#
define
_WINSOCK_DEPRECATED_NO_WARNINGS
#
include
<
algorithm
>
#
include
<
vector
>
#
include
<
stdarg
.
h
>
#
include
<
windef
.
h
>
#
include
<
winbase
.
h
>
#
include
<
wingdi
.
h
>
#
include
<
winuser
.
h
>
#
include
<
ole2
.
h
>
#
include
<
netcon
.
h
>
#
include
<
objbase
.
h
>
#
include
<
winsock2
.
h
>
#
include
<
ws2ipdef
.
h
>
#
include
<
tcpmib
.
h
>
#
include
<
iphlpapi
.
h
>
#
include
<
netioapi
.
h
>
#
include
<
netlistmgr
.
h
>
#
include
<
iprtrmib
.
h
>
#
include
"
plstr
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsNotifyAddrListener
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
mozilla
/
StaticPrefs_network
.
h
"
#
include
"
mozilla
/
SHA1
.
h
"
#
include
"
mozilla
/
Base64
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
<
iptypes
.
h
>
#
include
<
iphlpapi
.
h
>
using
namespace
mozilla
;
static
LazyLogModule
gNotifyAddrLog
(
"
nsNotifyAddr
"
)
;
#
define
LOG
(
args
)
MOZ_LOG
(
gNotifyAddrLog
mozilla
:
:
LogLevel
:
:
Debug
args
)
#
define
LOG_ENABLED
(
)
MOZ_LOG_TEST
(
gNotifyAddrLog
mozilla
:
:
LogLevel
:
:
Debug
)
static
const
unsigned
int
kNetworkChangeCoalescingPeriod
=
1000
;
NS_IMPL_ISUPPORTS
(
nsNotifyAddrListener
nsINetworkLinkService
nsIRunnable
nsIObserver
)
nsNotifyAddrListener
:
:
nsNotifyAddrListener
(
)
:
mLinkUp
(
true
)
mStatusKnown
(
false
)
mCheckAttempted
(
false
)
mMutex
(
"
nsNotifyAddrListener
:
:
mMutex
"
)
mCheckEvent
(
nullptr
)
mShutdown
(
false
)
mIPInterfaceChecksum
(
0
)
mCoalescingActive
(
false
)
{
}
nsNotifyAddrListener
:
:
~
nsNotifyAddrListener
(
)
{
NS_ASSERTION
(
!
mThread
"
nsNotifyAddrListener
thread
shutdown
failed
"
)
;
}
NS_IMETHODIMP
nsNotifyAddrListener
:
:
GetIsLinkUp
(
bool
*
aIsUp
)
{
if
(
!
mCheckAttempted
&
&
!
mStatusKnown
)
{
mCheckAttempted
=
true
;
CheckLinkStatus
(
)
;
}
*
aIsUp
=
mLinkUp
;
return
NS_OK
;
}
NS_IMETHODIMP
nsNotifyAddrListener
:
:
GetLinkStatusKnown
(
bool
*
aIsUp
)
{
*
aIsUp
=
mStatusKnown
;
return
NS_OK
;
}
NS_IMETHODIMP
nsNotifyAddrListener
:
:
GetLinkType
(
uint32_t
*
aLinkType
)
{
NS_ENSURE_ARG_POINTER
(
aLinkType
)
;
*
aLinkType
=
nsINetworkLinkService
:
:
LINK_TYPE_UNKNOWN
;
return
NS_OK
;
}
NS_IMETHODIMP
nsNotifyAddrListener
:
:
GetNetworkID
(
nsACString
&
aNetworkID
)
{
MutexAutoLock
lock
(
mMutex
)
;
aNetworkID
=
mNetworkId
;
return
NS_OK
;
}
NS_IMETHODIMP
nsNotifyAddrListener
:
:
GetDnsSuffixList
(
nsTArray
<
nsCString
>
&
aDnsSuffixList
)
{
aDnsSuffixList
.
Clear
(
)
;
MutexAutoLock
lock
(
mMutex
)
;
aDnsSuffixList
.
AppendElements
(
mDnsSuffixList
)
;
return
NS_OK
;
}
void
nsNotifyAddrListener
:
:
HashSortedNetworkIds
(
std
:
:
vector
<
GUID
>
nwGUIDS
SHA1Sum
&
sha1
)
{
std
:
:
sort
(
nwGUIDS
.
begin
(
)
nwGUIDS
.
end
(
)
[
]
(
const
GUID
&
a
const
GUID
&
b
)
{
return
memcmp
(
&
a
&
b
sizeof
(
GUID
)
)
<
0
;
}
)
;
for
(
auto
const
&
nwGUID
:
nwGUIDS
)
{
sha1
.
update
(
&
nwGUID
sizeof
(
GUID
)
)
;
if
(
LOG_ENABLED
(
)
)
{
nsPrintfCString
guid
(
"
%
08lX
%
04X
%
04X
%
02X
%
02X
%
02X
%
02X
%
02X
%
02X
%
02X
%
02X
%
lX
"
nwGUID
.
Data1
nwGUID
.
Data2
nwGUID
.
Data3
nwGUID
.
Data4
[
0
]
nwGUID
.
Data4
[
1
]
nwGUID
.
Data4
[
2
]
nwGUID
.
Data4
[
3
]
nwGUID
.
Data4
[
4
]
nwGUID
.
Data4
[
5
]
nwGUID
.
Data4
[
6
]
nwGUID
.
Data4
[
7
]
)
;
LOG
(
(
"
calculateNetworkId
:
interface
networkID
:
%
s
\
n
"
guid
.
get
(
)
)
)
;
}
}
}
void
nsNotifyAddrListener
:
:
calculateNetworkId
(
void
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
"
Must
not
be
called
on
the
main
thread
"
)
;
if
(
mShutdown
)
{
return
;
}
if
(
FAILED
(
CoInitializeEx
(
nullptr
COINIT_MULTITHREADED
)
)
)
{
return
;
}
auto
unitialize
=
MakeScopeExit
(
[
]
(
)
{
CoUninitialize
(
)
;
}
)
;
RefPtr
<
INetworkListManager
>
nlm
;
HRESULT
hr
=
CoCreateInstance
(
CLSID_NetworkListManager
nullptr
CLSCTX_ALL
IID_INetworkListManager
getter_AddRefs
(
nlm
)
)
;
if
(
NS_WARN_IF
(
FAILED
(
hr
)
)
)
{
LOG
(
(
"
CoCreateInstance
error
:
%
X
"
hr
)
)
;
return
;
}
RefPtr
<
IEnumNetworks
>
enumNetworks
;
hr
=
nlm
-
>
GetNetworks
(
NLM_ENUM_NETWORK_CONNECTED
getter_AddRefs
(
enumNetworks
)
)
;
if
(
NS_WARN_IF
(
FAILED
(
hr
)
)
)
{
LOG
(
(
"
GetNetworks
error
:
%
X
"
hr
)
)
;
return
;
}
SHA1Sum
sha1
;
std
:
:
vector
<
GUID
>
nwGUIDS
;
while
(
true
)
{
RefPtr
<
INetwork
>
network
;
hr
=
enumNetworks
-
>
Next
(
1
getter_AddRefs
(
network
)
nullptr
)
;
if
(
hr
!
=
S_OK
)
{
break
;
}
GUID
nwGUID
;
hr
=
network
-
>
GetNetworkId
(
&
nwGUID
)
;
if
(
hr
!
=
S_OK
)
{
continue
;
}
nwGUIDS
.
push_back
(
nwGUID
)
;
}
if
(
nwGUIDS
.
empty
(
)
)
{
MutexAutoLock
lock
(
mMutex
)
;
mNetworkId
.
Truncate
(
)
;
LOG
(
(
"
calculateNetworkId
:
no
network
ID
-
no
active
networks
"
)
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
NETWORK_ID2
0
)
;
return
;
}
nsAutoCString
output
;
SHA1Sum
:
:
Hash
digest
;
HashSortedNetworkIds
(
nwGUIDS
sha1
)
;
sha1
.
finish
(
digest
)
;
nsCString
newString
(
reinterpret_cast
<
char
*
>
(
digest
)
SHA1Sum
:
:
kHashSize
)
;
nsresult
rv
=
Base64Encode
(
newString
output
)
;
if
(
NS_FAILED
(
rv
)
)
{
{
MutexAutoLock
lock
(
mMutex
)
;
mNetworkId
.
Truncate
(
)
;
}
Telemetry
:
:
Accumulate
(
Telemetry
:
:
NETWORK_ID2
0
)
;
LOG
(
(
"
calculateNetworkId
:
no
network
ID
Base64Encode
error
%
X
"
rv
)
)
;
return
;
}
MutexAutoLock
lock
(
mMutex
)
;
if
(
output
!
=
mNetworkId
)
{
mNetworkId
=
output
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
NETWORK_ID2
1
)
;
LOG
(
(
"
calculateNetworkId
:
new
NetworkID
:
%
s
"
output
.
get
(
)
)
)
;
SendEvent
(
NS_NETWORK_LINK_DATA_NETWORKID_CHANGED
)
;
}
else
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
NETWORK_ID2
2
)
;
LOG
(
(
"
calculateNetworkId
:
same
NetworkID
:
%
s
"
output
.
get
(
)
)
)
;
}
}
static
void
WINAPI
OnInterfaceChange
(
PVOID
callerContext
PMIB_IPINTERFACE_ROW
row
MIB_NOTIFICATION_TYPE
notificationType
)
{
nsNotifyAddrListener
*
notify
=
static_cast
<
nsNotifyAddrListener
*
>
(
callerContext
)
;
notify
-
>
CheckLinkStatus
(
)
;
}
DWORD
nsNotifyAddrListener
:
:
nextCoalesceWaitTime
(
)
{
double
period
=
(
TimeStamp
:
:
Now
(
)
-
mChangeTime
)
.
ToMilliseconds
(
)
;
if
(
period
>
=
kNetworkChangeCoalescingPeriod
)
{
if
(
!
mNetworkChangeTime
.
IsNull
(
)
)
{
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
NETWORK_TIME_BETWEEN_NETWORK_CHANGE_EVENTS
mNetworkChangeTime
)
;
}
mNetworkChangeTime
=
TimeStamp
:
:
Now
(
)
;
SendEvent
(
NS_NETWORK_LINK_DATA_CHANGED
)
;
mCoalescingActive
=
false
;
return
INFINITE
;
}
else
{
return
static_cast
<
DWORD
>
(
kNetworkChangeCoalescingPeriod
-
period
)
;
}
}
NS_IMETHODIMP
nsNotifyAddrListener
:
:
Run
(
)
{
mStartTime
=
TimeStamp
:
:
Now
(
)
;
calculateNetworkId
(
)
;
DWORD
waitTime
=
INFINITE
;
HANDLE
interfacechange
;
DWORD
ret
=
NotifyIpInterfaceChange
(
StaticPrefs
:
:
network_notify_IPv6
(
)
?
AF_UNSPEC
:
AF_INET
(
PIPINTERFACE_CHANGE_CALLBACK
)
OnInterfaceChange
this
false
&
interfacechange
)
;
if
(
ret
=
=
NO_ERROR
)
{
do
{
ret
=
WaitForSingleObject
(
mCheckEvent
waitTime
)
;
if
(
!
mShutdown
)
{
waitTime
=
nextCoalesceWaitTime
(
)
;
}
else
{
break
;
}
}
while
(
ret
!
=
WAIT_FAILED
)
;
CancelMibChangeNotify2
(
interfacechange
)
;
}
else
{
LOG
(
(
"
Link
Monitor
:
NotifyIpInterfaceChange
returned
%
d
\
n
"
(
int
)
ret
)
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsNotifyAddrListener
:
:
Observe
(
nsISupports
*
subject
const
char
*
topic
const
char16_t
*
data
)
{
if
(
!
strcmp
(
"
xpcom
-
shutdown
-
threads
"
topic
)
)
Shutdown
(
)
;
return
NS_OK
;
}
nsresult
nsNotifyAddrListener
:
:
Init
(
void
)
{
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
!
observerService
)
return
NS_ERROR_FAILURE
;
nsresult
rv
=
observerService
-
>
AddObserver
(
this
"
xpcom
-
shutdown
-
threads
"
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mCheckEvent
=
CreateEvent
(
nullptr
FALSE
FALSE
nullptr
)
;
NS_ENSURE_TRUE
(
mCheckEvent
NS_ERROR_OUT_OF_MEMORY
)
;
nsCOMPtr
<
nsIThreadPool
>
threadPool
=
new
nsThreadPool
(
)
;
MOZ_ALWAYS_SUCCEEDS
(
threadPool
-
>
SetThreadLimit
(
1
)
)
;
MOZ_ALWAYS_SUCCEEDS
(
threadPool
-
>
SetThreadStackSize
(
nsIThreadManager
:
:
kThreadPoolStackSize
)
)
;
MOZ_ALWAYS_SUCCEEDS
(
threadPool
-
>
SetName
(
NS_LITERAL_CSTRING
(
"
Link
Monitor
"
)
)
)
;
mThread
=
threadPool
.
forget
(
)
;
return
mThread
-
>
Dispatch
(
this
NS_DISPATCH_NORMAL
)
;
}
nsresult
nsNotifyAddrListener
:
:
Shutdown
(
void
)
{
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
observerService
)
observerService
-
>
RemoveObserver
(
this
"
xpcom
-
shutdown
-
threads
"
)
;
if
(
!
mCheckEvent
)
return
NS_OK
;
mShutdown
=
true
;
SetEvent
(
mCheckEvent
)
;
nsresult
rv
=
mThread
?
mThread
-
>
ShutdownWithTimeout
(
2000
)
:
NS_OK
;
mThread
=
nullptr
;
CloseHandle
(
mCheckEvent
)
;
mCheckEvent
=
nullptr
;
return
rv
;
}
nsresult
nsNotifyAddrListener
:
:
NetworkChanged
(
)
{
if
(
mCoalescingActive
)
{
LOG
(
(
"
NetworkChanged
:
absorbed
an
event
(
coalescing
active
)
\
n
"
)
)
;
}
else
{
mChangeTime
=
TimeStamp
:
:
Now
(
)
;
mCoalescingActive
=
true
;
SetEvent
(
mCheckEvent
)
;
LOG
(
(
"
NetworkChanged
:
coalescing
period
started
\
n
"
)
)
;
}
return
NS_OK
;
}
nsresult
nsNotifyAddrListener
:
:
SendEvent
(
const
char
*
aEventID
)
{
if
(
!
aEventID
)
return
NS_ERROR_NULL_POINTER
;
LOG
(
(
"
SendEvent
:
network
is
'
%
s
'
\
n
"
aEventID
)
)
;
nsresult
rv
;
nsCOMPtr
<
nsIRunnable
>
event
=
new
ChangeEvent
(
this
aEventID
)
;
if
(
NS_FAILED
(
rv
=
NS_DispatchToMainThread
(
event
)
)
)
NS_WARNING
(
"
Failed
to
dispatch
ChangeEvent
"
)
;
return
rv
;
}
NS_IMETHODIMP
nsNotifyAddrListener
:
:
ChangeEvent
:
:
Run
(
)
{
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
observerService
)
observerService
-
>
NotifyObservers
(
mService
NS_NETWORK_LINK_TOPIC
NS_ConvertASCIItoUTF16
(
mEventID
)
.
get
(
)
)
;
return
NS_OK
;
}
DWORD
nsNotifyAddrListener
:
:
CheckAdaptersAddresses
(
void
)
{
ULONG
len
=
16384
;
PIP_ADAPTER_ADDRESSES
adapterList
=
(
PIP_ADAPTER_ADDRESSES
)
moz_xmalloc
(
len
)
;
ULONG
flags
=
GAA_FLAG_SKIP_DNS_SERVER
|
GAA_FLAG_SKIP_MULTICAST
|
GAA_FLAG_SKIP_ANYCAST
;
DWORD
ret
=
GetAdaptersAddresses
(
AF_UNSPEC
flags
nullptr
adapterList
&
len
)
;
if
(
ret
=
=
ERROR_BUFFER_OVERFLOW
)
{
free
(
adapterList
)
;
adapterList
=
static_cast
<
PIP_ADAPTER_ADDRESSES
>
(
moz_xmalloc
(
len
)
)
;
ret
=
GetAdaptersAddresses
(
AF_UNSPEC
flags
nullptr
adapterList
&
len
)
;
}
if
(
FAILED
(
CoInitializeEx
(
nullptr
COINIT_MULTITHREADED
)
)
)
{
free
(
adapterList
)
;
return
ERROR_NOT_SUPPORTED
;
}
ULONG
sumAll
=
0
;
nsTArray
<
nsCString
>
dnsSuffixList
;
if
(
ret
=
=
ERROR_SUCCESS
)
{
bool
linkUp
=
false
;
ULONG
sum
=
0
;
for
(
PIP_ADAPTER_ADDRESSES
adapter
=
adapterList
;
adapter
;
adapter
=
adapter
-
>
Next
)
{
if
(
adapter
-
>
OperStatus
!
=
IfOperStatusUp
|
|
!
adapter
-
>
FirstUnicastAddress
|
|
adapter
-
>
IfType
=
=
IF_TYPE_SOFTWARE_LOOPBACK
)
{
continue
;
}
sum
<
<
=
2
;
for
(
int
i
=
0
;
adapter
-
>
AdapterName
[
i
]
;
+
+
i
)
{
sum
+
=
adapter
-
>
AdapterName
[
i
]
;
}
for
(
PIP_ADAPTER_UNICAST_ADDRESS
pip
=
adapter
-
>
FirstUnicastAddress
;
pip
;
pip
=
pip
-
>
Next
)
{
SOCKET_ADDRESS
*
sockAddr
=
&
pip
-
>
Address
;
for
(
int
i
=
0
;
i
<
sockAddr
-
>
iSockaddrLength
;
+
+
i
)
{
sum
+
=
(
reinterpret_cast
<
unsigned
char
*
>
(
sockAddr
-
>
lpSockaddr
)
)
[
i
]
;
}
}
if
(
StaticPrefs
:
:
network_notify_dnsSuffixList
(
)
)
{
nsCString
suffix
=
NS_ConvertUTF16toUTF8
(
adapter
-
>
DnsSuffix
)
;
if
(
!
suffix
.
IsEmpty
(
)
)
{
LOG
(
(
"
found
DNS
suffix
=
%
s
\
n
"
suffix
.
get
(
)
)
)
;
dnsSuffixList
.
AppendElement
(
suffix
)
;
}
}
linkUp
=
true
;
sumAll
^
=
sum
;
}
mLinkUp
=
linkUp
;
mStatusKnown
=
true
;
}
free
(
adapterList
)
;
if
(
mLinkUp
)
{
mIPInterfaceChecksum
=
sumAll
;
}
CoUninitialize
(
)
;
if
(
StaticPrefs
:
:
network_notify_dnsSuffixList
(
)
)
{
MutexAutoLock
lock
(
mMutex
)
;
mDnsSuffixList
.
SwapElements
(
dnsSuffixList
)
;
}
calculateNetworkId
(
)
;
return
ret
;
}
void
nsNotifyAddrListener
:
:
CheckLinkStatus
(
void
)
{
DWORD
ret
;
const
char
*
event
;
bool
prevLinkUp
=
mLinkUp
;
ULONG
prevCsum
=
mIPInterfaceChecksum
;
LOG
(
(
"
check
status
of
all
network
adapters
\
n
"
)
)
;
if
(
NS_IsMainThread
(
)
)
{
NS_WARNING
(
"
CheckLinkStatus
called
on
main
thread
!
No
check
"
"
performed
.
Assuming
link
is
up
status
is
unknown
.
"
)
;
mLinkUp
=
true
;
if
(
!
mStatusKnown
)
{
event
=
NS_NETWORK_LINK_DATA_UNKNOWN
;
}
else
if
(
!
prevLinkUp
)
{
event
=
NS_NETWORK_LINK_DATA_UP
;
}
else
{
event
=
nullptr
;
}
if
(
event
)
{
SendEvent
(
event
)
;
}
}
else
{
ret
=
CheckAdaptersAddresses
(
)
;
if
(
ret
!
=
ERROR_SUCCESS
)
{
mLinkUp
=
true
;
}
if
(
mLinkUp
&
&
(
prevCsum
!
=
mIPInterfaceChecksum
)
)
{
TimeDuration
since
=
TimeStamp
:
:
Now
(
)
-
mStartTime
;
if
(
StaticPrefs
:
:
network_notify_changed
(
)
&
&
(
since
.
ToMilliseconds
(
)
>
2000
)
)
{
NetworkChanged
(
)
;
}
}
if
(
prevLinkUp
!
=
mLinkUp
)
{
SendEvent
(
mLinkUp
?
NS_NETWORK_LINK_DATA_UP
:
NS_NETWORK_LINK_DATA_DOWN
)
;
}
}
}
