#
ifndef
NETLINKSERVICE_H_
#
define
NETLINKSERVICE_H_
#
include
<
netinet
/
in
.
h
>
#
include
<
linux
/
netlink
.
h
>
#
include
"
nsIRunnable
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
mozilla
/
SHA1
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
mozilla
/
net
/
DNS
.
h
"
namespace
mozilla
{
namespace
net
{
class
NetlinkAddress
;
class
NetlinkNeighbor
;
class
NetlinkLink
;
class
NetlinkRoute
;
class
NetlinkMsg
;
class
NetlinkServiceListener
:
public
nsISupports
{
public
:
virtual
void
OnNetworkChanged
(
)
=
0
;
virtual
void
OnNetworkIDChanged
(
)
=
0
;
virtual
void
OnLinkUp
(
)
=
0
;
virtual
void
OnLinkDown
(
)
=
0
;
virtual
void
OnLinkStatusKnown
(
)
=
0
;
virtual
void
OnDnsSuffixListUpdated
(
)
=
0
;
protected
:
virtual
~
NetlinkServiceListener
(
)
=
default
;
}
;
class
NetlinkService
:
public
nsIRunnable
{
virtual
~
NetlinkService
(
)
;
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIRUNNABLE
NetlinkService
(
)
;
nsresult
Init
(
NetlinkServiceListener
*
aListener
)
;
nsresult
Shutdown
(
)
;
void
GetNetworkID
(
nsACString
&
aNetworkID
)
;
void
GetIsLinkUp
(
bool
*
aIsUp
)
;
nsresult
GetDnsSuffixList
(
nsTArray
<
nsCString
>
&
aDnsSuffixList
)
;
nsresult
GetResolvers
(
nsTArray
<
NetAddr
>
&
aResolvers
)
;
private
:
void
EnqueueGenMsg
(
uint16_t
aMsgType
uint8_t
aFamily
)
;
void
EnqueueRtMsg
(
uint8_t
aFamily
void
*
aAddress
)
;
void
RemovePendingMsg
(
)
;
mozilla
:
:
Mutex
mMutex
{
"
NetlinkService
:
:
mMutex
"
}
;
void
OnNetlinkMessage
(
int
aNetlinkSocket
)
;
void
OnLinkMessage
(
struct
nlmsghdr
*
aNlh
)
;
void
OnAddrMessage
(
struct
nlmsghdr
*
aNlh
)
;
void
OnRouteMessage
(
struct
nlmsghdr
*
aNlh
)
;
void
OnNeighborMessage
(
struct
nlmsghdr
*
aNlh
)
;
void
OnRouteCheckResult
(
struct
nlmsghdr
*
aNlh
)
;
void
UpdateLinkStatus
(
)
;
void
TriggerNetworkIDCalculation
(
)
;
int
GetPollWait
(
)
;
void
GetGWNeighboursForFamily
(
uint8_t
aFamily
nsTArray
<
NetlinkNeighbor
*
>
&
aGwNeighbors
)
;
bool
CalculateIDForFamily
(
uint8_t
aFamily
mozilla
:
:
SHA1Sum
*
aSHA1
)
;
void
CalculateNetworkID
(
)
;
void
ExtractDNSProperties
(
)
;
nsCOMPtr
<
nsIThread
>
mThread
;
bool
mInitialScanFinished
{
false
}
;
int
mShutdownPipe
[
2
]
{
-
1
-
1
}
;
struct
in_addr
mRouteCheckIPv4
{
}
;
struct
in6_addr
mRouteCheckIPv6
{
}
;
pid_t
mPid
;
uint32_t
mMsgId
{
0
}
;
bool
mLinkUp
{
true
}
;
bool
mRecalculateNetworkId
{
false
}
;
bool
mSendNetworkChangeEvent
{
false
}
;
mozilla
:
:
TimeStamp
mTriggerTime
;
nsCString
mNetworkId
;
nsTArray
<
nsCString
>
mDNSSuffixList
;
nsTArray
<
NetAddr
>
mDNSResolvers
;
class
LinkInfo
{
public
:
explicit
LinkInfo
(
UniquePtr
<
NetlinkLink
>
&
&
aLink
)
;
virtual
~
LinkInfo
(
)
;
bool
UpdateStatus
(
)
;
UniquePtr
<
NetlinkLink
>
mLink
;
nsTArray
<
UniquePtr
<
NetlinkAddress
>
>
mAddresses
;
nsClassHashtable
<
nsCStringHashKey
NetlinkNeighbor
>
mNeighbors
;
nsTArray
<
UniquePtr
<
NetlinkRoute
>
>
mDefaultRoutes
;
bool
mIsUp
;
}
;
bool
CalculateIDForEthernetLink
(
uint8_t
aFamily
NetlinkRoute
*
aRouteCheckResult
uint32_t
aRouteCheckIfIdx
LinkInfo
*
aRouteCheckLinkInfo
mozilla
:
:
SHA1Sum
*
aSHA1
)
;
bool
CalculateIDForNonEthernetLink
(
uint8_t
aFamily
NetlinkRoute
*
aRouteCheckResult
nsTArray
<
nsCString
>
&
aLinkNamesToHash
uint32_t
aRouteCheckIfIdx
LinkInfo
*
aRouteCheckLinkInfo
mozilla
:
:
SHA1Sum
*
aSHA1
)
;
nsClassHashtable
<
nsUint32HashKey
LinkInfo
>
mLinks
;
UniquePtr
<
NetlinkRoute
>
mIPv4RouteCheckResult
;
UniquePtr
<
NetlinkRoute
>
mIPv6RouteCheckResult
;
nsTArray
<
UniquePtr
<
NetlinkMsg
>
>
mOutgoingMessages
;
RefPtr
<
NetlinkServiceListener
>
mListener
;
}
;
}
}
#
endif
