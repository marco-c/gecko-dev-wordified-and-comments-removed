#
ifndef
mozilla_net_ChannelClassifierService_h
#
define
mozilla_net_ChannelClassifierService_h
#
include
"
nsIChannelClassifierService
.
h
"
#
include
"
mozilla
/
net
/
UrlClassifierCommon
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsTArray
.
h
"
namespace
mozilla
{
namespace
net
{
enum
class
ChannelBlockDecision
{
Blocked
Replaced
Allowed
}
;
class
UrlClassifierBlockedChannel
final
:
public
nsIUrlClassifierBlockedChannel
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIURLCLASSIFIERBLOCKEDCHANNEL
explicit
UrlClassifierBlockedChannel
(
nsIChannel
*
aChannel
)
;
bool
IsUnblocked
(
)
const
{
return
mDecision
!
=
ChannelBlockDecision
:
:
Blocked
;
}
ChannelBlockDecision
GetDecision
(
)
{
return
mDecision
;
}
;
void
SetReason
(
const
nsACString
&
aFeatureName
const
nsACString
&
aTableName
)
;
protected
:
~
UrlClassifierBlockedChannel
(
)
=
default
;
private
:
nsCOMPtr
<
nsIChannel
>
mChannel
;
ChannelBlockDecision
mDecision
;
uint8_t
mReason
;
nsCString
mTables
;
}
;
class
ChannelClassifierService
final
:
public
nsIChannelClassifierService
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSICHANNELCLASSIFIERSERVICE
friend
class
UrlClassifierBlockedChannel
;
static
already_AddRefed
<
nsIChannelClassifierService
>
GetSingleton
(
)
;
static
ChannelBlockDecision
OnBeforeBlockChannel
(
nsIChannel
*
aChannel
const
nsACString
&
aFeatureName
const
nsACString
&
aTableName
)
;
nsresult
OnBeforeBlockChannel
(
nsIChannel
*
aChannel
const
nsACString
&
aFeatureName
const
nsACString
&
aTableName
ChannelBlockDecision
&
aDecision
)
;
bool
HasListener
(
)
const
{
return
!
mListeners
.
IsEmpty
(
)
;
}
private
:
ChannelClassifierService
(
)
;
~
ChannelClassifierService
(
)
=
default
;
nsTArray
<
nsCOMPtr
<
nsIObserver
>
>
mListeners
;
}
;
}
}
#
endif
