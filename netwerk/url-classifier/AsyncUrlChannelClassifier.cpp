#
include
"
mozilla
/
ErrorNames
.
h
"
#
include
"
mozilla
/
net
/
AsyncUrlChannelClassifier
.
h
"
#
include
"
mozilla
/
net
/
UrlClassifierCommon
.
h
"
#
include
"
mozilla
/
net
/
UrlClassifierFeatureFactory
.
h
"
#
include
"
mozilla
/
net
/
UrlClassifierFeatureResult
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIChannel
.
h
"
#
include
"
nsIHttpChannel
.
h
"
#
include
"
nsIHttpChannelInternal
.
h
"
#
include
"
nsIURIClassifier
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsNetUtil
.
h
"
namespace
mozilla
{
namespace
net
{
namespace
{
struct
FeatureTask
{
nsCOMPtr
<
nsIURI
>
mURI
;
nsTArray
<
RefPtr
<
nsIUrlClassifierFeature
>
>
mFeatures
;
}
;
nsresult
GetFeatureTasks
(
nsIChannel
*
aChannel
const
nsTArray
<
nsCOMPtr
<
nsIUrlClassifierFeature
>
>
&
aFeatures
nsIUrlClassifierFeature
:
:
listType
aListType
nsTArray
<
FeatureTask
>
&
aTasks
)
{
MOZ_ASSERT
(
!
aFeatures
.
IsEmpty
(
)
)
;
for
(
nsIUrlClassifierFeature
*
feature
:
aFeatures
)
{
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
feature
-
>
GetURIByListType
(
aChannel
aListType
getter_AddRefs
(
uri
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
|
|
!
uri
)
{
if
(
UC_LOG_ENABLED
(
)
)
{
nsAutoCString
errorName
;
GetErrorName
(
rv
errorName
)
;
UC_LOG
(
(
"
GetFeatureTasks
got
an
unexpected
error
(
rv
=
%
s
)
while
trying
to
"
"
create
a
whitelist
URI
.
Allowing
tracker
.
"
errorName
.
get
(
)
)
)
;
}
return
rv
;
}
MOZ_ASSERT
(
uri
)
;
bool
found
=
false
;
for
(
FeatureTask
&
task
:
aTasks
)
{
bool
equal
=
false
;
rv
=
task
.
mURI
-
>
Equals
(
uri
&
equal
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
equal
)
{
task
.
mFeatures
.
AppendElement
(
feature
)
;
found
=
true
;
break
;
}
}
if
(
!
found
)
{
FeatureTask
*
task
=
aTasks
.
AppendElement
(
)
;
task
-
>
mURI
=
uri
;
task
-
>
mFeatures
.
AppendElement
(
feature
)
;
}
}
return
NS_OK
;
}
nsresult
TrackerFound
(
const
nsTArray
<
RefPtr
<
nsIUrlClassifierFeatureResult
>
>
&
aResults
nsIChannel
*
aChannel
const
std
:
:
function
<
void
(
)
>
&
aCallback
)
{
for
(
nsIUrlClassifierFeatureResult
*
result
:
aResults
)
{
UrlClassifierFeatureResult
*
r
=
static_cast
<
UrlClassifierFeatureResult
*
>
(
result
)
;
bool
shouldContinue
=
false
;
nsresult
rv
=
r
-
>
Feature
(
)
-
>
ProcessChannel
(
aChannel
r
-
>
List
(
)
&
shouldContinue
)
;
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
;
if
(
!
shouldContinue
)
{
break
;
}
}
aCallback
(
)
;
return
NS_OK
;
}
class
WhitelistClassifierCallback
final
:
public
nsIUrlClassifierFeatureCallback
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIURLCLASSIFIERFEATURECALLBACK
WhitelistClassifierCallback
(
nsIChannel
*
aChannel
const
nsTArray
<
RefPtr
<
nsIUrlClassifierFeatureResult
>
>
&
aBlacklistResults
std
:
:
function
<
void
(
)
>
&
aCallback
)
:
mChannel
(
aChannel
)
mTaskCount
(
0
)
mBlacklistResults
(
aBlacklistResults
)
mChannelCallback
(
aCallback
)
{
MOZ_ASSERT
(
mChannel
)
;
MOZ_ASSERT
(
!
mBlacklistResults
.
IsEmpty
(
)
)
;
}
void
SetTaskCount
(
uint32_t
aTaskCount
)
{
MOZ_ASSERT
(
aTaskCount
>
0
)
;
mTaskCount
=
aTaskCount
;
}
private
:
~
WhitelistClassifierCallback
(
)
=
default
;
nsresult
OnClassifyCompleteInternal
(
)
;
nsCOMPtr
<
nsIChannel
>
mChannel
;
nsCOMPtr
<
nsIURI
>
mURI
;
uint32_t
mTaskCount
;
nsTArray
<
RefPtr
<
nsIUrlClassifierFeatureResult
>
>
mBlacklistResults
;
std
:
:
function
<
void
(
)
>
mChannelCallback
;
nsTArray
<
RefPtr
<
nsIUrlClassifierFeatureResult
>
>
mWhitelistResults
;
}
;
NS_IMPL_ISUPPORTS
(
WhitelistClassifierCallback
nsIUrlClassifierFeatureCallback
)
NS_IMETHODIMP
WhitelistClassifierCallback
:
:
OnClassifyComplete
(
const
nsTArray
<
RefPtr
<
nsIUrlClassifierFeatureResult
>
>
&
aWhitelistResults
)
{
MOZ_ASSERT
(
mTaskCount
>
0
)
;
UC_LOG
(
(
"
WhitelistClassifierCallback
[
%
p
]
:
OnClassifyComplete
channel
=
%
p
"
this
mChannel
.
get
(
)
)
)
;
mWhitelistResults
.
AppendElements
(
aWhitelistResults
)
;
if
(
-
-
mTaskCount
)
{
return
NS_OK
;
}
return
OnClassifyCompleteInternal
(
)
;
}
nsresult
WhitelistClassifierCallback
:
:
OnClassifyCompleteInternal
(
)
{
nsTArray
<
RefPtr
<
nsIUrlClassifierFeatureResult
>
>
remainingResults
;
for
(
nsIUrlClassifierFeatureResult
*
blacklistResult
:
mBlacklistResults
)
{
UrlClassifierFeatureResult
*
result
=
static_cast
<
UrlClassifierFeatureResult
*
>
(
blacklistResult
)
;
nsIUrlClassifierFeature
*
blacklistFeature
=
result
-
>
Feature
(
)
;
MOZ_ASSERT
(
blacklistFeature
)
;
bool
found
=
false
;
for
(
nsIUrlClassifierFeatureResult
*
whitelistResult
:
mWhitelistResults
)
{
if
(
static_cast
<
UrlClassifierFeatureResult
*
>
(
whitelistResult
)
-
>
Feature
(
)
=
=
blacklistFeature
)
{
found
=
true
;
break
;
}
}
if
(
found
)
{
continue
;
}
nsAutoCString
skipList
;
nsresult
rv
=
blacklistFeature
-
>
GetSkipHostList
(
skipList
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
continue
;
}
if
(
nsContentUtils
:
:
IsURIInList
(
result
-
>
URI
(
)
skipList
)
)
{
if
(
UC_LOG_ENABLED
(
)
)
{
UC_LOG
(
(
"
WhitelistClassifierCallback
[
%
p
]
:
:
OnClassifyComplete
uri
found
in
"
"
skiplist
"
this
)
)
;
}
continue
;
}
remainingResults
.
AppendElement
(
blacklistResult
)
;
}
if
(
remainingResults
.
IsEmpty
(
)
)
{
if
(
UC_LOG_ENABLED
(
)
)
{
UC_LOG
(
(
"
WhitelistClassifierCallback
[
%
p
]
:
:
OnClassifyComplete
uri
fully
"
"
whitelisted
"
this
)
)
;
}
mChannelCallback
(
)
;
return
NS_OK
;
}
if
(
UC_LOG_ENABLED
(
)
)
{
UC_LOG
(
(
"
WhitelistClassifierCallback
[
%
p
]
:
:
OnClassifyComplete
channel
[
%
p
]
"
"
should
not
be
whitelisted
"
this
mChannel
.
get
(
)
)
)
;
}
return
TrackerFound
(
remainingResults
mChannel
mChannelCallback
)
;
}
class
BlacklistClassifierCallback
final
:
public
nsIUrlClassifierFeatureCallback
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIURLCLASSIFIERFEATURECALLBACK
BlacklistClassifierCallback
(
nsIChannel
*
aChannel
std
:
:
function
<
void
(
)
>
&
&
aCallback
)
:
mChannel
(
aChannel
)
mTaskCount
(
0
)
mChannelCallback
(
std
:
:
move
(
aCallback
)
)
{
MOZ_ASSERT
(
mChannel
)
;
}
void
SetTaskCount
(
uint32_t
aTaskCount
)
{
MOZ_ASSERT
(
aTaskCount
>
0
)
;
mTaskCount
=
aTaskCount
;
}
private
:
~
BlacklistClassifierCallback
(
)
=
default
;
nsresult
OnClassifyCompleteInternal
(
)
;
nsCOMPtr
<
nsIChannel
>
mChannel
;
uint32_t
mTaskCount
;
std
:
:
function
<
void
(
)
>
mChannelCallback
;
nsTArray
<
RefPtr
<
nsIUrlClassifierFeatureResult
>
>
mResults
;
}
;
NS_IMPL_ISUPPORTS
(
BlacklistClassifierCallback
nsIUrlClassifierFeatureCallback
)
NS_IMETHODIMP
BlacklistClassifierCallback
:
:
OnClassifyComplete
(
const
nsTArray
<
RefPtr
<
nsIUrlClassifierFeatureResult
>
>
&
aResults
)
{
MOZ_ASSERT
(
mTaskCount
>
0
)
;
UC_LOG
(
(
"
BlacklistClassifierCallback
[
%
p
]
:
OnClassifyComplete
-
remaining
%
d
"
this
mTaskCount
)
)
;
mResults
.
AppendElements
(
aResults
)
;
if
(
-
-
mTaskCount
)
{
return
NS_OK
;
}
return
OnClassifyCompleteInternal
(
)
;
}
nsresult
BlacklistClassifierCallback
:
:
OnClassifyCompleteInternal
(
)
{
if
(
mResults
.
IsEmpty
(
)
)
{
if
(
UC_LOG_ENABLED
(
)
)
{
UC_LOG
(
(
"
BlacklistClassifierCallback
[
%
p
]
:
:
OnClassifyComplete
uri
not
found
"
"
in
blacklist
"
this
)
)
;
}
mChannelCallback
(
)
;
return
NS_OK
;
}
if
(
UC_LOG_ENABLED
(
)
)
{
UC_LOG
(
(
"
BlacklistClassifierCallback
[
%
p
]
:
:
OnClassifyComplete
uri
is
in
"
"
blacklist
.
Start
checking
whitelist
.
"
this
)
)
;
}
nsTArray
<
nsCOMPtr
<
nsIUrlClassifierFeature
>
>
features
;
for
(
nsIUrlClassifierFeatureResult
*
result
:
mResults
)
{
features
.
AppendElement
(
static_cast
<
UrlClassifierFeatureResult
*
>
(
result
)
-
>
Feature
(
)
)
;
}
nsTArray
<
FeatureTask
>
tasks
;
nsresult
rv
=
GetFeatureTasks
(
mChannel
features
nsIUrlClassifierFeature
:
:
whitelist
tasks
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
TrackerFound
(
mResults
mChannel
mChannelCallback
)
;
}
if
(
tasks
.
IsEmpty
(
)
)
{
UC_LOG
(
(
"
BlacklistClassifierCallback
[
%
p
]
:
OnClassifyComplete
could
not
create
"
"
a
whitelist
URI
.
Ignoring
whitelist
.
"
this
)
)
;
return
TrackerFound
(
mResults
mChannel
mChannelCallback
)
;
}
RefPtr
<
WhitelistClassifierCallback
>
callback
=
new
WhitelistClassifierCallback
(
mChannel
mResults
mChannelCallback
)
;
nsCOMPtr
<
nsIURIClassifier
>
uriClassifier
=
do_GetService
(
NS_URICLASSIFIERSERVICE_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
uint32_t
pendingCallbacks
=
0
;
for
(
FeatureTask
&
task
:
tasks
)
{
rv
=
uriClassifier
-
>
AsyncClassifyLocalWithFeatures
(
task
.
mURI
task
.
mFeatures
nsIUrlClassifierFeature
:
:
whitelist
callback
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
if
(
UC_LOG_ENABLED
(
)
)
{
nsAutoCString
errorName
;
GetErrorName
(
rv
errorName
)
;
UC_LOG
(
(
"
BlacklistClassifierCallback
[
%
p
]
:
OnClassifyComplete
Failed
"
"
calling
AsyncClassifyLocalWithFeatures
with
rv
=
%
s
.
Let
'
s
move
on
.
"
this
errorName
.
get
(
)
)
)
;
}
continue
;
}
+
+
pendingCallbacks
;
}
if
(
pendingCallbacks
=
=
0
)
{
if
(
UC_LOG_ENABLED
(
)
)
{
UC_LOG
(
(
"
BlacklistClassifierCallback
[
%
p
]
:
OnClassifyComplete
All
"
"
AsyncClassifyLocalWithFeatures
(
)
calls
return
errors
.
We
cannot
"
"
continue
.
"
this
)
)
;
}
return
TrackerFound
(
mResults
mChannel
mChannelCallback
)
;
}
callback
-
>
SetTaskCount
(
pendingCallbacks
)
;
return
NS_OK
;
}
}
nsresult
AsyncUrlChannelClassifier
:
:
CheckChannel
(
nsIChannel
*
aChannel
std
:
:
function
<
void
(
)
>
&
&
aCallback
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
aChannel
)
;
if
(
!
aCallback
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsTArray
<
nsCOMPtr
<
nsIUrlClassifierFeature
>
>
features
;
UrlClassifierFeatureFactory
:
:
GetFeaturesFromChannel
(
aChannel
features
)
;
if
(
features
.
IsEmpty
(
)
)
{
UC_LOG
(
(
"
AsyncUrlChannelClassifier
:
Nothing
to
do
for
channel
%
p
"
aChannel
)
)
;
return
NS_ERROR_FAILURE
;
}
nsTArray
<
FeatureTask
>
tasks
;
nsresult
rv
=
GetFeatureTasks
(
aChannel
features
nsIUrlClassifierFeature
:
:
blacklist
tasks
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
|
|
tasks
.
IsEmpty
(
)
)
{
return
rv
;
}
MOZ_ASSERT
(
!
tasks
.
IsEmpty
(
)
)
;
nsCOMPtr
<
nsIURIClassifier
>
uriClassifier
=
do_GetService
(
NS_URICLASSIFIERSERVICE_CONTRACTID
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
RefPtr
<
BlacklistClassifierCallback
>
callback
=
new
BlacklistClassifierCallback
(
aChannel
std
:
:
move
(
aCallback
)
)
;
uint32_t
pendingCallbacks
=
0
;
for
(
FeatureTask
&
task
:
tasks
)
{
if
(
UC_LOG_ENABLED
(
)
)
{
nsCString
spec
=
task
.
mURI
-
>
GetSpecOrDefault
(
)
;
spec
.
Truncate
(
std
:
:
min
(
spec
.
Length
(
)
UrlClassifierCommon
:
:
sMaxSpecLength
)
)
;
UC_LOG
(
(
"
AsyncUrlChannelClassifier
:
Checking
blacklist
for
uri
=
%
s
\
n
"
spec
.
get
(
)
)
)
;
}
rv
=
uriClassifier
-
>
AsyncClassifyLocalWithFeatures
(
task
.
mURI
task
.
mFeatures
nsIUrlClassifierFeature
:
:
blacklist
callback
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
continue
;
}
+
+
pendingCallbacks
;
}
if
(
pendingCallbacks
=
=
0
)
{
return
NS_ERROR_FAILURE
;
}
callback
-
>
SetTaskCount
(
pendingCallbacks
)
;
return
NS_OK
;
}
}
}
