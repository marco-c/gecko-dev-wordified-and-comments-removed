#
ifndef
NETWERK_SCTP_DATACHANNEL_DATACHANNEL_H_
#
define
NETWERK_SCTP_DATACHANNEL_DATACHANNEL_H_
#
include
<
map
>
#
include
<
memory
>
#
include
<
string
>
#
include
<
vector
>
#
include
<
errno
.
h
>
#
include
"
nsISupports
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
mozilla
/
StopGapEventTarget
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
WeakPtr
.
h
"
#
include
"
mozilla
/
dom
/
RTCStatsReportBinding
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsDeque
.
h
"
#
include
"
mozilla
/
dom
/
Blob
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
DataChannelProtocol
.
h
"
#
include
"
mozilla
/
net
/
NeckoTargetHolder
.
h
"
#
include
"
MediaEventSource
.
h
"
#
include
"
transport
/
transportlayer
.
h
"
namespace
mozilla
{
class
DataChannelConnection
;
class
DataChannel
;
class
MediaPacket
;
class
MediaTransportHandler
;
namespace
dom
{
class
RTCDataChannel
;
struct
RTCStatsCollection
;
}
;
enum
class
DataChannelConnectionState
{
Connecting
Open
Closed
}
;
enum
class
DataChannelReliabilityPolicy
{
Reliable
LimitedRetransmissions
LimitedLifetime
}
;
class
DataChannelMessageMetadata
{
public
:
DataChannelMessageMetadata
(
uint16_t
aStreamId
uint32_t
aPpid
bool
aUnordered
Maybe
<
uint16_t
>
aMaxRetransmissions
=
Nothing
(
)
Maybe
<
uint16_t
>
aMaxLifetimeMs
=
Nothing
(
)
)
:
mStreamId
(
aStreamId
)
mPpid
(
aPpid
)
mUnordered
(
aUnordered
)
mMaxRetransmissions
(
aMaxRetransmissions
)
mMaxLifetimeMs
(
aMaxLifetimeMs
)
{
}
DataChannelMessageMetadata
(
const
DataChannelMessageMetadata
&
aOrig
)
=
default
;
DataChannelMessageMetadata
(
DataChannelMessageMetadata
&
&
aOrig
)
=
default
;
DataChannelMessageMetadata
&
operator
=
(
const
DataChannelMessageMetadata
&
aOrig
)
=
default
;
DataChannelMessageMetadata
&
operator
=
(
DataChannelMessageMetadata
&
&
aOrig
)
=
default
;
uint16_t
mStreamId
;
uint32_t
mPpid
;
bool
mUnordered
;
Maybe
<
uint16_t
>
mMaxRetransmissions
;
Maybe
<
uint16_t
>
mMaxLifetimeMs
;
}
;
class
OutgoingMsg
{
public
:
OutgoingMsg
(
nsACString
&
&
data
const
DataChannelMessageMetadata
&
aMetadata
)
;
OutgoingMsg
(
OutgoingMsg
&
&
aOrig
)
=
default
;
OutgoingMsg
&
operator
=
(
OutgoingMsg
&
&
aOrig
)
=
default
;
OutgoingMsg
(
const
OutgoingMsg
&
)
=
delete
;
OutgoingMsg
&
operator
=
(
const
OutgoingMsg
&
)
=
delete
;
void
Advance
(
size_t
offset
)
;
const
DataChannelMessageMetadata
&
GetMetadata
(
)
const
{
return
mMetadata
;
}
;
size_t
GetLength
(
)
const
{
return
mData
.
Length
(
)
;
}
;
Span
<
const
uint8_t
>
GetRemainingData
(
)
const
{
auto
span
=
Span
<
const
uint8_t
>
(
mData
)
;
return
span
.
From
(
mPos
)
;
}
protected
:
nsCString
mData
;
DataChannelMessageMetadata
mMetadata
;
size_t
mPos
=
0
;
}
;
class
IncomingMsg
{
public
:
explicit
IncomingMsg
(
uint32_t
aPpid
uint16_t
aStreamId
)
:
mPpid
(
aPpid
)
mStreamId
(
aStreamId
)
{
}
IncomingMsg
(
IncomingMsg
&
&
aOrig
)
=
default
;
IncomingMsg
&
operator
=
(
IncomingMsg
&
&
aOrig
)
=
default
;
IncomingMsg
(
const
IncomingMsg
&
)
=
delete
;
IncomingMsg
&
operator
=
(
const
IncomingMsg
&
)
=
delete
;
void
Append
(
const
uint8_t
*
aData
size_t
aLen
)
{
mData
.
Append
(
(
const
char
*
)
aData
aLen
)
;
}
const
nsCString
&
GetData
(
)
const
{
return
mData
;
}
nsCString
&
GetData
(
)
{
return
mData
;
}
size_t
GetLength
(
)
const
{
return
mData
.
Length
(
)
;
}
;
uint16_t
GetStreamId
(
)
const
{
return
mStreamId
;
}
uint32_t
GetPpid
(
)
const
{
return
mPpid
;
}
protected
:
nsCString
mData
;
uint32_t
mPpid
;
uint16_t
mStreamId
;
}
;
typedef
MozPromise
<
dom
:
:
RTCDataChannelStats
nsresult
true
>
DataChannelStatsPromise
;
class
DataChannelConnection
:
public
net
:
:
NeckoTargetHolder
{
friend
class
DataChannel
;
friend
class
DataChannelConnectRunnable
;
friend
class
DataChannelConnectionUsrsctp
;
protected
:
virtual
~
DataChannelConnection
(
)
;
public
:
enum
class
PendingType
{
None
Dcep
Data
}
;
class
DataConnectionListener
:
public
SupportsWeakPtr
{
public
:
virtual
~
DataConnectionListener
(
)
=
default
;
virtual
void
NotifyDataChannel
(
already_AddRefed
<
DataChannel
>
aChannel
const
nsACString
&
aLabel
bool
aOrdered
mozilla
:
:
dom
:
:
Nullable
<
uint16_t
>
aMaxLifeTime
mozilla
:
:
dom
:
:
Nullable
<
uint16_t
>
aMaxRetransmits
const
nsACString
&
aProtocol
bool
aNegotiated
)
=
0
;
virtual
void
NotifyDataChannelOpen
(
DataChannel
*
aChannel
)
=
0
;
virtual
void
NotifyDataChannelClosed
(
DataChannel
*
aChannel
)
=
0
;
virtual
void
NotifySctpConnected
(
)
=
0
;
virtual
void
NotifySctpClosed
(
)
=
0
;
}
;
static
Maybe
<
RefPtr
<
DataChannelConnection
>
>
Create
(
DataConnectionListener
*
aListener
nsISerialEventTarget
*
aTarget
MediaTransportHandler
*
aHandler
const
uint16_t
aLocalPort
const
uint16_t
aNumStreams
)
;
DataChannelConnection
(
const
DataChannelConnection
&
)
=
delete
;
DataChannelConnection
(
DataChannelConnection
&
&
)
=
delete
;
DataChannelConnection
&
operator
=
(
const
DataChannelConnection
&
)
=
delete
;
DataChannelConnection
&
operator
=
(
DataChannelConnection
&
&
)
=
delete
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
DataChannelConnection
)
virtual
bool
Init
(
const
uint16_t
aLocalPort
const
uint16_t
aNumStreams
)
=
0
;
virtual
void
OnTransportReady
(
)
=
0
;
virtual
void
OnStreamOpen
(
uint16_t
stream
)
=
0
;
virtual
bool
RaiseStreamLimitTo
(
uint16_t
aNewLimit
)
=
0
;
virtual
int
SendMessage
(
DataChannel
&
aChannel
OutgoingMsg
&
&
aMsg
)
=
0
;
virtual
void
OnSctpPacketReceived
(
const
MediaPacket
&
packet
)
=
0
;
virtual
void
ResetStreams
(
nsTArray
<
uint16_t
>
&
aStreams
)
=
0
;
virtual
void
Destroy
(
)
;
void
SetMaxMessageSize
(
uint64_t
aMaxMessageSize
)
;
double
GetMaxMessageSize
(
)
;
void
HandleDataMessage
(
IncomingMsg
&
&
aMsg
)
;
void
HandleDCEPMessage
(
IncomingMsg
&
&
aMsg
)
;
void
ProcessQueuedOpens
(
)
;
void
OnStreamsReset
(
std
:
:
vector
<
uint16_t
>
&
&
aStreams
)
;
typedef
DataChannelStatsPromise
:
:
AllPromiseType
StatsPromise
;
RefPtr
<
StatsPromise
>
GetStats
(
const
DOMHighResTimeStamp
aTimestamp
)
const
;
bool
ConnectToTransport
(
const
std
:
:
string
&
aTransportId
const
bool
aClient
const
uint16_t
aLocalPort
const
uint16_t
aRemotePort
)
;
void
TransportStateChange
(
const
std
:
:
string
&
aTransportId
TransportLayer
:
:
State
aState
)
;
void
SetSignals
(
const
std
:
:
string
&
aTransportId
)
;
[
[
nodiscard
]
]
already_AddRefed
<
DataChannel
>
Open
(
const
nsACString
&
label
const
nsACString
&
protocol
DataChannelReliabilityPolicy
prPolicy
bool
inOrder
uint32_t
prValue
bool
aExternalNegotiated
uint16_t
aStream
)
;
void
FinishClose
(
DataChannel
*
aChannel
)
;
void
FinishClose_s
(
DataChannel
*
aChannel
)
;
void
CloseAll
(
)
;
void
CloseAll_s
(
)
;
int
SendMessage
(
uint16_t
stream
nsACString
&
&
aMsg
)
{
return
SendDataMessage
(
stream
std
:
:
move
(
aMsg
)
false
)
;
}
int
SendBinaryMessage
(
uint16_t
stream
nsACString
&
&
aMsg
)
{
return
SendDataMessage
(
stream
std
:
:
move
(
aMsg
)
true
)
;
}
int
SendBlob
(
uint16_t
stream
nsIInputStream
*
aBlob
)
;
void
ReadBlob
(
already_AddRefed
<
DataChannelConnection
>
aThis
uint16_t
aStream
nsIInputStream
*
aBlob
)
;
bool
InShutdown
(
)
const
{
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
return
mShutdown
;
#
else
return
false
;
#
endif
}
protected
:
class
Channels
{
public
:
using
ChannelArray
=
AutoTArray
<
RefPtr
<
DataChannel
>
16
>
;
Channels
(
)
:
mMutex
(
"
DataChannelConnection
:
:
Channels
:
:
mMutex
"
)
{
}
Channels
(
const
Channels
&
)
=
delete
;
Channels
(
Channels
&
&
)
=
delete
;
Channels
&
operator
=
(
const
Channels
&
)
=
delete
;
Channels
&
operator
=
(
Channels
&
&
)
=
delete
;
void
Insert
(
const
RefPtr
<
DataChannel
>
&
aChannel
)
;
bool
Remove
(
const
RefPtr
<
DataChannel
>
&
aChannel
)
;
RefPtr
<
DataChannel
>
Get
(
uint16_t
aId
)
const
;
ChannelArray
GetAll
(
)
const
{
MutexAutoLock
lock
(
mMutex
)
;
return
mChannels
.
Clone
(
)
;
}
RefPtr
<
DataChannel
>
GetNextChannel
(
uint16_t
aCurrentId
)
const
;
private
:
struct
IdComparator
{
bool
Equals
(
const
RefPtr
<
DataChannel
>
&
aChannel
uint16_t
aId
)
const
;
bool
LessThan
(
const
RefPtr
<
DataChannel
>
&
aChannel
uint16_t
aId
)
const
;
bool
Equals
(
const
RefPtr
<
DataChannel
>
&
a1
const
RefPtr
<
DataChannel
>
&
a2
)
const
;
bool
LessThan
(
const
RefPtr
<
DataChannel
>
&
a1
const
RefPtr
<
DataChannel
>
&
a2
)
const
;
}
;
mutable
Mutex
mMutex
;
ChannelArray
mChannels
MOZ_GUARDED_BY
(
mMutex
)
;
}
;
DataChannelConnection
(
DataConnectionListener
*
aListener
nsISerialEventTarget
*
aTarget
MediaTransportHandler
*
aHandler
)
;
int
SendDataMessage
(
uint16_t
aStream
nsACString
&
&
aMsg
bool
aIsBinary
)
;
DataChannelConnectionState
GetState
(
)
const
{
MOZ_ASSERT
(
mSTS
-
>
IsOnCurrentThread
(
)
)
;
return
mState
;
}
void
SetState
(
DataChannelConnectionState
aState
)
;
static
void
DTLSConnectThread
(
void
*
data
)
;
void
SendPacket
(
std
:
:
unique_ptr
<
MediaPacket
>
&
&
packet
)
;
void
OnPacketReceived
(
const
std
:
:
string
&
aTransportId
const
MediaPacket
&
packet
)
;
already_AddRefed
<
DataChannel
>
FindChannelByStream
(
uint16_t
stream
)
;
uint16_t
FindFreeStream
(
)
const
;
int
SendControlMessage
(
DataChannel
&
aChannel
const
uint8_t
*
data
uint32_t
len
)
;
int
SendOpenAckMessage
(
DataChannel
&
aChannel
)
;
int
SendOpenRequestMessage
(
DataChannel
&
aChannel
)
;
void
OpenFinish
(
RefPtr
<
DataChannel
>
aChannel
)
;
void
ClearResets
(
)
;
void
MarkStreamForReset
(
DataChannel
&
aChannel
)
;
void
HandleUnknownMessage
(
uint32_t
ppid
uint32_t
length
uint16_t
stream
)
;
void
HandleOpenRequestMessage
(
const
struct
rtcweb_datachannel_open_request
*
req
uint32_t
length
uint16_t
stream
)
;
void
HandleOpenAckMessage
(
const
struct
rtcweb_datachannel_ack
*
ack
uint32_t
length
uint16_t
stream
)
;
bool
ReassembleMessageChunk
(
IncomingMsg
&
aReassembled
const
void
*
buffer
size_t
length
uint32_t
ppid
uint16_t
stream
)
;
WeakPtr
<
DataConnectionListener
>
mListener
;
uint64_t
mMaxMessageSize
=
WEBRTC_DATACHANNEL_MAX_MESSAGE_SIZE_REMOTE_DEFAULT
;
nsTArray
<
uint16_t
>
mStreamIds
;
Maybe
<
bool
>
mAllocateEven
;
nsCOMPtr
<
nsIThread
>
mInternalIOThread
=
nullptr
;
bool
mSendInterleaved
=
false
;
uint32_t
mCurrentStream
=
0
;
std
:
:
set
<
RefPtr
<
DataChannel
>
>
mPending
;
uint16_t
mNegotiatedIdLimit
=
0
;
PendingType
mPendingType
=
PendingType
:
:
None
;
nsTArray
<
OutgoingMsg
>
mBufferedControl
;
Maybe
<
IncomingMsg
>
mRecvBuffer
;
bool
mSctpConfigured
=
false
;
std
:
:
string
mTransportId
;
bool
mConnectedToTransportHandler
=
false
;
RefPtr
<
MediaTransportHandler
>
mTransportHandler
;
MediaEventListener
mPacketReceivedListener
;
MediaEventListener
mStateChangeListener
;
AutoTArray
<
uint16_t
4
>
mStreamsResetting
;
DataChannelConnectionState
mState
=
DataChannelConnectionState
:
:
Closed
;
Channels
mChannels
;
uintptr_t
mId
=
0
;
uint16_t
mLocalPort
=
0
;
uint16_t
mRemotePort
=
0
;
nsCOMPtr
<
nsISerialEventTarget
>
mSTS
;
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
bool
mShutdown
=
false
;
#
endif
}
;
class
DataChannel
{
friend
class
DataChannelConnection
;
friend
class
DataChannelConnectionUsrsctp
;
public
:
DataChannel
(
DataChannelConnection
*
connection
uint16_t
stream
const
nsACString
&
label
const
nsACString
&
protocol
DataChannelReliabilityPolicy
policy
uint32_t
value
bool
ordered
bool
negotiated
)
;
DataChannel
(
const
DataChannel
&
)
=
delete
;
DataChannel
(
DataChannel
&
&
)
=
delete
;
DataChannel
&
operator
=
(
const
DataChannel
&
)
=
delete
;
DataChannel
&
operator
=
(
DataChannel
&
&
)
=
delete
;
private
:
~
DataChannel
(
)
;
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
DataChannel
)
void
SetMainthreadDomDataChannel
(
dom
:
:
RTCDataChannel
*
aChannel
)
;
void
OnWorkerTransferStarted
(
)
;
void
OnWorkerTransferComplete
(
dom
:
:
RTCDataChannel
*
aChannel
)
;
void
OnWorkerTransferDisabled
(
)
;
void
UnsetMainthreadDomDataChannel
(
)
;
void
UnsetWorkerDomDataChannel
(
)
;
static
void
SendErrnoToErrorResult
(
int
error
size_t
aMessageSize
ErrorResult
&
aRv
)
;
int
SendMsg
(
nsACString
&
&
aMsg
)
;
int
SendBinaryMsg
(
nsACString
&
&
aMsg
)
;
int
SendBinaryBlob
(
nsIInputStream
*
aBlob
)
;
void
DecrementBufferedAmount
(
size_t
aSize
)
;
void
AnnounceOpen
(
)
;
void
AnnounceClosed
(
)
;
void
GracefulClose
(
)
;
Maybe
<
uint16_t
>
GetStream
(
)
const
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mStream
=
=
INVALID_STREAM
)
{
return
Nothing
(
)
;
}
return
Some
(
mStream
)
;
}
void
SetStream
(
uint16_t
aId
)
;
void
SetMaxMessageSize
(
double
aMaxMessageSize
)
;
double
GetMaxMessageSize
(
)
const
{
return
mConnection
-
>
GetMaxMessageSize
(
)
;
}
void
OnMessageReceived
(
nsCString
&
&
aMsg
bool
aIsBinary
)
;
RefPtr
<
DataChannelStatsPromise
>
GetStats
(
const
DOMHighResTimeStamp
aTimestamp
)
;
void
FinishClose
(
)
;
dom
:
:
RTCDataChannel
*
GetDomDataChannel
(
)
const
{
MOZ_ASSERT
(
mDomEventTarget
-
>
IsOnCurrentThread
(
)
)
;
if
(
NS_IsMainThread
(
)
)
{
return
mMainthreadDomDataChannel
;
}
return
mWorkerDomDataChannel
;
}
private
:
nsresult
AddDataToBinaryMsg
(
const
char
*
data
uint32_t
size
)
;
const
nsCString
mLabel
;
const
nsCString
mProtocol
;
const
DataChannelReliabilityPolicy
mPrPolicy
;
const
uint32_t
mPrValue
;
const
bool
mNegotiated
;
const
bool
mOrdered
;
dom
:
:
RTCDataChannel
*
mMainthreadDomDataChannel
=
nullptr
;
bool
mHasWorkerDomDataChannel
=
false
;
bool
mEverOpened
=
false
;
uint16_t
mStream
;
RefPtr
<
DataChannelConnection
>
mConnection
;
bool
mWaitingForAck
=
false
;
nsTArray
<
OutgoingMsg
>
mBufferedData
;
std
:
:
map
<
uint16_t
IncomingMsg
>
mRecvBuffers
;
const
RefPtr
<
StopGapEventTarget
>
mDomEventTarget
;
dom
:
:
RTCDataChannel
*
mWorkerDomDataChannel
=
nullptr
;
}
;
static
constexpr
const
char
*
ToString
(
DataChannelConnectionState
state
)
{
switch
(
state
)
{
case
DataChannelConnectionState
:
:
Connecting
:
return
"
CONNECTING
"
;
case
DataChannelConnectionState
:
:
Open
:
return
"
OPEN
"
;
case
DataChannelConnectionState
:
:
Closed
:
return
"
CLOSED
"
;
}
return
"
"
;
}
;
static
constexpr
const
char
*
ToString
(
DataChannelConnection
:
:
PendingType
type
)
{
switch
(
type
)
{
case
DataChannelConnection
:
:
PendingType
:
:
None
:
return
"
NONE
"
;
case
DataChannelConnection
:
:
PendingType
:
:
Dcep
:
return
"
DCEP
"
;
case
DataChannelConnection
:
:
PendingType
:
:
Data
:
return
"
DATA
"
;
}
return
"
"
;
}
;
static
constexpr
const
char
*
ToString
(
DataChannelReliabilityPolicy
type
)
{
switch
(
type
)
{
case
DataChannelReliabilityPolicy
:
:
Reliable
:
return
"
RELIABLE
"
;
case
DataChannelReliabilityPolicy
:
:
LimitedRetransmissions
:
return
"
LIMITED_RETRANSMISSIONS
"
;
case
DataChannelReliabilityPolicy
:
:
LimitedLifetime
:
return
"
LIMITED_LIFETIME
"
;
}
return
"
"
;
}
;
}
#
endif
