#
ifndef
NETWERK_SCTP_DATACHANNEL_DATACHANNEL_H_
#
define
NETWERK_SCTP_DATACHANNEL_DATACHANNEL_H_
#
include
<
memory
>
#
include
<
string
>
#
include
<
vector
>
#
include
<
errno
.
h
>
#
include
"
nsISupports
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
WeakPtr
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsDeque
.
h
"
#
include
"
mozilla
/
dom
/
Blob
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
DataChannelProtocol
.
h
"
#
include
"
DataChannelListener
.
h
"
#
include
"
mozilla
/
net
/
NeckoTargetHolder
.
h
"
#
include
"
MediaEventSource
.
h
"
#
include
"
transport
/
transportlayer
.
h
"
#
ifndef
EALREADY
#
define
EALREADY
WSAEALREADY
#
endif
extern
"
C
"
{
struct
socket
;
struct
sctp_rcvinfo
;
}
namespace
mozilla
{
class
DataChannelConnection
;
class
DataChannel
;
class
DataChannelOnMessageAvailable
;
class
MediaPacket
;
class
MediaTransportHandler
;
namespace
dom
{
struct
RTCStatsCollection
;
}
;
enum
class
DataChannelState
{
Connecting
Open
Closing
Closed
}
;
enum
class
DataChannelConnectionState
{
Connecting
Open
Closed
}
;
enum
class
DataChannelReliabilityPolicy
{
Reliable
LimitedRetransmissions
LimitedLifetime
}
;
class
DataChannelMessageMetadata
{
public
:
DataChannelMessageMetadata
(
uint16_t
aStreamId
uint32_t
aPpid
bool
aUnordered
Maybe
<
uint16_t
>
aMaxRetransmissions
=
Nothing
(
)
Maybe
<
uint16_t
>
aMaxLifetimeMs
=
Nothing
(
)
)
:
mStreamId
(
aStreamId
)
mPpid
(
aPpid
)
mUnordered
(
aUnordered
)
mMaxRetransmissions
(
aMaxRetransmissions
)
mMaxLifetimeMs
(
aMaxLifetimeMs
)
{
}
DataChannelMessageMetadata
(
const
DataChannelMessageMetadata
&
aOrig
)
=
default
;
DataChannelMessageMetadata
(
DataChannelMessageMetadata
&
&
aOrig
)
=
default
;
DataChannelMessageMetadata
&
operator
=
(
const
DataChannelMessageMetadata
&
aOrig
)
=
default
;
DataChannelMessageMetadata
&
operator
=
(
DataChannelMessageMetadata
&
&
aOrig
)
=
default
;
uint16_t
mStreamId
;
uint32_t
mPpid
;
bool
mUnordered
;
Maybe
<
uint16_t
>
mMaxRetransmissions
;
Maybe
<
uint16_t
>
mMaxLifetimeMs
;
}
;
class
OutgoingMsg
{
public
:
OutgoingMsg
(
nsACString
&
&
data
const
DataChannelMessageMetadata
&
aMetadata
)
;
OutgoingMsg
(
OutgoingMsg
&
&
aOrig
)
=
default
;
OutgoingMsg
&
operator
=
(
OutgoingMsg
&
&
aOrig
)
=
default
;
OutgoingMsg
(
const
OutgoingMsg
&
)
=
delete
;
OutgoingMsg
&
operator
=
(
const
OutgoingMsg
&
)
=
delete
;
void
Advance
(
size_t
offset
)
;
const
DataChannelMessageMetadata
&
GetMetadata
(
)
const
{
return
mMetadata
;
}
;
size_t
GetLength
(
)
const
{
return
mData
.
Length
(
)
;
}
;
Span
<
const
uint8_t
>
GetRemainingData
(
)
const
{
auto
span
=
Span
<
const
uint8_t
>
(
mData
)
;
return
span
.
From
(
mPos
)
;
}
protected
:
nsCString
mData
;
DataChannelMessageMetadata
mMetadata
;
size_t
mPos
=
0
;
}
;
class
IncomingMsg
{
public
:
explicit
IncomingMsg
(
uint32_t
aPpid
uint16_t
aStreamId
)
:
mPpid
(
aPpid
)
mStreamId
(
aStreamId
)
{
}
IncomingMsg
(
IncomingMsg
&
&
aOrig
)
=
default
;
IncomingMsg
&
operator
=
(
IncomingMsg
&
&
aOrig
)
=
default
;
IncomingMsg
(
const
IncomingMsg
&
)
=
delete
;
IncomingMsg
&
operator
=
(
const
IncomingMsg
&
)
=
delete
;
void
Append
(
const
uint8_t
*
aData
size_t
aLen
)
{
mData
.
Append
(
(
const
char
*
)
aData
aLen
)
;
}
const
nsCString
&
GetData
(
)
const
{
return
mData
;
}
nsCString
&
GetData
(
)
{
return
mData
;
}
size_t
GetLength
(
)
const
{
return
mData
.
Length
(
)
;
}
;
uint16_t
GetStreamId
(
)
const
{
return
mStreamId
;
}
uint32_t
GetPpid
(
)
const
{
return
mPpid
;
}
protected
:
nsCString
mData
;
uint32_t
mPpid
;
uint16_t
mStreamId
;
}
;
class
QueuedDataMessage
{
public
:
QueuedDataMessage
(
uint16_t
stream
uint32_t
ppid
uint16_t
messageId
int
flags
const
uint8_t
*
data
uint32_t
length
)
:
mStream
(
stream
)
mPpid
(
ppid
)
mMessageId
(
messageId
)
mFlags
(
flags
)
mData
(
data
length
)
{
}
const
uint16_t
mStream
;
const
uint32_t
mPpid
;
const
uint16_t
mMessageId
;
const
int
mFlags
;
const
nsTArray
<
uint8_t
>
mData
;
}
;
class
DataChannelConnection
:
public
net
:
:
NeckoTargetHolder
{
friend
class
DataChannel
;
friend
class
DataChannelOnMessageAvailable
;
friend
class
DataChannelConnectRunnable
;
virtual
~
DataChannelConnection
(
)
;
public
:
enum
class
PendingType
{
None
Dcep
Data
}
;
class
DataConnectionListener
:
public
SupportsWeakPtr
{
public
:
virtual
~
DataConnectionListener
(
)
=
default
;
virtual
void
NotifyDataChannel
(
already_AddRefed
<
DataChannel
>
channel
)
=
0
;
virtual
void
NotifyDataChannelOpen
(
DataChannel
*
aChannel
)
=
0
;
virtual
void
NotifyDataChannelClosed
(
DataChannel
*
aChannel
)
=
0
;
virtual
void
NotifySctpConnected
(
)
=
0
;
virtual
void
NotifySctpClosed
(
)
=
0
;
}
;
static
Maybe
<
RefPtr
<
DataChannelConnection
>
>
Create
(
DataConnectionListener
*
aListener
nsISerialEventTarget
*
aTarget
MediaTransportHandler
*
aHandler
const
uint16_t
aLocalPort
const
uint16_t
aNumStreams
const
Maybe
<
uint64_t
>
&
aMaxMessageSize
)
;
DataChannelConnection
(
const
DataChannelConnection
&
)
=
delete
;
DataChannelConnection
(
DataChannelConnection
&
&
)
=
delete
;
DataChannelConnection
&
operator
=
(
const
DataChannelConnection
&
)
=
delete
;
DataChannelConnection
&
operator
=
(
DataChannelConnection
&
&
)
=
delete
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
DataChannelConnection
)
void
Destroy
(
)
;
void
DestroyOnSTS
(
)
;
virtual
bool
RaiseStreamLimitTo
(
uint16_t
aNewLimit
)
;
virtual
void
ResetStreams
(
nsTArray
<
uint16_t
>
&
aStreams
)
;
int
SendMessage
(
DataChannel
&
aChannel
OutgoingMsg
&
&
aMsg
)
MOZ_REQUIRES
(
mLock
)
;
void
SetMaxMessageSize
(
bool
aMaxMessageSizeSet
uint64_t
aMaxMessageSize
)
;
uint64_t
GetMaxMessageSize
(
)
;
void
HandleDataMessage
(
IncomingMsg
&
&
aMsg
)
MOZ_REQUIRES
(
mLock
)
;
void
HandleDCEPMessage
(
IncomingMsg
&
&
aMsg
)
MOZ_REQUIRES
(
mLock
)
;
void
OnStreamsReset
(
std
:
:
vector
<
uint16_t
>
&
&
aStreams
)
MOZ_REQUIRES
(
mLock
)
;
void
AppendStatsToReport
(
const
UniquePtr
<
dom
:
:
RTCStatsCollection
>
&
aReport
const
DOMHighResTimeStamp
aTimestamp
)
const
;
bool
ConnectToTransport
(
const
std
:
:
string
&
aTransportId
const
bool
aClient
const
uint16_t
aLocalPort
const
uint16_t
aRemotePort
)
;
void
TransportStateChange
(
const
std
:
:
string
&
aTransportId
TransportLayer
:
:
State
aState
)
;
void
CompleteConnect
(
)
MOZ_REQUIRES
(
mLock
)
;
void
SetSignals
(
const
std
:
:
string
&
aTransportId
)
;
[
[
nodiscard
]
]
already_AddRefed
<
DataChannel
>
Open
(
const
nsACString
&
label
const
nsACString
&
protocol
DataChannelReliabilityPolicy
prPolicy
bool
inOrder
uint32_t
prValue
DataChannelListener
*
aListener
nsISupports
*
aContext
bool
aExternalNegotiated
uint16_t
aStream
)
;
void
Stop
(
)
;
void
Close
(
DataChannel
*
aChannel
)
;
void
GracefulClose
(
DataChannel
*
aChannel
)
;
void
FinishClose
(
DataChannel
*
aChannel
)
;
void
FinishClose_s
(
DataChannel
*
aChannel
)
MOZ_REQUIRES
(
mLock
)
;
void
CloseAll
(
)
;
int
SendMessage
(
uint16_t
stream
nsACString
&
&
aMsg
)
{
return
SendDataMessage
(
stream
std
:
:
move
(
aMsg
)
false
)
;
}
int
SendBinaryMessage
(
uint16_t
stream
nsACString
&
&
aMsg
)
{
return
SendDataMessage
(
stream
std
:
:
move
(
aMsg
)
true
)
;
}
int
SendBlob
(
uint16_t
stream
nsIInputStream
*
aBlob
)
;
int
ReceiveCallback
(
struct
socket
*
sock
void
*
data
size_t
datalen
struct
sctp_rcvinfo
rcv
int
flags
)
;
void
ReadBlob
(
already_AddRefed
<
DataChannelConnection
>
aThis
uint16_t
aStream
nsIInputStream
*
aBlob
)
;
void
SendDeferredMessages
(
)
MOZ_REQUIRES
(
mLock
)
;
int
SctpDtlsOutput
(
void
*
addr
void
*
buffer
size_t
length
uint8_t
tos
uint8_t
set_df
)
;
bool
InShutdown
(
)
const
{
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
return
mShutdown
;
#
else
return
false
;
#
endif
}
private
:
class
Channels
{
public
:
using
ChannelArray
=
AutoTArray
<
RefPtr
<
DataChannel
>
16
>
;
Channels
(
)
:
mMutex
(
"
DataChannelConnection
:
:
Channels
:
:
mMutex
"
)
{
}
Channels
(
const
Channels
&
)
=
delete
;
Channels
(
Channels
&
&
)
=
delete
;
Channels
&
operator
=
(
const
Channels
&
)
=
delete
;
Channels
&
operator
=
(
Channels
&
&
)
=
delete
;
void
Insert
(
const
RefPtr
<
DataChannel
>
&
aChannel
)
;
bool
Remove
(
const
RefPtr
<
DataChannel
>
&
aChannel
)
;
RefPtr
<
DataChannel
>
Get
(
uint16_t
aId
)
const
;
ChannelArray
GetAll
(
)
const
{
MutexAutoLock
lock
(
mMutex
)
;
return
mChannels
.
Clone
(
)
;
}
RefPtr
<
DataChannel
>
GetNextChannel
(
uint16_t
aCurrentId
)
const
;
private
:
struct
IdComparator
{
bool
Equals
(
const
RefPtr
<
DataChannel
>
&
aChannel
uint16_t
aId
)
const
;
bool
LessThan
(
const
RefPtr
<
DataChannel
>
&
aChannel
uint16_t
aId
)
const
;
bool
Equals
(
const
RefPtr
<
DataChannel
>
&
a1
const
RefPtr
<
DataChannel
>
&
a2
)
const
;
bool
LessThan
(
const
RefPtr
<
DataChannel
>
&
a1
const
RefPtr
<
DataChannel
>
&
a2
)
const
;
}
;
mutable
Mutex
mMutex
;
ChannelArray
mChannels
MOZ_GUARDED_BY
(
mMutex
)
;
}
;
DataChannelConnection
(
DataConnectionListener
*
aListener
nsISerialEventTarget
*
aTarget
MediaTransportHandler
*
aHandler
)
;
int
SendDataMessage
(
uint16_t
aStream
nsACString
&
&
aMsg
bool
aIsBinary
)
;
bool
Init
(
const
uint16_t
aLocalPort
const
uint16_t
aNumStreams
const
Maybe
<
uint64_t
>
&
aMaxMessageSize
)
;
DataChannelConnectionState
GetState
(
)
const
{
MOZ_ASSERT
(
mSTS
-
>
IsOnCurrentThread
(
)
)
;
return
mState
;
}
void
SetState
(
DataChannelConnectionState
aState
)
;
static
int
OnThresholdEvent
(
struct
socket
*
sock
uint32_t
sb_free
void
*
ulp_info
)
;
static
void
DTLSConnectThread
(
void
*
data
)
;
void
SendPacket
(
std
:
:
unique_ptr
<
MediaPacket
>
&
&
packet
)
;
void
SctpDtlsInput
(
const
std
:
:
string
&
aTransportId
const
MediaPacket
&
packet
)
;
DataChannel
*
FindChannelByStream
(
uint16_t
stream
)
MOZ_REQUIRES
(
mLock
)
;
uint16_t
FindFreeStream
(
)
const
MOZ_REQUIRES
(
mLock
)
;
uint32_t
UpdateCurrentStreamIndex
(
)
MOZ_REQUIRES
(
mLock
)
;
uint32_t
GetCurrentStreamIndex
(
)
MOZ_REQUIRES
(
mLock
)
;
int
SendControlMessage
(
DataChannel
&
aChannel
const
uint8_t
*
data
uint32_t
len
)
MOZ_REQUIRES
(
mLock
)
;
int
SendOpenAckMessage
(
DataChannel
&
aChannel
)
MOZ_REQUIRES
(
mLock
)
;
int
SendOpenRequestMessage
(
DataChannel
&
aChannel
)
MOZ_REQUIRES
(
mLock
)
;
bool
SendBufferedMessages
(
nsTArray
<
OutgoingMsg
>
&
buffer
size_t
*
aWritten
)
MOZ_REQUIRES
(
mLock
)
;
int
SendMsgInternal
(
OutgoingMsg
&
msg
size_t
*
aWritten
)
MOZ_REQUIRES
(
mLock
)
;
int
SendMsgInternalOrBuffer
(
nsTArray
<
OutgoingMsg
>
&
buffer
OutgoingMsg
&
&
msg
bool
*
buffered
size_t
*
aWritten
)
MOZ_REQUIRES
(
mLock
)
;
int
SendDataMsgInternalOrBuffer
(
DataChannel
&
channel
const
uint8_t
*
data
size_t
len
uint32_t
ppid
)
MOZ_REQUIRES
(
mLock
)
;
int
SendDataMsg
(
DataChannel
&
channel
const
uint8_t
*
data
size_t
len
uint32_t
ppidPartial
uint32_t
ppidFinal
)
MOZ_REQUIRES
(
mLock
)
;
void
DeliverQueuedData
(
uint16_t
stream
)
MOZ_REQUIRES
(
mLock
)
;
void
OpenFinish
(
RefPtr
<
DataChannel
>
aChannel
)
MOZ_REQUIRES
(
mLock
)
;
void
ProcessQueuedOpens
(
)
MOZ_REQUIRES
(
mLock
)
;
void
ClearResets
(
)
MOZ_REQUIRES
(
mLock
)
;
void
MarkStreamForReset
(
DataChannel
&
aChannel
)
MOZ_REQUIRES
(
mLock
)
;
void
HandleOpenRequestMessage
(
const
struct
rtcweb_datachannel_open_request
*
req
uint32_t
length
uint16_t
stream
)
MOZ_REQUIRES
(
mLock
)
;
void
HandleOpenAckMessage
(
const
struct
rtcweb_datachannel_ack
*
ack
uint32_t
length
uint16_t
stream
)
;
void
HandleUnknownMessage
(
uint32_t
ppid
uint32_t
length
uint16_t
stream
)
MOZ_REQUIRES
(
mLock
)
;
uint8_t
BufferMessage
(
nsACString
&
recvBuffer
const
void
*
data
uint32_t
length
uint32_t
ppid
int
flags
)
;
void
HandleDataMessage
(
const
void
*
data
size_t
length
uint32_t
ppid
uint16_t
stream
int
flags
)
MOZ_REQUIRES
(
mLock
)
;
void
HandleDCEPMessage
(
const
void
*
buffer
size_t
length
uint32_t
ppid
uint16_t
stream
int
flags
)
MOZ_REQUIRES
(
mLock
)
;
void
HandleMessage
(
const
void
*
buffer
size_t
length
uint32_t
ppid
uint16_t
stream
int
flags
)
MOZ_REQUIRES
(
mLock
)
;
void
HandleAssociationChangeEvent
(
const
struct
sctp_assoc_change
*
sac
)
MOZ_REQUIRES
(
mLock
)
;
void
HandlePeerAddressChangeEvent
(
const
struct
sctp_paddr_change
*
spc
)
MOZ_REQUIRES
(
mLock
)
;
void
HandleRemoteErrorEvent
(
const
struct
sctp_remote_error
*
sre
)
MOZ_REQUIRES
(
mLock
)
;
void
HandleShutdownEvent
(
const
struct
sctp_shutdown_event
*
sse
)
MOZ_REQUIRES
(
mLock
)
;
void
HandleAdaptationIndication
(
const
struct
sctp_adaptation_event
*
sai
)
MOZ_REQUIRES
(
mLock
)
;
void
HandlePartialDeliveryEvent
(
const
struct
sctp_pdapi_event
*
spde
)
MOZ_REQUIRES
(
mLock
)
;
void
HandleSendFailedEvent
(
const
struct
sctp_send_failed_event
*
ssfe
)
MOZ_REQUIRES
(
mLock
)
;
void
HandleStreamResetEvent
(
const
struct
sctp_stream_reset_event
*
strrst
)
MOZ_REQUIRES
(
mLock
)
;
void
HandleStreamChangeEvent
(
const
struct
sctp_stream_change_event
*
strchg
)
MOZ_REQUIRES
(
mLock
)
;
void
HandleNotification
(
const
union
sctp_notification
*
notif
size_t
n
)
MOZ_REQUIRES
(
mLock
)
;
bool
ReassembleMessageChunk
(
IncomingMsg
&
aReassembled
const
void
*
buffer
size_t
length
uint32_t
ppid
uint16_t
stream
)
;
void
HandleMessageChunk
(
const
void
*
buffer
size_t
length
uint32_t
ppid
uint16_t
messageId
uint16_t
stream
int
flags
)
;
void
HandleDataMessageChunk
(
const
void
*
data
size_t
length
uint32_t
ppid
uint16_t
stream
uint16_t
messageId
int
flags
)
;
void
HandleDCEPMessageChunk
(
const
void
*
buffer
size_t
length
uint32_t
ppid
uint16_t
stream
int
flags
)
;
mutable
Mutex
mLock
;
WeakPtr
<
DataConnectionListener
>
mListener
;
bool
mMaxMessageSizeSet
=
false
;
uint64_t
mMaxMessageSize
=
0
;
nsTArray
<
uint16_t
>
mStreamIds
;
Maybe
<
bool
>
mAllocateEven
;
nsCOMPtr
<
nsIThread
>
mInternalIOThread
=
nullptr
;
bool
mSendInterleaved
=
false
;
uint32_t
mCurrentStream
=
0
;
std
:
:
set
<
RefPtr
<
DataChannel
>
>
mPending
;
uint16_t
mNegotiatedIdLimit
=
0
;
PendingType
mPendingType
=
PendingType
:
:
None
;
nsTArray
<
UniquePtr
<
QueuedDataMessage
>
>
mQueuedData
;
nsTArray
<
OutgoingMsg
>
mBufferedControl
;
Maybe
<
IncomingMsg
>
mRecvBuffer
MOZ_GUARDED_BY
(
mLock
)
;
bool
mSctpConfigured
=
false
;
std
:
:
string
mTransportId
;
bool
mConnectedToTransportHandler
=
false
;
RefPtr
<
MediaTransportHandler
>
mTransportHandler
;
MediaEventListener
mPacketReceivedListener
;
MediaEventListener
mStateChangeListener
;
AutoTArray
<
uint16_t
4
>
mStreamsResetting
;
DataChannelConnectionState
mState
=
DataChannelConnectionState
:
:
Closed
;
Channels
mChannels
;
struct
socket
*
mSocket
=
nullptr
;
uintptr_t
mId
=
0
;
uint16_t
mLocalPort
=
0
;
uint16_t
mRemotePort
=
0
;
nsCOMPtr
<
nsISerialEventTarget
>
mSTS
;
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
bool
mShutdown
=
false
;
#
endif
}
;
class
DataChannel
{
friend
class
DataChannelOnMessageAvailable
;
friend
class
DataChannelConnection
;
public
:
struct
TrafficCounters
{
uint32_t
mMessagesSent
=
0
;
uint64_t
mBytesSent
=
0
;
uint32_t
mMessagesReceived
=
0
;
uint64_t
mBytesReceived
=
0
;
}
;
DataChannel
(
DataChannelConnection
*
connection
uint16_t
stream
DataChannelState
state
const
nsACString
&
label
const
nsACString
&
protocol
DataChannelReliabilityPolicy
policy
uint32_t
value
bool
ordered
bool
negotiated
DataChannelListener
*
aListener
nsISupports
*
aContext
)
;
DataChannel
(
const
DataChannel
&
)
=
delete
;
DataChannel
(
DataChannel
&
&
)
=
delete
;
DataChannel
&
operator
=
(
const
DataChannel
&
)
=
delete
;
DataChannel
&
operator
=
(
DataChannel
&
&
)
=
delete
;
private
:
~
DataChannel
(
)
;
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
DataChannel
)
void
ReleaseConnection
(
)
;
void
Close
(
)
;
void
SetListener
(
DataChannelListener
*
aListener
nsISupports
*
aContext
)
;
static
void
SendErrnoToErrorResult
(
int
error
size_t
aMessageSize
ErrorResult
&
aRv
)
;
void
SendMsg
(
nsACString
&
&
aMsg
ErrorResult
&
aRv
)
;
void
SendBinaryMsg
(
nsACString
&
&
aMsg
ErrorResult
&
aRv
)
;
void
SendBinaryBlob
(
dom
:
:
Blob
&
aBlob
ErrorResult
&
aRv
)
;
DataChannelReliabilityPolicy
GetType
(
)
const
{
return
mPrPolicy
;
}
dom
:
:
Nullable
<
uint16_t
>
GetMaxPacketLifeTime
(
)
const
;
dom
:
:
Nullable
<
uint16_t
>
GetMaxRetransmits
(
)
const
;
bool
GetNegotiated
(
)
const
{
return
mNegotiated
;
}
bool
GetOrdered
(
)
const
{
return
mOrdered
;
}
void
IncrementBufferedAmount
(
uint32_t
aSize
ErrorResult
&
aRv
)
;
void
DecrementBufferedAmount
(
uint32_t
aSize
)
;
uint32_t
GetBufferedAmount
(
)
const
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
mBufferedAmount
;
}
uint32_t
GetBufferedAmountLowThreshold
(
)
const
;
void
SetBufferedAmountLowThreshold
(
uint32_t
aThreshold
)
;
void
AnnounceOpen
(
)
;
void
AnnounceClosed
(
)
;
DataChannelState
GetReadyState
(
)
const
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
mReadyState
;
}
void
SetReadyState
(
DataChannelState
aState
)
;
void
GetLabel
(
nsAString
&
aLabel
)
{
CopyUTF8toUTF16
(
mLabel
aLabel
)
;
}
void
GetProtocol
(
nsAString
&
aProtocol
)
{
CopyUTF8toUTF16
(
mProtocol
aProtocol
)
;
}
uint16_t
GetStream
(
)
const
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
mStream
;
}
void
SendOrQueue
(
DataChannelOnMessageAvailable
*
aMessage
)
;
TrafficCounters
GetTrafficCounters
(
)
const
;
private
:
nsresult
AddDataToBinaryMsg
(
const
char
*
data
uint32_t
size
)
;
bool
EnsureValidStream
(
ErrorResult
&
aRv
)
;
void
WithTrafficCounters
(
const
std
:
:
function
<
void
(
TrafficCounters
&
)
>
&
)
;
DataChannelListener
*
mListener
;
nsCOMPtr
<
nsISupports
>
mContext
;
bool
mEverOpened
=
false
;
const
nsCString
mLabel
;
const
nsCString
mProtocol
;
DataChannelState
mReadyState
;
uint16_t
mStream
;
const
DataChannelReliabilityPolicy
mPrPolicy
;
const
uint32_t
mPrValue
;
size_t
mBufferedThreshold
;
size_t
mBufferedAmount
;
RefPtr
<
DataChannelConnection
>
mConnection
;
TrafficCounters
mTrafficCounters
;
bool
mWaitingForAck
=
false
;
nsTArray
<
OutgoingMsg
>
mBufferedData
;
std
:
:
map
<
uint16_t
IncomingMsg
>
mRecvBuffers
;
const
bool
mNegotiated
;
const
bool
mOrdered
;
nsCOMPtr
<
nsISerialEventTarget
>
mMainThreadEventTarget
;
}
;
class
DataChannelOnMessageAvailable
:
public
Runnable
{
public
:
enum
class
EventType
{
OnConnection
OnDisconnected
OnChannelCreated
OnDataString
OnDataBinary
}
;
DataChannelOnMessageAvailable
(
EventType
aType
DataChannelConnection
*
aConnection
DataChannel
*
aChannel
nsCString
&
&
aData
)
:
Runnable
(
"
DataChannelOnMessageAvailable
"
)
mType
(
aType
)
mChannel
(
aChannel
)
mConnection
(
aConnection
)
mData
(
std
:
:
move
(
aData
)
)
{
}
DataChannelOnMessageAvailable
(
EventType
aType
DataChannel
*
aChannel
)
:
Runnable
(
"
DataChannelOnMessageAvailable
"
)
mType
(
aType
)
mChannel
(
aChannel
)
{
}
DataChannelOnMessageAvailable
(
EventType
aType
DataChannelConnection
*
aConnection
DataChannel
*
aChannel
)
:
Runnable
(
"
DataChannelOnMessageAvailable
"
)
mType
(
aType
)
mChannel
(
aChannel
)
mConnection
(
aConnection
)
{
}
DataChannelOnMessageAvailable
(
EventType
aType
DataChannelConnection
*
aConnection
)
:
Runnable
(
"
DataChannelOnMessageAvailable
"
)
mType
(
aType
)
mConnection
(
aConnection
)
{
}
DataChannelOnMessageAvailable
(
const
DataChannelOnMessageAvailable
&
)
=
delete
;
DataChannelOnMessageAvailable
(
DataChannelOnMessageAvailable
&
&
)
=
delete
;
DataChannelOnMessageAvailable
&
operator
=
(
const
DataChannelOnMessageAvailable
&
)
=
delete
;
DataChannelOnMessageAvailable
&
operator
=
(
DataChannelOnMessageAvailable
&
&
)
=
delete
;
NS_IMETHOD
Run
(
)
override
;
private
:
~
DataChannelOnMessageAvailable
(
)
=
default
;
EventType
mType
;
RefPtr
<
DataChannel
>
mChannel
;
RefPtr
<
DataChannelConnection
>
mConnection
;
nsCString
mData
;
}
;
}
#
endif
