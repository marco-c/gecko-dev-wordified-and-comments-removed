#
include
<
algorithm
>
#
include
<
stdio
.
h
>
#
include
<
stdlib
.
h
>
#
if
!
defined
(
__Userspace_os_Windows
)
#
include
<
arpa
/
inet
.
h
>
#
endif
#
include
<
errno
.
h
>
#
define
SCTP_DEBUG
1
#
define
SCTP_STDINT_INCLUDE
<
stdint
.
h
>
#
ifdef
_MSC_VER
#
pragma
warning
(
push
)
#
pragma
warning
(
disable
:
4200
)
#
endif
#
include
"
usrsctp
.
h
"
#
ifdef
_MSC_VER
#
pragma
warning
(
pop
)
#
endif
#
include
"
nsIInputStream
.
h
"
#
include
"
nsIPrefBranch
.
h
"
#
include
"
nsIPrefService
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
include
"
nsThread
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
mozilla
/
Components
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
"
mozilla
/
UniquePtrExtensions
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
dom
/
RTCDataChannelBinding
.
h
"
#
include
"
mozilla
/
dom
/
RTCStatsReportBinding
.
h
"
#
include
"
mozilla
/
media
/
MediaUtils
.
h
"
#
ifdef
MOZ_PEERCONNECTION
#
include
"
transport
/
runnable_utils
.
h
"
#
include
"
jsapi
/
MediaTransportHandler
.
h
"
#
include
"
mediapacket
.
h
"
#
endif
#
include
"
DataChannel
.
h
"
#
include
"
DataChannelLog
.
h
"
#
include
"
DataChannelProtocol
.
h
"
#
ifdef
DEBUG
#
define
ASSERT_WEBRTC
(
x
)
MOZ_ASSERT
(
(
x
)
)
#
elif
defined
(
MOZ_WEBRTC_ASSERT_ALWAYS
)
#
define
ASSERT_WEBRTC
(
x
)
\
do
{
\
if
(
!
(
x
)
)
{
\
MOZ_CRASH
(
)
;
\
}
\
}
while
(
0
)
#
endif
namespace
mozilla
{
LazyLogModule
gDataChannelLog
(
"
DataChannel
"
)
;
static
LazyLogModule
gSCTPLog
(
"
SCTP
"
)
;
#
define
SCTP_LOG
(
args
)
\
MOZ_LOG
(
mozilla
:
:
gSCTPLog
mozilla
:
:
LogLevel
:
:
Debug
args
)
static
void
debug_printf
(
const
char
*
format
.
.
.
)
{
va_list
ap
;
char
buffer
[
1024
]
;
if
(
MOZ_LOG_TEST
(
gSCTPLog
LogLevel
:
:
Debug
)
)
{
va_start
(
ap
format
)
;
#
ifdef
_WIN32
if
(
vsnprintf_s
(
buffer
sizeof
(
buffer
)
_TRUNCATE
format
ap
)
>
0
)
{
#
else
if
(
VsprintfLiteral
(
buffer
format
ap
)
>
0
)
{
#
endif
SCTP_LOG
(
(
"
%
s
"
buffer
)
)
;
}
va_end
(
ap
)
;
}
}
static
constexpr
const
char
*
ToString
(
DataChannelState
state
)
{
switch
(
state
)
{
case
DataChannelState
:
:
Connecting
:
return
"
CONNECTING
"
;
case
DataChannelState
:
:
Open
:
return
"
OPEN
"
;
case
DataChannelState
:
:
Closing
:
return
"
CLOSING
"
;
case
DataChannelState
:
:
Closed
:
return
"
CLOSED
"
;
}
return
"
"
;
}
;
static
constexpr
const
char
*
ToString
(
DataChannelConnectionState
state
)
{
switch
(
state
)
{
case
DataChannelConnectionState
:
:
Connecting
:
return
"
CONNECTING
"
;
case
DataChannelConnectionState
:
:
Open
:
return
"
OPEN
"
;
case
DataChannelConnectionState
:
:
Closed
:
return
"
CLOSED
"
;
}
return
"
"
;
}
;
static
constexpr
const
char
*
ToString
(
DataChannelOnMessageAvailable
:
:
EventType
type
)
{
switch
(
type
)
{
case
DataChannelOnMessageAvailable
:
:
EventType
:
:
OnConnection
:
return
"
ON_CONNECTION
"
;
case
DataChannelOnMessageAvailable
:
:
EventType
:
:
OnDisconnected
:
return
"
ON_DISCONNECTED
"
;
case
DataChannelOnMessageAvailable
:
:
EventType
:
:
OnChannelCreated
:
return
"
ON_CHANNEL_CREATED
"
;
case
DataChannelOnMessageAvailable
:
:
EventType
:
:
OnDataString
:
return
"
ON_DATA_STRING
"
;
case
DataChannelOnMessageAvailable
:
:
EventType
:
:
OnDataBinary
:
return
"
ON_DATA_BINARY
"
;
}
return
"
"
;
}
;
static
constexpr
const
char
*
ToString
(
DataChannelConnection
:
:
PendingType
type
)
{
switch
(
type
)
{
case
DataChannelConnection
:
:
PendingType
:
:
None
:
return
"
NONE
"
;
case
DataChannelConnection
:
:
PendingType
:
:
Dcep
:
return
"
DCEP
"
;
case
DataChannelConnection
:
:
PendingType
:
:
Data
:
return
"
DATA
"
;
}
return
"
"
;
}
;
static
constexpr
const
char
*
ToString
(
DataChannelReliabilityPolicy
type
)
{
switch
(
type
)
{
case
DataChannelReliabilityPolicy
:
:
Reliable
:
return
"
RELIABLE
"
;
case
DataChannelReliabilityPolicy
:
:
LimitedRetransmissions
:
return
"
LIMITED_RETRANSMISSIONS
"
;
case
DataChannelReliabilityPolicy
:
:
LimitedLifetime
:
return
"
LIMITED_LIFETIME
"
;
}
return
"
"
;
}
;
class
DataChannelRegistry
{
public
:
static
uintptr_t
Register
(
DataChannelConnection
*
aConnection
)
{
StaticMutexAutoLock
lock
(
sInstanceMutex
)
;
uintptr_t
result
=
EnsureInstance
(
)
-
>
RegisterImpl
(
aConnection
)
;
DC_DEBUG
(
(
"
Registering
connection
%
p
as
ulp
%
p
"
aConnection
(
void
*
)
result
)
)
;
return
result
;
}
static
void
Deregister
(
uintptr_t
aId
)
{
std
:
:
unique_ptr
<
DataChannelRegistry
>
maybeTrash
;
{
StaticMutexAutoLock
lock
(
sInstanceMutex
)
;
DC_DEBUG
(
(
"
Deregistering
connection
ulp
=
%
p
"
(
void
*
)
aId
)
)
;
if
(
NS_WARN_IF
(
!
Instance
(
)
)
)
{
return
;
}
Instance
(
)
-
>
DeregisterImpl
(
aId
)
;
if
(
Instance
(
)
-
>
Empty
(
)
)
{
maybeTrash
=
std
:
:
move
(
Instance
(
)
)
;
}
}
}
static
RefPtr
<
DataChannelConnection
>
Lookup
(
uintptr_t
aId
)
{
StaticMutexAutoLock
lock
(
sInstanceMutex
)
;
if
(
NS_WARN_IF
(
!
Instance
(
)
)
)
{
return
nullptr
;
}
return
Instance
(
)
-
>
LookupImpl
(
aId
)
;
}
virtual
~
DataChannelRegistry
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
NS_WARN_IF
(
!
mConnections
.
empty
(
)
)
)
{
MOZ_DIAGNOSTIC_CRASH
(
"
mConnections
not
empty
"
)
;
mConnections
.
clear
(
)
;
}
MOZ_DIAGNOSTIC_ASSERT
(
!
Instance
(
)
)
;
DeinitUsrSctp
(
)
;
}
private
:
DataChannelRegistry
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
NS_IsMainThread
(
)
)
;
mShutdownBlocker
=
media
:
:
ShutdownBlockingTicket
:
:
Create
(
u
"
DataChannelRegistry
:
:
mShutdownBlocker
"
_ns
NS_LITERAL_STRING_FROM_CSTRING
(
__FILE__
)
__LINE__
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
Instance
(
)
)
;
InitUsrSctp
(
)
;
}
static
std
:
:
unique_ptr
<
DataChannelRegistry
>
&
Instance
(
)
{
static
std
:
:
unique_ptr
<
DataChannelRegistry
>
sRegistry
;
return
sRegistry
;
}
static
std
:
:
unique_ptr
<
DataChannelRegistry
>
&
EnsureInstance
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
Instance
(
)
)
{
Instance
(
)
.
reset
(
new
DataChannelRegistry
(
)
)
;
}
return
Instance
(
)
;
}
uintptr_t
RegisterImpl
(
DataChannelConnection
*
aConnection
)
{
MOZ_DIAGNOSTIC_ASSERT
(
NS_IsMainThread
(
)
)
;
mConnections
.
emplace
(
mNextId
aConnection
)
;
return
mNextId
+
+
;
}
void
DeregisterImpl
(
uintptr_t
aId
)
{
MOZ_DIAGNOSTIC_ASSERT
(
NS_IsMainThread
(
)
)
;
size_t
removed
=
mConnections
.
erase
(
aId
)
;
mozilla
:
:
Unused
<
<
removed
;
MOZ_DIAGNOSTIC_ASSERT
(
removed
)
;
}
bool
Empty
(
)
const
{
return
mConnections
.
empty
(
)
;
}
RefPtr
<
DataChannelConnection
>
LookupImpl
(
uintptr_t
aId
)
{
auto
it
=
mConnections
.
find
(
aId
)
;
if
(
NS_WARN_IF
(
it
=
=
mConnections
.
end
(
)
)
)
{
DC_DEBUG
(
(
"
Can
'
t
find
connection
ulp
%
p
"
(
void
*
)
aId
)
)
;
return
nullptr
;
}
return
it
-
>
second
;
}
static
int
SctpDtlsOutput
(
void
*
addr
void
*
buffer
size_t
length
uint8_t
tos
uint8_t
set_df
)
{
uintptr_t
id
=
reinterpret_cast
<
uintptr_t
>
(
addr
)
;
RefPtr
<
DataChannelConnection
>
connection
=
DataChannelRegistry
:
:
Lookup
(
id
)
;
if
(
NS_WARN_IF
(
!
connection
)
|
|
connection
-
>
InShutdown
(
)
)
{
return
0
;
}
return
connection
-
>
SctpDtlsOutput
(
addr
buffer
length
tos
set_df
)
;
}
void
InitUsrSctp
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
NS_IsMainThread
(
)
)
;
#
ifndef
MOZ_PEERCONNECTION
MOZ_CRASH
(
"
Trying
to
use
SCTP
/
DTLS
without
dom
/
media
/
webrtc
/
transport
"
)
;
#
endif
DC_DEBUG
(
(
"
Calling
usrsctp_init
%
p
"
this
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
sInitted
)
;
usrsctp_init
(
0
DataChannelRegistry
:
:
SctpDtlsOutput
debug_printf
)
;
sInitted
=
true
;
if
(
MOZ_LOG_TEST
(
gSCTPLog
LogLevel
:
:
Debug
)
)
{
usrsctp_sysctl_set_sctp_debug_on
(
SCTP_DEBUG_ALL
)
;
}
usrsctp_sysctl_set_sctp_blackhole
(
2
)
;
usrsctp_sysctl_set_sctp_ecn_enable
(
0
)
;
usrsctp_sysctl_set_sctp_default_frag_interleave
(
2
)
;
usrsctp_sysctl_set_sctp_asconf_enable
(
0
)
;
usrsctp_sysctl_set_sctp_auth_enable
(
0
)
;
}
void
DeinitUsrSctp
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
sInitted
)
;
DC_DEBUG
(
(
"
Calling
usrsctp_finish
%
p
"
this
)
)
;
usrsctp_finish
(
)
;
sInitted
=
false
;
}
uintptr_t
mNextId
=
1
;
std
:
:
map
<
uintptr_t
RefPtr
<
DataChannelConnection
>
>
mConnections
;
UniquePtr
<
media
:
:
ShutdownBlockingTicket
>
mShutdownBlocker
;
static
StaticMutex
sInstanceMutex
MOZ_UNANNOTATED
;
static
bool
sInitted
;
}
;
bool
DataChannelRegistry
:
:
sInitted
=
false
;
StaticMutex
DataChannelRegistry
:
:
sInstanceMutex
;
OutgoingMsg
:
:
OutgoingMsg
(
nsACString
&
&
aData
const
DataChannelMessageMetadata
&
aMetadata
)
:
mData
(
std
:
:
move
(
aData
)
)
mMetadata
(
aMetadata
)
{
}
void
OutgoingMsg
:
:
Advance
(
size_t
offset
)
{
mPos
+
=
offset
;
if
(
mPos
>
mData
.
Length
(
)
)
{
mPos
=
mData
.
Length
(
)
;
}
}
static
int
receive_cb
(
struct
socket
*
sock
union
sctp_sockstore
addr
void
*
data
size_t
datalen
struct
sctp_rcvinfo
rcv
int
flags
void
*
ulp_info
)
{
DC_DEBUG
(
(
"
In
receive_cb
ulp_info
=
%
p
"
ulp_info
)
)
;
uintptr_t
id
=
reinterpret_cast
<
uintptr_t
>
(
ulp_info
)
;
RefPtr
<
DataChannelConnection
>
connection
=
DataChannelRegistry
:
:
Lookup
(
id
)
;
if
(
!
connection
)
{
DC_DEBUG
(
(
"
Ignoring
receive
callback
for
terminated
Connection
ulp
=
%
p
%
zu
bytes
"
ulp_info
datalen
)
)
;
return
0
;
}
return
connection
-
>
ReceiveCallback
(
sock
data
datalen
rcv
flags
)
;
}
static
RefPtr
<
DataChannelConnection
>
GetConnectionFromSocket
(
struct
socket
*
sock
)
{
struct
sockaddr
*
addrs
=
nullptr
;
int
naddrs
=
usrsctp_getladdrs
(
sock
0
&
addrs
)
;
if
(
naddrs
<
=
0
|
|
addrs
[
0
]
.
sa_family
!
=
AF_CONN
)
{
return
nullptr
;
}
struct
sockaddr_conn
*
sconn
=
reinterpret_cast
<
struct
sockaddr_conn
*
>
(
&
addrs
[
0
]
)
;
uintptr_t
id
=
reinterpret_cast
<
uintptr_t
>
(
sconn
-
>
sconn_addr
)
;
RefPtr
<
DataChannelConnection
>
connection
=
DataChannelRegistry
:
:
Lookup
(
id
)
;
usrsctp_freeladdrs
(
addrs
)
;
return
connection
;
}
int
DataChannelConnection
:
:
OnThresholdEvent
(
struct
socket
*
sock
uint32_t
sb_free
void
*
ulp_info
)
{
RefPtr
<
DataChannelConnection
>
connection
=
GetConnectionFromSocket
(
sock
)
;
connection
-
>
mLock
.
AssertCurrentThreadOwns
(
)
;
if
(
connection
)
{
connection
-
>
SendDeferredMessages
(
)
;
}
else
{
DC_ERROR
(
(
"
Can
'
t
find
connection
for
socket
%
p
"
sock
)
)
;
}
return
0
;
}
DataChannelConnection
:
:
~
DataChannelConnection
(
)
{
DC_DEBUG
(
(
"
Deleting
DataChannelConnection
%
p
"
(
void
*
)
this
)
)
;
ASSERT_WEBRTC
(
mState
=
=
DataChannelConnectionState
:
:
Closed
)
;
MOZ_ASSERT
(
mPending
.
empty
(
)
)
;
if
(
!
IsSTSThread
(
)
)
{
if
(
mInternalIOThread
)
{
nsCOMPtr
<
nsIRunnable
>
r
=
WrapRunnable
(
nsCOMPtr
<
nsIThread
>
(
mInternalIOThread
)
&
nsIThread
:
:
AsyncShutdown
)
;
Dispatch
(
r
.
forget
(
)
)
;
}
}
else
{
if
(
mInternalIOThread
)
{
mInternalIOThread
-
>
Shutdown
(
)
;
}
}
}
void
DataChannelConnection
:
:
Destroy
(
)
{
ASSERT_WEBRTC
(
NS_IsMainThread
(
)
)
;
DC_DEBUG
(
(
"
Destroying
DataChannelConnection
%
p
"
(
void
*
)
this
)
)
;
CloseAll
(
)
;
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
MOZ_DIAGNOSTIC_ASSERT
(
mSTS
)
;
#
endif
mListener
=
nullptr
;
mSTS
-
>
Dispatch
(
NS_NewRunnableFunction
(
__func__
[
this
self
=
RefPtr
<
DataChannelConnection
>
(
this
)
]
(
)
{
mPacketReceivedListener
.
DisconnectIfExists
(
)
;
mStateChangeListener
.
DisconnectIfExists
(
)
;
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
mShutdown
=
true
;
DC_DEBUG
(
(
"
Shutting
down
connection
%
p
id
%
p
"
this
(
void
*
)
mId
)
)
;
#
endif
}
)
)
;
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
auto
self
=
DataChannelRegistry
:
:
Lookup
(
mId
)
;
MOZ_DIAGNOSTIC_ASSERT
(
self
)
;
MOZ_DIAGNOSTIC_ASSERT
(
this
=
=
self
.
get
(
)
)
;
#
endif
RUN_ON_THREAD
(
mSTS
WrapRunnable
(
RefPtr
<
DataChannelConnection
>
(
this
)
&
DataChannelConnection
:
:
DestroyOnSTS
)
NS_DISPATCH_NORMAL
)
;
}
void
DataChannelConnection
:
:
DestroyOnSTS
(
)
{
MOZ_ASSERT
(
mSTS
-
>
IsOnCurrentThread
(
)
)
;
if
(
mSocket
)
usrsctp_close
(
mSocket
)
;
mSocket
=
nullptr
;
usrsctp_deregister_address
(
reinterpret_cast
<
void
*
>
(
mId
)
)
;
DC_DEBUG
(
(
"
Deregistered
%
p
from
the
SCTP
stack
.
"
reinterpret_cast
<
void
*
>
(
mId
)
)
)
;
Dispatch
(
NS_NewRunnableFunction
(
"
DataChannelConnection
:
:
Destroy
"
[
this
self
=
RefPtr
<
DataChannelConnection
>
(
this
)
]
(
)
{
DataChannelRegistry
:
:
Deregister
(
mId
)
;
}
)
)
;
}
Maybe
<
RefPtr
<
DataChannelConnection
>
>
DataChannelConnection
:
:
Create
(
DataChannelConnection
:
:
DataConnectionListener
*
aListener
nsISerialEventTarget
*
aTarget
MediaTransportHandler
*
aHandler
const
uint16_t
aLocalPort
const
uint16_t
aNumStreams
const
Maybe
<
uint64_t
>
&
aMaxMessageSize
)
{
ASSERT_WEBRTC
(
NS_IsMainThread
(
)
)
;
RefPtr
<
DataChannelConnection
>
connection
=
new
DataChannelConnection
(
aListener
aTarget
aHandler
)
;
return
connection
-
>
Init
(
aLocalPort
aNumStreams
aMaxMessageSize
)
?
Some
(
connection
)
:
Nothing
(
)
;
}
DataChannelConnection
:
:
DataChannelConnection
(
DataChannelConnection
:
:
DataConnectionListener
*
aListener
nsISerialEventTarget
*
aTarget
MediaTransportHandler
*
aHandler
)
:
NeckoTargetHolder
(
aTarget
)
mLock
(
"
netwerk
:
:
sctp
:
:
DataChannelConnection
"
)
mListener
(
aListener
)
mTransportHandler
(
aHandler
)
{
DC_VERBOSE
(
(
"
Constructor
DataChannelConnection
=
%
p
listener
=
%
p
"
this
mListener
.
get
(
)
)
)
;
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
mShutdown
=
false
;
#
endif
}
bool
DataChannelConnection
:
:
Init
(
const
uint16_t
aLocalPort
const
uint16_t
aNumStreams
const
Maybe
<
uint64_t
>
&
aMaxMessageSize
)
{
ASSERT_WEBRTC
(
NS_IsMainThread
(
)
)
;
struct
sctp_initmsg
initmsg
=
{
}
;
struct
sctp_assoc_value
av
=
{
}
;
struct
sctp_event
event
=
{
}
;
socklen_t
len
;
uint16_t
event_types
[
]
=
{
SCTP_ASSOC_CHANGE
SCTP_PEER_ADDR_CHANGE
SCTP_REMOTE_ERROR
SCTP_SHUTDOWN_EVENT
SCTP_ADAPTATION_INDICATION
SCTP_PARTIAL_DELIVERY_EVENT
SCTP_SEND_FAILED_EVENT
SCTP_STREAM_RESET_EVENT
SCTP_STREAM_CHANGE_EVENT
}
;
SetMaxMessageSize
(
aMaxMessageSize
.
isSome
(
)
aMaxMessageSize
.
valueOr
(
0
)
)
;
mId
=
DataChannelRegistry
:
:
Register
(
this
)
;
nsresult
rv
;
mSTS
=
mozilla
:
:
components
:
:
SocketTransport
:
:
Service
(
&
rv
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
socklen_t
buf_size
=
1024
*
1024
;
if
(
(
mSocket
=
usrsctp_socket
(
AF_CONN
SOCK_STREAM
IPPROTO_SCTP
receive_cb
&
DataChannelConnection
:
:
OnThresholdEvent
usrsctp_sysctl_get_sctp_sendspace
(
)
/
2
reinterpret_cast
<
void
*
>
(
mId
)
)
)
=
=
nullptr
)
{
goto
error_cleanup
;
}
if
(
usrsctp_setsockopt
(
mSocket
SOL_SOCKET
SO_RCVBUF
(
const
void
*
)
&
buf_size
sizeof
(
buf_size
)
)
<
0
)
{
DC_ERROR
(
(
"
Couldn
'
t
change
receive
buffer
size
on
SCTP
socket
"
)
)
;
goto
error_cleanup
;
}
if
(
usrsctp_setsockopt
(
mSocket
SOL_SOCKET
SO_SNDBUF
(
const
void
*
)
&
buf_size
sizeof
(
buf_size
)
)
<
0
)
{
DC_ERROR
(
(
"
Couldn
'
t
change
send
buffer
size
on
SCTP
socket
"
)
)
;
goto
error_cleanup
;
}
if
(
usrsctp_set_non_blocking
(
mSocket
1
)
<
0
)
{
DC_ERROR
(
(
"
Couldn
'
t
set
non_blocking
on
SCTP
socket
"
)
)
;
goto
error_cleanup
;
}
struct
linger
l
;
l
.
l_onoff
=
1
;
l
.
l_linger
=
0
;
if
(
usrsctp_setsockopt
(
mSocket
SOL_SOCKET
SO_LINGER
(
const
void
*
)
&
l
(
socklen_t
)
sizeof
(
struct
linger
)
)
<
0
)
{
DC_ERROR
(
(
"
Couldn
'
t
set
SO_LINGER
on
SCTP
socket
"
)
)
;
goto
error_cleanup
;
}
{
const
int
option_value
=
1
;
if
(
usrsctp_setsockopt
(
mSocket
IPPROTO_SCTP
SCTP_REUSE_PORT
(
const
void
*
)
&
option_value
(
socklen_t
)
sizeof
(
option_value
)
)
<
0
)
{
DC_WARN
(
(
"
Couldn
'
t
set
SCTP_REUSE_PORT
on
SCTP
socket
"
)
)
;
}
if
(
usrsctp_setsockopt
(
mSocket
IPPROTO_SCTP
SCTP_NODELAY
(
const
void
*
)
&
option_value
(
socklen_t
)
sizeof
(
option_value
)
)
<
0
)
{
DC_WARN
(
(
"
Couldn
'
t
set
SCTP_NODELAY
on
SCTP
socket
"
)
)
;
}
}
{
const
int
option_value
=
1
;
if
(
usrsctp_setsockopt
(
mSocket
IPPROTO_SCTP
SCTP_EXPLICIT_EOR
(
const
void
*
)
&
option_value
(
socklen_t
)
sizeof
(
option_value
)
)
<
0
)
{
DC_ERROR
(
(
"
*
*
*
failed
to
enable
explicit
EOR
mode
%
d
"
errno
)
)
;
goto
error_cleanup
;
}
}
av
.
assoc_id
=
SCTP_FUTURE_ASSOC
;
av
.
assoc_value
=
1
;
if
(
usrsctp_setsockopt
(
mSocket
IPPROTO_SCTP
SCTP_INTERLEAVING_SUPPORTED
&
av
(
socklen_t
)
sizeof
(
struct
sctp_assoc_value
)
)
<
0
)
{
DC_ERROR
(
(
"
*
*
*
failed
enable
ndata
errno
%
d
"
errno
)
)
;
goto
error_cleanup
;
}
av
.
assoc_id
=
SCTP_ALL_ASSOC
;
av
.
assoc_value
=
SCTP_ENABLE_RESET_STREAM_REQ
|
SCTP_ENABLE_CHANGE_ASSOC_REQ
;
if
(
usrsctp_setsockopt
(
mSocket
IPPROTO_SCTP
SCTP_ENABLE_STREAM_RESET
&
av
(
socklen_t
)
sizeof
(
struct
sctp_assoc_value
)
)
<
0
)
{
DC_ERROR
(
(
"
*
*
*
failed
enable
stream
reset
errno
%
d
"
errno
)
)
;
goto
error_cleanup
;
}
event
.
se_assoc_id
=
SCTP_ALL_ASSOC
;
event
.
se_on
=
1
;
for
(
unsigned
short
event_type
:
event_types
)
{
event
.
se_type
=
event_type
;
if
(
usrsctp_setsockopt
(
mSocket
IPPROTO_SCTP
SCTP_EVENT
&
event
sizeof
(
event
)
)
<
0
)
{
DC_ERROR
(
(
"
*
*
*
failed
setsockopt
SCTP_EVENT
errno
%
d
"
errno
)
)
;
goto
error_cleanup
;
}
}
len
=
sizeof
(
initmsg
)
;
if
(
usrsctp_getsockopt
(
mSocket
IPPROTO_SCTP
SCTP_INITMSG
&
initmsg
&
len
)
<
0
)
{
DC_ERROR
(
(
"
*
*
*
failed
getsockopt
SCTP_INITMSG
"
)
)
;
goto
error_cleanup
;
}
DC_DEBUG
(
(
"
Setting
number
of
SCTP
streams
to
%
u
was
%
u
/
%
u
"
aNumStreams
initmsg
.
sinit_num_ostreams
initmsg
.
sinit_max_instreams
)
)
;
initmsg
.
sinit_num_ostreams
=
aNumStreams
;
initmsg
.
sinit_max_instreams
=
MAX_NUM_STREAMS
;
if
(
usrsctp_setsockopt
(
mSocket
IPPROTO_SCTP
SCTP_INITMSG
&
initmsg
(
socklen_t
)
sizeof
(
initmsg
)
)
<
0
)
{
DC_ERROR
(
(
"
*
*
*
failed
setsockopt
SCTP_INITMSG
errno
%
d
"
errno
)
)
;
goto
error_cleanup
;
}
mSTS
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
DataChannelConnection
:
:
Init
"
[
id
=
mId
]
(
)
{
usrsctp_register_address
(
reinterpret_cast
<
void
*
>
(
id
)
)
;
DC_DEBUG
(
(
"
Registered
%
p
within
the
SCTP
stack
.
"
reinterpret_cast
<
void
*
>
(
id
)
)
)
;
}
)
)
;
return
true
;
error_cleanup
:
usrsctp_close
(
mSocket
)
;
mSocket
=
nullptr
;
DataChannelRegistry
:
:
Deregister
(
mId
)
;
return
false
;
}
void
DataChannelConnection
:
:
SetMaxMessageSize
(
bool
aMaxMessageSizeSet
uint64_t
aMaxMessageSize
)
{
ASSERT_WEBRTC
(
NS_IsMainThread
(
)
)
;
if
(
mMaxMessageSizeSet
&
&
!
aMaxMessageSizeSet
)
{
return
;
}
mMaxMessageSizeSet
=
aMaxMessageSizeSet
;
mMaxMessageSize
=
aMaxMessageSize
;
nsresult
rv
;
nsCOMPtr
<
nsIPrefService
>
prefs
;
prefs
=
mozilla
:
:
components
:
:
Preferences
:
:
Service
(
&
rv
)
;
if
(
!
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
nsCOMPtr
<
nsIPrefBranch
>
branch
=
do_QueryInterface
(
prefs
)
;
if
(
branch
)
{
int32_t
temp
;
if
(
!
NS_FAILED
(
branch
-
>
GetIntPref
(
"
media
.
peerconnection
.
sctp
.
force_maximum_message_size
"
&
temp
)
)
)
{
if
(
temp
>
=
0
)
{
mMaxMessageSize
=
(
uint64_t
)
temp
;
}
}
}
}
if
(
mMaxMessageSize
=
=
0
|
|
mMaxMessageSize
>
WEBRTC_DATACHANNEL_MAX_MESSAGE_SIZE_REMOTE
)
{
mMaxMessageSize
=
WEBRTC_DATACHANNEL_MAX_MESSAGE_SIZE_REMOTE
;
}
DC_DEBUG
(
(
"
Maximum
message
size
(
outgoing
data
)
:
%
"
PRIu64
"
(
set
=
%
s
enforced
=
%
s
)
"
mMaxMessageSize
mMaxMessageSizeSet
?
"
yes
"
:
"
no
"
aMaxMessageSize
!
=
mMaxMessageSize
?
"
yes
"
:
"
no
"
)
)
;
}
uint64_t
DataChannelConnection
:
:
GetMaxMessageSize
(
)
{
ASSERT_WEBRTC
(
NS_IsMainThread
(
)
)
;
return
mMaxMessageSize
;
}
void
DataChannelConnection
:
:
AppendStatsToReport
(
const
UniquePtr
<
dom
:
:
RTCStatsCollection
>
&
aReport
const
DOMHighResTimeStamp
aTimestamp
)
const
{
ASSERT_WEBRTC
(
NS_IsMainThread
(
)
)
;
nsString
temp
;
for
(
const
RefPtr
<
DataChannel
>
&
chan
:
mChannels
.
GetAll
(
)
)
{
if
(
!
chan
)
{
continue
;
}
mozilla
:
:
dom
:
:
RTCDataChannelStats
stats
;
nsString
id
=
u
"
dc
"
_ns
;
id
.
AppendInt
(
chan
-
>
GetStream
(
)
)
;
stats
.
mId
.
Construct
(
id
)
;
chan
-
>
GetLabel
(
temp
)
;
stats
.
mTimestamp
.
Construct
(
aTimestamp
)
;
stats
.
mType
.
Construct
(
mozilla
:
:
dom
:
:
RTCStatsType
:
:
Data_channel
)
;
stats
.
mLabel
.
Construct
(
temp
)
;
chan
-
>
GetProtocol
(
temp
)
;
stats
.
mProtocol
.
Construct
(
temp
)
;
stats
.
mDataChannelIdentifier
.
Construct
(
chan
-
>
GetStream
(
)
)
;
{
using
State
=
mozilla
:
:
dom
:
:
RTCDataChannelState
;
State
state
;
switch
(
chan
-
>
GetReadyState
(
)
)
{
case
DataChannelState
:
:
Connecting
:
state
=
State
:
:
Connecting
;
break
;
case
DataChannelState
:
:
Open
:
state
=
State
:
:
Open
;
break
;
case
DataChannelState
:
:
Closing
:
state
=
State
:
:
Closing
;
break
;
case
DataChannelState
:
:
Closed
:
state
=
State
:
:
Closed
;
break
;
}
;
stats
.
mState
.
Construct
(
state
)
;
}
auto
counters
=
chan
-
>
GetTrafficCounters
(
)
;
stats
.
mMessagesSent
.
Construct
(
counters
.
mMessagesSent
)
;
stats
.
mBytesSent
.
Construct
(
counters
.
mBytesSent
)
;
stats
.
mMessagesReceived
.
Construct
(
counters
.
mMessagesReceived
)
;
stats
.
mBytesReceived
.
Construct
(
counters
.
mBytesReceived
)
;
if
(
!
aReport
-
>
mDataChannelStats
.
AppendElement
(
stats
fallible
)
)
{
mozalloc_handle_oom
(
0
)
;
}
}
}
#
ifdef
MOZ_PEERCONNECTION
bool
DataChannelConnection
:
:
ConnectToTransport
(
const
std
:
:
string
&
aTransportId
const
bool
aClient
const
uint16_t
aLocalPort
const
uint16_t
aRemotePort
)
{
MutexAutoLock
lock
(
mLock
)
;
ASSERT_WEBRTC
(
NS_IsMainThread
(
)
)
;
static
const
auto
paramString
=
[
]
(
const
std
:
:
string
&
tId
const
Maybe
<
bool
>
&
client
const
uint16_t
localPort
const
uint16_t
remotePort
)
-
>
std
:
:
string
{
std
:
:
ostringstream
stream
;
stream
<
<
"
Transport
ID
:
'
"
<
<
tId
<
<
"
'
Role
:
'
"
<
<
(
client
?
(
client
.
value
(
)
?
"
client
"
:
"
server
"
)
:
"
"
)
<
<
"
'
Local
Port
:
'
"
<
<
localPort
<
<
"
'
Remote
Port
:
'
"
<
<
remotePort
<
<
"
'
"
;
return
stream
.
str
(
)
;
}
;
const
auto
params
=
paramString
(
aTransportId
Some
(
aClient
)
aLocalPort
aRemotePort
)
;
DC_DEBUG
(
(
"
ConnectToTransport
connecting
DTLS
transport
with
parameters
:
%
s
"
params
.
c_str
(
)
)
)
;
DC_WARN
(
(
"
New
transport
parameters
:
%
s
"
params
.
c_str
(
)
)
)
;
if
(
NS_WARN_IF
(
aTransportId
.
empty
(
)
)
)
{
return
false
;
}
if
(
!
mAllocateEven
.
isSome
(
)
)
{
mLocalPort
=
aLocalPort
;
mRemotePort
=
aRemotePort
;
mAllocateEven
=
Some
(
aClient
)
;
nsTArray
<
RefPtr
<
DataChannel
>
>
hasStreamId
;
while
(
auto
channel
=
mChannels
.
Get
(
INVALID_STREAM
)
)
{
mChannels
.
Remove
(
channel
)
;
auto
id
=
FindFreeStream
(
)
;
if
(
id
!
=
INVALID_STREAM
)
{
channel
-
>
mStream
=
id
;
mChannels
.
Insert
(
channel
)
;
DC_DEBUG
(
(
"
%
s
%
p
:
Inserting
auto
-
selected
id
%
u
"
__func__
this
static_cast
<
unsigned
>
(
id
)
)
)
;
mStreamIds
.
InsertElementSorted
(
id
)
;
hasStreamId
.
AppendElement
(
channel
)
;
}
else
{
channel
-
>
AnnounceClosed
(
)
;
}
}
mSTS
-
>
Dispatch
(
NS_NewRunnableFunction
(
__func__
[
this
self
=
RefPtr
<
DataChannelConnection
>
(
this
)
hasStreamId
=
std
:
:
move
(
hasStreamId
)
]
(
)
{
MutexAutoLock
lock
(
mLock
)
;
SetState
(
DataChannelConnectionState
:
:
Connecting
)
;
for
(
auto
channel
:
hasStreamId
)
{
OpenFinish
(
channel
)
;
}
}
)
)
;
}
RUN_ON_THREAD
(
mSTS
WrapRunnable
(
RefPtr
<
DataChannelConnection
>
(
this
)
&
DataChannelConnection
:
:
SetSignals
aTransportId
)
NS_DISPATCH_NORMAL
)
;
return
true
;
}
void
DataChannelConnection
:
:
SetSignals
(
const
std
:
:
string
&
aTransportId
)
{
ASSERT_WEBRTC
(
IsSTSThread
(
)
)
;
MutexAutoLock
lock
(
mLock
)
;
if
(
mTransportId
=
=
aTransportId
)
{
return
;
}
mTransportId
=
aTransportId
;
if
(
!
mConnectedToTransportHandler
)
{
mPacketReceivedListener
=
mTransportHandler
-
>
GetSctpPacketReceived
(
)
.
Connect
(
mSTS
this
&
DataChannelConnection
:
:
SctpDtlsInput
)
;
mStateChangeListener
=
mTransportHandler
-
>
GetStateChange
(
)
.
Connect
(
mSTS
this
&
DataChannelConnection
:
:
TransportStateChange
)
;
mConnectedToTransportHandler
=
true
;
}
if
(
mTransportHandler
-
>
GetState
(
mTransportId
false
)
=
=
TransportLayer
:
:
TS_OPEN
)
{
DC_DEBUG
(
(
"
Setting
transport
signals
dtls
already
open
"
)
)
;
CompleteConnect
(
)
;
}
else
{
DC_DEBUG
(
(
"
Setting
transport
signals
dtls
not
open
yet
"
)
)
;
}
}
void
DataChannelConnection
:
:
TransportStateChange
(
const
std
:
:
string
&
aTransportId
TransportLayer
:
:
State
aState
)
{
ASSERT_WEBRTC
(
IsSTSThread
(
)
)
;
MutexAutoLock
lock
(
mLock
)
;
if
(
aTransportId
=
=
mTransportId
)
{
if
(
aState
=
=
TransportLayer
:
:
TS_OPEN
)
{
DC_DEBUG
(
(
"
Transport
is
open
!
"
)
)
;
CompleteConnect
(
)
;
}
else
if
(
aState
=
=
TransportLayer
:
:
TS_CLOSED
|
|
aState
=
=
TransportLayer
:
:
TS_NONE
|
|
aState
=
=
TransportLayer
:
:
TS_ERROR
)
{
DC_DEBUG
(
(
"
Transport
is
closed
!
"
)
)
;
Stop
(
)
;
}
}
}
void
DataChannelConnection
:
:
CompleteConnect
(
)
{
DC_DEBUG
(
(
"
dtls
open
"
)
)
;
ASSERT_WEBRTC
(
IsSTSThread
(
)
)
;
mLock
.
AssertCurrentThreadOwns
(
)
;
if
(
mSctpConfigured
)
{
return
;
}
mSctpConfigured
=
true
;
struct
sockaddr_conn
addr
=
{
}
;
addr
.
sconn_family
=
AF_CONN
;
#
if
defined
(
__Userspace_os_Darwin
)
addr
.
sconn_len
=
sizeof
(
addr
)
;
#
endif
addr
.
sconn_port
=
htons
(
mLocalPort
)
;
addr
.
sconn_addr
=
reinterpret_cast
<
void
*
>
(
mId
)
;
DC_DEBUG
(
(
"
Calling
usrsctp_bind
"
)
)
;
int
r
=
usrsctp_bind
(
mSocket
reinterpret_cast
<
struct
sockaddr
*
>
(
&
addr
)
sizeof
(
addr
)
)
;
if
(
r
<
0
)
{
DC_ERROR
(
(
"
usrsctp_bind
failed
:
%
d
"
r
)
)
;
}
else
{
addr
.
sconn_port
=
htons
(
mRemotePort
)
;
DC_DEBUG
(
(
"
Calling
usrsctp_connect
"
)
)
;
r
=
usrsctp_connect
(
mSocket
reinterpret_cast
<
struct
sockaddr
*
>
(
&
addr
)
sizeof
(
addr
)
)
;
if
(
r
>
=
0
|
|
errno
=
=
EINPROGRESS
)
{
struct
sctp_paddrparams
paddrparams
=
{
}
;
socklen_t
opt_len
;
memcpy
(
&
paddrparams
.
spp_address
&
addr
sizeof
(
struct
sockaddr_conn
)
)
;
opt_len
=
(
socklen_t
)
sizeof
(
struct
sctp_paddrparams
)
;
r
=
usrsctp_getsockopt
(
mSocket
IPPROTO_SCTP
SCTP_PEER_ADDR_PARAMS
&
paddrparams
&
opt_len
)
;
if
(
r
<
0
)
{
DC_ERROR
(
(
"
usrsctp_getsockopt
failed
:
%
d
"
r
)
)
;
}
else
{
paddrparams
.
spp_pathmtu
=
1179
;
paddrparams
.
spp_flags
&
=
~
SPP_PMTUD_ENABLE
;
paddrparams
.
spp_flags
|
=
SPP_PMTUD_DISABLE
;
opt_len
=
(
socklen_t
)
sizeof
(
struct
sctp_paddrparams
)
;
r
=
usrsctp_setsockopt
(
mSocket
IPPROTO_SCTP
SCTP_PEER_ADDR_PARAMS
&
paddrparams
opt_len
)
;
if
(
r
<
0
)
{
DC_ERROR
(
(
"
usrsctp_getsockopt
failed
:
%
d
"
r
)
)
;
}
else
{
DC_ERROR
(
(
"
usrsctp
:
PMTUD
disabled
MTU
set
to
%
u
"
paddrparams
.
spp_pathmtu
)
)
;
}
}
}
if
(
r
<
0
)
{
if
(
errno
=
=
EINPROGRESS
)
{
return
;
}
DC_ERROR
(
(
"
usrsctp_connect
failed
:
%
d
"
errno
)
)
;
SetState
(
DataChannelConnectionState
:
:
Closed
)
;
}
else
{
return
;
}
}
Dispatch
(
do_AddRef
(
new
DataChannelOnMessageAvailable
(
DataChannelOnMessageAvailable
:
:
EventType
:
:
OnConnection
this
)
)
)
;
}
void
DataChannelConnection
:
:
ProcessQueuedOpens
(
)
{
MOZ_ASSERT
(
mSTS
-
>
IsOnCurrentThread
(
)
)
;
mLock
.
AssertCurrentThreadOwns
(
)
;
std
:
:
set
<
RefPtr
<
DataChannel
>
>
temp
(
std
:
:
move
(
mPending
)
)
;
for
(
auto
channel
:
temp
)
{
DC_DEBUG
(
(
"
Processing
queued
open
for
%
p
(
%
u
)
"
channel
.
get
(
)
channel
-
>
mStream
)
)
;
OpenFinish
(
channel
)
;
}
}
void
DataChannelConnection
:
:
SctpDtlsInput
(
const
std
:
:
string
&
aTransportId
const
MediaPacket
&
packet
)
{
MutexAutoLock
lock
(
mLock
)
;
if
(
(
packet
.
type
(
)
!
=
MediaPacket
:
:
SCTP
)
|
|
(
mTransportId
!
=
aTransportId
)
)
{
return
;
}
if
(
MOZ_LOG_TEST
(
gSCTPLog
LogLevel
:
:
Debug
)
)
{
char
*
buf
;
if
(
(
buf
=
usrsctp_dumppacket
(
(
void
*
)
packet
.
data
(
)
packet
.
len
(
)
SCTP_DUMP_INBOUND
)
)
!
=
nullptr
)
{
SCTP_LOG
(
(
"
%
s
"
buf
)
)
;
usrsctp_freedumpbuffer
(
buf
)
;
}
}
usrsctp_conninput
(
reinterpret_cast
<
void
*
>
(
mId
)
packet
.
data
(
)
packet
.
len
(
)
0
)
;
}
void
DataChannelConnection
:
:
SendPacket
(
std
:
:
unique_ptr
<
MediaPacket
>
&
&
packet
)
{
mSTS
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
DataChannelConnection
:
:
SendPacket
"
[
this
self
=
RefPtr
<
DataChannelConnection
>
(
this
)
packet
=
std
:
:
move
(
packet
)
]
(
)
mutable
{
if
(
!
mTransportId
.
empty
(
)
&
&
mTransportHandler
)
{
mTransportHandler
-
>
SendPacket
(
mTransportId
std
:
:
move
(
*
packet
)
)
;
}
}
)
)
;
}
int
DataChannelConnection
:
:
SctpDtlsOutput
(
void
*
addr
void
*
buffer
size_t
length
uint8_t
tos
uint8_t
set_df
)
{
if
(
MOZ_LOG_TEST
(
gSCTPLog
LogLevel
:
:
Debug
)
)
{
char
*
buf
;
if
(
(
buf
=
usrsctp_dumppacket
(
buffer
length
SCTP_DUMP_OUTBOUND
)
)
!
=
nullptr
)
{
SCTP_LOG
(
(
"
%
s
"
buf
)
)
;
usrsctp_freedumpbuffer
(
buf
)
;
}
}
std
:
:
unique_ptr
<
MediaPacket
>
packet
(
new
MediaPacket
)
;
packet
-
>
SetType
(
MediaPacket
:
:
SCTP
)
;
packet
-
>
Copy
(
static_cast
<
const
uint8_t
*
>
(
buffer
)
length
)
;
SendPacket
(
std
:
:
move
(
packet
)
)
;
return
0
;
}
#
endif
DataChannel
*
DataChannelConnection
:
:
FindChannelByStream
(
uint16_t
stream
)
{
return
mChannels
.
Get
(
stream
)
.
get
(
)
;
}
uint16_t
DataChannelConnection
:
:
FindFreeStream
(
)
const
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mAllocateEven
.
isSome
(
)
)
;
if
(
!
mAllocateEven
.
isSome
(
)
)
{
return
INVALID_STREAM
;
}
uint16_t
i
=
(
*
mAllocateEven
?
0
:
1
)
;
for
(
auto
id
:
mStreamIds
)
{
if
(
i
>
=
MAX_NUM_STREAMS
)
{
return
INVALID_STREAM
;
}
if
(
id
=
=
i
)
{
i
+
=
2
;
}
else
if
(
id
>
i
)
{
break
;
}
}
return
i
;
}
uint32_t
DataChannelConnection
:
:
UpdateCurrentStreamIndex
(
)
{
RefPtr
<
DataChannel
>
channel
=
mChannels
.
GetNextChannel
(
mCurrentStream
)
;
if
(
!
channel
)
{
mCurrentStream
=
0
;
}
else
{
mCurrentStream
=
channel
-
>
mStream
;
}
return
mCurrentStream
;
}
uint32_t
DataChannelConnection
:
:
GetCurrentStreamIndex
(
)
{
if
(
!
mChannels
.
Get
(
mCurrentStream
)
)
{
DC_DEBUG
(
(
"
Reset
mCurrentChannel
"
)
)
;
mCurrentStream
=
0
;
}
return
mCurrentStream
;
}
bool
DataChannelConnection
:
:
RaiseStreamLimitTo
(
uint16_t
aNewLimit
)
{
MOZ_ASSERT
(
mSTS
-
>
IsOnCurrentThread
(
)
)
;
mLock
.
AssertCurrentThreadOwns
(
)
;
if
(
GetState
(
)
=
=
DataChannelConnectionState
:
:
Closed
)
{
return
true
;
}
if
(
mNegotiatedIdLimit
=
=
MAX_NUM_STREAMS
)
{
return
false
;
}
if
(
aNewLimit
<
=
mNegotiatedIdLimit
)
{
return
true
;
}
if
(
aNewLimit
>
MAX_NUM_STREAMS
)
{
aNewLimit
=
MAX_NUM_STREAMS
;
}
struct
sctp_status
status
=
{
}
;
socklen_t
len
=
(
socklen_t
)
sizeof
(
struct
sctp_status
)
;
if
(
usrsctp_getsockopt
(
mSocket
IPPROTO_SCTP
SCTP_STATUS
&
status
&
len
)
<
0
)
{
DC_ERROR
(
(
"
*
*
*
failed
:
getsockopt
SCTP_STATUS
"
)
)
;
return
false
;
}
const
uint16_t
outStreamsNeeded
=
aNewLimit
-
mNegotiatedIdLimit
;
struct
sctp_add_streams
sas
=
{
}
;
sas
.
sas_instrms
=
0
;
sas
.
sas_outstrms
=
outStreamsNeeded
;
if
(
usrsctp_setsockopt
(
mSocket
IPPROTO_SCTP
SCTP_ADD_STREAMS
&
sas
(
socklen_t
)
sizeof
(
struct
sctp_add_streams
)
)
<
0
)
{
if
(
errno
=
=
EALREADY
)
{
DC_DEBUG
(
(
"
Already
have
%
u
output
streams
"
outStreamsNeeded
)
)
;
return
true
;
}
DC_ERROR
(
(
"
*
*
*
failed
:
setsockopt
ADD
errno
=
%
d
"
errno
)
)
;
return
false
;
}
DC_DEBUG
(
(
"
Requested
%
u
more
streams
"
outStreamsNeeded
)
)
;
return
true
;
}
int
DataChannelConnection
:
:
SendControlMessage
(
DataChannel
&
aChannel
const
uint8_t
*
data
uint32_t
len
)
{
MOZ_ASSERT
(
mSTS
-
>
IsOnCurrentThread
(
)
)
;
#
if
(
UINT32_MAX
>
SIZE_MAX
)
if
(
len
>
SIZE_MAX
)
{
return
EMSGSIZE
;
}
#
endif
DataChannelMessageMetadata
metadata
(
aChannel
.
mStream
DATA_CHANNEL_PPID_CONTROL
false
)
;
nsCString
buffer
(
reinterpret_cast
<
const
char
*
>
(
data
)
len
)
;
OutgoingMsg
msg
(
std
:
:
move
(
buffer
)
metadata
)
;
return
SendMessage
(
aChannel
std
:
:
move
(
msg
)
)
;
}
int
DataChannelConnection
:
:
SendOpenAckMessage
(
DataChannel
&
aChannel
)
{
MOZ_ASSERT
(
mSTS
-
>
IsOnCurrentThread
(
)
)
;
struct
rtcweb_datachannel_ack
ack
=
{
}
;
ack
.
msg_type
=
DATA_CHANNEL_ACK
;
return
SendControlMessage
(
aChannel
(
const
uint8_t
*
)
&
ack
sizeof
(
ack
)
)
;
}
int
DataChannelConnection
:
:
SendOpenRequestMessage
(
DataChannel
&
aChannel
)
{
const
nsACString
&
label
=
aChannel
.
mLabel
;
const
nsACString
&
protocol
=
aChannel
.
mProtocol
;
const
bool
unordered
=
!
aChannel
.
mOrdered
;
const
DataChannelReliabilityPolicy
prPolicy
=
aChannel
.
mPrPolicy
;
const
uint32_t
prValue
=
aChannel
.
mPrValue
;
const
size_t
label_len
=
label
.
Length
(
)
;
const
size_t
proto_len
=
protocol
.
Length
(
)
;
const
size_t
req_size
=
sizeof
(
struct
rtcweb_datachannel_open_request
)
-
1
+
label_len
+
proto_len
;
UniqueFreePtr
<
struct
rtcweb_datachannel_open_request
>
req
(
(
struct
rtcweb_datachannel_open_request
*
)
moz_xmalloc
(
req_size
)
)
;
memset
(
req
.
get
(
)
0
req_size
)
;
req
-
>
msg_type
=
DATA_CHANNEL_OPEN_REQUEST
;
switch
(
prPolicy
)
{
case
DataChannelReliabilityPolicy
:
:
Reliable
:
req
-
>
channel_type
=
DATA_CHANNEL_RELIABLE
;
break
;
case
DataChannelReliabilityPolicy
:
:
LimitedLifetime
:
req
-
>
channel_type
=
DATA_CHANNEL_PARTIAL_RELIABLE_TIMED
;
break
;
case
DataChannelReliabilityPolicy
:
:
LimitedRetransmissions
:
req
-
>
channel_type
=
DATA_CHANNEL_PARTIAL_RELIABLE_REXMIT
;
break
;
default
:
return
EINVAL
;
}
if
(
unordered
)
{
req
-
>
channel_type
|
=
0x80
;
}
req
-
>
reliability_param
=
htonl
(
prValue
)
;
req
-
>
priority
=
htons
(
0
)
;
req
-
>
label_length
=
htons
(
label_len
)
;
req
-
>
protocol_length
=
htons
(
proto_len
)
;
memcpy
(
&
req
-
>
label
[
0
]
PromiseFlatCString
(
label
)
.
get
(
)
label_len
)
;
memcpy
(
&
req
-
>
label
[
label_len
]
PromiseFlatCString
(
protocol
)
.
get
(
)
proto_len
)
;
return
SendControlMessage
(
aChannel
(
const
uint8_t
*
)
req
.
get
(
)
req_size
)
;
}
bool
DataChannelConnection
:
:
SendDeferredMessages
(
)
{
MOZ_ASSERT
(
mSTS
-
>
IsOnCurrentThread
(
)
)
;
RefPtr
<
DataChannel
>
channel
;
mLock
.
AssertCurrentThreadOwns
(
)
;
DC_DEBUG
(
(
"
SendDeferredMessages
called
pending
type
:
%
s
"
ToString
(
mPendingType
)
)
)
;
if
(
mPendingType
=
=
PendingType
:
:
None
)
{
return
false
;
}
if
(
!
mBufferedControl
.
IsEmpty
(
)
&
&
(
mSendInterleaved
|
|
mPendingType
=
=
PendingType
:
:
Dcep
)
)
{
if
(
SendBufferedMessages
(
mBufferedControl
nullptr
)
)
{
return
true
;
}
mPendingType
=
PendingType
:
:
Data
;
}
bool
blocked
=
false
;
uint32_t
i
=
GetCurrentStreamIndex
(
)
;
uint32_t
end
=
i
;
do
{
channel
=
mChannels
.
Get
(
i
)
;
if
(
!
channel
)
{
continue
;
}
if
(
channel
-
>
mBufferedData
.
IsEmpty
(
)
)
{
i
=
UpdateCurrentStreamIndex
(
)
;
continue
;
}
size_t
written
=
0
;
blocked
=
SendBufferedMessages
(
channel
-
>
mBufferedData
&
written
)
;
if
(
written
)
{
channel
-
>
DecrementBufferedAmount
(
written
)
;
}
if
(
mSendInterleaved
|
|
!
blocked
)
{
i
=
UpdateCurrentStreamIndex
(
)
;
}
}
while
(
!
blocked
&
&
i
!
=
end
)
;
if
(
!
blocked
)
{
mPendingType
=
mBufferedControl
.
IsEmpty
(
)
?
PendingType
:
:
None
:
PendingType
:
:
Dcep
;
}
return
blocked
;
}
bool
DataChannelConnection
:
:
SendBufferedMessages
(
nsTArray
<
OutgoingMsg
>
&
buffer
size_t
*
aWritten
)
{
MOZ_ASSERT
(
mSTS
-
>
IsOnCurrentThread
(
)
)
;
mLock
.
AssertCurrentThreadOwns
(
)
;
do
{
const
int
error
=
SendMsgInternal
(
buffer
[
0
]
aWritten
)
;
switch
(
error
)
{
case
0
:
buffer
.
RemoveElementAt
(
0
)
;
break
;
case
EAGAIN
:
#
if
(
EAGAIN
!
=
EWOULDBLOCK
)
case
EWOULDBLOCK
:
#
endif
return
true
;
default
:
buffer
.
RemoveElementAt
(
0
)
;
DC_ERROR
(
(
"
error
on
sending
:
%
d
"
error
)
)
;
break
;
}
}
while
(
!
buffer
.
IsEmpty
(
)
)
;
return
false
;
}
void
DataChannelConnection
:
:
HandleOpenRequestMessage
(
const
struct
rtcweb_datachannel_open_request
*
req
uint32_t
length
uint16_t
stream
)
{
MOZ_ASSERT
(
mSTS
-
>
IsOnCurrentThread
(
)
)
;
RefPtr
<
DataChannel
>
channel
;
uint32_t
prValue
;
DataChannelReliabilityPolicy
prPolicy
;
ASSERT_WEBRTC
(
!
NS_IsMainThread
(
)
)
;
mLock
.
AssertCurrentThreadOwns
(
)
;
const
size_t
requiredLength
=
(
sizeof
(
*
req
)
-
1
)
+
ntohs
(
req
-
>
label_length
)
+
ntohs
(
req
-
>
protocol_length
)
;
if
(
(
(
size_t
)
length
)
!
=
requiredLength
)
{
if
(
(
(
size_t
)
length
)
<
requiredLength
)
{
DC_ERROR
(
(
"
%
s
:
insufficient
length
:
%
u
should
be
%
zu
.
Unable
to
continue
.
"
__FUNCTION__
length
requiredLength
)
)
;
return
;
}
DC_WARN
(
(
"
%
s
:
Inconsistent
length
:
%
u
should
be
%
zu
"
__FUNCTION__
length
requiredLength
)
)
;
}
DC_DEBUG
(
(
"
%
s
:
length
%
u
sizeof
(
*
req
)
=
%
zu
"
__FUNCTION__
length
sizeof
(
*
req
)
)
)
;
switch
(
req
-
>
channel_type
)
{
case
DATA_CHANNEL_RELIABLE
:
case
DATA_CHANNEL_RELIABLE_UNORDERED
:
prPolicy
=
DataChannelReliabilityPolicy
:
:
Reliable
;
break
;
case
DATA_CHANNEL_PARTIAL_RELIABLE_REXMIT
:
case
DATA_CHANNEL_PARTIAL_RELIABLE_REXMIT_UNORDERED
:
prPolicy
=
DataChannelReliabilityPolicy
:
:
LimitedRetransmissions
;
break
;
case
DATA_CHANNEL_PARTIAL_RELIABLE_TIMED
:
case
DATA_CHANNEL_PARTIAL_RELIABLE_TIMED_UNORDERED
:
prPolicy
=
DataChannelReliabilityPolicy
:
:
LimitedLifetime
;
break
;
default
:
DC_ERROR
(
(
"
Unknown
channel
type
%
d
"
req
-
>
channel_type
)
)
;
return
;
}
prValue
=
ntohl
(
req
-
>
reliability_param
)
;
bool
ordered
=
!
(
req
-
>
channel_type
&
0x80
)
;
if
(
(
channel
=
FindChannelByStream
(
stream
)
)
)
{
if
(
!
channel
-
>
mNegotiated
)
{
DC_ERROR
(
(
"
HandleOpenRequestMessage
:
channel
for
pre
-
existing
stream
"
"
%
u
that
was
not
externally
negotiated
.
JS
is
lying
to
us
or
"
"
there
'
s
an
id
collision
.
"
stream
)
)
;
}
else
{
DC_DEBUG
(
(
"
Open
for
externally
negotiated
channel
%
u
"
stream
)
)
;
if
(
prPolicy
!
=
channel
-
>
mPrPolicy
|
|
prValue
!
=
channel
-
>
mPrValue
|
|
ordered
!
=
channel
-
>
mOrdered
)
{
DC_WARN
(
(
"
external
negotiation
mismatch
with
OpenRequest
:
"
"
channel
%
u
policy
%
s
/
%
s
value
%
u
/
%
u
ordered
%
d
/
%
d
"
stream
ToString
(
prPolicy
)
ToString
(
channel
-
>
mPrPolicy
)
prValue
channel
-
>
mPrValue
static_cast
<
int
>
(
ordered
)
static_cast
<
int
>
(
channel
-
>
mOrdered
)
)
)
;
}
}
return
;
}
if
(
stream
>
=
mNegotiatedIdLimit
)
{
DC_ERROR
(
(
"
%
s
:
stream
%
u
out
of
bounds
(
%
u
)
"
__FUNCTION__
stream
mNegotiatedIdLimit
)
)
;
return
;
}
nsCString
label
(
nsDependentCSubstring
(
&
req
-
>
label
[
0
]
ntohs
(
req
-
>
label_length
)
)
)
;
nsCString
protocol
(
nsDependentCSubstring
(
&
req
-
>
label
[
ntohs
(
req
-
>
label_length
)
]
ntohs
(
req
-
>
protocol_length
)
)
)
;
channel
=
new
DataChannel
(
this
stream
DataChannelState
:
:
Open
label
protocol
prPolicy
prValue
ordered
false
nullptr
nullptr
)
;
mChannels
.
Insert
(
channel
)
;
DC_DEBUG
(
(
"
%
s
:
sending
ON_CHANNEL_CREATED
for
%
s
/
%
s
:
%
u
"
__FUNCTION__
channel
-
>
mLabel
.
get
(
)
channel
-
>
mProtocol
.
get
(
)
stream
)
)
;
Dispatch
(
do_AddRef
(
new
DataChannelOnMessageAvailable
(
DataChannelOnMessageAvailable
:
:
EventType
:
:
OnChannelCreated
this
channel
)
)
)
;
DC_DEBUG
(
(
"
%
s
:
deferring
sending
ON_CHANNEL_OPEN
for
%
p
"
__FUNCTION__
channel
.
get
(
)
)
)
;
channel
-
>
AnnounceOpen
(
)
;
const
auto
error
=
SendOpenAckMessage
(
*
channel
)
;
if
(
error
)
{
DC_ERROR
(
(
"
SendOpenRequest
failed
error
=
%
d
"
error
)
)
;
Dispatch
(
NS_NewRunnableFunction
(
"
DataChannelConnection
:
:
HandleOpenRequestMessage
"
[
channel
connection
=
RefPtr
<
DataChannelConnection
>
(
this
)
]
(
)
{
connection
-
>
Close
(
channel
)
;
}
)
)
;
return
;
}
DeliverQueuedData
(
channel
-
>
mStream
)
;
}
void
DataChannelConnection
:
:
DeliverQueuedData
(
uint16_t
stream
)
{
MOZ_ASSERT
(
mSTS
-
>
IsOnCurrentThread
(
)
)
;
mLock
.
AssertCurrentThreadOwns
(
)
;
mQueuedData
.
RemoveElementsBy
(
[
stream
this
]
(
const
auto
&
dataItem
)
{
mLock
.
AssertCurrentThreadOwns
(
)
;
const
bool
match
=
dataItem
-
>
mStream
=
=
stream
;
if
(
match
)
{
DC_DEBUG
(
(
"
Delivering
queued
data
for
stream
%
u
length
%
zu
"
stream
dataItem
-
>
mData
.
Length
(
)
)
)
;
HandleDataMessageChunk
(
dataItem
-
>
mData
.
Elements
(
)
dataItem
-
>
mData
.
Length
(
)
dataItem
-
>
mPpid
dataItem
-
>
mStream
dataItem
-
>
mMessageId
dataItem
-
>
mFlags
)
;
}
return
match
;
}
)
;
}
void
DataChannelConnection
:
:
HandleOpenAckMessage
(
const
struct
rtcweb_datachannel_ack
*
ack
uint32_t
length
uint16_t
stream
)
{
MOZ_ASSERT
(
mSTS
-
>
IsOnCurrentThread
(
)
)
;
DataChannel
*
channel
;
mLock
.
AssertCurrentThreadOwns
(
)
;
channel
=
FindChannelByStream
(
stream
)
;
if
(
NS_WARN_IF
(
!
channel
)
)
{
return
;
}
DC_DEBUG
(
(
"
OpenAck
received
for
stream
%
u
waiting
=
%
d
"
stream
channel
-
>
mWaitingForAck
?
1
:
0
)
)
;
channel
-
>
mWaitingForAck
=
false
;
}
void
DataChannelConnection
:
:
HandleUnknownMessage
(
uint32_t
ppid
uint32_t
length
uint16_t
stream
)
{
MOZ_ASSERT
(
mSTS
-
>
IsOnCurrentThread
(
)
)
;
DC_ERROR
(
(
"
unknown
DataChannel
message
received
:
%
u
len
%
u
on
stream
%
d
"
ppid
length
stream
)
)
;
}
void
DataChannelConnection
:
:
HandleDataMessageChunk
(
const
void
*
data
size_t
length
uint32_t
ppid
uint16_t
stream
uint16_t
messageId
int
flags
)
{
MOZ_ASSERT
(
mSTS
-
>
IsOnCurrentThread
(
)
)
;
DC_DEBUG
(
(
"
%
s
:
stream
%
u
length
%
zu
ppid
%
u
message
-
id
%
u
"
__func__
stream
length
ppid
messageId
)
)
;
DataChannel
*
channel
;
mLock
.
AssertCurrentThreadOwns
(
)
;
channel
=
FindChannelByStream
(
stream
)
;
if
(
!
channel
)
{
DC_DEBUG
(
(
"
Queuing
data
for
stream
%
u
length
%
zu
"
stream
length
)
)
;
mQueuedData
.
AppendElement
(
new
QueuedDataMessage
(
stream
ppid
messageId
flags
static_cast
<
const
uint8_t
*
>
(
data
)
length
)
)
;
return
;
}
channel
-
>
mConnection
-
>
mLock
.
AssertCurrentThreadOwns
(
)
;
channel
-
>
mWaitingForAck
=
false
;
const
char
*
type
=
(
ppid
=
=
DATA_CHANNEL_PPID_DOMSTRING_PARTIAL
|
|
ppid
=
=
DATA_CHANNEL_PPID_DOMSTRING
|
|
ppid
=
=
DATA_CHANNEL_PPID_DOMSTRING_EMPTY
)
?
"
string
"
:
"
binary
"
;
auto
it
=
channel
-
>
mRecvBuffers
.
find
(
messageId
)
;
if
(
it
!
=
channel
-
>
mRecvBuffers
.
end
(
)
)
{
IncomingMsg
&
msg
(
it
-
>
second
)
;
if
(
!
ReassembleMessageChunk
(
msg
data
length
ppid
stream
)
)
{
FinishClose_s
(
channel
)
;
return
;
}
if
(
flags
&
MSG_EOR
)
{
DC_DEBUG
(
(
"
%
s
:
last
chunk
of
multi
-
chunk
%
s
message
id
%
u
"
"
stream
%
u
length
%
zu
"
__func__
type
messageId
stream
length
)
)
;
HandleDataMessage
(
std
:
:
move
(
msg
)
)
;
channel
-
>
mRecvBuffers
.
erase
(
messageId
)
;
}
else
{
DC_DEBUG
(
(
"
%
s
:
middle
chunk
of
multi
-
chunk
%
s
message
id
%
u
"
"
stream
%
u
length
%
zu
"
__func__
type
messageId
stream
length
)
)
;
}
return
;
}
IncomingMsg
msg
(
ppid
stream
)
;
if
(
!
ReassembleMessageChunk
(
msg
data
length
ppid
stream
)
)
{
FinishClose_s
(
channel
)
;
return
;
}
if
(
flags
&
MSG_EOR
)
{
DC_DEBUG
(
(
"
%
s
:
single
-
chunk
%
s
message
id
%
u
stream
%
u
"
"
length
%
zu
"
__func__
type
messageId
stream
length
)
)
;
HandleDataMessage
(
std
:
:
move
(
msg
)
)
;
}
else
{
DC_DEBUG
(
(
"
%
s
:
first
chunk
of
multi
-
chunk
%
s
message
id
%
u
"
"
stream
%
u
length
%
zu
"
__func__
type
messageId
stream
length
)
)
;
channel
-
>
mRecvBuffers
.
insert
(
{
messageId
std
:
:
move
(
msg
)
}
)
;
}
}
void
DataChannelConnection
:
:
HandleDataMessage
(
IncomingMsg
&
&
aMsg
)
{
MOZ_ASSERT
(
mSTS
-
>
IsOnCurrentThread
(
)
)
;
DataChannelOnMessageAvailable
:
:
EventType
type
;
size_t
data_length
=
aMsg
.
GetData
(
)
.
Length
(
)
;
mLock
.
AssertCurrentThreadOwns
(
)
;
RefPtr
<
DataChannel
>
channel
=
FindChannelByStream
(
aMsg
.
GetStreamId
(
)
)
;
if
(
!
channel
)
{
MOZ_ASSERT
(
false
"
Wait
until
OnStreamOpenAck
is
called
before
calling
"
"
HandleDataMessage
!
"
)
;
return
;
}
channel
-
>
mConnection
-
>
mLock
.
AssertCurrentThreadOwns
(
)
;
switch
(
aMsg
.
GetPpid
(
)
)
{
case
DATA_CHANNEL_PPID_DOMSTRING
:
case
DATA_CHANNEL_PPID_DOMSTRING_PARTIAL
:
DC_DEBUG
(
(
"
DataChannel
:
Received
string
message
of
length
%
zu
on
"
"
channel
%
u
"
data_length
channel
-
>
mStream
)
)
;
type
=
DataChannelOnMessageAvailable
:
:
EventType
:
:
OnDataString
;
break
;
case
DATA_CHANNEL_PPID_DOMSTRING_EMPTY
:
DC_DEBUG
(
(
"
DataChannel
:
Received
empty
string
message
of
length
%
zu
on
channel
"
"
%
u
"
data_length
channel
-
>
mStream
)
)
;
aMsg
.
GetData
(
)
.
Truncate
(
0
)
;
type
=
DataChannelOnMessageAvailable
:
:
EventType
:
:
OnDataString
;
break
;
case
DATA_CHANNEL_PPID_BINARY
:
case
DATA_CHANNEL_PPID_BINARY_PARTIAL
:
DC_DEBUG
(
(
"
DataChannel
:
Received
binary
message
of
length
%
zu
on
"
"
channel
id
%
u
"
data_length
channel
-
>
mStream
)
)
;
type
=
DataChannelOnMessageAvailable
:
:
EventType
:
:
OnDataBinary
;
break
;
case
DATA_CHANNEL_PPID_BINARY_EMPTY
:
DC_DEBUG
(
(
"
DataChannel
:
Received
empty
binary
message
of
length
%
zu
on
channel
"
"
id
%
u
"
data_length
channel
-
>
mStream
)
)
;
aMsg
.
GetData
(
)
.
Truncate
(
0
)
;
type
=
DataChannelOnMessageAvailable
:
:
EventType
:
:
OnDataBinary
;
break
;
default
:
NS_ERROR
(
"
Unknown
data
PPID
"
)
;
DC_ERROR
(
(
"
Unknown
data
PPID
%
"
PRIu32
aMsg
.
GetPpid
(
)
)
)
;
return
;
}
Dispatch
(
NS_NewRunnableFunction
(
"
DataChannelConnection
:
:
HandleDataMessage
"
[
channel
data_length
]
(
)
{
channel
-
>
mTrafficCounters
.
mMessagesReceived
+
+
;
channel
-
>
mTrafficCounters
.
mBytesReceived
+
=
data_length
;
}
)
)
;
DC_DEBUG
(
(
"
%
s
:
sending
%
s
for
%
p
"
__FUNCTION__
ToString
(
type
)
channel
.
get
(
)
)
)
;
channel
-
>
SendOrQueue
(
new
DataChannelOnMessageAvailable
(
type
this
channel
std
:
:
move
(
aMsg
.
GetData
(
)
)
)
)
;
}
void
DataChannelConnection
:
:
HandleDCEPMessageChunk
(
const
void
*
buffer
size_t
length
uint32_t
ppid
uint16_t
stream
int
flags
)
{
MOZ_ASSERT
(
mSTS
-
>
IsOnCurrentThread
(
)
)
;
mLock
.
AssertCurrentThreadOwns
(
)
;
if
(
!
mRecvBuffer
.
isSome
(
)
)
{
mRecvBuffer
=
Some
(
IncomingMsg
(
ppid
stream
)
)
;
}
if
(
!
ReassembleMessageChunk
(
*
mRecvBuffer
buffer
length
ppid
stream
)
)
{
Stop
(
)
;
return
;
}
if
(
!
(
flags
&
MSG_EOR
)
)
{
DC_DEBUG
(
(
"
%
s
:
No
EOR
waiting
for
more
chunks
"
__func__
)
)
;
return
;
}
DC_DEBUG
(
(
"
%
s
:
EOR
handling
"
__func__
)
)
;
HandleDCEPMessage
(
std
:
:
move
(
*
mRecvBuffer
)
)
;
mRecvBuffer
=
Nothing
(
)
;
}
void
DataChannelConnection
:
:
HandleDCEPMessage
(
IncomingMsg
&
&
aMsg
)
{
const
struct
rtcweb_datachannel_open_request
*
req
;
const
struct
rtcweb_datachannel_ack
*
ack
;
mLock
.
AssertCurrentThreadOwns
(
)
;
req
=
reinterpret_cast
<
const
struct
rtcweb_datachannel_open_request
*
>
(
aMsg
.
GetData
(
)
.
BeginReading
(
)
)
;
size_t
data_length
=
aMsg
.
GetLength
(
)
;
DC_DEBUG
(
(
"
Handling
DCEP
message
of
length
%
zu
"
data_length
)
)
;
if
(
data_length
<
sizeof
(
*
ack
)
)
{
DC_WARN
(
(
"
Ignored
invalid
DCEP
message
(
too
short
)
"
)
)
;
return
;
}
switch
(
req
-
>
msg_type
)
{
case
DATA_CHANNEL_OPEN_REQUEST
:
if
(
NS_WARN_IF
(
data_length
<
sizeof
(
*
req
)
-
1
)
)
{
return
;
}
HandleOpenRequestMessage
(
req
data_length
aMsg
.
GetStreamId
(
)
)
;
break
;
case
DATA_CHANNEL_ACK
:
ack
=
reinterpret_cast
<
const
struct
rtcweb_datachannel_ack
*
>
(
aMsg
.
GetData
(
)
.
BeginReading
(
)
)
;
HandleOpenAckMessage
(
ack
data_length
aMsg
.
GetStreamId
(
)
)
;
break
;
default
:
HandleUnknownMessage
(
aMsg
.
GetPpid
(
)
data_length
aMsg
.
GetStreamId
(
)
)
;
break
;
}
}
bool
DataChannelConnection
:
:
ReassembleMessageChunk
(
IncomingMsg
&
aReassembled
const
void
*
buffer
size_t
length
uint32_t
ppid
uint16_t
stream
)
{
#
if
(
SIZE_MAX
>
UINT32_MAX
)
if
(
length
>
UINT32_MAX
)
{
DC_ERROR
(
(
"
DataChannel
:
Cannot
handle
message
of
size
%
zu
(
max
=
%
u
)
"
length
UINT32_MAX
)
)
;
return
false
;
}
#
endif
if
(
length
+
aReassembled
.
GetLength
(
)
>
WEBRTC_DATACHANNEL_MAX_MESSAGE_SIZE_LOCAL
)
{
DC_ERROR
(
(
"
DataChannel
:
Buffered
message
would
become
too
large
to
handle
"
"
closing
connection
"
)
)
;
return
false
;
}
if
(
aReassembled
.
GetPpid
(
)
!
=
ppid
)
{
NS_WARNING
(
"
DataChannel
message
aborted
by
fragment
type
change
!
"
)
;
return
false
;
}
aReassembled
.
Append
(
(
uint8_t
*
)
buffer
length
)
;
return
true
;
}
void
DataChannelConnection
:
:
HandleMessageChunk
(
const
void
*
buffer
size_t
length
uint32_t
ppid
uint16_t
stream
uint16_t
messageId
int
flags
)
{
MOZ_ASSERT
(
mSTS
-
>
IsOnCurrentThread
(
)
)
;
switch
(
ppid
)
{
case
DATA_CHANNEL_PPID_CONTROL
:
DC_DEBUG
(
(
"
%
s
:
Got
DCEP
message
size
%
zu
"
__func__
length
)
)
;
HandleDCEPMessageChunk
(
buffer
length
ppid
stream
flags
)
;
break
;
case
DATA_CHANNEL_PPID_DOMSTRING_PARTIAL
:
case
DATA_CHANNEL_PPID_DOMSTRING
:
case
DATA_CHANNEL_PPID_DOMSTRING_EMPTY
:
case
DATA_CHANNEL_PPID_BINARY_PARTIAL
:
case
DATA_CHANNEL_PPID_BINARY
:
case
DATA_CHANNEL_PPID_BINARY_EMPTY
:
HandleDataMessageChunk
(
buffer
length
ppid
stream
messageId
flags
)
;
break
;
default
:
DC_ERROR
(
(
"
Unhandled
message
of
length
%
zu
PPID
%
u
on
stream
%
u
received
(
%
s
)
.
"
length
ppid
stream
(
flags
&
MSG_EOR
)
?
"
complete
"
:
"
partial
"
)
)
;
break
;
}
}
void
DataChannelConnection
:
:
HandleAssociationChangeEvent
(
const
struct
sctp_assoc_change
*
sac
)
{
MOZ_ASSERT
(
mSTS
-
>
IsOnCurrentThread
(
)
)
;
mLock
.
AssertCurrentThreadOwns
(
)
;
uint32_t
i
n
;
DataChannelConnectionState
state
=
GetState
(
)
;
switch
(
sac
-
>
sac_state
)
{
case
SCTP_COMM_UP
:
DC_DEBUG
(
(
"
Association
change
:
SCTP_COMM_UP
"
)
)
;
if
(
state
=
=
DataChannelConnectionState
:
:
Connecting
)
{
SetState
(
DataChannelConnectionState
:
:
Open
)
;
DC_DEBUG
(
(
"
Negotiated
number
of
incoming
streams
:
%
"
PRIu16
sac
-
>
sac_inbound_streams
)
)
;
DC_DEBUG
(
(
"
Negotiated
number
of
outgoing
streams
:
%
"
PRIu16
sac
-
>
sac_outbound_streams
)
)
;
mNegotiatedIdLimit
=
std
:
:
max
(
mNegotiatedIdLimit
std
:
:
max
(
sac
-
>
sac_outbound_streams
sac
-
>
sac_inbound_streams
)
)
;
Dispatch
(
do_AddRef
(
new
DataChannelOnMessageAvailable
(
DataChannelOnMessageAvailable
:
:
EventType
:
:
OnConnection
this
)
)
)
;
DC_DEBUG
(
(
"
DTLS
connect
(
)
succeeded
!
Entering
connected
mode
"
)
)
;
ProcessQueuedOpens
(
)
;
}
else
if
(
state
=
=
DataChannelConnectionState
:
:
Open
)
{
DC_DEBUG
(
(
"
DataConnection
Already
OPEN
"
)
)
;
}
else
{
DC_ERROR
(
(
"
Unexpected
state
:
%
s
"
ToString
(
state
)
)
)
;
}
break
;
case
SCTP_COMM_LOST
:
DC_DEBUG
(
(
"
Association
change
:
SCTP_COMM_LOST
"
)
)
;
Stop
(
)
;
break
;
case
SCTP_RESTART
:
DC_DEBUG
(
(
"
Association
change
:
SCTP_RESTART
"
)
)
;
break
;
case
SCTP_SHUTDOWN_COMP
:
DC_DEBUG
(
(
"
Association
change
:
SCTP_SHUTDOWN_COMP
"
)
)
;
Stop
(
)
;
break
;
case
SCTP_CANT_STR_ASSOC
:
DC_DEBUG
(
(
"
Association
change
:
SCTP_CANT_STR_ASSOC
"
)
)
;
break
;
default
:
DC_DEBUG
(
(
"
Association
change
:
UNKNOWN
"
)
)
;
break
;
}
DC_DEBUG
(
(
"
Association
change
:
streams
(
in
/
out
)
=
(
%
u
/
%
u
)
"
sac
-
>
sac_inbound_streams
sac
-
>
sac_outbound_streams
)
)
;
if
(
NS_WARN_IF
(
!
sac
)
)
{
return
;
}
n
=
sac
-
>
sac_length
-
sizeof
(
*
sac
)
;
if
(
(
sac
-
>
sac_state
=
=
SCTP_COMM_UP
)
|
|
(
sac
-
>
sac_state
=
=
SCTP_RESTART
)
)
{
if
(
n
>
0
)
{
for
(
i
=
0
;
i
<
n
;
+
+
i
)
{
switch
(
sac
-
>
sac_info
[
i
]
)
{
case
SCTP_ASSOC_SUPPORTS_PR
:
DC_DEBUG
(
(
"
Supports
:
PR
"
)
)
;
break
;
case
SCTP_ASSOC_SUPPORTS_AUTH
:
DC_DEBUG
(
(
"
Supports
:
AUTH
"
)
)
;
break
;
case
SCTP_ASSOC_SUPPORTS_ASCONF
:
DC_DEBUG
(
(
"
Supports
:
ASCONF
"
)
)
;
break
;
case
SCTP_ASSOC_SUPPORTS_MULTIBUF
:
DC_DEBUG
(
(
"
Supports
:
MULTIBUF
"
)
)
;
break
;
case
SCTP_ASSOC_SUPPORTS_RE_CONFIG
:
DC_DEBUG
(
(
"
Supports
:
RE
-
CONFIG
"
)
)
;
break
;
#
if
defined
(
SCTP_ASSOC_SUPPORTS_INTERLEAVING
)
case
SCTP_ASSOC_SUPPORTS_INTERLEAVING
:
DC_DEBUG
(
(
"
Supports
:
NDATA
"
)
)
;
mSendInterleaved
=
true
;
break
;
#
endif
default
:
DC_ERROR
(
(
"
Supports
:
UNKNOWN
(
0x
%
02x
)
"
sac
-
>
sac_info
[
i
]
)
)
;
break
;
}
}
}
}
else
if
(
(
(
sac
-
>
sac_state
=
=
SCTP_COMM_LOST
)
|
|
(
sac
-
>
sac_state
=
=
SCTP_CANT_STR_ASSOC
)
)
&
&
(
n
>
0
)
)
{
DC_DEBUG
(
(
"
Association
:
ABORT
=
"
)
)
;
for
(
i
=
0
;
i
<
n
;
+
+
i
)
{
DC_DEBUG
(
(
"
0x
%
02x
"
sac
-
>
sac_info
[
i
]
)
)
;
}
}
if
(
(
sac
-
>
sac_state
=
=
SCTP_CANT_STR_ASSOC
)
|
|
(
sac
-
>
sac_state
=
=
SCTP_SHUTDOWN_COMP
)
|
|
(
sac
-
>
sac_state
=
=
SCTP_COMM_LOST
)
)
{
return
;
}
}
void
DataChannelConnection
:
:
HandlePeerAddressChangeEvent
(
const
struct
sctp_paddr_change
*
spc
)
{
MOZ_ASSERT
(
mSTS
-
>
IsOnCurrentThread
(
)
)
;
const
char
*
addr
=
"
"
;
#
if
!
defined
(
__Userspace_os_Windows
)
char
addr_buf
[
INET6_ADDRSTRLEN
]
;
struct
sockaddr_in
*
sin
;
struct
sockaddr_in6
*
sin6
;
#
endif
switch
(
spc
-
>
spc_aaddr
.
ss_family
)
{
case
AF_INET
:
#
if
!
defined
(
__Userspace_os_Windows
)
sin
=
(
struct
sockaddr_in
*
)
&
spc
-
>
spc_aaddr
;
addr
=
inet_ntop
(
AF_INET
&
sin
-
>
sin_addr
addr_buf
INET6_ADDRSTRLEN
)
;
#
endif
break
;
case
AF_INET6
:
#
if
!
defined
(
__Userspace_os_Windows
)
sin6
=
(
struct
sockaddr_in6
*
)
&
spc
-
>
spc_aaddr
;
addr
=
inet_ntop
(
AF_INET6
&
sin6
-
>
sin6_addr
addr_buf
INET6_ADDRSTRLEN
)
;
#
endif
break
;
case
AF_CONN
:
addr
=
"
DTLS
connection
"
;
break
;
default
:
break
;
}
DC_DEBUG
(
(
"
Peer
address
%
s
is
now
"
addr
)
)
;
switch
(
spc
-
>
spc_state
)
{
case
SCTP_ADDR_AVAILABLE
:
DC_DEBUG
(
(
"
SCTP_ADDR_AVAILABLE
"
)
)
;
break
;
case
SCTP_ADDR_UNREACHABLE
:
DC_DEBUG
(
(
"
SCTP_ADDR_UNREACHABLE
"
)
)
;
break
;
case
SCTP_ADDR_REMOVED
:
DC_DEBUG
(
(
"
SCTP_ADDR_REMOVED
"
)
)
;
break
;
case
SCTP_ADDR_ADDED
:
DC_DEBUG
(
(
"
SCTP_ADDR_ADDED
"
)
)
;
break
;
case
SCTP_ADDR_MADE_PRIM
:
DC_DEBUG
(
(
"
SCTP_ADDR_MADE_PRIM
"
)
)
;
break
;
case
SCTP_ADDR_CONFIRMED
:
DC_DEBUG
(
(
"
SCTP_ADDR_CONFIRMED
"
)
)
;
break
;
default
:
DC_ERROR
(
(
"
UNKNOWN
SCP
STATE
"
)
)
;
break
;
}
if
(
spc
-
>
spc_error
)
{
DC_ERROR
(
(
"
(
error
=
0x
%
08x
)
.
\
n
"
spc
-
>
spc_error
)
)
;
}
}
void
DataChannelConnection
:
:
HandleRemoteErrorEvent
(
const
struct
sctp_remote_error
*
sre
)
{
MOZ_ASSERT
(
mSTS
-
>
IsOnCurrentThread
(
)
)
;
size_t
i
n
;
n
=
sre
-
>
sre_length
-
sizeof
(
struct
sctp_remote_error
)
;
DC_WARN
(
(
"
Remote
Error
(
error
=
0x
%
04x
)
:
"
sre
-
>
sre_error
)
)
;
for
(
i
=
0
;
i
<
n
;
+
+
i
)
{
DC_WARN
(
(
"
0x
%
02x
"
sre
-
>
sre_data
[
i
]
)
)
;
}
}
void
DataChannelConnection
:
:
HandleShutdownEvent
(
const
struct
sctp_shutdown_event
*
sse
)
{
MOZ_ASSERT
(
mSTS
-
>
IsOnCurrentThread
(
)
)
;
DC_DEBUG
(
(
"
Shutdown
event
.
"
)
)
;
}
void
DataChannelConnection
:
:
HandleAdaptationIndication
(
const
struct
sctp_adaptation_event
*
sai
)
{
MOZ_ASSERT
(
mSTS
-
>
IsOnCurrentThread
(
)
)
;
DC_DEBUG
(
(
"
Adaptation
indication
:
%
x
.
"
sai
-
>
sai_adaptation_ind
)
)
;
}
void
DataChannelConnection
:
:
HandlePartialDeliveryEvent
(
const
struct
sctp_pdapi_event
*
spde
)
{
MOZ_ASSERT
(
mSTS
-
>
IsOnCurrentThread
(
)
)
;
DC_DEBUG
(
(
"
Partial
delivery
event
:
"
)
)
;
switch
(
spde
-
>
pdapi_indication
)
{
case
SCTP_PARTIAL_DELIVERY_ABORTED
:
DC_DEBUG
(
(
"
delivery
aborted
"
)
)
;
break
;
default
:
DC_ERROR
(
(
"
?
?
?
"
)
)
;
break
;
}
DC_DEBUG
(
(
"
(
flags
=
%
x
)
stream
=
%
"
PRIu32
"
sn
=
%
"
PRIu32
spde
-
>
pdapi_flags
spde
-
>
pdapi_stream
spde
-
>
pdapi_seq
)
)
;
if
(
spde
-
>
pdapi_stream
>
=
UINT16_MAX
)
{
DC_ERROR
(
(
"
Invalid
stream
id
in
partial
delivery
event
:
%
"
PRIu32
"
\
n
"
spde
-
>
pdapi_stream
)
)
;
return
;
}
DataChannel
*
channel
=
FindChannelByStream
(
(
uint16_t
)
spde
-
>
pdapi_stream
)
;
if
(
channel
)
{
auto
it
=
channel
-
>
mRecvBuffers
.
find
(
spde
-
>
pdapi_seq
)
;
if
(
it
!
=
channel
-
>
mRecvBuffers
.
end
(
)
)
{
DC_WARN
(
(
"
Abort
partially
delivered
message
of
%
zu
bytes
\
n
"
it
-
>
second
.
GetLength
(
)
)
)
;
channel
-
>
mRecvBuffers
.
erase
(
it
)
;
}
else
{
DC_WARN
(
(
"
Abort
partially
delivered
message
that
we
'
ve
never
seen
any
"
"
of
?
What
?
"
)
)
;
}
}
}
void
DataChannelConnection
:
:
HandleSendFailedEvent
(
const
struct
sctp_send_failed_event
*
ssfe
)
{
MOZ_ASSERT
(
mSTS
-
>
IsOnCurrentThread
(
)
)
;
size_t
i
n
;
if
(
ssfe
-
>
ssfe_flags
&
SCTP_DATA_UNSENT
)
{
DC_DEBUG
(
(
"
Unsent
"
)
)
;
}
if
(
ssfe
-
>
ssfe_flags
&
SCTP_DATA_SENT
)
{
DC_DEBUG
(
(
"
Sent
"
)
)
;
}
if
(
ssfe
-
>
ssfe_flags
&
~
(
SCTP_DATA_SENT
|
SCTP_DATA_UNSENT
)
)
{
DC_DEBUG
(
(
"
(
flags
=
%
x
)
"
ssfe
-
>
ssfe_flags
)
)
;
}
#
ifdef
XP_WIN
#
define
PRIPPID
"
lu
"
#
else
#
define
PRIPPID
"
u
"
#
endif
DC_DEBUG
(
(
"
message
with
PPID
=
%
"
PRIPPID
"
SID
=
%
d
flags
:
0x
%
04x
due
to
error
=
0x
%
08x
"
ntohl
(
ssfe
-
>
ssfe_info
.
snd_ppid
)
ssfe
-
>
ssfe_info
.
snd_sid
ssfe
-
>
ssfe_info
.
snd_flags
ssfe
-
>
ssfe_error
)
)
;
#
undef
PRIPPID
n
=
ssfe
-
>
ssfe_length
-
sizeof
(
struct
sctp_send_failed_event
)
;
for
(
i
=
0
;
i
<
n
;
+
+
i
)
{
DC_DEBUG
(
(
"
0x
%
02x
"
ssfe
-
>
ssfe_data
[
i
]
)
)
;
}
}
void
DataChannelConnection
:
:
ClearResets
(
)
{
if
(
!
mStreamsResetting
.
IsEmpty
(
)
)
{
DC_DEBUG
(
(
"
Clearing
resets
for
%
zu
streams
"
mStreamsResetting
.
Length
(
)
)
)
;
}
mStreamsResetting
.
Clear
(
)
;
}
void
DataChannelConnection
:
:
MarkStreamForReset
(
DataChannel
&
aChannel
)
{
MOZ_ASSERT
(
mSTS
-
>
IsOnCurrentThread
(
)
)
;
mLock
.
AssertCurrentThreadOwns
(
)
;
DC_DEBUG
(
(
"
%
s
%
p
:
Resetting
outgoing
stream
%
u
"
__func__
this
aChannel
.
mStream
)
)
;
for
(
size_t
i
=
0
;
i
<
mStreamsResetting
.
Length
(
)
;
+
+
i
)
{
if
(
mStreamsResetting
[
i
]
=
=
aChannel
.
mStream
)
{
return
;
}
}
mStreamsResetting
.
AppendElement
(
aChannel
.
mStream
)
;
}
void
DataChannelConnection
:
:
ResetStreams
(
nsTArray
<
uint16_t
>
&
aStreams
)
{
MOZ_ASSERT
(
mSTS
-
>
IsOnCurrentThread
(
)
)
;
DC_DEBUG
(
(
"
%
s
%
p
:
Sending
outgoing
stream
reset
for
%
zu
streams
"
__func__
this
aStreams
.
Length
(
)
)
)
;
if
(
aStreams
.
IsEmpty
(
)
)
{
DC_DEBUG
(
(
"
No
streams
to
reset
"
)
)
;
return
;
}
const
size_t
len
=
sizeof
(
sctp_reset_streams
)
+
(
aStreams
.
Length
(
)
)
*
sizeof
(
uint16_t
)
;
struct
sctp_reset_streams
*
srs
=
static_cast
<
struct
sctp_reset_streams
*
>
(
moz_xmalloc
(
len
)
)
;
memset
(
srs
0
len
)
;
srs
-
>
srs_flags
=
SCTP_STREAM_RESET_OUTGOING
;
srs
-
>
srs_number_streams
=
aStreams
.
Length
(
)
;
for
(
size_t
i
=
0
;
i
<
aStreams
.
Length
(
)
;
+
+
i
)
{
srs
-
>
srs_stream_list
[
i
]
=
aStreams
[
i
]
;
}
if
(
usrsctp_setsockopt
(
mSocket
IPPROTO_SCTP
SCTP_RESET_STREAMS
srs
(
socklen_t
)
len
)
<
0
)
{
DC_ERROR
(
(
"
*
*
*
failed
:
setsockopt
RESET
errno
%
d
"
errno
)
)
;
}
else
{
aStreams
.
Clear
(
)
;
}
free
(
srs
)
;
}
void
DataChannelConnection
:
:
HandleStreamResetEvent
(
const
struct
sctp_stream_reset_event
*
strrst
)
{
MOZ_ASSERT
(
mSTS
-
>
IsOnCurrentThread
(
)
)
;
mLock
.
AssertCurrentThreadOwns
(
)
;
std
:
:
vector
<
uint16_t
>
streamsReset
;
if
(
!
(
strrst
-
>
strreset_flags
&
SCTP_STREAM_RESET_DENIED
)
&
&
!
(
strrst
-
>
strreset_flags
&
SCTP_STREAM_RESET_FAILED
)
)
{
size_t
n
=
(
strrst
-
>
strreset_length
-
sizeof
(
struct
sctp_stream_reset_event
)
)
/
sizeof
(
uint16_t
)
;
for
(
size_t
i
=
0
;
i
<
n
;
+
+
i
)
{
if
(
strrst
-
>
strreset_flags
&
SCTP_STREAM_RESET_INCOMING_SSN
)
{
streamsReset
.
push_back
(
strrst
-
>
strreset_stream_list
[
i
]
)
;
}
}
}
OnStreamsReset
(
std
:
:
move
(
streamsReset
)
)
;
}
void
DataChannelConnection
:
:
OnStreamsReset
(
std
:
:
vector
<
uint16_t
>
&
&
aStreams
)
{
mLock
.
AssertCurrentThreadOwns
(
)
;
for
(
auto
stream
:
aStreams
)
{
auto
channel
=
FindChannelByStream
(
stream
)
;
if
(
channel
)
{
DC_DEBUG
(
(
"
Connection
%
p
:
stream
%
u
closed
"
this
stream
)
)
;
DC_DEBUG
(
(
"
Disconnected
DataChannel
%
p
from
connection
%
p
"
(
void
*
)
channel
this
)
)
;
FinishClose_s
(
channel
)
;
}
else
{
DC_WARN
(
(
"
Connection
%
p
:
Can
'
t
find
incoming
stream
%
u
"
this
stream
)
)
;
}
}
Dispatch
(
NS_NewRunnableFunction
(
"
DataChannelConnection
:
:
HandleStreamResetEvent
"
[
this
self
=
RefPtr
<
DataChannelConnection
>
(
this
)
streamsReset
=
std
:
:
move
(
aStreams
)
]
(
)
{
for
(
auto
stream
:
streamsReset
)
{
mStreamIds
.
RemoveElementSorted
(
stream
)
;
}
}
)
)
;
if
(
!
mStreamsResetting
.
IsEmpty
(
)
)
{
DC_DEBUG
(
(
"
Sending
%
zu
pending
resets
"
mStreamsResetting
.
Length
(
)
)
)
;
ResetStreams
(
mStreamsResetting
)
;
}
}
void
DataChannelConnection
:
:
HandleStreamChangeEvent
(
const
struct
sctp_stream_change_event
*
strchg
)
{
MOZ_ASSERT
(
mSTS
-
>
IsOnCurrentThread
(
)
)
;
mLock
.
AssertCurrentThreadOwns
(
)
;
if
(
strchg
-
>
strchange_flags
=
=
SCTP_STREAM_CHANGE_DENIED
)
{
DC_ERROR
(
(
"
*
*
*
Failed
increasing
number
of
streams
from
%
u
(
%
u
/
%
u
)
"
mNegotiatedIdLimit
strchg
-
>
strchange_instrms
strchg
-
>
strchange_outstrms
)
)
;
return
;
}
if
(
strchg
-
>
strchange_instrms
>
mNegotiatedIdLimit
)
{
DC_DEBUG
(
(
"
Other
side
increased
streams
from
%
u
to
%
u
"
mNegotiatedIdLimit
strchg
-
>
strchange_instrms
)
)
;
}
uint16_t
old_limit
=
mNegotiatedIdLimit
;
uint16_t
new_limit
=
std
:
:
min
(
(
uint16_t
)
MAX_NUM_STREAMS
std
:
:
max
(
strchg
-
>
strchange_outstrms
strchg
-
>
strchange_instrms
)
)
;
if
(
new_limit
>
mNegotiatedIdLimit
)
{
DC_DEBUG
(
(
"
Increasing
number
of
streams
from
%
u
to
%
u
-
adding
%
u
(
in
:
%
u
)
"
old_limit
new_limit
new_limit
-
old_limit
strchg
-
>
strchange_instrms
)
)
;
mNegotiatedIdLimit
=
new_limit
;
DC_DEBUG
(
(
"
New
length
=
%
u
(
was
%
u
)
"
mNegotiatedIdLimit
old_limit
)
)
;
auto
channels
=
mChannels
.
GetAll
(
)
;
size_t
num_needed
=
channels
.
Length
(
)
?
(
channels
.
LastElement
(
)
-
>
mStream
+
1
)
:
0
;
Maybe
<
uint16_t
>
num_desired
;
MOZ_ASSERT
(
num_needed
!
=
INVALID_STREAM
)
;
if
(
num_needed
>
new_limit
)
{
num_desired
=
Some
(
std
:
:
min
(
16
*
(
num_needed
/
16
+
1
)
(
size_t
)
MAX_NUM_STREAMS
)
)
;
DC_DEBUG
(
(
"
Not
enough
new
streams
asking
for
%
u
"
*
num_desired
)
)
;
}
else
if
(
strchg
-
>
strchange_outstrms
<
strchg
-
>
strchange_instrms
)
{
num_desired
=
Some
(
strchg
-
>
strchange_instrms
)
;
DC_DEBUG
(
(
"
Requesting
%
u
output
streams
to
match
partner
"
*
num_desired
)
)
;
}
if
(
num_desired
.
isSome
(
)
)
{
RaiseStreamLimitTo
(
*
num_desired
)
;
}
ProcessQueuedOpens
(
)
;
}
if
(
(
strchg
-
>
strchange_flags
&
SCTP_STREAM_CHANGE_DENIED
)
|
|
(
strchg
-
>
strchange_flags
&
SCTP_STREAM_CHANGE_FAILED
)
)
{
for
(
auto
&
channel
:
mChannels
.
GetAll
(
)
)
{
if
(
channel
-
>
mStream
>
=
mNegotiatedIdLimit
)
{
FinishClose_s
(
channel
)
;
}
}
}
}
void
DataChannelConnection
:
:
HandleNotification
(
const
union
sctp_notification
*
notif
size_t
n
)
{
mLock
.
AssertCurrentThreadOwns
(
)
;
MOZ_ASSERT
(
mSTS
-
>
IsOnCurrentThread
(
)
)
;
if
(
notif
-
>
sn_header
.
sn_length
!
=
(
uint32_t
)
n
)
{
return
;
}
switch
(
notif
-
>
sn_header
.
sn_type
)
{
case
SCTP_ASSOC_CHANGE
:
HandleAssociationChangeEvent
(
&
(
notif
-
>
sn_assoc_change
)
)
;
break
;
case
SCTP_PEER_ADDR_CHANGE
:
HandlePeerAddressChangeEvent
(
&
(
notif
-
>
sn_paddr_change
)
)
;
break
;
case
SCTP_REMOTE_ERROR
:
HandleRemoteErrorEvent
(
&
(
notif
-
>
sn_remote_error
)
)
;
break
;
case
SCTP_SHUTDOWN_EVENT
:
HandleShutdownEvent
(
&
(
notif
-
>
sn_shutdown_event
)
)
;
break
;
case
SCTP_ADAPTATION_INDICATION
:
HandleAdaptationIndication
(
&
(
notif
-
>
sn_adaptation_event
)
)
;
break
;
case
SCTP_AUTHENTICATION_EVENT
:
DC_DEBUG
(
(
"
SCTP_AUTHENTICATION_EVENT
"
)
)
;
break
;
case
SCTP_SENDER_DRY_EVENT
:
break
;
case
SCTP_NOTIFICATIONS_STOPPED_EVENT
:
DC_DEBUG
(
(
"
SCTP_NOTIFICATIONS_STOPPED_EVENT
"
)
)
;
break
;
case
SCTP_PARTIAL_DELIVERY_EVENT
:
HandlePartialDeliveryEvent
(
&
(
notif
-
>
sn_pdapi_event
)
)
;
break
;
case
SCTP_SEND_FAILED_EVENT
:
HandleSendFailedEvent
(
&
(
notif
-
>
sn_send_failed_event
)
)
;
break
;
case
SCTP_STREAM_RESET_EVENT
:
HandleStreamResetEvent
(
&
(
notif
-
>
sn_strreset_event
)
)
;
break
;
case
SCTP_ASSOC_RESET_EVENT
:
DC_DEBUG
(
(
"
SCTP_ASSOC_RESET_EVENT
"
)
)
;
break
;
case
SCTP_STREAM_CHANGE_EVENT
:
HandleStreamChangeEvent
(
&
(
notif
-
>
sn_strchange_event
)
)
;
break
;
default
:
DC_ERROR
(
(
"
unknown
SCTP
event
:
%
u
"
(
uint32_t
)
notif
-
>
sn_header
.
sn_type
)
)
;
break
;
}
}
int
DataChannelConnection
:
:
ReceiveCallback
(
struct
socket
*
sock
void
*
data
size_t
datalen
struct
sctp_rcvinfo
rcv
int
flags
)
{
ASSERT_WEBRTC
(
!
NS_IsMainThread
(
)
)
;
DC_DEBUG
(
(
"
In
ReceiveCallback
"
)
)
;
mSTS
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
DataChannelConnection
:
:
ReceiveCallback
"
[
data
datalen
rcv
flags
this
self
=
RefPtr
<
DataChannelConnection
>
(
this
)
]
(
)
mutable
{
if
(
!
data
)
{
DC_DEBUG
(
(
"
ReceiveCallback
:
SCTP
has
finished
shutting
down
"
)
)
;
}
else
{
mLock
.
Lock
(
)
;
if
(
flags
&
MSG_NOTIFICATION
)
{
HandleNotification
(
static_cast
<
union
sctp_notification
*
>
(
data
)
datalen
)
;
}
else
{
HandleMessageChunk
(
data
datalen
ntohl
(
rcv
.
rcv_ppid
)
rcv
.
rcv_sid
rcv
.
rcv_ssn
flags
)
;
}
mLock
.
Unlock
(
)
;
free
(
data
)
;
}
}
)
)
;
return
1
;
}
already_AddRefed
<
DataChannel
>
DataChannelConnection
:
:
Open
(
const
nsACString
&
label
const
nsACString
&
protocol
DataChannelReliabilityPolicy
prPolicy
bool
inOrder
uint32_t
prValue
DataChannelListener
*
aListener
nsISupports
*
aContext
bool
aExternalNegotiated
uint16_t
aStream
)
{
ASSERT_WEBRTC
(
NS_IsMainThread
(
)
)
;
MutexAutoLock
lock
(
mLock
)
;
if
(
!
aExternalNegotiated
)
{
if
(
mAllocateEven
.
isSome
(
)
)
{
aStream
=
FindFreeStream
(
)
;
if
(
aStream
=
=
INVALID_STREAM
)
{
return
nullptr
;
}
}
else
{
aStream
=
INVALID_STREAM
;
}
}
DC_DEBUG
(
(
"
DC
Open
:
label
%
s
/
%
s
type
%
s
inorder
%
d
prValue
%
u
listener
%
p
"
"
context
%
p
external
:
%
s
stream
%
u
"
PromiseFlatCString
(
label
)
.
get
(
)
PromiseFlatCString
(
protocol
)
.
get
(
)
ToString
(
prPolicy
)
inOrder
prValue
aListener
aContext
aExternalNegotiated
?
"
true
"
:
"
false
"
aStream
)
)
;
if
(
(
prPolicy
=
=
DataChannelReliabilityPolicy
:
:
Reliable
)
&
&
(
prValue
!
=
0
)
)
{
return
nullptr
;
}
if
(
aStream
!
=
INVALID_STREAM
)
{
if
(
mStreamIds
.
ContainsSorted
(
aStream
)
)
{
DC_ERROR
(
(
"
external
negotiation
of
already
-
open
channel
%
u
"
aStream
)
)
;
return
nullptr
;
}
DC_DEBUG
(
(
"
%
s
%
p
:
Inserting
externally
-
negotiated
id
%
u
"
__func__
this
static_cast
<
unsigned
>
(
aStream
)
)
)
;
mStreamIds
.
InsertElementSorted
(
aStream
)
;
}
RefPtr
<
DataChannel
>
channel
(
new
DataChannel
(
this
aStream
DataChannelState
:
:
Connecting
label
protocol
prPolicy
prValue
inOrder
aExternalNegotiated
aListener
aContext
)
)
;
mChannels
.
Insert
(
channel
)
;
if
(
aStream
!
=
INVALID_STREAM
)
{
mSTS
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
DataChannel
:
:
OpenFinish
"
[
this
self
=
RefPtr
<
DataChannelConnection
>
(
this
)
channel
]
(
)
mutable
{
MutexAutoLock
lock
(
mLock
)
;
OpenFinish
(
channel
)
;
}
)
)
;
}
return
channel
.
forget
(
)
;
}
void
DataChannelConnection
:
:
OpenFinish
(
RefPtr
<
DataChannel
>
aChannel
)
{
MOZ_ASSERT
(
mSTS
-
>
IsOnCurrentThread
(
)
)
;
mLock
.
AssertCurrentThreadOwns
(
)
;
const
uint16_t
stream
=
aChannel
-
>
mStream
;
DataChannelConnectionState
state
=
GetState
(
)
;
if
(
state
!
=
DataChannelConnectionState
:
:
Open
|
|
stream
>
=
mNegotiatedIdLimit
)
{
if
(
state
=
=
DataChannelConnectionState
:
:
Open
)
{
MOZ_ASSERT
(
stream
!
=
INVALID_STREAM
)
;
uint16_t
num_desired
=
std
:
:
min
(
16
*
(
stream
/
16
+
1
)
MAX_NUM_STREAMS
)
;
DC_DEBUG
(
(
"
Attempting
to
raise
stream
limit
%
u
-
>
%
u
"
mNegotiatedIdLimit
num_desired
)
)
;
if
(
!
RaiseStreamLimitTo
(
num_desired
)
)
{
NS_ERROR
(
"
Failed
to
request
more
streams
"
)
;
FinishClose_s
(
aChannel
)
;
return
;
}
}
DC_DEBUG
(
(
"
Queuing
channel
%
p
(
%
u
)
to
finish
open
"
aChannel
.
get
(
)
stream
)
)
;
mPending
.
insert
(
aChannel
)
;
return
;
}
MOZ_ASSERT
(
stream
!
=
INVALID_STREAM
)
;
MOZ_ASSERT
(
stream
<
mNegotiatedIdLimit
)
;
if
(
!
aChannel
-
>
mNegotiated
)
{
if
(
!
aChannel
-
>
mOrdered
)
{
aChannel
-
>
mWaitingForAck
=
true
;
}
const
int
error
=
SendOpenRequestMessage
(
*
aChannel
)
;
if
(
error
)
{
DC_ERROR
(
(
"
SendOpenRequest
failed
error
=
%
d
"
error
)
)
;
FinishClose_s
(
aChannel
)
;
return
;
}
}
aChannel
-
>
AnnounceOpen
(
)
;
}
int
DataChannelConnection
:
:
SendMsgInternal
(
OutgoingMsg
&
msg
size_t
*
aWritten
)
{
MOZ_ASSERT
(
mSTS
-
>
IsOnCurrentThread
(
)
)
;
mLock
.
AssertCurrentThreadOwns
(
)
;
struct
sctp_sendv_spa
info
=
{
}
;
info
.
sendv_flags
=
SCTP_SEND_SNDINFO_VALID
;
info
.
sendv_sndinfo
.
snd_sid
=
msg
.
GetMetadata
(
)
.
mStreamId
;
info
.
sendv_sndinfo
.
snd_ppid
=
htonl
(
msg
.
GetMetadata
(
)
.
mPpid
)
;
if
(
msg
.
GetMetadata
(
)
.
mUnordered
)
{
info
.
sendv_sndinfo
.
snd_flags
|
=
SCTP_UNORDERED
;
}
msg
.
GetMetadata
(
)
.
mMaxLifetimeMs
.
apply
(
[
&
]
(
auto
value
)
{
info
.
sendv_prinfo
.
pr_policy
=
SCTP_PR_SCTP_TTL
;
info
.
sendv_prinfo
.
pr_value
=
value
;
info
.
sendv_flags
|
=
SCTP_SEND_PRINFO_VALID
;
}
)
;
msg
.
GetMetadata
(
)
.
mMaxRetransmissions
.
apply
(
[
&
]
(
auto
value
)
{
info
.
sendv_prinfo
.
pr_policy
=
SCTP_PR_SCTP_RTX
;
info
.
sendv_prinfo
.
pr_value
=
value
;
info
.
sendv_flags
|
=
SCTP_SEND_PRINFO_VALID
;
}
)
;
Span
<
const
uint8_t
>
chunk
=
msg
.
GetRemainingData
(
)
;
do
{
if
(
chunk
.
Length
(
)
<
=
DATA_CHANNEL_MAX_BINARY_FRAGMENT
)
{
info
.
sendv_sndinfo
.
snd_flags
|
=
SCTP_EOR
;
}
else
{
chunk
=
chunk
.
To
(
DATA_CHANNEL_MAX_BINARY_FRAGMENT
)
;
}
const
ssize_t
writtenOrError
=
usrsctp_sendv
(
mSocket
chunk
.
Elements
(
)
chunk
.
Length
(
)
nullptr
0
(
void
*
)
&
info
(
socklen_t
)
sizeof
(
struct
sctp_sendv_spa
)
SCTP_SENDV_SPA
0
)
;
if
(
writtenOrError
<
0
)
{
return
errno
;
}
const
size_t
written
=
writtenOrError
;
if
(
aWritten
&
&
msg
.
GetMetadata
(
)
.
mPpid
!
=
DATA_CHANNEL_PPID_DOMSTRING_EMPTY
&
&
msg
.
GetMetadata
(
)
.
mPpid
!
=
DATA_CHANNEL_PPID_BINARY_EMPTY
)
{
*
aWritten
+
=
written
;
}
DC_DEBUG
(
(
"
Sent
buffer
(
written
=
%
zu
len
=
%
zu
left
=
%
zu
)
"
written
chunk
.
Length
(
)
msg
.
GetRemainingData
(
)
.
Length
(
)
-
written
)
)
;
if
(
written
=
=
0
)
{
DC_ERROR
(
(
"
tuexen
:
usrsctp_sendv
returned
0
"
)
)
;
return
EAGAIN
;
}
msg
.
Advance
(
written
)
;
if
(
written
<
chunk
.
Length
(
)
)
{
return
EAGAIN
;
}
chunk
=
msg
.
GetRemainingData
(
)
;
}
while
(
chunk
.
Length
(
)
>
0
)
;
return
0
;
}
int
DataChannelConnection
:
:
SendMsgInternalOrBuffer
(
nsTArray
<
OutgoingMsg
>
&
buffer
OutgoingMsg
&
&
msg
bool
*
buffered
size_t
*
aWritten
)
{
MOZ_ASSERT
(
mSTS
-
>
IsOnCurrentThread
(
)
)
;
NS_WARNING_ASSERTION
(
msg
.
GetLength
(
)
>
0
"
Length
is
0
?
!
"
)
;
int
error
=
0
;
bool
need_buffering
=
false
;
mLock
.
AssertCurrentThreadOwns
(
)
;
if
(
buffer
.
IsEmpty
(
)
&
&
(
mSendInterleaved
|
|
mPendingType
=
=
PendingType
:
:
None
)
)
{
error
=
SendMsgInternal
(
msg
aWritten
)
;
switch
(
error
)
{
case
0
:
break
;
case
EAGAIN
:
#
if
(
EAGAIN
!
=
EWOULDBLOCK
)
case
EWOULDBLOCK
:
#
endif
need_buffering
=
true
;
break
;
default
:
DC_ERROR
(
(
"
error
%
d
on
sending
"
error
)
)
;
break
;
}
}
else
{
need_buffering
=
true
;
}
if
(
need_buffering
)
{
buffer
.
EmplaceBack
(
std
:
:
move
(
msg
)
)
;
DC_DEBUG
(
(
"
Queued
%
zu
buffers
(
left
=
%
zu
total
=
%
zu
)
"
buffer
.
Length
(
)
buffer
.
LastElement
(
)
.
GetLength
(
)
msg
.
GetLength
(
)
)
)
;
if
(
buffered
)
{
*
buffered
=
true
;
}
return
0
;
}
if
(
buffered
)
{
*
buffered
=
false
;
}
return
error
;
}
class
ReadBlobRunnable
:
public
Runnable
{
public
:
ReadBlobRunnable
(
DataChannelConnection
*
aConnection
uint16_t
aStream
nsIInputStream
*
aBlob
)
:
Runnable
(
"
ReadBlobRunnable
"
)
mConnection
(
aConnection
)
mStream
(
aStream
)
mBlob
(
aBlob
)
{
}
NS_IMETHOD
Run
(
)
override
{
DataChannelConnection
*
self
=
mConnection
;
self
-
>
ReadBlob
(
mConnection
.
forget
(
)
mStream
mBlob
)
;
return
NS_OK
;
}
private
:
RefPtr
<
DataChannelConnection
>
mConnection
;
uint16_t
mStream
;
RefPtr
<
nsIInputStream
>
mBlob
;
}
;
int
DataChannelConnection
:
:
SendBlob
(
uint16_t
stream
nsIInputStream
*
aBlob
)
{
MutexAutoLock
lock
(
mLock
)
;
RefPtr
<
DataChannel
>
channel
=
mChannels
.
Get
(
stream
)
;
if
(
NS_WARN_IF
(
!
channel
)
)
{
return
EINVAL
;
}
if
(
!
mInternalIOThread
)
{
nsresult
rv
=
NS_NewNamedThread
(
"
DataChannel
IO
"
getter_AddRefs
(
mInternalIOThread
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
EINVAL
;
}
}
mInternalIOThread
-
>
Dispatch
(
do_AddRef
(
new
ReadBlobRunnable
(
this
stream
aBlob
)
)
NS_DISPATCH_NORMAL
)
;
return
0
;
}
class
DataChannelBlobSendRunnable
:
public
Runnable
{
public
:
DataChannelBlobSendRunnable
(
already_AddRefed
<
DataChannelConnection
>
&
aConnection
uint16_t
aStream
)
:
Runnable
(
"
DataChannelBlobSendRunnable
"
)
mConnection
(
aConnection
)
mStream
(
aStream
)
{
}
~
DataChannelBlobSendRunnable
(
)
override
{
if
(
!
NS_IsMainThread
(
)
&
&
mConnection
)
{
MOZ_ASSERT
(
false
)
;
Unused
<
<
mConnection
.
forget
(
)
.
take
(
)
;
}
}
NS_IMETHOD
Run
(
)
override
{
ASSERT_WEBRTC
(
NS_IsMainThread
(
)
)
;
mConnection
-
>
SendBinaryMessage
(
mStream
std
:
:
move
(
mData
)
)
;
mConnection
=
nullptr
;
return
NS_OK
;
}
nsCString
mData
;
private
:
RefPtr
<
DataChannelConnection
>
mConnection
;
uint16_t
mStream
;
}
;
void
DataChannelConnection
:
:
SetState
(
DataChannelConnectionState
aState
)
{
mLock
.
AssertCurrentThreadOwns
(
)
;
MOZ_ASSERT
(
mSTS
-
>
IsOnCurrentThread
(
)
)
;
DC_DEBUG
(
(
"
DataChannelConnection
labeled
%
s
(
%
p
)
switching
connection
state
%
s
-
>
"
"
%
s
"
mTransportId
.
c_str
(
)
this
ToString
(
mState
)
ToString
(
aState
)
)
)
;
mState
=
aState
;
}
void
DataChannelConnection
:
:
ReadBlob
(
already_AddRefed
<
DataChannelConnection
>
aThis
uint16_t
aStream
nsIInputStream
*
aBlob
)
{
RefPtr
<
DataChannelBlobSendRunnable
>
runnable
=
new
DataChannelBlobSendRunnable
(
aThis
aStream
)
;
if
(
NS_FAILED
(
NS_ReadInputStreamToString
(
aBlob
runnable
-
>
mData
-
1
)
)
)
{
NS_ReleaseOnMainThread
(
"
DataChannelBlobSendRunnable
"
runnable
.
forget
(
)
)
;
return
;
}
aBlob
-
>
Close
(
)
;
Dispatch
(
runnable
.
forget
(
)
)
;
}
int
DataChannelConnection
:
:
SendDataMessage
(
uint16_t
aStream
nsACString
&
&
aMsg
bool
aIsBinary
)
{
ASSERT_WEBRTC
(
NS_IsMainThread
(
)
)
;
MutexAutoLock
lock
(
mLock
)
;
if
(
mMaxMessageSize
!
=
0
&
&
aMsg
.
Length
(
)
>
mMaxMessageSize
)
{
DC_ERROR
(
(
"
Message
rejected
too
large
(
%
zu
>
%
"
PRIu64
"
)
"
aMsg
.
Length
(
)
mMaxMessageSize
)
)
;
return
EMSGSIZE
;
}
nsCString
temp
(
std
:
:
move
(
aMsg
)
)
;
mSTS
-
>
Dispatch
(
NS_NewRunnableFunction
(
__func__
[
this
self
=
RefPtr
<
DataChannelConnection
>
(
this
)
aStream
msg
=
std
:
:
move
(
temp
)
aIsBinary
]
(
)
mutable
{
MutexAutoLock
lock
(
mLock
)
;
RefPtr
<
DataChannel
>
channel
=
FindChannelByStream
(
aStream
)
;
if
(
!
channel
)
{
return
;
}
Maybe
<
uint16_t
>
maxRetransmissions
;
Maybe
<
uint16_t
>
maxLifetimeMs
;
switch
(
channel
-
>
mPrPolicy
)
{
case
DataChannelReliabilityPolicy
:
:
Reliable
:
break
;
case
DataChannelReliabilityPolicy
:
:
LimitedRetransmissions
:
maxRetransmissions
=
Some
(
channel
-
>
mPrValue
)
;
break
;
case
DataChannelReliabilityPolicy
:
:
LimitedLifetime
:
maxLifetimeMs
=
Some
(
channel
-
>
mPrValue
)
;
break
;
}
uint32_t
ppid
;
if
(
aIsBinary
)
{
if
(
msg
.
Length
(
)
)
{
ppid
=
DATA_CHANNEL_PPID_BINARY
;
}
else
{
ppid
=
DATA_CHANNEL_PPID_BINARY_EMPTY
;
msg
.
Append
(
'
\
0
'
)
;
}
}
else
{
if
(
msg
.
Length
(
)
)
{
ppid
=
DATA_CHANNEL_PPID_DOMSTRING
;
}
else
{
ppid
=
DATA_CHANNEL_PPID_DOMSTRING_EMPTY
;
msg
.
Append
(
'
\
0
'
)
;
}
}
DataChannelMessageMetadata
metadata
(
channel
-
>
mStream
ppid
!
channel
-
>
mOrdered
&
&
!
channel
-
>
mWaitingForAck
maxRetransmissions
maxLifetimeMs
)
;
OutgoingMsg
outgoing
(
std
:
:
move
(
msg
)
metadata
)
;
if
(
!
SendMessage
(
*
channel
std
:
:
move
(
outgoing
)
)
)
{
Dispatch
(
NS_NewRunnableFunction
(
__func__
[
channel
len
=
msg
.
Length
(
)
]
(
)
{
channel
-
>
mTrafficCounters
.
mMessagesSent
+
+
;
channel
-
>
mTrafficCounters
.
mBytesSent
+
=
len
;
}
)
)
;
}
}
)
)
;
return
0
;
}
int
DataChannelConnection
:
:
SendMessage
(
DataChannel
&
aChannel
OutgoingMsg
&
&
aMsg
)
{
MOZ_ASSERT
(
mSTS
-
>
IsOnCurrentThread
(
)
)
;
aChannel
.
mConnection
-
>
mLock
.
AssertCurrentThreadOwns
(
)
;
bool
buffered
;
if
(
aMsg
.
GetMetadata
(
)
.
mPpid
=
=
DATA_CHANNEL_PPID_CONTROL
)
{
int
error
=
SendMsgInternalOrBuffer
(
mBufferedControl
std
:
:
move
(
aMsg
)
&
buffered
nullptr
)
;
if
(
!
error
&
&
buffered
&
&
mPendingType
=
=
PendingType
:
:
None
)
{
mPendingType
=
PendingType
:
:
Dcep
;
}
return
error
;
}
size_t
written
=
0
;
if
(
const
int
error
=
SendMsgInternalOrBuffer
(
aChannel
.
mBufferedData
std
:
:
move
(
aMsg
)
&
buffered
&
written
)
;
error
)
{
return
error
;
}
if
(
written
&
&
aMsg
.
GetMetadata
(
)
.
mPpid
!
=
DATA_CHANNEL_PPID_DOMSTRING_EMPTY
&
&
aMsg
.
GetMetadata
(
)
.
mPpid
!
=
DATA_CHANNEL_PPID_BINARY_EMPTY
)
{
aChannel
.
DecrementBufferedAmount
(
written
)
;
}
if
(
buffered
&
&
mPendingType
=
=
PendingType
:
:
None
)
{
mPendingType
=
PendingType
:
:
Data
;
mCurrentStream
=
aChannel
.
mStream
;
}
return
0
;
}
void
DataChannelConnection
:
:
Stop
(
)
{
Dispatch
(
do_AddRef
(
new
DataChannelOnMessageAvailable
(
DataChannelOnMessageAvailable
:
:
EventType
:
:
OnDisconnected
this
)
)
)
;
}
void
DataChannelConnection
:
:
Close
(
DataChannel
*
aChannel
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aChannel
)
;
RefPtr
<
DataChannel
>
channel
(
aChannel
)
;
DataChannelState
channelState
=
channel
-
>
GetReadyState
(
)
;
if
(
channelState
=
=
DataChannelState
:
:
Closed
|
|
channelState
=
=
DataChannelState
:
:
Closing
)
{
DC_DEBUG
(
(
"
Channel
already
closing
/
closed
(
%
s
)
"
ToString
(
channelState
)
)
)
;
return
;
}
channel
-
>
SetReadyState
(
DataChannelState
:
:
Closing
)
;
GracefulClose
(
channel
)
;
}
void
DataChannelConnection
:
:
GracefulClose
(
DataChannel
*
aChannel
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
Dispatch
(
NS_NewRunnableFunction
(
__func__
[
this
self
=
RefPtr
<
DataChannelConnection
>
(
this
)
channel
=
RefPtr
<
DataChannel
>
(
aChannel
)
]
(
)
{
if
(
channel
-
>
GetReadyState
(
)
!
=
DataChannelState
:
:
Closing
&
&
channel
-
>
GetReadyState
(
)
!
=
DataChannelState
:
:
Closed
)
{
channel
-
>
SetReadyState
(
DataChannelState
:
:
Closing
)
;
}
if
(
!
channel
-
>
mBufferedAmount
&
&
channel
-
>
GetReadyState
(
)
!
=
DataChannelState
:
:
Closed
)
{
FinishClose
(
channel
)
;
}
}
)
)
;
}
void
DataChannelConnection
:
:
FinishClose
(
DataChannel
*
aChannel
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mSTS
-
>
Dispatch
(
NS_NewRunnableFunction
(
__func__
[
this
self
=
RefPtr
<
DataChannelConnection
>
(
this
)
channel
=
RefPtr
<
DataChannel
>
(
aChannel
)
]
(
)
{
MutexAutoLock
lock
(
mLock
)
;
FinishClose_s
(
channel
)
;
}
)
)
;
}
void
DataChannelConnection
:
:
FinishClose_s
(
DataChannel
*
aChannel
)
{
MOZ_ASSERT
(
mSTS
-
>
IsOnCurrentThread
(
)
)
;
mLock
.
AssertCurrentThreadOwns
(
)
;
RefPtr
<
DataChannel
>
channel
(
aChannel
)
;
aChannel
-
>
mBufferedData
.
Clear
(
)
;
mChannels
.
Remove
(
aChannel
)
;
mPending
.
erase
(
aChannel
)
;
if
(
channel
-
>
mStream
!
=
INVALID_STREAM
)
{
MarkStreamForReset
(
*
aChannel
)
;
if
(
GetState
(
)
!
=
DataChannelConnectionState
:
:
Closed
)
{
ResetStreams
(
mStreamsResetting
)
;
}
}
aChannel
-
>
AnnounceClosed
(
)
;
}
void
DataChannelConnection
:
:
CloseAll
(
)
{
ASSERT_WEBRTC
(
NS_IsMainThread
(
)
)
;
DC_DEBUG
(
(
"
Closing
all
channels
(
connection
%
p
)
"
(
void
*
)
this
)
)
;
MutexAutoLock
lock
(
mLock
)
;
for
(
auto
&
channel
:
mChannels
.
GetAll
(
)
)
{
MutexAutoUnlock
lock
(
mLock
)
;
channel
-
>
Close
(
)
;
}
mSTS
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
DataChannelConnection
:
:
CloseAll
"
[
this
self
=
RefPtr
<
DataChannelConnection
>
(
this
)
]
(
)
{
MutexAutoLock
lock
(
mLock
)
;
SetState
(
DataChannelConnectionState
:
:
Closed
)
;
for
(
auto
&
channel
:
mChannels
.
GetAll
(
)
)
{
FinishClose_s
(
channel
.
get
(
)
)
;
}
for
(
const
auto
&
channel
:
mPending
)
{
DC_DEBUG
(
(
"
closing
pending
channel
%
p
stream
%
u
"
channel
.
get
(
)
channel
-
>
mStream
)
)
;
FinishClose_s
(
channel
.
get
(
)
)
;
}
if
(
!
mStreamsResetting
.
IsEmpty
(
)
)
{
ResetStreams
(
mStreamsResetting
)
;
}
}
)
)
;
}
bool
DataChannelConnection
:
:
Channels
:
:
IdComparator
:
:
Equals
(
const
RefPtr
<
DataChannel
>
&
aChannel
uint16_t
aId
)
const
{
return
aChannel
-
>
mStream
=
=
aId
;
}
bool
DataChannelConnection
:
:
Channels
:
:
IdComparator
:
:
LessThan
(
const
RefPtr
<
DataChannel
>
&
aChannel
uint16_t
aId
)
const
{
return
aChannel
-
>
mStream
<
aId
;
}
bool
DataChannelConnection
:
:
Channels
:
:
IdComparator
:
:
Equals
(
const
RefPtr
<
DataChannel
>
&
a1
const
RefPtr
<
DataChannel
>
&
a2
)
const
{
return
Equals
(
a1
a2
-
>
mStream
)
;
}
bool
DataChannelConnection
:
:
Channels
:
:
IdComparator
:
:
LessThan
(
const
RefPtr
<
DataChannel
>
&
a1
const
RefPtr
<
DataChannel
>
&
a2
)
const
{
return
LessThan
(
a1
a2
-
>
mStream
)
;
}
void
DataChannelConnection
:
:
Channels
:
:
Insert
(
const
RefPtr
<
DataChannel
>
&
aChannel
)
{
DC_DEBUG
(
(
"
Inserting
channel
%
u
:
%
p
"
aChannel
-
>
mStream
aChannel
.
get
(
)
)
)
;
MutexAutoLock
lock
(
mMutex
)
;
if
(
aChannel
-
>
mStream
!
=
INVALID_STREAM
)
{
MOZ_ASSERT
(
!
mChannels
.
ContainsSorted
(
aChannel
IdComparator
(
)
)
)
;
}
MOZ_ASSERT
(
!
mChannels
.
Contains
(
aChannel
)
)
;
mChannels
.
InsertElementSorted
(
aChannel
IdComparator
(
)
)
;
}
bool
DataChannelConnection
:
:
Channels
:
:
Remove
(
const
RefPtr
<
DataChannel
>
&
aChannel
)
{
DC_DEBUG
(
(
"
Removing
channel
%
u
:
%
p
"
aChannel
-
>
mStream
aChannel
.
get
(
)
)
)
;
MutexAutoLock
lock
(
mMutex
)
;
if
(
aChannel
-
>
mStream
=
=
INVALID_STREAM
)
{
return
mChannels
.
RemoveElement
(
aChannel
)
;
}
return
mChannels
.
RemoveElementSorted
(
aChannel
IdComparator
(
)
)
;
}
RefPtr
<
DataChannel
>
DataChannelConnection
:
:
Channels
:
:
Get
(
uint16_t
aId
)
const
{
MutexAutoLock
lock
(
mMutex
)
;
auto
index
=
mChannels
.
BinaryIndexOf
(
aId
IdComparator
(
)
)
;
if
(
index
=
=
ChannelArray
:
:
NoIndex
)
{
return
nullptr
;
}
return
mChannels
[
index
]
;
}
RefPtr
<
DataChannel
>
DataChannelConnection
:
:
Channels
:
:
GetNextChannel
(
uint16_t
aCurrentId
)
const
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
mChannels
.
IsEmpty
(
)
)
{
return
nullptr
;
}
auto
index
=
mChannels
.
IndexOfFirstElementGt
(
aCurrentId
IdComparator
(
)
)
;
if
(
index
=
=
mChannels
.
Length
(
)
)
{
index
=
0
;
}
return
mChannels
[
index
]
;
}
DataChannel
:
:
DataChannel
(
DataChannelConnection
*
connection
uint16_t
stream
DataChannelState
state
const
nsACString
&
label
const
nsACString
&
protocol
DataChannelReliabilityPolicy
policy
uint32_t
value
bool
ordered
bool
negotiated
DataChannelListener
*
aListener
nsISupports
*
aContext
)
:
mListener
(
aListener
)
mContext
(
aContext
)
mConnection
(
connection
)
mLabel
(
label
)
mProtocol
(
protocol
)
mReadyState
(
state
)
mStream
(
stream
)
mPrPolicy
(
policy
)
mPrValue
(
value
)
mNegotiated
(
negotiated
)
mOrdered
(
ordered
)
mIsRecvBinary
(
false
)
mBufferedThreshold
(
0
)
mBufferedAmount
(
0
)
mMainThreadEventTarget
(
connection
-
>
GetNeckoTarget
(
)
)
{
NS_ASSERTION
(
mConnection
"
NULL
connection
"
)
;
}
DataChannel
:
:
~
DataChannel
(
)
{
NS_ASSERTION
(
mReadyState
=
=
DataChannelState
:
:
Closed
|
|
mReadyState
=
=
DataChannelState
:
:
Closing
"
unexpected
state
in
~
DataChannel
"
)
;
}
void
DataChannel
:
:
Close
(
)
{
if
(
mConnection
)
{
RefPtr
<
DataChannelConnection
>
connection
(
mConnection
)
;
connection
-
>
Close
(
this
)
;
}
}
void
DataChannel
:
:
ReleaseConnection
(
)
{
ASSERT_WEBRTC
(
NS_IsMainThread
(
)
)
;
mConnection
=
nullptr
;
}
void
DataChannel
:
:
SetListener
(
DataChannelListener
*
aListener
nsISupports
*
aContext
)
{
ASSERT_WEBRTC
(
NS_IsMainThread
(
)
)
;
mContext
=
aContext
;
mListener
=
aListener
;
}
void
DataChannel
:
:
SendErrnoToErrorResult
(
int
error
size_t
aMessageSize
ErrorResult
&
aRv
)
{
switch
(
error
)
{
case
0
:
break
;
case
EMSGSIZE
:
{
nsPrintfCString
err
(
"
Message
size
(
%
zu
)
exceeds
maxMessageSize
"
aMessageSize
)
;
aRv
.
ThrowTypeError
(
err
)
;
break
;
}
default
:
aRv
.
Throw
(
NS_ERROR_DOM_OPERATION_ERR
)
;
break
;
}
}
void
DataChannel
:
:
IncrementBufferedAmount
(
uint32_t
aSize
ErrorResult
&
aRv
)
{
ASSERT_WEBRTC
(
NS_IsMainThread
(
)
)
;
if
(
mBufferedAmount
>
UINT32_MAX
-
aSize
)
{
aRv
.
Throw
(
NS_ERROR_FILE_TOO_BIG
)
;
return
;
}
mBufferedAmount
+
=
aSize
;
}
void
DataChannel
:
:
DecrementBufferedAmount
(
uint32_t
aSize
)
{
mMainThreadEventTarget
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
DataChannel
:
:
DecrementBufferedAmount
"
[
this
self
=
RefPtr
<
DataChannel
>
(
this
)
aSize
]
{
MOZ_ASSERT
(
aSize
<
=
mBufferedAmount
)
;
bool
wasLow
=
mBufferedAmount
<
=
mBufferedThreshold
;
mBufferedAmount
-
=
aSize
;
if
(
!
wasLow
&
&
mBufferedAmount
<
=
mBufferedThreshold
)
{
DC_DEBUG
(
(
"
%
s
:
sending
BUFFER_LOW_THRESHOLD
for
%
s
/
%
s
:
%
u
"
__FUNCTION__
mLabel
.
get
(
)
mProtocol
.
get
(
)
mStream
)
)
;
mListener
-
>
OnBufferLow
(
mContext
)
;
}
if
(
mBufferedAmount
=
=
0
)
{
DC_DEBUG
(
(
"
%
s
:
sending
NO_LONGER_BUFFERED
for
%
s
/
%
s
:
%
u
"
__FUNCTION__
mLabel
.
get
(
)
mProtocol
.
get
(
)
mStream
)
)
;
mListener
-
>
NotBuffered
(
mContext
)
;
if
(
mReadyState
=
=
DataChannelState
:
:
Closing
)
{
if
(
mConnection
)
{
mConnection
-
>
FinishClose
(
this
)
;
}
}
}
}
)
)
;
}
void
DataChannel
:
:
AnnounceOpen
(
)
{
mMainThreadEventTarget
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
DataChannel
:
:
AnnounceOpen
"
[
this
self
=
RefPtr
<
DataChannel
>
(
this
)
]
{
DataChannelState
state
=
GetReadyState
(
)
;
if
(
state
!
=
DataChannelState
:
:
Closing
&
&
state
!
=
DataChannelState
:
:
Closed
)
{
if
(
!
mEverOpened
&
&
mConnection
&
&
mConnection
-
>
mListener
)
{
mEverOpened
=
true
;
mConnection
-
>
mListener
-
>
NotifyDataChannelOpen
(
this
)
;
}
SetReadyState
(
DataChannelState
:
:
Open
)
;
DC_DEBUG
(
(
"
%
s
:
sending
ON_CHANNEL_OPEN
for
%
s
/
%
s
:
%
u
"
__FUNCTION__
mLabel
.
get
(
)
mProtocol
.
get
(
)
mStream
)
)
;
if
(
mListener
)
{
mListener
-
>
OnChannelConnected
(
mContext
)
;
}
}
}
)
)
;
}
void
DataChannel
:
:
AnnounceClosed
(
)
{
mMainThreadEventTarget
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
DataChannel
:
:
AnnounceClosed
"
[
this
self
=
RefPtr
<
DataChannel
>
(
this
)
]
{
if
(
GetReadyState
(
)
=
=
DataChannelState
:
:
Closed
)
{
return
;
}
SetReadyState
(
DataChannelState
:
:
Closed
)
;
if
(
mListener
)
{
DC_DEBUG
(
(
"
%
s
:
sending
ON_CHANNEL_CLOSED
for
%
s
/
%
s
:
%
u
"
__FUNCTION__
mLabel
.
get
(
)
mProtocol
.
get
(
)
mStream
)
)
;
mListener
-
>
OnChannelClosed
(
mContext
)
;
}
if
(
mEverOpened
&
&
mConnection
&
&
mConnection
-
>
mListener
)
{
mConnection
-
>
mListener
-
>
NotifyDataChannelClosed
(
this
)
;
}
}
)
)
;
}
void
DataChannel
:
:
SetReadyState
(
const
DataChannelState
aState
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
DC_DEBUG
(
(
"
DataChannelConnection
labeled
%
s
(
%
p
)
(
stream
%
d
)
changing
ready
"
"
state
"
"
%
s
-
>
%
s
"
mLabel
.
get
(
)
this
mStream
ToString
(
mReadyState
)
ToString
(
aState
)
)
)
;
mReadyState
=
aState
;
}
void
DataChannel
:
:
SendMsg
(
nsACString
&
&
aMsg
ErrorResult
&
aRv
)
{
if
(
!
EnsureValidStream
(
aRv
)
)
{
return
;
}
const
size_t
length
=
aMsg
.
Length
(
)
;
SendErrnoToErrorResult
(
mConnection
-
>
SendMessage
(
mStream
std
:
:
move
(
aMsg
)
)
length
aRv
)
;
if
(
!
aRv
.
Failed
(
)
)
{
IncrementBufferedAmount
(
length
aRv
)
;
}
}
void
DataChannel
:
:
SendBinaryMsg
(
nsACString
&
&
aMsg
ErrorResult
&
aRv
)
{
if
(
!
EnsureValidStream
(
aRv
)
)
{
return
;
}
const
size_t
length
=
aMsg
.
Length
(
)
;
SendErrnoToErrorResult
(
mConnection
-
>
SendBinaryMessage
(
mStream
std
:
:
move
(
aMsg
)
)
length
aRv
)
;
if
(
!
aRv
.
Failed
(
)
)
{
IncrementBufferedAmount
(
length
aRv
)
;
}
}
void
DataChannel
:
:
SendBinaryBlob
(
dom
:
:
Blob
&
aBlob
ErrorResult
&
aRv
)
{
if
(
!
EnsureValidStream
(
aRv
)
)
{
return
;
}
uint64_t
msgLength
=
aBlob
.
GetSize
(
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
if
(
msgLength
>
UINT32_MAX
)
{
aRv
.
Throw
(
NS_ERROR_FILE_TOO_BIG
)
;
return
;
}
nsCOMPtr
<
nsIInputStream
>
msgStream
;
aBlob
.
CreateInputStream
(
getter_AddRefs
(
msgStream
)
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
;
}
SendErrnoToErrorResult
(
mConnection
-
>
SendBlob
(
mStream
msgStream
)
msgLength
aRv
)
;
if
(
!
aRv
.
Failed
(
)
)
{
IncrementBufferedAmount
(
msgLength
aRv
)
;
}
}
dom
:
:
Nullable
<
uint16_t
>
DataChannel
:
:
GetMaxPacketLifeTime
(
)
const
{
if
(
mPrPolicy
=
=
DataChannelReliabilityPolicy
:
:
LimitedLifetime
)
{
return
dom
:
:
Nullable
<
uint16_t
>
(
mPrValue
)
;
}
return
dom
:
:
Nullable
<
uint16_t
>
(
)
;
}
dom
:
:
Nullable
<
uint16_t
>
DataChannel
:
:
GetMaxRetransmits
(
)
const
{
if
(
mPrPolicy
=
=
DataChannelReliabilityPolicy
:
:
LimitedRetransmissions
)
{
return
dom
:
:
Nullable
<
uint16_t
>
(
mPrValue
)
;
}
return
dom
:
:
Nullable
<
uint16_t
>
(
)
;
}
uint32_t
DataChannel
:
:
GetBufferedAmountLowThreshold
(
)
const
{
return
mBufferedThreshold
;
}
void
DataChannel
:
:
SetBufferedAmountLowThreshold
(
uint32_t
aThreshold
)
{
mBufferedThreshold
=
aThreshold
;
}
void
DataChannel
:
:
SendOrQueue
(
DataChannelOnMessageAvailable
*
aMessage
)
{
nsCOMPtr
<
nsIRunnable
>
runnable
=
aMessage
;
mMainThreadEventTarget
-
>
Dispatch
(
runnable
.
forget
(
)
)
;
}
DataChannel
:
:
TrafficCounters
DataChannel
:
:
GetTrafficCounters
(
)
const
{
return
mTrafficCounters
;
}
bool
DataChannel
:
:
EnsureValidStream
(
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
mConnection
)
;
if
(
mConnection
&
&
mStream
!
=
INVALID_STREAM
)
{
return
true
;
}
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
false
;
}
nsresult
DataChannelOnMessageAvailable
:
:
Run
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
switch
(
mType
)
{
case
EventType
:
:
OnDataString
:
case
EventType
:
:
OnDataBinary
:
if
(
!
mChannel
-
>
mListener
)
{
DC_ERROR
(
(
"
DataChannelOnMessageAvailable
(
%
s
)
with
null
Listener
!
"
ToString
(
mType
)
)
)
;
return
NS_OK
;
}
if
(
mChannel
-
>
GetReadyState
(
)
=
=
DataChannelState
:
:
Closed
|
|
mChannel
-
>
GetReadyState
(
)
=
=
DataChannelState
:
:
Closing
)
{
return
NS_OK
;
}
if
(
mType
=
=
EventType
:
:
OnDataString
)
{
mChannel
-
>
mListener
-
>
OnMessageAvailable
(
mChannel
-
>
mContext
mData
)
;
}
else
{
mChannel
-
>
mListener
-
>
OnBinaryMessageAvailable
(
mChannel
-
>
mContext
mData
)
;
}
break
;
case
EventType
:
:
OnDisconnected
:
if
(
mConnection
-
>
mListener
)
{
mConnection
-
>
mListener
-
>
NotifySctpClosed
(
)
;
}
mConnection
-
>
CloseAll
(
)
;
break
;
case
EventType
:
:
OnChannelCreated
:
if
(
!
mConnection
-
>
mListener
)
{
DC_ERROR
(
(
"
DataChannelOnMessageAvailable
(
%
s
)
with
null
Listener
!
"
ToString
(
mType
)
)
)
;
return
NS_OK
;
}
mConnection
-
>
mListener
-
>
NotifyDataChannel
(
mChannel
.
forget
(
)
)
;
break
;
case
EventType
:
:
OnConnection
:
if
(
mConnection
-
>
mListener
)
{
mConnection
-
>
mListener
-
>
NotifySctpConnected
(
)
;
}
break
;
}
return
NS_OK
;
}
}
