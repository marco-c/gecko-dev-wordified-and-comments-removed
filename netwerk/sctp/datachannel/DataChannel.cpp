#
include
<
algorithm
>
#
include
<
stdio
.
h
>
#
include
<
stdlib
.
h
>
#
if
!
defined
(
__Userspace_os_Windows
)
#
include
<
arpa
/
inet
.
h
>
#
endif
#
include
<
errno
.
h
>
#
define
SCTP_DEBUG
1
#
define
SCTP_STDINT_INCLUDE
<
stdint
.
h
>
#
ifdef
_MSC_VER
#
pragma
warning
(
push
)
#
pragma
warning
(
disable
:
4200
)
#
endif
#
include
"
usrsctp
.
h
"
#
ifdef
_MSC_VER
#
pragma
warning
(
pop
)
#
endif
#
include
"
DataChannelLog
.
h
"
#
define
DATACHANNEL_LOG
(
args
)
LOG
(
args
)
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsIPrefBranch
.
h
"
#
include
"
nsIPrefService
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
include
"
nsThread
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
ifdef
MOZ_PEERCONNECTION
#
include
"
mtransport
/
runnable_utils
.
h
"
#
include
"
signaling
/
src
/
peerconnection
/
MediaTransportHandler
.
h
"
#
include
"
mediapacket
.
h
"
#
endif
#
include
"
DataChannel
.
h
"
#
include
"
DataChannelProtocol
.
h
"
#
ifdef
DEBUG
#
define
ASSERT_WEBRTC
(
x
)
MOZ_ASSERT
(
(
x
)
)
#
elif
defined
(
MOZ_WEBRTC_ASSERT_ALWAYS
)
#
define
ASSERT_WEBRTC
(
x
)
\
do
{
\
if
(
!
(
x
)
)
{
\
MOZ_CRASH
(
)
;
\
}
\
}
while
(
0
)
#
endif
static
bool
sctp_initialized
;
namespace
mozilla
{
LazyLogModule
gDataChannelLog
(
"
DataChannel
"
)
;
static
LazyLogModule
gSCTPLog
(
"
SCTP
"
)
;
#
define
SCTP_LOG
(
args
)
\
MOZ_LOG
(
mozilla
:
:
gSCTPLog
mozilla
:
:
LogLevel
:
:
Debug
args
)
class
DataChannelConnectionShutdown
:
public
nsITimerCallback
{
public
:
explicit
DataChannelConnectionShutdown
(
DataChannelConnection
*
aConnection
)
:
mConnection
(
aConnection
)
{
mTimer
=
NS_NewTimer
(
)
;
mTimer
-
>
InitWithCallback
(
this
30
*
1000
nsITimer
:
:
TYPE_ONE_SHOT
)
;
}
NS_IMETHODIMP
Notify
(
nsITimer
*
aTimer
)
override
;
NS_DECL_THREADSAFE_ISUPPORTS
private
:
virtual
~
DataChannelConnectionShutdown
(
)
{
mTimer
-
>
Cancel
(
)
;
}
RefPtr
<
DataChannelConnection
>
mConnection
;
nsCOMPtr
<
nsITimer
>
mTimer
;
}
;
class
DataChannelShutdown
;
StaticRefPtr
<
DataChannelShutdown
>
sDataChannelShutdown
;
class
DataChannelShutdown
:
public
nsIObserver
{
public
:
NS_DECL_ISUPPORTS
DataChannelShutdown
(
)
=
default
;
void
Init
(
)
{
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
!
observerService
)
return
;
nsresult
rv
=
observerService
-
>
AddObserver
(
this
"
xpcom
-
will
-
shutdown
"
false
)
;
MOZ_ASSERT
(
rv
=
=
NS_OK
)
;
(
void
)
rv
;
}
NS_IMETHOD
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
override
{
if
(
strcmp
(
aTopic
"
xpcom
-
will
-
shutdown
"
)
=
=
0
)
{
LOG
(
(
"
Shutting
down
SCTP
"
)
)
;
if
(
sctp_initialized
)
{
usrsctp_finish
(
)
;
sctp_initialized
=
false
;
}
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
!
observerService
)
return
NS_ERROR_FAILURE
;
nsresult
rv
=
observerService
-
>
RemoveObserver
(
this
"
xpcom
-
will
-
shutdown
"
)
;
MOZ_ASSERT
(
rv
=
=
NS_OK
)
;
(
void
)
rv
;
{
StaticMutexAutoLock
lock
(
sLock
)
;
sConnections
=
nullptr
;
}
sDataChannelShutdown
=
nullptr
;
}
return
NS_OK
;
}
void
CreateConnectionShutdown
(
DataChannelConnection
*
aConnection
)
{
StaticMutexAutoLock
lock
(
sLock
)
;
if
(
!
sConnections
)
{
sConnections
=
new
nsTArray
<
RefPtr
<
DataChannelConnectionShutdown
>
>
(
)
;
}
sConnections
-
>
AppendElement
(
new
DataChannelConnectionShutdown
(
aConnection
)
)
;
}
void
RemoveConnectionShutdown
(
DataChannelConnectionShutdown
*
aConnectionShutdown
)
{
StaticMutexAutoLock
lock
(
sLock
)
;
if
(
sConnections
)
{
sConnections
-
>
RemoveElement
(
aConnectionShutdown
)
;
}
}
private
:
virtual
~
DataChannelShutdown
(
)
=
default
;
static
StaticMutex
sLock
;
static
StaticAutoPtr
<
nsTArray
<
RefPtr
<
DataChannelConnectionShutdown
>
>
>
sConnections
;
}
;
StaticMutex
DataChannelShutdown
:
:
sLock
;
StaticAutoPtr
<
nsTArray
<
RefPtr
<
DataChannelConnectionShutdown
>
>
>
DataChannelShutdown
:
:
sConnections
;
NS_IMPL_ISUPPORTS
(
DataChannelShutdown
nsIObserver
)
;
NS_IMPL_ISUPPORTS
(
DataChannelConnectionShutdown
nsITimerCallback
)
NS_IMETHODIMP
DataChannelConnectionShutdown
:
:
Notify
(
nsITimer
*
aTimer
)
{
RefPtr
<
DataChannelConnectionShutdown
>
grip
(
this
)
;
if
(
sDataChannelShutdown
)
{
sDataChannelShutdown
-
>
RemoveConnectionShutdown
(
this
)
;
}
return
NS_OK
;
}
OutgoingMsg
:
:
OutgoingMsg
(
struct
sctp_sendv_spa
&
info
const
uint8_t
*
data
size_t
length
)
:
mLength
(
length
)
mData
(
data
)
{
mInfo
=
&
info
;
mPos
=
0
;
}
void
OutgoingMsg
:
:
Advance
(
size_t
offset
)
{
mPos
+
=
offset
;
if
(
mPos
>
mLength
)
{
mPos
=
mLength
;
}
}
BufferedOutgoingMsg
:
:
BufferedOutgoingMsg
(
OutgoingMsg
&
msg
)
{
size_t
length
=
msg
.
GetLeft
(
)
;
auto
*
tmp
=
new
uint8_t
[
length
]
;
memcpy
(
tmp
msg
.
GetData
(
)
length
)
;
mLength
=
length
;
mData
=
tmp
;
mInfo
=
new
sctp_sendv_spa
;
*
mInfo
=
msg
.
GetInfo
(
)
;
mPos
=
0
;
}
BufferedOutgoingMsg
:
:
~
BufferedOutgoingMsg
(
)
{
delete
mInfo
;
delete
mData
;
}
static
int
receive_cb
(
struct
socket
*
sock
union
sctp_sockstore
addr
void
*
data
size_t
datalen
struct
sctp_rcvinfo
rcv
int
flags
void
*
ulp_info
)
{
DataChannelConnection
*
connection
=
static_cast
<
DataChannelConnection
*
>
(
ulp_info
)
;
return
connection
-
>
ReceiveCallback
(
sock
data
datalen
rcv
flags
)
;
}
static
DataChannelConnection
*
GetConnectionFromSocket
(
struct
socket
*
sock
)
{
struct
sockaddr
*
addrs
=
nullptr
;
int
naddrs
=
usrsctp_getladdrs
(
sock
0
&
addrs
)
;
if
(
naddrs
<
=
0
|
|
addrs
[
0
]
.
sa_family
!
=
AF_CONN
)
{
return
nullptr
;
}
struct
sockaddr_conn
*
sconn
=
reinterpret_cast
<
struct
sockaddr_conn
*
>
(
&
addrs
[
0
]
)
;
DataChannelConnection
*
connection
=
reinterpret_cast
<
DataChannelConnection
*
>
(
sconn
-
>
sconn_addr
)
;
usrsctp_freeladdrs
(
addrs
)
;
return
connection
;
}
static
int
threshold_event
(
struct
socket
*
sock
uint32_t
sb_free
)
{
DataChannelConnection
*
connection
=
GetConnectionFromSocket
(
sock
)
;
if
(
connection
)
{
connection
-
>
SendDeferredMessages
(
)
;
}
else
{
LOG
(
(
"
Can
'
t
find
connection
for
socket
%
p
"
sock
)
)
;
}
return
0
;
}
static
void
debug_printf
(
const
char
*
format
.
.
.
)
{
va_list
ap
;
char
buffer
[
1024
]
;
if
(
MOZ_LOG_TEST
(
gSCTPLog
LogLevel
:
:
Debug
)
)
{
va_start
(
ap
format
)
;
#
ifdef
_WIN32
if
(
vsnprintf_s
(
buffer
sizeof
(
buffer
)
_TRUNCATE
format
ap
)
>
0
)
{
#
else
if
(
VsprintfLiteral
(
buffer
format
ap
)
>
0
)
{
#
endif
SCTP_LOG
(
(
"
%
s
"
buffer
)
)
;
}
va_end
(
ap
)
;
}
}
DataChannelConnection
:
:
DataChannelConnection
(
DataConnectionListener
*
listener
nsIEventTarget
*
aTarget
MediaTransportHandler
*
aHandler
)
:
NeckoTargetHolder
(
aTarget
)
mLock
(
"
netwerk
:
:
sctp
:
:
DataChannelConnection
"
)
mSendInterleaved
(
false
)
mPpidFragmentation
(
false
)
mMaxMessageSizeSet
(
false
)
mMaxMessageSize
(
0
)
mAllocateEven
(
false
)
mTransportHandler
(
aHandler
)
{
mCurrentStream
=
0
;
mState
=
CLOSED
;
mSocket
=
nullptr
;
mMasterSocket
=
nullptr
;
mListener
=
listener
;
mLocalPort
=
0
;
mRemotePort
=
0
;
mPendingType
=
PENDING_NONE
;
LOG
(
(
"
Constructor
DataChannelConnection
=
%
p
listener
=
%
p
"
this
mListener
.
get
(
)
)
)
;
mInternalIOThread
=
nullptr
;
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
mShutdown
=
false
;
#
endif
}
DataChannelConnection
:
:
~
DataChannelConnection
(
)
{
LOG
(
(
"
Deleting
DataChannelConnection
%
p
"
(
void
*
)
this
)
)
;
ASSERT_WEBRTC
(
mState
=
=
CLOSED
)
;
MOZ_ASSERT
(
!
mMasterSocket
)
;
MOZ_ASSERT
(
mPending
.
GetSize
(
)
=
=
0
)
;
if
(
!
IsSTSThread
(
)
)
{
ASSERT_WEBRTC
(
NS_IsMainThread
(
)
)
;
if
(
mInternalIOThread
)
{
nsCOMPtr
<
nsIRunnable
>
r
=
WrapRunnable
(
nsCOMPtr
<
nsIThread
>
(
mInternalIOThread
)
&
nsIThread
:
:
Shutdown
)
;
Dispatch
(
r
.
forget
(
)
)
;
}
}
else
{
if
(
mInternalIOThread
)
{
mInternalIOThread
-
>
Shutdown
(
)
;
}
}
}
void
DataChannelConnection
:
:
Destroy
(
)
{
LOG
(
(
"
Destroying
DataChannelConnection
%
p
"
(
void
*
)
this
)
)
;
ASSERT_WEBRTC
(
NS_IsMainThread
(
)
)
;
CloseAll
(
)
;
MutexAutoLock
lock
(
mLock
)
;
ClearResets
(
)
;
MOZ_ASSERT
(
mSTS
)
;
ASSERT_WEBRTC
(
NS_IsMainThread
(
)
)
;
mListener
=
nullptr
;
RUN_ON_THREAD
(
mSTS
WrapRunnable
(
RefPtr
<
DataChannelConnection
>
(
this
)
&
DataChannelConnection
:
:
DestroyOnSTS
mSocket
mMasterSocket
)
NS_DISPATCH_NORMAL
)
;
mSocket
=
nullptr
;
mMasterSocket
=
nullptr
;
}
void
DataChannelConnection
:
:
DestroyOnSTS
(
struct
socket
*
aMasterSocket
struct
socket
*
aSocket
)
{
if
(
aSocket
&
&
aSocket
!
=
aMasterSocket
)
usrsctp_close
(
aSocket
)
;
if
(
aMasterSocket
)
usrsctp_close
(
aMasterSocket
)
;
usrsctp_deregister_address
(
static_cast
<
void
*
>
(
this
)
)
;
LOG
(
(
"
Deregistered
%
p
from
the
SCTP
stack
.
"
static_cast
<
void
*
>
(
this
)
)
)
;
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
mShutdown
=
true
;
#
endif
disconnect_all
(
)
;
mTransportHandler
=
nullptr
;
mSTS
-
>
Dispatch
(
WrapRunnable
(
RefPtr
<
DataChannelConnection
>
(
this
)
&
DataChannelConnection
:
:
DestroyOnSTSFinal
)
NS_DISPATCH_NORMAL
)
;
}
void
DataChannelConnection
:
:
DestroyOnSTSFinal
(
)
{
sDataChannelShutdown
-
>
CreateConnectionShutdown
(
this
)
;
}
bool
DataChannelConnection
:
:
Init
(
unsigned
short
aPort
uint16_t
aNumStreams
bool
aMaxMessageSizeSet
uint64_t
aMaxMessageSize
)
{
struct
sctp_initmsg
initmsg
;
struct
sctp_assoc_value
av
;
struct
sctp_event
event
;
socklen_t
len
;
uint16_t
event_types
[
]
=
{
SCTP_ASSOC_CHANGE
SCTP_PEER_ADDR_CHANGE
SCTP_REMOTE_ERROR
SCTP_SHUTDOWN_EVENT
SCTP_ADAPTATION_INDICATION
SCTP_PARTIAL_DELIVERY_EVENT
SCTP_SEND_FAILED_EVENT
SCTP_STREAM_RESET_EVENT
SCTP_STREAM_CHANGE_EVENT
}
;
{
ASSERT_WEBRTC
(
NS_IsMainThread
(
)
)
;
mSendInterleaved
=
false
;
mPpidFragmentation
=
false
;
mMaxMessageSizeSet
=
false
;
SetMaxMessageSize
(
aMaxMessageSizeSet
aMaxMessageSize
)
;
if
(
!
sctp_initialized
)
{
LOG
(
(
"
sctp_init
"
)
)
;
#
ifdef
MOZ_PEERCONNECTION
usrsctp_init
(
0
DataChannelConnection
:
:
SctpDtlsOutput
debug_printf
)
;
#
else
MOZ_CRASH
(
"
Trying
to
use
SCTP
/
DTLS
without
mtransport
"
)
;
#
endif
if
(
MOZ_LOG_TEST
(
gSCTPLog
LogLevel
:
:
Debug
)
)
{
usrsctp_sysctl_set_sctp_debug_on
(
SCTP_DEBUG_ALL
)
;
}
usrsctp_sysctl_set_sctp_blackhole
(
2
)
;
usrsctp_sysctl_set_sctp_ecn_enable
(
0
)
;
usrsctp_sysctl_set_sctp_default_frag_interleave
(
2
)
;
sctp_initialized
=
true
;
sDataChannelShutdown
=
new
DataChannelShutdown
(
)
;
sDataChannelShutdown
-
>
Init
(
)
;
}
}
nsresult
rv
;
mSTS
=
do_GetService
(
NS_SOCKETTRANSPORTSERVICE_CONTRACTID
&
rv
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
if
(
(
mMasterSocket
=
usrsctp_socket
(
AF_CONN
SOCK_STREAM
IPPROTO_SCTP
receive_cb
threshold_event
usrsctp_sysctl_get_sctp_sendspace
(
)
/
2
this
)
)
=
=
nullptr
)
{
return
false
;
}
int
buf_size
=
1024
*
1024
;
if
(
usrsctp_setsockopt
(
mMasterSocket
SOL_SOCKET
SO_RCVBUF
(
const
void
*
)
&
buf_size
sizeof
(
buf_size
)
)
<
0
)
{
LOG
(
(
"
Couldn
'
t
change
receive
buffer
size
on
SCTP
socket
"
)
)
;
goto
error_cleanup
;
}
if
(
usrsctp_setsockopt
(
mMasterSocket
SOL_SOCKET
SO_SNDBUF
(
const
void
*
)
&
buf_size
sizeof
(
buf_size
)
)
<
0
)
{
LOG
(
(
"
Couldn
'
t
change
send
buffer
size
on
SCTP
socket
"
)
)
;
goto
error_cleanup
;
}
if
(
usrsctp_set_non_blocking
(
mMasterSocket
1
)
<
0
)
{
LOG
(
(
"
Couldn
'
t
set
non_blocking
on
SCTP
socket
"
)
)
;
goto
error_cleanup
;
}
struct
linger
l
;
l
.
l_onoff
=
1
;
l
.
l_linger
=
0
;
if
(
usrsctp_setsockopt
(
mMasterSocket
SOL_SOCKET
SO_LINGER
(
const
void
*
)
&
l
(
socklen_t
)
sizeof
(
struct
linger
)
)
<
0
)
{
LOG
(
(
"
Couldn
'
t
set
SO_LINGER
on
SCTP
socket
"
)
)
;
goto
error_cleanup
;
}
{
const
int
option_value
=
1
;
if
(
usrsctp_setsockopt
(
mMasterSocket
IPPROTO_SCTP
SCTP_REUSE_PORT
(
const
void
*
)
&
option_value
(
socklen_t
)
sizeof
(
option_value
)
)
<
0
)
{
LOG
(
(
"
Couldn
'
t
set
SCTP_REUSE_PORT
on
SCTP
socket
"
)
)
;
}
if
(
usrsctp_setsockopt
(
mMasterSocket
IPPROTO_SCTP
SCTP_NODELAY
(
const
void
*
)
&
option_value
(
socklen_t
)
sizeof
(
option_value
)
)
<
0
)
{
LOG
(
(
"
Couldn
'
t
set
SCTP_NODELAY
on
SCTP
socket
"
)
)
;
}
}
{
const
int
option_value
=
1
;
if
(
usrsctp_setsockopt
(
mMasterSocket
IPPROTO_SCTP
SCTP_EXPLICIT_EOR
(
const
void
*
)
&
option_value
(
socklen_t
)
sizeof
(
option_value
)
)
<
0
)
{
LOG
(
(
"
*
*
*
failed
enable
explicit
EOR
mode
%
d
"
errno
)
)
;
goto
error_cleanup
;
}
}
#
if
0
av
.
assoc_id
=
SCTP_FUTURE_ASSOC
;
av
.
assoc_value
=
1
;
if
(
usrsctp_setsockopt
(
mMasterSocket
IPPROTO_SCTP
SCTP_INTERLEAVING_SUPPORTED
&
av
(
socklen_t
)
sizeof
(
struct
sctp_assoc_value
)
)
<
0
)
{
LOG
(
(
"
*
*
*
failed
enable
ndata
errno
%
d
"
errno
)
)
;
goto
error_cleanup
;
}
#
endif
av
.
assoc_id
=
SCTP_ALL_ASSOC
;
av
.
assoc_value
=
SCTP_ENABLE_RESET_STREAM_REQ
|
SCTP_ENABLE_CHANGE_ASSOC_REQ
;
if
(
usrsctp_setsockopt
(
mMasterSocket
IPPROTO_SCTP
SCTP_ENABLE_STREAM_RESET
&
av
(
socklen_t
)
sizeof
(
struct
sctp_assoc_value
)
)
<
0
)
{
LOG
(
(
"
*
*
*
failed
enable
stream
reset
errno
%
d
"
errno
)
)
;
goto
error_cleanup
;
}
memset
(
&
event
0
sizeof
(
event
)
)
;
event
.
se_assoc_id
=
SCTP_ALL_ASSOC
;
event
.
se_on
=
1
;
for
(
unsigned
short
event_type
:
event_types
)
{
event
.
se_type
=
event_type
;
if
(
usrsctp_setsockopt
(
mMasterSocket
IPPROTO_SCTP
SCTP_EVENT
&
event
sizeof
(
event
)
)
<
0
)
{
LOG
(
(
"
*
*
*
failed
setsockopt
SCTP_EVENT
errno
%
d
"
errno
)
)
;
goto
error_cleanup
;
}
}
mStreams
.
AppendElements
(
aNumStreams
)
;
for
(
uint32_t
i
=
0
;
i
<
aNumStreams
;
+
+
i
)
{
mStreams
[
i
]
=
nullptr
;
}
memset
(
&
initmsg
0
sizeof
(
initmsg
)
)
;
len
=
sizeof
(
initmsg
)
;
if
(
usrsctp_getsockopt
(
mMasterSocket
IPPROTO_SCTP
SCTP_INITMSG
&
initmsg
&
len
)
<
0
)
{
LOG
(
(
"
*
*
*
failed
getsockopt
SCTP_INITMSG
"
)
)
;
goto
error_cleanup
;
}
LOG
(
(
"
Setting
number
of
SCTP
streams
to
%
u
was
%
u
/
%
u
"
aNumStreams
initmsg
.
sinit_num_ostreams
initmsg
.
sinit_max_instreams
)
)
;
initmsg
.
sinit_num_ostreams
=
aNumStreams
;
initmsg
.
sinit_max_instreams
=
MAX_NUM_STREAMS
;
if
(
usrsctp_setsockopt
(
mMasterSocket
IPPROTO_SCTP
SCTP_INITMSG
&
initmsg
(
socklen_t
)
sizeof
(
initmsg
)
)
<
0
)
{
LOG
(
(
"
*
*
*
failed
setsockopt
SCTP_INITMSG
errno
%
d
"
errno
)
)
;
goto
error_cleanup
;
}
mSocket
=
nullptr
;
usrsctp_register_address
(
static_cast
<
void
*
>
(
this
)
)
;
LOG
(
(
"
Registered
%
p
within
the
SCTP
stack
.
"
static_cast
<
void
*
>
(
this
)
)
)
;
return
true
;
error_cleanup
:
usrsctp_close
(
mMasterSocket
)
;
mMasterSocket
=
nullptr
;
return
false
;
}
void
DataChannelConnection
:
:
SetMaxMessageSize
(
bool
aMaxMessageSizeSet
uint64_t
aMaxMessageSize
)
{
MutexAutoLock
lock
(
mLock
)
;
if
(
mMaxMessageSizeSet
&
&
!
aMaxMessageSizeSet
)
{
return
;
}
mMaxMessageSizeSet
=
aMaxMessageSizeSet
;
mMaxMessageSize
=
aMaxMessageSize
;
bool
ppidFragmentationEnforced
=
false
;
nsresult
rv
;
nsCOMPtr
<
nsIPrefService
>
prefs
=
do_GetService
(
"
mozilla
.
org
/
preferences
-
service
;
1
"
&
rv
)
;
if
(
!
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
nsCOMPtr
<
nsIPrefBranch
>
branch
=
do_QueryInterface
(
prefs
)
;
if
(
branch
)
{
if
(
!
NS_FAILED
(
branch
-
>
GetBoolPref
(
"
media
.
peerconnection
.
sctp
.
force_ppid_fragmentation
"
&
mPpidFragmentation
)
)
)
{
mMaxMessageSizeSet
=
true
;
ppidFragmentationEnforced
=
true
;
}
int32_t
temp
;
if
(
!
NS_FAILED
(
branch
-
>
GetIntPref
(
"
media
.
peerconnection
.
sctp
.
force_maximum_message_size
"
&
temp
)
)
)
{
if
(
temp
>
=
0
)
{
mMaxMessageSize
=
(
uint64_t
)
temp
;
}
}
}
}
if
(
mMaxMessageSize
=
=
0
|
|
mMaxMessageSize
>
WEBRTC_DATACHANNEL_MAX_MESSAGE_SIZE_REMOTE
)
{
mMaxMessageSize
=
WEBRTC_DATACHANNEL_MAX_MESSAGE_SIZE_REMOTE
;
}
LOG
(
(
"
Use
PPID
-
based
fragmentation
/
reassembly
:
%
s
(
enforced
=
%
s
)
"
mPpidFragmentation
?
"
yes
"
:
"
no
"
ppidFragmentationEnforced
?
"
yes
"
:
"
no
"
)
)
;
LOG
(
(
"
Maximum
message
size
(
outgoing
data
)
:
%
"
PRIu64
"
(
set
=
%
s
enforced
=
%
s
)
"
mMaxMessageSize
mMaxMessageSizeSet
?
"
yes
"
:
"
no
"
aMaxMessageSize
!
=
mMaxMessageSize
?
"
yes
"
:
"
no
"
)
)
;
}
uint64_t
DataChannelConnection
:
:
GetMaxMessageSize
(
)
{
return
mMaxMessageSize
;
}
#
ifdef
MOZ_PEERCONNECTION
bool
DataChannelConnection
:
:
ConnectToTransport
(
const
std
:
:
string
&
aTransportId
bool
aClient
uint16_t
localport
uint16_t
remoteport
)
{
LOG
(
(
"
Connect
DTLS
local
%
u
remote
%
u
"
localport
remoteport
)
)
;
MOZ_ASSERT
(
mMasterSocket
"
SCTP
wasn
'
t
initialized
before
ConnectToTransport
!
"
)
;
if
(
NS_WARN_IF
(
aTransportId
.
empty
(
)
)
)
{
return
false
;
}
mLocalPort
=
localport
;
mRemotePort
=
remoteport
;
mState
=
CONNECTING
;
RUN_ON_THREAD
(
mSTS
WrapRunnable
(
RefPtr
<
DataChannelConnection
>
(
this
)
&
DataChannelConnection
:
:
SetSignals
aTransportId
aClient
)
NS_DISPATCH_NORMAL
)
;
return
true
;
}
void
DataChannelConnection
:
:
SetSignals
(
const
std
:
:
string
&
aTransportId
bool
aClient
)
{
ASSERT_WEBRTC
(
IsSTSThread
(
)
)
;
mTransportId
=
aTransportId
;
mAllocateEven
=
aClient
;
mTransportHandler
-
>
SignalPacketReceived
.
connect
(
this
&
DataChannelConnection
:
:
SctpDtlsInput
)
;
if
(
mTransportHandler
-
>
GetState
(
mTransportId
false
)
=
=
TransportLayer
:
:
TS_OPEN
)
{
LOG
(
(
"
Setting
transport
signals
dtls
already
open
"
)
)
;
CompleteConnect
(
)
;
}
else
{
LOG
(
(
"
Setting
transport
signals
dtls
not
open
yet
"
)
)
;
mTransportHandler
-
>
SignalStateChange
.
connect
(
this
&
DataChannelConnection
:
:
TransportStateChange
)
;
}
}
void
DataChannelConnection
:
:
TransportStateChange
(
const
std
:
:
string
&
aTransportId
TransportLayer
:
:
State
aState
)
{
if
(
aState
=
=
TransportLayer
:
:
TS_OPEN
)
{
CompleteConnect
(
)
;
}
}
void
DataChannelConnection
:
:
CompleteConnect
(
)
{
LOG
(
(
"
dtls
open
"
)
)
;
MutexAutoLock
lock
(
mLock
)
;
ASSERT_WEBRTC
(
IsSTSThread
(
)
)
;
if
(
!
mMasterSocket
)
{
return
;
}
struct
sockaddr_conn
addr
;
memset
(
&
addr
0
sizeof
(
addr
)
)
;
addr
.
sconn_family
=
AF_CONN
;
#
if
defined
(
__Userspace_os_Darwin
)
addr
.
sconn_len
=
sizeof
(
addr
)
;
#
endif
addr
.
sconn_port
=
htons
(
mLocalPort
)
;
addr
.
sconn_addr
=
static_cast
<
void
*
>
(
this
)
;
LOG
(
(
"
Calling
usrsctp_bind
"
)
)
;
int
r
=
usrsctp_bind
(
mMasterSocket
reinterpret_cast
<
struct
sockaddr
*
>
(
&
addr
)
sizeof
(
addr
)
)
;
if
(
r
<
0
)
{
LOG
(
(
"
usrsctp_bind
failed
:
%
d
"
r
)
)
;
}
else
{
addr
.
sconn_port
=
htons
(
mRemotePort
)
;
LOG
(
(
"
Calling
usrsctp_connect
"
)
)
;
r
=
usrsctp_connect
(
mMasterSocket
reinterpret_cast
<
struct
sockaddr
*
>
(
&
addr
)
sizeof
(
addr
)
)
;
if
(
r
>
=
0
|
|
errno
=
=
EINPROGRESS
)
{
struct
sctp_paddrparams
paddrparams
;
socklen_t
opt_len
;
memset
(
&
paddrparams
0
sizeof
(
struct
sctp_paddrparams
)
)
;
memcpy
(
&
paddrparams
.
spp_address
&
addr
sizeof
(
struct
sockaddr_conn
)
)
;
opt_len
=
(
socklen_t
)
sizeof
(
struct
sctp_paddrparams
)
;
r
=
usrsctp_getsockopt
(
mMasterSocket
IPPROTO_SCTP
SCTP_PEER_ADDR_PARAMS
&
paddrparams
&
opt_len
)
;
if
(
r
<
0
)
{
LOG
(
(
"
usrsctp_getsockopt
failed
:
%
d
"
r
)
)
;
}
else
{
paddrparams
.
spp_pathmtu
=
1200
;
paddrparams
.
spp_flags
&
=
~
SPP_PMTUD_ENABLE
;
paddrparams
.
spp_flags
|
=
SPP_PMTUD_DISABLE
;
opt_len
=
(
socklen_t
)
sizeof
(
struct
sctp_paddrparams
)
;
r
=
usrsctp_setsockopt
(
mMasterSocket
IPPROTO_SCTP
SCTP_PEER_ADDR_PARAMS
&
paddrparams
opt_len
)
;
if
(
r
<
0
)
{
LOG
(
(
"
usrsctp_getsockopt
failed
:
%
d
"
r
)
)
;
}
else
{
LOG
(
(
"
usrsctp
:
PMTUD
disabled
MTU
set
to
%
u
"
paddrparams
.
spp_pathmtu
)
)
;
}
}
}
if
(
r
<
0
)
{
if
(
errno
=
=
EINPROGRESS
)
{
return
;
}
LOG
(
(
"
usrsctp_connect
failed
:
%
d
"
errno
)
)
;
mState
=
CLOSED
;
}
else
{
return
;
}
}
Dispatch
(
do_AddRef
(
new
DataChannelOnMessageAvailable
(
DataChannelOnMessageAvailable
:
:
ON_CONNECTION
this
)
)
)
;
}
void
DataChannelConnection
:
:
ProcessQueuedOpens
(
)
{
nsDeque
temp
;
DataChannel
*
temp_channel
;
while
(
nullptr
!
=
(
temp_channel
=
static_cast
<
DataChannel
*
>
(
mPending
.
PopFront
(
)
)
)
)
{
temp
.
Push
(
static_cast
<
void
*
>
(
temp_channel
)
)
;
}
RefPtr
<
DataChannel
>
channel
;
while
(
nullptr
!
=
(
channel
=
dont_AddRef
(
static_cast
<
DataChannel
*
>
(
temp
.
PopFront
(
)
)
)
)
)
{
if
(
channel
-
>
mFlags
&
DATA_CHANNEL_FLAGS_FINISH_OPEN
)
{
LOG
(
(
"
Processing
queued
open
for
%
p
(
%
u
)
"
channel
.
get
(
)
channel
-
>
mStream
)
)
;
channel
-
>
mFlags
&
=
~
DATA_CHANNEL_FLAGS_FINISH_OPEN
;
channel
=
OpenFinish
(
channel
.
forget
(
)
)
;
}
else
{
NS_ASSERTION
(
false
"
How
did
a
DataChannel
get
queued
without
the
FINISH_OPEN
flag
?
"
)
;
}
}
}
void
DataChannelConnection
:
:
SctpDtlsInput
(
const
std
:
:
string
&
aTransportId
MediaPacket
&
packet
)
{
if
(
(
packet
.
type
(
)
!
=
MediaPacket
:
:
SCTP
)
|
|
(
mTransportId
!
=
aTransportId
)
)
{
return
;
}
if
(
MOZ_LOG_TEST
(
gSCTPLog
LogLevel
:
:
Debug
)
)
{
char
*
buf
;
if
(
(
buf
=
usrsctp_dumppacket
(
(
void
*
)
packet
.
data
(
)
packet
.
len
(
)
SCTP_DUMP_INBOUND
)
)
!
=
nullptr
)
{
SCTP_LOG
(
(
"
%
s
"
buf
)
)
;
usrsctp_freedumpbuffer
(
buf
)
;
}
}
MutexAutoLock
lock
(
mLock
)
;
usrsctp_conninput
(
static_cast
<
void
*
>
(
this
)
packet
.
data
(
)
packet
.
len
(
)
0
)
;
}
void
DataChannelConnection
:
:
SendPacket
(
nsAutoPtr
<
MediaPacket
>
packet
)
{
if
(
!
mTransportId
.
empty
(
)
&
&
mTransportHandler
)
{
mTransportHandler
-
>
SendPacket
(
mTransportId
std
:
:
move
(
*
packet
)
)
;
}
}
int
DataChannelConnection
:
:
SctpDtlsOutput
(
void
*
addr
void
*
buffer
size_t
length
uint8_t
tos
uint8_t
set_df
)
{
DataChannelConnection
*
peer
=
static_cast
<
DataChannelConnection
*
>
(
addr
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
peer
-
>
mShutdown
)
;
if
(
MOZ_LOG_TEST
(
gSCTPLog
LogLevel
:
:
Debug
)
)
{
char
*
buf
;
if
(
(
buf
=
usrsctp_dumppacket
(
buffer
length
SCTP_DUMP_OUTBOUND
)
)
!
=
nullptr
)
{
SCTP_LOG
(
(
"
%
s
"
buf
)
)
;
usrsctp_freedumpbuffer
(
buf
)
;
}
}
nsAutoPtr
<
MediaPacket
>
packet
(
new
MediaPacket
)
;
packet
-
>
SetType
(
MediaPacket
:
:
SCTP
)
;
packet
-
>
Copy
(
static_cast
<
const
uint8_t
*
>
(
buffer
)
length
)
;
peer
-
>
mSTS
-
>
Dispatch
(
WrapRunnable
(
RefPtr
<
DataChannelConnection
>
(
peer
)
&
DataChannelConnection
:
:
SendPacket
packet
)
NS_DISPATCH_NORMAL
)
;
return
0
;
}
#
endif
#
ifdef
ALLOW_DIRECT_SCTP_LISTEN_CONNECT
bool
DataChannelConnection
:
:
Listen
(
unsigned
short
port
)
{
struct
sockaddr_in
addr
;
socklen_t
addr_len
;
NS_WARNING_ASSERTION
(
!
NS_IsMainThread
(
)
"
Blocks
do
not
call
from
main
thread
!
!
!
"
)
;
memset
(
(
void
*
)
&
addr
0
sizeof
(
addr
)
)
;
#
ifdef
HAVE_SIN_LEN
addr
.
sin_len
=
sizeof
(
struct
sockaddr_in
)
;
#
endif
addr
.
sin_family
=
AF_INET
;
addr
.
sin_port
=
htons
(
port
)
;
addr
.
sin_addr
.
s_addr
=
htonl
(
INADDR_ANY
)
;
LOG
(
(
"
Waiting
for
connections
on
port
%
u
"
ntohs
(
addr
.
sin_port
)
)
)
;
mState
=
CONNECTING
;
if
(
usrsctp_bind
(
mMasterSocket
reinterpret_cast
<
struct
sockaddr
*
>
(
&
addr
)
sizeof
(
struct
sockaddr_in
)
)
<
0
)
{
LOG
(
(
"
*
*
*
Failed
userspace_bind
"
)
)
;
return
false
;
}
if
(
usrsctp_listen
(
mMasterSocket
1
)
<
0
)
{
LOG
(
(
"
*
*
*
Failed
userspace_listen
"
)
)
;
return
false
;
}
LOG
(
(
"
Accepting
connection
"
)
)
;
addr_len
=
0
;
if
(
(
mSocket
=
usrsctp_accept
(
mMasterSocket
nullptr
&
addr_len
)
)
=
=
nullptr
)
{
LOG
(
(
"
*
*
*
Failed
accept
"
)
)
;
return
false
;
}
mState
=
OPEN
;
struct
linger
l
;
l
.
l_onoff
=
1
;
l
.
l_linger
=
0
;
if
(
usrsctp_setsockopt
(
mSocket
SOL_SOCKET
SO_LINGER
(
const
void
*
)
&
l
(
socklen_t
)
sizeof
(
struct
linger
)
)
<
0
)
{
LOG
(
(
"
Couldn
'
t
set
SO_LINGER
on
SCTP
socket
"
)
)
;
}
LOG
(
(
"
%
s
:
sending
ON_CONNECTION
for
%
p
"
__FUNCTION__
this
)
)
;
Dispatch
(
do_AddRef
(
new
DataChannelOnMessageAvailable
(
DataChannelOnMessageAvailable
:
:
ON_CONNECTION
this
(
DataChannel
*
)
nullptr
)
)
)
;
return
true
;
}
bool
DataChannelConnection
:
:
Connect
(
const
char
*
addr
unsigned
short
port
)
{
struct
sockaddr_in
addr4
;
struct
sockaddr_in6
addr6
;
NS_WARNING_ASSERTION
(
!
NS_IsMainThread
(
)
"
Blocks
do
not
call
from
main
thread
!
!
!
"
)
;
LOG
(
(
"
Connecting
to
%
s
port
%
u
"
addr
port
)
)
;
memset
(
(
void
*
)
&
addr4
0
sizeof
(
struct
sockaddr_in
)
)
;
memset
(
(
void
*
)
&
addr6
0
sizeof
(
struct
sockaddr_in6
)
)
;
#
ifdef
HAVE_SIN_LEN
addr4
.
sin_len
=
sizeof
(
struct
sockaddr_in
)
;
#
endif
#
ifdef
HAVE_SIN6_LEN
addr6
.
sin6_len
=
sizeof
(
struct
sockaddr_in6
)
;
#
endif
addr4
.
sin_family
=
AF_INET
;
addr6
.
sin6_family
=
AF_INET6
;
addr4
.
sin_port
=
htons
(
port
)
;
addr6
.
sin6_port
=
htons
(
port
)
;
mState
=
CONNECTING
;
#
if
!
defined
(
__Userspace_os_Windows
)
if
(
inet_pton
(
AF_INET6
addr
&
addr6
.
sin6_addr
)
=
=
1
)
{
if
(
usrsctp_connect
(
mMasterSocket
reinterpret_cast
<
struct
sockaddr
*
>
(
&
addr6
)
sizeof
(
struct
sockaddr_in6
)
)
<
0
)
{
LOG
(
(
"
*
*
*
Failed
userspace_connect
"
)
)
;
return
false
;
}
}
else
if
(
inet_pton
(
AF_INET
addr
&
addr4
.
sin_addr
)
=
=
1
)
{
if
(
usrsctp_connect
(
mMasterSocket
reinterpret_cast
<
struct
sockaddr
*
>
(
&
addr4
)
sizeof
(
struct
sockaddr_in
)
)
<
0
)
{
LOG
(
(
"
*
*
*
Failed
userspace_connect
"
)
)
;
return
false
;
}
}
else
{
LOG
(
(
"
*
*
*
Illegal
destination
address
.
"
)
)
;
}
#
else
{
struct
sockaddr_storage
ss
;
int
sslen
=
sizeof
(
ss
)
;
if
(
!
WSAStringToAddressA
(
const_cast
<
char
*
>
(
addr
)
AF_INET6
nullptr
(
struct
sockaddr
*
)
&
ss
&
sslen
)
)
{
addr6
.
sin6_addr
=
(
reinterpret_cast
<
struct
sockaddr_in6
*
>
(
&
ss
)
)
-
>
sin6_addr
;
if
(
usrsctp_connect
(
mMasterSocket
reinterpret_cast
<
struct
sockaddr
*
>
(
&
addr6
)
sizeof
(
struct
sockaddr_in6
)
)
<
0
)
{
LOG
(
(
"
*
*
*
Failed
userspace_connect
"
)
)
;
return
false
;
}
}
else
if
(
!
WSAStringToAddressA
(
const_cast
<
char
*
>
(
addr
)
AF_INET
nullptr
(
struct
sockaddr
*
)
&
ss
&
sslen
)
)
{
addr4
.
sin_addr
=
(
reinterpret_cast
<
struct
sockaddr_in
*
>
(
&
ss
)
)
-
>
sin_addr
;
if
(
usrsctp_connect
(
mMasterSocket
reinterpret_cast
<
struct
sockaddr
*
>
(
&
addr4
)
sizeof
(
struct
sockaddr_in
)
)
<
0
)
{
LOG
(
(
"
*
*
*
Failed
userspace_connect
"
)
)
;
return
false
;
}
}
else
{
LOG
(
(
"
*
*
*
Illegal
destination
address
.
"
)
)
;
}
}
#
endif
mSocket
=
mMasterSocket
;
LOG
(
(
"
connect
(
)
succeeded
!
Entering
connected
mode
"
)
)
;
mState
=
OPEN
;
LOG
(
(
"
%
s
:
sending
ON_CONNECTION
for
%
p
"
__FUNCTION__
this
)
)
;
Dispatch
(
do_AddRef
(
new
DataChannelOnMessageAvailable
(
DataChannelOnMessageAvailable
:
:
ON_CONNECTION
this
(
DataChannel
*
)
nullptr
)
)
)
;
return
true
;
}
#
endif
DataChannel
*
DataChannelConnection
:
:
FindChannelByStream
(
uint16_t
stream
)
{
return
mStreams
.
SafeElementAt
(
stream
)
;
}
uint16_t
DataChannelConnection
:
:
FindFreeStream
(
)
{
uint32_t
i
j
limit
;
limit
=
mStreams
.
Length
(
)
;
if
(
limit
>
MAX_NUM_STREAMS
)
limit
=
MAX_NUM_STREAMS
;
for
(
i
=
(
mAllocateEven
?
0
:
1
)
;
i
<
limit
;
i
+
=
2
)
{
if
(
!
mStreams
[
i
]
)
{
for
(
j
=
0
;
j
<
mStreamsResetting
.
Length
(
)
;
+
+
j
)
{
if
(
mStreamsResetting
[
j
]
=
=
i
)
{
break
;
}
}
if
(
j
=
=
mStreamsResetting
.
Length
(
)
)
break
;
}
}
if
(
i
>
=
limit
)
{
return
INVALID_STREAM
;
}
return
i
;
}
uint32_t
DataChannelConnection
:
:
UpdateCurrentStreamIndex
(
)
{
if
(
mCurrentStream
=
=
mStreams
.
Length
(
)
-
1
)
{
mCurrentStream
=
0
;
}
else
{
+
+
mCurrentStream
;
}
return
mCurrentStream
;
}
uint32_t
DataChannelConnection
:
:
GetCurrentStreamIndex
(
)
{
if
(
mCurrentStream
>
=
mStreams
.
Length
(
)
)
{
mCurrentStream
=
0
;
}
return
mCurrentStream
;
}
bool
DataChannelConnection
:
:
RequestMoreStreams
(
int32_t
aNeeded
)
{
struct
sctp_status
status
;
struct
sctp_add_streams
sas
;
uint32_t
outStreamsNeeded
;
socklen_t
len
;
if
(
aNeeded
+
mStreams
.
Length
(
)
>
MAX_NUM_STREAMS
)
{
aNeeded
=
MAX_NUM_STREAMS
-
mStreams
.
Length
(
)
;
}
if
(
aNeeded
<
=
0
)
{
return
false
;
}
len
=
(
socklen_t
)
sizeof
(
struct
sctp_status
)
;
if
(
usrsctp_getsockopt
(
mMasterSocket
IPPROTO_SCTP
SCTP_STATUS
&
status
&
len
)
<
0
)
{
LOG
(
(
"
*
*
*
failed
:
getsockopt
SCTP_STATUS
"
)
)
;
return
false
;
}
outStreamsNeeded
=
aNeeded
;
memset
(
&
sas
0
sizeof
(
sas
)
)
;
sas
.
sas_instrms
=
0
;
sas
.
sas_outstrms
=
(
uint16_t
)
outStreamsNeeded
;
if
(
usrsctp_setsockopt
(
mMasterSocket
IPPROTO_SCTP
SCTP_ADD_STREAMS
&
sas
(
socklen_t
)
sizeof
(
struct
sctp_add_streams
)
)
<
0
)
{
if
(
errno
=
=
EALREADY
)
{
LOG
(
(
"
Already
have
%
u
output
streams
"
outStreamsNeeded
)
)
;
return
true
;
}
LOG
(
(
"
*
*
*
failed
:
setsockopt
ADD
errno
=
%
d
"
errno
)
)
;
return
false
;
}
LOG
(
(
"
Requested
%
u
more
streams
"
outStreamsNeeded
)
)
;
return
true
;
}
int
DataChannelConnection
:
:
SendControlMessage
(
const
uint8_t
*
data
uint32_t
len
uint16_t
stream
)
{
struct
sctp_sendv_spa
info
=
{
0
}
;
info
.
sendv_flags
=
SCTP_SEND_SNDINFO_VALID
;
info
.
sendv_sndinfo
.
snd_sid
=
stream
;
info
.
sendv_sndinfo
.
snd_flags
=
SCTP_EOR
;
info
.
sendv_sndinfo
.
snd_ppid
=
htonl
(
DATA_CHANNEL_PPID_CONTROL
)
;
#
if
(
UINT32_MAX
>
SIZE_MAX
)
if
(
len
>
SIZE_MAX
)
{
return
EMSGSIZE
;
}
#
endif
OutgoingMsg
msg
(
info
data
(
size_t
)
len
)
;
bool
buffered
;
int
error
=
SendMsgInternalOrBuffer
(
mBufferedControl
msg
buffered
)
;
if
(
!
error
&
&
buffered
&
&
!
mPendingType
)
{
mPendingType
=
PENDING_DCEP
;
}
return
error
;
}
int
DataChannelConnection
:
:
SendOpenAckMessage
(
uint16_t
stream
)
{
struct
rtcweb_datachannel_ack
ack
;
memset
(
&
ack
0
sizeof
(
struct
rtcweb_datachannel_ack
)
)
;
ack
.
msg_type
=
DATA_CHANNEL_ACK
;
return
SendControlMessage
(
(
const
uint8_t
*
)
&
ack
sizeof
(
ack
)
stream
)
;
}
int
DataChannelConnection
:
:
SendOpenRequestMessage
(
const
nsACString
&
label
const
nsACString
&
protocol
uint16_t
stream
bool
unordered
uint16_t
prPolicy
uint32_t
prValue
)
{
const
int
label_len
=
label
.
Length
(
)
;
const
int
proto_len
=
protocol
.
Length
(
)
;
const
int
req_size
=
sizeof
(
struct
rtcweb_datachannel_open_request
)
-
1
+
label_len
+
proto_len
;
struct
rtcweb_datachannel_open_request
*
req
=
(
struct
rtcweb_datachannel_open_request
*
)
moz_xmalloc
(
req_size
)
;
memset
(
req
0
req_size
)
;
req
-
>
msg_type
=
DATA_CHANNEL_OPEN_REQUEST
;
switch
(
prPolicy
)
{
case
SCTP_PR_SCTP_NONE
:
req
-
>
channel_type
=
DATA_CHANNEL_RELIABLE
;
break
;
case
SCTP_PR_SCTP_TTL
:
req
-
>
channel_type
=
DATA_CHANNEL_PARTIAL_RELIABLE_TIMED
;
break
;
case
SCTP_PR_SCTP_RTX
:
req
-
>
channel_type
=
DATA_CHANNEL_PARTIAL_RELIABLE_REXMIT
;
break
;
default
:
free
(
req
)
;
return
EINVAL
;
}
if
(
unordered
)
{
req
-
>
channel_type
|
=
0x80
;
}
req
-
>
reliability_param
=
htonl
(
prValue
)
;
req
-
>
priority
=
htons
(
0
)
;
req
-
>
label_length
=
htons
(
label_len
)
;
req
-
>
protocol_length
=
htons
(
proto_len
)
;
memcpy
(
&
req
-
>
label
[
0
]
PromiseFlatCString
(
label
)
.
get
(
)
label_len
)
;
memcpy
(
&
req
-
>
label
[
label_len
]
PromiseFlatCString
(
protocol
)
.
get
(
)
proto_len
)
;
int
error
=
SendControlMessage
(
(
const
uint8_t
*
)
req
req_size
stream
)
;
free
(
req
)
;
return
error
;
}
bool
DataChannelConnection
:
:
SendDeferredMessages
(
)
{
RefPtr
<
DataChannel
>
channel
;
mLock
.
AssertCurrentThreadOwns
(
)
;
LOG
(
(
"
SendDeferredMessages
called
pending
type
:
%
d
"
mPendingType
)
)
;
if
(
!
mPendingType
)
{
return
false
;
}
if
(
!
mBufferedControl
.
IsEmpty
(
)
&
&
(
mSendInterleaved
|
|
mPendingType
=
=
PENDING_DCEP
)
)
{
if
(
SendBufferedMessages
(
mBufferedControl
)
)
{
return
true
;
}
mPendingType
=
PENDING_DATA
;
}
bool
blocked
=
false
;
uint32_t
i
=
GetCurrentStreamIndex
(
)
;
uint32_t
end
=
i
;
do
{
channel
=
mStreams
[
i
]
;
if
(
!
channel
|
|
channel
-
>
mBufferedData
.
IsEmpty
(
)
)
{
i
=
UpdateCurrentStreamIndex
(
)
;
continue
;
}
if
(
channel
-
>
mState
=
=
CLOSED
|
|
channel
-
>
mState
=
=
CLOSING
)
{
channel
-
>
mBufferedData
.
Clear
(
)
;
i
=
UpdateCurrentStreamIndex
(
)
;
continue
;
}
size_t
bufferedAmount
=
channel
-
>
GetBufferedAmountLocked
(
)
;
size_t
threshold
=
channel
-
>
mBufferedThreshold
;
bool
wasOverThreshold
=
bufferedAmount
>
=
threshold
;
blocked
=
SendBufferedMessages
(
channel
-
>
mBufferedData
)
;
bufferedAmount
=
channel
-
>
GetBufferedAmountLocked
(
)
;
if
(
wasOverThreshold
&
&
bufferedAmount
<
threshold
)
{
LOG
(
(
"
%
s
:
sending
BUFFER_LOW_THRESHOLD
for
%
s
/
%
s
:
%
u
"
__FUNCTION__
channel
-
>
mLabel
.
get
(
)
channel
-
>
mProtocol
.
get
(
)
channel
-
>
mStream
)
)
;
Dispatch
(
do_AddRef
(
new
DataChannelOnMessageAvailable
(
DataChannelOnMessageAvailable
:
:
BUFFER_LOW_THRESHOLD
this
channel
)
)
)
;
}
if
(
bufferedAmount
=
=
0
)
{
LOG
(
(
"
%
s
:
sending
NO_LONGER_BUFFERED
for
%
s
/
%
s
:
%
u
"
__FUNCTION__
channel
-
>
mLabel
.
get
(
)
channel
-
>
mProtocol
.
get
(
)
channel
-
>
mStream
)
)
;
Dispatch
(
do_AddRef
(
new
DataChannelOnMessageAvailable
(
DataChannelOnMessageAvailable
:
:
NO_LONGER_BUFFERED
this
channel
)
)
)
;
}
if
(
mSendInterleaved
|
|
!
blocked
)
{
i
=
UpdateCurrentStreamIndex
(
)
;
}
}
while
(
!
blocked
&
&
i
!
=
end
)
;
if
(
!
blocked
)
{
mPendingType
=
mBufferedControl
.
IsEmpty
(
)
?
PENDING_NONE
:
PENDING_DCEP
;
}
return
blocked
;
}
bool
DataChannelConnection
:
:
SendBufferedMessages
(
nsTArray
<
nsAutoPtr
<
BufferedOutgoingMsg
>
>
&
buffer
)
{
do
{
int
error
=
SendMsgInternal
(
*
buffer
[
0
]
)
;
switch
(
error
)
{
case
0
:
buffer
.
RemoveElementAt
(
0
)
;
break
;
case
EAGAIN
:
#
if
(
EAGAIN
!
=
EWOULDBLOCK
)
case
EWOULDBLOCK
:
#
endif
return
true
;
default
:
buffer
.
RemoveElementAt
(
0
)
;
LOG
(
(
"
error
on
sending
:
%
d
"
error
)
)
;
break
;
}
}
while
(
!
buffer
.
IsEmpty
(
)
)
;
return
false
;
}
void
DataChannelConnection
:
:
HandleOpenRequestMessage
(
const
struct
rtcweb_datachannel_open_request
*
req
uint32_t
length
uint16_t
stream
)
{
RefPtr
<
DataChannel
>
channel
;
uint32_t
prValue
;
uint16_t
prPolicy
;
uint32_t
flags
;
mLock
.
AssertCurrentThreadOwns
(
)
;
const
size_t
requiredLength
=
(
sizeof
(
*
req
)
-
1
)
+
ntohs
(
req
-
>
label_length
)
+
ntohs
(
req
-
>
protocol_length
)
;
if
(
(
(
size_t
)
length
)
!
=
requiredLength
)
{
LOG
(
(
"
%
s
:
Inconsistent
length
:
%
u
should
be
%
zu
"
__FUNCTION__
length
requiredLength
)
)
;
if
(
(
(
size_t
)
length
)
<
requiredLength
)
return
;
}
LOG
(
(
"
%
s
:
length
%
u
sizeof
(
*
req
)
=
%
zu
"
__FUNCTION__
length
sizeof
(
*
req
)
)
)
;
switch
(
req
-
>
channel_type
)
{
case
DATA_CHANNEL_RELIABLE
:
case
DATA_CHANNEL_RELIABLE_UNORDERED
:
prPolicy
=
SCTP_PR_SCTP_NONE
;
break
;
case
DATA_CHANNEL_PARTIAL_RELIABLE_REXMIT
:
case
DATA_CHANNEL_PARTIAL_RELIABLE_REXMIT_UNORDERED
:
prPolicy
=
SCTP_PR_SCTP_RTX
;
break
;
case
DATA_CHANNEL_PARTIAL_RELIABLE_TIMED
:
case
DATA_CHANNEL_PARTIAL_RELIABLE_TIMED_UNORDERED
:
prPolicy
=
SCTP_PR_SCTP_TTL
;
break
;
default
:
LOG
(
(
"
Unknown
channel
type
%
d
"
req
-
>
channel_type
)
)
;
return
;
}
prValue
=
ntohl
(
req
-
>
reliability_param
)
;
flags
=
(
req
-
>
channel_type
&
0x80
)
?
DATA_CHANNEL_FLAGS_OUT_OF_ORDER_ALLOWED
:
0
;
if
(
(
channel
=
FindChannelByStream
(
stream
)
)
)
{
if
(
!
(
channel
-
>
mFlags
&
DATA_CHANNEL_FLAGS_EXTERNAL_NEGOTIATED
)
)
{
LOG
(
(
"
ERROR
:
HandleOpenRequestMessage
:
channel
for
stream
%
u
is
in
state
"
"
%
d
instead
of
CLOSED
.
"
stream
channel
-
>
mState
)
)
;
}
else
{
LOG
(
(
"
Open
for
externally
negotiated
channel
%
u
"
stream
)
)
;
if
(
prPolicy
!
=
channel
-
>
mPrPolicy
|
|
prValue
!
=
channel
-
>
mPrValue
|
|
flags
!
=
(
channel
-
>
mFlags
&
DATA_CHANNEL_FLAGS_OUT_OF_ORDER_ALLOWED
)
)
{
LOG
(
(
"
WARNING
:
external
negotiation
mismatch
with
OpenRequest
:
"
"
channel
%
u
policy
%
u
/
%
u
value
%
u
/
%
u
flags
%
x
/
%
x
"
stream
prPolicy
channel
-
>
mPrPolicy
prValue
channel
-
>
mPrValue
flags
channel
-
>
mFlags
)
)
;
}
}
return
;
}
if
(
stream
>
=
mStreams
.
Length
(
)
)
{
LOG
(
(
"
%
s
:
stream
%
u
out
of
bounds
(
%
zu
)
"
__FUNCTION__
stream
mStreams
.
Length
(
)
)
)
;
return
;
}
nsCString
label
(
nsDependentCSubstring
(
&
req
-
>
label
[
0
]
ntohs
(
req
-
>
label_length
)
)
)
;
nsCString
protocol
(
nsDependentCSubstring
(
&
req
-
>
label
[
ntohs
(
req
-
>
label_length
)
]
ntohs
(
req
-
>
protocol_length
)
)
)
;
channel
=
new
DataChannel
(
this
stream
DataChannel
:
:
CONNECTING
label
protocol
prPolicy
prValue
flags
nullptr
nullptr
)
;
mStreams
[
stream
]
=
channel
;
channel
-
>
mState
=
DataChannel
:
:
WAITING_TO_OPEN
;
LOG
(
(
"
%
s
:
sending
ON_CHANNEL_CREATED
for
%
s
/
%
s
:
%
u
(
state
%
u
)
"
__FUNCTION__
channel
-
>
mLabel
.
get
(
)
channel
-
>
mProtocol
.
get
(
)
stream
channel
-
>
mState
)
)
;
Dispatch
(
do_AddRef
(
new
DataChannelOnMessageAvailable
(
DataChannelOnMessageAvailable
:
:
ON_CHANNEL_CREATED
this
channel
)
)
)
;
LOG
(
(
"
%
s
:
deferring
sending
ON_CHANNEL_OPEN
for
%
p
"
__FUNCTION__
channel
.
get
(
)
)
)
;
int
error
=
SendOpenAckMessage
(
stream
)
;
if
(
error
)
{
LOG
(
(
"
SendOpenRequest
failed
error
=
%
d
"
error
)
)
;
CloseInt
(
channel
)
;
return
;
}
DeliverQueuedData
(
stream
)
;
}
void
DataChannelConnection
:
:
DeliverQueuedData
(
uint16_t
stream
)
{
mLock
.
AssertCurrentThreadOwns
(
)
;
uint32_t
i
=
0
;
while
(
i
<
mQueuedData
.
Length
(
)
)
{
if
(
mQueuedData
[
i
]
-
>
mStream
=
=
stream
)
{
LOG
(
(
"
Delivering
queued
data
for
stream
%
u
length
%
u
"
stream
mQueuedData
[
i
]
-
>
mLength
)
)
;
HandleDataMessage
(
mQueuedData
[
i
]
-
>
mData
mQueuedData
[
i
]
-
>
mLength
mQueuedData
[
i
]
-
>
mPpid
mQueuedData
[
i
]
-
>
mStream
mQueuedData
[
i
]
-
>
mFlags
)
;
mQueuedData
.
RemoveElementAt
(
i
)
;
continue
;
}
i
+
+
;
}
}
void
DataChannelConnection
:
:
HandleOpenAckMessage
(
const
struct
rtcweb_datachannel_ack
*
ack
uint32_t
length
uint16_t
stream
)
{
DataChannel
*
channel
;
mLock
.
AssertCurrentThreadOwns
(
)
;
channel
=
FindChannelByStream
(
stream
)
;
if
(
NS_WARN_IF
(
!
channel
)
)
{
return
;
}
LOG
(
(
"
OpenAck
received
for
stream
%
u
waiting
=
%
d
"
stream
(
channel
-
>
mFlags
&
DATA_CHANNEL_FLAGS_WAITING_ACK
)
?
1
:
0
)
)
;
channel
-
>
mFlags
&
=
~
DATA_CHANNEL_FLAGS_WAITING_ACK
;
}
void
DataChannelConnection
:
:
HandleUnknownMessage
(
uint32_t
ppid
uint32_t
length
uint16_t
stream
)
{
LOG
(
(
"
unknown
DataChannel
message
received
:
%
u
len
%
u
on
stream
%
d
"
ppid
length
stream
)
)
;
}
uint8_t
DataChannelConnection
:
:
BufferMessage
(
nsACString
&
recvBuffer
const
void
*
data
uint32_t
length
uint32_t
ppid
int
flags
)
{
const
char
*
buffer
=
(
const
char
*
)
data
;
uint8_t
bufferFlags
=
0
;
if
(
(
flags
&
MSG_EOR
)
&
&
ppid
!
=
DATA_CHANNEL_PPID_BINARY_PARTIAL
&
&
ppid
!
=
DATA_CHANNEL_PPID_DOMSTRING_PARTIAL
)
{
bufferFlags
|
=
DATA_CHANNEL_BUFFER_MESSAGE_FLAGS_COMPLETE
;
if
(
recvBuffer
.
IsEmpty
(
)
)
{
return
bufferFlags
;
}
}
if
(
(
(
uint64_t
)
recvBuffer
.
Length
(
)
)
+
(
(
uint64_t
)
length
)
>
WEBRTC_DATACHANNEL_MAX_MESSAGE_SIZE_LOCAL
)
{
bufferFlags
|
=
DATA_CHANNEL_BUFFER_MESSAGE_FLAGS_TOO_LARGE
;
return
bufferFlags
;
}
recvBuffer
.
Append
(
buffer
length
)
;
bufferFlags
|
=
DATA_CHANNEL_BUFFER_MESSAGE_FLAGS_BUFFERED
;
return
bufferFlags
;
}
void
DataChannelConnection
:
:
HandleDataMessage
(
const
void
*
data
size_t
length
uint32_t
ppid
uint16_t
stream
int
flags
)
{
DataChannel
*
channel
;
const
char
*
buffer
=
(
const
char
*
)
data
;
mLock
.
AssertCurrentThreadOwns
(
)
;
channel
=
FindChannelByStream
(
stream
)
;
#
if
(
SIZE_MAX
>
UINT32_MAX
)
if
(
length
>
UINT32_MAX
)
{
LOG
(
(
"
DataChannel
:
Cannot
handle
message
of
size
%
zu
(
max
=
%
"
PRIu32
"
)
"
length
UINT32_MAX
)
)
;
CloseInt
(
channel
)
;
return
;
}
#
endif
uint32_t
data_length
=
(
uint32_t
)
length
;
if
(
!
channel
)
{
LOG
(
(
"
Queuing
data
for
stream
%
u
length
%
u
"
stream
data_length
)
)
;
mQueuedData
.
AppendElement
(
new
QueuedDataMessage
(
stream
ppid
flags
data
data_length
)
)
;
return
;
}
if
(
channel
-
>
mState
=
=
CLOSED
)
{
return
;
}
bool
is_binary
=
true
;
uint8_t
bufferFlags
;
int32_t
type
;
const
char
*
info
=
"
"
;
if
(
ppid
=
=
DATA_CHANNEL_PPID_DOMSTRING_PARTIAL
|
|
ppid
=
=
DATA_CHANNEL_PPID_DOMSTRING
)
{
is_binary
=
false
;
}
if
(
is_binary
!
=
channel
-
>
mIsRecvBinary
&
&
!
channel
-
>
mRecvBuffer
.
IsEmpty
(
)
)
{
NS_WARNING
(
"
DataChannel
message
aborted
by
fragment
type
change
!
"
)
;
channel
-
>
mRecvBuffer
.
Truncate
(
0
)
;
}
channel
-
>
mIsRecvBinary
=
is_binary
;
if
(
channel
-
>
mFlags
&
DATA_CHANNEL_FLAGS_CLOSING_TOO_LARGE
)
{
LOG
(
(
"
DataChannel
:
Ignoring
partial
message
of
length
%
u
buffer
full
and
"
"
closing
"
data_length
)
)
;
if
(
(
channel
-
>
mFlags
&
DATA_CHANNEL_FLAGS_OUT_OF_ORDER_ALLOWED
)
&
&
(
flags
&
MSG_EOR
)
)
{
channel
-
>
mFlags
&
=
~
DATA_CHANNEL_FLAGS_CLOSING_TOO_LARGE
;
}
}
bufferFlags
=
BufferMessage
(
channel
-
>
mRecvBuffer
buffer
data_length
ppid
flags
)
;
if
(
bufferFlags
&
DATA_CHANNEL_BUFFER_MESSAGE_FLAGS_TOO_LARGE
)
{
LOG
(
(
"
DataChannel
:
Buffered
message
would
become
too
large
to
handle
"
"
closing
channel
"
)
)
;
channel
-
>
mRecvBuffer
.
Truncate
(
0
)
;
channel
-
>
mFlags
|
=
DATA_CHANNEL_FLAGS_CLOSING_TOO_LARGE
;
CloseInt
(
channel
)
;
return
;
}
if
(
!
(
bufferFlags
&
DATA_CHANNEL_BUFFER_MESSAGE_FLAGS_COMPLETE
)
)
{
LOG
(
(
"
DataChannel
:
Partial
%
s
message
of
length
%
u
(
total
%
u
)
on
channel
"
"
id
%
u
"
is_binary
?
"
binary
"
:
"
string
"
data_length
channel
-
>
mRecvBuffer
.
Length
(
)
channel
-
>
mStream
)
)
;
return
;
}
if
(
bufferFlags
&
DATA_CHANNEL_BUFFER_MESSAGE_FLAGS_BUFFERED
)
{
data_length
=
channel
-
>
mRecvBuffer
.
Length
(
)
;
}
if
(
data_length
>
WEBRTC_DATACHANNEL_MAX_MESSAGE_SIZE_LOCAL
)
{
LOG
(
(
"
DataChannel
:
Received
message
of
length
%
u
is
>
announced
maximum
"
"
message
size
(
%
u
)
"
data_length
WEBRTC_DATACHANNEL_MAX_MESSAGE_SIZE_LOCAL
)
)
;
}
switch
(
ppid
)
{
case
DATA_CHANNEL_PPID_DOMSTRING
:
LOG
(
(
"
DataChannel
:
Received
string
message
of
length
%
u
on
channel
%
u
"
data_length
channel
-
>
mStream
)
)
;
type
=
DataChannelOnMessageAvailable
:
:
ON_DATA_STRING
;
if
(
bufferFlags
&
DATA_CHANNEL_BUFFER_MESSAGE_FLAGS_BUFFERED
)
{
info
=
"
(
string
fragmented
)
"
;
}
break
;
case
DATA_CHANNEL_PPID_BINARY
:
LOG
(
(
"
DataChannel
:
Received
binary
message
of
length
%
u
on
channel
id
%
u
"
data_length
channel
-
>
mStream
)
)
;
type
=
DataChannelOnMessageAvailable
:
:
ON_DATA_BINARY
;
if
(
bufferFlags
&
DATA_CHANNEL_BUFFER_MESSAGE_FLAGS_BUFFERED
)
{
info
=
"
(
binary
fragmented
)
"
;
}
break
;
default
:
NS_ERROR
(
"
Unknown
data
PPID
"
)
;
return
;
}
LOG
(
(
"
%
s
:
sending
ON_DATA_
%
s
%
s
for
%
p
"
__FUNCTION__
(
type
=
=
DataChannelOnMessageAvailable
:
:
ON_DATA_STRING
)
?
"
STRING
"
:
"
BINARY
"
info
channel
)
)
;
if
(
bufferFlags
&
DATA_CHANNEL_BUFFER_MESSAGE_FLAGS_BUFFERED
)
{
channel
-
>
SendOrQueue
(
new
DataChannelOnMessageAvailable
(
type
this
channel
channel
-
>
mRecvBuffer
)
)
;
channel
-
>
mRecvBuffer
.
Truncate
(
0
)
;
}
else
{
nsAutoCString
recvData
(
buffer
data_length
)
;
channel
-
>
SendOrQueue
(
new
DataChannelOnMessageAvailable
(
type
this
channel
recvData
)
)
;
}
}
void
DataChannelConnection
:
:
HandleDCEPMessage
(
const
void
*
buffer
size_t
length
uint32_t
ppid
uint16_t
stream
int
flags
)
{
const
struct
rtcweb_datachannel_open_request
*
req
;
const
struct
rtcweb_datachannel_ack
*
ack
;
#
if
(
SIZE_MAX
>
UINT32_MAX
)
if
(
length
>
UINT32_MAX
)
{
LOG
(
(
"
DataChannel
:
Cannot
handle
message
of
size
%
zu
(
max
=
%
u
)
"
length
UINT32_MAX
)
)
;
Stop
(
)
;
return
;
}
#
endif
uint32_t
data_length
=
(
uint32_t
)
length
;
mLock
.
AssertCurrentThreadOwns
(
)
;
const
uint8_t
bufferFlags
=
BufferMessage
(
mRecvBuffer
buffer
data_length
ppid
flags
)
;
if
(
bufferFlags
&
DATA_CHANNEL_BUFFER_MESSAGE_FLAGS_TOO_LARGE
)
{
LOG
(
(
"
DataChannel
:
Buffered
message
would
become
too
large
to
handle
"
"
closing
connection
"
)
)
;
mRecvBuffer
.
Truncate
(
0
)
;
Stop
(
)
;
return
;
}
if
(
!
(
bufferFlags
&
DATA_CHANNEL_BUFFER_MESSAGE_FLAGS_COMPLETE
)
)
{
LOG
(
(
"
Buffered
partial
DCEP
message
of
length
%
u
"
data_length
)
)
;
return
;
}
if
(
bufferFlags
&
DATA_CHANNEL_BUFFER_MESSAGE_FLAGS_BUFFERED
)
{
buffer
=
reinterpret_cast
<
const
void
*
>
(
mRecvBuffer
.
BeginReading
(
)
)
;
data_length
=
mRecvBuffer
.
Length
(
)
;
}
req
=
static_cast
<
const
struct
rtcweb_datachannel_open_request
*
>
(
buffer
)
;
LOG
(
(
"
Handling
DCEP
message
of
length
%
u
"
data_length
)
)
;
if
(
(
size_t
)
data_length
<
sizeof
(
*
ack
)
)
{
LOG
(
(
"
Ignored
invalid
DCEP
message
(
too
short
)
"
)
)
;
return
;
}
switch
(
req
-
>
msg_type
)
{
case
DATA_CHANNEL_OPEN_REQUEST
:
if
(
NS_WARN_IF
(
(
size_t
)
data_length
<
sizeof
(
*
req
)
-
1
)
)
{
return
;
}
HandleOpenRequestMessage
(
req
data_length
stream
)
;
break
;
case
DATA_CHANNEL_ACK
:
ack
=
static_cast
<
const
struct
rtcweb_datachannel_ack
*
>
(
buffer
)
;
HandleOpenAckMessage
(
ack
data_length
stream
)
;
break
;
default
:
HandleUnknownMessage
(
ppid
data_length
stream
)
;
break
;
}
mRecvBuffer
.
Truncate
(
0
)
;
}
void
DataChannelConnection
:
:
HandleMessage
(
const
void
*
buffer
size_t
length
uint32_t
ppid
uint16_t
stream
int
flags
)
{
mLock
.
AssertCurrentThreadOwns
(
)
;
switch
(
ppid
)
{
case
DATA_CHANNEL_PPID_CONTROL
:
HandleDCEPMessage
(
buffer
length
ppid
stream
flags
)
;
break
;
case
DATA_CHANNEL_PPID_DOMSTRING_PARTIAL
:
case
DATA_CHANNEL_PPID_DOMSTRING
:
case
DATA_CHANNEL_PPID_BINARY_PARTIAL
:
case
DATA_CHANNEL_PPID_BINARY
:
HandleDataMessage
(
buffer
length
ppid
stream
flags
)
;
break
;
default
:
LOG
(
(
"
Message
of
length
%
zu
PPID
%
u
on
stream
%
u
received
(
%
s
)
.
"
length
ppid
stream
(
flags
&
MSG_EOR
)
?
"
complete
"
:
"
partial
"
)
)
;
break
;
}
}
void
DataChannelConnection
:
:
HandleAssociationChangeEvent
(
const
struct
sctp_assoc_change
*
sac
)
{
uint32_t
i
n
;
switch
(
sac
-
>
sac_state
)
{
case
SCTP_COMM_UP
:
LOG
(
(
"
Association
change
:
SCTP_COMM_UP
"
)
)
;
if
(
mState
=
=
CONNECTING
)
{
mSocket
=
mMasterSocket
;
mState
=
OPEN
;
LOG
(
(
"
Negotiated
number
of
incoming
streams
:
%
"
PRIu16
sac
-
>
sac_inbound_streams
)
)
;
if
(
!
mMaxMessageSizeSet
&
&
sac
-
>
sac_inbound_streams
=
=
WEBRTC_DATACHANNEL_STREAMS_OLDER_FIREFOX
)
{
LOG
(
(
"
Older
Firefox
detected
using
PPID
-
based
fragmentation
"
)
)
;
mPpidFragmentation
=
true
;
}
Dispatch
(
do_AddRef
(
new
DataChannelOnMessageAvailable
(
DataChannelOnMessageAvailable
:
:
ON_CONNECTION
this
)
)
)
;
LOG
(
(
"
DTLS
connect
(
)
succeeded
!
Entering
connected
mode
"
)
)
;
ProcessQueuedOpens
(
)
;
}
else
if
(
mState
=
=
OPEN
)
{
LOG
(
(
"
DataConnection
Already
OPEN
"
)
)
;
}
else
{
LOG
(
(
"
Unexpected
state
:
%
d
"
mState
)
)
;
}
break
;
case
SCTP_COMM_LOST
:
LOG
(
(
"
Association
change
:
SCTP_COMM_LOST
"
)
)
;
Stop
(
)
;
break
;
case
SCTP_RESTART
:
LOG
(
(
"
Association
change
:
SCTP_RESTART
"
)
)
;
break
;
case
SCTP_SHUTDOWN_COMP
:
LOG
(
(
"
Association
change
:
SCTP_SHUTDOWN_COMP
"
)
)
;
Stop
(
)
;
break
;
case
SCTP_CANT_STR_ASSOC
:
LOG
(
(
"
Association
change
:
SCTP_CANT_STR_ASSOC
"
)
)
;
break
;
default
:
LOG
(
(
"
Association
change
:
UNKNOWN
"
)
)
;
break
;
}
LOG
(
(
"
Association
change
:
streams
(
in
/
out
)
=
(
%
u
/
%
u
)
"
sac
-
>
sac_inbound_streams
sac
-
>
sac_outbound_streams
)
)
;
if
(
NS_WARN_IF
(
!
sac
)
)
{
return
;
}
n
=
sac
-
>
sac_length
-
sizeof
(
*
sac
)
;
if
(
(
sac
-
>
sac_state
=
=
SCTP_COMM_UP
)
|
|
(
sac
-
>
sac_state
=
=
SCTP_RESTART
)
)
{
if
(
n
>
0
)
{
for
(
i
=
0
;
i
<
n
;
+
+
i
)
{
switch
(
sac
-
>
sac_info
[
i
]
)
{
case
SCTP_ASSOC_SUPPORTS_PR
:
LOG
(
(
"
Supports
:
PR
"
)
)
;
break
;
case
SCTP_ASSOC_SUPPORTS_AUTH
:
LOG
(
(
"
Supports
:
AUTH
"
)
)
;
break
;
case
SCTP_ASSOC_SUPPORTS_ASCONF
:
LOG
(
(
"
Supports
:
ASCONF
"
)
)
;
break
;
case
SCTP_ASSOC_SUPPORTS_MULTIBUF
:
LOG
(
(
"
Supports
:
MULTIBUF
"
)
)
;
break
;
case
SCTP_ASSOC_SUPPORTS_RE_CONFIG
:
LOG
(
(
"
Supports
:
RE
-
CONFIG
"
)
)
;
break
;
#
if
defined
(
SCTP_ASSOC_SUPPORTS_INTERLEAVING
)
case
SCTP_ASSOC_SUPPORTS_INTERLEAVING
:
LOG
(
(
"
Supports
:
NDATA
"
)
)
;
mSendInterleaved
=
true
;
break
;
#
endif
default
:
LOG
(
(
"
Supports
:
UNKNOWN
(
0x
%
02x
)
"
sac
-
>
sac_info
[
i
]
)
)
;
break
;
}
}
}
}
else
if
(
(
(
sac
-
>
sac_state
=
=
SCTP_COMM_LOST
)
|
|
(
sac
-
>
sac_state
=
=
SCTP_CANT_STR_ASSOC
)
)
&
&
(
n
>
0
)
)
{
LOG
(
(
"
Association
:
ABORT
=
"
)
)
;
for
(
i
=
0
;
i
<
n
;
+
+
i
)
{
LOG
(
(
"
0x
%
02x
"
sac
-
>
sac_info
[
i
]
)
)
;
}
}
if
(
(
sac
-
>
sac_state
=
=
SCTP_CANT_STR_ASSOC
)
|
|
(
sac
-
>
sac_state
=
=
SCTP_SHUTDOWN_COMP
)
|
|
(
sac
-
>
sac_state
=
=
SCTP_COMM_LOST
)
)
{
return
;
}
}
void
DataChannelConnection
:
:
HandlePeerAddressChangeEvent
(
const
struct
sctp_paddr_change
*
spc
)
{
const
char
*
addr
=
"
"
;
#
if
!
defined
(
__Userspace_os_Windows
)
char
addr_buf
[
INET6_ADDRSTRLEN
]
;
struct
sockaddr_in
*
sin
;
struct
sockaddr_in6
*
sin6
;
#
endif
switch
(
spc
-
>
spc_aaddr
.
ss_family
)
{
case
AF_INET
:
#
if
!
defined
(
__Userspace_os_Windows
)
sin
=
(
struct
sockaddr_in
*
)
&
spc
-
>
spc_aaddr
;
addr
=
inet_ntop
(
AF_INET
&
sin
-
>
sin_addr
addr_buf
INET6_ADDRSTRLEN
)
;
#
endif
break
;
case
AF_INET6
:
#
if
!
defined
(
__Userspace_os_Windows
)
sin6
=
(
struct
sockaddr_in6
*
)
&
spc
-
>
spc_aaddr
;
addr
=
inet_ntop
(
AF_INET6
&
sin6
-
>
sin6_addr
addr_buf
INET6_ADDRSTRLEN
)
;
#
endif
break
;
case
AF_CONN
:
addr
=
"
DTLS
connection
"
;
break
;
default
:
break
;
}
LOG
(
(
"
Peer
address
%
s
is
now
"
addr
)
)
;
switch
(
spc
-
>
spc_state
)
{
case
SCTP_ADDR_AVAILABLE
:
LOG
(
(
"
SCTP_ADDR_AVAILABLE
"
)
)
;
break
;
case
SCTP_ADDR_UNREACHABLE
:
LOG
(
(
"
SCTP_ADDR_UNREACHABLE
"
)
)
;
break
;
case
SCTP_ADDR_REMOVED
:
LOG
(
(
"
SCTP_ADDR_REMOVED
"
)
)
;
break
;
case
SCTP_ADDR_ADDED
:
LOG
(
(
"
SCTP_ADDR_ADDED
"
)
)
;
break
;
case
SCTP_ADDR_MADE_PRIM
:
LOG
(
(
"
SCTP_ADDR_MADE_PRIM
"
)
)
;
break
;
case
SCTP_ADDR_CONFIRMED
:
LOG
(
(
"
SCTP_ADDR_CONFIRMED
"
)
)
;
break
;
default
:
LOG
(
(
"
UNKNOWN
"
)
)
;
break
;
}
LOG
(
(
"
(
error
=
0x
%
08x
)
.
\
n
"
spc
-
>
spc_error
)
)
;
}
void
DataChannelConnection
:
:
HandleRemoteErrorEvent
(
const
struct
sctp_remote_error
*
sre
)
{
size_t
i
n
;
n
=
sre
-
>
sre_length
-
sizeof
(
struct
sctp_remote_error
)
;
LOG
(
(
"
Remote
Error
(
error
=
0x
%
04x
)
:
"
sre
-
>
sre_error
)
)
;
for
(
i
=
0
;
i
<
n
;
+
+
i
)
{
LOG
(
(
"
0x
%
02x
"
sre
-
>
sre_data
[
i
]
)
)
;
}
}
void
DataChannelConnection
:
:
HandleShutdownEvent
(
const
struct
sctp_shutdown_event
*
sse
)
{
LOG
(
(
"
Shutdown
event
.
"
)
)
;
}
void
DataChannelConnection
:
:
HandleAdaptationIndication
(
const
struct
sctp_adaptation_event
*
sai
)
{
LOG
(
(
"
Adaptation
indication
:
%
x
.
"
sai
-
>
sai_adaptation_ind
)
)
;
}
void
DataChannelConnection
:
:
HandlePartialDeliveryEvent
(
const
struct
sctp_pdapi_event
*
spde
)
{
LOG
(
(
"
Partial
delivery
event
:
"
)
)
;
switch
(
spde
-
>
pdapi_indication
)
{
case
SCTP_PARTIAL_DELIVERY_ABORTED
:
LOG
(
(
"
delivery
aborted
"
)
)
;
break
;
default
:
LOG
(
(
"
?
?
?
"
)
)
;
break
;
}
LOG
(
(
"
(
flags
=
%
x
)
stream
=
%
"
PRIu32
"
sn
=
%
"
PRIu32
spde
-
>
pdapi_flags
spde
-
>
pdapi_stream
spde
-
>
pdapi_seq
)
)
;
if
(
spde
-
>
pdapi_stream
>
=
UINT16_MAX
)
{
LOG
(
(
"
Invalid
stream
id
in
partial
delivery
event
:
%
"
PRIu32
"
\
n
"
spde
-
>
pdapi_stream
)
)
;
return
;
}
DataChannel
*
channel
=
FindChannelByStream
(
(
uint16_t
)
spde
-
>
pdapi_stream
)
;
if
(
channel
)
{
LOG
(
(
"
Abort
partially
delivered
message
of
%
u
bytes
\
n
"
channel
-
>
mRecvBuffer
.
Length
(
)
)
)
;
channel
-
>
mRecvBuffer
.
Truncate
(
0
)
;
}
}
void
DataChannelConnection
:
:
HandleSendFailedEvent
(
const
struct
sctp_send_failed_event
*
ssfe
)
{
size_t
i
n
;
if
(
ssfe
-
>
ssfe_flags
&
SCTP_DATA_UNSENT
)
{
LOG
(
(
"
Unsent
"
)
)
;
}
if
(
ssfe
-
>
ssfe_flags
&
SCTP_DATA_SENT
)
{
LOG
(
(
"
Sent
"
)
)
;
}
if
(
ssfe
-
>
ssfe_flags
&
~
(
SCTP_DATA_SENT
|
SCTP_DATA_UNSENT
)
)
{
LOG
(
(
"
(
flags
=
%
x
)
"
ssfe
-
>
ssfe_flags
)
)
;
}
LOG
(
(
"
message
with
PPID
=
%
u
SID
=
%
d
flags
:
0x
%
04x
due
to
error
=
0x
%
08x
"
ntohl
(
ssfe
-
>
ssfe_info
.
snd_ppid
)
ssfe
-
>
ssfe_info
.
snd_sid
ssfe
-
>
ssfe_info
.
snd_flags
ssfe
-
>
ssfe_error
)
)
;
n
=
ssfe
-
>
ssfe_length
-
sizeof
(
struct
sctp_send_failed_event
)
;
for
(
i
=
0
;
i
<
n
;
+
+
i
)
{
LOG
(
(
"
0x
%
02x
"
ssfe
-
>
ssfe_data
[
i
]
)
)
;
}
}
void
DataChannelConnection
:
:
ClearResets
(
)
{
if
(
!
mStreamsResetting
.
IsEmpty
(
)
)
{
LOG
(
(
"
Clearing
resets
for
%
zu
streams
"
mStreamsResetting
.
Length
(
)
)
)
;
}
for
(
uint32_t
i
=
0
;
i
<
mStreamsResetting
.
Length
(
)
;
+
+
i
)
{
RefPtr
<
DataChannel
>
channel
;
channel
=
FindChannelByStream
(
mStreamsResetting
[
i
]
)
;
if
(
channel
)
{
LOG
(
(
"
Forgetting
channel
%
u
(
%
p
)
with
pending
reset
"
channel
-
>
mStream
channel
.
get
(
)
)
)
;
mStreams
[
channel
-
>
mStream
]
=
nullptr
;
}
}
mStreamsResetting
.
Clear
(
)
;
}
void
DataChannelConnection
:
:
ResetOutgoingStream
(
uint16_t
stream
)
{
uint32_t
i
;
mLock
.
AssertCurrentThreadOwns
(
)
;
LOG
(
(
"
Connection
%
p
:
Resetting
outgoing
stream
%
u
"
(
void
*
)
this
stream
)
)
;
for
(
i
=
0
;
i
<
mStreamsResetting
.
Length
(
)
;
+
+
i
)
{
if
(
mStreamsResetting
[
i
]
=
=
stream
)
{
return
;
}
}
mStreamsResetting
.
AppendElement
(
stream
)
;
}
void
DataChannelConnection
:
:
SendOutgoingStreamReset
(
)
{
struct
sctp_reset_streams
*
srs
;
uint32_t
i
;
size_t
len
;
LOG
(
(
"
Connection
%
p
:
Sending
outgoing
stream
reset
for
%
zu
streams
"
(
void
*
)
this
mStreamsResetting
.
Length
(
)
)
)
;
mLock
.
AssertCurrentThreadOwns
(
)
;
if
(
mStreamsResetting
.
IsEmpty
(
)
)
{
LOG
(
(
"
No
streams
to
reset
"
)
)
;
return
;
}
len
=
sizeof
(
sctp_assoc_t
)
+
(
2
+
mStreamsResetting
.
Length
(
)
)
*
sizeof
(
uint16_t
)
;
srs
=
static_cast
<
struct
sctp_reset_streams
*
>
(
moz_xmalloc
(
len
)
)
;
memset
(
srs
0
len
)
;
srs
-
>
srs_flags
=
SCTP_STREAM_RESET_OUTGOING
;
srs
-
>
srs_number_streams
=
mStreamsResetting
.
Length
(
)
;
for
(
i
=
0
;
i
<
mStreamsResetting
.
Length
(
)
;
+
+
i
)
{
srs
-
>
srs_stream_list
[
i
]
=
mStreamsResetting
[
i
]
;
}
if
(
usrsctp_setsockopt
(
mMasterSocket
IPPROTO_SCTP
SCTP_RESET_STREAMS
srs
(
socklen_t
)
len
)
<
0
)
{
LOG
(
(
"
*
*
*
failed
:
setsockopt
RESET
errno
%
d
"
errno
)
)
;
}
else
{
mStreamsResetting
.
Clear
(
)
;
}
free
(
srs
)
;
}
void
DataChannelConnection
:
:
HandleStreamResetEvent
(
const
struct
sctp_stream_reset_event
*
strrst
)
{
uint32_t
n
i
;
RefPtr
<
DataChannel
>
channel
;
if
(
!
(
strrst
-
>
strreset_flags
&
SCTP_STREAM_RESET_DENIED
)
&
&
!
(
strrst
-
>
strreset_flags
&
SCTP_STREAM_RESET_FAILED
)
)
{
n
=
(
strrst
-
>
strreset_length
-
sizeof
(
struct
sctp_stream_reset_event
)
)
/
sizeof
(
uint16_t
)
;
for
(
i
=
0
;
i
<
n
;
+
+
i
)
{
if
(
strrst
-
>
strreset_flags
&
SCTP_STREAM_RESET_INCOMING_SSN
)
{
channel
=
FindChannelByStream
(
strrst
-
>
strreset_stream_list
[
i
]
)
;
if
(
channel
)
{
LOG
(
(
"
Incoming
:
Channel
%
u
closed
state
%
d
"
channel
-
>
mStream
channel
-
>
mState
)
)
;
ASSERT_WEBRTC
(
channel
-
>
mState
=
=
DataChannel
:
:
OPEN
|
|
channel
-
>
mState
=
=
DataChannel
:
:
CLOSING
|
|
channel
-
>
mState
=
=
DataChannel
:
:
CONNECTING
|
|
channel
-
>
mState
=
=
DataChannel
:
:
WAITING_TO_OPEN
)
;
if
(
channel
-
>
mState
=
=
DataChannel
:
:
OPEN
|
|
channel
-
>
mState
=
=
DataChannel
:
:
WAITING_TO_OPEN
)
{
ResetOutgoingStream
(
channel
-
>
mStream
)
;
}
mStreams
[
channel
-
>
mStream
]
=
nullptr
;
LOG
(
(
"
Disconnected
DataChannel
%
p
from
connection
%
p
"
(
void
*
)
channel
.
get
(
)
(
void
*
)
channel
-
>
mConnection
.
get
(
)
)
)
;
channel
-
>
StreamClosedLocked
(
)
;
}
else
{
LOG
(
(
"
Can
'
t
find
incoming
channel
%
d
"
i
)
)
;
}
}
}
}
if
(
!
mStreamsResetting
.
IsEmpty
(
)
)
{
LOG
(
(
"
Sending
%
zu
pending
resets
"
mStreamsResetting
.
Length
(
)
)
)
;
SendOutgoingStreamReset
(
)
;
}
}
void
DataChannelConnection
:
:
HandleStreamChangeEvent
(
const
struct
sctp_stream_change_event
*
strchg
)
{
uint16_t
stream
;
RefPtr
<
DataChannel
>
channel
;
if
(
strchg
-
>
strchange_flags
=
=
SCTP_STREAM_CHANGE_DENIED
)
{
LOG
(
(
"
*
*
*
Failed
increasing
number
of
streams
from
%
zu
(
%
u
/
%
u
)
"
mStreams
.
Length
(
)
strchg
-
>
strchange_instrms
strchg
-
>
strchange_outstrms
)
)
;
return
;
}
if
(
strchg
-
>
strchange_instrms
>
mStreams
.
Length
(
)
)
{
LOG
(
(
"
Other
side
increased
streams
from
%
zu
to
%
u
"
mStreams
.
Length
(
)
strchg
-
>
strchange_instrms
)
)
;
}
if
(
strchg
-
>
strchange_outstrms
>
mStreams
.
Length
(
)
|
|
strchg
-
>
strchange_instrms
>
mStreams
.
Length
(
)
)
{
uint16_t
old_len
=
mStreams
.
Length
(
)
;
uint16_t
new_len
=
std
:
:
max
(
strchg
-
>
strchange_outstrms
strchg
-
>
strchange_instrms
)
;
LOG
(
(
"
Increasing
number
of
streams
from
%
u
to
%
u
-
adding
%
u
(
in
:
%
u
)
"
old_len
new_len
new_len
-
old_len
strchg
-
>
strchange_instrms
)
)
;
mStreams
.
AppendElements
(
new_len
-
old_len
)
;
LOG
(
(
"
New
length
=
%
zu
(
was
%
d
)
"
mStreams
.
Length
(
)
old_len
)
)
;
for
(
size_t
i
=
old_len
;
i
<
mStreams
.
Length
(
)
;
+
+
i
)
{
mStreams
[
i
]
=
nullptr
;
}
size_t
num_needed
=
mPending
.
GetSize
(
)
;
LOG
(
(
"
%
zu
of
%
d
new
streams
already
needed
"
num_needed
new_len
-
old_len
)
)
;
num_needed
-
=
(
new_len
-
old_len
)
;
if
(
num_needed
>
0
)
{
if
(
num_needed
<
16
)
num_needed
=
16
;
LOG
(
(
"
Not
enough
new
streams
asking
for
%
zu
more
"
num_needed
)
)
;
RequestMoreStreams
(
num_needed
)
;
}
else
if
(
strchg
-
>
strchange_outstrms
<
strchg
-
>
strchange_instrms
)
{
LOG
(
(
"
Requesting
%
d
output
streams
to
match
partner
"
strchg
-
>
strchange_instrms
-
strchg
-
>
strchange_outstrms
)
)
;
RequestMoreStreams
(
strchg
-
>
strchange_instrms
-
strchg
-
>
strchange_outstrms
)
;
}
ProcessQueuedOpens
(
)
;
}
for
(
uint32_t
i
=
0
;
i
<
mStreams
.
Length
(
)
;
+
+
i
)
{
channel
=
mStreams
[
i
]
;
if
(
!
channel
)
continue
;
if
(
(
channel
-
>
mState
=
=
CONNECTING
)
&
&
(
channel
-
>
mStream
=
=
INVALID_STREAM
)
)
{
if
(
(
strchg
-
>
strchange_flags
&
SCTP_STREAM_CHANGE_DENIED
)
|
|
(
strchg
-
>
strchange_flags
&
SCTP_STREAM_CHANGE_FAILED
)
)
{
channel
-
>
mState
=
CLOSED
;
Dispatch
(
do_AddRef
(
new
DataChannelOnMessageAvailable
(
DataChannelOnMessageAvailable
:
:
ON_CHANNEL_CLOSED
this
channel
)
)
)
;
}
else
{
stream
=
FindFreeStream
(
)
;
if
(
stream
!
=
INVALID_STREAM
)
{
channel
-
>
mStream
=
stream
;
mStreams
[
stream
]
=
channel
;
int
error
=
SendOpenRequestMessage
(
channel
-
>
mLabel
channel
-
>
mProtocol
channel
-
>
mStream
!
!
(
channel
-
>
mFlags
&
DATA_CHANNEL_FLAGS_OUT_OF_ORDER_ALLOWED
)
channel
-
>
mPrPolicy
channel
-
>
mPrValue
)
;
if
(
error
)
{
LOG
(
(
"
SendOpenRequest
failed
error
=
%
d
"
error
)
)
;
mStreams
[
channel
-
>
mStream
]
=
nullptr
;
channel
-
>
mState
=
CLOSED
;
Dispatch
(
do_AddRef
(
new
DataChannelOnMessageAvailable
(
DataChannelOnMessageAvailable
:
:
ON_CHANNEL_CLOSED
this
channel
)
)
)
;
}
else
{
channel
-
>
mState
=
OPEN
;
channel
-
>
mFlags
|
=
DATA_CHANNEL_FLAGS_READY
;
LOG
(
(
"
%
s
:
sending
ON_CHANNEL_OPEN
for
%
p
"
__FUNCTION__
channel
.
get
(
)
)
)
;
Dispatch
(
do_AddRef
(
new
DataChannelOnMessageAvailable
(
DataChannelOnMessageAvailable
:
:
ON_CHANNEL_OPEN
this
channel
)
)
)
;
}
}
else
{
break
;
}
}
}
}
}
void
DataChannelConnection
:
:
HandleNotification
(
const
union
sctp_notification
*
notif
size_t
n
)
{
mLock
.
AssertCurrentThreadOwns
(
)
;
if
(
notif
-
>
sn_header
.
sn_length
!
=
(
uint32_t
)
n
)
{
return
;
}
switch
(
notif
-
>
sn_header
.
sn_type
)
{
case
SCTP_ASSOC_CHANGE
:
HandleAssociationChangeEvent
(
&
(
notif
-
>
sn_assoc_change
)
)
;
break
;
case
SCTP_PEER_ADDR_CHANGE
:
HandlePeerAddressChangeEvent
(
&
(
notif
-
>
sn_paddr_change
)
)
;
break
;
case
SCTP_REMOTE_ERROR
:
HandleRemoteErrorEvent
(
&
(
notif
-
>
sn_remote_error
)
)
;
break
;
case
SCTP_SHUTDOWN_EVENT
:
HandleShutdownEvent
(
&
(
notif
-
>
sn_shutdown_event
)
)
;
break
;
case
SCTP_ADAPTATION_INDICATION
:
HandleAdaptationIndication
(
&
(
notif
-
>
sn_adaptation_event
)
)
;
break
;
case
SCTP_AUTHENTICATION_EVENT
:
LOG
(
(
"
SCTP_AUTHENTICATION_EVENT
"
)
)
;
break
;
case
SCTP_SENDER_DRY_EVENT
:
break
;
case
SCTP_NOTIFICATIONS_STOPPED_EVENT
:
LOG
(
(
"
SCTP_NOTIFICATIONS_STOPPED_EVENT
"
)
)
;
break
;
case
SCTP_PARTIAL_DELIVERY_EVENT
:
HandlePartialDeliveryEvent
(
&
(
notif
-
>
sn_pdapi_event
)
)
;
break
;
case
SCTP_SEND_FAILED_EVENT
:
HandleSendFailedEvent
(
&
(
notif
-
>
sn_send_failed_event
)
)
;
break
;
case
SCTP_STREAM_RESET_EVENT
:
HandleStreamResetEvent
(
&
(
notif
-
>
sn_strreset_event
)
)
;
break
;
case
SCTP_ASSOC_RESET_EVENT
:
LOG
(
(
"
SCTP_ASSOC_RESET_EVENT
"
)
)
;
break
;
case
SCTP_STREAM_CHANGE_EVENT
:
HandleStreamChangeEvent
(
&
(
notif
-
>
sn_strchange_event
)
)
;
break
;
default
:
LOG
(
(
"
unknown
SCTP
event
:
%
u
"
(
uint32_t
)
notif
-
>
sn_header
.
sn_type
)
)
;
break
;
}
}
int
DataChannelConnection
:
:
ReceiveCallback
(
struct
socket
*
sock
void
*
data
size_t
datalen
struct
sctp_rcvinfo
rcv
int
flags
)
{
ASSERT_WEBRTC
(
!
NS_IsMainThread
(
)
)
;
if
(
!
data
)
{
LOG
(
(
"
ReceiveCallback
:
SCTP
has
finished
shutting
down
"
)
)
;
}
else
{
mLock
.
AssertCurrentThreadOwns
(
)
;
if
(
flags
&
MSG_NOTIFICATION
)
{
HandleNotification
(
static_cast
<
union
sctp_notification
*
>
(
data
)
datalen
)
;
}
else
{
HandleMessage
(
data
datalen
ntohl
(
rcv
.
rcv_ppid
)
rcv
.
rcv_sid
flags
)
;
}
}
free
(
data
)
;
return
1
;
}
already_AddRefed
<
DataChannel
>
DataChannelConnection
:
:
Open
(
const
nsACString
&
label
const
nsACString
&
protocol
Type
type
bool
inOrder
uint32_t
prValue
DataChannelListener
*
aListener
nsISupports
*
aContext
bool
aExternalNegotiated
uint16_t
aStream
)
{
uint16_t
prPolicy
=
SCTP_PR_SCTP_NONE
;
uint32_t
flags
;
LOG
(
(
"
DC
Open
:
label
%
s
/
%
s
type
%
u
inorder
%
d
prValue
%
u
listener
%
p
"
"
context
%
p
external
:
%
s
stream
%
u
"
PromiseFlatCString
(
label
)
.
get
(
)
PromiseFlatCString
(
protocol
)
.
get
(
)
type
inOrder
prValue
aListener
aContext
aExternalNegotiated
?
"
true
"
:
"
false
"
aStream
)
)
;
switch
(
type
)
{
case
DATA_CHANNEL_RELIABLE
:
prPolicy
=
SCTP_PR_SCTP_NONE
;
break
;
case
DATA_CHANNEL_PARTIAL_RELIABLE_REXMIT
:
prPolicy
=
SCTP_PR_SCTP_RTX
;
break
;
case
DATA_CHANNEL_PARTIAL_RELIABLE_TIMED
:
prPolicy
=
SCTP_PR_SCTP_TTL
;
break
;
default
:
LOG
(
(
"
ERROR
:
unsupported
channel
type
:
%
u
"
type
)
)
;
MOZ_ASSERT
(
false
)
;
return
nullptr
;
}
if
(
(
prPolicy
=
=
SCTP_PR_SCTP_NONE
)
&
&
(
prValue
!
=
0
)
)
{
return
nullptr
;
}
if
(
aStream
!
=
INVALID_STREAM
&
&
aStream
<
mStreams
.
Length
(
)
&
&
mStreams
[
aStream
]
)
{
LOG
(
(
"
ERROR
:
external
negotiation
of
already
-
open
channel
%
u
"
aStream
)
)
;
return
nullptr
;
}
flags
=
!
inOrder
?
DATA_CHANNEL_FLAGS_OUT_OF_ORDER_ALLOWED
:
0
;
RefPtr
<
DataChannel
>
channel
(
new
DataChannel
(
this
aStream
DataChannel
:
:
CONNECTING
label
protocol
prPolicy
prValue
flags
aListener
aContext
)
)
;
if
(
aExternalNegotiated
)
{
channel
-
>
mFlags
|
=
DATA_CHANNEL_FLAGS_EXTERNAL_NEGOTIATED
;
}
MutexAutoLock
lock
(
mLock
)
;
return
OpenFinish
(
channel
.
forget
(
)
)
;
}
already_AddRefed
<
DataChannel
>
DataChannelConnection
:
:
OpenFinish
(
already_AddRefed
<
DataChannel
>
&
&
aChannel
)
{
RefPtr
<
DataChannel
>
channel
(
aChannel
)
;
uint16_t
stream
=
channel
-
>
mStream
;
bool
queue
=
false
;
mLock
.
AssertCurrentThreadOwns
(
)
;
if
(
mState
=
=
OPEN
)
{
if
(
stream
=
=
INVALID_STREAM
)
{
stream
=
FindFreeStream
(
)
;
}
if
(
stream
=
=
INVALID_STREAM
|
|
stream
>
=
mStreams
.
Length
(
)
)
{
int32_t
more_needed
=
(
stream
=
=
INVALID_STREAM
)
?
16
:
(
stream
-
(
(
int32_t
)
mStreams
.
Length
(
)
)
)
+
16
;
if
(
!
RequestMoreStreams
(
more_needed
)
)
{
goto
request_error_cleanup
;
}
queue
=
true
;
}
}
else
{
if
(
stream
!
=
INVALID_STREAM
&
&
stream
>
=
mStreams
.
Length
(
)
&
&
mState
=
=
CLOSED
)
{
struct
sctp_initmsg
initmsg
;
socklen_t
len
=
sizeof
(
initmsg
)
;
int32_t
total_needed
=
stream
+
16
;
memset
(
&
initmsg
0
sizeof
(
initmsg
)
)
;
if
(
usrsctp_getsockopt
(
mMasterSocket
IPPROTO_SCTP
SCTP_INITMSG
&
initmsg
&
len
)
<
0
)
{
LOG
(
(
"
*
*
*
failed
getsockopt
SCTP_INITMSG
"
)
)
;
goto
request_error_cleanup
;
}
LOG
(
(
"
Setting
number
of
SCTP
streams
to
%
u
was
%
u
/
%
u
"
total_needed
initmsg
.
sinit_num_ostreams
initmsg
.
sinit_max_instreams
)
)
;
initmsg
.
sinit_num_ostreams
=
total_needed
;
initmsg
.
sinit_max_instreams
=
MAX_NUM_STREAMS
;
if
(
usrsctp_setsockopt
(
mMasterSocket
IPPROTO_SCTP
SCTP_INITMSG
&
initmsg
(
socklen_t
)
sizeof
(
initmsg
)
)
<
0
)
{
LOG
(
(
"
*
*
*
failed
setsockopt
SCTP_INITMSG
errno
%
d
"
errno
)
)
;
goto
request_error_cleanup
;
}
int32_t
old_len
=
mStreams
.
Length
(
)
;
mStreams
.
AppendElements
(
total_needed
-
old_len
)
;
for
(
int32_t
i
=
old_len
;
i
<
total_needed
;
+
+
i
)
{
mStreams
[
i
]
=
nullptr
;
}
}
queue
=
true
;
}
if
(
queue
)
{
LOG
(
(
"
Queuing
channel
%
p
(
%
u
)
to
finish
open
"
channel
.
get
(
)
stream
)
)
;
channel
-
>
mFlags
|
=
DATA_CHANNEL_FLAGS_FINISH_OPEN
;
DataChannel
*
rawChannel
=
channel
;
rawChannel
-
>
AddRef
(
)
;
mPending
.
Push
(
rawChannel
)
;
return
channel
.
forget
(
)
;
}
MOZ_ASSERT
(
stream
!
=
INVALID_STREAM
)
;
mStreams
[
stream
]
=
channel
;
channel
-
>
mStream
=
stream
;
#
ifdef
TEST_QUEUED_DATA
channel
-
>
mState
=
OPEN
;
channel
-
>
mFlags
|
=
DATA_CHANNEL_FLAGS_READY
;
SendDataMsgInternalOrBuffer
(
channel
"
Help
me
!
"
8
DATA_CHANNEL_PPID_DOMSTRING
)
;
#
endif
if
(
channel
-
>
mFlags
&
DATA_CHANNEL_FLAGS_OUT_OF_ORDER_ALLOWED
)
{
channel
-
>
mFlags
|
=
DATA_CHANNEL_FLAGS_WAITING_ACK
;
}
if
(
!
(
channel
-
>
mFlags
&
DATA_CHANNEL_FLAGS_EXTERNAL_NEGOTIATED
)
)
{
int
error
=
SendOpenRequestMessage
(
channel
-
>
mLabel
channel
-
>
mProtocol
stream
!
!
(
channel
-
>
mFlags
&
DATA_CHANNEL_FLAGS_OUT_OF_ORDER_ALLOWED
)
channel
-
>
mPrPolicy
channel
-
>
mPrValue
)
;
if
(
error
)
{
LOG
(
(
"
SendOpenRequest
failed
error
=
%
d
"
error
)
)
;
if
(
channel
-
>
mFlags
&
DATA_CHANNEL_FLAGS_FINISH_OPEN
)
{
NS_ERROR
(
"
Failed
to
send
open
request
"
)
;
Dispatch
(
do_AddRef
(
new
DataChannelOnMessageAvailable
(
DataChannelOnMessageAvailable
:
:
ON_CHANNEL_CLOSED
this
channel
)
)
)
;
}
mStreams
[
stream
]
=
nullptr
;
channel
-
>
mStream
=
INVALID_STREAM
;
channel
-
>
mState
=
CLOSED
;
return
nullptr
;
}
}
channel
-
>
mState
=
OPEN
;
channel
-
>
mFlags
|
=
DATA_CHANNEL_FLAGS_READY
;
LOG
(
(
"
%
s
:
sending
ON_CHANNEL_OPEN
for
%
p
"
__FUNCTION__
channel
.
get
(
)
)
)
;
Dispatch
(
do_AddRef
(
new
DataChannelOnMessageAvailable
(
DataChannelOnMessageAvailable
:
:
ON_CHANNEL_OPEN
this
channel
)
)
)
;
return
channel
.
forget
(
)
;
request_error_cleanup
:
channel
-
>
mState
=
CLOSED
;
if
(
channel
-
>
mFlags
&
DATA_CHANNEL_FLAGS_FINISH_OPEN
)
{
NS_ERROR
(
"
Failed
to
request
more
streams
"
)
;
Dispatch
(
do_AddRef
(
new
DataChannelOnMessageAvailable
(
DataChannelOnMessageAvailable
:
:
ON_CHANNEL_CLOSED
this
channel
)
)
)
;
return
channel
.
forget
(
)
;
}
return
nullptr
;
}
int
DataChannelConnection
:
:
SendMsgInternal
(
OutgoingMsg
&
msg
)
{
auto
&
info
=
msg
.
GetInfo
(
)
.
sendv_sndinfo
;
int
error
;
bool
eor_set
=
info
.
snd_flags
&
SCTP_EOR
?
true
:
false
;
size_t
left
=
msg
.
GetLeft
(
)
;
do
{
size_t
length
;
if
(
left
>
DATA_CHANNEL_MAX_BINARY_FRAGMENT
)
{
length
=
DATA_CHANNEL_MAX_BINARY_FRAGMENT
;
info
.
snd_flags
&
=
~
SCTP_EOR
;
}
else
{
length
=
left
;
if
(
eor_set
)
{
info
.
snd_flags
|
=
SCTP_EOR
;
}
}
ssize_t
written
=
usrsctp_sendv
(
mSocket
msg
.
GetData
(
)
length
nullptr
0
(
void
*
)
&
msg
.
GetInfo
(
)
(
socklen_t
)
sizeof
(
struct
sctp_sendv_spa
)
SCTP_SENDV_SPA
0
)
;
if
(
written
<
0
)
{
error
=
errno
;
goto
out
;
}
LOG
(
(
"
Sent
buffer
(
written
=
%
zu
len
=
%
zu
left
=
%
zu
)
"
(
size_t
)
written
length
left
-
(
size_t
)
written
)
)
;
if
(
written
=
=
0
)
{
LOG
(
(
"
tuexen
:
usrsctp_sendv
returned
0
"
)
)
;
error
=
EAGAIN
;
goto
out
;
}
if
(
(
size_t
)
written
<
length
)
{
msg
.
Advance
(
(
size_t
)
written
)
;
error
=
EAGAIN
;
goto
out
;
}
msg
.
Advance
(
(
size_t
)
written
)
;
left
=
msg
.
GetLeft
(
)
;
}
while
(
left
>
0
)
;
error
=
0
;
out
:
if
(
eor_set
)
{
info
.
snd_flags
|
=
SCTP_EOR
;
}
return
error
;
}
int
DataChannelConnection
:
:
SendMsgInternalOrBuffer
(
nsTArray
<
nsAutoPtr
<
BufferedOutgoingMsg
>
>
&
buffer
OutgoingMsg
&
msg
bool
&
buffered
)
{
NS_WARNING_ASSERTION
(
msg
.
GetLength
(
)
>
0
"
Length
is
0
?
!
"
)
;
int
error
=
0
;
bool
need_buffering
=
false
;
mLock
.
AssertCurrentThreadOwns
(
)
;
if
(
buffer
.
IsEmpty
(
)
&
&
(
mSendInterleaved
|
|
!
mPendingType
)
)
{
error
=
SendMsgInternal
(
msg
)
;
switch
(
error
)
{
case
0
:
break
;
case
EAGAIN
:
#
if
(
EAGAIN
!
=
EWOULDBLOCK
)
case
EWOULDBLOCK
:
#
endif
need_buffering
=
true
;
break
;
default
:
LOG
(
(
"
error
%
d
on
sending
"
error
)
)
;
break
;
}
}
else
{
need_buffering
=
true
;
}
if
(
need_buffering
)
{
auto
*
bufferedMsg
=
new
BufferedOutgoingMsg
(
msg
)
;
buffer
.
AppendElement
(
bufferedMsg
)
;
LOG
(
(
"
Queued
%
zu
buffers
(
left
=
%
zu
total
=
%
zu
)
"
buffer
.
Length
(
)
msg
.
GetLeft
(
)
msg
.
GetLength
(
)
)
)
;
buffered
=
true
;
return
0
;
}
buffered
=
false
;
return
error
;
}
int
DataChannelConnection
:
:
SendDataMsgInternalOrBuffer
(
DataChannel
&
channel
const
uint8_t
*
data
size_t
len
uint32_t
ppid
)
{
if
(
NS_WARN_IF
(
channel
.
mState
!
=
OPEN
&
&
channel
.
mState
!
=
CONNECTING
)
)
{
return
EINVAL
;
}
struct
sctp_sendv_spa
info
=
{
0
}
;
info
.
sendv_flags
=
SCTP_SEND_SNDINFO_VALID
;
info
.
sendv_sndinfo
.
snd_sid
=
channel
.
mStream
;
info
.
sendv_sndinfo
.
snd_flags
=
SCTP_EOR
;
info
.
sendv_sndinfo
.
snd_ppid
=
htonl
(
ppid
)
;
if
(
(
channel
.
mFlags
&
DATA_CHANNEL_FLAGS_OUT_OF_ORDER_ALLOWED
)
&
&
!
(
channel
.
mFlags
&
DATA_CHANNEL_FLAGS_WAITING_ACK
)
)
{
info
.
sendv_sndinfo
.
snd_flags
|
=
SCTP_UNORDERED
;
}
if
(
channel
.
mPrPolicy
!
=
SCTP_PR_SCTP_NONE
)
{
info
.
sendv_prinfo
.
pr_policy
=
channel
.
mPrPolicy
;
info
.
sendv_prinfo
.
pr_value
=
channel
.
mPrValue
;
info
.
sendv_flags
|
=
SCTP_SEND_PRINFO_VALID
;
}
OutgoingMsg
msg
(
info
data
len
)
;
MutexAutoLock
lock
(
mLock
)
;
bool
buffered
;
int
error
=
SendMsgInternalOrBuffer
(
channel
.
mBufferedData
msg
buffered
)
;
if
(
!
error
&
&
buffered
&
&
!
mPendingType
)
{
mPendingType
=
PENDING_DATA
;
mCurrentStream
=
channel
.
mStream
;
}
return
error
;
}
int
DataChannelConnection
:
:
SendDataMsg
(
DataChannel
&
channel
const
uint8_t
*
data
size_t
len
uint32_t
ppidPartial
uint32_t
ppidFinal
)
{
if
(
mPpidFragmentation
)
{
if
(
len
>
DATA_CHANNEL_MAX_BINARY_FRAGMENT
&
&
channel
.
mPrPolicy
=
=
DATA_CHANNEL_RELIABLE
&
&
!
(
channel
.
mFlags
&
DATA_CHANNEL_FLAGS_OUT_OF_ORDER_ALLOWED
)
)
{
LOG
(
(
"
Sending
data
message
(
total
=
%
zu
)
using
deprecated
PPID
-
based
chunks
"
len
)
)
;
size_t
left
=
len
;
while
(
left
>
0
)
{
size_t
chunkLen
=
std
:
:
min
<
size_t
>
(
left
DATA_CHANNEL_MAX_BINARY_FRAGMENT
)
;
left
-
=
chunkLen
;
uint32_t
ppid
=
left
>
0
?
ppidPartial
:
ppidFinal
;
LOG
(
(
"
Send
chunk
(
len
=
%
zu
left
=
%
zu
total
=
%
zu
ppid
%
u
"
chunkLen
left
len
ppid
)
)
;
int
error
=
SendDataMsgInternalOrBuffer
(
channel
data
chunkLen
ppid
)
;
if
(
error
)
{
LOG
(
(
"
*
*
*
send
chunk
fail
%
d
"
error
)
)
;
return
error
;
}
data
+
=
chunkLen
;
}
LOG
(
(
"
Sent
%
zu
chunks
using
deprecated
PPID
-
based
fragmentation
"
(
size_t
)
(
len
+
DATA_CHANNEL_MAX_BINARY_FRAGMENT
-
1
)
/
DATA_CHANNEL_MAX_BINARY_FRAGMENT
)
)
;
return
0
;
}
NS_WARNING_ASSERTION
(
len
<
=
DATA_CHANNEL_MAX_BINARY_FRAGMENT
"
Sending
too
-
large
data
on
unreliable
channel
!
"
)
;
}
else
{
if
(
mMaxMessageSize
!
=
0
&
&
len
>
mMaxMessageSize
)
{
LOG
(
(
"
Message
rejected
too
large
(
%
zu
>
%
"
PRIu64
"
)
"
len
mMaxMessageSize
)
)
;
return
EMSGSIZE
;
}
}
return
SendDataMsgInternalOrBuffer
(
channel
data
len
ppidFinal
)
;
}
class
ReadBlobRunnable
:
public
Runnable
{
public
:
ReadBlobRunnable
(
DataChannelConnection
*
aConnection
uint16_t
aStream
nsIInputStream
*
aBlob
)
:
Runnable
(
"
ReadBlobRunnable
"
)
mConnection
(
aConnection
)
mStream
(
aStream
)
mBlob
(
aBlob
)
{
}
NS_IMETHOD
Run
(
)
override
{
DataChannelConnection
*
self
=
mConnection
;
self
-
>
ReadBlob
(
mConnection
.
forget
(
)
mStream
mBlob
)
;
return
NS_OK
;
}
private
:
RefPtr
<
DataChannelConnection
>
mConnection
;
uint16_t
mStream
;
RefPtr
<
nsIInputStream
>
mBlob
;
}
;
int
DataChannelConnection
:
:
SendBlob
(
uint16_t
stream
nsIInputStream
*
aBlob
)
{
DataChannel
*
channel
=
mStreams
[
stream
]
;
if
(
NS_WARN_IF
(
!
channel
)
)
{
return
EINVAL
;
}
if
(
!
mInternalIOThread
)
{
nsresult
rv
=
NS_NewNamedThread
(
"
DataChannel
IO
"
getter_AddRefs
(
mInternalIOThread
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
EINVAL
;
}
}
mInternalIOThread
-
>
Dispatch
(
do_AddRef
(
new
ReadBlobRunnable
(
this
stream
aBlob
)
)
NS_DISPATCH_NORMAL
)
;
return
0
;
}
class
DataChannelBlobSendRunnable
:
public
Runnable
{
public
:
DataChannelBlobSendRunnable
(
already_AddRefed
<
DataChannelConnection
>
&
aConnection
uint16_t
aStream
)
:
Runnable
(
"
DataChannelBlobSendRunnable
"
)
mConnection
(
aConnection
)
mStream
(
aStream
)
{
}
~
DataChannelBlobSendRunnable
(
)
override
{
if
(
!
NS_IsMainThread
(
)
&
&
mConnection
)
{
MOZ_ASSERT
(
false
)
;
Unused
<
<
mConnection
.
forget
(
)
.
take
(
)
;
}
}
NS_IMETHOD
Run
(
)
override
{
ASSERT_WEBRTC
(
NS_IsMainThread
(
)
)
;
mConnection
-
>
SendBinaryMsg
(
mStream
mData
)
;
mConnection
=
nullptr
;
return
NS_OK
;
}
nsCString
mData
;
private
:
RefPtr
<
DataChannelConnection
>
mConnection
;
uint16_t
mStream
;
}
;
void
DataChannelConnection
:
:
ReadBlob
(
already_AddRefed
<
DataChannelConnection
>
aThis
uint16_t
aStream
nsIInputStream
*
aBlob
)
{
RefPtr
<
DataChannelBlobSendRunnable
>
runnable
=
new
DataChannelBlobSendRunnable
(
aThis
aStream
)
;
if
(
NS_FAILED
(
NS_ReadInputStreamToString
(
aBlob
runnable
-
>
mData
-
1
)
)
)
{
NS_ReleaseOnMainThreadSystemGroup
(
"
DataChannelBlobSendRunnable
"
runnable
.
forget
(
)
)
;
return
;
}
aBlob
-
>
Close
(
)
;
Dispatch
(
runnable
.
forget
(
)
)
;
}
void
DataChannelConnection
:
:
GetStreamIds
(
std
:
:
vector
<
uint16_t
>
*
aStreamList
)
{
ASSERT_WEBRTC
(
NS_IsMainThread
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
mStreams
.
Length
(
)
;
+
+
i
)
{
if
(
mStreams
[
i
]
)
{
aStreamList
-
>
push_back
(
mStreams
[
i
]
-
>
mStream
)
;
}
}
}
int
DataChannelConnection
:
:
SendDataMsgCommon
(
uint16_t
stream
const
nsACString
&
aMsg
bool
isBinary
)
{
ASSERT_WEBRTC
(
NS_IsMainThread
(
)
)
;
const
uint8_t
*
data
=
(
const
uint8_t
*
)
aMsg
.
BeginReading
(
)
;
uint32_t
len
=
aMsg
.
Length
(
)
;
#
if
(
UINT32_MAX
>
SIZE_MAX
)
if
(
len
>
SIZE_MAX
)
{
return
EMSGSIZE
;
}
#
endif
DataChannel
*
channelPtr
;
LOG
(
(
"
Sending
%
sto
stream
%
u
:
%
u
bytes
"
isBinary
?
"
binary
"
:
"
"
stream
len
)
)
;
channelPtr
=
mStreams
[
stream
]
;
if
(
NS_WARN_IF
(
!
channelPtr
)
)
{
return
EINVAL
;
}
auto
&
channel
=
*
channelPtr
;
if
(
isBinary
)
{
return
SendDataMsg
(
channel
data
len
DATA_CHANNEL_PPID_BINARY_PARTIAL
DATA_CHANNEL_PPID_BINARY
)
;
}
return
SendDataMsg
(
channel
data
len
DATA_CHANNEL_PPID_DOMSTRING_PARTIAL
DATA_CHANNEL_PPID_DOMSTRING
)
;
}
void
DataChannelConnection
:
:
Stop
(
)
{
Dispatch
(
do_AddRef
(
new
DataChannelOnMessageAvailable
(
DataChannelOnMessageAvailable
:
:
ON_DISCONNECTED
this
)
)
)
;
}
void
DataChannelConnection
:
:
Close
(
DataChannel
*
aChannel
)
{
MutexAutoLock
lock
(
mLock
)
;
CloseInt
(
aChannel
)
;
}
void
DataChannelConnection
:
:
CloseInt
(
DataChannel
*
aChannel
)
{
MOZ_ASSERT
(
aChannel
)
;
RefPtr
<
DataChannel
>
channel
(
aChannel
)
;
mLock
.
AssertCurrentThreadOwns
(
)
;
LOG
(
(
"
Connection
%
p
/
Channel
%
p
:
Closing
stream
%
u
"
channel
-
>
mConnection
.
get
(
)
channel
.
get
(
)
channel
-
>
mStream
)
)
;
if
(
aChannel
-
>
mState
=
=
CLOSED
|
|
aChannel
-
>
mState
=
=
CLOSING
)
{
LOG
(
(
"
Channel
already
closing
/
closed
(
%
u
)
"
aChannel
-
>
mState
)
)
;
if
(
mState
=
=
CLOSED
&
&
channel
-
>
mStream
!
=
INVALID_STREAM
)
{
mStreams
[
channel
-
>
mStream
]
=
nullptr
;
}
return
;
}
aChannel
-
>
mBufferedData
.
Clear
(
)
;
if
(
channel
-
>
mStream
!
=
INVALID_STREAM
)
{
ResetOutgoingStream
(
channel
-
>
mStream
)
;
if
(
mState
=
=
CLOSED
)
{
mStreams
[
channel
-
>
mStream
]
=
nullptr
;
}
else
{
SendOutgoingStreamReset
(
)
;
}
}
aChannel
-
>
mState
=
CLOSING
;
if
(
mState
=
=
CLOSED
)
{
channel
-
>
StreamClosedLocked
(
)
;
}
}
void
DataChannelConnection
:
:
CloseAll
(
)
{
LOG
(
(
"
Closing
all
channels
(
connection
%
p
)
"
(
void
*
)
this
)
)
;
{
MutexAutoLock
lock
(
mLock
)
;
mState
=
CLOSED
;
}
bool
closed_some
=
false
;
for
(
uint32_t
i
=
0
;
i
<
mStreams
.
Length
(
)
;
+
+
i
)
{
if
(
mStreams
[
i
]
)
{
mStreams
[
i
]
-
>
Close
(
)
;
closed_some
=
true
;
}
}
RefPtr
<
DataChannel
>
channel
;
while
(
nullptr
!
=
(
channel
=
dont_AddRef
(
static_cast
<
DataChannel
*
>
(
mPending
.
PopFront
(
)
)
)
)
)
{
LOG
(
(
"
closing
pending
channel
%
p
stream
%
u
"
channel
.
get
(
)
channel
-
>
mStream
)
)
;
channel
-
>
Close
(
)
;
closed_some
=
true
;
}
if
(
closed_some
)
{
MutexAutoLock
lock
(
mLock
)
;
SendOutgoingStreamReset
(
)
;
}
}
DataChannel
:
:
~
DataChannel
(
)
{
NS_ASSERTION
(
mState
=
=
CLOSED
|
|
mState
=
=
CLOSING
"
unexpected
state
in
~
DataChannel
"
)
;
}
void
DataChannel
:
:
Close
(
)
{
if
(
mConnection
)
{
RefPtr
<
DataChannelConnection
>
connection
(
mConnection
)
;
connection
-
>
Close
(
this
)
;
}
}
void
DataChannel
:
:
StreamClosedLocked
(
)
{
mConnection
-
>
mLock
.
AssertCurrentThreadOwns
(
)
;
ENSURE_DATACONNECTION
;
LOG
(
(
"
Destroying
Data
channel
%
u
"
mStream
)
)
;
MOZ_ASSERT_IF
(
mStream
!
=
INVALID_STREAM
!
mConnection
-
>
FindChannelByStream
(
mStream
)
)
;
mStream
=
INVALID_STREAM
;
mState
=
CLOSED
;
mMainThreadEventTarget
-
>
Dispatch
(
do_AddRef
(
new
DataChannelOnMessageAvailable
(
DataChannelOnMessageAvailable
:
:
ON_CHANNEL_CLOSED
mConnection
this
)
)
)
;
}
void
DataChannel
:
:
ReleaseConnection
(
)
{
ASSERT_WEBRTC
(
NS_IsMainThread
(
)
)
;
mConnection
=
nullptr
;
}
void
DataChannel
:
:
SetListener
(
DataChannelListener
*
aListener
nsISupports
*
aContext
)
{
MutexAutoLock
mLock
(
mListenerLock
)
;
mContext
=
aContext
;
mListener
=
aListener
;
}
void
DataChannel
:
:
SendErrnoToErrorResult
(
int
error
ErrorResult
&
aRv
)
{
switch
(
error
)
{
case
0
:
break
;
case
EMSGSIZE
:
aRv
.
Throw
(
NS_ERROR_DOM_TYPE_ERR
)
;
break
;
default
:
aRv
.
Throw
(
NS_ERROR_DOM_OPERATION_ERR
)
;
break
;
}
}
void
DataChannel
:
:
SendMsg
(
const
nsACString
&
aMsg
ErrorResult
&
aRv
)
{
if
(
!
EnsureValidStream
(
aRv
)
)
{
return
;
}
SendErrnoToErrorResult
(
mConnection
-
>
SendMsg
(
mStream
aMsg
)
aRv
)
;
}
void
DataChannel
:
:
SendBinaryMsg
(
const
nsACString
&
aMsg
ErrorResult
&
aRv
)
{
if
(
!
EnsureValidStream
(
aRv
)
)
{
return
;
}
SendErrnoToErrorResult
(
mConnection
-
>
SendBinaryMsg
(
mStream
aMsg
)
aRv
)
;
}
void
DataChannel
:
:
SendBinaryStream
(
nsIInputStream
*
aBlob
ErrorResult
&
aRv
)
{
if
(
!
EnsureValidStream
(
aRv
)
)
{
return
;
}
SendErrnoToErrorResult
(
mConnection
-
>
SendBlob
(
mStream
aBlob
)
aRv
)
;
}
dom
:
:
Nullable
<
uint16_t
>
DataChannel
:
:
GetMaxPacketLifeTime
(
)
const
{
if
(
mPrPolicy
=
=
SCTP_PR_SCTP_TTL
)
{
return
dom
:
:
Nullable
<
uint16_t
>
(
mPrValue
)
;
}
return
dom
:
:
Nullable
<
uint16_t
>
(
)
;
}
dom
:
:
Nullable
<
uint16_t
>
DataChannel
:
:
GetMaxRetransmits
(
)
const
{
if
(
mPrPolicy
=
=
SCTP_PR_SCTP_RTX
)
{
return
dom
:
:
Nullable
<
uint16_t
>
(
mPrValue
)
;
}
return
dom
:
:
Nullable
<
uint16_t
>
(
)
;
}
void
DataChannel
:
:
AppReady
(
)
{
ENSURE_DATACONNECTION
;
MutexAutoLock
lock
(
mConnection
-
>
mLock
)
;
mFlags
|
=
DATA_CHANNEL_FLAGS_READY
;
if
(
mState
=
=
WAITING_TO_OPEN
)
{
mState
=
OPEN
;
mMainThreadEventTarget
-
>
Dispatch
(
do_AddRef
(
new
DataChannelOnMessageAvailable
(
DataChannelOnMessageAvailable
:
:
ON_CHANNEL_OPEN
mConnection
this
)
)
)
;
for
(
uint32_t
i
=
0
;
i
<
mQueuedMessages
.
Length
(
)
;
+
+
i
)
{
nsCOMPtr
<
nsIRunnable
>
runnable
=
mQueuedMessages
[
i
]
;
MOZ_ASSERT
(
runnable
)
;
mMainThreadEventTarget
-
>
Dispatch
(
runnable
.
forget
(
)
)
;
}
}
else
{
NS_ASSERTION
(
mQueuedMessages
.
IsEmpty
(
)
"
Shouldn
'
t
have
queued
messages
if
not
WAITING_TO_OPEN
"
)
;
}
mQueuedMessages
.
Clear
(
)
;
mQueuedMessages
.
Compact
(
)
;
}
size_t
DataChannel
:
:
GetBufferedAmountLocked
(
)
const
{
size_t
buffered
=
0
;
for
(
auto
&
msg
:
mBufferedData
)
{
buffered
+
=
msg
-
>
GetLeft
(
)
;
}
return
buffered
;
}
uint32_t
DataChannel
:
:
GetBufferedAmountLowThreshold
(
)
{
return
mBufferedThreshold
;
}
void
DataChannel
:
:
SetBufferedAmountLowThreshold
(
uint32_t
aThreshold
)
{
mBufferedThreshold
=
aThreshold
;
}
void
DataChannel
:
:
SendOrQueue
(
DataChannelOnMessageAvailable
*
aMessage
)
{
if
(
!
(
mFlags
&
DATA_CHANNEL_FLAGS_READY
)
&
&
(
mState
=
=
CONNECTING
|
|
mState
=
=
WAITING_TO_OPEN
)
)
{
mQueuedMessages
.
AppendElement
(
aMessage
)
;
}
else
{
nsCOMPtr
<
nsIRunnable
>
runnable
=
aMessage
;
mMainThreadEventTarget
-
>
Dispatch
(
runnable
.
forget
(
)
)
;
}
}
bool
DataChannel
:
:
EnsureValidStream
(
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
mConnection
)
;
if
(
mConnection
&
&
mStream
!
=
INVALID_STREAM
)
{
return
true
;
}
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
false
;
}
}
