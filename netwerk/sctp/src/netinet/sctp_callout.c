#
if
defined
(
__Userspace__
)
#
include
<
sys
/
types
.
h
>
#
if
!
defined
(
_WIN32
)
#
include
<
sys
/
wait
.
h
>
#
include
<
unistd
.
h
>
#
include
<
pthread
.
h
>
#
endif
#
if
defined
(
__native_client__
)
#
include
<
sys
/
select
.
h
>
#
endif
#
include
<
stdlib
.
h
>
#
include
<
string
.
h
>
#
include
<
stdio
.
h
>
#
include
<
errno
.
h
>
#
include
<
user_atomic
.
h
>
#
include
<
netinet
/
sctp_sysctl
.
h
>
#
include
<
netinet
/
sctp_pcb
.
h
>
#
else
#
include
<
netinet
/
sctp_os
.
h
>
#
include
<
netinet
/
sctp_callout
.
h
>
#
include
<
netinet
/
sctp_pcb
.
h
>
#
endif
#
include
<
netinet
/
sctputil
.
h
>
#
if
defined
(
__APPLE__
)
|
|
defined
(
__Userspace__
)
static
uint32_t
ticks
=
0
;
#
else
extern
int
ticks
;
#
endif
uint32_t
sctp_get_tick_count
(
void
)
{
uint32_t
ret
;
SCTP_TIMERQ_LOCK
(
)
;
ret
=
ticks
;
SCTP_TIMERQ_UNLOCK
(
)
;
return
ret
;
}
static
sctp_os_timer_t
*
sctp_os_timer_next
=
NULL
;
void
sctp_os_timer_init
(
sctp_os_timer_t
*
c
)
{
memset
(
c
0
sizeof
(
*
c
)
)
;
}
int
sctp_os_timer_start
(
sctp_os_timer_t
*
c
uint32_t
to_ticks
void
(
*
ftn
)
(
void
*
)
void
*
arg
)
{
int
ret
=
0
;
if
(
(
c
=
=
NULL
)
|
|
(
ftn
=
=
NULL
)
)
return
(
ret
)
;
SCTP_TIMERQ_LOCK
(
)
;
if
(
c
-
>
c_flags
&
SCTP_CALLOUT_PENDING
)
{
ret
=
1
;
if
(
c
=
=
sctp_os_timer_next
)
{
sctp_os_timer_next
=
TAILQ_NEXT
(
c
tqe
)
;
}
TAILQ_REMOVE
(
&
SCTP_BASE_INFO
(
callqueue
)
c
tqe
)
;
}
if
(
to_ticks
=
=
0
)
to_ticks
=
1
;
c
-
>
c_arg
=
arg
;
c
-
>
c_flags
=
(
SCTP_CALLOUT_ACTIVE
|
SCTP_CALLOUT_PENDING
)
;
c
-
>
c_func
=
ftn
;
c
-
>
c_time
=
ticks
+
to_ticks
;
TAILQ_INSERT_TAIL
(
&
SCTP_BASE_INFO
(
callqueue
)
c
tqe
)
;
SCTP_TIMERQ_UNLOCK
(
)
;
return
(
ret
)
;
}
int
sctp_os_timer_stop
(
sctp_os_timer_t
*
c
)
{
SCTP_TIMERQ_LOCK
(
)
;
if
(
(
c
-
>
c_flags
&
SCTP_CALLOUT_PENDING
)
=
=
0
)
{
c
-
>
c_flags
&
=
~
SCTP_CALLOUT_ACTIVE
;
SCTP_TIMERQ_UNLOCK
(
)
;
return
(
0
)
;
}
c
-
>
c_flags
&
=
~
(
SCTP_CALLOUT_ACTIVE
|
SCTP_CALLOUT_PENDING
)
;
if
(
c
=
=
sctp_os_timer_next
)
{
sctp_os_timer_next
=
TAILQ_NEXT
(
c
tqe
)
;
}
TAILQ_REMOVE
(
&
SCTP_BASE_INFO
(
callqueue
)
c
tqe
)
;
SCTP_TIMERQ_UNLOCK
(
)
;
return
(
1
)
;
}
void
sctp_handle_tick
(
uint32_t
elapsed_ticks
)
{
sctp_os_timer_t
*
c
;
void
(
*
c_func
)
(
void
*
)
;
void
*
c_arg
;
SCTP_TIMERQ_LOCK
(
)
;
ticks
+
=
elapsed_ticks
;
c
=
TAILQ_FIRST
(
&
SCTP_BASE_INFO
(
callqueue
)
)
;
while
(
c
)
{
if
(
SCTP_UINT32_GE
(
ticks
c
-
>
c_time
)
)
{
sctp_os_timer_next
=
TAILQ_NEXT
(
c
tqe
)
;
TAILQ_REMOVE
(
&
SCTP_BASE_INFO
(
callqueue
)
c
tqe
)
;
c_func
=
c
-
>
c_func
;
c_arg
=
c
-
>
c_arg
;
c
-
>
c_flags
&
=
~
SCTP_CALLOUT_PENDING
;
SCTP_TIMERQ_UNLOCK
(
)
;
c_func
(
c_arg
)
;
SCTP_TIMERQ_LOCK
(
)
;
c
=
sctp_os_timer_next
;
}
else
{
c
=
TAILQ_NEXT
(
c
tqe
)
;
}
}
sctp_os_timer_next
=
NULL
;
SCTP_TIMERQ_UNLOCK
(
)
;
}
#
if
defined
(
__APPLE__
)
&
&
!
defined
(
__Userspace__
)
void
sctp_timeout
(
void
*
arg
SCTP_UNUSED
)
{
sctp_handle_tick
(
SCTP_BASE_VAR
(
sctp_main_timer_ticks
)
)
;
sctp_start_main_timer
(
)
;
}
#
endif
#
if
defined
(
__Userspace__
)
#
define
TIMEOUT_INTERVAL
10
void
*
user_sctp_timer_iterate
(
void
*
arg
)
{
sctp_userspace_set_threadname
(
"
SCTP
timer
"
)
;
for
(
;
;
)
{
#
if
defined
(
_WIN32
)
Sleep
(
TIMEOUT_INTERVAL
)
;
#
else
struct
timespec
amount
remaining
;
remaining
.
tv_sec
=
0
;
remaining
.
tv_nsec
=
TIMEOUT_INTERVAL
*
1000
*
1000
;
do
{
amount
=
remaining
;
}
while
(
nanosleep
(
&
amount
&
remaining
)
=
=
-
1
)
;
#
endif
if
(
atomic_cmpset_int
(
&
SCTP_BASE_VAR
(
timer_thread_should_exit
)
1
1
)
)
{
break
;
}
sctp_handle_tick
(
sctp_msecs_to_ticks
(
TIMEOUT_INTERVAL
)
)
;
}
return
(
NULL
)
;
}
void
sctp_start_timer_thread
(
void
)
{
int
rc
;
rc
=
sctp_userspace_thread_create
(
&
SCTP_BASE_VAR
(
timer_thread
)
user_sctp_timer_iterate
)
;
if
(
rc
)
{
SCTP_PRINTF
(
"
ERROR
;
return
code
from
sctp_thread_create
(
)
is
%
d
\
n
"
rc
)
;
}
else
{
SCTP_BASE_VAR
(
timer_thread_started
)
=
1
;
}
}
void
sctp_stop_timer_thread
(
void
)
{
atomic_cmpset_int
(
&
SCTP_BASE_VAR
(
timer_thread_should_exit
)
0
1
)
;
if
(
SCTP_BASE_VAR
(
timer_thread_started
)
)
{
#
if
defined
(
_WIN32
)
WaitForSingleObject
(
SCTP_BASE_VAR
(
timer_thread
)
INFINITE
)
;
CloseHandle
(
SCTP_BASE_VAR
(
timer_thread
)
)
;
#
else
pthread_join
(
SCTP_BASE_VAR
(
timer_thread
)
NULL
)
;
#
endif
}
}
#
endif
