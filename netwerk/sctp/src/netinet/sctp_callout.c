#
if
defined
(
__Userspace__
)
#
include
<
sys
/
types
.
h
>
#
if
!
defined
(
__Userspace_os_Windows
)
#
include
<
sys
/
wait
.
h
>
#
include
<
unistd
.
h
>
#
include
<
pthread
.
h
>
#
endif
#
if
defined
(
__Userspace_os_NaCl
)
#
include
<
sys
/
select
.
h
>
#
endif
#
include
<
stdlib
.
h
>
#
include
<
string
.
h
>
#
include
<
stdio
.
h
>
#
include
<
errno
.
h
>
#
include
<
netinet
/
sctp_sysctl
.
h
>
#
include
<
netinet
/
sctp_pcb
.
h
>
#
else
#
include
<
netinet
/
sctp_os
.
h
>
#
include
<
netinet
/
sctp_callout
.
h
>
#
include
<
netinet
/
sctp_pcb
.
h
>
#
endif
#
if
defined
(
__APPLE__
)
|
|
defined
(
__Userspace__
)
static
int
ticks
=
0
;
#
else
extern
int
ticks
;
#
endif
int
sctp_get_tick_count
(
void
)
{
int
ret
;
SCTP_TIMERQ_LOCK
(
)
;
ret
=
ticks
;
SCTP_TIMERQ_UNLOCK
(
)
;
return
ret
;
}
static
sctp_os_timer_t
*
sctp_os_timer_next
=
NULL
;
static
sctp_os_timer_t
*
sctp_os_timer_current
=
NULL
;
static
int
sctp_os_timer_waiting
=
0
;
static
int
sctp_os_timer_wait_ctr
=
0
;
static
userland_thread_id_t
sctp_os_timer_current_tid
;
userland_mutex_t
sctp_os_timerwait_mtx
;
static
userland_cond_t
sctp_os_timer_wait_cond
;
static
int
sctp_os_timer_done_ctr
=
0
;
void
sctp_os_timer_init
(
sctp_os_timer_t
*
c
)
{
memset
(
c
0
sizeof
(
*
c
)
)
;
}
void
sctp_os_timer_start
(
sctp_os_timer_t
*
c
int
to_ticks
void
(
*
ftn
)
(
void
*
)
void
*
arg
)
{
if
(
(
c
=
=
NULL
)
|
|
(
ftn
=
=
NULL
)
)
return
;
SCTP_TIMERQ_LOCK
(
)
;
if
(
c
=
=
sctp_os_timer_current
)
{
if
(
sctp_os_timer_waiting
)
{
SCTP_TIMERQ_UNLOCK
(
)
;
return
;
}
}
if
(
c
-
>
c_flags
&
SCTP_CALLOUT_PENDING
)
{
if
(
c
=
=
sctp_os_timer_next
)
{
sctp_os_timer_next
=
TAILQ_NEXT
(
c
tqe
)
;
}
TAILQ_REMOVE
(
&
SCTP_BASE_INFO
(
callqueue
)
c
tqe
)
;
}
if
(
to_ticks
<
=
0
)
to_ticks
=
1
;
c
-
>
c_arg
=
arg
;
c
-
>
c_flags
=
(
SCTP_CALLOUT_ACTIVE
|
SCTP_CALLOUT_PENDING
)
;
c
-
>
c_func
=
ftn
;
c
-
>
c_time
=
ticks
+
to_ticks
;
TAILQ_INSERT_TAIL
(
&
SCTP_BASE_INFO
(
callqueue
)
c
tqe
)
;
SCTP_TIMERQ_UNLOCK
(
)
;
}
int
sctp_os_timer_stop
(
sctp_os_timer_t
*
c
)
{
int
wakeup_cookie
;
SCTP_TIMERQ_LOCK
(
)
;
if
(
!
(
c
-
>
c_flags
&
SCTP_CALLOUT_PENDING
)
)
{
c
-
>
c_flags
&
=
~
SCTP_CALLOUT_ACTIVE
;
if
(
sctp_os_timer_current
!
=
c
)
{
SCTP_TIMERQ_UNLOCK
(
)
;
return
(
0
)
;
}
else
{
userland_thread_id_t
tid
;
sctp_userspace_thread_id
(
&
tid
)
;
if
(
sctp_userspace_thread_equal
(
tid
sctp_os_timer_current_tid
)
)
{
SCTP_TIMERQ_UNLOCK
(
)
;
return
(
0
)
;
}
sctp_os_timer_waiting
=
1
;
wakeup_cookie
=
+
+
sctp_os_timer_wait_ctr
;
SCTP_TIMERQ_UNLOCK
(
)
;
SCTP_TIMERWAIT_LOCK
(
)
;
if
(
wakeup_cookie
-
sctp_os_timer_done_ctr
>
0
)
{
#
if
defined
(
__Userspace_os_Windows
)
SleepConditionVariableCS
(
&
sctp_os_timer_wait_cond
&
sctp_os_timerwait_mtx
INFINITE
)
;
#
else
pthread_cond_wait
(
&
sctp_os_timer_wait_cond
&
sctp_os_timerwait_mtx
)
;
#
endif
}
SCTP_TIMERWAIT_UNLOCK
(
)
;
}
return
(
0
)
;
}
c
-
>
c_flags
&
=
~
(
SCTP_CALLOUT_ACTIVE
|
SCTP_CALLOUT_PENDING
)
;
if
(
c
=
=
sctp_os_timer_next
)
{
sctp_os_timer_next
=
TAILQ_NEXT
(
c
tqe
)
;
}
TAILQ_REMOVE
(
&
SCTP_BASE_INFO
(
callqueue
)
c
tqe
)
;
SCTP_TIMERQ_UNLOCK
(
)
;
return
(
1
)
;
}
static
void
sctp_handle_tick
(
int
delta
)
{
sctp_os_timer_t
*
c
;
void
(
*
c_func
)
(
void
*
)
;
void
*
c_arg
;
int
wakeup_cookie
;
SCTP_TIMERQ_LOCK
(
)
;
ticks
+
=
delta
;
c
=
TAILQ_FIRST
(
&
SCTP_BASE_INFO
(
callqueue
)
)
;
while
(
c
)
{
if
(
c
-
>
c_time
<
=
ticks
)
{
sctp_os_timer_next
=
TAILQ_NEXT
(
c
tqe
)
;
TAILQ_REMOVE
(
&
SCTP_BASE_INFO
(
callqueue
)
c
tqe
)
;
c_func
=
c
-
>
c_func
;
c_arg
=
c
-
>
c_arg
;
c
-
>
c_flags
&
=
~
SCTP_CALLOUT_PENDING
;
sctp_os_timer_current
=
c
;
sctp_userspace_thread_id
(
&
sctp_os_timer_current_tid
)
;
SCTP_TIMERQ_UNLOCK
(
)
;
c_func
(
c_arg
)
;
SCTP_TIMERQ_LOCK
(
)
;
sctp_os_timer_current
=
NULL
;
if
(
sctp_os_timer_waiting
)
{
wakeup_cookie
=
sctp_os_timer_wait_ctr
;
SCTP_TIMERQ_UNLOCK
(
)
;
SCTP_TIMERWAIT_LOCK
(
)
;
#
if
defined
(
__Userspace_os_Windows
)
WakeAllConditionVariable
(
&
sctp_os_timer_wait_cond
)
;
#
else
pthread_cond_broadcast
(
&
sctp_os_timer_wait_cond
)
;
#
endif
sctp_os_timer_done_ctr
=
wakeup_cookie
;
SCTP_TIMERWAIT_UNLOCK
(
)
;
SCTP_TIMERQ_LOCK
(
)
;
sctp_os_timer_waiting
=
0
;
}
c
=
sctp_os_timer_next
;
}
else
{
c
=
TAILQ_NEXT
(
c
tqe
)
;
}
}
sctp_os_timer_next
=
NULL
;
SCTP_TIMERQ_UNLOCK
(
)
;
}
#
if
defined
(
__APPLE__
)
void
sctp_timeout
(
void
*
arg
SCTP_UNUSED
)
{
sctp_handle_tick
(
SCTP_BASE_VAR
(
sctp_main_timer_ticks
)
)
;
sctp_start_main_timer
(
)
;
}
#
endif
#
if
defined
(
__Userspace__
)
#
define
TIMEOUT_INTERVAL
10
void
*
user_sctp_timer_iterate
(
void
*
arg
)
{
sctp_userspace_set_threadname
(
"
SCTP
timer
"
)
;
for
(
;
;
)
{
#
if
defined
(
__Userspace_os_Windows
)
Sleep
(
TIMEOUT_INTERVAL
)
;
#
else
struct
timeval
timeout
;
timeout
.
tv_sec
=
0
;
timeout
.
tv_usec
=
1000
*
TIMEOUT_INTERVAL
;
select
(
0
NULL
NULL
NULL
&
timeout
)
;
#
endif
if
(
SCTP_BASE_VAR
(
timer_thread_should_exit
)
)
{
break
;
}
sctp_handle_tick
(
MSEC_TO_TICKS
(
TIMEOUT_INTERVAL
)
)
;
}
return
(
NULL
)
;
}
void
sctp_start_timer
(
void
)
{
int
rc
;
#
if
defined
(
__Userspace_os_Windows
)
InitializeConditionVariable
(
&
sctp_os_timer_wait_cond
)
;
#
else
rc
=
pthread_cond_init
(
&
sctp_os_timer_wait_cond
NULL
)
;
if
(
rc
)
SCTP_PRINTF
(
"
ERROR
;
return
code
from
pthread_cond_init
is
%
d
\
n
"
rc
)
;
#
endif
rc
=
sctp_userspace_thread_create
(
&
SCTP_BASE_VAR
(
timer_thread
)
user_sctp_timer_iterate
)
;
if
(
rc
)
{
SCTP_PRINTF
(
"
ERROR
;
return
code
from
sctp_thread_create
(
)
is
%
d
\
n
"
rc
)
;
}
}
#
endif
