#
ifdef
_WIN32
#
include
<
netinet
/
sctp_pcb
.
h
>
#
include
<
sys
/
timeb
.
h
>
#
include
<
iphlpapi
.
h
>
#
if
!
defined
(
__MINGW32__
)
#
pragma
comment
(
lib
"
iphlpapi
.
lib
"
)
#
endif
#
endif
#
include
<
netinet
/
sctp_os_userspace
.
h
>
#
if
defined
(
__FreeBSD__
)
#
include
<
pthread_np
.
h
>
#
endif
#
if
defined
(
__linux__
)
#
include
<
sys
/
prctl
.
h
>
#
endif
#
if
defined
(
_WIN32
)
#
if
defined
(
__MINGW32__
)
#
pragma
GCC
diagnostic
push
#
pragma
GCC
diagnostic
ignored
"
-
Wpedantic
"
#
endif
static
DWORD
WINAPI
sctp_create_thread_adapter
(
void
*
arg
)
{
start_routine_t
start_routine
=
(
start_routine_t
)
arg
;
return
start_routine
(
NULL
)
=
=
NULL
;
}
int
sctp_userspace_thread_create
(
userland_thread_t
*
thread
start_routine_t
start_routine
)
{
*
thread
=
CreateThread
(
NULL
0
sctp_create_thread_adapter
(
void
*
)
start_routine
0
NULL
)
;
if
(
*
thread
=
=
NULL
)
return
GetLastError
(
)
;
return
0
;
}
#
if
defined
(
__MINGW32__
)
#
pragma
GCC
diagnostic
pop
#
endif
#
else
int
sctp_userspace_thread_create
(
userland_thread_t
*
thread
start_routine_t
start_routine
)
{
return
pthread_create
(
thread
NULL
start_routine
NULL
)
;
}
#
endif
void
sctp_userspace_set_threadname
(
const
char
*
name
)
{
#
if
defined
(
__APPLE__
)
pthread_setname_np
(
name
)
;
#
endif
#
if
defined
(
__linux__
)
prctl
(
PR_SET_NAME
name
)
;
#
endif
#
if
defined
(
__FreeBSD__
)
pthread_set_name_np
(
pthread_self
(
)
name
)
;
#
endif
}
#
if
!
defined
(
_WIN32
)
&
&
!
defined
(
__native_client__
)
int
sctp_userspace_get_mtu_from_ifn
(
uint32_t
if_index
)
{
#
if
defined
(
INET
)
|
|
defined
(
INET6
)
struct
ifreq
ifr
;
int
fd
;
#
endif
int
mtu
;
if
(
if_index
=
=
0xffffffff
)
{
mtu
=
1280
;
}
else
{
mtu
=
0
;
#
if
defined
(
INET
)
|
|
defined
(
INET6
)
memset
(
&
ifr
0
sizeof
(
struct
ifreq
)
)
;
if
(
if_indextoname
(
if_index
ifr
.
ifr_name
)
!
=
NULL
)
{
#
if
defined
(
INET
)
if
(
(
fd
=
socket
(
AF_INET
SOCK_DGRAM
0
)
)
>
=
0
)
{
#
else
if
(
(
fd
=
socket
(
AF_INET6
SOCK_DGRAM
0
)
)
>
=
0
)
{
#
endif
if
(
ioctl
(
fd
SIOCGIFMTU
&
ifr
)
>
=
0
)
{
mtu
=
ifr
.
ifr_mtu
;
}
close
(
fd
)
;
}
}
#
endif
}
return
(
mtu
)
;
}
#
endif
#
if
defined
(
__native_client__
)
int
sctp_userspace_get_mtu_from_ifn
(
uint32_t
if_index
)
{
return
1280
;
}
#
endif
#
if
defined
(
__APPLE__
)
|
|
defined
(
__DragonFly__
)
|
|
defined
(
__linux__
)
|
|
defined
(
__native_client__
)
|
|
defined
(
__NetBSD__
)
|
|
defined
(
__QNX__
)
|
|
defined
(
_WIN32
)
|
|
defined
(
__Fuchsia__
)
|
|
defined
(
__EMSCRIPTEN__
)
int
timingsafe_bcmp
(
const
void
*
b1
const
void
*
b2
size_t
n
)
{
const
unsigned
char
*
p1
=
b1
*
p2
=
b2
;
int
ret
=
0
;
for
(
;
n
>
0
;
n
-
-
)
ret
|
=
*
p1
+
+
^
*
p2
+
+
;
return
(
ret
!
=
0
)
;
}
#
endif
#
ifdef
_WIN32
int
sctp_userspace_get_mtu_from_ifn
(
uint32_t
if_index
)
{
#
if
defined
(
INET
)
|
|
defined
(
INET6
)
PIP_ADAPTER_ADDRESSES
pAdapterAddrs
pAdapt
;
DWORD
AdapterAddrsSize
Err
;
#
endif
int
mtu
;
if
(
if_index
=
=
0xffffffff
)
{
mtu
=
1280
;
}
else
{
mtu
=
0
;
#
if
defined
(
INET
)
|
|
defined
(
INET6
)
AdapterAddrsSize
=
0
;
pAdapterAddrs
=
NULL
;
if
(
(
Err
=
GetAdaptersAddresses
(
AF_UNSPEC
0
NULL
NULL
&
AdapterAddrsSize
)
)
!
=
0
)
{
if
(
(
Err
!
=
ERROR_BUFFER_OVERFLOW
)
&
&
(
Err
!
=
ERROR_INSUFFICIENT_BUFFER
)
)
{
SCTPDBG
(
SCTP_DEBUG_USR
"
GetAdaptersAddresses
(
)
sizing
failed
with
error
code
%
d
AdapterAddrsSize
=
%
d
\
n
"
Err
AdapterAddrsSize
)
;
mtu
=
-
1
;
goto
cleanup
;
}
}
if
(
(
pAdapterAddrs
=
(
PIP_ADAPTER_ADDRESSES
)
GlobalAlloc
(
GPTR
AdapterAddrsSize
)
)
=
=
NULL
)
{
SCTPDBG
(
SCTP_DEBUG_USR
"
Memory
allocation
error
!
\
n
"
)
;
mtu
=
-
1
;
goto
cleanup
;
}
if
(
(
Err
=
GetAdaptersAddresses
(
AF_UNSPEC
0
NULL
pAdapterAddrs
&
AdapterAddrsSize
)
)
!
=
ERROR_SUCCESS
)
{
SCTPDBG
(
SCTP_DEBUG_USR
"
GetAdaptersAddresses
(
)
failed
with
error
code
%
d
\
n
"
Err
)
;
mtu
=
-
1
;
goto
cleanup
;
}
for
(
pAdapt
=
pAdapterAddrs
;
pAdapt
;
pAdapt
=
pAdapt
-
>
Next
)
{
if
(
pAdapt
-
>
IfIndex
=
=
if_index
)
{
mtu
=
pAdapt
-
>
Mtu
;
break
;
}
}
cleanup
:
if
(
pAdapterAddrs
!
=
NULL
)
{
GlobalFree
(
pAdapterAddrs
)
;
}
#
endif
}
return
(
mtu
)
;
}
void
getwintimeofday
(
struct
timeval
*
tv
)
{
FILETIME
filetime
;
ULARGE_INTEGER
ularge
;
GetSystemTimeAsFileTime
(
&
filetime
)
;
ularge
.
LowPart
=
filetime
.
dwLowDateTime
;
ularge
.
HighPart
=
filetime
.
dwHighDateTime
;
#
if
defined
(
__MINGW32__
)
ularge
.
QuadPart
-
=
116444736000000000ULL
;
#
else
ularge
.
QuadPart
-
=
116444736000000000UI64
;
#
endif
#
if
defined
(
__MINGW32__
)
tv
-
>
tv_sec
=
(
long
)
(
ularge
.
QuadPart
/
10000000ULL
)
;
tv
-
>
tv_usec
=
(
long
)
(
(
ularge
.
QuadPart
%
10000000ULL
)
/
10ULL
)
;
#
else
tv
-
>
tv_sec
=
(
long
)
(
ularge
.
QuadPart
/
10000000UI64
)
;
tv
-
>
tv_usec
=
(
long
)
(
(
ularge
.
QuadPart
%
10000000UI64
)
/
10UI64
)
;
#
endif
}
int
win_if_nametoindex
(
const
char
*
ifname
)
{
IP_ADAPTER_ADDRESSES
*
addresses
*
addr
;
ULONG
status
size
;
int
index
=
0
;
if
(
!
ifname
)
{
return
0
;
}
size
=
0
;
status
=
GetAdaptersAddresses
(
AF_UNSPEC
0
NULL
NULL
&
size
)
;
if
(
status
!
=
ERROR_BUFFER_OVERFLOW
)
{
return
0
;
}
addresses
=
malloc
(
size
)
;
status
=
GetAdaptersAddresses
(
AF_UNSPEC
0
NULL
addresses
&
size
)
;
if
(
status
=
=
ERROR_SUCCESS
)
{
for
(
addr
=
addresses
;
addr
;
addr
=
addr
-
>
Next
)
{
if
(
addr
-
>
AdapterName
&
&
!
strcmp
(
ifname
addr
-
>
AdapterName
)
)
{
index
=
addr
-
>
IfIndex
;
break
;
}
}
}
free
(
addresses
)
;
return
index
;
}
#
if
WINVER
<
0x0600
void
InitializeXPConditionVariable
(
userland_cond_t
*
cv
)
{
cv
-
>
waiters_count
=
0
;
InitializeCriticalSection
(
&
(
cv
-
>
waiters_count_lock
)
)
;
cv
-
>
events_
[
C_SIGNAL
]
=
CreateEvent
(
NULL
FALSE
FALSE
NULL
)
;
cv
-
>
events_
[
C_BROADCAST
]
=
CreateEvent
(
NULL
TRUE
FALSE
NULL
)
;
}
void
DeleteXPConditionVariable
(
userland_cond_t
*
cv
)
{
CloseHandle
(
cv
-
>
events_
[
C_BROADCAST
]
)
;
CloseHandle
(
cv
-
>
events_
[
C_SIGNAL
]
)
;
DeleteCriticalSection
(
&
(
cv
-
>
waiters_count_lock
)
)
;
}
int
SleepXPConditionVariable
(
userland_cond_t
*
cv
userland_mutex_t
*
mtx
)
{
int
result
last_waiter
;
EnterCriticalSection
(
&
cv
-
>
waiters_count_lock
)
;
cv
-
>
waiters_count
+
+
;
LeaveCriticalSection
(
&
cv
-
>
waiters_count_lock
)
;
LeaveCriticalSection
(
mtx
)
;
result
=
WaitForMultipleObjects
(
2
cv
-
>
events_
FALSE
INFINITE
)
;
if
(
result
=
=
-
1
)
{
result
=
GetLastError
(
)
;
}
EnterCriticalSection
(
&
cv
-
>
waiters_count_lock
)
;
cv
-
>
waiters_count
-
-
;
last_waiter
=
result
=
=
(
C_SIGNAL
+
C_BROADCAST
&
&
(
cv
-
>
waiters_count
=
=
0
)
)
;
LeaveCriticalSection
(
&
cv
-
>
waiters_count_lock
)
;
if
(
last_waiter
)
ResetEvent
(
cv
-
>
events_
[
C_BROADCAST
]
)
;
EnterCriticalSection
(
mtx
)
;
return
result
;
}
void
WakeAllXPConditionVariable
(
userland_cond_t
*
cv
)
{
int
have_waiters
;
EnterCriticalSection
(
&
cv
-
>
waiters_count_lock
)
;
have_waiters
=
cv
-
>
waiters_count
>
0
;
LeaveCriticalSection
(
&
cv
-
>
waiters_count_lock
)
;
if
(
have_waiters
)
SetEvent
(
cv
-
>
events_
[
C_BROADCAST
]
)
;
}
#
endif
#
endif
