#
include
"
mozilla
/
AntiTrackingUtils
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
ContentBlockingAllowList
.
h
"
#
include
"
mozilla
/
dom
/
BrowsingContext
.
h
"
#
include
"
mozilla
/
net
/
CookieJarSettings
.
h
"
#
include
"
mozilla
/
net
/
NeckoChannelParams
.
h
"
#
include
"
mozilla
/
Permission
.
h
"
#
include
"
mozilla
/
PermissionManager
.
h
"
#
include
"
mozilla
/
SchedulerGroup
.
h
"
#
include
"
mozilla
/
StaticPrefs_network
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsGlobalWindowInner
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
if
defined
(
MOZ_THUNDERBIRD
)
|
|
defined
(
MOZ_SUITE
)
#
include
"
nsIProtocolHandler
.
h
"
#
endif
#
include
"
nsICookieManager
.
h
"
#
include
"
nsICookieService
.
h
"
#
include
"
nsNetUtil
.
h
"
namespace
mozilla
{
namespace
net
{
static
StaticRefPtr
<
CookieJarSettings
>
sBlockinAll
;
namespace
{
class
PermissionComparator
{
public
:
static
bool
Equals
(
nsIPermission
*
aA
nsIPermission
*
aB
)
{
nsCOMPtr
<
nsIPrincipal
>
principalA
;
nsresult
rv
=
aA
-
>
GetPrincipal
(
getter_AddRefs
(
principalA
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
false
;
}
nsCOMPtr
<
nsIPrincipal
>
principalB
;
rv
=
aB
-
>
GetPrincipal
(
getter_AddRefs
(
principalB
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
false
;
}
bool
equals
=
false
;
rv
=
principalA
-
>
Equals
(
principalB
&
equals
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
false
;
}
return
equals
;
}
}
;
class
ReleaseCookiePermissions
final
:
public
Runnable
{
public
:
explicit
ReleaseCookiePermissions
(
nsTArray
<
RefPtr
<
nsIPermission
>
>
&
&
aArray
)
:
Runnable
(
"
ReleaseCookiePermissions
"
)
mArray
(
std
:
:
move
(
aArray
)
)
{
}
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mArray
.
Clear
(
)
;
return
NS_OK
;
}
private
:
nsTArray
<
RefPtr
<
nsIPermission
>
>
mArray
;
}
;
}
already_AddRefed
<
nsICookieJarSettings
>
CookieJarSettings
:
:
GetBlockingAll
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
sBlockinAll
)
{
return
do_AddRef
(
sBlockinAll
)
;
}
sBlockinAll
=
new
CookieJarSettings
(
nsICookieService
:
:
BEHAVIOR_REJECT
OriginAttributes
:
:
IsFirstPartyEnabled
(
)
eFixed
)
;
ClearOnShutdown
(
&
sBlockinAll
)
;
return
do_AddRef
(
sBlockinAll
)
;
}
already_AddRefed
<
nsICookieJarSettings
>
CookieJarSettings
:
:
Create
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
RefPtr
<
CookieJarSettings
>
cookieJarSettings
=
new
CookieJarSettings
(
nsICookieManager
:
:
GetCookieBehavior
(
)
OriginAttributes
:
:
IsFirstPartyEnabled
(
)
eProgressive
)
;
return
cookieJarSettings
.
forget
(
)
;
}
already_AddRefed
<
nsICookieJarSettings
>
CookieJarSettings
:
:
Create
(
uint32_t
aCookieBehavior
const
nsAString
&
aPartitionKey
bool
aIsFirstPartyIsolated
bool
aIsOnContentBlockingAllowList
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
RefPtr
<
CookieJarSettings
>
cookieJarSettings
=
new
CookieJarSettings
(
aCookieBehavior
aIsFirstPartyIsolated
eProgressive
)
;
cookieJarSettings
-
>
mPartitionKey
=
aPartitionKey
;
cookieJarSettings
-
>
mIsOnContentBlockingAllowList
=
aIsOnContentBlockingAllowList
;
return
cookieJarSettings
.
forget
(
)
;
}
CookieJarSettings
:
:
CookieJarSettings
(
uint32_t
aCookieBehavior
bool
aIsFirstPartyIsolated
State
aState
)
:
mCookieBehavior
(
aCookieBehavior
)
mIsFirstPartyIsolated
(
aIsFirstPartyIsolated
)
mIsOnContentBlockingAllowList
(
false
)
mState
(
aState
)
mToBeMerged
(
false
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT_IF
(
mIsFirstPartyIsolated
mCookieBehavior
!
=
nsICookieService
:
:
BEHAVIOR_REJECT_TRACKER_AND_PARTITION_FOREIGN
)
;
}
CookieJarSettings
:
:
~
CookieJarSettings
(
)
{
if
(
!
NS_IsMainThread
(
)
&
&
!
mCookiePermissions
.
IsEmpty
(
)
)
{
RefPtr
<
Runnable
>
r
=
new
ReleaseCookiePermissions
(
std
:
:
move
(
mCookiePermissions
)
)
;
MOZ_ASSERT
(
mCookiePermissions
.
IsEmpty
(
)
)
;
SchedulerGroup
:
:
Dispatch
(
TaskCategory
:
:
Other
r
.
forget
(
)
)
;
}
}
NS_IMETHODIMP
CookieJarSettings
:
:
GetCookieBehavior
(
uint32_t
*
aCookieBehavior
)
{
*
aCookieBehavior
=
mCookieBehavior
;
return
NS_OK
;
}
NS_IMETHODIMP
CookieJarSettings
:
:
GetIsFirstPartyIsolated
(
bool
*
aIsFirstPartyIsolated
)
{
*
aIsFirstPartyIsolated
=
mIsFirstPartyIsolated
;
return
NS_OK
;
}
NS_IMETHODIMP
CookieJarSettings
:
:
GetRejectThirdPartyContexts
(
bool
*
aRejectThirdPartyContexts
)
{
*
aRejectThirdPartyContexts
=
CookieJarSettings
:
:
IsRejectThirdPartyContexts
(
mCookieBehavior
)
;
return
NS_OK
;
}
NS_IMETHODIMP
CookieJarSettings
:
:
GetLimitForeignContexts
(
bool
*
aLimitForeignContexts
)
{
*
aLimitForeignContexts
=
mCookieBehavior
=
=
nsICookieService
:
:
BEHAVIOR_LIMIT_FOREIGN
|
|
(
StaticPrefs
:
:
privacy_dynamic_firstparty_limitForeign
(
)
&
&
mCookieBehavior
=
=
nsICookieService
:
:
BEHAVIOR_REJECT_TRACKER_AND_PARTITION_FOREIGN
)
;
return
NS_OK
;
}
NS_IMETHODIMP
CookieJarSettings
:
:
GetPartitionForeign
(
bool
*
aPartitionForeign
)
{
*
aPartitionForeign
=
mCookieBehavior
=
=
nsICookieService
:
:
BEHAVIOR_REJECT_TRACKER_AND_PARTITION_FOREIGN
;
return
NS_OK
;
}
NS_IMETHODIMP
CookieJarSettings
:
:
SetPartitionForeign
(
bool
aPartitionForeign
)
{
if
(
mIsFirstPartyIsolated
)
{
return
NS_OK
;
}
if
(
aPartitionForeign
)
{
mCookieBehavior
=
nsICookieService
:
:
BEHAVIOR_REJECT_TRACKER_AND_PARTITION_FOREIGN
;
}
return
NS_OK
;
}
NS_IMETHODIMP
CookieJarSettings
:
:
GetIsOnContentBlockingAllowList
(
bool
*
aIsOnContentBlockingAllowList
)
{
*
aIsOnContentBlockingAllowList
=
mIsOnContentBlockingAllowList
;
return
NS_OK
;
}
NS_IMETHODIMP
CookieJarSettings
:
:
GetPartitionKey
(
nsAString
&
aPartitionKey
)
{
aPartitionKey
=
mPartitionKey
;
return
NS_OK
;
}
NS_IMETHODIMP
CookieJarSettings
:
:
CookiePermission
(
nsIPrincipal
*
aPrincipal
uint32_t
*
aCookiePermission
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
NS_ENSURE_ARG_POINTER
(
aPrincipal
)
;
NS_ENSURE_ARG_POINTER
(
aCookiePermission
)
;
*
aCookiePermission
=
nsIPermissionManager
:
:
UNKNOWN_ACTION
;
nsresult
rv
;
if
(
!
mCookiePermissions
.
IsEmpty
(
)
)
{
nsCOMPtr
<
nsIPrincipal
>
principal
=
Permission
:
:
ClonePrincipalForPermission
(
aPrincipal
)
;
if
(
NS_WARN_IF
(
!
principal
)
)
{
return
NS_ERROR_FAILURE
;
}
for
(
const
RefPtr
<
nsIPermission
>
&
permission
:
mCookiePermissions
)
{
bool
match
=
false
;
rv
=
permission
-
>
MatchesPrincipalForPermission
(
principal
false
&
match
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
|
|
!
match
)
{
continue
;
}
rv
=
permission
-
>
GetCapability
(
aCookiePermission
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
}
PermissionManager
*
pm
=
PermissionManager
:
:
GetInstance
(
)
;
if
(
NS_WARN_IF
(
!
pm
)
)
{
return
NS_ERROR_FAILURE
;
}
#
if
defined
(
MOZ_THUNDERBIRD
)
|
|
defined
(
MOZ_SUITE
)
bool
hasFlags
;
nsCOMPtr
<
nsIURI
>
uri
;
BasePrincipal
:
:
Cast
(
aPrincipal
)
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
rv
=
NS_URIChainHasFlags
(
uri
nsIProtocolHandler
:
:
URI_FORBIDS_COOKIE_ACCESS
&
hasFlags
)
;
if
(
NS_FAILED
(
rv
)
|
|
hasFlags
)
{
*
aCookiePermission
=
PermissionManager
:
:
DENY_ACTION
;
rv
=
NS_OK
;
}
else
#
endif
rv
=
pm
-
>
TestPermissionFromPrincipal
(
aPrincipal
"
cookie
"
_ns
aCookiePermission
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCOMPtr
<
nsIPermission
>
permission
=
Permission
:
:
Create
(
aPrincipal
"
cookie
"
_ns
*
aCookiePermission
0
0
0
)
;
if
(
permission
)
{
mCookiePermissions
.
AppendElement
(
permission
)
;
}
mToBeMerged
=
true
;
return
NS_OK
;
}
void
CookieJarSettings
:
:
Serialize
(
CookieJarSettingsArgs
&
aData
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
aData
.
isFixed
(
)
=
mState
=
=
eFixed
;
aData
.
cookieBehavior
(
)
=
mCookieBehavior
;
aData
.
isFirstPartyIsolated
(
)
=
mIsFirstPartyIsolated
;
aData
.
isOnContentBlockingAllowList
(
)
=
mIsOnContentBlockingAllowList
;
aData
.
partitionKey
(
)
=
mPartitionKey
;
for
(
const
RefPtr
<
nsIPermission
>
&
permission
:
mCookiePermissions
)
{
nsCOMPtr
<
nsIPrincipal
>
principal
;
nsresult
rv
=
permission
-
>
GetPrincipal
(
getter_AddRefs
(
principal
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
continue
;
}
ipc
:
:
PrincipalInfo
principalInfo
;
rv
=
PrincipalToPrincipalInfo
(
principal
&
principalInfo
true
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
continue
;
}
uint32_t
cookiePermission
=
0
;
rv
=
permission
-
>
GetCapability
(
&
cookiePermission
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
continue
;
}
aData
.
cookiePermissions
(
)
.
AppendElement
(
CookiePermissionData
(
principalInfo
cookiePermission
)
)
;
}
mToBeMerged
=
false
;
}
void
CookieJarSettings
:
:
Deserialize
(
const
CookieJarSettingsArgs
&
aData
nsICookieJarSettings
*
*
aCookieJarSettings
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
CookiePermissionList
list
;
for
(
const
CookiePermissionData
&
data
:
aData
.
cookiePermissions
(
)
)
{
auto
principalOrErr
=
PrincipalInfoToPrincipal
(
data
.
principalInfo
(
)
)
;
if
(
NS_WARN_IF
(
principalOrErr
.
isErr
(
)
)
)
{
continue
;
}
nsCOMPtr
<
nsIPrincipal
>
principal
=
principalOrErr
.
unwrap
(
)
;
nsCOMPtr
<
nsIPermission
>
permission
=
Permission
:
:
Create
(
principal
"
cookie
"
_ns
data
.
cookiePermission
(
)
0
0
0
)
;
if
(
NS_WARN_IF
(
!
permission
)
)
{
continue
;
}
list
.
AppendElement
(
permission
)
;
}
RefPtr
<
CookieJarSettings
>
cookieJarSettings
=
new
CookieJarSettings
(
aData
.
cookieBehavior
(
)
aData
.
isFirstPartyIsolated
(
)
aData
.
isFixed
(
)
?
eFixed
:
eProgressive
)
;
cookieJarSettings
-
>
mIsOnContentBlockingAllowList
=
aData
.
isOnContentBlockingAllowList
(
)
;
cookieJarSettings
-
>
mCookiePermissions
=
std
:
:
move
(
list
)
;
cookieJarSettings
-
>
mPartitionKey
=
aData
.
partitionKey
(
)
;
cookieJarSettings
.
forget
(
aCookieJarSettings
)
;
}
void
CookieJarSettings
:
:
Merge
(
const
CookieJarSettingsArgs
&
aData
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mCookieBehavior
=
=
aData
.
cookieBehavior
(
)
|
|
(
mCookieBehavior
=
=
nsICookieService
:
:
BEHAVIOR_REJECT_TRACKER
&
&
aData
.
cookieBehavior
(
)
=
=
nsICookieService
:
:
BEHAVIOR_REJECT_TRACKER_AND_PARTITION_FOREIGN
)
|
|
(
mCookieBehavior
=
=
nsICookieService
:
:
BEHAVIOR_REJECT_TRACKER_AND_PARTITION_FOREIGN
&
&
aData
.
cookieBehavior
(
)
=
=
nsICookieService
:
:
BEHAVIOR_REJECT_TRACKER
)
)
;
if
(
mState
=
=
eFixed
)
{
return
;
}
if
(
mCookieBehavior
=
=
nsICookieService
:
:
BEHAVIOR_REJECT_TRACKER
&
&
aData
.
cookieBehavior
(
)
=
=
nsICookieService
:
:
BEHAVIOR_REJECT_TRACKER_AND_PARTITION_FOREIGN
)
{
if
(
!
mIsFirstPartyIsolated
)
{
mCookieBehavior
=
nsICookieService
:
:
BEHAVIOR_REJECT_TRACKER_AND_PARTITION_FOREIGN
;
}
}
if
(
mCookieBehavior
=
=
nsICookieService
:
:
BEHAVIOR_REJECT_TRACKER_AND_PARTITION_FOREIGN
&
&
aData
.
cookieBehavior
(
)
=
=
nsICookieService
:
:
BEHAVIOR_REJECT_TRACKER
)
{
if
(
aData
.
isFirstPartyIsolated
(
)
)
{
mCookieBehavior
=
nsICookieService
:
:
BEHAVIOR_REJECT_TRACKER
;
mIsFirstPartyIsolated
=
true
;
}
}
MOZ_ASSERT_IF
(
mIsFirstPartyIsolated
mCookieBehavior
!
=
nsICookieService
:
:
BEHAVIOR_REJECT_TRACKER_AND_PARTITION_FOREIGN
)
;
PermissionComparator
comparator
;
for
(
const
CookiePermissionData
&
data
:
aData
.
cookiePermissions
(
)
)
{
auto
principalOrErr
=
PrincipalInfoToPrincipal
(
data
.
principalInfo
(
)
)
;
if
(
NS_WARN_IF
(
principalOrErr
.
isErr
(
)
)
)
{
continue
;
}
nsCOMPtr
<
nsIPrincipal
>
principal
=
principalOrErr
.
unwrap
(
)
;
nsCOMPtr
<
nsIPermission
>
permission
=
Permission
:
:
Create
(
principal
"
cookie
"
_ns
data
.
cookiePermission
(
)
0
0
0
)
;
if
(
NS_WARN_IF
(
!
permission
)
)
{
continue
;
}
if
(
!
mCookiePermissions
.
Contains
(
permission
comparator
)
)
{
mCookiePermissions
.
AppendElement
(
permission
)
;
}
}
}
void
CookieJarSettings
:
:
SetPartitionKey
(
nsIURI
*
aURI
)
{
MOZ_ASSERT
(
aURI
)
;
OriginAttributes
attrs
;
attrs
.
SetPartitionKey
(
aURI
)
;
mPartitionKey
=
std
:
:
move
(
attrs
.
mPartitionKey
)
;
}
void
CookieJarSettings
:
:
UpdateIsOnContentBlockingAllowList
(
nsIChannel
*
aChannel
)
{
MOZ_DIAGNOSTIC_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
aChannel
)
;
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
aChannel
-
>
LoadInfo
(
)
;
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
aChannel
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
nsCOMPtr
<
nsIPrincipal
>
contentBlockingAllowListPrincipal
;
OriginAttributes
attrs
;
loadInfo
-
>
GetOriginAttributes
(
&
attrs
)
;
ContentBlockingAllowList
:
:
RecomputePrincipal
(
uri
attrs
getter_AddRefs
(
contentBlockingAllowListPrincipal
)
)
;
if
(
!
contentBlockingAllowListPrincipal
|
|
!
contentBlockingAllowListPrincipal
-
>
GetIsContentPrincipal
(
)
)
{
return
;
}
Unused
<
<
ContentBlockingAllowList
:
:
Check
(
contentBlockingAllowListPrincipal
NS_UsePrivateBrowsing
(
aChannel
)
mIsOnContentBlockingAllowList
)
;
}
bool
CookieJarSettings
:
:
IsRejectThirdPartyContexts
(
uint32_t
aCookieBehavior
)
{
return
aCookieBehavior
=
=
nsICookieService
:
:
BEHAVIOR_REJECT_TRACKER
|
|
aCookieBehavior
=
=
nsICookieService
:
:
BEHAVIOR_REJECT_TRACKER_AND_PARTITION_FOREIGN
|
|
IsRejectThirdPartyWithExceptions
(
aCookieBehavior
)
;
}
bool
CookieJarSettings
:
:
IsRejectThirdPartyWithExceptions
(
uint32_t
aCookieBehavior
)
{
return
aCookieBehavior
=
=
nsICookieService
:
:
BEHAVIOR_REJECT_FOREIGN
&
&
StaticPrefs
:
:
network_cookie_rejectForeignWithExceptions_enabled
(
)
;
}
NS_IMPL_ISUPPORTS
(
CookieJarSettings
nsICookieJarSettings
)
}
}
