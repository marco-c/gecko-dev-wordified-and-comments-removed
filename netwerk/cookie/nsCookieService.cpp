#
include
"
CookieLogging
.
h
"
#
include
"
CookieCommons
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
ContentBlockingNotifier
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
Printf
.
h
"
#
include
"
mozilla
/
StorageAccess
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
net
/
CookieJarSettings
.
h
"
#
include
"
mozilla
/
net
/
CookiePermission
.
h
"
#
include
"
mozilla
/
net
/
CookieServiceChild
.
h
"
#
include
"
mozilla
/
net
/
HttpBaseChannel
.
h
"
#
include
"
mozilla
/
net
/
NeckoCommon
.
h
"
#
include
"
nsCookieService
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIClassifiedChannel
.
h
"
#
include
"
nsIWebProgressListener
.
h
"
#
include
"
nsIHttpChannel
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsIURL
.
h
"
#
include
"
nsIChannel
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIEffectiveTLDService
.
h
"
#
include
"
nsIIDNService
.
h
"
#
include
"
mozIStorageBindingParamsArray
.
h
"
#
include
"
mozIStorageError
.
h
"
#
include
"
mozIStorageFunction
.
h
"
#
include
"
mozIStorageService
.
h
"
#
include
"
mozIThirdPartyUtil
.
h
"
#
include
"
prprf
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsCOMArray
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsQueryObject
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsAppDirectoryServiceDefs
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
mozilla
/
dom
/
nsMixedContentBlocker
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
storage
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
mozilla
/
FileUtils
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
StaticPrefs_network
.
h
"
#
include
"
mozilla
/
StaticPrefs_privacy
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
TextUtils
.
h
"
#
include
"
nsIConsoleService
.
h
"
#
include
"
nsVariant
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
net
;
static
StaticRefPtr
<
nsCookieService
>
gCookieService
;
#
define
COOKIES_FILE
"
cookies
.
sqlite
"
#
define
COOKIES_SCHEMA_VERSION
11
#
define
IDX_NAME
0
#
define
IDX_VALUE
1
#
define
IDX_HOST
2
#
define
IDX_PATH
3
#
define
IDX_EXPIRY
4
#
define
IDX_LAST_ACCESSED
5
#
define
IDX_CREATION_TIME
6
#
define
IDX_SECURE
7
#
define
IDX_HTTPONLY
8
#
define
IDX_ORIGIN_ATTRIBUTES
9
#
define
IDX_SAME_SITE
10
#
define
IDX_RAW_SAME_SITE
11
#
define
OLD_COOKIE_FILE_NAME
"
cookies
.
txt
"
#
define
CONSOLE_SAMESITE_CATEGORY
NS_LITERAL_CSTRING
(
"
cookieSameSite
"
)
#
define
CONSOLE_GENERIC_CATEGORY
NS_LITERAL_CSTRING
(
"
cookies
"
)
#
define
SAMESITE_MDN_URL
\
NS_LITERAL_STRING
(
"
https
:
/
/
developer
.
mozilla
.
org
/
docs
/
Web
/
HTTP
/
Cookies
"
)
static
void
bindCookieParameters
(
mozIStorageBindingParamsArray
*
aParamsArray
const
CookieKey
&
aKey
const
Cookie
*
aCookie
)
;
#
ifdef
DEBUG
#
define
NS_ASSERT_SUCCESS
(
res
)
\
PR_BEGIN_MACRO
\
nsresult
__rv
=
res
;
/
*
Do
not
evaluate
|
res
|
more
than
once
!
*
/
\
if
(
NS_FAILED
(
__rv
)
)
{
\
SmprintfPointer
msg
=
mozilla
:
:
Smprintf
(
\
"
NS_ASSERT_SUCCESS
(
%
s
)
failed
with
result
0x
%
"
PRIX32
#
res
\
static_cast
<
uint32_t
>
(
__rv
)
)
;
\
NS_ASSERTION
(
NS_SUCCEEDED
(
__rv
)
msg
.
get
(
)
)
;
\
}
\
PR_END_MACRO
#
else
#
define
NS_ASSERT_SUCCESS
(
res
)
PR_BEGIN_MACRO
/
*
nothing
*
/
PR_END_MACRO
#
endif
class
DBListenerErrorHandler
:
public
mozIStorageStatementCallback
{
protected
:
explicit
DBListenerErrorHandler
(
CookieDefaultStorage
*
dbState
)
:
mStorage
(
dbState
)
{
}
RefPtr
<
CookieDefaultStorage
>
mStorage
;
virtual
const
char
*
GetOpType
(
)
=
0
;
public
:
NS_IMETHOD
HandleError
(
mozIStorageError
*
aError
)
override
{
if
(
MOZ_LOG_TEST
(
gCookieLog
LogLevel
:
:
Warning
)
)
{
int32_t
result
=
-
1
;
aError
-
>
GetResult
(
&
result
)
;
nsAutoCString
message
;
aError
-
>
GetMessage
(
message
)
;
COOKIE_LOGSTRING
(
LogLevel
:
:
Warning
(
"
DBListenerErrorHandler
:
:
HandleError
(
)
:
Error
%
d
occurred
while
"
"
performing
operation
'
%
s
'
with
message
'
%
s
'
;
rebuilding
database
.
"
result
GetOpType
(
)
message
.
get
(
)
)
)
;
}
mStorage
-
>
HandleCorruptDB
(
)
;
return
NS_OK
;
}
}
;
class
InsertCookieDBListener
final
:
public
DBListenerErrorHandler
{
private
:
const
char
*
GetOpType
(
)
override
{
return
"
INSERT
"
;
}
~
InsertCookieDBListener
(
)
=
default
;
public
:
NS_DECL_ISUPPORTS
explicit
InsertCookieDBListener
(
CookieDefaultStorage
*
dbState
)
:
DBListenerErrorHandler
(
dbState
)
{
}
NS_IMETHOD
HandleResult
(
mozIStorageResultSet
*
)
override
{
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
call
to
"
"
InsertCookieDBListener
:
:
HandleResult
"
)
;
return
NS_OK
;
}
NS_IMETHOD
HandleCompletion
(
uint16_t
aReason
)
override
{
if
(
mStorage
-
>
corruptFlag
=
=
CookieDefaultStorage
:
:
REBUILDING
&
&
aReason
=
=
mozIStorageStatementCallback
:
:
REASON_FINISHED
)
{
COOKIE_LOGSTRING
(
LogLevel
:
:
Debug
(
"
InsertCookieDBListener
:
:
HandleCompletion
(
)
:
rebuild
complete
"
)
)
;
mStorage
-
>
corruptFlag
=
CookieDefaultStorage
:
:
OK
;
}
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
os
)
{
os
-
>
NotifyObservers
(
nullptr
"
cookie
-
saved
-
on
-
disk
"
nullptr
)
;
}
return
NS_OK
;
}
}
;
NS_IMPL_ISUPPORTS
(
InsertCookieDBListener
mozIStorageStatementCallback
)
class
UpdateCookieDBListener
final
:
public
DBListenerErrorHandler
{
private
:
const
char
*
GetOpType
(
)
override
{
return
"
UPDATE
"
;
}
~
UpdateCookieDBListener
(
)
=
default
;
public
:
NS_DECL_ISUPPORTS
explicit
UpdateCookieDBListener
(
CookieDefaultStorage
*
dbState
)
:
DBListenerErrorHandler
(
dbState
)
{
}
NS_IMETHOD
HandleResult
(
mozIStorageResultSet
*
)
override
{
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
call
to
"
"
UpdateCookieDBListener
:
:
HandleResult
"
)
;
return
NS_OK
;
}
NS_IMETHOD
HandleCompletion
(
uint16_t
aReason
)
override
{
return
NS_OK
;
}
}
;
NS_IMPL_ISUPPORTS
(
UpdateCookieDBListener
mozIStorageStatementCallback
)
class
RemoveCookieDBListener
final
:
public
DBListenerErrorHandler
{
private
:
const
char
*
GetOpType
(
)
override
{
return
"
REMOVE
"
;
}
~
RemoveCookieDBListener
(
)
=
default
;
public
:
NS_DECL_ISUPPORTS
explicit
RemoveCookieDBListener
(
CookieDefaultStorage
*
dbState
)
:
DBListenerErrorHandler
(
dbState
)
{
}
NS_IMETHOD
HandleResult
(
mozIStorageResultSet
*
)
override
{
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
call
to
"
"
RemoveCookieDBListener
:
:
HandleResult
"
)
;
return
NS_OK
;
}
NS_IMETHOD
HandleCompletion
(
uint16_t
aReason
)
override
{
return
NS_OK
;
}
}
;
NS_IMPL_ISUPPORTS
(
RemoveCookieDBListener
mozIStorageStatementCallback
)
class
CloseCookieDBListener
final
:
public
mozIStorageCompletionCallback
{
~
CloseCookieDBListener
(
)
=
default
;
public
:
explicit
CloseCookieDBListener
(
CookieDefaultStorage
*
dbState
)
:
mStorage
(
dbState
)
{
}
RefPtr
<
CookieDefaultStorage
>
mStorage
;
NS_DECL_ISUPPORTS
NS_IMETHOD
Complete
(
nsresult
nsISupports
*
)
override
{
gCookieService
-
>
HandleDBClosed
(
mStorage
)
;
return
NS_OK
;
}
}
;
NS_IMPL_ISUPPORTS
(
CloseCookieDBListener
mozIStorageCompletionCallback
)
namespace
{
bool
ProcessSameSiteCookieForForeignRequest
(
nsIChannel
*
aChannel
Cookie
*
aCookie
bool
aIsSafeTopLevelNav
bool
aLaxByDefault
)
{
int32_t
sameSiteAttr
=
0
;
aCookie
-
>
GetSameSite
(
&
sameSiteAttr
)
;
if
(
sameSiteAttr
=
=
nsICookie
:
:
SAMESITE_STRICT
)
{
return
false
;
}
int64_t
currentTimeInUsec
=
PR_Now
(
)
;
if
(
StaticPrefs
:
:
network_cookie_sameSite_laxPlusPOST_timeout
(
)
>
0
&
&
aLaxByDefault
&
&
sameSiteAttr
=
=
nsICookie
:
:
SAMESITE_LAX
&
&
aCookie
-
>
RawSameSite
(
)
=
=
nsICookie
:
:
SAMESITE_NONE
&
&
currentTimeInUsec
-
aCookie
-
>
CreationTime
(
)
<
=
(
StaticPrefs
:
:
network_cookie_sameSite_laxPlusPOST_timeout
(
)
*
PR_USEC_PER_SEC
)
&
&
!
NS_IsSafeMethodNav
(
aChannel
)
)
{
return
true
;
}
return
sameSiteAttr
!
=
nsICookie
:
:
SAMESITE_LAX
|
|
aIsSafeTopLevelNav
;
}
}
already_AddRefed
<
nsICookieService
>
nsCookieService
:
:
GetXPCOMSingleton
(
)
{
if
(
IsNeckoChild
(
)
)
return
CookieServiceChild
:
:
GetSingleton
(
)
;
return
GetSingleton
(
)
;
}
already_AddRefed
<
nsCookieService
>
nsCookieService
:
:
GetSingleton
(
)
{
NS_ASSERTION
(
!
IsNeckoChild
(
)
"
not
a
parent
process
"
)
;
if
(
gCookieService
)
{
return
do_AddRef
(
gCookieService
)
;
}
gCookieService
=
new
nsCookieService
(
)
;
if
(
gCookieService
)
{
if
(
NS_SUCCEEDED
(
gCookieService
-
>
Init
(
)
)
)
{
ClearOnShutdown
(
&
gCookieService
)
;
}
else
{
gCookieService
=
nullptr
;
}
}
return
do_AddRef
(
gCookieService
)
;
}
NS_IMPL_ISUPPORTS
(
nsCookieService
nsICookieService
nsICookieManager
nsIObserver
nsISupportsWeakReference
nsIMemoryReporter
)
nsCookieService
:
:
nsCookieService
(
)
:
mThread
(
nullptr
)
mMonitor
(
"
CookieThread
"
)
mInitializedCookieStorages
(
false
)
mInitializedDBConn
(
false
)
{
}
nsresult
nsCookieService
:
:
Init
(
)
{
nsresult
rv
;
mTLDService
=
do_GetService
(
NS_EFFECTIVETLDSERVICE_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mIDNService
=
do_GetService
(
NS_IDNSERVICE_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mThirdPartyUtil
=
do_GetService
(
THIRDPARTYUTIL_CONTRACTID
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mStorageService
=
do_GetService
(
"
mozilla
.
org
/
storage
/
service
;
1
"
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
InitCookieStorages
(
)
;
RegisterWeakMemoryReporter
(
this
)
;
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
NS_ENSURE_STATE
(
os
)
;
os
-
>
AddObserver
(
this
"
profile
-
before
-
change
"
true
)
;
os
-
>
AddObserver
(
this
"
profile
-
do
-
change
"
true
)
;
os
-
>
AddObserver
(
this
"
last
-
pb
-
context
-
exited
"
true
)
;
mPermissionService
=
CookiePermission
:
:
GetOrCreate
(
)
;
return
NS_OK
;
}
void
nsCookieService
:
:
InitCookieStorages
(
)
{
NS_ASSERTION
(
!
mDefaultStorage
"
already
have
a
default
CookieStorage
"
)
;
NS_ASSERTION
(
!
mPrivateStorage
"
already
have
a
private
CookieStorage
"
)
;
NS_ASSERTION
(
!
mInitializedCookieStorages
"
already
initialized
"
)
;
NS_ASSERTION
(
!
mThread
"
already
have
a
cookie
thread
"
)
;
mDefaultStorage
=
CookieDefaultStorage
:
:
Create
(
)
;
mPrivateStorage
=
CookiePrivateStorage
:
:
Create
(
)
;
nsresult
rv
=
NS_GetSpecialDirectory
(
NS_APP_USER_PROFILE_50_DIR
getter_AddRefs
(
mDefaultStorage
-
>
cookieFile
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
COOKIE_LOGSTRING
(
LogLevel
:
:
Warning
(
"
InitCookieStorages
(
)
:
couldn
'
t
get
cookie
file
"
)
)
;
mInitializedDBConn
=
true
;
mInitializedCookieStorages
=
true
;
return
;
}
mDefaultStorage
-
>
cookieFile
-
>
AppendNative
(
NS_LITERAL_CSTRING
(
COOKIES_FILE
)
)
;
NS_ENSURE_SUCCESS_VOID
(
NS_NewNamedThread
(
"
Cookie
"
getter_AddRefs
(
mThread
)
)
)
;
nsCOMPtr
<
nsIRunnable
>
runnable
=
NS_NewRunnableFunction
(
"
InitCookieStorages
.
TryInitDB
"
[
]
{
NS_ENSURE_TRUE_VOID
(
gCookieService
)
;
MonitorAutoLock
lock
(
gCookieService
-
>
mMonitor
)
;
OpenDBResult
result
=
gCookieService
-
>
TryInitDB
(
false
)
;
if
(
result
=
=
RESULT_RETRY
)
{
COOKIE_LOGSTRING
(
LogLevel
:
:
Warning
(
"
InitCookieStorages
(
)
:
retrying
TryInitDB
(
)
"
)
)
;
gCookieService
-
>
mDefaultStorage
-
>
CleanupCachedStatements
(
)
;
gCookieService
-
>
mDefaultStorage
-
>
CleanupDefaultDBConnection
(
)
;
result
=
gCookieService
-
>
TryInitDB
(
true
)
;
if
(
result
=
=
RESULT_RETRY
)
{
result
=
RESULT_FAILURE
;
}
}
if
(
result
=
=
RESULT_FAILURE
)
{
COOKIE_LOGSTRING
(
LogLevel
:
:
Warning
(
"
InitCookieStorages
(
)
:
TryInitDB
(
)
failed
closing
connection
"
)
)
;
gCookieService
-
>
mDefaultStorage
-
>
CleanupCachedStatements
(
)
;
gCookieService
-
>
mDefaultStorage
-
>
CleanupDefaultDBConnection
(
)
;
gCookieService
-
>
mInitializedDBConn
=
true
;
}
gCookieService
-
>
mInitializedCookieStorages
=
true
;
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
TryInitDB
.
InitDBConn
"
[
]
{
NS_ENSURE_TRUE_VOID
(
gCookieService
)
;
gCookieService
-
>
InitDBConn
(
)
;
}
)
)
;
gCookieService
-
>
mMonitor
.
Notify
(
)
;
}
)
;
mThread
-
>
Dispatch
(
runnable
NS_DISPATCH_NORMAL
)
;
}
namespace
{
class
ConvertAppIdToOriginAttrsSQLFunction
final
:
public
mozIStorageFunction
{
~
ConvertAppIdToOriginAttrsSQLFunction
(
)
=
default
;
NS_DECL_ISUPPORTS
NS_DECL_MOZISTORAGEFUNCTION
}
;
NS_IMPL_ISUPPORTS
(
ConvertAppIdToOriginAttrsSQLFunction
mozIStorageFunction
)
;
NS_IMETHODIMP
ConvertAppIdToOriginAttrsSQLFunction
:
:
OnFunctionCall
(
mozIStorageValueArray
*
aFunctionArguments
nsIVariant
*
*
aResult
)
{
nsresult
rv
;
int32_t
inIsolatedMozBrowser
;
rv
=
aFunctionArguments
-
>
GetInt32
(
1
&
inIsolatedMozBrowser
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
OriginAttributes
attrs
(
inIsolatedMozBrowser
?
true
:
false
)
;
nsAutoCString
suffix
;
attrs
.
CreateSuffix
(
suffix
)
;
RefPtr
<
nsVariant
>
outVar
(
new
nsVariant
(
)
)
;
rv
=
outVar
-
>
SetAsAUTF8String
(
suffix
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
outVar
.
forget
(
aResult
)
;
return
NS_OK
;
}
class
SetAppIdFromOriginAttributesSQLFunction
final
:
public
mozIStorageFunction
{
~
SetAppIdFromOriginAttributesSQLFunction
(
)
=
default
;
NS_DECL_ISUPPORTS
NS_DECL_MOZISTORAGEFUNCTION
}
;
NS_IMPL_ISUPPORTS
(
SetAppIdFromOriginAttributesSQLFunction
mozIStorageFunction
)
;
NS_IMETHODIMP
SetAppIdFromOriginAttributesSQLFunction
:
:
OnFunctionCall
(
mozIStorageValueArray
*
aFunctionArguments
nsIVariant
*
*
aResult
)
{
nsresult
rv
;
nsAutoCString
suffix
;
OriginAttributes
attrs
;
rv
=
aFunctionArguments
-
>
GetUTF8String
(
0
suffix
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
success
=
attrs
.
PopulateFromSuffix
(
suffix
)
;
NS_ENSURE_TRUE
(
success
NS_ERROR_FAILURE
)
;
RefPtr
<
nsVariant
>
outVar
(
new
nsVariant
(
)
)
;
rv
=
outVar
-
>
SetAsInt32
(
0
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
outVar
.
forget
(
aResult
)
;
return
NS_OK
;
}
class
SetInBrowserFromOriginAttributesSQLFunction
final
:
public
mozIStorageFunction
{
~
SetInBrowserFromOriginAttributesSQLFunction
(
)
=
default
;
NS_DECL_ISUPPORTS
NS_DECL_MOZISTORAGEFUNCTION
}
;
NS_IMPL_ISUPPORTS
(
SetInBrowserFromOriginAttributesSQLFunction
mozIStorageFunction
)
;
NS_IMETHODIMP
SetInBrowserFromOriginAttributesSQLFunction
:
:
OnFunctionCall
(
mozIStorageValueArray
*
aFunctionArguments
nsIVariant
*
*
aResult
)
{
nsresult
rv
;
nsAutoCString
suffix
;
OriginAttributes
attrs
;
rv
=
aFunctionArguments
-
>
GetUTF8String
(
0
suffix
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
success
=
attrs
.
PopulateFromSuffix
(
suffix
)
;
NS_ENSURE_TRUE
(
success
NS_ERROR_FAILURE
)
;
RefPtr
<
nsVariant
>
outVar
(
new
nsVariant
(
)
)
;
rv
=
outVar
-
>
SetAsInt32
(
attrs
.
mInIsolatedMozBrowser
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
outVar
.
forget
(
aResult
)
;
return
NS_OK
;
}
}
OpenDBResult
nsCookieService
:
:
TryInitDB
(
bool
aRecreateDB
)
{
NS_ASSERTION
(
!
mDefaultStorage
-
>
dbConn
"
nonnull
dbConn
"
)
;
NS_ASSERTION
(
!
mDefaultStorage
-
>
stmtInsert
"
nonnull
stmtInsert
"
)
;
NS_ASSERTION
(
!
mDefaultStorage
-
>
insertListener
"
nonnull
insertListener
"
)
;
NS_ASSERTION
(
!
mDefaultStorage
-
>
syncConn
"
nonnull
syncConn
"
)
;
NS_ASSERTION
(
NS_GetCurrentThread
(
)
=
=
mThread
"
non
cookie
thread
"
)
;
nsresult
rv
;
if
(
aRecreateDB
)
{
nsCOMPtr
<
nsIFile
>
backupFile
;
mDefaultStorage
-
>
cookieFile
-
>
Clone
(
getter_AddRefs
(
backupFile
)
)
;
rv
=
backupFile
-
>
MoveToNative
(
nullptr
NS_LITERAL_CSTRING
(
COOKIES_FILE
"
.
bak
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_FAILURE
)
;
}
{
Telemetry
:
:
AutoTimer
<
Telemetry
:
:
MOZ_SQLITE_COOKIES_OPEN_READAHEAD_MS
>
telemetry
;
ReadAheadFile
(
mDefaultStorage
-
>
cookieFile
)
;
rv
=
mStorageService
-
>
OpenUnsharedDatabase
(
mDefaultStorage
-
>
cookieFile
getter_AddRefs
(
mDefaultStorage
-
>
syncConn
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
}
auto
guard
=
MakeScopeExit
(
[
&
]
{
mDefaultStorage
-
>
syncConn
=
nullptr
;
}
)
;
bool
tableExists
=
false
;
mDefaultStorage
-
>
syncConn
-
>
TableExists
(
NS_LITERAL_CSTRING
(
"
moz_cookies
"
)
&
tableExists
)
;
if
(
!
tableExists
)
{
rv
=
CreateTable
(
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
}
else
{
int32_t
dbSchemaVersion
;
rv
=
mDefaultStorage
-
>
syncConn
-
>
GetSchemaVersion
(
&
dbSchemaVersion
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
mozStorageTransaction
transaction
(
mDefaultStorage
-
>
syncConn
true
)
;
switch
(
dbSchemaVersion
)
{
case
1
:
{
rv
=
mDefaultStorage
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
ALTER
TABLE
moz_cookies
ADD
lastAccessed
INTEGER
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
}
[
[
fallthrough
]
]
;
case
2
:
{
rv
=
mDefaultStorage
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
ALTER
TABLE
moz_cookies
ADD
baseDomain
TEXT
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
const
int64_t
SCHEMA2_IDX_ID
=
0
;
const
int64_t
SCHEMA2_IDX_HOST
=
1
;
nsCOMPtr
<
mozIStorageStatement
>
select
;
rv
=
mDefaultStorage
-
>
syncConn
-
>
CreateStatement
(
NS_LITERAL_CSTRING
(
"
SELECT
id
host
FROM
moz_cookies
"
)
getter_AddRefs
(
select
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
nsCOMPtr
<
mozIStorageStatement
>
update
;
rv
=
mDefaultStorage
-
>
syncConn
-
>
CreateStatement
(
NS_LITERAL_CSTRING
(
"
UPDATE
moz_cookies
SET
baseDomain
=
"
"
:
baseDomain
WHERE
id
=
:
id
"
)
getter_AddRefs
(
update
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
nsCString
baseDomain
host
;
bool
hasResult
;
while
(
true
)
{
rv
=
select
-
>
ExecuteStep
(
&
hasResult
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
if
(
!
hasResult
)
break
;
int64_t
id
=
select
-
>
AsInt64
(
SCHEMA2_IDX_ID
)
;
select
-
>
GetUTF8String
(
SCHEMA2_IDX_HOST
host
)
;
rv
=
GetBaseDomainFromHost
(
mTLDService
host
baseDomain
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
mozStorageStatementScoper
scoper
(
update
)
;
rv
=
update
-
>
BindUTF8StringByName
(
NS_LITERAL_CSTRING
(
"
baseDomain
"
)
baseDomain
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
rv
=
update
-
>
BindInt64ByName
(
NS_LITERAL_CSTRING
(
"
id
"
)
id
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
rv
=
update
-
>
ExecuteStep
(
&
hasResult
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
}
rv
=
mDefaultStorage
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
CREATE
INDEX
moz_basedomain
ON
moz_cookies
(
baseDomain
)
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
}
[
[
fallthrough
]
]
;
case
3
:
{
const
int64_t
SCHEMA3_IDX_ID
=
0
;
const
int64_t
SCHEMA3_IDX_NAME
=
1
;
const
int64_t
SCHEMA3_IDX_HOST
=
2
;
const
int64_t
SCHEMA3_IDX_PATH
=
3
;
nsCOMPtr
<
mozIStorageStatement
>
select
;
rv
=
mDefaultStorage
-
>
syncConn
-
>
CreateStatement
(
NS_LITERAL_CSTRING
(
"
SELECT
id
name
host
path
FROM
moz_cookies
"
"
ORDER
BY
name
ASC
host
ASC
path
ASC
expiry
ASC
"
)
getter_AddRefs
(
select
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
nsCOMPtr
<
mozIStorageStatement
>
deleteExpired
;
rv
=
mDefaultStorage
-
>
syncConn
-
>
CreateStatement
(
NS_LITERAL_CSTRING
(
"
DELETE
FROM
moz_cookies
WHERE
id
=
:
id
"
)
getter_AddRefs
(
deleteExpired
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
bool
hasResult
;
rv
=
select
-
>
ExecuteStep
(
&
hasResult
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
if
(
hasResult
)
{
nsCString
name1
host1
path1
;
int64_t
id1
=
select
-
>
AsInt64
(
SCHEMA3_IDX_ID
)
;
select
-
>
GetUTF8String
(
SCHEMA3_IDX_NAME
name1
)
;
select
-
>
GetUTF8String
(
SCHEMA3_IDX_HOST
host1
)
;
select
-
>
GetUTF8String
(
SCHEMA3_IDX_PATH
path1
)
;
nsCString
name2
host2
path2
;
while
(
true
)
{
rv
=
select
-
>
ExecuteStep
(
&
hasResult
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
if
(
!
hasResult
)
break
;
int64_t
id2
=
select
-
>
AsInt64
(
SCHEMA3_IDX_ID
)
;
select
-
>
GetUTF8String
(
SCHEMA3_IDX_NAME
name2
)
;
select
-
>
GetUTF8String
(
SCHEMA3_IDX_HOST
host2
)
;
select
-
>
GetUTF8String
(
SCHEMA3_IDX_PATH
path2
)
;
if
(
name1
=
=
name2
&
&
host1
=
=
host2
&
&
path1
=
=
path2
)
{
mozStorageStatementScoper
scoper
(
deleteExpired
)
;
rv
=
deleteExpired
-
>
BindInt64ByName
(
NS_LITERAL_CSTRING
(
"
id
"
)
id1
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
rv
=
deleteExpired
-
>
ExecuteStep
(
&
hasResult
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
}
name1
=
name2
;
host1
=
host2
;
path1
=
path2
;
id1
=
id2
;
}
}
rv
=
mDefaultStorage
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
ALTER
TABLE
moz_cookies
ADD
creationTime
INTEGER
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
rv
=
mDefaultStorage
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
UPDATE
moz_cookies
SET
creationTime
=
"
"
(
SELECT
id
WHERE
id
=
moz_cookies
.
id
)
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
rv
=
mDefaultStorage
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
CREATE
UNIQUE
INDEX
moz_uniqueid
"
"
ON
moz_cookies
(
name
host
path
)
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
}
[
[
fallthrough
]
]
;
case
4
:
{
rv
=
mDefaultStorage
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
ALTER
TABLE
moz_cookies
RENAME
TO
moz_cookies_old
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
rv
=
mDefaultStorage
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
DROP
INDEX
moz_basedomain
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
rv
=
CreateTableForSchemaVersion5
(
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
rv
=
mDefaultStorage
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
INSERT
INTO
moz_cookies
"
"
(
baseDomain
appId
inBrowserElement
name
value
host
path
"
"
expiry
"
"
lastAccessed
creationTime
isSecure
isHttpOnly
)
"
"
SELECT
baseDomain
0
0
name
value
host
path
expiry
"
"
lastAccessed
creationTime
isSecure
isHttpOnly
"
"
FROM
moz_cookies_old
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
rv
=
mDefaultStorage
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
DROP
TABLE
moz_cookies_old
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
COOKIE_LOGSTRING
(
LogLevel
:
:
Debug
(
"
Upgraded
database
to
schema
version
5
"
)
)
;
}
[
[
fallthrough
]
]
;
case
5
:
{
rv
=
mDefaultStorage
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
ALTER
TABLE
moz_cookies
RENAME
TO
moz_cookies_old
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
rv
=
mDefaultStorage
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
DROP
INDEX
moz_basedomain
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
rv
=
CreateTableForSchemaVersion6
(
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
nsCOMPtr
<
mozIStorageFunction
>
convertToOriginAttrs
(
new
ConvertAppIdToOriginAttrsSQLFunction
(
)
)
;
NS_ENSURE_TRUE
(
convertToOriginAttrs
RESULT_RETRY
)
;
NS_NAMED_LITERAL_CSTRING
(
convertToOriginAttrsName
"
CONVERT_TO_ORIGIN_ATTRIBUTES
"
)
;
rv
=
mDefaultStorage
-
>
syncConn
-
>
CreateFunction
(
convertToOriginAttrsName
2
convertToOriginAttrs
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
rv
=
mDefaultStorage
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
INSERT
INTO
moz_cookies
"
"
(
baseDomain
originAttributes
name
value
host
path
expiry
"
"
lastAccessed
creationTime
isSecure
isHttpOnly
)
"
"
SELECT
baseDomain
"
"
CONVERT_TO_ORIGIN_ATTRIBUTES
(
appId
inBrowserElement
)
"
"
name
value
host
path
expiry
lastAccessed
creationTime
"
"
isSecure
isHttpOnly
"
"
FROM
moz_cookies_old
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
rv
=
mDefaultStorage
-
>
syncConn
-
>
RemoveFunction
(
convertToOriginAttrsName
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
rv
=
mDefaultStorage
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
DROP
TABLE
moz_cookies_old
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
COOKIE_LOGSTRING
(
LogLevel
:
:
Debug
(
"
Upgraded
database
to
schema
version
6
"
)
)
;
}
[
[
fallthrough
]
]
;
case
6
:
{
rv
=
mDefaultStorage
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
ALTER
TABLE
moz_cookies
ADD
appId
INTEGER
DEFAULT
0
;
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
rv
=
mDefaultStorage
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
ALTER
TABLE
moz_cookies
ADD
inBrowserElement
INTEGER
DEFAULT
0
;
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
nsCOMPtr
<
mozIStorageFunction
>
setAppId
(
new
SetAppIdFromOriginAttributesSQLFunction
(
)
)
;
NS_ENSURE_TRUE
(
setAppId
RESULT_RETRY
)
;
NS_NAMED_LITERAL_CSTRING
(
setAppIdName
"
SET_APP_ID
"
)
;
rv
=
mDefaultStorage
-
>
syncConn
-
>
CreateFunction
(
setAppIdName
1
setAppId
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
nsCOMPtr
<
mozIStorageFunction
>
setInBrowser
(
new
SetInBrowserFromOriginAttributesSQLFunction
(
)
)
;
NS_ENSURE_TRUE
(
setInBrowser
RESULT_RETRY
)
;
NS_NAMED_LITERAL_CSTRING
(
setInBrowserName
"
SET_IN_BROWSER
"
)
;
rv
=
mDefaultStorage
-
>
syncConn
-
>
CreateFunction
(
setInBrowserName
1
setInBrowser
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
rv
=
mDefaultStorage
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
UPDATE
moz_cookies
SET
appId
=
SET_APP_ID
(
originAttributes
)
"
"
inBrowserElement
=
SET_IN_BROWSER
(
originAttributes
)
;
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
rv
=
mDefaultStorage
-
>
syncConn
-
>
RemoveFunction
(
setAppIdName
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
rv
=
mDefaultStorage
-
>
syncConn
-
>
RemoveFunction
(
setInBrowserName
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
COOKIE_LOGSTRING
(
LogLevel
:
:
Debug
(
"
Upgraded
database
to
schema
version
7
"
)
)
;
}
[
[
fallthrough
]
]
;
case
7
:
{
rv
=
mDefaultStorage
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
DROP
INDEX
moz_basedomain
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
rv
=
mDefaultStorage
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
CREATE
TABLE
new_moz_cookies
(
"
"
id
INTEGER
PRIMARY
KEY
"
"
baseDomain
TEXT
"
"
originAttributes
TEXT
NOT
NULL
DEFAULT
'
'
"
"
name
TEXT
"
"
value
TEXT
"
"
host
TEXT
"
"
path
TEXT
"
"
expiry
INTEGER
"
"
lastAccessed
INTEGER
"
"
creationTime
INTEGER
"
"
isSecure
INTEGER
"
"
isHttpOnly
INTEGER
"
"
inBrowserElement
INTEGER
DEFAULT
0
"
"
CONSTRAINT
moz_uniqueid
UNIQUE
(
name
host
"
"
path
originAttributes
)
"
"
)
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
rv
=
mDefaultStorage
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
INSERT
INTO
new_moz_cookies
(
"
"
id
"
"
baseDomain
"
"
originAttributes
"
"
name
"
"
value
"
"
host
"
"
path
"
"
expiry
"
"
lastAccessed
"
"
creationTime
"
"
isSecure
"
"
isHttpOnly
"
"
inBrowserElement
"
"
)
SELECT
"
"
id
"
"
baseDomain
"
"
originAttributes
"
"
name
"
"
value
"
"
host
"
"
path
"
"
expiry
"
"
lastAccessed
"
"
creationTime
"
"
isSecure
"
"
isHttpOnly
"
"
inBrowserElement
"
"
FROM
moz_cookies
;
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
rv
=
mDefaultStorage
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
DROP
TABLE
moz_cookies
;
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
rv
=
mDefaultStorage
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
ALTER
TABLE
new_moz_cookies
RENAME
TO
moz_cookies
;
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
rv
=
mDefaultStorage
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
CREATE
INDEX
moz_basedomain
ON
moz_cookies
"
"
(
baseDomain
originAttributes
)
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
COOKIE_LOGSTRING
(
LogLevel
:
:
Debug
(
"
Upgraded
database
to
schema
version
8
"
)
)
;
}
[
[
fallthrough
]
]
;
case
8
:
{
rv
=
mDefaultStorage
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
ALTER
TABLE
moz_cookies
ADD
sameSite
INTEGER
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
COOKIE_LOGSTRING
(
LogLevel
:
:
Debug
(
"
Upgraded
database
to
schema
version
9
"
)
)
;
}
[
[
fallthrough
]
]
;
case
9
:
{
rv
=
mDefaultStorage
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
ALTER
TABLE
moz_cookies
ADD
rawSameSite
INTEGER
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
rv
=
mDefaultStorage
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
UPDATE
moz_cookies
SET
rawSameSite
=
sameSite
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
COOKIE_LOGSTRING
(
LogLevel
:
:
Debug
(
"
Upgraded
database
to
schema
version
10
"
)
)
;
}
[
[
fallthrough
]
]
;
case
10
:
{
rv
=
mDefaultStorage
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
ALTER
TABLE
moz_cookies
RENAME
TO
moz_cookies_old
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
rv
=
mDefaultStorage
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
CREATE
TABLE
moz_cookies
(
"
"
id
INTEGER
PRIMARY
KEY
"
"
originAttributes
TEXT
NOT
NULL
DEFAULT
'
'
"
"
name
TEXT
"
"
value
TEXT
"
"
host
TEXT
"
"
path
TEXT
"
"
expiry
INTEGER
"
"
lastAccessed
INTEGER
"
"
creationTime
INTEGER
"
"
isSecure
INTEGER
"
"
isHttpOnly
INTEGER
"
"
inBrowserElement
INTEGER
DEFAULT
0
"
"
sameSite
INTEGER
DEFAULT
0
"
"
rawSameSite
INTEGER
DEFAULT
0
"
"
CONSTRAINT
moz_uniqueid
UNIQUE
(
name
host
"
"
path
originAttributes
)
"
"
)
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
rv
=
mDefaultStorage
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
INSERT
INTO
moz_cookies
(
"
"
id
"
"
originAttributes
"
"
name
"
"
value
"
"
host
"
"
path
"
"
expiry
"
"
lastAccessed
"
"
creationTime
"
"
isSecure
"
"
isHttpOnly
"
"
inBrowserElement
"
"
sameSite
"
"
rawSameSite
"
"
)
SELECT
"
"
id
"
"
originAttributes
"
"
name
"
"
value
"
"
host
"
"
path
"
"
expiry
"
"
lastAccessed
"
"
creationTime
"
"
isSecure
"
"
isHttpOnly
"
"
inBrowserElement
"
"
sameSite
"
"
rawSameSite
"
"
FROM
moz_cookies_old
"
"
WHERE
baseDomain
NOTNULL
;
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
rv
=
mDefaultStorage
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
DROP
TABLE
moz_cookies_old
;
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
rv
=
mDefaultStorage
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
DROP
INDEX
IF
EXISTS
moz_basedomain
;
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
COOKIE_LOGSTRING
(
LogLevel
:
:
Debug
(
"
Upgraded
database
to
schema
version
11
"
)
)
;
rv
=
mDefaultStorage
-
>
syncConn
-
>
SetSchemaVersion
(
COOKIES_SCHEMA_VERSION
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
}
[
[
fallthrough
]
]
;
case
COOKIES_SCHEMA_VERSION
:
break
;
case
0
:
{
NS_WARNING
(
"
couldn
'
t
get
schema
version
!
"
)
;
rv
=
mDefaultStorage
-
>
syncConn
-
>
SetSchemaVersion
(
COOKIES_SCHEMA_VERSION
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
}
[
[
fallthrough
]
]
;
default
:
{
nsCOMPtr
<
mozIStorageStatement
>
stmt
;
rv
=
mDefaultStorage
-
>
syncConn
-
>
CreateStatement
(
NS_LITERAL_CSTRING
(
"
SELECT
"
"
id
"
"
originAttributes
"
"
name
"
"
value
"
"
host
"
"
path
"
"
expiry
"
"
lastAccessed
"
"
creationTime
"
"
isSecure
"
"
isHttpOnly
"
"
sameSite
"
"
rawSameSite
"
"
FROM
moz_cookies
"
)
getter_AddRefs
(
stmt
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
break
;
rv
=
mDefaultStorage
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
DROP
TABLE
moz_cookies
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
rv
=
CreateTable
(
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
}
break
;
}
}
if
(
aRecreateDB
)
{
return
RESULT_OK
;
}
if
(
tableExists
)
{
return
Read
(
)
;
}
nsCOMPtr
<
nsIRunnable
>
runnable
=
NS_NewRunnableFunction
(
"
TryInitDB
.
ImportCookies
"
[
]
{
NS_ENSURE_TRUE_VOID
(
gCookieService
)
;
NS_ENSURE_TRUE_VOID
(
gCookieService
-
>
mDefaultStorage
)
;
nsCOMPtr
<
nsIFile
>
oldCookieFile
;
nsresult
rv
=
NS_GetSpecialDirectory
(
NS_APP_USER_PROFILE_50_DIR
getter_AddRefs
(
oldCookieFile
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
oldCookieFile
-
>
AppendNative
(
NS_LITERAL_CSTRING
(
OLD_COOKIE_FILE_NAME
)
)
;
gCookieService
-
>
ImportCookies
(
oldCookieFile
)
;
oldCookieFile
-
>
Remove
(
false
)
;
}
)
;
NS_DispatchToMainThread
(
runnable
)
;
return
RESULT_OK
;
}
void
nsCookieService
:
:
InitDBConn
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
mInitializedCookieStorages
|
|
mInitializedDBConn
|
|
!
mDefaultStorage
)
{
return
;
}
for
(
uint32_t
i
=
0
;
i
<
mReadArray
.
Length
(
)
;
+
+
i
)
{
CookieDomainTuple
&
tuple
=
mReadArray
[
i
]
;
MOZ_ASSERT
(
!
tuple
.
cookie
-
>
isSession
(
)
)
;
RefPtr
<
Cookie
>
cookie
=
Cookie
:
:
Create
(
tuple
.
cookie
-
>
name
(
)
tuple
.
cookie
-
>
value
(
)
tuple
.
cookie
-
>
host
(
)
tuple
.
cookie
-
>
path
(
)
tuple
.
cookie
-
>
expiry
(
)
tuple
.
cookie
-
>
lastAccessed
(
)
tuple
.
cookie
-
>
creationTime
(
)
tuple
.
cookie
-
>
isSession
(
)
tuple
.
cookie
-
>
isSecure
(
)
tuple
.
cookie
-
>
isHttpOnly
(
)
tuple
.
originAttributes
tuple
.
cookie
-
>
sameSite
(
)
tuple
.
cookie
-
>
rawSameSite
(
)
)
;
mDefaultStorage
-
>
AddCookieToList
(
tuple
.
key
.
mBaseDomain
tuple
.
key
.
mOriginAttributes
cookie
nullptr
false
)
;
}
if
(
NS_FAILED
(
InitDBConnInternal
(
)
)
)
{
COOKIE_LOGSTRING
(
LogLevel
:
:
Warning
(
"
InitDBConn
(
)
:
retrying
InitDBConnInternal
(
)
"
)
)
;
mDefaultStorage
-
>
CleanupCachedStatements
(
)
;
mDefaultStorage
-
>
CleanupDefaultDBConnection
(
)
;
if
(
NS_FAILED
(
InitDBConnInternal
(
)
)
)
{
COOKIE_LOGSTRING
(
LogLevel
:
:
Warning
(
"
InitDBConn
(
)
:
InitDBConnInternal
(
)
failed
closing
connection
"
)
)
;
mDefaultStorage
-
>
CleanupCachedStatements
(
)
;
mDefaultStorage
-
>
CleanupDefaultDBConnection
(
)
;
}
}
mInitializedDBConn
=
true
;
COOKIE_LOGSTRING
(
LogLevel
:
:
Debug
(
"
InitDBConn
(
)
:
mInitializedDBConn
=
true
"
)
)
;
mEndInitDBConn
=
mozilla
:
:
TimeStamp
:
:
Now
(
)
;
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
os
)
{
os
-
>
NotifyObservers
(
nullptr
"
cookie
-
db
-
read
"
nullptr
)
;
mReadArray
.
Clear
(
)
;
}
}
nsresult
nsCookieService
:
:
InitDBConnInternal
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsresult
rv
=
mStorageService
-
>
OpenUnsharedDatabase
(
mDefaultStorage
-
>
cookieFile
getter_AddRefs
(
mDefaultStorage
-
>
dbConn
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mDefaultStorage
-
>
insertListener
=
new
InsertCookieDBListener
(
mDefaultStorage
)
;
mDefaultStorage
-
>
updateListener
=
new
UpdateCookieDBListener
(
mDefaultStorage
)
;
mDefaultStorage
-
>
removeListener
=
new
RemoveCookieDBListener
(
mDefaultStorage
)
;
mDefaultStorage
-
>
closeListener
=
new
CloseCookieDBListener
(
mDefaultStorage
)
;
mDefaultStorage
-
>
dbConn
-
>
SetGrowthIncrement
(
512
*
1024
EmptyCString
(
)
)
;
mDefaultStorage
-
>
dbConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
PRAGMA
synchronous
=
OFF
"
)
)
;
mDefaultStorage
-
>
dbConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
MOZ_STORAGE_UNIQUIFY_QUERY_STR
"
PRAGMA
journal_mode
=
WAL
"
)
)
;
mDefaultStorage
-
>
dbConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
PRAGMA
wal_autocheckpoint
=
16
"
)
)
;
rv
=
mDefaultStorage
-
>
dbConn
-
>
CreateAsyncStatement
(
NS_LITERAL_CSTRING
(
"
INSERT
INTO
moz_cookies
(
"
"
originAttributes
"
"
name
"
"
value
"
"
host
"
"
path
"
"
expiry
"
"
lastAccessed
"
"
creationTime
"
"
isSecure
"
"
isHttpOnly
"
"
sameSite
"
"
rawSameSite
"
"
)
VALUES
(
"
"
:
originAttributes
"
"
:
name
"
"
:
value
"
"
:
host
"
"
:
path
"
"
:
expiry
"
"
:
lastAccessed
"
"
:
creationTime
"
"
:
isSecure
"
"
:
isHttpOnly
"
"
:
sameSite
"
"
:
rawSameSite
"
"
)
"
)
getter_AddRefs
(
mDefaultStorage
-
>
stmtInsert
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mDefaultStorage
-
>
dbConn
-
>
CreateAsyncStatement
(
NS_LITERAL_CSTRING
(
"
DELETE
FROM
moz_cookies
"
"
WHERE
name
=
:
name
AND
host
=
:
host
AND
path
=
:
path
"
"
AND
originAttributes
=
:
originAttributes
"
)
getter_AddRefs
(
mDefaultStorage
-
>
stmtDelete
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mDefaultStorage
-
>
dbConn
-
>
CreateAsyncStatement
(
NS_LITERAL_CSTRING
(
"
UPDATE
moz_cookies
SET
lastAccessed
=
:
lastAccessed
"
"
WHERE
name
=
:
name
AND
host
=
:
host
AND
path
=
:
path
"
"
AND
originAttributes
=
:
originAttributes
"
)
getter_AddRefs
(
mDefaultStorage
-
>
stmtUpdate
)
)
;
return
rv
;
}
nsresult
nsCookieService
:
:
CreateTableWorker
(
const
char
*
aName
)
{
nsAutoCString
command
(
"
CREATE
TABLE
"
)
;
command
.
Append
(
aName
)
;
command
.
AppendLiteral
(
"
(
"
"
id
INTEGER
PRIMARY
KEY
"
"
originAttributes
TEXT
NOT
NULL
DEFAULT
'
'
"
"
name
TEXT
"
"
value
TEXT
"
"
host
TEXT
"
"
path
TEXT
"
"
expiry
INTEGER
"
"
lastAccessed
INTEGER
"
"
creationTime
INTEGER
"
"
isSecure
INTEGER
"
"
isHttpOnly
INTEGER
"
"
inBrowserElement
INTEGER
DEFAULT
0
"
"
sameSite
INTEGER
DEFAULT
0
"
"
rawSameSite
INTEGER
DEFAULT
0
"
"
CONSTRAINT
moz_uniqueid
UNIQUE
(
name
host
path
originAttributes
)
"
"
)
"
)
;
return
mDefaultStorage
-
>
syncConn
-
>
ExecuteSimpleSQL
(
command
)
;
}
nsresult
nsCookieService
:
:
CreateTable
(
)
{
nsresult
rv
=
mDefaultStorage
-
>
syncConn
-
>
SetSchemaVersion
(
COOKIES_SCHEMA_VERSION
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
rv
=
CreateTableWorker
(
"
moz_cookies
"
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
return
NS_OK
;
}
nsresult
nsCookieService
:
:
CreateTableForSchemaVersion6
(
)
{
nsresult
rv
=
mDefaultStorage
-
>
syncConn
-
>
SetSchemaVersion
(
6
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
rv
=
mDefaultStorage
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
CREATE
TABLE
moz_cookies
(
"
"
id
INTEGER
PRIMARY
KEY
"
"
baseDomain
TEXT
"
"
originAttributes
TEXT
NOT
NULL
DEFAULT
'
'
"
"
name
TEXT
"
"
value
TEXT
"
"
host
TEXT
"
"
path
TEXT
"
"
expiry
INTEGER
"
"
lastAccessed
INTEGER
"
"
creationTime
INTEGER
"
"
isSecure
INTEGER
"
"
isHttpOnly
INTEGER
"
"
CONSTRAINT
moz_uniqueid
UNIQUE
(
name
host
path
originAttributes
)
"
"
)
"
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
return
mDefaultStorage
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
CREATE
INDEX
moz_basedomain
ON
moz_cookies
(
baseDomain
"
"
originAttributes
)
"
)
)
;
}
nsresult
nsCookieService
:
:
CreateTableForSchemaVersion5
(
)
{
nsresult
rv
=
mDefaultStorage
-
>
syncConn
-
>
SetSchemaVersion
(
5
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
rv
=
mDefaultStorage
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
CREATE
TABLE
moz_cookies
(
"
"
id
INTEGER
PRIMARY
KEY
"
"
baseDomain
TEXT
"
"
appId
INTEGER
DEFAULT
0
"
"
inBrowserElement
INTEGER
DEFAULT
0
"
"
name
TEXT
"
"
value
TEXT
"
"
host
TEXT
"
"
path
TEXT
"
"
expiry
INTEGER
"
"
lastAccessed
INTEGER
"
"
creationTime
INTEGER
"
"
isSecure
INTEGER
"
"
isHttpOnly
INTEGER
"
"
CONSTRAINT
moz_uniqueid
UNIQUE
(
name
host
path
"
"
appId
inBrowserElement
)
"
"
)
"
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
return
mDefaultStorage
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
CREATE
INDEX
moz_basedomain
ON
moz_cookies
(
baseDomain
"
"
appId
"
"
inBrowserElement
)
"
)
)
;
}
void
nsCookieService
:
:
CloseCookieStorages
(
)
{
if
(
!
mDefaultStorage
)
{
return
;
}
if
(
mThread
)
{
mThread
-
>
Shutdown
(
)
;
mThread
=
nullptr
;
}
if
(
mPrivateStorage
)
{
mPrivateStorage
-
>
Close
(
)
;
mPrivateStorage
=
nullptr
;
}
mDefaultStorage
-
>
Close
(
)
;
mDefaultStorage
=
nullptr
;
mInitializedDBConn
=
false
;
mInitializedCookieStorages
=
false
;
}
void
nsCookieService
:
:
HandleDBClosed
(
CookieDefaultStorage
*
aCookieStorage
)
{
COOKIE_LOGSTRING
(
LogLevel
:
:
Debug
(
"
HandleDBClosed
(
)
:
CookieStorage
%
p
closed
"
aCookieStorage
)
)
;
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
switch
(
aCookieStorage
-
>
corruptFlag
)
{
case
CookieDefaultStorage
:
:
OK
:
{
if
(
os
)
{
os
-
>
NotifyObservers
(
nullptr
"
cookie
-
db
-
closed
"
nullptr
)
;
}
break
;
}
case
CookieDefaultStorage
:
:
CLOSING_FOR_REBUILD
:
{
RebuildCorruptDB
(
aCookieStorage
)
;
break
;
}
case
CookieDefaultStorage
:
:
REBUILDING
:
{
nsCOMPtr
<
nsIFile
>
backupFile
;
aCookieStorage
-
>
cookieFile
-
>
Clone
(
getter_AddRefs
(
backupFile
)
)
;
nsresult
rv
=
backupFile
-
>
MoveToNative
(
nullptr
NS_LITERAL_CSTRING
(
COOKIES_FILE
"
.
bak
-
rebuild
"
)
)
;
COOKIE_LOGSTRING
(
LogLevel
:
:
Warning
(
"
HandleDBClosed
(
)
:
CookieStorage
%
p
encountered
error
"
"
rebuilding
db
;
move
to
"
"
'
cookies
.
sqlite
.
bak
-
rebuild
'
gave
rv
0x
%
"
PRIx32
aCookieStorage
static_cast
<
uint32_t
>
(
rv
)
)
)
;
if
(
os
)
{
os
-
>
NotifyObservers
(
nullptr
"
cookie
-
db
-
closed
"
nullptr
)
;
}
break
;
}
}
}
void
nsCookieService
:
:
RebuildCorruptDB
(
CookieDefaultStorage
*
aCookieStorage
)
{
NS_ASSERTION
(
!
aCookieStorage
-
>
dbConn
"
shouldn
'
t
have
an
open
db
connection
"
)
;
NS_ASSERTION
(
aCookieStorage
-
>
corruptFlag
=
=
CookieDefaultStorage
:
:
CLOSING_FOR_REBUILD
"
should
be
in
CLOSING_FOR_REBUILD
state
"
)
;
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
aCookieStorage
-
>
corruptFlag
=
CookieDefaultStorage
:
:
REBUILDING
;
if
(
mDefaultStorage
!
=
aCookieStorage
)
{
COOKIE_LOGSTRING
(
LogLevel
:
:
Warning
(
"
RebuildCorruptDB
(
)
:
CookieStorage
%
p
is
stale
aborting
"
aCookieStorage
)
)
;
if
(
os
)
{
os
-
>
NotifyObservers
(
nullptr
"
cookie
-
db
-
closed
"
nullptr
)
;
}
return
;
}
COOKIE_LOGSTRING
(
LogLevel
:
:
Debug
(
"
RebuildCorruptDB
(
)
:
creating
new
database
"
)
)
;
nsCOMPtr
<
nsIRunnable
>
runnable
=
NS_NewRunnableFunction
(
"
RebuildCorruptDB
.
TryInitDB
"
[
]
{
NS_ENSURE_TRUE_VOID
(
gCookieService
&
&
gCookieService
-
>
mDefaultStorage
)
;
OpenDBResult
result
=
gCookieService
-
>
TryInitDB
(
true
)
;
nsCOMPtr
<
nsIRunnable
>
innerRunnable
=
NS_NewRunnableFunction
(
"
RebuildCorruptDB
.
TryInitDBComplete
"
[
result
]
{
NS_ENSURE_TRUE_VOID
(
gCookieService
&
&
gCookieService
-
>
mDefaultStorage
)
;
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
result
!
=
RESULT_OK
)
{
COOKIE_LOGSTRING
(
LogLevel
:
:
Warning
(
"
RebuildCorruptDB
(
)
:
TryInitDB
(
)
failed
with
result
%
u
"
result
)
)
;
gCookieService
-
>
mDefaultStorage
-
>
CleanupCachedStatements
(
)
;
gCookieService
-
>
mDefaultStorage
-
>
CleanupDefaultDBConnection
(
)
;
gCookieService
-
>
mDefaultStorage
-
>
corruptFlag
=
CookieDefaultStorage
:
:
OK
;
if
(
os
)
{
os
-
>
NotifyObservers
(
nullptr
"
cookie
-
db
-
closed
"
nullptr
)
;
}
return
;
}
if
(
os
)
{
os
-
>
NotifyObservers
(
nullptr
"
cookie
-
db
-
rebuilding
"
nullptr
)
;
}
gCookieService
-
>
InitDBConnInternal
(
)
;
mozIStorageAsyncStatement
*
stmt
=
gCookieService
-
>
mDefaultStorage
-
>
stmtInsert
;
nsCOMPtr
<
mozIStorageBindingParamsArray
>
paramsArray
;
stmt
-
>
NewBindingParamsArray
(
getter_AddRefs
(
paramsArray
)
)
;
for
(
auto
iter
=
gCookieService
-
>
mDefaultStorage
-
>
hostTable
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
CookieEntry
*
entry
=
iter
.
Get
(
)
;
const
CookieEntry
:
:
ArrayType
&
cookies
=
entry
-
>
GetCookies
(
)
;
for
(
CookieEntry
:
:
IndexType
i
=
0
;
i
<
cookies
.
Length
(
)
;
+
+
i
)
{
Cookie
*
cookie
=
cookies
[
i
]
;
if
(
!
cookie
-
>
IsSession
(
)
)
{
bindCookieParameters
(
paramsArray
CookieKey
(
entry
)
cookie
)
;
}
}
}
uint32_t
length
;
paramsArray
-
>
GetLength
(
&
length
)
;
if
(
length
=
=
0
)
{
COOKIE_LOGSTRING
(
LogLevel
:
:
Debug
(
"
RebuildCorruptDB
(
)
:
nothing
to
write
rebuild
complete
"
)
)
;
gCookieService
-
>
mDefaultStorage
-
>
corruptFlag
=
CookieDefaultStorage
:
:
OK
;
return
;
}
DebugOnly
<
nsresult
>
rv
=
stmt
-
>
BindParameters
(
paramsArray
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
nsCOMPtr
<
mozIStoragePendingStatement
>
handle
;
rv
=
stmt
-
>
ExecuteAsync
(
gCookieService
-
>
mDefaultStorage
-
>
insertListener
getter_AddRefs
(
handle
)
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
}
)
;
NS_DispatchToMainThread
(
innerRunnable
)
;
}
)
;
mThread
-
>
Dispatch
(
runnable
NS_DISPATCH_NORMAL
)
;
}
nsCookieService
:
:
~
nsCookieService
(
)
{
CloseCookieStorages
(
)
;
UnregisterWeakMemoryReporter
(
this
)
;
gCookieService
=
nullptr
;
}
NS_IMETHODIMP
nsCookieService
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
if
(
!
strcmp
(
aTopic
"
profile
-
before
-
change
"
)
)
{
CloseCookieStorages
(
)
;
}
else
if
(
!
strcmp
(
aTopic
"
profile
-
do
-
change
"
)
)
{
NS_ASSERTION
(
!
mDefaultStorage
"
shouldn
'
t
have
a
default
CookieStorage
"
)
;
NS_ASSERTION
(
!
mPrivateStorage
"
shouldn
'
t
have
a
private
CookieStorage
"
)
;
InitCookieStorages
(
)
;
}
else
if
(
!
strcmp
(
aTopic
"
last
-
pb
-
context
-
exited
"
)
)
{
mozilla
:
:
OriginAttributesPattern
pattern
;
pattern
.
mPrivateBrowsingId
.
Construct
(
1
)
;
RemoveCookiesWithOriginAttributes
(
pattern
EmptyCString
(
)
)
;
mPrivateStorage
=
CookiePrivateStorage
:
:
Create
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsCookieService
:
:
GetCookieString
(
nsIURI
*
aHostURI
nsIChannel
*
aChannel
nsACString
&
aCookie
)
{
return
GetCookieStringCommon
(
aHostURI
aChannel
false
aCookie
)
;
}
NS_IMETHODIMP
nsCookieService
:
:
GetCookieStringFromHttp
(
nsIURI
*
aHostURI
nsIURI
*
aFirstURI
nsIChannel
*
aChannel
nsACString
&
aCookie
)
{
return
GetCookieStringCommon
(
aHostURI
aChannel
true
aCookie
)
;
}
nsresult
nsCookieService
:
:
GetCookieStringCommon
(
nsIURI
*
aHostURI
nsIChannel
*
aChannel
bool
aHttpBound
nsACString
&
aCookie
)
{
NS_ENSURE_ARG
(
aHostURI
)
;
aCookie
.
Truncate
(
)
;
uint32_t
rejectedReason
=
0
;
ThirdPartyAnalysisResult
result
=
mThirdPartyUtil
-
>
AnalyzeChannel
(
aChannel
false
aHostURI
nullptr
&
rejectedReason
)
;
OriginAttributes
attrs
;
if
(
aChannel
)
{
NS_GetOriginAttributes
(
aChannel
attrs
true
)
;
}
bool
isSafeTopLevelNav
=
NS_IsSafeTopLevelNav
(
aChannel
)
;
bool
isSameSiteForeign
=
NS_IsSameSiteForeign
(
aChannel
aHostURI
)
;
GetCookieStringInternal
(
aHostURI
aChannel
result
.
contains
(
ThirdPartyAnalysis
:
:
IsForeign
)
result
.
contains
(
ThirdPartyAnalysis
:
:
IsThirdPartyTrackingResource
)
result
.
contains
(
ThirdPartyAnalysis
:
:
IsThirdPartySocialTrackingResource
)
result
.
contains
(
ThirdPartyAnalysis
:
:
IsFirstPartyStorageAccessGranted
)
rejectedReason
isSafeTopLevelNav
isSameSiteForeign
aHttpBound
attrs
aCookie
)
;
return
NS_OK
;
}
already_AddRefed
<
nsICookieJarSettings
>
nsCookieService
:
:
GetCookieJarSettings
(
nsIChannel
*
aChannel
)
{
nsCOMPtr
<
nsICookieJarSettings
>
cookieJarSettings
;
if
(
aChannel
)
{
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
aChannel
-
>
LoadInfo
(
)
;
nsresult
rv
=
loadInfo
-
>
GetCookieJarSettings
(
getter_AddRefs
(
cookieJarSettings
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
cookieJarSettings
=
CookieJarSettings
:
:
GetBlockingAll
(
)
;
}
}
else
{
cookieJarSettings
=
CookieJarSettings
:
:
Create
(
)
;
}
MOZ_ASSERT
(
cookieJarSettings
)
;
return
cookieJarSettings
.
forget
(
)
;
}
NS_IMETHODIMP
nsCookieService
:
:
SetCookieString
(
nsIURI
*
aHostURI
const
nsACString
&
aCookieHeader
nsIChannel
*
aChannel
)
{
return
SetCookieStringCommon
(
aHostURI
aCookieHeader
VoidCString
(
)
aChannel
false
)
;
}
NS_IMETHODIMP
nsCookieService
:
:
SetCookieStringFromHttp
(
nsIURI
*
aHostURI
nsIURI
*
aFirstURI
const
nsACString
&
aCookieHeader
const
nsACString
&
aServerTime
nsIChannel
*
aChannel
)
{
return
SetCookieStringCommon
(
aHostURI
aCookieHeader
aServerTime
aChannel
true
)
;
}
int64_t
nsCookieService
:
:
ParseServerTime
(
const
nsACString
&
aServerTime
)
{
PRTime
tempServerTime
;
int64_t
serverTime
;
PRStatus
result
=
PR_ParseTimeString
(
aServerTime
.
BeginReading
(
)
true
&
tempServerTime
)
;
if
(
result
=
=
PR_SUCCESS
)
{
serverTime
=
tempServerTime
/
int64_t
(
PR_USEC_PER_SEC
)
;
}
else
{
serverTime
=
PR_Now
(
)
/
PR_USEC_PER_SEC
;
}
return
serverTime
;
}
nsresult
nsCookieService
:
:
SetCookieStringCommon
(
nsIURI
*
aHostURI
const
nsACString
&
aCookieHeader
const
nsACString
&
aServerTime
nsIChannel
*
aChannel
bool
aFromHttp
)
{
NS_ENSURE_ARG
(
aHostURI
)
;
uint32_t
rejectedReason
=
0
;
ThirdPartyAnalysisResult
result
=
mThirdPartyUtil
-
>
AnalyzeChannel
(
aChannel
false
aHostURI
nullptr
&
rejectedReason
)
;
OriginAttributes
attrs
;
if
(
aChannel
)
{
NS_GetOriginAttributes
(
aChannel
attrs
true
)
;
}
nsCString
cookieString
(
aCookieHeader
)
;
SetCookieStringInternal
(
aHostURI
result
.
contains
(
ThirdPartyAnalysis
:
:
IsForeign
)
result
.
contains
(
ThirdPartyAnalysis
:
:
IsThirdPartyTrackingResource
)
result
.
contains
(
ThirdPartyAnalysis
:
:
IsThirdPartySocialTrackingResource
)
result
.
contains
(
ThirdPartyAnalysis
:
:
IsFirstPartyStorageAccessGranted
)
rejectedReason
cookieString
aServerTime
aFromHttp
attrs
aChannel
)
;
return
NS_OK
;
}
void
nsCookieService
:
:
SetCookieStringInternal
(
nsIURI
*
aHostURI
bool
aIsForeign
bool
aIsThirdPartyTrackingResource
bool
aIsThirdPartySocialTrackingResource
bool
aFirstPartyStorageAccessGranted
uint32_t
aRejectedReason
nsCString
&
aCookieHeader
const
nsACString
&
aServerTime
bool
aFromHttp
const
OriginAttributes
&
aOriginAttrs
nsIChannel
*
aChannel
)
{
NS_ASSERTION
(
aHostURI
"
null
host
!
"
)
;
if
(
!
IsInitialized
(
)
)
{
return
;
}
CookieStorage
*
storage
=
PickStorage
(
aOriginAttrs
)
;
bool
requireHostMatch
;
nsAutoCString
baseDomain
;
nsresult
rv
=
GetBaseDomain
(
mTLDService
aHostURI
baseDomain
requireHostMatch
)
;
if
(
NS_FAILED
(
rv
)
)
{
COOKIE_LOGFAILURE
(
SET_COOKIE
aHostURI
aCookieHeader
"
couldn
'
t
get
base
domain
from
URI
"
)
;
return
;
}
nsCOMPtr
<
nsICookieJarSettings
>
cookieJarSettings
=
GetCookieJarSettings
(
aChannel
)
;
nsAutoCString
hostFromURI
;
aHostURI
-
>
GetHost
(
hostFromURI
)
;
rv
=
NormalizeHost
(
hostFromURI
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
nsAutoCString
baseDomainFromURI
;
rv
=
GetBaseDomainFromHost
(
mTLDService
hostFromURI
baseDomainFromURI
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
uint32_t
priorCookieCount
=
storage
-
>
CountCookiesFromHost
(
baseDomainFromURI
aOriginAttrs
.
mPrivateBrowsingId
)
;
uint32_t
rejectedReason
=
aRejectedReason
;
CookieStatus
cookieStatus
=
CheckPrefs
(
cookieJarSettings
aHostURI
aIsForeign
aIsThirdPartyTrackingResource
aIsThirdPartySocialTrackingResource
aFirstPartyStorageAccessGranted
aCookieHeader
priorCookieCount
aOriginAttrs
&
rejectedReason
)
;
MOZ_ASSERT_IF
(
rejectedReason
cookieStatus
=
=
STATUS_REJECTED
)
;
switch
(
cookieStatus
)
{
case
STATUS_REJECTED
:
NotifyRejected
(
aHostURI
aChannel
rejectedReason
OPERATION_WRITE
)
;
return
;
case
STATUS_REJECTED_WITH_ERROR
:
NotifyRejected
(
aHostURI
aChannel
rejectedReason
OPERATION_WRITE
)
;
return
;
case
STATUS_ACCEPTED
:
case
STATUS_ACCEPT_SESSION
:
NotifyAccepted
(
aChannel
)
;
break
;
default
:
break
;
}
int64_t
serverTime
=
ParseServerTime
(
aServerTime
)
;
while
(
SetCookieInternal
(
storage
aHostURI
baseDomain
aOriginAttrs
requireHostMatch
cookieStatus
aCookieHeader
serverTime
aFromHttp
aChannel
)
)
{
if
(
!
aFromHttp
)
break
;
}
}
void
nsCookieService
:
:
NotifyAccepted
(
nsIChannel
*
aChannel
)
{
ContentBlockingNotifier
:
:
OnDecision
(
aChannel
ContentBlockingNotifier
:
:
BlockingDecision
:
:
eAllow
0
)
;
}
void
nsCookieService
:
:
NotifyRejected
(
nsIURI
*
aHostURI
nsIChannel
*
aChannel
uint32_t
aRejectedReason
CookieOperation
aOperation
)
{
if
(
aOperation
=
=
OPERATION_WRITE
)
{
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
os
)
{
os
-
>
NotifyObservers
(
aHostURI
"
cookie
-
rejected
"
nullptr
)
;
}
}
else
{
MOZ_ASSERT
(
aOperation
=
=
OPERATION_READ
)
;
}
ContentBlockingNotifier
:
:
OnDecision
(
aChannel
ContentBlockingNotifier
:
:
BlockingDecision
:
:
eBlock
aRejectedReason
)
;
}
NS_IMETHODIMP
nsCookieService
:
:
RunInTransaction
(
nsICookieTransactionCallback
*
aCallback
)
{
NS_ENSURE_ARG
(
aCallback
)
;
if
(
!
IsInitialized
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
EnsureReadComplete
(
true
)
;
if
(
NS_WARN_IF
(
!
mDefaultStorage
-
>
dbConn
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
mozStorageTransaction
transaction
(
mDefaultStorage
-
>
dbConn
true
)
;
if
(
NS_FAILED
(
aCallback
-
>
Callback
(
)
)
)
{
Unused
<
<
transaction
.
Rollback
(
)
;
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsCookieService
:
:
RemoveAll
(
)
{
if
(
!
IsInitialized
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
EnsureReadComplete
(
true
)
;
mDefaultStorage
-
>
RemoveAll
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsCookieService
:
:
GetCookies
(
nsTArray
<
RefPtr
<
nsICookie
>
>
&
aCookies
)
{
if
(
!
IsInitialized
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
EnsureReadComplete
(
true
)
;
mDefaultStorage
-
>
GetCookies
(
aCookies
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsCookieService
:
:
GetSessionCookies
(
nsTArray
<
RefPtr
<
nsICookie
>
>
&
aCookies
)
{
if
(
!
IsInitialized
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
EnsureReadComplete
(
true
)
;
mDefaultStorage
-
>
GetCookies
(
aCookies
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsCookieService
:
:
Add
(
const
nsACString
&
aHost
const
nsACString
&
aPath
const
nsACString
&
aName
const
nsACString
&
aValue
bool
aIsSecure
bool
aIsHttpOnly
bool
aIsSession
int64_t
aExpiry
JS
:
:
HandleValue
aOriginAttributes
int32_t
aSameSite
JSContext
*
aCx
)
{
OriginAttributes
attrs
;
if
(
!
aOriginAttributes
.
isObject
(
)
|
|
!
attrs
.
Init
(
aCx
aOriginAttributes
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
return
AddNative
(
aHost
aPath
aName
aValue
aIsSecure
aIsHttpOnly
aIsSession
aExpiry
&
attrs
aSameSite
)
;
}
NS_IMETHODIMP_
(
nsresult
)
nsCookieService
:
:
AddNative
(
const
nsACString
&
aHost
const
nsACString
&
aPath
const
nsACString
&
aName
const
nsACString
&
aValue
bool
aIsSecure
bool
aIsHttpOnly
bool
aIsSession
int64_t
aExpiry
OriginAttributes
*
aOriginAttributes
int32_t
aSameSite
)
{
if
(
NS_WARN_IF
(
!
aOriginAttributes
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
IsInitialized
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsAutoCString
host
(
aHost
)
;
nsresult
rv
=
NormalizeHost
(
host
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
baseDomain
;
rv
=
GetBaseDomainFromHost
(
mTLDService
host
baseDomain
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
int64_t
currentTimeInUsec
=
PR_Now
(
)
;
CookieKey
key
=
CookieKey
(
baseDomain
*
aOriginAttributes
)
;
RefPtr
<
Cookie
>
cookie
=
Cookie
:
:
Create
(
aName
aValue
host
aPath
aExpiry
currentTimeInUsec
Cookie
:
:
GenerateUniqueCreationTime
(
currentTimeInUsec
)
aIsSession
aIsSecure
aIsHttpOnly
key
.
mOriginAttributes
aSameSite
aSameSite
)
;
if
(
!
cookie
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
CookieStorage
*
storage
=
PickStorage
(
*
aOriginAttributes
)
;
storage
-
>
AddCookie
(
baseDomain
*
aOriginAttributes
cookie
currentTimeInUsec
nullptr
VoidCString
(
)
true
)
;
return
NS_OK
;
}
nsresult
nsCookieService
:
:
Remove
(
const
nsACString
&
aHost
const
OriginAttributes
&
aAttrs
const
nsACString
&
aName
const
nsACString
&
aPath
)
{
nsAutoCString
host
(
aHost
)
;
nsresult
rv
=
NormalizeHost
(
host
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
baseDomain
;
if
(
!
host
.
IsEmpty
(
)
)
{
rv
=
GetBaseDomainFromHost
(
mTLDService
host
baseDomain
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
!
IsInitialized
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
CookieStorage
*
storage
=
PickStorage
(
aAttrs
)
;
storage
-
>
RemoveCookie
(
baseDomain
aAttrs
host
PromiseFlatCString
(
aName
)
PromiseFlatCString
(
aPath
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsCookieService
:
:
Remove
(
const
nsACString
&
aHost
const
nsACString
&
aName
const
nsACString
&
aPath
JS
:
:
HandleValue
aOriginAttributes
JSContext
*
aCx
)
{
OriginAttributes
attrs
;
if
(
!
aOriginAttributes
.
isObject
(
)
|
|
!
attrs
.
Init
(
aCx
aOriginAttributes
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
return
RemoveNative
(
aHost
aName
aPath
&
attrs
)
;
}
NS_IMETHODIMP_
(
nsresult
)
nsCookieService
:
:
RemoveNative
(
const
nsACString
&
aHost
const
nsACString
&
aName
const
nsACString
&
aPath
OriginAttributes
*
aOriginAttributes
)
{
if
(
NS_WARN_IF
(
!
aOriginAttributes
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
Remove
(
aHost
*
aOriginAttributes
aName
aPath
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
mozilla
:
:
UniquePtr
<
CookieStruct
>
nsCookieService
:
:
GetCookieFromRow
(
mozIStorageStatement
*
aRow
)
{
nsCString
name
value
host
path
;
DebugOnly
<
nsresult
>
rv
=
aRow
-
>
GetUTF8String
(
IDX_NAME
name
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
rv
=
aRow
-
>
GetUTF8String
(
IDX_VALUE
value
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
rv
=
aRow
-
>
GetUTF8String
(
IDX_HOST
host
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
rv
=
aRow
-
>
GetUTF8String
(
IDX_PATH
path
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
int64_t
expiry
=
aRow
-
>
AsInt64
(
IDX_EXPIRY
)
;
int64_t
lastAccessed
=
aRow
-
>
AsInt64
(
IDX_LAST_ACCESSED
)
;
int64_t
creationTime
=
aRow
-
>
AsInt64
(
IDX_CREATION_TIME
)
;
bool
isSecure
=
0
!
=
aRow
-
>
AsInt32
(
IDX_SECURE
)
;
bool
isHttpOnly
=
0
!
=
aRow
-
>
AsInt32
(
IDX_HTTPONLY
)
;
int32_t
sameSite
=
aRow
-
>
AsInt32
(
IDX_SAME_SITE
)
;
int32_t
rawSameSite
=
aRow
-
>
AsInt32
(
IDX_RAW_SAME_SITE
)
;
return
mozilla
:
:
MakeUnique
<
CookieStruct
>
(
name
value
host
path
expiry
lastAccessed
creationTime
isHttpOnly
false
isSecure
sameSite
rawSameSite
)
;
}
void
nsCookieService
:
:
EnsureReadComplete
(
bool
aInitDBConn
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
bool
isAccumulated
=
false
;
if
(
!
mInitializedCookieStorages
)
{
TimeStamp
startBlockTime
=
TimeStamp
:
:
Now
(
)
;
MonitorAutoLock
lock
(
mMonitor
)
;
while
(
!
mInitializedCookieStorages
)
{
mMonitor
.
Wait
(
)
;
}
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
MOZ_SQLITE_COOKIES_BLOCK_MAIN_THREAD_MS_V2
startBlockTime
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
MOZ_SQLITE_COOKIES_TIME_TO_BLOCK_MAIN_THREAD_MS
0
)
;
isAccumulated
=
true
;
}
else
if
(
!
mEndInitDBConn
.
IsNull
(
)
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
MOZ_SQLITE_COOKIES_TIME_TO_BLOCK_MAIN_THREAD_MS
(
TimeStamp
:
:
Now
(
)
-
mEndInitDBConn
)
.
ToMilliseconds
(
)
)
;
mEndInitDBConn
=
TimeStamp
(
)
;
isAccumulated
=
true
;
}
else
if
(
!
mInitializedDBConn
&
&
aInitDBConn
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
MOZ_SQLITE_COOKIES_TIME_TO_BLOCK_MAIN_THREAD_MS
0
)
;
isAccumulated
=
true
;
}
if
(
!
mInitializedDBConn
&
&
aInitDBConn
&
&
mDefaultStorage
)
{
InitDBConn
(
)
;
if
(
isAccumulated
)
{
mEndInitDBConn
=
TimeStamp
(
)
;
}
}
}
OpenDBResult
nsCookieService
:
:
Read
(
)
{
MOZ_ASSERT
(
NS_GetCurrentThread
(
)
=
=
mThread
)
;
nsCOMPtr
<
mozIStorageStatement
>
stmt
;
nsresult
rv
=
mDefaultStorage
-
>
syncConn
-
>
CreateStatement
(
NS_LITERAL_CSTRING
(
"
SELECT
"
"
name
"
"
value
"
"
host
"
"
path
"
"
expiry
"
"
lastAccessed
"
"
creationTime
"
"
isSecure
"
"
isHttpOnly
"
"
originAttributes
"
"
sameSite
"
"
rawSameSite
"
"
FROM
moz_cookies
"
)
getter_AddRefs
(
stmt
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
if
(
NS_WARN_IF
(
!
mReadArray
.
IsEmpty
(
)
)
)
{
mReadArray
.
Clear
(
)
;
}
mReadArray
.
SetCapacity
(
kMaxNumberOfCookies
)
;
nsCString
baseDomain
name
value
host
path
;
bool
hasResult
;
while
(
true
)
{
rv
=
stmt
-
>
ExecuteStep
(
&
hasResult
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
mReadArray
.
Clear
(
)
;
return
RESULT_RETRY
;
}
if
(
!
hasResult
)
break
;
stmt
-
>
GetUTF8String
(
IDX_HOST
host
)
;
rv
=
GetBaseDomainFromHost
(
mTLDService
host
baseDomain
)
;
if
(
NS_FAILED
(
rv
)
)
{
COOKIE_LOGSTRING
(
LogLevel
:
:
Debug
(
"
Read
(
)
:
Ignoring
invalid
host
'
%
s
'
"
host
.
get
(
)
)
)
;
continue
;
}
nsAutoCString
suffix
;
OriginAttributes
attrs
;
stmt
-
>
GetUTF8String
(
IDX_ORIGIN_ATTRIBUTES
suffix
)
;
Unused
<
<
attrs
.
PopulateFromSuffix
(
suffix
)
;
CookieKey
key
(
baseDomain
attrs
)
;
CookieDomainTuple
*
tuple
=
mReadArray
.
AppendElement
(
)
;
tuple
-
>
key
=
std
:
:
move
(
key
)
;
tuple
-
>
originAttributes
=
attrs
;
tuple
-
>
cookie
=
GetCookieFromRow
(
stmt
)
;
}
COOKIE_LOGSTRING
(
LogLevel
:
:
Debug
(
"
Read
(
)
:
%
zu
cookies
read
"
mReadArray
.
Length
(
)
)
)
;
return
RESULT_OK
;
}
NS_IMETHODIMP
nsCookieService
:
:
ImportCookies
(
nsIFile
*
aCookieFile
)
{
if
(
!
IsInitialized
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
EnsureReadComplete
(
true
)
;
return
mDefaultStorage
-
>
ImportCookies
(
aCookieFile
mTLDService
)
;
}
bool
nsCookieService
:
:
DomainMatches
(
Cookie
*
aCookie
const
nsACString
&
aHost
)
{
return
aCookie
-
>
RawHost
(
)
=
=
aHost
|
|
(
aCookie
-
>
IsDomain
(
)
&
&
StringEndsWith
(
aHost
aCookie
-
>
Host
(
)
)
)
;
}
bool
nsCookieService
:
:
PathMatches
(
Cookie
*
aCookie
const
nsACString
&
aPath
)
{
nsCString
cookiePath
(
aCookie
-
>
GetFilePath
(
)
)
;
if
(
cookiePath
.
IsEmpty
(
)
)
return
false
;
if
(
cookiePath
.
Equals
(
aPath
)
)
return
true
;
bool
isPrefix
=
StringBeginsWith
(
aPath
cookiePath
)
;
if
(
isPrefix
&
&
cookiePath
.
Last
(
)
=
=
'
/
'
)
return
true
;
uint32_t
cookiePathLen
=
cookiePath
.
Length
(
)
;
if
(
isPrefix
&
&
aPath
[
cookiePathLen
]
=
=
'
/
'
)
return
true
;
return
false
;
}
void
nsCookieService
:
:
GetCookiesForURI
(
nsIURI
*
aHostURI
nsIChannel
*
aChannel
bool
aIsForeign
bool
aIsThirdPartyTrackingResource
bool
aIsThirdPartySocialTrackingResource
bool
aFirstPartyStorageAccessGranted
uint32_t
aRejectedReason
bool
aIsSafeTopLevelNav
bool
aIsSameSiteForeign
bool
aHttpBound
const
OriginAttributes
&
aOriginAttrs
nsTArray
<
Cookie
*
>
&
aCookieList
)
{
NS_ASSERTION
(
aHostURI
"
null
host
!
"
)
;
if
(
!
IsInitialized
(
)
)
{
return
;
}
CookieStorage
*
storage
=
PickStorage
(
aOriginAttrs
)
;
bool
requireHostMatch
;
nsAutoCString
baseDomain
hostFromURI
pathFromURI
;
nsresult
rv
=
GetBaseDomain
(
mTLDService
aHostURI
baseDomain
requireHostMatch
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
rv
=
aHostURI
-
>
GetAsciiHost
(
hostFromURI
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
rv
=
aHostURI
-
>
GetFilePath
(
pathFromURI
)
;
if
(
NS_FAILED
(
rv
)
)
{
COOKIE_LOGFAILURE
(
GET_COOKIE
aHostURI
VoidCString
(
)
"
invalid
host
/
path
from
URI
"
)
;
return
;
}
nsCOMPtr
<
nsICookieJarSettings
>
cookieJarSettings
=
GetCookieJarSettings
(
aChannel
)
;
nsAutoCString
normalizedHostFromURI
(
hostFromURI
)
;
rv
=
NormalizeHost
(
normalizedHostFromURI
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
nsAutoCString
baseDomainFromURI
;
rv
=
GetBaseDomainFromHost
(
mTLDService
normalizedHostFromURI
baseDomainFromURI
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
uint32_t
rejectedReason
=
aRejectedReason
;
uint32_t
priorCookieCount
=
storage
-
>
CountCookiesFromHost
(
baseDomainFromURI
aOriginAttrs
.
mPrivateBrowsingId
)
;
CookieStatus
cookieStatus
=
CheckPrefs
(
cookieJarSettings
aHostURI
aIsForeign
aIsThirdPartyTrackingResource
aIsThirdPartySocialTrackingResource
aFirstPartyStorageAccessGranted
VoidCString
(
)
priorCookieCount
aOriginAttrs
&
rejectedReason
)
;
MOZ_ASSERT_IF
(
rejectedReason
cookieStatus
=
=
STATUS_REJECTED
)
;
switch
(
cookieStatus
)
{
case
STATUS_REJECTED
:
if
(
priorCookieCount
)
{
NotifyRejected
(
aHostURI
aChannel
rejectedReason
OPERATION_READ
)
;
}
return
;
default
:
break
;
}
bool
potentiallyTurstworthy
=
nsMixedContentBlocker
:
:
IsPotentiallyTrustworthyOrigin
(
aHostURI
)
;
int64_t
currentTimeInUsec
=
PR_Now
(
)
;
int64_t
currentTime
=
currentTimeInUsec
/
PR_USEC_PER_SEC
;
bool
stale
=
false
;
const
nsTArray
<
RefPtr
<
Cookie
>
>
*
cookies
=
storage
-
>
GetCookiesFromHost
(
baseDomain
aOriginAttrs
)
;
if
(
!
cookies
)
return
;
bool
laxByDefault
=
StaticPrefs
:
:
network_cookie_sameSite_laxByDefault
(
)
&
&
!
nsContentUtils
:
:
IsURIInPrefList
(
aHostURI
"
network
.
cookie
.
sameSite
.
laxByDefault
.
disabledHosts
"
)
;
for
(
Cookie
*
cookie
:
*
cookies
)
{
if
(
!
DomainMatches
(
cookie
hostFromURI
)
)
continue
;
if
(
cookie
-
>
IsSecure
(
)
&
&
!
potentiallyTurstworthy
)
continue
;
if
(
aIsSameSiteForeign
&
&
!
ProcessSameSiteCookieForForeignRequest
(
aChannel
cookie
aIsSafeTopLevelNav
laxByDefault
)
)
{
continue
;
}
if
(
cookie
-
>
IsHttpOnly
(
)
&
&
!
aHttpBound
)
continue
;
if
(
!
PathMatches
(
cookie
pathFromURI
)
)
continue
;
if
(
cookie
-
>
Expiry
(
)
<
=
currentTime
)
{
continue
;
}
aCookieList
.
AppendElement
(
cookie
)
;
if
(
cookie
-
>
IsStale
(
)
)
{
stale
=
true
;
}
}
if
(
aCookieList
.
IsEmpty
(
)
)
{
return
;
}
NotifyAccepted
(
aChannel
)
;
if
(
stale
)
{
storage
-
>
StaleCookies
(
aCookieList
currentTimeInUsec
)
;
}
aCookieList
.
Sort
(
CompareCookiesForSending
(
)
)
;
}
void
nsCookieService
:
:
GetCookieStringInternal
(
nsIURI
*
aHostURI
nsIChannel
*
aChannel
bool
aIsForeign
bool
aIsThirdPartyTrackingResource
bool
aIsThirdPartySocialTrackingResource
bool
aFirstPartyStorageAccessGranted
uint32_t
aRejectedReason
bool
aIsSafeTopLevelNav
bool
aIsSameSiteForeign
bool
aHttpBound
const
OriginAttributes
&
aOriginAttrs
nsACString
&
aCookieString
)
{
AutoTArray
<
Cookie
*
8
>
foundCookieList
;
GetCookiesForURI
(
aHostURI
aChannel
aIsForeign
aIsThirdPartyTrackingResource
aIsThirdPartySocialTrackingResource
aFirstPartyStorageAccessGranted
aRejectedReason
aIsSafeTopLevelNav
aIsSameSiteForeign
aHttpBound
aOriginAttrs
foundCookieList
)
;
Cookie
*
cookie
;
for
(
uint32_t
i
=
0
;
i
<
foundCookieList
.
Length
(
)
;
+
+
i
)
{
cookie
=
foundCookieList
.
ElementAt
(
i
)
;
if
(
!
cookie
-
>
Name
(
)
.
IsEmpty
(
)
|
|
!
cookie
-
>
Value
(
)
.
IsEmpty
(
)
)
{
if
(
!
aCookieString
.
IsEmpty
(
)
)
{
aCookieString
.
AppendLiteral
(
"
;
"
)
;
}
if
(
!
cookie
-
>
Name
(
)
.
IsEmpty
(
)
)
{
aCookieString
+
=
cookie
-
>
Name
(
)
+
NS_LITERAL_CSTRING
(
"
=
"
)
+
cookie
-
>
Value
(
)
;
}
else
{
aCookieString
+
=
cookie
-
>
Value
(
)
;
}
}
}
if
(
!
aCookieString
.
IsEmpty
(
)
)
COOKIE_LOGSUCCESS
(
GET_COOKIE
aHostURI
aCookieString
nullptr
false
)
;
}
bool
nsCookieService
:
:
CanSetCookie
(
nsIURI
*
aHostURI
const
nsACString
&
aBaseDomain
CookieStruct
&
aCookieData
bool
aRequireHostMatch
CookieStatus
aStatus
nsCString
&
aCookieHeader
int64_t
aServerTime
bool
aFromHttp
nsIChannel
*
aChannel
bool
&
aSetCookie
mozIThirdPartyUtil
*
aThirdPartyUtil
)
{
NS_ASSERTION
(
aHostURI
"
null
host
!
"
)
;
aSetCookie
=
false
;
aCookieData
.
expiry
(
)
=
INT64_MAX
;
nsCString
savedCookieHeader
(
aCookieHeader
)
;
nsAutoCString
expires
;
nsAutoCString
maxage
;
bool
acceptedByParser
=
false
;
bool
newCookie
=
ParseAttributes
(
aChannel
aHostURI
aCookieHeader
aCookieData
expires
maxage
acceptedByParser
)
;
if
(
!
acceptedByParser
)
{
return
newCookie
;
}
bool
potentiallyTurstworthy
=
nsMixedContentBlocker
:
:
IsPotentiallyTrustworthyOrigin
(
aHostURI
)
;
int64_t
currentTimeInUsec
=
PR_Now
(
)
;
aCookieData
.
isSession
(
)
=
GetExpiry
(
aCookieData
expires
maxage
aServerTime
currentTimeInUsec
/
PR_USEC_PER_SEC
aFromHttp
)
;
if
(
aStatus
=
=
STATUS_ACCEPT_SESSION
)
{
aCookieData
.
isSession
(
)
=
true
;
}
if
(
(
aCookieData
.
name
(
)
.
Length
(
)
+
aCookieData
.
value
(
)
.
Length
(
)
)
>
kMaxBytesPerCookie
)
{
COOKIE_LOGFAILURE
(
SET_COOKIE
aHostURI
savedCookieHeader
"
cookie
too
big
(
>
4kb
)
"
)
;
AutoTArray
<
nsString
2
>
params
=
{
NS_ConvertUTF8toUTF16
(
aCookieData
.
name
(
)
)
}
;
nsString
size
;
size
.
AppendInt
(
kMaxBytesPerCookie
)
;
params
.
AppendElement
(
size
)
;
LogMessageToConsole
(
aChannel
aHostURI
nsIScriptError
:
:
warningFlag
CONSOLE_GENERIC_CATEGORY
NS_LITERAL_CSTRING
(
"
CookieOversize
"
)
params
)
;
return
newCookie
;
}
const
char
illegalNameCharacters
[
]
=
{
0x01
0x02
0x03
0x04
0x05
0x06
0x07
0x08
0x09
0x0A
0x0B
0x0C
0x0D
0x0E
0x0F
0x10
0x11
0x12
0x13
0x14
0x15
0x16
0x17
0x18
0x19
0x1A
0x1B
0x1C
0x1D
0x1E
0x1F
0x00
}
;
if
(
aCookieData
.
name
(
)
.
FindCharInSet
(
illegalNameCharacters
0
)
!
=
-
1
)
{
COOKIE_LOGFAILURE
(
SET_COOKIE
aHostURI
savedCookieHeader
"
invalid
name
character
"
)
;
return
newCookie
;
}
if
(
!
CheckDomain
(
aCookieData
aHostURI
aBaseDomain
aRequireHostMatch
)
)
{
COOKIE_LOGFAILURE
(
SET_COOKIE
aHostURI
savedCookieHeader
"
failed
the
domain
tests
"
)
;
return
newCookie
;
}
if
(
!
CheckPath
(
aCookieData
aChannel
aHostURI
)
)
{
COOKIE_LOGFAILURE
(
SET_COOKIE
aHostURI
savedCookieHeader
"
failed
the
path
tests
"
)
;
return
newCookie
;
}
if
(
!
CheckPrefixes
(
aCookieData
potentiallyTurstworthy
)
)
{
COOKIE_LOGFAILURE
(
SET_COOKIE
aHostURI
savedCookieHeader
"
failed
the
prefix
tests
"
)
;
return
newCookie
;
}
const
char
illegalCharacters
[
]
=
{
0x01
0x02
0x03
0x04
0x05
0x06
0x07
0x08
0x0A
0x0B
0x0C
0x0D
0x0E
0x0F
0x10
0x11
0x12
0x13
0x14
0x15
0x16
0x17
0x18
0x19
0x1A
0x1B
0x1C
0x1D
0x1E
0x1F
0x3B
0x00
}
;
if
(
aFromHttp
&
&
(
aCookieData
.
value
(
)
.
FindCharInSet
(
illegalCharacters
0
)
!
=
-
1
)
)
{
COOKIE_LOGFAILURE
(
SET_COOKIE
aHostURI
savedCookieHeader
"
invalid
value
character
"
)
;
return
newCookie
;
}
if
(
!
aFromHttp
&
&
aCookieData
.
isHttpOnly
(
)
)
{
COOKIE_LOGFAILURE
(
SET_COOKIE
aHostURI
savedCookieHeader
"
cookie
is
httponly
;
coming
from
script
"
)
;
return
newCookie
;
}
if
(
aCookieData
.
isSecure
(
)
&
&
!
potentiallyTurstworthy
)
{
COOKIE_LOGFAILURE
(
SET_COOKIE
aHostURI
aCookieHeader
"
non
-
https
cookie
can
'
t
set
secure
flag
"
)
;
return
newCookie
;
}
if
(
(
aCookieData
.
sameSite
(
)
!
=
nsICookie
:
:
SAMESITE_NONE
)
&
&
aThirdPartyUtil
)
{
bool
addonAllowsLoad
=
false
;
if
(
aChannel
)
{
nsCOMPtr
<
nsIURI
>
channelURI
;
NS_GetFinalChannelURI
(
aChannel
getter_AddRefs
(
channelURI
)
)
;
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
aChannel
-
>
LoadInfo
(
)
;
addonAllowsLoad
=
BasePrincipal
:
:
Cast
(
loadInfo
-
>
TriggeringPrincipal
(
)
)
-
>
AddonAllowsLoad
(
channelURI
)
;
}
if
(
!
addonAllowsLoad
)
{
bool
isThirdParty
=
false
;
nsresult
rv
=
aThirdPartyUtil
-
>
IsThirdPartyChannel
(
aChannel
aHostURI
&
isThirdParty
)
;
if
(
NS_FAILED
(
rv
)
|
|
isThirdParty
)
{
COOKIE_LOGFAILURE
(
SET_COOKIE
aHostURI
savedCookieHeader
"
failed
the
samesite
tests
"
)
;
return
newCookie
;
}
}
}
aSetCookie
=
true
;
return
newCookie
;
}
bool
nsCookieService
:
:
SetCookieInternal
(
CookieStorage
*
aStorage
nsIURI
*
aHostURI
const
nsACString
&
aBaseDomain
const
OriginAttributes
&
aOriginAttributes
bool
aRequireHostMatch
CookieStatus
aStatus
nsCString
&
aCookieHeader
int64_t
aServerTime
bool
aFromHttp
nsIChannel
*
aChannel
)
{
NS_ASSERTION
(
aHostURI
"
null
host
!
"
)
;
bool
canSetCookie
=
false
;
nsCString
savedCookieHeader
(
aCookieHeader
)
;
CookieStruct
cookieData
;
bool
newCookie
=
CanSetCookie
(
aHostURI
aBaseDomain
cookieData
aRequireHostMatch
aStatus
aCookieHeader
aServerTime
aFromHttp
aChannel
canSetCookie
mThirdPartyUtil
)
;
if
(
!
canSetCookie
)
{
return
newCookie
;
}
int64_t
currentTimeInUsec
=
PR_Now
(
)
;
RefPtr
<
Cookie
>
cookie
=
Cookie
:
:
Create
(
cookieData
.
name
(
)
cookieData
.
value
(
)
cookieData
.
host
(
)
cookieData
.
path
(
)
cookieData
.
expiry
(
)
currentTimeInUsec
Cookie
:
:
GenerateUniqueCreationTime
(
currentTimeInUsec
)
cookieData
.
isSession
(
)
cookieData
.
isSecure
(
)
cookieData
.
isHttpOnly
(
)
aOriginAttributes
cookieData
.
sameSite
(
)
cookieData
.
rawSameSite
(
)
)
;
if
(
!
cookie
)
return
newCookie
;
if
(
mPermissionService
)
{
bool
permission
;
mPermissionService
-
>
CanSetCookie
(
aHostURI
aChannel
static_cast
<
nsICookie
*
>
(
static_cast
<
Cookie
*
>
(
cookie
)
)
&
cookieData
.
isSession
(
)
&
cookieData
.
expiry
(
)
&
permission
)
;
if
(
!
permission
)
{
COOKIE_LOGFAILURE
(
SET_COOKIE
aHostURI
savedCookieHeader
"
cookie
rejected
by
permission
manager
"
)
;
NotifyRejected
(
aHostURI
aChannel
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_BY_PERMISSION
OPERATION_WRITE
)
;
return
newCookie
;
}
cookie
-
>
SetIsSession
(
cookieData
.
isSession
(
)
)
;
cookie
-
>
SetExpiry
(
cookieData
.
expiry
(
)
)
;
}
aStorage
-
>
AddCookie
(
aBaseDomain
aOriginAttributes
cookie
PR_Now
(
)
aHostURI
savedCookieHeader
aFromHttp
)
;
return
newCookie
;
}
static
inline
bool
isnull
(
char
c
)
{
return
c
=
=
0
;
}
static
inline
bool
iswhitespace
(
char
c
)
{
return
c
=
=
'
'
|
|
c
=
=
'
\
t
'
;
}
static
inline
bool
isterminator
(
char
c
)
{
return
c
=
=
'
\
n
'
|
|
c
=
=
'
\
r
'
;
}
static
inline
bool
isvalueseparator
(
char
c
)
{
return
isterminator
(
c
)
|
|
c
=
=
'
;
'
;
}
static
inline
bool
istokenseparator
(
char
c
)
{
return
isvalueseparator
(
c
)
|
|
c
=
=
'
=
'
;
}
bool
nsCookieService
:
:
GetTokenValue
(
nsACString
:
:
const_char_iterator
&
aIter
nsACString
:
:
const_char_iterator
&
aEndIter
nsDependentCSubstring
&
aTokenString
nsDependentCSubstring
&
aTokenValue
bool
&
aEqualsFound
)
{
nsACString
:
:
const_char_iterator
start
lastSpace
;
aTokenValue
.
Rebind
(
aIter
aIter
)
;
while
(
aIter
!
=
aEndIter
&
&
iswhitespace
(
*
aIter
)
)
+
+
aIter
;
start
=
aIter
;
while
(
aIter
!
=
aEndIter
&
&
!
isnull
(
*
aIter
)
&
&
!
istokenseparator
(
*
aIter
)
)
+
+
aIter
;
lastSpace
=
aIter
;
if
(
lastSpace
!
=
start
)
{
while
(
-
-
lastSpace
!
=
start
&
&
iswhitespace
(
*
lastSpace
)
)
continue
;
+
+
lastSpace
;
}
aTokenString
.
Rebind
(
start
lastSpace
)
;
aEqualsFound
=
(
*
aIter
=
=
'
=
'
)
;
if
(
aEqualsFound
)
{
while
(
+
+
aIter
!
=
aEndIter
&
&
iswhitespace
(
*
aIter
)
)
continue
;
start
=
aIter
;
while
(
aIter
!
=
aEndIter
&
&
!
isnull
(
*
aIter
)
&
&
!
isvalueseparator
(
*
aIter
)
)
+
+
aIter
;
if
(
aIter
!
=
start
)
{
lastSpace
=
aIter
;
while
(
-
-
lastSpace
!
=
start
&
&
iswhitespace
(
*
lastSpace
)
)
continue
;
aTokenValue
.
Rebind
(
start
+
+
lastSpace
)
;
}
}
if
(
aIter
!
=
aEndIter
)
{
if
(
isterminator
(
*
aIter
)
)
{
+
+
aIter
;
return
true
;
}
+
+
aIter
;
}
return
false
;
}
bool
nsCookieService
:
:
ParseAttributes
(
nsIChannel
*
aChannel
nsIURI
*
aHostURI
nsCString
&
aCookieHeader
mozilla
:
:
net
:
:
CookieStruct
&
aCookieData
nsACString
&
aExpires
nsACString
&
aMaxage
bool
&
aAcceptedByParser
)
{
aAcceptedByParser
=
false
;
static
const
char
kPath
[
]
=
"
path
"
;
static
const
char
kDomain
[
]
=
"
domain
"
;
static
const
char
kExpires
[
]
=
"
expires
"
;
static
const
char
kMaxage
[
]
=
"
max
-
age
"
;
static
const
char
kSecure
[
]
=
"
secure
"
;
static
const
char
kHttpOnly
[
]
=
"
httponly
"
;
static
const
char
kSameSite
[
]
=
"
samesite
"
;
static
const
char
kSameSiteLax
[
]
=
"
lax
"
;
static
const
char
kSameSiteNone
[
]
=
"
none
"
;
static
const
char
kSameSiteStrict
[
]
=
"
strict
"
;
nsACString
:
:
const_char_iterator
tempBegin
tempEnd
;
nsACString
:
:
const_char_iterator
cookieStart
cookieEnd
;
aCookieHeader
.
BeginReading
(
cookieStart
)
;
aCookieHeader
.
EndReading
(
cookieEnd
)
;
aCookieData
.
isSecure
(
)
=
false
;
aCookieData
.
isHttpOnly
(
)
=
false
;
aCookieData
.
sameSite
(
)
=
nsICookie
:
:
SAMESITE_NONE
;
aCookieData
.
rawSameSite
(
)
=
nsICookie
:
:
SAMESITE_NONE
;
bool
laxByDefault
=
StaticPrefs
:
:
network_cookie_sameSite_laxByDefault
(
)
&
&
!
nsContentUtils
:
:
IsURIInPrefList
(
aHostURI
"
network
.
cookie
.
sameSite
.
laxByDefault
.
disabledHosts
"
)
;
if
(
laxByDefault
)
{
aCookieData
.
sameSite
(
)
=
nsICookie
:
:
SAMESITE_LAX
;
}
nsDependentCSubstring
tokenString
(
cookieStart
cookieStart
)
;
nsDependentCSubstring
tokenValue
(
cookieStart
cookieStart
)
;
bool
newCookie
equalsFound
;
newCookie
=
GetTokenValue
(
cookieStart
cookieEnd
tokenString
tokenValue
equalsFound
)
;
if
(
equalsFound
)
{
aCookieData
.
name
(
)
=
tokenString
;
aCookieData
.
value
(
)
=
tokenValue
;
}
else
{
aCookieData
.
value
(
)
=
tokenString
;
}
bool
sameSiteSet
=
false
;
while
(
cookieStart
!
=
cookieEnd
&
&
!
newCookie
)
{
newCookie
=
GetTokenValue
(
cookieStart
cookieEnd
tokenString
tokenValue
equalsFound
)
;
if
(
!
tokenValue
.
IsEmpty
(
)
)
{
tokenValue
.
BeginReading
(
tempBegin
)
;
tokenValue
.
EndReading
(
tempEnd
)
;
}
if
(
tokenString
.
LowerCaseEqualsLiteral
(
kPath
)
)
aCookieData
.
path
(
)
=
tokenValue
;
else
if
(
tokenString
.
LowerCaseEqualsLiteral
(
kDomain
)
)
aCookieData
.
host
(
)
=
tokenValue
;
else
if
(
tokenString
.
LowerCaseEqualsLiteral
(
kExpires
)
)
aExpires
=
tokenValue
;
else
if
(
tokenString
.
LowerCaseEqualsLiteral
(
kMaxage
)
)
aMaxage
=
tokenValue
;
else
if
(
tokenString
.
LowerCaseEqualsLiteral
(
kSecure
)
)
aCookieData
.
isSecure
(
)
=
true
;
else
if
(
tokenString
.
LowerCaseEqualsLiteral
(
kHttpOnly
)
)
aCookieData
.
isHttpOnly
(
)
=
true
;
else
if
(
tokenString
.
LowerCaseEqualsLiteral
(
kSameSite
)
)
{
if
(
tokenValue
.
LowerCaseEqualsLiteral
(
kSameSiteLax
)
)
{
aCookieData
.
sameSite
(
)
=
nsICookie
:
:
SAMESITE_LAX
;
aCookieData
.
rawSameSite
(
)
=
nsICookie
:
:
SAMESITE_LAX
;
sameSiteSet
=
true
;
}
else
if
(
tokenValue
.
LowerCaseEqualsLiteral
(
kSameSiteStrict
)
)
{
aCookieData
.
sameSite
(
)
=
nsICookie
:
:
SAMESITE_STRICT
;
aCookieData
.
rawSameSite
(
)
=
nsICookie
:
:
SAMESITE_STRICT
;
sameSiteSet
=
true
;
}
else
if
(
tokenValue
.
LowerCaseEqualsLiteral
(
kSameSiteNone
)
)
{
aCookieData
.
sameSite
(
)
=
nsICookie
:
:
SAMESITE_NONE
;
aCookieData
.
rawSameSite
(
)
=
nsICookie
:
:
SAMESITE_NONE
;
sameSiteSet
=
true
;
}
else
{
LogMessageToConsole
(
aChannel
aHostURI
nsIScriptError
:
:
infoFlag
CONSOLE_GENERIC_CATEGORY
NS_LITERAL_CSTRING
(
"
CookieSameSiteValueInvalid
"
)
AutoTArray
<
nsString
1
>
{
NS_ConvertUTF8toUTF16
(
aCookieData
.
name
(
)
)
}
)
;
}
}
}
Telemetry
:
:
Accumulate
(
Telemetry
:
:
COOKIE_SAMESITE_SET_VS_UNSET
sameSiteSet
?
1
:
0
)
;
aCookieHeader
.
Assign
(
Substring
(
cookieStart
cookieEnd
)
)
;
if
(
!
aCookieData
.
isSecure
(
)
&
&
aCookieData
.
sameSite
(
)
=
=
nsICookie
:
:
SAMESITE_NONE
)
{
if
(
laxByDefault
&
&
StaticPrefs
:
:
network_cookie_sameSite_noneRequiresSecure
(
)
)
{
LogMessageToConsole
(
aChannel
aHostURI
nsIScriptError
:
:
infoFlag
CONSOLE_SAMESITE_CATEGORY
NS_LITERAL_CSTRING
(
"
CookieRejectedNonRequiresSecure
"
)
AutoTArray
<
nsString
1
>
{
NS_ConvertUTF8toUTF16
(
aCookieData
.
name
(
)
)
}
)
;
return
newCookie
;
}
LogMessageToConsole
(
aChannel
aHostURI
nsIScriptError
:
:
warningFlag
CONSOLE_SAMESITE_CATEGORY
NS_LITERAL_CSTRING
(
"
CookieRejectedNonRequiresSecureForBeta
"
)
AutoTArray
<
nsString
2
>
{
NS_ConvertUTF8toUTF16
(
aCookieData
.
name
(
)
)
SAMESITE_MDN_URL
}
)
;
}
if
(
aCookieData
.
rawSameSite
(
)
=
=
nsICookie
:
:
SAMESITE_NONE
&
&
aCookieData
.
sameSite
(
)
=
=
nsICookie
:
:
SAMESITE_LAX
)
{
if
(
laxByDefault
)
{
LogMessageToConsole
(
aChannel
aHostURI
nsIScriptError
:
:
infoFlag
CONSOLE_SAMESITE_CATEGORY
NS_LITERAL_CSTRING
(
"
CookieLaxForced
"
)
AutoTArray
<
nsString
1
>
{
NS_ConvertUTF8toUTF16
(
aCookieData
.
name
(
)
)
}
)
;
}
else
{
LogMessageToConsole
(
aChannel
aHostURI
nsIScriptError
:
:
warningFlag
CONSOLE_SAMESITE_CATEGORY
NS_LITERAL_CSTRING
(
"
CookieLaxForcedForBeta
"
)
AutoTArray
<
nsString
2
>
{
NS_ConvertUTF8toUTF16
(
aCookieData
.
name
(
)
)
SAMESITE_MDN_URL
}
)
;
}
}
aAcceptedByParser
=
true
;
MOZ_ASSERT
(
Cookie
:
:
ValidateRawSame
(
aCookieData
)
)
;
return
newCookie
;
}
void
nsCookieService
:
:
LogMessageToConsole
(
nsIChannel
*
aChannel
nsIURI
*
aURI
uint32_t
aErrorFlags
const
nsACString
&
aCategory
const
nsACString
&
aMsg
const
nsTArray
<
nsString
>
&
aParams
)
{
MOZ_ASSERT
(
aURI
)
;
nsCOMPtr
<
HttpBaseChannel
>
httpChannel
=
do_QueryInterface
(
aChannel
)
;
if
(
!
httpChannel
)
{
return
;
}
nsAutoCString
uri
;
nsresult
rv
=
aURI
-
>
GetSpec
(
uri
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
httpChannel
-
>
AddConsoleReport
(
aErrorFlags
aCategory
nsContentUtils
:
:
eNECKO_PROPERTIES
uri
0
0
aMsg
aParams
)
;
}
nsresult
nsCookieService
:
:
GetBaseDomain
(
nsIEffectiveTLDService
*
aTLDService
nsIURI
*
aHostURI
nsCString
&
aBaseDomain
bool
&
aRequireHostMatch
)
{
nsresult
rv
=
aTLDService
-
>
GetBaseDomain
(
aHostURI
0
aBaseDomain
)
;
aRequireHostMatch
=
rv
=
=
NS_ERROR_HOST_IS_IP_ADDRESS
|
|
rv
=
=
NS_ERROR_INSUFFICIENT_DOMAIN_LEVELS
;
if
(
aRequireHostMatch
)
{
rv
=
aHostURI
-
>
GetAsciiHost
(
aBaseDomain
)
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
aBaseDomain
.
Length
(
)
=
=
1
&
&
aBaseDomain
.
Last
(
)
=
=
'
.
'
)
return
NS_ERROR_INVALID_ARG
;
if
(
aBaseDomain
.
IsEmpty
(
)
&
&
!
aHostURI
-
>
SchemeIs
(
"
file
"
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
return
NS_OK
;
}
nsresult
nsCookieService
:
:
GetBaseDomainFromHost
(
nsIEffectiveTLDService
*
aTLDService
const
nsACString
&
aHost
nsCString
&
aBaseDomain
)
{
if
(
aHost
.
Length
(
)
=
=
1
&
&
aHost
.
Last
(
)
=
=
'
.
'
)
return
NS_ERROR_INVALID_ARG
;
bool
domain
=
!
aHost
.
IsEmpty
(
)
&
&
aHost
.
First
(
)
=
=
'
.
'
;
nsresult
rv
=
aTLDService
-
>
GetBaseDomainFromHost
(
Substring
(
aHost
domain
)
0
aBaseDomain
)
;
if
(
rv
=
=
NS_ERROR_HOST_IS_IP_ADDRESS
|
|
rv
=
=
NS_ERROR_INSUFFICIENT_DOMAIN_LEVELS
)
{
if
(
domain
)
return
NS_ERROR_INVALID_ARG
;
aBaseDomain
=
aHost
;
return
NS_OK
;
}
return
rv
;
}
nsresult
nsCookieService
:
:
NormalizeHost
(
nsCString
&
aHost
)
{
if
(
!
IsAscii
(
aHost
)
)
{
nsAutoCString
host
;
nsresult
rv
=
mIDNService
-
>
ConvertUTF8toACE
(
aHost
host
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
aHost
=
host
;
}
ToLowerCase
(
aHost
)
;
return
NS_OK
;
}
static
inline
bool
IsSubdomainOf
(
const
nsACString
&
a
const
nsACString
&
b
)
{
if
(
a
=
=
b
)
return
true
;
if
(
a
.
Length
(
)
>
b
.
Length
(
)
)
return
a
[
a
.
Length
(
)
-
b
.
Length
(
)
-
1
]
=
=
'
.
'
&
&
StringEndsWith
(
a
b
)
;
return
false
;
}
CookieStatus
nsCookieService
:
:
CheckPrefs
(
nsICookieJarSettings
*
aCookieJarSettings
nsIURI
*
aHostURI
bool
aIsForeign
bool
aIsThirdPartyTrackingResource
bool
aIsThirdPartySocialTrackingResource
bool
aFirstPartyStorageAccessGranted
const
nsACString
&
aCookieHeader
const
int
aNumOfCookies
const
OriginAttributes
&
aOriginAttrs
uint32_t
*
aRejectedReason
)
{
nsresult
rv
;
MOZ_ASSERT
(
aRejectedReason
)
;
*
aRejectedReason
=
0
;
if
(
aHostURI
-
>
SchemeIs
(
"
ftp
"
)
)
{
COOKIE_LOGFAILURE
(
aCookieHeader
.
IsVoid
(
)
?
GET_COOKIE
:
SET_COOKIE
aHostURI
aCookieHeader
"
ftp
sites
cannot
read
cookies
"
)
;
return
STATUS_REJECTED_WITH_ERROR
;
}
nsCOMPtr
<
nsIPrincipal
>
principal
=
BasePrincipal
:
:
CreateContentPrincipal
(
aHostURI
aOriginAttrs
)
;
if
(
!
principal
)
{
COOKIE_LOGFAILURE
(
aCookieHeader
.
IsVoid
(
)
?
GET_COOKIE
:
SET_COOKIE
aHostURI
aCookieHeader
"
non
-
content
principals
cannot
get
/
set
cookies
"
)
;
return
STATUS_REJECTED_WITH_ERROR
;
}
uint32_t
cookiePermission
=
nsICookiePermission
:
:
ACCESS_DEFAULT
;
rv
=
aCookieJarSettings
-
>
CookiePermission
(
principal
&
cookiePermission
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
switch
(
cookiePermission
)
{
case
nsICookiePermission
:
:
ACCESS_DENY
:
COOKIE_LOGFAILURE
(
aCookieHeader
.
IsVoid
(
)
?
GET_COOKIE
:
SET_COOKIE
aHostURI
aCookieHeader
"
cookies
are
blocked
for
this
site
"
)
;
*
aRejectedReason
=
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_BY_PERMISSION
;
return
STATUS_REJECTED
;
case
nsICookiePermission
:
:
ACCESS_ALLOW
:
return
STATUS_ACCEPTED
;
}
}
if
(
aIsForeign
&
&
aIsThirdPartyTrackingResource
&
&
!
aFirstPartyStorageAccessGranted
&
&
aCookieJarSettings
-
>
GetRejectThirdPartyContexts
(
)
)
{
bool
rejectThirdPartyWithExceptions
=
CookieJarSettings
:
:
IsRejectThirdPartyWithExceptions
(
aCookieJarSettings
-
>
GetCookieBehavior
(
)
)
;
uint32_t
rejectReason
=
rejectThirdPartyWithExceptions
?
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_FOREIGN
:
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_TRACKER
;
if
(
StoragePartitioningEnabled
(
rejectReason
aCookieJarSettings
)
)
{
MOZ_ASSERT
(
!
aOriginAttrs
.
mFirstPartyDomain
.
IsEmpty
(
)
"
We
must
have
a
StoragePrincipal
here
!
"
)
;
return
STATUS_ACCEPTED
;
}
COOKIE_LOGFAILURE
(
aCookieHeader
.
IsVoid
(
)
?
GET_COOKIE
:
SET_COOKIE
aHostURI
aCookieHeader
"
cookies
are
disabled
in
trackers
"
)
;
if
(
aIsThirdPartySocialTrackingResource
)
{
*
aRejectedReason
=
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_SOCIALTRACKER
;
}
else
if
(
rejectThirdPartyWithExceptions
)
{
*
aRejectedReason
=
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_FOREIGN
;
}
else
{
*
aRejectedReason
=
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_TRACKER
;
}
return
STATUS_REJECTED
;
}
if
(
aCookieJarSettings
-
>
GetCookieBehavior
(
)
=
=
nsICookieService
:
:
BEHAVIOR_REJECT
&
&
!
aFirstPartyStorageAccessGranted
)
{
COOKIE_LOGFAILURE
(
aCookieHeader
.
IsVoid
(
)
?
GET_COOKIE
:
SET_COOKIE
aHostURI
aCookieHeader
"
cookies
are
disabled
"
)
;
*
aRejectedReason
=
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_ALL
;
return
STATUS_REJECTED
;
}
if
(
aIsForeign
)
{
if
(
aCookieJarSettings
-
>
GetCookieBehavior
(
)
=
=
nsICookieService
:
:
BEHAVIOR_REJECT_FOREIGN
&
&
!
aFirstPartyStorageAccessGranted
)
{
COOKIE_LOGFAILURE
(
aCookieHeader
.
IsVoid
(
)
?
GET_COOKIE
:
SET_COOKIE
aHostURI
aCookieHeader
"
context
is
third
party
"
)
;
*
aRejectedReason
=
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_FOREIGN
;
return
STATUS_REJECTED
;
}
if
(
aCookieJarSettings
-
>
GetLimitForeignContexts
(
)
&
&
!
aFirstPartyStorageAccessGranted
&
&
aNumOfCookies
=
=
0
)
{
COOKIE_LOGFAILURE
(
aCookieHeader
.
IsVoid
(
)
?
GET_COOKIE
:
SET_COOKIE
aHostURI
aCookieHeader
"
context
is
third
party
"
)
;
*
aRejectedReason
=
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_FOREIGN
;
return
STATUS_REJECTED
;
}
if
(
StaticPrefs
:
:
network_cookie_thirdparty_sessionOnly
(
)
)
{
return
STATUS_ACCEPT_SESSION
;
}
if
(
StaticPrefs
:
:
network_cookie_thirdparty_nonsecureSessionOnly
(
)
)
{
if
(
!
aHostURI
-
>
SchemeIs
(
"
https
"
)
)
{
return
STATUS_ACCEPT_SESSION
;
}
}
}
return
STATUS_ACCEPTED
;
}
bool
nsCookieService
:
:
CheckDomain
(
CookieStruct
&
aCookieData
nsIURI
*
aHostURI
const
nsACString
&
aBaseDomain
bool
aRequireHostMatch
)
{
nsAutoCString
hostFromURI
;
aHostURI
-
>
GetAsciiHost
(
hostFromURI
)
;
if
(
!
aCookieData
.
host
(
)
.
IsEmpty
(
)
)
{
if
(
aCookieData
.
host
(
)
.
Length
(
)
>
1
&
&
aCookieData
.
host
(
)
.
First
(
)
=
=
'
.
'
)
{
aCookieData
.
host
(
)
.
Cut
(
0
1
)
;
}
ToLowerCase
(
aCookieData
.
host
(
)
)
;
if
(
aRequireHostMatch
)
return
hostFromURI
.
Equals
(
aCookieData
.
host
(
)
)
;
if
(
IsSubdomainOf
(
aCookieData
.
host
(
)
aBaseDomain
)
&
&
IsSubdomainOf
(
hostFromURI
aCookieData
.
host
(
)
)
)
{
aCookieData
.
host
(
)
.
InsertLiteral
(
"
.
"
0
)
;
return
true
;
}
return
false
;
}
aCookieData
.
host
(
)
=
hostFromURI
;
return
true
;
}
nsAutoCString
nsCookieService
:
:
GetPathFromURI
(
nsIURI
*
aHostURI
)
{
nsAutoCString
path
;
nsCOMPtr
<
nsIURL
>
hostURL
=
do_QueryInterface
(
aHostURI
)
;
if
(
hostURL
)
{
hostURL
-
>
GetDirectory
(
path
)
;
}
else
{
aHostURI
-
>
GetPathQueryRef
(
path
)
;
int32_t
slash
=
path
.
RFindChar
(
'
/
'
)
;
if
(
slash
!
=
kNotFound
)
{
path
.
Truncate
(
slash
+
1
)
;
}
}
int32_t
lastSlash
=
path
.
RFindChar
(
'
/
'
)
;
int32_t
firstSlash
=
path
.
FindChar
(
'
/
'
)
;
if
(
lastSlash
!
=
firstSlash
&
&
lastSlash
!
=
kNotFound
&
&
lastSlash
=
=
(
int32_t
)
(
path
.
Length
(
)
-
1
)
)
{
path
.
Truncate
(
lastSlash
)
;
}
return
path
;
}
bool
nsCookieService
:
:
CheckPath
(
CookieStruct
&
aCookieData
nsIChannel
*
aChannel
nsIURI
*
aHostURI
)
{
if
(
aCookieData
.
path
(
)
.
IsEmpty
(
)
|
|
aCookieData
.
path
(
)
.
First
(
)
!
=
'
/
'
)
{
aCookieData
.
path
(
)
=
GetPathFromURI
(
aHostURI
)
;
#
if
0
}
else
{
nsAutoCString
pathFromURI
;
if
(
NS_FAILED
(
aHostURI
-
>
GetPathQueryRef
(
pathFromURI
)
)
|
|
!
StringBeginsWith
(
pathFromURI
aCookieData
.
path
(
)
)
)
{
return
false
;
}
#
endif
}
if
(
aCookieData
.
path
(
)
.
Length
(
)
>
kMaxBytesPerPath
)
{
AutoTArray
<
nsString
2
>
params
=
{
NS_ConvertUTF8toUTF16
(
aCookieData
.
name
(
)
)
}
;
nsString
size
;
size
.
AppendInt
(
kMaxBytesPerPath
)
;
params
.
AppendElement
(
size
)
;
LogMessageToConsole
(
aChannel
aHostURI
nsIScriptError
:
:
warningFlag
CONSOLE_GENERIC_CATEGORY
NS_LITERAL_CSTRING
(
"
CookiePathOversize
"
)
params
)
;
return
false
;
}
if
(
aCookieData
.
path
(
)
.
Contains
(
'
\
t
'
)
)
{
return
false
;
}
return
true
;
}
bool
nsCookieService
:
:
CheckPrefixes
(
CookieStruct
&
aCookieData
bool
aSecureRequest
)
{
static
const
char
kSecure
[
]
=
"
__Secure
-
"
;
static
const
char
kHost
[
]
=
"
__Host
-
"
;
static
const
int
kSecureLen
=
sizeof
(
kSecure
)
-
1
;
static
const
int
kHostLen
=
sizeof
(
kHost
)
-
1
;
bool
isSecure
=
strncmp
(
aCookieData
.
name
(
)
.
get
(
)
kSecure
kSecureLen
)
=
=
0
;
bool
isHost
=
strncmp
(
aCookieData
.
name
(
)
.
get
(
)
kHost
kHostLen
)
=
=
0
;
if
(
!
isSecure
&
&
!
isHost
)
{
return
true
;
}
if
(
!
aSecureRequest
|
|
!
aCookieData
.
isSecure
(
)
)
{
return
false
;
}
if
(
isHost
)
{
if
(
aCookieData
.
host
(
)
[
0
]
=
=
'
.
'
|
|
!
aCookieData
.
path
(
)
.
EqualsLiteral
(
"
/
"
)
)
{
return
false
;
}
}
return
true
;
}
bool
nsCookieService
:
:
GetExpiry
(
CookieStruct
&
aCookieData
const
nsACString
&
aExpires
const
nsACString
&
aMaxage
int64_t
aServerTime
int64_t
aCurrentTime
bool
aFromHttp
)
{
int64_t
maxageCap
=
aFromHttp
?
0
:
StaticPrefs
:
:
privacy_documentCookies_maxage
(
)
;
if
(
!
aMaxage
.
IsEmpty
(
)
)
{
int64_t
maxage
;
int32_t
numInts
=
PR_sscanf
(
aMaxage
.
BeginReading
(
)
"
%
lld
"
&
maxage
)
;
if
(
numInts
!
=
1
)
{
return
true
;
}
if
(
maxageCap
)
{
aCookieData
.
expiry
(
)
=
aCurrentTime
+
std
:
:
min
(
maxage
maxageCap
)
;
}
else
{
aCookieData
.
expiry
(
)
=
aCurrentTime
+
maxage
;
}
}
else
if
(
!
aExpires
.
IsEmpty
(
)
)
{
PRTime
expires
;
if
(
PR_ParseTimeString
(
aExpires
.
BeginReading
(
)
true
&
expires
)
!
=
PR_SUCCESS
)
{
return
true
;
}
if
(
maxageCap
)
{
aCookieData
.
expiry
(
)
=
std
:
:
min
(
expires
/
int64_t
(
PR_USEC_PER_SEC
)
aCurrentTime
+
maxageCap
)
;
}
else
{
aCookieData
.
expiry
(
)
=
expires
/
int64_t
(
PR_USEC_PER_SEC
)
;
}
}
else
{
return
true
;
}
return
false
;
}
NS_IMETHODIMP
nsCookieService
:
:
CookieExists
(
const
nsACString
&
aHost
const
nsACString
&
aPath
const
nsACString
&
aName
JS
:
:
HandleValue
aOriginAttributes
JSContext
*
aCx
bool
*
aFoundCookie
)
{
NS_ENSURE_ARG_POINTER
(
aCx
)
;
NS_ENSURE_ARG_POINTER
(
aFoundCookie
)
;
OriginAttributes
attrs
;
if
(
!
aOriginAttributes
.
isObject
(
)
|
|
!
attrs
.
Init
(
aCx
aOriginAttributes
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
return
CookieExistsNative
(
aHost
aPath
aName
&
attrs
aFoundCookie
)
;
}
NS_IMETHODIMP_
(
nsresult
)
nsCookieService
:
:
CookieExistsNative
(
const
nsACString
&
aHost
const
nsACString
&
aPath
const
nsACString
&
aName
OriginAttributes
*
aOriginAttributes
bool
*
aFoundCookie
)
{
NS_ENSURE_ARG_POINTER
(
aOriginAttributes
)
;
NS_ENSURE_ARG_POINTER
(
aFoundCookie
)
;
if
(
!
IsInitialized
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsAutoCString
baseDomain
;
nsresult
rv
=
GetBaseDomainFromHost
(
mTLDService
aHost
baseDomain
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
CookieListIter
iter
;
CookieStorage
*
storage
=
PickStorage
(
*
aOriginAttributes
)
;
*
aFoundCookie
=
storage
-
>
FindCookie
(
baseDomain
*
aOriginAttributes
aHost
aName
aPath
iter
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsCookieService
:
:
CountCookiesFromHost
(
const
nsACString
&
aHost
uint32_t
*
aCountFromHost
)
{
nsAutoCString
host
(
aHost
)
;
nsresult
rv
=
NormalizeHost
(
host
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
baseDomain
;
rv
=
GetBaseDomainFromHost
(
mTLDService
host
baseDomain
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
IsInitialized
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
EnsureReadComplete
(
true
)
;
*
aCountFromHost
=
mDefaultStorage
-
>
CountCookiesFromHost
(
baseDomain
0
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsCookieService
:
:
GetCookiesFromHost
(
const
nsACString
&
aHost
JS
:
:
HandleValue
aOriginAttributes
JSContext
*
aCx
nsTArray
<
RefPtr
<
nsICookie
>
>
&
aResult
)
{
nsAutoCString
host
(
aHost
)
;
nsresult
rv
=
NormalizeHost
(
host
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
baseDomain
;
rv
=
GetBaseDomainFromHost
(
mTLDService
host
baseDomain
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
OriginAttributes
attrs
;
if
(
!
aOriginAttributes
.
isObject
(
)
|
|
!
attrs
.
Init
(
aCx
aOriginAttributes
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
!
IsInitialized
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
CookieStorage
*
storage
=
PickStorage
(
attrs
)
;
const
nsTArray
<
RefPtr
<
Cookie
>
>
*
cookies
=
storage
-
>
GetCookiesFromHost
(
baseDomain
attrs
)
;
if
(
cookies
)
{
aResult
.
SetCapacity
(
cookies
-
>
Length
(
)
)
;
for
(
Cookie
*
cookie
:
*
cookies
)
{
aResult
.
AppendElement
(
cookie
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsCookieService
:
:
GetCookiesWithOriginAttributes
(
const
nsAString
&
aPattern
const
nsACString
&
aHost
nsTArray
<
RefPtr
<
nsICookie
>
>
&
aResult
)
{
mozilla
:
:
OriginAttributesPattern
pattern
;
if
(
!
pattern
.
Init
(
aPattern
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsAutoCString
host
(
aHost
)
;
nsresult
rv
=
NormalizeHost
(
host
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
baseDomain
;
rv
=
GetBaseDomainFromHost
(
mTLDService
host
baseDomain
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
GetCookiesWithOriginAttributes
(
pattern
baseDomain
aResult
)
;
}
nsresult
nsCookieService
:
:
GetCookiesWithOriginAttributes
(
const
mozilla
:
:
OriginAttributesPattern
&
aPattern
const
nsCString
&
aBaseDomain
nsTArray
<
RefPtr
<
nsICookie
>
>
&
aResult
)
{
CookieStorage
*
storage
=
PickStorage
(
aPattern
)
;
storage
-
>
GetCookiesWithOriginAttributes
(
aPattern
aBaseDomain
aResult
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsCookieService
:
:
RemoveCookiesWithOriginAttributes
(
const
nsAString
&
aPattern
const
nsACString
&
aHost
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
mozilla
:
:
OriginAttributesPattern
pattern
;
if
(
!
pattern
.
Init
(
aPattern
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsAutoCString
host
(
aHost
)
;
nsresult
rv
=
NormalizeHost
(
host
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
baseDomain
;
rv
=
GetBaseDomainFromHost
(
mTLDService
host
baseDomain
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
RemoveCookiesWithOriginAttributes
(
pattern
baseDomain
)
;
}
nsresult
nsCookieService
:
:
RemoveCookiesWithOriginAttributes
(
const
mozilla
:
:
OriginAttributesPattern
&
aPattern
const
nsCString
&
aBaseDomain
)
{
if
(
!
IsInitialized
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
CookieStorage
*
storage
=
PickStorage
(
aPattern
)
;
storage
-
>
RemoveCookiesWithOriginAttributes
(
aPattern
aBaseDomain
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsCookieService
:
:
RemoveCookiesFromExactHost
(
const
nsACString
&
aHost
const
nsAString
&
aPattern
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
mozilla
:
:
OriginAttributesPattern
pattern
;
if
(
!
pattern
.
Init
(
aPattern
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
return
RemoveCookiesFromExactHost
(
aHost
pattern
)
;
}
nsresult
nsCookieService
:
:
RemoveCookiesFromExactHost
(
const
nsACString
&
aHost
const
mozilla
:
:
OriginAttributesPattern
&
aPattern
)
{
nsAutoCString
host
(
aHost
)
;
nsresult
rv
=
NormalizeHost
(
host
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
baseDomain
;
rv
=
GetBaseDomainFromHost
(
mTLDService
host
baseDomain
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
IsInitialized
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
CookieStorage
*
storage
=
PickStorage
(
aPattern
)
;
storage
-
>
RemoveCookiesFromExactHost
(
aHost
baseDomain
aPattern
)
;
return
NS_OK
;
}
namespace
{
class
RemoveAllSinceRunnable
:
public
Runnable
{
public
:
typedef
nsTArray
<
RefPtr
<
nsICookie
>
>
CookieArray
;
RemoveAllSinceRunnable
(
Promise
*
aPromise
nsCookieService
*
aSelf
CookieArray
&
&
aCookieArray
int64_t
aSinceWhen
)
:
Runnable
(
"
RemoveAllSinceRunnable
"
)
mPromise
(
aPromise
)
mSelf
(
aSelf
)
mList
(
std
:
:
move
(
aCookieArray
)
)
mIndex
(
0
)
mSinceWhen
(
aSinceWhen
)
{
}
NS_IMETHODIMP
Run
(
)
{
RemoveSome
(
)
;
if
(
mIndex
<
mList
.
Length
(
)
)
{
return
NS_DispatchToCurrentThread
(
this
)
;
}
else
{
mPromise
-
>
MaybeResolveWithUndefined
(
)
;
}
return
NS_OK
;
}
private
:
void
RemoveSome
(
)
{
for
(
CookieArray
:
:
size_type
iter
=
0
;
iter
<
kYieldPeriod
&
&
mIndex
<
mList
.
Length
(
)
;
+
+
mIndex
+
+
iter
)
{
Cookie
*
cookie
=
static_cast
<
Cookie
*
>
(
mList
[
mIndex
]
.
get
(
)
)
;
if
(
cookie
-
>
CreationTime
(
)
>
mSinceWhen
&
&
NS_FAILED
(
mSelf
-
>
Remove
(
cookie
-
>
Host
(
)
cookie
-
>
OriginAttributesRef
(
)
cookie
-
>
Name
(
)
cookie
-
>
Path
(
)
)
)
)
{
continue
;
}
}
}
private
:
RefPtr
<
Promise
>
mPromise
;
RefPtr
<
nsCookieService
>
mSelf
;
CookieArray
mList
;
CookieArray
:
:
size_type
mIndex
;
int64_t
mSinceWhen
;
static
const
CookieArray
:
:
size_type
kYieldPeriod
=
10
;
}
;
}
NS_IMETHODIMP
nsCookieService
:
:
RemoveAllSince
(
int64_t
aSinceWhen
JSContext
*
aCx
Promise
*
*
aRetVal
)
{
nsIGlobalObject
*
globalObject
=
xpc
:
:
CurrentNativeGlobal
(
aCx
)
;
if
(
NS_WARN_IF
(
!
globalObject
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
ErrorResult
result
;
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
globalObject
result
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
return
result
.
StealNSResult
(
)
;
}
EnsureReadComplete
(
true
)
;
nsTArray
<
RefPtr
<
nsICookie
>
>
cookieList
;
mDefaultStorage
-
>
GetAll
(
cookieList
)
;
RefPtr
<
RemoveAllSinceRunnable
>
runMe
=
new
RemoveAllSinceRunnable
(
promise
this
std
:
:
move
(
cookieList
)
aSinceWhen
)
;
promise
.
forget
(
aRetVal
)
;
return
runMe
-
>
Run
(
)
;
}
void
bindCookieParameters
(
mozIStorageBindingParamsArray
*
aParamsArray
const
CookieKey
&
aKey
const
Cookie
*
aCookie
)
{
NS_ASSERTION
(
aParamsArray
"
Null
params
array
passed
to
bindCookieParameters
!
"
)
;
NS_ASSERTION
(
aCookie
"
Null
cookie
passed
to
bindCookieParameters
!
"
)
;
nsCOMPtr
<
mozIStorageBindingParams
>
params
;
DebugOnly
<
nsresult
>
rv
=
aParamsArray
-
>
NewBindingParams
(
getter_AddRefs
(
params
)
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
nsAutoCString
suffix
;
aKey
.
mOriginAttributes
.
CreateSuffix
(
suffix
)
;
rv
=
params
-
>
BindUTF8StringByName
(
NS_LITERAL_CSTRING
(
"
originAttributes
"
)
suffix
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
rv
=
params
-
>
BindUTF8StringByName
(
NS_LITERAL_CSTRING
(
"
name
"
)
aCookie
-
>
Name
(
)
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
rv
=
params
-
>
BindUTF8StringByName
(
NS_LITERAL_CSTRING
(
"
value
"
)
aCookie
-
>
Value
(
)
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
rv
=
params
-
>
BindUTF8StringByName
(
NS_LITERAL_CSTRING
(
"
host
"
)
aCookie
-
>
Host
(
)
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
rv
=
params
-
>
BindUTF8StringByName
(
NS_LITERAL_CSTRING
(
"
path
"
)
aCookie
-
>
Path
(
)
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
rv
=
params
-
>
BindInt64ByName
(
NS_LITERAL_CSTRING
(
"
expiry
"
)
aCookie
-
>
Expiry
(
)
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
rv
=
params
-
>
BindInt64ByName
(
NS_LITERAL_CSTRING
(
"
lastAccessed
"
)
aCookie
-
>
LastAccessed
(
)
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
rv
=
params
-
>
BindInt64ByName
(
NS_LITERAL_CSTRING
(
"
creationTime
"
)
aCookie
-
>
CreationTime
(
)
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
rv
=
params
-
>
BindInt32ByName
(
NS_LITERAL_CSTRING
(
"
isSecure
"
)
aCookie
-
>
IsSecure
(
)
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
rv
=
params
-
>
BindInt32ByName
(
NS_LITERAL_CSTRING
(
"
isHttpOnly
"
)
aCookie
-
>
IsHttpOnly
(
)
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
rv
=
params
-
>
BindInt32ByName
(
NS_LITERAL_CSTRING
(
"
sameSite
"
)
aCookie
-
>
SameSite
(
)
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
rv
=
params
-
>
BindInt32ByName
(
NS_LITERAL_CSTRING
(
"
rawSameSite
"
)
aCookie
-
>
RawSameSite
(
)
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
rv
=
aParamsArray
-
>
AddParams
(
params
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
}
size_t
nsCookieService
:
:
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
aMallocSizeOf
(
this
)
;
if
(
mDefaultStorage
)
{
n
+
=
mDefaultStorage
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
if
(
mPrivateStorage
)
{
n
+
=
mPrivateStorage
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
return
n
;
}
MOZ_DEFINE_MALLOC_SIZE_OF
(
CookieServiceMallocSizeOf
)
NS_IMETHODIMP
nsCookieService
:
:
CollectReports
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
bool
aAnonymize
)
{
MOZ_COLLECT_REPORT
(
"
explicit
/
cookie
-
service
"
KIND_HEAP
UNITS_BYTES
SizeOfIncludingThis
(
CookieServiceMallocSizeOf
)
"
Memory
used
by
the
cookie
service
.
"
)
;
return
NS_OK
;
}
bool
nsCookieService
:
:
IsInitialized
(
)
const
{
if
(
!
mDefaultStorage
)
{
NS_WARNING
(
"
No
CookieStorage
!
Profile
already
close
?
"
)
;
return
false
;
}
MOZ_ASSERT
(
mPrivateStorage
)
;
return
true
;
}
CookieStorage
*
nsCookieService
:
:
PickStorage
(
const
OriginAttributes
&
aAttrs
)
{
MOZ_ASSERT
(
IsInitialized
(
)
)
;
EnsureReadComplete
(
true
)
;
if
(
aAttrs
.
mPrivateBrowsingId
>
0
)
{
return
mPrivateStorage
;
}
return
mDefaultStorage
;
}
CookieStorage
*
nsCookieService
:
:
PickStorage
(
const
OriginAttributesPattern
&
aAttrs
)
{
MOZ_ASSERT
(
IsInitialized
(
)
)
;
EnsureReadComplete
(
true
)
;
if
(
aAttrs
.
mPrivateBrowsingId
.
WasPassed
(
)
&
&
aAttrs
.
mPrivateBrowsingId
.
Value
(
)
>
0
)
{
return
mPrivateStorage
;
}
return
mDefaultStorage
;
}
