#
include
"
mozilla
/
AntiTrackingCommon
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
Printf
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
net
/
CookieServiceChild
.
h
"
#
include
"
mozilla
/
net
/
NeckoCommon
.
h
"
#
include
"
nsCookieService
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIServiceManager
.
h
"
#
include
"
nsIScriptSecurityManager
.
h
"
#
include
"
nsIWebProgressListener
.
h
"
#
include
"
nsIIOService
.
h
"
#
include
"
nsIPermissionManager
.
h
"
#
include
"
nsIProtocolHandler
.
h
"
#
include
"
nsIPrefBranch
.
h
"
#
include
"
nsIPrefService
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsCookiePermission
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsIURL
.
h
"
#
include
"
nsIChannel
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsILineInputStream
.
h
"
#
include
"
nsIEffectiveTLDService
.
h
"
#
include
"
nsIIDNService
.
h
"
#
include
"
nsIThread
.
h
"
#
include
"
mozIThirdPartyUtil
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsCOMArray
.
h
"
#
include
"
nsIMutableArray
.
h
"
#
include
"
nsArrayEnumerator
.
h
"
#
include
"
nsEnumeratorUtils
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
prprf
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsISimpleEnumerator
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsAppDirectoryServiceDefs
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
mozilla
/
storage
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
mozilla
/
FileUtils
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
StaticPrefs
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
nsIConsoleService
.
h
"
#
include
"
nsTPriorityQueue
.
h
"
#
include
"
nsVariant
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
net
;
#
define
DEFAULT_APP_KEY
(
baseDomain
)
nsCookieKey
(
baseDomain
OriginAttributes
(
)
)
static
StaticRefPtr
<
nsCookieService
>
gCookieService
;
bool
nsCookieService
:
:
sSameSiteEnabled
=
false
;
#
define
HTTP_ONLY_PREFIX
"
#
HttpOnly_
"
#
define
COOKIES_FILE
"
cookies
.
sqlite
"
#
define
COOKIES_SCHEMA_VERSION
9
#
define
IDX_NAME
0
#
define
IDX_VALUE
1
#
define
IDX_HOST
2
#
define
IDX_PATH
3
#
define
IDX_EXPIRY
4
#
define
IDX_LAST_ACCESSED
5
#
define
IDX_CREATION_TIME
6
#
define
IDX_SECURE
7
#
define
IDX_HTTPONLY
8
#
define
IDX_BASE_DOMAIN
9
#
define
IDX_ORIGIN_ATTRIBUTES
10
#
define
IDX_SAME_SITE
11
#
define
TOPIC_CLEAR_ORIGIN_DATA
"
clear
-
origin
-
attributes
-
data
"
static
const
int64_t
kCookiePurgeAge
=
int64_t
(
30
*
24
*
60
*
60
)
*
PR_USEC_PER_SEC
;
#
define
OLD_COOKIE_FILE_NAME
"
cookies
.
txt
"
#
undef
LIMIT
#
define
LIMIT
(
x
low
high
default
)
\
(
(
x
)
>
=
(
low
)
&
&
(
x
)
<
=
(
high
)
?
(
x
)
:
(
default
)
)
#
undef
ADD_TEN_PERCENT
#
define
ADD_TEN_PERCENT
(
i
)
static_cast
<
uint32_t
>
(
(
i
)
+
(
i
)
/
10
)
static
const
uint32_t
kMaxNumberOfCookies
=
3000
;
static
const
uint32_t
kMaxCookiesPerHost
=
180
;
static
const
uint32_t
kCookieQuotaPerHost
=
150
;
static
const
uint32_t
kMaxBytesPerCookie
=
4096
;
static
const
uint32_t
kMaxBytesPerPath
=
1024
;
static
const
char
kPrefCookieBehavior
[
]
=
"
network
.
cookie
.
cookieBehavior
"
;
static
const
char
kPrefMaxNumberOfCookies
[
]
=
"
network
.
cookie
.
maxNumber
"
;
static
const
char
kPrefMaxCookiesPerHost
[
]
=
"
network
.
cookie
.
maxPerHost
"
;
static
const
char
kPrefCookieQuotaPerHost
[
]
=
"
network
.
cookie
.
quotaPerHost
"
;
static
const
char
kPrefCookiePurgeAge
[
]
=
"
network
.
cookie
.
purgeAge
"
;
static
const
char
kPrefThirdPartySession
[
]
=
"
network
.
cookie
.
thirdparty
.
sessionOnly
"
;
static
const
char
kPrefThirdPartyNonsecureSession
[
]
=
"
network
.
cookie
.
thirdparty
.
nonsecureSessionOnly
"
;
static
const
char
kCookieLeaveSecurityAlone
[
]
=
"
network
.
cookie
.
leave
-
secure
-
alone
"
;
#
define
BLOCKED_SECURE_SET_FROM_HTTP
0
#
define
BLOCKED_DOWNGRADE_SECURE_INEXACT
1
#
define
DOWNGRADE_SECURE_FROM_SECURE_INEXACT
2
#
define
EVICTED_NEWER_INSECURE
3
#
define
EVICTED_OLDEST_COOKIE
4
#
define
EVICTED_PREFERRED_COOKIE
5
#
define
EVICTING_SECURE_BLOCKED
6
#
define
BLOCKED_DOWNGRADE_SECURE_EXACT
7
#
define
DOWNGRADE_SECURE_FROM_SECURE_EXACT
8
static
void
bindCookieParameters
(
mozIStorageBindingParamsArray
*
aParamsArray
const
nsCookieKey
&
aKey
const
nsCookie
*
aCookie
)
;
struct
nsListIter
{
nsListIter
(
)
=
default
;
explicit
nsListIter
(
nsCookieEntry
*
aEntry
nsCookieEntry
:
:
IndexType
aIndex
)
:
entry
(
aEntry
)
index
(
aIndex
)
{
}
nsCookie
*
Cookie
(
)
const
{
return
entry
-
>
GetCookies
(
)
[
index
]
;
}
nsCookieEntry
*
entry
;
nsCookieEntry
:
:
IndexType
index
;
}
;
#
ifdef
MOZ_LOGGING
#
include
"
mozilla
/
Logging
.
h
"
#
endif
#
define
SET_COOKIE
true
#
define
GET_COOKIE
false
static
LazyLogModule
gCookieLog
(
"
cookie
"
)
;
#
define
COOKIE_LOGFAILURE
(
a
b
c
d
)
LogFailure
(
a
b
c
d
)
#
define
COOKIE_LOGSUCCESS
(
a
b
c
d
e
)
LogSuccess
(
a
b
c
d
e
)
#
define
COOKIE_LOGEVICTED
(
a
details
)
\
PR_BEGIN_MACRO
\
if
(
MOZ_LOG_TEST
(
gCookieLog
LogLevel
:
:
Debug
)
)
LogEvicted
(
a
details
)
;
\
PR_END_MACRO
#
define
COOKIE_LOGSTRING
(
lvl
fmt
)
\
PR_BEGIN_MACRO
\
MOZ_LOG
(
gCookieLog
lvl
fmt
)
;
\
MOZ_LOG
(
gCookieLog
lvl
(
"
\
n
"
)
)
;
\
PR_END_MACRO
static
void
LogFailure
(
bool
aSetCookie
nsIURI
*
aHostURI
const
char
*
aCookieString
const
char
*
aReason
)
{
if
(
!
MOZ_LOG_TEST
(
gCookieLog
LogLevel
:
:
Warning
)
)
return
;
nsAutoCString
spec
;
if
(
aHostURI
)
aHostURI
-
>
GetAsciiSpec
(
spec
)
;
MOZ_LOG
(
gCookieLog
LogLevel
:
:
Warning
(
"
=
=
=
=
=
%
s
=
=
=
=
=
\
n
"
aSetCookie
?
"
COOKIE
NOT
ACCEPTED
"
:
"
COOKIE
NOT
SENT
"
)
)
;
MOZ_LOG
(
gCookieLog
LogLevel
:
:
Warning
(
"
request
URL
:
%
s
\
n
"
spec
.
get
(
)
)
)
;
if
(
aSetCookie
)
MOZ_LOG
(
gCookieLog
LogLevel
:
:
Warning
(
"
cookie
string
:
%
s
\
n
"
aCookieString
)
)
;
PRExplodedTime
explodedTime
;
PR_ExplodeTime
(
PR_Now
(
)
PR_GMTParameters
&
explodedTime
)
;
char
timeString
[
40
]
;
PR_FormatTimeUSEnglish
(
timeString
40
"
%
c
GMT
"
&
explodedTime
)
;
MOZ_LOG
(
gCookieLog
LogLevel
:
:
Warning
(
"
current
time
:
%
s
"
timeString
)
)
;
MOZ_LOG
(
gCookieLog
LogLevel
:
:
Warning
(
"
rejected
because
%
s
\
n
"
aReason
)
)
;
MOZ_LOG
(
gCookieLog
LogLevel
:
:
Warning
(
"
\
n
"
)
)
;
}
static
void
LogCookie
(
nsCookie
*
aCookie
)
{
PRExplodedTime
explodedTime
;
PR_ExplodeTime
(
PR_Now
(
)
PR_GMTParameters
&
explodedTime
)
;
char
timeString
[
40
]
;
PR_FormatTimeUSEnglish
(
timeString
40
"
%
c
GMT
"
&
explodedTime
)
;
MOZ_LOG
(
gCookieLog
LogLevel
:
:
Debug
(
"
current
time
:
%
s
"
timeString
)
)
;
if
(
aCookie
)
{
MOZ_LOG
(
gCookieLog
LogLevel
:
:
Debug
(
"
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
\
n
"
)
)
;
MOZ_LOG
(
gCookieLog
LogLevel
:
:
Debug
(
"
name
:
%
s
\
n
"
aCookie
-
>
Name
(
)
.
get
(
)
)
)
;
MOZ_LOG
(
gCookieLog
LogLevel
:
:
Debug
(
"
value
:
%
s
\
n
"
aCookie
-
>
Value
(
)
.
get
(
)
)
)
;
MOZ_LOG
(
gCookieLog
LogLevel
:
:
Debug
(
"
%
s
:
%
s
\
n
"
aCookie
-
>
IsDomain
(
)
?
"
domain
"
:
"
host
"
aCookie
-
>
Host
(
)
.
get
(
)
)
)
;
MOZ_LOG
(
gCookieLog
LogLevel
:
:
Debug
(
"
path
:
%
s
\
n
"
aCookie
-
>
Path
(
)
.
get
(
)
)
)
;
PR_ExplodeTime
(
aCookie
-
>
Expiry
(
)
*
int64_t
(
PR_USEC_PER_SEC
)
PR_GMTParameters
&
explodedTime
)
;
PR_FormatTimeUSEnglish
(
timeString
40
"
%
c
GMT
"
&
explodedTime
)
;
MOZ_LOG
(
gCookieLog
LogLevel
:
:
Debug
(
"
expires
:
%
s
%
s
"
timeString
aCookie
-
>
IsSession
(
)
?
"
(
at
end
of
session
)
"
:
"
"
)
)
;
PR_ExplodeTime
(
aCookie
-
>
CreationTime
(
)
PR_GMTParameters
&
explodedTime
)
;
PR_FormatTimeUSEnglish
(
timeString
40
"
%
c
GMT
"
&
explodedTime
)
;
MOZ_LOG
(
gCookieLog
LogLevel
:
:
Debug
(
"
created
:
%
s
"
timeString
)
)
;
MOZ_LOG
(
gCookieLog
LogLevel
:
:
Debug
(
"
is
secure
:
%
s
\
n
"
aCookie
-
>
IsSecure
(
)
?
"
true
"
:
"
false
"
)
)
;
MOZ_LOG
(
gCookieLog
LogLevel
:
:
Debug
(
"
is
httpOnly
:
%
s
\
n
"
aCookie
-
>
IsHttpOnly
(
)
?
"
true
"
:
"
false
"
)
)
;
nsAutoCString
suffix
;
aCookie
-
>
OriginAttributesRef
(
)
.
CreateSuffix
(
suffix
)
;
MOZ_LOG
(
gCookieLog
LogLevel
:
:
Debug
(
"
origin
attributes
:
%
s
\
n
"
suffix
.
IsEmpty
(
)
?
"
{
empty
}
"
:
suffix
.
get
(
)
)
)
;
}
}
static
void
LogSuccess
(
bool
aSetCookie
nsIURI
*
aHostURI
const
char
*
aCookieString
nsCookie
*
aCookie
bool
aReplacing
)
{
if
(
!
MOZ_LOG_TEST
(
gCookieLog
LogLevel
:
:
Debug
)
)
{
return
;
}
nsAutoCString
spec
;
if
(
aHostURI
)
aHostURI
-
>
GetAsciiSpec
(
spec
)
;
MOZ_LOG
(
gCookieLog
LogLevel
:
:
Debug
(
"
=
=
=
=
=
%
s
=
=
=
=
=
\
n
"
aSetCookie
?
"
COOKIE
ACCEPTED
"
:
"
COOKIE
SENT
"
)
)
;
MOZ_LOG
(
gCookieLog
LogLevel
:
:
Debug
(
"
request
URL
:
%
s
\
n
"
spec
.
get
(
)
)
)
;
MOZ_LOG
(
gCookieLog
LogLevel
:
:
Debug
(
"
cookie
string
:
%
s
\
n
"
aCookieString
)
)
;
if
(
aSetCookie
)
MOZ_LOG
(
gCookieLog
LogLevel
:
:
Debug
(
"
replaces
existing
cookie
:
%
s
\
n
"
aReplacing
?
"
true
"
:
"
false
"
)
)
;
LogCookie
(
aCookie
)
;
MOZ_LOG
(
gCookieLog
LogLevel
:
:
Debug
(
"
\
n
"
)
)
;
}
static
void
LogEvicted
(
nsCookie
*
aCookie
const
char
*
details
)
{
MOZ_LOG
(
gCookieLog
LogLevel
:
:
Debug
(
"
=
=
=
=
=
COOKIE
EVICTED
=
=
=
=
=
\
n
"
)
)
;
MOZ_LOG
(
gCookieLog
LogLevel
:
:
Debug
(
"
%
s
\
n
"
details
)
)
;
LogCookie
(
aCookie
)
;
MOZ_LOG
(
gCookieLog
LogLevel
:
:
Debug
(
"
\
n
"
)
)
;
}
static
inline
void
LogFailure
(
bool
aSetCookie
nsIURI
*
aHostURI
const
nsCString
&
aCookieString
const
char
*
aReason
)
{
LogFailure
(
aSetCookie
aHostURI
aCookieString
.
get
(
)
aReason
)
;
}
static
inline
void
LogSuccess
(
bool
aSetCookie
nsIURI
*
aHostURI
const
nsCString
&
aCookieString
nsCookie
*
aCookie
bool
aReplacing
)
{
LogSuccess
(
aSetCookie
aHostURI
aCookieString
.
get
(
)
aCookie
aReplacing
)
;
}
#
ifdef
DEBUG
#
define
NS_ASSERT_SUCCESS
(
res
)
\
PR_BEGIN_MACRO
\
nsresult
__rv
=
res
;
/
*
Do
not
evaluate
|
res
|
more
than
once
!
*
/
\
if
(
NS_FAILED
(
__rv
)
)
{
\
SmprintfPointer
msg
=
mozilla
:
:
Smprintf
(
\
"
NS_ASSERT_SUCCESS
(
%
s
)
failed
with
result
0x
%
"
PRIX32
#
res
\
static_cast
<
uint32_t
>
(
__rv
)
)
;
\
NS_ASSERTION
(
NS_SUCCEEDED
(
__rv
)
msg
.
get
(
)
)
;
\
}
\
PR_END_MACRO
#
else
#
define
NS_ASSERT_SUCCESS
(
res
)
PR_BEGIN_MACRO
/
*
nothing
*
/
PR_END_MACRO
#
endif
class
DBListenerErrorHandler
:
public
mozIStorageStatementCallback
{
protected
:
explicit
DBListenerErrorHandler
(
DBState
*
dbState
)
:
mDBState
(
dbState
)
{
}
RefPtr
<
DBState
>
mDBState
;
virtual
const
char
*
GetOpType
(
)
=
0
;
public
:
NS_IMETHOD
HandleError
(
mozIStorageError
*
aError
)
override
{
if
(
MOZ_LOG_TEST
(
gCookieLog
LogLevel
:
:
Warning
)
)
{
int32_t
result
=
-
1
;
aError
-
>
GetResult
(
&
result
)
;
nsAutoCString
message
;
aError
-
>
GetMessage
(
message
)
;
COOKIE_LOGSTRING
(
LogLevel
:
:
Warning
(
"
DBListenerErrorHandler
:
:
HandleError
(
)
:
Error
%
d
occurred
while
"
"
performing
operation
'
%
s
'
with
message
'
%
s
'
;
rebuilding
database
.
"
result
GetOpType
(
)
message
.
get
(
)
)
)
;
}
gCookieService
-
>
HandleCorruptDB
(
mDBState
)
;
return
NS_OK
;
}
}
;
class
InsertCookieDBListener
final
:
public
DBListenerErrorHandler
{
private
:
const
char
*
GetOpType
(
)
override
{
return
"
INSERT
"
;
}
~
InsertCookieDBListener
(
)
=
default
;
public
:
NS_DECL_ISUPPORTS
explicit
InsertCookieDBListener
(
DBState
*
dbState
)
:
DBListenerErrorHandler
(
dbState
)
{
}
NS_IMETHOD
HandleResult
(
mozIStorageResultSet
*
)
override
{
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
call
to
"
"
InsertCookieDBListener
:
:
HandleResult
"
)
;
return
NS_OK
;
}
NS_IMETHOD
HandleCompletion
(
uint16_t
aReason
)
override
{
if
(
mDBState
-
>
corruptFlag
=
=
DBState
:
:
REBUILDING
&
&
aReason
=
=
mozIStorageStatementCallback
:
:
REASON_FINISHED
)
{
COOKIE_LOGSTRING
(
LogLevel
:
:
Debug
(
"
InsertCookieDBListener
:
:
HandleCompletion
(
)
:
rebuild
complete
"
)
)
;
mDBState
-
>
corruptFlag
=
DBState
:
:
OK
;
}
return
NS_OK
;
}
}
;
NS_IMPL_ISUPPORTS
(
InsertCookieDBListener
mozIStorageStatementCallback
)
class
UpdateCookieDBListener
final
:
public
DBListenerErrorHandler
{
private
:
const
char
*
GetOpType
(
)
override
{
return
"
UPDATE
"
;
}
~
UpdateCookieDBListener
(
)
=
default
;
public
:
NS_DECL_ISUPPORTS
explicit
UpdateCookieDBListener
(
DBState
*
dbState
)
:
DBListenerErrorHandler
(
dbState
)
{
}
NS_IMETHOD
HandleResult
(
mozIStorageResultSet
*
)
override
{
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
call
to
"
"
UpdateCookieDBListener
:
:
HandleResult
"
)
;
return
NS_OK
;
}
NS_IMETHOD
HandleCompletion
(
uint16_t
aReason
)
override
{
return
NS_OK
;
}
}
;
NS_IMPL_ISUPPORTS
(
UpdateCookieDBListener
mozIStorageStatementCallback
)
class
RemoveCookieDBListener
final
:
public
DBListenerErrorHandler
{
private
:
const
char
*
GetOpType
(
)
override
{
return
"
REMOVE
"
;
}
~
RemoveCookieDBListener
(
)
=
default
;
public
:
NS_DECL_ISUPPORTS
explicit
RemoveCookieDBListener
(
DBState
*
dbState
)
:
DBListenerErrorHandler
(
dbState
)
{
}
NS_IMETHOD
HandleResult
(
mozIStorageResultSet
*
)
override
{
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
call
to
"
"
RemoveCookieDBListener
:
:
HandleResult
"
)
;
return
NS_OK
;
}
NS_IMETHOD
HandleCompletion
(
uint16_t
aReason
)
override
{
return
NS_OK
;
}
}
;
NS_IMPL_ISUPPORTS
(
RemoveCookieDBListener
mozIStorageStatementCallback
)
class
CloseCookieDBListener
final
:
public
mozIStorageCompletionCallback
{
~
CloseCookieDBListener
(
)
=
default
;
public
:
explicit
CloseCookieDBListener
(
DBState
*
dbState
)
:
mDBState
(
dbState
)
{
}
RefPtr
<
DBState
>
mDBState
;
NS_DECL_ISUPPORTS
NS_IMETHOD
Complete
(
nsresult
nsISupports
*
)
override
{
gCookieService
-
>
HandleDBClosed
(
mDBState
)
;
return
NS_OK
;
}
}
;
NS_IMPL_ISUPPORTS
(
CloseCookieDBListener
mozIStorageCompletionCallback
)
namespace
{
class
AppClearDataObserver
final
:
public
nsIObserver
{
~
AppClearDataObserver
(
)
=
default
;
public
:
NS_DECL_ISUPPORTS
NS_IMETHOD
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
override
{
MOZ_ASSERT
(
!
nsCRT
:
:
strcmp
(
aTopic
TOPIC_CLEAR_ORIGIN_DATA
)
)
;
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
nsCOMPtr
<
nsICookieManager
>
cookieManager
=
do_GetService
(
NS_COOKIEMANAGER_CONTRACTID
)
;
MOZ_ASSERT
(
cookieManager
)
;
return
cookieManager
-
>
RemoveCookiesWithOriginAttributes
(
nsDependentString
(
aData
)
EmptyCString
(
)
)
;
}
}
;
NS_IMPL_ISUPPORTS
(
AppClearDataObserver
nsIObserver
)
class
CompareCookiesByIndex
{
public
:
bool
Equals
(
const
nsListIter
&
a
const
nsListIter
&
b
)
const
{
NS_ASSERTION
(
a
.
entry
!
=
b
.
entry
|
|
a
.
index
!
=
b
.
index
"
cookie
indexes
should
never
be
equal
"
)
;
return
false
;
}
bool
LessThan
(
const
nsListIter
&
a
const
nsListIter
&
b
)
const
{
if
(
a
.
entry
!
=
b
.
entry
)
return
a
.
entry
<
b
.
entry
;
return
a
.
index
<
b
.
index
;
}
}
;
}
size_t
nsCookieEntry
:
:
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
amount
=
nsCookieKey
:
:
SizeOfExcludingThis
(
aMallocSizeOf
)
;
amount
+
=
mCookies
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
for
(
uint32_t
i
=
0
;
i
<
mCookies
.
Length
(
)
;
+
+
i
)
{
amount
+
=
mCookies
[
i
]
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
return
amount
;
}
size_t
DBState
:
:
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
amount
=
0
;
amount
+
=
aMallocSizeOf
(
this
)
;
amount
+
=
hostTable
.
SizeOfExcludingThis
(
aMallocSizeOf
)
;
return
amount
;
}
already_AddRefed
<
nsICookieService
>
nsCookieService
:
:
GetXPCOMSingleton
(
)
{
if
(
IsNeckoChild
(
)
)
return
CookieServiceChild
:
:
GetSingleton
(
)
;
return
GetSingleton
(
)
;
}
already_AddRefed
<
nsCookieService
>
nsCookieService
:
:
GetSingleton
(
)
{
NS_ASSERTION
(
!
IsNeckoChild
(
)
"
not
a
parent
process
"
)
;
if
(
gCookieService
)
{
return
do_AddRef
(
gCookieService
)
;
}
gCookieService
=
new
nsCookieService
(
)
;
if
(
gCookieService
)
{
if
(
NS_SUCCEEDED
(
gCookieService
-
>
Init
(
)
)
)
{
ClearOnShutdown
(
&
gCookieService
)
;
}
else
{
gCookieService
=
nullptr
;
}
}
return
do_AddRef
(
gCookieService
)
;
}
void
nsCookieService
:
:
AppClearDataObserverInit
(
)
{
nsCOMPtr
<
nsIObserverService
>
observerService
=
services
:
:
GetObserverService
(
)
;
nsCOMPtr
<
nsIObserver
>
obs
=
new
AppClearDataObserver
(
)
;
observerService
-
>
AddObserver
(
obs
TOPIC_CLEAR_ORIGIN_DATA
false
)
;
}
NS_IMPL_ISUPPORTS
(
nsCookieService
nsICookieService
nsICookieManager
nsIObserver
nsISupportsWeakReference
nsIMemoryReporter
)
nsCookieService
:
:
nsCookieService
(
)
:
mDBState
(
nullptr
)
mCookieBehavior
(
nsICookieService
:
:
BEHAVIOR_ACCEPT
)
mThirdPartySession
(
false
)
mThirdPartyNonsecureSession
(
false
)
mLeaveSecureAlone
(
true
)
mMaxNumberOfCookies
(
kMaxNumberOfCookies
)
mMaxCookiesPerHost
(
kMaxCookiesPerHost
)
mCookieQuotaPerHost
(
kCookieQuotaPerHost
)
mCookiePurgeAge
(
kCookiePurgeAge
)
mThread
(
nullptr
)
mMonitor
(
"
CookieThread
"
)
mInitializedDBStates
(
false
)
mInitializedDBConn
(
false
)
{
}
nsresult
nsCookieService
:
:
Init
(
)
{
nsresult
rv
;
mTLDService
=
do_GetService
(
NS_EFFECTIVETLDSERVICE_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mIDNService
=
do_GetService
(
NS_IDNSERVICE_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mThirdPartyUtil
=
do_GetService
(
THIRDPARTYUTIL_CONTRACTID
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIPrefBranch
>
prefBranch
=
do_GetService
(
NS_PREFSERVICE_CONTRACTID
)
;
if
(
prefBranch
)
{
prefBranch
-
>
AddObserver
(
kPrefCookieBehavior
this
true
)
;
prefBranch
-
>
AddObserver
(
kPrefMaxNumberOfCookies
this
true
)
;
prefBranch
-
>
AddObserver
(
kPrefMaxCookiesPerHost
this
true
)
;
prefBranch
-
>
AddObserver
(
kPrefCookiePurgeAge
this
true
)
;
prefBranch
-
>
AddObserver
(
kPrefThirdPartySession
this
true
)
;
prefBranch
-
>
AddObserver
(
kPrefThirdPartyNonsecureSession
this
true
)
;
prefBranch
-
>
AddObserver
(
kCookieLeaveSecurityAlone
this
true
)
;
PrefChanged
(
prefBranch
)
;
}
mStorageService
=
do_GetService
(
"
mozilla
.
org
/
storage
/
service
;
1
"
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
InitDBStates
(
)
;
RegisterWeakMemoryReporter
(
this
)
;
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
NS_ENSURE_STATE
(
os
)
;
os
-
>
AddObserver
(
this
"
profile
-
before
-
change
"
true
)
;
os
-
>
AddObserver
(
this
"
profile
-
do
-
change
"
true
)
;
os
-
>
AddObserver
(
this
"
last
-
pb
-
context
-
exited
"
true
)
;
mPermissionService
=
nsCookiePermission
:
:
GetOrCreate
(
)
;
return
NS_OK
;
}
void
nsCookieService
:
:
InitDBStates
(
)
{
NS_ASSERTION
(
!
mDBState
"
already
have
a
DBState
"
)
;
NS_ASSERTION
(
!
mDefaultDBState
"
already
have
a
default
DBState
"
)
;
NS_ASSERTION
(
!
mPrivateDBState
"
already
have
a
private
DBState
"
)
;
NS_ASSERTION
(
!
mInitializedDBStates
"
already
initialized
"
)
;
NS_ASSERTION
(
!
mThread
"
already
have
a
cookie
thread
"
)
;
mDefaultDBState
=
new
DBState
(
)
;
mDBState
=
mDefaultDBState
;
mPrivateDBState
=
new
DBState
(
)
;
nsresult
rv
=
NS_GetSpecialDirectory
(
NS_APP_USER_PROFILE_50_DIR
getter_AddRefs
(
mDefaultDBState
-
>
cookieFile
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
COOKIE_LOGSTRING
(
LogLevel
:
:
Warning
(
"
InitDBStates
(
)
:
couldn
'
t
get
cookie
file
"
)
)
;
mInitializedDBConn
=
true
;
mInitializedDBStates
=
true
;
return
;
}
mDefaultDBState
-
>
cookieFile
-
>
AppendNative
(
NS_LITERAL_CSTRING
(
COOKIES_FILE
)
)
;
NS_ENSURE_SUCCESS_VOID
(
NS_NewNamedThread
(
"
Cookie
"
getter_AddRefs
(
mThread
)
)
)
;
nsCOMPtr
<
nsIRunnable
>
runnable
=
NS_NewRunnableFunction
(
"
InitDBStates
.
TryInitDB
"
[
]
{
NS_ENSURE_TRUE_VOID
(
gCookieService
&
&
gCookieService
-
>
mDBState
&
&
gCookieService
-
>
mDefaultDBState
)
;
MonitorAutoLock
lock
(
gCookieService
-
>
mMonitor
)
;
OpenDBResult
result
=
gCookieService
-
>
TryInitDB
(
false
)
;
if
(
result
=
=
RESULT_RETRY
)
{
COOKIE_LOGSTRING
(
LogLevel
:
:
Warning
(
"
InitDBStates
(
)
:
retrying
TryInitDB
(
)
"
)
)
;
gCookieService
-
>
CleanupCachedStatements
(
)
;
gCookieService
-
>
CleanupDefaultDBConnection
(
)
;
result
=
gCookieService
-
>
TryInitDB
(
true
)
;
if
(
result
=
=
RESULT_RETRY
)
{
result
=
RESULT_FAILURE
;
}
}
if
(
result
=
=
RESULT_FAILURE
)
{
COOKIE_LOGSTRING
(
LogLevel
:
:
Warning
(
"
InitDBStates
(
)
:
TryInitDB
(
)
failed
closing
connection
"
)
)
;
gCookieService
-
>
CleanupCachedStatements
(
)
;
gCookieService
-
>
CleanupDefaultDBConnection
(
)
;
gCookieService
-
>
mInitializedDBConn
=
true
;
}
gCookieService
-
>
mInitializedDBStates
=
true
;
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
TryInitDB
.
InitDBConn
"
[
]
{
NS_ENSURE_TRUE_VOID
(
gCookieService
)
;
gCookieService
-
>
InitDBConn
(
)
;
}
)
)
;
gCookieService
-
>
mMonitor
.
Notify
(
)
;
}
)
;
mThread
-
>
Dispatch
(
runnable
NS_DISPATCH_NORMAL
)
;
}
namespace
{
class
ConvertAppIdToOriginAttrsSQLFunction
final
:
public
mozIStorageFunction
{
~
ConvertAppIdToOriginAttrsSQLFunction
(
)
=
default
;
NS_DECL_ISUPPORTS
NS_DECL_MOZISTORAGEFUNCTION
}
;
NS_IMPL_ISUPPORTS
(
ConvertAppIdToOriginAttrsSQLFunction
mozIStorageFunction
)
;
NS_IMETHODIMP
ConvertAppIdToOriginAttrsSQLFunction
:
:
OnFunctionCall
(
mozIStorageValueArray
*
aFunctionArguments
nsIVariant
*
*
aResult
)
{
nsresult
rv
;
int32_t
inIsolatedMozBrowser
;
rv
=
aFunctionArguments
-
>
GetInt32
(
1
&
inIsolatedMozBrowser
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
OriginAttributes
attrs
(
nsIScriptSecurityManager
:
:
NO_APP_ID
(
inIsolatedMozBrowser
?
true
:
false
)
)
;
nsAutoCString
suffix
;
attrs
.
CreateSuffix
(
suffix
)
;
RefPtr
<
nsVariant
>
outVar
(
new
nsVariant
(
)
)
;
rv
=
outVar
-
>
SetAsAUTF8String
(
suffix
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
outVar
.
forget
(
aResult
)
;
return
NS_OK
;
}
class
SetAppIdFromOriginAttributesSQLFunction
final
:
public
mozIStorageFunction
{
~
SetAppIdFromOriginAttributesSQLFunction
(
)
=
default
;
NS_DECL_ISUPPORTS
NS_DECL_MOZISTORAGEFUNCTION
}
;
NS_IMPL_ISUPPORTS
(
SetAppIdFromOriginAttributesSQLFunction
mozIStorageFunction
)
;
NS_IMETHODIMP
SetAppIdFromOriginAttributesSQLFunction
:
:
OnFunctionCall
(
mozIStorageValueArray
*
aFunctionArguments
nsIVariant
*
*
aResult
)
{
nsresult
rv
;
nsAutoCString
suffix
;
OriginAttributes
attrs
;
rv
=
aFunctionArguments
-
>
GetUTF8String
(
0
suffix
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
success
=
attrs
.
PopulateFromSuffix
(
suffix
)
;
NS_ENSURE_TRUE
(
success
NS_ERROR_FAILURE
)
;
RefPtr
<
nsVariant
>
outVar
(
new
nsVariant
(
)
)
;
rv
=
outVar
-
>
SetAsInt32
(
attrs
.
mAppId
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
outVar
.
forget
(
aResult
)
;
return
NS_OK
;
}
class
SetInBrowserFromOriginAttributesSQLFunction
final
:
public
mozIStorageFunction
{
~
SetInBrowserFromOriginAttributesSQLFunction
(
)
=
default
;
NS_DECL_ISUPPORTS
NS_DECL_MOZISTORAGEFUNCTION
}
;
NS_IMPL_ISUPPORTS
(
SetInBrowserFromOriginAttributesSQLFunction
mozIStorageFunction
)
;
NS_IMETHODIMP
SetInBrowserFromOriginAttributesSQLFunction
:
:
OnFunctionCall
(
mozIStorageValueArray
*
aFunctionArguments
nsIVariant
*
*
aResult
)
{
nsresult
rv
;
nsAutoCString
suffix
;
OriginAttributes
attrs
;
rv
=
aFunctionArguments
-
>
GetUTF8String
(
0
suffix
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
success
=
attrs
.
PopulateFromSuffix
(
suffix
)
;
NS_ENSURE_TRUE
(
success
NS_ERROR_FAILURE
)
;
RefPtr
<
nsVariant
>
outVar
(
new
nsVariant
(
)
)
;
rv
=
outVar
-
>
SetAsInt32
(
attrs
.
mInIsolatedMozBrowser
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
outVar
.
forget
(
aResult
)
;
return
NS_OK
;
}
}
OpenDBResult
nsCookieService
:
:
TryInitDB
(
bool
aRecreateDB
)
{
NS_ASSERTION
(
!
mDefaultDBState
-
>
dbConn
"
nonnull
dbConn
"
)
;
NS_ASSERTION
(
!
mDefaultDBState
-
>
stmtInsert
"
nonnull
stmtInsert
"
)
;
NS_ASSERTION
(
!
mDefaultDBState
-
>
insertListener
"
nonnull
insertListener
"
)
;
NS_ASSERTION
(
!
mDefaultDBState
-
>
syncConn
"
nonnull
syncConn
"
)
;
NS_ASSERTION
(
NS_GetCurrentThread
(
)
=
=
mThread
"
non
cookie
thread
"
)
;
nsresult
rv
;
if
(
aRecreateDB
)
{
nsCOMPtr
<
nsIFile
>
backupFile
;
mDefaultDBState
-
>
cookieFile
-
>
Clone
(
getter_AddRefs
(
backupFile
)
)
;
rv
=
backupFile
-
>
MoveToNative
(
nullptr
NS_LITERAL_CSTRING
(
COOKIES_FILE
"
.
bak
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_FAILURE
)
;
}
{
Telemetry
:
:
AutoTimer
<
Telemetry
:
:
MOZ_SQLITE_COOKIES_OPEN_READAHEAD_MS
>
telemetry
;
ReadAheadFile
(
mDefaultDBState
-
>
cookieFile
)
;
rv
=
mStorageService
-
>
OpenUnsharedDatabase
(
mDefaultDBState
-
>
cookieFile
getter_AddRefs
(
mDefaultDBState
-
>
syncConn
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
}
auto
guard
=
MakeScopeExit
(
[
&
]
{
mDefaultDBState
-
>
syncConn
=
nullptr
;
}
)
;
bool
tableExists
=
false
;
mDefaultDBState
-
>
syncConn
-
>
TableExists
(
NS_LITERAL_CSTRING
(
"
moz_cookies
"
)
&
tableExists
)
;
if
(
!
tableExists
)
{
rv
=
CreateTable
(
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
}
else
{
int32_t
dbSchemaVersion
;
rv
=
mDefaultDBState
-
>
syncConn
-
>
GetSchemaVersion
(
&
dbSchemaVersion
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
mozStorageTransaction
transaction
(
mDefaultDBState
-
>
syncConn
true
)
;
switch
(
dbSchemaVersion
)
{
case
1
:
{
rv
=
mDefaultDBState
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
ALTER
TABLE
moz_cookies
ADD
lastAccessed
INTEGER
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
}
MOZ_FALLTHROUGH
;
case
2
:
{
rv
=
mDefaultDBState
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
ALTER
TABLE
moz_cookies
ADD
baseDomain
TEXT
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
const
int64_t
SCHEMA2_IDX_ID
=
0
;
const
int64_t
SCHEMA2_IDX_HOST
=
1
;
nsCOMPtr
<
mozIStorageStatement
>
select
;
rv
=
mDefaultDBState
-
>
syncConn
-
>
CreateStatement
(
NS_LITERAL_CSTRING
(
"
SELECT
id
host
FROM
moz_cookies
"
)
getter_AddRefs
(
select
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
nsCOMPtr
<
mozIStorageStatement
>
update
;
rv
=
mDefaultDBState
-
>
syncConn
-
>
CreateStatement
(
NS_LITERAL_CSTRING
(
"
UPDATE
moz_cookies
SET
baseDomain
=
"
"
:
baseDomain
WHERE
id
=
:
id
"
)
getter_AddRefs
(
update
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
nsCString
baseDomain
host
;
bool
hasResult
;
while
(
true
)
{
rv
=
select
-
>
ExecuteStep
(
&
hasResult
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
if
(
!
hasResult
)
break
;
int64_t
id
=
select
-
>
AsInt64
(
SCHEMA2_IDX_ID
)
;
select
-
>
GetUTF8String
(
SCHEMA2_IDX_HOST
host
)
;
rv
=
GetBaseDomainFromHost
(
mTLDService
host
baseDomain
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
mozStorageStatementScoper
scoper
(
update
)
;
rv
=
update
-
>
BindUTF8StringByName
(
NS_LITERAL_CSTRING
(
"
baseDomain
"
)
baseDomain
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
rv
=
update
-
>
BindInt64ByName
(
NS_LITERAL_CSTRING
(
"
id
"
)
id
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
rv
=
update
-
>
ExecuteStep
(
&
hasResult
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
}
rv
=
mDefaultDBState
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
CREATE
INDEX
moz_basedomain
ON
moz_cookies
(
baseDomain
)
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
}
MOZ_FALLTHROUGH
;
case
3
:
{
const
int64_t
SCHEMA3_IDX_ID
=
0
;
const
int64_t
SCHEMA3_IDX_NAME
=
1
;
const
int64_t
SCHEMA3_IDX_HOST
=
2
;
const
int64_t
SCHEMA3_IDX_PATH
=
3
;
nsCOMPtr
<
mozIStorageStatement
>
select
;
rv
=
mDefaultDBState
-
>
syncConn
-
>
CreateStatement
(
NS_LITERAL_CSTRING
(
"
SELECT
id
name
host
path
FROM
moz_cookies
"
"
ORDER
BY
name
ASC
host
ASC
path
ASC
expiry
ASC
"
)
getter_AddRefs
(
select
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
nsCOMPtr
<
mozIStorageStatement
>
deleteExpired
;
rv
=
mDefaultDBState
-
>
syncConn
-
>
CreateStatement
(
NS_LITERAL_CSTRING
(
"
DELETE
FROM
moz_cookies
WHERE
id
=
:
id
"
)
getter_AddRefs
(
deleteExpired
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
bool
hasResult
;
rv
=
select
-
>
ExecuteStep
(
&
hasResult
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
if
(
hasResult
)
{
nsCString
name1
host1
path1
;
int64_t
id1
=
select
-
>
AsInt64
(
SCHEMA3_IDX_ID
)
;
select
-
>
GetUTF8String
(
SCHEMA3_IDX_NAME
name1
)
;
select
-
>
GetUTF8String
(
SCHEMA3_IDX_HOST
host1
)
;
select
-
>
GetUTF8String
(
SCHEMA3_IDX_PATH
path1
)
;
nsCString
name2
host2
path2
;
while
(
true
)
{
rv
=
select
-
>
ExecuteStep
(
&
hasResult
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
if
(
!
hasResult
)
break
;
int64_t
id2
=
select
-
>
AsInt64
(
SCHEMA3_IDX_ID
)
;
select
-
>
GetUTF8String
(
SCHEMA3_IDX_NAME
name2
)
;
select
-
>
GetUTF8String
(
SCHEMA3_IDX_HOST
host2
)
;
select
-
>
GetUTF8String
(
SCHEMA3_IDX_PATH
path2
)
;
if
(
name1
=
=
name2
&
&
host1
=
=
host2
&
&
path1
=
=
path2
)
{
mozStorageStatementScoper
scoper
(
deleteExpired
)
;
rv
=
deleteExpired
-
>
BindInt64ByName
(
NS_LITERAL_CSTRING
(
"
id
"
)
id1
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
rv
=
deleteExpired
-
>
ExecuteStep
(
&
hasResult
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
}
name1
=
name2
;
host1
=
host2
;
path1
=
path2
;
id1
=
id2
;
}
}
rv
=
mDefaultDBState
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
ALTER
TABLE
moz_cookies
ADD
creationTime
INTEGER
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
rv
=
mDefaultDBState
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
UPDATE
moz_cookies
SET
creationTime
=
"
"
(
SELECT
id
WHERE
id
=
moz_cookies
.
id
)
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
rv
=
mDefaultDBState
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
CREATE
UNIQUE
INDEX
moz_uniqueid
"
"
ON
moz_cookies
(
name
host
path
)
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
}
MOZ_FALLTHROUGH
;
case
4
:
{
rv
=
mDefaultDBState
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
ALTER
TABLE
moz_cookies
RENAME
TO
moz_cookies_old
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
rv
=
mDefaultDBState
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
DROP
INDEX
moz_basedomain
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
rv
=
CreateTableForSchemaVersion5
(
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
rv
=
mDefaultDBState
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
INSERT
INTO
moz_cookies
"
"
(
baseDomain
appId
inBrowserElement
name
value
host
path
"
"
expiry
"
"
lastAccessed
creationTime
isSecure
isHttpOnly
)
"
"
SELECT
baseDomain
0
0
name
value
host
path
expiry
"
"
lastAccessed
creationTime
isSecure
isHttpOnly
"
"
FROM
moz_cookies_old
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
rv
=
mDefaultDBState
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
DROP
TABLE
moz_cookies_old
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
COOKIE_LOGSTRING
(
LogLevel
:
:
Debug
(
"
Upgraded
database
to
schema
version
5
"
)
)
;
}
MOZ_FALLTHROUGH
;
case
5
:
{
rv
=
mDefaultDBState
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
ALTER
TABLE
moz_cookies
RENAME
TO
moz_cookies_old
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
rv
=
mDefaultDBState
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
DROP
INDEX
moz_basedomain
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
rv
=
CreateTableForSchemaVersion6
(
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
nsCOMPtr
<
mozIStorageFunction
>
convertToOriginAttrs
(
new
ConvertAppIdToOriginAttrsSQLFunction
(
)
)
;
NS_ENSURE_TRUE
(
convertToOriginAttrs
RESULT_RETRY
)
;
NS_NAMED_LITERAL_CSTRING
(
convertToOriginAttrsName
"
CONVERT_TO_ORIGIN_ATTRIBUTES
"
)
;
rv
=
mDefaultDBState
-
>
syncConn
-
>
CreateFunction
(
convertToOriginAttrsName
2
convertToOriginAttrs
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
rv
=
mDefaultDBState
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
INSERT
INTO
moz_cookies
"
"
(
baseDomain
originAttributes
name
value
host
path
expiry
"
"
lastAccessed
creationTime
isSecure
isHttpOnly
)
"
"
SELECT
baseDomain
"
"
CONVERT_TO_ORIGIN_ATTRIBUTES
(
appId
inBrowserElement
)
"
"
name
value
host
path
expiry
lastAccessed
creationTime
"
"
isSecure
isHttpOnly
"
"
FROM
moz_cookies_old
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
rv
=
mDefaultDBState
-
>
syncConn
-
>
RemoveFunction
(
convertToOriginAttrsName
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
rv
=
mDefaultDBState
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
DROP
TABLE
moz_cookies_old
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
COOKIE_LOGSTRING
(
LogLevel
:
:
Debug
(
"
Upgraded
database
to
schema
version
6
"
)
)
;
}
MOZ_FALLTHROUGH
;
case
6
:
{
rv
=
mDefaultDBState
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
ALTER
TABLE
moz_cookies
ADD
appId
INTEGER
DEFAULT
0
;
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
rv
=
mDefaultDBState
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
ALTER
TABLE
moz_cookies
ADD
inBrowserElement
INTEGER
DEFAULT
0
;
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
nsCOMPtr
<
mozIStorageFunction
>
setAppId
(
new
SetAppIdFromOriginAttributesSQLFunction
(
)
)
;
NS_ENSURE_TRUE
(
setAppId
RESULT_RETRY
)
;
NS_NAMED_LITERAL_CSTRING
(
setAppIdName
"
SET_APP_ID
"
)
;
rv
=
mDefaultDBState
-
>
syncConn
-
>
CreateFunction
(
setAppIdName
1
setAppId
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
nsCOMPtr
<
mozIStorageFunction
>
setInBrowser
(
new
SetInBrowserFromOriginAttributesSQLFunction
(
)
)
;
NS_ENSURE_TRUE
(
setInBrowser
RESULT_RETRY
)
;
NS_NAMED_LITERAL_CSTRING
(
setInBrowserName
"
SET_IN_BROWSER
"
)
;
rv
=
mDefaultDBState
-
>
syncConn
-
>
CreateFunction
(
setInBrowserName
1
setInBrowser
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
rv
=
mDefaultDBState
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
UPDATE
moz_cookies
SET
appId
=
SET_APP_ID
(
originAttributes
)
"
"
inBrowserElement
=
SET_IN_BROWSER
(
originAttributes
)
;
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
rv
=
mDefaultDBState
-
>
syncConn
-
>
RemoveFunction
(
setAppIdName
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
rv
=
mDefaultDBState
-
>
syncConn
-
>
RemoveFunction
(
setInBrowserName
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
COOKIE_LOGSTRING
(
LogLevel
:
:
Debug
(
"
Upgraded
database
to
schema
version
7
"
)
)
;
}
MOZ_FALLTHROUGH
;
case
7
:
{
rv
=
mDefaultDBState
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
DROP
INDEX
moz_basedomain
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
rv
=
CreateTableWorker
(
"
new_moz_cookies
"
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
rv
=
mDefaultDBState
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
INSERT
INTO
new_moz_cookies
(
"
"
id
"
"
baseDomain
"
"
originAttributes
"
"
name
"
"
value
"
"
host
"
"
path
"
"
expiry
"
"
lastAccessed
"
"
creationTime
"
"
isSecure
"
"
isHttpOnly
"
"
inBrowserElement
"
"
)
SELECT
"
"
id
"
"
baseDomain
"
"
originAttributes
"
"
name
"
"
value
"
"
host
"
"
path
"
"
expiry
"
"
lastAccessed
"
"
creationTime
"
"
isSecure
"
"
isHttpOnly
"
"
inBrowserElement
"
"
FROM
moz_cookies
;
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
rv
=
mDefaultDBState
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
DROP
TABLE
moz_cookies
;
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
rv
=
mDefaultDBState
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
ALTER
TABLE
new_moz_cookies
RENAME
TO
moz_cookies
;
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
rv
=
CreateIndex
(
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
COOKIE_LOGSTRING
(
LogLevel
:
:
Debug
(
"
Upgraded
database
to
schema
version
8
"
)
)
;
}
MOZ_FALLTHROUGH
;
case
8
:
{
rv
=
mDefaultDBState
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
ALTER
TABLE
moz_cookies
ADD
sameSite
INTEGER
"
)
)
;
COOKIE_LOGSTRING
(
LogLevel
:
:
Debug
(
"
Upgraded
database
to
schema
version
9
"
)
)
;
}
rv
=
mDefaultDBState
-
>
syncConn
-
>
SetSchemaVersion
(
COOKIES_SCHEMA_VERSION
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
MOZ_FALLTHROUGH
;
case
COOKIES_SCHEMA_VERSION
:
break
;
case
0
:
{
NS_WARNING
(
"
couldn
'
t
get
schema
version
!
"
)
;
rv
=
mDefaultDBState
-
>
syncConn
-
>
SetSchemaVersion
(
COOKIES_SCHEMA_VERSION
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
}
MOZ_FALLTHROUGH
;
default
:
{
nsCOMPtr
<
mozIStorageStatement
>
stmt
;
rv
=
mDefaultDBState
-
>
syncConn
-
>
CreateStatement
(
NS_LITERAL_CSTRING
(
"
SELECT
"
"
id
"
"
baseDomain
"
"
originAttributes
"
"
name
"
"
value
"
"
host
"
"
path
"
"
expiry
"
"
lastAccessed
"
"
creationTime
"
"
isSecure
"
"
isHttpOnly
"
"
sameSite
"
"
FROM
moz_cookies
"
)
getter_AddRefs
(
stmt
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
break
;
rv
=
mDefaultDBState
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
DROP
TABLE
moz_cookies
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
rv
=
CreateTable
(
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
}
break
;
}
}
if
(
aRecreateDB
)
{
return
RESULT_OK
;
}
if
(
tableExists
)
{
return
Read
(
)
;
}
nsCOMPtr
<
nsIRunnable
>
runnable
=
NS_NewRunnableFunction
(
"
TryInitDB
.
ImportCookies
"
[
]
{
NS_ENSURE_TRUE_VOID
(
gCookieService
)
;
NS_ENSURE_TRUE_VOID
(
gCookieService
-
>
mDefaultDBState
)
;
nsCOMPtr
<
nsIFile
>
oldCookieFile
;
nsresult
rv
=
NS_GetSpecialDirectory
(
NS_APP_USER_PROFILE_50_DIR
getter_AddRefs
(
oldCookieFile
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
DBState
*
initialState
=
gCookieService
-
>
mDBState
;
gCookieService
-
>
mDBState
=
gCookieService
-
>
mDefaultDBState
;
oldCookieFile
-
>
AppendNative
(
NS_LITERAL_CSTRING
(
OLD_COOKIE_FILE_NAME
)
)
;
gCookieService
-
>
ImportCookies
(
oldCookieFile
)
;
oldCookieFile
-
>
Remove
(
false
)
;
gCookieService
-
>
mDBState
=
initialState
;
}
)
;
NS_DispatchToMainThread
(
runnable
)
;
return
RESULT_OK
;
}
void
nsCookieService
:
:
InitDBConn
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
mInitializedDBStates
|
|
mInitializedDBConn
|
|
!
mDefaultDBState
)
{
return
;
}
for
(
uint32_t
i
=
0
;
i
<
mReadArray
.
Length
(
)
;
+
+
i
)
{
CookieDomainTuple
&
tuple
=
mReadArray
[
i
]
;
RefPtr
<
nsCookie
>
cookie
=
nsCookie
:
:
Create
(
tuple
.
cookie
-
>
name
tuple
.
cookie
-
>
value
tuple
.
cookie
-
>
host
tuple
.
cookie
-
>
path
tuple
.
cookie
-
>
expiry
tuple
.
cookie
-
>
lastAccessed
tuple
.
cookie
-
>
creationTime
false
tuple
.
cookie
-
>
isSecure
tuple
.
cookie
-
>
isHttpOnly
tuple
.
cookie
-
>
originAttributes
tuple
.
cookie
-
>
sameSite
)
;
AddCookieToList
(
tuple
.
key
cookie
mDefaultDBState
nullptr
false
)
;
}
if
(
NS_FAILED
(
InitDBConnInternal
(
)
)
)
{
COOKIE_LOGSTRING
(
LogLevel
:
:
Warning
(
"
InitDBConn
(
)
:
retrying
InitDBConnInternal
(
)
"
)
)
;
CleanupCachedStatements
(
)
;
CleanupDefaultDBConnection
(
)
;
if
(
NS_FAILED
(
InitDBConnInternal
(
)
)
)
{
COOKIE_LOGSTRING
(
LogLevel
:
:
Warning
(
"
InitDBConn
(
)
:
InitDBConnInternal
(
)
failed
closing
connection
"
)
)
;
CleanupCachedStatements
(
)
;
CleanupDefaultDBConnection
(
)
;
}
}
mInitializedDBConn
=
true
;
COOKIE_LOGSTRING
(
LogLevel
:
:
Debug
(
"
InitDBConn
(
)
:
mInitializedDBConn
=
true
"
)
)
;
mEndInitDBConn
=
mozilla
:
:
TimeStamp
:
:
Now
(
)
;
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
os
)
{
os
-
>
NotifyObservers
(
nullptr
"
cookie
-
db
-
read
"
nullptr
)
;
mReadArray
.
Clear
(
)
;
}
}
nsresult
nsCookieService
:
:
InitDBConnInternal
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsresult
rv
=
mStorageService
-
>
OpenUnsharedDatabase
(
mDefaultDBState
-
>
cookieFile
getter_AddRefs
(
mDefaultDBState
-
>
dbConn
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mDefaultDBState
-
>
insertListener
=
new
InsertCookieDBListener
(
mDefaultDBState
)
;
mDefaultDBState
-
>
updateListener
=
new
UpdateCookieDBListener
(
mDefaultDBState
)
;
mDefaultDBState
-
>
removeListener
=
new
RemoveCookieDBListener
(
mDefaultDBState
)
;
mDefaultDBState
-
>
closeListener
=
new
CloseCookieDBListener
(
mDefaultDBState
)
;
mDefaultDBState
-
>
dbConn
-
>
SetGrowthIncrement
(
512
*
1024
EmptyCString
(
)
)
;
mDefaultDBState
-
>
dbConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
PRAGMA
synchronous
=
OFF
"
)
)
;
mDefaultDBState
-
>
dbConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
MOZ_STORAGE_UNIQUIFY_QUERY_STR
"
PRAGMA
journal_mode
=
WAL
"
)
)
;
mDefaultDBState
-
>
dbConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
PRAGMA
wal_autocheckpoint
=
16
"
)
)
;
rv
=
mDefaultDBState
-
>
dbConn
-
>
CreateAsyncStatement
(
NS_LITERAL_CSTRING
(
"
INSERT
INTO
moz_cookies
(
"
"
baseDomain
"
"
originAttributes
"
"
name
"
"
value
"
"
host
"
"
path
"
"
expiry
"
"
lastAccessed
"
"
creationTime
"
"
isSecure
"
"
isHttpOnly
"
"
sameSite
"
"
)
VALUES
(
"
"
:
baseDomain
"
"
:
originAttributes
"
"
:
name
"
"
:
value
"
"
:
host
"
"
:
path
"
"
:
expiry
"
"
:
lastAccessed
"
"
:
creationTime
"
"
:
isSecure
"
"
:
isHttpOnly
"
"
:
sameSite
"
"
)
"
)
getter_AddRefs
(
mDefaultDBState
-
>
stmtInsert
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mDefaultDBState
-
>
dbConn
-
>
CreateAsyncStatement
(
NS_LITERAL_CSTRING
(
"
DELETE
FROM
moz_cookies
"
"
WHERE
name
=
:
name
AND
host
=
:
host
AND
path
=
:
path
"
"
AND
originAttributes
=
:
originAttributes
"
)
getter_AddRefs
(
mDefaultDBState
-
>
stmtDelete
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mDefaultDBState
-
>
dbConn
-
>
CreateAsyncStatement
(
NS_LITERAL_CSTRING
(
"
UPDATE
moz_cookies
SET
lastAccessed
=
:
lastAccessed
"
"
WHERE
name
=
:
name
AND
host
=
:
host
AND
path
=
:
path
"
"
AND
originAttributes
=
:
originAttributes
"
)
getter_AddRefs
(
mDefaultDBState
-
>
stmtUpdate
)
)
;
return
rv
;
}
nsresult
nsCookieService
:
:
CreateTableWorker
(
const
char
*
aName
)
{
nsAutoCString
command
(
"
CREATE
TABLE
"
)
;
command
.
Append
(
aName
)
;
command
.
AppendLiteral
(
"
(
"
"
id
INTEGER
PRIMARY
KEY
"
"
baseDomain
TEXT
"
"
originAttributes
TEXT
NOT
NULL
DEFAULT
'
'
"
"
name
TEXT
"
"
value
TEXT
"
"
host
TEXT
"
"
path
TEXT
"
"
expiry
INTEGER
"
"
lastAccessed
INTEGER
"
"
creationTime
INTEGER
"
"
isSecure
INTEGER
"
"
isHttpOnly
INTEGER
"
"
inBrowserElement
INTEGER
DEFAULT
0
"
"
sameSite
INTEGER
DEFAULT
0
"
"
CONSTRAINT
moz_uniqueid
UNIQUE
(
name
host
path
originAttributes
)
"
"
)
"
)
;
return
mDefaultDBState
-
>
syncConn
-
>
ExecuteSimpleSQL
(
command
)
;
}
nsresult
nsCookieService
:
:
CreateTable
(
)
{
nsresult
rv
=
mDefaultDBState
-
>
syncConn
-
>
SetSchemaVersion
(
COOKIES_SCHEMA_VERSION
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
rv
=
CreateTableWorker
(
"
moz_cookies
"
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
return
CreateIndex
(
)
;
}
nsresult
nsCookieService
:
:
CreateIndex
(
)
{
return
mDefaultDBState
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
CREATE
INDEX
moz_basedomain
ON
moz_cookies
(
baseDomain
"
"
originAttributes
)
"
)
)
;
}
nsresult
nsCookieService
:
:
CreateTableForSchemaVersion6
(
)
{
nsresult
rv
=
mDefaultDBState
-
>
syncConn
-
>
SetSchemaVersion
(
6
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
rv
=
mDefaultDBState
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
CREATE
TABLE
moz_cookies
(
"
"
id
INTEGER
PRIMARY
KEY
"
"
baseDomain
TEXT
"
"
originAttributes
TEXT
NOT
NULL
DEFAULT
'
'
"
"
name
TEXT
"
"
value
TEXT
"
"
host
TEXT
"
"
path
TEXT
"
"
expiry
INTEGER
"
"
lastAccessed
INTEGER
"
"
creationTime
INTEGER
"
"
isSecure
INTEGER
"
"
isHttpOnly
INTEGER
"
"
CONSTRAINT
moz_uniqueid
UNIQUE
(
name
host
path
originAttributes
)
"
"
)
"
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
return
mDefaultDBState
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
CREATE
INDEX
moz_basedomain
ON
moz_cookies
(
baseDomain
"
"
originAttributes
)
"
)
)
;
}
nsresult
nsCookieService
:
:
CreateTableForSchemaVersion5
(
)
{
nsresult
rv
=
mDefaultDBState
-
>
syncConn
-
>
SetSchemaVersion
(
5
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
rv
=
mDefaultDBState
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
CREATE
TABLE
moz_cookies
(
"
"
id
INTEGER
PRIMARY
KEY
"
"
baseDomain
TEXT
"
"
appId
INTEGER
DEFAULT
0
"
"
inBrowserElement
INTEGER
DEFAULT
0
"
"
name
TEXT
"
"
value
TEXT
"
"
host
TEXT
"
"
path
TEXT
"
"
expiry
INTEGER
"
"
lastAccessed
INTEGER
"
"
creationTime
INTEGER
"
"
isSecure
INTEGER
"
"
isHttpOnly
INTEGER
"
"
CONSTRAINT
moz_uniqueid
UNIQUE
(
name
host
path
"
"
appId
inBrowserElement
)
"
"
)
"
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
return
mDefaultDBState
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
CREATE
INDEX
moz_basedomain
ON
moz_cookies
(
baseDomain
"
"
appId
"
"
inBrowserElement
)
"
)
)
;
}
void
nsCookieService
:
:
CloseDBStates
(
)
{
if
(
!
mDBState
)
{
return
;
}
if
(
mThread
)
{
mThread
-
>
Shutdown
(
)
;
mThread
=
nullptr
;
}
mPrivateDBState
=
nullptr
;
mDBState
=
nullptr
;
if
(
!
mDefaultDBState
)
return
;
CleanupCachedStatements
(
)
;
if
(
mDefaultDBState
-
>
dbConn
)
{
mDefaultDBState
-
>
dbConn
-
>
AsyncClose
(
mDefaultDBState
-
>
closeListener
)
;
}
CleanupDefaultDBConnection
(
)
;
mDefaultDBState
=
nullptr
;
mInitializedDBConn
=
false
;
mInitializedDBStates
=
false
;
}
void
nsCookieService
:
:
CleanupCachedStatements
(
)
{
mDefaultDBState
-
>
stmtInsert
=
nullptr
;
mDefaultDBState
-
>
stmtDelete
=
nullptr
;
mDefaultDBState
-
>
stmtUpdate
=
nullptr
;
}
void
nsCookieService
:
:
CleanupDefaultDBConnection
(
)
{
MOZ_ASSERT
(
!
mDefaultDBState
-
>
stmtInsert
"
stmtInsert
has
been
cleaned
up
"
)
;
MOZ_ASSERT
(
!
mDefaultDBState
-
>
stmtDelete
"
stmtDelete
has
been
cleaned
up
"
)
;
MOZ_ASSERT
(
!
mDefaultDBState
-
>
stmtUpdate
"
stmtUpdate
has
been
cleaned
up
"
)
;
mDefaultDBState
-
>
dbConn
=
nullptr
;
mDefaultDBState
-
>
insertListener
=
nullptr
;
mDefaultDBState
-
>
updateListener
=
nullptr
;
mDefaultDBState
-
>
removeListener
=
nullptr
;
mDefaultDBState
-
>
closeListener
=
nullptr
;
}
void
nsCookieService
:
:
HandleDBClosed
(
DBState
*
aDBState
)
{
COOKIE_LOGSTRING
(
LogLevel
:
:
Debug
(
"
HandleDBClosed
(
)
:
DBState
%
p
closed
"
aDBState
)
)
;
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
switch
(
aDBState
-
>
corruptFlag
)
{
case
DBState
:
:
OK
:
{
if
(
os
)
{
os
-
>
NotifyObservers
(
nullptr
"
cookie
-
db
-
closed
"
nullptr
)
;
}
break
;
}
case
DBState
:
:
CLOSING_FOR_REBUILD
:
{
RebuildCorruptDB
(
aDBState
)
;
break
;
}
case
DBState
:
:
REBUILDING
:
{
nsCOMPtr
<
nsIFile
>
backupFile
;
aDBState
-
>
cookieFile
-
>
Clone
(
getter_AddRefs
(
backupFile
)
)
;
nsresult
rv
=
backupFile
-
>
MoveToNative
(
nullptr
NS_LITERAL_CSTRING
(
COOKIES_FILE
"
.
bak
-
rebuild
"
)
)
;
COOKIE_LOGSTRING
(
LogLevel
:
:
Warning
(
"
HandleDBClosed
(
)
:
DBState
%
p
encountered
error
"
"
rebuilding
db
;
move
to
"
"
'
cookies
.
sqlite
.
bak
-
rebuild
'
gave
rv
0x
%
"
PRIx32
aDBState
static_cast
<
uint32_t
>
(
rv
)
)
)
;
if
(
os
)
{
os
-
>
NotifyObservers
(
nullptr
"
cookie
-
db
-
closed
"
nullptr
)
;
}
break
;
}
}
}
void
nsCookieService
:
:
HandleCorruptDB
(
DBState
*
aDBState
)
{
if
(
mDefaultDBState
!
=
aDBState
)
{
COOKIE_LOGSTRING
(
LogLevel
:
:
Warning
(
"
HandleCorruptDB
(
)
:
DBState
%
p
is
already
closed
aborting
"
aDBState
)
)
;
return
;
}
COOKIE_LOGSTRING
(
LogLevel
:
:
Debug
(
"
HandleCorruptDB
(
)
:
DBState
%
p
has
corruptFlag
%
u
"
aDBState
aDBState
-
>
corruptFlag
)
)
;
switch
(
mDefaultDBState
-
>
corruptFlag
)
{
case
DBState
:
:
OK
:
{
mDefaultDBState
-
>
corruptFlag
=
DBState
:
:
CLOSING_FOR_REBUILD
;
CleanupCachedStatements
(
)
;
mDefaultDBState
-
>
dbConn
-
>
AsyncClose
(
mDefaultDBState
-
>
closeListener
)
;
CleanupDefaultDBConnection
(
)
;
break
;
}
case
DBState
:
:
CLOSING_FOR_REBUILD
:
{
return
;
}
case
DBState
:
:
REBUILDING
:
{
CleanupCachedStatements
(
)
;
if
(
mDefaultDBState
-
>
dbConn
)
{
mDefaultDBState
-
>
dbConn
-
>
AsyncClose
(
mDefaultDBState
-
>
closeListener
)
;
}
CleanupDefaultDBConnection
(
)
;
break
;
}
}
}
void
nsCookieService
:
:
RebuildCorruptDB
(
DBState
*
aDBState
)
{
NS_ASSERTION
(
!
aDBState
-
>
dbConn
"
shouldn
'
t
have
an
open
db
connection
"
)
;
NS_ASSERTION
(
aDBState
-
>
corruptFlag
=
=
DBState
:
:
CLOSING_FOR_REBUILD
"
should
be
in
CLOSING_FOR_REBUILD
state
"
)
;
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
aDBState
-
>
corruptFlag
=
DBState
:
:
REBUILDING
;
if
(
mDefaultDBState
!
=
aDBState
)
{
COOKIE_LOGSTRING
(
LogLevel
:
:
Warning
(
"
RebuildCorruptDB
(
)
:
DBState
%
p
is
stale
aborting
"
aDBState
)
)
;
if
(
os
)
{
os
-
>
NotifyObservers
(
nullptr
"
cookie
-
db
-
closed
"
nullptr
)
;
}
return
;
}
COOKIE_LOGSTRING
(
LogLevel
:
:
Debug
(
"
RebuildCorruptDB
(
)
:
creating
new
database
"
)
)
;
nsCOMPtr
<
nsIRunnable
>
runnable
=
NS_NewRunnableFunction
(
"
RebuildCorruptDB
.
TryInitDB
"
[
]
{
NS_ENSURE_TRUE_VOID
(
gCookieService
&
&
gCookieService
-
>
mDefaultDBState
)
;
OpenDBResult
result
=
gCookieService
-
>
TryInitDB
(
true
)
;
nsCOMPtr
<
nsIRunnable
>
innerRunnable
=
NS_NewRunnableFunction
(
"
RebuildCorruptDB
.
TryInitDBComplete
"
[
result
]
{
NS_ENSURE_TRUE_VOID
(
gCookieService
&
&
gCookieService
-
>
mDefaultDBState
)
;
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
result
!
=
RESULT_OK
)
{
COOKIE_LOGSTRING
(
LogLevel
:
:
Warning
(
"
RebuildCorruptDB
(
)
:
TryInitDB
(
)
failed
with
result
%
u
"
result
)
)
;
gCookieService
-
>
CleanupCachedStatements
(
)
;
gCookieService
-
>
CleanupDefaultDBConnection
(
)
;
gCookieService
-
>
mDefaultDBState
-
>
corruptFlag
=
DBState
:
:
OK
;
if
(
os
)
{
os
-
>
NotifyObservers
(
nullptr
"
cookie
-
db
-
closed
"
nullptr
)
;
}
return
;
}
if
(
os
)
{
os
-
>
NotifyObservers
(
nullptr
"
cookie
-
db
-
rebuilding
"
nullptr
)
;
}
gCookieService
-
>
InitDBConnInternal
(
)
;
mozIStorageAsyncStatement
*
stmt
=
gCookieService
-
>
mDefaultDBState
-
>
stmtInsert
;
nsCOMPtr
<
mozIStorageBindingParamsArray
>
paramsArray
;
stmt
-
>
NewBindingParamsArray
(
getter_AddRefs
(
paramsArray
)
)
;
for
(
auto
iter
=
gCookieService
-
>
mDefaultDBState
-
>
hostTable
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
nsCookieEntry
*
entry
=
iter
.
Get
(
)
;
const
nsCookieEntry
:
:
ArrayType
&
cookies
=
entry
-
>
GetCookies
(
)
;
for
(
nsCookieEntry
:
:
IndexType
i
=
0
;
i
<
cookies
.
Length
(
)
;
+
+
i
)
{
nsCookie
*
cookie
=
cookies
[
i
]
;
if
(
!
cookie
-
>
IsSession
(
)
)
{
bindCookieParameters
(
paramsArray
nsCookieKey
(
entry
)
cookie
)
;
}
}
}
uint32_t
length
;
paramsArray
-
>
GetLength
(
&
length
)
;
if
(
length
=
=
0
)
{
COOKIE_LOGSTRING
(
LogLevel
:
:
Debug
(
"
RebuildCorruptDB
(
)
:
nothing
to
write
rebuild
complete
"
)
)
;
gCookieService
-
>
mDefaultDBState
-
>
corruptFlag
=
DBState
:
:
OK
;
return
;
}
DebugOnly
<
nsresult
>
rv
=
stmt
-
>
BindParameters
(
paramsArray
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
nsCOMPtr
<
mozIStoragePendingStatement
>
handle
;
rv
=
stmt
-
>
ExecuteAsync
(
gCookieService
-
>
mDefaultDBState
-
>
insertListener
getter_AddRefs
(
handle
)
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
}
)
;
NS_DispatchToMainThread
(
innerRunnable
)
;
}
)
;
mThread
-
>
Dispatch
(
runnable
NS_DISPATCH_NORMAL
)
;
}
nsCookieService
:
:
~
nsCookieService
(
)
{
CloseDBStates
(
)
;
UnregisterWeakMemoryReporter
(
this
)
;
gCookieService
=
nullptr
;
}
NS_IMETHODIMP
nsCookieService
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
if
(
!
strcmp
(
aTopic
"
profile
-
before
-
change
"
)
)
{
CloseDBStates
(
)
;
}
else
if
(
!
strcmp
(
aTopic
"
profile
-
do
-
change
"
)
)
{
NS_ASSERTION
(
!
mDefaultDBState
"
shouldn
'
t
have
a
default
DBState
"
)
;
NS_ASSERTION
(
!
mPrivateDBState
"
shouldn
'
t
have
a
private
DBState
"
)
;
InitDBStates
(
)
;
}
else
if
(
!
strcmp
(
aTopic
NS_PREFBRANCH_PREFCHANGE_TOPIC_ID
)
)
{
nsCOMPtr
<
nsIPrefBranch
>
prefBranch
=
do_QueryInterface
(
aSubject
)
;
if
(
prefBranch
)
PrefChanged
(
prefBranch
)
;
}
else
if
(
!
strcmp
(
aTopic
"
last
-
pb
-
context
-
exited
"
)
)
{
mozilla
:
:
OriginAttributesPattern
pattern
;
pattern
.
mPrivateBrowsingId
.
Construct
(
1
)
;
RemoveCookiesWithOriginAttributes
(
pattern
EmptyCString
(
)
)
;
mPrivateDBState
=
new
DBState
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsCookieService
:
:
GetCookieString
(
nsIURI
*
aHostURI
nsIChannel
*
aChannel
char
*
*
aCookie
)
{
return
GetCookieStringCommon
(
aHostURI
aChannel
false
aCookie
)
;
}
NS_IMETHODIMP
nsCookieService
:
:
GetCookieStringFromHttp
(
nsIURI
*
aHostURI
nsIURI
*
aFirstURI
nsIChannel
*
aChannel
char
*
*
aCookie
)
{
return
GetCookieStringCommon
(
aHostURI
aChannel
true
aCookie
)
;
}
nsresult
nsCookieService
:
:
GetCookieStringCommon
(
nsIURI
*
aHostURI
nsIChannel
*
aChannel
bool
aHttpBound
char
*
*
aCookie
)
{
NS_ENSURE_ARG
(
aHostURI
)
;
NS_ENSURE_ARG
(
aCookie
)
;
bool
isForeign
=
true
;
mThirdPartyUtil
-
>
IsThirdPartyChannel
(
aChannel
aHostURI
&
isForeign
)
;
bool
isTrackingResource
=
false
;
bool
firstPartyStorageAccessGranted
=
false
;
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
do_QueryInterface
(
aChannel
)
;
if
(
httpChannel
)
{
isTrackingResource
=
httpChannel
-
>
GetIsTrackingResource
(
)
;
if
(
AntiTrackingCommon
:
:
IsFirstPartyStorageAccessGrantedFor
(
httpChannel
aHostURI
nullptr
)
)
{
firstPartyStorageAccessGranted
=
true
;
}
}
OriginAttributes
attrs
;
if
(
aChannel
)
{
NS_GetOriginAttributes
(
aChannel
attrs
)
;
}
bool
isSafeTopLevelNav
=
NS_IsSafeTopLevelNav
(
aChannel
)
;
bool
isSameSiteForeign
=
NS_IsSameSiteForeign
(
aChannel
aHostURI
)
;
nsAutoCString
result
;
GetCookieStringInternal
(
aHostURI
aChannel
isForeign
isTrackingResource
firstPartyStorageAccessGranted
isSafeTopLevelNav
isSameSiteForeign
aHttpBound
attrs
result
)
;
*
aCookie
=
result
.
IsEmpty
(
)
?
nullptr
:
ToNewCString
(
result
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsCookieService
:
:
SetCookieString
(
nsIURI
*
aHostURI
nsIPrompt
*
aPrompt
const
char
*
aCookieHeader
nsIChannel
*
aChannel
)
{
MOZ_ASSERT
(
!
aPrompt
)
;
if
(
aPrompt
)
{
nsCOMPtr
<
nsIConsoleService
>
aConsoleService
=
do_GetService
(
"
mozilla
.
org
/
consoleservice
;
1
"
)
;
if
(
aConsoleService
)
{
aConsoleService
-
>
LogStringMessage
(
u
"
Non
-
null
prompt
ignored
by
nsCookieService
.
"
)
;
}
}
return
SetCookieStringCommon
(
aHostURI
aCookieHeader
nullptr
aChannel
false
)
;
}
NS_IMETHODIMP
nsCookieService
:
:
SetCookieStringFromHttp
(
nsIURI
*
aHostURI
nsIURI
*
aFirstURI
nsIPrompt
*
aPrompt
const
char
*
aCookieHeader
const
char
*
aServerTime
nsIChannel
*
aChannel
)
{
MOZ_ASSERT
(
!
aPrompt
)
;
if
(
aPrompt
)
{
nsCOMPtr
<
nsIConsoleService
>
aConsoleService
=
do_GetService
(
"
mozilla
.
org
/
consoleservice
;
1
"
)
;
if
(
aConsoleService
)
{
aConsoleService
-
>
LogStringMessage
(
u
"
Non
-
null
prompt
ignored
by
nsCookieService
.
"
)
;
}
}
return
SetCookieStringCommon
(
aHostURI
aCookieHeader
aServerTime
aChannel
true
)
;
}
int64_t
nsCookieService
:
:
ParseServerTime
(
const
nsCString
&
aServerTime
)
{
PRTime
tempServerTime
;
int64_t
serverTime
;
PRStatus
result
=
PR_ParseTimeString
(
aServerTime
.
get
(
)
true
&
tempServerTime
)
;
if
(
result
=
=
PR_SUCCESS
)
{
serverTime
=
tempServerTime
/
int64_t
(
PR_USEC_PER_SEC
)
;
}
else
{
serverTime
=
PR_Now
(
)
/
PR_USEC_PER_SEC
;
}
return
serverTime
;
}
nsresult
nsCookieService
:
:
SetCookieStringCommon
(
nsIURI
*
aHostURI
const
char
*
aCookieHeader
const
char
*
aServerTime
nsIChannel
*
aChannel
bool
aFromHttp
)
{
NS_ENSURE_ARG
(
aHostURI
)
;
NS_ENSURE_ARG
(
aCookieHeader
)
;
bool
isForeign
=
true
;
mThirdPartyUtil
-
>
IsThirdPartyChannel
(
aChannel
aHostURI
&
isForeign
)
;
bool
isTrackingResource
=
false
;
bool
firstPartyStorageAccessGranted
=
false
;
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
do_QueryInterface
(
aChannel
)
;
if
(
httpChannel
)
{
isTrackingResource
=
httpChannel
-
>
GetIsTrackingResource
(
)
;
if
(
AntiTrackingCommon
:
:
IsFirstPartyStorageAccessGrantedFor
(
httpChannel
aHostURI
nullptr
)
)
{
firstPartyStorageAccessGranted
=
true
;
}
}
OriginAttributes
attrs
;
if
(
aChannel
)
{
NS_GetOriginAttributes
(
aChannel
attrs
)
;
}
nsDependentCString
cookieString
(
aCookieHeader
)
;
nsDependentCString
serverTime
(
aServerTime
?
aServerTime
:
"
"
)
;
SetCookieStringInternal
(
aHostURI
isForeign
isTrackingResource
firstPartyStorageAccessGranted
cookieString
serverTime
aFromHttp
attrs
aChannel
)
;
return
NS_OK
;
}
void
nsCookieService
:
:
SetCookieStringInternal
(
nsIURI
*
aHostURI
bool
aIsForeign
bool
aIsTrackingResource
bool
aFirstPartyStorageAccessGranted
nsDependentCString
&
aCookieHeader
const
nsCString
&
aServerTime
bool
aFromHttp
const
OriginAttributes
&
aOriginAttrs
nsIChannel
*
aChannel
)
{
NS_ASSERTION
(
aHostURI
"
null
host
!
"
)
;
if
(
!
mDBState
)
{
NS_WARNING
(
"
No
DBState
!
Profile
already
closed
?
"
)
;
return
;
}
EnsureReadComplete
(
true
)
;
AutoRestore
<
DBState
*
>
savePrevDBState
(
mDBState
)
;
mDBState
=
(
aOriginAttrs
.
mPrivateBrowsingId
>
0
)
?
mPrivateDBState
:
mDefaultDBState
;
bool
requireHostMatch
;
nsAutoCString
baseDomain
;
nsresult
rv
=
GetBaseDomain
(
mTLDService
aHostURI
baseDomain
requireHostMatch
)
;
if
(
NS_FAILED
(
rv
)
)
{
COOKIE_LOGFAILURE
(
SET_COOKIE
aHostURI
aCookieHeader
"
couldn
'
t
get
base
domain
from
URI
"
)
;
return
;
}
nsCookieKey
key
(
baseDomain
aOriginAttrs
)
;
uint32_t
priorCookieCount
=
0
;
uint32_t
rejectedReason
=
0
;
nsAutoCString
hostFromURI
;
aHostURI
-
>
GetHost
(
hostFromURI
)
;
CountCookiesFromHost
(
hostFromURI
&
priorCookieCount
)
;
CookieStatus
cookieStatus
=
CheckPrefs
(
mPermissionService
mCookieBehavior
mThirdPartySession
mThirdPartyNonsecureSession
aHostURI
aIsForeign
aIsTrackingResource
aFirstPartyStorageAccessGranted
aCookieHeader
.
get
(
)
priorCookieCount
aOriginAttrs
&
rejectedReason
)
;
MOZ_ASSERT_IF
(
rejectedReason
cookieStatus
=
=
STATUS_REJECTED
)
;
switch
(
cookieStatus
)
{
case
STATUS_REJECTED
:
NotifyRejected
(
aHostURI
aChannel
rejectedReason
OPERATION_WRITE
)
;
if
(
aIsForeign
)
{
NotifyThirdParty
(
aHostURI
false
aChannel
)
;
}
return
;
case
STATUS_REJECTED_WITH_ERROR
:
return
;
case
STATUS_ACCEPTED
:
case
STATUS_ACCEPT_SESSION
:
NotifyAccepted
(
aChannel
)
;
if
(
aIsForeign
)
{
NotifyThirdParty
(
aHostURI
true
aChannel
)
;
}
break
;
default
:
break
;
}
int64_t
serverTime
=
ParseServerTime
(
aServerTime
)
;
while
(
SetCookieInternal
(
aHostURI
key
requireHostMatch
cookieStatus
aCookieHeader
serverTime
aFromHttp
aChannel
)
)
{
if
(
!
aFromHttp
)
break
;
}
}
void
nsCookieService
:
:
NotifyAccepted
(
nsIChannel
*
aChannel
)
{
AntiTrackingCommon
:
:
NotifyBlockingDecision
(
aChannel
AntiTrackingCommon
:
:
BlockingDecision
:
:
eAllow
0
)
;
}
void
nsCookieService
:
:
NotifyRejected
(
nsIURI
*
aHostURI
nsIChannel
*
aChannel
uint32_t
aRejectedReason
CookieOperation
aOperation
)
{
if
(
aOperation
=
=
OPERATION_WRITE
)
{
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
os
)
{
os
-
>
NotifyObservers
(
aHostURI
"
cookie
-
rejected
"
nullptr
)
;
}
}
else
{
MOZ_ASSERT
(
aOperation
=
=
OPERATION_READ
)
;
}
AntiTrackingCommon
:
:
NotifyBlockingDecision
(
aChannel
AntiTrackingCommon
:
:
BlockingDecision
:
:
eBlock
aRejectedReason
)
;
}
void
nsCookieService
:
:
NotifyThirdParty
(
nsIURI
*
aHostURI
bool
aIsAccepted
nsIChannel
*
aChannel
)
{
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
!
os
)
{
return
;
}
const
char
*
topic
;
if
(
mDBState
!
=
mPrivateDBState
)
{
if
(
aIsAccepted
)
{
topic
=
"
third
-
party
-
cookie
-
accepted
"
;
}
else
{
topic
=
"
third
-
party
-
cookie
-
rejected
"
;
}
}
else
{
if
(
aIsAccepted
)
{
topic
=
"
private
-
third
-
party
-
cookie
-
accepted
"
;
}
else
{
topic
=
"
private
-
third
-
party
-
cookie
-
rejected
"
;
}
}
do
{
if
(
!
aChannel
)
{
break
;
}
nsCOMPtr
<
nsIURI
>
channelURI
;
nsresult
rv
=
aChannel
-
>
GetURI
(
getter_AddRefs
(
channelURI
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
break
;
}
nsAutoCString
referringHost
;
rv
=
channelURI
-
>
GetHost
(
referringHost
)
;
if
(
NS_FAILED
(
rv
)
)
{
break
;
}
nsAutoString
referringHostUTF16
=
NS_ConvertUTF8toUTF16
(
referringHost
)
;
os
-
>
NotifyObservers
(
aHostURI
topic
referringHostUTF16
.
get
(
)
)
;
return
;
}
while
(
false
)
;
os
-
>
NotifyObservers
(
aHostURI
topic
u
"
?
"
)
;
}
void
nsCookieService
:
:
NotifyChanged
(
nsISupports
*
aSubject
const
char16_t
*
aData
bool
aOldCookieIsSession
bool
aFromHttp
)
{
const
char
*
topic
=
mDBState
=
=
mPrivateDBState
?
"
private
-
cookie
-
changed
"
:
"
cookie
-
changed
"
;
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
!
os
)
{
return
;
}
os
-
>
NotifyObservers
(
aSubject
topic
aData
)
;
if
(
mDBState
=
=
mPrivateDBState
)
{
return
;
}
if
(
NS_LITERAL_STRING
(
"
changed
"
)
.
Equals
(
aData
)
|
|
NS_LITERAL_STRING
(
"
deleted
"
)
.
Equals
(
aData
)
|
|
NS_LITERAL_STRING
(
"
added
"
)
.
Equals
(
aData
)
)
{
nsCOMPtr
<
nsICookie
>
xpcCookie
=
do_QueryInterface
(
aSubject
)
;
MOZ_ASSERT
(
xpcCookie
)
;
auto
cookie
=
static_cast
<
nsCookie
*
>
(
xpcCookie
.
get
(
)
)
;
if
(
!
cookie
-
>
IsSession
(
)
&
&
!
aOldCookieIsSession
)
{
return
;
}
}
os
-
>
NotifyObservers
(
aSubject
"
session
-
cookie
-
changed
"
aData
)
;
}
already_AddRefed
<
nsIArray
>
nsCookieService
:
:
CreatePurgeList
(
nsICookie2
*
aCookie
)
{
nsCOMPtr
<
nsIMutableArray
>
removedList
=
do_CreateInstance
(
NS_ARRAY_CONTRACTID
)
;
removedList
-
>
AppendElement
(
aCookie
)
;
return
removedList
.
forget
(
)
;
}
void
nsCookieService
:
:
CreateOrUpdatePurgeList
(
nsIArray
*
*
aPurgedList
nsICookie2
*
aCookie
)
{
if
(
!
*
aPurgedList
)
{
COOKIE_LOGSTRING
(
LogLevel
:
:
Debug
(
"
Creating
new
purge
list
"
)
)
;
nsCOMPtr
<
nsIArray
>
purgedList
=
CreatePurgeList
(
aCookie
)
;
purgedList
.
forget
(
aPurgedList
)
;
return
;
}
nsCOMPtr
<
nsIMutableArray
>
purgedList
=
do_QueryInterface
(
*
aPurgedList
)
;
if
(
purgedList
)
{
COOKIE_LOGSTRING
(
LogLevel
:
:
Debug
(
"
Updating
existing
purge
list
"
)
)
;
purgedList
-
>
AppendElement
(
aCookie
)
;
}
else
{
COOKIE_LOGSTRING
(
LogLevel
:
:
Debug
(
"
Could
not
QI
aPurgedList
!
"
)
)
;
}
}
NS_IMETHODIMP
nsCookieService
:
:
RunInTransaction
(
nsICookieTransactionCallback
*
aCallback
)
{
NS_ENSURE_ARG
(
aCallback
)
;
if
(
!
mDBState
)
{
NS_WARNING
(
"
No
DBState
!
Profile
already
closed
?
"
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
EnsureReadComplete
(
true
)
;
if
(
NS_WARN_IF
(
!
mDefaultDBState
-
>
dbConn
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
mozStorageTransaction
transaction
(
mDefaultDBState
-
>
dbConn
true
)
;
if
(
NS_FAILED
(
aCallback
-
>
Callback
(
)
)
)
{
Unused
<
<
transaction
.
Rollback
(
)
;
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
void
nsCookieService
:
:
PrefChanged
(
nsIPrefBranch
*
aPrefBranch
)
{
int32_t
val
;
if
(
NS_SUCCEEDED
(
aPrefBranch
-
>
GetIntPref
(
kPrefCookieBehavior
&
val
)
)
)
mCookieBehavior
=
(
uint8_t
)
LIMIT
(
val
0
nsICookieService
:
:
BEHAVIOR_LAST
0
)
;
if
(
NS_SUCCEEDED
(
aPrefBranch
-
>
GetIntPref
(
kPrefMaxNumberOfCookies
&
val
)
)
)
mMaxNumberOfCookies
=
(
uint16_t
)
LIMIT
(
val
1
0xFFFF
kMaxNumberOfCookies
)
;
if
(
NS_SUCCEEDED
(
aPrefBranch
-
>
GetIntPref
(
kPrefCookieQuotaPerHost
&
val
)
)
)
{
mCookieQuotaPerHost
=
(
uint16_t
)
LIMIT
(
val
1
mMaxCookiesPerHost
-
1
kCookieQuotaPerHost
)
;
}
if
(
NS_SUCCEEDED
(
aPrefBranch
-
>
GetIntPref
(
kPrefMaxCookiesPerHost
&
val
)
)
)
{
mMaxCookiesPerHost
=
(
uint16_t
)
LIMIT
(
val
mCookieQuotaPerHost
+
1
0xFFFF
kMaxCookiesPerHost
)
;
}
if
(
NS_SUCCEEDED
(
aPrefBranch
-
>
GetIntPref
(
kPrefCookiePurgeAge
&
val
)
)
)
{
mCookiePurgeAge
=
int64_t
(
LIMIT
(
val
0
INT32_MAX
INT32_MAX
)
)
*
PR_USEC_PER_SEC
;
}
bool
boolval
;
if
(
NS_SUCCEEDED
(
aPrefBranch
-
>
GetBoolPref
(
kPrefThirdPartySession
&
boolval
)
)
)
mThirdPartySession
=
boolval
;
if
(
NS_SUCCEEDED
(
aPrefBranch
-
>
GetBoolPref
(
kPrefThirdPartyNonsecureSession
&
boolval
)
)
)
mThirdPartyNonsecureSession
=
boolval
;
if
(
NS_SUCCEEDED
(
aPrefBranch
-
>
GetBoolPref
(
kCookieLeaveSecurityAlone
&
boolval
)
)
)
mLeaveSecureAlone
=
boolval
;
}
NS_IMETHODIMP
nsCookieService
:
:
RemoveAll
(
)
{
if
(
!
mDBState
)
{
NS_WARNING
(
"
No
DBState
!
Profile
already
closed
?
"
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
EnsureReadComplete
(
true
)
;
RemoveAllFromMemory
(
)
;
if
(
mDBState
-
>
dbConn
)
{
NS_ASSERTION
(
mDBState
=
=
mDefaultDBState
"
not
in
default
DB
state
"
)
;
nsCOMPtr
<
mozIStorageAsyncStatement
>
stmt
;
nsresult
rv
=
mDefaultDBState
-
>
dbConn
-
>
CreateAsyncStatement
(
NS_LITERAL_CSTRING
(
"
DELETE
FROM
moz_cookies
"
)
getter_AddRefs
(
stmt
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsCOMPtr
<
mozIStoragePendingStatement
>
handle
;
rv
=
stmt
-
>
ExecuteAsync
(
mDefaultDBState
-
>
removeListener
getter_AddRefs
(
handle
)
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
}
else
{
COOKIE_LOGSTRING
(
LogLevel
:
:
Debug
(
"
RemoveAll
(
)
:
corruption
detected
with
rv
0x
%
"
PRIx32
static_cast
<
uint32_t
>
(
rv
)
)
)
;
HandleCorruptDB
(
mDefaultDBState
)
;
}
}
NotifyChanged
(
nullptr
u
"
cleared
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsCookieService
:
:
GetEnumerator
(
nsISimpleEnumerator
*
*
aEnumerator
)
{
if
(
!
mDBState
)
{
NS_WARNING
(
"
No
DBState
!
Profile
already
closed
?
"
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
EnsureReadComplete
(
true
)
;
nsCOMArray
<
nsICookie
>
cookieList
(
mDBState
-
>
cookieCount
)
;
for
(
auto
iter
=
mDBState
-
>
hostTable
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
const
nsCookieEntry
:
:
ArrayType
&
cookies
=
iter
.
Get
(
)
-
>
GetCookies
(
)
;
for
(
nsCookieEntry
:
:
IndexType
i
=
0
;
i
<
cookies
.
Length
(
)
;
+
+
i
)
{
cookieList
.
AppendObject
(
cookies
[
i
]
)
;
}
}
return
NS_NewArrayEnumerator
(
aEnumerator
cookieList
NS_GET_IID
(
nsICookie2
)
)
;
}
NS_IMETHODIMP
nsCookieService
:
:
GetSessionEnumerator
(
nsISimpleEnumerator
*
*
aEnumerator
)
{
if
(
!
mDBState
)
{
NS_WARNING
(
"
No
DBState
!
Profile
already
closed
?
"
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
EnsureReadComplete
(
true
)
;
nsCOMArray
<
nsICookie
>
cookieList
(
mDBState
-
>
cookieCount
)
;
for
(
auto
iter
=
mDBState
-
>
hostTable
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
const
nsCookieEntry
:
:
ArrayType
&
cookies
=
iter
.
Get
(
)
-
>
GetCookies
(
)
;
for
(
nsCookieEntry
:
:
IndexType
i
=
0
;
i
<
cookies
.
Length
(
)
;
+
+
i
)
{
nsCookie
*
cookie
=
cookies
[
i
]
;
if
(
cookie
-
>
IsSession
(
)
)
{
cookieList
.
AppendObject
(
cookie
)
;
}
}
}
return
NS_NewArrayEnumerator
(
aEnumerator
cookieList
NS_GET_IID
(
nsICookie2
)
)
;
}
NS_IMETHODIMP
nsCookieService
:
:
Add
(
const
nsACString
&
aHost
const
nsACString
&
aPath
const
nsACString
&
aName
const
nsACString
&
aValue
bool
aIsSecure
bool
aIsHttpOnly
bool
aIsSession
int64_t
aExpiry
JS
:
:
HandleValue
aOriginAttributes
int32_t
aSameSite
JSContext
*
aCx
)
{
OriginAttributes
attrs
;
if
(
!
aOriginAttributes
.
isObject
(
)
|
|
!
attrs
.
Init
(
aCx
aOriginAttributes
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
return
AddNative
(
aHost
aPath
aName
aValue
aIsSecure
aIsHttpOnly
aIsSession
aExpiry
&
attrs
aSameSite
)
;
}
NS_IMETHODIMP_
(
nsresult
)
nsCookieService
:
:
AddNative
(
const
nsACString
&
aHost
const
nsACString
&
aPath
const
nsACString
&
aName
const
nsACString
&
aValue
bool
aIsSecure
bool
aIsHttpOnly
bool
aIsSession
int64_t
aExpiry
OriginAttributes
*
aOriginAttributes
int32_t
aSameSite
)
{
if
(
NS_WARN_IF
(
!
aOriginAttributes
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
mDBState
)
{
NS_WARNING
(
"
No
DBState
!
Profile
already
closed
?
"
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
EnsureReadComplete
(
true
)
;
AutoRestore
<
DBState
*
>
savePrevDBState
(
mDBState
)
;
mDBState
=
(
aOriginAttributes
-
>
mPrivateBrowsingId
>
0
)
?
mPrivateDBState
:
mDefaultDBState
;
nsAutoCString
host
(
aHost
)
;
nsresult
rv
=
NormalizeHost
(
host
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
baseDomain
;
rv
=
GetBaseDomainFromHost
(
mTLDService
host
baseDomain
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
int64_t
currentTimeInUsec
=
PR_Now
(
)
;
nsCookieKey
key
=
nsCookieKey
(
baseDomain
*
aOriginAttributes
)
;
RefPtr
<
nsCookie
>
cookie
=
nsCookie
:
:
Create
(
aName
aValue
host
aPath
aExpiry
currentTimeInUsec
nsCookie
:
:
GenerateUniqueCreationTime
(
currentTimeInUsec
)
aIsSession
aIsSecure
aIsHttpOnly
key
.
mOriginAttributes
aSameSite
)
;
if
(
!
cookie
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
AddInternal
(
key
cookie
currentTimeInUsec
nullptr
nullptr
true
)
;
return
NS_OK
;
}
nsresult
nsCookieService
:
:
Remove
(
const
nsACString
&
aHost
const
OriginAttributes
&
aAttrs
const
nsACString
&
aName
const
nsACString
&
aPath
bool
aBlocked
)
{
if
(
!
mDBState
)
{
NS_WARNING
(
"
No
DBState
!
Profile
already
closed
?
"
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
EnsureReadComplete
(
true
)
;
AutoRestore
<
DBState
*
>
savePrevDBState
(
mDBState
)
;
mDBState
=
(
aAttrs
.
mPrivateBrowsingId
>
0
)
?
mPrivateDBState
:
mDefaultDBState
;
nsAutoCString
host
(
aHost
)
;
nsresult
rv
=
NormalizeHost
(
host
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
baseDomain
;
rv
=
GetBaseDomainFromHost
(
mTLDService
host
baseDomain
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsListIter
matchIter
;
RefPtr
<
nsCookie
>
cookie
;
if
(
FindCookie
(
nsCookieKey
(
baseDomain
aAttrs
)
host
PromiseFlatCString
(
aName
)
PromiseFlatCString
(
aPath
)
matchIter
)
)
{
cookie
=
matchIter
.
Cookie
(
)
;
RemoveCookieFromList
(
matchIter
)
;
}
if
(
aBlocked
&
&
mPermissionService
)
{
if
(
!
host
.
IsEmpty
(
)
&
&
host
.
First
(
)
=
=
'
.
'
)
host
.
Cut
(
0
1
)
;
host
.
InsertLiteral
(
"
http
:
/
/
"
0
)
;
nsCOMPtr
<
nsIURI
>
uri
;
NS_NewURI
(
getter_AddRefs
(
uri
)
host
)
;
if
(
uri
)
mPermissionService
-
>
SetAccess
(
uri
nsICookiePermission
:
:
ACCESS_DENY
)
;
}
if
(
cookie
)
{
NotifyChanged
(
cookie
u
"
deleted
"
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsCookieService
:
:
Remove
(
const
nsACString
&
aHost
const
nsACString
&
aName
const
nsACString
&
aPath
bool
aBlocked
JS
:
:
HandleValue
aOriginAttributes
JSContext
*
aCx
)
{
OriginAttributes
attrs
;
if
(
!
aOriginAttributes
.
isObject
(
)
|
|
!
attrs
.
Init
(
aCx
aOriginAttributes
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
return
RemoveNative
(
aHost
aName
aPath
aBlocked
&
attrs
)
;
}
NS_IMETHODIMP_
(
nsresult
)
nsCookieService
:
:
RemoveNative
(
const
nsACString
&
aHost
const
nsACString
&
aName
const
nsACString
&
aPath
bool
aBlocked
OriginAttributes
*
aOriginAttributes
)
{
if
(
NS_WARN_IF
(
!
aOriginAttributes
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
Remove
(
aHost
*
aOriginAttributes
aName
aPath
aBlocked
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
mozilla
:
:
UniquePtr
<
ConstCookie
>
nsCookieService
:
:
GetCookieFromRow
(
mozIStorageStatement
*
aRow
const
OriginAttributes
&
aOriginAttributes
)
{
nsCString
name
value
host
path
;
DebugOnly
<
nsresult
>
rv
=
aRow
-
>
GetUTF8String
(
IDX_NAME
name
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
rv
=
aRow
-
>
GetUTF8String
(
IDX_VALUE
value
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
rv
=
aRow
-
>
GetUTF8String
(
IDX_HOST
host
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
rv
=
aRow
-
>
GetUTF8String
(
IDX_PATH
path
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
int64_t
expiry
=
aRow
-
>
AsInt64
(
IDX_EXPIRY
)
;
int64_t
lastAccessed
=
aRow
-
>
AsInt64
(
IDX_LAST_ACCESSED
)
;
int64_t
creationTime
=
aRow
-
>
AsInt64
(
IDX_CREATION_TIME
)
;
bool
isSecure
=
0
!
=
aRow
-
>
AsInt32
(
IDX_SECURE
)
;
bool
isHttpOnly
=
0
!
=
aRow
-
>
AsInt32
(
IDX_HTTPONLY
)
;
int32_t
sameSite
=
aRow
-
>
AsInt32
(
IDX_SAME_SITE
)
;
return
mozilla
:
:
MakeUnique
<
ConstCookie
>
(
name
value
host
path
expiry
lastAccessed
creationTime
isSecure
isHttpOnly
aOriginAttributes
sameSite
)
;
}
void
nsCookieService
:
:
EnsureReadComplete
(
bool
aInitDBConn
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
bool
isAccumulated
=
false
;
if
(
!
mInitializedDBStates
)
{
TimeStamp
startBlockTime
=
TimeStamp
:
:
Now
(
)
;
MonitorAutoLock
lock
(
mMonitor
)
;
while
(
!
mInitializedDBStates
)
{
mMonitor
.
Wait
(
)
;
}
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
MOZ_SQLITE_COOKIES_BLOCK_MAIN_THREAD_MS_V2
startBlockTime
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
MOZ_SQLITE_COOKIES_TIME_TO_BLOCK_MAIN_THREAD_MS
0
)
;
isAccumulated
=
true
;
}
else
if
(
!
mEndInitDBConn
.
IsNull
(
)
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
MOZ_SQLITE_COOKIES_TIME_TO_BLOCK_MAIN_THREAD_MS
(
TimeStamp
:
:
Now
(
)
-
mEndInitDBConn
)
.
ToMilliseconds
(
)
)
;
mEndInitDBConn
=
TimeStamp
(
)
;
isAccumulated
=
true
;
}
else
if
(
!
mInitializedDBConn
&
&
aInitDBConn
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
MOZ_SQLITE_COOKIES_TIME_TO_BLOCK_MAIN_THREAD_MS
0
)
;
isAccumulated
=
true
;
}
if
(
!
mInitializedDBConn
&
&
aInitDBConn
&
&
mDefaultDBState
)
{
InitDBConn
(
)
;
if
(
isAccumulated
)
{
mEndInitDBConn
=
TimeStamp
(
)
;
}
}
}
OpenDBResult
nsCookieService
:
:
Read
(
)
{
MOZ_ASSERT
(
NS_GetCurrentThread
(
)
=
=
mThread
)
;
nsresult
rv
=
mDefaultDBState
-
>
syncConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
DELETE
FROM
moz_cookies
WHERE
baseDomain
ISNULL
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
nsCOMPtr
<
mozIStorageStatement
>
stmt
;
rv
=
mDefaultDBState
-
>
syncConn
-
>
CreateStatement
(
NS_LITERAL_CSTRING
(
"
SELECT
"
"
name
"
"
value
"
"
host
"
"
path
"
"
expiry
"
"
lastAccessed
"
"
creationTime
"
"
isSecure
"
"
isHttpOnly
"
"
baseDomain
"
"
originAttributes
"
"
sameSite
"
"
FROM
moz_cookies
"
"
WHERE
baseDomain
NOTNULL
"
)
getter_AddRefs
(
stmt
)
)
;
NS_ENSURE_SUCCESS
(
rv
RESULT_RETRY
)
;
if
(
NS_WARN_IF
(
!
mReadArray
.
IsEmpty
(
)
)
)
{
mReadArray
.
Clear
(
)
;
}
mReadArray
.
SetCapacity
(
kMaxNumberOfCookies
)
;
nsCString
baseDomain
name
value
host
path
;
bool
hasResult
;
while
(
true
)
{
rv
=
stmt
-
>
ExecuteStep
(
&
hasResult
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
mReadArray
.
Clear
(
)
;
return
RESULT_RETRY
;
}
if
(
!
hasResult
)
break
;
stmt
-
>
GetUTF8String
(
IDX_BASE_DOMAIN
baseDomain
)
;
nsAutoCString
suffix
;
OriginAttributes
attrs
;
stmt
-
>
GetUTF8String
(
IDX_ORIGIN_ATTRIBUTES
suffix
)
;
Unused
<
<
attrs
.
PopulateFromSuffix
(
suffix
)
;
nsCookieKey
key
(
baseDomain
attrs
)
;
CookieDomainTuple
*
tuple
=
mReadArray
.
AppendElement
(
)
;
tuple
-
>
key
=
std
:
:
move
(
key
)
;
tuple
-
>
cookie
=
GetCookieFromRow
(
stmt
attrs
)
;
}
COOKIE_LOGSTRING
(
LogLevel
:
:
Debug
(
"
Read
(
)
:
%
zu
cookies
read
"
mReadArray
.
Length
(
)
)
)
;
return
RESULT_OK
;
}
NS_IMETHODIMP
nsCookieService
:
:
ImportCookies
(
nsIFile
*
aCookieFile
)
{
if
(
!
mDBState
)
{
NS_WARNING
(
"
No
DBState
!
Profile
already
closed
?
"
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
EnsureReadComplete
(
true
)
;
if
(
mDBState
!
=
mDefaultDBState
)
{
NS_WARNING
(
"
Trying
to
import
cookies
in
a
private
browsing
session
!
"
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
nsresult
rv
;
nsCOMPtr
<
nsIInputStream
>
fileInputStream
;
rv
=
NS_NewLocalFileInputStream
(
getter_AddRefs
(
fileInputStream
)
aCookieFile
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
nsCOMPtr
<
nsILineInputStream
>
lineInputStream
=
do_QueryInterface
(
fileInputStream
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
static
const
char
kTrue
[
]
=
"
TRUE
"
;
nsAutoCString
buffer
baseDomain
;
bool
isMore
=
true
;
int32_t
hostIndex
isDomainIndex
pathIndex
secureIndex
expiresIndex
nameIndex
cookieIndex
;
int32_t
numInts
;
int64_t
expires
;
bool
isDomain
isHttpOnly
=
false
;
uint32_t
originalCookieCount
=
mDefaultDBState
-
>
cookieCount
;
int64_t
currentTimeInUsec
=
PR_Now
(
)
;
int64_t
currentTime
=
currentTimeInUsec
/
PR_USEC_PER_SEC
;
int64_t
lastAccessedCounter
=
currentTimeInUsec
;
nsCOMPtr
<
mozIStorageBindingParamsArray
>
paramsArray
;
if
(
originalCookieCount
=
=
0
&
&
mDefaultDBState
-
>
dbConn
)
{
mDefaultDBState
-
>
stmtInsert
-
>
NewBindingParamsArray
(
getter_AddRefs
(
paramsArray
)
)
;
}
while
(
isMore
&
&
NS_SUCCEEDED
(
lineInputStream
-
>
ReadLine
(
buffer
&
isMore
)
)
)
{
if
(
StringBeginsWith
(
buffer
NS_LITERAL_CSTRING
(
HTTP_ONLY_PREFIX
)
)
)
{
isHttpOnly
=
true
;
hostIndex
=
sizeof
(
HTTP_ONLY_PREFIX
)
-
1
;
}
else
if
(
buffer
.
IsEmpty
(
)
|
|
buffer
.
First
(
)
=
=
'
#
'
)
{
continue
;
}
else
{
isHttpOnly
=
false
;
hostIndex
=
0
;
}
if
(
(
isDomainIndex
=
buffer
.
FindChar
(
'
\
t
'
hostIndex
)
+
1
)
=
=
0
|
|
(
pathIndex
=
buffer
.
FindChar
(
'
\
t
'
isDomainIndex
)
+
1
)
=
=
0
|
|
(
secureIndex
=
buffer
.
FindChar
(
'
\
t
'
pathIndex
)
+
1
)
=
=
0
|
|
(
expiresIndex
=
buffer
.
FindChar
(
'
\
t
'
secureIndex
)
+
1
)
=
=
0
|
|
(
nameIndex
=
buffer
.
FindChar
(
'
\
t
'
expiresIndex
)
+
1
)
=
=
0
|
|
(
cookieIndex
=
buffer
.
FindChar
(
'
\
t
'
nameIndex
)
+
1
)
=
=
0
)
{
continue
;
}
auto
iter
=
buffer
.
BeginWriting
(
)
+
nameIndex
-
1
;
*
iter
=
char
(
0
)
;
numInts
=
PR_sscanf
(
buffer
.
get
(
)
+
expiresIndex
"
%
lld
"
&
expires
)
;
if
(
numInts
!
=
1
|
|
expires
<
currentTime
)
{
continue
;
}
isDomain
=
Substring
(
buffer
isDomainIndex
pathIndex
-
isDomainIndex
-
1
)
.
EqualsLiteral
(
kTrue
)
;
const
nsACString
&
host
=
Substring
(
buffer
hostIndex
isDomainIndex
-
hostIndex
-
1
)
;
if
(
(
isDomain
&
&
!
host
.
IsEmpty
(
)
&
&
host
.
First
(
)
!
=
'
.
'
)
|
|
host
.
Contains
(
'
:
'
)
)
{
continue
;
}
rv
=
GetBaseDomainFromHost
(
mTLDService
host
baseDomain
)
;
if
(
NS_FAILED
(
rv
)
)
continue
;
nsCookieKey
key
=
DEFAULT_APP_KEY
(
baseDomain
)
;
RefPtr
<
nsCookie
>
newCookie
=
nsCookie
:
:
Create
(
Substring
(
buffer
nameIndex
cookieIndex
-
nameIndex
-
1
)
Substring
(
buffer
cookieIndex
buffer
.
Length
(
)
-
cookieIndex
)
host
Substring
(
buffer
pathIndex
secureIndex
-
pathIndex
-
1
)
expires
lastAccessedCounter
nsCookie
:
:
GenerateUniqueCreationTime
(
currentTimeInUsec
)
false
Substring
(
buffer
secureIndex
expiresIndex
-
secureIndex
-
1
)
.
EqualsLiteral
(
kTrue
)
isHttpOnly
key
.
mOriginAttributes
nsICookie2
:
:
SAMESITE_UNSET
)
;
if
(
!
newCookie
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
lastAccessedCounter
-
-
;
if
(
originalCookieCount
=
=
0
)
{
AddCookieToList
(
key
newCookie
mDefaultDBState
paramsArray
)
;
}
else
{
AddInternal
(
key
newCookie
currentTimeInUsec
nullptr
nullptr
true
)
;
}
}
if
(
paramsArray
)
{
uint32_t
length
;
paramsArray
-
>
GetLength
(
&
length
)
;
if
(
length
)
{
rv
=
mDefaultDBState
-
>
stmtInsert
-
>
BindParameters
(
paramsArray
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
nsCOMPtr
<
mozIStoragePendingStatement
>
handle
;
rv
=
mDefaultDBState
-
>
stmtInsert
-
>
ExecuteAsync
(
mDefaultDBState
-
>
insertListener
getter_AddRefs
(
handle
)
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
}
}
COOKIE_LOGSTRING
(
LogLevel
:
:
Debug
(
"
ImportCookies
(
)
:
%
"
PRIu32
"
cookies
imported
"
mDefaultDBState
-
>
cookieCount
)
)
;
return
NS_OK
;
}
static
inline
bool
ispathdelimiter
(
char
c
)
{
return
c
=
=
'
/
'
|
|
c
=
=
'
?
'
|
|
c
=
=
'
#
'
|
|
c
=
=
'
;
'
;
}
bool
nsCookieService
:
:
DomainMatches
(
nsCookie
*
aCookie
const
nsACString
&
aHost
)
{
return
aCookie
-
>
RawHost
(
)
=
=
aHost
|
|
(
aCookie
-
>
IsDomain
(
)
&
&
StringEndsWith
(
aHost
aCookie
-
>
Host
(
)
)
)
;
}
bool
nsCookieService
:
:
IsSameSiteEnabled
(
)
{
static
bool
prefInitialized
=
false
;
if
(
!
prefInitialized
)
{
Preferences
:
:
AddBoolVarCache
(
&
sSameSiteEnabled
"
network
.
cookie
.
same
-
site
.
enabled
"
false
)
;
prefInitialized
=
true
;
}
return
sSameSiteEnabled
;
}
bool
nsCookieService
:
:
PathMatches
(
nsCookie
*
aCookie
const
nsACString
&
aPath
)
{
uint32_t
cookiePathLen
=
aCookie
-
>
Path
(
)
.
Length
(
)
;
if
(
cookiePathLen
>
0
&
&
aCookie
-
>
Path
(
)
.
Last
(
)
=
=
'
/
'
)
-
-
cookiePathLen
;
if
(
!
StringBeginsWith
(
aPath
Substring
(
aCookie
-
>
Path
(
)
0
cookiePathLen
)
)
)
return
false
;
if
(
aPath
.
Length
(
)
>
cookiePathLen
&
&
!
ispathdelimiter
(
aPath
.
CharAt
(
cookiePathLen
)
)
)
{
return
false
;
}
return
true
;
}
void
nsCookieService
:
:
GetCookiesForURI
(
nsIURI
*
aHostURI
nsIChannel
*
aChannel
bool
aIsForeign
bool
aIsTrackingResource
bool
aFirstPartyStorageAccessGranted
bool
aIsSafeTopLevelNav
bool
aIsSameSiteForeign
bool
aHttpBound
const
OriginAttributes
&
aOriginAttrs
nsTArray
<
nsCookie
*
>
&
aCookieList
)
{
NS_ASSERTION
(
aHostURI
"
null
host
!
"
)
;
if
(
!
mDBState
)
{
NS_WARNING
(
"
No
DBState
!
Profile
already
closed
?
"
)
;
return
;
}
EnsureReadComplete
(
true
)
;
AutoRestore
<
DBState
*
>
savePrevDBState
(
mDBState
)
;
mDBState
=
(
aOriginAttrs
.
mPrivateBrowsingId
>
0
)
?
mPrivateDBState
:
mDefaultDBState
;
bool
requireHostMatch
;
nsAutoCString
baseDomain
hostFromURI
pathFromURI
;
nsresult
rv
=
GetBaseDomain
(
mTLDService
aHostURI
baseDomain
requireHostMatch
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
rv
=
aHostURI
-
>
GetAsciiHost
(
hostFromURI
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
rv
=
aHostURI
-
>
GetPathQueryRef
(
pathFromURI
)
;
if
(
NS_FAILED
(
rv
)
)
{
COOKIE_LOGFAILURE
(
GET_COOKIE
aHostURI
nullptr
"
invalid
host
/
path
from
URI
"
)
;
return
;
}
uint32_t
rejectedReason
=
0
;
uint32_t
priorCookieCount
=
0
;
CountCookiesFromHost
(
hostFromURI
&
priorCookieCount
)
;
CookieStatus
cookieStatus
=
CheckPrefs
(
mPermissionService
mCookieBehavior
mThirdPartySession
mThirdPartyNonsecureSession
aHostURI
aIsForeign
aIsTrackingResource
aFirstPartyStorageAccessGranted
nullptr
priorCookieCount
aOriginAttrs
&
rejectedReason
)
;
MOZ_ASSERT_IF
(
rejectedReason
cookieStatus
=
=
STATUS_REJECTED
)
;
switch
(
cookieStatus
)
{
case
STATUS_REJECTED
:
NotifyRejected
(
aHostURI
aChannel
rejectedReason
OPERATION_READ
)
;
return
;
default
:
break
;
}
bool
isSecure
;
if
(
NS_FAILED
(
aHostURI
-
>
SchemeIs
(
"
https
"
&
isSecure
)
)
)
{
isSecure
=
false
;
}
nsCookie
*
cookie
;
int64_t
currentTimeInUsec
=
PR_Now
(
)
;
int64_t
currentTime
=
currentTimeInUsec
/
PR_USEC_PER_SEC
;
bool
stale
=
false
;
nsCookieKey
key
(
baseDomain
aOriginAttrs
)
;
nsCookieEntry
*
entry
=
mDBState
-
>
hostTable
.
GetEntry
(
key
)
;
if
(
!
entry
)
return
;
const
nsCookieEntry
:
:
ArrayType
&
cookies
=
entry
-
>
GetCookies
(
)
;
for
(
nsCookieEntry
:
:
IndexType
i
=
0
;
i
<
cookies
.
Length
(
)
;
+
+
i
)
{
cookie
=
cookies
[
i
]
;
if
(
!
DomainMatches
(
cookie
hostFromURI
)
)
continue
;
if
(
cookie
-
>
IsSecure
(
)
&
&
!
isSecure
)
continue
;
int32_t
sameSiteAttr
=
0
;
cookie
-
>
GetSameSite
(
&
sameSiteAttr
)
;
if
(
aIsSameSiteForeign
&
&
IsSameSiteEnabled
(
)
)
{
if
(
sameSiteAttr
=
=
nsICookie2
:
:
SAMESITE_STRICT
)
{
continue
;
}
if
(
sameSiteAttr
=
=
nsICookie2
:
:
SAMESITE_LAX
&
&
!
aIsSafeTopLevelNav
)
{
continue
;
}
}
if
(
cookie
-
>
IsHttpOnly
(
)
&
&
!
aHttpBound
)
continue
;
if
(
!
PathMatches
(
cookie
pathFromURI
)
)
continue
;
if
(
cookie
-
>
Expiry
(
)
<
=
currentTime
)
{
continue
;
}
aCookieList
.
AppendElement
(
cookie
)
;
if
(
cookie
-
>
IsStale
(
)
)
{
stale
=
true
;
}
}
int32_t
count
=
aCookieList
.
Length
(
)
;
if
(
count
=
=
0
)
return
;
NotifyAccepted
(
aChannel
)
;
if
(
stale
)
{
nsCOMPtr
<
mozIStorageBindingParamsArray
>
paramsArray
;
mozIStorageAsyncStatement
*
stmt
=
mDBState
-
>
stmtUpdate
;
if
(
mDBState
-
>
dbConn
)
{
stmt
-
>
NewBindingParamsArray
(
getter_AddRefs
(
paramsArray
)
)
;
}
for
(
int32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
cookie
=
aCookieList
.
ElementAt
(
i
)
;
if
(
cookie
-
>
IsStale
(
)
)
{
UpdateCookieInList
(
cookie
currentTimeInUsec
paramsArray
)
;
}
}
if
(
paramsArray
)
{
uint32_t
length
;
paramsArray
-
>
GetLength
(
&
length
)
;
if
(
length
)
{
DebugOnly
<
nsresult
>
rv
=
stmt
-
>
BindParameters
(
paramsArray
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
nsCOMPtr
<
mozIStoragePendingStatement
>
handle
;
rv
=
stmt
-
>
ExecuteAsync
(
mDBState
-
>
updateListener
getter_AddRefs
(
handle
)
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
}
}
}
aCookieList
.
Sort
(
CompareCookiesForSending
(
)
)
;
}
void
nsCookieService
:
:
GetCookieStringInternal
(
nsIURI
*
aHostURI
nsIChannel
*
aChannel
bool
aIsForeign
bool
aIsTrackingResource
bool
aFirstPartyStorageAccessGranted
bool
aIsSafeTopLevelNav
bool
aIsSameSiteForeign
bool
aHttpBound
const
OriginAttributes
&
aOriginAttrs
nsCString
&
aCookieString
)
{
AutoTArray
<
nsCookie
*
8
>
foundCookieList
;
GetCookiesForURI
(
aHostURI
aChannel
aIsForeign
aIsTrackingResource
aFirstPartyStorageAccessGranted
aIsSafeTopLevelNav
aIsSameSiteForeign
aHttpBound
aOriginAttrs
foundCookieList
)
;
nsCookie
*
cookie
;
for
(
uint32_t
i
=
0
;
i
<
foundCookieList
.
Length
(
)
;
+
+
i
)
{
cookie
=
foundCookieList
.
ElementAt
(
i
)
;
if
(
!
cookie
-
>
Name
(
)
.
IsEmpty
(
)
|
|
!
cookie
-
>
Value
(
)
.
IsEmpty
(
)
)
{
if
(
!
aCookieString
.
IsEmpty
(
)
)
{
aCookieString
.
AppendLiteral
(
"
;
"
)
;
}
if
(
!
cookie
-
>
Name
(
)
.
IsEmpty
(
)
)
{
aCookieString
+
=
cookie
-
>
Name
(
)
+
NS_LITERAL_CSTRING
(
"
=
"
)
+
cookie
-
>
Value
(
)
;
}
else
{
aCookieString
+
=
cookie
-
>
Value
(
)
;
}
}
}
if
(
!
aCookieString
.
IsEmpty
(
)
)
COOKIE_LOGSUCCESS
(
GET_COOKIE
aHostURI
aCookieString
nullptr
false
)
;
}
bool
nsCookieService
:
:
CanSetCookie
(
nsIURI
*
aHostURI
const
nsCookieKey
&
aKey
nsCookieAttributes
&
aCookieAttributes
bool
aRequireHostMatch
CookieStatus
aStatus
nsDependentCString
&
aCookieHeader
int64_t
aServerTime
bool
aFromHttp
nsIChannel
*
aChannel
bool
aLeaveSecureAlone
bool
&
aSetCookie
mozIThirdPartyUtil
*
aThirdPartyUtil
)
{
NS_ASSERTION
(
aHostURI
"
null
host
!
"
)
;
aSetCookie
=
false
;
aCookieAttributes
.
expiryTime
=
INT64_MAX
;
nsDependentCString
savedCookieHeader
(
aCookieHeader
)
;
bool
newCookie
=
ParseAttributes
(
aCookieHeader
aCookieAttributes
)
;
bool
isHTTPS
;
nsresult
rv
=
aHostURI
-
>
SchemeIs
(
"
https
"
&
isHTTPS
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
COOKIE_SCHEME_SECURITY
(
(
aCookieAttributes
.
isSecure
)
?
0x02
:
0x00
)
|
(
(
isHTTPS
)
?
0x01
:
0x00
)
)
;
if
(
aThirdPartyUtil
)
{
bool
isThirdParty
=
true
;
aThirdPartyUtil
-
>
IsThirdPartyChannel
(
aChannel
aHostURI
&
isThirdParty
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
COOKIE_SCHEME_HTTPS
(
isThirdParty
?
0x04
:
0x00
)
|
(
isHTTPS
?
0x02
:
0x00
)
|
(
aCookieAttributes
.
isSecure
?
0x01
:
0x00
)
)
;
}
}
int64_t
currentTimeInUsec
=
PR_Now
(
)
;
aCookieAttributes
.
isSession
=
GetExpiry
(
aCookieAttributes
aServerTime
currentTimeInUsec
/
PR_USEC_PER_SEC
)
;
if
(
aStatus
=
=
STATUS_ACCEPT_SESSION
)
{
aCookieAttributes
.
isSession
=
true
;
}
if
(
(
aCookieAttributes
.
name
.
Length
(
)
+
aCookieAttributes
.
value
.
Length
(
)
)
>
kMaxBytesPerCookie
)
{
COOKIE_LOGFAILURE
(
SET_COOKIE
aHostURI
savedCookieHeader
"
cookie
too
big
(
>
4kb
)
"
)
;
return
newCookie
;
}
const
char
illegalNameCharacters
[
]
=
{
0x01
0x02
0x03
0x04
0x05
0x06
0x07
0x08
0x09
0x0A
0x0B
0x0C
0x0D
0x0E
0x0F
0x10
0x11
0x12
0x13
0x14
0x15
0x16
0x17
0x18
0x19
0x1A
0x1B
0x1C
0x1D
0x1E
0x1F
0x00
}
;
if
(
aCookieAttributes
.
name
.
FindCharInSet
(
illegalNameCharacters
0
)
!
=
-
1
)
{
COOKIE_LOGFAILURE
(
SET_COOKIE
aHostURI
savedCookieHeader
"
invalid
name
character
"
)
;
return
newCookie
;
}
if
(
!
CheckDomain
(
aCookieAttributes
aHostURI
aKey
.
mBaseDomain
aRequireHostMatch
)
)
{
COOKIE_LOGFAILURE
(
SET_COOKIE
aHostURI
savedCookieHeader
"
failed
the
domain
tests
"
)
;
return
newCookie
;
}
if
(
!
CheckPath
(
aCookieAttributes
aHostURI
)
)
{
COOKIE_LOGFAILURE
(
SET_COOKIE
aHostURI
savedCookieHeader
"
failed
the
path
tests
"
)
;
return
newCookie
;
}
if
(
!
CheckPrefixes
(
aCookieAttributes
isHTTPS
)
)
{
COOKIE_LOGFAILURE
(
SET_COOKIE
aHostURI
savedCookieHeader
"
failed
the
prefix
tests
"
)
;
return
newCookie
;
}
const
char
illegalCharacters
[
]
=
{
0x01
0x02
0x03
0x04
0x05
0x06
0x07
0x08
0x0A
0x0B
0x0C
0x0D
0x0E
0x0F
0x10
0x11
0x12
0x13
0x14
0x15
0x16
0x17
0x18
0x19
0x1A
0x1B
0x1C
0x1D
0x1E
0x1F
0x3B
0x00
}
;
if
(
aFromHttp
&
&
(
aCookieAttributes
.
value
.
FindCharInSet
(
illegalCharacters
0
)
!
=
-
1
)
)
{
COOKIE_LOGFAILURE
(
SET_COOKIE
aHostURI
savedCookieHeader
"
invalid
value
character
"
)
;
return
newCookie
;
}
if
(
!
aFromHttp
&
&
aCookieAttributes
.
isHttpOnly
)
{
COOKIE_LOGFAILURE
(
SET_COOKIE
aHostURI
savedCookieHeader
"
cookie
is
httponly
;
coming
from
script
"
)
;
return
newCookie
;
}
bool
isSecure
=
true
;
if
(
aHostURI
)
{
aHostURI
-
>
SchemeIs
(
"
https
"
&
isSecure
)
;
}
if
(
aLeaveSecureAlone
&
&
aCookieAttributes
.
isSecure
&
&
!
isSecure
)
{
COOKIE_LOGFAILURE
(
SET_COOKIE
aHostURI
aCookieHeader
"
non
-
https
cookie
can
'
t
set
secure
flag
"
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
COOKIE_LEAVE_SECURE_ALONE
BLOCKED_SECURE_SET_FROM_HTTP
)
;
return
newCookie
;
}
if
(
(
aCookieAttributes
.
sameSite
!
=
nsICookie2
:
:
SAMESITE_UNSET
)
&
&
aThirdPartyUtil
&
&
IsSameSiteEnabled
(
)
)
{
bool
addonAllowsLoad
=
false
;
if
(
aChannel
)
{
nsCOMPtr
<
nsIURI
>
channelURI
;
NS_GetFinalChannelURI
(
aChannel
getter_AddRefs
(
channelURI
)
)
;
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
aChannel
-
>
GetLoadInfo
(
)
;
addonAllowsLoad
=
loadInfo
&
&
BasePrincipal
:
:
Cast
(
loadInfo
-
>
TriggeringPrincipal
(
)
)
-
>
AddonAllowsLoad
(
channelURI
)
;
}
if
(
!
addonAllowsLoad
)
{
bool
isThirdParty
=
false
;
nsresult
rv
=
aThirdPartyUtil
-
>
IsThirdPartyChannel
(
aChannel
aHostURI
&
isThirdParty
)
;
if
(
NS_FAILED
(
rv
)
|
|
isThirdParty
)
{
COOKIE_LOGFAILURE
(
SET_COOKIE
aHostURI
savedCookieHeader
"
failed
the
samesite
tests
"
)
;
return
newCookie
;
}
}
}
aSetCookie
=
true
;
return
newCookie
;
}
bool
nsCookieService
:
:
SetCookieInternal
(
nsIURI
*
aHostURI
const
mozilla
:
:
net
:
:
nsCookieKey
&
aKey
bool
aRequireHostMatch
CookieStatus
aStatus
nsDependentCString
&
aCookieHeader
int64_t
aServerTime
bool
aFromHttp
nsIChannel
*
aChannel
)
{
NS_ASSERTION
(
aHostURI
"
null
host
!
"
)
;
bool
canSetCookie
=
false
;
nsDependentCString
savedCookieHeader
(
aCookieHeader
)
;
nsCookieAttributes
cookieAttributes
;
bool
newCookie
=
CanSetCookie
(
aHostURI
aKey
cookieAttributes
aRequireHostMatch
aStatus
aCookieHeader
aServerTime
aFromHttp
aChannel
mLeaveSecureAlone
canSetCookie
mThirdPartyUtil
)
;
if
(
!
canSetCookie
)
{
return
newCookie
;
}
int64_t
currentTimeInUsec
=
PR_Now
(
)
;
RefPtr
<
nsCookie
>
cookie
=
nsCookie
:
:
Create
(
cookieAttributes
.
name
cookieAttributes
.
value
cookieAttributes
.
host
cookieAttributes
.
path
cookieAttributes
.
expiryTime
currentTimeInUsec
nsCookie
:
:
GenerateUniqueCreationTime
(
currentTimeInUsec
)
cookieAttributes
.
isSession
cookieAttributes
.
isSecure
cookieAttributes
.
isHttpOnly
aKey
.
mOriginAttributes
cookieAttributes
.
sameSite
)
;
if
(
!
cookie
)
return
newCookie
;
if
(
mPermissionService
)
{
bool
permission
;
mPermissionService
-
>
CanSetCookie
(
aHostURI
aChannel
static_cast
<
nsICookie2
*
>
(
static_cast
<
nsCookie
*
>
(
cookie
)
)
&
cookieAttributes
.
isSession
&
cookieAttributes
.
expiryTime
&
permission
)
;
if
(
!
permission
)
{
COOKIE_LOGFAILURE
(
SET_COOKIE
aHostURI
savedCookieHeader
"
cookie
rejected
by
permission
manager
"
)
;
NotifyRejected
(
aHostURI
aChannel
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_BY_PERMISSION
OPERATION_WRITE
)
;
return
newCookie
;
}
cookie
-
>
SetIsSession
(
cookieAttributes
.
isSession
)
;
cookie
-
>
SetExpiry
(
cookieAttributes
.
expiryTime
)
;
}
AddInternal
(
aKey
cookie
PR_Now
(
)
aHostURI
savedCookieHeader
.
get
(
)
aFromHttp
)
;
return
newCookie
;
}
void
nsCookieService
:
:
AddInternal
(
const
nsCookieKey
&
aKey
nsCookie
*
aCookie
int64_t
aCurrentTimeInUsec
nsIURI
*
aHostURI
const
char
*
aCookieHeader
bool
aFromHttp
)
{
MOZ_ASSERT
(
mInitializedDBStates
)
;
MOZ_ASSERT
(
mInitializedDBConn
)
;
int64_t
currentTime
=
aCurrentTimeInUsec
/
PR_USEC_PER_SEC
;
nsListIter
exactIter
;
bool
foundCookie
=
false
;
foundCookie
=
FindCookie
(
aKey
aCookie
-
>
Host
(
)
aCookie
-
>
Name
(
)
aCookie
-
>
Path
(
)
exactIter
)
;
bool
foundSecureExact
=
foundCookie
&
&
exactIter
.
Cookie
(
)
-
>
IsSecure
(
)
;
bool
isSecure
=
true
;
if
(
aHostURI
&
&
NS_FAILED
(
aHostURI
-
>
SchemeIs
(
"
https
"
&
isSecure
)
)
)
{
isSecure
=
false
;
}
bool
oldCookieIsSession
=
false
;
if
(
mLeaveSecureAlone
)
{
if
(
!
aCookie
-
>
IsSecure
(
)
&
&
(
foundSecureExact
|
|
FindSecureCookie
(
aKey
aCookie
)
)
)
{
if
(
!
isSecure
)
{
COOKIE_LOGFAILURE
(
SET_COOKIE
aHostURI
aCookieHeader
"
cookie
can
'
t
save
because
older
cookie
is
secure
"
"
cookie
but
newer
cookie
is
non
-
secure
cookie
"
)
;
if
(
foundSecureExact
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
COOKIE_LEAVE_SECURE_ALONE
BLOCKED_DOWNGRADE_SECURE_EXACT
)
;
}
else
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
COOKIE_LEAVE_SECURE_ALONE
BLOCKED_DOWNGRADE_SECURE_INEXACT
)
;
}
return
;
}
if
(
foundSecureExact
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
COOKIE_LEAVE_SECURE_ALONE
DOWNGRADE_SECURE_FROM_SECURE_EXACT
)
;
}
else
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
COOKIE_LEAVE_SECURE_ALONE
DOWNGRADE_SECURE_FROM_SECURE_INEXACT
)
;
}
}
}
RefPtr
<
nsCookie
>
oldCookie
;
nsCOMPtr
<
nsIArray
>
purgedList
;
if
(
foundCookie
)
{
oldCookie
=
exactIter
.
Cookie
(
)
;
oldCookieIsSession
=
oldCookie
-
>
IsSession
(
)
;
if
(
oldCookie
-
>
Expiry
(
)
<
=
currentTime
)
{
if
(
aCookie
-
>
Expiry
(
)
<
=
currentTime
)
{
COOKIE_LOGFAILURE
(
SET_COOKIE
aHostURI
aCookieHeader
"
cookie
has
already
expired
"
)
;
return
;
}
RemoveCookieFromList
(
exactIter
)
;
COOKIE_LOGFAILURE
(
SET_COOKIE
aHostURI
aCookieHeader
"
stale
cookie
was
purged
"
)
;
purgedList
=
CreatePurgeList
(
oldCookie
)
;
foundCookie
=
false
;
}
else
{
if
(
!
aFromHttp
&
&
oldCookie
-
>
IsHttpOnly
(
)
)
{
COOKIE_LOGFAILURE
(
SET_COOKIE
aHostURI
aCookieHeader
"
previously
stored
cookie
is
httponly
;
coming
from
script
"
)
;
return
;
}
if
(
oldCookie
-
>
Value
(
)
.
Equals
(
aCookie
-
>
Value
(
)
)
&
&
oldCookie
-
>
Expiry
(
)
=
=
aCookie
-
>
Expiry
(
)
&
&
oldCookie
-
>
IsSecure
(
)
=
=
aCookie
-
>
IsSecure
(
)
&
&
oldCookie
-
>
IsSession
(
)
=
=
aCookie
-
>
IsSession
(
)
&
&
oldCookie
-
>
IsHttpOnly
(
)
=
=
aCookie
-
>
IsHttpOnly
(
)
&
&
oldCookie
-
>
SameSite
(
)
=
=
aCookie
-
>
SameSite
(
)
&
&
!
oldCookie
-
>
IsStale
(
)
)
{
oldCookie
-
>
SetLastAccessed
(
aCookie
-
>
LastAccessed
(
)
)
;
UpdateCookieOldestTime
(
mDBState
oldCookie
)
;
return
;
}
RemoveCookieFromList
(
exactIter
)
;
if
(
aCookie
-
>
Expiry
(
)
<
=
currentTime
)
{
COOKIE_LOGFAILURE
(
SET_COOKIE
aHostURI
aCookieHeader
"
previously
stored
cookie
was
deleted
"
)
;
NotifyChanged
(
oldCookie
u
"
deleted
"
oldCookieIsSession
aFromHttp
)
;
return
;
}
aCookie
-
>
SetCreationTime
(
oldCookie
-
>
CreationTime
(
)
)
;
}
}
else
{
if
(
aCookie
-
>
Expiry
(
)
<
=
currentTime
)
{
COOKIE_LOGFAILURE
(
SET_COOKIE
aHostURI
aCookieHeader
"
cookie
has
already
expired
"
)
;
return
;
}
nsCookieEntry
*
entry
=
mDBState
-
>
hostTable
.
GetEntry
(
aKey
)
;
if
(
entry
&
&
entry
-
>
GetCookies
(
)
.
Length
(
)
>
=
mMaxCookiesPerHost
)
{
nsTArray
<
nsListIter
>
removedIterList
;
mozilla
:
:
Maybe
<
bool
>
optionalSecurity
=
mLeaveSecureAlone
?
Some
(
false
)
:
Nothing
(
)
;
uint32_t
limit
=
mMaxCookiesPerHost
-
mCookieQuotaPerHost
;
FindStaleCookies
(
entry
currentTime
optionalSecurity
removedIterList
limit
)
;
if
(
removedIterList
.
Length
(
)
=
=
0
)
{
if
(
aCookie
-
>
IsSecure
(
)
)
{
FindStaleCookies
(
entry
currentTime
Some
(
true
)
removedIterList
limit
)
;
}
else
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
COOKIE_LEAVE_SECURE_ALONE
EVICTING_SECURE_BLOCKED
)
;
COOKIE_LOGEVICTED
(
aCookie
"
Too
many
cookies
for
this
domain
and
the
new
"
"
cookie
is
not
a
secure
cookie
"
)
;
return
;
}
}
MOZ_ASSERT
(
!
removedIterList
.
IsEmpty
(
)
)
;
removedIterList
.
Sort
(
CompareCookiesByIndex
(
)
)
;
for
(
auto
it
=
removedIterList
.
rbegin
(
)
;
it
!
=
removedIterList
.
rend
(
)
;
it
+
+
)
{
RefPtr
<
nsCookie
>
evictedCookie
=
(
*
it
)
.
Cookie
(
)
;
if
(
mLeaveSecureAlone
&
&
evictedCookie
-
>
Expiry
(
)
<
=
currentTime
)
{
TelemetryForEvictingStaleCookie
(
evictedCookie
evictedCookie
-
>
LastAccessed
(
)
)
;
}
COOKIE_LOGEVICTED
(
evictedCookie
"
Too
many
cookies
for
this
domain
"
)
;
RemoveCookieFromList
(
*
it
)
;
CreateOrUpdatePurgeList
(
getter_AddRefs
(
purgedList
)
evictedCookie
)
;
MOZ_ASSERT
(
(
*
it
)
.
entry
)
;
}
}
else
if
(
mDBState
-
>
cookieCount
>
=
ADD_TEN_PERCENT
(
mMaxNumberOfCookies
)
)
{
int64_t
maxAge
=
aCurrentTimeInUsec
-
mDBState
-
>
cookieOldestTime
;
int64_t
purgeAge
=
ADD_TEN_PERCENT
(
mCookiePurgeAge
)
;
if
(
maxAge
>
=
purgeAge
)
{
purgedList
=
PurgeCookies
(
aCurrentTimeInUsec
)
;
}
}
}
AddCookieToList
(
aKey
aCookie
mDBState
nullptr
)
;
COOKIE_LOGSUCCESS
(
SET_COOKIE
aHostURI
aCookieHeader
aCookie
foundCookie
)
;
if
(
purgedList
)
{
NotifyChanged
(
purgedList
u
"
batch
-
deleted
"
)
;
}
NotifyChanged
(
aCookie
foundCookie
?
u
"
changed
"
:
u
"
added
"
oldCookieIsSession
aFromHttp
)
;
}
static
inline
bool
iswhitespace
(
char
c
)
{
return
c
=
=
'
'
|
|
c
=
=
'
\
t
'
;
}
static
inline
bool
isterminator
(
char
c
)
{
return
c
=
=
'
\
n
'
|
|
c
=
=
'
\
r
'
;
}
static
inline
bool
isvalueseparator
(
char
c
)
{
return
isterminator
(
c
)
|
|
c
=
=
'
;
'
;
}
static
inline
bool
istokenseparator
(
char
c
)
{
return
isvalueseparator
(
c
)
|
|
c
=
=
'
=
'
;
}
bool
nsCookieService
:
:
GetTokenValue
(
nsACString
:
:
const_char_iterator
&
aIter
nsACString
:
:
const_char_iterator
&
aEndIter
nsDependentCSubstring
&
aTokenString
nsDependentCSubstring
&
aTokenValue
bool
&
aEqualsFound
)
{
nsACString
:
:
const_char_iterator
start
lastSpace
;
aTokenValue
.
Rebind
(
aIter
aIter
)
;
while
(
aIter
!
=
aEndIter
&
&
iswhitespace
(
*
aIter
)
)
+
+
aIter
;
start
=
aIter
;
while
(
aIter
!
=
aEndIter
&
&
!
istokenseparator
(
*
aIter
)
)
+
+
aIter
;
lastSpace
=
aIter
;
if
(
lastSpace
!
=
start
)
{
while
(
-
-
lastSpace
!
=
start
&
&
iswhitespace
(
*
lastSpace
)
)
continue
;
+
+
lastSpace
;
}
aTokenString
.
Rebind
(
start
lastSpace
)
;
aEqualsFound
=
(
*
aIter
=
=
'
=
'
)
;
if
(
aEqualsFound
)
{
while
(
+
+
aIter
!
=
aEndIter
&
&
iswhitespace
(
*
aIter
)
)
continue
;
start
=
aIter
;
while
(
aIter
!
=
aEndIter
&
&
!
isvalueseparator
(
*
aIter
)
)
+
+
aIter
;
if
(
aIter
!
=
start
)
{
lastSpace
=
aIter
;
while
(
-
-
lastSpace
!
=
start
&
&
iswhitespace
(
*
lastSpace
)
)
continue
;
aTokenValue
.
Rebind
(
start
+
+
lastSpace
)
;
}
}
if
(
aIter
!
=
aEndIter
)
{
if
(
isterminator
(
*
aIter
)
)
{
+
+
aIter
;
return
true
;
}
+
+
aIter
;
}
return
false
;
}
bool
nsCookieService
:
:
ParseAttributes
(
nsDependentCString
&
aCookieHeader
nsCookieAttributes
&
aCookieAttributes
)
{
static
const
char
kPath
[
]
=
"
path
"
;
static
const
char
kDomain
[
]
=
"
domain
"
;
static
const
char
kExpires
[
]
=
"
expires
"
;
static
const
char
kMaxage
[
]
=
"
max
-
age
"
;
static
const
char
kSecure
[
]
=
"
secure
"
;
static
const
char
kHttpOnly
[
]
=
"
httponly
"
;
static
const
char
kSameSite
[
]
=
"
samesite
"
;
static
const
char
kSameSiteLax
[
]
=
"
lax
"
;
static
const
char
kSameSiteStrict
[
]
=
"
strict
"
;
nsACString
:
:
const_char_iterator
tempBegin
tempEnd
;
nsACString
:
:
const_char_iterator
cookieStart
cookieEnd
;
aCookieHeader
.
BeginReading
(
cookieStart
)
;
aCookieHeader
.
EndReading
(
cookieEnd
)
;
aCookieAttributes
.
isSecure
=
false
;
aCookieAttributes
.
isHttpOnly
=
false
;
aCookieAttributes
.
sameSite
=
nsICookie2
:
:
SAMESITE_UNSET
;
nsDependentCSubstring
tokenString
(
cookieStart
cookieStart
)
;
nsDependentCSubstring
tokenValue
(
cookieStart
cookieStart
)
;
bool
newCookie
equalsFound
;
newCookie
=
GetTokenValue
(
cookieStart
cookieEnd
tokenString
tokenValue
equalsFound
)
;
if
(
equalsFound
)
{
aCookieAttributes
.
name
=
tokenString
;
aCookieAttributes
.
value
=
tokenValue
;
}
else
{
aCookieAttributes
.
value
=
tokenString
;
}
while
(
cookieStart
!
=
cookieEnd
&
&
!
newCookie
)
{
newCookie
=
GetTokenValue
(
cookieStart
cookieEnd
tokenString
tokenValue
equalsFound
)
;
if
(
!
tokenValue
.
IsEmpty
(
)
)
{
tokenValue
.
BeginReading
(
tempBegin
)
;
tokenValue
.
EndReading
(
tempEnd
)
;
}
if
(
tokenString
.
LowerCaseEqualsLiteral
(
kPath
)
)
aCookieAttributes
.
path
=
tokenValue
;
else
if
(
tokenString
.
LowerCaseEqualsLiteral
(
kDomain
)
)
aCookieAttributes
.
host
=
tokenValue
;
else
if
(
tokenString
.
LowerCaseEqualsLiteral
(
kExpires
)
)
aCookieAttributes
.
expires
=
tokenValue
;
else
if
(
tokenString
.
LowerCaseEqualsLiteral
(
kMaxage
)
)
aCookieAttributes
.
maxage
=
tokenValue
;
else
if
(
tokenString
.
LowerCaseEqualsLiteral
(
kSecure
)
)
aCookieAttributes
.
isSecure
=
true
;
else
if
(
tokenString
.
LowerCaseEqualsLiteral
(
kHttpOnly
)
)
aCookieAttributes
.
isHttpOnly
=
true
;
else
if
(
tokenString
.
LowerCaseEqualsLiteral
(
kSameSite
)
)
{
if
(
tokenValue
.
LowerCaseEqualsLiteral
(
kSameSiteLax
)
)
{
aCookieAttributes
.
sameSite
=
nsICookie2
:
:
SAMESITE_LAX
;
}
else
if
(
tokenValue
.
LowerCaseEqualsLiteral
(
kSameSiteStrict
)
)
{
aCookieAttributes
.
sameSite
=
nsICookie2
:
:
SAMESITE_STRICT
;
}
}
}
aCookieHeader
.
Rebind
(
cookieStart
cookieEnd
)
;
return
newCookie
;
}
nsresult
nsCookieService
:
:
GetBaseDomain
(
nsIEffectiveTLDService
*
aTLDService
nsIURI
*
aHostURI
nsCString
&
aBaseDomain
bool
&
aRequireHostMatch
)
{
nsresult
rv
=
aTLDService
-
>
GetBaseDomain
(
aHostURI
0
aBaseDomain
)
;
aRequireHostMatch
=
rv
=
=
NS_ERROR_HOST_IS_IP_ADDRESS
|
|
rv
=
=
NS_ERROR_INSUFFICIENT_DOMAIN_LEVELS
;
if
(
aRequireHostMatch
)
{
rv
=
aHostURI
-
>
GetAsciiHost
(
aBaseDomain
)
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
aBaseDomain
.
Length
(
)
=
=
1
&
&
aBaseDomain
.
Last
(
)
=
=
'
.
'
)
return
NS_ERROR_INVALID_ARG
;
if
(
aBaseDomain
.
IsEmpty
(
)
)
{
bool
isFileURI
=
false
;
aHostURI
-
>
SchemeIs
(
"
file
"
&
isFileURI
)
;
if
(
!
isFileURI
)
return
NS_ERROR_INVALID_ARG
;
}
return
NS_OK
;
}
nsresult
nsCookieService
:
:
GetBaseDomainFromHost
(
nsIEffectiveTLDService
*
aTLDService
const
nsACString
&
aHost
nsCString
&
aBaseDomain
)
{
if
(
aHost
.
Length
(
)
=
=
1
&
&
aHost
.
Last
(
)
=
=
'
.
'
)
return
NS_ERROR_INVALID_ARG
;
bool
domain
=
!
aHost
.
IsEmpty
(
)
&
&
aHost
.
First
(
)
=
=
'
.
'
;
nsresult
rv
=
aTLDService
-
>
GetBaseDomainFromHost
(
Substring
(
aHost
domain
)
0
aBaseDomain
)
;
if
(
rv
=
=
NS_ERROR_HOST_IS_IP_ADDRESS
|
|
rv
=
=
NS_ERROR_INSUFFICIENT_DOMAIN_LEVELS
)
{
if
(
domain
)
return
NS_ERROR_INVALID_ARG
;
aBaseDomain
=
aHost
;
return
NS_OK
;
}
return
rv
;
}
nsresult
nsCookieService
:
:
NormalizeHost
(
nsCString
&
aHost
)
{
if
(
!
IsASCII
(
aHost
)
)
{
nsAutoCString
host
;
nsresult
rv
=
mIDNService
-
>
ConvertUTF8toACE
(
aHost
host
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
aHost
=
host
;
}
ToLowerCase
(
aHost
)
;
return
NS_OK
;
}
static
inline
bool
IsSubdomainOf
(
const
nsCString
&
a
const
nsCString
&
b
)
{
if
(
a
=
=
b
)
return
true
;
if
(
a
.
Length
(
)
>
b
.
Length
(
)
)
return
a
[
a
.
Length
(
)
-
b
.
Length
(
)
-
1
]
=
=
'
.
'
&
&
StringEndsWith
(
a
b
)
;
return
false
;
}
CookieStatus
nsCookieService
:
:
CheckPrefs
(
nsICookiePermission
*
aPermissionService
uint8_t
aCookieBehavior
bool
aThirdPartySession
bool
aThirdPartyNonsecureSession
nsIURI
*
aHostURI
bool
aIsForeign
bool
aIsTrackingResource
bool
aFirstPartyStorageAccessGranted
const
char
*
aCookieHeader
const
int
aNumOfCookies
const
OriginAttributes
&
aOriginAttrs
uint32_t
*
aRejectedReason
)
{
nsresult
rv
;
uint32_t
rejectedReason
=
0
;
if
(
!
aRejectedReason
)
{
aRejectedReason
=
&
rejectedReason
;
}
*
aRejectedReason
=
0
;
bool
ftp
;
if
(
NS_SUCCEEDED
(
aHostURI
-
>
SchemeIs
(
"
ftp
"
&
ftp
)
)
&
&
ftp
)
{
COOKIE_LOGFAILURE
(
aCookieHeader
?
SET_COOKIE
:
GET_COOKIE
aHostURI
aCookieHeader
"
ftp
sites
cannot
read
cookies
"
)
;
return
STATUS_REJECTED_WITH_ERROR
;
}
nsCOMPtr
<
nsIPrincipal
>
principal
=
BasePrincipal
:
:
CreateCodebasePrincipal
(
aHostURI
aOriginAttrs
)
;
if
(
!
principal
)
{
COOKIE_LOGFAILURE
(
aCookieHeader
?
SET_COOKIE
:
GET_COOKIE
aHostURI
aCookieHeader
"
non
-
codebase
principals
cannot
get
/
set
cookies
"
)
;
return
STATUS_REJECTED_WITH_ERROR
;
}
if
(
aPermissionService
)
{
nsCookieAccess
access
;
rv
=
aPermissionService
-
>
CanAccess
(
principal
&
access
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
switch
(
access
)
{
case
nsICookiePermission
:
:
ACCESS_DENY
:
COOKIE_LOGFAILURE
(
aCookieHeader
?
SET_COOKIE
:
GET_COOKIE
aHostURI
aCookieHeader
"
cookies
are
blocked
for
this
site
"
)
;
*
aRejectedReason
=
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_BY_PERMISSION
;
return
STATUS_REJECTED
;
case
nsICookiePermission
:
:
ACCESS_ALLOW
:
return
STATUS_ACCEPTED
;
}
}
}
if
(
aIsForeign
&
&
aIsTrackingResource
&
&
!
aFirstPartyStorageAccessGranted
&
&
aCookieBehavior
=
=
nsICookieService
:
:
BEHAVIOR_REJECT_TRACKER
)
{
COOKIE_LOGFAILURE
(
aCookieHeader
?
SET_COOKIE
:
GET_COOKIE
aHostURI
aCookieHeader
"
cookies
are
disabled
in
trackers
"
)
;
*
aRejectedReason
=
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_TRACKER
;
return
STATUS_REJECTED
;
}
if
(
aCookieBehavior
=
=
nsICookieService
:
:
BEHAVIOR_REJECT
&
&
!
aFirstPartyStorageAccessGranted
)
{
COOKIE_LOGFAILURE
(
aCookieHeader
?
SET_COOKIE
:
GET_COOKIE
aHostURI
aCookieHeader
"
cookies
are
disabled
"
)
;
*
aRejectedReason
=
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_ALL
;
return
STATUS_REJECTED
;
}
if
(
aIsForeign
)
{
if
(
aCookieBehavior
=
=
nsICookieService
:
:
BEHAVIOR_REJECT_FOREIGN
&
&
!
aFirstPartyStorageAccessGranted
)
{
COOKIE_LOGFAILURE
(
aCookieHeader
?
SET_COOKIE
:
GET_COOKIE
aHostURI
aCookieHeader
"
context
is
third
party
"
)
;
*
aRejectedReason
=
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_FOREIGN
;
return
STATUS_REJECTED
;
}
if
(
aCookieBehavior
=
=
nsICookieService
:
:
BEHAVIOR_LIMIT_FOREIGN
&
&
!
aFirstPartyStorageAccessGranted
&
&
aNumOfCookies
=
=
0
)
{
COOKIE_LOGFAILURE
(
aCookieHeader
?
SET_COOKIE
:
GET_COOKIE
aHostURI
aCookieHeader
"
context
is
third
party
"
)
;
*
aRejectedReason
=
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_FOREIGN
;
return
STATUS_REJECTED
;
}
if
(
aThirdPartySession
)
return
STATUS_ACCEPT_SESSION
;
if
(
aThirdPartyNonsecureSession
)
{
bool
isHTTPS
=
false
;
aHostURI
-
>
SchemeIs
(
"
https
"
&
isHTTPS
)
;
if
(
!
isHTTPS
)
return
STATUS_ACCEPT_SESSION
;
}
}
return
STATUS_ACCEPTED
;
}
bool
nsCookieService
:
:
CheckDomain
(
nsCookieAttributes
&
aCookieAttributes
nsIURI
*
aHostURI
const
nsCString
&
aBaseDomain
bool
aRequireHostMatch
)
{
nsAutoCString
hostFromURI
;
aHostURI
-
>
GetAsciiHost
(
hostFromURI
)
;
if
(
!
aCookieAttributes
.
host
.
IsEmpty
(
)
)
{
if
(
aCookieAttributes
.
host
.
Length
(
)
>
1
&
&
aCookieAttributes
.
host
.
First
(
)
=
=
'
.
'
)
{
aCookieAttributes
.
host
.
Cut
(
0
1
)
;
}
ToLowerCase
(
aCookieAttributes
.
host
)
;
if
(
aRequireHostMatch
)
return
hostFromURI
.
Equals
(
aCookieAttributes
.
host
)
;
if
(
IsSubdomainOf
(
aCookieAttributes
.
host
aBaseDomain
)
&
&
IsSubdomainOf
(
hostFromURI
aCookieAttributes
.
host
)
)
{
aCookieAttributes
.
host
.
InsertLiteral
(
"
.
"
0
)
;
return
true
;
}
return
false
;
}
aCookieAttributes
.
host
=
hostFromURI
;
return
true
;
}
nsAutoCString
nsCookieService
:
:
GetPathFromURI
(
nsIURI
*
aHostURI
)
{
nsAutoCString
path
;
nsCOMPtr
<
nsIURL
>
hostURL
=
do_QueryInterface
(
aHostURI
)
;
if
(
hostURL
)
{
hostURL
-
>
GetDirectory
(
path
)
;
}
else
{
aHostURI
-
>
GetPathQueryRef
(
path
)
;
int32_t
slash
=
path
.
RFindChar
(
'
/
'
)
;
if
(
slash
!
=
kNotFound
)
{
path
.
Truncate
(
slash
+
1
)
;
}
}
return
path
;
}
bool
nsCookieService
:
:
CheckPath
(
nsCookieAttributes
&
aCookieAttributes
nsIURI
*
aHostURI
)
{
if
(
aCookieAttributes
.
path
.
IsEmpty
(
)
|
|
aCookieAttributes
.
path
.
First
(
)
!
=
'
/
'
)
{
aCookieAttributes
.
path
=
GetPathFromURI
(
aHostURI
)
;
#
if
0
}
else
{
nsAutoCString
pathFromURI
;
if
(
NS_FAILED
(
aHostURI
-
>
GetPathQueryRef
(
pathFromURI
)
)
|
|
!
StringBeginsWith
(
pathFromURI
aCookieAttributes
.
path
)
)
{
return
false
;
}
#
endif
}
if
(
aCookieAttributes
.
path
.
Length
(
)
>
kMaxBytesPerPath
|
|
aCookieAttributes
.
path
.
Contains
(
'
\
t
'
)
)
return
false
;
return
true
;
}
bool
nsCookieService
:
:
CheckPrefixes
(
nsCookieAttributes
&
aCookieAttributes
bool
aSecureRequest
)
{
static
const
char
kSecure
[
]
=
"
__Secure
-
"
;
static
const
char
kHost
[
]
=
"
__Host
-
"
;
static
const
int
kSecureLen
=
sizeof
(
kSecure
)
-
1
;
static
const
int
kHostLen
=
sizeof
(
kHost
)
-
1
;
bool
isSecure
=
strncmp
(
aCookieAttributes
.
name
.
get
(
)
kSecure
kSecureLen
)
=
=
0
;
bool
isHost
=
strncmp
(
aCookieAttributes
.
name
.
get
(
)
kHost
kHostLen
)
=
=
0
;
if
(
!
isSecure
&
&
!
isHost
)
{
return
true
;
}
if
(
!
aSecureRequest
|
|
!
aCookieAttributes
.
isSecure
)
{
return
false
;
}
if
(
isHost
)
{
if
(
aCookieAttributes
.
host
[
0
]
=
=
'
.
'
|
|
!
aCookieAttributes
.
path
.
EqualsLiteral
(
"
/
"
)
)
{
return
false
;
}
}
return
true
;
}
bool
nsCookieService
:
:
GetExpiry
(
nsCookieAttributes
&
aCookieAttributes
int64_t
aServerTime
int64_t
aCurrentTime
)
{
if
(
!
aCookieAttributes
.
maxage
.
IsEmpty
(
)
)
{
int64_t
maxage
;
int32_t
numInts
=
PR_sscanf
(
aCookieAttributes
.
maxage
.
get
(
)
"
%
lld
"
&
maxage
)
;
if
(
numInts
!
=
1
)
{
return
true
;
}
aCookieAttributes
.
expiryTime
=
aCurrentTime
+
maxage
;
}
else
if
(
!
aCookieAttributes
.
expires
.
IsEmpty
(
)
)
{
PRTime
expires
;
if
(
PR_ParseTimeString
(
aCookieAttributes
.
expires
.
get
(
)
true
&
expires
)
!
=
PR_SUCCESS
)
{
return
true
;
}
aCookieAttributes
.
expiryTime
=
expires
/
int64_t
(
PR_USEC_PER_SEC
)
;
}
else
{
return
true
;
}
return
false
;
}
void
nsCookieService
:
:
RemoveAllFromMemory
(
)
{
mDBState
-
>
hostTable
.
Clear
(
)
;
mDBState
-
>
cookieCount
=
0
;
mDBState
-
>
cookieOldestTime
=
INT64_MAX
;
}
class
CompareCookiesByAge
{
public
:
bool
Equals
(
const
nsListIter
&
a
const
nsListIter
&
b
)
const
{
return
a
.
Cookie
(
)
-
>
LastAccessed
(
)
=
=
b
.
Cookie
(
)
-
>
LastAccessed
(
)
&
&
a
.
Cookie
(
)
-
>
CreationTime
(
)
=
=
b
.
Cookie
(
)
-
>
CreationTime
(
)
;
}
bool
LessThan
(
const
nsListIter
&
a
const
nsListIter
&
b
)
const
{
int64_t
result
=
a
.
Cookie
(
)
-
>
LastAccessed
(
)
-
b
.
Cookie
(
)
-
>
LastAccessed
(
)
;
if
(
result
!
=
0
)
return
result
<
0
;
return
a
.
Cookie
(
)
-
>
CreationTime
(
)
<
b
.
Cookie
(
)
-
>
CreationTime
(
)
;
}
}
;
already_AddRefed
<
nsIArray
>
nsCookieService
:
:
PurgeCookies
(
int64_t
aCurrentTimeInUsec
)
{
NS_ASSERTION
(
mDBState
-
>
hostTable
.
Count
(
)
>
0
"
table
is
empty
"
)
;
uint32_t
initialCookieCount
=
mDBState
-
>
cookieCount
;
COOKIE_LOGSTRING
(
LogLevel
:
:
Debug
(
"
PurgeCookies
(
)
:
beginning
purge
with
%
"
PRIu32
"
cookies
and
%
"
PRId64
"
oldest
age
"
mDBState
-
>
cookieCount
aCurrentTimeInUsec
-
mDBState
-
>
cookieOldestTime
)
)
;
typedef
nsTArray
<
nsListIter
>
PurgeList
;
PurgeList
purgeList
(
kMaxNumberOfCookies
)
;
nsCOMPtr
<
nsIMutableArray
>
removedList
=
do_CreateInstance
(
NS_ARRAY_CONTRACTID
)
;
mozIStorageAsyncStatement
*
stmt
=
mDBState
-
>
stmtDelete
;
nsCOMPtr
<
mozIStorageBindingParamsArray
>
paramsArray
;
if
(
mDBState
-
>
dbConn
)
{
stmt
-
>
NewBindingParamsArray
(
getter_AddRefs
(
paramsArray
)
)
;
}
int64_t
currentTime
=
aCurrentTimeInUsec
/
PR_USEC_PER_SEC
;
int64_t
purgeTime
=
aCurrentTimeInUsec
-
mCookiePurgeAge
;
int64_t
oldestTime
=
INT64_MAX
;
for
(
auto
iter
=
mDBState
-
>
hostTable
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
nsCookieEntry
*
entry
=
iter
.
Get
(
)
;
const
nsCookieEntry
:
:
ArrayType
&
cookies
=
entry
-
>
GetCookies
(
)
;
auto
length
=
cookies
.
Length
(
)
;
for
(
nsCookieEntry
:
:
IndexType
i
=
0
;
i
<
length
;
)
{
nsListIter
iter
(
entry
i
)
;
nsCookie
*
cookie
=
cookies
[
i
]
;
if
(
cookie
-
>
Expiry
(
)
<
=
currentTime
)
{
removedList
-
>
AppendElement
(
cookie
)
;
COOKIE_LOGEVICTED
(
cookie
"
Cookie
expired
"
)
;
gCookieService
-
>
RemoveCookieFromList
(
iter
paramsArray
)
;
if
(
i
=
=
-
-
length
)
{
break
;
}
}
else
{
if
(
cookie
-
>
LastAccessed
(
)
<
=
purgeTime
)
{
purgeList
.
AppendElement
(
iter
)
;
}
else
if
(
cookie
-
>
LastAccessed
(
)
<
oldestTime
)
{
oldestTime
=
cookie
-
>
LastAccessed
(
)
;
}
+
+
i
;
}
MOZ_ASSERT
(
length
=
=
cookies
.
Length
(
)
)
;
}
}
uint32_t
postExpiryCookieCount
=
mDBState
-
>
cookieCount
;
purgeList
.
Sort
(
CompareCookiesByAge
(
)
)
;
uint32_t
excess
=
mDBState
-
>
cookieCount
>
mMaxNumberOfCookies
?
mDBState
-
>
cookieCount
-
mMaxNumberOfCookies
:
0
;
if
(
purgeList
.
Length
(
)
>
excess
)
{
oldestTime
=
purgeList
[
excess
]
.
Cookie
(
)
-
>
LastAccessed
(
)
;
purgeList
.
SetLength
(
excess
)
;
}
purgeList
.
Sort
(
CompareCookiesByIndex
(
)
)
;
for
(
PurgeList
:
:
index_type
i
=
purgeList
.
Length
(
)
;
i
-
-
;
)
{
nsCookie
*
cookie
=
purgeList
[
i
]
.
Cookie
(
)
;
removedList
-
>
AppendElement
(
cookie
)
;
COOKIE_LOGEVICTED
(
cookie
"
Cookie
too
old
"
)
;
RemoveCookieFromList
(
purgeList
[
i
]
paramsArray
)
;
}
if
(
paramsArray
)
{
uint32_t
length
;
paramsArray
-
>
GetLength
(
&
length
)
;
if
(
length
)
{
DebugOnly
<
nsresult
>
rv
=
stmt
-
>
BindParameters
(
paramsArray
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
nsCOMPtr
<
mozIStoragePendingStatement
>
handle
;
rv
=
stmt
-
>
ExecuteAsync
(
mDBState
-
>
removeListener
getter_AddRefs
(
handle
)
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
}
}
mDBState
-
>
cookieOldestTime
=
oldestTime
;
COOKIE_LOGSTRING
(
LogLevel
:
:
Debug
(
"
PurgeCookies
(
)
:
%
"
PRIu32
"
expired
;
%
"
PRIu32
"
purged
;
%
"
PRIu32
"
remain
;
%
"
PRId64
"
oldest
age
"
initialCookieCount
-
postExpiryCookieCount
postExpiryCookieCount
-
mDBState
-
>
cookieCount
mDBState
-
>
cookieCount
aCurrentTimeInUsec
-
mDBState
-
>
cookieOldestTime
)
)
;
return
removedList
.
forget
(
)
;
}
NS_IMETHODIMP
nsCookieService
:
:
CookieExists
(
const
nsACString
&
aHost
const
nsACString
&
aPath
const
nsACString
&
aName
JS
:
:
HandleValue
aOriginAttributes
JSContext
*
aCx
bool
*
aFoundCookie
)
{
NS_ENSURE_ARG_POINTER
(
aCx
)
;
NS_ENSURE_ARG_POINTER
(
aFoundCookie
)
;
OriginAttributes
attrs
;
if
(
!
aOriginAttributes
.
isObject
(
)
|
|
!
attrs
.
Init
(
aCx
aOriginAttributes
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
return
CookieExistsNative
(
aHost
aPath
aName
&
attrs
aFoundCookie
)
;
}
NS_IMETHODIMP_
(
nsresult
)
nsCookieService
:
:
CookieExistsNative
(
const
nsACString
&
aHost
const
nsACString
&
aPath
const
nsACString
&
aName
OriginAttributes
*
aOriginAttributes
bool
*
aFoundCookie
)
{
NS_ENSURE_ARG_POINTER
(
aOriginAttributes
)
;
NS_ENSURE_ARG_POINTER
(
aFoundCookie
)
;
if
(
!
mDBState
)
{
NS_WARNING
(
"
No
DBState
!
Profile
already
closed
?
"
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
EnsureReadComplete
(
true
)
;
AutoRestore
<
DBState
*
>
savePrevDBState
(
mDBState
)
;
mDBState
=
(
aOriginAttributes
-
>
mPrivateBrowsingId
>
0
)
?
mPrivateDBState
:
mDefaultDBState
;
nsAutoCString
baseDomain
;
nsresult
rv
=
GetBaseDomainFromHost
(
mTLDService
aHost
baseDomain
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsListIter
iter
;
*
aFoundCookie
=
FindCookie
(
nsCookieKey
(
baseDomain
*
aOriginAttributes
)
PromiseFlatCString
(
aHost
)
PromiseFlatCString
(
aName
)
PromiseFlatCString
(
aPath
)
iter
)
;
return
NS_OK
;
}
class
CookieIterComparator
{
private
:
CompareCookiesByAge
mAgeComparator
;
int64_t
mCurrentTime
;
public
:
explicit
CookieIterComparator
(
int64_t
aTime
)
:
mCurrentTime
(
aTime
)
{
}
bool
LessThan
(
const
nsListIter
&
lhs
const
nsListIter
&
rhs
)
{
bool
lExpired
=
lhs
.
Cookie
(
)
-
>
Expiry
(
)
<
=
mCurrentTime
;
bool
rExpired
=
rhs
.
Cookie
(
)
-
>
Expiry
(
)
<
=
mCurrentTime
;
if
(
lExpired
&
&
!
rExpired
)
{
return
true
;
}
if
(
!
lExpired
&
&
rExpired
)
{
return
false
;
}
return
mAgeComparator
.
LessThan
(
lhs
rhs
)
;
}
}
;
void
nsCookieService
:
:
FindStaleCookies
(
nsCookieEntry
*
aEntry
int64_t
aCurrentTime
const
mozilla
:
:
Maybe
<
bool
>
&
aIsSecure
nsTArray
<
nsListIter
>
&
aOutput
uint32_t
aLimit
)
{
MOZ_ASSERT
(
aLimit
)
;
const
nsCookieEntry
:
:
ArrayType
&
cookies
=
aEntry
-
>
GetCookies
(
)
;
aOutput
.
Clear
(
)
;
CookieIterComparator
comp
(
aCurrentTime
)
;
nsTPriorityQueue
<
nsListIter
CookieIterComparator
>
queue
(
comp
)
;
for
(
nsCookieEntry
:
:
IndexType
i
=
0
;
i
<
cookies
.
Length
(
)
;
+
+
i
)
{
nsCookie
*
cookie
=
cookies
[
i
]
;
if
(
cookie
-
>
Expiry
(
)
<
=
aCurrentTime
)
{
queue
.
Push
(
nsListIter
(
aEntry
i
)
)
;
continue
;
}
if
(
aIsSecure
.
isSome
(
)
&
&
!
aIsSecure
.
value
(
)
)
{
if
(
cookie
-
>
IsSecure
(
)
)
{
continue
;
}
}
queue
.
Push
(
nsListIter
(
aEntry
i
)
)
;
}
uint32_t
count
=
0
;
while
(
!
queue
.
IsEmpty
(
)
&
&
count
<
aLimit
)
{
aOutput
.
AppendElement
(
queue
.
Pop
(
)
)
;
count
+
+
;
}
}
void
nsCookieService
:
:
TelemetryForEvictingStaleCookie
(
nsCookie
*
aEvicted
int64_t
oldestCookieTime
)
{
if
(
!
aEvicted
-
>
IsSecure
(
)
)
{
if
(
aEvicted
-
>
LastAccessed
(
)
>
oldestCookieTime
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
COOKIE_LEAVE_SECURE_ALONE
EVICTED_NEWER_INSECURE
)
;
}
else
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
COOKIE_LEAVE_SECURE_ALONE
EVICTED_OLDEST_COOKIE
)
;
}
}
else
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
COOKIE_LEAVE_SECURE_ALONE
EVICTED_PREFERRED_COOKIE
)
;
}
}
NS_IMETHODIMP
nsCookieService
:
:
CountCookiesFromHost
(
const
nsACString
&
aHost
uint32_t
*
aCountFromHost
)
{
if
(
!
mDBState
)
{
NS_WARNING
(
"
No
DBState
!
Profile
already
closed
?
"
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
EnsureReadComplete
(
true
)
;
nsAutoCString
host
(
aHost
)
;
nsresult
rv
=
NormalizeHost
(
host
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
baseDomain
;
rv
=
GetBaseDomainFromHost
(
mTLDService
host
baseDomain
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCookieKey
key
=
DEFAULT_APP_KEY
(
baseDomain
)
;
nsCookieEntry
*
entry
=
mDBState
-
>
hostTable
.
GetEntry
(
key
)
;
*
aCountFromHost
=
entry
?
entry
-
>
GetCookies
(
)
.
Length
(
)
:
0
;
return
NS_OK
;
}
NS_IMETHODIMP
nsCookieService
:
:
GetCookiesFromHost
(
const
nsACString
&
aHost
JS
:
:
HandleValue
aOriginAttributes
JSContext
*
aCx
nsISimpleEnumerator
*
*
aEnumerator
)
{
if
(
!
mDBState
)
{
NS_WARNING
(
"
No
DBState
!
Profile
already
closed
?
"
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
EnsureReadComplete
(
true
)
;
nsAutoCString
host
(
aHost
)
;
nsresult
rv
=
NormalizeHost
(
host
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
baseDomain
;
rv
=
GetBaseDomainFromHost
(
mTLDService
host
baseDomain
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
OriginAttributes
attrs
;
if
(
!
aOriginAttributes
.
isObject
(
)
|
|
!
attrs
.
Init
(
aCx
aOriginAttributes
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
AutoRestore
<
DBState
*
>
savePrevDBState
(
mDBState
)
;
mDBState
=
(
attrs
.
mPrivateBrowsingId
>
0
)
?
mPrivateDBState
:
mDefaultDBState
;
nsCookieKey
key
=
nsCookieKey
(
baseDomain
attrs
)
;
nsCookieEntry
*
entry
=
mDBState
-
>
hostTable
.
GetEntry
(
key
)
;
if
(
!
entry
)
return
NS_NewEmptyEnumerator
(
aEnumerator
)
;
nsCOMArray
<
nsICookie
>
cookieList
(
mMaxCookiesPerHost
)
;
const
nsCookieEntry
:
:
ArrayType
&
cookies
=
entry
-
>
GetCookies
(
)
;
for
(
nsCookieEntry
:
:
IndexType
i
=
0
;
i
<
cookies
.
Length
(
)
;
+
+
i
)
{
cookieList
.
AppendObject
(
cookies
[
i
]
)
;
}
return
NS_NewArrayEnumerator
(
aEnumerator
cookieList
NS_GET_IID
(
nsICookie2
)
)
;
}
NS_IMETHODIMP
nsCookieService
:
:
GetCookiesWithOriginAttributes
(
const
nsAString
&
aPattern
const
nsACString
&
aHost
nsISimpleEnumerator
*
*
aEnumerator
)
{
mozilla
:
:
OriginAttributesPattern
pattern
;
if
(
!
pattern
.
Init
(
aPattern
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsAutoCString
host
(
aHost
)
;
nsresult
rv
=
NormalizeHost
(
host
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
baseDomain
;
rv
=
GetBaseDomainFromHost
(
mTLDService
host
baseDomain
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
GetCookiesWithOriginAttributes
(
pattern
baseDomain
aEnumerator
)
;
}
nsresult
nsCookieService
:
:
GetCookiesWithOriginAttributes
(
const
mozilla
:
:
OriginAttributesPattern
&
aPattern
const
nsCString
&
aBaseDomain
nsISimpleEnumerator
*
*
aEnumerator
)
{
if
(
!
mDBState
)
{
NS_WARNING
(
"
No
DBState
!
Profile
already
closed
?
"
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
EnsureReadComplete
(
true
)
;
AutoRestore
<
DBState
*
>
savePrevDBState
(
mDBState
)
;
mDBState
=
(
aPattern
.
mPrivateBrowsingId
.
WasPassed
(
)
&
&
aPattern
.
mPrivateBrowsingId
.
Value
(
)
>
0
)
?
mPrivateDBState
:
mDefaultDBState
;
nsCOMArray
<
nsICookie
>
cookies
;
for
(
auto
iter
=
mDBState
-
>
hostTable
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
nsCookieEntry
*
entry
=
iter
.
Get
(
)
;
if
(
!
aBaseDomain
.
IsEmpty
(
)
&
&
!
aBaseDomain
.
Equals
(
entry
-
>
mBaseDomain
)
)
{
continue
;
}
if
(
!
aPattern
.
Matches
(
entry
-
>
mOriginAttributes
)
)
{
continue
;
}
const
nsCookieEntry
:
:
ArrayType
&
entryCookies
=
entry
-
>
GetCookies
(
)
;
for
(
nsCookieEntry
:
:
IndexType
i
=
0
;
i
<
entryCookies
.
Length
(
)
;
+
+
i
)
{
cookies
.
AppendObject
(
entryCookies
[
i
]
)
;
}
}
return
NS_NewArrayEnumerator
(
aEnumerator
cookies
NS_GET_IID
(
nsICookie2
)
)
;
}
NS_IMETHODIMP
nsCookieService
:
:
RemoveCookiesWithOriginAttributes
(
const
nsAString
&
aPattern
const
nsACString
&
aHost
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
mozilla
:
:
OriginAttributesPattern
pattern
;
if
(
!
pattern
.
Init
(
aPattern
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsAutoCString
host
(
aHost
)
;
nsresult
rv
=
NormalizeHost
(
host
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
baseDomain
;
rv
=
GetBaseDomainFromHost
(
mTLDService
host
baseDomain
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
RemoveCookiesWithOriginAttributes
(
pattern
baseDomain
)
;
}
nsresult
nsCookieService
:
:
RemoveCookiesWithOriginAttributes
(
const
mozilla
:
:
OriginAttributesPattern
&
aPattern
const
nsCString
&
aBaseDomain
)
{
if
(
!
mDBState
)
{
NS_WARNING
(
"
No
DBState
!
Profile
already
close
?
"
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
EnsureReadComplete
(
true
)
;
AutoRestore
<
DBState
*
>
savePrevDBState
(
mDBState
)
;
mDBState
=
(
aPattern
.
mPrivateBrowsingId
.
WasPassed
(
)
&
&
aPattern
.
mPrivateBrowsingId
.
Value
(
)
>
0
)
?
mPrivateDBState
:
mDefaultDBState
;
mozStorageTransaction
transaction
(
mDBState
-
>
dbConn
false
)
;
for
(
auto
iter
=
mDBState
-
>
hostTable
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
nsCookieEntry
*
entry
=
iter
.
Get
(
)
;
if
(
!
aBaseDomain
.
IsEmpty
(
)
&
&
!
aBaseDomain
.
Equals
(
entry
-
>
mBaseDomain
)
)
{
continue
;
}
if
(
!
aPattern
.
Matches
(
entry
-
>
mOriginAttributes
)
)
{
continue
;
}
uint32_t
cookiesCount
=
entry
-
>
GetCookies
(
)
.
Length
(
)
;
for
(
nsCookieEntry
:
:
IndexType
i
=
0
;
i
<
cookiesCount
;
+
+
i
)
{
nsListIter
iter
(
entry
0
)
;
RefPtr
<
nsCookie
>
cookie
=
iter
.
Cookie
(
)
;
RemoveCookieFromList
(
iter
)
;
if
(
cookie
)
{
NotifyChanged
(
cookie
u
"
deleted
"
)
;
}
}
}
DebugOnly
<
nsresult
>
rv
=
transaction
.
Commit
(
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
return
NS_OK
;
}
bool
nsCookieService
:
:
FindSecureCookie
(
const
nsCookieKey
&
aKey
nsCookie
*
aCookie
)
{
nsCookieEntry
*
entry
=
mDBState
-
>
hostTable
.
GetEntry
(
aKey
)
;
if
(
!
entry
)
return
false
;
const
nsCookieEntry
:
:
ArrayType
&
cookies
=
entry
-
>
GetCookies
(
)
;
for
(
nsCookieEntry
:
:
IndexType
i
=
0
;
i
<
cookies
.
Length
(
)
;
+
+
i
)
{
nsCookie
*
cookie
=
cookies
[
i
]
;
if
(
!
cookie
-
>
IsSecure
(
)
|
|
!
aCookie
-
>
Name
(
)
.
Equals
(
cookie
-
>
Name
(
)
)
)
continue
;
if
(
DomainMatches
(
cookie
aCookie
-
>
Host
(
)
)
|
|
DomainMatches
(
aCookie
cookie
-
>
Host
(
)
)
)
{
if
(
PathMatches
(
cookie
aCookie
-
>
Path
(
)
)
)
{
return
true
;
}
}
}
return
false
;
}
bool
nsCookieService
:
:
FindCookie
(
const
nsCookieKey
&
aKey
const
nsCString
&
aHost
const
nsCString
&
aName
const
nsCString
&
aPath
nsListIter
&
aIter
)
{
MOZ_ASSERT
(
mInitializedDBStates
)
;
MOZ_ASSERT
(
mInitializedDBConn
)
;
nsCookieEntry
*
entry
=
mDBState
-
>
hostTable
.
GetEntry
(
aKey
)
;
if
(
!
entry
)
return
false
;
const
nsCookieEntry
:
:
ArrayType
&
cookies
=
entry
-
>
GetCookies
(
)
;
for
(
nsCookieEntry
:
:
IndexType
i
=
0
;
i
<
cookies
.
Length
(
)
;
+
+
i
)
{
nsCookie
*
cookie
=
cookies
[
i
]
;
if
(
aHost
.
Equals
(
cookie
-
>
Host
(
)
)
&
&
aPath
.
Equals
(
cookie
-
>
Path
(
)
)
&
&
aName
.
Equals
(
cookie
-
>
Name
(
)
)
)
{
aIter
=
nsListIter
(
entry
i
)
;
return
true
;
}
}
return
false
;
}
void
nsCookieService
:
:
RemoveCookieFromList
(
const
nsListIter
&
aIter
mozIStorageBindingParamsArray
*
aParamsArray
)
{
if
(
!
aIter
.
Cookie
(
)
-
>
IsSession
(
)
&
&
mDBState
-
>
dbConn
)
{
mozIStorageAsyncStatement
*
stmt
=
mDBState
-
>
stmtDelete
;
nsCOMPtr
<
mozIStorageBindingParamsArray
>
paramsArray
(
aParamsArray
)
;
if
(
!
paramsArray
)
{
stmt
-
>
NewBindingParamsArray
(
getter_AddRefs
(
paramsArray
)
)
;
}
nsCOMPtr
<
mozIStorageBindingParams
>
params
;
paramsArray
-
>
NewBindingParams
(
getter_AddRefs
(
params
)
)
;
DebugOnly
<
nsresult
>
rv
=
params
-
>
BindUTF8StringByName
(
NS_LITERAL_CSTRING
(
"
name
"
)
aIter
.
Cookie
(
)
-
>
Name
(
)
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
rv
=
params
-
>
BindUTF8StringByName
(
NS_LITERAL_CSTRING
(
"
host
"
)
aIter
.
Cookie
(
)
-
>
Host
(
)
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
rv
=
params
-
>
BindUTF8StringByName
(
NS_LITERAL_CSTRING
(
"
path
"
)
aIter
.
Cookie
(
)
-
>
Path
(
)
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
nsAutoCString
suffix
;
aIter
.
Cookie
(
)
-
>
OriginAttributesRef
(
)
.
CreateSuffix
(
suffix
)
;
rv
=
params
-
>
BindUTF8StringByName
(
NS_LITERAL_CSTRING
(
"
originAttributes
"
)
suffix
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
rv
=
paramsArray
-
>
AddParams
(
params
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
if
(
!
aParamsArray
)
{
rv
=
stmt
-
>
BindParameters
(
paramsArray
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
nsCOMPtr
<
mozIStoragePendingStatement
>
handle
;
rv
=
stmt
-
>
ExecuteAsync
(
mDBState
-
>
removeListener
getter_AddRefs
(
handle
)
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
}
}
if
(
aIter
.
entry
-
>
GetCookies
(
)
.
Length
(
)
=
=
1
)
{
mDBState
-
>
hostTable
.
RawRemoveEntry
(
aIter
.
entry
)
;
}
else
{
aIter
.
entry
-
>
GetCookies
(
)
.
RemoveElementAt
(
aIter
.
index
)
;
}
-
-
mDBState
-
>
cookieCount
;
}
void
bindCookieParameters
(
mozIStorageBindingParamsArray
*
aParamsArray
const
nsCookieKey
&
aKey
const
nsCookie
*
aCookie
)
{
NS_ASSERTION
(
aParamsArray
"
Null
params
array
passed
to
bindCookieParameters
!
"
)
;
NS_ASSERTION
(
aCookie
"
Null
cookie
passed
to
bindCookieParameters
!
"
)
;
nsCOMPtr
<
mozIStorageBindingParams
>
params
;
DebugOnly
<
nsresult
>
rv
=
aParamsArray
-
>
NewBindingParams
(
getter_AddRefs
(
params
)
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
rv
=
params
-
>
BindUTF8StringByName
(
NS_LITERAL_CSTRING
(
"
baseDomain
"
)
aKey
.
mBaseDomain
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
nsAutoCString
suffix
;
aKey
.
mOriginAttributes
.
CreateSuffix
(
suffix
)
;
rv
=
params
-
>
BindUTF8StringByName
(
NS_LITERAL_CSTRING
(
"
originAttributes
"
)
suffix
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
rv
=
params
-
>
BindUTF8StringByName
(
NS_LITERAL_CSTRING
(
"
name
"
)
aCookie
-
>
Name
(
)
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
rv
=
params
-
>
BindUTF8StringByName
(
NS_LITERAL_CSTRING
(
"
value
"
)
aCookie
-
>
Value
(
)
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
rv
=
params
-
>
BindUTF8StringByName
(
NS_LITERAL_CSTRING
(
"
host
"
)
aCookie
-
>
Host
(
)
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
rv
=
params
-
>
BindUTF8StringByName
(
NS_LITERAL_CSTRING
(
"
path
"
)
aCookie
-
>
Path
(
)
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
rv
=
params
-
>
BindInt64ByName
(
NS_LITERAL_CSTRING
(
"
expiry
"
)
aCookie
-
>
Expiry
(
)
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
rv
=
params
-
>
BindInt64ByName
(
NS_LITERAL_CSTRING
(
"
lastAccessed
"
)
aCookie
-
>
LastAccessed
(
)
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
rv
=
params
-
>
BindInt64ByName
(
NS_LITERAL_CSTRING
(
"
creationTime
"
)
aCookie
-
>
CreationTime
(
)
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
rv
=
params
-
>
BindInt32ByName
(
NS_LITERAL_CSTRING
(
"
isSecure
"
)
aCookie
-
>
IsSecure
(
)
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
rv
=
params
-
>
BindInt32ByName
(
NS_LITERAL_CSTRING
(
"
isHttpOnly
"
)
aCookie
-
>
IsHttpOnly
(
)
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
rv
=
params
-
>
BindInt32ByName
(
NS_LITERAL_CSTRING
(
"
sameSite
"
)
aCookie
-
>
SameSite
(
)
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
rv
=
aParamsArray
-
>
AddParams
(
params
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
}
void
nsCookieService
:
:
UpdateCookieOldestTime
(
DBState
*
aDBState
nsCookie
*
aCookie
)
{
if
(
aCookie
-
>
LastAccessed
(
)
<
aDBState
-
>
cookieOldestTime
)
{
aDBState
-
>
cookieOldestTime
=
aCookie
-
>
LastAccessed
(
)
;
}
}
void
nsCookieService
:
:
AddCookieToList
(
const
nsCookieKey
&
aKey
nsCookie
*
aCookie
DBState
*
aDBState
mozIStorageBindingParamsArray
*
aParamsArray
bool
aWriteToDB
)
{
NS_ASSERTION
(
!
(
aDBState
-
>
dbConn
&
&
!
aWriteToDB
&
&
aParamsArray
)
"
Not
writing
to
the
DB
but
have
a
params
array
?
"
)
;
NS_ASSERTION
(
!
(
!
aDBState
-
>
dbConn
&
&
aParamsArray
)
"
Do
not
have
a
DB
connection
but
have
a
params
array
?
"
)
;
if
(
!
aCookie
)
{
NS_WARNING
(
"
Attempting
to
AddCookieToList
with
null
cookie
"
)
;
return
;
}
nsCookieEntry
*
entry
=
aDBState
-
>
hostTable
.
PutEntry
(
aKey
)
;
NS_ASSERTION
(
entry
"
can
'
t
insert
element
into
a
null
entry
!
"
)
;
entry
-
>
GetCookies
(
)
.
AppendElement
(
aCookie
)
;
+
+
aDBState
-
>
cookieCount
;
UpdateCookieOldestTime
(
aDBState
aCookie
)
;
if
(
aWriteToDB
&
&
!
aCookie
-
>
IsSession
(
)
&
&
aDBState
-
>
dbConn
)
{
mozIStorageAsyncStatement
*
stmt
=
aDBState
-
>
stmtInsert
;
nsCOMPtr
<
mozIStorageBindingParamsArray
>
paramsArray
(
aParamsArray
)
;
if
(
!
paramsArray
)
{
stmt
-
>
NewBindingParamsArray
(
getter_AddRefs
(
paramsArray
)
)
;
}
bindCookieParameters
(
paramsArray
aKey
aCookie
)
;
if
(
!
aParamsArray
)
{
DebugOnly
<
nsresult
>
rv
=
stmt
-
>
BindParameters
(
paramsArray
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
nsCOMPtr
<
mozIStoragePendingStatement
>
handle
;
rv
=
stmt
-
>
ExecuteAsync
(
mDBState
-
>
insertListener
getter_AddRefs
(
handle
)
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
}
}
}
void
nsCookieService
:
:
UpdateCookieInList
(
nsCookie
*
aCookie
int64_t
aLastAccessed
mozIStorageBindingParamsArray
*
aParamsArray
)
{
NS_ASSERTION
(
aCookie
"
Passing
a
null
cookie
to
UpdateCookieInList
!
"
)
;
aCookie
-
>
SetLastAccessed
(
aLastAccessed
)
;
if
(
!
aCookie
-
>
IsSession
(
)
&
&
aParamsArray
)
{
nsCOMPtr
<
mozIStorageBindingParams
>
params
;
aParamsArray
-
>
NewBindingParams
(
getter_AddRefs
(
params
)
)
;
DebugOnly
<
nsresult
>
rv
=
params
-
>
BindInt64ByName
(
NS_LITERAL_CSTRING
(
"
lastAccessed
"
)
aLastAccessed
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
rv
=
params
-
>
BindUTF8StringByName
(
NS_LITERAL_CSTRING
(
"
name
"
)
aCookie
-
>
Name
(
)
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
rv
=
params
-
>
BindUTF8StringByName
(
NS_LITERAL_CSTRING
(
"
host
"
)
aCookie
-
>
Host
(
)
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
rv
=
params
-
>
BindUTF8StringByName
(
NS_LITERAL_CSTRING
(
"
path
"
)
aCookie
-
>
Path
(
)
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
nsAutoCString
suffix
;
aCookie
-
>
OriginAttributesRef
(
)
.
CreateSuffix
(
suffix
)
;
rv
=
params
-
>
BindUTF8StringByName
(
NS_LITERAL_CSTRING
(
"
originAttributes
"
)
suffix
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
rv
=
aParamsArray
-
>
AddParams
(
params
)
;
NS_ASSERT_SUCCESS
(
rv
)
;
}
}
size_t
nsCookieService
:
:
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
aMallocSizeOf
(
this
)
;
if
(
mDefaultDBState
)
{
n
+
=
mDefaultDBState
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
if
(
mPrivateDBState
)
{
n
+
=
mPrivateDBState
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
return
n
;
}
MOZ_DEFINE_MALLOC_SIZE_OF
(
CookieServiceMallocSizeOf
)
NS_IMETHODIMP
nsCookieService
:
:
CollectReports
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
bool
aAnonymize
)
{
MOZ_COLLECT_REPORT
(
"
explicit
/
cookie
-
service
"
KIND_HEAP
UNITS_BYTES
SizeOfIncludingThis
(
CookieServiceMallocSizeOf
)
"
Memory
used
by
the
cookie
service
.
"
)
;
return
NS_OK
;
}
