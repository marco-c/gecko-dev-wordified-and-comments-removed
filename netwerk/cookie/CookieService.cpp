#
include
"
CookieCommons
.
h
"
#
include
"
CookieLogging
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
ContentBlockingNotifier
.
h
"
#
include
"
mozilla
/
dom
/
nsMixedContentBlocker
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
net
/
CookieJarSettings
.
h
"
#
include
"
mozilla
/
net
/
CookiePermission
.
h
"
#
include
"
mozilla
/
net
/
CookiePersistentStorage
.
h
"
#
include
"
mozilla
/
net
/
CookiePrivateStorage
.
h
"
#
include
"
mozilla
/
net
/
CookieService
.
h
"
#
include
"
mozilla
/
net
/
CookieServiceChild
.
h
"
#
include
"
mozilla
/
net
/
HttpBaseChannel
.
h
"
#
include
"
mozilla
/
net
/
NeckoCommon
.
h
"
#
include
"
mozilla
/
StaticPrefs_network
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozIThirdPartyUtil
.
h
"
#
include
"
nsIEffectiveTLDService
.
h
"
#
include
"
nsIIDNService
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsIURL
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
prprf
.
h
"
using
namespace
mozilla
:
:
dom
;
namespace
mozilla
{
namespace
net
{
static
StaticRefPtr
<
CookieService
>
gCookieService
;
#
define
CONSOLE_SAMESITE_CATEGORY
NS_LITERAL_CSTRING
(
"
cookieSameSite
"
)
#
define
CONSOLE_GENERIC_CATEGORY
NS_LITERAL_CSTRING
(
"
cookies
"
)
#
define
SAMESITE_MDN_URL
\
NS_LITERAL_STRING
(
"
https
:
/
/
developer
.
mozilla
.
org
/
docs
/
Web
/
HTTP
/
Cookies
"
)
namespace
{
bool
ProcessSameSiteCookieForForeignRequest
(
nsIChannel
*
aChannel
Cookie
*
aCookie
bool
aIsSafeTopLevelNav
bool
aLaxByDefault
)
{
int32_t
sameSiteAttr
=
0
;
aCookie
-
>
GetSameSite
(
&
sameSiteAttr
)
;
if
(
sameSiteAttr
=
=
nsICookie
:
:
SAMESITE_STRICT
)
{
return
false
;
}
int64_t
currentTimeInUsec
=
PR_Now
(
)
;
if
(
StaticPrefs
:
:
network_cookie_sameSite_laxPlusPOST_timeout
(
)
>
0
&
&
aLaxByDefault
&
&
sameSiteAttr
=
=
nsICookie
:
:
SAMESITE_LAX
&
&
aCookie
-
>
RawSameSite
(
)
=
=
nsICookie
:
:
SAMESITE_NONE
&
&
currentTimeInUsec
-
aCookie
-
>
CreationTime
(
)
<
=
(
StaticPrefs
:
:
network_cookie_sameSite_laxPlusPOST_timeout
(
)
*
PR_USEC_PER_SEC
)
&
&
!
NS_IsSafeMethodNav
(
aChannel
)
)
{
return
true
;
}
return
sameSiteAttr
!
=
nsICookie
:
:
SAMESITE_LAX
|
|
aIsSafeTopLevelNav
;
}
}
already_AddRefed
<
nsICookieService
>
CookieService
:
:
GetXPCOMSingleton
(
)
{
if
(
IsNeckoChild
(
)
)
return
CookieServiceChild
:
:
GetSingleton
(
)
;
return
GetSingleton
(
)
;
}
already_AddRefed
<
CookieService
>
CookieService
:
:
GetSingleton
(
)
{
NS_ASSERTION
(
!
IsNeckoChild
(
)
"
not
a
parent
process
"
)
;
if
(
gCookieService
)
{
return
do_AddRef
(
gCookieService
)
;
}
gCookieService
=
new
CookieService
(
)
;
if
(
gCookieService
)
{
if
(
NS_SUCCEEDED
(
gCookieService
-
>
Init
(
)
)
)
{
ClearOnShutdown
(
&
gCookieService
)
;
}
else
{
gCookieService
=
nullptr
;
}
}
return
do_AddRef
(
gCookieService
)
;
}
NS_IMPL_ISUPPORTS
(
CookieService
nsICookieService
nsICookieManager
nsIObserver
nsISupportsWeakReference
nsIMemoryReporter
)
CookieService
:
:
CookieService
(
)
=
default
;
nsresult
CookieService
:
:
Init
(
)
{
nsresult
rv
;
mTLDService
=
do_GetService
(
NS_EFFECTIVETLDSERVICE_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mIDNService
=
do_GetService
(
NS_IDNSERVICE_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mThirdPartyUtil
=
do_GetService
(
THIRDPARTYUTIL_CONTRACTID
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
InitCookieStorages
(
)
;
RegisterWeakMemoryReporter
(
this
)
;
nsCOMPtr
<
nsIObserverService
>
os
=
services
:
:
GetObserverService
(
)
;
NS_ENSURE_STATE
(
os
)
;
os
-
>
AddObserver
(
this
"
profile
-
before
-
change
"
true
)
;
os
-
>
AddObserver
(
this
"
profile
-
do
-
change
"
true
)
;
os
-
>
AddObserver
(
this
"
last
-
pb
-
context
-
exited
"
true
)
;
mPermissionService
=
CookiePermission
:
:
GetOrCreate
(
)
;
return
NS_OK
;
}
void
CookieService
:
:
InitCookieStorages
(
)
{
NS_ASSERTION
(
!
mPersistentStorage
"
already
have
a
default
CookieStorage
"
)
;
NS_ASSERTION
(
!
mPrivateStorage
"
already
have
a
private
CookieStorage
"
)
;
mPersistentStorage
=
CookiePersistentStorage
:
:
Create
(
)
;
mPrivateStorage
=
CookiePrivateStorage
:
:
Create
(
)
;
mPersistentStorage
-
>
Activate
(
)
;
}
void
CookieService
:
:
CloseCookieStorages
(
)
{
if
(
!
mPersistentStorage
)
{
return
;
}
mPrivateStorage
-
>
Close
(
)
;
mPrivateStorage
=
nullptr
;
mPersistentStorage
-
>
Close
(
)
;
mPersistentStorage
=
nullptr
;
}
CookieService
:
:
~
CookieService
(
)
{
CloseCookieStorages
(
)
;
UnregisterWeakMemoryReporter
(
this
)
;
gCookieService
=
nullptr
;
}
NS_IMETHODIMP
CookieService
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
if
(
!
strcmp
(
aTopic
"
profile
-
before
-
change
"
)
)
{
CloseCookieStorages
(
)
;
}
else
if
(
!
strcmp
(
aTopic
"
profile
-
do
-
change
"
)
)
{
NS_ASSERTION
(
!
mPersistentStorage
"
shouldn
'
t
have
a
default
CookieStorage
"
)
;
NS_ASSERTION
(
!
mPrivateStorage
"
shouldn
'
t
have
a
private
CookieStorage
"
)
;
InitCookieStorages
(
)
;
}
else
if
(
!
strcmp
(
aTopic
"
last
-
pb
-
context
-
exited
"
)
)
{
OriginAttributesPattern
pattern
;
pattern
.
mPrivateBrowsingId
.
Construct
(
1
)
;
RemoveCookiesWithOriginAttributes
(
pattern
EmptyCString
(
)
)
;
mPrivateStorage
=
CookiePrivateStorage
:
:
Create
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
CookieService
:
:
GetCookieString
(
nsIURI
*
aHostURI
nsIChannel
*
aChannel
nsACString
&
aCookie
)
{
return
GetCookieStringCommon
(
aHostURI
aChannel
false
aCookie
)
;
}
NS_IMETHODIMP
CookieService
:
:
GetCookieStringFromHttp
(
nsIURI
*
aHostURI
nsIURI
*
aFirstURI
nsIChannel
*
aChannel
nsACString
&
aCookie
)
{
return
GetCookieStringCommon
(
aHostURI
aChannel
true
aCookie
)
;
}
nsresult
CookieService
:
:
GetCookieStringCommon
(
nsIURI
*
aHostURI
nsIChannel
*
aChannel
bool
aHttpBound
nsACString
&
aCookie
)
{
NS_ENSURE_ARG
(
aHostURI
)
;
aCookie
.
Truncate
(
)
;
uint32_t
rejectedReason
=
0
;
ThirdPartyAnalysisResult
result
=
mThirdPartyUtil
-
>
AnalyzeChannel
(
aChannel
false
aHostURI
nullptr
&
rejectedReason
)
;
OriginAttributes
attrs
;
if
(
aChannel
)
{
NS_GetOriginAttributes
(
aChannel
attrs
true
)
;
}
bool
isSafeTopLevelNav
=
NS_IsSafeTopLevelNav
(
aChannel
)
;
bool
isSameSiteForeign
=
NS_IsSameSiteForeign
(
aChannel
aHostURI
)
;
GetCookieStringInternal
(
aHostURI
aChannel
result
.
contains
(
ThirdPartyAnalysis
:
:
IsForeign
)
result
.
contains
(
ThirdPartyAnalysis
:
:
IsThirdPartyTrackingResource
)
result
.
contains
(
ThirdPartyAnalysis
:
:
IsThirdPartySocialTrackingResource
)
result
.
contains
(
ThirdPartyAnalysis
:
:
IsFirstPartyStorageAccessGranted
)
rejectedReason
isSafeTopLevelNav
isSameSiteForeign
aHttpBound
attrs
aCookie
)
;
return
NS_OK
;
}
already_AddRefed
<
nsICookieJarSettings
>
CookieService
:
:
GetCookieJarSettings
(
nsIChannel
*
aChannel
)
{
nsCOMPtr
<
nsICookieJarSettings
>
cookieJarSettings
;
if
(
aChannel
)
{
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
aChannel
-
>
LoadInfo
(
)
;
nsresult
rv
=
loadInfo
-
>
GetCookieJarSettings
(
getter_AddRefs
(
cookieJarSettings
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
cookieJarSettings
=
CookieJarSettings
:
:
GetBlockingAll
(
)
;
}
}
else
{
cookieJarSettings
=
CookieJarSettings
:
:
Create
(
)
;
}
MOZ_ASSERT
(
cookieJarSettings
)
;
return
cookieJarSettings
.
forget
(
)
;
}
NS_IMETHODIMP
CookieService
:
:
SetCookieString
(
nsIURI
*
aHostURI
const
nsACString
&
aCookieHeader
nsIChannel
*
aChannel
)
{
return
SetCookieStringCommon
(
aHostURI
aCookieHeader
VoidCString
(
)
aChannel
false
)
;
}
NS_IMETHODIMP
CookieService
:
:
SetCookieStringFromHttp
(
nsIURI
*
aHostURI
nsIURI
*
aFirstURI
const
nsACString
&
aCookieHeader
const
nsACString
&
aServerTime
nsIChannel
*
aChannel
)
{
return
SetCookieStringCommon
(
aHostURI
aCookieHeader
aServerTime
aChannel
true
)
;
}
int64_t
CookieService
:
:
ParseServerTime
(
const
nsACString
&
aServerTime
)
{
PRTime
tempServerTime
;
int64_t
serverTime
;
PRStatus
result
=
PR_ParseTimeString
(
aServerTime
.
BeginReading
(
)
true
&
tempServerTime
)
;
if
(
result
=
=
PR_SUCCESS
)
{
serverTime
=
tempServerTime
/
int64_t
(
PR_USEC_PER_SEC
)
;
}
else
{
serverTime
=
PR_Now
(
)
/
PR_USEC_PER_SEC
;
}
return
serverTime
;
}
nsresult
CookieService
:
:
SetCookieStringCommon
(
nsIURI
*
aHostURI
const
nsACString
&
aCookieHeader
const
nsACString
&
aServerTime
nsIChannel
*
aChannel
bool
aFromHttp
)
{
NS_ENSURE_ARG
(
aHostURI
)
;
uint32_t
rejectedReason
=
0
;
ThirdPartyAnalysisResult
result
=
mThirdPartyUtil
-
>
AnalyzeChannel
(
aChannel
false
aHostURI
nullptr
&
rejectedReason
)
;
OriginAttributes
attrs
;
if
(
aChannel
)
{
NS_GetOriginAttributes
(
aChannel
attrs
true
)
;
}
nsCString
cookieString
(
aCookieHeader
)
;
SetCookieStringInternal
(
aHostURI
result
.
contains
(
ThirdPartyAnalysis
:
:
IsForeign
)
result
.
contains
(
ThirdPartyAnalysis
:
:
IsThirdPartyTrackingResource
)
result
.
contains
(
ThirdPartyAnalysis
:
:
IsThirdPartySocialTrackingResource
)
result
.
contains
(
ThirdPartyAnalysis
:
:
IsFirstPartyStorageAccessGranted
)
rejectedReason
cookieString
aServerTime
aFromHttp
attrs
aChannel
)
;
return
NS_OK
;
}
void
CookieService
:
:
SetCookieStringInternal
(
nsIURI
*
aHostURI
bool
aIsForeign
bool
aIsThirdPartyTrackingResource
bool
aIsThirdPartySocialTrackingResource
bool
aFirstPartyStorageAccessGranted
uint32_t
aRejectedReason
nsCString
&
aCookieHeader
const
nsACString
&
aServerTime
bool
aFromHttp
const
OriginAttributes
&
aOriginAttrs
nsIChannel
*
aChannel
)
{
NS_ASSERTION
(
aHostURI
"
null
host
!
"
)
;
if
(
!
IsInitialized
(
)
)
{
return
;
}
CookieStorage
*
storage
=
PickStorage
(
aOriginAttrs
)
;
bool
requireHostMatch
;
nsAutoCString
baseDomain
;
nsresult
rv
=
CookieCommons
:
:
GetBaseDomain
(
mTLDService
aHostURI
baseDomain
requireHostMatch
)
;
if
(
NS_FAILED
(
rv
)
)
{
COOKIE_LOGFAILURE
(
SET_COOKIE
aHostURI
aCookieHeader
"
couldn
'
t
get
base
domain
from
URI
"
)
;
return
;
}
nsCOMPtr
<
nsICookieJarSettings
>
cookieJarSettings
=
GetCookieJarSettings
(
aChannel
)
;
nsAutoCString
hostFromURI
;
aHostURI
-
>
GetHost
(
hostFromURI
)
;
rv
=
NormalizeHost
(
hostFromURI
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
nsAutoCString
baseDomainFromURI
;
rv
=
CookieCommons
:
:
GetBaseDomainFromHost
(
mTLDService
hostFromURI
baseDomainFromURI
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
uint32_t
priorCookieCount
=
storage
-
>
CountCookiesFromHost
(
baseDomainFromURI
aOriginAttrs
.
mPrivateBrowsingId
)
;
uint32_t
rejectedReason
=
aRejectedReason
;
CookieStatus
cookieStatus
=
CheckPrefs
(
cookieJarSettings
aHostURI
aIsForeign
aIsThirdPartyTrackingResource
aIsThirdPartySocialTrackingResource
aFirstPartyStorageAccessGranted
aCookieHeader
priorCookieCount
aOriginAttrs
&
rejectedReason
)
;
MOZ_ASSERT_IF
(
rejectedReason
cookieStatus
=
=
STATUS_REJECTED
)
;
switch
(
cookieStatus
)
{
case
STATUS_REJECTED
:
NotifyRejected
(
aHostURI
aChannel
rejectedReason
OPERATION_WRITE
)
;
return
;
case
STATUS_REJECTED_WITH_ERROR
:
NotifyRejected
(
aHostURI
aChannel
rejectedReason
OPERATION_WRITE
)
;
return
;
case
STATUS_ACCEPTED
:
case
STATUS_ACCEPT_SESSION
:
NotifyAccepted
(
aChannel
)
;
break
;
default
:
break
;
}
int64_t
serverTime
=
ParseServerTime
(
aServerTime
)
;
while
(
SetCookieInternal
(
storage
aHostURI
baseDomain
aOriginAttrs
requireHostMatch
cookieStatus
aCookieHeader
serverTime
aFromHttp
aChannel
)
)
{
if
(
!
aFromHttp
)
break
;
}
}
void
CookieService
:
:
NotifyAccepted
(
nsIChannel
*
aChannel
)
{
ContentBlockingNotifier
:
:
OnDecision
(
aChannel
ContentBlockingNotifier
:
:
BlockingDecision
:
:
eAllow
0
)
;
}
void
CookieService
:
:
NotifyRejected
(
nsIURI
*
aHostURI
nsIChannel
*
aChannel
uint32_t
aRejectedReason
CookieOperation
aOperation
)
{
if
(
aOperation
=
=
OPERATION_WRITE
)
{
nsCOMPtr
<
nsIObserverService
>
os
=
services
:
:
GetObserverService
(
)
;
if
(
os
)
{
os
-
>
NotifyObservers
(
aHostURI
"
cookie
-
rejected
"
nullptr
)
;
}
}
else
{
MOZ_ASSERT
(
aOperation
=
=
OPERATION_READ
)
;
}
ContentBlockingNotifier
:
:
OnDecision
(
aChannel
ContentBlockingNotifier
:
:
BlockingDecision
:
:
eBlock
aRejectedReason
)
;
}
NS_IMETHODIMP
CookieService
:
:
RunInTransaction
(
nsICookieTransactionCallback
*
aCallback
)
{
NS_ENSURE_ARG
(
aCallback
)
;
if
(
!
IsInitialized
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
mPersistentStorage
-
>
EnsureReadComplete
(
)
;
return
mPersistentStorage
-
>
RunInTransaction
(
aCallback
)
;
}
NS_IMETHODIMP
CookieService
:
:
RemoveAll
(
)
{
if
(
!
IsInitialized
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
mPersistentStorage
-
>
EnsureReadComplete
(
)
;
mPersistentStorage
-
>
RemoveAll
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
CookieService
:
:
GetCookies
(
nsTArray
<
RefPtr
<
nsICookie
>
>
&
aCookies
)
{
if
(
!
IsInitialized
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
mPersistentStorage
-
>
EnsureReadComplete
(
)
;
mPersistentStorage
-
>
GetCookies
(
aCookies
)
;
return
NS_OK
;
}
NS_IMETHODIMP
CookieService
:
:
GetSessionCookies
(
nsTArray
<
RefPtr
<
nsICookie
>
>
&
aCookies
)
{
if
(
!
IsInitialized
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
mPersistentStorage
-
>
EnsureReadComplete
(
)
;
mPersistentStorage
-
>
GetCookies
(
aCookies
)
;
return
NS_OK
;
}
NS_IMETHODIMP
CookieService
:
:
Add
(
const
nsACString
&
aHost
const
nsACString
&
aPath
const
nsACString
&
aName
const
nsACString
&
aValue
bool
aIsSecure
bool
aIsHttpOnly
bool
aIsSession
int64_t
aExpiry
JS
:
:
HandleValue
aOriginAttributes
int32_t
aSameSite
JSContext
*
aCx
)
{
OriginAttributes
attrs
;
if
(
!
aOriginAttributes
.
isObject
(
)
|
|
!
attrs
.
Init
(
aCx
aOriginAttributes
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
return
AddNative
(
aHost
aPath
aName
aValue
aIsSecure
aIsHttpOnly
aIsSession
aExpiry
&
attrs
aSameSite
)
;
}
NS_IMETHODIMP_
(
nsresult
)
CookieService
:
:
AddNative
(
const
nsACString
&
aHost
const
nsACString
&
aPath
const
nsACString
&
aName
const
nsACString
&
aValue
bool
aIsSecure
bool
aIsHttpOnly
bool
aIsSession
int64_t
aExpiry
OriginAttributes
*
aOriginAttributes
int32_t
aSameSite
)
{
if
(
NS_WARN_IF
(
!
aOriginAttributes
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
IsInitialized
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsAutoCString
host
(
aHost
)
;
nsresult
rv
=
NormalizeHost
(
host
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
baseDomain
;
rv
=
CookieCommons
:
:
GetBaseDomainFromHost
(
mTLDService
host
baseDomain
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
int64_t
currentTimeInUsec
=
PR_Now
(
)
;
CookieKey
key
=
CookieKey
(
baseDomain
*
aOriginAttributes
)
;
RefPtr
<
Cookie
>
cookie
=
Cookie
:
:
Create
(
aName
aValue
host
aPath
aExpiry
currentTimeInUsec
Cookie
:
:
GenerateUniqueCreationTime
(
currentTimeInUsec
)
aIsSession
aIsSecure
aIsHttpOnly
key
.
mOriginAttributes
aSameSite
aSameSite
)
;
if
(
!
cookie
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
CookieStorage
*
storage
=
PickStorage
(
*
aOriginAttributes
)
;
storage
-
>
AddCookie
(
baseDomain
*
aOriginAttributes
cookie
currentTimeInUsec
nullptr
VoidCString
(
)
true
)
;
return
NS_OK
;
}
nsresult
CookieService
:
:
Remove
(
const
nsACString
&
aHost
const
OriginAttributes
&
aAttrs
const
nsACString
&
aName
const
nsACString
&
aPath
)
{
nsAutoCString
host
(
aHost
)
;
nsresult
rv
=
NormalizeHost
(
host
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
baseDomain
;
if
(
!
host
.
IsEmpty
(
)
)
{
rv
=
CookieCommons
:
:
GetBaseDomainFromHost
(
mTLDService
host
baseDomain
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
!
IsInitialized
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
CookieStorage
*
storage
=
PickStorage
(
aAttrs
)
;
storage
-
>
RemoveCookie
(
baseDomain
aAttrs
host
PromiseFlatCString
(
aName
)
PromiseFlatCString
(
aPath
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
CookieService
:
:
Remove
(
const
nsACString
&
aHost
const
nsACString
&
aName
const
nsACString
&
aPath
JS
:
:
HandleValue
aOriginAttributes
JSContext
*
aCx
)
{
OriginAttributes
attrs
;
if
(
!
aOriginAttributes
.
isObject
(
)
|
|
!
attrs
.
Init
(
aCx
aOriginAttributes
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
return
RemoveNative
(
aHost
aName
aPath
&
attrs
)
;
}
NS_IMETHODIMP_
(
nsresult
)
CookieService
:
:
RemoveNative
(
const
nsACString
&
aHost
const
nsACString
&
aName
const
nsACString
&
aPath
OriginAttributes
*
aOriginAttributes
)
{
if
(
NS_WARN_IF
(
!
aOriginAttributes
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
Remove
(
aHost
*
aOriginAttributes
aName
aPath
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
NS_IMETHODIMP
CookieService
:
:
ImportCookies
(
nsIFile
*
aCookieFile
)
{
if
(
!
IsInitialized
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
mPersistentStorage
-
>
EnsureReadComplete
(
)
;
return
mPersistentStorage
-
>
ImportCookies
(
aCookieFile
)
;
}
void
CookieService
:
:
GetCookiesForURI
(
nsIURI
*
aHostURI
nsIChannel
*
aChannel
bool
aIsForeign
bool
aIsThirdPartyTrackingResource
bool
aIsThirdPartySocialTrackingResource
bool
aFirstPartyStorageAccessGranted
uint32_t
aRejectedReason
bool
aIsSafeTopLevelNav
bool
aIsSameSiteForeign
bool
aHttpBound
const
OriginAttributes
&
aOriginAttrs
nsTArray
<
Cookie
*
>
&
aCookieList
)
{
NS_ASSERTION
(
aHostURI
"
null
host
!
"
)
;
if
(
!
IsInitialized
(
)
)
{
return
;
}
CookieStorage
*
storage
=
PickStorage
(
aOriginAttrs
)
;
bool
requireHostMatch
;
nsAutoCString
baseDomain
hostFromURI
pathFromURI
;
nsresult
rv
=
CookieCommons
:
:
GetBaseDomain
(
mTLDService
aHostURI
baseDomain
requireHostMatch
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
rv
=
aHostURI
-
>
GetAsciiHost
(
hostFromURI
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
rv
=
aHostURI
-
>
GetFilePath
(
pathFromURI
)
;
if
(
NS_FAILED
(
rv
)
)
{
COOKIE_LOGFAILURE
(
GET_COOKIE
aHostURI
VoidCString
(
)
"
invalid
host
/
path
from
URI
"
)
;
return
;
}
nsCOMPtr
<
nsICookieJarSettings
>
cookieJarSettings
=
GetCookieJarSettings
(
aChannel
)
;
nsAutoCString
normalizedHostFromURI
(
hostFromURI
)
;
rv
=
NormalizeHost
(
normalizedHostFromURI
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
nsAutoCString
baseDomainFromURI
;
rv
=
CookieCommons
:
:
GetBaseDomainFromHost
(
mTLDService
normalizedHostFromURI
baseDomainFromURI
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
uint32_t
rejectedReason
=
aRejectedReason
;
uint32_t
priorCookieCount
=
storage
-
>
CountCookiesFromHost
(
baseDomainFromURI
aOriginAttrs
.
mPrivateBrowsingId
)
;
CookieStatus
cookieStatus
=
CheckPrefs
(
cookieJarSettings
aHostURI
aIsForeign
aIsThirdPartyTrackingResource
aIsThirdPartySocialTrackingResource
aFirstPartyStorageAccessGranted
VoidCString
(
)
priorCookieCount
aOriginAttrs
&
rejectedReason
)
;
MOZ_ASSERT_IF
(
rejectedReason
cookieStatus
=
=
STATUS_REJECTED
)
;
switch
(
cookieStatus
)
{
case
STATUS_REJECTED
:
if
(
priorCookieCount
)
{
NotifyRejected
(
aHostURI
aChannel
rejectedReason
OPERATION_READ
)
;
}
return
;
default
:
break
;
}
bool
potentiallyTurstworthy
=
nsMixedContentBlocker
:
:
IsPotentiallyTrustworthyOrigin
(
aHostURI
)
;
int64_t
currentTimeInUsec
=
PR_Now
(
)
;
int64_t
currentTime
=
currentTimeInUsec
/
PR_USEC_PER_SEC
;
bool
stale
=
false
;
const
nsTArray
<
RefPtr
<
Cookie
>
>
*
cookies
=
storage
-
>
GetCookiesFromHost
(
baseDomain
aOriginAttrs
)
;
if
(
!
cookies
)
return
;
bool
laxByDefault
=
StaticPrefs
:
:
network_cookie_sameSite_laxByDefault
(
)
&
&
!
nsContentUtils
:
:
IsURIInPrefList
(
aHostURI
"
network
.
cookie
.
sameSite
.
laxByDefault
.
disabledHosts
"
)
;
for
(
Cookie
*
cookie
:
*
cookies
)
{
if
(
!
CookieCommons
:
:
DomainMatches
(
cookie
hostFromURI
)
)
continue
;
if
(
cookie
-
>
IsSecure
(
)
&
&
!
potentiallyTurstworthy
)
continue
;
if
(
aIsSameSiteForeign
&
&
!
ProcessSameSiteCookieForForeignRequest
(
aChannel
cookie
aIsSafeTopLevelNav
laxByDefault
)
)
{
continue
;
}
if
(
cookie
-
>
IsHttpOnly
(
)
&
&
!
aHttpBound
)
continue
;
if
(
!
CookieCommons
:
:
PathMatches
(
cookie
pathFromURI
)
)
continue
;
if
(
cookie
-
>
Expiry
(
)
<
=
currentTime
)
{
continue
;
}
aCookieList
.
AppendElement
(
cookie
)
;
if
(
cookie
-
>
IsStale
(
)
)
{
stale
=
true
;
}
}
if
(
aCookieList
.
IsEmpty
(
)
)
{
return
;
}
NotifyAccepted
(
aChannel
)
;
if
(
stale
)
{
storage
-
>
StaleCookies
(
aCookieList
currentTimeInUsec
)
;
}
aCookieList
.
Sort
(
CompareCookiesForSending
(
)
)
;
}
void
CookieService
:
:
GetCookieStringInternal
(
nsIURI
*
aHostURI
nsIChannel
*
aChannel
bool
aIsForeign
bool
aIsThirdPartyTrackingResource
bool
aIsThirdPartySocialTrackingResource
bool
aFirstPartyStorageAccessGranted
uint32_t
aRejectedReason
bool
aIsSafeTopLevelNav
bool
aIsSameSiteForeign
bool
aHttpBound
const
OriginAttributes
&
aOriginAttrs
nsACString
&
aCookieString
)
{
AutoTArray
<
Cookie
*
8
>
foundCookieList
;
GetCookiesForURI
(
aHostURI
aChannel
aIsForeign
aIsThirdPartyTrackingResource
aIsThirdPartySocialTrackingResource
aFirstPartyStorageAccessGranted
aRejectedReason
aIsSafeTopLevelNav
aIsSameSiteForeign
aHttpBound
aOriginAttrs
foundCookieList
)
;
Cookie
*
cookie
;
for
(
uint32_t
i
=
0
;
i
<
foundCookieList
.
Length
(
)
;
+
+
i
)
{
cookie
=
foundCookieList
.
ElementAt
(
i
)
;
if
(
!
cookie
-
>
Name
(
)
.
IsEmpty
(
)
|
|
!
cookie
-
>
Value
(
)
.
IsEmpty
(
)
)
{
if
(
!
aCookieString
.
IsEmpty
(
)
)
{
aCookieString
.
AppendLiteral
(
"
;
"
)
;
}
if
(
!
cookie
-
>
Name
(
)
.
IsEmpty
(
)
)
{
aCookieString
+
=
cookie
-
>
Name
(
)
+
NS_LITERAL_CSTRING
(
"
=
"
)
+
cookie
-
>
Value
(
)
;
}
else
{
aCookieString
+
=
cookie
-
>
Value
(
)
;
}
}
}
if
(
!
aCookieString
.
IsEmpty
(
)
)
COOKIE_LOGSUCCESS
(
GET_COOKIE
aHostURI
aCookieString
nullptr
false
)
;
}
bool
CookieService
:
:
CanSetCookie
(
nsIURI
*
aHostURI
const
nsACString
&
aBaseDomain
CookieStruct
&
aCookieData
bool
aRequireHostMatch
CookieStatus
aStatus
nsCString
&
aCookieHeader
int64_t
aServerTime
bool
aFromHttp
nsIChannel
*
aChannel
bool
&
aSetCookie
mozIThirdPartyUtil
*
aThirdPartyUtil
)
{
NS_ASSERTION
(
aHostURI
"
null
host
!
"
)
;
aSetCookie
=
false
;
aCookieData
.
expiry
(
)
=
INT64_MAX
;
nsCString
savedCookieHeader
(
aCookieHeader
)
;
nsAutoCString
expires
;
nsAutoCString
maxage
;
bool
acceptedByParser
=
false
;
bool
newCookie
=
ParseAttributes
(
aChannel
aHostURI
aCookieHeader
aCookieData
expires
maxage
acceptedByParser
)
;
if
(
!
acceptedByParser
)
{
return
newCookie
;
}
bool
potentiallyTurstworthy
=
nsMixedContentBlocker
:
:
IsPotentiallyTrustworthyOrigin
(
aHostURI
)
;
int64_t
currentTimeInUsec
=
PR_Now
(
)
;
aCookieData
.
isSession
(
)
=
GetExpiry
(
aCookieData
expires
maxage
aServerTime
currentTimeInUsec
/
PR_USEC_PER_SEC
aFromHttp
)
;
if
(
aStatus
=
=
STATUS_ACCEPT_SESSION
)
{
aCookieData
.
isSession
(
)
=
true
;
}
if
(
(
aCookieData
.
name
(
)
.
Length
(
)
+
aCookieData
.
value
(
)
.
Length
(
)
)
>
kMaxBytesPerCookie
)
{
COOKIE_LOGFAILURE
(
SET_COOKIE
aHostURI
savedCookieHeader
"
cookie
too
big
(
>
4kb
)
"
)
;
AutoTArray
<
nsString
2
>
params
=
{
NS_ConvertUTF8toUTF16
(
aCookieData
.
name
(
)
)
}
;
nsString
size
;
size
.
AppendInt
(
kMaxBytesPerCookie
)
;
params
.
AppendElement
(
size
)
;
LogMessageToConsole
(
aChannel
aHostURI
nsIScriptError
:
:
warningFlag
CONSOLE_GENERIC_CATEGORY
NS_LITERAL_CSTRING
(
"
CookieOversize
"
)
params
)
;
return
newCookie
;
}
const
char
illegalNameCharacters
[
]
=
{
0x01
0x02
0x03
0x04
0x05
0x06
0x07
0x08
0x09
0x0A
0x0B
0x0C
0x0D
0x0E
0x0F
0x10
0x11
0x12
0x13
0x14
0x15
0x16
0x17
0x18
0x19
0x1A
0x1B
0x1C
0x1D
0x1E
0x1F
0x00
}
;
if
(
aCookieData
.
name
(
)
.
FindCharInSet
(
illegalNameCharacters
0
)
!
=
-
1
)
{
COOKIE_LOGFAILURE
(
SET_COOKIE
aHostURI
savedCookieHeader
"
invalid
name
character
"
)
;
return
newCookie
;
}
if
(
!
CheckDomain
(
aCookieData
aHostURI
aBaseDomain
aRequireHostMatch
)
)
{
COOKIE_LOGFAILURE
(
SET_COOKIE
aHostURI
savedCookieHeader
"
failed
the
domain
tests
"
)
;
return
newCookie
;
}
if
(
!
CheckPath
(
aCookieData
aChannel
aHostURI
)
)
{
COOKIE_LOGFAILURE
(
SET_COOKIE
aHostURI
savedCookieHeader
"
failed
the
path
tests
"
)
;
return
newCookie
;
}
if
(
!
CheckPrefixes
(
aCookieData
potentiallyTurstworthy
)
)
{
COOKIE_LOGFAILURE
(
SET_COOKIE
aHostURI
savedCookieHeader
"
failed
the
prefix
tests
"
)
;
return
newCookie
;
}
const
char
illegalCharacters
[
]
=
{
0x01
0x02
0x03
0x04
0x05
0x06
0x07
0x08
0x0A
0x0B
0x0C
0x0D
0x0E
0x0F
0x10
0x11
0x12
0x13
0x14
0x15
0x16
0x17
0x18
0x19
0x1A
0x1B
0x1C
0x1D
0x1E
0x1F
0x3B
0x00
}
;
if
(
aFromHttp
&
&
(
aCookieData
.
value
(
)
.
FindCharInSet
(
illegalCharacters
0
)
!
=
-
1
)
)
{
COOKIE_LOGFAILURE
(
SET_COOKIE
aHostURI
savedCookieHeader
"
invalid
value
character
"
)
;
return
newCookie
;
}
if
(
!
aFromHttp
&
&
aCookieData
.
isHttpOnly
(
)
)
{
COOKIE_LOGFAILURE
(
SET_COOKIE
aHostURI
savedCookieHeader
"
cookie
is
httponly
;
coming
from
script
"
)
;
return
newCookie
;
}
if
(
aCookieData
.
isSecure
(
)
&
&
!
potentiallyTurstworthy
)
{
COOKIE_LOGFAILURE
(
SET_COOKIE
aHostURI
aCookieHeader
"
non
-
https
cookie
can
'
t
set
secure
flag
"
)
;
return
newCookie
;
}
if
(
(
aCookieData
.
sameSite
(
)
!
=
nsICookie
:
:
SAMESITE_NONE
)
&
&
aThirdPartyUtil
)
{
bool
addonAllowsLoad
=
false
;
if
(
aChannel
)
{
nsCOMPtr
<
nsIURI
>
channelURI
;
NS_GetFinalChannelURI
(
aChannel
getter_AddRefs
(
channelURI
)
)
;
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
aChannel
-
>
LoadInfo
(
)
;
addonAllowsLoad
=
BasePrincipal
:
:
Cast
(
loadInfo
-
>
TriggeringPrincipal
(
)
)
-
>
AddonAllowsLoad
(
channelURI
)
;
}
if
(
!
addonAllowsLoad
)
{
bool
isThirdParty
=
false
;
nsresult
rv
=
aThirdPartyUtil
-
>
IsThirdPartyChannel
(
aChannel
aHostURI
&
isThirdParty
)
;
if
(
NS_FAILED
(
rv
)
|
|
isThirdParty
)
{
COOKIE_LOGFAILURE
(
SET_COOKIE
aHostURI
savedCookieHeader
"
failed
the
samesite
tests
"
)
;
return
newCookie
;
}
}
}
aSetCookie
=
true
;
return
newCookie
;
}
bool
CookieService
:
:
SetCookieInternal
(
CookieStorage
*
aStorage
nsIURI
*
aHostURI
const
nsACString
&
aBaseDomain
const
OriginAttributes
&
aOriginAttributes
bool
aRequireHostMatch
CookieStatus
aStatus
nsCString
&
aCookieHeader
int64_t
aServerTime
bool
aFromHttp
nsIChannel
*
aChannel
)
{
NS_ASSERTION
(
aHostURI
"
null
host
!
"
)
;
bool
canSetCookie
=
false
;
nsCString
savedCookieHeader
(
aCookieHeader
)
;
CookieStruct
cookieData
;
bool
newCookie
=
CanSetCookie
(
aHostURI
aBaseDomain
cookieData
aRequireHostMatch
aStatus
aCookieHeader
aServerTime
aFromHttp
aChannel
canSetCookie
mThirdPartyUtil
)
;
if
(
!
canSetCookie
)
{
return
newCookie
;
}
int64_t
currentTimeInUsec
=
PR_Now
(
)
;
RefPtr
<
Cookie
>
cookie
=
Cookie
:
:
Create
(
cookieData
.
name
(
)
cookieData
.
value
(
)
cookieData
.
host
(
)
cookieData
.
path
(
)
cookieData
.
expiry
(
)
currentTimeInUsec
Cookie
:
:
GenerateUniqueCreationTime
(
currentTimeInUsec
)
cookieData
.
isSession
(
)
cookieData
.
isSecure
(
)
cookieData
.
isHttpOnly
(
)
aOriginAttributes
cookieData
.
sameSite
(
)
cookieData
.
rawSameSite
(
)
)
;
if
(
!
cookie
)
return
newCookie
;
if
(
mPermissionService
)
{
bool
permission
;
mPermissionService
-
>
CanSetCookie
(
aHostURI
aChannel
static_cast
<
nsICookie
*
>
(
static_cast
<
Cookie
*
>
(
cookie
)
)
&
cookieData
.
isSession
(
)
&
cookieData
.
expiry
(
)
&
permission
)
;
if
(
!
permission
)
{
COOKIE_LOGFAILURE
(
SET_COOKIE
aHostURI
savedCookieHeader
"
cookie
rejected
by
permission
manager
"
)
;
NotifyRejected
(
aHostURI
aChannel
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_BY_PERMISSION
OPERATION_WRITE
)
;
return
newCookie
;
}
cookie
-
>
SetIsSession
(
cookieData
.
isSession
(
)
)
;
cookie
-
>
SetExpiry
(
cookieData
.
expiry
(
)
)
;
}
aStorage
-
>
AddCookie
(
aBaseDomain
aOriginAttributes
cookie
PR_Now
(
)
aHostURI
savedCookieHeader
aFromHttp
)
;
return
newCookie
;
}
static
inline
bool
isnull
(
char
c
)
{
return
c
=
=
0
;
}
static
inline
bool
iswhitespace
(
char
c
)
{
return
c
=
=
'
'
|
|
c
=
=
'
\
t
'
;
}
static
inline
bool
isterminator
(
char
c
)
{
return
c
=
=
'
\
n
'
|
|
c
=
=
'
\
r
'
;
}
static
inline
bool
isvalueseparator
(
char
c
)
{
return
isterminator
(
c
)
|
|
c
=
=
'
;
'
;
}
static
inline
bool
istokenseparator
(
char
c
)
{
return
isvalueseparator
(
c
)
|
|
c
=
=
'
=
'
;
}
bool
CookieService
:
:
GetTokenValue
(
nsACString
:
:
const_char_iterator
&
aIter
nsACString
:
:
const_char_iterator
&
aEndIter
nsDependentCSubstring
&
aTokenString
nsDependentCSubstring
&
aTokenValue
bool
&
aEqualsFound
)
{
nsACString
:
:
const_char_iterator
start
lastSpace
;
aTokenValue
.
Rebind
(
aIter
aIter
)
;
while
(
aIter
!
=
aEndIter
&
&
iswhitespace
(
*
aIter
)
)
+
+
aIter
;
start
=
aIter
;
while
(
aIter
!
=
aEndIter
&
&
!
isnull
(
*
aIter
)
&
&
!
istokenseparator
(
*
aIter
)
)
+
+
aIter
;
lastSpace
=
aIter
;
if
(
lastSpace
!
=
start
)
{
while
(
-
-
lastSpace
!
=
start
&
&
iswhitespace
(
*
lastSpace
)
)
continue
;
+
+
lastSpace
;
}
aTokenString
.
Rebind
(
start
lastSpace
)
;
aEqualsFound
=
(
*
aIter
=
=
'
=
'
)
;
if
(
aEqualsFound
)
{
while
(
+
+
aIter
!
=
aEndIter
&
&
iswhitespace
(
*
aIter
)
)
continue
;
start
=
aIter
;
while
(
aIter
!
=
aEndIter
&
&
!
isnull
(
*
aIter
)
&
&
!
isvalueseparator
(
*
aIter
)
)
+
+
aIter
;
if
(
aIter
!
=
start
)
{
lastSpace
=
aIter
;
while
(
-
-
lastSpace
!
=
start
&
&
iswhitespace
(
*
lastSpace
)
)
continue
;
aTokenValue
.
Rebind
(
start
+
+
lastSpace
)
;
}
}
if
(
aIter
!
=
aEndIter
)
{
if
(
isterminator
(
*
aIter
)
)
{
+
+
aIter
;
return
true
;
}
+
+
aIter
;
}
return
false
;
}
bool
CookieService
:
:
ParseAttributes
(
nsIChannel
*
aChannel
nsIURI
*
aHostURI
nsCString
&
aCookieHeader
CookieStruct
&
aCookieData
nsACString
&
aExpires
nsACString
&
aMaxage
bool
&
aAcceptedByParser
)
{
aAcceptedByParser
=
false
;
static
const
char
kPath
[
]
=
"
path
"
;
static
const
char
kDomain
[
]
=
"
domain
"
;
static
const
char
kExpires
[
]
=
"
expires
"
;
static
const
char
kMaxage
[
]
=
"
max
-
age
"
;
static
const
char
kSecure
[
]
=
"
secure
"
;
static
const
char
kHttpOnly
[
]
=
"
httponly
"
;
static
const
char
kSameSite
[
]
=
"
samesite
"
;
static
const
char
kSameSiteLax
[
]
=
"
lax
"
;
static
const
char
kSameSiteNone
[
]
=
"
none
"
;
static
const
char
kSameSiteStrict
[
]
=
"
strict
"
;
nsACString
:
:
const_char_iterator
tempBegin
tempEnd
;
nsACString
:
:
const_char_iterator
cookieStart
cookieEnd
;
aCookieHeader
.
BeginReading
(
cookieStart
)
;
aCookieHeader
.
EndReading
(
cookieEnd
)
;
aCookieData
.
isSecure
(
)
=
false
;
aCookieData
.
isHttpOnly
(
)
=
false
;
aCookieData
.
sameSite
(
)
=
nsICookie
:
:
SAMESITE_NONE
;
aCookieData
.
rawSameSite
(
)
=
nsICookie
:
:
SAMESITE_NONE
;
bool
laxByDefault
=
StaticPrefs
:
:
network_cookie_sameSite_laxByDefault
(
)
&
&
!
nsContentUtils
:
:
IsURIInPrefList
(
aHostURI
"
network
.
cookie
.
sameSite
.
laxByDefault
.
disabledHosts
"
)
;
if
(
laxByDefault
)
{
aCookieData
.
sameSite
(
)
=
nsICookie
:
:
SAMESITE_LAX
;
}
nsDependentCSubstring
tokenString
(
cookieStart
cookieStart
)
;
nsDependentCSubstring
tokenValue
(
cookieStart
cookieStart
)
;
bool
newCookie
equalsFound
;
newCookie
=
GetTokenValue
(
cookieStart
cookieEnd
tokenString
tokenValue
equalsFound
)
;
if
(
equalsFound
)
{
aCookieData
.
name
(
)
=
tokenString
;
aCookieData
.
value
(
)
=
tokenValue
;
}
else
{
aCookieData
.
value
(
)
=
tokenString
;
}
bool
sameSiteSet
=
false
;
while
(
cookieStart
!
=
cookieEnd
&
&
!
newCookie
)
{
newCookie
=
GetTokenValue
(
cookieStart
cookieEnd
tokenString
tokenValue
equalsFound
)
;
if
(
!
tokenValue
.
IsEmpty
(
)
)
{
tokenValue
.
BeginReading
(
tempBegin
)
;
tokenValue
.
EndReading
(
tempEnd
)
;
}
if
(
tokenString
.
LowerCaseEqualsLiteral
(
kPath
)
)
aCookieData
.
path
(
)
=
tokenValue
;
else
if
(
tokenString
.
LowerCaseEqualsLiteral
(
kDomain
)
)
aCookieData
.
host
(
)
=
tokenValue
;
else
if
(
tokenString
.
LowerCaseEqualsLiteral
(
kExpires
)
)
aExpires
=
tokenValue
;
else
if
(
tokenString
.
LowerCaseEqualsLiteral
(
kMaxage
)
)
aMaxage
=
tokenValue
;
else
if
(
tokenString
.
LowerCaseEqualsLiteral
(
kSecure
)
)
aCookieData
.
isSecure
(
)
=
true
;
else
if
(
tokenString
.
LowerCaseEqualsLiteral
(
kHttpOnly
)
)
aCookieData
.
isHttpOnly
(
)
=
true
;
else
if
(
tokenString
.
LowerCaseEqualsLiteral
(
kSameSite
)
)
{
if
(
tokenValue
.
LowerCaseEqualsLiteral
(
kSameSiteLax
)
)
{
aCookieData
.
sameSite
(
)
=
nsICookie
:
:
SAMESITE_LAX
;
aCookieData
.
rawSameSite
(
)
=
nsICookie
:
:
SAMESITE_LAX
;
sameSiteSet
=
true
;
}
else
if
(
tokenValue
.
LowerCaseEqualsLiteral
(
kSameSiteStrict
)
)
{
aCookieData
.
sameSite
(
)
=
nsICookie
:
:
SAMESITE_STRICT
;
aCookieData
.
rawSameSite
(
)
=
nsICookie
:
:
SAMESITE_STRICT
;
sameSiteSet
=
true
;
}
else
if
(
tokenValue
.
LowerCaseEqualsLiteral
(
kSameSiteNone
)
)
{
aCookieData
.
sameSite
(
)
=
nsICookie
:
:
SAMESITE_NONE
;
aCookieData
.
rawSameSite
(
)
=
nsICookie
:
:
SAMESITE_NONE
;
sameSiteSet
=
true
;
}
else
{
LogMessageToConsole
(
aChannel
aHostURI
nsIScriptError
:
:
infoFlag
CONSOLE_GENERIC_CATEGORY
NS_LITERAL_CSTRING
(
"
CookieSameSiteValueInvalid
"
)
AutoTArray
<
nsString
1
>
{
NS_ConvertUTF8toUTF16
(
aCookieData
.
name
(
)
)
}
)
;
}
}
}
Telemetry
:
:
Accumulate
(
Telemetry
:
:
COOKIE_SAMESITE_SET_VS_UNSET
sameSiteSet
?
1
:
0
)
;
aCookieHeader
.
Assign
(
Substring
(
cookieStart
cookieEnd
)
)
;
if
(
!
aCookieData
.
isSecure
(
)
&
&
aCookieData
.
sameSite
(
)
=
=
nsICookie
:
:
SAMESITE_NONE
)
{
if
(
laxByDefault
&
&
StaticPrefs
:
:
network_cookie_sameSite_noneRequiresSecure
(
)
)
{
LogMessageToConsole
(
aChannel
aHostURI
nsIScriptError
:
:
infoFlag
CONSOLE_SAMESITE_CATEGORY
NS_LITERAL_CSTRING
(
"
CookieRejectedNonRequiresSecure
"
)
AutoTArray
<
nsString
1
>
{
NS_ConvertUTF8toUTF16
(
aCookieData
.
name
(
)
)
}
)
;
return
newCookie
;
}
LogMessageToConsole
(
aChannel
aHostURI
nsIScriptError
:
:
warningFlag
CONSOLE_SAMESITE_CATEGORY
NS_LITERAL_CSTRING
(
"
CookieRejectedNonRequiresSecureForBeta
"
)
AutoTArray
<
nsString
2
>
{
NS_ConvertUTF8toUTF16
(
aCookieData
.
name
(
)
)
SAMESITE_MDN_URL
}
)
;
}
if
(
aCookieData
.
rawSameSite
(
)
=
=
nsICookie
:
:
SAMESITE_NONE
&
&
aCookieData
.
sameSite
(
)
=
=
nsICookie
:
:
SAMESITE_LAX
)
{
if
(
laxByDefault
)
{
LogMessageToConsole
(
aChannel
aHostURI
nsIScriptError
:
:
infoFlag
CONSOLE_SAMESITE_CATEGORY
NS_LITERAL_CSTRING
(
"
CookieLaxForced
"
)
AutoTArray
<
nsString
1
>
{
NS_ConvertUTF8toUTF16
(
aCookieData
.
name
(
)
)
}
)
;
}
else
{
LogMessageToConsole
(
aChannel
aHostURI
nsIScriptError
:
:
warningFlag
CONSOLE_SAMESITE_CATEGORY
NS_LITERAL_CSTRING
(
"
CookieLaxForcedForBeta
"
)
AutoTArray
<
nsString
2
>
{
NS_ConvertUTF8toUTF16
(
aCookieData
.
name
(
)
)
SAMESITE_MDN_URL
}
)
;
}
}
aAcceptedByParser
=
true
;
MOZ_ASSERT
(
Cookie
:
:
ValidateRawSame
(
aCookieData
)
)
;
return
newCookie
;
}
void
CookieService
:
:
LogMessageToConsole
(
nsIChannel
*
aChannel
nsIURI
*
aURI
uint32_t
aErrorFlags
const
nsACString
&
aCategory
const
nsACString
&
aMsg
const
nsTArray
<
nsString
>
&
aParams
)
{
MOZ_ASSERT
(
aURI
)
;
nsCOMPtr
<
HttpBaseChannel
>
httpChannel
=
do_QueryInterface
(
aChannel
)
;
if
(
!
httpChannel
)
{
return
;
}
nsAutoCString
uri
;
nsresult
rv
=
aURI
-
>
GetSpec
(
uri
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
httpChannel
-
>
AddConsoleReport
(
aErrorFlags
aCategory
nsContentUtils
:
:
eNECKO_PROPERTIES
uri
0
0
aMsg
aParams
)
;
}
nsresult
CookieService
:
:
NormalizeHost
(
nsCString
&
aHost
)
{
if
(
!
IsAscii
(
aHost
)
)
{
nsAutoCString
host
;
nsresult
rv
=
mIDNService
-
>
ConvertUTF8toACE
(
aHost
host
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
aHost
=
host
;
}
ToLowerCase
(
aHost
)
;
return
NS_OK
;
}
static
inline
bool
IsSubdomainOf
(
const
nsACString
&
a
const
nsACString
&
b
)
{
if
(
a
=
=
b
)
return
true
;
if
(
a
.
Length
(
)
>
b
.
Length
(
)
)
return
a
[
a
.
Length
(
)
-
b
.
Length
(
)
-
1
]
=
=
'
.
'
&
&
StringEndsWith
(
a
b
)
;
return
false
;
}
CookieStatus
CookieService
:
:
CheckPrefs
(
nsICookieJarSettings
*
aCookieJarSettings
nsIURI
*
aHostURI
bool
aIsForeign
bool
aIsThirdPartyTrackingResource
bool
aIsThirdPartySocialTrackingResource
bool
aFirstPartyStorageAccessGranted
const
nsACString
&
aCookieHeader
const
int
aNumOfCookies
const
OriginAttributes
&
aOriginAttrs
uint32_t
*
aRejectedReason
)
{
nsresult
rv
;
MOZ_ASSERT
(
aRejectedReason
)
;
*
aRejectedReason
=
0
;
if
(
aHostURI
-
>
SchemeIs
(
"
ftp
"
)
)
{
COOKIE_LOGFAILURE
(
aCookieHeader
.
IsVoid
(
)
?
GET_COOKIE
:
SET_COOKIE
aHostURI
aCookieHeader
"
ftp
sites
cannot
read
cookies
"
)
;
return
STATUS_REJECTED_WITH_ERROR
;
}
nsCOMPtr
<
nsIPrincipal
>
principal
=
BasePrincipal
:
:
CreateContentPrincipal
(
aHostURI
aOriginAttrs
)
;
if
(
!
principal
)
{
COOKIE_LOGFAILURE
(
aCookieHeader
.
IsVoid
(
)
?
GET_COOKIE
:
SET_COOKIE
aHostURI
aCookieHeader
"
non
-
content
principals
cannot
get
/
set
cookies
"
)
;
return
STATUS_REJECTED_WITH_ERROR
;
}
uint32_t
cookiePermission
=
nsICookiePermission
:
:
ACCESS_DEFAULT
;
rv
=
aCookieJarSettings
-
>
CookiePermission
(
principal
&
cookiePermission
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
switch
(
cookiePermission
)
{
case
nsICookiePermission
:
:
ACCESS_DENY
:
COOKIE_LOGFAILURE
(
aCookieHeader
.
IsVoid
(
)
?
GET_COOKIE
:
SET_COOKIE
aHostURI
aCookieHeader
"
cookies
are
blocked
for
this
site
"
)
;
*
aRejectedReason
=
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_BY_PERMISSION
;
return
STATUS_REJECTED
;
case
nsICookiePermission
:
:
ACCESS_ALLOW
:
return
STATUS_ACCEPTED
;
}
}
if
(
aIsForeign
&
&
aIsThirdPartyTrackingResource
&
&
!
aFirstPartyStorageAccessGranted
&
&
aCookieJarSettings
-
>
GetRejectThirdPartyContexts
(
)
)
{
bool
rejectThirdPartyWithExceptions
=
CookieJarSettings
:
:
IsRejectThirdPartyWithExceptions
(
aCookieJarSettings
-
>
GetCookieBehavior
(
)
)
;
uint32_t
rejectReason
=
rejectThirdPartyWithExceptions
?
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_FOREIGN
:
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_TRACKER
;
if
(
StoragePartitioningEnabled
(
rejectReason
aCookieJarSettings
)
)
{
MOZ_ASSERT
(
!
aOriginAttrs
.
mFirstPartyDomain
.
IsEmpty
(
)
"
We
must
have
a
StoragePrincipal
here
!
"
)
;
return
STATUS_ACCEPTED
;
}
COOKIE_LOGFAILURE
(
aCookieHeader
.
IsVoid
(
)
?
GET_COOKIE
:
SET_COOKIE
aHostURI
aCookieHeader
"
cookies
are
disabled
in
trackers
"
)
;
if
(
aIsThirdPartySocialTrackingResource
)
{
*
aRejectedReason
=
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_SOCIALTRACKER
;
}
else
if
(
rejectThirdPartyWithExceptions
)
{
*
aRejectedReason
=
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_FOREIGN
;
}
else
{
*
aRejectedReason
=
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_TRACKER
;
}
return
STATUS_REJECTED
;
}
if
(
aCookieJarSettings
-
>
GetCookieBehavior
(
)
=
=
nsICookieService
:
:
BEHAVIOR_REJECT
&
&
!
aFirstPartyStorageAccessGranted
)
{
COOKIE_LOGFAILURE
(
aCookieHeader
.
IsVoid
(
)
?
GET_COOKIE
:
SET_COOKIE
aHostURI
aCookieHeader
"
cookies
are
disabled
"
)
;
*
aRejectedReason
=
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_ALL
;
return
STATUS_REJECTED
;
}
if
(
aIsForeign
)
{
if
(
aCookieJarSettings
-
>
GetCookieBehavior
(
)
=
=
nsICookieService
:
:
BEHAVIOR_REJECT_FOREIGN
&
&
!
aFirstPartyStorageAccessGranted
)
{
COOKIE_LOGFAILURE
(
aCookieHeader
.
IsVoid
(
)
?
GET_COOKIE
:
SET_COOKIE
aHostURI
aCookieHeader
"
context
is
third
party
"
)
;
*
aRejectedReason
=
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_FOREIGN
;
return
STATUS_REJECTED
;
}
if
(
aCookieJarSettings
-
>
GetLimitForeignContexts
(
)
&
&
!
aFirstPartyStorageAccessGranted
&
&
aNumOfCookies
=
=
0
)
{
COOKIE_LOGFAILURE
(
aCookieHeader
.
IsVoid
(
)
?
GET_COOKIE
:
SET_COOKIE
aHostURI
aCookieHeader
"
context
is
third
party
"
)
;
*
aRejectedReason
=
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_FOREIGN
;
return
STATUS_REJECTED
;
}
if
(
StaticPrefs
:
:
network_cookie_thirdparty_sessionOnly
(
)
)
{
return
STATUS_ACCEPT_SESSION
;
}
if
(
StaticPrefs
:
:
network_cookie_thirdparty_nonsecureSessionOnly
(
)
)
{
if
(
!
aHostURI
-
>
SchemeIs
(
"
https
"
)
)
{
return
STATUS_ACCEPT_SESSION
;
}
}
}
return
STATUS_ACCEPTED
;
}
bool
CookieService
:
:
CheckDomain
(
CookieStruct
&
aCookieData
nsIURI
*
aHostURI
const
nsACString
&
aBaseDomain
bool
aRequireHostMatch
)
{
nsAutoCString
hostFromURI
;
aHostURI
-
>
GetAsciiHost
(
hostFromURI
)
;
if
(
!
aCookieData
.
host
(
)
.
IsEmpty
(
)
)
{
if
(
aCookieData
.
host
(
)
.
Length
(
)
>
1
&
&
aCookieData
.
host
(
)
.
First
(
)
=
=
'
.
'
)
{
aCookieData
.
host
(
)
.
Cut
(
0
1
)
;
}
ToLowerCase
(
aCookieData
.
host
(
)
)
;
if
(
aRequireHostMatch
)
return
hostFromURI
.
Equals
(
aCookieData
.
host
(
)
)
;
if
(
IsSubdomainOf
(
aCookieData
.
host
(
)
aBaseDomain
)
&
&
IsSubdomainOf
(
hostFromURI
aCookieData
.
host
(
)
)
)
{
aCookieData
.
host
(
)
.
InsertLiteral
(
"
.
"
0
)
;
return
true
;
}
return
false
;
}
aCookieData
.
host
(
)
=
hostFromURI
;
return
true
;
}
nsAutoCString
CookieService
:
:
GetPathFromURI
(
nsIURI
*
aHostURI
)
{
nsAutoCString
path
;
nsCOMPtr
<
nsIURL
>
hostURL
=
do_QueryInterface
(
aHostURI
)
;
if
(
hostURL
)
{
hostURL
-
>
GetDirectory
(
path
)
;
}
else
{
aHostURI
-
>
GetPathQueryRef
(
path
)
;
int32_t
slash
=
path
.
RFindChar
(
'
/
'
)
;
if
(
slash
!
=
kNotFound
)
{
path
.
Truncate
(
slash
+
1
)
;
}
}
int32_t
lastSlash
=
path
.
RFindChar
(
'
/
'
)
;
int32_t
firstSlash
=
path
.
FindChar
(
'
/
'
)
;
if
(
lastSlash
!
=
firstSlash
&
&
lastSlash
!
=
kNotFound
&
&
lastSlash
=
=
(
int32_t
)
(
path
.
Length
(
)
-
1
)
)
{
path
.
Truncate
(
lastSlash
)
;
}
return
path
;
}
bool
CookieService
:
:
CheckPath
(
CookieStruct
&
aCookieData
nsIChannel
*
aChannel
nsIURI
*
aHostURI
)
{
if
(
aCookieData
.
path
(
)
.
IsEmpty
(
)
|
|
aCookieData
.
path
(
)
.
First
(
)
!
=
'
/
'
)
{
aCookieData
.
path
(
)
=
GetPathFromURI
(
aHostURI
)
;
#
if
0
}
else
{
nsAutoCString
pathFromURI
;
if
(
NS_FAILED
(
aHostURI
-
>
GetPathQueryRef
(
pathFromURI
)
)
|
|
!
StringBeginsWith
(
pathFromURI
aCookieData
.
path
(
)
)
)
{
return
false
;
}
#
endif
}
if
(
aCookieData
.
path
(
)
.
Length
(
)
>
kMaxBytesPerPath
)
{
AutoTArray
<
nsString
2
>
params
=
{
NS_ConvertUTF8toUTF16
(
aCookieData
.
name
(
)
)
}
;
nsString
size
;
size
.
AppendInt
(
kMaxBytesPerPath
)
;
params
.
AppendElement
(
size
)
;
LogMessageToConsole
(
aChannel
aHostURI
nsIScriptError
:
:
warningFlag
CONSOLE_GENERIC_CATEGORY
NS_LITERAL_CSTRING
(
"
CookiePathOversize
"
)
params
)
;
return
false
;
}
if
(
aCookieData
.
path
(
)
.
Contains
(
'
\
t
'
)
)
{
return
false
;
}
return
true
;
}
bool
CookieService
:
:
CheckPrefixes
(
CookieStruct
&
aCookieData
bool
aSecureRequest
)
{
static
const
char
kSecure
[
]
=
"
__Secure
-
"
;
static
const
char
kHost
[
]
=
"
__Host
-
"
;
static
const
int
kSecureLen
=
sizeof
(
kSecure
)
-
1
;
static
const
int
kHostLen
=
sizeof
(
kHost
)
-
1
;
bool
isSecure
=
strncmp
(
aCookieData
.
name
(
)
.
get
(
)
kSecure
kSecureLen
)
=
=
0
;
bool
isHost
=
strncmp
(
aCookieData
.
name
(
)
.
get
(
)
kHost
kHostLen
)
=
=
0
;
if
(
!
isSecure
&
&
!
isHost
)
{
return
true
;
}
if
(
!
aSecureRequest
|
|
!
aCookieData
.
isSecure
(
)
)
{
return
false
;
}
if
(
isHost
)
{
if
(
aCookieData
.
host
(
)
[
0
]
=
=
'
.
'
|
|
!
aCookieData
.
path
(
)
.
EqualsLiteral
(
"
/
"
)
)
{
return
false
;
}
}
return
true
;
}
bool
CookieService
:
:
GetExpiry
(
CookieStruct
&
aCookieData
const
nsACString
&
aExpires
const
nsACString
&
aMaxage
int64_t
aServerTime
int64_t
aCurrentTime
bool
aFromHttp
)
{
int64_t
maxageCap
=
aFromHttp
?
0
:
StaticPrefs
:
:
privacy_documentCookies_maxage
(
)
;
if
(
!
aMaxage
.
IsEmpty
(
)
)
{
int64_t
maxage
;
int32_t
numInts
=
PR_sscanf
(
aMaxage
.
BeginReading
(
)
"
%
lld
"
&
maxage
)
;
if
(
numInts
!
=
1
)
{
return
true
;
}
if
(
maxageCap
)
{
aCookieData
.
expiry
(
)
=
aCurrentTime
+
std
:
:
min
(
maxage
maxageCap
)
;
}
else
{
aCookieData
.
expiry
(
)
=
aCurrentTime
+
maxage
;
}
}
else
if
(
!
aExpires
.
IsEmpty
(
)
)
{
PRTime
expires
;
if
(
PR_ParseTimeString
(
aExpires
.
BeginReading
(
)
true
&
expires
)
!
=
PR_SUCCESS
)
{
return
true
;
}
if
(
maxageCap
)
{
aCookieData
.
expiry
(
)
=
std
:
:
min
(
expires
/
int64_t
(
PR_USEC_PER_SEC
)
aCurrentTime
+
maxageCap
)
;
}
else
{
aCookieData
.
expiry
(
)
=
expires
/
int64_t
(
PR_USEC_PER_SEC
)
;
}
}
else
{
return
true
;
}
return
false
;
}
NS_IMETHODIMP
CookieService
:
:
CookieExists
(
const
nsACString
&
aHost
const
nsACString
&
aPath
const
nsACString
&
aName
JS
:
:
HandleValue
aOriginAttributes
JSContext
*
aCx
bool
*
aFoundCookie
)
{
NS_ENSURE_ARG_POINTER
(
aCx
)
;
NS_ENSURE_ARG_POINTER
(
aFoundCookie
)
;
OriginAttributes
attrs
;
if
(
!
aOriginAttributes
.
isObject
(
)
|
|
!
attrs
.
Init
(
aCx
aOriginAttributes
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
return
CookieExistsNative
(
aHost
aPath
aName
&
attrs
aFoundCookie
)
;
}
NS_IMETHODIMP_
(
nsresult
)
CookieService
:
:
CookieExistsNative
(
const
nsACString
&
aHost
const
nsACString
&
aPath
const
nsACString
&
aName
OriginAttributes
*
aOriginAttributes
bool
*
aFoundCookie
)
{
NS_ENSURE_ARG_POINTER
(
aOriginAttributes
)
;
NS_ENSURE_ARG_POINTER
(
aFoundCookie
)
;
if
(
!
IsInitialized
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsAutoCString
baseDomain
;
nsresult
rv
=
CookieCommons
:
:
GetBaseDomainFromHost
(
mTLDService
aHost
baseDomain
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
CookieListIter
iter
;
CookieStorage
*
storage
=
PickStorage
(
*
aOriginAttributes
)
;
*
aFoundCookie
=
storage
-
>
FindCookie
(
baseDomain
*
aOriginAttributes
aHost
aName
aPath
iter
)
;
return
NS_OK
;
}
NS_IMETHODIMP
CookieService
:
:
CountCookiesFromHost
(
const
nsACString
&
aHost
uint32_t
*
aCountFromHost
)
{
nsAutoCString
host
(
aHost
)
;
nsresult
rv
=
NormalizeHost
(
host
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
baseDomain
;
rv
=
CookieCommons
:
:
GetBaseDomainFromHost
(
mTLDService
host
baseDomain
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
IsInitialized
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
mPersistentStorage
-
>
EnsureReadComplete
(
)
;
*
aCountFromHost
=
mPersistentStorage
-
>
CountCookiesFromHost
(
baseDomain
0
)
;
return
NS_OK
;
}
NS_IMETHODIMP
CookieService
:
:
GetCookiesFromHost
(
const
nsACString
&
aHost
JS
:
:
HandleValue
aOriginAttributes
JSContext
*
aCx
nsTArray
<
RefPtr
<
nsICookie
>
>
&
aResult
)
{
nsAutoCString
host
(
aHost
)
;
nsresult
rv
=
NormalizeHost
(
host
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
baseDomain
;
rv
=
CookieCommons
:
:
GetBaseDomainFromHost
(
mTLDService
host
baseDomain
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
OriginAttributes
attrs
;
if
(
!
aOriginAttributes
.
isObject
(
)
|
|
!
attrs
.
Init
(
aCx
aOriginAttributes
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
!
IsInitialized
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
CookieStorage
*
storage
=
PickStorage
(
attrs
)
;
const
nsTArray
<
RefPtr
<
Cookie
>
>
*
cookies
=
storage
-
>
GetCookiesFromHost
(
baseDomain
attrs
)
;
if
(
cookies
)
{
aResult
.
SetCapacity
(
cookies
-
>
Length
(
)
)
;
for
(
Cookie
*
cookie
:
*
cookies
)
{
aResult
.
AppendElement
(
cookie
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
CookieService
:
:
GetCookiesWithOriginAttributes
(
const
nsAString
&
aPattern
const
nsACString
&
aHost
nsTArray
<
RefPtr
<
nsICookie
>
>
&
aResult
)
{
OriginAttributesPattern
pattern
;
if
(
!
pattern
.
Init
(
aPattern
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsAutoCString
host
(
aHost
)
;
nsresult
rv
=
NormalizeHost
(
host
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
baseDomain
;
rv
=
CookieCommons
:
:
GetBaseDomainFromHost
(
mTLDService
host
baseDomain
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
GetCookiesWithOriginAttributes
(
pattern
baseDomain
aResult
)
;
}
nsresult
CookieService
:
:
GetCookiesWithOriginAttributes
(
const
OriginAttributesPattern
&
aPattern
const
nsCString
&
aBaseDomain
nsTArray
<
RefPtr
<
nsICookie
>
>
&
aResult
)
{
CookieStorage
*
storage
=
PickStorage
(
aPattern
)
;
storage
-
>
GetCookiesWithOriginAttributes
(
aPattern
aBaseDomain
aResult
)
;
return
NS_OK
;
}
NS_IMETHODIMP
CookieService
:
:
RemoveCookiesWithOriginAttributes
(
const
nsAString
&
aPattern
const
nsACString
&
aHost
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
OriginAttributesPattern
pattern
;
if
(
!
pattern
.
Init
(
aPattern
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsAutoCString
host
(
aHost
)
;
nsresult
rv
=
NormalizeHost
(
host
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
baseDomain
;
rv
=
CookieCommons
:
:
GetBaseDomainFromHost
(
mTLDService
host
baseDomain
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
RemoveCookiesWithOriginAttributes
(
pattern
baseDomain
)
;
}
nsresult
CookieService
:
:
RemoveCookiesWithOriginAttributes
(
const
OriginAttributesPattern
&
aPattern
const
nsCString
&
aBaseDomain
)
{
if
(
!
IsInitialized
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
CookieStorage
*
storage
=
PickStorage
(
aPattern
)
;
storage
-
>
RemoveCookiesWithOriginAttributes
(
aPattern
aBaseDomain
)
;
return
NS_OK
;
}
NS_IMETHODIMP
CookieService
:
:
RemoveCookiesFromExactHost
(
const
nsACString
&
aHost
const
nsAString
&
aPattern
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
OriginAttributesPattern
pattern
;
if
(
!
pattern
.
Init
(
aPattern
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
return
RemoveCookiesFromExactHost
(
aHost
pattern
)
;
}
nsresult
CookieService
:
:
RemoveCookiesFromExactHost
(
const
nsACString
&
aHost
const
OriginAttributesPattern
&
aPattern
)
{
nsAutoCString
host
(
aHost
)
;
nsresult
rv
=
NormalizeHost
(
host
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
baseDomain
;
rv
=
CookieCommons
:
:
GetBaseDomainFromHost
(
mTLDService
host
baseDomain
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
IsInitialized
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
CookieStorage
*
storage
=
PickStorage
(
aPattern
)
;
storage
-
>
RemoveCookiesFromExactHost
(
aHost
baseDomain
aPattern
)
;
return
NS_OK
;
}
namespace
{
class
RemoveAllSinceRunnable
:
public
Runnable
{
public
:
typedef
nsTArray
<
RefPtr
<
nsICookie
>
>
CookieArray
;
RemoveAllSinceRunnable
(
Promise
*
aPromise
CookieService
*
aSelf
CookieArray
&
&
aCookieArray
int64_t
aSinceWhen
)
:
Runnable
(
"
RemoveAllSinceRunnable
"
)
mPromise
(
aPromise
)
mSelf
(
aSelf
)
mList
(
std
:
:
move
(
aCookieArray
)
)
mIndex
(
0
)
mSinceWhen
(
aSinceWhen
)
{
}
NS_IMETHODIMP
Run
(
)
{
RemoveSome
(
)
;
if
(
mIndex
<
mList
.
Length
(
)
)
{
return
NS_DispatchToCurrentThread
(
this
)
;
}
else
{
mPromise
-
>
MaybeResolveWithUndefined
(
)
;
}
return
NS_OK
;
}
private
:
void
RemoveSome
(
)
{
for
(
CookieArray
:
:
size_type
iter
=
0
;
iter
<
kYieldPeriod
&
&
mIndex
<
mList
.
Length
(
)
;
+
+
mIndex
+
+
iter
)
{
Cookie
*
cookie
=
static_cast
<
Cookie
*
>
(
mList
[
mIndex
]
.
get
(
)
)
;
if
(
cookie
-
>
CreationTime
(
)
>
mSinceWhen
&
&
NS_FAILED
(
mSelf
-
>
Remove
(
cookie
-
>
Host
(
)
cookie
-
>
OriginAttributesRef
(
)
cookie
-
>
Name
(
)
cookie
-
>
Path
(
)
)
)
)
{
continue
;
}
}
}
private
:
RefPtr
<
Promise
>
mPromise
;
RefPtr
<
CookieService
>
mSelf
;
CookieArray
mList
;
CookieArray
:
:
size_type
mIndex
;
int64_t
mSinceWhen
;
static
const
CookieArray
:
:
size_type
kYieldPeriod
=
10
;
}
;
}
NS_IMETHODIMP
CookieService
:
:
RemoveAllSince
(
int64_t
aSinceWhen
JSContext
*
aCx
Promise
*
*
aRetVal
)
{
nsIGlobalObject
*
globalObject
=
xpc
:
:
CurrentNativeGlobal
(
aCx
)
;
if
(
NS_WARN_IF
(
!
globalObject
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
ErrorResult
result
;
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
globalObject
result
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
return
result
.
StealNSResult
(
)
;
}
mPersistentStorage
-
>
EnsureReadComplete
(
)
;
nsTArray
<
RefPtr
<
nsICookie
>
>
cookieList
;
mPersistentStorage
-
>
GetAll
(
cookieList
)
;
RefPtr
<
RemoveAllSinceRunnable
>
runMe
=
new
RemoveAllSinceRunnable
(
promise
this
std
:
:
move
(
cookieList
)
aSinceWhen
)
;
promise
.
forget
(
aRetVal
)
;
return
runMe
-
>
Run
(
)
;
}
size_t
CookieService
:
:
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
aMallocSizeOf
(
this
)
;
if
(
mPersistentStorage
)
{
n
+
=
mPersistentStorage
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
if
(
mPrivateStorage
)
{
n
+
=
mPrivateStorage
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
return
n
;
}
MOZ_DEFINE_MALLOC_SIZE_OF
(
CookieServiceMallocSizeOf
)
NS_IMETHODIMP
CookieService
:
:
CollectReports
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
bool
aAnonymize
)
{
MOZ_COLLECT_REPORT
(
"
explicit
/
cookie
-
service
"
KIND_HEAP
UNITS_BYTES
SizeOfIncludingThis
(
CookieServiceMallocSizeOf
)
"
Memory
used
by
the
cookie
service
.
"
)
;
return
NS_OK
;
}
bool
CookieService
:
:
IsInitialized
(
)
const
{
if
(
!
mPersistentStorage
)
{
NS_WARNING
(
"
No
CookieStorage
!
Profile
already
close
?
"
)
;
return
false
;
}
MOZ_ASSERT
(
mPrivateStorage
)
;
return
true
;
}
CookieStorage
*
CookieService
:
:
PickStorage
(
const
OriginAttributes
&
aAttrs
)
{
MOZ_ASSERT
(
IsInitialized
(
)
)
;
if
(
aAttrs
.
mPrivateBrowsingId
>
0
)
{
return
mPrivateStorage
;
}
mPersistentStorage
-
>
EnsureReadComplete
(
)
;
return
mPersistentStorage
;
}
CookieStorage
*
CookieService
:
:
PickStorage
(
const
OriginAttributesPattern
&
aAttrs
)
{
MOZ_ASSERT
(
IsInitialized
(
)
)
;
if
(
aAttrs
.
mPrivateBrowsingId
.
WasPassed
(
)
&
&
aAttrs
.
mPrivateBrowsingId
.
Value
(
)
>
0
)
{
return
mPrivateStorage
;
}
mPersistentStorage
-
>
EnsureReadComplete
(
)
;
return
mPersistentStorage
;
}
}
}
