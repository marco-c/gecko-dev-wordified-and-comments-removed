#
include
"
CookieCommons
.
h
"
#
include
"
CookieLogging
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
ContentBlockingNotifier
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
nsMixedContentBlocker
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
net
/
CookieJarSettings
.
h
"
#
include
"
mozilla
/
net
/
CookiePersistentStorage
.
h
"
#
include
"
mozilla
/
net
/
CookiePrivateStorage
.
h
"
#
include
"
mozilla
/
net
/
CookieService
.
h
"
#
include
"
mozilla
/
net
/
CookieServiceChild
.
h
"
#
include
"
mozilla
/
net
/
HttpBaseChannel
.
h
"
#
include
"
mozilla
/
net
/
NeckoCommon
.
h
"
#
include
"
mozilla
/
StaticPrefs_network
.
h
"
#
include
"
mozilla
/
StoragePrincipalHelper
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozIThirdPartyUtil
.
h
"
#
include
"
nsICookiePermission
.
h
"
#
include
"
nsIConsoleReportCollector
.
h
"
#
include
"
nsIEffectiveTLDService
.
h
"
#
include
"
nsIIDNService
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsIURL
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsIWebProgressListener
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
prprf
.
h
"
#
include
"
ThirdPartyUtil
.
h
"
using
namespace
mozilla
:
:
dom
;
namespace
{
uint32_t
MakeCookieBehavior
(
uint32_t
aCookieBehavior
)
{
bool
isFirstPartyIsolated
=
OriginAttributes
:
:
IsFirstPartyEnabled
(
)
;
if
(
isFirstPartyIsolated
&
&
aCookieBehavior
=
=
nsICookieService
:
:
BEHAVIOR_REJECT_TRACKER_AND_PARTITION_FOREIGN
)
{
return
nsICookieService
:
:
BEHAVIOR_REJECT_TRACKER
;
}
return
aCookieBehavior
;
}
void
MigrateCookieLifetimePrefs
(
)
{
if
(
mozilla
:
:
Preferences
:
:
GetInt
(
"
network
.
cookie
.
lifetimePolicy
"
)
!
=
2
)
{
return
;
}
if
(
!
mozilla
:
:
Preferences
:
:
GetBool
(
"
privacy
.
sanitize
.
sanitizeOnShutdown
"
)
)
{
mozilla
:
:
Preferences
:
:
SetBool
(
"
privacy
.
sanitize
.
sanitizeOnShutdown
"
true
)
;
mozilla
:
:
Preferences
:
:
SetBool
(
"
privacy
.
clearOnShutdown
.
history
"
false
)
;
mozilla
:
:
Preferences
:
:
SetBool
(
"
privacy
.
clearOnShutdown
.
formdata
"
false
)
;
mozilla
:
:
Preferences
:
:
SetBool
(
"
privacy
.
clearOnShutdown
.
downloads
"
false
)
;
mozilla
:
:
Preferences
:
:
SetBool
(
"
privacy
.
clearOnShutdown
.
sessions
"
false
)
;
mozilla
:
:
Preferences
:
:
SetBool
(
"
privacy
.
clearOnShutdown
.
siteSettings
"
false
)
;
}
mozilla
:
:
Preferences
:
:
SetBool
(
"
privacy
.
clearOnShutdown
.
cookies
"
true
)
;
mozilla
:
:
Preferences
:
:
SetBool
(
"
privacy
.
clearOnShutdown
.
cache
"
true
)
;
mozilla
:
:
Preferences
:
:
SetBool
(
"
privacy
.
clearOnShutdown
.
offlineApps
"
true
)
;
mozilla
:
:
Preferences
:
:
ClearUser
(
"
network
.
cookie
.
lifetimePolicy
"
)
;
}
}
uint32_t
nsICookieManager
:
:
GetCookieBehavior
(
bool
aIsPrivate
)
{
if
(
aIsPrivate
)
{
if
(
mozilla
:
:
Preferences
:
:
HasUserValue
(
"
network
.
cookie
.
cookieBehavior
.
pbmode
"
)
)
{
return
MakeCookieBehavior
(
mozilla
:
:
StaticPrefs
:
:
network_cookie_cookieBehavior_pbmode
(
)
)
;
}
if
(
mozilla
:
:
Preferences
:
:
HasUserValue
(
"
network
.
cookie
.
cookieBehavior
"
)
)
{
return
MakeCookieBehavior
(
mozilla
:
:
StaticPrefs
:
:
network_cookie_cookieBehavior
(
)
)
;
}
return
MakeCookieBehavior
(
mozilla
:
:
StaticPrefs
:
:
network_cookie_cookieBehavior_pbmode
(
)
)
;
}
return
MakeCookieBehavior
(
mozilla
:
:
StaticPrefs
:
:
network_cookie_cookieBehavior
(
)
)
;
}
namespace
mozilla
{
namespace
net
{
static
StaticRefPtr
<
CookieService
>
gCookieService
;
constexpr
auto
CONSOLE_SAMESITE_CATEGORY
=
"
cookieSameSite
"
_ns
;
constexpr
auto
CONSOLE_OVERSIZE_CATEGORY
=
"
cookiesOversize
"
_ns
;
constexpr
auto
CONSOLE_REJECTION_CATEGORY
=
"
cookiesRejection
"
_ns
;
constexpr
auto
SAMESITE_MDN_URL
=
"
https
:
/
/
developer
.
mozilla
.
org
/
docs
/
Web
/
HTTP
/
Headers
/
Set
-
Cookie
/
"
u
"
SameSite
"
_ns
;
namespace
{
void
ComposeCookieString
(
nsTArray
<
Cookie
*
>
&
aCookieList
nsACString
&
aCookieString
)
{
for
(
Cookie
*
cookie
:
aCookieList
)
{
if
(
!
cookie
-
>
Name
(
)
.
IsEmpty
(
)
|
|
!
cookie
-
>
Value
(
)
.
IsEmpty
(
)
)
{
if
(
!
aCookieString
.
IsEmpty
(
)
)
{
aCookieString
.
AppendLiteral
(
"
;
"
)
;
}
if
(
!
cookie
-
>
Name
(
)
.
IsEmpty
(
)
)
{
aCookieString
+
=
cookie
-
>
Name
(
)
+
"
=
"
_ns
+
cookie
-
>
Value
(
)
;
}
else
{
aCookieString
+
=
cookie
-
>
Value
(
)
;
}
}
}
}
bool
ProcessSameSiteCookieForForeignRequest
(
nsIChannel
*
aChannel
Cookie
*
aCookie
bool
aIsSafeTopLevelNav
bool
aLaxByDefault
)
{
if
(
aCookie
-
>
SameSite
(
)
=
=
nsICookie
:
:
SAMESITE_STRICT
)
{
return
false
;
}
if
(
aCookie
-
>
SameSite
(
)
=
=
nsICookie
:
:
SAMESITE_NONE
|
|
(
!
aLaxByDefault
&
&
aCookie
-
>
IsDefaultSameSite
(
)
)
)
{
return
true
;
}
int64_t
currentTimeInUsec
=
PR_Now
(
)
;
if
(
aLaxByDefault
&
&
aCookie
-
>
IsDefaultSameSite
(
)
&
&
StaticPrefs
:
:
network_cookie_sameSite_laxPlusPOST_timeout
(
)
>
0
&
&
currentTimeInUsec
-
aCookie
-
>
CreationTime
(
)
<
=
(
StaticPrefs
:
:
network_cookie_sameSite_laxPlusPOST_timeout
(
)
*
PR_USEC_PER_SEC
)
&
&
!
NS_IsSafeMethodNav
(
aChannel
)
)
{
return
true
;
}
MOZ_ASSERT
(
(
aLaxByDefault
&
&
aCookie
-
>
IsDefaultSameSite
(
)
)
|
|
aCookie
-
>
SameSite
(
)
=
=
nsICookie
:
:
SAMESITE_LAX
)
;
return
aIsSafeTopLevelNav
;
}
}
already_AddRefed
<
nsICookieService
>
CookieService
:
:
GetXPCOMSingleton
(
)
{
if
(
IsNeckoChild
(
)
)
{
return
CookieServiceChild
:
:
GetSingleton
(
)
;
}
return
GetSingleton
(
)
;
}
already_AddRefed
<
CookieService
>
CookieService
:
:
GetSingleton
(
)
{
NS_ASSERTION
(
!
IsNeckoChild
(
)
"
not
a
parent
process
"
)
;
if
(
gCookieService
)
{
return
do_AddRef
(
gCookieService
)
;
}
gCookieService
=
new
CookieService
(
)
;
if
(
gCookieService
)
{
if
(
NS_SUCCEEDED
(
gCookieService
-
>
Init
(
)
)
)
{
ClearOnShutdown
(
&
gCookieService
)
;
}
else
{
gCookieService
=
nullptr
;
}
}
return
do_AddRef
(
gCookieService
)
;
}
NS_IMPL_ISUPPORTS
(
CookieService
nsICookieService
nsICookieManager
nsIObserver
nsISupportsWeakReference
nsIMemoryReporter
)
CookieService
:
:
CookieService
(
)
=
default
;
nsresult
CookieService
:
:
Init
(
)
{
nsresult
rv
;
mTLDService
=
do_GetService
(
NS_EFFECTIVETLDSERVICE_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mIDNService
=
do_GetService
(
NS_IDNSERVICE_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mThirdPartyUtil
=
do_GetService
(
THIRDPARTYUTIL_CONTRACTID
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
InitCookieStorages
(
)
;
MigrateCookieLifetimePrefs
(
)
;
RegisterWeakMemoryReporter
(
this
)
;
nsCOMPtr
<
nsIObserverService
>
os
=
services
:
:
GetObserverService
(
)
;
NS_ENSURE_STATE
(
os
)
;
os
-
>
AddObserver
(
this
"
profile
-
before
-
change
"
true
)
;
os
-
>
AddObserver
(
this
"
profile
-
do
-
change
"
true
)
;
os
-
>
AddObserver
(
this
"
last
-
pb
-
context
-
exited
"
true
)
;
return
NS_OK
;
}
void
CookieService
:
:
InitCookieStorages
(
)
{
NS_ASSERTION
(
!
mPersistentStorage
"
already
have
a
default
CookieStorage
"
)
;
NS_ASSERTION
(
!
mPrivateStorage
"
already
have
a
private
CookieStorage
"
)
;
if
(
MOZ_UNLIKELY
(
StaticPrefs
:
:
network_cookie_noPersistentStorage
(
)
)
)
{
mPersistentStorage
=
CookiePrivateStorage
:
:
Create
(
)
;
}
else
{
mPersistentStorage
=
CookiePersistentStorage
:
:
Create
(
)
;
}
mPrivateStorage
=
CookiePrivateStorage
:
:
Create
(
)
;
}
void
CookieService
:
:
CloseCookieStorages
(
)
{
if
(
!
mPersistentStorage
)
{
return
;
}
RefPtr
<
CookieStorage
>
privateStorage
;
privateStorage
.
swap
(
mPrivateStorage
)
;
RefPtr
<
CookieStorage
>
persistentStorage
;
persistentStorage
.
swap
(
mPersistentStorage
)
;
privateStorage
-
>
Close
(
)
;
persistentStorage
-
>
Close
(
)
;
}
CookieService
:
:
~
CookieService
(
)
{
CloseCookieStorages
(
)
;
UnregisterWeakMemoryReporter
(
this
)
;
gCookieService
=
nullptr
;
}
NS_IMETHODIMP
CookieService
:
:
Observe
(
nsISupports
*
const
char
*
aTopic
const
char16_t
*
)
{
if
(
!
strcmp
(
aTopic
"
profile
-
before
-
change
"
)
)
{
CloseCookieStorages
(
)
;
}
else
if
(
!
strcmp
(
aTopic
"
profile
-
do
-
change
"
)
)
{
NS_ASSERTION
(
!
mPersistentStorage
"
shouldn
'
t
have
a
default
CookieStorage
"
)
;
NS_ASSERTION
(
!
mPrivateStorage
"
shouldn
'
t
have
a
private
CookieStorage
"
)
;
InitCookieStorages
(
)
;
}
else
if
(
!
strcmp
(
aTopic
"
last
-
pb
-
context
-
exited
"
)
)
{
OriginAttributesPattern
pattern
;
pattern
.
mPrivateBrowsingId
.
Construct
(
1
)
;
RemoveCookiesWithOriginAttributes
(
pattern
"
"
_ns
)
;
mPrivateStorage
=
CookiePrivateStorage
:
:
Create
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
CookieService
:
:
GetCookieBehavior
(
bool
aIsPrivate
uint32_t
*
aCookieBehavior
)
{
NS_ENSURE_ARG_POINTER
(
aCookieBehavior
)
;
*
aCookieBehavior
=
nsICookieManager
:
:
GetCookieBehavior
(
aIsPrivate
)
;
return
NS_OK
;
}
NS_IMETHODIMP
CookieService
:
:
GetCookieStringFromDocument
(
Document
*
aDocument
nsACString
&
aCookie
)
{
NS_ENSURE_ARG
(
aDocument
)
;
nsresult
rv
;
aCookie
.
Truncate
(
)
;
if
(
!
IsInitialized
(
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIPrincipal
>
principal
=
aDocument
-
>
EffectiveCookiePrincipal
(
)
;
if
(
!
CookieCommons
:
:
IsSchemeSupported
(
principal
)
)
{
return
NS_OK
;
}
CookieStorage
*
storage
=
PickStorage
(
principal
-
>
OriginAttributesRef
(
)
)
;
nsAutoCString
baseDomain
;
rv
=
CookieCommons
:
:
GetBaseDomain
(
principal
baseDomain
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
NS_OK
;
}
nsAutoCString
hostFromURI
;
rv
=
nsContentUtils
:
:
GetHostOrIPv6WithBrackets
(
principal
hostFromURI
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
NS_OK
;
}
nsAutoCString
pathFromURI
;
rv
=
principal
-
>
GetFilePath
(
pathFromURI
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
NS_OK
;
}
int64_t
currentTimeInUsec
=
PR_Now
(
)
;
int64_t
currentTime
=
currentTimeInUsec
/
PR_USEC_PER_SEC
;
const
nsTArray
<
RefPtr
<
Cookie
>
>
*
cookies
=
storage
-
>
GetCookiesFromHost
(
baseDomain
principal
-
>
OriginAttributesRef
(
)
)
;
if
(
!
cookies
)
{
return
NS_OK
;
}
bool
potentiallyTurstworthy
=
principal
-
>
GetIsOriginPotentiallyTrustworthy
(
)
;
bool
thirdParty
=
true
;
nsPIDOMWindowInner
*
innerWindow
=
aDocument
-
>
GetInnerWindow
(
)
;
if
(
innerWindow
)
{
ThirdPartyUtil
*
thirdPartyUtil
=
ThirdPartyUtil
:
:
GetInstance
(
)
;
if
(
thirdPartyUtil
)
{
Unused
<
<
thirdPartyUtil
-
>
IsThirdPartyWindow
(
innerWindow
-
>
GetOuterWindow
(
)
nullptr
&
thirdParty
)
;
}
}
bool
stale
=
false
;
nsTArray
<
Cookie
*
>
cookieList
;
for
(
Cookie
*
cookie
:
*
cookies
)
{
if
(
!
CookieCommons
:
:
DomainMatches
(
cookie
hostFromURI
)
)
{
continue
;
}
if
(
cookie
-
>
IsHttpOnly
(
)
)
{
continue
;
}
if
(
thirdParty
&
&
!
CookieCommons
:
:
ShouldIncludeCrossSiteCookieForDocument
(
cookie
)
)
{
continue
;
}
if
(
cookie
-
>
IsSecure
(
)
&
&
!
potentiallyTurstworthy
)
{
continue
;
}
if
(
!
CookieCommons
:
:
PathMatches
(
cookie
pathFromURI
)
)
{
continue
;
}
if
(
cookie
-
>
Expiry
(
)
<
=
currentTime
)
{
continue
;
}
cookieList
.
AppendElement
(
cookie
)
;
if
(
cookie
-
>
IsStale
(
)
)
{
stale
=
true
;
}
}
if
(
cookieList
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
if
(
stale
)
{
storage
-
>
StaleCookies
(
cookieList
currentTimeInUsec
)
;
}
cookieList
.
Sort
(
CompareCookiesForSending
(
)
)
;
ComposeCookieString
(
cookieList
aCookie
)
;
return
NS_OK
;
}
NS_IMETHODIMP
CookieService
:
:
GetCookieStringFromHttp
(
nsIURI
*
aHostURI
nsIChannel
*
aChannel
nsACString
&
aCookieString
)
{
NS_ENSURE_ARG
(
aHostURI
)
;
NS_ENSURE_ARG
(
aChannel
)
;
aCookieString
.
Truncate
(
)
;
if
(
!
CookieCommons
:
:
IsSchemeSupported
(
aHostURI
)
)
{
return
NS_OK
;
}
uint32_t
rejectedReason
=
0
;
ThirdPartyAnalysisResult
result
=
mThirdPartyUtil
-
>
AnalyzeChannel
(
aChannel
false
aHostURI
nullptr
&
rejectedReason
)
;
OriginAttributes
attrs
;
StoragePrincipalHelper
:
:
GetOriginAttributes
(
aChannel
attrs
StoragePrincipalHelper
:
:
eStorageAccessPrincipal
)
;
bool
isSafeTopLevelNav
=
CookieCommons
:
:
IsSafeTopLevelNav
(
aChannel
)
;
bool
hadCrossSiteRedirects
=
false
;
bool
isSameSiteForeign
=
CookieCommons
:
:
IsSameSiteForeign
(
aChannel
aHostURI
&
hadCrossSiteRedirects
)
;
AutoTArray
<
Cookie
*
8
>
foundCookieList
;
GetCookiesForURI
(
aHostURI
aChannel
result
.
contains
(
ThirdPartyAnalysis
:
:
IsForeign
)
result
.
contains
(
ThirdPartyAnalysis
:
:
IsThirdPartyTrackingResource
)
result
.
contains
(
ThirdPartyAnalysis
:
:
IsThirdPartySocialTrackingResource
)
result
.
contains
(
ThirdPartyAnalysis
:
:
IsStorageAccessPermissionGranted
)
rejectedReason
isSafeTopLevelNav
isSameSiteForeign
hadCrossSiteRedirects
true
attrs
foundCookieList
)
;
ComposeCookieString
(
foundCookieList
aCookieString
)
;
if
(
!
aCookieString
.
IsEmpty
(
)
)
{
COOKIE_LOGSUCCESS
(
GET_COOKIE
aHostURI
aCookieString
nullptr
false
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
CookieService
:
:
SetCookieStringFromDocument
(
Document
*
aDocument
const
nsACString
&
aCookieString
)
{
NS_ENSURE_ARG
(
aDocument
)
;
if
(
!
IsInitialized
(
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIURI
>
documentURI
;
nsAutoCString
baseDomain
;
OriginAttributes
attrs
;
int64_t
currentTimeInUsec
=
PR_Now
(
)
;
auto
hasExistingCookiesLambda
=
[
&
]
(
const
nsACString
&
aBaseDomain
const
OriginAttributes
&
aAttrs
)
{
CookieStorage
*
storage
=
PickStorage
(
aAttrs
)
;
return
!
!
storage
-
>
CountCookiesFromHost
(
aBaseDomain
aAttrs
.
mPrivateBrowsingId
)
;
}
;
RefPtr
<
Cookie
>
cookie
=
CookieCommons
:
:
CreateCookieFromDocument
(
aDocument
aCookieString
currentTimeInUsec
mTLDService
mThirdPartyUtil
hasExistingCookiesLambda
getter_AddRefs
(
documentURI
)
baseDomain
attrs
)
;
if
(
!
cookie
)
{
return
NS_OK
;
}
bool
thirdParty
=
true
;
nsPIDOMWindowInner
*
innerWindow
=
aDocument
-
>
GetInnerWindow
(
)
;
if
(
innerWindow
)
{
ThirdPartyUtil
*
thirdPartyUtil
=
ThirdPartyUtil
:
:
GetInstance
(
)
;
if
(
thirdPartyUtil
)
{
Unused
<
<
thirdPartyUtil
-
>
IsThirdPartyWindow
(
innerWindow
-
>
GetOuterWindow
(
)
nullptr
&
thirdParty
)
;
}
}
if
(
thirdParty
&
&
!
CookieCommons
:
:
ShouldIncludeCrossSiteCookieForDocument
(
cookie
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIConsoleReportCollector
>
crc
=
do_QueryInterface
(
aDocument
-
>
GetChannel
(
)
)
;
PickStorage
(
attrs
)
-
>
AddCookie
(
crc
baseDomain
attrs
cookie
currentTimeInUsec
documentURI
aCookieString
false
)
;
return
NS_OK
;
}
NS_IMETHODIMP
CookieService
:
:
SetCookieStringFromHttp
(
nsIURI
*
aHostURI
const
nsACString
&
aCookieHeader
nsIChannel
*
aChannel
)
{
NS_ENSURE_ARG
(
aHostURI
)
;
NS_ENSURE_ARG
(
aChannel
)
;
if
(
!
IsInitialized
(
)
)
{
return
NS_OK
;
}
if
(
!
CookieCommons
:
:
IsSchemeSupported
(
aHostURI
)
)
{
return
NS_OK
;
}
uint32_t
rejectedReason
=
0
;
ThirdPartyAnalysisResult
result
=
mThirdPartyUtil
-
>
AnalyzeChannel
(
aChannel
false
aHostURI
nullptr
&
rejectedReason
)
;
OriginAttributes
attrs
;
StoragePrincipalHelper
:
:
GetOriginAttributes
(
aChannel
attrs
StoragePrincipalHelper
:
:
eStorageAccessPrincipal
)
;
bool
requireHostMatch
;
nsAutoCString
baseDomain
;
nsresult
rv
=
CookieCommons
:
:
GetBaseDomain
(
mTLDService
aHostURI
baseDomain
requireHostMatch
)
;
if
(
NS_FAILED
(
rv
)
)
{
COOKIE_LOGFAILURE
(
SET_COOKIE
aHostURI
aCookieHeader
"
couldn
'
t
get
base
domain
from
URI
"
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsICookieJarSettings
>
cookieJarSettings
=
CookieCommons
:
:
GetCookieJarSettings
(
aChannel
)
;
nsAutoCString
hostFromURI
;
nsContentUtils
:
:
GetHostOrIPv6WithBrackets
(
aHostURI
hostFromURI
)
;
nsAutoCString
baseDomainFromURI
;
rv
=
CookieCommons
:
:
GetBaseDomainFromHost
(
mTLDService
hostFromURI
baseDomainFromURI
)
;
NS_ENSURE_SUCCESS
(
rv
NS_OK
)
;
CookieStorage
*
storage
=
PickStorage
(
attrs
)
;
uint32_t
priorCookieCount
=
storage
-
>
CountCookiesFromHost
(
baseDomainFromURI
attrs
.
mPrivateBrowsingId
)
;
nsCOMPtr
<
nsIConsoleReportCollector
>
crc
=
do_QueryInterface
(
aChannel
)
;
CookieStatus
cookieStatus
=
CheckPrefs
(
crc
cookieJarSettings
aHostURI
result
.
contains
(
ThirdPartyAnalysis
:
:
IsForeign
)
result
.
contains
(
ThirdPartyAnalysis
:
:
IsThirdPartyTrackingResource
)
result
.
contains
(
ThirdPartyAnalysis
:
:
IsThirdPartySocialTrackingResource
)
result
.
contains
(
ThirdPartyAnalysis
:
:
IsStorageAccessPermissionGranted
)
aCookieHeader
priorCookieCount
attrs
&
rejectedReason
)
;
MOZ_ASSERT_IF
(
rejectedReason
cookieStatus
=
=
STATUS_REJECTED
)
;
switch
(
cookieStatus
)
{
case
STATUS_REJECTED
:
CookieCommons
:
:
NotifyRejected
(
aHostURI
aChannel
rejectedReason
OPERATION_WRITE
)
;
return
NS_OK
;
case
STATUS_REJECTED_WITH_ERROR
:
CookieCommons
:
:
NotifyRejected
(
aHostURI
aChannel
rejectedReason
OPERATION_WRITE
)
;
return
NS_OK
;
case
STATUS_ACCEPTED
:
case
STATUS_ACCEPT_SESSION
:
NotifyAccepted
(
aChannel
)
;
break
;
default
:
break
;
}
bool
addonAllowsLoad
=
false
;
nsCOMPtr
<
nsIURI
>
channelURI
;
NS_GetFinalChannelURI
(
aChannel
getter_AddRefs
(
channelURI
)
)
;
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
aChannel
-
>
LoadInfo
(
)
;
addonAllowsLoad
=
BasePrincipal
:
:
Cast
(
loadInfo
-
>
TriggeringPrincipal
(
)
)
-
>
AddonAllowsLoad
(
channelURI
)
;
bool
isForeignAndNotAddon
=
false
;
if
(
!
addonAllowsLoad
)
{
mThirdPartyUtil
-
>
IsThirdPartyChannel
(
aChannel
aHostURI
&
isForeignAndNotAddon
)
;
}
nsCString
cookieHeader
(
aCookieHeader
)
;
bool
moreCookieToRead
=
true
;
while
(
moreCookieToRead
)
{
CookieStruct
cookieData
;
bool
canSetCookie
=
false
;
moreCookieToRead
=
CanSetCookie
(
aHostURI
baseDomain
cookieData
requireHostMatch
cookieStatus
cookieHeader
true
isForeignAndNotAddon
crc
canSetCookie
)
;
if
(
!
canSetCookie
)
{
continue
;
}
if
(
!
CookieCommons
:
:
CheckCookiePermission
(
aChannel
cookieData
)
)
{
COOKIE_LOGFAILURE
(
SET_COOKIE
aHostURI
aCookieHeader
"
cookie
rejected
by
permission
manager
"
)
;
CookieCommons
:
:
NotifyRejected
(
aHostURI
aChannel
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_BY_PERMISSION
OPERATION_WRITE
)
;
CookieLogging
:
:
LogMessageToConsole
(
crc
aHostURI
nsIScriptError
:
:
warningFlag
CONSOLE_REJECTION_CATEGORY
"
CookieRejectedByPermissionManager
"
_ns
AutoTArray
<
nsString
1
>
{
NS_ConvertUTF8toUTF16
(
cookieData
.
name
(
)
)
}
)
;
continue
;
}
RefPtr
<
Cookie
>
cookie
=
Cookie
:
:
Create
(
cookieData
attrs
)
;
MOZ_ASSERT
(
cookie
)
;
int64_t
currentTimeInUsec
=
PR_Now
(
)
;
cookie
-
>
SetLastAccessed
(
currentTimeInUsec
)
;
cookie
-
>
SetCreationTime
(
Cookie
:
:
GenerateUniqueCreationTime
(
currentTimeInUsec
)
)
;
storage
-
>
AddCookie
(
crc
baseDomain
attrs
cookie
currentTimeInUsec
aHostURI
aCookieHeader
true
)
;
}
return
NS_OK
;
}
void
CookieService
:
:
NotifyAccepted
(
nsIChannel
*
aChannel
)
{
ContentBlockingNotifier
:
:
OnDecision
(
aChannel
ContentBlockingNotifier
:
:
BlockingDecision
:
:
eAllow
0
)
;
}
NS_IMETHODIMP
CookieService
:
:
RunInTransaction
(
nsICookieTransactionCallback
*
aCallback
)
{
NS_ENSURE_ARG
(
aCallback
)
;
if
(
!
IsInitialized
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
mPersistentStorage
-
>
EnsureInitialized
(
)
;
return
mPersistentStorage
-
>
RunInTransaction
(
aCallback
)
;
}
NS_IMETHODIMP
CookieService
:
:
RemoveAll
(
)
{
if
(
!
IsInitialized
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
mPersistentStorage
-
>
EnsureInitialized
(
)
;
mPersistentStorage
-
>
RemoveAll
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
CookieService
:
:
GetCookies
(
nsTArray
<
RefPtr
<
nsICookie
>
>
&
aCookies
)
{
if
(
!
IsInitialized
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
mPersistentStorage
-
>
EnsureInitialized
(
)
;
mPersistentStorage
-
>
GetCookies
(
aCookies
)
;
return
NS_OK
;
}
NS_IMETHODIMP
CookieService
:
:
GetSessionCookies
(
nsTArray
<
RefPtr
<
nsICookie
>
>
&
aCookies
)
{
if
(
!
IsInitialized
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
mPersistentStorage
-
>
EnsureInitialized
(
)
;
mPersistentStorage
-
>
GetCookies
(
aCookies
)
;
return
NS_OK
;
}
NS_IMETHODIMP
CookieService
:
:
Add
(
const
nsACString
&
aHost
const
nsACString
&
aPath
const
nsACString
&
aName
const
nsACString
&
aValue
bool
aIsSecure
bool
aIsHttpOnly
bool
aIsSession
int64_t
aExpiry
JS
:
:
Handle
<
JS
:
:
Value
>
aOriginAttributes
int32_t
aSameSite
nsICookie
:
:
schemeType
aSchemeMap
JSContext
*
aCx
)
{
OriginAttributes
attrs
;
if
(
!
aOriginAttributes
.
isObject
(
)
|
|
!
attrs
.
Init
(
aCx
aOriginAttributes
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
return
AddNative
(
aHost
aPath
aName
aValue
aIsSecure
aIsHttpOnly
aIsSession
aExpiry
&
attrs
aSameSite
aSchemeMap
)
;
}
NS_IMETHODIMP_
(
nsresult
)
CookieService
:
:
AddNative
(
const
nsACString
&
aHost
const
nsACString
&
aPath
const
nsACString
&
aName
const
nsACString
&
aValue
bool
aIsSecure
bool
aIsHttpOnly
bool
aIsSession
int64_t
aExpiry
OriginAttributes
*
aOriginAttributes
int32_t
aSameSite
nsICookie
:
:
schemeType
aSchemeMap
)
{
if
(
NS_WARN_IF
(
!
aOriginAttributes
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
IsInitialized
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsAutoCString
host
(
aHost
)
;
nsresult
rv
=
NormalizeHost
(
host
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
baseDomain
;
rv
=
CookieCommons
:
:
GetBaseDomainFromHost
(
mTLDService
host
baseDomain
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
int64_t
currentTimeInUsec
=
PR_Now
(
)
;
CookieKey
key
=
CookieKey
(
baseDomain
*
aOriginAttributes
)
;
CookieStruct
cookieData
(
nsCString
(
aName
)
nsCString
(
aValue
)
nsCString
(
aHost
)
nsCString
(
aPath
)
aExpiry
currentTimeInUsec
Cookie
:
:
GenerateUniqueCreationTime
(
currentTimeInUsec
)
aIsHttpOnly
aIsSession
aIsSecure
aSameSite
aSameSite
aSchemeMap
)
;
RefPtr
<
Cookie
>
cookie
=
Cookie
:
:
Create
(
cookieData
key
.
mOriginAttributes
)
;
MOZ_ASSERT
(
cookie
)
;
CookieStorage
*
storage
=
PickStorage
(
*
aOriginAttributes
)
;
storage
-
>
AddCookie
(
nullptr
baseDomain
*
aOriginAttributes
cookie
currentTimeInUsec
nullptr
VoidCString
(
)
true
)
;
return
NS_OK
;
}
nsresult
CookieService
:
:
Remove
(
const
nsACString
&
aHost
const
OriginAttributes
&
aAttrs
const
nsACString
&
aName
const
nsACString
&
aPath
)
{
nsAutoCString
host
(
aHost
)
;
nsresult
rv
=
NormalizeHost
(
host
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
baseDomain
;
if
(
!
host
.
IsEmpty
(
)
)
{
rv
=
CookieCommons
:
:
GetBaseDomainFromHost
(
mTLDService
host
baseDomain
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
!
IsInitialized
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
CookieStorage
*
storage
=
PickStorage
(
aAttrs
)
;
storage
-
>
RemoveCookie
(
baseDomain
aAttrs
host
PromiseFlatCString
(
aName
)
PromiseFlatCString
(
aPath
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
CookieService
:
:
Remove
(
const
nsACString
&
aHost
const
nsACString
&
aName
const
nsACString
&
aPath
JS
:
:
Handle
<
JS
:
:
Value
>
aOriginAttributes
JSContext
*
aCx
)
{
OriginAttributes
attrs
;
if
(
!
aOriginAttributes
.
isObject
(
)
|
|
!
attrs
.
Init
(
aCx
aOriginAttributes
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
return
RemoveNative
(
aHost
aName
aPath
&
attrs
)
;
}
NS_IMETHODIMP_
(
nsresult
)
CookieService
:
:
RemoveNative
(
const
nsACString
&
aHost
const
nsACString
&
aName
const
nsACString
&
aPath
OriginAttributes
*
aOriginAttributes
)
{
if
(
NS_WARN_IF
(
!
aOriginAttributes
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
Remove
(
aHost
*
aOriginAttributes
aName
aPath
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
enum
class
CookieProblem
:
uint32_t
{
None
=
0
RedirectDefault
=
1
<
<
0
RedirectExplicit
=
1
<
<
1
RedirectGoogleAds
=
1
<
<
2
OtherDefault
=
1
<
<
3
OtherExplicit
=
1
<
<
4
}
;
MOZ_MAKE_ENUM_CLASS_BITWISE_OPERATORS
(
CookieProblem
)
void
CookieService
:
:
GetCookiesForURI
(
nsIURI
*
aHostURI
nsIChannel
*
aChannel
bool
aIsForeign
bool
aIsThirdPartyTrackingResource
bool
aIsThirdPartySocialTrackingResource
bool
aStorageAccessPermissionGranted
uint32_t
aRejectedReason
bool
aIsSafeTopLevelNav
bool
aIsSameSiteForeign
bool
aHadCrossSiteRedirects
bool
aHttpBound
const
OriginAttributes
&
aOriginAttrs
nsTArray
<
Cookie
*
>
&
aCookieList
)
{
NS_ASSERTION
(
aHostURI
"
null
host
!
"
)
;
if
(
!
CookieCommons
:
:
IsSchemeSupported
(
aHostURI
)
)
{
return
;
}
if
(
!
IsInitialized
(
)
)
{
return
;
}
CookieStorage
*
storage
=
PickStorage
(
aOriginAttrs
)
;
bool
requireHostMatch
;
nsAutoCString
baseDomain
;
nsAutoCString
hostFromURI
;
nsAutoCString
pathFromURI
;
nsresult
rv
=
CookieCommons
:
:
GetBaseDomain
(
mTLDService
aHostURI
baseDomain
requireHostMatch
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
nsContentUtils
:
:
GetHostOrIPv6WithBrackets
(
aHostURI
hostFromURI
)
;
}
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
aHostURI
-
>
GetFilePath
(
pathFromURI
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
COOKIE_LOGFAILURE
(
GET_COOKIE
aHostURI
VoidCString
(
)
"
invalid
host
/
path
from
URI
"
)
;
return
;
}
nsCOMPtr
<
nsICookieJarSettings
>
cookieJarSettings
=
CookieCommons
:
:
GetCookieJarSettings
(
aChannel
)
;
nsAutoCString
normalizedHostFromURI
(
hostFromURI
)
;
rv
=
NormalizeHost
(
normalizedHostFromURI
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
nsAutoCString
baseDomainFromURI
;
rv
=
CookieCommons
:
:
GetBaseDomainFromHost
(
mTLDService
normalizedHostFromURI
baseDomainFromURI
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
uint32_t
rejectedReason
=
aRejectedReason
;
uint32_t
priorCookieCount
=
storage
-
>
CountCookiesFromHost
(
baseDomainFromURI
aOriginAttrs
.
mPrivateBrowsingId
)
;
nsCOMPtr
<
nsIConsoleReportCollector
>
crc
=
do_QueryInterface
(
aChannel
)
;
CookieStatus
cookieStatus
=
CheckPrefs
(
crc
cookieJarSettings
aHostURI
aIsForeign
aIsThirdPartyTrackingResource
aIsThirdPartySocialTrackingResource
aStorageAccessPermissionGranted
VoidCString
(
)
priorCookieCount
aOriginAttrs
&
rejectedReason
)
;
MOZ_ASSERT_IF
(
rejectedReason
cookieStatus
=
=
STATUS_REJECTED
)
;
switch
(
cookieStatus
)
{
case
STATUS_REJECTED
:
if
(
priorCookieCount
)
{
CookieCommons
:
:
NotifyRejected
(
aHostURI
aChannel
rejectedReason
OPERATION_READ
)
;
}
return
;
default
:
break
;
}
bool
potentiallyTurstworthy
=
nsMixedContentBlocker
:
:
IsPotentiallyTrustworthyOrigin
(
aHostURI
)
;
int64_t
currentTimeInUsec
=
PR_Now
(
)
;
int64_t
currentTime
=
currentTimeInUsec
/
PR_USEC_PER_SEC
;
bool
stale
=
false
;
const
nsTArray
<
RefPtr
<
Cookie
>
>
*
cookies
=
storage
-
>
GetCookiesFromHost
(
baseDomain
aOriginAttrs
)
;
if
(
!
cookies
)
{
return
;
}
bool
laxByDefault
=
StaticPrefs
:
:
network_cookie_sameSite_laxByDefault
(
)
&
&
!
nsContentUtils
:
:
IsURIInPrefList
(
aHostURI
"
network
.
cookie
.
sameSite
.
laxByDefault
.
disabledHosts
"
)
;
CookieProblem
sameSiteProblems
=
CookieProblem
:
:
None
;
for
(
Cookie
*
cookie
:
*
cookies
)
{
if
(
!
CookieCommons
:
:
DomainMatches
(
cookie
hostFromURI
)
)
{
continue
;
}
if
(
cookie
-
>
IsSecure
(
)
&
&
!
potentiallyTurstworthy
)
{
continue
;
}
if
(
cookie
-
>
IsHttpOnly
(
)
&
&
!
aHttpBound
)
{
continue
;
}
if
(
!
CookieCommons
:
:
PathMatches
(
cookie
pathFromURI
)
)
{
continue
;
}
if
(
cookie
-
>
Expiry
(
)
<
=
currentTime
)
{
continue
;
}
if
(
aHttpBound
&
&
aIsSameSiteForeign
)
{
bool
blockCookie
=
!
ProcessSameSiteCookieForForeignRequest
(
aChannel
cookie
aIsSafeTopLevelNav
laxByDefault
)
;
if
(
blockCookie
|
|
(
!
laxByDefault
&
&
cookie
-
>
IsDefaultSameSite
(
)
&
&
!
ProcessSameSiteCookieForForeignRequest
(
aChannel
cookie
aIsSafeTopLevelNav
true
)
)
)
{
if
(
aHadCrossSiteRedirects
)
{
if
(
StringBeginsWith
(
hostFromURI
"
adservice
.
google
.
"
_ns
)
)
{
sameSiteProblems
|
=
CookieProblem
:
:
RedirectGoogleAds
;
}
else
{
if
(
cookie
-
>
IsDefaultSameSite
(
)
)
{
sameSiteProblems
|
=
CookieProblem
:
:
RedirectDefault
;
}
else
{
sameSiteProblems
|
=
CookieProblem
:
:
RedirectExplicit
;
}
}
}
else
{
if
(
cookie
-
>
IsDefaultSameSite
(
)
)
{
sameSiteProblems
|
=
CookieProblem
:
:
OtherDefault
;
}
else
{
sameSiteProblems
|
=
CookieProblem
:
:
OtherExplicit
;
}
}
}
if
(
blockCookie
)
{
CookieLogging
:
:
LogMessageToConsole
(
crc
aHostURI
nsIScriptError
:
:
warningFlag
CONSOLE_REJECTION_CATEGORY
"
CookieBlockedCrossSiteRedirect
"
_ns
AutoTArray
<
nsString
1
>
{
NS_ConvertUTF8toUTF16
(
cookie
-
>
Name
(
)
)
}
)
;
continue
;
}
}
aCookieList
.
AppendElement
(
cookie
)
;
if
(
cookie
-
>
IsStale
(
)
)
{
stale
=
true
;
}
}
Telemetry
:
:
Accumulate
(
Telemetry
:
:
COOKIE_RETRIEVAL_SAMESITE_PROBLEM
static_cast
<
uint32_t
>
(
sameSiteProblems
)
)
;
if
(
aCookieList
.
IsEmpty
(
)
)
{
return
;
}
NotifyAccepted
(
aChannel
)
;
if
(
stale
)
{
storage
-
>
StaleCookies
(
aCookieList
currentTimeInUsec
)
;
}
aCookieList
.
Sort
(
CompareCookiesForSending
(
)
)
;
}
bool
CookieService
:
:
CanSetCookie
(
nsIURI
*
aHostURI
const
nsACString
&
aBaseDomain
CookieStruct
&
aCookieData
bool
aRequireHostMatch
CookieStatus
aStatus
nsCString
&
aCookieHeader
bool
aFromHttp
bool
aIsForeignAndNotAddon
nsIConsoleReportCollector
*
aCRC
bool
&
aSetCookie
)
{
MOZ_ASSERT
(
aHostURI
)
;
aSetCookie
=
false
;
aCookieData
.
expiry
(
)
=
INT64_MAX
;
aCookieData
.
schemeMap
(
)
=
CookieCommons
:
:
URIToSchemeType
(
aHostURI
)
;
nsCString
savedCookieHeader
(
aCookieHeader
)
;
nsAutoCString
expires
;
nsAutoCString
maxage
;
bool
acceptedByParser
=
false
;
bool
newCookie
=
ParseAttributes
(
aCRC
aHostURI
aCookieHeader
aCookieData
expires
maxage
acceptedByParser
)
;
if
(
!
acceptedByParser
)
{
return
newCookie
;
}
bool
potentiallyTurstworthy
=
nsMixedContentBlocker
:
:
IsPotentiallyTrustworthyOrigin
(
aHostURI
)
;
int64_t
currentTimeInUsec
=
PR_Now
(
)
;
aCookieData
.
isSession
(
)
=
GetExpiry
(
aCookieData
expires
maxage
currentTimeInUsec
/
PR_USEC_PER_SEC
aFromHttp
)
;
if
(
aStatus
=
=
STATUS_ACCEPT_SESSION
)
{
aCookieData
.
isSession
(
)
=
true
;
}
if
(
!
CookieCommons
:
:
CheckNameAndValueSize
(
aCookieData
)
)
{
COOKIE_LOGFAILURE
(
SET_COOKIE
aHostURI
savedCookieHeader
"
cookie
too
big
(
>
4kb
)
"
)
;
AutoTArray
<
nsString
2
>
params
=
{
NS_ConvertUTF8toUTF16
(
aCookieData
.
name
(
)
)
}
;
nsString
size
;
size
.
AppendInt
(
kMaxBytesPerCookie
)
;
params
.
AppendElement
(
size
)
;
CookieLogging
:
:
LogMessageToConsole
(
aCRC
aHostURI
nsIScriptError
:
:
warningFlag
CONSOLE_OVERSIZE_CATEGORY
"
CookieOversize
"
_ns
params
)
;
return
newCookie
;
}
if
(
!
CookieCommons
:
:
CheckName
(
aCookieData
)
)
{
COOKIE_LOGFAILURE
(
SET_COOKIE
aHostURI
savedCookieHeader
"
invalid
name
character
"
)
;
CookieLogging
:
:
LogMessageToConsole
(
aCRC
aHostURI
nsIScriptError
:
:
warningFlag
CONSOLE_REJECTION_CATEGORY
"
CookieRejectedInvalidCharName
"
_ns
AutoTArray
<
nsString
1
>
{
NS_ConvertUTF8toUTF16
(
aCookieData
.
name
(
)
)
}
)
;
return
newCookie
;
}
if
(
!
CheckDomain
(
aCookieData
aHostURI
aBaseDomain
aRequireHostMatch
)
)
{
COOKIE_LOGFAILURE
(
SET_COOKIE
aHostURI
savedCookieHeader
"
failed
the
domain
tests
"
)
;
CookieLogging
:
:
LogMessageToConsole
(
aCRC
aHostURI
nsIScriptError
:
:
warningFlag
CONSOLE_REJECTION_CATEGORY
"
CookieRejectedInvalidDomain
"
_ns
AutoTArray
<
nsString
1
>
{
NS_ConvertUTF8toUTF16
(
aCookieData
.
name
(
)
)
}
)
;
return
newCookie
;
}
if
(
!
CheckPath
(
aCookieData
aCRC
aHostURI
)
)
{
COOKIE_LOGFAILURE
(
SET_COOKIE
aHostURI
savedCookieHeader
"
failed
the
path
tests
"
)
;
return
newCookie
;
}
if
(
!
CheckPrefixes
(
aCookieData
potentiallyTurstworthy
)
)
{
COOKIE_LOGFAILURE
(
SET_COOKIE
aHostURI
savedCookieHeader
"
failed
the
prefix
tests
"
)
;
CookieLogging
:
:
LogMessageToConsole
(
aCRC
aHostURI
nsIScriptError
:
:
warningFlag
CONSOLE_REJECTION_CATEGORY
"
CookieRejectedInvalidPrefix
"
_ns
AutoTArray
<
nsString
1
>
{
NS_ConvertUTF8toUTF16
(
aCookieData
.
name
(
)
)
}
)
;
return
newCookie
;
}
if
(
aFromHttp
&
&
!
CookieCommons
:
:
CheckHttpValue
(
aCookieData
)
)
{
COOKIE_LOGFAILURE
(
SET_COOKIE
aHostURI
savedCookieHeader
"
invalid
value
character
"
)
;
CookieLogging
:
:
LogMessageToConsole
(
aCRC
aHostURI
nsIScriptError
:
:
warningFlag
CONSOLE_REJECTION_CATEGORY
"
CookieRejectedInvalidCharValue
"
_ns
AutoTArray
<
nsString
1
>
{
NS_ConvertUTF8toUTF16
(
aCookieData
.
name
(
)
)
}
)
;
return
newCookie
;
}
if
(
!
aFromHttp
&
&
aCookieData
.
isHttpOnly
(
)
)
{
COOKIE_LOGFAILURE
(
SET_COOKIE
aHostURI
savedCookieHeader
"
cookie
is
httponly
;
coming
from
script
"
)
;
CookieLogging
:
:
LogMessageToConsole
(
aCRC
aHostURI
nsIScriptError
:
:
warningFlag
CONSOLE_REJECTION_CATEGORY
"
CookieRejectedHttpOnlyButFromScript
"
_ns
AutoTArray
<
nsString
1
>
{
NS_ConvertUTF8toUTF16
(
aCookieData
.
name
(
)
)
}
)
;
return
newCookie
;
}
if
(
aCookieData
.
isSecure
(
)
&
&
!
potentiallyTurstworthy
)
{
COOKIE_LOGFAILURE
(
SET_COOKIE
aHostURI
aCookieHeader
"
non
-
https
cookie
can
'
t
set
secure
flag
"
)
;
CookieLogging
:
:
LogMessageToConsole
(
aCRC
aHostURI
nsIScriptError
:
:
warningFlag
CONSOLE_REJECTION_CATEGORY
"
CookieRejectedSecureButNonHttps
"
_ns
AutoTArray
<
nsString
1
>
{
NS_ConvertUTF8toUTF16
(
aCookieData
.
name
(
)
)
}
)
;
return
newCookie
;
}
bool
laxByDefault
=
StaticPrefs
:
:
network_cookie_sameSite_laxByDefault
(
)
&
&
!
nsContentUtils
:
:
IsURIInPrefList
(
aHostURI
"
network
.
cookie
.
sameSite
.
laxByDefault
.
disabledHosts
"
)
;
auto
effectiveSameSite
=
laxByDefault
?
aCookieData
.
sameSite
(
)
:
aCookieData
.
rawSameSite
(
)
;
if
(
(
effectiveSameSite
!
=
nsICookie
:
:
SAMESITE_NONE
)
&
&
aIsForeignAndNotAddon
)
{
COOKIE_LOGFAILURE
(
SET_COOKIE
aHostURI
savedCookieHeader
"
failed
the
samesite
tests
"
)
;
CookieLogging
:
:
LogMessageToConsole
(
aCRC
aHostURI
nsIScriptError
:
:
warningFlag
CONSOLE_SAMESITE_CATEGORY
"
CookieRejectedForNonSameSiteness
"
_ns
AutoTArray
<
nsString
1
>
{
NS_ConvertUTF8toUTF16
(
aCookieData
.
name
(
)
)
}
)
;
return
newCookie
;
}
aSetCookie
=
true
;
return
newCookie
;
}
static
inline
bool
isnull
(
char
c
)
{
return
c
=
=
0
;
}
static
inline
bool
iswhitespace
(
char
c
)
{
return
c
=
=
'
'
|
|
c
=
=
'
\
t
'
;
}
static
inline
bool
isterminator
(
char
c
)
{
return
c
=
=
'
\
n
'
|
|
c
=
=
'
\
r
'
;
}
static
inline
bool
isvalueseparator
(
char
c
)
{
return
isterminator
(
c
)
|
|
c
=
=
'
;
'
;
}
static
inline
bool
istokenseparator
(
char
c
)
{
return
isvalueseparator
(
c
)
|
|
c
=
=
'
=
'
;
}
bool
CookieService
:
:
GetTokenValue
(
nsACString
:
:
const_char_iterator
&
aIter
nsACString
:
:
const_char_iterator
&
aEndIter
nsDependentCSubstring
&
aTokenString
nsDependentCSubstring
&
aTokenValue
bool
&
aEqualsFound
)
{
nsACString
:
:
const_char_iterator
start
;
nsACString
:
:
const_char_iterator
lastSpace
;
aTokenValue
.
Rebind
(
aIter
aIter
)
;
while
(
aIter
!
=
aEndIter
&
&
iswhitespace
(
*
aIter
)
)
{
+
+
aIter
;
}
start
=
aIter
;
while
(
aIter
!
=
aEndIter
&
&
!
isnull
(
*
aIter
)
&
&
!
istokenseparator
(
*
aIter
)
)
{
+
+
aIter
;
}
lastSpace
=
aIter
;
if
(
lastSpace
!
=
start
)
{
while
(
-
-
lastSpace
!
=
start
&
&
iswhitespace
(
*
lastSpace
)
)
{
}
+
+
lastSpace
;
}
aTokenString
.
Rebind
(
start
lastSpace
)
;
aEqualsFound
=
(
*
aIter
=
=
'
=
'
)
;
if
(
aEqualsFound
)
{
while
(
+
+
aIter
!
=
aEndIter
&
&
iswhitespace
(
*
aIter
)
)
{
}
start
=
aIter
;
while
(
aIter
!
=
aEndIter
&
&
!
isnull
(
*
aIter
)
&
&
!
isvalueseparator
(
*
aIter
)
)
{
+
+
aIter
;
}
if
(
aIter
!
=
start
)
{
lastSpace
=
aIter
;
while
(
-
-
lastSpace
!
=
start
&
&
iswhitespace
(
*
lastSpace
)
)
{
}
aTokenValue
.
Rebind
(
start
+
+
lastSpace
)
;
}
}
if
(
aIter
!
=
aEndIter
)
{
if
(
isterminator
(
*
aIter
)
)
{
+
+
aIter
;
return
true
;
}
+
+
aIter
;
}
return
false
;
}
static
inline
void
SetSameSiteAttributeDefault
(
CookieStruct
&
aCookieData
)
{
aCookieData
.
sameSite
(
)
=
nsICookie
:
:
SAMESITE_LAX
;
aCookieData
.
rawSameSite
(
)
=
nsICookie
:
:
SAMESITE_NONE
;
}
static
inline
void
SetSameSiteAttribute
(
CookieStruct
&
aCookieData
int32_t
aValue
)
{
aCookieData
.
sameSite
(
)
=
aValue
;
aCookieData
.
rawSameSite
(
)
=
aValue
;
}
bool
CookieService
:
:
ParseAttributes
(
nsIConsoleReportCollector
*
aCRC
nsIURI
*
aHostURI
nsCString
&
aCookieHeader
CookieStruct
&
aCookieData
nsACString
&
aExpires
nsACString
&
aMaxage
bool
&
aAcceptedByParser
)
{
aAcceptedByParser
=
false
;
static
const
char
kPath
[
]
=
"
path
"
;
static
const
char
kDomain
[
]
=
"
domain
"
;
static
const
char
kExpires
[
]
=
"
expires
"
;
static
const
char
kMaxage
[
]
=
"
max
-
age
"
;
static
const
char
kSecure
[
]
=
"
secure
"
;
static
const
char
kHttpOnly
[
]
=
"
httponly
"
;
static
const
char
kSameSite
[
]
=
"
samesite
"
;
static
const
char
kSameSiteLax
[
]
=
"
lax
"
;
static
const
char
kSameSiteNone
[
]
=
"
none
"
;
static
const
char
kSameSiteStrict
[
]
=
"
strict
"
;
nsACString
:
:
const_char_iterator
cookieStart
;
aCookieHeader
.
BeginReading
(
cookieStart
)
;
nsACString
:
:
const_char_iterator
cookieEnd
;
aCookieHeader
.
EndReading
(
cookieEnd
)
;
aCookieData
.
isSecure
(
)
=
false
;
aCookieData
.
isHttpOnly
(
)
=
false
;
SetSameSiteAttributeDefault
(
aCookieData
)
;
nsDependentCSubstring
tokenString
(
cookieStart
cookieStart
)
;
nsDependentCSubstring
tokenValue
(
cookieStart
cookieStart
)
;
bool
newCookie
;
bool
equalsFound
;
newCookie
=
GetTokenValue
(
cookieStart
cookieEnd
tokenString
tokenValue
equalsFound
)
;
if
(
equalsFound
)
{
aCookieData
.
name
(
)
=
tokenString
;
aCookieData
.
value
(
)
=
tokenValue
;
}
else
{
aCookieData
.
value
(
)
=
tokenString
;
}
while
(
cookieStart
!
=
cookieEnd
&
&
!
newCookie
)
{
newCookie
=
GetTokenValue
(
cookieStart
cookieEnd
tokenString
tokenValue
equalsFound
)
;
if
(
tokenString
.
LowerCaseEqualsLiteral
(
kPath
)
)
{
aCookieData
.
path
(
)
=
tokenValue
;
}
else
if
(
tokenString
.
LowerCaseEqualsLiteral
(
kDomain
)
)
{
aCookieData
.
host
(
)
=
tokenValue
;
}
else
if
(
tokenString
.
LowerCaseEqualsLiteral
(
kExpires
)
)
{
aExpires
=
tokenValue
;
}
else
if
(
tokenString
.
LowerCaseEqualsLiteral
(
kMaxage
)
)
{
aMaxage
=
tokenValue
;
}
else
if
(
tokenString
.
LowerCaseEqualsLiteral
(
kSecure
)
)
{
aCookieData
.
isSecure
(
)
=
true
;
}
else
if
(
tokenString
.
LowerCaseEqualsLiteral
(
kHttpOnly
)
)
{
aCookieData
.
isHttpOnly
(
)
=
true
;
}
else
if
(
tokenString
.
LowerCaseEqualsLiteral
(
kSameSite
)
)
{
if
(
tokenValue
.
LowerCaseEqualsLiteral
(
kSameSiteLax
)
)
{
SetSameSiteAttribute
(
aCookieData
nsICookie
:
:
SAMESITE_LAX
)
;
}
else
if
(
tokenValue
.
LowerCaseEqualsLiteral
(
kSameSiteStrict
)
)
{
SetSameSiteAttribute
(
aCookieData
nsICookie
:
:
SAMESITE_STRICT
)
;
}
else
if
(
tokenValue
.
LowerCaseEqualsLiteral
(
kSameSiteNone
)
)
{
SetSameSiteAttribute
(
aCookieData
nsICookie
:
:
SAMESITE_NONE
)
;
}
else
{
SetSameSiteAttributeDefault
(
aCookieData
)
;
CookieLogging
:
:
LogMessageToConsole
(
aCRC
aHostURI
nsIScriptError
:
:
infoFlag
CONSOLE_SAMESITE_CATEGORY
"
CookieSameSiteValueInvalid2
"
_ns
AutoTArray
<
nsString
1
>
{
NS_ConvertUTF8toUTF16
(
aCookieData
.
name
(
)
)
}
)
;
}
}
}
aCookieHeader
.
Assign
(
Substring
(
cookieStart
cookieEnd
)
)
;
if
(
!
aCookieData
.
isSecure
(
)
&
&
aCookieData
.
sameSite
(
)
=
=
nsICookie
:
:
SAMESITE_NONE
)
{
if
(
StaticPrefs
:
:
network_cookie_sameSite_noneRequiresSecure
(
)
)
{
CookieLogging
:
:
LogMessageToConsole
(
aCRC
aHostURI
nsIScriptError
:
:
errorFlag
CONSOLE_SAMESITE_CATEGORY
"
CookieRejectedNonRequiresSecure2
"
_ns
AutoTArray
<
nsString
1
>
{
NS_ConvertUTF8toUTF16
(
aCookieData
.
name
(
)
)
}
)
;
return
newCookie
;
}
CookieLogging
:
:
LogMessageToConsole
(
aCRC
aHostURI
nsIScriptError
:
:
warningFlag
CONSOLE_SAMESITE_CATEGORY
"
CookieRejectedNonRequiresSecureForBeta3
"
_ns
AutoTArray
<
nsString
2
>
{
NS_ConvertUTF8toUTF16
(
aCookieData
.
name
(
)
)
SAMESITE_MDN_URL
}
)
;
}
if
(
aCookieData
.
rawSameSite
(
)
=
=
nsICookie
:
:
SAMESITE_NONE
&
&
aCookieData
.
sameSite
(
)
=
=
nsICookie
:
:
SAMESITE_LAX
)
{
bool
laxByDefault
=
StaticPrefs
:
:
network_cookie_sameSite_laxByDefault
(
)
&
&
!
nsContentUtils
:
:
IsURIInPrefList
(
aHostURI
"
network
.
cookie
.
sameSite
.
laxByDefault
.
disabledHosts
"
)
;
if
(
laxByDefault
)
{
CookieLogging
:
:
LogMessageToConsole
(
aCRC
aHostURI
nsIScriptError
:
:
infoFlag
CONSOLE_SAMESITE_CATEGORY
"
CookieLaxForced2
"
_ns
AutoTArray
<
nsString
1
>
{
NS_ConvertUTF8toUTF16
(
aCookieData
.
name
(
)
)
}
)
;
}
else
{
CookieLogging
:
:
LogMessageToConsole
(
aCRC
aHostURI
nsIScriptError
:
:
warningFlag
CONSOLE_SAMESITE_CATEGORY
"
CookieLaxForcedForBeta2
"
_ns
AutoTArray
<
nsString
2
>
{
NS_ConvertUTF8toUTF16
(
aCookieData
.
name
(
)
)
SAMESITE_MDN_URL
}
)
;
}
}
aAcceptedByParser
=
true
;
MOZ_ASSERT
(
Cookie
:
:
ValidateSameSite
(
aCookieData
)
)
;
return
newCookie
;
}
nsresult
CookieService
:
:
NormalizeHost
(
nsCString
&
aHost
)
{
if
(
!
IsAscii
(
aHost
)
)
{
nsAutoCString
host
;
nsresult
rv
=
mIDNService
-
>
ConvertUTF8toACE
(
aHost
host
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
aHost
=
host
;
}
ToLowerCase
(
aHost
)
;
return
NS_OK
;
}
static
inline
bool
IsSubdomainOf
(
const
nsACString
&
a
const
nsACString
&
b
)
{
if
(
a
=
=
b
)
{
return
true
;
}
if
(
a
.
Length
(
)
>
b
.
Length
(
)
)
{
return
a
[
a
.
Length
(
)
-
b
.
Length
(
)
-
1
]
=
=
'
.
'
&
&
StringEndsWith
(
a
b
)
;
}
return
false
;
}
CookieStatus
CookieService
:
:
CheckPrefs
(
nsIConsoleReportCollector
*
aCRC
nsICookieJarSettings
*
aCookieJarSettings
nsIURI
*
aHostURI
bool
aIsForeign
bool
aIsThirdPartyTrackingResource
bool
aIsThirdPartySocialTrackingResource
bool
aStorageAccessPermissionGranted
const
nsACString
&
aCookieHeader
const
int
aNumOfCookies
const
OriginAttributes
&
aOriginAttrs
uint32_t
*
aRejectedReason
)
{
nsresult
rv
;
MOZ_ASSERT
(
aRejectedReason
)
;
*
aRejectedReason
=
0
;
if
(
!
CookieCommons
:
:
IsSchemeSupported
(
aHostURI
)
)
{
COOKIE_LOGFAILURE
(
!
aCookieHeader
.
IsVoid
(
)
aHostURI
aCookieHeader
"
non
http
/
https
sites
cannot
read
cookies
"
)
;
return
STATUS_REJECTED_WITH_ERROR
;
}
nsCOMPtr
<
nsIPrincipal
>
principal
=
BasePrincipal
:
:
CreateContentPrincipal
(
aHostURI
aOriginAttrs
)
;
if
(
!
principal
)
{
COOKIE_LOGFAILURE
(
!
aCookieHeader
.
IsVoid
(
)
aHostURI
aCookieHeader
"
non
-
content
principals
cannot
get
/
set
cookies
"
)
;
return
STATUS_REJECTED_WITH_ERROR
;
}
uint32_t
cookiePermission
=
nsICookiePermission
:
:
ACCESS_DEFAULT
;
rv
=
aCookieJarSettings
-
>
CookiePermission
(
principal
&
cookiePermission
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
switch
(
cookiePermission
)
{
case
nsICookiePermission
:
:
ACCESS_DENY
:
COOKIE_LOGFAILURE
(
!
aCookieHeader
.
IsVoid
(
)
aHostURI
aCookieHeader
"
cookies
are
blocked
for
this
site
"
)
;
CookieLogging
:
:
LogMessageToConsole
(
aCRC
aHostURI
nsIScriptError
:
:
warningFlag
CONSOLE_REJECTION_CATEGORY
"
CookieRejectedByPermissionManager
"
_ns
AutoTArray
<
nsString
1
>
{
NS_ConvertUTF8toUTF16
(
aCookieHeader
)
}
)
;
*
aRejectedReason
=
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_BY_PERMISSION
;
return
STATUS_REJECTED
;
case
nsICookiePermission
:
:
ACCESS_ALLOW
:
return
STATUS_ACCEPTED
;
default
:
break
;
}
}
if
(
aIsForeign
&
&
aIsThirdPartyTrackingResource
&
&
!
aStorageAccessPermissionGranted
&
&
aCookieJarSettings
-
>
GetRejectThirdPartyContexts
(
)
)
{
bool
rejectThirdPartyWithExceptions
=
CookieJarSettings
:
:
IsRejectThirdPartyWithExceptions
(
aCookieJarSettings
-
>
GetCookieBehavior
(
)
)
;
uint32_t
rejectReason
=
rejectThirdPartyWithExceptions
?
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_FOREIGN
:
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_TRACKER
;
if
(
StoragePartitioningEnabled
(
rejectReason
aCookieJarSettings
)
)
{
MOZ_ASSERT
(
!
aOriginAttrs
.
mPartitionKey
.
IsEmpty
(
)
"
We
must
have
a
StoragePrincipal
here
!
"
)
;
return
STATUS_ACCEPTED
;
}
COOKIE_LOGFAILURE
(
!
aCookieHeader
.
IsVoid
(
)
aHostURI
aCookieHeader
"
cookies
are
disabled
in
trackers
"
)
;
if
(
aIsThirdPartySocialTrackingResource
)
{
*
aRejectedReason
=
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_SOCIALTRACKER
;
}
else
if
(
rejectThirdPartyWithExceptions
)
{
*
aRejectedReason
=
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_FOREIGN
;
}
else
{
*
aRejectedReason
=
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_TRACKER
;
}
return
STATUS_REJECTED
;
}
if
(
aCookieJarSettings
-
>
GetCookieBehavior
(
)
=
=
nsICookieService
:
:
BEHAVIOR_REJECT
&
&
!
aStorageAccessPermissionGranted
)
{
COOKIE_LOGFAILURE
(
!
aCookieHeader
.
IsVoid
(
)
aHostURI
aCookieHeader
"
cookies
are
disabled
"
)
;
*
aRejectedReason
=
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_ALL
;
return
STATUS_REJECTED
;
}
if
(
aIsForeign
)
{
if
(
aCookieJarSettings
-
>
GetCookieBehavior
(
)
=
=
nsICookieService
:
:
BEHAVIOR_REJECT_FOREIGN
&
&
!
aStorageAccessPermissionGranted
)
{
COOKIE_LOGFAILURE
(
!
aCookieHeader
.
IsVoid
(
)
aHostURI
aCookieHeader
"
context
is
third
party
"
)
;
CookieLogging
:
:
LogMessageToConsole
(
aCRC
aHostURI
nsIScriptError
:
:
warningFlag
CONSOLE_REJECTION_CATEGORY
"
CookieRejectedThirdParty
"
_ns
AutoTArray
<
nsString
1
>
{
NS_ConvertUTF8toUTF16
(
aCookieHeader
)
}
)
;
*
aRejectedReason
=
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_FOREIGN
;
return
STATUS_REJECTED
;
}
if
(
aCookieJarSettings
-
>
GetLimitForeignContexts
(
)
&
&
!
aStorageAccessPermissionGranted
&
&
aNumOfCookies
=
=
0
)
{
COOKIE_LOGFAILURE
(
!
aCookieHeader
.
IsVoid
(
)
aHostURI
aCookieHeader
"
context
is
third
party
"
)
;
CookieLogging
:
:
LogMessageToConsole
(
aCRC
aHostURI
nsIScriptError
:
:
warningFlag
CONSOLE_REJECTION_CATEGORY
"
CookieRejectedThirdParty
"
_ns
AutoTArray
<
nsString
1
>
{
NS_ConvertUTF8toUTF16
(
aCookieHeader
)
}
)
;
*
aRejectedReason
=
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_FOREIGN
;
return
STATUS_REJECTED
;
}
if
(
StaticPrefs
:
:
network_cookie_thirdparty_sessionOnly
(
)
)
{
return
STATUS_ACCEPT_SESSION
;
}
if
(
StaticPrefs
:
:
network_cookie_thirdparty_nonsecureSessionOnly
(
)
)
{
if
(
!
aHostURI
-
>
SchemeIs
(
"
https
"
)
)
{
return
STATUS_ACCEPT_SESSION
;
}
}
}
return
STATUS_ACCEPTED
;
}
bool
CookieService
:
:
CheckDomain
(
CookieStruct
&
aCookieData
nsIURI
*
aHostURI
const
nsACString
&
aBaseDomain
bool
aRequireHostMatch
)
{
nsAutoCString
hostFromURI
;
nsContentUtils
:
:
GetHostOrIPv6WithBrackets
(
aHostURI
hostFromURI
)
;
if
(
!
aCookieData
.
host
(
)
.
IsEmpty
(
)
)
{
if
(
aCookieData
.
host
(
)
.
Length
(
)
>
1
&
&
aCookieData
.
host
(
)
.
First
(
)
=
=
'
.
'
)
{
aCookieData
.
host
(
)
.
Cut
(
0
1
)
;
}
ToLowerCase
(
aCookieData
.
host
(
)
)
;
if
(
aRequireHostMatch
)
{
return
hostFromURI
.
Equals
(
aCookieData
.
host
(
)
)
;
}
if
(
IsSubdomainOf
(
aCookieData
.
host
(
)
aBaseDomain
)
&
&
IsSubdomainOf
(
hostFromURI
aCookieData
.
host
(
)
)
)
{
aCookieData
.
host
(
)
.
InsertLiteral
(
"
.
"
0
)
;
return
true
;
}
return
false
;
}
aCookieData
.
host
(
)
=
hostFromURI
;
return
true
;
}
namespace
{
nsAutoCString
GetPathFromURI
(
nsIURI
*
aHostURI
)
{
nsAutoCString
path
;
nsCOMPtr
<
nsIURL
>
hostURL
=
do_QueryInterface
(
aHostURI
)
;
if
(
hostURL
)
{
hostURL
-
>
GetDirectory
(
path
)
;
}
else
{
aHostURI
-
>
GetPathQueryRef
(
path
)
;
int32_t
slash
=
path
.
RFindChar
(
'
/
'
)
;
if
(
slash
!
=
kNotFound
)
{
path
.
Truncate
(
slash
+
1
)
;
}
}
int32_t
lastSlash
=
path
.
RFindChar
(
'
/
'
)
;
int32_t
firstSlash
=
path
.
FindChar
(
'
/
'
)
;
if
(
lastSlash
!
=
firstSlash
&
&
lastSlash
!
=
kNotFound
&
&
lastSlash
=
=
static_cast
<
int32_t
>
(
path
.
Length
(
)
-
1
)
)
{
path
.
Truncate
(
lastSlash
)
;
}
return
path
;
}
}
bool
CookieService
:
:
CheckPath
(
CookieStruct
&
aCookieData
nsIConsoleReportCollector
*
aCRC
nsIURI
*
aHostURI
)
{
if
(
aCookieData
.
path
(
)
.
IsEmpty
(
)
|
|
aCookieData
.
path
(
)
.
First
(
)
!
=
'
/
'
)
{
aCookieData
.
path
(
)
=
GetPathFromURI
(
aHostURI
)
;
#
if
0
}
else
{
nsAutoCString
pathFromURI
;
if
(
NS_FAILED
(
aHostURI
-
>
GetPathQueryRef
(
pathFromURI
)
)
|
|
!
StringBeginsWith
(
pathFromURI
aCookieData
.
path
(
)
)
)
{
return
false
;
}
#
endif
}
if
(
!
CookieCommons
:
:
CheckPathSize
(
aCookieData
)
)
{
AutoTArray
<
nsString
2
>
params
=
{
NS_ConvertUTF8toUTF16
(
aCookieData
.
name
(
)
)
}
;
nsString
size
;
size
.
AppendInt
(
kMaxBytesPerPath
)
;
params
.
AppendElement
(
size
)
;
CookieLogging
:
:
LogMessageToConsole
(
aCRC
aHostURI
nsIScriptError
:
:
warningFlag
CONSOLE_OVERSIZE_CATEGORY
"
CookiePathOversize
"
_ns
params
)
;
return
false
;
}
return
!
aCookieData
.
path
(
)
.
Contains
(
'
\
t
'
)
;
}
bool
CookieService
:
:
CheckPrefixes
(
CookieStruct
&
aCookieData
bool
aSecureRequest
)
{
static
const
char
kSecure
[
]
=
"
__Secure
-
"
;
static
const
char
kHost
[
]
=
"
__Host
-
"
;
static
const
int
kSecureLen
=
sizeof
(
kSecure
)
-
1
;
static
const
int
kHostLen
=
sizeof
(
kHost
)
-
1
;
bool
isSecure
=
strncmp
(
aCookieData
.
name
(
)
.
get
(
)
kSecure
kSecureLen
)
=
=
0
;
bool
isHost
=
strncmp
(
aCookieData
.
name
(
)
.
get
(
)
kHost
kHostLen
)
=
=
0
;
if
(
!
isSecure
&
&
!
isHost
)
{
return
true
;
}
if
(
!
aSecureRequest
|
|
!
aCookieData
.
isSecure
(
)
)
{
return
false
;
}
if
(
isHost
)
{
if
(
aCookieData
.
host
(
)
[
0
]
=
=
'
.
'
|
|
!
aCookieData
.
path
(
)
.
EqualsLiteral
(
"
/
"
)
)
{
return
false
;
}
}
return
true
;
}
bool
CookieService
:
:
GetExpiry
(
CookieStruct
&
aCookieData
const
nsACString
&
aExpires
const
nsACString
&
aMaxage
int64_t
aCurrentTime
bool
aFromHttp
)
{
int64_t
maxageCap
=
aFromHttp
?
0
:
StaticPrefs
:
:
privacy_documentCookies_maxage
(
)
;
if
(
!
aMaxage
.
IsEmpty
(
)
)
{
int64_t
maxage
;
int32_t
numInts
=
PR_sscanf
(
aMaxage
.
BeginReading
(
)
"
%
lld
"
&
maxage
)
;
if
(
numInts
!
=
1
)
{
return
true
;
}
if
(
maxageCap
)
{
aCookieData
.
expiry
(
)
=
aCurrentTime
+
std
:
:
min
(
maxage
maxageCap
)
;
}
else
{
aCookieData
.
expiry
(
)
=
aCurrentTime
+
maxage
;
}
}
else
if
(
!
aExpires
.
IsEmpty
(
)
)
{
PRTime
expires
;
if
(
PR_ParseTimeString
(
aExpires
.
BeginReading
(
)
true
&
expires
)
!
=
PR_SUCCESS
)
{
return
true
;
}
if
(
maxageCap
)
{
aCookieData
.
expiry
(
)
=
std
:
:
min
(
expires
/
int64_t
(
PR_USEC_PER_SEC
)
aCurrentTime
+
maxageCap
)
;
}
else
{
aCookieData
.
expiry
(
)
=
expires
/
int64_t
(
PR_USEC_PER_SEC
)
;
}
}
else
{
return
true
;
}
return
false
;
}
NS_IMETHODIMP
CookieService
:
:
CookieExists
(
const
nsACString
&
aHost
const
nsACString
&
aPath
const
nsACString
&
aName
JS
:
:
Handle
<
JS
:
:
Value
>
aOriginAttributes
JSContext
*
aCx
bool
*
aFoundCookie
)
{
NS_ENSURE_ARG_POINTER
(
aCx
)
;
NS_ENSURE_ARG_POINTER
(
aFoundCookie
)
;
OriginAttributes
attrs
;
if
(
!
aOriginAttributes
.
isObject
(
)
|
|
!
attrs
.
Init
(
aCx
aOriginAttributes
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
return
CookieExistsNative
(
aHost
aPath
aName
&
attrs
aFoundCookie
)
;
}
NS_IMETHODIMP_
(
nsresult
)
CookieService
:
:
CookieExistsNative
(
const
nsACString
&
aHost
const
nsACString
&
aPath
const
nsACString
&
aName
OriginAttributes
*
aOriginAttributes
bool
*
aFoundCookie
)
{
nsCOMPtr
<
nsICookie
>
cookie
;
nsresult
rv
=
GetCookieNative
(
aHost
aPath
aName
aOriginAttributes
getter_AddRefs
(
cookie
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
*
aFoundCookie
=
cookie
!
=
nullptr
;
return
NS_OK
;
}
NS_IMETHODIMP_
(
nsresult
)
CookieService
:
:
GetCookieNative
(
const
nsACString
&
aHost
const
nsACString
&
aPath
const
nsACString
&
aName
OriginAttributes
*
aOriginAttributes
nsICookie
*
*
aCookie
)
{
NS_ENSURE_ARG_POINTER
(
aOriginAttributes
)
;
NS_ENSURE_ARG_POINTER
(
aCookie
)
;
if
(
!
IsInitialized
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsAutoCString
baseDomain
;
nsresult
rv
=
CookieCommons
:
:
GetBaseDomainFromHost
(
mTLDService
aHost
baseDomain
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
CookieListIter
iter
{
}
;
CookieStorage
*
storage
=
PickStorage
(
*
aOriginAttributes
)
;
bool
foundCookie
=
storage
-
>
FindCookie
(
baseDomain
*
aOriginAttributes
aHost
aName
aPath
iter
)
;
if
(
foundCookie
)
{
RefPtr
<
Cookie
>
cookie
=
iter
.
Cookie
(
)
;
NS_ENSURE_TRUE
(
cookie
NS_ERROR_NULL_POINTER
)
;
cookie
.
forget
(
aCookie
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
CookieService
:
:
CountCookiesFromHost
(
const
nsACString
&
aHost
uint32_t
*
aCountFromHost
)
{
nsAutoCString
host
(
aHost
)
;
nsresult
rv
=
NormalizeHost
(
host
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
baseDomain
;
rv
=
CookieCommons
:
:
GetBaseDomainFromHost
(
mTLDService
host
baseDomain
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
IsInitialized
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
mPersistentStorage
-
>
EnsureInitialized
(
)
;
*
aCountFromHost
=
mPersistentStorage
-
>
CountCookiesFromHost
(
baseDomain
0
)
;
return
NS_OK
;
}
NS_IMETHODIMP
CookieService
:
:
GetCookiesFromHost
(
const
nsACString
&
aHost
JS
:
:
Handle
<
JS
:
:
Value
>
aOriginAttributes
JSContext
*
aCx
nsTArray
<
RefPtr
<
nsICookie
>
>
&
aResult
)
{
nsAutoCString
host
(
aHost
)
;
nsresult
rv
=
NormalizeHost
(
host
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
baseDomain
;
rv
=
CookieCommons
:
:
GetBaseDomainFromHost
(
mTLDService
host
baseDomain
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
OriginAttributes
attrs
;
if
(
!
aOriginAttributes
.
isObject
(
)
|
|
!
attrs
.
Init
(
aCx
aOriginAttributes
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
!
IsInitialized
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
CookieStorage
*
storage
=
PickStorage
(
attrs
)
;
const
nsTArray
<
RefPtr
<
Cookie
>
>
*
cookies
=
storage
-
>
GetCookiesFromHost
(
baseDomain
attrs
)
;
if
(
cookies
)
{
aResult
.
SetCapacity
(
cookies
-
>
Length
(
)
)
;
for
(
Cookie
*
cookie
:
*
cookies
)
{
aResult
.
AppendElement
(
cookie
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
CookieService
:
:
GetCookiesWithOriginAttributes
(
const
nsAString
&
aPattern
const
nsACString
&
aHost
nsTArray
<
RefPtr
<
nsICookie
>
>
&
aResult
)
{
OriginAttributesPattern
pattern
;
if
(
!
pattern
.
Init
(
aPattern
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsAutoCString
host
(
aHost
)
;
nsresult
rv
=
NormalizeHost
(
host
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
baseDomain
;
rv
=
CookieCommons
:
:
GetBaseDomainFromHost
(
mTLDService
host
baseDomain
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
GetCookiesWithOriginAttributes
(
pattern
baseDomain
aResult
)
;
}
nsresult
CookieService
:
:
GetCookiesWithOriginAttributes
(
const
OriginAttributesPattern
&
aPattern
const
nsCString
&
aBaseDomain
nsTArray
<
RefPtr
<
nsICookie
>
>
&
aResult
)
{
CookieStorage
*
storage
=
PickStorage
(
aPattern
)
;
storage
-
>
GetCookiesWithOriginAttributes
(
aPattern
aBaseDomain
aResult
)
;
return
NS_OK
;
}
NS_IMETHODIMP
CookieService
:
:
RemoveCookiesWithOriginAttributes
(
const
nsAString
&
aPattern
const
nsACString
&
aHost
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
OriginAttributesPattern
pattern
;
if
(
!
pattern
.
Init
(
aPattern
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsAutoCString
host
(
aHost
)
;
nsresult
rv
=
NormalizeHost
(
host
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
baseDomain
;
rv
=
CookieCommons
:
:
GetBaseDomainFromHost
(
mTLDService
host
baseDomain
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
RemoveCookiesWithOriginAttributes
(
pattern
baseDomain
)
;
}
nsresult
CookieService
:
:
RemoveCookiesWithOriginAttributes
(
const
OriginAttributesPattern
&
aPattern
const
nsCString
&
aBaseDomain
)
{
if
(
!
IsInitialized
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
CookieStorage
*
storage
=
PickStorage
(
aPattern
)
;
storage
-
>
RemoveCookiesWithOriginAttributes
(
aPattern
aBaseDomain
)
;
return
NS_OK
;
}
NS_IMETHODIMP
CookieService
:
:
RemoveCookiesFromExactHost
(
const
nsACString
&
aHost
const
nsAString
&
aPattern
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
OriginAttributesPattern
pattern
;
if
(
!
pattern
.
Init
(
aPattern
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
return
RemoveCookiesFromExactHost
(
aHost
pattern
)
;
}
nsresult
CookieService
:
:
RemoveCookiesFromExactHost
(
const
nsACString
&
aHost
const
OriginAttributesPattern
&
aPattern
)
{
nsAutoCString
host
(
aHost
)
;
nsresult
rv
=
NormalizeHost
(
host
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
baseDomain
;
rv
=
CookieCommons
:
:
GetBaseDomainFromHost
(
mTLDService
host
baseDomain
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
IsInitialized
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
CookieStorage
*
storage
=
PickStorage
(
aPattern
)
;
storage
-
>
RemoveCookiesFromExactHost
(
aHost
baseDomain
aPattern
)
;
return
NS_OK
;
}
namespace
{
class
RemoveAllSinceRunnable
:
public
Runnable
{
public
:
using
CookieArray
=
nsTArray
<
RefPtr
<
nsICookie
>
>
;
RemoveAllSinceRunnable
(
Promise
*
aPromise
CookieService
*
aSelf
CookieArray
&
&
aCookieArray
int64_t
aSinceWhen
)
:
Runnable
(
"
RemoveAllSinceRunnable
"
)
mPromise
(
aPromise
)
mSelf
(
aSelf
)
mList
(
std
:
:
move
(
aCookieArray
)
)
mIndex
(
0
)
mSinceWhen
(
aSinceWhen
)
{
}
NS_IMETHODIMP
Run
(
)
override
{
RemoveSome
(
)
;
if
(
mIndex
<
mList
.
Length
(
)
)
{
return
NS_DispatchToCurrentThread
(
this
)
;
}
mPromise
-
>
MaybeResolveWithUndefined
(
)
;
return
NS_OK
;
}
private
:
void
RemoveSome
(
)
{
for
(
CookieArray
:
:
size_type
iter
=
0
;
iter
<
kYieldPeriod
&
&
mIndex
<
mList
.
Length
(
)
;
+
+
mIndex
+
+
iter
)
{
auto
*
cookie
=
static_cast
<
Cookie
*
>
(
mList
[
mIndex
]
.
get
(
)
)
;
if
(
cookie
-
>
CreationTime
(
)
>
mSinceWhen
&
&
NS_FAILED
(
mSelf
-
>
Remove
(
cookie
-
>
Host
(
)
cookie
-
>
OriginAttributesRef
(
)
cookie
-
>
Name
(
)
cookie
-
>
Path
(
)
)
)
)
{
continue
;
}
}
}
private
:
RefPtr
<
Promise
>
mPromise
;
RefPtr
<
CookieService
>
mSelf
;
CookieArray
mList
;
CookieArray
:
:
size_type
mIndex
;
int64_t
mSinceWhen
;
static
const
CookieArray
:
:
size_type
kYieldPeriod
=
10
;
}
;
}
NS_IMETHODIMP
CookieService
:
:
RemoveAllSince
(
int64_t
aSinceWhen
JSContext
*
aCx
Promise
*
*
aRetVal
)
{
nsIGlobalObject
*
globalObject
=
xpc
:
:
CurrentNativeGlobal
(
aCx
)
;
if
(
NS_WARN_IF
(
!
globalObject
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
ErrorResult
result
;
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
globalObject
result
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
return
result
.
StealNSResult
(
)
;
}
mPersistentStorage
-
>
EnsureInitialized
(
)
;
nsTArray
<
RefPtr
<
nsICookie
>
>
cookieList
;
mPersistentStorage
-
>
GetAll
(
cookieList
)
;
RefPtr
<
RemoveAllSinceRunnable
>
runMe
=
new
RemoveAllSinceRunnable
(
promise
this
std
:
:
move
(
cookieList
)
aSinceWhen
)
;
promise
.
forget
(
aRetVal
)
;
return
runMe
-
>
Run
(
)
;
}
namespace
{
class
CompareCookiesCreationTime
{
public
:
static
bool
Equals
(
const
nsICookie
*
aCookie1
const
nsICookie
*
aCookie2
)
{
return
static_cast
<
const
Cookie
*
>
(
aCookie1
)
-
>
CreationTime
(
)
=
=
static_cast
<
const
Cookie
*
>
(
aCookie2
)
-
>
CreationTime
(
)
;
}
static
bool
LessThan
(
const
nsICookie
*
aCookie1
const
nsICookie
*
aCookie2
)
{
return
static_cast
<
const
Cookie
*
>
(
aCookie1
)
-
>
CreationTime
(
)
<
static_cast
<
const
Cookie
*
>
(
aCookie2
)
-
>
CreationTime
(
)
;
}
}
;
}
NS_IMETHODIMP
CookieService
:
:
GetCookiesSince
(
int64_t
aSinceWhen
nsTArray
<
RefPtr
<
nsICookie
>
>
&
aResult
)
{
if
(
!
IsInitialized
(
)
)
{
return
NS_OK
;
}
mPersistentStorage
-
>
EnsureInitialized
(
)
;
nsTArray
<
RefPtr
<
nsICookie
>
>
cookieList
;
mPersistentStorage
-
>
GetAll
(
cookieList
)
;
for
(
RefPtr
<
nsICookie
>
&
cookie
:
cookieList
)
{
if
(
static_cast
<
Cookie
*
>
(
cookie
.
get
(
)
)
-
>
CreationTime
(
)
>
=
aSinceWhen
)
{
aResult
.
AppendElement
(
cookie
)
;
}
}
aResult
.
Sort
(
CompareCookiesCreationTime
(
)
)
;
return
NS_OK
;
}
size_t
CookieService
:
:
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
aMallocSizeOf
(
this
)
;
if
(
mPersistentStorage
)
{
n
+
=
mPersistentStorage
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
if
(
mPrivateStorage
)
{
n
+
=
mPrivateStorage
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
return
n
;
}
MOZ_DEFINE_MALLOC_SIZE_OF
(
CookieServiceMallocSizeOf
)
NS_IMETHODIMP
CookieService
:
:
CollectReports
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
bool
)
{
MOZ_COLLECT_REPORT
(
"
explicit
/
cookie
-
service
"
KIND_HEAP
UNITS_BYTES
SizeOfIncludingThis
(
CookieServiceMallocSizeOf
)
"
Memory
used
by
the
cookie
service
.
"
)
;
return
NS_OK
;
}
bool
CookieService
:
:
IsInitialized
(
)
const
{
if
(
!
mPersistentStorage
)
{
NS_WARNING
(
"
No
CookieStorage
!
Profile
already
close
?
"
)
;
return
false
;
}
MOZ_ASSERT
(
mPrivateStorage
)
;
return
true
;
}
CookieStorage
*
CookieService
:
:
PickStorage
(
const
OriginAttributes
&
aAttrs
)
{
MOZ_ASSERT
(
IsInitialized
(
)
)
;
if
(
aAttrs
.
mPrivateBrowsingId
>
0
)
{
return
mPrivateStorage
;
}
mPersistentStorage
-
>
EnsureInitialized
(
)
;
return
mPersistentStorage
;
}
CookieStorage
*
CookieService
:
:
PickStorage
(
const
OriginAttributesPattern
&
aAttrs
)
{
MOZ_ASSERT
(
IsInitialized
(
)
)
;
if
(
aAttrs
.
mPrivateBrowsingId
.
WasPassed
(
)
&
&
aAttrs
.
mPrivateBrowsingId
.
Value
(
)
>
0
)
{
return
mPrivateStorage
;
}
mPersistentStorage
-
>
EnsureInitialized
(
)
;
return
mPersistentStorage
;
}
bool
CookieService
:
:
SetCookiesFromIPC
(
const
nsACString
&
aBaseDomain
const
OriginAttributes
&
aAttrs
nsIURI
*
aHostURI
bool
aFromHttp
const
nsTArray
<
CookieStruct
>
&
aCookies
)
{
if
(
!
IsInitialized
(
)
)
{
return
true
;
}
CookieStorage
*
storage
=
PickStorage
(
aAttrs
)
;
int64_t
currentTimeInUsec
=
PR_Now
(
)
;
for
(
const
CookieStruct
&
cookieData
:
aCookies
)
{
if
(
!
CookieCommons
:
:
CheckPathSize
(
cookieData
)
)
{
return
false
;
}
if
(
!
CookieCommons
:
:
CheckNameAndValueSize
(
cookieData
)
)
{
return
false
;
}
if
(
!
CookieCommons
:
:
CheckName
(
cookieData
)
)
{
return
false
;
}
if
(
aFromHttp
&
&
!
CookieCommons
:
:
CheckHttpValue
(
cookieData
)
)
{
return
false
;
}
RefPtr
<
Cookie
>
cookie
=
Cookie
:
:
Create
(
cookieData
aAttrs
)
;
if
(
!
cookie
)
{
continue
;
}
cookie
-
>
SetLastAccessed
(
currentTimeInUsec
)
;
cookie
-
>
SetCreationTime
(
Cookie
:
:
GenerateUniqueCreationTime
(
currentTimeInUsec
)
)
;
storage
-
>
AddCookie
(
nullptr
aBaseDomain
aAttrs
cookie
currentTimeInUsec
aHostURI
"
"
_ns
aFromHttp
)
;
}
return
true
;
}
}
}
