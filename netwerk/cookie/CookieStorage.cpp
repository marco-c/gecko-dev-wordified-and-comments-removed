#
include
"
Cookie
.
h
"
#
include
"
CookieCommons
.
h
"
#
include
"
CookieLogging
.
h
"
#
include
"
CookieParser
.
h
"
#
include
"
CookieNotification
.
h
"
#
include
"
mozilla
/
net
/
MozURL_ffi
.
h
"
#
include
"
CookieService
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsICookieNotification
.
h
"
#
include
"
CookieStorage
.
h
"
#
include
"
mozilla
/
dom
/
nsMixedContentBlocker
.
h
"
#
include
"
mozilla
/
glean
/
GleanMetrics
.
h
"
#
include
"
mozilla
/
StaticPrefs_network
.
h
"
#
include
"
nsIMutableArray
.
h
"
#
include
"
nsTPriorityQueue
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsIUserIdleService
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
prprf
.
h
"
#
include
"
nsIPrefService
.
h
"
#
undef
ADD_TEN_PERCENT
#
define
ADD_TEN_PERCENT
(
i
)
static_cast
<
uint32_t
>
(
(
i
)
+
(
i
)
/
10
)
#
undef
LIMIT
#
define
LIMIT
(
x
low
high
default
)
\
(
(
x
)
>
=
(
low
)
&
&
(
x
)
<
=
(
high
)
?
(
x
)
:
(
default
)
)
static
const
uint32_t
kChipsPartitionByteCapacityDefault
=
10240
;
namespace
mozilla
{
namespace
net
{
namespace
{
class
CompareCookiesByAge
{
public
:
static
bool
Equals
(
const
CookieListIter
&
a
const
CookieListIter
&
b
)
{
return
a
.
Cookie
(
)
-
>
LastAccessed
(
)
=
=
b
.
Cookie
(
)
-
>
LastAccessed
(
)
&
&
a
.
Cookie
(
)
-
>
CreationTime
(
)
=
=
b
.
Cookie
(
)
-
>
CreationTime
(
)
;
}
static
bool
LessThan
(
const
CookieListIter
&
a
const
CookieListIter
&
b
)
{
int64_t
result
=
a
.
Cookie
(
)
-
>
LastAccessed
(
)
-
b
.
Cookie
(
)
-
>
LastAccessed
(
)
;
if
(
result
!
=
0
)
{
return
result
<
0
;
}
return
a
.
Cookie
(
)
-
>
CreationTime
(
)
<
b
.
Cookie
(
)
-
>
CreationTime
(
)
;
}
}
;
class
CookieIterComparator
{
private
:
int64_t
mCurrentTime
;
public
:
explicit
CookieIterComparator
(
int64_t
aTime
)
:
mCurrentTime
(
aTime
)
{
}
bool
LessThan
(
const
CookieListIter
&
lhs
const
CookieListIter
&
rhs
)
{
bool
lExpired
=
lhs
.
Cookie
(
)
-
>
Expiry
(
)
<
=
mCurrentTime
;
bool
rExpired
=
rhs
.
Cookie
(
)
-
>
Expiry
(
)
<
=
mCurrentTime
;
if
(
lExpired
&
&
!
rExpired
)
{
return
true
;
}
if
(
!
lExpired
&
&
rExpired
)
{
return
false
;
}
return
mozilla
:
:
net
:
:
CompareCookiesByAge
:
:
LessThan
(
lhs
rhs
)
;
}
}
;
class
CompareCookiesByIndex
{
public
:
static
bool
Equals
(
const
CookieListIter
&
a
const
CookieListIter
&
b
)
{
NS_ASSERTION
(
a
.
entry
!
=
b
.
entry
|
|
a
.
index
!
=
b
.
index
"
cookie
indexes
should
never
be
equal
"
)
;
return
false
;
}
static
bool
LessThan
(
const
CookieListIter
&
a
const
CookieListIter
&
b
)
{
if
(
a
.
entry
!
=
b
.
entry
)
{
return
a
.
entry
<
b
.
entry
;
}
return
a
.
index
<
b
.
index
;
}
}
;
}
size_t
CookieEntry
:
:
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
amount
=
CookieKey
:
:
SizeOfExcludingThis
(
aMallocSizeOf
)
;
amount
+
=
mCookies
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
for
(
uint32_t
i
=
0
;
i
<
mCookies
.
Length
(
)
;
+
+
i
)
{
amount
+
=
mCookies
[
i
]
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
return
amount
;
}
bool
CookieEntry
:
:
IsPartitioned
(
)
const
{
return
!
mOriginAttributes
.
mPartitionKey
.
IsEmpty
(
)
;
}
NS_IMPL_ISUPPORTS
(
CookieStorage
nsIObserver
nsISupportsWeakReference
)
void
CookieStorage
:
:
Init
(
)
{
nsCOMPtr
<
nsIPrefBranch
>
prefBranch
=
do_GetService
(
NS_PREFSERVICE_CONTRACTID
)
;
if
(
prefBranch
)
{
prefBranch
-
>
AddObserver
(
kPrefMaxNumberOfCookies
this
true
)
;
prefBranch
-
>
AddObserver
(
kPrefMaxCookiesPerHost
this
true
)
;
prefBranch
-
>
AddObserver
(
kPrefCookiePurgeAge
this
true
)
;
PrefChanged
(
prefBranch
)
;
}
nsCOMPtr
<
nsIObserverService
>
observerService
=
services
:
:
GetObserverService
(
)
;
NS_ENSURE_TRUE_VOID
(
observerService
)
;
nsresult
rv
=
observerService
-
>
AddObserver
(
this
OBSERVER_TOPIC_IDLE_DAILY
true
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
}
size_t
CookieStorage
:
:
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
amount
=
0
;
amount
+
=
aMallocSizeOf
(
this
)
;
amount
+
=
mHostTable
.
SizeOfExcludingThis
(
aMallocSizeOf
)
;
return
amount
;
}
void
CookieStorage
:
:
GetCookies
(
nsTArray
<
RefPtr
<
nsICookie
>
>
&
aCookies
)
const
{
aCookies
.
SetCapacity
(
mCookieCount
)
;
for
(
const
auto
&
entry
:
mHostTable
)
{
const
CookieEntry
:
:
ArrayType
&
cookies
=
entry
.
GetCookies
(
)
;
for
(
CookieEntry
:
:
IndexType
i
=
0
;
i
<
cookies
.
Length
(
)
;
+
+
i
)
{
aCookies
.
AppendElement
(
cookies
[
i
]
)
;
}
}
}
void
CookieStorage
:
:
GetSessionCookies
(
nsTArray
<
RefPtr
<
nsICookie
>
>
&
aCookies
)
const
{
aCookies
.
SetCapacity
(
mCookieCount
)
;
for
(
const
auto
&
entry
:
mHostTable
)
{
const
CookieEntry
:
:
ArrayType
&
cookies
=
entry
.
GetCookies
(
)
;
for
(
CookieEntry
:
:
IndexType
i
=
0
;
i
<
cookies
.
Length
(
)
;
+
+
i
)
{
Cookie
*
cookie
=
cookies
[
i
]
;
if
(
cookie
-
>
IsSession
(
)
)
{
aCookies
.
AppendElement
(
cookie
)
;
}
}
}
}
bool
CookieStorage
:
:
FindCookie
(
const
nsACString
&
aBaseDomain
const
OriginAttributes
&
aOriginAttributes
const
nsACString
&
aHost
const
nsACString
&
aName
const
nsACString
&
aPath
CookieListIter
&
aIter
)
{
CookieEntry
*
entry
=
mHostTable
.
GetEntry
(
CookieKey
(
aBaseDomain
aOriginAttributes
)
)
;
if
(
!
entry
)
{
return
false
;
}
const
CookieEntry
:
:
ArrayType
&
cookies
=
entry
-
>
GetCookies
(
)
;
for
(
CookieEntry
:
:
IndexType
i
=
0
;
i
<
cookies
.
Length
(
)
;
+
+
i
)
{
Cookie
*
cookie
=
cookies
[
i
]
;
if
(
aHost
.
Equals
(
cookie
-
>
Host
(
)
)
&
&
aPath
.
Equals
(
cookie
-
>
Path
(
)
)
&
&
aName
.
Equals
(
cookie
-
>
Name
(
)
)
)
{
aIter
=
CookieListIter
(
entry
i
)
;
return
true
;
}
}
return
false
;
}
bool
CookieStorage
:
:
FindSecureCookie
(
const
nsACString
&
aBaseDomain
const
OriginAttributes
&
aOriginAttributes
Cookie
*
aCookie
)
{
CookieEntry
*
entry
=
mHostTable
.
GetEntry
(
CookieKey
(
aBaseDomain
aOriginAttributes
)
)
;
if
(
!
entry
)
{
return
false
;
}
const
CookieEntry
:
:
ArrayType
&
cookies
=
entry
-
>
GetCookies
(
)
;
for
(
CookieEntry
:
:
IndexType
i
=
0
;
i
<
cookies
.
Length
(
)
;
+
+
i
)
{
Cookie
*
cookie
=
cookies
[
i
]
;
if
(
!
cookie
-
>
IsSecure
(
)
|
|
!
aCookie
-
>
Name
(
)
.
Equals
(
cookie
-
>
Name
(
)
)
)
{
continue
;
}
if
(
CookieCommons
:
:
DomainMatches
(
cookie
aCookie
-
>
Host
(
)
)
|
|
CookieCommons
:
:
DomainMatches
(
aCookie
cookie
-
>
Host
(
)
)
)
{
if
(
CookieCommons
:
:
PathMatches
(
cookie
aCookie
-
>
Path
(
)
)
)
{
return
true
;
}
}
}
return
false
;
}
uint32_t
CookieStorage
:
:
CountCookiesFromHost
(
const
nsACString
&
aBaseDomain
uint32_t
aPrivateBrowsingId
)
{
OriginAttributes
attrs
;
attrs
.
mPrivateBrowsingId
=
aPrivateBrowsingId
;
CookieEntry
*
entry
=
mHostTable
.
GetEntry
(
CookieKey
(
aBaseDomain
attrs
)
)
;
return
entry
?
entry
-
>
GetCookies
(
)
.
Length
(
)
:
0
;
}
uint32_t
CookieStorage
:
:
CountCookieBytesNotMatchingCookie
(
const
Cookie
&
cookie
const
nsACString
&
baseDomain
)
{
nsTArray
<
RefPtr
<
Cookie
>
>
cookies
;
GetCookiesFromHost
(
baseDomain
cookie
.
OriginAttributesRef
(
)
cookies
)
;
uint32_t
cookieBytes
=
0
;
for
(
Cookie
*
c
:
cookies
)
{
nsAutoCString
name
;
nsAutoCString
value
;
c
-
>
GetName
(
name
)
;
c
-
>
GetValue
(
value
)
;
if
(
!
cookie
.
Name
(
)
.
Equals
(
name
)
)
{
cookieBytes
+
=
name
.
Length
(
)
+
value
.
Length
(
)
;
}
}
return
cookieBytes
;
}
void
CookieStorage
:
:
GetAll
(
nsTArray
<
RefPtr
<
nsICookie
>
>
&
aResult
)
const
{
aResult
.
SetCapacity
(
mCookieCount
)
;
for
(
const
auto
&
entry
:
mHostTable
)
{
const
CookieEntry
:
:
ArrayType
&
cookies
=
entry
.
GetCookies
(
)
;
for
(
CookieEntry
:
:
IndexType
i
=
0
;
i
<
cookies
.
Length
(
)
;
+
+
i
)
{
aResult
.
AppendElement
(
cookies
[
i
]
)
;
}
}
}
void
CookieStorage
:
:
GetCookiesFromHost
(
const
nsACString
&
aBaseDomain
const
OriginAttributes
&
aOriginAttributes
nsTArray
<
RefPtr
<
Cookie
>
>
&
aCookies
)
{
CookieEntry
*
entry
=
mHostTable
.
GetEntry
(
CookieKey
(
aBaseDomain
aOriginAttributes
)
)
;
if
(
!
entry
)
{
return
;
}
aCookies
=
entry
-
>
GetCookies
(
)
.
Clone
(
)
;
}
void
CookieStorage
:
:
GetCookiesWithOriginAttributes
(
const
OriginAttributesPattern
&
aPattern
const
nsACString
&
aBaseDomain
nsTArray
<
RefPtr
<
nsICookie
>
>
&
aResult
)
{
for
(
auto
iter
=
mHostTable
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
CookieEntry
*
entry
=
iter
.
Get
(
)
;
if
(
!
aBaseDomain
.
IsEmpty
(
)
&
&
!
aBaseDomain
.
Equals
(
entry
-
>
mBaseDomain
)
)
{
continue
;
}
if
(
!
aPattern
.
Matches
(
entry
-
>
mOriginAttributes
)
)
{
continue
;
}
const
CookieEntry
:
:
ArrayType
&
entryCookies
=
entry
-
>
GetCookies
(
)
;
for
(
CookieEntry
:
:
IndexType
i
=
0
;
i
<
entryCookies
.
Length
(
)
;
+
+
i
)
{
aResult
.
AppendElement
(
entryCookies
[
i
]
)
;
}
}
}
void
CookieStorage
:
:
RemoveCookie
(
const
nsACString
&
aBaseDomain
const
OriginAttributes
&
aOriginAttributes
const
nsACString
&
aHost
const
nsACString
&
aName
const
nsACString
&
aPath
const
nsID
*
aOperationID
)
{
CookieListIter
matchIter
{
}
;
RefPtr
<
Cookie
>
cookie
;
if
(
FindCookie
(
aBaseDomain
aOriginAttributes
aHost
aName
aPath
matchIter
)
)
{
cookie
=
matchIter
.
Cookie
(
)
;
RemoveCookieFromList
(
matchIter
)
;
}
if
(
cookie
)
{
NotifyChanged
(
cookie
nsICookieNotification
:
:
COOKIE_DELETED
aBaseDomain
aOperationID
)
;
}
}
void
CookieStorage
:
:
RemoveCookiesWithOriginAttributes
(
const
OriginAttributesPattern
&
aPattern
const
nsACString
&
aBaseDomain
)
{
for
(
auto
iter
=
mHostTable
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
CookieEntry
*
entry
=
iter
.
Get
(
)
;
if
(
!
aBaseDomain
.
IsEmpty
(
)
&
&
!
aBaseDomain
.
Equals
(
entry
-
>
mBaseDomain
)
)
{
continue
;
}
if
(
!
aPattern
.
Matches
(
entry
-
>
mOriginAttributes
)
)
{
continue
;
}
uint32_t
cookiesCount
=
entry
-
>
GetCookies
(
)
.
Length
(
)
;
for
(
CookieEntry
:
:
IndexType
i
=
0
;
i
<
cookiesCount
;
+
+
i
)
{
CookieListIter
iter
(
entry
0
)
;
RefPtr
<
Cookie
>
cookie
=
iter
.
Cookie
(
)
;
RemoveCookieFromList
(
iter
)
;
if
(
cookie
)
{
NotifyChanged
(
cookie
nsICookieNotification
:
:
COOKIE_DELETED
aBaseDomain
)
;
}
}
}
}
bool
CookieStorage
:
:
SerializeIPv6BaseDomain
(
nsACString
&
aBaseDomain
)
{
bool
hasStartBracket
=
aBaseDomain
.
First
(
)
=
=
'
[
'
;
bool
hasEndBracket
=
aBaseDomain
.
Last
(
)
=
=
'
]
'
;
if
(
hasStartBracket
!
=
hasEndBracket
)
{
return
false
;
}
if
(
!
hasStartBracket
)
{
aBaseDomain
.
Insert
(
'
[
'
0
)
;
aBaseDomain
.
Append
(
'
]
'
)
;
}
nsAutoCString
baseDomain
;
nsresult
rv
=
(
nsresult
)
rusturl_parse_ipv6addr
(
&
aBaseDomain
&
baseDomain
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
aBaseDomain
=
Substring
(
baseDomain
1
baseDomain
.
Length
(
)
-
2
)
;
return
true
;
}
void
CookieStorage
:
:
RemoveCookiesFromExactHost
(
const
nsACString
&
aHost
const
nsACString
&
aBaseDomain
const
OriginAttributesPattern
&
aPattern
)
{
nsAutoCString
removeBaseDomain
;
bool
isIPv6
=
CookieCommons
:
:
IsIPv6BaseDomain
(
aBaseDomain
)
;
if
(
isIPv6
)
{
MOZ_ASSERT
(
!
aBaseDomain
.
IsEmpty
(
)
)
;
removeBaseDomain
=
aBaseDomain
;
if
(
NS_WARN_IF
(
!
SerializeIPv6BaseDomain
(
removeBaseDomain
)
)
)
{
return
;
}
}
for
(
auto
iter
=
mHostTable
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
CookieEntry
*
entry
=
iter
.
Get
(
)
;
if
(
isIPv6
)
{
if
(
!
CookieCommons
:
:
IsIPv6BaseDomain
(
entry
-
>
mBaseDomain
)
)
{
continue
;
}
nsAutoCString
entryBaseDomain
;
entryBaseDomain
=
entry
-
>
mBaseDomain
;
if
(
NS_WARN_IF
(
!
SerializeIPv6BaseDomain
(
entryBaseDomain
)
)
)
{
continue
;
}
if
(
!
removeBaseDomain
.
Equals
(
entryBaseDomain
)
)
{
continue
;
}
}
else
if
(
!
aBaseDomain
.
Equals
(
entry
-
>
mBaseDomain
)
)
{
continue
;
}
if
(
!
aPattern
.
Matches
(
entry
-
>
mOriginAttributes
)
)
{
continue
;
}
uint32_t
cookiesCount
=
entry
-
>
GetCookies
(
)
.
Length
(
)
;
for
(
CookieEntry
:
:
IndexType
i
=
cookiesCount
;
i
!
=
0
;
-
-
i
)
{
CookieListIter
iter
(
entry
i
-
1
)
;
RefPtr
<
Cookie
>
cookie
=
iter
.
Cookie
(
)
;
if
(
!
isIPv6
&
&
!
aHost
.
Equals
(
cookie
-
>
RawHost
(
)
)
)
{
continue
;
}
RemoveCookieFromList
(
iter
)
;
if
(
cookie
)
{
NotifyChanged
(
cookie
nsICookieNotification
:
:
COOKIE_DELETED
aBaseDomain
)
;
}
}
}
}
void
CookieStorage
:
:
RemoveAll
(
)
{
mHostTable
.
Clear
(
)
;
mCookieCount
=
0
;
mCookieOldestTime
=
INT64_MAX
;
RemoveAllInternal
(
)
;
NotifyChanged
(
nullptr
nsICookieNotification
:
:
ALL_COOKIES_CLEARED
"
"
_ns
)
;
}
void
CookieStorage
:
:
NotifyChanged
(
nsISupports
*
aSubject
nsICookieNotification
:
:
Action
aAction
const
nsACString
&
aBaseDomain
bool
aIsThirdParty
dom
:
:
BrowsingContext
*
aBrowsingContext
bool
aOldCookieIsSession
const
nsID
*
aOperationID
)
{
nsCOMPtr
<
nsIObserverService
>
os
=
services
:
:
GetObserverService
(
)
;
if
(
!
os
)
{
return
;
}
nsCOMPtr
<
nsICookie
>
cookie
;
nsCOMPtr
<
nsIArray
>
batchDeletedCookies
;
if
(
aAction
=
=
nsICookieNotification
:
:
COOKIES_BATCH_DELETED
)
{
batchDeletedCookies
=
do_QueryInterface
(
aSubject
)
;
}
else
{
cookie
=
do_QueryInterface
(
aSubject
)
;
}
uint64_t
browsingContextId
=
0
;
if
(
aBrowsingContext
)
{
browsingContextId
=
aBrowsingContext
-
>
Id
(
)
;
}
nsCOMPtr
<
nsICookieNotification
>
notification
=
new
CookieNotification
(
aAction
cookie
aBaseDomain
aIsThirdParty
batchDeletedCookies
browsingContextId
aOperationID
)
;
os
-
>
NotifyObservers
(
notification
NotificationTopic
(
)
u
"
"
)
;
NotifyChangedInternal
(
notification
aOldCookieIsSession
)
;
}
bool
CookieStorage
:
:
RemoveCookiesFromBackUntilUnderLimit
(
nsTArray
<
CookieListIter
>
&
aCookieListIter
Cookie
*
aCookie
const
nsACString
&
aBaseDomain
nsCOMPtr
<
nsIArray
>
&
aPurgedList
)
{
MOZ_ASSERT
(
aCookie
)
;
auto
it
=
aCookieListIter
.
rbegin
(
)
;
while
(
it
!
=
aCookieListIter
.
rend
(
)
)
{
RefPtr
<
Cookie
>
evictedCookie
=
(
*
it
)
.
Cookie
(
)
;
COOKIE_LOGEVICTED
(
evictedCookie
"
Too
many
cookie
bytes
for
this
partition
"
)
;
RemoveCookieFromList
(
*
it
)
;
CreateOrUpdatePurgeList
(
aPurgedList
evictedCookie
)
;
MOZ_ASSERT
(
(
*
it
)
.
entry
)
;
if
(
PartitionLimitExceededBytes
(
aCookie
aBaseDomain
false
)
<
=
0
)
{
return
true
;
}
}
return
false
;
}
void
CookieStorage
:
:
RemoveOlderCookiesUntilUnderLimit
(
CookieEntry
*
aEntry
Cookie
*
aCookie
const
nsACString
&
aBaseDomain
nsCOMPtr
<
nsIArray
>
&
aPurgedList
)
{
MOZ_ASSERT
(
aEntry
)
;
const
CookieEntry
:
:
ArrayType
&
cookies
=
aEntry
-
>
GetCookies
(
)
;
using
MaybePurgeList
=
nsTArray
<
CookieListIter
>
;
MaybePurgeList
maybePurgeListInsecure
(
aEntry
-
>
GetCookies
(
)
.
Length
(
)
)
;
for
(
CookieEntry
:
:
IndexType
i
=
0
;
i
<
cookies
.
Length
(
)
;
+
+
i
)
{
CookieListIter
iter
(
aEntry
i
)
;
if
(
!
iter
.
Cookie
(
)
-
>
IsSecure
(
)
)
{
maybePurgeListInsecure
.
AppendElement
(
iter
)
;
}
}
maybePurgeListInsecure
.
Sort
(
CompareCookiesByAge
(
)
)
;
maybePurgeListInsecure
.
Reverse
(
)
;
bool
underLimit
=
RemoveCookiesFromBackUntilUnderLimit
(
maybePurgeListInsecure
aCookie
aBaseDomain
aPurgedList
)
;
if
(
!
underLimit
)
{
MOZ_LOG
(
gCookieLog
LogLevel
:
:
Debug
(
"
Still
too
many
cookies
for
partition
purging
secure
\
n
"
)
)
;
MaybePurgeList
maybePurgeList
(
aEntry
-
>
GetCookies
(
)
.
Length
(
)
)
;
for
(
CookieEntry
:
:
IndexType
i
=
0
;
i
<
cookies
.
Length
(
)
;
+
+
i
)
{
CookieListIter
iter
(
aEntry
i
)
;
maybePurgeList
.
AppendElement
(
iter
)
;
}
maybePurgeList
.
Sort
(
CompareCookiesByAge
(
)
)
;
maybePurgeList
.
Reverse
(
)
;
Unused
<
<
RemoveCookiesFromBackUntilUnderLimit
(
maybePurgeList
aCookie
aBaseDomain
aPurgedList
)
;
}
}
int32_t
CookieStorage
:
:
PartitionLimitExceededBytes
(
Cookie
*
aCookie
const
nsACString
&
aBaseDomain
bool
aHardMax
)
{
uint32_t
newCount
=
CountCookieBytesNotMatchingCookie
(
*
aCookie
aBaseDomain
)
+
aCookie
-
>
NameAndValueBytes
(
)
;
double
factor
=
aHardMax
?
1
.
2
:
1
;
return
static_cast
<
int32_t
>
(
newCount
-
StaticPrefs
:
:
network_cookie_chips_partitionLimitByteCapacity
(
)
*
factor
)
;
}
void
CookieStorage
:
:
AddCookie
(
CookieParser
*
aCookieParser
const
nsACString
&
aBaseDomain
const
OriginAttributes
&
aOriginAttributes
Cookie
*
aCookie
int64_t
aCurrentTimeInUsec
nsIURI
*
aHostURI
const
nsACString
&
aCookieHeader
bool
aFromHttp
bool
aIsThirdParty
dom
:
:
BrowsingContext
*
aBrowsingContext
const
nsID
*
aOperationID
)
{
int64_t
currentTime
=
aCurrentTimeInUsec
/
PR_USEC_PER_SEC
;
CookieListIter
exactIter
{
}
;
bool
foundCookie
=
false
;
foundCookie
=
FindCookie
(
aBaseDomain
aOriginAttributes
aCookie
-
>
Host
(
)
aCookie
-
>
Name
(
)
aCookie
-
>
Path
(
)
exactIter
)
;
bool
foundSecureExact
=
foundCookie
&
&
exactIter
.
Cookie
(
)
-
>
IsSecure
(
)
;
bool
potentiallyTrustworthy
=
true
;
if
(
aHostURI
)
{
potentiallyTrustworthy
=
nsMixedContentBlocker
:
:
IsPotentiallyTrustworthyOrigin
(
aHostURI
)
;
}
bool
oldCookieIsSession
=
false
;
if
(
!
aCookie
-
>
IsSecure
(
)
&
&
(
foundSecureExact
|
|
FindSecureCookie
(
aBaseDomain
aOriginAttributes
aCookie
)
)
&
&
!
potentiallyTrustworthy
)
{
COOKIE_LOGFAILURE
(
SET_COOKIE
aHostURI
aCookieHeader
"
cookie
can
'
t
save
because
older
cookie
is
secure
"
"
cookie
but
newer
cookie
is
non
-
secure
cookie
"
)
;
if
(
aCookieParser
)
{
aCookieParser
-
>
RejectCookie
(
CookieParser
:
:
RejectedNonsecureOverSecure
)
;
}
return
;
}
RefPtr
<
Cookie
>
oldCookie
;
nsCOMPtr
<
nsIArray
>
purgedList
;
if
(
foundCookie
)
{
oldCookie
=
exactIter
.
Cookie
(
)
;
oldCookieIsSession
=
oldCookie
-
>
IsSession
(
)
;
if
(
oldCookie
-
>
Expiry
(
)
<
=
currentTime
)
{
if
(
aCookie
-
>
Expiry
(
)
<
=
currentTime
)
{
COOKIE_LOGFAILURE
(
SET_COOKIE
aHostURI
aCookieHeader
"
cookie
has
already
expired
"
)
;
return
;
}
RemoveCookieFromList
(
exactIter
)
;
COOKIE_LOGFAILURE
(
SET_COOKIE
aHostURI
aCookieHeader
"
stale
cookie
was
purged
"
)
;
purgedList
=
CreatePurgeList
(
oldCookie
)
;
foundCookie
=
false
;
}
else
{
if
(
!
aFromHttp
&
&
oldCookie
-
>
IsHttpOnly
(
)
)
{
COOKIE_LOGFAILURE
(
SET_COOKIE
aHostURI
aCookieHeader
"
previously
stored
cookie
is
httponly
;
coming
from
script
"
)
;
if
(
aCookieParser
)
{
aCookieParser
-
>
RejectCookie
(
CookieParser
:
:
RejectedHttpOnlyButFromScript
)
;
}
return
;
}
if
(
oldCookie
-
>
Value
(
)
.
Equals
(
aCookie
-
>
Value
(
)
)
&
&
oldCookie
-
>
Expiry
(
)
=
=
aCookie
-
>
Expiry
(
)
&
&
oldCookie
-
>
IsSecure
(
)
=
=
aCookie
-
>
IsSecure
(
)
&
&
oldCookie
-
>
IsSession
(
)
=
=
aCookie
-
>
IsSession
(
)
&
&
oldCookie
-
>
IsHttpOnly
(
)
=
=
aCookie
-
>
IsHttpOnly
(
)
&
&
oldCookie
-
>
SameSite
(
)
=
=
aCookie
-
>
SameSite
(
)
&
&
oldCookie
-
>
RawSameSite
(
)
=
=
aCookie
-
>
RawSameSite
(
)
&
&
oldCookie
-
>
SchemeMap
(
)
=
=
aCookie
-
>
SchemeMap
(
)
&
&
!
oldCookie
-
>
IsStale
(
)
)
{
oldCookie
-
>
SetLastAccessed
(
aCookie
-
>
LastAccessed
(
)
)
;
UpdateCookieOldestTime
(
oldCookie
)
;
return
;
}
MergeCookieSchemeMap
(
oldCookie
aCookie
)
;
RemoveCookieFromList
(
exactIter
)
;
if
(
aCookie
-
>
Expiry
(
)
<
=
currentTime
)
{
COOKIE_LOGFAILURE
(
SET_COOKIE
aHostURI
aCookieHeader
"
previously
stored
cookie
was
deleted
"
)
;
NotifyChanged
(
oldCookie
nsICookieNotification
:
:
COOKIE_DELETED
aBaseDomain
false
aBrowsingContext
oldCookieIsSession
aOperationID
)
;
return
;
}
aCookie
-
>
SetCreationTime
(
oldCookie
-
>
CreationTime
(
)
)
;
}
if
(
CookieCommons
:
:
ChipsLimitEnabledAndChipsCookie
(
*
aCookie
aBrowsingContext
)
)
{
CookieEntry
*
entry
=
mHostTable
.
GetEntry
(
CookieKey
(
aBaseDomain
aOriginAttributes
)
)
;
if
(
entry
)
{
int32_t
exceededBytes
=
PartitionLimitExceededBytes
(
aCookie
aBaseDomain
true
)
;
if
(
exceededBytes
>
0
)
{
MOZ_LOG
(
gCookieLog
LogLevel
:
:
Debug
(
"
Partition
byte
limit
exceeded
on
cookie
overwrite
\
n
"
)
)
;
if
(
!
StaticPrefs
:
:
network_cookie_chips_partitionLimitDryRun
(
)
)
{
RemoveOlderCookiesUntilUnderLimit
(
entry
aCookie
aBaseDomain
purgedList
)
;
}
if
(
StaticPrefs
:
:
network_cookie_chips_partitionLimitByteCapacity
(
)
=
=
kChipsPartitionByteCapacityDefault
)
{
mozilla
:
:
glean
:
:
networking
:
:
cookie_chips_partition_limit_overflow
.
AccumulateSingleSample
(
exceededBytes
)
;
}
}
}
}
}
else
{
if
(
aCookie
-
>
Expiry
(
)
<
=
currentTime
)
{
COOKIE_LOGFAILURE
(
SET_COOKIE
aHostURI
aCookieHeader
"
cookie
has
already
expired
"
)
;
return
;
}
CookieEntry
*
entry
=
mHostTable
.
GetEntry
(
CookieKey
(
aBaseDomain
aOriginAttributes
)
)
;
int32_t
partitionLimitExceededBytes
=
0
;
if
(
entry
&
&
entry
-
>
GetCookies
(
)
.
Length
(
)
>
=
mMaxCookiesPerHost
)
{
nsTArray
<
CookieListIter
>
removedIterList
;
uint32_t
limit
=
mMaxCookiesPerHost
-
mCookieQuotaPerHost
;
FindStaleCookies
(
entry
currentTime
false
removedIterList
limit
)
;
if
(
removedIterList
.
Length
(
)
=
=
0
)
{
if
(
aCookie
-
>
IsSecure
(
)
)
{
FindStaleCookies
(
entry
currentTime
true
removedIterList
limit
)
;
}
else
{
COOKIE_LOGEVICTED
(
aCookie
"
Too
many
cookies
for
this
domain
and
the
new
"
"
cookie
is
not
a
secure
cookie
"
)
;
return
;
}
}
MOZ_ASSERT
(
!
removedIterList
.
IsEmpty
(
)
)
;
removedIterList
.
Sort
(
CompareCookiesByIndex
(
)
)
;
for
(
auto
it
=
removedIterList
.
rbegin
(
)
;
it
!
=
removedIterList
.
rend
(
)
;
it
+
+
)
{
RefPtr
<
Cookie
>
evictedCookie
=
(
*
it
)
.
Cookie
(
)
;
COOKIE_LOGEVICTED
(
evictedCookie
"
Too
many
cookies
for
this
domain
"
)
;
RemoveCookieFromList
(
*
it
)
;
CreateOrUpdatePurgeList
(
purgedList
evictedCookie
)
;
MOZ_ASSERT
(
(
*
it
)
.
entry
)
;
}
uint32_t
purgedLength
=
0
;
purgedList
-
>
GetLength
(
&
purgedLength
)
;
mozilla
:
:
glean
:
:
networking
:
:
cookie_purge_entry_max
.
AccumulateSingleSample
(
purgedLength
)
;
}
else
if
(
CookieCommons
:
:
ChipsLimitEnabledAndChipsCookie
(
*
aCookie
aBrowsingContext
)
&
&
entry
&
&
(
partitionLimitExceededBytes
=
PartitionLimitExceededBytes
(
aCookie
aBaseDomain
true
)
)
>
0
)
{
MOZ_LOG
(
gCookieLog
LogLevel
:
:
Debug
(
"
Partition
byte
limit
exceeded
on
cookie
add
\
n
"
)
)
;
if
(
!
StaticPrefs
:
:
network_cookie_chips_partitionLimitDryRun
(
)
)
{
RemoveOlderCookiesUntilUnderLimit
(
entry
aCookie
aBaseDomain
purgedList
)
;
}
if
(
StaticPrefs
:
:
network_cookie_chips_partitionLimitByteCapacity
(
)
=
=
kChipsPartitionByteCapacityDefault
)
{
mozilla
:
:
glean
:
:
networking
:
:
cookie_chips_partition_limit_overflow
.
AccumulateSingleSample
(
partitionLimitExceededBytes
)
;
}
}
else
if
(
mCookieCount
>
=
ADD_TEN_PERCENT
(
mMaxNumberOfCookies
)
)
{
int64_t
maxAge
=
aCurrentTimeInUsec
-
mCookieOldestTime
;
int64_t
purgeAge
=
ADD_TEN_PERCENT
(
mCookiePurgeAge
)
;
if
(
maxAge
>
=
purgeAge
)
{
purgedList
=
PurgeCookies
(
aCurrentTimeInUsec
mMaxNumberOfCookies
mCookiePurgeAge
)
;
uint32_t
purgedLength
=
0
;
purgedList
-
>
GetLength
(
&
purgedLength
)
;
mozilla
:
:
glean
:
:
networking
:
:
cookie_purge_max
.
AccumulateSingleSample
(
purgedLength
)
;
}
}
}
AddCookieToList
(
aBaseDomain
aOriginAttributes
aCookie
)
;
StoreCookie
(
aBaseDomain
aOriginAttributes
aCookie
)
;
COOKIE_LOGSUCCESS
(
SET_COOKIE
aHostURI
aCookieHeader
aCookie
foundCookie
)
;
if
(
purgedList
)
{
NotifyChanged
(
purgedList
nsICookieNotification
:
:
COOKIES_BATCH_DELETED
"
"
_ns
false
nullptr
false
aOperationID
)
;
}
NotifyChanged
(
aCookie
foundCookie
?
nsICookieNotification
:
:
COOKIE_CHANGED
:
nsICookieNotification
:
:
COOKIE_ADDED
aBaseDomain
aIsThirdParty
aBrowsingContext
oldCookieIsSession
aOperationID
)
;
}
void
CookieStorage
:
:
UpdateCookieOldestTime
(
Cookie
*
aCookie
)
{
if
(
aCookie
-
>
LastAccessed
(
)
<
mCookieOldestTime
)
{
mCookieOldestTime
=
aCookie
-
>
LastAccessed
(
)
;
}
}
void
CookieStorage
:
:
MergeCookieSchemeMap
(
Cookie
*
aOldCookie
Cookie
*
aNewCookie
)
{
aNewCookie
-
>
SetSchemeMap
(
aOldCookie
-
>
SchemeMap
(
)
|
aNewCookie
-
>
SchemeMap
(
)
)
;
}
void
CookieStorage
:
:
AddCookieToList
(
const
nsACString
&
aBaseDomain
const
OriginAttributes
&
aOriginAttributes
Cookie
*
aCookie
)
{
if
(
!
aCookie
)
{
NS_WARNING
(
"
Attempting
to
AddCookieToList
with
null
cookie
"
)
;
return
;
}
CookieKey
key
(
aBaseDomain
aOriginAttributes
)
;
CookieEntry
*
entry
=
mHostTable
.
PutEntry
(
key
)
;
NS_ASSERTION
(
entry
"
can
'
t
insert
element
into
a
null
entry
!
"
)
;
entry
-
>
GetCookies
(
)
.
AppendElement
(
aCookie
)
;
+
+
mCookieCount
;
UpdateCookieOldestTime
(
aCookie
)
;
}
already_AddRefed
<
nsIArray
>
CookieStorage
:
:
CreatePurgeList
(
nsICookie
*
aCookie
)
{
nsCOMPtr
<
nsIMutableArray
>
removedList
=
do_CreateInstance
(
NS_ARRAY_CONTRACTID
)
;
removedList
-
>
AppendElement
(
aCookie
)
;
return
removedList
.
forget
(
)
;
}
void
CookieStorage
:
:
FindStaleCookies
(
CookieEntry
*
aEntry
int64_t
aCurrentTime
bool
aIsSecure
nsTArray
<
CookieListIter
>
&
aOutput
uint32_t
aLimit
)
{
MOZ_ASSERT
(
aLimit
)
;
const
CookieEntry
:
:
ArrayType
&
cookies
=
aEntry
-
>
GetCookies
(
)
;
aOutput
.
Clear
(
)
;
CookieIterComparator
comp
(
aCurrentTime
)
;
nsTPriorityQueue
<
CookieListIter
CookieIterComparator
>
queue
(
comp
)
;
for
(
CookieEntry
:
:
IndexType
i
=
0
;
i
<
cookies
.
Length
(
)
;
+
+
i
)
{
Cookie
*
cookie
=
cookies
[
i
]
;
if
(
cookie
-
>
Expiry
(
)
<
=
aCurrentTime
)
{
queue
.
Push
(
CookieListIter
(
aEntry
i
)
)
;
continue
;
}
if
(
!
aIsSecure
)
{
if
(
cookie
-
>
IsSecure
(
)
)
{
continue
;
}
}
queue
.
Push
(
CookieListIter
(
aEntry
i
)
)
;
}
uint32_t
count
=
0
;
while
(
!
queue
.
IsEmpty
(
)
&
&
count
<
aLimit
)
{
aOutput
.
AppendElement
(
queue
.
Pop
(
)
)
;
count
+
+
;
}
}
void
CookieStorage
:
:
CreateOrUpdatePurgeList
(
nsCOMPtr
<
nsIArray
>
&
aPurgedList
nsICookie
*
aCookie
)
{
if
(
!
aPurgedList
)
{
COOKIE_LOGSTRING
(
LogLevel
:
:
Debug
(
"
Creating
new
purge
list
"
)
)
;
aPurgedList
=
CreatePurgeList
(
aCookie
)
;
return
;
}
nsCOMPtr
<
nsIMutableArray
>
purgedList
=
do_QueryInterface
(
aPurgedList
)
;
if
(
purgedList
)
{
COOKIE_LOGSTRING
(
LogLevel
:
:
Debug
(
"
Updating
existing
purge
list
"
)
)
;
purgedList
-
>
AppendElement
(
aCookie
)
;
}
else
{
COOKIE_LOGSTRING
(
LogLevel
:
:
Debug
(
"
Could
not
QI
aPurgedList
!
"
)
)
;
}
}
already_AddRefed
<
nsIArray
>
CookieStorage
:
:
PurgeCookiesWithCallbacks
(
int64_t
aCurrentTimeInUsec
uint16_t
aMaxNumberOfCookies
int64_t
aCookiePurgeAge
std
:
:
function
<
void
(
const
CookieListIter
&
)
>
&
&
aRemoveCookieCallback
std
:
:
function
<
void
(
)
>
&
&
aFinalizeCallback
)
{
NS_ASSERTION
(
mHostTable
.
Count
(
)
>
0
"
table
is
empty
"
)
;
uint32_t
initialCookieCount
=
mCookieCount
;
COOKIE_LOGSTRING
(
LogLevel
:
:
Debug
(
"
PurgeCookies
(
)
:
beginning
purge
with
%
"
PRIu32
"
cookies
and
%
"
PRId64
"
oldest
age
"
mCookieCount
aCurrentTimeInUsec
-
mCookieOldestTime
)
)
;
using
PurgeList
=
nsTArray
<
CookieListIter
>
;
PurgeList
purgeList
(
kMaxNumberOfCookies
)
;
nsCOMPtr
<
nsIMutableArray
>
removedList
=
do_CreateInstance
(
NS_ARRAY_CONTRACTID
)
;
int64_t
currentTime
=
aCurrentTimeInUsec
/
PR_USEC_PER_SEC
;
int64_t
purgeTime
=
aCurrentTimeInUsec
-
aCookiePurgeAge
;
int64_t
oldestTime
=
INT64_MAX
;
for
(
auto
iter
=
mHostTable
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
CookieEntry
*
entry
=
iter
.
Get
(
)
;
const
CookieEntry
:
:
ArrayType
&
cookies
=
entry
-
>
GetCookies
(
)
;
auto
length
=
cookies
.
Length
(
)
;
for
(
CookieEntry
:
:
IndexType
i
=
0
;
i
<
length
;
)
{
CookieListIter
iter
(
entry
i
)
;
Cookie
*
cookie
=
cookies
[
i
]
;
if
(
cookie
-
>
Expiry
(
)
<
=
currentTime
)
{
removedList
-
>
AppendElement
(
cookie
)
;
COOKIE_LOGEVICTED
(
cookie
"
Cookie
expired
"
)
;
aRemoveCookieCallback
(
iter
)
;
if
(
i
=
=
-
-
length
)
{
break
;
}
}
else
{
if
(
cookie
-
>
LastAccessed
(
)
<
=
purgeTime
)
{
purgeList
.
AppendElement
(
iter
)
;
}
else
if
(
cookie
-
>
LastAccessed
(
)
<
oldestTime
)
{
oldestTime
=
cookie
-
>
LastAccessed
(
)
;
}
+
+
i
;
}
MOZ_ASSERT
(
length
=
=
cookies
.
Length
(
)
)
;
}
}
uint32_t
postExpiryCookieCount
=
mCookieCount
;
purgeList
.
Sort
(
CompareCookiesByAge
(
)
)
;
uint32_t
excess
=
mCookieCount
>
aMaxNumberOfCookies
?
mCookieCount
-
aMaxNumberOfCookies
:
0
;
if
(
purgeList
.
Length
(
)
>
excess
)
{
oldestTime
=
purgeList
[
excess
]
.
Cookie
(
)
-
>
LastAccessed
(
)
;
purgeList
.
SetLength
(
excess
)
;
}
purgeList
.
Sort
(
CompareCookiesByIndex
(
)
)
;
for
(
PurgeList
:
:
index_type
i
=
purgeList
.
Length
(
)
;
i
-
-
;
)
{
Cookie
*
cookie
=
purgeList
[
i
]
.
Cookie
(
)
;
removedList
-
>
AppendElement
(
cookie
)
;
COOKIE_LOGEVICTED
(
cookie
"
Cookie
too
old
"
)
;
aRemoveCookieCallback
(
purgeList
[
i
]
)
;
}
if
(
aFinalizeCallback
)
{
aFinalizeCallback
(
)
;
}
mCookieOldestTime
=
oldestTime
;
COOKIE_LOGSTRING
(
LogLevel
:
:
Debug
(
"
PurgeCookies
(
)
:
%
"
PRIu32
"
expired
;
%
"
PRIu32
"
purged
;
%
"
PRIu32
"
remain
;
%
"
PRId64
"
oldest
age
"
initialCookieCount
-
postExpiryCookieCount
postExpiryCookieCount
-
mCookieCount
mCookieCount
aCurrentTimeInUsec
-
mCookieOldestTime
)
)
;
return
removedList
.
forget
(
)
;
}
void
CookieStorage
:
:
RemoveCookieFromList
(
const
CookieListIter
&
aIter
)
{
RemoveCookieFromDB
(
*
aIter
.
Cookie
(
)
)
;
RemoveCookieFromListInternal
(
aIter
)
;
}
void
CookieStorage
:
:
RemoveCookieFromListInternal
(
const
CookieListIter
&
aIter
)
{
if
(
aIter
.
entry
-
>
GetCookies
(
)
.
Length
(
)
=
=
1
)
{
mHostTable
.
RawRemoveEntry
(
aIter
.
entry
)
;
}
else
{
aIter
.
entry
-
>
GetCookies
(
)
.
RemoveElementAt
(
aIter
.
index
)
;
}
-
-
mCookieCount
;
}
void
CookieStorage
:
:
PrefChanged
(
nsIPrefBranch
*
aPrefBranch
)
{
int32_t
val
;
if
(
NS_SUCCEEDED
(
aPrefBranch
-
>
GetIntPref
(
kPrefMaxNumberOfCookies
&
val
)
)
)
{
mMaxNumberOfCookies
=
static_cast
<
uint16_t
>
LIMIT
(
val
1
0xFFFF
kMaxNumberOfCookies
)
;
}
if
(
NS_SUCCEEDED
(
aPrefBranch
-
>
GetIntPref
(
kPrefCookieQuotaPerHost
&
val
)
)
)
{
mCookieQuotaPerHost
=
static_cast
<
uint16_t
>
LIMIT
(
val
1
mMaxCookiesPerHost
-
1
kCookieQuotaPerHost
)
;
}
if
(
NS_SUCCEEDED
(
aPrefBranch
-
>
GetIntPref
(
kPrefMaxCookiesPerHost
&
val
)
)
)
{
mMaxCookiesPerHost
=
static_cast
<
uint16_t
>
LIMIT
(
val
mCookieQuotaPerHost
+
1
0xFFFF
kMaxCookiesPerHost
)
;
}
if
(
NS_SUCCEEDED
(
aPrefBranch
-
>
GetIntPref
(
kPrefCookiePurgeAge
&
val
)
)
)
{
mCookiePurgeAge
=
int64_t
(
LIMIT
(
val
0
INT32_MAX
INT32_MAX
)
)
*
PR_USEC_PER_SEC
;
}
}
NS_IMETHODIMP
CookieStorage
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
)
{
if
(
!
strcmp
(
aTopic
NS_PREFBRANCH_PREFCHANGE_TOPIC_ID
)
)
{
nsCOMPtr
<
nsIPrefBranch
>
prefBranch
=
do_QueryInterface
(
aSubject
)
;
if
(
prefBranch
)
{
PrefChanged
(
prefBranch
)
;
}
}
else
if
(
!
strcmp
(
aTopic
OBSERVER_TOPIC_IDLE_DAILY
)
)
{
CollectCookieJarSizeData
(
)
;
}
return
NS_OK
;
}
}
}
