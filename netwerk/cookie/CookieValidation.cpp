#
include
"
CookieValidation
.
h
"
#
include
"
CookieLogging
.
h
"
#
include
"
CookieService
.
h
"
#
include
"
mozilla
/
dom
/
nsMixedContentBlocker
.
h
"
#
include
"
mozilla
/
StaticPrefs_network
.
h
"
constexpr
uint32_t
kMaxBytesPerCookie
=
4096
;
constexpr
uint32_t
kMaxBytesPerDomain
=
1024
;
constexpr
uint32_t
kMaxBytesPerPath
=
1024
;
using
namespace
mozilla
:
:
net
;
NS_IMPL_ISUPPORTS
(
CookieValidation
nsICookieValidation
)
CookieValidation
:
:
CookieValidation
(
const
CookieStruct
&
aCookieData
)
:
mCookieData
(
aCookieData
)
{
}
already_AddRefed
<
CookieValidation
>
CookieValidation
:
:
Validate
(
const
CookieStruct
&
aCookieData
)
{
RefPtr
<
CookieValidation
>
cv
=
new
CookieValidation
(
aCookieData
)
;
cv
-
>
ValidateInternal
(
)
;
return
cv
.
forget
(
)
;
}
already_AddRefed
<
CookieValidation
>
CookieValidation
:
:
ValidateForHost
(
const
CookieStruct
&
aCookieData
nsIURI
*
aHostURI
const
nsACString
&
aBaseDomain
bool
aRequireHostMatch
bool
aFromHttp
)
{
RefPtr
<
CookieValidation
>
cv
=
new
CookieValidation
(
aCookieData
)
;
cv
-
>
ValidateForHostInternal
(
aHostURI
aBaseDomain
aRequireHostMatch
aFromHttp
)
;
return
cv
.
forget
(
)
;
}
already_AddRefed
<
CookieValidation
>
CookieValidation
:
:
ValidateInContext
(
const
CookieStruct
&
aCookieData
nsIURI
*
aHostURI
const
nsACString
&
aBaseDomain
bool
aRequireHostMatch
bool
aFromHttp
bool
aIsForeignAndNotAddon
bool
aPartitionedOnly
bool
aIsInPrivateBrowsing
)
{
RefPtr
<
CookieValidation
>
cv
=
new
CookieValidation
(
aCookieData
)
;
cv
-
>
ValidateInContextInternal
(
aHostURI
aBaseDomain
aRequireHostMatch
aFromHttp
aIsForeignAndNotAddon
aPartitionedOnly
aIsInPrivateBrowsing
)
;
return
cv
.
forget
(
)
;
}
void
CookieValidation
:
:
ValidateInternal
(
)
{
MOZ_ASSERT
(
mResult
=
=
eOK
)
;
if
(
mCookieData
.
name
(
)
.
IsEmpty
(
)
&
&
mCookieData
.
value
(
)
.
IsEmpty
(
)
)
{
mResult
=
eRejectedEmptyNameAndValue
;
return
;
}
if
(
!
CheckNameAndValueSize
(
mCookieData
)
)
{
mResult
=
eRejectedNameValueOversize
;
return
;
}
if
(
!
CheckName
(
mCookieData
)
)
{
mResult
=
eRejectedInvalidCharName
;
return
;
}
if
(
!
CheckValue
(
mCookieData
)
)
{
mResult
=
eRejectedInvalidCharValue
;
return
;
}
if
(
mCookieData
.
path
(
)
.
Length
(
)
>
kMaxBytesPerPath
)
{
mResult
=
eRejectedAttributePathOversize
;
return
;
}
if
(
mCookieData
.
path
(
)
.
Contains
(
'
\
t
'
)
)
{
mResult
=
eRejectedInvalidPath
;
return
;
}
if
(
mCookieData
.
host
(
)
.
Length
(
)
>
kMaxBytesPerDomain
)
{
mResult
=
eRejectedAttributeDomainOversize
;
return
;
}
if
(
mCookieData
.
name
(
)
.
IsEmpty
(
)
&
&
(
HasSecurePrefix
(
mCookieData
.
value
(
)
)
|
|
HasHostPrefix
(
mCookieData
.
value
(
)
)
)
)
{
mResult
=
eRejectedInvalidPrefix
;
return
;
}
if
(
!
mCookieData
.
isSecure
(
)
&
&
mCookieData
.
sameSite
(
)
=
=
nsICookie
:
:
SAMESITE_NONE
)
{
if
(
StaticPrefs
:
:
network_cookie_sameSite_noneRequiresSecure
(
)
)
{
mResult
=
eRejectedNoneRequiresSecure
;
return
;
}
mWarnings
.
mSameSiteNoneRequiresSecureForBeta
=
true
;
}
if
(
StaticPrefs
:
:
network_cookie_CHIPS_enabled
(
)
&
&
mCookieData
.
isPartitioned
(
)
&
&
!
mCookieData
.
isSecure
(
)
)
{
mResult
=
eRejectedPartitionedRequiresSecure
;
return
;
}
}
void
CookieValidation
:
:
ValidateForHostInternal
(
nsIURI
*
aHostURI
const
nsACString
&
aBaseDomain
bool
aRequireHostMatch
bool
aFromHttp
)
{
MOZ_ASSERT
(
mResult
=
=
eOK
)
;
ValidateInternal
(
)
;
if
(
mResult
!
=
eOK
)
{
return
;
}
if
(
!
aBaseDomain
.
IsEmpty
(
)
&
&
!
CheckDomain
(
mCookieData
aHostURI
aBaseDomain
aRequireHostMatch
)
)
{
mResult
=
eRejectedInvalidDomain
;
return
;
}
if
(
!
aFromHttp
&
&
mCookieData
.
isHttpOnly
(
)
)
{
mResult
=
eRejectedHttpOnlyButFromScript
;
return
;
}
bool
potentiallyTrustworthy
=
nsMixedContentBlocker
:
:
IsPotentiallyTrustworthyOrigin
(
aHostURI
)
;
if
(
!
CheckPrefixes
(
mCookieData
potentiallyTrustworthy
)
)
{
mResult
=
eRejectedInvalidPrefix
;
return
;
}
if
(
mCookieData
.
isSecure
(
)
&
&
!
potentiallyTrustworthy
)
{
mResult
=
eRejectedSecureButNonHttps
;
return
;
}
if
(
mCookieData
.
sameSite
(
)
=
=
nsICookie
:
:
SAMESITE_UNSET
)
{
bool
laxByDefault
=
StaticPrefs
:
:
network_cookie_sameSite_laxByDefault
(
)
&
&
!
nsContentUtils
:
:
IsURIInPrefList
(
aHostURI
"
network
.
cookie
.
sameSite
.
laxByDefault
.
disabledHosts
"
)
;
if
(
laxByDefault
)
{
mWarnings
.
mSameSiteLaxForced
=
true
;
}
else
if
(
StaticPrefs
:
:
network_cookie_sameSite_laxByDefaultWarningsForBeta
(
)
)
{
mWarnings
.
mSameSiteLaxForcedForBeta
=
true
;
}
}
}
void
CookieValidation
:
:
ValidateInContextInternal
(
nsIURI
*
aHostURI
const
nsACString
&
aBaseDomain
bool
aRequireHostMatch
bool
aFromHttp
bool
aIsForeignAndNotAddon
bool
aPartitionedOnly
bool
aIsInPrivateBrowsing
)
{
MOZ_ASSERT
(
mResult
=
=
eOK
)
;
ValidateForHostInternal
(
aHostURI
aBaseDomain
aRequireHostMatch
aFromHttp
)
;
if
(
mResult
!
=
eOK
)
{
return
;
}
bool
laxByDefault
=
StaticPrefs
:
:
network_cookie_sameSite_laxByDefault
(
)
&
&
!
nsContentUtils
:
:
IsURIInPrefList
(
aHostURI
"
network
.
cookie
.
sameSite
.
laxByDefault
.
disabledHosts
"
)
;
uint32_t
sameSite
=
mCookieData
.
sameSite
(
)
;
if
(
sameSite
=
=
nsICookie
:
:
SAMESITE_UNSET
)
{
sameSite
=
laxByDefault
?
nsICookie
:
:
SAMESITE_LAX
:
nsICookie
:
:
SAMESITE_NONE
;
}
if
(
sameSite
!
=
nsICookie
:
:
SAMESITE_NONE
&
&
aIsForeignAndNotAddon
)
{
mResult
=
eRejectedForNonSameSiteness
;
return
;
}
}
NS_IMETHODIMP
CookieValidation
:
:
GetResult
(
nsICookieValidation
:
:
ValidationError
*
aRetval
)
{
NS_ENSURE_ARG_POINTER
(
aRetval
)
;
*
aRetval
=
mResult
;
return
NS_OK
;
}
bool
CookieValidation
:
:
CheckDomain
(
const
CookieStruct
&
aCookieData
nsIURI
*
aHostURI
const
nsACString
&
aBaseDomain
bool
aRequireHostMatch
)
{
if
(
aCookieData
.
host
(
)
.
IsEmpty
(
)
)
{
return
false
;
}
nsAutoCString
hostFromURI
;
nsContentUtils
:
:
GetHostOrIPv6WithBrackets
(
aHostURI
hostFromURI
)
;
if
(
aRequireHostMatch
)
{
return
hostFromURI
.
Equals
(
aCookieData
.
host
(
)
)
;
}
nsCString
cookieHost
=
aCookieData
.
host
(
)
;
if
(
aCookieData
.
host
(
)
.
Length
(
)
>
1
&
&
aCookieData
.
host
(
)
.
First
(
)
=
=
'
.
'
)
{
cookieHost
.
Cut
(
0
1
)
;
}
if
(
CookieCommons
:
:
IsSubdomainOf
(
cookieHost
aBaseDomain
)
&
&
CookieCommons
:
:
IsSubdomainOf
(
hostFromURI
cookieHost
)
)
{
return
true
;
}
return
false
;
}
bool
CookieValidation
:
:
HasSecurePrefix
(
const
nsACString
&
aString
)
{
return
StringBeginsWith
(
aString
"
__Secure
-
"
_ns
nsCaseInsensitiveCStringComparator
)
;
}
bool
CookieValidation
:
:
HasHostPrefix
(
const
nsACString
&
aString
)
{
return
StringBeginsWith
(
aString
"
__Host
-
"
_ns
nsCaseInsensitiveCStringComparator
)
;
}
bool
CookieValidation
:
:
CheckPrefixes
(
const
CookieStruct
&
aCookieData
bool
aSecureRequest
)
{
bool
hasSecurePrefix
=
HasSecurePrefix
(
aCookieData
.
name
(
)
)
;
bool
hasHostPrefix
=
HasHostPrefix
(
aCookieData
.
name
(
)
)
;
if
(
!
hasSecurePrefix
&
&
!
hasHostPrefix
)
{
return
true
;
}
if
(
!
aSecureRequest
|
|
!
aCookieData
.
isSecure
(
)
)
{
return
false
;
}
if
(
hasHostPrefix
)
{
if
(
aCookieData
.
host
(
)
[
0
]
=
=
'
.
'
|
|
!
aCookieData
.
path
(
)
.
EqualsLiteral
(
"
/
"
)
)
{
return
false
;
}
}
return
true
;
}
void
CookieValidation
:
:
ReportErrorsAndWarnings
(
nsIConsoleReportCollector
*
aCRC
nsIURI
*
aHostURI
)
const
{
#
define
COOKIE_LOGGING_WITH_NAME
(
category
x
)
\
CookieLogging
:
:
LogMessageToConsole
(
\
aCRC
aHostURI
nsIScriptError
:
:
errorFlag
category
x
\
AutoTArray
<
nsString
1
>
{
NS_ConvertUTF8toUTF16
(
mCookieData
.
name
(
)
)
}
)
;
switch
(
mResult
)
{
case
eOK
:
break
;
case
eRejectedEmptyNameAndValue
:
CookieLogging
:
:
LogMessageToConsole
(
aCRC
aHostURI
nsIScriptError
:
:
warningFlag
CONSOLE_REJECTION_CATEGORY
"
CookieRejectedEmptyNameAndValue
"
_ns
nsTArray
<
nsString
>
(
)
)
;
break
;
case
eRejectedNoneRequiresSecure
:
COOKIE_LOGGING_WITH_NAME
(
CONSOLE_SAMESITE_CATEGORY
"
CookieRejectedNonRequiresSecure2
"
_ns
)
;
break
;
case
eRejectedPartitionedRequiresSecure
:
COOKIE_LOGGING_WITH_NAME
(
CONSOLE_REJECTION_CATEGORY
"
CookieRejectedPartitionedRequiresSecure
"
_ns
)
;
break
;
case
eRejectedNameValueOversize
:
{
AutoTArray
<
nsString
2
>
params
=
{
NS_ConvertUTF8toUTF16
(
mCookieData
.
name
(
)
)
}
;
nsString
size
;
size
.
AppendInt
(
kMaxBytesPerCookie
)
;
params
.
AppendElement
(
size
)
;
CookieLogging
:
:
LogMessageToConsole
(
aCRC
aHostURI
nsIScriptError
:
:
warningFlag
CONSOLE_OVERSIZE_CATEGORY
"
CookieOversize
"
_ns
params
)
;
break
;
}
case
eRejectedInvalidCharName
:
COOKIE_LOGGING_WITH_NAME
(
CONSOLE_REJECTION_CATEGORY
"
CookieRejectedInvalidCharName
"
_ns
)
;
break
;
case
eRejectedInvalidCharValue
:
COOKIE_LOGGING_WITH_NAME
(
CONSOLE_REJECTION_CATEGORY
"
CookieRejectedInvalidCharValue
"
_ns
)
;
break
;
case
eRejectedAttributePathOversize
:
COOKIE_LOGGING_WITH_NAME
(
CONSOLE_REJECTION_CATEGORY
"
CookieRejectedAttributePathOversize
"
_ns
)
;
break
;
case
eRejectedAttributeDomainOversize
:
COOKIE_LOGGING_WITH_NAME
(
CONSOLE_REJECTION_CATEGORY
"
CookieRejectedAttributeDomainOversize
"
_ns
)
;
break
;
case
eRejectedInvalidPath
:
COOKIE_LOGGING_WITH_NAME
(
CONSOLE_REJECTION_CATEGORY
"
CookieRejectedInvalidPath
"
_ns
)
;
break
;
case
eRejectedInvalidDomain
:
COOKIE_LOGGING_WITH_NAME
(
CONSOLE_REJECTION_CATEGORY
"
CookieRejectedInvalidDomain
"
_ns
)
;
break
;
case
eRejectedInvalidPrefix
:
COOKIE_LOGGING_WITH_NAME
(
CONSOLE_REJECTION_CATEGORY
"
CookieRejectedInvalidPrefix
"
_ns
)
;
break
;
case
eRejectedHttpOnlyButFromScript
:
COOKIE_LOGGING_WITH_NAME
(
CONSOLE_REJECTION_CATEGORY
"
CookieRejectedHttpOnlyButFromScript
"
_ns
)
;
break
;
case
eRejectedSecureButNonHttps
:
COOKIE_LOGGING_WITH_NAME
(
CONSOLE_REJECTION_CATEGORY
"
CookieRejectedSecureButNonHttps
"
_ns
)
;
break
;
case
eRejectedForNonSameSiteness
:
COOKIE_LOGGING_WITH_NAME
(
CONSOLE_SAMESITE_CATEGORY
"
CookieRejectedForNonSameSiteness
"
_ns
)
;
break
;
}
#
undef
COOKIE_LOGGING_WITH_NAME
if
(
mResult
!
=
eOK
)
{
return
;
}
if
(
mWarnings
.
mSameSiteNoneRequiresSecureForBeta
)
{
CookieLogging
:
:
LogMessageToConsole
(
aCRC
aHostURI
nsIScriptError
:
:
warningFlag
CONSOLE_SAMESITE_CATEGORY
"
CookieRejectedNonRequiresSecureForBeta3
"
_ns
AutoTArray
<
nsString
2
>
{
NS_ConvertUTF8toUTF16
(
mCookieData
.
name
(
)
)
SAMESITE_MDN_URL
}
)
;
}
if
(
mWarnings
.
mSameSiteLaxForced
)
{
CookieLogging
:
:
LogMessageToConsole
(
aCRC
aHostURI
nsIScriptError
:
:
infoFlag
CONSOLE_SAMESITE_CATEGORY
"
CookieLaxForced2
"
_ns
AutoTArray
<
nsString
1
>
{
NS_ConvertUTF8toUTF16
(
mCookieData
.
name
(
)
)
}
)
;
}
if
(
mWarnings
.
mSameSiteLaxForcedForBeta
)
{
CookieLogging
:
:
LogMessageToConsole
(
aCRC
aHostURI
nsIScriptError
:
:
warningFlag
CONSOLE_SAMESITE_CATEGORY
"
CookieLaxForcedForBeta2
"
_ns
AutoTArray
<
nsString
2
>
{
NS_ConvertUTF8toUTF16
(
mCookieData
.
name
(
)
)
SAMESITE_MDN_URL
}
)
;
}
}
bool
CookieValidation
:
:
CheckNameAndValueSize
(
const
CookieStruct
&
aCookieData
)
{
return
(
aCookieData
.
name
(
)
.
Length
(
)
+
aCookieData
.
value
(
)
.
Length
(
)
)
<
=
kMaxBytesPerCookie
;
}
bool
CookieValidation
:
:
CheckName
(
const
CookieStruct
&
aCookieData
)
{
const
char
illegalNameCharacters
[
]
=
{
0x01
0x02
0x03
0x04
0x05
0x06
0x07
0x08
0x0A
0x0B
0x0C
0x0D
0x0E
0x0F
0x10
0x11
0x12
0x13
0x14
0x15
0x16
0x17
0x18
0x19
0x1A
0x1B
0x1C
0x1D
0x1E
0x1F
0x3B
0x3D
0x7F
0x00
}
;
const
auto
*
start
=
aCookieData
.
name
(
)
.
BeginReading
(
)
;
const
auto
*
end
=
aCookieData
.
name
(
)
.
EndReading
(
)
;
auto
charFilter
=
[
&
]
(
unsigned
char
c
)
{
if
(
StaticPrefs
:
:
network_cookie_blockUnicode
(
)
&
&
c
>
=
0x80
)
{
return
true
;
}
return
std
:
:
find
(
std
:
:
begin
(
illegalNameCharacters
)
std
:
:
end
(
illegalNameCharacters
)
c
)
!
=
std
:
:
end
(
illegalNameCharacters
)
;
}
;
return
std
:
:
find_if
(
start
end
charFilter
)
=
=
end
;
}
bool
CookieValidation
:
:
CheckValue
(
const
CookieStruct
&
aCookieData
)
{
const
char
illegalCharacters
[
]
=
{
0x01
0x02
0x03
0x04
0x05
0x06
0x07
0x08
0x0A
0x0B
0x0C
0x0D
0x0E
0x0F
0x10
0x11
0x12
0x13
0x14
0x15
0x16
0x17
0x18
0x19
0x1A
0x1B
0x1C
0x1D
0x1E
0x1F
0x3B
0x7F
0x00
}
;
const
auto
*
start
=
aCookieData
.
value
(
)
.
BeginReading
(
)
;
const
auto
*
end
=
aCookieData
.
value
(
)
.
EndReading
(
)
;
auto
charFilter
=
[
&
]
(
unsigned
char
c
)
{
if
(
StaticPrefs
:
:
network_cookie_blockUnicode
(
)
&
&
c
>
=
0x80
)
{
return
true
;
}
return
std
:
:
find
(
std
:
:
begin
(
illegalCharacters
)
std
:
:
end
(
illegalCharacters
)
c
)
!
=
std
:
:
end
(
illegalCharacters
)
;
}
;
return
std
:
:
find_if
(
start
end
charFilter
)
=
=
end
;
}
