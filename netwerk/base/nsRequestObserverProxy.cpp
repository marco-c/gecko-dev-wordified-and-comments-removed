#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
nscore
.
h
"
#
include
"
nsRequestObserverProxy
.
h
"
#
include
"
nsIRequest
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
IntegerPrintfMacros
.
h
"
namespace
mozilla
{
namespace
net
{
static
LazyLogModule
gRequestObserverProxyLog
(
"
nsRequestObserverProxy
"
)
;
#
undef
LOG
#
define
LOG
(
args
)
MOZ_LOG
(
gRequestObserverProxyLog
LogLevel
:
:
Debug
args
)
nsARequestObserverEvent
:
:
nsARequestObserverEvent
(
nsIRequest
*
request
)
:
Runnable
(
"
net
:
:
nsARequestObserverEvent
"
)
mRequest
(
request
)
{
MOZ_ASSERT
(
mRequest
"
null
pointer
"
)
;
}
class
nsOnStartRequestEvent
:
public
nsARequestObserverEvent
{
RefPtr
<
nsRequestObserverProxy
>
mProxy
;
public
:
nsOnStartRequestEvent
(
nsRequestObserverProxy
*
proxy
nsIRequest
*
request
)
:
nsARequestObserverEvent
(
request
)
mProxy
(
proxy
)
{
MOZ_ASSERT
(
mProxy
"
null
pointer
"
)
;
}
virtual
~
nsOnStartRequestEvent
(
)
=
default
;
NS_IMETHOD
Run
(
)
override
{
LOG
(
(
"
nsOnStartRequestEvent
:
:
HandleEvent
[
req
=
%
p
]
\
n
"
mRequest
.
get
(
)
)
)
;
if
(
!
mProxy
-
>
mObserver
)
{
MOZ_ASSERT_UNREACHABLE
(
"
already
handled
onStopRequest
event
"
"
(
observer
is
null
)
"
)
;
return
NS_OK
;
}
LOG
(
(
"
handle
startevent
=
%
p
\
n
"
this
)
)
;
nsresult
rv
=
mProxy
-
>
mObserver
-
>
OnStartRequest
(
mRequest
mProxy
-
>
mContext
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
OnStartRequest
failed
[
rv
=
%
"
PRIx32
"
]
canceling
request
!
\
n
"
static_cast
<
uint32_t
>
(
rv
)
)
)
;
rv
=
mRequest
-
>
Cancel
(
rv
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Cancel
failed
for
request
!
"
)
;
}
return
NS_OK
;
}
}
;
class
nsOnStopRequestEvent
:
public
nsARequestObserverEvent
{
RefPtr
<
nsRequestObserverProxy
>
mProxy
;
public
:
nsOnStopRequestEvent
(
nsRequestObserverProxy
*
proxy
nsIRequest
*
request
)
:
nsARequestObserverEvent
(
request
)
mProxy
(
proxy
)
{
MOZ_ASSERT
(
mProxy
"
null
pointer
"
)
;
}
virtual
~
nsOnStopRequestEvent
(
)
=
default
;
NS_IMETHOD
Run
(
)
override
{
LOG
(
(
"
nsOnStopRequestEvent
:
:
HandleEvent
[
req
=
%
p
]
\
n
"
mRequest
.
get
(
)
)
)
;
nsMainThreadPtrHandle
<
nsIRequestObserver
>
observer
=
mProxy
-
>
mObserver
;
if
(
!
observer
)
{
MOZ_ASSERT_UNREACHABLE
(
"
already
handled
onStopRequest
event
"
"
(
observer
is
null
)
"
)
;
return
NS_OK
;
}
mProxy
-
>
mObserver
=
nullptr
;
nsresult
status
=
NS_OK
;
DebugOnly
<
nsresult
>
rv
=
mRequest
-
>
GetStatus
(
&
status
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
GetStatus
failed
for
request
!
"
)
;
LOG
(
(
"
handle
stopevent
=
%
p
\
n
"
this
)
)
;
(
void
)
observer
-
>
OnStopRequest
(
mRequest
mProxy
-
>
mContext
status
)
;
return
NS_OK
;
}
}
;
NS_IMPL_ISUPPORTS
(
nsRequestObserverProxy
nsIRequestObserver
nsIRequestObserverProxy
)
NS_IMETHODIMP
nsRequestObserverProxy
:
:
OnStartRequest
(
nsIRequest
*
request
nsISupports
*
context
)
{
MOZ_ASSERT
(
!
context
|
|
context
=
=
mContext
)
;
LOG
(
(
"
nsRequestObserverProxy
:
:
OnStartRequest
[
this
=
%
p
req
=
%
p
]
\
n
"
this
request
)
)
;
nsOnStartRequestEvent
*
ev
=
new
nsOnStartRequestEvent
(
this
request
)
;
if
(
!
ev
)
return
NS_ERROR_OUT_OF_MEMORY
;
LOG
(
(
"
post
startevent
=
%
p
\
n
"
ev
)
)
;
nsresult
rv
=
FireEvent
(
ev
)
;
if
(
NS_FAILED
(
rv
)
)
delete
ev
;
return
rv
;
}
NS_IMETHODIMP
nsRequestObserverProxy
:
:
OnStopRequest
(
nsIRequest
*
request
nsISupports
*
context
nsresult
status
)
{
MOZ_ASSERT
(
!
context
|
|
context
=
=
mContext
)
;
LOG
(
(
"
nsRequestObserverProxy
:
OnStopRequest
[
this
=
%
p
req
=
%
p
status
=
%
"
PRIx32
"
]
\
n
"
this
request
static_cast
<
uint32_t
>
(
status
)
)
)
;
nsOnStopRequestEvent
*
ev
=
new
nsOnStopRequestEvent
(
this
request
)
;
if
(
!
ev
)
return
NS_ERROR_OUT_OF_MEMORY
;
LOG
(
(
"
post
stopevent
=
%
p
\
n
"
ev
)
)
;
nsresult
rv
=
FireEvent
(
ev
)
;
if
(
NS_FAILED
(
rv
)
)
delete
ev
;
return
rv
;
}
NS_IMETHODIMP
nsRequestObserverProxy
:
:
Init
(
nsIRequestObserver
*
observer
nsISupports
*
context
)
{
NS_ENSURE_ARG_POINTER
(
observer
)
;
mObserver
=
new
nsMainThreadPtrHolder
<
nsIRequestObserver
>
(
"
nsRequestObserverProxy
:
:
mObserver
"
observer
)
;
mContext
=
new
nsMainThreadPtrHolder
<
nsISupports
>
(
"
nsRequestObserverProxy
:
:
mContext
"
context
)
;
return
NS_OK
;
}
nsresult
nsRequestObserverProxy
:
:
FireEvent
(
nsARequestObserverEvent
*
event
)
{
nsCOMPtr
<
nsIEventTarget
>
mainThread
(
GetMainThreadEventTarget
(
)
)
;
return
mainThread
-
>
Dispatch
(
event
NS_DISPATCH_NORMAL
)
;
}
}
}
