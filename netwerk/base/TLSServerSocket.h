#
ifndef
mozilla_net_TLSServerSocket_h
#
define
mozilla_net_TLSServerSocket_h
#
include
"
nsITLSServerSocket
.
h
"
#
include
"
nsServerSocket
.
h
"
#
include
"
nsString
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
seccomon
.
h
"
namespace
mozilla
{
namespace
net
{
class
TLSServerSocket
final
:
public
nsServerSocket
public
nsITLSServerSocket
{
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_FORWARD_NSISERVERSOCKET
(
nsServerSocket
:
:
)
NS_DECL_NSITLSSERVERSOCKET
virtual
void
CreateClientTransport
(
PRFileDesc
*
clientFD
const
NetAddr
&
clientAddr
)
override
;
virtual
nsresult
SetSocketDefaults
(
)
override
;
virtual
nsresult
OnSocketListen
(
)
override
;
TLSServerSocket
(
)
=
default
;
private
:
virtual
~
TLSServerSocket
(
)
=
default
;
static
SECStatus
AuthCertificateHook
(
void
*
arg
PRFileDesc
*
fd
PRBool
checksig
PRBool
isServer
)
;
nsCOMPtr
<
nsIX509Cert
>
mServerCert
;
}
;
class
TLSServerConnectionInfo
:
public
nsITLSServerConnectionInfo
public
nsITLSClientStatus
{
friend
class
TLSServerSocket
;
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSITLSSERVERCONNECTIONINFO
NS_DECL_NSITLSCLIENTSTATUS
TLSServerConnectionInfo
(
)
=
default
;
private
:
virtual
~
TLSServerConnectionInfo
(
)
;
static
void
HandshakeCallback
(
PRFileDesc
*
aFD
void
*
aArg
)
;
nsresult
HandshakeCallback
(
PRFileDesc
*
aFD
)
;
RefPtr
<
TLSServerSocket
>
mServerSocket
;
nsISocketTransport
*
mTransport
{
nullptr
}
;
nsCOMPtr
<
nsIX509Cert
>
mPeerCert
;
int16_t
mTlsVersionUsed
{
TLS_VERSION_UNKNOWN
}
;
nsCString
mCipherName
;
uint32_t
mKeyLength
{
0
}
;
uint32_t
mMacLength
{
0
}
;
mozilla
:
:
Mutex
mLock
{
"
TLSServerConnectionInfo
.
mLock
"
}
;
nsCOMPtr
<
nsITLSServerSecurityObserver
>
mSecurityObserver
MOZ_GUARDED_BY
(
mLock
)
;
}
;
}
}
#
endif
