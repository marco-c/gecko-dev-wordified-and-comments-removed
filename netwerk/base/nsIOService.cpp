#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
nsIOService
.
h
"
#
include
"
nsIProtocolHandler
.
h
"
#
include
"
nsIFileProtocolHandler
.
h
"
#
include
"
nscore
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
prprf
.
h
"
#
include
"
nsErrorService
.
h
"
#
include
"
netCore
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsXPCOM
.
h
"
#
include
"
nsIProxiedProtocolHandler
.
h
"
#
include
"
nsIProxyInfo
.
h
"
#
include
"
nsDNSService2
.
h
"
#
include
"
nsEscape
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsSimpleNestedURI
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsIConsoleService
.
h
"
#
include
"
nsIUploadChannel2
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
nsIProtocolProxyCallback
.
h
"
#
include
"
nsICancelable
.
h
"
#
include
"
nsINetworkLinkService
.
h
"
#
include
"
nsAsyncRedirectVerifyHelper
.
h
"
#
include
"
nsURLHelper
.
h
"
#
include
"
nsIProtocolProxyService2
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
mozilla
/
AppShutdown
.
h
"
#
include
"
mozilla
/
LoadInfo
.
h
"
#
include
"
mozilla
/
net
/
NeckoCommon
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
net
/
DNS
.
h
"
#
include
"
mozilla
/
ipc
/
URIUtils
.
h
"
#
include
"
mozilla
/
net
/
NeckoChild
.
h
"
#
include
"
mozilla
/
net
/
NeckoParent
.
h
"
#
include
"
mozilla
/
dom
/
ClientInfo
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
dom
/
nsHTTPSOnlyUtils
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorkerDescriptor
.
h
"
#
include
"
mozilla
/
net
/
CaptivePortalService
.
h
"
#
include
"
mozilla
/
net
/
NetworkConnectivityService
.
h
"
#
include
"
mozilla
/
net
/
SocketProcessHost
.
h
"
#
include
"
mozilla
/
net
/
SocketProcessParent
.
h
"
#
include
"
mozilla
/
net
/
SSLTokensCache
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsContentSecurityManager
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
mozilla
/
StaticPrefs_network
.
h
"
#
include
"
mozilla
/
StaticPrefs_security
.
h
"
#
include
"
nsNSSComponent
.
h
"
#
include
"
ssl
.
h
"
#
ifdef
MOZ_WIDGET_GTK
#
include
"
nsGIOProtocolHandler
.
h
"
#
endif
namespace
mozilla
{
namespace
net
{
using
mozilla
:
:
Maybe
;
using
mozilla
:
:
dom
:
:
ClientInfo
;
using
mozilla
:
:
dom
:
:
ServiceWorkerDescriptor
;
#
define
PORT_PREF_PREFIX
"
network
.
security
.
ports
.
"
#
define
PORT_PREF
(
x
)
PORT_PREF_PREFIX
x
#
define
MANAGE_OFFLINE_STATUS_PREF
"
network
.
manage
-
offline
-
status
"
#
define
NECKO_BUFFER_CACHE_COUNT_PREF
"
network
.
buffer
.
cache
.
count
"
#
define
NECKO_BUFFER_CACHE_SIZE_PREF
"
network
.
buffer
.
cache
.
size
"
#
define
NETWORK_CAPTIVE_PORTAL_PREF
"
network
.
captive
-
portal
-
service
.
enabled
"
#
define
WEBRTC_PREF_PREFIX
"
media
.
peerconnection
.
"
#
define
NETWORK_DNS_PREF
"
network
.
dns
.
"
#
define
MAX_RECURSION_COUNT
50
nsIOService
*
gIOService
;
static
bool
gHasWarnedUploadChannel2
;
static
bool
gCaptivePortalEnabled
=
false
;
static
LazyLogModule
gIOServiceLog
(
"
nsIOService
"
)
;
#
undef
LOG
#
define
LOG
(
args
)
MOZ_LOG
(
gIOServiceLog
LogLevel
:
:
Debug
args
)
int16_t
gBadPortList
[
]
=
{
1
7
9
11
13
15
17
19
20
21
22
23
25
37
42
43
53
69
77
79
87
95
101
102
103
104
109
110
111
113
115
117
119
123
135
137
139
143
161
179
389
427
465
512
513
514
515
526
530
531
532
540
548
554
556
563
587
601
636
989
990
993
995
1719
1720
1723
2049
3659
4045
5060
5061
6000
6566
6665
6666
6667
6668
6669
6697
10080
0
}
;
static
const
char
kProfileChangeNetTeardownTopic
[
]
=
"
profile
-
change
-
net
-
teardown
"
;
static
const
char
kProfileChangeNetRestoreTopic
[
]
=
"
profile
-
change
-
net
-
restore
"
;
static
const
char
kProfileDoChange
[
]
=
"
profile
-
do
-
change
"
;
uint32_t
nsIOService
:
:
gDefaultSegmentSize
=
4096
;
uint32_t
nsIOService
:
:
gDefaultSegmentCount
=
24
;
uint32_t
nsIOService
:
:
sSocketProcessCrashedCount
=
0
;
nsIOService
:
:
nsIOService
(
)
:
mLastOfflineStateChange
(
PR_IntervalNow
(
)
)
mLastConnectivityChange
(
PR_IntervalNow
(
)
)
mLastNetworkLinkChange
(
PR_IntervalNow
(
)
)
{
}
static
const
char
*
gCallbackPrefs
[
]
=
{
PORT_PREF_PREFIX
MANAGE_OFFLINE_STATUS_PREF
NECKO_BUFFER_CACHE_COUNT_PREF
NECKO_BUFFER_CACHE_SIZE_PREF
NETWORK_CAPTIVE_PORTAL_PREF
nullptr
}
;
static
const
char
*
gCallbackPrefsForSocketProcess
[
]
=
{
WEBRTC_PREF_PREFIX
NETWORK_DNS_PREF
"
network
.
ssl_tokens_cache_enabled
"
"
network
.
send_ODA_to_content_directly
"
"
network
.
trr
.
"
"
doh
-
rollout
.
"
"
network
.
dns
.
disableIPv6
"
"
network
.
dns
.
skipTRR
-
when
-
parental
-
control
-
enabled
"
"
network
.
offline
-
mirrors
-
connectivity
"
"
network
.
disable
-
localhost
-
when
-
offline
"
"
network
.
proxy
.
parse_pac_on_socket_process
"
"
network
.
proxy
.
allow_hijacking_localhost
"
"
network
.
connectivity
-
service
.
"
"
network
.
captive
-
portal
-
service
.
testMode
"
nullptr
}
;
static
const
char
*
gCallbackSecurityPrefs
[
]
=
{
"
security
.
tls
.
version
.
min
"
"
security
.
tls
.
version
.
max
"
"
security
.
tls
.
version
.
enable
-
deprecated
"
"
security
.
tls
.
hello_downgrade_check
"
"
security
.
ssl
.
require_safe_negotiation
"
"
security
.
ssl
.
enable_false_start
"
"
security
.
ssl
.
enable_alpn
"
"
security
.
tls
.
enable_0rtt_data
"
"
security
.
ssl
.
disable_session_identifiers
"
"
security
.
tls
.
enable_post_handshake_auth
"
"
security
.
tls
.
enable_delegated_credentials
"
"
security
.
ssl
.
enable_ocsp_stapling
"
"
security
.
ssl
.
enable_ocsp_must_staple
"
"
security
.
pki
.
certificate_transparency
.
mode
"
nullptr
}
;
nsresult
nsIOService
:
:
Init
(
)
{
nsCOMPtr
<
nsIErrorService
>
errorService
=
nsErrorService
:
:
GetOrCreate
(
)
;
MOZ_ALWAYS_TRUE
(
errorService
)
;
errorService
-
>
RegisterErrorStringBundle
(
NS_ERROR_MODULE_NETWORK
NECKO_MSGS_URL
)
;
SSLTokensCache
:
:
Init
(
)
;
InitializeCaptivePortalService
(
)
;
for
(
int
i
=
0
;
gBadPortList
[
i
]
;
i
+
+
)
{
MOZ_PUSH_IGNORE_THREAD_SAFETY
mRestrictedPortList
.
AppendElement
(
gBadPortList
[
i
]
)
;
MOZ_POP_THREAD_SAFETY
}
Preferences
:
:
RegisterPrefixCallbacks
(
nsIOService
:
:
PrefsChanged
gCallbackPrefs
this
)
;
PrefsChanged
(
)
;
mSocketProcessTopicBlockedList
.
Insert
(
nsLiteralCString
(
NS_XPCOM_WILL_SHUTDOWN_OBSERVER_ID
)
)
;
mSocketProcessTopicBlockedList
.
Insert
(
nsLiteralCString
(
NS_XPCOM_SHUTDOWN_OBSERVER_ID
)
)
;
mSocketProcessTopicBlockedList
.
Insert
(
"
xpcom
-
shutdown
-
threads
"
_ns
)
;
mSocketProcessTopicBlockedList
.
Insert
(
"
profile
-
do
-
change
"
_ns
)
;
mSocketProcessTopicBlockedList
.
Insert
(
"
network
:
socket
-
process
-
crashed
"
_ns
)
;
mObserverService
=
services
:
:
GetObserverService
(
)
;
AddObserver
(
this
kProfileChangeNetTeardownTopic
true
)
;
AddObserver
(
this
kProfileChangeNetRestoreTopic
true
)
;
AddObserver
(
this
kProfileDoChange
true
)
;
AddObserver
(
this
NS_XPCOM_SHUTDOWN_OBSERVER_ID
true
)
;
AddObserver
(
this
NS_NETWORK_LINK_TOPIC
true
)
;
AddObserver
(
this
NS_NETWORK_ID_CHANGED_TOPIC
true
)
;
AddObserver
(
this
NS_WIDGET_WAKE_OBSERVER_TOPIC
true
)
;
if
(
XRE_IsParentProcess
(
)
)
{
AddObserver
(
this
"
profile
-
initial
-
state
"
true
)
;
AddObserver
(
this
NS_WIDGET_SLEEP_OBSERVER_TOPIC
true
)
;
}
if
(
IsSocketProcessChild
(
)
)
{
Preferences
:
:
RegisterCallbacks
(
nsIOService
:
:
OnTLSPrefChange
gCallbackSecurityPrefs
this
)
;
}
gIOService
=
this
;
InitializeNetworkLinkService
(
)
;
InitializeProtocolProxyService
(
)
;
SetOffline
(
false
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsIOService
:
:
AddObserver
(
nsIObserver
*
aObserver
const
char
*
aTopic
bool
aOwnsWeak
)
{
if
(
!
mObserverService
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
mObserverService
-
>
AddObserver
(
aObserver
aTopic
aOwnsWeak
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
XRE_IsParentProcess
(
)
)
{
return
NS_OK
;
}
nsAutoCString
topic
(
aTopic
)
;
if
(
SameCOMIdentity
(
aObserver
static_cast
<
nsIObserver
*
>
(
this
)
)
)
{
mIOServiceTopicList
.
Insert
(
topic
)
;
return
NS_OK
;
}
if
(
!
UseSocketProcess
(
)
)
{
return
NS_OK
;
}
if
(
mSocketProcessTopicBlockedList
.
Contains
(
topic
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
mObserverTopicForSocketProcess
.
Contains
(
topic
)
)
{
return
NS_ERROR_FAILURE
;
}
mObserverTopicForSocketProcess
.
Insert
(
topic
)
;
if
(
mIOServiceTopicList
.
Contains
(
topic
)
)
{
return
NS_ERROR_FAILURE
;
}
return
mObserverService
-
>
AddObserver
(
this
aTopic
true
)
;
}
NS_IMETHODIMP
nsIOService
:
:
RemoveObserver
(
nsIObserver
*
aObserver
const
char
*
aTopic
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
nsIOService
:
:
EnumerateObservers
(
const
char
*
aTopic
nsISimpleEnumerator
*
*
anEnumerator
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
nsIOService
:
:
NotifyObservers
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aSomeData
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
nsIOService
:
:
~
nsIOService
(
)
{
if
(
gIOService
)
{
MOZ_ASSERT
(
gIOService
=
=
this
)
;
gIOService
=
nullptr
;
}
}
void
nsIOService
:
:
OnTLSPrefChange
(
const
char
*
aPref
void
*
aSelf
)
{
MOZ_ASSERT
(
IsSocketProcessChild
(
)
)
;
if
(
!
EnsureNSSInitializedChromeOrContent
(
)
)
{
LOG
(
(
"
NSS
not
initialized
.
"
)
)
;
return
;
}
nsAutoCString
pref
(
aPref
)
;
if
(
HandleTLSPrefChange
(
pref
)
)
{
LOG
(
(
"
HandleTLSPrefChange
done
"
)
)
;
}
else
if
(
pref
.
EqualsLiteral
(
"
security
.
ssl
.
enable_ocsp_stapling
"
)
|
|
pref
.
EqualsLiteral
(
"
security
.
ssl
.
enable_ocsp_must_staple
"
)
|
|
pref
.
EqualsLiteral
(
"
security
.
pki
.
certificate_transparency
.
mode
"
)
)
{
SetValidationOptionsCommon
(
)
;
}
}
nsresult
nsIOService
:
:
InitializeCaptivePortalService
(
)
{
if
(
XRE_GetProcessType
(
)
!
=
GeckoProcessType_Default
)
{
return
NS_OK
;
}
mCaptivePortalService
=
do_GetService
(
NS_CAPTIVEPORTAL_CID
)
;
if
(
mCaptivePortalService
)
{
return
static_cast
<
CaptivePortalService
*
>
(
mCaptivePortalService
.
get
(
)
)
-
>
Initialize
(
)
;
}
RefPtr
<
NetworkConnectivityService
>
ncs
=
NetworkConnectivityService
:
:
GetSingleton
(
)
;
return
NS_OK
;
}
nsresult
nsIOService
:
:
InitializeSocketTransportService
(
)
{
nsresult
rv
=
NS_OK
;
if
(
!
mSocketTransportService
)
{
mSocketTransportService
=
do_GetService
(
NS_SOCKETTRANSPORTSERVICE_CONTRACTID
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
failed
to
get
socket
transport
service
"
)
;
}
}
if
(
mSocketTransportService
)
{
rv
=
mSocketTransportService
-
>
Init
(
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
socket
transport
service
init
failed
"
)
;
mSocketTransportService
-
>
SetOffline
(
false
)
;
}
return
rv
;
}
nsresult
nsIOService
:
:
InitializeNetworkLinkService
(
)
{
nsresult
rv
=
NS_OK
;
if
(
mNetworkLinkServiceInitialized
)
return
rv
;
if
(
!
NS_IsMainThread
(
)
)
{
NS_WARNING
(
"
Network
link
service
should
be
created
on
main
thread
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
!
XRE_IsParentProcess
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
mNetworkLinkService
=
do_GetService
(
NS_NETWORK_LINK_SERVICE_CONTRACTID
&
rv
)
;
if
(
mNetworkLinkService
)
{
mNetworkLinkServiceInitialized
=
true
;
}
OnNetworkLinkEvent
(
NS_NETWORK_LINK_DATA_UNKNOWN
)
;
return
rv
;
}
nsresult
nsIOService
:
:
InitializeProtocolProxyService
(
)
{
nsresult
rv
=
NS_OK
;
if
(
XRE_IsParentProcess
(
)
)
{
Unused
<
<
do_GetService
(
NS_PROTOCOLPROXYSERVICE_CONTRACTID
&
rv
)
;
}
return
rv
;
}
already_AddRefed
<
nsIOService
>
nsIOService
:
:
GetInstance
(
)
{
if
(
!
gIOService
)
{
RefPtr
<
nsIOService
>
ios
=
new
nsIOService
(
)
;
if
(
NS_SUCCEEDED
(
ios
-
>
Init
(
)
)
)
{
MOZ_ASSERT
(
gIOService
=
=
ios
.
get
(
)
)
;
return
ios
.
forget
(
)
;
}
}
return
do_AddRef
(
gIOService
)
;
}
class
SocketProcessListenerProxy
:
public
SocketProcessHost
:
:
Listener
{
public
:
SocketProcessListenerProxy
(
)
=
default
;
void
OnProcessLaunchComplete
(
SocketProcessHost
*
aHost
bool
aSucceeded
)
{
if
(
!
gIOService
)
{
return
;
}
gIOService
-
>
OnProcessLaunchComplete
(
aHost
aSucceeded
)
;
}
void
OnProcessUnexpectedShutdown
(
SocketProcessHost
*
aHost
)
{
if
(
!
gIOService
)
{
return
;
}
gIOService
-
>
OnProcessUnexpectedShutdown
(
aHost
)
;
}
}
;
bool
nsIOService
:
:
TooManySocketProcessCrash
(
)
{
return
sSocketProcessCrashedCount
>
=
StaticPrefs
:
:
network_max_socket_process_failed_count
(
)
;
}
void
nsIOService
:
:
IncreaseSocketProcessCrashCount
(
)
{
MOZ_ASSERT
(
IsNeckoChild
(
)
)
;
sSocketProcessCrashedCount
+
+
;
}
nsresult
nsIOService
:
:
LaunchSocketProcess
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
XRE_GetProcessType
(
)
!
=
GeckoProcessType_Default
)
{
return
NS_OK
;
}
if
(
AppShutdown
:
:
IsInOrBeyond
(
ShutdownPhase
:
:
AppShutdownConfirmed
)
)
{
return
NS_OK
;
}
if
(
mSocketProcess
)
{
return
NS_OK
;
}
if
(
PR_GetEnv
(
"
MOZ_DISABLE_SOCKET_PROCESS
"
)
)
{
LOG
(
(
"
nsIOService
skipping
LaunchSocketProcess
because
of
the
env
"
)
)
;
return
NS_OK
;
}
if
(
!
StaticPrefs
:
:
network_process_enabled
(
)
)
{
LOG
(
(
"
nsIOService
skipping
LaunchSocketProcess
because
of
the
pref
"
)
)
;
return
NS_OK
;
}
Preferences
:
:
RegisterPrefixCallbacks
(
nsIOService
:
:
NotifySocketProcessPrefsChanged
gCallbackPrefsForSocketProcess
this
)
;
mSocketProcess
=
new
SocketProcessHost
(
new
SocketProcessListenerProxy
(
)
)
;
LOG
(
(
"
nsIOService
:
:
LaunchSocketProcess
"
)
)
;
if
(
!
mSocketProcess
-
>
Launch
(
)
)
{
NS_WARNING
(
"
Failed
to
launch
socket
process
!
!
"
)
;
DestroySocketProcess
(
)
;
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
void
nsIOService
:
:
DestroySocketProcess
(
)
{
LOG
(
(
"
nsIOService
:
:
DestroySocketProcess
"
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
XRE_GetProcessType
(
)
!
=
GeckoProcessType_Default
|
|
!
mSocketProcess
)
{
return
;
}
Preferences
:
:
UnregisterPrefixCallbacks
(
nsIOService
:
:
NotifySocketProcessPrefsChanged
gCallbackPrefsForSocketProcess
this
)
;
mSocketProcess
-
>
Shutdown
(
)
;
mSocketProcess
=
nullptr
;
}
bool
nsIOService
:
:
SocketProcessReady
(
)
{
return
mSocketProcess
&
&
mSocketProcess
-
>
IsConnected
(
)
;
}
static
bool
sUseSocketProcess
=
false
;
static
bool
sUseSocketProcessChecked
=
false
;
bool
nsIOService
:
:
UseSocketProcess
(
bool
aCheckAgain
)
{
if
(
sUseSocketProcessChecked
&
&
!
aCheckAgain
)
{
return
sUseSocketProcess
;
}
sUseSocketProcessChecked
=
true
;
sUseSocketProcess
=
false
;
if
(
PR_GetEnv
(
"
MOZ_DISABLE_SOCKET_PROCESS
"
)
)
{
return
sUseSocketProcess
;
}
if
(
TooManySocketProcessCrash
(
)
)
{
LOG
(
(
"
TooManySocketProcessCrash
"
)
)
;
return
sUseSocketProcess
;
}
if
(
PR_GetEnv
(
"
MOZ_FORCE_USE_SOCKET_PROCESS
"
)
)
{
sUseSocketProcess
=
true
;
return
sUseSocketProcess
;
}
if
(
StaticPrefs
:
:
network_process_enabled
(
)
)
{
sUseSocketProcess
=
StaticPrefs
:
:
network_http_network_access_on_socket_process_enabled
(
)
;
}
return
sUseSocketProcess
;
}
void
nsIOService
:
:
NotifySocketProcessPrefsChanged
(
const
char
*
aName
void
*
aSelf
)
{
static_cast
<
nsIOService
*
>
(
aSelf
)
-
>
NotifySocketProcessPrefsChanged
(
aName
)
;
}
void
nsIOService
:
:
NotifySocketProcessPrefsChanged
(
const
char
*
aName
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
XRE_IsParentProcess
(
)
)
{
return
;
}
if
(
!
StaticPrefs
:
:
network_process_enabled
(
)
)
{
return
;
}
dom
:
:
Pref
pref
(
nsCString
(
aName
)
false
false
Nothing
(
)
Nothing
(
)
)
;
Preferences
:
:
GetPreference
(
&
pref
GeckoProcessType_Socket
"
"
_ns
)
;
auto
sendPrefUpdate
=
[
pref
]
(
)
{
Unused
<
<
gIOService
-
>
mSocketProcess
-
>
GetActor
(
)
-
>
SendPreferenceUpdate
(
pref
)
;
}
;
CallOrWaitForSocketProcess
(
sendPrefUpdate
)
;
}
void
nsIOService
:
:
OnProcessLaunchComplete
(
SocketProcessHost
*
aHost
bool
aSucceeded
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
LOG
(
(
"
nsIOService
:
:
OnProcessLaunchComplete
aSucceeded
=
%
d
\
n
"
aSucceeded
)
)
;
mSocketProcessLaunchComplete
=
aSucceeded
;
if
(
mShutdown
|
|
!
SocketProcessReady
(
)
|
|
!
aSucceeded
)
{
mPendingEvents
.
Clear
(
)
;
return
;
}
if
(
!
mPendingEvents
.
IsEmpty
(
)
)
{
nsTArray
<
std
:
:
function
<
void
(
)
>
>
pendingEvents
=
std
:
:
move
(
mPendingEvents
)
;
for
(
auto
&
func
:
pendingEvents
)
{
func
(
)
;
}
}
}
void
nsIOService
:
:
CallOrWaitForSocketProcess
(
const
std
:
:
function
<
void
(
)
>
&
aFunc
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
IsSocketProcessLaunchComplete
(
)
&
&
SocketProcessReady
(
)
)
{
aFunc
(
)
;
}
else
{
mPendingEvents
.
AppendElement
(
aFunc
)
;
LaunchSocketProcess
(
)
;
}
}
int32_t
nsIOService
:
:
SocketProcessPid
(
)
{
if
(
!
mSocketProcess
)
{
return
0
;
}
if
(
SocketProcessParent
*
actor
=
mSocketProcess
-
>
GetActor
(
)
)
{
return
(
int32_t
)
actor
-
>
OtherPid
(
)
;
}
return
0
;
}
bool
nsIOService
:
:
IsSocketProcessLaunchComplete
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
mSocketProcessLaunchComplete
;
}
void
nsIOService
:
:
OnProcessUnexpectedShutdown
(
SocketProcessHost
*
aHost
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
LOG
(
(
"
nsIOService
:
:
OnProcessUnexpectedShutdown
\
n
"
)
)
;
DestroySocketProcess
(
)
;
mPendingEvents
.
Clear
(
)
;
if
(
!
UseSocketProcess
(
)
)
{
return
;
}
sSocketProcessCrashedCount
+
+
;
if
(
TooManySocketProcessCrash
(
)
)
{
sUseSocketProcessChecked
=
false
;
DNSServiceWrapper
:
:
SwitchToBackupDNSService
(
)
;
}
nsCOMPtr
<
nsIObserverService
>
observerService
=
services
:
:
GetObserverService
(
)
;
if
(
observerService
)
{
(
void
)
observerService
-
>
NotifyObservers
(
nullptr
"
network
:
socket
-
process
-
crashed
"
nullptr
)
;
}
if
(
UseSocketProcess
(
)
)
{
MOZ_ALWAYS_SUCCEEDS
(
NS_DispatchToMainThread
(
NewRunnableMethod
(
"
nsIOService
:
:
LaunchSocketProcess
"
this
&
nsIOService
:
:
LaunchSocketProcess
)
)
)
;
}
}
RefPtr
<
MemoryReportingProcess
>
nsIOService
:
:
GetSocketProcessMemoryReporter
(
)
{
if
(
!
StaticPrefs
:
:
network_process_enabled
(
)
|
|
!
SocketProcessReady
(
)
)
{
return
nullptr
;
}
return
new
SocketProcessMemoryReporter
(
)
;
}
NS_IMETHODIMP
nsIOService
:
:
SocketProcessTelemetryPing
(
)
{
CallOrWaitForSocketProcess
(
[
]
(
)
{
Unused
<
<
gIOService
-
>
mSocketProcess
-
>
GetActor
(
)
-
>
SendSocketProcessTelemetryPing
(
)
;
}
)
;
return
NS_OK
;
}
NS_IMPL_ISUPPORTS
(
nsIOService
nsIIOService
nsINetUtil
nsISpeculativeConnect
nsIObserver
nsIIOServiceInternal
nsISupportsWeakReference
nsIObserverService
)
nsresult
nsIOService
:
:
RecheckCaptivePortal
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Must
be
called
on
the
main
thread
"
)
;
if
(
!
mCaptivePortalService
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIRunnable
>
task
=
NewRunnableMethod
(
"
nsIOService
:
:
RecheckCaptivePortal
"
mCaptivePortalService
&
nsICaptivePortalService
:
:
RecheckCaptivePortal
)
;
return
NS_DispatchToMainThread
(
task
)
;
}
nsresult
nsIOService
:
:
RecheckCaptivePortalIfLocalRedirect
(
nsIChannel
*
newChan
)
{
nsresult
rv
;
if
(
!
mCaptivePortalService
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIURI
>
uri
;
rv
=
newChan
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsCString
host
;
rv
=
uri
-
>
GetHost
(
host
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
NetAddr
addr
;
if
(
NS_SUCCEEDED
(
addr
.
InitFromString
(
host
)
)
&
&
addr
.
IsIPAddrLocal
(
)
)
{
RecheckCaptivePortal
(
)
;
}
return
NS_OK
;
}
nsresult
nsIOService
:
:
AsyncOnChannelRedirect
(
nsIChannel
*
oldChan
nsIChannel
*
newChan
uint32_t
flags
nsAsyncRedirectVerifyHelper
*
helper
)
{
RecheckCaptivePortalIfLocalRedirect
(
newChan
)
;
nsCOMPtr
<
nsIChannelEventSink
>
sink
=
do_GetService
(
NS_CONTENTSECURITYMANAGER_CONTRACTID
)
;
if
(
sink
)
{
nsresult
rv
=
helper
-
>
DelegateOnChannelRedirect
(
sink
oldChan
newChan
flags
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
}
nsCOMArray
<
nsIChannelEventSink
>
entries
;
mChannelEventSinks
.
GetEntries
(
entries
)
;
int32_t
len
=
entries
.
Count
(
)
;
for
(
int32_t
i
=
0
;
i
<
len
;
+
+
i
)
{
nsresult
rv
=
helper
-
>
DelegateOnChannelRedirect
(
entries
[
i
]
oldChan
newChan
flags
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
}
nsCOMPtr
<
nsIHttpChannel
>
httpChan
(
do_QueryInterface
(
oldChan
)
)
;
if
(
httpChan
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIURI
>
newURI
;
newChan
-
>
GetURI
(
getter_AddRefs
(
newURI
)
)
;
MOZ_ASSERT
(
newURI
)
;
nsAutoCString
scheme
;
newURI
-
>
GetScheme
(
scheme
)
;
MOZ_ASSERT
(
!
scheme
.
IsEmpty
(
)
)
;
Telemetry
:
:
AccumulateCategoricalKeyed
(
scheme
oldChan
-
>
IsDocument
(
)
?
Telemetry
:
:
LABELS_NETWORK_HTTP_REDIRECT_TO_SCHEME
:
:
topLevel
:
Telemetry
:
:
LABELS_NETWORK_HTTP_REDIRECT_TO_SCHEME
:
:
subresource
)
;
}
return
NS_OK
;
}
nsresult
nsIOService
:
:
CacheProtocolHandler
(
const
char
*
scheme
nsIProtocolHandler
*
handler
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
for
(
unsigned
int
i
=
0
;
i
<
NS_N
(
gScheme
)
;
i
+
+
)
{
if
(
!
nsCRT
:
:
strcasecmp
(
scheme
gScheme
[
i
]
)
)
{
nsresult
rv
;
NS_ASSERTION
(
!
mWeakHandler
[
i
]
"
Protocol
handler
already
cached
"
)
;
nsCOMPtr
<
nsISupportsWeakReference
>
factoryPtr
=
do_QueryInterface
(
handler
&
rv
)
;
if
(
!
factoryPtr
)
{
#
ifdef
DEBUG_dp
printf
(
"
DEBUG
:
%
s
protcol
handler
doesn
'
t
support
weak
ref
.
Not
cached
.
\
n
"
scheme
)
;
#
endif
return
NS_ERROR_FAILURE
;
}
mWeakHandler
[
i
]
=
do_GetWeakReference
(
handler
)
;
return
NS_OK
;
}
}
return
NS_ERROR_FAILURE
;
}
nsresult
nsIOService
:
:
GetCachedProtocolHandler
(
const
char
*
scheme
nsIProtocolHandler
*
*
result
uint32_t
start
uint32_t
end
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
uint32_t
len
=
end
-
start
-
1
;
for
(
unsigned
int
i
=
0
;
i
<
NS_N
(
gScheme
)
;
i
+
+
)
{
if
(
!
mWeakHandler
[
i
]
)
continue
;
if
(
end
?
(
!
nsCRT
:
:
strncasecmp
(
scheme
+
start
gScheme
[
i
]
len
)
&
&
gScheme
[
i
]
[
len
]
=
=
'
\
0
'
)
:
(
!
nsCRT
:
:
strcasecmp
(
scheme
gScheme
[
i
]
)
)
)
{
return
CallQueryReferent
(
mWeakHandler
[
i
]
.
get
(
)
result
)
;
}
}
return
NS_ERROR_FAILURE
;
}
static
bool
UsesExternalProtocolHandler
(
const
char
*
aScheme
)
{
if
(
"
file
"
_ns
.
Equals
(
aScheme
)
|
|
"
chrome
"
_ns
.
Equals
(
aScheme
)
|
|
"
resource
"
_ns
.
Equals
(
aScheme
)
)
{
return
false
;
}
for
(
const
auto
&
forcedExternalScheme
:
gForcedExternalSchemes
)
{
if
(
!
nsCRT
:
:
strcasecmp
(
forcedExternalScheme
aScheme
)
)
{
return
true
;
}
}
nsAutoCString
pref
(
"
network
.
protocol
-
handler
.
external
.
"
)
;
pref
+
=
aScheme
;
return
Preferences
:
:
GetBool
(
pref
.
get
(
)
false
)
;
}
NS_IMETHODIMP
nsIOService
:
:
GetProtocolHandler
(
const
char
*
scheme
nsIProtocolHandler
*
*
result
)
{
nsresult
rv
;
NS_ENSURE_ARG_POINTER
(
scheme
)
;
rv
=
GetCachedProtocolHandler
(
scheme
result
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
return
rv
;
if
(
scheme
[
0
]
!
=
'
\
0
'
&
&
!
UsesExternalProtocolHandler
(
scheme
)
)
{
nsAutoCString
contractID
(
NS_NETWORK_PROTOCOL_CONTRACTID_PREFIX
)
;
contractID
+
=
scheme
;
ToLowerCase
(
contractID
)
;
rv
=
CallGetService
(
contractID
.
get
(
)
result
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
CacheProtocolHandler
(
scheme
*
result
)
;
return
rv
;
}
#
ifdef
MOZ_WIDGET_GTK
RefPtr
<
nsGIOProtocolHandler
>
gioHandler
=
nsGIOProtocolHandler
:
:
GetSingleton
(
)
;
if
(
gioHandler
-
>
IsSupportedProtocol
(
nsCString
(
scheme
)
)
)
{
gioHandler
.
forget
(
result
)
;
return
NS_OK
;
}
#
endif
}
rv
=
CallGetService
(
NS_NETWORK_PROTOCOL_CONTRACTID_PREFIX
"
default
"
result
)
;
if
(
NS_FAILED
(
rv
)
)
return
NS_ERROR_UNKNOWN_PROTOCOL
;
return
rv
;
}
NS_IMETHODIMP
nsIOService
:
:
ExtractScheme
(
const
nsACString
&
inURI
nsACString
&
scheme
)
{
return
net_ExtractURLScheme
(
inURI
scheme
)
;
}
NS_IMETHODIMP
nsIOService
:
:
HostnameIsLocalIPAddress
(
nsIURI
*
aURI
bool
*
aResult
)
{
NS_ENSURE_ARG_POINTER
(
aURI
)
;
nsCOMPtr
<
nsIURI
>
innerURI
=
NS_GetInnermostURI
(
aURI
)
;
NS_ENSURE_ARG_POINTER
(
innerURI
)
;
nsAutoCString
host
;
nsresult
rv
=
innerURI
-
>
GetAsciiHost
(
host
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
*
aResult
=
false
;
NetAddr
addr
;
if
(
NS_SUCCEEDED
(
addr
.
InitFromString
(
host
)
)
&
&
addr
.
IsIPAddrLocal
(
)
)
{
*
aResult
=
true
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsIOService
:
:
HostnameIsSharedIPAddress
(
nsIURI
*
aURI
bool
*
aResult
)
{
NS_ENSURE_ARG_POINTER
(
aURI
)
;
nsCOMPtr
<
nsIURI
>
innerURI
=
NS_GetInnermostURI
(
aURI
)
;
NS_ENSURE_ARG_POINTER
(
innerURI
)
;
nsAutoCString
host
;
nsresult
rv
=
innerURI
-
>
GetAsciiHost
(
host
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
*
aResult
=
false
;
NetAddr
addr
;
if
(
NS_SUCCEEDED
(
addr
.
InitFromString
(
host
)
)
&
&
addr
.
IsIPAddrShared
(
)
)
{
*
aResult
=
true
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsIOService
:
:
GetProtocolFlags
(
const
char
*
scheme
uint32_t
*
flags
)
{
nsCOMPtr
<
nsIProtocolHandler
>
handler
;
nsresult
rv
=
GetProtocolHandler
(
scheme
getter_AddRefs
(
handler
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
rv
=
handler
-
>
GetProtocolFlags
(
flags
)
;
#
if
!
IS_ORIGIN_IS_FULL_SPEC_DEFINED
MOZ_RELEASE_ASSERT
(
!
(
*
flags
&
nsIProtocolHandler
:
:
ORIGIN_IS_FULL_SPEC
)
"
ORIGIN_IS_FULL_SPEC
is
unsupported
but
used
"
)
;
#
endif
return
rv
;
}
class
AutoIncrement
{
public
:
explicit
AutoIncrement
(
uint32_t
*
var
)
:
mVar
(
var
)
{
+
+
*
var
;
}
~
AutoIncrement
(
)
{
-
-
*
mVar
;
}
private
:
uint32_t
*
mVar
;
}
;
nsresult
nsIOService
:
:
NewURI
(
const
nsACString
&
aSpec
const
char
*
aCharset
nsIURI
*
aBaseURI
nsIURI
*
*
result
)
{
return
NS_NewURI
(
result
aSpec
aCharset
aBaseURI
)
;
}
NS_IMETHODIMP
nsIOService
:
:
NewFileURI
(
nsIFile
*
file
nsIURI
*
*
result
)
{
nsresult
rv
;
NS_ENSURE_ARG_POINTER
(
file
)
;
nsCOMPtr
<
nsIProtocolHandler
>
handler
;
rv
=
GetProtocolHandler
(
"
file
"
getter_AddRefs
(
handler
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
nsCOMPtr
<
nsIFileProtocolHandler
>
fileHandler
(
do_QueryInterface
(
handler
&
rv
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
return
fileHandler
-
>
NewFileURI
(
file
result
)
;
}
already_AddRefed
<
nsIURI
>
nsIOService
:
:
CreateExposableURI
(
nsIURI
*
aURI
)
{
MOZ_ASSERT
(
aURI
"
Must
have
a
URI
"
)
;
nsCOMPtr
<
nsIURI
>
uri
=
aURI
;
nsAutoCString
userPass
;
uri
-
>
GetUserPass
(
userPass
)
;
if
(
!
userPass
.
IsEmpty
(
)
)
{
DebugOnly
<
nsresult
>
rv
=
NS_MutateURI
(
uri
)
.
SetUserPass
(
"
"
_ns
)
.
Finalize
(
uri
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
&
&
uri
"
Mutating
URI
should
never
fail
"
)
;
}
return
uri
.
forget
(
)
;
}
NS_IMETHODIMP
nsIOService
:
:
CreateExposableURI
(
nsIURI
*
aURI
nsIURI
*
*
_result
)
{
NS_ENSURE_ARG_POINTER
(
aURI
)
;
NS_ENSURE_ARG_POINTER
(
_result
)
;
nsCOMPtr
<
nsIURI
>
exposableURI
=
CreateExposableURI
(
aURI
)
;
exposableURI
.
forget
(
_result
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsIOService
:
:
NewChannelFromURI
(
nsIURI
*
aURI
nsINode
*
aLoadingNode
nsIPrincipal
*
aLoadingPrincipal
nsIPrincipal
*
aTriggeringPrincipal
uint32_t
aSecurityFlags
nsContentPolicyType
aContentPolicyType
nsIChannel
*
*
result
)
{
return
NewChannelFromURIWithProxyFlags
(
aURI
nullptr
0
aLoadingNode
aLoadingPrincipal
aTriggeringPrincipal
aSecurityFlags
aContentPolicyType
result
)
;
}
nsresult
nsIOService
:
:
NewChannelFromURIWithClientAndController
(
nsIURI
*
aURI
nsINode
*
aLoadingNode
nsIPrincipal
*
aLoadingPrincipal
nsIPrincipal
*
aTriggeringPrincipal
const
Maybe
<
ClientInfo
>
&
aLoadingClientInfo
const
Maybe
<
ServiceWorkerDescriptor
>
&
aController
uint32_t
aSecurityFlags
nsContentPolicyType
aContentPolicyType
uint32_t
aSandboxFlags
bool
aSkipCheckForBrokenURLOrZeroSized
nsIChannel
*
*
aResult
)
{
return
NewChannelFromURIWithProxyFlagsInternal
(
aURI
nullptr
0
aLoadingNode
aLoadingPrincipal
aTriggeringPrincipal
aLoadingClientInfo
aController
aSecurityFlags
aContentPolicyType
aSandboxFlags
aSkipCheckForBrokenURLOrZeroSized
aResult
)
;
}
NS_IMETHODIMP
nsIOService
:
:
NewChannelFromURIWithLoadInfo
(
nsIURI
*
aURI
nsILoadInfo
*
aLoadInfo
nsIChannel
*
*
result
)
{
return
NewChannelFromURIWithProxyFlagsInternal
(
aURI
nullptr
0
aLoadInfo
result
)
;
}
nsresult
nsIOService
:
:
NewChannelFromURIWithProxyFlagsInternal
(
nsIURI
*
aURI
nsIURI
*
aProxyURI
uint32_t
aProxyFlags
nsINode
*
aLoadingNode
nsIPrincipal
*
aLoadingPrincipal
nsIPrincipal
*
aTriggeringPrincipal
const
Maybe
<
ClientInfo
>
&
aLoadingClientInfo
const
Maybe
<
ServiceWorkerDescriptor
>
&
aController
uint32_t
aSecurityFlags
nsContentPolicyType
aContentPolicyType
uint32_t
aSandboxFlags
bool
aSkipCheckForBrokenURLOrZeroSized
nsIChannel
*
*
result
)
{
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
new
LoadInfo
(
aLoadingPrincipal
aTriggeringPrincipal
aLoadingNode
aSecurityFlags
aContentPolicyType
aLoadingClientInfo
aController
aSandboxFlags
aSkipCheckForBrokenURLOrZeroSized
)
;
return
NewChannelFromURIWithProxyFlagsInternal
(
aURI
aProxyURI
aProxyFlags
loadInfo
result
)
;
}
nsresult
nsIOService
:
:
NewChannelFromURIWithProxyFlagsInternal
(
nsIURI
*
aURI
nsIURI
*
aProxyURI
uint32_t
aProxyFlags
nsILoadInfo
*
aLoadInfo
nsIChannel
*
*
result
)
{
nsresult
rv
;
NS_ENSURE_ARG_POINTER
(
aURI
)
;
MOZ_ASSERT
(
aLoadInfo
"
can
not
create
channel
without
aLoadInfo
"
)
;
NS_ENSURE_ARG_POINTER
(
aLoadInfo
)
;
nsAutoCString
scheme
;
rv
=
aURI
-
>
GetScheme
(
scheme
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
nsCOMPtr
<
nsIProtocolHandler
>
handler
;
rv
=
GetProtocolHandler
(
scheme
.
get
(
)
getter_AddRefs
(
handler
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
uint32_t
protoFlags
;
rv
=
handler
-
>
DoGetProtocolFlags
(
aURI
&
protoFlags
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
nsCOMPtr
<
nsIChannel
>
channel
;
nsCOMPtr
<
nsIProxiedProtocolHandler
>
pph
=
do_QueryInterface
(
handler
)
;
if
(
pph
)
{
rv
=
pph
-
>
NewProxiedChannel
(
aURI
nullptr
aProxyFlags
aProxyURI
aLoadInfo
getter_AddRefs
(
channel
)
)
;
}
else
{
rv
=
handler
-
>
NewChannel
(
aURI
aLoadInfo
getter_AddRefs
(
channel
)
)
;
}
if
(
NS_FAILED
(
rv
)
)
return
rv
;
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
channel
-
>
LoadInfo
(
)
;
if
(
aLoadInfo
!
=
loadInfo
)
{
MOZ_ASSERT
(
false
"
newly
created
channel
must
have
a
loadinfo
attached
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
if
(
loadInfo
-
>
GetLoadingSandboxed
(
)
)
{
channel
-
>
SetOwner
(
nullptr
)
;
}
if
(
!
gHasWarnedUploadChannel2
&
&
scheme
.
EqualsLiteral
(
"
http
"
)
)
{
nsCOMPtr
<
nsIUploadChannel2
>
uploadChannel2
=
do_QueryInterface
(
channel
)
;
if
(
!
uploadChannel2
)
{
nsCOMPtr
<
nsIConsoleService
>
consoleService
=
do_GetService
(
NS_CONSOLESERVICE_CONTRACTID
)
;
if
(
consoleService
)
{
consoleService
-
>
LogStringMessage
(
u
"
Http
channel
implementation
"
"
doesn
'
t
support
nsIUploadChannel2
.
An
extension
has
"
"
supplied
a
non
-
functional
http
protocol
handler
.
This
will
"
"
break
behavior
and
in
future
releases
not
work
at
all
.
"
)
;
}
gHasWarnedUploadChannel2
=
true
;
}
}
channel
.
forget
(
result
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsIOService
:
:
NewChannelFromURIWithProxyFlags
(
nsIURI
*
aURI
nsIURI
*
aProxyURI
uint32_t
aProxyFlags
nsINode
*
aLoadingNode
nsIPrincipal
*
aLoadingPrincipal
nsIPrincipal
*
aTriggeringPrincipal
uint32_t
aSecurityFlags
nsContentPolicyType
aContentPolicyType
nsIChannel
*
*
result
)
{
return
NewChannelFromURIWithProxyFlagsInternal
(
aURI
aProxyURI
aProxyFlags
aLoadingNode
aLoadingPrincipal
aTriggeringPrincipal
Maybe
<
ClientInfo
>
(
)
Maybe
<
ServiceWorkerDescriptor
>
(
)
aSecurityFlags
aContentPolicyType
0
false
result
)
;
}
NS_IMETHODIMP
nsIOService
:
:
NewChannel
(
const
nsACString
&
aSpec
const
char
*
aCharset
nsIURI
*
aBaseURI
nsINode
*
aLoadingNode
nsIPrincipal
*
aLoadingPrincipal
nsIPrincipal
*
aTriggeringPrincipal
uint32_t
aSecurityFlags
nsContentPolicyType
aContentPolicyType
nsIChannel
*
*
result
)
{
nsresult
rv
;
nsCOMPtr
<
nsIURI
>
uri
;
rv
=
NewURI
(
aSpec
aCharset
aBaseURI
getter_AddRefs
(
uri
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
return
NewChannelFromURI
(
uri
aLoadingNode
aLoadingPrincipal
aTriggeringPrincipal
aSecurityFlags
aContentPolicyType
result
)
;
}
bool
nsIOService
:
:
IsLinkUp
(
)
{
InitializeNetworkLinkService
(
)
;
if
(
!
mNetworkLinkService
)
{
return
true
;
}
bool
isLinkUp
;
nsresult
rv
;
rv
=
mNetworkLinkService
-
>
GetIsLinkUp
(
&
isLinkUp
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
true
;
}
return
isLinkUp
;
}
NS_IMETHODIMP
nsIOService
:
:
GetOffline
(
bool
*
offline
)
{
if
(
StaticPrefs
:
:
network_offline_mirrors_connectivity
(
)
)
{
*
offline
=
mOffline
|
|
!
mConnectivity
;
}
else
{
*
offline
=
mOffline
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsIOService
:
:
SetOffline
(
bool
offline
)
{
return
SetOfflineInternal
(
offline
)
;
}
nsresult
nsIOService
:
:
SetOfflineInternal
(
bool
offline
bool
notifySocketProcess
)
{
LOG
(
(
"
nsIOService
:
:
SetOffline
offline
=
%
d
\
n
"
offline
)
)
;
if
(
(
mShutdown
|
|
mOfflineForProfileChange
)
&
&
!
offline
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
mSetOfflineValue
=
offline
;
if
(
mSettingOffline
)
{
return
NS_OK
;
}
mSettingOffline
=
true
;
nsCOMPtr
<
nsIObserverService
>
observerService
=
services
:
:
GetObserverService
(
)
;
NS_ASSERTION
(
observerService
"
The
observer
service
should
not
be
null
"
)
;
if
(
XRE_IsParentProcess
(
)
)
{
if
(
observerService
)
{
(
void
)
observerService
-
>
NotifyObservers
(
nullptr
NS_IPC_IOSERVICE_SET_OFFLINE_TOPIC
offline
?
u
"
true
"
:
u
"
false
"
)
;
}
if
(
SocketProcessReady
(
)
&
&
notifySocketProcess
)
{
Unused
<
<
mSocketProcess
-
>
GetActor
(
)
-
>
SendSetOffline
(
offline
)
;
}
}
nsIIOService
*
subject
=
static_cast
<
nsIIOService
*
>
(
this
)
;
while
(
mSetOfflineValue
!
=
mOffline
)
{
offline
=
mSetOfflineValue
;
if
(
offline
&
&
!
mOffline
)
{
mOffline
=
true
;
if
(
observerService
)
{
observerService
-
>
NotifyObservers
(
subject
NS_IOSERVICE_GOING_OFFLINE_TOPIC
u
"
"
NS_IOSERVICE_OFFLINE
)
;
}
if
(
mSocketTransportService
)
mSocketTransportService
-
>
SetOffline
(
true
)
;
mLastOfflineStateChange
=
PR_IntervalNow
(
)
;
if
(
observerService
)
{
observerService
-
>
NotifyObservers
(
subject
NS_IOSERVICE_OFFLINE_STATUS_TOPIC
u
"
"
NS_IOSERVICE_OFFLINE
)
;
}
}
else
if
(
!
offline
&
&
mOffline
)
{
InitializeSocketTransportService
(
)
;
mOffline
=
false
;
mLastOfflineStateChange
=
PR_IntervalNow
(
)
;
if
(
observerService
&
&
mConnectivity
)
{
observerService
-
>
NotifyObservers
(
subject
NS_IOSERVICE_OFFLINE_STATUS_TOPIC
(
u
"
"
NS_IOSERVICE_ONLINE
)
)
;
}
}
}
if
(
(
mShutdown
|
|
mOfflineForProfileChange
)
&
&
mOffline
)
{
if
(
mSocketTransportService
)
{
DebugOnly
<
nsresult
>
rv
=
mSocketTransportService
-
>
Shutdown
(
mShutdown
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
socket
transport
service
shutdown
failed
"
)
;
}
}
mSettingOffline
=
false
;
return
NS_OK
;
}
NS_IMETHODIMP
nsIOService
:
:
GetConnectivity
(
bool
*
aConnectivity
)
{
*
aConnectivity
=
mConnectivity
;
return
NS_OK
;
}
NS_IMETHODIMP
nsIOService
:
:
SetConnectivity
(
bool
aConnectivity
)
{
LOG
(
(
"
nsIOService
:
:
SetConnectivity
aConnectivity
=
%
d
\
n
"
aConnectivity
)
)
;
if
(
XRE_IsParentProcess
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
return
SetConnectivityInternal
(
aConnectivity
)
;
}
nsresult
nsIOService
:
:
SetConnectivityInternal
(
bool
aConnectivity
)
{
LOG
(
(
"
nsIOService
:
:
SetConnectivityInternal
aConnectivity
=
%
d
\
n
"
aConnectivity
)
)
;
if
(
mConnectivity
=
=
aConnectivity
)
{
return
NS_OK
;
}
mConnectivity
=
aConnectivity
;
mLastConnectivityChange
=
PR_IntervalNow
(
)
;
if
(
mCaptivePortalService
)
{
if
(
aConnectivity
&
&
gCaptivePortalEnabled
)
{
static_cast
<
CaptivePortalService
*
>
(
mCaptivePortalService
.
get
(
)
)
-
>
Start
(
)
;
}
else
{
static_cast
<
CaptivePortalService
*
>
(
mCaptivePortalService
.
get
(
)
)
-
>
Stop
(
)
;
}
}
nsCOMPtr
<
nsIObserverService
>
observerService
=
services
:
:
GetObserverService
(
)
;
if
(
!
observerService
)
{
return
NS_OK
;
}
if
(
XRE_IsParentProcess
(
)
)
{
observerService
-
>
NotifyObservers
(
nullptr
NS_IPC_IOSERVICE_SET_CONNECTIVITY_TOPIC
aConnectivity
?
u
"
true
"
:
u
"
false
"
)
;
if
(
SocketProcessReady
(
)
)
{
Unused
<
<
mSocketProcess
-
>
GetActor
(
)
-
>
SendSetConnectivity
(
aConnectivity
)
;
}
}
if
(
mOffline
)
{
return
NS_OK
;
}
if
(
aConnectivity
)
{
observerService
-
>
NotifyObservers
(
static_cast
<
nsIIOService
*
>
(
this
)
NS_IOSERVICE_OFFLINE_STATUS_TOPIC
(
u
"
"
NS_IOSERVICE_ONLINE
)
)
;
}
else
{
observerService
-
>
NotifyObservers
(
static_cast
<
nsIIOService
*
>
(
this
)
NS_IOSERVICE_GOING_OFFLINE_TOPIC
u
"
"
NS_IOSERVICE_OFFLINE
)
;
observerService
-
>
NotifyObservers
(
static_cast
<
nsIIOService
*
>
(
this
)
NS_IOSERVICE_OFFLINE_STATUS_TOPIC
u
"
"
NS_IOSERVICE_OFFLINE
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsIOService
:
:
AllowPort
(
int32_t
inPort
const
char
*
scheme
bool
*
_retval
)
{
int32_t
port
=
inPort
;
if
(
port
=
=
-
1
)
{
*
_retval
=
true
;
return
NS_OK
;
}
if
(
port
<
=
0
|
|
port
>
std
:
:
numeric_limits
<
uint16_t
>
:
:
max
(
)
)
{
*
_retval
=
false
;
return
NS_OK
;
}
nsTArray
<
int32_t
>
restrictedPortList
;
{
MutexAutoLock
lock
(
mMutex
)
;
restrictedPortList
.
Assign
(
mRestrictedPortList
)
;
}
int32_t
badPortListCnt
=
restrictedPortList
.
Length
(
)
;
for
(
int
i
=
0
;
i
<
badPortListCnt
;
i
+
+
)
{
if
(
port
=
=
restrictedPortList
[
i
]
)
{
*
_retval
=
false
;
if
(
!
scheme
)
return
NS_OK
;
if
(
!
NS_IsMainThread
(
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIProtocolHandler
>
handler
;
nsresult
rv
=
GetProtocolHandler
(
scheme
getter_AddRefs
(
handler
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
return
handler
-
>
AllowPort
(
port
scheme
_retval
)
;
}
}
*
_retval
=
true
;
return
NS_OK
;
}
void
nsIOService
:
:
PrefsChanged
(
const
char
*
pref
void
*
self
)
{
static_cast
<
nsIOService
*
>
(
self
)
-
>
PrefsChanged
(
pref
)
;
}
void
nsIOService
:
:
PrefsChanged
(
const
char
*
pref
)
{
if
(
!
pref
|
|
strcmp
(
pref
PORT_PREF
(
"
banned
"
)
)
=
=
0
)
{
ParsePortList
(
PORT_PREF
(
"
banned
"
)
false
)
;
}
if
(
!
pref
|
|
strcmp
(
pref
PORT_PREF
(
"
banned
.
override
"
)
)
=
=
0
)
{
ParsePortList
(
PORT_PREF
(
"
banned
.
override
"
)
true
)
;
}
if
(
!
pref
|
|
strcmp
(
pref
MANAGE_OFFLINE_STATUS_PREF
)
=
=
0
)
{
bool
manage
;
if
(
mNetworkLinkServiceInitialized
&
&
NS_SUCCEEDED
(
Preferences
:
:
GetBool
(
MANAGE_OFFLINE_STATUS_PREF
&
manage
)
)
)
{
LOG
(
(
"
nsIOService
:
:
PrefsChanged
ManageOfflineStatus
manage
=
%
d
\
n
"
manage
)
)
;
SetManageOfflineStatus
(
manage
)
;
}
}
if
(
!
pref
|
|
strcmp
(
pref
NECKO_BUFFER_CACHE_COUNT_PREF
)
=
=
0
)
{
int32_t
count
;
if
(
NS_SUCCEEDED
(
Preferences
:
:
GetInt
(
NECKO_BUFFER_CACHE_COUNT_PREF
&
count
)
)
)
{
if
(
count
>
0
)
gDefaultSegmentCount
=
count
;
}
}
if
(
!
pref
|
|
strcmp
(
pref
NECKO_BUFFER_CACHE_SIZE_PREF
)
=
=
0
)
{
int32_t
size
;
if
(
NS_SUCCEEDED
(
Preferences
:
:
GetInt
(
NECKO_BUFFER_CACHE_SIZE_PREF
&
size
)
)
)
{
if
(
size
>
0
&
&
size
<
1024
*
1024
)
gDefaultSegmentSize
=
size
;
}
NS_WARNING_ASSERTION
(
!
(
size
&
(
size
-
1
)
)
"
network
segment
size
is
not
a
power
of
2
!
"
)
;
}
if
(
!
pref
|
|
strcmp
(
pref
NETWORK_CAPTIVE_PORTAL_PREF
)
=
=
0
)
{
nsresult
rv
=
Preferences
:
:
GetBool
(
NETWORK_CAPTIVE_PORTAL_PREF
&
gCaptivePortalEnabled
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
mCaptivePortalService
)
{
if
(
gCaptivePortalEnabled
)
{
static_cast
<
CaptivePortalService
*
>
(
mCaptivePortalService
.
get
(
)
)
-
>
Start
(
)
;
}
else
{
static_cast
<
CaptivePortalService
*
>
(
mCaptivePortalService
.
get
(
)
)
-
>
Stop
(
)
;
}
}
}
}
void
nsIOService
:
:
ParsePortList
(
const
char
*
pref
bool
remove
)
{
nsAutoCString
portList
;
nsTArray
<
int32_t
>
restrictedPortList
;
{
MutexAutoLock
lock
(
mMutex
)
;
restrictedPortList
.
Assign
(
std
:
:
move
(
mRestrictedPortList
)
)
;
}
Preferences
:
:
GetCString
(
pref
portList
)
;
if
(
!
portList
.
IsVoid
(
)
)
{
nsTArray
<
nsCString
>
portListArray
;
ParseString
(
portList
'
'
portListArray
)
;
uint32_t
index
;
for
(
index
=
0
;
index
<
portListArray
.
Length
(
)
;
index
+
+
)
{
portListArray
[
index
]
.
StripWhitespace
(
)
;
int32_t
portBegin
portEnd
;
if
(
PR_sscanf
(
portListArray
[
index
]
.
get
(
)
"
%
d
-
%
d
"
&
portBegin
&
portEnd
)
=
=
2
)
{
if
(
(
portBegin
<
65536
)
&
&
(
portEnd
<
65536
)
)
{
int32_t
curPort
;
if
(
remove
)
{
for
(
curPort
=
portBegin
;
curPort
<
=
portEnd
;
curPort
+
+
)
{
restrictedPortList
.
RemoveElement
(
curPort
)
;
}
}
else
{
for
(
curPort
=
portBegin
;
curPort
<
=
portEnd
;
curPort
+
+
)
{
restrictedPortList
.
AppendElement
(
curPort
)
;
}
}
}
}
else
{
nsresult
aErrorCode
;
int32_t
port
=
portListArray
[
index
]
.
ToInteger
(
&
aErrorCode
)
;
if
(
NS_SUCCEEDED
(
aErrorCode
)
&
&
port
<
65536
)
{
if
(
remove
)
{
restrictedPortList
.
RemoveElement
(
port
)
;
}
else
{
restrictedPortList
.
AppendElement
(
port
)
;
}
}
}
}
}
MutexAutoLock
lock
(
mMutex
)
;
mRestrictedPortList
.
Assign
(
std
:
:
move
(
restrictedPortList
)
)
;
}
class
nsWakeupNotifier
:
public
Runnable
{
public
:
explicit
nsWakeupNotifier
(
nsIIOServiceInternal
*
ioService
)
:
Runnable
(
"
net
:
:
nsWakeupNotifier
"
)
mIOService
(
ioService
)
{
}
NS_IMETHOD
Run
(
)
override
{
return
mIOService
-
>
NotifyWakeup
(
)
;
}
private
:
virtual
~
nsWakeupNotifier
(
)
=
default
;
nsCOMPtr
<
nsIIOServiceInternal
>
mIOService
;
}
;
NS_IMETHODIMP
nsIOService
:
:
NotifyWakeup
(
)
{
nsCOMPtr
<
nsIObserverService
>
observerService
=
services
:
:
GetObserverService
(
)
;
NS_ASSERTION
(
observerService
"
The
observer
service
should
not
be
null
"
)
;
if
(
observerService
&
&
StaticPrefs
:
:
network_notify_changed
(
)
)
{
(
void
)
observerService
-
>
NotifyObservers
(
nullptr
NS_NETWORK_LINK_TOPIC
(
u
"
"
NS_NETWORK_LINK_DATA_CHANGED
)
)
;
}
RecheckCaptivePortal
(
)
;
return
NS_OK
;
}
void
nsIOService
:
:
SetHttpHandlerAlreadyShutingDown
(
)
{
if
(
!
mShutdown
&
&
!
mOfflineForProfileChange
)
{
mNetTearingDownStarted
=
PR_IntervalNow
(
)
;
mHttpHandlerAlreadyShutingDown
=
true
;
}
}
NS_IMETHODIMP
nsIOService
:
:
Observe
(
nsISupports
*
subject
const
char
*
topic
const
char16_t
*
data
)
{
if
(
UseSocketProcess
(
)
&
&
SocketProcessReady
(
)
&
&
mObserverTopicForSocketProcess
.
Contains
(
nsDependentCString
(
topic
)
)
)
{
nsCString
topicStr
(
topic
)
;
nsString
dataStr
(
data
)
;
Unused
<
<
mSocketProcess
-
>
GetActor
(
)
-
>
SendNotifyObserver
(
topicStr
dataStr
)
;
}
if
(
!
strcmp
(
topic
kProfileChangeNetTeardownTopic
)
)
{
if
(
!
mHttpHandlerAlreadyShutingDown
)
{
mNetTearingDownStarted
=
PR_IntervalNow
(
)
;
}
mHttpHandlerAlreadyShutingDown
=
false
;
if
(
!
mOffline
)
{
mOfflineForProfileChange
=
true
;
SetOfflineInternal
(
true
false
)
;
}
}
else
if
(
!
strcmp
(
topic
kProfileChangeNetRestoreTopic
)
)
{
if
(
mOfflineForProfileChange
)
{
mOfflineForProfileChange
=
false
;
SetOfflineInternal
(
false
false
)
;
}
}
else
if
(
!
strcmp
(
topic
kProfileDoChange
)
)
{
if
(
data
&
&
u
"
startup
"
_ns
.
Equals
(
data
)
)
{
InitializeNetworkLinkService
(
)
;
mNetworkLinkServiceInitialized
=
true
;
PrefsChanged
(
MANAGE_OFFLINE_STATUS_PREF
)
;
nsCOMPtr
<
nsISupports
>
cookieServ
=
do_GetService
(
NS_COOKIESERVICE_CONTRACTID
)
;
}
}
else
if
(
!
strcmp
(
topic
NS_XPCOM_SHUTDOWN_OBSERVER_ID
)
)
{
mShutdown
=
true
;
if
(
!
mHttpHandlerAlreadyShutingDown
&
&
!
mOfflineForProfileChange
)
{
mNetTearingDownStarted
=
PR_IntervalNow
(
)
;
}
mHttpHandlerAlreadyShutingDown
=
false
;
SetOfflineInternal
(
true
false
)
;
if
(
mCaptivePortalService
)
{
static_cast
<
CaptivePortalService
*
>
(
mCaptivePortalService
.
get
(
)
)
-
>
Stop
(
)
;
mCaptivePortalService
=
nullptr
;
}
SSLTokensCache
:
:
Shutdown
(
)
;
DestroySocketProcess
(
)
;
if
(
IsSocketProcessChild
(
)
)
{
Preferences
:
:
UnregisterCallbacks
(
nsIOService
:
:
OnTLSPrefChange
gCallbackSecurityPrefs
this
)
;
NSSShutdownForSocketProcess
(
)
;
}
}
else
if
(
!
strcmp
(
topic
NS_NETWORK_LINK_TOPIC
)
)
{
OnNetworkLinkEvent
(
NS_ConvertUTF16toUTF8
(
data
)
.
get
(
)
)
;
}
else
if
(
!
strcmp
(
topic
NS_NETWORK_ID_CHANGED_TOPIC
)
)
{
LOG
(
(
"
nsIOService
:
:
OnNetworkLinkEvent
Network
id
changed
"
)
)
;
}
else
if
(
!
strcmp
(
topic
NS_WIDGET_WAKE_OBSERVER_TOPIC
)
)
{
nsCOMPtr
<
nsIRunnable
>
wakeupNotifier
=
new
nsWakeupNotifier
(
this
)
;
NS_DispatchToMainThread
(
wakeupNotifier
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsIOService
:
:
ParseRequestContentType
(
const
nsACString
&
aTypeHeader
nsACString
&
aCharset
bool
*
aHadCharset
nsACString
&
aContentType
)
{
net_ParseRequestContentType
(
aTypeHeader
aContentType
aCharset
aHadCharset
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsIOService
:
:
ParseResponseContentType
(
const
nsACString
&
aTypeHeader
nsACString
&
aCharset
bool
*
aHadCharset
nsACString
&
aContentType
)
{
net_ParseContentType
(
aTypeHeader
aContentType
aCharset
aHadCharset
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsIOService
:
:
ProtocolHasFlags
(
nsIURI
*
uri
uint32_t
flags
bool
*
result
)
{
NS_ENSURE_ARG
(
uri
)
;
*
result
=
false
;
nsAutoCString
scheme
;
nsresult
rv
=
uri
-
>
GetScheme
(
scheme
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
uint32_t
protocolFlags
;
nsCOMPtr
<
nsIProtocolHandler
>
handler
;
rv
=
GetProtocolHandler
(
scheme
.
get
(
)
getter_AddRefs
(
handler
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
handler
-
>
DoGetProtocolFlags
(
uri
&
protocolFlags
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
*
result
=
(
protocolFlags
&
flags
)
=
=
flags
;
return
NS_OK
;
}
NS_IMETHODIMP
nsIOService
:
:
URIChainHasFlags
(
nsIURI
*
uri
uint32_t
flags
bool
*
result
)
{
nsresult
rv
=
ProtocolHasFlags
(
uri
flags
result
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
*
result
)
{
return
rv
;
}
nsCOMPtr
<
nsINestedURI
>
nestedURI
=
do_QueryInterface
(
uri
)
;
while
(
nestedURI
)
{
nsCOMPtr
<
nsIURI
>
innerURI
;
rv
=
nestedURI
-
>
GetInnerURI
(
getter_AddRefs
(
innerURI
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
ProtocolHasFlags
(
innerURI
flags
result
)
;
if
(
*
result
)
{
return
rv
;
}
nestedURI
=
do_QueryInterface
(
innerURI
)
;
}
return
rv
;
}
NS_IMETHODIMP
nsIOService
:
:
SetManageOfflineStatus
(
bool
aManage
)
{
LOG
(
(
"
nsIOService
:
:
SetManageOfflineStatus
aManage
=
%
d
\
n
"
aManage
)
)
;
mManageLinkStatus
=
aManage
;
if
(
!
mManageLinkStatus
)
{
SetConnectivityInternal
(
true
)
;
return
NS_OK
;
}
InitializeNetworkLinkService
(
)
;
OnNetworkLinkEvent
(
NS_NETWORK_LINK_DATA_UNKNOWN
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsIOService
:
:
GetManageOfflineStatus
(
bool
*
aManage
)
{
*
aManage
=
mManageLinkStatus
;
return
NS_OK
;
}
nsresult
nsIOService
:
:
OnNetworkLinkEvent
(
const
char
*
data
)
{
if
(
IsNeckoChild
(
)
|
|
IsSocketProcessChild
(
)
)
{
return
NS_OK
;
}
if
(
mShutdown
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsCString
dataAsString
(
data
)
;
for
(
auto
*
cp
:
mozilla
:
:
dom
:
:
ContentParent
:
:
AllProcesses
(
mozilla
:
:
dom
:
:
ContentParent
:
:
eLive
)
)
{
PNeckoParent
*
neckoParent
=
SingleManagedOrNull
(
cp
-
>
ManagedPNeckoParent
(
)
)
;
if
(
!
neckoParent
)
{
continue
;
}
Unused
<
<
neckoParent
-
>
SendNetworkChangeNotification
(
dataAsString
)
;
}
LOG
(
(
"
nsIOService
:
:
OnNetworkLinkEvent
data
:
%
s
\
n
"
data
)
)
;
if
(
!
mNetworkLinkService
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
mManageLinkStatus
)
{
LOG
(
(
"
nsIOService
:
:
OnNetworkLinkEvent
mManageLinkStatus
=
false
\
n
"
)
)
;
return
NS_OK
;
}
bool
isUp
=
true
;
if
(
!
strcmp
(
data
NS_NETWORK_LINK_DATA_CHANGED
)
)
{
mLastNetworkLinkChange
=
PR_IntervalNow
(
)
;
RecheckCaptivePortal
(
)
;
return
NS_OK
;
}
if
(
!
strcmp
(
data
NS_NETWORK_LINK_DATA_DOWN
)
)
{
isUp
=
false
;
}
else
if
(
!
strcmp
(
data
NS_NETWORK_LINK_DATA_UP
)
)
{
isUp
=
true
;
}
else
if
(
!
strcmp
(
data
NS_NETWORK_LINK_DATA_UNKNOWN
)
)
{
nsresult
rv
=
mNetworkLinkService
-
>
GetIsLinkUp
(
&
isUp
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
NS_WARNING
(
"
Unhandled
network
event
!
"
)
;
return
NS_OK
;
}
return
SetConnectivityInternal
(
isUp
)
;
}
NS_IMETHODIMP
nsIOService
:
:
EscapeString
(
const
nsACString
&
aString
uint32_t
aEscapeType
nsACString
&
aResult
)
{
NS_ENSURE_ARG_MAX
(
aEscapeType
4
)
;
nsAutoCString
stringCopy
(
aString
)
;
nsCString
result
;
if
(
!
NS_Escape
(
stringCopy
result
(
nsEscapeMask
)
aEscapeType
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
aResult
.
Assign
(
result
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsIOService
:
:
EscapeURL
(
const
nsACString
&
aStr
uint32_t
aFlags
nsACString
&
aResult
)
{
aResult
.
Truncate
(
)
;
NS_EscapeURL
(
aStr
.
BeginReading
(
)
aStr
.
Length
(
)
aFlags
|
esc_AlwaysCopy
aResult
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsIOService
:
:
UnescapeString
(
const
nsACString
&
aStr
uint32_t
aFlags
nsACString
&
aResult
)
{
aResult
.
Truncate
(
)
;
NS_UnescapeURL
(
aStr
.
BeginReading
(
)
aStr
.
Length
(
)
aFlags
|
esc_AlwaysCopy
aResult
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsIOService
:
:
ExtractCharsetFromContentType
(
const
nsACString
&
aTypeHeader
nsACString
&
aCharset
int32_t
*
aCharsetStart
int32_t
*
aCharsetEnd
bool
*
aHadCharset
)
{
nsAutoCString
ignored
;
net_ParseContentType
(
aTypeHeader
ignored
aCharset
aHadCharset
aCharsetStart
aCharsetEnd
)
;
if
(
*
aHadCharset
&
&
*
aCharsetStart
=
=
*
aCharsetEnd
)
{
*
aHadCharset
=
false
;
}
return
NS_OK
;
}
class
IOServiceProxyCallback
final
:
public
nsIProtocolProxyCallback
{
~
IOServiceProxyCallback
(
)
=
default
;
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIPROTOCOLPROXYCALLBACK
IOServiceProxyCallback
(
nsIInterfaceRequestor
*
aCallbacks
nsIOService
*
aIOService
)
:
mCallbacks
(
aCallbacks
)
mIOService
(
aIOService
)
{
}
private
:
RefPtr
<
nsIInterfaceRequestor
>
mCallbacks
;
RefPtr
<
nsIOService
>
mIOService
;
}
;
NS_IMPL_ISUPPORTS
(
IOServiceProxyCallback
nsIProtocolProxyCallback
)
NS_IMETHODIMP
IOServiceProxyCallback
:
:
OnProxyAvailable
(
nsICancelable
*
request
nsIChannel
*
channel
nsIProxyInfo
*
pi
nsresult
status
)
{
nsAutoCString
type
;
if
(
NS_SUCCEEDED
(
status
)
&
&
pi
&
&
NS_SUCCEEDED
(
pi
-
>
GetType
(
type
)
)
&
&
!
type
.
EqualsLiteral
(
"
direct
"
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
channel
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_OK
;
}
nsAutoCString
scheme
;
rv
=
uri
-
>
GetScheme
(
scheme
)
;
if
(
NS_FAILED
(
rv
)
)
return
NS_OK
;
nsCOMPtr
<
nsIProtocolHandler
>
handler
;
rv
=
mIOService
-
>
GetProtocolHandler
(
scheme
.
get
(
)
getter_AddRefs
(
handler
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
NS_OK
;
nsCOMPtr
<
nsISpeculativeConnect
>
speculativeHandler
=
do_QueryInterface
(
handler
)
;
if
(
!
speculativeHandler
)
return
NS_OK
;
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
channel
-
>
LoadInfo
(
)
;
nsCOMPtr
<
nsIPrincipal
>
principal
=
loadInfo
-
>
GetLoadingPrincipal
(
)
;
nsLoadFlags
loadFlags
=
0
;
channel
-
>
GetLoadFlags
(
&
loadFlags
)
;
if
(
loadFlags
&
nsIRequest
:
:
LOAD_ANONYMOUS
)
{
speculativeHandler
-
>
SpeculativeAnonymousConnect
(
uri
principal
mCallbacks
)
;
}
else
{
speculativeHandler
-
>
SpeculativeConnect
(
uri
principal
mCallbacks
)
;
}
return
NS_OK
;
}
nsresult
nsIOService
:
:
SpeculativeConnectInternal
(
nsIURI
*
aURI
nsIPrincipal
*
aPrincipal
nsIInterfaceRequestor
*
aCallbacks
bool
aAnonymous
)
{
NS_ENSURE_ARG
(
aURI
)
;
if
(
!
aURI
-
>
SchemeIs
(
"
http
"
)
&
&
!
aURI
-
>
SchemeIs
(
"
https
"
)
)
{
return
NS_OK
;
}
if
(
IsNeckoChild
(
)
)
{
gNeckoChild
-
>
SendSpeculativeConnect
(
aURI
aPrincipal
aAnonymous
)
;
return
NS_OK
;
}
nsresult
rv
;
nsCOMPtr
<
nsIProtocolProxyService
>
pps
=
do_GetService
(
NS_PROTOCOLPROXYSERVICE_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIPrincipal
>
loadingPrincipal
=
aPrincipal
;
MOZ_ASSERT
(
aPrincipal
"
We
expect
passing
a
principal
here
.
"
)
;
if
(
!
aPrincipal
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsCOMPtr
<
nsIURI
>
httpsURI
;
if
(
aURI
-
>
SchemeIs
(
"
http
"
)
)
{
nsCOMPtr
<
nsILoadInfo
>
httpsOnlyCheckLoadInfo
=
new
LoadInfo
(
loadingPrincipal
loadingPrincipal
nullptr
nsILoadInfo
:
:
SEC_ONLY_FOR_EXPLICIT_CONTENTSEC_CHECK
nsIContentPolicy
:
:
TYPE_SPECULATIVE
)
;
if
(
nsHTTPSOnlyUtils
:
:
ShouldUpgradeRequest
(
aURI
httpsOnlyCheckLoadInfo
)
|
|
nsHTTPSOnlyUtils
:
:
ShouldUpgradeHttpsFirstRequest
(
aURI
httpsOnlyCheckLoadInfo
)
)
{
rv
=
NS_GetSecureUpgradedURI
(
aURI
getter_AddRefs
(
httpsURI
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aURI
=
httpsURI
.
get
(
)
;
}
}
nsCOMPtr
<
nsIChannel
>
channel
;
rv
=
NewChannelFromURI
(
aURI
nullptr
loadingPrincipal
nullptr
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_SEC_CONTEXT_IS_NULL
nsIContentPolicy
:
:
TYPE_SPECULATIVE
getter_AddRefs
(
channel
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
aAnonymous
)
{
nsLoadFlags
loadFlags
=
0
;
channel
-
>
GetLoadFlags
(
&
loadFlags
)
;
loadFlags
|
=
nsIRequest
:
:
LOAD_ANONYMOUS
;
channel
-
>
SetLoadFlags
(
loadFlags
)
;
}
nsCOMPtr
<
nsICancelable
>
cancelable
;
RefPtr
<
IOServiceProxyCallback
>
callback
=
new
IOServiceProxyCallback
(
aCallbacks
this
)
;
nsCOMPtr
<
nsIProtocolProxyService2
>
pps2
=
do_QueryInterface
(
pps
)
;
if
(
pps2
)
{
return
pps2
-
>
AsyncResolve2
(
channel
0
callback
nullptr
getter_AddRefs
(
cancelable
)
)
;
}
return
pps
-
>
AsyncResolve
(
channel
0
callback
nullptr
getter_AddRefs
(
cancelable
)
)
;
}
NS_IMETHODIMP
nsIOService
:
:
SpeculativeConnect
(
nsIURI
*
aURI
nsIPrincipal
*
aPrincipal
nsIInterfaceRequestor
*
aCallbacks
)
{
return
SpeculativeConnectInternal
(
aURI
aPrincipal
aCallbacks
false
)
;
}
NS_IMETHODIMP
nsIOService
:
:
SpeculativeAnonymousConnect
(
nsIURI
*
aURI
nsIPrincipal
*
aPrincipal
nsIInterfaceRequestor
*
aCallbacks
)
{
return
SpeculativeConnectInternal
(
aURI
aPrincipal
aCallbacks
true
)
;
}
NS_IMETHODIMP
nsIOService
:
:
NotImplemented
(
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
nsIOService
:
:
GetSocketProcessLaunched
(
bool
*
aResult
)
{
NS_ENSURE_ARG_POINTER
(
aResult
)
;
*
aResult
=
SocketProcessReady
(
)
;
return
NS_OK
;
}
bool
nsIOService
:
:
HasObservers
(
const
char
*
aTopic
)
{
MOZ_ASSERT
(
false
"
Calling
this
method
is
unexpected
"
)
;
return
false
;
}
NS_IMETHODIMP
nsIOService
:
:
GetSocketProcessId
(
uint64_t
*
aPid
)
{
NS_ENSURE_ARG_POINTER
(
aPid
)
;
*
aPid
=
0
;
if
(
!
mSocketProcess
)
{
return
NS_OK
;
}
if
(
SocketProcessParent
*
actor
=
mSocketProcess
-
>
GetActor
(
)
)
{
*
aPid
=
(
uint64_t
)
actor
-
>
OtherPid
(
)
;
}
return
NS_OK
;
}
}
}
