#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
nsIOService
.
h
"
#
include
"
nsIProtocolHandler
.
h
"
#
include
"
nsIFileProtocolHandler
.
h
"
#
include
"
nscore
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
prprf
.
h
"
#
include
"
nsErrorService
.
h
"
#
include
"
netCore
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIPrefService
.
h
"
#
include
"
nsXPCOM
.
h
"
#
include
"
nsIProxiedProtocolHandler
.
h
"
#
include
"
nsIProxyInfo
.
h
"
#
include
"
nsEscape
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsSimpleNestedURI
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsIConsoleService
.
h
"
#
include
"
nsIUploadChannel2
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
nsIScriptSecurityManager
.
h
"
#
include
"
nsIProtocolProxyCallback
.
h
"
#
include
"
nsICancelable
.
h
"
#
include
"
nsINetworkLinkService
.
h
"
#
include
"
nsPISocketTransportService
.
h
"
#
include
"
nsAsyncRedirectVerifyHelper
.
h
"
#
include
"
nsURLHelper
.
h
"
#
include
"
nsIProtocolProxyService2
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
mozilla
/
LoadInfo
.
h
"
#
include
"
mozilla
/
net
/
NeckoCommon
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
net
/
DNS
.
h
"
#
include
"
mozilla
/
ipc
/
URIUtils
.
h
"
#
include
"
mozilla
/
net
/
NeckoChild
.
h
"
#
include
"
mozilla
/
net
/
NeckoParent
.
h
"
#
include
"
mozilla
/
dom
/
ClientInfo
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorkerDescriptor
.
h
"
#
include
"
mozilla
/
net
/
CaptivePortalService
.
h
"
#
include
"
mozilla
/
net
/
NetworkConnectivityService
.
h
"
#
include
"
mozilla
/
net
/
SocketProcessHost
.
h
"
#
include
"
mozilla
/
net
/
SocketProcessParent
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
ReferrerPolicy
.
h
"
#
include
"
nsContentSecurityManager
.
h
"
#
include
"
nsContentUtils
.
h
"
namespace
mozilla
{
namespace
net
{
using
mozilla
:
:
Maybe
;
using
mozilla
:
:
dom
:
:
ClientInfo
;
using
mozilla
:
:
dom
:
:
ServiceWorkerDescriptor
;
#
define
PORT_PREF_PREFIX
"
network
.
security
.
ports
.
"
#
define
PORT_PREF
(
x
)
PORT_PREF_PREFIX
x
#
define
MANAGE_OFFLINE_STATUS_PREF
"
network
.
manage
-
offline
-
status
"
#
define
OFFLINE_MIRRORS_CONNECTIVITY
"
network
.
offline
-
mirrors
-
connectivity
"
#
define
NECKO_BUFFER_CACHE_COUNT_PREF
"
network
.
buffer
.
cache
.
count
"
#
define
NECKO_BUFFER_CACHE_SIZE_PREF
"
network
.
buffer
.
cache
.
size
"
#
define
NETWORK_NOTIFY_CHANGED_PREF
"
network
.
notify
.
changed
"
#
define
NETWORK_CAPTIVE_PORTAL_PREF
"
network
.
captive
-
portal
-
service
.
enabled
"
#
define
WEBRTC_PREF_PREFIX
"
media
.
peerconnection
.
"
#
define
MAX_RECURSION_COUNT
50
nsIOService
*
gIOService
;
static
bool
gHasWarnedUploadChannel2
;
static
bool
gCaptivePortalEnabled
=
false
;
static
LazyLogModule
gIOServiceLog
(
"
nsIOService
"
)
;
#
undef
LOG
#
define
LOG
(
args
)
MOZ_LOG
(
gIOServiceLog
LogLevel
:
:
Debug
args
)
int16_t
gBadPortList
[
]
=
{
1
7
9
11
13
15
17
19
20
21
22
23
25
37
42
43
53
77
79
87
95
101
102
103
104
109
110
111
113
115
117
119
123
135
139
143
179
389
427
465
512
513
514
515
526
530
531
532
540
548
556
563
587
601
636
993
995
2049
3659
4045
6000
6665
6666
6667
6668
6669
6697
0
}
;
static
const
char
kProfileChangeNetTeardownTopic
[
]
=
"
profile
-
change
-
net
-
teardown
"
;
static
const
char
kProfileChangeNetRestoreTopic
[
]
=
"
profile
-
change
-
net
-
restore
"
;
static
const
char
kProfileDoChange
[
]
=
"
profile
-
do
-
change
"
;
uint32_t
nsIOService
:
:
gDefaultSegmentSize
=
4096
;
uint32_t
nsIOService
:
:
gDefaultSegmentCount
=
24
;
bool
nsIOService
:
:
sIsDataURIUniqueOpaqueOrigin
=
false
;
bool
nsIOService
:
:
sBlockToplevelDataUriNavigations
=
false
;
bool
nsIOService
:
:
sBlockFTPSubresources
=
false
;
nsIOService
:
:
nsIOService
(
)
:
mOffline
(
true
)
mOfflineForProfileChange
(
false
)
mManageLinkStatus
(
false
)
mConnectivity
(
true
)
mOfflineMirrorsConnectivity
(
true
)
mSettingOffline
(
false
)
mSetOfflineValue
(
false
)
mSocketProcessLaunchComplete
(
false
)
mShutdown
(
false
)
mHttpHandlerAlreadyShutingDown
(
false
)
mNetworkLinkServiceInitialized
(
false
)
mChannelEventSinks
(
NS_CHANNEL_EVENT_SINK_CATEGORY
)
mNetworkNotifyChanged
(
true
)
mTotalRequests
(
0
)
mCacheWon
(
0
)
mNetWon
(
0
)
mLastOfflineStateChange
(
PR_IntervalNow
(
)
)
mLastConnectivityChange
(
PR_IntervalNow
(
)
)
mLastNetworkLinkChange
(
PR_IntervalNow
(
)
)
mNetTearingDownStarted
(
0
)
mSocketProcess
(
nullptr
)
{
}
static
const
char
*
gCallbackPrefs
[
]
=
{
PORT_PREF_PREFIX
MANAGE_OFFLINE_STATUS_PREF
NECKO_BUFFER_CACHE_COUNT_PREF
NECKO_BUFFER_CACHE_SIZE_PREF
NETWORK_NOTIFY_CHANGED_PREF
NETWORK_CAPTIVE_PORTAL_PREF
nullptr
}
;
static
const
char
*
gCallbackPrefsForSocketProcess
[
]
=
{
WEBRTC_PREF_PREFIX
nullptr
}
;
nsresult
nsIOService
:
:
Init
(
)
{
nsCOMPtr
<
nsIErrorService
>
errorService
=
nsErrorService
:
:
GetOrCreate
(
)
;
MOZ_ALWAYS_TRUE
(
errorService
)
;
errorService
-
>
RegisterErrorStringBundle
(
NS_ERROR_MODULE_NETWORK
NECKO_MSGS_URL
)
;
InitializeCaptivePortalService
(
)
;
for
(
int
i
=
0
;
gBadPortList
[
i
]
;
i
+
+
)
mRestrictedPortList
.
AppendElement
(
gBadPortList
[
i
]
)
;
Preferences
:
:
RegisterPrefixCallbacks
(
PREF_CHANGE_METHOD
(
nsIOService
:
:
PrefsChanged
)
gCallbackPrefs
this
)
;
PrefsChanged
(
)
;
nsCOMPtr
<
nsIObserverService
>
observerService
=
services
:
:
GetObserverService
(
)
;
if
(
observerService
)
{
observerService
-
>
AddObserver
(
this
kProfileChangeNetTeardownTopic
true
)
;
observerService
-
>
AddObserver
(
this
kProfileChangeNetRestoreTopic
true
)
;
observerService
-
>
AddObserver
(
this
kProfileDoChange
true
)
;
observerService
-
>
AddObserver
(
this
NS_XPCOM_SHUTDOWN_OBSERVER_ID
true
)
;
observerService
-
>
AddObserver
(
this
NS_NETWORK_LINK_TOPIC
true
)
;
observerService
-
>
AddObserver
(
this
NS_WIDGET_WAKE_OBSERVER_TOPIC
true
)
;
observerService
-
>
AddObserver
(
this
NS_PREFSERVICE_READ_TOPIC_ID
true
)
;
}
else
NS_WARNING
(
"
failed
to
get
observer
service
"
)
;
Preferences
:
:
AddBoolVarCache
(
&
sIsDataURIUniqueOpaqueOrigin
"
security
.
data_uri
.
unique_opaque_origin
"
false
)
;
Preferences
:
:
AddBoolVarCache
(
&
sBlockToplevelDataUriNavigations
"
security
.
data_uri
.
block_toplevel_data_uri_navigations
"
false
)
;
Preferences
:
:
AddBoolVarCache
(
&
sBlockFTPSubresources
"
security
.
block_ftp_subresources
"
true
)
;
Preferences
:
:
AddBoolVarCache
(
&
mOfflineMirrorsConnectivity
OFFLINE_MIRRORS_CONNECTIVITY
true
)
;
gIOService
=
this
;
InitializeNetworkLinkService
(
)
;
InitializeProtocolProxyService
(
)
;
SetOffline
(
false
)
;
return
NS_OK
;
}
nsIOService
:
:
~
nsIOService
(
)
{
if
(
gIOService
)
{
MOZ_ASSERT
(
gIOService
=
=
this
)
;
gIOService
=
nullptr
;
}
}
nsresult
nsIOService
:
:
InitializeCaptivePortalService
(
)
{
if
(
XRE_GetProcessType
(
)
!
=
GeckoProcessType_Default
)
{
return
NS_OK
;
}
mCaptivePortalService
=
do_GetService
(
NS_CAPTIVEPORTAL_CID
)
;
if
(
mCaptivePortalService
)
{
return
static_cast
<
CaptivePortalService
*
>
(
mCaptivePortalService
.
get
(
)
)
-
>
Initialize
(
)
;
}
RefPtr
<
NetworkConnectivityService
>
ncs
=
NetworkConnectivityService
:
:
GetSingleton
(
)
;
ncs
-
>
Init
(
)
;
return
NS_OK
;
}
nsresult
nsIOService
:
:
InitializeSocketTransportService
(
)
{
nsresult
rv
=
NS_OK
;
if
(
!
mSocketTransportService
)
{
mSocketTransportService
=
do_GetService
(
NS_SOCKETTRANSPORTSERVICE_CONTRACTID
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
failed
to
get
socket
transport
service
"
)
;
}
}
if
(
mSocketTransportService
)
{
rv
=
mSocketTransportService
-
>
Init
(
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
socket
transport
service
init
failed
"
)
;
mSocketTransportService
-
>
SetOffline
(
false
)
;
}
return
rv
;
}
nsresult
nsIOService
:
:
InitializeNetworkLinkService
(
)
{
nsresult
rv
=
NS_OK
;
if
(
mNetworkLinkServiceInitialized
)
return
rv
;
if
(
!
NS_IsMainThread
(
)
)
{
NS_WARNING
(
"
Network
link
service
should
be
created
on
main
thread
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
XRE_IsParentProcess
(
)
)
{
mNetworkLinkService
=
do_GetService
(
NS_NETWORK_LINK_SERVICE_CONTRACTID
&
rv
)
;
}
if
(
mNetworkLinkService
)
{
mNetworkLinkServiceInitialized
=
true
;
}
OnNetworkLinkEvent
(
NS_NETWORK_LINK_DATA_UNKNOWN
)
;
return
rv
;
}
nsresult
nsIOService
:
:
InitializeProtocolProxyService
(
)
{
nsresult
rv
=
NS_OK
;
if
(
XRE_IsParentProcess
(
)
)
{
Unused
<
<
do_GetService
(
NS_PROTOCOLPROXYSERVICE_CONTRACTID
&
rv
)
;
}
return
rv
;
}
already_AddRefed
<
nsIOService
>
nsIOService
:
:
GetInstance
(
)
{
if
(
!
gIOService
)
{
RefPtr
<
nsIOService
>
ios
=
new
nsIOService
(
)
;
if
(
NS_SUCCEEDED
(
ios
-
>
Init
(
)
)
)
{
MOZ_ASSERT
(
gIOService
=
=
ios
.
get
(
)
)
;
return
ios
.
forget
(
)
;
}
}
return
do_AddRef
(
gIOService
)
;
}
class
SocketProcessListenerProxy
:
public
SocketProcessHost
:
:
Listener
{
public
:
SocketProcessListenerProxy
(
)
=
default
;
void
OnProcessLaunchComplete
(
SocketProcessHost
*
aHost
bool
aSucceeded
)
{
if
(
!
gIOService
)
{
return
;
}
gIOService
-
>
OnProcessLaunchComplete
(
aHost
aSucceeded
)
;
}
void
OnProcessUnexpectedShutdown
(
SocketProcessHost
*
aHost
)
{
if
(
!
gIOService
)
{
return
;
}
gIOService
-
>
OnProcessUnexpectedShutdown
(
aHost
)
;
}
}
;
nsresult
nsIOService
:
:
LaunchSocketProcess
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
XRE_GetProcessType
(
)
!
=
GeckoProcessType_Default
)
{
return
NS_OK
;
}
if
(
mSocketProcess
)
{
return
NS_OK
;
}
if
(
!
Preferences
:
:
GetBool
(
"
network
.
process
.
enabled
"
true
)
)
{
LOG
(
(
"
nsIOService
skipping
LaunchSocketProcess
because
of
the
pref
"
)
)
;
return
NS_OK
;
}
Preferences
:
:
RegisterPrefixCallbacks
(
PREF_CHANGE_METHOD
(
nsIOService
:
:
NotifySocketProcessPrefsChanged
)
gCallbackPrefsForSocketProcess
this
)
;
mSocketProcess
=
new
SocketProcessHost
(
new
SocketProcessListenerProxy
(
)
)
;
LOG
(
(
"
nsIOService
:
:
LaunchSocketProcess
"
)
)
;
if
(
!
mSocketProcess
-
>
Launch
(
)
)
{
NS_WARNING
(
"
Failed
to
launch
socket
process
!
!
"
)
;
DestroySocketProcess
(
)
;
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
void
nsIOService
:
:
DestroySocketProcess
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
XRE_GetProcessType
(
)
!
=
GeckoProcessType_Default
|
|
!
mSocketProcess
)
{
return
;
}
Preferences
:
:
UnregisterPrefixCallbacks
(
PREF_CHANGE_METHOD
(
nsIOService
:
:
NotifySocketProcessPrefsChanged
)
gCallbackPrefsForSocketProcess
this
)
;
mSocketProcess
-
>
Shutdown
(
)
;
mSocketProcess
=
nullptr
;
}
bool
nsIOService
:
:
SocketProcessReady
(
)
{
return
mSocketProcess
&
&
mSocketProcess
-
>
IsConnected
(
)
;
}
void
nsIOService
:
:
NotifySocketProcessPrefsChanged
(
const
char
*
aName
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
XRE_IsParentProcess
(
)
)
{
return
;
}
dom
:
:
Pref
pref
(
nsCString
(
aName
)
false
null_t
(
)
null_t
(
)
)
;
Preferences
:
:
GetPreference
(
&
pref
)
;
auto
sendPrefUpdate
=
[
pref
]
(
)
{
Unused
<
<
gIOService
-
>
mSocketProcess
-
>
GetActor
(
)
-
>
SendPreferenceUpdate
(
pref
)
;
}
;
CallOrWaitForSocketProcess
(
sendPrefUpdate
)
;
}
void
nsIOService
:
:
OnProcessLaunchComplete
(
SocketProcessHost
*
aHost
bool
aSucceeded
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
LOG
(
(
"
nsIOService
:
:
OnProcessLaunchComplete
aSucceeded
=
%
d
\
n
"
aSucceeded
)
)
;
mSocketProcessLaunchComplete
=
true
;
if
(
mShutdown
|
|
!
SocketProcessReady
(
)
)
{
return
;
}
if
(
!
mPendingEvents
.
IsEmpty
(
)
)
{
nsTArray
<
std
:
:
function
<
void
(
)
>
>
pendingEvents
;
mPendingEvents
.
SwapElements
(
pendingEvents
)
;
for
(
auto
&
func
:
pendingEvents
)
{
func
(
)
;
}
}
}
void
nsIOService
:
:
CallOrWaitForSocketProcess
(
const
std
:
:
function
<
void
(
)
>
&
aFunc
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
IsSocketProcessLaunchComplete
(
)
&
&
SocketProcessReady
(
)
)
{
aFunc
(
)
;
}
else
{
mPendingEvents
.
AppendElement
(
aFunc
)
;
}
}
bool
nsIOService
:
:
IsSocketProcessLaunchComplete
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
mSocketProcessLaunchComplete
;
}
void
nsIOService
:
:
OnProcessUnexpectedShutdown
(
SocketProcessHost
*
aHost
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
LOG
(
(
"
nsIOService
:
:
OnProcessUnexpectedShutdown
\
n
"
)
)
;
DestroySocketProcess
(
)
;
}
RefPtr
<
MemoryReportingProcess
>
nsIOService
:
:
GetSocketProcessMemoryReporter
(
)
{
if
(
!
Preferences
:
:
GetBool
(
"
network
.
process
.
enabled
"
)
|
|
!
SocketProcessReady
(
)
)
{
return
nullptr
;
}
return
new
SocketProcessMemoryReporter
(
)
;
}
NS_IMETHODIMP
nsIOService
:
:
SocketProcessTelemetryPing
(
)
{
CallOrWaitForSocketProcess
(
[
]
(
)
{
Unused
<
<
gIOService
-
>
mSocketProcess
-
>
GetActor
(
)
-
>
SendSocketProcessTelemetryPing
(
)
;
}
)
;
return
NS_OK
;
}
NS_IMPL_ISUPPORTS
(
nsIOService
nsIIOService
nsINetUtil
nsISpeculativeConnect
nsIObserver
nsIIOServiceInternal
nsISupportsWeakReference
)
nsresult
nsIOService
:
:
RecheckCaptivePortal
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Must
be
called
on
the
main
thread
"
)
;
if
(
!
mCaptivePortalService
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIRunnable
>
task
=
NewRunnableMethod
(
"
nsIOService
:
:
RecheckCaptivePortal
"
mCaptivePortalService
&
nsICaptivePortalService
:
:
RecheckCaptivePortal
)
;
return
NS_DispatchToMainThread
(
task
)
;
}
nsresult
nsIOService
:
:
RecheckCaptivePortalIfLocalRedirect
(
nsIChannel
*
newChan
)
{
nsresult
rv
;
if
(
!
mCaptivePortalService
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIURI
>
uri
;
rv
=
newChan
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsCString
host
;
rv
=
uri
-
>
GetHost
(
host
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
PRNetAddr
prAddr
;
if
(
PR_StringToNetAddr
(
host
.
BeginReading
(
)
&
prAddr
)
!
=
PR_SUCCESS
)
{
return
NS_OK
;
}
NetAddr
netAddr
;
PRNetAddrToNetAddr
(
&
prAddr
&
netAddr
)
;
if
(
IsIPAddrLocal
(
&
netAddr
)
)
{
RecheckCaptivePortal
(
)
;
}
return
NS_OK
;
}
nsresult
nsIOService
:
:
AsyncOnChannelRedirect
(
nsIChannel
*
oldChan
nsIChannel
*
newChan
uint32_t
flags
nsAsyncRedirectVerifyHelper
*
helper
)
{
RecheckCaptivePortalIfLocalRedirect
(
newChan
)
;
nsCOMPtr
<
nsIChannelEventSink
>
sink
=
do_GetService
(
NS_CONTENTSECURITYMANAGER_CONTRACTID
)
;
if
(
sink
)
{
nsresult
rv
=
helper
-
>
DelegateOnChannelRedirect
(
sink
oldChan
newChan
flags
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
}
nsCOMArray
<
nsIChannelEventSink
>
entries
;
mChannelEventSinks
.
GetEntries
(
entries
)
;
int32_t
len
=
entries
.
Count
(
)
;
for
(
int32_t
i
=
0
;
i
<
len
;
+
+
i
)
{
nsresult
rv
=
helper
-
>
DelegateOnChannelRedirect
(
entries
[
i
]
oldChan
newChan
flags
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
}
return
NS_OK
;
}
nsresult
nsIOService
:
:
CacheProtocolHandler
(
const
char
*
scheme
nsIProtocolHandler
*
handler
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
for
(
unsigned
int
i
=
0
;
i
<
NS_N
(
gScheme
)
;
i
+
+
)
{
if
(
!
nsCRT
:
:
strcasecmp
(
scheme
gScheme
[
i
]
)
)
{
nsresult
rv
;
NS_ASSERTION
(
!
mWeakHandler
[
i
]
"
Protocol
handler
already
cached
"
)
;
nsCOMPtr
<
nsISupportsWeakReference
>
factoryPtr
=
do_QueryInterface
(
handler
&
rv
)
;
if
(
!
factoryPtr
)
{
#
ifdef
DEBUG_dp
printf
(
"
DEBUG
:
%
s
protcol
handler
doesn
'
t
support
weak
ref
.
Not
cached
.
\
n
"
scheme
)
;
#
endif
return
NS_ERROR_FAILURE
;
}
mWeakHandler
[
i
]
=
do_GetWeakReference
(
handler
)
;
return
NS_OK
;
}
}
return
NS_ERROR_FAILURE
;
}
nsresult
nsIOService
:
:
GetCachedProtocolHandler
(
const
char
*
scheme
nsIProtocolHandler
*
*
result
uint32_t
start
uint32_t
end
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
uint32_t
len
=
end
-
start
-
1
;
for
(
unsigned
int
i
=
0
;
i
<
NS_N
(
gScheme
)
;
i
+
+
)
{
if
(
!
mWeakHandler
[
i
]
)
continue
;
if
(
end
?
(
!
nsCRT
:
:
strncasecmp
(
scheme
+
start
gScheme
[
i
]
len
)
&
&
gScheme
[
i
]
[
len
]
=
=
'
\
0
'
)
:
(
!
nsCRT
:
:
strcasecmp
(
scheme
gScheme
[
i
]
)
)
)
{
return
CallQueryReferent
(
mWeakHandler
[
i
]
.
get
(
)
result
)
;
}
}
return
NS_ERROR_FAILURE
;
}
static
bool
UsesExternalProtocolHandler
(
const
char
*
aScheme
)
{
if
(
NS_LITERAL_CSTRING
(
"
file
"
)
.
Equals
(
aScheme
)
|
|
NS_LITERAL_CSTRING
(
"
chrome
"
)
.
Equals
(
aScheme
)
|
|
NS_LITERAL_CSTRING
(
"
resource
"
)
.
Equals
(
aScheme
)
)
{
return
false
;
}
for
(
const
auto
&
forcedExternalScheme
:
gForcedExternalSchemes
)
{
if
(
!
nsCRT
:
:
strcasecmp
(
forcedExternalScheme
aScheme
)
)
{
return
true
;
}
}
nsAutoCString
pref
(
"
network
.
protocol
-
handler
.
external
.
"
)
;
pref
+
=
aScheme
;
return
Preferences
:
:
GetBool
(
pref
.
get
(
)
false
)
;
}
NS_IMETHODIMP
nsIOService
:
:
GetProtocolHandler
(
const
char
*
scheme
nsIProtocolHandler
*
*
result
)
{
nsresult
rv
;
NS_ENSURE_ARG_POINTER
(
scheme
)
;
rv
=
GetCachedProtocolHandler
(
scheme
result
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
return
rv
;
if
(
scheme
[
0
]
!
=
'
\
0
'
&
&
!
UsesExternalProtocolHandler
(
scheme
)
)
{
nsAutoCString
contractID
(
NS_NETWORK_PROTOCOL_CONTRACTID_PREFIX
)
;
contractID
+
=
scheme
;
ToLowerCase
(
contractID
)
;
rv
=
CallGetService
(
contractID
.
get
(
)
result
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
CacheProtocolHandler
(
scheme
*
result
)
;
return
rv
;
}
#
ifdef
MOZ_WIDGET_GTK
rv
=
CallGetService
(
NS_NETWORK_PROTOCOL_CONTRACTID_PREFIX
"
moz
-
gio
"
result
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsAutoCString
spec
(
scheme
)
;
spec
.
Append
(
'
:
'
)
;
nsIURI
*
uri
;
rv
=
(
*
result
)
-
>
NewURI
(
spec
nullptr
nullptr
&
uri
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
NS_RELEASE
(
uri
)
;
return
rv
;
}
NS_RELEASE
(
*
result
)
;
}
#
endif
}
rv
=
CallGetService
(
NS_NETWORK_PROTOCOL_CONTRACTID_PREFIX
"
default
"
result
)
;
if
(
NS_FAILED
(
rv
)
)
return
NS_ERROR_UNKNOWN_PROTOCOL
;
return
rv
;
}
NS_IMETHODIMP
nsIOService
:
:
ExtractScheme
(
const
nsACString
&
inURI
nsACString
&
scheme
)
{
return
net_ExtractURLScheme
(
inURI
scheme
)
;
}
NS_IMETHODIMP
nsIOService
:
:
HostnameIsLocalIPAddress
(
nsIURI
*
aURI
bool
*
aResult
)
{
NS_ENSURE_ARG_POINTER
(
aURI
)
;
nsCOMPtr
<
nsIURI
>
innerURI
=
NS_GetInnermostURI
(
aURI
)
;
NS_ENSURE_ARG_POINTER
(
innerURI
)
;
nsAutoCString
host
;
nsresult
rv
=
innerURI
-
>
GetAsciiHost
(
host
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
*
aResult
=
false
;
PRNetAddr
addr
;
PRStatus
result
=
PR_StringToNetAddr
(
host
.
get
(
)
&
addr
)
;
if
(
result
=
=
PR_SUCCESS
)
{
NetAddr
netAddr
;
PRNetAddrToNetAddr
(
&
addr
&
netAddr
)
;
if
(
IsIPAddrLocal
(
&
netAddr
)
)
{
*
aResult
=
true
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsIOService
:
:
GetProtocolFlags
(
const
char
*
scheme
uint32_t
*
flags
)
{
nsCOMPtr
<
nsIProtocolHandler
>
handler
;
nsresult
rv
=
GetProtocolHandler
(
scheme
getter_AddRefs
(
handler
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
rv
=
handler
-
>
GetProtocolFlags
(
flags
)
;
#
if
!
IS_ORIGIN_IS_FULL_SPEC_DEFINED
MOZ_RELEASE_ASSERT
(
!
(
*
flags
&
nsIProtocolHandler
:
:
ORIGIN_IS_FULL_SPEC
)
"
ORIGIN_IS_FULL_SPEC
is
unsupported
but
used
"
)
;
#
endif
return
rv
;
}
class
AutoIncrement
{
public
:
explicit
AutoIncrement
(
uint32_t
*
var
)
:
mVar
(
var
)
{
+
+
*
var
;
}
~
AutoIncrement
(
)
{
-
-
*
mVar
;
}
private
:
uint32_t
*
mVar
;
}
;
nsresult
nsIOService
:
:
NewURI
(
const
nsACString
&
aSpec
const
char
*
aCharset
nsIURI
*
aBaseURI
nsIURI
*
*
result
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
wrong
thread
"
)
;
static
uint32_t
recursionCount
=
0
;
if
(
recursionCount
>
=
MAX_RECURSION_COUNT
)
return
NS_ERROR_MALFORMED_URI
;
AutoIncrement
inc
(
&
recursionCount
)
;
nsAutoCString
scheme
;
nsresult
rv
=
ExtractScheme
(
aSpec
scheme
)
;
if
(
NS_FAILED
(
rv
)
)
{
if
(
!
aBaseURI
)
return
NS_ERROR_MALFORMED_URI
;
if
(
!
aSpec
.
IsEmpty
(
)
&
&
aSpec
[
0
]
=
=
'
#
'
)
{
return
NS_GetURIWithNewRef
(
aBaseURI
aSpec
result
)
;
}
rv
=
aBaseURI
-
>
GetScheme
(
scheme
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
}
nsCOMPtr
<
nsIProtocolHandler
>
handler
;
rv
=
GetProtocolHandler
(
scheme
.
get
(
)
getter_AddRefs
(
handler
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
return
handler
-
>
NewURI
(
aSpec
aCharset
aBaseURI
result
)
;
}
NS_IMETHODIMP
nsIOService
:
:
NewFileURI
(
nsIFile
*
file
nsIURI
*
*
result
)
{
nsresult
rv
;
NS_ENSURE_ARG_POINTER
(
file
)
;
nsCOMPtr
<
nsIProtocolHandler
>
handler
;
rv
=
GetProtocolHandler
(
"
file
"
getter_AddRefs
(
handler
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
nsCOMPtr
<
nsIFileProtocolHandler
>
fileHandler
(
do_QueryInterface
(
handler
&
rv
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
return
fileHandler
-
>
NewFileURI
(
file
result
)
;
}
NS_IMETHODIMP
nsIOService
:
:
NewChannelFromURI2
(
nsIURI
*
aURI
nsINode
*
aLoadingNode
nsIPrincipal
*
aLoadingPrincipal
nsIPrincipal
*
aTriggeringPrincipal
uint32_t
aSecurityFlags
uint32_t
aContentPolicyType
nsIChannel
*
*
result
)
{
return
NewChannelFromURIWithProxyFlags2
(
aURI
nullptr
0
aLoadingNode
aLoadingPrincipal
aTriggeringPrincipal
aSecurityFlags
aContentPolicyType
result
)
;
}
nsresult
nsIOService
:
:
NewChannelFromURIWithClientAndController
(
nsIURI
*
aURI
nsINode
*
aLoadingNode
nsIPrincipal
*
aLoadingPrincipal
nsIPrincipal
*
aTriggeringPrincipal
const
Maybe
<
ClientInfo
>
&
aLoadingClientInfo
const
Maybe
<
ServiceWorkerDescriptor
>
&
aController
uint32_t
aSecurityFlags
uint32_t
aContentPolicyType
nsIChannel
*
*
aResult
)
{
return
NewChannelFromURIWithProxyFlagsInternal
(
aURI
nullptr
0
aLoadingNode
aLoadingPrincipal
aTriggeringPrincipal
aLoadingClientInfo
aController
aSecurityFlags
aContentPolicyType
aResult
)
;
}
NS_IMETHODIMP
nsIOService
:
:
NewChannelFromURIWithLoadInfo
(
nsIURI
*
aURI
nsILoadInfo
*
aLoadInfo
nsIChannel
*
*
result
)
{
return
NewChannelFromURIWithProxyFlagsInternal
(
aURI
nullptr
0
aLoadInfo
result
)
;
}
nsresult
nsIOService
:
:
NewChannelFromURIWithProxyFlagsInternal
(
nsIURI
*
aURI
nsIURI
*
aProxyURI
uint32_t
aProxyFlags
nsINode
*
aLoadingNode
nsIPrincipal
*
aLoadingPrincipal
nsIPrincipal
*
aTriggeringPrincipal
const
Maybe
<
ClientInfo
>
&
aLoadingClientInfo
const
Maybe
<
ServiceWorkerDescriptor
>
&
aController
uint32_t
aSecurityFlags
uint32_t
aContentPolicyType
nsIChannel
*
*
result
)
{
nsCOMPtr
<
nsILoadInfo
>
loadInfo
;
if
(
aLoadingNode
|
|
aLoadingPrincipal
|
|
aContentPolicyType
=
=
nsIContentPolicy
:
:
TYPE_DOCUMENT
)
{
loadInfo
=
new
LoadInfo
(
aLoadingPrincipal
aTriggeringPrincipal
aLoadingNode
aSecurityFlags
aContentPolicyType
aLoadingClientInfo
aController
)
;
}
NS_ASSERTION
(
loadInfo
"
Please
pass
security
info
when
creating
a
channel
"
)
;
return
NewChannelFromURIWithProxyFlagsInternal
(
aURI
aProxyURI
aProxyFlags
loadInfo
result
)
;
}
nsresult
nsIOService
:
:
NewChannelFromURIWithProxyFlagsInternal
(
nsIURI
*
aURI
nsIURI
*
aProxyURI
uint32_t
aProxyFlags
nsILoadInfo
*
aLoadInfo
nsIChannel
*
*
result
)
{
nsresult
rv
;
NS_ENSURE_ARG_POINTER
(
aURI
)
;
nsAutoCString
scheme
;
rv
=
aURI
-
>
GetScheme
(
scheme
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
nsCOMPtr
<
nsIProtocolHandler
>
handler
;
rv
=
GetProtocolHandler
(
scheme
.
get
(
)
getter_AddRefs
(
handler
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
uint32_t
protoFlags
;
rv
=
handler
-
>
DoGetProtocolFlags
(
aURI
&
protoFlags
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
nsCOMPtr
<
nsIChannel
>
channel
;
nsCOMPtr
<
nsIProxiedProtocolHandler
>
pph
=
do_QueryInterface
(
handler
)
;
if
(
pph
)
{
rv
=
pph
-
>
NewProxiedChannel2
(
aURI
nullptr
aProxyFlags
aProxyURI
aLoadInfo
getter_AddRefs
(
channel
)
)
;
}
else
{
rv
=
handler
-
>
NewChannel2
(
aURI
aLoadInfo
getter_AddRefs
(
channel
)
)
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
aLoadInfo
)
{
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
channel
-
>
GetLoadInfo
(
)
;
if
(
aLoadInfo
!
=
loadInfo
)
{
MOZ_ASSERT
(
false
"
newly
created
channel
must
have
a
loadinfo
attached
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
if
(
loadInfo
-
>
GetLoadingSandboxed
(
)
)
{
channel
-
>
SetOwner
(
nullptr
)
;
}
}
if
(
!
gHasWarnedUploadChannel2
&
&
scheme
.
EqualsLiteral
(
"
http
"
)
)
{
nsCOMPtr
<
nsIUploadChannel2
>
uploadChannel2
=
do_QueryInterface
(
channel
)
;
if
(
!
uploadChannel2
)
{
nsCOMPtr
<
nsIConsoleService
>
consoleService
=
do_GetService
(
NS_CONSOLESERVICE_CONTRACTID
)
;
if
(
consoleService
)
{
consoleService
-
>
LogStringMessage
(
u
"
Http
channel
implementation
"
"
doesn
'
t
support
nsIUploadChannel2
.
An
extension
has
"
"
supplied
a
non
-
functional
http
protocol
handler
.
This
will
"
"
break
behavior
and
in
future
releases
not
work
at
all
.
"
)
;
}
gHasWarnedUploadChannel2
=
true
;
}
}
channel
.
forget
(
result
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsIOService
:
:
NewChannelFromURIWithProxyFlags2
(
nsIURI
*
aURI
nsIURI
*
aProxyURI
uint32_t
aProxyFlags
nsINode
*
aLoadingNode
nsIPrincipal
*
aLoadingPrincipal
nsIPrincipal
*
aTriggeringPrincipal
uint32_t
aSecurityFlags
uint32_t
aContentPolicyType
nsIChannel
*
*
result
)
{
return
NewChannelFromURIWithProxyFlagsInternal
(
aURI
aProxyURI
aProxyFlags
aLoadingNode
aLoadingPrincipal
aTriggeringPrincipal
Maybe
<
ClientInfo
>
(
)
Maybe
<
ServiceWorkerDescriptor
>
(
)
aSecurityFlags
aContentPolicyType
result
)
;
}
NS_IMETHODIMP
nsIOService
:
:
NewChannel2
(
const
nsACString
&
aSpec
const
char
*
aCharset
nsIURI
*
aBaseURI
nsINode
*
aLoadingNode
nsIPrincipal
*
aLoadingPrincipal
nsIPrincipal
*
aTriggeringPrincipal
uint32_t
aSecurityFlags
uint32_t
aContentPolicyType
nsIChannel
*
*
result
)
{
nsresult
rv
;
nsCOMPtr
<
nsIURI
>
uri
;
rv
=
NewURI
(
aSpec
aCharset
aBaseURI
getter_AddRefs
(
uri
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
return
NewChannelFromURI2
(
uri
aLoadingNode
aLoadingPrincipal
aTriggeringPrincipal
aSecurityFlags
aContentPolicyType
result
)
;
}
bool
nsIOService
:
:
IsLinkUp
(
)
{
InitializeNetworkLinkService
(
)
;
if
(
!
mNetworkLinkService
)
{
return
true
;
}
bool
isLinkUp
;
nsresult
rv
;
rv
=
mNetworkLinkService
-
>
GetIsLinkUp
(
&
isLinkUp
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
true
;
}
return
isLinkUp
;
}
NS_IMETHODIMP
nsIOService
:
:
GetOffline
(
bool
*
offline
)
{
if
(
mOfflineMirrorsConnectivity
)
{
*
offline
=
mOffline
|
|
!
mConnectivity
;
}
else
{
*
offline
=
mOffline
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsIOService
:
:
SetOffline
(
bool
offline
)
{
LOG
(
(
"
nsIOService
:
:
SetOffline
offline
=
%
d
\
n
"
offline
)
)
;
if
(
(
mShutdown
|
|
mOfflineForProfileChange
)
&
&
!
offline
)
return
NS_ERROR_NOT_AVAILABLE
;
mSetOfflineValue
=
offline
;
if
(
mSettingOffline
)
{
return
NS_OK
;
}
mSettingOffline
=
true
;
nsCOMPtr
<
nsIObserverService
>
observerService
=
services
:
:
GetObserverService
(
)
;
NS_ASSERTION
(
observerService
"
The
observer
service
should
not
be
null
"
)
;
if
(
XRE_IsParentProcess
(
)
)
{
if
(
observerService
)
{
(
void
)
observerService
-
>
NotifyObservers
(
nullptr
NS_IPC_IOSERVICE_SET_OFFLINE_TOPIC
offline
?
u
"
true
"
:
u
"
false
"
)
;
}
}
nsIIOService
*
subject
=
static_cast
<
nsIIOService
*
>
(
this
)
;
while
(
mSetOfflineValue
!
=
mOffline
)
{
offline
=
mSetOfflineValue
;
if
(
offline
&
&
!
mOffline
)
{
mOffline
=
true
;
if
(
observerService
)
observerService
-
>
NotifyObservers
(
subject
NS_IOSERVICE_GOING_OFFLINE_TOPIC
u
"
"
NS_IOSERVICE_OFFLINE
)
;
if
(
mSocketTransportService
)
mSocketTransportService
-
>
SetOffline
(
true
)
;
mLastOfflineStateChange
=
PR_IntervalNow
(
)
;
if
(
observerService
)
observerService
-
>
NotifyObservers
(
subject
NS_IOSERVICE_OFFLINE_STATUS_TOPIC
u
"
"
NS_IOSERVICE_OFFLINE
)
;
}
else
if
(
!
offline
&
&
mOffline
)
{
InitializeSocketTransportService
(
)
;
mOffline
=
false
;
mLastOfflineStateChange
=
PR_IntervalNow
(
)
;
if
(
observerService
&
&
mConnectivity
)
{
observerService
-
>
NotifyObservers
(
subject
NS_IOSERVICE_OFFLINE_STATUS_TOPIC
(
u
"
"
NS_IOSERVICE_ONLINE
)
)
;
}
}
}
if
(
(
mShutdown
|
|
mOfflineForProfileChange
)
&
&
mOffline
)
{
if
(
mSocketTransportService
)
{
DebugOnly
<
nsresult
>
rv
=
mSocketTransportService
-
>
Shutdown
(
mShutdown
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
socket
transport
service
shutdown
failed
"
)
;
}
}
mSettingOffline
=
false
;
return
NS_OK
;
}
NS_IMETHODIMP
nsIOService
:
:
GetConnectivity
(
bool
*
aConnectivity
)
{
*
aConnectivity
=
mConnectivity
;
return
NS_OK
;
}
NS_IMETHODIMP
nsIOService
:
:
SetConnectivity
(
bool
aConnectivity
)
{
LOG
(
(
"
nsIOService
:
:
SetConnectivity
aConnectivity
=
%
d
\
n
"
aConnectivity
)
)
;
if
(
XRE_IsParentProcess
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
return
SetConnectivityInternal
(
aConnectivity
)
;
}
nsresult
nsIOService
:
:
SetConnectivityInternal
(
bool
aConnectivity
)
{
LOG
(
(
"
nsIOService
:
:
SetConnectivityInternal
aConnectivity
=
%
d
\
n
"
aConnectivity
)
)
;
if
(
mConnectivity
=
=
aConnectivity
)
{
return
NS_OK
;
}
mConnectivity
=
aConnectivity
;
mLastConnectivityChange
=
PR_IntervalNow
(
)
;
if
(
mCaptivePortalService
)
{
if
(
aConnectivity
&
&
gCaptivePortalEnabled
)
{
static_cast
<
CaptivePortalService
*
>
(
mCaptivePortalService
.
get
(
)
)
-
>
Start
(
)
;
}
else
{
static_cast
<
CaptivePortalService
*
>
(
mCaptivePortalService
.
get
(
)
)
-
>
Stop
(
)
;
}
}
nsCOMPtr
<
nsIObserverService
>
observerService
=
services
:
:
GetObserverService
(
)
;
if
(
!
observerService
)
{
return
NS_OK
;
}
if
(
XRE_IsParentProcess
(
)
)
{
observerService
-
>
NotifyObservers
(
nullptr
NS_IPC_IOSERVICE_SET_CONNECTIVITY_TOPIC
aConnectivity
?
u
"
true
"
:
u
"
false
"
)
;
}
if
(
mOffline
)
{
return
NS_OK
;
}
if
(
aConnectivity
)
{
observerService
-
>
NotifyObservers
(
static_cast
<
nsIIOService
*
>
(
this
)
NS_IOSERVICE_OFFLINE_STATUS_TOPIC
(
u
"
"
NS_IOSERVICE_ONLINE
)
)
;
}
else
{
observerService
-
>
NotifyObservers
(
static_cast
<
nsIIOService
*
>
(
this
)
NS_IOSERVICE_GOING_OFFLINE_TOPIC
u
"
"
NS_IOSERVICE_OFFLINE
)
;
observerService
-
>
NotifyObservers
(
static_cast
<
nsIIOService
*
>
(
this
)
NS_IOSERVICE_OFFLINE_STATUS_TOPIC
u
"
"
NS_IOSERVICE_OFFLINE
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsIOService
:
:
AllowPort
(
int32_t
inPort
const
char
*
scheme
bool
*
_retval
)
{
int16_t
port
=
inPort
;
if
(
port
=
=
-
1
)
{
*
_retval
=
true
;
return
NS_OK
;
}
if
(
port
=
=
0
)
{
*
_retval
=
false
;
return
NS_OK
;
}
int32_t
badPortListCnt
=
mRestrictedPortList
.
Length
(
)
;
for
(
int
i
=
0
;
i
<
badPortListCnt
;
i
+
+
)
{
if
(
port
=
=
mRestrictedPortList
[
i
]
)
{
*
_retval
=
false
;
if
(
!
scheme
)
return
NS_OK
;
nsCOMPtr
<
nsIProtocolHandler
>
handler
;
nsresult
rv
=
GetProtocolHandler
(
scheme
getter_AddRefs
(
handler
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
return
handler
-
>
AllowPort
(
port
scheme
_retval
)
;
}
}
*
_retval
=
true
;
return
NS_OK
;
}
void
nsIOService
:
:
PrefsChanged
(
const
char
*
pref
)
{
if
(
!
pref
|
|
strcmp
(
pref
PORT_PREF
(
"
banned
"
)
)
=
=
0
)
ParsePortList
(
PORT_PREF
(
"
banned
"
)
false
)
;
if
(
!
pref
|
|
strcmp
(
pref
PORT_PREF
(
"
banned
.
override
"
)
)
=
=
0
)
ParsePortList
(
PORT_PREF
(
"
banned
.
override
"
)
true
)
;
if
(
!
pref
|
|
strcmp
(
pref
MANAGE_OFFLINE_STATUS_PREF
)
=
=
0
)
{
bool
manage
;
if
(
mNetworkLinkServiceInitialized
&
&
NS_SUCCEEDED
(
Preferences
:
:
GetBool
(
MANAGE_OFFLINE_STATUS_PREF
&
manage
)
)
)
{
LOG
(
(
"
nsIOService
:
:
PrefsChanged
ManageOfflineStatus
manage
=
%
d
\
n
"
manage
)
)
;
SetManageOfflineStatus
(
manage
)
;
}
}
if
(
!
pref
|
|
strcmp
(
pref
NECKO_BUFFER_CACHE_COUNT_PREF
)
=
=
0
)
{
int32_t
count
;
if
(
NS_SUCCEEDED
(
Preferences
:
:
GetInt
(
NECKO_BUFFER_CACHE_COUNT_PREF
&
count
)
)
)
if
(
count
>
0
)
gDefaultSegmentCount
=
count
;
}
if
(
!
pref
|
|
strcmp
(
pref
NECKO_BUFFER_CACHE_SIZE_PREF
)
=
=
0
)
{
int32_t
size
;
if
(
NS_SUCCEEDED
(
Preferences
:
:
GetInt
(
NECKO_BUFFER_CACHE_SIZE_PREF
&
size
)
)
)
if
(
size
>
0
&
&
size
<
1024
*
1024
)
gDefaultSegmentSize
=
size
;
NS_WARNING_ASSERTION
(
!
(
size
&
(
size
-
1
)
)
"
network
segment
size
is
not
a
power
of
2
!
"
)
;
}
if
(
!
pref
|
|
strcmp
(
pref
NETWORK_NOTIFY_CHANGED_PREF
)
=
=
0
)
{
bool
allow
;
nsresult
rv
=
Preferences
:
:
GetBool
(
NETWORK_NOTIFY_CHANGED_PREF
&
allow
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
mNetworkNotifyChanged
=
allow
;
}
}
if
(
!
pref
|
|
strcmp
(
pref
NETWORK_CAPTIVE_PORTAL_PREF
)
=
=
0
)
{
nsresult
rv
=
Preferences
:
:
GetBool
(
NETWORK_CAPTIVE_PORTAL_PREF
&
gCaptivePortalEnabled
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
mCaptivePortalService
)
{
if
(
gCaptivePortalEnabled
)
{
static_cast
<
CaptivePortalService
*
>
(
mCaptivePortalService
.
get
(
)
)
-
>
Start
(
)
;
}
else
{
static_cast
<
CaptivePortalService
*
>
(
mCaptivePortalService
.
get
(
)
)
-
>
Stop
(
)
;
}
}
}
}
void
nsIOService
:
:
ParsePortList
(
const
char
*
pref
bool
remove
)
{
nsAutoCString
portList
;
Preferences
:
:
GetCString
(
pref
portList
)
;
if
(
!
portList
.
IsVoid
(
)
)
{
nsTArray
<
nsCString
>
portListArray
;
ParseString
(
portList
'
'
portListArray
)
;
uint32_t
index
;
for
(
index
=
0
;
index
<
portListArray
.
Length
(
)
;
index
+
+
)
{
portListArray
[
index
]
.
StripWhitespace
(
)
;
int32_t
portBegin
portEnd
;
if
(
PR_sscanf
(
portListArray
[
index
]
.
get
(
)
"
%
d
-
%
d
"
&
portBegin
&
portEnd
)
=
=
2
)
{
if
(
(
portBegin
<
65536
)
&
&
(
portEnd
<
65536
)
)
{
int32_t
curPort
;
if
(
remove
)
{
for
(
curPort
=
portBegin
;
curPort
<
=
portEnd
;
curPort
+
+
)
mRestrictedPortList
.
RemoveElement
(
curPort
)
;
}
else
{
for
(
curPort
=
portBegin
;
curPort
<
=
portEnd
;
curPort
+
+
)
mRestrictedPortList
.
AppendElement
(
curPort
)
;
}
}
}
else
{
nsresult
aErrorCode
;
int32_t
port
=
portListArray
[
index
]
.
ToInteger
(
&
aErrorCode
)
;
if
(
NS_SUCCEEDED
(
aErrorCode
)
&
&
port
<
65536
)
{
if
(
remove
)
mRestrictedPortList
.
RemoveElement
(
port
)
;
else
mRestrictedPortList
.
AppendElement
(
port
)
;
}
}
}
}
}
class
nsWakeupNotifier
:
public
Runnable
{
public
:
explicit
nsWakeupNotifier
(
nsIIOServiceInternal
*
ioService
)
:
Runnable
(
"
net
:
:
nsWakeupNotifier
"
)
mIOService
(
ioService
)
{
}
NS_IMETHOD
Run
(
)
override
{
return
mIOService
-
>
NotifyWakeup
(
)
;
}
private
:
virtual
~
nsWakeupNotifier
(
)
=
default
;
nsCOMPtr
<
nsIIOServiceInternal
>
mIOService
;
}
;
NS_IMETHODIMP
nsIOService
:
:
NotifyWakeup
(
)
{
nsCOMPtr
<
nsIObserverService
>
observerService
=
services
:
:
GetObserverService
(
)
;
NS_ASSERTION
(
observerService
"
The
observer
service
should
not
be
null
"
)
;
if
(
observerService
&
&
mNetworkNotifyChanged
)
{
(
void
)
observerService
-
>
NotifyObservers
(
nullptr
NS_NETWORK_LINK_TOPIC
(
u
"
"
NS_NETWORK_LINK_DATA_CHANGED
)
)
;
}
RecheckCaptivePortal
(
)
;
return
NS_OK
;
}
void
nsIOService
:
:
SetHttpHandlerAlreadyShutingDown
(
)
{
if
(
!
mShutdown
&
&
!
mOfflineForProfileChange
)
{
mNetTearingDownStarted
=
PR_IntervalNow
(
)
;
mHttpHandlerAlreadyShutingDown
=
true
;
}
}
NS_IMETHODIMP
nsIOService
:
:
Observe
(
nsISupports
*
subject
const
char
*
topic
const
char16_t
*
data
)
{
if
(
!
strcmp
(
topic
kProfileChangeNetTeardownTopic
)
)
{
if
(
!
mHttpHandlerAlreadyShutingDown
)
{
mNetTearingDownStarted
=
PR_IntervalNow
(
)
;
}
mHttpHandlerAlreadyShutingDown
=
false
;
if
(
!
mOffline
)
{
mOfflineForProfileChange
=
true
;
SetOffline
(
true
)
;
}
}
else
if
(
!
strcmp
(
topic
kProfileChangeNetRestoreTopic
)
)
{
if
(
mOfflineForProfileChange
)
{
mOfflineForProfileChange
=
false
;
SetOffline
(
false
)
;
}
}
else
if
(
!
strcmp
(
topic
kProfileDoChange
)
)
{
if
(
!
data
)
{
return
NS_OK
;
}
if
(
NS_LITERAL_STRING
(
"
startup
"
)
.
Equals
(
data
)
)
{
InitializeNetworkLinkService
(
)
;
mNetworkLinkServiceInitialized
=
true
;
PrefsChanged
(
MANAGE_OFFLINE_STATUS_PREF
)
;
nsCOMPtr
<
nsISupports
>
cookieServ
=
do_GetService
(
NS_COOKIESERVICE_CONTRACTID
)
;
}
else
if
(
NS_LITERAL_STRING
(
"
xpcshell
-
do
-
get
-
profile
"
)
.
Equals
(
data
)
)
{
LaunchSocketProcess
(
)
;
}
}
else
if
(
!
strcmp
(
topic
NS_XPCOM_SHUTDOWN_OBSERVER_ID
)
)
{
mShutdown
=
true
;
if
(
!
mHttpHandlerAlreadyShutingDown
&
&
!
mOfflineForProfileChange
)
{
mNetTearingDownStarted
=
PR_IntervalNow
(
)
;
}
mHttpHandlerAlreadyShutingDown
=
false
;
SetOffline
(
true
)
;
if
(
mCaptivePortalService
)
{
static_cast
<
CaptivePortalService
*
>
(
mCaptivePortalService
.
get
(
)
)
-
>
Stop
(
)
;
mCaptivePortalService
=
nullptr
;
}
DestroySocketProcess
(
)
;
}
else
if
(
!
strcmp
(
topic
NS_NETWORK_LINK_TOPIC
)
)
{
OnNetworkLinkEvent
(
NS_ConvertUTF16toUTF8
(
data
)
.
get
(
)
)
;
}
else
if
(
!
strcmp
(
topic
NS_WIDGET_WAKE_OBSERVER_TOPIC
)
)
{
nsCOMPtr
<
nsIRunnable
>
wakeupNotifier
=
new
nsWakeupNotifier
(
this
)
;
NS_DispatchToMainThread
(
wakeupNotifier
)
;
}
else
if
(
!
strcmp
(
topic
NS_PREFSERVICE_READ_TOPIC_ID
)
)
{
LaunchSocketProcess
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsIOService
:
:
ParseRequestContentType
(
const
nsACString
&
aTypeHeader
nsACString
&
aCharset
bool
*
aHadCharset
nsACString
&
aContentType
)
{
net_ParseRequestContentType
(
aTypeHeader
aContentType
aCharset
aHadCharset
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsIOService
:
:
ParseResponseContentType
(
const
nsACString
&
aTypeHeader
nsACString
&
aCharset
bool
*
aHadCharset
nsACString
&
aContentType
)
{
net_ParseContentType
(
aTypeHeader
aContentType
aCharset
aHadCharset
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsIOService
:
:
ProtocolHasFlags
(
nsIURI
*
uri
uint32_t
flags
bool
*
result
)
{
NS_ENSURE_ARG
(
uri
)
;
*
result
=
false
;
nsAutoCString
scheme
;
nsresult
rv
=
uri
-
>
GetScheme
(
scheme
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
uint32_t
protocolFlags
;
nsCOMPtr
<
nsIProtocolHandler
>
handler
;
rv
=
GetProtocolHandler
(
scheme
.
get
(
)
getter_AddRefs
(
handler
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
handler
-
>
DoGetProtocolFlags
(
uri
&
protocolFlags
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
*
result
=
(
protocolFlags
&
flags
)
=
=
flags
;
return
NS_OK
;
}
NS_IMETHODIMP
nsIOService
:
:
URIChainHasFlags
(
nsIURI
*
uri
uint32_t
flags
bool
*
result
)
{
nsresult
rv
=
ProtocolHasFlags
(
uri
flags
result
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
*
result
)
{
return
rv
;
}
nsCOMPtr
<
nsINestedURI
>
nestedURI
=
do_QueryInterface
(
uri
)
;
while
(
nestedURI
)
{
nsCOMPtr
<
nsIURI
>
innerURI
;
rv
=
nestedURI
-
>
GetInnerURI
(
getter_AddRefs
(
innerURI
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
ProtocolHasFlags
(
innerURI
flags
result
)
;
if
(
*
result
)
{
return
rv
;
}
nestedURI
=
do_QueryInterface
(
innerURI
)
;
}
return
rv
;
}
NS_IMETHODIMP
nsIOService
:
:
SetManageOfflineStatus
(
bool
aManage
)
{
LOG
(
(
"
nsIOService
:
:
SetManageOfflineStatus
aManage
=
%
d
\
n
"
aManage
)
)
;
mManageLinkStatus
=
aManage
;
if
(
!
mManageLinkStatus
)
{
SetConnectivityInternal
(
true
)
;
return
NS_OK
;
}
InitializeNetworkLinkService
(
)
;
OnNetworkLinkEvent
(
NS_NETWORK_LINK_DATA_UNKNOWN
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsIOService
:
:
GetManageOfflineStatus
(
bool
*
aManage
)
{
*
aManage
=
mManageLinkStatus
;
return
NS_OK
;
}
nsresult
nsIOService
:
:
OnNetworkLinkEvent
(
const
char
*
data
)
{
if
(
IsNeckoChild
(
)
|
|
IsSocketProcessChild
(
)
)
{
return
NS_OK
;
}
if
(
mShutdown
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsCString
dataAsString
(
data
)
;
for
(
auto
*
cp
:
mozilla
:
:
dom
:
:
ContentParent
:
:
AllProcesses
(
mozilla
:
:
dom
:
:
ContentParent
:
:
eLive
)
)
{
PNeckoParent
*
neckoParent
=
SingleManagedOrNull
(
cp
-
>
ManagedPNeckoParent
(
)
)
;
if
(
!
neckoParent
)
{
continue
;
}
Unused
<
<
neckoParent
-
>
SendNetworkChangeNotification
(
dataAsString
)
;
}
LOG
(
(
"
nsIOService
:
:
OnNetworkLinkEvent
data
:
%
s
\
n
"
data
)
)
;
if
(
!
mNetworkLinkService
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
mManageLinkStatus
)
{
LOG
(
(
"
nsIOService
:
:
OnNetworkLinkEvent
mManageLinkStatus
=
false
\
n
"
)
)
;
return
NS_OK
;
}
bool
isUp
=
true
;
if
(
!
strcmp
(
data
NS_NETWORK_LINK_DATA_CHANGED
)
)
{
mLastNetworkLinkChange
=
PR_IntervalNow
(
)
;
RecheckCaptivePortal
(
)
;
return
NS_OK
;
}
if
(
!
strcmp
(
data
NS_NETWORK_LINK_DATA_DOWN
)
)
{
isUp
=
false
;
}
else
if
(
!
strcmp
(
data
NS_NETWORK_LINK_DATA_UP
)
)
{
isUp
=
true
;
}
else
if
(
!
strcmp
(
data
NS_NETWORK_LINK_DATA_UNKNOWN
)
)
{
nsresult
rv
=
mNetworkLinkService
-
>
GetIsLinkUp
(
&
isUp
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
NS_WARNING
(
"
Unhandled
network
event
!
"
)
;
return
NS_OK
;
}
return
SetConnectivityInternal
(
isUp
)
;
}
NS_IMETHODIMP
nsIOService
:
:
EscapeString
(
const
nsACString
&
aString
uint32_t
aEscapeType
nsACString
&
aResult
)
{
NS_ENSURE_ARG_MAX
(
aEscapeType
4
)
;
nsAutoCString
stringCopy
(
aString
)
;
nsCString
result
;
if
(
!
NS_Escape
(
stringCopy
result
(
nsEscapeMask
)
aEscapeType
)
)
return
NS_ERROR_OUT_OF_MEMORY
;
aResult
.
Assign
(
result
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsIOService
:
:
EscapeURL
(
const
nsACString
&
aStr
uint32_t
aFlags
nsACString
&
aResult
)
{
aResult
.
Truncate
(
)
;
NS_EscapeURL
(
aStr
.
BeginReading
(
)
aStr
.
Length
(
)
aFlags
|
esc_AlwaysCopy
aResult
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsIOService
:
:
UnescapeString
(
const
nsACString
&
aStr
uint32_t
aFlags
nsACString
&
aResult
)
{
aResult
.
Truncate
(
)
;
NS_UnescapeURL
(
aStr
.
BeginReading
(
)
aStr
.
Length
(
)
aFlags
|
esc_AlwaysCopy
aResult
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsIOService
:
:
ExtractCharsetFromContentType
(
const
nsACString
&
aTypeHeader
nsACString
&
aCharset
int32_t
*
aCharsetStart
int32_t
*
aCharsetEnd
bool
*
aHadCharset
)
{
nsAutoCString
ignored
;
net_ParseContentType
(
aTypeHeader
ignored
aCharset
aHadCharset
aCharsetStart
aCharsetEnd
)
;
if
(
*
aHadCharset
&
&
*
aCharsetStart
=
=
*
aCharsetEnd
)
{
*
aHadCharset
=
false
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsIOService
:
:
ParseAttributePolicyString
(
const
nsAString
&
policyString
uint32_t
*
outPolicyEnum
)
{
NS_ENSURE_ARG
(
outPolicyEnum
)
;
*
outPolicyEnum
=
(
uint32_t
)
AttributeReferrerPolicyFromString
(
policyString
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsIOService
:
:
GetReferrerPolicyString
(
uint32_t
aPolicy
nsACString
&
aResult
)
{
if
(
aPolicy
>
=
ArrayLength
(
kReferrerPolicyString
)
)
{
aResult
.
AssignLiteral
(
"
unknown
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
aResult
.
AssignASCII
(
ReferrerPolicyToString
(
static_cast
<
ReferrerPolicy
>
(
aPolicy
)
)
)
;
return
NS_OK
;
}
class
IOServiceProxyCallback
final
:
public
nsIProtocolProxyCallback
{
~
IOServiceProxyCallback
(
)
=
default
;
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIPROTOCOLPROXYCALLBACK
IOServiceProxyCallback
(
nsIInterfaceRequestor
*
aCallbacks
nsIOService
*
aIOService
)
:
mCallbacks
(
aCallbacks
)
mIOService
(
aIOService
)
{
}
private
:
RefPtr
<
nsIInterfaceRequestor
>
mCallbacks
;
RefPtr
<
nsIOService
>
mIOService
;
}
;
NS_IMPL_ISUPPORTS
(
IOServiceProxyCallback
nsIProtocolProxyCallback
)
NS_IMETHODIMP
IOServiceProxyCallback
:
:
OnProxyAvailable
(
nsICancelable
*
request
nsIChannel
*
channel
nsIProxyInfo
*
pi
nsresult
status
)
{
nsAutoCString
type
;
if
(
NS_SUCCEEDED
(
status
)
&
&
pi
&
&
NS_SUCCEEDED
(
pi
-
>
GetType
(
type
)
)
&
&
!
type
.
EqualsLiteral
(
"
direct
"
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
channel
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_OK
;
}
nsAutoCString
scheme
;
rv
=
uri
-
>
GetScheme
(
scheme
)
;
if
(
NS_FAILED
(
rv
)
)
return
NS_OK
;
nsCOMPtr
<
nsIProtocolHandler
>
handler
;
rv
=
mIOService
-
>
GetProtocolHandler
(
scheme
.
get
(
)
getter_AddRefs
(
handler
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
NS_OK
;
nsCOMPtr
<
nsISpeculativeConnect
>
speculativeHandler
=
do_QueryInterface
(
handler
)
;
if
(
!
speculativeHandler
)
return
NS_OK
;
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
channel
-
>
GetLoadInfo
(
)
;
nsCOMPtr
<
nsIPrincipal
>
principal
;
if
(
loadInfo
)
{
principal
=
loadInfo
-
>
LoadingPrincipal
(
)
;
}
nsLoadFlags
loadFlags
=
0
;
channel
-
>
GetLoadFlags
(
&
loadFlags
)
;
if
(
loadFlags
&
nsIRequest
:
:
LOAD_ANONYMOUS
)
{
speculativeHandler
-
>
SpeculativeAnonymousConnect2
(
uri
principal
mCallbacks
)
;
}
else
{
speculativeHandler
-
>
SpeculativeConnect2
(
uri
principal
mCallbacks
)
;
}
return
NS_OK
;
}
nsresult
nsIOService
:
:
SpeculativeConnectInternal
(
nsIURI
*
aURI
nsIPrincipal
*
aPrincipal
nsIInterfaceRequestor
*
aCallbacks
bool
aAnonymous
)
{
NS_ENSURE_ARG
(
aURI
)
;
bool
isHTTP
isHTTPS
;
if
(
!
(
NS_SUCCEEDED
(
aURI
-
>
SchemeIs
(
"
http
"
&
isHTTP
)
)
&
&
isHTTP
)
&
&
!
(
NS_SUCCEEDED
(
aURI
-
>
SchemeIs
(
"
https
"
&
isHTTPS
)
)
&
&
isHTTPS
)
)
{
return
NS_OK
;
}
if
(
IsNeckoChild
(
)
)
{
ipc
:
:
URIParams
params
;
SerializeURI
(
aURI
params
)
;
gNeckoChild
-
>
SendSpeculativeConnect
(
params
IPC
:
:
Principal
(
aPrincipal
)
aAnonymous
)
;
return
NS_OK
;
}
nsresult
rv
;
nsCOMPtr
<
nsIProtocolProxyService
>
pps
=
do_GetService
(
NS_PROTOCOLPROXYSERVICE_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIPrincipal
>
loadingPrincipal
=
aPrincipal
;
MOZ_ASSERT
(
aPrincipal
"
We
expect
passing
a
principal
here
.
"
)
;
nsCOMPtr
<
nsIChannel
>
channel
;
rv
=
NewChannelFromURI2
(
aURI
nullptr
loadingPrincipal
nullptr
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL
nsIContentPolicy
:
:
TYPE_SPECULATIVE
getter_AddRefs
(
channel
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
aAnonymous
)
{
nsLoadFlags
loadFlags
=
0
;
channel
-
>
GetLoadFlags
(
&
loadFlags
)
;
loadFlags
|
=
nsIRequest
:
:
LOAD_ANONYMOUS
;
channel
-
>
SetLoadFlags
(
loadFlags
)
;
}
nsCOMPtr
<
nsICancelable
>
cancelable
;
RefPtr
<
IOServiceProxyCallback
>
callback
=
new
IOServiceProxyCallback
(
aCallbacks
this
)
;
nsCOMPtr
<
nsIProtocolProxyService2
>
pps2
=
do_QueryInterface
(
pps
)
;
if
(
pps2
)
{
return
pps2
-
>
AsyncResolve2
(
channel
0
callback
nullptr
getter_AddRefs
(
cancelable
)
)
;
}
return
pps
-
>
AsyncResolve
(
channel
0
callback
nullptr
getter_AddRefs
(
cancelable
)
)
;
}
NS_IMETHODIMP
nsIOService
:
:
SpeculativeConnect2
(
nsIURI
*
aURI
nsIPrincipal
*
aPrincipal
nsIInterfaceRequestor
*
aCallbacks
)
{
return
SpeculativeConnectInternal
(
aURI
aPrincipal
aCallbacks
false
)
;
}
NS_IMETHODIMP
nsIOService
:
:
SpeculativeAnonymousConnect2
(
nsIURI
*
aURI
nsIPrincipal
*
aPrincipal
nsIInterfaceRequestor
*
aCallbacks
)
{
return
SpeculativeConnectInternal
(
aURI
aPrincipal
aCallbacks
true
)
;
}
bool
nsIOService
:
:
IsDataURIUniqueOpaqueOrigin
(
)
{
return
sIsDataURIUniqueOpaqueOrigin
;
}
bool
nsIOService
:
:
BlockToplevelDataUriNavigations
(
)
{
return
sBlockToplevelDataUriNavigations
;
}
bool
nsIOService
:
:
BlockFTPSubresources
(
)
{
return
sBlockFTPSubresources
;
}
NS_IMETHODIMP
nsIOService
:
:
NotImplemented
(
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
}
}
