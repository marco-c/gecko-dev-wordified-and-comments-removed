#
ifndef
nsBaseChannel_h__
#
define
nsBaseChannel_h__
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
net
/
NeckoTargetHolder
.
h
"
#
include
"
mozilla
/
net
/
PrivateBrowsingChannel
.
h
"
#
include
"
nsHashPropertyBag
.
h
"
#
include
"
nsIAsyncVerifyRedirectCallback
.
h
"
#
include
"
nsIChannel
.
h
"
#
include
"
nsIInterfaceRequestor
.
h
"
#
include
"
nsILoadGroup
.
h
"
#
include
"
nsILoadInfo
.
h
"
#
include
"
nsIProgressEventSink
.
h
"
#
include
"
nsIStreamListener
.
h
"
#
include
"
nsIThreadRetargetableRequest
.
h
"
#
include
"
nsIThreadRetargetableStreamListener
.
h
"
#
include
"
nsITransport
.
h
"
#
include
"
nsITransportSecurityInfo
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsInputStreamPump
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsCOMPtr
.
h
"
class
nsIInputStream
;
class
nsICancelable
;
class
nsBaseChannel
:
public
nsHashPropertyBag
public
nsIChannel
public
nsIThreadRetargetableRequest
public
nsIInterfaceRequestor
public
nsITransportEventSink
public
nsIAsyncVerifyRedirectCallback
public
mozilla
:
:
net
:
:
PrivateBrowsingChannel
<
nsBaseChannel
>
public
mozilla
:
:
net
:
:
NeckoTargetHolder
protected
nsIThreadRetargetableStreamListener
{
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_NSIREQUEST
NS_DECL_NSICHANNEL
NS_DECL_NSIINTERFACEREQUESTOR
NS_DECL_NSITRANSPORTEVENTSINK
NS_DECL_NSIASYNCVERIFYREDIRECTCALLBACK
NS_DECL_NSITHREADRETARGETABLEREQUEST
NS_DECL_NSITHREADRETARGETABLESTREAMLISTENER
nsBaseChannel
(
)
;
protected
:
virtual
~
nsBaseChannel
(
)
;
using
BlockingPromise
=
mozilla
:
:
MozPromise
<
nsresult
nsresult
true
>
;
private
:
virtual
nsresult
OpenContentStream
(
bool
async
nsIInputStream
*
*
stream
nsIChannel
*
*
channel
)
=
0
;
virtual
nsresult
BeginAsyncRead
(
nsIStreamListener
*
listener
nsIRequest
*
*
request
nsICancelable
*
*
cancelableRequest
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
virtual
nsresult
ListenerBlockingPromise
(
BlockingPromise
*
*
aPromise
)
{
NS_ENSURE_ARG
(
aPromise
)
;
*
aPromise
=
nullptr
;
return
NS_OK
;
}
virtual
bool
GetStatusArg
(
nsresult
status
nsString
&
statusArg
)
{
return
false
;
}
virtual
void
OnCallbacksChanged
(
)
{
}
virtual
void
OnChannelDone
(
)
{
}
public
:
nsresult
Redirect
(
nsIChannel
*
newChannel
uint32_t
redirectFlags
bool
openNewChannel
)
;
bool
HasContentTypeHint
(
)
const
;
nsIURI
*
URI
(
)
{
return
mURI
;
}
void
SetURI
(
nsIURI
*
uri
)
{
NS_ASSERTION
(
uri
"
must
specify
a
non
-
null
URI
"
)
;
NS_ASSERTION
(
!
mURI
"
must
not
modify
URI
"
)
;
NS_ASSERTION
(
!
mOriginalURI
"
how
did
that
get
set
so
early
?
"
)
;
mURI
=
uri
;
mOriginalURI
=
uri
;
}
nsIURI
*
OriginalURI
(
)
{
return
mOriginalURI
;
}
nsITransportSecurityInfo
*
SecurityInfo
(
)
{
return
mSecurityInfo
;
}
void
SetSecurityInfo
(
nsITransportSecurityInfo
*
info
)
{
mSecurityInfo
=
info
;
}
bool
HasLoadFlag
(
uint32_t
flag
)
{
return
(
mLoadFlags
&
flag
)
!
=
0
;
}
virtual
bool
Pending
(
)
const
{
return
mPumpingData
|
|
mWaitingOnAsyncRedirect
;
}
class
ContentRange
{
private
:
uint64_t
mStart
;
uint64_t
mEnd
;
uint64_t
mSize
;
public
:
uint64_t
Start
(
)
const
{
return
mStart
;
}
uint64_t
End
(
)
const
{
return
mEnd
;
}
uint64_t
Size
(
)
const
{
return
mSize
;
}
bool
IsValid
(
)
const
{
return
mStart
<
mSize
;
}
ContentRange
(
)
:
mStart
(
0
)
mEnd
(
0
)
mSize
(
0
)
{
}
ContentRange
(
uint64_t
aStart
uint64_t
aEnd
uint64_t
aSize
)
:
mStart
(
aStart
)
mEnd
(
aEnd
)
mSize
(
aSize
)
{
}
ContentRange
(
const
nsACString
&
aRangeHeader
uint64_t
aSize
)
;
void
AsHeader
(
nsACString
&
aOutString
)
const
;
}
;
const
mozilla
:
:
Maybe
<
ContentRange
>
&
GetContentRange
(
)
const
{
return
mContentRange
;
}
void
SetContentRange
(
uint64_t
aStart
uint64_t
aEnd
uint64_t
aSize
)
{
mContentRange
.
emplace
(
ContentRange
(
aStart
aEnd
aSize
)
)
;
}
bool
SetContentRange
(
const
nsACString
&
aRangeHeader
uint64_t
aSize
)
{
auto
range
=
ContentRange
(
aRangeHeader
aSize
)
;
if
(
!
range
.
IsValid
(
)
)
{
return
false
;
}
mContentRange
.
emplace
(
range
)
;
return
true
;
}
template
<
class
T
>
void
GetCallback
(
nsCOMPtr
<
T
>
&
result
)
{
GetInterface
(
NS_GET_TEMPLATE_IID
(
T
)
getter_AddRefs
(
result
)
)
;
}
void
EnableSynthesizedProgressEvents
(
bool
enable
)
{
mSynthProgressEvents
=
enable
;
}
void
SetStreamListener
(
nsIStreamListener
*
listener
)
{
mListener
=
listener
;
}
nsIStreamListener
*
StreamListener
(
)
{
return
mListener
;
}
protected
:
void
DisallowThreadRetargeting
(
)
{
mAllowThreadRetargeting
=
false
;
}
virtual
void
SetupNeckoTarget
(
)
;
private
:
NS_DECL_NSISTREAMLISTENER
NS_DECL_NSIREQUESTOBSERVER
nsresult
BeginPumpingData
(
)
;
void
CallbacksChanged
(
)
{
mProgressSink
=
nullptr
;
mQueriedProgressSink
=
false
;
OnCallbacksChanged
(
)
;
}
void
ChannelDone
(
)
{
mListener
=
nullptr
;
OnChannelDone
(
)
;
}
void
HandleAsyncRedirect
(
nsIChannel
*
newChannel
)
;
void
ContinueHandleAsyncRedirect
(
nsresult
result
)
;
nsresult
ContinueRedirect
(
)
;
void
ClassifyURI
(
)
;
class
RedirectRunnable
:
public
mozilla
:
:
Runnable
{
public
:
RedirectRunnable
(
nsBaseChannel
*
chan
nsIChannel
*
newChannel
)
:
mozilla
:
:
Runnable
(
"
nsBaseChannel
:
:
RedirectRunnable
"
)
mChannel
(
chan
)
mNewChannel
(
newChannel
)
{
MOZ_ASSERT
(
newChannel
"
Must
have
channel
to
redirect
to
"
)
;
}
NS_IMETHOD
Run
(
)
override
{
mChannel
-
>
HandleAsyncRedirect
(
mNewChannel
)
;
return
NS_OK
;
}
private
:
RefPtr
<
nsBaseChannel
>
mChannel
;
nsCOMPtr
<
nsIChannel
>
mNewChannel
;
}
;
friend
class
RedirectRunnable
;
RefPtr
<
nsInputStreamPump
>
mPump
;
RefPtr
<
nsIRequest
>
mRequest
;
nsCOMPtr
<
nsICancelable
>
mCancelableAsyncRequest
;
bool
mPumpingData
{
false
}
;
nsCOMPtr
<
nsIProgressEventSink
>
mProgressSink
;
nsCOMPtr
<
nsIURI
>
mOriginalURI
;
nsCOMPtr
<
nsISupports
>
mOwner
;
nsCOMPtr
<
nsITransportSecurityInfo
>
mSecurityInfo
;
nsCOMPtr
<
nsIChannel
>
mRedirectChannel
;
uint32_t
mLoadFlags
{
LOAD_NORMAL
}
;
bool
mQueriedProgressSink
{
true
}
;
bool
mSynthProgressEvents
{
false
}
;
bool
mAllowThreadRetargeting
{
true
}
;
bool
mWaitingOnAsyncRedirect
{
false
}
;
bool
mOpenRedirectChannel
{
false
}
;
uint32_t
mRedirectFlags
{
0
}
;
mozilla
:
:
Maybe
<
ContentRange
>
mContentRange
;
protected
:
nsCString
mContentType
;
nsCString
mContentCharset
;
nsCOMPtr
<
nsIURI
>
mURI
;
nsCOMPtr
<
nsILoadGroup
>
mLoadGroup
;
nsCOMPtr
<
nsILoadInfo
>
mLoadInfo
;
nsCOMPtr
<
nsIInterfaceRequestor
>
mCallbacks
;
nsCOMPtr
<
nsIStreamListener
>
mListener
;
nsresult
mStatus
{
NS_OK
}
;
uint32_t
mContentDispositionHint
{
UINT32_MAX
}
;
mozilla
:
:
UniquePtr
<
nsString
>
mContentDispositionFilename
;
int64_t
mContentLength
{
-
1
}
;
bool
mWasOpened
{
false
}
;
bool
mCanceled
{
false
}
;
friend
class
mozilla
:
:
net
:
:
PrivateBrowsingChannel
<
nsBaseChannel
>
;
}
;
#
endif
