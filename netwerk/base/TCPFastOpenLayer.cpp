#
include
"
TCPFastOpenLayer
.
h
"
#
include
"
nsSocketTransportService2
.
h
"
#
include
"
prmem
.
h
"
#
include
"
prio
.
h
"
namespace
mozilla
{
namespace
net
{
static
PRDescIdentity
sTCPFastOpenLayerIdentity
;
static
PRIOMethods
sTCPFastOpenLayerMethods
;
static
PRIOMethods
*
sTCPFastOpenLayerMethodsPtr
=
nullptr
;
#
define
TFO_MAX_PACKET_SIZE_IPV4
1460
#
define
TFO_MAX_PACKET_SIZE_IPV6
1440
#
define
TFO_TLS_RECORD_HEADER_SIZE
22
class
TCPFastOpenSecret
{
public
:
TCPFastOpenSecret
(
)
:
mState
(
WAITING_FOR_CONNECT
)
mFirstPacketBufLen
(
0
)
mCondition
(
0
)
{
}
enum
{
CONNECTED
WAITING_FOR_CONNECTCONTINUE
COLLECT_DATA_FOR_FIRST_PACKET
WAITING_FOR_CONNECT
SOCKET_ERROR_STATE
}
mState
;
PRNetAddr
mAddr
;
char
mFirstPacketBuf
[
1460
]
;
uint16_t
mFirstPacketBufLen
;
PRErrorCode
mCondition
;
}
;
static
PRStatus
TCPFastOpenConnect
(
PRFileDesc
*
fd
const
PRNetAddr
*
addr
PRIntervalTime
timeout
)
{
MOZ_RELEASE_ASSERT
(
fd
-
>
identity
=
=
sTCPFastOpenLayerIdentity
)
;
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
TCPFastOpenSecret
*
secret
=
reinterpret_cast
<
TCPFastOpenSecret
*
>
(
fd
-
>
secret
)
;
SOCKET_LOG
(
(
"
TCPFastOpenConnect
state
=
%
d
.
\
n
"
secret
-
>
mState
)
)
;
if
(
secret
-
>
mState
!
=
TCPFastOpenSecret
:
:
WAITING_FOR_CONNECT
)
{
PR_SetError
(
PR_IS_CONNECTED_ERROR
0
)
;
return
PR_FAILURE
;
}
memcpy
(
&
secret
-
>
mAddr
addr
sizeof
(
secret
-
>
mAddr
)
)
;
secret
-
>
mState
=
TCPFastOpenSecret
:
:
COLLECT_DATA_FOR_FIRST_PACKET
;
return
PR_SUCCESS
;
}
static
PRInt32
TCPFastOpenSend
(
PRFileDesc
*
fd
const
void
*
buf
PRInt32
amount
PRIntn
flags
PRIntervalTime
timeout
)
{
MOZ_RELEASE_ASSERT
(
fd
-
>
identity
=
=
sTCPFastOpenLayerIdentity
)
;
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
TCPFastOpenSecret
*
secret
=
reinterpret_cast
<
TCPFastOpenSecret
*
>
(
fd
-
>
secret
)
;
SOCKET_LOG
(
(
"
TCPFastOpenSend
state
=
%
d
.
\
n
"
secret
-
>
mState
)
)
;
switch
(
secret
-
>
mState
)
{
case
TCPFastOpenSecret
:
:
CONNECTED
:
if
(
secret
-
>
mFirstPacketBufLen
)
{
SOCKET_LOG
(
(
"
TCPFastOpenSend
-
%
d
bytes
to
drain
from
"
"
mFirstPacketBufLen
.
\
n
"
secret
-
>
mFirstPacketBufLen
)
)
;
PRInt32
rv
=
(
fd
-
>
lower
-
>
methods
-
>
send
)
(
fd
-
>
lower
secret
-
>
mFirstPacketBuf
secret
-
>
mFirstPacketBufLen
0
PR_INTERVAL_NO_WAIT
)
;
if
(
rv
<
=
0
)
{
return
rv
;
}
else
{
secret
-
>
mFirstPacketBufLen
-
=
rv
;
if
(
secret
-
>
mFirstPacketBufLen
)
{
memmove
(
secret
-
>
mFirstPacketBuf
secret
-
>
mFirstPacketBuf
+
rv
secret
-
>
mFirstPacketBufLen
)
;
PR_SetError
(
PR_WOULD_BLOCK_ERROR
0
)
;
return
PR_FAILURE
;
}
}
}
SOCKET_LOG
(
(
"
TCPFastOpenSend
sending
new
data
.
\
n
"
)
)
;
return
(
fd
-
>
lower
-
>
methods
-
>
send
)
(
fd
-
>
lower
buf
amount
flags
timeout
)
;
case
TCPFastOpenSecret
:
:
WAITING_FOR_CONNECTCONTINUE
:
PR_SetError
(
PR_WOULD_BLOCK_ERROR
0
)
;
return
-
1
;
case
TCPFastOpenSecret
:
:
COLLECT_DATA_FOR_FIRST_PACKET
:
{
int32_t
toSend
=
(
secret
-
>
mAddr
.
raw
.
family
=
=
PR_AF_INET
)
?
TFO_MAX_PACKET_SIZE_IPV4
:
TFO_MAX_PACKET_SIZE_IPV6
;
MOZ_ASSERT
(
secret
-
>
mFirstPacketBufLen
<
=
toSend
)
;
toSend
-
=
secret
-
>
mFirstPacketBufLen
;
SOCKET_LOG
(
(
"
TCPFastOpenSend
:
amount
of
data
in
the
buffer
=
%
d
;
the
amount
"
"
of
additional
data
that
can
be
stored
=
%
d
.
\
n
"
secret
-
>
mFirstPacketBufLen
toSend
)
)
;
if
(
!
toSend
)
{
PR_SetError
(
PR_WOULD_BLOCK_ERROR
0
)
;
return
-
1
;
}
toSend
=
(
toSend
>
amount
)
?
amount
:
toSend
;
memcpy
(
secret
-
>
mFirstPacketBuf
+
secret
-
>
mFirstPacketBufLen
buf
toSend
)
;
secret
-
>
mFirstPacketBufLen
+
=
toSend
;
return
toSend
;
}
case
TCPFastOpenSecret
:
:
WAITING_FOR_CONNECT
:
PR_SetError
(
PR_NOT_CONNECTED_ERROR
0
)
;
return
-
1
;
case
TCPFastOpenSecret
:
:
SOCKET_ERROR_STATE
:
PR_SetError
(
secret
-
>
mCondition
0
)
;
return
-
1
;
}
PR_SetError
(
PR_WOULD_BLOCK_ERROR
0
)
;
return
PR_FAILURE
;
}
static
PRInt32
TCPFastOpenWrite
(
PRFileDesc
*
fd
const
void
*
buf
PRInt32
amount
)
{
return
TCPFastOpenSend
(
fd
buf
amount
0
PR_INTERVAL_NO_WAIT
)
;
}
static
PRInt32
TCPFastOpenRecv
(
PRFileDesc
*
fd
void
*
buf
PRInt32
amount
PRIntn
flags
PRIntervalTime
timeout
)
{
MOZ_RELEASE_ASSERT
(
fd
-
>
identity
=
=
sTCPFastOpenLayerIdentity
)
;
TCPFastOpenSecret
*
secret
=
reinterpret_cast
<
TCPFastOpenSecret
*
>
(
fd
-
>
secret
)
;
PRInt32
rv
=
-
1
;
switch
(
secret
-
>
mState
)
{
case
TCPFastOpenSecret
:
:
CONNECTED
:
if
(
secret
-
>
mFirstPacketBufLen
)
{
SOCKET_LOG
(
(
"
TCPFastOpenRevc
-
%
d
bytes
to
drain
from
mFirstPacketBuf
.
\
n
"
secret
-
>
mFirstPacketBufLen
)
)
;
PRInt32
rv
=
(
fd
-
>
lower
-
>
methods
-
>
send
)
(
fd
-
>
lower
secret
-
>
mFirstPacketBuf
secret
-
>
mFirstPacketBufLen
0
PR_INTERVAL_NO_WAIT
)
;
if
(
rv
<
=
0
)
{
return
rv
;
}
else
{
secret
-
>
mFirstPacketBufLen
-
=
rv
;
if
(
secret
-
>
mFirstPacketBufLen
)
{
memmove
(
secret
-
>
mFirstPacketBuf
secret
-
>
mFirstPacketBuf
+
rv
secret
-
>
mFirstPacketBufLen
)
;
}
}
}
rv
=
(
fd
-
>
lower
-
>
methods
-
>
recv
)
(
fd
-
>
lower
buf
amount
flags
timeout
)
;
break
;
case
TCPFastOpenSecret
:
:
WAITING_FOR_CONNECTCONTINUE
:
case
TCPFastOpenSecret
:
:
COLLECT_DATA_FOR_FIRST_PACKET
:
PR_SetError
(
PR_WOULD_BLOCK_ERROR
0
)
;
break
;
case
TCPFastOpenSecret
:
:
WAITING_FOR_CONNECT
:
PR_SetError
(
PR_NOT_CONNECTED_ERROR
0
)
;
break
;
case
TCPFastOpenSecret
:
:
SOCKET_ERROR_STATE
:
PR_SetError
(
secret
-
>
mCondition
0
)
;
}
return
rv
;
}
static
PRInt32
TCPFastOpenRead
(
PRFileDesc
*
fd
void
*
buf
PRInt32
amount
)
{
return
TCPFastOpenRecv
(
fd
buf
amount
0
PR_INTERVAL_NO_WAIT
)
;
}
static
PRStatus
TCPFastOpenConnectContinue
(
PRFileDesc
*
fd
PRInt16
out_flags
)
{
MOZ_RELEASE_ASSERT
(
fd
-
>
identity
=
=
sTCPFastOpenLayerIdentity
)
;
TCPFastOpenSecret
*
secret
=
reinterpret_cast
<
TCPFastOpenSecret
*
>
(
fd
-
>
secret
)
;
PRStatus
rv
=
PR_FAILURE
;
switch
(
secret
-
>
mState
)
{
case
TCPFastOpenSecret
:
:
CONNECTED
:
rv
=
PR_SUCCESS
;
break
;
case
TCPFastOpenSecret
:
:
WAITING_FOR_CONNECT
:
case
TCPFastOpenSecret
:
:
COLLECT_DATA_FOR_FIRST_PACKET
:
PR_SetError
(
PR_NOT_CONNECTED_ERROR
0
)
;
rv
=
PR_FAILURE
;
break
;
case
TCPFastOpenSecret
:
:
WAITING_FOR_CONNECTCONTINUE
:
rv
=
(
fd
-
>
lower
-
>
methods
-
>
connectcontinue
)
(
fd
-
>
lower
out_flags
)
;
SOCKET_LOG
(
(
"
TCPFastOpenConnectContinue
result
=
%
d
.
\
n
"
rv
)
)
;
secret
-
>
mState
=
TCPFastOpenSecret
:
:
CONNECTED
;
break
;
case
TCPFastOpenSecret
:
:
SOCKET_ERROR_STATE
:
PR_SetError
(
secret
-
>
mCondition
0
)
;
rv
=
PR_FAILURE
;
}
return
rv
;
}
static
PRStatus
TCPFastOpenClose
(
PRFileDesc
*
fd
)
{
if
(
!
fd
)
{
return
PR_FAILURE
;
}
PRFileDesc
*
layer
=
PR_PopIOLayer
(
fd
PR_TOP_IO_LAYER
)
;
MOZ_RELEASE_ASSERT
(
layer
&
&
layer
-
>
identity
=
=
sTCPFastOpenLayerIdentity
"
TCP
Fast
Open
Layer
not
on
top
of
stack
"
)
;
TCPFastOpenSecret
*
secret
=
reinterpret_cast
<
TCPFastOpenSecret
*
>
(
layer
-
>
secret
)
;
layer
-
>
secret
=
nullptr
;
layer
-
>
dtor
(
layer
)
;
delete
secret
;
return
fd
-
>
methods
-
>
close
(
fd
)
;
}
static
PRStatus
TCPFastOpenGetpeername
(
PRFileDesc
*
fd
PRNetAddr
*
addr
)
{
MOZ_RELEASE_ASSERT
(
fd
)
;
MOZ_RELEASE_ASSERT
(
addr
)
;
MOZ_RELEASE_ASSERT
(
fd
-
>
identity
=
=
sTCPFastOpenLayerIdentity
)
;
TCPFastOpenSecret
*
secret
=
reinterpret_cast
<
TCPFastOpenSecret
*
>
(
fd
-
>
secret
)
;
if
(
secret
-
>
mState
=
=
TCPFastOpenSecret
:
:
WAITING_FOR_CONNECT
)
{
PR_SetError
(
PR_NOT_CONNECTED_ERROR
0
)
;
return
PR_FAILURE
;
}
memcpy
(
addr
&
secret
-
>
mAddr
sizeof
(
secret
-
>
mAddr
)
)
;
return
PR_SUCCESS
;
}
static
PRInt16
TCPFastOpenPoll
(
PRFileDesc
*
fd
PRInt16
how_flags
PRInt16
*
p_out_flags
)
{
MOZ_RELEASE_ASSERT
(
fd
)
;
MOZ_RELEASE_ASSERT
(
fd
-
>
identity
=
=
sTCPFastOpenLayerIdentity
)
;
TCPFastOpenSecret
*
secret
=
reinterpret_cast
<
TCPFastOpenSecret
*
>
(
fd
-
>
secret
)
;
if
(
secret
-
>
mFirstPacketBufLen
)
{
how_flags
|
=
PR_POLL_WRITE
;
}
return
fd
-
>
lower
-
>
methods
-
>
poll
(
fd
-
>
lower
how_flags
p_out_flags
)
;
}
nsresult
AttachTCPFastOpenIOLayer
(
PRFileDesc
*
fd
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
if
(
!
sTCPFastOpenLayerMethodsPtr
)
{
sTCPFastOpenLayerIdentity
=
PR_GetUniqueIdentity
(
"
TCPFastOpen
Layer
"
)
;
sTCPFastOpenLayerMethods
=
*
PR_GetDefaultIOMethods
(
)
;
sTCPFastOpenLayerMethods
.
connect
=
TCPFastOpenConnect
;
sTCPFastOpenLayerMethods
.
send
=
TCPFastOpenSend
;
sTCPFastOpenLayerMethods
.
write
=
TCPFastOpenWrite
;
sTCPFastOpenLayerMethods
.
recv
=
TCPFastOpenRecv
;
sTCPFastOpenLayerMethods
.
read
=
TCPFastOpenRead
;
sTCPFastOpenLayerMethods
.
connectcontinue
=
TCPFastOpenConnectContinue
;
sTCPFastOpenLayerMethods
.
close
=
TCPFastOpenClose
;
sTCPFastOpenLayerMethods
.
getpeername
=
TCPFastOpenGetpeername
;
sTCPFastOpenLayerMethods
.
poll
=
TCPFastOpenPoll
;
sTCPFastOpenLayerMethodsPtr
=
&
sTCPFastOpenLayerMethods
;
}
PRFileDesc
*
layer
=
PR_CreateIOLayerStub
(
sTCPFastOpenLayerIdentity
sTCPFastOpenLayerMethodsPtr
)
;
if
(
!
layer
)
{
return
NS_ERROR_FAILURE
;
}
TCPFastOpenSecret
*
secret
=
new
TCPFastOpenSecret
(
)
;
layer
-
>
secret
=
reinterpret_cast
<
PRFilePrivate
*
>
(
secret
)
;
PRStatus
status
=
PR_PushIOLayer
(
fd
PR_NSPR_IO_LAYER
layer
)
;
if
(
status
=
=
PR_FAILURE
)
{
delete
secret
;
PR_DELETE
(
layer
)
;
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
void
TCPFastOpenFinish
(
PRFileDesc
*
fd
PRErrorCode
&
err
bool
&
fastOpenNotSupported
uint8_t
&
tfoStatus
)
{
PRFileDesc
*
tfoFd
=
PR_GetIdentitiesLayer
(
fd
sTCPFastOpenLayerIdentity
)
;
MOZ_RELEASE_ASSERT
(
tfoFd
)
;
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
TCPFastOpenSecret
*
secret
=
reinterpret_cast
<
TCPFastOpenSecret
*
>
(
tfoFd
-
>
secret
)
;
MOZ_ASSERT
(
secret
-
>
mState
=
=
TCPFastOpenSecret
:
:
COLLECT_DATA_FOR_FIRST_PACKET
)
;
fastOpenNotSupported
=
false
;
tfoStatus
=
TFO_NOT_TRIED
;
PRErrorCode
result
=
0
;
PRInt32
rv
=
(
tfoFd
-
>
lower
-
>
methods
-
>
connect
)
(
tfoFd
-
>
lower
&
secret
-
>
mAddr
PR_INTERVAL_NO_WAIT
)
;
if
(
rv
=
=
PR_SUCCESS
)
{
result
=
PR_IS_CONNECTED_ERROR
;
}
else
{
result
=
PR_GetError
(
)
;
}
if
(
tfoFd
-
>
lower
-
>
methods
-
>
sendto
=
=
(
PRSendtoFN
)
tfoFd
-
>
lower
-
>
methods
-
>
reserved_fn_0
)
{
SOCKET_LOG
(
(
"
TCPFastOpenFinish
-
sendto
not
implemented
.
\
n
"
)
)
;
fastOpenNotSupported
=
true
;
}
if
(
result
=
=
PR_IN_PROGRESS_ERROR
)
{
secret
-
>
mState
=
TCPFastOpenSecret
:
:
WAITING_FOR_CONNECTCONTINUE
;
}
else
{
secret
-
>
mState
=
TCPFastOpenSecret
:
:
CONNECTED
;
}
err
=
result
;
}
int32_t
TCPFastOpenGetBufferSizeLeft
(
PRFileDesc
*
fd
)
{
PRFileDesc
*
tfoFd
=
PR_GetIdentitiesLayer
(
fd
sTCPFastOpenLayerIdentity
)
;
MOZ_RELEASE_ASSERT
(
tfoFd
)
;
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
TCPFastOpenSecret
*
secret
=
reinterpret_cast
<
TCPFastOpenSecret
*
>
(
tfoFd
-
>
secret
)
;
if
(
secret
-
>
mState
!
=
TCPFastOpenSecret
:
:
COLLECT_DATA_FOR_FIRST_PACKET
)
{
return
0
;
}
int32_t
sizeLeft
=
(
secret
-
>
mAddr
.
raw
.
family
=
=
PR_AF_INET
)
?
TFO_MAX_PACKET_SIZE_IPV4
:
TFO_MAX_PACKET_SIZE_IPV6
;
MOZ_ASSERT
(
secret
-
>
mFirstPacketBufLen
<
=
sizeLeft
)
;
sizeLeft
-
=
secret
-
>
mFirstPacketBufLen
;
SOCKET_LOG
(
(
"
TCPFastOpenGetBufferSizeLeft
=
%
d
.
\
n
"
sizeLeft
)
)
;
return
(
sizeLeft
>
TFO_TLS_RECORD_HEADER_SIZE
)
?
sizeLeft
-
TFO_TLS_RECORD_HEADER_SIZE
:
0
;
}
bool
TCPFastOpenGetCurrentBufferSize
(
PRFileDesc
*
fd
)
{
PRFileDesc
*
tfoFd
=
PR_GetIdentitiesLayer
(
fd
sTCPFastOpenLayerIdentity
)
;
MOZ_RELEASE_ASSERT
(
tfoFd
)
;
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
TCPFastOpenSecret
*
secret
=
reinterpret_cast
<
TCPFastOpenSecret
*
>
(
tfoFd
-
>
secret
)
;
return
secret
-
>
mFirstPacketBufLen
;
}
bool
TCPFastOpenFlushBuffer
(
PRFileDesc
*
fd
)
{
PRFileDesc
*
tfoFd
=
PR_GetIdentitiesLayer
(
fd
sTCPFastOpenLayerIdentity
)
;
MOZ_RELEASE_ASSERT
(
tfoFd
)
;
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
TCPFastOpenSecret
*
secret
=
reinterpret_cast
<
TCPFastOpenSecret
*
>
(
tfoFd
-
>
secret
)
;
MOZ_ASSERT
(
secret
-
>
mState
=
=
TCPFastOpenSecret
:
:
CONNECTED
)
;
if
(
secret
-
>
mFirstPacketBufLen
)
{
SOCKET_LOG
(
(
"
TCPFastOpenFlushBuffer
-
%
d
bytes
to
drain
from
"
"
mFirstPacketBufLen
.
\
n
"
secret
-
>
mFirstPacketBufLen
)
)
;
PRInt32
rv
=
(
tfoFd
-
>
lower
-
>
methods
-
>
send
)
(
tfoFd
-
>
lower
secret
-
>
mFirstPacketBuf
secret
-
>
mFirstPacketBufLen
0
PR_INTERVAL_NO_WAIT
)
;
if
(
rv
<
=
0
)
{
PRErrorCode
err
=
PR_GetError
(
)
;
if
(
err
=
=
PR_WOULD_BLOCK_ERROR
)
{
return
true
;
}
else
{
secret
-
>
mCondition
=
err
;
secret
-
>
mState
=
TCPFastOpenSecret
:
:
SOCKET_ERROR_STATE
;
return
false
;
}
}
secret
-
>
mFirstPacketBufLen
-
=
rv
;
if
(
secret
-
>
mFirstPacketBufLen
)
{
memmove
(
secret
-
>
mFirstPacketBuf
secret
-
>
mFirstPacketBuf
+
rv
secret
-
>
mFirstPacketBufLen
)
;
}
}
return
secret
-
>
mFirstPacketBufLen
;
}
}
}
