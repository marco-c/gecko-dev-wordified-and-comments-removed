#
ifndef
nsIOService_h__
#
define
nsIOService_h__
#
include
"
nsStringFwd
.
h
"
#
include
"
nsIIOService
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsIWeakReferenceUtils
.
h
"
#
include
"
nsINetUtil
.
h
"
#
include
"
nsIChannelEventSink
.
h
"
#
include
"
nsCategoryCache
.
h
"
#
include
"
nsISpeculativeConnect
.
h
"
#
include
"
nsWeakReference
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
prtime
.
h
"
#
include
"
nsICaptivePortalService
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsTHashSet
.
h
"
#
include
"
nsWeakReference
.
h
"
#
include
"
nsNetCID
.
h
"
#
define
NS_N
(
x
)
(
sizeof
(
x
)
/
sizeof
(
*
(
x
)
)
)
#
define
NS_IPC_IOSERVICE_SET_OFFLINE_TOPIC
"
ipc
:
network
:
set
-
offline
"
#
define
NS_IPC_IOSERVICE_SET_CONNECTIVITY_TOPIC
"
ipc
:
network
:
set
-
connectivity
"
static
const
char
gScheme
[
]
[
sizeof
(
"
moz
-
safe
-
about
"
)
]
=
{
"
chrome
"
"
file
"
"
http
"
"
https
"
"
jar
"
"
data
"
"
about
"
"
moz
-
safe
-
about
"
"
resource
"
"
moz
-
extension
"
"
page
-
icon
"
"
blob
"
}
;
static
const
char
gForcedExternalSchemes
[
]
[
sizeof
(
"
moz
-
nullprincipal
"
)
]
=
{
"
place
"
"
fake
-
favicon
-
uri
"
"
favicon
"
"
moz
-
nullprincipal
"
}
;
class
nsINetworkLinkService
;
class
nsIPrefBranch
;
class
nsIProtocolProxyService2
;
class
nsIProxyInfo
;
class
nsPISocketTransportService
;
namespace
mozilla
{
class
MemoryReportingProcess
;
namespace
net
{
class
NeckoChild
;
class
nsAsyncRedirectVerifyHelper
;
class
SocketProcessHost
;
class
SocketProcessMemoryReporter
;
class
nsIOService
final
:
public
nsIIOService
public
nsIObserver
public
nsINetUtil
public
nsISpeculativeConnect
public
nsSupportsWeakReference
public
nsIIOServiceInternal
public
nsIObserverService
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIIOSERVICE
NS_DECL_NSIOBSERVER
NS_DECL_NSINETUTIL
NS_DECL_NSISPECULATIVECONNECT
NS_DECL_NSIIOSERVICEINTERNAL
NS_DECL_NSIOBSERVERSERVICE
static
already_AddRefed
<
nsIOService
>
GetInstance
(
)
;
nsresult
Init
(
)
;
nsresult
NewURI
(
const
char
*
aSpec
nsIURI
*
aBaseURI
nsIURI
*
*
result
nsIProtocolHandler
*
*
hdlrResult
)
;
nsresult
AsyncOnChannelRedirect
(
nsIChannel
*
oldChan
nsIChannel
*
newChan
uint32_t
flags
nsAsyncRedirectVerifyHelper
*
helper
)
;
bool
IsOffline
(
)
{
return
mOffline
;
}
PRIntervalTime
LastOfflineStateChange
(
)
{
return
mLastOfflineStateChange
;
}
PRIntervalTime
LastConnectivityChange
(
)
{
return
mLastConnectivityChange
;
}
PRIntervalTime
LastNetworkLinkChange
(
)
{
return
mLastNetworkLinkChange
;
}
bool
IsNetTearingDown
(
)
{
return
mShutdown
|
|
mOfflineForProfileChange
|
|
mHttpHandlerAlreadyShutingDown
;
}
PRIntervalTime
NetTearingDownStarted
(
)
{
return
mNetTearingDownStarted
;
}
void
SetHttpHandlerAlreadyShutingDown
(
)
;
bool
IsLinkUp
(
)
;
static
already_AddRefed
<
nsIURI
>
CreateExposableURI
(
nsIURI
*
)
;
void
IncrementRequestNumber
(
)
{
mTotalRequests
+
+
;
}
uint32_t
GetTotalRequestNumber
(
)
{
return
mTotalRequests
;
}
void
IncrementCacheWonRequestNumber
(
)
{
mCacheWon
+
+
;
}
uint32_t
GetCacheWonRequestNumber
(
)
{
return
mCacheWon
;
}
void
IncrementNetWonRequestNumber
(
)
{
mNetWon
+
+
;
}
uint32_t
GetNetWonRequestNumber
(
)
{
return
mNetWon
;
}
nsresult
RecheckCaptivePortal
(
)
;
void
OnProcessLaunchComplete
(
SocketProcessHost
*
aHost
bool
aSucceeded
)
;
void
OnProcessUnexpectedShutdown
(
SocketProcessHost
*
aHost
)
;
bool
SocketProcessReady
(
)
;
static
void
NotifySocketProcessPrefsChanged
(
const
char
*
aName
void
*
aSelf
)
;
void
NotifySocketProcessPrefsChanged
(
const
char
*
aName
)
;
static
bool
UseSocketProcess
(
bool
aCheckAgain
=
false
)
;
bool
IsSocketProcessLaunchComplete
(
)
;
void
CallOrWaitForSocketProcess
(
const
std
:
:
function
<
void
(
)
>
&
aFunc
)
;
int32_t
SocketProcessPid
(
)
;
SocketProcessHost
*
SocketProcess
(
)
{
return
mSocketProcess
;
}
friend
SocketProcessMemoryReporter
;
RefPtr
<
MemoryReportingProcess
>
GetSocketProcessMemoryReporter
(
)
;
static
void
OnTLSPrefChange
(
const
char
*
aPref
void
*
aSelf
)
;
nsresult
LaunchSocketProcess
(
)
;
static
bool
TooManySocketProcessCrash
(
)
;
static
void
IncreaseSocketProcessCrashCount
(
)
;
private
:
nsIOService
(
)
;
~
nsIOService
(
)
;
nsresult
SetConnectivityInternal
(
bool
aConnectivity
)
;
nsresult
OnNetworkLinkEvent
(
const
char
*
data
)
;
nsresult
GetCachedProtocolHandler
(
const
char
*
scheme
nsIProtocolHandler
*
*
hdlrResult
uint32_t
start
=
0
uint32_t
end
=
0
)
;
nsresult
CacheProtocolHandler
(
const
char
*
scheme
nsIProtocolHandler
*
handler
)
;
nsresult
InitializeCaptivePortalService
(
)
;
nsresult
RecheckCaptivePortalIfLocalRedirect
(
nsIChannel
*
newChan
)
;
static
void
PrefsChanged
(
const
char
*
pref
void
*
self
)
;
void
PrefsChanged
(
const
char
*
pref
=
nullptr
)
;
void
ParsePortList
(
const
char
*
pref
bool
remove
)
;
nsresult
InitializeSocketTransportService
(
)
;
nsresult
InitializeNetworkLinkService
(
)
;
nsresult
InitializeProtocolProxyService
(
)
;
void
LookupProxyInfo
(
nsIURI
*
aURI
nsIURI
*
aProxyURI
uint32_t
aProxyFlags
nsCString
*
aScheme
nsIProxyInfo
*
*
outPI
)
;
nsresult
NewChannelFromURIWithProxyFlagsInternal
(
nsIURI
*
aURI
nsIURI
*
aProxyURI
uint32_t
aProxyFlags
nsINode
*
aLoadingNode
nsIPrincipal
*
aLoadingPrincipal
nsIPrincipal
*
aTriggeringPrincipal
const
mozilla
:
:
Maybe
<
mozilla
:
:
dom
:
:
ClientInfo
>
&
aLoadingClientInfo
const
mozilla
:
:
Maybe
<
mozilla
:
:
dom
:
:
ServiceWorkerDescriptor
>
&
aController
uint32_t
aSecurityFlags
nsContentPolicyType
aContentPolicyType
uint32_t
aSandboxFlags
bool
aSkipCheckForBrokenURLOrZeroSized
nsIChannel
*
*
result
)
;
nsresult
NewChannelFromURIWithProxyFlagsInternal
(
nsIURI
*
aURI
nsIURI
*
aProxyURI
uint32_t
aProxyFlags
nsILoadInfo
*
aLoadInfo
nsIChannel
*
*
result
)
;
nsresult
SpeculativeConnectInternal
(
nsIURI
*
aURI
nsIPrincipal
*
aPrincipal
nsIInterfaceRequestor
*
aCallbacks
bool
aAnonymous
)
;
void
DestroySocketProcess
(
)
;
nsresult
SetOfflineInternal
(
bool
offline
bool
notifySocketProcess
=
true
)
;
private
:
mozilla
:
:
Atomic
<
bool
mozilla
:
:
Relaxed
>
mOffline
{
true
}
;
mozilla
:
:
Atomic
<
bool
mozilla
:
:
Relaxed
>
mOfflineForProfileChange
{
false
}
;
bool
mManageLinkStatus
{
false
}
;
mozilla
:
:
Atomic
<
bool
mozilla
:
:
Relaxed
>
mConnectivity
{
true
}
;
bool
mSettingOffline
{
false
}
;
bool
mSetOfflineValue
{
false
}
;
bool
mSocketProcessLaunchComplete
{
false
}
;
mozilla
:
:
Atomic
<
bool
mozilla
:
:
Relaxed
>
mShutdown
{
false
}
;
mozilla
:
:
Atomic
<
bool
mozilla
:
:
Relaxed
>
mHttpHandlerAlreadyShutingDown
{
false
}
;
nsCOMPtr
<
nsPISocketTransportService
>
mSocketTransportService
;
nsCOMPtr
<
nsICaptivePortalService
>
mCaptivePortalService
;
nsCOMPtr
<
nsINetworkLinkService
>
mNetworkLinkService
;
bool
mNetworkLinkServiceInitialized
{
false
}
;
nsWeakPtr
mWeakHandler
[
NS_N
(
gScheme
)
]
;
nsCategoryCache
<
nsIChannelEventSink
>
mChannelEventSinks
{
NS_CHANNEL_EVENT_SINK_CATEGORY
}
;
Mutex
mMutex
{
"
nsIOService
:
:
mMutex
"
}
;
nsTArray
<
int32_t
>
mRestrictedPortList
GUARDED_BY
(
mMutex
)
;
uint32_t
mTotalRequests
{
0
}
;
uint32_t
mCacheWon
{
0
}
;
uint32_t
mNetWon
{
0
}
;
static
uint32_t
sSocketProcessCrashedCount
;
mozilla
:
:
Atomic
<
PRIntervalTime
>
mLastOfflineStateChange
;
mozilla
:
:
Atomic
<
PRIntervalTime
>
mLastConnectivityChange
;
mozilla
:
:
Atomic
<
PRIntervalTime
>
mLastNetworkLinkChange
;
mozilla
:
:
Atomic
<
PRIntervalTime
>
mNetTearingDownStarted
{
0
}
;
SocketProcessHost
*
mSocketProcess
{
nullptr
}
;
nsTArray
<
std
:
:
function
<
void
(
)
>
>
mPendingEvents
;
nsTHashSet
<
nsCString
>
mObserverTopicForSocketProcess
;
nsTHashSet
<
nsCString
>
mSocketProcessTopicBlockedList
;
nsTHashSet
<
nsCString
>
mIOServiceTopicList
;
nsCOMPtr
<
nsIObserverService
>
mObserverService
;
public
:
static
uint32_t
gDefaultSegmentSize
;
static
uint32_t
gDefaultSegmentCount
;
}
;
extern
nsIOService
*
gIOService
;
}
}
#
endif
