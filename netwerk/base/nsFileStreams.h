#
ifndef
nsFileStreams_h__
#
define
nsFileStreams_h__
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsIFileStreams
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsICloneableInputStream
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsIOutputStream
.
h
"
#
include
"
nsISafeOutputStream
.
h
"
#
include
"
nsISeekableStream
.
h
"
#
include
"
nsILineInputStream
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIIPCSerializableInputStream
.
h
"
#
include
"
nsReadLine
.
h
"
#
include
<
algorithm
>
class
nsFileStreamBase
:
public
nsISeekableStream
public
nsIFileMetadata
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS_WITH_RECORDING
(
mozilla
:
:
recordreplay
:
:
Behavior
:
:
Preserve
)
NS_DECL_NSISEEKABLESTREAM
NS_DECL_NSITELLABLESTREAM
NS_DECL_NSIFILEMETADATA
nsFileStreamBase
(
)
;
protected
:
virtual
~
nsFileStreamBase
(
)
;
nsresult
Close
(
)
;
nsresult
Available
(
uint64_t
*
_retval
)
;
nsresult
Read
(
char
*
aBuf
uint32_t
aCount
uint32_t
*
_retval
)
;
nsresult
ReadSegments
(
nsWriteSegmentFun
aWriter
void
*
aClosure
uint32_t
aCount
uint32_t
*
_retval
)
;
nsresult
IsNonBlocking
(
bool
*
_retval
)
;
nsresult
Flush
(
)
;
nsresult
Write
(
const
char
*
aBuf
uint32_t
aCount
uint32_t
*
_retval
)
;
nsresult
WriteFrom
(
nsIInputStream
*
aFromStream
uint32_t
aCount
uint32_t
*
_retval
)
;
nsresult
WriteSegments
(
nsReadSegmentFun
aReader
void
*
aClosure
uint32_t
aCount
uint32_t
*
_retval
)
;
PRFileDesc
*
mFD
;
int32_t
mBehaviorFlags
;
enum
{
eUnitialized
eDeferredOpen
eOpened
eClosed
eError
}
mState
;
struct
OpenParams
{
nsCOMPtr
<
nsIFile
>
localFile
;
int32_t
ioFlags
;
int32_t
perm
;
}
;
OpenParams
mOpenParams
;
nsresult
mErrorValue
;
nsresult
MaybeOpen
(
nsIFile
*
aFile
int32_t
aIoFlags
int32_t
aPerm
bool
aDeferred
)
;
void
CleanUpOpen
(
)
;
virtual
nsresult
DoOpen
(
)
;
inline
nsresult
DoPendingOpen
(
)
;
}
;
class
nsFileInputStream
:
public
nsFileStreamBase
public
nsIFileInputStream
public
nsILineInputStream
public
nsIIPCSerializableInputStream
public
nsICloneableInputStream
{
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_NSIFILEINPUTSTREAM
NS_DECL_NSILINEINPUTSTREAM
NS_DECL_NSIIPCSERIALIZABLEINPUTSTREAM
NS_DECL_NSICLONEABLEINPUTSTREAM
NS_IMETHOD
Close
(
)
override
;
NS_IMETHOD
Tell
(
int64_t
*
aResult
)
override
;
NS_IMETHOD
Available
(
uint64_t
*
_retval
)
override
;
NS_IMETHOD
Read
(
char
*
aBuf
uint32_t
aCount
uint32_t
*
_retval
)
override
;
NS_IMETHOD
ReadSegments
(
nsWriteSegmentFun
aWriter
void
*
aClosure
uint32_t
aCount
uint32_t
*
_retval
)
override
{
return
nsFileStreamBase
:
:
ReadSegments
(
aWriter
aClosure
aCount
_retval
)
;
}
NS_IMETHOD
IsNonBlocking
(
bool
*
_retval
)
override
{
return
nsFileStreamBase
:
:
IsNonBlocking
(
_retval
)
;
}
NS_IMETHOD
Seek
(
int32_t
aWhence
int64_t
aOffset
)
override
;
nsFileInputStream
(
)
:
mLineBuffer
(
nullptr
)
mIOFlags
(
0
)
mPerm
(
0
)
mCachedPosition
(
0
)
{
}
static
nsresult
Create
(
nsISupports
*
aOuter
REFNSIID
aIID
void
*
*
aResult
)
;
protected
:
virtual
~
nsFileInputStream
(
)
=
default
;
void
SerializeInternal
(
mozilla
:
:
ipc
:
:
InputStreamParams
&
aParams
FileDescriptorArray
&
aFileDescriptors
)
;
nsresult
SeekInternal
(
int32_t
aWhence
int64_t
aOffset
bool
aClearBuf
=
true
)
;
nsAutoPtr
<
nsLineBuffer
<
char
>
>
mLineBuffer
;
nsCOMPtr
<
nsIFile
>
mFile
;
int32_t
mIOFlags
;
int32_t
mPerm
;
int64_t
mCachedPosition
;
protected
:
nsresult
Open
(
nsIFile
*
file
int32_t
ioFlags
int32_t
perm
)
;
bool
IsCloneable
(
)
const
;
}
;
class
nsFileOutputStream
:
public
nsFileStreamBase
public
nsIFileOutputStream
{
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_NSIFILEOUTPUTSTREAM
NS_FORWARD_NSIOUTPUTSTREAM
(
nsFileStreamBase
:
:
)
static
nsresult
Create
(
nsISupports
*
aOuter
REFNSIID
aIID
void
*
*
aResult
)
;
protected
:
virtual
~
nsFileOutputStream
(
)
=
default
;
}
;
class
nsAtomicFileOutputStream
:
public
nsFileOutputStream
public
nsISafeOutputStream
{
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_NSISAFEOUTPUTSTREAM
nsAtomicFileOutputStream
(
)
:
mTargetFileExists
(
true
)
mWriteResult
(
NS_OK
)
{
}
virtual
nsresult
DoOpen
(
)
override
;
NS_IMETHOD
Close
(
)
override
;
NS_IMETHOD
Write
(
const
char
*
buf
uint32_t
count
uint32_t
*
result
)
override
;
NS_IMETHOD
Init
(
nsIFile
*
file
int32_t
ioFlags
int32_t
perm
int32_t
behaviorFlags
)
override
;
protected
:
virtual
~
nsAtomicFileOutputStream
(
)
=
default
;
nsCOMPtr
<
nsIFile
>
mTargetFile
;
nsCOMPtr
<
nsIFile
>
mTempFile
;
bool
mTargetFileExists
;
nsresult
mWriteResult
;
}
;
class
nsSafeFileOutputStream
:
public
nsAtomicFileOutputStream
{
public
:
NS_IMETHOD
Finish
(
)
override
;
}
;
class
nsFileStream
:
public
nsFileStreamBase
public
nsIInputStream
public
nsIOutputStream
public
nsIFileStream
{
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_NSIFILESTREAM
NS_FORWARD_NSIINPUTSTREAM
(
nsFileStreamBase
:
:
)
NS_IMETHOD
Flush
(
)
override
{
return
nsFileStreamBase
:
:
Flush
(
)
;
}
NS_IMETHOD
Write
(
const
char
*
aBuf
uint32_t
aCount
uint32_t
*
_retval
)
override
{
return
nsFileStreamBase
:
:
Write
(
aBuf
aCount
_retval
)
;
}
NS_IMETHOD
WriteFrom
(
nsIInputStream
*
aFromStream
uint32_t
aCount
uint32_t
*
_retval
)
override
{
return
nsFileStreamBase
:
:
WriteFrom
(
aFromStream
aCount
_retval
)
;
}
NS_IMETHOD
WriteSegments
(
nsReadSegmentFun
aReader
void
*
aClosure
uint32_t
aCount
uint32_t
*
_retval
)
override
{
return
nsFileStreamBase
:
:
WriteSegments
(
aReader
aClosure
aCount
_retval
)
;
}
protected
:
virtual
~
nsFileStream
(
)
=
default
;
}
;
#
endif
