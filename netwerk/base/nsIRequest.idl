#
include
"
nsISupports
.
idl
"
%
{
C
+
+
#
include
"
nsString
.
h
"
%
}
interface
nsILoadGroup
;
typedef
unsigned
long
nsLoadFlags
;
[
scriptable
uuid
(
ef6bfbd2
-
fd46
-
48d8
-
96b7
-
9f8f0fd387fe
)
]
interface
nsIRequest
:
nsISupports
{
readonly
attribute
AUTF8String
name
;
boolean
isPending
(
)
;
readonly
attribute
nsresult
status
;
void
cancel
(
in
nsresult
aStatus
)
;
void
suspend
(
)
;
void
resume
(
)
;
attribute
nsILoadGroup
loadGroup
;
attribute
nsLoadFlags
loadFlags
;
const
unsigned
long
LOAD_REQUESTMASK
=
0xFFFF
;
const
unsigned
long
LOAD_NORMAL
=
0
;
const
unsigned
long
LOAD_BACKGROUND
=
1
<
<
0
;
const
unsigned
long
LOAD_HTML_OBJECT_DATA
=
1
<
<
1
;
const
unsigned
long
LOAD_DOCUMENT_NEEDS_COOKIE
=
1
<
<
2
;
cenum
TRRMode
:
8
{
TRR_DEFAULT_MODE
=
0
TRR_DISABLED_MODE
=
1
TRR_FIRST_MODE
=
2
TRR_ONLY_MODE
=
3
}
;
nsIRequest_TRRMode
getTRRMode
(
)
;
void
setTRRMode
(
in
nsIRequest_TRRMode
mode
)
;
%
{
C
+
+
inline
TRRMode
GetTRRMode
(
)
{
TRRMode
mode
=
TRR_DEFAULT_MODE
;
GetTRRMode
(
&
mode
)
;
return
mode
;
}
inline
nsresult
GetTRRModeImpl
(
nsIRequest
:
:
TRRMode
*
aTRRMode
)
{
NS_ENSURE_ARG_POINTER
(
aTRRMode
)
;
nsLoadFlags
flags
=
nsIRequest
:
:
LOAD_NORMAL
;
nsresult
rv
=
GetLoadFlags
(
&
flags
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
*
aTRRMode
=
static_cast
<
nsIRequest
:
:
TRRMode
>
(
(
flags
&
nsIRequest
:
:
LOAD_TRR_MASK
)
>
>
3
)
;
return
NS_OK
;
}
inline
nsresult
SetTRRModeImpl
(
nsIRequest
:
:
TRRMode
aTRRMode
)
{
MOZ_ASSERT
(
aTRRMode
<
=
3
"
invalid
value
"
)
;
nsLoadFlags
flags
=
nsIRequest
:
:
LOAD_NORMAL
;
nsresult
rv
=
GetLoadFlags
(
&
flags
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
flags
=
(
flags
&
~
nsIRequest
:
:
LOAD_TRR_MASK
)
|
(
aTRRMode
<
<
3
)
;
return
SetLoadFlags
(
flags
)
;
}
%
}
const
unsigned
long
LOAD_TRR_MASK
=
(
1
<
<
3
)
|
(
1
<
<
4
)
;
const
unsigned
long
LOAD_TRR_DISABLED_MODE
=
1
<
<
3
;
const
unsigned
long
LOAD_TRR_FIRST_MODE
=
1
<
<
4
;
const
unsigned
long
LOAD_TRR_ONLY_MODE
=
(
1
<
<
3
)
|
(
1
<
<
4
)
;
void
cancelWithReason
(
in
nsresult
aStatus
in
ACString
aReason
)
;
attribute
ACString
canceledReason
;
%
{
C
+
+
protected
:
nsCString
mCanceledReason
;
public
:
inline
nsresult
SetCanceledReasonImpl
(
const
nsACString
&
aReason
)
{
if
(
mCanceledReason
.
IsEmpty
(
)
)
{
mCanceledReason
.
Assign
(
aReason
)
;
}
return
NS_OK
;
}
inline
nsresult
CancelWithReasonImpl
(
nsresult
aStatus
const
nsACString
&
aReason
)
{
SetCanceledReasonImpl
(
aReason
)
;
return
Cancel
(
aStatus
)
;
}
inline
nsresult
GetCanceledReasonImpl
(
nsACString
&
aReason
)
{
aReason
.
Assign
(
mCanceledReason
)
;
return
NS_OK
;
}
%
}
const
long
LOAD_ANONYMOUS_ALLOW_CLIENT_CERT
=
1
<
<
5
;
const
long
LOAD_RECORD_START_REQUEST_DELAY
=
1
<
<
6
;
const
unsigned
long
INHIBIT_CACHING
=
1
<
<
7
;
const
unsigned
long
INHIBIT_PERSISTENT_CACHING
=
1
<
<
8
;
const
unsigned
long
LOAD_BYPASS_CACHE
=
1
<
<
9
;
const
unsigned
long
LOAD_FROM_CACHE
=
1
<
<
10
;
const
unsigned
long
VALIDATE_ALWAYS
=
1
<
<
11
;
const
unsigned
long
VALIDATE_NEVER
=
1
<
<
12
;
const
unsigned
long
VALIDATE_ONCE_PER_SESSION
=
1
<
<
13
;
const
unsigned
long
LOAD_ANONYMOUS
=
1
<
<
14
;
const
unsigned
long
LOAD_FRESH_CONNECTION
=
1
<
<
15
;
}
;
