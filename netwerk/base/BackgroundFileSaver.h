#
ifndef
BackgroundFileSaver_h__
#
define
BackgroundFileSaver_h__
#
include
"
ScopedNSSTypes
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
nsCOMArray
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIAsyncOutputStream
.
h
"
#
include
"
nsIBackgroundFileSaver
.
h
"
#
include
"
nsIStreamListener
.
h
"
#
include
"
nsStreamUtils
.
h
"
#
include
"
nsString
.
h
"
class
nsIAsyncInputStream
;
class
nsISerialEventTarget
;
namespace
mozilla
{
namespace
net
{
class
DigestOutputStream
;
class
BackgroundFileSaver
:
public
nsIBackgroundFileSaver
{
public
:
NS_DECL_NSIBACKGROUNDFILESAVER
BackgroundFileSaver
(
)
;
nsresult
Init
(
)
;
static
uint32_t
sThreadCount
;
static
uint32_t
sTelemetryMaxThreadCount
;
protected
:
virtual
~
BackgroundFileSaver
(
)
;
nsCOMPtr
<
nsIEventTarget
>
mControlEventTarget
;
nsCOMPtr
<
nsISerialEventTarget
>
mBackgroundET
;
nsCOMPtr
<
nsIAsyncOutputStream
>
mPipeOutputStream
;
virtual
bool
HasInfiniteBuffer
(
)
=
0
;
virtual
nsAsyncCopyProgressFun
GetProgressCallback
(
)
=
0
;
nsCOMPtr
<
nsIAsyncInputStream
>
mPipeInputStream
;
private
:
friend
class
NotifyTargetChangeRunnable
;
nsCOMPtr
<
nsIBackgroundFileSaverObserver
>
mObserver
;
mozilla
:
:
Mutex
mLock
{
"
BackgroundFileSaver
.
mLock
"
}
;
bool
mWorkerThreadAttentionRequested
{
false
}
;
bool
mFinishRequested
{
false
}
;
bool
mComplete
{
false
}
;
nsresult
mStatus
{
NS_OK
}
;
bool
mAppend
{
false
}
;
nsCOMPtr
<
nsIFile
>
mInitialTarget
;
bool
mInitialTargetKeepPartial
{
false
}
;
nsCOMPtr
<
nsIFile
>
mRenamedTarget
;
bool
mRenamedTargetKeepPartial
{
false
}
;
nsCOMPtr
<
nsISupports
>
mAsyncCopyContext
;
nsCString
mSha256
;
bool
mSha256Enabled
{
false
}
;
nsTArray
<
nsTArray
<
nsTArray
<
uint8_t
>
>
>
mSignatureInfo
;
bool
mSignatureInfoEnabled
{
false
}
;
nsCOMPtr
<
nsIFile
>
mActualTarget
;
bool
mActualTargetKeepPartial
{
false
}
;
Maybe
<
Digest
>
mDigest
;
static
void
AsyncCopyCallback
(
void
*
aClosure
nsresult
aStatus
)
;
nsresult
GetWorkerThreadAttention
(
bool
aShouldInterruptCopy
)
;
nsresult
ProcessAttention
(
)
;
nsresult
ProcessStateChange
(
)
;
bool
CheckCompletion
(
)
;
nsresult
NotifyTargetChange
(
nsIFile
*
aTarget
)
;
nsresult
NotifySaveComplete
(
)
;
nsresult
ExtractSignatureInfo
(
const
nsAString
&
filePath
)
;
}
;
class
BackgroundFileSaverOutputStream
:
public
BackgroundFileSaver
public
nsIAsyncOutputStream
public
nsIOutputStreamCallback
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIOUTPUTSTREAM
NS_DECL_NSIASYNCOUTPUTSTREAM
NS_DECL_NSIOUTPUTSTREAMCALLBACK
BackgroundFileSaverOutputStream
(
)
;
protected
:
virtual
bool
HasInfiniteBuffer
(
)
override
;
virtual
nsAsyncCopyProgressFun
GetProgressCallback
(
)
override
;
private
:
~
BackgroundFileSaverOutputStream
(
)
=
default
;
nsCOMPtr
<
nsIOutputStreamCallback
>
mAsyncWaitCallback
;
}
;
class
BackgroundFileSaverStreamListener
final
:
public
BackgroundFileSaver
public
nsIStreamListener
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIREQUESTOBSERVER
NS_DECL_NSISTREAMLISTENER
BackgroundFileSaverStreamListener
(
)
=
default
;
protected
:
virtual
bool
HasInfiniteBuffer
(
)
override
;
virtual
nsAsyncCopyProgressFun
GetProgressCallback
(
)
override
;
private
:
~
BackgroundFileSaverStreamListener
(
)
=
default
;
mozilla
:
:
Mutex
mSuspensionLock
{
"
BackgroundFileSaverStreamListener
.
mSuspensionLock
"
}
;
bool
mReceivedTooMuchData
{
false
}
;
nsCOMPtr
<
nsIRequest
>
mRequest
;
bool
mRequestSuspended
{
false
}
;
static
void
AsyncCopyProgressCallback
(
void
*
aClosure
uint32_t
aCount
)
;
nsresult
NotifySuspendOrResume
(
)
;
}
;
class
DigestOutputStream
:
public
nsIOutputStream
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIOUTPUTSTREAM
DigestOutputStream
(
nsIOutputStream
*
aStream
Digest
&
aDigest
)
;
private
:
virtual
~
DigestOutputStream
(
)
=
default
;
nsCOMPtr
<
nsIOutputStream
>
mOutputStream
;
Digest
&
mDigest
;
DigestOutputStream
(
const
DigestOutputStream
&
d
)
=
delete
;
}
;
}
}
#
endif
