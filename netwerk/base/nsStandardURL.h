#
ifndef
nsStandardURL_h__
#
define
nsStandardURL_h__
#
include
"
nsString
.
h
"
#
include
"
nsISerializable
.
h
"
#
include
"
nsIFileURL
.
h
"
#
include
"
nsIStandardURL
.
h
"
#
include
"
mozilla
/
Encoding
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsURLHelper
.
h
"
#
include
"
nsIClassInfo
.
h
"
#
include
"
nsISizeOf
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
nsISensitiveInfoHiddenURI
.
h
"
#
include
"
nsIURIMutator
.
h
"
#
ifdef
NS_BUILD_REFCNT_LOGGING
#
define
DEBUG_DUMP_URLS_AT_SHUTDOWN
#
endif
class
nsIBinaryInputStream
;
class
nsIBinaryOutputStream
;
class
nsIIDNService
;
class
nsIPrefBranch
;
class
nsIFile
;
class
nsIURLParser
;
namespace
mozilla
{
class
Encoding
;
namespace
net
{
class
nsStandardURL
:
public
nsIFileURL
public
nsIStandardURL
public
nsISerializable
public
nsIClassInfo
public
nsISizeOf
public
nsISensitiveInfoHiddenURI
#
ifdef
DEBUG_DUMP_URLS_AT_SHUTDOWN
public
LinkedListElement
<
nsStandardURL
>
#
endif
{
protected
:
virtual
~
nsStandardURL
(
)
;
explicit
nsStandardURL
(
bool
aSupportsFileURL
=
false
bool
aTrackURL
=
true
)
;
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIURI
NS_DECL_NSIURL
NS_DECL_NSIFILEURL
NS_DECL_NSISTANDARDURL
NS_DECL_NSISERIALIZABLE
NS_DECL_NSICLASSINFO
NS_DECL_NSISENSITIVEINFOHIDDENURI
virtual
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
override
;
virtual
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
override
;
static
void
InitGlobalObjects
(
)
;
static
void
ShutdownGlobalObjects
(
)
;
public
:
struct
URLSegment
{
uint32_t
mPos
;
int32_t
mLen
;
URLSegment
(
)
:
mPos
(
0
)
mLen
(
-
1
)
{
}
URLSegment
(
uint32_t
pos
int32_t
len
)
:
mPos
(
pos
)
mLen
(
len
)
{
}
URLSegment
(
const
URLSegment
&
aCopy
)
=
default
;
void
Reset
(
)
{
mPos
=
0
;
mLen
=
-
1
;
}
void
Merge
(
const
nsCString
&
spec
const
char
separator
const
URLSegment
&
right
)
{
if
(
mLen
>
=
0
&
&
*
(
spec
.
get
(
)
+
mPos
+
mLen
)
=
=
separator
&
&
mPos
+
mLen
+
1
=
=
right
.
mPos
)
{
mLen
+
=
1
+
right
.
mLen
;
}
}
}
;
class
nsSegmentEncoder
{
public
:
explicit
nsSegmentEncoder
(
const
Encoding
*
encoding
=
nullptr
)
;
int32_t
EncodeSegmentCount
(
const
char
*
str
const
URLSegment
&
segment
int16_t
mask
nsCString
&
buf
bool
&
appended
uint32_t
extraLen
=
0
)
;
const
nsACString
&
EncodeSegment
(
const
nsACString
&
str
int16_t
mask
nsCString
&
buf
)
;
private
:
const
Encoding
*
mEncoding
;
}
;
friend
class
nsSegmentEncoder
;
static
nsresult
NormalizeIPv4
(
const
nsACString
&
host
nsCString
&
result
)
;
protected
:
enum
RefHandlingEnum
{
eIgnoreRef
eHonorRef
eReplaceRef
}
;
nsresult
EqualsInternal
(
nsIURI
*
unknownOther
RefHandlingEnum
refHandlingMode
bool
*
result
)
;
virtual
nsStandardURL
*
StartClone
(
)
;
nsresult
CloneInternal
(
RefHandlingEnum
aRefHandlingMode
const
nsACString
&
newRef
nsIURI
*
*
aClone
)
;
nsresult
CopyMembers
(
nsStandardURL
*
source
RefHandlingEnum
mode
const
nsACString
&
newRef
bool
copyCached
=
false
)
;
virtual
nsresult
EnsureFile
(
)
;
virtual
nsresult
Clone
(
nsIURI
*
*
aURI
)
;
virtual
nsresult
SetSpecInternal
(
const
nsACString
&
input
)
;
virtual
nsresult
SetScheme
(
const
nsACString
&
input
)
;
virtual
nsresult
SetUserPass
(
const
nsACString
&
input
)
;
virtual
nsresult
SetUsername
(
const
nsACString
&
input
)
;
virtual
nsresult
SetPassword
(
const
nsACString
&
input
)
;
virtual
nsresult
SetHostPort
(
const
nsACString
&
aValue
)
;
virtual
nsresult
SetHost
(
const
nsACString
&
input
)
;
virtual
nsresult
SetPort
(
int32_t
port
)
;
virtual
nsresult
SetPathQueryRef
(
const
nsACString
&
input
)
;
virtual
nsresult
SetRef
(
const
nsACString
&
input
)
;
virtual
nsresult
SetFilePath
(
const
nsACString
&
input
)
;
virtual
nsresult
SetQuery
(
const
nsACString
&
input
)
;
virtual
nsresult
SetQueryWithEncoding
(
const
nsACString
&
input
const
Encoding
*
encoding
)
;
bool
Deserialize
(
const
mozilla
:
:
ipc
:
:
URIParams
&
)
;
nsresult
ReadPrivate
(
nsIObjectInputStream
*
stream
)
;
private
:
nsresult
Init
(
uint32_t
urlType
int32_t
defaultPort
const
nsACString
&
spec
const
char
*
charset
nsIURI
*
baseURI
)
;
nsresult
SetDefaultPort
(
int32_t
aNewDefaultPort
)
;
nsresult
SetFile
(
nsIFile
*
file
)
;
nsresult
SetFileNameInternal
(
const
nsACString
&
input
)
;
nsresult
SetFileBaseNameInternal
(
const
nsACString
&
input
)
;
nsresult
SetFileExtensionInternal
(
const
nsACString
&
input
)
;
int32_t
Port
(
)
{
return
mPort
=
=
-
1
?
mDefaultPort
:
mPort
;
}
void
ReplacePortInSpec
(
int32_t
aNewPort
)
;
void
Clear
(
)
;
void
InvalidateCache
(
bool
invalidateCachedFile
=
true
)
;
bool
ValidIPv6orHostname
(
const
char
*
host
uint32_t
aLen
)
;
static
bool
IsValidOfBase
(
unsigned
char
c
const
uint32_t
base
)
;
nsresult
NormalizeIDN
(
const
nsACString
&
host
nsCString
&
result
)
;
nsresult
CheckIfHostIsAscii
(
)
;
void
CoalescePath
(
netCoalesceFlags
coalesceFlag
char
*
path
)
;
uint32_t
AppendSegmentToBuf
(
char
*
uint32_t
const
char
*
const
URLSegment
&
input
URLSegment
&
output
const
nsCString
*
esc
=
nullptr
bool
useEsc
=
false
int32_t
*
diff
=
nullptr
)
;
uint32_t
AppendToBuf
(
char
*
uint32_t
const
char
*
uint32_t
)
;
nsresult
BuildNormalizedSpec
(
const
char
*
spec
const
Encoding
*
encoding
)
;
nsresult
SetSpecWithEncoding
(
const
nsACString
&
input
const
Encoding
*
encoding
)
;
bool
SegmentIs
(
const
URLSegment
&
s1
const
char
*
val
bool
ignoreCase
=
false
)
;
bool
SegmentIs
(
const
char
*
spec
const
URLSegment
&
s1
const
char
*
val
bool
ignoreCase
=
false
)
;
bool
SegmentIs
(
const
URLSegment
&
s1
const
char
*
val
const
URLSegment
&
s2
bool
ignoreCase
=
false
)
;
int32_t
ReplaceSegment
(
uint32_t
pos
uint32_t
len
const
char
*
val
uint32_t
valLen
)
;
int32_t
ReplaceSegment
(
uint32_t
pos
uint32_t
len
const
nsACString
&
val
)
;
nsresult
ParseURL
(
const
char
*
spec
int32_t
specLen
)
;
nsresult
ParsePath
(
const
char
*
spec
uint32_t
pathPos
int32_t
pathLen
=
-
1
)
;
char
*
AppendToSubstring
(
uint32_t
pos
int32_t
len
const
char
*
tail
)
;
const
nsDependentCSubstring
Segment
(
uint32_t
pos
int32_t
len
)
;
const
nsDependentCSubstring
Segment
(
const
URLSegment
&
s
)
{
return
Segment
(
s
.
mPos
s
.
mLen
)
;
}
const
nsDependentCSubstring
Prepath
(
)
;
const
nsDependentCSubstring
Scheme
(
)
{
return
Segment
(
mScheme
)
;
}
const
nsDependentCSubstring
Userpass
(
bool
includeDelim
=
false
)
;
const
nsDependentCSubstring
Username
(
)
{
return
Segment
(
mUsername
)
;
}
const
nsDependentCSubstring
Password
(
)
{
return
Segment
(
mPassword
)
;
}
const
nsDependentCSubstring
Hostport
(
)
;
const
nsDependentCSubstring
Host
(
)
;
const
nsDependentCSubstring
Path
(
)
{
return
Segment
(
mPath
)
;
}
const
nsDependentCSubstring
Filepath
(
)
{
return
Segment
(
mFilepath
)
;
}
const
nsDependentCSubstring
Directory
(
)
{
return
Segment
(
mDirectory
)
;
}
const
nsDependentCSubstring
Filename
(
)
;
const
nsDependentCSubstring
Basename
(
)
{
return
Segment
(
mBasename
)
;
}
const
nsDependentCSubstring
Extension
(
)
{
return
Segment
(
mExtension
)
;
}
const
nsDependentCSubstring
Query
(
)
{
return
Segment
(
mQuery
)
;
}
const
nsDependentCSubstring
Ref
(
)
{
return
Segment
(
mRef
)
;
}
void
ShiftFromAuthority
(
int32_t
diff
)
;
void
ShiftFromUsername
(
int32_t
diff
)
;
void
ShiftFromPassword
(
int32_t
diff
)
;
void
ShiftFromHost
(
int32_t
diff
)
;
void
ShiftFromPath
(
int32_t
diff
)
;
void
ShiftFromFilepath
(
int32_t
diff
)
;
void
ShiftFromDirectory
(
int32_t
diff
)
;
void
ShiftFromBasename
(
int32_t
diff
)
;
void
ShiftFromExtension
(
int32_t
diff
)
;
void
ShiftFromQuery
(
int32_t
diff
)
;
void
ShiftFromRef
(
int32_t
diff
)
;
nsresult
ReadSegment
(
nsIBinaryInputStream
*
URLSegment
&
)
;
nsresult
WriteSegment
(
nsIBinaryOutputStream
*
const
URLSegment
&
)
;
void
FindHostLimit
(
nsACString
:
:
const_iterator
&
aStart
nsACString
:
:
const_iterator
&
aEnd
)
;
nsCString
mSpec
;
int32_t
mDefaultPort
;
int32_t
mPort
;
URLSegment
mScheme
;
URLSegment
mAuthority
;
URLSegment
mUsername
;
URLSegment
mPassword
;
URLSegment
mHost
;
URLSegment
mPath
;
URLSegment
mFilepath
;
URLSegment
mDirectory
;
URLSegment
mBasename
;
URLSegment
mExtension
;
URLSegment
mQuery
;
URLSegment
mRef
;
nsCOMPtr
<
nsIURLParser
>
mParser
;
protected
:
nsCOMPtr
<
nsIFile
>
mFile
;
private
:
nsCString
mDisplayHost
;
enum
{
eEncoding_Unknown
eEncoding_ASCII
eEncoding_UTF8
}
;
uint32_t
mURLType
:
2
;
uint32_t
mSupportsFileURL
:
1
;
uint32_t
mCheckedIfHostA
:
1
;
static
nsIIDNService
*
gIDN
;
static
const
char
gHostLimitDigits
[
]
;
static
bool
gInitialized
;
static
bool
gPunycodeHost
;
public
:
#
ifdef
DEBUG_DUMP_URLS_AT_SHUTDOWN
void
PrintSpec
(
)
const
{
printf
(
"
%
s
\
n
"
mSpec
.
get
(
)
)
;
}
#
endif
public
:
template
<
class
T
>
class
TemplatedMutator
:
public
nsIURIMutator
public
BaseURIMutator
<
T
>
public
nsIStandardURLMutator
public
nsIURLMutator
public
nsIFileURLMutator
public
nsISerializable
{
NS_FORWARD_SAFE_NSIURISETTERS_RET
(
BaseURIMutator
<
T
>
:
:
mURI
)
MOZ_MUST_USE
NS_IMETHOD
Deserialize
(
const
mozilla
:
:
ipc
:
:
URIParams
&
aParams
)
override
{
return
BaseURIMutator
<
T
>
:
:
InitFromIPCParams
(
aParams
)
;
}
NS_IMETHOD
Write
(
nsIObjectOutputStream
*
aOutputStream
)
override
{
MOZ_ASSERT_UNREACHABLE
(
"
Use
nsIURIMutator
.
read
(
)
instead
"
)
;
return
NS_ERROR_NOT_IMPLEMENTED
;
}
MOZ_MUST_USE
NS_IMETHOD
Read
(
nsIObjectInputStream
*
aStream
)
override
{
return
BaseURIMutator
<
T
>
:
:
InitFromInputStream
(
aStream
)
;
}
MOZ_MUST_USE
NS_IMETHOD
Finalize
(
nsIURI
*
*
aURI
)
override
{
BaseURIMutator
<
T
>
:
:
mURI
.
forget
(
aURI
)
;
return
NS_OK
;
}
MOZ_MUST_USE
NS_IMETHOD
SetSpec
(
const
nsACString
&
aSpec
nsIURIMutator
*
*
aMutator
)
override
{
if
(
aMutator
)
{
nsCOMPtr
<
nsIURIMutator
>
mutator
=
this
;
mutator
.
forget
(
aMutator
)
;
}
return
BaseURIMutator
<
T
>
:
:
InitFromSpec
(
aSpec
)
;
}
MOZ_MUST_USE
NS_IMETHOD
Init
(
uint32_t
aURLType
int32_t
aDefaultPort
const
nsACString
&
aSpec
const
char
*
aCharset
nsIURI
*
aBaseURI
nsIURIMutator
*
*
aMutator
)
override
{
if
(
aMutator
)
{
nsCOMPtr
<
nsIURIMutator
>
mutator
=
this
;
mutator
.
forget
(
aMutator
)
;
}
RefPtr
<
T
>
uri
;
if
(
BaseURIMutator
<
T
>
:
:
mURI
)
{
BaseURIMutator
<
T
>
:
:
mURI
.
swap
(
uri
)
;
}
else
{
uri
=
Create
(
)
;
}
nsresult
rv
=
uri
-
>
Init
(
aURLType
aDefaultPort
aSpec
aCharset
aBaseURI
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
BaseURIMutator
<
T
>
:
:
mURI
=
uri
.
forget
(
)
;
return
NS_OK
;
}
MOZ_MUST_USE
NS_IMETHODIMP
SetDefaultPort
(
int32_t
aNewDefaultPort
nsIURIMutator
*
*
aMutator
)
override
{
if
(
!
BaseURIMutator
<
T
>
:
:
mURI
)
{
return
NS_ERROR_NULL_POINTER
;
}
if
(
aMutator
)
{
nsCOMPtr
<
nsIURIMutator
>
mutator
=
this
;
mutator
.
forget
(
aMutator
)
;
}
return
BaseURIMutator
<
T
>
:
:
mURI
-
>
SetDefaultPort
(
aNewDefaultPort
)
;
}
MOZ_MUST_USE
NS_IMETHOD
SetFileName
(
const
nsACString
&
aFileName
nsIURIMutator
*
*
aMutator
)
override
{
if
(
!
BaseURIMutator
<
T
>
:
:
mURI
)
{
return
NS_ERROR_NULL_POINTER
;
}
if
(
aMutator
)
{
nsCOMPtr
<
nsIURIMutator
>
mutator
=
this
;
mutator
.
forget
(
aMutator
)
;
}
return
BaseURIMutator
<
T
>
:
:
mURI
-
>
SetFileNameInternal
(
aFileName
)
;
}
MOZ_MUST_USE
NS_IMETHOD
SetFileBaseName
(
const
nsACString
&
aFileBaseName
nsIURIMutator
*
*
aMutator
)
override
{
if
(
!
BaseURIMutator
<
T
>
:
:
mURI
)
{
return
NS_ERROR_NULL_POINTER
;
}
if
(
aMutator
)
{
nsCOMPtr
<
nsIURIMutator
>
mutator
=
this
;
mutator
.
forget
(
aMutator
)
;
}
return
BaseURIMutator
<
T
>
:
:
mURI
-
>
SetFileBaseNameInternal
(
aFileBaseName
)
;
}
MOZ_MUST_USE
NS_IMETHOD
SetFileExtension
(
const
nsACString
&
aFileExtension
nsIURIMutator
*
*
aMutator
)
override
{
if
(
!
BaseURIMutator
<
T
>
:
:
mURI
)
{
return
NS_ERROR_NULL_POINTER
;
}
if
(
aMutator
)
{
nsCOMPtr
<
nsIURIMutator
>
mutator
=
this
;
mutator
.
forget
(
aMutator
)
;
}
return
BaseURIMutator
<
T
>
:
:
mURI
-
>
SetFileExtensionInternal
(
aFileExtension
)
;
}
T
*
Create
(
)
override
{
return
new
T
(
mMarkedFileURL
)
;
}
MOZ_MUST_USE
NS_IMETHOD
MarkFileURL
(
)
override
{
mMarkedFileURL
=
true
;
return
NS_OK
;
}
MOZ_MUST_USE
NS_IMETHOD
SetFile
(
nsIFile
*
aFile
)
override
{
RefPtr
<
T
>
uri
;
if
(
BaseURIMutator
<
T
>
:
:
mURI
)
{
BaseURIMutator
<
T
>
:
:
mURI
.
swap
(
uri
)
;
}
else
{
uri
=
new
T
(
true
)
;
}
nsresult
rv
=
uri
-
>
SetFile
(
aFile
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
BaseURIMutator
<
T
>
:
:
mURI
.
swap
(
uri
)
;
return
NS_OK
;
}
explicit
TemplatedMutator
(
)
:
mMarkedFileURL
(
false
)
{
}
private
:
virtual
~
TemplatedMutator
(
)
=
default
;
bool
mMarkedFileURL
=
false
;
friend
T
;
}
;
class
Mutator
final
:
public
TemplatedMutator
<
nsStandardURL
>
{
NS_DECL_ISUPPORTS
public
:
explicit
Mutator
(
)
=
default
;
private
:
virtual
~
Mutator
(
)
=
default
;
}
;
friend
BaseURIMutator
<
nsStandardURL
>
;
}
;
#
define
NS_THIS_STANDARDURL_IMPL_CID
\
{
/
*
b8e3e97b
-
1ccd
-
4b45
-
af5a
-
79596770f5d7
*
/
\
0xb8e3e97b
0x1ccd
0x4b45
{
\
0xaf
0x5a
0x79
0x59
0x67
0x70
0xf5
0xd7
\
}
\
}
inline
const
nsDependentCSubstring
nsStandardURL
:
:
Segment
(
uint32_t
pos
int32_t
len
)
{
if
(
len
<
0
)
{
pos
=
0
;
len
=
0
;
}
return
Substring
(
mSpec
pos
uint32_t
(
len
)
)
;
}
inline
const
nsDependentCSubstring
nsStandardURL
:
:
Prepath
(
)
{
uint32_t
len
=
0
;
if
(
mAuthority
.
mLen
>
=
0
)
len
=
mAuthority
.
mPos
+
mAuthority
.
mLen
;
return
Substring
(
mSpec
0
len
)
;
}
inline
const
nsDependentCSubstring
nsStandardURL
:
:
Userpass
(
bool
includeDelim
)
{
uint32_t
pos
=
0
len
=
0
;
if
(
mUsername
.
mLen
>
0
|
|
mPassword
.
mLen
>
0
)
{
if
(
mUsername
.
mLen
>
0
)
{
pos
=
mUsername
.
mPos
;
len
=
mUsername
.
mLen
;
if
(
mPassword
.
mLen
>
=
0
)
{
len
+
=
(
mPassword
.
mLen
+
1
)
;
}
}
else
{
pos
=
mPassword
.
mPos
-
1
;
len
=
mPassword
.
mLen
+
1
;
}
if
(
includeDelim
)
len
+
+
;
}
return
Substring
(
mSpec
pos
len
)
;
}
inline
const
nsDependentCSubstring
nsStandardURL
:
:
Hostport
(
)
{
uint32_t
pos
=
0
len
=
0
;
if
(
mAuthority
.
mLen
>
0
)
{
pos
=
mHost
.
mPos
;
len
=
mAuthority
.
mPos
+
mAuthority
.
mLen
-
pos
;
}
return
Substring
(
mSpec
pos
len
)
;
}
inline
const
nsDependentCSubstring
nsStandardURL
:
:
Host
(
)
{
uint32_t
pos
=
0
len
=
0
;
if
(
mHost
.
mLen
>
0
)
{
pos
=
mHost
.
mPos
;
len
=
mHost
.
mLen
;
if
(
mSpec
.
CharAt
(
pos
)
=
=
'
[
'
&
&
mSpec
.
CharAt
(
pos
+
len
-
1
)
=
=
'
]
'
)
{
pos
+
+
;
len
-
=
2
;
}
}
return
Substring
(
mSpec
pos
len
)
;
}
inline
const
nsDependentCSubstring
nsStandardURL
:
:
Filename
(
)
{
uint32_t
pos
=
0
len
=
0
;
if
(
mBasename
.
mLen
>
0
)
{
pos
=
mBasename
.
mPos
;
len
=
mBasename
.
mLen
;
if
(
mExtension
.
mLen
>
=
0
)
len
+
=
(
mExtension
.
mLen
+
1
)
;
}
return
Substring
(
mSpec
pos
len
)
;
}
}
}
#
endif
