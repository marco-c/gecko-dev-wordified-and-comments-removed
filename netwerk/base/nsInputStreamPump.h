#
ifndef
nsInputStreamPump_h__
#
define
nsInputStreamPump_h__
#
include
"
nsIInputStreamPump
.
h
"
#
include
"
nsIAsyncInputStream
.
h
"
#
include
"
nsIThreadRetargetableRequest
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
RecursiveMutex
.
h
"
#
ifdef
DEBUG
#
include
"
MainThreadUtils
.
h
"
#
include
"
nsIEventTarget
.
h
"
#
endif
class
nsIInputStream
;
class
nsILoadGroup
;
class
nsIStreamListener
;
#
define
NS_INPUT_STREAM_PUMP_IID
\
{
\
0x42f1cc9b
0xdf5f
0x4c9b
{
\
0xbd
0x71
0x8d
0x4a
0xe2
0x27
0xc1
0x8a
\
}
\
}
class
nsInputStreamPump
final
:
public
nsIInputStreamPump
public
nsIInputStreamCallback
public
nsIThreadRetargetableRequest
{
~
nsInputStreamPump
(
)
=
default
;
public
:
using
RecursiveMutexAutoLock
=
mozilla
:
:
RecursiveMutexAutoLock
;
using
RecursiveMutexAutoUnlock
=
mozilla
:
:
RecursiveMutexAutoUnlock
;
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIREQUEST
NS_DECL_NSIINPUTSTREAMPUMP
NS_DECL_NSIINPUTSTREAMCALLBACK
NS_DECL_NSITHREADRETARGETABLEREQUEST
NS_DECLARE_STATIC_IID_ACCESSOR
(
NS_INPUT_STREAM_PUMP_IID
)
nsInputStreamPump
(
)
;
static
nsresult
Create
(
nsInputStreamPump
*
*
result
nsIInputStream
*
stream
uint32_t
segsize
=
0
uint32_t
segcount
=
0
bool
closeWhenDone
=
false
nsIEventTarget
*
mainThreadTarget
=
nullptr
)
;
using
PeekSegmentFun
=
void
(
*
)
(
void
*
const
uint8_t
*
uint32_t
)
;
nsresult
PeekStream
(
PeekSegmentFun
callback
void
*
closure
)
;
nsresult
CallOnStateStop
(
)
;
protected
:
enum
{
STATE_IDLE
STATE_START
STATE_TRANSFER
STATE_STOP
STATE_DEAD
}
;
nsresult
EnsureWaiting
(
)
;
uint32_t
OnStateStart
(
)
;
uint32_t
OnStateTransfer
(
)
;
uint32_t
OnStateStop
(
)
;
nsresult
CreateBufferedStreamIfNeeded
(
)
REQUIRES
(
mMutex
)
;
MOZ_ALWAYS_INLINE
void
AssertOnThread
(
)
const
{
PUSH_IGNORE_THREAD_SAFETY
if
(
mOffMainThread
)
{
MOZ_ASSERT
(
mTargetThread
-
>
IsOnCurrentThread
(
)
)
;
}
else
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
POP_THREAD_SAFETY
}
uint32_t
mState
GUARDED_BY
(
mMutex
)
{
STATE_IDLE
}
;
nsCOMPtr
<
nsILoadGroup
>
mLoadGroup
GUARDED_BY
(
mMutex
)
;
nsCOMPtr
<
nsIStreamListener
>
mListener
GUARDED_BY
(
mMutex
)
;
nsCOMPtr
<
nsIEventTarget
>
mTargetThread
GUARDED_BY
(
mMutex
)
;
nsCOMPtr
<
nsIEventTarget
>
mLabeledMainThreadTarget
GUARDED_BY
(
mMutex
)
;
nsCOMPtr
<
nsIInputStream
>
mStream
GUARDED_BY
(
mMutex
)
;
nsCOMPtr
<
nsIAsyncInputStream
>
mAsyncStream
GUARDED_BY
(
mMutex
)
;
uint64_t
mStreamOffset
GUARDED_BY
(
mMutex
)
{
0
}
;
uint64_t
mStreamLength
GUARDED_BY
(
mMutex
)
{
0
}
;
uint32_t
mSegSize
GUARDED_BY
(
mMutex
)
{
0
}
;
uint32_t
mSegCount
GUARDED_BY
(
mMutex
)
{
0
}
;
nsresult
mStatus
GUARDED_BY
(
mMutex
)
{
NS_OK
}
;
uint32_t
mSuspendCount
GUARDED_BY
(
mMutex
)
{
0
}
;
uint32_t
mLoadFlags
GUARDED_BY
(
mMutex
)
{
LOAD_NORMAL
}
;
bool
mIsPending
GUARDED_BY
(
mMutex
)
{
false
}
;
bool
mProcessingCallbacks
GUARDED_BY
(
mMutex
)
{
false
}
;
bool
mWaitingForInputStreamReady
GUARDED_BY
(
mMutex
)
{
false
}
;
bool
mCloseWhenDone
GUARDED_BY
(
mMutex
)
{
false
}
;
bool
mRetargeting
GUARDED_BY
(
mMutex
)
{
false
}
;
bool
mAsyncStreamIsBuffered
GUARDED_BY
(
mMutex
)
{
false
}
;
const
bool
mOffMainThread
;
mozilla
:
:
RecursiveMutex
mMutex
{
"
nsInputStreamPump
"
}
;
}
;
NS_DEFINE_STATIC_IID_ACCESSOR
(
nsInputStreamPump
NS_INPUT_STREAM_PUMP_IID
)
#
endif
