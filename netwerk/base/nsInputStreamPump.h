#
ifndef
nsInputStreamPump_h__
#
define
nsInputStreamPump_h__
#
include
"
nsIInputStreamPump
.
h
"
#
include
"
nsIAsyncInputStream
.
h
"
#
include
"
nsIThreadRetargetableRequest
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
RecursiveMutex
.
h
"
#
ifdef
DEBUG
#
include
"
MainThreadUtils
.
h
"
#
include
"
nsISerialEventTarget
.
h
"
#
endif
class
nsIInputStream
;
class
nsILoadGroup
;
class
nsIStreamListener
;
#
define
NS_INPUT_STREAM_PUMP_IID
\
{
0x42f1cc9b
0xdf5f
0x4c9b
{
0xbd
0x71
0x8d
0x4a
0xe2
0x27
0xc1
0x8a
}
}
class
nsInputStreamPump
final
:
public
nsIInputStreamPump
public
nsIInputStreamCallback
public
nsIThreadRetargetableRequest
{
~
nsInputStreamPump
(
)
=
default
;
public
:
using
RecursiveMutexAutoLock
=
mozilla
:
:
RecursiveMutexAutoLock
;
using
RecursiveMutexAutoUnlock
=
mozilla
:
:
RecursiveMutexAutoUnlock
;
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIREQUEST
NS_DECL_NSIINPUTSTREAMPUMP
NS_DECL_NSIINPUTSTREAMCALLBACK
NS_DECL_NSITHREADRETARGETABLEREQUEST
NS_INLINE_DECL_STATIC_IID
(
NS_INPUT_STREAM_PUMP_IID
)
nsInputStreamPump
(
)
;
static
nsresult
Create
(
nsInputStreamPump
*
*
result
nsIInputStream
*
stream
uint32_t
segsize
=
0
uint32_t
segcount
=
0
bool
closeWhenDone
=
false
nsISerialEventTarget
*
mainThreadTarget
=
nullptr
)
;
using
PeekSegmentFun
=
void
(
*
)
(
void
*
const
uint8_t
*
uint32_t
)
;
nsresult
PeekStream
(
PeekSegmentFun
callback
void
*
closure
)
;
nsresult
CallOnStateStop
(
)
;
protected
:
enum
{
STATE_IDLE
STATE_START
STATE_TRANSFER
STATE_STOP
STATE_DEAD
}
;
nsresult
EnsureWaiting
(
)
;
uint32_t
OnStateStart
(
)
;
uint32_t
OnStateTransfer
(
)
;
uint32_t
OnStateStop
(
)
;
nsresult
CreateBufferedStreamIfNeeded
(
)
MOZ_REQUIRES
(
mMutex
)
;
MOZ_ALWAYS_INLINE
void
AssertOnThread
(
)
const
MOZ_REQUIRES
(
mMutex
)
{
if
(
mOffMainThread
)
{
MOZ_ASSERT
(
mTargetThread
-
>
IsOnCurrentThread
(
)
)
;
}
else
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
}
uint32_t
mState
MOZ_GUARDED_BY
(
mMutex
)
{
STATE_IDLE
}
;
nsCOMPtr
<
nsILoadGroup
>
mLoadGroup
MOZ_GUARDED_BY
(
mMutex
)
;
nsCOMPtr
<
nsIStreamListener
>
mListener
MOZ_GUARDED_BY
(
mMutex
)
;
nsCOMPtr
<
nsISerialEventTarget
>
mTargetThread
MOZ_GUARDED_BY
(
mMutex
)
;
nsCOMPtr
<
nsISerialEventTarget
>
mLabeledMainThreadTarget
MOZ_GUARDED_BY
(
mMutex
)
;
nsCOMPtr
<
nsIInputStream
>
mStream
MOZ_GUARDED_BY
(
mMutex
)
;
nsCOMPtr
<
nsIAsyncInputStream
>
mAsyncStream
MOZ_GUARDED_BY
(
mMutex
)
;
uint64_t
mStreamOffset
MOZ_GUARDED_BY
(
mMutex
)
{
0
}
;
uint64_t
mStreamLength
MOZ_GUARDED_BY
(
mMutex
)
{
0
}
;
uint32_t
mSegSize
MOZ_GUARDED_BY
(
mMutex
)
{
0
}
;
uint32_t
mSegCount
MOZ_GUARDED_BY
(
mMutex
)
{
0
}
;
nsresult
mStatus
MOZ_GUARDED_BY
(
mMutex
)
{
NS_OK
}
;
uint32_t
mSuspendCount
MOZ_GUARDED_BY
(
mMutex
)
{
0
}
;
uint32_t
mLoadFlags
MOZ_GUARDED_BY
(
mMutex
)
{
LOAD_NORMAL
}
;
bool
mIsPending
MOZ_GUARDED_BY
(
mMutex
)
{
false
}
;
bool
mProcessingCallbacks
MOZ_GUARDED_BY
(
mMutex
)
{
false
}
;
bool
mWaitingForInputStreamReady
MOZ_GUARDED_BY
(
mMutex
)
{
false
}
;
bool
mCloseWhenDone
MOZ_GUARDED_BY
(
mMutex
)
{
false
}
;
bool
mRetargeting
MOZ_GUARDED_BY
(
mMutex
)
{
false
}
;
bool
mAsyncStreamIsBuffered
MOZ_GUARDED_BY
(
mMutex
)
{
false
}
;
const
bool
mOffMainThread
;
mozilla
:
:
RecursiveMutex
mMutex
{
"
nsInputStreamPump
"
}
;
}
;
#
endif
