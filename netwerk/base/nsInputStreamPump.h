#
ifndef
nsInputStreamPump_h__
#
define
nsInputStreamPump_h__
#
include
"
nsIInputStreamPump
.
h
"
#
include
"
nsIAsyncInputStream
.
h
"
#
include
"
nsIThreadRetargetableRequest
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
RecursiveMutex
.
h
"
class
nsIInputStream
;
class
nsILoadGroup
;
class
nsIStreamListener
;
#
define
NS_INPUT_STREAM_PUMP_IID
\
{
\
0x42f1cc9b
0xdf5f
0x4c9b
{
\
0xbd
0x71
0x8d
0x4a
0xe2
0x27
0xc1
0x8a
\
}
\
}
class
nsInputStreamPump
final
:
public
nsIInputStreamPump
public
nsIInputStreamCallback
public
nsIThreadRetargetableRequest
{
~
nsInputStreamPump
(
)
=
default
;
public
:
using
RecursiveMutexAutoLock
=
mozilla
:
:
RecursiveMutexAutoLock
;
using
RecursiveMutexAutoUnlock
=
mozilla
:
:
RecursiveMutexAutoUnlock
;
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIREQUEST
NS_DECL_NSIINPUTSTREAMPUMP
NS_DECL_NSIINPUTSTREAMCALLBACK
NS_DECL_NSITHREADRETARGETABLEREQUEST
NS_DECLARE_STATIC_IID_ACCESSOR
(
NS_INPUT_STREAM_PUMP_IID
)
nsInputStreamPump
(
)
;
static
nsresult
Create
(
nsInputStreamPump
*
*
result
nsIInputStream
*
stream
uint32_t
segsize
=
0
uint32_t
segcount
=
0
bool
closeWhenDone
=
false
nsIEventTarget
*
mainThreadTarget
=
nullptr
)
;
using
PeekSegmentFun
=
void
(
*
)
(
void
*
const
uint8_t
*
uint32_t
)
;
nsresult
PeekStream
(
PeekSegmentFun
callback
void
*
closure
)
;
nsresult
CallOnStateStop
(
)
;
protected
:
enum
{
STATE_IDLE
STATE_START
STATE_TRANSFER
STATE_STOP
}
;
nsresult
EnsureWaiting
(
)
;
uint32_t
OnStateStart
(
)
;
uint32_t
OnStateTransfer
(
)
;
uint32_t
OnStateStop
(
)
;
nsresult
CreateBufferedStreamIfNeeded
(
)
;
MOZ_ALWAYS_INLINE
void
AssertOnThread
(
)
const
{
if
(
mOffMainThread
)
{
MOZ_ASSERT
(
mTargetThread
-
>
IsOnCurrentThread
(
)
)
;
}
else
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
}
uint32_t
mState
{
STATE_IDLE
}
;
nsCOMPtr
<
nsILoadGroup
>
mLoadGroup
;
nsCOMPtr
<
nsIStreamListener
>
mListener
;
nsCOMPtr
<
nsIEventTarget
>
mTargetThread
;
nsCOMPtr
<
nsIEventTarget
>
mLabeledMainThreadTarget
;
nsCOMPtr
<
nsIInputStream
>
mStream
;
nsCOMPtr
<
nsIAsyncInputStream
>
mAsyncStream
;
uint64_t
mStreamOffset
{
0
}
;
uint64_t
mStreamLength
{
0
}
;
uint32_t
mSegSize
{
0
}
;
uint32_t
mSegCount
{
0
}
;
nsresult
mStatus
{
NS_OK
}
;
uint32_t
mSuspendCount
{
0
}
;
uint32_t
mLoadFlags
{
LOAD_NORMAL
}
;
bool
mIsPending
{
false
}
;
bool
mProcessingCallbacks
{
false
}
;
bool
mWaitingForInputStreamReady
{
false
}
;
bool
mCloseWhenDone
{
false
}
;
bool
mRetargeting
{
false
}
;
bool
mAsyncStreamIsBuffered
{
false
}
;
bool
mOffMainThread
;
mozilla
:
:
RecursiveMutex
mMutex
{
"
nsInputStreamPump
"
}
;
}
;
NS_DEFINE_STATIC_IID_ACCESSOR
(
nsInputStreamPump
NS_INPUT_STREAM_PUMP_IID
)
#
endif
