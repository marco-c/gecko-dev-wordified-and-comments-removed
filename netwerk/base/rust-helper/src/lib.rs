use
std
:
:
{
fs
:
:
File
io
:
:
{
self
BufRead
}
net
:
:
Ipv4Addr
path
:
:
Path
}
;
use
nserror
:
:
*
;
use
nsstring
:
:
{
nsACString
nsCString
}
;
use
thin_vec
:
:
ThinVec
;
#
[
cfg
(
windows
)
]
use
{
std
:
:
{
fs
:
:
OpenOptions
os
:
:
windows
:
:
fs
:
:
OpenOptionsExt
}
windows_sys
:
:
Win32
:
:
Storage
:
:
FileSystem
:
:
{
FILE_SHARE_DELETE
FILE_SHARE_READ
FILE_SHARE_WRITE
}
}
;
static
HTTP_LWS
:
&
[
u8
]
=
b
"
\
t
"
;
fn
trim_token
(
token
:
&
[
u8
]
)
-
>
&
[
u8
]
{
let
ltrim
=
token
.
iter
(
)
.
take_while
(
|
c
|
HTTP_LWS
.
iter
(
)
.
any
(
|
ws
|
&
ws
=
=
c
)
)
.
count
(
)
;
let
rtrim
=
token
[
ltrim
.
.
]
.
iter
(
)
.
take_while
(
|
c
|
*
*
c
!
=
b
'
;
'
&
&
HTTP_LWS
.
iter
(
)
.
all
(
|
ws
|
ws
!
=
*
c
)
)
.
count
(
)
;
&
token
[
ltrim
.
.
ltrim
+
rtrim
]
}
fn
open_read_fast_fail
(
path
:
&
Path
)
-
>
io
:
:
Result
<
File
>
{
#
[
cfg
(
windows
)
]
{
OpenOptions
:
:
new
(
)
.
read
(
true
)
.
share_mode
(
FILE_SHARE_READ
|
FILE_SHARE_WRITE
|
FILE_SHARE_DELETE
)
.
open
(
path
)
}
#
[
cfg
(
not
(
windows
)
)
]
{
File
:
:
open
(
path
)
}
}
#
[
no_mangle
]
pub
extern
"
C
"
fn
rust_prepare_accept_languages
(
i_accept_languages
:
&
nsACString
o_accept_languages
:
&
mut
nsACString
)
-
>
nsresult
{
if
i_accept_languages
.
is_empty
(
)
{
return
NS_OK
;
}
let
make_tokens
=
|
|
{
i_accept_languages
.
split
(
|
c
|
*
c
=
=
b
'
'
)
.
map
(
trim_token
)
.
filter
(
|
token
|
!
token
.
is_empty
(
)
)
}
;
for
(
count_n
i_token
)
in
make_tokens
(
)
.
enumerate
(
)
{
if
count_n
!
=
0
{
o_accept_languages
.
append
(
"
"
)
;
}
let
token_pos
=
o_accept_languages
.
len
(
)
;
o_accept_languages
.
append
(
i_token
as
&
[
u8
]
)
;
{
let
o_token
=
o_accept_languages
.
to_mut
(
)
;
canonicalize_language_tag
(
&
mut
o_token
[
token_pos
.
.
]
)
;
}
let
q_val_max
=
10
;
let
weight_of_decrement
=
1
;
let
step
=
std
:
:
cmp
:
:
min
(
10
count_n
)
;
let
q_val
=
std
:
:
cmp
:
:
max
(
q_val_max
-
step
*
weight_of_decrement
1
)
;
if
count_n
>
0
&
&
q_val
<
10
{
o_accept_languages
.
append
(
&
format
!
(
"
;
q
=
0
.
{
}
"
q_val
)
)
;
}
}
NS_OK
}
fn
canonicalize_language_tag
(
token
:
&
mut
[
u8
]
)
{
for
c
in
token
.
iter_mut
(
)
{
*
c
=
c
.
to_ascii_lowercase
(
)
;
}
let
sub_tags
=
token
.
split_mut
(
|
c
|
*
c
=
=
b
'
-
'
)
;
for
(
i
sub_tag
)
in
sub_tags
.
enumerate
(
)
{
if
i
=
=
0
{
continue
;
}
match
sub_tag
.
len
(
)
{
1
=
>
break
2
=
>
{
sub_tag
[
0
]
=
sub_tag
[
0
]
.
to_ascii_uppercase
(
)
;
sub_tag
[
1
]
=
sub_tag
[
1
]
.
to_ascii_uppercase
(
)
;
}
4
=
>
{
sub_tag
[
0
]
=
sub_tag
[
0
]
.
to_ascii_uppercase
(
)
;
}
_
=
>
{
}
}
;
}
}
#
[
no_mangle
]
pub
extern
"
C
"
fn
rust_net_is_valid_ipv4_addr
(
addr
:
&
nsACString
)
-
>
bool
{
is_valid_ipv4_addr
(
addr
)
}
#
[
inline
]
fn
try_apply_digit
(
current_octet
:
u8
digit_to_apply
:
u8
)
-
>
Option
<
u8
>
{
current_octet
.
checked_mul
(
10
)
?
.
checked_add
(
digit_to_apply
)
}
pub
fn
is_valid_ipv4_addr
(
addr
:
&
[
u8
]
)
-
>
bool
{
let
mut
current_octet
:
Option
<
u8
>
=
None
;
let
mut
dots
:
u8
=
0
;
for
c
in
addr
{
let
c
=
*
c
as
char
;
match
c
{
'
.
'
=
>
{
match
current_octet
{
None
=
>
{
return
false
;
}
Some
(
_
)
=
>
{
dots
+
=
1
;
current_octet
=
None
;
}
}
}
no_digit
if
no_digit
.
to_digit
(
10
)
.
is_none
(
)
=
>
{
return
false
;
}
digit
=
>
{
match
current_octet
{
None
=
>
{
current_octet
=
Some
(
digit
.
to_digit
(
10
)
.
unwrap
(
)
as
u8
)
;
}
Some
(
octet
)
=
>
{
if
let
Some
(
0
)
=
current_octet
{
return
false
;
}
if
let
Some
(
applied
)
=
try_apply_digit
(
octet
digit
.
to_digit
(
10
)
.
unwrap
(
)
as
u8
)
{
current_octet
=
Some
(
applied
)
;
}
else
{
return
false
;
}
}
}
}
}
}
dots
=
=
3
&
&
current_octet
.
is_some
(
)
}
#
[
no_mangle
]
pub
extern
"
C
"
fn
rust_net_is_valid_ipv6_addr
(
addr
:
&
nsACString
)
-
>
bool
{
is_valid_ipv6_addr
(
addr
)
}
pub
fn
is_valid_ipv6_addr
(
addr
:
&
[
u8
]
)
-
>
bool
{
let
mut
double_colon
=
false
;
let
mut
colon_before
=
false
;
let
mut
digits
:
u8
=
0
;
let
mut
blocks
:
u8
=
0
;
if
addr
.
len
(
)
<
2
|
|
addr
[
0
]
=
=
b
'
:
'
&
&
addr
[
1
]
!
=
b
'
:
'
{
return
false
;
}
for
(
i
c
)
in
(
0u8
.
.
)
.
zip
(
addr
)
{
match
c
{
maybe_digit
if
maybe_digit
.
is_ascii_hexdigit
(
)
=
>
{
if
digits
=
=
4
{
return
false
;
}
colon_before
=
false
;
digits
+
=
1
;
}
b
'
:
'
=
>
{
if
double_colon
&
&
colon_before
|
|
blocks
=
=
8
{
return
false
;
}
if
!
colon_before
{
if
digits
!
=
0
{
blocks
+
=
1
;
}
digits
=
0
;
colon_before
=
true
;
}
else
if
!
double_colon
{
double_colon
=
true
;
}
}
b
'
.
'
=
>
{
if
is_valid_ipv4_addr
(
&
addr
[
(
i
-
digits
)
as
usize
.
.
]
)
{
return
double_colon
&
&
blocks
<
6
|
|
!
double_colon
&
&
blocks
=
=
6
;
}
return
false
;
}
_
=
>
{
return
false
;
}
}
}
if
colon_before
&
&
!
double_colon
{
return
false
;
}
if
digits
!
=
0
{
blocks
+
=
1
;
}
double_colon
&
&
blocks
<
8
|
|
!
double_colon
&
&
blocks
=
=
8
}
#
[
no_mangle
]
pub
extern
"
C
"
fn
rust_net_is_valid_scheme_char
(
a_char
:
u8
)
-
>
bool
{
is_valid_scheme_char
(
a_char
)
}
#
[
no_mangle
]
pub
extern
"
C
"
fn
rust_net_is_valid_scheme
(
scheme
:
&
nsACString
)
-
>
bool
{
if
scheme
.
is_empty
(
)
{
return
false
;
}
if
!
scheme
[
0
]
.
is_ascii_alphabetic
(
)
{
return
false
;
}
scheme
[
1
.
.
]
.
iter
(
)
.
all
(
|
a_char
|
is_valid_scheme_char
(
*
a_char
)
)
}
fn
is_valid_scheme_char
(
a_char
:
u8
)
-
>
bool
{
a_char
.
is_ascii_alphanumeric
(
)
|
|
a_char
=
=
b
'
+
'
|
|
a_char
=
=
b
'
.
'
|
|
a_char
=
=
b
'
-
'
}
pub
type
ParsingCallback
=
extern
"
C
"
fn
(
&
ThinVec
<
nsCString
>
)
-
>
bool
;
#
[
no_mangle
]
pub
extern
"
C
"
fn
rust_parse_etc_hosts
(
path
:
&
nsACString
callback
:
ParsingCallback
)
{
let
path_str
=
path
.
to_utf8
(
)
;
let
path
=
Path
:
:
new
(
&
*
path_str
)
;
let
file
=
match
open_read_fast_fail
(
path
)
{
Ok
(
f
)
=
>
io
:
:
BufReader
:
:
new
(
f
)
Err
(
.
.
)
=
>
return
}
;
let
mut
array
=
ThinVec
:
:
new
(
)
;
for
line
in
file
.
lines
(
)
{
let
line
=
match
line
{
Ok
(
l
)
=
>
l
Err
(
.
.
)
=
>
continue
}
;
let
mut
iter
=
line
.
split
(
'
#
'
)
.
next
(
)
.
unwrap
(
)
.
split_whitespace
(
)
;
iter
.
next
(
)
;
array
.
extend
(
iter
.
filter
(
|
host
|
{
let
invalid
=
[
'
\
0
'
'
\
t
'
'
\
n
'
'
\
r
'
'
'
'
#
'
'
%
'
'
/
'
'
:
'
'
?
'
'
'
'
[
'
'
\
\
'
'
]
'
]
;
host
.
parse
:
:
<
Ipv4Addr
>
(
)
.
is_err
(
)
&
&
!
host
.
contains
(
&
invalid
[
.
.
]
)
}
)
.
map
(
nsCString
:
:
from
)
)
;
if
array
.
len
(
)
>
100
{
let
keep_going
=
callback
(
&
array
)
;
array
.
clear
(
)
;
if
!
keep_going
{
break
;
}
}
}
if
!
array
.
is_empty
(
)
{
callback
(
&
array
)
;
}
}
