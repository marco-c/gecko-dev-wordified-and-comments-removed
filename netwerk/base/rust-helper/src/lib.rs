extern
crate
nserror
;
use
self
:
:
nserror
:
:
*
;
extern
crate
nsstring
;
use
self
:
:
nsstring
:
:
nsACString
;
static
HTTP_LWS
:
&
'
static
[
u8
]
=
&
[
'
'
as
u8
'
\
t
'
as
u8
]
;
fn
trim_token
(
token
:
&
[
u8
]
)
-
>
&
[
u8
]
{
let
ltrim
=
token
.
iter
(
)
.
take_while
(
|
c
|
HTTP_LWS
.
iter
(
)
.
any
(
|
ws
|
&
ws
=
=
c
)
)
.
count
(
)
;
let
rtrim
=
token
[
ltrim
.
.
]
.
iter
(
)
.
take_while
(
|
c
|
*
*
c
!
=
(
'
;
'
as
u8
)
&
&
HTTP_LWS
.
iter
(
)
.
all
(
|
ws
|
ws
!
=
*
c
)
)
.
count
(
)
;
&
token
[
ltrim
.
.
ltrim
+
rtrim
]
}
#
[
no_mangle
]
#
[
allow
(
non_snake_case
)
]
pub
extern
"
C
"
fn
rust_prepare_accept_languages
<
'
a
'
b
>
(
i_accept_languages
:
&
'
a
nsACString
o_accept_languages
:
&
'
b
mut
nsACString
)
-
>
nsresult
{
if
i_accept_languages
.
is_empty
(
)
{
return
NS_OK
;
}
let
make_tokens
=
|
|
{
i_accept_languages
.
split
(
|
c
|
*
c
=
=
(
'
'
as
u8
)
)
.
map
(
|
token
|
trim_token
(
token
)
)
.
filter
(
|
token
|
token
.
len
(
)
!
=
0
)
}
;
let
n
=
make_tokens
(
)
.
count
(
)
;
for
(
count_n
i_token
)
in
make_tokens
(
)
.
enumerate
(
)
{
if
count_n
!
=
0
{
o_accept_languages
.
append
(
"
"
)
;
}
let
token_pos
=
o_accept_languages
.
len
(
)
;
o_accept_languages
.
append
(
&
i_token
as
&
[
u8
]
)
;
{
let
o_token
=
o_accept_languages
.
to_mut
(
)
;
canonicalize_language_tag
(
&
mut
o_token
[
token_pos
.
.
]
)
;
}
let
q
=
1
.
0
-
count_n
as
f32
/
n
as
f32
;
let
u
:
u32
=
(
(
q
+
0
.
005
)
*
100
.
0
)
as
u32
;
if
u
<
100
{
if
n
<
10
|
|
u
%
10
=
=
0
{
let
u
=
(
u
+
5
)
/
10
;
o_accept_languages
.
append
(
&
format
!
(
"
;
q
=
0
.
{
}
"
u
)
)
;
}
else
{
o_accept_languages
.
append
(
&
format
!
(
"
;
q
=
0
.
{
:
02
}
"
u
)
)
;
}
}
}
NS_OK
}
fn
canonicalize_language_tag
(
token
:
&
mut
[
u8
]
)
{
for
c
in
token
.
iter_mut
(
)
{
*
c
=
c
.
to_ascii_lowercase
(
)
;
}
let
sub_tags
=
token
.
split_mut
(
|
c
|
*
c
=
=
(
'
-
'
as
u8
)
)
;
for
(
i
sub_tag
)
in
sub_tags
.
enumerate
(
)
{
if
i
=
=
0
{
continue
;
}
match
sub_tag
.
len
(
)
{
1
=
>
break
2
=
>
{
sub_tag
[
0
]
=
sub_tag
[
0
]
.
to_ascii_uppercase
(
)
;
sub_tag
[
1
]
=
sub_tag
[
1
]
.
to_ascii_uppercase
(
)
;
}
4
=
>
{
sub_tag
[
0
]
=
sub_tag
[
0
]
.
to_ascii_uppercase
(
)
;
}
_
=
>
{
}
}
;
}
}
#
[
no_mangle
]
#
[
allow
(
non_snake_case
)
]
pub
extern
"
C
"
fn
rust_net_is_valid_ipv4_addr
<
'
a
>
(
addr
:
&
'
a
nsACString
)
-
>
bool
{
is_valid_ipv4_addr
(
addr
)
}
#
[
inline
]
fn
try_apply_digit
(
current_octet
:
u8
digit_to_apply
:
u8
)
-
>
Option
<
u8
>
{
current_octet
.
checked_mul
(
10
)
?
.
checked_add
(
digit_to_apply
)
}
pub
fn
is_valid_ipv4_addr
<
'
a
>
(
addr
:
&
'
a
[
u8
]
)
-
>
bool
{
let
mut
current_octet
:
Option
<
u8
>
=
None
;
let
mut
dots
:
u8
=
0
;
for
c
in
addr
{
let
c
=
*
c
as
char
;
match
c
{
'
.
'
=
>
{
match
current_octet
{
None
=
>
{
return
false
;
}
Some
(
_
)
=
>
{
dots
=
dots
+
1
;
current_octet
=
None
;
}
}
}
no_digit
if
no_digit
.
to_digit
(
10
)
.
is_none
(
)
=
>
{
return
false
;
}
digit
=
>
{
match
current_octet
{
None
=
>
{
current_octet
=
Some
(
digit
.
to_digit
(
10
)
.
unwrap
(
)
as
u8
)
;
}
Some
(
octet
)
=
>
{
if
let
Some
(
0
)
=
current_octet
{
return
false
;
}
if
let
Some
(
applied
)
=
try_apply_digit
(
octet
digit
.
to_digit
(
10
)
.
unwrap
(
)
as
u8
)
{
current_octet
=
Some
(
applied
)
;
}
else
{
return
false
;
}
}
}
}
}
}
dots
=
=
3
&
&
current_octet
.
is_some
(
)
}
