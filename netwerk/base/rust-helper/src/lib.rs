extern
crate
nserror
;
use
self
:
:
nserror
:
:
*
;
extern
crate
nsstring
;
use
self
:
:
nsstring
:
:
{
nsACString
nsCString
}
;
extern
crate
thin_vec
;
use
self
:
:
thin_vec
:
:
ThinVec
;
use
std
:
:
fs
:
:
File
;
use
std
:
:
io
:
:
{
self
BufRead
}
;
use
std
:
:
net
:
:
Ipv4Addr
;
static
HTTP_LWS
:
&
'
static
[
u8
]
=
&
[
'
'
as
u8
'
\
t
'
as
u8
]
;
fn
trim_token
(
token
:
&
[
u8
]
)
-
>
&
[
u8
]
{
let
ltrim
=
token
.
iter
(
)
.
take_while
(
|
c
|
HTTP_LWS
.
iter
(
)
.
any
(
|
ws
|
&
ws
=
=
c
)
)
.
count
(
)
;
let
rtrim
=
token
[
ltrim
.
.
]
.
iter
(
)
.
take_while
(
|
c
|
*
*
c
!
=
(
'
;
'
as
u8
)
&
&
HTTP_LWS
.
iter
(
)
.
all
(
|
ws
|
ws
!
=
*
c
)
)
.
count
(
)
;
&
token
[
ltrim
.
.
ltrim
+
rtrim
]
}
#
[
no_mangle
]
pub
extern
"
C
"
fn
rust_prepare_accept_languages
<
'
a
'
b
>
(
i_accept_languages
:
&
'
a
nsACString
o_accept_languages
:
&
'
b
mut
nsACString
)
-
>
nsresult
{
if
i_accept_languages
.
is_empty
(
)
{
return
NS_OK
;
}
let
make_tokens
=
|
|
{
i_accept_languages
.
split
(
|
c
|
*
c
=
=
(
'
'
as
u8
)
)
.
map
(
|
token
|
trim_token
(
token
)
)
.
filter
(
|
token
|
token
.
len
(
)
!
=
0
)
}
;
let
n
=
make_tokens
(
)
.
count
(
)
;
for
(
count_n
i_token
)
in
make_tokens
(
)
.
enumerate
(
)
{
if
count_n
!
=
0
{
o_accept_languages
.
append
(
"
"
)
;
}
let
token_pos
=
o_accept_languages
.
len
(
)
;
o_accept_languages
.
append
(
&
i_token
as
&
[
u8
]
)
;
{
let
o_token
=
o_accept_languages
.
to_mut
(
)
;
canonicalize_language_tag
(
&
mut
o_token
[
token_pos
.
.
]
)
;
}
let
q
=
1
.
0
-
count_n
as
f32
/
n
as
f32
;
let
u
:
u32
=
(
(
q
+
0
.
005
)
*
100
.
0
)
as
u32
;
if
u
<
100
{
if
n
<
10
|
|
u
%
10
=
=
0
{
let
u
=
(
u
+
5
)
/
10
;
o_accept_languages
.
append
(
&
format
!
(
"
;
q
=
0
.
{
}
"
u
)
)
;
}
else
{
o_accept_languages
.
append
(
&
format
!
(
"
;
q
=
0
.
{
:
02
}
"
u
)
)
;
}
}
}
NS_OK
}
fn
canonicalize_language_tag
(
token
:
&
mut
[
u8
]
)
{
for
c
in
token
.
iter_mut
(
)
{
*
c
=
c
.
to_ascii_lowercase
(
)
;
}
let
sub_tags
=
token
.
split_mut
(
|
c
|
*
c
=
=
(
'
-
'
as
u8
)
)
;
for
(
i
sub_tag
)
in
sub_tags
.
enumerate
(
)
{
if
i
=
=
0
{
continue
;
}
match
sub_tag
.
len
(
)
{
1
=
>
break
2
=
>
{
sub_tag
[
0
]
=
sub_tag
[
0
]
.
to_ascii_uppercase
(
)
;
sub_tag
[
1
]
=
sub_tag
[
1
]
.
to_ascii_uppercase
(
)
;
}
4
=
>
{
sub_tag
[
0
]
=
sub_tag
[
0
]
.
to_ascii_uppercase
(
)
;
}
_
=
>
{
}
}
;
}
}
#
[
no_mangle
]
pub
extern
"
C
"
fn
rust_net_is_valid_ipv4_addr
<
'
a
>
(
addr
:
&
'
a
nsACString
)
-
>
bool
{
is_valid_ipv4_addr
(
addr
)
}
#
[
inline
]
fn
try_apply_digit
(
current_octet
:
u8
digit_to_apply
:
u8
)
-
>
Option
<
u8
>
{
current_octet
.
checked_mul
(
10
)
?
.
checked_add
(
digit_to_apply
)
}
pub
fn
is_valid_ipv4_addr
<
'
a
>
(
addr
:
&
'
a
[
u8
]
)
-
>
bool
{
let
mut
current_octet
:
Option
<
u8
>
=
None
;
let
mut
dots
:
u8
=
0
;
for
c
in
addr
{
let
c
=
*
c
as
char
;
match
c
{
'
.
'
=
>
{
match
current_octet
{
None
=
>
{
return
false
;
}
Some
(
_
)
=
>
{
dots
=
dots
+
1
;
current_octet
=
None
;
}
}
}
no_digit
if
no_digit
.
to_digit
(
10
)
.
is_none
(
)
=
>
{
return
false
;
}
digit
=
>
{
match
current_octet
{
None
=
>
{
current_octet
=
Some
(
digit
.
to_digit
(
10
)
.
unwrap
(
)
as
u8
)
;
}
Some
(
octet
)
=
>
{
if
let
Some
(
0
)
=
current_octet
{
return
false
;
}
if
let
Some
(
applied
)
=
try_apply_digit
(
octet
digit
.
to_digit
(
10
)
.
unwrap
(
)
as
u8
)
{
current_octet
=
Some
(
applied
)
;
}
else
{
return
false
;
}
}
}
}
}
}
dots
=
=
3
&
&
current_octet
.
is_some
(
)
}
#
[
no_mangle
]
pub
extern
"
C
"
fn
rust_net_is_valid_ipv6_addr
<
'
a
>
(
addr
:
&
'
a
nsACString
)
-
>
bool
{
is_valid_ipv6_addr
(
addr
)
}
#
[
inline
(
always
)
]
fn
fast_is_hex_digit
(
c
:
u8
)
-
>
bool
{
match
c
{
b
'
0
'
.
.
=
b
'
9
'
=
>
true
b
'
a
'
.
.
=
b
'
f
'
=
>
true
b
'
A
'
.
.
=
b
'
F
'
=
>
true
_
=
>
false
}
}
pub
fn
is_valid_ipv6_addr
<
'
a
>
(
addr
:
&
'
a
[
u8
]
)
-
>
bool
{
let
mut
double_colon
=
false
;
let
mut
colon_before
=
false
;
let
mut
digits
:
u8
=
0
;
let
mut
blocks
:
u8
=
0
;
if
addr
.
len
(
)
<
2
|
|
addr
[
0
]
=
=
b
'
:
'
&
&
addr
[
1
]
!
=
b
'
:
'
{
return
false
;
}
for
(
i
c
)
in
(
0u8
.
.
)
.
zip
(
addr
)
{
match
c
{
maybe_digit
if
fast_is_hex_digit
(
*
maybe_digit
)
=
>
{
if
digits
=
=
4
{
return
false
;
}
colon_before
=
false
;
digits
+
=
1
;
}
b
'
:
'
=
>
{
if
double_colon
&
&
colon_before
|
|
blocks
=
=
8
{
return
false
;
}
if
!
colon_before
{
if
digits
!
=
0
{
blocks
+
=
1
;
}
digits
=
0
;
colon_before
=
true
;
}
else
if
!
double_colon
{
double_colon
=
true
;
}
}
b
'
.
'
=
>
{
if
is_valid_ipv4_addr
(
&
addr
[
(
i
-
digits
)
as
usize
.
.
]
)
{
return
double_colon
&
&
blocks
<
6
|
|
!
double_colon
&
&
blocks
=
=
6
;
}
return
false
;
}
_
=
>
{
return
false
;
}
}
}
if
colon_before
&
&
!
double_colon
{
return
false
;
}
if
digits
!
=
0
{
blocks
+
=
1
;
}
double_colon
&
&
blocks
<
8
|
|
!
double_colon
&
&
blocks
=
=
8
}
#
[
no_mangle
]
pub
extern
"
C
"
fn
rust_net_is_valid_scheme_char
(
a_char
:
u8
)
-
>
bool
{
is_valid_scheme_char
(
a_char
)
}
#
[
no_mangle
]
pub
extern
"
C
"
fn
rust_net_is_valid_scheme
<
'
a
>
(
scheme
:
&
'
a
nsACString
)
-
>
bool
{
if
scheme
.
is_empty
(
)
{
return
false
;
}
if
!
scheme
[
0
]
.
is_ascii_alphabetic
(
)
{
return
false
;
}
scheme
[
1
.
.
]
.
iter
(
)
.
all
(
|
a_char
|
is_valid_scheme_char
(
*
a_char
)
)
}
fn
is_valid_scheme_char
(
a_char
:
u8
)
-
>
bool
{
a_char
.
is_ascii_alphanumeric
(
)
|
|
a_char
=
=
b
'
+
'
|
|
a_char
=
=
b
'
.
'
|
|
a_char
=
=
b
'
-
'
}
pub
type
ParsingCallback
=
extern
"
C
"
fn
(
&
ThinVec
<
nsCString
>
)
-
>
bool
;
#
[
no_mangle
]
pub
extern
"
C
"
fn
rust_parse_etc_hosts
<
'
a
>
(
path
:
&
'
a
nsACString
callback
:
ParsingCallback
)
{
let
file
=
match
File
:
:
open
(
&
*
path
.
to_utf8
(
)
)
{
Ok
(
file
)
=
>
io
:
:
BufReader
:
:
new
(
file
)
Err
(
.
.
)
=
>
return
}
;
let
mut
array
=
ThinVec
:
:
new
(
)
;
for
line
in
file
.
lines
(
)
{
let
line
=
match
line
{
Ok
(
l
)
=
>
l
Err
(
.
.
)
=
>
continue
}
;
let
mut
iter
=
line
.
split
(
'
#
'
)
.
next
(
)
.
unwrap
(
)
.
split_whitespace
(
)
;
iter
.
next
(
)
;
array
.
extend
(
iter
.
filter
(
|
host
|
{
let
invalid
=
[
'
\
0
'
'
\
t
'
'
\
n
'
'
\
r
'
'
'
'
#
'
'
%
'
'
/
'
'
:
'
'
?
'
'
'
'
[
'
'
\
\
'
'
]
'
]
;
host
.
parse
:
:
<
Ipv4Addr
>
(
)
.
is_err
(
)
&
&
!
host
.
contains
(
&
invalid
[
.
.
]
)
}
)
.
map
(
nsCString
:
:
from
)
)
;
if
array
.
len
(
)
>
100
{
let
keep_going
=
callback
(
&
array
)
;
array
.
clear
(
)
;
if
!
keep_going
{
break
;
}
}
}
if
!
array
.
is_empty
(
)
{
callback
(
&
array
)
;
}
}
