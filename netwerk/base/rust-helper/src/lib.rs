use
std
:
:
ascii
:
:
AsciiExt
;
extern
crate
nserror
;
use
self
:
:
nserror
:
:
*
;
extern
crate
nsstring
;
use
self
:
:
nsstring
:
:
nsACString
;
static
HTTP_LWS
:
&
'
static
[
u8
]
=
&
[
'
'
as
u8
'
\
t
'
as
u8
]
;
fn
trim_token
(
token
:
&
[
u8
]
)
-
>
&
[
u8
]
{
let
ltrim
=
token
.
iter
(
)
.
take_while
(
|
c
|
HTTP_LWS
.
iter
(
)
.
any
(
|
ws
|
&
ws
=
=
c
)
)
.
count
(
)
;
let
rtrim
=
token
[
ltrim
.
.
]
.
iter
(
)
.
take_while
(
|
c
|
*
*
c
!
=
(
'
;
'
as
u8
)
&
&
HTTP_LWS
.
iter
(
)
.
all
(
|
ws
|
ws
!
=
*
c
)
)
.
count
(
)
;
&
token
[
ltrim
.
.
ltrim
+
rtrim
]
}
#
[
no_mangle
]
#
[
allow
(
non_snake_case
)
]
pub
extern
"
C
"
fn
rust_prepare_accept_languages
<
'
a
'
b
>
(
i_accept_languages
:
&
'
a
nsACString
o_accept_languages
:
&
'
b
mut
nsACString
)
-
>
nsresult
{
if
i_accept_languages
.
is_empty
(
)
{
return
NS_OK
;
}
let
make_tokens
=
|
|
{
i_accept_languages
.
split
(
|
c
|
*
c
=
=
(
'
'
as
u8
)
)
.
map
(
|
token
|
trim_token
(
token
)
)
.
filter
(
|
token
|
token
.
len
(
)
!
=
0
)
}
;
let
n
=
make_tokens
(
)
.
count
(
)
;
for
(
count_n
i_token
)
in
make_tokens
(
)
.
enumerate
(
)
{
if
count_n
!
=
0
{
o_accept_languages
.
append
(
"
"
)
;
}
let
token_pos
=
o_accept_languages
.
len
(
)
;
o_accept_languages
.
append
(
&
i_token
as
&
[
u8
]
)
;
{
let
o_token
=
o_accept_languages
.
to_mut
(
)
;
canonicalize_language_tag
(
&
mut
o_token
[
token_pos
.
.
]
)
;
}
let
q
=
1
.
0
-
count_n
as
f32
/
n
as
f32
;
let
u
:
u32
=
(
(
q
+
0
.
005
)
*
100
.
0
)
as
u32
;
if
u
<
100
{
if
n
<
10
|
|
u
%
10
=
=
0
{
let
u
=
(
u
+
5
)
/
10
;
o_accept_languages
.
append
(
&
format
!
(
"
;
q
=
0
.
{
}
"
u
)
)
;
}
else
{
o_accept_languages
.
append
(
&
format
!
(
"
;
q
=
0
.
{
:
02
}
"
u
)
)
;
}
}
}
NS_OK
}
fn
canonicalize_language_tag
(
token
:
&
mut
[
u8
]
)
{
for
c
in
token
.
iter_mut
(
)
{
*
c
=
AsciiExt
:
:
to_ascii_lowercase
(
c
)
;
}
let
sub_tags
=
token
.
split_mut
(
|
c
|
*
c
=
=
(
'
-
'
as
u8
)
)
;
for
(
i
mut
sub_tag
)
in
sub_tags
.
enumerate
(
)
{
if
i
=
=
0
{
continue
;
}
match
sub_tag
.
len
(
)
{
1
=
>
break
2
=
>
{
sub_tag
[
0
]
=
AsciiExt
:
:
to_ascii_uppercase
(
&
sub_tag
[
0
]
)
;
sub_tag
[
1
]
=
AsciiExt
:
:
to_ascii_uppercase
(
&
sub_tag
[
1
]
)
;
}
4
=
>
{
sub_tag
[
0
]
=
AsciiExt
:
:
to_ascii_uppercase
(
&
sub_tag
[
0
]
)
;
}
_
=
>
{
}
}
;
}
}
