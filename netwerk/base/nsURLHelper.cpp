#
include
"
nsURLHelper
.
h
"
#
include
"
mozilla
/
Encoding
.
h
"
#
include
"
mozilla
/
RangedPtr
.
h
"
#
include
"
mozilla
/
TextUtils
.
h
"
#
include
<
algorithm
>
#
include
<
iterator
>
#
include
"
nsASCIIMask
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsIURLParser
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
prnetdb
.
h
"
#
include
"
mozilla
/
StaticPrefs_network
.
h
"
#
include
"
mozilla
/
Tokenizer
.
h
"
#
include
"
nsEscape
.
h
"
#
include
"
nsDOMString
.
h
"
#
include
"
mozilla
/
net
/
rust_helper
.
h
"
#
include
"
mozilla
/
net
/
DNS
.
h
"
using
namespace
mozilla
;
static
bool
gInitialized
=
false
;
static
StaticRefPtr
<
nsIURLParser
>
gNoAuthURLParser
;
static
StaticRefPtr
<
nsIURLParser
>
gAuthURLParser
;
static
StaticRefPtr
<
nsIURLParser
>
gStdURLParser
;
static
void
InitGlobals
(
)
{
nsCOMPtr
<
nsIURLParser
>
parser
;
parser
=
do_GetService
(
NS_NOAUTHURLPARSER_CONTRACTID
)
;
NS_ASSERTION
(
parser
"
failed
getting
'
noauth
'
url
parser
"
)
;
if
(
parser
)
{
gNoAuthURLParser
=
parser
;
}
parser
=
do_GetService
(
NS_AUTHURLPARSER_CONTRACTID
)
;
NS_ASSERTION
(
parser
"
failed
getting
'
auth
'
url
parser
"
)
;
if
(
parser
)
{
gAuthURLParser
=
parser
;
}
parser
=
do_GetService
(
NS_STDURLPARSER_CONTRACTID
)
;
NS_ASSERTION
(
parser
"
failed
getting
'
std
'
url
parser
"
)
;
if
(
parser
)
{
gStdURLParser
=
parser
;
}
gInitialized
=
true
;
}
void
net_ShutdownURLHelper
(
)
{
if
(
gInitialized
)
{
gInitialized
=
false
;
}
gNoAuthURLParser
=
nullptr
;
gAuthURLParser
=
nullptr
;
gStdURLParser
=
nullptr
;
}
nsIURLParser
*
net_GetAuthURLParser
(
)
{
if
(
!
gInitialized
)
InitGlobals
(
)
;
return
gAuthURLParser
;
}
nsIURLParser
*
net_GetNoAuthURLParser
(
)
{
if
(
!
gInitialized
)
InitGlobals
(
)
;
return
gNoAuthURLParser
;
}
nsIURLParser
*
net_GetStdURLParser
(
)
{
if
(
!
gInitialized
)
InitGlobals
(
)
;
return
gStdURLParser
;
}
nsresult
net_GetURLSpecFromDir
(
nsIFile
*
aFile
nsACString
&
result
)
{
nsAutoCString
escPath
;
nsresult
rv
=
net_GetURLSpecFromActualFile
(
aFile
escPath
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
if
(
escPath
.
Last
(
)
!
=
'
/
'
)
{
escPath
+
=
'
/
'
;
}
result
=
escPath
;
return
NS_OK
;
}
nsresult
net_GetURLSpecFromFile
(
nsIFile
*
aFile
nsACString
&
result
)
{
nsAutoCString
escPath
;
nsresult
rv
=
net_GetURLSpecFromActualFile
(
aFile
escPath
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
if
(
escPath
.
Last
(
)
!
=
'
/
'
)
{
bool
dir
;
rv
=
aFile
-
>
IsDirectory
(
&
dir
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
dir
)
escPath
+
=
'
/
'
;
}
result
=
escPath
;
return
NS_OK
;
}
nsresult
net_ParseFileURL
(
const
nsACString
&
inURL
nsACString
&
outDirectory
nsACString
&
outFileBaseName
nsACString
&
outFileExtension
)
{
nsresult
rv
;
if
(
inURL
.
Length
(
)
>
(
uint32_t
)
StaticPrefs
:
:
network_standard_url_max_length
(
)
)
{
return
NS_ERROR_MALFORMED_URI
;
}
outDirectory
.
Truncate
(
)
;
outFileBaseName
.
Truncate
(
)
;
outFileExtension
.
Truncate
(
)
;
const
nsPromiseFlatCString
&
flatURL
=
PromiseFlatCString
(
inURL
)
;
const
char
*
url
=
flatURL
.
get
(
)
;
nsAutoCString
scheme
;
rv
=
net_ExtractURLScheme
(
flatURL
scheme
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
if
(
!
scheme
.
EqualsLiteral
(
"
file
"
)
)
{
NS_ERROR
(
"
must
be
a
file
:
/
/
url
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
nsIURLParser
*
parser
=
net_GetNoAuthURLParser
(
)
;
NS_ENSURE_TRUE
(
parser
NS_ERROR_UNEXPECTED
)
;
uint32_t
pathPos
filepathPos
directoryPos
basenamePos
extensionPos
;
int32_t
pathLen
filepathLen
directoryLen
basenameLen
extensionLen
;
rv
=
parser
-
>
ParseURL
(
url
flatURL
.
Length
(
)
nullptr
nullptr
nullptr
nullptr
&
pathPos
&
pathLen
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
rv
=
parser
-
>
ParsePath
(
url
+
pathPos
pathLen
&
filepathPos
&
filepathLen
nullptr
nullptr
nullptr
nullptr
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
filepathPos
+
=
pathPos
;
rv
=
parser
-
>
ParseFilePath
(
url
+
filepathPos
filepathLen
&
directoryPos
&
directoryLen
&
basenamePos
&
basenameLen
&
extensionPos
&
extensionLen
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
if
(
directoryLen
>
0
)
{
outDirectory
=
Substring
(
inURL
filepathPos
+
directoryPos
directoryLen
)
;
}
if
(
basenameLen
>
0
)
{
outFileBaseName
=
Substring
(
inURL
filepathPos
+
basenamePos
basenameLen
)
;
}
if
(
extensionLen
>
0
)
{
outFileExtension
=
Substring
(
inURL
filepathPos
+
extensionPos
extensionLen
)
;
}
return
NS_OK
;
}
void
net_CoalesceDirs
(
netCoalesceFlags
flags
char
*
path
)
{
char
*
fwdPtr
=
path
;
char
*
urlPtr
=
path
;
char
*
lastslash
=
path
;
uint32_t
traversal
=
0
;
uint32_t
special_ftp_len
=
0
;
if
(
flags
&
NET_COALESCE_DOUBLE_SLASH_IS_ROOT
)
{
if
(
nsCRT
:
:
strncasecmp
(
path
"
/
%
2F
"
4
)
=
=
0
)
{
special_ftp_len
=
4
;
}
else
if
(
strncmp
(
path
"
/
/
"
2
)
=
=
0
)
{
special_ftp_len
=
2
;
}
}
for
(
;
(
*
fwdPtr
!
=
'
\
0
'
)
&
&
(
*
fwdPtr
!
=
'
?
'
)
&
&
(
*
fwdPtr
!
=
'
#
'
)
;
+
+
fwdPtr
)
{
}
if
(
fwdPtr
!
=
path
&
&
*
fwdPtr
=
=
'
\
0
'
)
{
-
-
fwdPtr
;
}
for
(
;
(
fwdPtr
!
=
path
)
&
&
(
*
fwdPtr
!
=
'
/
'
)
;
-
-
fwdPtr
)
{
}
lastslash
=
fwdPtr
;
fwdPtr
=
path
;
for
(
;
(
*
fwdPtr
!
=
'
\
0
'
)
&
&
(
*
fwdPtr
!
=
'
?
'
)
&
&
(
*
fwdPtr
!
=
'
#
'
)
&
&
(
*
lastslash
=
=
'
\
0
'
|
|
fwdPtr
!
=
lastslash
)
;
+
+
fwdPtr
)
{
if
(
*
fwdPtr
=
=
'
%
'
&
&
*
(
fwdPtr
+
1
)
=
=
'
2
'
&
&
(
*
(
fwdPtr
+
2
)
=
=
'
E
'
|
|
*
(
fwdPtr
+
2
)
=
=
'
e
'
)
)
{
*
urlPtr
+
+
=
'
.
'
;
+
+
fwdPtr
;
+
+
fwdPtr
;
}
else
{
*
urlPtr
+
+
=
*
fwdPtr
;
}
}
for
(
;
*
fwdPtr
!
=
'
\
0
'
;
+
+
fwdPtr
)
{
*
urlPtr
+
+
=
*
fwdPtr
;
}
*
urlPtr
=
'
\
0
'
;
fwdPtr
=
path
;
urlPtr
=
path
;
for
(
;
(
*
fwdPtr
!
=
'
\
0
'
)
&
&
(
*
fwdPtr
!
=
'
?
'
)
&
&
(
*
fwdPtr
!
=
'
#
'
)
;
+
+
fwdPtr
)
{
if
(
*
fwdPtr
=
=
'
/
'
&
&
*
(
fwdPtr
+
1
)
=
=
'
.
'
&
&
*
(
fwdPtr
+
2
)
=
=
'
/
'
)
{
+
+
fwdPtr
;
}
else
if
(
*
fwdPtr
=
=
'
/
'
&
&
*
(
fwdPtr
+
1
)
=
=
'
.
'
&
&
*
(
fwdPtr
+
2
)
=
=
'
.
'
&
&
(
*
(
fwdPtr
+
3
)
=
=
'
/
'
|
|
*
(
fwdPtr
+
3
)
=
=
'
\
0
'
|
|
*
(
fwdPtr
+
3
)
=
=
'
?
'
|
|
*
(
fwdPtr
+
3
)
=
=
'
#
'
)
)
{
if
(
traversal
>
0
|
|
!
(
flags
&
NET_COALESCE_ALLOW_RELATIVE_ROOT
)
)
{
if
(
urlPtr
!
=
path
)
urlPtr
-
-
;
for
(
;
*
urlPtr
!
=
'
/
'
&
&
urlPtr
!
=
path
;
urlPtr
-
-
)
{
;
}
-
-
traversal
;
fwdPtr
+
=
2
;
if
(
urlPtr
=
=
path
&
&
special_ftp_len
>
3
)
{
+
+
urlPtr
;
+
+
urlPtr
;
+
+
urlPtr
;
}
if
(
*
fwdPtr
=
=
'
.
'
&
&
*
(
fwdPtr
+
1
)
=
=
'
\
0
'
)
+
+
urlPtr
;
}
else
{
if
(
special_ftp_len
>
3
&
&
urlPtr
=
=
path
+
special_ftp_len
-
1
)
{
+
+
urlPtr
;
}
else
{
*
urlPtr
+
+
=
*
fwdPtr
;
}
+
+
fwdPtr
;
*
urlPtr
+
+
=
*
fwdPtr
;
+
+
fwdPtr
;
*
urlPtr
+
+
=
*
fwdPtr
;
}
}
else
{
if
(
*
fwdPtr
=
=
'
/
'
&
&
*
(
fwdPtr
+
1
)
!
=
'
.
'
&
&
(
special_ftp_len
!
=
2
|
|
*
(
fwdPtr
+
1
)
!
=
'
/
'
)
)
{
traversal
+
+
;
}
*
urlPtr
+
+
=
*
fwdPtr
;
}
}
if
(
(
urlPtr
>
(
path
+
1
)
)
&
&
(
*
(
urlPtr
-
1
)
=
=
'
.
'
)
&
&
(
*
(
urlPtr
-
2
)
=
=
'
/
'
)
)
{
urlPtr
-
-
;
}
for
(
;
*
fwdPtr
!
=
'
\
0
'
;
+
+
fwdPtr
)
{
*
urlPtr
+
+
=
*
fwdPtr
;
}
*
urlPtr
=
'
\
0
'
;
}
static
bool
net_IsValidSchemeChar
(
const
char
aChar
)
{
return
mozilla
:
:
net
:
:
rust_net_is_valid_scheme_char
(
aChar
)
;
}
nsresult
net_ExtractURLScheme
(
const
nsACString
&
inURI
nsACString
&
scheme
)
{
nsACString
:
:
const_iterator
start
end
;
inURI
.
BeginReading
(
start
)
;
inURI
.
EndReading
(
end
)
;
while
(
start
!
=
end
)
{
if
(
(
uint8_t
)
*
start
>
0x20
)
{
break
;
}
start
+
+
;
}
Tokenizer
p
(
Substring
(
start
end
)
"
\
r
\
n
\
t
"
)
;
p
.
Record
(
)
;
if
(
!
p
.
CheckChar
(
IsAsciiAlpha
)
)
{
return
NS_ERROR_MALFORMED_URI
;
}
while
(
p
.
CheckChar
(
net_IsValidSchemeChar
)
|
|
p
.
CheckWhite
(
)
)
{
}
if
(
!
p
.
CheckChar
(
'
:
'
)
)
{
return
NS_ERROR_MALFORMED_URI
;
}
p
.
Claim
(
scheme
)
;
scheme
.
StripTaggedASCII
(
ASCIIMask
:
:
MaskCRLFTab
(
)
)
;
ToLowerCase
(
scheme
)
;
return
NS_OK
;
}
bool
net_IsValidScheme
(
const
nsACString
&
scheme
)
{
return
mozilla
:
:
net
:
:
rust_net_is_valid_scheme
(
&
scheme
)
;
}
bool
net_IsAbsoluteURL
(
const
nsACString
&
uri
)
{
nsACString
:
:
const_iterator
start
end
;
uri
.
BeginReading
(
start
)
;
uri
.
EndReading
(
end
)
;
while
(
start
!
=
end
)
{
if
(
(
uint8_t
)
*
start
>
0x20
)
{
break
;
}
start
+
+
;
}
Tokenizer
p
(
Substring
(
start
end
)
"
\
r
\
n
\
t
"
)
;
if
(
!
p
.
CheckChar
(
IsAsciiAlpha
)
)
{
return
false
;
}
while
(
p
.
CheckChar
(
net_IsValidSchemeChar
)
|
|
p
.
CheckWhite
(
)
)
{
}
if
(
!
p
.
CheckChar
(
'
:
'
)
)
{
return
false
;
}
p
.
SkipWhites
(
)
;
if
(
!
p
.
CheckChar
(
'
/
'
)
)
{
return
false
;
}
p
.
SkipWhites
(
)
;
if
(
p
.
CheckChar
(
'
/
'
)
)
{
return
true
;
}
return
false
;
}
void
net_FilterURIString
(
const
nsACString
&
input
nsACString
&
result
)
{
result
.
Truncate
(
)
;
const
auto
*
start
=
input
.
BeginReading
(
)
;
const
auto
*
end
=
input
.
EndReading
(
)
;
auto
charFilter
=
[
]
(
char
c
)
{
return
static_cast
<
uint8_t
>
(
c
)
>
0x20
;
}
;
const
auto
*
newStart
=
std
:
:
find_if
(
start
end
charFilter
)
;
const
auto
*
newEnd
=
std
:
:
find_if
(
std
:
:
reverse_iterator
<
decltype
(
end
)
>
(
end
)
std
:
:
reverse_iterator
<
decltype
(
newStart
)
>
(
newStart
)
charFilter
)
.
base
(
)
;
bool
needsStrip
=
false
;
const
ASCIIMaskArray
&
mask
=
ASCIIMask
:
:
MaskCRLFTab
(
)
;
for
(
const
auto
*
itr
=
start
;
itr
!
=
end
;
+
+
itr
)
{
if
(
ASCIIMask
:
:
IsMasked
(
mask
*
itr
)
)
{
needsStrip
=
true
;
break
;
}
}
if
(
newStart
=
=
start
&
&
newEnd
=
=
end
&
&
!
needsStrip
)
{
result
=
input
;
return
;
}
result
.
Assign
(
Substring
(
newStart
newEnd
)
)
;
if
(
needsStrip
)
{
result
.
StripTaggedASCII
(
mask
)
;
}
}
nsresult
net_FilterAndEscapeURI
(
const
nsACString
&
aInput
uint32_t
aFlags
const
ASCIIMaskArray
&
aFilterMask
nsACString
&
aResult
)
{
aResult
.
Truncate
(
)
;
const
auto
*
start
=
aInput
.
BeginReading
(
)
;
const
auto
*
end
=
aInput
.
EndReading
(
)
;
auto
charFilter
=
[
]
(
char
c
)
{
return
static_cast
<
uint8_t
>
(
c
)
>
0x20
;
}
;
const
auto
*
newStart
=
std
:
:
find_if
(
start
end
charFilter
)
;
const
auto
*
newEnd
=
std
:
:
find_if
(
std
:
:
reverse_iterator
<
decltype
(
end
)
>
(
end
)
std
:
:
reverse_iterator
<
decltype
(
newStart
)
>
(
newStart
)
charFilter
)
.
base
(
)
;
return
NS_EscapeAndFilterURL
(
Substring
(
newStart
newEnd
)
aFlags
&
aFilterMask
aResult
fallible
)
;
}
#
if
defined
(
XP_WIN
)
bool
net_NormalizeFileURL
(
const
nsACString
&
aURL
nsCString
&
aResultBuf
)
{
bool
writing
=
false
;
nsACString
:
:
const_iterator
beginIter
endIter
;
aURL
.
BeginReading
(
beginIter
)
;
aURL
.
EndReading
(
endIter
)
;
const
char
*
s
*
begin
=
beginIter
.
get
(
)
;
for
(
s
=
begin
;
s
!
=
endIter
.
get
(
)
;
+
+
s
)
{
if
(
*
s
=
=
'
\
\
'
)
{
writing
=
true
;
if
(
s
>
begin
)
aResultBuf
.
Append
(
begin
s
-
begin
)
;
aResultBuf
+
=
'
/
'
;
begin
=
s
+
1
;
}
}
if
(
writing
&
&
s
>
begin
)
aResultBuf
.
Append
(
begin
s
-
begin
)
;
return
writing
;
}
#
endif
static
inline
void
ToLower
(
char
&
c
)
{
if
(
(
unsigned
)
(
c
-
'
A
'
)
<
=
(
unsigned
)
(
'
Z
'
-
'
A
'
)
)
c
+
=
'
a
'
-
'
A
'
;
}
void
net_ToLowerCase
(
char
*
str
uint32_t
length
)
{
for
(
char
*
end
=
str
+
length
;
str
<
end
;
+
+
str
)
ToLower
(
*
str
)
;
}
void
net_ToLowerCase
(
char
*
str
)
{
for
(
;
*
str
;
+
+
str
)
ToLower
(
*
str
)
;
}
char
*
net_FindCharInSet
(
const
char
*
iter
const
char
*
stop
const
char
*
set
)
{
for
(
;
iter
!
=
stop
&
&
*
iter
;
+
+
iter
)
{
for
(
const
char
*
s
=
set
;
*
s
;
+
+
s
)
{
if
(
*
iter
=
=
*
s
)
return
(
char
*
)
iter
;
}
}
return
(
char
*
)
iter
;
}
char
*
net_FindCharNotInSet
(
const
char
*
iter
const
char
*
stop
const
char
*
set
)
{
repeat
:
for
(
const
char
*
s
=
set
;
*
s
;
+
+
s
)
{
if
(
*
iter
=
=
*
s
)
{
if
(
+
+
iter
=
=
stop
)
break
;
goto
repeat
;
}
}
return
(
char
*
)
iter
;
}
char
*
net_RFindCharNotInSet
(
const
char
*
stop
const
char
*
iter
const
char
*
set
)
{
-
-
iter
;
-
-
stop
;
if
(
iter
=
=
stop
)
return
(
char
*
)
iter
;
repeat
:
for
(
const
char
*
s
=
set
;
*
s
;
+
+
s
)
{
if
(
*
iter
=
=
*
s
)
{
if
(
-
-
iter
=
=
stop
)
break
;
goto
repeat
;
}
}
return
(
char
*
)
iter
;
}
#
define
HTTP_LWS
"
\
t
"
static
uint32_t
net_FindStringEnd
(
const
nsCString
&
flatStr
uint32_t
stringStart
char
stringDelim
)
{
NS_ASSERTION
(
stringStart
<
flatStr
.
Length
(
)
&
&
flatStr
.
CharAt
(
stringStart
)
=
=
stringDelim
&
&
(
stringDelim
=
=
'
"
'
|
|
stringDelim
=
=
'
\
'
'
)
"
Invalid
stringStart
"
)
;
const
char
set
[
]
=
{
stringDelim
'
\
\
'
'
\
0
'
}
;
do
{
uint32_t
stringEnd
=
flatStr
.
FindCharInSet
(
set
stringStart
+
1
)
;
if
(
stringEnd
=
=
uint32_t
(
kNotFound
)
)
return
flatStr
.
Length
(
)
;
if
(
flatStr
.
CharAt
(
stringEnd
)
=
=
'
\
\
'
)
{
stringStart
=
stringEnd
+
1
;
if
(
stringStart
=
=
flatStr
.
Length
(
)
)
return
stringStart
;
continue
;
}
return
stringEnd
;
}
while
(
true
)
;
MOZ_ASSERT_UNREACHABLE
(
"
How
did
we
get
here
?
"
)
;
return
flatStr
.
Length
(
)
;
}
static
uint32_t
net_FindMediaDelimiter
(
const
nsCString
&
flatStr
uint32_t
searchStart
char
delimiter
)
{
do
{
const
char
delimStr
[
]
=
{
delimiter
'
"
'
'
\
0
'
}
;
uint32_t
curDelimPos
=
flatStr
.
FindCharInSet
(
delimStr
searchStart
)
;
if
(
curDelimPos
=
=
uint32_t
(
kNotFound
)
)
return
flatStr
.
Length
(
)
;
char
ch
=
flatStr
.
CharAt
(
curDelimPos
)
;
if
(
ch
=
=
delimiter
)
{
return
curDelimPos
;
}
searchStart
=
net_FindStringEnd
(
flatStr
curDelimPos
ch
)
;
if
(
searchStart
=
=
flatStr
.
Length
(
)
)
return
searchStart
;
+
+
searchStart
;
}
while
(
true
)
;
MOZ_ASSERT_UNREACHABLE
(
"
How
did
we
get
here
?
"
)
;
return
flatStr
.
Length
(
)
;
}
static
void
net_ParseMediaType
(
const
nsACString
&
aMediaTypeStr
nsACString
&
aContentType
nsACString
&
aContentCharset
int32_t
aOffset
bool
*
aHadCharset
int32_t
*
aCharsetStart
int32_t
*
aCharsetEnd
bool
aStrict
)
{
const
nsCString
&
flatStr
=
PromiseFlatCString
(
aMediaTypeStr
)
;
const
char
*
start
=
flatStr
.
get
(
)
;
const
char
*
end
=
start
+
flatStr
.
Length
(
)
;
const
char
*
type
=
net_FindCharNotInSet
(
start
end
HTTP_LWS
)
;
const
char
*
typeEnd
=
net_FindCharInSet
(
type
end
HTTP_LWS
"
;
(
"
)
;
const
char
*
charset
=
"
"
;
const
char
*
charsetEnd
=
charset
;
int32_t
charsetParamStart
=
0
;
int32_t
charsetParamEnd
=
0
;
uint32_t
consumed
=
typeEnd
-
type
;
bool
typeHasCharset
=
false
;
uint32_t
paramStart
=
flatStr
.
FindChar
(
'
;
'
typeEnd
-
start
)
;
if
(
paramStart
!
=
uint32_t
(
kNotFound
)
)
{
uint32_t
curParamStart
=
paramStart
+
1
;
do
{
uint32_t
curParamEnd
=
net_FindMediaDelimiter
(
flatStr
curParamStart
'
;
'
)
;
const
char
*
paramName
=
net_FindCharNotInSet
(
start
+
curParamStart
start
+
curParamEnd
HTTP_LWS
)
;
static
const
char
charsetStr
[
]
=
"
charset
=
"
;
if
(
nsCRT
:
:
strncasecmp
(
paramName
charsetStr
sizeof
(
charsetStr
)
-
1
)
=
=
0
)
{
charset
=
paramName
+
sizeof
(
charsetStr
)
-
1
;
charsetEnd
=
start
+
curParamEnd
;
typeHasCharset
=
true
;
charsetParamStart
=
curParamStart
-
1
;
charsetParamEnd
=
curParamEnd
;
}
consumed
=
curParamEnd
;
curParamStart
=
curParamEnd
+
1
;
}
while
(
curParamStart
<
flatStr
.
Length
(
)
)
;
}
bool
charsetNeedsQuotedStringUnescaping
=
false
;
if
(
typeHasCharset
)
{
charset
=
net_FindCharNotInSet
(
charset
charsetEnd
HTTP_LWS
)
;
if
(
*
charset
=
=
'
"
'
)
{
charsetNeedsQuotedStringUnescaping
=
true
;
charsetEnd
=
start
+
net_FindStringEnd
(
flatStr
charset
-
start
*
charset
)
;
charset
+
+
;
NS_ASSERTION
(
charsetEnd
>
=
charset
"
Bad
charset
parsing
"
)
;
}
else
{
charsetEnd
=
net_FindCharInSet
(
charset
charsetEnd
HTTP_LWS
"
;
(
"
)
;
}
}
if
(
type
!
=
typeEnd
&
&
memchr
(
type
'
/
'
typeEnd
-
type
)
!
=
nullptr
&
&
(
aStrict
?
(
net_FindCharNotInSet
(
start
+
consumed
end
HTTP_LWS
)
=
=
end
)
:
(
strncmp
(
type
"
*
/
*
"
typeEnd
-
type
)
!
=
0
)
)
)
{
bool
eq
=
!
aContentType
.
IsEmpty
(
)
&
&
aContentType
.
Equals
(
Substring
(
type
typeEnd
)
nsCaseInsensitiveCStringComparator
)
;
if
(
!
eq
)
{
aContentType
.
Assign
(
type
typeEnd
-
type
)
;
ToLowerCase
(
aContentType
)
;
}
if
(
(
!
eq
&
&
*
aHadCharset
)
|
|
typeHasCharset
)
{
*
aHadCharset
=
true
;
if
(
charsetNeedsQuotedStringUnescaping
)
{
aContentCharset
.
Truncate
(
)
;
for
(
const
char
*
c
=
charset
;
c
!
=
charsetEnd
;
c
+
+
)
{
if
(
*
c
=
=
'
\
\
'
&
&
c
+
1
!
=
charsetEnd
)
{
c
+
+
;
}
aContentCharset
.
Append
(
*
c
)
;
}
}
else
{
aContentCharset
.
Assign
(
charset
charsetEnd
-
charset
)
;
}
if
(
typeHasCharset
)
{
*
aCharsetStart
=
charsetParamStart
+
aOffset
;
*
aCharsetEnd
=
charsetParamEnd
+
aOffset
;
}
}
if
(
!
eq
&
&
!
typeHasCharset
)
{
int32_t
charsetStart
=
int32_t
(
paramStart
)
;
if
(
charsetStart
=
=
kNotFound
)
charsetStart
=
flatStr
.
Length
(
)
;
*
aCharsetEnd
=
*
aCharsetStart
=
charsetStart
+
aOffset
;
}
}
}
#
undef
HTTP_LWS
void
net_ParseContentType
(
const
nsACString
&
aHeaderStr
nsACString
&
aContentType
nsACString
&
aContentCharset
bool
*
aHadCharset
)
{
int32_t
dummy1
dummy2
;
net_ParseContentType
(
aHeaderStr
aContentType
aContentCharset
aHadCharset
&
dummy1
&
dummy2
)
;
}
void
net_ParseContentType
(
const
nsACString
&
aHeaderStr
nsACString
&
aContentType
nsACString
&
aContentCharset
bool
*
aHadCharset
int32_t
*
aCharsetStart
int32_t
*
aCharsetEnd
)
{
*
aHadCharset
=
false
;
const
nsCString
&
flatStr
=
PromiseFlatCString
(
aHeaderStr
)
;
uint32_t
curTypeStart
=
0
;
do
{
uint32_t
curTypeEnd
=
net_FindMediaDelimiter
(
flatStr
curTypeStart
'
'
)
;
net_ParseMediaType
(
Substring
(
flatStr
curTypeStart
curTypeEnd
-
curTypeStart
)
aContentType
aContentCharset
curTypeStart
aHadCharset
aCharsetStart
aCharsetEnd
false
)
;
curTypeStart
=
curTypeEnd
+
1
;
}
while
(
curTypeStart
<
flatStr
.
Length
(
)
)
;
}
void
net_ParseRequestContentType
(
const
nsACString
&
aHeaderStr
nsACString
&
aContentType
nsACString
&
aContentCharset
bool
*
aHadCharset
)
{
aContentType
.
Truncate
(
)
;
aContentCharset
.
Truncate
(
)
;
*
aHadCharset
=
false
;
const
nsCString
&
flatStr
=
PromiseFlatCString
(
aHeaderStr
)
;
nsAutoCString
contentType
contentCharset
;
bool
hadCharset
=
false
;
int32_t
dummy1
dummy2
;
uint32_t
typeEnd
=
net_FindMediaDelimiter
(
flatStr
0
'
'
)
;
if
(
typeEnd
!
=
flatStr
.
Length
(
)
)
{
return
;
}
net_ParseMediaType
(
flatStr
contentType
contentCharset
0
&
hadCharset
&
dummy1
&
dummy2
true
)
;
aContentType
=
contentType
;
aContentCharset
=
contentCharset
;
*
aHadCharset
=
hadCharset
;
}
bool
net_IsValidHostName
(
const
nsACString
&
host
)
{
if
(
StaticPrefs
:
:
network_dns_limit_253_chars
(
)
&
&
host
.
Length
(
)
>
253
)
{
return
false
;
}
const
char
*
end
=
host
.
EndReading
(
)
;
if
(
net_FindCharNotInSet
(
host
.
BeginReading
(
)
end
"
abcdefghijklmnopqrstuvwxyz
"
"
.
-
0123456789
"
"
ABCDEFGHIJKLMNOPQRSTUVWXYZ
+
_
"
)
=
=
end
)
{
return
true
;
}
return
mozilla
:
:
net
:
:
HostIsIPLiteral
(
host
)
;
}
bool
net_IsValidIPv4Addr
(
const
nsACString
&
aAddr
)
{
return
mozilla
:
:
net
:
:
rust_net_is_valid_ipv4_addr
(
&
aAddr
)
;
}
bool
net_IsValidIPv6Addr
(
const
nsACString
&
aAddr
)
{
return
mozilla
:
:
net
:
:
rust_net_is_valid_ipv6_addr
(
&
aAddr
)
;
}
namespace
mozilla
{
static
auto
MakeNameMatcher
(
const
nsAString
&
aName
)
{
return
[
&
aName
]
(
const
auto
&
param
)
{
return
param
.
mKey
.
Equals
(
aName
)
;
}
;
}
bool
URLParams
:
:
Has
(
const
nsAString
&
aName
)
{
return
std
:
:
any_of
(
mParams
.
cbegin
(
)
mParams
.
cend
(
)
MakeNameMatcher
(
aName
)
)
;
}
void
URLParams
:
:
Get
(
const
nsAString
&
aName
nsString
&
aRetval
)
{
SetDOMStringToNull
(
aRetval
)
;
const
auto
end
=
mParams
.
cend
(
)
;
const
auto
it
=
std
:
:
find_if
(
mParams
.
cbegin
(
)
end
MakeNameMatcher
(
aName
)
)
;
if
(
it
!
=
end
)
{
aRetval
.
Assign
(
it
-
>
mValue
)
;
}
}
void
URLParams
:
:
GetAll
(
const
nsAString
&
aName
nsTArray
<
nsString
>
&
aRetval
)
{
aRetval
.
Clear
(
)
;
for
(
uint32_t
i
=
0
len
=
mParams
.
Length
(
)
;
i
<
len
;
+
+
i
)
{
if
(
mParams
[
i
]
.
mKey
.
Equals
(
aName
)
)
{
aRetval
.
AppendElement
(
mParams
[
i
]
.
mValue
)
;
}
}
}
void
URLParams
:
:
Append
(
const
nsAString
&
aName
const
nsAString
&
aValue
)
{
Param
*
param
=
mParams
.
AppendElement
(
)
;
param
-
>
mKey
=
aName
;
param
-
>
mValue
=
aValue
;
}
void
URLParams
:
:
Set
(
const
nsAString
&
aName
const
nsAString
&
aValue
)
{
Param
*
param
=
nullptr
;
for
(
uint32_t
i
=
0
len
=
mParams
.
Length
(
)
;
i
<
len
;
)
{
if
(
!
mParams
[
i
]
.
mKey
.
Equals
(
aName
)
)
{
+
+
i
;
continue
;
}
if
(
!
param
)
{
param
=
&
mParams
[
i
]
;
+
+
i
;
continue
;
}
mParams
.
RemoveElementAt
(
i
)
;
-
-
len
;
}
if
(
!
param
)
{
param
=
mParams
.
AppendElement
(
)
;
param
-
>
mKey
=
aName
;
}
param
-
>
mValue
=
aValue
;
}
void
URLParams
:
:
Delete
(
const
nsAString
&
aName
)
{
mParams
.
RemoveElementsBy
(
[
&
aName
]
(
const
auto
&
param
)
{
return
param
.
mKey
.
Equals
(
aName
)
;
}
)
;
}
void
URLParams
:
:
ConvertString
(
const
nsACString
&
aInput
nsAString
&
aOutput
)
{
if
(
NS_FAILED
(
UTF_8_ENCODING
-
>
DecodeWithoutBOMHandling
(
aInput
aOutput
)
)
)
{
MOZ_CRASH
(
"
Out
of
memory
when
converting
URL
params
.
"
)
;
}
}
void
URLParams
:
:
DecodeString
(
const
nsACString
&
aInput
nsAString
&
aOutput
)
{
const
char
*
const
end
=
aInput
.
EndReading
(
)
;
nsAutoCString
unescaped
;
for
(
const
char
*
iter
=
aInput
.
BeginReading
(
)
;
iter
!
=
end
;
)
{
if
(
*
iter
=
=
'
+
'
)
{
unescaped
.
Append
(
'
'
)
;
+
+
iter
;
continue
;
}
if
(
*
iter
=
=
'
%
'
)
{
const
char
*
const
first
=
iter
+
1
;
const
char
*
const
second
=
first
+
1
;
const
auto
asciiHexDigit
=
[
]
(
char
x
)
{
return
(
x
>
=
0x41
&
&
x
<
=
0x46
)
|
|
(
x
>
=
0x61
&
&
x
<
=
0x66
)
|
|
(
x
>
=
0x30
&
&
x
<
=
0x39
)
;
}
;
const
auto
hexDigit
=
[
]
(
char
x
)
{
return
x
>
=
0x30
&
&
x
<
=
0x39
?
x
-
0x30
:
(
x
>
=
0x41
&
&
x
<
=
0x46
?
x
-
0x37
:
x
-
0x57
)
;
}
;
if
(
first
!
=
end
&
&
second
!
=
end
&
&
asciiHexDigit
(
*
first
)
&
&
asciiHexDigit
(
*
second
)
)
{
unescaped
.
Append
(
hexDigit
(
*
first
)
*
16
+
hexDigit
(
*
second
)
)
;
iter
=
second
+
1
;
}
else
{
unescaped
.
Append
(
'
%
'
)
;
+
+
iter
;
}
continue
;
}
unescaped
.
Append
(
*
iter
)
;
+
+
iter
;
}
ConvertString
(
unescaped
aOutput
)
;
}
bool
URLParams
:
:
ParseNextInternal
(
const
char
*
&
aStart
const
char
*
const
aEnd
nsAString
*
aOutDecodedName
nsAString
*
aOutDecodedValue
)
{
nsDependentCSubstring
string
;
const
char
*
const
iter
=
std
:
:
find
(
aStart
aEnd
'
&
'
)
;
if
(
iter
!
=
aEnd
)
{
string
.
Rebind
(
aStart
iter
)
;
aStart
=
iter
+
1
;
}
else
{
string
.
Rebind
(
aStart
aEnd
)
;
aStart
=
aEnd
;
}
if
(
string
.
IsEmpty
(
)
)
{
return
false
;
}
const
auto
*
const
eqStart
=
string
.
BeginReading
(
)
;
const
auto
*
const
eqEnd
=
string
.
EndReading
(
)
;
const
auto
*
const
eqIter
=
std
:
:
find
(
eqStart
eqEnd
'
=
'
)
;
nsDependentCSubstring
name
;
nsDependentCSubstring
value
;
if
(
eqIter
!
=
eqEnd
)
{
name
.
Rebind
(
eqStart
eqIter
)
;
value
.
Rebind
(
eqIter
+
1
eqEnd
)
;
}
else
{
name
.
Rebind
(
string
0
)
;
}
DecodeString
(
name
*
aOutDecodedName
)
;
DecodeString
(
value
*
aOutDecodedValue
)
;
return
true
;
}
bool
URLParams
:
:
Extract
(
const
nsACString
&
aInput
const
nsAString
&
aName
nsAString
&
aValue
)
{
aValue
.
SetIsVoid
(
true
)
;
return
!
URLParams
:
:
Parse
(
aInput
[
&
aName
&
aValue
]
(
const
nsAString
&
name
nsString
&
&
value
)
{
if
(
aName
=
=
name
)
{
aValue
=
std
:
:
move
(
value
)
;
return
false
;
}
return
true
;
}
)
;
}
void
URLParams
:
:
ParseInput
(
const
nsACString
&
aInput
)
{
DeleteAll
(
)
;
URLParams
:
:
Parse
(
aInput
[
this
]
(
nsString
&
&
name
nsString
&
&
value
)
{
mParams
.
AppendElement
(
Param
{
std
:
:
move
(
name
)
std
:
:
move
(
value
)
}
)
;
return
true
;
}
)
;
}
namespace
{
void
SerializeString
(
const
nsCString
&
aInput
nsAString
&
aValue
)
{
const
unsigned
char
*
p
=
(
const
unsigned
char
*
)
aInput
.
get
(
)
;
const
unsigned
char
*
end
=
p
+
aInput
.
Length
(
)
;
while
(
p
!
=
end
)
{
if
(
*
p
=
=
0x20
)
{
aValue
.
Append
(
0x2B
)
;
}
else
if
(
*
p
=
=
0x2A
|
|
*
p
=
=
0x2D
|
|
*
p
=
=
0x2E
|
|
(
*
p
>
=
0x30
&
&
*
p
<
=
0x39
)
|
|
(
*
p
>
=
0x41
&
&
*
p
<
=
0x5A
)
|
|
*
p
=
=
0x5F
|
|
(
*
p
>
=
0x61
&
&
*
p
<
=
0x7A
)
)
{
aValue
.
Append
(
*
p
)
;
}
else
{
aValue
.
AppendPrintf
(
"
%
%
%
.
2X
"
*
p
)
;
}
+
+
p
;
}
}
}
void
URLParams
:
:
Serialize
(
nsAString
&
aValue
)
const
{
aValue
.
Truncate
(
)
;
bool
first
=
true
;
for
(
uint32_t
i
=
0
len
=
mParams
.
Length
(
)
;
i
<
len
;
+
+
i
)
{
if
(
first
)
{
first
=
false
;
}
else
{
aValue
.
Append
(
'
&
'
)
;
}
SerializeString
(
NS_ConvertUTF16toUTF8
(
mParams
[
i
]
.
mKey
)
aValue
)
;
aValue
.
Append
(
'
=
'
)
;
SerializeString
(
NS_ConvertUTF16toUTF8
(
mParams
[
i
]
.
mValue
)
aValue
)
;
}
}
void
URLParams
:
:
Sort
(
)
{
mParams
.
StableSort
(
[
]
(
const
Param
&
lhs
const
Param
&
rhs
)
{
return
Compare
(
lhs
.
mKey
rhs
.
mKey
)
;
}
)
;
}
}
