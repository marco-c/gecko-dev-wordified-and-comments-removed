#
include
"
mozilla
/
RangedPtr
.
h
"
#
include
"
mozilla
/
TextUtils
.
h
"
#
include
<
algorithm
>
#
include
<
iterator
>
#
include
"
nsASCIIMask
.
h
"
#
include
"
nsURLHelper
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsIURLParser
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
prnetdb
.
h
"
#
include
"
mozilla
/
Tokenizer
.
h
"
#
include
"
nsEscape
.
h
"
#
include
"
rust
-
helper
/
src
/
helper
.
h
"
using
namespace
mozilla
;
static
bool
gInitialized
=
false
;
static
nsIURLParser
*
gNoAuthURLParser
=
nullptr
;
static
nsIURLParser
*
gAuthURLParser
=
nullptr
;
static
nsIURLParser
*
gStdURLParser
=
nullptr
;
static
int32_t
gMaxLength
=
1048576
;
static
void
InitGlobals
(
)
{
nsCOMPtr
<
nsIURLParser
>
parser
;
parser
=
do_GetService
(
NS_NOAUTHURLPARSER_CONTRACTID
)
;
NS_ASSERTION
(
parser
"
failed
getting
'
noauth
'
url
parser
"
)
;
if
(
parser
)
{
gNoAuthURLParser
=
parser
.
get
(
)
;
NS_ADDREF
(
gNoAuthURLParser
)
;
}
parser
=
do_GetService
(
NS_AUTHURLPARSER_CONTRACTID
)
;
NS_ASSERTION
(
parser
"
failed
getting
'
auth
'
url
parser
"
)
;
if
(
parser
)
{
gAuthURLParser
=
parser
.
get
(
)
;
NS_ADDREF
(
gAuthURLParser
)
;
}
parser
=
do_GetService
(
NS_STDURLPARSER_CONTRACTID
)
;
NS_ASSERTION
(
parser
"
failed
getting
'
std
'
url
parser
"
)
;
if
(
parser
)
{
gStdURLParser
=
parser
.
get
(
)
;
NS_ADDREF
(
gStdURLParser
)
;
}
gInitialized
=
true
;
Preferences
:
:
AddIntVarCache
(
&
gMaxLength
"
network
.
standard
-
url
.
max
-
length
"
1048576
)
;
}
void
net_ShutdownURLHelper
(
)
{
if
(
gInitialized
)
{
NS_IF_RELEASE
(
gNoAuthURLParser
)
;
NS_IF_RELEASE
(
gAuthURLParser
)
;
NS_IF_RELEASE
(
gStdURLParser
)
;
gInitialized
=
false
;
}
}
int32_t
net_GetURLMaxLength
(
)
{
return
gMaxLength
;
}
nsIURLParser
*
net_GetAuthURLParser
(
)
{
if
(
!
gInitialized
)
InitGlobals
(
)
;
return
gAuthURLParser
;
}
nsIURLParser
*
net_GetNoAuthURLParser
(
)
{
if
(
!
gInitialized
)
InitGlobals
(
)
;
return
gNoAuthURLParser
;
}
nsIURLParser
*
net_GetStdURLParser
(
)
{
if
(
!
gInitialized
)
InitGlobals
(
)
;
return
gStdURLParser
;
}
nsresult
net_GetURLSpecFromDir
(
nsIFile
*
aFile
nsACString
&
result
)
{
nsAutoCString
escPath
;
nsresult
rv
=
net_GetURLSpecFromActualFile
(
aFile
escPath
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
if
(
escPath
.
Last
(
)
!
=
'
/
'
)
{
escPath
+
=
'
/
'
;
}
result
=
escPath
;
return
NS_OK
;
}
nsresult
net_GetURLSpecFromFile
(
nsIFile
*
aFile
nsACString
&
result
)
{
nsAutoCString
escPath
;
nsresult
rv
=
net_GetURLSpecFromActualFile
(
aFile
escPath
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
if
(
escPath
.
Last
(
)
!
=
'
/
'
)
{
bool
dir
;
rv
=
aFile
-
>
IsDirectory
(
&
dir
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
dir
)
escPath
+
=
'
/
'
;
}
result
=
escPath
;
return
NS_OK
;
}
nsresult
net_ParseFileURL
(
const
nsACString
&
inURL
nsACString
&
outDirectory
nsACString
&
outFileBaseName
nsACString
&
outFileExtension
)
{
nsresult
rv
;
if
(
inURL
.
Length
(
)
>
(
uint32_t
)
gMaxLength
)
{
return
NS_ERROR_MALFORMED_URI
;
}
outDirectory
.
Truncate
(
)
;
outFileBaseName
.
Truncate
(
)
;
outFileExtension
.
Truncate
(
)
;
const
nsPromiseFlatCString
&
flatURL
=
PromiseFlatCString
(
inURL
)
;
const
char
*
url
=
flatURL
.
get
(
)
;
nsAutoCString
scheme
;
rv
=
net_ExtractURLScheme
(
flatURL
scheme
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
if
(
!
scheme
.
EqualsLiteral
(
"
file
"
)
)
{
NS_ERROR
(
"
must
be
a
file
:
/
/
url
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
nsIURLParser
*
parser
=
net_GetNoAuthURLParser
(
)
;
NS_ENSURE_TRUE
(
parser
NS_ERROR_UNEXPECTED
)
;
uint32_t
pathPos
filepathPos
directoryPos
basenamePos
extensionPos
;
int32_t
pathLen
filepathLen
directoryLen
basenameLen
extensionLen
;
rv
=
parser
-
>
ParseURL
(
url
flatURL
.
Length
(
)
nullptr
nullptr
nullptr
nullptr
&
pathPos
&
pathLen
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
rv
=
parser
-
>
ParsePath
(
url
+
pathPos
pathLen
&
filepathPos
&
filepathLen
nullptr
nullptr
nullptr
nullptr
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
filepathPos
+
=
pathPos
;
rv
=
parser
-
>
ParseFilePath
(
url
+
filepathPos
filepathLen
&
directoryPos
&
directoryLen
&
basenamePos
&
basenameLen
&
extensionPos
&
extensionLen
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
if
(
directoryLen
>
0
)
outDirectory
=
Substring
(
inURL
filepathPos
+
directoryPos
directoryLen
)
;
if
(
basenameLen
>
0
)
outFileBaseName
=
Substring
(
inURL
filepathPos
+
basenamePos
basenameLen
)
;
if
(
extensionLen
>
0
)
outFileExtension
=
Substring
(
inURL
filepathPos
+
extensionPos
extensionLen
)
;
return
NS_OK
;
}
void
net_CoalesceDirs
(
netCoalesceFlags
flags
char
*
path
)
{
char
*
fwdPtr
=
path
;
char
*
urlPtr
=
path
;
char
*
lastslash
=
path
;
uint32_t
traversal
=
0
;
uint32_t
special_ftp_len
=
0
;
if
(
flags
&
NET_COALESCE_DOUBLE_SLASH_IS_ROOT
)
{
if
(
nsCRT
:
:
strncasecmp
(
path
"
/
%
2F
"
4
)
=
=
0
)
special_ftp_len
=
4
;
else
if
(
strncmp
(
path
"
/
/
"
2
)
=
=
0
)
special_ftp_len
=
2
;
}
for
(
;
(
*
fwdPtr
!
=
'
\
0
'
)
&
&
(
*
fwdPtr
!
=
'
?
'
)
&
&
(
*
fwdPtr
!
=
'
#
'
)
;
+
+
fwdPtr
)
{
}
if
(
fwdPtr
!
=
path
&
&
*
fwdPtr
=
=
'
\
0
'
)
{
-
-
fwdPtr
;
}
for
(
;
(
fwdPtr
!
=
path
)
&
&
(
*
fwdPtr
!
=
'
/
'
)
;
-
-
fwdPtr
)
{
}
lastslash
=
fwdPtr
;
fwdPtr
=
path
;
for
(
;
(
*
fwdPtr
!
=
'
\
0
'
)
&
&
(
*
fwdPtr
!
=
'
?
'
)
&
&
(
*
fwdPtr
!
=
'
#
'
)
&
&
(
*
lastslash
=
=
'
\
0
'
|
|
fwdPtr
!
=
lastslash
)
;
+
+
fwdPtr
)
{
if
(
*
fwdPtr
=
=
'
%
'
&
&
*
(
fwdPtr
+
1
)
=
=
'
2
'
&
&
(
*
(
fwdPtr
+
2
)
=
=
'
E
'
|
|
*
(
fwdPtr
+
2
)
=
=
'
e
'
)
)
{
*
urlPtr
+
+
=
'
.
'
;
+
+
fwdPtr
;
+
+
fwdPtr
;
}
else
{
*
urlPtr
+
+
=
*
fwdPtr
;
}
}
for
(
;
*
fwdPtr
!
=
'
\
0
'
;
+
+
fwdPtr
)
{
*
urlPtr
+
+
=
*
fwdPtr
;
}
*
urlPtr
=
'
\
0
'
;
fwdPtr
=
path
;
urlPtr
=
path
;
for
(
;
(
*
fwdPtr
!
=
'
\
0
'
)
&
&
(
*
fwdPtr
!
=
'
?
'
)
&
&
(
*
fwdPtr
!
=
'
#
'
)
;
+
+
fwdPtr
)
{
if
(
*
fwdPtr
=
=
'
/
'
&
&
*
(
fwdPtr
+
1
)
=
=
'
.
'
&
&
*
(
fwdPtr
+
2
)
=
=
'
/
'
)
{
+
+
fwdPtr
;
}
else
if
(
*
fwdPtr
=
=
'
/
'
&
&
*
(
fwdPtr
+
1
)
=
=
'
.
'
&
&
*
(
fwdPtr
+
2
)
=
=
'
.
'
&
&
(
*
(
fwdPtr
+
3
)
=
=
'
/
'
|
|
*
(
fwdPtr
+
3
)
=
=
'
\
0
'
|
|
*
(
fwdPtr
+
3
)
=
=
'
?
'
|
|
*
(
fwdPtr
+
3
)
=
=
'
#
'
)
)
{
if
(
traversal
>
0
|
|
!
(
flags
&
NET_COALESCE_ALLOW_RELATIVE_ROOT
)
)
{
if
(
urlPtr
!
=
path
)
urlPtr
-
-
;
for
(
;
*
urlPtr
!
=
'
/
'
&
&
urlPtr
!
=
path
;
urlPtr
-
-
)
;
-
-
traversal
;
fwdPtr
+
=
2
;
if
(
urlPtr
=
=
path
&
&
special_ftp_len
>
3
)
{
+
+
urlPtr
;
+
+
urlPtr
;
+
+
urlPtr
;
}
if
(
*
fwdPtr
=
=
'
.
'
&
&
*
(
fwdPtr
+
1
)
=
=
'
\
0
'
)
+
+
urlPtr
;
}
else
{
if
(
special_ftp_len
>
3
&
&
urlPtr
=
=
path
+
special_ftp_len
-
1
)
+
+
urlPtr
;
else
*
urlPtr
+
+
=
*
fwdPtr
;
+
+
fwdPtr
;
*
urlPtr
+
+
=
*
fwdPtr
;
+
+
fwdPtr
;
*
urlPtr
+
+
=
*
fwdPtr
;
}
}
else
{
if
(
*
fwdPtr
=
=
'
/
'
&
&
*
(
fwdPtr
+
1
)
!
=
'
.
'
&
&
(
special_ftp_len
!
=
2
|
|
*
(
fwdPtr
+
1
)
!
=
'
/
'
)
)
traversal
+
+
;
*
urlPtr
+
+
=
*
fwdPtr
;
}
}
if
(
(
urlPtr
>
(
path
+
1
)
)
&
&
(
*
(
urlPtr
-
1
)
=
=
'
.
'
)
&
&
(
*
(
urlPtr
-
2
)
=
=
'
/
'
)
)
urlPtr
-
-
;
for
(
;
*
fwdPtr
!
=
'
\
0
'
;
+
+
fwdPtr
)
{
*
urlPtr
+
+
=
*
fwdPtr
;
}
*
urlPtr
=
'
\
0
'
;
}
nsresult
net_ResolveRelativePath
(
const
nsACString
&
relativePath
const
nsACString
&
basePath
nsACString
&
result
)
{
nsAutoCString
name
;
nsAutoCString
path
(
basePath
)
;
bool
needsDelim
=
false
;
if
(
!
path
.
IsEmpty
(
)
)
{
char16_t
last
=
path
.
Last
(
)
;
needsDelim
=
!
(
last
=
=
'
/
'
)
;
}
nsACString
:
:
const_iterator
beg
end
;
relativePath
.
BeginReading
(
beg
)
;
relativePath
.
EndReading
(
end
)
;
bool
stop
=
false
;
char
c
;
for
(
;
!
stop
;
+
+
beg
)
{
c
=
(
beg
=
=
end
)
?
'
\
0
'
:
*
beg
;
switch
(
c
)
{
case
'
\
0
'
:
case
'
#
'
:
case
'
?
'
:
stop
=
true
;
[
[
fallthrough
]
]
;
case
'
/
'
:
if
(
name
.
EqualsLiteral
(
"
.
.
"
)
)
{
int32_t
offset
=
path
.
Length
(
)
-
(
needsDelim
?
1
:
2
)
;
if
(
offset
<
0
)
return
NS_ERROR_MALFORMED_URI
;
int32_t
pos
=
path
.
RFind
(
"
/
"
false
offset
)
;
if
(
pos
>
=
0
)
path
.
Truncate
(
pos
+
1
)
;
else
path
.
Truncate
(
)
;
}
else
if
(
name
.
IsEmpty
(
)
|
|
name
.
EqualsLiteral
(
"
.
"
)
)
{
}
else
{
if
(
needsDelim
)
path
+
=
'
/
'
;
path
+
=
name
;
needsDelim
=
true
;
}
name
.
Truncate
(
)
;
break
;
default
:
name
+
=
c
;
}
}
if
(
c
!
=
'
\
0
'
)
path
+
=
Substring
(
-
-
beg
end
)
;
result
=
path
;
return
NS_OK
;
}
static
bool
net_IsValidSchemeChar
(
const
char
aChar
)
{
if
(
IsAsciiAlpha
(
aChar
)
|
|
IsAsciiDigit
(
aChar
)
|
|
aChar
=
=
'
+
'
|
|
aChar
=
=
'
.
'
|
|
aChar
=
=
'
-
'
)
{
return
true
;
}
return
false
;
}
nsresult
net_ExtractURLScheme
(
const
nsACString
&
inURI
nsACString
&
scheme
)
{
nsACString
:
:
const_iterator
start
end
;
inURI
.
BeginReading
(
start
)
;
inURI
.
EndReading
(
end
)
;
while
(
start
!
=
end
)
{
if
(
(
uint8_t
)
*
start
>
0x20
)
{
break
;
}
start
+
+
;
}
Tokenizer
p
(
Substring
(
start
end
)
"
\
r
\
n
\
t
"
)
;
p
.
Record
(
)
;
if
(
!
p
.
CheckChar
(
IsAsciiAlpha
)
)
{
return
NS_ERROR_MALFORMED_URI
;
}
while
(
p
.
CheckChar
(
net_IsValidSchemeChar
)
|
|
p
.
CheckWhite
(
)
)
{
}
if
(
!
p
.
CheckChar
(
'
:
'
)
)
{
return
NS_ERROR_MALFORMED_URI
;
}
p
.
Claim
(
scheme
)
;
scheme
.
StripTaggedASCII
(
ASCIIMask
:
:
MaskCRLFTab
(
)
)
;
ToLowerCase
(
scheme
)
;
return
NS_OK
;
}
bool
net_IsValidScheme
(
const
char
*
scheme
uint32_t
schemeLen
)
{
if
(
!
IsAsciiAlpha
(
*
scheme
)
)
return
false
;
for
(
;
schemeLen
;
+
+
scheme
-
-
schemeLen
)
{
if
(
!
(
IsAsciiAlpha
(
*
scheme
)
|
|
IsAsciiDigit
(
*
scheme
)
|
|
*
scheme
=
=
'
+
'
|
|
*
scheme
=
=
'
.
'
|
|
*
scheme
=
=
'
-
'
)
)
return
false
;
}
return
true
;
}
bool
net_IsAbsoluteURL
(
const
nsACString
&
uri
)
{
nsACString
:
:
const_iterator
start
end
;
uri
.
BeginReading
(
start
)
;
uri
.
EndReading
(
end
)
;
while
(
start
!
=
end
)
{
if
(
(
uint8_t
)
*
start
>
0x20
)
{
break
;
}
start
+
+
;
}
Tokenizer
p
(
Substring
(
start
end
)
"
\
r
\
n
\
t
"
)
;
if
(
!
p
.
CheckChar
(
IsAsciiAlpha
)
)
{
return
false
;
}
while
(
p
.
CheckChar
(
net_IsValidSchemeChar
)
|
|
p
.
CheckWhite
(
)
)
{
}
if
(
!
p
.
CheckChar
(
'
:
'
)
)
{
return
false
;
}
p
.
SkipWhites
(
)
;
if
(
!
p
.
CheckChar
(
'
/
'
)
)
{
return
false
;
}
p
.
SkipWhites
(
)
;
if
(
p
.
CheckChar
(
'
/
'
)
)
{
return
true
;
}
return
false
;
}
void
net_FilterURIString
(
const
nsACString
&
input
nsACString
&
result
)
{
result
.
Truncate
(
)
;
auto
start
=
input
.
BeginReading
(
)
;
auto
end
=
input
.
EndReading
(
)
;
auto
charFilter
=
[
]
(
char
c
)
{
return
static_cast
<
uint8_t
>
(
c
)
>
0x20
;
}
;
auto
newStart
=
std
:
:
find_if
(
start
end
charFilter
)
;
auto
newEnd
=
std
:
:
find_if
(
std
:
:
reverse_iterator
<
decltype
(
end
)
>
(
end
)
std
:
:
reverse_iterator
<
decltype
(
newStart
)
>
(
newStart
)
charFilter
)
.
base
(
)
;
bool
needsStrip
=
false
;
const
ASCIIMaskArray
&
mask
=
ASCIIMask
:
:
MaskCRLFTab
(
)
;
for
(
auto
itr
=
start
;
itr
!
=
end
;
+
+
itr
)
{
if
(
ASCIIMask
:
:
IsMasked
(
mask
*
itr
)
)
{
needsStrip
=
true
;
break
;
}
}
if
(
newStart
=
=
start
&
&
newEnd
=
=
end
&
&
!
needsStrip
)
{
result
=
input
;
return
;
}
result
.
Assign
(
Substring
(
newStart
newEnd
)
)
;
if
(
needsStrip
)
{
result
.
StripTaggedASCII
(
mask
)
;
}
}
nsresult
net_FilterAndEscapeURI
(
const
nsACString
&
aInput
uint32_t
aFlags
nsACString
&
aResult
)
{
aResult
.
Truncate
(
)
;
auto
start
=
aInput
.
BeginReading
(
)
;
auto
end
=
aInput
.
EndReading
(
)
;
auto
charFilter
=
[
]
(
char
c
)
{
return
static_cast
<
uint8_t
>
(
c
)
>
0x20
;
}
;
auto
newStart
=
std
:
:
find_if
(
start
end
charFilter
)
;
auto
newEnd
=
std
:
:
find_if
(
std
:
:
reverse_iterator
<
decltype
(
end
)
>
(
end
)
std
:
:
reverse_iterator
<
decltype
(
newStart
)
>
(
newStart
)
charFilter
)
.
base
(
)
;
const
ASCIIMaskArray
&
mask
=
ASCIIMask
:
:
MaskCRLFTab
(
)
;
return
NS_EscapeAndFilterURL
(
Substring
(
newStart
newEnd
)
aFlags
&
mask
aResult
fallible
)
;
}
#
if
defined
(
XP_WIN
)
bool
net_NormalizeFileURL
(
const
nsACString
&
aURL
nsCString
&
aResultBuf
)
{
bool
writing
=
false
;
nsACString
:
:
const_iterator
beginIter
endIter
;
aURL
.
BeginReading
(
beginIter
)
;
aURL
.
EndReading
(
endIter
)
;
const
char
*
s
*
begin
=
beginIter
.
get
(
)
;
for
(
s
=
begin
;
s
!
=
endIter
.
get
(
)
;
+
+
s
)
{
if
(
*
s
=
=
'
\
\
'
)
{
writing
=
true
;
if
(
s
>
begin
)
aResultBuf
.
Append
(
begin
s
-
begin
)
;
aResultBuf
+
=
'
/
'
;
begin
=
s
+
1
;
}
}
if
(
writing
&
&
s
>
begin
)
aResultBuf
.
Append
(
begin
s
-
begin
)
;
return
writing
;
}
#
endif
static
inline
void
ToLower
(
char
&
c
)
{
if
(
(
unsigned
)
(
c
-
'
A
'
)
<
=
(
unsigned
)
(
'
Z
'
-
'
A
'
)
)
c
+
=
'
a
'
-
'
A
'
;
}
void
net_ToLowerCase
(
char
*
str
uint32_t
length
)
{
for
(
char
*
end
=
str
+
length
;
str
<
end
;
+
+
str
)
ToLower
(
*
str
)
;
}
void
net_ToLowerCase
(
char
*
str
)
{
for
(
;
*
str
;
+
+
str
)
ToLower
(
*
str
)
;
}
char
*
net_FindCharInSet
(
const
char
*
iter
const
char
*
stop
const
char
*
set
)
{
for
(
;
iter
!
=
stop
&
&
*
iter
;
+
+
iter
)
{
for
(
const
char
*
s
=
set
;
*
s
;
+
+
s
)
{
if
(
*
iter
=
=
*
s
)
return
(
char
*
)
iter
;
}
}
return
(
char
*
)
iter
;
}
char
*
net_FindCharNotInSet
(
const
char
*
iter
const
char
*
stop
const
char
*
set
)
{
repeat
:
for
(
const
char
*
s
=
set
;
*
s
;
+
+
s
)
{
if
(
*
iter
=
=
*
s
)
{
if
(
+
+
iter
=
=
stop
)
break
;
goto
repeat
;
}
}
return
(
char
*
)
iter
;
}
char
*
net_RFindCharNotInSet
(
const
char
*
stop
const
char
*
iter
const
char
*
set
)
{
-
-
iter
;
-
-
stop
;
if
(
iter
=
=
stop
)
return
(
char
*
)
iter
;
repeat
:
for
(
const
char
*
s
=
set
;
*
s
;
+
+
s
)
{
if
(
*
iter
=
=
*
s
)
{
if
(
-
-
iter
=
=
stop
)
break
;
goto
repeat
;
}
}
return
(
char
*
)
iter
;
}
#
define
HTTP_LWS
"
\
t
"
static
uint32_t
net_FindStringEnd
(
const
nsCString
&
flatStr
uint32_t
stringStart
char
stringDelim
)
{
NS_ASSERTION
(
stringStart
<
flatStr
.
Length
(
)
&
&
flatStr
.
CharAt
(
stringStart
)
=
=
stringDelim
&
&
(
stringDelim
=
=
'
"
'
|
|
stringDelim
=
=
'
\
'
'
)
"
Invalid
stringStart
"
)
;
const
char
set
[
]
=
{
stringDelim
'
\
\
'
'
\
0
'
}
;
do
{
uint32_t
stringEnd
=
flatStr
.
FindCharInSet
(
set
stringStart
+
1
)
;
if
(
stringEnd
=
=
uint32_t
(
kNotFound
)
)
return
flatStr
.
Length
(
)
;
if
(
flatStr
.
CharAt
(
stringEnd
)
=
=
'
\
\
'
)
{
stringStart
=
stringEnd
+
1
;
if
(
stringStart
=
=
flatStr
.
Length
(
)
)
return
stringStart
;
continue
;
}
return
stringEnd
;
}
while
(
true
)
;
MOZ_ASSERT_UNREACHABLE
(
"
How
did
we
get
here
?
"
)
;
return
flatStr
.
Length
(
)
;
}
static
uint32_t
net_FindMediaDelimiter
(
const
nsCString
&
flatStr
uint32_t
searchStart
char
delimiter
)
{
do
{
const
char
delimStr
[
]
=
{
delimiter
'
"
'
'
\
0
'
}
;
uint32_t
curDelimPos
=
flatStr
.
FindCharInSet
(
delimStr
searchStart
)
;
if
(
curDelimPos
=
=
uint32_t
(
kNotFound
)
)
return
flatStr
.
Length
(
)
;
char
ch
=
flatStr
.
CharAt
(
curDelimPos
)
;
if
(
ch
=
=
delimiter
)
{
return
curDelimPos
;
}
searchStart
=
net_FindStringEnd
(
flatStr
curDelimPos
ch
)
;
if
(
searchStart
=
=
flatStr
.
Length
(
)
)
return
searchStart
;
+
+
searchStart
;
}
while
(
true
)
;
MOZ_ASSERT_UNREACHABLE
(
"
How
did
we
get
here
?
"
)
;
return
flatStr
.
Length
(
)
;
}
static
void
net_ParseMediaType
(
const
nsACString
&
aMediaTypeStr
nsACString
&
aContentType
nsACString
&
aContentCharset
int32_t
aOffset
bool
*
aHadCharset
int32_t
*
aCharsetStart
int32_t
*
aCharsetEnd
bool
aStrict
)
{
const
nsCString
&
flatStr
=
PromiseFlatCString
(
aMediaTypeStr
)
;
const
char
*
start
=
flatStr
.
get
(
)
;
const
char
*
end
=
start
+
flatStr
.
Length
(
)
;
const
char
*
type
=
net_FindCharNotInSet
(
start
end
HTTP_LWS
)
;
const
char
*
typeEnd
=
net_FindCharInSet
(
type
end
HTTP_LWS
"
;
(
"
)
;
const
char
*
charset
=
"
"
;
const
char
*
charsetEnd
=
charset
;
int32_t
charsetParamStart
=
0
;
int32_t
charsetParamEnd
=
0
;
uint32_t
consumed
=
typeEnd
-
type
;
bool
typeHasCharset
=
false
;
uint32_t
paramStart
=
flatStr
.
FindChar
(
'
;
'
typeEnd
-
start
)
;
if
(
paramStart
!
=
uint32_t
(
kNotFound
)
)
{
uint32_t
curParamStart
=
paramStart
+
1
;
do
{
uint32_t
curParamEnd
=
net_FindMediaDelimiter
(
flatStr
curParamStart
'
;
'
)
;
const
char
*
paramName
=
net_FindCharNotInSet
(
start
+
curParamStart
start
+
curParamEnd
HTTP_LWS
)
;
static
const
char
charsetStr
[
]
=
"
charset
=
"
;
if
(
PL_strncasecmp
(
paramName
charsetStr
sizeof
(
charsetStr
)
-
1
)
=
=
0
)
{
charset
=
paramName
+
sizeof
(
charsetStr
)
-
1
;
charsetEnd
=
start
+
curParamEnd
;
typeHasCharset
=
true
;
charsetParamStart
=
curParamStart
-
1
;
charsetParamEnd
=
curParamEnd
;
}
consumed
=
curParamEnd
;
curParamStart
=
curParamEnd
+
1
;
}
while
(
curParamStart
<
flatStr
.
Length
(
)
)
;
}
bool
charsetNeedsQuotedStringUnescaping
=
false
;
if
(
typeHasCharset
)
{
charset
=
net_FindCharNotInSet
(
charset
charsetEnd
HTTP_LWS
)
;
if
(
*
charset
=
=
'
"
'
)
{
charsetNeedsQuotedStringUnescaping
=
true
;
charsetEnd
=
start
+
net_FindStringEnd
(
flatStr
charset
-
start
*
charset
)
;
charset
+
+
;
NS_ASSERTION
(
charsetEnd
>
=
charset
"
Bad
charset
parsing
"
)
;
}
else
{
charsetEnd
=
net_FindCharInSet
(
charset
charsetEnd
HTTP_LWS
"
;
(
"
)
;
}
}
if
(
type
!
=
typeEnd
&
&
memchr
(
type
'
/
'
typeEnd
-
type
)
!
=
nullptr
&
&
(
aStrict
?
(
net_FindCharNotInSet
(
start
+
consumed
end
HTTP_LWS
)
=
=
end
)
:
(
strncmp
(
type
"
*
/
*
"
typeEnd
-
type
)
!
=
0
)
)
)
{
bool
eq
=
!
aContentType
.
IsEmpty
(
)
&
&
aContentType
.
Equals
(
Substring
(
type
typeEnd
)
nsCaseInsensitiveCStringComparator
(
)
)
;
if
(
!
eq
)
{
aContentType
.
Assign
(
type
typeEnd
-
type
)
;
ToLowerCase
(
aContentType
)
;
}
if
(
(
!
eq
&
&
*
aHadCharset
)
|
|
typeHasCharset
)
{
*
aHadCharset
=
true
;
if
(
charsetNeedsQuotedStringUnescaping
)
{
aContentCharset
.
Truncate
(
)
;
for
(
const
char
*
c
=
charset
;
c
!
=
charsetEnd
;
c
+
+
)
{
if
(
*
c
=
=
'
\
\
'
&
&
c
+
1
!
=
charsetEnd
)
{
c
+
+
;
}
aContentCharset
.
Append
(
*
c
)
;
}
}
else
{
aContentCharset
.
Assign
(
charset
charsetEnd
-
charset
)
;
}
if
(
typeHasCharset
)
{
*
aCharsetStart
=
charsetParamStart
+
aOffset
;
*
aCharsetEnd
=
charsetParamEnd
+
aOffset
;
}
}
if
(
!
eq
&
&
!
typeHasCharset
)
{
int32_t
charsetStart
=
int32_t
(
paramStart
)
;
if
(
charsetStart
=
=
kNotFound
)
charsetStart
=
flatStr
.
Length
(
)
;
*
aCharsetEnd
=
*
aCharsetStart
=
charsetStart
+
aOffset
;
}
}
}
#
undef
HTTP_LWS
void
net_ParseContentType
(
const
nsACString
&
aHeaderStr
nsACString
&
aContentType
nsACString
&
aContentCharset
bool
*
aHadCharset
)
{
int32_t
dummy1
dummy2
;
net_ParseContentType
(
aHeaderStr
aContentType
aContentCharset
aHadCharset
&
dummy1
&
dummy2
)
;
}
void
net_ParseContentType
(
const
nsACString
&
aHeaderStr
nsACString
&
aContentType
nsACString
&
aContentCharset
bool
*
aHadCharset
int32_t
*
aCharsetStart
int32_t
*
aCharsetEnd
)
{
*
aHadCharset
=
false
;
const
nsCString
&
flatStr
=
PromiseFlatCString
(
aHeaderStr
)
;
uint32_t
curTypeStart
=
0
;
do
{
uint32_t
curTypeEnd
=
net_FindMediaDelimiter
(
flatStr
curTypeStart
'
'
)
;
net_ParseMediaType
(
Substring
(
flatStr
curTypeStart
curTypeEnd
-
curTypeStart
)
aContentType
aContentCharset
curTypeStart
aHadCharset
aCharsetStart
aCharsetEnd
false
)
;
curTypeStart
=
curTypeEnd
+
1
;
}
while
(
curTypeStart
<
flatStr
.
Length
(
)
)
;
}
void
net_ParseRequestContentType
(
const
nsACString
&
aHeaderStr
nsACString
&
aContentType
nsACString
&
aContentCharset
bool
*
aHadCharset
)
{
aContentType
.
Truncate
(
)
;
aContentCharset
.
Truncate
(
)
;
*
aHadCharset
=
false
;
const
nsCString
&
flatStr
=
PromiseFlatCString
(
aHeaderStr
)
;
nsAutoCString
contentType
contentCharset
;
bool
hadCharset
=
false
;
int32_t
dummy1
dummy2
;
uint32_t
typeEnd
=
net_FindMediaDelimiter
(
flatStr
0
'
'
)
;
if
(
typeEnd
!
=
flatStr
.
Length
(
)
)
{
return
;
}
net_ParseMediaType
(
flatStr
contentType
contentCharset
0
&
hadCharset
&
dummy1
&
dummy2
true
)
;
aContentType
=
contentType
;
aContentCharset
=
contentCharset
;
*
aHadCharset
=
hadCharset
;
}
bool
net_IsValidHostName
(
const
nsACString
&
host
)
{
const
char
*
end
=
host
.
EndReading
(
)
;
if
(
net_FindCharNotInSet
(
host
.
BeginReading
(
)
end
"
abcdefghijklmnopqrstuvwxyz
"
"
.
-
0123456789
"
"
ABCDEFGHIJKLMNOPQRSTUVWXYZ
+
_
"
)
=
=
end
)
return
true
;
nsAutoCString
strhost
(
host
)
;
PRNetAddr
addr
;
return
PR_StringToNetAddr
(
strhost
.
get
(
)
&
addr
)
=
=
PR_SUCCESS
;
}
bool
net_IsValidIPv4Addr
(
const
nsACString
&
aAddr
)
{
return
rust_net_is_valid_ipv4_addr
(
aAddr
)
;
}
bool
net_IsValidIPv6Addr
(
const
nsACString
&
aAddr
)
{
return
rust_net_is_valid_ipv6_addr
(
aAddr
)
;
}
