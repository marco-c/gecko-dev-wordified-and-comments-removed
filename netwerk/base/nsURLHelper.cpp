#
include
"
mozilla
/
RangedPtr
.
h
"
#
include
"
nsURLHelper
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsIURLParser
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
prnetdb
.
h
"
#
include
"
mozilla
/
Tokenizer
.
h
"
using
namespace
mozilla
;
static
bool
gInitialized
=
false
;
static
nsIURLParser
*
gNoAuthURLParser
=
nullptr
;
static
nsIURLParser
*
gAuthURLParser
=
nullptr
;
static
nsIURLParser
*
gStdURLParser
=
nullptr
;
static
int32_t
gMaxLength
=
1048576
;
static
void
InitGlobals
(
)
{
nsCOMPtr
<
nsIURLParser
>
parser
;
parser
=
do_GetService
(
NS_NOAUTHURLPARSER_CONTRACTID
)
;
NS_ASSERTION
(
parser
"
failed
getting
'
noauth
'
url
parser
"
)
;
if
(
parser
)
{
gNoAuthURLParser
=
parser
.
get
(
)
;
NS_ADDREF
(
gNoAuthURLParser
)
;
}
parser
=
do_GetService
(
NS_AUTHURLPARSER_CONTRACTID
)
;
NS_ASSERTION
(
parser
"
failed
getting
'
auth
'
url
parser
"
)
;
if
(
parser
)
{
gAuthURLParser
=
parser
.
get
(
)
;
NS_ADDREF
(
gAuthURLParser
)
;
}
parser
=
do_GetService
(
NS_STDURLPARSER_CONTRACTID
)
;
NS_ASSERTION
(
parser
"
failed
getting
'
std
'
url
parser
"
)
;
if
(
parser
)
{
gStdURLParser
=
parser
.
get
(
)
;
NS_ADDREF
(
gStdURLParser
)
;
}
gInitialized
=
true
;
#
if
!
defined
(
MOZILLA_XPCOMRT_API
)
Preferences
:
:
AddIntVarCache
(
&
gMaxLength
"
network
.
standard
-
url
.
max
-
length
"
1048576
)
;
#
endif
}
void
net_ShutdownURLHelper
(
)
{
if
(
gInitialized
)
{
NS_IF_RELEASE
(
gNoAuthURLParser
)
;
NS_IF_RELEASE
(
gAuthURLParser
)
;
NS_IF_RELEASE
(
gStdURLParser
)
;
gInitialized
=
false
;
}
}
int32_t
net_GetURLMaxLength
(
)
{
return
gMaxLength
;
}
nsIURLParser
*
net_GetAuthURLParser
(
)
{
if
(
!
gInitialized
)
InitGlobals
(
)
;
return
gAuthURLParser
;
}
nsIURLParser
*
net_GetNoAuthURLParser
(
)
{
if
(
!
gInitialized
)
InitGlobals
(
)
;
return
gNoAuthURLParser
;
}
nsIURLParser
*
net_GetStdURLParser
(
)
{
if
(
!
gInitialized
)
InitGlobals
(
)
;
return
gStdURLParser
;
}
nsresult
net_GetURLSpecFromDir
(
nsIFile
*
aFile
nsACString
&
result
)
{
#
if
defined
(
MOZILLA_XPCOMRT_API
)
NS_WARNING
(
"
net_GetURLSpecFromDir
not
implemented
"
)
;
return
NS_ERROR_NOT_IMPLEMENTED
;
#
else
nsAutoCString
escPath
;
nsresult
rv
=
net_GetURLSpecFromActualFile
(
aFile
escPath
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
if
(
escPath
.
Last
(
)
!
=
'
/
'
)
{
escPath
+
=
'
/
'
;
}
result
=
escPath
;
return
NS_OK
;
#
endif
}
nsresult
net_GetURLSpecFromFile
(
nsIFile
*
aFile
nsACString
&
result
)
{
#
if
defined
(
MOZILLA_XPCOMRT_API
)
NS_WARNING
(
"
net_GetURLSpecFromFile
not
implemented
"
)
;
return
NS_ERROR_NOT_IMPLEMENTED
;
#
else
nsAutoCString
escPath
;
nsresult
rv
=
net_GetURLSpecFromActualFile
(
aFile
escPath
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
if
(
escPath
.
Last
(
)
!
=
'
/
'
)
{
bool
dir
;
rv
=
aFile
-
>
IsDirectory
(
&
dir
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
dir
)
escPath
+
=
'
/
'
;
}
result
=
escPath
;
return
NS_OK
;
#
endif
}
nsresult
net_ParseFileURL
(
const
nsACString
&
inURL
nsACString
&
outDirectory
nsACString
&
outFileBaseName
nsACString
&
outFileExtension
)
{
nsresult
rv
;
if
(
inURL
.
Length
(
)
>
(
uint32_t
)
gMaxLength
)
{
return
NS_ERROR_MALFORMED_URI
;
}
outDirectory
.
Truncate
(
)
;
outFileBaseName
.
Truncate
(
)
;
outFileExtension
.
Truncate
(
)
;
const
nsPromiseFlatCString
&
flatURL
=
PromiseFlatCString
(
inURL
)
;
const
char
*
url
=
flatURL
.
get
(
)
;
nsAutoCString
scheme
;
rv
=
net_ExtractURLScheme
(
flatURL
scheme
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
if
(
!
scheme
.
EqualsLiteral
(
"
file
"
)
)
{
NS_ERROR
(
"
must
be
a
file
:
/
/
url
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
nsIURLParser
*
parser
=
net_GetNoAuthURLParser
(
)
;
NS_ENSURE_TRUE
(
parser
NS_ERROR_UNEXPECTED
)
;
uint32_t
pathPos
filepathPos
directoryPos
basenamePos
extensionPos
;
int32_t
pathLen
filepathLen
directoryLen
basenameLen
extensionLen
;
rv
=
parser
-
>
ParseURL
(
url
flatURL
.
Length
(
)
nullptr
nullptr
nullptr
nullptr
&
pathPos
&
pathLen
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
rv
=
parser
-
>
ParsePath
(
url
+
pathPos
pathLen
&
filepathPos
&
filepathLen
nullptr
nullptr
nullptr
nullptr
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
filepathPos
+
=
pathPos
;
rv
=
parser
-
>
ParseFilePath
(
url
+
filepathPos
filepathLen
&
directoryPos
&
directoryLen
&
basenamePos
&
basenameLen
&
extensionPos
&
extensionLen
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
if
(
directoryLen
>
0
)
outDirectory
=
Substring
(
inURL
filepathPos
+
directoryPos
directoryLen
)
;
if
(
basenameLen
>
0
)
outFileBaseName
=
Substring
(
inURL
filepathPos
+
basenamePos
basenameLen
)
;
if
(
extensionLen
>
0
)
outFileExtension
=
Substring
(
inURL
filepathPos
+
extensionPos
extensionLen
)
;
return
NS_OK
;
}
void
net_CoalesceDirs
(
netCoalesceFlags
flags
char
*
path
)
{
char
*
fwdPtr
=
path
;
char
*
urlPtr
=
path
;
char
*
endPath
=
path
;
uint32_t
traversal
=
0
;
uint32_t
special_ftp_len
=
0
;
if
(
flags
&
NET_COALESCE_DOUBLE_SLASH_IS_ROOT
)
{
if
(
nsCRT
:
:
strncasecmp
(
path
"
/
%
2F
"
4
)
=
=
0
)
special_ftp_len
=
4
;
else
if
(
nsCRT
:
:
strncmp
(
path
"
/
/
"
2
)
=
=
0
)
special_ftp_len
=
2
;
}
for
(
;
(
*
fwdPtr
!
=
'
\
0
'
)
&
&
(
*
fwdPtr
!
=
'
?
'
)
&
&
(
*
fwdPtr
!
=
'
#
'
)
;
+
+
fwdPtr
)
{
}
endPath
=
fwdPtr
;
fwdPtr
=
path
;
for
(
;
fwdPtr
!
=
endPath
;
+
+
fwdPtr
)
{
if
(
*
fwdPtr
=
=
'
%
'
&
&
*
(
fwdPtr
+
1
)
=
=
'
2
'
&
&
(
*
(
fwdPtr
+
2
)
=
=
'
E
'
|
|
*
(
fwdPtr
+
2
)
=
=
'
e
'
)
)
{
*
urlPtr
+
+
=
'
.
'
;
+
+
fwdPtr
;
+
+
fwdPtr
;
}
else
{
*
urlPtr
+
+
=
*
fwdPtr
;
}
}
for
(
;
*
fwdPtr
!
=
'
\
0
'
;
+
+
fwdPtr
)
{
*
urlPtr
+
+
=
*
fwdPtr
;
}
*
urlPtr
=
'
\
0
'
;
fwdPtr
=
path
;
urlPtr
=
path
;
for
(
;
(
*
fwdPtr
!
=
'
\
0
'
)
&
&
(
*
fwdPtr
!
=
'
?
'
)
&
&
(
*
fwdPtr
!
=
'
#
'
)
;
+
+
fwdPtr
)
{
if
(
*
fwdPtr
=
=
'
/
'
&
&
*
(
fwdPtr
+
1
)
=
=
'
.
'
&
&
*
(
fwdPtr
+
2
)
=
=
'
/
'
)
{
+
+
fwdPtr
;
}
else
if
(
*
fwdPtr
=
=
'
/
'
&
&
*
(
fwdPtr
+
1
)
=
=
'
.
'
&
&
*
(
fwdPtr
+
2
)
=
=
'
.
'
&
&
(
*
(
fwdPtr
+
3
)
=
=
'
/
'
|
|
*
(
fwdPtr
+
3
)
=
=
'
\
0
'
|
|
*
(
fwdPtr
+
3
)
=
=
'
?
'
|
|
*
(
fwdPtr
+
3
)
=
=
'
#
'
)
)
{
if
(
traversal
>
0
|
|
!
(
flags
&
NET_COALESCE_ALLOW_RELATIVE_ROOT
)
)
{
if
(
urlPtr
!
=
path
)
urlPtr
-
-
;
for
(
;
*
urlPtr
!
=
'
/
'
&
&
urlPtr
!
=
path
;
urlPtr
-
-
)
;
-
-
traversal
;
fwdPtr
+
=
2
;
if
(
urlPtr
=
=
path
&
&
special_ftp_len
>
3
)
{
+
+
urlPtr
;
+
+
urlPtr
;
+
+
urlPtr
;
}
if
(
*
fwdPtr
=
=
'
.
'
&
&
*
(
fwdPtr
+
1
)
=
=
'
\
0
'
)
+
+
urlPtr
;
}
else
{
if
(
special_ftp_len
>
3
&
&
urlPtr
=
=
path
+
special_ftp_len
-
1
)
+
+
urlPtr
;
else
*
urlPtr
+
+
=
*
fwdPtr
;
+
+
fwdPtr
;
*
urlPtr
+
+
=
*
fwdPtr
;
+
+
fwdPtr
;
*
urlPtr
+
+
=
*
fwdPtr
;
}
}
else
{
if
(
*
fwdPtr
=
=
'
/
'
&
&
*
(
fwdPtr
+
1
)
!
=
'
.
'
&
&
(
special_ftp_len
!
=
2
|
|
*
(
fwdPtr
+
1
)
!
=
'
/
'
)
)
traversal
+
+
;
*
urlPtr
+
+
=
*
fwdPtr
;
}
}
if
(
(
urlPtr
>
(
path
+
1
)
)
&
&
(
*
(
urlPtr
-
1
)
=
=
'
.
'
)
&
&
(
*
(
urlPtr
-
2
)
=
=
'
/
'
)
)
urlPtr
-
-
;
for
(
;
*
fwdPtr
!
=
'
\
0
'
;
+
+
fwdPtr
)
{
*
urlPtr
+
+
=
*
fwdPtr
;
}
*
urlPtr
=
'
\
0
'
;
}
nsresult
net_ResolveRelativePath
(
const
nsACString
&
relativePath
const
nsACString
&
basePath
nsACString
&
result
)
{
nsAutoCString
name
;
nsAutoCString
path
(
basePath
)
;
bool
needsDelim
=
false
;
if
(
!
path
.
IsEmpty
(
)
)
{
char16_t
last
=
path
.
Last
(
)
;
needsDelim
=
!
(
last
=
=
'
/
'
)
;
}
nsACString
:
:
const_iterator
beg
end
;
relativePath
.
BeginReading
(
beg
)
;
relativePath
.
EndReading
(
end
)
;
bool
stop
=
false
;
char
c
;
for
(
;
!
stop
;
+
+
beg
)
{
c
=
(
beg
=
=
end
)
?
'
\
0
'
:
*
beg
;
switch
(
c
)
{
case
'
\
0
'
:
case
'
#
'
:
case
'
?
'
:
stop
=
true
;
MOZ_FALLTHROUGH
;
case
'
/
'
:
if
(
name
.
EqualsLiteral
(
"
.
.
"
)
)
{
int32_t
offset
=
path
.
Length
(
)
-
(
needsDelim
?
1
:
2
)
;
if
(
offset
<
0
)
return
NS_ERROR_MALFORMED_URI
;
int32_t
pos
=
path
.
RFind
(
"
/
"
false
offset
)
;
if
(
pos
>
=
0
)
path
.
Truncate
(
pos
+
1
)
;
else
path
.
Truncate
(
)
;
}
else
if
(
name
.
IsEmpty
(
)
|
|
name
.
EqualsLiteral
(
"
.
"
)
)
{
}
else
{
if
(
needsDelim
)
path
+
=
'
/
'
;
path
+
=
name
;
needsDelim
=
true
;
}
name
.
Truncate
(
)
;
break
;
default
:
name
+
=
c
;
}
}
if
(
c
!
=
'
\
0
'
)
path
+
=
Substring
(
-
-
beg
end
)
;
result
=
path
;
return
NS_OK
;
}
#
if
!
defined
(
MOZILLA_XPCOMRT_API
)
static
bool
isAsciiAlpha
(
char
c
)
{
return
nsCRT
:
:
IsAsciiAlpha
(
c
)
;
}
static
bool
net_IsValidSchemeChar
(
const
char
aChar
)
{
if
(
nsCRT
:
:
IsAsciiAlpha
(
aChar
)
|
|
nsCRT
:
:
IsAsciiDigit
(
aChar
)
|
|
aChar
=
=
'
+
'
|
|
aChar
=
=
'
.
'
|
|
aChar
=
=
'
-
'
)
{
return
true
;
}
return
false
;
}
#
endif
nsresult
net_ExtractURLScheme
(
const
nsACString
&
inURI
nsACString
&
scheme
)
{
#
if
defined
(
MOZILLA_XPCOMRT_API
)
NS_WARNING
(
"
net_ExtractURLScheme
not
implemented
"
)
;
return
NS_ERROR_NOT_IMPLEMENTED
;
#
else
Tokenizer
p
(
inURI
"
\
r
\
n
\
t
"
)
;
while
(
p
.
CheckWhite
(
)
|
|
p
.
CheckChar
(
'
'
)
)
{
}
p
.
Record
(
)
;
if
(
!
p
.
CheckChar
(
isAsciiAlpha
)
)
{
return
NS_ERROR_MALFORMED_URI
;
}
while
(
p
.
CheckChar
(
net_IsValidSchemeChar
)
|
|
p
.
CheckWhite
(
)
)
{
}
if
(
!
p
.
CheckChar
(
'
:
'
)
)
{
return
NS_ERROR_MALFORMED_URI
;
}
p
.
Claim
(
scheme
)
;
scheme
.
StripChars
(
"
\
r
\
n
\
t
"
)
;
return
NS_OK
;
#
endif
}
bool
net_IsValidScheme
(
const
char
*
scheme
uint32_t
schemeLen
)
{
if
(
!
nsCRT
:
:
IsAsciiAlpha
(
*
scheme
)
)
return
false
;
for
(
;
schemeLen
;
+
+
scheme
-
-
schemeLen
)
{
if
(
!
(
nsCRT
:
:
IsAsciiAlpha
(
*
scheme
)
|
|
nsCRT
:
:
IsAsciiDigit
(
*
scheme
)
|
|
*
scheme
=
=
'
+
'
|
|
*
scheme
=
=
'
.
'
|
|
*
scheme
=
=
'
-
'
)
)
return
false
;
}
return
true
;
}
bool
net_IsAbsoluteURL
(
const
nsACString
&
uri
)
{
#
if
!
defined
(
MOZILLA_XPCOMRT_API
)
Tokenizer
p
(
uri
"
\
r
\
n
\
t
"
)
;
while
(
p
.
CheckWhite
(
)
|
|
p
.
CheckChar
(
'
'
)
)
{
}
if
(
!
p
.
CheckChar
(
isAsciiAlpha
)
)
{
return
false
;
}
while
(
p
.
CheckChar
(
net_IsValidSchemeChar
)
|
|
p
.
CheckWhite
(
)
)
{
}
if
(
!
p
.
CheckChar
(
'
:
'
)
)
{
return
false
;
}
p
.
SkipWhites
(
)
;
if
(
!
p
.
CheckChar
(
'
/
'
)
)
{
return
false
;
}
p
.
SkipWhites
(
)
;
if
(
p
.
CheckChar
(
'
/
'
)
)
{
return
true
;
}
#
endif
return
false
;
}
bool
net_FilterURIString
(
const
char
*
str
nsACString
&
result
)
{
NS_PRECONDITION
(
str
"
Must
have
a
non
-
null
string
!
"
)
;
result
.
Truncate
(
)
;
const
char
*
p
=
str
;
bool
writing
=
false
;
while
(
*
p
)
{
if
(
*
p
=
=
'
'
|
|
*
p
=
=
'
\
t
'
|
|
*
p
=
=
'
\
r
'
|
|
*
p
=
=
'
\
n
'
)
{
writing
=
true
;
break
;
}
p
+
+
;
}
if
(
!
writing
)
{
return
false
;
}
nsAutoCString
temp
;
temp
.
Assign
(
str
)
;
temp
.
Trim
(
"
\
r
\
n
\
t
"
)
;
temp
.
StripChars
(
"
\
r
\
n
\
t
"
)
;
result
.
Assign
(
temp
)
;
return
true
;
}
#
if
defined
(
XP_WIN
)
bool
net_NormalizeFileURL
(
const
nsACString
&
aURL
nsCString
&
aResultBuf
)
{
bool
writing
=
false
;
nsACString
:
:
const_iterator
beginIter
endIter
;
aURL
.
BeginReading
(
beginIter
)
;
aURL
.
EndReading
(
endIter
)
;
const
char
*
s
*
begin
=
beginIter
.
get
(
)
;
for
(
s
=
begin
;
s
!
=
endIter
.
get
(
)
;
+
+
s
)
{
if
(
*
s
=
=
'
\
\
'
)
{
writing
=
true
;
if
(
s
>
begin
)
aResultBuf
.
Append
(
begin
s
-
begin
)
;
aResultBuf
+
=
'
/
'
;
begin
=
s
+
1
;
}
}
if
(
writing
&
&
s
>
begin
)
aResultBuf
.
Append
(
begin
s
-
begin
)
;
return
writing
;
}
#
endif
static
inline
void
ToLower
(
char
&
c
)
{
if
(
(
unsigned
)
(
c
-
'
A
'
)
<
=
(
unsigned
)
(
'
Z
'
-
'
A
'
)
)
c
+
=
'
a
'
-
'
A
'
;
}
void
net_ToLowerCase
(
char
*
str
uint32_t
length
)
{
for
(
char
*
end
=
str
+
length
;
str
<
end
;
+
+
str
)
ToLower
(
*
str
)
;
}
void
net_ToLowerCase
(
char
*
str
)
{
for
(
;
*
str
;
+
+
str
)
ToLower
(
*
str
)
;
}
char
*
net_FindCharInSet
(
const
char
*
iter
const
char
*
stop
const
char
*
set
)
{
for
(
;
iter
!
=
stop
&
&
*
iter
;
+
+
iter
)
{
for
(
const
char
*
s
=
set
;
*
s
;
+
+
s
)
{
if
(
*
iter
=
=
*
s
)
return
(
char
*
)
iter
;
}
}
return
(
char
*
)
iter
;
}
char
*
net_FindCharNotInSet
(
const
char
*
iter
const
char
*
stop
const
char
*
set
)
{
repeat
:
for
(
const
char
*
s
=
set
;
*
s
;
+
+
s
)
{
if
(
*
iter
=
=
*
s
)
{
if
(
+
+
iter
=
=
stop
)
break
;
goto
repeat
;
}
}
return
(
char
*
)
iter
;
}
char
*
net_RFindCharNotInSet
(
const
char
*
stop
const
char
*
iter
const
char
*
set
)
{
-
-
iter
;
-
-
stop
;
if
(
iter
=
=
stop
)
return
(
char
*
)
iter
;
repeat
:
for
(
const
char
*
s
=
set
;
*
s
;
+
+
s
)
{
if
(
*
iter
=
=
*
s
)
{
if
(
-
-
iter
=
=
stop
)
break
;
goto
repeat
;
}
}
return
(
char
*
)
iter
;
}
#
define
HTTP_LWS
"
\
t
"
static
uint32_t
net_FindStringEnd
(
const
nsCString
&
flatStr
uint32_t
stringStart
char
stringDelim
)
{
NS_ASSERTION
(
stringStart
<
flatStr
.
Length
(
)
&
&
flatStr
.
CharAt
(
stringStart
)
=
=
stringDelim
&
&
(
stringDelim
=
=
'
"
'
|
|
stringDelim
=
=
'
\
'
'
)
"
Invalid
stringStart
"
)
;
const
char
set
[
]
=
{
stringDelim
'
\
\
'
'
\
0
'
}
;
do
{
uint32_t
stringEnd
=
flatStr
.
FindCharInSet
(
set
stringStart
+
1
)
;
if
(
stringEnd
=
=
uint32_t
(
kNotFound
)
)
return
flatStr
.
Length
(
)
;
if
(
flatStr
.
CharAt
(
stringEnd
)
=
=
'
\
\
'
)
{
stringStart
=
stringEnd
+
1
;
if
(
stringStart
=
=
flatStr
.
Length
(
)
)
return
stringStart
;
continue
;
}
return
stringEnd
;
}
while
(
true
)
;
NS_NOTREACHED
(
"
How
did
we
get
here
?
"
)
;
return
flatStr
.
Length
(
)
;
}
static
uint32_t
net_FindMediaDelimiter
(
const
nsCString
&
flatStr
uint32_t
searchStart
char
delimiter
)
{
do
{
const
char
delimStr
[
]
=
{
delimiter
'
"
'
'
\
0
'
}
;
uint32_t
curDelimPos
=
flatStr
.
FindCharInSet
(
delimStr
searchStart
)
;
if
(
curDelimPos
=
=
uint32_t
(
kNotFound
)
)
return
flatStr
.
Length
(
)
;
char
ch
=
flatStr
.
CharAt
(
curDelimPos
)
;
if
(
ch
=
=
delimiter
)
{
return
curDelimPos
;
}
searchStart
=
net_FindStringEnd
(
flatStr
curDelimPos
ch
)
;
if
(
searchStart
=
=
flatStr
.
Length
(
)
)
return
searchStart
;
+
+
searchStart
;
}
while
(
true
)
;
NS_NOTREACHED
(
"
How
did
we
get
here
?
"
)
;
return
flatStr
.
Length
(
)
;
}
static
void
net_ParseMediaType
(
const
nsACString
&
aMediaTypeStr
nsACString
&
aContentType
nsACString
&
aContentCharset
int32_t
aOffset
bool
*
aHadCharset
int32_t
*
aCharsetStart
int32_t
*
aCharsetEnd
bool
aStrict
)
{
const
nsCString
&
flatStr
=
PromiseFlatCString
(
aMediaTypeStr
)
;
const
char
*
start
=
flatStr
.
get
(
)
;
const
char
*
end
=
start
+
flatStr
.
Length
(
)
;
const
char
*
type
=
net_FindCharNotInSet
(
start
end
HTTP_LWS
)
;
const
char
*
typeEnd
=
net_FindCharInSet
(
type
end
HTTP_LWS
"
;
(
"
)
;
const
char
*
charset
=
"
"
;
const
char
*
charsetEnd
=
charset
;
int32_t
charsetParamStart
=
0
;
int32_t
charsetParamEnd
=
0
;
uint32_t
consumed
=
typeEnd
-
type
;
bool
typeHasCharset
=
false
;
uint32_t
paramStart
=
flatStr
.
FindChar
(
'
;
'
typeEnd
-
start
)
;
if
(
paramStart
!
=
uint32_t
(
kNotFound
)
)
{
uint32_t
curParamStart
=
paramStart
+
1
;
do
{
uint32_t
curParamEnd
=
net_FindMediaDelimiter
(
flatStr
curParamStart
'
;
'
)
;
const
char
*
paramName
=
net_FindCharNotInSet
(
start
+
curParamStart
start
+
curParamEnd
HTTP_LWS
)
;
static
const
char
charsetStr
[
]
=
"
charset
=
"
;
if
(
PL_strncasecmp
(
paramName
charsetStr
sizeof
(
charsetStr
)
-
1
)
=
=
0
)
{
charset
=
paramName
+
sizeof
(
charsetStr
)
-
1
;
charsetEnd
=
start
+
curParamEnd
;
typeHasCharset
=
true
;
charsetParamStart
=
curParamStart
-
1
;
charsetParamEnd
=
curParamEnd
;
}
consumed
=
curParamEnd
;
curParamStart
=
curParamEnd
+
1
;
}
while
(
curParamStart
<
flatStr
.
Length
(
)
)
;
}
bool
charsetNeedsQuotedStringUnescaping
=
false
;
if
(
typeHasCharset
)
{
charset
=
net_FindCharNotInSet
(
charset
charsetEnd
HTTP_LWS
)
;
if
(
*
charset
=
=
'
"
'
)
{
charsetNeedsQuotedStringUnescaping
=
true
;
charsetEnd
=
start
+
net_FindStringEnd
(
flatStr
charset
-
start
*
charset
)
;
charset
+
+
;
NS_ASSERTION
(
charsetEnd
>
=
charset
"
Bad
charset
parsing
"
)
;
}
else
{
charsetEnd
=
net_FindCharInSet
(
charset
charsetEnd
HTTP_LWS
"
;
(
"
)
;
}
}
if
(
type
!
=
typeEnd
&
&
memchr
(
type
'
/
'
typeEnd
-
type
)
!
=
nullptr
&
&
(
aStrict
?
(
net_FindCharNotInSet
(
start
+
consumed
end
HTTP_LWS
)
=
=
end
)
:
(
strncmp
(
type
"
*
/
*
"
typeEnd
-
type
)
!
=
0
)
)
)
{
bool
eq
=
!
aContentType
.
IsEmpty
(
)
&
&
aContentType
.
Equals
(
Substring
(
type
typeEnd
)
nsCaseInsensitiveCStringComparator
(
)
)
;
if
(
!
eq
)
{
aContentType
.
Assign
(
type
typeEnd
-
type
)
;
ToLowerCase
(
aContentType
)
;
}
if
(
(
!
eq
&
&
*
aHadCharset
)
|
|
typeHasCharset
)
{
*
aHadCharset
=
true
;
if
(
charsetNeedsQuotedStringUnescaping
)
{
aContentCharset
.
Truncate
(
)
;
for
(
const
char
*
c
=
charset
;
c
!
=
charsetEnd
;
c
+
+
)
{
if
(
*
c
=
=
'
\
\
'
&
&
c
+
1
!
=
charsetEnd
)
{
c
+
+
;
}
aContentCharset
.
Append
(
*
c
)
;
}
}
else
{
aContentCharset
.
Assign
(
charset
charsetEnd
-
charset
)
;
}
if
(
typeHasCharset
)
{
*
aCharsetStart
=
charsetParamStart
+
aOffset
;
*
aCharsetEnd
=
charsetParamEnd
+
aOffset
;
}
}
if
(
!
eq
&
&
!
typeHasCharset
)
{
int32_t
charsetStart
=
int32_t
(
paramStart
)
;
if
(
charsetStart
=
=
kNotFound
)
charsetStart
=
flatStr
.
Length
(
)
;
*
aCharsetEnd
=
*
aCharsetStart
=
charsetStart
+
aOffset
;
}
}
}
#
undef
HTTP_LWS
void
net_ParseContentType
(
const
nsACString
&
aHeaderStr
nsACString
&
aContentType
nsACString
&
aContentCharset
bool
*
aHadCharset
)
{
int32_t
dummy1
dummy2
;
net_ParseContentType
(
aHeaderStr
aContentType
aContentCharset
aHadCharset
&
dummy1
&
dummy2
)
;
}
void
net_ParseContentType
(
const
nsACString
&
aHeaderStr
nsACString
&
aContentType
nsACString
&
aContentCharset
bool
*
aHadCharset
int32_t
*
aCharsetStart
int32_t
*
aCharsetEnd
)
{
*
aHadCharset
=
false
;
const
nsCString
&
flatStr
=
PromiseFlatCString
(
aHeaderStr
)
;
uint32_t
curTypeStart
=
0
;
do
{
uint32_t
curTypeEnd
=
net_FindMediaDelimiter
(
flatStr
curTypeStart
'
'
)
;
net_ParseMediaType
(
Substring
(
flatStr
curTypeStart
curTypeEnd
-
curTypeStart
)
aContentType
aContentCharset
curTypeStart
aHadCharset
aCharsetStart
aCharsetEnd
false
)
;
curTypeStart
=
curTypeEnd
+
1
;
}
while
(
curTypeStart
<
flatStr
.
Length
(
)
)
;
}
void
net_ParseRequestContentType
(
const
nsACString
&
aHeaderStr
nsACString
&
aContentType
nsACString
&
aContentCharset
bool
*
aHadCharset
)
{
aContentType
.
Truncate
(
)
;
aContentCharset
.
Truncate
(
)
;
*
aHadCharset
=
false
;
const
nsCString
&
flatStr
=
PromiseFlatCString
(
aHeaderStr
)
;
nsAutoCString
contentType
contentCharset
;
bool
hadCharset
=
false
;
int32_t
dummy1
dummy2
;
uint32_t
typeEnd
=
net_FindMediaDelimiter
(
flatStr
0
'
'
)
;
if
(
typeEnd
!
=
flatStr
.
Length
(
)
)
{
return
;
}
net_ParseMediaType
(
flatStr
contentType
contentCharset
0
&
hadCharset
&
dummy1
&
dummy2
true
)
;
aContentType
=
contentType
;
aContentCharset
=
contentCharset
;
*
aHadCharset
=
hadCharset
;
}
bool
net_IsValidHostName
(
const
nsCSubstring
&
host
)
{
const
char
*
end
=
host
.
EndReading
(
)
;
if
(
net_FindCharNotInSet
(
host
.
BeginReading
(
)
end
"
abcdefghijklmnopqrstuvwxyz
"
"
.
-
0123456789
"
"
ABCDEFGHIJKLMNOPQRSTUVWXYZ
+
_
"
)
=
=
end
)
return
true
;
nsAutoCString
strhost
(
host
)
;
PRNetAddr
addr
;
return
PR_StringToNetAddr
(
strhost
.
get
(
)
&
addr
)
=
=
PR_SUCCESS
;
}
bool
net_IsValidIPv4Addr
(
const
char
*
addr
int32_t
addrLen
)
{
RangedPtr
<
const
char
>
p
(
addr
addrLen
)
;
int32_t
octet
=
-
1
;
int32_t
dotCount
=
0
;
for
(
;
addrLen
;
+
+
p
-
-
addrLen
)
{
if
(
*
p
=
=
'
.
'
)
{
dotCount
+
+
;
if
(
octet
=
=
-
1
)
{
return
false
;
}
octet
=
-
1
;
}
else
if
(
*
p
>
=
'
0
'
&
&
*
p
<
=
'
9
'
)
{
if
(
octet
=
=
0
)
{
return
false
;
}
else
if
(
octet
=
=
-
1
)
{
octet
=
*
p
-
'
0
'
;
}
else
{
octet
*
=
10
;
octet
+
=
*
p
-
'
0
'
;
if
(
octet
>
255
)
return
false
;
}
}
else
{
return
false
;
}
}
return
(
dotCount
=
=
3
&
&
octet
!
=
-
1
)
;
}
bool
net_IsValidIPv6Addr
(
const
char
*
addr
int32_t
addrLen
)
{
RangedPtr
<
const
char
>
p
(
addr
addrLen
)
;
int32_t
digits
=
0
;
int32_t
colons
=
0
;
int32_t
blocks
=
0
;
bool
haveZeros
=
false
;
for
(
;
addrLen
;
+
+
p
-
-
addrLen
)
{
if
(
*
p
=
=
'
:
'
)
{
if
(
colons
=
=
0
)
{
if
(
digits
!
=
0
)
{
digits
=
0
;
blocks
+
+
;
}
}
else
if
(
colons
=
=
1
)
{
if
(
haveZeros
)
return
false
;
haveZeros
=
true
;
}
else
{
return
false
;
}
colons
+
+
;
}
else
if
(
(
*
p
>
=
'
0
'
&
&
*
p
<
=
'
9
'
)
|
|
(
*
p
>
=
'
a
'
&
&
*
p
<
=
'
f
'
)
|
|
(
*
p
>
=
'
A
'
&
&
*
p
<
=
'
F
'
)
)
{
if
(
colons
=
=
1
&
&
blocks
=
=
0
)
return
false
;
if
(
digits
=
=
4
)
return
false
;
colons
=
0
;
digits
+
+
;
}
else
if
(
*
p
=
=
'
.
'
)
{
if
(
!
net_IsValidIPv4Addr
(
p
.
get
(
)
-
digits
addrLen
+
digits
)
)
return
false
;
return
(
haveZeros
&
&
blocks
<
6
)
|
|
(
!
haveZeros
&
&
blocks
=
=
6
)
;
}
else
{
return
false
;
}
}
if
(
colons
=
=
1
)
return
false
;
if
(
digits
)
blocks
+
+
;
return
(
haveZeros
&
&
blocks
<
8
)
|
|
(
!
haveZeros
&
&
blocks
=
=
8
)
;
}
