#
ifndef
nsProtocolProxyService_h__
#
define
nsProtocolProxyService_h__
#
include
"
nsString
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsIProtocolProxyService2
.
h
"
#
include
"
nsIProtocolProxyFilter
.
h
"
#
include
"
nsIProxyInfo
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsTHashMap
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
prio
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
class
nsIPrefBranch
;
class
nsISystemProxySettings
;
namespace
mozilla
{
namespace
net
{
using
nsFailedProxyTable
=
nsTHashMap
<
nsCStringHashKey
uint32_t
>
;
class
nsPACMan
;
class
nsProxyInfo
;
struct
nsProtocolInfo
;
#
define
NS_PROTOCOL_PROXY_SERVICE_IMPL_CID
\
{
0x091eedd8
0x8bae
0x4fe3
{
0xad
0x62
0x0c
0x87
0x35
0x1e
0x64
0x0d
}
}
class
nsProtocolProxyService
final
:
public
nsIProtocolProxyService2
public
nsIObserver
public
nsITimerCallback
public
nsINamed
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIPROTOCOLPROXYSERVICE2
NS_DECL_NSIPROTOCOLPROXYSERVICE
NS_DECL_NSIOBSERVER
NS_DECL_NSITIMERCALLBACK
NS_DECL_NSINAMED
NS_INLINE_DECL_STATIC_IID
(
NS_PROTOCOL_PROXY_SERVICE_IMPL_CID
)
nsProtocolProxyService
(
)
;
nsresult
Init
(
)
;
public
:
class
FilterLink
{
public
:
NS_INLINE_DECL_REFCOUNTING
(
FilterLink
)
uint32_t
position
;
nsCOMPtr
<
nsIProtocolProxyFilter
>
filter
;
nsCOMPtr
<
nsIProtocolProxyChannelFilter
>
channelFilter
;
FilterLink
(
uint32_t
p
nsIProtocolProxyFilter
*
f
)
;
FilterLink
(
uint32_t
p
nsIProtocolProxyChannelFilter
*
cf
)
;
private
:
~
FilterLink
(
)
;
}
;
protected
:
friend
class
nsAsyncResolveRequest
;
friend
class
TestProtocolProxyService_LoadHostFilters_Test
;
friend
class
AsyncApplyFilters
;
~
nsProtocolProxyService
(
)
;
void
PrefsChanged
(
nsIPrefBranch
*
prefBranch
const
char
*
pref
)
;
const
char
*
ExtractProxyInfo
(
const
char
*
start
uint32_t
aResolveFlags
nsProxyInfo
*
*
result
)
;
nsresult
ConfigureFromPAC
(
const
nsCString
&
spec
bool
forceReload
)
;
void
ProcessPACString
(
const
nsCString
&
pacString
uint32_t
aResolveFlags
nsIProxyInfo
*
*
result
)
;
void
GetProxyKey
(
nsProxyInfo
*
pi
nsCString
&
key
)
;
uint32_t
SecondsSinceSessionStart
(
)
;
void
EnableProxy
(
nsProxyInfo
*
pi
)
;
void
DisableProxy
(
nsProxyInfo
*
pi
)
;
bool
IsProxyDisabled
(
nsProxyInfo
*
pi
)
;
nsresult
GetProtocolInfo
(
nsIURI
*
uri
nsProtocolInfo
*
info
)
;
nsresult
NewProxyInfo_Internal
(
const
char
*
type
const
nsACString
&
host
int32_t
port
const
nsACString
&
username
const
nsACString
&
password
const
nsACString
&
aProxyAuthorizationHeader
const
nsACString
&
aConnectionIsolationKey
uint32_t
flags
uint32_t
timeout
nsIProxyInfo
*
aFailoverProxy
uint32_t
aResolveFlags
nsIProxyInfo
*
*
result
)
;
nsresult
Resolve_Internal
(
nsIChannel
*
channel
const
nsProtocolInfo
&
info
uint32_t
flags
bool
*
usePAC
nsIProxyInfo
*
*
result
)
;
void
CopyFilters
(
nsTArray
<
RefPtr
<
FilterLink
>
>
&
aCopy
)
;
bool
ApplyFilter
(
FilterLink
const
*
filterLink
nsIChannel
*
channel
const
nsProtocolInfo
&
info
nsCOMPtr
<
nsIProxyInfo
>
list
nsIProxyProtocolFilterResult
*
callback
)
;
void
PruneProxyInfo
(
const
nsProtocolInfo
&
info
nsIProxyInfo
*
*
list
)
;
void
PruneProxyInfo
(
const
nsProtocolInfo
&
info
nsCOMPtr
<
nsIProxyInfo
>
&
proxyInfo
)
{
nsIProxyInfo
*
pi
=
nullptr
;
proxyInfo
.
swap
(
pi
)
;
PruneProxyInfo
(
info
&
pi
)
;
proxyInfo
.
swap
(
pi
)
;
}
void
LoadHostFilters
(
const
nsACString
&
aFilters
)
;
bool
CanUseProxy
(
nsIURI
*
uri
int32_t
defaultPort
)
;
void
MaybeDisableDNSPrefetch
(
nsIProxyInfo
*
aProxy
)
;
private
:
nsresult
SetupPACThread
(
nsISerialEventTarget
*
mainThreadEventTarget
=
nullptr
)
;
nsresult
ResetPACThread
(
)
;
nsresult
ReloadNetworkPAC
(
)
;
nsresult
AsyncConfigureWPADOrFromPAC
(
bool
aForceReload
bool
aResetPACThread
bool
aSystemWPADAllowed
)
;
nsresult
OnAsyncGetPACURIOrSystemWPADSetting
(
bool
aForceReload
bool
aResetPACThread
nsresult
aResult
const
nsACString
&
aUri
bool
aSystemWPADSetting
)
;
static
void
CallOnProxyAvailableCallback
(
nsProtocolProxyService
*
aService
nsIProtocolProxyCallback
*
aCallback
nsICancelable
*
aRequest
nsIChannel
*
aChannel
nsIProxyInfo
*
aProxyInfo
nsresult
aStatus
)
;
public
:
struct
HostInfoIP
{
uint16_t
family
;
uint16_t
mask_len
;
PRIPv6Addr
addr
;
}
;
struct
HostInfoName
{
char
*
host
;
uint32_t
host_len
;
}
;
protected
:
struct
HostInfo
{
bool
is_ipaddr
{
false
}
;
int32_t
port
{
0
}
;
union
{
HostInfoIP
ip
;
HostInfoName
name
;
}
;
HostInfo
(
)
=
default
;
~
HostInfo
(
)
{
if
(
!
is_ipaddr
&
&
name
.
host
)
{
free
(
name
.
host
)
;
}
}
}
;
private
:
nsresult
InsertFilterLink
(
RefPtr
<
FilterLink
>
&
&
link
)
;
nsresult
RemoveFilterLink
(
nsISupports
*
givenObject
)
;
protected
:
bool
mFilterLocalHosts
{
false
}
;
nsTArray
<
UniquePtr
<
HostInfo
>
>
mHostFiltersArray
;
nsTArray
<
RefPtr
<
FilterLink
>
>
mFilters
;
nsTArray
<
nsCOMPtr
<
nsIProxyConfigChangedCallback
>
>
mProxyConfigChangedCallbacks
;
uint32_t
mProxyConfig
{
PROXYCONFIG_DIRECT
}
;
nsCString
mHTTPProxyHost
;
int32_t
mHTTPProxyPort
{
-
1
}
;
nsCString
mHTTPSProxyHost
;
int32_t
mHTTPSProxyPort
{
-
1
}
;
nsCString
mSOCKSProxyTarget
;
int32_t
mSOCKSProxyPort
{
-
1
}
;
int32_t
mSOCKSProxyVersion
{
nsIProxyInfo
:
:
SOCKS_V4
}
;
bool
mSOCKS4ProxyRemoteDNS
{
false
}
;
bool
mSOCKS5ProxyRemoteDNS
{
false
}
;
bool
mProxyOverTLS
{
true
}
;
bool
mWPADOverDHCPEnabled
{
false
}
;
RefPtr
<
nsPACMan
>
mPACMan
;
nsCOMPtr
<
nsISystemProxySettings
>
mSystemProxySettings
;
PRTime
mSessionStart
;
nsFailedProxyTable
mFailedProxies
;
int32_t
mFailedProxyTimeout
{
30
*
60
}
;
private
:
nsresult
AsyncResolveInternal
(
nsIChannel
*
channel
uint32_t
flags
nsIProtocolProxyCallback
*
callback
nsICancelable
*
*
result
bool
isSyncOK
nsISerialEventTarget
*
mainThreadEventTarget
)
;
const
char
*
SOCKSProxyType
(
)
;
bool
SOCKSRemoteDNS
(
)
;
bool
mIsShutdown
{
false
}
;
nsCOMPtr
<
nsITimer
>
mReloadPACTimer
;
}
;
}
}
#
endif
