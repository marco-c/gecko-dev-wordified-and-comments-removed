#
ifndef
nsSocketTransportService2_h__
#
define
nsSocketTransportService2_h__
#
include
"
PollableEvent
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
Tuple
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
net
/
DashboardTypes
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIDirectTaskDispatcher
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsIThreadInternal
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsPISocketTransportService
.
h
"
#
include
"
prinit
.
h
"
#
include
"
prinrval
.
h
"
class
nsASocketHandler
;
struct
PRPollDesc
;
class
nsIPrefBranch
;
namespace
mozilla
{
namespace
net
{
extern
LazyLogModule
gSocketTransportLog
;
#
define
SOCKET_LOG
(
args
)
MOZ_LOG
(
gSocketTransportLog
LogLevel
:
:
Debug
args
)
#
define
SOCKET_LOG1
(
args
)
MOZ_LOG
(
gSocketTransportLog
LogLevel
:
:
Error
args
)
#
define
SOCKET_LOG_ENABLED
(
)
MOZ_LOG_TEST
(
gSocketTransportLog
LogLevel
:
:
Debug
)
extern
LazyLogModule
gUDPSocketLog
;
#
define
UDPSOCKET_LOG
(
args
)
MOZ_LOG
(
gUDPSocketLog
LogLevel
:
:
Debug
args
)
#
define
UDPSOCKET_LOG_ENABLED
(
)
MOZ_LOG_TEST
(
gUDPSocketLog
LogLevel
:
:
Debug
)
#
define
NS_SOCKET_POLL_TIMEOUT
PR_INTERVAL_NO_TIMEOUT
static
const
int32_t
kMaxTCPKeepIdle
=
32767
;
static
const
int32_t
kMaxTCPKeepIntvl
=
32767
;
static
const
int32_t
kMaxTCPKeepCount
=
127
;
static
const
int32_t
kDefaultTCPKeepCount
=
#
if
defined
(
XP_WIN
)
10
;
#
elif
defined
(
XP_MACOSX
)
8
;
#
else
4
;
/
/
Specifiable
in
Linux
.
#
endif
class
LinkedRunnableEvent
final
:
public
LinkedListElement
<
LinkedRunnableEvent
>
{
public
:
explicit
LinkedRunnableEvent
(
nsIRunnable
*
event
)
:
mEvent
(
event
)
{
}
~
LinkedRunnableEvent
(
)
=
default
;
already_AddRefed
<
nsIRunnable
>
TakeEvent
(
)
{
return
mEvent
.
forget
(
)
;
}
private
:
nsCOMPtr
<
nsIRunnable
>
mEvent
;
}
;
class
nsSocketTransportService
final
:
public
nsPISocketTransportService
public
nsISerialEventTarget
public
nsIThreadObserver
public
nsIRunnable
public
nsIObserver
public
nsINamed
public
nsIDirectTaskDispatcher
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSPISOCKETTRANSPORTSERVICE
NS_DECL_NSISOCKETTRANSPORTSERVICE
NS_DECL_NSIROUTEDSOCKETTRANSPORTSERVICE
NS_DECL_NSIEVENTTARGET_FULL
NS_DECL_NSITHREADOBSERVER
NS_DECL_NSIRUNNABLE
NS_DECL_NSIOBSERVER
NS_DECL_NSINAMED
NS_DECL_NSIDIRECTTASKDISPATCHER
static
const
uint32_t
SOCKET_LIMIT_MIN
=
50U
;
nsSocketTransportService
(
)
;
static
uint32_t
gMaxCount
;
static
PRCallOnceType
gMaxCountInitOnce
;
static
PRStatus
DiscoverMaxCount
(
)
;
bool
CanAttachSocket
(
)
;
void
GetSocketConnections
(
nsTArray
<
SocketInfo
>
*
)
;
uint64_t
GetSentBytes
(
)
{
return
mSentBytesCount
;
}
uint64_t
GetReceivedBytes
(
)
{
return
mReceivedBytesCount
;
}
bool
IsKeepaliveEnabled
(
)
{
return
mKeepaliveEnabledPref
;
}
bool
IsTelemetryEnabledAndNotSleepPhase
(
)
;
PRIntervalTime
MaxTimeForPrClosePref
(
)
{
return
mMaxTimeForPrClosePref
;
}
void
SetNotTrustedMitmDetected
(
)
{
mNotTrustedMitmDetected
=
true
;
}
void
ApplyPortRemap
(
uint16_t
*
aPort
)
;
bool
UpdatePortRemapPreference
(
nsACString
const
&
aPortMappingPref
)
;
protected
:
virtual
~
nsSocketTransportService
(
)
;
private
:
nsIThread
*
mRawThread
{
nullptr
}
;
already_AddRefed
<
nsIThread
>
GetThreadSafely
(
)
;
already_AddRefed
<
nsIDirectTaskDispatcher
>
GetDirectTaskDispatcherSafely
(
)
;
Atomic
<
bool
>
mInitialized
{
false
}
;
Atomic
<
bool
>
mShuttingDown
{
false
}
;
Mutex
mLock
{
"
nsSocketTransportService
:
:
mLock
"
}
;
nsCOMPtr
<
nsIThread
>
mThread
;
nsCOMPtr
<
nsIDirectTaskDispatcher
>
mDirectTaskDispatcher
;
UniquePtr
<
PollableEvent
>
mPollableEvent
;
bool
mOffline
{
false
}
;
bool
mGoingOffline
{
false
}
;
void
Reset
(
bool
aGuardLocals
)
;
nsresult
ShutdownThread
(
)
;
struct
SocketContext
{
PRFileDesc
*
mFD
;
nsASocketHandler
*
mHandler
;
PRIntervalTime
mPollStartEpoch
;
public
:
bool
IsTimedOut
(
PRIntervalTime
now
)
const
;
void
EnsureTimeout
(
PRIntervalTime
now
)
;
void
DisengageTimeout
(
)
;
PRIntervalTime
TimeoutIn
(
PRIntervalTime
now
)
const
;
void
MaybeResetEpoch
(
)
;
}
;
SocketContext
*
mActiveList
;
SocketContext
*
mIdleList
;
uint32_t
mActiveListSize
{
SOCKET_LIMIT_MIN
}
;
uint32_t
mIdleListSize
{
SOCKET_LIMIT_MIN
}
;
uint32_t
mActiveCount
{
0
}
;
uint32_t
mIdleCount
{
0
}
;
nsresult
DetachSocket
(
SocketContext
*
SocketContext
*
)
;
nsresult
AddToIdleList
(
SocketContext
*
)
;
nsresult
AddToPollList
(
SocketContext
*
)
;
void
RemoveFromIdleList
(
SocketContext
*
)
;
void
RemoveFromPollList
(
SocketContext
*
)
;
void
MoveToIdleList
(
SocketContext
*
sock
)
;
void
MoveToPollList
(
SocketContext
*
sock
)
;
bool
GrowActiveList
(
)
;
bool
GrowIdleList
(
)
;
void
InitMaxCount
(
)
;
uint64_t
mSentBytesCount
{
0
}
;
uint64_t
mReceivedBytesCount
{
0
}
;
PRPollDesc
*
mPollList
;
PRIntervalTime
PollTimeout
(
PRIntervalTime
now
)
;
nsresult
DoPollIteration
(
TimeDuration
*
pollDuration
)
;
int32_t
Poll
(
TimeDuration
*
pollDuration
PRIntervalTime
ts
)
;
AutoCleanLinkedList
<
LinkedRunnableEvent
>
mPendingSocketQueue
;
nsresult
UpdatePrefs
(
)
;
static
void
UpdatePrefs
(
const
char
*
aPref
void
*
aSelf
)
;
void
UpdateSendBufferPref
(
)
;
int32_t
mSendBufferSize
{
0
}
;
int32_t
mKeepaliveIdleTimeS
{
600
}
;
int32_t
mKeepaliveRetryIntervalS
{
1
}
;
int32_t
mKeepaliveProbeCount
{
kDefaultTCPKeepCount
}
;
bool
mKeepaliveEnabledPref
{
false
}
;
TimeDuration
mPollableEventTimeout
;
Atomic
<
bool
>
mServingPendingQueue
{
false
}
;
Atomic
<
int32_t
Relaxed
>
mMaxTimePerPollIter
{
100
}
;
Atomic
<
PRIntervalTime
Relaxed
>
mMaxTimeForPrClosePref
;
Atomic
<
PRIntervalTime
Relaxed
>
mLastNetworkLinkChangeTime
{
0
}
;
Atomic
<
PRIntervalTime
Relaxed
>
mNetworkLinkChangeBusyWaitPeriod
;
Atomic
<
PRIntervalTime
Relaxed
>
mNetworkLinkChangeBusyWaitTimeout
;
Atomic
<
bool
Relaxed
>
mSleepPhase
{
false
}
;
nsCOMPtr
<
nsITimer
>
mAfterWakeUpTimer
;
using
TPortRemapping
=
CopyableTArray
<
Tuple
<
uint16_t
uint16_t
uint16_t
>
>
;
Maybe
<
TPortRemapping
>
mPortRemapping
;
void
ApplyPortRemapPreference
(
TPortRemapping
const
&
portRemapping
)
;
void
OnKeepaliveEnabledPrefChange
(
)
;
void
NotifyKeepaliveEnabledPrefChange
(
SocketContext
*
sock
)
;
#
if
defined
(
XP_WIN
)
void
ProbeMaxCount
(
)
;
#
endif
bool
mProbedMaxCount
{
false
}
;
void
AnalyzeConnection
(
nsTArray
<
SocketInfo
>
*
data
SocketContext
*
context
bool
aActive
)
;
void
ClosePrivateConnections
(
)
;
void
DetachSocketWithGuard
(
bool
aGuardLocals
SocketContext
*
socketList
int32_t
index
)
;
void
MarkTheLastElementOfPendingQueue
(
)
;
#
if
defined
(
XP_WIN
)
Atomic
<
bool
>
mPolling
{
false
}
;
nsCOMPtr
<
nsITimer
>
mPollRepairTimer
;
void
StartPollWatchdog
(
)
;
void
DoPollRepair
(
)
;
void
StartPolling
(
)
;
void
EndPolling
(
)
;
#
endif
void
TryRepairPollableEvent
(
)
;
bool
mNotTrustedMitmDetected
{
false
}
;
CopyableTArray
<
nsCOMPtr
<
nsISTSShutdownObserver
>
>
mShutdownObservers
;
}
;
extern
nsSocketTransportService
*
gSocketTransportService
;
bool
OnSocketThread
(
)
;
}
}
#
endif
