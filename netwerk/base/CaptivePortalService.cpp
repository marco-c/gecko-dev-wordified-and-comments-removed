#
include
"
mozilla
/
net
/
CaptivePortalService
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
xpcpublic
.
h
"
static
const
char16_t
kInterfaceName
[
]
=
u
"
captive
-
portal
-
inteface
"
;
static
const
char
kOpenCaptivePortalLoginEvent
[
]
=
"
captive
-
portal
-
login
"
;
static
const
char
kAbortCaptivePortalLoginEvent
[
]
=
"
captive
-
portal
-
login
-
abort
"
;
static
const
char
kCaptivePortalLoginSuccessEvent
[
]
=
"
captive
-
portal
-
login
-
success
"
;
static
const
uint32_t
kDefaultInterval
=
60
*
1000
;
namespace
mozilla
{
namespace
net
{
static
LazyLogModule
gCaptivePortalLog
(
"
CaptivePortalService
"
)
;
#
undef
LOG
#
define
LOG
(
args
)
MOZ_LOG
(
gCaptivePortalLog
mozilla
:
:
LogLevel
:
:
Debug
args
)
NS_IMPL_ISUPPORTS
(
CaptivePortalService
nsICaptivePortalService
nsIObserver
nsISupportsWeakReference
nsITimerCallback
nsICaptivePortalCallback
nsINamed
)
CaptivePortalService
:
:
CaptivePortalService
(
)
:
mState
(
UNKNOWN
)
mStarted
(
false
)
mInitialized
(
false
)
mRequestInProgress
(
false
)
mEverBeenCaptive
(
false
)
mDelay
(
kDefaultInterval
)
mSlackCount
(
0
)
mMinInterval
(
kDefaultInterval
)
mMaxInterval
(
25
*
kDefaultInterval
)
mBackoffFactor
(
5
.
0
)
{
mLastChecked
=
TimeStamp
:
:
Now
(
)
;
}
CaptivePortalService
:
:
~
CaptivePortalService
(
)
{
LOG
(
(
"
CaptivePortalService
:
:
~
CaptivePortalService
isParentProcess
:
%
d
\
n
"
XRE_GetProcessType
(
)
=
=
GeckoProcessType_Default
)
)
;
}
nsresult
CaptivePortalService
:
:
PerformCheck
(
)
{
LOG
(
(
"
CaptivePortalService
:
:
PerformCheck
mRequestInProgress
:
%
d
mInitialized
:
%
d
mStarted
:
%
d
\
n
"
mRequestInProgress
mInitialized
mStarted
)
)
;
if
(
mRequestInProgress
|
|
!
mInitialized
|
|
!
mStarted
)
{
return
NS_OK
;
}
MOZ_ASSERT
(
XRE_GetProcessType
(
)
=
=
GeckoProcessType_Default
)
;
nsresult
rv
;
if
(
!
mCaptivePortalDetector
)
{
mCaptivePortalDetector
=
do_GetService
(
"
mozilla
.
org
/
toolkit
/
captive
-
detector
;
1
"
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
Unable
to
get
a
captive
portal
detector
\
n
"
)
)
;
return
rv
;
}
}
LOG
(
(
"
CaptivePortalService
:
:
PerformCheck
-
Calling
CheckCaptivePortal
\
n
"
)
)
;
mRequestInProgress
=
true
;
mCaptivePortalDetector
-
>
CheckCaptivePortal
(
kInterfaceName
this
)
;
return
NS_OK
;
}
nsresult
CaptivePortalService
:
:
RearmTimer
(
)
{
LOG
(
(
"
CaptivePortalService
:
:
RearmTimer
\
n
"
)
)
;
MOZ_ASSERT
(
XRE_GetProcessType
(
)
=
=
GeckoProcessType_Default
)
;
if
(
mTimer
)
{
mTimer
-
>
Cancel
(
)
;
}
if
(
mState
=
=
NOT_CAPTIVE
)
{
return
NS_OK
;
}
if
(
!
mTimer
)
{
mTimer
=
NS_NewTimer
(
)
;
}
if
(
mTimer
&
&
mDelay
>
0
)
{
LOG
(
(
"
CaptivePortalService
-
Reloading
timer
with
delay
%
u
\
n
"
mDelay
)
)
;
return
mTimer
-
>
InitWithCallback
(
this
mDelay
nsITimer
:
:
TYPE_ONE_SHOT
)
;
}
return
NS_OK
;
}
nsresult
CaptivePortalService
:
:
Initialize
(
)
{
if
(
mInitialized
)
{
return
NS_OK
;
}
mInitialized
=
true
;
if
(
XRE_GetProcessType
(
)
!
=
GeckoProcessType_Default
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
observerService
)
{
observerService
-
>
AddObserver
(
this
kOpenCaptivePortalLoginEvent
true
)
;
observerService
-
>
AddObserver
(
this
kAbortCaptivePortalLoginEvent
true
)
;
observerService
-
>
AddObserver
(
this
kCaptivePortalLoginSuccessEvent
true
)
;
}
LOG
(
(
"
Initialized
CaptivePortalService
\
n
"
)
)
;
return
NS_OK
;
}
nsresult
CaptivePortalService
:
:
Start
(
)
{
if
(
!
mInitialized
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
if
(
xpc
:
:
AreNonLocalConnectionsDisabled
(
)
&
&
!
Preferences
:
:
GetBool
(
"
network
.
captive
-
portal
-
service
.
testMode
"
false
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
if
(
XRE_GetProcessType
(
)
!
=
GeckoProcessType_Default
)
{
return
NS_OK
;
}
if
(
mStarted
)
{
return
NS_OK
;
}
MOZ_ASSERT
(
mState
=
=
UNKNOWN
"
Initial
state
should
be
UNKNOWN
"
)
;
mStarted
=
true
;
mEverBeenCaptive
=
false
;
Preferences
:
:
GetUint
(
"
network
.
captive
-
portal
-
service
.
minInterval
"
&
mMinInterval
)
;
Preferences
:
:
GetUint
(
"
network
.
captive
-
portal
-
service
.
maxInterval
"
&
mMaxInterval
)
;
Preferences
:
:
GetFloat
(
"
network
.
captive
-
portal
-
service
.
backoffFactor
"
&
mBackoffFactor
)
;
LOG
(
(
"
CaptivePortalService
:
:
Start
min
:
%
u
max
:
%
u
backoff
:
%
.
2f
\
n
"
mMinInterval
mMaxInterval
mBackoffFactor
)
)
;
mSlackCount
=
0
;
mDelay
=
mMinInterval
;
PerformCheck
(
)
;
RearmTimer
(
)
;
return
NS_OK
;
}
nsresult
CaptivePortalService
:
:
Stop
(
)
{
LOG
(
(
"
CaptivePortalService
:
:
Stop
\
n
"
)
)
;
if
(
XRE_GetProcessType
(
)
!
=
GeckoProcessType_Default
)
{
return
NS_OK
;
}
if
(
!
mStarted
)
{
return
NS_OK
;
}
if
(
mTimer
)
{
mTimer
-
>
Cancel
(
)
;
}
mTimer
=
nullptr
;
mRequestInProgress
=
false
;
mStarted
=
false
;
if
(
mCaptivePortalDetector
)
{
mCaptivePortalDetector
-
>
Abort
(
kInterfaceName
)
;
}
mCaptivePortalDetector
=
nullptr
;
mState
=
UNKNOWN
;
return
NS_OK
;
}
void
CaptivePortalService
:
:
SetStateInChild
(
int32_t
aState
)
{
MOZ_ASSERT
(
XRE_GetProcessType
(
)
!
=
GeckoProcessType_Default
)
;
mState
=
aState
;
mLastChecked
=
TimeStamp
:
:
Now
(
)
;
}
NS_IMETHODIMP
CaptivePortalService
:
:
GetState
(
int32_t
*
aState
)
{
*
aState
=
mState
;
return
NS_OK
;
}
NS_IMETHODIMP
CaptivePortalService
:
:
RecheckCaptivePortal
(
)
{
LOG
(
(
"
CaptivePortalService
:
:
RecheckCaptivePortal
\
n
"
)
)
;
if
(
XRE_GetProcessType
(
)
!
=
GeckoProcessType_Default
)
{
return
NS_OK
;
}
mSlackCount
=
0
;
mDelay
=
mMinInterval
;
PerformCheck
(
)
;
RearmTimer
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
CaptivePortalService
:
:
GetLastChecked
(
uint64_t
*
aLastChecked
)
{
double
duration
=
(
TimeStamp
:
:
Now
(
)
-
mLastChecked
)
.
ToMilliseconds
(
)
;
*
aLastChecked
=
static_cast
<
uint64_t
>
(
duration
)
;
return
NS_OK
;
}
NS_IMETHODIMP
CaptivePortalService
:
:
Notify
(
nsITimer
*
aTimer
)
{
LOG
(
(
"
CaptivePortalService
:
:
Notify
\
n
"
)
)
;
MOZ_ASSERT
(
aTimer
=
=
mTimer
)
;
MOZ_ASSERT
(
XRE_GetProcessType
(
)
=
=
GeckoProcessType_Default
)
;
PerformCheck
(
)
;
mSlackCount
+
+
;
if
(
mSlackCount
%
10
=
=
0
)
{
mDelay
=
mDelay
*
mBackoffFactor
;
}
if
(
mDelay
>
mMaxInterval
)
{
mDelay
=
mMaxInterval
;
}
RearmTimer
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
CaptivePortalService
:
:
GetName
(
nsACString
&
aName
)
{
aName
.
AssignLiteral
(
"
CaptivePortalService
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
CaptivePortalService
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
if
(
XRE_GetProcessType
(
)
!
=
GeckoProcessType_Default
)
{
return
NS_OK
;
}
LOG
(
(
"
CaptivePortalService
:
:
Observe
(
)
topic
=
%
s
\
n
"
aTopic
)
)
;
if
(
!
strcmp
(
aTopic
kOpenCaptivePortalLoginEvent
)
)
{
mState
=
LOCKED_PORTAL
;
mLastChecked
=
TimeStamp
:
:
Now
(
)
;
mEverBeenCaptive
=
true
;
}
else
if
(
!
strcmp
(
aTopic
kCaptivePortalLoginSuccessEvent
)
)
{
mState
=
UNLOCKED_PORTAL
;
mLastChecked
=
TimeStamp
:
:
Now
(
)
;
mSlackCount
=
0
;
mDelay
=
mMinInterval
;
RearmTimer
(
)
;
}
else
if
(
!
strcmp
(
aTopic
kAbortCaptivePortalLoginEvent
)
)
{
mState
=
UNKNOWN
;
mLastChecked
=
TimeStamp
:
:
Now
(
)
;
mSlackCount
=
0
;
}
nsCOMPtr
<
nsIObserverService
>
observerService
=
services
:
:
GetObserverService
(
)
;
if
(
observerService
)
{
nsCOMPtr
<
nsICaptivePortalService
>
cps
(
this
)
;
observerService
-
>
NotifyObservers
(
cps
NS_IPC_CAPTIVE_PORTAL_SET_STATE
nullptr
)
;
}
return
NS_OK
;
}
void
CaptivePortalService
:
:
NotifyConnectivityAvailable
(
bool
aCaptive
)
{
nsCOMPtr
<
nsIObserverService
>
observerService
=
services
:
:
GetObserverService
(
)
;
if
(
observerService
)
{
nsCOMPtr
<
nsICaptivePortalService
>
cps
(
this
)
;
observerService
-
>
NotifyObservers
(
cps
NS_CAPTIVE_PORTAL_CONNECTIVITY
aCaptive
?
u
"
captive
"
:
u
"
clear
"
)
;
}
}
NS_IMETHODIMP
CaptivePortalService
:
:
Prepare
(
)
{
LOG
(
(
"
CaptivePortalService
:
:
Prepare
\
n
"
)
)
;
MOZ_ASSERT
(
XRE_GetProcessType
(
)
=
=
GeckoProcessType_Default
)
;
if
(
mCaptivePortalDetector
)
{
mCaptivePortalDetector
-
>
FinishPreparation
(
kInterfaceName
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
CaptivePortalService
:
:
Complete
(
bool
success
)
{
LOG
(
(
"
CaptivePortalService
:
:
Complete
(
success
=
%
d
)
mState
=
%
d
\
n
"
success
mState
)
)
;
MOZ_ASSERT
(
XRE_GetProcessType
(
)
=
=
GeckoProcessType_Default
)
;
mLastChecked
=
TimeStamp
:
:
Now
(
)
;
if
(
success
)
{
if
(
mEverBeenCaptive
)
{
mState
=
UNLOCKED_PORTAL
;
NotifyConnectivityAvailable
(
true
)
;
}
else
{
mState
=
NOT_CAPTIVE
;
NotifyConnectivityAvailable
(
false
)
;
}
}
mRequestInProgress
=
false
;
return
NS_OK
;
}
}
}
