"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
runBackgroundTask
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
setTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
}
)
;
const
{
EXIT_CODE
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
BackgroundTasksManager
.
jsm
"
)
.
BackgroundTasksManager
;
function
tryRemoveDir
(
aFile
)
{
try
{
aFile
.
remove
(
true
)
;
}
catch
(
e
)
{
return
false
;
}
return
true
;
}
async
function
runBackgroundTask
(
commandLine
)
{
if
(
commandLine
.
length
<
3
)
{
throw
new
Error
(
"
Insufficient
arguments
"
)
;
}
let
profileDirPath
=
commandLine
.
getArgument
(
0
)
;
let
cacheDirName
=
commandLine
.
getArgument
(
1
)
;
let
secondsToWait
=
parseInt
(
commandLine
.
getArgument
(
2
)
)
;
if
(
isNaN
(
secondsToWait
)
)
{
secondsToWait
=
10
;
}
let
otherFoldersSuffix
=
"
"
;
if
(
commandLine
.
length
>
=
4
)
{
otherFoldersSuffix
=
commandLine
.
getArgument
(
3
)
;
}
console
.
error
(
profileDirPath
cacheDirName
secondsToWait
otherFoldersSuffix
)
;
if
(
cacheDirName
&
&
cacheDirName
.
length
>
0
)
{
let
targetFile
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsIFile
)
;
targetFile
.
initWithPath
(
profileDirPath
)
;
targetFile
.
append
(
cacheDirName
)
;
let
retryCount
=
0
;
while
(
!
targetFile
.
exists
(
)
)
{
if
(
retryCount
>
secondsToWait
)
{
throw
new
Error
(
couldn
'
t
find
cache
folder
{
targetFile
.
path
}
)
;
}
await
new
Promise
(
resolve
=
>
lazy
.
setTimeout
(
resolve
1000
)
)
;
retryCount
+
+
;
console
.
error
(
Cache
folder
attempt
no
{
retryCount
}
)
;
}
if
(
!
targetFile
.
isDirectory
(
)
)
{
throw
new
Error
(
"
Path
was
not
a
directory
"
)
;
}
console
.
error
(
"
have
path
"
)
;
targetFile
.
remove
(
true
)
;
console
.
error
(
done
removing
{
targetFile
.
path
}
)
;
}
if
(
otherFoldersSuffix
.
length
)
{
let
targetFile
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsIFile
)
;
targetFile
.
initWithPath
(
profileDirPath
)
;
let
entries
=
targetFile
.
directoryEntries
;
while
(
entries
.
hasMoreElements
(
)
)
{
let
entry
=
entries
.
nextFile
;
if
(
!
entry
.
leafName
.
endsWith
(
otherFoldersSuffix
)
|
|
!
entry
.
isDirectory
(
)
)
{
continue
;
}
let
removedDir
=
tryRemoveDir
(
entry
)
;
if
(
!
removedDir
&
&
entry
.
exists
(
)
)
{
removedDir
=
tryRemoveDir
(
entry
)
;
}
console
.
error
(
Deletion
of
folder
{
entry
.
leafName
}
-
success
=
{
removedDir
}
)
;
}
}
return
EXIT_CODE
.
SUCCESS
;
}
