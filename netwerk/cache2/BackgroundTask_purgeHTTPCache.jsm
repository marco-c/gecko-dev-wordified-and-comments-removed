"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
runBackgroundTask
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
setTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
}
)
;
const
{
EXIT_CODE
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
BackgroundTasksManager
.
jsm
"
)
.
BackgroundTasksManager
;
function
tryRemoveDir
(
aFile
)
{
try
{
aFile
.
remove
(
true
)
;
}
catch
(
e
)
{
return
false
;
}
return
true
;
}
const
FILE_CHECK_ITERATION_TIMEOUT_MS
=
1000
;
async
function
deleteCacheDirectory
(
profileDirPath
cacheDirName
secondsToWait
)
{
if
(
!
cacheDirName
|
|
cacheDirName
.
length
=
=
0
)
{
return
;
}
let
targetFile
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsIFile
)
;
targetFile
.
initWithPath
(
profileDirPath
)
;
targetFile
.
append
(
cacheDirName
)
;
let
dirLock
=
Cc
[
"
mozilla
.
org
/
net
/
CachePurgeLock
;
1
"
]
.
createInstance
(
Ci
.
nsICachePurgeLock
)
;
let
wasFirst
=
false
;
let
locked
=
false
;
try
{
dirLock
.
lock
(
cacheDirName
)
;
locked
=
true
;
wasFirst
=
!
dirLock
.
isOtherInstanceRunning
(
)
;
}
catch
(
e
)
{
console
.
error
(
"
Failed
to
check
dirLock
"
)
;
}
if
(
!
wasFirst
)
{
if
(
locked
)
{
dirLock
.
unlock
(
)
;
locked
=
false
;
}
console
.
error
(
"
Another
instance
is
already
purging
this
directory
"
)
;
return
;
}
let
retryCount
=
0
;
while
(
!
targetFile
.
exists
(
)
)
{
if
(
retryCount
*
FILE_CHECK_ITERATION_TIMEOUT_MS
>
secondsToWait
*
1000
)
{
console
.
error
(
couldn
'
t
find
cache
folder
{
targetFile
.
path
}
)
;
if
(
locked
)
{
dirLock
.
unlock
(
)
;
locked
=
false
;
}
return
;
}
await
new
Promise
(
resolve
=
>
lazy
.
setTimeout
(
resolve
FILE_CHECK_ITERATION_TIMEOUT_MS
)
)
;
retryCount
+
+
;
console
.
error
(
Cache
folder
attempt
no
{
retryCount
}
)
;
}
if
(
!
targetFile
.
isDirectory
(
)
)
{
if
(
locked
)
{
dirLock
.
unlock
(
)
;
locked
=
false
;
}
throw
new
Error
(
"
Path
was
not
a
directory
"
)
;
}
console
.
error
(
started
removing
{
targetFile
.
path
}
)
;
targetFile
.
remove
(
true
)
;
console
.
error
(
done
removing
{
targetFile
.
path
}
)
;
if
(
locked
)
{
dirLock
.
unlock
(
)
;
locked
=
false
;
}
}
async
function
cleanupOtherCacheDirectories
(
profileDirPath
otherFoldersSuffix
)
{
if
(
!
otherFoldersSuffix
|
|
otherFoldersSuffix
.
length
=
=
0
)
{
return
;
}
let
targetFile
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsIFile
)
;
targetFile
.
initWithPath
(
profileDirPath
)
;
let
entries
=
targetFile
.
directoryEntries
;
while
(
entries
.
hasMoreElements
(
)
)
{
let
entry
=
entries
.
nextFile
;
if
(
!
entry
.
leafName
.
endsWith
(
otherFoldersSuffix
)
)
{
continue
;
}
let
shouldProcessEntry
=
false
;
try
{
shouldProcessEntry
=
entry
.
isDirectory
(
)
;
}
catch
(
e
)
{
}
if
(
!
shouldProcessEntry
)
{
continue
;
}
let
dirLock
=
Cc
[
"
mozilla
.
org
/
net
/
CachePurgeLock
;
1
"
]
.
createInstance
(
Ci
.
nsICachePurgeLock
)
;
let
wasFirst
=
false
;
try
{
dirLock
.
lock
(
entry
.
leafName
)
;
wasFirst
=
!
dirLock
.
isOtherInstanceRunning
(
)
;
}
catch
(
e
)
{
console
.
error
(
"
Failed
to
check
dirlock
.
Skipping
folder
"
)
;
dirLock
.
unlock
(
)
;
continue
;
}
if
(
!
wasFirst
)
{
dirLock
.
unlock
(
)
;
continue
;
}
let
removedDir
=
tryRemoveDir
(
entry
)
;
if
(
!
removedDir
&
&
entry
.
exists
(
)
)
{
removedDir
=
tryRemoveDir
(
entry
)
;
}
console
.
error
(
Deletion
of
folder
{
entry
.
leafName
}
-
success
=
{
removedDir
}
)
;
dirLock
.
unlock
(
)
;
}
}
async
function
runBackgroundTask
(
commandLine
)
{
if
(
commandLine
.
length
<
3
)
{
throw
new
Error
(
"
Insufficient
arguments
"
)
;
}
let
profileDirPath
=
commandLine
.
getArgument
(
0
)
;
let
cacheDirName
=
commandLine
.
getArgument
(
1
)
;
let
secondsToWait
=
parseInt
(
commandLine
.
getArgument
(
2
)
)
;
if
(
isNaN
(
secondsToWait
)
)
{
secondsToWait
=
10
;
}
let
otherFoldersSuffix
=
"
"
;
if
(
commandLine
.
length
>
=
4
)
{
otherFoldersSuffix
=
commandLine
.
getArgument
(
3
)
;
}
console
.
error
(
profileDirPath
cacheDirName
secondsToWait
otherFoldersSuffix
)
;
await
deleteCacheDirectory
(
profileDirPath
cacheDirName
secondsToWait
)
;
await
cleanupOtherCacheDirectories
(
profileDirPath
otherFoldersSuffix
)
;
return
EXIT_CODE
.
SUCCESS
;
}
