#
ifndef
CacheFileUtils__h__
#
define
CacheFileUtils__h__
#
include
"
nsError
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
class
nsILoadContextInfo
;
namespace
mozilla
{
namespace
net
{
namespace
CacheFileUtils
{
extern
const
char
*
kAltDataKey
;
already_AddRefed
<
nsILoadContextInfo
>
ParseKey
(
const
nsACString
&
aKey
nsACString
*
aIdEnhance
=
nullptr
nsACString
*
aURISpec
=
nullptr
)
;
void
AppendKeyPrefix
(
nsILoadContextInfo
*
aInfo
nsACString
&
_retval
)
;
void
AppendTagWithValue
(
nsACString
&
aTarget
char
const
aTag
const
nsACString
&
aValue
)
;
nsresult
KeyMatchesLoadContextInfo
(
const
nsACString
&
aKey
nsILoadContextInfo
*
aInfo
bool
*
_retval
)
;
class
ValidityPair
{
public
:
ValidityPair
(
uint32_t
aOffset
uint32_t
aLen
)
;
ValidityPair
&
operator
=
(
const
ValidityPair
&
aOther
)
=
default
;
bool
CanBeMerged
(
const
ValidityPair
&
aOther
)
const
;
bool
IsInOrFollows
(
uint32_t
aOffset
)
const
;
bool
LessThan
(
const
ValidityPair
&
aOther
)
const
;
void
Merge
(
const
ValidityPair
&
aOther
)
;
uint32_t
Offset
(
)
const
{
return
mOffset
;
}
uint32_t
Len
(
)
const
{
return
mLen
;
}
private
:
uint32_t
mOffset
;
uint32_t
mLen
;
}
;
class
ValidityMap
{
public
:
void
Log
(
)
const
;
uint32_t
Length
(
)
const
;
void
AddPair
(
uint32_t
aOffset
uint32_t
aLen
)
;
void
Clear
(
)
;
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
ValidityPair
&
operator
[
]
(
uint32_t
aIdx
)
;
private
:
nsTArray
<
ValidityPair
>
mMap
;
}
;
class
DetailedCacheHitTelemetry
{
public
:
enum
ERecType
{
HIT
=
0
MISS
=
1
}
;
static
void
AddRecord
(
ERecType
aType
TimeStamp
aLoadStart
)
;
private
:
class
HitRate
{
public
:
HitRate
(
)
;
void
AddRecord
(
ERecType
aType
)
;
uint32_t
GetHitRateBucket
(
uint32_t
aNumOfBuckets
)
const
;
uint32_t
Count
(
)
;
void
Reset
(
)
;
private
:
uint32_t
mHitCnt
=
0
;
uint32_t
mMissCnt
=
0
;
}
;
static
const
uint32_t
kRangeSize
=
5000
;
static
const
uint32_t
kNumOfRanges
=
20
;
static
const
uint32_t
kTotalSamplesReportLimit
=
1000
;
static
const
uint32_t
kHitRateSamplesReportLimit
=
500
;
static
const
uint32_t
kHitRateBuckets
=
20
;
static
StaticMutex
sLock
;
static
uint32_t
sRecordCnt
;
static
HitRate
sHRStats
[
kNumOfRanges
]
;
}
;
class
CachePerfStats
{
public
:
enum
EDataType
{
IO_OPEN
=
0
IO_READ
=
1
IO_WRITE
=
2
ENTRY_OPEN
=
3
LAST
=
4
}
;
static
void
AddValue
(
EDataType
aType
uint32_t
aValue
bool
aShortOnly
)
;
static
uint32_t
GetAverage
(
EDataType
aType
bool
aFiltered
)
;
static
uint32_t
GetStdDev
(
EDataType
aType
bool
aFiltered
)
;
static
bool
IsCacheSlow
(
)
;
static
void
GetSlowStats
(
uint32_t
*
aSlow
uint32_t
*
aNotSlow
)
;
private
:
class
MMA
{
public
:
MMA
(
uint32_t
aTotalWeight
bool
aFilter
)
;
void
AddValue
(
uint32_t
aValue
)
;
uint32_t
GetAverage
(
)
;
uint32_t
GetStdDev
(
)
;
private
:
uint64_t
mSum
;
uint64_t
mSumSq
;
uint32_t
mCnt
;
uint32_t
mWeight
;
bool
mFilter
;
}
;
class
PerfData
{
public
:
PerfData
(
)
;
void
AddValue
(
uint32_t
aValue
bool
aShortOnly
)
;
uint32_t
GetAverage
(
bool
aFiltered
)
;
uint32_t
GetStdDev
(
bool
aFiltered
)
;
private
:
MMA
mFilteredAvg
;
MMA
mShortAvg
;
}
;
static
StaticMutex
sLock
;
static
PerfData
sData
[
LAST
]
;
static
uint32_t
sCacheSlowCnt
;
static
uint32_t
sCacheNotSlowCnt
;
}
;
void
FreeBuffer
(
void
*
aBuf
)
;
nsresult
ParseAlternativeDataInfo
(
const
char
*
aInfo
int64_t
*
_offset
nsACString
*
_type
)
;
void
BuildAlternativeDataInfo
(
const
char
*
aInfo
int64_t
aOffset
nsACString
&
_retval
)
;
class
CacheFileLock
final
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
CacheFileLock
)
CacheFileLock
(
)
=
default
;
mozilla
:
:
Mutex
&
Lock
(
)
{
return
mLock
;
}
private
:
~
CacheFileLock
(
)
=
default
;
mozilla
:
:
Mutex
mLock
{
"
CacheFile
.
mLock
"
}
;
}
;
}
}
}
#
endif
