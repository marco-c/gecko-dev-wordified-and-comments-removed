#
include
"
CacheObserver
.
h
"
#
include
"
CacheStorageService
.
h
"
#
include
"
CacheFileIOManager
.
h
"
#
include
"
LoadContextInfo
.
h
"
#
include
"
nsICacheStorage
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
mozilla
/
net
/
NeckoCommon
.
h
"
#
include
"
prsystem
.
h
"
#
include
<
time
.
h
>
#
include
<
math
.
h
>
namespace
mozilla
{
namespace
net
{
StaticRefPtr
<
CacheObserver
>
CacheObserver
:
:
sSelf
;
static
float
const
kDefaultHalfLifeHours
=
24
.
0F
;
float
CacheObserver
:
:
sHalfLifeHours
=
kDefaultHalfLifeHours
;
int32_t
CacheObserver
:
:
sAutoMemoryCacheCapacity
=
-
1
;
Atomic
<
uint32_t
Relaxed
>
CacheObserver
:
:
sSmartDiskCacheCapacity
(
1024
*
1024
)
;
static
bool
kDefaultCacheFSReported
=
false
;
bool
CacheObserver
:
:
sCacheFSReported
=
kDefaultCacheFSReported
;
static
bool
kDefaultHashStatsReported
=
false
;
bool
CacheObserver
:
:
sHashStatsReported
=
kDefaultHashStatsReported
;
Atomic
<
PRIntervalTime
>
CacheObserver
:
:
sShutdownDemandedTime
(
PR_INTERVAL_NO_TIMEOUT
)
;
static
uint32_t
const
kDefaultCacheAmountWritten
=
0
;
Atomic
<
uint32_t
Relaxed
>
CacheObserver
:
:
sCacheAmountWritten
(
kDefaultCacheAmountWritten
)
;
NS_IMPL_ISUPPORTS
(
CacheObserver
nsIObserver
nsISupportsWeakReference
)
nsresult
CacheObserver
:
:
Init
(
)
{
if
(
IsNeckoChild
(
)
)
{
return
NS_OK
;
}
if
(
sSelf
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
!
obs
)
{
return
NS_ERROR_UNEXPECTED
;
}
sSelf
=
new
CacheObserver
(
)
;
obs
-
>
AddObserver
(
sSelf
"
prefservice
:
after
-
app
-
defaults
"
true
)
;
obs
-
>
AddObserver
(
sSelf
"
profile
-
do
-
change
"
true
)
;
obs
-
>
AddObserver
(
sSelf
"
browser
-
delayed
-
startup
-
finished
"
true
)
;
obs
-
>
AddObserver
(
sSelf
"
profile
-
before
-
change
"
true
)
;
obs
-
>
AddObserver
(
sSelf
"
xpcom
-
shutdown
"
true
)
;
obs
-
>
AddObserver
(
sSelf
"
last
-
pb
-
context
-
exited
"
true
)
;
obs
-
>
AddObserver
(
sSelf
"
memory
-
pressure
"
true
)
;
return
NS_OK
;
}
nsresult
CacheObserver
:
:
Shutdown
(
)
{
if
(
!
sSelf
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
sSelf
=
nullptr
;
return
NS_OK
;
}
void
CacheObserver
:
:
AttachToPreferences
(
)
{
mozilla
:
:
Preferences
:
:
GetComplex
(
"
browser
.
cache
.
disk
.
parent_directory
"
NS_GET_IID
(
nsIFile
)
getter_AddRefs
(
mCacheParentDirectoryOverride
)
)
;
sHalfLifeHours
=
std
:
:
max
(
0
.
01F
std
:
:
min
(
1440
.
0F
mozilla
:
:
Preferences
:
:
GetFloat
(
"
browser
.
cache
.
frecency_half_life_hours
"
kDefaultHalfLifeHours
)
)
)
;
mozilla
:
:
Preferences
:
:
AddAtomicUintVarCache
(
&
sCacheAmountWritten
"
browser
.
cache
.
disk
.
amount_written
"
kDefaultCacheAmountWritten
)
;
}
uint32_t
CacheObserver
:
:
MemoryCacheCapacity
(
)
{
if
(
StaticPrefs
:
:
browser_cache_memory_capacity
(
)
>
=
0
)
{
return
StaticPrefs
:
:
browser_cache_memory_capacity
(
)
;
}
if
(
sAutoMemoryCacheCapacity
!
=
-
1
)
return
sAutoMemoryCacheCapacity
;
static
uint64_t
bytes
=
PR_GetPhysicalMemorySize
(
)
;
if
(
bytes
=
=
0
)
bytes
=
32
*
1024
*
1024
;
if
(
bytes
>
INT64_MAX
)
bytes
=
INT64_MAX
;
uint64_t
kbytes
=
bytes
>
>
10
;
double
kBytesD
=
double
(
kbytes
)
;
double
x
=
log
(
kBytesD
)
/
log
(
2
.
0
)
-
14
;
int32_t
capacity
=
0
;
if
(
x
>
0
)
{
capacity
=
(
int32_t
)
(
x
*
x
/
3
.
0
+
x
+
2
.
0
/
3
+
0
.
1
)
;
if
(
capacity
>
32
)
capacity
=
32
;
capacity
<
<
=
10
;
}
return
sAutoMemoryCacheCapacity
=
capacity
;
}
void
CacheObserver
:
:
SetSmartDiskCacheCapacity
(
uint32_t
aCapacity
)
{
sSmartDiskCacheCapacity
=
aCapacity
;
}
uint32_t
CacheObserver
:
:
DiskCacheCapacity
(
)
{
return
SmartCacheSizeEnabled
(
)
?
sSmartDiskCacheCapacity
:
StaticPrefs
:
:
browser_cache_disk_capacity
(
)
;
}
void
CacheObserver
:
:
SetCacheFSReported
(
)
{
sCacheFSReported
=
true
;
if
(
!
sSelf
)
{
return
;
}
if
(
NS_IsMainThread
(
)
)
{
sSelf
-
>
StoreCacheFSReported
(
)
;
}
else
{
nsCOMPtr
<
nsIRunnable
>
event
=
NewRunnableMethod
(
"
net
:
:
CacheObserver
:
:
StoreCacheFSReported
"
sSelf
.
get
(
)
&
CacheObserver
:
:
StoreCacheFSReported
)
;
NS_DispatchToMainThread
(
event
)
;
}
}
void
CacheObserver
:
:
StoreCacheFSReported
(
)
{
mozilla
:
:
Preferences
:
:
SetInt
(
"
browser
.
cache
.
disk
.
filesystem_reported
"
sCacheFSReported
)
;
}
void
CacheObserver
:
:
SetHashStatsReported
(
)
{
sHashStatsReported
=
true
;
if
(
!
sSelf
)
{
return
;
}
if
(
NS_IsMainThread
(
)
)
{
sSelf
-
>
StoreHashStatsReported
(
)
;
}
else
{
nsCOMPtr
<
nsIRunnable
>
event
=
NewRunnableMethod
(
"
net
:
:
CacheObserver
:
:
StoreHashStatsReported
"
sSelf
.
get
(
)
&
CacheObserver
:
:
StoreHashStatsReported
)
;
NS_DispatchToMainThread
(
event
)
;
}
}
void
CacheObserver
:
:
StoreHashStatsReported
(
)
{
mozilla
:
:
Preferences
:
:
SetInt
(
"
browser
.
cache
.
disk
.
hashstats_reported
"
sHashStatsReported
)
;
}
void
CacheObserver
:
:
SetCacheAmountWritten
(
uint32_t
aCacheAmountWritten
)
{
sCacheAmountWritten
=
aCacheAmountWritten
;
if
(
!
sSelf
)
{
return
;
}
if
(
NS_IsMainThread
(
)
)
{
sSelf
-
>
StoreCacheAmountWritten
(
)
;
}
else
{
nsCOMPtr
<
nsIRunnable
>
event
=
NewRunnableMethod
(
"
net
:
:
CacheObserver
:
:
StoreCacheAmountWritten
"
sSelf
.
get
(
)
&
CacheObserver
:
:
StoreCacheAmountWritten
)
;
NS_DispatchToMainThread
(
event
)
;
}
}
void
CacheObserver
:
:
StoreCacheAmountWritten
(
)
{
mozilla
:
:
Preferences
:
:
SetInt
(
"
browser
.
cache
.
disk
.
amount_written
"
sCacheAmountWritten
)
;
}
void
CacheObserver
:
:
ParentDirOverride
(
nsIFile
*
*
aDir
)
{
if
(
NS_WARN_IF
(
!
aDir
)
)
return
;
*
aDir
=
nullptr
;
if
(
!
sSelf
)
return
;
if
(
!
sSelf
-
>
mCacheParentDirectoryOverride
)
return
;
sSelf
-
>
mCacheParentDirectoryOverride
-
>
Clone
(
aDir
)
;
}
bool
CacheObserver
:
:
EntryIsTooBig
(
int64_t
aSize
bool
aUsingDisk
)
{
int64_t
preferredLimit
=
aUsingDisk
?
MaxDiskEntrySize
(
)
:
MaxMemoryEntrySize
(
)
;
if
(
preferredLimit
>
0
)
{
preferredLimit
<
<
=
10
;
}
if
(
preferredLimit
!
=
-
1
&
&
aSize
>
preferredLimit
)
return
true
;
int64_t
derivedLimit
=
aUsingDisk
?
DiskCacheCapacity
(
)
:
MemoryCacheCapacity
(
)
;
derivedLimit
<
<
=
(
10
-
3
)
;
if
(
aSize
>
derivedLimit
)
return
true
;
return
false
;
}
bool
CacheObserver
:
:
IsPastShutdownIOLag
(
)
{
#
ifdef
DEBUG
return
false
;
#
endif
if
(
sShutdownDemandedTime
=
=
PR_INTERVAL_NO_TIMEOUT
|
|
MaxShutdownIOLag
(
)
=
=
UINT32_MAX
)
{
return
false
;
}
static
const
PRIntervalTime
kMaxShutdownIOLag
=
PR_SecondsToInterval
(
MaxShutdownIOLag
(
)
)
;
if
(
(
PR_IntervalNow
(
)
-
sShutdownDemandedTime
)
>
kMaxShutdownIOLag
)
{
return
true
;
}
return
false
;
}
NS_IMETHODIMP
CacheObserver
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
if
(
!
strcmp
(
aTopic
"
prefservice
:
after
-
app
-
defaults
"
)
)
{
CacheFileIOManager
:
:
Init
(
)
;
return
NS_OK
;
}
if
(
!
strcmp
(
aTopic
"
profile
-
do
-
change
"
)
)
{
AttachToPreferences
(
)
;
CacheFileIOManager
:
:
Init
(
)
;
CacheFileIOManager
:
:
OnProfile
(
)
;
return
NS_OK
;
}
if
(
!
strcmp
(
aTopic
"
browser
-
delayed
-
startup
-
finished
"
)
)
{
CacheStorageService
:
:
CleaupCacheDirectories
(
)
;
return
NS_OK
;
}
if
(
!
strcmp
(
aTopic
"
profile
-
change
-
net
-
teardown
"
)
|
|
!
strcmp
(
aTopic
"
profile
-
before
-
change
"
)
|
|
!
strcmp
(
aTopic
"
xpcom
-
shutdown
"
)
)
{
if
(
sShutdownDemandedTime
=
=
PR_INTERVAL_NO_TIMEOUT
)
{
sShutdownDemandedTime
=
PR_IntervalNow
(
)
;
}
RefPtr
<
CacheStorageService
>
service
=
CacheStorageService
:
:
Self
(
)
;
if
(
service
)
{
service
-
>
Shutdown
(
)
;
}
CacheFileIOManager
:
:
Shutdown
(
)
;
return
NS_OK
;
}
if
(
!
strcmp
(
aTopic
"
last
-
pb
-
context
-
exited
"
)
)
{
RefPtr
<
CacheStorageService
>
service
=
CacheStorageService
:
:
Self
(
)
;
if
(
service
)
{
service
-
>
DropPrivateBrowsingEntries
(
)
;
}
return
NS_OK
;
}
if
(
!
strcmp
(
aTopic
"
memory
-
pressure
"
)
)
{
RefPtr
<
CacheStorageService
>
service
=
CacheStorageService
:
:
Self
(
)
;
if
(
service
)
service
-
>
PurgeFromMemory
(
nsICacheStorageService
:
:
PURGE_EVERYTHING
)
;
return
NS_OK
;
}
MOZ_ASSERT
(
false
"
Missing
observer
handler
"
)
;
return
NS_OK
;
}
}
}
