#
ifndef
CacheFileInputStream__h__
#
define
CacheFileInputStream__h__
#
include
"
nsIAsyncInputStream
.
h
"
#
include
"
nsISeekableStream
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
CacheFileChunk
.
h
"
namespace
mozilla
{
namespace
net
{
class
CacheFile
;
class
CacheFileInputStream
:
public
nsIAsyncInputStream
public
nsISeekableStream
public
CacheFileChunkListener
{
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIINPUTSTREAM
NS_DECL_NSIASYNCINPUTSTREAM
NS_DECL_NSISEEKABLESTREAM
NS_DECL_NSITELLABLESTREAM
public
:
explicit
CacheFileInputStream
(
CacheFile
*
aFile
nsISupports
*
aEntry
bool
aAlternativeData
)
;
NS_IMETHOD
OnChunkRead
(
nsresult
aResult
CacheFileChunk
*
aChunk
)
override
;
NS_IMETHOD
OnChunkWritten
(
nsresult
aResult
CacheFileChunk
*
aChunk
)
override
;
NS_IMETHOD
OnChunkAvailable
(
nsresult
aResult
uint32_t
aChunkIdx
CacheFileChunk
*
aChunk
)
override
;
NS_IMETHOD
OnChunkUpdated
(
CacheFileChunk
*
aChunk
)
override
;
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
uint32_t
GetPosition
(
)
const
{
return
mPos
;
}
;
bool
IsAlternativeData
(
)
const
{
return
mAlternativeData
;
}
;
int64_t
GetChunkIdx
(
)
const
{
return
mChunk
?
static_cast
<
int64_t
>
(
mChunk
-
>
Index
(
)
)
:
-
1
;
}
;
private
:
virtual
~
CacheFileInputStream
(
)
;
void
CloseWithStatusLocked
(
nsresult
aStatus
)
;
void
CleanUp
(
)
;
void
ReleaseChunk
(
)
;
void
EnsureCorrectChunk
(
bool
aReleaseOnly
)
;
int64_t
CanRead
(
CacheFileChunkReadHandle
*
aHandle
)
;
void
NotifyListener
(
)
;
void
MaybeNotifyListener
(
)
;
RefPtr
<
CacheFile
>
mFile
;
RefPtr
<
CacheFileChunk
>
mChunk
;
int64_t
mPos
;
nsresult
mStatus
;
bool
mClosed
:
1
;
bool
mInReadSegments
:
1
;
bool
mWaitingForUpdate
:
1
;
bool
const
mAlternativeData
:
1
;
int64_t
mListeningForChunk
;
nsCOMPtr
<
nsIInputStreamCallback
>
mCallback
;
uint32_t
mCallbackFlags
;
nsCOMPtr
<
nsIEventTarget
>
mCallbackTarget
;
RefPtr
<
nsISupports
>
mCacheEntryHandle
;
}
;
}
}
#
endif
