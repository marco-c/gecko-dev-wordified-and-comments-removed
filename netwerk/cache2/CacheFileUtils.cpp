#
include
"
CacheIndex
.
h
"
#
include
"
CacheLog
.
h
"
#
include
"
CacheFileUtils
.
h
"
#
include
"
LoadContextInfo
.
h
"
#
include
"
mozilla
/
Tokenizer
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsString
.
h
"
#
include
<
algorithm
>
#
include
"
mozilla
/
Unused
.
h
"
namespace
mozilla
{
namespace
net
{
namespace
CacheFileUtils
{
static
uint32_t
const
kAltDataVersion
=
1
;
const
char
*
kAltDataKey
=
"
alt
-
data
"
;
namespace
{
class
KeyParser
:
protected
Tokenizer
{
public
:
explicit
KeyParser
(
nsACString
const
&
aInput
)
:
Tokenizer
(
aInput
)
isAnonymous
(
false
)
lastTag
(
0
)
{
}
private
:
OriginAttributes
originAttribs
;
bool
isAnonymous
;
nsCString
idEnhance
;
nsDependentCSubstring
cacheKey
;
char
lastTag
;
static
bool
TagChar
(
const
char
aChar
)
{
unsigned
char
c
=
static_cast
<
unsigned
char
>
(
aChar
)
;
return
c
>
=
'
'
&
&
c
<
=
'
\
x7f
'
;
}
bool
ParseTags
(
)
{
if
(
CheckEOF
(
)
)
{
return
true
;
}
char
tag
;
if
(
!
ReadChar
(
&
TagChar
&
tag
)
)
{
return
false
;
}
if
(
!
(
lastTag
<
tag
|
|
tag
=
=
'
:
'
)
)
{
return
false
;
}
lastTag
=
tag
;
switch
(
tag
)
{
case
'
:
'
:
cacheKey
.
Rebind
(
mCursor
mEnd
-
mCursor
)
;
return
true
;
case
'
O
'
:
{
nsAutoCString
originSuffix
;
if
(
!
ParseValue
(
&
originSuffix
)
|
|
!
originAttribs
.
PopulateFromSuffix
(
originSuffix
)
)
{
return
false
;
}
break
;
}
case
'
p
'
:
originAttribs
.
SyncAttributesWithPrivateBrowsing
(
true
)
;
break
;
case
'
b
'
:
originAttribs
.
mInIsolatedMozBrowser
=
true
;
break
;
case
'
a
'
:
isAnonymous
=
true
;
break
;
case
'
i
'
:
{
uint32_t
deprecatedAppId
=
0
;
if
(
!
ReadInteger
(
&
deprecatedAppId
)
)
{
return
false
;
}
break
;
}
case
'
~
'
:
if
(
!
ParseValue
(
&
idEnhance
)
)
{
return
false
;
}
break
;
default
:
if
(
!
ParseValue
(
)
)
{
return
false
;
}
break
;
}
if
(
!
CheckChar
(
'
'
)
)
{
return
false
;
}
return
ParseTags
(
)
;
}
bool
ParseValue
(
nsACString
*
result
=
nullptr
)
{
if
(
CheckEOF
(
)
)
{
return
false
;
}
Token
t
;
while
(
Next
(
t
)
)
{
if
(
!
Token
:
:
Char
(
'
'
)
.
Equals
(
t
)
)
{
if
(
result
)
{
result
-
>
Append
(
t
.
Fragment
(
)
)
;
}
continue
;
}
if
(
CheckChar
(
'
'
)
)
{
if
(
result
)
{
result
-
>
Append
(
'
'
)
;
}
continue
;
}
Rollback
(
)
;
return
true
;
}
return
false
;
}
public
:
already_AddRefed
<
LoadContextInfo
>
Parse
(
)
{
RefPtr
<
LoadContextInfo
>
info
;
if
(
ParseTags
(
)
)
{
info
=
GetLoadContextInfo
(
isAnonymous
originAttribs
)
;
}
return
info
.
forget
(
)
;
}
void
URISpec
(
nsACString
&
result
)
{
result
.
Assign
(
cacheKey
)
;
}
void
IdEnhance
(
nsACString
&
result
)
{
result
.
Assign
(
idEnhance
)
;
}
}
;
}
already_AddRefed
<
nsILoadContextInfo
>
ParseKey
(
const
nsACString
&
aKey
nsACString
*
aIdEnhance
nsACString
*
aURISpec
)
{
KeyParser
parser
(
aKey
)
;
RefPtr
<
LoadContextInfo
>
info
=
parser
.
Parse
(
)
;
if
(
info
)
{
if
(
aIdEnhance
)
parser
.
IdEnhance
(
*
aIdEnhance
)
;
if
(
aURISpec
)
parser
.
URISpec
(
*
aURISpec
)
;
}
return
info
.
forget
(
)
;
}
void
AppendKeyPrefix
(
nsILoadContextInfo
*
aInfo
nsACString
&
_retval
)
{
OriginAttributes
const
*
oa
=
aInfo
-
>
OriginAttributesPtr
(
)
;
nsAutoCString
suffix
;
oa
-
>
CreateSuffix
(
suffix
)
;
if
(
!
suffix
.
IsEmpty
(
)
)
{
AppendTagWithValue
(
_retval
'
O
'
suffix
)
;
}
if
(
aInfo
-
>
IsAnonymous
(
)
)
{
_retval
.
AppendLiteral
(
"
a
"
)
;
}
if
(
aInfo
-
>
IsPrivate
(
)
)
{
_retval
.
AppendLiteral
(
"
p
"
)
;
}
}
void
AppendTagWithValue
(
nsACString
&
aTarget
char
const
aTag
const
nsACString
&
aValue
)
{
aTarget
.
Append
(
aTag
)
;
if
(
!
aValue
.
IsEmpty
(
)
)
{
if
(
!
aValue
.
Contains
(
'
'
)
)
{
aTarget
.
Append
(
aValue
)
;
}
else
{
nsAutoCString
escapedValue
(
aValue
)
;
escapedValue
.
ReplaceSubstring
(
NS_LITERAL_CSTRING
(
"
"
)
NS_LITERAL_CSTRING
(
"
"
)
)
;
aTarget
.
Append
(
escapedValue
)
;
}
}
aTarget
.
Append
(
'
'
)
;
}
nsresult
KeyMatchesLoadContextInfo
(
const
nsACString
&
aKey
nsILoadContextInfo
*
aInfo
bool
*
_retval
)
{
nsCOMPtr
<
nsILoadContextInfo
>
info
=
ParseKey
(
aKey
)
;
if
(
!
info
)
{
return
NS_ERROR_FAILURE
;
}
*
_retval
=
info
-
>
Equals
(
aInfo
)
;
return
NS_OK
;
}
ValidityPair
:
:
ValidityPair
(
uint32_t
aOffset
uint32_t
aLen
)
:
mOffset
(
aOffset
)
mLen
(
aLen
)
{
}
bool
ValidityPair
:
:
CanBeMerged
(
const
ValidityPair
&
aOther
)
const
{
return
IsInOrFollows
(
aOther
.
mOffset
)
|
|
aOther
.
IsInOrFollows
(
mOffset
)
;
}
bool
ValidityPair
:
:
IsInOrFollows
(
uint32_t
aOffset
)
const
{
return
mOffset
<
=
aOffset
&
&
mOffset
+
mLen
>
=
aOffset
;
}
bool
ValidityPair
:
:
LessThan
(
const
ValidityPair
&
aOther
)
const
{
if
(
mOffset
<
aOther
.
mOffset
)
{
return
true
;
}
if
(
mOffset
=
=
aOther
.
mOffset
&
&
mLen
<
aOther
.
mLen
)
{
return
true
;
}
return
false
;
}
void
ValidityPair
:
:
Merge
(
const
ValidityPair
&
aOther
)
{
MOZ_ASSERT
(
CanBeMerged
(
aOther
)
)
;
uint32_t
offset
=
std
:
:
min
(
mOffset
aOther
.
mOffset
)
;
uint32_t
end
=
std
:
:
max
(
mOffset
+
mLen
aOther
.
mOffset
+
aOther
.
mLen
)
;
mOffset
=
offset
;
mLen
=
end
-
offset
;
}
void
ValidityMap
:
:
Log
(
)
const
{
LOG
(
(
"
ValidityMap
:
:
Log
(
)
-
number
of
pairs
:
%
zu
"
mMap
.
Length
(
)
)
)
;
for
(
uint32_t
i
=
0
;
i
<
mMap
.
Length
(
)
;
i
+
+
)
{
LOG
(
(
"
(
%
u
%
u
)
"
mMap
[
i
]
.
Offset
(
)
+
0
mMap
[
i
]
.
Len
(
)
+
0
)
)
;
}
}
uint32_t
ValidityMap
:
:
Length
(
)
const
{
return
mMap
.
Length
(
)
;
}
void
ValidityMap
:
:
AddPair
(
uint32_t
aOffset
uint32_t
aLen
)
{
ValidityPair
pair
(
aOffset
aLen
)
;
if
(
mMap
.
Length
(
)
=
=
0
)
{
mMap
.
AppendElement
(
pair
)
;
return
;
}
uint32_t
pos
=
0
;
for
(
pos
=
mMap
.
Length
(
)
;
pos
>
0
;
)
{
-
-
pos
;
if
(
mMap
[
pos
]
.
LessThan
(
pair
)
)
{
if
(
mMap
[
pos
]
.
CanBeMerged
(
pair
)
)
{
mMap
[
pos
]
.
Merge
(
pair
)
;
}
else
{
+
+
pos
;
if
(
pos
=
=
mMap
.
Length
(
)
)
{
mMap
.
AppendElement
(
pair
)
;
}
else
{
mMap
.
InsertElementAt
(
pos
pair
)
;
}
}
break
;
}
if
(
pos
=
=
0
)
{
mMap
.
InsertElementAt
(
0
pair
)
;
}
}
while
(
pos
+
1
<
mMap
.
Length
(
)
)
{
if
(
mMap
[
pos
]
.
CanBeMerged
(
mMap
[
pos
+
1
]
)
)
{
mMap
[
pos
]
.
Merge
(
mMap
[
pos
+
1
]
)
;
mMap
.
RemoveElementAt
(
pos
+
1
)
;
}
else
{
break
;
}
}
}
void
ValidityMap
:
:
Clear
(
)
{
mMap
.
Clear
(
)
;
}
size_t
ValidityMap
:
:
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
mMap
.
ShallowSizeOfExcludingThis
(
mallocSizeOf
)
;
}
ValidityPair
&
ValidityMap
:
:
operator
[
]
(
uint32_t
aIdx
)
{
return
mMap
.
ElementAt
(
aIdx
)
;
}
StaticMutex
DetailedCacheHitTelemetry
:
:
sLock
;
uint32_t
DetailedCacheHitTelemetry
:
:
sRecordCnt
=
0
;
DetailedCacheHitTelemetry
:
:
HitRate
DetailedCacheHitTelemetry
:
:
sHRStats
[
kNumOfRanges
]
;
DetailedCacheHitTelemetry
:
:
HitRate
:
:
HitRate
(
)
{
Reset
(
)
;
}
void
DetailedCacheHitTelemetry
:
:
HitRate
:
:
AddRecord
(
ERecType
aType
)
{
if
(
aType
=
=
HIT
)
{
+
+
mHitCnt
;
}
else
{
+
+
mMissCnt
;
}
}
uint32_t
DetailedCacheHitTelemetry
:
:
HitRate
:
:
GetHitRateBucket
(
uint32_t
aNumOfBuckets
)
const
{
uint32_t
bucketIdx
=
(
aNumOfBuckets
*
mHitCnt
)
/
(
mHitCnt
+
mMissCnt
)
;
if
(
bucketIdx
=
=
aNumOfBuckets
)
{
-
-
bucketIdx
;
}
return
bucketIdx
;
}
uint32_t
DetailedCacheHitTelemetry
:
:
HitRate
:
:
Count
(
)
{
return
mHitCnt
+
mMissCnt
;
}
void
DetailedCacheHitTelemetry
:
:
HitRate
:
:
Reset
(
)
{
mHitCnt
=
0
;
mMissCnt
=
0
;
}
void
DetailedCacheHitTelemetry
:
:
AddRecord
(
ERecType
aType
TimeStamp
aLoadStart
)
{
bool
isUpToDate
=
false
;
CacheIndex
:
:
IsUpToDate
(
&
isUpToDate
)
;
if
(
!
isUpToDate
)
{
return
;
}
uint32_t
entryCount
;
nsresult
rv
=
CacheIndex
:
:
GetEntryFileCount
(
&
entryCount
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
uint32_t
rangeIdx
=
entryCount
/
kRangeSize
;
if
(
rangeIdx
>
=
kNumOfRanges
)
{
rangeIdx
=
kNumOfRanges
-
1
;
}
uint32_t
hitMissValue
=
2
*
rangeIdx
;
if
(
aType
=
=
MISS
)
{
+
+
hitMissValue
;
}
StaticMutexAutoLock
lock
(
sLock
)
;
if
(
aType
=
=
MISS
)
{
mozilla
:
:
Telemetry
:
:
AccumulateTimeDelta
(
mozilla
:
:
Telemetry
:
:
NETWORK_CACHE_V2_MISS_TIME_MS
aLoadStart
)
;
}
else
{
mozilla
:
:
Telemetry
:
:
AccumulateTimeDelta
(
mozilla
:
:
Telemetry
:
:
NETWORK_CACHE_V2_HIT_TIME_MS
aLoadStart
)
;
}
Telemetry
:
:
Accumulate
(
Telemetry
:
:
NETWORK_CACHE_HIT_MISS_STAT_PER_CACHE_SIZE
hitMissValue
)
;
sHRStats
[
rangeIdx
]
.
AddRecord
(
aType
)
;
+
+
sRecordCnt
;
if
(
sRecordCnt
<
kTotalSamplesReportLimit
)
{
return
;
}
sRecordCnt
=
0
;
for
(
uint32_t
i
=
0
;
i
<
kNumOfRanges
;
+
+
i
)
{
if
(
sHRStats
[
i
]
.
Count
(
)
>
=
kHitRateSamplesReportLimit
)
{
uint32_t
bucketOffset
=
sHRStats
[
i
]
.
GetHitRateBucket
(
kHitRateBuckets
)
*
kNumOfRanges
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
NETWORK_CACHE_HIT_RATE_PER_CACHE_SIZE
bucketOffset
+
i
)
;
sHRStats
[
i
]
.
Reset
(
)
;
}
}
}
StaticMutex
CachePerfStats
:
:
sLock
;
CachePerfStats
:
:
PerfData
CachePerfStats
:
:
sData
[
CachePerfStats
:
:
LAST
]
;
uint32_t
CachePerfStats
:
:
sCacheSlowCnt
=
0
;
uint32_t
CachePerfStats
:
:
sCacheNotSlowCnt
=
0
;
CachePerfStats
:
:
MMA
:
:
MMA
(
uint32_t
aTotalWeight
bool
aFilter
)
:
mSum
(
0
)
mSumSq
(
0
)
mCnt
(
0
)
mWeight
(
aTotalWeight
)
mFilter
(
aFilter
)
{
}
void
CachePerfStats
:
:
MMA
:
:
AddValue
(
uint32_t
aValue
)
{
if
(
mFilter
)
{
uint32_t
avg
=
GetAverage
(
)
;
uint32_t
stddev
=
GetStdDev
(
)
;
uint32_t
maxdiff
=
avg
+
(
3
*
stddev
)
;
if
(
avg
&
&
aValue
>
avg
+
maxdiff
)
{
return
;
}
}
if
(
mCnt
<
mWeight
)
{
CheckedInt
<
uint64_t
>
newSumSq
=
CheckedInt
<
uint64_t
>
(
aValue
)
*
aValue
;
newSumSq
+
=
mSumSq
;
if
(
!
newSumSq
.
isValid
(
)
)
{
return
;
}
mSumSq
=
newSumSq
.
value
(
)
;
mSum
+
=
aValue
;
+
+
mCnt
;
}
else
{
CheckedInt
<
uint64_t
>
newSumSq
=
mSumSq
-
mSumSq
/
mCnt
;
newSumSq
+
=
static_cast
<
uint64_t
>
(
aValue
)
*
aValue
;
if
(
!
newSumSq
.
isValid
(
)
)
{
return
;
}
mSumSq
=
newSumSq
.
value
(
)
;
mSum
-
=
GetAverage
(
)
;
mSum
+
=
aValue
;
}
}
uint32_t
CachePerfStats
:
:
MMA
:
:
GetAverage
(
)
{
if
(
mCnt
=
=
0
)
{
return
0
;
}
return
mSum
/
mCnt
;
}
uint32_t
CachePerfStats
:
:
MMA
:
:
GetStdDev
(
)
{
if
(
mCnt
=
=
0
)
{
return
0
;
}
uint32_t
avg
=
GetAverage
(
)
;
uint64_t
avgSq
=
static_cast
<
uint64_t
>
(
avg
)
*
avg
;
uint64_t
variance
=
mSumSq
/
mCnt
;
if
(
variance
<
avgSq
)
{
variance
=
avgSq
;
mSumSq
=
variance
*
mCnt
;
}
variance
-
=
avgSq
;
return
sqrt
(
static_cast
<
double
>
(
variance
)
)
;
}
CachePerfStats
:
:
PerfData
:
:
PerfData
(
)
:
mFilteredAvg
(
50
true
)
mShortAvg
(
3
false
)
{
}
void
CachePerfStats
:
:
PerfData
:
:
AddValue
(
uint32_t
aValue
bool
aShortOnly
)
{
if
(
!
aShortOnly
)
{
mFilteredAvg
.
AddValue
(
aValue
)
;
}
mShortAvg
.
AddValue
(
aValue
)
;
}
uint32_t
CachePerfStats
:
:
PerfData
:
:
GetAverage
(
bool
aFiltered
)
{
return
aFiltered
?
mFilteredAvg
.
GetAverage
(
)
:
mShortAvg
.
GetAverage
(
)
;
}
uint32_t
CachePerfStats
:
:
PerfData
:
:
GetStdDev
(
bool
aFiltered
)
{
return
aFiltered
?
mFilteredAvg
.
GetStdDev
(
)
:
mShortAvg
.
GetStdDev
(
)
;
}
void
CachePerfStats
:
:
AddValue
(
EDataType
aType
uint32_t
aValue
bool
aShortOnly
)
{
StaticMutexAutoLock
lock
(
sLock
)
;
sData
[
aType
]
.
AddValue
(
aValue
aShortOnly
)
;
}
uint32_t
CachePerfStats
:
:
GetAverage
(
EDataType
aType
bool
aFiltered
)
{
StaticMutexAutoLock
lock
(
sLock
)
;
return
sData
[
aType
]
.
GetAverage
(
aFiltered
)
;
}
uint32_t
CachePerfStats
:
:
GetStdDev
(
EDataType
aType
bool
aFiltered
)
{
StaticMutexAutoLock
lock
(
sLock
)
;
return
sData
[
aType
]
.
GetStdDev
(
aFiltered
)
;
}
bool
CachePerfStats
:
:
IsCacheSlow
(
)
{
StaticMutexAutoLock
lock
(
sLock
)
;
for
(
uint32_t
i
=
0
;
i
<
ENTRY_OPEN
;
+
+
i
)
{
if
(
i
=
=
IO_WRITE
)
{
continue
;
}
uint32_t
avgLong
=
sData
[
i
]
.
GetAverage
(
true
)
;
if
(
avgLong
=
=
0
)
{
continue
;
}
uint32_t
avgShort
=
sData
[
i
]
.
GetAverage
(
false
)
;
uint32_t
stddevLong
=
sData
[
i
]
.
GetStdDev
(
true
)
;
uint32_t
maxdiff
=
avgLong
+
(
3
*
stddevLong
)
;
if
(
avgShort
>
avgLong
+
maxdiff
)
{
LOG
(
(
"
CachePerfStats
:
:
IsCacheSlow
(
)
-
result
is
slow
based
on
perf
"
"
type
%
u
[
avgShort
=
%
u
avgLong
=
%
u
stddevLong
=
%
u
]
"
i
avgShort
avgLong
stddevLong
)
)
;
+
+
sCacheSlowCnt
;
return
true
;
}
}
+
+
sCacheNotSlowCnt
;
return
false
;
}
void
CachePerfStats
:
:
GetSlowStats
(
uint32_t
*
aSlow
uint32_t
*
aNotSlow
)
{
*
aSlow
=
sCacheSlowCnt
;
*
aNotSlow
=
sCacheNotSlowCnt
;
}
void
FreeBuffer
(
void
*
aBuf
)
{
#
ifndef
NS_FREE_PERMANENT_DATA
if
(
CacheObserver
:
:
ShuttingDown
(
)
)
{
return
;
}
#
endif
free
(
aBuf
)
;
}
nsresult
ParseAlternativeDataInfo
(
const
char
*
aInfo
int64_t
*
_offset
nsACString
*
_type
)
{
mozilla
:
:
Tokenizer
p
(
aInfo
nullptr
"
/
"
)
;
uint32_t
altDataVersion
=
0
;
int64_t
altDataOffset
=
-
1
;
if
(
!
p
.
ReadInteger
(
&
altDataVersion
)
|
|
altDataVersion
!
=
kAltDataVersion
)
{
LOG
(
(
"
ParseAlternativeDataInfo
(
)
-
altDataVersion
=
%
u
"
"
expectedVersion
=
%
u
"
altDataVersion
kAltDataVersion
)
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
if
(
!
p
.
CheckChar
(
'
;
'
)
|
|
!
p
.
ReadInteger
(
&
altDataOffset
)
|
|
!
p
.
CheckChar
(
'
'
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
if
(
altDataOffset
<
0
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
if
(
_offset
)
{
*
_offset
=
altDataOffset
;
}
if
(
_type
)
{
mozilla
:
:
Unused
<
<
p
.
ReadUntil
(
Tokenizer
:
:
Token
:
:
EndOfFile
(
)
*
_type
)
;
}
return
NS_OK
;
}
void
BuildAlternativeDataInfo
(
const
char
*
aInfo
int64_t
aOffset
nsACString
&
_retval
)
{
_retval
.
Truncate
(
)
;
_retval
.
AppendInt
(
kAltDataVersion
)
;
_retval
.
Append
(
'
;
'
)
;
_retval
.
AppendInt
(
aOffset
)
;
_retval
.
Append
(
'
'
)
;
_retval
.
Append
(
aInfo
)
;
}
}
}
}
