#
include
"
CacheIOThread
.
h
"
#
include
"
CacheFileIOManager
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
mozilla
/
IOInterposer
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
ifdef
XP_WIN
#
include
<
windows
.
h
>
#
endif
#
ifdef
MOZ_TASK_TRACER
#
include
"
GeckoTaskTracer
.
h
"
#
include
"
TracedTaskCommon
.
h
"
#
endif
namespace
mozilla
{
namespace
net
{
namespace
{
class
CacheIOTelemetry
{
public
:
typedef
CacheIOThread
:
:
EventQueue
:
:
size_type
size_type
;
static
size_type
mMinLengthToReport
[
CacheIOThread
:
:
LAST_LEVEL
]
;
static
void
Report
(
uint32_t
aLevel
size_type
aLength
)
;
}
;
static
CacheIOTelemetry
:
:
size_type
const
kGranularity
=
30
;
CacheIOTelemetry
:
:
size_type
CacheIOTelemetry
:
:
mMinLengthToReport
[
CacheIOThread
:
:
LAST_LEVEL
]
=
{
kGranularity
kGranularity
kGranularity
kGranularity
kGranularity
kGranularity
kGranularity
kGranularity
}
;
void
CacheIOTelemetry
:
:
Report
(
uint32_t
aLevel
CacheIOTelemetry
:
:
size_type
aLength
)
{
if
(
mMinLengthToReport
[
aLevel
]
>
aLength
)
{
return
;
}
static
Telemetry
:
:
ID
telemetryID
[
]
=
{
Telemetry
:
:
HTTP_CACHE_IO_QUEUE_2_OPEN_PRIORITY
Telemetry
:
:
HTTP_CACHE_IO_QUEUE_2_READ_PRIORITY
Telemetry
:
:
HTTP_CACHE_IO_QUEUE_2_MANAGEMENT
Telemetry
:
:
HTTP_CACHE_IO_QUEUE_2_OPEN
Telemetry
:
:
HTTP_CACHE_IO_QUEUE_2_READ
Telemetry
:
:
HTTP_CACHE_IO_QUEUE_2_WRITE_PRIORITY
Telemetry
:
:
HTTP_CACHE_IO_QUEUE_2_WRITE
Telemetry
:
:
HTTP_CACHE_IO_QUEUE_2_INDEX
Telemetry
:
:
HTTP_CACHE_IO_QUEUE_2_EVICT
}
;
aLength
=
(
aLength
/
kGranularity
)
;
mMinLengthToReport
[
aLevel
]
=
(
aLength
+
1
)
*
kGranularity
;
aLength
=
std
:
:
min
<
size_type
>
(
aLength
10
)
;
Telemetry
:
:
Accumulate
(
telemetryID
[
aLevel
]
aLength
-
1
)
;
}
}
namespace
detail
{
class
BlockingIOWatcher
{
#
ifdef
XP_WIN
typedef
BOOL
(
WINAPI
*
TCancelSynchronousIo
)
(
HANDLE
hThread
)
;
TCancelSynchronousIo
mCancelSynchronousIo
;
HANDLE
mThread
;
HANDLE
mEvent
;
#
endif
public
:
BlockingIOWatcher
(
)
;
~
BlockingIOWatcher
(
)
;
void
InitThread
(
)
;
void
WatchAndCancel
(
Monitor
&
aMonitor
)
;
void
NotifyOperationDone
(
)
;
}
;
#
ifdef
XP_WIN
BlockingIOWatcher
:
:
BlockingIOWatcher
(
)
:
mCancelSynchronousIo
(
NULL
)
mThread
(
NULL
)
mEvent
(
NULL
)
{
HMODULE
kernel32_dll
=
GetModuleHandle
(
"
kernel32
.
dll
"
)
;
if
(
!
kernel32_dll
)
{
return
;
}
FARPROC
ptr
=
GetProcAddress
(
kernel32_dll
"
CancelSynchronousIo
"
)
;
if
(
!
ptr
)
{
return
;
}
mCancelSynchronousIo
=
reinterpret_cast
<
TCancelSynchronousIo
>
(
ptr
)
;
mEvent
=
:
:
CreateEvent
(
NULL
TRUE
FALSE
NULL
)
;
}
BlockingIOWatcher
:
:
~
BlockingIOWatcher
(
)
{
if
(
mEvent
)
{
CloseHandle
(
mEvent
)
;
}
if
(
mThread
)
{
CloseHandle
(
mThread
)
;
}
}
void
BlockingIOWatcher
:
:
InitThread
(
)
{
BOOL
result
=
:
:
DuplicateHandle
(
GetCurrentProcess
(
)
GetCurrentThread
(
)
GetCurrentProcess
(
)
&
mThread
0
FALSE
DUPLICATE_SAME_ACCESS
)
;
}
void
BlockingIOWatcher
:
:
WatchAndCancel
(
Monitor
&
aMonitor
)
{
if
(
!
mEvent
)
{
return
;
}
:
:
ResetEvent
(
mEvent
)
;
HANDLE
thread
;
{
MonitorAutoLock
lock
(
aMonitor
)
;
thread
=
mThread
;
if
(
!
thread
)
{
return
;
}
}
LOG
(
(
"
Blocking
IO
operation
pending
on
IO
thread
waiting
.
.
.
"
)
)
;
uint32_t
maxLag
=
std
:
:
min
<
uint32_t
>
(
5
CacheObserver
:
:
MaxShutdownIOLag
(
)
)
*
1000
;
DWORD
result
=
:
:
WaitForSingleObject
(
mEvent
maxLag
)
;
if
(
result
=
=
WAIT_TIMEOUT
)
{
LOG
(
(
"
CacheIOThread
:
Attempting
to
cancel
a
long
blocking
IO
operation
"
)
)
;
BOOL
result
=
mCancelSynchronousIo
(
thread
)
;
if
(
result
)
{
LOG
(
(
"
cancelation
signal
succeeded
"
)
)
;
}
else
{
DWORD
error
=
GetLastError
(
)
;
LOG
(
(
"
cancelation
signal
failed
with
GetLastError
=
%
u
"
error
)
)
;
}
}
}
void
BlockingIOWatcher
:
:
NotifyOperationDone
(
)
{
if
(
mEvent
)
{
:
:
SetEvent
(
mEvent
)
;
}
}
#
else
BlockingIOWatcher
:
:
BlockingIOWatcher
(
)
{
}
BlockingIOWatcher
:
:
~
BlockingIOWatcher
(
)
{
}
void
BlockingIOWatcher
:
:
InitThread
(
)
{
}
void
BlockingIOWatcher
:
:
WatchAndCancel
(
Monitor
&
)
{
}
void
BlockingIOWatcher
:
:
NotifyOperationDone
(
)
{
}
#
endif
}
CacheIOThread
*
CacheIOThread
:
:
sSelf
=
nullptr
;
NS_IMPL_ISUPPORTS
(
CacheIOThread
nsIThreadObserver
)
CacheIOThread
:
:
CacheIOThread
(
)
:
mMonitor
(
"
CacheIOThread
"
)
mThread
(
nullptr
)
mXPCOMThread
(
nullptr
)
mLowestLevelWaiting
(
LAST_LEVEL
)
mCurrentlyExecutingLevel
(
0
)
mHasXPCOMEvents
(
false
)
mRerunCurrentEvent
(
false
)
mShutdown
(
false
)
mIOCancelableEvents
(
0
)
#
ifdef
DEBUG
mInsideLoop
(
true
)
#
endif
{
for
(
uint32_t
i
=
0
;
i
<
LAST_LEVEL
;
+
+
i
)
{
mQueueLength
[
i
]
=
0
;
}
sSelf
=
this
;
}
CacheIOThread
:
:
~
CacheIOThread
(
)
{
if
(
mXPCOMThread
)
{
nsIThread
*
thread
=
mXPCOMThread
;
thread
-
>
Release
(
)
;
}
sSelf
=
nullptr
;
#
ifdef
DEBUG
for
(
uint32_t
level
=
0
;
level
<
LAST_LEVEL
;
+
+
level
)
{
MOZ_ASSERT
(
!
mEventQueue
[
level
]
.
Length
(
)
)
;
}
#
endif
}
nsresult
CacheIOThread
:
:
Init
(
)
{
{
MonitorAutoLock
lock
(
mMonitor
)
;
mBlockingIOWatcher
=
MakeUnique
<
detail
:
:
BlockingIOWatcher
>
(
)
;
}
mThread
=
PR_CreateThread
(
PR_USER_THREAD
ThreadFunc
this
PR_PRIORITY_NORMAL
PR_GLOBAL_THREAD
PR_JOINABLE_THREAD
128
*
1024
)
;
if
(
!
mThread
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
nsresult
CacheIOThread
:
:
Dispatch
(
nsIRunnable
*
aRunnable
uint32_t
aLevel
)
{
return
Dispatch
(
do_AddRef
(
aRunnable
)
aLevel
)
;
}
nsresult
CacheIOThread
:
:
Dispatch
(
already_AddRefed
<
nsIRunnable
>
aRunnable
uint32_t
aLevel
)
{
NS_ENSURE_ARG
(
aLevel
<
LAST_LEVEL
)
;
nsCOMPtr
<
nsIRunnable
>
runnable
(
aRunnable
)
;
MOZ_ASSERT
(
runnable
)
;
MonitorAutoLock
lock
(
mMonitor
)
;
if
(
mShutdown
&
&
(
PR_GetCurrentThread
(
)
!
=
mThread
)
)
return
NS_ERROR_UNEXPECTED
;
return
DispatchInternal
(
runnable
.
forget
(
)
aLevel
)
;
}
nsresult
CacheIOThread
:
:
DispatchAfterPendingOpens
(
nsIRunnable
*
aRunnable
)
{
MOZ_ASSERT
(
aRunnable
)
;
MonitorAutoLock
lock
(
mMonitor
)
;
if
(
mShutdown
&
&
(
PR_GetCurrentThread
(
)
!
=
mThread
)
)
return
NS_ERROR_UNEXPECTED
;
mQueueLength
[
OPEN_PRIORITY
]
+
=
mEventQueue
[
OPEN
]
.
Length
(
)
;
mQueueLength
[
OPEN
]
-
=
mEventQueue
[
OPEN
]
.
Length
(
)
;
mEventQueue
[
OPEN_PRIORITY
]
.
AppendElements
(
mEventQueue
[
OPEN
]
)
;
mEventQueue
[
OPEN
]
.
Clear
(
)
;
return
DispatchInternal
(
do_AddRef
(
aRunnable
)
OPEN_PRIORITY
)
;
}
nsresult
CacheIOThread
:
:
DispatchInternal
(
already_AddRefed
<
nsIRunnable
>
aRunnable
uint32_t
aLevel
)
{
nsCOMPtr
<
nsIRunnable
>
runnable
(
aRunnable
)
;
#
ifdef
MOZ_TASK_TRACER
runnable
=
tasktracer
:
:
CreateTracedRunnable
(
runnable
.
forget
(
)
)
;
(
static_cast
<
tasktracer
:
:
TracedRunnable
*
>
(
runnable
.
get
(
)
)
)
-
>
DispatchTask
(
)
;
#
endif
if
(
NS_WARN_IF
(
!
runnable
)
)
return
NS_ERROR_NULL_POINTER
;
mMonitor
.
AssertCurrentThreadOwns
(
)
;
+
+
mQueueLength
[
aLevel
]
;
mEventQueue
[
aLevel
]
.
AppendElement
(
runnable
.
forget
(
)
)
;
if
(
mLowestLevelWaiting
>
aLevel
)
mLowestLevelWaiting
=
aLevel
;
mMonitor
.
NotifyAll
(
)
;
return
NS_OK
;
}
bool
CacheIOThread
:
:
IsCurrentThread
(
)
{
return
mThread
=
=
PR_GetCurrentThread
(
)
;
}
uint32_t
CacheIOThread
:
:
QueueSize
(
bool
highPriority
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
if
(
highPriority
)
{
return
mQueueLength
[
OPEN_PRIORITY
]
+
mQueueLength
[
READ_PRIORITY
]
;
}
return
mQueueLength
[
OPEN_PRIORITY
]
+
mQueueLength
[
READ_PRIORITY
]
+
mQueueLength
[
MANAGEMENT
]
+
mQueueLength
[
OPEN
]
+
mQueueLength
[
READ
]
;
}
bool
CacheIOThread
:
:
YieldInternal
(
)
{
if
(
!
IsCurrentThread
(
)
)
{
NS_WARNING
(
"
Trying
to
yield
to
priority
events
on
non
-
cache2
I
/
O
thread
?
"
"
You
probably
do
something
wrong
.
"
)
;
return
false
;
}
if
(
mCurrentlyExecutingLevel
=
=
XPCOM_LEVEL
)
{
return
false
;
}
if
(
!
EventsPending
(
mCurrentlyExecutingLevel
)
)
return
false
;
mRerunCurrentEvent
=
true
;
return
true
;
}
void
CacheIOThread
:
:
Shutdown
(
)
{
if
(
!
mThread
)
{
return
;
}
{
MonitorAutoLock
lock
(
mMonitor
)
;
mShutdown
=
true
;
mMonitor
.
NotifyAll
(
)
;
}
PR_JoinThread
(
mThread
)
;
mThread
=
nullptr
;
}
void
CacheIOThread
:
:
CancelBlockingIO
(
)
{
if
(
!
mBlockingIOWatcher
)
{
return
;
}
if
(
!
mIOCancelableEvents
)
{
LOG
(
(
"
CacheIOThread
:
:
CancelBlockingIO
no
blocking
operation
to
cancel
"
)
)
;
return
;
}
mBlockingIOWatcher
-
>
WatchAndCancel
(
mMonitor
)
;
}
already_AddRefed
<
nsIEventTarget
>
CacheIOThread
:
:
Target
(
)
{
nsCOMPtr
<
nsIEventTarget
>
target
;
target
=
mXPCOMThread
;
if
(
!
target
&
&
mThread
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
while
(
!
mXPCOMThread
)
{
lock
.
Wait
(
)
;
}
target
=
mXPCOMThread
;
}
return
target
.
forget
(
)
;
}
void
CacheIOThread
:
:
ThreadFunc
(
void
*
aClosure
)
{
PR_SetCurrentThreadName
(
"
Cache2
I
/
O
"
)
;
mozilla
:
:
IOInterposer
:
:
RegisterCurrentThread
(
)
;
CacheIOThread
*
thread
=
static_cast
<
CacheIOThread
*
>
(
aClosure
)
;
thread
-
>
ThreadFunc
(
)
;
mozilla
:
:
IOInterposer
:
:
UnregisterCurrentThread
(
)
;
}
void
CacheIOThread
:
:
ThreadFunc
(
)
{
nsCOMPtr
<
nsIThreadInternal
>
threadInternal
;
{
MonitorAutoLock
lock
(
mMonitor
)
;
MOZ_ASSERT
(
mBlockingIOWatcher
)
;
mBlockingIOWatcher
-
>
InitThread
(
)
;
nsCOMPtr
<
nsIThread
>
xpcomThread
=
NS_GetCurrentThread
(
)
;
threadInternal
=
do_QueryInterface
(
xpcomThread
)
;
if
(
threadInternal
)
threadInternal
-
>
SetObserver
(
this
)
;
mXPCOMThread
=
xpcomThread
.
forget
(
)
.
take
(
)
;
lock
.
NotifyAll
(
)
;
do
{
loopStart
:
mLowestLevelWaiting
=
LAST_LEVEL
;
while
(
mHasXPCOMEvents
)
{
mHasXPCOMEvents
=
false
;
mCurrentlyExecutingLevel
=
XPCOM_LEVEL
;
MonitorAutoUnlock
unlock
(
mMonitor
)
;
bool
processedEvent
;
nsresult
rv
;
do
{
nsIThread
*
thread
=
mXPCOMThread
;
rv
=
thread
-
>
ProcessNextEvent
(
false
&
processedEvent
)
;
MOZ_ASSERT
(
mBlockingIOWatcher
)
;
mBlockingIOWatcher
-
>
NotifyOperationDone
(
)
;
}
while
(
NS_SUCCEEDED
(
rv
)
&
&
processedEvent
)
;
}
uint32_t
level
;
for
(
level
=
0
;
level
<
LAST_LEVEL
;
+
+
level
)
{
if
(
!
mEventQueue
[
level
]
.
Length
(
)
)
{
continue
;
}
LoopOneLevel
(
level
)
;
goto
loopStart
;
}
if
(
EventsPending
(
)
)
{
continue
;
}
if
(
mShutdown
)
{
break
;
}
lock
.
Wait
(
PR_INTERVAL_NO_TIMEOUT
)
;
}
while
(
true
)
;
MOZ_ASSERT
(
!
EventsPending
(
)
)
;
#
ifdef
DEBUG
mInsideLoop
=
false
;
#
endif
}
if
(
threadInternal
)
threadInternal
-
>
SetObserver
(
nullptr
)
;
}
void
CacheIOThread
:
:
LoopOneLevel
(
uint32_t
aLevel
)
{
EventQueue
events
;
events
.
SwapElements
(
mEventQueue
[
aLevel
]
)
;
EventQueue
:
:
size_type
length
=
events
.
Length
(
)
;
mCurrentlyExecutingLevel
=
aLevel
;
bool
returnEvents
=
false
;
bool
reportTelementry
=
true
;
EventQueue
:
:
size_type
index
;
{
MonitorAutoUnlock
unlock
(
mMonitor
)
;
for
(
index
=
0
;
index
<
length
;
+
+
index
)
{
if
(
EventsPending
(
aLevel
)
)
{
returnEvents
=
true
;
break
;
}
if
(
reportTelementry
)
{
reportTelementry
=
false
;
CacheIOTelemetry
:
:
Report
(
aLevel
length
)
;
}
mRerunCurrentEvent
=
false
;
events
[
index
]
-
>
Run
(
)
;
MOZ_ASSERT
(
mBlockingIOWatcher
)
;
mBlockingIOWatcher
-
>
NotifyOperationDone
(
)
;
if
(
mRerunCurrentEvent
)
{
returnEvents
=
true
;
break
;
}
-
-
mQueueLength
[
aLevel
]
;
events
[
index
]
=
nullptr
;
}
}
if
(
returnEvents
)
mEventQueue
[
aLevel
]
.
InsertElementsAt
(
0
events
.
Elements
(
)
+
index
length
-
index
)
;
}
bool
CacheIOThread
:
:
EventsPending
(
uint32_t
aLastLevel
)
{
return
mLowestLevelWaiting
<
aLastLevel
|
|
mHasXPCOMEvents
;
}
NS_IMETHODIMP
CacheIOThread
:
:
OnDispatchedEvent
(
nsIThreadInternal
*
thread
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
mHasXPCOMEvents
=
true
;
MOZ_ASSERT
(
mInsideLoop
)
;
lock
.
Notify
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
CacheIOThread
:
:
OnProcessNextEvent
(
nsIThreadInternal
*
thread
bool
mayWait
)
{
return
NS_OK
;
}
NS_IMETHODIMP
CacheIOThread
:
:
AfterProcessNextEvent
(
nsIThreadInternal
*
thread
bool
eventWasProcessed
)
{
return
NS_OK
;
}
size_t
CacheIOThread
:
:
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
MonitorAutoLock
lock
(
const_cast
<
CacheIOThread
*
>
(
this
)
-
>
mMonitor
)
;
size_t
n
=
0
;
n
+
=
mallocSizeOf
(
mThread
)
;
for
(
uint32_t
level
=
0
;
level
<
LAST_LEVEL
;
+
+
level
)
{
n
+
=
mEventQueue
[
level
]
.
ShallowSizeOfExcludingThis
(
mallocSizeOf
)
;
}
return
n
;
}
size_t
CacheIOThread
:
:
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
mallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
mallocSizeOf
)
;
}
CacheIOThread
:
:
Cancelable
:
:
Cancelable
(
bool
aCancelable
)
:
mCancelable
(
aCancelable
)
{
MOZ_ASSERT
(
CacheIOThread
:
:
sSelf
)
;
MOZ_ASSERT
(
CacheIOThread
:
:
sSelf
-
>
IsCurrentThread
(
)
)
;
if
(
mCancelable
)
{
+
+
CacheIOThread
:
:
sSelf
-
>
mIOCancelableEvents
;
}
}
CacheIOThread
:
:
Cancelable
:
:
~
Cancelable
(
)
{
MOZ_ASSERT
(
CacheIOThread
:
:
sSelf
)
;
if
(
mCancelable
)
{
-
-
CacheIOThread
:
:
sSelf
-
>
mIOCancelableEvents
;
}
}
}
}
