#
include
"
CacheIOThread
.
h
"
#
include
"
CacheFileIOManager
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
mozilla
/
IOInterposer
.
h
"
namespace
mozilla
{
namespace
net
{
namespace
{
class
CacheIOTelemetry
{
public
:
typedef
CacheIOThread
:
:
EventQueue
:
:
size_type
size_type
;
static
size_type
mMinLengthToReport
[
CacheIOThread
:
:
LAST_LEVEL
]
;
static
void
Report
(
uint32_t
aLevel
uint32_t
aLength
)
;
}
;
static
CacheIOTelemetry
:
:
size_type
const
kGranularity
=
30
;
uint32_t
CacheIOTelemetry
:
:
mMinLengthToReport
[
CacheIOThread
:
:
LAST_LEVEL
]
=
{
kGranularity
kGranularity
kGranularity
kGranularity
kGranularity
kGranularity
kGranularity
kGranularity
}
;
void
CacheIOTelemetry
:
:
Report
(
uint32_t
aLevel
size_type
aLength
)
{
if
(
mMinLengthToReport
[
aLevel
]
>
aLength
)
{
return
;
}
static
Telemetry
:
:
ID
telemetryID
[
]
=
{
Telemetry
:
:
HTTP_CACHE_IO_QUEUE_OPEN_PRIORITY
Telemetry
:
:
HTTP_CACHE_IO_QUEUE_READ_PRIORITY
Telemetry
:
:
HTTP_CACHE_IO_QUEUE_OPEN
Telemetry
:
:
HTTP_CACHE_IO_QUEUE_READ
Telemetry
:
:
HTTP_CACHE_IO_QUEUE_MANAGEMENT
Telemetry
:
:
HTTP_CACHE_IO_QUEUE_WRITE
Telemetry
:
:
HTTP_CACHE_IO_QUEUE_INDEX
Telemetry
:
:
HTTP_CACHE_IO_QUEUE_EVICT
}
;
aLength
=
(
aLength
/
kGranularity
)
;
mMinLengthToReport
[
aLevel
]
=
(
aLength
+
1
)
*
kGranularity
;
aLength
=
std
:
:
min
<
size_type
>
(
aLength
10
)
;
Telemetry
:
:
Accumulate
(
telemetryID
[
aLevel
]
aLength
-
1
)
;
}
}
CacheIOThread
*
CacheIOThread
:
:
sSelf
=
nullptr
;
NS_IMPL_ISUPPORTS
(
CacheIOThread
nsIThreadObserver
)
CacheIOThread
:
:
CacheIOThread
(
)
:
mMonitor
(
"
CacheIOThread
"
)
mThread
(
nullptr
)
mXPCOMThread
(
nullptr
)
mLowestLevelWaiting
(
LAST_LEVEL
)
mCurrentlyExecutingLevel
(
0
)
mHasXPCOMEvents
(
false
)
mRerunCurrentEvent
(
false
)
mShutdown
(
false
)
#
ifdef
DEBUG
mInsideLoop
(
true
)
#
endif
{
sSelf
=
this
;
}
CacheIOThread
:
:
~
CacheIOThread
(
)
{
if
(
mXPCOMThread
)
{
nsIThread
*
thread
=
mXPCOMThread
;
thread
-
>
Release
(
)
;
}
sSelf
=
nullptr
;
#
ifdef
DEBUG
for
(
uint32_t
level
=
0
;
level
<
LAST_LEVEL
;
+
+
level
)
{
MOZ_ASSERT
(
!
mEventQueue
[
level
]
.
Length
(
)
)
;
}
#
endif
}
nsresult
CacheIOThread
:
:
Init
(
)
{
mThread
=
PR_CreateThread
(
PR_USER_THREAD
ThreadFunc
this
PR_PRIORITY_NORMAL
PR_GLOBAL_THREAD
PR_JOINABLE_THREAD
128
*
1024
)
;
if
(
!
mThread
)
return
NS_ERROR_FAILURE
;
return
NS_OK
;
}
nsresult
CacheIOThread
:
:
Dispatch
(
nsIRunnable
*
aRunnable
uint32_t
aLevel
)
{
NS_ENSURE_ARG
(
aLevel
<
LAST_LEVEL
)
;
MOZ_ASSERT
(
aRunnable
)
;
MonitorAutoLock
lock
(
mMonitor
)
;
if
(
mShutdown
&
&
(
PR_GetCurrentThread
(
)
!
=
mThread
)
)
return
NS_ERROR_UNEXPECTED
;
return
DispatchInternal
(
aRunnable
aLevel
)
;
}
nsresult
CacheIOThread
:
:
DispatchAfterPendingOpens
(
nsIRunnable
*
aRunnable
)
{
MOZ_ASSERT
(
aRunnable
)
;
MonitorAutoLock
lock
(
mMonitor
)
;
if
(
mShutdown
&
&
(
PR_GetCurrentThread
(
)
!
=
mThread
)
)
return
NS_ERROR_UNEXPECTED
;
mEventQueue
[
OPEN_PRIORITY
]
.
AppendElements
(
mEventQueue
[
OPEN
]
)
;
mEventQueue
[
OPEN
]
.
Clear
(
)
;
return
DispatchInternal
(
aRunnable
OPEN_PRIORITY
)
;
}
nsresult
CacheIOThread
:
:
DispatchInternal
(
nsIRunnable
*
aRunnable
uint32_t
aLevel
)
{
if
(
NS_WARN_IF
(
!
aRunnable
)
)
return
NS_ERROR_NULL_POINTER
;
mMonitor
.
AssertCurrentThreadOwns
(
)
;
mEventQueue
[
aLevel
]
.
AppendElement
(
aRunnable
)
;
if
(
mLowestLevelWaiting
>
aLevel
)
mLowestLevelWaiting
=
aLevel
;
mMonitor
.
NotifyAll
(
)
;
return
NS_OK
;
}
bool
CacheIOThread
:
:
IsCurrentThread
(
)
{
return
mThread
=
=
PR_GetCurrentThread
(
)
;
}
bool
CacheIOThread
:
:
YieldInternal
(
)
{
if
(
!
IsCurrentThread
(
)
)
{
NS_WARNING
(
"
Trying
to
yield
to
priority
events
on
non
-
cache2
I
/
O
thread
?
"
"
You
probably
do
something
wrong
.
"
)
;
return
false
;
}
if
(
mCurrentlyExecutingLevel
=
=
XPCOM_LEVEL
)
{
return
false
;
}
if
(
!
EventsPending
(
mCurrentlyExecutingLevel
)
)
return
false
;
mRerunCurrentEvent
=
true
;
return
true
;
}
nsresult
CacheIOThread
:
:
Shutdown
(
)
{
{
MonitorAutoLock
lock
(
mMonitor
)
;
mShutdown
=
true
;
mMonitor
.
NotifyAll
(
)
;
}
PR_JoinThread
(
mThread
)
;
mThread
=
nullptr
;
return
NS_OK
;
}
already_AddRefed
<
nsIEventTarget
>
CacheIOThread
:
:
Target
(
)
{
nsCOMPtr
<
nsIEventTarget
>
target
;
target
=
mXPCOMThread
;
if
(
!
target
&
&
mThread
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
while
(
!
mXPCOMThread
)
{
lock
.
Wait
(
)
;
}
target
=
mXPCOMThread
;
}
return
target
.
forget
(
)
;
}
void
CacheIOThread
:
:
ThreadFunc
(
void
*
aClosure
)
{
PR_SetCurrentThreadName
(
"
Cache2
I
/
O
"
)
;
mozilla
:
:
IOInterposer
:
:
RegisterCurrentThread
(
)
;
CacheIOThread
*
thread
=
static_cast
<
CacheIOThread
*
>
(
aClosure
)
;
thread
-
>
ThreadFunc
(
)
;
mozilla
:
:
IOInterposer
:
:
UnregisterCurrentThread
(
)
;
}
void
CacheIOThread
:
:
ThreadFunc
(
)
{
nsCOMPtr
<
nsIThreadInternal
>
threadInternal
;
{
MonitorAutoLock
lock
(
mMonitor
)
;
nsCOMPtr
<
nsIThread
>
xpcomThread
=
NS_GetCurrentThread
(
)
;
threadInternal
=
do_QueryInterface
(
xpcomThread
)
;
if
(
threadInternal
)
threadInternal
-
>
SetObserver
(
this
)
;
mXPCOMThread
=
xpcomThread
.
forget
(
)
.
take
(
)
;
lock
.
NotifyAll
(
)
;
do
{
loopStart
:
mLowestLevelWaiting
=
LAST_LEVEL
;
while
(
mHasXPCOMEvents
)
{
mHasXPCOMEvents
=
false
;
mCurrentlyExecutingLevel
=
XPCOM_LEVEL
;
MonitorAutoUnlock
unlock
(
mMonitor
)
;
bool
processedEvent
;
nsresult
rv
;
do
{
nsIThread
*
thread
=
mXPCOMThread
;
rv
=
thread
-
>
ProcessNextEvent
(
false
&
processedEvent
)
;
}
while
(
NS_SUCCEEDED
(
rv
)
&
&
processedEvent
)
;
}
uint32_t
level
;
for
(
level
=
0
;
level
<
LAST_LEVEL
;
+
+
level
)
{
if
(
!
mEventQueue
[
level
]
.
Length
(
)
)
{
continue
;
}
LoopOneLevel
(
level
)
;
goto
loopStart
;
}
if
(
EventsPending
(
)
)
continue
;
if
(
mShutdown
)
break
;
lock
.
Wait
(
PR_INTERVAL_NO_TIMEOUT
)
;
if
(
EventsPending
(
)
)
continue
;
}
while
(
true
)
;
MOZ_ASSERT
(
!
EventsPending
(
)
)
;
#
ifdef
DEBUG
mInsideLoop
=
false
;
#
endif
}
if
(
threadInternal
)
threadInternal
-
>
SetObserver
(
nullptr
)
;
}
void
CacheIOThread
:
:
LoopOneLevel
(
uint32_t
aLevel
)
{
EventQueue
events
;
events
.
SwapElements
(
mEventQueue
[
aLevel
]
)
;
EventQueue
:
:
size_type
length
=
events
.
Length
(
)
;
mCurrentlyExecutingLevel
=
aLevel
;
bool
returnEvents
=
false
;
bool
reportTelementry
=
true
;
EventQueue
:
:
size_type
index
;
{
MonitorAutoUnlock
unlock
(
mMonitor
)
;
for
(
index
=
0
;
index
<
length
;
+
+
index
)
{
if
(
EventsPending
(
aLevel
)
)
{
returnEvents
=
true
;
break
;
}
if
(
reportTelementry
)
{
reportTelementry
=
false
;
CacheIOTelemetry
:
:
Report
(
aLevel
length
)
;
}
mRerunCurrentEvent
=
false
;
events
[
index
]
-
>
Run
(
)
;
if
(
mRerunCurrentEvent
)
{
returnEvents
=
true
;
break
;
}
events
[
index
]
=
nullptr
;
}
}
if
(
returnEvents
)
mEventQueue
[
aLevel
]
.
InsertElementsAt
(
0
events
.
Elements
(
)
+
index
length
-
index
)
;
}
bool
CacheIOThread
:
:
EventsPending
(
uint32_t
aLastLevel
)
{
return
mLowestLevelWaiting
<
aLastLevel
|
|
mHasXPCOMEvents
;
}
NS_IMETHODIMP
CacheIOThread
:
:
OnDispatchedEvent
(
nsIThreadInternal
*
thread
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
mHasXPCOMEvents
=
true
;
MOZ_ASSERT
(
mInsideLoop
)
;
lock
.
Notify
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
CacheIOThread
:
:
OnProcessNextEvent
(
nsIThreadInternal
*
thread
bool
mayWait
)
{
return
NS_OK
;
}
NS_IMETHODIMP
CacheIOThread
:
:
AfterProcessNextEvent
(
nsIThreadInternal
*
thread
bool
eventWasProcessed
)
{
return
NS_OK
;
}
size_t
CacheIOThread
:
:
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
MonitorAutoLock
lock
(
const_cast
<
CacheIOThread
*
>
(
this
)
-
>
mMonitor
)
;
size_t
n
=
0
;
n
+
=
mallocSizeOf
(
mThread
)
;
for
(
uint32_t
level
=
0
;
level
<
LAST_LEVEL
;
+
+
level
)
{
n
+
=
mEventQueue
[
level
]
.
ShallowSizeOfExcludingThis
(
mallocSizeOf
)
;
}
return
n
;
}
size_t
CacheIOThread
:
:
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
mallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
mallocSizeOf
)
;
}
}
}
