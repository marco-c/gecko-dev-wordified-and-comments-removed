#
ifndef
mozilla_net_Dictionary_h
#
define
mozilla_net_Dictionary_h
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsICacheEntry
.
h
"
#
include
"
nsICacheEntryOpenCallback
.
h
"
#
include
"
nsICacheStorageService
.
h
"
#
include
"
nsICacheStorageVisitor
.
h
"
#
include
"
nsICryptoHash
.
h
"
#
include
"
nsIInterfaceRequestor
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsIStreamListener
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
mozilla
/
dom
/
RequestBinding
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
nsTHashMap
.
h
"
#
include
"
nsHashKeys
.
h
"
class
nsICacheStorage
;
class
nsIIOService
;
class
nsILoadContextInfo
;
static
const
uint32_t
METADATA_DICTIONARY_VERSION
=
1
;
#
define
META_DICTIONARY_PREFIX
"
dict
:
"
_ns
namespace
mozilla
{
namespace
net
{
class
DictionaryOrigin
;
class
DictionaryCacheEntry
final
:
public
nsICacheEntryOpenCallback
public
nsIStreamListener
{
friend
class
DictionaryOrigin
;
private
:
~
DictionaryCacheEntry
(
)
{
MOZ_ASSERT
(
mUsers
=
=
0
)
;
}
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSICACHEENTRYOPENCALLBACK
NS_DECL_NSIREQUESTOBSERVER
NS_DECL_NSISTREAMLISTENER
DictionaryCacheEntry
(
const
char
*
aKey
)
;
DictionaryCacheEntry
(
const
nsACString
&
aKey
const
nsACString
&
aPattern
nsTArray
<
nsCString
>
&
aMatchDest
const
nsACString
&
aId
uint32_t
aExpiration
=
0
const
Maybe
<
nsCString
>
&
aHash
=
Nothing
(
)
)
;
static
void
ConvertMatchDestToEnumArray
(
const
nsTArray
<
nsCString
>
&
aMatchDest
nsTArray
<
dom
:
:
RequestDestination
>
&
aMatchEnums
)
;
bool
Match
(
const
nsACString
&
aFilePath
ExtContentPolicyType
aType
uint32_t
aNow
uint32_t
&
aLongest
)
;
nsresult
Prefetch
(
nsILoadContextInfo
*
aLoadContextInfo
bool
&
aShouldSuspend
const
std
:
:
function
<
void
(
)
>
&
aFunc
)
;
const
nsACString
&
GetHash
(
)
const
{
return
mHash
;
}
bool
HasHash
(
)
{
return
!
mHash
.
IsEmpty
(
)
;
}
void
SetHash
(
const
nsACString
&
aHash
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mHash
=
aHash
;
}
void
WriteOnHash
(
)
;
void
SetOrigin
(
DictionaryOrigin
*
aOrigin
)
{
mOrigin
=
aOrigin
;
}
const
nsCString
&
GetId
(
)
const
{
return
mId
;
}
void
InUse
(
)
;
void
UseCompleted
(
)
;
bool
IsReading
(
)
const
{
return
mUsers
>
0
&
&
!
mWaitingPrefetch
.
IsEmpty
(
)
;
}
void
SetReplacement
(
DictionaryCacheEntry
*
aEntry
DictionaryOrigin
*
aOrigin
)
{
mReplacement
=
aEntry
;
mOrigin
=
aOrigin
;
if
(
mReplacement
)
{
mReplacement
-
>
mShouldSuspend
=
true
;
mReplacement
-
>
mBlocked
=
true
;
}
}
bool
ShouldSuspendUntilCacheRead
(
)
const
{
return
mShouldSuspend
;
}
void
CallbackOnCacheRead
(
const
std
:
:
function
<
void
(
)
>
&
aFunc
)
{
mWaitingPrefetch
.
AppendElement
(
aFunc
)
;
}
const
nsACString
&
GetURI
(
)
const
{
return
mURI
;
}
void
Clear
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mHash
.
Truncate
(
0
)
;
mDictionaryData
.
clear
(
)
;
mDictionaryDataComplete
=
false
;
MOZ_ASSERT
(
mWaitingPrefetch
.
IsEmpty
(
)
)
;
}
const
Vector
<
uint8_t
>
&
GetDictionary
(
)
const
{
return
mDictionaryData
;
}
void
AccumulateHash
(
const
char
*
aBuf
int32_t
aCount
)
;
void
FinishHash
(
)
;
uint8_t
*
DictionaryData
(
size_t
*
aLength
)
const
{
*
aLength
=
mDictionaryData
.
length
(
)
;
return
(
uint8_t
*
)
mDictionaryData
.
begin
(
)
;
}
bool
DictionaryReady
(
)
const
{
return
mDictionaryDataComplete
;
}
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
mallocSizeOf
(
this
)
;
}
static
nsresult
ReadCacheData
(
nsIInputStream
*
aInStream
void
*
aClosure
const
char
*
aFromSegment
uint32_t
aToOffset
uint32_t
aCount
uint32_t
*
aWriteCount
)
;
void
MakeMetadataEntry
(
nsCString
&
aNewValue
)
;
nsresult
Write
(
nsICacheEntry
*
aEntry
)
;
nsresult
RemoveEntry
(
nsICacheEntry
*
aCacheEntry
)
;
bool
ParseMetadata
(
const
char
*
aSrc
)
;
void
CopyFrom
(
DictionaryCacheEntry
*
aOther
)
{
mURI
=
aOther
-
>
mURI
;
mPattern
=
aOther
-
>
mPattern
;
mId
=
aOther
-
>
mId
;
}
void
UnblockAddEntry
(
DictionaryOrigin
*
aOrigin
)
;
private
:
nsCString
mURI
;
uint32_t
mExpiration
{
0
}
;
nsCString
mPattern
;
nsCString
mId
;
nsTArray
<
dom
:
:
RequestDestination
>
mMatchDest
;
nsCString
mHash
;
uint32_t
mUsers
{
0
}
;
Vector
<
uint8_t
>
mDictionaryData
;
bool
mDictionaryDataComplete
{
false
}
;
nsCOMPtr
<
nsICryptoHash
>
mCrypto
;
nsTArray
<
std
:
:
function
<
void
(
)
>
>
mWaitingPrefetch
;
RefPtr
<
DictionaryOrigin
>
mOrigin
;
bool
mStopReceived
{
false
}
;
RefPtr
<
DictionaryCacheEntry
>
mReplacement
;
bool
mShouldSuspend
{
false
}
;
bool
mNotCached
{
false
}
;
bool
mBlocked
{
false
}
;
}
;
class
DictionaryCache
;
class
DictionaryOriginReader
final
:
public
nsICacheEntryOpenCallback
public
nsIStreamListener
{
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSICACHEENTRYOPENCALLBACK
NS_DECL_NSIREQUESTOBSERVER
NS_DECL_NSISTREAMLISTENER
DictionaryOriginReader
(
)
{
}
void
Start
(
DictionaryOrigin
*
aOrigin
nsACString
&
aKey
nsIURI
*
aURI
ExtContentPolicyType
aType
DictionaryCache
*
aCache
const
std
:
:
function
<
nsresult
(
bool
DictionaryCacheEntry
*
)
>
&
aCallback
)
;
void
FinishMatch
(
)
;
private
:
~
DictionaryOriginReader
(
)
{
}
RefPtr
<
DictionaryOrigin
>
mOrigin
;
nsCOMPtr
<
nsIURI
>
mURI
;
ExtContentPolicyType
mType
;
std
:
:
function
<
nsresult
(
bool
DictionaryCacheEntry
*
)
>
mCallback
;
RefPtr
<
DictionaryCache
>
mCache
;
}
;
using
DictCacheList
=
nsTArray
<
RefPtr
<
DictionaryCacheEntry
>
>
;
class
DictionaryOrigin
:
public
nsICacheEntryMetaDataVisitor
{
friend
class
DictionaryCache
;
friend
class
DictionaryOriginReader
;
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSICACHEENTRYMETADATAVISITOR
DictionaryOrigin
(
const
nsACString
&
aOrigin
nsICacheEntry
*
aEntry
)
:
mOrigin
(
aOrigin
)
mEntry
(
aEntry
)
{
}
void
SetCacheEntry
(
nsICacheEntry
*
aEntry
)
;
nsresult
Write
(
DictionaryCacheEntry
*
aDictEntry
)
;
already_AddRefed
<
DictionaryCacheEntry
>
AddEntry
(
DictionaryCacheEntry
*
aDictEntry
bool
aNewEntry
)
;
nsresult
RemoveEntry
(
const
nsACString
&
aKey
)
;
void
RemoveEntry
(
DictionaryCacheEntry
*
aEntry
)
;
DictionaryCacheEntry
*
Match
(
const
nsACString
&
path
ExtContentPolicyType
aType
)
;
void
FinishAddEntry
(
DictionaryCacheEntry
*
aEntry
)
;
void
DumpEntries
(
)
;
void
Clear
(
)
;
private
:
virtual
~
DictionaryOrigin
(
)
{
}
nsCString
mOrigin
;
nsCOMPtr
<
nsICacheEntry
>
mEntry
;
DictCacheList
mEntries
;
DictCacheList
mPendingEntries
;
DictCacheList
mPendingRemove
;
bool
mDeferredWrites
{
false
}
;
nsTArray
<
RefPtr
<
DictionaryOriginReader
>
>
mWaitingCacheRead
;
}
;
class
DictionaryCache
final
{
private
:
DictionaryCache
(
)
{
nsresult
rv
=
Init
(
)
;
Unused
<
<
rv
;
MOZ_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
~
DictionaryCache
(
)
{
}
friend
class
DictionaryOriginReader
;
friend
class
DictionaryCacheEntry
;
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
DictionaryCache
)
static
already_AddRefed
<
DictionaryCache
>
GetInstance
(
)
;
nsresult
Init
(
)
;
nsresult
AddEntry
(
nsIURI
*
aURI
const
nsACString
&
aKey
const
nsACString
&
aPattern
nsTArray
<
nsCString
>
&
aMatchDest
const
nsACString
&
aId
const
Maybe
<
nsCString
>
&
aHash
bool
aNewEntry
uint32_t
aExpiration
DictionaryCacheEntry
*
*
aDictEntry
)
;
already_AddRefed
<
DictionaryCacheEntry
>
AddEntry
(
nsIURI
*
aURI
bool
aNewEntry
DictionaryCacheEntry
*
aDictEntry
)
;
static
void
RemoveDictionaryFor
(
const
nsACString
&
aKey
)
;
void
RemoveDictionary
(
const
nsACString
&
aKey
)
;
nsresult
RemoveEntry
(
nsIURI
*
aURI
const
nsACString
&
aKey
)
;
static
void
RemoveDictionaries
(
nsIURI
*
aURI
)
;
static
void
RemoveAllDictionaries
(
)
;
void
Clear
(
)
;
void
GetDictionaryFor
(
nsIURI
*
aURI
ExtContentPolicyType
aType
bool
&
aAsync
const
std
:
:
function
<
nsresult
(
bool
DictionaryCacheEntry
*
)
>
&
aCallback
)
;
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
mallocSizeOf
(
this
)
;
}
private
:
static
nsCOMPtr
<
nsICacheStorage
>
sCacheStorage
;
nsTHashMap
<
nsCStringHashKey
RefPtr
<
DictionaryOrigin
>
>
mDictionaryCache
;
}
;
}
}
#
endif
