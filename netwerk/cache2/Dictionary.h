#
ifndef
mozilla_net_Dictionary_h
#
define
mozilla_net_Dictionary_h
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsICacheEntry
.
h
"
#
include
"
nsICacheEntryOpenCallback
.
h
"
#
include
"
nsICacheStorageService
.
h
"
#
include
"
nsICacheStorageVisitor
.
h
"
#
include
"
nsICryptoHash
.
h
"
#
include
"
nsIInterfaceRequestor
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsIStreamListener
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
class
nsICacheStorage
;
class
nsIIOService
;
class
nsILoadContextInfo
;
class
nsITimer
;
namespace
mozilla
{
namespace
net
{
class
DictionaryCacheEntry
final
:
public
LinkedListElement
<
RefPtr
<
DictionaryCacheEntry
>
>
{
private
:
~
DictionaryCacheEntry
(
)
{
MOZ_ASSERT
(
mUsers
=
=
0
)
;
}
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
DictionaryCacheEntry
)
DictionaryCacheEntry
(
const
nsACString
&
aKey
const
nsACString
&
aPattern
const
nsACString
&
aId
const
Maybe
<
nsCString
>
&
aHash
=
Nothing
(
)
)
;
bool
Match
(
const
nsACString
&
aFilePath
uint32_t
&
aLongest
)
;
void
Prefetch
(
)
;
const
nsACString
&
GetHash
(
)
const
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
mHash
;
}
void
SetHash
(
const
nsACString
&
aHash
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mHash
=
aHash
;
}
bool
Valid
(
)
const
{
return
!
mHash
.
IsEmpty
(
)
;
}
const
nsCString
&
GetId
(
)
const
{
return
mId
;
}
void
InUse
(
)
{
mUsers
+
+
;
}
void
UseCompleted
(
)
{
MOZ_ASSERT
(
mUsers
>
0
)
;
mUsers
-
-
;
}
const
nsACString
&
GetURI
(
)
const
{
return
mURI
;
}
void
Clear
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mHash
.
Truncate
(
0
)
;
mDictionaryData
.
clear
(
)
;
}
const
Vector
<
uint8_t
>
&
GetDictionary
(
)
const
{
return
mDictionaryData
;
}
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
mallocSizeOf
(
this
)
;
}
private
:
nsCString
mURI
;
nsCString
mPattern
;
nsCString
mId
;
nsCString
mHash
;
uint32_t
mUsers
{
0
}
;
Vector
<
uint8_t
>
mDictionaryData
;
nsCOMPtr
<
nsICryptoHash
>
mCrypto
;
}
;
using
DictCacheList
=
AutoCleanLinkedList
<
RefPtr
<
DictionaryCacheEntry
>
>
;
class
DictionaryCache
final
{
private
:
DictionaryCache
(
)
{
}
;
~
DictionaryCache
(
)
{
}
;
public
:
NS_INLINE_DECL_REFCOUNTING
(
DictionaryCache
)
static
already_AddRefed
<
DictionaryCache
>
GetInstance
(
)
;
nsresult
Init
(
)
;
nsresult
AddEntry
(
nsIURI
*
aURI
const
nsACString
&
aKey
const
nsACString
&
aPattern
const
nsACString
&
aId
const
Maybe
<
nsCString
>
&
aHash
DictionaryCacheEntry
*
*
aDictEntry
)
;
nsresult
AddEntry
(
nsIURI
*
aURI
DictionaryCacheEntry
*
aDictEntry
)
;
nsresult
RemoveEntry
(
nsIURI
*
aURI
const
nsACString
&
aKey
)
;
already_AddRefed
<
DictionaryCacheEntry
>
GetDictionaryFor
(
nsIURI
*
aURI
)
;
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
mallocSizeOf
(
this
)
;
}
private
:
nsTHashMap
<
nsCStringHashKey
UniquePtr
<
DictCacheList
>
>
mDictionaryCache
;
}
;
}
}
#
endif
