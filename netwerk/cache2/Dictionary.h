#
ifndef
mozilla_net_Dictionary_h
#
define
mozilla_net_Dictionary_h
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsICacheEntry
.
h
"
#
include
"
nsICacheEntryOpenCallback
.
h
"
#
include
"
nsICacheStorageService
.
h
"
#
include
"
nsICacheStorageVisitor
.
h
"
#
include
"
nsICryptoHash
.
h
"
#
include
"
nsIInterfaceRequestor
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsIStreamListener
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
nsTHashMap
.
h
"
#
include
"
nsHashKeys
.
h
"
class
nsICacheStorage
;
class
nsIIOService
;
class
nsILoadContextInfo
;
class
nsITimer
;
static
const
uint32_t
METADATA_DICTIONARY_VERSION
=
1
;
#
define
META_DICTIONARY_PREFIX
"
dict
:
"
_ns
namespace
mozilla
{
namespace
net
{
class
DictionaryCacheEntry
final
:
public
LinkedListElement
<
RefPtr
<
DictionaryCacheEntry
>
>
public
nsICacheEntryOpenCallback
public
nsIStreamListener
{
private
:
~
DictionaryCacheEntry
(
)
{
MOZ_ASSERT
(
mUsers
=
=
0
)
;
MOZ_ASSERT
(
!
isInList
(
)
)
;
}
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSICACHEENTRYOPENCALLBACK
NS_DECL_NSIREQUESTOBSERVER
NS_DECL_NSISTREAMLISTENER
DictionaryCacheEntry
(
const
nsACString
&
aKey
const
nsACString
&
aPattern
const
nsACString
&
aId
const
Maybe
<
nsCString
>
&
aHash
=
Nothing
(
)
)
;
bool
Match
(
const
nsACString
&
aFilePath
uint32_t
&
aLongest
)
;
bool
Prefetch
(
nsILoadContextInfo
*
aLoadContextInfo
const
std
:
:
function
<
void
(
)
>
&
aFunc
)
;
const
nsACString
&
GetHash
(
)
const
{
return
mHash
;
}
void
SetHash
(
const
nsACString
&
aHash
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mHash
=
aHash
;
}
const
nsCString
&
GetId
(
)
const
{
return
mId
;
}
void
InUse
(
)
;
void
UseCompleted
(
)
;
const
nsACString
&
GetURI
(
)
const
{
return
mURI
;
}
void
Clear
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mHash
.
Truncate
(
0
)
;
mDictionaryData
.
clear
(
)
;
mDictionaryDataComplete
=
false
;
MOZ_ASSERT
(
mWaitingPrefetch
.
IsEmpty
(
)
)
;
}
const
Vector
<
uint8_t
>
&
GetDictionary
(
)
const
{
return
mDictionaryData
;
}
void
AccumulateHash
(
const
char
*
aBuf
int32_t
aCount
)
;
void
AccumulateFile
(
const
char
*
aBuf
int32_t
aCount
)
;
void
FinishFile
(
)
;
uint8_t
*
DictionaryData
(
size_t
*
aLength
)
const
{
*
aLength
=
mDictionaryData
.
length
(
)
;
return
(
uint8_t
*
)
mDictionaryData
.
begin
(
)
;
}
bool
DictionaryReady
(
)
const
{
return
mDictionaryDataComplete
;
}
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
mallocSizeOf
(
this
)
;
}
static
nsresult
ReadCacheData
(
nsIInputStream
*
aInStream
void
*
aClosure
const
char
*
aFromSegment
uint32_t
aToOffset
uint32_t
aCount
uint32_t
*
aWriteCount
)
;
private
:
nsCString
mURI
;
nsCString
mPattern
;
nsCString
mId
;
nsCString
mHash
;
uint32_t
mUsers
{
0
}
;
Vector
<
uint8_t
>
mDictionaryData
;
bool
mDictionaryDataComplete
{
false
}
;
nsCOMPtr
<
nsICryptoHash
>
mCrypto
;
nsTArray
<
std
:
:
function
<
void
(
)
>
>
mWaitingPrefetch
;
}
;
using
DictCacheList
=
AutoCleanLinkedList
<
RefPtr
<
DictionaryCacheEntry
>
>
;
class
DictionaryOriginReader
;
class
DictionaryCache
final
{
private
:
DictionaryCache
(
)
{
Init
(
)
;
}
;
~
DictionaryCache
(
)
{
}
;
friend
class
DictionaryOriginReader
;
friend
class
DictionaryCacheEntry
;
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
DictionaryCache
)
static
already_AddRefed
<
DictionaryCache
>
GetInstance
(
)
;
nsresult
Init
(
)
;
nsresult
AddEntry
(
nsIURI
*
aURI
const
nsACString
&
aKey
const
nsACString
&
aPattern
const
nsACString
&
aId
const
Maybe
<
nsCString
>
&
aHash
DictionaryCacheEntry
*
*
aDictEntry
)
;
nsresult
AddEntry
(
nsIURI
*
aURI
DictionaryCacheEntry
*
aDictEntry
)
;
nsresult
RemoveEntry
(
nsIURI
*
aURI
const
nsACString
&
aKey
)
;
void
GetDictionaryFor
(
nsIURI
*
aURI
const
std
:
:
function
<
nsresult
(
DictionaryCacheEntry
*
)
>
&
aCallback
)
;
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
mallocSizeOf
(
this
)
;
}
private
:
bool
ParseMetaDataEntry
(
const
char
*
key
const
char
*
value
nsCString
&
uri
uint32_t
&
hitCount
uint32_t
&
lastHit
uint32_t
&
flags
)
;
static
nsCOMPtr
<
nsICacheStorage
>
sCacheStorage
;
nsTHashMap
<
nsCStringHashKey
UniquePtr
<
DictCacheList
>
>
mDictionaryCache
;
}
;
}
}
#
endif
