#
ifndef
CacheFileIOManager__h__
#
define
CacheFileIOManager__h__
#
include
"
CacheIOThread
.
h
"
#
include
"
CacheStorageService
.
h
"
#
include
"
CacheHashUtils
.
h
"
#
include
"
nsIEventTarget
.
h
"
#
include
"
nsINamed
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
SHA1
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTHashtable
.
h
"
#
include
"
prio
.
h
"
class
nsIFile
;
class
nsITimer
;
class
nsIDirectoryEnumerator
;
class
nsILoadContextInfo
;
namespace
mozilla
{
namespace
net
{
class
CacheFile
;
class
CacheFileIOListener
;
#
ifdef
DEBUG_HANDLES
class
CacheFileHandlesEntry
;
#
endif
#
define
ENTRIES_DIR
"
entries
"
#
define
DOOMED_DIR
"
doomed
"
#
define
TRASH_DIR
"
trash
"
class
CacheFileHandle
final
:
public
nsISupports
{
public
:
enum
class
PinningStatus
:
uint32_t
{
UNKNOWN
NON_PINNED
PINNED
}
;
NS_DECL_THREADSAFE_ISUPPORTS
bool
DispatchRelease
(
)
;
CacheFileHandle
(
const
SHA1Sum
:
:
Hash
*
aHash
bool
aPriority
PinningStatus
aPinning
)
;
CacheFileHandle
(
const
nsACString
&
aKey
bool
aPriority
PinningStatus
aPinning
)
;
void
Log
(
)
;
bool
IsDoomed
(
)
const
{
return
mIsDoomed
;
}
const
SHA1Sum
:
:
Hash
*
Hash
(
)
const
{
return
mHash
;
}
int64_t
FileSize
(
)
const
{
return
mFileSize
;
}
uint32_t
FileSizeInK
(
)
const
;
bool
IsPriority
(
)
const
{
return
mPriority
;
}
bool
FileExists
(
)
const
{
return
mFileExists
;
}
bool
IsClosed
(
)
const
{
return
mClosed
;
}
bool
IsSpecialFile
(
)
const
{
return
mSpecialFile
;
}
nsCString
&
Key
(
)
{
return
mKey
;
}
bool
SetPinned
(
bool
aPinned
)
;
void
SetInvalid
(
)
{
mInvalid
=
true
;
}
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
private
:
friend
class
CacheFileIOManager
;
friend
class
CacheFileHandles
;
friend
class
ReleaseNSPRHandleEvent
;
virtual
~
CacheFileHandle
(
)
;
const
SHA1Sum
:
:
Hash
*
mHash
;
mozilla
:
:
Atomic
<
bool
ReleaseAcquire
>
mIsDoomed
;
mozilla
:
:
Atomic
<
bool
ReleaseAcquire
>
mClosed
;
bool
const
mPriority
;
bool
const
mSpecialFile
;
mozilla
:
:
Atomic
<
bool
Relaxed
>
mInvalid
;
bool
mFileExists
:
1
;
bool
mDoomWhenFoundPinned
:
1
;
bool
mDoomWhenFoundNonPinned
:
1
;
bool
mKilled
:
1
;
PinningStatus
mPinning
;
nsCOMPtr
<
nsIFile
>
mFile
;
Atomic
<
int64_t
Relaxed
>
mFileSize
;
PRFileDesc
*
mFD
;
nsCString
mKey
;
}
;
class
CacheFileHandles
{
public
:
CacheFileHandles
(
)
;
~
CacheFileHandles
(
)
;
nsresult
GetHandle
(
const
SHA1Sum
:
:
Hash
*
aHash
CacheFileHandle
*
*
_retval
)
;
already_AddRefed
<
CacheFileHandle
>
NewHandle
(
const
SHA1Sum
:
:
Hash
*
bool
aPriority
CacheFileHandle
:
:
PinningStatus
)
;
void
RemoveHandle
(
CacheFileHandle
*
aHandle
)
;
void
GetAllHandles
(
nsTArray
<
RefPtr
<
CacheFileHandle
>
>
*
_retval
)
;
void
GetActiveHandles
(
nsTArray
<
RefPtr
<
CacheFileHandle
>
>
*
_retval
)
;
void
ClearAll
(
)
;
uint32_t
HandleCount
(
)
;
#
ifdef
DEBUG_HANDLES
void
Log
(
CacheFileHandlesEntry
*
entry
)
;
#
endif
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
class
HandleHashKey
:
public
PLDHashEntryHdr
{
public
:
using
KeyType
=
const
SHA1Sum
:
:
Hash
&
;
using
KeyTypePointer
=
const
SHA1Sum
:
:
Hash
*
;
explicit
HandleHashKey
(
KeyTypePointer
aKey
)
{
MOZ_COUNT_CTOR
(
HandleHashKey
)
;
mHash
=
MakeUnique
<
uint8_t
[
]
>
(
SHA1Sum
:
:
kHashSize
)
;
memcpy
(
mHash
.
get
(
)
aKey
sizeof
(
SHA1Sum
:
:
Hash
)
)
;
}
HandleHashKey
(
const
HandleHashKey
&
aOther
)
{
MOZ_ASSERT_UNREACHABLE
(
"
HandleHashKey
copy
constructor
is
forbidden
!
"
)
;
}
MOZ_COUNTED_DTOR
(
HandleHashKey
)
bool
KeyEquals
(
KeyTypePointer
aKey
)
const
{
return
memcmp
(
mHash
.
get
(
)
aKey
sizeof
(
SHA1Sum
:
:
Hash
)
)
=
=
0
;
}
static
KeyTypePointer
KeyToPointer
(
KeyType
aKey
)
{
return
&
aKey
;
}
static
PLDHashNumber
HashKey
(
KeyTypePointer
aKey
)
{
return
(
reinterpret_cast
<
const
uint32_t
*
>
(
aKey
)
)
[
0
]
;
}
void
AddHandle
(
CacheFileHandle
*
aHandle
)
;
void
RemoveHandle
(
CacheFileHandle
*
aHandle
)
;
already_AddRefed
<
CacheFileHandle
>
GetNewestHandle
(
)
;
void
GetHandles
(
nsTArray
<
RefPtr
<
CacheFileHandle
>
>
&
aResult
)
;
SHA1Sum
:
:
Hash
*
Hash
(
)
const
{
return
reinterpret_cast
<
SHA1Sum
:
:
Hash
*
>
(
mHash
.
get
(
)
)
;
}
bool
IsEmpty
(
)
const
{
return
mHandles
.
Length
(
)
=
=
0
;
}
enum
{
ALLOW_MEMMOVE
=
true
}
;
#
ifdef
DEBUG
void
AssertHandlesState
(
)
;
#
endif
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
private
:
UniquePtr
<
uint8_t
[
]
>
mHash
;
nsTArray
<
CacheFileHandle
*
>
mHandles
;
}
;
private
:
nsTHashtable
<
HandleHashKey
>
mTable
;
}
;
class
OpenFileEvent
;
class
ReadEvent
;
class
WriteEvent
;
class
MetadataWriteScheduleEvent
;
class
CacheFileContextEvictor
;
#
define
CACHEFILEIOLISTENER_IID
\
{
/
*
dcaf2ddc
-
17cf
-
4242
-
bca1
-
8c86936375a5
*
/
\
0xdcaf2ddc
0x17cf
0x4242
{
\
0xbc
0xa1
0x8c
0x86
0x93
0x63
0x75
0xa5
\
}
\
}
class
CacheFileIOListener
:
public
nsISupports
{
public
:
NS_DECLARE_STATIC_IID_ACCESSOR
(
CACHEFILEIOLISTENER_IID
)
NS_IMETHOD
OnFileOpened
(
CacheFileHandle
*
aHandle
nsresult
aResult
)
=
0
;
NS_IMETHOD
OnDataWritten
(
CacheFileHandle
*
aHandle
const
char
*
aBuf
nsresult
aResult
)
=
0
;
NS_IMETHOD
OnDataRead
(
CacheFileHandle
*
aHandle
char
*
aBuf
nsresult
aResult
)
=
0
;
NS_IMETHOD
OnFileDoomed
(
CacheFileHandle
*
aHandle
nsresult
aResult
)
=
0
;
NS_IMETHOD
OnEOFSet
(
CacheFileHandle
*
aHandle
nsresult
aResult
)
=
0
;
NS_IMETHOD
OnFileRenamed
(
CacheFileHandle
*
aHandle
nsresult
aResult
)
=
0
;
virtual
bool
IsKilled
(
)
{
return
false
;
}
}
;
NS_DEFINE_STATIC_IID_ACCESSOR
(
CacheFileIOListener
CACHEFILEIOLISTENER_IID
)
class
CacheFileIOManager
final
:
public
nsITimerCallback
public
nsINamed
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSITIMERCALLBACK
NS_DECL_NSINAMED
enum
{
OPEN
=
0U
CREATE
=
1U
CREATE_NEW
=
2U
PRIORITY
=
4U
SPECIAL_FILE
=
8U
PINNED
=
16U
}
;
CacheFileIOManager
(
)
;
static
nsresult
Init
(
)
;
static
nsresult
Shutdown
(
)
;
static
nsresult
OnProfile
(
)
;
static
nsresult
OnDelayedStartupFinished
(
)
;
static
nsresult
OnIdleDaily
(
)
;
static
already_AddRefed
<
nsIEventTarget
>
IOTarget
(
)
;
static
already_AddRefed
<
CacheIOThread
>
IOThread
(
)
;
static
bool
IsOnIOThread
(
)
;
static
bool
IsOnIOThreadOrCeased
(
)
;
static
bool
IsShutdown
(
)
;
static
nsresult
ScheduleMetadataWrite
(
CacheFile
*
aFile
)
;
static
nsresult
UnscheduleMetadataWrite
(
CacheFile
*
aFile
)
;
static
nsresult
ShutdownMetadataWriteScheduling
(
)
;
static
nsresult
OpenFile
(
const
nsACString
&
aKey
uint32_t
aFlags
CacheFileIOListener
*
aCallback
)
;
static
nsresult
Read
(
CacheFileHandle
*
aHandle
int64_t
aOffset
char
*
aBuf
int32_t
aCount
CacheFileIOListener
*
aCallback
)
;
static
nsresult
Write
(
CacheFileHandle
*
aHandle
int64_t
aOffset
const
char
*
aBuf
int32_t
aCount
bool
aValidate
bool
aTruncate
CacheFileIOListener
*
aCallback
)
;
enum
PinningDoomRestriction
{
NO_RESTRICTION
DOOM_WHEN_NON_PINNED
DOOM_WHEN_PINNED
}
;
static
nsresult
DoomFile
(
CacheFileHandle
*
aHandle
CacheFileIOListener
*
aCallback
)
;
static
nsresult
DoomFileByKey
(
const
nsACString
&
aKey
CacheFileIOListener
*
aCallback
)
;
static
nsresult
ReleaseNSPRHandle
(
CacheFileHandle
*
aHandle
)
;
static
nsresult
TruncateSeekSetEOF
(
CacheFileHandle
*
aHandle
int64_t
aTruncatePos
int64_t
aEOFPos
CacheFileIOListener
*
aCallback
)
;
static
nsresult
RenameFile
(
CacheFileHandle
*
aHandle
const
nsACString
&
aNewName
CacheFileIOListener
*
aCallback
)
;
static
nsresult
EvictIfOverLimit
(
)
;
static
nsresult
EvictAll
(
)
;
static
nsresult
EvictByContext
(
nsILoadContextInfo
*
aLoadContextInfo
bool
aPinned
const
nsAString
&
aOrigin
const
nsAString
&
aBaseDomain
=
u
"
"
_ns
)
;
static
nsresult
InitIndexEntry
(
CacheFileHandle
*
aHandle
OriginAttrsHash
aOriginAttrsHash
bool
aAnonymous
bool
aPinning
)
;
static
nsresult
UpdateIndexEntry
(
CacheFileHandle
*
aHandle
const
uint32_t
*
aFrecency
const
bool
*
aHasAltData
const
uint16_t
*
aOnStartTime
const
uint16_t
*
aOnStopTime
const
uint8_t
*
aContentType
)
;
static
nsresult
UpdateIndexEntry
(
)
;
enum
EEnumerateMode
{
ENTRIES
DOOMED
}
;
static
void
GetCacheDirectory
(
nsIFile
*
*
result
)
;
#
if
defined
(
MOZ_WIDGET_ANDROID
)
static
void
GetProfilelessCacheDirectory
(
nsIFile
*
*
result
)
;
#
endif
static
nsresult
GetEntryInfo
(
const
SHA1Sum
:
:
Hash
*
aHash
CacheStorageService
:
:
EntryInfoCallback
*
aCallback
)
;
static
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
;
static
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
;
private
:
friend
class
CacheFileHandle
;
friend
class
CacheFileChunk
;
friend
class
CacheFile
;
friend
class
ShutdownEvent
;
friend
class
OpenFileEvent
;
friend
class
CloseHandleEvent
;
friend
class
ReadEvent
;
friend
class
WriteEvent
;
friend
class
DoomFileEvent
;
friend
class
DoomFileByKeyEvent
;
friend
class
ReleaseNSPRHandleEvent
;
friend
class
TruncateSeekSetEOFEvent
;
friend
class
RenameFileEvent
;
friend
class
CacheIndex
;
friend
class
MetadataWriteScheduleEvent
;
friend
class
CacheFileContextEvictor
;
virtual
~
CacheFileIOManager
(
)
;
nsresult
InitInternal
(
)
;
void
ShutdownInternal
(
)
;
nsresult
OpenFileInternal
(
const
SHA1Sum
:
:
Hash
*
aHash
const
nsACString
&
aKey
uint32_t
aFlags
CacheFileHandle
*
*
_retval
)
;
nsresult
OpenSpecialFileInternal
(
const
nsACString
&
aKey
uint32_t
aFlags
CacheFileHandle
*
*
_retval
)
;
void
CloseHandleInternal
(
CacheFileHandle
*
aHandle
)
;
nsresult
ReadInternal
(
CacheFileHandle
*
aHandle
int64_t
aOffset
char
*
aBuf
int32_t
aCount
)
;
nsresult
WriteInternal
(
CacheFileHandle
*
aHandle
int64_t
aOffset
const
char
*
aBuf
int32_t
aCount
bool
aValidate
bool
aTruncate
)
;
nsresult
DoomFileInternal
(
CacheFileHandle
*
aHandle
PinningDoomRestriction
aPinningDoomRestriction
=
NO_RESTRICTION
)
;
nsresult
DoomFileByKeyInternal
(
const
SHA1Sum
:
:
Hash
*
aHash
)
;
nsresult
MaybeReleaseNSPRHandleInternal
(
CacheFileHandle
*
aHandle
bool
aIgnoreShutdownLag
=
false
)
;
nsresult
TruncateSeekSetEOFInternal
(
CacheFileHandle
*
aHandle
int64_t
aTruncatePos
int64_t
aEOFPos
)
;
nsresult
RenameFileInternal
(
CacheFileHandle
*
aHandle
const
nsACString
&
aNewName
)
;
nsresult
EvictIfOverLimitInternal
(
)
;
nsresult
OverLimitEvictionInternal
(
)
;
nsresult
EvictAllInternal
(
)
;
nsresult
EvictByContextInternal
(
nsILoadContextInfo
*
aLoadContextInfo
bool
aPinned
const
nsAString
&
aOrigin
const
nsAString
&
aBaseDomain
=
u
"
"
_ns
)
;
nsresult
TrashDirectory
(
nsIFile
*
aFile
)
;
static
void
OnTrashTimer
(
nsITimer
*
aTimer
void
*
aClosure
)
;
nsresult
StartRemovingTrash
(
)
;
nsresult
RemoveTrashInternal
(
)
;
nsresult
FindTrashDirToRemove
(
)
;
nsresult
CreateFile
(
CacheFileHandle
*
aHandle
)
;
static
void
HashToStr
(
const
SHA1Sum
:
:
Hash
*
aHash
nsACString
&
_retval
)
;
static
nsresult
StrToHash
(
const
nsACString
&
aHash
SHA1Sum
:
:
Hash
*
_retval
)
;
nsresult
GetFile
(
const
SHA1Sum
:
:
Hash
*
aHash
nsIFile
*
*
_retval
)
;
nsresult
GetSpecialFile
(
const
nsACString
&
aKey
nsIFile
*
*
_retval
)
;
nsresult
GetDoomedFile
(
nsIFile
*
*
_retval
)
;
nsresult
IsEmptyDirectory
(
nsIFile
*
aFile
bool
*
_retval
)
;
nsresult
CheckAndCreateDir
(
nsIFile
*
aFile
const
char
*
aDir
bool
aEnsureEmptyDir
)
;
nsresult
CreateCacheTree
(
)
;
nsresult
OpenNSPRHandle
(
CacheFileHandle
*
aHandle
bool
aCreate
=
false
)
;
void
NSPRHandleUsed
(
CacheFileHandle
*
aHandle
)
;
nsresult
SyncRemoveDir
(
nsIFile
*
aFile
const
char
*
aDir
)
;
void
SyncRemoveAllCacheFiles
(
)
;
nsresult
ScheduleMetadataWriteInternal
(
CacheFile
*
aFile
)
;
void
UnscheduleMetadataWriteInternal
(
CacheFile
*
aFile
)
;
void
ShutdownMetadataWriteSchedulingInternal
(
)
;
static
nsresult
CacheIndexStateChanged
(
)
;
void
CacheIndexStateChangedInternal
(
)
;
nsresult
DispatchPurgeTask
(
const
nsCString
&
aCacheDirName
const
nsCString
&
aSecondsToWait
const
nsCString
&
aPurgeExtension
)
;
nsresult
UpdateSmartCacheSize
(
int64_t
aFreeSpace
)
;
size_t
SizeOfExcludingThisInternal
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
static
StaticRefPtr
<
CacheFileIOManager
>
gInstance
;
TimeStamp
mStartTime
;
bool
mShuttingDown
{
false
}
;
RefPtr
<
CacheIOThread
>
mIOThread
;
nsCOMPtr
<
nsIFile
>
mCacheDirectory
;
#
if
defined
(
MOZ_WIDGET_ANDROID
)
nsCOMPtr
<
nsIFile
>
mCacheProfilelessDirectory
;
#
endif
bool
mTreeCreated
{
false
}
;
bool
mTreeCreationFailed
{
false
}
;
CacheFileHandles
mHandles
;
nsTArray
<
CacheFileHandle
*
>
mHandlesByLastUsed
;
nsTArray
<
CacheFileHandle
*
>
mSpecialHandles
;
nsTArray
<
RefPtr
<
CacheFile
>
>
mScheduledMetadataWrites
;
nsCOMPtr
<
nsITimer
>
mMetadataWritesTimer
;
bool
mOverLimitEvicting
{
false
}
;
bool
mCacheSizeOnHardLimit
{
false
}
;
bool
mRemovingTrashDirs
{
false
}
;
nsCOMPtr
<
nsITimer
>
mTrashTimer
;
nsCOMPtr
<
nsIFile
>
mTrashDir
;
nsCOMPtr
<
nsIDirectoryEnumerator
>
mTrashDirEnumerator
;
nsTArray
<
nsCString
>
mFailedTrashDirs
;
RefPtr
<
CacheFileContextEvictor
>
mContextEvictor
;
TimeStamp
mLastSmartSizeTime
;
}
;
}
}
#
endif
