#
ifndef
CacheIndex__h__
#
define
CacheIndex__h__
#
include
"
CacheLog
.
h
"
#
include
"
CacheFileIOManager
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
CacheHashUtils
.
h
"
#
include
"
nsICacheStorageService
.
h
"
#
include
"
nsICacheEntry
.
h
"
#
include
"
nsILoadContextInfo
.
h
"
#
include
"
nsIWeakReferenceUtils
.
h
"
#
include
"
nsTHashtable
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
mozilla
/
IntegerPrintfMacros
.
h
"
#
include
"
mozilla
/
SHA1
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
EndianUtils
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
class
nsIFile
;
class
nsIDirectoryEnumerator
;
class
nsITimer
;
#
ifdef
DEBUG
#
define
DEBUG_STATS
1
#
endif
namespace
mozilla
{
namespace
net
{
class
CacheFileMetadata
;
class
FileOpenHelper
;
class
CacheIndexIterator
;
const
uint16_t
kIndexTimeNotAvailable
=
0xFFFFU
;
const
uint16_t
kIndexTimeOutOfBound
=
0xFFFEU
;
typedef
struct
{
uint32_t
mVersion
;
uint32_t
mTimeStamp
;
uint32_t
mIsDirty
;
uint32_t
mKBWritten
;
}
CacheIndexHeader
;
static_assert
(
sizeof
(
CacheIndexHeader
:
:
mVersion
)
+
sizeof
(
CacheIndexHeader
:
:
mTimeStamp
)
+
sizeof
(
CacheIndexHeader
:
:
mIsDirty
)
+
sizeof
(
CacheIndexHeader
:
:
mKBWritten
)
=
=
sizeof
(
CacheIndexHeader
)
"
Unexpected
sizeof
(
CacheIndexHeader
)
!
"
)
;
#
pragma
pack
(
push
1
)
struct
CacheIndexRecord
{
SHA1Sum
:
:
Hash
mHash
;
uint32_t
mFrecency
;
OriginAttrsHash
mOriginAttrsHash
;
uint16_t
mOnStartTime
;
uint16_t
mOnStopTime
;
uint8_t
mContentType
;
uint32_t
mFlags
;
CacheIndexRecord
(
)
:
mFrecency
(
0
)
mOriginAttrsHash
(
0
)
mOnStartTime
(
kIndexTimeNotAvailable
)
mOnStopTime
(
kIndexTimeNotAvailable
)
mContentType
(
nsICacheEntry
:
:
CONTENT_TYPE_UNKNOWN
)
mFlags
(
0
)
{
}
~
CacheIndexRecord
(
)
;
}
;
#
pragma
pack
(
pop
)
static_assert
(
sizeof
(
CacheIndexRecord
:
:
mHash
)
+
sizeof
(
CacheIndexRecord
:
:
mFrecency
)
+
sizeof
(
CacheIndexRecord
:
:
mOriginAttrsHash
)
+
sizeof
(
CacheIndexRecord
:
:
mOnStartTime
)
+
sizeof
(
CacheIndexRecord
:
:
mOnStopTime
)
+
sizeof
(
CacheIndexRecord
:
:
mContentType
)
+
sizeof
(
CacheIndexRecord
:
:
mFlags
)
=
=
sizeof
(
CacheIndexRecord
)
"
Unexpected
sizeof
(
CacheIndexRecord
)
!
"
)
;
class
CacheIndexEntry
:
public
PLDHashEntryHdr
{
public
:
typedef
const
SHA1Sum
:
:
Hash
&
KeyType
;
typedef
const
SHA1Sum
:
:
Hash
*
KeyTypePointer
;
explicit
CacheIndexEntry
(
KeyTypePointer
aKey
)
{
MOZ_COUNT_CTOR
(
CacheIndexEntry
)
;
mRec
=
MakeUnique
<
CacheIndexRecord
>
(
)
;
LOG
(
(
"
CacheIndexEntry
:
:
CacheIndexEntry
(
)
-
Created
record
[
rec
=
%
p
]
"
mRec
.
get
(
)
)
)
;
memcpy
(
&
mRec
-
>
mHash
aKey
sizeof
(
SHA1Sum
:
:
Hash
)
)
;
}
CacheIndexEntry
(
const
CacheIndexEntry
&
aOther
)
{
MOZ_ASSERT_UNREACHABLE
(
"
CacheIndexEntry
copy
constructor
is
forbidden
!
"
)
;
}
~
CacheIndexEntry
(
)
{
MOZ_COUNT_DTOR
(
CacheIndexEntry
)
;
LOG
(
(
"
CacheIndexEntry
:
:
~
CacheIndexEntry
(
)
-
Deleting
record
[
rec
=
%
p
]
"
mRec
.
get
(
)
)
)
;
}
bool
KeyEquals
(
KeyTypePointer
aKey
)
const
{
return
memcmp
(
&
mRec
-
>
mHash
aKey
sizeof
(
SHA1Sum
:
:
Hash
)
)
=
=
0
;
}
static
KeyTypePointer
KeyToPointer
(
KeyType
aKey
)
{
return
&
aKey
;
}
static
PLDHashNumber
HashKey
(
KeyTypePointer
aKey
)
{
return
(
reinterpret_cast
<
const
uint32_t
*
>
(
aKey
)
)
[
0
]
;
}
enum
{
ALLOW_MEMMOVE
=
true
}
;
bool
operator
=
=
(
const
CacheIndexEntry
&
aOther
)
const
{
return
KeyEquals
(
&
aOther
.
mRec
-
>
mHash
)
;
}
CacheIndexEntry
&
operator
=
(
const
CacheIndexEntry
&
aOther
)
{
MOZ_ASSERT
(
memcmp
(
&
mRec
-
>
mHash
&
aOther
.
mRec
-
>
mHash
sizeof
(
SHA1Sum
:
:
Hash
)
)
=
=
0
)
;
mRec
-
>
mFrecency
=
aOther
.
mRec
-
>
mFrecency
;
mRec
-
>
mOriginAttrsHash
=
aOther
.
mRec
-
>
mOriginAttrsHash
;
mRec
-
>
mOnStartTime
=
aOther
.
mRec
-
>
mOnStartTime
;
mRec
-
>
mOnStopTime
=
aOther
.
mRec
-
>
mOnStopTime
;
mRec
-
>
mContentType
=
aOther
.
mRec
-
>
mContentType
;
mRec
-
>
mFlags
=
aOther
.
mRec
-
>
mFlags
;
return
*
this
;
}
void
InitNew
(
)
{
mRec
-
>
mFrecency
=
0
;
mRec
-
>
mOriginAttrsHash
=
0
;
mRec
-
>
mOnStartTime
=
kIndexTimeNotAvailable
;
mRec
-
>
mOnStopTime
=
kIndexTimeNotAvailable
;
mRec
-
>
mContentType
=
nsICacheEntry
:
:
CONTENT_TYPE_UNKNOWN
;
mRec
-
>
mFlags
=
0
;
}
void
Init
(
OriginAttrsHash
aOriginAttrsHash
bool
aAnonymous
bool
aPinned
)
{
MOZ_ASSERT
(
mRec
-
>
mFrecency
=
=
0
)
;
MOZ_ASSERT
(
mRec
-
>
mOriginAttrsHash
=
=
0
)
;
MOZ_ASSERT
(
mRec
-
>
mOnStartTime
=
=
kIndexTimeNotAvailable
)
;
MOZ_ASSERT
(
mRec
-
>
mOnStopTime
=
=
kIndexTimeNotAvailable
)
;
MOZ_ASSERT
(
mRec
-
>
mContentType
=
=
nsICacheEntry
:
:
CONTENT_TYPE_UNKNOWN
)
;
MOZ_ASSERT
(
(
mRec
-
>
mFlags
&
~
kDirtyMask
)
=
=
kFreshMask
)
;
mRec
-
>
mOriginAttrsHash
=
aOriginAttrsHash
;
mRec
-
>
mFlags
|
=
kInitializedMask
;
if
(
aAnonymous
)
{
mRec
-
>
mFlags
|
=
kAnonymousMask
;
}
if
(
aPinned
)
{
mRec
-
>
mFlags
|
=
kPinnedMask
;
}
}
const
SHA1Sum
:
:
Hash
*
Hash
(
)
const
{
return
&
mRec
-
>
mHash
;
}
bool
IsInitialized
(
)
const
{
return
!
!
(
mRec
-
>
mFlags
&
kInitializedMask
)
;
}
mozilla
:
:
net
:
:
OriginAttrsHash
OriginAttrsHash
(
)
const
{
return
mRec
-
>
mOriginAttrsHash
;
}
bool
Anonymous
(
)
const
{
return
!
!
(
mRec
-
>
mFlags
&
kAnonymousMask
)
;
}
bool
IsRemoved
(
)
const
{
return
!
!
(
mRec
-
>
mFlags
&
kRemovedMask
)
;
}
void
MarkRemoved
(
)
{
mRec
-
>
mFlags
|
=
kRemovedMask
;
}
bool
IsDirty
(
)
const
{
return
!
!
(
mRec
-
>
mFlags
&
kDirtyMask
)
;
}
void
MarkDirty
(
)
{
mRec
-
>
mFlags
|
=
kDirtyMask
;
}
void
ClearDirty
(
)
{
mRec
-
>
mFlags
&
=
~
kDirtyMask
;
}
bool
IsFresh
(
)
const
{
return
!
!
(
mRec
-
>
mFlags
&
kFreshMask
)
;
}
void
MarkFresh
(
)
{
mRec
-
>
mFlags
|
=
kFreshMask
;
}
bool
IsPinned
(
)
const
{
return
!
!
(
mRec
-
>
mFlags
&
kPinnedMask
)
;
}
void
SetFrecency
(
uint32_t
aFrecency
)
{
mRec
-
>
mFrecency
=
aFrecency
;
}
uint32_t
GetFrecency
(
)
const
{
return
mRec
-
>
mFrecency
;
}
void
SetHasAltData
(
bool
aHasAltData
)
{
aHasAltData
?
mRec
-
>
mFlags
|
=
kHasAltDataMask
:
mRec
-
>
mFlags
&
=
~
kHasAltDataMask
;
}
bool
GetHasAltData
(
)
const
{
return
!
!
(
mRec
-
>
mFlags
&
kHasAltDataMask
)
;
}
void
SetOnStartTime
(
uint16_t
aTime
)
{
mRec
-
>
mOnStartTime
=
aTime
;
}
uint16_t
GetOnStartTime
(
)
const
{
return
mRec
-
>
mOnStartTime
;
}
void
SetOnStopTime
(
uint16_t
aTime
)
{
mRec
-
>
mOnStopTime
=
aTime
;
}
uint16_t
GetOnStopTime
(
)
const
{
return
mRec
-
>
mOnStopTime
;
}
void
SetContentType
(
uint8_t
aType
)
{
mRec
-
>
mContentType
=
aType
;
}
uint8_t
GetContentType
(
)
const
{
return
GetContentType
(
mRec
.
get
(
)
)
;
}
static
uint8_t
GetContentType
(
CacheIndexRecord
*
aRec
)
{
if
(
aRec
-
>
mContentType
>
=
nsICacheEntry
:
:
CONTENT_TYPE_LAST
)
{
LOG
(
(
"
CacheIndexEntry
:
:
GetContentType
(
)
-
Found
invalid
content
type
"
"
[
hash
=
%
08x
%
08x
%
08x
%
08x
%
08x
contentType
=
%
u
]
"
LOGSHA1
(
aRec
-
>
mHash
)
aRec
-
>
mContentType
)
)
;
return
nsICacheEntry
:
:
CONTENT_TYPE_UNKNOWN
;
}
return
aRec
-
>
mContentType
;
}
void
SetFileSize
(
uint32_t
aFileSize
)
{
if
(
aFileSize
>
kFileSizeMask
)
{
LOG
(
(
"
CacheIndexEntry
:
:
SetFileSize
(
)
-
FileSize
is
too
large
"
"
truncating
to
%
u
"
kFileSizeMask
)
)
;
aFileSize
=
kFileSizeMask
;
}
mRec
-
>
mFlags
&
=
~
kFileSizeMask
;
mRec
-
>
mFlags
|
=
aFileSize
;
}
uint32_t
GetFileSize
(
)
const
{
return
GetFileSize
(
*
mRec
)
;
}
static
uint32_t
GetFileSize
(
const
CacheIndexRecord
&
aRec
)
{
return
aRec
.
mFlags
&
kFileSizeMask
;
}
static
uint32_t
IsPinned
(
CacheIndexRecord
*
aRec
)
{
return
aRec
-
>
mFlags
&
kPinnedMask
;
}
bool
IsFileEmpty
(
)
const
{
return
GetFileSize
(
)
=
=
0
;
}
void
WriteToBuf
(
void
*
aBuf
)
{
uint8_t
*
ptr
=
static_cast
<
uint8_t
*
>
(
aBuf
)
;
memcpy
(
ptr
mRec
-
>
mHash
sizeof
(
SHA1Sum
:
:
Hash
)
)
;
ptr
+
=
sizeof
(
SHA1Sum
:
:
Hash
)
;
NetworkEndian
:
:
writeUint32
(
ptr
mRec
-
>
mFrecency
)
;
ptr
+
=
sizeof
(
uint32_t
)
;
NetworkEndian
:
:
writeUint64
(
ptr
mRec
-
>
mOriginAttrsHash
)
;
ptr
+
=
sizeof
(
uint64_t
)
;
NetworkEndian
:
:
writeUint16
(
ptr
mRec
-
>
mOnStartTime
)
;
ptr
+
=
sizeof
(
uint16_t
)
;
NetworkEndian
:
:
writeUint16
(
ptr
mRec
-
>
mOnStopTime
)
;
ptr
+
=
sizeof
(
uint16_t
)
;
*
ptr
=
mRec
-
>
mContentType
;
ptr
+
=
sizeof
(
uint8_t
)
;
NetworkEndian
:
:
writeUint32
(
ptr
mRec
-
>
mFlags
&
~
(
kDirtyMask
|
kFreshMask
)
)
;
}
void
ReadFromBuf
(
void
*
aBuf
)
{
const
uint8_t
*
ptr
=
static_cast
<
const
uint8_t
*
>
(
aBuf
)
;
MOZ_ASSERT
(
memcmp
(
&
mRec
-
>
mHash
ptr
sizeof
(
SHA1Sum
:
:
Hash
)
)
=
=
0
)
;
ptr
+
=
sizeof
(
SHA1Sum
:
:
Hash
)
;
mRec
-
>
mFrecency
=
NetworkEndian
:
:
readUint32
(
ptr
)
;
ptr
+
=
sizeof
(
uint32_t
)
;
mRec
-
>
mOriginAttrsHash
=
NetworkEndian
:
:
readUint64
(
ptr
)
;
ptr
+
=
sizeof
(
uint64_t
)
;
mRec
-
>
mOnStartTime
=
NetworkEndian
:
:
readUint16
(
ptr
)
;
ptr
+
=
sizeof
(
uint16_t
)
;
mRec
-
>
mOnStopTime
=
NetworkEndian
:
:
readUint16
(
ptr
)
;
ptr
+
=
sizeof
(
uint16_t
)
;
mRec
-
>
mContentType
=
*
ptr
;
ptr
+
=
sizeof
(
uint8_t
)
;
mRec
-
>
mFlags
=
NetworkEndian
:
:
readUint32
(
ptr
)
;
}
void
Log
(
)
const
{
LOG
(
(
"
CacheIndexEntry
:
:
Log
(
)
[
this
=
%
p
hash
=
%
08x
%
08x
%
08x
%
08x
%
08x
fresh
=
%
u
"
"
initialized
=
%
u
removed
=
%
u
dirty
=
%
u
anonymous
=
%
u
"
"
originAttrsHash
=
%
"
PRIx64
"
frecency
=
%
u
hasAltData
=
%
u
"
"
onStartTime
=
%
u
onStopTime
=
%
u
contentType
=
%
u
size
=
%
u
]
"
this
LOGSHA1
(
mRec
-
>
mHash
)
IsFresh
(
)
IsInitialized
(
)
IsRemoved
(
)
IsDirty
(
)
Anonymous
(
)
OriginAttrsHash
(
)
GetFrecency
(
)
GetHasAltData
(
)
GetOnStartTime
(
)
GetOnStopTime
(
)
GetContentType
(
)
GetFileSize
(
)
)
)
;
}
static
bool
RecordMatchesLoadContextInfo
(
CacheIndexRecord
*
aRec
nsILoadContextInfo
*
aInfo
)
{
MOZ_ASSERT
(
aInfo
)
;
if
(
!
aInfo
-
>
IsPrivate
(
)
&
&
GetOriginAttrsHash
(
*
aInfo
-
>
OriginAttributesPtr
(
)
)
=
=
aRec
-
>
mOriginAttrsHash
&
&
aInfo
-
>
IsAnonymous
(
)
=
=
!
!
(
aRec
-
>
mFlags
&
kAnonymousMask
)
)
{
return
true
;
}
return
false
;
}
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
mallocSizeOf
(
mRec
.
get
(
)
)
;
}
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
mallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
mallocSizeOf
)
;
}
private
:
friend
class
CacheIndexEntryUpdate
;
friend
class
CacheIndex
;
friend
class
CacheIndexEntryAutoManage
;
friend
struct
CacheIndexRecord
;
static
const
uint32_t
kInitializedMask
=
0x80000000
;
static
const
uint32_t
kAnonymousMask
=
0x40000000
;
static
const
uint32_t
kRemovedMask
=
0x20000000
;
static
const
uint32_t
kDirtyMask
=
0x10000000
;
static
const
uint32_t
kFreshMask
=
0x08000000
;
static
const
uint32_t
kPinnedMask
=
0x04000000
;
static
const
uint32_t
kHasAltDataMask
=
0x02000000
;
static
const
uint32_t
kReservedMask
=
0x01000000
;
static
const
uint32_t
kFileSizeMask
=
0x00FFFFFF
;
UniquePtr
<
CacheIndexRecord
>
mRec
;
}
;
class
CacheIndexEntryUpdate
:
public
CacheIndexEntry
{
public
:
explicit
CacheIndexEntryUpdate
(
CacheIndexEntry
:
:
KeyTypePointer
aKey
)
:
CacheIndexEntry
(
aKey
)
mUpdateFlags
(
0
)
{
MOZ_COUNT_CTOR
(
CacheIndexEntryUpdate
)
;
LOG
(
(
"
CacheIndexEntryUpdate
:
:
CacheIndexEntryUpdate
(
)
"
)
)
;
}
~
CacheIndexEntryUpdate
(
)
{
MOZ_COUNT_DTOR
(
CacheIndexEntryUpdate
)
;
LOG
(
(
"
CacheIndexEntryUpdate
:
:
~
CacheIndexEntryUpdate
(
)
"
)
)
;
}
CacheIndexEntryUpdate
&
operator
=
(
const
CacheIndexEntry
&
aOther
)
{
MOZ_ASSERT
(
memcmp
(
&
mRec
-
>
mHash
&
aOther
.
mRec
-
>
mHash
sizeof
(
SHA1Sum
:
:
Hash
)
)
=
=
0
)
;
mUpdateFlags
=
0
;
*
(
static_cast
<
CacheIndexEntry
*
>
(
this
)
)
=
aOther
;
return
*
this
;
}
void
InitNew
(
)
{
mUpdateFlags
=
kFrecencyUpdatedMask
|
kHasAltDataUpdatedMask
|
kOnStartTimeUpdatedMask
|
kOnStopTimeUpdatedMask
|
kContentTypeUpdatedMask
|
kFileSizeUpdatedMask
;
CacheIndexEntry
:
:
InitNew
(
)
;
}
void
SetFrecency
(
uint32_t
aFrecency
)
{
mUpdateFlags
|
=
kFrecencyUpdatedMask
;
CacheIndexEntry
:
:
SetFrecency
(
aFrecency
)
;
}
void
SetHasAltData
(
bool
aHasAltData
)
{
mUpdateFlags
|
=
kHasAltDataUpdatedMask
;
CacheIndexEntry
:
:
SetHasAltData
(
aHasAltData
)
;
}
void
SetOnStartTime
(
uint16_t
aTime
)
{
mUpdateFlags
|
=
kOnStartTimeUpdatedMask
;
CacheIndexEntry
:
:
SetOnStartTime
(
aTime
)
;
}
void
SetOnStopTime
(
uint16_t
aTime
)
{
mUpdateFlags
|
=
kOnStopTimeUpdatedMask
;
CacheIndexEntry
:
:
SetOnStopTime
(
aTime
)
;
}
void
SetContentType
(
uint8_t
aType
)
{
mUpdateFlags
|
=
kContentTypeUpdatedMask
;
CacheIndexEntry
:
:
SetContentType
(
aType
)
;
}
void
SetFileSize
(
uint32_t
aFileSize
)
{
mUpdateFlags
|
=
kFileSizeUpdatedMask
;
CacheIndexEntry
:
:
SetFileSize
(
aFileSize
)
;
}
void
ApplyUpdate
(
CacheIndexEntry
*
aDst
)
{
MOZ_ASSERT
(
memcmp
(
&
mRec
-
>
mHash
&
aDst
-
>
mRec
-
>
mHash
sizeof
(
SHA1Sum
:
:
Hash
)
)
=
=
0
)
;
if
(
mUpdateFlags
&
kFrecencyUpdatedMask
)
{
aDst
-
>
mRec
-
>
mFrecency
=
mRec
-
>
mFrecency
;
}
aDst
-
>
mRec
-
>
mOriginAttrsHash
=
mRec
-
>
mOriginAttrsHash
;
if
(
mUpdateFlags
&
kOnStartTimeUpdatedMask
)
{
aDst
-
>
mRec
-
>
mOnStartTime
=
mRec
-
>
mOnStartTime
;
}
if
(
mUpdateFlags
&
kOnStopTimeUpdatedMask
)
{
aDst
-
>
mRec
-
>
mOnStopTime
=
mRec
-
>
mOnStopTime
;
}
if
(
mUpdateFlags
&
kContentTypeUpdatedMask
)
{
aDst
-
>
mRec
-
>
mContentType
=
mRec
-
>
mContentType
;
}
if
(
mUpdateFlags
&
kHasAltDataUpdatedMask
&
&
(
(
aDst
-
>
mRec
-
>
mFlags
^
mRec
-
>
mFlags
)
&
kHasAltDataMask
)
)
{
aDst
-
>
mRec
-
>
mFlags
^
=
kHasAltDataMask
;
}
if
(
mUpdateFlags
&
kFileSizeUpdatedMask
)
{
aDst
-
>
mRec
-
>
mFlags
|
=
(
mRec
-
>
mFlags
&
~
kHasAltDataMask
)
;
}
else
{
aDst
-
>
mRec
-
>
mFlags
&
=
kFileSizeMask
;
aDst
-
>
mRec
-
>
mFlags
|
=
(
mRec
-
>
mFlags
&
~
kHasAltDataMask
&
~
kFileSizeMask
)
;
}
}
private
:
static
const
uint32_t
kFrecencyUpdatedMask
=
0x00000001
;
static
const
uint32_t
kContentTypeUpdatedMask
=
0x00000002
;
static
const
uint32_t
kFileSizeUpdatedMask
=
0x00000004
;
static
const
uint32_t
kHasAltDataUpdatedMask
=
0x00000008
;
static
const
uint32_t
kOnStartTimeUpdatedMask
=
0x00000010
;
static
const
uint32_t
kOnStopTimeUpdatedMask
=
0x00000020
;
uint32_t
mUpdateFlags
;
}
;
class
CacheIndexStats
{
public
:
CacheIndexStats
(
)
:
mCount
(
0
)
mNotInitialized
(
0
)
mRemoved
(
0
)
mDirty
(
0
)
mFresh
(
0
)
mEmpty
(
0
)
mSize
(
0
)
#
ifdef
DEBUG
mStateLogged
(
false
)
mDisableLogging
(
false
)
#
endif
{
for
(
uint32_t
i
=
0
;
i
<
nsICacheEntry
:
:
CONTENT_TYPE_LAST
;
+
+
i
)
{
mCountByType
[
i
]
=
0
;
mSizeByType
[
i
]
=
0
;
}
}
bool
operator
=
=
(
const
CacheIndexStats
&
aOther
)
const
{
for
(
uint32_t
i
=
0
;
i
<
nsICacheEntry
:
:
CONTENT_TYPE_LAST
;
+
+
i
)
{
if
(
mCountByType
[
i
]
!
=
aOther
.
mCountByType
[
i
]
|
|
mSizeByType
[
i
]
!
=
aOther
.
mSizeByType
[
i
]
)
{
return
false
;
}
}
return
#
ifdef
DEBUG
aOther
.
mStateLogged
=
=
mStateLogged
&
&
#
endif
aOther
.
mCount
=
=
mCount
&
&
aOther
.
mNotInitialized
=
=
mNotInitialized
&
&
aOther
.
mRemoved
=
=
mRemoved
&
&
aOther
.
mDirty
=
=
mDirty
&
&
aOther
.
mFresh
=
=
mFresh
&
&
aOther
.
mEmpty
=
=
mEmpty
&
&
aOther
.
mSize
=
=
mSize
;
}
#
ifdef
DEBUG
void
DisableLogging
(
)
{
mDisableLogging
=
true
;
}
#
endif
void
Log
(
)
{
LOG
(
(
"
CacheIndexStats
:
:
Log
(
)
[
count
=
%
u
notInitialized
=
%
u
removed
=
%
u
"
"
dirty
=
%
u
fresh
=
%
u
empty
=
%
u
size
=
%
u
]
"
mCount
mNotInitialized
mRemoved
mDirty
mFresh
mEmpty
mSize
)
)
;
}
void
Clear
(
)
{
MOZ_ASSERT
(
!
mStateLogged
"
CacheIndexStats
:
:
Clear
(
)
-
state
logged
!
"
)
;
mCount
=
0
;
mNotInitialized
=
0
;
mRemoved
=
0
;
mDirty
=
0
;
mFresh
=
0
;
mEmpty
=
0
;
mSize
=
0
;
for
(
uint32_t
i
=
0
;
i
<
nsICacheEntry
:
:
CONTENT_TYPE_LAST
;
+
+
i
)
{
mCountByType
[
i
]
=
0
;
mSizeByType
[
i
]
=
0
;
}
}
#
ifdef
DEBUG
bool
StateLogged
(
)
{
return
mStateLogged
;
}
#
endif
uint32_t
Count
(
)
{
MOZ_ASSERT
(
!
mStateLogged
"
CacheIndexStats
:
:
Count
(
)
-
state
logged
!
"
)
;
return
mCount
;
}
uint32_t
CountByType
(
uint8_t
aContentType
)
{
MOZ_ASSERT
(
!
mStateLogged
"
CacheIndexStats
:
:
CountByType
(
)
-
state
logged
!
"
)
;
MOZ_RELEASE_ASSERT
(
aContentType
<
nsICacheEntry
:
:
CONTENT_TYPE_LAST
)
;
return
mCountByType
[
aContentType
]
;
}
uint32_t
Dirty
(
)
{
MOZ_ASSERT
(
!
mStateLogged
"
CacheIndexStats
:
:
Dirty
(
)
-
state
logged
!
"
)
;
return
mDirty
;
}
uint32_t
Fresh
(
)
{
MOZ_ASSERT
(
!
mStateLogged
"
CacheIndexStats
:
:
Fresh
(
)
-
state
logged
!
"
)
;
return
mFresh
;
}
uint32_t
ActiveEntriesCount
(
)
{
MOZ_ASSERT
(
!
mStateLogged
"
CacheIndexStats
:
:
ActiveEntriesCount
(
)
-
state
"
"
logged
!
"
)
;
return
mCount
-
mRemoved
-
mNotInitialized
-
mEmpty
;
}
uint32_t
Size
(
)
{
MOZ_ASSERT
(
!
mStateLogged
"
CacheIndexStats
:
:
Size
(
)
-
state
logged
!
"
)
;
return
mSize
;
}
uint32_t
SizeByType
(
uint8_t
aContentType
)
{
MOZ_ASSERT
(
!
mStateLogged
"
CacheIndexStats
:
:
SizeByType
(
)
-
state
logged
!
"
)
;
MOZ_RELEASE_ASSERT
(
aContentType
<
nsICacheEntry
:
:
CONTENT_TYPE_LAST
)
;
return
mSizeByType
[
aContentType
]
;
}
void
BeforeChange
(
const
CacheIndexEntry
*
aEntry
)
{
#
ifdef
DEBUG_STATS
if
(
!
mDisableLogging
)
{
LOG
(
(
"
CacheIndexStats
:
:
BeforeChange
(
)
"
)
)
;
Log
(
)
;
}
#
endif
MOZ_ASSERT
(
!
mStateLogged
"
CacheIndexStats
:
:
BeforeChange
(
)
-
state
"
"
logged
!
"
)
;
#
ifdef
DEBUG
mStateLogged
=
true
;
#
endif
if
(
aEntry
)
{
MOZ_ASSERT
(
mCount
)
;
uint8_t
contentType
=
aEntry
-
>
GetContentType
(
)
;
mCount
-
-
;
mCountByType
[
contentType
]
-
-
;
if
(
aEntry
-
>
IsDirty
(
)
)
{
MOZ_ASSERT
(
mDirty
)
;
mDirty
-
-
;
}
if
(
aEntry
-
>
IsFresh
(
)
)
{
MOZ_ASSERT
(
mFresh
)
;
mFresh
-
-
;
}
if
(
aEntry
-
>
IsRemoved
(
)
)
{
MOZ_ASSERT
(
mRemoved
)
;
mRemoved
-
-
;
}
else
{
if
(
!
aEntry
-
>
IsInitialized
(
)
)
{
MOZ_ASSERT
(
mNotInitialized
)
;
mNotInitialized
-
-
;
}
else
{
if
(
aEntry
-
>
IsFileEmpty
(
)
)
{
MOZ_ASSERT
(
mEmpty
)
;
mEmpty
-
-
;
}
else
{
MOZ_ASSERT
(
mSize
>
=
aEntry
-
>
GetFileSize
(
)
)
;
mSize
-
=
aEntry
-
>
GetFileSize
(
)
;
mSizeByType
[
contentType
]
-
=
aEntry
-
>
GetFileSize
(
)
;
}
}
}
}
}
void
AfterChange
(
const
CacheIndexEntry
*
aEntry
)
{
MOZ_ASSERT
(
mStateLogged
"
CacheIndexStats
:
:
AfterChange
(
)
-
state
not
"
"
logged
!
"
)
;
#
ifdef
DEBUG
mStateLogged
=
false
;
#
endif
if
(
aEntry
)
{
uint8_t
contentType
=
aEntry
-
>
GetContentType
(
)
;
+
+
mCount
;
+
+
mCountByType
[
contentType
]
;
if
(
aEntry
-
>
IsDirty
(
)
)
{
mDirty
+
+
;
}
if
(
aEntry
-
>
IsFresh
(
)
)
{
mFresh
+
+
;
}
if
(
aEntry
-
>
IsRemoved
(
)
)
{
mRemoved
+
+
;
}
else
{
if
(
!
aEntry
-
>
IsInitialized
(
)
)
{
mNotInitialized
+
+
;
}
else
{
if
(
aEntry
-
>
IsFileEmpty
(
)
)
{
mEmpty
+
+
;
}
else
{
mSize
+
=
aEntry
-
>
GetFileSize
(
)
;
mSizeByType
[
contentType
]
+
=
aEntry
-
>
GetFileSize
(
)
;
}
}
}
}
#
ifdef
DEBUG_STATS
if
(
!
mDisableLogging
)
{
LOG
(
(
"
CacheIndexStats
:
:
AfterChange
(
)
"
)
)
;
Log
(
)
;
}
#
endif
}
private
:
uint32_t
mCount
;
uint32_t
mCountByType
[
nsICacheEntry
:
:
CONTENT_TYPE_LAST
]
;
uint32_t
mNotInitialized
;
uint32_t
mRemoved
;
uint32_t
mDirty
;
uint32_t
mFresh
;
uint32_t
mEmpty
;
uint32_t
mSize
;
uint32_t
mSizeByType
[
nsICacheEntry
:
:
CONTENT_TYPE_LAST
]
;
#
ifdef
DEBUG
bool
mStateLogged
;
bool
mDisableLogging
;
#
endif
}
;
class
CacheIndex
final
:
public
CacheFileIOListener
public
nsIRunnable
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIRUNNABLE
CacheIndex
(
)
;
static
nsresult
Init
(
nsIFile
*
aCacheDirectory
)
;
static
nsresult
PreShutdown
(
)
;
static
nsresult
Shutdown
(
)
;
static
nsresult
AddEntry
(
const
SHA1Sum
:
:
Hash
*
aHash
)
;
static
nsresult
EnsureEntryExists
(
const
SHA1Sum
:
:
Hash
*
aHash
)
;
static
nsresult
InitEntry
(
const
SHA1Sum
:
:
Hash
*
aHash
OriginAttrsHash
aOriginAttrsHash
bool
aAnonymous
bool
aPinned
)
;
static
nsresult
RemoveEntry
(
const
SHA1Sum
:
:
Hash
*
aHash
)
;
static
nsresult
UpdateEntry
(
const
SHA1Sum
:
:
Hash
*
aHash
const
uint32_t
*
aFrecency
const
bool
*
aHasAltData
const
uint16_t
*
aOnStartTime
const
uint16_t
*
aOnStopTime
const
uint8_t
*
aContentType
const
uint32_t
*
aSize
)
;
static
nsresult
RemoveAll
(
)
;
enum
EntryStatus
{
EXISTS
=
0
DOES_NOT_EXIST
=
1
DO_NOT_KNOW
=
2
}
;
static
nsresult
HasEntry
(
const
nsACString
&
aKey
EntryStatus
*
_retval
const
std
:
:
function
<
void
(
const
CacheIndexEntry
*
)
>
&
aCB
=
nullptr
)
;
static
nsresult
HasEntry
(
const
SHA1Sum
:
:
Hash
&
hash
EntryStatus
*
_retval
const
std
:
:
function
<
void
(
const
CacheIndexEntry
*
)
>
&
aCB
=
nullptr
)
;
static
nsresult
GetEntryForEviction
(
bool
aIgnoreEmptyEntries
SHA1Sum
:
:
Hash
*
aHash
uint32_t
*
aCnt
)
;
static
bool
IsForcedValidEntry
(
const
SHA1Sum
:
:
Hash
*
aHash
)
;
static
nsresult
GetCacheSize
(
uint32_t
*
_retval
)
;
static
nsresult
GetEntryFileCount
(
uint32_t
*
_retval
)
;
static
nsresult
GetCacheStats
(
nsILoadContextInfo
*
aInfo
uint32_t
*
aSize
uint32_t
*
aCount
)
;
static
nsresult
AsyncGetDiskConsumption
(
nsICacheStorageConsumptionObserver
*
aObserver
)
;
static
nsresult
GetIterator
(
nsILoadContextInfo
*
aInfo
bool
aAddNew
CacheIndexIterator
*
*
_retval
)
;
static
nsresult
IsUpToDate
(
bool
*
_retval
)
;
static
void
OnAsyncEviction
(
bool
aEvicting
)
;
static
void
UpdateTotalBytesWritten
(
uint32_t
aBytesWritten
)
;
static
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
;
static
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
;
private
:
friend
class
CacheIndexEntryAutoManage
;
friend
class
FileOpenHelper
;
friend
class
CacheIndexIterator
;
friend
struct
CacheIndexRecord
;
virtual
~
CacheIndex
(
)
;
NS_IMETHOD
OnFileOpened
(
CacheFileHandle
*
aHandle
nsresult
aResult
)
override
;
void
OnFileOpenedInternal
(
FileOpenHelper
*
aOpener
CacheFileHandle
*
aHandle
nsresult
aResult
)
;
NS_IMETHOD
OnDataWritten
(
CacheFileHandle
*
aHandle
const
char
*
aBuf
nsresult
aResult
)
override
;
NS_IMETHOD
OnDataRead
(
CacheFileHandle
*
aHandle
char
*
aBuf
nsresult
aResult
)
override
;
NS_IMETHOD
OnFileDoomed
(
CacheFileHandle
*
aHandle
nsresult
aResult
)
override
;
NS_IMETHOD
OnEOFSet
(
CacheFileHandle
*
aHandle
nsresult
aResult
)
override
;
NS_IMETHOD
OnFileRenamed
(
CacheFileHandle
*
aHandle
nsresult
aResult
)
override
;
nsresult
InitInternal
(
nsIFile
*
aCacheDirectory
)
;
void
PreShutdownInternal
(
)
;
bool
IsIndexUsable
(
)
;
static
bool
IsCollision
(
CacheIndexEntry
*
aEntry
OriginAttrsHash
aOriginAttrsHash
bool
aAnonymous
)
;
static
bool
HasEntryChanged
(
CacheIndexEntry
*
aEntry
const
uint32_t
*
aFrecency
const
bool
*
aHasAltData
const
uint16_t
*
aOnStartTime
const
uint16_t
*
aOnStopTime
const
uint8_t
*
aContentType
const
uint32_t
*
aSize
)
;
void
ProcessPendingOperations
(
)
;
bool
WriteIndexToDiskIfNeeded
(
)
;
void
WriteIndexToDisk
(
)
;
void
WriteRecords
(
)
;
void
FinishWrite
(
bool
aSucceeded
)
;
nsresult
GetFile
(
const
nsACString
&
aName
nsIFile
*
*
_retval
)
;
void
RemoveFile
(
const
nsACString
&
aName
)
;
void
RemoveAllIndexFiles
(
)
;
void
RemoveJournalAndTempFile
(
)
;
nsresult
WriteLogToDisk
(
)
;
void
ReadIndexFromDisk
(
)
;
void
StartReadingIndex
(
)
;
void
ParseRecords
(
)
;
void
StartReadingJournal
(
)
;
void
ParseJournal
(
)
;
void
MergeJournal
(
)
;
void
EnsureNoFreshEntry
(
)
;
void
EnsureCorrectStats
(
)
;
void
FinishRead
(
bool
aSucceeded
)
;
static
void
DelayedUpdate
(
nsITimer
*
aTimer
void
*
aClosure
)
;
void
DelayedUpdateLocked
(
)
;
nsresult
ScheduleUpdateTimer
(
uint32_t
aDelay
)
;
nsresult
SetupDirectoryEnumerator
(
)
;
nsresult
InitEntryFromDiskData
(
CacheIndexEntry
*
aEntry
CacheFileMetadata
*
aMetaData
int64_t
aFileSize
)
;
bool
IsUpdatePending
(
)
;
void
BuildIndex
(
)
;
bool
StartUpdatingIndexIfNeeded
(
bool
aSwitchingToReadyState
=
false
)
;
void
StartUpdatingIndex
(
bool
aRebuild
)
;
void
UpdateIndex
(
)
;
void
FinishUpdate
(
bool
aSucceeded
)
;
void
RemoveNonFreshEntries
(
)
;
enum
EState
{
INITIAL
=
0
READING
=
1
WRITING
=
2
BUILDING
=
3
UPDATING
=
4
READY
=
5
SHUTDOWN
=
6
}
;
static
char
const
*
StateString
(
EState
aState
)
;
void
ChangeState
(
EState
aNewState
)
;
void
NotifyAsyncGetDiskConsumptionCallbacks
(
)
;
void
AllocBuffer
(
)
;
void
ReleaseBuffer
(
)
;
void
AddRecordToIterators
(
CacheIndexRecord
*
aRecord
)
;
void
RemoveRecordFromIterators
(
CacheIndexRecord
*
aRecord
)
;
void
ReplaceRecordInIterators
(
CacheIndexRecord
*
aOldRecord
CacheIndexRecord
*
aNewRecord
)
;
size_t
SizeOfExcludingThisInternal
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
void
DoTelemetryReport
(
)
;
static
mozilla
:
:
StaticRefPtr
<
CacheIndex
>
gInstance
;
static
StaticMutex
sLock
;
nsCOMPtr
<
nsIFile
>
mCacheDirectory
;
EState
mState
;
TimeStamp
mStartTime
;
bool
mShuttingDown
;
bool
mIndexNeedsUpdate
;
bool
mRemovingAll
;
bool
mIndexOnDiskIsValid
;
bool
mDontMarkIndexClean
;
uint32_t
mIndexTimeStamp
;
TimeStamp
mLastDumpTime
;
nsCOMPtr
<
nsITimer
>
mUpdateTimer
;
bool
mUpdateEventPending
;
uint32_t
mSkipEntries
;
uint32_t
mProcessEntries
;
char
*
mRWBuf
;
uint32_t
mRWBufSize
;
uint32_t
mRWBufPos
;
RefPtr
<
CacheHash
>
mRWHash
;
bool
mRWPending
;
bool
mJournalReadSuccessfully
;
RefPtr
<
CacheFileHandle
>
mIndexHandle
;
RefPtr
<
CacheFileHandle
>
mJournalHandle
;
RefPtr
<
CacheFileHandle
>
mTmpHandle
;
RefPtr
<
FileOpenHelper
>
mIndexFileOpener
;
RefPtr
<
FileOpenHelper
>
mJournalFileOpener
;
RefPtr
<
FileOpenHelper
>
mTmpFileOpener
;
nsCOMPtr
<
nsIDirectoryEnumerator
>
mDirEnumerator
;
nsTHashtable
<
CacheIndexEntry
>
mIndex
;
nsTHashtable
<
CacheIndexEntryUpdate
>
mPendingUpdates
;
CacheIndexStats
mIndexStats
;
nsTHashtable
<
CacheIndexEntry
>
mTmpJournal
;
class
FrecencyArray
{
class
Iterator
{
public
:
explicit
Iterator
(
nsTArray
<
CacheIndexRecord
*
>
*
aRecs
)
:
mRecs
(
aRecs
)
mIdx
(
0
)
{
while
(
!
Done
(
)
&
&
!
(
*
mRecs
)
[
mIdx
]
)
{
mIdx
+
+
;
}
}
bool
Done
(
)
const
{
return
mIdx
=
=
mRecs
-
>
Length
(
)
;
}
CacheIndexRecord
*
Get
(
)
const
{
MOZ_ASSERT
(
!
Done
(
)
)
;
return
(
*
mRecs
)
[
mIdx
]
;
}
void
Next
(
)
{
MOZ_ASSERT
(
!
Done
(
)
)
;
+
+
mIdx
;
while
(
!
Done
(
)
&
&
!
(
*
mRecs
)
[
mIdx
]
)
{
mIdx
+
+
;
}
}
private
:
nsTArray
<
CacheIndexRecord
*
>
*
mRecs
;
uint32_t
mIdx
;
}
;
public
:
Iterator
Iter
(
)
{
return
Iterator
(
&
mRecs
)
;
}
FrecencyArray
(
)
:
mUnsortedElements
(
0
)
mRemovedElements
(
0
)
{
}
void
AppendRecord
(
CacheIndexRecord
*
aRecord
)
;
void
RemoveRecord
(
CacheIndexRecord
*
aRecord
)
;
void
ReplaceRecord
(
CacheIndexRecord
*
aOldRecord
CacheIndexRecord
*
aNewRecord
)
;
bool
RecordExisted
(
CacheIndexRecord
*
aRecord
)
;
void
SortIfNeeded
(
)
;
size_t
Length
(
)
const
{
return
mRecs
.
Length
(
)
-
mRemovedElements
;
}
void
Clear
(
)
{
mRecs
.
Clear
(
)
;
}
private
:
friend
class
CacheIndex
;
nsTArray
<
CacheIndexRecord
*
>
mRecs
;
uint32_t
mUnsortedElements
;
uint32_t
mRemovedElements
;
}
;
FrecencyArray
mFrecencyArray
;
nsTArray
<
CacheIndexIterator
*
>
mIterators
;
bool
mAsyncGetDiskConsumptionBlocked
;
class
DiskConsumptionObserver
:
public
Runnable
{
public
:
static
DiskConsumptionObserver
*
Init
(
nsICacheStorageConsumptionObserver
*
aObserver
)
{
nsWeakPtr
observer
=
do_GetWeakReference
(
aObserver
)
;
if
(
!
observer
)
return
nullptr
;
return
new
DiskConsumptionObserver
(
observer
)
;
}
void
OnDiskConsumption
(
int64_t
aSize
)
{
mSize
=
aSize
;
NS_DispatchToMainThread
(
this
)
;
}
private
:
explicit
DiskConsumptionObserver
(
nsWeakPtr
const
&
aWeakObserver
)
:
Runnable
(
"
net
:
:
CacheIndex
:
:
DiskConsumptionObserver
"
)
mObserver
(
aWeakObserver
)
mSize
(
0
)
{
}
virtual
~
DiskConsumptionObserver
(
)
{
if
(
mObserver
&
&
!
NS_IsMainThread
(
)
)
{
NS_ReleaseOnMainThread
(
"
DiskConsumptionObserver
:
:
mObserver
"
mObserver
.
forget
(
)
)
;
}
}
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsICacheStorageConsumptionObserver
>
observer
=
do_QueryReferent
(
mObserver
)
;
mObserver
=
nullptr
;
if
(
observer
)
{
observer
-
>
OnNetworkCacheDiskConsumption
(
mSize
)
;
}
return
NS_OK
;
}
nsWeakPtr
mObserver
;
int64_t
mSize
;
}
;
nsTArray
<
RefPtr
<
DiskConsumptionObserver
>
>
mDiskConsumptionObservers
;
uint64_t
mTotalBytesWritten
;
}
;
}
}
#
endif
