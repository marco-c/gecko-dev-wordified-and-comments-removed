#
ifndef
CacheIOThread__h__
#
define
CacheIOThread__h__
#
include
"
nsIThreadInternal
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
prthread
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
mozilla
/
Monitor
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
class
nsIRunnable
;
namespace
mozilla
{
namespace
net
{
namespace
detail
{
class
BlockingIOWatcher
;
}
class
CacheIOThread
final
:
public
nsIThreadObserver
{
virtual
~
CacheIOThread
(
)
;
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSITHREADOBSERVER
CacheIOThread
(
)
;
using
EventQueue
=
nsTArray
<
nsCOMPtr
<
nsIRunnable
>
>
;
enum
ELevel
:
uint32_t
{
OPEN_PRIORITY
READ_PRIORITY
MANAGEMENT
OPEN
READ
WRITE_PRIORITY
WRITE
INDEX
EVICT
LAST_LEVEL
XPCOM_LEVEL
}
;
nsresult
Init
(
)
;
nsresult
Dispatch
(
nsIRunnable
*
aRunnable
uint32_t
aLevel
)
;
nsresult
Dispatch
(
already_AddRefed
<
nsIRunnable
>
uint32_t
aLevel
)
;
nsresult
DispatchAfterPendingOpens
(
nsIRunnable
*
aRunnable
)
;
bool
IsCurrentThread
(
)
;
uint32_t
QueueSize
(
bool
highPriority
)
;
uint32_t
EventCounter
(
)
const
{
return
mEventCounter
;
}
static
bool
YieldAndRerun
(
)
{
return
sSelf
?
sSelf
-
>
YieldInternal
(
)
:
false
;
}
void
Shutdown
(
)
;
void
CancelBlockingIO
(
)
;
already_AddRefed
<
nsIEventTarget
>
Target
(
)
;
class
Cancelable
{
bool
mCancelable
;
public
:
explicit
Cancelable
(
bool
aCancelable
)
;
~
Cancelable
(
)
;
}
;
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
private
:
static
void
ThreadFunc
(
void
*
aClosure
)
;
void
ThreadFunc
(
)
;
void
LoopOneLevel
(
uint32_t
aLevel
)
;
bool
EventsPending
(
uint32_t
aLastLevel
=
LAST_LEVEL
)
;
nsresult
DispatchInternal
(
already_AddRefed
<
nsIRunnable
>
aRunnable
uint32_t
aLevel
)
;
bool
YieldInternal
(
)
;
static
CacheIOThread
*
sSelf
;
mozilla
:
:
Monitor
mMonitor
MOZ_UNANNOTATED
{
"
CacheIOThread
"
}
;
PRThread
*
mThread
{
nullptr
}
;
UniquePtr
<
detail
:
:
BlockingIOWatcher
>
mBlockingIOWatcher
;
Atomic
<
nsIThread
*
>
mXPCOMThread
{
nullptr
}
;
Atomic
<
uint32_t
Relaxed
>
mLowestLevelWaiting
{
LAST_LEVEL
}
;
uint32_t
mCurrentlyExecutingLevel
{
0
}
;
Atomic
<
int32_t
>
mQueueLength
[
LAST_LEVEL
]
;
EventQueue
mEventQueue
[
LAST_LEVEL
]
;
Atomic
<
bool
Relaxed
>
mHasXPCOMEvents
{
false
}
;
bool
mRerunCurrentEvent
{
false
}
;
bool
mShutdown
{
false
}
;
Atomic
<
uint32_t
Relaxed
>
mIOCancelableEvents
{
0
}
;
Atomic
<
uint32_t
Relaxed
>
mEventCounter
{
0
}
;
#
ifdef
DEBUG
bool
mInsideLoop
{
true
}
;
#
endif
}
;
}
}
#
endif
