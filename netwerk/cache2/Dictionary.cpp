#
include
<
algorithm
>
#
include
"
Dictionary
.
h
"
#
include
"
nsAppDirectoryServiceDefs
.
h
"
#
include
"
nsIAsyncInputStream
.
h
"
#
include
"
nsICacheStorageService
.
h
"
#
include
"
nsICacheStorage
.
h
"
#
include
"
nsICacheEntry
.
h
"
#
include
"
nsICachingChannel
.
h
"
#
include
"
nsICancelable
.
h
"
#
include
"
nsIChannel
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsIHttpChannel
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsILoadContext
.
h
"
#
include
"
nsILoadContextInfo
.
h
"
#
include
"
nsILoadGroup
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsInputStreamPump
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsStreamUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
Components
.
h
"
#
include
"
mozilla
/
OriginAttributes
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
SchedulerGroup
.
h
"
#
include
"
mozilla
/
StaticPrefs_network
.
h
"
#
include
"
mozilla
/
glean
/
NetwerkMetrics
.
h
"
#
include
"
mozilla
/
net
/
NeckoCommon
.
h
"
#
include
"
mozilla
/
net
/
NeckoParent
.
h
"
#
include
"
LoadContextInfo
.
h
"
#
include
"
mozilla
/
ipc
/
URIUtils
.
h
"
#
include
"
SerializedLoadContext
.
h
"
#
include
"
mozilla
/
net
/
NeckoChild
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
ReferrerInfo
.
h
"
using
namespace
mozilla
;
namespace
mozilla
{
namespace
net
{
LazyLogModule
gDictionaryLog
(
"
CompressionDictionaries
"
)
;
#
define
DICTIONARY_LOG
(
args
)
\
MOZ_LOG
(
gDictionaryLog
mozilla
:
:
LogLevel
:
:
Debug
args
)
StaticRefPtr
<
DictionaryCache
>
gDictionaryCache
;
nsCOMPtr
<
nsICacheStorage
>
DictionaryCache
:
:
sCacheStorage
;
DictionaryCacheEntry
:
:
DictionaryCacheEntry
(
const
char
*
aKey
)
{
mURI
=
aKey
;
}
DictionaryCacheEntry
:
:
DictionaryCacheEntry
(
const
nsACString
&
aURI
const
nsACString
&
aPattern
const
nsACString
&
aId
const
Maybe
<
nsCString
>
&
aHash
)
:
mURI
(
aURI
)
mPattern
(
aPattern
)
mId
(
aId
)
{
if
(
aHash
)
{
mHash
=
aHash
.
value
(
)
;
}
}
NS_IMPL_ISUPPORTS
(
DictionaryCacheEntry
nsICacheEntryOpenCallback
nsIStreamListener
)
bool
DictionaryCacheEntry
:
:
Match
(
const
nsACString
&
aFilePath
uint32_t
&
aLongest
)
{
if
(
mHash
.
IsEmpty
(
)
)
{
return
false
;
}
if
(
mPattern
.
Length
(
)
>
aLongest
)
{
DICTIONARY_LOG
(
(
"
Match
:
%
s
to
%
s
"
PromiseFlatCString
(
aFilePath
)
.
get
(
)
PromiseFlatCString
(
mPattern
)
.
get
(
)
)
)
;
if
(
mPattern
.
Last
(
)
=
=
'
*
'
&
&
aFilePath
.
Length
(
)
>
=
mPattern
.
Length
(
)
)
{
nsAutoCString
partial
(
aFilePath
)
;
partial
.
Truncate
(
mPattern
.
Length
(
)
-
1
)
;
nsAutoCString
pattern
(
mPattern
)
;
pattern
.
Truncate
(
mPattern
.
Length
(
)
-
1
)
;
if
(
partial
.
Equals
(
pattern
)
)
{
aLongest
=
mPattern
.
Length
(
)
;
DICTIONARY_LOG
(
(
"
Match
:
%
s
(
longest
%
u
)
"
mURI
.
get
(
)
aLongest
)
)
;
return
true
;
}
return
false
;
}
else
if
(
mPattern
.
Equals
(
aFilePath
)
)
{
if
(
mHash
.
IsEmpty
(
)
)
{
return
false
;
}
aLongest
=
mPattern
.
Length
(
)
;
DICTIONARY_LOG
(
(
"
Match
:
%
s
(
longest
%
u
)
"
PromiseFlatCString
(
mURI
)
.
get
(
)
aLongest
)
)
;
return
true
;
}
}
return
false
;
}
void
DictionaryCacheEntry
:
:
InUse
(
)
{
mUsers
+
+
;
DICTIONARY_LOG
(
(
"
Dictionary
users
for
%
s
-
-
%
u
Users
"
mURI
.
get
(
)
mUsers
)
)
;
}
void
DictionaryCacheEntry
:
:
UseCompleted
(
)
{
MOZ_ASSERT
(
mUsers
>
0
)
;
mUsers
-
-
;
if
(
mUsers
=
=
0
)
{
DICTIONARY_LOG
(
(
"
Clearing
Dictionary
data
for
%
s
"
mURI
.
get
(
)
)
)
;
mDictionaryData
.
clear
(
)
;
mDictionaryDataComplete
=
false
;
}
else
{
DICTIONARY_LOG
(
(
"
Not
clearing
Dictionary
data
for
%
s
-
-
%
u
Users
"
mURI
.
get
(
)
mUsers
)
)
;
}
}
bool
DictionaryCacheEntry
:
:
Prefetch
(
nsILoadContextInfo
*
aLoadContextInfo
const
std
:
:
function
<
void
(
)
>
&
aFunc
)
{
DICTIONARY_LOG
(
(
"
Prefetch
for
%
s
"
mURI
.
get
(
)
)
)
;
if
(
mWaitingPrefetch
.
IsEmpty
(
)
)
{
if
(
!
mDictionaryDataComplete
)
{
nsCOMPtr
<
nsICacheStorageService
>
cacheStorageService
(
components
:
:
CacheStorage
:
:
Service
(
)
)
;
if
(
!
cacheStorageService
)
{
return
false
;
}
nsCOMPtr
<
nsICacheStorage
>
cacheStorage
;
nsresult
rv
=
cacheStorageService
-
>
DiskCacheStorage
(
aLoadContextInfo
getter_AddRefs
(
cacheStorage
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
mWaitingPrefetch
.
AppendElement
(
aFunc
)
;
cacheStorage
-
>
AsyncOpenURIString
(
mURI
"
"
_ns
nsICacheStorage
:
:
OPEN_READONLY
this
)
;
DICTIONARY_LOG
(
(
"
Started
Prefetch
for
%
s
anonymous
=
%
d
"
mURI
.
get
(
)
aLoadContextInfo
-
>
IsAnonymous
(
)
)
)
;
return
true
;
}
DICTIONARY_LOG
(
(
"
Prefetch
for
%
s
-
already
have
data
in
memory
(
%
u
users
)
"
mURI
.
get
(
)
mUsers
)
)
;
return
false
;
}
DICTIONARY_LOG
(
(
"
Prefetch
for
%
s
-
already
waiting
"
mURI
.
get
(
)
)
)
;
return
true
;
}
void
DictionaryCacheEntry
:
:
AccumulateHash
(
const
char
*
aBuf
int32_t
aCount
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
mHash
.
IsEmpty
(
)
)
{
if
(
!
mDictionaryData
.
empty
(
)
)
{
return
;
}
return
;
}
if
(
!
mCrypto
)
{
DICTIONARY_LOG
(
(
"
Calculating
new
hash
for
%
s
"
mURI
.
get
(
)
)
)
;
nsresult
rv
;
mCrypto
=
do_CreateInstance
(
NS_CRYPTO_HASH_CONTRACTID
&
rv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
rv
=
mCrypto
-
>
Init
(
nsICryptoHash
:
:
SHA256
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Cache
InitCrypto
failed
"
)
;
}
mCrypto
-
>
Update
(
reinterpret_cast
<
const
uint8_t
*
>
(
aBuf
)
aCount
)
;
DICTIONARY_LOG
(
(
"
Accumulate
Hash
%
p
:
%
d
bytes
total
%
zu
"
this
aCount
mDictionaryData
.
length
(
)
)
)
;
}
void
DictionaryCacheEntry
:
:
FinishHash
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mCrypto
)
{
mCrypto
-
>
Finish
(
true
mHash
)
;
mCrypto
=
nullptr
;
DICTIONARY_LOG
(
(
"
Hash
for
%
p
(
%
s
)
is
%
s
"
this
mURI
.
get
(
)
mHash
.
get
(
)
)
)
;
if
(
mOrigin
)
{
DICTIONARY_LOG
(
(
"
Write
on
hash
"
)
)
;
mOrigin
-
>
Write
(
this
)
;
if
(
!
mBlocked
)
{
mOrigin
-
>
FinishAddEntry
(
this
)
;
}
mOrigin
=
nullptr
;
}
}
}
static
void
EscapeMetadataString
(
const
nsACString
&
aInput
nsCString
&
aOutput
)
{
const
char
*
src
=
aInput
.
BeginReading
(
)
;
size_t
len
=
1
;
while
(
*
src
)
{
if
(
*
src
=
=
'
|
'
|
|
*
src
=
=
'
\
\
'
)
{
len
+
=
2
;
}
else
{
len
+
+
;
}
src
+
+
;
}
aOutput
.
SetCapacity
(
aOutput
.
Length
(
)
+
len
)
;
src
=
aInput
.
BeginReading
(
)
;
aOutput
.
AppendLiteral
(
"
|
"
)
;
while
(
*
src
)
{
if
(
*
src
=
=
'
|
'
|
|
*
src
=
=
'
\
\
'
)
{
aOutput
.
AppendLiteral
(
"
\
\
"
)
;
}
aOutput
.
Append
(
*
src
+
+
)
;
}
}
void
DictionaryCacheEntry
:
:
MakeMetadataEntry
(
nsCString
&
aNewValue
)
{
EscapeMetadataString
(
mHash
aNewValue
)
;
EscapeMetadataString
(
mPattern
aNewValue
)
;
EscapeMetadataString
(
mId
aNewValue
)
;
EscapeMetadataString
(
"
"
_ns
aNewValue
)
;
}
nsresult
DictionaryCacheEntry
:
:
Write
(
nsICacheEntry
*
aCacheEntry
)
{
nsAutoCStringN
<
2048
>
metadata
;
MakeMetadataEntry
(
metadata
)
;
DICTIONARY_LOG
(
(
"
DictionaryCacheEntry
:
:
Write
%
s
%
s
"
mURI
.
get
(
)
metadata
.
get
(
)
)
)
;
return
aCacheEntry
-
>
SetMetaDataElement
(
mURI
.
get
(
)
metadata
.
get
(
)
)
;
}
nsresult
DictionaryCacheEntry
:
:
RemoveEntry
(
nsICacheEntry
*
aCacheEntry
)
{
return
aCacheEntry
-
>
SetMetaDataElement
(
mURI
.
BeginReading
(
)
nullptr
)
;
}
static
const
char
*
GetEncodedString
(
const
char
*
aSrc
nsACString
&
aOutput
)
{
aOutput
.
Truncate
(
)
;
while
(
*
aSrc
)
{
if
(
*
aSrc
=
=
'
|
'
)
{
break
;
}
if
(
*
aSrc
=
=
'
\
\
'
)
{
aSrc
+
+
;
}
aOutput
.
Append
(
*
aSrc
+
+
)
;
}
return
aSrc
;
}
bool
DictionaryCacheEntry
:
:
ParseMetadata
(
const
char
*
aSrc
)
{
MOZ_ASSERT
(
*
aSrc
=
=
'
|
'
)
;
aSrc
+
+
;
aSrc
=
GetEncodedString
(
aSrc
mHash
)
;
aSrc
=
GetEncodedString
(
aSrc
mPattern
)
;
aSrc
=
GetEncodedString
(
aSrc
mId
)
;
nsAutoCString
temp
;
do
{
aSrc
=
GetEncodedString
(
aSrc
temp
)
;
if
(
!
temp
.
IsEmpty
(
)
)
{
}
}
while
(
!
temp
.
IsEmpty
(
)
)
;
aSrc
=
GetEncodedString
(
aSrc
temp
)
;
DICTIONARY_LOG
(
(
"
Parse
entry
%
s
:
|
%
s
|
%
s
id
=
%
s
"
PromiseFlatCString
(
mURI
)
.
get
(
)
PromiseFlatCString
(
mHash
)
.
get
(
)
PromiseFlatCString
(
mPattern
)
.
get
(
)
mId
.
get
(
)
)
)
;
return
true
;
}
NS_IMETHODIMP
DictionaryCacheEntry
:
:
OnStartRequest
(
nsIRequest
*
request
)
{
DICTIONARY_LOG
(
(
"
DictionaryCacheEntry
%
s
OnStartRequest
"
mURI
.
get
(
)
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
DictionaryCacheEntry
:
:
OnDataAvailable
(
nsIRequest
*
request
nsIInputStream
*
aInputStream
uint64_t
aOffset
uint32_t
aCount
)
{
uint32_t
n
;
DICTIONARY_LOG
(
(
"
DictionaryCacheEntry
%
s
OnDataAvailable
%
u
"
mURI
.
get
(
)
aCount
)
)
;
return
aInputStream
-
>
ReadSegments
(
&
DictionaryCacheEntry
:
:
ReadCacheData
this
aCount
&
n
)
;
}
nsresult
DictionaryCacheEntry
:
:
ReadCacheData
(
nsIInputStream
*
aInStream
void
*
aClosure
const
char
*
aFromSegment
uint32_t
aToOffset
uint32_t
aCount
uint32_t
*
aWriteCount
)
{
DictionaryCacheEntry
*
self
=
static_cast
<
DictionaryCacheEntry
*
>
(
aClosure
)
;
Unused
<
<
self
-
>
mDictionaryData
.
append
(
aFromSegment
aCount
)
;
DICTIONARY_LOG
(
(
"
Accumulate
%
p
(
%
s
)
:
%
d
bytes
total
%
zu
"
self
self
-
>
mURI
.
get
(
)
aCount
self
-
>
mDictionaryData
.
length
(
)
)
)
;
*
aWriteCount
=
aCount
;
return
NS_OK
;
}
NS_IMETHODIMP
DictionaryCacheEntry
:
:
OnStopRequest
(
nsIRequest
*
request
nsresult
result
)
{
DICTIONARY_LOG
(
(
"
DictionaryCacheEntry
%
s
OnStopRequest
"
mURI
.
get
(
)
)
)
;
if
(
NS_SUCCEEDED
(
result
)
)
{
mDictionaryDataComplete
=
true
;
DICTIONARY_LOG
(
(
"
Unsuspending
%
zu
channels
Dictionary
len
%
zu
"
mWaitingPrefetch
.
Length
(
)
mDictionaryData
.
length
(
)
)
)
;
for
(
auto
&
lambda
:
mWaitingPrefetch
)
{
(
lambda
)
(
)
;
}
mWaitingPrefetch
.
Clear
(
)
;
}
else
{
}
RefPtr
<
DictionaryCacheEntry
>
self
;
if
(
mReplacement
)
{
DICTIONARY_LOG
(
(
"
Replacing
entry
%
p
with
%
p
for
%
s
"
this
mReplacement
.
get
(
)
mURI
.
get
(
)
)
)
;
self
=
this
;
mReplacement
-
>
mShouldSuspend
=
false
;
mOrigin
-
>
RemoveEntry
(
this
)
;
mReplacement
-
>
UnblockAddEntry
(
mOrigin
)
;
mOrigin
=
nullptr
;
}
mStopReceived
=
true
;
return
NS_OK
;
}
void
DictionaryCacheEntry
:
:
UnblockAddEntry
(
DictionaryOrigin
*
aOrigin
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
mHash
.
IsEmpty
(
)
)
{
aOrigin
-
>
FinishAddEntry
(
this
)
;
}
mBlocked
=
false
;
}
void
DictionaryCacheEntry
:
:
WriteOnHash
(
DictionaryOrigin
*
aOrigin
)
{
bool
hasHash
=
false
;
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
mHash
.
IsEmpty
(
)
)
{
hasHash
=
true
;
}
}
if
(
hasHash
)
{
DICTIONARY_LOG
(
(
"
Write
already
hashed
"
)
)
;
aOrigin
-
>
Write
(
this
)
;
}
else
if
(
!
mStopReceived
)
{
mOrigin
=
aOrigin
;
}
}
NS_IMETHODIMP
DictionaryCacheEntry
:
:
OnCacheEntryCheck
(
nsICacheEntry
*
aEntry
uint32_t
*
result
)
{
DICTIONARY_LOG
(
(
"
OnCacheEntryCheck
%
s
"
mURI
.
get
(
)
)
)
;
*
result
=
nsICacheEntryOpenCallback
:
:
ENTRY_WANTED
;
return
NS_OK
;
}
NS_IMETHODIMP
DictionaryCacheEntry
:
:
OnCacheEntryAvailable
(
nsICacheEntry
*
entry
bool
isNew
nsresult
status
)
{
DICTIONARY_LOG
(
(
"
OnCacheEntryAvailable
%
s
result
%
u
entry
%
p
"
mURI
.
get
(
)
(
uint32_t
)
status
entry
)
)
;
if
(
entry
)
{
nsCOMPtr
<
nsIInputStream
>
stream
;
entry
-
>
OpenInputStream
(
0
getter_AddRefs
(
stream
)
)
;
if
(
!
stream
)
{
return
NS_OK
;
}
RefPtr
<
nsInputStreamPump
>
pump
;
nsresult
rv
=
nsInputStreamPump
:
:
Create
(
getter_AddRefs
(
pump
)
stream
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_OK
;
}
rv
=
pump
-
>
AsyncRead
(
this
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_OK
;
}
DICTIONARY_LOG
(
(
"
Waiting
for
data
"
)
)
;
}
else
{
DICTIONARY_LOG
(
(
"
Prefetched
cache
entry
not
available
!
"
)
)
;
}
return
NS_OK
;
}
class
DictionaryOriginReader
final
:
public
nsICacheEntryOpenCallback
public
nsIStreamListener
{
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSICACHEENTRYOPENCALLBACK
NS_DECL_NSIREQUESTOBSERVER
NS_DECL_NSISTREAMLISTENER
DictionaryOriginReader
(
)
{
}
void
Start
(
DictionaryOrigin
*
aOrigin
nsACString
&
aKey
nsIURI
*
aURI
DictionaryCache
*
aCache
const
std
:
:
function
<
nsresult
(
DictionaryCacheEntry
*
)
>
&
aCallback
)
{
mOrigin
=
aOrigin
;
mURI
=
aURI
;
mCallback
=
aCallback
;
mCache
=
aCache
;
mSelf
=
this
;
DICTIONARY_LOG
(
(
"
DictionaryOriginReader
:
:
Start
(
%
s
)
:
%
p
"
PromiseFlatCString
(
aKey
)
.
get
(
)
this
)
)
;
DictionaryCache
:
:
sCacheStorage
-
>
AsyncOpenURIString
(
aKey
META_DICTIONARY_PREFIX
aOrigin
?
nsICacheStorage
:
:
OPEN_NORMALLY
:
nsICacheStorage
:
:
OPEN_READONLY
|
nsICacheStorage
:
:
OPEN_SECRETLY
this
)
;
}
private
:
~
DictionaryOriginReader
(
)
{
}
RefPtr
<
DictionaryOrigin
>
mOrigin
;
nsCOMPtr
<
nsIURI
>
mURI
;
std
:
:
function
<
nsresult
(
DictionaryCacheEntry
*
)
>
mCallback
;
RefPtr
<
DictionaryCache
>
mCache
;
RefPtr
<
DictionaryOriginReader
>
mSelf
;
}
;
NS_IMPL_ISUPPORTS
(
DictionaryOriginReader
nsICacheEntryOpenCallback
nsIStreamListener
)
NS_IMETHODIMP
DictionaryOriginReader
:
:
OnCacheEntryCheck
(
nsICacheEntry
*
entry
uint32_t
*
result
)
{
*
result
=
nsICacheEntryOpenCallback
:
:
ENTRY_WANTED
;
DICTIONARY_LOG
(
(
"
DictionaryOriginReader
:
:
OnCacheEntryCheck
this
=
%
p
for
entry
%
p
"
this
entry
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
DictionaryOriginReader
:
:
OnCacheEntryAvailable
(
nsICacheEntry
*
aCacheEntry
bool
isNew
nsresult
result
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Got
cache
entry
off
main
thread
!
"
)
;
DICTIONARY_LOG
(
(
"
DictionaryOriginReader
:
:
OnCacheEntryAvailable
this
=
%
p
for
entry
%
p
"
this
aCacheEntry
)
)
;
if
(
!
aCacheEntry
)
{
(
mCallback
)
(
nullptr
)
;
return
NS_OK
;
}
if
(
mOrigin
)
{
mOrigin
-
>
SetCacheEntry
(
aCacheEntry
)
;
nsCOMPtr
<
nsICacheEntryMetaDataVisitor
>
metadata
(
mOrigin
)
;
aCacheEntry
-
>
VisitMetaData
(
metadata
)
;
(
mCallback
)
(
nullptr
)
;
mSelf
=
nullptr
;
return
NS_OK
;
}
nsCString
prepath
;
if
(
NS_FAILED
(
mURI
-
>
GetPrePath
(
prepath
)
)
)
{
(
mCallback
)
(
nullptr
)
;
return
NS_ERROR_FAILURE
;
}
Unused
<
<
mCache
-
>
mDictionaryCache
.
WithEntryHandle
(
prepath
[
&
]
(
auto
&
&
entry
)
{
auto
&
origin
=
entry
.
OrInsertWith
(
[
&
]
{
return
new
DictionaryOrigin
(
prepath
aCacheEntry
)
;
}
)
;
nsCOMPtr
<
nsICacheEntryMetaDataVisitor
>
metadata
(
origin
)
;
aCacheEntry
-
>
VisitMetaData
(
metadata
)
;
nsCString
path
;
mURI
-
>
GetPathQueryRef
(
path
)
;
RefPtr
<
DictionaryCacheEntry
>
result
=
origin
-
>
Match
(
path
)
;
(
mCallback
)
(
result
)
;
mSelf
=
nullptr
;
return
NS_OK
;
}
)
;
return
NS_OK
;
}
NS_IMETHODIMP
DictionaryOriginReader
:
:
OnStartRequest
(
nsIRequest
*
request
)
{
DICTIONARY_LOG
(
(
"
DictionaryOriginReader
%
p
OnStartRequest
"
this
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
DictionaryOriginReader
:
:
OnDataAvailable
(
nsIRequest
*
request
nsIInputStream
*
aInputStream
uint64_t
aOffset
uint32_t
aCount
)
{
uint32_t
n
;
DICTIONARY_LOG
(
(
"
DictionaryOriginReader
%
p
OnDataAvailable
%
u
"
this
aCount
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
DictionaryOriginReader
:
:
OnStopRequest
(
nsIRequest
*
request
nsresult
result
)
{
DICTIONARY_LOG
(
(
"
DictionaryOriginReader
%
p
OnStopRequest
"
this
)
)
;
return
NS_OK
;
}
already_AddRefed
<
DictionaryCache
>
DictionaryCache
:
:
GetInstance
(
)
{
if
(
!
gDictionaryCache
)
{
gDictionaryCache
=
new
DictionaryCache
(
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
gDictionaryCache
-
>
Init
(
)
)
)
;
}
return
do_AddRef
(
gDictionaryCache
)
;
}
nsresult
DictionaryCache
:
:
Init
(
)
{
if
(
XRE_IsParentProcess
(
)
)
{
nsCOMPtr
<
nsICacheStorageService
>
cacheStorageService
(
components
:
:
CacheStorage
:
:
Service
(
)
)
;
if
(
!
cacheStorageService
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
cacheStorageService
-
>
DiskCacheStorage
(
nullptr
getter_AddRefs
(
sCacheStorage
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
DICTIONARY_LOG
(
(
"
Inited
DictionaryCache
%
p
"
sCacheStorage
.
get
(
)
)
)
;
return
NS_OK
;
}
nsresult
DictionaryCache
:
:
AddEntry
(
nsIURI
*
aURI
const
nsACString
&
aKey
const
nsACString
&
aPattern
const
nsACString
&
aId
const
Maybe
<
nsCString
>
&
aHash
bool
aNewEntry
DictionaryCacheEntry
*
*
aDictEntry
)
{
RefPtr
<
DictionaryCacheEntry
>
dict
=
new
DictionaryCacheEntry
(
aKey
aPattern
aId
aHash
)
;
dict
=
AddEntry
(
aURI
aNewEntry
dict
)
;
if
(
dict
)
{
*
aDictEntry
=
do_AddRef
(
dict
)
.
take
(
)
;
return
NS_OK
;
}
DICTIONARY_LOG
(
(
"
Failed
adding
entry
for
%
s
"
PromiseFlatCString
(
aKey
)
.
get
(
)
)
)
;
*
aDictEntry
=
nullptr
;
return
NS_ERROR_FAILURE
;
}
already_AddRefed
<
DictionaryCacheEntry
>
DictionaryCache
:
:
AddEntry
(
nsIURI
*
aURI
bool
aNewEntry
DictionaryCacheEntry
*
aDictEntry
)
{
nsCString
prepath
;
if
(
NS_FAILED
(
aURI
-
>
GetPrePath
(
prepath
)
)
)
{
return
nullptr
;
}
RefPtr
<
DictionaryCacheEntry
>
newEntry
;
Unused
<
<
mDictionaryCache
.
WithEntryHandle
(
prepath
[
&
]
(
auto
&
&
entry
)
{
auto
&
origin
=
entry
.
OrInsertWith
(
[
&
]
{
RefPtr
<
DictionaryOrigin
>
origin
=
new
DictionaryOrigin
(
prepath
nullptr
)
;
RefPtr
<
DictionaryOriginReader
>
reader
=
new
DictionaryOriginReader
(
)
;
reader
-
>
Start
(
origin
prepath
aURI
this
[
origin
aDictEntry
]
(
DictionaryCacheEntry
*
aDict
)
{
aDictEntry
-
>
WriteOnHash
(
origin
)
;
return
NS_OK
;
}
)
;
return
origin
;
}
)
;
newEntry
=
origin
-
>
AddEntry
(
aDictEntry
aNewEntry
)
;
return
NS_OK
;
}
)
;
return
newEntry
.
forget
(
)
;
}
nsresult
DictionaryCache
:
:
RemoveEntry
(
nsIURI
*
aURI
const
nsACString
&
aKey
)
{
nsCString
prepath
;
if
(
NS_FAILED
(
aURI
-
>
GetPrePath
(
prepath
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
auto
origin
=
mDictionaryCache
.
Lookup
(
prepath
)
)
{
return
origin
.
Data
(
)
-
>
RemoveEntry
(
aKey
)
;
}
return
NS_ERROR_FAILURE
;
}
void
DictionaryCache
:
:
GetDictionaryFor
(
nsIURI
*
aURI
const
std
:
:
function
<
nsresult
(
DictionaryCacheEntry
*
)
>
&
aCallback
)
{
nsCString
prepath
;
if
(
NS_FAILED
(
aURI
-
>
GetPrePath
(
prepath
)
)
)
{
(
aCallback
)
(
nullptr
)
;
return
;
}
if
(
auto
origin
=
mDictionaryCache
.
Lookup
(
prepath
)
)
{
nsCString
path
;
RefPtr
<
DictionaryCacheEntry
>
result
;
aURI
-
>
GetPathQueryRef
(
path
)
;
DICTIONARY_LOG
(
(
"
GetDictionaryFor
(
%
s
%
s
)
"
prepath
.
get
(
)
path
.
get
(
)
)
)
;
result
=
origin
.
Data
(
)
-
>
Match
(
path
)
;
(
aCallback
)
(
result
)
;
return
;
}
if
(
!
sCacheStorage
)
{
(
aCallback
)
(
nullptr
)
;
return
;
}
DICTIONARY_LOG
(
(
"
Reading
%
s
for
dictionary
entries
"
PromiseFlatCString
(
prepath
)
.
get
(
)
)
)
;
RefPtr
<
DictionaryOriginReader
>
reader
=
new
DictionaryOriginReader
(
)
;
reader
-
>
Start
(
nullptr
prepath
aURI
this
aCallback
)
;
}
NS_IMPL_ISUPPORTS
(
DictionaryOrigin
nsICacheEntryMetaDataVisitor
)
void
DictionaryOrigin
:
:
Write
(
DictionaryCacheEntry
*
aDictEntry
)
{
DICTIONARY_LOG
(
(
"
DictionaryOrigin
:
:
Write
%
s
%
p
"
mOrigin
.
get
(
)
aDictEntry
)
)
;
aDictEntry
-
>
Write
(
mEntry
)
;
}
already_AddRefed
<
DictionaryCacheEntry
>
DictionaryOrigin
:
:
AddEntry
(
DictionaryCacheEntry
*
aDictEntry
bool
aNewEntry
)
{
for
(
size_t
i
=
0
;
i
<
mEntries
.
Length
(
)
;
i
+
+
)
{
if
(
mEntries
[
i
]
-
>
GetURI
(
)
.
Equals
(
aDictEntry
-
>
GetURI
(
)
)
)
{
DictionaryCacheEntry
*
oldEntry
=
mEntries
[
i
]
;
if
(
aNewEntry
)
{
DICTIONARY_LOG
(
(
"
Replacing
dictionary
%
p
for
%
s
:
new
will
be
%
p
"
mEntries
[
i
]
.
get
(
)
PromiseFlatCString
(
oldEntry
-
>
GetURI
(
)
)
.
get
(
)
oldEntry
)
)
;
if
(
mEntries
[
i
]
-
>
IsReading
(
)
&
&
!
aDictEntry
-
>
HasHash
(
)
)
{
DICTIONARY_LOG
(
(
"
Old
entry
is
reading
data
"
)
)
;
mEntries
[
i
]
-
>
SetReplacement
(
aDictEntry
this
)
;
return
do_AddRef
(
aDictEntry
)
;
}
else
{
DICTIONARY_LOG
(
(
"
Removing
old
entry
no
users
or
already
read
data
"
)
)
;
mEntries
[
i
]
-
>
RemoveEntry
(
mEntry
)
;
mEntries
.
RemoveElementAt
(
i
)
;
}
}
else
{
DICTIONARY_LOG
(
(
"
Updating
dictionary
for
%
s
(
%
p
)
"
mOrigin
.
get
(
)
oldEntry
)
)
;
oldEntry
-
>
CopyFrom
(
aDictEntry
)
;
oldEntry
-
>
Write
(
mEntry
)
;
return
nullptr
;
}
break
;
}
}
DICTIONARY_LOG
(
(
"
New
dictionary
%
sfor
%
s
:
%
p
"
aDictEntry
-
>
HasHash
(
)
?
"
"
:
"
(
pending
)
"
mOrigin
.
get
(
)
aDictEntry
)
)
;
if
(
aDictEntry
-
>
HasHash
(
)
)
{
mEntries
.
AppendElement
(
aDictEntry
)
;
}
else
{
mPendingEntries
.
AppendElement
(
aDictEntry
)
;
aDictEntry
-
>
SetReplacement
(
nullptr
this
)
;
}
return
do_AddRef
(
aDictEntry
)
;
}
nsresult
DictionaryOrigin
:
:
RemoveEntry
(
const
nsACString
&
aKey
)
{
for
(
const
auto
&
dict
:
mEntries
)
{
if
(
dict
-
>
GetURI
(
)
.
Equals
(
aKey
)
)
{
mEntries
.
RemoveElement
(
dict
)
;
dict
-
>
RemoveEntry
(
mEntry
)
;
return
NS_OK
;
}
}
return
NS_ERROR_FAILURE
;
}
void
DictionaryOrigin
:
:
FinishAddEntry
(
DictionaryCacheEntry
*
aEntry
)
{
if
(
mPendingEntries
.
RemoveElement
(
aEntry
)
)
{
mEntries
.
InsertElementAt
(
0
aEntry
)
;
}
}
void
DictionaryOrigin
:
:
RemoveEntry
(
DictionaryCacheEntry
*
aEntry
)
{
mEntries
.
RemoveElement
(
aEntry
)
;
}
DictionaryCacheEntry
*
DictionaryOrigin
:
:
Match
(
const
nsACString
&
aPath
)
{
uint32_t
longest
=
0
;
DictionaryCacheEntry
*
result
=
nullptr
;
for
(
const
auto
&
dict
:
mEntries
)
{
if
(
dict
-
>
Match
(
aPath
longest
)
)
{
result
=
dict
;
}
}
return
result
;
}
nsresult
DictionaryOrigin
:
:
OnMetaDataElement
(
const
char
*
asciiKey
const
char
*
asciiValue
)
{
DICTIONARY_LOG
(
(
"
DictionaryOrigin
:
:
OnMetaDataElement
%
s
%
s
"
asciiKey
?
asciiKey
:
"
"
asciiValue
)
)
;
RefPtr
<
DictionaryCacheEntry
>
entry
=
new
DictionaryCacheEntry
(
asciiKey
)
;
if
(
entry
-
>
ParseMetadata
(
asciiValue
)
)
{
mEntries
.
AppendElement
(
entry
)
;
}
return
NS_OK
;
}
}
}
