#
include
<
algorithm
>
#
include
"
Dictionary
.
h
"
#
include
"
nsAppDirectoryServiceDefs
.
h
"
#
include
"
nsICacheStorage
.
h
"
#
include
"
nsICachingChannel
.
h
"
#
include
"
nsICancelable
.
h
"
#
include
"
nsIChannel
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsIHttpChannel
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsILoadContext
.
h
"
#
include
"
nsILoadContextInfo
.
h
"
#
include
"
nsILoadGroup
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsStreamUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
Components
.
h
"
#
include
"
mozilla
/
OriginAttributes
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
SchedulerGroup
.
h
"
#
include
"
mozilla
/
StaticPrefs_network
.
h
"
#
include
"
mozilla
/
glean
/
NetwerkMetrics
.
h
"
#
include
"
mozilla
/
net
/
NeckoCommon
.
h
"
#
include
"
mozilla
/
net
/
NeckoParent
.
h
"
#
include
"
LoadContextInfo
.
h
"
#
include
"
mozilla
/
ipc
/
URIUtils
.
h
"
#
include
"
SerializedLoadContext
.
h
"
#
include
"
mozilla
/
net
/
NeckoChild
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
ReferrerInfo
.
h
"
using
namespace
mozilla
;
namespace
mozilla
{
namespace
net
{
static
LazyLogModule
gDictionaryLog
(
"
CompressionDictionaries
"
)
;
#
define
DICTIONARY_LOG
(
args
)
\
MOZ_LOG
(
gDictionaryLog
mozilla
:
:
LogLevel
:
:
Debug
args
)
StaticRefPtr
<
DictionaryCache
>
gDictionaryCache
;
DictionaryCacheEntry
:
:
DictionaryCacheEntry
(
const
nsACString
&
aURI
const
nsACString
&
aPattern
const
nsACString
&
aId
const
Maybe
<
nsCString
>
&
aHash
)
:
mURI
(
aURI
)
mPattern
(
aPattern
)
mId
(
aId
)
{
if
(
aHash
)
{
mHash
=
aHash
.
value
(
)
;
}
}
bool
DictionaryCacheEntry
:
:
Match
(
const
nsACString
&
aFilePath
uint32_t
&
aLongest
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mPattern
.
Length
(
)
>
aLongest
)
{
DICTIONARY_LOG
(
(
"
Match
:
%
s
to
%
s
"
PromiseFlatCString
(
aFilePath
)
.
get
(
)
PromiseFlatCString
(
mPattern
)
.
get
(
)
)
)
;
if
(
mPattern
.
Last
(
)
=
=
'
*
'
&
&
aFilePath
.
Length
(
)
>
=
mPattern
.
Length
(
)
)
{
nsAutoCString
partial
(
aFilePath
)
;
partial
.
Truncate
(
mPattern
.
Length
(
)
-
1
)
;
nsAutoCString
pattern
(
mPattern
)
;
pattern
.
Truncate
(
mPattern
.
Length
(
)
-
1
)
;
if
(
partial
.
Equals
(
pattern
)
)
{
aLongest
=
mPattern
.
Length
(
)
;
DICTIONARY_LOG
(
(
"
Match
:
%
s
(
longest
%
u
)
"
mURI
.
get
(
)
aLongest
)
)
;
return
true
;
}
return
false
;
}
else
if
(
mPattern
.
Equals
(
aFilePath
)
)
{
if
(
mHash
.
IsEmpty
(
)
)
{
return
false
;
}
aLongest
=
mPattern
.
Length
(
)
;
DICTIONARY_LOG
(
(
"
Match
:
%
s
(
longest
%
u
)
"
PromiseFlatCString
(
mURI
)
.
get
(
)
aLongest
)
)
;
return
true
;
}
}
return
false
;
}
void
DictionaryCacheEntry
:
:
Prefetch
(
)
{
}
already_AddRefed
<
DictionaryCache
>
DictionaryCache
:
:
GetInstance
(
)
{
if
(
!
gDictionaryCache
)
{
gDictionaryCache
=
new
DictionaryCache
(
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
gDictionaryCache
-
>
Init
(
)
)
)
;
}
return
do_AddRef
(
gDictionaryCache
)
;
}
nsresult
DictionaryCache
:
:
Init
(
)
{
return
NS_OK
;
}
nsresult
DictionaryCache
:
:
AddEntry
(
nsIURI
*
aURI
const
nsACString
&
aKey
const
nsACString
&
aPattern
const
nsACString
&
aId
const
Maybe
<
nsCString
>
&
aHash
DictionaryCacheEntry
*
*
aDictEntry
)
{
nsCString
hostport
;
if
(
NS_FAILED
(
aURI
-
>
GetHostPort
(
hostport
)
)
)
{
return
NS_ERROR_FAILURE
;
}
Unused
<
<
mDictionaryCache
.
WithEntryHandle
(
hostport
[
&
]
(
auto
&
&
entry
)
{
auto
&
list
=
entry
.
OrInsertWith
(
[
&
]
{
return
new
DictCacheList
;
}
)
;
for
(
const
auto
&
dict
:
*
list
)
{
if
(
dict
-
>
GetURI
(
)
.
Equals
(
aKey
)
)
{
DICTIONARY_LOG
(
(
"
Reusing
dictionary
for
%
s
:
%
p
"
PromiseFlatCString
(
dict
-
>
GetURI
(
)
)
.
get
(
)
dict
)
)
;
dict
-
>
Clear
(
)
;
*
aDictEntry
=
do_AddRef
(
dict
)
.
take
(
)
;
return
NS_OK
;
}
}
RefPtr
<
DictionaryCacheEntry
>
dict
=
new
DictionaryCacheEntry
(
aKey
aPattern
aId
aHash
)
;
DICTIONARY_LOG
(
(
"
New
dictionary
for
%
s
:
%
p
"
PromiseFlatCString
(
aKey
)
.
get
(
)
dict
.
get
(
)
)
)
;
list
-
>
insertFront
(
dict
)
;
*
aDictEntry
=
do_AddRef
(
dict
)
.
take
(
)
;
return
NS_OK
;
}
)
;
return
NS_OK
;
}
nsresult
DictionaryCache
:
:
AddEntry
(
nsIURI
*
aURI
DictionaryCacheEntry
*
aDictEntry
)
{
nsCString
prepath
;
if
(
NS_FAILED
(
aURI
-
>
GetPrePath
(
prepath
)
)
)
{
return
NS_ERROR_FAILURE
;
}
Unused
<
<
mDictionaryCache
.
WithEntryHandle
(
prepath
[
&
]
(
auto
&
&
entry
)
{
auto
&
list
=
entry
.
OrInsertWith
(
[
&
]
{
return
new
DictCacheList
;
}
)
;
for
(
const
auto
&
dict
:
*
list
)
{
if
(
dict
-
>
GetURI
(
)
.
Equals
(
aDictEntry
-
>
GetURI
(
)
)
)
{
dict
-
>
remove
(
)
;
return
NS_OK
;
}
}
list
-
>
insertFront
(
aDictEntry
)
;
return
NS_OK
;
}
)
;
return
NS_OK
;
}
nsresult
DictionaryCache
:
:
RemoveEntry
(
nsIURI
*
aURI
const
nsACString
&
aKey
)
{
nsCString
prepath
;
if
(
NS_FAILED
(
aURI
-
>
GetPrePath
(
prepath
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
auto
origin
=
mDictionaryCache
.
Lookup
(
prepath
)
)
{
for
(
const
auto
&
dict
:
*
(
origin
-
>
get
(
)
)
)
{
if
(
dict
-
>
GetURI
(
)
.
Equals
(
aKey
)
)
{
dict
-
>
remove
(
)
;
return
NS_OK
;
}
}
return
NS_ERROR_FAILURE
;
}
return
NS_ERROR_FAILURE
;
}
already_AddRefed
<
DictionaryCacheEntry
>
DictionaryCache
:
:
GetDictionaryFor
(
nsIURI
*
aURI
)
{
nsCString
prepath
;
if
(
NS_FAILED
(
aURI
-
>
GetPrePath
(
prepath
)
)
)
{
return
nullptr
;
}
if
(
auto
origin
=
mDictionaryCache
.
Lookup
(
prepath
)
)
{
uint32_t
longest
=
0
;
nsCString
path
;
RefPtr
<
DictionaryCacheEntry
>
result
;
aURI
-
>
GetPathQueryRef
(
path
)
;
for
(
const
auto
&
dict
:
*
(
origin
-
>
get
(
)
)
)
{
if
(
dict
-
>
Valid
(
)
&
&
dict
-
>
Match
(
path
longest
)
)
{
result
=
dict
;
}
}
if
(
result
)
{
result
-
>
removeFrom
(
*
(
origin
-
>
get
(
)
)
)
;
origin
-
>
get
(
)
-
>
insertFront
(
result
)
;
}
return
result
.
forget
(
)
;
}
return
nullptr
;
}
}
}
