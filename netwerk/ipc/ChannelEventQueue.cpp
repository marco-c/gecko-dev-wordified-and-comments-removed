#
include
"
ChannelEventQueue
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsIChannel
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsThreadUtils
.
h
"
namespace
mozilla
{
namespace
net
{
ChannelEvent
*
ChannelEventQueue
:
:
TakeEvent
(
)
{
mMutex
.
AssertCurrentThreadOwns
(
)
;
MOZ_ASSERT
(
mFlushing
)
;
if
(
mSuspended
|
|
mEventQueue
.
IsEmpty
(
)
)
{
return
nullptr
;
}
UniquePtr
<
ChannelEvent
>
event
(
std
:
:
move
(
mEventQueue
[
0
]
)
)
;
mEventQueue
.
RemoveElementAt
(
0
)
;
return
event
.
release
(
)
;
}
void
ChannelEventQueue
:
:
FlushQueue
(
)
{
nsCOMPtr
<
nsISupports
>
kungFuDeathGrip
(
mOwner
)
;
mozilla
:
:
Unused
<
<
kungFuDeathGrip
;
#
ifdef
DEBUG
{
MutexAutoLock
lock
(
mMutex
)
;
MOZ_ASSERT
(
mFlushing
)
;
}
#
endif
bool
needResumeOnOtherThread
=
false
;
while
(
true
)
{
UniquePtr
<
ChannelEvent
>
event
;
{
MutexAutoLock
lock
(
mMutex
)
;
event
.
reset
(
TakeEvent
(
)
)
;
if
(
!
event
)
{
MOZ_ASSERT
(
mFlushing
)
;
mFlushing
=
false
;
MOZ_ASSERT
(
mEventQueue
.
IsEmpty
(
)
|
|
(
mSuspended
|
|
!
!
mForcedCount
)
)
;
break
;
}
}
nsCOMPtr
<
nsIEventTarget
>
target
=
event
-
>
GetEventTarget
(
)
;
MOZ_ASSERT
(
target
)
;
bool
isCurrentThread
=
false
;
nsresult
rv
=
target
-
>
IsOnCurrentThread
(
&
isCurrentThread
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
false
)
;
isCurrentThread
=
true
;
}
if
(
!
isCurrentThread
)
{
Suspend
(
)
;
PrependEvent
(
event
)
;
needResumeOnOtherThread
=
true
;
{
MutexAutoLock
lock
(
mMutex
)
;
MOZ_ASSERT
(
mFlushing
)
;
mFlushing
=
false
;
MOZ_ASSERT
(
!
mEventQueue
.
IsEmpty
(
)
)
;
}
break
;
}
event
-
>
Run
(
)
;
}
if
(
needResumeOnOtherThread
)
{
Resume
(
)
;
}
}
void
ChannelEventQueue
:
:
Suspend
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
SuspendInternal
(
)
;
}
void
ChannelEventQueue
:
:
SuspendInternal
(
)
{
mMutex
.
AssertCurrentThreadOwns
(
)
;
mSuspended
=
true
;
mSuspendCount
+
+
;
}
void
ChannelEventQueue
:
:
Resume
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
ResumeInternal
(
)
;
}
void
ChannelEventQueue
:
:
ResumeInternal
(
)
{
mMutex
.
AssertCurrentThreadOwns
(
)
;
MOZ_ASSERT
(
mSuspendCount
>
0
)
;
if
(
mSuspendCount
<
=
0
)
{
return
;
}
if
(
!
-
-
mSuspendCount
)
{
if
(
mEventQueue
.
IsEmpty
(
)
|
|
!
!
mForcedCount
)
{
mSuspended
=
false
;
return
;
}
class
CompleteResumeRunnable
:
public
CancelableRunnable
{
public
:
explicit
CompleteResumeRunnable
(
ChannelEventQueue
*
aQueue
nsISupports
*
aOwner
)
:
CancelableRunnable
(
"
CompleteResumeRunnable
"
)
mQueue
(
aQueue
)
mOwner
(
aOwner
)
{
}
NS_IMETHOD
Run
(
)
override
{
mQueue
-
>
CompleteResume
(
)
;
return
NS_OK
;
}
private
:
virtual
~
CompleteResumeRunnable
(
)
=
default
;
RefPtr
<
ChannelEventQueue
>
mQueue
;
nsCOMPtr
<
nsISupports
>
mOwner
;
}
;
RefPtr
<
Runnable
>
event
=
new
CompleteResumeRunnable
(
this
mOwner
)
;
nsCOMPtr
<
nsIEventTarget
>
target
;
target
=
mEventQueue
[
0
]
-
>
GetEventTarget
(
)
;
MOZ_ASSERT
(
target
)
;
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
target
-
>
Dispatch
(
event
.
forget
(
)
NS_DISPATCH_NORMAL
)
)
)
;
}
}
bool
ChannelEventQueue
:
:
MaybeSuspendIfEventsAreSuppressed
(
)
{
if
(
!
NS_IsMainThread
(
)
)
{
return
false
;
}
if
(
mHasCheckedForXMLHttpRequest
&
&
!
mForXMLHttpRequest
)
{
return
false
;
}
nsCOMPtr
<
nsIChannel
>
channel
(
do_QueryInterface
(
mOwner
)
)
;
if
(
!
channel
)
{
return
false
;
}
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
channel
-
>
GetLoadInfo
(
)
;
if
(
!
loadInfo
)
{
return
false
;
}
if
(
!
mHasCheckedForXMLHttpRequest
)
{
nsContentPolicyType
contentType
=
loadInfo
-
>
InternalContentPolicyType
(
)
;
mForXMLHttpRequest
=
(
contentType
=
=
nsIContentPolicy
:
:
TYPE_INTERNAL_XMLHTTPREQUEST
)
;
mHasCheckedForXMLHttpRequest
=
true
;
if
(
!
mForXMLHttpRequest
)
{
return
false
;
}
}
nsCOMPtr
<
nsIDocument
>
document
;
loadInfo
-
>
GetLoadingDocument
(
getter_AddRefs
(
document
)
)
;
if
(
document
&
&
document
-
>
EventHandlingSuppressed
(
)
&
&
!
document
-
>
IsInSyncOperation
(
)
)
{
document
-
>
AddSuspendedChannelEventQueue
(
this
)
;
SuspendInternal
(
)
;
return
true
;
}
return
false
;
}
}
}
