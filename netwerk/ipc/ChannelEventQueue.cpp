#
include
"
nsISupports
.
h
"
#
include
"
mozilla
/
net
/
ChannelEventQueue
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
namespace
mozilla
{
namespace
net
{
ChannelEvent
*
ChannelEventQueue
:
:
TakeEvent
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
MOZ_ASSERT
(
mFlushing
)
;
if
(
mSuspended
|
|
mEventQueue
.
IsEmpty
(
)
)
{
return
nullptr
;
}
UniquePtr
<
ChannelEvent
>
event
(
Move
(
mEventQueue
[
0
]
)
)
;
mEventQueue
.
RemoveElementAt
(
0
)
;
return
event
.
release
(
)
;
}
void
ChannelEventQueue
:
:
FlushQueue
(
)
{
nsCOMPtr
<
nsISupports
>
kungFuDeathGrip
(
mOwner
)
;
mozilla
:
:
Unused
<
<
kungFuDeathGrip
;
{
MutexAutoLock
lock
(
mMutex
)
;
mFlushing
=
true
;
}
while
(
true
)
{
UniquePtr
<
ChannelEvent
>
event
(
TakeEvent
(
)
)
;
if
(
!
event
)
{
break
;
}
event
-
>
Run
(
)
;
}
MutexAutoLock
lock
(
mMutex
)
;
mFlushing
=
false
;
}
void
ChannelEventQueue
:
:
Resume
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
MOZ_ASSERT
(
mSuspendCount
>
0
)
;
if
(
mSuspendCount
<
=
0
)
{
return
;
}
if
(
!
-
-
mSuspendCount
)
{
RefPtr
<
Runnable
>
event
=
NewRunnableMethod
(
this
&
ChannelEventQueue
:
:
CompleteResume
)
;
if
(
mTargetThread
)
{
mTargetThread
-
>
Dispatch
(
event
.
forget
(
)
NS_DISPATCH_NORMAL
)
;
}
else
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
NS_DispatchToCurrentThread
(
event
.
forget
(
)
)
)
)
;
}
}
}
nsresult
ChannelEventQueue
:
:
RetargetDeliveryTo
(
nsIEventTarget
*
aTargetThread
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
mTargetThread
)
;
MOZ_RELEASE_ASSERT
(
aTargetThread
)
;
mTargetThread
=
do_QueryInterface
(
aTargetThread
)
;
MOZ_RELEASE_ASSERT
(
mTargetThread
)
;
return
NS_OK
;
}
}
}
