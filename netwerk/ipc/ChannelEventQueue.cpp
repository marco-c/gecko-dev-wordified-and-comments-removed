#
include
"
ChannelEventQueue
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsThreadUtils
.
h
"
namespace
mozilla
{
namespace
net
{
ChannelEvent
*
ChannelEventQueue
:
:
TakeEvent
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
MOZ_ASSERT
(
mFlushing
)
;
if
(
mSuspended
|
|
mEventQueue
.
IsEmpty
(
)
)
{
return
nullptr
;
}
UniquePtr
<
ChannelEvent
>
event
(
Move
(
mEventQueue
[
0
]
)
)
;
mEventQueue
.
RemoveElementAt
(
0
)
;
return
event
.
release
(
)
;
}
void
ChannelEventQueue
:
:
FlushQueue
(
)
{
nsCOMPtr
<
nsISupports
>
kungFuDeathGrip
(
mOwner
)
;
mozilla
:
:
Unused
<
<
kungFuDeathGrip
;
bool
needResumeOnOtherThread
=
false
;
{
ReentrantMonitorAutoEnter
monitor
(
mRunningMonitor
)
;
{
MutexAutoLock
lock
(
mMutex
)
;
MOZ_ASSERT
(
!
mFlushing
)
;
mFlushing
=
true
;
}
while
(
true
)
{
UniquePtr
<
ChannelEvent
>
event
(
TakeEvent
(
)
)
;
if
(
!
event
)
{
break
;
}
nsCOMPtr
<
nsIEventTarget
>
target
=
event
-
>
GetEventTarget
(
)
;
MOZ_ASSERT
(
target
)
;
bool
isCurrentThread
=
false
;
nsresult
rv
=
target
-
>
IsOnCurrentThread
(
&
isCurrentThread
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
false
)
;
isCurrentThread
=
true
;
}
if
(
!
isCurrentThread
)
{
Suspend
(
)
;
PrependEvent
(
event
)
;
needResumeOnOtherThread
=
true
;
break
;
}
event
-
>
Run
(
)
;
}
{
MutexAutoLock
lock
(
mMutex
)
;
MOZ_ASSERT
(
mFlushing
)
;
mFlushing
=
false
;
MOZ_ASSERT
(
mEventQueue
.
IsEmpty
(
)
|
|
(
needResumeOnOtherThread
|
|
mSuspended
|
|
!
!
mForcedCount
)
)
;
}
}
if
(
needResumeOnOtherThread
)
{
Resume
(
)
;
}
}
void
ChannelEventQueue
:
:
Suspend
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
SuspendInternal
(
)
;
}
void
ChannelEventQueue
:
:
SuspendInternal
(
)
{
mMutex
.
AssertCurrentThreadOwns
(
)
;
mSuspended
=
true
;
mSuspendCount
+
+
;
}
void
ChannelEventQueue
:
:
Resume
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
ResumeInternal
(
)
;
}
void
ChannelEventQueue
:
:
ResumeInternal
(
)
{
mMutex
.
AssertCurrentThreadOwns
(
)
;
MOZ_ASSERT
(
mSuspendCount
>
0
)
;
if
(
mSuspendCount
<
=
0
)
{
return
;
}
if
(
!
-
-
mSuspendCount
)
{
if
(
mEventQueue
.
IsEmpty
(
)
)
{
mSuspended
=
false
;
return
;
}
RefPtr
<
Runnable
>
event
=
NewCancelableRunnableMethod
(
this
&
ChannelEventQueue
:
:
CompleteResume
)
;
nsCOMPtr
<
nsIEventTarget
>
target
;
target
=
mEventQueue
[
0
]
-
>
GetEventTarget
(
)
;
MOZ_ASSERT
(
target
)
;
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
target
-
>
Dispatch
(
event
.
forget
(
)
NS_DISPATCH_NORMAL
)
)
)
;
}
}
}
}
