#
include
"
DocumentChannelParent
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
LoadInfo
.
h
"
#
include
"
mozilla
/
MozPromiseInlines
.
h
"
#
include
"
mozilla
/
dom
/
BrowserParent
.
h
"
#
include
"
mozilla
/
dom
/
ClientChannelHelper
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
dom
/
ContentProcessManager
.
h
"
#
include
"
mozilla
/
dom
/
ipc
/
IdType
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorkerManager
.
h
"
#
include
"
mozilla
/
net
/
HttpChannelParent
.
h
"
#
include
"
mozilla
/
net
/
RedirectChannelRegistrar
.
h
"
#
include
"
nsDocShell
.
h
"
#
include
"
nsDocShellLoadState
.
h
"
#
include
"
nsHttpChannel
.
h
"
#
include
"
nsIHttpProtocolHandler
.
h
"
#
include
"
nsISecureBrowserUI
.
h
"
#
include
"
nsRedirectHistoryEntry
.
h
"
#
include
"
nsSerializationHelper
.
h
"
#
include
"
nsIPrompt
.
h
"
#
include
"
nsIWindowWatcher
.
h
"
using
namespace
mozilla
:
:
dom
;
namespace
mozilla
{
namespace
net
{
NS_IMPL_ADDREF
(
DocumentChannelParent
)
NS_IMPL_RELEASE
(
DocumentChannelParent
)
NS_INTERFACE_MAP_BEGIN
(
DocumentChannelParent
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsIInterfaceRequestor
)
NS_INTERFACE_MAP_ENTRY
(
nsIInterfaceRequestor
)
NS_INTERFACE_MAP_ENTRY
(
nsIRequestObserver
)
NS_INTERFACE_MAP_ENTRY
(
nsIStreamListener
)
NS_INTERFACE_MAP_ENTRY
(
nsIParentChannel
)
NS_INTERFACE_MAP_ENTRY
(
nsIAsyncVerifyRedirectReadyCallback
)
NS_INTERFACE_MAP_ENTRY
(
nsIChannelEventSink
)
NS_INTERFACE_MAP_ENTRY
(
nsIProcessSwitchRequestor
)
NS_INTERFACE_MAP_ENTRY_CONCRETE
(
DocumentChannelParent
)
NS_INTERFACE_MAP_END
DocumentChannelParent
:
:
DocumentChannelParent
(
const
PBrowserOrId
&
iframeEmbedding
nsILoadContext
*
aLoadContext
PBOverrideStatus
aOverrideStatus
)
:
mLoadContext
(
aLoadContext
)
mPBOverride
(
aOverrideStatus
)
{
RefPtr
<
dom
:
:
BrowserParent
>
parent
;
if
(
iframeEmbedding
.
type
(
)
=
=
PBrowserOrId
:
:
TPBrowserParent
)
{
parent
=
static_cast
<
dom
:
:
BrowserParent
*
>
(
iframeEmbedding
.
get_PBrowserParent
(
)
)
;
}
mListener
=
new
ParentChannelListener
(
this
parent
)
;
}
bool
DocumentChannelParent
:
:
Init
(
const
DocumentChannelCreationArgs
&
aArgs
)
{
RefPtr
<
nsDocShellLoadState
>
loadState
=
new
nsDocShellLoadState
(
aArgs
.
loadState
(
)
)
;
RefPtr
<
LoadInfo
>
loadInfo
;
nsresult
rv
=
mozilla
:
:
ipc
:
:
LoadInfoArgsToLoadInfo
(
Some
(
aArgs
.
loadInfo
(
)
)
getter_AddRefs
(
loadInfo
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
bool
result
=
nsDocShell
:
:
CreateChannelForLoadState
(
loadState
loadInfo
mListener
nullptr
aArgs
.
initiatorType
(
)
.
ptrOr
(
nullptr
)
aArgs
.
loadFlags
(
)
aArgs
.
loadType
(
)
aArgs
.
cacheKey
(
)
aArgs
.
isActive
(
)
aArgs
.
isTopLevelDoc
(
)
aArgs
.
hasNonEmptySandboxingFlags
(
)
rv
getter_AddRefs
(
mChannel
)
)
;
if
(
!
result
)
{
mListener
=
nullptr
;
return
SendFailedAsyncOpen
(
rv
)
;
}
nsDocShell
:
:
ConfigureChannel
(
mChannel
loadState
aArgs
.
initiatorType
(
)
.
ptrOr
(
nullptr
)
aArgs
.
loadType
(
)
aArgs
.
cacheKey
(
)
aArgs
.
hasNonEmptySandboxingFlags
(
)
)
;
RefPtr
<
HttpBaseChannel
>
httpBaseChannel
=
do_QueryObject
(
mChannel
&
rv
)
;
if
(
httpBaseChannel
)
{
nsCOMPtr
<
nsIURI
>
topWindowURI
=
DeserializeURI
(
aArgs
.
topWindowURI
(
)
)
;
rv
=
httpBaseChannel
-
>
SetTopWindowURI
(
topWindowURI
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
if
(
aArgs
.
contentBlockingAllowListPrincipal
(
)
)
{
nsCOMPtr
<
nsIPrincipal
>
contentBlockingAllowListPrincipal
=
PrincipalInfoToPrincipal
(
*
aArgs
.
contentBlockingAllowListPrincipal
(
)
)
;
httpBaseChannel
-
>
SetContentBlockingAllowListPrincipal
(
contentBlockingAllowListPrincipal
)
;
}
if
(
!
aArgs
.
customUserAgent
(
)
.
IsEmpty
(
)
)
{
NS_ConvertUTF16toUTF8
utf8CustomUserAgent
(
aArgs
.
customUserAgent
(
)
)
;
rv
=
httpBaseChannel
-
>
SetRequestHeader
(
NS_LITERAL_CSTRING
(
"
User
-
Agent
"
)
utf8CustomUserAgent
false
)
;
}
}
nsCOMPtr
<
nsIPrivateBrowsingChannel
>
privateChannel
=
do_QueryInterface
(
mChannel
)
;
if
(
mPBOverride
!
=
kPBOverride_Unset
)
{
privateChannel
-
>
SetPrivate
(
mPBOverride
=
=
kPBOverride_Private
)
;
}
nsCOMPtr
<
nsIIdentChannel
>
identChannel
=
do_QueryInterface
(
mChannel
)
;
if
(
identChannel
)
{
Unused
<
<
identChannel
-
>
SetChannelId
(
aArgs
.
channelId
(
)
)
;
}
RefPtr
<
nsHttpChannel
>
httpChannelImpl
=
do_QueryObject
(
mChannel
)
;
if
(
httpChannelImpl
)
{
httpChannelImpl
-
>
SetWarningReporter
(
this
)
;
}
nsCOMPtr
<
nsITimedChannel
>
timedChannel
=
do_QueryInterface
(
mChannel
)
;
if
(
timedChannel
)
{
timedChannel
-
>
SetAsyncOpen
(
aArgs
.
asyncOpenTime
(
)
)
;
}
AddClientChannelHelperInParent
(
mChannel
GetMainThreadSerialEventTarget
(
)
)
;
rv
=
mChannel
-
>
AsyncOpen
(
mListener
)
;
if
(
NS_FAILED
(
rv
)
)
{
mListener
=
nullptr
;
return
SendFailedAsyncOpen
(
rv
)
;
}
mChannelCreationURI
=
loadState
-
>
URI
(
)
;
return
true
;
}
void
DocumentChannelParent
:
:
ActorDestroy
(
ActorDestroyReason
why
)
{
RefPtr
<
nsHttpChannel
>
httpChannelImpl
=
do_QueryObject
(
mChannel
)
;
if
(
httpChannelImpl
)
{
httpChannelImpl
-
>
SetWarningReporter
(
nullptr
)
;
}
}
bool
DocumentChannelParent
:
:
RecvCancel
(
const
nsresult
&
aStatusCode
)
{
if
(
mChannel
&
&
!
mDoingProcessSwitch
)
{
mChannel
-
>
Cancel
(
aStatusCode
)
;
}
return
true
;
}
bool
DocumentChannelParent
:
:
RecvSuspend
(
)
{
if
(
mChannel
&
&
!
mDoingProcessSwitch
)
{
mChannel
-
>
Suspend
(
)
;
}
return
true
;
}
bool
DocumentChannelParent
:
:
RecvResume
(
)
{
if
(
mChannel
&
&
!
mDoingProcessSwitch
)
{
mChannel
-
>
Resume
(
)
;
}
return
true
;
}
void
DocumentChannelParent
:
:
RedirectToRealChannelFinished
(
nsresult
aRv
)
{
if
(
NS_FAILED
(
aRv
)
)
{
FinishReplacementChannelSetup
(
false
)
;
return
;
}
nsCOMPtr
<
nsIRedirectChannelRegistrar
>
redirectReg
=
RedirectChannelRegistrar
:
:
GetOrCreate
(
)
;
MOZ_ASSERT
(
redirectReg
)
;
nsCOMPtr
<
nsIParentChannel
>
redirectParentChannel
;
redirectReg
-
>
GetParentChannel
(
mRedirectChannelId
getter_AddRefs
(
redirectParentChannel
)
)
;
if
(
!
redirectParentChannel
)
{
FinishReplacementChannelSetup
(
false
)
;
return
;
}
nsCOMPtr
<
nsIParentRedirectingChannel
>
redirectingParent
=
do_QueryInterface
(
redirectParentChannel
)
;
if
(
!
redirectingParent
)
{
FinishReplacementChannelSetup
(
true
)
;
return
;
}
redirectingParent
-
>
ContinueVerification
(
this
)
;
return
;
}
NS_IMETHODIMP
DocumentChannelParent
:
:
ReadyToVerify
(
nsresult
aResultCode
)
{
FinishReplacementChannelSetup
(
NS_SUCCEEDED
(
aResultCode
)
)
;
return
NS_OK
;
}
void
DocumentChannelParent
:
:
FinishReplacementChannelSetup
(
bool
aSucceeded
)
{
nsresult
rv
;
if
(
mDoingProcessSwitch
&
&
CanSend
(
)
)
{
Unused
<
<
SendDisconnectChildListeners
(
NS_BINDING_ABORTED
)
;
}
nsCOMPtr
<
nsIParentChannel
>
redirectChannel
;
if
(
mRedirectChannelId
)
{
nsCOMPtr
<
nsIRedirectChannelRegistrar
>
registrar
=
RedirectChannelRegistrar
:
:
GetOrCreate
(
)
;
MOZ_ASSERT
(
registrar
)
;
rv
=
registrar
-
>
GetParentChannel
(
mRedirectChannelId
getter_AddRefs
(
redirectChannel
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
redirectChannel
)
{
nsCOMPtr
<
nsIChannel
>
newChannel
;
rv
=
registrar
-
>
GetRegisteredChannel
(
mRedirectChannelId
getter_AddRefs
(
newChannel
)
)
;
MOZ_ASSERT
(
newChannel
"
Already
registered
channel
not
found
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
newChannel
-
>
Cancel
(
NS_BINDING_ABORTED
)
;
}
}
registrar
-
>
DeregisterChannels
(
mRedirectChannelId
)
;
mRedirectChannelId
=
0
;
}
if
(
!
redirectChannel
)
{
aSucceeded
=
false
;
}
if
(
!
aSucceeded
)
{
if
(
redirectChannel
)
{
redirectChannel
-
>
Delete
(
)
;
}
if
(
mSuspendedChannel
)
{
mChannel
-
>
Resume
(
)
;
}
return
;
}
MOZ_ASSERT
(
!
SameCOMIdentity
(
redirectChannel
static_cast
<
nsIParentChannel
*
>
(
this
)
)
)
;
Delete
(
)
;
if
(
!
mStopRequestValue
)
{
mListener
-
>
SetListenerAfterRedirect
(
redirectChannel
)
;
}
redirectChannel
-
>
SetParentListener
(
mListener
)
;
for
(
auto
&
variant
:
mIParentChannelFunctions
)
{
variant
.
match
(
[
redirectChannel
]
(
const
nsIHttpChannel
:
:
FlashPluginState
&
aState
)
{
redirectChannel
-
>
NotifyFlashPluginStateChanged
(
aState
)
;
}
[
redirectChannel
]
(
const
ClassifierMatchedInfoParams
&
aParams
)
{
redirectChannel
-
>
SetClassifierMatchedInfo
(
aParams
.
mList
aParams
.
mProvider
aParams
.
mFullHash
)
;
}
[
redirectChannel
]
(
const
ClassifierMatchedTrackingInfoParams
&
aParams
)
{
redirectChannel
-
>
SetClassifierMatchedTrackingInfo
(
aParams
.
mLists
aParams
.
mFullHashes
)
;
}
[
redirectChannel
]
(
const
ClassificationFlagsParams
&
aParams
)
{
redirectChannel
-
>
NotifyClassificationFlags
(
aParams
.
mClassificationFlags
aParams
.
mIsThirdParty
)
;
}
)
;
}
RefPtr
<
HttpChannelParent
>
httpParent
=
do_QueryObject
(
redirectChannel
)
;
if
(
httpParent
)
{
RefPtr
<
HttpChannelSecurityWarningReporter
>
reporter
=
httpParent
;
for
(
auto
&
variant
:
mSecurityWarningFunctions
)
{
variant
.
match
(
[
reporter
]
(
const
ReportSecurityMessageParams
&
aParams
)
{
Unused
<
<
reporter
-
>
ReportSecurityMessage
(
aParams
.
mMessageTag
aParams
.
mMessageCategory
)
;
}
[
reporter
]
(
const
LogBlockedCORSRequestParams
&
aParams
)
{
Unused
<
<
reporter
-
>
LogBlockedCORSRequest
(
aParams
.
mMessage
aParams
.
mCategory
)
;
}
[
reporter
]
(
const
LogMimeTypeMismatchParams
&
aParams
)
{
Unused
<
<
reporter
-
>
LogMimeTypeMismatch
(
aParams
.
mMessageName
aParams
.
mWarning
aParams
.
mURL
aParams
.
mContentType
)
;
}
)
;
}
}
if
(
mSuspendedChannel
)
{
nsTArray
<
OnDataAvailableRequest
>
pendingRequests
=
std
:
:
move
(
mPendingRequests
)
;
MOZ_ASSERT
(
mPendingRequests
.
IsEmpty
(
)
)
;
nsCOMPtr
<
nsHttpChannel
>
httpChannel
=
do_QueryInterface
(
mChannel
)
;
if
(
httpChannel
)
{
httpChannel
-
>
SetApplyConversion
(
mOldApplyConversion
)
;
}
rv
=
redirectChannel
-
>
OnStartRequest
(
mChannel
)
;
if
(
NS_FAILED
(
rv
)
)
{
mChannel
-
>
Cancel
(
rv
)
;
}
if
(
NS_SUCCEEDED
(
rv
)
&
&
(
!
mStopRequestValue
|
|
NS_SUCCEEDED
(
*
mStopRequestValue
)
)
)
{
for
(
auto
&
request
:
pendingRequests
)
{
nsCOMPtr
<
nsIInputStream
>
stringStream
;
rv
=
NS_NewByteInputStream
(
getter_AddRefs
(
stringStream
)
Span
<
const
char
>
(
request
.
data
.
get
(
)
request
.
count
)
NS_ASSIGNMENT_DEPEND
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
redirectChannel
-
>
OnDataAvailable
(
mChannel
stringStream
request
.
offset
request
.
count
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
mChannel
-
>
Cancel
(
rv
)
;
mStopRequestValue
=
Some
(
rv
)
;
break
;
}
}
}
if
(
mStopRequestValue
)
{
redirectChannel
-
>
OnStopRequest
(
mChannel
*
mStopRequestValue
)
;
}
mChannel
-
>
Resume
(
)
;
}
}
void
DocumentChannelParent
:
:
TriggerCrossProcessSwitch
(
)
{
MOZ_ASSERT
(
mRedirectContentProcessIdPromise
)
;
MOZ_ASSERT
(
!
mDoingProcessSwitch
"
Already
in
the
middle
of
switching
?
"
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mDoingProcessSwitch
=
true
;
RefPtr
<
DocumentChannelParent
>
self
=
this
;
mRedirectContentProcessIdPromise
-
>
Then
(
GetMainThreadSerialEventTarget
(
)
__func__
[
self
this
]
(
uint64_t
aCpId
)
{
MOZ_ASSERT
(
mChannel
"
Something
went
wrong
channel
got
cancelled
"
)
;
TriggerRedirectToRealChannel
(
mChannel
Some
(
aCpId
)
mCrossProcessRedirectIdentifier
)
;
}
[
self
]
(
nsresult
aStatusCode
)
{
MOZ_ASSERT
(
NS_FAILED
(
aStatusCode
)
"
Status
should
be
error
"
)
;
self
-
>
RedirectToRealChannelFinished
(
aStatusCode
)
;
}
)
;
}
void
DocumentChannelParent
:
:
TriggerRedirectToRealChannel
(
nsIChannel
*
aChannel
const
Maybe
<
uint64_t
>
&
aDestinationProcess
uint64_t
aIdentifier
)
{
nsCOMPtr
<
nsIURI
>
uri
=
mChannelCreationURI
;
if
(
!
uri
)
{
aChannel
-
>
GetOriginalURI
(
getter_AddRefs
(
uri
)
)
;
}
nsCOMPtr
<
nsILoadInfo
>
channelLoadInfo
;
aChannel
-
>
GetLoadInfo
(
getter_AddRefs
(
channelLoadInfo
)
)
;
nsCOMPtr
<
nsIPrincipal
>
principalToInherit
;
channelLoadInfo
-
>
GetPrincipalToInherit
(
getter_AddRefs
(
principalToInherit
)
)
;
RefPtr
<
nsHttpChannel
>
baseChannel
=
do_QueryObject
(
aChannel
)
;
nsCOMPtr
<
nsILoadInfo
>
redirectLoadInfo
;
if
(
baseChannel
)
{
redirectLoadInfo
=
baseChannel
-
>
CloneLoadInfoForRedirect
(
uri
nsIChannelEventSink
:
:
REDIRECT_INTERNAL
)
;
redirectLoadInfo
-
>
SetResultPrincipalURI
(
uri
)
;
if
(
principalToInherit
)
{
redirectLoadInfo
-
>
SetPrincipalToInherit
(
principalToInherit
)
;
}
}
else
{
redirectLoadInfo
=
static_cast
<
mozilla
:
:
net
:
:
LoadInfo
*
>
(
channelLoadInfo
.
get
(
)
)
-
>
Clone
(
)
;
nsCOMPtr
<
nsIPrincipal
>
uriPrincipal
;
nsIScriptSecurityManager
*
sm
=
nsContentUtils
:
:
GetSecurityManager
(
)
;
sm
-
>
GetChannelURIPrincipal
(
aChannel
getter_AddRefs
(
uriPrincipal
)
)
;
nsCOMPtr
<
nsIRedirectHistoryEntry
>
entry
=
new
nsRedirectHistoryEntry
(
uriPrincipal
nullptr
EmptyCString
(
)
)
;
redirectLoadInfo
-
>
AppendRedirectHistoryEntry
(
entry
true
)
;
}
if
(
!
aDestinationProcess
)
{
const
Maybe
<
ClientInfo
>
&
reservedClientInfo
=
channelLoadInfo
-
>
GetReservedClientInfo
(
)
;
if
(
reservedClientInfo
)
{
redirectLoadInfo
-
>
SetReservedClientInfo
(
*
reservedClientInfo
)
;
}
}
nsCOMPtr
<
nsIRedirectChannelRegistrar
>
registrar
=
RedirectChannelRegistrar
:
:
GetOrCreate
(
)
;
MOZ_ASSERT
(
registrar
)
;
nsresult
rv
=
registrar
-
>
RegisterChannel
(
aChannel
&
mRedirectChannelId
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
Maybe
<
LoadInfoArgs
>
loadInfoArgs
;
MOZ_ALWAYS_SUCCEEDS
(
ipc
:
:
LoadInfoToLoadInfoArgs
(
redirectLoadInfo
&
loadInfoArgs
)
)
;
uint32_t
newLoadFlags
=
nsIRequest
:
:
LOAD_NORMAL
;
MOZ_ALWAYS_SUCCEEDS
(
aChannel
-
>
GetLoadFlags
(
&
newLoadFlags
)
)
;
if
(
!
aDestinationProcess
)
{
newLoadFlags
|
=
nsIChannel
:
:
LOAD_REPLACE
;
}
nsCOMPtr
<
nsIURI
>
originalURI
;
aChannel
-
>
GetOriginalURI
(
getter_AddRefs
(
originalURI
)
)
;
uint64_t
channelId
=
0
;
if
(
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
do_QueryInterface
(
aChannel
)
)
{
MOZ_ALWAYS_SUCCEEDS
(
httpChannel
-
>
GetChannelId
(
&
channelId
)
)
;
}
uint32_t
redirectMode
=
nsIHttpChannelInternal
:
:
REDIRECT_MODE_FOLLOW
;
nsCOMPtr
<
nsIHttpChannelInternal
>
httpChannelInternal
=
do_QueryInterface
(
aChannel
)
;
if
(
httpChannelInternal
)
{
MOZ_ALWAYS_SUCCEEDS
(
httpChannelInternal
-
>
GetRedirectMode
(
&
redirectMode
)
)
;
}
uint32_t
redirectFlags
=
0
;
if
(
mRedirects
.
IsEmpty
(
)
)
{
redirectFlags
=
nsIChannelEventSink
:
:
REDIRECT_INTERNAL
;
}
Maybe
<
ReplacementChannelConfigInit
>
config
;
if
(
baseChannel
)
{
uint32_t
loadFlags
=
0
;
if
(
!
aDestinationProcess
)
{
loadFlags
|
=
nsIChannel
:
:
LOAD_REPLACE
;
}
config
=
Some
(
baseChannel
-
>
CloneReplacementChannelConfig
(
true
redirectFlags
loadFlags
)
.
Serialize
(
)
)
;
}
Maybe
<
uint32_t
>
contentDisposition
;
uint32_t
contentDispositionTemp
;
rv
=
aChannel
-
>
GetContentDisposition
(
&
contentDispositionTemp
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
contentDisposition
=
Some
(
contentDispositionTemp
)
;
}
Maybe
<
nsString
>
contentDispositionFilename
;
nsString
contentDispositionFilenameTemp
;
rv
=
aChannel
-
>
GetContentDispositionFilename
(
contentDispositionFilenameTemp
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
contentDispositionFilename
=
Some
(
contentDispositionFilenameTemp
)
;
}
RefPtr
<
DocumentChannelParent
>
self
=
this
;
if
(
aDestinationProcess
)
{
dom
:
:
ContentParent
*
cp
=
dom
:
:
ContentProcessManager
:
:
GetSingleton
(
)
-
>
GetContentProcessById
(
ContentParentId
{
*
aDestinationProcess
}
)
;
if
(
!
cp
)
{
return
;
}
cp
-
>
SendCrossProcessRedirect
(
mRedirectChannelId
uri
config
loadInfoArgs
channelId
originalURI
aIdentifier
redirectMode
)
-
>
Then
(
GetCurrentThreadSerialEventTarget
(
)
__func__
[
self
]
(
Tuple
<
nsresult
Maybe
<
LoadInfoArgs
>
>
&
&
aResponse
)
{
if
(
NS_SUCCEEDED
(
Get
<
0
>
(
aResponse
)
)
)
{
nsCOMPtr
<
nsILoadInfo
>
newLoadInfo
;
MOZ_ALWAYS_SUCCEEDS
(
LoadInfoArgsToLoadInfo
(
Get
<
1
>
(
aResponse
)
getter_AddRefs
(
newLoadInfo
)
)
)
;
if
(
newLoadInfo
)
{
nsCOMPtr
<
nsILoadInfo
>
oldLoadInfo
;
self
-
>
mChannel
-
>
GetLoadInfo
(
getter_AddRefs
(
oldLoadInfo
)
)
;
MOZ_ASSERT
(
oldLoadInfo
)
;
Maybe
<
ClientInfo
>
oldClientInfo
=
oldLoadInfo
-
>
GetReservedClientInfo
(
)
;
Maybe
<
ServiceWorkerDescriptor
>
oldController
=
oldLoadInfo
-
>
GetController
(
)
;
Maybe
<
ClientInfo
>
newClientInfo
=
newLoadInfo
-
>
GetReservedClientInfo
(
)
;
Maybe
<
ServiceWorkerDescriptor
>
newController
=
newLoadInfo
-
>
GetController
(
)
;
if
(
oldClientInfo
.
isSome
(
)
&
&
newClientInfo
.
isSome
(
)
&
&
newController
.
isSome
(
)
&
&
oldController
.
isSome
(
)
&
&
newController
.
ref
(
)
=
=
oldController
.
ref
(
)
)
{
RefPtr
<
ServiceWorkerManager
>
swMgr
=
ServiceWorkerManager
:
:
GetInstance
(
)
;
MOZ_ASSERT
(
swMgr
)
;
swMgr
-
>
UpdateControlledClient
(
oldClientInfo
.
ref
(
)
newClientInfo
.
ref
(
)
newController
.
ref
(
)
)
;
}
self
-
>
mChannel
-
>
SetLoadInfo
(
newLoadInfo
)
;
}
}
self
-
>
RedirectToRealChannelFinished
(
Get
<
0
>
(
aResponse
)
)
;
}
[
self
]
(
const
mozilla
:
:
ipc
:
:
ResponseRejectReason
)
{
self
-
>
RedirectToRealChannelFinished
(
NS_ERROR_FAILURE
)
;
}
)
;
}
else
{
SendRedirectToRealChannel
(
mRedirectChannelId
uri
newLoadFlags
config
loadInfoArgs
mRedirects
channelId
originalURI
redirectMode
redirectFlags
contentDisposition
contentDispositionFilename
)
-
>
Then
(
GetCurrentThreadSerialEventTarget
(
)
__func__
[
self
]
(
nsresult
aRv
)
{
self
-
>
RedirectToRealChannelFinished
(
aRv
)
;
}
[
self
]
(
const
mozilla
:
:
ipc
:
:
ResponseRejectReason
)
{
self
-
>
RedirectToRealChannelFinished
(
NS_ERROR_FAILURE
)
;
}
)
;
}
}
NS_IMETHODIMP
DocumentChannelParent
:
:
OnStartRequest
(
nsIRequest
*
aRequest
)
{
nsCOMPtr
<
nsHttpChannel
>
channel
=
do_QueryInterface
(
aRequest
)
;
mChannel
=
do_QueryInterface
(
aRequest
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mChannel
)
;
if
(
!
CanSend
(
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
mDoingProcessSwitch
)
{
return
NS_OK
;
}
mChannel
-
>
Suspend
(
)
;
mSuspendedChannel
=
true
;
if
(
channel
)
{
Unused
<
<
channel
-
>
GetApplyConversion
(
&
mOldApplyConversion
)
;
channel
-
>
SetApplyConversion
(
false
)
;
gHttpHandler
-
>
OnMayChangeProcess
(
this
)
;
if
(
mRedirectContentProcessIdPromise
)
{
TriggerCrossProcessSwitch
(
)
;
return
NS_OK
;
}
}
TriggerRedirectToRealChannel
(
mChannel
)
;
return
NS_OK
;
}
NS_IMETHODIMP
DocumentChannelParent
:
:
OnStopRequest
(
nsIRequest
*
aRequest
nsresult
aStatusCode
)
{
mStopRequestValue
=
Some
(
aStatusCode
)
;
return
NS_OK
;
}
NS_IMETHODIMP
DocumentChannelParent
:
:
OnDataAvailable
(
nsIRequest
*
aRequest
nsIInputStream
*
aInputStream
uint64_t
aOffset
uint32_t
aCount
)
{
nsCString
data
;
nsresult
rv
=
NS_ReadInputStreamToString
(
aInputStream
data
aCount
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mPendingRequests
.
AppendElement
(
OnDataAvailableRequest
(
{
data
aOffset
aCount
}
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
DocumentChannelParent
:
:
SetParentListener
(
mozilla
:
:
net
:
:
ParentChannelListener
*
listener
)
{
return
NS_OK
;
}
NS_IMETHODIMP
DocumentChannelParent
:
:
GetInterface
(
const
nsIID
&
aIID
void
*
*
result
)
{
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsILoadContext
)
)
&
&
mLoadContext
)
{
nsCOMPtr
<
nsILoadContext
>
copy
=
mLoadContext
;
copy
.
forget
(
result
)
;
return
NS_OK
;
}
return
QueryInterface
(
aIID
result
)
;
}
NS_IMETHODIMP
DocumentChannelParent
:
:
NotifyChannelClassifierProtectionDisabled
(
uint32_t
aAcceptedReason
)
{
if
(
CanSend
(
)
)
{
Unused
<
<
SendNotifyChannelClassifierProtectionDisabled
(
aAcceptedReason
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
DocumentChannelParent
:
:
NotifyCookieAllowed
(
)
{
if
(
CanSend
(
)
)
{
Unused
<
<
SendNotifyCookieAllowed
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
DocumentChannelParent
:
:
NotifyCookieBlocked
(
uint32_t
aRejectedReason
)
{
if
(
CanSend
(
)
)
{
Unused
<
<
SendNotifyCookieBlocked
(
aRejectedReason
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
DocumentChannelParent
:
:
NotifyFlashPluginStateChanged
(
nsIHttpChannel
:
:
FlashPluginState
aState
)
{
mIParentChannelFunctions
.
AppendElement
(
IParentChannelFunction
{
VariantIndex
<
0
>
{
}
aState
}
)
;
return
NS_OK
;
}
NS_IMETHODIMP
DocumentChannelParent
:
:
SetClassifierMatchedInfo
(
const
nsACString
&
aList
const
nsACString
&
aProvider
const
nsACString
&
aFullHash
)
{
ClassifierMatchedInfoParams
params
;
params
.
mList
=
aList
;
params
.
mProvider
=
aProvider
;
params
.
mFullHash
=
aFullHash
;
if
(
CanSend
(
)
)
{
Unused
<
<
SendSetClassifierMatchedInfo
(
params
.
mList
params
.
mProvider
params
.
mFullHash
)
;
}
mIParentChannelFunctions
.
AppendElement
(
IParentChannelFunction
{
VariantIndex
<
1
>
{
}
std
:
:
move
(
params
)
}
)
;
return
NS_OK
;
}
NS_IMETHODIMP
DocumentChannelParent
:
:
SetClassifierMatchedTrackingInfo
(
const
nsACString
&
aLists
const
nsACString
&
aFullHash
)
{
ClassifierMatchedTrackingInfoParams
params
;
params
.
mLists
=
aLists
;
params
.
mFullHashes
=
aFullHash
;
if
(
CanSend
(
)
)
{
Unused
<
<
SendSetClassifierMatchedTrackingInfo
(
params
.
mLists
params
.
mFullHashes
)
;
}
mIParentChannelFunctions
.
AppendElement
(
IParentChannelFunction
{
VariantIndex
<
2
>
{
}
std
:
:
move
(
params
)
}
)
;
return
NS_OK
;
}
NS_IMETHODIMP
DocumentChannelParent
:
:
NotifyClassificationFlags
(
uint32_t
aClassificationFlags
bool
aIsThirdParty
)
{
if
(
CanSend
(
)
)
{
Unused
<
<
SendNotifyClassificationFlags
(
aClassificationFlags
aIsThirdParty
)
;
}
mIParentChannelFunctions
.
AppendElement
(
IParentChannelFunction
{
VariantIndex
<
3
>
{
}
ClassificationFlagsParams
{
aClassificationFlags
aIsThirdParty
}
}
)
;
return
NS_OK
;
}
NS_IMETHODIMP
DocumentChannelParent
:
:
Delete
(
)
{
if
(
!
CanSend
(
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
Unused
<
<
SendDeleteSelf
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
DocumentChannelParent
:
:
AsyncOnChannelRedirect
(
nsIChannel
*
aOldChannel
nsIChannel
*
aNewChannel
uint32_t
aFlags
nsIAsyncVerifyRedirectCallback
*
aCallback
)
{
mChannel
=
aNewChannel
;
aNewChannel
-
>
GetOriginalURI
(
getter_AddRefs
(
mChannelCreationURI
)
)
;
nsCOMPtr
<
nsHttpChannel
>
httpChannel
=
do_QueryInterface
(
aOldChannel
)
;
if
(
httpChannel
)
{
bool
mismatch
=
false
;
MOZ_ALWAYS_SUCCEEDS
(
httpChannel
-
>
HasCrossOriginOpenerPolicyMismatch
(
&
mismatch
)
)
;
mHasCrossOriginOpenerPolicyMismatch
|
=
mismatch
;
}
if
(
aFlags
&
nsIChannelEventSink
:
:
REDIRECT_INTERNAL
)
{
aCallback
-
>
OnRedirectVerifyCallback
(
NS_OK
)
;
return
NS_OK
;
}
else
{
nsCOMPtr
<
nsIURI
>
oldURI
;
aOldChannel
-
>
GetURI
(
getter_AddRefs
(
oldURI
)
)
;
uint32_t
responseStatus
=
0
;
bool
isPost
=
false
;
if
(
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
do_QueryInterface
(
aOldChannel
)
)
{
Unused
<
<
httpChannel
-
>
GetResponseStatus
(
&
responseStatus
)
;
nsAutoCString
method
;
Unused
<
<
httpChannel
-
>
GetRequestMethod
(
method
)
;
isPost
=
method
.
EqualsLiteral
(
"
POST
"
)
;
}
mRedirects
.
AppendElement
(
DocumentChannelRedirect
{
oldURI
aFlags
responseStatus
isPost
}
)
;
}
if
(
!
CanSend
(
)
)
{
return
NS_BINDING_ABORTED
;
}
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
aOldChannel
-
>
LoadInfo
(
)
;
Maybe
<
LoadInfoArgs
>
loadInfoArgs
;
MOZ_ALWAYS_SUCCEEDS
(
ipc
:
:
LoadInfoToLoadInfoArgs
(
loadInfo
&
loadInfoArgs
)
)
;
MOZ_ASSERT
(
loadInfoArgs
.
isSome
(
)
)
;
nsCOMPtr
<
nsIURI
>
newUri
;
nsresult
rv
=
aNewChannel
-
>
GetURI
(
getter_AddRefs
(
newUri
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIAsyncVerifyRedirectCallback
>
callback
(
aCallback
)
;
nsCOMPtr
<
nsIChannel
>
oldChannel
(
aOldChannel
)
;
SendConfirmRedirect
(
*
loadInfoArgs
newUri
)
-
>
Then
(
GetCurrentThreadSerialEventTarget
(
)
__func__
[
callback
oldChannel
]
(
const
Tuple
<
nsresult
Maybe
<
nsresult
>
>
&
aResult
)
{
if
(
Get
<
1
>
(
aResult
)
)
{
oldChannel
-
>
Cancel
(
*
Get
<
1
>
(
aResult
)
)
;
}
callback
-
>
OnRedirectVerifyCallback
(
Get
<
0
>
(
aResult
)
)
;
}
[
callback
oldChannel
]
(
const
mozilla
:
:
ipc
:
:
ResponseRejectReason
)
{
oldChannel
-
>
Cancel
(
NS_ERROR_DOM_BAD_URI
)
;
callback
-
>
OnRedirectVerifyCallback
(
NS_BINDING_ABORTED
)
;
}
)
;
mIParentChannelFunctions
.
Clear
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
DocumentChannelParent
:
:
GetChannel
(
nsIChannel
*
*
aChannel
)
{
MOZ_ASSERT
(
mChannel
)
;
nsCOMPtr
<
nsIChannel
>
channel
(
mChannel
)
;
channel
.
forget
(
aChannel
)
;
return
NS_OK
;
}
NS_IMETHODIMP
DocumentChannelParent
:
:
SwitchProcessTo
(
dom
:
:
Promise
*
aContentProcessIdPromise
uint64_t
aIdentifier
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
NS_ENSURE_ARG
(
aContentProcessIdPromise
)
;
mRedirectContentProcessIdPromise
=
ContentProcessIdPromise
:
:
FromDomPromise
(
aContentProcessIdPromise
)
;
mCrossProcessRedirectIdentifier
=
aIdentifier
;
return
NS_OK
;
}
NS_IMETHODIMP
DocumentChannelParent
:
:
HasCrossOriginOpenerPolicyMismatch
(
bool
*
aMismatch
)
{
MOZ_ASSERT
(
aMismatch
)
;
if
(
!
aMismatch
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
mHasCrossOriginOpenerPolicyMismatch
)
{
*
aMismatch
=
true
;
return
NS_OK
;
}
nsCOMPtr
<
nsHttpChannel
>
channel
=
do_QueryInterface
(
mChannel
)
;
if
(
!
channel
)
{
*
aMismatch
=
false
;
return
NS_OK
;
}
return
channel
-
>
HasCrossOriginOpenerPolicyMismatch
(
aMismatch
)
;
}
NS_IMETHODIMP
DocumentChannelParent
:
:
GetCrossOriginOpenerPolicy
(
nsILoadInfo
:
:
CrossOriginOpenerPolicy
*
aPolicy
)
{
MOZ_ASSERT
(
aPolicy
)
;
if
(
!
aPolicy
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsCOMPtr
<
nsHttpChannel
>
channel
=
do_QueryInterface
(
mChannel
)
;
if
(
!
channel
)
{
*
aPolicy
=
nsILoadInfo
:
:
OPENER_POLICY_NULL
;
return
NS_OK
;
}
return
channel
-
>
GetCrossOriginOpenerPolicy
(
aPolicy
)
;
}
}
}
