#
include
"
DocumentChannelParent
.
h
"
#
include
"
mozilla
/
dom
/
BrowserParent
.
h
"
#
include
"
mozilla
/
dom
/
CanonicalBrowsingContext
.
h
"
#
include
"
mozilla
/
dom
/
ClientInfo
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
extern
mozilla
:
:
LazyLogModule
gDocumentChannelLog
;
#
define
LOG
(
fmt
)
MOZ_LOG
(
gDocumentChannelLog
mozilla
:
:
LogLevel
:
:
Verbose
fmt
)
using
namespace
mozilla
:
:
dom
;
namespace
mozilla
{
namespace
net
{
DocumentChannelParent
:
:
DocumentChannelParent
(
)
{
LOG
(
(
"
DocumentChannelParent
ctor
[
this
=
%
p
]
"
this
)
)
;
}
DocumentChannelParent
:
:
~
DocumentChannelParent
(
)
{
LOG
(
(
"
DocumentChannelParent
dtor
[
this
=
%
p
]
"
this
)
)
;
}
bool
DocumentChannelParent
:
:
Init
(
dom
:
:
CanonicalBrowsingContext
*
aContext
const
DocumentChannelCreationArgs
&
aArgs
)
{
RefPtr
<
nsDocShellLoadState
>
loadState
=
new
nsDocShellLoadState
(
aArgs
.
loadState
(
)
)
;
LOG
(
(
"
DocumentChannelParent
Init
[
this
=
%
p
uri
=
%
s
]
"
this
loadState
-
>
URI
(
)
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
)
;
RefPtr
<
DocumentLoadListener
:
:
OpenPromise
>
promise
;
if
(
loadState
-
>
GetLoadIdentifier
(
)
)
{
promise
=
DocumentLoadListener
:
:
ClaimParentLoad
(
getter_AddRefs
(
mDocumentLoadListener
)
loadState
-
>
GetLoadIdentifier
(
)
)
;
if
(
!
promise
)
{
return
false
;
}
}
else
{
mDocumentLoadListener
=
new
DocumentLoadListener
(
aContext
)
;
Maybe
<
ClientInfo
>
clientInfo
;
if
(
aArgs
.
initialClientInfo
(
)
.
isSome
(
)
)
{
clientInfo
.
emplace
(
ClientInfo
(
aArgs
.
initialClientInfo
(
)
.
ref
(
)
)
)
;
}
nsresult
rv
=
NS_ERROR_UNEXPECTED
;
promise
=
mDocumentLoadListener
-
>
Open
(
loadState
aArgs
.
cacheKey
(
)
Some
(
aArgs
.
channelId
(
)
)
aArgs
.
asyncOpenTime
(
)
aArgs
.
timing
(
)
.
refOr
(
nullptr
)
std
:
:
move
(
clientInfo
)
aArgs
.
outerWindowId
(
)
aArgs
.
hasValidTransientUserAction
(
)
Some
(
aArgs
.
uriModified
(
)
)
Some
(
aArgs
.
isXFOError
(
)
)
IProtocol
:
:
OtherPid
(
)
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_ASSERT
(
!
promise
)
;
return
SendFailedAsyncOpen
(
rv
)
;
}
}
RefPtr
<
DocumentChannelParent
>
self
=
this
;
promise
-
>
Then
(
GetCurrentThreadSerialEventTarget
(
)
__func__
[
self
]
(
DocumentLoadListener
:
:
OpenPromiseSucceededType
&
&
aResolveValue
)
{
auto
promise
=
self
-
>
RedirectToRealChannel
(
std
:
:
move
(
aResolveValue
.
mStreamFilterEndpoints
)
aResolveValue
.
mRedirectFlags
aResolveValue
.
mLoadFlags
)
;
promise
-
>
ChainTo
(
aResolveValue
.
mPromise
.
forget
(
)
__func__
)
;
self
-
>
mDocumentLoadListener
=
nullptr
;
}
[
self
]
(
DocumentLoadListener
:
:
OpenPromiseFailedType
&
&
aRejectValue
)
{
if
(
aRejectValue
.
mStatus
=
=
NS_ERROR_DOCSHELL_DYING
)
{
Unused
<
<
self
-
>
SendDeleteSelf
(
)
;
return
;
}
Unused
<
<
self
-
>
SendDisconnectChildListeners
(
aRejectValue
.
mStatus
aRejectValue
.
mLoadGroupStatus
)
;
self
-
>
mDocumentLoadListener
=
nullptr
;
}
)
;
return
true
;
}
RefPtr
<
PDocumentChannelParent
:
:
RedirectToRealChannelPromise
>
DocumentChannelParent
:
:
RedirectToRealChannel
(
nsTArray
<
ipc
:
:
Endpoint
<
extensions
:
:
PStreamFilterParent
>
>
&
&
aStreamFilterEndpoints
uint32_t
aRedirectFlags
uint32_t
aLoadFlags
)
{
if
(
!
CanSend
(
)
)
{
return
PDocumentChannelParent
:
:
RedirectToRealChannelPromise
:
:
CreateAndReject
(
ResponseRejectReason
:
:
ChannelClosed
__func__
)
;
}
RedirectToRealChannelArgs
args
;
mDocumentLoadListener
-
>
SerializeRedirectData
(
args
false
aRedirectFlags
aLoadFlags
static_cast
<
ContentParent
*
>
(
Manager
(
)
-
>
Manager
(
)
)
)
;
return
SendRedirectToRealChannel
(
args
std
:
:
move
(
aStreamFilterEndpoints
)
)
;
}
}
}
#
undef
LOG
