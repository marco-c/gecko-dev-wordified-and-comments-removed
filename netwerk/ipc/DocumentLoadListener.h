#
ifndef
mozilla_net_DocumentLoadListener_h
#
define
mozilla_net_DocumentLoadListener_h
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
"
mozilla
/
WeakPtr
.
h
"
#
include
"
mozilla
/
ipc
/
ProtocolUtils
.
h
"
#
include
"
mozilla
/
dom
/
SessionHistoryEntry
.
h
"
#
include
"
mozilla
/
net
/
NeckoCommon
.
h
"
#
include
"
mozilla
/
net
/
NeckoParent
.
h
"
#
include
"
mozilla
/
net
/
PDocumentChannelParent
.
h
"
#
include
"
mozilla
/
net
/
ParentChannelListener
.
h
"
#
include
"
nsDOMNavigationTiming
.
h
"
#
include
"
nsIBrowser
.
h
"
#
include
"
nsIInterfaceRequestor
.
h
"
#
include
"
nsIMultiPartChannel
.
h
"
#
include
"
nsIParentChannel
.
h
"
#
include
"
nsIParentRedirectingChannel
.
h
"
#
include
"
nsIProgressEventSink
.
h
"
#
include
"
nsIRedirectResultListener
.
h
"
#
define
DOCUMENT_LOAD_LISTENER_IID
\
{
\
0x3b393c56
0x9e01
0x11e9
{
\
0xa2
0xa3
0x2a
0x2a
0xe2
0xdb
0xcc
0xe4
\
}
\
}
namespace
mozilla
{
namespace
dom
{
class
CanonicalBrowsingContext
;
}
namespace
net
{
using
ChildEndpointPromise
=
MozPromise
<
ipc
:
:
Endpoint
<
extensions
:
:
PStreamFilterChild
>
bool
true
>
;
struct
StreamFilterRequest
{
StreamFilterRequest
(
)
=
default
;
StreamFilterRequest
(
StreamFilterRequest
&
&
)
=
default
;
~
StreamFilterRequest
(
)
{
if
(
mPromise
)
{
mPromise
-
>
Reject
(
false
__func__
)
;
}
}
RefPtr
<
ChildEndpointPromise
:
:
Private
>
mPromise
;
base
:
:
ProcessId
mChildProcessId
;
ipc
:
:
Endpoint
<
extensions
:
:
PStreamFilterChild
>
mChildEndpoint
;
}
;
}
}
MOZ_DECLARE_RELOCATE_USING_MOVE_CONSTRUCTOR
(
mozilla
:
:
net
:
:
StreamFilterRequest
)
namespace
mozilla
{
namespace
net
{
class
LoadInfo
;
class
DocumentLoadListener
:
public
nsIInterfaceRequestor
public
nsIAsyncVerifyRedirectReadyCallback
public
nsIParentChannel
public
nsIChannelEventSink
public
HttpChannelSecurityWarningReporter
public
nsIMultiPartChannelListener
public
nsIProgressEventSink
{
public
:
DocumentLoadListener
(
dom
:
:
CanonicalBrowsingContext
*
aLoadingBrowsingContext
bool
aIsDocumentLoad
)
;
struct
OpenPromiseSucceededType
{
nsTArray
<
ipc
:
:
Endpoint
<
extensions
:
:
PStreamFilterParent
>
>
mStreamFilterEndpoints
;
uint32_t
mRedirectFlags
;
uint32_t
mLoadFlags
;
RefPtr
<
PDocumentChannelParent
:
:
RedirectToRealChannelPromise
:
:
Private
>
mPromise
;
}
;
struct
OpenPromiseFailedType
{
nsresult
mStatus
;
nsresult
mLoadGroupStatus
;
bool
mSwitchedProcess
=
false
;
}
;
typedef
MozPromise
<
OpenPromiseSucceededType
OpenPromiseFailedType
true
>
OpenPromise
;
struct
ObjectUpgradeHandler
:
public
SupportsWeakPtr
{
using
ObjectUpgradePromise
=
MozPromise
<
RefPtr
<
dom
:
:
CanonicalBrowsingContext
>
nsresult
true
>
;
virtual
RefPtr
<
ObjectUpgradePromise
>
UpgradeObjectLoad
(
)
=
0
;
}
;
private
:
RefPtr
<
OpenPromise
>
Open
(
nsDocShellLoadState
*
aLoadState
LoadInfo
*
aLoadInfo
nsLoadFlags
aLoadFlags
uint32_t
aCacheKey
const
Maybe
<
uint64_t
>
&
aChannelId
const
TimeStamp
&
aAsyncOpenTime
nsDOMNavigationTiming
*
aTiming
Maybe
<
dom
:
:
ClientInfo
>
&
&
aInfo
bool
aUrgentStart
base
:
:
ProcessId
aPid
nsresult
*
aRv
)
;
public
:
RefPtr
<
OpenPromise
>
OpenDocument
(
nsDocShellLoadState
*
aLoadState
uint32_t
aCacheKey
const
Maybe
<
uint64_t
>
&
aChannelId
const
TimeStamp
&
aAsyncOpenTime
nsDOMNavigationTiming
*
aTiming
Maybe
<
dom
:
:
ClientInfo
>
&
&
aInfo
Maybe
<
bool
>
aUriModified
Maybe
<
bool
>
aIsXFOError
base
:
:
ProcessId
aPid
nsresult
*
aRv
)
;
RefPtr
<
OpenPromise
>
OpenObject
(
nsDocShellLoadState
*
aLoadState
uint32_t
aCacheKey
const
Maybe
<
uint64_t
>
&
aChannelId
const
TimeStamp
&
aAsyncOpenTime
nsDOMNavigationTiming
*
aTiming
Maybe
<
dom
:
:
ClientInfo
>
&
&
aInfo
uint64_t
aInnerWindowId
nsLoadFlags
aLoadFlags
nsContentPolicyType
aContentPolicyType
bool
aUrgentStart
base
:
:
ProcessId
aPid
ObjectUpgradeHandler
*
aUpgradeHandler
nsresult
*
aRv
)
;
static
bool
LoadInParent
(
dom
:
:
CanonicalBrowsingContext
*
aBrowsingContext
nsDocShellLoadState
*
aLoadState
bool
aSetNavigating
)
;
static
bool
SpeculativeLoadInParent
(
dom
:
:
CanonicalBrowsingContext
*
aBrowsingContext
nsDocShellLoadState
*
aLoadState
)
;
static
void
CleanupParentLoadAttempt
(
uint64_t
aLoadIdent
)
;
static
RefPtr
<
OpenPromise
>
ClaimParentLoad
(
DocumentLoadListener
*
*
aListener
uint64_t
aLoadIdent
)
;
void
Abort
(
)
;
NS_DECL_ISUPPORTS
NS_DECL_NSIREQUESTOBSERVER
NS_DECL_NSISTREAMLISTENER
NS_DECL_NSIPARENTCHANNEL
NS_DECL_NSIINTERFACEREQUESTOR
NS_DECL_NSIASYNCVERIFYREDIRECTREADYCALLBACK
NS_DECL_NSICHANNELEVENTSINK
NS_DECL_NSIMULTIPARTCHANNELLISTENER
NS_DECL_NSIPROGRESSEVENTSINK
bool
ResumeSuspendedChannel
(
nsIStreamListener
*
aListener
)
;
NS_DECLARE_STATIC_IID_ACCESSOR
(
DOCUMENT_LOAD_LISTENER_IID
)
void
Cancel
(
const
nsresult
&
aStatusCode
)
;
nsIChannel
*
GetChannel
(
)
const
{
return
mChannel
;
}
uint32_t
GetRedirectChannelId
(
)
const
{
return
mRedirectChannelId
;
}
nsresult
ReportSecurityMessage
(
const
nsAString
&
aMessageTag
const
nsAString
&
aMessageCategory
)
override
{
ReportSecurityMessageParams
params
;
params
.
mMessageTag
=
aMessageTag
;
params
.
mMessageCategory
=
aMessageCategory
;
mSecurityWarningFunctions
.
AppendElement
(
SecurityWarningFunction
{
VariantIndex
<
0
>
{
}
std
:
:
move
(
params
)
}
)
;
return
NS_OK
;
}
nsresult
LogBlockedCORSRequest
(
const
nsAString
&
aMessage
const
nsACString
&
aCategory
)
override
{
LogBlockedCORSRequestParams
params
;
params
.
mMessage
=
aMessage
;
params
.
mCategory
=
aCategory
;
mSecurityWarningFunctions
.
AppendElement
(
SecurityWarningFunction
{
VariantIndex
<
1
>
{
}
std
:
:
move
(
params
)
}
)
;
return
NS_OK
;
}
nsresult
LogMimeTypeMismatch
(
const
nsACString
&
aMessageName
bool
aWarning
const
nsAString
&
aURL
const
nsAString
&
aContentType
)
override
{
LogMimeTypeMismatchParams
params
;
params
.
mMessageName
=
aMessageName
;
params
.
mWarning
=
aWarning
;
params
.
mURL
=
aURL
;
params
.
mContentType
=
aContentType
;
mSecurityWarningFunctions
.
AppendElement
(
SecurityWarningFunction
{
VariantIndex
<
2
>
{
}
std
:
:
move
(
params
)
}
)
;
return
NS_OK
;
}
base
:
:
ProcessId
OtherPid
(
)
const
{
return
mOtherPid
;
}
[
[
nodiscard
]
]
RefPtr
<
ChildEndpointPromise
>
AttachStreamFilter
(
base
:
:
ProcessId
aChildProcessId
)
;
void
SerializeRedirectData
(
RedirectToRealChannelArgs
&
aArgs
bool
aIsCrossProcess
uint32_t
aRedirectFlags
uint32_t
aLoadFlags
dom
:
:
ContentParent
*
aParent
)
const
;
uint64_t
GetLoadIdentifier
(
)
const
{
return
mLoadIdentifier
;
}
uint32_t
GetLoadType
(
)
const
{
return
mLoadStateLoadType
;
}
mozilla
:
:
dom
:
:
LoadingSessionHistoryInfo
*
GetLoadingSessionHistoryInfo
(
)
{
return
mLoadingSessionHistoryInfo
.
get
(
)
;
}
bool
IsDocumentLoad
(
)
const
{
return
mIsDocumentLoad
;
}
protected
:
virtual
~
DocumentLoadListener
(
)
;
private
:
RefPtr
<
OpenPromise
>
OpenInParent
(
nsDocShellLoadState
*
aLoadState
bool
aSupportsRedirectToRealChannel
)
;
friend
class
ParentProcessDocumentOpenInfo
;
void
DisconnectListeners
(
nsresult
aStatus
nsresult
aLoadGroupStatus
bool
aSwitchedProcess
=
false
)
;
void
NotifyDocumentChannelFailed
(
)
;
void
TriggerRedirectToRealChannel
(
const
Maybe
<
uint64_t
>
&
aDestinationProcess
)
;
void
RedirectToRealChannelFinished
(
nsresult
aRv
)
;
void
FinishReplacementChannelSetup
(
nsresult
aResult
)
;
bool
MaybeTriggerProcessSwitch
(
bool
*
aWillSwitchToRemote
)
;
void
TriggerProcessSwitch
(
dom
:
:
CanonicalBrowsingContext
*
aContext
const
nsCString
&
aRemoteType
bool
aReplaceBrowsingContext
uint64_t
aSpecificGroupId
)
;
using
ParentEndpoint
=
ipc
:
:
Endpoint
<
extensions
:
:
PStreamFilterParent
>
;
RefPtr
<
PDocumentChannelParent
:
:
RedirectToRealChannelPromise
>
RedirectToRealChannel
(
uint32_t
aRedirectFlags
uint32_t
aLoadFlags
const
Maybe
<
uint64_t
>
&
aDestinationProcess
nsTArray
<
ParentEndpoint
>
&
&
aStreamFilterEndpoints
)
;
RefPtr
<
PDocumentChannelParent
:
:
RedirectToRealChannelPromise
>
RedirectToParentProcess
(
uint32_t
aRedirectFlags
uint32_t
aLoadFlags
)
;
dom
:
:
CanonicalBrowsingContext
*
GetLoadingBrowsingContext
(
)
const
;
dom
:
:
CanonicalBrowsingContext
*
GetDocumentBrowsingContext
(
)
const
;
dom
:
:
CanonicalBrowsingContext
*
GetTopBrowsingContext
(
)
const
;
dom
:
:
WindowGlobalParent
*
GetParentWindowContext
(
)
const
;
void
AddURIVisit
(
nsIChannel
*
aChannel
uint32_t
aLoadFlags
)
;
bool
HasCrossOriginOpenerPolicyMismatch
(
)
const
;
void
ApplyPendingFunctions
(
nsIParentChannel
*
aChannel
)
const
;
void
Disconnect
(
)
;
void
MaybeReportBlockedByURLClassifier
(
nsresult
aStatus
)
;
bool
DocShellWillDisplayContent
(
nsresult
aStatus
)
;
void
FireStateChange
(
uint32_t
aStateFlags
nsresult
aStatus
)
;
bool
MaybeHandleLoadErrorWithURIFixup
(
nsresult
aStatus
)
;
struct
ClassifierMatchedInfoParams
{
nsCString
mList
;
nsCString
mProvider
;
nsCString
mFullHash
;
}
;
struct
ClassifierMatchedTrackingInfoParams
{
nsCString
mLists
;
nsCString
mFullHashes
;
}
;
struct
ClassificationFlagsParams
{
uint32_t
mClassificationFlags
;
bool
mIsThirdParty
;
}
;
typedef
mozilla
:
:
Variant
<
nsIHttpChannel
:
:
FlashPluginState
ClassifierMatchedInfoParams
ClassifierMatchedTrackingInfoParams
ClassificationFlagsParams
>
IParentChannelFunction
;
nsTArray
<
IParentChannelFunction
>
mIParentChannelFunctions
;
struct
ReportSecurityMessageParams
{
nsString
mMessageTag
;
nsString
mMessageCategory
;
}
;
struct
LogBlockedCORSRequestParams
{
nsString
mMessage
;
nsCString
mCategory
;
}
;
struct
LogMimeTypeMismatchParams
{
nsCString
mMessageName
;
bool
mWarning
;
nsString
mURL
;
nsString
mContentType
;
}
;
typedef
mozilla
:
:
Variant
<
ReportSecurityMessageParams
LogBlockedCORSRequestParams
LogMimeTypeMismatchParams
>
SecurityWarningFunction
;
nsTArray
<
SecurityWarningFunction
>
mSecurityWarningFunctions
;
struct
OnStartRequestParams
{
nsCOMPtr
<
nsIRequest
>
request
;
}
;
struct
OnDataAvailableParams
{
nsCOMPtr
<
nsIRequest
>
request
;
nsCString
data
;
uint64_t
offset
;
uint32_t
count
;
}
;
struct
OnStopRequestParams
{
nsCOMPtr
<
nsIRequest
>
request
;
nsresult
status
;
}
;
struct
OnAfterLastPartParams
{
nsresult
status
;
}
;
typedef
mozilla
:
:
Variant
<
OnStartRequestParams
OnDataAvailableParams
OnStopRequestParams
OnAfterLastPartParams
>
StreamListenerFunction
;
nsTArray
<
StreamListenerFunction
>
mStreamListenerFunctions
;
nsCOMPtr
<
nsIChannel
>
mChannel
;
RefPtr
<
ParentChannelListener
>
mParentChannelListener
;
nsCOMPtr
<
nsIURI
>
mChannelCreationURI
;
RefPtr
<
nsDOMNavigationTiming
>
mTiming
;
WeakPtr
<
ObjectUpgradeHandler
>
mObjectUpgradeHandler
;
bool
mHaveVisibleRedirect
=
false
;
nsTArray
<
StreamFilterRequest
>
mStreamFilterRequests
;
nsString
mSrcdocData
;
nsCOMPtr
<
nsIURI
>
mBaseURI
;
mozilla
:
:
UniquePtr
<
mozilla
:
:
dom
:
:
LoadingSessionHistoryInfo
>
mLoadingSessionHistoryInfo
;
RefPtr
<
dom
:
:
WindowGlobalParent
>
mParentWindowContext
;
uint32_t
mLoadStateLoadFlags
=
0
;
uint32_t
mLoadStateLoadType
=
0
;
uint64_t
mRedirectChannelId
=
0
;
bool
mInitiatedRedirectToRealChannel
=
false
;
bool
mDoingProcessSwitch
=
false
;
bool
mOldApplyConversion
=
false
;
bool
mHasCrossOriginOpenerPolicyMismatch
=
false
;
bool
mIsFinished
=
false
;
uint64_t
mLoadIdentifier
=
0
;
Maybe
<
nsCString
>
mOriginalUriString
;
bool
mSupportsRedirectToRealChannel
=
true
;
base
:
:
ProcessId
mOtherPid
=
0
;
void
RejectOpenPromise
(
nsresult
aStatus
nsresult
aLoadGroupStatus
bool
aSwitchedProcess
const
char
*
aLocation
)
{
if
(
!
mOpenPromiseResolved
&
&
mOpenPromise
)
{
mOpenPromise
-
>
Reject
(
OpenPromiseFailedType
(
{
aStatus
aLoadGroupStatus
aSwitchedProcess
}
)
aLocation
)
;
mOpenPromiseResolved
=
true
;
}
}
RefPtr
<
OpenPromise
:
:
Private
>
mOpenPromise
;
bool
mOpenPromiseResolved
=
false
;
const
bool
mIsDocumentLoad
;
}
;
NS_DEFINE_STATIC_IID_ACCESSOR
(
DocumentLoadListener
DOCUMENT_LOAD_LISTENER_IID
)
inline
nsISupports
*
ToSupports
(
DocumentLoadListener
*
aObj
)
{
return
static_cast
<
nsIInterfaceRequestor
*
>
(
aObj
)
;
}
}
}
#
endif
