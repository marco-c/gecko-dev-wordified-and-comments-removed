#
ifndef
mozilla_net_ChannelEventQueue_h
#
define
mozilla_net_ChannelEventQueue_h
#
include
"
nsTArray
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
class
nsISupports
;
class
nsIEventTarget
;
namespace
mozilla
{
namespace
net
{
class
ChannelEvent
{
public
:
ChannelEvent
(
)
{
MOZ_COUNT_CTOR
(
ChannelEvent
)
;
}
virtual
~
ChannelEvent
(
)
{
MOZ_COUNT_DTOR
(
ChannelEvent
)
;
}
virtual
void
Run
(
)
=
0
;
}
;
class
ChannelEventQueue
final
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
ChannelEventQueue
)
public
:
explicit
ChannelEventQueue
(
nsISupports
*
owner
)
:
mSuspendCount
(
0
)
mSuspended
(
false
)
mForced
(
false
)
mFlushing
(
false
)
mOwner
(
owner
)
mMutex
(
"
ChannelEventQueue
:
:
mMutex
"
)
{
}
inline
void
RunOrEnqueue
(
ChannelEvent
*
aCallback
bool
aAssertionWhenNotQueued
=
false
)
;
inline
nsresult
PrependEvents
(
nsTArray
<
UniquePtr
<
ChannelEvent
>
>
&
aEvents
)
;
inline
void
StartForcedQueueing
(
)
;
inline
void
EndForcedQueueing
(
)
;
inline
void
Suspend
(
)
;
void
Resume
(
)
;
nsresult
RetargetDeliveryTo
(
nsIEventTarget
*
aTargetThread
)
;
nsresult
ResetDeliveryTarget
(
)
;
private
:
~
ChannelEventQueue
(
)
{
}
inline
void
MaybeFlushQueue
(
)
;
void
FlushQueue
(
)
;
inline
void
CompleteResume
(
)
;
ChannelEvent
*
TakeEvent
(
)
;
nsTArray
<
UniquePtr
<
ChannelEvent
>
>
mEventQueue
;
uint32_t
mSuspendCount
;
bool
mSuspended
;
bool
mForced
;
bool
mFlushing
;
nsISupports
*
mOwner
;
Mutex
mMutex
;
nsCOMPtr
<
nsIEventTarget
>
mTargetThread
;
friend
class
AutoEventEnqueuer
;
}
;
inline
void
ChannelEventQueue
:
:
RunOrEnqueue
(
ChannelEvent
*
aCallback
bool
aAssertionWhenNotQueued
)
{
MOZ_ASSERT
(
aCallback
)
;
UniquePtr
<
ChannelEvent
>
event
(
aCallback
)
;
{
MutexAutoLock
lock
(
mMutex
)
;
bool
enqueue
=
mForced
|
|
mSuspended
|
|
mFlushing
;
MOZ_ASSERT
(
enqueue
=
=
true
|
|
mEventQueue
.
IsEmpty
(
)
"
Should
always
enqueue
if
ChannelEventQueue
not
empty
"
)
;
if
(
enqueue
)
{
mEventQueue
.
AppendElement
(
Move
(
event
)
)
;
return
;
}
}
MOZ_RELEASE_ASSERT
(
!
aAssertionWhenNotQueued
)
;
event
-
>
Run
(
)
;
}
inline
void
ChannelEventQueue
:
:
StartForcedQueueing
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
mForced
=
true
;
}
inline
void
ChannelEventQueue
:
:
EndForcedQueueing
(
)
{
{
MutexAutoLock
lock
(
mMutex
)
;
mForced
=
false
;
}
MaybeFlushQueue
(
)
;
}
inline
nsresult
ChannelEventQueue
:
:
PrependEvents
(
nsTArray
<
UniquePtr
<
ChannelEvent
>
>
&
aEvents
)
{
MutexAutoLock
lock
(
mMutex
)
;
UniquePtr
<
ChannelEvent
>
*
newEvents
=
mEventQueue
.
InsertElementsAt
(
0
aEvents
.
Length
(
)
)
;
if
(
!
newEvents
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
for
(
uint32_t
i
=
0
;
i
<
aEvents
.
Length
(
)
;
i
+
+
)
{
newEvents
[
i
]
=
Move
(
aEvents
[
i
]
)
;
}
return
NS_OK
;
}
inline
void
ChannelEventQueue
:
:
Suspend
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
mSuspended
=
true
;
mSuspendCount
+
+
;
}
inline
void
ChannelEventQueue
:
:
CompleteResume
(
)
{
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
!
mSuspendCount
)
{
mSuspended
=
false
;
}
}
MaybeFlushQueue
(
)
;
}
inline
void
ChannelEventQueue
:
:
MaybeFlushQueue
(
)
{
bool
flushQueue
=
false
;
{
MutexAutoLock
lock
(
mMutex
)
;
flushQueue
=
!
mForced
&
&
!
mFlushing
&
&
!
mSuspended
&
&
!
mEventQueue
.
IsEmpty
(
)
;
}
if
(
flushQueue
)
{
FlushQueue
(
)
;
}
}
class
MOZ_STACK_CLASS
AutoEventEnqueuer
{
public
:
explicit
AutoEventEnqueuer
(
ChannelEventQueue
*
queue
)
:
mEventQueue
(
queue
)
{
mEventQueue
-
>
StartForcedQueueing
(
)
;
}
~
AutoEventEnqueuer
(
)
{
mEventQueue
-
>
EndForcedQueueing
(
)
;
}
private
:
RefPtr
<
ChannelEventQueue
>
mEventQueue
;
}
;
}
}
#
endif
