#
ifndef
mozilla_net_ChannelEventQueue_h
#
define
mozilla_net_ChannelEventQueue_h
#
include
"
nsTArray
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsIEventTarget
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
ReentrantMonitor
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
class
nsISupports
;
namespace
mozilla
{
namespace
net
{
class
ChannelEvent
{
public
:
ChannelEvent
(
)
{
MOZ_COUNT_CTOR
(
ChannelEvent
)
;
}
virtual
~
ChannelEvent
(
)
{
MOZ_COUNT_DTOR
(
ChannelEvent
)
;
}
virtual
void
Run
(
)
=
0
;
virtual
already_AddRefed
<
nsIEventTarget
>
GetEventTarget
(
)
=
0
;
}
;
class
MainThreadChannelEvent
:
public
ChannelEvent
{
public
:
MainThreadChannelEvent
(
)
{
MOZ_COUNT_CTOR
(
MainThreadChannelEvent
)
;
}
virtual
~
MainThreadChannelEvent
(
)
{
MOZ_COUNT_DTOR
(
MainThreadChannelEvent
)
;
}
already_AddRefed
<
nsIEventTarget
>
GetEventTarget
(
)
override
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
return
do_AddRef
(
GetMainThreadEventTarget
(
)
)
;
}
}
;
template
<
typename
T
>
class
NeckoTargetChannelEvent
:
public
ChannelEvent
{
public
:
explicit
NeckoTargetChannelEvent
(
T
*
aChild
)
:
mChild
(
aChild
)
{
MOZ_COUNT_CTOR
(
NeckoTargetChannelEvent
)
;
}
virtual
~
NeckoTargetChannelEvent
(
)
{
MOZ_COUNT_DTOR
(
NeckoTargetChannelEvent
)
;
}
already_AddRefed
<
nsIEventTarget
>
GetEventTarget
(
)
override
{
MOZ_ASSERT
(
mChild
)
;
return
mChild
-
>
GetNeckoTarget
(
)
;
}
protected
:
T
*
mChild
;
}
;
class
ChannelEventQueue
final
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
ChannelEventQueue
)
public
:
explicit
ChannelEventQueue
(
nsISupports
*
owner
)
:
mSuspendCount
(
0
)
mSuspended
(
false
)
mForcedCount
(
0
)
mFlushing
(
false
)
mOwner
(
owner
)
mMutex
(
"
ChannelEventQueue
:
:
mMutex
"
)
mRunningMonitor
(
"
ChannelEventQueue
:
:
mRunningMonitor
"
)
{
}
inline
void
RunOrEnqueue
(
ChannelEvent
*
aCallback
bool
aAssertionWhenNotQueued
=
false
)
;
inline
nsresult
PrependEvent
(
UniquePtr
<
ChannelEvent
>
&
aEvent
)
;
inline
nsresult
PrependEvents
(
nsTArray
<
UniquePtr
<
ChannelEvent
>
>
&
aEvents
)
;
inline
void
StartForcedQueueing
(
)
;
inline
void
EndForcedQueueing
(
)
;
void
Suspend
(
)
;
void
Resume
(
)
;
private
:
~
ChannelEventQueue
(
)
{
}
void
SuspendInternal
(
)
;
void
ResumeInternal
(
)
;
inline
void
MaybeFlushQueue
(
)
;
void
FlushQueue
(
)
;
inline
void
CompleteResume
(
)
;
ChannelEvent
*
TakeEvent
(
)
;
nsTArray
<
UniquePtr
<
ChannelEvent
>
>
mEventQueue
;
uint32_t
mSuspendCount
;
bool
mSuspended
;
uint32_t
mForcedCount
;
bool
mFlushing
;
nsISupports
*
mOwner
;
Mutex
mMutex
;
ReentrantMonitor
mRunningMonitor
;
friend
class
AutoEventEnqueuer
;
}
;
inline
void
ChannelEventQueue
:
:
RunOrEnqueue
(
ChannelEvent
*
aCallback
bool
aAssertionWhenNotQueued
)
{
MOZ_ASSERT
(
aCallback
)
;
nsCOMPtr
<
nsISupports
>
kungFuDeathGrip
(
mOwner
)
;
Unused
<
<
kungFuDeathGrip
;
UniquePtr
<
ChannelEvent
>
event
(
aCallback
)
;
ReentrantMonitorAutoEnter
monitor
(
mRunningMonitor
)
;
{
MutexAutoLock
lock
(
mMutex
)
;
bool
enqueue
=
!
!
mForcedCount
|
|
mSuspended
|
|
mFlushing
|
|
!
mEventQueue
.
IsEmpty
(
)
;
if
(
enqueue
)
{
mEventQueue
.
AppendElement
(
Move
(
event
)
)
;
return
;
}
nsCOMPtr
<
nsIEventTarget
>
target
=
event
-
>
GetEventTarget
(
)
;
MOZ_ASSERT
(
target
)
;
bool
isCurrentThread
=
false
;
DebugOnly
<
nsresult
>
rv
=
target
-
>
IsOnCurrentThread
(
&
isCurrentThread
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
if
(
!
isCurrentThread
)
{
SuspendInternal
(
)
;
mEventQueue
.
AppendElement
(
Move
(
event
)
)
;
ResumeInternal
(
)
;
return
;
}
}
MOZ_RELEASE_ASSERT
(
!
aAssertionWhenNotQueued
)
;
event
-
>
Run
(
)
;
}
inline
void
ChannelEventQueue
:
:
StartForcedQueueing
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
+
+
mForcedCount
;
}
inline
void
ChannelEventQueue
:
:
EndForcedQueueing
(
)
{
bool
tryFlush
=
false
;
{
MutexAutoLock
lock
(
mMutex
)
;
MOZ_ASSERT
(
mForcedCount
>
0
)
;
if
(
!
-
-
mForcedCount
)
{
tryFlush
=
true
;
}
}
if
(
tryFlush
)
{
MaybeFlushQueue
(
)
;
}
}
inline
nsresult
ChannelEventQueue
:
:
PrependEvent
(
UniquePtr
<
ChannelEvent
>
&
aEvent
)
{
MutexAutoLock
lock
(
mMutex
)
;
MOZ_ASSERT
(
mSuspended
|
|
!
!
mForcedCount
)
;
UniquePtr
<
ChannelEvent
>
*
newEvent
=
mEventQueue
.
InsertElementAt
(
0
Move
(
aEvent
)
)
;
if
(
!
newEvent
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
return
NS_OK
;
}
inline
nsresult
ChannelEventQueue
:
:
PrependEvents
(
nsTArray
<
UniquePtr
<
ChannelEvent
>
>
&
aEvents
)
{
MutexAutoLock
lock
(
mMutex
)
;
MOZ_ASSERT
(
mSuspended
|
|
!
!
mForcedCount
)
;
UniquePtr
<
ChannelEvent
>
*
newEvents
=
mEventQueue
.
InsertElementsAt
(
0
aEvents
.
Length
(
)
)
;
if
(
!
newEvents
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
for
(
uint32_t
i
=
0
;
i
<
aEvents
.
Length
(
)
;
i
+
+
)
{
newEvents
[
i
]
=
Move
(
aEvents
[
i
]
)
;
}
return
NS_OK
;
}
inline
void
ChannelEventQueue
:
:
CompleteResume
(
)
{
bool
tryFlush
=
false
;
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
!
mSuspendCount
)
{
mSuspended
=
false
;
tryFlush
=
true
;
}
}
if
(
tryFlush
)
{
MaybeFlushQueue
(
)
;
}
}
inline
void
ChannelEventQueue
:
:
MaybeFlushQueue
(
)
{
bool
flushQueue
=
false
;
{
MutexAutoLock
lock
(
mMutex
)
;
flushQueue
=
!
mForcedCount
&
&
!
mFlushing
&
&
!
mSuspended
&
&
!
mEventQueue
.
IsEmpty
(
)
;
}
if
(
flushQueue
)
{
FlushQueue
(
)
;
}
}
class
MOZ_STACK_CLASS
AutoEventEnqueuer
{
public
:
explicit
AutoEventEnqueuer
(
ChannelEventQueue
*
queue
)
:
mEventQueue
(
queue
)
mOwner
(
queue
-
>
mOwner
)
{
mEventQueue
-
>
StartForcedQueueing
(
)
;
}
~
AutoEventEnqueuer
(
)
{
mEventQueue
-
>
EndForcedQueueing
(
)
;
}
private
:
RefPtr
<
ChannelEventQueue
>
mEventQueue
;
nsCOMPtr
<
nsISupports
>
mOwner
;
}
;
}
}
#
endif
