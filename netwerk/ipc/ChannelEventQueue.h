#
ifndef
mozilla_net_ChannelEventQueue_h
#
define
mozilla_net_ChannelEventQueue_h
#
include
"
nsTArray
.
h
"
#
include
"
nsIEventTarget
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
RecursiveMutex
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
class
nsISupports
;
namespace
mozilla
{
namespace
net
{
class
ChannelEvent
{
public
:
MOZ_COUNTED_DEFAULT_CTOR
(
ChannelEvent
)
MOZ_COUNTED_DTOR_VIRTUAL
(
ChannelEvent
)
virtual
void
Run
(
)
=
0
;
virtual
already_AddRefed
<
nsIEventTarget
>
GetEventTarget
(
)
=
0
;
}
;
class
MainThreadChannelEvent
:
public
ChannelEvent
{
public
:
MOZ_COUNTED_DEFAULT_CTOR
(
MainThreadChannelEvent
)
MOZ_COUNTED_DTOR_OVERRIDE
(
MainThreadChannelEvent
)
already_AddRefed
<
nsIEventTarget
>
GetEventTarget
(
)
override
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
return
do_AddRef
(
GetMainThreadEventTarget
(
)
)
;
}
}
;
class
ChannelFunctionEvent
:
public
ChannelEvent
{
public
:
ChannelFunctionEvent
(
std
:
:
function
<
already_AddRefed
<
nsIEventTarget
>
(
)
>
&
&
aGetEventTarget
std
:
:
function
<
void
(
)
>
&
&
aCallback
)
:
mGetEventTarget
(
std
:
:
move
(
aGetEventTarget
)
)
mCallback
(
std
:
:
move
(
aCallback
)
)
{
}
void
Run
(
)
override
{
mCallback
(
)
;
}
already_AddRefed
<
nsIEventTarget
>
GetEventTarget
(
)
override
{
return
mGetEventTarget
(
)
;
}
private
:
const
std
:
:
function
<
already_AddRefed
<
nsIEventTarget
>
(
)
>
mGetEventTarget
;
const
std
:
:
function
<
void
(
)
>
mCallback
;
}
;
template
<
typename
T
>
class
UnsafePtr
{
public
:
explicit
UnsafePtr
(
T
*
aPtr
)
:
mPtr
(
aPtr
)
{
}
T
&
operator
*
(
)
const
{
return
*
mPtr
;
}
T
*
operator
-
>
(
)
const
{
MOZ_ASSERT
(
mPtr
"
dereferencing
a
null
pointer
"
)
;
return
mPtr
;
}
operator
T
*
(
)
const
&
{
return
mPtr
;
}
explicit
operator
bool
(
)
const
{
return
mPtr
!
=
nullptr
;
}
private
:
T
*
const
mPtr
;
}
;
class
NeckoTargetChannelFunctionEvent
:
public
ChannelFunctionEvent
{
public
:
template
<
typename
T
>
NeckoTargetChannelFunctionEvent
(
T
*
aChild
std
:
:
function
<
void
(
)
>
&
&
aCallback
)
:
ChannelFunctionEvent
(
[
child
=
UnsafePtr
<
T
>
(
aChild
)
]
(
)
{
MOZ_ASSERT
(
child
)
;
return
child
-
>
GetNeckoTarget
(
)
;
}
std
:
:
move
(
aCallback
)
)
{
}
}
;
class
ChannelEventQueue
final
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
ChannelEventQueue
)
public
:
explicit
ChannelEventQueue
(
nsISupports
*
owner
)
:
mSuspendCount
(
0
)
mSuspended
(
false
)
mForcedCount
(
0
)
mFlushing
(
false
)
mHasCheckedForXMLHttpRequest
(
false
)
mForXMLHttpRequest
(
false
)
mOwner
(
owner
)
mMutex
(
"
ChannelEventQueue
:
:
mMutex
"
)
mRunningMutex
(
"
ChannelEventQueue
:
:
mRunningMutex
"
)
{
}
inline
void
RunOrEnqueue
(
ChannelEvent
*
aCallback
bool
aAssertionWhenNotQueued
=
false
)
;
inline
void
PrependEvent
(
UniquePtr
<
ChannelEvent
>
&
&
aEvent
)
;
inline
void
PrependEvents
(
nsTArray
<
UniquePtr
<
ChannelEvent
>
>
&
aEvents
)
;
inline
void
StartForcedQueueing
(
)
;
inline
void
EndForcedQueueing
(
)
;
void
Suspend
(
)
;
void
Resume
(
)
;
void
NotifyReleasingOwner
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
mOwner
=
nullptr
;
}
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
bool
IsEmpty
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
return
mEventQueue
.
IsEmpty
(
)
;
}
#
endif
private
:
~
ChannelEventQueue
(
)
=
default
;
void
SuspendInternal
(
)
;
void
ResumeInternal
(
)
;
bool
MaybeSuspendIfEventsAreSuppressed
(
)
REQUIRES
(
mMutex
)
;
inline
void
MaybeFlushQueue
(
)
;
void
FlushQueue
(
)
;
inline
void
CompleteResume
(
)
;
ChannelEvent
*
TakeEvent
(
)
;
nsTArray
<
UniquePtr
<
ChannelEvent
>
>
mEventQueue
GUARDED_BY
(
mMutex
)
;
uint32_t
mSuspendCount
GUARDED_BY
(
mMutex
)
;
bool
mSuspended
GUARDED_BY
(
mMutex
)
;
uint32_t
mForcedCount
GUARDED_BY
(
mMutex
)
;
bool
mFlushing
GUARDED_BY
(
mMutex
)
;
bool
mHasCheckedForXMLHttpRequest
;
bool
mForXMLHttpRequest
;
nsISupports
*
mOwner
GUARDED_BY
(
mMutex
)
;
Mutex
mMutex
;
RecursiveMutex
mRunningMutex
ACQUIRED_BEFORE
(
mMutex
)
;
friend
class
AutoEventEnqueuer
;
}
;
inline
void
ChannelEventQueue
:
:
RunOrEnqueue
(
ChannelEvent
*
aCallback
bool
aAssertionWhenNotQueued
)
{
MOZ_ASSERT
(
aCallback
)
;
nsCOMPtr
<
nsISupports
>
kungFuDeathGrip
;
UniquePtr
<
ChannelEvent
>
event
(
aCallback
)
;
RecursiveMutexAutoLock
lock
(
mRunningMutex
)
;
{
MutexAutoLock
lock
(
mMutex
)
;
kungFuDeathGrip
=
mOwner
;
bool
enqueue
=
!
!
mForcedCount
|
|
mSuspended
|
|
mFlushing
|
|
!
mEventQueue
.
IsEmpty
(
)
|
|
MaybeSuspendIfEventsAreSuppressed
(
)
;
if
(
enqueue
)
{
mEventQueue
.
AppendElement
(
std
:
:
move
(
event
)
)
;
return
;
}
nsCOMPtr
<
nsIEventTarget
>
target
=
event
-
>
GetEventTarget
(
)
;
MOZ_ASSERT
(
target
)
;
bool
isCurrentThread
=
false
;
DebugOnly
<
nsresult
>
rv
=
target
-
>
IsOnCurrentThread
(
&
isCurrentThread
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
if
(
!
isCurrentThread
)
{
SuspendInternal
(
)
;
mEventQueue
.
AppendElement
(
std
:
:
move
(
event
)
)
;
ResumeInternal
(
)
;
return
;
}
}
MOZ_RELEASE_ASSERT
(
!
aAssertionWhenNotQueued
)
;
event
-
>
Run
(
)
;
}
inline
void
ChannelEventQueue
:
:
StartForcedQueueing
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
+
+
mForcedCount
;
}
inline
void
ChannelEventQueue
:
:
EndForcedQueueing
(
)
{
bool
tryFlush
=
false
;
{
MutexAutoLock
lock
(
mMutex
)
;
MOZ_ASSERT
(
mForcedCount
>
0
)
;
if
(
!
-
-
mForcedCount
)
{
tryFlush
=
true
;
}
}
if
(
tryFlush
)
{
MaybeFlushQueue
(
)
;
}
}
inline
void
ChannelEventQueue
:
:
PrependEvent
(
UniquePtr
<
ChannelEvent
>
&
&
aEvent
)
{
MutexAutoLock
lock
(
mMutex
)
;
MOZ_ASSERT
(
mSuspended
|
|
!
!
mForcedCount
)
;
mEventQueue
.
InsertElementAt
(
0
std
:
:
move
(
aEvent
)
)
;
}
inline
void
ChannelEventQueue
:
:
PrependEvents
(
nsTArray
<
UniquePtr
<
ChannelEvent
>
>
&
aEvents
)
{
MutexAutoLock
lock
(
mMutex
)
;
MOZ_ASSERT
(
mSuspended
|
|
!
!
mForcedCount
)
;
mEventQueue
.
InsertElementsAt
(
0
aEvents
.
Length
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
aEvents
.
Length
(
)
;
i
+
+
)
{
mEventQueue
[
i
]
=
std
:
:
move
(
aEvents
[
i
]
)
;
}
}
inline
void
ChannelEventQueue
:
:
CompleteResume
(
)
{
bool
tryFlush
=
false
;
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
!
mSuspendCount
)
{
mSuspended
=
false
;
tryFlush
=
true
;
}
}
if
(
tryFlush
)
{
MaybeFlushQueue
(
)
;
}
}
inline
void
ChannelEventQueue
:
:
MaybeFlushQueue
(
)
{
bool
flushQueue
=
false
;
{
MutexAutoLock
lock
(
mMutex
)
;
flushQueue
=
!
mForcedCount
&
&
!
mFlushing
&
&
!
mSuspended
&
&
!
mEventQueue
.
IsEmpty
(
)
&
&
!
MaybeSuspendIfEventsAreSuppressed
(
)
;
if
(
flushQueue
)
{
mFlushing
=
true
;
}
}
if
(
flushQueue
)
{
FlushQueue
(
)
;
}
}
class
MOZ_STACK_CLASS
AutoEventEnqueuer
{
public
:
explicit
AutoEventEnqueuer
(
ChannelEventQueue
*
queue
)
:
mEventQueue
(
queue
)
{
{
MutexAutoLock
lock
(
queue
-
>
mMutex
)
;
mOwner
=
queue
-
>
mOwner
;
}
mEventQueue
-
>
StartForcedQueueing
(
)
;
}
~
AutoEventEnqueuer
(
)
{
mEventQueue
-
>
EndForcedQueueing
(
)
;
}
private
:
RefPtr
<
ChannelEventQueue
>
mEventQueue
;
nsCOMPtr
<
nsISupports
>
mOwner
;
}
;
}
}
#
endif
