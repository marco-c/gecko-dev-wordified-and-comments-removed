#
include
"
DocumentLoadListener
.
h
"
#
include
"
mozilla
/
AntiTrackingUtils
.
h
"
#
include
"
mozilla
/
ContentBlockingAllowList
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
LoadInfo
.
h
"
#
include
"
mozilla
/
MozPromiseInlines
.
h
"
#
include
"
mozilla
/
dom
/
CanonicalBrowsingContext
.
h
"
#
include
"
mozilla
/
dom
/
ClientChannelHelper
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
dom
/
ContentProcessManager
.
h
"
#
include
"
mozilla
/
dom
/
ipc
/
IdType
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorkerManager
.
h
"
#
include
"
mozilla
/
net
/
CookieJarSettings
.
h
"
#
include
"
mozilla
/
net
/
HttpChannelParent
.
h
"
#
include
"
mozilla
/
net
/
RedirectChannelRegistrar
.
h
"
#
include
"
nsDocShell
.
h
"
#
include
"
nsDocShellLoadState
.
h
"
#
include
"
nsContentSecurityUtils
.
h
"
#
include
"
nsHttpChannel
.
h
"
#
include
"
nsISecureBrowserUI
.
h
"
#
include
"
nsRedirectHistoryEntry
.
h
"
#
include
"
nsSerializationHelper
.
h
"
#
include
"
nsIPrompt
.
h
"
#
include
"
nsIWindowWatcher
.
h
"
#
include
"
nsIURIContentListener
.
h
"
#
include
"
nsWebNavigationInfo
.
h
"
#
include
"
nsURILoader
.
h
"
#
include
"
nsIStreamConverterService
.
h
"
#
include
"
nsExternalHelperAppService
.
h
"
#
include
"
nsCExternalHandlerService
.
h
"
#
include
"
nsMimeTypes
.
h
"
#
include
"
nsIViewSourceChannel
.
h
"
#
include
"
nsIOService
.
h
"
#
include
"
mozilla
/
dom
/
WindowGlobalParent
.
h
"
#
include
"
mozilla
/
StaticPrefs_security
.
h
"
#
include
"
nsICookieService
.
h
"
#
ifdef
ANDROID
#
include
"
mozilla
/
widget
/
nsWindow
.
h
"
#
endif
mozilla
:
:
LazyLogModule
gDocumentChannelLog
(
"
DocumentChannel
"
)
;
#
define
LOG
(
fmt
)
MOZ_LOG
(
gDocumentChannelLog
mozilla
:
:
LogLevel
:
:
Verbose
fmt
)
using
namespace
mozilla
:
:
dom
;
namespace
mozilla
{
namespace
net
{
class
ParentProcessDocumentOpenInfo
final
:
public
nsDocumentOpenInfo
public
nsIMultiPartChannelListener
{
public
:
ParentProcessDocumentOpenInfo
(
ParentChannelListener
*
aListener
uint32_t
aFlags
mozilla
:
:
dom
:
:
BrowsingContext
*
aBrowsingContext
)
:
nsDocumentOpenInfo
(
aFlags
false
)
mBrowsingContext
(
aBrowsingContext
)
mListener
(
aListener
)
{
LOG
(
(
"
ParentProcessDocumentOpenInfo
ctor
[
this
=
%
p
]
"
this
)
)
;
}
NS_DECL_ISUPPORTS_INHERITED
bool
TryDefaultContentListener
(
nsIChannel
*
aChannel
const
nsCString
&
aContentType
)
{
uint32_t
canHandle
=
nsWebNavigationInfo
:
:
IsTypeSupported
(
aContentType
mBrowsingContext
-
>
GetAllowPlugins
(
)
)
;
if
(
canHandle
!
=
nsIWebNavigationInfo
:
:
UNSUPPORTED
)
{
m_targetStreamListener
=
mListener
;
nsLoadFlags
loadFlags
=
0
;
aChannel
-
>
GetLoadFlags
(
&
loadFlags
)
;
aChannel
-
>
SetLoadFlags
(
loadFlags
|
nsIChannel
:
:
LOAD_TARGETED
)
;
return
true
;
}
return
false
;
}
bool
TryDefaultContentListener
(
nsIChannel
*
aChannel
)
override
{
return
TryDefaultContentListener
(
aChannel
mContentType
)
;
}
nsresult
TryStreamConversion
(
nsIChannel
*
aChannel
)
override
{
if
(
mContentType
.
LowerCaseEqualsASCII
(
UNKNOWN_CONTENT_TYPE
)
)
{
return
nsDocumentOpenInfo
:
:
TryStreamConversion
(
aChannel
)
;
}
nsresult
rv
;
nsCOMPtr
<
nsIStreamConverterService
>
streamConvService
=
do_GetService
(
NS_STREAMCONVERTERSERVICE_CONTRACTID
&
rv
)
;
nsAutoCString
str
;
rv
=
streamConvService
-
>
ConvertedType
(
mContentType
str
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
TryDefaultContentListener
(
aChannel
str
)
)
{
mContentType
=
str
;
return
NS_OK
;
}
return
NS_ERROR_FAILURE
;
}
nsresult
TryExternalHelperApp
(
nsIExternalHelperAppService
*
aHelperAppService
nsIChannel
*
aChannel
)
override
{
RefPtr
<
nsExternalAppHandler
>
handler
;
nsresult
rv
=
aHelperAppService
-
>
CreateListener
(
mContentType
aChannel
mBrowsingContext
false
nullptr
getter_AddRefs
(
handler
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
m_targetStreamListener
=
handler
;
}
return
rv
;
}
nsDocumentOpenInfo
*
Clone
(
)
override
{
mCloned
=
true
;
return
new
ParentProcessDocumentOpenInfo
(
mListener
mFlags
mBrowsingContext
)
;
}
NS_IMETHOD
OnStartRequest
(
nsIRequest
*
request
)
override
{
LOG
(
(
"
ParentProcessDocumentOpenInfo
OnStartRequest
[
this
=
%
p
]
"
this
)
)
;
nsresult
rv
=
nsDocumentOpenInfo
:
:
OnStartRequest
(
request
)
;
if
(
!
mUsedContentHandler
&
&
!
m_targetStreamListener
)
{
m_targetStreamListener
=
mListener
;
return
m_targetStreamListener
-
>
OnStartRequest
(
request
)
;
}
if
(
m_targetStreamListener
!
=
mListener
)
{
LOG
(
(
"
ParentProcessDocumentOpenInfo
targeted
to
non
-
default
listener
"
"
[
this
=
%
p
]
"
this
)
)
;
nsCOMPtr
<
nsIMultiPartChannel
>
multiPartChannel
=
do_QueryInterface
(
request
)
;
if
(
!
multiPartChannel
&
&
!
mCloned
)
{
DisconnectChildListeners
(
)
;
}
}
return
rv
;
}
NS_IMETHOD
OnAfterLastPart
(
nsresult
aStatus
)
override
{
mListener
-
>
OnAfterLastPart
(
aStatus
)
;
return
NS_OK
;
}
private
:
virtual
~
ParentProcessDocumentOpenInfo
(
)
{
LOG
(
(
"
ParentProcessDocumentOpenInfo
dtor
[
this
=
%
p
]
"
this
)
)
;
}
void
DisconnectChildListeners
(
)
{
RefPtr
<
DocumentLoadListener
>
doc
=
do_GetInterface
(
ToSupports
(
mListener
)
)
;
MOZ_ASSERT
(
doc
)
;
doc
-
>
DisconnectChildListeners
(
NS_BINDING_RETARGETED
NS_OK
)
;
mListener
-
>
SetListenerAfterRedirect
(
nullptr
)
;
}
RefPtr
<
mozilla
:
:
dom
:
:
BrowsingContext
>
mBrowsingContext
;
RefPtr
<
ParentChannelListener
>
mListener
;
bool
mCloned
=
false
;
}
;
NS_IMPL_ADDREF_INHERITED
(
ParentProcessDocumentOpenInfo
nsDocumentOpenInfo
)
NS_IMPL_RELEASE_INHERITED
(
ParentProcessDocumentOpenInfo
nsDocumentOpenInfo
)
NS_INTERFACE_MAP_BEGIN
(
ParentProcessDocumentOpenInfo
)
NS_INTERFACE_MAP_ENTRY
(
nsIMultiPartChannelListener
)
NS_INTERFACE_MAP_END_INHERITING
(
nsDocumentOpenInfo
)
NS_IMPL_ADDREF
(
DocumentLoadListener
)
NS_IMPL_RELEASE
(
DocumentLoadListener
)
NS_INTERFACE_MAP_BEGIN
(
DocumentLoadListener
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsIInterfaceRequestor
)
NS_INTERFACE_MAP_ENTRY
(
nsIInterfaceRequestor
)
NS_INTERFACE_MAP_ENTRY
(
nsIRequestObserver
)
NS_INTERFACE_MAP_ENTRY
(
nsIStreamListener
)
NS_INTERFACE_MAP_ENTRY
(
nsIParentChannel
)
NS_INTERFACE_MAP_ENTRY
(
nsIAsyncVerifyRedirectReadyCallback
)
NS_INTERFACE_MAP_ENTRY
(
nsIChannelEventSink
)
NS_INTERFACE_MAP_ENTRY
(
nsIProcessSwitchRequestor
)
NS_INTERFACE_MAP_ENTRY
(
nsIMultiPartChannelListener
)
NS_INTERFACE_MAP_ENTRY_CONCRETE
(
DocumentLoadListener
)
NS_INTERFACE_MAP_END
DocumentLoadListener
:
:
DocumentLoadListener
(
CanonicalBrowsingContext
*
aBrowsingContext
nsILoadContext
*
aLoadContext
ADocumentChannelBridge
*
aBridge
)
:
mLoadContext
(
aLoadContext
)
{
LOG
(
(
"
DocumentLoadListener
ctor
[
this
=
%
p
]
"
this
)
)
;
mParentChannelListener
=
new
ParentChannelListener
(
this
aBrowsingContext
aLoadContext
-
>
UsePrivateBrowsing
(
)
)
;
mDocumentChannelBridge
=
aBridge
;
}
DocumentLoadListener
:
:
~
DocumentLoadListener
(
)
{
LOG
(
(
"
DocumentLoadListener
dtor
[
this
=
%
p
]
"
this
)
)
;
}
already_AddRefed
<
LoadInfo
>
DocumentLoadListener
:
:
CreateLoadInfo
(
CanonicalBrowsingContext
*
aBrowsingContext
nsDocShellLoadState
*
aLoadState
uint64_t
aOuterWindowId
)
{
bool
inheritPrincipal
=
false
;
if
(
aLoadState
-
>
PrincipalToInherit
(
)
)
{
bool
isSrcdoc
=
aLoadState
-
>
HasLoadFlags
(
nsDocShell
:
:
INTERNAL_LOAD_FLAGS_IS_SRCDOC
)
;
bool
inheritAttrs
=
nsContentUtils
:
:
ChannelShouldInheritPrincipal
(
aLoadState
-
>
PrincipalToInherit
(
)
aLoadState
-
>
URI
(
)
true
isSrcdoc
)
;
bool
isURIUniqueOrigin
=
StaticPrefs
:
:
security_data_uri_unique_opaque_origin
(
)
&
&
SchemeIsData
(
aLoadState
-
>
URI
(
)
)
;
inheritPrincipal
=
inheritAttrs
&
&
!
isURIUniqueOrigin
;
}
nsSecurityFlags
securityFlags
=
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL
;
uint32_t
sandboxFlags
=
aBrowsingContext
-
>
GetSandboxFlags
(
)
;
if
(
aLoadState
-
>
LoadType
(
)
=
=
LOAD_ERROR_PAGE
)
{
securityFlags
|
=
nsILoadInfo
:
:
SEC_LOAD_ERROR_PAGE
;
}
if
(
inheritPrincipal
)
{
securityFlags
|
=
nsILoadInfo
:
:
SEC_FORCE_INHERIT_PRINCIPAL
;
}
RefPtr
<
LoadInfo
>
loadInfo
;
if
(
aBrowsingContext
-
>
GetParent
(
)
)
{
loadInfo
=
new
LoadInfo
(
aBrowsingContext
aLoadState
-
>
TriggeringPrincipal
(
)
aOuterWindowId
securityFlags
sandboxFlags
)
;
}
else
{
OriginAttributes
attrs
;
mLoadContext
-
>
GetOriginAttributes
(
attrs
)
;
loadInfo
=
new
LoadInfo
(
aBrowsingContext
aLoadState
-
>
TriggeringPrincipal
(
)
attrs
aOuterWindowId
securityFlags
sandboxFlags
)
;
}
loadInfo
-
>
SetHasValidUserGestureActivation
(
aLoadState
-
>
HasValidUserGestureActivation
(
)
)
;
return
loadInfo
.
forget
(
)
;
}
already_AddRefed
<
WindowGlobalParent
>
GetTopWindowExcludingExtensionAccessibleContentFrames
(
CanonicalBrowsingContext
*
aBrowsingContext
nsIURI
*
aURIBeingLoaded
)
{
CanonicalBrowsingContext
*
bc
=
aBrowsingContext
;
RefPtr
<
WindowGlobalParent
>
prev
;
while
(
RefPtr
<
WindowGlobalParent
>
parent
=
bc
-
>
GetParentWindowGlobal
(
)
)
{
CanonicalBrowsingContext
*
parentBC
=
parent
-
>
BrowsingContext
(
)
;
nsIPrincipal
*
parentPrincipal
=
parent
-
>
DocumentPrincipal
(
)
;
nsIURI
*
uri
=
prev
?
prev
-
>
GetDocumentURI
(
)
:
aURIBeingLoaded
;
if
(
uri
&
&
BasePrincipal
:
:
Cast
(
parentPrincipal
)
-
>
AddonAllowsLoad
(
uri
true
)
)
{
break
;
}
bc
=
parentBC
;
prev
=
parent
;
}
if
(
!
prev
)
{
prev
=
bc
-
>
GetCurrentWindowGlobal
(
)
;
}
return
prev
.
forget
(
)
;
}
bool
DocumentLoadListener
:
:
Open
(
nsDocShellLoadState
*
aLoadState
nsLoadFlags
aLoadFlags
uint32_t
aCacheKey
const
uint64_t
&
aChannelId
const
TimeStamp
&
aAsyncOpenTime
nsDOMNavigationTiming
*
aTiming
Maybe
<
ClientInfo
>
&
&
aInfo
uint64_t
aOuterWindowId
bool
aHasGesture
nsresult
*
aRv
)
{
LOG
(
(
"
DocumentLoadListener
Open
[
this
=
%
p
uri
=
%
s
]
"
this
aLoadState
-
>
URI
(
)
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
)
;
RefPtr
<
CanonicalBrowsingContext
>
browsingContext
=
mParentChannelListener
-
>
GetBrowsingContext
(
)
;
OriginAttributes
attrs
;
mLoadContext
-
>
GetOriginAttributes
(
attrs
)
;
RefPtr
<
WindowGlobalParent
>
embedderWGP
=
browsingContext
-
>
GetParentWindowGlobal
(
)
;
if
(
browsingContext
-
>
GetParent
(
)
&
&
!
embedderWGP
)
{
NS_WARNING
(
"
We
don
'
t
have
an
embedder
WindowGlobalParent
probably
because
of
a
"
"
race
"
)
;
return
false
;
}
RefPtr
<
LoadInfo
>
loadInfo
=
CreateLoadInfo
(
browsingContext
aLoadState
aOuterWindowId
)
;
if
(
!
nsDocShell
:
:
CreateAndConfigureRealChannelForLoadState
(
browsingContext
aLoadState
loadInfo
mParentChannelListener
nullptr
attrs
aLoadFlags
aCacheKey
*
aRv
getter_AddRefs
(
mChannel
)
)
)
{
mParentChannelListener
=
nullptr
;
return
false
;
}
nsCOMPtr
<
nsIURI
>
uriBeingLoaded
=
AntiTrackingUtils
:
:
MaybeGetDocumentURIBeingLoaded
(
mChannel
)
;
RefPtr
<
HttpBaseChannel
>
httpBaseChannel
=
do_QueryObject
(
mChannel
aRv
)
;
if
(
httpBaseChannel
)
{
nsCOMPtr
<
nsIURI
>
topWindowURI
;
if
(
browsingContext
-
>
IsTop
(
)
)
{
topWindowURI
=
uriBeingLoaded
;
nsCOMPtr
<
nsICookieJarSettings
>
cookieJarSettings
;
Unused
<
<
loadInfo
-
>
GetCookieJarSettings
(
getter_AddRefs
(
cookieJarSettings
)
)
;
net
:
:
CookieJarSettings
:
:
Cast
(
cookieJarSettings
)
-
>
UpdateIsOnContentBlockingAllowList
(
mChannel
)
;
}
else
if
(
RefPtr
<
WindowGlobalParent
>
topWindow
=
GetTopWindowExcludingExtensionAccessibleContentFrames
(
browsingContext
uriBeingLoaded
)
)
{
nsCOMPtr
<
nsIPrincipal
>
topWindowPrincipal
=
topWindow
-
>
DocumentPrincipal
(
)
;
if
(
topWindowPrincipal
&
&
!
topWindowPrincipal
-
>
GetIsNullPrincipal
(
)
)
{
auto
*
basePrin
=
BasePrincipal
:
:
Cast
(
topWindowPrincipal
)
;
basePrin
-
>
GetURI
(
getter_AddRefs
(
topWindowURI
)
)
;
}
}
httpBaseChannel
-
>
SetTopWindowURI
(
topWindowURI
)
;
}
Unused
<
<
loadInfo
-
>
SetHasStoragePermission
(
AntiTrackingUtils
:
:
HasStoragePermissionInParent
(
mChannel
)
)
;
nsCOMPtr
<
nsIIdentChannel
>
identChannel
=
do_QueryInterface
(
mChannel
)
;
if
(
identChannel
)
{
Unused
<
<
identChannel
-
>
SetChannelId
(
aChannelId
)
;
}
RefPtr
<
nsHttpChannel
>
httpChannelImpl
=
do_QueryObject
(
mChannel
)
;
if
(
httpChannelImpl
)
{
httpChannelImpl
-
>
SetWarningReporter
(
this
)
;
}
nsCOMPtr
<
nsITimedChannel
>
timedChannel
=
do_QueryInterface
(
mChannel
)
;
if
(
timedChannel
)
{
timedChannel
-
>
SetAsyncOpen
(
aAsyncOpenTime
)
;
}
if
(
nsCOMPtr
<
nsIViewSourceChannel
>
viewSourceChannel
=
do_QueryInterface
(
mChannel
)
)
{
viewSourceChannel
-
>
SetReplaceRequest
(
false
)
;
}
AddClientChannelHelperInParent
(
mChannel
std
:
:
move
(
aInfo
)
)
;
MOZ_ASSERT
(
!
aLoadState
-
>
GetPendingRedirectedChannel
(
)
)
;
uint32_t
openFlags
=
nsDocShell
:
:
ComputeURILoaderFlags
(
browsingContext
aLoadState
-
>
LoadType
(
)
)
;
RefPtr
<
ParentProcessDocumentOpenInfo
>
openInfo
=
new
ParentProcessDocumentOpenInfo
(
mParentChannelListener
openFlags
browsingContext
)
;
openInfo
-
>
Prepare
(
)
;
#
ifdef
ANDROID
RefPtr
<
MozPromise
<
bool
bool
false
>
>
promise
;
if
(
aLoadState
-
>
LoadType
(
)
!
=
LOAD_ERROR_PAGE
&
&
!
(
aLoadState
-
>
HasLoadFlags
(
nsDocShell
:
:
INTERNAL_LOAD_FLAGS_BYPASS_LOAD_URI_DELEGATE
)
)
&
&
browsingContext
-
>
IsTopContent
(
)
&
&
!
(
aLoadState
-
>
LoadType
(
)
&
LOAD_HISTORY
)
)
{
nsCOMPtr
<
nsIWidget
>
widget
=
browsingContext
-
>
GetParentProcessWidgetContaining
(
)
;
RefPtr
<
nsWindow
>
window
=
nsWindow
:
:
From
(
widget
)
;
if
(
window
)
{
promise
=
window
-
>
OnLoadRequest
(
aLoadState
-
>
URI
(
)
nsIBrowserDOMWindow
:
:
OPEN_CURRENTWINDOW
aLoadState
-
>
LoadFlags
(
)
aLoadState
-
>
TriggeringPrincipal
(
)
aHasGesture
)
;
}
}
if
(
promise
)
{
RefPtr
<
DocumentLoadListener
>
self
=
this
;
promise
-
>
Then
(
GetCurrentThreadSerialEventTarget
(
)
__func__
[
=
]
(
const
MozPromise
<
bool
bool
false
>
:
:
ResolveOrRejectValue
&
aValue
)
{
if
(
aValue
.
IsResolve
(
)
)
{
bool
handled
=
aValue
.
ResolveValue
(
)
;
if
(
handled
)
{
self
-
>
DisconnectChildListeners
(
NS_ERROR_ABORT
NS_ERROR_ABORT
)
;
mParentChannelListener
=
nullptr
;
}
else
{
nsresult
rv
=
mChannel
-
>
AsyncOpen
(
openInfo
)
;
if
(
NS_FAILED
(
rv
)
)
{
self
-
>
DisconnectChildListeners
(
NS_ERROR_ABORT
NS_ERROR_ABORT
)
;
mParentChannelListener
=
nullptr
;
}
}
}
}
)
;
}
else
#
endif
{
*
aRv
=
mChannel
-
>
AsyncOpen
(
openInfo
)
;
if
(
NS_FAILED
(
*
aRv
)
)
{
mParentChannelListener
=
nullptr
;
return
false
;
}
}
mChannelCreationURI
=
aLoadState
-
>
URI
(
)
;
mLoadStateLoadFlags
=
aLoadState
-
>
LoadFlags
(
)
;
mLoadStateLoadType
=
aLoadState
-
>
LoadType
(
)
;
mTiming
=
aTiming
;
mSrcdocData
=
aLoadState
-
>
SrcdocData
(
)
;
mBaseURI
=
aLoadState
-
>
BaseURI
(
)
;
return
true
;
}
void
DocumentLoadListener
:
:
DocumentChannelBridgeDisconnected
(
)
{
LOG
(
(
"
DocumentLoadListener
DocumentChannelBridgeDisconnected
[
this
=
%
p
]
"
this
)
)
;
RefPtr
<
nsHttpChannel
>
httpChannelImpl
=
do_QueryObject
(
mChannel
)
;
if
(
httpChannelImpl
)
{
httpChannelImpl
-
>
SetWarningReporter
(
nullptr
)
;
}
mDocumentChannelBridge
=
nullptr
;
}
void
DocumentLoadListener
:
:
Cancel
(
const
nsresult
&
aStatusCode
)
{
LOG
(
(
"
DocumentLoadListener
Cancel
[
this
=
%
p
"
"
aStatusCode
=
%
"
PRIx32
"
]
"
this
static_cast
<
uint32_t
>
(
aStatusCode
)
)
)
;
if
(
mChannel
&
&
!
mDoingProcessSwitch
)
{
mChannel
-
>
Cancel
(
aStatusCode
)
;
}
}
void
DocumentLoadListener
:
:
DisconnectChildListeners
(
nsresult
aStatus
nsresult
aLoadGroupStatus
)
{
LOG
(
(
"
DocumentLoadListener
DisconnectChildListener
[
this
=
%
p
"
"
aStatus
=
%
"
PRIx32
"
aLoadGroupStatus
=
%
"
PRIx32
"
]
"
this
static_cast
<
uint32_t
>
(
aStatus
)
static_cast
<
uint32_t
>
(
aLoadGroupStatus
)
)
)
;
if
(
mDocumentChannelBridge
)
{
mDocumentChannelBridge
-
>
DisconnectChildListeners
(
aStatus
aLoadGroupStatus
)
;
}
DocumentChannelBridgeDisconnected
(
)
;
mStreamFilterRequests
.
Clear
(
)
;
}
void
DocumentLoadListener
:
:
RedirectToRealChannelFinished
(
nsresult
aRv
)
{
LOG
(
(
"
DocumentLoadListener
RedirectToRealChannelFinished
[
this
=
%
p
"
"
aRv
=
%
"
PRIx32
"
]
"
this
static_cast
<
uint32_t
>
(
aRv
)
)
)
;
if
(
NS_FAILED
(
aRv
)
)
{
FinishReplacementChannelSetup
(
false
)
;
return
;
}
nsCOMPtr
<
nsIRedirectChannelRegistrar
>
redirectReg
=
RedirectChannelRegistrar
:
:
GetOrCreate
(
)
;
MOZ_ASSERT
(
redirectReg
)
;
nsCOMPtr
<
nsIParentChannel
>
redirectParentChannel
;
redirectReg
-
>
GetParentChannel
(
mRedirectChannelId
getter_AddRefs
(
redirectParentChannel
)
)
;
if
(
!
redirectParentChannel
)
{
FinishReplacementChannelSetup
(
false
)
;
return
;
}
nsCOMPtr
<
nsIParentRedirectingChannel
>
redirectingParent
=
do_QueryInterface
(
redirectParentChannel
)
;
if
(
!
redirectingParent
)
{
FinishReplacementChannelSetup
(
true
)
;
return
;
}
redirectingParent
-
>
ContinueVerification
(
this
)
;
return
;
}
NS_IMETHODIMP
DocumentLoadListener
:
:
ReadyToVerify
(
nsresult
aResultCode
)
{
FinishReplacementChannelSetup
(
NS_SUCCEEDED
(
aResultCode
)
)
;
return
NS_OK
;
}
void
DocumentLoadListener
:
:
FinishReplacementChannelSetup
(
bool
aSucceeded
)
{
LOG
(
(
"
DocumentLoadListener
FinishReplacementChannelSetup
[
this
=
%
p
"
"
aSucceeded
=
%
d
]
"
this
aSucceeded
)
)
;
nsresult
rv
;
if
(
mDoingProcessSwitch
)
{
DisconnectChildListeners
(
NS_BINDING_ABORTED
NS_BINDING_ABORTED
)
;
}
nsCOMPtr
<
nsIParentChannel
>
redirectChannel
;
if
(
mRedirectChannelId
)
{
nsCOMPtr
<
nsIRedirectChannelRegistrar
>
registrar
=
RedirectChannelRegistrar
:
:
GetOrCreate
(
)
;
MOZ_ASSERT
(
registrar
)
;
rv
=
registrar
-
>
GetParentChannel
(
mRedirectChannelId
getter_AddRefs
(
redirectChannel
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
redirectChannel
)
{
nsCOMPtr
<
nsIChannel
>
newChannel
;
rv
=
registrar
-
>
GetRegisteredChannel
(
mRedirectChannelId
getter_AddRefs
(
newChannel
)
)
;
MOZ_ASSERT
(
newChannel
"
Already
registered
channel
not
found
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
newChannel
-
>
Cancel
(
NS_BINDING_ABORTED
)
;
}
}
registrar
-
>
DeregisterChannels
(
mRedirectChannelId
)
;
mRedirectChannelId
=
0
;
}
if
(
!
redirectChannel
)
{
aSucceeded
=
false
;
}
if
(
!
aSucceeded
)
{
if
(
redirectChannel
)
{
redirectChannel
-
>
Delete
(
)
;
}
mChannel
-
>
Resume
(
)
;
return
;
}
MOZ_ASSERT
(
!
SameCOMIdentity
(
redirectChannel
static_cast
<
nsIParentChannel
*
>
(
this
)
)
)
;
Delete
(
)
;
if
(
!
mIsFinished
)
{
mParentChannelListener
-
>
SetListenerAfterRedirect
(
redirectChannel
)
;
}
redirectChannel
-
>
SetParentListener
(
mParentChannelListener
)
;
for
(
auto
&
variant
:
mIParentChannelFunctions
)
{
variant
.
match
(
[
redirectChannel
]
(
const
nsIHttpChannel
:
:
FlashPluginState
&
aState
)
{
redirectChannel
-
>
NotifyFlashPluginStateChanged
(
aState
)
;
}
[
redirectChannel
]
(
const
ClassifierMatchedInfoParams
&
aParams
)
{
redirectChannel
-
>
SetClassifierMatchedInfo
(
aParams
.
mList
aParams
.
mProvider
aParams
.
mFullHash
)
;
}
[
redirectChannel
]
(
const
ClassifierMatchedTrackingInfoParams
&
aParams
)
{
redirectChannel
-
>
SetClassifierMatchedTrackingInfo
(
aParams
.
mLists
aParams
.
mFullHashes
)
;
}
[
redirectChannel
]
(
const
ClassificationFlagsParams
&
aParams
)
{
redirectChannel
-
>
NotifyClassificationFlags
(
aParams
.
mClassificationFlags
aParams
.
mIsThirdParty
)
;
}
)
;
}
RefPtr
<
HttpChannelParent
>
httpParent
=
do_QueryObject
(
redirectChannel
)
;
if
(
httpParent
)
{
RefPtr
<
HttpChannelSecurityWarningReporter
>
reporter
=
httpParent
;
for
(
auto
&
variant
:
mSecurityWarningFunctions
)
{
variant
.
match
(
[
reporter
]
(
const
ReportSecurityMessageParams
&
aParams
)
{
Unused
<
<
reporter
-
>
ReportSecurityMessage
(
aParams
.
mMessageTag
aParams
.
mMessageCategory
)
;
}
[
reporter
]
(
const
LogBlockedCORSRequestParams
&
aParams
)
{
Unused
<
<
reporter
-
>
LogBlockedCORSRequest
(
aParams
.
mMessage
aParams
.
mCategory
)
;
}
[
reporter
]
(
const
LogMimeTypeMismatchParams
&
aParams
)
{
Unused
<
<
reporter
-
>
LogMimeTypeMismatch
(
aParams
.
mMessageName
aParams
.
mWarning
aParams
.
mURL
aParams
.
mContentType
)
;
}
)
;
}
}
ResumeSuspendedChannel
(
redirectChannel
)
;
}
void
DocumentLoadListener
:
:
ResumeSuspendedChannel
(
nsIStreamListener
*
aListener
)
{
LOG
(
(
"
DocumentLoadListener
ResumeSuspendedChannel
[
this
=
%
p
]
"
this
)
)
;
RefPtr
<
nsHttpChannel
>
httpChannel
=
do_QueryObject
(
mChannel
)
;
if
(
httpChannel
)
{
httpChannel
-
>
SetApplyConversion
(
mOldApplyConversion
)
;
}
nsTArray
<
StreamListenerFunction
>
streamListenerFunctions
=
std
:
:
move
(
mStreamListenerFunctions
)
;
nsresult
rv
=
NS_OK
;
for
(
auto
&
variant
:
streamListenerFunctions
)
{
variant
.
match
(
[
&
]
(
const
OnStartRequestParams
&
aParams
)
{
rv
=
aListener
-
>
OnStartRequest
(
aParams
.
request
)
;
if
(
NS_FAILED
(
rv
)
)
{
aParams
.
request
-
>
Cancel
(
rv
)
;
}
}
[
&
]
(
const
OnDataAvailableParams
&
aParams
)
{
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
nsCOMPtr
<
nsIInputStream
>
stringStream
;
rv
=
NS_NewByteInputStream
(
getter_AddRefs
(
stringStream
)
Span
<
const
char
>
(
aParams
.
data
.
get
(
)
aParams
.
count
)
NS_ASSIGNMENT_DEPEND
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
aListener
-
>
OnDataAvailable
(
aParams
.
request
stringStream
aParams
.
offset
aParams
.
count
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
aParams
.
request
-
>
Cancel
(
rv
)
;
}
}
[
&
]
(
const
OnStopRequestParams
&
aParams
)
{
if
(
NS_SUCCEEDED
(
rv
)
)
{
aListener
-
>
OnStopRequest
(
aParams
.
request
aParams
.
status
)
;
}
else
{
aListener
-
>
OnStopRequest
(
aParams
.
request
rv
)
;
}
rv
=
NS_OK
;
}
[
&
]
(
const
OnAfterLastPartParams
&
aParams
)
{
nsCOMPtr
<
nsIMultiPartChannelListener
>
multiListener
=
do_QueryInterface
(
aListener
)
;
if
(
multiListener
)
{
if
(
NS_SUCCEEDED
(
rv
)
)
{
multiListener
-
>
OnAfterLastPart
(
aParams
.
status
)
;
}
else
{
multiListener
-
>
OnAfterLastPart
(
rv
)
;
}
}
}
)
;
}
NS_ASSERTION
(
mStreamListenerFunctions
.
IsEmpty
(
)
"
Should
not
have
added
new
stream
listener
function
!
"
)
;
mChannel
-
>
Resume
(
)
;
}
void
DocumentLoadListener
:
:
SerializeRedirectData
(
RedirectToRealChannelArgs
&
aArgs
bool
aIsCrossProcess
uint32_t
aRedirectFlags
uint32_t
aLoadFlags
)
{
aArgs
.
uri
(
)
=
mChannelCreationURI
;
if
(
!
aArgs
.
uri
(
)
)
{
mChannel
-
>
GetOriginalURI
(
getter_AddRefs
(
aArgs
.
uri
(
)
)
)
;
}
nsCOMPtr
<
nsILoadInfo
>
channelLoadInfo
;
mChannel
-
>
GetLoadInfo
(
getter_AddRefs
(
channelLoadInfo
)
)
;
nsCOMPtr
<
nsIPrincipal
>
principalToInherit
;
channelLoadInfo
-
>
GetPrincipalToInherit
(
getter_AddRefs
(
principalToInherit
)
)
;
RefPtr
<
nsHttpChannel
>
baseChannel
=
do_QueryObject
(
mChannel
)
;
nsCOMPtr
<
nsILoadInfo
>
redirectLoadInfo
;
if
(
baseChannel
)
{
redirectLoadInfo
=
baseChannel
-
>
CloneLoadInfoForRedirect
(
aArgs
.
uri
(
)
nsIChannelEventSink
:
:
REDIRECT_INTERNAL
)
;
redirectLoadInfo
-
>
SetResultPrincipalURI
(
aArgs
.
uri
(
)
)
;
if
(
principalToInherit
)
{
redirectLoadInfo
-
>
SetPrincipalToInherit
(
principalToInherit
)
;
}
}
else
{
redirectLoadInfo
=
static_cast
<
mozilla
:
:
net
:
:
LoadInfo
*
>
(
channelLoadInfo
.
get
(
)
)
-
>
Clone
(
)
;
nsCOMPtr
<
nsIPrincipal
>
uriPrincipal
;
nsIScriptSecurityManager
*
sm
=
nsContentUtils
:
:
GetSecurityManager
(
)
;
sm
-
>
GetChannelURIPrincipal
(
mChannel
getter_AddRefs
(
uriPrincipal
)
)
;
nsCOMPtr
<
nsIRedirectHistoryEntry
>
entry
=
new
nsRedirectHistoryEntry
(
uriPrincipal
nullptr
EmptyCString
(
)
)
;
redirectLoadInfo
-
>
AppendRedirectHistoryEntry
(
entry
true
)
;
}
const
Maybe
<
ClientInfo
>
&
reservedClientInfo
=
channelLoadInfo
-
>
GetReservedClientInfo
(
)
;
if
(
reservedClientInfo
)
{
redirectLoadInfo
-
>
SetReservedClientInfo
(
*
reservedClientInfo
)
;
}
nsCOMPtr
<
nsIRedirectChannelRegistrar
>
registrar
=
RedirectChannelRegistrar
:
:
GetOrCreate
(
)
;
MOZ_ASSERT
(
registrar
)
;
nsresult
rv
=
registrar
-
>
RegisterChannel
(
mChannel
&
mRedirectChannelId
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
aArgs
.
registrarId
(
)
=
mRedirectChannelId
;
MOZ_ALWAYS_SUCCEEDS
(
ipc
:
:
LoadInfoToLoadInfoArgs
(
redirectLoadInfo
&
aArgs
.
loadInfo
(
)
)
)
;
mChannel
-
>
GetOriginalURI
(
getter_AddRefs
(
aArgs
.
originalURI
(
)
)
)
;
if
(
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
do_QueryInterface
(
mChannel
)
)
{
MOZ_ALWAYS_SUCCEEDS
(
httpChannel
-
>
GetChannelId
(
&
aArgs
.
channelId
(
)
)
)
;
}
aArgs
.
redirectMode
(
)
=
nsIHttpChannelInternal
:
:
REDIRECT_MODE_FOLLOW
;
nsCOMPtr
<
nsIHttpChannelInternal
>
httpChannelInternal
=
do_QueryInterface
(
mChannel
)
;
if
(
httpChannelInternal
)
{
MOZ_ALWAYS_SUCCEEDS
(
httpChannelInternal
-
>
GetRedirectMode
(
&
aArgs
.
redirectMode
(
)
)
)
;
}
if
(
baseChannel
)
{
aArgs
.
init
(
)
=
Some
(
baseChannel
-
>
CloneReplacementChannelConfig
(
true
aRedirectFlags
HttpBaseChannel
:
:
ReplacementReason
:
:
DocumentChannel
)
.
Serialize
(
)
)
;
}
uint32_t
contentDispositionTemp
;
rv
=
mChannel
-
>
GetContentDisposition
(
&
contentDispositionTemp
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
aArgs
.
contentDisposition
(
)
=
Some
(
contentDispositionTemp
)
;
}
nsString
contentDispositionFilenameTemp
;
rv
=
mChannel
-
>
GetContentDispositionFilename
(
contentDispositionFilenameTemp
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
aArgs
.
contentDispositionFilename
(
)
=
Some
(
contentDispositionFilenameTemp
)
;
}
aArgs
.
newLoadFlags
(
)
=
aLoadFlags
;
aArgs
.
redirectFlags
(
)
=
aRedirectFlags
;
aArgs
.
redirects
(
)
=
mRedirects
;
aArgs
.
redirectIdentifier
(
)
=
mCrossProcessRedirectIdentifier
;
aArgs
.
properties
(
)
=
do_QueryObject
(
mChannel
)
;
nsCOMPtr
<
nsIURI
>
previousURI
;
uint32_t
previousFlags
=
0
;
nsDocShell
:
:
ExtractLastVisit
(
mChannel
getter_AddRefs
(
previousURI
)
&
previousFlags
)
;
aArgs
.
lastVisitInfo
(
)
=
LastVisitInfo
{
previousURI
previousFlags
}
;
aArgs
.
srcdocData
(
)
=
mSrcdocData
;
aArgs
.
baseUri
(
)
=
mBaseURI
;
aArgs
.
loadStateLoadFlags
(
)
=
mLoadStateLoadFlags
;
aArgs
.
loadStateLoadType
(
)
=
mLoadStateLoadType
;
}
void
DocumentLoadListener
:
:
TriggerCrossProcessSwitch
(
)
{
MOZ_ASSERT
(
mRedirectContentProcessIdPromise
)
;
MOZ_ASSERT
(
!
mDoingProcessSwitch
"
Already
in
the
middle
of
switching
?
"
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
LOG
(
(
"
DocumentLoadListener
TriggerCrossProcessSwitch
[
this
=
%
p
]
"
this
)
)
;
mDoingProcessSwitch
=
true
;
RefPtr
<
DocumentLoadListener
>
self
=
this
;
mRedirectContentProcessIdPromise
-
>
Then
(
GetMainThreadSerialEventTarget
(
)
__func__
[
self
this
]
(
uint64_t
aCpId
)
{
MOZ_ASSERT
(
mChannel
"
Something
went
wrong
channel
got
cancelled
"
)
;
TriggerRedirectToRealChannel
(
Some
(
aCpId
)
)
;
}
[
self
]
(
nsresult
aStatusCode
)
{
MOZ_ASSERT
(
NS_FAILED
(
aStatusCode
)
"
Status
should
be
error
"
)
;
self
-
>
RedirectToRealChannelFinished
(
aStatusCode
)
;
}
)
;
}
RefPtr
<
PDocumentChannelParent
:
:
RedirectToRealChannelPromise
>
DocumentLoadListener
:
:
RedirectToRealChannel
(
uint32_t
aRedirectFlags
uint32_t
aLoadFlags
const
Maybe
<
uint64_t
>
&
aDestinationProcess
nsTArray
<
ParentEndpoint
>
&
&
aStreamFilterEndpoints
)
{
LOG
(
(
"
DocumentLoadListener
RedirectToRealChannel
[
this
=
%
p
]
"
this
)
)
;
if
(
aDestinationProcess
)
{
dom
:
:
ContentParent
*
cp
=
dom
:
:
ContentProcessManager
:
:
GetSingleton
(
)
-
>
GetContentProcessById
(
ContentParentId
{
*
aDestinationProcess
}
)
;
if
(
!
cp
)
{
return
PDocumentChannelParent
:
:
RedirectToRealChannelPromise
:
:
CreateAndReject
(
ipc
:
:
ResponseRejectReason
:
:
SendError
__func__
)
;
}
RedirectToRealChannelArgs
args
;
SerializeRedirectData
(
args
!
!
aDestinationProcess
aRedirectFlags
aLoadFlags
)
;
if
(
mTiming
)
{
mTiming
-
>
Anonymize
(
args
.
uri
(
)
)
;
args
.
timing
(
)
=
Some
(
std
:
:
move
(
mTiming
)
)
;
}
return
cp
-
>
SendCrossProcessRedirect
(
args
std
:
:
move
(
aStreamFilterEndpoints
)
)
;
}
MOZ_ASSERT
(
mDocumentChannelBridge
)
;
return
mDocumentChannelBridge
-
>
RedirectToRealChannel
(
std
:
:
move
(
aStreamFilterEndpoints
)
aRedirectFlags
aLoadFlags
)
;
}
void
DocumentLoadListener
:
:
TriggerRedirectToRealChannel
(
const
Maybe
<
uint64_t
>
&
aDestinationProcess
)
{
nsTArray
<
ParentEndpoint
>
parentEndpoints
(
mStreamFilterRequests
.
Length
(
)
)
;
if
(
!
mStreamFilterRequests
.
IsEmpty
(
)
)
{
base
:
:
ProcessId
pid
=
OtherPid
(
)
;
if
(
aDestinationProcess
)
{
dom
:
:
ContentParent
*
cp
=
dom
:
:
ContentProcessManager
:
:
GetSingleton
(
)
-
>
GetContentProcessById
(
ContentParentId
(
*
aDestinationProcess
)
)
;
if
(
cp
)
{
pid
=
cp
-
>
OtherPid
(
)
;
}
}
for
(
StreamFilterRequest
&
request
:
mStreamFilterRequests
)
{
ParentEndpoint
parent
;
nsresult
rv
=
extensions
:
:
PStreamFilter
:
:
CreateEndpoints
(
pid
request
.
mChildProcessId
&
parent
&
request
.
mChildEndpoint
)
;
if
(
NS_FAILED
(
rv
)
)
{
request
.
mPromise
-
>
Reject
(
false
__func__
)
;
request
.
mPromise
=
nullptr
;
}
else
{
parentEndpoints
.
AppendElement
(
std
:
:
move
(
parent
)
)
;
}
}
}
uint32_t
redirectFlags
=
0
;
if
(
mRedirects
.
IsEmpty
(
)
)
{
redirectFlags
=
nsIChannelEventSink
:
:
REDIRECT_INTERNAL
;
}
uint32_t
newLoadFlags
=
nsIRequest
:
:
LOAD_NORMAL
;
MOZ_ALWAYS_SUCCEEDS
(
mChannel
-
>
GetLoadFlags
(
&
newLoadFlags
)
)
;
if
(
!
aDestinationProcess
)
{
newLoadFlags
|
=
nsIChannel
:
:
LOAD_REPLACE
;
}
RefPtr
<
DocumentLoadListener
>
self
=
this
;
RedirectToRealChannel
(
redirectFlags
newLoadFlags
aDestinationProcess
std
:
:
move
(
parentEndpoints
)
)
-
>
Then
(
GetCurrentThreadSerialEventTarget
(
)
__func__
[
self
requests
=
std
:
:
move
(
mStreamFilterRequests
)
]
(
const
nsresult
&
aResponse
)
mutable
{
for
(
StreamFilterRequest
&
request
:
requests
)
{
if
(
request
.
mPromise
)
{
request
.
mPromise
-
>
Resolve
(
std
:
:
move
(
request
.
mChildEndpoint
)
__func__
)
;
request
.
mPromise
=
nullptr
;
}
}
self
-
>
RedirectToRealChannelFinished
(
aResponse
)
;
}
[
self
]
(
const
mozilla
:
:
ipc
:
:
ResponseRejectReason
)
{
self
-
>
RedirectToRealChannelFinished
(
NS_ERROR_FAILURE
)
;
}
)
;
}
NS_IMETHODIMP
DocumentLoadListener
:
:
OnStartRequest
(
nsIRequest
*
aRequest
)
{
LOG
(
(
"
DocumentLoadListener
OnStartRequest
[
this
=
%
p
]
"
this
)
)
;
nsCOMPtr
<
nsIMultiPartChannel
>
multiPartChannel
=
do_QueryInterface
(
aRequest
)
;
if
(
multiPartChannel
)
{
multiPartChannel
-
>
GetBaseChannel
(
getter_AddRefs
(
mChannel
)
)
;
}
else
{
mChannel
=
do_QueryInterface
(
aRequest
)
;
}
MOZ_DIAGNOSTIC_ASSERT
(
mChannel
)
;
RefPtr
<
nsHttpChannel
>
httpChannel
=
do_QueryObject
(
mChannel
)
;
if
(
!
mDocumentChannelBridge
)
{
return
NS_ERROR_UNEXPECTED
;
}
nsContentSecurityUtils
:
:
PerformCSPFrameAncestorAndXFOCheck
(
mChannel
)
;
if
(
mDoingProcessSwitch
)
{
return
NS_OK
;
}
nsresult
status
=
NS_OK
;
aRequest
-
>
GetStatus
(
&
status
)
;
if
(
status
=
=
NS_ERROR_NO_CONTENT
)
{
mDocumentChannelBridge
-
>
DisconnectChildListeners
(
status
status
)
;
return
NS_OK
;
}
mStreamListenerFunctions
.
AppendElement
(
StreamListenerFunction
{
VariantIndex
<
0
>
{
}
OnStartRequestParams
{
aRequest
}
}
)
;
if
(
!
mInitiatedRedirectToRealChannel
)
{
mChannel
-
>
Suspend
(
)
;
}
else
{
return
NS_OK
;
}
mInitiatedRedirectToRealChannel
=
true
;
if
(
httpChannel
)
{
Unused
<
<
httpChannel
-
>
GetApplyConversion
(
&
mOldApplyConversion
)
;
httpChannel
-
>
SetApplyConversion
(
false
)
;
}
if
(
status
!
=
NS_BINDING_ABORTED
)
{
nsCOMPtr
<
nsIObserverService
>
obsService
=
services
:
:
GetObserverService
(
)
;
obsService
-
>
NotifyObservers
(
ToSupports
(
this
)
"
channel
-
on
-
may
-
change
-
process
"
nullptr
)
;
}
if
(
mRedirectContentProcessIdPromise
)
{
TriggerCrossProcessSwitch
(
)
;
return
NS_OK
;
}
TriggerRedirectToRealChannel
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
DocumentLoadListener
:
:
OnStopRequest
(
nsIRequest
*
aRequest
nsresult
aStatusCode
)
{
LOG
(
(
"
DocumentLoadListener
OnStopRequest
[
this
=
%
p
]
"
this
)
)
;
mStreamListenerFunctions
.
AppendElement
(
StreamListenerFunction
{
VariantIndex
<
2
>
{
}
OnStopRequestParams
{
aRequest
aStatusCode
}
}
)
;
nsCOMPtr
<
nsIMultiPartChannel
>
multiPartChannel
=
do_QueryInterface
(
aRequest
)
;
if
(
!
multiPartChannel
)
{
mIsFinished
=
true
;
}
mStreamFilterRequests
.
Clear
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
DocumentLoadListener
:
:
OnDataAvailable
(
nsIRequest
*
aRequest
nsIInputStream
*
aInputStream
uint64_t
aOffset
uint32_t
aCount
)
{
LOG
(
(
"
DocumentLoadListener
OnDataAvailable
[
this
=
%
p
]
"
this
)
)
;
nsCString
data
;
nsresult
rv
=
NS_ReadInputStreamToString
(
aInputStream
data
aCount
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mStreamListenerFunctions
.
AppendElement
(
StreamListenerFunction
{
VariantIndex
<
1
>
{
}
OnDataAvailableParams
{
aRequest
data
aOffset
aCount
}
}
)
;
return
NS_OK
;
}
NS_IMETHODIMP
DocumentLoadListener
:
:
OnAfterLastPart
(
nsresult
aStatus
)
{
LOG
(
(
"
DocumentLoadListener
OnAfterLastPart
[
this
=
%
p
]
"
this
)
)
;
if
(
!
mInitiatedRedirectToRealChannel
)
{
LOG
(
(
"
DocumentLoadListener
Disconnecting
child
"
)
)
;
DisconnectChildListeners
(
NS_BINDING_RETARGETED
NS_OK
)
;
return
NS_OK
;
}
mStreamListenerFunctions
.
AppendElement
(
StreamListenerFunction
{
VariantIndex
<
3
>
{
}
OnAfterLastPartParams
{
aStatus
}
}
)
;
mIsFinished
=
true
;
return
NS_OK
;
}
NS_IMETHODIMP
DocumentLoadListener
:
:
SetParentListener
(
mozilla
:
:
net
:
:
ParentChannelListener
*
listener
)
{
return
NS_OK
;
}
NS_IMETHODIMP
DocumentLoadListener
:
:
GetInterface
(
const
nsIID
&
aIID
void
*
*
result
)
{
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsILoadContext
)
)
&
&
mLoadContext
)
{
nsCOMPtr
<
nsILoadContext
>
copy
=
mLoadContext
;
copy
.
forget
(
result
)
;
return
NS_OK
;
}
return
QueryInterface
(
aIID
result
)
;
}
NS_IMETHODIMP
DocumentLoadListener
:
:
NotifyFlashPluginStateChanged
(
nsIHttpChannel
:
:
FlashPluginState
aState
)
{
mIParentChannelFunctions
.
AppendElement
(
IParentChannelFunction
{
VariantIndex
<
0
>
{
}
aState
}
)
;
return
NS_OK
;
}
NS_IMETHODIMP
DocumentLoadListener
:
:
SetClassifierMatchedInfo
(
const
nsACString
&
aList
const
nsACString
&
aProvider
const
nsACString
&
aFullHash
)
{
ClassifierMatchedInfoParams
params
;
params
.
mList
=
aList
;
params
.
mProvider
=
aProvider
;
params
.
mFullHash
=
aFullHash
;
mIParentChannelFunctions
.
AppendElement
(
IParentChannelFunction
{
VariantIndex
<
1
>
{
}
std
:
:
move
(
params
)
}
)
;
return
NS_OK
;
}
NS_IMETHODIMP
DocumentLoadListener
:
:
SetClassifierMatchedTrackingInfo
(
const
nsACString
&
aLists
const
nsACString
&
aFullHash
)
{
ClassifierMatchedTrackingInfoParams
params
;
params
.
mLists
=
aLists
;
params
.
mFullHashes
=
aFullHash
;
mIParentChannelFunctions
.
AppendElement
(
IParentChannelFunction
{
VariantIndex
<
2
>
{
}
std
:
:
move
(
params
)
}
)
;
return
NS_OK
;
}
NS_IMETHODIMP
DocumentLoadListener
:
:
NotifyClassificationFlags
(
uint32_t
aClassificationFlags
bool
aIsThirdParty
)
{
mIParentChannelFunctions
.
AppendElement
(
IParentChannelFunction
{
VariantIndex
<
3
>
{
}
ClassificationFlagsParams
{
aClassificationFlags
aIsThirdParty
}
}
)
;
return
NS_OK
;
}
NS_IMETHODIMP
DocumentLoadListener
:
:
Delete
(
)
{
if
(
mDocumentChannelBridge
)
{
mDocumentChannelBridge
-
>
Delete
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
DocumentLoadListener
:
:
AsyncOnChannelRedirect
(
nsIChannel
*
aOldChannel
nsIChannel
*
aNewChannel
uint32_t
aFlags
nsIAsyncVerifyRedirectCallback
*
aCallback
)
{
mChannel
=
aNewChannel
;
aNewChannel
-
>
GetOriginalURI
(
getter_AddRefs
(
mChannelCreationURI
)
)
;
RefPtr
<
nsHttpChannel
>
httpChannel
=
do_QueryObject
(
aOldChannel
)
;
if
(
httpChannel
)
{
bool
mismatch
=
false
;
MOZ_ALWAYS_SUCCEEDS
(
httpChannel
-
>
HasCrossOriginOpenerPolicyMismatch
(
&
mismatch
)
)
;
mHasCrossOriginOpenerPolicyMismatch
|
=
mismatch
;
}
if
(
aFlags
&
nsIChannelEventSink
:
:
REDIRECT_INTERNAL
)
{
aCallback
-
>
OnRedirectVerifyCallback
(
NS_OK
)
;
return
NS_OK
;
}
else
{
nsCOMPtr
<
nsIURI
>
oldURI
;
aOldChannel
-
>
GetURI
(
getter_AddRefs
(
oldURI
)
)
;
uint32_t
responseStatus
=
0
;
if
(
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
do_QueryInterface
(
aOldChannel
)
)
{
Unused
<
<
httpChannel
-
>
GetResponseStatus
(
&
responseStatus
)
;
}
mRedirects
.
AppendElement
(
DocumentChannelRedirect
{
oldURI
aFlags
responseStatus
net
:
:
ChannelIsPost
(
aOldChannel
)
}
)
;
}
if
(
!
mDocumentChannelBridge
)
{
return
NS_BINDING_ABORTED
;
}
mIParentChannelFunctions
.
Clear
(
)
;
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
aOldChannel
-
>
LoadInfo
(
)
;
nsCOMPtr
<
nsIURI
>
originalUri
;
nsresult
rv
=
aOldChannel
-
>
GetOriginalURI
(
getter_AddRefs
(
originalUri
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
aOldChannel
-
>
Cancel
(
NS_ERROR_DOM_BAD_URI
)
;
return
rv
;
}
nsCOMPtr
<
nsIURI
>
newUri
;
rv
=
aNewChannel
-
>
GetURI
(
getter_AddRefs
(
newUri
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
Maybe
<
nsresult
>
cancelCode
;
rv
=
CSPService
:
:
ConsultCSPForRedirect
(
originalUri
newUri
loadInfo
cancelCode
)
;
if
(
cancelCode
)
{
aOldChannel
-
>
Cancel
(
*
cancelCode
)
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
#
ifdef
ANDROID
nsCOMPtr
<
nsIURI
>
uriBeingLoaded
=
AntiTrackingUtils
:
:
MaybeGetDocumentURIBeingLoaded
(
mChannel
)
;
RefPtr
<
CanonicalBrowsingContext
>
bc
=
mParentChannelListener
-
>
GetBrowsingContext
(
)
;
RefPtr
<
MozPromise
<
bool
bool
false
>
>
promise
;
if
(
bc
-
>
IsTopContent
(
)
)
{
nsCOMPtr
<
nsIWidget
>
widget
=
bc
-
>
GetParentProcessWidgetContaining
(
)
;
RefPtr
<
nsWindow
>
window
=
nsWindow
:
:
From
(
widget
)
;
if
(
window
)
{
promise
=
window
-
>
OnLoadRequest
(
uriBeingLoaded
nsIBrowserDOMWindow
:
:
OPEN_CURRENTWINDOW
nsIWebNavigation
:
:
LOAD_FLAGS_IS_REDIRECT
nullptr
false
)
;
}
}
if
(
promise
)
{
RefPtr
<
nsIAsyncVerifyRedirectCallback
>
cb
=
aCallback
;
promise
-
>
Then
(
GetCurrentThreadSerialEventTarget
(
)
__func__
[
=
]
(
const
MozPromise
<
bool
bool
false
>
:
:
ResolveOrRejectValue
&
aValue
)
{
if
(
aValue
.
IsResolve
(
)
)
{
bool
handled
=
aValue
.
ResolveValue
(
)
;
if
(
handled
)
{
cb
-
>
OnRedirectVerifyCallback
(
NS_ERROR_ABORT
)
;
}
else
{
cb
-
>
OnRedirectVerifyCallback
(
NS_OK
)
;
}
}
}
)
;
}
else
#
endif
{
aCallback
-
>
OnRedirectVerifyCallback
(
NS_OK
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
DocumentLoadListener
:
:
GetChannel
(
nsIChannel
*
*
aChannel
)
{
MOZ_ASSERT
(
mChannel
)
;
nsCOMPtr
<
nsIChannel
>
channel
(
mChannel
)
;
channel
.
forget
(
aChannel
)
;
return
NS_OK
;
}
NS_IMETHODIMP
DocumentLoadListener
:
:
SwitchProcessTo
(
dom
:
:
Promise
*
aContentProcessIdPromise
uint64_t
aIdentifier
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
NS_ENSURE_ARG
(
aContentProcessIdPromise
)
;
mRedirectContentProcessIdPromise
=
ContentProcessIdPromise
:
:
FromDomPromise
(
aContentProcessIdPromise
)
;
mCrossProcessRedirectIdentifier
=
aIdentifier
;
return
NS_OK
;
}
NS_IMETHODIMP
DocumentLoadListener
:
:
HasCrossOriginOpenerPolicyMismatch
(
bool
*
aMismatch
)
{
MOZ_ASSERT
(
aMismatch
)
;
if
(
!
aMismatch
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
mHasCrossOriginOpenerPolicyMismatch
)
{
*
aMismatch
=
true
;
return
NS_OK
;
}
RefPtr
<
nsHttpChannel
>
httpChannel
=
do_QueryObject
(
mChannel
)
;
if
(
!
httpChannel
)
{
*
aMismatch
=
false
;
return
NS_OK
;
}
return
httpChannel
-
>
HasCrossOriginOpenerPolicyMismatch
(
aMismatch
)
;
}
NS_IMETHODIMP
DocumentLoadListener
:
:
GetCachedCrossOriginOpenerPolicy
(
nsILoadInfo
:
:
CrossOriginOpenerPolicy
*
aPolicy
)
{
MOZ_ASSERT
(
aPolicy
)
;
if
(
!
aPolicy
)
{
return
NS_ERROR_INVALID_ARG
;
}
RefPtr
<
nsHttpChannel
>
httpChannel
=
do_QueryObject
(
mChannel
)
;
if
(
!
httpChannel
)
{
*
aPolicy
=
nsILoadInfo
:
:
OPENER_POLICY_UNSAFE_NONE
;
return
NS_OK
;
}
return
httpChannel
-
>
GetCrossOriginOpenerPolicy
(
aPolicy
)
;
}
auto
DocumentLoadListener
:
:
AttachStreamFilter
(
base
:
:
ProcessId
aChildProcessId
)
-
>
RefPtr
<
ChildEndpointPromise
>
{
LOG
(
(
"
DocumentLoadListener
AttachStreamFilter
[
this
=
%
p
]
"
this
)
)
;
StreamFilterRequest
*
request
=
mStreamFilterRequests
.
AppendElement
(
)
;
request
-
>
mPromise
=
new
ChildEndpointPromise
:
:
Private
(
__func__
)
;
request
-
>
mChildProcessId
=
aChildProcessId
;
return
request
-
>
mPromise
;
}
}
}
#
undef
LOG
