#
include
"
DocumentChannelChild
.
h
"
#
include
"
SerializedLoadContext
.
h
"
#
include
"
mozIThirdPartyUtil
.
h
"
#
include
"
mozilla
/
LoadInfo
.
h
"
#
include
"
mozilla
/
dom
/
BrowserChild
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
ipc
/
IPCStreamUtils
.
h
"
#
include
"
mozilla
/
ipc
/
URIUtils
.
h
"
#
include
"
mozilla
/
net
/
HttpChannelChild
.
h
"
#
include
"
mozilla
/
net
/
NeckoChild
.
h
"
#
include
"
nsContentSecurityManager
.
h
"
#
include
"
nsDocShellLoadState
.
h
"
#
include
"
nsQueryObject
.
h
"
#
include
"
nsSerializationHelper
.
h
"
#
include
"
nsStringStream
.
h
"
#
include
"
mozilla
/
net
/
UrlClassifierCommon
.
h
"
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
ipc
;
namespace
mozilla
{
namespace
net
{
NS_INTERFACE_MAP_BEGIN
(
DocumentChannelChild
)
if
(
mWasOpened
&
&
aIID
=
=
NS_GET_IID
(
nsIHttpChannel
)
)
{
NS_WARNING
(
"
Trying
to
request
nsIHttpChannel
from
DocumentChannelChild
this
is
"
"
likely
broken
"
)
;
}
NS_INTERFACE_MAP_ENTRY
(
nsIClassifiedChannel
)
NS_INTERFACE_MAP_ENTRY_CONCRETE
(
DocumentChannelChild
)
NS_INTERFACE_MAP_END_INHERITING
(
nsBaseChannel
)
NS_IMPL_ADDREF_INHERITED
(
DocumentChannelChild
nsBaseChannel
)
NS_IMPL_RELEASE_INHERITED
(
DocumentChannelChild
nsBaseChannel
)
DocumentChannelChild
:
:
DocumentChannelChild
(
nsDocShellLoadState
*
aLoadState
net
:
:
LoadInfo
*
aLoadInfo
const
nsString
*
aInitiatorType
nsLoadFlags
aLoadFlags
uint32_t
aLoadType
uint32_t
aCacheKey
bool
aIsActive
bool
aIsTopLevelDoc
)
:
mLoadState
(
aLoadState
)
mInitiatorType
(
aInitiatorType
?
Some
(
*
aInitiatorType
)
:
Nothing
(
)
)
mLoadType
(
aLoadType
)
mCacheKey
(
aCacheKey
)
mIsActive
(
aIsActive
)
mIsTopLevelDoc
(
aIsTopLevelDoc
)
{
mEventQueue
=
new
ChannelEventQueue
(
static_cast
<
nsIChannel
*
>
(
this
)
)
;
SetURI
(
aLoadState
-
>
URI
(
)
)
;
SetLoadInfo
(
aLoadInfo
)
;
SetLoadFlags
(
aLoadFlags
)
;
}
NS_IMETHODIMP
DocumentChannelChild
:
:
AsyncOpen
(
nsIStreamListener
*
aListener
)
{
nsresult
rv
=
NS_OK
;
nsCOMPtr
<
nsIStreamListener
>
listener
=
aListener
;
rv
=
nsContentSecurityManager
:
:
doContentSecurityCheck
(
this
listener
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
gNeckoChild
NS_ERROR_FAILURE
)
;
NS_ENSURE_ARG_POINTER
(
listener
)
;
NS_ENSURE_TRUE
(
!
mIsPending
NS_ERROR_IN_PROGRESS
)
;
NS_ENSURE_TRUE
(
!
mWasOpened
NS_ERROR_ALREADY_OPENED
)
;
rv
=
NS_CheckPortSafety
(
nsBaseChannel
:
:
URI
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIURI
>
topWindowURI
;
nsCOMPtr
<
nsIURI
>
uriBeingLoaded
=
AntiTrackingCommon
:
:
MaybeGetDocumentURIBeingLoaded
(
this
)
;
nsCOMPtr
<
nsIPrincipal
>
contentBlockingAllowListPrincipal
;
nsCOMPtr
<
mozIThirdPartyUtil
>
util
=
services
:
:
GetThirdPartyUtil
(
)
;
if
(
util
)
{
nsCOMPtr
<
mozIDOMWindowProxy
>
win
;
rv
=
util
-
>
GetTopWindowForChannel
(
this
uriBeingLoaded
getter_AddRefs
(
win
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
util
-
>
GetURIFromWindow
(
win
getter_AddRefs
(
topWindowURI
)
)
;
Unused
<
<
util
-
>
GetContentBlockingAllowListPrincipalFromWindow
(
win
uriBeingLoaded
getter_AddRefs
(
contentBlockingAllowListPrincipal
)
)
;
}
}
if
(
mLoadGroup
)
{
mLoadGroup
-
>
AddRequest
(
this
nullptr
)
;
}
if
(
mCanceled
)
{
return
mStatus
;
}
gHttpHandler
-
>
OnOpeningDocumentRequest
(
this
)
;
DocumentChannelCreationArgs
args
;
SerializeURI
(
topWindowURI
args
.
topWindowURI
(
)
)
;
args
.
loadState
(
)
=
mLoadState
-
>
Serialize
(
)
;
Maybe
<
LoadInfoArgs
>
maybeArgs
;
rv
=
LoadInfoToLoadInfoArgs
(
mLoadInfo
&
maybeArgs
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
MOZ_DIAGNOSTIC_ASSERT
(
maybeArgs
)
;
if
(
contentBlockingAllowListPrincipal
)
{
PrincipalInfo
principalInfo
;
rv
=
PrincipalToPrincipalInfo
(
contentBlockingAllowListPrincipal
&
principalInfo
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
args
.
contentBlockingAllowListPrincipal
(
)
=
Some
(
principalInfo
)
;
}
args
.
loadInfo
(
)
=
*
maybeArgs
;
GetLoadFlags
(
&
args
.
loadFlags
(
)
)
;
args
.
initiatorType
(
)
=
mInitiatorType
;
args
.
loadType
(
)
=
mLoadType
;
args
.
cacheKey
(
)
=
mCacheKey
;
args
.
isActive
(
)
=
mIsActive
;
args
.
isTopLevelDoc
(
)
=
mIsTopLevelDoc
;
args
.
channelId
(
)
=
mChannelId
;
nsCOMPtr
<
nsILoadContext
>
loadContext
;
NS_QueryNotificationCallbacks
(
this
loadContext
)
;
if
(
loadContext
)
{
nsCOMPtr
<
mozIDOMWindowProxy
>
domWindow
;
loadContext
-
>
GetAssociatedWindow
(
getter_AddRefs
(
domWindow
)
)
;
if
(
domWindow
)
{
auto
*
pDomWindow
=
nsPIDOMWindowOuter
:
:
From
(
domWindow
)
;
nsIDocShell
*
docshell
=
pDomWindow
-
>
GetDocShell
(
)
;
if
(
docshell
)
{
docshell
-
>
GetCustomUserAgent
(
args
.
customUserAgent
(
)
)
;
}
}
}
nsCOMPtr
<
nsIBrowserChild
>
iBrowserChild
;
GetCallback
(
iBrowserChild
)
;
BrowserChild
*
browserChild
=
static_cast
<
BrowserChild
*
>
(
iBrowserChild
.
get
(
)
)
;
if
(
MissingRequiredBrowserChild
(
browserChild
"
ftp
"
)
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
gNeckoChild
-
>
SendPDocumentChannelConstructor
(
this
browserChild
IPC
:
:
SerializedLoadContext
(
this
)
args
)
;
mIsPending
=
true
;
mWasOpened
=
true
;
mListener
=
listener
;
return
NS_OK
;
}
class
DocumentFailedAsyncOpenEvent
:
public
NeckoTargetChannelEvent
<
DocumentChannelChild
>
{
public
:
DocumentFailedAsyncOpenEvent
(
DocumentChannelChild
*
aChild
nsresult
aStatusCode
)
:
NeckoTargetChannelEvent
<
DocumentChannelChild
>
(
aChild
)
mStatus
(
aStatusCode
)
{
}
void
Run
(
)
override
{
mChild
-
>
DoFailedAsyncOpen
(
mStatus
)
;
}
private
:
nsresult
mStatus
;
}
;
IPCResult
DocumentChannelChild
:
:
RecvFailedAsyncOpen
(
const
nsresult
&
aStatusCode
)
{
mEventQueue
-
>
RunOrEnqueue
(
new
DocumentFailedAsyncOpenEvent
(
this
aStatusCode
)
)
;
return
IPC_OK
(
)
;
}
void
DocumentChannelChild
:
:
DoFailedAsyncOpen
(
const
nsresult
&
aStatusCode
)
{
ShutdownListeners
(
aStatusCode
)
;
}
void
DocumentChannelChild
:
:
ShutdownListeners
(
nsresult
aStatusCode
)
{
mStatus
=
aStatusCode
;
nsCOMPtr
<
nsIStreamListener
>
l
=
mListener
;
if
(
l
)
{
l
-
>
OnStartRequest
(
this
)
;
}
mIsPending
=
false
;
l
=
mListener
;
if
(
l
)
{
l
-
>
OnStopRequest
(
this
aStatusCode
)
;
}
mListener
=
nullptr
;
mCallbacks
=
nullptr
;
if
(
mLoadGroup
)
{
mLoadGroup
-
>
RemoveRequest
(
this
nullptr
aStatusCode
)
;
mLoadGroup
=
nullptr
;
}
if
(
CanSend
(
)
)
{
Send__delete__
(
this
)
;
}
}
IPCResult
DocumentChannelChild
:
:
RecvCancelForProcessSwitch
(
)
{
ShutdownListeners
(
NS_BINDING_ABORTED
)
;
return
IPC_OK
(
)
;
}
IPCResult
DocumentChannelChild
:
:
RecvDeleteSelf
(
)
{
Send__delete__
(
this
)
;
return
IPC_OK
(
)
;
}
IPCResult
DocumentChannelChild
:
:
RecvRedirectToRealChannel
(
const
uint32_t
&
aRegistrarId
nsIURI
*
aURI
const
uint32_t
&
aNewLoadFlags
const
Maybe
<
ReplacementChannelConfigInit
>
&
aInit
const
Maybe
<
LoadInfoArgs
>
&
aLoadInfo
nsTArray
<
DocumentChannelRedirect
>
&
&
aRedirects
const
uint64_t
&
aChannelId
nsIURI
*
aOriginalURI
const
uint32_t
&
aRedirectMode
const
uint32_t
&
aRedirectFlags
const
Maybe
<
uint32_t
>
&
aContentDisposition
const
Maybe
<
nsString
>
&
aContentDispositionFilename
RedirectToRealChannelResolver
&
&
aResolve
)
{
nsCOMPtr
<
nsILoadInfo
>
originalLoadInfo
;
RefPtr
<
dom
:
:
Document
>
loadingDocument
;
GetLoadInfo
(
getter_AddRefs
(
originalLoadInfo
)
)
;
if
(
originalLoadInfo
)
{
originalLoadInfo
-
>
GetLoadingDocument
(
getter_AddRefs
(
loadingDocument
)
)
;
}
nsCOMPtr
<
nsILoadInfo
>
loadInfo
;
nsresult
rv
=
LoadInfoArgsToLoadInfo
(
aLoadInfo
loadingDocument
getter_AddRefs
(
loadInfo
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
false
"
LoadInfoArgsToLoadInfo
failed
"
)
;
return
IPC_OK
(
)
;
}
mRedirects
=
std
:
:
move
(
aRedirects
)
;
mRedirectResolver
=
std
:
:
move
(
aResolve
)
;
nsCOMPtr
<
nsIChannel
>
newChannel
;
rv
=
NS_NewChannelInternal
(
getter_AddRefs
(
newChannel
)
aURI
loadInfo
nullptr
mLoadGroup
nullptr
aNewLoadFlags
)
;
RefPtr
<
HttpChannelChild
>
httpChild
=
do_QueryObject
(
newChannel
)
;
RefPtr
<
nsIChildChannel
>
childChannel
=
do_QueryObject
(
newChannel
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
false
"
NS_NewChannelInternal
failed
"
)
;
return
IPC_OK
(
)
;
}
auto
scopeExit
=
MakeScopeExit
(
[
&
]
(
)
{
mRedirectResolver
(
rv
)
;
mRedirectResolver
=
nullptr
;
}
)
;
if
(
httpChild
)
{
rv
=
httpChild
-
>
SetChannelId
(
aChannelId
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
return
IPC_OK
(
)
;
}
rv
=
newChannel
-
>
SetOriginalURI
(
aOriginalURI
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
IPC_OK
(
)
;
}
if
(
httpChild
)
{
rv
=
httpChild
-
>
SetRedirectMode
(
aRedirectMode
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
return
IPC_OK
(
)
;
}
newChannel
-
>
SetNotificationCallbacks
(
mCallbacks
)
;
if
(
aInit
)
{
HttpBaseChannel
:
:
ReplacementChannelConfig
config
(
*
aInit
)
;
HttpBaseChannel
:
:
ConfigureReplacementChannel
(
newChannel
config
)
;
}
if
(
aContentDisposition
)
{
newChannel
-
>
SetContentDisposition
(
*
aContentDisposition
)
;
}
if
(
aContentDispositionFilename
)
{
newChannel
-
>
SetContentDispositionFilename
(
*
aContentDispositionFilename
)
;
}
nsCOMPtr
<
nsIWritablePropertyBag
>
bag
(
do_QueryInterface
(
newChannel
)
)
;
if
(
bag
)
{
for
(
auto
iter
=
mPropertyHash
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
bag
-
>
SetProperty
(
iter
.
Key
(
)
iter
.
UserData
(
)
)
;
}
}
if
(
childChannel
)
{
rv
=
childChannel
-
>
ConnectParent
(
aRegistrarId
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
IPC_OK
(
)
;
}
mRedirectChannel
=
childChannel
;
}
nsCOMPtr
<
nsIEventTarget
>
target
=
GetNeckoTarget
(
)
;
MOZ_ASSERT
(
target
)
;
rv
=
gHttpHandler
-
>
AsyncOnChannelRedirect
(
this
newChannel
aRedirectFlags
target
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
scopeExit
.
release
(
)
;
}
return
IPC_OK
(
)
;
}
NS_IMETHODIMP
DocumentChannelChild
:
:
OnRedirectVerifyCallback
(
nsresult
aStatusCode
)
{
if
(
mRedirectChannel
)
{
if
(
NS_SUCCEEDED
(
aStatusCode
)
&
&
NS_SUCCEEDED
(
mStatus
)
)
{
mRedirectChannel
-
>
CompleteRedirectSetup
(
mListener
nullptr
)
;
}
else
{
nsCOMPtr
<
nsIChannel
>
channel
=
do_QueryInterface
(
mRedirectChannel
)
;
channel
-
>
SetNotificationCallbacks
(
nullptr
)
;
}
}
mRedirectChannel
=
nullptr
;
mRedirectResolver
(
aStatusCode
)
;
mRedirectResolver
=
nullptr
;
if
(
NS_FAILED
(
aStatusCode
)
)
{
ShutdownListeners
(
aStatusCode
)
;
return
NS_OK
;
}
if
(
mLoadGroup
)
{
mLoadGroup
-
>
RemoveRequest
(
this
nullptr
NS_BINDING_REDIRECTED
)
;
}
mCallbacks
=
nullptr
;
mListener
=
nullptr
;
if
(
CanSend
(
)
)
{
Send__delete__
(
this
)
;
}
return
NS_OK
;
}
IPCResult
DocumentChannelChild
:
:
RecvConfirmRedirect
(
nsIURI
*
aNewUri
ConfirmRedirectResolver
&
&
aResolve
)
{
nsCOMPtr
<
nsIURI
>
originalUri
;
nsresult
rv
=
GetOriginalURI
(
getter_AddRefs
(
originalUri
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
aResolve
(
rv
)
;
return
IPC_OK
(
)
;
}
int16_t
decision
=
nsIContentPolicy
:
:
ACCEPT
;
rv
=
CSPService
:
:
ConsultCSPForRedirect
(
originalUri
aNewUri
mLoadInfo
&
decision
)
;
if
(
NS_FAILED
(
rv
)
)
{
aResolve
(
rv
)
;
return
IPC_OK
(
)
;
}
if
(
NS_CP_REJECTED
(
decision
)
)
{
aResolve
(
NS_BINDING_FAILED
)
;
}
else
{
aResolve
(
NS_OK
)
;
}
return
IPC_OK
(
)
;
}
IPCResult
DocumentChannelChild
:
:
RecvNotifyChannelClassifierProtectionDisabled
(
const
uint32_t
&
aAcceptedReason
)
{
UrlClassifierCommon
:
:
NotifyChannelClassifierProtectionDisabled
(
this
aAcceptedReason
)
;
return
IPC_OK
(
)
;
}
IPCResult
DocumentChannelChild
:
:
RecvNotifyCookieAllowed
(
)
{
AntiTrackingCommon
:
:
NotifyBlockingDecision
(
this
AntiTrackingCommon
:
:
BlockingDecision
:
:
eAllow
0
)
;
return
IPC_OK
(
)
;
}
IPCResult
DocumentChannelChild
:
:
RecvNotifyCookieBlocked
(
const
uint32_t
&
aRejectedReason
)
{
AntiTrackingCommon
:
:
NotifyBlockingDecision
(
this
AntiTrackingCommon
:
:
BlockingDecision
:
:
eBlock
aRejectedReason
)
;
return
IPC_OK
(
)
;
}
IPCResult
DocumentChannelChild
:
:
RecvSetClassifierMatchedInfo
(
const
nsCString
&
aList
const
nsCString
&
aProvider
const
nsCString
&
aFullHash
)
{
SetMatchedInfo
(
aList
aProvider
aFullHash
)
;
return
IPC_OK
(
)
;
}
IPCResult
DocumentChannelChild
:
:
RecvSetClassifierMatchedTrackingInfo
(
const
nsCString
&
aLists
const
nsCString
&
aFullHash
)
{
nsTArray
<
nsCString
>
lists
fullhashes
;
for
(
const
nsACString
&
token
:
aLists
.
Split
(
'
'
)
)
{
lists
.
AppendElement
(
token
)
;
}
for
(
const
nsACString
&
token
:
aFullHash
.
Split
(
'
'
)
)
{
fullhashes
.
AppendElement
(
token
)
;
}
SetMatchedTrackingInfo
(
lists
fullhashes
)
;
return
IPC_OK
(
)
;
}
NS_IMETHODIMP
DocumentChannelChild
:
:
GetMatchedList
(
nsACString
&
aList
)
{
aList
=
mMatchedList
;
return
NS_OK
;
}
NS_IMETHODIMP
DocumentChannelChild
:
:
GetMatchedProvider
(
nsACString
&
aProvider
)
{
aProvider
=
mMatchedProvider
;
return
NS_OK
;
}
NS_IMETHODIMP
DocumentChannelChild
:
:
GetMatchedFullHash
(
nsACString
&
aFullHash
)
{
aFullHash
=
mMatchedFullHash
;
return
NS_OK
;
}
NS_IMETHODIMP
DocumentChannelChild
:
:
SetMatchedInfo
(
const
nsACString
&
aList
const
nsACString
&
aProvider
const
nsACString
&
aFullHash
)
{
NS_ENSURE_ARG
(
!
aList
.
IsEmpty
(
)
)
;
mMatchedList
=
aList
;
mMatchedProvider
=
aProvider
;
mMatchedFullHash
=
aFullHash
;
return
NS_OK
;
}
NS_IMETHODIMP
DocumentChannelChild
:
:
GetMatchedTrackingLists
(
nsTArray
<
nsCString
>
&
aLists
)
{
aLists
=
mMatchedTrackingLists
;
return
NS_OK
;
}
NS_IMETHODIMP
DocumentChannelChild
:
:
GetMatchedTrackingFullHashes
(
nsTArray
<
nsCString
>
&
aFullHashes
)
{
aFullHashes
=
mMatchedTrackingFullHashes
;
return
NS_OK
;
}
NS_IMETHODIMP
DocumentChannelChild
:
:
SetMatchedTrackingInfo
(
const
nsTArray
<
nsCString
>
&
aLists
const
nsTArray
<
nsCString
>
&
aFullHashes
)
{
NS_ENSURE_ARG
(
!
aLists
.
IsEmpty
(
)
)
;
mMatchedTrackingLists
=
aLists
;
mMatchedTrackingFullHashes
=
aFullHashes
;
return
NS_OK
;
}
NS_IMETHODIMP
DocumentChannelChild
:
:
Cancel
(
nsresult
aStatusCode
)
{
if
(
mCanceled
)
{
return
NS_OK
;
}
mCanceled
=
true
;
if
(
CanSend
(
)
)
{
SendCancel
(
aStatusCode
)
;
}
ShutdownListeners
(
aStatusCode
)
;
return
NS_OK
;
}
NS_IMETHODIMP
DocumentChannelChild
:
:
Suspend
(
)
{
NS_ENSURE_TRUE
(
CanSend
(
)
NS_ERROR_NOT_AVAILABLE
)
;
if
(
!
mSuspendCount
+
+
)
{
SendSuspend
(
)
;
}
mEventQueue
-
>
Suspend
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
DocumentChannelChild
:
:
Resume
(
)
{
NS_ENSURE_TRUE
(
CanSend
(
)
NS_ERROR_NOT_AVAILABLE
)
;
MOZ_ASSERT
(
mSuspendCount
)
;
if
(
!
-
-
mSuspendCount
)
{
SendResume
(
)
;
}
mEventQueue
-
>
Resume
(
)
;
return
NS_OK
;
}
}
}
