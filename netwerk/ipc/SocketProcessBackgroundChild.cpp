#
include
"
SocketProcessBackgroundChild
.
h
"
#
include
"
SocketProcessLogging
.
h
"
#
include
"
mozilla
/
ipc
/
Endpoint
.
h
"
#
include
"
nsThreadUtils
.
h
"
namespace
mozilla
:
:
net
{
StaticMutex
SocketProcessBackgroundChild
:
:
sMutex
;
StaticRefPtr
<
SocketProcessBackgroundChild
>
SocketProcessBackgroundChild
:
:
sInstance
;
StaticRefPtr
<
nsISerialEventTarget
>
SocketProcessBackgroundChild
:
:
sTaskQueue
;
RefPtr
<
SocketProcessBackgroundChild
>
SocketProcessBackgroundChild
:
:
GetSingleton
(
)
{
StaticMutexAutoLock
lock
(
sMutex
)
;
return
sInstance
;
}
void
SocketProcessBackgroundChild
:
:
Create
(
ipc
:
:
Endpoint
<
PSocketProcessBackgroundChild
>
&
&
aEndpoint
)
{
if
(
NS_WARN_IF
(
!
aEndpoint
.
IsValid
(
)
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Can
'
t
create
SocketProcessBackgroundChild
with
invalid
endpoint
"
)
;
return
;
}
nsCOMPtr
<
nsISerialEventTarget
>
transportQueue
;
if
(
NS_WARN_IF
(
NS_FAILED
(
NS_CreateBackgroundTaskQueue
(
"
SocketBackgroundChildQueue
"
getter_AddRefs
(
transportQueue
)
)
)
)
)
{
return
;
}
RefPtr
<
SocketProcessBackgroundChild
>
actor
=
new
SocketProcessBackgroundChild
(
)
;
transportQueue
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
BindSocketBackgroundChild
"
[
endpoint
=
std
:
:
move
(
aEndpoint
)
actor
]
(
)
mutable
{
MOZ_ALWAYS_TRUE
(
endpoint
.
Bind
(
actor
)
)
;
}
)
)
;
LOG
(
(
"
SocketProcessBackgroundChild
:
:
Create
"
)
)
;
StaticMutexAutoLock
lock
(
sMutex
)
;
MOZ_ASSERT
(
!
sInstance
&
&
!
sTaskQueue
"
Cannot
initialize
SocketProcessBackgroundChild
twice
!
"
)
;
sInstance
=
actor
;
sTaskQueue
=
transportQueue
;
}
void
SocketProcessBackgroundChild
:
:
Shutdown
(
)
{
nsCOMPtr
<
nsISerialEventTarget
>
taskQueue
=
TaskQueue
(
)
;
if
(
!
taskQueue
)
{
return
;
}
taskQueue
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
SocketProcessBackgroundChild
:
:
Shutdown
"
[
]
(
)
{
LOG
(
(
"
SocketProcessBackgroundChild
:
:
Shutdown
"
)
)
;
StaticMutexAutoLock
lock
(
sMutex
)
;
sInstance
-
>
Close
(
)
;
sInstance
=
nullptr
;
sTaskQueue
=
nullptr
;
}
)
)
;
}
already_AddRefed
<
nsISerialEventTarget
>
SocketProcessBackgroundChild
:
:
TaskQueue
(
)
{
StaticMutexAutoLock
lock
(
sMutex
)
;
return
do_AddRef
(
sTaskQueue
)
;
}
nsresult
SocketProcessBackgroundChild
:
:
WithActor
(
const
char
*
aName
MoveOnlyFunction
<
void
(
SocketProcessBackgroundChild
*
)
>
aCallback
)
{
nsCOMPtr
<
nsISerialEventTarget
>
taskQueue
=
TaskQueue
(
)
;
if
(
!
taskQueue
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
return
taskQueue
-
>
Dispatch
(
NS_NewRunnableFunction
(
aName
[
callback
=
std
:
:
move
(
aCallback
)
]
(
)
mutable
{
RefPtr
<
SocketProcessBackgroundChild
>
actor
=
SocketProcessBackgroundChild
:
:
GetSingleton
(
)
;
if
(
actor
)
{
callback
(
actor
)
;
}
}
)
)
;
}
SocketProcessBackgroundChild
:
:
SocketProcessBackgroundChild
(
)
{
LOG
(
(
"
SocketProcessBackgroundChild
ctor
"
)
)
;
}
SocketProcessBackgroundChild
:
:
~
SocketProcessBackgroundChild
(
)
{
LOG
(
(
"
SocketProcessBackgroundChild
dtor
"
)
)
;
}
}
