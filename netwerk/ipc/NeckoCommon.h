#
ifndef
mozilla_net_NeckoCommon_h
#
define
mozilla_net_NeckoCommon_h
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
"
nsIRequest
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
prenv
.
h
"
class
nsIStreamListener
;
namespace
mozilla
{
namespace
dom
{
class
BrowserChild
;
}
}
#
if
defined
(
DEBUG
)
#
define
NECKO_ERRORS_ARE_FATAL_DEFAULT
true
#
else
#
define
NECKO_ERRORS_ARE_FATAL_DEFAULT
false
#
endif
#
define
NECKO_MAYBE_ABORT
(
msg
)
\
do
{
\
bool
abort
=
NECKO_ERRORS_ARE_FATAL_DEFAULT
;
\
const
char
*
e
=
PR_GetEnv
(
"
NECKO_ERRORS_ARE_FATAL
"
)
;
\
if
(
e
)
abort
=
(
*
e
=
=
'
0
'
)
?
false
:
true
;
\
if
(
abort
)
{
\
msg
.
AppendLiteral
(
\
"
(
set
NECKO_ERRORS_ARE_FATAL
=
0
in
your
environment
"
\
"
to
convert
this
error
into
a
warning
.
)
"
)
;
\
MOZ_CRASH_UNSAFE
(
msg
.
get
(
)
)
;
\
}
else
{
\
msg
.
AppendLiteral
(
\
"
(
set
NECKO_ERRORS_ARE_FATAL
=
1
in
your
environment
"
\
"
to
convert
this
warning
into
a
fatal
error
.
)
"
)
;
\
NS_WARNING
(
msg
.
get
(
)
)
;
\
}
\
}
while
(
0
)
#
define
DROP_DEAD
(
)
\
do
{
\
nsPrintfCString
msg
(
"
NECKO
ERROR
:
'
%
s
'
UNIMPLEMENTED
"
__FUNCTION__
)
;
\
NECKO_MAYBE_ABORT
(
msg
)
;
\
return
NS_ERROR_NOT_IMPLEMENTED
;
\
}
while
(
0
)
#
define
ENSURE_CALLED_BEFORE_ASYNC_OPEN
(
)
\
do
{
\
if
(
LoadIsPending
(
)
|
|
LoadWasOpened
(
)
)
{
\
nsPrintfCString
msg
(
"
'
%
s
'
called
after
AsyncOpen
:
%
s
+
%
d
"
__FUNCTION__
\
__FILE__
__LINE__
)
;
\
NECKO_MAYBE_ABORT
(
msg
)
;
\
}
\
NS_ENSURE_TRUE
(
!
LoadIsPending
(
)
NS_ERROR_IN_PROGRESS
)
;
\
NS_ENSURE_TRUE
(
!
LoadWasOpened
(
)
NS_ERROR_ALREADY_OPENED
)
;
\
}
while
(
0
)
#
define
ENSURE_CALLED_BEFORE_CONNECT
(
)
\
do
{
\
if
(
LoadRequestObserversCalled
(
)
)
{
\
nsPrintfCString
msg
(
"
'
%
s
'
called
too
late
:
%
s
+
%
d
"
__FUNCTION__
\
__FILE__
__LINE__
)
;
\
NECKO_MAYBE_ABORT
(
msg
)
;
\
if
(
LoadIsPending
(
)
)
return
NS_ERROR_IN_PROGRESS
;
\
MOZ_ASSERT
(
LoadWasOpened
(
)
)
;
\
return
NS_ERROR_ALREADY_OPENED
;
\
}
\
}
while
(
0
)
namespace
mozilla
{
namespace
net
{
inline
bool
IsNeckoChild
(
)
{
static
bool
didCheck
=
false
;
static
bool
amChild
=
false
;
if
(
!
didCheck
)
{
didCheck
=
true
;
amChild
=
(
XRE_GetProcessType
(
)
=
=
GeckoProcessType_Content
)
;
}
return
amChild
;
}
inline
bool
IsSocketProcessChild
(
)
{
static
bool
amChild
=
(
XRE_GetProcessType
(
)
=
=
GeckoProcessType_Socket
)
;
return
amChild
;
}
class
HttpChannelSecurityWarningReporter
:
public
nsISupports
{
public
:
[
[
nodiscard
]
]
virtual
nsresult
ReportSecurityMessage
(
const
nsAString
&
aMessageTag
const
nsAString
&
aMessageCategory
)
=
0
;
[
[
nodiscard
]
]
virtual
nsresult
LogBlockedCORSRequest
(
const
nsAString
&
aMessage
const
nsACString
&
aCategory
bool
aIsWarning
=
false
)
=
0
;
[
[
nodiscard
]
]
virtual
nsresult
LogMimeTypeMismatch
(
const
nsACString
&
aMessageName
bool
aWarning
const
nsAString
&
aURL
const
nsAString
&
aContentType
)
=
0
;
}
;
struct
OnStartRequestParams
{
nsCOMPtr
<
nsIRequest
>
request
;
}
;
struct
OnDataAvailableParams
{
nsCOMPtr
<
nsIRequest
>
request
;
nsCString
data
;
uint64_t
offset
;
uint32_t
count
;
}
;
struct
OnStopRequestParams
{
nsCOMPtr
<
nsIRequest
>
request
;
nsresult
status
;
}
;
struct
OnAfterLastPartParams
{
nsresult
status
;
}
;
using
StreamListenerFunction
=
mozilla
:
:
Variant
<
OnStartRequestParams
OnDataAvailableParams
OnStopRequestParams
OnAfterLastPartParams
>
;
nsresult
ForwardStreamListenerFunctions
(
nsTArray
<
StreamListenerFunction
>
aCalls
nsIStreamListener
*
aParent
)
;
}
}
#
endif
