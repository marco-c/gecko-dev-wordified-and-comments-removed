;
(
(
factory
)
=
>
{
if
(
typeof
(
require
)
=
=
=
'
function
'
)
{
require
(
"
chrome
"
)
.
Cu
.
import
(
module
.
uri
exports
)
;
}
else
if
(
~
String
(
this
)
.
indexOf
(
'
BackstagePass
'
)
)
{
let
module
=
{
uri
:
__URI__
id
:
"
toolkit
/
loader
"
exports
:
Object
.
create
(
null
)
}
factory
(
module
)
;
Object
.
assign
(
this
module
.
exports
)
;
this
.
EXPORTED_SYMBOLS
=
Object
.
getOwnPropertyNames
(
module
.
exports
)
;
}
else
{
throw
Error
(
"
Loading
environment
is
not
supported
"
)
;
}
}
)
(
module
=
>
{
'
use
strict
'
;
module
.
metadata
=
{
"
stability
"
:
"
unstable
"
}
;
const
{
classes
:
Cc
Constructor
:
CC
interfaces
:
Ci
utils
:
Cu
results
:
Cr
manager
:
Cm
}
=
Components
;
const
systemPrincipal
=
CC
(
'
mozilla
.
org
/
systemprincipal
;
1
'
'
nsIPrincipal
'
)
(
)
;
const
{
loadSubScript
}
=
Cc
[
'
mozilla
.
org
/
moz
/
jssubscript
-
loader
;
1
'
]
.
getService
(
Ci
.
mozIJSSubScriptLoader
)
;
const
{
addObserver
notifyObservers
}
=
Cc
[
'
mozilla
.
org
/
observer
-
service
;
1
'
]
.
getService
(
Ci
.
nsIObserverService
)
;
const
{
XPCOMUtils
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
{
}
)
;
const
{
NetUtil
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
{
}
)
;
const
{
join
:
pathJoin
normalize
dirname
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
/
ospath_unix
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
resProto
"
"
mozilla
.
org
/
network
/
protocol
;
1
?
name
=
resource
"
"
nsIResProtocolHandler
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
zipCache
"
"
mozilla
.
org
/
libjar
/
zip
-
reader
-
cache
;
1
"
"
nsIZipReaderCache
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
XulApp
"
(
)
=
>
{
let
xulappURI
=
module
.
uri
.
replace
(
"
toolkit
/
loader
.
js
"
"
sdk
/
system
/
xul
-
app
.
jsm
"
)
;
return
Cu
.
import
(
xulappURI
{
}
)
;
}
)
;
const
bind
=
Function
.
call
.
bind
(
Function
.
bind
)
;
const
getOwnPropertyDescriptor
=
Object
.
getOwnPropertyDescriptor
;
const
prototypeOf
=
Object
.
getPrototypeOf
;
const
getOwnIdentifiers
=
x
=
>
[
.
.
.
Object
.
getOwnPropertyNames
(
x
)
.
.
.
Object
.
getOwnPropertySymbols
(
x
)
]
;
const
NODE_MODULES
=
new
Set
(
[
"
assert
"
"
buffer_ieee754
"
"
buffer
"
"
child_process
"
"
cluster
"
"
console
"
"
constants
"
"
crypto
"
"
_debugger
"
"
dgram
"
"
dns
"
"
domain
"
"
events
"
"
freelist
"
"
fs
"
"
http
"
"
https
"
"
_linklist
"
"
module
"
"
net
"
"
os
"
"
path
"
"
punycode
"
"
querystring
"
"
readline
"
"
repl
"
"
stream
"
"
string_decoder
"
"
sys
"
"
timers
"
"
tls
"
"
tty
"
"
url
"
"
util
"
"
vm
"
"
zlib
"
]
)
;
const
COMPONENT_ERROR
=
'
Components
is
not
available
in
this
context
.
\
n
'
+
'
Functionality
provided
by
Components
may
be
available
in
an
SDK
\
n
'
+
'
module
:
https
:
/
/
developer
.
mozilla
.
org
/
en
-
US
/
Add
-
ons
/
SDK
\
n
\
n
'
+
'
However
if
you
still
need
to
import
Components
you
may
use
the
\
n
'
+
'
chrome
module
\
'
s
properties
for
shortcuts
to
Component
properties
:
\
n
\
n
'
+
'
Shortcuts
:
\
n
'
+
'
Cc
=
Components
'
+
'
.
classes
\
n
'
+
'
Ci
=
Components
'
+
'
.
interfaces
\
n
'
+
'
Cu
=
Components
'
+
'
.
utils
\
n
'
+
'
CC
=
Components
'
+
'
.
Constructor
\
n
'
+
'
Example
:
\
n
'
+
'
let
{
Cc
Ci
}
=
require
(
\
'
chrome
\
'
)
;
\
n
'
;
function
freeze
(
object
)
{
if
(
prototypeOf
(
object
)
=
=
=
null
)
{
Object
.
freeze
(
object
)
;
}
else
{
prototypeOf
(
prototypeOf
(
object
.
isPrototypeOf
)
)
.
constructor
.
freeze
(
object
)
;
}
return
object
;
}
const
descriptor
=
iced
(
function
descriptor
(
object
)
{
let
value
=
{
}
;
getOwnIdentifiers
(
object
)
.
forEach
(
function
(
name
)
{
value
[
name
]
=
getOwnPropertyDescriptor
(
object
name
)
}
)
;
return
value
;
}
)
;
Loader
.
descriptor
=
descriptor
;
freeze
(
Object
)
;
freeze
(
Object
.
prototype
)
;
freeze
(
Function
)
;
freeze
(
Function
.
prototype
)
;
freeze
(
Array
)
;
freeze
(
Array
.
prototype
)
;
freeze
(
String
)
;
freeze
(
String
.
prototype
)
;
function
iced
(
f
)
{
if
(
!
Object
.
isFrozen
(
f
)
)
{
f
.
prototype
=
undefined
;
}
return
freeze
(
f
)
;
}
const
override
=
iced
(
function
override
(
target
source
)
{
let
properties
=
descriptor
(
target
)
let
extension
=
descriptor
(
source
|
|
{
}
)
getOwnIdentifiers
(
extension
)
.
forEach
(
function
(
name
)
{
properties
[
name
]
=
extension
[
name
]
;
}
)
;
return
Object
.
defineProperties
(
{
}
properties
)
;
}
)
;
Loader
.
override
=
override
;
function
sourceURI
(
uri
)
{
return
String
(
uri
)
.
split
(
"
-
>
"
)
.
pop
(
)
;
}
Loader
.
sourceURI
=
iced
(
sourceURI
)
;
function
isntLoaderFrame
(
frame
)
{
return
frame
.
fileName
!
=
=
module
.
uri
}
function
parseURI
(
uri
)
{
return
String
(
uri
)
.
split
(
"
-
>
"
)
.
pop
(
)
;
}
Loader
.
parseURI
=
parseURI
;
function
parseStack
(
stack
)
{
let
lines
=
String
(
stack
)
.
split
(
"
\
n
"
)
;
return
lines
.
reduce
(
function
(
frames
line
)
{
if
(
line
)
{
let
atIndex
=
line
.
indexOf
(
"
"
)
;
let
columnIndex
=
line
.
lastIndexOf
(
"
:
"
)
;
let
lineIndex
=
line
.
lastIndexOf
(
"
:
"
columnIndex
-
1
)
;
let
fileName
=
parseURI
(
line
.
slice
(
atIndex
+
1
lineIndex
)
)
;
let
lineNumber
=
parseInt
(
line
.
slice
(
lineIndex
+
1
columnIndex
)
)
;
let
columnNumber
=
parseInt
(
line
.
slice
(
columnIndex
+
1
)
)
;
let
name
=
line
.
slice
(
0
atIndex
)
.
split
(
"
(
"
)
.
shift
(
)
;
frames
.
unshift
(
{
fileName
:
fileName
name
:
name
lineNumber
:
lineNumber
columnNumber
:
columnNumber
}
)
;
}
return
frames
;
}
[
]
)
;
}
Loader
.
parseStack
=
parseStack
;
function
serializeStack
(
frames
)
{
return
frames
.
reduce
(
function
(
stack
frame
)
{
return
frame
.
name
+
"
"
+
frame
.
fileName
+
"
:
"
+
frame
.
lineNumber
+
"
:
"
+
frame
.
columnNumber
+
"
\
n
"
+
stack
;
}
"
"
)
;
}
Loader
.
serializeStack
=
serializeStack
;
class
DefaultMap
extends
Map
{
constructor
(
createItem
items
=
undefined
)
{
super
(
items
)
;
this
.
createItem
=
createItem
;
}
get
(
key
)
{
if
(
!
this
.
has
(
key
)
)
{
this
.
set
(
key
this
.
createItem
(
key
)
)
;
}
return
super
.
get
(
key
)
;
}
}
const
urlCache
=
{
getZipFileContents
(
uri
baseURL
)
{
let
basePath
=
addTrailingSlash
(
uri
.
JAREntry
)
.
slice
(
1
)
;
let
file
=
uri
.
JARFile
.
QueryInterface
(
Ci
.
nsIFileURL
)
.
file
;
let
enumerator
=
zipCache
.
getZip
(
file
)
.
findEntries
(
"
(
*
.
js
|
*
.
json
|
*
/
)
"
)
;
let
results
=
new
Set
(
)
;
for
(
let
entry
of
XPCOMUtils
.
IterStringEnumerator
(
enumerator
)
)
{
if
(
entry
.
startsWith
(
basePath
)
)
{
let
path
=
entry
.
slice
(
basePath
.
length
)
;
results
.
add
(
baseURL
+
path
)
;
}
}
return
results
;
}
zipContentsCache
:
new
DefaultMap
(
baseURL
=
>
{
let
uri
=
NetUtil
.
newURI
(
baseURL
)
;
if
(
baseURL
.
startsWith
(
"
resource
:
"
)
)
{
uri
=
NetUtil
.
newURI
(
resProto
.
resolveURI
(
uri
)
)
;
}
if
(
uri
instanceof
Ci
.
nsIJARURI
)
{
return
urlCache
.
getZipFileContents
(
uri
baseURL
)
;
}
return
null
;
}
)
filesCache
:
new
DefaultMap
(
url
=
>
{
try
{
let
uri
=
NetUtil
.
newURI
(
url
)
.
QueryInterface
(
Ci
.
nsIFileURL
)
;
return
uri
.
file
.
exists
(
)
;
}
catch
(
e
)
{
return
false
;
}
}
)
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsISupportsWeakReference
]
)
observe
(
)
{
this
.
zipContentsCache
.
clear
(
)
;
this
.
filesCache
.
clear
(
)
;
}
getBaseURL
(
url
)
{
if
(
url
.
startsWith
(
"
resource
:
/
/
"
)
)
{
return
/
^
resource
:
\
/
\
/
[
^
\
/
]
+
\
/
/
.
exec
(
url
)
[
0
]
;
}
let
uri
=
NetUtil
.
newURI
(
url
)
;
if
(
uri
instanceof
Ci
.
nsIJARURI
)
{
return
jar
:
{
uri
.
JARFile
.
spec
}
!
/
;
}
return
null
;
}
exists
(
url
)
{
if
(
!
/
\
.
(
?
:
js
|
json
)
/
.
test
(
url
)
)
{
url
=
addTrailingSlash
(
url
)
;
}
let
baseURL
=
this
.
getBaseURL
(
url
)
;
let
scripts
=
baseURL
&
&
this
.
zipContentsCache
.
get
(
baseURL
)
;
if
(
scripts
)
{
return
scripts
.
has
(
url
)
;
}
return
this
.
filesCache
.
get
(
url
)
;
}
}
addObserver
(
urlCache
"
startupcache
-
invalidate
"
true
)
;
function
readURI
(
uri
)
{
let
nsURI
=
NetUtil
.
newURI
(
uri
)
;
if
(
nsURI
.
scheme
=
=
"
resource
"
)
{
uri
=
resProto
.
resolveURI
(
nsURI
)
;
}
let
stream
=
NetUtil
.
newChannel
(
{
uri
:
NetUtil
.
newURI
(
uri
'
UTF
-
8
'
)
loadUsingSystemPrincipal
:
true
}
)
.
open2
(
)
;
let
count
=
stream
.
available
(
)
;
let
data
=
NetUtil
.
readInputStreamToString
(
stream
count
{
charset
:
'
UTF
-
8
'
}
)
;
stream
.
close
(
)
;
return
data
;
}
function
join
(
base
.
.
.
paths
)
{
let
match
=
/
^
(
(
?
:
resource
|
file
|
chrome
)
\
:
\
/
\
/
[
^
\
/
]
*
|
jar
:
[
^
!
]
+
!
)
(
.
*
)
/
.
exec
(
base
)
;
if
(
match
)
{
return
match
[
1
]
+
normalize
(
pathJoin
(
match
[
2
]
.
.
.
paths
)
)
;
}
return
normalize
(
pathJoin
(
base
.
.
.
paths
)
)
;
}
Loader
.
join
=
join
;
const
Sandbox
=
iced
(
function
Sandbox
(
options
)
{
options
=
{
wantComponents
:
false
sandboxName
:
options
.
name
principal
:
'
principal
'
in
options
?
options
.
principal
:
systemPrincipal
wantXrays
:
'
wantXrays
'
in
options
?
options
.
wantXrays
:
true
wantGlobalProperties
:
'
wantGlobalProperties
'
in
options
?
options
.
wantGlobalProperties
:
[
]
sandboxPrototype
:
'
prototype
'
in
options
?
options
.
prototype
:
{
}
invisibleToDebugger
:
'
invisibleToDebugger
'
in
options
?
options
.
invisibleToDebugger
:
false
metadata
:
'
metadata
'
in
options
?
options
.
metadata
:
{
}
waiveIntereposition
:
!
!
options
.
waiveIntereposition
}
;
if
(
options
.
metadata
&
&
options
.
metadata
.
addonID
)
{
options
.
addonId
=
options
.
metadata
.
addonID
;
}
let
sandbox
=
Cu
.
Sandbox
(
options
.
principal
options
)
;
delete
sandbox
.
Iterator
;
delete
sandbox
.
Components
;
delete
sandbox
.
importFunction
;
delete
sandbox
.
debug
;
return
sandbox
;
}
)
;
Loader
.
Sandbox
=
Sandbox
;
const
evaluate
=
iced
(
function
evaluate
(
sandbox
uri
options
)
{
let
{
source
line
version
encoding
}
=
override
(
{
encoding
:
'
UTF
-
8
'
line
:
1
version
:
'
1
.
8
'
source
:
null
}
options
)
;
return
source
?
Cu
.
evalInSandbox
(
source
sandbox
version
uri
line
)
:
loadSubScript
(
uri
sandbox
encoding
)
;
}
)
;
Loader
.
evaluate
=
evaluate
;
const
load
=
iced
(
function
load
(
loader
module
)
{
let
{
sandboxes
globals
loadModuleHook
}
=
loader
;
let
require
=
Require
(
loader
module
)
;
let
descriptors
=
descriptor
(
{
require
:
require
module
:
module
exports
:
module
.
exports
get
Components
(
)
{
throw
new
ReferenceError
(
COMPONENT_ERROR
)
;
}
}
)
;
let
sandbox
;
if
(
(
loader
.
useSharedGlobalSandbox
|
|
isSystemURI
(
module
.
uri
)
)
&
&
loader
.
sharedGlobalBlocklist
.
indexOf
(
module
.
id
)
=
=
-
1
)
{
sandbox
=
new
loader
.
sharedGlobalSandbox
.
Object
(
)
;
getOwnIdentifiers
(
globals
)
.
forEach
(
function
(
name
)
{
descriptors
[
name
]
=
getOwnPropertyDescriptor
(
globals
name
)
descriptors
[
name
]
.
configurable
=
true
;
}
)
;
Object
.
defineProperties
(
sandbox
descriptors
)
;
}
else
{
sandbox
=
Sandbox
(
{
name
:
module
.
uri
prototype
:
Object
.
create
(
globals
descriptors
)
wantXrays
:
false
wantGlobalProperties
:
module
.
id
=
=
"
sdk
/
indexed
-
db
"
?
[
"
indexedDB
"
]
:
[
]
invisibleToDebugger
:
loader
.
invisibleToDebugger
metadata
:
{
addonID
:
loader
.
id
URI
:
module
.
uri
}
}
)
;
}
sandboxes
[
module
.
uri
]
=
sandbox
;
try
{
evaluate
(
sandbox
module
.
uri
)
;
}
catch
(
error
)
{
let
{
message
fileName
lineNumber
}
=
error
;
let
stack
=
error
.
stack
|
|
Error
(
)
.
stack
;
let
frames
=
parseStack
(
stack
)
.
filter
(
isntLoaderFrame
)
;
let
toString
=
String
(
error
)
;
let
file
=
sourceURI
(
fileName
)
;
if
(
/
^
Error
opening
input
stream
/
.
test
(
String
(
error
)
)
)
{
let
caller
=
frames
.
slice
(
0
)
.
pop
(
)
;
fileName
=
caller
.
fileName
;
lineNumber
=
caller
.
lineNumber
;
message
=
"
Module
"
+
module
.
id
+
"
is
not
found
at
"
+
module
.
uri
;
toString
=
message
;
}
else
if
(
frames
[
frames
.
length
-
1
]
.
fileName
!
=
=
file
)
{
frames
.
push
(
{
fileName
:
file
lineNumber
:
lineNumber
name
:
"
"
}
)
;
}
let
prototype
=
typeof
(
error
)
=
=
=
"
object
"
?
error
.
constructor
.
prototype
:
Error
.
prototype
;
throw
Object
.
create
(
prototype
{
message
:
{
value
:
message
writable
:
true
configurable
:
true
}
fileName
:
{
value
:
fileName
writable
:
true
configurable
:
true
}
lineNumber
:
{
value
:
lineNumber
writable
:
true
configurable
:
true
}
stack
:
{
value
:
serializeStack
(
frames
)
writable
:
true
configurable
:
true
}
toString
:
{
value
:
(
)
=
>
toString
writable
:
true
configurable
:
true
}
}
)
;
}
if
(
loadModuleHook
)
{
module
=
loadModuleHook
(
module
require
)
;
}
if
(
loader
.
checkCompatibility
)
{
let
err
=
XulApp
.
incompatibility
(
module
)
;
if
(
err
)
{
throw
err
;
}
}
if
(
module
.
exports
&
&
typeof
(
module
.
exports
)
=
=
=
'
object
'
)
freeze
(
module
.
exports
)
;
return
module
;
}
)
;
Loader
.
load
=
load
;
function
normalizeExt
(
uri
)
{
return
isJSURI
(
uri
)
?
uri
:
isJSONURI
(
uri
)
?
uri
:
isJSMURI
(
uri
)
?
uri
:
uri
+
'
.
js
'
;
}
function
stripBase
(
rootURI
string
)
{
return
string
.
replace
(
rootURI
'
.
/
'
)
;
}
const
resolve
=
iced
(
function
resolve
(
id
base
)
{
if
(
!
isRelative
(
id
)
)
return
id
;
let
baseDir
=
dirname
(
base
)
;
if
(
!
baseDir
)
return
normalize
(
id
)
;
let
resolved
=
join
(
baseDir
id
)
;
if
(
isRelative
(
base
)
)
resolved
=
'
.
/
'
+
resolved
;
return
resolved
;
}
)
;
Loader
.
resolve
=
resolve
;
function
resolveAsFile
(
path
)
{
path
=
normalizeExt
(
path
)
;
if
(
urlCache
.
exists
(
path
)
)
{
return
path
;
}
return
null
;
}
function
resolveAsDirectory
(
path
)
{
try
{
let
manifestPath
=
addTrailingSlash
(
path
)
+
'
package
.
json
'
;
let
main
=
(
urlCache
.
exists
(
manifestPath
)
&
&
getManifestMain
(
JSON
.
parse
(
readURI
(
manifestPath
)
)
)
)
;
if
(
main
)
{
let
found
=
resolveAsFile
(
join
(
path
main
)
)
;
if
(
found
)
{
return
found
}
}
}
catch
(
e
)
{
}
return
resolveAsFile
(
addTrailingSlash
(
path
)
+
'
index
.
js
'
)
;
}
function
resolveRelative
(
rootURI
modulesDir
id
)
{
let
fullId
=
join
(
rootURI
modulesDir
id
)
;
let
resolvedPath
=
(
resolveAsFile
(
fullId
)
|
|
resolveAsDirectory
(
fullId
)
)
;
if
(
resolvedPath
)
{
return
stripBase
(
rootURI
resolvedPath
)
;
}
return
null
;
}
function
*
getNodeModulePaths
(
rootURI
start
)
{
let
moduleDir
=
'
node_modules
'
;
let
parts
=
start
.
split
(
'
/
'
)
;
while
(
parts
.
length
)
{
let
leaf
=
parts
.
pop
(
)
;
let
path
=
join
(
.
.
.
parts
leaf
moduleDir
)
;
if
(
leaf
!
=
=
moduleDir
&
&
urlCache
.
exists
(
join
(
rootURI
path
)
)
)
{
yield
path
;
}
}
if
(
urlCache
.
exists
(
join
(
rootURI
moduleDir
)
)
)
{
yield
moduleDir
;
}
}
const
nodeResolve
=
iced
(
function
nodeResolve
(
id
requirer
{
rootURI
}
)
{
id
=
Loader
.
resolve
(
id
requirer
)
;
if
(
isAbsoluteURI
(
id
)
)
{
return
null
;
}
let
resolvedPath
;
if
(
(
resolvedPath
=
resolveRelative
(
rootURI
"
"
id
)
)
)
{
return
resolvedPath
;
}
if
(
isAbsoluteURI
(
requirer
)
)
{
return
null
;
}
for
(
let
modulesDir
of
getNodeModulePaths
(
rootURI
dirname
(
requirer
)
)
)
{
if
(
(
resolvedPath
=
resolveRelative
(
rootURI
modulesDir
id
)
)
)
{
return
resolvedPath
;
}
}
return
null
;
}
)
;
Loader
.
nodeResolve
=
nodeResolve
;
function
addTrailingSlash
(
path
)
{
return
path
.
replace
(
/
\
/
*
/
"
/
"
)
;
}
const
resolveURI
=
iced
(
function
resolveURI
(
id
mapping
)
{
if
(
isAbsoluteURI
(
id
)
)
return
normalizeExt
(
id
)
;
for
(
let
[
path
uri
]
of
mapping
)
{
let
stripped
=
path
.
replace
(
/
\
/
+
/
"
"
)
;
if
(
stripped
=
=
=
"
"
|
|
id
=
=
=
stripped
|
|
id
.
startsWith
(
stripped
+
"
/
"
)
)
{
return
normalizeExt
(
id
.
replace
(
path
uri
)
)
;
}
}
return
null
;
}
)
;
Loader
.
resolveURI
=
resolveURI
;
const
Require
=
iced
(
function
Require
(
loader
requirer
)
{
let
{
modules
mapping
resolve
:
loaderResolve
load
manifest
rootURI
isNative
requireMap
requireHook
}
=
loader
;
if
(
isSystemURI
(
requirer
.
uri
)
)
{
isNative
=
false
;
loaderResolve
=
Loader
.
resolve
;
}
function
require
(
id
)
{
if
(
!
id
)
throw
Error
(
'
You
must
provide
a
module
name
when
calling
require
(
)
from
'
+
requirer
.
id
requirer
.
uri
)
;
if
(
requireHook
)
{
return
requireHook
(
id
_require
)
;
}
return
_require
(
id
)
;
}
function
_require
(
id
)
{
let
{
uri
requirement
}
=
getRequirements
(
id
)
;
let
module
=
null
;
if
(
uri
in
modules
)
{
module
=
modules
[
uri
]
;
}
else
if
(
isJSMURI
(
uri
)
)
{
module
=
modules
[
uri
]
=
Module
(
requirement
uri
)
;
module
.
exports
=
Cu
.
import
(
uri
{
}
)
;
freeze
(
module
)
;
}
else
if
(
isJSONURI
(
uri
)
)
{
let
data
;
try
{
data
=
JSON
.
parse
(
readURI
(
uri
)
)
;
module
=
modules
[
uri
]
=
Module
(
requirement
uri
)
;
module
.
exports
=
data
;
freeze
(
module
)
;
}
catch
(
err
)
{
if
(
err
&
&
/
JSON
\
.
parse
/
.
test
(
err
.
message
)
)
throw
err
;
uri
=
uri
+
'
.
js
'
;
}
}
if
(
!
(
uri
in
modules
)
)
{
module
=
modules
[
uri
]
=
Module
(
requirement
uri
)
;
try
{
freeze
(
load
(
loader
module
)
)
;
}
catch
(
e
)
{
delete
modules
[
uri
]
;
delete
loader
.
sandboxes
[
uri
]
;
throw
e
;
}
}
return
module
.
exports
;
}
function
getRequirements
(
id
)
{
if
(
!
id
)
throw
Error
(
'
you
must
provide
a
module
name
when
calling
require
(
)
from
'
+
requirer
.
id
requirer
.
uri
)
;
let
requirement
uri
;
if
(
isNative
)
{
if
(
requireMap
&
&
requireMap
[
requirer
.
id
]
)
requirement
=
requireMap
[
requirer
.
id
]
[
id
]
;
let
{
overrides
}
=
manifest
.
jetpack
;
for
(
let
key
in
overrides
)
{
if
(
/
^
[
.
\
/
]
/
.
test
(
key
)
)
{
continue
;
}
if
(
id
=
=
key
|
|
id
.
startsWith
(
key
+
"
/
"
)
)
{
id
=
overrides
[
key
]
+
id
.
substr
(
key
.
length
)
;
id
=
id
.
replace
(
/
^
[
.
\
/
]
+
/
"
"
)
;
}
}
if
(
!
requirement
&
&
modules
[
id
]
)
uri
=
requirement
=
id
;
if
(
!
requirement
&
&
!
NODE_MODULES
.
has
(
id
)
)
{
requirement
=
loaderResolve
(
id
requirer
.
id
{
manifest
:
manifest
rootURI
:
rootURI
}
)
;
}
if
(
!
requirement
)
{
requirement
=
isRelative
(
id
)
?
Loader
.
resolve
(
id
requirer
.
id
)
:
id
;
}
}
else
if
(
modules
[
id
]
)
{
uri
=
requirement
=
id
;
}
else
if
(
requirer
)
{
requirement
=
loaderResolve
(
id
requirer
.
id
)
;
}
else
{
requirement
=
id
;
}
uri
=
uri
|
|
resolveURI
(
requirement
mapping
)
;
if
(
!
uri
)
{
throw
Error
(
'
Module
:
Can
not
resolve
"
'
+
id
+
'
"
module
required
by
'
+
requirer
.
id
+
'
located
at
'
+
requirer
.
uri
requirer
.
uri
)
;
}
return
{
uri
:
uri
requirement
:
requirement
}
;
}
require
.
resolve
=
_require
.
resolve
=
function
resolve
(
id
)
{
let
{
uri
}
=
getRequirements
(
id
)
;
return
uri
;
}
require
.
context
=
prefix
=
>
{
return
id
=
>
{
return
require
(
prefix
+
id
)
;
}
;
}
;
require
.
main
=
loader
.
main
=
=
=
requirer
?
requirer
:
undefined
;
return
iced
(
require
)
;
}
)
;
Loader
.
Require
=
Require
;
const
main
=
iced
(
function
main
(
loader
id
)
{
if
(
!
id
&
&
loader
.
isNative
)
id
=
getManifestMain
(
loader
.
manifest
)
;
let
uri
=
resolveURI
(
id
loader
.
mapping
)
;
let
module
=
loader
.
main
=
loader
.
modules
[
uri
]
=
Module
(
id
uri
)
;
return
loader
.
load
(
loader
module
)
.
exports
;
}
)
;
Loader
.
main
=
main
;
const
Module
=
iced
(
function
Module
(
id
uri
)
{
return
Object
.
create
(
null
{
id
:
{
enumerable
:
true
value
:
id
}
exports
:
{
enumerable
:
true
writable
:
true
value
:
Object
.
create
(
null
)
configurable
:
true
}
uri
:
{
value
:
uri
}
}
)
;
}
)
;
Loader
.
Module
=
Module
;
const
unload
=
iced
(
function
unload
(
loader
reason
)
{
let
subject
=
{
wrappedJSObject
:
loader
.
destructor
}
;
notifyObservers
(
subject
'
sdk
:
loader
:
destroy
'
reason
)
;
}
)
;
Loader
.
unload
=
unload
;
function
Loader
(
options
)
{
if
(
options
.
sharedGlobalBlacklist
&
&
!
options
.
sharedGlobalBlocklist
)
{
options
.
sharedGlobalBlocklist
=
options
.
sharedGlobalBlacklist
;
}
let
{
modules
globals
resolve
paths
rootURI
manifest
requireMap
isNative
metadata
sharedGlobal
sharedGlobalBlocklist
checkCompatibility
waiveIntereposition
}
=
override
(
{
paths
:
{
}
modules
:
{
}
globals
:
{
get
console
(
)
{
let
{
ConsoleAPI
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Console
.
jsm
"
)
;
let
console
=
new
ConsoleAPI
(
{
consoleID
:
options
.
id
?
"
addon
/
"
+
options
.
id
:
"
"
}
)
;
Object
.
defineProperty
(
this
"
console
"
{
value
:
console
}
)
;
return
this
.
console
;
}
}
checkCompatibility
:
false
resolve
:
options
.
isNative
?
(
id
requirer
)
=
>
Loader
.
nodeResolve
(
id
requirer
{
rootURI
:
rootURI
}
)
:
Loader
.
resolve
sharedGlobalBlocklist
:
[
"
sdk
/
indexed
-
db
"
]
waiveIntereposition
:
false
}
options
)
;
if
(
typeof
manifest
!
=
"
object
"
|
|
!
manifest
)
{
manifest
=
{
}
;
}
if
(
typeof
manifest
.
jetpack
!
=
"
object
"
|
|
!
manifest
.
jetpack
)
{
manifest
.
jetpack
=
{
overrides
:
{
}
}
;
}
if
(
typeof
manifest
.
jetpack
.
overrides
!
=
"
object
"
|
|
!
manifest
.
jetpack
.
overrides
)
{
manifest
.
jetpack
.
overrides
=
{
}
;
}
let
destructor
=
freeze
(
Object
.
create
(
null
)
)
;
let
mapping
=
Object
.
keys
(
paths
)
.
sort
(
(
a
b
)
=
>
b
.
length
-
a
.
length
)
.
map
(
path
=
>
[
path
paths
[
path
]
]
)
;
modules
=
override
(
{
'
loader
/
unload
'
:
destructor
'
loader
/
options
'
:
options
'
chrome
'
:
{
Cc
:
Cc
Ci
:
Ci
Cu
:
Cu
Cr
:
Cr
Cm
:
Cm
CC
:
bind
(
CC
Components
)
components
:
Components
ChromeWorker
:
ChromeWorker
}
}
modules
)
;
const
builtinModuleExports
=
modules
;
modules
=
{
}
;
for
(
let
id
of
Object
.
keys
(
builtinModuleExports
)
)
{
let
uri
=
resolveURI
(
id
mapping
)
;
if
(
isNative
&
&
!
uri
)
uri
=
id
;
let
module
=
Module
(
id
uri
)
;
Object
.
defineProperty
(
module
"
exports
"
{
enumerable
:
true
get
:
function
(
)
{
return
builtinModuleExports
[
id
]
;
}
}
)
;
modules
[
uri
]
=
freeze
(
module
)
;
}
let
sharedGlobalSandbox
=
Sandbox
(
{
name
:
"
Addon
-
SDK
"
wantXrays
:
false
wantGlobalProperties
:
[
]
invisibleToDebugger
:
options
.
invisibleToDebugger
|
|
false
metadata
:
{
addonID
:
options
.
id
URI
:
"
Addon
-
SDK
"
}
prototype
:
options
.
sandboxPrototype
|
|
{
}
}
)
;
let
returnObj
=
{
destructor
:
{
enumerable
:
false
value
:
destructor
}
globals
:
{
enumerable
:
false
value
:
globals
}
mapping
:
{
enumerable
:
false
value
:
mapping
}
modules
:
{
enumerable
:
false
value
:
modules
}
metadata
:
{
enumerable
:
false
value
:
metadata
}
useSharedGlobalSandbox
:
{
enumerable
:
false
value
:
!
!
sharedGlobal
}
sharedGlobalSandbox
:
{
enumerable
:
false
value
:
sharedGlobalSandbox
}
sharedGlobalBlocklist
:
{
enumerable
:
false
value
:
sharedGlobalBlocklist
}
sharedGlobalBlacklist
:
{
enumerable
:
false
value
:
sharedGlobalBlocklist
}
sandboxes
:
{
enumerable
:
false
value
:
{
}
}
resolve
:
{
enumerable
:
false
value
:
resolve
}
id
:
{
enumerable
:
false
value
:
options
.
id
}
invisibleToDebugger
:
{
enumerable
:
false
value
:
options
.
invisibleToDebugger
|
|
false
}
load
:
{
enumerable
:
false
value
:
options
.
load
|
|
load
}
checkCompatibility
:
{
enumerable
:
false
value
:
checkCompatibility
}
requireHook
:
{
enumerable
:
false
value
:
options
.
requireHook
}
loadModuleHook
:
{
enumerable
:
false
value
:
options
.
loadModuleHook
}
main
:
new
function
(
)
{
let
main
;
return
{
enumerable
:
false
get
:
function
(
)
{
return
main
;
}
set
:
function
(
module
)
{
main
=
main
|
|
module
;
}
}
}
}
;
if
(
isNative
)
{
returnObj
.
isNative
=
{
enumerable
:
false
value
:
true
}
;
returnObj
.
manifest
=
{
enumerable
:
false
value
:
manifest
}
;
returnObj
.
requireMap
=
{
enumerable
:
false
value
:
requireMap
}
;
returnObj
.
rootURI
=
{
enumerable
:
false
value
:
addTrailingSlash
(
rootURI
)
}
;
}
return
freeze
(
Object
.
create
(
null
returnObj
)
)
;
}
;
Loader
.
Loader
=
Loader
;
var
isSystemURI
=
uri
=
>
/
^
resource
:
\
/
\
/
(
gre
|
devtools
|
testing
-
common
)
\
/
/
.
test
(
uri
)
;
var
isJSONURI
=
uri
=
>
uri
.
endsWith
(
'
.
json
'
)
;
var
isJSMURI
=
uri
=
>
uri
.
endsWith
(
'
.
jsm
'
)
;
var
isJSURI
=
uri
=
>
uri
.
endsWith
(
'
.
js
'
)
;
var
isAbsoluteURI
=
uri
=
>
uri
.
startsWith
(
"
resource
:
/
/
"
)
|
|
uri
.
startsWith
(
"
chrome
:
/
/
"
)
|
|
uri
.
startsWith
(
"
file
:
/
/
"
)
;
var
isRelative
=
id
=
>
id
.
startsWith
(
"
.
"
)
;
function
getManifestMain
(
manifest
)
{
let
main
=
manifest
.
main
|
|
'
.
/
index
.
js
'
;
return
isRelative
(
main
)
?
main
:
'
.
/
'
+
main
;
}
module
.
exports
=
iced
(
Loader
)
;
}
)
;
