'
use
strict
'
;
module
.
metadata
=
{
"
stability
"
:
"
unstable
"
}
;
var
getPrototypeOf
=
Object
.
getPrototypeOf
;
function
*
getNames
(
x
)
{
yield
*
Object
.
getOwnPropertyNames
(
x
)
;
yield
*
Object
.
getOwnPropertySymbols
(
x
)
;
}
var
getOwnPropertyDescriptor
=
Object
.
getOwnPropertyDescriptor
;
var
freeze
=
Object
.
freeze
;
var
hasOwnProperty
=
Function
.
call
.
bind
(
Object
.
prototype
.
hasOwnProperty
)
;
function
getOwnPropertyDescriptors
(
.
.
.
objects
)
{
let
descriptors
=
{
}
;
for
(
let
object
of
objects
)
for
(
let
name
of
getNames
(
object
)
)
descriptors
[
name
]
=
getOwnPropertyDescriptor
(
object
name
)
;
return
descriptors
;
}
function
isDataProperty
(
property
)
{
var
type
=
typeof
(
property
.
value
)
;
return
"
value
"
in
property
&
&
type
!
=
=
"
function
"
&
&
(
type
!
=
=
"
object
"
|
|
property
.
value
=
=
=
null
)
;
}
function
getDataProperties
(
object
)
{
var
properties
=
getOwnPropertyDescriptors
(
object
)
;
let
result
=
{
}
;
for
(
let
name
of
getNames
(
properties
)
)
{
var
property
=
properties
[
name
]
;
if
(
isDataProperty
(
property
)
)
{
result
[
name
]
=
{
value
:
property
.
value
writable
:
true
configurable
:
true
enumerable
:
false
}
;
}
}
return
result
;
}
function
obscure
(
source
prototype
=
getPrototypeOf
(
source
)
)
{
let
descriptors
=
{
}
;
for
(
let
name
of
getNames
(
source
)
)
{
let
property
=
getOwnPropertyDescriptor
(
source
name
)
;
property
.
enumerable
=
false
;
descriptors
[
name
]
=
property
;
}
return
Object
.
create
(
prototype
descriptors
)
;
}
exports
.
obscure
=
obscure
;
var
mix
=
function
(
.
.
.
sources
)
{
return
Object
.
create
(
getPrototypeOf
(
sources
[
0
]
)
getOwnPropertyDescriptors
(
.
.
.
sources
)
)
;
}
;
exports
.
mix
=
mix
;
function
extend
(
prototype
properties
)
{
return
Object
.
create
(
prototype
getOwnPropertyDescriptors
(
properties
)
)
;
}
exports
.
extend
=
extend
;
function
prototypeOf
(
input
)
{
return
typeof
(
input
)
=
=
=
'
function
'
?
input
.
prototype
:
input
;
}
function
Class
(
options
)
{
var
descriptor
=
{
extends
:
hasOwnProperty
(
options
'
extends
'
)
?
prototypeOf
(
options
.
extends
)
:
Class
.
prototype
implements
:
freeze
(
hasOwnProperty
(
options
'
implements
'
)
?
options
.
implements
.
map
(
prototypeOf
)
:
[
]
)
}
;
var
descriptors
=
[
]
.
concat
(
descriptor
.
implements
options
descriptor
{
constructor
}
)
;
function
constructor
(
)
{
var
instance
=
Object
.
create
(
prototype
attributes
)
;
if
(
initialize
)
Reflect
.
apply
(
initialize
instance
arguments
)
;
return
instance
;
}
var
prototype
=
Object
.
create
(
descriptor
.
extends
getOwnPropertyDescriptors
(
.
.
.
descriptors
)
)
;
var
initialize
=
prototype
.
initialize
;
var
attributes
=
mix
(
descriptor
.
extends
.
constructor
.
attributes
|
|
{
}
getDataProperties
(
prototype
)
)
;
constructor
.
attributes
=
attributes
;
Object
.
defineProperty
(
constructor
'
prototype
'
{
configurable
:
false
writable
:
false
value
:
prototype
}
)
;
return
constructor
;
}
Class
.
prototype
=
obscure
(
{
constructor
:
function
constructor
(
)
{
this
.
initialize
.
apply
(
this
arguments
)
;
return
this
;
}
initialize
:
function
initialize
(
)
{
}
toString
:
Object
.
prototype
.
toString
toLocaleString
:
Object
.
prototype
.
toLocaleString
toSource
:
Object
.
prototype
.
toSource
valueOf
:
Object
.
prototype
.
valueOf
isPrototypeOf
:
Object
.
prototype
.
isPrototypeOf
}
null
)
;
exports
.
Class
=
freeze
(
Class
)
;
