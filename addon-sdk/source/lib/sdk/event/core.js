"
use
strict
"
;
module
.
metadata
=
{
"
stability
"
:
"
unstable
"
}
;
const
UNCAUGHT_ERROR
=
'
An
error
event
was
emitted
for
which
there
was
no
listener
.
'
;
const
BAD_LISTENER
=
'
The
event
listener
must
be
a
function
.
'
;
const
{
DefaultMap
DefaultWeakMap
}
=
require
(
'
.
.
/
util
/
object
'
)
;
const
EVENT_TYPE_PATTERN
=
/
^
on
(
[
A
-
Z
]
\
w
+
)
/
;
exports
.
EVENT_TYPE_PATTERN
=
EVENT_TYPE_PATTERN
;
let
listenerCount
=
0
;
const
observers
=
new
DefaultWeakMap
(
(
)
=
>
{
return
new
DefaultMap
(
(
)
=
>
new
Map
(
)
)
;
}
)
;
function
on
(
target
type
listener
)
{
if
(
typeof
(
listener
)
!
=
=
'
function
'
)
throw
new
Error
(
BAD_LISTENER
)
;
observers
.
get
(
target
)
.
get
(
type
)
.
set
(
listener
listenerCount
+
+
)
;
}
exports
.
on
=
on
;
var
onceWeakMap
=
new
WeakMap
(
)
;
function
once
(
target
type
listener
)
{
function
replacement
(
.
.
.
args
)
{
off
(
target
type
replacement
)
;
onceWeakMap
.
delete
(
listener
)
;
listener
.
apply
(
target
args
)
;
}
;
onceWeakMap
.
set
(
listener
replacement
)
;
on
(
target
type
replacement
)
;
}
exports
.
once
=
once
;
function
emit
(
target
type
.
.
.
args
)
{
emitOnObject
(
target
type
target
.
.
.
args
)
;
}
exports
.
emit
=
emit
;
function
emitOnObject
(
target
type
thisArg
.
.
.
args
)
{
let
allListeners
=
observers
.
get
(
target
)
;
let
listeners
=
allListeners
.
get
(
type
)
;
if
(
type
=
=
=
'
error
'
&
&
!
listeners
.
size
&
&
!
allListeners
.
get
(
'
*
'
)
.
size
)
console
.
exception
(
args
[
0
]
)
;
let
count
=
listenerCount
;
for
(
let
[
listener
added
]
of
listeners
)
try
{
if
(
added
>
=
count
)
break
;
listener
.
apply
(
thisArg
args
)
;
}
catch
(
error
)
{
if
(
type
!
=
=
'
error
'
)
emitOnObject
(
target
'
error
'
target
error
)
;
else
console
.
exception
(
error
)
;
}
if
(
type
!
=
=
'
*
'
&
&
allListeners
.
get
(
'
*
'
)
.
size
)
emitOnObject
(
target
'
*
'
target
type
.
.
.
args
)
;
}
exports
.
emitOnObject
=
emitOnObject
;
function
off
(
target
type
listener
)
{
let
length
=
arguments
.
length
;
if
(
length
=
=
=
3
)
{
if
(
onceWeakMap
.
has
(
listener
)
)
{
observers
.
get
(
target
)
.
get
(
type
)
.
delete
(
onceWeakMap
.
get
(
listener
)
)
;
onceWeakMap
.
delete
(
listener
)
;
}
observers
.
get
(
target
)
.
get
(
type
)
.
delete
(
listener
)
;
}
else
if
(
length
=
=
=
2
)
{
observers
.
get
(
target
)
.
get
(
type
)
.
clear
(
)
;
observers
.
get
(
target
)
.
delete
(
type
)
;
}
else
if
(
length
=
=
=
1
)
{
for
(
let
listeners
of
observers
.
get
(
target
)
.
values
(
)
)
listeners
.
clear
(
)
;
observers
.
delete
(
target
)
;
}
}
exports
.
off
=
off
;
function
count
(
target
type
)
{
return
observers
.
get
(
target
)
.
get
(
type
)
.
size
;
}
exports
.
count
=
count
;
function
setListeners
(
target
listeners
)
{
Object
.
keys
(
listeners
|
|
{
}
)
.
forEach
(
key
=
>
{
let
match
=
EVENT_TYPE_PATTERN
.
exec
(
key
)
;
let
type
=
match
&
&
match
[
1
]
.
toLowerCase
(
)
;
if
(
!
type
)
return
;
let
listener
=
listeners
[
key
]
;
if
(
typeof
(
listener
)
=
=
=
'
function
'
)
on
(
target
type
listener
)
;
}
)
;
}
exports
.
setListeners
=
setListeners
;
