'
use
strict
'
;
module
.
metadata
=
{
"
stability
"
:
"
unstable
"
}
;
const
{
Cc
Ci
CC
}
=
require
(
'
chrome
'
)
;
const
options
=
require
(
'
loader
/
options
'
)
;
const
runtime
=
require
(
"
.
/
system
/
runtime
"
)
;
const
{
when
:
unload
}
=
require
(
"
.
/
system
/
unload
"
)
;
const
{
XPCOMUtils
}
=
require
(
'
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
'
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
'
appStartup
'
'
mozilla
.
org
/
toolkit
/
app
-
startup
;
1
'
'
nsIAppStartup
'
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
'
directoryService
'
'
mozilla
.
org
/
file
/
directory_service
;
1
'
'
nsIProperties
'
)
;
const
appInfo
=
Cc
[
"
mozilla
.
org
/
xre
/
app
-
info
;
1
"
]
.
getService
(
Ci
.
nsIXULAppInfo
)
;
const
PR_WRONLY
=
parseInt
(
"
0x02
"
)
;
const
PR_CREATE_FILE
=
parseInt
(
"
0x08
"
)
;
const
PR_APPEND
=
parseInt
(
"
0x10
"
)
;
const
PR_TRUNCATE
=
parseInt
(
"
0x20
"
)
;
function
openFile
(
path
mode
)
{
let
file
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsIFile
)
;
file
.
initWithPath
(
path
)
;
let
stream
=
Cc
[
"
mozilla
.
org
/
network
/
file
-
output
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIFileOutputStream
)
;
stream
.
init
(
file
mode
-
1
0
)
;
return
stream
}
exports
.
staticArgs
=
options
.
staticArgs
;
exports
.
env
=
require
(
'
.
/
system
/
environment
'
)
.
env
;
var
forcedExit
=
false
;
exports
.
exit
=
function
exit
(
code
)
{
if
(
forcedExit
)
{
return
;
}
let
resultsFile
=
'
resultFile
'
in
options
&
&
options
.
resultFile
;
function
unloader
(
)
{
if
(
!
options
.
resultFile
)
{
return
;
}
let
mode
=
PR_WRONLY
|
PR_CREATE_FILE
|
PR_TRUNCATE
;
let
stream
=
openFile
(
options
.
resultFile
mode
)
;
let
status
=
code
?
'
FAIL
'
:
'
OK
'
;
stream
.
write
(
status
status
.
length
)
;
stream
.
flush
(
)
;
stream
.
close
(
)
;
return
;
}
if
(
code
=
=
0
)
{
forcedExit
=
true
;
}
if
(
options
.
noQuit
)
{
return
unload
(
unloader
)
;
}
unloader
(
)
;
appStartup
.
quit
(
code
?
appStartup
.
eAttemptQuit
:
appStartup
.
eForceQuit
)
;
}
;
var
stdout
=
Object
.
freeze
(
{
write
:
dump
end
:
dump
}
)
;
exports
.
stdout
=
stdout
;
exports
.
stderr
=
stdout
;
exports
.
pathFor
=
function
pathFor
(
id
)
{
return
directoryService
.
get
(
id
Ci
.
nsIFile
)
.
path
;
}
;
exports
.
platform
=
runtime
.
OS
.
toLowerCase
(
)
;
const
[
architecture
compiler
]
=
runtime
.
XPCOMABI
?
runtime
.
XPCOMABI
.
match
(
/
^
(
[
^
-
]
*
)
-
(
.
*
)
/
)
:
[
null
null
]
;
exports
.
architecture
=
architecture
;
exports
.
compiler
=
compiler
;
exports
.
build
=
appInfo
.
appBuildID
;
exports
.
id
=
appInfo
.
ID
;
exports
.
name
=
appInfo
.
name
;
exports
.
version
=
appInfo
.
version
;
exports
.
platformVersion
=
appInfo
.
platformVersion
;
exports
.
vendor
=
appInfo
.
vendor
;
