"
use
strict
"
;
module
.
metadata
=
{
"
stability
"
:
"
unstable
"
}
;
const
{
Cc
Ci
}
=
require
(
"
chrome
"
)
;
const
{
Services
}
=
require
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
setTimeout
}
=
require
(
"
.
.
/
timers
"
)
;
const
{
platform
}
=
require
(
"
.
.
/
system
"
)
;
const
{
getMostRecentBrowserWindow
getOwnerBrowserWindow
getHiddenWindow
getScreenPixelsPerCSSPixel
}
=
require
(
"
.
.
/
window
/
utils
"
)
;
const
{
create
:
createFrame
swapFrameLoaders
getDocShell
}
=
require
(
"
.
.
/
frame
/
utils
"
)
;
const
{
window
:
addonWindow
}
=
require
(
"
.
.
/
addon
/
window
"
)
;
const
{
isNil
}
=
require
(
"
.
.
/
lang
/
type
"
)
;
const
{
data
}
=
require
(
'
.
.
/
self
'
)
;
const
events
=
require
(
"
.
.
/
system
/
events
"
)
;
const
XUL_NS
=
"
http
:
/
/
www
.
mozilla
.
org
/
keymaster
/
gatekeeper
/
there
.
is
.
only
.
xul
"
;
function
calculateRegion
(
{
position
width
height
defaultWidth
defaultHeight
}
rect
)
{
position
=
position
|
|
{
}
;
let
x
y
;
let
hasTop
=
!
isNil
(
position
.
top
)
;
let
hasRight
=
!
isNil
(
position
.
right
)
;
let
hasBottom
=
!
isNil
(
position
.
bottom
)
;
let
hasLeft
=
!
isNil
(
position
.
left
)
;
let
hasWidth
=
!
isNil
(
width
)
;
let
hasHeight
=
!
isNil
(
height
)
;
if
(
!
hasWidth
)
width
=
defaultWidth
;
if
(
!
hasHeight
)
height
=
defaultHeight
;
x
=
(
rect
.
right
-
width
)
/
2
;
y
=
(
rect
.
top
+
rect
.
bottom
-
height
)
/
2
;
if
(
hasTop
)
{
y
=
rect
.
top
+
position
.
top
;
if
(
hasBottom
&
&
!
hasHeight
)
height
=
rect
.
bottom
-
position
.
bottom
-
y
;
}
else
if
(
hasBottom
)
{
y
=
rect
.
bottom
-
position
.
bottom
-
height
;
}
if
(
hasLeft
)
{
x
=
position
.
left
;
if
(
hasRight
&
&
!
hasWidth
)
width
=
rect
.
right
-
position
.
right
-
x
;
}
else
if
(
hasRight
)
{
x
=
rect
.
right
-
width
-
position
.
right
;
}
return
{
x
:
x
y
:
y
width
:
width
height
:
height
}
;
}
function
open
(
panel
options
anchor
)
{
if
(
!
panel
.
openPopup
)
setTimeout
(
open
50
panel
options
anchor
)
;
else
display
(
panel
options
anchor
)
;
}
exports
.
open
=
open
;
function
isOpen
(
panel
)
{
return
panel
.
state
=
=
=
"
open
"
}
exports
.
isOpen
=
isOpen
;
function
isOpening
(
panel
)
{
return
panel
.
state
=
=
=
"
showing
"
}
exports
.
isOpening
=
isOpening
function
close
(
panel
)
{
return
panel
.
hidePopup
&
&
panel
.
hidePopup
(
)
;
}
exports
.
close
=
close
function
resize
(
panel
width
height
)
{
if
(
panel
.
firstChild
)
{
panel
.
firstChild
.
style
.
width
=
width
+
"
px
"
;
panel
.
firstChild
.
style
.
height
=
height
+
"
px
"
;
}
}
exports
.
resize
=
resize
function
display
(
panel
options
anchor
)
{
let
document
=
panel
.
ownerDocument
;
let
x
y
;
let
{
width
height
defaultWidth
defaultHeight
}
=
options
;
let
popupPosition
=
null
;
shimDefaultStyle
(
panel
)
;
if
(
!
anchor
)
{
panel
.
style
.
margin
=
"
0
"
;
let
viewportRect
=
document
.
defaultView
.
gBrowser
.
getBoundingClientRect
(
)
;
(
{
x
y
width
height
}
=
calculateRegion
(
options
viewportRect
)
)
;
}
else
{
panel
.
style
.
margin
=
"
"
;
let
{
CustomizableUI
window
}
=
anchor
.
ownerGlobal
;
if
(
CustomizableUI
)
{
let
node
=
anchor
;
(
{
anchor
}
=
CustomizableUI
.
getWidget
(
anchor
.
id
)
.
forWindow
(
window
)
)
;
if
(
node
!
=
=
anchor
)
CustomizableUI
.
hidePanelForNode
(
anchor
)
;
}
width
=
width
|
|
defaultWidth
;
height
=
height
|
|
defaultHeight
;
let
rect
=
anchor
.
getBoundingClientRect
(
)
;
let
zoom
=
getScreenPixelsPerCSSPixel
(
window
)
;
let
screenX
=
rect
.
left
+
window
.
mozInnerScreenX
*
zoom
;
let
screenY
=
rect
.
top
+
window
.
mozInnerScreenY
*
zoom
;
let
horizontal
vertical
;
if
(
screenY
>
window
.
screen
.
availHeight
/
2
+
height
)
vertical
=
"
top
"
;
else
vertical
=
"
bottom
"
;
if
(
screenY
>
window
.
screen
.
availWidth
/
2
+
width
)
horizontal
=
"
left
"
;
else
horizontal
=
"
right
"
;
let
verticalInverse
=
vertical
=
=
"
top
"
?
"
bottom
"
:
"
top
"
;
popupPosition
=
vertical
+
"
center
"
+
verticalInverse
+
horizontal
;
panel
.
setAttribute
(
"
flip
"
"
both
"
)
;
}
if
(
!
panel
.
viewFrame
)
{
panel
.
viewFrame
=
document
.
importNode
(
panel
.
backgroundFrame
false
)
;
panel
.
appendChild
(
panel
.
viewFrame
)
;
let
{
privateBrowsingId
}
=
getDocShell
(
panel
.
viewFrame
)
.
getOriginAttributes
(
)
;
let
principal
=
Services
.
scriptSecurityManager
.
createNullPrincipal
(
{
privateBrowsingId
}
)
;
getDocShell
(
panel
.
viewFrame
)
.
createAboutBlankContentViewer
(
principal
)
;
}
panel
.
firstChild
.
style
.
width
=
width
+
"
px
"
;
panel
.
firstChild
.
style
.
height
=
height
+
"
px
"
;
panel
.
openPopup
(
anchor
popupPosition
x
y
)
;
}
exports
.
display
=
display
;
function
shimDefaultStyle
(
panel
)
{
let
document
=
panel
.
ownerDocument
;
[
"
panel
-
inner
-
arrowcontent
"
"
panel
-
arrowcontent
"
]
.
forEach
(
function
(
value
)
{
let
node
=
document
.
getAnonymousElementByAttribute
(
panel
"
class
"
value
)
;
if
(
node
)
node
.
style
.
padding
=
0
;
}
)
;
}
function
show
(
panel
options
anchor
)
{
panel
.
setAttribute
(
"
noautofocus
"
!
options
.
focus
)
;
let
window
=
anchor
&
&
getOwnerBrowserWindow
(
anchor
)
;
let
{
document
}
=
window
?
window
:
getMostRecentBrowserWindow
(
)
;
attach
(
panel
document
)
;
open
(
panel
options
anchor
)
;
}
exports
.
show
=
show
function
onPanelClick
(
event
)
{
let
{
target
metaKey
ctrlKey
shiftKey
button
}
=
event
;
let
accel
=
platform
=
=
=
"
darwin
"
?
metaKey
:
ctrlKey
;
let
isLeftClick
=
button
=
=
=
0
;
let
isMiddleClick
=
button
=
=
=
1
;
if
(
(
isLeftClick
&
&
(
accel
|
|
shiftKey
)
)
|
|
isMiddleClick
)
{
let
link
=
target
.
closest
(
'
a
'
)
;
if
(
link
&
&
link
.
href
)
getMostRecentBrowserWindow
(
)
.
openUILink
(
link
.
href
event
)
}
}
function
setupPanelFrame
(
frame
)
{
frame
.
setAttribute
(
"
flex
"
1
)
;
frame
.
setAttribute
(
"
transparent
"
"
transparent
"
)
;
frame
.
setAttribute
(
"
autocompleteenabled
"
true
)
;
frame
.
setAttribute
(
"
tooltip
"
"
aHTMLTooltip
"
)
;
if
(
platform
=
=
=
"
darwin
"
)
{
frame
.
style
.
borderRadius
=
"
var
(
-
-
arrowpanel
-
border
-
radius
3
.
5px
)
"
;
frame
.
style
.
padding
=
"
1px
"
;
}
}
function
make
(
document
options
)
{
document
=
document
|
|
getMostRecentBrowserWindow
(
)
.
document
;
let
panel
=
document
.
createElementNS
(
XUL_NS
"
panel
"
)
;
panel
.
setAttribute
(
"
type
"
"
arrow
"
)
;
panel
.
setAttribute
(
"
sdkscriptenabled
"
options
.
allowJavascript
)
;
attach
(
panel
document
)
;
let
frameOptions
=
{
allowJavascript
:
options
.
allowJavascript
allowPlugins
:
true
allowAuth
:
true
allowWindowControl
:
false
browser
:
false
}
;
let
backgroundFrame
=
createFrame
(
addonWindow
frameOptions
)
;
setupPanelFrame
(
backgroundFrame
)
;
getDocShell
(
backgroundFrame
)
.
inheritPrivateBrowsingId
=
false
;
function
onPopupShowing
(
{
type
target
}
)
{
if
(
target
=
=
=
this
)
{
let
attrs
=
getDocShell
(
backgroundFrame
)
.
getOriginAttributes
(
)
;
getDocShell
(
panel
.
viewFrame
)
.
setOriginAttributes
(
attrs
)
;
swapFrameLoaders
(
backgroundFrame
panel
.
viewFrame
)
;
}
}
function
onPopupHiding
(
{
type
target
}
)
{
if
(
target
=
=
=
this
)
{
swapFrameLoaders
(
backgroundFrame
panel
.
viewFrame
)
;
panel
.
viewFrame
.
remove
(
)
;
panel
.
viewFrame
=
null
;
}
}
function
onContentReady
(
{
target
type
}
)
{
if
(
target
=
=
=
getContentDocument
(
panel
)
)
{
style
(
panel
)
;
events
.
emit
(
type
{
subject
:
panel
}
)
;
}
}
function
onContentLoad
(
{
target
type
}
)
{
if
(
target
=
=
=
getContentDocument
(
panel
)
)
events
.
emit
(
type
{
subject
:
panel
}
)
;
}
function
onContentChange
(
{
subject
:
document
type
}
)
{
if
(
document
=
=
=
getContentDocument
(
panel
)
&
&
document
.
defaultView
)
events
.
emit
(
type
{
subject
:
panel
}
)
;
}
function
onPanelStateChange
(
{
target
type
}
)
{
if
(
target
=
=
=
this
)
events
.
emit
(
type
{
subject
:
panel
}
)
}
panel
.
addEventListener
(
"
popupshowing
"
onPopupShowing
)
;
panel
.
addEventListener
(
"
popuphiding
"
onPopupHiding
)
;
for
(
let
event
of
[
"
popupshowing
"
"
popuphiding
"
"
popupshown
"
"
popuphidden
"
]
)
panel
.
addEventListener
(
event
onPanelStateChange
)
;
panel
.
addEventListener
(
"
click
"
onPanelClick
)
;
panel
.
addEventListener
(
"
DOMContentLoaded
"
onContentReady
true
)
;
backgroundFrame
.
addEventListener
(
"
DOMContentLoaded
"
onContentReady
true
)
;
panel
.
addEventListener
(
"
load
"
onContentLoad
true
)
;
backgroundFrame
.
addEventListener
(
"
load
"
onContentLoad
true
)
;
events
.
on
(
"
document
-
element
-
inserted
"
onContentChange
)
;
panel
.
backgroundFrame
=
backgroundFrame
;
panel
.
viewFrame
=
null
;
panel
.
onContentChange
=
onContentChange
;
return
panel
;
}
exports
.
make
=
make
;
function
attach
(
panel
document
)
{
document
=
document
|
|
getMostRecentBrowserWindow
(
)
.
document
;
let
container
=
document
.
getElementById
(
"
mainPopupSet
"
)
;
if
(
container
!
=
=
panel
.
parentNode
)
{
detach
(
panel
)
;
document
.
getElementById
(
"
mainPopupSet
"
)
.
appendChild
(
panel
)
;
}
}
exports
.
attach
=
attach
;
function
detach
(
panel
)
{
if
(
panel
.
parentNode
)
panel
.
parentNode
.
removeChild
(
panel
)
;
}
exports
.
detach
=
detach
;
function
dispose
(
panel
)
{
panel
.
backgroundFrame
.
remove
(
)
;
panel
.
backgroundFrame
=
null
;
events
.
off
(
"
document
-
element
-
inserted
"
panel
.
onContentChange
)
;
panel
.
onContentChange
=
null
;
detach
(
panel
)
;
}
exports
.
dispose
=
dispose
;
function
style
(
panel
)
{
try
{
let
document
=
panel
.
ownerDocument
;
let
contentDocument
=
getContentDocument
(
panel
)
;
let
window
=
document
.
defaultView
;
let
node
=
document
.
getAnonymousElementByAttribute
(
panel
"
class
"
"
panel
-
arrowcontent
"
)
;
let
{
color
fontFamily
fontSize
fontWeight
}
=
window
.
getComputedStyle
(
node
)
;
let
style
=
contentDocument
.
createElement
(
"
style
"
)
;
style
.
id
=
"
sdk
-
panel
-
style
"
;
style
.
textContent
=
"
body
{
"
+
"
color
:
"
+
color
+
"
;
"
+
"
font
-
family
:
"
+
fontFamily
+
"
;
"
+
"
font
-
weight
:
"
+
fontWeight
+
"
;
"
+
"
font
-
size
:
"
+
fontSize
+
"
;
"
+
"
}
"
;
let
container
=
contentDocument
.
head
?
contentDocument
.
head
:
contentDocument
.
documentElement
;
if
(
container
.
firstChild
)
container
.
insertBefore
(
style
container
.
firstChild
)
;
else
container
.
appendChild
(
style
)
;
}
catch
(
error
)
{
console
.
error
(
"
Unable
to
apply
panel
style
"
)
;
console
.
exception
(
error
)
;
}
}
exports
.
style
=
style
;
var
getContentFrame
=
panel
=
>
panel
.
viewFrame
|
|
panel
.
backgroundFrame
;
exports
.
getContentFrame
=
getContentFrame
;
function
getContentDocument
(
panel
)
{
return
getContentFrame
(
panel
)
.
contentDocument
;
}
exports
.
getContentDocument
=
getContentDocument
;
function
setURL
(
panel
url
)
{
let
frame
=
getContentFrame
(
panel
)
;
let
webNav
=
getDocShell
(
frame
)
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
;
webNav
.
loadURI
(
url
?
data
.
url
(
url
)
:
"
about
:
blank
"
0
null
null
null
)
;
}
exports
.
setURL
=
setURL
;
function
allowContextMenu
(
panel
allow
)
{
if
(
allow
)
{
panel
.
setAttribute
(
"
context
"
"
contentAreaContextMenu
"
)
;
}
else
{
panel
.
removeAttribute
(
"
context
"
)
;
}
}
exports
.
allowContextMenu
=
allowContextMenu
;
