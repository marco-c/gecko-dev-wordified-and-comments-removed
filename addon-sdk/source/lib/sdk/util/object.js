"
use
strict
"
;
module
.
metadata
=
{
"
stability
"
:
"
unstable
"
}
;
const
{
flatten
}
=
require
(
'
.
/
array
'
)
;
const
unbind
=
Function
.
call
.
bind
(
Function
.
bind
Function
.
call
)
;
const
slice
=
unbind
(
Array
.
prototype
.
slice
)
;
function
merge
(
source
)
{
let
descriptor
=
{
}
;
slice
(
arguments
1
)
.
filter
(
Boolean
)
.
forEach
(
function
onEach
(
properties
)
{
getOwnPropertyIdentifiers
(
properties
)
.
forEach
(
function
(
name
)
{
descriptor
[
name
]
=
Object
.
getOwnPropertyDescriptor
(
properties
name
)
;
}
)
;
}
)
;
return
Object
.
defineProperties
(
source
descriptor
)
;
}
exports
.
merge
=
merge
;
function
extend
(
source
)
{
let
rest
=
slice
(
arguments
1
)
;
rest
.
unshift
(
Object
.
create
(
source
)
)
;
return
merge
.
apply
(
null
rest
)
;
}
exports
.
extend
=
extend
;
function
has
(
obj
key
)
{
return
obj
.
hasOwnProperty
(
key
)
;
}
exports
.
has
=
has
;
function
each
(
obj
fn
)
{
for
(
let
key
in
obj
)
has
(
obj
key
)
&
&
fn
(
obj
[
key
]
key
obj
)
;
}
exports
.
each
=
each
;
function
safeMerge
(
source
)
{
slice
(
arguments
1
)
.
forEach
(
function
onEach
(
obj
)
{
for
(
let
prop
in
obj
)
source
[
prop
]
=
obj
[
prop
]
;
}
)
;
return
source
;
}
exports
.
safeMerge
=
safeMerge
;
function
omit
(
source
.
.
.
values
)
{
let
copy
=
{
}
;
let
keys
=
flatten
(
values
)
;
for
(
let
prop
in
source
)
if
(
!
~
keys
.
indexOf
(
prop
)
)
copy
[
prop
]
=
source
[
prop
]
;
return
copy
;
}
exports
.
omit
=
omit
;
function
getOwnPropertyIdentifiers
(
object
options
=
{
names
:
true
symbols
:
true
nonEnumerables
:
true
}
)
{
const
symbols
=
!
options
.
symbols
?
[
]
:
Object
.
getOwnPropertySymbols
(
object
)
;
const
names
=
!
options
.
names
?
[
]
:
options
.
nonEnumerables
?
Object
.
getOwnPropertyNames
(
object
)
:
Object
.
keys
(
object
)
;
return
[
.
.
.
names
.
.
.
symbols
]
;
}
exports
.
getOwnPropertyIdentifiers
=
getOwnPropertyIdentifiers
;
