#
include
"
BaseProfiler
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
BaseProfileJSONWriter
.
h
"
#
ifdef
MOZ_GECKO_PROFILER
#
include
"
BaseProfilerMarkerPayload
.
h
"
#
include
"
mozilla
/
BaseProfilerMarkerTypes
.
h
"
#
include
"
mozilla
/
BlocksRingBuffer
.
h
"
#
include
"
mozilla
/
leb128iterator
.
h
"
#
include
"
mozilla
/
ModuloBuffer
.
h
"
#
include
"
mozilla
/
PowerOfTwo
.
h
"
#
include
"
mozilla
/
ProfileBufferChunk
.
h
"
#
include
"
mozilla
/
ProfileBufferChunkManagerSingle
.
h
"
#
include
"
mozilla
/
ProfileBufferChunkManagerWithLocalLimit
.
h
"
#
include
"
mozilla
/
ProfileBufferControlledChunkManager
.
h
"
#
include
"
mozilla
/
ProfileChunkedBuffer
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
endif
#
if
defined
(
_MSC_VER
)
|
|
defined
(
__MINGW32__
)
#
include
<
windows
.
h
>
#
include
<
mmsystem
.
h
>
#
include
<
process
.
h
>
#
else
#
include
<
errno
.
h
>
#
include
<
string
.
h
>
#
include
<
time
.
h
>
#
include
<
unistd
.
h
>
#
endif
#
include
<
algorithm
>
#
include
<
atomic
>
#
include
<
iostream
>
#
include
<
thread
>
#
include
<
type_traits
>
#
include
<
utility
>
#
ifdef
MOZ_GECKO_PROFILER
MOZ_MAYBE_UNUSED
static
void
SleepMilli
(
unsigned
aMilliseconds
)
{
#
if
defined
(
_MSC_VER
)
|
|
defined
(
__MINGW32__
)
Sleep
(
aMilliseconds
)
;
#
else
struct
timespec
ts
=
{
static_cast
<
time_t
>
(
aMilliseconds
/
1000
)
long
(
aMilliseconds
%
1000
)
*
1000000
}
;
struct
timespec
tr
=
{
0
0
}
;
while
(
nanosleep
(
&
ts
&
tr
)
)
{
if
(
errno
=
=
EINTR
)
{
ts
=
tr
;
}
else
{
printf
(
"
nanosleep
(
)
-
>
%
s
\
n
"
strerror
(
errno
)
)
;
exit
(
1
)
;
}
}
#
endif
}
using
namespace
mozilla
;
void
TestPowerOfTwoMask
(
)
{
printf
(
"
TestPowerOfTwoMask
.
.
.
\
n
"
)
;
static_assert
(
MakePowerOfTwoMask
<
uint32_t
0
>
(
)
.
MaskValue
(
)
=
=
0
)
;
constexpr
PowerOfTwoMask
<
uint32_t
>
c0
=
MakePowerOfTwoMask
<
uint32_t
0
>
(
)
;
MOZ_RELEASE_ASSERT
(
c0
.
MaskValue
(
)
=
=
0
)
;
static_assert
(
MakePowerOfTwoMask
<
uint32_t
0xFFu
>
(
)
.
MaskValue
(
)
=
=
0xFFu
)
;
constexpr
PowerOfTwoMask
<
uint32_t
>
cFF
=
MakePowerOfTwoMask
<
uint32_t
0xFFu
>
(
)
;
MOZ_RELEASE_ASSERT
(
cFF
.
MaskValue
(
)
=
=
0xFFu
)
;
static_assert
(
MakePowerOfTwoMask
<
uint32_t
0xFFFFFFFFu
>
(
)
.
MaskValue
(
)
=
=
0xFFFFFFFFu
)
;
constexpr
PowerOfTwoMask
<
uint32_t
>
cFFFFFFFF
=
MakePowerOfTwoMask
<
uint32_t
0xFFFFFFFFu
>
(
)
;
MOZ_RELEASE_ASSERT
(
cFFFFFFFF
.
MaskValue
(
)
=
=
0xFFFFFFFFu
)
;
struct
TestDataU32
{
uint32_t
mInput
;
uint32_t
mMask
;
}
;
TestDataU32
tests
[
]
=
{
{
0
0
}
{
1
1
}
{
2
3
}
{
3
3
}
{
4
7
}
{
5
7
}
{
(
1u
<
<
31
)
-
1
(
1u
<
<
31
)
-
1
}
{
(
1u
<
<
31
)
uint32_t
(
-
1
)
}
{
(
1u
<
<
31
)
+
1
uint32_t
(
-
1
)
}
{
uint32_t
(
-
1
)
uint32_t
(
-
1
)
}
}
;
for
(
const
TestDataU32
&
test
:
tests
)
{
PowerOfTwoMask
<
uint32_t
>
p2m
(
test
.
mInput
)
;
MOZ_RELEASE_ASSERT
(
p2m
.
MaskValue
(
)
=
=
test
.
mMask
)
;
for
(
const
TestDataU32
&
inner
:
tests
)
{
if
(
p2m
.
MaskValue
(
)
!
=
uint32_t
(
-
1
)
)
{
MOZ_RELEASE_ASSERT
(
(
inner
.
mInput
%
p2m
)
=
=
(
inner
.
mInput
%
(
p2m
.
MaskValue
(
)
+
1
)
)
)
;
}
MOZ_RELEASE_ASSERT
(
(
inner
.
mInput
&
p2m
)
=
=
(
inner
.
mInput
%
p2m
)
)
;
MOZ_RELEASE_ASSERT
(
(
p2m
&
inner
.
mInput
)
=
=
(
inner
.
mInput
&
p2m
)
)
;
}
}
printf
(
"
TestPowerOfTwoMask
done
\
n
"
)
;
}
void
TestPowerOfTwo
(
)
{
printf
(
"
TestPowerOfTwo
.
.
.
\
n
"
)
;
static_assert
(
MakePowerOfTwo
<
uint32_t
1
>
(
)
.
Value
(
)
=
=
1
)
;
constexpr
PowerOfTwo
<
uint32_t
>
c1
=
MakePowerOfTwo
<
uint32_t
1
>
(
)
;
MOZ_RELEASE_ASSERT
(
c1
.
Value
(
)
=
=
1
)
;
static_assert
(
MakePowerOfTwo
<
uint32_t
1
>
(
)
.
Mask
(
)
.
MaskValue
(
)
=
=
0
)
;
static_assert
(
MakePowerOfTwo
<
uint32_t
128
>
(
)
.
Value
(
)
=
=
128
)
;
constexpr
PowerOfTwo
<
uint32_t
>
c128
=
MakePowerOfTwo
<
uint32_t
128
>
(
)
;
MOZ_RELEASE_ASSERT
(
c128
.
Value
(
)
=
=
128
)
;
static_assert
(
MakePowerOfTwo
<
uint32_t
128
>
(
)
.
Mask
(
)
.
MaskValue
(
)
=
=
127
)
;
static_assert
(
MakePowerOfTwo
<
uint32_t
0x80000000u
>
(
)
.
Value
(
)
=
=
0x80000000u
)
;
constexpr
PowerOfTwo
<
uint32_t
>
cMax
=
MakePowerOfTwo
<
uint32_t
0x80000000u
>
(
)
;
MOZ_RELEASE_ASSERT
(
cMax
.
Value
(
)
=
=
0x80000000u
)
;
static_assert
(
MakePowerOfTwo
<
uint32_t
0x80000000u
>
(
)
.
Mask
(
)
.
MaskValue
(
)
=
=
0x7FFFFFFFu
)
;
struct
TestDataU32
{
uint32_t
mInput
;
uint32_t
mValue
;
uint32_t
mMask
;
}
;
TestDataU32
tests
[
]
=
{
{
0
1
0
}
{
1
1
0
}
{
2
2
1
}
{
3
4
3
}
{
4
4
3
}
{
5
8
7
}
{
(
1u
<
<
31
)
-
1
(
1u
<
<
31
)
(
1u
<
<
31
)
-
1
}
{
(
1u
<
<
31
)
(
1u
<
<
31
)
(
1u
<
<
31
)
-
1
}
{
(
1u
<
<
31
)
+
1
(
1u
<
<
31
)
(
1u
<
<
31
)
-
1
}
{
uint32_t
(
-
1
)
(
1u
<
<
31
)
(
1u
<
<
31
)
-
1
}
}
;
for
(
const
TestDataU32
&
test
:
tests
)
{
PowerOfTwo
<
uint32_t
>
p2
(
test
.
mInput
)
;
MOZ_RELEASE_ASSERT
(
p2
.
Value
(
)
=
=
test
.
mValue
)
;
MOZ_RELEASE_ASSERT
(
p2
.
MaskValue
(
)
=
=
test
.
mMask
)
;
PowerOfTwoMask
<
uint32_t
>
p2m
=
p2
.
Mask
(
)
;
MOZ_RELEASE_ASSERT
(
p2m
.
MaskValue
(
)
=
=
test
.
mMask
)
;
for
(
const
TestDataU32
&
inner
:
tests
)
{
MOZ_RELEASE_ASSERT
(
(
inner
.
mInput
%
p2
)
=
=
(
inner
.
mInput
%
p2
.
Value
(
)
)
)
;
}
}
printf
(
"
TestPowerOfTwo
done
\
n
"
)
;
}
void
TestLEB128
(
)
{
printf
(
"
TestLEB128
.
.
.
\
n
"
)
;
MOZ_RELEASE_ASSERT
(
ULEB128MaxSize
<
uint8_t
>
(
)
=
=
2
)
;
MOZ_RELEASE_ASSERT
(
ULEB128MaxSize
<
uint16_t
>
(
)
=
=
3
)
;
MOZ_RELEASE_ASSERT
(
ULEB128MaxSize
<
uint32_t
>
(
)
=
=
5
)
;
MOZ_RELEASE_ASSERT
(
ULEB128MaxSize
<
uint64_t
>
(
)
=
=
10
)
;
struct
TestDataU64
{
uint64_t
mValue
;
unsigned
mSize
;
const
char
*
mBytes
;
}
;
TestDataU64
tests
[
]
=
{
{
0u
1
"
\
0
"
}
{
1u
1
"
\
x01
"
}
{
0x7Fu
1
"
\
x7F
"
}
{
0x80u
2
"
\
x80
\
x01
"
}
{
0x81u
2
"
\
x81
\
x01
"
}
{
0xFFu
2
"
\
xFF
\
x01
"
}
{
0x100u
2
"
\
x80
\
x02
"
}
{
0xFFFFFFFFu
5
"
\
xFF
\
xFF
\
xFF
\
xFF
\
x0F
"
}
{
0xFFFFFFFFFFFFFFFFu
10
"
\
xFF
\
xFF
\
xFF
\
xFF
\
xFF
\
xFF
\
xFF
\
xFF
\
xFF
\
x01
"
}
}
;
for
(
const
TestDataU64
&
test
:
tests
)
{
MOZ_RELEASE_ASSERT
(
ULEB128Size
(
test
.
mValue
)
=
=
test
.
mSize
)
;
uint8_t
buffer
[
ULEB128MaxSize
<
uint64_t
>
(
)
]
;
uint8_t
*
p
=
buffer
;
WriteULEB128
(
test
.
mValue
p
)
;
MOZ_RELEASE_ASSERT
(
p
=
=
buffer
+
test
.
mSize
)
;
for
(
unsigned
i
=
0
;
i
<
test
.
mSize
;
+
+
i
)
{
MOZ_RELEASE_ASSERT
(
buffer
[
i
]
=
=
uint8_t
(
test
.
mBytes
[
i
]
)
)
;
}
p
=
buffer
;
uint64_t
read
=
ReadULEB128
<
uint64_t
>
(
p
)
;
MOZ_RELEASE_ASSERT
(
p
=
=
buffer
+
test
.
mSize
)
;
MOZ_RELEASE_ASSERT
(
read
=
=
test
.
mValue
)
;
ULEB128Reader
<
uint64_t
>
reader
;
MOZ_RELEASE_ASSERT
(
!
reader
.
IsComplete
(
)
)
;
p
=
buffer
;
for
(
;
;
)
{
if
(
reader
.
FeedByteIsComplete
(
*
p
+
+
)
)
{
break
;
}
MOZ_RELEASE_ASSERT
(
!
reader
.
IsComplete
(
)
)
;
MOZ_RELEASE_ASSERT
(
p
<
buffer
+
test
.
mSize
)
;
}
MOZ_RELEASE_ASSERT
(
reader
.
IsComplete
(
)
)
;
MOZ_RELEASE_ASSERT
(
p
=
=
buffer
+
test
.
mSize
)
;
MOZ_RELEASE_ASSERT
(
reader
.
Value
(
)
=
=
test
.
mValue
)
;
reader
.
Reset
(
)
;
MOZ_RELEASE_ASSERT
(
!
reader
.
IsComplete
(
)
)
;
p
=
buffer
;
for
(
;
;
)
{
if
(
reader
.
FeedByteIsComplete
(
*
p
+
+
)
)
{
break
;
}
MOZ_RELEASE_ASSERT
(
!
reader
.
IsComplete
(
)
)
;
MOZ_RELEASE_ASSERT
(
p
<
buffer
+
test
.
mSize
)
;
}
MOZ_RELEASE_ASSERT
(
reader
.
IsComplete
(
)
)
;
MOZ_RELEASE_ASSERT
(
p
=
=
buffer
+
test
.
mSize
)
;
MOZ_RELEASE_ASSERT
(
reader
.
Value
(
)
=
=
test
.
mValue
)
;
}
printf
(
"
TestLEB128
done
\
n
"
)
;
}
template
<
uint8_t
byte
uint8_t
.
.
.
tail
>
constexpr
bool
TestConstexprULEB128Reader
(
ULEB128Reader
<
uint64_t
>
&
aReader
)
{
if
(
aReader
.
IsComplete
(
)
)
{
return
false
;
}
const
bool
isComplete
=
aReader
.
FeedByteIsComplete
(
byte
)
;
if
(
aReader
.
IsComplete
(
)
!
=
isComplete
)
{
return
false
;
}
if
constexpr
(
sizeof
.
.
.
(
tail
)
=
=
0
)
{
return
isComplete
;
}
else
{
if
(
isComplete
)
{
return
false
;
}
return
TestConstexprULEB128Reader
<
tail
.
.
.
>
(
aReader
)
;
}
}
template
<
uint64_t
expected
uint8_t
.
.
.
bytes
>
constexpr
bool
TestConstexprULEB128Reader
(
)
{
ULEB128Reader
<
uint64_t
>
reader
;
if
(
!
TestConstexprULEB128Reader
<
bytes
.
.
.
>
(
reader
)
)
{
return
false
;
}
if
(
!
reader
.
IsComplete
(
)
)
{
return
false
;
}
if
(
reader
.
Value
(
)
!
=
expected
)
{
return
false
;
}
reader
.
Reset
(
)
;
if
(
!
TestConstexprULEB128Reader
<
bytes
.
.
.
>
(
reader
)
)
{
return
false
;
}
if
(
!
reader
.
IsComplete
(
)
)
{
return
false
;
}
if
(
reader
.
Value
(
)
!
=
expected
)
{
return
false
;
}
return
true
;
}
static_assert
(
TestConstexprULEB128Reader
<
0x0u
0x0u
>
(
)
)
;
static_assert
(
!
TestConstexprULEB128Reader
<
0x0u
0x0u
0x0u
>
(
)
)
;
static_assert
(
TestConstexprULEB128Reader
<
0x1u
0x1u
>
(
)
)
;
static_assert
(
TestConstexprULEB128Reader
<
0x7Fu
0x7Fu
>
(
)
)
;
static_assert
(
TestConstexprULEB128Reader
<
0x80u
0x80u
0x01u
>
(
)
)
;
static_assert
(
!
TestConstexprULEB128Reader
<
0x80u
0x80u
>
(
)
)
;
static_assert
(
!
TestConstexprULEB128Reader
<
0x80u
0x01u
>
(
)
)
;
static_assert
(
TestConstexprULEB128Reader
<
0x81u
0x81u
0x01u
>
(
)
)
;
static_assert
(
TestConstexprULEB128Reader
<
0xFFu
0xFFu
0x01u
>
(
)
)
;
static_assert
(
TestConstexprULEB128Reader
<
0x100u
0x80u
0x02u
>
(
)
)
;
static_assert
(
TestConstexprULEB128Reader
<
0xFFFFFFFFu
0xFFu
0xFFu
0xFFu
0xFFu
0x0Fu
>
(
)
)
;
static_assert
(
!
TestConstexprULEB128Reader
<
0xFFFFFFFFu
0xFFu
0xFFu
0xFFu
0xFFu
>
(
)
)
;
static_assert
(
!
TestConstexprULEB128Reader
<
0xFFFFFFFFu
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
0x0Fu
>
(
)
)
;
static_assert
(
TestConstexprULEB128Reader
<
0xFFFFFFFFFFFFFFFFu
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
0x01u
>
(
)
)
;
static_assert
(
!
TestConstexprULEB128Reader
<
0xFFFFFFFFFFFFFFFFu
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
>
(
)
)
;
static
void
TestChunk
(
)
{
printf
(
"
TestChunk
.
.
.
\
n
"
)
;
static_assert
(
!
std
:
:
is_default_constructible_v
<
ProfileBufferChunk
>
"
ProfileBufferChunk
should
not
be
default
-
constructible
"
)
;
static_assert
(
!
std
:
:
is_constructible_v
<
ProfileBufferChunk
ProfileBufferChunk
:
:
Length
>
"
ProfileBufferChunk
should
not
be
constructible
from
Length
"
)
;
static_assert
(
sizeof
(
ProfileBufferChunk
:
:
Header
)
=
=
sizeof
(
ProfileBufferChunk
:
:
Header
:
:
mOffsetFirstBlock
)
+
sizeof
(
ProfileBufferChunk
:
:
Header
:
:
mOffsetPastLastBlock
)
+
sizeof
(
ProfileBufferChunk
:
:
Header
:
:
mDoneTimeStamp
)
+
sizeof
(
ProfileBufferChunk
:
:
Header
:
:
mBufferBytes
)
+
sizeof
(
ProfileBufferChunk
:
:
Header
:
:
mBlockCount
)
+
sizeof
(
ProfileBufferChunk
:
:
Header
:
:
mRangeStart
)
+
sizeof
(
ProfileBufferChunk
:
:
Header
:
:
mProcessId
)
+
sizeof
(
ProfileBufferChunk
:
:
Header
:
:
mPADDING
)
"
ProfileBufferChunk
:
:
Header
may
have
unwanted
padding
please
review
"
)
;
constexpr
ProfileBufferChunk
:
:
Length
TestLen
=
1000
;
for
(
ProfileBufferChunk
:
:
Length
len
=
0
;
len
<
=
TestLen
;
+
+
len
)
{
auto
chunk
=
ProfileBufferChunk
:
:
Create
(
len
)
;
static_assert
(
std
:
:
is_same_v
<
decltype
(
chunk
)
UniquePtr
<
ProfileBufferChunk
>
>
"
ProfileBufferChunk
:
:
Create
(
)
should
return
a
"
"
UniquePtr
<
ProfileBufferChunk
>
"
)
;
MOZ_RELEASE_ASSERT
(
!
!
chunk
"
OOM
!
?
"
)
;
MOZ_RELEASE_ASSERT
(
chunk
-
>
BufferBytes
(
)
>
=
len
)
;
MOZ_RELEASE_ASSERT
(
chunk
-
>
ChunkBytes
(
)
>
=
len
+
ProfileBufferChunk
:
:
SizeofChunkMetadata
(
)
)
;
MOZ_RELEASE_ASSERT
(
chunk
-
>
RemainingBytes
(
)
=
=
chunk
-
>
BufferBytes
(
)
)
;
MOZ_RELEASE_ASSERT
(
chunk
-
>
OffsetFirstBlock
(
)
=
=
0
)
;
MOZ_RELEASE_ASSERT
(
chunk
-
>
OffsetPastLastBlock
(
)
=
=
0
)
;
MOZ_RELEASE_ASSERT
(
chunk
-
>
BlockCount
(
)
=
=
0
)
;
MOZ_RELEASE_ASSERT
(
chunk
-
>
ProcessId
(
)
=
=
0
)
;
MOZ_RELEASE_ASSERT
(
chunk
-
>
RangeStart
(
)
=
=
0
)
;
MOZ_RELEASE_ASSERT
(
chunk
-
>
BufferSpan
(
)
.
LengthBytes
(
)
=
=
chunk
-
>
BufferBytes
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
chunk
-
>
GetNext
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
chunk
-
>
ReleaseNext
(
)
)
;
MOZ_RELEASE_ASSERT
(
chunk
-
>
Last
(
)
=
=
chunk
.
get
(
)
)
;
}
auto
chunkA
=
ProfileBufferChunk
:
:
Create
(
TestLen
)
;
MOZ_RELEASE_ASSERT
(
!
!
chunkA
"
OOM
!
?
"
)
;
MOZ_RELEASE_ASSERT
(
chunkA
-
>
BufferBytes
(
)
>
=
TestLen
)
;
MOZ_RELEASE_ASSERT
(
chunkA
-
>
ChunkBytes
(
)
>
=
TestLen
+
ProfileBufferChunk
:
:
SizeofChunkMetadata
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
chunkA
-
>
GetNext
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
chunkA
-
>
ReleaseNext
(
)
)
;
constexpr
ProfileBufferIndex
chunkARangeStart
=
12345
;
chunkA
-
>
SetRangeStart
(
chunkARangeStart
)
;
MOZ_RELEASE_ASSERT
(
chunkA
-
>
RangeStart
(
)
=
=
chunkARangeStart
)
;
auto
bufferA
=
chunkA
-
>
BufferSpan
(
)
;
static_assert
(
std
:
:
is_same_v
<
decltype
(
bufferA
)
Span
<
const
ProfileBufferChunk
:
:
Byte
>
>
"
BufferSpan
(
)
should
return
a
Span
<
const
Byte
>
"
)
;
MOZ_RELEASE_ASSERT
(
bufferA
.
LengthBytes
(
)
=
=
chunkA
-
>
BufferBytes
(
)
)
;
constexpr
ProfileBufferChunk
:
:
Length
initTailLen
=
10
;
auto
initTail
=
chunkA
-
>
ReserveInitialBlockAsTail
(
initTailLen
)
;
static_assert
(
std
:
:
is_same_v
<
decltype
(
initTail
)
Span
<
ProfileBufferChunk
:
:
Byte
>
>
"
ReserveInitialBlockAsTail
(
)
should
return
a
Span
<
Byte
>
"
)
;
MOZ_RELEASE_ASSERT
(
initTail
.
LengthBytes
(
)
=
=
initTailLen
)
;
MOZ_RELEASE_ASSERT
(
initTail
.
Elements
(
)
=
=
bufferA
.
Elements
(
)
)
;
MOZ_RELEASE_ASSERT
(
chunkA
-
>
OffsetFirstBlock
(
)
=
=
initTailLen
)
;
MOZ_RELEASE_ASSERT
(
chunkA
-
>
OffsetPastLastBlock
(
)
=
=
initTailLen
)
;
constexpr
ProfileBufferChunk
:
:
Length
block1Len
=
20
;
auto
block1
=
chunkA
-
>
ReserveBlock
(
block1Len
)
;
static_assert
(
std
:
:
is_same_v
<
decltype
(
block1
)
ProfileBufferChunk
:
:
ReserveReturn
>
"
ReserveBlock
(
)
should
return
a
ReserveReturn
"
)
;
MOZ_RELEASE_ASSERT
(
block1
.
mBlockRangeIndex
.
ConvertToProfileBufferIndex
(
)
=
=
chunkARangeStart
+
initTailLen
)
;
MOZ_RELEASE_ASSERT
(
block1
.
mSpan
.
LengthBytes
(
)
=
=
block1Len
)
;
MOZ_RELEASE_ASSERT
(
block1
.
mSpan
.
Elements
(
)
=
=
bufferA
.
Elements
(
)
+
initTailLen
)
;
MOZ_RELEASE_ASSERT
(
chunkA
-
>
OffsetFirstBlock
(
)
=
=
initTailLen
)
;
MOZ_RELEASE_ASSERT
(
chunkA
-
>
OffsetPastLastBlock
(
)
=
=
initTailLen
+
block1Len
)
;
MOZ_RELEASE_ASSERT
(
chunkA
-
>
RemainingBytes
(
)
!
=
0
)
;
const
ProfileBufferChunk
:
:
Length
remaining
=
chunkA
-
>
BufferBytes
(
)
-
(
initTailLen
+
block1Len
)
;
constexpr
ProfileBufferChunk
:
:
Length
overfill
=
30
;
const
ProfileBufferChunk
:
:
Length
block2Len
=
remaining
+
overfill
;
ProfileBufferChunk
:
:
ReserveReturn
block2
=
chunkA
-
>
ReserveBlock
(
block2Len
)
;
MOZ_RELEASE_ASSERT
(
block2
.
mBlockRangeIndex
.
ConvertToProfileBufferIndex
(
)
=
=
chunkARangeStart
+
initTailLen
+
block1Len
)
;
MOZ_RELEASE_ASSERT
(
block2
.
mSpan
.
LengthBytes
(
)
=
=
remaining
)
;
MOZ_RELEASE_ASSERT
(
block2
.
mSpan
.
Elements
(
)
=
=
bufferA
.
Elements
(
)
+
initTailLen
+
block1Len
)
;
MOZ_RELEASE_ASSERT
(
chunkA
-
>
OffsetFirstBlock
(
)
=
=
initTailLen
)
;
MOZ_RELEASE_ASSERT
(
chunkA
-
>
OffsetPastLastBlock
(
)
=
=
chunkA
-
>
BufferBytes
(
)
)
;
MOZ_RELEASE_ASSERT
(
chunkA
-
>
RemainingBytes
(
)
=
=
0
)
;
chunkA
-
>
MarkDone
(
)
;
chunkA
-
>
MarkRecycled
(
)
;
Span
<
ProfileBufferChunk
:
:
Byte
>
initTail2
=
chunkA
-
>
ReserveInitialBlockAsTail
(
0
)
;
MOZ_RELEASE_ASSERT
(
initTail2
.
LengthBytes
(
)
=
=
0
)
;
MOZ_RELEASE_ASSERT
(
initTail2
.
Elements
(
)
=
=
bufferA
.
Elements
(
)
)
;
MOZ_RELEASE_ASSERT
(
chunkA
-
>
OffsetFirstBlock
(
)
=
=
0
)
;
MOZ_RELEASE_ASSERT
(
chunkA
-
>
OffsetPastLastBlock
(
)
=
=
0
)
;
chunkA
-
>
MarkDone
(
)
;
chunkA
-
>
SetProcessId
(
123
)
;
MOZ_RELEASE_ASSERT
(
chunkA
-
>
ProcessId
(
)
=
=
123
)
;
printf
(
"
TestChunk
done
\
n
"
)
;
}
static
void
TestChunkManagerSingle
(
)
{
printf
(
"
TestChunkManagerSingle
.
.
.
\
n
"
)
;
constexpr
ProfileBufferChunk
:
:
Length
ChunkMinBufferBytes
=
1000
;
ProfileBufferChunkManagerSingle
cms
{
ChunkMinBufferBytes
}
;
ProfileBufferChunkManager
&
cm
=
cms
;
#
ifdef
DEBUG
const
char
*
chunkManagerRegisterer
=
"
TestChunkManagerSingle
"
;
cm
.
RegisteredWith
(
chunkManagerRegisterer
)
;
#
endif
const
auto
maxTotalSize
=
cm
.
MaxTotalSize
(
)
;
MOZ_RELEASE_ASSERT
(
maxTotalSize
>
=
ChunkMinBufferBytes
)
;
cm
.
SetChunkDestroyedCallback
(
[
]
(
const
ProfileBufferChunk
&
)
{
MOZ_RELEASE_ASSERT
(
false
"
ProfileBufferChunkManagerSingle
should
never
destroy
its
one
chunk
"
)
;
}
)
;
UniquePtr
<
ProfileBufferChunk
>
extantReleasedChunks
=
cm
.
GetExtantReleasedChunks
(
)
;
MOZ_RELEASE_ASSERT
(
!
extantReleasedChunks
"
Unexpected
released
chunk
(
s
)
"
)
;
UniquePtr
<
ProfileBufferChunk
>
chunk
=
cm
.
GetChunk
(
)
;
MOZ_RELEASE_ASSERT
(
!
!
chunk
"
First
chunk
request
should
always
work
"
)
;
MOZ_RELEASE_ASSERT
(
chunk
-
>
BufferBytes
(
)
>
=
ChunkMinBufferBytes
"
Unexpected
chunk
size
"
)
;
MOZ_RELEASE_ASSERT
(
!
chunk
-
>
GetNext
(
)
"
There
should
only
be
one
chunk
"
)
;
const
uintptr_t
chunkAddress
=
reinterpret_cast
<
uintptr_t
>
(
chunk
.
get
(
)
)
;
extantReleasedChunks
=
cm
.
GetExtantReleasedChunks
(
)
;
MOZ_RELEASE_ASSERT
(
!
extantReleasedChunks
"
Unexpected
released
chunk
(
s
)
"
)
;
MOZ_RELEASE_ASSERT
(
!
cm
.
GetChunk
(
)
"
Second
chunk
request
should
always
fail
"
)
;
extantReleasedChunks
=
cm
.
GetExtantReleasedChunks
(
)
;
MOZ_RELEASE_ASSERT
(
!
extantReleasedChunks
"
Unexpected
released
chunk
(
s
)
"
)
;
MOZ_RELEASE_ASSERT
(
chunk
-
>
ChunkHeader
(
)
.
mOffsetFirstBlock
=
=
0
)
;
MOZ_RELEASE_ASSERT
(
chunk
-
>
ChunkHeader
(
)
.
mOffsetPastLastBlock
=
=
0
)
;
MOZ_RELEASE_ASSERT
(
chunk
-
>
RangeStart
(
)
=
=
0
)
;
chunk
-
>
SetRangeStart
(
100
)
;
MOZ_RELEASE_ASSERT
(
chunk
-
>
RangeStart
(
)
=
=
100
)
;
Unused
<
<
chunk
-
>
ReserveInitialBlockAsTail
(
1
)
;
Unused
<
<
chunk
-
>
ReserveBlock
(
2
)
;
MOZ_RELEASE_ASSERT
(
chunk
-
>
ChunkHeader
(
)
.
mOffsetFirstBlock
=
=
1
)
;
MOZ_RELEASE_ASSERT
(
chunk
-
>
ChunkHeader
(
)
.
mOffsetPastLastBlock
=
=
1
+
2
)
;
chunk
-
>
MarkDone
(
)
;
cm
.
ReleaseChunks
(
std
:
:
move
(
chunk
)
)
;
MOZ_RELEASE_ASSERT
(
!
chunk
"
chunk
UniquePtr
should
have
been
moved
-
from
"
)
;
MOZ_RELEASE_ASSERT
(
!
cm
.
GetChunk
(
)
"
Chunk
request
after
release
should
also
fail
"
)
;
extantReleasedChunks
=
cm
.
GetExtantReleasedChunks
(
)
;
MOZ_RELEASE_ASSERT
(
!
!
extantReleasedChunks
"
Could
not
retrieve
released
chunk
"
)
;
MOZ_RELEASE_ASSERT
(
!
extantReleasedChunks
-
>
GetNext
(
)
"
There
should
only
be
one
released
chunk
"
)
;
MOZ_RELEASE_ASSERT
(
reinterpret_cast
<
uintptr_t
>
(
extantReleasedChunks
.
get
(
)
)
=
=
chunkAddress
"
Released
chunk
should
be
first
requested
one
"
)
;
MOZ_RELEASE_ASSERT
(
!
cm
.
GetExtantReleasedChunks
(
)
"
Unexpected
extra
released
chunk
(
s
)
"
)
;
MOZ_RELEASE_ASSERT
(
!
cm
.
GetChunk
(
)
"
Chunk
request
after
release
should
also
fail
"
)
;
MOZ_RELEASE_ASSERT
(
cm
.
MaxTotalSize
(
)
=
=
maxTotalSize
"
MaxTotalSize
(
)
should
not
change
after
requests
&
releases
"
)
;
cms
.
Reset
(
std
:
:
move
(
extantReleasedChunks
)
)
;
MOZ_RELEASE_ASSERT
(
!
extantReleasedChunks
"
Released
chunk
UniquePtr
should
have
been
moved
-
from
"
)
;
MOZ_RELEASE_ASSERT
(
cm
.
MaxTotalSize
(
)
=
=
maxTotalSize
"
MaxTotalSize
(
)
should
not
change
when
resetting
with
the
same
chunk
"
)
;
bool
ran
=
false
;
cm
.
RequestChunk
(
[
&
]
(
UniquePtr
<
ProfileBufferChunk
>
aChunk
)
{
ran
=
true
;
MOZ_RELEASE_ASSERT
(
!
!
aChunk
)
;
chunk
=
std
:
:
move
(
aChunk
)
;
}
)
;
MOZ_RELEASE_ASSERT
(
ran
"
RequestChunk
callback
not
called
immediately
"
)
;
ran
=
false
;
cm
.
FulfillChunkRequests
(
)
;
MOZ_RELEASE_ASSERT
(
!
ran
"
FulfillChunkRequests
should
not
have
any
effects
"
)
;
MOZ_RELEASE_ASSERT
(
!
!
chunk
"
First
chunk
request
should
always
work
"
)
;
MOZ_RELEASE_ASSERT
(
chunk
-
>
BufferBytes
(
)
>
=
ChunkMinBufferBytes
"
Unexpected
chunk
size
"
)
;
MOZ_RELEASE_ASSERT
(
!
chunk
-
>
GetNext
(
)
"
There
should
only
be
one
chunk
"
)
;
MOZ_RELEASE_ASSERT
(
reinterpret_cast
<
uintptr_t
>
(
chunk
.
get
(
)
)
=
=
chunkAddress
"
Requested
chunk
should
be
first
requested
one
"
)
;
MOZ_RELEASE_ASSERT
(
chunk
-
>
ChunkHeader
(
)
.
mOffsetFirstBlock
=
=
0
)
;
MOZ_RELEASE_ASSERT
(
chunk
-
>
ChunkHeader
(
)
.
mOffsetPastLastBlock
=
=
0
)
;
MOZ_RELEASE_ASSERT
(
chunk
-
>
RangeStart
(
)
=
=
0
)
;
chunk
-
>
SetRangeStart
(
200
)
;
MOZ_RELEASE_ASSERT
(
chunk
-
>
RangeStart
(
)
=
=
200
)
;
Unused
<
<
chunk
-
>
ReserveInitialBlockAsTail
(
3
)
;
Unused
<
<
chunk
-
>
ReserveBlock
(
4
)
;
MOZ_RELEASE_ASSERT
(
chunk
-
>
ChunkHeader
(
)
.
mOffsetFirstBlock
=
=
3
)
;
MOZ_RELEASE_ASSERT
(
chunk
-
>
ChunkHeader
(
)
.
mOffsetPastLastBlock
=
=
3
+
4
)
;
ran
=
false
;
cm
.
RequestChunk
(
[
&
]
(
UniquePtr
<
ProfileBufferChunk
>
aChunk
)
{
ran
=
true
;
MOZ_RELEASE_ASSERT
(
!
aChunk
"
Second
chunk
request
should
always
fail
"
)
;
}
)
;
MOZ_RELEASE_ASSERT
(
ran
"
RequestChunk
callback
not
called
"
)
;
cm
.
ForgetUnreleasedChunks
(
)
;
chunk
-
>
MarkDone
(
)
;
chunk
=
nullptr
;
chunk
=
ProfileBufferChunk
:
:
Create
(
1
)
;
MOZ_RELEASE_ASSERT
(
!
!
chunk
)
;
auto
tinyChunkSize
=
chunk
-
>
BufferBytes
(
)
;
MOZ_RELEASE_ASSERT
(
tinyChunkSize
>
=
1
)
;
MOZ_RELEASE_ASSERT
(
tinyChunkSize
<
ChunkMinBufferBytes
)
;
MOZ_RELEASE_ASSERT
(
chunk
-
>
RangeStart
(
)
=
=
0
)
;
chunk
-
>
SetRangeStart
(
300
)
;
MOZ_RELEASE_ASSERT
(
chunk
-
>
RangeStart
(
)
=
=
300
)
;
cms
.
Reset
(
std
:
:
move
(
chunk
)
)
;
MOZ_RELEASE_ASSERT
(
!
chunk
"
chunk
UniquePtr
should
have
been
moved
-
from
"
)
;
MOZ_RELEASE_ASSERT
(
cm
.
MaxTotalSize
(
)
=
=
tinyChunkSize
"
MaxTotalSize
(
)
should
match
the
new
chunk
size
"
)
;
chunk
=
cm
.
GetChunk
(
)
;
MOZ_RELEASE_ASSERT
(
chunk
-
>
RangeStart
(
)
=
=
0
"
Got
non
-
recycled
chunk
"
)
;
Unused
<
<
chunk
-
>
ReserveInitialBlockAsTail
(
0
)
;
chunk
-
>
MarkDone
(
)
;
cm
.
ForgetUnreleasedChunks
(
)
;
#
ifdef
DEBUG
cm
.
DeregisteredFrom
(
chunkManagerRegisterer
)
;
#
endif
printf
(
"
TestChunkManagerSingle
done
\
n
"
)
;
}
static
void
TestChunkManagerWithLocalLimit
(
)
{
printf
(
"
TestChunkManagerWithLocalLimit
.
.
.
\
n
"
)
;
constexpr
ProfileBufferChunk
:
:
Length
MaxTotalBytes
=
1000
;
constexpr
ProfileBufferChunk
:
:
Length
ChunkMinBufferBytes
=
100
;
ProfileBufferChunkManagerWithLocalLimit
cmll
{
MaxTotalBytes
ChunkMinBufferBytes
}
;
ProfileBufferChunkManager
&
cm
=
cmll
;
#
ifdef
DEBUG
const
char
*
chunkManagerRegisterer
=
"
TestChunkManagerWithLocalLimit
"
;
cm
.
RegisteredWith
(
chunkManagerRegisterer
)
;
#
endif
MOZ_RELEASE_ASSERT
(
cm
.
MaxTotalSize
(
)
=
=
MaxTotalBytes
"
Max
total
size
should
be
exactly
as
given
"
)
;
unsigned
destroyedChunks
=
0
;
unsigned
destroyedBytes
=
0
;
cm
.
SetChunkDestroyedCallback
(
[
&
]
(
const
ProfileBufferChunk
&
aChunks
)
{
for
(
const
ProfileBufferChunk
*
chunk
=
&
aChunks
;
chunk
;
chunk
=
chunk
-
>
GetNext
(
)
)
{
destroyedChunks
+
=
1
;
destroyedBytes
+
=
chunk
-
>
BufferBytes
(
)
;
}
}
)
;
UniquePtr
<
ProfileBufferChunk
>
extantReleasedChunks
=
cm
.
GetExtantReleasedChunks
(
)
;
MOZ_RELEASE_ASSERT
(
!
extantReleasedChunks
"
Unexpected
released
chunk
(
s
)
"
)
;
UniquePtr
<
ProfileBufferChunk
>
chunk
=
cm
.
GetChunk
(
)
;
MOZ_RELEASE_ASSERT
(
!
!
chunk
"
First
chunk
immediate
request
should
always
work
"
)
;
const
auto
chunkActualBufferBytes
=
chunk
-
>
BufferBytes
(
)
;
MOZ_RELEASE_ASSERT
(
chunkActualBufferBytes
>
=
ChunkMinBufferBytes
"
Unexpected
chunk
size
"
)
;
MOZ_RELEASE_ASSERT
(
!
chunk
-
>
GetNext
(
)
"
There
should
only
be
one
chunk
"
)
;
const
uintptr_t
chunk1Address
=
reinterpret_cast
<
uintptr_t
>
(
chunk
.
get
(
)
)
;
extantReleasedChunks
=
cm
.
GetExtantReleasedChunks
(
)
;
MOZ_RELEASE_ASSERT
(
!
extantReleasedChunks
"
Unexpected
released
chunk
(
s
)
"
)
;
MOZ_RELEASE_ASSERT
(
chunkActualBufferBytes
<
2
*
MaxTotalBytes
)
;
unsigned
chunk1ReuseCount
=
0
;
const
unsigned
Rollovers
=
3
;
const
unsigned
Loops
=
Rollovers
*
MaxTotalBytes
/
chunkActualBufferBytes
;
for
(
unsigned
i
=
0
;
i
<
Loops
;
+
+
i
)
{
MOZ_RELEASE_ASSERT
(
chunk
-
>
ChunkHeader
(
)
.
mOffsetFirstBlock
=
=
0
)
;
MOZ_RELEASE_ASSERT
(
chunk
-
>
ChunkHeader
(
)
.
mOffsetPastLastBlock
=
=
0
)
;
MOZ_RELEASE_ASSERT
(
chunk
-
>
RangeStart
(
)
=
=
0
)
;
const
ProfileBufferIndex
index
=
1
+
i
*
chunkActualBufferBytes
;
chunk
-
>
SetRangeStart
(
index
)
;
MOZ_RELEASE_ASSERT
(
chunk
-
>
RangeStart
(
)
=
=
index
)
;
Unused
<
<
chunk
-
>
ReserveInitialBlockAsTail
(
1
)
;
Unused
<
<
chunk
-
>
ReserveBlock
(
2
)
;
MOZ_RELEASE_ASSERT
(
chunk
-
>
ChunkHeader
(
)
.
mOffsetFirstBlock
=
=
1
)
;
MOZ_RELEASE_ASSERT
(
chunk
-
>
ChunkHeader
(
)
.
mOffsetPastLastBlock
=
=
1
+
2
)
;
bool
ran
=
false
;
UniquePtr
<
ProfileBufferChunk
>
newChunk
;
cm
.
RequestChunk
(
[
&
]
(
UniquePtr
<
ProfileBufferChunk
>
aChunk
)
{
ran
=
true
;
newChunk
=
std
:
:
move
(
aChunk
)
;
}
)
;
MOZ_RELEASE_ASSERT
(
!
ran
"
RequestChunk
should
not
immediately
fulfill
the
request
"
)
;
cm
.
FulfillChunkRequests
(
)
;
MOZ_RELEASE_ASSERT
(
ran
"
FulfillChunkRequests
should
invoke
the
callback
"
)
;
MOZ_RELEASE_ASSERT
(
!
!
newChunk
"
Chunk
request
should
always
work
"
)
;
MOZ_RELEASE_ASSERT
(
newChunk
-
>
BufferBytes
(
)
=
=
chunkActualBufferBytes
"
Unexpected
chunk
size
"
)
;
MOZ_RELEASE_ASSERT
(
!
newChunk
-
>
GetNext
(
)
"
There
should
only
be
one
chunk
"
)
;
chunk
-
>
MarkDone
(
)
;
cm
.
ReleaseChunks
(
std
:
:
move
(
chunk
)
)
;
chunk
=
std
:
:
move
(
newChunk
)
;
if
(
reinterpret_cast
<
uintptr_t
>
(
chunk
.
get
(
)
)
=
=
chunk1Address
)
{
+
+
chunk1ReuseCount
;
}
}
MOZ_RELEASE_ASSERT
(
destroyedChunks
>
=
(
Rollovers
-
1
)
*
MaxTotalBytes
/
chunkActualBufferBytes
"
Not
enough
destroyed
chunks
"
)
;
MOZ_RELEASE_ASSERT
(
destroyedBytes
=
=
destroyedChunks
*
chunkActualBufferBytes
"
Mismatched
destroyed
chunks
and
bytes
"
)
;
MOZ_RELEASE_ASSERT
(
chunk1ReuseCount
>
=
(
Rollovers
-
1
)
"
Not
enough
reuse
of
the
first
chunks
"
)
;
bool
ran
=
false
;
bool
ranInner
=
false
;
UniquePtr
<
ProfileBufferChunk
>
newChunk
;
cm
.
RequestChunk
(
[
&
]
(
UniquePtr
<
ProfileBufferChunk
>
aChunk
)
{
ran
=
true
;
MOZ_RELEASE_ASSERT
(
!
!
aChunk
"
Chunk
request
should
always
work
"
)
;
Unused
<
<
aChunk
-
>
ReserveInitialBlockAsTail
(
0
)
;
aChunk
-
>
MarkDone
(
)
;
UniquePtr
<
ProfileBufferChunk
>
anotherChunk
=
cm
.
GetChunk
(
)
;
MOZ_RELEASE_ASSERT
(
!
!
anotherChunk
)
;
Unused
<
<
anotherChunk
-
>
ReserveInitialBlockAsTail
(
0
)
;
anotherChunk
-
>
MarkDone
(
)
;
cm
.
RequestChunk
(
[
&
]
(
UniquePtr
<
ProfileBufferChunk
>
aChunk
)
{
ranInner
=
true
;
MOZ_RELEASE_ASSERT
(
!
!
aChunk
"
Chunk
request
should
always
work
"
)
;
Unused
<
<
aChunk
-
>
ReserveInitialBlockAsTail
(
0
)
;
aChunk
-
>
MarkDone
(
)
;
}
)
;
MOZ_RELEASE_ASSERT
(
!
ranInner
"
RequestChunk
should
not
immediately
fulfill
the
request
"
)
;
}
)
;
MOZ_RELEASE_ASSERT
(
!
ran
"
RequestChunk
should
not
immediately
fulfill
the
request
"
)
;
MOZ_RELEASE_ASSERT
(
!
ranInner
"
RequestChunk
should
not
immediately
fulfill
the
inner
request
"
)
;
cm
.
FulfillChunkRequests
(
)
;
MOZ_RELEASE_ASSERT
(
ran
"
FulfillChunkRequests
should
invoke
the
callback
"
)
;
MOZ_RELEASE_ASSERT
(
!
ranInner
"
FulfillChunkRequests
should
not
immediately
fulfill
"
"
the
inner
request
"
)
;
cm
.
FulfillChunkRequests
(
)
;
MOZ_RELEASE_ASSERT
(
ran
"
2nd
FulfillChunkRequests
should
invoke
the
inner
request
callback
"
)
;
Unused
<
<
chunk
-
>
ReserveInitialBlockAsTail
(
0
)
;
chunk
-
>
MarkDone
(
)
;
cm
.
ForgetUnreleasedChunks
(
)
;
#
ifdef
DEBUG
cm
.
DeregisteredFrom
(
chunkManagerRegisterer
)
;
#
endif
printf
(
"
TestChunkManagerWithLocalLimit
done
\
n
"
)
;
}
static
bool
IsSameMetadata
(
const
ProfileBufferControlledChunkManager
:
:
ChunkMetadata
&
a1
const
ProfileBufferControlledChunkManager
:
:
ChunkMetadata
&
a2
)
{
return
a1
.
mDoneTimeStamp
=
=
a2
.
mDoneTimeStamp
&
&
a1
.
mBufferBytes
=
=
a2
.
mBufferBytes
;
}
;
static
bool
IsSameUpdate
(
const
ProfileBufferControlledChunkManager
:
:
Update
&
a1
const
ProfileBufferControlledChunkManager
:
:
Update
&
a2
)
{
if
(
a1
.
IsFinal
(
)
|
|
a2
.
IsFinal
(
)
)
{
return
a1
.
IsFinal
(
)
&
&
a2
.
IsFinal
(
)
;
}
if
(
a1
.
IsNotUpdate
(
)
|
|
a2
.
IsNotUpdate
(
)
)
{
return
a1
.
IsNotUpdate
(
)
&
&
a2
.
IsNotUpdate
(
)
;
}
if
(
a1
.
UnreleasedBytes
(
)
!
=
a2
.
UnreleasedBytes
(
)
)
{
return
false
;
}
if
(
a1
.
ReleasedBytes
(
)
!
=
a2
.
ReleasedBytes
(
)
)
{
return
false
;
}
if
(
a1
.
OldestDoneTimeStamp
(
)
!
=
a2
.
OldestDoneTimeStamp
(
)
)
{
return
false
;
}
if
(
a1
.
NewlyReleasedChunksRef
(
)
.
size
(
)
!
=
a2
.
NewlyReleasedChunksRef
(
)
.
size
(
)
)
{
return
false
;
}
for
(
unsigned
i
=
0
;
i
<
a1
.
NewlyReleasedChunksRef
(
)
.
size
(
)
;
+
+
i
)
{
if
(
!
IsSameMetadata
(
a1
.
NewlyReleasedChunksRef
(
)
[
i
]
a2
.
NewlyReleasedChunksRef
(
)
[
i
]
)
)
{
return
false
;
}
}
return
true
;
}
static
void
TestControlledChunkManagerUpdate
(
)
{
printf
(
"
TestControlledChunkManagerUpdate
.
.
.
\
n
"
)
;
using
Update
=
ProfileBufferControlledChunkManager
:
:
Update
;
Update
update1
;
MOZ_RELEASE_ASSERT
(
update1
.
IsNotUpdate
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
update1
.
IsFinal
(
)
)
;
update1
.
Clear
(
)
;
MOZ_RELEASE_ASSERT
(
update1
.
IsNotUpdate
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
update1
.
IsFinal
(
)
)
;
const
Update
final
(
nullptr
)
;
MOZ_RELEASE_ASSERT
(
final
.
IsFinal
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
final
.
IsNotUpdate
(
)
)
;
update1
=
final
;
MOZ_RELEASE_ASSERT
(
update1
.
IsFinal
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
update1
.
IsNotUpdate
(
)
)
;
update1
=
final
;
MOZ_RELEASE_ASSERT
(
update1
.
IsFinal
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
update1
.
IsNotUpdate
(
)
)
;
update1
.
Clear
(
)
;
MOZ_RELEASE_ASSERT
(
update1
.
IsNotUpdate
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
update1
.
IsFinal
(
)
)
;
update1
=
Update
(
nullptr
)
;
MOZ_RELEASE_ASSERT
(
update1
.
IsFinal
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
update1
.
IsNotUpdate
(
)
)
;
update1
=
Update
(
nullptr
)
;
MOZ_RELEASE_ASSERT
(
update1
.
IsFinal
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
update1
.
IsNotUpdate
(
)
)
;
update1
=
Update
(
)
;
MOZ_RELEASE_ASSERT
(
update1
.
IsNotUpdate
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
update1
.
IsFinal
(
)
)
;
auto
CreateBiggerChunkAfter
=
[
]
(
const
ProfileBufferChunk
&
aChunkToBeat
)
{
while
(
TimeStamp
:
:
NowUnfuzzed
(
)
<
=
aChunkToBeat
.
ChunkHeader
(
)
.
mDoneTimeStamp
)
{
:
:
SleepMilli
(
1
)
;
}
auto
chunk
=
ProfileBufferChunk
:
:
Create
(
aChunkToBeat
.
BufferBytes
(
)
*
2
)
;
MOZ_RELEASE_ASSERT
(
!
!
chunk
)
;
MOZ_RELEASE_ASSERT
(
chunk
-
>
BufferBytes
(
)
>
=
aChunkToBeat
.
BufferBytes
(
)
*
2
)
;
Unused
<
<
chunk
-
>
ReserveInitialBlockAsTail
(
0
)
;
chunk
-
>
MarkDone
(
)
;
MOZ_RELEASE_ASSERT
(
chunk
-
>
ChunkHeader
(
)
.
mDoneTimeStamp
>
aChunkToBeat
.
ChunkHeader
(
)
.
mDoneTimeStamp
)
;
return
chunk
;
}
;
update1
=
Update
(
1
2
nullptr
nullptr
)
;
auto
released
=
ProfileBufferChunk
:
:
Create
(
10
)
;
ProfileBufferChunk
*
c1
=
released
.
get
(
)
;
Unused
<
<
c1
-
>
ReserveInitialBlockAsTail
(
0
)
;
c1
-
>
MarkDone
(
)
;
released
-
>
SetLast
(
CreateBiggerChunkAfter
(
*
c1
)
)
;
ProfileBufferChunk
*
c2
=
c1
-
>
GetNext
(
)
;
auto
unreleased
=
CreateBiggerChunkAfter
(
*
c2
)
;
ProfileBufferChunk
*
c3
=
unreleased
.
get
(
)
;
Update
update2
(
c3
-
>
BufferBytes
(
)
c1
-
>
BufferBytes
(
)
+
c2
-
>
BufferBytes
(
)
c1
c1
)
;
MOZ_RELEASE_ASSERT
(
IsSameUpdate
(
update2
Update
(
c3
-
>
BufferBytes
(
)
c1
-
>
BufferBytes
(
)
+
c2
-
>
BufferBytes
(
)
c1
-
>
ChunkHeader
(
)
.
mDoneTimeStamp
{
{
c1
-
>
ChunkHeader
(
)
.
mDoneTimeStamp
c1
-
>
BufferBytes
(
)
}
{
c2
-
>
ChunkHeader
(
)
.
mDoneTimeStamp
c2
-
>
BufferBytes
(
)
}
}
)
)
)
;
MOZ_RELEASE_ASSERT
(
!
update2
.
IsNotUpdate
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
update2
.
IsFinal
(
)
)
;
MOZ_RELEASE_ASSERT
(
update2
.
UnreleasedBytes
(
)
=
=
c3
-
>
BufferBytes
(
)
)
;
MOZ_RELEASE_ASSERT
(
update2
.
ReleasedBytes
(
)
=
=
c1
-
>
BufferBytes
(
)
+
c2
-
>
BufferBytes
(
)
)
;
MOZ_RELEASE_ASSERT
(
update2
.
OldestDoneTimeStamp
(
)
=
=
c1
-
>
ChunkHeader
(
)
.
mDoneTimeStamp
)
;
MOZ_RELEASE_ASSERT
(
update2
.
NewlyReleasedChunksRef
(
)
.
size
(
)
=
=
2
)
;
MOZ_RELEASE_ASSERT
(
IsSameMetadata
(
update2
.
NewlyReleasedChunksRef
(
)
[
0
]
{
c1
-
>
ChunkHeader
(
)
.
mDoneTimeStamp
c1
-
>
BufferBytes
(
)
}
)
)
;
MOZ_RELEASE_ASSERT
(
IsSameMetadata
(
update2
.
NewlyReleasedChunksRef
(
)
[
1
]
{
c2
-
>
ChunkHeader
(
)
.
mDoneTimeStamp
c2
-
>
BufferBytes
(
)
}
)
)
;
update1
.
Fold
(
std
:
:
move
(
update2
)
)
;
MOZ_RELEASE_ASSERT
(
IsSameUpdate
(
update1
Update
(
c3
-
>
BufferBytes
(
)
c1
-
>
BufferBytes
(
)
+
c2
-
>
BufferBytes
(
)
c1
-
>
ChunkHeader
(
)
.
mDoneTimeStamp
{
{
c1
-
>
ChunkHeader
(
)
.
mDoneTimeStamp
c1
-
>
BufferBytes
(
)
}
{
c2
-
>
ChunkHeader
(
)
.
mDoneTimeStamp
c2
-
>
BufferBytes
(
)
}
}
)
)
)
;
update2
=
Update
(
c3
-
>
BufferBytes
(
)
c1
-
>
BufferBytes
(
)
+
c2
-
>
BufferBytes
(
)
c1
nullptr
)
;
MOZ_RELEASE_ASSERT
(
IsSameUpdate
(
update2
Update
(
c3
-
>
BufferBytes
(
)
c1
-
>
BufferBytes
(
)
+
c2
-
>
BufferBytes
(
)
c1
-
>
ChunkHeader
(
)
.
mDoneTimeStamp
{
}
)
)
)
;
update1
.
Fold
(
std
:
:
move
(
update2
)
)
;
MOZ_RELEASE_ASSERT
(
IsSameUpdate
(
update1
Update
(
c3
-
>
BufferBytes
(
)
c1
-
>
BufferBytes
(
)
+
c2
-
>
BufferBytes
(
)
c1
-
>
ChunkHeader
(
)
.
mDoneTimeStamp
{
{
c1
-
>
ChunkHeader
(
)
.
mDoneTimeStamp
c1
-
>
BufferBytes
(
)
}
{
c2
-
>
ChunkHeader
(
)
.
mDoneTimeStamp
c2
-
>
BufferBytes
(
)
}
}
)
)
)
;
c3
-
>
SetLast
(
CreateBiggerChunkAfter
(
*
c3
)
)
;
ProfileBufferChunk
*
c4
=
c3
-
>
GetNext
(
)
;
update2
=
Update
(
c3
-
>
BufferBytes
(
)
+
c4
-
>
BufferBytes
(
)
c1
-
>
BufferBytes
(
)
+
c2
-
>
BufferBytes
(
)
c1
nullptr
)
;
MOZ_RELEASE_ASSERT
(
IsSameUpdate
(
update2
Update
(
c3
-
>
BufferBytes
(
)
+
c4
-
>
BufferBytes
(
)
c1
-
>
BufferBytes
(
)
+
c2
-
>
BufferBytes
(
)
c1
-
>
ChunkHeader
(
)
.
mDoneTimeStamp
{
}
)
)
)
;
update1
.
Fold
(
std
:
:
move
(
update2
)
)
;
MOZ_RELEASE_ASSERT
(
IsSameUpdate
(
update1
Update
(
c3
-
>
BufferBytes
(
)
+
c4
-
>
BufferBytes
(
)
c1
-
>
BufferBytes
(
)
+
c2
-
>
BufferBytes
(
)
c1
-
>
ChunkHeader
(
)
.
mDoneTimeStamp
{
{
c1
-
>
ChunkHeader
(
)
.
mDoneTimeStamp
c1
-
>
BufferBytes
(
)
}
{
c2
-
>
ChunkHeader
(
)
.
mDoneTimeStamp
c2
-
>
BufferBytes
(
)
}
}
)
)
)
;
released
-
>
SetLast
(
std
:
:
exchange
(
unreleased
unreleased
-
>
ReleaseNext
(
)
)
)
;
update2
=
Update
(
c4
-
>
BufferBytes
(
)
c1
-
>
BufferBytes
(
)
+
c2
-
>
BufferBytes
(
)
+
c3
-
>
BufferBytes
(
)
c1
c3
)
;
MOZ_RELEASE_ASSERT
(
IsSameUpdate
(
update2
Update
(
c4
-
>
BufferBytes
(
)
c1
-
>
BufferBytes
(
)
+
c2
-
>
BufferBytes
(
)
+
c3
-
>
BufferBytes
(
)
c1
-
>
ChunkHeader
(
)
.
mDoneTimeStamp
{
{
c3
-
>
ChunkHeader
(
)
.
mDoneTimeStamp
c3
-
>
BufferBytes
(
)
}
}
)
)
)
;
update1
.
Fold
(
std
:
:
move
(
update2
)
)
;
MOZ_RELEASE_ASSERT
(
IsSameUpdate
(
update1
Update
(
c4
-
>
BufferBytes
(
)
c1
-
>
BufferBytes
(
)
+
c2
-
>
BufferBytes
(
)
+
c3
-
>
BufferBytes
(
)
c1
-
>
ChunkHeader
(
)
.
mDoneTimeStamp
{
{
c1
-
>
ChunkHeader
(
)
.
mDoneTimeStamp
c1
-
>
BufferBytes
(
)
}
{
c2
-
>
ChunkHeader
(
)
.
mDoneTimeStamp
c2
-
>
BufferBytes
(
)
}
{
c3
-
>
ChunkHeader
(
)
.
mDoneTimeStamp
c3
-
>
BufferBytes
(
)
}
}
)
)
)
;
released
=
released
-
>
ReleaseNext
(
)
;
c1
=
nullptr
;
update2
=
Update
(
c4
-
>
BufferBytes
(
)
c2
-
>
BufferBytes
(
)
+
c3
-
>
BufferBytes
(
)
c2
nullptr
)
;
MOZ_RELEASE_ASSERT
(
IsSameUpdate
(
update2
Update
(
c4
-
>
BufferBytes
(
)
c2
-
>
BufferBytes
(
)
+
c3
-
>
BufferBytes
(
)
c2
-
>
ChunkHeader
(
)
.
mDoneTimeStamp
{
}
)
)
)
;
update1
.
Fold
(
std
:
:
move
(
update2
)
)
;
MOZ_RELEASE_ASSERT
(
IsSameUpdate
(
update1
Update
(
c4
-
>
BufferBytes
(
)
c2
-
>
BufferBytes
(
)
+
c3
-
>
BufferBytes
(
)
c2
-
>
ChunkHeader
(
)
.
mDoneTimeStamp
{
{
c2
-
>
ChunkHeader
(
)
.
mDoneTimeStamp
c2
-
>
BufferBytes
(
)
}
{
c3
-
>
ChunkHeader
(
)
.
mDoneTimeStamp
c3
-
>
BufferBytes
(
)
}
}
)
)
)
;
auto
recycled
=
std
:
:
exchange
(
released
released
-
>
ReleaseNext
(
)
)
;
recycled
-
>
MarkRecycled
(
)
;
Unused
<
<
recycled
-
>
ReserveInitialBlockAsTail
(
0
)
;
recycled
-
>
MarkDone
(
)
;
released
-
>
SetLast
(
std
:
:
move
(
unreleased
)
)
;
unreleased
=
std
:
:
move
(
recycled
)
;
ProfileBufferChunk
*
c5
=
c2
;
c2
=
nullptr
;
update2
=
Update
(
c5
-
>
BufferBytes
(
)
c3
-
>
BufferBytes
(
)
+
c4
-
>
BufferBytes
(
)
c3
c4
)
;
MOZ_RELEASE_ASSERT
(
IsSameUpdate
(
update2
Update
(
c5
-
>
BufferBytes
(
)
c3
-
>
BufferBytes
(
)
+
c4
-
>
BufferBytes
(
)
c3
-
>
ChunkHeader
(
)
.
mDoneTimeStamp
{
{
c4
-
>
ChunkHeader
(
)
.
mDoneTimeStamp
c4
-
>
BufferBytes
(
)
}
}
)
)
)
;
update1
.
Fold
(
std
:
:
move
(
update2
)
)
;
MOZ_RELEASE_ASSERT
(
IsSameUpdate
(
update1
Update
(
c5
-
>
BufferBytes
(
)
c3
-
>
BufferBytes
(
)
+
c4
-
>
BufferBytes
(
)
c3
-
>
ChunkHeader
(
)
.
mDoneTimeStamp
{
{
c3
-
>
ChunkHeader
(
)
.
mDoneTimeStamp
c3
-
>
BufferBytes
(
)
}
{
c4
-
>
ChunkHeader
(
)
.
mDoneTimeStamp
c4
-
>
BufferBytes
(
)
}
}
)
)
)
;
update1
.
Fold
(
Update
(
nullptr
)
)
;
MOZ_RELEASE_ASSERT
(
update1
.
IsFinal
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
update1
.
IsNotUpdate
(
)
)
;
printf
(
"
TestControlledChunkManagerUpdate
done
\
n
"
)
;
}
static
void
TestControlledChunkManagerWithLocalLimit
(
)
{
printf
(
"
TestControlledChunkManagerWithLocalLimit
.
.
.
\
n
"
)
;
constexpr
ProfileBufferChunk
:
:
Length
MaxTotalBytes
=
1000
;
constexpr
ProfileBufferChunk
:
:
Length
ChunkMinBufferBytes
=
100
;
ProfileBufferChunkManagerWithLocalLimit
cmll
{
MaxTotalBytes
ChunkMinBufferBytes
}
;
ProfileBufferChunkManager
&
cm
=
cmll
;
ProfileBufferControlledChunkManager
&
ccm
=
cmll
;
#
ifdef
DEBUG
const
char
*
chunkManagerRegisterer
=
"
TestControlledChunkManagerWithLocalLimit
"
;
cm
.
RegisteredWith
(
chunkManagerRegisterer
)
;
#
endif
MOZ_RELEASE_ASSERT
(
cm
.
MaxTotalSize
(
)
=
=
MaxTotalBytes
"
Max
total
size
should
be
exactly
as
given
"
)
;
unsigned
destroyedChunks
=
0
;
unsigned
destroyedBytes
=
0
;
cm
.
SetChunkDestroyedCallback
(
[
&
]
(
const
ProfileBufferChunk
&
aChunks
)
{
for
(
const
ProfileBufferChunk
*
chunk
=
&
aChunks
;
chunk
;
chunk
=
chunk
-
>
GetNext
(
)
)
{
destroyedChunks
+
=
1
;
destroyedBytes
+
=
chunk
-
>
BufferBytes
(
)
;
}
}
)
;
using
Update
=
ProfileBufferControlledChunkManager
:
:
Update
;
unsigned
updateCount
=
0
;
ProfileBufferControlledChunkManager
:
:
Update
update
;
MOZ_RELEASE_ASSERT
(
update
.
IsNotUpdate
(
)
)
;
auto
updateCallback
=
[
&
]
(
Update
&
&
aUpdate
)
{
+
+
updateCount
;
update
.
Fold
(
std
:
:
move
(
aUpdate
)
)
;
}
;
ccm
.
SetUpdateCallback
(
updateCallback
)
;
MOZ_RELEASE_ASSERT
(
updateCount
=
=
1
"
SetUpdateCallback
should
have
triggered
an
update
"
)
;
MOZ_RELEASE_ASSERT
(
IsSameUpdate
(
update
Update
(
0
0
TimeStamp
{
}
{
}
)
)
)
;
updateCount
=
0
;
update
.
Clear
(
)
;
UniquePtr
<
ProfileBufferChunk
>
extantReleasedChunks
=
cm
.
GetExtantReleasedChunks
(
)
;
MOZ_RELEASE_ASSERT
(
!
extantReleasedChunks
"
Unexpected
released
chunk
(
s
)
"
)
;
MOZ_RELEASE_ASSERT
(
updateCount
=
=
1
"
GetExtantReleasedChunks
should
have
triggered
an
update
"
)
;
MOZ_RELEASE_ASSERT
(
IsSameUpdate
(
update
Update
(
0
0
TimeStamp
{
}
{
}
)
)
)
;
updateCount
=
0
;
update
.
Clear
(
)
;
UniquePtr
<
ProfileBufferChunk
>
chunk
=
cm
.
GetChunk
(
)
;
MOZ_RELEASE_ASSERT
(
!
!
chunk
"
First
chunk
immediate
request
should
always
work
"
)
;
const
auto
chunkActualBufferBytes
=
chunk
-
>
BufferBytes
(
)
;
const
uintptr_t
chunk1Address
=
reinterpret_cast
<
uintptr_t
>
(
chunk
.
get
(
)
)
;
MOZ_RELEASE_ASSERT
(
updateCount
=
=
1
"
GetChunk
should
have
triggered
an
update
"
)
;
MOZ_RELEASE_ASSERT
(
IsSameUpdate
(
update
Update
(
chunk
-
>
BufferBytes
(
)
0
TimeStamp
{
}
{
}
)
)
)
;
updateCount
=
0
;
update
.
Clear
(
)
;
extantReleasedChunks
=
cm
.
GetExtantReleasedChunks
(
)
;
MOZ_RELEASE_ASSERT
(
!
extantReleasedChunks
"
Unexpected
released
chunk
(
s
)
"
)
;
MOZ_RELEASE_ASSERT
(
updateCount
=
=
1
"
GetExtantReleasedChunks
should
have
triggered
an
update
"
)
;
MOZ_RELEASE_ASSERT
(
IsSameUpdate
(
update
Update
(
chunk
-
>
BufferBytes
(
)
0
TimeStamp
{
}
{
}
)
)
)
;
updateCount
=
0
;
update
.
Clear
(
)
;
MOZ_RELEASE_ASSERT
(
chunkActualBufferBytes
<
2
*
MaxTotalBytes
)
;
ProfileBufferChunk
:
:
Length
previousUnreleasedBytes
=
chunk
-
>
BufferBytes
(
)
;
ProfileBufferChunk
:
:
Length
previousReleasedBytes
=
0
;
TimeStamp
previousOldestDoneTimeStamp
;
unsigned
chunk1ReuseCount
=
0
;
const
unsigned
Rollovers
=
3
;
const
unsigned
Loops
=
Rollovers
*
MaxTotalBytes
/
chunkActualBufferBytes
;
for
(
unsigned
i
=
0
;
i
<
Loops
;
+
+
i
)
{
const
ProfileBufferIndex
index
=
ProfileBufferIndex
(
chunkActualBufferBytes
)
*
i
+
1
;
chunk
-
>
SetRangeStart
(
index
)
;
Unused
<
<
chunk
-
>
ReserveInitialBlockAsTail
(
1
)
;
Unused
<
<
chunk
-
>
ReserveBlock
(
2
)
;
UniquePtr
<
ProfileBufferChunk
>
newChunk
;
cm
.
RequestChunk
(
[
&
]
(
UniquePtr
<
ProfileBufferChunk
>
aChunk
)
{
newChunk
=
std
:
:
move
(
aChunk
)
;
}
)
;
MOZ_RELEASE_ASSERT
(
updateCount
=
=
0
"
RequestChunk
(
)
shouldn
'
t
have
triggered
an
update
"
)
;
cm
.
FulfillChunkRequests
(
)
;
MOZ_RELEASE_ASSERT
(
!
!
newChunk
"
Chunk
request
should
always
work
"
)
;
MOZ_RELEASE_ASSERT
(
newChunk
-
>
BufferBytes
(
)
=
=
chunkActualBufferBytes
"
Unexpected
chunk
size
"
)
;
MOZ_RELEASE_ASSERT
(
!
newChunk
-
>
GetNext
(
)
"
There
should
only
be
one
chunk
"
)
;
MOZ_RELEASE_ASSERT
(
updateCount
=
=
1
"
FulfillChunkRequests
(
)
after
a
request
should
have
"
"
triggered
an
update
"
)
;
MOZ_RELEASE_ASSERT
(
!
update
.
IsFinal
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
update
.
IsNotUpdate
(
)
)
;
MOZ_RELEASE_ASSERT
(
update
.
UnreleasedBytes
(
)
=
=
previousUnreleasedBytes
+
newChunk
-
>
BufferBytes
(
)
)
;
previousUnreleasedBytes
=
update
.
UnreleasedBytes
(
)
;
MOZ_RELEASE_ASSERT
(
update
.
ReleasedBytes
(
)
<
=
previousReleasedBytes
)
;
previousReleasedBytes
=
update
.
ReleasedBytes
(
)
;
MOZ_RELEASE_ASSERT
(
previousOldestDoneTimeStamp
.
IsNull
(
)
|
|
update
.
OldestDoneTimeStamp
(
)
>
=
previousOldestDoneTimeStamp
)
;
previousOldestDoneTimeStamp
=
update
.
OldestDoneTimeStamp
(
)
;
MOZ_RELEASE_ASSERT
(
update
.
NewlyReleasedChunksRef
(
)
.
empty
(
)
)
;
updateCount
=
0
;
update
.
Clear
(
)
;
const
TimeStamp
now
=
TimeStamp
:
:
NowUnfuzzed
(
)
;
while
(
TimeStamp
:
:
NowUnfuzzed
(
)
=
=
now
)
{
:
:
SleepMilli
(
1
)
;
}
chunk
-
>
MarkDone
(
)
;
const
auto
doneTimeStamp
=
chunk
-
>
ChunkHeader
(
)
.
mDoneTimeStamp
;
const
auto
bufferBytes
=
chunk
-
>
BufferBytes
(
)
;
cm
.
ReleaseChunks
(
std
:
:
move
(
chunk
)
)
;
MOZ_RELEASE_ASSERT
(
updateCount
=
=
1
"
ReleaseChunks
(
)
should
have
triggered
an
update
"
)
;
MOZ_RELEASE_ASSERT
(
!
update
.
IsFinal
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
update
.
IsNotUpdate
(
)
)
;
MOZ_RELEASE_ASSERT
(
update
.
UnreleasedBytes
(
)
=
=
previousUnreleasedBytes
-
bufferBytes
)
;
previousUnreleasedBytes
=
update
.
UnreleasedBytes
(
)
;
MOZ_RELEASE_ASSERT
(
update
.
ReleasedBytes
(
)
=
=
previousReleasedBytes
+
bufferBytes
)
;
previousReleasedBytes
=
update
.
ReleasedBytes
(
)
;
MOZ_RELEASE_ASSERT
(
previousOldestDoneTimeStamp
.
IsNull
(
)
|
|
update
.
OldestDoneTimeStamp
(
)
>
=
previousOldestDoneTimeStamp
)
;
previousOldestDoneTimeStamp
=
update
.
OldestDoneTimeStamp
(
)
;
MOZ_RELEASE_ASSERT
(
update
.
OldestDoneTimeStamp
(
)
<
=
doneTimeStamp
)
;
MOZ_RELEASE_ASSERT
(
update
.
NewlyReleasedChunksRef
(
)
.
size
(
)
=
=
1
)
;
MOZ_RELEASE_ASSERT
(
update
.
NewlyReleasedChunksRef
(
)
[
0
]
.
mDoneTimeStamp
=
=
doneTimeStamp
)
;
MOZ_RELEASE_ASSERT
(
update
.
NewlyReleasedChunksRef
(
)
[
0
]
.
mBufferBytes
=
=
bufferBytes
)
;
updateCount
=
0
;
update
.
Clear
(
)
;
chunk
=
std
:
:
move
(
newChunk
)
;
if
(
reinterpret_cast
<
uintptr_t
>
(
chunk
.
get
(
)
)
=
=
chunk1Address
)
{
+
+
chunk1ReuseCount
;
}
}
Unused
<
<
chunk
-
>
ReserveInitialBlockAsTail
(
0
)
;
chunk
-
>
MarkDone
(
)
;
cm
.
ForgetUnreleasedChunks
(
)
;
MOZ_RELEASE_ASSERT
(
updateCount
=
=
1
"
ForgetUnreleasedChunks
(
)
should
have
triggered
an
update
"
)
;
MOZ_RELEASE_ASSERT
(
!
update
.
IsFinal
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
update
.
IsNotUpdate
(
)
)
;
MOZ_RELEASE_ASSERT
(
update
.
UnreleasedBytes
(
)
=
=
0
)
;
MOZ_RELEASE_ASSERT
(
update
.
ReleasedBytes
(
)
=
=
previousReleasedBytes
)
;
MOZ_RELEASE_ASSERT
(
update
.
NewlyReleasedChunksRef
(
)
.
empty
(
)
=
=
1
)
;
updateCount
=
0
;
update
.
Clear
(
)
;
ccm
.
SetUpdateCallback
(
{
}
)
;
MOZ_RELEASE_ASSERT
(
updateCount
=
=
1
"
SetUpdateCallback
(
{
}
)
should
have
triggered
an
update
"
)
;
MOZ_RELEASE_ASSERT
(
update
.
IsFinal
(
)
)
;
#
ifdef
DEBUG
cm
.
DeregisteredFrom
(
chunkManagerRegisterer
)
;
#
endif
printf
(
"
TestControlledChunkManagerWithLocalLimit
done
\
n
"
)
;
}
static
void
TestChunkedBuffer
(
)
{
printf
(
"
TestChunkedBuffer
.
.
.
\
n
"
)
;
ProfileBufferBlockIndex
blockIndex
;
MOZ_RELEASE_ASSERT
(
!
blockIndex
)
;
MOZ_RELEASE_ASSERT
(
blockIndex
=
=
nullptr
)
;
ProfileChunkedBuffer
cb
(
ProfileChunkedBuffer
:
:
ThreadSafety
:
:
WithMutex
)
;
MOZ_RELEASE_ASSERT
(
cb
.
BufferLength
(
)
.
isNothing
(
)
)
;
int
result
=
0
;
result
=
cb
.
ReserveAndPut
(
[
]
(
)
{
MOZ_RELEASE_ASSERT
(
false
)
;
return
1
;
}
[
]
(
Maybe
<
ProfileBufferEntryWriter
>
&
aEW
)
{
return
aEW
?
2
:
3
;
}
)
;
MOZ_RELEASE_ASSERT
(
result
=
=
3
)
;
result
=
0
;
result
=
cb
.
Put
(
1
[
]
(
Maybe
<
ProfileBufferEntryWriter
>
&
aEW
)
{
return
aEW
?
1
:
2
;
}
)
;
MOZ_RELEASE_ASSERT
(
result
=
=
2
)
;
blockIndex
=
cb
.
PutFrom
(
&
result
1
)
;
MOZ_RELEASE_ASSERT
(
!
blockIndex
)
;
blockIndex
=
cb
.
PutObjects
(
123
result
"
hello
"
)
;
MOZ_RELEASE_ASSERT
(
!
blockIndex
)
;
blockIndex
=
cb
.
PutObject
(
123
)
;
MOZ_RELEASE_ASSERT
(
!
blockIndex
)
;
auto
chunks
=
cb
.
GetAllChunks
(
)
;
static_assert
(
std
:
:
is_same_v
<
decltype
(
chunks
)
UniquePtr
<
ProfileBufferChunk
>
>
"
ProfileChunkedBuffer
:
:
GetAllChunks
(
)
should
return
a
"
"
UniquePtr
<
ProfileBufferChunk
>
"
)
;
MOZ_RELEASE_ASSERT
(
!
chunks
"
Expected
no
chunks
when
out
-
of
-
session
"
)
;
bool
ran
=
false
;
result
=
0
;
result
=
cb
.
Read
(
[
&
]
(
ProfileChunkedBuffer
:
:
Reader
*
aReader
)
{
ran
=
true
;
MOZ_RELEASE_ASSERT
(
!
aReader
)
;
return
3
;
}
)
;
MOZ_RELEASE_ASSERT
(
ran
)
;
MOZ_RELEASE_ASSERT
(
result
=
=
3
)
;
cb
.
ReadEach
(
[
]
(
ProfileBufferEntryReader
&
)
{
MOZ_RELEASE_ASSERT
(
false
)
;
}
)
;
result
=
0
;
result
=
cb
.
ReadAt
(
nullptr
[
]
(
Maybe
<
ProfileBufferEntryReader
>
&
&
er
)
{
MOZ_RELEASE_ASSERT
(
er
.
isNothing
(
)
)
;
return
4
;
}
)
;
MOZ_RELEASE_ASSERT
(
result
=
=
4
)
;
constexpr
size_t
bufferMaxSize
=
1024
;
constexpr
ProfileChunkedBuffer
:
:
Length
chunkMinSize
=
128
;
ProfileBufferChunkManagerWithLocalLimit
cm
(
bufferMaxSize
chunkMinSize
)
;
cb
.
SetChunkManager
(
cm
)
;
cm
.
FulfillChunkRequests
(
)
;
MOZ_RELEASE_ASSERT
(
cm
.
MaxTotalSize
(
)
=
=
bufferMaxSize
)
;
MOZ_RELEASE_ASSERT
(
cb
.
BufferLength
(
)
.
isSome
(
)
)
;
MOZ_RELEASE_ASSERT
(
*
cb
.
BufferLength
(
)
=
=
bufferMaxSize
)
;
const
int
test
=
123
;
ran
=
false
;
blockIndex
=
nullptr
;
bool
success
=
cb
.
ReserveAndPut
(
[
]
(
)
{
return
sizeof
(
test
)
;
}
[
&
]
(
Maybe
<
ProfileBufferEntryWriter
>
&
aEW
)
{
ran
=
true
;
if
(
!
aEW
)
{
return
false
;
}
blockIndex
=
aEW
-
>
CurrentBlockIndex
(
)
;
MOZ_RELEASE_ASSERT
(
aEW
-
>
RemainingBytes
(
)
=
=
sizeof
(
test
)
)
;
aEW
-
>
WriteObject
(
test
)
;
MOZ_RELEASE_ASSERT
(
aEW
-
>
RemainingBytes
(
)
=
=
0
)
;
return
true
;
}
)
;
MOZ_RELEASE_ASSERT
(
ran
)
;
MOZ_RELEASE_ASSERT
(
success
)
;
MOZ_RELEASE_ASSERT
(
blockIndex
.
ConvertToProfileBufferIndex
(
)
=
=
1
)
;
ran
=
false
;
result
=
0
;
result
=
cb
.
Read
(
[
&
]
(
ProfileChunkedBuffer
:
:
Reader
*
aReader
)
{
ran
=
true
;
MOZ_RELEASE_ASSERT
(
!
!
aReader
)
;
MOZ_RELEASE_ASSERT
(
aReader
-
>
begin
(
)
.
CurrentBlockIndex
(
)
.
ConvertToProfileBufferIndex
(
)
=
=
1
)
;
MOZ_RELEASE_ASSERT
(
aReader
-
>
end
(
)
.
CurrentBlockIndex
(
)
.
ConvertToProfileBufferIndex
(
)
=
=
0
)
;
MOZ_RELEASE_ASSERT
(
aReader
-
>
At
(
nullptr
)
=
=
aReader
-
>
begin
(
)
)
;
MOZ_RELEASE_ASSERT
(
aReader
-
>
At
(
blockIndex
)
=
=
aReader
-
>
begin
(
)
)
;
MOZ_RELEASE_ASSERT
(
aReader
-
>
At
(
aReader
-
>
begin
(
)
.
CurrentBlockIndex
(
)
)
=
=
aReader
-
>
begin
(
)
)
;
MOZ_RELEASE_ASSERT
(
aReader
-
>
At
(
ProfileBufferBlockIndex
:
:
CreateFromProfileBufferIndex
(
1
+
1
+
sizeof
(
test
)
)
)
=
=
aReader
-
>
end
(
)
)
;
size_t
read
=
0
;
aReader
-
>
ForEach
(
[
&
]
(
ProfileBufferEntryReader
&
er
)
{
+
+
read
;
MOZ_RELEASE_ASSERT
(
er
.
RemainingBytes
(
)
=
=
sizeof
(
test
)
)
;
const
auto
value
=
er
.
ReadObject
<
decltype
(
test
)
>
(
)
;
MOZ_RELEASE_ASSERT
(
value
=
=
test
)
;
MOZ_RELEASE_ASSERT
(
er
.
RemainingBytes
(
)
=
=
0
)
;
}
)
;
MOZ_RELEASE_ASSERT
(
read
=
=
1
)
;
read
=
0
;
for
(
auto
er
:
*
aReader
)
{
static_assert
(
std
:
:
is_same_v
<
decltype
(
er
)
ProfileBufferEntryReader
>
"
ProfileChunkedBuffer
:
:
Reader
range
-
for
should
produce
"
"
ProfileBufferEntryReader
objects
"
)
;
+
+
read
;
MOZ_RELEASE_ASSERT
(
er
.
RemainingBytes
(
)
=
=
sizeof
(
test
)
)
;
const
auto
value
=
er
.
ReadObject
<
decltype
(
test
)
>
(
)
;
MOZ_RELEASE_ASSERT
(
value
=
=
test
)
;
MOZ_RELEASE_ASSERT
(
er
.
RemainingBytes
(
)
=
=
0
)
;
}
;
MOZ_RELEASE_ASSERT
(
read
=
=
1
)
;
return
5
;
}
)
;
MOZ_RELEASE_ASSERT
(
ran
)
;
MOZ_RELEASE_ASSERT
(
result
=
=
5
)
;
size_t
read
=
0
;
cb
.
ReadEach
(
[
&
]
(
ProfileBufferEntryReader
&
er
)
{
+
+
read
;
MOZ_RELEASE_ASSERT
(
er
.
RemainingBytes
(
)
=
=
sizeof
(
test
)
)
;
const
auto
value
=
er
.
ReadObject
<
decltype
(
test
)
>
(
)
;
MOZ_RELEASE_ASSERT
(
value
=
=
test
)
;
MOZ_RELEASE_ASSERT
(
er
.
RemainingBytes
(
)
=
=
0
)
;
}
)
;
MOZ_RELEASE_ASSERT
(
read
=
=
1
)
;
read
=
0
;
blockIndex
=
nullptr
;
cb
.
ReadEach
(
[
&
]
(
ProfileBufferEntryReader
&
er
ProfileBufferBlockIndex
aBlockIndex
)
{
+
+
read
;
MOZ_RELEASE_ASSERT
(
!
!
aBlockIndex
)
;
MOZ_RELEASE_ASSERT
(
!
blockIndex
)
;
blockIndex
=
aBlockIndex
;
MOZ_RELEASE_ASSERT
(
er
.
RemainingBytes
(
)
=
=
sizeof
(
test
)
)
;
const
auto
value
=
er
.
ReadObject
<
decltype
(
test
)
>
(
)
;
MOZ_RELEASE_ASSERT
(
value
=
=
test
)
;
MOZ_RELEASE_ASSERT
(
er
.
RemainingBytes
(
)
=
=
0
)
;
}
)
;
MOZ_RELEASE_ASSERT
(
read
=
=
1
)
;
MOZ_RELEASE_ASSERT
(
!
!
blockIndex
)
;
MOZ_RELEASE_ASSERT
(
blockIndex
!
=
nullptr
)
;
read
=
0
;
result
=
0
;
result
=
cb
.
ReadAt
(
blockIndex
[
&
]
(
Maybe
<
ProfileBufferEntryReader
>
&
&
er
)
{
+
+
read
;
MOZ_RELEASE_ASSERT
(
er
.
isSome
(
)
)
;
MOZ_RELEASE_ASSERT
(
er
-
>
CurrentBlockIndex
(
)
=
=
blockIndex
)
;
MOZ_RELEASE_ASSERT
(
!
er
-
>
NextBlockIndex
(
)
)
;
MOZ_RELEASE_ASSERT
(
er
-
>
RemainingBytes
(
)
=
=
sizeof
(
test
)
)
;
const
auto
value
=
er
-
>
ReadObject
<
decltype
(
test
)
>
(
)
;
MOZ_RELEASE_ASSERT
(
value
=
=
test
)
;
MOZ_RELEASE_ASSERT
(
er
-
>
RemainingBytes
(
)
=
=
0
)
;
return
6
;
}
)
;
MOZ_RELEASE_ASSERT
(
result
=
=
6
)
;
MOZ_RELEASE_ASSERT
(
read
=
=
1
)
;
chunks
=
cb
.
GetAllChunks
(
)
;
MOZ_RELEASE_ASSERT
(
!
!
chunks
"
Expected
at
least
one
chunk
"
)
;
MOZ_RELEASE_ASSERT
(
!
!
chunks
-
>
GetNext
(
)
"
Expected
two
chunks
"
)
;
MOZ_RELEASE_ASSERT
(
!
chunks
-
>
GetNext
(
)
-
>
GetNext
(
)
"
Expected
only
two
chunks
"
)
;
const
ProfileChunkedBuffer
:
:
Length
chunkActualSize
=
chunks
-
>
BufferBytes
(
)
;
MOZ_RELEASE_ASSERT
(
chunkActualSize
>
=
chunkMinSize
)
;
MOZ_RELEASE_ASSERT
(
chunks
-
>
RangeStart
(
)
=
=
1
)
;
MOZ_RELEASE_ASSERT
(
chunks
-
>
OffsetFirstBlock
(
)
=
=
0
)
;
MOZ_RELEASE_ASSERT
(
chunks
-
>
OffsetPastLastBlock
(
)
=
=
1
+
sizeof
(
test
)
)
;
cb
.
ReadEach
(
[
]
(
ProfileBufferEntryReader
&
)
{
MOZ_RELEASE_ASSERT
(
false
)
;
}
)
;
cb
.
ReadEach
(
[
]
(
ProfileBufferEntryReader
&
ProfileBufferBlockIndex
)
{
MOZ_RELEASE_ASSERT
(
false
)
;
}
)
;
result
=
0
;
result
=
cb
.
ReadAt
(
nullptr
[
]
(
Maybe
<
ProfileBufferEntryReader
>
&
&
er
)
{
MOZ_RELEASE_ASSERT
(
er
.
isNothing
(
)
)
;
return
7
;
}
)
;
MOZ_RELEASE_ASSERT
(
result
=
=
7
)
;
read
=
0
;
ProfileChunkedBuffer
:
:
ReadEach
(
chunks
.
get
(
)
nullptr
[
&
]
(
ProfileBufferEntryReader
&
er
ProfileBufferBlockIndex
aBlockIndex
)
{
+
+
read
;
MOZ_RELEASE_ASSERT
(
aBlockIndex
=
=
blockIndex
)
;
MOZ_RELEASE_ASSERT
(
er
.
RemainingBytes
(
)
=
=
sizeof
(
test
)
)
;
const
auto
value
=
er
.
ReadObject
<
decltype
(
test
)
>
(
)
;
MOZ_RELEASE_ASSERT
(
value
=
=
test
)
;
MOZ_RELEASE_ASSERT
(
er
.
RemainingBytes
(
)
=
=
0
)
;
}
)
;
MOZ_RELEASE_ASSERT
(
read
=
=
1
)
;
ProfileBufferBlockIndex
firstBlockIndex
;
MOZ_RELEASE_ASSERT
(
!
firstBlockIndex
)
;
ProfileBufferBlockIndex
lastBlockIndex
;
MOZ_RELEASE_ASSERT
(
!
lastBlockIndex
)
;
const
size_t
lots
=
2
*
bufferMaxSize
/
(
1
+
sizeof
(
int
)
)
;
for
(
size_t
i
=
1
;
i
<
lots
;
+
+
i
)
{
ProfileBufferBlockIndex
blockIndex
=
cb
.
PutFrom
(
&
i
sizeof
(
i
)
)
;
MOZ_RELEASE_ASSERT
(
!
!
blockIndex
)
;
MOZ_RELEASE_ASSERT
(
blockIndex
>
firstBlockIndex
)
;
if
(
!
firstBlockIndex
)
{
firstBlockIndex
=
blockIndex
;
}
MOZ_RELEASE_ASSERT
(
blockIndex
>
lastBlockIndex
)
;
lastBlockIndex
=
blockIndex
;
}
read
=
0
;
size_t
i
=
0
;
cb
.
ReadEach
(
[
&
]
(
ProfileBufferEntryReader
&
er
ProfileBufferBlockIndex
aBlockIndex
)
{
+
+
read
;
MOZ_RELEASE_ASSERT
(
!
!
aBlockIndex
)
;
MOZ_RELEASE_ASSERT
(
aBlockIndex
>
firstBlockIndex
)
;
MOZ_RELEASE_ASSERT
(
aBlockIndex
<
=
lastBlockIndex
)
;
MOZ_RELEASE_ASSERT
(
er
.
RemainingBytes
(
)
=
=
sizeof
(
size_t
)
)
;
const
auto
value
=
er
.
ReadObject
<
size_t
>
(
)
;
if
(
i
=
=
0
)
{
i
=
value
;
}
else
{
MOZ_RELEASE_ASSERT
(
value
=
=
+
+
i
)
;
}
MOZ_RELEASE_ASSERT
(
er
.
RemainingBytes
(
)
=
=
0
)
;
}
)
;
MOZ_RELEASE_ASSERT
(
read
!
=
0
)
;
MOZ_RELEASE_ASSERT
(
read
<
lots
)
;
read
=
0
;
i
=
0
;
blockIndex
=
nullptr
;
success
=
cb
.
ReadAt
(
firstBlockIndex
[
&
]
(
Maybe
<
ProfileBufferEntryReader
>
&
&
er
)
{
MOZ_ASSERT
(
er
.
isSome
(
)
)
;
+
+
read
;
MOZ_RELEASE_ASSERT
(
er
-
>
CurrentBlockIndex
(
)
>
firstBlockIndex
)
;
MOZ_RELEASE_ASSERT
(
!
!
er
-
>
NextBlockIndex
(
)
)
;
MOZ_RELEASE_ASSERT
(
er
-
>
NextBlockIndex
(
)
>
firstBlockIndex
)
;
MOZ_RELEASE_ASSERT
(
er
-
>
NextBlockIndex
(
)
<
lastBlockIndex
)
;
blockIndex
=
er
-
>
NextBlockIndex
(
)
;
MOZ_RELEASE_ASSERT
(
er
-
>
RemainingBytes
(
)
=
=
sizeof
(
size_t
)
)
;
const
auto
value
=
er
-
>
ReadObject
<
size_t
>
(
)
;
MOZ_RELEASE_ASSERT
(
i
=
=
0
)
;
i
=
value
;
MOZ_RELEASE_ASSERT
(
er
-
>
RemainingBytes
(
)
=
=
0
)
;
return
7
;
}
)
;
MOZ_RELEASE_ASSERT
(
success
)
;
MOZ_RELEASE_ASSERT
(
read
=
=
1
)
;
do
{
bool
success
=
cb
.
ReadAt
(
blockIndex
[
&
]
(
Maybe
<
ProfileBufferEntryReader
>
&
&
er
)
{
MOZ_ASSERT
(
er
.
isSome
(
)
)
;
+
+
read
;
MOZ_RELEASE_ASSERT
(
er
-
>
CurrentBlockIndex
(
)
=
=
blockIndex
)
;
MOZ_RELEASE_ASSERT
(
!
er
-
>
NextBlockIndex
(
)
|
|
er
-
>
NextBlockIndex
(
)
>
blockIndex
)
;
MOZ_RELEASE_ASSERT
(
!
er
-
>
NextBlockIndex
(
)
|
|
er
-
>
NextBlockIndex
(
)
>
firstBlockIndex
)
;
MOZ_RELEASE_ASSERT
(
!
er
-
>
NextBlockIndex
(
)
|
|
er
-
>
NextBlockIndex
(
)
<
=
lastBlockIndex
)
;
MOZ_RELEASE_ASSERT
(
er
-
>
NextBlockIndex
(
)
?
blockIndex
<
lastBlockIndex
:
blockIndex
=
=
lastBlockIndex
"
er
-
>
NextBlockIndex
(
)
should
only
be
null
when
"
"
blockIndex
is
at
the
last
block
"
)
;
blockIndex
=
er
-
>
NextBlockIndex
(
)
;
MOZ_RELEASE_ASSERT
(
er
-
>
RemainingBytes
(
)
=
=
sizeof
(
size_t
)
)
;
const
auto
value
=
er
-
>
ReadObject
<
size_t
>
(
)
;
MOZ_RELEASE_ASSERT
(
value
=
=
+
+
i
)
;
MOZ_RELEASE_ASSERT
(
er
-
>
RemainingBytes
(
)
=
=
0
)
;
return
true
;
}
)
;
MOZ_RELEASE_ASSERT
(
success
)
;
}
while
(
blockIndex
)
;
MOZ_RELEASE_ASSERT
(
read
>
1
)
;
#
ifdef
DEBUG
#
endif
cb
.
Clear
(
)
;
#
ifdef
DEBUG
#
endif
constexpr
int
ThreadCount
=
32
;
std
:
:
thread
threads
[
ThreadCount
]
;
for
(
int
threadNo
=
0
;
threadNo
<
ThreadCount
;
+
+
threadNo
)
{
threads
[
threadNo
]
=
std
:
:
thread
(
[
&
]
(
int
aThreadNo
)
{
:
:
SleepMilli
(
1
)
;
constexpr
int
pushCount
=
1024
;
for
(
int
push
=
0
;
push
<
pushCount
;
+
+
push
)
{
const
bool
success
=
cb
.
Put
(
std
:
:
max
(
aThreadNo
int
(
sizeof
(
push
)
)
)
[
&
]
(
Maybe
<
ProfileBufferEntryWriter
>
&
aEW
)
{
if
(
!
aEW
)
{
return
false
;
}
aEW
-
>
WriteObject
(
aThreadNo
*
1000000
+
push
)
;
for
(
size_t
r
=
aEW
-
>
RemainingBytes
(
)
;
r
!
=
0
;
-
-
r
)
{
aEW
-
>
WriteObject
<
char
>
(
'
_
'
)
;
}
return
true
;
}
)
;
MOZ_RELEASE_ASSERT
(
success
)
;
}
}
threadNo
)
;
}
for
(
auto
&
&
thread
:
threads
)
{
thread
.
join
(
)
;
}
#
ifdef
DEBUG
#
endif
cb
.
ResetChunkManager
(
)
;
success
=
cb
.
ReserveAndPut
(
[
]
(
)
{
MOZ_RELEASE_ASSERT
(
false
)
;
return
1
;
}
[
]
(
Maybe
<
ProfileBufferEntryWriter
>
&
aEW
)
{
return
!
!
aEW
;
}
)
;
MOZ_RELEASE_ASSERT
(
!
success
)
;
success
=
cb
.
Put
(
1
[
]
(
Maybe
<
ProfileBufferEntryWriter
>
&
aEW
)
{
return
!
!
aEW
;
}
)
;
MOZ_RELEASE_ASSERT
(
!
success
)
;
blockIndex
=
cb
.
PutFrom
(
&
success
1
)
;
MOZ_RELEASE_ASSERT
(
!
blockIndex
)
;
blockIndex
=
cb
.
PutObjects
(
123
success
"
hello
"
)
;
MOZ_RELEASE_ASSERT
(
!
blockIndex
)
;
blockIndex
=
cb
.
PutObject
(
123
)
;
MOZ_RELEASE_ASSERT
(
!
blockIndex
)
;
chunks
=
cb
.
GetAllChunks
(
)
;
MOZ_RELEASE_ASSERT
(
!
chunks
"
Expected
no
chunks
when
out
-
of
-
session
"
)
;
cb
.
ReadEach
(
[
]
(
ProfileBufferEntryReader
&
)
{
MOZ_RELEASE_ASSERT
(
false
)
;
}
)
;
success
=
cb
.
ReadAt
(
nullptr
[
]
(
Maybe
<
ProfileBufferEntryReader
>
&
&
er
)
{
MOZ_RELEASE_ASSERT
(
er
.
isNothing
(
)
)
;
return
true
;
}
)
;
MOZ_RELEASE_ASSERT
(
success
)
;
printf
(
"
TestChunkedBuffer
done
\
n
"
)
;
}
static
void
TestChunkedBufferSingle
(
)
{
printf
(
"
TestChunkedBufferSingle
.
.
.
\
n
"
)
;
constexpr
ProfileChunkedBuffer
:
:
Length
chunkMinSize
=
128
;
ProfileChunkedBuffer
cbSingle
(
ProfileChunkedBuffer
:
:
ThreadSafety
:
:
WithoutMutex
MakeUnique
<
ProfileBufferChunkManagerSingle
>
(
chunkMinSize
)
)
;
MOZ_RELEASE_ASSERT
(
cbSingle
.
BufferLength
(
)
.
isSome
(
)
)
;
MOZ_RELEASE_ASSERT
(
*
cbSingle
.
BufferLength
(
)
>
=
chunkMinSize
)
;
size_t
firstIndexToFail
=
0
;
ProfileBufferBlockIndex
lastBlockIndex
;
for
(
size_t
i
=
1
;
i
<
3
*
chunkMinSize
/
(
1
+
sizeof
(
int
)
)
;
+
+
i
)
{
ProfileBufferBlockIndex
blockIndex
=
cbSingle
.
PutObject
(
i
)
;
if
(
blockIndex
)
{
MOZ_RELEASE_ASSERT
(
firstIndexToFail
=
=
0
"
We
should
successfully
write
after
we
have
failed
once
"
)
;
lastBlockIndex
=
blockIndex
;
}
else
if
(
firstIndexToFail
=
=
0
)
{
firstIndexToFail
=
i
;
}
}
MOZ_RELEASE_ASSERT
(
firstIndexToFail
!
=
0
"
There
should
be
at
least
one
failure
"
)
;
MOZ_RELEASE_ASSERT
(
firstIndexToFail
!
=
1
"
We
shouldn
'
t
fail
from
the
start
"
)
;
MOZ_RELEASE_ASSERT
(
!
!
lastBlockIndex
"
We
shouldn
'
t
fail
from
the
start
"
)
;
size_t
read
=
0
;
cbSingle
.
ReadEach
(
[
&
]
(
ProfileBufferEntryReader
&
er
ProfileBufferBlockIndex
blockIndex
)
{
+
+
read
;
MOZ_RELEASE_ASSERT
(
er
.
RemainingBytes
(
)
=
=
sizeof
(
size_t
)
)
;
const
auto
value
=
er
.
ReadObject
<
size_t
>
(
)
;
MOZ_RELEASE_ASSERT
(
value
=
=
read
)
;
MOZ_RELEASE_ASSERT
(
er
.
RemainingBytes
(
)
=
=
0
)
;
MOZ_RELEASE_ASSERT
(
blockIndex
<
=
lastBlockIndex
"
Unexpected
block
index
past
the
last
written
one
"
)
;
}
)
;
MOZ_RELEASE_ASSERT
(
read
=
=
firstIndexToFail
-
1
"
We
should
have
read
up
to
before
the
first
failure
"
)
;
constexpr
size_t
bufferMaxSize
=
1024
;
ProfileBufferChunkManagerWithLocalLimit
cmTarget
(
bufferMaxSize
chunkMinSize
)
;
ProfileChunkedBuffer
cbTarget
(
ProfileChunkedBuffer
:
:
ThreadSafety
:
:
WithMutex
cmTarget
)
;
cbTarget
.
ReadEach
(
[
]
(
ProfileBufferEntryReader
&
)
{
MOZ_RELEASE_ASSERT
(
false
)
;
}
)
;
cbTarget
.
AppendContents
(
cbSingle
)
;
read
=
0
;
cbTarget
.
ReadEach
(
[
&
]
(
ProfileBufferEntryReader
&
er
ProfileBufferBlockIndex
blockIndex
)
{
+
+
read
;
MOZ_RELEASE_ASSERT
(
er
.
RemainingBytes
(
)
=
=
sizeof
(
size_t
)
)
;
const
auto
value
=
er
.
ReadObject
<
size_t
>
(
)
;
MOZ_RELEASE_ASSERT
(
value
=
=
read
)
;
MOZ_RELEASE_ASSERT
(
er
.
RemainingBytes
(
)
=
=
0
)
;
MOZ_RELEASE_ASSERT
(
blockIndex
<
=
lastBlockIndex
"
Unexpected
block
index
past
the
last
written
one
"
)
;
}
)
;
MOZ_RELEASE_ASSERT
(
read
=
=
firstIndexToFail
-
1
"
We
should
have
read
up
to
before
the
first
failure
"
)
;
#
ifdef
DEBUG
#
endif
printf
(
"
TestChunkedBufferSingle
done
\
n
"
)
;
}
static
void
TestModuloBuffer
(
ModuloBuffer
<
>
&
mb
uint32_t
MBSize
)
{
using
MB
=
ModuloBuffer
<
>
;
MOZ_RELEASE_ASSERT
(
mb
.
BufferLength
(
)
.
Value
(
)
=
=
MBSize
)
;
MOZ_RELEASE_ASSERT
(
mb
.
ReaderAt
(
2
)
=
=
mb
.
ReaderAt
(
2
)
)
;
MOZ_RELEASE_ASSERT
(
mb
.
ReaderAt
(
2
)
!
=
mb
.
ReaderAt
(
3
)
)
;
MOZ_RELEASE_ASSERT
(
mb
.
ReaderAt
(
2
)
<
mb
.
ReaderAt
(
3
)
)
;
MOZ_RELEASE_ASSERT
(
mb
.
ReaderAt
(
2
)
<
=
mb
.
ReaderAt
(
2
)
)
;
MOZ_RELEASE_ASSERT
(
mb
.
ReaderAt
(
2
)
<
=
mb
.
ReaderAt
(
3
)
)
;
MOZ_RELEASE_ASSERT
(
mb
.
ReaderAt
(
3
)
>
mb
.
ReaderAt
(
2
)
)
;
MOZ_RELEASE_ASSERT
(
mb
.
ReaderAt
(
2
)
>
=
mb
.
ReaderAt
(
2
)
)
;
MOZ_RELEASE_ASSERT
(
mb
.
ReaderAt
(
3
)
>
=
mb
.
ReaderAt
(
2
)
)
;
MOZ_RELEASE_ASSERT
(
mb
.
ReaderAt
(
2
)
!
=
mb
.
ReaderAt
(
MBSize
+
2
)
)
;
MOZ_RELEASE_ASSERT
(
mb
.
ReaderAt
(
MBSize
+
2
)
!
=
mb
.
ReaderAt
(
2
)
)
;
static_assert
(
std
:
:
is_same
<
decltype
(
*
mb
.
ReaderAt
(
0
)
)
const
MB
:
:
Byte
&
>
:
:
value
"
Dereferencing
from
a
reader
should
return
const
Byte
*
"
)
;
static_assert
(
std
:
:
is_same
<
decltype
(
*
mb
.
WriterAt
(
0
)
)
MB
:
:
Byte
&
>
:
:
value
"
Dereferencing
from
a
writer
should
return
Byte
*
"
)
;
MOZ_RELEASE_ASSERT
(
&
*
mb
.
ReaderAt
(
MBSize
-
1
)
=
=
&
*
mb
.
ReaderAt
(
0
)
+
(
MBSize
-
1
)
)
;
MOZ_RELEASE_ASSERT
(
&
*
mb
.
ReaderAt
(
MBSize
)
=
=
&
*
mb
.
ReaderAt
(
0
)
)
;
MOZ_RELEASE_ASSERT
(
&
*
mb
.
ReaderAt
(
MBSize
+
MBSize
-
1
)
=
=
&
*
mb
.
ReaderAt
(
MBSize
-
1
)
)
;
MOZ_RELEASE_ASSERT
(
&
*
mb
.
ReaderAt
(
MBSize
+
MBSize
)
=
=
&
*
mb
.
ReaderAt
(
0
)
)
;
MOZ_RELEASE_ASSERT
(
&
*
mb
.
ReaderAt
(
uint32_t
(
-
1
)
)
=
=
&
*
mb
.
ReaderAt
(
MBSize
-
1
)
)
;
MOZ_RELEASE_ASSERT
(
&
*
mb
.
ReaderAt
(
static_cast
<
MB
:
:
Index
>
(
-
1
)
)
=
=
&
*
mb
.
ReaderAt
(
MBSize
-
1
)
)
;
MB
:
:
Reader
arit
=
mb
.
ReaderAt
(
0
)
;
MOZ_RELEASE_ASSERT
(
+
+
arit
=
=
mb
.
ReaderAt
(
1
)
)
;
MOZ_RELEASE_ASSERT
(
arit
=
=
mb
.
ReaderAt
(
1
)
)
;
MOZ_RELEASE_ASSERT
(
-
-
arit
=
=
mb
.
ReaderAt
(
0
)
)
;
MOZ_RELEASE_ASSERT
(
arit
=
=
mb
.
ReaderAt
(
0
)
)
;
MOZ_RELEASE_ASSERT
(
arit
+
+
=
=
mb
.
ReaderAt
(
0
)
)
;
MOZ_RELEASE_ASSERT
(
arit
=
=
mb
.
ReaderAt
(
1
)
)
;
MOZ_RELEASE_ASSERT
(
arit
-
-
=
=
mb
.
ReaderAt
(
1
)
)
;
MOZ_RELEASE_ASSERT
(
arit
=
=
mb
.
ReaderAt
(
0
)
)
;
MOZ_RELEASE_ASSERT
(
arit
+
3
=
=
mb
.
ReaderAt
(
3
)
)
;
MOZ_RELEASE_ASSERT
(
arit
=
=
mb
.
ReaderAt
(
0
)
)
;
MOZ_RELEASE_ASSERT
(
4
+
arit
=
=
mb
.
ReaderAt
(
4
)
)
;
MOZ_RELEASE_ASSERT
(
arit
=
=
mb
.
ReaderAt
(
0
)
)
;
const
bool
checkPlusEq
=
(
(
arit
+
=
3
)
=
=
mb
.
ReaderAt
(
3
)
)
;
MOZ_RELEASE_ASSERT
(
checkPlusEq
)
;
MOZ_RELEASE_ASSERT
(
arit
=
=
mb
.
ReaderAt
(
3
)
)
;
MOZ_RELEASE_ASSERT
(
(
arit
-
2
)
=
=
mb
.
ReaderAt
(
1
)
)
;
MOZ_RELEASE_ASSERT
(
arit
=
=
mb
.
ReaderAt
(
3
)
)
;
const
bool
checkMinusEq
=
(
(
arit
-
=
2
)
=
=
mb
.
ReaderAt
(
1
)
)
;
MOZ_RELEASE_ASSERT
(
checkMinusEq
)
;
MOZ_RELEASE_ASSERT
(
arit
=
=
mb
.
ReaderAt
(
1
)
)
;
MOZ_RELEASE_ASSERT
(
&
arit
[
3
]
=
=
&
*
(
arit
+
3
)
)
;
MOZ_RELEASE_ASSERT
(
arit
=
=
mb
.
ReaderAt
(
1
)
)
;
MOZ_RELEASE_ASSERT
(
mb
.
ReaderAt
(
3
)
-
mb
.
ReaderAt
(
1
)
=
=
2
)
;
MOZ_RELEASE_ASSERT
(
mb
.
ReaderAt
(
1
)
-
mb
.
ReaderAt
(
3
)
=
=
MB
:
:
Index
(
-
2
)
)
;
MB
:
:
Writer
it
=
mb
.
WriterAt
(
0
)
;
MOZ_RELEASE_ASSERT
(
it
.
CurrentIndex
(
)
=
=
0
)
;
it
.
WriteObject
(
'
x
'
)
;
it
.
WriteObject
(
'
y
'
)
;
it
-
=
2
;
MOZ_RELEASE_ASSERT
(
it
.
PeekObject
<
char
>
(
)
=
=
'
x
'
)
;
MOZ_RELEASE_ASSERT
(
it
.
CurrentIndex
(
)
=
=
0
)
;
MOZ_RELEASE_ASSERT
(
it
.
ReadObject
<
char
>
(
)
=
=
'
x
'
)
;
MOZ_RELEASE_ASSERT
(
it
.
CurrentIndex
(
)
=
=
1
)
;
MOZ_RELEASE_ASSERT
(
it
.
PeekObject
<
char
>
(
)
=
=
'
y
'
)
;
MOZ_RELEASE_ASSERT
(
it
.
CurrentIndex
(
)
=
=
1
)
;
MOZ_RELEASE_ASSERT
(
it
.
ReadObject
<
char
>
(
)
=
=
'
y
'
)
;
MOZ_RELEASE_ASSERT
(
it
.
CurrentIndex
(
)
=
=
2
)
;
MB
:
:
Reader
it2
(
it
)
;
MOZ_RELEASE_ASSERT
(
it2
.
CurrentIndex
(
)
=
=
2
)
;
it2
=
it
;
MOZ_RELEASE_ASSERT
(
it2
.
CurrentIndex
(
)
=
=
2
)
;
static_assert
(
std
:
:
is_same
<
std
:
:
iterator_traits
<
MB
:
:
Reader
>
:
:
difference_type
MB
:
:
Index
>
:
:
value
"
ModuloBuffer
:
:
Reader
:
:
difference_type
should
be
Index
"
)
;
static_assert
(
std
:
:
is_same
<
std
:
:
iterator_traits
<
MB
:
:
Reader
>
:
:
value_type
MB
:
:
Byte
>
:
:
value
"
ModuloBuffer
:
:
Reader
:
:
value_type
should
be
Byte
"
)
;
static_assert
(
std
:
:
is_same
<
std
:
:
iterator_traits
<
MB
:
:
Reader
>
:
:
pointer
const
MB
:
:
Byte
*
>
:
:
value
"
ModuloBuffer
:
:
Reader
:
:
pointer
should
be
const
Byte
*
"
)
;
static_assert
(
std
:
:
is_same
<
std
:
:
iterator_traits
<
MB
:
:
Reader
>
:
:
reference
const
MB
:
:
Byte
&
>
:
:
value
"
ModuloBuffer
:
:
Reader
:
:
reference
should
be
const
Byte
&
"
)
;
static_assert
(
std
:
:
is_base_of
<
std
:
:
input_iterator_tag
std
:
:
iterator_traits
<
MB
:
:
Reader
>
:
:
iterator_category
>
:
:
value
"
ModuloBuffer
:
:
Reader
:
:
iterator_category
should
be
derived
"
"
from
input_iterator_tag
"
)
;
static_assert
(
std
:
:
is_base_of
<
std
:
:
forward_iterator_tag
std
:
:
iterator_traits
<
MB
:
:
Reader
>
:
:
iterator_category
>
:
:
value
"
ModuloBuffer
:
:
Reader
:
:
iterator_category
should
be
derived
"
"
from
forward_iterator_tag
"
)
;
static_assert
(
std
:
:
is_base_of
<
std
:
:
bidirectional_iterator_tag
std
:
:
iterator_traits
<
MB
:
:
Reader
>
:
:
iterator_category
>
:
:
value
"
ModuloBuffer
:
:
Reader
:
:
iterator_category
should
be
derived
"
"
from
bidirectional_iterator_tag
"
)
;
static_assert
(
std
:
:
is_same
<
std
:
:
iterator_traits
<
MB
:
:
Reader
>
:
:
iterator_category
std
:
:
random_access_iterator_tag
>
:
:
value
"
ModuloBuffer
:
:
Reader
:
:
iterator_category
should
be
"
"
random_access_iterator_tag
"
)
;
std
:
:
string
s
(
mb
.
ReaderAt
(
0
)
mb
.
ReaderAt
(
2
)
)
;
MOZ_RELEASE_ASSERT
(
s
=
=
"
xy
"
)
;
it
.
WriteObject
(
int32_t
(
123
)
)
;
MOZ_RELEASE_ASSERT
(
it
.
CurrentIndex
(
)
=
=
6
)
;
it
.
WriteObject
(
int32_t
(
456
)
)
;
MOZ_RELEASE_ASSERT
(
it
.
CurrentIndex
(
)
=
=
MBSize
+
2
)
;
MOZ_RELEASE_ASSERT
(
it
.
ReadObject
<
int32_t
>
(
)
=
=
123
)
;
MOZ_RELEASE_ASSERT
(
it
.
CurrentIndex
(
)
=
=
MBSize
+
6
)
;
MOZ_RELEASE_ASSERT
(
it
.
ReadObject
<
int32_t
>
(
)
=
=
456
)
;
MOZ_RELEASE_ASSERT
(
it
.
CurrentIndex
(
)
=
=
MBSize
+
MBSize
+
2
)
;
}
void
TestModuloBuffer
(
)
{
printf
(
"
TestModuloBuffer
.
.
.
\
n
"
)
;
using
MB
=
ModuloBuffer
<
>
;
constexpr
uint32_t
MBSize
=
8
;
MB
mbByLength
(
MakePowerOfTwo32
<
MBSize
>
(
)
)
;
TestModuloBuffer
(
mbByLength
MBSize
)
;
auto
uniqueBuffer
=
MakeUnique
<
uint8_t
[
]
>
(
MBSize
)
;
MB
mbByUniquePtr
(
MakeUnique
<
uint8_t
[
]
>
(
MBSize
)
MakePowerOfTwo32
<
MBSize
>
(
)
)
;
TestModuloBuffer
(
mbByUniquePtr
MBSize
)
;
uint8_t
buffer
[
MBSize
*
3
]
;
for
(
size_t
i
=
0
;
i
<
MBSize
*
3
;
+
+
i
)
{
buffer
[
i
]
=
uint8_t
(
'
A
'
+
i
)
;
}
MB
mbByBuffer
(
&
buffer
[
MBSize
]
MakePowerOfTwo32
<
MBSize
>
(
)
)
;
TestModuloBuffer
(
mbByBuffer
MBSize
)
;
uint32_t
changed
=
0
;
for
(
size_t
i
=
MBSize
;
i
<
MBSize
*
2
;
+
+
i
)
{
changed
+
=
(
buffer
[
i
]
=
=
uint8_t
(
'
A
'
+
i
)
)
?
0
:
1
;
}
MOZ_RELEASE_ASSERT
(
changed
>
=
MBSize
*
6
/
8
)
;
for
(
size_t
i
=
0
;
i
<
MBSize
;
+
+
i
)
{
MOZ_RELEASE_ASSERT
(
buffer
[
i
]
=
=
uint8_t
(
'
A
'
+
i
)
)
;
}
for
(
size_t
i
=
MBSize
*
2
;
i
<
MBSize
*
3
;
+
+
i
)
{
MOZ_RELEASE_ASSERT
(
buffer
[
i
]
=
=
uint8_t
(
'
A
'
+
i
)
)
;
}
MB
mbByStolenBuffer
=
std
:
:
move
(
mbByBuffer
)
;
TestModuloBuffer
(
mbByStolenBuffer
MBSize
)
;
changed
=
0
;
for
(
size_t
i
=
MBSize
;
i
<
MBSize
*
2
;
+
+
i
)
{
changed
+
=
(
buffer
[
i
]
=
=
uint8_t
(
'
A
'
+
i
)
)
?
0
:
1
;
}
MOZ_RELEASE_ASSERT
(
changed
>
=
MBSize
*
6
/
8
)
;
for
(
size_t
i
=
0
;
i
<
MBSize
;
+
+
i
)
{
MOZ_RELEASE_ASSERT
(
buffer
[
i
]
=
=
uint8_t
(
'
A
'
+
i
)
)
;
}
for
(
size_t
i
=
MBSize
*
2
;
i
<
MBSize
*
3
;
+
+
i
)
{
MOZ_RELEASE_ASSERT
(
buffer
[
i
]
=
=
uint8_t
(
'
A
'
+
i
)
)
;
}
auto
TestReadInto
=
[
]
(
MB
:
:
Index
aReadFrom
MB
:
:
Index
aWriteTo
MB
:
:
Length
aBytes
)
{
constexpr
uint32_t
TRISize
=
16
;
uint8_t
input
[
TRISize
+
1
]
=
"
ABCDEFGHIJKLMNOP
"
;
const
MB
mbInput
(
input
MakePowerOfTwo32
<
TRISize
>
(
)
)
;
uint8_t
output
[
TRISize
+
1
]
=
"
abcdefghijklmnop
"
;
MB
mbOutput
(
output
MakePowerOfTwo32
<
TRISize
>
(
)
)
;
auto
writer
=
mbOutput
.
WriterAt
(
aWriteTo
)
;
mbInput
.
ReaderAt
(
aReadFrom
)
.
ReadInto
(
writer
aBytes
)
;
uint8_t
outputCheck
[
TRISize
+
1
]
=
"
abcdefghijklmnop
"
;
MB
mbOutputCheck
(
outputCheck
MakePowerOfTwo32
<
TRISize
>
(
)
)
;
auto
readerCheck
=
mbInput
.
ReaderAt
(
aReadFrom
)
;
auto
writerCheck
=
mbOutputCheck
.
WriterAt
(
aWriteTo
)
;
for
(
MB
:
:
Length
i
=
0
;
i
<
aBytes
;
+
+
i
)
{
*
writerCheck
+
+
=
*
readerCheck
+
+
;
}
for
(
uint32_t
i
=
0
;
i
<
TRISize
;
+
+
i
)
{
#
ifdef
TEST_MODULOBUFFER_FAILURE_DEBUG
if
(
output
[
i
]
!
=
outputCheck
[
i
]
)
{
printf
(
"
*
*
*
from
=
%
u
to
=
%
u
bytes
=
%
u
i
=
%
u
\
ninput
:
'
%
s
'
\
noutput
:
"
"
'
%
s
'
\
ncheck
:
'
%
s
'
\
n
"
unsigned
(
aReadFrom
)
unsigned
(
aWriteTo
)
unsigned
(
aBytes
)
unsigned
(
i
)
input
output
outputCheck
)
;
}
#
endif
MOZ_RELEASE_ASSERT
(
output
[
i
]
=
=
outputCheck
[
i
]
)
;
}
#
ifdef
TEST_MODULOBUFFER_HELPER
printf
(
"
*
*
*
from
=
%
u
to
=
%
u
bytes
=
%
u
output
:
%
s
\
n
"
unsigned
(
aReadFrom
)
unsigned
(
aWriteTo
)
unsigned
(
aBytes
)
output
)
;
#
endif
return
std
:
:
string
(
reinterpret_cast
<
const
char
*
>
(
output
)
)
;
}
;
constexpr
uint32_t
TRISize
=
16
;
MOZ_RELEASE_ASSERT
(
TestReadInto
(
0
0
0
)
=
=
"
abcdefghijklmnop
"
)
;
MOZ_RELEASE_ASSERT
(
TestReadInto
(
0
0
TRISize
)
=
=
"
ABCDEFGHIJKLMNOP
"
)
;
MOZ_RELEASE_ASSERT
(
TestReadInto
(
0
5
TRISize
)
=
=
"
LMNOPABCDEFGHIJK
"
)
;
MOZ_RELEASE_ASSERT
(
TestReadInto
(
5
0
TRISize
)
=
=
"
FGHIJKLMNOPABCDE
"
)
;
for
(
MB
:
:
Index
r
=
0
;
r
<
TRISize
;
+
+
r
)
{
for
(
MB
:
:
Index
w
=
0
;
w
<
TRISize
;
+
+
w
)
{
for
(
MB
:
:
Length
len
=
0
;
len
<
TRISize
;
+
+
len
)
{
TestReadInto
(
r
w
len
)
;
}
}
}
printf
(
"
TestModuloBuffer
done
\
n
"
)
;
}
void
TestBlocksRingBufferAPI
(
)
{
printf
(
"
TestBlocksRingBufferAPI
.
.
.
\
n
"
)
;
constexpr
uint32_t
MBSize
=
16
;
uint8_t
buffer
[
MBSize
*
3
]
;
for
(
size_t
i
=
0
;
i
<
MBSize
*
3
;
+
+
i
)
{
buffer
[
i
]
=
uint8_t
(
'
A
'
+
i
)
;
}
{
BlocksRingBuffer
rb
(
BlocksRingBuffer
:
:
ThreadSafety
:
:
WithMutex
&
buffer
[
MBSize
]
MakePowerOfTwo32
<
MBSize
>
(
)
)
;
#
define
VERIFY_START_END_PUSHED_CLEARED
(
aStart
aEnd
aPushed
aCleared
)
\
{
\
BlocksRingBuffer
:
:
State
state
=
rb
.
GetState
(
)
;
\
MOZ_RELEASE_ASSERT
(
state
.
mRangeStart
.
ConvertToProfileBufferIndex
(
)
=
=
\
(
aStart
)
)
;
\
MOZ_RELEASE_ASSERT
(
state
.
mRangeEnd
.
ConvertToProfileBufferIndex
(
)
=
=
\
(
aEnd
)
)
;
\
MOZ_RELEASE_ASSERT
(
state
.
mPushedBlockCount
=
=
(
aPushed
)
)
;
\
MOZ_RELEASE_ASSERT
(
state
.
mClearedBlockCount
=
=
(
aCleared
)
)
;
\
}
VERIFY_START_END_PUSHED_CLEARED
(
1
1
0
0
)
;
ProfileBufferBlockIndex
bi0
;
if
(
bi0
)
{
MOZ_RELEASE_ASSERT
(
false
"
if
(
ProfileBufferBlockIndex
{
}
)
should
fail
test
"
)
;
}
if
(
!
bi0
)
{
}
else
{
MOZ_RELEASE_ASSERT
(
false
"
if
(
!
ProfileBufferBlockIndex
{
}
)
should
succeed
test
"
)
;
}
MOZ_RELEASE_ASSERT
(
!
bi0
)
;
MOZ_RELEASE_ASSERT
(
bi0
=
=
bi0
)
;
MOZ_RELEASE_ASSERT
(
bi0
<
=
bi0
)
;
MOZ_RELEASE_ASSERT
(
bi0
>
=
bi0
)
;
MOZ_RELEASE_ASSERT
(
!
(
bi0
!
=
bi0
)
)
;
MOZ_RELEASE_ASSERT
(
!
(
bi0
<
bi0
)
)
;
MOZ_RELEASE_ASSERT
(
!
(
bi0
>
bi0
)
)
;
rb
.
ReadAt
(
bi0
[
]
(
Maybe
<
ProfileBufferEntryReader
>
&
&
aMaybeReader
)
{
MOZ_RELEASE_ASSERT
(
aMaybeReader
.
isNothing
(
)
)
;
}
)
;
MOZ_RELEASE_ASSERT
(
rb
.
PutObject
(
uint32_t
(
1
)
)
.
ConvertToProfileBufferIndex
(
)
=
=
1
)
;
VERIFY_START_END_PUSHED_CLEARED
(
1
6
1
0
)
;
auto
bi2
=
rb
.
ReserveAndPut
(
[
]
(
)
{
return
sizeof
(
uint32_t
)
;
}
[
]
(
Maybe
<
ProfileBufferEntryWriter
>
&
aEW
)
{
MOZ_RELEASE_ASSERT
(
aEW
.
isSome
(
)
)
;
aEW
-
>
WriteObject
(
uint32_t
(
2
)
)
;
return
aEW
-
>
CurrentBlockIndex
(
)
;
}
)
;
static_assert
(
std
:
:
is_same
<
decltype
(
bi2
)
ProfileBufferBlockIndex
>
:
:
value
"
All
index
-
returning
functions
should
return
a
"
"
ProfileBufferBlockIndex
"
)
;
MOZ_RELEASE_ASSERT
(
bi2
.
ConvertToProfileBufferIndex
(
)
=
=
6
)
;
VERIFY_START_END_PUSHED_CLEARED
(
1
11
2
0
)
;
auto
i2Next
=
rb
.
ReadAt
(
bi2
[
bi2
]
(
Maybe
<
ProfileBufferEntryReader
>
&
&
aMaybeReader
)
{
MOZ_RELEASE_ASSERT
(
aMaybeReader
.
isSome
(
)
)
;
MOZ_RELEASE_ASSERT
(
aMaybeReader
-
>
CurrentBlockIndex
(
)
=
=
bi2
)
;
MOZ_RELEASE_ASSERT
(
aMaybeReader
-
>
NextBlockIndex
(
)
=
=
nullptr
)
;
size_t
entrySize
=
aMaybeReader
-
>
RemainingBytes
(
)
;
MOZ_RELEASE_ASSERT
(
aMaybeReader
-
>
ReadObject
<
uint32_t
>
(
)
=
=
2
)
;
return
bi2
.
ConvertToProfileBufferIndex
(
)
+
ULEB128Size
(
entrySize
)
+
entrySize
;
}
)
;
auto
bi2Next
=
rb
.
GetState
(
)
.
mRangeEnd
;
MOZ_RELEASE_ASSERT
(
bi2Next
.
ConvertToProfileBufferIndex
(
)
=
=
i2Next
)
;
rb
.
ReadAt
(
bi2Next
[
]
(
Maybe
<
ProfileBufferEntryReader
>
&
&
aMaybeReader
)
{
MOZ_RELEASE_ASSERT
(
aMaybeReader
.
isNothing
(
)
)
;
}
)
;
if
(
bi2
)
{
}
else
{
MOZ_RELEASE_ASSERT
(
false
"
if
(
non
-
default
-
ProfileBufferBlockIndex
)
should
succeed
test
"
)
;
}
if
(
!
bi2
)
{
MOZ_RELEASE_ASSERT
(
false
"
if
(
!
non
-
default
-
ProfileBufferBlockIndex
)
should
fail
test
"
)
;
}
MOZ_RELEASE_ASSERT
(
!
!
bi2
)
;
MOZ_RELEASE_ASSERT
(
bi2
=
=
bi2
)
;
MOZ_RELEASE_ASSERT
(
bi2
<
=
bi2
)
;
MOZ_RELEASE_ASSERT
(
bi2
>
=
bi2
)
;
MOZ_RELEASE_ASSERT
(
!
(
bi2
!
=
bi2
)
)
;
MOZ_RELEASE_ASSERT
(
!
(
bi2
<
bi2
)
)
;
MOZ_RELEASE_ASSERT
(
!
(
bi2
>
bi2
)
)
;
MOZ_RELEASE_ASSERT
(
bi0
!
=
bi2
)
;
MOZ_RELEASE_ASSERT
(
bi0
<
bi2
)
;
MOZ_RELEASE_ASSERT
(
bi0
<
=
bi2
)
;
MOZ_RELEASE_ASSERT
(
!
(
bi0
=
=
bi2
)
)
;
MOZ_RELEASE_ASSERT
(
!
(
bi0
>
bi2
)
)
;
MOZ_RELEASE_ASSERT
(
!
(
bi0
>
=
bi2
)
)
;
MOZ_RELEASE_ASSERT
(
bi2
!
=
bi0
)
;
MOZ_RELEASE_ASSERT
(
bi2
>
bi0
)
;
MOZ_RELEASE_ASSERT
(
bi2
>
=
bi0
)
;
MOZ_RELEASE_ASSERT
(
!
(
bi2
=
=
bi0
)
)
;
MOZ_RELEASE_ASSERT
(
!
(
bi2
<
bi0
)
)
;
MOZ_RELEASE_ASSERT
(
!
(
bi2
<
=
bi0
)
)
;
MOZ_RELEASE_ASSERT
(
bi2
!
=
bi2Next
)
;
MOZ_RELEASE_ASSERT
(
bi2
<
bi2Next
)
;
MOZ_RELEASE_ASSERT
(
bi2
<
=
bi2Next
)
;
MOZ_RELEASE_ASSERT
(
!
(
bi2
=
=
bi2Next
)
)
;
MOZ_RELEASE_ASSERT
(
!
(
bi2
>
bi2Next
)
)
;
MOZ_RELEASE_ASSERT
(
!
(
bi2
>
=
bi2Next
)
)
;
MOZ_RELEASE_ASSERT
(
bi2Next
!
=
bi2
)
;
MOZ_RELEASE_ASSERT
(
bi2Next
>
bi2
)
;
MOZ_RELEASE_ASSERT
(
bi2Next
>
=
bi2
)
;
MOZ_RELEASE_ASSERT
(
!
(
bi2Next
=
=
bi2
)
)
;
MOZ_RELEASE_ASSERT
(
!
(
bi2Next
<
bi2
)
)
;
MOZ_RELEASE_ASSERT
(
!
(
bi2Next
<
=
bi2
)
)
;
auto
put3
=
rb
.
Put
(
sizeof
(
uint32_t
)
[
&
]
(
Maybe
<
ProfileBufferEntryWriter
>
&
aEW
)
{
MOZ_RELEASE_ASSERT
(
aEW
.
isSome
(
)
)
;
aEW
-
>
WriteObject
(
uint32_t
(
3
)
)
;
MOZ_RELEASE_ASSERT
(
aEW
-
>
CurrentBlockIndex
(
)
=
=
bi2Next
)
;
return
float
(
aEW
-
>
CurrentBlockIndex
(
)
.
ConvertToProfileBufferIndex
(
)
)
;
}
)
;
static_assert
(
std
:
:
is_same
<
decltype
(
put3
)
float
>
:
:
value
"
Expect
float
as
returned
by
callback
.
"
)
;
MOZ_RELEASE_ASSERT
(
put3
=
=
11
.
0
)
;
VERIFY_START_END_PUSHED_CLEARED
(
1
16
3
0
)
;
rb
.
ReadAt
(
bi2
[
&
]
(
Maybe
<
ProfileBufferEntryReader
>
&
&
aMaybeReader
)
{
MOZ_RELEASE_ASSERT
(
aMaybeReader
.
isSome
(
)
)
;
MOZ_RELEASE_ASSERT
(
aMaybeReader
-
>
CurrentBlockIndex
(
)
=
=
bi2
)
;
MOZ_RELEASE_ASSERT
(
aMaybeReader
-
>
ReadObject
<
uint32_t
>
(
)
=
=
2
)
;
MOZ_RELEASE_ASSERT
(
aMaybeReader
-
>
NextBlockIndex
(
)
=
=
bi2Next
)
;
}
)
;
uint32_t
count
=
0
;
rb
.
ReadEach
(
[
&
]
(
ProfileBufferEntryReader
&
aReader
)
{
MOZ_RELEASE_ASSERT
(
aReader
.
ReadObject
<
uint32_t
>
(
)
=
=
+
+
count
)
;
}
)
;
MOZ_RELEASE_ASSERT
(
count
=
=
3
)
;
ProfileBufferBlockIndex
bi4
=
rb
.
PutObject
(
uint32_t
(
4
)
)
;
VERIFY_START_END_PUSHED_CLEARED
(
6
21
4
1
)
;
count
=
1
;
rb
.
ReadEach
(
[
&
]
(
ProfileBufferEntryReader
&
aReader
)
{
MOZ_RELEASE_ASSERT
(
aReader
.
ReadObject
<
uint32_t
>
(
)
=
=
+
+
count
)
;
}
)
;
MOZ_RELEASE_ASSERT
(
count
=
=
4
)
;
auto
bi5
=
rb
.
Put
(
sizeof
(
uint32_t
)
[
&
]
(
Maybe
<
ProfileBufferEntryWriter
>
&
aEW
)
{
MOZ_RELEASE_ASSERT
(
aEW
.
isSome
(
)
)
;
aEW
-
>
WriteObject
(
uint32_t
(
5
)
)
;
return
aEW
-
>
CurrentBlockIndex
(
)
;
}
)
;
auto
bi6
=
rb
.
GetState
(
)
.
mRangeEnd
;
VERIFY_START_END_PUSHED_CLEARED
(
11
26
5
2
)
;
rb
.
ReadAt
(
bi2
[
]
(
Maybe
<
ProfileBufferEntryReader
>
&
&
aMaybeReader
)
{
MOZ_RELEASE_ASSERT
(
aMaybeReader
.
isNothing
(
)
)
;
}
)
;
rb
.
ReadAt
(
bi5
[
]
(
Maybe
<
ProfileBufferEntryReader
>
&
&
aMaybeReader
)
{
MOZ_RELEASE_ASSERT
(
aMaybeReader
.
isSome
(
)
)
;
MOZ_RELEASE_ASSERT
(
aMaybeReader
-
>
ReadObject
<
uint32_t
>
(
)
=
=
5
)
;
}
)
;
rb
.
Read
(
[
&
]
(
BlocksRingBuffer
:
:
Reader
*
aReader
)
{
MOZ_RELEASE_ASSERT
(
!
!
aReader
)
;
MOZ_RELEASE_ASSERT
(
aReader
-
>
begin
(
)
.
CurrentBlockIndex
(
)
.
ConvertToProfileBufferIndex
(
)
=
=
11
)
;
MOZ_RELEASE_ASSERT
(
aReader
-
>
end
(
)
.
CurrentBlockIndex
(
)
.
ConvertToProfileBufferIndex
(
)
=
=
26
)
;
MOZ_RELEASE_ASSERT
(
aReader
-
>
At
(
bi0
)
=
=
aReader
-
>
begin
(
)
)
;
MOZ_RELEASE_ASSERT
(
aReader
-
>
At
(
bi2
)
=
=
aReader
-
>
begin
(
)
)
;
MOZ_RELEASE_ASSERT
(
aReader
-
>
At
(
aReader
-
>
begin
(
)
.
CurrentBlockIndex
(
)
)
=
=
aReader
-
>
begin
(
)
)
;
MOZ_RELEASE_ASSERT
(
aReader
-
>
At
(
bi5
)
.
CurrentBlockIndex
(
)
.
ConvertToProfileBufferIndex
(
)
=
=
21
)
;
MOZ_RELEASE_ASSERT
(
aReader
-
>
At
(
bi6
)
=
=
aReader
-
>
end
(
)
)
;
MOZ_RELEASE_ASSERT
(
aReader
-
>
At
(
aReader
-
>
end
(
)
.
CurrentBlockIndex
(
)
)
=
=
aReader
-
>
end
(
)
)
;
}
)
;
count
=
2
;
rb
.
ReadEach
(
[
&
]
(
ProfileBufferEntryReader
&
aReader
)
{
MOZ_RELEASE_ASSERT
(
aReader
.
ReadObject
<
uint32_t
>
(
)
=
=
+
+
count
)
;
}
)
;
MOZ_RELEASE_ASSERT
(
count
=
=
5
)
;
rb
.
ClearBefore
(
bi4
)
;
VERIFY_START_END_PUSHED_CLEARED
(
16
26
5
3
)
;
count
=
3
;
rb
.
ReadEach
(
[
&
]
(
ProfileBufferEntryReader
&
aReader
)
{
MOZ_RELEASE_ASSERT
(
aReader
.
ReadObject
<
uint32_t
>
(
)
=
=
+
+
count
)
;
}
)
;
MOZ_RELEASE_ASSERT
(
count
=
=
5
)
;
rb
.
ClearBefore
(
bi4
)
;
VERIFY_START_END_PUSHED_CLEARED
(
16
26
5
3
)
;
rb
.
ClearBefore
(
bi6
)
;
VERIFY_START_END_PUSHED_CLEARED
(
26
26
5
5
)
;
rb
.
ReadEach
(
[
&
]
(
auto
&
&
)
{
MOZ_RELEASE_ASSERT
(
false
)
;
}
)
;
rb
.
ReadAt
(
bi5
[
]
(
Maybe
<
ProfileBufferEntryReader
>
&
&
aMaybeReader
)
{
MOZ_RELEASE_ASSERT
(
aMaybeReader
.
isNothing
(
)
)
;
}
)
;
rb
.
ClearBefore
(
bi4
)
;
VERIFY_START_END_PUSHED_CLEARED
(
26
26
5
5
)
;
MOZ_RELEASE_ASSERT
(
rb
.
PutObject
(
uint32_t
(
6
)
)
=
=
bi6
)
;
VERIFY_START_END_PUSHED_CLEARED
(
26
31
6
5
)
;
{
uint8_t
buffer2
[
MBSize
]
;
BlocksRingBuffer
rb2
(
BlocksRingBuffer
:
:
ThreadSafety
:
:
WithoutMutex
buffer2
MakePowerOfTwo32
<
MBSize
>
(
)
)
;
rb2
.
PutObject
(
uint32_t
(
7
)
)
;
rb2
.
PutObject
(
uint32_t
(
8
)
)
;
VERIFY_START_END_PUSHED_CLEARED
(
26
31
6
5
)
;
rb
.
AppendContents
(
rb2
)
;
VERIFY_START_END_PUSHED_CLEARED
(
26
41
8
5
)
;
rb
.
AppendContents
(
rb2
)
;
VERIFY_START_END_PUSHED_CLEARED
(
36
51
10
7
)
;
}
VERIFY_START_END_PUSHED_CLEARED
(
36
51
10
7
)
;
rb
.
ReadAt
(
bi6
[
]
(
Maybe
<
ProfileBufferEntryReader
>
&
&
aMaybeReader
)
{
MOZ_RELEASE_ASSERT
(
aMaybeReader
.
isNothing
(
)
)
;
}
)
;
count
=
0
;
uint32_t
expected
[
3
]
=
{
8
7
8
}
;
rb
.
ReadEach
(
[
&
]
(
ProfileBufferEntryReader
&
aReader
)
{
MOZ_RELEASE_ASSERT
(
count
<
3
)
;
MOZ_RELEASE_ASSERT
(
aReader
.
ReadObject
<
uint32_t
>
(
)
=
=
expected
[
count
+
+
]
)
;
}
)
;
MOZ_RELEASE_ASSERT
(
count
=
=
3
)
;
}
uint32_t
changed
=
0
;
for
(
size_t
i
=
MBSize
;
i
<
MBSize
*
2
;
+
+
i
)
{
changed
+
=
(
buffer
[
i
]
=
=
uint8_t
(
'
A
'
+
i
)
)
?
0
:
1
;
}
MOZ_RELEASE_ASSERT
(
changed
>
=
MBSize
*
6
/
8
)
;
for
(
size_t
i
=
0
;
i
<
MBSize
;
+
+
i
)
{
MOZ_RELEASE_ASSERT
(
buffer
[
i
]
=
=
uint8_t
(
'
A
'
+
i
)
)
;
}
for
(
size_t
i
=
MBSize
*
2
;
i
<
MBSize
*
3
;
+
+
i
)
{
MOZ_RELEASE_ASSERT
(
buffer
[
i
]
=
=
uint8_t
(
'
A
'
+
i
)
)
;
}
printf
(
"
TestBlocksRingBufferAPI
done
\
n
"
)
;
}
void
TestBlocksRingBufferUnderlyingBufferChanges
(
)
{
printf
(
"
TestBlocksRingBufferUnderlyingBufferChanges
.
.
.
\
n
"
)
;
BlocksRingBuffer
rb
(
BlocksRingBuffer
:
:
ThreadSafety
:
:
WithMutex
)
;
ProfileBufferBlockIndex
bi
;
auto
testOutOfSession
=
[
&
]
(
)
{
MOZ_RELEASE_ASSERT
(
rb
.
BufferLength
(
)
.
isNothing
(
)
)
;
BlocksRingBuffer
:
:
State
state
=
rb
.
GetState
(
)
;
MOZ_RELEASE_ASSERT
(
state
.
mRangeStart
=
=
state
.
mRangeEnd
)
;
MOZ_RELEASE_ASSERT
(
state
.
mPushedBlockCount
=
=
0
)
;
MOZ_RELEASE_ASSERT
(
state
.
mClearedBlockCount
=
=
0
)
;
int32_t
ran
=
0
;
rb
.
Put
(
1
[
&
]
(
Maybe
<
ProfileBufferEntryWriter
>
&
aMaybeEntryWriter
)
{
MOZ_RELEASE_ASSERT
(
aMaybeEntryWriter
.
isNothing
(
)
)
;
+
+
ran
;
}
)
;
MOZ_RELEASE_ASSERT
(
ran
=
=
1
)
;
MOZ_RELEASE_ASSERT
(
rb
.
PutFrom
(
&
ran
sizeof
(
ran
)
)
=
=
ProfileBufferBlockIndex
{
}
)
;
MOZ_RELEASE_ASSERT
(
rb
.
PutObject
(
ran
)
=
=
ProfileBufferBlockIndex
{
}
)
;
ran
=
0
;
rb
.
Read
(
[
&
]
(
BlocksRingBuffer
:
:
Reader
*
aReader
)
{
MOZ_RELEASE_ASSERT
(
!
aReader
)
;
+
+
ran
;
}
)
;
MOZ_RELEASE_ASSERT
(
ran
=
=
1
)
;
ran
=
0
;
rb
.
ReadAt
(
ProfileBufferBlockIndex
{
}
[
&
]
(
Maybe
<
ProfileBufferEntryReader
>
&
&
aMaybeEntryReader
)
{
MOZ_RELEASE_ASSERT
(
aMaybeEntryReader
.
isNothing
(
)
)
;
+
+
ran
;
}
)
;
MOZ_RELEASE_ASSERT
(
ran
=
=
1
)
;
ran
=
0
;
rb
.
ReadAt
(
bi
[
&
]
(
Maybe
<
ProfileBufferEntryReader
>
&
&
aMaybeEntryReader
)
{
MOZ_RELEASE_ASSERT
(
aMaybeEntryReader
.
isNothing
(
)
)
;
+
+
ran
;
}
)
;
MOZ_RELEASE_ASSERT
(
ran
=
=
1
)
;
rb
.
ReadEach
(
[
]
(
auto
&
&
)
{
MOZ_RELEASE_ASSERT
(
false
)
;
}
)
;
}
;
testOutOfSession
(
)
;
testOutOfSession
(
)
;
rb
.
ClearBefore
(
bi
)
;
testOutOfSession
(
)
;
testOutOfSession
(
)
;
rb
.
Clear
(
)
;
testOutOfSession
(
)
;
testOutOfSession
(
)
;
rb
.
Reset
(
)
;
testOutOfSession
(
)
;
testOutOfSession
(
)
;
constexpr
uint32_t
MBSize
=
32
;
rb
.
Set
(
MakePowerOfTwo
<
BlocksRingBuffer
:
:
Length
MBSize
>
(
)
)
;
constexpr
bool
EMPTY
=
true
;
constexpr
bool
NOT_EMPTY
=
false
;
auto
testInSession
=
[
&
]
(
bool
aExpectEmpty
)
{
MOZ_RELEASE_ASSERT
(
rb
.
BufferLength
(
)
.
isSome
(
)
)
;
BlocksRingBuffer
:
:
State
state
=
rb
.
GetState
(
)
;
if
(
aExpectEmpty
)
{
MOZ_RELEASE_ASSERT
(
state
.
mRangeStart
=
=
state
.
mRangeEnd
)
;
MOZ_RELEASE_ASSERT
(
state
.
mPushedBlockCount
=
=
0
)
;
MOZ_RELEASE_ASSERT
(
state
.
mClearedBlockCount
=
=
0
)
;
}
else
{
MOZ_RELEASE_ASSERT
(
state
.
mRangeStart
<
state
.
mRangeEnd
)
;
MOZ_RELEASE_ASSERT
(
state
.
mPushedBlockCount
>
0
)
;
MOZ_RELEASE_ASSERT
(
state
.
mClearedBlockCount
<
=
state
.
mPushedBlockCount
)
;
}
int32_t
ran
=
0
;
bi
=
rb
.
Put
(
sizeof
(
ran
)
[
&
]
(
Maybe
<
ProfileBufferEntryWriter
>
&
aMaybeEntryWriter
)
{
MOZ_RELEASE_ASSERT
(
aMaybeEntryWriter
.
isSome
(
)
)
;
+
+
ran
;
aMaybeEntryWriter
-
>
WriteObject
(
ran
)
;
return
aMaybeEntryWriter
-
>
CurrentBlockIndex
(
)
;
}
)
;
MOZ_RELEASE_ASSERT
(
ran
=
=
1
)
;
MOZ_RELEASE_ASSERT
(
rb
.
PutFrom
(
&
ran
sizeof
(
ran
)
)
!
=
ProfileBufferBlockIndex
{
}
)
;
MOZ_RELEASE_ASSERT
(
rb
.
PutObject
(
ran
)
!
=
ProfileBufferBlockIndex
{
}
)
;
ran
=
0
;
rb
.
Read
(
[
&
]
(
BlocksRingBuffer
:
:
Reader
*
aReader
)
{
MOZ_RELEASE_ASSERT
(
!
!
aReader
)
;
+
+
ran
;
}
)
;
MOZ_RELEASE_ASSERT
(
ran
=
=
1
)
;
ran
=
0
;
rb
.
ReadEach
(
[
&
]
(
ProfileBufferEntryReader
&
aEntryReader
)
{
MOZ_RELEASE_ASSERT
(
aEntryReader
.
RemainingBytes
(
)
=
=
sizeof
(
ran
)
)
;
MOZ_RELEASE_ASSERT
(
aEntryReader
.
ReadObject
<
decltype
(
ran
)
>
(
)
=
=
1
)
;
+
+
ran
;
}
)
;
MOZ_RELEASE_ASSERT
(
ran
>
=
3
)
;
ran
=
0
;
rb
.
ReadAt
(
ProfileBufferBlockIndex
{
}
[
&
]
(
Maybe
<
ProfileBufferEntryReader
>
&
&
aMaybeEntryReader
)
{
MOZ_RELEASE_ASSERT
(
aMaybeEntryReader
.
isNothing
(
)
)
;
+
+
ran
;
}
)
;
MOZ_RELEASE_ASSERT
(
ran
=
=
1
)
;
ran
=
0
;
rb
.
ReadAt
(
bi
[
&
]
(
Maybe
<
ProfileBufferEntryReader
>
&
&
aMaybeEntryReader
)
{
MOZ_RELEASE_ASSERT
(
aMaybeEntryReader
.
isNothing
(
)
=
=
!
bi
)
;
+
+
ran
;
}
)
;
MOZ_RELEASE_ASSERT
(
ran
=
=
1
)
;
}
;
testInSession
(
EMPTY
)
;
testInSession
(
NOT_EMPTY
)
;
rb
.
Set
(
MakePowerOfTwo
<
BlocksRingBuffer
:
:
Length
32
>
(
)
)
;
MOZ_RELEASE_ASSERT
(
rb
.
BufferLength
(
)
.
isSome
(
)
)
;
rb
.
ReadEach
(
[
]
(
auto
&
&
)
{
MOZ_RELEASE_ASSERT
(
false
)
;
}
)
;
testInSession
(
EMPTY
)
;
testInSession
(
NOT_EMPTY
)
;
rb
.
Reset
(
)
;
testOutOfSession
(
)
;
testOutOfSession
(
)
;
uint8_t
buffer
[
MBSize
*
3
]
;
for
(
size_t
i
=
0
;
i
<
MBSize
*
3
;
+
+
i
)
{
buffer
[
i
]
=
uint8_t
(
'
A
'
+
i
)
;
}
rb
.
Set
(
&
buffer
[
MBSize
]
MakePowerOfTwo
<
BlocksRingBuffer
:
:
Length
MBSize
>
(
)
)
;
MOZ_RELEASE_ASSERT
(
rb
.
BufferLength
(
)
.
isSome
(
)
)
;
rb
.
ReadEach
(
[
]
(
auto
&
&
)
{
MOZ_RELEASE_ASSERT
(
false
)
;
}
)
;
testInSession
(
EMPTY
)
;
testInSession
(
NOT_EMPTY
)
;
rb
.
Reset
(
)
;
testOutOfSession
(
)
;
testOutOfSession
(
)
;
rb
.
Set
(
&
buffer
[
MBSize
]
MakePowerOfTwo
<
BlocksRingBuffer
:
:
Length
MBSize
>
(
)
)
;
MOZ_RELEASE_ASSERT
(
rb
.
BufferLength
(
)
.
isSome
(
)
)
;
rb
.
ReadEach
(
[
]
(
auto
&
&
)
{
MOZ_RELEASE_ASSERT
(
false
)
;
}
)
;
testInSession
(
EMPTY
)
;
testInSession
(
NOT_EMPTY
)
;
rb
.
Reset
(
)
;
uint32_t
changed
=
0
;
for
(
size_t
i
=
MBSize
;
i
<
MBSize
*
2
;
+
+
i
)
{
changed
+
=
(
buffer
[
i
]
=
=
uint8_t
(
'
A
'
+
i
)
)
?
0
:
1
;
}
MOZ_RELEASE_ASSERT
(
changed
>
=
MBSize
*
6
/
8
)
;
for
(
size_t
i
=
0
;
i
<
MBSize
;
+
+
i
)
{
MOZ_RELEASE_ASSERT
(
buffer
[
i
]
=
=
uint8_t
(
'
A
'
+
i
)
)
;
}
for
(
size_t
i
=
MBSize
*
2
;
i
<
MBSize
*
3
;
+
+
i
)
{
MOZ_RELEASE_ASSERT
(
buffer
[
i
]
=
=
uint8_t
(
'
A
'
+
i
)
)
;
}
testOutOfSession
(
)
;
testOutOfSession
(
)
;
printf
(
"
TestBlocksRingBufferUnderlyingBufferChanges
done
\
n
"
)
;
}
void
TestBlocksRingBufferThreading
(
)
{
printf
(
"
TestBlocksRingBufferThreading
.
.
.
\
n
"
)
;
constexpr
uint32_t
MBSize
=
8192
;
uint8_t
buffer
[
MBSize
*
3
]
;
for
(
size_t
i
=
0
;
i
<
MBSize
*
3
;
+
+
i
)
{
buffer
[
i
]
=
uint8_t
(
'
A
'
+
i
)
;
}
BlocksRingBuffer
rb
(
BlocksRingBuffer
:
:
ThreadSafety
:
:
WithMutex
&
buffer
[
MBSize
]
MakePowerOfTwo32
<
MBSize
>
(
)
)
;
std
:
:
atomic
<
bool
>
stopReader
{
false
}
;
std
:
:
thread
reader
(
[
&
]
(
)
{
for
(
;
;
)
{
BlocksRingBuffer
:
:
State
state
=
rb
.
GetState
(
)
;
printf
(
"
Reader
:
range
=
%
llu
.
.
%
llu
(
%
llu
bytes
)
pushed
=
%
llu
cleared
=
%
llu
"
"
(
alive
=
%
llu
)
\
n
"
static_cast
<
unsigned
long
long
>
(
state
.
mRangeStart
.
ConvertToProfileBufferIndex
(
)
)
static_cast
<
unsigned
long
long
>
(
state
.
mRangeEnd
.
ConvertToProfileBufferIndex
(
)
)
static_cast
<
unsigned
long
long
>
(
state
.
mRangeEnd
.
ConvertToProfileBufferIndex
(
)
)
-
static_cast
<
unsigned
long
long
>
(
state
.
mRangeStart
.
ConvertToProfileBufferIndex
(
)
)
static_cast
<
unsigned
long
long
>
(
state
.
mPushedBlockCount
)
static_cast
<
unsigned
long
long
>
(
state
.
mClearedBlockCount
)
static_cast
<
unsigned
long
long
>
(
state
.
mPushedBlockCount
-
state
.
mClearedBlockCount
)
)
;
if
(
stopReader
)
{
break
;
}
:
:
SleepMilli
(
1
)
;
}
}
)
;
constexpr
int
ThreadCount
=
32
;
std
:
:
thread
threads
[
ThreadCount
]
;
for
(
int
threadNo
=
0
;
threadNo
<
ThreadCount
;
+
+
threadNo
)
{
threads
[
threadNo
]
=
std
:
:
thread
(
[
&
]
(
int
aThreadNo
)
{
:
:
SleepMilli
(
1
)
;
constexpr
int
pushCount
=
1024
;
for
(
int
push
=
0
;
push
<
pushCount
;
+
+
push
)
{
rb
.
Put
(
std
:
:
max
(
aThreadNo
int
(
sizeof
(
push
)
)
)
[
&
]
(
Maybe
<
ProfileBufferEntryWriter
>
&
aEW
)
{
MOZ_RELEASE_ASSERT
(
aEW
.
isSome
(
)
)
;
aEW
-
>
WriteObject
(
aThreadNo
*
1000000
+
push
)
;
*
aEW
+
=
aEW
-
>
RemainingBytes
(
)
;
}
)
;
}
}
threadNo
)
;
}
for
(
auto
&
&
thread
:
threads
)
{
thread
.
join
(
)
;
}
stopReader
=
true
;
reader
.
join
(
)
;
uint32_t
changed
=
0
;
for
(
size_t
i
=
MBSize
;
i
<
MBSize
*
2
;
+
+
i
)
{
changed
+
=
(
buffer
[
i
]
=
=
uint8_t
(
'
A
'
+
i
)
)
?
0
:
1
;
}
MOZ_RELEASE_ASSERT
(
changed
>
=
MBSize
*
6
/
8
)
;
for
(
size_t
i
=
0
;
i
<
MBSize
;
+
+
i
)
{
MOZ_RELEASE_ASSERT
(
buffer
[
i
]
=
=
uint8_t
(
'
A
'
+
i
)
)
;
}
for
(
size_t
i
=
MBSize
*
2
;
i
<
MBSize
*
3
;
+
+
i
)
{
MOZ_RELEASE_ASSERT
(
buffer
[
i
]
=
=
uint8_t
(
'
A
'
+
i
)
)
;
}
printf
(
"
TestBlocksRingBufferThreading
done
\
n
"
)
;
}
void
TestBlocksRingBufferSerialization
(
)
{
printf
(
"
TestBlocksRingBufferSerialization
.
.
.
\
n
"
)
;
constexpr
uint32_t
MBSize
=
64
;
uint8_t
buffer
[
MBSize
*
3
]
;
for
(
size_t
i
=
0
;
i
<
MBSize
*
3
;
+
+
i
)
{
buffer
[
i
]
=
uint8_t
(
'
A
'
+
i
)
;
}
BlocksRingBuffer
rb
(
BlocksRingBuffer
:
:
ThreadSafety
:
:
WithMutex
&
buffer
[
MBSize
]
MakePowerOfTwo32
<
MBSize
>
(
)
)
;
#
define
THE_ANSWER
"
The
answer
is
"
const
char
*
theAnswer
=
THE_ANSWER
;
rb
.
PutObjects
(
'
0
'
WrapProfileBufferLiteralCStringPointer
(
THE_ANSWER
)
42
std
:
:
string
(
"
but
pi
=
"
)
3
.
14
)
;
rb
.
ReadEach
(
[
&
]
(
ProfileBufferEntryReader
&
aER
)
{
char
c0
;
const
char
*
answer
;
int
integer
;
std
:
:
string
str
;
double
pi
;
aER
.
ReadIntoObjects
(
c0
answer
integer
str
pi
)
;
MOZ_RELEASE_ASSERT
(
c0
=
=
'
0
'
)
;
MOZ_RELEASE_ASSERT
(
answer
=
=
theAnswer
)
;
MOZ_RELEASE_ASSERT
(
integer
=
=
42
)
;
MOZ_RELEASE_ASSERT
(
str
=
=
"
but
pi
=
"
)
;
MOZ_RELEASE_ASSERT
(
pi
=
=
3
.
14
)
;
}
)
;
rb
.
ReadEach
(
[
&
]
(
ProfileBufferEntryReader
&
aER
)
{
char
c0
=
aER
.
ReadObject
<
char
>
(
)
;
MOZ_RELEASE_ASSERT
(
c0
=
=
'
0
'
)
;
const
char
*
answer
=
aER
.
ReadObject
<
const
char
*
>
(
)
;
MOZ_RELEASE_ASSERT
(
answer
=
=
theAnswer
)
;
int
integer
=
aER
.
ReadObject
<
int
>
(
)
;
MOZ_RELEASE_ASSERT
(
integer
=
=
42
)
;
std
:
:
string
str
=
aER
.
ReadObject
<
std
:
:
string
>
(
)
;
MOZ_RELEASE_ASSERT
(
str
=
=
"
but
pi
=
"
)
;
double
pi
=
aER
.
ReadObject
<
double
>
(
)
;
MOZ_RELEASE_ASSERT
(
pi
=
=
3
.
14
)
;
}
)
;
rb
.
Clear
(
)
;
ProfileBufferBlockIndex
blockIndex
=
rb
.
PutObject
(
123
)
;
MOZ_RELEASE_ASSERT
(
blockIndex
!
=
ProfileBufferBlockIndex
{
}
)
;
rb
.
PutObject
(
blockIndex
)
;
rb
.
Read
(
[
&
]
(
BlocksRingBuffer
:
:
Reader
*
aR
)
{
BlocksRingBuffer
:
:
BlockIterator
it
=
aR
-
>
begin
(
)
;
const
BlocksRingBuffer
:
:
BlockIterator
itEnd
=
aR
-
>
end
(
)
;
MOZ_RELEASE_ASSERT
(
it
!
=
itEnd
)
;
MOZ_RELEASE_ASSERT
(
(
*
it
)
.
ReadObject
<
int
>
(
)
=
=
123
)
;
+
+
it
;
MOZ_RELEASE_ASSERT
(
it
!
=
itEnd
)
;
MOZ_RELEASE_ASSERT
(
(
*
it
)
.
ReadObject
<
ProfileBufferBlockIndex
>
(
)
=
=
blockIndex
)
;
+
+
it
;
MOZ_RELEASE_ASSERT
(
it
=
=
itEnd
)
;
}
)
;
rb
.
Clear
(
)
;
rb
.
PutObjects
(
std
:
:
make_tuple
(
'
0
'
WrapProfileBufferLiteralCStringPointer
(
THE_ANSWER
)
42
std
:
:
string
(
"
but
pi
=
"
)
3
.
14
)
)
;
rb
.
ReadEach
(
[
&
]
(
ProfileBufferEntryReader
&
aER
)
{
MOZ_RELEASE_ASSERT
(
aER
.
ReadObject
<
char
>
(
)
=
=
'
0
'
)
;
MOZ_RELEASE_ASSERT
(
aER
.
ReadObject
<
const
char
*
>
(
)
=
=
theAnswer
)
;
MOZ_RELEASE_ASSERT
(
aER
.
ReadObject
<
int
>
(
)
=
=
42
)
;
MOZ_RELEASE_ASSERT
(
aER
.
ReadObject
<
std
:
:
string
>
(
)
=
=
"
but
pi
=
"
)
;
MOZ_RELEASE_ASSERT
(
aER
.
ReadObject
<
double
>
(
)
=
=
3
.
14
)
;
}
)
;
rb
.
Clear
(
)
;
rb
.
PutObjects
(
MakeTuple
(
'
0
'
WrapProfileBufferLiteralCStringPointer
(
THE_ANSWER
)
42
std
:
:
string
(
"
but
pi
=
"
)
3
.
14
)
)
;
rb
.
ReadEach
(
[
&
]
(
ProfileBufferEntryReader
&
aER
)
{
MOZ_RELEASE_ASSERT
(
aER
.
ReadObject
<
char
>
(
)
=
=
'
0
'
)
;
MOZ_RELEASE_ASSERT
(
aER
.
ReadObject
<
const
char
*
>
(
)
=
=
theAnswer
)
;
MOZ_RELEASE_ASSERT
(
aER
.
ReadObject
<
int
>
(
)
=
=
42
)
;
MOZ_RELEASE_ASSERT
(
aER
.
ReadObject
<
std
:
:
string
>
(
)
=
=
"
but
pi
=
"
)
;
MOZ_RELEASE_ASSERT
(
aER
.
ReadObject
<
double
>
(
)
=
=
3
.
14
)
;
}
)
;
rb
.
Clear
(
)
;
{
UniqueFreePtr
<
char
>
ufps
(
strdup
(
THE_ANSWER
)
)
;
rb
.
PutObjects
(
ufps
)
;
}
rb
.
ReadEach
(
[
&
]
(
ProfileBufferEntryReader
&
aER
)
{
auto
ufps
=
aER
.
ReadObject
<
UniqueFreePtr
<
char
>
>
(
)
;
MOZ_RELEASE_ASSERT
(
!
!
ufps
)
;
MOZ_RELEASE_ASSERT
(
std
:
:
string
(
THE_ANSWER
)
=
=
ufps
.
get
(
)
)
;
}
)
;
rb
.
Clear
(
)
;
int
intArray
[
]
=
{
1
2
3
4
5
}
;
rb
.
PutObjects
(
Span
(
intArray
)
)
;
rb
.
ReadEach
(
[
&
]
(
ProfileBufferEntryReader
&
aER
)
{
int
intArrayOut
[
sizeof
(
intArray
)
/
sizeof
(
intArray
[
0
]
)
]
=
{
0
}
;
auto
outSpan
=
Span
(
intArrayOut
)
;
aER
.
ReadIntoObject
(
outSpan
)
;
for
(
size_t
i
=
0
;
i
<
sizeof
(
intArray
)
/
sizeof
(
intArray
[
0
]
)
;
+
+
i
)
{
MOZ_RELEASE_ASSERT
(
intArrayOut
[
i
]
=
=
intArray
[
i
]
)
;
}
}
)
;
rb
.
Clear
(
)
;
rb
.
PutObjects
(
Maybe
<
int
>
(
Nothing
{
}
)
Maybe
<
int
>
(
Some
(
123
)
)
)
;
rb
.
ReadEach
(
[
&
]
(
ProfileBufferEntryReader
&
aER
)
{
Maybe
<
int
>
mi0
mi1
;
aER
.
ReadIntoObjects
(
mi0
mi1
)
;
MOZ_RELEASE_ASSERT
(
mi0
.
isNothing
(
)
)
;
MOZ_RELEASE_ASSERT
(
mi1
.
isSome
(
)
)
;
MOZ_RELEASE_ASSERT
(
*
mi1
=
=
123
)
;
}
)
;
rb
.
Clear
(
)
;
using
V
=
Variant
<
int
double
int
>
;
V
v0
(
VariantIndex
<
0
>
{
}
123
)
;
V
v1
(
3
.
14
)
;
V
v2
(
VariantIndex
<
2
>
{
}
456
)
;
rb
.
PutObjects
(
v0
v1
v2
)
;
rb
.
ReadEach
(
[
&
]
(
ProfileBufferEntryReader
&
aER
)
{
MOZ_RELEASE_ASSERT
(
aER
.
ReadObject
<
V
>
(
)
=
=
v0
)
;
MOZ_RELEASE_ASSERT
(
aER
.
ReadObject
<
V
>
(
)
=
=
v1
)
;
MOZ_RELEASE_ASSERT
(
aER
.
ReadObject
<
V
>
(
)
=
=
v2
)
;
}
)
;
constexpr
uint32_t
MBSize2
=
MBSize
*
4
;
uint8_t
buffer2
[
MBSize2
*
3
]
;
for
(
size_t
i
=
0
;
i
<
MBSize2
*
3
;
+
+
i
)
{
buffer2
[
i
]
=
uint8_t
(
'
B
'
+
i
)
;
}
BlocksRingBuffer
rb2
(
BlocksRingBuffer
:
:
ThreadSafety
:
:
WithoutMutex
&
buffer2
[
MBSize2
]
MakePowerOfTwo32
<
MBSize2
>
(
)
)
;
rb2
.
PutObject
(
rb
)
;
uint8_t
buffer3
[
MBSize
*
3
]
;
for
(
size_t
i
=
0
;
i
<
MBSize
*
3
;
+
+
i
)
{
buffer3
[
i
]
=
uint8_t
(
'
C
'
+
i
)
;
}
BlocksRingBuffer
rb3
(
BlocksRingBuffer
:
:
ThreadSafety
:
:
WithoutMutex
&
buffer3
[
MBSize
]
MakePowerOfTwo32
<
MBSize
>
(
)
)
;
rb2
.
ReadEach
(
[
&
]
(
ProfileBufferEntryReader
&
aER
)
{
aER
.
ReadIntoObject
(
rb3
)
;
}
)
;
UniquePtr
<
BlocksRingBuffer
>
rb4up
;
rb2
.
ReadEach
(
[
&
]
(
ProfileBufferEntryReader
&
aER
)
{
rb4up
=
aER
.
ReadObject
<
UniquePtr
<
BlocksRingBuffer
>
>
(
)
;
}
)
;
MOZ_RELEASE_ASSERT
(
!
!
rb4up
)
;
rb
.
Clear
(
)
;
rb2
.
Clear
(
)
;
rb3
.
ReadEach
(
[
&
]
(
ProfileBufferEntryReader
&
aER
)
{
MOZ_RELEASE_ASSERT
(
aER
.
ReadObject
<
V
>
(
)
=
=
v0
)
;
MOZ_RELEASE_ASSERT
(
aER
.
ReadObject
<
V
>
(
)
=
=
v1
)
;
MOZ_RELEASE_ASSERT
(
aER
.
ReadObject
<
V
>
(
)
=
=
v2
)
;
}
)
;
rb4up
-
>
ReadEach
(
[
&
]
(
ProfileBufferEntryReader
&
aER
)
{
MOZ_RELEASE_ASSERT
(
aER
.
ReadObject
<
V
>
(
)
=
=
v0
)
;
MOZ_RELEASE_ASSERT
(
aER
.
ReadObject
<
V
>
(
)
=
=
v1
)
;
MOZ_RELEASE_ASSERT
(
aER
.
ReadObject
<
V
>
(
)
=
=
v2
)
;
}
)
;
MOZ_RELEASE_ASSERT
(
rb3
.
GetState
(
)
.
mRangeStart
=
=
rb4up
-
>
GetState
(
)
.
mRangeStart
)
;
MOZ_RELEASE_ASSERT
(
rb3
.
GetState
(
)
.
mRangeEnd
=
=
rb4up
-
>
GetState
(
)
.
mRangeEnd
)
;
MOZ_RELEASE_ASSERT
(
rb3
.
GetState
(
)
.
mPushedBlockCount
=
=
rb4up
-
>
GetState
(
)
.
mPushedBlockCount
)
;
MOZ_RELEASE_ASSERT
(
rb3
.
GetState
(
)
.
mClearedBlockCount
=
=
rb4up
-
>
GetState
(
)
.
mClearedBlockCount
)
;
uint32_t
changed
=
0
;
for
(
size_t
i
=
MBSize
;
i
<
MBSize
*
2
;
+
+
i
)
{
changed
+
=
(
buffer
[
i
]
=
=
uint8_t
(
'
A
'
+
i
)
)
?
0
:
1
;
}
MOZ_RELEASE_ASSERT
(
changed
>
=
MBSize
*
6
/
8
)
;
for
(
size_t
i
=
0
;
i
<
MBSize
;
+
+
i
)
{
MOZ_RELEASE_ASSERT
(
buffer
[
i
]
=
=
uint8_t
(
'
A
'
+
i
)
)
;
}
for
(
size_t
i
=
MBSize
*
2
;
i
<
MBSize
*
3
;
+
+
i
)
{
MOZ_RELEASE_ASSERT
(
buffer
[
i
]
=
=
uint8_t
(
'
A
'
+
i
)
)
;
}
for
(
size_t
i
=
0
;
i
<
MBSize2
;
+
+
i
)
{
MOZ_RELEASE_ASSERT
(
buffer2
[
i
]
=
=
uint8_t
(
'
B
'
+
i
)
)
;
}
for
(
size_t
i
=
MBSize2
*
2
;
i
<
MBSize2
*
3
;
+
+
i
)
{
MOZ_RELEASE_ASSERT
(
buffer2
[
i
]
=
=
uint8_t
(
'
B
'
+
i
)
)
;
}
for
(
size_t
i
=
0
;
i
<
MBSize
;
+
+
i
)
{
MOZ_RELEASE_ASSERT
(
buffer3
[
i
]
=
=
uint8_t
(
'
C
'
+
i
)
)
;
}
for
(
size_t
i
=
MBSize
*
2
;
i
<
MBSize
*
3
;
+
+
i
)
{
MOZ_RELEASE_ASSERT
(
buffer3
[
i
]
=
=
uint8_t
(
'
C
'
+
i
)
)
;
}
printf
(
"
TestBlocksRingBufferSerialization
done
\
n
"
)
;
}
void
TestLiteralEmptyStringView
(
)
{
printf
(
"
TestLiteralEmptyStringView
.
.
.
\
n
"
)
;
static_assert
(
mozilla
:
:
LiteralEmptyStringView
<
char
>
(
)
=
=
std
:
:
string_view
(
"
"
)
)
;
static_assert
(
!
!
mozilla
:
:
LiteralEmptyStringView
<
char
>
(
)
.
data
(
)
)
;
static_assert
(
mozilla
:
:
LiteralEmptyStringView
<
char
>
(
)
.
length
(
)
=
=
0
)
;
static_assert
(
mozilla
:
:
LiteralEmptyStringView
<
char16_t
>
(
)
=
=
std
:
:
basic_string_view
<
char16_t
>
(
u
"
"
)
)
;
static_assert
(
!
!
mozilla
:
:
LiteralEmptyStringView
<
char16_t
>
(
)
.
data
(
)
)
;
static_assert
(
mozilla
:
:
LiteralEmptyStringView
<
char16_t
>
(
)
.
length
(
)
=
=
0
)
;
printf
(
"
TestLiteralEmptyStringView
done
\
n
"
)
;
}
void
TestProfilerStringView
(
)
{
printf
(
"
TestProfilerStringView
.
.
.
\
n
"
)
;
auto
BS8V
=
[
]
(
mozilla
:
:
ProfilerString8View
&
&
aBS8V
)
{
return
std
:
:
move
(
aBS8V
)
;
}
;
MOZ_RELEASE_ASSERT
(
BS8V
(
"
"
)
.
Data
(
)
)
;
MOZ_RELEASE_ASSERT
(
BS8V
(
"
"
)
.
Data
(
)
[
0
]
=
=
'
\
0
'
)
;
MOZ_RELEASE_ASSERT
(
BS8V
(
"
"
)
.
Length
(
)
=
=
0
)
;
MOZ_RELEASE_ASSERT
(
BS8V
(
"
"
)
.
IsLiteral
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
BS8V
(
"
"
)
.
IsReference
(
)
)
;
MOZ_RELEASE_ASSERT
(
BS8V
(
"
hi
"
)
.
Data
(
)
)
;
MOZ_RELEASE_ASSERT
(
BS8V
(
"
hi
"
)
.
Data
(
)
[
0
]
=
=
'
h
'
)
;
MOZ_RELEASE_ASSERT
(
BS8V
(
"
hi
"
)
.
Data
(
)
[
1
]
=
=
'
i
'
)
;
MOZ_RELEASE_ASSERT
(
BS8V
(
"
hi
"
)
.
Data
(
)
[
2
]
=
=
'
\
0
'
)
;
MOZ_RELEASE_ASSERT
(
BS8V
(
"
hi
"
)
.
Length
(
)
=
=
2
)
;
MOZ_RELEASE_ASSERT
(
BS8V
(
"
hi
"
)
.
IsLiteral
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
BS8V
(
"
hi
"
)
.
IsReference
(
)
)
;
MOZ_RELEASE_ASSERT
(
BS8V
(
std
:
:
string_view
(
"
"
)
)
.
Data
(
)
)
;
MOZ_RELEASE_ASSERT
(
BS8V
(
std
:
:
string_view
(
"
"
)
)
.
Data
(
)
[
0
]
=
=
'
\
0
'
)
;
MOZ_RELEASE_ASSERT
(
BS8V
(
std
:
:
string_view
(
"
"
)
)
.
Length
(
)
=
=
0
)
;
MOZ_RELEASE_ASSERT
(
!
BS8V
(
std
:
:
string_view
(
"
"
)
)
.
IsLiteral
(
)
)
;
MOZ_RELEASE_ASSERT
(
BS8V
(
std
:
:
string_view
(
"
"
)
)
.
IsReference
(
)
)
;
MOZ_RELEASE_ASSERT
(
BS8V
(
std
:
:
string_view
(
"
hi
"
)
)
.
Data
(
)
)
;
MOZ_RELEASE_ASSERT
(
BS8V
(
std
:
:
string_view
(
"
hi
"
)
)
.
Data
(
)
[
0
]
=
=
'
h
'
)
;
MOZ_RELEASE_ASSERT
(
BS8V
(
std
:
:
string_view
(
"
hi
"
)
)
.
Data
(
)
[
1
]
=
=
'
i
'
)
;
MOZ_RELEASE_ASSERT
(
BS8V
(
std
:
:
string_view
(
"
hi
"
)
)
.
Data
(
)
[
2
]
=
=
'
\
0
'
)
;
MOZ_RELEASE_ASSERT
(
BS8V
(
std
:
:
string_view
(
"
hi
"
)
)
.
Length
(
)
=
=
2
)
;
MOZ_RELEASE_ASSERT
(
!
BS8V
(
std
:
:
string_view
(
"
hi
"
)
)
.
IsLiteral
(
)
)
;
MOZ_RELEASE_ASSERT
(
BS8V
(
std
:
:
string_view
(
"
hi
"
)
)
.
IsReference
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
std
:
:
string_view
(
)
.
data
(
)
)
;
MOZ_RELEASE_ASSERT
(
BS8V
(
std
:
:
string_view
(
)
)
.
Data
(
)
)
;
MOZ_RELEASE_ASSERT
(
BS8V
(
std
:
:
string_view
(
)
)
.
Data
(
)
[
0
]
=
=
'
\
0
'
)
;
MOZ_RELEASE_ASSERT
(
BS8V
(
std
:
:
string_view
(
)
)
.
Length
(
)
=
=
0
)
;
MOZ_RELEASE_ASSERT
(
BS8V
(
std
:
:
string_view
(
)
)
.
IsLiteral
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
BS8V
(
std
:
:
string_view
(
)
)
.
IsReference
(
)
)
;
MOZ_RELEASE_ASSERT
(
BS8V
(
std
:
:
string
(
"
"
)
)
.
Data
(
)
)
;
MOZ_RELEASE_ASSERT
(
BS8V
(
std
:
:
string
(
"
"
)
)
.
Data
(
)
[
0
]
=
=
'
\
0
'
)
;
MOZ_RELEASE_ASSERT
(
BS8V
(
std
:
:
string
(
"
"
)
)
.
Length
(
)
=
=
0
)
;
MOZ_RELEASE_ASSERT
(
!
BS8V
(
std
:
:
string
(
"
"
)
)
.
IsLiteral
(
)
)
;
MOZ_RELEASE_ASSERT
(
BS8V
(
std
:
:
string
(
"
"
)
)
.
IsReference
(
)
)
;
MOZ_RELEASE_ASSERT
(
BS8V
(
std
:
:
string
(
"
hi
"
)
)
.
Data
(
)
)
;
MOZ_RELEASE_ASSERT
(
BS8V
(
std
:
:
string
(
"
hi
"
)
)
.
Data
(
)
[
0
]
=
=
'
h
'
)
;
MOZ_RELEASE_ASSERT
(
BS8V
(
std
:
:
string
(
"
hi
"
)
)
.
Data
(
)
[
1
]
=
=
'
i
'
)
;
MOZ_RELEASE_ASSERT
(
BS8V
(
std
:
:
string
(
"
hi
"
)
)
.
Data
(
)
[
2
]
=
=
'
\
0
'
)
;
MOZ_RELEASE_ASSERT
(
BS8V
(
std
:
:
string
(
"
hi
"
)
)
.
Length
(
)
=
=
2
)
;
MOZ_RELEASE_ASSERT
(
!
BS8V
(
std
:
:
string
(
"
hi
"
)
)
.
IsLiteral
(
)
)
;
MOZ_RELEASE_ASSERT
(
BS8V
(
std
:
:
string
(
"
hi
"
)
)
.
IsReference
(
)
)
;
MOZ_RELEASE_ASSERT
(
std
:
:
string
(
)
.
data
(
)
)
;
MOZ_RELEASE_ASSERT
(
BS8V
(
std
:
:
string
(
)
)
.
Data
(
)
)
;
MOZ_RELEASE_ASSERT
(
BS8V
(
std
:
:
string
(
)
)
.
Data
(
)
[
0
]
=
=
'
\
0
'
)
;
MOZ_RELEASE_ASSERT
(
BS8V
(
std
:
:
string
(
)
)
.
Length
(
)
=
=
0
)
;
MOZ_RELEASE_ASSERT
(
!
BS8V
(
std
:
:
string
(
)
)
.
IsLiteral
(
)
)
;
MOZ_RELEASE_ASSERT
(
BS8V
(
std
:
:
string
(
)
)
.
IsReference
(
)
)
;
class
FakeNsCString
{
public
:
FakeNsCString
(
const
char
*
aData
size_t
aLength
bool
aIsLiteral
)
:
mData
(
aData
)
mLength
(
aLength
)
mIsLiteral
(
aIsLiteral
)
{
}
const
char
*
Data
(
)
const
{
return
mData
;
}
size_t
Length
(
)
const
{
return
mLength
;
}
bool
IsLiteral
(
)
const
{
return
mIsLiteral
;
}
private
:
const
char
*
mData
;
size_t
mLength
;
bool
mIsLiteral
;
}
;
MOZ_RELEASE_ASSERT
(
BS8V
(
FakeNsCString
(
nullptr
0
true
)
)
.
Data
(
)
)
;
MOZ_RELEASE_ASSERT
(
BS8V
(
FakeNsCString
(
nullptr
0
true
)
)
.
Data
(
)
[
0
]
=
=
'
\
0
'
)
;
MOZ_RELEASE_ASSERT
(
BS8V
(
FakeNsCString
(
nullptr
0
true
)
)
.
Length
(
)
=
=
0
)
;
MOZ_RELEASE_ASSERT
(
BS8V
(
FakeNsCString
(
nullptr
0
true
)
)
.
IsLiteral
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
BS8V
(
FakeNsCString
(
nullptr
0
true
)
)
.
IsReference
(
)
)
;
MOZ_RELEASE_ASSERT
(
BS8V
(
FakeNsCString
(
"
"
0
true
)
)
.
Data
(
)
)
;
MOZ_RELEASE_ASSERT
(
BS8V
(
FakeNsCString
(
"
"
0
true
)
)
.
Data
(
)
[
0
]
=
=
'
\
0
'
)
;
MOZ_RELEASE_ASSERT
(
BS8V
(
FakeNsCString
(
"
"
0
true
)
)
.
Length
(
)
=
=
0
)
;
MOZ_RELEASE_ASSERT
(
BS8V
(
FakeNsCString
(
"
"
0
true
)
)
.
IsLiteral
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
BS8V
(
FakeNsCString
(
"
"
0
true
)
)
.
IsReference
(
)
)
;
MOZ_RELEASE_ASSERT
(
BS8V
(
FakeNsCString
(
"
hi
"
2
true
)
)
.
Data
(
)
)
;
MOZ_RELEASE_ASSERT
(
BS8V
(
FakeNsCString
(
"
hi
"
2
true
)
)
.
Data
(
)
[
0
]
=
=
'
h
'
)
;
MOZ_RELEASE_ASSERT
(
BS8V
(
FakeNsCString
(
"
hi
"
2
true
)
)
.
Data
(
)
[
1
]
=
=
'
i
'
)
;
MOZ_RELEASE_ASSERT
(
BS8V
(
FakeNsCString
(
"
hi
"
2
true
)
)
.
Data
(
)
[
2
]
=
=
'
\
0
'
)
;
MOZ_RELEASE_ASSERT
(
BS8V
(
FakeNsCString
(
"
hi
"
2
true
)
)
.
Length
(
)
=
=
2
)
;
MOZ_RELEASE_ASSERT
(
BS8V
(
FakeNsCString
(
"
hi
"
2
true
)
)
.
IsLiteral
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
BS8V
(
FakeNsCString
(
"
hi
"
2
true
)
)
.
IsReference
(
)
)
;
MOZ_RELEASE_ASSERT
(
BS8V
(
FakeNsCString
(
"
hi
"
2
false
)
)
.
Data
(
)
)
;
MOZ_RELEASE_ASSERT
(
BS8V
(
FakeNsCString
(
"
hi
"
2
false
)
)
.
Data
(
)
[
0
]
=
=
'
h
'
)
;
MOZ_RELEASE_ASSERT
(
BS8V
(
FakeNsCString
(
"
hi
"
2
false
)
)
.
Data
(
)
[
1
]
=
=
'
i
'
)
;
MOZ_RELEASE_ASSERT
(
BS8V
(
FakeNsCString
(
"
hi
"
2
false
)
)
.
Data
(
)
[
2
]
=
=
'
\
0
'
)
;
MOZ_RELEASE_ASSERT
(
BS8V
(
FakeNsCString
(
"
hi
"
2
false
)
)
.
Length
(
)
=
=
2
)
;
MOZ_RELEASE_ASSERT
(
!
BS8V
(
FakeNsCString
(
"
hi
"
2
false
)
)
.
IsLiteral
(
)
)
;
MOZ_RELEASE_ASSERT
(
BS8V
(
FakeNsCString
(
"
hi
"
2
false
)
)
.
IsReference
(
)
)
;
constexpr
size_t
bufferMaxSize
=
1024
;
constexpr
ProfileChunkedBuffer
:
:
Length
chunkMinSize
=
128
;
ProfileBufferChunkManagerWithLocalLimit
cm
(
bufferMaxSize
chunkMinSize
)
;
ProfileChunkedBuffer
cb
(
ProfileChunkedBuffer
:
:
ThreadSafety
:
:
WithMutex
cm
)
;
MOZ_RELEASE_ASSERT
(
cb
.
PutObject
(
BS8V
(
"
hi
"
)
)
)
;
{
unsigned
read
=
0
;
ProfilerString8View
outerBS8V
;
cb
.
ReadEach
(
[
&
]
(
ProfileBufferEntryReader
&
aER
)
{
+
+
read
;
auto
bs8v
=
aER
.
ReadObject
<
ProfilerString8View
>
(
)
;
MOZ_RELEASE_ASSERT
(
bs8v
.
Data
(
)
)
;
MOZ_RELEASE_ASSERT
(
bs8v
.
Data
(
)
[
0
]
=
=
'
h
'
)
;
MOZ_RELEASE_ASSERT
(
bs8v
.
Data
(
)
[
1
]
=
=
'
i
'
)
;
MOZ_RELEASE_ASSERT
(
bs8v
.
Data
(
)
[
2
]
=
=
'
\
0
'
)
;
MOZ_RELEASE_ASSERT
(
bs8v
.
Length
(
)
=
=
2
)
;
MOZ_RELEASE_ASSERT
(
bs8v
.
IsLiteral
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
bs8v
.
IsReference
(
)
)
;
outerBS8V
=
std
:
:
move
(
bs8v
)
;
}
)
;
MOZ_RELEASE_ASSERT
(
read
=
=
1
)
;
MOZ_RELEASE_ASSERT
(
outerBS8V
.
Data
(
)
)
;
MOZ_RELEASE_ASSERT
(
outerBS8V
.
Data
(
)
[
0
]
=
=
'
h
'
)
;
MOZ_RELEASE_ASSERT
(
outerBS8V
.
Data
(
)
[
1
]
=
=
'
i
'
)
;
MOZ_RELEASE_ASSERT
(
outerBS8V
.
Data
(
)
[
2
]
=
=
'
\
0
'
)
;
MOZ_RELEASE_ASSERT
(
outerBS8V
.
Length
(
)
=
=
2
)
;
MOZ_RELEASE_ASSERT
(
outerBS8V
.
IsLiteral
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
outerBS8V
.
IsReference
(
)
)
;
}
cb
.
Clear
(
)
;
std
:
:
string
hiString
(
"
hi
"
)
;
MOZ_RELEASE_ASSERT
(
cb
.
PutObject
(
BS8V
(
hiString
)
)
)
;
{
unsigned
read
=
0
;
ProfilerString8View
outerBS8V
;
cb
.
ReadEach
(
[
&
]
(
ProfileBufferEntryReader
&
aER
)
{
+
+
read
;
auto
bs8v
=
aER
.
ReadObject
<
ProfilerString8View
>
(
)
;
MOZ_RELEASE_ASSERT
(
bs8v
.
Data
(
)
)
;
MOZ_RELEASE_ASSERT
(
bs8v
.
Data
(
)
!
=
hiString
.
data
(
)
)
;
MOZ_RELEASE_ASSERT
(
bs8v
.
Data
(
)
[
0
]
=
=
'
h
'
)
;
MOZ_RELEASE_ASSERT
(
bs8v
.
Data
(
)
[
1
]
=
=
'
i
'
)
;
MOZ_RELEASE_ASSERT
(
bs8v
.
Data
(
)
[
2
]
=
=
'
\
0
'
)
;
MOZ_RELEASE_ASSERT
(
bs8v
.
Length
(
)
=
=
2
)
;
MOZ_RELEASE_ASSERT
(
!
bs8v
.
IsLiteral
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
bs8v
.
IsReference
(
)
)
;
outerBS8V
=
std
:
:
move
(
bs8v
)
;
MOZ_RELEASE_ASSERT
(
bs8v
.
Length
(
)
=
=
0
)
;
}
)
;
MOZ_RELEASE_ASSERT
(
read
=
=
1
)
;
MOZ_RELEASE_ASSERT
(
outerBS8V
.
Data
(
)
)
;
MOZ_RELEASE_ASSERT
(
outerBS8V
.
Data
(
)
!
=
hiString
.
data
(
)
)
;
MOZ_RELEASE_ASSERT
(
outerBS8V
.
Data
(
)
[
0
]
=
=
'
h
'
)
;
MOZ_RELEASE_ASSERT
(
outerBS8V
.
Data
(
)
[
1
]
=
=
'
i
'
)
;
MOZ_RELEASE_ASSERT
(
outerBS8V
.
Data
(
)
[
2
]
=
=
'
\
0
'
)
;
MOZ_RELEASE_ASSERT
(
outerBS8V
.
Length
(
)
=
=
2
)
;
MOZ_RELEASE_ASSERT
(
!
outerBS8V
.
IsLiteral
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
outerBS8V
.
IsReference
(
)
)
;
}
printf
(
"
TestProfilerStringView
done
\
n
"
)
;
}
void
TestProfilerDependencies
(
)
{
TestPowerOfTwoMask
(
)
;
TestPowerOfTwo
(
)
;
TestLEB128
(
)
;
TestChunk
(
)
;
TestChunkManagerSingle
(
)
;
TestChunkManagerWithLocalLimit
(
)
;
TestControlledChunkManagerUpdate
(
)
;
TestControlledChunkManagerWithLocalLimit
(
)
;
TestChunkedBuffer
(
)
;
TestChunkedBufferSingle
(
)
;
TestModuloBuffer
(
)
;
TestBlocksRingBufferAPI
(
)
;
TestBlocksRingBufferUnderlyingBufferChanges
(
)
;
TestBlocksRingBufferThreading
(
)
;
TestBlocksRingBufferSerialization
(
)
;
TestLiteralEmptyStringView
(
)
;
TestProfilerStringView
(
)
;
}
class
BaseTestMarkerPayload
:
public
baseprofiler
:
:
ProfilerMarkerPayload
{
public
:
explicit
BaseTestMarkerPayload
(
int
aData
)
:
mData
(
aData
)
{
}
int
GetData
(
)
const
{
return
mData
;
}
static
UniquePtr
<
ProfilerMarkerPayload
>
Deserialize
(
ProfileBufferEntryReader
&
aEntryReader
)
;
ProfileBufferEntryWriter
:
:
Length
TagAndSerializationBytes
(
)
const
override
;
void
SerializeTagAndPayload
(
ProfileBufferEntryWriter
&
aEntryWriter
)
const
override
;
void
StreamPayload
(
:
:
mozilla
:
:
baseprofiler
:
:
SpliceableJSONWriter
&
aWriter
const
:
:
mozilla
:
:
TimeStamp
&
aProcessStartTime
:
:
mozilla
:
:
baseprofiler
:
:
UniqueStacks
&
aUniqueStacks
)
const
override
;
private
:
BaseTestMarkerPayload
(
CommonProps
&
&
aProps
int
aData
)
:
baseprofiler
:
:
ProfilerMarkerPayload
(
std
:
:
move
(
aProps
)
)
mData
(
aData
)
{
}
int
mData
;
}
;
UniquePtr
<
baseprofiler
:
:
ProfilerMarkerPayload
>
BaseTestMarkerPayload
:
:
Deserialize
(
ProfileBufferEntryReader
&
aEntryReader
)
{
CommonProps
props
=
DeserializeCommonProps
(
aEntryReader
)
;
int
data
=
aEntryReader
.
ReadObject
<
int
>
(
)
;
return
UniquePtr
<
baseprofiler
:
:
ProfilerMarkerPayload
>
(
new
BaseTestMarkerPayload
(
std
:
:
move
(
props
)
data
)
)
;
}
ProfileBufferEntryWriter
:
:
Length
BaseTestMarkerPayload
:
:
TagAndSerializationBytes
(
)
const
{
return
CommonPropsTagAndSerializationBytes
(
)
+
sizeof
(
int
)
;
}
void
BaseTestMarkerPayload
:
:
SerializeTagAndPayload
(
ProfileBufferEntryWriter
&
aEntryWriter
)
const
{
static
const
DeserializerTag
tag
=
TagForDeserializer
(
Deserialize
)
;
SerializeTagAndCommonProps
(
tag
aEntryWriter
)
;
aEntryWriter
.
WriteObject
(
mData
)
;
}
void
BaseTestMarkerPayload
:
:
StreamPayload
(
baseprofiler
:
:
SpliceableJSONWriter
&
aWriter
const
TimeStamp
&
aProcessStartTime
baseprofiler
:
:
UniqueStacks
&
aUniqueStacks
)
const
{
aWriter
.
IntProperty
(
"
data
"
mData
)
;
}
void
TestProfilerMarkerSerialization
(
)
{
printf
(
"
TestProfilerMarkerSerialization
.
.
.
\
n
"
)
;
constexpr
uint32_t
MBSize
=
256
;
uint8_t
buffer
[
MBSize
*
3
]
;
for
(
size_t
i
=
0
;
i
<
MBSize
*
3
;
+
+
i
)
{
buffer
[
i
]
=
uint8_t
(
'
A
'
+
i
)
;
}
BlocksRingBuffer
rb
(
BlocksRingBuffer
:
:
ThreadSafety
:
:
WithMutex
&
buffer
[
MBSize
]
MakePowerOfTwo32
<
MBSize
>
(
)
)
;
constexpr
int
data
=
42
;
{
BaseTestMarkerPayload
payload
(
data
)
;
rb
.
PutObject
(
static_cast
<
const
baseprofiler
:
:
ProfilerMarkerPayload
*
>
(
&
payload
)
)
;
}
int
read
=
0
;
rb
.
ReadEach
(
[
&
]
(
ProfileBufferEntryReader
&
aER
)
{
UniquePtr
<
baseprofiler
:
:
ProfilerMarkerPayload
>
payload
=
aER
.
ReadObject
<
UniquePtr
<
baseprofiler
:
:
ProfilerMarkerPayload
>
>
(
)
;
MOZ_RELEASE_ASSERT
(
!
!
payload
)
;
+
+
read
;
BaseTestMarkerPayload
*
testPayload
=
static_cast
<
BaseTestMarkerPayload
*
>
(
payload
.
get
(
)
)
;
MOZ_RELEASE_ASSERT
(
testPayload
)
;
MOZ_RELEASE_ASSERT
(
testPayload
-
>
GetData
(
)
=
=
data
)
;
}
)
;
MOZ_RELEASE_ASSERT
(
read
=
=
1
)
;
for
(
size_t
i
=
0
;
i
<
MBSize
;
+
+
i
)
{
MOZ_RELEASE_ASSERT
(
buffer
[
i
]
=
=
uint8_t
(
'
A
'
+
i
)
)
;
}
for
(
size_t
i
=
MBSize
*
2
;
i
<
MBSize
*
3
;
+
+
i
)
{
MOZ_RELEASE_ASSERT
(
buffer
[
i
]
=
=
uint8_t
(
'
A
'
+
i
)
)
;
}
printf
(
"
TestProfilerMarkerSerialization
done
\
n
"
)
;
}
static
constexpr
size_t
NextDepth
(
size_t
aDepth
)
{
constexpr
size_t
MAX_DEPTH
=
128
;
return
(
aDepth
<
MAX_DEPTH
)
?
(
aDepth
+
1
)
:
aDepth
;
}
Atomic
<
bool
Relaxed
>
sStopFibonacci
;
template
<
size_t
DEPTH
=
0
>
MOZ_NEVER_INLINE
unsigned
long
long
Fibonacci
(
unsigned
long
long
n
)
{
AUTO_BASE_PROFILER_LABEL_DYNAMIC_STRING
(
"
fib
"
OTHER
std
:
:
to_string
(
DEPTH
)
)
;
if
(
n
=
=
0
)
{
return
0
;
}
if
(
n
=
=
1
)
{
return
1
;
}
if
(
DEPTH
<
5
&
&
sStopFibonacci
)
{
return
1
'
000
'
000
'
000
;
}
TimeStamp
start
=
TimeStamp
:
:
NowUnfuzzed
(
)
;
static
constexpr
size_t
MAX_MARKER_DEPTH
=
10
;
unsigned
long
long
f2
=
Fibonacci
<
NextDepth
(
DEPTH
)
>
(
n
-
2
)
;
if
(
DEPTH
=
=
0
)
{
BASE_PROFILER_MARKER_UNTYPED
(
"
Half
-
way
through
Fibonacci
"
OTHER
)
;
}
unsigned
long
long
f1
=
Fibonacci
<
NextDepth
(
DEPTH
)
>
(
n
-
1
)
;
if
(
DEPTH
<
MAX_MARKER_DEPTH
)
{
BASE_PROFILER_MARKER_TEXT
(
"
fib
"
OTHER
.
WithOptions
(
MarkerTiming
:
:
IntervalUntilNowFrom
(
start
)
)
std
:
:
to_string
(
DEPTH
)
)
;
}
return
f2
+
f1
;
}
void
TestProfiler
(
)
{
printf
(
"
TestProfiler
starting
-
-
pid
:
%
d
tid
:
%
d
\
n
"
baseprofiler
:
:
profiler_current_process_id
(
)
baseprofiler
:
:
profiler_current_thread_id
(
)
)
;
TestProfilerDependencies
(
)
;
TestProfilerMarkerSerialization
(
)
;
{
printf
(
"
profiler_init
(
)
.
.
.
\
n
"
)
;
AUTO_BASE_PROFILER_INIT
;
MOZ_RELEASE_ASSERT
(
!
baseprofiler
:
:
profiler_is_active
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
baseprofiler
:
:
profiler_thread_is_being_profiled
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
baseprofiler
:
:
profiler_thread_is_sleeping
(
)
)
;
printf
(
"
profiler_start
(
)
.
.
.
\
n
"
)
;
Vector
<
const
char
*
>
filters
;
MOZ_RELEASE_ASSERT
(
filters
.
append
(
"
"
)
)
;
const
uint32_t
features
=
baseprofiler
:
:
ProfilerFeature
:
:
Leaf
|
baseprofiler
:
:
ProfilerFeature
:
:
StackWalk
|
baseprofiler
:
:
ProfilerFeature
:
:
Threads
;
baseprofiler
:
:
profiler_start
(
baseprofiler
:
:
BASE_PROFILER_DEFAULT_ENTRIES
BASE_PROFILER_DEFAULT_INTERVAL
features
filters
.
begin
(
)
filters
.
length
(
)
)
;
MOZ_RELEASE_ASSERT
(
baseprofiler
:
:
profiler_is_active
(
)
)
;
MOZ_RELEASE_ASSERT
(
baseprofiler
:
:
profiler_thread_is_being_profiled
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
baseprofiler
:
:
profiler_thread_is_sleeping
(
)
)
;
sStopFibonacci
=
false
;
std
:
:
thread
threadFib
(
[
]
(
)
{
AUTO_BASE_PROFILER_REGISTER_THREAD
(
"
fibonacci
"
)
;
SleepMilli
(
5
)
;
auto
cause
=
baseprofiler
:
:
profiler_capture_backtrace
(
)
;
AUTO_BASE_PROFILER_MARKER_TEXT
(
"
fibonacci
"
OTHER
.
WithOptions
(
MarkerStack
:
:
TakeBacktrace
(
std
:
:
move
(
cause
)
)
)
"
First
leaf
call
"
)
;
static
const
unsigned
long
long
fibStart
=
37
;
printf
(
"
Fibonacci
(
%
llu
)
.
.
.
\
n
"
fibStart
)
;
AUTO_BASE_PROFILER_LABEL
(
"
Label
around
Fibonacci
"
OTHER
)
;
unsigned
long
long
f
=
Fibonacci
(
fibStart
)
;
printf
(
"
Fibonacci
(
%
llu
)
=
%
llu
\
n
"
fibStart
f
)
;
}
)
;
std
:
:
thread
threadCancelFib
(
[
]
(
)
{
AUTO_BASE_PROFILER_REGISTER_THREAD
(
"
fibonacci
canceller
"
)
;
SleepMilli
(
5
)
;
AUTO_BASE_PROFILER_MARKER_TEXT
(
"
fibonacci
"
OTHER
"
Canceller
"
)
;
static
const
int
waitMaxSeconds
=
10
;
for
(
int
i
=
0
;
i
<
waitMaxSeconds
;
+
+
i
)
{
if
(
sStopFibonacci
)
{
AUTO_BASE_PROFILER_LABEL_DYNAMIC_STRING
(
"
fibCancel
"
OTHER
std
:
:
to_string
(
i
)
)
;
return
;
}
AUTO_BASE_PROFILER_THREAD_SLEEP
;
SleepMilli
(
1000
)
;
}
AUTO_BASE_PROFILER_LABEL_DYNAMIC_STRING
(
"
fibCancel
"
OTHER
"
Cancelling
!
"
)
;
sStopFibonacci
=
true
;
}
)
;
{
AUTO_BASE_PROFILER_MARKER_TEXT
(
"
main
thread
"
OTHER
"
joining
fibonacci
thread
"
)
;
AUTO_BASE_PROFILER_THREAD_SLEEP
;
threadFib
.
join
(
)
;
}
{
AUTO_BASE_PROFILER_MARKER_TEXT
(
"
main
thread
"
OTHER
"
joining
fibonacci
-
canceller
thread
"
)
;
sStopFibonacci
=
true
;
AUTO_BASE_PROFILER_THREAD_SLEEP
;
threadCancelFib
.
join
(
)
;
}
baseprofiler
:
:
profiler_add_marker
(
"
TracingMarkerPayload
"
baseprofiler
:
:
ProfilingCategoryPair
:
:
OTHER
baseprofiler
:
:
TracingMarkerPayload
(
"
category
"
baseprofiler
:
:
TRACING_EVENT
)
)
;
auto
cause
=
#
if
defined
(
__linux__
)
|
|
defined
(
__ANDROID__
)
decltype
(
baseprofiler
:
:
profiler_get_backtrace
(
)
)
{
}
;
#
else
baseprofiler
:
:
profiler_get_backtrace
(
)
;
#
endif
baseprofiler
:
:
profiler_add_marker
(
"
FileIOMarkerPayload
"
baseprofiler
:
:
ProfilingCategoryPair
:
:
OTHER
baseprofiler
:
:
FileIOMarkerPayload
(
"
operation
"
"
source
"
"
filename
"
TimeStamp
:
:
NowUnfuzzed
(
)
TimeStamp
:
:
NowUnfuzzed
(
)
std
:
:
move
(
cause
)
)
)
;
baseprofiler
:
:
AddMarker
<
mozilla
:
:
baseprofiler
:
:
markers
:
:
FileIO
>
(
"
m2fileio
"
mozilla
:
:
baseprofiler
:
:
category
:
:
OTHER
"
op2
"
"
src2
"
"
f2
"
MarkerThreadId
{
}
)
;
baseprofiler
:
:
AddMarker
<
mozilla
:
:
baseprofiler
:
:
markers
:
:
FileIO
>
(
"
m2fileio
-
capture
"
mozilla
:
:
baseprofiler
:
:
category
:
:
OTHER
.
WithOptions
(
MarkerStack
:
:
Capture
(
)
)
"
op2
"
"
src2
"
"
f2
"
MarkerThreadId
{
}
)
;
baseprofiler
:
:
AddMarker
<
mozilla
:
:
baseprofiler
:
:
markers
:
:
FileIO
>
(
"
m2fileio
-
take
-
backtrace
"
mozilla
:
:
baseprofiler
:
:
category
:
:
OTHER
.
WithOptions
(
MarkerStack
:
:
TakeBacktrace
(
baseprofiler
:
:
profiler_capture_backtrace
(
)
)
)
"
op2
"
"
src2
"
"
f2
"
MarkerThreadId
{
}
)
;
baseprofiler
:
:
profiler_add_marker
(
"
UserTimingMarkerPayload
"
baseprofiler
:
:
ProfilingCategoryPair
:
:
OTHER
baseprofiler
:
:
UserTimingMarkerPayload
(
"
name
"
TimeStamp
:
:
NowUnfuzzed
(
)
Nothing
{
}
)
)
;
baseprofiler
:
:
profiler_add_marker
(
"
HangMarkerPayload
"
baseprofiler
:
:
ProfilingCategoryPair
:
:
OTHER
baseprofiler
:
:
HangMarkerPayload
(
TimeStamp
:
:
NowUnfuzzed
(
)
TimeStamp
:
:
NowUnfuzzed
(
)
)
)
;
baseprofiler
:
:
profiler_add_marker
(
"
LongTaskMarkerPayload
"
baseprofiler
:
:
ProfilingCategoryPair
:
:
OTHER
baseprofiler
:
:
LongTaskMarkerPayload
(
TimeStamp
:
:
NowUnfuzzed
(
)
TimeStamp
:
:
NowUnfuzzed
(
)
)
)
;
{
std
:
:
string
s
=
"
text
payload
"
;
baseprofiler
:
:
profiler_add_marker
(
"
TextMarkerPayload
"
baseprofiler
:
:
ProfilingCategoryPair
:
:
OTHER
baseprofiler
:
:
TextMarkerPayload
(
s
TimeStamp
:
:
NowUnfuzzed
(
)
TimeStamp
:
:
NowUnfuzzed
(
)
)
)
;
}
baseprofiler
:
:
profiler_add_marker
(
"
LogMarkerPayload
"
baseprofiler
:
:
ProfilingCategoryPair
:
:
OTHER
baseprofiler
:
:
LogMarkerPayload
(
"
module
"
"
text
"
TimeStamp
:
:
NowUnfuzzed
(
)
)
)
;
MOZ_RELEASE_ASSERT
(
baseprofiler
:
:
AddMarker
(
"
markers
2
.
0
without
options
"
mozilla
:
:
baseprofiler
:
:
category
:
:
OTHER
)
)
;
MOZ_RELEASE_ASSERT
(
baseprofiler
:
:
AddMarker
(
"
markers
2
.
0
with
option
"
mozilla
:
:
baseprofiler
:
:
category
:
:
OTHER
.
WithOptions
(
MarkerInnerWindowId
(
123
)
)
)
)
;
MOZ_RELEASE_ASSERT
(
baseprofiler
:
:
AddMarker
<
>
(
"
default
-
templated
markers
2
.
0
without
options
"
mozilla
:
:
baseprofiler
:
:
category
:
:
OTHER
)
)
;
MOZ_RELEASE_ASSERT
(
baseprofiler
:
:
AddMarker
<
>
(
"
default
-
templated
markers
2
.
0
with
option
"
mozilla
:
:
baseprofiler
:
:
category
:
:
OTHER
.
WithOptions
(
MarkerInnerWindowId
(
123
)
)
)
)
;
MOZ_RELEASE_ASSERT
(
baseprofiler
:
:
AddMarker
<
:
:
mozilla
:
:
baseprofiler
:
:
markers
:
:
NoPayload
>
(
"
explicitly
-
default
-
templated
markers
2
.
0
without
options
"
mozilla
:
:
baseprofiler
:
:
category
:
:
OTHER
)
)
;
MOZ_RELEASE_ASSERT
(
baseprofiler
:
:
AddMarker
<
:
:
mozilla
:
:
baseprofiler
:
:
markers
:
:
NoPayload
>
(
"
explicitly
-
default
-
templated
markers
2
.
0
with
option
"
mozilla
:
:
baseprofiler
:
:
category
:
:
OTHER
.
WithOptions
(
MarkerInnerWindowId
(
123
)
)
)
)
;
MOZ_RELEASE_ASSERT
(
baseprofiler
:
:
AddMarker
<
mozilla
:
:
baseprofiler
:
:
markers
:
:
Tracing
>
(
"
tracing
"
mozilla
:
:
baseprofiler
:
:
category
:
:
OTHER
"
category
"
)
)
;
MOZ_RELEASE_ASSERT
(
baseprofiler
:
:
AddMarker
<
mozilla
:
:
baseprofiler
:
:
markers
:
:
UserTimingMark
>
(
"
mark
"
mozilla
:
:
baseprofiler
:
:
category
:
:
OTHER
"
mark
name
"
)
)
;
MOZ_RELEASE_ASSERT
(
baseprofiler
:
:
AddMarker
<
mozilla
:
:
baseprofiler
:
:
markers
:
:
UserTimingMeasure
>
(
"
measure
"
mozilla
:
:
baseprofiler
:
:
category
:
:
OTHER
"
measure
name
"
Some
(
ProfilerString8View
(
"
start
"
)
)
Some
(
ProfilerString8View
(
"
end
"
)
)
)
)
;
MOZ_RELEASE_ASSERT
(
baseprofiler
:
:
AddMarker
<
mozilla
:
:
baseprofiler
:
:
markers
:
:
Hang
>
(
"
hang
"
mozilla
:
:
baseprofiler
:
:
category
:
:
OTHER
)
)
;
MOZ_RELEASE_ASSERT
(
baseprofiler
:
:
AddMarker
<
mozilla
:
:
baseprofiler
:
:
markers
:
:
LongTask
>
(
"
longtask
"
mozilla
:
:
baseprofiler
:
:
category
:
:
OTHER
)
)
;
MOZ_RELEASE_ASSERT
(
baseprofiler
:
:
AddMarker
<
mozilla
:
:
baseprofiler
:
:
markers
:
:
Text
>
(
"
text
"
mozilla
:
:
baseprofiler
:
:
category
:
:
OTHER
"
text
text
"
)
)
;
MOZ_RELEASE_ASSERT
(
baseprofiler
:
:
AddMarker
<
mozilla
:
:
baseprofiler
:
:
markers
:
:
Log
>
(
"
log
"
mozilla
:
:
baseprofiler
:
:
category
:
:
OTHER
"
module
"
"
text
"
)
)
;
MOZ_RELEASE_ASSERT
(
baseprofiler
:
:
AddMarker
<
mozilla
:
:
baseprofiler
:
:
markers
:
:
MediaSample
>
(
"
media
sample
"
mozilla
:
:
baseprofiler
:
:
category
:
:
OTHER
123
456
)
)
;
printf
(
"
Sleep
1s
.
.
.
\
n
"
)
;
{
AUTO_BASE_PROFILER_THREAD_SLEEP
;
SleepMilli
(
1000
)
;
}
Maybe
<
baseprofiler
:
:
ProfilerBufferInfo
>
info
=
baseprofiler
:
:
profiler_get_buffer_info
(
)
;
MOZ_RELEASE_ASSERT
(
info
.
isSome
(
)
)
;
printf
(
"
Profiler
buffer
range
:
%
llu
.
.
%
llu
(
%
llu
bytes
)
\
n
"
static_cast
<
unsigned
long
long
>
(
info
-
>
mRangeStart
)
static_cast
<
unsigned
long
long
>
(
info
-
>
mRangeEnd
)
(
static_cast
<
unsigned
long
long
>
(
info
-
>
mRangeEnd
)
-
static_cast
<
unsigned
long
long
>
(
info
-
>
mRangeStart
)
)
*
9
)
;
printf
(
"
Stats
:
min
(
ns
)
.
.
mean
(
ns
)
.
.
max
(
ns
)
[
count
]
\
n
"
)
;
printf
(
"
-
Intervals
:
%
7
.
1f
.
.
%
7
.
1f
.
.
%
7
.
1f
[
%
u
]
\
n
"
info
-
>
mIntervalsNs
.
min
info
-
>
mIntervalsNs
.
sum
/
info
-
>
mIntervalsNs
.
n
info
-
>
mIntervalsNs
.
max
info
-
>
mIntervalsNs
.
n
)
;
printf
(
"
-
Overheads
:
%
7
.
1f
.
.
%
7
.
1f
.
.
%
7
.
1f
[
%
u
]
\
n
"
info
-
>
mOverheadsNs
.
min
info
-
>
mOverheadsNs
.
sum
/
info
-
>
mOverheadsNs
.
n
info
-
>
mOverheadsNs
.
max
info
-
>
mOverheadsNs
.
n
)
;
printf
(
"
-
Locking
:
%
7
.
1f
.
.
%
7
.
1f
.
.
%
7
.
1f
[
%
u
]
\
n
"
info
-
>
mLockingsNs
.
min
info
-
>
mLockingsNs
.
sum
/
info
-
>
mLockingsNs
.
n
info
-
>
mLockingsNs
.
max
info
-
>
mLockingsNs
.
n
)
;
printf
(
"
-
Clearning
:
%
7
.
1f
.
.
%
7
.
1f
.
.
%
7
.
1f
[
%
u
]
\
n
"
info
-
>
mCleaningsNs
.
min
info
-
>
mCleaningsNs
.
sum
/
info
-
>
mCleaningsNs
.
n
info
-
>
mCleaningsNs
.
max
info
-
>
mCleaningsNs
.
n
)
;
printf
(
"
-
Counters
:
%
7
.
1f
.
.
%
7
.
1f
.
.
%
7
.
1f
[
%
u
]
\
n
"
info
-
>
mCountersNs
.
min
info
-
>
mCountersNs
.
sum
/
info
-
>
mCountersNs
.
n
info
-
>
mCountersNs
.
max
info
-
>
mCountersNs
.
n
)
;
printf
(
"
-
Threads
:
%
7
.
1f
.
.
%
7
.
1f
.
.
%
7
.
1f
[
%
u
]
\
n
"
info
-
>
mThreadsNs
.
min
info
-
>
mThreadsNs
.
sum
/
info
-
>
mThreadsNs
.
n
info
-
>
mThreadsNs
.
max
info
-
>
mThreadsNs
.
n
)
;
printf
(
"
baseprofiler_save_profile_to_file
(
)
.
.
.
\
n
"
)
;
baseprofiler
:
:
profiler_save_profile_to_file
(
"
TestProfiler_profile
.
json
"
)
;
printf
(
"
profiler_stop
(
)
.
.
.
\
n
"
)
;
baseprofiler
:
:
profiler_stop
(
)
;
MOZ_RELEASE_ASSERT
(
!
baseprofiler
:
:
profiler_is_active
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
baseprofiler
:
:
profiler_thread_is_being_profiled
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
baseprofiler
:
:
profiler_thread_is_sleeping
(
)
)
;
printf
(
"
profiler_shutdown
(
)
.
.
.
\
n
"
)
;
}
printf
(
"
TestProfiler
done
\
n
"
)
;
}
void
StreamMarkers
(
const
mozilla
:
:
ProfileChunkedBuffer
&
aBuffer
mozilla
:
:
JSONWriter
&
aWriter
)
{
aWriter
.
Start
(
)
;
{
aWriter
.
StartArrayProperty
(
"
data
"
)
;
{
aBuffer
.
ReadEach
(
[
&
]
(
mozilla
:
:
ProfileBufferEntryReader
&
aEntryReader
)
{
mozilla
:
:
ProfileBufferEntryKind
entryKind
=
aEntryReader
.
ReadObject
<
mozilla
:
:
ProfileBufferEntryKind
>
(
)
;
MOZ_RELEASE_ASSERT
(
entryKind
=
=
mozilla
:
:
ProfileBufferEntryKind
:
:
Marker
)
;
const
bool
success
=
mozilla
:
:
base_profiler_markers_detail
:
:
DeserializeAfterKindAndStream
(
aEntryReader
aWriter
0
[
&
]
(
const
mozilla
:
:
ProfilerString8View
&
aName
)
{
aWriter
.
StringElement
(
aName
.
String
(
)
.
c_str
(
)
)
;
}
[
&
]
(
mozilla
:
:
ProfileChunkedBuffer
&
)
{
aWriter
.
StringElement
(
"
Real
backtrace
would
be
here
"
)
;
}
)
;
MOZ_RELEASE_ASSERT
(
success
)
;
}
)
;
}
aWriter
.
EndArray
(
)
;
}
aWriter
.
End
(
)
;
}
void
PrintMarkers
(
const
mozilla
:
:
ProfileChunkedBuffer
&
aBuffer
)
{
mozilla
:
:
baseprofiler
:
:
SpliceableJSONWriter
writer
(
mozilla
:
:
MakeUnique
<
mozilla
:
:
baseprofiler
:
:
OStreamJSONWriteFunc
>
(
std
:
:
cout
)
)
;
StreamMarkers
(
aBuffer
writer
)
;
}
void
TestMarkerNoPayload
(
)
{
printf
(
"
TestMarkerNoPayload
.
.
.
\
n
"
)
;
mozilla
:
:
ProfileBufferChunkManagerSingle
chunkManager
(
512
)
;
mozilla
:
:
ProfileChunkedBuffer
buffer
(
mozilla
:
:
ProfileChunkedBuffer
:
:
ThreadSafety
:
:
WithoutMutex
chunkManager
)
;
mozilla
:
:
ProfileBufferBlockIndex
i0
=
mozilla
:
:
baseprofiler
:
:
AddMarkerToBuffer
<
>
(
buffer
"
literal
"
mozilla
:
:
baseprofiler
:
:
category
:
:
OTHER_Profiling
)
;
MOZ_RELEASE_ASSERT
(
i0
)
;
const
std
:
:
string
dynamic
=
"
dynamic
"
;
mozilla
:
:
ProfileBufferBlockIndex
i1
=
mozilla
:
:
baseprofiler
:
:
AddMarkerToBuffer
<
>
(
buffer
dynamic
mozilla
:
:
baseprofiler
:
:
category
:
:
GRAPHICS_FlushingAsyncPaints
)
;
MOZ_RELEASE_ASSERT
(
i1
)
;
MOZ_RELEASE_ASSERT
(
i1
>
i0
)
;
mozilla
:
:
ProfileBufferBlockIndex
i2
=
mozilla
:
:
baseprofiler
:
:
AddMarkerToBuffer
<
>
(
buffer
std
:
:
string_view
(
"
string_view
"
)
mozilla
:
:
baseprofiler
:
:
category
:
:
GRAPHICS_FlushingAsyncPaints
)
;
MOZ_RELEASE_ASSERT
(
i2
)
;
MOZ_RELEASE_ASSERT
(
i2
>
i1
)
;
#
ifdef
DEBUG
buffer
.
Dump
(
)
;
#
endif
PrintMarkers
(
buffer
)
;
printf
(
"
TestMarkerNoPayload
done
\
n
"
)
;
}
void
TestUserMarker
(
)
{
printf
(
"
TestUserMarker
.
.
.
\
n
"
)
;
struct
MarkerTypeTestMinimal
{
static
constexpr
const
char
*
MarkerTypeName
(
)
{
return
"
test
-
minimal
"
;
}
static
void
StreamJSONMarkerData
(
mozilla
:
:
JSONWriter
&
aWriter
const
std
:
:
string
&
aText
)
{
aWriter
.
StringProperty
(
"
text
"
aText
.
c_str
(
)
)
;
}
}
;
mozilla
:
:
ProfileBufferChunkManagerSingle
chunkManager
(
1024
)
;
mozilla
:
:
ProfileChunkedBuffer
buffer
(
mozilla
:
:
ProfileChunkedBuffer
:
:
ThreadSafety
:
:
WithoutMutex
chunkManager
)
;
MOZ_RELEASE_ASSERT
(
mozilla
:
:
baseprofiler
:
:
AddMarkerToBuffer
<
MarkerTypeTestMinimal
>
(
buffer
"
test2
"
mozilla
:
:
baseprofiler
:
:
category
:
:
OTHER_Profiling
std
:
:
string
(
"
payload
text
"
)
)
)
;
MOZ_RELEASE_ASSERT
(
mozilla
:
:
baseprofiler
:
:
AddMarkerToBuffer
<
MarkerTypeTestMinimal
>
(
buffer
"
test2
"
mozilla
:
:
baseprofiler
:
:
category
:
:
OTHER_Profiling
.
WithOptions
(
mozilla
:
:
MarkerThreadId
(
123
)
)
std
:
:
string
(
"
ThreadId
(
123
)
"
)
)
)
;
auto
start
=
mozilla
:
:
TimeStamp
:
:
NowUnfuzzed
(
)
;
MOZ_RELEASE_ASSERT
(
mozilla
:
:
baseprofiler
:
:
AddMarkerToBuffer
<
MarkerTypeTestMinimal
>
(
buffer
"
test2
"
mozilla
:
:
baseprofiler
:
:
category
:
:
OTHER_Profiling
.
WithOptions
(
mozilla
:
:
MarkerTiming
:
:
InstantAt
(
start
)
)
std
:
:
string
(
"
InstantAt
(
start
)
"
)
)
)
;
auto
then
=
mozilla
:
:
TimeStamp
:
:
NowUnfuzzed
(
)
;
MOZ_RELEASE_ASSERT
(
mozilla
:
:
baseprofiler
:
:
AddMarkerToBuffer
<
MarkerTypeTestMinimal
>
(
buffer
"
test2
"
mozilla
:
:
baseprofiler
:
:
category
:
:
OTHER_Profiling
.
WithOptions
(
mozilla
:
:
MarkerTiming
:
:
IntervalStart
(
start
)
)
std
:
:
string
(
"
IntervalStart
(
start
)
"
)
)
)
;
MOZ_RELEASE_ASSERT
(
mozilla
:
:
baseprofiler
:
:
AddMarkerToBuffer
<
MarkerTypeTestMinimal
>
(
buffer
"
test2
"
mozilla
:
:
baseprofiler
:
:
category
:
:
OTHER_Profiling
.
WithOptions
(
mozilla
:
:
MarkerTiming
:
:
IntervalEnd
(
then
)
)
std
:
:
string
(
"
IntervalEnd
(
then
)
"
)
)
)
;
MOZ_RELEASE_ASSERT
(
mozilla
:
:
baseprofiler
:
:
AddMarkerToBuffer
<
MarkerTypeTestMinimal
>
(
buffer
"
test2
"
mozilla
:
:
baseprofiler
:
:
category
:
:
OTHER_Profiling
.
WithOptions
(
mozilla
:
:
MarkerTiming
:
:
Interval
(
start
then
)
)
std
:
:
string
(
"
Interval
(
start
then
)
"
)
)
)
;
MOZ_RELEASE_ASSERT
(
mozilla
:
:
baseprofiler
:
:
AddMarkerToBuffer
<
MarkerTypeTestMinimal
>
(
buffer
"
test2
"
mozilla
:
:
baseprofiler
:
:
category
:
:
OTHER_Profiling
.
WithOptions
(
mozilla
:
:
MarkerTiming
:
:
IntervalUntilNowFrom
(
start
)
)
std
:
:
string
(
"
IntervalUntilNowFrom
(
start
)
"
)
)
)
;
MOZ_RELEASE_ASSERT
(
mozilla
:
:
baseprofiler
:
:
AddMarkerToBuffer
<
MarkerTypeTestMinimal
>
(
buffer
"
test2
"
mozilla
:
:
baseprofiler
:
:
category
:
:
OTHER_Profiling
.
WithOptions
(
mozilla
:
:
MarkerStack
:
:
NoStack
(
)
)
std
:
:
string
(
"
NoStack
"
)
)
)
;
MOZ_RELEASE_ASSERT
(
mozilla
:
:
baseprofiler
:
:
AddMarkerToBuffer
<
MarkerTypeTestMinimal
>
(
buffer
"
test2
"
mozilla
:
:
baseprofiler
:
:
category
:
:
OTHER_Profiling
.
WithOptions
(
mozilla
:
:
MarkerInnerWindowId
(
123
)
)
std
:
:
string
(
"
InnerWindowId
(
123
)
"
)
)
)
;
#
ifdef
DEBUG
buffer
.
Dump
(
)
;
#
endif
PrintMarkers
(
buffer
)
;
printf
(
"
TestUserMarker
done
\
n
"
)
;
}
void
TestPredefinedMarkers
(
)
{
printf
(
"
TestPredefinedMarkers
.
.
.
\
n
"
)
;
struct
MarkerTypeTestMinimal
{
static
constexpr
const
char
*
MarkerTypeName
(
)
{
return
"
test
-
minimal
"
;
}
static
void
StreamJSONMarkerData
(
mozilla
:
:
JSONWriter
&
aWriter
const
std
:
:
string
&
aText
)
{
aWriter
.
StringProperty
(
"
text
"
aText
.
c_str
(
)
)
;
}
}
;
mozilla
:
:
ProfileBufferChunkManagerSingle
chunkManager
(
1024
)
;
mozilla
:
:
ProfileChunkedBuffer
buffer
(
mozilla
:
:
ProfileChunkedBuffer
:
:
ThreadSafety
:
:
WithoutMutex
chunkManager
)
;
MOZ_RELEASE_ASSERT
(
mozilla
:
:
baseprofiler
:
:
AddMarkerToBuffer
<
mozilla
:
:
baseprofiler
:
:
markers
:
:
Tracing
>
(
buffer
std
:
:
string_view
(
"
tracing
"
)
mozilla
:
:
baseprofiler
:
:
category
:
:
OTHER
"
category
"
)
)
;
MOZ_RELEASE_ASSERT
(
mozilla
:
:
baseprofiler
:
:
AddMarkerToBuffer
<
mozilla
:
:
baseprofiler
:
:
markers
:
:
UserTimingMark
>
(
buffer
std
:
:
string_view
(
"
mark
"
)
mozilla
:
:
baseprofiler
:
:
category
:
:
OTHER
"
mark
name
"
)
)
;
MOZ_RELEASE_ASSERT
(
mozilla
:
:
baseprofiler
:
:
AddMarkerToBuffer
<
mozilla
:
:
baseprofiler
:
:
markers
:
:
UserTimingMeasure
>
(
buffer
std
:
:
string_view
(
"
measure
"
)
mozilla
:
:
baseprofiler
:
:
category
:
:
OTHER
"
measure
name
"
mozilla
:
:
Some
(
mozilla
:
:
ProfilerString8View
(
"
start
"
)
)
mozilla
:
:
Some
(
mozilla
:
:
ProfilerString8View
(
"
end
"
)
)
)
)
;
MOZ_RELEASE_ASSERT
(
mozilla
:
:
baseprofiler
:
:
AddMarkerToBuffer
<
mozilla
:
:
baseprofiler
:
:
markers
:
:
Hang
>
(
buffer
std
:
:
string_view
(
"
hang
"
)
mozilla
:
:
baseprofiler
:
:
category
:
:
OTHER
)
)
;
MOZ_RELEASE_ASSERT
(
mozilla
:
:
baseprofiler
:
:
AddMarkerToBuffer
<
mozilla
:
:
baseprofiler
:
:
markers
:
:
LongTask
>
(
buffer
std
:
:
string_view
(
"
long
task
"
)
mozilla
:
:
baseprofiler
:
:
category
:
:
OTHER
)
)
;
MOZ_RELEASE_ASSERT
(
mozilla
:
:
baseprofiler
:
:
AddMarkerToBuffer
<
mozilla
:
:
baseprofiler
:
:
markers
:
:
Text
>
(
buffer
std
:
:
string_view
(
"
text
"
)
mozilla
:
:
baseprofiler
:
:
category
:
:
OTHER
"
text
text
"
)
)
;
MOZ_RELEASE_ASSERT
(
mozilla
:
:
baseprofiler
:
:
AddMarkerToBuffer
<
mozilla
:
:
baseprofiler
:
:
markers
:
:
Log
>
(
buffer
std
:
:
string_view
(
"
log
"
)
mozilla
:
:
baseprofiler
:
:
category
:
:
OTHER
"
module
"
"
text
"
)
)
;
MOZ_RELEASE_ASSERT
(
mozilla
:
:
baseprofiler
:
:
AddMarkerToBuffer
<
mozilla
:
:
baseprofiler
:
:
markers
:
:
MediaSample
>
(
buffer
std
:
:
string_view
(
"
media
"
)
mozilla
:
:
baseprofiler
:
:
category
:
:
OTHER
123
456
)
)
;
#
ifdef
DEBUG
buffer
.
Dump
(
)
;
#
endif
PrintMarkers
(
buffer
)
;
printf
(
"
TestPredefinedMarkers
done
\
n
"
)
;
}
void
TestProfilerMarkers
(
)
{
printf
(
"
TestProfilerMarkers
-
-
pid
:
%
d
tid
:
%
d
\
n
"
mozilla
:
:
baseprofiler
:
:
profiler_current_process_id
(
)
mozilla
:
:
baseprofiler
:
:
profiler_current_thread_id
(
)
)
;
TestMarkerNoPayload
(
)
;
TestUserMarker
(
)
;
TestPredefinedMarkers
(
)
;
printf
(
"
TestProfilerMarkers
done
\
n
"
)
;
}
#
else
void
TestProfiler
(
)
{
#
ifndef
AUTO_BASE_PROFILER_INIT
#
error
AUTO_BASE_PROFILER_INIT
not
#
defined
#
endif
AUTO_BASE_PROFILER_INIT
;
#
ifndef
AUTO_BASE_PROFILER_MARKER_TEXT
#
error
AUTO_BASE_PROFILER_MARKER_TEXT
not
#
defined
#
endif
AUTO_BASE_PROFILER_MARKER_TEXT
(
catch
catch
catch
)
;
#
ifndef
AUTO_BASE_PROFILER_LABEL
#
error
AUTO_BASE_PROFILER_LABEL
not
#
defined
#
endif
AUTO_BASE_PROFILER_LABEL
(
catch
catch
)
;
#
ifndef
AUTO_BASE_PROFILER_THREAD_SLEEP
#
error
AUTO_BASE_PROFILER_THREAD_SLEEP
not
#
defined
#
endif
AUTO_BASE_PROFILER_THREAD_SLEEP
;
#
ifndef
BASE_PROFILER_MARKER_UNTYPED
#
error
BASE_PROFILER_MARKER_UNTYPED
not
#
defined
#
endif
BASE_PROFILER_MARKER_UNTYPED
(
catch
catch
)
;
#
ifndef
BASE_PROFILER_MARKER
#
error
BASE_PROFILER_MARKER
not
#
defined
#
endif
BASE_PROFILER_MARKER
(
catch
catch
catch
)
;
BASE_PROFILER_MARKER
(
catch
catch
catch
catch
)
;
#
ifndef
BASE_PROFILER_MARKER_TEXT
#
error
BASE_PROFILER_MARKER_TEXT
not
#
defined
#
endif
BASE_PROFILER_MARKER_TEXT
(
catch
catch
catch
)
;
MOZ_RELEASE_ASSERT
(
!
mozilla
:
:
baseprofiler
:
:
profiler_get_backtrace
(
)
"
profiler_get_backtrace
should
return
nullptr
"
)
;
mozilla
:
:
ProfileChunkedBuffer
buffer
;
MOZ_RELEASE_ASSERT
(
!
mozilla
:
:
baseprofiler
:
:
profiler_capture_backtrace_into
(
buffer
)
"
profiler_capture_backtrace_into
should
return
false
"
)
;
MOZ_RELEASE_ASSERT
(
!
mozilla
:
:
baseprofiler
:
:
profiler_capture_backtrace
(
)
"
profiler_capture_backtrace
should
return
nullptr
"
)
;
}
void
TestProfilerMarkers
(
)
{
}
#
endif
#
if
defined
(
XP_WIN
)
int
wmain
(
)
#
else
int
main
(
)
#
endif
{
#
ifdef
MOZ_GECKO_PROFILER
printf
(
"
BaseTestProfiler
-
-
pid
:
%
d
tid
:
%
d
\
n
"
baseprofiler
:
:
profiler_current_process_id
(
)
baseprofiler
:
:
profiler_current_thread_id
(
)
)
;
#
endif
TestProfiler
(
)
;
TestProfilerMarkers
(
)
;
return
0
;
}
