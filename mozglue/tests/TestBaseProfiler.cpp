#
include
"
BaseProfiler
.
h
"
#
ifdef
MOZ_BASE_PROFILER
#
include
"
mozilla
/
BlocksRingBuffer
.
h
"
#
include
"
mozilla
/
leb128iterator
.
h
"
#
include
"
mozilla
/
ModuloBuffer
.
h
"
#
include
"
mozilla
/
PowerOfTwo
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
if
defined
(
_MSC_VER
)
#
include
<
windows
.
h
>
#
include
<
mmsystem
.
h
>
#
include
<
process
.
h
>
#
else
#
include
<
time
.
h
>
#
include
<
unistd
.
h
>
#
endif
#
include
<
algorithm
>
#
include
<
atomic
>
#
include
<
thread
>
#
include
<
type_traits
>
using
namespace
mozilla
;
MOZ_MAYBE_UNUSED
static
void
SleepMilli
(
unsigned
aMilliseconds
)
{
#
if
defined
(
_MSC_VER
)
Sleep
(
aMilliseconds
)
;
#
else
struct
timespec
ts
;
ts
.
tv_sec
=
aMilliseconds
/
1000
;
ts
.
tv_nsec
=
long
(
aMilliseconds
%
1000
)
*
1000000
;
struct
timespec
tr
;
while
(
nanosleep
(
&
ts
&
tr
)
)
{
if
(
errno
=
=
EINTR
)
{
ts
=
tr
;
}
else
{
printf
(
"
nanosleep
(
)
-
>
%
s
\
n
"
strerror
(
errno
)
)
;
exit
(
1
)
;
}
}
#
endif
}
void
TestPowerOfTwoMask
(
)
{
printf
(
"
TestPowerOfTwoMask
.
.
.
\
n
"
)
;
static_assert
(
MakePowerOfTwoMask
<
uint32_t
0
>
(
)
.
MaskValue
(
)
=
=
0
"
"
)
;
constexpr
PowerOfTwoMask
<
uint32_t
>
c0
=
MakePowerOfTwoMask
<
uint32_t
0
>
(
)
;
MOZ_RELEASE_ASSERT
(
c0
.
MaskValue
(
)
=
=
0
)
;
static_assert
(
MakePowerOfTwoMask
<
uint32_t
0xFFu
>
(
)
.
MaskValue
(
)
=
=
0xFFu
"
"
)
;
constexpr
PowerOfTwoMask
<
uint32_t
>
cFF
=
MakePowerOfTwoMask
<
uint32_t
0xFFu
>
(
)
;
MOZ_RELEASE_ASSERT
(
cFF
.
MaskValue
(
)
=
=
0xFFu
)
;
static_assert
(
MakePowerOfTwoMask
<
uint32_t
0xFFFFFFFFu
>
(
)
.
MaskValue
(
)
=
=
0xFFFFFFFFu
"
"
)
;
constexpr
PowerOfTwoMask
<
uint32_t
>
cFFFFFFFF
=
MakePowerOfTwoMask
<
uint32_t
0xFFFFFFFFu
>
(
)
;
MOZ_RELEASE_ASSERT
(
cFFFFFFFF
.
MaskValue
(
)
=
=
0xFFFFFFFFu
)
;
struct
TestDataU32
{
uint32_t
mInput
;
uint32_t
mMask
;
}
;
TestDataU32
tests
[
]
=
{
{
0
0
}
{
1
1
}
{
2
3
}
{
3
3
}
{
4
7
}
{
5
7
}
{
(
1u
<
<
31
)
-
1
(
1u
<
<
31
)
-
1
}
{
(
1u
<
<
31
)
uint32_t
(
-
1
)
}
{
(
1u
<
<
31
)
+
1
uint32_t
(
-
1
)
}
{
uint32_t
(
-
1
)
uint32_t
(
-
1
)
}
}
;
for
(
const
TestDataU32
&
test
:
tests
)
{
PowerOfTwoMask
<
uint32_t
>
p2m
(
test
.
mInput
)
;
MOZ_RELEASE_ASSERT
(
p2m
.
MaskValue
(
)
=
=
test
.
mMask
)
;
for
(
const
TestDataU32
&
inner
:
tests
)
{
if
(
p2m
.
MaskValue
(
)
!
=
uint32_t
(
-
1
)
)
{
MOZ_RELEASE_ASSERT
(
(
inner
.
mInput
%
p2m
)
=
=
(
inner
.
mInput
%
(
p2m
.
MaskValue
(
)
+
1
)
)
)
;
}
MOZ_RELEASE_ASSERT
(
(
inner
.
mInput
&
p2m
)
=
=
(
inner
.
mInput
%
p2m
)
)
;
MOZ_RELEASE_ASSERT
(
(
p2m
&
inner
.
mInput
)
=
=
(
inner
.
mInput
&
p2m
)
)
;
}
}
printf
(
"
TestPowerOfTwoMask
done
\
n
"
)
;
}
void
TestPowerOfTwo
(
)
{
printf
(
"
TestPowerOfTwo
.
.
.
\
n
"
)
;
static_assert
(
MakePowerOfTwo
<
uint32_t
1
>
(
)
.
Value
(
)
=
=
1
"
"
)
;
constexpr
PowerOfTwo
<
uint32_t
>
c1
=
MakePowerOfTwo
<
uint32_t
1
>
(
)
;
MOZ_RELEASE_ASSERT
(
c1
.
Value
(
)
=
=
1
)
;
static_assert
(
MakePowerOfTwo
<
uint32_t
1
>
(
)
.
Mask
(
)
.
MaskValue
(
)
=
=
0
"
"
)
;
static_assert
(
MakePowerOfTwo
<
uint32_t
128
>
(
)
.
Value
(
)
=
=
128
"
"
)
;
constexpr
PowerOfTwo
<
uint32_t
>
c128
=
MakePowerOfTwo
<
uint32_t
128
>
(
)
;
MOZ_RELEASE_ASSERT
(
c128
.
Value
(
)
=
=
128
)
;
static_assert
(
MakePowerOfTwo
<
uint32_t
128
>
(
)
.
Mask
(
)
.
MaskValue
(
)
=
=
127
"
"
)
;
static_assert
(
MakePowerOfTwo
<
uint32_t
0x80000000u
>
(
)
.
Value
(
)
=
=
0x80000000u
"
"
)
;
constexpr
PowerOfTwo
<
uint32_t
>
cMax
=
MakePowerOfTwo
<
uint32_t
0x80000000u
>
(
)
;
MOZ_RELEASE_ASSERT
(
cMax
.
Value
(
)
=
=
0x80000000u
)
;
static_assert
(
MakePowerOfTwo
<
uint32_t
0x80000000u
>
(
)
.
Mask
(
)
.
MaskValue
(
)
=
=
0x7FFFFFFFu
"
"
)
;
struct
TestDataU32
{
uint32_t
mInput
;
uint32_t
mValue
;
uint32_t
mMask
;
}
;
TestDataU32
tests
[
]
=
{
{
0
1
0
}
{
1
1
0
}
{
2
2
1
}
{
3
4
3
}
{
4
4
3
}
{
5
8
7
}
{
(
1u
<
<
31
)
-
1
(
1u
<
<
31
)
(
1u
<
<
31
)
-
1
}
{
(
1u
<
<
31
)
(
1u
<
<
31
)
(
1u
<
<
31
)
-
1
}
{
(
1u
<
<
31
)
+
1
(
1u
<
<
31
)
(
1u
<
<
31
)
-
1
}
{
uint32_t
(
-
1
)
(
1u
<
<
31
)
(
1u
<
<
31
)
-
1
}
}
;
for
(
const
TestDataU32
&
test
:
tests
)
{
PowerOfTwo
<
uint32_t
>
p2
(
test
.
mInput
)
;
MOZ_RELEASE_ASSERT
(
p2
.
Value
(
)
=
=
test
.
mValue
)
;
MOZ_RELEASE_ASSERT
(
p2
.
MaskValue
(
)
=
=
test
.
mMask
)
;
PowerOfTwoMask
<
uint32_t
>
p2m
=
p2
.
Mask
(
)
;
MOZ_RELEASE_ASSERT
(
p2m
.
MaskValue
(
)
=
=
test
.
mMask
)
;
for
(
const
TestDataU32
&
inner
:
tests
)
{
MOZ_RELEASE_ASSERT
(
(
inner
.
mInput
%
p2
)
=
=
(
inner
.
mInput
%
p2
.
Value
(
)
)
)
;
}
}
printf
(
"
TestPowerOfTwo
done
\
n
"
)
;
}
void
TestLEB128
(
)
{
printf
(
"
TestLEB128
.
.
.
\
n
"
)
;
MOZ_RELEASE_ASSERT
(
ULEB128MaxSize
<
uint8_t
>
(
)
=
=
2
)
;
MOZ_RELEASE_ASSERT
(
ULEB128MaxSize
<
uint16_t
>
(
)
=
=
3
)
;
MOZ_RELEASE_ASSERT
(
ULEB128MaxSize
<
uint32_t
>
(
)
=
=
5
)
;
MOZ_RELEASE_ASSERT
(
ULEB128MaxSize
<
uint64_t
>
(
)
=
=
10
)
;
struct
TestDataU64
{
uint64_t
mValue
;
unsigned
mSize
;
const
char
*
mBytes
;
}
;
TestDataU64
tests
[
]
=
{
{
0u
1
"
\
0
"
}
{
1u
1
"
\
x01
"
}
{
0x7Fu
1
"
\
x7F
"
}
{
0x80u
2
"
\
x80
\
x01
"
}
{
0x81u
2
"
\
x81
\
x01
"
}
{
0xFFu
2
"
\
xFF
\
x01
"
}
{
0x100u
2
"
\
x80
\
x02
"
}
{
0xFFFFFFFFu
5
"
\
xFF
\
xFF
\
xFF
\
xFF
\
x0F
"
}
{
0xFFFFFFFFFFFFFFFFu
10
"
\
xFF
\
xFF
\
xFF
\
xFF
\
xFF
\
xFF
\
xFF
\
xFF
\
xFF
\
x01
"
}
}
;
for
(
const
TestDataU64
&
test
:
tests
)
{
MOZ_RELEASE_ASSERT
(
ULEB128Size
(
test
.
mValue
)
=
=
test
.
mSize
)
;
uint8_t
buffer
[
ULEB128MaxSize
<
uint64_t
>
(
)
]
;
uint8_t
*
p
=
buffer
;
WriteULEB128
(
test
.
mValue
p
)
;
MOZ_RELEASE_ASSERT
(
p
=
=
buffer
+
test
.
mSize
)
;
for
(
unsigned
i
=
0
;
i
<
test
.
mSize
;
+
+
i
)
{
MOZ_RELEASE_ASSERT
(
buffer
[
i
]
=
=
uint8_t
(
test
.
mBytes
[
i
]
)
)
;
}
p
=
buffer
;
uint64_t
read
=
ReadULEB128
<
uint64_t
>
(
p
)
;
MOZ_RELEASE_ASSERT
(
p
=
=
buffer
+
test
.
mSize
)
;
MOZ_RELEASE_ASSERT
(
read
=
=
test
.
mValue
)
;
}
printf
(
"
TestLEB128
done
\
n
"
)
;
}
static
void
TestModuloBuffer
(
ModuloBuffer
<
>
&
mb
uint32_t
MBSize
)
{
using
MB
=
ModuloBuffer
<
>
;
MOZ_RELEASE_ASSERT
(
mb
.
BufferLength
(
)
.
Value
(
)
=
=
MBSize
)
;
MOZ_RELEASE_ASSERT
(
mb
.
ReaderAt
(
2
)
=
=
mb
.
ReaderAt
(
2
)
)
;
MOZ_RELEASE_ASSERT
(
mb
.
ReaderAt
(
2
)
!
=
mb
.
ReaderAt
(
3
)
)
;
MOZ_RELEASE_ASSERT
(
mb
.
ReaderAt
(
2
)
<
mb
.
ReaderAt
(
3
)
)
;
MOZ_RELEASE_ASSERT
(
mb
.
ReaderAt
(
2
)
<
=
mb
.
ReaderAt
(
2
)
)
;
MOZ_RELEASE_ASSERT
(
mb
.
ReaderAt
(
2
)
<
=
mb
.
ReaderAt
(
3
)
)
;
MOZ_RELEASE_ASSERT
(
mb
.
ReaderAt
(
3
)
>
mb
.
ReaderAt
(
2
)
)
;
MOZ_RELEASE_ASSERT
(
mb
.
ReaderAt
(
2
)
>
=
mb
.
ReaderAt
(
2
)
)
;
MOZ_RELEASE_ASSERT
(
mb
.
ReaderAt
(
3
)
>
=
mb
.
ReaderAt
(
2
)
)
;
MOZ_RELEASE_ASSERT
(
mb
.
ReaderAt
(
2
)
!
=
mb
.
ReaderAt
(
MBSize
+
2
)
)
;
MOZ_RELEASE_ASSERT
(
mb
.
ReaderAt
(
MBSize
+
2
)
!
=
mb
.
ReaderAt
(
2
)
)
;
static_assert
(
std
:
:
is_same
<
decltype
(
*
mb
.
ReaderAt
(
0
)
)
const
MB
:
:
Byte
&
>
:
:
value
"
Dereferencing
from
a
reader
should
return
const
Byte
*
"
)
;
static_assert
(
std
:
:
is_same
<
decltype
(
*
mb
.
WriterAt
(
0
)
)
MB
:
:
Byte
&
>
:
:
value
"
Dereferencing
from
a
writer
should
return
Byte
*
"
)
;
MOZ_RELEASE_ASSERT
(
&
*
mb
.
ReaderAt
(
MBSize
-
1
)
=
=
&
*
mb
.
ReaderAt
(
0
)
+
(
MBSize
-
1
)
)
;
MOZ_RELEASE_ASSERT
(
&
*
mb
.
ReaderAt
(
MBSize
)
=
=
&
*
mb
.
ReaderAt
(
0
)
)
;
MOZ_RELEASE_ASSERT
(
&
*
mb
.
ReaderAt
(
MBSize
+
MBSize
-
1
)
=
=
&
*
mb
.
ReaderAt
(
MBSize
-
1
)
)
;
MOZ_RELEASE_ASSERT
(
&
*
mb
.
ReaderAt
(
MBSize
+
MBSize
)
=
=
&
*
mb
.
ReaderAt
(
0
)
)
;
MOZ_RELEASE_ASSERT
(
&
*
mb
.
ReaderAt
(
uint32_t
(
-
1
)
)
=
=
&
*
mb
.
ReaderAt
(
MBSize
-
1
)
)
;
MOZ_RELEASE_ASSERT
(
&
*
mb
.
ReaderAt
(
static_cast
<
MB
:
:
Index
>
(
-
1
)
)
=
=
&
*
mb
.
ReaderAt
(
MBSize
-
1
)
)
;
MB
:
:
Reader
arit
=
mb
.
ReaderAt
(
0
)
;
MOZ_RELEASE_ASSERT
(
+
+
arit
=
=
mb
.
ReaderAt
(
1
)
)
;
MOZ_RELEASE_ASSERT
(
arit
=
=
mb
.
ReaderAt
(
1
)
)
;
MOZ_RELEASE_ASSERT
(
-
-
arit
=
=
mb
.
ReaderAt
(
0
)
)
;
MOZ_RELEASE_ASSERT
(
arit
=
=
mb
.
ReaderAt
(
0
)
)
;
MOZ_RELEASE_ASSERT
(
arit
+
3
=
=
mb
.
ReaderAt
(
3
)
)
;
MOZ_RELEASE_ASSERT
(
arit
=
=
mb
.
ReaderAt
(
0
)
)
;
const
bool
checkPlusEq
=
(
(
arit
+
=
3
)
=
=
mb
.
ReaderAt
(
3
)
)
;
MOZ_RELEASE_ASSERT
(
checkPlusEq
)
;
MOZ_RELEASE_ASSERT
(
arit
=
=
mb
.
ReaderAt
(
3
)
)
;
MOZ_RELEASE_ASSERT
(
(
arit
-
2
)
=
=
mb
.
ReaderAt
(
1
)
)
;
MOZ_RELEASE_ASSERT
(
arit
=
=
mb
.
ReaderAt
(
3
)
)
;
const
bool
checkMinusEq
=
(
(
arit
-
=
2
)
=
=
mb
.
ReaderAt
(
1
)
)
;
MOZ_RELEASE_ASSERT
(
checkMinusEq
)
;
MOZ_RELEASE_ASSERT
(
arit
=
=
mb
.
ReaderAt
(
1
)
)
;
MOZ_RELEASE_ASSERT
(
mb
.
ReaderAt
(
3
)
-
mb
.
ReaderAt
(
1
)
=
=
2
)
;
MOZ_RELEASE_ASSERT
(
mb
.
ReaderAt
(
1
)
-
mb
.
ReaderAt
(
3
)
=
=
MB
:
:
Index
(
-
2
)
)
;
MB
:
:
Writer
it
=
mb
.
WriterAt
(
0
)
;
MOZ_RELEASE_ASSERT
(
it
.
CurrentIndex
(
)
=
=
0
)
;
it
.
WriteObject
(
'
x
'
)
;
it
.
WriteObject
(
'
y
'
)
;
it
-
=
2
;
MOZ_RELEASE_ASSERT
(
it
.
PeekObject
<
char
>
(
)
=
=
'
x
'
)
;
MOZ_RELEASE_ASSERT
(
it
.
CurrentIndex
(
)
=
=
0
)
;
MOZ_RELEASE_ASSERT
(
it
.
ReadObject
<
char
>
(
)
=
=
'
x
'
)
;
MOZ_RELEASE_ASSERT
(
it
.
CurrentIndex
(
)
=
=
1
)
;
MOZ_RELEASE_ASSERT
(
it
.
PeekObject
<
char
>
(
)
=
=
'
y
'
)
;
MOZ_RELEASE_ASSERT
(
it
.
CurrentIndex
(
)
=
=
1
)
;
MOZ_RELEASE_ASSERT
(
it
.
ReadObject
<
char
>
(
)
=
=
'
y
'
)
;
MOZ_RELEASE_ASSERT
(
it
.
CurrentIndex
(
)
=
=
2
)
;
MB
:
:
Reader
it2
(
it
)
;
MOZ_RELEASE_ASSERT
(
it2
.
CurrentIndex
(
)
=
=
2
)
;
it2
=
it
;
MOZ_RELEASE_ASSERT
(
it2
.
CurrentIndex
(
)
=
=
2
)
;
it
.
WriteObject
(
int32_t
(
123
)
)
;
MOZ_RELEASE_ASSERT
(
it
.
CurrentIndex
(
)
=
=
6
)
;
it
.
WriteObject
(
int32_t
(
456
)
)
;
MOZ_RELEASE_ASSERT
(
it
.
CurrentIndex
(
)
=
=
MBSize
+
2
)
;
MOZ_RELEASE_ASSERT
(
it
.
ReadObject
<
int32_t
>
(
)
=
=
123
)
;
MOZ_RELEASE_ASSERT
(
it
.
CurrentIndex
(
)
=
=
MBSize
+
6
)
;
MOZ_RELEASE_ASSERT
(
it
.
ReadObject
<
int32_t
>
(
)
=
=
456
)
;
MOZ_RELEASE_ASSERT
(
it
.
CurrentIndex
(
)
=
=
MBSize
+
MBSize
+
2
)
;
}
void
TestModuloBuffer
(
)
{
printf
(
"
TestModuloBuffer
.
.
.
\
n
"
)
;
using
MB
=
ModuloBuffer
<
>
;
constexpr
uint32_t
MBSize
=
8
;
MB
mbByLength
(
MakePowerOfTwo32
<
MBSize
>
(
)
)
;
TestModuloBuffer
(
mbByLength
MBSize
)
;
auto
uniqueBuffer
=
MakeUnique
<
uint8_t
[
]
>
(
MBSize
)
;
MB
mbByUniquePtr
(
MakeUnique
<
uint8_t
[
]
>
(
MBSize
)
MakePowerOfTwo32
<
MBSize
>
(
)
)
;
TestModuloBuffer
(
mbByUniquePtr
MBSize
)
;
uint8_t
buffer
[
MBSize
*
3
]
;
for
(
size_t
i
=
0
;
i
<
MBSize
*
3
;
+
+
i
)
{
buffer
[
i
]
=
uint8_t
(
'
A
'
+
i
)
;
}
MB
mbByBuffer
(
&
buffer
[
MBSize
]
MakePowerOfTwo32
<
MBSize
>
(
)
)
;
TestModuloBuffer
(
mbByBuffer
MBSize
)
;
uint32_t
changed
=
0
;
for
(
size_t
i
=
MBSize
;
i
<
MBSize
*
2
;
+
+
i
)
{
changed
+
=
(
buffer
[
i
]
=
=
uint8_t
(
'
A
'
+
i
)
)
?
0
:
1
;
}
MOZ_RELEASE_ASSERT
(
changed
>
=
MBSize
*
6
/
8
)
;
for
(
size_t
i
=
0
;
i
<
MBSize
;
+
+
i
)
{
MOZ_RELEASE_ASSERT
(
buffer
[
i
]
=
=
uint8_t
(
'
A
'
+
i
)
)
;
}
for
(
size_t
i
=
MBSize
*
2
;
i
<
MBSize
*
3
;
+
+
i
)
{
MOZ_RELEASE_ASSERT
(
buffer
[
i
]
=
=
uint8_t
(
'
A
'
+
i
)
)
;
}
MB
mbByStolenBuffer
=
std
:
:
move
(
mbByBuffer
)
;
TestModuloBuffer
(
mbByStolenBuffer
MBSize
)
;
changed
=
0
;
for
(
size_t
i
=
MBSize
;
i
<
MBSize
*
2
;
+
+
i
)
{
changed
+
=
(
buffer
[
i
]
=
=
uint8_t
(
'
A
'
+
i
)
)
?
0
:
1
;
}
MOZ_RELEASE_ASSERT
(
changed
>
=
MBSize
*
6
/
8
)
;
for
(
size_t
i
=
0
;
i
<
MBSize
;
+
+
i
)
{
MOZ_RELEASE_ASSERT
(
buffer
[
i
]
=
=
uint8_t
(
'
A
'
+
i
)
)
;
}
for
(
size_t
i
=
MBSize
*
2
;
i
<
MBSize
*
3
;
+
+
i
)
{
MOZ_RELEASE_ASSERT
(
buffer
[
i
]
=
=
uint8_t
(
'
A
'
+
i
)
)
;
}
printf
(
"
TestModuloBuffer
done
\
n
"
)
;
}
static
uint64_t
ExtractBlockIndex
(
const
BlocksRingBuffer
:
:
BlockIndex
bi
)
{
uint64_t
index
;
static_assert
(
sizeof
(
bi
)
=
=
sizeof
(
index
)
"
BlockIndex
expected
to
only
contain
a
uint64_t
"
)
;
memcpy
(
&
index
&
bi
sizeof
(
index
)
)
;
return
index
;
}
;
void
TestBlocksRingBufferAPI
(
)
{
printf
(
"
TestBlocksRingBufferAPI
.
.
.
\
n
"
)
;
uint32_t
lastDestroyed
=
0
;
constexpr
uint32_t
MBSize
=
16
;
uint8_t
buffer
[
MBSize
*
3
]
;
for
(
size_t
i
=
0
;
i
<
MBSize
*
3
;
+
+
i
)
{
buffer
[
i
]
=
uint8_t
(
'
A
'
+
i
)
;
}
{
BlocksRingBuffer
rb
(
&
buffer
[
MBSize
]
MakePowerOfTwo32
<
MBSize
>
(
)
[
&
]
(
BlocksRingBuffer
:
:
EntryReader
aReader
)
{
lastDestroyed
=
aReader
.
ReadObject
<
uint32_t
>
(
)
;
}
)
;
#
define
VERIFY_START_END_DESTROYED
(
aStart
aEnd
aLastDestroyed
)
\
rb
.
Read
(
[
&
]
(
const
BlocksRingBuffer
:
:
Reader
aReader
)
{
\
MOZ_RELEASE_ASSERT
(
ExtractBlockIndex
(
aReader
.
BufferRangeStart
(
)
)
=
=
\
(
aStart
)
)
;
\
MOZ_RELEASE_ASSERT
(
ExtractBlockIndex
(
aReader
.
BufferRangeEnd
(
)
)
=
=
\
(
aEnd
)
)
;
\
MOZ_RELEASE_ASSERT
(
lastDestroyed
=
=
(
aLastDestroyed
)
)
;
\
}
)
;
VERIFY_START_END_DESTROYED
(
1
1
0
)
;
BlocksRingBuffer
:
:
BlockIndex
bi0
;
if
(
bi0
)
{
MOZ_RELEASE_ASSERT
(
false
"
if
(
BlockIndex
{
}
)
should
fail
test
"
)
;
}
if
(
!
bi0
)
{
}
else
{
MOZ_RELEASE_ASSERT
(
false
"
if
(
!
BlockIndex
{
}
)
should
succeed
test
"
)
;
}
MOZ_RELEASE_ASSERT
(
!
bi0
)
;
MOZ_RELEASE_ASSERT
(
bi0
=
=
bi0
)
;
MOZ_RELEASE_ASSERT
(
bi0
<
=
bi0
)
;
MOZ_RELEASE_ASSERT
(
bi0
>
=
bi0
)
;
MOZ_RELEASE_ASSERT
(
!
(
bi0
!
=
bi0
)
)
;
MOZ_RELEASE_ASSERT
(
!
(
bi0
<
bi0
)
)
;
MOZ_RELEASE_ASSERT
(
!
(
bi0
>
bi0
)
)
;
rb
.
ReadAt
(
bi0
[
]
(
Maybe
<
BlocksRingBuffer
:
:
EntryReader
>
&
&
aMaybeReader
)
{
MOZ_RELEASE_ASSERT
(
aMaybeReader
.
isNothing
(
)
)
;
}
)
;
MOZ_RELEASE_ASSERT
(
ExtractBlockIndex
(
rb
.
PutObject
(
uint32_t
(
1
)
)
)
=
=
1
)
;
VERIFY_START_END_DESTROYED
(
1
6
0
)
;
auto
bi2
=
rb
.
Put
(
[
]
(
BlocksRingBuffer
:
:
EntryReserver
aER
)
{
return
aER
.
WriteObject
(
uint32_t
(
2
)
)
;
}
)
;
static_assert
(
std
:
:
is_same
<
decltype
(
bi2
)
BlocksRingBuffer
:
:
BlockIndex
>
:
:
value
"
All
index
-
returning
functions
should
return
a
"
"
BlocksRingBuffer
:
:
BlockIndex
"
)
;
MOZ_RELEASE_ASSERT
(
ExtractBlockIndex
(
bi2
)
=
=
6
)
;
VERIFY_START_END_DESTROYED
(
1
11
0
)
;
auto
bi2Next
=
rb
.
ReadAt
(
bi2
[
]
(
Maybe
<
BlocksRingBuffer
:
:
EntryReader
>
&
&
aMaybeReader
)
{
MOZ_RELEASE_ASSERT
(
aMaybeReader
.
isSome
(
)
)
;
MOZ_RELEASE_ASSERT
(
aMaybeReader
-
>
ReadObject
<
uint32_t
>
(
)
=
=
2
)
;
MOZ_RELEASE_ASSERT
(
aMaybeReader
-
>
GetEntryAt
(
aMaybeReader
-
>
NextBlockIndex
(
)
)
.
isNothing
(
)
)
;
return
aMaybeReader
-
>
NextBlockIndex
(
)
;
}
)
;
rb
.
ReadAt
(
bi2Next
[
]
(
Maybe
<
BlocksRingBuffer
:
:
EntryReader
>
&
&
aMaybeReader
)
{
MOZ_RELEASE_ASSERT
(
aMaybeReader
.
isNothing
(
)
)
;
}
)
;
if
(
bi2
)
{
}
else
{
MOZ_RELEASE_ASSERT
(
false
"
if
(
non
-
default
-
BlockIndex
)
should
succeed
test
"
)
;
}
if
(
!
bi2
)
{
MOZ_RELEASE_ASSERT
(
false
"
if
(
!
non
-
default
-
BlockIndex
)
should
fail
test
"
)
;
}
MOZ_RELEASE_ASSERT
(
!
!
bi2
)
;
MOZ_RELEASE_ASSERT
(
bi2
=
=
bi2
)
;
MOZ_RELEASE_ASSERT
(
bi2
<
=
bi2
)
;
MOZ_RELEASE_ASSERT
(
bi2
>
=
bi2
)
;
MOZ_RELEASE_ASSERT
(
!
(
bi2
!
=
bi2
)
)
;
MOZ_RELEASE_ASSERT
(
!
(
bi2
<
bi2
)
)
;
MOZ_RELEASE_ASSERT
(
!
(
bi2
>
bi2
)
)
;
MOZ_RELEASE_ASSERT
(
bi0
!
=
bi2
)
;
MOZ_RELEASE_ASSERT
(
bi0
<
bi2
)
;
MOZ_RELEASE_ASSERT
(
bi0
<
=
bi2
)
;
MOZ_RELEASE_ASSERT
(
!
(
bi0
=
=
bi2
)
)
;
MOZ_RELEASE_ASSERT
(
!
(
bi0
>
bi2
)
)
;
MOZ_RELEASE_ASSERT
(
!
(
bi0
>
=
bi2
)
)
;
MOZ_RELEASE_ASSERT
(
bi2
!
=
bi0
)
;
MOZ_RELEASE_ASSERT
(
bi2
>
bi0
)
;
MOZ_RELEASE_ASSERT
(
bi2
>
=
bi0
)
;
MOZ_RELEASE_ASSERT
(
!
(
bi2
=
=
bi0
)
)
;
MOZ_RELEASE_ASSERT
(
!
(
bi2
<
bi0
)
)
;
MOZ_RELEASE_ASSERT
(
!
(
bi2
<
=
bi0
)
)
;
MOZ_RELEASE_ASSERT
(
bi2
!
=
bi2Next
)
;
MOZ_RELEASE_ASSERT
(
bi2
<
bi2Next
)
;
MOZ_RELEASE_ASSERT
(
bi2
<
=
bi2Next
)
;
MOZ_RELEASE_ASSERT
(
!
(
bi2
=
=
bi2Next
)
)
;
MOZ_RELEASE_ASSERT
(
!
(
bi2
>
bi2Next
)
)
;
MOZ_RELEASE_ASSERT
(
!
(
bi2
>
=
bi2Next
)
)
;
MOZ_RELEASE_ASSERT
(
bi2Next
!
=
bi2
)
;
MOZ_RELEASE_ASSERT
(
bi2Next
>
bi2
)
;
MOZ_RELEASE_ASSERT
(
bi2Next
>
=
bi2
)
;
MOZ_RELEASE_ASSERT
(
!
(
bi2Next
=
=
bi2
)
)
;
MOZ_RELEASE_ASSERT
(
!
(
bi2Next
<
bi2
)
)
;
MOZ_RELEASE_ASSERT
(
!
(
bi2Next
<
=
bi2
)
)
;
auto
put3
=
rb
.
Put
(
[
&
]
(
BlocksRingBuffer
:
:
EntryReserver
aER
)
{
return
aER
.
Reserve
(
sizeof
(
uint32_t
)
[
&
]
(
BlocksRingBuffer
:
:
EntryWriter
aEW
)
{
aEW
.
WriteObject
(
uint32_t
(
3
)
)
;
return
float
(
ExtractBlockIndex
(
aEW
.
CurrentBlockIndex
(
)
)
)
;
}
)
;
}
)
;
static_assert
(
std
:
:
is_same
<
decltype
(
put3
)
float
>
:
:
value
"
Expect
float
as
returned
by
callback
.
"
)
;
MOZ_RELEASE_ASSERT
(
put3
=
=
11
.
0
)
;
VERIFY_START_END_DESTROYED
(
1
16
0
)
;
rb
.
ReadAt
(
bi2
[
&
]
(
Maybe
<
BlocksRingBuffer
:
:
EntryReader
>
&
&
aMaybeReader
)
{
MOZ_RELEASE_ASSERT
(
aMaybeReader
.
isSome
(
)
)
;
MOZ_RELEASE_ASSERT
(
aMaybeReader
-
>
ReadObject
<
uint32_t
>
(
)
=
=
2
)
;
MOZ_RELEASE_ASSERT
(
aMaybeReader
-
>
NextBlockIndex
(
)
=
=
bi2Next
)
;
MOZ_RELEASE_ASSERT
(
aMaybeReader
-
>
GetNextEntry
(
)
.
isSome
(
)
)
;
MOZ_RELEASE_ASSERT
(
aMaybeReader
-
>
GetEntryAt
(
aMaybeReader
-
>
NextBlockIndex
(
)
)
.
isSome
(
)
)
;
MOZ_RELEASE_ASSERT
(
aMaybeReader
-
>
GetNextEntry
(
)
-
>
CurrentBlockIndex
(
)
=
=
aMaybeReader
-
>
GetEntryAt
(
aMaybeReader
-
>
NextBlockIndex
(
)
)
-
>
CurrentBlockIndex
(
)
)
;
MOZ_RELEASE_ASSERT
(
aMaybeReader
-
>
GetEntryAt
(
aMaybeReader
-
>
NextBlockIndex
(
)
)
-
>
ReadObject
<
uint32_t
>
(
)
=
=
3
)
;
}
)
;
uint32_t
count
=
0
;
rb
.
ReadEach
(
[
&
]
(
BlocksRingBuffer
:
:
EntryReader
aReader
)
{
MOZ_RELEASE_ASSERT
(
aReader
.
ReadObject
<
uint32_t
>
(
)
=
=
+
+
count
)
;
}
)
;
MOZ_RELEASE_ASSERT
(
count
=
=
3
)
;
BlocksRingBuffer
:
:
BlockIndex
bi4
=
rb
.
PutObject
(
uint32_t
(
4
)
)
;
VERIFY_START_END_DESTROYED
(
6
21
1
)
;
count
=
1
;
rb
.
ReadEach
(
[
&
]
(
BlocksRingBuffer
:
:
EntryReader
aReader
)
{
MOZ_RELEASE_ASSERT
(
aReader
.
ReadObject
<
uint32_t
>
(
)
=
=
+
+
count
)
;
}
)
;
MOZ_RELEASE_ASSERT
(
count
=
=
4
)
;
auto
bi5
=
rb
.
Put
(
[
&
]
(
BlocksRingBuffer
:
:
EntryReserver
aER
)
{
return
aER
.
Reserve
(
sizeof
(
uint32_t
)
[
&
]
(
BlocksRingBuffer
:
:
EntryWriter
aEW
)
{
aEW
.
WriteObject
(
uint32_t
(
5
)
)
;
MOZ_RELEASE_ASSERT
(
aEW
.
GetEntryAt
(
bi2
)
.
isNothing
(
)
)
;
MOZ_RELEASE_ASSERT
(
aEW
.
GetEntryAt
(
bi4
)
.
isSome
(
)
)
;
MOZ_RELEASE_ASSERT
(
aEW
.
GetEntryAt
(
bi4
)
-
>
CurrentBlockIndex
(
)
=
=
bi4
)
;
MOZ_RELEASE_ASSERT
(
aEW
.
GetEntryAt
(
bi4
)
-
>
ReadObject
<
uint32_t
>
(
)
=
=
4
)
;
return
aEW
.
CurrentBlockIndex
(
)
;
}
)
;
}
)
;
VERIFY_START_END_DESTROYED
(
11
26
2
)
;
rb
.
ReadAt
(
bi2
[
]
(
Maybe
<
BlocksRingBuffer
:
:
EntryReader
>
&
&
aMaybeReader
)
{
MOZ_RELEASE_ASSERT
(
aMaybeReader
.
isNothing
(
)
)
;
}
)
;
rb
.
ReadAt
(
bi5
[
]
(
Maybe
<
BlocksRingBuffer
:
:
EntryReader
>
&
&
aMaybeReader
)
{
MOZ_RELEASE_ASSERT
(
aMaybeReader
.
isSome
(
)
)
;
MOZ_RELEASE_ASSERT
(
aMaybeReader
-
>
ReadObject
<
uint32_t
>
(
)
=
=
5
)
;
MOZ_RELEASE_ASSERT
(
aMaybeReader
-
>
GetEntryAt
(
aMaybeReader
-
>
NextBlockIndex
(
)
)
.
isNothing
(
)
)
;
}
)
;
count
=
2
;
rb
.
ReadEach
(
[
&
]
(
BlocksRingBuffer
:
:
EntryReader
aReader
)
{
MOZ_RELEASE_ASSERT
(
aReader
.
ReadObject
<
uint32_t
>
(
)
=
=
+
+
count
)
;
}
)
;
MOZ_RELEASE_ASSERT
(
count
=
=
5
)
;
rb
.
ClearBefore
(
bi4
)
;
VERIFY_START_END_DESTROYED
(
16
26
3
)
;
count
=
3
;
rb
.
ReadEach
(
[
&
]
(
BlocksRingBuffer
:
:
EntryReader
aReader
)
{
MOZ_RELEASE_ASSERT
(
aReader
.
ReadObject
<
uint32_t
>
(
)
=
=
+
+
count
)
;
}
)
;
MOZ_RELEASE_ASSERT
(
count
=
=
5
)
;
lastDestroyed
=
0
;
rb
.
ClearBefore
(
bi4
)
;
VERIFY_START_END_DESTROYED
(
16
26
0
)
;
rb
.
Clear
(
)
;
VERIFY_START_END_DESTROYED
(
26
26
5
)
;
rb
.
ReadEach
(
[
&
]
(
auto
&
&
)
{
MOZ_RELEASE_ASSERT
(
false
)
;
}
)
;
rb
.
ReadAt
(
bi5
[
]
(
Maybe
<
BlocksRingBuffer
:
:
EntryReader
>
&
&
aMaybeReader
)
{
MOZ_RELEASE_ASSERT
(
aMaybeReader
.
isNothing
(
)
)
;
}
)
;
lastDestroyed
=
0
;
rb
.
ClearBefore
(
bi4
)
;
VERIFY_START_END_DESTROYED
(
26
26
0
)
;
MOZ_RELEASE_ASSERT
(
ExtractBlockIndex
(
rb
.
PutObject
(
uint32_t
(
6
)
)
)
=
=
26
)
;
VERIFY_START_END_DESTROYED
(
26
31
0
)
;
}
MOZ_RELEASE_ASSERT
(
lastDestroyed
=
=
6
)
;
uint32_t
changed
=
0
;
for
(
size_t
i
=
MBSize
;
i
<
MBSize
*
2
;
+
+
i
)
{
changed
+
=
(
buffer
[
i
]
=
=
uint8_t
(
'
A
'
+
i
)
)
?
0
:
1
;
}
MOZ_RELEASE_ASSERT
(
changed
>
=
MBSize
*
6
/
8
)
;
for
(
size_t
i
=
0
;
i
<
MBSize
;
+
+
i
)
{
MOZ_RELEASE_ASSERT
(
buffer
[
i
]
=
=
uint8_t
(
'
A
'
+
i
)
)
;
}
for
(
size_t
i
=
MBSize
*
2
;
i
<
MBSize
*
3
;
+
+
i
)
{
MOZ_RELEASE_ASSERT
(
buffer
[
i
]
=
=
uint8_t
(
'
A
'
+
i
)
)
;
}
printf
(
"
TestBlocksRingBufferAPI
done
\
n
"
)
;
}
void
TestBlocksRingBufferThreading
(
)
{
printf
(
"
TestBlocksRingBufferThreading
.
.
.
\
n
"
)
;
std
:
:
atomic
<
int
>
lastDestroyed
{
0
}
;
constexpr
uint32_t
MBSize
=
8192
;
uint8_t
buffer
[
MBSize
*
3
]
;
for
(
size_t
i
=
0
;
i
<
MBSize
*
3
;
+
+
i
)
{
buffer
[
i
]
=
uint8_t
(
'
A
'
+
i
)
;
}
BlocksRingBuffer
rb
(
&
buffer
[
MBSize
]
MakePowerOfTwo32
<
MBSize
>
(
)
[
&
]
(
BlocksRingBuffer
:
:
EntryReader
aReader
)
{
lastDestroyed
=
aReader
.
ReadObject
<
int
>
(
)
;
}
)
;
std
:
:
atomic
<
bool
>
stopReader
{
false
}
;
std
:
:
thread
reader
(
[
&
]
(
)
{
for
(
;
;
)
{
Pair
<
uint64_t
uint64_t
>
counts
=
rb
.
GetPushedAndDeletedCounts
(
)
;
printf
(
"
Reader
:
pushed
=
%
llu
deleted
=
%
llu
alive
=
%
llu
lastDestroyed
=
%
d
\
n
"
static_cast
<
unsigned
long
long
>
(
counts
.
first
(
)
)
static_cast
<
unsigned
long
long
>
(
counts
.
second
(
)
)
static_cast
<
unsigned
long
long
>
(
counts
.
first
(
)
-
counts
.
second
(
)
)
int
(
lastDestroyed
)
)
;
if
(
stopReader
)
{
break
;
}
:
:
SleepMilli
(
1
)
;
}
}
)
;
constexpr
int
ThreadCount
=
32
;
std
:
:
thread
threads
[
ThreadCount
]
;
for
(
int
threadNo
=
0
;
threadNo
<
ThreadCount
;
+
+
threadNo
)
{
threads
[
threadNo
]
=
std
:
:
thread
(
[
&
]
(
int
aThreadNo
)
{
:
:
SleepMilli
(
1
)
;
constexpr
int
pushCount
=
1024
;
for
(
int
push
=
0
;
push
<
pushCount
;
+
+
push
)
{
rb
.
Put
(
std
:
:
max
(
aThreadNo
int
(
sizeof
(
push
)
)
)
[
&
]
(
BlocksRingBuffer
:
:
EntryWriter
aEW
)
{
aEW
.
WriteObject
(
aThreadNo
*
1000000
+
push
)
;
aEW
+
=
aEW
.
RemainingBytes
(
)
;
}
)
;
}
}
threadNo
)
;
}
for
(
auto
&
&
thread
:
threads
)
{
thread
.
join
(
)
;
}
stopReader
=
true
;
reader
.
join
(
)
;
uint32_t
changed
=
0
;
for
(
size_t
i
=
MBSize
;
i
<
MBSize
*
2
;
+
+
i
)
{
changed
+
=
(
buffer
[
i
]
=
=
uint8_t
(
'
A
'
+
i
)
)
?
0
:
1
;
}
MOZ_RELEASE_ASSERT
(
changed
>
=
MBSize
*
6
/
8
)
;
for
(
size_t
i
=
0
;
i
<
MBSize
;
+
+
i
)
{
MOZ_RELEASE_ASSERT
(
buffer
[
i
]
=
=
uint8_t
(
'
A
'
+
i
)
)
;
}
for
(
size_t
i
=
MBSize
*
2
;
i
<
MBSize
*
3
;
+
+
i
)
{
MOZ_RELEASE_ASSERT
(
buffer
[
i
]
=
=
uint8_t
(
'
A
'
+
i
)
)
;
}
printf
(
"
TestBlocksRingBufferThreading
done
\
n
"
)
;
}
static
constexpr
size_t
NextDepth
(
size_t
aDepth
)
{
constexpr
size_t
MAX_DEPTH
=
128
;
return
(
aDepth
<
MAX_DEPTH
)
?
(
aDepth
+
1
)
:
aDepth
;
}
template
<
size_t
DEPTH
=
0
>
MOZ_NEVER_INLINE
unsigned
long
long
Fibonacci
(
unsigned
long
long
n
)
{
if
(
n
=
=
0
)
{
return
0
;
}
if
(
n
=
=
1
)
{
return
1
;
}
unsigned
long
long
f2
=
Fibonacci
<
NextDepth
(
DEPTH
)
>
(
n
-
2
)
;
if
(
DEPTH
=
=
0
)
{
BASE_PROFILER_ADD_MARKER
(
"
Half
-
way
through
Fibonacci
"
OTHER
)
;
}
unsigned
long
long
f1
=
Fibonacci
<
NextDepth
(
DEPTH
)
>
(
n
-
1
)
;
return
f2
+
f1
;
}
void
TestProfiler
(
)
{
printf
(
"
TestProfiler
starting
-
-
pid
:
%
d
tid
:
%
d
\
n
"
baseprofiler
:
:
profiler_current_process_id
(
)
baseprofiler
:
:
profiler_current_thread_id
(
)
)
;
TestPowerOfTwoMask
(
)
;
TestPowerOfTwo
(
)
;
TestLEB128
(
)
;
TestModuloBuffer
(
)
;
TestBlocksRingBufferAPI
(
)
;
TestBlocksRingBufferThreading
(
)
;
{
printf
(
"
profiler_init
(
)
.
.
.
\
n
"
)
;
AUTO_BASE_PROFILER_INIT
;
MOZ_RELEASE_ASSERT
(
!
baseprofiler
:
:
profiler_is_active
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
baseprofiler
:
:
profiler_thread_is_being_profiled
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
baseprofiler
:
:
profiler_thread_is_sleeping
(
)
)
;
printf
(
"
profiler_start
(
)
.
.
.
\
n
"
)
;
Vector
<
const
char
*
>
filters
;
MOZ_RELEASE_ASSERT
(
filters
.
append
(
"
"
)
)
;
const
uint32_t
features
=
baseprofiler
:
:
ProfilerFeature
:
:
Leaf
|
baseprofiler
:
:
ProfilerFeature
:
:
StackWalk
|
baseprofiler
:
:
ProfilerFeature
:
:
Threads
;
baseprofiler
:
:
profiler_start
(
baseprofiler
:
:
BASE_PROFILER_DEFAULT_ENTRIES
BASE_PROFILER_DEFAULT_INTERVAL
features
filters
.
begin
(
)
filters
.
length
(
)
)
;
MOZ_RELEASE_ASSERT
(
baseprofiler
:
:
profiler_is_active
(
)
)
;
MOZ_RELEASE_ASSERT
(
baseprofiler
:
:
profiler_thread_is_being_profiled
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
baseprofiler
:
:
profiler_thread_is_sleeping
(
)
)
;
{
AUTO_BASE_PROFILER_TEXT_MARKER_CAUSE
(
"
fibonacci
"
"
First
leaf
call
"
OTHER
nullptr
)
;
static
const
unsigned
long
long
fibStart
=
40
;
printf
(
"
Fibonacci
(
%
llu
)
.
.
.
\
n
"
fibStart
)
;
AUTO_BASE_PROFILER_LABEL
(
"
Label
around
Fibonacci
"
OTHER
)
;
unsigned
long
long
f
=
Fibonacci
(
fibStart
)
;
printf
(
"
Fibonacci
(
%
llu
)
=
%
llu
\
n
"
fibStart
f
)
;
}
printf
(
"
Sleep
1s
.
.
.
\
n
"
)
;
{
AUTO_BASE_PROFILER_THREAD_SLEEP
;
SleepMilli
(
1000
)
;
}
printf
(
"
baseprofiler_save_profile_to_file
(
)
.
.
.
\
n
"
)
;
baseprofiler
:
:
profiler_save_profile_to_file
(
"
TestProfiler_profile
.
json
"
)
;
printf
(
"
profiler_stop
(
)
.
.
.
\
n
"
)
;
baseprofiler
:
:
profiler_stop
(
)
;
MOZ_RELEASE_ASSERT
(
!
baseprofiler
:
:
profiler_is_active
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
baseprofiler
:
:
profiler_thread_is_being_profiled
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
baseprofiler
:
:
profiler_thread_is_sleeping
(
)
)
;
printf
(
"
profiler_shutdown
(
)
.
.
.
\
n
"
)
;
}
printf
(
"
TestProfiler
done
\
n
"
)
;
}
#
else
void
TestProfiler
(
)
{
AUTO_BASE_PROFILER_INIT
;
AUTO_BASE_PROFILER_TEXT_MARKER_CAUSE
(
catch
catch
catch
catch
)
;
AUTO_BASE_PROFILER_LABEL
(
catch
catch
)
;
AUTO_BASE_PROFILER_THREAD_SLEEP
;
}
#
endif
int
main
(
)
{
TestProfiler
(
)
;
return
0
;
}
