#
include
"
BaseProfiler
.
h
"
#
ifdef
MOZ_BASE_PROFILER
#
include
"
BaseProfileJSONWriter
.
h
"
#
include
"
BaseProfilerMarkerPayload
.
h
"
#
include
"
mozilla
/
BlocksRingBuffer
.
h
"
#
include
"
mozilla
/
leb128iterator
.
h
"
#
include
"
mozilla
/
ModuloBuffer
.
h
"
#
include
"
mozilla
/
PowerOfTwo
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
if
defined
(
_MSC_VER
)
#
include
<
windows
.
h
>
#
include
<
mmsystem
.
h
>
#
include
<
process
.
h
>
#
else
#
include
<
time
.
h
>
#
include
<
unistd
.
h
>
#
endif
#
include
<
algorithm
>
#
include
<
atomic
>
#
include
<
thread
>
#
include
<
type_traits
>
using
namespace
mozilla
;
MOZ_MAYBE_UNUSED
static
void
SleepMilli
(
unsigned
aMilliseconds
)
{
#
if
defined
(
_MSC_VER
)
Sleep
(
aMilliseconds
)
;
#
else
struct
timespec
ts
;
ts
.
tv_sec
=
aMilliseconds
/
1000
;
ts
.
tv_nsec
=
long
(
aMilliseconds
%
1000
)
*
1000000
;
struct
timespec
tr
;
while
(
nanosleep
(
&
ts
&
tr
)
)
{
if
(
errno
=
=
EINTR
)
{
ts
=
tr
;
}
else
{
printf
(
"
nanosleep
(
)
-
>
%
s
\
n
"
strerror
(
errno
)
)
;
exit
(
1
)
;
}
}
#
endif
}
void
TestPowerOfTwoMask
(
)
{
printf
(
"
TestPowerOfTwoMask
.
.
.
\
n
"
)
;
static_assert
(
MakePowerOfTwoMask
<
uint32_t
0
>
(
)
.
MaskValue
(
)
=
=
0
"
"
)
;
constexpr
PowerOfTwoMask
<
uint32_t
>
c0
=
MakePowerOfTwoMask
<
uint32_t
0
>
(
)
;
MOZ_RELEASE_ASSERT
(
c0
.
MaskValue
(
)
=
=
0
)
;
static_assert
(
MakePowerOfTwoMask
<
uint32_t
0xFFu
>
(
)
.
MaskValue
(
)
=
=
0xFFu
"
"
)
;
constexpr
PowerOfTwoMask
<
uint32_t
>
cFF
=
MakePowerOfTwoMask
<
uint32_t
0xFFu
>
(
)
;
MOZ_RELEASE_ASSERT
(
cFF
.
MaskValue
(
)
=
=
0xFFu
)
;
static_assert
(
MakePowerOfTwoMask
<
uint32_t
0xFFFFFFFFu
>
(
)
.
MaskValue
(
)
=
=
0xFFFFFFFFu
"
"
)
;
constexpr
PowerOfTwoMask
<
uint32_t
>
cFFFFFFFF
=
MakePowerOfTwoMask
<
uint32_t
0xFFFFFFFFu
>
(
)
;
MOZ_RELEASE_ASSERT
(
cFFFFFFFF
.
MaskValue
(
)
=
=
0xFFFFFFFFu
)
;
struct
TestDataU32
{
uint32_t
mInput
;
uint32_t
mMask
;
}
;
TestDataU32
tests
[
]
=
{
{
0
0
}
{
1
1
}
{
2
3
}
{
3
3
}
{
4
7
}
{
5
7
}
{
(
1u
<
<
31
)
-
1
(
1u
<
<
31
)
-
1
}
{
(
1u
<
<
31
)
uint32_t
(
-
1
)
}
{
(
1u
<
<
31
)
+
1
uint32_t
(
-
1
)
}
{
uint32_t
(
-
1
)
uint32_t
(
-
1
)
}
}
;
for
(
const
TestDataU32
&
test
:
tests
)
{
PowerOfTwoMask
<
uint32_t
>
p2m
(
test
.
mInput
)
;
MOZ_RELEASE_ASSERT
(
p2m
.
MaskValue
(
)
=
=
test
.
mMask
)
;
for
(
const
TestDataU32
&
inner
:
tests
)
{
if
(
p2m
.
MaskValue
(
)
!
=
uint32_t
(
-
1
)
)
{
MOZ_RELEASE_ASSERT
(
(
inner
.
mInput
%
p2m
)
=
=
(
inner
.
mInput
%
(
p2m
.
MaskValue
(
)
+
1
)
)
)
;
}
MOZ_RELEASE_ASSERT
(
(
inner
.
mInput
&
p2m
)
=
=
(
inner
.
mInput
%
p2m
)
)
;
MOZ_RELEASE_ASSERT
(
(
p2m
&
inner
.
mInput
)
=
=
(
inner
.
mInput
&
p2m
)
)
;
}
}
printf
(
"
TestPowerOfTwoMask
done
\
n
"
)
;
}
void
TestPowerOfTwo
(
)
{
printf
(
"
TestPowerOfTwo
.
.
.
\
n
"
)
;
static_assert
(
MakePowerOfTwo
<
uint32_t
1
>
(
)
.
Value
(
)
=
=
1
"
"
)
;
constexpr
PowerOfTwo
<
uint32_t
>
c1
=
MakePowerOfTwo
<
uint32_t
1
>
(
)
;
MOZ_RELEASE_ASSERT
(
c1
.
Value
(
)
=
=
1
)
;
static_assert
(
MakePowerOfTwo
<
uint32_t
1
>
(
)
.
Mask
(
)
.
MaskValue
(
)
=
=
0
"
"
)
;
static_assert
(
MakePowerOfTwo
<
uint32_t
128
>
(
)
.
Value
(
)
=
=
128
"
"
)
;
constexpr
PowerOfTwo
<
uint32_t
>
c128
=
MakePowerOfTwo
<
uint32_t
128
>
(
)
;
MOZ_RELEASE_ASSERT
(
c128
.
Value
(
)
=
=
128
)
;
static_assert
(
MakePowerOfTwo
<
uint32_t
128
>
(
)
.
Mask
(
)
.
MaskValue
(
)
=
=
127
"
"
)
;
static_assert
(
MakePowerOfTwo
<
uint32_t
0x80000000u
>
(
)
.
Value
(
)
=
=
0x80000000u
"
"
)
;
constexpr
PowerOfTwo
<
uint32_t
>
cMax
=
MakePowerOfTwo
<
uint32_t
0x80000000u
>
(
)
;
MOZ_RELEASE_ASSERT
(
cMax
.
Value
(
)
=
=
0x80000000u
)
;
static_assert
(
MakePowerOfTwo
<
uint32_t
0x80000000u
>
(
)
.
Mask
(
)
.
MaskValue
(
)
=
=
0x7FFFFFFFu
"
"
)
;
struct
TestDataU32
{
uint32_t
mInput
;
uint32_t
mValue
;
uint32_t
mMask
;
}
;
TestDataU32
tests
[
]
=
{
{
0
1
0
}
{
1
1
0
}
{
2
2
1
}
{
3
4
3
}
{
4
4
3
}
{
5
8
7
}
{
(
1u
<
<
31
)
-
1
(
1u
<
<
31
)
(
1u
<
<
31
)
-
1
}
{
(
1u
<
<
31
)
(
1u
<
<
31
)
(
1u
<
<
31
)
-
1
}
{
(
1u
<
<
31
)
+
1
(
1u
<
<
31
)
(
1u
<
<
31
)
-
1
}
{
uint32_t
(
-
1
)
(
1u
<
<
31
)
(
1u
<
<
31
)
-
1
}
}
;
for
(
const
TestDataU32
&
test
:
tests
)
{
PowerOfTwo
<
uint32_t
>
p2
(
test
.
mInput
)
;
MOZ_RELEASE_ASSERT
(
p2
.
Value
(
)
=
=
test
.
mValue
)
;
MOZ_RELEASE_ASSERT
(
p2
.
MaskValue
(
)
=
=
test
.
mMask
)
;
PowerOfTwoMask
<
uint32_t
>
p2m
=
p2
.
Mask
(
)
;
MOZ_RELEASE_ASSERT
(
p2m
.
MaskValue
(
)
=
=
test
.
mMask
)
;
for
(
const
TestDataU32
&
inner
:
tests
)
{
MOZ_RELEASE_ASSERT
(
(
inner
.
mInput
%
p2
)
=
=
(
inner
.
mInput
%
p2
.
Value
(
)
)
)
;
}
}
printf
(
"
TestPowerOfTwo
done
\
n
"
)
;
}
void
TestLEB128
(
)
{
printf
(
"
TestLEB128
.
.
.
\
n
"
)
;
MOZ_RELEASE_ASSERT
(
ULEB128MaxSize
<
uint8_t
>
(
)
=
=
2
)
;
MOZ_RELEASE_ASSERT
(
ULEB128MaxSize
<
uint16_t
>
(
)
=
=
3
)
;
MOZ_RELEASE_ASSERT
(
ULEB128MaxSize
<
uint32_t
>
(
)
=
=
5
)
;
MOZ_RELEASE_ASSERT
(
ULEB128MaxSize
<
uint64_t
>
(
)
=
=
10
)
;
struct
TestDataU64
{
uint64_t
mValue
;
unsigned
mSize
;
const
char
*
mBytes
;
}
;
TestDataU64
tests
[
]
=
{
{
0u
1
"
\
0
"
}
{
1u
1
"
\
x01
"
}
{
0x7Fu
1
"
\
x7F
"
}
{
0x80u
2
"
\
x80
\
x01
"
}
{
0x81u
2
"
\
x81
\
x01
"
}
{
0xFFu
2
"
\
xFF
\
x01
"
}
{
0x100u
2
"
\
x80
\
x02
"
}
{
0xFFFFFFFFu
5
"
\
xFF
\
xFF
\
xFF
\
xFF
\
x0F
"
}
{
0xFFFFFFFFFFFFFFFFu
10
"
\
xFF
\
xFF
\
xFF
\
xFF
\
xFF
\
xFF
\
xFF
\
xFF
\
xFF
\
x01
"
}
}
;
for
(
const
TestDataU64
&
test
:
tests
)
{
MOZ_RELEASE_ASSERT
(
ULEB128Size
(
test
.
mValue
)
=
=
test
.
mSize
)
;
uint8_t
buffer
[
ULEB128MaxSize
<
uint64_t
>
(
)
]
;
uint8_t
*
p
=
buffer
;
WriteULEB128
(
test
.
mValue
p
)
;
MOZ_RELEASE_ASSERT
(
p
=
=
buffer
+
test
.
mSize
)
;
for
(
unsigned
i
=
0
;
i
<
test
.
mSize
;
+
+
i
)
{
MOZ_RELEASE_ASSERT
(
buffer
[
i
]
=
=
uint8_t
(
test
.
mBytes
[
i
]
)
)
;
}
p
=
buffer
;
uint64_t
read
=
ReadULEB128
<
uint64_t
>
(
p
)
;
MOZ_RELEASE_ASSERT
(
p
=
=
buffer
+
test
.
mSize
)
;
MOZ_RELEASE_ASSERT
(
read
=
=
test
.
mValue
)
;
}
printf
(
"
TestLEB128
done
\
n
"
)
;
}
static
void
TestModuloBuffer
(
ModuloBuffer
<
>
&
mb
uint32_t
MBSize
)
{
using
MB
=
ModuloBuffer
<
>
;
MOZ_RELEASE_ASSERT
(
mb
.
BufferLength
(
)
.
Value
(
)
=
=
MBSize
)
;
MOZ_RELEASE_ASSERT
(
mb
.
ReaderAt
(
2
)
=
=
mb
.
ReaderAt
(
2
)
)
;
MOZ_RELEASE_ASSERT
(
mb
.
ReaderAt
(
2
)
!
=
mb
.
ReaderAt
(
3
)
)
;
MOZ_RELEASE_ASSERT
(
mb
.
ReaderAt
(
2
)
<
mb
.
ReaderAt
(
3
)
)
;
MOZ_RELEASE_ASSERT
(
mb
.
ReaderAt
(
2
)
<
=
mb
.
ReaderAt
(
2
)
)
;
MOZ_RELEASE_ASSERT
(
mb
.
ReaderAt
(
2
)
<
=
mb
.
ReaderAt
(
3
)
)
;
MOZ_RELEASE_ASSERT
(
mb
.
ReaderAt
(
3
)
>
mb
.
ReaderAt
(
2
)
)
;
MOZ_RELEASE_ASSERT
(
mb
.
ReaderAt
(
2
)
>
=
mb
.
ReaderAt
(
2
)
)
;
MOZ_RELEASE_ASSERT
(
mb
.
ReaderAt
(
3
)
>
=
mb
.
ReaderAt
(
2
)
)
;
MOZ_RELEASE_ASSERT
(
mb
.
ReaderAt
(
2
)
!
=
mb
.
ReaderAt
(
MBSize
+
2
)
)
;
MOZ_RELEASE_ASSERT
(
mb
.
ReaderAt
(
MBSize
+
2
)
!
=
mb
.
ReaderAt
(
2
)
)
;
static_assert
(
std
:
:
is_same
<
decltype
(
*
mb
.
ReaderAt
(
0
)
)
const
MB
:
:
Byte
&
>
:
:
value
"
Dereferencing
from
a
reader
should
return
const
Byte
*
"
)
;
static_assert
(
std
:
:
is_same
<
decltype
(
*
mb
.
WriterAt
(
0
)
)
MB
:
:
Byte
&
>
:
:
value
"
Dereferencing
from
a
writer
should
return
Byte
*
"
)
;
MOZ_RELEASE_ASSERT
(
&
*
mb
.
ReaderAt
(
MBSize
-
1
)
=
=
&
*
mb
.
ReaderAt
(
0
)
+
(
MBSize
-
1
)
)
;
MOZ_RELEASE_ASSERT
(
&
*
mb
.
ReaderAt
(
MBSize
)
=
=
&
*
mb
.
ReaderAt
(
0
)
)
;
MOZ_RELEASE_ASSERT
(
&
*
mb
.
ReaderAt
(
MBSize
+
MBSize
-
1
)
=
=
&
*
mb
.
ReaderAt
(
MBSize
-
1
)
)
;
MOZ_RELEASE_ASSERT
(
&
*
mb
.
ReaderAt
(
MBSize
+
MBSize
)
=
=
&
*
mb
.
ReaderAt
(
0
)
)
;
MOZ_RELEASE_ASSERT
(
&
*
mb
.
ReaderAt
(
uint32_t
(
-
1
)
)
=
=
&
*
mb
.
ReaderAt
(
MBSize
-
1
)
)
;
MOZ_RELEASE_ASSERT
(
&
*
mb
.
ReaderAt
(
static_cast
<
MB
:
:
Index
>
(
-
1
)
)
=
=
&
*
mb
.
ReaderAt
(
MBSize
-
1
)
)
;
MB
:
:
Reader
arit
=
mb
.
ReaderAt
(
0
)
;
MOZ_RELEASE_ASSERT
(
+
+
arit
=
=
mb
.
ReaderAt
(
1
)
)
;
MOZ_RELEASE_ASSERT
(
arit
=
=
mb
.
ReaderAt
(
1
)
)
;
MOZ_RELEASE_ASSERT
(
-
-
arit
=
=
mb
.
ReaderAt
(
0
)
)
;
MOZ_RELEASE_ASSERT
(
arit
=
=
mb
.
ReaderAt
(
0
)
)
;
MOZ_RELEASE_ASSERT
(
arit
+
+
=
=
mb
.
ReaderAt
(
0
)
)
;
MOZ_RELEASE_ASSERT
(
arit
=
=
mb
.
ReaderAt
(
1
)
)
;
MOZ_RELEASE_ASSERT
(
arit
-
-
=
=
mb
.
ReaderAt
(
1
)
)
;
MOZ_RELEASE_ASSERT
(
arit
=
=
mb
.
ReaderAt
(
0
)
)
;
MOZ_RELEASE_ASSERT
(
arit
+
3
=
=
mb
.
ReaderAt
(
3
)
)
;
MOZ_RELEASE_ASSERT
(
arit
=
=
mb
.
ReaderAt
(
0
)
)
;
MOZ_RELEASE_ASSERT
(
4
+
arit
=
=
mb
.
ReaderAt
(
4
)
)
;
MOZ_RELEASE_ASSERT
(
arit
=
=
mb
.
ReaderAt
(
0
)
)
;
const
bool
checkPlusEq
=
(
(
arit
+
=
3
)
=
=
mb
.
ReaderAt
(
3
)
)
;
MOZ_RELEASE_ASSERT
(
checkPlusEq
)
;
MOZ_RELEASE_ASSERT
(
arit
=
=
mb
.
ReaderAt
(
3
)
)
;
MOZ_RELEASE_ASSERT
(
(
arit
-
2
)
=
=
mb
.
ReaderAt
(
1
)
)
;
MOZ_RELEASE_ASSERT
(
arit
=
=
mb
.
ReaderAt
(
3
)
)
;
const
bool
checkMinusEq
=
(
(
arit
-
=
2
)
=
=
mb
.
ReaderAt
(
1
)
)
;
MOZ_RELEASE_ASSERT
(
checkMinusEq
)
;
MOZ_RELEASE_ASSERT
(
arit
=
=
mb
.
ReaderAt
(
1
)
)
;
MOZ_RELEASE_ASSERT
(
&
arit
[
3
]
=
=
&
*
(
arit
+
3
)
)
;
MOZ_RELEASE_ASSERT
(
arit
=
=
mb
.
ReaderAt
(
1
)
)
;
MOZ_RELEASE_ASSERT
(
mb
.
ReaderAt
(
3
)
-
mb
.
ReaderAt
(
1
)
=
=
2
)
;
MOZ_RELEASE_ASSERT
(
mb
.
ReaderAt
(
1
)
-
mb
.
ReaderAt
(
3
)
=
=
MB
:
:
Index
(
-
2
)
)
;
MB
:
:
Writer
it
=
mb
.
WriterAt
(
0
)
;
MOZ_RELEASE_ASSERT
(
it
.
CurrentIndex
(
)
=
=
0
)
;
it
.
WriteObject
(
'
x
'
)
;
it
.
WriteObject
(
'
y
'
)
;
it
-
=
2
;
MOZ_RELEASE_ASSERT
(
it
.
PeekObject
<
char
>
(
)
=
=
'
x
'
)
;
MOZ_RELEASE_ASSERT
(
it
.
CurrentIndex
(
)
=
=
0
)
;
MOZ_RELEASE_ASSERT
(
it
.
ReadObject
<
char
>
(
)
=
=
'
x
'
)
;
MOZ_RELEASE_ASSERT
(
it
.
CurrentIndex
(
)
=
=
1
)
;
MOZ_RELEASE_ASSERT
(
it
.
PeekObject
<
char
>
(
)
=
=
'
y
'
)
;
MOZ_RELEASE_ASSERT
(
it
.
CurrentIndex
(
)
=
=
1
)
;
MOZ_RELEASE_ASSERT
(
it
.
ReadObject
<
char
>
(
)
=
=
'
y
'
)
;
MOZ_RELEASE_ASSERT
(
it
.
CurrentIndex
(
)
=
=
2
)
;
MB
:
:
Reader
it2
(
it
)
;
MOZ_RELEASE_ASSERT
(
it2
.
CurrentIndex
(
)
=
=
2
)
;
it2
=
it
;
MOZ_RELEASE_ASSERT
(
it2
.
CurrentIndex
(
)
=
=
2
)
;
static_assert
(
std
:
:
is_same
<
std
:
:
iterator_traits
<
MB
:
:
Reader
>
:
:
difference_type
MB
:
:
Index
>
:
:
value
"
ModuloBuffer
:
:
Reader
:
:
difference_type
should
be
Index
"
)
;
static_assert
(
std
:
:
is_same
<
std
:
:
iterator_traits
<
MB
:
:
Reader
>
:
:
value_type
MB
:
:
Byte
>
:
:
value
"
ModuloBuffer
:
:
Reader
:
:
value_type
should
be
Byte
"
)
;
static_assert
(
std
:
:
is_same
<
std
:
:
iterator_traits
<
MB
:
:
Reader
>
:
:
pointer
const
MB
:
:
Byte
*
>
:
:
value
"
ModuloBuffer
:
:
Reader
:
:
pointer
should
be
const
Byte
*
"
)
;
static_assert
(
std
:
:
is_same
<
std
:
:
iterator_traits
<
MB
:
:
Reader
>
:
:
reference
const
MB
:
:
Byte
&
>
:
:
value
"
ModuloBuffer
:
:
Reader
:
:
reference
should
be
const
Byte
&
"
)
;
static_assert
(
std
:
:
is_base_of
<
std
:
:
input_iterator_tag
std
:
:
iterator_traits
<
MB
:
:
Reader
>
:
:
iterator_category
>
:
:
value
"
ModuloBuffer
:
:
Reader
:
:
iterator_category
should
be
derived
"
"
from
input_iterator_tag
"
)
;
static_assert
(
std
:
:
is_base_of
<
std
:
:
forward_iterator_tag
std
:
:
iterator_traits
<
MB
:
:
Reader
>
:
:
iterator_category
>
:
:
value
"
ModuloBuffer
:
:
Reader
:
:
iterator_category
should
be
derived
"
"
from
forward_iterator_tag
"
)
;
static_assert
(
std
:
:
is_base_of
<
std
:
:
bidirectional_iterator_tag
std
:
:
iterator_traits
<
MB
:
:
Reader
>
:
:
iterator_category
>
:
:
value
"
ModuloBuffer
:
:
Reader
:
:
iterator_category
should
be
derived
"
"
from
bidirectional_iterator_tag
"
)
;
static_assert
(
std
:
:
is_same
<
std
:
:
iterator_traits
<
MB
:
:
Reader
>
:
:
iterator_category
std
:
:
random_access_iterator_tag
>
:
:
value
"
ModuloBuffer
:
:
Reader
:
:
iterator_category
should
be
"
"
random_access_iterator_tag
"
)
;
std
:
:
string
s
(
mb
.
ReaderAt
(
0
)
mb
.
ReaderAt
(
2
)
)
;
MOZ_RELEASE_ASSERT
(
s
=
=
"
xy
"
)
;
it
.
WriteObject
(
int32_t
(
123
)
)
;
MOZ_RELEASE_ASSERT
(
it
.
CurrentIndex
(
)
=
=
6
)
;
it
.
WriteObject
(
int32_t
(
456
)
)
;
MOZ_RELEASE_ASSERT
(
it
.
CurrentIndex
(
)
=
=
MBSize
+
2
)
;
MOZ_RELEASE_ASSERT
(
it
.
ReadObject
<
int32_t
>
(
)
=
=
123
)
;
MOZ_RELEASE_ASSERT
(
it
.
CurrentIndex
(
)
=
=
MBSize
+
6
)
;
MOZ_RELEASE_ASSERT
(
it
.
ReadObject
<
int32_t
>
(
)
=
=
456
)
;
MOZ_RELEASE_ASSERT
(
it
.
CurrentIndex
(
)
=
=
MBSize
+
MBSize
+
2
)
;
}
void
TestModuloBuffer
(
)
{
printf
(
"
TestModuloBuffer
.
.
.
\
n
"
)
;
using
MB
=
ModuloBuffer
<
>
;
constexpr
uint32_t
MBSize
=
8
;
MB
mbByLength
(
MakePowerOfTwo32
<
MBSize
>
(
)
)
;
TestModuloBuffer
(
mbByLength
MBSize
)
;
auto
uniqueBuffer
=
MakeUnique
<
uint8_t
[
]
>
(
MBSize
)
;
MB
mbByUniquePtr
(
MakeUnique
<
uint8_t
[
]
>
(
MBSize
)
MakePowerOfTwo32
<
MBSize
>
(
)
)
;
TestModuloBuffer
(
mbByUniquePtr
MBSize
)
;
uint8_t
buffer
[
MBSize
*
3
]
;
for
(
size_t
i
=
0
;
i
<
MBSize
*
3
;
+
+
i
)
{
buffer
[
i
]
=
uint8_t
(
'
A
'
+
i
)
;
}
MB
mbByBuffer
(
&
buffer
[
MBSize
]
MakePowerOfTwo32
<
MBSize
>
(
)
)
;
TestModuloBuffer
(
mbByBuffer
MBSize
)
;
uint32_t
changed
=
0
;
for
(
size_t
i
=
MBSize
;
i
<
MBSize
*
2
;
+
+
i
)
{
changed
+
=
(
buffer
[
i
]
=
=
uint8_t
(
'
A
'
+
i
)
)
?
0
:
1
;
}
MOZ_RELEASE_ASSERT
(
changed
>
=
MBSize
*
6
/
8
)
;
for
(
size_t
i
=
0
;
i
<
MBSize
;
+
+
i
)
{
MOZ_RELEASE_ASSERT
(
buffer
[
i
]
=
=
uint8_t
(
'
A
'
+
i
)
)
;
}
for
(
size_t
i
=
MBSize
*
2
;
i
<
MBSize
*
3
;
+
+
i
)
{
MOZ_RELEASE_ASSERT
(
buffer
[
i
]
=
=
uint8_t
(
'
A
'
+
i
)
)
;
}
MB
mbByStolenBuffer
=
std
:
:
move
(
mbByBuffer
)
;
TestModuloBuffer
(
mbByStolenBuffer
MBSize
)
;
changed
=
0
;
for
(
size_t
i
=
MBSize
;
i
<
MBSize
*
2
;
+
+
i
)
{
changed
+
=
(
buffer
[
i
]
=
=
uint8_t
(
'
A
'
+
i
)
)
?
0
:
1
;
}
MOZ_RELEASE_ASSERT
(
changed
>
=
MBSize
*
6
/
8
)
;
for
(
size_t
i
=
0
;
i
<
MBSize
;
+
+
i
)
{
MOZ_RELEASE_ASSERT
(
buffer
[
i
]
=
=
uint8_t
(
'
A
'
+
i
)
)
;
}
for
(
size_t
i
=
MBSize
*
2
;
i
<
MBSize
*
3
;
+
+
i
)
{
MOZ_RELEASE_ASSERT
(
buffer
[
i
]
=
=
uint8_t
(
'
A
'
+
i
)
)
;
}
auto
TestReadInto
=
[
]
(
MB
:
:
Index
aReadFrom
MB
:
:
Index
aWriteTo
MB
:
:
Length
aBytes
)
{
constexpr
uint32_t
TRISize
=
16
;
uint8_t
input
[
TRISize
+
1
]
=
"
ABCDEFGHIJKLMNOP
"
;
const
MB
mbInput
(
input
MakePowerOfTwo32
<
TRISize
>
(
)
)
;
uint8_t
output
[
TRISize
+
1
]
=
"
abcdefghijklmnop
"
;
MB
mbOutput
(
output
MakePowerOfTwo32
<
TRISize
>
(
)
)
;
auto
writer
=
mbOutput
.
WriterAt
(
aWriteTo
)
;
mbInput
.
ReaderAt
(
aReadFrom
)
.
ReadInto
(
writer
aBytes
)
;
uint8_t
outputCheck
[
TRISize
+
1
]
=
"
abcdefghijklmnop
"
;
MB
mbOutputCheck
(
outputCheck
MakePowerOfTwo32
<
TRISize
>
(
)
)
;
auto
readerCheck
=
mbInput
.
ReaderAt
(
aReadFrom
)
;
auto
writerCheck
=
mbOutputCheck
.
WriterAt
(
aWriteTo
)
;
for
(
MB
:
:
Length
i
=
0
;
i
<
aBytes
;
+
+
i
)
{
*
writerCheck
+
+
=
*
readerCheck
+
+
;
}
for
(
uint32_t
i
=
0
;
i
<
TRISize
;
+
+
i
)
{
#
ifdef
TEST_MODULOBUFFER_FAILURE_DEBUG
if
(
output
[
i
]
!
=
outputCheck
[
i
]
)
{
printf
(
"
*
*
*
from
=
%
u
to
=
%
u
bytes
=
%
u
i
=
%
u
\
ninput
:
'
%
s
'
\
noutput
:
"
"
'
%
s
'
\
ncheck
:
'
%
s
'
\
n
"
unsigned
(
aReadFrom
)
unsigned
(
aWriteTo
)
unsigned
(
aBytes
)
unsigned
(
i
)
input
output
outputCheck
)
;
}
#
endif
MOZ_RELEASE_ASSERT
(
output
[
i
]
=
=
outputCheck
[
i
]
)
;
}
#
ifdef
TEST_MODULOBUFFER_HELPER
printf
(
"
*
*
*
from
=
%
u
to
=
%
u
bytes
=
%
u
output
:
%
s
\
n
"
unsigned
(
aReadFrom
)
unsigned
(
aWriteTo
)
unsigned
(
aBytes
)
output
)
;
#
endif
return
std
:
:
string
(
reinterpret_cast
<
const
char
*
>
(
output
)
)
;
}
;
constexpr
uint32_t
TRISize
=
16
;
MOZ_RELEASE_ASSERT
(
TestReadInto
(
0
0
0
)
=
=
"
abcdefghijklmnop
"
)
;
MOZ_RELEASE_ASSERT
(
TestReadInto
(
0
0
TRISize
)
=
=
"
ABCDEFGHIJKLMNOP
"
)
;
MOZ_RELEASE_ASSERT
(
TestReadInto
(
0
5
TRISize
)
=
=
"
LMNOPABCDEFGHIJK
"
)
;
MOZ_RELEASE_ASSERT
(
TestReadInto
(
5
0
TRISize
)
=
=
"
FGHIJKLMNOPABCDE
"
)
;
for
(
MB
:
:
Index
r
=
0
;
r
<
TRISize
;
+
+
r
)
{
for
(
MB
:
:
Index
w
=
0
;
w
<
TRISize
;
+
+
w
)
{
for
(
MB
:
:
Length
len
=
0
;
len
<
TRISize
;
+
+
len
)
{
TestReadInto
(
r
w
len
)
;
}
}
}
printf
(
"
TestModuloBuffer
done
\
n
"
)
;
}
static
uint64_t
ExtractBlockIndex
(
const
BlocksRingBuffer
:
:
BlockIndex
bi
)
{
uint64_t
index
;
static_assert
(
sizeof
(
bi
)
=
=
sizeof
(
index
)
"
BlockIndex
expected
to
only
contain
a
uint64_t
"
)
;
memcpy
(
&
index
&
bi
sizeof
(
index
)
)
;
return
index
;
}
;
void
TestBlocksRingBufferAPI
(
)
{
printf
(
"
TestBlocksRingBufferAPI
.
.
.
\
n
"
)
;
constexpr
uint32_t
MBSize
=
16
;
uint8_t
buffer
[
MBSize
*
3
]
;
for
(
size_t
i
=
0
;
i
<
MBSize
*
3
;
+
+
i
)
{
buffer
[
i
]
=
uint8_t
(
'
A
'
+
i
)
;
}
{
BlocksRingBuffer
rb
(
BlocksRingBuffer
:
:
ThreadSafety
:
:
WithMutex
&
buffer
[
MBSize
]
MakePowerOfTwo32
<
MBSize
>
(
)
)
;
#
define
VERIFY_START_END_PUSHED_CLEARED
(
aStart
aEnd
aPushed
aCleared
)
\
{
\
BlocksRingBuffer
:
:
State
state
=
rb
.
GetState
(
)
;
\
MOZ_RELEASE_ASSERT
(
ExtractBlockIndex
(
state
.
mRangeStart
)
=
=
(
aStart
)
)
;
\
MOZ_RELEASE_ASSERT
(
ExtractBlockIndex
(
state
.
mRangeEnd
)
=
=
(
aEnd
)
)
;
\
MOZ_RELEASE_ASSERT
(
state
.
mPushedBlockCount
=
=
(
aPushed
)
)
;
\
MOZ_RELEASE_ASSERT
(
state
.
mClearedBlockCount
=
=
(
aCleared
)
)
;
\
}
VERIFY_START_END_PUSHED_CLEARED
(
1
1
0
0
)
;
BlocksRingBuffer
:
:
BlockIndex
bi0
;
if
(
bi0
)
{
MOZ_RELEASE_ASSERT
(
false
"
if
(
BlockIndex
{
}
)
should
fail
test
"
)
;
}
if
(
!
bi0
)
{
}
else
{
MOZ_RELEASE_ASSERT
(
false
"
if
(
!
BlockIndex
{
}
)
should
succeed
test
"
)
;
}
MOZ_RELEASE_ASSERT
(
!
bi0
)
;
MOZ_RELEASE_ASSERT
(
bi0
=
=
bi0
)
;
MOZ_RELEASE_ASSERT
(
bi0
<
=
bi0
)
;
MOZ_RELEASE_ASSERT
(
bi0
>
=
bi0
)
;
MOZ_RELEASE_ASSERT
(
!
(
bi0
!
=
bi0
)
)
;
MOZ_RELEASE_ASSERT
(
!
(
bi0
<
bi0
)
)
;
MOZ_RELEASE_ASSERT
(
!
(
bi0
>
bi0
)
)
;
rb
.
ReadAt
(
bi0
[
]
(
Maybe
<
BlocksRingBuffer
:
:
EntryReader
>
&
&
aMaybeReader
)
{
MOZ_RELEASE_ASSERT
(
aMaybeReader
.
isNothing
(
)
)
;
}
)
;
MOZ_RELEASE_ASSERT
(
ExtractBlockIndex
(
rb
.
PutObject
(
uint32_t
(
1
)
)
)
=
=
1
)
;
VERIFY_START_END_PUSHED_CLEARED
(
1
6
1
0
)
;
auto
bi2
=
rb
.
ReserveAndPut
(
[
]
(
)
{
return
sizeof
(
uint32_t
)
;
}
[
]
(
BlocksRingBuffer
:
:
EntryWriter
*
aEW
)
{
MOZ_RELEASE_ASSERT
(
!
!
aEW
)
;
aEW
-
>
WriteObject
(
uint32_t
(
2
)
)
;
return
aEW
-
>
CurrentBlockIndex
(
)
;
}
)
;
static_assert
(
std
:
:
is_same
<
decltype
(
bi2
)
BlocksRingBuffer
:
:
BlockIndex
>
:
:
value
"
All
index
-
returning
functions
should
return
a
"
"
BlocksRingBuffer
:
:
BlockIndex
"
)
;
MOZ_RELEASE_ASSERT
(
ExtractBlockIndex
(
bi2
)
=
=
6
)
;
VERIFY_START_END_PUSHED_CLEARED
(
1
11
2
0
)
;
auto
bi2Next
=
rb
.
ReadAt
(
bi2
[
]
(
Maybe
<
BlocksRingBuffer
:
:
EntryReader
>
&
&
aMaybeReader
)
{
MOZ_RELEASE_ASSERT
(
aMaybeReader
.
isSome
(
)
)
;
MOZ_RELEASE_ASSERT
(
aMaybeReader
-
>
ReadObject
<
uint32_t
>
(
)
=
=
2
)
;
MOZ_RELEASE_ASSERT
(
aMaybeReader
-
>
GetEntryAt
(
aMaybeReader
-
>
NextBlockIndex
(
)
)
.
isNothing
(
)
)
;
return
aMaybeReader
-
>
NextBlockIndex
(
)
;
}
)
;
rb
.
ReadAt
(
bi2Next
[
]
(
Maybe
<
BlocksRingBuffer
:
:
EntryReader
>
&
&
aMaybeReader
)
{
MOZ_RELEASE_ASSERT
(
aMaybeReader
.
isNothing
(
)
)
;
}
)
;
if
(
bi2
)
{
}
else
{
MOZ_RELEASE_ASSERT
(
false
"
if
(
non
-
default
-
BlockIndex
)
should
succeed
test
"
)
;
}
if
(
!
bi2
)
{
MOZ_RELEASE_ASSERT
(
false
"
if
(
!
non
-
default
-
BlockIndex
)
should
fail
test
"
)
;
}
MOZ_RELEASE_ASSERT
(
!
!
bi2
)
;
MOZ_RELEASE_ASSERT
(
bi2
=
=
bi2
)
;
MOZ_RELEASE_ASSERT
(
bi2
<
=
bi2
)
;
MOZ_RELEASE_ASSERT
(
bi2
>
=
bi2
)
;
MOZ_RELEASE_ASSERT
(
!
(
bi2
!
=
bi2
)
)
;
MOZ_RELEASE_ASSERT
(
!
(
bi2
<
bi2
)
)
;
MOZ_RELEASE_ASSERT
(
!
(
bi2
>
bi2
)
)
;
MOZ_RELEASE_ASSERT
(
bi0
!
=
bi2
)
;
MOZ_RELEASE_ASSERT
(
bi0
<
bi2
)
;
MOZ_RELEASE_ASSERT
(
bi0
<
=
bi2
)
;
MOZ_RELEASE_ASSERT
(
!
(
bi0
=
=
bi2
)
)
;
MOZ_RELEASE_ASSERT
(
!
(
bi0
>
bi2
)
)
;
MOZ_RELEASE_ASSERT
(
!
(
bi0
>
=
bi2
)
)
;
MOZ_RELEASE_ASSERT
(
bi2
!
=
bi0
)
;
MOZ_RELEASE_ASSERT
(
bi2
>
bi0
)
;
MOZ_RELEASE_ASSERT
(
bi2
>
=
bi0
)
;
MOZ_RELEASE_ASSERT
(
!
(
bi2
=
=
bi0
)
)
;
MOZ_RELEASE_ASSERT
(
!
(
bi2
<
bi0
)
)
;
MOZ_RELEASE_ASSERT
(
!
(
bi2
<
=
bi0
)
)
;
MOZ_RELEASE_ASSERT
(
bi2
!
=
bi2Next
)
;
MOZ_RELEASE_ASSERT
(
bi2
<
bi2Next
)
;
MOZ_RELEASE_ASSERT
(
bi2
<
=
bi2Next
)
;
MOZ_RELEASE_ASSERT
(
!
(
bi2
=
=
bi2Next
)
)
;
MOZ_RELEASE_ASSERT
(
!
(
bi2
>
bi2Next
)
)
;
MOZ_RELEASE_ASSERT
(
!
(
bi2
>
=
bi2Next
)
)
;
MOZ_RELEASE_ASSERT
(
bi2Next
!
=
bi2
)
;
MOZ_RELEASE_ASSERT
(
bi2Next
>
bi2
)
;
MOZ_RELEASE_ASSERT
(
bi2Next
>
=
bi2
)
;
MOZ_RELEASE_ASSERT
(
!
(
bi2Next
=
=
bi2
)
)
;
MOZ_RELEASE_ASSERT
(
!
(
bi2Next
<
bi2
)
)
;
MOZ_RELEASE_ASSERT
(
!
(
bi2Next
<
=
bi2
)
)
;
auto
put3
=
rb
.
Put
(
sizeof
(
uint32_t
)
[
&
]
(
BlocksRingBuffer
:
:
EntryWriter
*
aEW
)
{
MOZ_RELEASE_ASSERT
(
!
!
aEW
)
;
aEW
-
>
WriteObject
(
uint32_t
(
3
)
)
;
return
float
(
ExtractBlockIndex
(
aEW
-
>
CurrentBlockIndex
(
)
)
)
;
}
)
;
static_assert
(
std
:
:
is_same
<
decltype
(
put3
)
float
>
:
:
value
"
Expect
float
as
returned
by
callback
.
"
)
;
MOZ_RELEASE_ASSERT
(
put3
=
=
11
.
0
)
;
VERIFY_START_END_PUSHED_CLEARED
(
1
16
3
0
)
;
rb
.
ReadAt
(
bi2
[
&
]
(
Maybe
<
BlocksRingBuffer
:
:
EntryReader
>
&
&
aMaybeReader
)
{
MOZ_RELEASE_ASSERT
(
aMaybeReader
.
isSome
(
)
)
;
MOZ_RELEASE_ASSERT
(
aMaybeReader
-
>
ReadObject
<
uint32_t
>
(
)
=
=
2
)
;
MOZ_RELEASE_ASSERT
(
aMaybeReader
-
>
NextBlockIndex
(
)
=
=
bi2Next
)
;
MOZ_RELEASE_ASSERT
(
aMaybeReader
-
>
GetNextEntry
(
)
.
isSome
(
)
)
;
MOZ_RELEASE_ASSERT
(
aMaybeReader
-
>
GetEntryAt
(
aMaybeReader
-
>
NextBlockIndex
(
)
)
.
isSome
(
)
)
;
MOZ_RELEASE_ASSERT
(
aMaybeReader
-
>
GetNextEntry
(
)
-
>
CurrentBlockIndex
(
)
=
=
aMaybeReader
-
>
GetEntryAt
(
aMaybeReader
-
>
NextBlockIndex
(
)
)
-
>
CurrentBlockIndex
(
)
)
;
MOZ_RELEASE_ASSERT
(
aMaybeReader
-
>
GetEntryAt
(
aMaybeReader
-
>
NextBlockIndex
(
)
)
-
>
ReadObject
<
uint32_t
>
(
)
=
=
3
)
;
}
)
;
uint32_t
count
=
0
;
rb
.
ReadEach
(
[
&
]
(
BlocksRingBuffer
:
:
EntryReader
&
aReader
)
{
MOZ_RELEASE_ASSERT
(
aReader
.
ReadObject
<
uint32_t
>
(
)
=
=
+
+
count
)
;
}
)
;
MOZ_RELEASE_ASSERT
(
count
=
=
3
)
;
BlocksRingBuffer
:
:
BlockIndex
bi4
=
rb
.
PutObject
(
uint32_t
(
4
)
)
;
VERIFY_START_END_PUSHED_CLEARED
(
6
21
4
1
)
;
count
=
1
;
rb
.
ReadEach
(
[
&
]
(
BlocksRingBuffer
:
:
EntryReader
&
aReader
)
{
MOZ_RELEASE_ASSERT
(
aReader
.
ReadObject
<
uint32_t
>
(
)
=
=
+
+
count
)
;
}
)
;
MOZ_RELEASE_ASSERT
(
count
=
=
4
)
;
auto
bi5_6
=
rb
.
Put
(
sizeof
(
uint32_t
)
[
&
]
(
BlocksRingBuffer
:
:
EntryWriter
*
aEW
)
{
MOZ_RELEASE_ASSERT
(
!
!
aEW
)
;
aEW
-
>
WriteObject
(
uint32_t
(
5
)
)
;
MOZ_RELEASE_ASSERT
(
aEW
-
>
GetEntryAt
(
bi2
)
.
isNothing
(
)
)
;
MOZ_RELEASE_ASSERT
(
aEW
-
>
GetEntryAt
(
bi4
)
.
isSome
(
)
)
;
MOZ_RELEASE_ASSERT
(
aEW
-
>
GetEntryAt
(
bi4
)
-
>
CurrentBlockIndex
(
)
=
=
bi4
)
;
MOZ_RELEASE_ASSERT
(
aEW
-
>
GetEntryAt
(
bi4
)
-
>
ReadObject
<
uint32_t
>
(
)
=
=
4
)
;
return
MakePair
(
aEW
-
>
CurrentBlockIndex
(
)
aEW
-
>
BlockEndIndex
(
)
)
;
}
)
;
auto
&
bi5
=
bi5_6
.
first
(
)
;
auto
&
bi6
=
bi5_6
.
second
(
)
;
VERIFY_START_END_PUSHED_CLEARED
(
11
26
5
2
)
;
rb
.
ReadAt
(
bi2
[
]
(
Maybe
<
BlocksRingBuffer
:
:
EntryReader
>
&
&
aMaybeReader
)
{
MOZ_RELEASE_ASSERT
(
aMaybeReader
.
isNothing
(
)
)
;
}
)
;
rb
.
ReadAt
(
bi5
[
]
(
Maybe
<
BlocksRingBuffer
:
:
EntryReader
>
&
&
aMaybeReader
)
{
MOZ_RELEASE_ASSERT
(
aMaybeReader
.
isSome
(
)
)
;
MOZ_RELEASE_ASSERT
(
aMaybeReader
-
>
ReadObject
<
uint32_t
>
(
)
=
=
5
)
;
MOZ_RELEASE_ASSERT
(
aMaybeReader
-
>
GetEntryAt
(
aMaybeReader
-
>
NextBlockIndex
(
)
)
.
isNothing
(
)
)
;
}
)
;
rb
.
Read
(
[
&
]
(
BlocksRingBuffer
:
:
Reader
*
aReader
)
{
MOZ_RELEASE_ASSERT
(
!
!
aReader
)
;
MOZ_RELEASE_ASSERT
(
ExtractBlockIndex
(
aReader
-
>
begin
(
)
.
CurrentBlockIndex
(
)
)
=
=
11
)
;
MOZ_RELEASE_ASSERT
(
ExtractBlockIndex
(
aReader
-
>
end
(
)
.
CurrentBlockIndex
(
)
)
=
=
26
)
;
MOZ_RELEASE_ASSERT
(
aReader
-
>
At
(
bi0
)
=
=
aReader
-
>
begin
(
)
)
;
MOZ_RELEASE_ASSERT
(
aReader
-
>
At
(
bi2
)
=
=
aReader
-
>
begin
(
)
)
;
MOZ_RELEASE_ASSERT
(
aReader
-
>
At
(
aReader
-
>
begin
(
)
.
CurrentBlockIndex
(
)
)
=
=
aReader
-
>
begin
(
)
)
;
MOZ_RELEASE_ASSERT
(
ExtractBlockIndex
(
aReader
-
>
At
(
bi5
)
.
CurrentBlockIndex
(
)
)
=
=
21
)
;
MOZ_RELEASE_ASSERT
(
aReader
-
>
At
(
bi6
)
=
=
aReader
-
>
end
(
)
)
;
MOZ_RELEASE_ASSERT
(
aReader
-
>
At
(
aReader
-
>
end
(
)
.
CurrentBlockIndex
(
)
)
=
=
aReader
-
>
end
(
)
)
;
}
)
;
count
=
2
;
rb
.
ReadEach
(
[
&
]
(
BlocksRingBuffer
:
:
EntryReader
&
aReader
)
{
MOZ_RELEASE_ASSERT
(
aReader
.
ReadObject
<
uint32_t
>
(
)
=
=
+
+
count
)
;
}
)
;
MOZ_RELEASE_ASSERT
(
count
=
=
5
)
;
rb
.
ClearBefore
(
bi4
)
;
VERIFY_START_END_PUSHED_CLEARED
(
16
26
5
3
)
;
count
=
3
;
rb
.
ReadEach
(
[
&
]
(
BlocksRingBuffer
:
:
EntryReader
&
aReader
)
{
MOZ_RELEASE_ASSERT
(
aReader
.
ReadObject
<
uint32_t
>
(
)
=
=
+
+
count
)
;
}
)
;
MOZ_RELEASE_ASSERT
(
count
=
=
5
)
;
rb
.
ClearBefore
(
bi4
)
;
VERIFY_START_END_PUSHED_CLEARED
(
16
26
5
3
)
;
rb
.
ClearBefore
(
bi6
)
;
VERIFY_START_END_PUSHED_CLEARED
(
26
26
5
5
)
;
rb
.
ReadEach
(
[
&
]
(
auto
&
&
)
{
MOZ_RELEASE_ASSERT
(
false
)
;
}
)
;
rb
.
ReadAt
(
bi5
[
]
(
Maybe
<
BlocksRingBuffer
:
:
EntryReader
>
&
&
aMaybeReader
)
{
MOZ_RELEASE_ASSERT
(
aMaybeReader
.
isNothing
(
)
)
;
}
)
;
rb
.
ClearBefore
(
bi4
)
;
VERIFY_START_END_PUSHED_CLEARED
(
26
26
5
5
)
;
MOZ_RELEASE_ASSERT
(
rb
.
PutObject
(
uint32_t
(
6
)
)
=
=
bi6
)
;
VERIFY_START_END_PUSHED_CLEARED
(
26
31
6
5
)
;
{
uint8_t
buffer2
[
MBSize
]
;
BlocksRingBuffer
rb2
(
BlocksRingBuffer
:
:
ThreadSafety
:
:
WithoutMutex
buffer2
MakePowerOfTwo32
<
MBSize
>
(
)
)
;
rb2
.
PutObject
(
uint32_t
(
7
)
)
;
rb2
.
PutObject
(
uint32_t
(
8
)
)
;
VERIFY_START_END_PUSHED_CLEARED
(
26
31
6
5
)
;
rb
.
AppendContents
(
rb2
)
;
VERIFY_START_END_PUSHED_CLEARED
(
26
41
8
5
)
;
rb
.
AppendContents
(
rb2
)
;
VERIFY_START_END_PUSHED_CLEARED
(
36
51
10
7
)
;
}
VERIFY_START_END_PUSHED_CLEARED
(
36
51
10
7
)
;
rb
.
ReadAt
(
bi6
[
]
(
Maybe
<
BlocksRingBuffer
:
:
EntryReader
>
&
&
aMaybeReader
)
{
MOZ_RELEASE_ASSERT
(
aMaybeReader
.
isNothing
(
)
)
;
}
)
;
count
=
0
;
uint32_t
expected
[
3
]
=
{
8
7
8
}
;
rb
.
ReadEach
(
[
&
]
(
BlocksRingBuffer
:
:
EntryReader
&
aReader
)
{
MOZ_RELEASE_ASSERT
(
count
<
3
)
;
MOZ_RELEASE_ASSERT
(
aReader
.
ReadObject
<
uint32_t
>
(
)
=
=
expected
[
count
+
+
]
)
;
}
)
;
MOZ_RELEASE_ASSERT
(
count
=
=
3
)
;
}
uint32_t
changed
=
0
;
for
(
size_t
i
=
MBSize
;
i
<
MBSize
*
2
;
+
+
i
)
{
changed
+
=
(
buffer
[
i
]
=
=
uint8_t
(
'
A
'
+
i
)
)
?
0
:
1
;
}
MOZ_RELEASE_ASSERT
(
changed
>
=
MBSize
*
6
/
8
)
;
for
(
size_t
i
=
0
;
i
<
MBSize
;
+
+
i
)
{
MOZ_RELEASE_ASSERT
(
buffer
[
i
]
=
=
uint8_t
(
'
A
'
+
i
)
)
;
}
for
(
size_t
i
=
MBSize
*
2
;
i
<
MBSize
*
3
;
+
+
i
)
{
MOZ_RELEASE_ASSERT
(
buffer
[
i
]
=
=
uint8_t
(
'
A
'
+
i
)
)
;
}
printf
(
"
TestBlocksRingBufferAPI
done
\
n
"
)
;
}
void
TestBlocksRingBufferUnderlyingBufferChanges
(
)
{
printf
(
"
TestBlocksRingBufferUnderlyingBufferChanges
.
.
.
\
n
"
)
;
BlocksRingBuffer
rb
(
BlocksRingBuffer
:
:
ThreadSafety
:
:
WithMutex
)
;
BlocksRingBuffer
:
:
BlockIndex
bi
;
auto
testOutOfSession
=
[
&
]
(
)
{
MOZ_RELEASE_ASSERT
(
rb
.
BufferLength
(
)
.
isNothing
(
)
)
;
BlocksRingBuffer
:
:
State
state
=
rb
.
GetState
(
)
;
MOZ_RELEASE_ASSERT
(
state
.
mRangeStart
=
=
state
.
mRangeEnd
)
;
MOZ_RELEASE_ASSERT
(
state
.
mPushedBlockCount
=
=
0
)
;
MOZ_RELEASE_ASSERT
(
state
.
mClearedBlockCount
=
=
0
)
;
int32_t
ran
=
0
;
rb
.
Put
(
1
[
&
]
(
BlocksRingBuffer
:
:
EntryWriter
*
aMaybeEntryWriter
)
{
MOZ_RELEASE_ASSERT
(
!
aMaybeEntryWriter
)
;
+
+
ran
;
}
)
;
MOZ_RELEASE_ASSERT
(
ran
=
=
1
)
;
MOZ_RELEASE_ASSERT
(
rb
.
PutFrom
(
&
ran
sizeof
(
ran
)
)
=
=
BlocksRingBuffer
:
:
BlockIndex
{
}
)
;
MOZ_RELEASE_ASSERT
(
rb
.
PutObject
(
ran
)
=
=
BlocksRingBuffer
:
:
BlockIndex
{
}
)
;
ran
=
0
;
rb
.
Read
(
[
&
]
(
BlocksRingBuffer
:
:
Reader
*
aReader
)
{
MOZ_RELEASE_ASSERT
(
!
aReader
)
;
+
+
ran
;
}
)
;
MOZ_RELEASE_ASSERT
(
ran
=
=
1
)
;
ran
=
0
;
rb
.
ReadAt
(
BlocksRingBuffer
:
:
BlockIndex
{
}
[
&
]
(
Maybe
<
BlocksRingBuffer
:
:
EntryReader
>
&
&
aMaybeEntryReader
)
{
MOZ_RELEASE_ASSERT
(
aMaybeEntryReader
.
isNothing
(
)
)
;
+
+
ran
;
}
)
;
MOZ_RELEASE_ASSERT
(
ran
=
=
1
)
;
ran
=
0
;
rb
.
ReadAt
(
bi
[
&
]
(
Maybe
<
BlocksRingBuffer
:
:
EntryReader
>
&
&
aMaybeEntryReader
)
{
MOZ_RELEASE_ASSERT
(
aMaybeEntryReader
.
isNothing
(
)
)
;
+
+
ran
;
}
)
;
MOZ_RELEASE_ASSERT
(
ran
=
=
1
)
;
rb
.
ReadEach
(
[
]
(
auto
&
&
)
{
MOZ_RELEASE_ASSERT
(
false
)
;
}
)
;
}
;
testOutOfSession
(
)
;
testOutOfSession
(
)
;
rb
.
ClearBefore
(
bi
)
;
testOutOfSession
(
)
;
testOutOfSession
(
)
;
rb
.
Clear
(
)
;
testOutOfSession
(
)
;
testOutOfSession
(
)
;
rb
.
Reset
(
)
;
testOutOfSession
(
)
;
testOutOfSession
(
)
;
constexpr
uint32_t
MBSize
=
32
;
rb
.
Set
(
MakePowerOfTwo
<
BlocksRingBuffer
:
:
Length
MBSize
>
(
)
)
;
constexpr
bool
EMPTY
=
true
;
constexpr
bool
NOT_EMPTY
=
false
;
auto
testInSession
=
[
&
]
(
bool
aExpectEmpty
)
{
MOZ_RELEASE_ASSERT
(
rb
.
BufferLength
(
)
.
isSome
(
)
)
;
BlocksRingBuffer
:
:
State
state
=
rb
.
GetState
(
)
;
if
(
aExpectEmpty
)
{
MOZ_RELEASE_ASSERT
(
state
.
mRangeStart
=
=
state
.
mRangeEnd
)
;
MOZ_RELEASE_ASSERT
(
state
.
mPushedBlockCount
=
=
0
)
;
MOZ_RELEASE_ASSERT
(
state
.
mClearedBlockCount
=
=
0
)
;
}
else
{
MOZ_RELEASE_ASSERT
(
state
.
mRangeStart
<
state
.
mRangeEnd
)
;
MOZ_RELEASE_ASSERT
(
state
.
mPushedBlockCount
>
0
)
;
MOZ_RELEASE_ASSERT
(
state
.
mClearedBlockCount
<
=
state
.
mPushedBlockCount
)
;
}
int32_t
ran
=
0
;
bi
=
rb
.
Put
(
sizeof
(
ran
)
[
&
]
(
BlocksRingBuffer
:
:
EntryWriter
*
aMaybeEntryWriter
)
{
MOZ_RELEASE_ASSERT
(
!
!
aMaybeEntryWriter
)
;
+
+
ran
;
aMaybeEntryWriter
-
>
WriteObject
(
ran
)
;
return
aMaybeEntryWriter
-
>
CurrentBlockIndex
(
)
;
}
)
;
MOZ_RELEASE_ASSERT
(
ran
=
=
1
)
;
MOZ_RELEASE_ASSERT
(
rb
.
PutFrom
(
&
ran
sizeof
(
ran
)
)
!
=
BlocksRingBuffer
:
:
BlockIndex
{
}
)
;
MOZ_RELEASE_ASSERT
(
rb
.
PutObject
(
ran
)
!
=
BlocksRingBuffer
:
:
BlockIndex
{
}
)
;
ran
=
0
;
rb
.
Read
(
[
&
]
(
BlocksRingBuffer
:
:
Reader
*
aReader
)
{
MOZ_RELEASE_ASSERT
(
!
!
aReader
)
;
+
+
ran
;
}
)
;
MOZ_RELEASE_ASSERT
(
ran
=
=
1
)
;
ran
=
0
;
rb
.
ReadEach
(
[
&
]
(
BlocksRingBuffer
:
:
EntryReader
&
aEntryReader
)
{
MOZ_RELEASE_ASSERT
(
aEntryReader
.
RemainingBytes
(
)
=
=
sizeof
(
ran
)
)
;
MOZ_RELEASE_ASSERT
(
aEntryReader
.
ReadObject
<
decltype
(
ran
)
>
(
)
=
=
1
)
;
+
+
ran
;
}
)
;
MOZ_RELEASE_ASSERT
(
ran
>
=
3
)
;
ran
=
0
;
rb
.
ReadAt
(
BlocksRingBuffer
:
:
BlockIndex
{
}
[
&
]
(
Maybe
<
BlocksRingBuffer
:
:
EntryReader
>
&
&
aMaybeEntryReader
)
{
MOZ_RELEASE_ASSERT
(
aMaybeEntryReader
.
isNothing
(
)
)
;
+
+
ran
;
}
)
;
MOZ_RELEASE_ASSERT
(
ran
=
=
1
)
;
ran
=
0
;
rb
.
ReadAt
(
bi
[
&
]
(
Maybe
<
BlocksRingBuffer
:
:
EntryReader
>
&
&
aMaybeEntryReader
)
{
MOZ_RELEASE_ASSERT
(
aMaybeEntryReader
.
isNothing
(
)
=
=
!
bi
)
;
+
+
ran
;
}
)
;
MOZ_RELEASE_ASSERT
(
ran
=
=
1
)
;
}
;
testInSession
(
EMPTY
)
;
testInSession
(
NOT_EMPTY
)
;
rb
.
Set
(
MakePowerOfTwo
<
BlocksRingBuffer
:
:
Length
32
>
(
)
)
;
MOZ_RELEASE_ASSERT
(
rb
.
BufferLength
(
)
.
isSome
(
)
)
;
rb
.
ReadEach
(
[
]
(
auto
&
&
)
{
MOZ_RELEASE_ASSERT
(
false
)
;
}
)
;
testInSession
(
EMPTY
)
;
testInSession
(
NOT_EMPTY
)
;
rb
.
Reset
(
)
;
testOutOfSession
(
)
;
testOutOfSession
(
)
;
uint8_t
buffer
[
MBSize
*
3
]
;
for
(
size_t
i
=
0
;
i
<
MBSize
*
3
;
+
+
i
)
{
buffer
[
i
]
=
uint8_t
(
'
A
'
+
i
)
;
}
rb
.
Set
(
&
buffer
[
MBSize
]
MakePowerOfTwo
<
BlocksRingBuffer
:
:
Length
MBSize
>
(
)
)
;
MOZ_RELEASE_ASSERT
(
rb
.
BufferLength
(
)
.
isSome
(
)
)
;
rb
.
ReadEach
(
[
]
(
auto
&
&
)
{
MOZ_RELEASE_ASSERT
(
false
)
;
}
)
;
testInSession
(
EMPTY
)
;
testInSession
(
NOT_EMPTY
)
;
rb
.
Reset
(
)
;
testOutOfSession
(
)
;
testOutOfSession
(
)
;
rb
.
Set
(
&
buffer
[
MBSize
]
MakePowerOfTwo
<
BlocksRingBuffer
:
:
Length
MBSize
>
(
)
)
;
MOZ_RELEASE_ASSERT
(
rb
.
BufferLength
(
)
.
isSome
(
)
)
;
rb
.
ReadEach
(
[
]
(
auto
&
&
)
{
MOZ_RELEASE_ASSERT
(
false
)
;
}
)
;
testInSession
(
EMPTY
)
;
testInSession
(
NOT_EMPTY
)
;
rb
.
Reset
(
)
;
uint32_t
changed
=
0
;
for
(
size_t
i
=
MBSize
;
i
<
MBSize
*
2
;
+
+
i
)
{
changed
+
=
(
buffer
[
i
]
=
=
uint8_t
(
'
A
'
+
i
)
)
?
0
:
1
;
}
MOZ_RELEASE_ASSERT
(
changed
>
=
MBSize
*
6
/
8
)
;
for
(
size_t
i
=
0
;
i
<
MBSize
;
+
+
i
)
{
MOZ_RELEASE_ASSERT
(
buffer
[
i
]
=
=
uint8_t
(
'
A
'
+
i
)
)
;
}
for
(
size_t
i
=
MBSize
*
2
;
i
<
MBSize
*
3
;
+
+
i
)
{
MOZ_RELEASE_ASSERT
(
buffer
[
i
]
=
=
uint8_t
(
'
A
'
+
i
)
)
;
}
testOutOfSession
(
)
;
testOutOfSession
(
)
;
printf
(
"
TestBlocksRingBufferUnderlyingBufferChanges
done
\
n
"
)
;
}
void
TestBlocksRingBufferThreading
(
)
{
printf
(
"
TestBlocksRingBufferThreading
.
.
.
\
n
"
)
;
constexpr
uint32_t
MBSize
=
8192
;
uint8_t
buffer
[
MBSize
*
3
]
;
for
(
size_t
i
=
0
;
i
<
MBSize
*
3
;
+
+
i
)
{
buffer
[
i
]
=
uint8_t
(
'
A
'
+
i
)
;
}
BlocksRingBuffer
rb
(
BlocksRingBuffer
:
:
ThreadSafety
:
:
WithMutex
&
buffer
[
MBSize
]
MakePowerOfTwo32
<
MBSize
>
(
)
)
;
std
:
:
atomic
<
bool
>
stopReader
{
false
}
;
std
:
:
thread
reader
(
[
&
]
(
)
{
for
(
;
;
)
{
BlocksRingBuffer
:
:
State
state
=
rb
.
GetState
(
)
;
printf
(
"
Reader
:
range
=
%
llu
.
.
%
llu
(
%
llu
bytes
)
pushed
=
%
llu
cleared
=
%
llu
"
"
(
alive
=
%
llu
)
\
n
"
static_cast
<
unsigned
long
long
>
(
ExtractBlockIndex
(
state
.
mRangeStart
)
)
static_cast
<
unsigned
long
long
>
(
ExtractBlockIndex
(
state
.
mRangeEnd
)
)
static_cast
<
unsigned
long
long
>
(
ExtractBlockIndex
(
state
.
mRangeEnd
)
)
-
static_cast
<
unsigned
long
long
>
(
ExtractBlockIndex
(
state
.
mRangeStart
)
)
static_cast
<
unsigned
long
long
>
(
state
.
mPushedBlockCount
)
static_cast
<
unsigned
long
long
>
(
state
.
mClearedBlockCount
)
static_cast
<
unsigned
long
long
>
(
state
.
mPushedBlockCount
-
state
.
mClearedBlockCount
)
)
;
if
(
stopReader
)
{
break
;
}
:
:
SleepMilli
(
1
)
;
}
}
)
;
constexpr
int
ThreadCount
=
32
;
std
:
:
thread
threads
[
ThreadCount
]
;
for
(
int
threadNo
=
0
;
threadNo
<
ThreadCount
;
+
+
threadNo
)
{
threads
[
threadNo
]
=
std
:
:
thread
(
[
&
]
(
int
aThreadNo
)
{
:
:
SleepMilli
(
1
)
;
constexpr
int
pushCount
=
1024
;
for
(
int
push
=
0
;
push
<
pushCount
;
+
+
push
)
{
rb
.
Put
(
std
:
:
max
(
aThreadNo
int
(
sizeof
(
push
)
)
)
[
&
]
(
BlocksRingBuffer
:
:
EntryWriter
*
aEW
)
{
MOZ_RELEASE_ASSERT
(
!
!
aEW
)
;
aEW
-
>
WriteObject
(
aThreadNo
*
1000000
+
push
)
;
*
aEW
+
=
aEW
-
>
RemainingBytes
(
)
;
}
)
;
}
}
threadNo
)
;
}
for
(
auto
&
&
thread
:
threads
)
{
thread
.
join
(
)
;
}
stopReader
=
true
;
reader
.
join
(
)
;
uint32_t
changed
=
0
;
for
(
size_t
i
=
MBSize
;
i
<
MBSize
*
2
;
+
+
i
)
{
changed
+
=
(
buffer
[
i
]
=
=
uint8_t
(
'
A
'
+
i
)
)
?
0
:
1
;
}
MOZ_RELEASE_ASSERT
(
changed
>
=
MBSize
*
6
/
8
)
;
for
(
size_t
i
=
0
;
i
<
MBSize
;
+
+
i
)
{
MOZ_RELEASE_ASSERT
(
buffer
[
i
]
=
=
uint8_t
(
'
A
'
+
i
)
)
;
}
for
(
size_t
i
=
MBSize
*
2
;
i
<
MBSize
*
3
;
+
+
i
)
{
MOZ_RELEASE_ASSERT
(
buffer
[
i
]
=
=
uint8_t
(
'
A
'
+
i
)
)
;
}
printf
(
"
TestBlocksRingBufferThreading
done
\
n
"
)
;
}
void
TestBlocksRingBufferSerialization
(
)
{
printf
(
"
TestBlocksRingBufferSerialization
.
.
.
\
n
"
)
;
constexpr
uint32_t
MBSize
=
64
;
uint8_t
buffer
[
MBSize
*
3
]
;
for
(
size_t
i
=
0
;
i
<
MBSize
*
3
;
+
+
i
)
{
buffer
[
i
]
=
uint8_t
(
'
A
'
+
i
)
;
}
BlocksRingBuffer
rb
(
BlocksRingBuffer
:
:
ThreadSafety
:
:
WithMutex
&
buffer
[
MBSize
]
MakePowerOfTwo32
<
MBSize
>
(
)
)
;
#
define
THE_ANSWER
"
The
answer
is
"
const
char
*
theAnswer
=
THE_ANSWER
;
rb
.
PutObjects
(
'
0
'
WrapBlocksRingBufferLiteralCStringPointer
(
THE_ANSWER
)
42
std
:
:
string
(
"
but
pi
=
"
)
3
.
14
)
;
rb
.
ReadEach
(
[
&
]
(
BlocksRingBuffer
:
:
EntryReader
&
aER
)
{
char
c0
;
const
char
*
answer
;
int
integer
;
std
:
:
string
str
;
double
pi
;
aER
.
ReadIntoObjects
(
c0
answer
integer
str
pi
)
;
MOZ_RELEASE_ASSERT
(
c0
=
=
'
0
'
)
;
MOZ_RELEASE_ASSERT
(
answer
=
=
theAnswer
)
;
MOZ_RELEASE_ASSERT
(
integer
=
=
42
)
;
MOZ_RELEASE_ASSERT
(
str
=
=
"
but
pi
=
"
)
;
MOZ_RELEASE_ASSERT
(
pi
=
=
3
.
14
)
;
}
)
;
rb
.
ReadEach
(
[
&
]
(
BlocksRingBuffer
:
:
EntryReader
&
aER
)
{
char
c0
=
aER
.
ReadObject
<
char
>
(
)
;
MOZ_RELEASE_ASSERT
(
c0
=
=
'
0
'
)
;
const
char
*
answer
=
aER
.
ReadObject
<
const
char
*
>
(
)
;
MOZ_RELEASE_ASSERT
(
answer
=
=
theAnswer
)
;
int
integer
=
aER
.
ReadObject
<
int
>
(
)
;
MOZ_RELEASE_ASSERT
(
integer
=
=
42
)
;
std
:
:
string
str
=
aER
.
ReadObject
<
std
:
:
string
>
(
)
;
MOZ_RELEASE_ASSERT
(
str
=
=
"
but
pi
=
"
)
;
double
pi
=
aER
.
ReadObject
<
double
>
(
)
;
MOZ_RELEASE_ASSERT
(
pi
=
=
3
.
14
)
;
}
)
;
rb
.
Clear
(
)
;
BlocksRingBuffer
:
:
BlockIndex
blockIndex
=
rb
.
PutObject
(
123
)
;
MOZ_RELEASE_ASSERT
(
blockIndex
!
=
BlocksRingBuffer
:
:
BlockIndex
{
}
)
;
rb
.
PutObject
(
blockIndex
)
;
rb
.
Read
(
[
&
]
(
BlocksRingBuffer
:
:
Reader
*
aR
)
{
BlocksRingBuffer
:
:
BlockIterator
it
=
aR
-
>
begin
(
)
;
const
BlocksRingBuffer
:
:
BlockIterator
itEnd
=
aR
-
>
end
(
)
;
MOZ_RELEASE_ASSERT
(
it
!
=
itEnd
)
;
MOZ_RELEASE_ASSERT
(
(
*
it
)
.
ReadObject
<
int
>
(
)
=
=
123
)
;
+
+
it
;
MOZ_RELEASE_ASSERT
(
it
!
=
itEnd
)
;
MOZ_RELEASE_ASSERT
(
(
*
it
)
.
ReadObject
<
BlocksRingBuffer
:
:
BlockIndex
>
(
)
=
=
blockIndex
)
;
+
+
it
;
MOZ_RELEASE_ASSERT
(
it
=
=
itEnd
)
;
}
)
;
rb
.
Clear
(
)
;
rb
.
PutObjects
(
std
:
:
make_tuple
(
'
0
'
WrapBlocksRingBufferLiteralCStringPointer
(
THE_ANSWER
)
42
std
:
:
string
(
"
but
pi
=
"
)
3
.
14
)
)
;
rb
.
ReadEach
(
[
&
]
(
BlocksRingBuffer
:
:
EntryReader
&
aER
)
{
MOZ_RELEASE_ASSERT
(
aER
.
ReadObject
<
char
>
(
)
=
=
'
0
'
)
;
MOZ_RELEASE_ASSERT
(
aER
.
ReadObject
<
const
char
*
>
(
)
=
=
theAnswer
)
;
MOZ_RELEASE_ASSERT
(
aER
.
ReadObject
<
int
>
(
)
=
=
42
)
;
MOZ_RELEASE_ASSERT
(
aER
.
ReadObject
<
std
:
:
string
>
(
)
=
=
"
but
pi
=
"
)
;
MOZ_RELEASE_ASSERT
(
aER
.
ReadObject
<
double
>
(
)
=
=
3
.
14
)
;
}
)
;
rb
.
Clear
(
)
;
rb
.
PutObjects
(
MakeTuple
(
'
0
'
WrapBlocksRingBufferLiteralCStringPointer
(
THE_ANSWER
)
42
std
:
:
string
(
"
but
pi
=
"
)
3
.
14
)
)
;
rb
.
ReadEach
(
[
&
]
(
BlocksRingBuffer
:
:
EntryReader
&
aER
)
{
MOZ_RELEASE_ASSERT
(
aER
.
ReadObject
<
char
>
(
)
=
=
'
0
'
)
;
MOZ_RELEASE_ASSERT
(
aER
.
ReadObject
<
const
char
*
>
(
)
=
=
theAnswer
)
;
MOZ_RELEASE_ASSERT
(
aER
.
ReadObject
<
int
>
(
)
=
=
42
)
;
MOZ_RELEASE_ASSERT
(
aER
.
ReadObject
<
std
:
:
string
>
(
)
=
=
"
but
pi
=
"
)
;
MOZ_RELEASE_ASSERT
(
aER
.
ReadObject
<
double
>
(
)
=
=
3
.
14
)
;
}
)
;
rb
.
Clear
(
)
;
{
UniqueFreePtr
<
char
>
ufps
(
strdup
(
THE_ANSWER
)
)
;
rb
.
PutObjects
(
ufps
)
;
}
rb
.
ReadEach
(
[
&
]
(
BlocksRingBuffer
:
:
EntryReader
&
aER
)
{
auto
ufps
=
aER
.
ReadObject
<
UniqueFreePtr
<
char
>
>
(
)
;
MOZ_RELEASE_ASSERT
(
!
!
ufps
)
;
MOZ_RELEASE_ASSERT
(
std
:
:
string
(
THE_ANSWER
)
=
=
ufps
.
get
(
)
)
;
}
)
;
rb
.
Clear
(
)
;
int
intArray
[
]
=
{
1
2
3
4
5
}
;
rb
.
PutObjects
(
MakeSpan
(
intArray
)
)
;
rb
.
ReadEach
(
[
&
]
(
BlocksRingBuffer
:
:
EntryReader
&
aER
)
{
int
intArrayOut
[
sizeof
(
intArray
)
/
sizeof
(
intArray
[
0
]
)
]
=
{
0
}
;
auto
outSpan
=
MakeSpan
(
intArrayOut
)
;
aER
.
ReadIntoObject
(
outSpan
)
;
for
(
size_t
i
=
0
;
i
<
sizeof
(
intArray
)
/
sizeof
(
intArray
[
0
]
)
;
+
+
i
)
{
MOZ_RELEASE_ASSERT
(
intArrayOut
[
i
]
=
=
intArray
[
i
]
)
;
}
}
)
;
rb
.
Clear
(
)
;
rb
.
PutObjects
(
Maybe
<
int
>
(
Nothing
{
}
)
Maybe
<
int
>
(
Some
(
123
)
)
)
;
rb
.
ReadEach
(
[
&
]
(
BlocksRingBuffer
:
:
EntryReader
&
aER
)
{
Maybe
<
int
>
mi0
mi1
;
aER
.
ReadIntoObjects
(
mi0
mi1
)
;
MOZ_RELEASE_ASSERT
(
mi0
.
isNothing
(
)
)
;
MOZ_RELEASE_ASSERT
(
mi1
.
isSome
(
)
)
;
MOZ_RELEASE_ASSERT
(
*
mi1
=
=
123
)
;
}
)
;
rb
.
Clear
(
)
;
using
V
=
Variant
<
int
double
int
>
;
V
v0
(
VariantIndex
<
0
>
{
}
123
)
;
V
v1
(
3
.
14
)
;
V
v2
(
VariantIndex
<
2
>
{
}
456
)
;
rb
.
PutObjects
(
v0
v1
v2
)
;
rb
.
ReadEach
(
[
&
]
(
BlocksRingBuffer
:
:
EntryReader
&
aER
)
{
MOZ_RELEASE_ASSERT
(
aER
.
ReadObject
<
V
>
(
)
=
=
v0
)
;
MOZ_RELEASE_ASSERT
(
aER
.
ReadObject
<
V
>
(
)
=
=
v1
)
;
MOZ_RELEASE_ASSERT
(
aER
.
ReadObject
<
V
>
(
)
=
=
v2
)
;
}
)
;
constexpr
uint32_t
MBSize2
=
MBSize
*
4
;
uint8_t
buffer2
[
MBSize2
*
3
]
;
for
(
size_t
i
=
0
;
i
<
MBSize2
*
3
;
+
+
i
)
{
buffer2
[
i
]
=
uint8_t
(
'
B
'
+
i
)
;
}
BlocksRingBuffer
rb2
(
BlocksRingBuffer
:
:
ThreadSafety
:
:
WithoutMutex
&
buffer2
[
MBSize2
]
MakePowerOfTwo32
<
MBSize2
>
(
)
)
;
rb2
.
PutObject
(
rb
)
;
uint8_t
buffer3
[
MBSize
*
3
]
;
for
(
size_t
i
=
0
;
i
<
MBSize
*
3
;
+
+
i
)
{
buffer3
[
i
]
=
uint8_t
(
'
C
'
+
i
)
;
}
BlocksRingBuffer
rb3
(
BlocksRingBuffer
:
:
ThreadSafety
:
:
WithoutMutex
&
buffer3
[
MBSize
]
MakePowerOfTwo32
<
MBSize
>
(
)
)
;
rb2
.
ReadEach
(
[
&
]
(
BlocksRingBuffer
:
:
EntryReader
&
aER
)
{
aER
.
ReadIntoObject
(
rb3
)
;
}
)
;
UniquePtr
<
BlocksRingBuffer
>
rb4up
;
rb2
.
ReadEach
(
[
&
]
(
BlocksRingBuffer
:
:
EntryReader
&
aER
)
{
rb4up
=
aER
.
ReadObject
<
UniquePtr
<
BlocksRingBuffer
>
>
(
)
;
}
)
;
MOZ_RELEASE_ASSERT
(
!
!
rb4up
)
;
rb
.
Clear
(
)
;
rb2
.
Clear
(
)
;
rb3
.
ReadEach
(
[
&
]
(
BlocksRingBuffer
:
:
EntryReader
&
aER
)
{
MOZ_RELEASE_ASSERT
(
aER
.
ReadObject
<
V
>
(
)
=
=
v0
)
;
MOZ_RELEASE_ASSERT
(
aER
.
ReadObject
<
V
>
(
)
=
=
v1
)
;
MOZ_RELEASE_ASSERT
(
aER
.
ReadObject
<
V
>
(
)
=
=
v2
)
;
}
)
;
rb4up
-
>
ReadEach
(
[
&
]
(
BlocksRingBuffer
:
:
EntryReader
&
aER
)
{
MOZ_RELEASE_ASSERT
(
aER
.
ReadObject
<
V
>
(
)
=
=
v0
)
;
MOZ_RELEASE_ASSERT
(
aER
.
ReadObject
<
V
>
(
)
=
=
v1
)
;
MOZ_RELEASE_ASSERT
(
aER
.
ReadObject
<
V
>
(
)
=
=
v2
)
;
}
)
;
MOZ_RELEASE_ASSERT
(
rb3
.
GetState
(
)
.
mRangeStart
=
=
rb4up
-
>
GetState
(
)
.
mRangeStart
)
;
MOZ_RELEASE_ASSERT
(
rb3
.
GetState
(
)
.
mRangeEnd
=
=
rb4up
-
>
GetState
(
)
.
mRangeEnd
)
;
MOZ_RELEASE_ASSERT
(
rb3
.
GetState
(
)
.
mPushedBlockCount
=
=
rb4up
-
>
GetState
(
)
.
mPushedBlockCount
)
;
MOZ_RELEASE_ASSERT
(
rb3
.
GetState
(
)
.
mClearedBlockCount
=
=
rb4up
-
>
GetState
(
)
.
mClearedBlockCount
)
;
uint32_t
changed
=
0
;
for
(
size_t
i
=
MBSize
;
i
<
MBSize
*
2
;
+
+
i
)
{
changed
+
=
(
buffer
[
i
]
=
=
uint8_t
(
'
A
'
+
i
)
)
?
0
:
1
;
}
MOZ_RELEASE_ASSERT
(
changed
>
=
MBSize
*
6
/
8
)
;
for
(
size_t
i
=
0
;
i
<
MBSize
;
+
+
i
)
{
MOZ_RELEASE_ASSERT
(
buffer
[
i
]
=
=
uint8_t
(
'
A
'
+
i
)
)
;
}
for
(
size_t
i
=
MBSize
*
2
;
i
<
MBSize
*
3
;
+
+
i
)
{
MOZ_RELEASE_ASSERT
(
buffer
[
i
]
=
=
uint8_t
(
'
A
'
+
i
)
)
;
}
for
(
size_t
i
=
0
;
i
<
MBSize2
;
+
+
i
)
{
MOZ_RELEASE_ASSERT
(
buffer2
[
i
]
=
=
uint8_t
(
'
B
'
+
i
)
)
;
}
for
(
size_t
i
=
MBSize2
*
2
;
i
<
MBSize2
*
3
;
+
+
i
)
{
MOZ_RELEASE_ASSERT
(
buffer2
[
i
]
=
=
uint8_t
(
'
B
'
+
i
)
)
;
}
for
(
size_t
i
=
0
;
i
<
MBSize
;
+
+
i
)
{
MOZ_RELEASE_ASSERT
(
buffer3
[
i
]
=
=
uint8_t
(
'
C
'
+
i
)
)
;
}
for
(
size_t
i
=
MBSize
*
2
;
i
<
MBSize
*
3
;
+
+
i
)
{
MOZ_RELEASE_ASSERT
(
buffer3
[
i
]
=
=
uint8_t
(
'
C
'
+
i
)
)
;
}
printf
(
"
TestBlocksRingBufferSerialization
done
\
n
"
)
;
}
class
BaseTestMarkerPayload
:
public
baseprofiler
:
:
ProfilerMarkerPayload
{
public
:
explicit
BaseTestMarkerPayload
(
int
aData
)
:
mData
(
aData
)
{
}
int
GetData
(
)
const
{
return
mData
;
}
static
UniquePtr
<
ProfilerMarkerPayload
>
Deserialize
(
BlocksRingBuffer
:
:
EntryReader
&
aEntryReader
)
;
BlocksRingBuffer
:
:
Length
TagAndSerializationBytes
(
)
const
override
;
void
SerializeTagAndPayload
(
BlocksRingBuffer
:
:
EntryWriter
&
aEntryWriter
)
const
override
;
void
StreamPayload
(
:
:
mozilla
:
:
baseprofiler
:
:
SpliceableJSONWriter
&
aWriter
const
:
:
mozilla
:
:
TimeStamp
&
aProcessStartTime
:
:
mozilla
:
:
baseprofiler
:
:
UniqueStacks
&
aUniqueStacks
)
const
override
;
private
:
BaseTestMarkerPayload
(
CommonProps
&
&
aProps
int
aData
)
:
baseprofiler
:
:
ProfilerMarkerPayload
(
std
:
:
move
(
aProps
)
)
mData
(
aData
)
{
}
int
mData
;
}
;
UniquePtr
<
baseprofiler
:
:
ProfilerMarkerPayload
>
BaseTestMarkerPayload
:
:
Deserialize
(
BlocksRingBuffer
:
:
EntryReader
&
aEntryReader
)
{
CommonProps
props
=
DeserializeCommonProps
(
aEntryReader
)
;
int
data
=
aEntryReader
.
ReadObject
<
int
>
(
)
;
return
UniquePtr
<
baseprofiler
:
:
ProfilerMarkerPayload
>
(
new
BaseTestMarkerPayload
(
std
:
:
move
(
props
)
data
)
)
;
}
BlocksRingBuffer
:
:
Length
BaseTestMarkerPayload
:
:
TagAndSerializationBytes
(
)
const
{
return
CommonPropsTagAndSerializationBytes
(
)
+
sizeof
(
int
)
;
}
void
BaseTestMarkerPayload
:
:
SerializeTagAndPayload
(
BlocksRingBuffer
:
:
EntryWriter
&
aEntryWriter
)
const
{
static
const
DeserializerTag
tag
=
TagForDeserializer
(
Deserialize
)
;
SerializeTagAndCommonProps
(
tag
aEntryWriter
)
;
aEntryWriter
.
WriteObject
(
mData
)
;
}
void
BaseTestMarkerPayload
:
:
StreamPayload
(
baseprofiler
:
:
SpliceableJSONWriter
&
aWriter
const
TimeStamp
&
aProcessStartTime
baseprofiler
:
:
UniqueStacks
&
aUniqueStacks
)
const
{
aWriter
.
IntProperty
(
"
data
"
mData
)
;
}
void
TestProfilerMarkerSerialization
(
)
{
printf
(
"
TestProfilerMarkerSerialization
.
.
.
\
n
"
)
;
constexpr
uint32_t
MBSize
=
256
;
uint8_t
buffer
[
MBSize
*
3
]
;
for
(
size_t
i
=
0
;
i
<
MBSize
*
3
;
+
+
i
)
{
buffer
[
i
]
=
uint8_t
(
'
A
'
+
i
)
;
}
BlocksRingBuffer
rb
(
BlocksRingBuffer
:
:
ThreadSafety
:
:
WithMutex
&
buffer
[
MBSize
]
MakePowerOfTwo32
<
MBSize
>
(
)
)
;
constexpr
int
data
=
42
;
{
BaseTestMarkerPayload
payload
(
data
)
;
rb
.
PutObject
(
static_cast
<
const
baseprofiler
:
:
ProfilerMarkerPayload
*
>
(
&
payload
)
)
;
}
int
read
=
0
;
rb
.
ReadEach
(
[
&
]
(
BlocksRingBuffer
:
:
EntryReader
&
aER
)
{
UniquePtr
<
baseprofiler
:
:
ProfilerMarkerPayload
>
payload
=
aER
.
ReadObject
<
UniquePtr
<
baseprofiler
:
:
ProfilerMarkerPayload
>
>
(
)
;
MOZ_RELEASE_ASSERT
(
!
!
payload
)
;
+
+
read
;
BaseTestMarkerPayload
*
testPayload
=
static_cast
<
BaseTestMarkerPayload
*
>
(
payload
.
get
(
)
)
;
MOZ_RELEASE_ASSERT
(
testPayload
)
;
MOZ_RELEASE_ASSERT
(
testPayload
-
>
GetData
(
)
=
=
data
)
;
}
)
;
MOZ_RELEASE_ASSERT
(
read
=
=
1
)
;
for
(
size_t
i
=
0
;
i
<
MBSize
;
+
+
i
)
{
MOZ_RELEASE_ASSERT
(
buffer
[
i
]
=
=
uint8_t
(
'
A
'
+
i
)
)
;
}
for
(
size_t
i
=
MBSize
*
2
;
i
<
MBSize
*
3
;
+
+
i
)
{
MOZ_RELEASE_ASSERT
(
buffer
[
i
]
=
=
uint8_t
(
'
A
'
+
i
)
)
;
}
printf
(
"
TestProfilerMarkerSerialization
done
\
n
"
)
;
}
static
constexpr
size_t
NextDepth
(
size_t
aDepth
)
{
constexpr
size_t
MAX_DEPTH
=
128
;
return
(
aDepth
<
MAX_DEPTH
)
?
(
aDepth
+
1
)
:
aDepth
;
}
Atomic
<
bool
Relaxed
recordreplay
:
:
Behavior
:
:
DontPreserve
>
sStopFibonacci
;
template
<
size_t
DEPTH
=
0
>
MOZ_NEVER_INLINE
unsigned
long
long
Fibonacci
(
unsigned
long
long
n
)
{
AUTO_BASE_PROFILER_LABEL_DYNAMIC_STRING
(
"
fib
"
OTHER
std
:
:
to_string
(
DEPTH
)
)
;
if
(
n
=
=
0
)
{
return
0
;
}
if
(
n
=
=
1
)
{
return
1
;
}
if
(
DEPTH
<
5
&
&
sStopFibonacci
)
{
return
1
'
000
'
000
'
000
;
}
TimeStamp
start
=
TimeStamp
:
:
NowUnfuzzed
(
)
;
static
constexpr
size_t
MAX_MARKER_DEPTH
=
10
;
unsigned
long
long
f2
=
Fibonacci
<
NextDepth
(
DEPTH
)
>
(
n
-
2
)
;
if
(
DEPTH
=
=
0
)
{
BASE_PROFILER_ADD_MARKER
(
"
Half
-
way
through
Fibonacci
"
OTHER
)
;
}
unsigned
long
long
f1
=
Fibonacci
<
NextDepth
(
DEPTH
)
>
(
n
-
1
)
;
if
(
DEPTH
<
MAX_MARKER_DEPTH
)
{
baseprofiler
:
:
profiler_add_text_marker
(
"
fib
"
std
:
:
to_string
(
DEPTH
)
baseprofiler
:
:
ProfilingCategoryPair
:
:
OTHER
start
TimeStamp
:
:
NowUnfuzzed
(
)
)
;
}
return
f2
+
f1
;
}
void
TestProfiler
(
)
{
printf
(
"
TestProfiler
starting
-
-
pid
:
%
d
tid
:
%
d
\
n
"
baseprofiler
:
:
profiler_current_process_id
(
)
baseprofiler
:
:
profiler_current_thread_id
(
)
)
;
TestPowerOfTwoMask
(
)
;
TestPowerOfTwo
(
)
;
TestLEB128
(
)
;
TestModuloBuffer
(
)
;
TestBlocksRingBufferAPI
(
)
;
TestBlocksRingBufferUnderlyingBufferChanges
(
)
;
TestBlocksRingBufferThreading
(
)
;
TestBlocksRingBufferSerialization
(
)
;
TestProfilerMarkerSerialization
(
)
;
{
printf
(
"
profiler_init
(
)
.
.
.
\
n
"
)
;
AUTO_BASE_PROFILER_INIT
;
MOZ_RELEASE_ASSERT
(
!
baseprofiler
:
:
profiler_is_active
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
baseprofiler
:
:
profiler_thread_is_being_profiled
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
baseprofiler
:
:
profiler_thread_is_sleeping
(
)
)
;
printf
(
"
profiler_start
(
)
.
.
.
\
n
"
)
;
Vector
<
const
char
*
>
filters
;
MOZ_RELEASE_ASSERT
(
filters
.
append
(
"
"
)
)
;
const
uint32_t
features
=
baseprofiler
:
:
ProfilerFeature
:
:
Leaf
|
baseprofiler
:
:
ProfilerFeature
:
:
StackWalk
|
baseprofiler
:
:
ProfilerFeature
:
:
Threads
;
baseprofiler
:
:
profiler_start
(
baseprofiler
:
:
BASE_PROFILER_DEFAULT_ENTRIES
BASE_PROFILER_DEFAULT_INTERVAL
features
filters
.
begin
(
)
filters
.
length
(
)
)
;
MOZ_RELEASE_ASSERT
(
baseprofiler
:
:
profiler_is_active
(
)
)
;
MOZ_RELEASE_ASSERT
(
baseprofiler
:
:
profiler_thread_is_being_profiled
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
baseprofiler
:
:
profiler_thread_is_sleeping
(
)
)
;
sStopFibonacci
=
false
;
std
:
:
thread
threadFib
(
[
]
(
)
{
AUTO_BASE_PROFILER_REGISTER_THREAD
(
"
fibonacci
"
)
;
SleepMilli
(
5
)
;
auto
cause
=
#
if
defined
(
__linux__
)
|
|
defined
(
__ANDROID__
)
decltype
(
baseprofiler
:
:
profiler_get_backtrace
(
)
)
{
}
;
#
else
baseprofiler
:
:
profiler_get_backtrace
(
)
;
#
endif
AUTO_BASE_PROFILER_TEXT_MARKER_CAUSE
(
"
fibonacci
"
"
First
leaf
call
"
OTHER
std
:
:
move
(
cause
)
)
;
static
const
unsigned
long
long
fibStart
=
37
;
printf
(
"
Fibonacci
(
%
llu
)
.
.
.
\
n
"
fibStart
)
;
AUTO_BASE_PROFILER_LABEL
(
"
Label
around
Fibonacci
"
OTHER
)
;
unsigned
long
long
f
=
Fibonacci
(
fibStart
)
;
printf
(
"
Fibonacci
(
%
llu
)
=
%
llu
\
n
"
fibStart
f
)
;
}
)
;
std
:
:
thread
threadCancelFib
(
[
]
(
)
{
AUTO_BASE_PROFILER_REGISTER_THREAD
(
"
fibonacci
canceller
"
)
;
SleepMilli
(
5
)
;
AUTO_BASE_PROFILER_TEXT_MARKER_CAUSE
(
"
fibonacci
"
"
Canceller
"
OTHER
nullptr
)
;
static
const
int
waitMaxSeconds
=
10
;
for
(
int
i
=
0
;
i
<
waitMaxSeconds
;
+
+
i
)
{
if
(
sStopFibonacci
)
{
AUTO_BASE_PROFILER_LABEL_DYNAMIC_STRING
(
"
fibCancel
"
OTHER
std
:
:
to_string
(
i
)
)
;
return
;
}
AUTO_BASE_PROFILER_THREAD_SLEEP
;
SleepMilli
(
1000
)
;
}
AUTO_BASE_PROFILER_LABEL_DYNAMIC_STRING
(
"
fibCancel
"
OTHER
"
Cancelling
!
"
)
;
sStopFibonacci
=
true
;
}
)
;
{
AUTO_BASE_PROFILER_TEXT_MARKER_CAUSE
(
"
main
thread
"
"
joining
fibonacci
thread
"
OTHER
nullptr
)
;
AUTO_BASE_PROFILER_THREAD_SLEEP
;
threadFib
.
join
(
)
;
}
{
AUTO_BASE_PROFILER_TEXT_MARKER_CAUSE
(
"
main
thread
"
"
joining
fibonacci
-
canceller
thread
"
OTHER
nullptr
)
;
sStopFibonacci
=
true
;
AUTO_BASE_PROFILER_THREAD_SLEEP
;
threadCancelFib
.
join
(
)
;
}
baseprofiler
:
:
profiler_add_marker
(
"
TracingMarkerPayload
"
baseprofiler
:
:
ProfilingCategoryPair
:
:
OTHER
baseprofiler
:
:
TracingMarkerPayload
(
"
category
"
baseprofiler
:
:
TRACING_EVENT
)
)
;
auto
cause
=
#
if
defined
(
__linux__
)
|
|
defined
(
__ANDROID__
)
decltype
(
baseprofiler
:
:
profiler_get_backtrace
(
)
)
{
}
;
#
else
baseprofiler
:
:
profiler_get_backtrace
(
)
;
#
endif
baseprofiler
:
:
profiler_add_marker
(
"
FileIOMarkerPayload
"
baseprofiler
:
:
ProfilingCategoryPair
:
:
OTHER
baseprofiler
:
:
FileIOMarkerPayload
(
"
operation
"
"
source
"
"
filename
"
TimeStamp
:
:
NowUnfuzzed
(
)
TimeStamp
:
:
NowUnfuzzed
(
)
std
:
:
move
(
cause
)
)
)
;
baseprofiler
:
:
profiler_add_marker
(
"
UserTimingMarkerPayload
"
baseprofiler
:
:
ProfilingCategoryPair
:
:
OTHER
baseprofiler
:
:
UserTimingMarkerPayload
(
"
name
"
TimeStamp
:
:
NowUnfuzzed
(
)
Nothing
{
}
)
)
;
baseprofiler
:
:
profiler_add_marker
(
"
HangMarkerPayload
"
baseprofiler
:
:
ProfilingCategoryPair
:
:
OTHER
baseprofiler
:
:
HangMarkerPayload
(
TimeStamp
:
:
NowUnfuzzed
(
)
TimeStamp
:
:
NowUnfuzzed
(
)
)
)
;
baseprofiler
:
:
profiler_add_marker
(
"
LongTaskMarkerPayload
"
baseprofiler
:
:
ProfilingCategoryPair
:
:
OTHER
baseprofiler
:
:
LongTaskMarkerPayload
(
TimeStamp
:
:
NowUnfuzzed
(
)
TimeStamp
:
:
NowUnfuzzed
(
)
)
)
;
{
std
:
:
string
s
=
"
text
payload
"
;
baseprofiler
:
:
profiler_add_marker
(
"
TextMarkerPayload
"
baseprofiler
:
:
ProfilingCategoryPair
:
:
OTHER
baseprofiler
:
:
TextMarkerPayload
(
s
TimeStamp
:
:
NowUnfuzzed
(
)
TimeStamp
:
:
NowUnfuzzed
(
)
)
)
;
}
baseprofiler
:
:
profiler_add_marker
(
"
LogMarkerPayload
"
baseprofiler
:
:
ProfilingCategoryPair
:
:
OTHER
baseprofiler
:
:
LogMarkerPayload
(
"
module
"
"
text
"
TimeStamp
:
:
NowUnfuzzed
(
)
)
)
;
printf
(
"
Sleep
1s
.
.
.
\
n
"
)
;
{
AUTO_BASE_PROFILER_THREAD_SLEEP
;
SleepMilli
(
1000
)
;
}
Maybe
<
baseprofiler
:
:
ProfilerBufferInfo
>
info
=
baseprofiler
:
:
profiler_get_buffer_info
(
)
;
MOZ_RELEASE_ASSERT
(
info
.
isSome
(
)
)
;
printf
(
"
Profiler
buffer
range
:
%
llu
.
.
%
llu
(
%
llu
bytes
)
\
n
"
static_cast
<
unsigned
long
long
>
(
info
-
>
mRangeStart
)
static_cast
<
unsigned
long
long
>
(
info
-
>
mRangeEnd
)
(
static_cast
<
unsigned
long
long
>
(
info
-
>
mRangeEnd
)
-
static_cast
<
unsigned
long
long
>
(
info
-
>
mRangeStart
)
)
*
9
)
;
printf
(
"
Stats
:
min
(
ns
)
.
.
mean
(
ns
)
.
.
max
(
ns
)
[
count
]
\
n
"
)
;
printf
(
"
-
Intervals
:
%
7
.
1f
.
.
%
7
.
1f
.
.
%
7
.
1f
[
%
u
]
\
n
"
info
-
>
mIntervalsNs
.
min
info
-
>
mIntervalsNs
.
sum
/
info
-
>
mIntervalsNs
.
n
info
-
>
mIntervalsNs
.
max
info
-
>
mIntervalsNs
.
n
)
;
printf
(
"
-
Overheads
:
%
7
.
1f
.
.
%
7
.
1f
.
.
%
7
.
1f
[
%
u
]
\
n
"
info
-
>
mOverheadsNs
.
min
info
-
>
mOverheadsNs
.
sum
/
info
-
>
mOverheadsNs
.
n
info
-
>
mOverheadsNs
.
max
info
-
>
mOverheadsNs
.
n
)
;
printf
(
"
-
Locking
:
%
7
.
1f
.
.
%
7
.
1f
.
.
%
7
.
1f
[
%
u
]
\
n
"
info
-
>
mLockingsNs
.
min
info
-
>
mLockingsNs
.
sum
/
info
-
>
mLockingsNs
.
n
info
-
>
mLockingsNs
.
max
info
-
>
mLockingsNs
.
n
)
;
printf
(
"
-
Clearning
:
%
7
.
1f
.
.
%
7
.
1f
.
.
%
7
.
1f
[
%
u
]
\
n
"
info
-
>
mCleaningsNs
.
min
info
-
>
mCleaningsNs
.
sum
/
info
-
>
mCleaningsNs
.
n
info
-
>
mCleaningsNs
.
max
info
-
>
mCleaningsNs
.
n
)
;
printf
(
"
-
Counters
:
%
7
.
1f
.
.
%
7
.
1f
.
.
%
7
.
1f
[
%
u
]
\
n
"
info
-
>
mCountersNs
.
min
info
-
>
mCountersNs
.
sum
/
info
-
>
mCountersNs
.
n
info
-
>
mCountersNs
.
max
info
-
>
mCountersNs
.
n
)
;
printf
(
"
-
Threads
:
%
7
.
1f
.
.
%
7
.
1f
.
.
%
7
.
1f
[
%
u
]
\
n
"
info
-
>
mThreadsNs
.
min
info
-
>
mThreadsNs
.
sum
/
info
-
>
mThreadsNs
.
n
info
-
>
mThreadsNs
.
max
info
-
>
mThreadsNs
.
n
)
;
printf
(
"
baseprofiler_save_profile_to_file
(
)
.
.
.
\
n
"
)
;
baseprofiler
:
:
profiler_save_profile_to_file
(
"
TestProfiler_profile
.
json
"
)
;
printf
(
"
profiler_stop
(
)
.
.
.
\
n
"
)
;
baseprofiler
:
:
profiler_stop
(
)
;
MOZ_RELEASE_ASSERT
(
!
baseprofiler
:
:
profiler_is_active
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
baseprofiler
:
:
profiler_thread_is_being_profiled
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
baseprofiler
:
:
profiler_thread_is_sleeping
(
)
)
;
printf
(
"
profiler_shutdown
(
)
.
.
.
\
n
"
)
;
}
printf
(
"
TestProfiler
done
\
n
"
)
;
}
#
else
void
TestProfiler
(
)
{
AUTO_BASE_PROFILER_INIT
;
AUTO_BASE_PROFILER_TEXT_MARKER_CAUSE
(
catch
catch
catch
catch
)
;
AUTO_BASE_PROFILER_LABEL
(
catch
catch
)
;
AUTO_BASE_PROFILER_THREAD_SLEEP
;
}
#
endif
int
main
(
)
{
TestProfiler
(
)
;
return
0
;
}
