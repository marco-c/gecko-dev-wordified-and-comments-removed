#
include
"
mozilla
/
StackWalk
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
<
algorithm
>
#
include
"
gtest
/
gtest
.
h
"
MOZ_EXPORT
bool
gStackWalkTesterDummy
=
true
;
struct
StackWalkTester
;
struct
CallInfo
{
int
(
*
mFunc
)
(
int
aDepth
int
aLastSkipped
int
aIgnored
StackWalkTester
&
aTester
)
;
bool
mTailCall
;
bool
TailCall
(
)
{
#
if
defined
(
__i386__
)
|
|
defined
(
MOZ_CODE_COVERAGE
)
return
false
;
#
else
return
mTailCall
;
#
endif
}
}
;
struct
PCRange
{
void
*
mStart
;
void
*
mEnd
;
}
;
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
aStream
const
PCRange
&
aRange
)
{
aStream
<
<
aRange
.
mStart
;
aStream
<
<
"
-
"
;
aStream
<
<
aRange
.
mEnd
;
return
aStream
;
}
bool
operator
=
=
(
const
std
:
:
vector
<
PCRange
>
&
aRanges
const
std
:
:
vector
<
void
*
>
&
aPtrs
)
{
if
(
aRanges
.
size
(
)
!
=
aPtrs
.
size
(
)
)
{
return
false
;
}
for
(
size_t
i
=
0
;
i
<
aRanges
.
size
(
)
;
i
+
+
)
{
auto
range
=
aRanges
[
i
]
;
auto
ptr
=
reinterpret_cast
<
uintptr_t
>
(
aPtrs
[
i
]
)
;
if
(
ptr
<
=
reinterpret_cast
<
uintptr_t
>
(
range
.
mStart
)
|
|
ptr
>
=
reinterpret_cast
<
uintptr_t
>
(
range
.
mEnd
)
)
{
return
false
;
}
}
return
true
;
}
struct
StackWalkTester
{
std
:
:
vector
<
CallInfo
>
mFuncCalls
;
std
:
:
vector
<
void
*
>
mFramePCs
;
std
:
:
vector
<
PCRange
>
mExpectedFramePCs
;
void
*
mFirstFramePC
=
nullptr
;
static
void
StackWalkCallback
(
uint32_t
aFrameNumber
void
*
aPC
void
*
aSP
void
*
aClosure
)
{
ASSERT_NE
(
aClosure
nullptr
)
;
StackWalkTester
&
tester
=
*
reinterpret_cast
<
StackWalkTester
*
>
(
aClosure
)
;
tester
.
mFramePCs
.
push_back
(
aPC
)
;
EXPECT_EQ
(
tester
.
mFramePCs
.
size
(
)
size_t
(
aFrameNumber
)
)
<
<
"
Frame
number
doesn
'
t
match
"
;
}
MOZ_NEVER_INLINE
void
AddExpectedPC
(
void
*
aPC
)
{
mExpectedFramePCs
.
push_back
(
{
aPC
CallerPC
(
)
}
)
;
}
template
<
int
Id
>
MOZ_NEVER_INLINE
MOZ_EXPORT
static
int
IntermediateCallback
(
int
aDepth
int
aLastSkipped
int
aIgnored
StackWalkTester
&
aTester
)
{
auto
&
callInfo
=
aTester
.
mFuncCalls
.
at
(
aDepth
+
1
)
;
if
(
aDepth
=
=
aLastSkipped
)
{
aTester
.
mFirstFramePC
=
CallerPC
(
)
;
}
if
(
aTester
.
mFuncCalls
.
at
(
aDepth
)
.
TailCall
(
)
)
{
return
callInfo
.
mFunc
(
aDepth
+
1
aLastSkipped
Id
aTester
)
;
}
here
:
callInfo
.
mFunc
(
aDepth
+
1
aLastSkipped
Id
+
1
aTester
)
;
aTester
.
AddExpectedPC
(
&
&
here
)
;
return
0
;
}
MOZ_NEVER_INLINE
MOZ_EXPORT
static
void
LeafCallback
(
int
aDepth
int
aLastSkipped
int
aIgnored
StackWalkTester
&
aTester
)
{
if
(
aDepth
=
=
aLastSkipped
)
{
aTester
.
mFirstFramePC
=
CallerPC
(
)
;
}
if
(
aTester
.
mFuncCalls
.
at
(
aDepth
)
.
TailCall
(
)
)
{
return
MozStackWalk
(
StackWalkTester
:
:
StackWalkCallback
aTester
.
mFirstFramePC
19
&
aTester
)
;
}
here
:
MozStackWalk
(
StackWalkTester
:
:
StackWalkCallback
aTester
.
mFirstFramePC
20
&
aTester
)
;
aTester
.
AddExpectedPC
(
&
&
here
)
;
MOZ_RELEASE_ASSERT
(
gStackWalkTesterDummy
)
;
}
explicit
StackWalkTester
(
std
:
:
initializer_list
<
CallInfo
>
aFuncCalls
)
:
mFuncCalls
(
aFuncCalls
)
{
}
static
std
:
:
string
DumpFrames
(
std
:
:
vector
<
PCRange
>
&
aFramePCRanges
)
{
std
:
:
vector
<
void
*
>
framePCs
;
framePCs
.
reserve
(
aFramePCRanges
.
size
(
)
)
;
for
(
auto
range
:
aFramePCRanges
)
{
framePCs
.
push_back
(
range
.
mEnd
)
;
}
return
DumpFrames
(
framePCs
)
;
}
static
std
:
:
string
DumpFrames
(
std
:
:
vector
<
void
*
>
&
aFramePCs
)
{
size_t
n
=
0
;
std
:
:
string
result
;
for
(
auto
*
framePC
:
aFramePCs
)
{
char
buf
[
1024
]
;
MozCodeAddressDetails
details
;
result
.
append
(
"
"
)
;
n
+
+
;
if
(
MozDescribeCodeAddress
(
framePC
&
details
)
)
{
int
length
=
MozFormatCodeAddressDetails
(
buf
sizeof
(
buf
)
n
framePC
&
details
)
;
result
.
append
(
buf
std
:
:
min
(
length
(
int
)
sizeof
(
buf
)
-
1
)
)
;
}
else
{
result
.
append
(
"
MozDescribeCodeAddress
failed
"
)
;
}
result
.
append
(
"
\
n
"
)
;
}
return
result
;
}
static
std
:
:
string
DumpFuncCalls
(
std
:
:
vector
<
CallInfo
>
&
aFuncCalls
)
{
std
:
:
string
result
;
for
(
auto
funcCall
:
aFuncCalls
)
{
MozCodeAddressDetails
details
;
result
.
append
(
"
"
)
;
if
(
MozDescribeCodeAddress
(
reinterpret_cast
<
void
*
>
(
funcCall
.
mFunc
)
&
details
)
)
{
result
.
append
(
details
.
function
)
;
if
(
funcCall
.
TailCall
(
)
)
{
result
.
append
(
"
tail
call
"
)
;
}
}
else
{
result
.
append
(
"
MozDescribeCodeAddress
failed
"
)
;
}
result
.
append
(
"
\
n
"
)
;
}
return
result
;
}
MOZ_EXPORT
MOZ_NEVER_INLINE
void
RunTest
(
int
aLastSkipped
)
{
ASSERT_TRUE
(
aLastSkipped
<
(
int
)
mFuncCalls
.
size
(
)
)
;
mFramePCs
.
clear
(
)
;
mExpectedFramePCs
.
clear
(
)
;
mFirstFramePC
=
nullptr
;
auto
&
callInfo
=
mFuncCalls
.
at
(
0
)
;
here
:
callInfo
.
mFunc
(
0
aLastSkipped
0
*
this
)
;
AddExpectedPC
(
&
&
here
)
;
if
(
aLastSkipped
<
0
)
{
aLastSkipped
=
mFuncCalls
.
size
(
)
;
}
for
(
int
i
=
(
int
)
mFuncCalls
.
size
(
)
-
1
;
i
>
=
aLastSkipped
;
i
-
-
)
{
if
(
!
mFuncCalls
.
at
(
i
)
.
TailCall
(
)
)
{
mExpectedFramePCs
.
erase
(
mExpectedFramePCs
.
begin
(
)
)
;
}
}
mFramePCs
.
resize
(
std
:
:
min
(
mExpectedFramePCs
.
size
(
)
mFramePCs
.
size
(
)
)
)
;
EXPECT_EQ
(
mExpectedFramePCs
mFramePCs
)
<
<
"
Expected
frames
:
\
n
"
<
<
DumpFrames
(
mExpectedFramePCs
)
<
<
"
Found
frames
:
\
n
"
<
<
DumpFrames
(
mFramePCs
)
<
<
"
Function
calls
data
(
last
skipped
:
"
<
<
aLastSkipped
<
<
"
)
:
\
n
"
<
<
DumpFuncCalls
(
mFuncCalls
)
;
}
}
;
TEST
(
TestStackWalk
StackWalk
)
{
const
auto
foo
=
StackWalkTester
:
:
IntermediateCallback
<
1
>
;
const
auto
bar
=
StackWalkTester
:
:
IntermediateCallback
<
2
>
;
const
auto
qux
=
StackWalkTester
:
:
IntermediateCallback
<
3
>
;
const
auto
leaf
=
reinterpret_cast
<
int
(
*
)
(
int
int
int
StackWalkTester
&
)
>
(
StackWalkTester
:
:
LeafCallback
)
;
const
std
:
:
initializer_list
<
CallInfo
>
tests
[
]
=
{
{
{
foo
false
}
{
bar
false
}
{
qux
false
}
{
leaf
false
}
}
{
{
foo
false
}
{
bar
true
}
{
qux
false
}
{
leaf
false
}
}
{
{
foo
false
}
{
bar
false
}
{
qux
false
}
{
leaf
true
}
}
{
{
foo
true
}
{
bar
false
}
{
qux
true
}
{
leaf
true
}
}
}
;
for
(
auto
test
:
tests
)
{
StackWalkTester
tester
(
test
)
;
for
(
int
i
=
-
1
;
i
<
(
int
)
test
.
size
(
)
;
i
+
+
)
{
tester
.
RunTest
(
i
)
;
}
}
}
