#
include
<
windows
.
h
>
#
include
<
winternl
.
h
>
#
pragma
warning
(
push
)
#
pragma
warning
(
disable
:
4275
4530
)
/
/
See
msvc
-
stl
-
wrapper
.
template
.
h
#
include
<
map
>
#
pragma
warning
(
pop
)
#
include
"
Authenticode
.
h
"
#
include
"
BaseProfiler
.
h
"
#
include
"
CrashAnnotations
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsWindowsDllInterceptor
.
h
"
#
include
"
mozilla
/
CmdLineAndEnvUtils
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
StackWalk_windows
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
mozilla
/
WindowsVersion
.
h
"
#
include
"
mozilla
/
WinHeaderOnlyUtils
.
h
"
#
include
"
nsWindowsHelpers
.
h
"
#
include
"
WindowsDllBlocklist
.
h
"
#
include
"
mozilla
/
AutoProfilerLabel
.
h
"
#
include
"
mozilla
/
glue
/
Debug
.
h
"
#
include
"
mozilla
/
glue
/
WindowsDllServices
.
h
"
#
include
"
mozilla
/
glue
/
WinUtils
.
h
"
#
include
"
LoaderObserver
.
h
"
#
include
"
ModuleLoadFrame
.
h
"
#
include
"
mozilla
/
glue
/
WindowsUnicode
.
h
"
namespace
mozilla
{
glue
:
:
Win32SRWLock
gDllServicesLock
;
glue
:
:
detail
:
:
DllServicesBase
*
gDllServices
;
}
using
namespace
mozilla
;
using
CrashReporter
:
:
Annotation
;
using
CrashReporter
:
:
AnnotationToString
;
#
define
DLL_BLOCKLIST_ENTRY
(
name
.
.
.
)
{
name
__VA_ARGS__
}
#
define
DLL_BLOCKLIST_STRING_TYPE
const
char
*
#
include
"
mozilla
/
WindowsDllBlocklistLegacyDefs
.
h
"
#
undef
DEBUG_very_verbose
static
uint32_t
sInitFlags
;
static
bool
sBlocklistInitAttempted
;
static
bool
sBlocklistInitFailed
;
static
bool
sUser32BeforeBlocklist
;
typedef
MOZ_NORETURN_PTR
void
(
__fastcall
*
BaseThreadInitThunk_func
)
(
BOOL
aIsInitialThread
void
*
aStartAddress
void
*
aThreadParam
)
;
static
WindowsDllInterceptor
:
:
FuncHookType
<
BaseThreadInitThunk_func
>
stub_BaseThreadInitThunk
;
typedef
NTSTATUS
(
NTAPI
*
LdrLoadDll_func
)
(
PWCHAR
filePath
PULONG
flags
PUNICODE_STRING
moduleFileName
PHANDLE
handle
)
;
static
WindowsDllInterceptor
:
:
FuncHookType
<
LdrLoadDll_func
>
stub_LdrLoadDll
;
#
ifdef
_M_AMD64
typedef
decltype
(
RtlInstallFunctionTableCallback
)
*
RtlInstallFunctionTableCallback_func
;
static
WindowsDllInterceptor
:
:
FuncHookType
<
RtlInstallFunctionTableCallback_func
>
stub_RtlInstallFunctionTableCallback
;
extern
uint8_t
*
sMsMpegJitCodeRegionStart
;
extern
size_t
sMsMpegJitCodeRegionSize
;
BOOLEAN
WINAPI
patched_RtlInstallFunctionTableCallback
(
DWORD64
TableIdentifier
DWORD64
BaseAddress
DWORD
Length
PGET_RUNTIME_FUNCTION_CALLBACK
Callback
PVOID
Context
PCWSTR
OutOfProcessCallbackDll
)
{
HMODULE
callbackModule
=
nullptr
;
DWORD
moduleFlags
=
GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS
|
GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT
;
AutoSuppressStackWalking
suppress
;
if
(
GetModuleHandleExW
(
moduleFlags
(
LPWSTR
)
Callback
&
callbackModule
)
&
&
GetModuleHandleW
(
L
"
msmpeg2vdec
.
dll
"
)
=
=
callbackModule
)
{
sMsMpegJitCodeRegionStart
=
(
uint8_t
*
)
BaseAddress
;
sMsMpegJitCodeRegionSize
=
Length
;
}
return
stub_RtlInstallFunctionTableCallback
(
TableIdentifier
BaseAddress
Length
Callback
Context
OutOfProcessCallbackDll
)
;
}
#
endif
template
<
class
T
>
struct
RVAMap
{
RVAMap
(
HANDLE
map
DWORD
offset
)
{
SYSTEM_INFO
info
;
GetSystemInfo
(
&
info
)
;
DWORD
alignedOffset
=
(
offset
/
info
.
dwAllocationGranularity
)
*
info
.
dwAllocationGranularity
;
MOZ_ASSERT
(
offset
-
alignedOffset
<
info
.
dwAllocationGranularity
"
Wtf
"
)
;
mRealView
=
:
:
MapViewOfFile
(
map
FILE_MAP_READ
0
alignedOffset
sizeof
(
T
)
+
(
offset
-
alignedOffset
)
)
;
mMappedView
=
mRealView
?
reinterpret_cast
<
T
*
>
(
(
char
*
)
mRealView
+
(
offset
-
alignedOffset
)
)
:
nullptr
;
}
~
RVAMap
(
)
{
if
(
mRealView
)
{
:
:
UnmapViewOfFile
(
mRealView
)
;
}
}
operator
const
T
*
(
)
const
{
return
mMappedView
;
}
const
T
*
operator
-
>
(
)
const
{
return
mMappedView
;
}
private
:
const
T
*
mMappedView
;
void
*
mRealView
;
}
;
static
DWORD
GetTimestamp
(
const
wchar_t
*
path
)
{
DWORD
timestamp
=
0
;
HANDLE
file
=
:
:
CreateFileW
(
path
GENERIC_READ
FILE_SHARE_READ
nullptr
OPEN_EXISTING
FILE_ATTRIBUTE_NORMAL
nullptr
)
;
if
(
file
!
=
INVALID_HANDLE_VALUE
)
{
HANDLE
map
=
:
:
CreateFileMappingW
(
file
nullptr
PAGE_READONLY
0
0
nullptr
)
;
if
(
map
)
{
RVAMap
<
IMAGE_DOS_HEADER
>
peHeader
(
map
0
)
;
if
(
peHeader
)
{
RVAMap
<
IMAGE_NT_HEADERS
>
ntHeader
(
map
peHeader
-
>
e_lfanew
)
;
if
(
ntHeader
)
{
timestamp
=
ntHeader
-
>
FileHeader
.
TimeDateStamp
;
}
}
:
:
CloseHandle
(
map
)
;
}
:
:
CloseHandle
(
file
)
;
}
return
timestamp
;
}
static
CRITICAL_SECTION
sLock
;
class
ReentrancySentinel
{
public
:
explicit
ReentrancySentinel
(
const
char
*
dllName
)
{
DWORD
currentThreadId
=
GetCurrentThreadId
(
)
;
AutoCriticalSection
lock
(
&
sLock
)
;
mPreviousDllName
=
(
*
sThreadMap
)
[
currentThreadId
]
;
mReentered
=
mPreviousDllName
&
&
!
stricmp
(
mPreviousDllName
dllName
)
;
(
*
sThreadMap
)
[
currentThreadId
]
=
dllName
;
}
~
ReentrancySentinel
(
)
{
DWORD
currentThreadId
=
GetCurrentThreadId
(
)
;
AutoCriticalSection
lock
(
&
sLock
)
;
(
*
sThreadMap
)
[
currentThreadId
]
=
mPreviousDllName
;
}
bool
BailOut
(
)
const
{
return
mReentered
;
}
;
static
void
InitializeStatics
(
)
{
InitializeCriticalSection
(
&
sLock
)
;
sThreadMap
=
new
std
:
:
map
<
DWORD
const
char
*
>
;
}
private
:
static
std
:
:
map
<
DWORD
const
char
*
>
*
sThreadMap
;
const
char
*
mPreviousDllName
;
bool
mReentered
;
}
;
std
:
:
map
<
DWORD
const
char
*
>
*
ReentrancySentinel
:
:
sThreadMap
;
class
DllBlockSet
{
public
:
static
void
Add
(
const
char
*
name
unsigned
long
long
version
)
;
static
void
Write
(
HANDLE
file
)
;
private
:
DllBlockSet
(
const
char
*
name
unsigned
long
long
version
)
:
mName
(
name
)
mVersion
(
version
)
mNext
(
nullptr
)
{
}
const
char
*
mName
;
unsigned
long
long
mVersion
;
DllBlockSet
*
mNext
;
static
DllBlockSet
*
gFirst
;
}
;
DllBlockSet
*
DllBlockSet
:
:
gFirst
;
void
DllBlockSet
:
:
Add
(
const
char
*
name
unsigned
long
long
version
)
{
AutoCriticalSection
lock
(
&
sLock
)
;
for
(
DllBlockSet
*
b
=
gFirst
;
b
;
b
=
b
-
>
mNext
)
{
if
(
0
=
=
strcmp
(
b
-
>
mName
name
)
&
&
b
-
>
mVersion
=
=
version
)
{
return
;
}
}
DllBlockSet
*
n
=
new
DllBlockSet
(
name
version
)
;
n
-
>
mNext
=
gFirst
;
gFirst
=
n
;
}
void
DllBlockSet
:
:
Write
(
HANDLE
file
)
{
:
:
EnterCriticalSection
(
&
sLock
)
;
MOZ_SEH_TRY
{
DWORD
nBytes
;
for
(
DllBlockSet
*
b
=
gFirst
;
b
;
b
=
b
-
>
mNext
)
{
WriteFile
(
file
b
-
>
mName
strlen
(
b
-
>
mName
)
&
nBytes
nullptr
)
;
if
(
b
-
>
mVersion
!
=
DllBlockInfo
:
:
ALL_VERSIONS
)
{
WriteFile
(
file
"
"
1
&
nBytes
nullptr
)
;
uint16_t
parts
[
4
]
;
parts
[
0
]
=
b
-
>
mVersion
>
>
48
;
parts
[
1
]
=
(
b
-
>
mVersion
>
>
32
)
&
0xFFFF
;
parts
[
2
]
=
(
b
-
>
mVersion
>
>
16
)
&
0xFFFF
;
parts
[
3
]
=
b
-
>
mVersion
&
0xFFFF
;
for
(
int
p
=
0
;
p
<
4
;
+
+
p
)
{
char
buf
[
32
]
;
ltoa
(
parts
[
p
]
buf
10
)
;
WriteFile
(
file
buf
strlen
(
buf
)
&
nBytes
nullptr
)
;
if
(
p
!
=
3
)
{
WriteFile
(
file
"
.
"
1
&
nBytes
nullptr
)
;
}
}
}
WriteFile
(
file
"
;
"
1
&
nBytes
nullptr
)
;
}
}
MOZ_SEH_EXCEPT
(
EXCEPTION_EXECUTE_HANDLER
)
{
}
:
:
LeaveCriticalSection
(
&
sLock
)
;
}
static
UniquePtr
<
wchar_t
[
]
>
getFullPath
(
PWCHAR
filePath
wchar_t
*
fname
)
{
PWCHAR
sanitizedFilePath
=
nullptr
;
if
(
(
uintptr_t
(
filePath
)
>
=
65536
)
&
&
(
(
uintptr_t
(
filePath
)
&
1
)
=
=
0
)
)
{
sanitizedFilePath
=
filePath
;
}
DWORD
pathlen
=
SearchPathW
(
sanitizedFilePath
fname
L
"
.
dll
"
0
nullptr
nullptr
)
;
if
(
pathlen
=
=
0
)
{
return
nullptr
;
}
auto
full_fname
=
MakeUnique
<
wchar_t
[
]
>
(
pathlen
+
1
)
;
if
(
!
full_fname
)
{
return
nullptr
;
}
SearchPathW
(
sanitizedFilePath
fname
L
"
.
dll
"
pathlen
+
1
full_fname
.
get
(
)
nullptr
)
;
return
full_fname
;
}
static
wchar_t
*
lastslash
(
wchar_t
*
s
int
len
)
{
for
(
wchar_t
*
c
=
s
+
len
-
1
;
c
>
=
s
;
-
-
c
)
{
if
(
*
c
=
=
L
'
\
\
'
|
|
*
c
=
=
L
'
/
'
)
{
return
c
;
}
}
return
nullptr
;
}
static
NTSTATUS
NTAPI
patched_LdrLoadDll
(
PWCHAR
filePath
PULONG
flags
PUNICODE_STRING
moduleFileName
PHANDLE
handle
)
{
#
define
DLLNAME_MAX
128
char
dllName
[
DLLNAME_MAX
+
1
]
;
wchar_t
*
dll_part
;
char
*
dot
;
int
len
=
moduleFileName
-
>
Length
/
2
;
wchar_t
*
fname
=
moduleFileName
-
>
Buffer
;
UniquePtr
<
wchar_t
[
]
>
full_fname
;
if
(
moduleFileName
-
>
MaximumLength
<
moduleFileName
-
>
Length
+
2
|
|
fname
[
len
]
!
=
0
)
{
#
ifdef
DEBUG
printf_stderr
(
"
LdrLoadDll
:
non
-
null
terminated
string
found
!
\
n
"
)
;
#
endif
goto
continue_loading
;
}
dll_part
=
lastslash
(
fname
len
)
;
if
(
dll_part
)
{
dll_part
=
dll_part
+
1
;
len
-
=
dll_part
-
fname
;
}
else
{
dll_part
=
fname
;
}
#
ifdef
DEBUG_very_verbose
printf_stderr
(
"
LdrLoadDll
:
dll_part
'
%
S
'
%
d
\
n
"
dll_part
len
)
;
#
endif
if
(
len
>
DLLNAME_MAX
)
{
#
ifdef
DEBUG
printf_stderr
(
"
LdrLoadDll
:
len
too
long
!
%
d
\
n
"
len
)
;
#
endif
goto
continue_loading
;
}
for
(
int
i
=
0
;
i
<
len
;
i
+
+
)
{
wchar_t
c
=
dll_part
[
i
]
;
if
(
c
>
0x7f
)
{
goto
continue_loading
;
}
if
(
c
>
=
'
A
'
&
&
c
<
=
'
Z
'
)
c
+
=
'
a
'
-
'
A
'
;
dllName
[
i
]
=
(
char
)
c
;
}
dllName
[
len
]
=
0
;
#
ifdef
DEBUG_very_verbose
printf_stderr
(
"
LdrLoadDll
:
dll
name
'
%
s
'
\
n
"
dllName
)
;
#
endif
if
(
!
(
sInitFlags
&
eDllBlocklistInitFlagWasBootstrapped
)
)
{
dot
=
strchr
(
dllName
'
.
'
)
;
if
(
dot
&
&
(
strchr
(
dot
+
1
'
.
'
)
=
=
dot
+
13
)
)
{
char
*
end
=
nullptr
;
_strtoui64
(
dot
+
1
&
end
16
)
;
if
(
end
=
=
dot
+
13
)
{
return
STATUS_DLL_NOT_FOUND
;
}
}
if
(
dot
&
&
(
(
dot
-
dllName
)
>
=
16
)
)
{
char
*
current
=
dllName
;
while
(
current
<
dot
&
&
isxdigit
(
*
current
)
)
{
current
+
+
;
}
if
(
current
=
=
dot
)
{
return
STATUS_DLL_NOT_FOUND
;
}
}
DECLARE_POINTER_TO_FIRST_DLL_BLOCKLIST_ENTRY
(
info
)
;
while
(
info
-
>
mName
)
{
if
(
strcmp
(
info
-
>
mName
dllName
)
=
=
0
)
break
;
info
+
+
;
}
if
(
info
-
>
mName
)
{
bool
load_ok
=
false
;
#
ifdef
DEBUG_very_verbose
printf_stderr
(
"
LdrLoadDll
:
info
-
>
mName
:
'
%
s
'
\
n
"
info
-
>
mName
)
;
#
endif
if
(
(
info
-
>
mFlags
&
DllBlockInfo
:
:
BLOCK_WIN8PLUS_ONLY
)
&
&
!
IsWin8OrLater
(
)
)
{
goto
continue_loading
;
}
if
(
(
info
-
>
mFlags
&
DllBlockInfo
:
:
BLOCK_WIN8_ONLY
)
&
&
(
!
IsWin8OrLater
(
)
|
|
IsWin8Point1OrLater
(
)
)
)
{
goto
continue_loading
;
}
if
(
(
info
-
>
mFlags
&
DllBlockInfo
:
:
CHILD_PROCESSES_ONLY
)
&
&
!
(
sInitFlags
&
eDllBlocklistInitFlagIsChildProcess
)
)
{
goto
continue_loading
;
}
unsigned
long
long
fVersion
=
DllBlockInfo
:
:
ALL_VERSIONS
;
if
(
info
-
>
mMaxVersion
!
=
DllBlockInfo
:
:
ALL_VERSIONS
)
{
ReentrancySentinel
sentinel
(
dllName
)
;
if
(
sentinel
.
BailOut
(
)
)
{
goto
continue_loading
;
}
full_fname
=
getFullPath
(
filePath
fname
)
;
if
(
!
full_fname
)
{
printf_stderr
(
"
LdrLoadDll
:
Blocking
load
of
'
%
s
'
(
SearchPathW
didn
'
t
find
"
"
it
?
)
\
n
"
dllName
)
;
return
STATUS_DLL_NOT_FOUND
;
}
if
(
info
-
>
mFlags
&
DllBlockInfo
:
:
USE_TIMESTAMP
)
{
fVersion
=
GetTimestamp
(
full_fname
.
get
(
)
)
;
if
(
fVersion
>
info
-
>
mMaxVersion
)
{
load_ok
=
true
;
}
}
else
{
LauncherResult
<
ModuleVersion
>
version
=
GetModuleVersion
(
full_fname
.
get
(
)
)
;
if
(
version
.
isOk
(
)
)
{
load_ok
=
!
info
-
>
IsVersionBlocked
(
version
.
unwrap
(
)
)
;
}
}
}
if
(
!
load_ok
)
{
printf_stderr
(
"
LdrLoadDll
:
Blocking
load
of
'
%
s
'
-
-
see
"
"
http
:
/
/
www
.
mozilla
.
com
/
en
-
US
/
blocklist
/
\
n
"
dllName
)
;
DllBlockSet
:
:
Add
(
info
-
>
mName
fVersion
)
;
return
STATUS_DLL_NOT_FOUND
;
}
}
}
continue_loading
:
#
ifdef
DEBUG_very_verbose
printf_stderr
(
"
LdrLoadDll
:
continuing
load
.
.
.
(
'
%
S
'
)
\
n
"
moduleFileName
-
>
Buffer
)
;
#
endif
glue
:
:
ModuleLoadFrame
loadFrame
(
moduleFileName
)
;
NTSTATUS
ret
;
HANDLE
myHandle
;
ret
=
stub_LdrLoadDll
(
filePath
flags
moduleFileName
&
myHandle
)
;
if
(
handle
)
{
*
handle
=
myHandle
;
}
loadFrame
.
SetLoadStatus
(
ret
myHandle
)
;
return
ret
;
}
#
if
defined
(
NIGHTLY_BUILD
)
static
void
*
gStartAddressesToBlock
[
4
]
;
#
endif
static
bool
ShouldBlockThread
(
void
*
aStartAddress
)
{
if
(
aStartAddress
=
=
nullptr
)
return
false
;
#
if
defined
(
NIGHTLY_BUILD
)
for
(
auto
p
:
gStartAddressesToBlock
)
{
if
(
p
=
=
aStartAddress
)
{
return
true
;
}
}
#
endif
bool
shouldBlock
=
false
;
MEMORY_BASIC_INFORMATION
startAddressInfo
=
{
0
}
;
if
(
VirtualQuery
(
aStartAddress
&
startAddressInfo
sizeof
(
startAddressInfo
)
)
)
{
shouldBlock
|
=
startAddressInfo
.
State
!
=
MEM_COMMIT
;
shouldBlock
|
=
startAddressInfo
.
Protect
!
=
PAGE_EXECUTE_READ
;
}
return
shouldBlock
;
}
static
DWORD
WINAPI
NopThreadProc
(
void
*
)
{
return
0
;
}
static
MOZ_NORETURN
void
__fastcall
patched_BaseThreadInitThunk
(
BOOL
aIsInitialThread
void
*
aStartAddress
void
*
aThreadParam
)
{
if
(
ShouldBlockThread
(
aStartAddress
)
)
{
aStartAddress
=
(
void
*
)
NopThreadProc
;
}
stub_BaseThreadInitThunk
(
aIsInitialThread
aStartAddress
aThreadParam
)
;
}
static
WindowsDllInterceptor
NtDllIntercept
;
static
WindowsDllInterceptor
Kernel32Intercept
;
static
void
GetNativeNtBlockSetWriter
(
)
;
static
glue
:
:
LoaderObserver
gMozglueLoaderObserver
;
MFBT_API
void
DllBlocklist_Initialize
(
uint32_t
aInitFlags
)
{
if
(
sBlocklistInitAttempted
)
{
return
;
}
sBlocklistInitAttempted
=
true
;
sInitFlags
=
aInitFlags
;
glue
:
:
ModuleLoadFrame
:
:
StaticInit
(
&
gMozglueLoaderObserver
)
;
#
ifdef
_M_AMD64
if
(
!
IsWin8OrLater
(
)
)
{
Kernel32Intercept
.
Init
(
"
kernel32
.
dll
"
)
;
stub_RtlInstallFunctionTableCallback
.
Set
(
Kernel32Intercept
"
RtlInstallFunctionTableCallback
"
&
patched_RtlInstallFunctionTableCallback
)
;
}
#
endif
if
(
aInitFlags
&
eDllBlocklistInitFlagWasBootstrapped
)
{
GetNativeNtBlockSetWriter
(
)
;
return
;
}
const
bool
skipUser32Check
=
(
sInitFlags
&
eDllBlocklistInitFlagWasBootstrapped
)
#
ifdef
MOZ_BASE_PROFILER
|
|
(
!
IsWin10AnniversaryUpdateOrLater
(
)
&
&
baseprofiler
:
:
profiler_is_active
(
)
)
#
endif
;
if
(
!
skipUser32Check
&
&
GetModuleHandleW
(
L
"
user32
.
dll
"
)
)
{
sUser32BeforeBlocklist
=
true
;
#
ifdef
DEBUG
printf_stderr
(
"
DLL
blocklist
was
unable
to
intercept
AppInit
DLLs
.
\
n
"
)
;
#
endif
}
NtDllIntercept
.
Init
(
"
ntdll
.
dll
"
)
;
ReentrancySentinel
:
:
InitializeStatics
(
)
;
bool
ok
=
stub_LdrLoadDll
.
SetDetour
(
NtDllIntercept
"
LdrLoadDll
"
&
patched_LdrLoadDll
)
;
if
(
!
ok
)
{
sBlocklistInitFailed
=
true
;
#
ifdef
DEBUG
printf_stderr
(
"
LdrLoadDll
hook
failed
no
dll
blocklisting
active
\
n
"
)
;
#
endif
}
if
(
!
sUser32BeforeBlocklist
)
{
:
:
LoadLibraryW
(
L
"
user32
.
dll
"
)
;
}
Kernel32Intercept
.
Init
(
"
kernel32
.
dll
"
)
;
if
(
!
GetModuleHandleW
(
L
"
WRusr
.
dll
"
)
)
{
if
(
!
stub_BaseThreadInitThunk
.
SetDetour
(
Kernel32Intercept
"
BaseThreadInitThunk
"
&
patched_BaseThreadInitThunk
)
)
{
#
ifdef
DEBUG
printf_stderr
(
"
BaseThreadInitThunk
hook
failed
\
n
"
)
;
#
endif
}
}
#
if
defined
(
NIGHTLY_BUILD
)
HMODULE
hKernel
=
GetModuleHandleW
(
L
"
kernel32
.
dll
"
)
;
if
(
hKernel
)
{
void
*
pProc
;
pProc
=
(
void
*
)
GetProcAddress
(
hKernel
"
LoadLibraryA
"
)
;
gStartAddressesToBlock
[
0
]
=
pProc
;
pProc
=
(
void
*
)
GetProcAddress
(
hKernel
"
LoadLibraryW
"
)
;
gStartAddressesToBlock
[
1
]
=
pProc
;
pProc
=
(
void
*
)
GetProcAddress
(
hKernel
"
LoadLibraryExA
"
)
;
gStartAddressesToBlock
[
2
]
=
pProc
;
pProc
=
(
void
*
)
GetProcAddress
(
hKernel
"
LoadLibraryExW
"
)
;
gStartAddressesToBlock
[
3
]
=
pProc
;
}
#
endif
}
#
ifdef
DEBUG
MFBT_API
void
DllBlocklist_Shutdown
(
)
{
}
#
endif
static
void
WriteAnnotation
(
HANDLE
aFile
Annotation
aAnnotation
const
char
*
aValue
DWORD
*
aNumBytes
)
{
const
char
*
str
=
AnnotationToString
(
aAnnotation
)
;
WriteFile
(
aFile
str
strlen
(
str
)
aNumBytes
nullptr
)
;
WriteFile
(
aFile
"
=
"
1
aNumBytes
nullptr
)
;
WriteFile
(
aFile
aValue
strlen
(
aValue
)
aNumBytes
nullptr
)
;
}
static
void
InternalWriteNotes
(
HANDLE
file
)
{
DWORD
nBytes
;
WriteAnnotation
(
file
Annotation
:
:
BlockedDllList
"
"
&
nBytes
)
;
DllBlockSet
:
:
Write
(
file
)
;
WriteFile
(
file
"
\
n
"
1
&
nBytes
nullptr
)
;
if
(
sBlocklistInitFailed
)
{
WriteAnnotation
(
file
Annotation
:
:
BlocklistInitFailed
"
1
\
n
"
&
nBytes
)
;
}
if
(
sUser32BeforeBlocklist
)
{
WriteAnnotation
(
file
Annotation
:
:
User32BeforeBlocklist
"
1
\
n
"
&
nBytes
)
;
}
}
using
WriterFn
=
void
(
*
)
(
HANDLE
)
;
static
WriterFn
gWriterFn
=
&
InternalWriteNotes
;
static
void
GetNativeNtBlockSetWriter
(
)
{
auto
nativeWriter
=
reinterpret_cast
<
WriterFn
>
(
:
:
GetProcAddress
(
:
:
GetModuleHandleW
(
nullptr
)
"
NativeNtBlockSet_Write
"
)
)
;
if
(
nativeWriter
)
{
gWriterFn
=
nativeWriter
;
}
}
MFBT_API
void
DllBlocklist_WriteNotes
(
HANDLE
file
)
{
MOZ_ASSERT
(
gWriterFn
)
;
gWriterFn
(
file
)
;
}
MFBT_API
bool
DllBlocklist_CheckStatus
(
)
{
if
(
sBlocklistInitFailed
|
|
sUser32BeforeBlocklist
)
return
false
;
return
true
;
}
namespace
mozilla
{
Authenticode
*
GetAuthenticode
(
)
;
}
MFBT_API
void
DllBlocklist_SetFullDllServices
(
mozilla
:
:
glue
:
:
detail
:
:
DllServicesBase
*
aSvc
)
{
glue
:
:
AutoExclusiveLock
lock
(
gDllServicesLock
)
;
if
(
aSvc
)
{
aSvc
-
>
SetAuthenticodeImpl
(
GetAuthenticode
(
)
)
;
gMozglueLoaderObserver
.
Forward
(
aSvc
)
;
}
gDllServices
=
aSvc
;
}
MFBT_API
void
DllBlocklist_SetBasicDllServices
(
mozilla
:
:
glue
:
:
detail
:
:
DllServicesBase
*
aSvc
)
{
if
(
!
aSvc
)
{
return
;
}
aSvc
-
>
SetAuthenticodeImpl
(
GetAuthenticode
(
)
)
;
gMozglueLoaderObserver
.
Clear
(
)
;
}
