#
ifndef
ProfileChunkedBuffer_h
#
define
ProfileChunkedBuffer_h
#
include
"
mozilla
/
BaseProfilerDetail
.
h
"
#
include
"
mozilla
/
ProfileBufferChunkManager
.
h
"
#
include
"
mozilla
/
RefCounted
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
<
cstdio
>
#
include
<
utility
>
namespace
mozilla
{
class
ProfileChunkedBuffer
{
public
:
using
Byte
=
ProfileBufferChunk
:
:
Byte
;
using
Length
=
ProfileBufferChunk
:
:
Length
;
enum
class
ThreadSafety
{
WithoutMutex
WithMutex
}
;
explicit
ProfileChunkedBuffer
(
ThreadSafety
aThreadSafety
)
:
mMutex
(
aThreadSafety
!
=
ThreadSafety
:
:
WithoutMutex
)
{
}
ProfileChunkedBuffer
(
ThreadSafety
aThreadSafety
ProfileBufferChunkManager
&
aChunkManager
)
:
mMutex
(
aThreadSafety
!
=
ThreadSafety
:
:
WithoutMutex
)
{
SetChunkManager
(
aChunkManager
)
;
}
ProfileChunkedBuffer
(
ThreadSafety
aThreadSafety
UniquePtr
<
ProfileBufferChunkManager
>
&
&
aChunkManager
)
:
mMutex
(
aThreadSafety
!
=
ThreadSafety
:
:
WithoutMutex
)
{
SetChunkManager
(
std
:
:
move
(
aChunkManager
)
)
;
}
~
ProfileChunkedBuffer
(
)
{
ResetChunkManager
(
)
;
}
[
[
nodiscard
]
]
bool
IsThreadSafe
(
)
const
{
return
mMutex
.
IsActivated
(
)
;
}
[
[
nodiscard
]
]
bool
IsInSession
(
)
const
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
return
!
!
mChunkManager
;
}
void
ResetChunkManager
(
)
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
Unused
<
<
ResetChunkManager
(
lock
)
;
}
void
SetChunkManager
(
ProfileBufferChunkManager
&
aChunkManager
)
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
Unused
<
<
ResetChunkManager
(
lock
)
;
SetChunkManager
(
aChunkManager
lock
)
;
}
void
SetChunkManager
(
UniquePtr
<
ProfileBufferChunkManager
>
&
&
aChunkManager
)
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
Unused
<
<
ResetChunkManager
(
lock
)
;
mOwnedChunkManager
=
std
:
:
move
(
aChunkManager
)
;
if
(
mOwnedChunkManager
)
{
SetChunkManager
(
*
mOwnedChunkManager
lock
)
;
}
}
[
[
nodiscard
]
]
UniquePtr
<
ProfileBufferChunkManager
>
ExtractChunkManager
(
)
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
return
ResetChunkManager
(
lock
)
;
}
void
Clear
(
)
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
if
(
MOZ_UNLIKELY
(
!
mChunkManager
)
)
{
return
;
}
Unused
<
<
mChunkManager
-
>
GetExtantReleasedChunks
(
)
;
mRangeStart
=
mRangeEnd
=
mNextChunkRangeStart
;
mPushedBlockCount
=
0
;
mClearedBlockCount
=
0
;
if
(
mCurrentChunk
)
{
mCurrentChunk
-
>
MarkDone
(
)
;
mCurrentChunk
-
>
MarkRecycled
(
)
;
InitializeCurrentChunk
(
lock
)
;
}
}
Maybe
<
size_t
>
BufferLength
(
)
const
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
if
(
!
mChunkManager
)
{
return
Nothing
{
}
;
}
return
Some
(
mChunkManager
-
>
MaxTotalSize
(
)
)
;
}
[
[
nodiscard
]
]
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
return
SizeOfExcludingThis
(
aMallocSizeOf
lock
)
;
}
[
[
nodiscard
]
]
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
return
aMallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
aMallocSizeOf
lock
)
;
}
struct
State
{
ProfileBufferIndex
mRangeStart
=
1
;
ProfileBufferIndex
mRangeEnd
=
1
;
uint64_t
mPushedBlockCount
=
0
;
uint64_t
mClearedBlockCount
=
0
;
}
;
[
[
nodiscard
]
]
State
GetState
(
)
const
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
return
{
mRangeStart
mRangeEnd
mPushedBlockCount
mClearedBlockCount
}
;
}
template
<
typename
Callback
>
auto
LockAndRun
(
Callback
&
&
aCallback
)
const
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
return
std
:
:
forward
<
Callback
>
(
aCallback
)
(
)
;
}
[
[
nodiscard
]
]
UniquePtr
<
ProfileBufferChunk
>
GetAllChunks
(
)
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
if
(
MOZ_UNLIKELY
(
!
mChunkManager
)
)
{
return
nullptr
;
}
UniquePtr
<
ProfileBufferChunk
>
chunks
=
mChunkManager
-
>
GetExtantReleasedChunks
(
)
;
Unused
<
<
HandleRequestedChunk_IsPending
(
lock
)
;
if
(
MOZ_LIKELY
(
!
!
mCurrentChunk
)
)
{
mCurrentChunk
-
>
MarkDone
(
)
;
chunks
=
ProfileBufferChunk
:
:
Join
(
std
:
:
move
(
chunks
)
std
:
:
move
(
mCurrentChunk
)
)
;
}
chunks
=
ProfileBufferChunk
:
:
Join
(
std
:
:
move
(
chunks
)
std
:
:
move
(
mNextChunks
)
)
;
mChunkManager
-
>
ForgetUnreleasedChunks
(
)
;
mRangeStart
=
mRangeEnd
=
mNextChunkRangeStart
;
return
chunks
;
}
#
ifdef
DEBUG
void
Dump
(
std
:
:
FILE
*
aFile
=
stdout
)
const
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
fprintf
(
aFile
"
ProfileChunkedBuffer
[
%
p
]
State
:
range
%
u
-
%
u
pushed
=
%
u
cleared
=
%
u
"
"
(
live
=
%
u
)
"
this
unsigned
(
mRangeStart
)
unsigned
(
mRangeEnd
)
unsigned
(
mPushedBlockCount
)
unsigned
(
mClearedBlockCount
)
unsigned
(
mPushedBlockCount
)
-
unsigned
(
mClearedBlockCount
)
)
;
if
(
MOZ_UNLIKELY
(
!
mChunkManager
)
)
{
fprintf
(
aFile
"
-
Out
-
of
-
session
\
n
"
)
;
return
;
}
fprintf
(
aFile
"
-
chunks
:
\
n
"
)
;
bool
hasChunks
=
false
;
mChunkManager
-
>
PeekExtantReleasedChunks
(
[
&
]
(
const
ProfileBufferChunk
*
aOldestChunk
)
{
for
(
const
ProfileBufferChunk
*
chunk
=
aOldestChunk
;
chunk
;
chunk
=
chunk
-
>
GetNext
(
)
)
{
fprintf
(
aFile
"
R
"
)
;
chunk
-
>
Dump
(
aFile
)
;
hasChunks
=
true
;
}
}
)
;
if
(
mCurrentChunk
)
{
fprintf
(
aFile
"
C
"
)
;
mCurrentChunk
-
>
Dump
(
aFile
)
;
hasChunks
=
true
;
}
for
(
const
ProfileBufferChunk
*
chunk
=
mNextChunks
.
get
(
)
;
chunk
;
chunk
=
chunk
-
>
GetNext
(
)
)
{
fprintf
(
aFile
"
N
"
)
;
chunk
-
>
Dump
(
aFile
)
;
hasChunks
=
true
;
}
switch
(
mRequestedChunkHolder
-
>
GetState
(
)
)
{
case
RequestedChunkRefCountedHolder
:
:
State
:
:
Unused
:
fprintf
(
aFile
"
-
No
request
pending
.
\
n
"
)
;
break
;
case
RequestedChunkRefCountedHolder
:
:
State
:
:
Requested
:
fprintf
(
aFile
"
-
Request
pending
.
\
n
"
)
;
break
;
case
RequestedChunkRefCountedHolder
:
:
State
:
:
Fulfilled
:
fprintf
(
aFile
"
-
Request
fulfilled
.
\
n
"
)
;
break
;
}
if
(
!
hasChunks
)
{
fprintf
(
aFile
"
No
chunks
.
\
n
"
)
;
}
}
#
endif
private
:
[
[
nodiscard
]
]
UniquePtr
<
ProfileBufferChunkManager
>
ResetChunkManager
(
const
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
&
)
{
UniquePtr
<
ProfileBufferChunkManager
>
chunkManager
;
if
(
mChunkManager
)
{
mRequestedChunkHolder
=
nullptr
;
mChunkManager
-
>
ForgetUnreleasedChunks
(
)
;
#
ifdef
DEBUG
mChunkManager
-
>
DeregisteredFrom
(
this
)
;
#
endif
mChunkManager
=
nullptr
;
chunkManager
=
std
:
:
move
(
mOwnedChunkManager
)
;
if
(
mCurrentChunk
)
{
mCurrentChunk
-
>
MarkDone
(
)
;
mCurrentChunk
=
nullptr
;
}
mNextChunks
=
nullptr
;
mNextChunkRangeStart
=
mRangeEnd
;
mRangeStart
=
mRangeEnd
;
mPushedBlockCount
=
0
;
mClearedBlockCount
=
0
;
}
return
chunkManager
;
}
void
SetChunkManager
(
ProfileBufferChunkManager
&
aChunkManager
const
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
&
aLock
)
{
MOZ_ASSERT
(
!
mChunkManager
)
;
mChunkManager
=
&
aChunkManager
;
#
ifdef
DEBUG
mChunkManager
-
>
RegisteredWith
(
this
)
;
#
endif
mChunkManager
-
>
SetChunkDestroyedCallback
(
[
this
]
(
const
ProfileBufferChunk
&
aChunk
)
{
for
(
;
;
)
{
ProfileBufferIndex
rangeStart
=
mRangeStart
;
if
(
MOZ_LIKELY
(
rangeStart
<
=
aChunk
.
RangeStart
(
)
)
)
{
if
(
MOZ_LIKELY
(
mRangeStart
.
compareExchange
(
rangeStart
aChunk
.
RangeStart
(
)
+
aChunk
.
BufferBytes
(
)
)
)
)
{
break
;
}
}
}
mClearedBlockCount
+
=
aChunk
.
BlockCount
(
)
;
}
)
;
SetAndInitializeCurrentChunk
(
mChunkManager
-
>
GetChunk
(
)
aLock
)
;
mRequestedChunkHolder
=
MakeRefPtr
<
RequestedChunkRefCountedHolder
>
(
)
;
RequestChunk
(
aLock
)
;
}
[
[
nodiscard
]
]
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
const
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
&
)
const
{
if
(
MOZ_UNLIKELY
(
!
mChunkManager
)
)
{
return
0
;
}
size_t
size
=
mChunkManager
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
if
(
mCurrentChunk
)
{
size
+
=
mCurrentChunk
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
if
(
mNextChunks
)
{
size
+
=
mNextChunks
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
return
size
;
}
void
InitializeCurrentChunk
(
const
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
&
)
{
MOZ_ASSERT
(
!
!
mCurrentChunk
)
;
mCurrentChunk
-
>
SetRangeStart
(
mNextChunkRangeStart
)
;
mNextChunkRangeStart
+
=
mCurrentChunk
-
>
BufferBytes
(
)
;
Unused
<
<
mCurrentChunk
-
>
ReserveInitialBlockAsTail
(
0
)
;
}
void
SetAndInitializeCurrentChunk
(
UniquePtr
<
ProfileBufferChunk
>
&
&
aChunk
const
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
&
aLock
)
{
mCurrentChunk
=
std
:
:
move
(
aChunk
)
;
if
(
mCurrentChunk
)
{
InitializeCurrentChunk
(
aLock
)
;
}
}
void
RequestChunk
(
const
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
&
aLock
)
{
if
(
HandleRequestedChunk_IsPending
(
aLock
)
)
{
return
;
}
mRequestedChunkHolder
-
>
StartRequest
(
)
;
mChunkManager
-
>
RequestChunk
(
[
requestedChunkHolder
=
RefPtr
<
RequestedChunkRefCountedHolder
>
(
mRequestedChunkHolder
)
]
(
UniquePtr
<
ProfileBufferChunk
>
aChunk
)
{
requestedChunkHolder
-
>
AddRequestedChunk
(
std
:
:
move
(
aChunk
)
)
;
}
)
;
}
[
[
nodiscard
]
]
bool
HandleRequestedChunk_IsPending
(
const
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
&
aLock
)
{
MOZ_ASSERT
(
!
!
mChunkManager
)
;
MOZ_ASSERT
(
!
!
mRequestedChunkHolder
)
;
if
(
mRequestedChunkHolder
-
>
GetState
(
)
=
=
RequestedChunkRefCountedHolder
:
:
State
:
:
Unused
)
{
return
false
;
}
Maybe
<
UniquePtr
<
ProfileBufferChunk
>
>
maybeChunk
=
mRequestedChunkHolder
-
>
GetChunkIfFulfilled
(
)
;
if
(
maybeChunk
.
isNothing
(
)
)
{
return
true
;
}
MOZ_ASSERT
(
mRequestedChunkHolder
-
>
GetState
(
)
=
=
RequestedChunkRefCountedHolder
:
:
State
:
:
Unused
)
;
UniquePtr
<
ProfileBufferChunk
>
&
chunk
=
*
maybeChunk
;
if
(
chunk
)
{
if
(
!
mCurrentChunk
)
{
SetAndInitializeCurrentChunk
(
std
:
:
move
(
chunk
)
aLock
)
;
MOZ_ASSERT
(
!
mNextChunks
)
;
RequestChunk
(
aLock
)
;
return
true
;
}
if
(
!
mNextChunks
)
{
mNextChunks
=
std
:
:
move
(
chunk
)
;
}
else
{
mNextChunks
-
>
InsertNext
(
std
:
:
move
(
chunk
)
)
;
}
}
return
false
;
}
mutable
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeMutex
mMutex
;
ProfileBufferChunkManager
*
mChunkManager
=
nullptr
;
UniquePtr
<
ProfileBufferChunkManager
>
mOwnedChunkManager
;
UniquePtr
<
ProfileBufferChunk
>
mCurrentChunk
;
UniquePtr
<
ProfileBufferChunk
>
mNextChunks
;
class
RequestedChunkRefCountedHolder
:
public
external
:
:
AtomicRefCounted
<
RequestedChunkRefCountedHolder
>
{
public
:
MOZ_DECLARE_REFCOUNTED_TYPENAME
(
RequestedChunkRefCountedHolder
)
enum
class
State
{
Unused
Requested
Fulfilled
}
;
[
[
nodiscard
]
]
State
GetState
(
)
const
{
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
lock
(
mRequestMutex
)
;
return
mState
;
}
void
StartRequest
(
)
{
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
lock
(
mRequestMutex
)
;
MOZ_ASSERT
(
mState
=
=
State
:
:
Unused
"
Already
requested
or
fulfilled
"
)
;
mState
=
State
:
:
Requested
;
}
void
AddRequestedChunk
(
UniquePtr
<
ProfileBufferChunk
>
&
&
aChunk
)
{
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
lock
(
mRequestMutex
)
;
MOZ_ASSERT
(
mState
=
=
State
:
:
Requested
)
;
mState
=
State
:
:
Fulfilled
;
mRequestedChunk
=
std
:
:
move
(
aChunk
)
;
}
[
[
nodiscard
]
]
Maybe
<
UniquePtr
<
ProfileBufferChunk
>
>
GetChunkIfFulfilled
(
)
{
Maybe
<
UniquePtr
<
ProfileBufferChunk
>
>
maybeChunk
;
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
lock
(
mRequestMutex
)
;
MOZ_ASSERT
(
mState
=
=
State
:
:
Requested
|
|
mState
=
=
State
:
:
Fulfilled
)
;
if
(
mState
=
=
State
:
:
Fulfilled
)
{
mState
=
State
:
:
Unused
;
maybeChunk
.
emplace
(
std
:
:
move
(
mRequestedChunk
)
)
;
}
return
maybeChunk
;
}
private
:
mutable
baseprofiler
:
:
detail
:
:
BaseProfilerMutex
mRequestMutex
;
State
mState
=
State
:
:
Unused
;
UniquePtr
<
ProfileBufferChunk
>
mRequestedChunk
;
}
;
RefPtr
<
RequestedChunkRefCountedHolder
>
mRequestedChunkHolder
;
ProfileBufferIndex
mNextChunkRangeStart
=
1
;
Atomic
<
ProfileBufferIndex
MemoryOrdering
:
:
ReleaseAcquire
>
mRangeStart
{
1
}
;
ProfileBufferIndex
mRangeEnd
=
1
;
uint64_t
mPushedBlockCount
=
0
;
Atomic
<
uint64_t
MemoryOrdering
:
:
ReleaseAcquire
>
mClearedBlockCount
{
0
}
;
}
;
}
#
endif
