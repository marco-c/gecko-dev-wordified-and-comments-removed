#
ifndef
ProfileChunkedBuffer_h
#
define
ProfileChunkedBuffer_h
#
include
"
mozilla
/
BaseProfilerDetail
.
h
"
#
include
"
mozilla
/
NotNull
.
h
"
#
include
"
mozilla
/
ProfileBufferChunkManager
.
h
"
#
include
"
mozilla
/
ProfileBufferChunkManagerSingle
.
h
"
#
include
"
mozilla
/
ProfileBufferEntrySerialization
.
h
"
#
include
"
mozilla
/
RefCounted
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
<
cstdio
>
#
include
<
utility
>
namespace
mozilla
{
namespace
detail
{
class
InChunkPointer
{
public
:
using
Byte
=
ProfileBufferChunk
:
:
Byte
;
using
Length
=
ProfileBufferChunk
:
:
Length
;
InChunkPointer
(
)
:
mChunk
(
nullptr
)
mNextChunkGroup
(
nullptr
)
mOffsetInChunk
(
0
)
{
}
InChunkPointer
(
const
ProfileBufferChunk
*
aChunk
const
ProfileBufferChunk
*
aNextChunkGroup
ProfileBufferBlockIndex
aBlockIndex
)
:
mChunk
(
aChunk
)
mNextChunkGroup
(
aNextChunkGroup
)
{
if
(
mChunk
)
{
mOffsetInChunk
=
mChunk
-
>
OffsetFirstBlock
(
)
;
Adjust
(
)
;
}
else
if
(
mNextChunkGroup
)
{
mChunk
=
mNextChunkGroup
;
mNextChunkGroup
=
nullptr
;
mOffsetInChunk
=
mChunk
-
>
OffsetFirstBlock
(
)
;
Adjust
(
)
;
}
else
{
mOffsetInChunk
=
0
;
}
if
(
!
AdvanceToGlobalRangePosition
(
aBlockIndex
)
)
{
mChunk
=
nullptr
;
mNextChunkGroup
=
nullptr
;
}
}
InChunkPointer
(
const
ProfileBufferChunk
*
aChunk
const
ProfileBufferChunk
*
aNextChunkGroup
ProfileBufferIndex
aIndex
=
ProfileBufferIndex
(
0
)
)
:
mChunk
(
aChunk
)
mNextChunkGroup
(
aNextChunkGroup
)
{
if
(
mChunk
)
{
mOffsetInChunk
=
mChunk
-
>
OffsetFirstBlock
(
)
;
Adjust
(
)
;
}
else
if
(
mNextChunkGroup
)
{
mChunk
=
mNextChunkGroup
;
mNextChunkGroup
=
nullptr
;
mOffsetInChunk
=
mChunk
-
>
OffsetFirstBlock
(
)
;
Adjust
(
)
;
}
else
{
mOffsetInChunk
=
0
;
}
if
(
!
AdvanceToGlobalRangePosition
(
aIndex
)
)
{
mChunk
=
nullptr
;
mNextChunkGroup
=
nullptr
;
}
}
[
[
nodiscard
]
]
ProfileBufferIndex
GlobalRangePosition
(
)
const
{
if
(
IsNull
(
)
)
{
return
0
;
}
return
mChunk
-
>
RangeStart
(
)
+
mOffsetInChunk
;
}
[
[
nodiscard
]
]
bool
AdvanceToGlobalRangePosition
(
ProfileBufferBlockIndex
aBlockIndex
)
{
if
(
IsNull
(
)
)
{
return
false
;
}
if
(
!
aBlockIndex
)
{
return
ShouldPointAtValidBlock
(
)
;
}
if
(
aBlockIndex
.
ConvertToProfileBufferIndex
(
)
<
GlobalRangePosition
(
)
)
{
return
ShouldPointAtValidBlock
(
)
;
}
for
(
;
;
)
{
if
(
aBlockIndex
.
ConvertToProfileBufferIndex
(
)
<
mChunk
-
>
RangeStart
(
)
+
mChunk
-
>
OffsetPastLastBlock
(
)
)
{
mOffsetInChunk
=
aBlockIndex
.
ConvertToProfileBufferIndex
(
)
-
mChunk
-
>
RangeStart
(
)
;
return
ShouldPointAtValidBlock
(
)
;
}
GoToNextChunk
(
)
;
if
(
IsNull
(
)
)
{
return
false
;
}
mOffsetInChunk
=
mChunk
-
>
OffsetFirstBlock
(
)
;
if
(
aBlockIndex
.
ConvertToProfileBufferIndex
(
)
<
GlobalRangePosition
(
)
)
{
MOZ_ASSERT
(
false
"
AdvanceToGlobalRangePosition
-
In
-
between
blocks
"
)
;
return
false
;
}
}
}
[
[
nodiscard
]
]
bool
AdvanceToGlobalRangePosition
(
ProfileBufferIndex
aPosition
)
{
if
(
aPosition
=
=
0
)
{
return
!
IsNull
(
)
;
}
for
(
;
;
)
{
ProfileBufferIndex
currentPosition
=
GlobalRangePosition
(
)
;
if
(
currentPosition
=
=
0
)
{
return
false
;
}
if
(
aPosition
<
=
currentPosition
)
{
return
true
;
}
if
(
aPosition
<
mChunk
-
>
RangeStart
(
)
+
mChunk
-
>
OffsetPastLastBlock
(
)
)
{
for
(
;
;
)
{
mOffsetInChunk
+
=
ReadEntrySize
(
)
;
if
(
mOffsetInChunk
>
=
mChunk
-
>
OffsetPastLastBlock
(
)
)
{
break
;
}
if
(
aPosition
<
=
mChunk
-
>
RangeStart
(
)
+
mOffsetInChunk
)
{
return
true
;
}
}
}
GoToNextChunk
(
)
;
if
(
IsNull
(
)
)
{
return
false
;
}
mOffsetInChunk
=
mChunk
-
>
OffsetFirstBlock
(
)
;
}
}
[
[
nodiscard
]
]
Byte
ReadByte
(
)
{
MOZ_ASSERT
(
!
IsNull
(
)
)
;
MOZ_ASSERT
(
mOffsetInChunk
<
mChunk
-
>
OffsetPastLastBlock
(
)
)
;
Byte
byte
=
mChunk
-
>
ByteAt
(
mOffsetInChunk
)
;
if
(
MOZ_UNLIKELY
(
+
+
mOffsetInChunk
=
=
mChunk
-
>
OffsetPastLastBlock
(
)
)
)
{
Adjust
(
)
;
}
return
byte
;
}
[
[
nodiscard
]
]
Length
ReadEntrySize
(
)
{
ULEB128Reader
<
Length
>
reader
;
if
(
IsNull
(
)
)
{
return
0
;
}
for
(
;
;
)
{
const
bool
isComplete
=
reader
.
FeedByteIsComplete
(
ReadByte
(
)
)
;
if
(
MOZ_UNLIKELY
(
IsNull
(
)
)
)
{
return
0
;
}
if
(
MOZ_LIKELY
(
isComplete
)
)
{
if
(
MOZ_UNLIKELY
(
reader
.
Value
(
)
>
mChunk
-
>
BufferBytes
(
)
)
)
{
return
0
;
}
return
reader
.
Value
(
)
;
}
}
}
InChunkPointer
&
operator
+
=
(
Length
aLength
)
{
MOZ_ASSERT
(
!
IsNull
(
)
)
;
mOffsetInChunk
+
=
aLength
;
Adjust
(
)
;
return
*
this
;
}
[
[
nodiscard
]
]
ProfileBufferEntryReader
EntryReader
(
Length
aLength
)
{
if
(
IsNull
(
)
|
|
aLength
=
=
0
)
{
return
ProfileBufferEntryReader
(
)
;
}
MOZ_ASSERT
(
mOffsetInChunk
<
mChunk
-
>
OffsetPastLastBlock
(
)
)
;
const
ProfileBufferIndex
entryIndex
=
GlobalRangePosition
(
)
;
MOZ_ASSERT
(
entryIndex
>
=
1u
+
ULEB128Size
(
aLength
)
)
;
const
Length
remaining
=
mChunk
-
>
OffsetPastLastBlock
(
)
-
mOffsetInChunk
;
Span
<
const
Byte
>
mem0
=
mChunk
-
>
BufferSpan
(
)
;
mem0
=
mem0
.
From
(
mOffsetInChunk
)
;
if
(
aLength
<
=
remaining
)
{
*
this
+
=
aLength
;
return
ProfileBufferEntryReader
(
mem0
.
To
(
aLength
)
ProfileBufferBlockIndex
:
:
CreateFromProfileBufferIndex
(
entryIndex
-
ULEB128Size
(
aLength
)
)
ProfileBufferBlockIndex
:
:
CreateFromProfileBufferIndex
(
GlobalRangePosition
(
)
)
)
;
}
GoToNextChunk
(
)
;
if
(
IsNull
(
)
)
{
return
ProfileBufferEntryReader
(
)
;
}
Span
<
const
Byte
>
mem1
=
mChunk
-
>
BufferSpan
(
)
;
const
Length
tail
=
aLength
-
remaining
;
MOZ_ASSERT
(
tail
<
=
mChunk
-
>
BufferBytes
(
)
)
;
MOZ_ASSERT
(
tail
=
=
mChunk
-
>
OffsetFirstBlock
(
)
)
;
mOffsetInChunk
=
tail
;
Adjust
(
)
;
return
ProfileBufferEntryReader
(
mem0
mem1
.
To
(
tail
)
ProfileBufferBlockIndex
:
:
CreateFromProfileBufferIndex
(
entryIndex
-
ULEB128Size
(
aLength
)
)
ProfileBufferBlockIndex
:
:
CreateFromProfileBufferIndex
(
GlobalRangePosition
(
)
)
)
;
}
[
[
nodiscard
]
]
bool
IsNull
(
)
const
{
return
!
mChunk
;
}
[
[
nodiscard
]
]
bool
operator
=
=
(
const
InChunkPointer
&
aOther
)
const
{
if
(
IsNull
(
)
|
|
aOther
.
IsNull
(
)
)
{
return
IsNull
(
)
&
&
aOther
.
IsNull
(
)
;
}
return
mChunk
=
=
aOther
.
mChunk
&
&
mOffsetInChunk
=
=
aOther
.
mOffsetInChunk
;
}
[
[
nodiscard
]
]
bool
operator
!
=
(
const
InChunkPointer
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
[
[
nodiscard
]
]
Byte
operator
*
(
)
const
{
MOZ_ASSERT
(
!
IsNull
(
)
)
;
MOZ_ASSERT
(
mOffsetInChunk
<
mChunk
-
>
OffsetPastLastBlock
(
)
)
;
return
mChunk
-
>
ByteAt
(
mOffsetInChunk
)
;
}
InChunkPointer
&
operator
+
+
(
)
{
MOZ_ASSERT
(
!
IsNull
(
)
)
;
MOZ_ASSERT
(
mOffsetInChunk
<
mChunk
-
>
OffsetPastLastBlock
(
)
)
;
if
(
MOZ_UNLIKELY
(
+
+
mOffsetInChunk
=
=
mChunk
-
>
OffsetPastLastBlock
(
)
)
)
{
mOffsetInChunk
=
0
;
GoToNextChunk
(
)
;
Adjust
(
)
;
}
return
*
this
;
}
private
:
void
GoToNextChunk
(
)
{
MOZ_ASSERT
(
!
IsNull
(
)
)
;
const
ProfileBufferIndex
expectedNextRangeStart
=
mChunk
-
>
RangeStart
(
)
+
mChunk
-
>
BufferBytes
(
)
;
mChunk
=
mChunk
-
>
GetNext
(
)
;
if
(
!
mChunk
)
{
mChunk
=
mNextChunkGroup
;
mNextChunkGroup
=
nullptr
;
}
if
(
mChunk
&
&
mChunk
-
>
RangeStart
(
)
=
=
0
)
{
mChunk
=
nullptr
;
}
MOZ_ASSERT
(
!
mChunk
|
|
mChunk
-
>
RangeStart
(
)
=
=
expectedNextRangeStart
"
We
don
'
t
handle
discontinuous
buffers
(
yet
)
"
)
;
if
(
mChunk
&
&
mChunk
-
>
RangeStart
(
)
!
=
expectedNextRangeStart
)
{
mChunk
=
nullptr
;
}
}
void
Adjust
(
)
{
while
(
mChunk
&
&
mOffsetInChunk
>
=
mChunk
-
>
OffsetPastLastBlock
(
)
)
{
if
(
mOffsetInChunk
<
mChunk
-
>
BufferBytes
(
)
)
{
mOffsetInChunk
-
=
mChunk
-
>
BufferBytes
(
)
;
}
else
{
mOffsetInChunk
-
=
mChunk
-
>
OffsetPastLastBlock
(
)
;
}
GoToNextChunk
(
)
;
}
}
[
[
nodiscard
]
]
bool
ShouldPointAtValidBlock
(
)
const
{
if
(
IsNull
(
)
)
{
MOZ_ASSERT
(
false
"
ShouldPointAtValidBlock
-
null
pointer
"
)
;
return
false
;
}
InChunkPointer
pointer
=
*
this
;
Length
entrySize
=
pointer
.
ReadEntrySize
(
)
;
if
(
entrySize
=
=
0
)
{
MOZ_ASSERT
(
false
"
ShouldPointAtValidBlock
-
invalid
size
"
)
;
return
false
;
}
pointer
+
=
entrySize
-
1
;
MOZ_ASSERT
(
!
IsNull
(
)
"
ShouldPointAtValidBlock
-
past
end
of
buffer
"
)
;
return
!
IsNull
(
)
;
}
const
ProfileBufferChunk
*
mChunk
;
const
ProfileBufferChunk
*
mNextChunkGroup
;
Length
mOffsetInChunk
;
}
;
}
class
ProfileChunkedBuffer
{
public
:
using
Byte
=
ProfileBufferChunk
:
:
Byte
;
using
Length
=
ProfileBufferChunk
:
:
Length
;
enum
class
ThreadSafety
{
WithoutMutex
WithMutex
}
;
explicit
ProfileChunkedBuffer
(
ThreadSafety
aThreadSafety
)
:
mMutex
(
aThreadSafety
!
=
ThreadSafety
:
:
WithoutMutex
)
{
}
ProfileChunkedBuffer
(
ThreadSafety
aThreadSafety
ProfileBufferChunkManager
&
aChunkManager
)
:
mMutex
(
aThreadSafety
!
=
ThreadSafety
:
:
WithoutMutex
)
{
SetChunkManager
(
aChunkManager
)
;
}
ProfileChunkedBuffer
(
ThreadSafety
aThreadSafety
UniquePtr
<
ProfileBufferChunkManager
>
&
&
aChunkManager
)
:
mMutex
(
aThreadSafety
!
=
ThreadSafety
:
:
WithoutMutex
)
{
SetChunkManager
(
std
:
:
move
(
aChunkManager
)
)
;
}
~
ProfileChunkedBuffer
(
)
{
ResetChunkManager
(
)
;
}
[
[
nodiscard
]
]
bool
IsThreadSafe
(
)
const
{
return
mMutex
.
IsActivated
(
)
;
}
[
[
nodiscard
]
]
bool
IsInSession
(
)
const
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
return
!
!
mChunkManager
;
}
void
ResetChunkManager
(
)
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
Unused
<
<
ResetChunkManager
(
lock
)
;
}
void
SetChunkManager
(
ProfileBufferChunkManager
&
aChunkManager
)
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
Unused
<
<
ResetChunkManager
(
lock
)
;
SetChunkManager
(
aChunkManager
lock
)
;
}
void
SetChunkManager
(
UniquePtr
<
ProfileBufferChunkManager
>
&
&
aChunkManager
)
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
Unused
<
<
ResetChunkManager
(
lock
)
;
mOwnedChunkManager
=
std
:
:
move
(
aChunkManager
)
;
if
(
mOwnedChunkManager
)
{
SetChunkManager
(
*
mOwnedChunkManager
lock
)
;
}
}
[
[
nodiscard
]
]
UniquePtr
<
ProfileBufferChunkManager
>
ExtractChunkManager
(
)
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
return
ResetChunkManager
(
lock
)
;
}
void
Clear
(
)
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
if
(
MOZ_UNLIKELY
(
!
mChunkManager
)
)
{
return
;
}
Unused
<
<
mChunkManager
-
>
GetExtantReleasedChunks
(
)
;
mRangeStart
=
mRangeEnd
=
mNextChunkRangeStart
;
mPushedBlockCount
=
0
;
mClearedBlockCount
=
0
;
if
(
mCurrentChunk
)
{
mCurrentChunk
-
>
MarkDone
(
)
;
mCurrentChunk
-
>
MarkRecycled
(
)
;
InitializeCurrentChunk
(
lock
)
;
}
}
Maybe
<
size_t
>
BufferLength
(
)
const
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
if
(
!
mChunkManager
)
{
return
Nothing
{
}
;
}
return
Some
(
mChunkManager
-
>
MaxTotalSize
(
)
)
;
}
[
[
nodiscard
]
]
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
return
SizeOfExcludingThis
(
aMallocSizeOf
lock
)
;
}
[
[
nodiscard
]
]
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
return
aMallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
aMallocSizeOf
lock
)
;
}
struct
State
{
ProfileBufferIndex
mRangeStart
=
1
;
ProfileBufferIndex
mRangeEnd
=
1
;
uint64_t
mPushedBlockCount
=
0
;
uint64_t
mClearedBlockCount
=
0
;
}
;
[
[
nodiscard
]
]
State
GetState
(
)
const
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
return
{
mRangeStart
mRangeEnd
mPushedBlockCount
mClearedBlockCount
}
;
}
[
[
nodiscard
]
]
bool
IsEmpty
(
)
const
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
return
mRangeStart
=
=
mRangeEnd
;
}
[
[
nodiscard
]
]
bool
IsThreadSafeAndLockedOnCurrentThread
(
)
const
{
return
mMutex
.
IsActivatedAndLockedOnCurrentThread
(
)
;
}
template
<
typename
Callback
>
auto
LockAndRun
(
Callback
&
&
aCallback
)
const
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
return
std
:
:
forward
<
Callback
>
(
aCallback
)
(
)
;
}
template
<
typename
CallbackEntryBytes
typename
Callback
>
auto
ReserveAndPut
(
CallbackEntryBytes
&
&
aCallbackEntryBytes
Callback
&
&
aCallback
)
-
>
decltype
(
std
:
:
forward
<
Callback
>
(
aCallback
)
(
std
:
:
declval
<
Maybe
<
ProfileBufferEntryWriter
>
&
>
(
)
)
)
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
Length
entryBytes
;
return
ReserveAndPutRaw
(
[
&
]
(
)
{
entryBytes
=
std
:
:
forward
<
CallbackEntryBytes
>
(
aCallbackEntryBytes
)
(
)
;
MOZ_ASSERT
(
entryBytes
!
=
0
"
Empty
entries
are
not
allowed
"
)
;
return
ULEB128Size
(
entryBytes
)
+
entryBytes
;
}
[
&
]
(
Maybe
<
ProfileBufferEntryWriter
>
&
aMaybeEntryWriter
)
{
if
(
aMaybeEntryWriter
.
isSome
(
)
)
{
aMaybeEntryWriter
-
>
WriteULEB128
(
entryBytes
)
;
MOZ_ASSERT
(
aMaybeEntryWriter
-
>
RemainingBytes
(
)
=
=
entryBytes
)
;
}
return
std
:
:
forward
<
Callback
>
(
aCallback
)
(
aMaybeEntryWriter
)
;
}
lock
)
;
}
template
<
typename
Callback
>
auto
Put
(
Length
aEntryBytes
Callback
&
&
aCallback
)
{
return
ReserveAndPut
(
[
aEntryBytes
]
(
)
{
return
aEntryBytes
;
}
std
:
:
forward
<
Callback
>
(
aCallback
)
)
;
}
ProfileBufferBlockIndex
PutFrom
(
const
void
*
aSrc
Length
aBytes
)
{
return
ReserveAndPut
(
[
aBytes
]
(
)
{
return
aBytes
;
}
[
aSrc
aBytes
]
(
Maybe
<
ProfileBufferEntryWriter
>
&
aMaybeEntryWriter
)
{
if
(
aMaybeEntryWriter
.
isNothing
(
)
)
{
return
ProfileBufferBlockIndex
{
}
;
}
aMaybeEntryWriter
-
>
WriteBytes
(
aSrc
aBytes
)
;
return
aMaybeEntryWriter
-
>
CurrentBlockIndex
(
)
;
}
)
;
}
template
<
typename
.
.
.
Ts
>
ProfileBufferBlockIndex
PutObjects
(
const
Ts
&
.
.
.
aTs
)
{
static_assert
(
sizeof
.
.
.
(
Ts
)
>
0
"
PutObjects
must
be
given
at
least
one
object
.
"
)
;
return
ReserveAndPut
(
[
&
]
(
)
{
return
ProfileBufferEntryWriter
:
:
SumBytes
(
aTs
.
.
.
)
;
}
[
&
]
(
Maybe
<
ProfileBufferEntryWriter
>
&
aMaybeEntryWriter
)
{
if
(
aMaybeEntryWriter
.
isNothing
(
)
)
{
return
ProfileBufferBlockIndex
{
}
;
}
aMaybeEntryWriter
-
>
WriteObjects
(
aTs
.
.
.
)
;
return
aMaybeEntryWriter
-
>
CurrentBlockIndex
(
)
;
}
)
;
}
template
<
typename
T
>
ProfileBufferBlockIndex
PutObject
(
const
T
&
aOb
)
{
return
PutObjects
(
aOb
)
;
}
[
[
nodiscard
]
]
UniquePtr
<
ProfileBufferChunk
>
GetAllChunks
(
)
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
if
(
MOZ_UNLIKELY
(
!
mChunkManager
)
)
{
return
nullptr
;
}
UniquePtr
<
ProfileBufferChunk
>
chunks
=
mChunkManager
-
>
GetExtantReleasedChunks
(
)
;
Unused
<
<
HandleRequestedChunk_IsPending
(
lock
)
;
if
(
MOZ_LIKELY
(
!
!
mCurrentChunk
)
)
{
mCurrentChunk
-
>
MarkDone
(
)
;
chunks
=
ProfileBufferChunk
:
:
Join
(
std
:
:
move
(
chunks
)
std
:
:
move
(
mCurrentChunk
)
)
;
}
chunks
=
ProfileBufferChunk
:
:
Join
(
std
:
:
move
(
chunks
)
std
:
:
move
(
mNextChunks
)
)
;
mChunkManager
-
>
ForgetUnreleasedChunks
(
)
;
mRangeStart
=
mRangeEnd
=
mNextChunkRangeStart
;
return
chunks
;
}
class
Reader
;
class
BlockIterator
{
public
:
#
ifdef
DEBUG
~
BlockIterator
(
)
{
mBuffer
-
>
mMutex
.
AssertCurrentThreadOwns
(
)
;
}
#
endif
[
[
nodiscard
]
]
bool
operator
=
=
(
const
BlockIterator
&
aRhs
)
const
{
MOZ_ASSERT
(
mBuffer
=
=
aRhs
.
mBuffer
)
;
return
mCurrentBlockIndex
=
=
aRhs
.
mCurrentBlockIndex
;
}
[
[
nodiscard
]
]
bool
operator
!
=
(
const
BlockIterator
&
aRhs
)
const
{
MOZ_ASSERT
(
mBuffer
=
=
aRhs
.
mBuffer
)
;
return
mCurrentBlockIndex
!
=
aRhs
.
mCurrentBlockIndex
;
}
BlockIterator
&
operator
+
+
(
)
{
mBuffer
-
>
mMutex
.
AssertCurrentThreadOwns
(
)
;
mCurrentBlockIndex
=
ProfileBufferBlockIndex
:
:
CreateFromProfileBufferIndex
(
mNextBlockPointer
.
GlobalRangePosition
(
)
)
;
mCurrentEntry
=
mNextBlockPointer
.
EntryReader
(
mNextBlockPointer
.
ReadEntrySize
(
)
)
;
return
*
this
;
}
[
[
nodiscard
]
]
ProfileBufferEntryReader
operator
*
(
)
const
{
return
mCurrentEntry
;
}
[
[
nodiscard
]
]
bool
IsAtEnd
(
)
const
{
return
mCurrentEntry
.
RemainingBytes
(
)
=
=
0
;
}
[
[
nodiscard
]
]
ProfileBufferBlockIndex
CurrentBlockIndex
(
)
const
{
return
mCurrentBlockIndex
;
}
[
[
nodiscard
]
]
ProfileBufferBlockIndex
NextBlockIndex
(
)
const
{
MOZ_ASSERT
(
!
IsAtEnd
(
)
)
;
return
ProfileBufferBlockIndex
:
:
CreateFromProfileBufferIndex
(
mNextBlockPointer
.
GlobalRangePosition
(
)
)
;
}
[
[
nodiscard
]
]
ProfileBufferBlockIndex
BufferRangeStart
(
)
const
{
mBuffer
-
>
mMutex
.
AssertCurrentThreadOwns
(
)
;
return
ProfileBufferBlockIndex
:
:
CreateFromProfileBufferIndex
(
mBuffer
-
>
mRangeStart
)
;
}
[
[
nodiscard
]
]
ProfileBufferBlockIndex
BufferRangeEnd
(
)
const
{
mBuffer
-
>
mMutex
.
AssertCurrentThreadOwns
(
)
;
return
ProfileBufferBlockIndex
:
:
CreateFromProfileBufferIndex
(
mBuffer
-
>
mRangeEnd
)
;
}
private
:
friend
class
Reader
;
BlockIterator
(
const
ProfileChunkedBuffer
&
aBuffer
const
ProfileBufferChunk
*
aChunks0
const
ProfileBufferChunk
*
aChunks1
ProfileBufferBlockIndex
aBlockIndex
)
:
mNextBlockPointer
(
aChunks0
aChunks1
aBlockIndex
)
mCurrentBlockIndex
(
ProfileBufferBlockIndex
:
:
CreateFromProfileBufferIndex
(
mNextBlockPointer
.
GlobalRangePosition
(
)
)
)
mCurrentEntry
(
mNextBlockPointer
.
EntryReader
(
mNextBlockPointer
.
ReadEntrySize
(
)
)
)
mBuffer
(
WrapNotNull
(
&
aBuffer
)
)
{
mBuffer
-
>
mMutex
.
AssertCurrentThreadOwns
(
)
;
}
detail
:
:
InChunkPointer
mNextBlockPointer
;
ProfileBufferBlockIndex
mCurrentBlockIndex
;
ProfileBufferEntryReader
mCurrentEntry
;
NotNull
<
const
ProfileChunkedBuffer
*
>
mBuffer
;
}
;
class
MOZ_RAII
Reader
{
public
:
Reader
(
const
Reader
&
)
=
delete
;
Reader
&
operator
=
(
const
Reader
&
)
=
delete
;
Reader
(
Reader
&
&
)
=
delete
;
Reader
&
operator
=
(
Reader
&
&
)
=
delete
;
#
ifdef
DEBUG
~
Reader
(
)
{
mBuffer
.
mMutex
.
AssertCurrentThreadOwns
(
)
;
}
#
endif
[
[
nodiscard
]
]
ProfileBufferBlockIndex
BufferRangeStart
(
)
const
{
mBuffer
.
mMutex
.
AssertCurrentThreadOwns
(
)
;
return
ProfileBufferBlockIndex
:
:
CreateFromProfileBufferIndex
(
mBuffer
.
mRangeStart
)
;
}
[
[
nodiscard
]
]
ProfileBufferBlockIndex
BufferRangeEnd
(
)
const
{
mBuffer
.
mMutex
.
AssertCurrentThreadOwns
(
)
;
return
ProfileBufferBlockIndex
:
:
CreateFromProfileBufferIndex
(
mBuffer
.
mRangeEnd
)
;
}
[
[
nodiscard
]
]
BlockIterator
begin
(
)
const
{
return
BlockIterator
(
mBuffer
mChunks0
mChunks1
nullptr
)
;
}
[
[
nodiscard
]
]
BlockIterator
end
(
)
const
{
return
BlockIterator
(
mBuffer
nullptr
nullptr
nullptr
)
;
}
[
[
nodiscard
]
]
BlockIterator
At
(
ProfileBufferBlockIndex
aBlockIndex
)
const
{
if
(
aBlockIndex
<
BufferRangeStart
(
)
)
{
return
begin
(
)
;
}
return
BlockIterator
(
mBuffer
mChunks0
mChunks1
aBlockIndex
)
;
}
template
<
typename
Callback
>
void
ForEach
(
Callback
&
&
aCallback
)
const
{
for
(
ProfileBufferEntryReader
reader
:
*
this
)
{
aCallback
(
reader
)
;
}
}
[
[
nodiscard
]
]
ProfileBufferEntryReader
SingleChunkDataAsEntry
(
)
{
const
ProfileBufferChunk
*
onlyNonEmptyChunk
=
nullptr
;
for
(
const
ProfileBufferChunk
*
chunkList
:
{
mChunks0
mChunks1
}
)
{
for
(
const
ProfileBufferChunk
*
chunk
=
chunkList
;
chunk
;
chunk
=
chunk
-
>
GetNext
(
)
)
{
if
(
chunk
-
>
OffsetFirstBlock
(
)
!
=
chunk
-
>
OffsetPastLastBlock
(
)
)
{
if
(
onlyNonEmptyChunk
)
{
return
ProfileBufferEntryReader
(
)
;
}
onlyNonEmptyChunk
=
chunk
;
}
}
}
if
(
!
onlyNonEmptyChunk
)
{
return
ProfileBufferEntryReader
(
)
;
}
return
ProfileBufferEntryReader
(
onlyNonEmptyChunk
-
>
BufferSpan
(
)
.
FromTo
(
onlyNonEmptyChunk
-
>
OffsetFirstBlock
(
)
onlyNonEmptyChunk
-
>
OffsetPastLastBlock
(
)
)
ProfileBufferBlockIndex
:
:
CreateFromProfileBufferIndex
(
onlyNonEmptyChunk
-
>
RangeStart
(
)
)
ProfileBufferBlockIndex
:
:
CreateFromProfileBufferIndex
(
onlyNonEmptyChunk
-
>
RangeStart
(
)
+
(
onlyNonEmptyChunk
-
>
OffsetPastLastBlock
(
)
-
onlyNonEmptyChunk
-
>
OffsetFirstBlock
(
)
)
)
)
;
}
private
:
friend
class
ProfileChunkedBuffer
;
explicit
Reader
(
const
ProfileChunkedBuffer
&
aBuffer
const
ProfileBufferChunk
*
aChunks0
const
ProfileBufferChunk
*
aChunks1
)
:
mBuffer
(
aBuffer
)
mChunks0
(
aChunks0
)
mChunks1
(
aChunks1
)
{
mBuffer
.
mMutex
.
AssertCurrentThreadOwns
(
)
;
}
const
ProfileChunkedBuffer
&
mBuffer
;
const
ProfileBufferChunk
*
mChunks0
;
const
ProfileBufferChunk
*
mChunks1
;
}
;
template
<
typename
Callback
>
[
[
nodiscard
]
]
auto
Read
(
Callback
&
&
aCallback
)
const
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
if
(
MOZ_UNLIKELY
(
!
mChunkManager
)
)
{
return
std
:
:
forward
<
Callback
>
(
aCallback
)
(
static_cast
<
Reader
*
>
(
nullptr
)
)
;
}
return
mChunkManager
-
>
PeekExtantReleasedChunks
(
[
&
]
(
const
ProfileBufferChunk
*
aOldestChunk
)
{
Reader
reader
(
*
this
aOldestChunk
mCurrentChunk
.
get
(
)
)
;
return
std
:
:
forward
<
Callback
>
(
aCallback
)
(
&
reader
)
;
}
)
;
}
template
<
typename
Callback
>
static
void
ReadEach
(
const
ProfileBufferChunk
*
aChunks0
const
ProfileBufferChunk
*
aChunks1
Callback
&
&
aCallback
)
{
static_assert
(
std
:
:
is_invocable_v
<
Callback
ProfileBufferEntryReader
&
>
|
|
std
:
:
is_invocable_v
<
Callback
ProfileBufferEntryReader
&
ProfileBufferBlockIndex
>
"
ReadEach
callback
must
take
ProfileBufferEntryReader
&
and
"
"
optionally
a
ProfileBufferBlockIndex
"
)
;
detail
:
:
InChunkPointer
p
{
aChunks0
aChunks1
}
;
while
(
!
p
.
IsNull
(
)
)
{
const
ProfileBufferBlockIndex
blockIndex
=
ProfileBufferBlockIndex
:
:
CreateFromProfileBufferIndex
(
p
.
GlobalRangePosition
(
)
)
;
Length
entrySize
=
p
.
ReadEntrySize
(
)
;
if
(
entrySize
=
=
0
)
{
return
;
}
ProfileBufferEntryReader
entryReader
=
p
.
EntryReader
(
entrySize
)
;
if
(
entryReader
.
RemainingBytes
(
)
=
=
0
)
{
return
;
}
MOZ_ASSERT
(
entryReader
.
RemainingBytes
(
)
=
=
entrySize
)
;
if
constexpr
(
std
:
:
is_invocable_v
<
Callback
ProfileBufferEntryReader
&
ProfileBufferBlockIndex
>
)
{
aCallback
(
entryReader
blockIndex
)
;
}
else
{
Unused
<
<
blockIndex
;
aCallback
(
entryReader
)
;
}
MOZ_ASSERT
(
entryReader
.
RemainingBytes
(
)
=
=
0
)
;
}
}
template
<
typename
Callback
>
void
ReadEach
(
Callback
&
&
aCallback
)
const
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
if
(
MOZ_UNLIKELY
(
!
mChunkManager
)
)
{
return
;
}
mChunkManager
-
>
PeekExtantReleasedChunks
(
[
&
]
(
const
ProfileBufferChunk
*
aOldestChunk
)
{
ReadEach
(
aOldestChunk
mCurrentChunk
.
get
(
)
std
:
:
forward
<
Callback
>
(
aCallback
)
)
;
}
)
;
}
template
<
typename
Callback
>
[
[
nodiscard
]
]
static
auto
ReadAt
(
ProfileBufferBlockIndex
aMinimumBlockIndex
const
ProfileBufferChunk
*
aChunks0
const
ProfileBufferChunk
*
aChunks1
Callback
&
&
aCallback
)
{
static_assert
(
std
:
:
is_invocable_v
<
Callback
Maybe
<
ProfileBufferEntryReader
>
&
&
>
"
ReadAt
callback
must
take
a
Maybe
<
ProfileBufferEntryReader
>
&
&
"
)
;
Maybe
<
ProfileBufferEntryReader
>
maybeEntryReader
;
if
(
detail
:
:
InChunkPointer
p
{
aChunks0
aChunks1
}
;
!
p
.
IsNull
(
)
)
{
if
(
p
.
GlobalRangePosition
(
)
>
=
aMinimumBlockIndex
.
ConvertToProfileBufferIndex
(
)
|
|
p
.
AdvanceToGlobalRangePosition
(
aMinimumBlockIndex
.
ConvertToProfileBufferIndex
(
)
)
)
{
MOZ_ASSERT
(
p
.
GlobalRangePosition
(
)
>
=
aMinimumBlockIndex
.
ConvertToProfileBufferIndex
(
)
)
;
if
(
Length
entrySize
=
p
.
ReadEntrySize
(
)
;
entrySize
!
=
0
)
{
maybeEntryReader
.
emplace
(
p
.
EntryReader
(
entrySize
)
)
;
if
(
maybeEntryReader
-
>
RemainingBytes
(
)
=
=
0
)
{
maybeEntryReader
.
reset
(
)
;
}
else
{
MOZ_ASSERT
(
maybeEntryReader
-
>
RemainingBytes
(
)
=
=
entrySize
)
;
}
}
}
}
#
ifdef
DEBUG
auto
assertAllRead
=
MakeScopeExit
(
[
&
]
(
)
{
MOZ_ASSERT
(
!
maybeEntryReader
|
|
maybeEntryReader
-
>
RemainingBytes
(
)
=
=
0
)
;
}
)
;
#
endif
return
std
:
:
forward
<
Callback
>
(
aCallback
)
(
std
:
:
move
(
maybeEntryReader
)
)
;
}
template
<
typename
Callback
>
[
[
nodiscard
]
]
auto
ReadAt
(
ProfileBufferBlockIndex
aBlockIndex
Callback
&
&
aCallback
)
const
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
if
(
MOZ_UNLIKELY
(
!
mChunkManager
)
)
{
return
std
:
:
forward
<
Callback
>
(
aCallback
)
(
Nothing
{
}
)
;
}
return
mChunkManager
-
>
PeekExtantReleasedChunks
(
[
&
]
(
const
ProfileBufferChunk
*
aOldestChunk
)
{
return
ReadAt
(
aBlockIndex
aOldestChunk
mCurrentChunk
.
get
(
)
std
:
:
forward
<
Callback
>
(
aCallback
)
)
;
}
)
;
}
ProfileBufferBlockIndex
AppendContents
(
const
ProfileChunkedBuffer
&
aSrc
)
{
ProfileBufferBlockIndex
firstBlockIndex
;
bool
failed
=
false
;
aSrc
.
ReadEach
(
[
&
]
(
ProfileBufferEntryReader
&
aER
)
{
if
(
failed
)
{
return
;
}
failed
=
!
Put
(
aER
.
RemainingBytes
(
)
[
&
]
(
Maybe
<
ProfileBufferEntryWriter
>
&
aEW
)
{
if
(
aEW
.
isNothing
(
)
)
{
return
false
;
}
if
(
!
firstBlockIndex
)
{
firstBlockIndex
=
aEW
-
>
CurrentBlockIndex
(
)
;
}
aEW
-
>
WriteFromReader
(
aER
aER
.
RemainingBytes
(
)
)
;
return
true
;
}
)
;
}
)
;
return
failed
?
nullptr
:
firstBlockIndex
;
}
#
ifdef
DEBUG
void
Dump
(
std
:
:
FILE
*
aFile
=
stdout
)
const
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
fprintf
(
aFile
"
ProfileChunkedBuffer
[
%
p
]
State
:
range
%
u
-
%
u
pushed
=
%
u
cleared
=
%
u
"
"
(
live
=
%
u
)
"
this
unsigned
(
mRangeStart
)
unsigned
(
mRangeEnd
)
unsigned
(
mPushedBlockCount
)
unsigned
(
mClearedBlockCount
)
unsigned
(
mPushedBlockCount
)
-
unsigned
(
mClearedBlockCount
)
)
;
if
(
MOZ_UNLIKELY
(
!
mChunkManager
)
)
{
fprintf
(
aFile
"
-
Out
-
of
-
session
\
n
"
)
;
return
;
}
fprintf
(
aFile
"
-
chunks
:
\
n
"
)
;
bool
hasChunks
=
false
;
mChunkManager
-
>
PeekExtantReleasedChunks
(
[
&
]
(
const
ProfileBufferChunk
*
aOldestChunk
)
{
for
(
const
ProfileBufferChunk
*
chunk
=
aOldestChunk
;
chunk
;
chunk
=
chunk
-
>
GetNext
(
)
)
{
fprintf
(
aFile
"
R
"
)
;
chunk
-
>
Dump
(
aFile
)
;
hasChunks
=
true
;
}
}
)
;
if
(
mCurrentChunk
)
{
fprintf
(
aFile
"
C
"
)
;
mCurrentChunk
-
>
Dump
(
aFile
)
;
hasChunks
=
true
;
}
for
(
const
ProfileBufferChunk
*
chunk
=
mNextChunks
.
get
(
)
;
chunk
;
chunk
=
chunk
-
>
GetNext
(
)
)
{
fprintf
(
aFile
"
N
"
)
;
chunk
-
>
Dump
(
aFile
)
;
hasChunks
=
true
;
}
switch
(
mRequestedChunkHolder
-
>
GetState
(
)
)
{
case
RequestedChunkRefCountedHolder
:
:
State
:
:
Unused
:
fprintf
(
aFile
"
-
No
request
pending
.
\
n
"
)
;
break
;
case
RequestedChunkRefCountedHolder
:
:
State
:
:
Requested
:
fprintf
(
aFile
"
-
Request
pending
.
\
n
"
)
;
break
;
case
RequestedChunkRefCountedHolder
:
:
State
:
:
Fulfilled
:
fprintf
(
aFile
"
-
Request
fulfilled
.
\
n
"
)
;
break
;
}
if
(
!
hasChunks
)
{
fprintf
(
aFile
"
No
chunks
.
\
n
"
)
;
}
}
#
endif
private
:
friend
ProfileBufferEntryWriter
:
:
Serializer
<
ProfileChunkedBuffer
>
;
friend
ProfileBufferEntryReader
:
:
Deserializer
<
ProfileChunkedBuffer
>
;
friend
ProfileBufferEntryWriter
:
:
Serializer
<
UniquePtr
<
ProfileChunkedBuffer
>
>
;
friend
ProfileBufferEntryReader
:
:
Deserializer
<
UniquePtr
<
ProfileChunkedBuffer
>
>
;
[
[
nodiscard
]
]
UniquePtr
<
ProfileBufferChunkManager
>
ResetChunkManager
(
const
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
&
)
{
UniquePtr
<
ProfileBufferChunkManager
>
chunkManager
;
if
(
mChunkManager
)
{
mRequestedChunkHolder
=
nullptr
;
mChunkManager
-
>
ForgetUnreleasedChunks
(
)
;
#
ifdef
DEBUG
mChunkManager
-
>
DeregisteredFrom
(
this
)
;
#
endif
mChunkManager
=
nullptr
;
chunkManager
=
std
:
:
move
(
mOwnedChunkManager
)
;
if
(
mCurrentChunk
)
{
mCurrentChunk
-
>
MarkDone
(
)
;
mCurrentChunk
=
nullptr
;
}
mNextChunks
=
nullptr
;
mNextChunkRangeStart
=
mRangeEnd
;
mRangeStart
=
mRangeEnd
;
mPushedBlockCount
=
0
;
mClearedBlockCount
=
0
;
}
return
chunkManager
;
}
void
SetChunkManager
(
ProfileBufferChunkManager
&
aChunkManager
const
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
&
aLock
)
{
MOZ_ASSERT
(
!
mChunkManager
)
;
mChunkManager
=
&
aChunkManager
;
#
ifdef
DEBUG
mChunkManager
-
>
RegisteredWith
(
this
)
;
#
endif
mChunkManager
-
>
SetChunkDestroyedCallback
(
[
this
]
(
const
ProfileBufferChunk
&
aChunk
)
{
for
(
;
;
)
{
ProfileBufferIndex
rangeStart
=
mRangeStart
;
if
(
MOZ_LIKELY
(
rangeStart
<
=
aChunk
.
RangeStart
(
)
)
)
{
if
(
MOZ_LIKELY
(
mRangeStart
.
compareExchange
(
rangeStart
aChunk
.
RangeStart
(
)
+
aChunk
.
BufferBytes
(
)
)
)
)
{
break
;
}
}
}
mClearedBlockCount
+
=
aChunk
.
BlockCount
(
)
;
}
)
;
SetAndInitializeCurrentChunk
(
mChunkManager
-
>
GetChunk
(
)
aLock
)
;
mRequestedChunkHolder
=
MakeRefPtr
<
RequestedChunkRefCountedHolder
>
(
)
;
RequestChunk
(
aLock
)
;
}
[
[
nodiscard
]
]
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
const
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
&
)
const
{
if
(
MOZ_UNLIKELY
(
!
mChunkManager
)
)
{
return
0
;
}
size_t
size
=
mChunkManager
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
if
(
mCurrentChunk
)
{
size
+
=
mCurrentChunk
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
if
(
mNextChunks
)
{
size
+
=
mNextChunks
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
return
size
;
}
void
InitializeCurrentChunk
(
const
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
&
)
{
MOZ_ASSERT
(
!
!
mCurrentChunk
)
;
mCurrentChunk
-
>
SetRangeStart
(
mNextChunkRangeStart
)
;
mNextChunkRangeStart
+
=
mCurrentChunk
-
>
BufferBytes
(
)
;
Unused
<
<
mCurrentChunk
-
>
ReserveInitialBlockAsTail
(
0
)
;
}
void
SetAndInitializeCurrentChunk
(
UniquePtr
<
ProfileBufferChunk
>
&
&
aChunk
const
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
&
aLock
)
{
mCurrentChunk
=
std
:
:
move
(
aChunk
)
;
if
(
mCurrentChunk
)
{
InitializeCurrentChunk
(
aLock
)
;
}
}
void
RequestChunk
(
const
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
&
aLock
)
{
if
(
HandleRequestedChunk_IsPending
(
aLock
)
)
{
return
;
}
mRequestedChunkHolder
-
>
StartRequest
(
)
;
mChunkManager
-
>
RequestChunk
(
[
requestedChunkHolder
=
RefPtr
<
RequestedChunkRefCountedHolder
>
(
mRequestedChunkHolder
)
]
(
UniquePtr
<
ProfileBufferChunk
>
aChunk
)
{
requestedChunkHolder
-
>
AddRequestedChunk
(
std
:
:
move
(
aChunk
)
)
;
}
)
;
}
[
[
nodiscard
]
]
bool
HandleRequestedChunk_IsPending
(
const
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
&
aLock
)
{
MOZ_ASSERT
(
!
!
mChunkManager
)
;
MOZ_ASSERT
(
!
!
mRequestedChunkHolder
)
;
if
(
mRequestedChunkHolder
-
>
GetState
(
)
=
=
RequestedChunkRefCountedHolder
:
:
State
:
:
Unused
)
{
return
false
;
}
Maybe
<
UniquePtr
<
ProfileBufferChunk
>
>
maybeChunk
=
mRequestedChunkHolder
-
>
GetChunkIfFulfilled
(
)
;
if
(
maybeChunk
.
isNothing
(
)
)
{
return
true
;
}
MOZ_ASSERT
(
mRequestedChunkHolder
-
>
GetState
(
)
=
=
RequestedChunkRefCountedHolder
:
:
State
:
:
Unused
)
;
UniquePtr
<
ProfileBufferChunk
>
&
chunk
=
*
maybeChunk
;
if
(
chunk
)
{
if
(
!
mCurrentChunk
)
{
SetAndInitializeCurrentChunk
(
std
:
:
move
(
chunk
)
aLock
)
;
MOZ_ASSERT
(
!
mNextChunks
)
;
RequestChunk
(
aLock
)
;
return
true
;
}
if
(
!
mNextChunks
)
{
mNextChunks
=
std
:
:
move
(
chunk
)
;
}
else
{
mNextChunks
-
>
InsertNext
(
std
:
:
move
(
chunk
)
)
;
}
}
return
false
;
}
[
[
nodiscard
]
]
ProfileBufferChunk
*
GetOrCreateCurrentChunk
(
const
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
&
aLock
)
{
ProfileBufferChunk
*
current
=
mCurrentChunk
.
get
(
)
;
if
(
MOZ_UNLIKELY
(
!
current
)
)
{
MOZ_ASSERT
(
!
mNextChunks
"
There
shouldn
'
t
be
next
chunks
when
there
is
no
current
one
"
)
;
Unused
<
<
HandleRequestedChunk_IsPending
(
aLock
)
;
current
=
mCurrentChunk
.
get
(
)
;
if
(
MOZ_UNLIKELY
(
!
current
)
)
{
SetAndInitializeCurrentChunk
(
mChunkManager
-
>
GetChunk
(
)
aLock
)
;
current
=
mCurrentChunk
.
get
(
)
;
}
}
return
current
;
}
[
[
nodiscard
]
]
ProfileBufferChunk
*
GetOrCreateNextChunk
(
const
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
&
aLock
)
{
MOZ_ASSERT
(
!
!
mCurrentChunk
"
Why
ask
for
a
next
chunk
when
there
isn
'
t
even
a
current
one
?
"
)
;
ProfileBufferChunk
*
next
=
mNextChunks
.
get
(
)
;
if
(
MOZ_UNLIKELY
(
!
next
)
)
{
Unused
<
<
HandleRequestedChunk_IsPending
(
aLock
)
;
next
=
mNextChunks
.
get
(
)
;
if
(
MOZ_UNLIKELY
(
!
next
)
)
{
mNextChunks
=
mChunkManager
-
>
GetChunk
(
)
;
next
=
mNextChunks
.
get
(
)
;
if
(
MOZ_UNLIKELY
(
!
next
)
)
{
RequestChunk
(
aLock
)
;
}
}
}
return
next
;
}
template
<
typename
CallbackBlockBytes
typename
Callback
>
auto
ReserveAndPutRaw
(
CallbackBlockBytes
&
&
aCallbackBlockBytes
Callback
&
&
aCallback
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
&
aLock
uint64_t
aBlockCount
=
1
)
{
Maybe
<
ProfileBufferEntryWriter
>
maybeEntryWriter
;
bool
currentChunkFilled
=
false
;
bool
nextChunkInitialized
=
false
;
if
(
MOZ_LIKELY
(
mChunkManager
)
)
{
if
(
ProfileBufferChunk
*
current
=
GetOrCreateCurrentChunk
(
aLock
)
;
MOZ_LIKELY
(
current
)
)
{
const
Length
blockBytes
=
std
:
:
forward
<
CallbackBlockBytes
>
(
aCallbackBlockBytes
)
(
)
;
if
(
blockBytes
<
=
current
-
>
RemainingBytes
(
)
)
{
currentChunkFilled
=
blockBytes
=
=
current
-
>
RemainingBytes
(
)
;
const
auto
[
mem0
blockIndex
]
=
current
-
>
ReserveBlock
(
blockBytes
)
;
MOZ_ASSERT
(
mem0
.
LengthBytes
(
)
=
=
blockBytes
)
;
maybeEntryWriter
.
emplace
(
mem0
blockIndex
ProfileBufferBlockIndex
:
:
CreateFromProfileBufferIndex
(
blockIndex
.
ConvertToProfileBufferIndex
(
)
+
blockBytes
)
)
;
MOZ_ASSERT
(
maybeEntryWriter
-
>
RemainingBytes
(
)
=
=
blockBytes
)
;
mRangeEnd
+
=
blockBytes
;
mPushedBlockCount
+
=
aBlockCount
;
}
else
{
if
(
ProfileBufferChunk
*
next
=
GetOrCreateNextChunk
(
aLock
)
;
MOZ_LIKELY
(
next
)
)
{
const
auto
[
mem0
blockIndex
]
=
current
-
>
ReserveBlock
(
current
-
>
RemainingBytes
(
)
)
;
MOZ_ASSERT
(
mem0
.
LengthBytes
(
)
<
blockBytes
)
;
MOZ_ASSERT
(
current
-
>
RemainingBytes
(
)
=
=
0
)
;
next
-
>
SetRangeStart
(
mNextChunkRangeStart
)
;
mNextChunkRangeStart
+
=
next
-
>
BufferBytes
(
)
;
const
auto
mem1
=
next
-
>
ReserveInitialBlockAsTail
(
blockBytes
-
mem0
.
LengthBytes
(
)
)
;
MOZ_ASSERT
(
next
-
>
RemainingBytes
(
)
!
=
0
)
;
currentChunkFilled
=
true
;
nextChunkInitialized
=
true
;
maybeEntryWriter
.
emplace
(
mem0
mem1
blockIndex
ProfileBufferBlockIndex
:
:
CreateFromProfileBufferIndex
(
blockIndex
.
ConvertToProfileBufferIndex
(
)
+
blockBytes
)
)
;
MOZ_ASSERT
(
maybeEntryWriter
-
>
RemainingBytes
(
)
=
=
blockBytes
)
;
mRangeEnd
+
=
blockBytes
;
mPushedBlockCount
+
=
aBlockCount
;
}
}
}
}
auto
handleFilledChunk
=
MakeScopeExit
(
[
&
]
(
)
{
MOZ_ASSERT
(
!
maybeEntryWriter
|
|
maybeEntryWriter
-
>
RemainingBytes
(
)
=
=
0
)
;
if
(
currentChunkFilled
)
{
UniquePtr
<
ProfileBufferChunk
>
filled
=
std
:
:
move
(
mCurrentChunk
)
;
if
(
mNextChunks
)
{
mCurrentChunk
=
std
:
:
exchange
(
mNextChunks
mNextChunks
-
>
ReleaseNext
(
)
)
;
if
(
!
nextChunkInitialized
)
{
InitializeCurrentChunk
(
aLock
)
;
}
}
filled
-
>
MarkDone
(
)
;
mChunkManager
-
>
ReleaseChunks
(
std
:
:
move
(
filled
)
)
;
if
(
!
mCurrentChunk
|
|
!
mNextChunks
)
{
RequestChunk
(
aLock
)
;
}
}
}
)
;
return
std
:
:
forward
<
Callback
>
(
aCallback
)
(
maybeEntryWriter
)
;
}
template
<
typename
Callback
>
auto
ReserveAndPutRaw
(
Length
aBlockBytes
Callback
&
&
aCallback
uint64_t
aBlockCount
)
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
return
ReserveAndPutRaw
(
[
aBlockBytes
]
(
)
{
return
aBlockBytes
;
}
std
:
:
forward
<
Callback
>
(
aCallback
)
lock
aBlockCount
)
;
}
mutable
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeMutex
mMutex
;
ProfileBufferChunkManager
*
mChunkManager
=
nullptr
;
UniquePtr
<
ProfileBufferChunkManager
>
mOwnedChunkManager
;
UniquePtr
<
ProfileBufferChunk
>
mCurrentChunk
;
UniquePtr
<
ProfileBufferChunk
>
mNextChunks
;
class
RequestedChunkRefCountedHolder
:
public
external
:
:
AtomicRefCounted
<
RequestedChunkRefCountedHolder
>
{
public
:
MOZ_DECLARE_REFCOUNTED_TYPENAME
(
RequestedChunkRefCountedHolder
)
enum
class
State
{
Unused
Requested
Fulfilled
}
;
[
[
nodiscard
]
]
State
GetState
(
)
const
{
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
lock
(
mRequestMutex
)
;
return
mState
;
}
void
StartRequest
(
)
{
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
lock
(
mRequestMutex
)
;
MOZ_ASSERT
(
mState
=
=
State
:
:
Unused
"
Already
requested
or
fulfilled
"
)
;
mState
=
State
:
:
Requested
;
}
void
AddRequestedChunk
(
UniquePtr
<
ProfileBufferChunk
>
&
&
aChunk
)
{
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
lock
(
mRequestMutex
)
;
MOZ_ASSERT
(
mState
=
=
State
:
:
Requested
)
;
mState
=
State
:
:
Fulfilled
;
mRequestedChunk
=
std
:
:
move
(
aChunk
)
;
}
[
[
nodiscard
]
]
Maybe
<
UniquePtr
<
ProfileBufferChunk
>
>
GetChunkIfFulfilled
(
)
{
Maybe
<
UniquePtr
<
ProfileBufferChunk
>
>
maybeChunk
;
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
lock
(
mRequestMutex
)
;
MOZ_ASSERT
(
mState
=
=
State
:
:
Requested
|
|
mState
=
=
State
:
:
Fulfilled
)
;
if
(
mState
=
=
State
:
:
Fulfilled
)
{
mState
=
State
:
:
Unused
;
maybeChunk
.
emplace
(
std
:
:
move
(
mRequestedChunk
)
)
;
}
return
maybeChunk
;
}
private
:
mutable
baseprofiler
:
:
detail
:
:
BaseProfilerMutex
mRequestMutex
;
State
mState
=
State
:
:
Unused
;
UniquePtr
<
ProfileBufferChunk
>
mRequestedChunk
;
}
;
RefPtr
<
RequestedChunkRefCountedHolder
>
mRequestedChunkHolder
;
ProfileBufferIndex
mNextChunkRangeStart
=
1
;
Atomic
<
ProfileBufferIndex
MemoryOrdering
:
:
ReleaseAcquire
>
mRangeStart
{
1
}
;
ProfileBufferIndex
mRangeEnd
=
1
;
uint64_t
mPushedBlockCount
=
0
;
Atomic
<
uint64_t
MemoryOrdering
:
:
ReleaseAcquire
>
mClearedBlockCount
{
0
}
;
}
;
template
<
>
struct
ProfileBufferEntryWriter
:
:
Serializer
<
ProfileChunkedBuffer
>
{
static
Length
Bytes
(
const
ProfileChunkedBuffer
&
aBuffer
)
{
return
aBuffer
.
Read
(
[
&
]
(
ProfileChunkedBuffer
:
:
Reader
*
aReader
)
{
if
(
!
aReader
)
{
return
ULEB128Size
<
Length
>
(
0
)
;
}
ProfileBufferEntryReader
reader
=
aReader
-
>
SingleChunkDataAsEntry
(
)
;
const
ProfileBufferIndex
start
=
reader
.
CurrentBlockIndex
(
)
.
ConvertToProfileBufferIndex
(
)
;
const
ProfileBufferIndex
end
=
reader
.
NextBlockIndex
(
)
.
ConvertToProfileBufferIndex
(
)
;
MOZ_ASSERT
(
end
-
start
<
=
std
:
:
numeric_limits
<
Length
>
:
:
max
(
)
)
;
const
Length
len
=
static_cast
<
Length
>
(
end
-
start
)
;
if
(
len
=
=
0
)
{
return
ULEB128Size
<
Length
>
(
0
)
;
}
return
static_cast
<
Length
>
(
ULEB128Size
(
len
)
+
sizeof
(
start
)
+
len
+
sizeof
(
aBuffer
.
mPushedBlockCount
)
+
sizeof
(
aBuffer
.
mClearedBlockCount
)
)
;
}
)
;
}
static
void
Write
(
ProfileBufferEntryWriter
&
aEW
const
ProfileChunkedBuffer
&
aBuffer
)
{
aBuffer
.
Read
(
[
&
]
(
ProfileChunkedBuffer
:
:
Reader
*
aReader
)
{
if
(
!
aReader
)
{
aEW
.
WriteULEB128
<
Length
>
(
0
)
;
return
;
}
ProfileBufferEntryReader
reader
=
aReader
-
>
SingleChunkDataAsEntry
(
)
;
const
ProfileBufferIndex
start
=
reader
.
CurrentBlockIndex
(
)
.
ConvertToProfileBufferIndex
(
)
;
const
ProfileBufferIndex
end
=
reader
.
NextBlockIndex
(
)
.
ConvertToProfileBufferIndex
(
)
;
MOZ_ASSERT
(
end
-
start
<
=
std
:
:
numeric_limits
<
Length
>
:
:
max
(
)
)
;
const
Length
len
=
static_cast
<
Length
>
(
end
-
start
)
;
MOZ_ASSERT
(
len
<
=
aEW
.
RemainingBytes
(
)
)
;
if
(
len
=
=
0
)
{
aEW
.
WriteULEB128
<
Length
>
(
0
)
;
return
;
}
aEW
.
WriteULEB128
(
len
)
;
aEW
.
WriteObject
(
start
)
;
aEW
.
WriteFromReader
(
reader
reader
.
RemainingBytes
(
)
)
;
aEW
.
WriteObject
(
static_cast
<
uint64_t
>
(
aBuffer
.
mPushedBlockCount
)
)
;
aEW
.
WriteObject
(
static_cast
<
uint64_t
>
(
aBuffer
.
mClearedBlockCount
)
)
;
}
)
;
}
}
;
template
<
>
struct
ProfileBufferEntryReader
:
:
Deserializer
<
ProfileChunkedBuffer
>
{
static
void
ReadInto
(
ProfileBufferEntryReader
&
aER
ProfileChunkedBuffer
&
aBuffer
)
{
MOZ_ASSERT
(
aBuffer
.
GetState
(
)
.
mRangeStart
=
=
aBuffer
.
GetState
(
)
.
mRangeEnd
)
;
const
auto
len
=
aER
.
ReadULEB128
<
ProfileChunkedBuffer
:
:
Length
>
(
)
;
if
(
len
=
=
0
)
{
return
;
}
const
auto
start
=
aER
.
ReadObject
<
ProfileBufferIndex
>
(
)
;
aBuffer
.
mRangeStart
=
start
;
aBuffer
.
mRangeEnd
=
start
;
if
(
aBuffer
.
IsInSession
(
)
)
{
MOZ_RELEASE_ASSERT
(
aBuffer
.
BufferLength
(
)
.
value
(
)
>
=
len
)
;
}
else
{
aBuffer
.
SetChunkManager
(
MakeUnique
<
ProfileBufferChunkManagerSingle
>
(
len
)
)
;
MOZ_ASSERT
(
aBuffer
.
BufferLength
(
)
.
value
(
)
>
=
len
)
;
}
aBuffer
.
ReserveAndPutRaw
(
len
[
&
]
(
Maybe
<
ProfileBufferEntryWriter
>
&
aEW
)
{
MOZ_RELEASE_ASSERT
(
aEW
.
isSome
(
)
)
;
aEW
-
>
WriteFromReader
(
aER
len
)
;
}
0
)
;
aBuffer
.
mPushedBlockCount
=
aER
.
ReadObject
<
uint64_t
>
(
)
;
aBuffer
.
mClearedBlockCount
=
aER
.
ReadObject
<
uint64_t
>
(
)
;
}
static
ProfileChunkedBuffer
Read
(
ProfileBufferEntryReader
&
aER
)
=
delete
;
}
;
template
<
>
struct
ProfileBufferEntryWriter
:
:
Serializer
<
UniquePtr
<
ProfileChunkedBuffer
>
>
{
static
Length
Bytes
(
const
UniquePtr
<
ProfileChunkedBuffer
>
&
aBufferUPtr
)
{
if
(
!
aBufferUPtr
)
{
return
ULEB128Size
<
Length
>
(
0
)
;
}
return
SumBytes
(
*
aBufferUPtr
)
;
}
static
void
Write
(
ProfileBufferEntryWriter
&
aEW
const
UniquePtr
<
ProfileChunkedBuffer
>
&
aBufferUPtr
)
{
if
(
!
aBufferUPtr
)
{
aEW
.
WriteULEB128
<
Length
>
(
0
)
;
return
;
}
aEW
.
WriteObject
(
*
aBufferUPtr
)
;
}
}
;
template
<
>
struct
ProfileBufferEntryWriter
:
:
Serializer
<
ProfileChunkedBuffer
*
>
{
static
Length
Bytes
(
ProfileChunkedBuffer
*
aBufferUPtr
)
{
if
(
!
aBufferUPtr
)
{
return
ULEB128Size
<
Length
>
(
0
)
;
}
return
SumBytes
(
*
aBufferUPtr
)
;
}
static
void
Write
(
ProfileBufferEntryWriter
&
aEW
ProfileChunkedBuffer
*
aBufferUPtr
)
{
if
(
!
aBufferUPtr
)
{
aEW
.
WriteULEB128
<
Length
>
(
0
)
;
return
;
}
aEW
.
WriteObject
(
*
aBufferUPtr
)
;
}
}
;
template
<
>
struct
ProfileBufferEntryReader
:
:
Deserializer
<
UniquePtr
<
ProfileChunkedBuffer
>
>
{
static
void
ReadInto
(
ProfileBufferEntryReader
&
aER
UniquePtr
<
ProfileChunkedBuffer
>
&
aBuffer
)
{
aBuffer
=
Read
(
aER
)
;
}
static
UniquePtr
<
ProfileChunkedBuffer
>
Read
(
ProfileBufferEntryReader
&
aER
)
{
UniquePtr
<
ProfileChunkedBuffer
>
bufferUPtr
;
ProfileBufferEntryReader
readerBeforeLen
=
aER
;
const
auto
len
=
aER
.
ReadULEB128
<
ProfileChunkedBuffer
:
:
Length
>
(
)
;
if
(
len
=
=
0
)
{
return
bufferUPtr
;
}
bufferUPtr
=
MakeUnique
<
ProfileChunkedBuffer
>
(
ProfileChunkedBuffer
:
:
ThreadSafety
:
:
WithoutMutex
)
;
aER
=
readerBeforeLen
;
aER
.
ReadIntoObject
(
*
bufferUPtr
)
;
return
bufferUPtr
;
}
}
;
}
#
endif
