#
ifndef
ProfileChunkedBuffer_h
#
define
ProfileChunkedBuffer_h
#
include
"
mozilla
/
BaseProfilerDetail
.
h
"
#
include
"
mozilla
/
ProfileBufferChunkManager
.
h
"
#
include
"
mozilla
/
ProfileBufferEntrySerialization
.
h
"
#
include
"
mozilla
/
RefCounted
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
<
cstdio
>
#
include
<
utility
>
namespace
mozilla
{
class
ProfileChunkedBuffer
{
public
:
using
Byte
=
ProfileBufferChunk
:
:
Byte
;
using
Length
=
ProfileBufferChunk
:
:
Length
;
enum
class
ThreadSafety
{
WithoutMutex
WithMutex
}
;
explicit
ProfileChunkedBuffer
(
ThreadSafety
aThreadSafety
)
:
mMutex
(
aThreadSafety
!
=
ThreadSafety
:
:
WithoutMutex
)
{
}
ProfileChunkedBuffer
(
ThreadSafety
aThreadSafety
ProfileBufferChunkManager
&
aChunkManager
)
:
mMutex
(
aThreadSafety
!
=
ThreadSafety
:
:
WithoutMutex
)
{
SetChunkManager
(
aChunkManager
)
;
}
ProfileChunkedBuffer
(
ThreadSafety
aThreadSafety
UniquePtr
<
ProfileBufferChunkManager
>
&
&
aChunkManager
)
:
mMutex
(
aThreadSafety
!
=
ThreadSafety
:
:
WithoutMutex
)
{
SetChunkManager
(
std
:
:
move
(
aChunkManager
)
)
;
}
~
ProfileChunkedBuffer
(
)
{
ResetChunkManager
(
)
;
}
[
[
nodiscard
]
]
bool
IsThreadSafe
(
)
const
{
return
mMutex
.
IsActivated
(
)
;
}
[
[
nodiscard
]
]
bool
IsInSession
(
)
const
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
return
!
!
mChunkManager
;
}
void
ResetChunkManager
(
)
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
Unused
<
<
ResetChunkManager
(
lock
)
;
}
void
SetChunkManager
(
ProfileBufferChunkManager
&
aChunkManager
)
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
Unused
<
<
ResetChunkManager
(
lock
)
;
SetChunkManager
(
aChunkManager
lock
)
;
}
void
SetChunkManager
(
UniquePtr
<
ProfileBufferChunkManager
>
&
&
aChunkManager
)
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
Unused
<
<
ResetChunkManager
(
lock
)
;
mOwnedChunkManager
=
std
:
:
move
(
aChunkManager
)
;
if
(
mOwnedChunkManager
)
{
SetChunkManager
(
*
mOwnedChunkManager
lock
)
;
}
}
[
[
nodiscard
]
]
UniquePtr
<
ProfileBufferChunkManager
>
ExtractChunkManager
(
)
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
return
ResetChunkManager
(
lock
)
;
}
void
Clear
(
)
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
if
(
MOZ_UNLIKELY
(
!
mChunkManager
)
)
{
return
;
}
Unused
<
<
mChunkManager
-
>
GetExtantReleasedChunks
(
)
;
mRangeStart
=
mRangeEnd
=
mNextChunkRangeStart
;
mPushedBlockCount
=
0
;
mClearedBlockCount
=
0
;
if
(
mCurrentChunk
)
{
mCurrentChunk
-
>
MarkDone
(
)
;
mCurrentChunk
-
>
MarkRecycled
(
)
;
InitializeCurrentChunk
(
lock
)
;
}
}
Maybe
<
size_t
>
BufferLength
(
)
const
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
if
(
!
mChunkManager
)
{
return
Nothing
{
}
;
}
return
Some
(
mChunkManager
-
>
MaxTotalSize
(
)
)
;
}
[
[
nodiscard
]
]
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
return
SizeOfExcludingThis
(
aMallocSizeOf
lock
)
;
}
[
[
nodiscard
]
]
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
return
aMallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
aMallocSizeOf
lock
)
;
}
struct
State
{
ProfileBufferIndex
mRangeStart
=
1
;
ProfileBufferIndex
mRangeEnd
=
1
;
uint64_t
mPushedBlockCount
=
0
;
uint64_t
mClearedBlockCount
=
0
;
}
;
[
[
nodiscard
]
]
State
GetState
(
)
const
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
return
{
mRangeStart
mRangeEnd
mPushedBlockCount
mClearedBlockCount
}
;
}
template
<
typename
Callback
>
auto
LockAndRun
(
Callback
&
&
aCallback
)
const
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
return
std
:
:
forward
<
Callback
>
(
aCallback
)
(
)
;
}
template
<
typename
CallbackEntryBytes
typename
Callback
>
auto
ReserveAndPut
(
CallbackEntryBytes
&
&
aCallbackEntryBytes
Callback
&
&
aCallback
)
-
>
decltype
(
std
:
:
forward
<
Callback
>
(
aCallback
)
(
std
:
:
declval
<
ProfileBufferEntryWriter
*
>
(
)
)
)
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
Length
entryBytes
;
return
ReserveAndPutRaw
(
[
&
]
(
)
{
entryBytes
=
std
:
:
forward
<
CallbackEntryBytes
>
(
aCallbackEntryBytes
)
(
)
;
MOZ_ASSERT
(
entryBytes
!
=
0
"
Empty
entries
are
not
allowed
"
)
;
return
ULEB128Size
(
entryBytes
)
+
entryBytes
;
}
[
&
]
(
ProfileBufferEntryWriter
*
aEntryWriter
)
{
if
(
aEntryWriter
)
{
aEntryWriter
-
>
WriteULEB128
(
entryBytes
)
;
MOZ_ASSERT
(
aEntryWriter
-
>
RemainingBytes
(
)
=
=
entryBytes
)
;
}
return
std
:
:
forward
<
Callback
>
(
aCallback
)
(
aEntryWriter
)
;
}
lock
)
;
}
template
<
typename
Callback
>
auto
Put
(
Length
aEntryBytes
Callback
&
&
aCallback
)
{
return
ReserveAndPut
(
[
aEntryBytes
]
(
)
{
return
aEntryBytes
;
}
std
:
:
forward
<
Callback
>
(
aCallback
)
)
;
}
ProfileBufferBlockIndex
PutFrom
(
const
void
*
aSrc
Length
aBytes
)
{
return
ReserveAndPut
(
[
aBytes
]
(
)
{
return
aBytes
;
}
[
aSrc
aBytes
]
(
ProfileBufferEntryWriter
*
aEntryWriter
)
{
if
(
!
aEntryWriter
)
{
return
ProfileBufferBlockIndex
{
}
;
}
aEntryWriter
-
>
WriteBytes
(
aSrc
aBytes
)
;
return
aEntryWriter
-
>
CurrentBlockIndex
(
)
;
}
)
;
}
template
<
typename
.
.
.
Ts
>
ProfileBufferBlockIndex
PutObjects
(
const
Ts
&
.
.
.
aTs
)
{
static_assert
(
sizeof
.
.
.
(
Ts
)
>
0
"
PutObjects
must
be
given
at
least
one
object
.
"
)
;
return
ReserveAndPut
(
[
&
]
(
)
{
return
ProfileBufferEntryWriter
:
:
SumBytes
(
aTs
.
.
.
)
;
}
[
&
]
(
ProfileBufferEntryWriter
*
aEntryWriter
)
{
if
(
!
aEntryWriter
)
{
return
ProfileBufferBlockIndex
{
}
;
}
aEntryWriter
-
>
WriteObjects
(
aTs
.
.
.
)
;
return
aEntryWriter
-
>
CurrentBlockIndex
(
)
;
}
)
;
}
template
<
typename
T
>
ProfileBufferBlockIndex
PutObject
(
const
T
&
aOb
)
{
return
PutObjects
(
aOb
)
;
}
[
[
nodiscard
]
]
UniquePtr
<
ProfileBufferChunk
>
GetAllChunks
(
)
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
if
(
MOZ_UNLIKELY
(
!
mChunkManager
)
)
{
return
nullptr
;
}
UniquePtr
<
ProfileBufferChunk
>
chunks
=
mChunkManager
-
>
GetExtantReleasedChunks
(
)
;
Unused
<
<
HandleRequestedChunk_IsPending
(
lock
)
;
if
(
MOZ_LIKELY
(
!
!
mCurrentChunk
)
)
{
mCurrentChunk
-
>
MarkDone
(
)
;
chunks
=
ProfileBufferChunk
:
:
Join
(
std
:
:
move
(
chunks
)
std
:
:
move
(
mCurrentChunk
)
)
;
}
chunks
=
ProfileBufferChunk
:
:
Join
(
std
:
:
move
(
chunks
)
std
:
:
move
(
mNextChunks
)
)
;
mChunkManager
-
>
ForgetUnreleasedChunks
(
)
;
mRangeStart
=
mRangeEnd
=
mNextChunkRangeStart
;
return
chunks
;
}
#
ifdef
DEBUG
void
Dump
(
std
:
:
FILE
*
aFile
=
stdout
)
const
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
fprintf
(
aFile
"
ProfileChunkedBuffer
[
%
p
]
State
:
range
%
u
-
%
u
pushed
=
%
u
cleared
=
%
u
"
"
(
live
=
%
u
)
"
this
unsigned
(
mRangeStart
)
unsigned
(
mRangeEnd
)
unsigned
(
mPushedBlockCount
)
unsigned
(
mClearedBlockCount
)
unsigned
(
mPushedBlockCount
)
-
unsigned
(
mClearedBlockCount
)
)
;
if
(
MOZ_UNLIKELY
(
!
mChunkManager
)
)
{
fprintf
(
aFile
"
-
Out
-
of
-
session
\
n
"
)
;
return
;
}
fprintf
(
aFile
"
-
chunks
:
\
n
"
)
;
bool
hasChunks
=
false
;
mChunkManager
-
>
PeekExtantReleasedChunks
(
[
&
]
(
const
ProfileBufferChunk
*
aOldestChunk
)
{
for
(
const
ProfileBufferChunk
*
chunk
=
aOldestChunk
;
chunk
;
chunk
=
chunk
-
>
GetNext
(
)
)
{
fprintf
(
aFile
"
R
"
)
;
chunk
-
>
Dump
(
aFile
)
;
hasChunks
=
true
;
}
}
)
;
if
(
mCurrentChunk
)
{
fprintf
(
aFile
"
C
"
)
;
mCurrentChunk
-
>
Dump
(
aFile
)
;
hasChunks
=
true
;
}
for
(
const
ProfileBufferChunk
*
chunk
=
mNextChunks
.
get
(
)
;
chunk
;
chunk
=
chunk
-
>
GetNext
(
)
)
{
fprintf
(
aFile
"
N
"
)
;
chunk
-
>
Dump
(
aFile
)
;
hasChunks
=
true
;
}
switch
(
mRequestedChunkHolder
-
>
GetState
(
)
)
{
case
RequestedChunkRefCountedHolder
:
:
State
:
:
Unused
:
fprintf
(
aFile
"
-
No
request
pending
.
\
n
"
)
;
break
;
case
RequestedChunkRefCountedHolder
:
:
State
:
:
Requested
:
fprintf
(
aFile
"
-
Request
pending
.
\
n
"
)
;
break
;
case
RequestedChunkRefCountedHolder
:
:
State
:
:
Fulfilled
:
fprintf
(
aFile
"
-
Request
fulfilled
.
\
n
"
)
;
break
;
}
if
(
!
hasChunks
)
{
fprintf
(
aFile
"
No
chunks
.
\
n
"
)
;
}
}
#
endif
private
:
[
[
nodiscard
]
]
UniquePtr
<
ProfileBufferChunkManager
>
ResetChunkManager
(
const
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
&
)
{
UniquePtr
<
ProfileBufferChunkManager
>
chunkManager
;
if
(
mChunkManager
)
{
mRequestedChunkHolder
=
nullptr
;
mChunkManager
-
>
ForgetUnreleasedChunks
(
)
;
#
ifdef
DEBUG
mChunkManager
-
>
DeregisteredFrom
(
this
)
;
#
endif
mChunkManager
=
nullptr
;
chunkManager
=
std
:
:
move
(
mOwnedChunkManager
)
;
if
(
mCurrentChunk
)
{
mCurrentChunk
-
>
MarkDone
(
)
;
mCurrentChunk
=
nullptr
;
}
mNextChunks
=
nullptr
;
mNextChunkRangeStart
=
mRangeEnd
;
mRangeStart
=
mRangeEnd
;
mPushedBlockCount
=
0
;
mClearedBlockCount
=
0
;
}
return
chunkManager
;
}
void
SetChunkManager
(
ProfileBufferChunkManager
&
aChunkManager
const
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
&
aLock
)
{
MOZ_ASSERT
(
!
mChunkManager
)
;
mChunkManager
=
&
aChunkManager
;
#
ifdef
DEBUG
mChunkManager
-
>
RegisteredWith
(
this
)
;
#
endif
mChunkManager
-
>
SetChunkDestroyedCallback
(
[
this
]
(
const
ProfileBufferChunk
&
aChunk
)
{
for
(
;
;
)
{
ProfileBufferIndex
rangeStart
=
mRangeStart
;
if
(
MOZ_LIKELY
(
rangeStart
<
=
aChunk
.
RangeStart
(
)
)
)
{
if
(
MOZ_LIKELY
(
mRangeStart
.
compareExchange
(
rangeStart
aChunk
.
RangeStart
(
)
+
aChunk
.
BufferBytes
(
)
)
)
)
{
break
;
}
}
}
mClearedBlockCount
+
=
aChunk
.
BlockCount
(
)
;
}
)
;
SetAndInitializeCurrentChunk
(
mChunkManager
-
>
GetChunk
(
)
aLock
)
;
mRequestedChunkHolder
=
MakeRefPtr
<
RequestedChunkRefCountedHolder
>
(
)
;
RequestChunk
(
aLock
)
;
}
[
[
nodiscard
]
]
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
const
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
&
)
const
{
if
(
MOZ_UNLIKELY
(
!
mChunkManager
)
)
{
return
0
;
}
size_t
size
=
mChunkManager
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
if
(
mCurrentChunk
)
{
size
+
=
mCurrentChunk
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
if
(
mNextChunks
)
{
size
+
=
mNextChunks
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
return
size
;
}
void
InitializeCurrentChunk
(
const
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
&
)
{
MOZ_ASSERT
(
!
!
mCurrentChunk
)
;
mCurrentChunk
-
>
SetRangeStart
(
mNextChunkRangeStart
)
;
mNextChunkRangeStart
+
=
mCurrentChunk
-
>
BufferBytes
(
)
;
Unused
<
<
mCurrentChunk
-
>
ReserveInitialBlockAsTail
(
0
)
;
}
void
SetAndInitializeCurrentChunk
(
UniquePtr
<
ProfileBufferChunk
>
&
&
aChunk
const
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
&
aLock
)
{
mCurrentChunk
=
std
:
:
move
(
aChunk
)
;
if
(
mCurrentChunk
)
{
InitializeCurrentChunk
(
aLock
)
;
}
}
void
RequestChunk
(
const
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
&
aLock
)
{
if
(
HandleRequestedChunk_IsPending
(
aLock
)
)
{
return
;
}
mRequestedChunkHolder
-
>
StartRequest
(
)
;
mChunkManager
-
>
RequestChunk
(
[
requestedChunkHolder
=
RefPtr
<
RequestedChunkRefCountedHolder
>
(
mRequestedChunkHolder
)
]
(
UniquePtr
<
ProfileBufferChunk
>
aChunk
)
{
requestedChunkHolder
-
>
AddRequestedChunk
(
std
:
:
move
(
aChunk
)
)
;
}
)
;
}
[
[
nodiscard
]
]
bool
HandleRequestedChunk_IsPending
(
const
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
&
aLock
)
{
MOZ_ASSERT
(
!
!
mChunkManager
)
;
MOZ_ASSERT
(
!
!
mRequestedChunkHolder
)
;
if
(
mRequestedChunkHolder
-
>
GetState
(
)
=
=
RequestedChunkRefCountedHolder
:
:
State
:
:
Unused
)
{
return
false
;
}
Maybe
<
UniquePtr
<
ProfileBufferChunk
>
>
maybeChunk
=
mRequestedChunkHolder
-
>
GetChunkIfFulfilled
(
)
;
if
(
maybeChunk
.
isNothing
(
)
)
{
return
true
;
}
MOZ_ASSERT
(
mRequestedChunkHolder
-
>
GetState
(
)
=
=
RequestedChunkRefCountedHolder
:
:
State
:
:
Unused
)
;
UniquePtr
<
ProfileBufferChunk
>
&
chunk
=
*
maybeChunk
;
if
(
chunk
)
{
if
(
!
mCurrentChunk
)
{
SetAndInitializeCurrentChunk
(
std
:
:
move
(
chunk
)
aLock
)
;
MOZ_ASSERT
(
!
mNextChunks
)
;
RequestChunk
(
aLock
)
;
return
true
;
}
if
(
!
mNextChunks
)
{
mNextChunks
=
std
:
:
move
(
chunk
)
;
}
else
{
mNextChunks
-
>
InsertNext
(
std
:
:
move
(
chunk
)
)
;
}
}
return
false
;
}
[
[
nodiscard
]
]
ProfileBufferChunk
*
GetOrCreateCurrentChunk
(
const
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
&
aLock
)
{
ProfileBufferChunk
*
current
=
mCurrentChunk
.
get
(
)
;
if
(
MOZ_UNLIKELY
(
!
current
)
)
{
MOZ_ASSERT
(
!
mNextChunks
"
There
shouldn
'
t
be
next
chunks
when
there
is
no
current
one
"
)
;
Unused
<
<
HandleRequestedChunk_IsPending
(
aLock
)
;
current
=
mCurrentChunk
.
get
(
)
;
if
(
MOZ_UNLIKELY
(
!
current
)
)
{
SetAndInitializeCurrentChunk
(
mChunkManager
-
>
GetChunk
(
)
aLock
)
;
current
=
mCurrentChunk
.
get
(
)
;
}
}
return
current
;
}
[
[
nodiscard
]
]
ProfileBufferChunk
*
GetOrCreateNextChunk
(
const
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
&
aLock
)
{
MOZ_ASSERT
(
!
!
mCurrentChunk
"
Why
ask
for
a
next
chunk
when
there
isn
'
t
even
a
current
one
?
"
)
;
ProfileBufferChunk
*
next
=
mNextChunks
.
get
(
)
;
if
(
MOZ_UNLIKELY
(
!
next
)
)
{
Unused
<
<
HandleRequestedChunk_IsPending
(
aLock
)
;
next
=
mNextChunks
.
get
(
)
;
if
(
MOZ_UNLIKELY
(
!
next
)
)
{
mNextChunks
=
mChunkManager
-
>
GetChunk
(
)
;
next
=
mNextChunks
.
get
(
)
;
if
(
MOZ_UNLIKELY
(
!
next
)
)
{
RequestChunk
(
aLock
)
;
}
}
}
return
next
;
}
template
<
typename
CallbackBlockBytes
typename
Callback
>
auto
ReserveAndPutRaw
(
CallbackBlockBytes
&
&
aCallbackBlockBytes
Callback
&
&
aCallback
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
&
aLock
uint64_t
aBlockCount
=
1
)
{
bool
currentChunkFilled
=
false
;
bool
nextChunkInitialized
=
false
;
ProfileBufferEntryWriter
entryWriter
;
auto
handleFilledChunk
=
MakeScopeExit
(
[
&
]
(
)
{
MOZ_ASSERT
(
entryWriter
.
RemainingBytes
(
)
=
=
0
)
;
if
(
currentChunkFilled
)
{
UniquePtr
<
ProfileBufferChunk
>
filled
=
std
:
:
move
(
mCurrentChunk
)
;
if
(
mNextChunks
)
{
mCurrentChunk
=
std
:
:
exchange
(
mNextChunks
mNextChunks
-
>
ReleaseNext
(
)
)
;
if
(
!
nextChunkInitialized
)
{
InitializeCurrentChunk
(
aLock
)
;
}
}
filled
-
>
MarkDone
(
)
;
mChunkManager
-
>
ReleaseChunks
(
std
:
:
move
(
filled
)
)
;
if
(
!
mCurrentChunk
|
|
!
mNextChunks
)
{
RequestChunk
(
aLock
)
;
}
}
}
)
;
if
(
MOZ_LIKELY
(
mChunkManager
)
)
{
if
(
ProfileBufferChunk
*
current
=
GetOrCreateCurrentChunk
(
aLock
)
;
MOZ_LIKELY
(
current
)
)
{
const
Length
blockBytes
=
std
:
:
forward
<
CallbackBlockBytes
>
(
aCallbackBlockBytes
)
(
)
;
if
(
blockBytes
<
=
current
-
>
RemainingBytes
(
)
)
{
currentChunkFilled
=
blockBytes
=
=
current
-
>
RemainingBytes
(
)
;
const
auto
[
mem0
blockIndex
]
=
current
-
>
ReserveBlock
(
blockBytes
)
;
MOZ_ASSERT
(
mem0
.
LengthBytes
(
)
=
=
blockBytes
)
;
entryWriter
.
Set
(
mem0
blockIndex
ProfileBufferBlockIndex
:
:
CreateFromProfileBufferIndex
(
blockIndex
.
ConvertToProfileBufferIndex
(
)
+
blockBytes
)
)
;
}
else
{
if
(
ProfileBufferChunk
*
next
=
GetOrCreateNextChunk
(
aLock
)
;
MOZ_LIKELY
(
next
)
)
{
const
auto
[
mem0
blockIndex
]
=
current
-
>
ReserveBlock
(
current
-
>
RemainingBytes
(
)
)
;
MOZ_ASSERT
(
mem0
.
LengthBytes
(
)
<
blockBytes
)
;
MOZ_ASSERT
(
current
-
>
RemainingBytes
(
)
=
=
0
)
;
next
-
>
SetRangeStart
(
mNextChunkRangeStart
)
;
mNextChunkRangeStart
+
=
next
-
>
BufferBytes
(
)
;
const
auto
mem1
=
next
-
>
ReserveInitialBlockAsTail
(
blockBytes
-
mem0
.
LengthBytes
(
)
)
;
MOZ_ASSERT
(
next
-
>
RemainingBytes
(
)
!
=
0
)
;
currentChunkFilled
=
true
;
nextChunkInitialized
=
true
;
entryWriter
.
Set
(
mem0
mem1
blockIndex
ProfileBufferBlockIndex
:
:
CreateFromProfileBufferIndex
(
blockIndex
.
ConvertToProfileBufferIndex
(
)
+
blockBytes
)
)
;
}
}
if
(
MOZ_LIKELY
(
entryWriter
.
RemainingBytes
(
)
!
=
0
)
)
{
MOZ_ASSERT
(
entryWriter
.
RemainingBytes
(
)
=
=
blockBytes
)
;
mRangeEnd
+
=
blockBytes
;
mPushedBlockCount
+
=
aBlockCount
;
return
std
:
:
forward
<
Callback
>
(
aCallback
)
(
&
entryWriter
)
;
}
}
}
return
std
:
:
forward
<
Callback
>
(
aCallback
)
(
nullptr
)
;
}
template
<
typename
Callback
>
auto
ReserveAndPutRaw
(
Length
aBlockBytes
Callback
&
&
aCallback
uint64_t
aBlockCount
)
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
return
ReserveAndPutRaw
(
[
aBlockBytes
]
(
)
{
return
aBlockBytes
;
}
std
:
:
forward
<
Callback
>
(
aCallback
)
lock
aBlockCount
)
;
}
mutable
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeMutex
mMutex
;
ProfileBufferChunkManager
*
mChunkManager
=
nullptr
;
UniquePtr
<
ProfileBufferChunkManager
>
mOwnedChunkManager
;
UniquePtr
<
ProfileBufferChunk
>
mCurrentChunk
;
UniquePtr
<
ProfileBufferChunk
>
mNextChunks
;
class
RequestedChunkRefCountedHolder
:
public
external
:
:
AtomicRefCounted
<
RequestedChunkRefCountedHolder
>
{
public
:
MOZ_DECLARE_REFCOUNTED_TYPENAME
(
RequestedChunkRefCountedHolder
)
enum
class
State
{
Unused
Requested
Fulfilled
}
;
[
[
nodiscard
]
]
State
GetState
(
)
const
{
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
lock
(
mRequestMutex
)
;
return
mState
;
}
void
StartRequest
(
)
{
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
lock
(
mRequestMutex
)
;
MOZ_ASSERT
(
mState
=
=
State
:
:
Unused
"
Already
requested
or
fulfilled
"
)
;
mState
=
State
:
:
Requested
;
}
void
AddRequestedChunk
(
UniquePtr
<
ProfileBufferChunk
>
&
&
aChunk
)
{
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
lock
(
mRequestMutex
)
;
MOZ_ASSERT
(
mState
=
=
State
:
:
Requested
)
;
mState
=
State
:
:
Fulfilled
;
mRequestedChunk
=
std
:
:
move
(
aChunk
)
;
}
[
[
nodiscard
]
]
Maybe
<
UniquePtr
<
ProfileBufferChunk
>
>
GetChunkIfFulfilled
(
)
{
Maybe
<
UniquePtr
<
ProfileBufferChunk
>
>
maybeChunk
;
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
lock
(
mRequestMutex
)
;
MOZ_ASSERT
(
mState
=
=
State
:
:
Requested
|
|
mState
=
=
State
:
:
Fulfilled
)
;
if
(
mState
=
=
State
:
:
Fulfilled
)
{
mState
=
State
:
:
Unused
;
maybeChunk
.
emplace
(
std
:
:
move
(
mRequestedChunk
)
)
;
}
return
maybeChunk
;
}
private
:
mutable
baseprofiler
:
:
detail
:
:
BaseProfilerMutex
mRequestMutex
;
State
mState
=
State
:
:
Unused
;
UniquePtr
<
ProfileBufferChunk
>
mRequestedChunk
;
}
;
RefPtr
<
RequestedChunkRefCountedHolder
>
mRequestedChunkHolder
;
ProfileBufferIndex
mNextChunkRangeStart
=
1
;
Atomic
<
ProfileBufferIndex
MemoryOrdering
:
:
ReleaseAcquire
>
mRangeStart
{
1
}
;
ProfileBufferIndex
mRangeEnd
=
1
;
uint64_t
mPushedBlockCount
=
0
;
Atomic
<
uint64_t
MemoryOrdering
:
:
ReleaseAcquire
>
mClearedBlockCount
{
0
}
;
}
;
}
#
endif
