#
ifndef
ProfileBufferEntrySerialization_h
#
define
ProfileBufferEntrySerialization_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
leb128iterator
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
ProfileBufferIndex
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
mozilla
/
Tuple
.
h
"
#
include
"
mozilla
/
UniquePtrExtensions
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
<
string
>
#
include
<
tuple
>
namespace
mozilla
{
class
ProfileBufferEntryWriter
;
class
ProfileBufferEntryReader
{
public
:
using
Byte
=
uint8_t
;
using
Length
=
uint32_t
;
using
SpanOfConstBytes
=
Span
<
const
Byte
>
;
template
<
typename
T
>
struct
Deserializer
;
ProfileBufferEntryReader
(
)
=
default
;
ProfileBufferEntryReader
(
SpanOfConstBytes
aSpan
ProfileBufferBlockIndex
aCurrentBlockIndex
ProfileBufferBlockIndex
aNextBlockIndex
)
:
mCurrentSpan
(
aSpan
)
mNextSpanOrEmpty
(
aSpan
.
Last
(
0
)
)
mCurrentBlockIndex
(
aCurrentBlockIndex
)
mNextBlockIndex
(
aNextBlockIndex
)
{
CheckInvariants
(
)
;
}
ProfileBufferEntryReader
(
SpanOfConstBytes
aSpanHead
SpanOfConstBytes
aSpanTail
ProfileBufferBlockIndex
aCurrentBlockIndex
ProfileBufferBlockIndex
aNextBlockIndex
)
:
mCurrentSpan
(
aSpanHead
)
mNextSpanOrEmpty
(
aSpanTail
)
mCurrentBlockIndex
(
aCurrentBlockIndex
)
mNextBlockIndex
(
aNextBlockIndex
)
{
MOZ_RELEASE_ASSERT
(
!
mNextSpanOrEmpty
.
IsEmpty
(
)
)
;
if
(
MOZ_UNLIKELY
(
mCurrentSpan
.
IsEmpty
(
)
)
)
{
mCurrentSpan
=
mNextSpanOrEmpty
;
mNextSpanOrEmpty
=
mNextSpanOrEmpty
.
Last
(
0
)
;
}
CheckInvariants
(
)
;
}
ProfileBufferEntryReader
(
const
ProfileBufferEntryReader
&
)
=
default
;
ProfileBufferEntryReader
&
operator
=
(
const
ProfileBufferEntryReader
&
)
=
default
;
[
[
nodiscard
]
]
Length
RemainingBytes
(
)
const
{
return
mCurrentSpan
.
LengthBytes
(
)
+
mNextSpanOrEmpty
.
LengthBytes
(
)
;
}
void
SetRemainingBytes
(
Length
aBytes
)
{
MOZ_RELEASE_ASSERT
(
aBytes
<
=
RemainingBytes
(
)
)
;
if
(
aBytes
<
=
mCurrentSpan
.
LengthBytes
(
)
)
{
mCurrentSpan
=
mCurrentSpan
.
First
(
aBytes
)
;
mNextSpanOrEmpty
=
mCurrentSpan
.
Last
(
0
)
;
}
else
{
mNextSpanOrEmpty
=
mNextSpanOrEmpty
.
First
(
aBytes
-
mCurrentSpan
.
LengthBytes
(
)
)
;
}
}
[
[
nodiscard
]
]
ProfileBufferBlockIndex
CurrentBlockIndex
(
)
const
{
return
mCurrentBlockIndex
;
}
[
[
nodiscard
]
]
ProfileBufferBlockIndex
NextBlockIndex
(
)
const
{
return
mNextBlockIndex
;
}
[
[
nodiscard
]
]
ProfileBufferEntryReader
EmptyIteratorAtOffset
(
Length
aOffset
)
const
{
MOZ_RELEASE_ASSERT
(
aOffset
<
=
RemainingBytes
(
)
)
;
if
(
MOZ_LIKELY
(
aOffset
<
mCurrentSpan
.
LengthBytes
(
)
)
)
{
return
ProfileBufferEntryReader
(
mCurrentSpan
.
Subspan
(
aOffset
0
)
mCurrentBlockIndex
mNextBlockIndex
)
;
}
return
ProfileBufferEntryReader
(
mNextSpanOrEmpty
.
Subspan
(
aOffset
-
mCurrentSpan
.
LengthBytes
(
)
0
)
mCurrentBlockIndex
mNextBlockIndex
)
;
}
using
difference_type
=
std
:
:
make_signed_t
<
Length
>
;
using
value_type
=
Byte
;
using
pointer
=
const
Byte
*
;
using
reference
=
const
Byte
&
;
using
iterator_category
=
std
:
:
input_iterator_tag
;
[
[
nodiscard
]
]
const
Byte
&
operator
*
(
)
{
MOZ_RELEASE_ASSERT
(
mCurrentSpan
.
LengthBytes
(
)
>
=
1
)
;
return
*
(
mCurrentSpan
.
Elements
(
)
)
;
}
ProfileBufferEntryReader
&
operator
+
+
(
)
{
MOZ_RELEASE_ASSERT
(
mCurrentSpan
.
LengthBytes
(
)
>
=
1
)
;
if
(
MOZ_LIKELY
(
mCurrentSpan
.
LengthBytes
(
)
>
1
)
)
{
mCurrentSpan
=
mCurrentSpan
.
From
(
1
)
;
}
else
{
mCurrentSpan
=
mNextSpanOrEmpty
;
mNextSpanOrEmpty
=
mNextSpanOrEmpty
.
Last
(
0
)
;
}
CheckInvariants
(
)
;
return
*
this
;
}
ProfileBufferEntryReader
&
operator
+
=
(
Length
aBytes
)
{
MOZ_RELEASE_ASSERT
(
aBytes
<
=
RemainingBytes
(
)
)
;
if
(
MOZ_LIKELY
(
aBytes
<
=
mCurrentSpan
.
LengthBytes
(
)
)
)
{
mCurrentSpan
=
mCurrentSpan
.
From
(
aBytes
)
;
if
(
mCurrentSpan
.
IsEmpty
(
)
&
&
!
mNextSpanOrEmpty
.
IsEmpty
(
)
)
{
mCurrentSpan
=
mNextSpanOrEmpty
;
mNextSpanOrEmpty
=
mNextSpanOrEmpty
.
Last
(
0
)
;
}
}
else
{
const
Length
tail
=
aBytes
-
static_cast
<
Length
>
(
mCurrentSpan
.
LengthBytes
(
)
)
;
mCurrentSpan
=
mNextSpanOrEmpty
.
From
(
tail
)
;
mNextSpanOrEmpty
=
mNextSpanOrEmpty
.
Last
(
0
)
;
}
CheckInvariants
(
)
;
return
*
this
;
}
[
[
nodiscard
]
]
bool
operator
=
=
(
const
ProfileBufferEntryReader
&
aOther
)
const
{
return
mCurrentSpan
.
Elements
(
)
=
=
aOther
.
mCurrentSpan
.
Elements
(
)
;
}
[
[
nodiscard
]
]
bool
operator
!
=
(
const
ProfileBufferEntryReader
&
aOther
)
const
{
return
mCurrentSpan
.
Elements
(
)
!
=
aOther
.
mCurrentSpan
.
Elements
(
)
;
}
template
<
typename
T
>
[
[
nodiscard
]
]
T
ReadULEB128
(
)
{
return
:
:
mozilla
:
:
ReadULEB128
<
T
>
(
*
this
)
;
}
struct
DoubleSpanOfConstBytes
{
SpanOfConstBytes
mFirstOrOnly
;
SpanOfConstBytes
mSecondOrEmpty
;
void
CheckInvariants
(
)
const
{
MOZ_ASSERT
(
mFirstOrOnly
.
IsEmpty
(
)
?
mSecondOrEmpty
.
IsEmpty
(
)
:
true
"
mSecondOrEmpty
should
not
be
the
only
span
to
contain
data
"
)
;
}
DoubleSpanOfConstBytes
(
)
:
mFirstOrOnly
(
)
mSecondOrEmpty
(
)
{
CheckInvariants
(
)
;
}
DoubleSpanOfConstBytes
(
const
Byte
*
aOnlyPointer
size_t
aOnlyLength
)
:
mFirstOrOnly
(
aOnlyPointer
aOnlyLength
)
mSecondOrEmpty
(
)
{
CheckInvariants
(
)
;
}
DoubleSpanOfConstBytes
(
const
Byte
*
aFirstPointer
size_t
aFirstLength
const
Byte
*
aSecondPointer
size_t
aSecondLength
)
:
mFirstOrOnly
(
aFirstPointer
aFirstLength
)
mSecondOrEmpty
(
aSecondPointer
aSecondLength
)
{
CheckInvariants
(
)
;
}
[
[
nodiscard
]
]
bool
IsEmpty
(
)
const
{
return
mFirstOrOnly
.
IsEmpty
(
)
;
}
[
[
nodiscard
]
]
size_t
LengthBytes
(
)
const
{
return
mFirstOrOnly
.
LengthBytes
(
)
+
mSecondOrEmpty
.
LengthBytes
(
)
;
}
void
CopyBytesTo
(
void
*
aDest
)
const
{
memcpy
(
aDest
mFirstOrOnly
.
Elements
(
)
mFirstOrOnly
.
LengthBytes
(
)
)
;
if
(
MOZ_UNLIKELY
(
!
mSecondOrEmpty
.
IsEmpty
(
)
)
)
{
memcpy
(
static_cast
<
Byte
*
>
(
aDest
)
+
mFirstOrOnly
.
LengthBytes
(
)
mSecondOrEmpty
.
Elements
(
)
mSecondOrEmpty
.
LengthBytes
(
)
)
;
}
}
[
[
nodiscard
]
]
bool
IsSingleSpan
(
)
const
{
return
mSecondOrEmpty
.
IsEmpty
(
)
;
}
}
;
[
[
nodiscard
]
]
DoubleSpanOfConstBytes
PeekSpans
(
Length
aBytes
)
const
{
MOZ_RELEASE_ASSERT
(
aBytes
<
=
RemainingBytes
(
)
)
;
if
(
MOZ_LIKELY
(
aBytes
<
=
mCurrentSpan
.
LengthBytes
(
)
)
)
{
return
DoubleSpanOfConstBytes
{
mCurrentSpan
.
Elements
(
)
aBytes
}
;
}
return
DoubleSpanOfConstBytes
{
mCurrentSpan
.
Elements
(
)
mCurrentSpan
.
LengthBytes
(
)
mNextSpanOrEmpty
.
Elements
(
)
aBytes
-
mCurrentSpan
.
LengthBytes
(
)
}
;
}
[
[
nodiscard
]
]
DoubleSpanOfConstBytes
ReadSpans
(
Length
aBytes
)
{
DoubleSpanOfConstBytes
spans
=
PeekSpans
(
aBytes
)
;
(
*
this
)
+
=
aBytes
;
return
spans
;
}
void
ReadBytes
(
void
*
aDest
Length
aBytes
)
{
DoubleSpanOfConstBytes
spans
=
ReadSpans
(
aBytes
)
;
MOZ_ASSERT
(
spans
.
LengthBytes
(
)
=
=
aBytes
)
;
spans
.
CopyBytesTo
(
aDest
)
;
}
template
<
typename
T
>
void
ReadIntoObject
(
T
&
aObject
)
{
Deserializer
<
T
>
:
:
ReadInto
(
*
this
aObject
)
;
}
template
<
typename
.
.
.
Ts
>
void
ReadIntoObjects
(
Ts
&
.
.
.
aTs
)
{
(
ReadIntoObject
(
aTs
)
.
.
.
)
;
}
template
<
typename
T
>
[
[
nodiscard
]
]
T
ReadObject
(
)
{
T
ob
=
Deserializer
<
T
>
:
:
Read
(
*
this
)
;
return
ob
;
}
private
:
friend
class
ProfileBufferEntryWriter
;
SpanOfConstBytes
mCurrentSpan
;
SpanOfConstBytes
mNextSpanOrEmpty
;
ProfileBufferBlockIndex
mCurrentBlockIndex
;
ProfileBufferBlockIndex
mNextBlockIndex
;
void
CheckInvariants
(
)
const
{
MOZ_ASSERT
(
!
mCurrentSpan
.
IsEmpty
(
)
|
|
mNextSpanOrEmpty
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
!
mNextSpanOrEmpty
.
IsEmpty
(
)
|
|
(
mNextSpanOrEmpty
=
=
mCurrentSpan
.
Last
(
0
)
)
)
;
}
}
;
class
ProfileBufferEntryWriter
{
public
:
using
Byte
=
uint8_t
;
using
Length
=
uint32_t
;
using
SpanOfBytes
=
Span
<
Byte
>
;
template
<
typename
T
>
struct
Serializer
;
ProfileBufferEntryWriter
(
)
=
default
;
ProfileBufferEntryWriter
(
SpanOfBytes
aSpan
ProfileBufferBlockIndex
aCurrentBlockIndex
ProfileBufferBlockIndex
aNextBlockIndex
)
:
mCurrentSpan
(
aSpan
)
mCurrentBlockIndex
(
aCurrentBlockIndex
)
mNextBlockIndex
(
aNextBlockIndex
)
{
}
ProfileBufferEntryWriter
(
SpanOfBytes
aSpanHead
SpanOfBytes
aSpanTail
ProfileBufferBlockIndex
aCurrentBlockIndex
ProfileBufferBlockIndex
aNextBlockIndex
)
:
mCurrentSpan
(
aSpanHead
)
mNextSpanOrEmpty
(
aSpanTail
)
mCurrentBlockIndex
(
aCurrentBlockIndex
)
mNextBlockIndex
(
aNextBlockIndex
)
{
MOZ_RELEASE_ASSERT
(
!
mCurrentSpan
.
IsEmpty
(
)
|
|
mNextSpanOrEmpty
.
IsEmpty
(
)
)
;
}
ProfileBufferEntryWriter
(
const
ProfileBufferEntryWriter
&
)
=
delete
;
ProfileBufferEntryWriter
&
operator
=
(
const
ProfileBufferEntryWriter
&
)
=
delete
;
ProfileBufferEntryWriter
(
ProfileBufferEntryWriter
&
&
)
=
delete
;
ProfileBufferEntryWriter
&
operator
=
(
ProfileBufferEntryWriter
&
&
)
=
delete
;
void
Set
(
)
{
mCurrentSpan
=
SpanOfBytes
{
}
;
mNextSpanOrEmpty
=
SpanOfBytes
{
}
;
mCurrentBlockIndex
=
nullptr
;
mNextBlockIndex
=
nullptr
;
}
void
Set
(
SpanOfBytes
aSpan
ProfileBufferBlockIndex
aCurrentBlockIndex
ProfileBufferBlockIndex
aNextBlockIndex
)
{
mCurrentSpan
=
aSpan
;
mNextSpanOrEmpty
=
SpanOfBytes
{
}
;
mCurrentBlockIndex
=
aCurrentBlockIndex
;
mNextBlockIndex
=
aNextBlockIndex
;
}
void
Set
(
SpanOfBytes
aSpan0
SpanOfBytes
aSpan1
ProfileBufferBlockIndex
aCurrentBlockIndex
ProfileBufferBlockIndex
aNextBlockIndex
)
{
mCurrentSpan
=
aSpan0
;
mNextSpanOrEmpty
=
aSpan1
;
mCurrentBlockIndex
=
aCurrentBlockIndex
;
mNextBlockIndex
=
aNextBlockIndex
;
MOZ_RELEASE_ASSERT
(
!
mCurrentSpan
.
IsEmpty
(
)
|
|
mNextSpanOrEmpty
.
IsEmpty
(
)
)
;
}
[
[
nodiscard
]
]
Length
RemainingBytes
(
)
const
{
return
mCurrentSpan
.
LengthBytes
(
)
+
mNextSpanOrEmpty
.
LengthBytes
(
)
;
}
[
[
nodiscard
]
]
ProfileBufferBlockIndex
CurrentBlockIndex
(
)
const
{
return
mCurrentBlockIndex
;
}
[
[
nodiscard
]
]
ProfileBufferBlockIndex
NextBlockIndex
(
)
const
{
return
mNextBlockIndex
;
}
using
value_type
=
Byte
;
using
pointer
=
Byte
*
;
using
reference
=
Byte
&
;
using
iterator_category
=
std
:
:
output_iterator_tag
;
[
[
nodiscard
]
]
Byte
&
operator
*
(
)
{
MOZ_RELEASE_ASSERT
(
RemainingBytes
(
)
>
=
1
)
;
return
*
(
(
MOZ_LIKELY
(
!
mCurrentSpan
.
IsEmpty
(
)
)
?
mCurrentSpan
:
mNextSpanOrEmpty
)
.
Elements
(
)
)
;
}
ProfileBufferEntryWriter
&
operator
+
+
(
)
{
if
(
MOZ_LIKELY
(
mCurrentSpan
.
LengthBytes
(
)
>
=
1
)
)
{
mCurrentSpan
=
mCurrentSpan
.
From
(
1
)
;
}
else
{
MOZ_RELEASE_ASSERT
(
mNextSpanOrEmpty
.
LengthBytes
(
)
>
=
1
)
;
mCurrentSpan
=
mNextSpanOrEmpty
.
From
(
1
)
;
mNextSpanOrEmpty
=
mNextSpanOrEmpty
.
First
(
0
)
;
}
return
*
this
;
}
ProfileBufferEntryWriter
&
operator
+
=
(
Length
aBytes
)
{
MOZ_RELEASE_ASSERT
(
aBytes
<
=
RemainingBytes
(
)
)
;
if
(
MOZ_LIKELY
(
aBytes
<
=
mCurrentSpan
.
LengthBytes
(
)
)
)
{
mCurrentSpan
=
mCurrentSpan
.
From
(
aBytes
)
;
}
else
{
const
Length
tail
=
aBytes
-
static_cast
<
Length
>
(
mCurrentSpan
.
LengthBytes
(
)
)
;
mCurrentSpan
=
mNextSpanOrEmpty
.
From
(
tail
)
;
mNextSpanOrEmpty
=
mNextSpanOrEmpty
.
First
(
0
)
;
}
return
*
this
;
}
template
<
typename
T
>
[
[
nodiscard
]
]
static
unsigned
ULEB128Size
(
T
aValue
)
{
return
:
:
mozilla
:
:
ULEB128Size
(
aValue
)
;
}
template
<
typename
T
>
void
WriteULEB128
(
T
aValue
)
{
:
:
mozilla
:
:
WriteULEB128
(
aValue
*
this
)
;
}
template
<
typename
.
.
.
Ts
>
[
[
nodiscard
]
]
static
Length
SumBytes
(
const
Ts
&
.
.
.
aTs
)
{
return
(
0
+
.
.
.
+
Serializer
<
Ts
>
:
:
Bytes
(
aTs
)
)
;
}
void
WriteBytes
(
const
void
*
aSrc
Length
aBytes
)
{
MOZ_RELEASE_ASSERT
(
aBytes
<
=
RemainingBytes
(
)
)
;
if
(
MOZ_LIKELY
(
aBytes
<
=
mCurrentSpan
.
LengthBytes
(
)
)
)
{
memcpy
(
mCurrentSpan
.
Elements
(
)
aSrc
aBytes
)
;
mCurrentSpan
=
mCurrentSpan
.
From
(
aBytes
)
;
}
else
{
memcpy
(
mCurrentSpan
.
Elements
(
)
aSrc
mCurrentSpan
.
LengthBytes
(
)
)
;
const
Length
tail
=
aBytes
-
static_cast
<
Length
>
(
mCurrentSpan
.
LengthBytes
(
)
)
;
memcpy
(
mNextSpanOrEmpty
.
Elements
(
)
reinterpret_cast
<
const
Byte
*
>
(
aSrc
)
+
mCurrentSpan
.
LengthBytes
(
)
tail
)
;
mCurrentSpan
=
mNextSpanOrEmpty
.
From
(
tail
)
;
mNextSpanOrEmpty
=
mNextSpanOrEmpty
.
First
(
0
)
;
}
}
void
WriteFromReader
(
ProfileBufferEntryReader
&
aReader
Length
aBytes
)
{
MOZ_RELEASE_ASSERT
(
aBytes
<
=
RemainingBytes
(
)
)
;
MOZ_RELEASE_ASSERT
(
aBytes
<
=
aReader
.
RemainingBytes
(
)
)
;
Length
read0
=
std
:
:
min
(
aBytes
static_cast
<
Length
>
(
aReader
.
mCurrentSpan
.
LengthBytes
(
)
)
)
;
if
(
read0
!
=
0
)
{
WriteBytes
(
aReader
.
mCurrentSpan
.
Elements
(
)
read0
)
;
}
Length
read1
=
aBytes
-
read0
;
if
(
read1
!
=
0
)
{
WriteBytes
(
aReader
.
mNextSpanOrEmpty
.
Elements
(
)
read1
)
;
}
aReader
+
=
aBytes
;
}
template
<
typename
T
>
void
WriteObject
(
const
T
&
aObject
)
{
Serializer
<
T
>
:
:
Write
(
*
this
aObject
)
;
}
template
<
typename
.
.
.
Ts
>
void
WriteObjects
(
const
Ts
&
.
.
.
aTs
)
{
(
WriteObject
(
aTs
)
.
.
.
)
;
}
private
:
SpanOfBytes
mCurrentSpan
;
SpanOfBytes
mNextSpanOrEmpty
;
ProfileBufferBlockIndex
mCurrentBlockIndex
;
ProfileBufferBlockIndex
mNextBlockIndex
;
}
;
template
<
typename
T
>
struct
ProfileBufferEntryWriter
:
:
Serializer
{
static_assert
(
std
:
:
is_trivially_copyable
<
T
>
:
:
value
"
Serializer
only
works
with
trivially
-
copyable
types
by
"
"
default
use
/
add
specialization
for
other
types
.
"
)
;
static
constexpr
Length
Bytes
(
const
T
&
)
{
return
sizeof
(
T
)
;
}
static
void
Write
(
ProfileBufferEntryWriter
&
aEW
const
T
&
aT
)
{
static_assert
(
!
std
:
:
is_pointer
<
T
>
:
:
value
"
Serializer
won
'
t
write
raw
pointers
by
default
use
"
"
WrapProfileBufferRawPointer
or
other
.
"
)
;
aEW
.
WriteBytes
(
&
aT
sizeof
(
T
)
)
;
}
}
;
template
<
typename
T
>
struct
ProfileBufferEntryReader
:
:
Deserializer
{
static_assert
(
std
:
:
is_trivially_copyable
<
T
>
:
:
value
"
Deserializer
only
works
with
trivially
-
copyable
types
by
"
"
default
use
/
add
specialization
for
other
types
.
"
)
;
static
void
ReadInto
(
ProfileBufferEntryReader
&
aER
T
&
aT
)
{
aER
.
ReadBytes
(
&
aT
sizeof
(
T
)
)
;
}
static
T
Read
(
ProfileBufferEntryReader
&
aER
)
{
T
ob
;
ReadInto
(
aER
ob
)
;
return
ob
;
}
}
;
template
<
typename
T
>
struct
ProfileBufferEntryWriter
:
:
Serializer
<
const
T
>
:
public
ProfileBufferEntryWriter
:
:
Serializer
<
T
>
{
}
;
template
<
typename
T
>
struct
ProfileBufferEntryReader
:
:
Deserializer
<
const
T
>
:
public
ProfileBufferEntryReader
:
:
Deserializer
<
T
>
{
}
;
template
<
typename
T
>
struct
ProfileBufferEntryWriter
:
:
Serializer
<
volatile
T
>
:
public
ProfileBufferEntryWriter
:
:
Serializer
<
T
>
{
}
;
template
<
typename
T
>
struct
ProfileBufferEntryReader
:
:
Deserializer
<
volatile
T
>
:
public
ProfileBufferEntryReader
:
:
Deserializer
<
T
>
{
}
;
template
<
typename
T
>
struct
ProfileBufferEntryWriter
:
:
Serializer
<
T
&
>
:
public
ProfileBufferEntryWriter
:
:
Serializer
<
T
>
{
}
;
template
<
typename
T
>
struct
ProfileBufferEntryReader
:
:
Deserializer
<
T
&
>
:
public
ProfileBufferEntryReader
:
:
Deserializer
<
T
>
{
}
;
template
<
typename
T
>
struct
ProfileBufferEntryWriter
:
:
Serializer
<
T
&
&
>
:
public
ProfileBufferEntryWriter
:
:
Serializer
<
T
>
{
}
;
template
<
typename
T
>
struct
ProfileBufferEntryReader
:
:
Deserializer
<
T
&
&
>
:
public
ProfileBufferEntryReader
:
:
Deserializer
<
T
>
{
}
;
template
<
>
struct
ProfileBufferEntryWriter
:
:
Serializer
<
ProfileBufferBlockIndex
>
{
static
constexpr
Length
Bytes
(
const
ProfileBufferBlockIndex
&
aBlockIndex
)
{
return
sizeof
(
ProfileBufferBlockIndex
)
;
}
static
void
Write
(
ProfileBufferEntryWriter
&
aEW
const
ProfileBufferBlockIndex
&
aBlockIndex
)
{
aEW
.
WriteBytes
(
&
aBlockIndex
sizeof
(
aBlockIndex
)
)
;
}
}
;
template
<
>
struct
ProfileBufferEntryReader
:
:
Deserializer
<
ProfileBufferBlockIndex
>
{
static
void
ReadInto
(
ProfileBufferEntryReader
&
aER
ProfileBufferBlockIndex
&
aBlockIndex
)
{
aER
.
ReadBytes
(
&
aBlockIndex
sizeof
(
aBlockIndex
)
)
;
}
static
ProfileBufferBlockIndex
Read
(
ProfileBufferEntryReader
&
aER
)
{
ProfileBufferBlockIndex
blockIndex
;
ReadInto
(
aER
blockIndex
)
;
return
blockIndex
;
}
}
;
template
<
size_t
NonTerminalCharacters
>
struct
ProfileBufferLiteralCStringPointer
{
const
char
*
mCString
;
}
;
template
<
size_t
CharactersIncludingTerminal
>
ProfileBufferLiteralCStringPointer
<
CharactersIncludingTerminal
-
1
>
WrapProfileBufferLiteralCStringPointer
(
const
char
(
&
aCString
)
[
CharactersIncludingTerminal
]
)
{
return
{
aCString
}
;
}
template
<
size_t
CharactersIncludingTerminal
>
struct
ProfileBufferEntryReader
:
:
Deserializer
<
ProfileBufferLiteralCStringPointer
<
CharactersIncludingTerminal
>
>
{
static
constexpr
Length
Bytes
(
const
ProfileBufferLiteralCStringPointer
<
CharactersIncludingTerminal
>
&
)
{
return
sizeof
(
const
char
*
)
;
}
static
void
Write
(
ProfileBufferEntryWriter
&
aEW
const
ProfileBufferLiteralCStringPointer
<
CharactersIncludingTerminal
>
&
aWrapper
)
{
aEW
.
WriteBytes
(
aWrapper
.
mCString
sizeof
(
aWrapper
.
mCString
)
)
;
}
}
;
struct
ProfileBufferUnownedCString
{
const
char
*
mCString
;
}
;
inline
ProfileBufferUnownedCString
WrapProfileBufferUnownedCString
(
const
char
*
aCString
)
{
return
{
aCString
}
;
}
template
<
>
struct
ProfileBufferEntryWriter
:
:
Serializer
<
ProfileBufferUnownedCString
>
{
static
Length
Bytes
(
const
ProfileBufferUnownedCString
&
aS
)
{
const
auto
len
=
strlen
(
aS
.
mCString
)
;
return
ULEB128Size
(
len
)
+
len
;
}
static
void
Write
(
ProfileBufferEntryWriter
&
aEW
const
ProfileBufferUnownedCString
&
aS
)
{
const
auto
len
=
strlen
(
aS
.
mCString
)
;
aEW
.
WriteULEB128
(
len
)
;
aEW
.
WriteBytes
(
aS
.
mCString
len
)
;
}
}
;
template
<
typename
T
>
struct
ProfileBufferRawPointer
{
T
*
mRawPointer
;
}
;
template
<
typename
T
>
ProfileBufferRawPointer
<
T
>
WrapProfileBufferRawPointer
(
T
*
aRawPointer
)
{
return
{
aRawPointer
}
;
}
template
<
typename
T
>
struct
ProfileBufferEntryWriter
:
:
Serializer
<
ProfileBufferRawPointer
<
T
>
>
{
template
<
typename
U
>
static
constexpr
Length
Bytes
(
const
U
&
)
{
return
sizeof
(
T
*
)
;
}
static
void
Write
(
ProfileBufferEntryWriter
&
aEW
const
ProfileBufferRawPointer
<
T
>
&
aWrapper
)
{
aEW
.
WriteBytes
(
&
aWrapper
.
mRawPointer
sizeof
(
aWrapper
.
mRawPointer
)
)
;
}
}
;
template
<
typename
T
>
struct
ProfileBufferEntryReader
:
:
Deserializer
<
ProfileBufferRawPointer
<
T
>
>
{
static
void
ReadInto
(
ProfileBufferEntryReader
&
aER
ProfileBufferRawPointer
<
T
>
&
aPtr
)
{
aER
.
ReadBytes
(
&
aPtr
.
mRawPointer
sizeof
(
aPtr
)
)
;
}
static
ProfileBufferRawPointer
<
T
>
Read
(
ProfileBufferEntryReader
&
aER
)
{
ProfileBufferRawPointer
<
T
>
rawPointer
;
ReadInto
(
aER
rawPointer
)
;
return
rawPointer
;
}
}
;
template
<
typename
CHAR
>
struct
ProfileBufferEntryWriter
:
:
Serializer
<
std
:
:
basic_string
<
CHAR
>
>
{
static
Length
Bytes
(
const
std
:
:
basic_string
<
CHAR
>
&
aS
)
{
const
Length
len
=
static_cast
<
Length
>
(
aS
.
length
(
)
)
;
return
ULEB128Size
(
len
)
+
len
;
}
static
void
Write
(
ProfileBufferEntryWriter
&
aEW
const
std
:
:
basic_string
<
CHAR
>
&
aS
)
{
const
Length
len
=
static_cast
<
Length
>
(
aS
.
length
(
)
)
;
aEW
.
WriteULEB128
(
len
)
;
aEW
.
WriteBytes
(
aS
.
c_str
(
)
len
*
sizeof
(
CHAR
)
)
;
}
}
;
template
<
typename
CHAR
>
struct
ProfileBufferEntryReader
:
:
Deserializer
<
std
:
:
basic_string
<
CHAR
>
>
{
static
void
ReadCharsInto
(
ProfileBufferEntryReader
&
aER
std
:
:
basic_string
<
CHAR
>
&
aS
size_t
aLength
)
{
aS
.
assign
(
aER
aER
.
EmptyIteratorAtOffset
(
aLength
)
)
;
aER
+
=
aLength
;
}
static
void
ReadInto
(
ProfileBufferEntryReader
&
aER
std
:
:
basic_string
<
CHAR
>
&
aS
)
{
ReadCharsInto
(
aER
aS
aER
.
ReadULEB128
<
typename
std
:
:
basic_string
<
CHAR
>
:
:
size_type
>
(
)
)
;
}
static
std
:
:
basic_string
<
CHAR
>
ReadChars
(
ProfileBufferEntryReader
&
aER
size_t
aLength
)
{
std
:
:
basic_string
<
CHAR
>
s
(
aER
aER
.
EmptyIteratorAtOffset
(
aLength
)
)
;
aER
+
=
aLength
;
return
s
;
}
static
std
:
:
basic_string
<
CHAR
>
Read
(
ProfileBufferEntryReader
&
aER
)
{
return
ReadChars
(
aER
aER
.
ReadULEB128
<
typename
std
:
:
basic_string
<
CHAR
>
:
:
size_type
>
(
)
)
;
}
}
;
template
<
typename
CHAR
>
struct
ProfileBufferEntryWriter
:
:
Serializer
<
UniqueFreePtr
<
CHAR
>
>
{
static
Length
Bytes
(
const
UniqueFreePtr
<
CHAR
>
&
aS
)
{
if
(
!
aS
)
{
return
ULEB128Size
(
0u
)
;
}
const
auto
bytes
=
std
:
:
char_traits
<
CHAR
>
:
:
length
(
aS
.
get
(
)
)
*
sizeof
(
CHAR
)
;
return
ULEB128Size
(
bytes
)
+
bytes
;
}
static
void
Write
(
ProfileBufferEntryWriter
&
aEW
const
UniqueFreePtr
<
CHAR
>
&
aS
)
{
if
(
!
aS
)
{
aEW
.
WriteULEB128
(
0u
)
;
return
;
}
const
auto
bytes
=
std
:
:
char_traits
<
CHAR
>
:
:
length
(
aS
.
get
(
)
)
*
sizeof
(
CHAR
)
;
aEW
.
WriteULEB128
(
bytes
)
;
aEW
.
WriteBytes
(
aS
.
get
(
)
bytes
)
;
}
}
;
template
<
typename
CHAR
>
struct
ProfileBufferEntryReader
:
:
Deserializer
<
UniqueFreePtr
<
CHAR
>
>
{
static
void
ReadInto
(
ProfileBufferEntryReader
&
aER
UniqueFreePtr
<
CHAR
>
&
aS
)
{
aS
=
Read
(
aER
)
;
}
static
UniqueFreePtr
<
CHAR
>
Read
(
ProfileBufferEntryReader
&
aER
)
{
const
auto
bytes
=
aER
.
ReadULEB128
<
size_t
>
(
)
;
using
NC_CHAR
=
std
:
:
remove_const_t
<
CHAR
>
;
NC_CHAR
*
buffer
=
static_cast
<
NC_CHAR
*
>
(
malloc
(
bytes
+
sizeof
(
NC_CHAR
)
)
)
;
aER
.
ReadBytes
(
buffer
bytes
)
;
buffer
[
bytes
/
sizeof
(
NC_CHAR
)
]
=
NC_CHAR
(
0
)
;
return
UniqueFreePtr
<
CHAR
>
(
buffer
)
;
}
}
;
template
<
typename
.
.
.
Ts
>
struct
ProfileBufferEntryWriter
:
:
Serializer
<
std
:
:
tuple
<
Ts
.
.
.
>
>
{
private
:
template
<
size_t
.
.
.
Is
>
static
Length
TupleBytes
(
const
std
:
:
tuple
<
Ts
.
.
.
>
&
aTuple
std
:
:
index_sequence
<
Is
.
.
.
>
)
{
return
(
0
+
.
.
.
+
SumBytes
(
std
:
:
get
<
Is
>
(
aTuple
)
)
)
;
}
template
<
size_t
.
.
.
Is
>
static
void
TupleWrite
(
ProfileBufferEntryWriter
&
aEW
const
std
:
:
tuple
<
Ts
.
.
.
>
&
aTuple
std
:
:
index_sequence
<
Is
.
.
.
>
)
{
(
aEW
.
WriteObject
(
std
:
:
get
<
Is
>
(
aTuple
)
)
.
.
.
)
;
}
public
:
static
Length
Bytes
(
const
std
:
:
tuple
<
Ts
.
.
.
>
&
aTuple
)
{
return
TupleBytes
(
aTuple
std
:
:
index_sequence_for
<
Ts
.
.
.
>
(
)
)
;
}
static
void
Write
(
ProfileBufferEntryWriter
&
aEW
const
std
:
:
tuple
<
Ts
.
.
.
>
&
aTuple
)
{
TupleWrite
(
aEW
aTuple
std
:
:
index_sequence_for
<
Ts
.
.
.
>
(
)
)
;
}
}
;
template
<
typename
.
.
.
Ts
>
struct
ProfileBufferEntryReader
:
:
Deserializer
<
std
:
:
tuple
<
Ts
.
.
.
>
>
{
static
void
ReadInto
(
ProfileBufferEntryReader
&
aER
std
:
:
tuple
<
Ts
.
.
.
>
&
aTuple
)
{
aER
.
ReadBytes
(
&
aTuple
Bytes
(
aTuple
)
)
;
}
static
std
:
:
tuple
<
Ts
.
.
.
>
Read
(
ProfileBufferEntryReader
&
aER
)
{
std
:
:
tuple
<
Ts
.
.
.
>
ob
;
ReadInto
(
aER
ob
)
;
return
ob
;
}
}
;
template
<
typename
.
.
.
Ts
>
struct
ProfileBufferEntryWriter
:
:
Serializer
<
Tuple
<
Ts
.
.
.
>
>
{
private
:
template
<
size_t
.
.
.
Is
>
static
Length
TupleBytes
(
const
Tuple
<
Ts
.
.
.
>
&
aTuple
std
:
:
index_sequence
<
Is
.
.
.
>
)
{
return
(
0
+
.
.
.
+
SumBytes
(
Get
<
Is
>
(
aTuple
)
)
)
;
}
template
<
size_t
.
.
.
Is
>
static
void
TupleWrite
(
ProfileBufferEntryWriter
&
aEW
const
Tuple
<
Ts
.
.
.
>
&
aTuple
std
:
:
index_sequence
<
Is
.
.
.
>
)
{
(
aEW
.
WriteObject
(
Get
<
Is
>
(
aTuple
)
)
.
.
.
)
;
}
public
:
static
Length
Bytes
(
const
Tuple
<
Ts
.
.
.
>
&
aTuple
)
{
return
TupleBytes
(
aTuple
std
:
:
index_sequence_for
<
Ts
.
.
.
>
(
)
)
;
}
static
void
Write
(
ProfileBufferEntryWriter
&
aEW
const
Tuple
<
Ts
.
.
.
>
&
aTuple
)
{
TupleWrite
(
aEW
aTuple
std
:
:
index_sequence_for
<
Ts
.
.
.
>
(
)
)
;
}
}
;
template
<
typename
.
.
.
Ts
>
struct
ProfileBufferEntryReader
:
:
Deserializer
<
Tuple
<
Ts
.
.
.
>
>
{
static
void
ReadInto
(
ProfileBufferEntryReader
&
aER
Tuple
<
Ts
.
.
.
>
&
aTuple
)
{
aER
.
ReadBytes
(
&
aTuple
Bytes
(
aTuple
)
)
;
}
static
Tuple
<
Ts
.
.
.
>
Read
(
ProfileBufferEntryReader
&
aER
)
{
Tuple
<
Ts
.
.
.
>
ob
;
ReadInto
(
aER
ob
)
;
return
ob
;
}
}
;
template
<
class
T
size_t
N
>
struct
ProfileBufferEntryWriter
:
:
Serializer
<
Span
<
T
N
>
>
{
static
Length
Bytes
(
const
Span
<
T
N
>
&
aSpan
)
{
Length
bytes
=
0
;
for
(
const
T
&
element
:
aSpan
)
{
bytes
+
=
SumBytes
(
element
)
;
}
return
bytes
;
}
static
void
Write
(
ProfileBufferEntryWriter
&
aEW
const
Span
<
T
N
>
&
aSpan
)
{
for
(
const
T
&
element
:
aSpan
)
{
aEW
.
WriteObject
(
element
)
;
}
}
}
;
template
<
class
T
size_t
N
>
struct
ProfileBufferEntryReader
:
:
Deserializer
<
Span
<
T
N
>
>
{
static
void
ReadInto
(
ProfileBufferEntryReader
&
aER
Span
<
T
N
>
&
aSpan
)
{
for
(
T
&
element
:
aSpan
)
{
aER
.
ReadIntoObject
(
element
)
;
}
}
static
Span
<
T
N
>
Read
(
ProfileBufferEntryReader
&
aER
)
=
delete
;
}
;
template
<
typename
T
>
struct
ProfileBufferEntryWriter
:
:
Serializer
<
Maybe
<
T
>
>
{
static
Length
Bytes
(
const
Maybe
<
T
>
&
aMaybe
)
{
return
aMaybe
.
isNothing
(
)
?
1
:
(
1
+
SumBytes
(
aMaybe
.
ref
(
)
)
)
;
}
static
void
Write
(
ProfileBufferEntryWriter
&
aEW
const
Maybe
<
T
>
&
aMaybe
)
{
if
(
aMaybe
.
isNothing
(
)
)
{
aEW
.
WriteObject
<
char
>
(
'
m
'
)
;
}
else
{
aEW
.
WriteObject
<
char
>
(
'
M
'
)
;
aEW
.
WriteObject
(
aMaybe
.
ref
(
)
)
;
}
}
}
;
template
<
typename
T
>
struct
ProfileBufferEntryReader
:
:
Deserializer
<
Maybe
<
T
>
>
{
static
void
ReadInto
(
ProfileBufferEntryReader
&
aER
Maybe
<
T
>
&
aMaybe
)
{
char
c
=
aER
.
ReadObject
<
char
>
(
)
;
if
(
c
=
=
'
m
'
)
{
aMaybe
.
reset
(
)
;
}
else
{
MOZ_ASSERT
(
c
=
=
'
M
'
)
;
if
(
aMaybe
.
isNothing
(
)
)
{
aMaybe
.
emplace
(
)
;
}
aER
.
ReadIntoObject
(
aMaybe
.
ref
(
)
)
;
}
}
static
Maybe
<
T
>
Read
(
ProfileBufferEntryReader
&
aER
)
{
Maybe
<
T
>
maybe
;
char
c
=
aER
.
ReadObject
<
char
>
(
)
;
MOZ_ASSERT
(
c
=
=
'
M
'
|
|
c
=
=
'
m
'
)
;
if
(
c
=
=
'
M
'
)
{
maybe
=
Some
(
T
{
}
)
;
aER
.
ReadIntoObject
(
maybe
.
ref
(
)
)
;
}
return
maybe
;
}
}
;
template
<
typename
.
.
.
Ts
>
struct
ProfileBufferEntryWriter
:
:
Serializer
<
Variant
<
Ts
.
.
.
>
>
{
public
:
static
Length
Bytes
(
const
Variant
<
Ts
.
.
.
>
&
aVariantTs
)
{
return
aVariantTs
.
match
(
[
]
(
auto
aIndex
const
auto
&
aAlternative
)
{
return
ULEB128Size
(
aIndex
)
+
SumBytes
(
aAlternative
)
;
}
)
;
}
static
void
Write
(
ProfileBufferEntryWriter
&
aEW
const
Variant
<
Ts
.
.
.
>
&
aVariantTs
)
{
aVariantTs
.
match
(
[
&
aEW
]
(
auto
aIndex
const
auto
&
aAlternative
)
{
aEW
.
WriteULEB128
(
aIndex
)
;
aEW
.
WriteObject
(
aAlternative
)
;
}
)
;
}
}
;
template
<
typename
.
.
.
Ts
>
struct
ProfileBufferEntryReader
:
:
Deserializer
<
Variant
<
Ts
.
.
.
>
>
{
private
:
template
<
size_t
I
>
static
void
VariantIReadInto
(
ProfileBufferEntryReader
&
aER
Variant
<
Ts
.
.
.
>
&
aVariantTs
unsigned
aTag
)
{
if
(
I
=
=
aTag
)
{
if
(
!
aVariantTs
.
template
is
<
I
>
(
)
)
{
aVariantTs
=
Variant
<
Ts
.
.
.
>
(
VariantIndex
<
I
>
{
}
)
;
}
aER
.
ReadIntoObject
(
aVariantTs
.
template
as
<
I
>
(
)
)
;
}
}
template
<
size_t
.
.
.
Is
>
static
void
VariantReadInto
(
ProfileBufferEntryReader
&
aER
Variant
<
Ts
.
.
.
>
&
aVariantTs
std
:
:
index_sequence
<
Is
.
.
.
>
)
{
unsigned
tag
=
aER
.
ReadULEB128
<
unsigned
>
(
)
;
(
VariantIReadInto
<
Is
>
(
aER
aVariantTs
tag
)
.
.
.
)
;
}
public
:
static
void
ReadInto
(
ProfileBufferEntryReader
&
aER
Variant
<
Ts
.
.
.
>
&
aVariantTs
)
{
VariantReadInto
(
aER
aVariantTs
std
:
:
index_sequence_for
<
Ts
.
.
.
>
(
)
)
;
}
static
Variant
<
Ts
.
.
.
>
Read
(
ProfileBufferEntryReader
&
aER
)
{
Variant
<
Ts
.
.
.
>
variant
(
VariantIndex
<
0
>
{
}
)
;
ReadInto
(
aER
variant
)
;
return
variant
;
}
}
;
}
#
endif
