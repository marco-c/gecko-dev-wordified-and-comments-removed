#
ifndef
leb128iterator_h
#
define
leb128iterator_h
#
include
<
climits
>
#
include
<
cstdint
>
#
include
<
limits
>
#
include
<
type_traits
>
namespace
mozilla
{
template
<
typename
T
>
constexpr
uint_fast8_t
ULEB128Size
(
T
aValue
)
{
static_assert
(
!
std
:
:
numeric_limits
<
T
>
:
:
is_signed
"
ULEB128Size
only
takes
unsigned
types
"
)
;
uint_fast8_t
size
=
0
;
for
(
;
;
)
{
size
+
=
1
;
aValue
>
>
=
7
;
if
(
MOZ_LIKELY
(
aValue
=
=
0
)
)
{
return
size
;
}
}
}
template
<
typename
T
>
constexpr
uint_fast8_t
ULEB128MaxSize
(
)
{
return
ULEB128Size
<
T
>
(
std
:
:
numeric_limits
<
T
>
:
:
max
(
)
)
;
}
template
<
typename
T
typename
It
>
void
WriteULEB128
(
T
aValue
It
&
aIterator
)
{
static_assert
(
!
std
:
:
numeric_limits
<
T
>
:
:
is_signed
"
WriteULEB128
only
takes
unsigned
types
"
)
;
using
IteratorValue
=
std
:
:
remove_reference_t
<
decltype
(
*
aIterator
)
>
;
static_assert
(
sizeof
(
IteratorValue
)
=
=
1
"
WriteULEB128
expects
an
iterator
to
single
bytes
"
)
;
for
(
;
;
)
{
const
uint_fast8_t
byte
=
aValue
&
0x7Fu
;
aValue
>
>
=
7
;
*
aIterator
=
static_cast
<
IteratorValue
>
(
MOZ_LIKELY
(
aValue
=
=
0
)
?
byte
:
(
byte
|
0x80u
)
)
;
+
+
aIterator
;
if
(
MOZ_LIKELY
(
aValue
=
=
0
)
)
{
return
;
}
}
}
template
<
typename
T
typename
It
>
T
ReadULEB128
(
It
&
aIterator
)
{
static_assert
(
!
std
:
:
numeric_limits
<
T
>
:
:
is_signed
"
ReadULEB128
must
return
an
unsigned
type
"
)
;
using
IteratorValue
=
std
:
:
remove_reference_t
<
decltype
(
*
aIterator
)
>
;
static_assert
(
sizeof
(
IteratorValue
)
=
=
1
"
ReadULEB128
expects
an
iterator
to
single
bytes
"
)
;
T
result
=
0
;
uint_fast8_t
shift
=
0
;
for
(
;
;
)
{
const
uint_fast8_t
byte
=
static_cast
<
uint_fast8_t
>
(
*
aIterator
)
;
+
+
aIterator
;
result
|
=
static_cast
<
T
>
(
byte
&
0x7fu
)
<
<
shift
;
if
(
MOZ_LIKELY
(
(
byte
&
0x80u
)
=
=
0
)
)
{
return
result
;
}
shift
+
=
7
;
MOZ_ASSERT
(
shift
<
CHAR_BIT
*
sizeof
(
T
)
)
;
}
}
}
#
endif
