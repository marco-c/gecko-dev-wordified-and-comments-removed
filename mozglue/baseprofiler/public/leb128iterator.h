#
ifndef
leb128iterator_h
#
define
leb128iterator_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
<
climits
>
#
include
<
cstdint
>
#
include
<
limits
>
#
include
<
type_traits
>
namespace
mozilla
{
template
<
typename
T
>
constexpr
uint_fast8_t
ULEB128Size
(
T
aValue
)
{
static_assert
(
!
std
:
:
numeric_limits
<
T
>
:
:
is_signed
"
ULEB128Size
only
takes
unsigned
types
"
)
;
uint_fast8_t
size
=
0
;
for
(
;
;
)
{
size
+
=
1
;
aValue
>
>
=
7
;
if
(
MOZ_LIKELY
(
aValue
=
=
0
)
)
{
return
size
;
}
}
}
template
<
typename
T
>
constexpr
uint_fast8_t
ULEB128MaxSize
(
)
{
return
ULEB128Size
<
T
>
(
std
:
:
numeric_limits
<
T
>
:
:
max
(
)
)
;
}
template
<
typename
T
typename
It
>
void
WriteULEB128
(
T
aValue
It
&
aIterator
)
{
static_assert
(
!
std
:
:
numeric_limits
<
T
>
:
:
is_signed
"
WriteULEB128
only
takes
unsigned
types
"
)
;
using
IteratorValue
=
std
:
:
remove_reference_t
<
decltype
(
*
aIterator
)
>
;
static_assert
(
sizeof
(
IteratorValue
)
=
=
1
"
WriteULEB128
expects
an
iterator
to
single
bytes
"
)
;
for
(
;
;
)
{
const
uint_fast8_t
byte
=
aValue
&
0x7Fu
;
aValue
>
>
=
7
;
*
aIterator
=
static_cast
<
IteratorValue
>
(
MOZ_LIKELY
(
aValue
=
=
0
)
?
byte
:
(
byte
|
0x80u
)
)
;
+
+
aIterator
;
if
(
MOZ_LIKELY
(
aValue
=
=
0
)
)
{
return
;
}
}
}
template
<
typename
T
typename
It
>
T
ReadULEB128
(
It
&
aIterator
)
{
static_assert
(
!
std
:
:
numeric_limits
<
T
>
:
:
is_signed
"
ReadULEB128
must
return
an
unsigned
type
"
)
;
using
IteratorValue
=
std
:
:
remove_reference_t
<
decltype
(
*
aIterator
)
>
;
static_assert
(
sizeof
(
IteratorValue
)
=
=
1
"
ReadULEB128
expects
an
iterator
to
single
bytes
"
)
;
T
result
=
0
;
uint_fast8_t
shift
=
0
;
for
(
;
;
)
{
const
uint_fast8_t
byte
=
static_cast
<
uint_fast8_t
>
(
*
aIterator
)
;
+
+
aIterator
;
result
|
=
static_cast
<
T
>
(
byte
&
0x7fu
)
<
<
shift
;
if
(
MOZ_LIKELY
(
(
byte
&
0x80u
)
=
=
0
)
)
{
return
result
;
}
shift
+
=
7
;
MOZ_ASSERT
(
shift
<
CHAR_BIT
*
sizeof
(
T
)
)
;
}
}
template
<
typename
T
>
class
ULEB128Reader
{
static_assert
(
!
std
:
:
numeric_limits
<
T
>
:
:
is_signed
"
ULEB128Reader
must
handle
an
unsigned
type
"
)
;
public
:
constexpr
ULEB128Reader
(
)
=
default
;
constexpr
ULEB128Reader
(
const
ULEB128Reader
&
)
=
delete
;
constexpr
ULEB128Reader
&
operator
=
(
const
ULEB128Reader
&
)
=
delete
;
[
[
nodiscard
]
]
constexpr
bool
FeedByteIsComplete
(
unsigned
aByte
)
{
MOZ_ASSERT
(
!
IsComplete
(
)
)
;
mValue
|
=
static_cast
<
T
>
(
aByte
&
0x7fu
)
<
<
mShift
;
if
(
MOZ_LIKELY
(
(
aByte
&
0x80u
)
=
=
0
)
)
{
mShift
=
mCompleteShift
;
return
true
;
}
mShift
+
=
7
;
MOZ_ASSERT
(
mShift
<
CHAR_BIT
*
sizeof
(
T
)
)
;
return
false
;
}
constexpr
void
Reset
(
)
{
mValue
=
0
;
mShift
=
0
;
}
[
[
nodiscard
]
]
constexpr
bool
IsComplete
(
)
const
{
return
mShift
=
=
mCompleteShift
;
}
[
[
nodiscard
]
]
constexpr
T
Value
(
)
const
{
MOZ_ASSERT
(
IsComplete
(
)
)
;
return
mValue
;
}
private
:
constexpr
static
unsigned
mCompleteShift
=
0x10000u
;
T
mValue
=
0
;
unsigned
mShift
=
0
;
}
;
}
#
endif
