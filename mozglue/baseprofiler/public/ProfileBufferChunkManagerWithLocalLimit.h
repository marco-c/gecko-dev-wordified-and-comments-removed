#
ifndef
ProfileBufferChunkManagerWithLocalLimit_h
#
define
ProfileBufferChunkManagerWithLocalLimit_h
#
include
"
BaseProfiler
.
h
"
#
include
"
mozilla
/
BaseProfilerDetail
.
h
"
#
include
"
mozilla
/
ProfileBufferChunkManager
.
h
"
#
include
"
mozilla
/
ProfileBufferControlledChunkManager
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
<
utility
>
namespace
mozilla
{
class
ProfileBufferChunkManagerWithLocalLimit
final
:
public
ProfileBufferChunkManager
public
ProfileBufferControlledChunkManager
{
public
:
using
Length
=
ProfileBufferChunk
:
:
Length
;
explicit
ProfileBufferChunkManagerWithLocalLimit
(
size_t
aMaxTotalBytes
Length
aChunkMinBufferBytes
)
:
mMaxTotalBytes
(
aMaxTotalBytes
)
mChunkMinBufferBytes
(
aChunkMinBufferBytes
)
{
}
~
ProfileBufferChunkManagerWithLocalLimit
(
)
{
if
(
mUpdateCallback
)
{
std
:
:
move
(
mUpdateCallback
)
(
Update
(
nullptr
)
)
;
}
}
[
[
nodiscard
]
]
size_t
MaxTotalSize
(
)
const
final
{
return
mMaxTotalBytes
;
}
[
[
nodiscard
]
]
size_t
TotalSize
(
)
const
{
return
mTotalBytes
;
}
[
[
nodiscard
]
]
UniquePtr
<
ProfileBufferChunk
>
GetChunk
(
)
final
{
AUTO_PROFILER_STATS
(
Local_GetChunk
)
;
ChunkAndUpdate
chunkAndUpdate
=
[
&
]
(
)
{
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
lock
(
mMutex
)
;
return
GetChunk
(
lock
)
;
}
(
)
;
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
lock
(
mUpdateCallbackMutex
)
;
if
(
mUpdateCallback
&
&
!
chunkAndUpdate
.
second
.
IsNotUpdate
(
)
)
{
mUpdateCallback
(
std
:
:
move
(
chunkAndUpdate
.
second
)
)
;
}
return
std
:
:
move
(
chunkAndUpdate
.
first
)
;
}
void
RequestChunk
(
std
:
:
function
<
void
(
UniquePtr
<
ProfileBufferChunk
>
)
>
&
&
aChunkReceiver
)
final
{
AUTO_PROFILER_STATS
(
Local_RequestChunk
)
;
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
lock
(
mMutex
)
;
if
(
mChunkReceiver
)
{
return
;
}
mChunkReceiver
=
std
:
:
move
(
aChunkReceiver
)
;
}
void
FulfillChunkRequests
(
)
final
{
AUTO_PROFILER_STATS
(
Local_FulfillChunkRequests
)
;
std
:
:
function
<
void
(
UniquePtr
<
ProfileBufferChunk
>
)
>
chunkReceiver
;
ChunkAndUpdate
chunkAndUpdate
=
[
&
]
(
)
-
>
ChunkAndUpdate
{
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
lock
(
mMutex
)
;
if
(
!
mChunkReceiver
)
{
return
{
}
;
}
std
:
:
swap
(
chunkReceiver
mChunkReceiver
)
;
MOZ_ASSERT
(
!
mChunkReceiver
"
mChunkReceiver
should
have
been
emptied
"
)
;
AUTO_PROFILER_STATS
(
Local_FulfillChunkRequests_GetChunk
)
;
return
GetChunk
(
lock
)
;
}
(
)
;
if
(
chunkReceiver
)
{
{
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
lock
(
mUpdateCallbackMutex
)
;
if
(
mUpdateCallback
&
&
!
chunkAndUpdate
.
second
.
IsNotUpdate
(
)
)
{
mUpdateCallback
(
std
:
:
move
(
chunkAndUpdate
.
second
)
)
;
}
}
std
:
:
move
(
chunkReceiver
)
(
std
:
:
move
(
chunkAndUpdate
.
first
)
)
;
}
}
void
ReleaseChunk
(
UniquePtr
<
ProfileBufferChunk
>
aChunk
)
final
{
if
(
!
aChunk
)
{
return
;
}
MOZ_RELEASE_ASSERT
(
!
aChunk
-
>
GetNext
(
)
"
ReleaseChunk
only
accepts
1
chunk
"
)
;
MOZ_RELEASE_ASSERT
(
!
aChunk
-
>
ChunkHeader
(
)
.
mDoneTimeStamp
.
IsNull
(
)
"
Released
chunk
should
have
a
'
Done
'
timestamp
"
)
;
Update
update
=
[
&
]
(
)
{
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
lock
(
mMutex
)
;
MOZ_ASSERT
(
mUser
"
Not
registered
yet
"
)
;
const
ProfileBufferChunk
*
const
newlyReleasedChunk
=
aChunk
.
get
(
)
;
mUnreleasedBufferBytes
-
=
aChunk
-
>
BufferBytes
(
)
;
mReleasedBufferBytes
+
=
aChunk
-
>
BufferBytes
(
)
;
if
(
!
mReleasedChunks
)
{
MOZ_ASSERT
(
mReleasedBufferBytes
=
=
aChunk
-
>
BufferBytes
(
)
)
;
mReleasedChunks
=
std
:
:
move
(
aChunk
)
;
}
else
{
const
TimeStamp
&
releasedChunkDoneTimeStamp
=
aChunk
-
>
ChunkHeader
(
)
.
mDoneTimeStamp
;
if
(
releasedChunkDoneTimeStamp
<
mReleasedChunks
-
>
ChunkHeader
(
)
.
mDoneTimeStamp
)
{
aChunk
-
>
SetLast
(
std
:
:
move
(
mReleasedChunks
)
)
;
mReleasedChunks
=
std
:
:
move
(
aChunk
)
;
}
else
{
ProfileBufferChunk
*
chunk
=
mReleasedChunks
.
get
(
)
;
for
(
;
;
)
{
ProfileBufferChunk
*
const
nextChunk
=
chunk
-
>
GetNext
(
)
;
if
(
!
nextChunk
|
|
releasedChunkDoneTimeStamp
<
nextChunk
-
>
ChunkHeader
(
)
.
mDoneTimeStamp
)
{
chunk
-
>
InsertNext
(
std
:
:
move
(
aChunk
)
)
;
break
;
}
chunk
=
nextChunk
;
}
}
}
return
Update
(
mUnreleasedBufferBytes
mReleasedBufferBytes
mReleasedChunks
.
get
(
)
newlyReleasedChunk
)
;
}
(
)
;
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
lock
(
mUpdateCallbackMutex
)
;
if
(
mUpdateCallback
&
&
!
update
.
IsNotUpdate
(
)
)
{
mUpdateCallback
(
std
:
:
move
(
update
)
)
;
}
}
void
SetChunkDestroyedCallback
(
std
:
:
function
<
void
(
const
ProfileBufferChunk
&
)
>
&
&
aChunkDestroyedCallback
)
final
{
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
lock
(
mMutex
)
;
MOZ_ASSERT
(
mUser
"
Not
registered
yet
"
)
;
mChunkDestroyedCallback
=
std
:
:
move
(
aChunkDestroyedCallback
)
;
}
[
[
nodiscard
]
]
UniquePtr
<
ProfileBufferChunk
>
GetExtantReleasedChunks
(
)
final
{
UniquePtr
<
ProfileBufferChunk
>
chunks
;
size_t
unreleasedBufferBytes
=
[
&
]
(
)
{
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
lock
(
mMutex
)
;
MOZ_ASSERT
(
mUser
"
Not
registered
yet
"
)
;
mReleasedBufferBytes
=
0
;
chunks
=
std
:
:
move
(
mReleasedChunks
)
;
return
mUnreleasedBufferBytes
;
}
(
)
;
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
lock
(
mUpdateCallbackMutex
)
;
if
(
mUpdateCallback
)
{
mUpdateCallback
(
Update
(
unreleasedBufferBytes
0
nullptr
nullptr
)
)
;
}
return
chunks
;
}
void
ForgetUnreleasedChunks
(
)
final
{
Update
update
=
[
&
]
(
)
{
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
lock
(
mMutex
)
;
MOZ_ASSERT
(
mUser
"
Not
registered
yet
"
)
;
mUnreleasedBufferBytes
=
0
;
return
Update
(
0
mReleasedBufferBytes
mReleasedChunks
.
get
(
)
nullptr
)
;
}
(
)
;
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
lock
(
mUpdateCallbackMutex
)
;
if
(
mUpdateCallback
)
{
mUpdateCallback
(
std
:
:
move
(
update
)
)
;
}
}
[
[
nodiscard
]
]
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
final
{
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
lock
(
mMutex
)
;
return
SizeOfExcludingThis
(
aMallocSizeOf
lock
)
;
}
[
[
nodiscard
]
]
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
final
{
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
lock
(
mMutex
)
;
MOZ_ASSERT
(
mUser
"
Not
registered
yet
"
)
;
return
aMallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
aMallocSizeOf
lock
)
;
}
void
SetUpdateCallback
(
UpdateCallback
&
&
aUpdateCallback
)
final
{
{
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
lock
(
mUpdateCallbackMutex
)
;
if
(
mUpdateCallback
)
{
std
:
:
move
(
mUpdateCallback
)
(
Update
(
nullptr
)
)
;
mUpdateCallback
=
nullptr
;
}
}
if
(
aUpdateCallback
)
{
Update
initialUpdate
=
[
&
]
(
)
{
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
lock
(
mMutex
)
;
return
Update
(
mUnreleasedBufferBytes
mReleasedBufferBytes
mReleasedChunks
.
get
(
)
nullptr
)
;
}
(
)
;
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
lock
(
mUpdateCallbackMutex
)
;
MOZ_ASSERT
(
!
mUpdateCallback
"
Only
one
update
callback
allowed
"
)
;
mUpdateCallback
=
std
:
:
move
(
aUpdateCallback
)
;
mUpdateCallback
(
std
:
:
move
(
initialUpdate
)
)
;
}
}
void
DestroyChunksAtOrBefore
(
TimeStamp
aDoneTimeStamp
)
final
{
MOZ_ASSERT
(
!
aDoneTimeStamp
.
IsNull
(
)
)
;
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
lock
(
mMutex
)
;
for
(
;
;
)
{
if
(
!
mReleasedChunks
)
{
break
;
}
if
(
mReleasedChunks
-
>
ChunkHeader
(
)
.
mDoneTimeStamp
>
aDoneTimeStamp
)
{
break
;
}
DiscardOldestReleasedChunk
(
lock
)
;
}
}
protected
:
const
ProfileBufferChunk
*
PeekExtantReleasedChunksAndLock
(
)
final
{
mMutex
.
Lock
(
)
;
MOZ_ASSERT
(
mUser
"
Not
registered
yet
"
)
;
return
mReleasedChunks
.
get
(
)
;
}
void
UnlockAfterPeekExtantReleasedChunks
(
)
final
{
mMutex
.
Unlock
(
)
;
}
private
:
size_t
MaybeRecycleChunkAndGetDeallocatedSize
(
UniquePtr
<
ProfileBufferChunk
>
&
&
chunk
const
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
&
aLock
)
{
if
(
chunk
-
>
BufferBytes
(
)
>
=
mChunkMinBufferBytes
)
{
if
(
!
mRecycledChunks
)
{
mRecycledChunks
=
std
:
:
move
(
chunk
)
;
return
0
;
}
else
if
(
!
mRecycledChunks
-
>
GetNext
(
)
)
{
mRecycledChunks
-
>
InsertNext
(
std
:
:
move
(
chunk
)
)
;
return
0
;
}
}
return
moz_malloc_usable_size
(
chunk
.
get
(
)
)
;
}
UniquePtr
<
ProfileBufferChunk
>
TakeRecycledChunk
(
const
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
&
aLock
)
{
UniquePtr
<
ProfileBufferChunk
>
recycled
;
if
(
mRecycledChunks
)
{
recycled
=
std
:
:
exchange
(
mRecycledChunks
mRecycledChunks
-
>
ReleaseNext
(
)
)
;
recycled
-
>
MarkRecycled
(
)
;
}
return
recycled
;
}
void
DiscardOldestReleasedChunk
(
const
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
&
aLock
)
{
MOZ_ASSERT
(
!
!
mReleasedChunks
)
;
UniquePtr
<
ProfileBufferChunk
>
oldest
=
std
:
:
exchange
(
mReleasedChunks
mReleasedChunks
-
>
ReleaseNext
(
)
)
;
mReleasedBufferBytes
-
=
oldest
-
>
BufferBytes
(
)
;
if
(
mChunkDestroyedCallback
)
{
mChunkDestroyedCallback
(
*
oldest
)
;
}
mTotalBytes
-
=
MaybeRecycleChunkAndGetDeallocatedSize
(
std
:
:
move
(
oldest
)
aLock
)
;
}
using
ChunkAndUpdate
=
std
:
:
pair
<
UniquePtr
<
ProfileBufferChunk
>
Update
>
;
[
[
nodiscard
]
]
ChunkAndUpdate
GetChunk
(
const
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
&
aLock
)
{
MOZ_ASSERT
(
mUser
"
Not
registered
yet
"
)
;
while
(
mReleasedBufferBytes
+
mUnreleasedBufferBytes
+
mChunkMinBufferBytes
>
=
mMaxTotalBytes
&
&
!
!
mReleasedChunks
)
{
DiscardOldestReleasedChunk
(
aLock
)
;
}
ChunkAndUpdate
chunkAndUpdate
{
TakeRecycledChunk
(
aLock
)
Update
(
)
}
;
UniquePtr
<
ProfileBufferChunk
>
&
chunk
=
chunkAndUpdate
.
first
;
if
(
!
chunk
)
{
chunk
=
ProfileBufferChunk
:
:
Create
(
mChunkMinBufferBytes
)
;
mTotalBytes
+
=
moz_malloc_usable_size
(
chunk
.
get
(
)
)
;
}
if
(
chunk
)
{
mUnreleasedBufferBytes
+
=
chunk
-
>
BufferBytes
(
)
;
chunkAndUpdate
.
second
=
Update
(
mUnreleasedBufferBytes
mReleasedBufferBytes
mReleasedChunks
.
get
(
)
nullptr
)
;
}
return
chunkAndUpdate
;
}
[
[
nodiscard
]
]
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
const
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
&
)
const
{
MOZ_ASSERT
(
mUser
"
Not
registered
yet
"
)
;
size_t
size
=
0
;
if
(
mReleasedChunks
)
{
size
+
=
mReleasedChunks
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
if
(
mRecycledChunks
)
{
size
+
=
mRecycledChunks
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
return
size
;
}
const
size_t
mMaxTotalBytes
;
const
Length
mChunkMinBufferBytes
;
mutable
baseprofiler
:
:
detail
:
:
BaseProfilerMutex
mMutex
;
size_t
mUnreleasedBufferBytes
=
0
;
size_t
mReleasedBufferBytes
=
0
;
size_t
mTotalBytes
=
0
;
UniquePtr
<
ProfileBufferChunk
>
mReleasedChunks
;
UniquePtr
<
ProfileBufferChunk
>
mRecycledChunks
;
std
:
:
function
<
void
(
const
ProfileBufferChunk
&
)
>
mChunkDestroyedCallback
;
std
:
:
function
<
void
(
UniquePtr
<
ProfileBufferChunk
>
)
>
mChunkReceiver
;
mutable
baseprofiler
:
:
detail
:
:
BaseProfilerMutex
mUpdateCallbackMutex
;
UpdateCallback
mUpdateCallback
;
}
;
}
#
endif
