#
ifndef
ProfileBufferChunkManagerWithLocalLimit_h
#
define
ProfileBufferChunkManagerWithLocalLimit_h
#
include
"
BaseProfiler
.
h
"
#
include
"
mozilla
/
BaseProfilerDetail
.
h
"
#
include
"
mozilla
/
ProfileBufferChunkManager
.
h
"
namespace
mozilla
{
class
ProfileBufferChunkManagerWithLocalLimit
final
:
public
ProfileBufferChunkManager
{
public
:
using
Length
=
ProfileBufferChunk
:
:
Length
;
explicit
ProfileBufferChunkManagerWithLocalLimit
(
size_t
aMaxTotalBytes
Length
aChunkMinBufferBytes
)
:
mMaxTotalBytes
(
aMaxTotalBytes
)
mChunkMinBufferBytes
(
aChunkMinBufferBytes
)
{
}
[
[
nodiscard
]
]
size_t
MaxTotalSize
(
)
const
final
{
return
mMaxTotalBytes
;
}
[
[
nodiscard
]
]
UniquePtr
<
ProfileBufferChunk
>
GetChunk
(
)
final
{
AUTO_PROFILER_STATS
(
Local_GetChunk
)
;
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
lock
(
mMutex
)
;
return
GetChunk
(
lock
)
;
}
void
RequestChunk
(
std
:
:
function
<
void
(
UniquePtr
<
ProfileBufferChunk
>
)
>
&
&
aChunkReceiver
)
final
{
AUTO_PROFILER_STATS
(
Local_RequestChunk
)
;
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
lock
(
mMutex
)
;
if
(
mChunkReceiver
)
{
return
;
}
mChunkReceiver
=
std
:
:
move
(
aChunkReceiver
)
;
}
void
FulfillChunkRequests
(
)
final
{
AUTO_PROFILER_STATS
(
Local_FulfillChunkRequests
)
;
std
:
:
function
<
void
(
UniquePtr
<
ProfileBufferChunk
>
)
>
chunkReceiver
;
UniquePtr
<
ProfileBufferChunk
>
chunk
;
{
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
lock
(
mMutex
)
;
if
(
!
mChunkReceiver
)
{
return
;
}
std
:
:
swap
(
chunkReceiver
mChunkReceiver
)
;
MOZ_ASSERT
(
!
mChunkReceiver
"
mChunkReceiver
should
have
been
emptied
"
)
;
AUTO_PROFILER_STATS
(
Local_FulfillChunkRequests_GetChunk
)
;
chunk
=
GetChunk
(
lock
)
;
}
MOZ_ASSERT
(
!
!
chunkReceiver
"
chunkReceiver
shouldn
'
t
be
empty
here
"
)
;
std
:
:
move
(
chunkReceiver
)
(
std
:
:
move
(
chunk
)
)
;
}
void
ReleaseChunks
(
UniquePtr
<
ProfileBufferChunk
>
aChunks
)
final
{
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
lock
(
mMutex
)
;
MOZ_ASSERT
(
mUser
"
Not
registered
yet
"
)
;
size_t
bytes
=
0
;
for
(
const
ProfileBufferChunk
*
chunk
=
aChunks
.
get
(
)
;
chunk
;
chunk
=
chunk
-
>
GetNext
(
)
)
{
bytes
+
=
chunk
-
>
BufferBytes
(
)
;
}
mUnreleasedBufferBytes
-
=
bytes
;
if
(
!
mReleasedChunks
)
{
MOZ_ASSERT
(
mReleasedBufferBytes
=
=
0
)
;
mReleasedBufferBytes
=
bytes
;
mReleasedChunks
=
std
:
:
move
(
aChunks
)
;
}
else
{
mReleasedBufferBytes
+
=
bytes
;
mReleasedChunks
-
>
SetLast
(
std
:
:
move
(
aChunks
)
)
;
}
}
void
SetChunkDestroyedCallback
(
std
:
:
function
<
void
(
const
ProfileBufferChunk
&
)
>
&
&
aChunkDestroyedCallback
)
final
{
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
lock
(
mMutex
)
;
MOZ_ASSERT
(
mUser
"
Not
registered
yet
"
)
;
mChunkDestroyedCallback
=
std
:
:
move
(
aChunkDestroyedCallback
)
;
}
[
[
nodiscard
]
]
UniquePtr
<
ProfileBufferChunk
>
GetExtantReleasedChunks
(
)
final
{
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
lock
(
mMutex
)
;
MOZ_ASSERT
(
mUser
"
Not
registered
yet
"
)
;
mReleasedBufferBytes
=
0
;
return
std
:
:
move
(
mReleasedChunks
)
;
}
void
ForgetUnreleasedChunks
(
)
final
{
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
lock
(
mMutex
)
;
MOZ_ASSERT
(
mUser
"
Not
registered
yet
"
)
;
mUnreleasedBufferBytes
=
0
;
}
[
[
nodiscard
]
]
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
final
{
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
lock
(
mMutex
)
;
return
SizeOfExcludingThis
(
aMallocSizeOf
lock
)
;
}
[
[
nodiscard
]
]
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
final
{
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
lock
(
mMutex
)
;
MOZ_ASSERT
(
mUser
"
Not
registered
yet
"
)
;
return
aMallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
aMallocSizeOf
lock
)
;
}
protected
:
const
ProfileBufferChunk
*
PeekExtantReleasedChunksAndLock
(
)
final
{
mMutex
.
Lock
(
)
;
MOZ_ASSERT
(
mUser
"
Not
registered
yet
"
)
;
return
mReleasedChunks
.
get
(
)
;
}
void
UnlockAfterPeekExtantReleasedChunks
(
)
final
{
mMutex
.
Unlock
(
)
;
}
private
:
[
[
nodiscard
]
]
UniquePtr
<
ProfileBufferChunk
>
GetChunk
(
const
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
&
)
{
MOZ_ASSERT
(
mUser
"
Not
registered
yet
"
)
;
UniquePtr
<
ProfileBufferChunk
>
chunk
;
while
(
mReleasedBufferBytes
+
mUnreleasedBufferBytes
+
mChunkMinBufferBytes
>
=
mMaxTotalBytes
&
&
mReleasedBufferBytes
!
=
0
)
{
MOZ_ASSERT
(
!
!
mReleasedChunks
)
;
UniquePtr
<
ProfileBufferChunk
>
oldest
=
std
:
:
exchange
(
mReleasedChunks
mReleasedChunks
-
>
ReleaseNext
(
)
)
;
mReleasedBufferBytes
-
=
oldest
-
>
BufferBytes
(
)
;
if
(
mChunkDestroyedCallback
)
{
mChunkDestroyedCallback
(
*
oldest
)
;
}
if
(
!
chunk
&
&
oldest
-
>
BufferBytes
(
)
>
=
mChunkMinBufferBytes
)
{
chunk
=
std
:
:
move
(
oldest
)
;
chunk
-
>
MarkRecycled
(
)
;
}
}
if
(
!
chunk
)
{
chunk
=
ProfileBufferChunk
:
:
Create
(
mChunkMinBufferBytes
)
;
}
if
(
chunk
)
{
mUnreleasedBufferBytes
+
=
chunk
-
>
BufferBytes
(
)
;
}
return
chunk
;
}
[
[
nodiscard
]
]
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
const
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
&
)
const
{
MOZ_ASSERT
(
mUser
"
Not
registered
yet
"
)
;
return
mReleasedChunks
?
mReleasedChunks
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
:
0
;
}
const
size_t
mMaxTotalBytes
;
const
Length
mChunkMinBufferBytes
;
mutable
baseprofiler
:
:
detail
:
:
BaseProfilerMutex
mMutex
;
size_t
mUnreleasedBufferBytes
=
0
;
size_t
mReleasedBufferBytes
=
0
;
UniquePtr
<
ProfileBufferChunk
>
mReleasedChunks
;
std
:
:
function
<
void
(
const
ProfileBufferChunk
&
)
>
mChunkDestroyedCallback
;
std
:
:
function
<
void
(
UniquePtr
<
ProfileBufferChunk
>
)
>
mChunkReceiver
;
}
;
}
#
endif
