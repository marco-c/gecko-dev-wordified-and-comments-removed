#
ifndef
ModuloBuffer_h
#
define
ModuloBuffer_h
#
include
"
mozilla
/
leb128iterator
.
h
"
#
include
"
mozilla
/
NotNull
.
h
"
#
include
"
mozilla
/
PowerOfTwo
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
<
limits
>
#
include
<
type_traits
>
namespace
mozilla
{
template
<
typename
OffsetT
=
uint32_t
typename
IndexT
=
uint64_t
>
class
ModuloBuffer
{
public
:
using
Byte
=
uint8_t
;
static_assert
(
sizeof
(
Byte
)
=
=
1
"
ModuloBuffer
:
:
Byte
must
be
1
byte
"
)
;
using
Offset
=
OffsetT
;
static_assert
(
!
std
:
:
numeric_limits
<
Offset
>
:
:
is_signed
"
ModuloBuffer
:
:
Offset
must
be
an
unsigned
integral
type
"
)
;
using
Length
=
Offset
;
using
Index
=
IndexT
;
static_assert
(
!
std
:
:
numeric_limits
<
Index
>
:
:
is_signed
"
ModuloBuffer
:
:
Index
must
be
an
unsigned
integral
type
"
)
;
static_assert
(
sizeof
(
Index
)
>
=
sizeof
(
Offset
)
"
ModuloBuffer
:
:
Index
size
must
>
=
Offset
"
)
;
explicit
ModuloBuffer
(
PowerOfTwo
<
Length
>
aLength
)
:
mMask
(
aLength
.
Mask
(
)
)
mBuffer
(
new
Byte
[
aLength
.
Value
(
)
]
)
{
}
PowerOfTwo
<
Length
>
BufferLength
(
)
const
{
return
PowerOfTwo
<
Length
>
(
mMask
.
MaskValue
(
)
+
1
)
;
}
template
<
bool
IsBufferConst
>
class
Iterator
{
using
ConstOrMutableBuffer
=
typename
std
:
:
conditional
<
IsBufferConst
const
ModuloBuffer
ModuloBuffer
>
:
:
type
;
public
:
Iterator
(
const
Iterator
&
aRhs
)
=
default
;
Iterator
&
operator
=
(
const
Iterator
&
aRhs
)
=
default
;
template
<
bool
IsRhsBufferConst
typename
=
std
:
:
enable_if_t
<
(
!
IsRhsBufferConst
)
&
&
IsBufferConst
>
>
MOZ_IMPLICIT
Iterator
(
const
Iterator
<
IsRhsBufferConst
>
&
aRhs
)
:
mModuloBuffer
(
aRhs
.
mModuloBuffer
)
mIndex
(
aRhs
.
mIndex
)
{
}
template
<
bool
IsRhsBufferConst
typename
=
std
:
:
enable_if_t
<
(
!
IsRhsBufferConst
)
&
&
IsBufferConst
>
>
Iterator
&
operator
=
(
const
Iterator
<
IsRhsBufferConst
>
&
aRhs
)
{
mModuloBuffer
=
aRhs
.
mModuloBuffer
;
mIndex
=
aRhs
.
mIndex
;
return
*
this
;
}
Index
CurrentIndex
(
)
const
{
return
mIndex
;
}
bool
operator
=
=
(
const
Iterator
&
aRhs
)
const
{
MOZ_ASSERT
(
mModuloBuffer
=
=
aRhs
.
mModuloBuffer
)
;
return
mIndex
=
=
aRhs
.
mIndex
;
}
bool
operator
!
=
(
const
Iterator
&
aRhs
)
const
{
MOZ_ASSERT
(
mModuloBuffer
=
=
aRhs
.
mModuloBuffer
)
;
return
mIndex
!
=
aRhs
.
mIndex
;
}
bool
operator
<
(
const
Iterator
&
aRhs
)
const
{
MOZ_ASSERT
(
mModuloBuffer
=
=
aRhs
.
mModuloBuffer
)
;
return
mIndex
<
aRhs
.
mIndex
;
}
bool
operator
<
=
(
const
Iterator
&
aRhs
)
const
{
MOZ_ASSERT
(
mModuloBuffer
=
=
aRhs
.
mModuloBuffer
)
;
return
mIndex
<
=
aRhs
.
mIndex
;
}
bool
operator
>
(
const
Iterator
&
aRhs
)
const
{
MOZ_ASSERT
(
mModuloBuffer
=
=
aRhs
.
mModuloBuffer
)
;
return
mIndex
>
aRhs
.
mIndex
;
}
bool
operator
>
=
(
const
Iterator
&
aRhs
)
const
{
MOZ_ASSERT
(
mModuloBuffer
=
=
aRhs
.
mModuloBuffer
)
;
return
mIndex
>
=
aRhs
.
mIndex
;
}
Iterator
&
operator
+
+
(
)
{
+
+
mIndex
;
return
*
this
;
}
Iterator
&
operator
-
-
(
)
{
-
-
mIndex
;
return
*
this
;
}
Iterator
&
operator
+
=
(
Length
aLength
)
{
mIndex
+
=
aLength
;
return
*
this
;
}
Iterator
operator
+
(
Length
aLength
)
const
{
return
Iterator
(
*
mModuloBuffer
mIndex
+
aLength
)
;
}
Iterator
&
operator
-
=
(
Length
aLength
)
{
mIndex
-
=
aLength
;
return
*
this
;
}
Iterator
operator
-
(
Length
aLength
)
const
{
return
Iterator
(
*
mModuloBuffer
mIndex
-
aLength
)
;
}
Index
operator
-
(
const
Iterator
&
aRef
)
const
{
MOZ_ASSERT
(
mModuloBuffer
=
=
aRef
.
mModuloBuffer
)
;
return
mIndex
-
aRef
.
mIndex
;
}
std
:
:
conditional_t
<
IsBufferConst
const
Byte
&
Byte
&
>
operator
*
(
)
const
{
return
mModuloBuffer
-
>
mBuffer
[
OffsetInBuffer
(
)
]
;
}
template
<
bool
NotIsBufferConst
=
!
IsBufferConst
>
std
:
:
enable_if_t
<
NotIsBufferConst
>
Poke
(
const
void
*
aSrc
Length
aLength
)
const
{
MOZ_ASSERT
(
aLength
<
=
mModuloBuffer
-
>
BufferLength
(
)
.
Value
(
)
)
;
Offset
offset
=
OffsetInBuffer
(
)
;
Length
remaining
=
mModuloBuffer
-
>
BufferLength
(
)
.
Value
(
)
-
offset
;
if
(
MOZ_LIKELY
(
remaining
>
=
aLength
)
)
{
memcpy
(
&
mModuloBuffer
-
>
mBuffer
[
offset
]
aSrc
aLength
)
;
}
else
{
memcpy
(
&
mModuloBuffer
-
>
mBuffer
[
offset
]
aSrc
remaining
)
;
memcpy
(
&
mModuloBuffer
-
>
mBuffer
[
0
]
static_cast
<
const
Byte
*
>
(
aSrc
)
+
remaining
(
aLength
-
remaining
)
)
;
}
}
template
<
typename
T
bool
NotIsBufferConst
=
!
IsBufferConst
>
std
:
:
enable_if_t
<
NotIsBufferConst
>
PokeObject
(
const
T
&
aObject
)
const
{
static_assert
(
std
:
:
is_trivially_copyable
<
T
>
:
:
value
"
PokeObject
<
T
>
-
T
must
be
trivially
copyable
"
)
;
return
Poke
(
&
aObject
sizeof
(
T
)
)
;
}
template
<
bool
NotIsBufferConst
=
!
IsBufferConst
>
std
:
:
enable_if_t
<
NotIsBufferConst
>
Write
(
const
void
*
aSrc
Length
aLength
)
{
Poke
(
aSrc
aLength
)
;
mIndex
+
=
aLength
;
}
template
<
typename
T
bool
NotIsBufferConst
=
!
IsBufferConst
>
std
:
:
enable_if_t
<
NotIsBufferConst
>
WriteObject
(
const
T
&
aObject
)
{
static_assert
(
std
:
:
is_trivially_copyable
<
T
>
:
:
value
"
WriteObject
<
T
>
-
T
must
be
trivially
copyable
"
)
;
return
Write
(
&
aObject
sizeof
(
T
)
)
;
}
template
<
typename
T
>
static
unsigned
ULEB128Size
(
T
aValue
)
{
return
:
:
mozilla
:
:
ULEB128Size
(
aValue
)
;
}
template
<
typename
T
bool
NotIsBufferConst
=
!
IsBufferConst
>
std
:
:
enable_if_t
<
NotIsBufferConst
>
WriteULEB128
(
T
aValue
)
{
:
:
mozilla
:
:
WriteULEB128
(
aValue
*
this
)
;
}
void
Peek
(
void
*
aDst
Length
aLength
)
const
{
MOZ_ASSERT
(
aLength
<
=
mModuloBuffer
-
>
BufferLength
(
)
.
Value
(
)
)
;
Offset
offset
=
OffsetInBuffer
(
)
;
Length
remaining
=
mModuloBuffer
-
>
BufferLength
(
)
.
Value
(
)
-
offset
;
if
(
MOZ_LIKELY
(
remaining
>
=
aLength
)
)
{
memcpy
(
aDst
&
mModuloBuffer
-
>
mBuffer
[
offset
]
aLength
)
;
}
else
{
memcpy
(
aDst
&
mModuloBuffer
-
>
mBuffer
[
offset
]
remaining
)
;
memcpy
(
static_cast
<
Byte
*
>
(
aDst
)
+
remaining
&
mModuloBuffer
-
>
mBuffer
[
0
]
(
aLength
-
remaining
)
)
;
}
}
template
<
typename
T
>
void
PeekIntoObject
(
T
&
aObject
)
const
{
static_assert
(
std
:
:
is_trivially_copyable
<
T
>
:
:
value
"
PeekIntoObject
<
T
>
-
T
must
be
trivially
copyable
"
)
;
Peek
(
&
aObject
sizeof
(
T
)
)
;
}
template
<
typename
T
>
T
PeekObject
(
)
const
{
static_assert
(
std
:
:
is_trivially_copyable
<
T
>
:
:
value
"
PeekObject
<
T
>
-
T
must
be
trivially
copyable
"
)
;
T
object
;
PeekIntoObject
(
object
)
;
return
object
;
}
void
Read
(
void
*
aDst
Length
aLength
)
{
Peek
(
aDst
aLength
)
;
mIndex
+
=
aLength
;
}
template
<
typename
T
>
void
ReadIntoObject
(
T
&
aObject
)
{
static_assert
(
std
:
:
is_trivially_copyable
<
T
>
:
:
value
"
ReadIntoObject
<
T
>
-
T
must
be
trivially
copyable
"
)
;
Read
(
&
aObject
sizeof
(
T
)
)
;
}
template
<
typename
T
>
T
ReadObject
(
)
{
static_assert
(
std
:
:
is_trivially_copyable
<
T
>
:
:
value
"
ReadObject
<
T
>
-
T
must
be
trivially
copyable
"
)
;
T
object
;
ReadIntoObject
(
object
)
;
return
object
;
}
template
<
typename
T
>
T
ReadULEB128
(
)
{
return
:
:
mozilla
:
:
ReadULEB128
<
T
>
(
*
this
)
;
}
private
:
friend
class
ModuloBuffer
;
Iterator
(
ConstOrMutableBuffer
&
aBuffer
Index
aIndex
)
:
mModuloBuffer
(
WrapNotNull
(
&
aBuffer
)
)
mIndex
(
aIndex
)
{
}
Offset
OffsetInBuffer
(
)
const
{
return
static_cast
<
Offset
>
(
mIndex
)
&
mModuloBuffer
-
>
mMask
;
}
NotNull
<
ConstOrMutableBuffer
*
>
mModuloBuffer
;
Index
mIndex
;
}
;
using
Reader
=
Iterator
<
true
>
;
using
Writer
=
Iterator
<
false
>
;
Reader
ReaderAt
(
Index
aIndex
)
const
{
return
Reader
(
*
this
aIndex
)
;
}
Writer
WriterAt
(
Index
aIndex
)
{
return
Writer
(
*
this
aIndex
)
;
}
#
ifdef
DEBUG
void
Dump
(
)
const
{
Length
len
=
BufferLength
(
)
.
Value
(
)
;
if
(
len
>
128
)
{
len
=
128
;
}
for
(
Length
i
=
0
;
i
<
len
;
+
+
i
)
{
printf
(
"
%
02x
"
mBuffer
[
i
]
)
;
}
printf
(
"
\
n
"
)
;
}
#
endif
private
:
const
PowerOfTwoMask
<
Offset
>
mMask
;
UniquePtr
<
Byte
[
]
>
mBuffer
;
}
;
}
#
endif
