#
ifndef
ModuloBuffer_h
#
define
ModuloBuffer_h
#
include
"
mozilla
/
leb128iterator
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
NotNull
.
h
"
#
include
"
mozilla
/
PowerOfTwo
.
h
"
#
include
"
mozilla
/
ProfileBufferEntrySerialization
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
<
functional
>
#
include
<
iterator
>
#
include
<
limits
>
#
include
<
type_traits
>
namespace
mozilla
{
template
<
typename
OffsetT
=
uint32_t
typename
IndexT
=
uint64_t
>
class
ModuloBuffer
{
public
:
using
Byte
=
uint8_t
;
static_assert
(
sizeof
(
Byte
)
=
=
1
"
ModuloBuffer
:
:
Byte
must
be
1
byte
"
)
;
using
Offset
=
OffsetT
;
static_assert
(
!
std
:
:
numeric_limits
<
Offset
>
:
:
is_signed
"
ModuloBuffer
:
:
Offset
must
be
an
unsigned
integral
type
"
)
;
using
Length
=
Offset
;
using
Index
=
IndexT
;
static_assert
(
!
std
:
:
numeric_limits
<
Index
>
:
:
is_signed
"
ModuloBuffer
:
:
Index
must
be
an
unsigned
integral
type
"
)
;
static_assert
(
sizeof
(
Index
)
>
=
sizeof
(
Offset
)
"
ModuloBuffer
:
:
Index
size
must
>
=
Offset
"
)
;
explicit
ModuloBuffer
(
PowerOfTwo
<
Length
>
aLength
)
:
mMask
(
aLength
.
Mask
(
)
)
mBuffer
(
WrapNotNull
(
new
Byte
[
aLength
.
Value
(
)
]
)
)
mBufferDeleter
(
[
]
(
Byte
*
aBuffer
)
{
delete
[
]
aBuffer
;
}
)
{
}
ModuloBuffer
(
UniquePtr
<
Byte
[
]
>
aExistingBuffer
PowerOfTwo
<
Length
>
aLength
)
:
mMask
(
aLength
.
Mask
(
)
)
mBuffer
(
WrapNotNull
(
aExistingBuffer
.
release
(
)
)
)
mBufferDeleter
(
[
]
(
Byte
*
aBuffer
)
{
delete
[
]
aBuffer
;
}
)
{
}
ModuloBuffer
(
Byte
*
aExternalBuffer
PowerOfTwo
<
Length
>
aLength
)
:
mMask
(
aLength
.
Mask
(
)
)
mBuffer
(
WrapNotNull
(
aExternalBuffer
)
)
{
}
ModuloBuffer
(
const
ModuloBuffer
&
aOther
)
=
delete
;
ModuloBuffer
&
operator
=
(
const
ModuloBuffer
&
aOther
)
=
delete
;
ModuloBuffer
(
ModuloBuffer
&
&
aOther
)
:
mMask
(
std
:
:
move
(
aOther
.
mMask
)
)
mBuffer
(
std
:
:
move
(
aOther
.
mBuffer
)
)
mBufferDeleter
(
std
:
:
move
(
aOther
.
mBufferDeleter
)
)
{
if
(
aOther
.
mBufferDeleter
)
{
aOther
.
mBufferDeleter
=
nullptr
;
}
}
ModuloBuffer
&
operator
=
(
ModuloBuffer
&
&
aOther
)
=
delete
;
~
ModuloBuffer
(
)
{
if
(
mBufferDeleter
)
{
mBufferDeleter
(
mBuffer
)
;
}
}
PowerOfTwo
<
Length
>
BufferLength
(
)
const
{
return
PowerOfTwo
<
Length
>
(
mMask
.
MaskValue
(
)
+
1
)
;
}
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
if
(
!
mBufferDeleter
)
{
return
0
;
}
return
aMallocSizeOf
(
mBuffer
)
;
}
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
ProfileBufferEntryReader
EntryReaderFromTo
(
Index
aStart
Index
aEnd
ProfileBufferBlockIndex
aBlockIndex
ProfileBufferBlockIndex
aNextBlockIndex
)
const
{
using
EntrySpan
=
Span
<
const
ProfileBufferEntryReader
:
:
Byte
>
;
if
(
aStart
=
=
aEnd
)
{
return
ProfileBufferEntryReader
{
}
;
}
MOZ_ASSERT
(
aEnd
-
aStart
<
=
mMask
.
MaskValue
(
)
+
1
)
;
Offset
start
=
static_cast
<
Offset
>
(
aStart
)
&
mMask
;
Offset
end
=
(
static_cast
<
Offset
>
(
aEnd
-
1
)
&
mMask
)
+
1
;
if
(
start
<
end
)
{
return
ProfileBufferEntryReader
{
EntrySpan
(
&
mBuffer
[
start
]
end
-
start
)
aBlockIndex
aNextBlockIndex
}
;
}
return
ProfileBufferEntryReader
{
EntrySpan
(
&
mBuffer
[
start
]
mMask
.
MaskValue
(
)
+
1
-
start
)
EntrySpan
(
&
mBuffer
[
0
]
end
)
aBlockIndex
aNextBlockIndex
}
;
}
ProfileBufferEntryWriter
EntryWriterFromTo
(
Index
aStart
Index
aEnd
)
const
{
using
EntrySpan
=
Span
<
ProfileBufferEntryReader
:
:
Byte
>
;
if
(
aStart
=
=
aEnd
)
{
return
ProfileBufferEntryWriter
{
}
;
}
MOZ_ASSERT
(
aEnd
-
aStart
<
=
mMask
.
MaskValue
(
)
+
1
)
;
Offset
start
=
static_cast
<
Offset
>
(
aStart
)
&
mMask
;
Offset
end
=
(
static_cast
<
Offset
>
(
aEnd
-
1
)
&
mMask
)
+
1
;
if
(
start
<
end
)
{
return
ProfileBufferEntryWriter
{
EntrySpan
(
&
mBuffer
[
start
]
end
-
start
)
ProfileBufferBlockIndex
:
:
CreateFromProfileBufferIndex
(
aStart
)
ProfileBufferBlockIndex
:
:
CreateFromProfileBufferIndex
(
aEnd
)
}
;
}
return
ProfileBufferEntryWriter
{
EntrySpan
(
&
mBuffer
[
start
]
mMask
.
MaskValue
(
)
+
1
-
start
)
EntrySpan
(
&
mBuffer
[
0
]
end
)
ProfileBufferBlockIndex
:
:
CreateFromProfileBufferIndex
(
aStart
)
ProfileBufferBlockIndex
:
:
CreateFromProfileBufferIndex
(
aEnd
)
}
;
}
template
<
bool
IsBufferConst
>
class
Iterator
{
using
ConstOrMutableBuffer
=
std
:
:
conditional_t
<
IsBufferConst
const
ModuloBuffer
ModuloBuffer
>
;
public
:
using
difference_type
=
Index
;
using
value_type
=
Byte
;
using
pointer
=
std
:
:
conditional_t
<
IsBufferConst
const
Byte
*
Byte
*
>
;
using
reference
=
std
:
:
conditional_t
<
IsBufferConst
const
Byte
&
Byte
&
>
;
using
iterator_category
=
std
:
:
random_access_iterator_tag
;
Iterator
(
const
Iterator
&
aRhs
)
=
default
;
Iterator
&
operator
=
(
const
Iterator
&
aRhs
)
=
default
;
template
<
bool
IsRhsBufferConst
typename
=
std
:
:
enable_if_t
<
(
!
IsRhsBufferConst
)
&
&
IsBufferConst
>
>
MOZ_IMPLICIT
Iterator
(
const
Iterator
<
IsRhsBufferConst
>
&
aRhs
)
:
mModuloBuffer
(
aRhs
.
mModuloBuffer
)
mIndex
(
aRhs
.
mIndex
)
{
}
template
<
bool
IsRhsBufferConst
typename
=
std
:
:
enable_if_t
<
(
!
IsRhsBufferConst
)
&
&
IsBufferConst
>
>
Iterator
&
operator
=
(
const
Iterator
<
IsRhsBufferConst
>
&
aRhs
)
{
mModuloBuffer
=
aRhs
.
mModuloBuffer
;
mIndex
=
aRhs
.
mIndex
;
return
*
this
;
}
Index
CurrentIndex
(
)
const
{
return
mIndex
;
}
bool
operator
=
=
(
const
Iterator
&
aRhs
)
const
{
MOZ_ASSERT
(
mModuloBuffer
=
=
aRhs
.
mModuloBuffer
)
;
return
mIndex
=
=
aRhs
.
mIndex
;
}
bool
operator
!
=
(
const
Iterator
&
aRhs
)
const
{
MOZ_ASSERT
(
mModuloBuffer
=
=
aRhs
.
mModuloBuffer
)
;
return
mIndex
!
=
aRhs
.
mIndex
;
}
bool
operator
<
(
const
Iterator
&
aRhs
)
const
{
MOZ_ASSERT
(
mModuloBuffer
=
=
aRhs
.
mModuloBuffer
)
;
return
mIndex
<
aRhs
.
mIndex
;
}
bool
operator
<
=
(
const
Iterator
&
aRhs
)
const
{
MOZ_ASSERT
(
mModuloBuffer
=
=
aRhs
.
mModuloBuffer
)
;
return
mIndex
<
=
aRhs
.
mIndex
;
}
bool
operator
>
(
const
Iterator
&
aRhs
)
const
{
MOZ_ASSERT
(
mModuloBuffer
=
=
aRhs
.
mModuloBuffer
)
;
return
mIndex
>
aRhs
.
mIndex
;
}
bool
operator
>
=
(
const
Iterator
&
aRhs
)
const
{
MOZ_ASSERT
(
mModuloBuffer
=
=
aRhs
.
mModuloBuffer
)
;
return
mIndex
>
=
aRhs
.
mIndex
;
}
Iterator
&
operator
+
+
(
)
{
+
+
mIndex
;
return
*
this
;
}
Iterator
operator
+
+
(
int
)
{
Iterator
here
(
*
mModuloBuffer
mIndex
)
;
+
+
mIndex
;
return
here
;
}
Iterator
&
operator
-
-
(
)
{
-
-
mIndex
;
return
*
this
;
}
Iterator
operator
-
-
(
int
)
{
Iterator
here
(
*
mModuloBuffer
mIndex
)
;
-
-
mIndex
;
return
here
;
}
Iterator
&
operator
+
=
(
Length
aLength
)
{
mIndex
+
=
aLength
;
return
*
this
;
}
Iterator
operator
+
(
Length
aLength
)
const
{
return
Iterator
(
*
mModuloBuffer
mIndex
+
aLength
)
;
}
friend
Iterator
operator
+
(
Length
aLength
const
Iterator
&
aIt
)
{
return
aIt
+
aLength
;
}
Iterator
&
operator
-
=
(
Length
aLength
)
{
mIndex
-
=
aLength
;
return
*
this
;
}
Iterator
operator
-
(
Length
aLength
)
const
{
return
Iterator
(
*
mModuloBuffer
mIndex
-
aLength
)
;
}
Index
operator
-
(
const
Iterator
&
aRef
)
const
{
MOZ_ASSERT
(
mModuloBuffer
=
=
aRef
.
mModuloBuffer
)
;
return
mIndex
-
aRef
.
mIndex
;
}
reference
operator
*
(
)
const
{
return
mModuloBuffer
-
>
mBuffer
[
OffsetInBuffer
(
)
]
;
}
reference
operator
[
]
(
Length
aLength
)
const
{
return
*
(
*
this
+
aLength
)
;
}
template
<
bool
NotIsBufferConst
=
!
IsBufferConst
>
std
:
:
enable_if_t
<
NotIsBufferConst
>
Poke
(
const
void
*
aSrc
Length
aLength
)
const
{
MOZ_ASSERT
(
aLength
<
=
mModuloBuffer
-
>
BufferLength
(
)
.
Value
(
)
)
;
Offset
offset
=
OffsetInBuffer
(
)
;
Length
remaining
=
mModuloBuffer
-
>
BufferLength
(
)
.
Value
(
)
-
offset
;
if
(
MOZ_LIKELY
(
remaining
>
=
aLength
)
)
{
memcpy
(
&
mModuloBuffer
-
>
mBuffer
[
offset
]
aSrc
aLength
)
;
}
else
{
memcpy
(
&
mModuloBuffer
-
>
mBuffer
[
offset
]
aSrc
remaining
)
;
memcpy
(
&
mModuloBuffer
-
>
mBuffer
[
0
]
static_cast
<
const
Byte
*
>
(
aSrc
)
+
remaining
(
aLength
-
remaining
)
)
;
}
}
template
<
typename
T
bool
NotIsBufferConst
=
!
IsBufferConst
>
std
:
:
enable_if_t
<
NotIsBufferConst
>
PokeObject
(
const
T
&
aObject
)
const
{
static_assert
(
std
:
:
is_trivially_copyable
<
T
>
:
:
value
"
PokeObject
<
T
>
-
T
must
be
trivially
copyable
"
)
;
return
Poke
(
&
aObject
sizeof
(
T
)
)
;
}
template
<
bool
NotIsBufferConst
=
!
IsBufferConst
>
std
:
:
enable_if_t
<
NotIsBufferConst
>
Write
(
const
void
*
aSrc
Length
aLength
)
{
Poke
(
aSrc
aLength
)
;
mIndex
+
=
aLength
;
}
template
<
typename
T
bool
NotIsBufferConst
=
!
IsBufferConst
>
std
:
:
enable_if_t
<
NotIsBufferConst
>
WriteObject
(
const
T
&
aObject
)
{
static_assert
(
std
:
:
is_trivially_copyable
<
T
>
:
:
value
"
WriteObject
<
T
>
-
T
must
be
trivially
copyable
"
)
;
return
Write
(
&
aObject
sizeof
(
T
)
)
;
}
template
<
typename
T
>
static
unsigned
ULEB128Size
(
T
aValue
)
{
return
:
:
mozilla
:
:
ULEB128Size
(
aValue
)
;
}
template
<
typename
T
bool
NotIsBufferConst
=
!
IsBufferConst
>
std
:
:
enable_if_t
<
NotIsBufferConst
>
WriteULEB128
(
T
aValue
)
{
:
:
mozilla
:
:
WriteULEB128
(
aValue
*
this
)
;
}
void
Peek
(
void
*
aDst
Length
aLength
)
const
{
MOZ_ASSERT
(
aLength
<
=
mModuloBuffer
-
>
BufferLength
(
)
.
Value
(
)
)
;
Offset
offset
=
OffsetInBuffer
(
)
;
Length
remaining
=
mModuloBuffer
-
>
BufferLength
(
)
.
Value
(
)
-
offset
;
if
(
MOZ_LIKELY
(
remaining
>
=
aLength
)
)
{
memcpy
(
aDst
&
mModuloBuffer
-
>
mBuffer
[
offset
]
aLength
)
;
}
else
{
memcpy
(
aDst
&
mModuloBuffer
-
>
mBuffer
[
offset
]
remaining
)
;
memcpy
(
static_cast
<
Byte
*
>
(
aDst
)
+
remaining
&
mModuloBuffer
-
>
mBuffer
[
0
]
(
aLength
-
remaining
)
)
;
}
}
template
<
typename
T
>
void
PeekIntoObject
(
T
&
aObject
)
const
{
static_assert
(
std
:
:
is_trivially_copyable
<
T
>
:
:
value
"
PeekIntoObject
<
T
>
-
T
must
be
trivially
copyable
"
)
;
Peek
(
&
aObject
sizeof
(
T
)
)
;
}
template
<
typename
T
>
T
PeekObject
(
)
const
{
static_assert
(
std
:
:
is_trivially_copyable
<
T
>
:
:
value
"
PeekObject
<
T
>
-
T
must
be
trivially
copyable
"
)
;
T
object
;
PeekIntoObject
(
object
)
;
return
object
;
}
void
Read
(
void
*
aDst
Length
aLength
)
{
Peek
(
aDst
aLength
)
;
mIndex
+
=
aLength
;
}
void
ReadInto
(
Iterator
<
false
>
&
aDst
Length
aLength
)
{
MOZ_ASSERT
(
aLength
<
=
mModuloBuffer
-
>
BufferLength
(
)
.
Value
(
)
)
;
MOZ_ASSERT
(
aLength
<
=
aDst
.
mModuloBuffer
-
>
BufferLength
(
)
.
Value
(
)
)
;
Offset
offset
=
OffsetInBuffer
(
)
;
Length
remaining
=
mModuloBuffer
-
>
BufferLength
(
)
.
Value
(
)
-
offset
;
if
(
MOZ_LIKELY
(
remaining
>
=
aLength
)
)
{
aDst
.
Write
(
&
mModuloBuffer
-
>
mBuffer
[
offset
]
aLength
)
;
}
else
{
aDst
.
Write
(
&
mModuloBuffer
-
>
mBuffer
[
offset
]
remaining
)
;
aDst
.
Write
(
&
mModuloBuffer
-
>
mBuffer
[
0
]
(
aLength
-
remaining
)
)
;
}
mIndex
+
=
aLength
;
}
template
<
typename
T
>
void
ReadIntoObject
(
T
&
aObject
)
{
static_assert
(
std
:
:
is_trivially_copyable
<
T
>
:
:
value
"
ReadIntoObject
<
T
>
-
T
must
be
trivially
copyable
"
)
;
Read
(
&
aObject
sizeof
(
T
)
)
;
}
template
<
typename
T
>
T
ReadObject
(
)
{
static_assert
(
std
:
:
is_trivially_copyable
<
T
>
:
:
value
"
ReadObject
<
T
>
-
T
must
be
trivially
copyable
"
)
;
T
object
;
ReadIntoObject
(
object
)
;
return
object
;
}
template
<
typename
T
>
T
ReadULEB128
(
)
{
return
:
:
mozilla
:
:
ReadULEB128
<
T
>
(
*
this
)
;
}
private
:
friend
class
ModuloBuffer
;
Iterator
(
ConstOrMutableBuffer
&
aBuffer
Index
aIndex
)
:
mModuloBuffer
(
WrapNotNull
(
&
aBuffer
)
)
mIndex
(
aIndex
)
{
}
Offset
OffsetInBuffer
(
)
const
{
return
static_cast
<
Offset
>
(
mIndex
)
&
mModuloBuffer
-
>
mMask
;
}
NotNull
<
ConstOrMutableBuffer
*
>
mModuloBuffer
;
Index
mIndex
;
}
;
using
Reader
=
Iterator
<
true
>
;
using
Writer
=
Iterator
<
false
>
;
Reader
ReaderAt
(
Index
aIndex
)
const
{
return
Reader
(
*
this
aIndex
)
;
}
Writer
WriterAt
(
Index
aIndex
)
{
return
Writer
(
*
this
aIndex
)
;
}
#
ifdef
DEBUG
void
Dump
(
)
const
{
Length
len
=
BufferLength
(
)
.
Value
(
)
;
if
(
len
>
128
)
{
len
=
128
;
}
for
(
Length
i
=
0
;
i
<
len
;
+
+
i
)
{
printf
(
"
%
02x
"
mBuffer
[
i
]
)
;
}
printf
(
"
\
n
"
)
;
}
#
endif
private
:
const
PowerOfTwoMask
<
Offset
>
mMask
;
const
NotNull
<
Byte
*
const
>
mBuffer
;
std
:
:
function
<
void
(
Byte
*
)
>
mBufferDeleter
;
}
;
}
#
endif
