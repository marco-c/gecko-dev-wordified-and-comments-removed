#
ifndef
BASEPROFILEJSONWRITER_H
#
define
BASEPROFILEJSONWRITER_H
#
include
"
BaseProfiler
.
h
"
#
ifndef
MOZ_GECKO_PROFILER
#
error
Do
not
#
include
this
header
when
MOZ_GECKO_PROFILER
is
not
#
defined
.
#
endif
#
include
"
mozilla
/
JSONWriter
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
<
functional
>
#
include
<
ostream
>
#
include
<
string
>
namespace
mozilla
{
namespace
baseprofiler
{
class
SpliceableJSONWriter
;
class
ChunkedJSONWriteFunc
final
:
public
JSONWriteFunc
{
public
:
friend
class
SpliceableJSONWriter
;
ChunkedJSONWriteFunc
(
)
:
mChunkPtr
{
nullptr
}
mChunkEnd
{
nullptr
}
{
AllocChunk
(
kChunkSize
)
;
}
bool
IsEmpty
(
)
const
{
MOZ_ASSERT_IF
(
!
mChunkPtr
!
mChunkEnd
&
&
mChunkList
.
length
(
)
=
=
0
&
&
mChunkLengths
.
length
(
)
=
=
0
)
;
return
!
mChunkPtr
;
}
void
Write
(
const
char
*
aStr
)
override
{
size_t
len
=
strlen
(
aStr
)
;
Write
(
aStr
len
)
;
}
void
Write
(
const
char
*
aStr
size_t
aLen
)
override
{
MOZ_ASSERT
(
mChunkPtr
>
=
mChunkList
.
back
(
)
.
get
(
)
&
&
mChunkPtr
<
=
mChunkEnd
)
;
MOZ_ASSERT
(
mChunkEnd
>
=
mChunkList
.
back
(
)
.
get
(
)
+
mChunkLengths
.
back
(
)
)
;
MOZ_ASSERT
(
*
mChunkPtr
=
=
'
\
0
'
)
;
char
*
newPtr
;
if
(
aLen
>
=
kChunkSize
)
{
AllocChunk
(
aLen
+
1
)
;
newPtr
=
mChunkPtr
+
aLen
;
}
else
{
newPtr
=
mChunkPtr
+
aLen
;
if
(
newPtr
>
=
mChunkEnd
)
{
AllocChunk
(
kChunkSize
)
;
newPtr
=
mChunkPtr
+
aLen
;
}
}
memcpy
(
mChunkPtr
aStr
aLen
)
;
*
newPtr
=
'
\
0
'
;
mChunkPtr
=
newPtr
;
mChunkLengths
.
back
(
)
+
=
aLen
;
}
void
CopyDataIntoLazilyAllocatedBuffer
(
const
std
:
:
function
<
char
*
(
size_t
)
>
&
aAllocator
)
const
{
size_t
totalLen
=
GetTotalLength
(
)
;
char
*
ptr
=
aAllocator
(
totalLen
)
;
if
(
!
ptr
)
{
return
;
}
for
(
size_t
i
=
0
;
i
<
mChunkList
.
length
(
)
;
i
+
+
)
{
size_t
len
=
mChunkLengths
[
i
]
;
memcpy
(
ptr
mChunkList
[
i
]
.
get
(
)
len
)
;
ptr
+
=
len
;
}
*
ptr
=
'
\
0
'
;
}
UniquePtr
<
char
[
]
>
CopyData
(
)
const
{
UniquePtr
<
char
[
]
>
c
;
CopyDataIntoLazilyAllocatedBuffer
(
[
&
]
(
size_t
allocationSize
)
{
c
=
MakeUnique
<
char
[
]
>
(
allocationSize
)
;
return
c
.
get
(
)
;
}
)
;
return
c
;
}
void
Take
(
ChunkedJSONWriteFunc
&
&
aOther
)
{
for
(
size_t
i
=
0
;
i
<
aOther
.
mChunkList
.
length
(
)
;
i
+
+
)
{
MOZ_ALWAYS_TRUE
(
mChunkLengths
.
append
(
aOther
.
mChunkLengths
[
i
]
)
)
;
MOZ_ALWAYS_TRUE
(
mChunkList
.
append
(
std
:
:
move
(
aOther
.
mChunkList
[
i
]
)
)
)
;
}
mChunkPtr
=
mChunkList
.
back
(
)
.
get
(
)
+
mChunkLengths
.
back
(
)
;
mChunkEnd
=
mChunkPtr
;
aOther
.
mChunkPtr
=
nullptr
;
aOther
.
mChunkEnd
=
nullptr
;
aOther
.
mChunkList
.
clear
(
)
;
aOther
.
mChunkLengths
.
clear
(
)
;
}
size_t
GetTotalLength
(
)
const
{
MOZ_ASSERT
(
mChunkLengths
.
length
(
)
=
=
mChunkList
.
length
(
)
)
;
size_t
totalLen
=
1
;
for
(
size_t
i
=
0
;
i
<
mChunkLengths
.
length
(
)
;
i
+
+
)
{
MOZ_ASSERT
(
strlen
(
mChunkList
[
i
]
.
get
(
)
)
=
=
mChunkLengths
[
i
]
)
;
totalLen
+
=
mChunkLengths
[
i
]
;
}
return
totalLen
;
}
private
:
void
AllocChunk
(
size_t
aChunkSize
)
{
MOZ_ASSERT
(
mChunkLengths
.
length
(
)
=
=
mChunkList
.
length
(
)
)
;
UniquePtr
<
char
[
]
>
newChunk
=
MakeUnique
<
char
[
]
>
(
aChunkSize
)
;
mChunkPtr
=
newChunk
.
get
(
)
;
mChunkEnd
=
mChunkPtr
+
aChunkSize
;
*
mChunkPtr
=
'
\
0
'
;
MOZ_ALWAYS_TRUE
(
mChunkLengths
.
append
(
0
)
)
;
MOZ_ALWAYS_TRUE
(
mChunkList
.
append
(
std
:
:
move
(
newChunk
)
)
)
;
}
static
const
size_t
kChunkSize
=
4096
*
512
;
char
*
mChunkPtr
;
char
*
mChunkEnd
;
Vector
<
UniquePtr
<
char
[
]
>
>
mChunkList
;
Vector
<
size_t
>
mChunkLengths
;
}
;
struct
OStreamJSONWriteFunc
final
:
public
JSONWriteFunc
{
explicit
OStreamJSONWriteFunc
(
std
:
:
ostream
&
aStream
)
:
mStream
(
aStream
)
{
}
void
Write
(
const
char
*
aStr
)
override
{
mStream
<
<
aStr
;
}
void
Write
(
const
char
*
aStr
size_t
aLen
)
override
{
mStream
<
<
aStr
;
}
std
:
:
ostream
&
mStream
;
}
;
class
SpliceableJSONWriter
:
public
JSONWriter
{
public
:
explicit
SpliceableJSONWriter
(
UniquePtr
<
JSONWriteFunc
>
aWriter
)
:
JSONWriter
(
std
:
:
move
(
aWriter
)
)
{
}
void
StartBareList
(
CollectionStyle
aStyle
=
MultiLineStyle
)
{
StartCollection
(
nullptr
"
"
aStyle
)
;
}
void
EndBareList
(
)
{
EndCollection
(
"
"
)
;
}
void
NullElements
(
uint32_t
aCount
)
{
for
(
uint32_t
i
=
0
;
i
<
aCount
;
i
+
+
)
{
NullElement
(
)
;
}
}
void
Splice
(
const
char
*
aStr
)
{
Separator
(
)
;
WriteFunc
(
)
-
>
Write
(
aStr
)
;
mNeedComma
[
mDepth
]
=
true
;
}
void
Splice
(
const
char
*
aStr
size_t
aLen
)
{
Separator
(
)
;
WriteFunc
(
)
-
>
Write
(
aStr
aLen
)
;
mNeedComma
[
mDepth
]
=
true
;
}
void
SplicedJSONProperty
(
const
char
*
aMaybePropertyName
const
char
*
aJsonValue
)
{
Scalar
(
aMaybePropertyName
aJsonValue
)
;
}
void
CopyAndSplice
(
const
ChunkedJSONWriteFunc
&
aFunc
)
{
Separator
(
)
;
for
(
size_t
i
=
0
;
i
<
aFunc
.
mChunkList
.
length
(
)
;
i
+
+
)
{
WriteFunc
(
)
-
>
Write
(
aFunc
.
mChunkList
[
i
]
.
get
(
)
aFunc
.
mChunkLengths
[
i
]
)
;
}
mNeedComma
[
mDepth
]
=
true
;
}
virtual
void
TakeAndSplice
(
ChunkedJSONWriteFunc
&
&
aFunc
)
{
Separator
(
)
;
for
(
size_t
i
=
0
;
i
<
aFunc
.
mChunkList
.
length
(
)
;
i
+
+
)
{
WriteFunc
(
)
-
>
Write
(
aFunc
.
mChunkList
[
i
]
.
get
(
)
)
;
}
aFunc
.
mChunkPtr
=
nullptr
;
aFunc
.
mChunkEnd
=
nullptr
;
aFunc
.
mChunkList
.
clear
(
)
;
aFunc
.
mChunkLengths
.
clear
(
)
;
mNeedComma
[
mDepth
]
=
true
;
}
}
;
class
SpliceableChunkedJSONWriter
final
:
public
SpliceableJSONWriter
{
public
:
explicit
SpliceableChunkedJSONWriter
(
)
:
SpliceableJSONWriter
(
MakeUnique
<
ChunkedJSONWriteFunc
>
(
)
)
{
}
const
ChunkedJSONWriteFunc
&
ChunkedWriteFunc
(
)
const
{
MOZ_ASSERT
(
!
mTaken
)
;
return
*
static_cast
<
const
ChunkedJSONWriteFunc
*
>
(
WriteFunc
(
)
)
;
}
ChunkedJSONWriteFunc
&
&
TakeChunkedWriteFunc
(
)
{
#
ifdef
DEBUG
MOZ_ASSERT
(
!
mTaken
)
;
mTaken
=
true
;
#
endif
return
std
:
:
move
(
*
static_cast
<
ChunkedJSONWriteFunc
*
>
(
WriteFunc
(
)
)
)
;
}
void
TakeAndSplice
(
ChunkedJSONWriteFunc
&
&
aFunc
)
override
{
MOZ_ASSERT
(
!
mTaken
)
;
Separator
(
)
;
static_cast
<
ChunkedJSONWriteFunc
*
>
(
WriteFunc
(
)
)
-
>
Take
(
std
:
:
move
(
aFunc
)
)
;
mNeedComma
[
mDepth
]
=
true
;
}
#
ifdef
DEBUG
private
:
bool
mTaken
=
false
;
#
endif
}
;
class
JSONSchemaWriter
{
JSONWriter
&
mWriter
;
uint32_t
mIndex
;
public
:
explicit
JSONSchemaWriter
(
JSONWriter
&
aWriter
)
:
mWriter
(
aWriter
)
mIndex
(
0
)
{
aWriter
.
StartObjectProperty
(
"
schema
"
SpliceableJSONWriter
:
:
SingleLineStyle
)
;
}
void
WriteField
(
const
char
*
aName
)
{
mWriter
.
IntProperty
(
aName
mIndex
+
+
)
;
}
~
JSONSchemaWriter
(
)
{
mWriter
.
EndObject
(
)
;
}
}
;
}
}
#
endif
