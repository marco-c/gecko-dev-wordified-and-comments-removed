#
ifndef
BASEPROFILEJSONWRITER_H
#
define
BASEPROFILEJSONWRITER_H
#
include
"
BaseProfiler
.
h
"
#
ifndef
MOZ_GECKO_PROFILER
#
error
Do
not
#
include
this
header
when
MOZ_GECKO_PROFILER
is
not
#
defined
.
#
endif
#
include
"
mozilla
/
JSONWriter
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
<
functional
>
#
include
<
ostream
>
#
include
<
string
>
namespace
mozilla
{
namespace
baseprofiler
{
class
SpliceableJSONWriter
;
class
ChunkedJSONWriteFunc
:
public
JSONWriteFunc
{
public
:
friend
class
SpliceableJSONWriter
;
ChunkedJSONWriteFunc
(
)
:
mChunkPtr
{
nullptr
}
mChunkEnd
{
nullptr
}
{
AllocChunk
(
kChunkSize
)
;
}
bool
IsEmpty
(
)
const
{
MOZ_ASSERT_IF
(
!
mChunkPtr
!
mChunkEnd
&
&
mChunkList
.
length
(
)
=
=
0
&
&
mChunkLengths
.
length
(
)
=
=
0
)
;
return
!
mChunkPtr
;
}
void
Write
(
const
char
*
aStr
)
override
;
void
Write
(
const
char
*
aStr
size_t
aLen
)
override
;
void
CopyDataIntoLazilyAllocatedBuffer
(
const
std
:
:
function
<
char
*
(
size_t
)
>
&
aAllocator
)
const
;
UniquePtr
<
char
[
]
>
CopyData
(
)
const
;
void
Take
(
ChunkedJSONWriteFunc
&
&
aOther
)
;
size_t
GetTotalLength
(
)
const
;
private
:
void
AllocChunk
(
size_t
aChunkSize
)
;
static
const
size_t
kChunkSize
=
4096
*
512
;
char
*
mChunkPtr
;
char
*
mChunkEnd
;
Vector
<
UniquePtr
<
char
[
]
>
>
mChunkList
;
Vector
<
size_t
>
mChunkLengths
;
}
;
struct
OStreamJSONWriteFunc
:
public
JSONWriteFunc
{
explicit
OStreamJSONWriteFunc
(
std
:
:
ostream
&
aStream
)
:
mStream
(
aStream
)
{
}
void
Write
(
const
char
*
aStr
)
override
{
mStream
<
<
aStr
;
}
void
Write
(
const
char
*
aStr
size_t
aLen
)
override
{
mStream
<
<
aStr
;
}
std
:
:
ostream
&
mStream
;
}
;
class
SpliceableJSONWriter
:
public
JSONWriter
{
public
:
explicit
SpliceableJSONWriter
(
UniquePtr
<
JSONWriteFunc
>
aWriter
)
:
JSONWriter
(
std
:
:
move
(
aWriter
)
)
{
}
void
StartBareList
(
CollectionStyle
aStyle
=
MultiLineStyle
)
{
StartCollection
(
nullptr
"
"
aStyle
)
;
}
void
EndBareList
(
)
{
EndCollection
(
"
"
)
;
}
void
NullElements
(
uint32_t
aCount
)
{
for
(
uint32_t
i
=
0
;
i
<
aCount
;
i
+
+
)
{
NullElement
(
)
;
}
}
void
Splice
(
const
ChunkedJSONWriteFunc
*
aFunc
)
;
void
Splice
(
const
char
*
aStr
)
;
void
SplicedJSONProperty
(
const
char
*
aMaybePropertyName
const
char
*
aJsonValue
)
{
Scalar
(
aMaybePropertyName
aJsonValue
)
;
}
virtual
void
TakeAndSplice
(
ChunkedJSONWriteFunc
*
aFunc
)
;
}
;
class
SpliceableChunkedJSONWriter
:
public
SpliceableJSONWriter
{
public
:
explicit
SpliceableChunkedJSONWriter
(
)
:
SpliceableJSONWriter
(
MakeUnique
<
ChunkedJSONWriteFunc
>
(
)
)
{
}
ChunkedJSONWriteFunc
*
WriteFunc
(
)
const
{
return
static_cast
<
ChunkedJSONWriteFunc
*
>
(
JSONWriter
:
:
WriteFunc
(
)
)
;
}
virtual
void
TakeAndSplice
(
ChunkedJSONWriteFunc
*
aFunc
)
override
;
}
;
class
JSONSchemaWriter
{
JSONWriter
&
mWriter
;
uint32_t
mIndex
;
public
:
explicit
JSONSchemaWriter
(
JSONWriter
&
aWriter
)
:
mWriter
(
aWriter
)
mIndex
(
0
)
{
aWriter
.
StartObjectProperty
(
"
schema
"
SpliceableJSONWriter
:
:
SingleLineStyle
)
;
}
void
WriteField
(
const
char
*
aName
)
{
mWriter
.
IntProperty
(
aName
mIndex
+
+
)
;
}
~
JSONSchemaWriter
(
)
{
mWriter
.
EndObject
(
)
;
}
}
;
}
}
#
endif
