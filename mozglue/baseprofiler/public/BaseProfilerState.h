#
ifndef
BaseProfilerState_h
#
define
BaseProfilerState_h
#
include
"
mozilla
/
BaseProfilerUtils
.
h
"
#
ifndef
MOZ_GECKO_PROFILER
#
define
AUTO_PROFILER_STATS
(
name
)
namespace
mozilla
:
:
baseprofiler
{
[
[
nodiscard
]
]
inline
bool
profiler_is_active
(
)
{
return
false
;
}
[
[
nodiscard
]
]
inline
bool
profiler_is_active_and_unpaused
(
)
{
return
false
;
}
}
#
else
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
<
stdint
.
h
>
#
include
<
string
>
#
ifdef
PROFILER_RUNTIME_STATS
#
include
"
mozilla
/
TimeStamp
.
h
"
#
endif
namespace
mozilla
:
:
baseprofiler
{
#
ifdef
PROFILER_RUNTIME_STATS
class
StaticBaseProfilerStats
{
public
:
explicit
StaticBaseProfilerStats
(
const
char
*
aName
)
:
mName
(
aName
)
{
}
~
StaticBaseProfilerStats
(
)
{
using
ULL
=
unsigned
long
long
;
ULL
n
=
static_cast
<
ULL
>
(
mNumberDurations
)
;
if
(
n
!
=
0
)
{
ULL
sumNs
=
static_cast
<
ULL
>
(
mSumDurationsNs
)
;
printf
(
"
[
%
d
]
Profiler
stats
%
s
:
%
llu
ns
/
%
llu
=
%
llu
ns
max
%
llu
ns
\
n
"
int
(
profiler_current_process_id
(
)
.
ToNumber
(
)
)
mName
sumNs
n
sumNs
/
n
static_cast
<
ULL
>
(
mLongestDurationNs
)
)
;
}
else
{
printf
(
"
[
%
d
]
Profiler
stats
%
s
:
(
nothing
)
\
n
"
int
(
profiler_current_process_id
(
)
.
ToNumber
(
)
)
mName
)
;
}
}
void
AddDurationFrom
(
TimeStamp
aStart
)
{
DurationNs
duration
=
static_cast
<
DurationNs
>
(
(
TimeStamp
:
:
Now
(
)
-
aStart
)
.
ToMicroseconds
(
)
*
1000
+
0
.
5
)
;
mSumDurationsNs
+
=
duration
;
+
+
mNumberDurations
;
for
(
;
;
)
{
DurationNs
longest
=
mLongestDurationNs
;
if
(
MOZ_LIKELY
(
longest
>
=
duration
)
)
{
break
;
}
if
(
MOZ_LIKELY
(
mLongestDurationNs
.
compareExchange
(
longest
duration
)
)
)
{
break
;
}
}
}
private
:
using
DurationNs
=
uint64_t
;
using
Count
=
uint32_t
;
Atomic
<
DurationNs
>
mSumDurationsNs
{
0
}
;
Atomic
<
DurationNs
>
mLongestDurationNs
{
0
}
;
Atomic
<
Count
>
mNumberDurations
{
0
}
;
const
char
*
mName
;
}
;
class
MOZ_RAII
AutoProfilerStats
{
public
:
explicit
AutoProfilerStats
(
StaticBaseProfilerStats
&
aStats
)
:
mStats
(
aStats
)
mStart
(
TimeStamp
:
:
Now
(
)
)
{
}
~
AutoProfilerStats
(
)
{
mStats
.
AddDurationFrom
(
mStart
)
;
}
private
:
StaticBaseProfilerStats
&
mStats
;
TimeStamp
mStart
;
}
;
#
define
AUTO_PROFILER_STATS
(
name
)
\
static
:
:
mozilla
:
:
baseprofiler
:
:
StaticBaseProfilerStats
sStat
#
#
name
(
\
#
name
)
;
\
:
:
mozilla
:
:
baseprofiler
:
:
AutoProfilerStats
autoStat
#
#
name
(
sStat
#
#
name
)
;
#
else
#
define
AUTO_PROFILER_STATS
(
name
)
#
endif
#
define
BASE_PROFILER_FOR_EACH_FEATURE
(
MACRO
)
\
MACRO
(
0
"
java
"
Java
"
Profile
Java
code
Android
only
"
)
\
\
MACRO
(
1
"
js
"
JS
\
"
Get
the
JS
engine
to
expose
the
JS
stack
to
the
profiler
"
)
\
\
/
*
The
DevTools
profiler
doesn
'
t
want
the
native
addresses
.
*
/
\
MACRO
(
2
"
leaf
"
Leaf
"
Include
the
C
+
+
leaf
node
if
not
stackwalking
"
)
\
\
MACRO
(
3
"
mainthreadio
"
MainThreadIO
"
Add
main
thread
file
I
/
O
"
)
\
\
MACRO
(
4
"
fileio
"
FileIO
\
"
Add
file
I
/
O
from
all
profiled
threads
implies
mainthreadio
"
)
\
\
MACRO
(
5
"
fileioall
"
FileIOAll
\
"
Add
file
I
/
O
from
all
threads
implies
fileio
"
)
\
\
MACRO
(
6
"
noiostacks
"
NoIOStacks
\
"
File
I
/
O
markers
do
not
capture
stacks
to
reduce
overhead
"
)
\
\
MACRO
(
7
"
screenshots
"
Screenshots
\
"
Take
a
snapshot
of
the
window
on
every
composition
"
)
\
\
MACRO
(
8
"
seqstyle
"
SequentialStyle
\
"
Disable
parallel
traversal
in
styling
"
)
\
\
MACRO
(
9
"
stackwalk
"
StackWalk
\
"
Walk
the
C
+
+
stack
not
available
on
all
platforms
"
)
\
\
MACRO
(
10
"
jsallocations
"
JSAllocations
\
"
Have
the
JavaScript
engine
track
allocations
"
)
\
\
MACRO
(
11
"
nostacksampling
"
NoStackSampling
\
"
Disable
all
stack
sampling
:
Cancels
\
"
js
\
"
\
"
leaf
\
"
"
\
"
\
"
stackwalk
\
"
and
labels
"
)
\
\
MACRO
(
12
"
preferencereads
"
PreferenceReads
\
"
Track
when
preferences
are
read
"
)
\
\
MACRO
(
13
"
nativeallocations
"
NativeAllocations
\
"
Collect
the
stacks
from
a
smaller
subset
of
all
native
"
\
"
allocations
biasing
towards
collecting
larger
allocations
"
)
\
\
MACRO
(
14
"
ipcmessages
"
IPCMessages
\
"
Have
the
IPC
layer
track
cross
-
process
messages
"
)
\
\
MACRO
(
15
"
audiocallbacktracing
"
AudioCallbackTracing
\
"
Audio
callback
tracing
"
)
\
\
MACRO
(
16
"
cpu
"
CPUUtilization
"
CPU
utilization
"
)
\
\
MACRO
(
17
"
notimerresolutionchange
"
NoTimerResolutionChange
\
"
Do
not
adjust
the
timer
resolution
for
fast
sampling
so
that
"
\
"
other
Firefox
timers
do
not
get
affected
"
)
\
\
MACRO
(
18
"
cpuallthreads
"
CPUAllThreads
\
"
Sample
the
CPU
utilization
of
all
registered
threads
"
)
\
\
MACRO
(
19
"
samplingallthreads
"
SamplingAllThreads
\
"
Sample
the
stacks
of
all
registered
threads
"
)
\
\
MACRO
(
20
"
markersallthreads
"
MarkersAllThreads
\
"
Record
markers
from
all
registered
threads
"
)
\
\
MACRO
(
21
"
unregisteredthreads
"
UnregisteredThreads
\
"
Discover
and
profile
unregistered
threads
-
-
beware
:
expensive
!
"
)
\
\
MACRO
(
22
"
processcpu
"
ProcessCPU
\
"
Sample
the
CPU
utilization
of
each
process
"
)
\
\
MACRO
(
23
"
power
"
Power
\
"
Sample
energy
meters
on
Windows
11
and
per
process
power
use
on
"
\
"
Apple
Silicon
"
)
struct
ProfilerFeature
{
#
define
DECLARE
(
n_
str_
Name_
desc_
)
\
static
constexpr
uint32_t
Name_
=
(
1u
<
<
n_
)
;
\
[
[
nodiscard
]
]
static
constexpr
bool
Has
#
#
Name_
(
uint32_t
aFeatures
)
{
\
return
aFeatures
&
Name_
;
\
}
\
static
constexpr
void
Set
#
#
Name_
(
uint32_t
&
aFeatures
)
{
\
aFeatures
|
=
Name_
;
\
}
\
static
constexpr
void
Clear
#
#
Name_
(
uint32_t
&
aFeatures
)
{
\
aFeatures
&
=
~
Name_
;
\
}
BASE_PROFILER_FOR_EACH_FEATURE
(
DECLARE
)
#
undef
DECLARE
}
;
namespace
detail
{
class
RacyFeatures
{
public
:
MFBT_API
static
void
SetActive
(
uint32_t
aFeatures
)
;
MFBT_API
static
void
SetInactive
(
)
;
MFBT_API
static
void
SetPaused
(
)
;
MFBT_API
static
void
SetUnpaused
(
)
;
MFBT_API
static
void
SetSamplingPaused
(
)
;
MFBT_API
static
void
SetSamplingUnpaused
(
)
;
[
[
nodiscard
]
]
MFBT_API
static
bool
IsActive
(
)
;
[
[
nodiscard
]
]
MFBT_API
static
bool
IsActiveWithFeature
(
uint32_t
aFeature
)
;
[
[
nodiscard
]
]
MFBT_API
static
bool
IsActiveAndUnpaused
(
)
;
[
[
nodiscard
]
]
MFBT_API
static
bool
IsActiveAndSamplingUnpaused
(
)
;
private
:
static
constexpr
uint32_t
Active
=
1u
<
<
31
;
static
constexpr
uint32_t
Paused
=
1u
<
<
30
;
static
constexpr
uint32_t
SamplingPaused
=
1u
<
<
29
;
#
define
NO_OVERLAP
(
n_
str_
Name_
desc_
)
\
static_assert
(
ProfilerFeature
:
:
Name_
!
=
SamplingPaused
\
"
bad
feature
value
"
)
;
BASE_PROFILER_FOR_EACH_FEATURE
(
NO_OVERLAP
)
;
#
undef
NO_OVERLAP
static
Atomic
<
uint32_t
MemoryOrdering
:
:
Relaxed
>
sActiveAndFeatures
;
}
;
MFBT_API
bool
IsThreadBeingProfiled
(
)
;
}
[
[
nodiscard
]
]
inline
bool
profiler_is_active
(
)
{
return
baseprofiler
:
:
detail
:
:
RacyFeatures
:
:
IsActive
(
)
;
}
[
[
nodiscard
]
]
inline
bool
profiler_is_active_and_unpaused
(
)
{
return
baseprofiler
:
:
detail
:
:
RacyFeatures
:
:
IsActiveAndUnpaused
(
)
;
}
[
[
nodiscard
]
]
inline
bool
profiler_thread_is_being_profiled
(
)
{
return
baseprofiler
:
:
detail
:
:
RacyFeatures
:
:
IsActiveAndUnpaused
(
)
&
&
baseprofiler
:
:
detail
:
:
IsThreadBeingProfiled
(
)
;
}
[
[
nodiscard
]
]
MFBT_API
bool
profiler_is_paused
(
)
;
[
[
nodiscard
]
]
MFBT_API
bool
profiler_is_sampling_paused
(
)
;
[
[
nodiscard
]
]
MFBT_API
bool
profiler_thread_is_sleeping
(
)
;
[
[
nodiscard
]
]
MFBT_API
uint32_t
profiler_get_available_features
(
)
;
[
[
nodiscard
]
]
MFBT_API
bool
profiler_feature_active
(
uint32_t
aFeature
)
;
[
[
nodiscard
]
]
bool
profiler_is_locked_on_current_thread
(
)
;
}
#
endif
#
endif
