#
ifndef
ProportionValue_h
#
define
ProportionValue_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
<
algorithm
>
#
include
<
limits
>
namespace
mozilla
{
class
ProportionValue
{
public
:
using
UnderlyingType
=
uint32_t
;
constexpr
ProportionValue
(
)
noexcept
:
mIntegralValue
(
0u
)
{
}
constexpr
explicit
ProportionValue
(
double
aValue
)
:
mIntegralValue
(
UnderlyingType
(
std
:
:
clamp
(
aValue
0
.
0
1
.
0
)
*
scMaxD
)
)
{
}
[
[
nodiscard
]
]
static
constexpr
ProportionValue
MakeInvalid
(
)
{
return
ProportionValue
(
scInvalidU
Internal
{
}
)
;
}
[
[
nodiscard
]
]
constexpr
double
ToDouble
(
)
const
{
return
IsInvalid
(
)
?
std
:
:
numeric_limits
<
double
>
:
:
signaling_NaN
(
)
:
(
double
(
mIntegralValue
)
*
scInvMaxD
)
;
}
[
[
nodiscard
]
]
constexpr
UnderlyingType
ToUnderlyingType
(
)
const
{
return
mIntegralValue
;
}
;
[
[
nodiscard
]
]
static
constexpr
ProportionValue
FromUnderlyingType
(
UnderlyingType
aUnderlyingType
)
{
return
ProportionValue
(
(
aUnderlyingType
<
=
scMaxU
)
?
aUnderlyingType
:
scInvalidU
Internal
{
}
)
;
}
[
[
nodiscard
]
]
constexpr
bool
IsExactlyZero
(
)
const
{
return
mIntegralValue
=
=
0u
;
}
[
[
nodiscard
]
]
constexpr
bool
IsExactlyOne
(
)
const
{
return
mIntegralValue
=
=
scMaxU
;
}
[
[
nodiscard
]
]
constexpr
bool
IsValid
(
)
const
{
return
mIntegralValue
<
=
scMaxU
;
}
[
[
nodiscard
]
]
constexpr
bool
IsInvalid
(
)
const
{
return
mIntegralValue
>
scMaxU
;
}
#
define
OPERATOR_COMPARISON
(
CMP
)
\
[
[
nodiscard
]
]
constexpr
friend
bool
operator
CMP
(
\
const
ProportionValue
&
aLHS
const
ProportionValue
&
aRHS
)
{
\
return
aLHS
.
mIntegralValue
CMP
aRHS
.
mIntegralValue
;
\
}
OPERATOR_COMPARISON
(
=
=
)
OPERATOR_COMPARISON
(
!
=
)
OPERATOR_COMPARISON
(
<
)
OPERATOR_COMPARISON
(
<
=
)
OPERATOR_COMPARISON
(
>
)
OPERATOR_COMPARISON
(
>
=
)
#
undef
OPERATOR_COMPARISON
[
[
nodiscard
]
]
constexpr
ProportionValue
operator
+
(
ProportionValue
aRHS
)
const
{
return
ProportionValue
(
(
IsInvalid
(
)
|
|
aRHS
.
IsInvalid
(
)
)
?
scInvalidU
:
(
mIntegralValue
+
std
:
:
min
(
aRHS
.
mIntegralValue
scMaxU
-
mIntegralValue
)
)
Internal
{
}
)
;
}
[
[
nodiscard
]
]
constexpr
ProportionValue
operator
-
(
ProportionValue
aRHS
)
const
{
return
ProportionValue
(
(
IsInvalid
(
)
|
|
aRHS
.
IsInvalid
(
)
)
?
scInvalidU
:
(
mIntegralValue
-
std
:
:
min
(
aRHS
.
mIntegralValue
mIntegralValue
)
)
Internal
{
}
)
;
}
[
[
nodiscard
]
]
constexpr
ProportionValue
operator
*
(
ProportionValue
aRHS
)
const
{
using
DoublePrecisionType
=
uint64_t
;
static_assert
(
sizeof
(
DoublePrecisionType
)
>
=
2
*
sizeof
(
UnderlyingType
)
)
;
return
ProportionValue
(
(
IsInvalid
(
)
|
|
aRHS
.
IsInvalid
(
)
)
?
scInvalidU
:
(
UnderlyingType
(
(
DoublePrecisionType
(
mIntegralValue
)
*
DoublePrecisionType
(
aRHS
.
mIntegralValue
)
)
/
DoublePrecisionType
(
scMaxU
)
)
)
Internal
{
}
)
;
}
[
[
nodiscard
]
]
constexpr
ProportionValue
operator
/
(
ProportionValue
aRHS
)
const
=
delete
;
[
[
nodiscard
]
]
constexpr
ProportionValue
operator
/
(
uint32_t
aDivisor
)
const
{
return
ProportionValue
(
(
IsInvalid
(
)
|
|
aDivisor
=
=
0u
)
?
scInvalidU
:
(
mIntegralValue
/
aDivisor
)
Internal
{
}
)
;
}
[
[
nodiscard
]
]
constexpr
ProportionValue
operator
*
(
uint32_t
aMultiplier
)
const
{
return
ProportionValue
(
IsInvalid
(
)
?
scInvalidU
:
(
(
aMultiplier
>
scMaxU
/
mIntegralValue
)
?
scMaxU
:
(
mIntegralValue
*
aMultiplier
)
)
Internal
{
}
)
;
}
private
:
struct
Internal
{
}
;
constexpr
ProportionValue
(
UnderlyingType
aIntegralValue
Internal
)
:
mIntegralValue
(
aIntegralValue
)
{
}
static
constexpr
unsigned
scFractionalBits
=
sizeof
(
UnderlyingType
)
*
8
-
1
;
static
constexpr
UnderlyingType
scMaxU
=
UnderlyingType
(
1u
)
<
<
scFractionalBits
;
static
constexpr
double
scMaxD
=
double
(
scMaxU
)
;
static
constexpr
double
scInvMaxD
=
1
.
0
/
scMaxD
;
static
constexpr
UnderlyingType
scInvalidU
=
~
UnderlyingType
(
0u
)
;
UnderlyingType
mIntegralValue
;
}
;
namespace
literals
{
inline
namespace
ProportionValue_literals
{
[
[
nodiscard
]
]
constexpr
ProportionValue
operator
"
"
_pc
(
unsigned
long
long
int
aPercentage
)
{
return
ProportionValue
{
double
(
std
:
:
clamp
<
unsigned
long
long
int
>
(
aPercentage
0u
100u
)
)
/
100
.
0
}
;
}
[
[
nodiscard
]
]
constexpr
ProportionValue
operator
"
"
_pc
(
long
double
aPercentage
)
{
return
ProportionValue
{
double
(
std
:
:
clamp
<
long
double
>
(
aPercentage
0
.
0
100
.
0
)
)
/
100
.
0
}
;
}
}
}
}
#
endif
