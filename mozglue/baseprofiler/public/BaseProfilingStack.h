#
ifndef
BaseProfilingStack_h
#
define
BaseProfilingStack_h
#
include
"
BaseProfilingCategory
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
BaseProfiler
.
h
"
#
ifndef
MOZ_GECKO_PROFILER
#
error
Do
not
#
include
this
header
when
MOZ_GECKO_PROFILER
is
not
#
defined
.
#
endif
#
include
<
algorithm
>
#
include
<
stdint
.
h
>
namespace
mozilla
{
namespace
baseprofiler
{
class
ProfilingStackFrame
{
Atomic
<
const
char
*
ReleaseAcquire
>
label_
;
Atomic
<
const
char
*
ReleaseAcquire
>
dynamicString_
;
Atomic
<
void
*
ReleaseAcquire
>
spOrScript
;
Atomic
<
int32_t
ReleaseAcquire
>
pcOffsetIfJS_
;
mozilla
:
:
Atomic
<
uint64_t
mozilla
:
:
ReleaseAcquire
>
realmID_
;
Atomic
<
uint32_t
ReleaseAcquire
>
flagsAndCategoryPair_
;
public
:
ProfilingStackFrame
(
)
=
default
;
ProfilingStackFrame
&
operator
=
(
const
ProfilingStackFrame
&
other
)
{
label_
=
other
.
label
(
)
;
dynamicString_
=
other
.
dynamicString
(
)
;
void
*
spScript
=
other
.
spOrScript
;
spOrScript
=
spScript
;
int32_t
offsetIfJS
=
other
.
pcOffsetIfJS_
;
pcOffsetIfJS_
=
offsetIfJS
;
int64_t
realmID
=
other
.
realmID_
;
realmID_
=
realmID
;
uint32_t
flagsAndCategory
=
other
.
flagsAndCategoryPair_
;
flagsAndCategoryPair_
=
flagsAndCategory
;
return
*
this
;
}
enum
class
Flags
:
uint32_t
{
IS_LABEL_FRAME
=
1
<
<
0
IS_SP_MARKER_FRAME
=
1
<
<
1
IS_JS_FRAME
=
1
<
<
2
JS_OSR
=
1
<
<
3
STRING_TEMPLATE_METHOD
=
1
<
<
4
STRING_TEMPLATE_GETTER
=
1
<
<
5
STRING_TEMPLATE_SETTER
=
1
<
<
6
RELEVANT_FOR_JS
=
1
<
<
7
LABEL_DETERMINED_BY_CATEGORY_PAIR
=
1
<
<
8
FLAGS_BITCOUNT
=
9
FLAGS_MASK
=
(
1
<
<
FLAGS_BITCOUNT
)
-
1
}
;
static_assert
(
uint32_t
(
ProfilingCategoryPair
:
:
LAST
)
<
=
(
UINT32_MAX
>
>
uint32_t
(
Flags
:
:
FLAGS_BITCOUNT
)
)
"
Too
many
category
pairs
to
fit
into
u32
with
together
with
the
"
"
reserved
bits
for
the
flags
"
)
;
bool
isLabelFrame
(
)
const
{
return
uint32_t
(
flagsAndCategoryPair_
)
&
uint32_t
(
Flags
:
:
IS_LABEL_FRAME
)
;
}
bool
isSpMarkerFrame
(
)
const
{
return
uint32_t
(
flagsAndCategoryPair_
)
&
uint32_t
(
Flags
:
:
IS_SP_MARKER_FRAME
)
;
}
bool
isJsFrame
(
)
const
{
return
uint32_t
(
flagsAndCategoryPair_
)
&
uint32_t
(
Flags
:
:
IS_JS_FRAME
)
;
}
bool
isOSRFrame
(
)
const
{
return
uint32_t
(
flagsAndCategoryPair_
)
&
uint32_t
(
Flags
:
:
JS_OSR
)
;
}
void
setIsOSRFrame
(
bool
isOSR
)
{
if
(
isOSR
)
{
flagsAndCategoryPair_
=
uint32_t
(
flagsAndCategoryPair_
)
|
uint32_t
(
Flags
:
:
JS_OSR
)
;
}
else
{
flagsAndCategoryPair_
=
uint32_t
(
flagsAndCategoryPair_
)
&
~
uint32_t
(
Flags
:
:
JS_OSR
)
;
}
}
const
char
*
label
(
)
const
{
uint32_t
flagsAndCategoryPair
=
flagsAndCategoryPair_
;
if
(
flagsAndCategoryPair
&
uint32_t
(
Flags
:
:
LABEL_DETERMINED_BY_CATEGORY_PAIR
)
)
{
auto
categoryPair
=
ProfilingCategoryPair
(
flagsAndCategoryPair
>
>
uint32_t
(
Flags
:
:
FLAGS_BITCOUNT
)
)
;
return
GetProfilingCategoryPairInfo
(
categoryPair
)
.
mLabel
;
}
return
label_
;
}
const
char
*
dynamicString
(
)
const
{
return
dynamicString_
;
}
void
initLabelFrame
(
const
char
*
aLabel
const
char
*
aDynamicString
void
*
sp
ProfilingCategoryPair
aCategoryPair
uint32_t
aFlags
)
{
label_
=
aLabel
;
dynamicString_
=
aDynamicString
;
spOrScript
=
sp
;
flagsAndCategoryPair_
=
uint32_t
(
Flags
:
:
IS_LABEL_FRAME
)
|
(
uint32_t
(
aCategoryPair
)
<
<
uint32_t
(
Flags
:
:
FLAGS_BITCOUNT
)
)
|
aFlags
;
MOZ_ASSERT
(
isLabelFrame
(
)
)
;
}
void
initSpMarkerFrame
(
void
*
sp
)
{
label_
=
"
"
;
dynamicString_
=
nullptr
;
spOrScript
=
sp
;
flagsAndCategoryPair_
=
uint32_t
(
Flags
:
:
IS_SP_MARKER_FRAME
)
|
(
uint32_t
(
ProfilingCategoryPair
:
:
OTHER
)
<
<
uint32_t
(
Flags
:
:
FLAGS_BITCOUNT
)
)
;
MOZ_ASSERT
(
isSpMarkerFrame
(
)
)
;
}
void
initJsFrame
(
const
char
*
aLabel
const
char
*
aDynamicString
void
*
aScript
int32_t
aOffset
uint64_t
aRealmID
)
{
label_
=
aLabel
;
dynamicString_
=
aDynamicString
;
spOrScript
=
aScript
;
pcOffsetIfJS_
=
aOffset
;
realmID_
=
aRealmID
;
flagsAndCategoryPair_
=
uint32_t
(
Flags
:
:
IS_JS_FRAME
)
|
(
uint32_t
(
ProfilingCategoryPair
:
:
JS
)
<
<
uint32_t
(
Flags
:
:
FLAGS_BITCOUNT
)
)
;
MOZ_ASSERT
(
isJsFrame
(
)
)
;
}
uint32_t
flags
(
)
const
{
return
uint32_t
(
flagsAndCategoryPair_
)
&
uint32_t
(
Flags
:
:
FLAGS_MASK
)
;
}
ProfilingCategoryPair
categoryPair
(
)
const
{
return
ProfilingCategoryPair
(
flagsAndCategoryPair_
>
>
uint32_t
(
Flags
:
:
FLAGS_BITCOUNT
)
)
;
}
uint64_t
realmID
(
)
const
{
return
realmID_
;
}
void
*
stackAddress
(
)
const
{
MOZ_ASSERT
(
!
isJsFrame
(
)
)
;
return
spOrScript
;
}
void
*
rawScript
(
)
const
{
MOZ_ASSERT
(
isJsFrame
(
)
)
;
return
spOrScript
;
}
void
setRawScript
(
void
*
aScript
)
{
MOZ_ASSERT
(
isJsFrame
(
)
)
;
spOrScript
=
aScript
;
}
int32_t
pcOffset
(
)
const
{
MOZ_ASSERT
(
isJsFrame
(
)
)
;
return
pcOffsetIfJS_
;
}
void
setPCOffset
(
int32_t
aOffset
)
{
MOZ_ASSERT
(
isJsFrame
(
)
)
;
pcOffsetIfJS_
=
aOffset
;
}
static
const
int32_t
NullPCOffset
=
-
1
;
}
;
class
ProfilingStack
final
{
public
:
ProfilingStack
(
)
=
default
;
MFBT_API
~
ProfilingStack
(
)
;
void
pushLabelFrame
(
const
char
*
label
const
char
*
dynamicString
void
*
sp
ProfilingCategoryPair
categoryPair
uint32_t
flags
=
0
)
{
uint32_t
stackPointerVal
=
stackPointer
;
if
(
MOZ_UNLIKELY
(
stackPointerVal
>
=
capacity
)
)
{
ensureCapacitySlow
(
)
;
}
frames
[
stackPointerVal
]
.
initLabelFrame
(
label
dynamicString
sp
categoryPair
flags
)
;
stackPointer
=
stackPointer
+
1
;
}
void
pushSpMarkerFrame
(
void
*
sp
)
{
uint32_t
oldStackPointer
=
stackPointer
;
if
(
MOZ_UNLIKELY
(
oldStackPointer
>
=
capacity
)
)
{
ensureCapacitySlow
(
)
;
}
frames
[
oldStackPointer
]
.
initSpMarkerFrame
(
sp
)
;
stackPointer
=
oldStackPointer
+
1
;
}
void
pushJsOffsetFrame
(
const
char
*
label
const
char
*
dynamicString
void
*
script
int32_t
offset
uint64_t
aRealmID
)
{
uint32_t
oldStackPointer
=
stackPointer
;
if
(
MOZ_UNLIKELY
(
oldStackPointer
>
=
capacity
)
)
{
ensureCapacitySlow
(
)
;
}
frames
[
oldStackPointer
]
.
initJsFrame
(
label
dynamicString
script
offset
aRealmID
)
;
stackPointer
=
stackPointer
+
1
;
}
void
pop
(
)
{
MOZ_ASSERT
(
stackPointer
>
0
)
;
uint32_t
oldStackPointer
=
stackPointer
;
stackPointer
=
oldStackPointer
-
1
;
}
uint32_t
stackSize
(
)
const
{
return
stackPointer
;
}
uint32_t
stackCapacity
(
)
const
{
return
capacity
;
}
private
:
MFBT_API
MOZ_COLD
void
ensureCapacitySlow
(
)
;
ProfilingStack
(
const
ProfilingStack
&
)
=
delete
;
void
operator
=
(
const
ProfilingStack
&
)
=
delete
;
ProfilingStack
(
ProfilingStack
&
&
)
=
delete
;
void
operator
=
(
ProfilingStack
&
&
)
=
delete
;
uint32_t
capacity
=
0
;
public
:
Atomic
<
ProfilingStackFrame
*
SequentiallyConsistent
>
frames
{
nullptr
}
;
Atomic
<
uint32_t
ReleaseAcquire
>
stackPointer
{
0
}
;
}
;
class
AutoGeckoProfilerEntry
;
class
GeckoProfilerEntryMarker
;
class
GeckoProfilerBaselineOSRMarker
;
class
GeckoProfilerThread
{
friend
class
AutoGeckoProfilerEntry
;
friend
class
GeckoProfilerEntryMarker
;
friend
class
GeckoProfilerBaselineOSRMarker
;
ProfilingStack
*
profilingStack_
;
ProfilingStack
*
profilingStackIfEnabled_
;
public
:
MFBT_API
GeckoProfilerThread
(
)
;
uint32_t
stackPointer
(
)
{
MOZ_ASSERT
(
infraInstalled
(
)
)
;
return
profilingStack_
-
>
stackPointer
;
}
ProfilingStackFrame
*
stack
(
)
{
return
profilingStack_
-
>
frames
;
}
ProfilingStack
*
getProfilingStack
(
)
{
return
profilingStack_
;
}
ProfilingStack
*
getProfilingStackIfEnabled
(
)
{
return
profilingStackIfEnabled_
;
}
bool
infraInstalled
(
)
{
return
profilingStack_
!
=
nullptr
;
}
MFBT_API
void
setProfilingStack
(
ProfilingStack
*
profilingStack
bool
enabled
)
;
void
enable
(
bool
enable
)
{
profilingStackIfEnabled_
=
enable
?
profilingStack_
:
nullptr
;
}
}
;
}
}
#
endif
