#
ifndef
BaseProfilerMarkersDetail_h
#
define
BaseProfilerMarkersDetail_h
#
ifndef
BaseProfilerMarkers_h
#
error
"
This
header
should
only
be
#
included
by
BaseProfilerMarkers
.
h
"
#
endif
#
include
"
mozilla
/
BaseProfilerMarkersPrerequisites
.
h
"
#
include
"
mozilla
/
BaseProfileJSONWriter
.
h
"
#
include
"
mozilla
/
ProfileBufferEntryKinds
.
h
"
#
include
<
limits
>
#
include
<
tuple
>
namespace
mozilla
:
:
baseprofiler
{
MFBT_API
ProfileChunkedBuffer
&
profiler_get_core_buffer
(
)
;
}
namespace
mozilla
:
:
base_profiler_markers_detail
{
inline
ProfileChunkedBuffer
&
CachedBaseCoreBuffer
(
)
{
static
ProfileChunkedBuffer
&
coreBuffer
=
baseprofiler
:
:
profiler_get_core_buffer
(
)
;
return
coreBuffer
;
}
struct
Streaming
{
using
MarkerDataDeserializer
=
void
(
*
)
(
ProfileBufferEntryReader
&
baseprofiler
:
:
SpliceableJSONWriter
&
)
;
using
MarkerTypeNameFunction
=
Span
<
const
char
>
(
*
)
(
)
;
using
MarkerSchemaFunction
=
MarkerSchema
(
*
)
(
)
;
struct
MarkerTypeFunctions
{
MarkerDataDeserializer
mMarkerDataDeserializer
=
nullptr
;
MarkerTypeNameFunction
mMarkerTypeNameFunction
=
nullptr
;
MarkerSchemaFunction
mMarkerSchemaFunction
=
nullptr
;
}
;
using
DeserializerTag
=
uint8_t
;
MFBT_API
static
DeserializerTag
TagForMarkerTypeFunctions
(
MarkerDataDeserializer
aDeserializer
MarkerTypeNameFunction
aMarkerTypeNameFunction
MarkerSchemaFunction
aMarkerSchemaFunction
)
;
MFBT_API
static
MarkerDataDeserializer
DeserializerForTag
(
DeserializerTag
aTag
)
;
MFBT_API
static
Span
<
const
MarkerTypeFunctions
>
MarkerTypeFunctionsArray
(
)
;
}
;
template
<
typename
T
>
struct
StreamFunctionTypeHelper
;
template
<
typename
R
typename
.
.
.
As
>
struct
StreamFunctionTypeHelper
<
R
(
baseprofiler
:
:
SpliceableJSONWriter
&
As
.
.
.
)
>
{
constexpr
static
size_t
scArity
=
sizeof
.
.
.
(
As
)
;
using
TupleType
=
std
:
:
tuple
<
std
:
:
remove_cv_t
<
std
:
:
remove_reference_t
<
As
>
>
.
.
.
>
;
static
ProfileBufferBlockIndex
Serialize
(
ProfileChunkedBuffer
&
aBuffer
const
ProfilerString8View
&
aName
const
MarkerCategory
&
aCategory
MarkerOptions
&
&
aOptions
Streaming
:
:
DeserializerTag
aDeserializerTag
const
As
&
.
.
.
aAs
)
{
return
aBuffer
.
PutObjects
(
ProfileBufferEntryKind
:
:
Marker
aOptions
aName
aCategory
aDeserializerTag
MarkerPayloadType
:
:
Cpp
aAs
.
.
.
)
;
}
}
;
template
<
typename
MarkerType
>
struct
MarkerTypeSerialization
{
using
StreamFunctionType
=
StreamFunctionTypeHelper
<
decltype
(
MarkerType
:
:
StreamJSONMarkerData
)
>
;
constexpr
static
size_t
scStreamFunctionParameterCount
=
StreamFunctionType
:
:
scArity
;
using
StreamFunctionUserParametersTuple
=
typename
StreamFunctionType
:
:
TupleType
;
template
<
size_t
i
>
using
StreamFunctionParameter
=
std
:
:
tuple_element_t
<
i
StreamFunctionUserParametersTuple
>
;
template
<
typename
.
.
.
Ts
>
static
ProfileBufferBlockIndex
Serialize
(
ProfileChunkedBuffer
&
aBuffer
const
ProfilerString8View
&
aName
const
MarkerCategory
&
aCategory
MarkerOptions
&
&
aOptions
const
Ts
&
.
.
.
aTs
)
{
static_assert
(
!
std
:
:
is_same_v
<
MarkerType
:
:
mozilla
:
:
baseprofiler
:
:
markers
:
:
NoPayload
>
"
NoPayload
should
have
been
handled
in
the
caller
.
"
)
;
static
const
Streaming
:
:
DeserializerTag
tag
=
Streaming
:
:
TagForMarkerTypeFunctions
(
Deserialize
MarkerType
:
:
MarkerTypeName
MarkerType
:
:
MarkerTypeDisplay
)
;
return
StreamFunctionType
:
:
Serialize
(
aBuffer
aName
aCategory
std
:
:
move
(
aOptions
)
tag
aTs
.
.
.
)
;
}
private
:
template
<
size_t
i
=
0
typename
.
.
.
Args
>
static
void
DeserializeArguments
(
ProfileBufferEntryReader
&
aEntryReader
baseprofiler
:
:
SpliceableJSONWriter
&
aWriter
const
Args
&
.
.
.
aArgs
)
{
static_assert
(
sizeof
.
.
.
(
Args
)
=
=
i
"
We
should
have
collected
i
arguments
so
far
"
)
;
if
constexpr
(
i
<
scStreamFunctionParameterCount
)
{
auto
argument
=
aEntryReader
.
ReadObject
<
StreamFunctionParameter
<
i
>
>
(
)
;
DeserializeArguments
<
i
+
1
>
(
aEntryReader
aWriter
aArgs
.
.
.
argument
)
;
}
else
{
MarkerType
:
:
StreamJSONMarkerData
(
aWriter
aArgs
.
.
.
)
;
}
}
public
:
static
void
Deserialize
(
ProfileBufferEntryReader
&
aEntryReader
baseprofiler
:
:
SpliceableJSONWriter
&
aWriter
)
{
aWriter
.
StringProperty
(
"
type
"
MarkerType
:
:
MarkerTypeName
(
)
)
;
DeserializeArguments
(
aEntryReader
aWriter
)
;
}
}
;
template
<
>
struct
MarkerTypeSerialization
<
:
:
mozilla
:
:
baseprofiler
:
:
markers
:
:
NoPayload
>
{
}
;
template
<
typename
MarkerType
typename
.
.
.
Ts
>
static
ProfileBufferBlockIndex
AddMarkerWithOptionalStackToBuffer
(
ProfileChunkedBuffer
&
aBuffer
const
ProfilerString8View
&
aName
const
MarkerCategory
&
aCategory
MarkerOptions
&
&
aOptions
const
Ts
&
.
.
.
aTs
)
{
if
constexpr
(
std
:
:
is_same_v
<
MarkerType
:
:
mozilla
:
:
baseprofiler
:
:
markers
:
:
NoPayload
>
)
{
static_assert
(
sizeof
.
.
.
(
Ts
)
=
=
0
"
NoPayload
does
not
accept
any
payload
arguments
.
"
)
;
if
(
aOptions
.
Stack
(
)
.
GetChunkedBuffer
(
)
|
|
!
aOptions
.
InnerWindowId
(
)
.
IsUnspecified
(
)
)
{
struct
NoPayloadUserData
{
static
constexpr
Span
<
const
char
>
MarkerTypeName
(
)
{
return
MakeStringSpan
(
"
NoPayloadUserData
"
)
;
}
static
void
StreamJSONMarkerData
(
baseprofiler
:
:
SpliceableJSONWriter
&
aWriter
)
{
}
static
mozilla
:
:
MarkerSchema
MarkerTypeDisplay
(
)
{
using
MS
=
mozilla
:
:
MarkerSchema
;
MS
schema
{
MS
:
:
Location
:
:
MarkerChart
MS
:
:
Location
:
:
MarkerTable
}
;
return
schema
;
}
}
;
return
MarkerTypeSerialization
<
NoPayloadUserData
>
:
:
Serialize
(
aBuffer
aName
aCategory
std
:
:
move
(
aOptions
)
)
;
}
return
aBuffer
.
PutObjects
(
ProfileBufferEntryKind
:
:
Marker
std
:
:
move
(
aOptions
)
aName
aCategory
base_profiler_markers_detail
:
:
Streaming
:
:
DeserializerTag
(
0
)
)
;
}
else
{
return
MarkerTypeSerialization
<
MarkerType
>
:
:
Serialize
(
aBuffer
aName
aCategory
std
:
:
move
(
aOptions
)
aTs
.
.
.
)
;
}
}
using
BacktraceCaptureFunction
=
bool
(
*
)
(
ProfileChunkedBuffer
&
StackCaptureOptions
)
;
template
<
typename
MarkerType
typename
.
.
.
Ts
>
ProfileBufferBlockIndex
AddMarkerToBuffer
(
ProfileChunkedBuffer
&
aBuffer
const
ProfilerString8View
&
aName
const
MarkerCategory
&
aCategory
MarkerOptions
&
&
aOptions
BacktraceCaptureFunction
aBacktraceCaptureFunction
const
Ts
&
.
.
.
aTs
)
{
if
(
aOptions
.
ThreadId
(
)
.
IsUnspecified
(
)
)
{
aOptions
.
Set
(
MarkerThreadId
:
:
CurrentThread
(
)
)
;
}
if
(
aOptions
.
IsTimingUnspecified
(
)
)
{
aOptions
.
Set
(
MarkerTiming
:
:
InstantNow
(
)
)
;
}
StackCaptureOptions
captureOptions
=
aOptions
.
Stack
(
)
.
CaptureOptions
(
)
;
if
(
captureOptions
!
=
StackCaptureOptions
:
:
NoStack
)
{
ProfileBufferChunkManagerSingle
chunkManager
(
ProfileBufferChunkManager
:
:
scExpectedMaximumStackSize
)
;
ProfileChunkedBuffer
chunkedBuffer
(
ProfileChunkedBuffer
:
:
ThreadSafety
:
:
WithoutMutex
chunkManager
)
;
aOptions
.
StackRef
(
)
.
UseRequestedBacktrace
(
aBacktraceCaptureFunction
(
chunkedBuffer
captureOptions
)
?
&
chunkedBuffer
:
nullptr
)
;
return
AddMarkerWithOptionalStackToBuffer
<
MarkerType
>
(
aBuffer
aName
aCategory
std
:
:
move
(
aOptions
)
aTs
.
.
.
)
;
}
return
AddMarkerWithOptionalStackToBuffer
<
MarkerType
>
(
aBuffer
aName
aCategory
std
:
:
move
(
aOptions
)
aTs
.
.
.
)
;
}
template
<
typename
StackCallback
>
[
[
nodiscard
]
]
bool
DeserializeAfterKindAndStream
(
ProfileBufferEntryReader
&
aEntryReader
baseprofiler
:
:
SpliceableJSONWriter
&
aWriter
baseprofiler
:
:
BaseProfilerThreadId
aThreadIdOrUnspecified
StackCallback
&
&
aStackCallback
)
{
const
MarkerOptions
options
=
aEntryReader
.
ReadObject
<
MarkerOptions
>
(
)
;
if
(
aThreadIdOrUnspecified
.
IsSpecified
(
)
&
&
options
.
ThreadId
(
)
.
ThreadId
(
)
!
=
aThreadIdOrUnspecified
)
{
return
false
;
}
aWriter
.
StartArrayElement
(
)
;
{
aWriter
.
UniqueStringElement
(
aEntryReader
.
ReadObject
<
ProfilerString8View
>
(
)
)
;
const
double
startTime
=
options
.
Timing
(
)
.
GetStartTime
(
)
;
aWriter
.
TimeDoubleMsElement
(
startTime
)
;
const
double
endTime
=
options
.
Timing
(
)
.
GetEndTime
(
)
;
aWriter
.
TimeDoubleMsElement
(
endTime
)
;
aWriter
.
IntElement
(
static_cast
<
int64_t
>
(
options
.
Timing
(
)
.
MarkerPhase
(
)
)
)
;
MarkerCategory
category
=
aEntryReader
.
ReadObject
<
MarkerCategory
>
(
)
;
aWriter
.
IntElement
(
static_cast
<
int64_t
>
(
category
.
GetCategory
(
)
)
)
;
if
(
const
auto
tag
=
aEntryReader
.
ReadObject
<
mozilla
:
:
base_profiler_markers_detail
:
:
Streaming
:
:
DeserializerTag
>
(
)
;
tag
!
=
0
)
{
aWriter
.
StartObjectElement
(
JSONWriter
:
:
SingleLineStyle
)
;
{
if
(
!
options
.
InnerWindowId
(
)
.
IsUnspecified
(
)
)
{
aWriter
.
DoubleProperty
(
"
innerWindowID
"
static_cast
<
double
>
(
options
.
InnerWindowId
(
)
.
Id
(
)
)
)
;
}
if
(
ProfileChunkedBuffer
*
chunkedBuffer
=
options
.
Stack
(
)
.
GetChunkedBuffer
(
)
;
chunkedBuffer
)
{
aWriter
.
StartObjectProperty
(
"
stack
"
)
;
{
std
:
:
forward
<
StackCallback
>
(
aStackCallback
)
(
*
chunkedBuffer
)
;
}
aWriter
.
EndObject
(
)
;
}
auto
payloadType
=
static_cast
<
mozilla
:
:
MarkerPayloadType
>
(
aEntryReader
.
ReadObject
<
mozilla
:
:
MarkerPayloadTypeUnderlyingType
>
(
)
)
;
switch
(
payloadType
)
{
case
mozilla
:
:
MarkerPayloadType
:
:
Cpp
:
{
mozilla
:
:
base_profiler_markers_detail
:
:
Streaming
:
:
MarkerDataDeserializer
deserializer
=
mozilla
:
:
base_profiler_markers_detail
:
:
Streaming
:
:
DeserializerForTag
(
tag
)
;
MOZ_RELEASE_ASSERT
(
deserializer
)
;
deserializer
(
aEntryReader
aWriter
)
;
break
;
}
case
mozilla
:
:
MarkerPayloadType
:
:
Rust
:
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
payload
type
.
"
)
;
break
;
}
}
aWriter
.
EndObject
(
)
;
}
}
aWriter
.
EndArray
(
)
;
return
true
;
}
}
namespace
mozilla
{
template
<
typename
CHAR
>
struct
ProfileBufferEntryWriter
:
:
Serializer
<
ProfilerStringView
<
CHAR
>
>
{
static
Length
Bytes
(
const
ProfilerStringView
<
CHAR
>
&
aString
)
{
MOZ_RELEASE_ASSERT
(
aString
.
Length
(
)
<
std
:
:
numeric_limits
<
Length
>
:
:
max
(
)
/
2
"
Double
the
string
length
doesn
'
t
fit
in
Length
type
"
)
;
const
Length
stringLength
=
static_cast
<
Length
>
(
aString
.
Length
(
)
)
;
if
(
aString
.
IsLiteral
(
)
)
{
return
ULEB128Size
(
stringLength
<
<
1
|
0u
)
+
static_cast
<
ProfileChunkedBuffer
:
:
Length
>
(
sizeof
(
const
CHAR
*
)
)
;
}
return
ULEB128Size
(
(
stringLength
<
<
1
)
|
1u
)
+
stringLength
*
sizeof
(
CHAR
)
;
}
static
void
Write
(
ProfileBufferEntryWriter
&
aEW
const
ProfilerStringView
<
CHAR
>
&
aString
)
{
MOZ_RELEASE_ASSERT
(
aString
.
Length
(
)
<
std
:
:
numeric_limits
<
Length
>
:
:
max
(
)
/
2
"
Double
the
string
length
doesn
'
t
fit
in
Length
type
"
)
;
const
Span
<
const
CHAR
>
span
=
aString
;
if
(
aString
.
IsLiteral
(
)
)
{
aEW
.
WriteULEB128
(
span
.
Length
(
)
<
<
1
|
0u
)
;
aEW
.
WriteObject
(
WrapProfileBufferRawPointer
(
span
.
Elements
(
)
)
)
;
return
;
}
aEW
.
WriteULEB128
(
span
.
Length
(
)
<
<
1
|
1u
)
;
aEW
.
WriteBytes
(
span
.
Elements
(
)
span
.
LengthBytes
(
)
)
;
}
}
;
template
<
typename
CHAR
>
struct
ProfileBufferEntryReader
:
:
Deserializer
<
ProfilerStringView
<
CHAR
>
>
{
static
void
ReadInto
(
ProfileBufferEntryReader
&
aER
ProfilerStringView
<
CHAR
>
&
aString
)
{
aString
=
Read
(
aER
)
;
}
static
ProfilerStringView
<
CHAR
>
Read
(
ProfileBufferEntryReader
&
aER
)
{
const
Length
lengthAndIsLiteral
=
aER
.
ReadULEB128
<
Length
>
(
)
;
const
Length
stringLength
=
lengthAndIsLiteral
>
>
1
;
if
(
(
lengthAndIsLiteral
&
1u
)
=
=
0u
)
{
return
ProfilerStringView
<
CHAR
>
(
aER
.
ReadObject
<
const
CHAR
*
>
(
)
stringLength
ProfilerStringView
<
CHAR
>
:
:
Ownership
:
:
Literal
)
;
}
ProfileBufferEntryReader
:
:
DoubleSpanOfConstBytes
spans
=
aER
.
ReadSpans
(
stringLength
*
sizeof
(
CHAR
)
)
;
if
(
MOZ_LIKELY
(
spans
.
IsSingleSpan
(
)
)
&
&
reinterpret_cast
<
uintptr_t
>
(
spans
.
mFirstOrOnly
.
Elements
(
)
)
%
alignof
(
CHAR
)
=
=
0u
)
{
return
ProfilerStringView
<
CHAR
>
(
reinterpret_cast
<
const
CHAR
*
>
(
spans
.
mFirstOrOnly
.
Elements
(
)
)
stringLength
ProfilerStringView
<
CHAR
>
:
:
Ownership
:
:
Reference
)
;
}
else
{
CHAR
*
buffer
=
new
CHAR
[
stringLength
+
1
]
;
spans
.
CopyBytesTo
(
buffer
)
;
buffer
[
stringLength
]
=
CHAR
(
0
)
;
return
ProfilerStringView
<
CHAR
>
(
buffer
stringLength
ProfilerStringView
<
CHAR
>
:
:
Ownership
:
:
OwnedThroughStringView
)
;
}
}
}
;
template
<
>
struct
ProfileBufferEntryWriter
:
:
Serializer
<
MarkerCategory
>
{
static
Length
Bytes
(
const
MarkerCategory
&
aCategory
)
{
return
ULEB128Size
(
static_cast
<
uint32_t
>
(
aCategory
.
CategoryPair
(
)
)
)
;
}
static
void
Write
(
ProfileBufferEntryWriter
&
aEW
const
MarkerCategory
&
aCategory
)
{
aEW
.
WriteULEB128
(
static_cast
<
uint32_t
>
(
aCategory
.
CategoryPair
(
)
)
)
;
}
}
;
template
<
>
struct
ProfileBufferEntryReader
:
:
Deserializer
<
MarkerCategory
>
{
static
void
ReadInto
(
ProfileBufferEntryReader
&
aER
MarkerCategory
&
aCategory
)
{
aCategory
=
Read
(
aER
)
;
}
static
MarkerCategory
Read
(
ProfileBufferEntryReader
&
aER
)
{
return
MarkerCategory
(
static_cast
<
baseprofiler
:
:
ProfilingCategoryPair
>
(
aER
.
ReadULEB128
<
uint32_t
>
(
)
)
)
;
}
}
;
template
<
>
struct
ProfileBufferEntryWriter
:
:
Serializer
<
MarkerTiming
>
{
static
Length
Bytes
(
const
MarkerTiming
&
aTiming
)
{
MOZ_ASSERT
(
!
aTiming
.
IsUnspecified
(
)
)
;
const
auto
phase
=
aTiming
.
MarkerPhase
(
)
;
switch
(
phase
)
{
case
MarkerTiming
:
:
Phase
:
:
Instant
:
return
SumBytes
(
phase
aTiming
.
StartTime
(
)
)
;
case
MarkerTiming
:
:
Phase
:
:
Interval
:
return
SumBytes
(
phase
aTiming
.
StartTime
(
)
aTiming
.
EndTime
(
)
)
;
case
MarkerTiming
:
:
Phase
:
:
IntervalStart
:
return
SumBytes
(
phase
aTiming
.
StartTime
(
)
)
;
case
MarkerTiming
:
:
Phase
:
:
IntervalEnd
:
return
SumBytes
(
phase
aTiming
.
EndTime
(
)
)
;
default
:
MOZ_RELEASE_ASSERT
(
phase
=
=
MarkerTiming
:
:
Phase
:
:
Instant
|
|
phase
=
=
MarkerTiming
:
:
Phase
:
:
Interval
|
|
phase
=
=
MarkerTiming
:
:
Phase
:
:
IntervalStart
|
|
phase
=
=
MarkerTiming
:
:
Phase
:
:
IntervalEnd
)
;
return
0
;
}
}
static
void
Write
(
ProfileBufferEntryWriter
&
aEW
const
MarkerTiming
&
aTiming
)
{
MOZ_ASSERT
(
!
aTiming
.
IsUnspecified
(
)
)
;
const
auto
phase
=
aTiming
.
MarkerPhase
(
)
;
switch
(
phase
)
{
case
MarkerTiming
:
:
Phase
:
:
Instant
:
aEW
.
WriteObjects
(
phase
aTiming
.
StartTime
(
)
)
;
return
;
case
MarkerTiming
:
:
Phase
:
:
Interval
:
aEW
.
WriteObjects
(
phase
aTiming
.
StartTime
(
)
aTiming
.
EndTime
(
)
)
;
return
;
case
MarkerTiming
:
:
Phase
:
:
IntervalStart
:
aEW
.
WriteObjects
(
phase
aTiming
.
StartTime
(
)
)
;
return
;
case
MarkerTiming
:
:
Phase
:
:
IntervalEnd
:
aEW
.
WriteObjects
(
phase
aTiming
.
EndTime
(
)
)
;
return
;
default
:
MOZ_RELEASE_ASSERT
(
phase
=
=
MarkerTiming
:
:
Phase
:
:
Instant
|
|
phase
=
=
MarkerTiming
:
:
Phase
:
:
Interval
|
|
phase
=
=
MarkerTiming
:
:
Phase
:
:
IntervalStart
|
|
phase
=
=
MarkerTiming
:
:
Phase
:
:
IntervalEnd
)
;
return
;
}
}
}
;
template
<
>
struct
ProfileBufferEntryReader
:
:
Deserializer
<
MarkerTiming
>
{
static
void
ReadInto
(
ProfileBufferEntryReader
&
aER
MarkerTiming
&
aTiming
)
{
aTiming
.
mPhase
=
aER
.
ReadObject
<
MarkerTiming
:
:
Phase
>
(
)
;
switch
(
aTiming
.
mPhase
)
{
case
MarkerTiming
:
:
Phase
:
:
Instant
:
aTiming
.
mStartTime
=
aER
.
ReadObject
<
TimeStamp
>
(
)
;
aTiming
.
mEndTime
=
TimeStamp
{
}
;
break
;
case
MarkerTiming
:
:
Phase
:
:
Interval
:
aTiming
.
mStartTime
=
aER
.
ReadObject
<
TimeStamp
>
(
)
;
aTiming
.
mEndTime
=
aER
.
ReadObject
<
TimeStamp
>
(
)
;
break
;
case
MarkerTiming
:
:
Phase
:
:
IntervalStart
:
aTiming
.
mStartTime
=
aER
.
ReadObject
<
TimeStamp
>
(
)
;
aTiming
.
mEndTime
=
TimeStamp
{
}
;
break
;
case
MarkerTiming
:
:
Phase
:
:
IntervalEnd
:
aTiming
.
mStartTime
=
TimeStamp
{
}
;
aTiming
.
mEndTime
=
aER
.
ReadObject
<
TimeStamp
>
(
)
;
break
;
default
:
MOZ_RELEASE_ASSERT
(
aTiming
.
mPhase
=
=
MarkerTiming
:
:
Phase
:
:
Instant
|
|
aTiming
.
mPhase
=
=
MarkerTiming
:
:
Phase
:
:
Interval
|
|
aTiming
.
mPhase
=
=
MarkerTiming
:
:
Phase
:
:
IntervalStart
|
|
aTiming
.
mPhase
=
=
MarkerTiming
:
:
Phase
:
:
IntervalEnd
)
;
break
;
}
}
static
MarkerTiming
Read
(
ProfileBufferEntryReader
&
aER
)
{
TimeStamp
start
;
TimeStamp
end
;
auto
phase
=
aER
.
ReadObject
<
MarkerTiming
:
:
Phase
>
(
)
;
switch
(
phase
)
{
case
MarkerTiming
:
:
Phase
:
:
Instant
:
start
=
aER
.
ReadObject
<
TimeStamp
>
(
)
;
break
;
case
MarkerTiming
:
:
Phase
:
:
Interval
:
start
=
aER
.
ReadObject
<
TimeStamp
>
(
)
;
end
=
aER
.
ReadObject
<
TimeStamp
>
(
)
;
break
;
case
MarkerTiming
:
:
Phase
:
:
IntervalStart
:
start
=
aER
.
ReadObject
<
TimeStamp
>
(
)
;
break
;
case
MarkerTiming
:
:
Phase
:
:
IntervalEnd
:
end
=
aER
.
ReadObject
<
TimeStamp
>
(
)
;
break
;
default
:
MOZ_RELEASE_ASSERT
(
phase
=
=
MarkerTiming
:
:
Phase
:
:
Instant
|
|
phase
=
=
MarkerTiming
:
:
Phase
:
:
Interval
|
|
phase
=
=
MarkerTiming
:
:
Phase
:
:
IntervalStart
|
|
phase
=
=
MarkerTiming
:
:
Phase
:
:
IntervalEnd
)
;
break
;
}
return
MarkerTiming
(
start
end
phase
)
;
}
}
;
template
<
>
struct
ProfileBufferEntryWriter
:
:
Serializer
<
MarkerStack
>
{
static
Length
Bytes
(
const
MarkerStack
&
aStack
)
{
return
SumBytes
(
aStack
.
GetChunkedBuffer
(
)
)
;
}
static
void
Write
(
ProfileBufferEntryWriter
&
aEW
const
MarkerStack
&
aStack
)
{
aEW
.
WriteObject
(
aStack
.
GetChunkedBuffer
(
)
)
;
}
}
;
template
<
>
struct
ProfileBufferEntryReader
:
:
Deserializer
<
MarkerStack
>
{
static
void
ReadInto
(
ProfileBufferEntryReader
&
aER
MarkerStack
&
aStack
)
{
aStack
=
Read
(
aER
)
;
}
static
MarkerStack
Read
(
ProfileBufferEntryReader
&
aER
)
{
return
MarkerStack
(
aER
.
ReadObject
<
UniquePtr
<
ProfileChunkedBuffer
>
>
(
)
)
;
}
}
;
template
<
>
struct
ProfileBufferEntryWriter
:
:
Serializer
<
MarkerOptions
>
{
static
Length
Bytes
(
const
MarkerOptions
&
aOptions
)
{
return
SumBytes
(
aOptions
.
ThreadId
(
)
aOptions
.
Timing
(
)
aOptions
.
Stack
(
)
aOptions
.
InnerWindowId
(
)
)
;
}
static
void
Write
(
ProfileBufferEntryWriter
&
aEW
const
MarkerOptions
&
aOptions
)
{
aEW
.
WriteObjects
(
aOptions
.
ThreadId
(
)
aOptions
.
Timing
(
)
aOptions
.
Stack
(
)
aOptions
.
InnerWindowId
(
)
)
;
}
}
;
template
<
>
struct
ProfileBufferEntryReader
:
:
Deserializer
<
MarkerOptions
>
{
static
void
ReadInto
(
ProfileBufferEntryReader
&
aER
MarkerOptions
&
aOptions
)
{
aER
.
ReadIntoObjects
(
aOptions
.
mThreadId
aOptions
.
mTiming
aOptions
.
mStack
aOptions
.
mInnerWindowId
)
;
}
static
MarkerOptions
Read
(
ProfileBufferEntryReader
&
aER
)
{
MarkerOptions
options
;
ReadInto
(
aER
options
)
;
return
options
;
}
}
;
}
#
endif
