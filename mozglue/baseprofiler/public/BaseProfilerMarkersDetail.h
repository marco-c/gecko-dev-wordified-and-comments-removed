#
ifndef
BaseProfilerMarkersDetail_h
#
define
BaseProfilerMarkersDetail_h
#
ifndef
BaseProfilerMarkers_h
#
error
"
This
header
should
only
be
#
included
by
BaseProfilerMarkers
.
h
"
#
endif
#
include
"
mozilla
/
BaseProfilerMarkersPrerequisites
.
h
"
#
ifdef
MOZ_GECKO_PROFILER
#
include
"
mozilla
/
JSONWriter
.
h
"
#
include
<
limits
>
namespace
mozilla
:
:
baseprofiler
{
MFBT_API
ProfileChunkedBuffer
&
profiler_get_core_buffer
(
)
;
}
namespace
mozilla
:
:
base_profiler_markers_detail
{
inline
ProfileChunkedBuffer
&
CachedBaseCoreBuffer
(
)
{
static
ProfileChunkedBuffer
&
coreBuffer
=
baseprofiler
:
:
profiler_get_core_buffer
(
)
;
return
coreBuffer
;
}
struct
Streaming
{
using
Deserializer
=
void
(
*
)
(
ProfileBufferEntryReader
&
JSONWriter
&
)
;
using
DeserializerTag
=
unsigned
char
;
MFBT_API
static
DeserializerTag
TagForDeserializer
(
Deserializer
aDeserializer
)
;
MFBT_API
static
Deserializer
DeserializerForTag
(
DeserializerTag
aTag
)
;
}
;
}
namespace
mozilla
{
template
<
typename
CHAR
>
struct
ProfileBufferEntryWriter
:
:
Serializer
<
ProfilerStringView
<
CHAR
>
>
{
static
Length
Bytes
(
const
ProfilerStringView
<
CHAR
>
&
aString
)
{
MOZ_RELEASE_ASSERT
(
aString
.
Length
(
)
<
std
:
:
numeric_limits
<
Length
>
:
:
max
(
)
/
2
"
Double
the
string
length
doesn
'
t
fit
in
Length
type
"
)
;
const
Length
stringLength
=
static_cast
<
Length
>
(
aString
.
Length
(
)
)
;
if
(
aString
.
IsLiteral
(
)
)
{
return
ULEB128Size
(
stringLength
<
<
1
|
0u
)
+
static_cast
<
ProfileChunkedBuffer
:
:
Length
>
(
sizeof
(
const
CHAR
*
)
)
;
}
return
ULEB128Size
(
(
stringLength
<
<
1
)
|
1u
)
+
stringLength
*
sizeof
(
CHAR
)
;
}
static
void
Write
(
ProfileBufferEntryWriter
&
aEW
const
ProfilerStringView
<
CHAR
>
&
aString
)
{
MOZ_RELEASE_ASSERT
(
aString
.
Length
(
)
<
std
:
:
numeric_limits
<
Length
>
:
:
max
(
)
/
2
"
Double
the
string
length
doesn
'
t
fit
in
Length
type
"
)
;
const
Length
stringLength
=
static_cast
<
Length
>
(
aString
.
Length
(
)
)
;
if
(
aString
.
IsLiteral
(
)
)
{
aEW
.
WriteULEB128
(
stringLength
<
<
1
|
0u
)
;
aEW
.
WriteObject
(
WrapProfileBufferRawPointer
(
aString
.
Data
(
)
)
)
;
return
;
}
aEW
.
WriteULEB128
(
stringLength
<
<
1
|
1u
)
;
aEW
.
WriteBytes
(
aString
.
Data
(
)
stringLength
*
sizeof
(
CHAR
)
)
;
}
}
;
template
<
typename
CHAR
>
struct
ProfileBufferEntryReader
:
:
Deserializer
<
ProfilerStringView
<
CHAR
>
>
{
static
void
ReadInto
(
ProfileBufferEntryReader
&
aER
ProfilerStringView
<
CHAR
>
&
aString
)
{
const
Length
lengthAndIsLiteral
=
aER
.
ReadULEB128
<
Length
>
(
)
;
const
Length
stringLength
=
lengthAndIsLiteral
>
>
1
;
if
(
(
lengthAndIsLiteral
&
1u
)
=
=
0u
)
{
aString
.
mStringView
=
std
:
:
basic_string_view
<
CHAR
>
(
aER
.
ReadObject
<
const
CHAR
*
>
(
)
stringLength
)
;
aString
.
mOwnership
=
ProfilerStringView
<
CHAR
>
:
:
Ownership
:
:
Literal
;
return
;
}
CHAR
*
buffer
=
new
CHAR
[
stringLength
+
1
]
;
aER
.
ReadBytes
(
buffer
stringLength
*
sizeof
(
CHAR
)
)
;
buffer
[
stringLength
]
=
CHAR
(
0
)
;
aString
.
mStringView
=
std
:
:
basic_string_view
<
CHAR
>
(
buffer
stringLength
)
;
aString
.
mOwnership
=
ProfilerStringView
<
CHAR
>
:
:
Ownership
:
:
OwnedThroughStringView
;
}
static
ProfilerStringView
<
CHAR
>
Read
(
ProfileBufferEntryReader
&
aER
)
{
const
Length
lengthAndIsLiteral
=
aER
.
ReadULEB128
<
Length
>
(
)
;
const
Length
stringLength
=
lengthAndIsLiteral
>
>
1
;
if
(
(
lengthAndIsLiteral
&
1u
)
=
=
0u
)
{
return
ProfilerStringView
<
CHAR
>
(
aER
.
ReadObject
<
const
CHAR
*
>
(
)
stringLength
ProfilerStringView
<
CHAR
>
:
:
Ownership
:
:
Literal
)
;
}
CHAR
*
buffer
=
new
CHAR
[
stringLength
+
1
]
;
aER
.
ReadBytes
(
buffer
stringLength
*
sizeof
(
CHAR
)
)
;
buffer
[
stringLength
]
=
CHAR
(
0
)
;
return
ProfilerStringView
<
CHAR
>
(
buffer
stringLength
ProfilerStringView
<
CHAR
>
:
:
Ownership
:
:
OwnedThroughStringView
)
;
}
}
;
template
<
>
struct
ProfileBufferEntryWriter
:
:
Serializer
<
MarkerCategory
>
{
static
Length
Bytes
(
const
MarkerCategory
&
aCategory
)
{
return
ULEB128Size
(
static_cast
<
uint32_t
>
(
aCategory
.
CategoryPair
(
)
)
)
+
ULEB128Size
(
static_cast
<
uint32_t
>
(
aCategory
.
Category
(
)
)
)
;
}
static
void
Write
(
ProfileBufferEntryWriter
&
aEW
const
MarkerCategory
&
aCategory
)
{
aEW
.
WriteULEB128
(
static_cast
<
uint32_t
>
(
aCategory
.
CategoryPair
(
)
)
)
;
aEW
.
WriteULEB128
(
static_cast
<
uint32_t
>
(
aCategory
.
Category
(
)
)
)
;
}
}
;
template
<
>
struct
ProfileBufferEntryReader
:
:
Deserializer
<
MarkerCategory
>
{
static
void
ReadInto
(
ProfileBufferEntryReader
&
aER
MarkerCategory
&
aCategory
)
{
aCategory
.
mCategoryPair
=
static_cast
<
baseprofiler
:
:
ProfilingCategoryPair
>
(
aER
.
ReadULEB128
<
uint32_t
>
(
)
)
;
aCategory
.
mCategory
=
static_cast
<
baseprofiler
:
:
ProfilingCategory
>
(
aER
.
ReadULEB128
<
uint32_t
>
(
)
)
;
}
static
MarkerCategory
Read
(
ProfileBufferEntryReader
&
aER
)
{
return
MarkerCategory
(
static_cast
<
baseprofiler
:
:
ProfilingCategoryPair
>
(
aER
.
ReadULEB128
<
uint32_t
>
(
)
)
static_cast
<
baseprofiler
:
:
ProfilingCategory
>
(
aER
.
ReadULEB128
<
uint32_t
>
(
)
)
)
;
}
}
;
template
<
>
struct
ProfileBufferEntryWriter
:
:
Serializer
<
MarkerTiming
>
{
static
Length
Bytes
(
const
MarkerTiming
&
aTiming
)
{
MOZ_ASSERT
(
!
aTiming
.
IsUnspecified
(
)
)
;
const
auto
phase
=
aTiming
.
MarkerPhase
(
)
;
switch
(
phase
)
{
case
MarkerTiming
:
:
Phase
:
:
Instant
:
return
SumBytes
(
phase
aTiming
.
StartTime
(
)
)
;
case
MarkerTiming
:
:
Phase
:
:
Interval
:
return
SumBytes
(
phase
aTiming
.
StartTime
(
)
aTiming
.
EndTime
(
)
)
;
case
MarkerTiming
:
:
Phase
:
:
IntervalStart
:
return
SumBytes
(
phase
aTiming
.
StartTime
(
)
)
;
case
MarkerTiming
:
:
Phase
:
:
IntervalEnd
:
return
SumBytes
(
phase
aTiming
.
EndTime
(
)
)
;
default
:
MOZ_RELEASE_ASSERT
(
phase
=
=
MarkerTiming
:
:
Phase
:
:
Instant
|
|
phase
=
=
MarkerTiming
:
:
Phase
:
:
Interval
|
|
phase
=
=
MarkerTiming
:
:
Phase
:
:
IntervalStart
|
|
phase
=
=
MarkerTiming
:
:
Phase
:
:
IntervalEnd
)
;
return
0
;
}
}
static
void
Write
(
ProfileBufferEntryWriter
&
aEW
const
MarkerTiming
&
aTiming
)
{
MOZ_ASSERT
(
!
aTiming
.
IsUnspecified
(
)
)
;
const
auto
phase
=
aTiming
.
MarkerPhase
(
)
;
switch
(
phase
)
{
case
MarkerTiming
:
:
Phase
:
:
Instant
:
aEW
.
WriteObjects
(
phase
aTiming
.
StartTime
(
)
)
;
return
;
case
MarkerTiming
:
:
Phase
:
:
Interval
:
aEW
.
WriteObjects
(
phase
aTiming
.
StartTime
(
)
aTiming
.
EndTime
(
)
)
;
return
;
case
MarkerTiming
:
:
Phase
:
:
IntervalStart
:
aEW
.
WriteObjects
(
phase
aTiming
.
StartTime
(
)
)
;
return
;
case
MarkerTiming
:
:
Phase
:
:
IntervalEnd
:
aEW
.
WriteObjects
(
phase
aTiming
.
EndTime
(
)
)
;
return
;
default
:
MOZ_RELEASE_ASSERT
(
phase
=
=
MarkerTiming
:
:
Phase
:
:
Instant
|
|
phase
=
=
MarkerTiming
:
:
Phase
:
:
Interval
|
|
phase
=
=
MarkerTiming
:
:
Phase
:
:
IntervalStart
|
|
phase
=
=
MarkerTiming
:
:
Phase
:
:
IntervalEnd
)
;
return
;
}
}
}
;
template
<
>
struct
ProfileBufferEntryReader
:
:
Deserializer
<
MarkerTiming
>
{
static
void
ReadInto
(
ProfileBufferEntryReader
&
aER
MarkerTiming
&
aTiming
)
{
aTiming
.
mPhase
=
aER
.
ReadObject
<
MarkerTiming
:
:
Phase
>
(
)
;
switch
(
aTiming
.
mPhase
)
{
case
MarkerTiming
:
:
Phase
:
:
Instant
:
aTiming
.
mStartTime
=
aER
.
ReadObject
<
TimeStamp
>
(
)
;
aTiming
.
mEndTime
=
TimeStamp
{
}
;
break
;
case
MarkerTiming
:
:
Phase
:
:
Interval
:
aTiming
.
mStartTime
=
aER
.
ReadObject
<
TimeStamp
>
(
)
;
aTiming
.
mEndTime
=
aER
.
ReadObject
<
TimeStamp
>
(
)
;
break
;
case
MarkerTiming
:
:
Phase
:
:
IntervalStart
:
aTiming
.
mStartTime
=
aER
.
ReadObject
<
TimeStamp
>
(
)
;
aTiming
.
mEndTime
=
TimeStamp
{
}
;
break
;
case
MarkerTiming
:
:
Phase
:
:
IntervalEnd
:
aTiming
.
mStartTime
=
TimeStamp
{
}
;
aTiming
.
mEndTime
=
aER
.
ReadObject
<
TimeStamp
>
(
)
;
break
;
default
:
MOZ_RELEASE_ASSERT
(
aTiming
.
mPhase
=
=
MarkerTiming
:
:
Phase
:
:
Instant
|
|
aTiming
.
mPhase
=
=
MarkerTiming
:
:
Phase
:
:
Interval
|
|
aTiming
.
mPhase
=
=
MarkerTiming
:
:
Phase
:
:
IntervalStart
|
|
aTiming
.
mPhase
=
=
MarkerTiming
:
:
Phase
:
:
IntervalEnd
)
;
break
;
}
}
static
MarkerTiming
Read
(
ProfileBufferEntryReader
&
aER
)
{
TimeStamp
start
;
TimeStamp
end
;
auto
phase
=
aER
.
ReadObject
<
MarkerTiming
:
:
Phase
>
(
)
;
switch
(
phase
)
{
case
MarkerTiming
:
:
Phase
:
:
Instant
:
start
=
aER
.
ReadObject
<
TimeStamp
>
(
)
;
break
;
case
MarkerTiming
:
:
Phase
:
:
Interval
:
start
=
aER
.
ReadObject
<
TimeStamp
>
(
)
;
end
=
aER
.
ReadObject
<
TimeStamp
>
(
)
;
break
;
case
MarkerTiming
:
:
Phase
:
:
IntervalStart
:
start
=
aER
.
ReadObject
<
TimeStamp
>
(
)
;
break
;
case
MarkerTiming
:
:
Phase
:
:
IntervalEnd
:
end
=
aER
.
ReadObject
<
TimeStamp
>
(
)
;
break
;
default
:
MOZ_RELEASE_ASSERT
(
phase
=
=
MarkerTiming
:
:
Phase
:
:
Instant
|
|
phase
=
=
MarkerTiming
:
:
Phase
:
:
Interval
|
|
phase
=
=
MarkerTiming
:
:
Phase
:
:
IntervalStart
|
|
phase
=
=
MarkerTiming
:
:
Phase
:
:
IntervalEnd
)
;
break
;
}
return
MarkerTiming
(
start
end
phase
)
;
}
}
;
template
<
>
struct
ProfileBufferEntryWriter
:
:
Serializer
<
MarkerStack
>
{
static
Length
Bytes
(
const
MarkerStack
&
aStack
)
{
return
SumBytes
(
aStack
.
GetChunkedBuffer
(
)
)
;
}
static
void
Write
(
ProfileBufferEntryWriter
&
aEW
const
MarkerStack
&
aStack
)
{
aEW
.
WriteObject
(
aStack
.
GetChunkedBuffer
(
)
)
;
}
}
;
template
<
>
struct
ProfileBufferEntryReader
:
:
Deserializer
<
MarkerStack
>
{
static
void
ReadInto
(
ProfileBufferEntryReader
&
aER
MarkerStack
&
aStack
)
{
aStack
=
Read
(
aER
)
;
}
static
MarkerStack
Read
(
ProfileBufferEntryReader
&
aER
)
{
return
MarkerStack
(
aER
.
ReadObject
<
UniquePtr
<
ProfileChunkedBuffer
>
>
(
)
)
;
}
}
;
template
<
>
struct
ProfileBufferEntryWriter
:
:
Serializer
<
MarkerOptions
>
{
static
Length
Bytes
(
const
MarkerOptions
&
aOptions
)
{
return
SumBytes
(
aOptions
.
Category
(
)
aOptions
.
ThreadId
(
)
aOptions
.
Timing
(
)
aOptions
.
Stack
(
)
aOptions
.
InnerWindowId
(
)
)
;
}
static
void
Write
(
ProfileBufferEntryWriter
&
aEW
const
MarkerOptions
&
aOptions
)
{
aEW
.
WriteObjects
(
aOptions
.
Category
(
)
aOptions
.
ThreadId
(
)
aOptions
.
Timing
(
)
aOptions
.
Stack
(
)
aOptions
.
InnerWindowId
(
)
)
;
}
}
;
template
<
>
struct
ProfileBufferEntryReader
:
:
Deserializer
<
MarkerOptions
>
{
static
void
ReadInto
(
ProfileBufferEntryReader
&
aER
MarkerOptions
&
aOptions
)
{
aER
.
ReadIntoObjects
(
aOptions
.
mCategory
aOptions
.
mThreadId
aOptions
.
mTiming
aOptions
.
mStack
aOptions
.
mInnerWindowId
)
;
}
static
MarkerOptions
Read
(
ProfileBufferEntryReader
&
aER
)
{
MarkerOptions
options
;
ReadInto
(
aER
options
)
;
return
options
;
}
}
;
}
#
endif
#
endif
