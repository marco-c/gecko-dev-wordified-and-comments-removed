#
ifndef
BaseProfilerMarkersDetail_h
#
define
BaseProfilerMarkersDetail_h
#
ifndef
BaseProfilerMarkers_h
#
error
"
This
header
should
only
be
#
included
by
BaseProfilerMarkers
.
h
"
#
endif
#
include
"
mozilla
/
BaseProfilerMarkersPrerequisites
.
h
"
#
ifdef
MOZ_GECKO_PROFILER
#
include
<
limits
>
namespace
mozilla
:
:
baseprofiler
{
MFBT_API
ProfileChunkedBuffer
&
profiler_get_core_buffer
(
)
;
}
namespace
mozilla
:
:
base_profiler_markers_detail
{
inline
ProfileChunkedBuffer
&
CachedBaseCoreBuffer
(
)
{
static
ProfileChunkedBuffer
&
coreBuffer
=
baseprofiler
:
:
profiler_get_core_buffer
(
)
;
return
coreBuffer
;
}
}
namespace
mozilla
{
template
<
typename
CHAR
>
struct
ProfileBufferEntryWriter
:
:
Serializer
<
ProfilerStringView
<
CHAR
>
>
{
static
Length
Bytes
(
const
ProfilerStringView
<
CHAR
>
&
aString
)
{
MOZ_RELEASE_ASSERT
(
aString
.
Length
(
)
<
std
:
:
numeric_limits
<
Length
>
:
:
max
(
)
/
2
"
Double
the
string
length
doesn
'
t
fit
in
Length
type
"
)
;
const
Length
stringLength
=
static_cast
<
Length
>
(
aString
.
Length
(
)
)
;
if
(
aString
.
IsLiteral
(
)
)
{
return
ULEB128Size
(
stringLength
<
<
1
|
0u
)
+
static_cast
<
ProfileChunkedBuffer
:
:
Length
>
(
sizeof
(
const
CHAR
*
)
)
;
}
return
ULEB128Size
(
(
stringLength
<
<
1
)
|
1u
)
+
stringLength
*
sizeof
(
CHAR
)
;
}
static
void
Write
(
ProfileBufferEntryWriter
&
aEW
const
ProfilerStringView
<
CHAR
>
&
aString
)
{
MOZ_RELEASE_ASSERT
(
aString
.
Length
(
)
<
std
:
:
numeric_limits
<
Length
>
:
:
max
(
)
/
2
"
Double
the
string
length
doesn
'
t
fit
in
Length
type
"
)
;
const
Length
stringLength
=
static_cast
<
Length
>
(
aString
.
Length
(
)
)
;
if
(
aString
.
IsLiteral
(
)
)
{
aEW
.
WriteULEB128
(
stringLength
<
<
1
|
0u
)
;
aEW
.
WriteObject
(
WrapProfileBufferRawPointer
(
aString
.
Data
(
)
)
)
;
return
;
}
aEW
.
WriteULEB128
(
stringLength
<
<
1
|
1u
)
;
aEW
.
WriteBytes
(
aString
.
Data
(
)
stringLength
*
sizeof
(
CHAR
)
)
;
}
}
;
template
<
typename
CHAR
>
struct
ProfileBufferEntryReader
:
:
Deserializer
<
ProfilerStringView
<
CHAR
>
>
{
static
void
ReadInto
(
ProfileBufferEntryReader
&
aER
ProfilerStringView
<
CHAR
>
&
aString
)
{
const
Length
lengthAndIsLiteral
=
aER
.
ReadULEB128
<
Length
>
(
)
;
const
Length
stringLength
=
lengthAndIsLiteral
>
>
1
;
if
(
(
lengthAndIsLiteral
&
1u
)
=
=
0u
)
{
aString
.
mStringView
=
std
:
:
basic_string_view
<
CHAR
>
(
aER
.
ReadObject
<
const
CHAR
*
>
(
)
stringLength
)
;
aString
.
mOwnership
=
ProfilerStringView
<
CHAR
>
:
:
Ownership
:
:
Literal
;
return
;
}
CHAR
*
buffer
=
new
CHAR
[
stringLength
+
1
]
;
aER
.
ReadBytes
(
buffer
stringLength
*
sizeof
(
CHAR
)
)
;
buffer
[
stringLength
]
=
CHAR
(
0
)
;
aString
.
mStringView
=
std
:
:
basic_string_view
<
CHAR
>
(
buffer
stringLength
)
;
aString
.
mOwnership
=
ProfilerStringView
<
CHAR
>
:
:
Ownership
:
:
OwnedThroughStringView
;
}
static
ProfilerStringView
<
CHAR
>
Read
(
ProfileBufferEntryReader
&
aER
)
{
const
Length
lengthAndIsLiteral
=
aER
.
ReadULEB128
<
Length
>
(
)
;
const
Length
stringLength
=
lengthAndIsLiteral
>
>
1
;
if
(
(
lengthAndIsLiteral
&
1u
)
=
=
0u
)
{
return
ProfilerStringView
<
CHAR
>
(
aER
.
ReadObject
<
const
CHAR
*
>
(
)
stringLength
ProfilerStringView
<
CHAR
>
:
:
Ownership
:
:
Literal
)
;
}
CHAR
*
buffer
=
new
CHAR
[
stringLength
+
1
]
;
aER
.
ReadBytes
(
buffer
stringLength
*
sizeof
(
CHAR
)
)
;
buffer
[
stringLength
]
=
CHAR
(
0
)
;
return
ProfilerStringView
<
CHAR
>
(
buffer
stringLength
ProfilerStringView
<
CHAR
>
:
:
Ownership
:
:
OwnedThroughStringView
)
;
}
}
;
}
#
endif
#
endif
