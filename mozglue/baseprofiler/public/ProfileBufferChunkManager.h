#
ifndef
ProfileBufferChunkManager_h
#
define
ProfileBufferChunkManager_h
#
include
"
mozilla
/
ProfileBufferChunk
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
<
functional
>
namespace
mozilla
{
class
ProfileBufferChunkManager
{
public
:
virtual
~
ProfileBufferChunkManager
(
)
#
ifdef
DEBUG
{
MOZ_ASSERT
(
!
mUser
"
Still
registered
when
being
destroyed
"
)
;
}
#
else
=
default
;
#
endif
virtual
MOZ_MUST_USE
size_t
MaxTotalSize
(
)
const
=
0
;
virtual
MOZ_MUST_USE
UniquePtr
<
ProfileBufferChunk
>
GetChunk
(
)
=
0
;
virtual
void
RequestChunk
(
std
:
:
function
<
void
(
UniquePtr
<
ProfileBufferChunk
>
)
>
&
&
aChunkReceiver
)
=
0
;
virtual
void
FulfillChunkRequests
(
)
=
0
;
virtual
void
ReleaseChunks
(
UniquePtr
<
ProfileBufferChunk
>
aChunks
)
=
0
;
virtual
void
SetChunkDestroyedCallback
(
std
:
:
function
<
void
(
const
ProfileBufferChunk
&
)
>
&
&
aChunkDestroyedCallback
)
=
0
;
virtual
MOZ_MUST_USE
UniquePtr
<
ProfileBufferChunk
>
GetExtantReleasedChunks
(
)
=
0
;
template
<
typename
Callback
>
MOZ_MUST_USE
auto
PeekExtantReleasedChunks
(
Callback
&
&
aCallback
)
{
const
ProfileBufferChunk
*
chunks
=
PeekExtantReleasedChunksAndLock
(
)
;
auto
unlock
=
MakeScopeExit
(
[
&
]
(
)
{
UnlockAfterPeekExtantReleasedChunks
(
)
;
}
)
;
return
std
:
:
forward
<
Callback
>
(
aCallback
)
(
chunks
)
;
}
virtual
void
ForgetUnreleasedChunks
(
)
=
0
;
virtual
MOZ_MUST_USE
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
=
0
;
virtual
MOZ_MUST_USE
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
=
0
;
protected
:
virtual
const
ProfileBufferChunk
*
PeekExtantReleasedChunksAndLock
(
)
=
0
;
virtual
void
UnlockAfterPeekExtantReleasedChunks
(
)
=
0
;
#
ifdef
DEBUG
public
:
void
RegisteredWith
(
const
void
*
aUser
)
{
MOZ_ASSERT
(
!
mUser
)
;
MOZ_ASSERT
(
aUser
)
;
mUser
=
aUser
;
}
void
DeregisteredFrom
(
const
void
*
aUser
)
{
MOZ_ASSERT
(
mUser
=
=
aUser
)
;
mUser
=
nullptr
;
}
protected
:
const
void
*
mUser
=
nullptr
;
#
endif
}
;
}
#
endif
