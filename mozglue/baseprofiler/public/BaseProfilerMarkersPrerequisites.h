#
ifndef
BaseProfilerMarkersPrerequisites_h
#
define
BaseProfilerMarkersPrerequisites_h
#
ifdef
MOZ_GECKO_PROFILER
#
include
"
mozilla
/
ProfileChunkedBuffer
.
h
"
#
include
<
string_view
>
#
include
<
string
>
#
include
<
type_traits
>
#
include
<
utility
>
namespace
mozilla
{
template
<
typename
CHAR
>
constexpr
const
CHAR
*
LiteralEmptyStringPointer
(
)
{
static_assert
(
std
:
:
is_same_v
<
CHAR
char
>
|
|
std
:
:
is_same_v
<
CHAR
char16_t
>
"
Only
char
and
char16_t
are
supported
in
Firefox
"
)
;
if
constexpr
(
std
:
:
is_same_v
<
CHAR
char
>
)
{
return
"
"
;
}
if
constexpr
(
std
:
:
is_same_v
<
CHAR
char16_t
>
)
{
return
u
"
"
;
}
}
template
<
typename
CHAR
>
constexpr
std
:
:
basic_string_view
<
CHAR
>
LiteralEmptyStringView
(
)
{
static_assert
(
std
:
:
is_same_v
<
CHAR
char
>
|
|
std
:
:
is_same_v
<
CHAR
char16_t
>
"
Only
char
and
char16_t
are
supported
in
Firefox
"
)
;
using
namespace
std
:
:
literals
:
:
string_view_literals
;
if
constexpr
(
std
:
:
is_same_v
<
CHAR
char
>
)
{
return
"
"
sv
;
}
if
constexpr
(
std
:
:
is_same_v
<
CHAR
char16_t
>
)
{
return
u
"
"
sv
;
}
}
template
<
typename
CHAR
>
class
MOZ_STACK_CLASS
ProfilerStringView
{
public
:
constexpr
ProfilerStringView
(
)
=
default
;
ProfilerStringView
(
const
ProfilerStringView
&
)
=
delete
;
ProfilerStringView
&
operator
=
(
const
ProfilerStringView
&
)
=
delete
;
constexpr
ProfilerStringView
(
ProfilerStringView
&
&
aOther
)
:
mStringView
(
std
:
:
move
(
aOther
.
mStringView
)
)
mOwnership
(
aOther
.
mOwnership
)
{
if
(
mOwnership
=
=
Ownership
:
:
OwnedThroughStringView
)
{
aOther
.
mStringView
=
LiteralEmptyStringView
<
CHAR
>
(
)
;
aOther
.
mOwnership
=
Ownership
:
:
Literal
;
}
}
constexpr
ProfilerStringView
&
operator
=
(
ProfilerStringView
&
&
aOther
)
{
mStringView
=
std
:
:
move
(
aOther
.
mStringView
)
;
mOwnership
=
aOther
.
mOwnership
;
if
(
mOwnership
=
=
Ownership
:
:
OwnedThroughStringView
)
{
aOther
.
mStringView
=
LiteralEmptyStringView
<
CHAR
>
(
)
;
aOther
.
mOwnership
=
Ownership
:
:
Literal
;
}
return
*
this
;
}
~
ProfilerStringView
(
)
{
if
(
MOZ_UNLIKELY
(
mOwnership
=
=
Ownership
:
:
OwnedThroughStringView
)
)
{
delete
mStringView
.
data
(
)
;
}
}
constexpr
MOZ_IMPLICIT
ProfilerStringView
(
decltype
(
nullptr
)
)
{
}
template
<
size_t
Np1
>
constexpr
MOZ_IMPLICIT
ProfilerStringView
(
const
CHAR
(
&
aLiteralString
)
[
Np1
]
)
:
ProfilerStringView
(
aLiteralString
Np1
-
1
Ownership
:
:
Literal
)
{
}
constexpr
ProfilerStringView
(
const
CHAR
*
aString
size_t
aLength
)
:
ProfilerStringView
(
aString
aLength
Ownership
:
:
Reference
)
{
}
constexpr
MOZ_IMPLICIT
ProfilerStringView
(
const
std
:
:
basic_string_view
<
CHAR
>
&
aStringView
)
:
ProfilerStringView
(
aStringView
.
data
(
)
aStringView
.
length
(
)
Ownership
:
:
Reference
)
{
}
constexpr
MOZ_IMPLICIT
ProfilerStringView
(
std
:
:
basic_string_view
<
CHAR
>
&
&
aStringView
)
:
ProfilerStringView
(
aStringView
.
data
(
)
aStringView
.
length
(
)
Ownership
:
:
Reference
)
{
}
constexpr
MOZ_IMPLICIT
ProfilerStringView
(
const
std
:
:
string
&
aString
)
:
ProfilerStringView
(
aString
.
data
(
)
aString
.
length
(
)
Ownership
:
:
Reference
)
{
}
static
constexpr
ProfilerStringView
WrapNullTerminatedString
(
const
CHAR
*
aString
)
{
return
ProfilerStringView
(
aString
aString
?
std
:
:
char_traits
<
char
>
:
:
length
(
aString
)
:
0
Ownership
:
:
Reference
)
;
}
template
<
typename
String
typename
DataReturnType
=
decltype
(
std
:
:
declval
<
const
String
>
(
)
.
Data
(
)
)
typename
LengthReturnType
=
decltype
(
std
:
:
declval
<
const
String
>
(
)
.
Length
(
)
)
typename
IsLiteralReturnType
=
decltype
(
std
:
:
declval
<
const
String
>
(
)
.
IsLiteral
(
)
)
typename
=
std
:
:
enable_if_t
<
std
:
:
is_convertible_v
<
DataReturnType
const
CHAR
*
>
&
&
std
:
:
is_integral_v
<
LengthReturnType
>
&
&
std
:
:
is_same_v
<
IsLiteralReturnType
bool
>
>
>
constexpr
MOZ_IMPLICIT
ProfilerStringView
(
const
String
&
aString
)
:
ProfilerStringView
(
static_cast
<
const
CHAR
*
>
(
aString
.
Data
(
)
)
aString
.
Length
(
)
aString
.
IsLiteral
(
)
?
Ownership
:
:
Literal
:
Ownership
:
:
Reference
)
{
}
[
[
nodiscard
]
]
constexpr
const
std
:
:
basic_string_view
<
CHAR
>
&
StringView
(
)
const
{
return
mStringView
;
}
[
[
nodiscard
]
]
constexpr
const
CHAR
*
Data
(
)
const
{
return
mStringView
.
data
(
)
;
}
[
[
nodiscard
]
]
constexpr
size_t
Length
(
)
const
{
return
mStringView
.
length
(
)
;
}
[
[
nodiscard
]
]
constexpr
bool
IsLiteral
(
)
const
{
return
mOwnership
=
=
Ownership
:
:
Literal
;
}
[
[
nodiscard
]
]
constexpr
bool
IsReference
(
)
const
{
return
mOwnership
=
=
Ownership
:
:
Reference
;
}
[
[
nodiscard
]
]
std
:
:
basic_string
<
CHAR
>
String
(
)
const
{
return
std
:
:
basic_string
<
CHAR
>
(
mStringView
)
;
}
private
:
enum
class
Ownership
{
Literal
Reference
OwnedThroughStringView
}
;
friend
ProfileBufferEntryReader
:
:
Deserializer
<
ProfilerStringView
>
;
constexpr
ProfilerStringView
(
const
CHAR
*
aString
size_t
aLength
Ownership
aOwnership
)
:
mStringView
(
aString
?
std
:
:
basic_string_view
<
CHAR
>
(
aString
aLength
)
:
LiteralEmptyStringView
<
CHAR
>
(
)
)
mOwnership
(
aString
?
aOwnership
:
Ownership
:
:
Literal
)
{
}
std
:
:
basic_string_view
<
CHAR
>
mStringView
=
LiteralEmptyStringView
<
CHAR
>
(
)
;
Ownership
mOwnership
=
Ownership
:
:
Literal
;
}
;
using
ProfilerString8View
=
ProfilerStringView
<
char
>
;
using
ProfilerString16View
=
ProfilerStringView
<
char16_t
>
;
class
MarkerOptions
;
class
MarkerCategory
{
public
:
constexpr
MarkerCategory
(
baseprofiler
:
:
ProfilingCategoryPair
aCategoryPair
baseprofiler
:
:
ProfilingCategory
aCategory
)
:
mCategoryPair
(
aCategoryPair
)
mCategory
(
aCategory
)
{
}
constexpr
baseprofiler
:
:
ProfilingCategoryPair
CategoryPair
(
)
const
{
return
mCategoryPair
;
}
constexpr
baseprofiler
:
:
ProfilingCategory
Category
(
)
const
{
return
mCategory
;
}
private
:
friend
MarkerOptions
;
constexpr
MarkerCategory
(
)
=
default
;
friend
ProfileBufferEntryReader
:
:
Deserializer
<
MarkerCategory
>
;
baseprofiler
:
:
ProfilingCategoryPair
mCategoryPair
=
baseprofiler
:
:
ProfilingCategoryPair
:
:
OTHER
;
baseprofiler
:
:
ProfilingCategory
mCategory
=
baseprofiler
:
:
ProfilingCategory
:
:
OTHER
;
}
;
namespace
baseprofiler
:
:
category
{
#
define
CATEGORY_ENUM_BEGIN_CATEGORY
(
name
labelAsString
color
)
#
define
CATEGORY_ENUM_SUBCATEGORY
(
supercategory
name
labelAsString
)
\
static
constexpr
MarkerCategory
name
{
ProfilingCategoryPair
:
:
name
\
ProfilingCategory
:
:
supercategory
}
;
#
define
CATEGORY_ENUM_END_CATEGORY
MOZ_PROFILING_CATEGORY_LIST
(
CATEGORY_ENUM_BEGIN_CATEGORY
CATEGORY_ENUM_SUBCATEGORY
CATEGORY_ENUM_END_CATEGORY
)
#
undef
CATEGORY_ENUM_BEGIN_CATEGORY
#
undef
CATEGORY_ENUM_SUBCATEGORY
#
undef
CATEGORY_ENUM_END_CATEGORY
}
}
#
endif
#
endif
