#
ifndef
BaseProfilerMarkersPrerequisites_h
#
define
BaseProfilerMarkersPrerequisites_h
#
ifdef
MOZ_GECKO_PROFILER
#
include
"
BaseProfilingCategory
.
h
"
#
include
"
mozilla
/
ProfileChunkedBuffer
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
<
string_view
>
#
include
<
string
>
#
include
<
type_traits
>
#
include
<
utility
>
namespace
mozilla
:
:
baseprofiler
{
MFBT_API
int
profiler_current_thread_id
(
)
;
}
namespace
mozilla
{
template
<
typename
CHAR
>
constexpr
const
CHAR
*
LiteralEmptyStringPointer
(
)
{
static_assert
(
std
:
:
is_same_v
<
CHAR
char
>
|
|
std
:
:
is_same_v
<
CHAR
char16_t
>
"
Only
char
and
char16_t
are
supported
in
Firefox
"
)
;
if
constexpr
(
std
:
:
is_same_v
<
CHAR
char
>
)
{
return
"
"
;
}
if
constexpr
(
std
:
:
is_same_v
<
CHAR
char16_t
>
)
{
return
u
"
"
;
}
}
template
<
typename
CHAR
>
constexpr
std
:
:
basic_string_view
<
CHAR
>
LiteralEmptyStringView
(
)
{
static_assert
(
std
:
:
is_same_v
<
CHAR
char
>
|
|
std
:
:
is_same_v
<
CHAR
char16_t
>
"
Only
char
and
char16_t
are
supported
in
Firefox
"
)
;
using
namespace
std
:
:
literals
:
:
string_view_literals
;
if
constexpr
(
std
:
:
is_same_v
<
CHAR
char
>
)
{
return
"
"
sv
;
}
if
constexpr
(
std
:
:
is_same_v
<
CHAR
char16_t
>
)
{
return
u
"
"
sv
;
}
}
template
<
typename
CHAR
>
class
MOZ_STACK_CLASS
ProfilerStringView
{
public
:
constexpr
ProfilerStringView
(
)
=
default
;
ProfilerStringView
(
const
ProfilerStringView
&
)
=
delete
;
ProfilerStringView
&
operator
=
(
const
ProfilerStringView
&
)
=
delete
;
constexpr
ProfilerStringView
(
ProfilerStringView
&
&
aOther
)
:
mStringView
(
std
:
:
move
(
aOther
.
mStringView
)
)
mOwnership
(
aOther
.
mOwnership
)
{
if
(
mOwnership
=
=
Ownership
:
:
OwnedThroughStringView
)
{
aOther
.
mStringView
=
LiteralEmptyStringView
<
CHAR
>
(
)
;
aOther
.
mOwnership
=
Ownership
:
:
Literal
;
}
}
constexpr
ProfilerStringView
&
operator
=
(
ProfilerStringView
&
&
aOther
)
{
mStringView
=
std
:
:
move
(
aOther
.
mStringView
)
;
mOwnership
=
aOther
.
mOwnership
;
if
(
mOwnership
=
=
Ownership
:
:
OwnedThroughStringView
)
{
aOther
.
mStringView
=
LiteralEmptyStringView
<
CHAR
>
(
)
;
aOther
.
mOwnership
=
Ownership
:
:
Literal
;
}
return
*
this
;
}
~
ProfilerStringView
(
)
{
if
(
MOZ_UNLIKELY
(
mOwnership
=
=
Ownership
:
:
OwnedThroughStringView
)
)
{
delete
mStringView
.
data
(
)
;
}
}
constexpr
MOZ_IMPLICIT
ProfilerStringView
(
decltype
(
nullptr
)
)
{
}
template
<
size_t
Np1
>
constexpr
MOZ_IMPLICIT
ProfilerStringView
(
const
CHAR
(
&
aLiteralString
)
[
Np1
]
)
:
ProfilerStringView
(
aLiteralString
Np1
-
1
Ownership
:
:
Literal
)
{
}
constexpr
ProfilerStringView
(
const
CHAR
*
aString
size_t
aLength
)
:
ProfilerStringView
(
aString
aLength
Ownership
:
:
Reference
)
{
}
constexpr
MOZ_IMPLICIT
ProfilerStringView
(
const
std
:
:
basic_string_view
<
CHAR
>
&
aStringView
)
:
ProfilerStringView
(
aStringView
.
data
(
)
aStringView
.
length
(
)
Ownership
:
:
Reference
)
{
}
constexpr
MOZ_IMPLICIT
ProfilerStringView
(
std
:
:
basic_string_view
<
CHAR
>
&
&
aStringView
)
:
ProfilerStringView
(
aStringView
.
data
(
)
aStringView
.
length
(
)
Ownership
:
:
Reference
)
{
}
constexpr
MOZ_IMPLICIT
ProfilerStringView
(
const
std
:
:
string
&
aString
)
:
ProfilerStringView
(
aString
.
data
(
)
aString
.
length
(
)
Ownership
:
:
Reference
)
{
}
static
constexpr
ProfilerStringView
WrapNullTerminatedString
(
const
CHAR
*
aString
)
{
return
ProfilerStringView
(
aString
aString
?
std
:
:
char_traits
<
char
>
:
:
length
(
aString
)
:
0
Ownership
:
:
Reference
)
;
}
template
<
typename
String
typename
DataReturnType
=
decltype
(
std
:
:
declval
<
const
String
>
(
)
.
Data
(
)
)
typename
LengthReturnType
=
decltype
(
std
:
:
declval
<
const
String
>
(
)
.
Length
(
)
)
typename
IsLiteralReturnType
=
decltype
(
std
:
:
declval
<
const
String
>
(
)
.
IsLiteral
(
)
)
typename
=
std
:
:
enable_if_t
<
std
:
:
is_convertible_v
<
DataReturnType
const
CHAR
*
>
&
&
std
:
:
is_integral_v
<
LengthReturnType
>
&
&
std
:
:
is_same_v
<
IsLiteralReturnType
bool
>
>
>
constexpr
MOZ_IMPLICIT
ProfilerStringView
(
const
String
&
aString
)
:
ProfilerStringView
(
static_cast
<
const
CHAR
*
>
(
aString
.
Data
(
)
)
aString
.
Length
(
)
aString
.
IsLiteral
(
)
?
Ownership
:
:
Literal
:
Ownership
:
:
Reference
)
{
}
[
[
nodiscard
]
]
constexpr
const
std
:
:
basic_string_view
<
CHAR
>
&
StringView
(
)
const
{
return
mStringView
;
}
[
[
nodiscard
]
]
constexpr
const
CHAR
*
Data
(
)
const
{
return
mStringView
.
data
(
)
;
}
[
[
nodiscard
]
]
constexpr
size_t
Length
(
)
const
{
return
mStringView
.
length
(
)
;
}
[
[
nodiscard
]
]
constexpr
bool
IsLiteral
(
)
const
{
return
mOwnership
=
=
Ownership
:
:
Literal
;
}
[
[
nodiscard
]
]
constexpr
bool
IsReference
(
)
const
{
return
mOwnership
=
=
Ownership
:
:
Reference
;
}
[
[
nodiscard
]
]
operator
Span
<
const
char
>
(
)
const
{
return
Span
<
const
char
>
(
Data
(
)
Length
(
)
)
;
}
[
[
nodiscard
]
]
std
:
:
basic_string
<
CHAR
>
String
(
)
const
{
return
std
:
:
basic_string
<
CHAR
>
(
mStringView
)
;
}
private
:
enum
class
Ownership
{
Literal
Reference
OwnedThroughStringView
}
;
friend
ProfileBufferEntryReader
:
:
Deserializer
<
ProfilerStringView
>
;
constexpr
ProfilerStringView
(
const
CHAR
*
aString
size_t
aLength
Ownership
aOwnership
)
:
mStringView
(
aString
?
std
:
:
basic_string_view
<
CHAR
>
(
aString
aLength
)
:
LiteralEmptyStringView
<
CHAR
>
(
)
)
mOwnership
(
aString
?
aOwnership
:
Ownership
:
:
Literal
)
{
}
std
:
:
basic_string_view
<
CHAR
>
mStringView
=
LiteralEmptyStringView
<
CHAR
>
(
)
;
Ownership
mOwnership
=
Ownership
:
:
Literal
;
}
;
using
ProfilerString8View
=
ProfilerStringView
<
char
>
;
using
ProfilerString16View
=
ProfilerStringView
<
char16_t
>
;
class
MarkerOptions
;
class
MarkerCategory
{
public
:
constexpr
explicit
MarkerCategory
(
baseprofiler
:
:
ProfilingCategoryPair
aCategoryPair
)
:
mCategoryPair
(
aCategoryPair
)
{
}
constexpr
baseprofiler
:
:
ProfilingCategoryPair
CategoryPair
(
)
const
{
return
mCategoryPair
;
}
baseprofiler
:
:
ProfilingCategory
GetCategory
(
)
const
{
return
GetProfilingCategoryPairInfo
(
mCategoryPair
)
.
mCategory
;
}
template
<
typename
.
.
.
Options
>
MarkerOptions
WithOptions
(
Options
&
&
.
.
.
aOptions
)
const
;
private
:
friend
MarkerOptions
;
constexpr
MarkerCategory
(
)
=
default
;
friend
ProfileBufferEntryReader
:
:
Deserializer
<
MarkerCategory
>
;
baseprofiler
:
:
ProfilingCategoryPair
mCategoryPair
=
baseprofiler
:
:
ProfilingCategoryPair
:
:
OTHER
;
}
;
namespace
baseprofiler
:
:
category
{
#
define
CATEGORY_ENUM_BEGIN_CATEGORY
(
name
labelAsString
color
)
#
define
CATEGORY_ENUM_SUBCATEGORY
(
supercategory
name
labelAsString
)
\
static
constexpr
MarkerCategory
name
{
ProfilingCategoryPair
:
:
name
}
;
#
define
CATEGORY_ENUM_END_CATEGORY
MOZ_PROFILING_CATEGORY_LIST
(
CATEGORY_ENUM_BEGIN_CATEGORY
CATEGORY_ENUM_SUBCATEGORY
CATEGORY_ENUM_END_CATEGORY
)
#
undef
CATEGORY_ENUM_BEGIN_CATEGORY
#
undef
CATEGORY_ENUM_SUBCATEGORY
#
undef
CATEGORY_ENUM_END_CATEGORY
using
MarkerCategory
=
:
:
mozilla
:
:
MarkerCategory
;
}
class
MarkerThreadId
{
public
:
constexpr
MarkerThreadId
(
)
=
default
;
constexpr
explicit
MarkerThreadId
(
int
aThreadId
)
:
mThreadId
(
aThreadId
)
{
}
static
MarkerThreadId
CurrentThread
(
)
{
return
MarkerThreadId
(
baseprofiler
:
:
profiler_current_thread_id
(
)
)
;
}
[
[
nodiscard
]
]
constexpr
int
ThreadId
(
)
const
{
return
mThreadId
;
}
[
[
nodiscard
]
]
constexpr
bool
IsUnspecified
(
)
const
{
return
mThreadId
=
=
0
;
}
private
:
int
mThreadId
=
0
;
}
;
class
MarkerTiming
{
public
:
static
MarkerTiming
InstantAt
(
const
TimeStamp
&
aTime
)
{
MOZ_ASSERT
(
!
aTime
.
IsNull
(
)
"
Time
is
null
for
an
instant
marker
.
"
)
;
return
MarkerTiming
{
aTime
TimeStamp
{
}
MarkerTiming
:
:
Phase
:
:
Instant
}
;
}
static
MarkerTiming
InstantNow
(
)
{
return
InstantAt
(
TimeStamp
:
:
NowUnfuzzed
(
)
)
;
}
static
MarkerTiming
Interval
(
const
TimeStamp
&
aStartTime
const
TimeStamp
&
aEndTime
)
{
MOZ_ASSERT
(
!
aStartTime
.
IsNull
(
)
"
Start
time
is
null
for
an
interval
marker
.
"
)
;
MOZ_ASSERT
(
!
aEndTime
.
IsNull
(
)
"
End
time
is
null
for
an
interval
marker
.
"
)
;
return
MarkerTiming
{
aStartTime
aEndTime
MarkerTiming
:
:
Phase
:
:
Interval
}
;
}
static
MarkerTiming
IntervalUntilNowFrom
(
const
TimeStamp
&
aStartTime
)
{
return
Interval
(
aStartTime
TimeStamp
:
:
NowUnfuzzed
(
)
)
;
}
static
MarkerTiming
IntervalStart
(
const
TimeStamp
&
aTime
=
TimeStamp
:
:
NowUnfuzzed
(
)
)
{
MOZ_ASSERT
(
!
aTime
.
IsNull
(
)
"
Time
is
null
for
an
interval
start
marker
.
"
)
;
return
MarkerTiming
{
aTime
TimeStamp
{
}
MarkerTiming
:
:
Phase
:
:
IntervalStart
}
;
}
static
MarkerTiming
IntervalEnd
(
const
TimeStamp
&
aTime
=
TimeStamp
:
:
NowUnfuzzed
(
)
)
{
MOZ_ASSERT
(
!
aTime
.
IsNull
(
)
"
Time
is
null
for
an
interval
end
marker
.
"
)
;
return
MarkerTiming
{
TimeStamp
{
}
aTime
MarkerTiming
:
:
Phase
:
:
IntervalEnd
}
;
}
void
SetIntervalEnd
(
const
TimeStamp
&
aTime
=
TimeStamp
:
:
NowUnfuzzed
(
)
)
{
MOZ_ASSERT
(
!
aTime
.
IsNull
(
)
"
Time
is
null
for
an
interval
end
marker
.
"
)
;
mEndTime
=
aTime
;
mPhase
=
mStartTime
.
IsNull
(
)
?
Phase
:
:
IntervalEnd
:
Phase
:
:
Interval
;
}
[
[
nodiscard
]
]
const
TimeStamp
&
StartTime
(
)
const
{
return
mStartTime
;
}
[
[
nodiscard
]
]
const
TimeStamp
&
EndTime
(
)
const
{
return
mEndTime
;
}
enum
class
Phase
:
uint8_t
{
Instant
=
0
Interval
=
1
IntervalStart
=
2
IntervalEnd
=
3
}
;
[
[
nodiscard
]
]
Phase
MarkerPhase
(
)
const
{
MOZ_ASSERT
(
!
IsUnspecified
(
)
)
;
return
mPhase
;
}
[
[
nodiscard
]
]
double
GetStartTime
(
)
const
{
MOZ_ASSERT
(
!
IsUnspecified
(
)
)
;
return
MarkerTiming
:
:
timeStampToDouble
(
mStartTime
)
;
}
[
[
nodiscard
]
]
double
GetEndTime
(
)
const
{
MOZ_ASSERT
(
!
IsUnspecified
(
)
)
;
return
MarkerTiming
:
:
timeStampToDouble
(
mEndTime
)
;
}
[
[
nodiscard
]
]
uint8_t
GetPhase
(
)
const
{
MOZ_ASSERT
(
!
IsUnspecified
(
)
)
;
return
static_cast
<
uint8_t
>
(
mPhase
)
;
}
private
:
friend
ProfileBufferEntryWriter
:
:
Serializer
<
MarkerTiming
>
;
friend
ProfileBufferEntryReader
:
:
Deserializer
<
MarkerTiming
>
;
friend
MarkerOptions
;
constexpr
MarkerTiming
(
)
=
default
;
[
[
nodiscard
]
]
bool
IsUnspecified
(
)
const
{
return
mStartTime
.
IsNull
(
)
&
&
mEndTime
.
IsNull
(
)
;
}
constexpr
MarkerTiming
(
const
TimeStamp
&
aStartTime
const
TimeStamp
&
aEndTime
Phase
aPhase
)
:
mStartTime
(
aStartTime
)
mEndTime
(
aEndTime
)
mPhase
(
aPhase
)
{
}
static
double
timeStampToDouble
(
const
TimeStamp
&
time
)
{
if
(
time
.
IsNull
(
)
)
{
return
0
;
}
return
(
time
-
TimeStamp
:
:
ProcessCreation
(
)
)
.
ToMilliseconds
(
)
;
}
TimeStamp
mStartTime
;
TimeStamp
mEndTime
;
Phase
mPhase
=
Phase
:
:
Instant
;
}
;
class
MarkerStack
{
public
:
constexpr
MarkerStack
(
)
=
default
;
MarkerStack
(
const
MarkerStack
&
)
=
delete
;
MarkerStack
&
operator
=
(
const
MarkerStack
&
)
=
delete
;
MarkerStack
(
MarkerStack
&
&
aOther
)
:
mIsCaptureRequested
(
aOther
.
mIsCaptureRequested
)
mOptionalChunkedBufferStorage
(
std
:
:
move
(
aOther
.
mOptionalChunkedBufferStorage
)
)
mChunkedBuffer
(
aOther
.
mChunkedBuffer
)
{
AssertInvariants
(
)
;
aOther
.
Clear
(
)
;
}
MarkerStack
&
operator
=
(
MarkerStack
&
&
aOther
)
{
mIsCaptureRequested
=
aOther
.
mIsCaptureRequested
;
mOptionalChunkedBufferStorage
=
std
:
:
move
(
aOther
.
mOptionalChunkedBufferStorage
)
;
mChunkedBuffer
=
aOther
.
mChunkedBuffer
;
AssertInvariants
(
)
;
aOther
.
Clear
(
)
;
return
*
this
;
}
explicit
MarkerStack
(
UniquePtr
<
ProfileChunkedBuffer
>
&
&
aExternalChunkedBuffer
)
:
mIsCaptureRequested
(
false
)
mOptionalChunkedBufferStorage
(
(
!
aExternalChunkedBuffer
|
|
aExternalChunkedBuffer
-
>
IsEmpty
(
)
)
?
nullptr
:
std
:
:
move
(
aExternalChunkedBuffer
)
)
mChunkedBuffer
(
mOptionalChunkedBufferStorage
.
get
(
)
)
{
AssertInvariants
(
)
;
}
explicit
MarkerStack
(
ProfileChunkedBuffer
&
aExternalChunkedBuffer
)
:
mIsCaptureRequested
(
false
)
mChunkedBuffer
(
aExternalChunkedBuffer
.
IsEmpty
(
)
?
nullptr
:
&
aExternalChunkedBuffer
)
{
AssertInvariants
(
)
;
}
static
MarkerStack
NoStack
(
)
{
return
MarkerStack
(
false
)
;
}
static
MarkerStack
Capture
(
)
{
return
MarkerStack
(
true
)
;
}
static
MarkerStack
UseBacktrace
(
ProfileChunkedBuffer
&
aExternalChunkedBuffer
)
{
return
MarkerStack
(
aExternalChunkedBuffer
)
;
}
static
MarkerStack
TakeBacktrace
(
UniquePtr
<
ProfileChunkedBuffer
>
&
&
aExternalChunkedBuffer
)
{
return
MarkerStack
(
std
:
:
move
(
aExternalChunkedBuffer
)
)
;
}
[
[
nodiscard
]
]
bool
IsCaptureNeeded
(
)
const
{
return
mIsCaptureRequested
;
}
ProfileChunkedBuffer
*
GetChunkedBuffer
(
)
const
{
return
mChunkedBuffer
;
}
void
UseRequestedBacktrace
(
ProfileChunkedBuffer
*
aExternalChunkedBuffer
)
{
MOZ_RELEASE_ASSERT
(
IsCaptureNeeded
(
)
)
;
mIsCaptureRequested
=
false
;
if
(
aExternalChunkedBuffer
&
&
!
aExternalChunkedBuffer
-
>
IsEmpty
(
)
)
{
mChunkedBuffer
=
aExternalChunkedBuffer
;
}
AssertInvariants
(
)
;
}
void
Clear
(
)
{
mIsCaptureRequested
=
false
;
mOptionalChunkedBufferStorage
.
reset
(
)
;
mChunkedBuffer
=
nullptr
;
AssertInvariants
(
)
;
}
private
:
explicit
MarkerStack
(
bool
aIsCaptureRequested
)
:
mIsCaptureRequested
(
aIsCaptureRequested
)
{
AssertInvariants
(
)
;
}
void
AssertInvariants
(
)
const
{
#
ifdef
DEBUG
if
(
mIsCaptureRequested
)
{
MOZ_ASSERT
(
!
mOptionalChunkedBufferStorage
"
We
should
not
hold
a
buffer
when
capture
is
requested
"
)
;
MOZ_ASSERT
(
!
mChunkedBuffer
"
We
should
not
point
at
a
buffer
when
capture
is
requested
"
)
;
}
else
{
if
(
mOptionalChunkedBufferStorage
)
{
MOZ_ASSERT
(
mChunkedBuffer
=
=
mOptionalChunkedBufferStorage
.
get
(
)
"
Non
-
null
mOptionalChunkedBufferStorage
must
be
pointed
-
at
"
"
by
mChunkedBuffer
"
)
;
}
if
(
mChunkedBuffer
)
{
MOZ_ASSERT
(
!
mChunkedBuffer
-
>
IsEmpty
(
)
"
Non
-
null
mChunkedBuffer
must
not
be
empty
"
)
;
}
}
#
endif
}
bool
mIsCaptureRequested
=
false
;
UniquePtr
<
ProfileChunkedBuffer
>
mOptionalChunkedBufferStorage
;
ProfileChunkedBuffer
*
mChunkedBuffer
=
nullptr
;
}
;
class
MarkerInnerWindowId
{
public
:
constexpr
MarkerInnerWindowId
(
)
=
default
;
constexpr
explicit
MarkerInnerWindowId
(
uint64_t
i
)
:
mInnerWindowId
(
i
)
{
}
constexpr
static
MarkerInnerWindowId
NoId
(
)
{
return
MarkerInnerWindowId
{
}
;
}
[
[
nodiscard
]
]
bool
IsUnspecified
(
)
const
{
return
mInnerWindowId
=
=
scNoId
;
}
[
[
nodiscard
]
]
constexpr
uint64_t
Id
(
)
const
{
return
mInnerWindowId
;
}
private
:
static
constexpr
uint64_t
scNoId
=
0
;
uint64_t
mInnerWindowId
=
scNoId
;
}
;
class
MarkerOptions
{
public
:
constexpr
MOZ_IMPLICIT
MarkerOptions
(
const
MarkerCategory
&
aCategory
)
:
mCategory
(
aCategory
)
{
}
template
<
typename
.
.
.
Options
>
explicit
MarkerOptions
(
const
MarkerCategory
&
aCategory
Options
&
&
.
.
.
aOptions
)
:
mCategory
(
aCategory
)
{
(
Set
(
std
:
:
forward
<
Options
>
(
aOptions
)
)
.
.
.
)
;
}
MarkerOptions
(
const
MarkerOptions
&
)
=
delete
;
MarkerOptions
&
operator
=
(
const
MarkerOptions
&
)
=
delete
;
MarkerOptions
(
MarkerOptions
&
&
)
=
default
;
MarkerOptions
&
operator
=
(
MarkerOptions
&
&
)
=
default
;
[
[
nodiscard
]
]
bool
IsTimingUnspecified
(
)
const
{
return
mTiming
.
IsUnspecified
(
)
;
}
#
define
FUNCTIONS_ON_MEMBER
(
NAME
)
\
MarkerOptions
&
Set
(
Marker
#
#
NAME
&
&
a
#
#
NAME
)
&
{
\
m
#
#
NAME
=
std
:
:
move
(
a
#
#
NAME
)
;
\
return
*
this
;
\
}
\
\
MarkerOptions
&
&
Set
(
Marker
#
#
NAME
&
&
a
#
#
NAME
)
&
&
{
\
m
#
#
NAME
=
std
:
:
move
(
a
#
#
NAME
)
;
\
return
std
:
:
move
(
*
this
)
;
\
}
\
\
const
Marker
#
#
NAME
&
NAME
(
)
const
{
return
m
#
#
NAME
;
}
\
\
Marker
#
#
NAME
&
NAME
#
#
Ref
(
)
{
return
m
#
#
NAME
;
}
FUNCTIONS_ON_MEMBER
(
Category
)
;
FUNCTIONS_ON_MEMBER
(
ThreadId
)
;
FUNCTIONS_ON_MEMBER
(
Timing
)
;
FUNCTIONS_ON_MEMBER
(
Stack
)
;
FUNCTIONS_ON_MEMBER
(
InnerWindowId
)
;
#
undef
FUNCTIONS_ON_MEMBER
private
:
friend
ProfileBufferEntryReader
:
:
Deserializer
<
MarkerOptions
>
;
constexpr
MarkerOptions
(
)
=
default
;
MarkerCategory
mCategory
;
MarkerThreadId
mThreadId
;
MarkerTiming
mTiming
;
MarkerStack
mStack
;
MarkerInnerWindowId
mInnerWindowId
;
}
;
template
<
typename
.
.
.
Options
>
MarkerOptions
MarkerCategory
:
:
WithOptions
(
Options
&
&
.
.
.
aOptions
)
const
{
return
MarkerOptions
(
*
this
std
:
:
forward
<
Options
>
(
aOptions
)
.
.
.
)
;
}
namespace
baseprofiler
:
:
category
{
using
MarkerOptions
=
:
:
mozilla
:
:
MarkerOptions
;
}
}
namespace
mozilla
:
:
baseprofiler
:
:
markers
{
struct
NoPayload
final
{
}
;
}
#
endif
#
endif
