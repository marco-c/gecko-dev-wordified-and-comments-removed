#
ifndef
BaseProfilerMarkersPrerequisites_h
#
define
BaseProfilerMarkersPrerequisites_h
namespace
mozilla
{
enum
class
StackCaptureOptions
{
NoStack
Full
NonNative
}
;
}
#
include
"
BaseProfileJSONWriter
.
h
"
#
include
"
BaseProfilingCategory
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
ProfileChunkedBuffer
.
h
"
#
include
"
mozilla
/
BaseProfilerState
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
<
initializer_list
>
#
include
<
string_view
>
#
include
<
string
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
<
vector
>
#
ifdef
None
#
undef
None
#
endif
namespace
mozilla
{
template
<
typename
CHAR
>
constexpr
const
CHAR
*
LiteralEmptyStringPointer
(
)
{
static_assert
(
std
:
:
is_same_v
<
CHAR
char
>
|
|
std
:
:
is_same_v
<
CHAR
char16_t
>
"
Only
char
and
char16_t
are
supported
in
Firefox
"
)
;
if
constexpr
(
std
:
:
is_same_v
<
CHAR
char
>
)
{
return
"
"
;
}
if
constexpr
(
std
:
:
is_same_v
<
CHAR
char16_t
>
)
{
return
u
"
"
;
}
}
template
<
typename
CHAR
>
constexpr
std
:
:
basic_string_view
<
CHAR
>
LiteralEmptyStringView
(
)
{
static_assert
(
std
:
:
is_same_v
<
CHAR
char
>
|
|
std
:
:
is_same_v
<
CHAR
char16_t
>
"
Only
char
and
char16_t
are
supported
in
Firefox
"
)
;
using
namespace
std
:
:
literals
:
:
string_view_literals
;
if
constexpr
(
std
:
:
is_same_v
<
CHAR
char
>
)
{
return
"
"
sv
;
}
if
constexpr
(
std
:
:
is_same_v
<
CHAR
char16_t
>
)
{
return
u
"
"
sv
;
}
}
template
<
typename
CHAR
>
class
MOZ_STACK_CLASS
ProfilerStringView
{
public
:
constexpr
ProfilerStringView
(
)
=
default
;
ProfilerStringView
(
const
ProfilerStringView
&
)
=
delete
;
ProfilerStringView
&
operator
=
(
const
ProfilerStringView
&
)
=
delete
;
constexpr
ProfilerStringView
(
ProfilerStringView
&
&
aOther
)
:
mStringView
(
std
:
:
move
(
aOther
.
mStringView
)
)
mOwnership
(
aOther
.
mOwnership
)
{
if
(
mOwnership
=
=
Ownership
:
:
OwnedThroughStringView
)
{
aOther
.
mStringView
=
LiteralEmptyStringView
<
CHAR
>
(
)
;
aOther
.
mOwnership
=
Ownership
:
:
Literal
;
}
}
constexpr
ProfilerStringView
&
operator
=
(
ProfilerStringView
&
&
aOther
)
{
mStringView
=
std
:
:
move
(
aOther
.
mStringView
)
;
mOwnership
=
aOther
.
mOwnership
;
if
(
mOwnership
=
=
Ownership
:
:
OwnedThroughStringView
)
{
aOther
.
mStringView
=
LiteralEmptyStringView
<
CHAR
>
(
)
;
aOther
.
mOwnership
=
Ownership
:
:
Literal
;
}
return
*
this
;
}
~
ProfilerStringView
(
)
{
if
(
MOZ_UNLIKELY
(
mOwnership
=
=
Ownership
:
:
OwnedThroughStringView
)
)
{
delete
mStringView
.
data
(
)
;
}
}
constexpr
MOZ_IMPLICIT
ProfilerStringView
(
decltype
(
nullptr
)
)
{
}
template
<
size_t
Np1
>
constexpr
MOZ_IMPLICIT
ProfilerStringView
(
const
CHAR
(
&
aLiteralString
)
[
Np1
]
)
:
ProfilerStringView
(
aLiteralString
Np1
-
1
Ownership
:
:
Literal
)
{
}
constexpr
ProfilerStringView
(
const
CHAR
*
aString
size_t
aLength
)
:
ProfilerStringView
(
aString
aLength
Ownership
:
:
Reference
)
{
}
constexpr
MOZ_IMPLICIT
ProfilerStringView
(
const
std
:
:
basic_string_view
<
CHAR
>
&
aStringView
)
:
ProfilerStringView
(
aStringView
.
data
(
)
aStringView
.
length
(
)
Ownership
:
:
Reference
)
{
}
constexpr
MOZ_IMPLICIT
ProfilerStringView
(
std
:
:
basic_string_view
<
CHAR
>
&
&
aStringView
)
:
ProfilerStringView
(
aStringView
.
data
(
)
aStringView
.
length
(
)
Ownership
:
:
Reference
)
{
}
constexpr
MOZ_IMPLICIT
ProfilerStringView
(
const
std
:
:
basic_string
<
CHAR
>
&
aString
)
:
ProfilerStringView
(
aString
.
data
(
)
aString
.
length
(
)
Ownership
:
:
Reference
)
{
}
static
constexpr
ProfilerStringView
WrapNullTerminatedString
(
const
CHAR
*
aString
)
{
return
ProfilerStringView
(
aString
aString
?
std
:
:
char_traits
<
CHAR
>
:
:
length
(
aString
)
:
0
Ownership
:
:
Reference
)
;
}
template
<
typename
String
typename
DataReturnType
=
decltype
(
std
:
:
declval
<
const
String
>
(
)
.
Data
(
)
)
typename
LengthReturnType
=
decltype
(
std
:
:
declval
<
const
String
>
(
)
.
Length
(
)
)
typename
IsLiteralReturnType
=
decltype
(
std
:
:
declval
<
const
String
>
(
)
.
IsLiteral
(
)
)
typename
=
std
:
:
enable_if_t
<
std
:
:
is_convertible_v
<
DataReturnType
const
CHAR
*
>
&
&
std
:
:
is_integral_v
<
LengthReturnType
>
&
&
std
:
:
is_same_v
<
IsLiteralReturnType
bool
>
>
>
constexpr
MOZ_IMPLICIT
ProfilerStringView
(
const
String
&
aString
)
:
ProfilerStringView
(
static_cast
<
const
CHAR
*
>
(
aString
.
Data
(
)
)
aString
.
Length
(
)
aString
.
IsLiteral
(
)
?
Ownership
:
:
Literal
:
Ownership
:
:
Reference
)
{
}
[
[
nodiscard
]
]
constexpr
const
std
:
:
basic_string_view
<
CHAR
>
&
StringView
(
)
const
{
return
mStringView
;
}
[
[
nodiscard
]
]
constexpr
size_t
Length
(
)
const
{
return
mStringView
.
length
(
)
;
}
[
[
nodiscard
]
]
constexpr
bool
IsLiteral
(
)
const
{
return
mOwnership
=
=
Ownership
:
:
Literal
;
}
[
[
nodiscard
]
]
constexpr
bool
IsReference
(
)
const
{
return
mOwnership
=
=
Ownership
:
:
Reference
;
}
[
[
nodiscard
]
]
Span
<
const
CHAR
>
AsSpan
(
)
const
{
return
Span
<
const
CHAR
>
(
mStringView
.
data
(
)
mStringView
.
length
(
)
)
;
}
[
[
nodiscard
]
]
operator
Span
<
const
CHAR
>
(
)
const
{
return
AsSpan
(
)
;
}
private
:
enum
class
Ownership
{
Literal
Reference
OwnedThroughStringView
}
;
friend
ProfileBufferEntryReader
:
:
Deserializer
<
ProfilerStringView
>
;
constexpr
ProfilerStringView
(
const
CHAR
*
aString
size_t
aLength
Ownership
aOwnership
)
:
mStringView
(
aString
?
std
:
:
basic_string_view
<
CHAR
>
(
aString
aLength
)
:
LiteralEmptyStringView
<
CHAR
>
(
)
)
mOwnership
(
aString
?
aOwnership
:
Ownership
:
:
Literal
)
{
}
std
:
:
basic_string_view
<
CHAR
>
mStringView
=
LiteralEmptyStringView
<
CHAR
>
(
)
;
Ownership
mOwnership
=
Ownership
:
:
Literal
;
}
;
using
ProfilerString8View
=
ProfilerStringView
<
char
>
;
using
ProfilerString16View
=
ProfilerStringView
<
char16_t
>
;
class
MarkerCategory
{
public
:
constexpr
explicit
MarkerCategory
(
baseprofiler
:
:
ProfilingCategoryPair
aCategoryPair
)
:
mCategoryPair
(
aCategoryPair
)
{
}
constexpr
baseprofiler
:
:
ProfilingCategoryPair
CategoryPair
(
)
const
{
return
mCategoryPair
;
}
baseprofiler
:
:
ProfilingCategory
GetCategory
(
)
const
{
return
GetProfilingCategoryPairInfo
(
mCategoryPair
)
.
mCategory
;
}
private
:
baseprofiler
:
:
ProfilingCategoryPair
mCategoryPair
=
baseprofiler
:
:
ProfilingCategoryPair
:
:
OTHER
;
}
;
namespace
baseprofiler
:
:
category
{
#
define
CATEGORY_ENUM_BEGIN_CATEGORY
(
name
labelAsString
color
)
#
define
CATEGORY_ENUM_SUBCATEGORY
(
supercategory
name
labelAsString
)
\
static
constexpr
MarkerCategory
name
{
ProfilingCategoryPair
:
:
name
}
;
#
define
CATEGORY_ENUM_END_CATEGORY
MOZ_PROFILING_CATEGORY_LIST
(
CATEGORY_ENUM_BEGIN_CATEGORY
CATEGORY_ENUM_SUBCATEGORY
CATEGORY_ENUM_END_CATEGORY
)
#
undef
CATEGORY_ENUM_BEGIN_CATEGORY
#
undef
CATEGORY_ENUM_SUBCATEGORY
#
undef
CATEGORY_ENUM_END_CATEGORY
using
MarkerCategory
=
:
:
mozilla
:
:
MarkerCategory
;
}
class
MarkerOptions
;
class
MarkerThreadId
{
public
:
constexpr
MarkerThreadId
(
)
=
default
;
constexpr
explicit
MarkerThreadId
(
baseprofiler
:
:
BaseProfilerThreadId
aThreadId
)
:
mThreadId
(
aThreadId
)
{
}
static
MarkerThreadId
CurrentThread
(
)
{
return
MarkerThreadId
(
baseprofiler
:
:
profiler_current_thread_id
(
)
)
;
}
static
MarkerThreadId
MainThread
(
)
{
return
MarkerThreadId
(
baseprofiler
:
:
profiler_main_thread_id
(
)
)
;
}
[
[
nodiscard
]
]
constexpr
baseprofiler
:
:
BaseProfilerThreadId
ThreadId
(
)
const
{
return
mThreadId
;
}
[
[
nodiscard
]
]
constexpr
bool
IsUnspecified
(
)
const
{
return
!
mThreadId
.
IsSpecified
(
)
;
}
private
:
baseprofiler
:
:
BaseProfilerThreadId
mThreadId
;
}
;
class
MarkerTiming
{
public
:
static
MarkerTiming
InstantAt
(
const
TimeStamp
&
aTime
)
{
MOZ_ASSERT
(
!
aTime
.
IsNull
(
)
"
Time
is
null
for
an
instant
marker
.
"
)
;
return
MarkerTiming
{
aTime
TimeStamp
{
}
MarkerTiming
:
:
Phase
:
:
Instant
}
;
}
static
MarkerTiming
InstantNow
(
)
{
return
InstantAt
(
TimeStamp
:
:
Now
(
)
)
;
}
static
MarkerTiming
Interval
(
const
TimeStamp
&
aStartTime
const
TimeStamp
&
aEndTime
)
{
MOZ_ASSERT
(
!
aStartTime
.
IsNull
(
)
"
Start
time
is
null
for
an
interval
marker
.
"
)
;
MOZ_ASSERT
(
!
aEndTime
.
IsNull
(
)
"
End
time
is
null
for
an
interval
marker
.
"
)
;
return
MarkerTiming
{
aStartTime
aEndTime
MarkerTiming
:
:
Phase
:
:
Interval
}
;
}
static
MarkerTiming
IntervalUntilNowFrom
(
const
TimeStamp
&
aStartTime
)
{
return
Interval
(
aStartTime
TimeStamp
:
:
Now
(
)
)
;
}
static
MarkerTiming
IntervalStart
(
const
TimeStamp
&
aTime
=
TimeStamp
:
:
Now
(
)
)
{
MOZ_ASSERT
(
!
aTime
.
IsNull
(
)
"
Time
is
null
for
an
interval
start
marker
.
"
)
;
return
MarkerTiming
{
aTime
TimeStamp
{
}
MarkerTiming
:
:
Phase
:
:
IntervalStart
}
;
}
static
MarkerTiming
IntervalEnd
(
const
TimeStamp
&
aTime
=
TimeStamp
:
:
Now
(
)
)
{
MOZ_ASSERT
(
!
aTime
.
IsNull
(
)
"
Time
is
null
for
an
interval
end
marker
.
"
)
;
return
MarkerTiming
{
TimeStamp
{
}
aTime
MarkerTiming
:
:
Phase
:
:
IntervalEnd
}
;
}
void
SetIntervalEnd
(
const
TimeStamp
&
aTime
=
TimeStamp
:
:
Now
(
)
)
{
MOZ_ASSERT
(
!
aTime
.
IsNull
(
)
"
Time
is
null
for
an
interval
end
marker
.
"
)
;
mEndTime
=
aTime
;
mPhase
=
mStartTime
.
IsNull
(
)
?
Phase
:
:
IntervalEnd
:
Phase
:
:
Interval
;
}
[
[
nodiscard
]
]
const
TimeStamp
&
StartTime
(
)
const
{
return
mStartTime
;
}
[
[
nodiscard
]
]
const
TimeStamp
&
EndTime
(
)
const
{
return
mEndTime
;
}
enum
class
Phase
:
uint8_t
{
Instant
=
0
Interval
=
1
IntervalStart
=
2
IntervalEnd
=
3
}
;
[
[
nodiscard
]
]
Phase
MarkerPhase
(
)
const
{
MOZ_ASSERT
(
!
IsUnspecified
(
)
)
;
return
mPhase
;
}
[
[
nodiscard
]
]
double
GetStartTime
(
)
const
{
MOZ_ASSERT
(
!
IsUnspecified
(
)
)
;
return
MarkerTiming
:
:
timeStampToDouble
(
mStartTime
)
;
}
[
[
nodiscard
]
]
double
GetEndTime
(
)
const
{
MOZ_ASSERT
(
!
IsUnspecified
(
)
)
;
return
MarkerTiming
:
:
timeStampToDouble
(
mEndTime
)
;
}
[
[
nodiscard
]
]
uint8_t
GetPhase
(
)
const
{
MOZ_ASSERT
(
!
IsUnspecified
(
)
)
;
return
static_cast
<
uint8_t
>
(
mPhase
)
;
}
static
void
UnsafeConstruct
(
MarkerTiming
*
aMarkerTiming
const
TimeStamp
&
aStartTime
const
TimeStamp
&
aEndTime
Phase
aPhase
)
{
new
(
aMarkerTiming
)
MarkerTiming
{
aStartTime
aEndTime
aPhase
}
;
}
private
:
friend
ProfileBufferEntryWriter
:
:
Serializer
<
MarkerTiming
>
;
friend
ProfileBufferEntryReader
:
:
Deserializer
<
MarkerTiming
>
;
friend
MarkerOptions
;
constexpr
MarkerTiming
(
)
=
default
;
[
[
nodiscard
]
]
bool
IsUnspecified
(
)
const
{
return
mStartTime
.
IsNull
(
)
&
&
mEndTime
.
IsNull
(
)
;
}
constexpr
MarkerTiming
(
const
TimeStamp
&
aStartTime
const
TimeStamp
&
aEndTime
Phase
aPhase
)
:
mStartTime
(
aStartTime
)
mEndTime
(
aEndTime
)
mPhase
(
aPhase
)
{
}
static
double
timeStampToDouble
(
const
TimeStamp
&
time
)
{
if
(
time
.
IsNull
(
)
)
{
return
0
;
}
return
(
time
-
TimeStamp
:
:
ProcessCreation
(
)
)
.
ToMilliseconds
(
)
;
}
TimeStamp
mStartTime
;
TimeStamp
mEndTime
;
Phase
mPhase
=
Phase
:
:
Instant
;
}
;
class
MarkerStack
{
public
:
constexpr
MarkerStack
(
)
=
default
;
MarkerStack
(
const
MarkerStack
&
)
=
delete
;
MarkerStack
&
operator
=
(
const
MarkerStack
&
)
=
delete
;
MarkerStack
(
MarkerStack
&
&
aOther
)
:
mCaptureOptions
(
aOther
.
mCaptureOptions
)
mOptionalChunkedBufferStorage
(
std
:
:
move
(
aOther
.
mOptionalChunkedBufferStorage
)
)
mChunkedBuffer
(
aOther
.
mChunkedBuffer
)
{
AssertInvariants
(
)
;
aOther
.
Clear
(
)
;
}
MarkerStack
&
operator
=
(
MarkerStack
&
&
aOther
)
{
mCaptureOptions
=
aOther
.
mCaptureOptions
;
mOptionalChunkedBufferStorage
=
std
:
:
move
(
aOther
.
mOptionalChunkedBufferStorage
)
;
mChunkedBuffer
=
aOther
.
mChunkedBuffer
;
AssertInvariants
(
)
;
aOther
.
Clear
(
)
;
return
*
this
;
}
explicit
MarkerStack
(
UniquePtr
<
ProfileChunkedBuffer
>
&
&
aExternalChunkedBuffer
)
:
mOptionalChunkedBufferStorage
(
(
!
aExternalChunkedBuffer
|
|
aExternalChunkedBuffer
-
>
IsEmpty
(
)
)
?
nullptr
:
std
:
:
move
(
aExternalChunkedBuffer
)
)
mChunkedBuffer
(
mOptionalChunkedBufferStorage
.
get
(
)
)
{
AssertInvariants
(
)
;
}
explicit
MarkerStack
(
ProfileChunkedBuffer
&
aExternalChunkedBuffer
)
:
mChunkedBuffer
(
aExternalChunkedBuffer
.
IsEmpty
(
)
?
nullptr
:
&
aExternalChunkedBuffer
)
{
AssertInvariants
(
)
;
}
static
MarkerStack
NoStack
(
)
{
return
MarkerStack
(
StackCaptureOptions
:
:
NoStack
)
;
}
static
MarkerStack
Capture
(
StackCaptureOptions
aCaptureOptions
=
StackCaptureOptions
:
:
Full
)
{
return
MarkerStack
(
aCaptureOptions
)
;
}
static
MarkerStack
MaybeCapture
(
bool
aDoCapture
)
{
return
aDoCapture
?
Capture
(
)
:
NoStack
(
)
;
}
static
MarkerStack
UseBacktrace
(
ProfileChunkedBuffer
&
aExternalChunkedBuffer
)
{
return
MarkerStack
(
aExternalChunkedBuffer
)
;
}
static
MarkerStack
TakeBacktrace
(
UniquePtr
<
ProfileChunkedBuffer
>
&
&
aExternalChunkedBuffer
)
{
return
MarkerStack
(
std
:
:
move
(
aExternalChunkedBuffer
)
)
;
}
static
MarkerStack
WithCaptureOptions
(
StackCaptureOptions
aCaptureOptions
)
{
return
MarkerStack
(
aCaptureOptions
)
;
}
[
[
nodiscard
]
]
StackCaptureOptions
CaptureOptions
(
)
const
{
return
mCaptureOptions
;
}
ProfileChunkedBuffer
*
GetChunkedBuffer
(
)
const
{
return
mChunkedBuffer
;
}
void
UseRequestedBacktrace
(
ProfileChunkedBuffer
*
aExternalChunkedBuffer
)
{
MOZ_RELEASE_ASSERT
(
mCaptureOptions
!
=
StackCaptureOptions
:
:
NoStack
)
;
mCaptureOptions
=
StackCaptureOptions
:
:
NoStack
;
if
(
aExternalChunkedBuffer
&
&
!
aExternalChunkedBuffer
-
>
IsEmpty
(
)
)
{
mChunkedBuffer
=
aExternalChunkedBuffer
;
}
AssertInvariants
(
)
;
}
void
Clear
(
)
{
mCaptureOptions
=
StackCaptureOptions
:
:
NoStack
;
mOptionalChunkedBufferStorage
.
reset
(
)
;
mChunkedBuffer
=
nullptr
;
AssertInvariants
(
)
;
}
private
:
explicit
MarkerStack
(
StackCaptureOptions
aCaptureOptions
)
:
mCaptureOptions
(
aCaptureOptions
)
{
AssertInvariants
(
)
;
}
void
AssertInvariants
(
)
const
{
#
ifdef
DEBUG
if
(
mCaptureOptions
!
=
StackCaptureOptions
:
:
NoStack
)
{
MOZ_ASSERT
(
!
mOptionalChunkedBufferStorage
"
We
should
not
hold
a
buffer
when
capture
is
requested
"
)
;
MOZ_ASSERT
(
!
mChunkedBuffer
"
We
should
not
point
at
a
buffer
when
capture
is
requested
"
)
;
}
else
{
if
(
mOptionalChunkedBufferStorage
)
{
MOZ_ASSERT
(
mChunkedBuffer
=
=
mOptionalChunkedBufferStorage
.
get
(
)
"
Non
-
null
mOptionalChunkedBufferStorage
must
be
pointed
-
at
"
"
by
mChunkedBuffer
"
)
;
}
if
(
mChunkedBuffer
)
{
MOZ_ASSERT
(
!
mChunkedBuffer
-
>
IsEmpty
(
)
"
Non
-
null
mChunkedBuffer
must
not
be
empty
"
)
;
}
}
#
endif
}
StackCaptureOptions
mCaptureOptions
=
StackCaptureOptions
:
:
NoStack
;
UniquePtr
<
ProfileChunkedBuffer
>
mOptionalChunkedBufferStorage
;
ProfileChunkedBuffer
*
mChunkedBuffer
=
nullptr
;
}
;
class
MarkerInnerWindowId
{
public
:
constexpr
MarkerInnerWindowId
(
)
=
default
;
constexpr
explicit
MarkerInnerWindowId
(
uint64_t
i
)
:
mInnerWindowId
(
i
)
{
}
constexpr
explicit
MarkerInnerWindowId
(
const
Maybe
<
uint64_t
>
&
i
)
:
mInnerWindowId
(
i
.
valueOr
(
scNoId
)
)
{
}
constexpr
static
MarkerInnerWindowId
NoId
(
)
{
return
MarkerInnerWindowId
{
}
;
}
[
[
nodiscard
]
]
bool
IsUnspecified
(
)
const
{
return
mInnerWindowId
=
=
scNoId
;
}
[
[
nodiscard
]
]
constexpr
uint64_t
Id
(
)
const
{
return
mInnerWindowId
;
}
private
:
static
constexpr
uint64_t
scNoId
=
0
;
uint64_t
mInnerWindowId
=
scNoId
;
}
;
class
MarkerOptions
{
public
:
template
<
typename
.
.
.
Options
>
MOZ_IMPLICIT
MarkerOptions
(
Options
&
&
.
.
.
aOptions
)
{
(
Set
(
std
:
:
forward
<
Options
>
(
aOptions
)
)
.
.
.
)
;
}
MarkerOptions
(
const
MarkerOptions
&
)
=
delete
;
MarkerOptions
&
operator
=
(
const
MarkerOptions
&
)
=
delete
;
MarkerOptions
(
MarkerOptions
&
&
)
=
default
;
MarkerOptions
&
operator
=
(
MarkerOptions
&
&
)
=
default
;
[
[
nodiscard
]
]
bool
IsTimingUnspecified
(
)
const
{
return
mTiming
.
IsUnspecified
(
)
;
}
#
define
FUNCTIONS_ON_MEMBER
(
NAME
)
\
MarkerOptions
&
Set
(
Marker
#
#
NAME
&
&
a
#
#
NAME
)
&
{
\
m
#
#
NAME
=
std
:
:
move
(
a
#
#
NAME
)
;
\
return
*
this
;
\
}
\
\
MarkerOptions
&
&
Set
(
Marker
#
#
NAME
&
&
a
#
#
NAME
)
&
&
{
\
m
#
#
NAME
=
std
:
:
move
(
a
#
#
NAME
)
;
\
return
std
:
:
move
(
*
this
)
;
\
}
\
\
const
Marker
#
#
NAME
&
NAME
(
)
const
{
return
m
#
#
NAME
;
}
\
\
Marker
#
#
NAME
&
NAME
#
#
Ref
(
)
{
return
m
#
#
NAME
;
}
FUNCTIONS_ON_MEMBER
(
ThreadId
)
;
FUNCTIONS_ON_MEMBER
(
Timing
)
;
FUNCTIONS_ON_MEMBER
(
Stack
)
;
FUNCTIONS_ON_MEMBER
(
InnerWindowId
)
;
#
undef
FUNCTIONS_ON_MEMBER
private
:
friend
ProfileBufferEntryReader
:
:
Deserializer
<
MarkerOptions
>
;
MarkerThreadId
mThreadId
;
MarkerTiming
mTiming
;
MarkerStack
mStack
;
MarkerInnerWindowId
mInnerWindowId
;
}
;
}
namespace
mozilla
:
:
baseprofiler
:
:
markers
{
struct
NoPayload
final
{
}
;
}
namespace
mozilla
{
class
JSONWriter
;
class
MarkerSchema
{
public
:
enum
class
InputType
{
Uint64
Uint32
Uint8
Boolean
CString
String
TimeStamp
TimeDuration
}
;
template
<
typename
T
>
static
constexpr
InputType
getDefaultInputTypeForType
(
)
{
using
CleanT
=
std
:
:
remove_cv_t
<
std
:
:
remove_pointer_t
<
T
>
>
;
if
constexpr
(
std
:
:
is_same_v
<
CleanT
bool
>
)
{
return
InputType
:
:
Boolean
;
}
else
if
constexpr
(
std
:
:
is_unsigned_v
<
CleanT
>
&
&
sizeof
(
CleanT
)
=
=
4
)
{
return
InputType
:
:
Uint32
;
}
else
if
constexpr
(
std
:
:
is_unsigned_v
<
CleanT
>
&
&
sizeof
(
CleanT
)
=
=
8
)
{
return
InputType
:
:
Uint64
;
}
else
if
constexpr
(
std
:
:
is_unsigned_v
<
CleanT
>
&
&
sizeof
(
CleanT
)
=
=
1
)
{
return
InputType
:
:
Uint8
;
}
else
if
constexpr
(
std
:
:
is_same_v
<
CleanT
TimeStamp
>
)
{
return
InputType
:
:
TimeStamp
;
}
else
if
constexpr
(
std
:
:
is_same_v
<
CleanT
TimeDuration
>
)
{
return
InputType
:
:
TimeDuration
;
}
else
if
constexpr
(
std
:
:
is_same_v
<
CleanT
ProfilerString8View
>
)
{
return
InputType
:
:
CString
;
}
else
{
static_assert
(
sizeof
(
T
)
=
=
0
"
Unsupported
type
"
)
;
}
}
enum
class
Location
:
unsigned
{
MarkerChart
MarkerTable
TimelineOverview
TimelineMemory
TimelineIPC
TimelineFileIO
StackChart
}
;
struct
SpecialFrontendLocation
{
}
;
enum
class
Format
{
Url
FilePath
SanitizedString
String
UniqueString
Duration
Time
Seconds
Milliseconds
Microseconds
Nanoseconds
Bytes
Percentage
Integer
Decimal
Flow
TerminatingFlow
}
;
template
<
typename
T
>
static
constexpr
Format
getDefaultFormatForType
(
)
{
using
CleanT
=
std
:
:
remove_cv_t
<
T
>
;
if
constexpr
(
std
:
:
is_unsigned_v
<
CleanT
>
|
|
std
:
:
is_same_v
<
CleanT
bool
>
)
{
return
Format
:
:
Integer
;
}
else
if
constexpr
(
std
:
:
is_same_v
<
CleanT
TimeStamp
>
)
{
return
Format
:
:
Time
;
}
else
if
constexpr
(
std
:
:
is_same_v
<
CleanT
TimeDuration
>
)
{
return
Format
:
:
Duration
;
}
else
if
constexpr
(
std
:
:
is_same_v
<
CleanT
ProfilerString8View
>
)
{
return
Format
:
:
SanitizedString
;
}
else
{
static_assert
(
sizeof
(
T
)
=
=
0
"
Unsupported
type
"
)
;
}
}
enum
class
ETWMarkerGroup
:
uint64_t
{
Generic
=
1
UserMarkers
=
1
<
<
1
Memory
=
1
<
<
2
Scheduling
=
1
<
<
3
Text
=
1
<
<
4
Tracing
=
1
<
<
5
}
;
enum
class
PayloadFlags
:
uint32_t
{
None
=
0
Searchable
=
1
}
;
struct
PayloadField
{
const
char
*
Key
;
InputType
InputTy
;
const
char
*
Label
=
nullptr
;
Format
Fmt
=
Format
:
:
String
;
PayloadFlags
Flags
=
PayloadFlags
:
:
None
;
}
;
enum
class
Searchable
{
NotSearchable
Searchable
}
;
enum
class
GraphType
{
Line
Bar
FilledLine
}
;
enum
class
GraphColor
{
Blue
Green
Grey
Ink
Magenta
Orange
Purple
Red
Teal
Yellow
}
;
template
<
typename
.
.
.
Locations
>
explicit
MarkerSchema
(
Location
aLocation
Locations
.
.
.
aLocations
)
:
mLocations
{
aLocation
aLocations
.
.
.
}
{
}
explicit
MarkerSchema
(
const
mozilla
:
:
MarkerSchema
:
:
Location
*
aLocations
size_t
aLength
)
:
mLocations
(
aLocations
aLocations
+
aLength
)
{
}
MOZ_IMPLICIT
MarkerSchema
(
SpecialFrontendLocation
)
{
}
MarkerSchema
(
)
=
delete
;
#
define
LABEL_SETTER
(
name
)
\
MarkerSchema
&
Set
#
#
name
(
std
:
:
string
a
#
#
name
)
{
\
m
#
#
name
=
std
:
:
move
(
a
#
#
name
)
;
\
return
*
this
;
\
}
LABEL_SETTER
(
ChartLabel
)
LABEL_SETTER
(
TooltipLabel
)
LABEL_SETTER
(
TableLabel
)
#
undef
LABEL_SETTER
MarkerSchema
&
SetAllLabels
(
std
:
:
string
aText
)
{
SetChartLabel
(
aText
)
;
SetTooltipLabel
(
aText
)
;
SetTableLabel
(
std
:
:
move
(
aText
)
)
;
return
*
this
;
}
MarkerSchema
&
SetIsStackBased
(
)
{
mIsStackBased
=
true
;
return
*
this
;
}
MarkerSchema
&
AddKeyFormat
(
std
:
:
string
aKey
Format
aFormat
)
{
mData
.
emplace_back
(
mozilla
:
:
VariantType
<
DynamicData
>
{
}
DynamicData
{
std
:
:
move
(
aKey
)
mozilla
:
:
Nothing
{
}
aFormat
mozilla
:
:
Nothing
{
}
}
)
;
return
*
this
;
}
MarkerSchema
&
AddKeyLabelFormat
(
std
:
:
string
aKey
std
:
:
string
aLabel
Format
aFormat
)
{
mData
.
emplace_back
(
mozilla
:
:
VariantType
<
DynamicData
>
{
}
DynamicData
{
std
:
:
move
(
aKey
)
mozilla
:
:
Some
(
std
:
:
move
(
aLabel
)
)
aFormat
mozilla
:
:
Nothing
{
}
}
)
;
return
*
this
;
}
MarkerSchema
&
AddKeyFormatSearchable
(
std
:
:
string
aKey
Format
aFormat
Searchable
aSearchable
)
{
mData
.
emplace_back
(
mozilla
:
:
VariantType
<
DynamicData
>
{
}
DynamicData
{
std
:
:
move
(
aKey
)
mozilla
:
:
Nothing
{
}
aFormat
mozilla
:
:
Some
(
aSearchable
)
}
)
;
return
*
this
;
}
MarkerSchema
&
AddKeyLabelFormatSearchable
(
std
:
:
string
aKey
std
:
:
string
aLabel
Format
aFormat
Searchable
aSearchable
)
{
mData
.
emplace_back
(
mozilla
:
:
VariantType
<
DynamicData
>
{
}
DynamicData
{
std
:
:
move
(
aKey
)
mozilla
:
:
Some
(
std
:
:
move
(
aLabel
)
)
aFormat
mozilla
:
:
Some
(
aSearchable
)
}
)
;
return
*
this
;
}
MarkerSchema
&
AddStaticLabelValue
(
std
:
:
string
aLabel
std
:
:
string
aValue
)
{
mData
.
emplace_back
(
mozilla
:
:
VariantType
<
StaticData
>
{
}
StaticData
{
std
:
:
move
(
aLabel
)
std
:
:
move
(
aValue
)
}
)
;
return
*
this
;
}
MarkerSchema
&
AddChart
(
std
:
:
string
aKey
GraphType
aType
)
{
mGraphs
.
emplace_back
(
GraphData
{
std
:
:
move
(
aKey
)
aType
mozilla
:
:
Nothing
{
}
}
)
;
return
*
this
;
}
MarkerSchema
&
AddChartColor
(
std
:
:
string
aKey
GraphType
aType
GraphColor
aColor
)
{
mGraphs
.
emplace_back
(
GraphData
{
std
:
:
move
(
aKey
)
aType
mozilla
:
:
Some
(
aColor
)
}
)
;
return
*
this
;
}
MFBT_API
void
Stream
(
JSONWriter
&
aWriter
const
Span
<
const
char
>
&
aName
)
&
&
;
private
:
MFBT_API
static
Span
<
const
char
>
LocationToStringSpan
(
Location
aLocation
)
;
MFBT_API
static
Span
<
const
char
>
FormatToStringSpan
(
Format
aFormat
)
;
MFBT_API
static
Span
<
const
char
>
GraphTypeToStringSpan
(
GraphType
aType
)
;
MFBT_API
static
Span
<
const
char
>
GraphColorToStringSpan
(
GraphColor
aColor
)
;
std
:
:
vector
<
Location
>
mLocations
;
std
:
:
string
mChartLabel
;
std
:
:
string
mTooltipLabel
;
std
:
:
string
mTableLabel
;
bool
mIsStackBased
=
false
;
private
:
struct
DynamicData
{
std
:
:
string
mKey
;
mozilla
:
:
Maybe
<
std
:
:
string
>
mLabel
;
Format
mFormat
;
mozilla
:
:
Maybe
<
Searchable
>
mSearchable
;
}
;
struct
StaticData
{
std
:
:
string
mLabel
;
std
:
:
string
mValue
;
}
;
using
DataRow
=
mozilla
:
:
Variant
<
DynamicData
StaticData
>
;
using
DataRowVector
=
std
:
:
vector
<
DataRow
>
;
DataRowVector
mData
;
struct
GraphData
{
std
:
:
string
mKey
;
GraphType
mType
;
mozilla
:
:
Maybe
<
GraphColor
>
mColor
;
}
;
std
:
:
vector
<
GraphData
>
mGraphs
;
}
;
namespace
detail
{
template
<
typename
PayloadType
>
static
void
StreamPayload
(
baseprofiler
:
:
SpliceableJSONWriter
&
aWriter
const
Span
<
const
char
>
aKey
const
PayloadType
&
aPayload
)
{
using
CleanT
=
std
:
:
remove_cv_t
<
PayloadType
>
;
if
constexpr
(
std
:
:
is_unsigned_v
<
CleanT
>
)
{
aWriter
.
IntProperty
(
aKey
aPayload
)
;
}
else
{
aWriter
.
StringProperty
(
aKey
aPayload
)
;
}
}
template
<
typename
PayloadType
>
inline
void
StreamPayload
(
baseprofiler
:
:
SpliceableJSONWriter
&
aWriter
const
Span
<
const
char
>
aKey
const
Maybe
<
PayloadType
>
&
aPayload
)
{
if
(
aPayload
.
isSome
(
)
)
{
StreamPayload
(
aWriter
aKey
*
aPayload
)
;
}
else
{
aWriter
.
NullProperty
(
aKey
)
;
}
}
template
<
>
inline
void
StreamPayload
<
bool
>
(
baseprofiler
:
:
SpliceableJSONWriter
&
aWriter
const
Span
<
const
char
>
aKey
const
bool
&
aPayload
)
{
aWriter
.
BoolProperty
(
aKey
aPayload
)
;
}
template
<
>
inline
void
StreamPayload
<
ProfilerString8View
>
(
baseprofiler
:
:
SpliceableJSONWriter
&
aWriter
const
Span
<
const
char
>
aKey
const
ProfilerString8View
&
aPayload
)
{
aWriter
.
StringProperty
(
aKey
aPayload
)
;
}
template
<
>
inline
void
StreamPayload
<
Flow
>
(
baseprofiler
:
:
SpliceableJSONWriter
&
aWriter
const
Span
<
const
char
>
aKey
const
Flow
&
aPayload
)
{
aWriter
.
FlowProperty
(
aKey
aPayload
)
;
}
}
template
<
typename
T
>
struct
BaseMarkerType
{
static
constexpr
const
char
*
Description
=
nullptr
;
static
constexpr
const
char
*
AllLabels
=
nullptr
;
static
constexpr
const
char
*
ChartLabel
=
nullptr
;
static
constexpr
const
char
*
TableLabel
=
nullptr
;
static
constexpr
const
char
*
TooltipLabel
=
nullptr
;
static
constexpr
bool
IsStackBased
=
false
;
static
constexpr
bool
StoreName
=
false
;
static
constexpr
MarkerSchema
:
:
ETWMarkerGroup
Group
=
MarkerSchema
:
:
ETWMarkerGroup
:
:
Generic
;
static
MarkerSchema
MarkerTypeDisplay
(
)
{
using
MS
=
MarkerSchema
;
MS
schema
{
T
:
:
Locations
std
:
:
size
(
T
:
:
Locations
)
}
;
if
(
T
:
:
AllLabels
)
{
schema
.
SetAllLabels
(
T
:
:
AllLabels
)
;
}
if
(
T
:
:
ChartLabel
)
{
schema
.
SetChartLabel
(
T
:
:
ChartLabel
)
;
}
if
(
T
:
:
TableLabel
)
{
schema
.
SetTableLabel
(
T
:
:
TableLabel
)
;
}
if
(
T
:
:
TooltipLabel
)
{
schema
.
SetTooltipLabel
(
T
:
:
TooltipLabel
)
;
}
if
(
T
:
:
IsStackBased
)
{
schema
.
SetIsStackBased
(
)
;
}
for
(
const
MS
:
:
PayloadField
field
:
T
:
:
PayloadFields
)
{
if
(
field
.
Label
)
{
if
(
uint32_t
(
field
.
Flags
)
&
uint32_t
(
MS
:
:
PayloadFlags
:
:
Searchable
)
)
{
schema
.
AddKeyLabelFormatSearchable
(
field
.
Key
field
.
Label
field
.
Fmt
MS
:
:
Searchable
:
:
Searchable
)
;
}
else
{
schema
.
AddKeyLabelFormat
(
field
.
Key
field
.
Label
field
.
Fmt
)
;
}
}
else
{
if
(
uint32_t
(
field
.
Flags
)
&
uint32_t
(
MS
:
:
PayloadFlags
:
:
Searchable
)
)
{
schema
.
AddKeyFormatSearchable
(
field
.
Key
field
.
Fmt
MS
:
:
Searchable
:
:
Searchable
)
;
}
else
{
schema
.
AddKeyFormat
(
field
.
Key
field
.
Fmt
)
;
}
}
}
if
(
T
:
:
Description
)
{
schema
.
AddStaticLabelValue
(
"
Description
"
T
:
:
Description
)
;
}
return
schema
;
}
static
constexpr
Span
<
const
char
>
MarkerTypeName
(
)
{
return
MakeStringSpan
(
T
:
:
Name
)
;
}
template
<
typename
.
.
.
PayloadArguments
>
static
void
StreamJSONMarkerDataImpl
(
baseprofiler
:
:
SpliceableJSONWriter
&
aWriter
const
PayloadArguments
&
.
.
.
aPayloadArguments
)
{
size_t
i
=
0
;
(
detail
:
:
StreamPayload
(
aWriter
MakeStringSpan
(
T
:
:
PayloadFields
[
i
+
+
]
.
Key
)
aPayloadArguments
)
.
.
.
)
;
}
}
;
}
#
endif
