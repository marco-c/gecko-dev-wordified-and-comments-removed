#
ifndef
ProfileBufferControlledChunkManager_h
#
define
ProfileBufferControlledChunkManager_h
#
include
"
mozilla
/
ProfileBufferChunk
.
h
"
#
include
<
functional
>
#
include
<
vector
>
namespace
mozilla
{
class
ProfileBufferControlledChunkManager
{
public
:
using
Length
=
ProfileBufferChunk
:
:
Length
;
virtual
~
ProfileBufferControlledChunkManager
(
)
=
default
;
struct
ChunkMetadata
{
TimeStamp
mDoneTimeStamp
;
Length
mBufferBytes
;
ChunkMetadata
(
TimeStamp
aDoneTimeStamp
Length
aBufferBytes
)
:
mDoneTimeStamp
(
aDoneTimeStamp
)
mBufferBytes
(
aBufferBytes
)
{
}
}
;
class
Update
{
public
:
Update
(
)
=
default
;
explicit
Update
(
decltype
(
nullptr
)
)
:
mUnreleasedBytes
(
FINAL
)
{
}
Update
(
size_t
aUnreleasedBytes
size_t
aReleasedBytes
const
ProfileBufferChunk
*
aExistingReleasedChunks
const
ProfileBufferChunk
*
aNewlyReleasedChunks
)
:
mUnreleasedBytes
(
aUnreleasedBytes
)
mReleasedBytes
(
aReleasedBytes
)
mOldestDoneTimeStamp
(
aExistingReleasedChunks
?
aExistingReleasedChunks
-
>
ChunkHeader
(
)
.
mDoneTimeStamp
:
TimeStamp
{
}
)
{
MOZ_RELEASE_ASSERT
(
!
IsNotUpdate
(
)
"
Empty
update
should
only
be
constructed
with
default
constructor
"
)
;
MOZ_RELEASE_ASSERT
(
!
IsFinal
(
)
"
Final
update
should
only
be
constructed
with
nullptr
constructor
"
)
;
for
(
const
ProfileBufferChunk
*
chunk
=
aNewlyReleasedChunks
;
chunk
;
chunk
=
chunk
-
>
GetNext
(
)
)
{
mNewlyReleasedChunks
.
emplace_back
(
ChunkMetadata
{
chunk
-
>
ChunkHeader
(
)
.
mDoneTimeStamp
chunk
-
>
BufferBytes
(
)
}
)
;
}
}
Update
(
size_t
aUnreleasedBytes
size_t
aReleasedBytes
TimeStamp
aOldestDoneTimeStamp
std
:
:
vector
<
ChunkMetadata
>
&
&
aNewlyReleasedChunks
)
:
mUnreleasedBytes
(
aUnreleasedBytes
)
mReleasedBytes
(
aReleasedBytes
)
mOldestDoneTimeStamp
(
aOldestDoneTimeStamp
)
mNewlyReleasedChunks
(
std
:
:
move
(
aNewlyReleasedChunks
)
)
{
}
void
Clear
(
)
{
mUnreleasedBytes
=
NO_UPDATE
;
mReleasedBytes
=
0
;
mOldestDoneTimeStamp
=
TimeStamp
{
}
;
mNewlyReleasedChunks
.
clear
(
)
;
}
bool
IsNotUpdate
(
)
const
{
return
mUnreleasedBytes
=
=
NO_UPDATE
;
}
bool
IsFinal
(
)
const
{
return
mUnreleasedBytes
=
=
FINAL
;
}
size_t
UnreleasedBytes
(
)
const
{
MOZ_RELEASE_ASSERT
(
!
IsNotUpdate
(
)
"
Cannot
access
UnreleasedBytes
from
empty
update
"
)
;
MOZ_RELEASE_ASSERT
(
!
IsFinal
(
)
"
Cannot
access
UnreleasedBytes
from
final
update
"
)
;
return
mUnreleasedBytes
;
}
size_t
ReleasedBytes
(
)
const
{
MOZ_RELEASE_ASSERT
(
!
IsNotUpdate
(
)
"
Cannot
access
ReleasedBytes
from
empty
update
"
)
;
MOZ_RELEASE_ASSERT
(
!
IsFinal
(
)
"
Cannot
access
ReleasedBytes
from
final
update
"
)
;
return
mReleasedBytes
;
}
TimeStamp
OldestDoneTimeStamp
(
)
const
{
MOZ_RELEASE_ASSERT
(
!
IsNotUpdate
(
)
"
Cannot
access
OldestDoneTimeStamp
from
empty
update
"
)
;
MOZ_RELEASE_ASSERT
(
!
IsFinal
(
)
"
Cannot
access
OldestDoneTimeStamp
from
final
update
"
)
;
return
mOldestDoneTimeStamp
;
}
const
std
:
:
vector
<
ChunkMetadata
>
&
NewlyReleasedChunksRef
(
)
const
{
MOZ_RELEASE_ASSERT
(
!
IsNotUpdate
(
)
"
Cannot
access
NewlyReleasedChunksRef
from
empty
update
"
)
;
MOZ_RELEASE_ASSERT
(
!
IsFinal
(
)
"
Cannot
access
NewlyReleasedChunksRef
from
final
update
"
)
;
return
mNewlyReleasedChunks
;
}
void
Fold
(
Update
&
&
aNewUpdate
)
{
MOZ_ASSERT
(
!
IsFinal
(
)
|
|
aNewUpdate
.
IsFinal
(
)
"
There
shouldn
'
t
be
another
non
-
final
update
after
the
final
update
"
)
;
if
(
IsNotUpdate
(
)
|
|
aNewUpdate
.
IsFinal
(
)
)
{
*
this
=
std
:
:
move
(
aNewUpdate
)
;
return
;
}
mUnreleasedBytes
=
aNewUpdate
.
mUnreleasedBytes
;
mReleasedBytes
=
aNewUpdate
.
mReleasedBytes
;
if
(
!
aNewUpdate
.
mOldestDoneTimeStamp
.
IsNull
(
)
)
{
MOZ_ASSERT
(
mOldestDoneTimeStamp
.
IsNull
(
)
|
|
mOldestDoneTimeStamp
<
=
aNewUpdate
.
mOldestDoneTimeStamp
)
;
mOldestDoneTimeStamp
=
aNewUpdate
.
mOldestDoneTimeStamp
;
auto
it
=
mNewlyReleasedChunks
.
begin
(
)
;
while
(
it
!
=
mNewlyReleasedChunks
.
end
(
)
&
&
it
-
>
mDoneTimeStamp
<
mOldestDoneTimeStamp
)
{
it
=
mNewlyReleasedChunks
.
erase
(
it
)
;
}
}
if
(
!
aNewUpdate
.
mNewlyReleasedChunks
.
empty
(
)
)
{
mNewlyReleasedChunks
.
reserve
(
mNewlyReleasedChunks
.
size
(
)
+
aNewUpdate
.
mNewlyReleasedChunks
.
size
(
)
)
;
mNewlyReleasedChunks
.
insert
(
mNewlyReleasedChunks
.
end
(
)
aNewUpdate
.
mNewlyReleasedChunks
.
begin
(
)
aNewUpdate
.
mNewlyReleasedChunks
.
end
(
)
)
;
}
}
private
:
static
const
size_t
NO_UPDATE
=
size_t
(
-
1
)
;
static
const
size_t
FINAL
=
size_t
(
-
2
)
;
size_t
mUnreleasedBytes
=
NO_UPDATE
;
size_t
mReleasedBytes
=
0
;
TimeStamp
mOldestDoneTimeStamp
;
std
:
:
vector
<
ChunkMetadata
>
mNewlyReleasedChunks
;
}
;
using
UpdateCallback
=
std
:
:
function
<
void
(
Update
&
&
)
>
;
virtual
void
SetUpdateCallback
(
UpdateCallback
&
&
aUpdateCallback
)
=
0
;
virtual
void
DestroyChunksAtOrBefore
(
TimeStamp
aDoneTimeStamp
)
=
0
;
}
;
}
#
endif
