#
ifndef
ProfileBufferChunk_h
#
define
ProfileBufferChunk_h
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
ProfileBufferIndex
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
if
defined
(
MOZ_MEMORY
)
#
include
"
mozmemory
.
h
"
#
endif
#
include
<
algorithm
>
#
include
<
limits
>
#
include
<
type_traits
>
#
ifdef
DEBUG
#
include
<
cstdio
>
#
endif
namespace
mozilla
{
class
ProfileBufferChunk
{
public
:
using
Byte
=
uint8_t
;
using
Length
=
uint32_t
;
using
SpanOfBytes
=
Span
<
Byte
>
;
[
[
nodiscard
]
]
static
constexpr
Length
SizeofChunkMetadata
(
)
{
return
static_cast
<
Length
>
(
sizeof
(
InternalHeader
)
)
;
}
[
[
nodiscard
]
]
static
UniquePtr
<
ProfileBufferChunk
>
Create
(
Length
aMinBufferBytes
)
{
aMinBufferBytes
=
std
:
:
max
(
aMinBufferBytes
Length
(
1
)
)
;
struct
alignas
(
alignof
(
InternalHeader
)
)
ChunkStruct
{
Byte
c
[
alignof
(
InternalHeader
)
]
;
}
;
static_assert
(
std
:
:
is_trivial_v
<
ChunkStruct
>
"
ChunkStruct
must
be
trivial
to
avoid
any
construction
"
)
;
size_t
count
=
(
sizeof
(
InternalHeader
)
+
aMinBufferBytes
+
(
alignof
(
InternalHeader
)
-
1
)
)
/
alignof
(
InternalHeader
)
;
#
if
defined
(
MOZ_MEMORY
)
count
=
(
malloc_good_size
(
count
*
sizeof
(
ChunkStruct
)
)
+
(
sizeof
(
ChunkStruct
)
-
1
)
)
/
sizeof
(
ChunkStruct
)
;
#
endif
auto
chunkStorage
=
MakeUnique
<
ChunkStruct
[
]
>
(
count
)
;
MOZ_ASSERT
(
reinterpret_cast
<
uintptr_t
>
(
chunkStorage
.
get
(
)
)
%
alignof
(
InternalHeader
)
=
=
0
)
;
const
size_t
chunkBytes
=
count
*
sizeof
(
ChunkStruct
)
;
MOZ_ASSERT
(
chunkBytes
>
=
sizeof
(
ProfileBufferChunk
)
"
Not
enough
space
to
construct
a
ProfileBufferChunk
"
)
;
MOZ_ASSERT
(
chunkBytes
<
=
static_cast
<
size_t
>
(
std
:
:
numeric_limits
<
Length
>
:
:
max
(
)
)
)
;
const
Length
bufferBytes
=
static_cast
<
Length
>
(
chunkBytes
-
sizeof
(
InternalHeader
)
)
;
MOZ_ASSERT
(
bufferBytes
>
=
aMinBufferBytes
"
Not
enough
space
for
minimum
buffer
size
"
)
;
new
(
chunkStorage
.
get
(
)
)
ProfileBufferChunk
(
bufferBytes
)
;
UniquePtr
<
ProfileBufferChunk
>
chunk
{
reinterpret_cast
<
ProfileBufferChunk
*
>
(
chunkStorage
.
release
(
)
)
}
;
MOZ_ASSERT
(
size_t
(
reinterpret_cast
<
const
char
*
>
(
&
chunk
.
get
(
)
-
>
BufferSpan
(
)
[
bufferBytes
-
1
]
)
-
reinterpret_cast
<
const
char
*
>
(
chunk
.
get
(
)
)
)
=
=
chunkBytes
-
1
"
Buffer
span
spills
out
of
chunk
allocation
"
)
;
return
chunk
;
}
#
ifdef
DEBUG
~
ProfileBufferChunk
(
)
{
MOZ_ASSERT
(
mInternalHeader
.
mState
!
=
InternalHeader
:
:
State
:
:
InUse
)
;
MOZ_ASSERT
(
mInternalHeader
.
mState
!
=
InternalHeader
:
:
State
:
:
Full
)
;
MOZ_ASSERT
(
mInternalHeader
.
mState
=
=
InternalHeader
:
:
State
:
:
Created
|
|
mInternalHeader
.
mState
=
=
InternalHeader
:
:
State
:
:
Done
|
|
mInternalHeader
.
mState
=
=
InternalHeader
:
:
State
:
:
Recycled
)
;
}
#
endif
[
[
nodiscard
]
]
SpanOfBytes
ReserveInitialBlockAsTail
(
Length
aTailSize
)
{
#
ifdef
DEBUG
MOZ_ASSERT
(
mInternalHeader
.
mState
!
=
InternalHeader
:
:
State
:
:
InUse
)
;
MOZ_ASSERT
(
mInternalHeader
.
mState
!
=
InternalHeader
:
:
State
:
:
Full
)
;
MOZ_ASSERT
(
mInternalHeader
.
mState
!
=
InternalHeader
:
:
State
:
:
Done
)
;
MOZ_ASSERT
(
mInternalHeader
.
mState
=
=
InternalHeader
:
:
State
:
:
Created
|
|
mInternalHeader
.
mState
=
=
InternalHeader
:
:
State
:
:
Recycled
)
;
mInternalHeader
.
mState
=
InternalHeader
:
:
State
:
:
InUse
;
#
endif
mInternalHeader
.
mHeader
.
mOffsetFirstBlock
=
aTailSize
;
mInternalHeader
.
mHeader
.
mOffsetPastLastBlock
=
aTailSize
;
mInternalHeader
.
mHeader
.
mStartTimeStamp
=
TimeStamp
:
:
Now
(
)
;
return
SpanOfBytes
(
&
mBuffer
aTailSize
)
;
}
struct
ReserveReturn
{
SpanOfBytes
mSpan
;
ProfileBufferBlockIndex
mBlockRangeIndex
;
}
;
[
[
nodiscard
]
]
ReserveReturn
ReserveBlock
(
Length
aBlockSize
)
{
MOZ_ASSERT
(
mInternalHeader
.
mState
!
=
InternalHeader
:
:
State
:
:
Created
)
;
MOZ_ASSERT
(
mInternalHeader
.
mState
!
=
InternalHeader
:
:
State
:
:
Full
)
;
MOZ_ASSERT
(
mInternalHeader
.
mState
!
=
InternalHeader
:
:
State
:
:
Done
)
;
MOZ_ASSERT
(
mInternalHeader
.
mState
!
=
InternalHeader
:
:
State
:
:
Recycled
)
;
MOZ_ASSERT
(
mInternalHeader
.
mState
=
=
InternalHeader
:
:
State
:
:
InUse
)
;
MOZ_ASSERT
(
RangeStart
(
)
!
=
0
"
Expected
valid
range
start
before
first
Reserve
(
)
"
)
;
const
Length
blockOffset
=
mInternalHeader
.
mHeader
.
mOffsetPastLastBlock
;
Length
reservedSize
=
aBlockSize
;
if
(
MOZ_UNLIKELY
(
aBlockSize
>
=
RemainingBytes
(
)
)
)
{
reservedSize
=
RemainingBytes
(
)
;
#
ifdef
DEBUG
mInternalHeader
.
mState
=
InternalHeader
:
:
State
:
:
Full
;
#
endif
}
mInternalHeader
.
mHeader
.
mOffsetPastLastBlock
+
=
reservedSize
;
mInternalHeader
.
mHeader
.
mBlockCount
+
=
1
;
return
{
SpanOfBytes
(
&
mBuffer
+
blockOffset
reservedSize
)
ProfileBufferBlockIndex
:
:
CreateFromProfileBufferIndex
(
mInternalHeader
.
mHeader
.
mRangeStart
+
blockOffset
)
}
;
}
void
MarkDone
(
)
{
#
ifdef
DEBUG
MOZ_ASSERT
(
mInternalHeader
.
mState
!
=
InternalHeader
:
:
State
:
:
Created
)
;
MOZ_ASSERT
(
mInternalHeader
.
mState
!
=
InternalHeader
:
:
State
:
:
Done
)
;
MOZ_ASSERT
(
mInternalHeader
.
mState
!
=
InternalHeader
:
:
State
:
:
Recycled
)
;
MOZ_ASSERT
(
mInternalHeader
.
mState
=
=
InternalHeader
:
:
State
:
:
InUse
|
|
mInternalHeader
.
mState
=
=
InternalHeader
:
:
State
:
:
Full
)
;
mInternalHeader
.
mState
=
InternalHeader
:
:
State
:
:
Done
;
#
endif
mInternalHeader
.
mHeader
.
mDoneTimeStamp
=
TimeStamp
:
:
Now
(
)
;
}
void
MarkRecycled
(
)
{
#
ifdef
DEBUG
MOZ_ASSERT
(
mInternalHeader
.
mState
!
=
InternalHeader
:
:
State
:
:
InUse
)
;
MOZ_ASSERT
(
mInternalHeader
.
mState
!
=
InternalHeader
:
:
State
:
:
Full
)
;
MOZ_ASSERT
(
mInternalHeader
.
mState
=
=
InternalHeader
:
:
State
:
:
Created
|
|
mInternalHeader
.
mState
=
=
InternalHeader
:
:
State
:
:
Done
|
|
mInternalHeader
.
mState
=
=
InternalHeader
:
:
State
:
:
Recycled
)
;
mInternalHeader
.
mState
=
InternalHeader
:
:
State
:
:
Recycled
;
#
endif
mInternalHeader
.
mHeader
.
Reset
(
)
;
}
struct
Header
{
explicit
Header
(
Length
aBufferBytes
)
:
mBufferBytes
(
aBufferBytes
)
{
}
void
Reset
(
)
{
mOffsetFirstBlock
=
0
;
mOffsetPastLastBlock
=
0
;
mStartTimeStamp
=
TimeStamp
{
}
;
mDoneTimeStamp
=
TimeStamp
{
}
;
mBlockCount
=
0
;
mRangeStart
=
0
;
mProcessId
=
0
;
}
Length
mOffsetFirstBlock
=
0
;
Length
mOffsetPastLastBlock
=
0
;
TimeStamp
mStartTimeStamp
;
TimeStamp
mDoneTimeStamp
;
const
Length
mBufferBytes
;
Length
mBlockCount
=
0
;
ProfileBufferIndex
mRangeStart
=
0
;
int
mProcessId
=
0
;
const
int
mPADDING
=
0
;
}
;
[
[
nodiscard
]
]
const
Header
&
ChunkHeader
(
)
const
{
return
mInternalHeader
.
mHeader
;
}
[
[
nodiscard
]
]
Length
BufferBytes
(
)
const
{
return
ChunkHeader
(
)
.
mBufferBytes
;
}
[
[
nodiscard
]
]
Length
ChunkBytes
(
)
const
{
return
static_cast
<
Length
>
(
sizeof
(
InternalHeader
)
)
+
BufferBytes
(
)
;
}
[
[
nodiscard
]
]
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
const
ProfileBufferChunk
*
const
next
=
GetNext
(
)
;
return
next
?
next
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
:
0
;
}
[
[
nodiscard
]
]
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
std
:
:
max
<
size_t
>
(
aMallocSizeOf
(
this
)
ChunkBytes
(
)
)
+
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
[
[
nodiscard
]
]
Length
RemainingBytes
(
)
const
{
return
BufferBytes
(
)
-
OffsetPastLastBlock
(
)
;
}
[
[
nodiscard
]
]
Length
OffsetFirstBlock
(
)
const
{
return
ChunkHeader
(
)
.
mOffsetFirstBlock
;
}
[
[
nodiscard
]
]
Length
OffsetPastLastBlock
(
)
const
{
return
ChunkHeader
(
)
.
mOffsetPastLastBlock
;
}
[
[
nodiscard
]
]
Length
BlockCount
(
)
const
{
return
ChunkHeader
(
)
.
mBlockCount
;
}
[
[
nodiscard
]
]
int
ProcessId
(
)
const
{
return
ChunkHeader
(
)
.
mProcessId
;
}
void
SetProcessId
(
int
aProcessId
)
{
mInternalHeader
.
mHeader
.
mProcessId
=
aProcessId
;
}
[
[
nodiscard
]
]
ProfileBufferIndex
RangeStart
(
)
const
{
return
ChunkHeader
(
)
.
mRangeStart
;
}
void
SetRangeStart
(
ProfileBufferIndex
aRangeStart
)
{
mInternalHeader
.
mHeader
.
mRangeStart
=
aRangeStart
;
}
[
[
nodiscard
]
]
Span
<
const
Byte
>
BufferSpan
(
)
const
{
return
Span
<
const
Byte
>
(
&
mBuffer
BufferBytes
(
)
)
;
}
[
[
nodiscard
]
]
Byte
ByteAt
(
Length
aOffset
)
const
{
MOZ_ASSERT
(
aOffset
<
OffsetPastLastBlock
(
)
)
;
return
*
(
&
mBuffer
+
aOffset
)
;
}
[
[
nodiscard
]
]
ProfileBufferChunk
*
GetNext
(
)
{
return
mInternalHeader
.
mNext
.
get
(
)
;
}
[
[
nodiscard
]
]
const
ProfileBufferChunk
*
GetNext
(
)
const
{
return
mInternalHeader
.
mNext
.
get
(
)
;
}
[
[
nodiscard
]
]
UniquePtr
<
ProfileBufferChunk
>
ReleaseNext
(
)
{
return
std
:
:
move
(
mInternalHeader
.
mNext
)
;
}
void
InsertNext
(
UniquePtr
<
ProfileBufferChunk
>
&
&
aChunk
)
{
if
(
!
aChunk
)
{
return
;
}
aChunk
-
>
SetLast
(
ReleaseNext
(
)
)
;
mInternalHeader
.
mNext
=
std
:
:
move
(
aChunk
)
;
}
[
[
nodiscard
]
]
ProfileBufferChunk
*
Last
(
)
{
ProfileBufferChunk
*
chunk
=
this
;
for
(
;
;
)
{
ProfileBufferChunk
*
next
=
chunk
-
>
GetNext
(
)
;
if
(
!
next
)
{
return
chunk
;
}
chunk
=
next
;
}
}
[
[
nodiscard
]
]
const
ProfileBufferChunk
*
Last
(
)
const
{
const
ProfileBufferChunk
*
chunk
=
this
;
for
(
;
;
)
{
const
ProfileBufferChunk
*
next
=
chunk
-
>
GetNext
(
)
;
if
(
!
next
)
{
return
chunk
;
}
chunk
=
next
;
}
}
void
SetLast
(
UniquePtr
<
ProfileBufferChunk
>
&
&
aChunk
)
{
if
(
!
aChunk
)
{
return
;
}
Last
(
)
-
>
mInternalHeader
.
mNext
=
std
:
:
move
(
aChunk
)
;
}
[
[
nodiscard
]
]
static
UniquePtr
<
ProfileBufferChunk
>
Join
(
UniquePtr
<
ProfileBufferChunk
>
&
&
aFirst
UniquePtr
<
ProfileBufferChunk
>
&
&
aLast
)
{
if
(
aFirst
)
{
aFirst
-
>
SetLast
(
std
:
:
move
(
aLast
)
)
;
return
std
:
:
move
(
aFirst
)
;
}
return
std
:
:
move
(
aLast
)
;
}
#
ifdef
DEBUG
void
Dump
(
std
:
:
FILE
*
aFile
=
stdout
)
const
{
fprintf
(
aFile
"
Chunk
[
%
p
]
chunkSize
=
%
u
bufferSize
=
%
u
state
=
%
s
rangeStart
=
%
u
"
"
firstBlockOffset
=
%
u
offsetPastLastBlock
=
%
u
blockCount
=
%
u
"
this
unsigned
(
ChunkBytes
(
)
)
unsigned
(
BufferBytes
(
)
)
mInternalHeader
.
StateString
(
)
unsigned
(
RangeStart
(
)
)
unsigned
(
OffsetFirstBlock
(
)
)
unsigned
(
OffsetPastLastBlock
(
)
)
unsigned
(
BlockCount
(
)
)
)
;
const
auto
len
=
OffsetPastLastBlock
(
)
;
constexpr
unsigned
columns
=
16
;
unsigned
char
ascii
[
columns
+
1
]
;
ascii
[
columns
]
=
'
\
0
'
;
for
(
Length
i
=
0
;
i
<
len
;
+
+
i
)
{
if
(
i
%
columns
=
=
0
)
{
fprintf
(
aFile
"
\
n
%
4u
=
0x
%
03x
:
"
unsigned
(
i
)
unsigned
(
i
)
)
;
for
(
unsigned
a
=
0
;
a
<
columns
;
+
+
a
)
{
ascii
[
a
]
=
'
'
;
}
}
unsigned
char
sep
=
'
'
;
if
(
i
=
=
OffsetFirstBlock
(
)
)
{
if
(
i
=
=
OffsetPastLastBlock
(
)
)
{
sep
=
'
#
'
;
}
else
{
sep
=
'
[
'
;
}
}
else
if
(
i
=
=
OffsetPastLastBlock
(
)
)
{
sep
=
'
]
'
;
}
unsigned
char
c
=
*
(
&
mBuffer
+
i
)
;
fprintf
(
aFile
"
%
c
%
02x
"
sep
c
)
;
if
(
i
=
=
len
-
1
)
{
if
(
i
+
1
=
=
OffsetPastLastBlock
(
)
)
{
fprintf
(
aFile
"
]
"
)
;
}
else
{
fprintf
(
aFile
"
"
)
;
}
}
else
if
(
i
%
columns
=
=
columns
-
1
)
{
fprintf
(
aFile
"
"
)
;
}
ascii
[
i
%
columns
]
=
(
c
>
=
'
'
&
&
c
<
=
'
~
'
)
?
c
:
'
.
'
;
if
(
i
%
columns
=
=
columns
-
1
)
{
fprintf
(
aFile
"
%
s
"
ascii
)
;
}
}
if
(
len
%
columns
<
columns
-
1
)
{
for
(
Length
i
=
len
%
columns
;
i
<
columns
;
+
+
i
)
{
fprintf
(
aFile
"
"
)
;
}
fprintf
(
aFile
"
%
s
"
ascii
)
;
}
fprintf
(
aFile
"
\
n
"
)
;
}
#
endif
private
:
explicit
ProfileBufferChunk
(
Length
aBufferBytes
)
:
mInternalHeader
(
aBufferBytes
)
{
}
struct
InternalHeader
{
explicit
InternalHeader
(
Length
aBufferBytes
)
:
mHeader
(
aBufferBytes
)
{
}
Header
mHeader
;
UniquePtr
<
ProfileBufferChunk
>
mNext
;
#
ifdef
DEBUG
enum
class
State
{
Created
InUse
Full
Done
Recycled
}
;
State
mState
=
State
:
:
Created
;
const
char
*
StateString
(
)
const
{
switch
(
mState
)
{
case
State
:
:
Created
:
return
"
Created
"
;
case
State
:
:
InUse
:
return
"
InUse
"
;
case
State
:
:
Full
:
return
"
Full
"
;
case
State
:
:
Done
:
return
"
Done
"
;
case
State
:
:
Recycled
:
return
"
Recycled
"
;
default
:
return
"
?
"
;
}
}
#
else
const
char
*
StateString
(
)
const
{
return
"
(
non
-
DEBUG
)
"
;
}
#
endif
}
;
InternalHeader
mInternalHeader
;
Byte
mBuffer
=
'
\
0
'
;
}
;
}
#
endif
