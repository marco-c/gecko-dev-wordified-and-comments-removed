#
ifndef
mozilla_FailureLatch_h
#
define
mozilla_FailureLatch_h
#
include
<
mozilla
/
Assertions
.
h
>
#
include
<
string
>
namespace
mozilla
{
class
FailureLatch
{
public
:
virtual
~
FailureLatch
(
)
=
default
;
[
[
nodiscard
]
]
virtual
bool
Fallible
(
)
const
=
0
;
virtual
void
SetFailure
(
std
:
:
string
aReason
)
=
0
;
[
[
nodiscard
]
]
virtual
bool
Failed
(
)
const
=
0
;
[
[
nodiscard
]
]
virtual
const
char
*
GetFailure
(
)
const
=
0
;
[
[
nodiscard
]
]
virtual
const
FailureLatch
&
SourceFailureLatch
(
)
const
=
0
;
[
[
nodiscard
]
]
virtual
FailureLatch
&
SourceFailureLatch
(
)
=
0
;
void
SetFailureFrom
(
const
FailureLatch
&
aOther
)
{
if
(
Failed
(
)
)
{
return
;
}
if
(
const
char
*
otherFailure
=
aOther
.
GetFailure
(
)
;
otherFailure
)
{
SetFailure
(
otherFailure
)
;
}
}
}
;
class
FailureLatchInfallibleSource
final
:
public
FailureLatch
{
public
:
[
[
nodiscard
]
]
bool
Fallible
(
)
const
final
{
return
false
;
}
void
SetFailure
(
std
:
:
string
aReason
)
final
{
MOZ_RELEASE_ASSERT
(
false
"
SetFailure
in
infallible
FailureLatchInfallibleSource
"
)
;
}
[
[
nodiscard
]
]
bool
Failed
(
)
const
final
{
return
false
;
}
[
[
nodiscard
]
]
const
char
*
GetFailure
(
)
const
final
{
return
nullptr
;
}
[
[
nodiscard
]
]
const
:
:
mozilla
:
:
FailureLatch
&
SourceFailureLatch
(
)
const
final
{
return
*
this
;
}
[
[
nodiscard
]
]
:
:
mozilla
:
:
FailureLatch
&
SourceFailureLatch
(
)
final
{
return
*
this
;
}
static
FailureLatchInfallibleSource
&
Singleton
(
)
{
static
FailureLatchInfallibleSource
singleton
;
return
singleton
;
}
}
;
class
FailureLatchSource
final
:
public
FailureLatch
{
public
:
[
[
nodiscard
]
]
bool
Fallible
(
)
const
final
{
return
true
;
}
void
SetFailure
(
std
:
:
string
aReason
)
final
{
if
(
!
mFailed
)
{
mFailed
=
true
;
mReason
=
std
:
:
move
(
aReason
)
;
}
}
[
[
nodiscard
]
]
bool
Failed
(
)
const
final
{
return
mFailed
;
}
[
[
nodiscard
]
]
const
char
*
GetFailure
(
)
const
final
{
return
mFailed
?
mReason
.
c_str
(
)
:
nullptr
;
}
[
[
nodiscard
]
]
const
FailureLatch
&
SourceFailureLatch
(
)
const
final
{
return
*
this
;
}
[
[
nodiscard
]
]
FailureLatch
&
SourceFailureLatch
(
)
final
{
return
*
this
;
}
private
:
bool
mFailed
=
false
;
std
:
:
string
mReason
;
}
;
#
define
FAILURELATCH_IMPL_PROXY
(
FAILURELATCH_REF
)
\
[
[
nodiscard
]
]
bool
Fallible
(
)
const
final
{
\
return
static_cast
<
const
:
:
mozilla
:
:
FailureLatch
&
>
(
FAILURELATCH_REF
)
\
.
Fallible
(
)
;
\
}
\
void
SetFailure
(
std
:
:
string
aReason
)
final
{
\
static_cast
<
:
:
mozilla
:
:
FailureLatch
&
>
(
FAILURELATCH_REF
)
\
.
SetFailure
(
std
:
:
move
(
aReason
)
)
;
\
}
\
[
[
nodiscard
]
]
bool
Failed
(
)
const
final
{
\
return
static_cast
<
const
:
:
mozilla
:
:
FailureLatch
&
>
(
FAILURELATCH_REF
)
\
.
Failed
(
)
;
\
}
\
[
[
nodiscard
]
]
const
char
*
GetFailure
(
)
const
final
{
\
return
static_cast
<
const
:
:
mozilla
:
:
FailureLatch
&
>
(
FAILURELATCH_REF
)
\
.
GetFailure
(
)
;
\
}
\
[
[
nodiscard
]
]
const
FailureLatch
&
SourceFailureLatch
(
)
const
final
{
\
return
static_cast
<
const
:
:
mozilla
:
:
FailureLatch
&
>
(
FAILURELATCH_REF
)
\
.
SourceFailureLatch
(
)
;
\
}
\
[
[
nodiscard
]
]
FailureLatch
&
SourceFailureLatch
(
)
final
{
\
return
static_cast
<
:
:
mozilla
:
:
FailureLatch
&
>
(
FAILURELATCH_REF
)
\
.
SourceFailureLatch
(
)
;
\
}
#
define
FAILURELATCH_IMPL_PROXY_OR_INFALLIBLE
(
FAILURELATCH_PTR
CLASS_NAME
)
\
[
[
nodiscard
]
]
bool
Fallible
(
)
const
final
{
\
return
FAILURELATCH_PTR
\
?
static_cast
<
const
:
:
mozilla
:
:
FailureLatch
*
>
(
FAILURELATCH_PTR
)
\
-
>
Fallible
(
)
\
:
false
;
\
}
\
void
SetFailure
(
std
:
:
string
aReason
)
final
{
\
if
(
FAILURELATCH_PTR
)
{
\
static_cast
<
:
:
mozilla
:
:
FailureLatch
*
>
(
FAILURELATCH_PTR
)
\
-
>
SetFailure
(
std
:
:
move
(
aReason
)
)
;
\
}
else
{
\
MOZ_RELEASE_ASSERT
(
false
"
SetFailure
in
infallible
"
#
CLASS_NAME
)
;
\
}
\
}
\
[
[
nodiscard
]
]
bool
Failed
(
)
const
final
{
\
return
FAILURELATCH_PTR
\
?
static_cast
<
const
:
:
mozilla
:
:
FailureLatch
*
>
(
FAILURELATCH_PTR
)
\
-
>
Failed
(
)
\
:
false
;
\
}
\
[
[
nodiscard
]
]
const
char
*
GetFailure
(
)
const
final
{
\
return
FAILURELATCH_PTR
\
?
static_cast
<
const
:
:
mozilla
:
:
FailureLatch
*
>
(
FAILURELATCH_PTR
)
\
-
>
GetFailure
(
)
\
:
nullptr
;
\
}
\
[
[
nodiscard
]
]
const
FailureLatch
&
SourceFailureLatch
(
)
const
final
{
\
return
FAILURELATCH_PTR
\
?
static_cast
<
const
:
:
mozilla
:
:
FailureLatch
*
>
(
FAILURELATCH_PTR
)
\
-
>
SourceFailureLatch
(
)
\
:
:
:
mozilla
:
:
FailureLatchInfallibleSource
:
:
Singleton
(
)
;
\
}
\
[
[
nodiscard
]
]
FailureLatch
&
SourceFailureLatch
(
)
final
{
\
return
FAILURELATCH_PTR
\
?
static_cast
<
:
:
mozilla
:
:
FailureLatch
*
>
(
FAILURELATCH_PTR
)
\
-
>
SourceFailureLatch
(
)
\
:
:
:
mozilla
:
:
FailureLatchInfallibleSource
:
:
Singleton
(
)
;
\
}
}
#
endif
