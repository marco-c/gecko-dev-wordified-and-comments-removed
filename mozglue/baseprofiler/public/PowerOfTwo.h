#
ifndef
PowerOfTwo_h
#
define
PowerOfTwo_h
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
<
limits
>
namespace
mozilla
{
template
<
typename
T
>
T
FriendlyRoundUpPow2
(
T
aInput
)
{
constexpr
T
max
=
T
(
1
)
<
<
(
sizeof
(
T
)
*
CHAR_BIT
-
1
)
;
if
(
aInput
>
=
max
)
{
return
max
;
}
return
T
(
1
)
<
<
CeilingLog2
(
aInput
)
;
}
namespace
detail
{
inline
uint_fast8_t
CountLeadingZeroes
(
uint32_t
aValue
)
{
MOZ_ASSERT
(
aValue
!
=
0
)
;
return
detail
:
:
CountLeadingZeroes32
(
aValue
)
;
}
inline
uint_fast8_t
CountLeadingZeroes
(
uint64_t
aValue
)
{
MOZ_ASSERT
(
aValue
!
=
0
)
;
return
detail
:
:
CountLeadingZeroes64
(
aValue
)
;
}
template
<
typename
T
>
inline
uint_fast8_t
CountLeadingZeroes
(
T
aValue
)
=
delete
;
}
template
<
typename
T
>
T
RoundUpPow2Mask
(
T
aInput
)
{
if
(
aInput
=
=
0
)
{
return
0
;
}
return
T
(
-
1
)
>
>
detail
:
:
CountLeadingZeroes
(
aInput
)
;
}
template
<
typename
T
>
class
PowerOfTwoMask
;
template
<
typename
T
T
Mask
>
constexpr
PowerOfTwoMask
<
T
>
MakePowerOfTwoMask
(
)
;
template
<
typename
T
>
class
PowerOfTwo
;
template
<
typename
T
T
Value
>
constexpr
PowerOfTwo
<
T
>
MakePowerOfTwo
(
)
;
template
<
typename
T
>
class
PowerOfTwoMask
{
static_assert
(
!
std
:
:
numeric_limits
<
T
>
:
:
is_signed
"
PowerOfTwoMask
must
use
an
unsigned
type
"
)
;
public
:
explicit
PowerOfTwoMask
(
T
aInput
)
:
mMask
(
RoundUpPow2Mask
(
aInput
)
)
{
}
template
<
typename
U
>
static
constexpr
PowerOfTwoMask
<
U
>
MaskForPowerOfTwo
(
const
PowerOfTwo
<
U
>
&
aP2
)
{
return
PowerOfTwoMask
(
aP2
)
;
}
template
<
typename
U
>
explicit
constexpr
PowerOfTwoMask
(
U
aInput
)
:
mMask
(
RoundUpPow2Mask
(
static_cast
<
T
>
(
aInput
)
)
)
{
static_assert
(
!
std
:
:
numeric_limits
<
T
>
:
:
is_signed
"
PowerOfTwoMask
does
not
accept
signed
types
"
)
;
static_assert
(
sizeof
(
U
)
<
=
sizeof
(
T
)
"
PowerOfTwoMask
does
not
accept
bigger
types
"
)
;
}
constexpr
T
MaskValue
(
)
const
{
return
mMask
;
}
template
<
typename
U
>
friend
U
operator
&
(
U
aNumber
PowerOfTwoMask
aP2M
)
{
return
static_cast
<
U
>
(
aNumber
&
aP2M
.
MaskValue
(
)
)
;
}
template
<
typename
U
>
friend
constexpr
U
operator
&
(
PowerOfTwoMask
aP2M
U
aNumber
)
{
return
static_cast
<
U
>
(
aP2M
.
MaskValue
(
)
&
aNumber
)
;
}
template
<
typename
U
>
friend
constexpr
U
operator
%
(
U
aNumerator
PowerOfTwoMask
aDenominator
)
{
return
aNumerator
&
aDenominator
.
MaskValue
(
)
;
}
constexpr
bool
operator
=
=
(
const
PowerOfTwoMask
&
aRhs
)
const
{
return
mMask
=
=
aRhs
.
mMask
;
}
constexpr
bool
operator
!
=
(
const
PowerOfTwoMask
&
aRhs
)
const
{
return
mMask
!
=
aRhs
.
mMask
;
}
private
:
friend
class
PowerOfTwo
<
T
>
;
template
<
typename
U
U
Mask
>
friend
constexpr
PowerOfTwoMask
<
U
>
MakePowerOfTwoMask
(
)
;
struct
Trusted
{
T
mMask
;
}
;
explicit
constexpr
PowerOfTwoMask
(
const
Trusted
&
aP2
)
:
mMask
(
aP2
.
mMask
)
{
}
T
mMask
=
0
;
}
;
template
<
typename
T
T
Mask
>
constexpr
PowerOfTwoMask
<
T
>
MakePowerOfTwoMask
(
)
{
static_assert
(
Mask
=
=
T
(
-
1
)
|
|
IsPowerOfTwo
(
Mask
+
1
)
"
MakePowerOfTwoMask
<
T
Mask
>
:
Mask
must
be
2
^
N
-
1
"
)
;
using
Trusted
=
typename
PowerOfTwoMask
<
T
>
:
:
Trusted
;
return
PowerOfTwoMask
<
T
>
(
Trusted
{
Mask
}
)
;
}
template
<
typename
T
>
class
PowerOfTwo
{
static_assert
(
!
std
:
:
numeric_limits
<
T
>
:
:
is_signed
"
PowerOfTwo
must
use
an
unsigned
type
"
)
;
public
:
explicit
PowerOfTwo
(
T
aInput
)
:
mValue
(
FriendlyRoundUpPow2
(
aInput
)
)
{
}
template
<
typename
U
>
explicit
PowerOfTwo
(
U
aInput
)
:
mValue
(
FriendlyRoundUpPow2
(
static_cast
<
T
>
(
aInput
)
)
)
{
static_assert
(
!
std
:
:
numeric_limits
<
T
>
:
:
is_signed
"
PowerOfTwo
does
not
accept
signed
types
"
)
;
static_assert
(
sizeof
(
U
)
<
=
sizeof
(
T
)
"
PowerOfTwo
does
not
accept
bigger
types
"
)
;
}
constexpr
T
Value
(
)
const
{
return
mValue
;
}
constexpr
T
MaskValue
(
)
const
{
return
mValue
-
1
;
}
constexpr
PowerOfTwoMask
<
T
>
Mask
(
)
const
{
using
Trusted
=
typename
PowerOfTwoMask
<
T
>
:
:
Trusted
;
return
PowerOfTwoMask
<
T
>
(
Trusted
{
MaskValue
(
)
}
)
;
}
template
<
typename
U
>
friend
constexpr
U
operator
%
(
U
aNumerator
PowerOfTwo
aDenominator
)
{
return
aNumerator
&
aDenominator
.
MaskValue
(
)
;
}
constexpr
bool
operator
=
=
(
const
PowerOfTwo
&
aRhs
)
const
{
return
mValue
=
=
aRhs
.
mValue
;
}
constexpr
bool
operator
!
=
(
const
PowerOfTwo
&
aRhs
)
const
{
return
mValue
!
=
aRhs
.
mValue
;
}
constexpr
bool
operator
<
(
const
PowerOfTwo
&
aRhs
)
const
{
return
mValue
<
aRhs
.
mValue
;
}
constexpr
bool
operator
<
=
(
const
PowerOfTwo
&
aRhs
)
const
{
return
mValue
<
=
aRhs
.
mValue
;
}
constexpr
bool
operator
>
(
const
PowerOfTwo
&
aRhs
)
const
{
return
mValue
>
aRhs
.
mValue
;
}
constexpr
bool
operator
>
=
(
const
PowerOfTwo
&
aRhs
)
const
{
return
mValue
>
=
aRhs
.
mValue
;
}
private
:
template
<
typename
U
U
Value
>
friend
constexpr
PowerOfTwo
<
U
>
MakePowerOfTwo
(
)
;
struct
Trusted
{
T
mValue
;
}
;
explicit
constexpr
PowerOfTwo
(
const
Trusted
&
aP2
)
:
mValue
(
aP2
.
mValue
)
{
}
T
mValue
=
1
;
}
;
template
<
typename
T
T
Value
>
constexpr
PowerOfTwo
<
T
>
MakePowerOfTwo
(
)
{
static_assert
(
IsPowerOfTwo
(
Value
)
"
MakePowerOfTwo
<
T
Value
>
:
Value
must
be
2
^
N
"
)
;
using
Trusted
=
typename
PowerOfTwo
<
T
>
:
:
Trusted
;
return
PowerOfTwo
<
T
>
(
Trusted
{
Value
}
)
;
}
using
PowerOfTwoMask32
=
PowerOfTwoMask
<
uint32_t
>
;
using
PowerOfTwo32
=
PowerOfTwo
<
uint32_t
>
;
using
PowerOfTwoMask64
=
PowerOfTwoMask
<
uint64_t
>
;
using
PowerOfTwo64
=
PowerOfTwo
<
uint64_t
>
;
template
<
uint32_t
Mask
>
constexpr
PowerOfTwoMask32
MakePowerOfTwoMask32
(
)
{
return
MakePowerOfTwoMask
<
uint32_t
Mask
>
(
)
;
}
template
<
uint32_t
Value
>
constexpr
PowerOfTwo32
MakePowerOfTwo32
(
)
{
return
MakePowerOfTwo
<
uint32_t
Value
>
(
)
;
}
template
<
uint64_t
Mask
>
constexpr
PowerOfTwoMask64
MakePowerOfTwoMask64
(
)
{
return
MakePowerOfTwoMask
<
uint64_t
Mask
>
(
)
;
}
template
<
uint64_t
Value
>
constexpr
PowerOfTwo64
MakePowerOfTwo64
(
)
{
return
MakePowerOfTwo
<
uint64_t
Value
>
(
)
;
}
}
#
endif
