#
ifndef
BaseProfilerDetail_h
#
define
BaseProfilerDetail_h
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
PlatformMutex
.
h
"
#
ifdef
DEBUG
#
include
"
BaseProfiler
.
h
"
#
ifdef
MOZ_BASE_PROFILER
#
include
"
mozilla
/
Atomics
.
h
"
#
define
MOZ_BASE_PROFILER_DEBUG
#
endif
#
endif
namespace
mozilla
{
namespace
baseprofiler
{
namespace
detail
{
class
BaseProfilerMutex
:
private
:
:
mozilla
:
:
detail
:
:
MutexImpl
{
public
:
BaseProfilerMutex
(
)
:
:
:
mozilla
:
:
detail
:
:
MutexImpl
(
)
{
}
BaseProfilerMutex
(
const
BaseProfilerMutex
&
)
=
delete
;
BaseProfilerMutex
&
operator
=
(
const
BaseProfilerMutex
&
)
=
delete
;
BaseProfilerMutex
(
BaseProfilerMutex
&
&
)
=
delete
;
BaseProfilerMutex
&
operator
=
(
BaseProfilerMutex
&
&
)
=
delete
;
#
ifdef
MOZ_BASE_PROFILER_DEBUG
~
BaseProfilerMutex
(
)
{
MOZ_ASSERT
(
mOwningThreadId
=
=
0
)
;
}
#
endif
void
Lock
(
)
{
#
ifdef
MOZ_BASE_PROFILER_DEBUG
const
int
tid
=
baseprofiler
:
:
profiler_current_thread_id
(
)
;
MOZ_ASSERT
(
tid
!
=
0
)
;
MOZ_ASSERT
(
mOwningThreadId
!
=
tid
)
;
#
endif
:
:
mozilla
:
:
detail
:
:
MutexImpl
:
:
lock
(
)
;
#
ifdef
MOZ_BASE_PROFILER_DEBUG
MOZ_ASSERT
(
mOwningThreadId
=
=
0
)
;
mOwningThreadId
=
tid
;
#
endif
}
void
Unlock
(
)
{
#
ifdef
MOZ_BASE_PROFILER_DEBUG
MOZ_ASSERT
(
mOwningThreadId
=
=
baseprofiler
:
:
profiler_current_thread_id
(
)
)
;
mOwningThreadId
=
0
;
#
endif
:
:
mozilla
:
:
detail
:
:
MutexImpl
:
:
unlock
(
)
;
}
void
AssertCurrentThreadOwns
(
)
const
{
#
ifdef
MOZ_BASE_PROFILER_DEBUG
MOZ_ASSERT
(
mOwningThreadId
=
=
baseprofiler
:
:
profiler_current_thread_id
(
)
)
;
#
endif
}
#
ifdef
MOZ_BASE_PROFILER_DEBUG
private
:
Atomic
<
int
MemoryOrdering
:
:
SequentiallyConsistent
>
mOwningThreadId
{
0
}
;
#
endif
}
;
class
MOZ_RAII
BaseProfilerAutoLock
{
public
:
explicit
BaseProfilerAutoLock
(
BaseProfilerMutex
&
aMutex
)
:
mMutex
(
aMutex
)
{
mMutex
.
Lock
(
)
;
}
BaseProfilerAutoLock
(
const
BaseProfilerAutoLock
&
)
=
delete
;
BaseProfilerAutoLock
&
operator
=
(
const
BaseProfilerAutoLock
&
)
=
delete
;
BaseProfilerAutoLock
(
BaseProfilerAutoLock
&
&
)
=
delete
;
BaseProfilerAutoLock
&
operator
=
(
BaseProfilerAutoLock
&
&
)
=
delete
;
~
BaseProfilerAutoLock
(
)
{
mMutex
.
Unlock
(
)
;
}
private
:
BaseProfilerMutex
&
mMutex
;
}
;
class
BaseProfilerMaybeMutex
:
private
:
:
mozilla
:
:
detail
:
:
MutexImpl
{
public
:
explicit
BaseProfilerMaybeMutex
(
bool
aActivate
)
{
if
(
aActivate
)
{
mMaybeMutex
.
emplace
(
)
;
}
}
BaseProfilerMaybeMutex
(
const
BaseProfilerMaybeMutex
&
)
=
delete
;
BaseProfilerMaybeMutex
&
operator
=
(
const
BaseProfilerMaybeMutex
&
)
=
delete
;
BaseProfilerMaybeMutex
(
BaseProfilerMaybeMutex
&
&
)
=
delete
;
BaseProfilerMaybeMutex
&
operator
=
(
BaseProfilerMaybeMutex
&
&
)
=
delete
;
~
BaseProfilerMaybeMutex
(
)
=
default
;
bool
IsActivated
(
)
const
{
return
mMaybeMutex
.
isSome
(
)
;
}
void
Lock
(
)
{
if
(
IsActivated
(
)
)
{
mMaybeMutex
-
>
Lock
(
)
;
}
}
void
Unlock
(
)
{
if
(
IsActivated
(
)
)
{
mMaybeMutex
-
>
Unlock
(
)
;
}
}
void
AssertCurrentThreadOwns
(
)
const
{
#
ifdef
MOZ_BASE_PROFILER_DEBUG
if
(
IsActivated
(
)
)
{
mMaybeMutex
-
>
AssertCurrentThreadOwns
(
)
;
}
#
endif
}
private
:
Maybe
<
BaseProfilerMutex
>
mMaybeMutex
;
}
;
class
MOZ_RAII
BaseProfilerMaybeAutoLock
{
public
:
explicit
BaseProfilerMaybeAutoLock
(
BaseProfilerMaybeMutex
&
aMaybeMutex
)
:
mMaybeMutex
(
aMaybeMutex
)
{
mMaybeMutex
.
Lock
(
)
;
}
BaseProfilerMaybeAutoLock
(
const
BaseProfilerMaybeAutoLock
&
)
=
delete
;
BaseProfilerMaybeAutoLock
&
operator
=
(
const
BaseProfilerMaybeAutoLock
&
)
=
delete
;
BaseProfilerMaybeAutoLock
(
BaseProfilerMaybeAutoLock
&
&
)
=
delete
;
BaseProfilerMaybeAutoLock
&
operator
=
(
BaseProfilerMaybeAutoLock
&
&
)
=
delete
;
~
BaseProfilerMaybeAutoLock
(
)
{
mMaybeMutex
.
Unlock
(
)
;
}
private
:
BaseProfilerMaybeMutex
&
mMaybeMutex
;
}
;
}
}
}
#
endif
