#
ifndef
BaseProfilerDetail_h
#
define
BaseProfilerDetail_h
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
PlatformMutex
.
h
"
#
include
"
mozilla
/
PlatformRWLock
.
h
"
#
include
"
mozilla
/
BaseProfilerUtils
.
h
"
namespace
mozilla
{
namespace
baseprofiler
{
namespace
detail
{
class
MOZ_CAPABILITY
BaseProfilerMutex
:
private
:
:
mozilla
:
:
detail
:
:
MutexImpl
{
public
:
BaseProfilerMutex
(
)
:
:
:
mozilla
:
:
detail
:
:
MutexImpl
(
)
{
}
explicit
BaseProfilerMutex
(
const
char
*
aName
)
:
:
:
mozilla
:
:
detail
:
:
MutexImpl
(
)
mName
(
aName
)
{
}
BaseProfilerMutex
(
const
BaseProfilerMutex
&
)
=
delete
;
BaseProfilerMutex
&
operator
=
(
const
BaseProfilerMutex
&
)
=
delete
;
BaseProfilerMutex
(
BaseProfilerMutex
&
&
)
=
delete
;
BaseProfilerMutex
&
operator
=
(
BaseProfilerMutex
&
&
)
=
delete
;
#
ifdef
DEBUG
~
BaseProfilerMutex
(
)
{
MOZ_ASSERT
(
!
BaseProfilerThreadId
:
:
FromNumber
(
mOwningThreadId
)
.
IsSpecified
(
)
"
BaseProfilerMutex
should
have
been
unlocked
when
destroyed
"
)
;
}
#
endif
[
[
nodiscard
]
]
bool
IsLockedOnCurrentThread
(
)
const
{
return
BaseProfilerThreadId
:
:
FromNumber
(
mOwningThreadId
)
=
=
baseprofiler
:
:
profiler_current_thread_id
(
)
;
}
void
AssertCurrentThreadOwns
(
)
const
MOZ_ASSERT_CAPABILITY
(
this
)
{
MOZ_ASSERT
(
IsLockedOnCurrentThread
(
)
)
;
}
void
Lock
(
)
MOZ_CAPABILITY_ACQUIRE
(
)
{
const
BaseProfilerThreadId
tid
=
baseprofiler
:
:
profiler_current_thread_id
(
)
;
MOZ_ASSERT
(
tid
.
IsSpecified
(
)
)
;
MOZ_ASSERT
(
!
IsLockedOnCurrentThread
(
)
"
Recursive
locking
"
)
;
:
:
mozilla
:
:
detail
:
:
MutexImpl
:
:
lock
(
)
;
MOZ_ASSERT
(
!
BaseProfilerThreadId
:
:
FromNumber
(
mOwningThreadId
)
.
IsSpecified
(
)
"
Not
unlocked
properly
"
)
;
mOwningThreadId
=
tid
.
ToNumber
(
)
;
}
[
[
nodiscard
]
]
bool
TryLock
(
)
MOZ_TRY_ACQUIRE
(
true
)
{
const
BaseProfilerThreadId
tid
=
baseprofiler
:
:
profiler_current_thread_id
(
)
;
MOZ_ASSERT
(
tid
.
IsSpecified
(
)
)
;
MOZ_ASSERT
(
!
IsLockedOnCurrentThread
(
)
"
Recursive
locking
"
)
;
if
(
!
:
:
mozilla
:
:
detail
:
:
MutexImpl
:
:
tryLock
(
)
)
{
return
false
;
}
MOZ_ASSERT
(
!
BaseProfilerThreadId
:
:
FromNumber
(
mOwningThreadId
)
.
IsSpecified
(
)
"
Not
unlocked
properly
"
)
;
mOwningThreadId
=
tid
.
ToNumber
(
)
;
return
true
;
}
void
Unlock
(
)
MOZ_CAPABILITY_RELEASE
(
)
{
MOZ_ASSERT
(
IsLockedOnCurrentThread
(
)
"
Unlocking
when
not
locked
here
"
)
;
mOwningThreadId
=
BaseProfilerThreadId
{
}
.
ToNumber
(
)
;
:
:
mozilla
:
:
detail
:
:
MutexImpl
:
:
unlock
(
)
;
}
const
char
*
GetName
(
)
const
{
return
mName
;
}
private
:
Atomic
<
typename
BaseProfilerThreadId
:
:
NumberType
MemoryOrdering
:
:
Relaxed
>
mOwningThreadId
;
const
char
*
mName
=
nullptr
;
}
;
class
MOZ_RAII
BaseProfilerAutoLock
{
public
:
explicit
BaseProfilerAutoLock
(
BaseProfilerMutex
&
aMutex
)
:
mMutex
(
aMutex
)
{
mMutex
.
Lock
(
)
;
}
BaseProfilerAutoLock
(
const
BaseProfilerAutoLock
&
)
=
delete
;
BaseProfilerAutoLock
&
operator
=
(
const
BaseProfilerAutoLock
&
)
=
delete
;
BaseProfilerAutoLock
(
BaseProfilerAutoLock
&
&
)
=
delete
;
BaseProfilerAutoLock
&
operator
=
(
BaseProfilerAutoLock
&
&
)
=
delete
;
~
BaseProfilerAutoLock
(
)
{
mMutex
.
Unlock
(
)
;
}
private
:
BaseProfilerMutex
&
mMutex
;
}
;
class
BaseProfilerMaybeMutex
:
private
:
:
mozilla
:
:
detail
:
:
MutexImpl
{
public
:
explicit
BaseProfilerMaybeMutex
(
bool
aActivate
)
{
if
(
aActivate
)
{
mMaybeMutex
.
emplace
(
)
;
}
}
BaseProfilerMaybeMutex
(
const
BaseProfilerMaybeMutex
&
)
=
delete
;
BaseProfilerMaybeMutex
&
operator
=
(
const
BaseProfilerMaybeMutex
&
)
=
delete
;
BaseProfilerMaybeMutex
(
BaseProfilerMaybeMutex
&
&
)
=
delete
;
BaseProfilerMaybeMutex
&
operator
=
(
BaseProfilerMaybeMutex
&
&
)
=
delete
;
~
BaseProfilerMaybeMutex
(
)
=
default
;
bool
IsActivated
(
)
const
{
return
mMaybeMutex
.
isSome
(
)
;
}
[
[
nodiscard
]
]
bool
IsActivatedAndLockedOnCurrentThread
(
)
const
{
if
(
!
IsActivated
(
)
)
{
return
false
;
}
return
mMaybeMutex
-
>
IsLockedOnCurrentThread
(
)
;
}
void
AssertCurrentThreadOwns
(
)
const
{
#
ifdef
DEBUG
if
(
IsActivated
(
)
)
{
mMaybeMutex
-
>
AssertCurrentThreadOwns
(
)
;
}
#
endif
}
MOZ_PUSH_IGNORE_THREAD_SAFETY
void
Lock
(
)
{
if
(
IsActivated
(
)
)
{
mMaybeMutex
-
>
Lock
(
)
;
}
}
void
Unlock
(
)
{
if
(
IsActivated
(
)
)
{
mMaybeMutex
-
>
Unlock
(
)
;
}
}
MOZ_POP_THREAD_SAFETY
private
:
Maybe
<
BaseProfilerMutex
>
mMaybeMutex
;
}
;
class
MOZ_RAII
BaseProfilerMaybeAutoLock
{
public
:
explicit
BaseProfilerMaybeAutoLock
(
BaseProfilerMaybeMutex
&
aMaybeMutex
)
:
mMaybeMutex
(
aMaybeMutex
)
{
mMaybeMutex
.
Lock
(
)
;
}
BaseProfilerMaybeAutoLock
(
const
BaseProfilerMaybeAutoLock
&
)
=
delete
;
BaseProfilerMaybeAutoLock
&
operator
=
(
const
BaseProfilerMaybeAutoLock
&
)
=
delete
;
BaseProfilerMaybeAutoLock
(
BaseProfilerMaybeAutoLock
&
&
)
=
delete
;
BaseProfilerMaybeAutoLock
&
operator
=
(
BaseProfilerMaybeAutoLock
&
&
)
=
delete
;
~
BaseProfilerMaybeAutoLock
(
)
{
mMaybeMutex
.
Unlock
(
)
;
}
private
:
BaseProfilerMaybeMutex
&
mMaybeMutex
;
}
;
class
BaseProfilerSharedMutex
:
public
:
:
mozilla
:
:
detail
:
:
RWLockImpl
{
public
:
#
ifdef
DEBUG
~
BaseProfilerSharedMutex
(
)
{
MOZ_ASSERT
(
!
BaseProfilerThreadId
:
:
FromNumber
(
mOwningThreadId
)
.
IsSpecified
(
)
"
BaseProfilerMutex
should
have
been
unlocked
when
destroyed
"
)
;
}
#
endif
[
[
nodiscard
]
]
bool
IsLockedExclusiveOnCurrentThread
(
)
const
{
return
BaseProfilerThreadId
:
:
FromNumber
(
mOwningThreadId
)
=
=
baseprofiler
:
:
profiler_current_thread_id
(
)
;
}
void
LockExclusive
(
)
{
const
BaseProfilerThreadId
tid
=
baseprofiler
:
:
profiler_current_thread_id
(
)
;
MOZ_ASSERT
(
tid
.
IsSpecified
(
)
)
;
MOZ_ASSERT
(
!
IsLockedExclusiveOnCurrentThread
(
)
"
Recursive
locking
"
)
;
:
:
mozilla
:
:
detail
:
:
RWLockImpl
:
:
writeLock
(
)
;
MOZ_ASSERT
(
!
BaseProfilerThreadId
:
:
FromNumber
(
mOwningThreadId
)
.
IsSpecified
(
)
"
Not
unlocked
properly
"
)
;
mOwningThreadId
=
tid
.
ToNumber
(
)
;
}
void
UnlockExclusive
(
)
{
MOZ_ASSERT
(
IsLockedExclusiveOnCurrentThread
(
)
"
Unlocking
when
not
locked
here
"
)
;
mOwningThreadId
=
BaseProfilerThreadId
{
}
.
ToNumber
(
)
;
writeUnlock
(
)
;
}
void
LockShared
(
)
{
readLock
(
)
;
}
void
UnlockShared
(
)
{
readUnlock
(
)
;
}
private
:
Atomic
<
typename
BaseProfilerThreadId
:
:
NumberType
MemoryOrdering
:
:
Relaxed
>
mOwningThreadId
;
}
;
class
MOZ_RAII
BaseProfilerAutoLockExclusive
{
public
:
explicit
BaseProfilerAutoLockExclusive
(
BaseProfilerSharedMutex
&
aSharedMutex
)
:
mSharedMutex
(
aSharedMutex
)
{
mSharedMutex
.
LockExclusive
(
)
;
}
BaseProfilerAutoLockExclusive
(
const
BaseProfilerAutoLockExclusive
&
)
=
delete
;
BaseProfilerAutoLockExclusive
&
operator
=
(
const
BaseProfilerAutoLockExclusive
&
)
=
delete
;
BaseProfilerAutoLockExclusive
(
BaseProfilerAutoLockExclusive
&
&
)
=
delete
;
BaseProfilerAutoLockExclusive
&
operator
=
(
BaseProfilerAutoLockExclusive
&
&
)
=
delete
;
~
BaseProfilerAutoLockExclusive
(
)
{
mSharedMutex
.
UnlockExclusive
(
)
;
}
private
:
BaseProfilerSharedMutex
&
mSharedMutex
;
}
;
class
MOZ_RAII
BaseProfilerAutoLockShared
{
public
:
explicit
BaseProfilerAutoLockShared
(
BaseProfilerSharedMutex
&
aSharedMutex
)
:
mSharedMutex
(
aSharedMutex
)
{
mSharedMutex
.
LockShared
(
)
;
}
BaseProfilerAutoLockShared
(
const
BaseProfilerAutoLockShared
&
)
=
delete
;
BaseProfilerAutoLockShared
&
operator
=
(
const
BaseProfilerAutoLockShared
&
)
=
delete
;
BaseProfilerAutoLockShared
(
BaseProfilerAutoLockShared
&
&
)
=
delete
;
BaseProfilerAutoLockShared
&
operator
=
(
BaseProfilerAutoLockShared
&
&
)
=
delete
;
~
BaseProfilerAutoLockShared
(
)
{
mSharedMutex
.
UnlockShared
(
)
;
}
private
:
BaseProfilerSharedMutex
&
mSharedMutex
;
}
;
}
}
}
#
endif
