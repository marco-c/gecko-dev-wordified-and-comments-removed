#
ifndef
BaseProfilerDetail_h
#
define
BaseProfilerDetail_h
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
PlatformMutex
.
h
"
#
ifndef
MOZ_GECKO_PROFILER
#
error
Do
not
#
include
this
header
when
MOZ_GECKO_PROFILER
is
not
#
defined
.
#
endif
namespace
mozilla
{
namespace
baseprofiler
{
MFBT_API
int
profiler_current_thread_id
(
)
;
namespace
detail
{
class
BaseProfilerMutex
:
private
:
:
mozilla
:
:
detail
:
:
MutexImpl
{
public
:
BaseProfilerMutex
(
)
:
:
:
mozilla
:
:
detail
:
:
MutexImpl
(
)
{
}
BaseProfilerMutex
(
const
BaseProfilerMutex
&
)
=
delete
;
BaseProfilerMutex
&
operator
=
(
const
BaseProfilerMutex
&
)
=
delete
;
BaseProfilerMutex
(
BaseProfilerMutex
&
&
)
=
delete
;
BaseProfilerMutex
&
operator
=
(
BaseProfilerMutex
&
&
)
=
delete
;
#
ifdef
DEBUG
~
BaseProfilerMutex
(
)
{
MOZ_ASSERT
(
mOwningThreadId
=
=
0
)
;
}
#
endif
[
[
nodiscard
]
]
bool
IsLockedOnCurrentThread
(
)
const
{
return
mOwningThreadId
=
=
baseprofiler
:
:
profiler_current_thread_id
(
)
;
}
void
AssertCurrentThreadOwns
(
)
const
{
MOZ_ASSERT
(
IsLockedOnCurrentThread
(
)
)
;
}
void
Lock
(
)
{
const
int
tid
=
baseprofiler
:
:
profiler_current_thread_id
(
)
;
MOZ_ASSERT
(
tid
!
=
0
)
;
MOZ_ASSERT
(
!
IsLockedOnCurrentThread
(
)
"
Recursive
locking
"
)
;
:
:
mozilla
:
:
detail
:
:
MutexImpl
:
:
lock
(
)
;
MOZ_ASSERT
(
mOwningThreadId
=
=
0
"
Not
unlocked
properly
"
)
;
mOwningThreadId
=
tid
;
}
[
[
nodiscard
]
]
bool
TryLock
(
)
{
const
int
tid
=
baseprofiler
:
:
profiler_current_thread_id
(
)
;
MOZ_ASSERT
(
tid
!
=
0
)
;
MOZ_ASSERT
(
!
IsLockedOnCurrentThread
(
)
"
Recursive
locking
"
)
;
if
(
!
:
:
mozilla
:
:
detail
:
:
MutexImpl
:
:
tryLock
(
)
)
{
return
false
;
}
MOZ_ASSERT
(
mOwningThreadId
=
=
0
"
Not
unlocked
properly
"
)
;
mOwningThreadId
=
tid
;
return
true
;
}
void
Unlock
(
)
{
MOZ_ASSERT
(
IsLockedOnCurrentThread
(
)
"
Unlocking
when
not
locked
here
"
)
;
mOwningThreadId
=
0
;
:
:
mozilla
:
:
detail
:
:
MutexImpl
:
:
unlock
(
)
;
}
private
:
Atomic
<
int
MemoryOrdering
:
:
Relaxed
>
mOwningThreadId
{
0
}
;
}
;
class
MOZ_RAII
BaseProfilerAutoLock
{
public
:
explicit
BaseProfilerAutoLock
(
BaseProfilerMutex
&
aMutex
)
:
mMutex
(
aMutex
)
{
mMutex
.
Lock
(
)
;
}
BaseProfilerAutoLock
(
const
BaseProfilerAutoLock
&
)
=
delete
;
BaseProfilerAutoLock
&
operator
=
(
const
BaseProfilerAutoLock
&
)
=
delete
;
BaseProfilerAutoLock
(
BaseProfilerAutoLock
&
&
)
=
delete
;
BaseProfilerAutoLock
&
operator
=
(
BaseProfilerAutoLock
&
&
)
=
delete
;
~
BaseProfilerAutoLock
(
)
{
mMutex
.
Unlock
(
)
;
}
private
:
BaseProfilerMutex
&
mMutex
;
}
;
class
BaseProfilerMaybeMutex
:
private
:
:
mozilla
:
:
detail
:
:
MutexImpl
{
public
:
explicit
BaseProfilerMaybeMutex
(
bool
aActivate
)
{
if
(
aActivate
)
{
mMaybeMutex
.
emplace
(
)
;
}
}
BaseProfilerMaybeMutex
(
const
BaseProfilerMaybeMutex
&
)
=
delete
;
BaseProfilerMaybeMutex
&
operator
=
(
const
BaseProfilerMaybeMutex
&
)
=
delete
;
BaseProfilerMaybeMutex
(
BaseProfilerMaybeMutex
&
&
)
=
delete
;
BaseProfilerMaybeMutex
&
operator
=
(
BaseProfilerMaybeMutex
&
&
)
=
delete
;
~
BaseProfilerMaybeMutex
(
)
=
default
;
bool
IsActivated
(
)
const
{
return
mMaybeMutex
.
isSome
(
)
;
}
[
[
nodiscard
]
]
bool
IsActivatedAndLockedOnCurrentThread
(
)
const
{
if
(
!
IsActivated
(
)
)
{
return
false
;
}
return
mMaybeMutex
-
>
IsLockedOnCurrentThread
(
)
;
}
void
AssertCurrentThreadOwns
(
)
const
{
#
ifdef
DEBUG
if
(
IsActivated
(
)
)
{
mMaybeMutex
-
>
AssertCurrentThreadOwns
(
)
;
}
#
endif
}
void
Lock
(
)
{
if
(
IsActivated
(
)
)
{
mMaybeMutex
-
>
Lock
(
)
;
}
}
void
Unlock
(
)
{
if
(
IsActivated
(
)
)
{
mMaybeMutex
-
>
Unlock
(
)
;
}
}
private
:
Maybe
<
BaseProfilerMutex
>
mMaybeMutex
;
}
;
class
MOZ_RAII
BaseProfilerMaybeAutoLock
{
public
:
explicit
BaseProfilerMaybeAutoLock
(
BaseProfilerMaybeMutex
&
aMaybeMutex
)
:
mMaybeMutex
(
aMaybeMutex
)
{
mMaybeMutex
.
Lock
(
)
;
}
BaseProfilerMaybeAutoLock
(
const
BaseProfilerMaybeAutoLock
&
)
=
delete
;
BaseProfilerMaybeAutoLock
&
operator
=
(
const
BaseProfilerMaybeAutoLock
&
)
=
delete
;
BaseProfilerMaybeAutoLock
(
BaseProfilerMaybeAutoLock
&
&
)
=
delete
;
BaseProfilerMaybeAutoLock
&
operator
=
(
BaseProfilerMaybeAutoLock
&
&
)
=
delete
;
~
BaseProfilerMaybeAutoLock
(
)
{
mMaybeMutex
.
Unlock
(
)
;
}
private
:
BaseProfilerMaybeMutex
&
mMaybeMutex
;
}
;
}
}
}
#
endif
