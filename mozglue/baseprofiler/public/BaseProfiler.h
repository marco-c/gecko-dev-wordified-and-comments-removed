#
ifndef
BaseProfiler_h
#
define
BaseProfiler_h
#
include
"
mozilla
/
BaseProfilerCounts
.
h
"
#
ifndef
MOZ_GECKO_PROFILER
#
define
AUTO_BASE_PROFILER_INIT
#
define
BASE_PROFILER_REGISTER_THREAD
(
name
)
#
define
BASE_PROFILER_UNREGISTER_THREAD
(
)
#
define
AUTO_BASE_PROFILER_REGISTER_THREAD
(
name
)
#
define
AUTO_BASE_PROFILER_THREAD_SLEEP
#
define
AUTO_BASE_PROFILER_THREAD_WAKE
#
define
AUTO_BASE_PROFILER_LABEL
(
label
categoryPair
)
#
define
AUTO_BASE_PROFILER_LABEL_CATEGORY_PAIR
(
categoryPair
)
#
define
AUTO_BASE_PROFILER_LABEL_DYNAMIC_CSTR
(
label
categoryPair
cStr
)
#
define
AUTO_BASE_PROFILER_LABEL_DYNAMIC_STRING
(
label
categoryPair
str
)
#
define
AUTO_BASE_PROFILER_LABEL_FAST
(
label
categoryPair
ctx
)
#
define
AUTO_BASE_PROFILER_LABEL_DYNAMIC_FAST
(
label
dynamicString
\
categoryPair
ctx
flags
)
#
define
BASE_PROFILER_ADD_MARKER
(
markerName
categoryPair
)
#
define
BASE_PROFILER_ADD_MARKER_WITH_PAYLOAD
(
\
markerName
categoryPair
PayloadType
parenthesizedPayloadArgs
)
#
define
BASE_PROFILER_TRACING_MARKER
(
categoryString
markerName
\
categoryPair
kind
)
#
define
AUTO_BASE_PROFILER_TRACING_MARKER
(
categoryString
markerName
\
categoryPair
)
#
define
AUTO_BASE_PROFILER_TEXT_MARKER_CAUSE
(
markerName
text
categoryPair
\
cause
)
#
define
AUTO_PROFILER_STATS
(
name
)
#
else
#
include
"
BaseProfilingStack
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
GuardObjects
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
PowerOfTwo
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
mozilla
/
ThreadLocal
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
<
functional
>
#
include
<
stdint
.
h
>
#
include
<
string
>
namespace
mozilla
{
class
MallocAllocPolicy
;
template
<
class
T
size_t
MinInlineCapacity
class
AllocPolicy
>
class
Vector
;
namespace
baseprofiler
{
class
ProfilerBacktrace
;
class
ProfilerMarkerPayload
;
class
SpliceableJSONWriter
;
#
define
BASE_PROFILER_RAII_PASTE
(
id
line
)
id
#
#
line
#
define
BASE_PROFILER_RAII_EXPAND
(
id
line
)
BASE_PROFILER_RAII_PASTE
(
id
line
)
#
define
BASE_PROFILER_RAII
BASE_PROFILER_RAII_EXPAND
(
raiiObject
__LINE__
)
#
define
BASE_PROFILER_FOR_EACH_FEATURE
(
MACRO
)
\
MACRO
(
0
"
java
"
Java
"
Profile
Java
code
Android
only
"
)
\
\
MACRO
(
1
"
js
"
JS
\
"
Get
the
JS
engine
to
expose
the
JS
stack
to
the
profiler
"
)
\
\
/
*
The
DevTools
profiler
doesn
'
t
want
the
native
addresses
.
*
/
\
MACRO
(
2
"
leaf
"
Leaf
"
Include
the
C
+
+
leaf
node
if
not
stackwalking
"
)
\
\
MACRO
(
3
"
mainthreadio
"
MainThreadIO
"
Add
main
thread
file
I
/
O
"
)
\
\
MACRO
(
4
"
fileio
"
FileIO
\
"
Add
file
I
/
O
from
all
profiled
threads
implies
mainthreadio
"
)
\
\
MACRO
(
5
"
fileioall
"
FileIOAll
\
"
Add
file
I
/
O
from
all
threads
implies
fileio
"
)
\
\
MACRO
(
6
"
noiostacks
"
NoIOStacks
\
"
File
I
/
O
markers
do
not
capture
stacks
to
reduce
overhead
"
)
\
\
MACRO
(
7
"
privacy
"
Privacy
\
"
Do
not
include
user
-
identifiable
information
"
)
\
\
MACRO
(
8
"
screenshots
"
Screenshots
\
"
Take
a
snapshot
of
the
window
on
every
composition
"
)
\
\
MACRO
(
9
"
seqstyle
"
SequentialStyle
\
"
Disable
parallel
traversal
in
styling
"
)
\
\
MACRO
(
10
"
stackwalk
"
StackWalk
\
"
Walk
the
C
+
+
stack
not
available
on
all
platforms
"
)
\
\
MACRO
(
11
"
tasktracer
"
TaskTracer
\
"
Start
profiling
with
feature
TaskTracer
"
)
\
\
MACRO
(
12
"
threads
"
Threads
"
Profile
the
registered
secondary
threads
"
)
\
\
MACRO
(
13
"
trackopts
"
TrackOptimizations
\
"
Have
the
JavaScript
engine
track
JIT
optimizations
"
)
\
\
MACRO
(
14
"
jstracer
"
JSTracer
"
Enable
tracing
of
the
JavaScript
engine
"
)
\
\
MACRO
(
15
"
jsallocations
"
JSAllocations
\
"
Have
the
JavaScript
engine
track
allocations
"
)
\
\
MACRO
(
16
"
nostacksampling
"
NoStackSampling
\
"
Disable
all
stack
sampling
:
Cancels
\
"
js
\
"
\
"
leaf
\
"
"
\
"
\
"
stackwalk
\
"
and
labels
"
)
\
\
MACRO
(
17
"
preferencereads
"
PreferenceReads
\
"
Track
when
preferences
are
read
"
)
\
\
MACRO
(
18
"
nativeallocations
"
NativeAllocations
\
"
Collect
the
stacks
from
a
smaller
subset
of
all
native
"
\
"
allocations
biasing
towards
collecting
larger
allocations
"
)
\
\
MACRO
(
19
"
ipcmessages
"
IPCMessages
\
"
Have
the
IPC
layer
track
cross
-
process
messages
"
)
struct
ProfilerFeature
{
#
define
DECLARE
(
n_
str_
Name_
desc_
)
\
static
constexpr
uint32_t
Name_
=
(
1u
<
<
n_
)
;
\
static
constexpr
bool
Has
#
#
Name_
(
uint32_t
aFeatures
)
{
\
return
aFeatures
&
Name_
;
\
}
\
static
constexpr
void
Set
#
#
Name_
(
uint32_t
&
aFeatures
)
{
\
aFeatures
|
=
Name_
;
\
}
\
static
constexpr
void
Clear
#
#
Name_
(
uint32_t
&
aFeatures
)
{
\
aFeatures
&
=
~
Name_
;
\
}
BASE_PROFILER_FOR_EACH_FEATURE
(
DECLARE
)
#
undef
DECLARE
}
;
namespace
detail
{
class
RacyFeatures
{
public
:
MFBT_API
static
void
SetActive
(
uint32_t
aFeatures
)
;
MFBT_API
static
void
SetInactive
(
)
;
MFBT_API
static
void
SetPaused
(
)
;
MFBT_API
static
void
SetUnpaused
(
)
;
MFBT_API
static
bool
IsActive
(
)
;
MFBT_API
static
bool
IsActiveWithFeature
(
uint32_t
aFeature
)
;
MFBT_API
static
bool
IsActiveWithoutPrivacy
(
)
;
MFBT_API
static
bool
IsActiveAndUnpausedWithoutPrivacy
(
)
;
private
:
static
constexpr
uint32_t
Active
=
1u
<
<
31
;
static
constexpr
uint32_t
Paused
=
1u
<
<
30
;
#
define
NO_OVERLAP
(
n_
str_
Name_
desc_
)
\
static_assert
(
ProfilerFeature
:
:
Name_
!
=
Paused
"
bad
feature
value
"
)
;
BASE_PROFILER_FOR_EACH_FEATURE
(
NO_OVERLAP
)
;
#
undef
NO_OVERLAP
static
Atomic
<
uint32_t
MemoryOrdering
:
:
Relaxed
>
sActiveAndFeatures
;
}
;
MFBT_API
bool
IsThreadBeingProfiled
(
)
;
}
static
constexpr
PowerOfTwo32
BASE_PROFILER_DEFAULT_ENTRIES
=
#
if
!
defined
(
GP_PLAT_arm_android
)
MakePowerOfTwo32
<
1024
*
1024
>
(
)
;
#
else
MakePowerOfTwo32
<
128
*
1024
>
(
)
;
/
/
128k
entries
=
1MB
#
endif
static
constexpr
PowerOfTwo32
BASE_PROFILER_DEFAULT_STARTUP_ENTRIES
=
#
if
!
defined
(
GP_PLAT_arm_android
)
MakePowerOfTwo32
<
4
*
1024
*
1024
>
(
)
;
#
else
MakePowerOfTwo32
<
256
*
1024
>
(
)
;
/
/
256k
entries
=
2MB
#
endif
#
define
BASE_PROFILER_DEFAULT_DURATION
20
#
define
BASE_PROFILER_DEFAULT_INTERVAL
1
MFBT_API
void
profiler_init
(
void
*
stackTop
)
;
#
define
AUTO_BASE_PROFILER_INIT
\
:
:
mozilla
:
:
baseprofiler
:
:
AutoProfilerInit
BASE_PROFILER_RAII
MFBT_API
void
profiler_shutdown
(
)
;
MFBT_API
void
profiler_start
(
PowerOfTwo32
aCapacity
double
aInterval
uint32_t
aFeatures
const
char
*
*
aFilters
uint32_t
aFilterCount
const
Maybe
<
double
>
&
aDuration
=
Nothing
(
)
)
;
MFBT_API
void
profiler_stop
(
)
;
MFBT_API
void
profiler_ensure_started
(
PowerOfTwo32
aCapacity
double
aInterval
uint32_t
aFeatures
const
char
*
*
aFilters
uint32_t
aFilterCount
const
Maybe
<
double
>
&
aDuration
=
Nothing
(
)
)
;
#
define
BASE_PROFILER_REGISTER_THREAD
(
name
)
\
do
{
\
char
stackTop
;
\
:
:
mozilla
:
:
baseprofiler
:
:
profiler_register_thread
(
name
&
stackTop
)
;
\
}
while
(
0
)
#
define
BASE_PROFILER_UNREGISTER_THREAD
(
)
\
:
:
mozilla
:
:
baseprofiler
:
:
profiler_unregister_thread
(
)
MFBT_API
ProfilingStack
*
profiler_register_thread
(
const
char
*
name
void
*
guessStackTop
)
;
MFBT_API
void
profiler_unregister_thread
(
)
;
MFBT_API
void
profiler_register_page
(
uint64_t
aBrowsingContextID
uint64_t
aInnerWindowID
const
std
:
:
string
&
aUrl
uint64_t
aEmbedderInnerWindowID
)
;
MFBT_API
void
profiler_unregister_page
(
uint64_t
aRegisteredInnerWindowID
)
;
void
profiler_clear_all_pages
(
)
;
class
BaseProfilerCount
;
MFBT_API
void
profiler_add_sampled_counter
(
BaseProfilerCount
*
aCounter
)
;
MFBT_API
void
profiler_remove_sampled_counter
(
BaseProfilerCount
*
aCounter
)
;
#
define
AUTO_BASE_PROFILER_REGISTER_THREAD
(
name
)
\
:
:
mozilla
:
:
baseprofiler
:
:
AutoProfilerRegisterThread
BASE_PROFILER_RAII
(
name
)
MFBT_API
void
profiler_pause
(
)
;
MFBT_API
void
profiler_resume
(
)
;
MFBT_API
void
profiler_thread_sleep
(
)
;
MFBT_API
void
profiler_thread_wake
(
)
;
#
define
AUTO_BASE_PROFILER_THREAD_SLEEP
\
:
:
mozilla
:
:
baseprofiler
:
:
AutoProfilerThreadSleep
BASE_PROFILER_RAII
#
define
AUTO_BASE_PROFILER_THREAD_WAKE
\
:
:
mozilla
:
:
baseprofiler
:
:
AutoProfilerThreadWake
BASE_PROFILER_RAII
inline
bool
profiler_is_active
(
)
{
return
baseprofiler
:
:
detail
:
:
RacyFeatures
:
:
IsActive
(
)
;
}
inline
bool
profiler_can_accept_markers
(
)
{
return
baseprofiler
:
:
detail
:
:
RacyFeatures
:
:
IsActiveAndUnpausedWithoutPrivacy
(
)
;
}
inline
bool
profiler_thread_is_being_profiled
(
)
{
return
profiler_is_active
(
)
&
&
baseprofiler
:
:
detail
:
:
IsThreadBeingProfiled
(
)
;
}
MFBT_API
bool
profiler_is_paused
(
)
;
MFBT_API
bool
profiler_thread_is_sleeping
(
)
;
MFBT_API
uint32_t
profiler_get_available_features
(
)
;
MFBT_API
bool
profiler_feature_active
(
uint32_t
aFeature
)
;
MFBT_API
void
profiler_get_start_params
(
int
*
aEntrySize
Maybe
<
double
>
*
aDuration
double
*
aInterval
uint32_t
*
aFeatures
Vector
<
const
char
*
0
MallocAllocPolicy
>
*
aFilters
)
;
MFBT_API
double
profiler_time
(
)
;
MFBT_API
int
profiler_current_process_id
(
)
;
MFBT_API
int
profiler_current_thread_id
(
)
;
class
ProfilerStackCollector
{
public
:
virtual
Maybe
<
uint64_t
>
SamplePositionInBuffer
(
)
{
return
Nothing
(
)
;
}
virtual
Maybe
<
uint64_t
>
BufferRangeStart
(
)
{
return
Nothing
(
)
;
}
virtual
void
SetIsMainThread
(
)
{
}
virtual
void
CollectNativeLeafAddr
(
void
*
aAddr
)
=
0
;
virtual
void
CollectProfilingStackFrame
(
const
ProfilingStackFrame
&
aFrame
)
=
0
;
}
;
MFBT_API
void
profiler_suspend_and_sample_thread
(
int
aThreadId
uint32_t
aFeatures
ProfilerStackCollector
&
aCollector
bool
aSampleNative
=
true
)
;
struct
ProfilerBacktraceDestructor
{
MFBT_API
void
operator
(
)
(
ProfilerBacktrace
*
)
;
}
;
using
UniqueProfilerBacktrace
=
UniquePtr
<
ProfilerBacktrace
ProfilerBacktraceDestructor
>
;
MFBT_API
UniqueProfilerBacktrace
profiler_get_backtrace
(
)
;
struct
ProfilerStats
{
unsigned
n
=
0
;
double
sum
=
0
;
double
min
=
std
:
:
numeric_limits
<
double
>
:
:
max
(
)
;
double
max
=
0
;
void
Count
(
double
v
)
{
+
+
n
;
sum
+
=
v
;
if
(
v
<
min
)
{
min
=
v
;
}
if
(
v
>
max
)
{
max
=
v
;
}
}
}
;
struct
ProfilerBufferInfo
{
uint64_t
mRangeStart
;
uint64_t
mRangeEnd
;
uint32_t
mEntryCount
;
ProfilerStats
mIntervalsNs
;
ProfilerStats
mOverheadsNs
;
ProfilerStats
mLockingsNs
;
ProfilerStats
mCleaningsNs
;
ProfilerStats
mCountersNs
;
ProfilerStats
mThreadsNs
;
}
;
MFBT_API
Maybe
<
ProfilerBufferInfo
>
profiler_get_buffer_info
(
)
;
#
ifdef
PROFILER_RUNTIME_STATS
class
StaticBaseProfilerStats
{
public
:
explicit
StaticBaseProfilerStats
(
const
char
*
aName
)
:
mName
(
aName
)
{
}
~
StaticBaseProfilerStats
(
)
{
using
ULL
=
unsigned
long
long
;
ULL
n
=
static_cast
<
ULL
>
(
mNumberDurations
)
;
if
(
n
!
=
0
)
{
ULL
sumNs
=
static_cast
<
ULL
>
(
mSumDurationsNs
)
;
printf
(
"
[
%
d
]
Profiler
stats
%
s
:
%
llu
ns
/
%
llu
=
%
llu
ns
max
%
llu
ns
\
n
"
profiler_current_process_id
(
)
mName
sumNs
n
sumNs
/
n
static_cast
<
ULL
>
(
mLongestDurationNs
)
)
;
}
else
{
printf
(
"
[
%
d
]
Profiler
stats
%
s
:
(
nothing
)
\
n
"
profiler_current_process_id
(
)
mName
)
;
}
}
void
AddDurationFrom
(
TimeStamp
aStart
)
{
DurationNs
duration
=
static_cast
<
DurationNs
>
(
(
TimeStamp
:
:
NowUnfuzzed
(
)
-
aStart
)
.
ToMicroseconds
(
)
*
1000
+
0
.
5
)
;
mSumDurationsNs
+
=
duration
;
+
+
mNumberDurations
;
for
(
;
;
)
{
DurationNs
longest
=
mLongestDurationNs
;
if
(
MOZ_LIKELY
(
longest
>
=
duration
)
)
{
break
;
}
if
(
MOZ_LIKELY
(
mLongestDurationNs
.
compareExchange
(
longest
duration
)
)
)
{
break
;
}
}
}
private
:
using
DurationNs
=
uint64_t
;
using
Count
=
uint32_t
;
Atomic
<
DurationNs
>
mSumDurationsNs
{
0
}
;
Atomic
<
DurationNs
>
mLongestDurationNs
{
0
}
;
Atomic
<
Count
>
mNumberDurations
{
0
}
;
const
char
*
mName
;
}
;
class
MOZ_RAII
AutoProfilerStats
{
public
:
explicit
AutoProfilerStats
(
StaticBaseProfilerStats
&
aStats
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
mStats
(
aStats
)
mStart
(
TimeStamp
:
:
NowUnfuzzed
(
)
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
}
~
AutoProfilerStats
(
)
{
mStats
.
AddDurationFrom
(
mStart
)
;
}
private
:
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
StaticBaseProfilerStats
&
mStats
;
TimeStamp
mStart
;
}
;
#
define
AUTO_PROFILER_STATS
(
name
)
\
static
:
:
mozilla
:
:
baseprofiler
:
:
StaticBaseProfilerStats
sStat
#
#
name
(
\
#
name
)
;
\
:
:
mozilla
:
:
baseprofiler
:
:
AutoProfilerStats
autoStat
#
#
name
(
sStat
#
#
name
)
;
#
else
#
define
AUTO_PROFILER_STATS
(
name
)
#
endif
#
define
AUTO_BASE_PROFILER_LABEL
(
label
categoryPair
)
\
:
:
mozilla
:
:
baseprofiler
:
:
AutoProfilerLabel
BASE_PROFILER_RAII
(
\
label
nullptr
\
:
:
mozilla
:
:
baseprofiler
:
:
ProfilingCategoryPair
:
:
categoryPair
)
#
define
AUTO_BASE_PROFILER_LABEL_CATEGORY_PAIR
(
categoryPair
)
\
:
:
mozilla
:
:
baseprofiler
:
:
AutoProfilerLabel
BASE_PROFILER_RAII
(
\
"
"
nullptr
\
:
:
mozilla
:
:
baseprofiler
:
:
ProfilingCategoryPair
:
:
categoryPair
\
uint32_t
(
:
:
mozilla
:
:
baseprofiler
:
:
ProfilingStackFrame
:
:
Flags
:
:
\
LABEL_DETERMINED_BY_CATEGORY_PAIR
)
)
#
define
AUTO_BASE_PROFILER_LABEL_DYNAMIC_CSTR
(
label
categoryPair
cStr
)
\
:
:
mozilla
:
:
baseprofiler
:
:
AutoProfilerLabel
BASE_PROFILER_RAII
(
\
label
cStr
\
:
:
mozilla
:
:
baseprofiler
:
:
ProfilingCategoryPair
:
:
categoryPair
)
#
define
AUTO_BASE_PROFILER_LABEL_DYNAMIC_STRING
(
label
categoryPair
str
)
\
Maybe
<
std
:
:
string
>
autoStr
;
\
Maybe
<
:
:
mozilla
:
:
baseprofiler
:
:
AutoProfilerLabel
>
raiiObjectString
;
\
if
(
:
:
mozilla
:
:
baseprofiler
:
:
profiler_is_active
(
)
)
{
\
autoStr
.
emplace
(
str
)
;
\
raiiObjectString
.
emplace
(
\
label
autoStr
-
>
c_str
(
)
\
:
:
mozilla
:
:
baseprofiler
:
:
ProfilingCategoryPair
:
:
categoryPair
)
;
\
}
#
define
AUTO_BASE_PROFILER_LABEL_FAST
(
label
categoryPair
ctx
)
\
:
:
mozilla
:
:
baseprofiler
:
:
AutoProfilerLabel
BASE_PROFILER_RAII
(
\
ctx
label
nullptr
\
:
:
mozilla
:
:
baseprofiler
:
:
ProfilingCategoryPair
:
:
categoryPair
)
#
define
AUTO_BASE_PROFILER_LABEL_DYNAMIC_FAST
(
label
dynamicString
\
categoryPair
ctx
flags
)
\
:
:
mozilla
:
:
baseprofiler
:
:
AutoProfilerLabel
BASE_PROFILER_RAII
(
\
ctx
label
dynamicString
\
:
:
mozilla
:
:
baseprofiler
:
:
ProfilingCategoryPair
:
:
categoryPair
flags
)
#
define
BASE_PROFILER_ADD_MARKER
(
markerName
categoryPair
)
\
do
{
\
AUTO_PROFILER_STATS
(
base_add_marker
)
;
\
:
:
mozilla
:
:
baseprofiler
:
:
profiler_add_marker
(
\
markerName
\
:
:
mozilla
:
:
baseprofiler
:
:
ProfilingCategoryPair
:
:
categoryPair
)
;
\
}
while
(
false
)
MFBT_API
void
profiler_add_marker
(
const
char
*
aMarkerName
ProfilingCategoryPair
aCategoryPair
)
;
#
define
BASE_PROFILER_ADD_MARKER_WITH_PAYLOAD
(
\
markerName
categoryPair
PayloadType
parenthesizedPayloadArgs
)
\
do
{
\
AUTO_PROFILER_STATS
(
base_add_marker_with_
#
#
PayloadType
)
;
\
:
:
mozilla
:
:
baseprofiler
:
:
profiler_add_marker
(
\
markerName
\
:
:
mozilla
:
:
baseprofiler
:
:
ProfilingCategoryPair
:
:
categoryPair
\
PayloadType
parenthesizedPayloadArgs
)
;
\
}
while
(
false
)
MFBT_API
void
profiler_add_marker
(
const
char
*
aMarkerName
ProfilingCategoryPair
aCategoryPair
const
ProfilerMarkerPayload
&
aPayload
)
;
MFBT_API
void
profiler_add_js_marker
(
const
char
*
aMarkerName
)
;
bool
profiler_is_locked_on_current_thread
(
)
;
MFBT_API
void
profiler_add_marker_for_thread
(
int
aThreadId
ProfilingCategoryPair
aCategoryPair
const
char
*
aMarkerName
const
ProfilerMarkerPayload
&
aPayload
)
;
MFBT_API
void
profiler_add_marker_for_mainthread
(
ProfilingCategoryPair
aCategoryPair
const
char
*
aMarkerName
const
ProfilerMarkerPayload
&
aPayload
)
;
enum
TracingKind
{
TRACING_EVENT
TRACING_INTERVAL_START
TRACING_INTERVAL_END
}
;
#
define
BASE_PROFILER_TRACING_MARKER
(
categoryString
markerName
\
categoryPair
kind
)
\
:
:
mozilla
:
:
baseprofiler
:
:
profiler_tracing_marker
(
\
categoryString
markerName
\
:
:
mozilla
:
:
baseprofiler
:
:
ProfilingCategoryPair
:
:
categoryPair
kind
)
MFBT_API
void
profiler_tracing_marker
(
const
char
*
aCategoryString
const
char
*
aMarkerName
ProfilingCategoryPair
aCategoryPair
TracingKind
aKind
const
Maybe
<
uint64_t
>
&
aInnerWindowID
=
Nothing
(
)
)
;
MFBT_API
void
profiler_tracing_marker
(
const
char
*
aCategoryString
const
char
*
aMarkerName
ProfilingCategoryPair
aCategoryPair
TracingKind
aKind
UniqueProfilerBacktrace
aCause
const
Maybe
<
uint64_t
>
&
aInnerWindowID
=
Nothing
(
)
)
;
#
define
AUTO_BASE_PROFILER_TRACING_MARKER
(
categoryString
markerName
\
categoryPair
)
\
:
:
mozilla
:
:
baseprofiler
:
:
AutoProfilerTracing
BASE_PROFILER_RAII
(
\
categoryString
markerName
\
:
:
mozilla
:
:
baseprofiler
:
:
ProfilingCategoryPair
:
:
categoryPair
\
Nothing
(
)
)
MFBT_API
void
profiler_add_text_marker
(
const
char
*
aMarkerName
const
std
:
:
string
&
aText
ProfilingCategoryPair
aCategoryPair
const
TimeStamp
&
aStartTime
const
TimeStamp
&
aEndTime
const
Maybe
<
uint64_t
>
&
aInnerWindowID
=
Nothing
(
)
UniqueProfilerBacktrace
aCause
=
nullptr
)
;
class
MOZ_RAII
AutoProfilerTextMarker
{
public
:
AutoProfilerTextMarker
(
const
char
*
aMarkerName
const
std
:
:
string
&
aText
ProfilingCategoryPair
aCategoryPair
const
Maybe
<
uint64_t
>
&
aInnerWindowID
UniqueProfilerBacktrace
&
&
aCause
=
nullptr
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
mMarkerName
(
aMarkerName
)
mText
(
aText
)
mCategoryPair
(
aCategoryPair
)
mStartTime
(
TimeStamp
:
:
NowUnfuzzed
(
)
)
mCause
(
std
:
:
move
(
aCause
)
)
mInnerWindowID
(
aInnerWindowID
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
}
~
AutoProfilerTextMarker
(
)
{
profiler_add_text_marker
(
mMarkerName
mText
mCategoryPair
mStartTime
TimeStamp
:
:
NowUnfuzzed
(
)
mInnerWindowID
std
:
:
move
(
mCause
)
)
;
}
protected
:
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
const
char
*
mMarkerName
;
std
:
:
string
mText
;
const
ProfilingCategoryPair
mCategoryPair
;
TimeStamp
mStartTime
;
UniqueProfilerBacktrace
mCause
;
const
Maybe
<
uint64_t
>
mInnerWindowID
;
}
;
#
define
AUTO_BASE_PROFILER_TEXT_MARKER_CAUSE
(
markerName
text
categoryPair
\
cause
)
\
:
:
mozilla
:
:
baseprofiler
:
:
AutoProfilerTextMarker
BASE_PROFILER_RAII
(
\
markerName
text
\
:
:
mozilla
:
:
baseprofiler
:
:
ProfilingCategoryPair
:
:
categoryPair
\
mozilla
:
:
Nothing
(
)
cause
)
MFBT_API
void
profiler_set_process_name
(
const
std
:
:
string
&
aProcessName
)
;
MFBT_API
UniquePtr
<
char
[
]
>
profiler_get_profile
(
double
aSinceTime
=
0
bool
aIsShuttingDown
=
false
bool
aOnlyThreads
=
false
)
;
MFBT_API
bool
profiler_stream_json_for_this_process
(
SpliceableJSONWriter
&
aWriter
double
aSinceTime
=
0
bool
aIsShuttingDown
=
false
bool
aOnlyThreads
=
false
)
;
MFBT_API
void
profiler_save_profile_to_file
(
const
char
*
aFilename
)
;
class
MOZ_RAII
AutoProfilerInit
{
public
:
explicit
AutoProfilerInit
(
MOZ_GUARD_OBJECT_NOTIFIER_ONLY_PARAM
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
profiler_init
(
this
)
;
}
~
AutoProfilerInit
(
)
{
profiler_shutdown
(
)
;
}
private
:
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
class
MOZ_RAII
AutoProfilerRegisterThread
final
{
public
:
explicit
AutoProfilerRegisterThread
(
const
char
*
aName
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
profiler_register_thread
(
aName
this
)
;
}
~
AutoProfilerRegisterThread
(
)
{
profiler_unregister_thread
(
)
;
}
private
:
AutoProfilerRegisterThread
(
const
AutoProfilerRegisterThread
&
)
=
delete
;
AutoProfilerRegisterThread
&
operator
=
(
const
AutoProfilerRegisterThread
&
)
=
delete
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
class
MOZ_RAII
AutoProfilerThreadSleep
{
public
:
explicit
AutoProfilerThreadSleep
(
MOZ_GUARD_OBJECT_NOTIFIER_ONLY_PARAM
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
profiler_thread_sleep
(
)
;
}
~
AutoProfilerThreadSleep
(
)
{
profiler_thread_wake
(
)
;
}
private
:
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
class
MOZ_RAII
AutoProfilerThreadWake
{
public
:
explicit
AutoProfilerThreadWake
(
MOZ_GUARD_OBJECT_NOTIFIER_ONLY_PARAM
)
:
mIssuedWake
(
profiler_thread_is_sleeping
(
)
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
if
(
mIssuedWake
)
{
profiler_thread_wake
(
)
;
}
}
~
AutoProfilerThreadWake
(
)
{
if
(
mIssuedWake
)
{
MOZ_ASSERT
(
!
profiler_thread_is_sleeping
(
)
)
;
profiler_thread_sleep
(
)
;
}
}
private
:
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
bool
mIssuedWake
;
}
;
class
MOZ_RAII
AutoProfilerLabel
{
public
:
AutoProfilerLabel
(
const
char
*
aLabel
const
char
*
aDynamicString
ProfilingCategoryPair
aCategoryPair
uint32_t
aFlags
=
0
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
Push
(
GetProfilingStack
(
)
aLabel
aDynamicString
aCategoryPair
aFlags
)
;
}
void
Push
(
ProfilingStack
*
aProfilingStack
const
char
*
aLabel
const
char
*
aDynamicString
ProfilingCategoryPair
aCategoryPair
uint32_t
aFlags
=
0
)
{
mProfilingStack
=
aProfilingStack
;
if
(
mProfilingStack
)
{
mProfilingStack
-
>
pushLabelFrame
(
aLabel
aDynamicString
this
aCategoryPair
aFlags
)
;
}
}
~
AutoProfilerLabel
(
)
{
if
(
mProfilingStack
)
{
mProfilingStack
-
>
pop
(
)
;
}
}
MFBT_API
static
ProfilingStack
*
GetProfilingStack
(
)
;
private
:
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
ProfilingStack
*
mProfilingStack
;
public
:
static
MOZ_THREAD_LOCAL
(
ProfilingStack
*
)
sProfilingStack
;
}
;
class
MOZ_RAII
AutoProfilerTracing
{
public
:
AutoProfilerTracing
(
const
char
*
aCategoryString
const
char
*
aMarkerName
ProfilingCategoryPair
aCategoryPair
const
Maybe
<
uint64_t
>
&
aInnerWindowID
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
mCategoryString
(
aCategoryString
)
mMarkerName
(
aMarkerName
)
mCategoryPair
(
aCategoryPair
)
mInnerWindowID
(
aInnerWindowID
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
profiler_tracing_marker
(
mCategoryString
mMarkerName
aCategoryPair
TRACING_INTERVAL_START
mInnerWindowID
)
;
}
AutoProfilerTracing
(
const
char
*
aCategoryString
const
char
*
aMarkerName
ProfilingCategoryPair
aCategoryPair
UniqueProfilerBacktrace
aBacktrace
const
Maybe
<
uint64_t
>
&
aInnerWindowID
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
mCategoryString
(
aCategoryString
)
mMarkerName
(
aMarkerName
)
mCategoryPair
(
aCategoryPair
)
mInnerWindowID
(
aInnerWindowID
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
profiler_tracing_marker
(
mCategoryString
mMarkerName
aCategoryPair
TRACING_INTERVAL_START
std
:
:
move
(
aBacktrace
)
mInnerWindowID
)
;
}
~
AutoProfilerTracing
(
)
{
profiler_tracing_marker
(
mCategoryString
mMarkerName
mCategoryPair
TRACING_INTERVAL_END
mInnerWindowID
)
;
}
protected
:
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
const
char
*
mCategoryString
;
const
char
*
mMarkerName
;
const
ProfilingCategoryPair
mCategoryPair
;
const
Maybe
<
uint64_t
>
mInnerWindowID
;
}
;
MFBT_API
void
GetProfilerEnvVarsForChildProcess
(
std
:
:
function
<
void
(
const
char
*
key
const
char
*
value
)
>
&
&
aSetEnv
)
;
}
}
#
endif
#
endif
