#
ifndef
BlocksRingBuffer_h
#
define
BlocksRingBuffer_h
#
include
"
mozilla
/
BaseProfilerDetail
.
h
"
#
include
"
mozilla
/
ModuloBuffer
.
h
"
#
include
"
mozilla
/
Pair
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
<
functional
>
#
include
<
utility
>
namespace
mozilla
{
class
BlocksRingBuffer
{
using
Index
=
uint64_t
;
using
Buffer
=
ModuloBuffer
<
uint32_t
Index
>
;
using
BufferWriter
=
Buffer
:
:
Writer
;
using
BufferReader
=
Buffer
:
:
Reader
;
public
:
using
Length
=
uint32_t
;
class
BlockIndex
{
public
:
BlockIndex
(
)
:
mBlockIndex
(
0
)
{
}
explicit
operator
bool
(
)
const
{
return
mBlockIndex
!
=
0
;
}
bool
operator
=
=
(
const
BlockIndex
&
aRhs
)
const
{
return
mBlockIndex
=
=
aRhs
.
mBlockIndex
;
}
bool
operator
!
=
(
const
BlockIndex
&
aRhs
)
const
{
return
mBlockIndex
!
=
aRhs
.
mBlockIndex
;
}
bool
operator
<
(
const
BlockIndex
&
aRhs
)
const
{
return
mBlockIndex
<
aRhs
.
mBlockIndex
;
}
bool
operator
<
=
(
const
BlockIndex
&
aRhs
)
const
{
return
mBlockIndex
<
=
aRhs
.
mBlockIndex
;
}
bool
operator
>
(
const
BlockIndex
&
aRhs
)
const
{
return
mBlockIndex
>
aRhs
.
mBlockIndex
;
}
bool
operator
>
=
(
const
BlockIndex
&
aRhs
)
const
{
return
mBlockIndex
>
=
aRhs
.
mBlockIndex
;
}
private
:
friend
class
BlocksRingBuffer
;
explicit
BlockIndex
(
Index
aBlockIndex
)
:
mBlockIndex
(
aBlockIndex
)
{
}
explicit
operator
Index
(
)
const
{
return
mBlockIndex
;
}
Index
mBlockIndex
;
}
;
BlocksRingBuffer
(
)
=
default
;
explicit
BlocksRingBuffer
(
PowerOfTwo
<
Length
>
aLength
)
:
mMaybeUnderlyingBuffer
(
Some
(
UnderlyingBuffer
(
aLength
)
)
)
{
}
BlocksRingBuffer
(
UniquePtr
<
Buffer
:
:
Byte
[
]
>
aExistingBuffer
PowerOfTwo
<
Length
>
aLength
)
:
mMaybeUnderlyingBuffer
(
Some
(
UnderlyingBuffer
(
std
:
:
move
(
aExistingBuffer
)
aLength
)
)
)
{
}
BlocksRingBuffer
(
Buffer
:
:
Byte
*
aExternalBuffer
PowerOfTwo
<
Length
>
aLength
)
:
mMaybeUnderlyingBuffer
(
Some
(
UnderlyingBuffer
(
aExternalBuffer
aLength
)
)
)
{
}
template
<
typename
EntryDestructor
>
explicit
BlocksRingBuffer
(
PowerOfTwo
<
Length
>
aLength
EntryDestructor
&
&
aEntryDestructor
)
:
mMaybeUnderlyingBuffer
(
Some
(
UnderlyingBuffer
(
aLength
std
:
:
forward
<
EntryDestructor
>
(
aEntryDestructor
)
)
)
)
{
}
template
<
typename
EntryDestructor
>
explicit
BlocksRingBuffer
(
UniquePtr
<
Buffer
:
:
Byte
[
]
>
aExistingBuffer
PowerOfTwo
<
Length
>
aLength
EntryDestructor
&
&
aEntryDestructor
)
:
mMaybeUnderlyingBuffer
(
Some
(
UnderlyingBuffer
(
std
:
:
move
(
aExistingBuffer
)
aLength
std
:
:
forward
<
EntryDestructor
>
(
aEntryDestructor
)
)
)
)
{
}
template
<
typename
EntryDestructor
>
explicit
BlocksRingBuffer
(
Buffer
:
:
Byte
*
aExternalBuffer
PowerOfTwo
<
Length
>
aLength
EntryDestructor
&
&
aEntryDestructor
)
:
mMaybeUnderlyingBuffer
(
Some
(
UnderlyingBuffer
(
aExternalBuffer
aLength
std
:
:
forward
<
EntryDestructor
>
(
aEntryDestructor
)
)
)
)
{
}
~
BlocksRingBuffer
(
)
{
#
ifdef
DEBUG
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
lock
(
mMutex
)
;
#
endif
DestroyAllEntries
(
)
;
}
void
Reset
(
)
{
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
lock
(
mMutex
)
;
ResetUnderlyingBuffer
(
)
;
}
void
Set
(
PowerOfTwo
<
Length
>
aLength
)
{
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
lock
(
mMutex
)
;
ResetUnderlyingBuffer
(
)
;
mMaybeUnderlyingBuffer
.
emplace
(
aLength
)
;
}
void
Set
(
UniquePtr
<
Buffer
:
:
Byte
[
]
>
aExistingBuffer
PowerOfTwo
<
Length
>
aLength
)
{
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
lock
(
mMutex
)
;
ResetUnderlyingBuffer
(
)
;
mMaybeUnderlyingBuffer
.
emplace
(
std
:
:
move
(
aExistingBuffer
)
aLength
)
;
}
void
Set
(
Buffer
:
:
Byte
*
aExternalBuffer
PowerOfTwo
<
Length
>
aLength
)
{
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
lock
(
mMutex
)
;
ResetUnderlyingBuffer
(
)
;
mMaybeUnderlyingBuffer
.
emplace
(
aExternalBuffer
aLength
)
;
}
template
<
typename
EntryDestructor
>
void
Set
(
PowerOfTwo
<
Length
>
aLength
EntryDestructor
&
&
aEntryDestructor
)
{
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
lock
(
mMutex
)
;
ResetUnderlyingBuffer
(
)
;
mMaybeUnderlyingBuffer
.
emplace
(
aLength
std
:
:
forward
<
EntryDestructor
>
(
aEntryDestructor
)
)
;
}
template
<
typename
EntryDestructor
>
void
Set
(
UniquePtr
<
Buffer
:
:
Byte
[
]
>
aExistingBuffer
PowerOfTwo
<
Length
>
aLength
EntryDestructor
&
&
aEntryDestructor
)
{
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
lock
(
mMutex
)
;
ResetUnderlyingBuffer
(
)
;
mMaybeUnderlyingBuffer
.
emplace
(
std
:
:
move
(
aExistingBuffer
)
aLength
std
:
:
forward
<
EntryDestructor
>
(
aEntryDestructor
)
)
;
}
template
<
typename
EntryDestructor
>
void
Set
(
Buffer
:
:
Byte
*
aExternalBuffer
PowerOfTwo
<
Length
>
aLength
EntryDestructor
&
&
aEntryDestructor
)
{
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
lock
(
mMutex
)
;
ResetUnderlyingBuffer
(
)
;
mMaybeUnderlyingBuffer
.
emplace
(
aExternalBuffer
aLength
std
:
:
forward
<
EntryDestructor
>
(
aEntryDestructor
)
)
;
}
Maybe
<
PowerOfTwo
<
Length
>
>
BufferLength
(
)
const
{
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
lock
(
mMutex
)
;
return
mMaybeUnderlyingBuffer
.
map
(
[
]
(
const
UnderlyingBuffer
&
aBuffer
)
{
return
aBuffer
.
mBuffer
.
BufferLength
(
)
;
}
)
;
;
}
struct
State
{
BlockIndex
mRangeStart
;
BlockIndex
mRangeEnd
;
uint64_t
mPushedBlockCount
=
0
;
uint64_t
mClearedBlockCount
=
0
;
}
;
State
GetState
(
)
const
{
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
lock
(
mMutex
)
;
return
{
mFirstReadIndex
mNextWriteIndex
mMaybeUnderlyingBuffer
?
mMaybeUnderlyingBuffer
-
>
mPushedBlockCount
:
0
mMaybeUnderlyingBuffer
?
mMaybeUnderlyingBuffer
-
>
mClearedBlockCount
:
0
}
;
}
class
EntryReader
:
public
BufferReader
{
public
:
EntryReader
(
EntryReader
&
&
aOther
)
=
default
;
EntryReader
(
const
EntryReader
&
aOther
)
=
delete
;
EntryReader
&
operator
=
(
const
EntryReader
&
aOther
)
=
delete
;
EntryReader
&
operator
=
(
EntryReader
&
&
aOther
)
=
delete
;
#
ifdef
DEBUG
~
EntryReader
(
)
{
MOZ_ASSERT
(
CurrentIndex
(
)
>
=
mEntryStart
)
;
MOZ_ASSERT
(
CurrentIndex
(
)
<
=
mEntryStart
+
mEntryBytes
)
;
mRing
.
mMutex
.
AssertCurrentThreadOwns
(
)
;
}
#
endif
Length
EntryBytes
(
)
const
{
return
mEntryBytes
;
}
Length
IndexInEntry
(
)
const
{
return
static_cast
<
Length
>
(
CurrentIndex
(
)
-
mEntryStart
)
;
}
Length
RemainingBytes
(
)
const
{
return
static_cast
<
Length
>
(
mEntryStart
+
mEntryBytes
-
CurrentIndex
(
)
)
;
}
BlockIndex
CurrentBlockIndex
(
)
const
{
return
BlockIndex
(
mEntryStart
-
BufferReader
:
:
ULEB128Size
(
mEntryBytes
)
)
;
}
BlockIndex
NextBlockIndex
(
)
const
{
return
BlockIndex
(
mEntryStart
+
mEntryBytes
)
;
}
BlockIndex
BufferRangeStart
(
)
const
{
return
mRing
.
mFirstReadIndex
;
}
BlockIndex
BufferRangeEnd
(
)
const
{
return
mRing
.
mNextWriteIndex
;
}
Maybe
<
EntryReader
>
GetEntryAt
(
BlockIndex
aBlockIndex
)
{
MOZ_ASSERT
(
aBlockIndex
<
=
BufferRangeEnd
(
)
)
;
if
(
aBlockIndex
>
=
BufferRangeStart
(
)
&
&
aBlockIndex
<
BufferRangeEnd
(
)
)
{
mRing
.
AssertBlockIndexIsValid
(
aBlockIndex
)
;
return
Some
(
EntryReader
(
mRing
aBlockIndex
)
)
;
}
return
Nothing
(
)
;
}
Maybe
<
EntryReader
>
GetNextEntry
(
)
{
const
BlockIndex
nextBlockIndex
=
NextBlockIndex
(
)
;
if
(
nextBlockIndex
<
BufferRangeEnd
(
)
)
{
return
Some
(
EntryReader
(
mRing
nextBlockIndex
)
)
;
}
return
Nothing
(
)
;
}
private
:
friend
class
BlocksRingBuffer
;
explicit
EntryReader
(
const
BlocksRingBuffer
&
aRing
BlockIndex
aBlockIndex
)
:
BufferReader
(
aRing
.
mMaybeUnderlyingBuffer
-
>
mBuffer
.
ReaderAt
(
Index
(
aBlockIndex
)
)
)
mRing
(
aRing
)
mEntryBytes
(
BufferReader
:
:
ReadULEB128
<
Length
>
(
)
)
mEntryStart
(
CurrentIndex
(
)
)
{
mRing
.
mMutex
.
AssertCurrentThreadOwns
(
)
;
}
const
BlocksRingBuffer
&
mRing
;
const
Length
mEntryBytes
;
const
Index
mEntryStart
;
}
;
class
Reader
;
class
BlockIterator
{
public
:
#
ifdef
DEBUG
~
BlockIterator
(
)
{
mRing
-
>
mMutex
.
AssertCurrentThreadOwns
(
)
;
}
#
endif
bool
operator
=
=
(
const
BlockIterator
aRhs
)
const
{
MOZ_ASSERT
(
mRing
=
=
aRhs
.
mRing
)
;
return
mBlockIndex
=
=
aRhs
.
mBlockIndex
;
}
bool
operator
!
=
(
const
BlockIterator
aRhs
)
const
{
MOZ_ASSERT
(
mRing
=
=
aRhs
.
mRing
)
;
return
mBlockIndex
!
=
aRhs
.
mBlockIndex
;
}
BlockIterator
&
operator
+
+
(
)
{
mBlockIndex
=
NextBlockIndex
(
)
;
return
*
this
;
}
EntryReader
operator
*
(
)
const
{
return
mRing
-
>
ReaderInBlockAt
(
mBlockIndex
)
;
}
bool
IsAtEnd
(
)
const
{
MOZ_ASSERT
(
mBlockIndex
<
=
BufferRangeEnd
(
)
)
;
return
mBlockIndex
=
=
BufferRangeEnd
(
)
;
}
BlockIndex
CurrentBlockIndex
(
)
const
{
return
mBlockIndex
;
}
BlockIndex
NextBlockIndex
(
)
const
{
MOZ_ASSERT
(
!
IsAtEnd
(
)
)
;
BufferReader
reader
=
mRing
-
>
mMaybeUnderlyingBuffer
-
>
mBuffer
.
ReaderAt
(
Index
(
mBlockIndex
)
)
;
Length
entrySize
=
reader
.
ReadULEB128
<
Length
>
(
)
;
return
BlockIndex
(
reader
.
CurrentIndex
(
)
+
entrySize
)
;
}
BlockIndex
BufferRangeStart
(
)
const
{
return
mRing
-
>
mFirstReadIndex
;
}
BlockIndex
BufferRangeEnd
(
)
const
{
return
mRing
-
>
mNextWriteIndex
;
}
private
:
friend
class
Reader
;
BlockIterator
(
const
BlocksRingBuffer
&
aRing
BlockIndex
aBlockIndex
)
:
mRing
(
WrapNotNull
(
&
aRing
)
)
mBlockIndex
(
aBlockIndex
)
{
mRing
-
>
mMutex
.
AssertCurrentThreadOwns
(
)
;
}
NotNull
<
const
BlocksRingBuffer
*
>
mRing
;
BlockIndex
mBlockIndex
;
}
;
class
Reader
{
public
:
#
ifdef
DEBUG
~
Reader
(
)
{
mRing
-
>
mMutex
.
AssertCurrentThreadOwns
(
)
;
}
#
endif
BlockIndex
BufferRangeStart
(
)
const
{
return
mRing
-
>
mFirstReadIndex
;
}
BlockIndex
BufferRangeEnd
(
)
const
{
return
mRing
-
>
mNextWriteIndex
;
}
BlockIterator
begin
(
)
const
{
return
BlockIterator
(
*
mRing
BufferRangeStart
(
)
)
;
}
BlockIterator
end
(
)
const
{
return
BlockIterator
(
*
mRing
BufferRangeEnd
(
)
)
;
}
template
<
typename
Callback
>
void
ForEach
(
Callback
&
&
aCallback
)
const
{
for
(
EntryReader
reader
:
*
this
)
{
aCallback
(
reader
)
;
}
}
private
:
friend
class
BlocksRingBuffer
;
explicit
Reader
(
const
BlocksRingBuffer
&
aRing
)
:
mRing
(
WrapNotNull
(
&
aRing
)
)
{
mRing
-
>
mMutex
.
AssertCurrentThreadOwns
(
)
;
}
NotNull
<
const
BlocksRingBuffer
*
>
mRing
;
}
;
template
<
typename
Callback
>
auto
Read
(
Callback
&
&
aCallback
)
const
{
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
lock
(
mMutex
)
;
Maybe
<
Reader
>
maybeReader
;
if
(
MOZ_LIKELY
(
mMaybeUnderlyingBuffer
)
)
{
maybeReader
.
emplace
(
Reader
(
*
this
)
)
;
}
return
std
:
:
forward
<
Callback
>
(
aCallback
)
(
std
:
:
move
(
maybeReader
)
)
;
}
template
<
typename
Callback
>
void
ReadEach
(
Callback
&
&
aCallback
)
const
{
Read
(
[
&
]
(
Maybe
<
Reader
>
&
&
aMaybeReader
)
{
if
(
MOZ_LIKELY
(
aMaybeReader
)
)
{
std
:
:
move
(
aMaybeReader
)
-
>
ForEach
(
aCallback
)
;
}
}
)
;
}
template
<
typename
Callback
>
auto
ReadAt
(
BlockIndex
aBlockIndex
Callback
&
&
aCallback
)
const
{
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
lock
(
mMutex
)
;
MOZ_ASSERT
(
aBlockIndex
<
=
mNextWriteIndex
)
;
Maybe
<
EntryReader
>
maybeEntryReader
;
if
(
MOZ_LIKELY
(
mMaybeUnderlyingBuffer
)
&
&
aBlockIndex
>
=
mFirstReadIndex
&
&
aBlockIndex
<
mNextWriteIndex
)
{
AssertBlockIndexIsValid
(
aBlockIndex
)
;
maybeEntryReader
.
emplace
(
ReaderInBlockAt
(
aBlockIndex
)
)
;
}
return
std
:
:
forward
<
Callback
>
(
aCallback
)
(
std
:
:
move
(
maybeEntryReader
)
)
;
}
class
EntryReserver
;
class
MOZ_RAII
EntryWriter
:
public
BufferWriter
{
public
:
EntryWriter
(
const
EntryWriter
&
aOther
)
=
delete
;
EntryWriter
&
operator
=
(
const
EntryWriter
&
aOther
)
=
delete
;
EntryWriter
(
EntryWriter
&
&
aOther
)
=
delete
;
EntryWriter
&
operator
=
(
EntryWriter
&
&
aOther
)
=
delete
;
#
ifdef
DEBUG
~
EntryWriter
(
)
{
MOZ_ASSERT
(
RemainingBytes
(
)
=
=
0
)
;
mRing
.
mMutex
.
AssertCurrentThreadOwns
(
)
;
}
#
endif
Length
EntryBytes
(
)
const
{
return
mEntryBytes
;
}
Length
IndexInEntry
(
)
const
{
return
static_cast
<
Length
>
(
CurrentIndex
(
)
-
mEntryStart
)
;
}
Length
RemainingBytes
(
)
const
{
return
static_cast
<
Length
>
(
mEntryStart
+
mEntryBytes
-
CurrentIndex
(
)
)
;
}
BlockIndex
CurrentBlockIndex
(
)
const
{
return
BlockIndex
(
mEntryStart
-
BufferWriter
:
:
ULEB128Size
(
mEntryBytes
)
)
;
}
BlockIndex
BlockEndIndex
(
)
const
{
return
BlockIndex
(
mEntryStart
+
mEntryBytes
)
;
}
BlockIndex
BufferRangeStart
(
)
const
{
return
mRing
.
mFirstReadIndex
;
}
BlockIndex
BufferRangeEnd
(
)
const
{
return
mRing
.
mNextWriteIndex
;
}
Maybe
<
EntryReader
>
GetEntryAt
(
BlockIndex
aBlockIndex
)
{
MOZ_RELEASE_ASSERT
(
aBlockIndex
<
BufferRangeEnd
(
)
)
;
if
(
aBlockIndex
>
=
BufferRangeStart
(
)
)
{
mRing
.
AssertBlockIndexIsValid
(
aBlockIndex
)
;
return
Some
(
EntryReader
(
mRing
aBlockIndex
)
)
;
}
return
Nothing
(
)
;
}
private
:
friend
class
EntryReserver
;
static
Length
BlockSizeForEntrySize
(
Length
aEntryBytes
)
{
return
aEntryBytes
+
static_cast
<
Length
>
(
BufferWriter
:
:
ULEB128Size
(
aEntryBytes
)
)
;
}
EntryWriter
(
BlocksRingBuffer
&
aRing
BlockIndex
aBlockIndex
Length
aEntryBytes
)
:
BufferWriter
(
aRing
.
mMaybeUnderlyingBuffer
-
>
mBuffer
.
WriterAt
(
Index
(
aBlockIndex
)
)
)
mRing
(
aRing
)
mEntryBytes
(
aEntryBytes
)
mEntryStart
(
[
&
]
(
)
{
BufferWriter
:
:
WriteULEB128
(
aEntryBytes
)
;
return
CurrentIndex
(
)
;
}
(
)
)
{
mRing
.
mMutex
.
AssertCurrentThreadOwns
(
)
;
}
BlocksRingBuffer
&
mRing
;
const
Length
mEntryBytes
;
const
Index
mEntryStart
;
}
;
class
EntryReserver
{
public
:
#
ifdef
DEBUG
~
EntryReserver
(
)
{
mRing
-
>
mMutex
.
AssertCurrentThreadOwns
(
)
;
}
#
endif
template
<
typename
Callback
>
auto
Reserve
(
Length
aBytes
Callback
&
&
aCallback
)
{
MOZ_RELEASE_ASSERT
(
aBytes
<
mRing
-
>
mMaybeUnderlyingBuffer
-
>
mBuffer
.
BufferLength
(
)
.
Value
(
)
/
2
)
;
const
Length
blockBytes
=
EntryWriter
:
:
BlockSizeForEntrySize
(
aBytes
)
;
const
BlockIndex
blockIndex
=
mRing
-
>
mNextWriteIndex
;
const
Index
blockEnd
=
Index
(
blockIndex
)
+
blockBytes
;
mRing
-
>
mNextWriteIndex
=
BlockIndex
(
blockEnd
)
;
while
(
blockEnd
>
Index
(
mRing
-
>
mFirstReadIndex
)
+
mRing
-
>
mMaybeUnderlyingBuffer
-
>
mBuffer
.
BufferLength
(
)
.
Value
(
)
)
{
EntryReader
reader
=
mRing
-
>
ReaderInBlockAt
(
mRing
-
>
mFirstReadIndex
)
;
if
(
mRing
-
>
mMaybeUnderlyingBuffer
-
>
mEntryDestructor
)
{
mRing
-
>
mMaybeUnderlyingBuffer
-
>
mEntryDestructor
(
reader
)
;
}
mRing
-
>
mMaybeUnderlyingBuffer
-
>
mClearedBlockCount
+
=
1
;
MOZ_ASSERT
(
reader
.
CurrentIndex
(
)
<
=
Index
(
reader
.
NextBlockIndex
(
)
)
)
;
mRing
-
>
mFirstReadIndex
=
reader
.
NextBlockIndex
(
)
;
}
mRing
-
>
mMaybeUnderlyingBuffer
-
>
mPushedBlockCount
+
=
1
;
return
std
:
:
forward
<
Callback
>
(
aCallback
)
(
EntryWriter
(
*
mRing
blockIndex
aBytes
)
)
;
}
BlockIndex
Write
(
const
void
*
aSrc
Length
aBytes
)
{
return
Reserve
(
aBytes
[
&
]
(
EntryWriter
&
aEW
)
{
aEW
.
Write
(
aSrc
aBytes
)
;
return
aEW
.
CurrentBlockIndex
(
)
;
}
)
;
}
template
<
typename
T
>
BlockIndex
WriteObject
(
const
T
&
aOb
)
{
return
Write
(
&
aOb
sizeof
(
T
)
)
;
}
BlockIndex
BufferRangeStart
(
)
const
{
return
mRing
-
>
mFirstReadIndex
;
}
BlockIndex
BufferRangeEnd
(
)
const
{
return
mRing
-
>
mNextWriteIndex
;
}
Maybe
<
EntryReader
>
GetEntryAt
(
BlockIndex
aBlockIndex
)
{
MOZ_ASSERT
(
aBlockIndex
<
=
BufferRangeEnd
(
)
)
;
if
(
aBlockIndex
>
=
BufferRangeStart
(
)
&
&
aBlockIndex
<
BufferRangeEnd
(
)
)
{
mRing
-
>
AssertBlockIndexIsValid
(
aBlockIndex
)
;
return
Some
(
EntryReader
(
*
mRing
aBlockIndex
)
)
;
}
return
Nothing
(
)
;
}
private
:
friend
class
BlocksRingBuffer
;
explicit
EntryReserver
(
BlocksRingBuffer
&
aRing
)
:
mRing
(
WrapNotNull
(
&
aRing
)
)
{
mRing
-
>
mMutex
.
AssertCurrentThreadOwns
(
)
;
}
NotNull
<
BlocksRingBuffer
*
>
mRing
;
}
;
template
<
typename
Callback
>
auto
Put
(
Callback
&
&
aCallback
)
{
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
lock
(
mMutex
)
;
Maybe
<
EntryReserver
>
maybeEntryReserver
;
if
(
MOZ_LIKELY
(
mMaybeUnderlyingBuffer
)
)
{
maybeEntryReserver
.
emplace
(
EntryReserver
(
*
this
)
)
;
}
return
std
:
:
forward
<
Callback
>
(
aCallback
)
(
std
:
:
move
(
maybeEntryReserver
)
)
;
}
template
<
typename
Callback
>
auto
Put
(
Length
aLength
Callback
&
&
aCallback
)
{
return
Put
(
[
&
]
(
Maybe
<
EntryReserver
>
&
&
aER
)
{
if
(
MOZ_LIKELY
(
aER
)
)
{
return
aER
-
>
Reserve
(
aLength
[
&
]
(
EntryWriter
&
aEW
)
{
return
std
:
:
forward
<
Callback
>
(
aCallback
)
(
&
aEW
)
;
}
)
;
}
return
std
:
:
forward
<
Callback
>
(
aCallback
)
(
nullptr
)
;
}
)
;
}
BlockIndex
PutFrom
(
const
void
*
aSrc
Length
aBytes
)
{
return
Put
(
[
&
]
(
Maybe
<
EntryReserver
>
&
&
aER
)
{
if
(
MOZ_LIKELY
(
aER
)
)
{
return
std
:
:
move
(
aER
)
-
>
Write
(
aSrc
aBytes
)
;
}
return
BlockIndex
{
}
;
}
)
;
}
template
<
typename
T
>
BlockIndex
PutObject
(
const
T
&
aOb
)
{
return
Put
(
[
&
]
(
Maybe
<
EntryReserver
>
&
&
aER
)
{
if
(
MOZ_LIKELY
(
aER
)
)
{
return
std
:
:
move
(
aER
)
-
>
WriteObject
<
T
>
(
aOb
)
;
}
return
BlockIndex
{
}
;
}
)
;
}
void
Clear
(
)
{
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
lock
(
mMutex
)
;
ClearAllEntries
(
)
;
}
void
ClearBefore
(
BlockIndex
aBlockIndex
)
{
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
lock
(
mMutex
)
;
if
(
!
mMaybeUnderlyingBuffer
)
{
return
;
}
MOZ_ASSERT
(
aBlockIndex
<
=
mNextWriteIndex
)
;
if
(
aBlockIndex
<
=
mFirstReadIndex
)
{
return
;
}
if
(
aBlockIndex
=
=
mNextWriteIndex
)
{
ClearAllEntries
(
)
;
return
;
}
AssertBlockIndexIsValid
(
aBlockIndex
)
;
if
(
mMaybeUnderlyingBuffer
-
>
mEntryDestructor
)
{
Reader
reader
(
*
this
)
;
BlockIterator
it
=
reader
.
begin
(
)
;
for
(
;
it
.
CurrentBlockIndex
(
)
<
aBlockIndex
;
+
+
it
)
{
MOZ_ASSERT
(
it
.
CurrentBlockIndex
(
)
<
reader
.
end
(
)
.
CurrentBlockIndex
(
)
)
;
EntryReader
reader
=
*
it
;
mMaybeUnderlyingBuffer
-
>
mEntryDestructor
(
reader
)
;
mMaybeUnderlyingBuffer
-
>
mClearedBlockCount
+
=
1
;
}
MOZ_ASSERT
(
it
.
CurrentBlockIndex
(
)
=
=
aBlockIndex
)
;
}
else
{
Reader
reader
(
*
this
)
;
BlockIterator
it
=
reader
.
begin
(
)
;
for
(
;
it
.
CurrentBlockIndex
(
)
<
aBlockIndex
;
+
+
it
)
{
MOZ_ASSERT
(
it
.
CurrentBlockIndex
(
)
<
reader
.
end
(
)
.
CurrentBlockIndex
(
)
)
;
mMaybeUnderlyingBuffer
-
>
mClearedBlockCount
+
=
1
;
}
MOZ_ASSERT
(
it
.
CurrentBlockIndex
(
)
=
=
aBlockIndex
)
;
}
mFirstReadIndex
=
aBlockIndex
;
}
#
ifdef
DEBUG
void
Dump
(
)
const
{
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
lock
(
mMutex
)
;
if
(
!
mMaybeUnderlyingBuffer
)
{
printf
(
"
empty
BlocksRingBuffer
\
n
"
)
;
return
;
}
using
ULL
=
unsigned
long
long
;
printf
(
"
start
=
%
llu
(
%
llu
)
end
=
%
llu
(
%
llu
)
-
"
ULL
(
Index
(
mFirstReadIndex
)
)
ULL
(
Index
(
mFirstReadIndex
)
&
(
mMaybeUnderlyingBuffer
-
>
mBuffer
.
BufferLength
(
)
.
Value
(
)
-
1
)
)
ULL
(
Index
(
mNextWriteIndex
)
)
ULL
(
Index
(
mNextWriteIndex
)
&
(
mMaybeUnderlyingBuffer
-
>
mBuffer
.
BufferLength
(
)
.
Value
(
)
-
1
)
)
)
;
mMaybeUnderlyingBuffer
-
>
mBuffer
.
Dump
(
)
;
}
#
endif
private
:
void
AssertBlockIndexIsValid
(
BlockIndex
aBlockIndex
)
const
{
mMutex
.
AssertCurrentThreadOwns
(
)
;
#
ifdef
DEBUG
MOZ_ASSERT
(
aBlockIndex
>
=
mFirstReadIndex
)
;
MOZ_ASSERT
(
aBlockIndex
<
mNextWriteIndex
)
;
#
if
1
BufferReader
br
=
mMaybeUnderlyingBuffer
-
>
mBuffer
.
ReaderAt
(
Index
(
aBlockIndex
)
)
;
Length
entryBytes
=
br
.
ReadULEB128
<
Length
>
(
)
;
MOZ_ASSERT
(
entryBytes
>
0
)
;
MOZ_ASSERT
(
entryBytes
<
mMaybeUnderlyingBuffer
-
>
mBuffer
.
BufferLength
(
)
.
Value
(
)
/
2
)
;
MOZ_ASSERT
(
Index
(
aBlockIndex
)
+
BufferReader
:
:
ULEB128Size
(
entryBytes
)
+
entryBytes
<
=
Index
(
mNextWriteIndex
)
)
;
#
else
Reader
reader
(
*
this
)
;
BlockIterator
it
=
reader
.
begin
(
)
;
for
(
;
it
.
CurrentBlockIndex
(
)
<
aBlockIndex
;
+
+
it
)
{
MOZ_ASSERT
(
it
.
CurrentBlockIndex
(
)
<
reader
.
end
(
)
.
CurrentBlockIndex
(
)
)
;
}
MOZ_ASSERT
(
it
.
CurrentBlockIndex
(
)
=
=
aBlockIndex
)
;
#
endif
#
endif
}
EntryReader
ReaderInBlockAt
(
BlockIndex
aBlockIndex
)
const
{
mMutex
.
AssertCurrentThreadOwns
(
)
;
MOZ_ASSERT
(
aBlockIndex
>
=
mFirstReadIndex
)
;
MOZ_ASSERT
(
aBlockIndex
<
mNextWriteIndex
)
;
return
EntryReader
(
*
this
aBlockIndex
)
;
}
void
DestroyAllEntries
(
)
{
mMutex
.
AssertCurrentThreadOwns
(
)
;
if
(
!
mMaybeUnderlyingBuffer
)
{
return
;
}
if
(
mMaybeUnderlyingBuffer
-
>
mEntryDestructor
)
{
Reader
(
*
this
)
.
ForEach
(
[
this
]
(
EntryReader
&
aReader
)
{
mMaybeUnderlyingBuffer
-
>
mEntryDestructor
(
aReader
)
;
}
)
;
}
mMaybeUnderlyingBuffer
-
>
mClearedBlockCount
=
mMaybeUnderlyingBuffer
-
>
mPushedBlockCount
;
}
void
ClearAllEntries
(
)
{
mMutex
.
AssertCurrentThreadOwns
(
)
;
if
(
!
mMaybeUnderlyingBuffer
)
{
return
;
}
DestroyAllEntries
(
)
;
mFirstReadIndex
=
mNextWriteIndex
;
}
void
ResetUnderlyingBuffer
(
)
{
if
(
!
mMaybeUnderlyingBuffer
)
{
return
;
}
ClearAllEntries
(
)
;
mMaybeUnderlyingBuffer
.
reset
(
)
;
}
mutable
baseprofiler
:
:
detail
:
:
BaseProfilerMutex
mMutex
;
struct
UnderlyingBuffer
{
explicit
UnderlyingBuffer
(
PowerOfTwo
<
Length
>
aLength
)
:
mBuffer
(
aLength
)
{
}
UnderlyingBuffer
(
UniquePtr
<
Buffer
:
:
Byte
[
]
>
aExistingBuffer
PowerOfTwo
<
Length
>
aLength
)
:
mBuffer
(
std
:
:
move
(
aExistingBuffer
)
aLength
)
{
}
UnderlyingBuffer
(
Buffer
:
:
Byte
*
aExternalBuffer
PowerOfTwo
<
Length
>
aLength
)
:
mBuffer
(
aExternalBuffer
aLength
)
{
}
template
<
typename
EntryDestructor
>
explicit
UnderlyingBuffer
(
PowerOfTwo
<
Length
>
aLength
EntryDestructor
&
&
aEntryDestructor
)
:
mBuffer
(
aLength
)
mEntryDestructor
(
std
:
:
forward
<
EntryDestructor
>
(
aEntryDestructor
)
)
{
}
template
<
typename
EntryDestructor
>
explicit
UnderlyingBuffer
(
UniquePtr
<
Buffer
:
:
Byte
[
]
>
aExistingBuffer
PowerOfTwo
<
Length
>
aLength
EntryDestructor
&
&
aEntryDestructor
)
:
mBuffer
(
std
:
:
move
(
aExistingBuffer
)
aLength
)
mEntryDestructor
(
std
:
:
forward
<
EntryDestructor
>
(
aEntryDestructor
)
)
{
}
template
<
typename
EntryDestructor
>
explicit
UnderlyingBuffer
(
Buffer
:
:
Byte
*
aExternalBuffer
PowerOfTwo
<
Length
>
aLength
EntryDestructor
&
&
aEntryDestructor
)
:
mBuffer
(
aExternalBuffer
aLength
)
mEntryDestructor
(
std
:
:
forward
<
EntryDestructor
>
(
aEntryDestructor
)
)
{
}
UnderlyingBuffer
(
UnderlyingBuffer
&
&
)
=
default
;
UnderlyingBuffer
(
const
UnderlyingBuffer
&
)
=
delete
;
UnderlyingBuffer
&
operator
=
(
const
UnderlyingBuffer
&
)
=
delete
;
UnderlyingBuffer
&
operator
=
(
UnderlyingBuffer
&
&
)
=
delete
;
Buffer
mBuffer
;
std
:
:
function
<
void
(
EntryReader
&
)
>
mEntryDestructor
;
uint64_t
mPushedBlockCount
=
0
;
uint64_t
mClearedBlockCount
=
0
;
}
;
Maybe
<
UnderlyingBuffer
>
mMaybeUnderlyingBuffer
;
BlockIndex
mFirstReadIndex
=
BlockIndex
(
Index
(
1
)
)
;
BlockIndex
mNextWriteIndex
=
BlockIndex
(
Index
(
1
)
)
;
}
;
}
#
endif
