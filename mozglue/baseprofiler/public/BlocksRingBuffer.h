#
ifndef
BlocksRingBuffer_h
#
define
BlocksRingBuffer_h
#
include
"
mozilla
/
ModuloBuffer
.
h
"
#
include
"
mozilla
/
Pair
.
h
"
#
include
"
mozilla
/
PlatformMutex
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
<
functional
>
#
include
<
utility
>
namespace
mozilla
{
class
BlocksRingBuffer
{
using
Index
=
uint64_t
;
using
Buffer
=
ModuloBuffer
<
uint32_t
Index
>
;
using
BufferWriter
=
Buffer
:
:
Writer
;
using
BufferReader
=
Buffer
:
:
Reader
;
public
:
using
Length
=
uint32_t
;
class
BlockIndex
{
public
:
bool
operator
=
=
(
const
BlockIndex
&
aRhs
)
const
{
return
mBlockIndex
=
=
aRhs
.
mBlockIndex
;
}
bool
operator
!
=
(
const
BlockIndex
&
aRhs
)
const
{
return
mBlockIndex
!
=
aRhs
.
mBlockIndex
;
}
bool
operator
<
(
const
BlockIndex
&
aRhs
)
const
{
return
mBlockIndex
<
aRhs
.
mBlockIndex
;
}
bool
operator
<
=
(
const
BlockIndex
&
aRhs
)
const
{
return
mBlockIndex
<
=
aRhs
.
mBlockIndex
;
}
bool
operator
>
(
const
BlockIndex
&
aRhs
)
const
{
return
mBlockIndex
>
aRhs
.
mBlockIndex
;
}
bool
operator
>
=
(
const
BlockIndex
&
aRhs
)
const
{
return
mBlockIndex
>
=
aRhs
.
mBlockIndex
;
}
private
:
friend
class
BlocksRingBuffer
;
explicit
BlockIndex
(
Index
aBlockIndex
)
:
mBlockIndex
(
aBlockIndex
)
{
}
explicit
operator
Index
(
)
const
{
return
mBlockIndex
;
}
Index
mBlockIndex
;
}
;
explicit
BlocksRingBuffer
(
PowerOfTwo
<
Length
>
aLength
)
:
mBuffer
(
aLength
)
{
}
BlocksRingBuffer
(
UniquePtr
<
Buffer
:
:
Byte
[
]
>
aExistingBuffer
PowerOfTwo
<
Length
>
aLength
)
:
mBuffer
(
std
:
:
move
(
aExistingBuffer
)
aLength
)
{
}
BlocksRingBuffer
(
Buffer
:
:
Byte
*
aExternalBuffer
PowerOfTwo
<
Length
>
aLength
)
:
mBuffer
(
aExternalBuffer
aLength
)
{
}
template
<
typename
Deleter
>
explicit
BlocksRingBuffer
(
PowerOfTwo
<
Length
>
aLength
Deleter
&
&
aDeleter
)
:
mBuffer
(
aLength
)
mDeleter
(
std
:
:
forward
<
Deleter
>
(
aDeleter
)
)
{
}
template
<
typename
Deleter
>
explicit
BlocksRingBuffer
(
UniquePtr
<
Buffer
:
:
Byte
[
]
>
aExistingBuffer
PowerOfTwo
<
Length
>
aLength
Deleter
&
&
aDeleter
)
:
mBuffer
(
std
:
:
move
(
aExistingBuffer
)
aLength
)
mDeleter
(
std
:
:
forward
<
Deleter
>
(
aDeleter
)
)
{
}
template
<
typename
Deleter
>
explicit
BlocksRingBuffer
(
Buffer
:
:
Byte
*
aExternalBuffer
PowerOfTwo
<
Length
>
aLength
Deleter
&
&
aDeleter
)
:
mBuffer
(
aExternalBuffer
aLength
)
mDeleter
(
std
:
:
forward
<
Deleter
>
(
aDeleter
)
)
{
}
~
BlocksRingBuffer
(
)
{
DeleteAllEntries
(
)
;
}
PowerOfTwo
<
Length
>
BufferLength
(
)
const
{
return
mBuffer
.
BufferLength
(
)
;
}
Pair
<
uint64_t
uint64_t
>
GetPushedAndDeletedCounts
(
)
const
{
RBAutoLock
lock
(
*
this
)
;
return
{
mPushedBlockCount
mDeletedBlockCount
}
;
}
class
EntryReader
:
public
BufferReader
{
public
:
~
EntryReader
(
)
{
MOZ_ASSERT
(
CurrentIndex
(
)
>
=
mEntryStart
)
;
MOZ_ASSERT
(
CurrentIndex
(
)
<
=
mEntryStart
+
mEntryBytes
)
;
}
Length
EntryBytes
(
)
const
{
return
mEntryBytes
;
}
Length
IndexInEntry
(
)
const
{
return
static_cast
<
Length
>
(
CurrentIndex
(
)
-
mEntryStart
)
;
}
Length
RemainingBytes
(
)
const
{
return
static_cast
<
Length
>
(
mEntryStart
+
mEntryBytes
-
CurrentIndex
(
)
)
;
}
BlockIndex
CurrentBlockIndex
(
)
const
{
return
BlockIndex
(
mEntryStart
-
BufferReader
:
:
ULEB128Size
(
mEntryBytes
)
)
;
}
BlockIndex
NextBlockIndex
(
)
const
{
return
BlockIndex
(
mEntryStart
+
mEntryBytes
)
;
}
BlockIndex
BufferRangeStart
(
)
const
{
return
mRing
-
>
mFirstReadIndex
;
}
BlockIndex
BufferRangeEnd
(
)
const
{
return
mRing
-
>
mNextWriteIndex
;
}
Maybe
<
EntryReader
>
GetEntryAt
(
BlockIndex
aBlockIndex
)
{
MOZ_ASSERT
(
aBlockIndex
<
=
BufferRangeEnd
(
)
)
;
if
(
aBlockIndex
>
=
BufferRangeStart
(
)
&
&
aBlockIndex
<
BufferRangeEnd
(
)
)
{
mRing
-
>
AssertBlockIndexIsValid
(
aBlockIndex
)
;
return
Some
(
EntryReader
(
*
mRing
aBlockIndex
)
)
;
}
return
Nothing
(
)
;
}
Maybe
<
EntryReader
>
GetNextEntry
(
)
{
const
BlockIndex
nextBlockIndex
=
NextBlockIndex
(
)
;
if
(
nextBlockIndex
<
BufferRangeEnd
(
)
)
{
return
Some
(
EntryReader
(
*
mRing
nextBlockIndex
)
)
;
}
return
Nothing
(
)
;
}
private
:
friend
class
BlocksRingBuffer
;
explicit
EntryReader
(
const
BlocksRingBuffer
&
aRing
BlockIndex
aBlockIndex
)
:
BufferReader
(
aRing
.
mBuffer
.
ReaderAt
(
Index
(
aBlockIndex
)
)
)
mRing
(
WrapNotNull
(
&
aRing
)
)
mEntryBytes
(
BufferReader
:
:
ReadULEB128
<
Length
>
(
)
)
mEntryStart
(
CurrentIndex
(
)
)
{
}
NotNull
<
const
BlocksRingBuffer
*
>
mRing
;
Length
mEntryBytes
;
Index
mEntryStart
;
}
;
class
Reader
;
class
BlockIterator
{
public
:
bool
operator
=
=
(
const
BlockIterator
aRhs
)
const
{
MOZ_ASSERT
(
mRing
=
=
aRhs
.
mRing
)
;
return
mBlockIndex
=
=
aRhs
.
mBlockIndex
;
}
bool
operator
!
=
(
const
BlockIterator
aRhs
)
const
{
MOZ_ASSERT
(
mRing
=
=
aRhs
.
mRing
)
;
return
mBlockIndex
!
=
aRhs
.
mBlockIndex
;
}
BlockIterator
&
operator
+
+
(
)
{
mBlockIndex
=
NextBlockIndex
(
)
;
return
*
this
;
}
EntryReader
operator
*
(
)
const
{
return
mRing
-
>
ReaderInBlockAt
(
mBlockIndex
)
;
}
bool
IsAtEnd
(
)
const
{
MOZ_ASSERT
(
mBlockIndex
<
=
BufferRangeEnd
(
)
)
;
return
mBlockIndex
=
=
BufferRangeEnd
(
)
;
}
BlockIndex
CurrentBlockIndex
(
)
const
{
return
mBlockIndex
;
}
BlockIndex
NextBlockIndex
(
)
const
{
MOZ_ASSERT
(
~
IsAtEnd
(
)
)
;
BufferReader
reader
=
mRing
-
>
mBuffer
.
ReaderAt
(
Index
(
mBlockIndex
)
)
;
Length
entrySize
=
reader
.
ReadULEB128
<
Length
>
(
)
;
return
BlockIndex
(
reader
.
CurrentIndex
(
)
+
entrySize
)
;
}
BlockIndex
BufferRangeStart
(
)
const
{
return
mRing
-
>
mFirstReadIndex
;
}
BlockIndex
BufferRangeEnd
(
)
const
{
return
mRing
-
>
mNextWriteIndex
;
}
private
:
friend
class
Reader
;
BlockIterator
(
const
BlocksRingBuffer
&
aRing
BlockIndex
aBlockIndex
)
:
mRing
(
WrapNotNull
(
&
aRing
)
)
mBlockIndex
(
aBlockIndex
)
{
}
NotNull
<
const
BlocksRingBuffer
*
>
mRing
;
BlockIndex
mBlockIndex
;
}
;
class
Reader
{
public
:
BlockIndex
BufferRangeStart
(
)
const
{
return
mRing
-
>
mFirstReadIndex
;
}
BlockIndex
BufferRangeEnd
(
)
const
{
return
mRing
-
>
mNextWriteIndex
;
}
BlockIterator
begin
(
)
const
{
return
BlockIterator
(
*
mRing
BufferRangeStart
(
)
)
;
}
BlockIterator
end
(
)
const
{
return
BlockIterator
(
*
mRing
BufferRangeEnd
(
)
)
;
}
template
<
typename
Callback
>
void
ForEach
(
Callback
&
&
aCallback
)
const
{
for
(
auto
it
:
*
this
)
{
aCallback
(
it
)
;
}
}
private
:
friend
class
BlocksRingBuffer
;
explicit
Reader
(
const
BlocksRingBuffer
&
aRing
)
:
mRing
(
WrapNotNull
(
&
aRing
)
)
{
}
NotNull
<
const
BlocksRingBuffer
*
>
mRing
;
}
;
template
<
typename
Callback
>
auto
Read
(
Callback
&
&
aCallback
)
const
{
RBAutoLock
lock
(
*
this
)
;
return
std
:
:
forward
<
Callback
>
(
aCallback
)
(
Reader
(
*
this
)
)
;
}
template
<
typename
Callback
>
void
ReadEach
(
Callback
&
&
aCallback
)
const
{
Read
(
[
&
]
(
const
Reader
&
aReader
)
{
aReader
.
ForEach
(
aCallback
)
;
}
)
;
}
template
<
typename
Callback
>
auto
ReadAt
(
BlockIndex
aBlockIndex
Callback
&
&
aCallback
)
const
{
RBAutoLock
lock
(
*
this
)
;
MOZ_ASSERT
(
aBlockIndex
<
=
mNextWriteIndex
)
;
Maybe
<
EntryReader
>
maybeReader
;
if
(
aBlockIndex
>
=
mFirstReadIndex
&
&
aBlockIndex
<
mNextWriteIndex
)
{
AssertBlockIndexIsValid
(
aBlockIndex
)
;
maybeReader
=
Some
(
ReaderInBlockAt
(
aBlockIndex
)
)
;
}
return
std
:
:
forward
<
Callback
>
(
aCallback
)
(
std
:
:
move
(
maybeReader
)
)
;
}
class
EntryReserver
;
class
EntryWriter
:
public
BufferWriter
{
public
:
Length
EntryBytes
(
)
const
{
return
mEntryBytes
;
}
Length
IndexInEntry
(
)
const
{
return
static_cast
<
Length
>
(
CurrentIndex
(
)
-
mEntryStart
)
;
}
Length
RemainingBytes
(
)
const
{
return
static_cast
<
Length
>
(
mEntryStart
+
mEntryBytes
-
CurrentIndex
(
)
)
;
}
BlockIndex
CurrentBlockIndex
(
)
const
{
return
BlockIndex
(
mEntryStart
-
BufferWriter
:
:
ULEB128Size
(
mEntryBytes
)
)
;
}
BlockIndex
BlockEndIndex
(
)
const
{
return
BlockIndex
(
mEntryStart
+
mEntryBytes
)
;
}
BlockIndex
BufferRangeStart
(
)
const
{
return
mRing
-
>
mFirstReadIndex
;
}
BlockIndex
BufferRangeEnd
(
)
const
{
return
mRing
-
>
mNextWriteIndex
;
}
Maybe
<
EntryReader
>
GetEntryAt
(
BlockIndex
aBlockIndex
)
{
MOZ_RELEASE_ASSERT
(
aBlockIndex
<
BufferRangeEnd
(
)
)
;
if
(
aBlockIndex
>
=
BufferRangeStart
(
)
)
{
mRing
-
>
AssertBlockIndexIsValid
(
aBlockIndex
)
;
return
Some
(
EntryReader
(
*
mRing
aBlockIndex
)
)
;
}
return
Nothing
(
)
;
}
private
:
friend
class
EntryReserver
;
static
Length
BlockSizeForEntrySize
(
Length
aEntryBytes
)
{
return
aEntryBytes
+
static_cast
<
Length
>
(
BufferWriter
:
:
ULEB128Size
(
aEntryBytes
)
)
;
}
EntryWriter
(
BlocksRingBuffer
&
aRing
BlockIndex
aBlockIndex
Length
aEntryBytes
)
:
BufferWriter
(
aRing
.
mBuffer
.
WriterAt
(
Index
(
aBlockIndex
)
)
)
mRing
(
WrapNotNull
(
&
aRing
)
)
mEntryBytes
(
aEntryBytes
)
mEntryStart
(
[
&
]
(
)
{
BufferWriter
:
:
WriteULEB128
(
aEntryBytes
)
;
return
CurrentIndex
(
)
;
}
(
)
)
{
}
~
EntryWriter
(
)
{
MOZ_ASSERT
(
RemainingBytes
(
)
=
=
0
)
;
}
NotNull
<
BlocksRingBuffer
*
>
mRing
;
Length
mEntryBytes
;
Index
mEntryStart
;
}
;
class
EntryReserver
{
public
:
template
<
typename
Callback
>
auto
Reserve
(
Length
aBytes
Callback
&
&
aCallback
)
{
MOZ_RELEASE_ASSERT
(
aBytes
<
mRing
-
>
BufferLength
(
)
.
Value
(
)
/
2
)
;
const
Length
blockBytes
=
EntryWriter
:
:
BlockSizeForEntrySize
(
aBytes
)
;
const
BlockIndex
blockIndex
=
mRing
-
>
mNextWriteIndex
;
const
Index
blockEnd
=
Index
(
blockIndex
)
+
blockBytes
;
mRing
-
>
mNextWriteIndex
=
BlockIndex
(
blockEnd
)
;
while
(
blockEnd
>
Index
(
mRing
-
>
mFirstReadIndex
)
+
mRing
-
>
BufferLength
(
)
.
Value
(
)
)
{
EntryReader
reader
=
mRing
-
>
ReaderInBlockAt
(
mRing
-
>
mFirstReadIndex
)
;
if
(
mRing
-
>
mDeleter
)
{
mRing
-
>
mDeleter
(
reader
)
;
}
mRing
-
>
mDeletedBlockCount
+
=
1
;
MOZ_ASSERT
(
reader
.
CurrentIndex
(
)
<
=
Index
(
reader
.
NextBlockIndex
(
)
)
)
;
mRing
-
>
mFirstReadIndex
=
reader
.
NextBlockIndex
(
)
;
}
mRing
-
>
mPushedBlockCount
+
=
1
;
return
std
:
:
forward
<
Callback
>
(
aCallback
)
(
EntryWriter
(
*
mRing
blockIndex
aBytes
)
)
;
}
BlockIndex
Write
(
const
void
*
aSrc
Length
aBytes
)
{
return
Reserve
(
aBytes
[
&
]
(
EntryWriter
aEW
)
{
aEW
.
Write
(
aSrc
aBytes
)
;
return
aEW
.
CurrentBlockIndex
(
)
;
}
)
;
}
template
<
typename
T
>
BlockIndex
WriteObject
(
const
T
&
aOb
)
{
return
Write
(
&
aOb
sizeof
(
T
)
)
;
}
BlockIndex
BufferRangeStart
(
)
const
{
return
mRing
-
>
mFirstReadIndex
;
}
BlockIndex
BufferRangeEnd
(
)
const
{
return
mRing
-
>
mNextWriteIndex
;
}
Maybe
<
EntryReader
>
GetEntryAt
(
BlockIndex
aBlockIndex
)
{
MOZ_ASSERT
(
aBlockIndex
<
=
BufferRangeEnd
(
)
)
;
if
(
aBlockIndex
>
=
BufferRangeStart
(
)
&
&
aBlockIndex
<
BufferRangeEnd
(
)
)
{
mRing
-
>
AssertBlockIndexIsValid
(
aBlockIndex
)
;
return
Some
(
EntryReader
(
*
mRing
aBlockIndex
)
)
;
}
return
Nothing
(
)
;
}
private
:
friend
class
BlocksRingBuffer
;
explicit
EntryReserver
(
BlocksRingBuffer
&
aRing
)
:
mRing
(
WrapNotNull
(
&
aRing
)
)
{
}
NotNull
<
BlocksRingBuffer
*
>
mRing
;
}
;
template
<
typename
Callback
>
auto
Put
(
Callback
&
&
aCallback
)
{
RBAutoLock
lock
(
*
this
)
;
return
std
:
:
forward
<
Callback
>
(
aCallback
)
(
EntryReserver
(
*
this
)
)
;
}
template
<
typename
Callback
>
auto
Put
(
Length
aLength
Callback
&
&
aCallback
)
{
return
Put
(
[
&
]
(
EntryReserver
aER
)
{
return
aER
.
Reserve
(
aLength
std
:
:
forward
<
Callback
>
(
aCallback
)
)
;
}
)
;
}
BlockIndex
PutFrom
(
const
void
*
aSrc
Length
aBytes
)
{
return
Put
(
[
&
]
(
EntryReserver
aER
)
{
return
aER
.
Write
(
aSrc
aBytes
)
;
}
)
;
}
template
<
typename
T
>
BlockIndex
PutObject
(
const
T
&
aOb
)
{
return
Put
(
[
&
]
(
EntryReserver
aER
)
{
return
aER
.
WriteObject
<
T
>
(
aOb
)
;
}
)
;
}
void
Clear
(
)
{
RBAutoLock
lock
(
*
this
)
;
DeleteAllEntries
(
)
;
mFirstReadIndex
=
mNextWriteIndex
;
}
void
ClearBefore
(
BlockIndex
aBlockIndex
)
{
RBAutoLock
lock
(
*
this
)
;
MOZ_ASSERT
(
aBlockIndex
<
=
mNextWriteIndex
)
;
if
(
aBlockIndex
<
=
mFirstReadIndex
)
{
return
;
}
if
(
aBlockIndex
=
=
mNextWriteIndex
)
{
Clear
(
)
;
}
AssertBlockIndexIsValid
(
aBlockIndex
)
;
if
(
mDeleter
)
{
Reader
reader
(
*
this
)
;
BlockIterator
it
=
reader
.
begin
(
)
;
for
(
;
it
.
CurrentBlockIndex
(
)
<
aBlockIndex
;
+
+
it
)
{
MOZ_ASSERT
(
it
.
CurrentBlockIndex
(
)
<
reader
.
end
(
)
.
CurrentBlockIndex
(
)
)
;
mDeleter
(
*
it
)
;
mDeletedBlockCount
+
=
1
;
}
MOZ_ASSERT
(
it
.
CurrentBlockIndex
(
)
=
=
aBlockIndex
)
;
}
else
{
Reader
reader
(
*
this
)
;
BlockIterator
it
=
reader
.
begin
(
)
;
for
(
;
it
.
CurrentBlockIndex
(
)
<
aBlockIndex
;
+
+
it
)
{
MOZ_ASSERT
(
it
.
CurrentBlockIndex
(
)
<
reader
.
end
(
)
.
CurrentBlockIndex
(
)
)
;
mDeletedBlockCount
+
=
1
;
}
MOZ_ASSERT
(
it
.
CurrentBlockIndex
(
)
=
=
aBlockIndex
)
;
}
mFirstReadIndex
=
aBlockIndex
;
}
#
ifdef
DEBUG
void
Dump
(
)
const
{
using
ULL
=
unsigned
long
long
;
printf
(
"
start
=
%
llu
(
%
llu
)
end
=
%
llu
(
%
llu
)
-
"
ULL
(
Index
(
mFirstReadIndex
)
)
ULL
(
Index
(
mFirstReadIndex
)
&
(
BufferLength
(
)
.
Value
(
)
-
1
)
)
ULL
(
Index
(
mNextWriteIndex
)
)
ULL
(
Index
(
mNextWriteIndex
)
&
(
BufferLength
(
)
.
Value
(
)
-
1
)
)
)
;
mBuffer
.
Dump
(
)
;
}
#
endif
private
:
void
AssertBlockIndexIsValid
(
BlockIndex
aBlockIndex
)
const
{
#
ifdef
DEBUG
MOZ_ASSERT
(
aBlockIndex
>
=
mFirstReadIndex
)
;
MOZ_ASSERT
(
aBlockIndex
<
mNextWriteIndex
)
;
#
if
1
BufferReader
br
=
mBuffer
.
ReaderAt
(
Index
(
aBlockIndex
)
)
;
Length
entryBytes
=
br
.
ReadULEB128
<
Length
>
(
)
;
MOZ_ASSERT
(
entryBytes
>
0
)
;
MOZ_ASSERT
(
entryBytes
<
BufferLength
(
)
.
Value
(
)
/
2
)
;
MOZ_ASSERT
(
Index
(
aBlockIndex
)
+
BufferReader
:
:
ULEB128Size
(
entryBytes
)
+
entryBytes
<
=
Index
(
mNextWriteIndex
)
)
;
#
else
Reader
reader
(
*
this
)
;
BlockIterator
it
=
reader
.
begin
(
)
;
for
(
;
it
.
CurrentBlockIndex
(
)
<
aBlockIndex
;
+
+
it
)
{
MOZ_ASSERT
(
it
.
CurrentBlockIndex
(
)
<
reader
.
end
(
)
.
CurrentBlockIndex
(
)
)
;
}
MOZ_ASSERT
(
it
.
CurrentBlockIndex
(
)
=
=
aBlockIndex
)
;
#
endif
#
endif
}
EntryReader
ReaderInBlockAt
(
BlockIndex
aBlockIndex
)
const
{
MOZ_ASSERT
(
aBlockIndex
>
=
mFirstReadIndex
)
;
MOZ_ASSERT
(
aBlockIndex
<
mNextWriteIndex
)
;
return
EntryReader
(
*
this
aBlockIndex
)
;
}
void
DeleteAllEntries
(
)
{
if
(
mDeleter
)
{
Reader
(
*
this
)
.
ForEach
(
[
this
]
(
EntryReader
aReader
)
{
mDeleter
(
aReader
)
;
}
)
;
}
mDeletedBlockCount
=
mPushedBlockCount
;
}
class
RBMutex
:
private
mozilla
:
:
detail
:
:
MutexImpl
{
public
:
RBMutex
(
)
:
mozilla
:
:
detail
:
:
MutexImpl
(
mozilla
:
:
recordreplay
:
:
Behavior
:
:
DontPreserve
)
{
}
void
Lock
(
)
{
mozilla
:
:
detail
:
:
MutexImpl
:
:
lock
(
)
;
}
void
Unlock
(
)
{
mozilla
:
:
detail
:
:
MutexImpl
:
:
unlock
(
)
;
}
}
;
class
MOZ_RAII
RBAutoLock
{
public
:
explicit
RBAutoLock
(
const
BlocksRingBuffer
&
aBuffer
)
:
mBuffer
(
aBuffer
)
{
mBuffer
.
mMutex
.
Lock
(
)
;
}
~
RBAutoLock
(
)
{
mBuffer
.
mMutex
.
Unlock
(
)
;
}
private
:
const
BlocksRingBuffer
&
mBuffer
;
}
;
mutable
RBMutex
mMutex
;
Buffer
mBuffer
;
BlockIndex
mFirstReadIndex
=
BlockIndex
(
Index
(
0
)
)
;
BlockIndex
mNextWriteIndex
=
BlockIndex
(
Index
(
0
)
)
;
std
:
:
function
<
void
(
EntryReader
)
>
mDeleter
;
uint64_t
mPushedBlockCount
=
0
;
uint64_t
mDeletedBlockCount
=
0
;
}
;
}
#
endif
