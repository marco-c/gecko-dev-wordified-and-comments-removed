#
ifndef
BlocksRingBuffer_h
#
define
BlocksRingBuffer_h
#
include
"
mozilla
/
BaseProfilerDetail
.
h
"
#
include
"
mozilla
/
ModuloBuffer
.
h
"
#
include
"
mozilla
/
ProfileBufferIndex
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
<
functional
>
#
include
<
string
>
#
include
<
tuple
>
#
include
<
utility
>
namespace
mozilla
{
class
BlocksRingBuffer
{
public
:
using
Buffer
=
ModuloBuffer
<
uint32_t
ProfileBufferIndex
>
;
using
Byte
=
Buffer
:
:
Byte
;
using
Length
=
uint32_t
;
enum
class
ThreadSafety
{
WithoutMutex
WithMutex
}
;
explicit
BlocksRingBuffer
(
ThreadSafety
aThreadSafety
)
:
mMutex
(
aThreadSafety
!
=
ThreadSafety
:
:
WithoutMutex
)
{
}
explicit
BlocksRingBuffer
(
ThreadSafety
aThreadSafety
PowerOfTwo
<
Length
>
aLength
)
:
mMutex
(
aThreadSafety
!
=
ThreadSafety
:
:
WithoutMutex
)
mMaybeUnderlyingBuffer
(
Some
(
UnderlyingBuffer
(
aLength
)
)
)
{
}
BlocksRingBuffer
(
ThreadSafety
aThreadSafety
UniquePtr
<
Buffer
:
:
Byte
[
]
>
aExistingBuffer
PowerOfTwo
<
Length
>
aLength
)
:
mMutex
(
aThreadSafety
!
=
ThreadSafety
:
:
WithoutMutex
)
mMaybeUnderlyingBuffer
(
Some
(
UnderlyingBuffer
(
std
:
:
move
(
aExistingBuffer
)
aLength
)
)
)
{
}
BlocksRingBuffer
(
ThreadSafety
aThreadSafety
Buffer
:
:
Byte
*
aExternalBuffer
PowerOfTwo
<
Length
>
aLength
)
:
mMutex
(
aThreadSafety
!
=
ThreadSafety
:
:
WithoutMutex
)
mMaybeUnderlyingBuffer
(
Some
(
UnderlyingBuffer
(
aExternalBuffer
aLength
)
)
)
{
}
~
BlocksRingBuffer
(
)
=
default
;
void
Reset
(
)
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
ResetUnderlyingBuffer
(
)
;
}
void
Set
(
PowerOfTwo
<
Length
>
aLength
)
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
ResetUnderlyingBuffer
(
)
;
mMaybeUnderlyingBuffer
.
emplace
(
aLength
)
;
}
void
Set
(
UniquePtr
<
Buffer
:
:
Byte
[
]
>
aExistingBuffer
PowerOfTwo
<
Length
>
aLength
)
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
ResetUnderlyingBuffer
(
)
;
mMaybeUnderlyingBuffer
.
emplace
(
std
:
:
move
(
aExistingBuffer
)
aLength
)
;
}
void
Set
(
Buffer
:
:
Byte
*
aExternalBuffer
PowerOfTwo
<
Length
>
aLength
)
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
ResetUnderlyingBuffer
(
)
;
mMaybeUnderlyingBuffer
.
emplace
(
aExternalBuffer
aLength
)
;
}
bool
IsThreadSafe
(
)
const
{
return
mMutex
.
IsActivated
(
)
;
}
[
[
nodiscard
]
]
bool
IsInSession
(
)
const
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
return
!
!
mMaybeUnderlyingBuffer
;
}
template
<
typename
Callback
>
auto
LockAndRun
(
Callback
&
&
aCallback
)
const
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
return
std
:
:
forward
<
Callback
>
(
aCallback
)
(
)
;
}
Maybe
<
PowerOfTwo
<
Length
>
>
BufferLength
(
)
const
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
return
mMaybeUnderlyingBuffer
.
map
(
[
]
(
const
UnderlyingBuffer
&
aBuffer
)
{
return
aBuffer
.
mBuffer
.
BufferLength
(
)
;
}
)
;
;
}
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
if
(
!
mMaybeUnderlyingBuffer
)
{
return
0
;
}
return
mMaybeUnderlyingBuffer
-
>
mBuffer
.
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
struct
State
{
ProfileBufferBlockIndex
mRangeStart
;
ProfileBufferBlockIndex
mRangeEnd
;
uint64_t
mPushedBlockCount
=
0
;
uint64_t
mClearedBlockCount
=
0
;
}
;
State
GetState
(
)
const
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
return
{
mFirstReadIndex
mNextWriteIndex
mMaybeUnderlyingBuffer
?
mMaybeUnderlyingBuffer
-
>
mPushedBlockCount
:
0
mMaybeUnderlyingBuffer
?
mMaybeUnderlyingBuffer
-
>
mClearedBlockCount
:
0
}
;
}
class
Reader
;
class
BlockIterator
{
public
:
#
ifdef
DEBUG
~
BlockIterator
(
)
{
mRing
-
>
mMutex
.
AssertCurrentThreadOwns
(
)
;
}
#
endif
bool
operator
=
=
(
const
BlockIterator
aRhs
)
const
{
MOZ_ASSERT
(
mRing
=
=
aRhs
.
mRing
)
;
return
mBlockIndex
=
=
aRhs
.
mBlockIndex
;
}
bool
operator
!
=
(
const
BlockIterator
aRhs
)
const
{
MOZ_ASSERT
(
mRing
=
=
aRhs
.
mRing
)
;
return
mBlockIndex
!
=
aRhs
.
mBlockIndex
;
}
BlockIterator
&
operator
+
+
(
)
{
mBlockIndex
=
NextBlockIndex
(
)
;
return
*
this
;
}
ProfileBufferEntryReader
operator
*
(
)
const
{
return
mRing
-
>
ReaderInBlockAt
(
mBlockIndex
)
;
}
bool
IsAtEnd
(
)
const
{
MOZ_ASSERT
(
mBlockIndex
<
=
BufferRangeEnd
(
)
)
;
return
mBlockIndex
=
=
BufferRangeEnd
(
)
;
}
ProfileBufferBlockIndex
CurrentBlockIndex
(
)
const
{
return
mBlockIndex
;
}
ProfileBufferBlockIndex
NextBlockIndex
(
)
const
{
MOZ_ASSERT
(
!
IsAtEnd
(
)
)
;
const
Length
entrySize
=
mRing
-
>
ReaderInBlockAt
(
mBlockIndex
)
.
RemainingBytes
(
)
;
return
ProfileBufferBlockIndex
:
:
CreateFromProfileBufferIndex
(
mBlockIndex
.
ConvertToProfileBufferIndex
(
)
+
ULEB128Size
(
entrySize
)
+
entrySize
)
;
}
ProfileBufferBlockIndex
BufferRangeStart
(
)
const
{
return
mRing
-
>
mFirstReadIndex
;
}
ProfileBufferBlockIndex
BufferRangeEnd
(
)
const
{
return
mRing
-
>
mNextWriteIndex
;
}
private
:
friend
class
Reader
;
BlockIterator
(
const
BlocksRingBuffer
&
aRing
ProfileBufferBlockIndex
aBlockIndex
)
:
mRing
(
WrapNotNull
(
&
aRing
)
)
mBlockIndex
(
aBlockIndex
)
{
mRing
-
>
mMutex
.
AssertCurrentThreadOwns
(
)
;
}
NotNull
<
const
BlocksRingBuffer
*
>
mRing
;
ProfileBufferBlockIndex
mBlockIndex
;
}
;
class
MOZ_RAII
Reader
{
public
:
Reader
(
const
Reader
&
)
=
delete
;
Reader
&
operator
=
(
const
Reader
&
)
=
delete
;
Reader
(
Reader
&
&
)
=
delete
;
Reader
&
operator
=
(
Reader
&
&
)
=
delete
;
#
ifdef
DEBUG
~
Reader
(
)
{
mRing
.
mMutex
.
AssertCurrentThreadOwns
(
)
;
}
#
endif
ProfileBufferBlockIndex
BufferRangeStart
(
)
const
{
return
mRing
.
mFirstReadIndex
;
}
ProfileBufferBlockIndex
BufferRangeEnd
(
)
const
{
return
mRing
.
mNextWriteIndex
;
}
BlockIterator
begin
(
)
const
{
return
BlockIterator
(
mRing
BufferRangeStart
(
)
)
;
}
BlockIterator
end
(
)
const
{
return
BlockIterator
(
mRing
BufferRangeEnd
(
)
)
;
}
BlockIterator
At
(
ProfileBufferBlockIndex
aBlockIndex
)
const
{
if
(
aBlockIndex
<
BufferRangeStart
(
)
)
{
return
begin
(
)
;
}
mRing
.
AssertBlockIndexIsValidOrEnd
(
aBlockIndex
)
;
return
BlockIterator
(
mRing
aBlockIndex
)
;
}
template
<
typename
Callback
>
void
ForEach
(
Callback
&
&
aCallback
)
const
{
for
(
ProfileBufferEntryReader
reader
:
*
this
)
{
aCallback
(
reader
)
;
}
}
private
:
friend
class
BlocksRingBuffer
;
explicit
Reader
(
const
BlocksRingBuffer
&
aRing
)
:
mRing
(
aRing
)
{
mRing
.
mMutex
.
AssertCurrentThreadOwns
(
)
;
}
const
BlocksRingBuffer
&
mRing
;
}
;
template
<
typename
Callback
>
auto
Read
(
Callback
&
&
aCallback
)
const
{
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
if
(
MOZ_LIKELY
(
mMaybeUnderlyingBuffer
)
)
{
Reader
reader
(
*
this
)
;
return
std
:
:
forward
<
Callback
>
(
aCallback
)
(
&
reader
)
;
}
}
return
std
:
:
forward
<
Callback
>
(
aCallback
)
(
nullptr
)
;
}
template
<
typename
Callback
>
void
ReadEach
(
Callback
&
&
aCallback
)
const
{
Read
(
[
&
]
(
Reader
*
aReader
)
{
if
(
MOZ_LIKELY
(
aReader
)
)
{
aReader
-
>
ForEach
(
aCallback
)
;
}
}
)
;
}
template
<
typename
Callback
>
auto
ReadAt
(
ProfileBufferBlockIndex
aBlockIndex
Callback
&
&
aCallback
)
const
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
MOZ_ASSERT
(
aBlockIndex
<
=
mNextWriteIndex
)
;
Maybe
<
ProfileBufferEntryReader
>
maybeEntryReader
;
if
(
MOZ_LIKELY
(
mMaybeUnderlyingBuffer
)
&
&
aBlockIndex
>
=
mFirstReadIndex
&
&
aBlockIndex
<
mNextWriteIndex
)
{
AssertBlockIndexIsValid
(
aBlockIndex
)
;
maybeEntryReader
.
emplace
(
ReaderInBlockAt
(
aBlockIndex
)
)
;
}
return
std
:
:
forward
<
Callback
>
(
aCallback
)
(
std
:
:
move
(
maybeEntryReader
)
)
;
}
template
<
typename
CallbackBytes
typename
Callback
>
auto
ReserveAndPut
(
CallbackBytes
aCallbackBytes
Callback
&
&
aCallback
)
{
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
if
(
MOZ_LIKELY
(
mMaybeUnderlyingBuffer
)
)
{
const
Length
entryBytes
=
std
:
:
forward
<
CallbackBytes
>
(
aCallbackBytes
)
(
)
;
const
Length
bufferBytes
=
mMaybeUnderlyingBuffer
-
>
mBuffer
.
BufferLength
(
)
.
Value
(
)
;
MOZ_RELEASE_ASSERT
(
entryBytes
<
=
bufferBytes
-
ULEB128Size
(
entryBytes
)
"
Entry
would
wrap
and
overwrite
itself
"
)
;
const
Length
blockBytes
=
ULEB128Size
(
entryBytes
)
+
entryBytes
;
const
ProfileBufferIndex
blockIndex
=
mNextWriteIndex
.
ConvertToProfileBufferIndex
(
)
;
const
ProfileBufferIndex
blockEnd
=
blockIndex
+
blockBytes
;
while
(
blockEnd
>
mFirstReadIndex
.
ConvertToProfileBufferIndex
(
)
+
bufferBytes
)
{
ProfileBufferEntryReader
reader
=
ReaderInBlockAt
(
mFirstReadIndex
)
;
mMaybeUnderlyingBuffer
-
>
mClearedBlockCount
+
=
1
;
mFirstReadIndex
=
ProfileBufferBlockIndex
:
:
CreateFromProfileBufferIndex
(
mFirstReadIndex
.
ConvertToProfileBufferIndex
(
)
+
ULEB128Size
(
reader
.
RemainingBytes
(
)
)
+
reader
.
RemainingBytes
(
)
)
;
}
mNextWriteIndex
=
ProfileBufferBlockIndex
:
:
CreateFromProfileBufferIndex
(
blockEnd
)
;
mMaybeUnderlyingBuffer
-
>
mPushedBlockCount
+
=
1
;
ProfileBufferEntryWriter
entryWriter
=
mMaybeUnderlyingBuffer
-
>
mBuffer
.
EntryWriterFromTo
(
blockIndex
blockEnd
)
;
entryWriter
.
WriteULEB128
(
entryBytes
)
;
MOZ_ASSERT
(
entryWriter
.
RemainingBytes
(
)
=
=
entryBytes
)
;
#
ifdef
DEBUG
auto
checkAllWritten
=
MakeScopeExit
(
[
&
]
(
)
{
MOZ_ASSERT
(
entryWriter
.
RemainingBytes
(
)
=
=
0
)
;
}
)
;
#
endif
return
std
:
:
forward
<
Callback
>
(
aCallback
)
(
&
entryWriter
)
;
}
}
return
std
:
:
forward
<
Callback
>
(
aCallback
)
(
nullptr
)
;
}
template
<
typename
Callback
>
auto
Put
(
Length
aBytes
Callback
&
&
aCallback
)
{
return
ReserveAndPut
(
[
aBytes
]
(
)
{
return
aBytes
;
}
std
:
:
forward
<
Callback
>
(
aCallback
)
)
;
}
ProfileBufferBlockIndex
PutFrom
(
const
void
*
aSrc
Length
aBytes
)
{
return
ReserveAndPut
(
[
aBytes
]
(
)
{
return
aBytes
;
}
[
&
]
(
ProfileBufferEntryWriter
*
aEntryWriter
)
{
if
(
MOZ_UNLIKELY
(
!
aEntryWriter
)
)
{
return
ProfileBufferBlockIndex
{
}
;
}
aEntryWriter
-
>
WriteBytes
(
aSrc
aBytes
)
;
return
aEntryWriter
-
>
CurrentBlockIndex
(
)
;
}
)
;
}
template
<
typename
.
.
.
Ts
>
ProfileBufferBlockIndex
PutObjects
(
const
Ts
&
.
.
.
aTs
)
{
static_assert
(
sizeof
.
.
.
(
Ts
)
>
0
"
PutObjects
must
be
given
at
least
one
object
.
"
)
;
return
ReserveAndPut
(
[
&
]
(
)
{
return
ProfileBufferEntryWriter
:
:
SumBytes
(
aTs
.
.
.
)
;
}
[
&
]
(
ProfileBufferEntryWriter
*
aEntryWriter
)
{
if
(
MOZ_UNLIKELY
(
!
aEntryWriter
)
)
{
return
ProfileBufferBlockIndex
{
}
;
}
aEntryWriter
-
>
WriteObjects
(
aTs
.
.
.
)
;
return
aEntryWriter
-
>
CurrentBlockIndex
(
)
;
}
)
;
}
template
<
typename
T
>
ProfileBufferBlockIndex
PutObject
(
const
T
&
aOb
)
{
return
PutObjects
(
aOb
)
;
}
ProfileBufferBlockIndex
AppendContents
(
const
BlocksRingBuffer
&
aSrc
)
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
if
(
MOZ_UNLIKELY
(
!
mMaybeUnderlyingBuffer
)
)
{
return
ProfileBufferBlockIndex
{
}
;
}
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
srcLock
(
aSrc
.
mMutex
)
;
if
(
MOZ_UNLIKELY
(
!
aSrc
.
mMaybeUnderlyingBuffer
)
)
{
return
ProfileBufferBlockIndex
{
}
;
}
const
ProfileBufferIndex
srcStartIndex
=
aSrc
.
mFirstReadIndex
.
ConvertToProfileBufferIndex
(
)
;
const
ProfileBufferIndex
srcEndIndex
=
aSrc
.
mNextWriteIndex
.
ConvertToProfileBufferIndex
(
)
;
const
Length
bytesToCopy
=
static_cast
<
Length
>
(
srcEndIndex
-
srcStartIndex
)
;
if
(
MOZ_UNLIKELY
(
bytesToCopy
=
=
0
)
)
{
return
ProfileBufferBlockIndex
{
}
;
}
const
Length
bufferBytes
=
mMaybeUnderlyingBuffer
-
>
mBuffer
.
BufferLength
(
)
.
Value
(
)
;
MOZ_RELEASE_ASSERT
(
bytesToCopy
<
=
bufferBytes
"
Entry
would
wrap
and
overwrite
itself
"
)
;
const
ProfileBufferIndex
dstStartIndex
=
mNextWriteIndex
.
ConvertToProfileBufferIndex
(
)
;
const
ProfileBufferIndex
dstEndIndex
=
dstStartIndex
+
bytesToCopy
;
while
(
dstEndIndex
>
mFirstReadIndex
.
ConvertToProfileBufferIndex
(
)
+
bufferBytes
)
{
ProfileBufferEntryReader
reader
=
ReaderInBlockAt
(
mFirstReadIndex
)
;
mMaybeUnderlyingBuffer
-
>
mClearedBlockCount
+
=
1
;
mFirstReadIndex
=
ProfileBufferBlockIndex
:
:
CreateFromProfileBufferIndex
(
mFirstReadIndex
.
ConvertToProfileBufferIndex
(
)
+
ULEB128Size
(
reader
.
RemainingBytes
(
)
)
+
reader
.
RemainingBytes
(
)
)
;
}
mNextWriteIndex
=
ProfileBufferBlockIndex
:
:
CreateFromProfileBufferIndex
(
dstEndIndex
)
;
mMaybeUnderlyingBuffer
-
>
mPushedBlockCount
+
=
aSrc
.
mMaybeUnderlyingBuffer
-
>
mPushedBlockCount
-
aSrc
.
mMaybeUnderlyingBuffer
-
>
mClearedBlockCount
;
auto
reader
=
aSrc
.
mMaybeUnderlyingBuffer
-
>
mBuffer
.
EntryReaderFromTo
(
srcStartIndex
srcEndIndex
nullptr
nullptr
)
;
auto
writer
=
mMaybeUnderlyingBuffer
-
>
mBuffer
.
EntryWriterFromTo
(
dstStartIndex
dstEndIndex
)
;
writer
.
WriteFromReader
(
reader
bytesToCopy
)
;
return
ProfileBufferBlockIndex
:
:
CreateFromProfileBufferIndex
(
dstStartIndex
)
;
}
void
Clear
(
)
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
ClearAllEntries
(
)
;
}
void
ClearBefore
(
ProfileBufferBlockIndex
aBlockIndex
)
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
if
(
!
mMaybeUnderlyingBuffer
)
{
return
;
}
MOZ_ASSERT
(
aBlockIndex
<
=
mNextWriteIndex
)
;
if
(
aBlockIndex
<
=
mFirstReadIndex
)
{
return
;
}
if
(
aBlockIndex
=
=
mNextWriteIndex
)
{
ClearAllEntries
(
)
;
return
;
}
AssertBlockIndexIsValid
(
aBlockIndex
)
;
Reader
reader
(
*
this
)
;
BlockIterator
it
=
reader
.
begin
(
)
;
for
(
;
it
.
CurrentBlockIndex
(
)
<
aBlockIndex
;
+
+
it
)
{
MOZ_ASSERT
(
it
.
CurrentBlockIndex
(
)
<
reader
.
end
(
)
.
CurrentBlockIndex
(
)
)
;
mMaybeUnderlyingBuffer
-
>
mClearedBlockCount
+
=
1
;
}
MOZ_ASSERT
(
it
.
CurrentBlockIndex
(
)
=
=
aBlockIndex
)
;
mFirstReadIndex
=
aBlockIndex
;
}
#
ifdef
DEBUG
void
Dump
(
)
const
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
mMutex
)
;
if
(
!
mMaybeUnderlyingBuffer
)
{
printf
(
"
empty
BlocksRingBuffer
\
n
"
)
;
return
;
}
using
ULL
=
unsigned
long
long
;
printf
(
"
start
=
%
llu
(
%
llu
)
end
=
%
llu
(
%
llu
)
-
"
ULL
(
mFirstReadIndex
.
ConvertToProfileBufferIndex
(
)
)
ULL
(
mFirstReadIndex
.
ConvertToProfileBufferIndex
(
)
&
(
mMaybeUnderlyingBuffer
-
>
mBuffer
.
BufferLength
(
)
.
Value
(
)
-
1
)
)
ULL
(
mNextWriteIndex
.
ConvertToProfileBufferIndex
(
)
)
ULL
(
mNextWriteIndex
.
ConvertToProfileBufferIndex
(
)
&
(
mMaybeUnderlyingBuffer
-
>
mBuffer
.
BufferLength
(
)
.
Value
(
)
-
1
)
)
)
;
mMaybeUnderlyingBuffer
-
>
mBuffer
.
Dump
(
)
;
}
#
endif
private
:
void
AssertBlockIndexIsValid
(
ProfileBufferBlockIndex
aBlockIndex
)
const
{
#
ifdef
DEBUG
mMutex
.
AssertCurrentThreadOwns
(
)
;
MOZ_ASSERT
(
aBlockIndex
>
=
mFirstReadIndex
)
;
MOZ_ASSERT
(
aBlockIndex
<
mNextWriteIndex
)
;
#
if
1
const
Length
entryBytes
=
ReaderInBlockAt
(
aBlockIndex
)
.
RemainingBytes
(
)
;
MOZ_ASSERT
(
entryBytes
>
0
"
Empty
entries
are
not
allowed
"
)
;
MOZ_ASSERT
(
entryBytes
<
mMaybeUnderlyingBuffer
-
>
mBuffer
.
BufferLength
(
)
.
Value
(
)
-
ULEB128Size
(
entryBytes
)
"
Entry
would
wrap
and
overwrite
itself
"
)
;
MOZ_ASSERT
(
aBlockIndex
.
ConvertToProfileBufferIndex
(
)
+
ULEB128Size
(
entryBytes
)
+
entryBytes
<
=
mNextWriteIndex
.
ConvertToProfileBufferIndex
(
)
)
;
#
else
Reader
reader
(
*
this
)
;
BlockIterator
it
=
reader
.
begin
(
)
;
for
(
;
it
.
CurrentBlockIndex
(
)
<
aBlockIndex
;
+
+
it
)
{
MOZ_ASSERT
(
it
.
CurrentBlockIndex
(
)
<
reader
.
end
(
)
.
CurrentBlockIndex
(
)
)
;
}
MOZ_ASSERT
(
it
.
CurrentBlockIndex
(
)
=
=
aBlockIndex
)
;
#
endif
#
endif
}
void
AssertBlockIndexIsValidOrEnd
(
ProfileBufferBlockIndex
aBlockIndex
)
const
{
#
ifdef
DEBUG
mMutex
.
AssertCurrentThreadOwns
(
)
;
if
(
aBlockIndex
=
=
mNextWriteIndex
)
{
return
;
}
AssertBlockIndexIsValid
(
aBlockIndex
)
;
#
endif
}
ProfileBufferEntryReader
ReaderInBlockAt
(
ProfileBufferBlockIndex
aBlockIndex
)
const
{
mMutex
.
AssertCurrentThreadOwns
(
)
;
MOZ_ASSERT
(
mMaybeUnderlyingBuffer
.
isSome
(
)
)
;
MOZ_ASSERT
(
aBlockIndex
>
=
mFirstReadIndex
)
;
MOZ_ASSERT
(
aBlockIndex
<
mNextWriteIndex
)
;
ProfileBufferEntryReader
reader
=
mMaybeUnderlyingBuffer
-
>
mBuffer
.
EntryReaderFromTo
(
aBlockIndex
.
ConvertToProfileBufferIndex
(
)
mNextWriteIndex
.
ConvertToProfileBufferIndex
(
)
nullptr
nullptr
)
;
const
Length
entryBytes
=
reader
.
ReadULEB128
<
Length
>
(
)
;
MOZ_RELEASE_ASSERT
(
entryBytes
<
=
reader
.
RemainingBytes
(
)
)
;
ProfileBufferIndex
nextBlockIndex
=
aBlockIndex
.
ConvertToProfileBufferIndex
(
)
+
ULEB128Size
(
entryBytes
)
+
entryBytes
;
reader
=
mMaybeUnderlyingBuffer
-
>
mBuffer
.
EntryReaderFromTo
(
aBlockIndex
.
ConvertToProfileBufferIndex
(
)
+
ULEB128Size
(
entryBytes
)
nextBlockIndex
aBlockIndex
(
nextBlockIndex
<
mNextWriteIndex
.
ConvertToProfileBufferIndex
(
)
)
?
ProfileBufferBlockIndex
:
:
CreateFromProfileBufferIndex
(
nextBlockIndex
)
:
ProfileBufferBlockIndex
{
}
)
;
return
reader
;
}
ProfileBufferEntryReader
FullBufferReader
(
)
const
{
mMutex
.
AssertCurrentThreadOwns
(
)
;
if
(
!
mMaybeUnderlyingBuffer
)
{
return
{
}
;
}
return
mMaybeUnderlyingBuffer
-
>
mBuffer
.
EntryReaderFromTo
(
mFirstReadIndex
.
ConvertToProfileBufferIndex
(
)
mNextWriteIndex
.
ConvertToProfileBufferIndex
(
)
nullptr
nullptr
)
;
}
void
ClearAllEntries
(
)
{
mMutex
.
AssertCurrentThreadOwns
(
)
;
if
(
!
mMaybeUnderlyingBuffer
)
{
return
;
}
mMaybeUnderlyingBuffer
-
>
mClearedBlockCount
=
mMaybeUnderlyingBuffer
-
>
mPushedBlockCount
;
mFirstReadIndex
=
mNextWriteIndex
;
}
void
ResetUnderlyingBuffer
(
)
{
mMutex
.
AssertCurrentThreadOwns
(
)
;
if
(
!
mMaybeUnderlyingBuffer
)
{
return
;
}
ClearAllEntries
(
)
;
mMaybeUnderlyingBuffer
.
reset
(
)
;
}
friend
ProfileBufferEntryWriter
:
:
Serializer
<
BlocksRingBuffer
>
;
friend
ProfileBufferEntryReader
:
:
Deserializer
<
BlocksRingBuffer
>
;
friend
ProfileBufferEntryWriter
:
:
Serializer
<
UniquePtr
<
BlocksRingBuffer
>
>
;
friend
ProfileBufferEntryReader
:
:
Deserializer
<
UniquePtr
<
BlocksRingBuffer
>
>
;
mutable
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeMutex
mMutex
;
struct
UnderlyingBuffer
{
explicit
UnderlyingBuffer
(
PowerOfTwo
<
Length
>
aLength
)
:
mBuffer
(
aLength
)
{
MOZ_ASSERT
(
aLength
.
Value
(
)
>
ULEB128MaxSize
<
Length
>
(
)
"
Buffer
should
be
able
to
contain
more
than
a
block
size
"
)
;
}
UnderlyingBuffer
(
UniquePtr
<
Buffer
:
:
Byte
[
]
>
aExistingBuffer
PowerOfTwo
<
Length
>
aLength
)
:
mBuffer
(
std
:
:
move
(
aExistingBuffer
)
aLength
)
{
MOZ_ASSERT
(
aLength
.
Value
(
)
>
ULEB128MaxSize
<
Length
>
(
)
"
Buffer
should
be
able
to
contain
more
than
a
block
size
"
)
;
}
UnderlyingBuffer
(
Buffer
:
:
Byte
*
aExternalBuffer
PowerOfTwo
<
Length
>
aLength
)
:
mBuffer
(
aExternalBuffer
aLength
)
{
MOZ_ASSERT
(
aLength
.
Value
(
)
>
ULEB128MaxSize
<
Length
>
(
)
"
Buffer
should
be
able
to
contain
more
than
a
block
size
"
)
;
}
UnderlyingBuffer
(
UnderlyingBuffer
&
&
)
=
default
;
UnderlyingBuffer
(
const
UnderlyingBuffer
&
)
=
delete
;
UnderlyingBuffer
&
operator
=
(
const
UnderlyingBuffer
&
)
=
delete
;
UnderlyingBuffer
&
operator
=
(
UnderlyingBuffer
&
&
)
=
delete
;
Buffer
mBuffer
;
uint64_t
mPushedBlockCount
=
0
;
uint64_t
mClearedBlockCount
=
0
;
}
;
Maybe
<
UnderlyingBuffer
>
mMaybeUnderlyingBuffer
;
ProfileBufferBlockIndex
mFirstReadIndex
=
ProfileBufferBlockIndex
:
:
CreateFromProfileBufferIndex
(
ProfileBufferIndex
(
1
)
)
;
ProfileBufferBlockIndex
mNextWriteIndex
=
ProfileBufferBlockIndex
:
:
CreateFromProfileBufferIndex
(
ProfileBufferIndex
(
1
)
)
;
}
;
template
<
>
struct
ProfileBufferEntryWriter
:
:
Serializer
<
BlocksRingBuffer
>
{
static
Length
Bytes
(
const
BlocksRingBuffer
&
aBuffer
)
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
aBuffer
.
mMutex
)
;
if
(
aBuffer
.
mMaybeUnderlyingBuffer
.
isNothing
(
)
)
{
return
ULEB128Size
<
Length
>
(
0
)
;
}
const
auto
start
=
aBuffer
.
mFirstReadIndex
.
ConvertToProfileBufferIndex
(
)
;
const
auto
end
=
aBuffer
.
mNextWriteIndex
.
ConvertToProfileBufferIndex
(
)
;
const
auto
len
=
end
-
start
;
if
(
len
=
=
0
)
{
return
ULEB128Size
<
Length
>
(
0
)
;
}
return
ULEB128Size
(
len
)
+
sizeof
(
start
)
+
sizeof
(
end
)
+
len
+
sizeof
(
aBuffer
.
mMaybeUnderlyingBuffer
-
>
mPushedBlockCount
)
+
sizeof
(
aBuffer
.
mMaybeUnderlyingBuffer
-
>
mClearedBlockCount
)
;
}
static
void
Write
(
ProfileBufferEntryWriter
&
aEW
const
BlocksRingBuffer
&
aBuffer
)
{
baseprofiler
:
:
detail
:
:
BaseProfilerMaybeAutoLock
lock
(
aBuffer
.
mMutex
)
;
if
(
aBuffer
.
mMaybeUnderlyingBuffer
.
isNothing
(
)
)
{
aEW
.
WriteULEB128
<
Length
>
(
0
)
;
return
;
}
const
auto
start
=
aBuffer
.
mFirstReadIndex
.
ConvertToProfileBufferIndex
(
)
;
const
auto
end
=
aBuffer
.
mNextWriteIndex
.
ConvertToProfileBufferIndex
(
)
;
MOZ_ASSERT
(
end
-
start
<
=
std
:
:
numeric_limits
<
Length
>
:
:
max
(
)
)
;
const
auto
len
=
static_cast
<
Length
>
(
end
-
start
)
;
if
(
len
=
=
0
)
{
aEW
.
WriteULEB128
<
Length
>
(
0
)
;
return
;
}
aEW
.
WriteULEB128
<
Length
>
(
len
)
;
aEW
.
WriteObject
(
start
)
;
aEW
.
WriteObject
(
end
)
;
auto
reader
=
aBuffer
.
FullBufferReader
(
)
;
aEW
.
WriteFromReader
(
reader
reader
.
RemainingBytes
(
)
)
;
aEW
.
WriteObject
(
aBuffer
.
mMaybeUnderlyingBuffer
-
>
mPushedBlockCount
)
;
aEW
.
WriteObject
(
aBuffer
.
mMaybeUnderlyingBuffer
-
>
mClearedBlockCount
)
;
}
}
;
template
<
>
struct
ProfileBufferEntryReader
:
:
Deserializer
<
BlocksRingBuffer
>
{
static
void
ReadInto
(
ProfileBufferEntryReader
&
aER
BlocksRingBuffer
&
aBuffer
)
{
MOZ_ASSERT
(
aBuffer
.
GetState
(
)
.
mRangeStart
=
=
aBuffer
.
GetState
(
)
.
mRangeEnd
)
;
const
auto
len
=
aER
.
ReadULEB128
<
Length
>
(
)
;
if
(
len
=
=
0
)
{
return
;
}
if
(
aBuffer
.
BufferLength
(
)
.
isSome
(
)
)
{
MOZ_RELEASE_ASSERT
(
aBuffer
.
BufferLength
(
)
-
>
Value
(
)
>
=
len
)
;
}
else
{
aBuffer
.
Set
(
PowerOfTwo
<
Length
>
(
len
)
)
;
MOZ_ASSERT
(
aBuffer
.
BufferLength
(
)
-
>
Value
(
)
>
=
len
)
;
}
const
auto
start
=
aER
.
ReadObject
<
ProfileBufferIndex
>
(
)
;
aBuffer
.
mFirstReadIndex
=
ProfileBufferBlockIndex
:
:
CreateFromProfileBufferIndex
(
start
)
;
const
auto
end
=
aER
.
ReadObject
<
ProfileBufferIndex
>
(
)
;
aBuffer
.
mNextWriteIndex
=
ProfileBufferBlockIndex
:
:
CreateFromProfileBufferIndex
(
end
)
;
MOZ_ASSERT
(
end
-
start
=
=
len
)
;
auto
writer
=
aBuffer
.
mMaybeUnderlyingBuffer
-
>
mBuffer
.
EntryWriterFromTo
(
start
end
)
;
writer
.
WriteFromReader
(
aER
end
-
start
)
;
MOZ_ASSERT
(
writer
.
RemainingBytes
(
)
=
=
0
)
;
aBuffer
.
mMaybeUnderlyingBuffer
-
>
mPushedBlockCount
=
aER
.
ReadObject
<
decltype
(
aBuffer
.
mMaybeUnderlyingBuffer
-
>
mPushedBlockCount
)
>
(
)
;
aBuffer
.
mMaybeUnderlyingBuffer
-
>
mClearedBlockCount
=
aER
.
ReadObject
<
decltype
(
aBuffer
.
mMaybeUnderlyingBuffer
-
>
mClearedBlockCount
)
>
(
)
;
}
static
BlocksRingBuffer
Read
(
ProfileBufferEntryReader
&
aER
)
=
delete
;
}
;
template
<
>
struct
ProfileBufferEntryWriter
:
:
Serializer
<
UniquePtr
<
BlocksRingBuffer
>
>
{
static
Length
Bytes
(
const
UniquePtr
<
BlocksRingBuffer
>
&
aBufferUPtr
)
{
if
(
!
aBufferUPtr
)
{
return
ULEB128Size
<
Length
>
(
0
)
;
}
return
SumBytes
(
*
aBufferUPtr
)
;
}
static
void
Write
(
ProfileBufferEntryWriter
&
aEW
const
UniquePtr
<
BlocksRingBuffer
>
&
aBufferUPtr
)
{
if
(
!
aBufferUPtr
)
{
aEW
.
WriteULEB128
<
Length
>
(
0
)
;
return
;
}
aEW
.
WriteObject
(
*
aBufferUPtr
)
;
}
}
;
template
<
>
struct
ProfileBufferEntryReader
:
:
Deserializer
<
UniquePtr
<
BlocksRingBuffer
>
>
{
static
void
ReadInto
(
ProfileBufferEntryReader
&
aER
UniquePtr
<
BlocksRingBuffer
>
&
aBuffer
)
{
aBuffer
=
Read
(
aER
)
;
}
static
UniquePtr
<
BlocksRingBuffer
>
Read
(
ProfileBufferEntryReader
&
aER
)
{
UniquePtr
<
BlocksRingBuffer
>
bufferUPtr
;
ProfileBufferEntryReader
readerBeforeLen
=
aER
;
const
auto
len
=
aER
.
ReadULEB128
<
Length
>
(
)
;
if
(
len
=
=
0
)
{
return
bufferUPtr
;
}
bufferUPtr
=
MakeUnique
<
BlocksRingBuffer
>
(
BlocksRingBuffer
:
:
ThreadSafety
:
:
WithoutMutex
)
;
aER
=
readerBeforeLen
;
aER
.
ReadIntoObject
(
*
bufferUPtr
)
;
return
bufferUPtr
;
}
}
;
}
#
endif
