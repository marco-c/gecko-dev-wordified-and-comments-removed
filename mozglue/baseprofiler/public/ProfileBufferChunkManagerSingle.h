#
ifndef
ProfileBufferChunkManagerSingle_h
#
define
ProfileBufferChunkManagerSingle_h
#
include
"
mozilla
/
ProfileBufferChunkManager
.
h
"
#
ifdef
DEBUG
#
include
"
mozilla
/
Atomics
.
h
"
#
endif
namespace
mozilla
{
class
ProfileBufferChunkManagerSingle
final
:
public
ProfileBufferChunkManager
{
public
:
using
Length
=
ProfileBufferChunk
:
:
Length
;
explicit
ProfileBufferChunkManagerSingle
(
UniquePtr
<
ProfileBufferChunk
>
aChunk
)
:
mInitialChunk
(
std
:
:
move
(
aChunk
)
)
mBufferBytes
(
mInitialChunk
?
mInitialChunk
-
>
BufferBytes
(
)
:
0
)
{
MOZ_ASSERT
(
!
mInitialChunk
|
|
!
mInitialChunk
-
>
GetNext
(
)
"
Expected
at
most
one
chunk
"
)
;
}
explicit
ProfileBufferChunkManagerSingle
(
Length
aChunkMinBufferBytes
)
:
mInitialChunk
(
ProfileBufferChunk
:
:
Create
(
aChunkMinBufferBytes
)
)
mBufferBytes
(
mInitialChunk
?
mInitialChunk
-
>
BufferBytes
(
)
:
0
)
{
}
#
ifdef
DEBUG
~
ProfileBufferChunkManagerSingle
(
)
{
MOZ_ASSERT
(
mVirtuallyLocked
=
=
false
)
;
}
#
endif
void
Reset
(
UniquePtr
<
ProfileBufferChunk
>
aPossibleChunk
)
{
if
(
aPossibleChunk
)
{
mInitialChunk
=
std
:
:
move
(
aPossibleChunk
)
;
mReleasedChunk
=
nullptr
;
}
else
if
(
!
mInitialChunk
)
{
MOZ_ASSERT
(
!
!
mReleasedChunk
"
Can
'
t
reset
properly
!
"
)
;
mInitialChunk
=
std
:
:
move
(
mReleasedChunk
)
;
}
if
(
mInitialChunk
)
{
mInitialChunk
-
>
MarkRecycled
(
)
;
mBufferBytes
=
mInitialChunk
-
>
BufferBytes
(
)
;
}
else
{
mBufferBytes
=
0
;
}
}
[
[
nodiscard
]
]
size_t
MaxTotalSize
(
)
const
final
{
return
mBufferBytes
;
}
[
[
nodiscard
]
]
UniquePtr
<
ProfileBufferChunk
>
GetChunk
(
)
final
{
MOZ_ASSERT
(
mUser
"
Not
registered
yet
"
)
;
return
std
:
:
move
(
mInitialChunk
)
;
}
void
RequestChunk
(
std
:
:
function
<
void
(
UniquePtr
<
ProfileBufferChunk
>
)
>
&
&
aChunkReceiver
)
final
{
MOZ_ASSERT
(
mUser
"
Not
registered
yet
"
)
;
std
:
:
move
(
aChunkReceiver
)
(
GetChunk
(
)
)
;
}
void
FulfillChunkRequests
(
)
final
{
}
void
ReleaseChunks
(
UniquePtr
<
ProfileBufferChunk
>
aChunks
)
final
{
MOZ_ASSERT
(
mUser
"
Not
registered
yet
"
)
;
MOZ_ASSERT
(
!
mReleasedChunk
"
Unexpected
2nd
released
chunk
"
)
;
MOZ_ASSERT
(
!
aChunks
-
>
GetNext
(
)
"
Only
expected
one
released
chunk
"
)
;
mReleasedChunk
=
std
:
:
move
(
aChunks
)
;
}
void
SetChunkDestroyedCallback
(
std
:
:
function
<
void
(
const
ProfileBufferChunk
&
)
>
&
&
aChunkDestroyedCallback
)
final
{
MOZ_ASSERT
(
mUser
"
Not
registered
yet
"
)
;
mChunkDestroyedCallback
=
std
:
:
move
(
aChunkDestroyedCallback
)
;
}
[
[
nodiscard
]
]
UniquePtr
<
ProfileBufferChunk
>
GetExtantReleasedChunks
(
)
final
{
MOZ_ASSERT
(
mUser
"
Not
registered
yet
"
)
;
return
std
:
:
move
(
mReleasedChunk
)
;
}
void
ForgetUnreleasedChunks
(
)
final
{
MOZ_ASSERT
(
mUser
"
Not
registered
yet
"
)
;
}
[
[
nodiscard
]
]
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
final
{
MOZ_ASSERT
(
mUser
"
Not
registered
yet
"
)
;
size_t
size
=
0
;
if
(
mInitialChunk
)
{
size
+
=
mInitialChunk
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
if
(
mReleasedChunk
)
{
size
+
=
mReleasedChunk
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
return
size
;
}
[
[
nodiscard
]
]
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
final
{
MOZ_ASSERT
(
mUser
"
Not
registered
yet
"
)
;
return
aMallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
protected
:
const
ProfileBufferChunk
*
PeekExtantReleasedChunksAndLock
(
)
final
{
MOZ_ASSERT
(
mVirtuallyLocked
.
compareExchange
(
false
true
)
)
;
MOZ_ASSERT
(
mUser
"
Not
registered
yet
"
)
;
return
mReleasedChunk
.
get
(
)
;
}
void
UnlockAfterPeekExtantReleasedChunks
(
)
final
{
MOZ_ASSERT
(
mVirtuallyLocked
.
compareExchange
(
true
false
)
)
;
}
private
:
UniquePtr
<
ProfileBufferChunk
>
mInitialChunk
;
UniquePtr
<
ProfileBufferChunk
>
mReleasedChunk
;
Length
mBufferBytes
;
std
:
:
function
<
void
(
const
ProfileBufferChunk
&
)
>
mChunkDestroyedCallback
;
#
ifdef
DEBUG
mutable
Atomic
<
bool
>
mVirtuallyLocked
{
false
}
;
#
endif
}
;
}
#
endif
