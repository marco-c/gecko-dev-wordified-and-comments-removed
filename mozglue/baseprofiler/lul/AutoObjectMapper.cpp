#
include
"
BaseProfiler
.
h
"
#
ifdef
MOZ_BASE_PROFILER
#
include
<
sys
/
mman
.
h
>
#
include
<
unistd
.
h
>
#
include
<
sys
/
types
.
h
>
#
include
<
sys
/
stat
.
h
>
#
include
<
fcntl
.
h
>
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
PlatformMacros
.
h
"
#
include
"
AutoObjectMapper
.
h
"
#
if
defined
(
MOZ_LINKER
)
#
include
<
dlfcn
.
h
>
#
include
"
mozilla
/
Types
.
h
"
#
if
defined
(
ANDROID
)
#
include
<
sys
/
system_properties
.
h
>
#
endif
extern
"
C
"
{
MFBT_API
size_t
__dl_get_mappable_length
(
void
*
handle
)
;
MFBT_API
void
*
__dl_mmap
(
void
*
handle
void
*
addr
size_t
length
off_t
offset
)
;
MFBT_API
void
__dl_munmap
(
void
*
handle
void
*
addr
size_t
length
)
;
}
#
endif
static
void
failedToMessage
(
void
(
*
aLog
)
(
const
char
*
)
const
char
*
aHowFailed
std
:
:
string
aFileName
)
{
char
buf
[
300
]
;
SprintfLiteral
(
buf
"
AutoObjectMapper
:
:
Map
:
Failed
to
%
s
\
'
%
s
\
'
"
aHowFailed
aFileName
.
c_str
(
)
)
;
buf
[
sizeof
(
buf
)
-
1
]
=
0
;
aLog
(
buf
)
;
}
AutoObjectMapperPOSIX
:
:
AutoObjectMapperPOSIX
(
void
(
*
aLog
)
(
const
char
*
)
)
:
mImage
(
nullptr
)
mSize
(
0
)
mLog
(
aLog
)
mIsMapped
(
false
)
{
}
AutoObjectMapperPOSIX
:
:
~
AutoObjectMapperPOSIX
(
)
{
if
(
!
mIsMapped
)
{
MOZ_ASSERT
(
!
mImage
)
;
MOZ_ASSERT
(
mSize
=
=
0
)
;
return
;
}
MOZ_ASSERT
(
mSize
>
0
)
;
MOZ_ASSERT
(
mImage
)
;
munmap
(
mImage
mSize
)
;
}
bool
AutoObjectMapperPOSIX
:
:
Map
(
void
*
*
start
size_t
*
length
std
:
:
string
fileName
)
{
MOZ_ASSERT
(
!
mIsMapped
)
;
int
fd
=
open
(
fileName
.
c_str
(
)
O_RDONLY
)
;
if
(
fd
=
=
-
1
)
{
failedToMessage
(
mLog
"
open
"
fileName
)
;
return
false
;
}
struct
stat
st
;
int
err
=
fstat
(
fd
&
st
)
;
size_t
sz
=
(
err
=
=
0
)
?
st
.
st_size
:
0
;
if
(
err
!
=
0
|
|
sz
=
=
0
)
{
failedToMessage
(
mLog
"
fstat
"
fileName
)
;
close
(
fd
)
;
return
false
;
}
void
*
image
=
mmap
(
nullptr
sz
PROT_READ
MAP_SHARED
fd
0
)
;
if
(
image
=
=
MAP_FAILED
)
{
failedToMessage
(
mLog
"
mmap
"
fileName
)
;
close
(
fd
)
;
return
false
;
}
close
(
fd
)
;
mIsMapped
=
true
;
mImage
=
*
start
=
image
;
mSize
=
*
length
=
sz
;
return
true
;
}
#
if
defined
(
MOZ_LINKER
)
#
if
defined
(
ANDROID
)
static
int
GetAndroidSDKVersion
(
)
{
static
int
version
=
0
;
if
(
version
)
{
return
version
;
}
char
version_string
[
PROP_VALUE_MAX
]
=
{
'
\
0
'
}
;
int
len
=
__system_property_get
(
"
ro
.
build
.
version
.
sdk
"
version_string
)
;
if
(
len
)
{
version
=
static_cast
<
int
>
(
strtol
(
version_string
nullptr
10
)
)
;
}
return
version
;
}
#
endif
AutoObjectMapperFaultyLib
:
:
AutoObjectMapperFaultyLib
(
void
(
*
aLog
)
(
const
char
*
)
)
:
AutoObjectMapperPOSIX
(
aLog
)
mHdl
(
nullptr
)
{
}
AutoObjectMapperFaultyLib
:
:
~
AutoObjectMapperFaultyLib
(
)
{
if
(
mHdl
)
{
MOZ_ASSERT
(
mSize
>
0
)
;
MOZ_ASSERT
(
mImage
)
;
__dl_munmap
(
mHdl
mImage
mSize
)
;
dlclose
(
mHdl
)
;
mImage
=
nullptr
;
mSize
=
0
;
}
}
bool
AutoObjectMapperFaultyLib
:
:
Map
(
void
*
*
start
size_t
*
length
std
:
:
string
fileName
)
{
MOZ_ASSERT
(
!
mHdl
)
;
#
if
defined
(
ANDROID
)
if
(
GetAndroidSDKVersion
(
)
>
=
23
)
{
return
AutoObjectMapperPOSIX
:
:
Map
(
start
length
fileName
)
;
}
#
endif
return
false
;
}
#
endif
#
endif
