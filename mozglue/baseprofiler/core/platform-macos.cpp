#
include
<
unistd
.
h
>
#
include
<
sys
/
mman
.
h
>
#
include
<
mach
/
mach_init
.
h
>
#
include
<
mach
-
o
/
getsect
.
h
>
#
include
<
AvailabilityMacros
.
h
>
#
include
<
pthread
.
h
>
#
include
<
semaphore
.
h
>
#
include
<
signal
.
h
>
#
include
<
libkern
/
OSAtomic
.
h
>
#
include
<
mach
/
mach
.
h
>
#
include
<
mach
/
semaphore
.
h
>
#
include
<
mach
/
task
.
h
>
#
include
<
mach
/
thread_act
.
h
>
#
include
<
mach
/
vm_statistics
.
h
>
#
include
<
sys
/
time
.
h
>
#
include
<
sys
/
resource
.
h
>
#
include
<
sys
/
syscall
.
h
>
#
include
<
sys
/
types
.
h
>
#
include
<
sys
/
sysctl
.
h
>
#
include
<
stdarg
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
string
.
h
>
#
include
<
errno
.
h
>
#
include
<
math
.
h
>
namespace
mozilla
{
namespace
baseprofiler
{
int
profiler_current_process_id
(
)
{
return
getpid
(
)
;
}
int
profiler_current_thread_id
(
)
{
return
static_cast
<
int
>
(
static_cast
<
pid_t
>
(
syscall
(
SYS_thread_selfid
)
)
)
;
}
static
int64_t
MicrosecondsSince1970
(
)
{
struct
timeval
tv
;
gettimeofday
(
&
tv
NULL
)
;
return
int64_t
(
tv
.
tv_sec
)
*
1000000
+
int64_t
(
tv
.
tv_usec
)
;
}
void
*
GetStackTop
(
void
*
aGuess
)
{
pthread_t
thread
=
pthread_self
(
)
;
return
pthread_get_stackaddr_np
(
thread
)
;
}
class
PlatformData
{
public
:
explicit
PlatformData
(
int
aThreadId
)
:
mProfiledThread
(
mach_thread_self
(
)
)
{
}
~
PlatformData
(
)
{
mach_port_deallocate
(
mach_task_self
(
)
mProfiledThread
)
;
}
thread_act_t
ProfiledThread
(
)
{
return
mProfiledThread
;
}
private
:
thread_act_t
mProfiledThread
;
}
;
Sampler
:
:
Sampler
(
PSLockRef
aLock
)
{
}
void
Sampler
:
:
Disable
(
PSLockRef
aLock
)
{
}
template
<
typename
Func
>
void
Sampler
:
:
SuspendAndSampleAndResumeThread
(
PSLockRef
aLock
const
RegisteredThread
&
aRegisteredThread
const
TimeStamp
&
aNow
const
Func
&
aProcessRegs
)
{
thread_act_t
samplee_thread
=
aRegisteredThread
.
GetPlatformData
(
)
-
>
ProfiledThread
(
)
;
if
(
KERN_SUCCESS
!
=
thread_suspend
(
samplee_thread
)
)
{
return
;
}
thread_state_flavor_t
flavor
=
x86_THREAD_STATE64
;
x86_thread_state64_t
state
;
mach_msg_type_number_t
count
=
x86_THREAD_STATE64_COUNT
;
#
if
__DARWIN_UNIX03
#
define
REGISTER_FIELD
(
name
)
__r
#
#
name
#
else
#
define
REGISTER_FIELD
(
name
)
r
#
#
name
#
endif
if
(
thread_get_state
(
samplee_thread
flavor
reinterpret_cast
<
natural_t
*
>
(
&
state
)
&
count
)
=
=
KERN_SUCCESS
)
{
Registers
regs
;
regs
.
mPC
=
reinterpret_cast
<
Address
>
(
state
.
REGISTER_FIELD
(
ip
)
)
;
regs
.
mSP
=
reinterpret_cast
<
Address
>
(
state
.
REGISTER_FIELD
(
sp
)
)
;
regs
.
mFP
=
reinterpret_cast
<
Address
>
(
state
.
REGISTER_FIELD
(
bp
)
)
;
regs
.
mLR
=
0
;
aProcessRegs
(
regs
aNow
)
;
}
#
undef
REGISTER_FIELD
thread_resume
(
samplee_thread
)
;
}
static
void
*
ThreadEntry
(
void
*
aArg
)
{
auto
thread
=
static_cast
<
SamplerThread
*
>
(
aArg
)
;
thread
-
>
Run
(
)
;
return
nullptr
;
}
SamplerThread
:
:
SamplerThread
(
PSLockRef
aLock
uint32_t
aActivityGeneration
double
aIntervalMilliseconds
)
:
mSampler
(
aLock
)
mActivityGeneration
(
aActivityGeneration
)
mIntervalMicroseconds
(
std
:
:
max
(
1
int
(
floor
(
aIntervalMilliseconds
*
1000
+
0
.
5
)
)
)
)
mThread
{
nullptr
}
{
pthread_attr_t
*
attr_ptr
=
nullptr
;
if
(
pthread_create
(
&
mThread
attr_ptr
ThreadEntry
this
)
!
=
0
)
{
MOZ_CRASH
(
"
pthread_create
failed
"
)
;
}
}
SamplerThread
:
:
~
SamplerThread
(
)
{
pthread_join
(
mThread
nullptr
)
;
}
void
SamplerThread
:
:
SleepMicro
(
uint32_t
aMicroseconds
)
{
usleep
(
aMicroseconds
)
;
}
void
SamplerThread
:
:
Stop
(
PSLockRef
aLock
)
{
mSampler
.
Disable
(
aLock
)
;
}
static
void
PlatformInit
(
PSLockRef
aLock
)
{
}
#
if
defined
(
HAVE_NATIVE_UNWIND
)
void
Registers
:
:
SyncPopulate
(
)
{
asm
(
"
leaq
0x10
(
%
%
rbp
)
%
0
\
n
\
t
"
"
movq
(
%
%
rbp
)
%
1
\
n
\
t
"
:
"
=
r
"
(
mSP
)
"
=
r
"
(
mFP
)
)
;
mPC
=
reinterpret_cast
<
Address
>
(
__builtin_extract_return_addr
(
__builtin_return_address
(
0
)
)
)
;
mLR
=
0
;
}
#
endif
}
}
