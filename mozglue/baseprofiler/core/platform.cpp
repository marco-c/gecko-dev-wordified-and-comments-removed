#
include
"
platform
.
h
"
#
include
<
algorithm
>
#
include
<
errno
.
h
>
#
include
<
fstream
>
#
include
<
ostream
>
#
include
<
set
>
#
include
<
sstream
>
#
include
<
string_view
>
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
AutoProfilerLabel
.
h
"
#
include
"
mozilla
/
BaseAndGeckoProfilerDetail
.
h
"
#
include
"
mozilla
/
BaseProfilerDetail
.
h
"
#
include
"
mozilla
/
DoubleConversion
.
h
"
#
include
"
mozilla
/
Printf
.
h
"
#
include
"
mozilla
/
ProfileBufferChunkManagerSingle
.
h
"
#
include
"
mozilla
/
ProfileBufferChunkManagerWithLocalLimit
.
h
"
#
include
"
mozilla
/
ProfileChunkedBuffer
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
mozilla
/
StackWalk
.
h
"
#
ifdef
XP_WIN
#
include
"
mozilla
/
StackWalkThread
.
h
"
#
endif
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
ThreadLocal
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
Tuple
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
prdtoa
.
h
"
#
include
"
prtime
.
h
"
#
include
"
BaseProfiler
.
h
"
#
include
"
BaseProfilingCategory
.
h
"
#
include
"
PageInformation
.
h
"
#
include
"
ProfiledThreadData
.
h
"
#
include
"
ProfilerBacktrace
.
h
"
#
include
"
ProfileBuffer
.
h
"
#
include
"
RegisteredThread
.
h
"
#
include
"
BaseProfilerSharedLibraries
.
h
"
#
include
"
ThreadInfo
.
h
"
#
include
"
VTuneProfiler
.
h
"
#
if
defined
(
GP_PLAT_x86_windows
)
#
define
HAVE_NATIVE_UNWIND
#
define
USE_FRAME_POINTER_STACK_WALK
#
endif
#
if
defined
(
GP_PLAT_amd64_windows
)
#
define
HAVE_NATIVE_UNWIND
#
define
USE_MOZ_STACK_WALK
#
endif
#
if
defined
(
GP_PLAT_arm64_windows
)
#
define
HAVE_NATIVE_UNWIND
#
define
USE_MOZ_STACK_WALK
#
endif
#
if
defined
(
GP_OS_darwin
)
#
define
HAVE_NATIVE_UNWIND
#
define
USE_FRAME_POINTER_STACK_WALK
#
endif
#
if
0
#
if
defined
(
GP_PLAT_arm_linux
)
|
|
defined
(
GP_PLAT_arm_android
)
#
define
HAVE_NATIVE_UNWIND
#
define
USE_EHABI_STACKWALK
#
include
"
EHABIStackWalk
.
h
"
#
endif
#
if
defined
(
GP_PLAT_amd64_linux
)
|
|
defined
(
GP_PLAT_x86_linux
)
|
|
\
defined
(
GP_PLAT_amd64_android
)
|
|
defined
(
GP_PLAT_x86_android
)
|
|
\
defined
(
GP_PLAT_mips64_linux
)
|
|
defined
(
GP_PLAT_arm64_linux
)
|
|
\
defined
(
GP_PLAT_arm64_android
)
|
|
defined
(
GP_PLAT_amd64_freebsd
)
|
|
\
defined
(
GP_PLAT_arm64_freebsd
)
#
define
HAVE_NATIVE_UNWIND
#
define
USE_LUL_STACKWALK
#
include
"
lul
/
LulMain
.
h
"
#
include
"
lul
/
platform
-
linux
-
lul
.
h
"
#
if
defined
(
MOZ_PROFILING
)
#
define
USE_FRAME_POINTER_STACK_WALK
#
endif
#
endif
#
endif
#
if
defined
(
USE_FRAME_POINTER_STACK_WALK
)
|
|
defined
(
USE_MOZ_STACK_WALK
)
#
define
HAVE_FASTINIT_NATIVE_UNWIND
#
endif
#
ifdef
MOZ_VALGRIND
#
include
<
valgrind
/
memcheck
.
h
>
#
else
#
define
VALGRIND_MAKE_MEM_DEFINED
(
_addr
_len
)
(
(
void
)
0
)
#
endif
#
if
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_android
)
|
|
defined
(
GP_OS_freebsd
)
#
include
<
ucontext
.
h
>
#
endif
namespace
mozilla
{
namespace
baseprofiler
{
using
detail
:
:
RacyFeatures
;
bool
LogTest
(
int
aLevelToTest
)
{
static
const
int
maxLevel
=
getenv
(
"
MOZ_BASE_PROFILER_VERBOSE_LOGGING
"
)
?
5
:
getenv
(
"
MOZ_BASE_PROFILER_DEBUG_LOGGING
"
)
?
4
:
getenv
(
"
MOZ_BASE_PROFILER_LOGGING
"
)
?
3
:
0
;
return
aLevelToTest
<
=
maxLevel
;
}
void
PrintToConsole
(
const
char
*
aFmt
.
.
.
)
{
va_list
args
;
va_start
(
args
aFmt
)
;
#
if
defined
(
ANDROID
)
__android_log_vprint
(
ANDROID_LOG_INFO
"
Gecko
"
aFmt
args
)
;
#
else
vfprintf
(
stderr
aFmt
args
)
;
#
endif
va_end
(
args
)
;
}
ProfileChunkedBuffer
&
profiler_get_core_buffer
(
)
{
static
ProfileChunkedBuffer
sProfileChunkedBuffer
{
ProfileChunkedBuffer
:
:
ThreadSafety
:
:
WithMutex
}
;
return
sProfileChunkedBuffer
;
}
Atomic
<
int
MemoryOrdering
:
:
Relaxed
>
gSkipSampling
;
constexpr
static
bool
ValidateFeatures
(
)
{
int
expectedFeatureNumber
=
0
;
#
define
CHECK_FEATURE
(
n_
str_
Name_
desc_
)
\
if
(
(
n_
)
!
=
expectedFeatureNumber
)
{
\
return
false
;
\
}
\
+
+
expectedFeatureNumber
;
BASE_PROFILER_FOR_EACH_FEATURE
(
CHECK_FEATURE
)
#
undef
CHECK_FEATURE
return
true
;
}
static_assert
(
ValidateFeatures
(
)
"
Feature
list
is
invalid
"
)
;
static
uint32_t
AvailableFeatures
(
)
{
uint32_t
features
=
0
;
#
define
ADD_FEATURE
(
n_
str_
Name_
desc_
)
\
ProfilerFeature
:
:
Set
#
#
Name_
(
features
)
;
BASE_PROFILER_FOR_EACH_FEATURE
(
ADD_FEATURE
)
#
undef
ADD_FEATURE
ProfilerFeature
:
:
ClearJava
(
features
)
;
ProfilerFeature
:
:
ClearJS
(
features
)
;
ProfilerFeature
:
:
ClearScreenshots
(
features
)
;
#
if
!
defined
(
HAVE_NATIVE_UNWIND
)
ProfilerFeature
:
:
ClearStackWalk
(
features
)
;
#
endif
#
if
!
defined
(
GP_OS_windows
)
ProfilerFeature
:
:
ClearNoTimerResolutionChange
(
features
)
;
#
endif
return
features
;
}
static
constexpr
uint32_t
DefaultFeatures
(
)
{
return
ProfilerFeature
:
:
Java
|
ProfilerFeature
:
:
JS
|
ProfilerFeature
:
:
StackWalk
|
ProfilerFeature
:
:
CPUUtilization
|
ProfilerFeature
:
:
ProcessCPU
;
}
static
constexpr
uint32_t
StartupExtraDefaultFeatures
(
)
{
return
ProfilerFeature
:
:
MainThreadIO
|
ProfilerFeature
:
:
IPCMessages
;
}
class
MOZ_RAII
PSAutoLock
{
public
:
PSAutoLock
(
)
:
mLock
(
gPSMutex
)
{
}
PSAutoLock
(
const
PSAutoLock
&
)
=
delete
;
void
operator
=
(
const
PSAutoLock
&
)
=
delete
;
[
[
nodiscard
]
]
static
bool
IsLockedOnCurrentThread
(
)
{
return
gPSMutex
.
IsLockedOnCurrentThread
(
)
;
}
private
:
static
detail
:
:
BaseProfilerMutex
gPSMutex
;
detail
:
:
BaseProfilerAutoLock
mLock
;
}
;
detail
:
:
BaseProfilerMutex
PSAutoLock
:
:
gPSMutex
{
"
Base
Profiler
mutex
"
}
;
typedef
const
PSAutoLock
&
PSLockRef
;
#
define
PS_GET
(
type_
name_
)
\
static
type_
name_
(
PSLockRef
)
{
\
MOZ_ASSERT
(
sInstance
)
;
\
return
sInstance
-
>
m
#
#
name_
;
\
}
#
define
PS_GET_LOCKLESS
(
type_
name_
)
\
static
type_
name_
(
)
{
\
MOZ_ASSERT
(
sInstance
)
;
\
return
sInstance
-
>
m
#
#
name_
;
\
}
#
define
PS_GET_AND_SET
(
type_
name_
)
\
PS_GET
(
type_
name_
)
\
static
void
Set
#
#
name_
(
PSLockRef
type_
a
#
#
name_
)
{
\
MOZ_ASSERT
(
sInstance
)
;
\
sInstance
-
>
m
#
#
name_
=
a
#
#
name_
;
\
}
class
CorePS
{
private
:
CorePS
(
)
:
mProcessStartTime
(
TimeStamp
:
:
ProcessCreation
(
)
)
#
ifdef
USE_LUL_STACKWALK
mLul
(
nullptr
)
#
endif
{
}
~
CorePS
(
)
{
}
public
:
static
void
Create
(
PSLockRef
aLock
)
{
MOZ_ASSERT
(
!
sInstance
)
;
sInstance
=
new
CorePS
(
)
;
}
static
void
Destroy
(
PSLockRef
aLock
)
{
MOZ_ASSERT
(
sInstance
)
;
delete
sInstance
;
sInstance
=
nullptr
;
}
static
bool
Exists
(
)
{
return
!
!
sInstance
;
}
static
void
AddSizeOf
(
PSLockRef
MallocSizeOf
aMallocSizeOf
size_t
&
aProfSize
size_t
&
aLulSize
)
{
MOZ_ASSERT
(
sInstance
)
;
aProfSize
+
=
aMallocSizeOf
(
sInstance
)
;
for
(
auto
&
registeredThread
:
sInstance
-
>
mRegisteredThreads
)
{
aProfSize
+
=
registeredThread
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
for
(
auto
&
registeredPage
:
sInstance
-
>
mRegisteredPages
)
{
aProfSize
+
=
registeredPage
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
#
if
defined
(
USE_LUL_STACKWALK
)
if
(
sInstance
-
>
mLul
)
{
aLulSize
+
=
sInstance
-
>
mLul
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
#
endif
}
PS_GET_LOCKLESS
(
const
TimeStamp
&
ProcessStartTime
)
PS_GET
(
const
Vector
<
UniquePtr
<
RegisteredThread
>
>
&
RegisteredThreads
)
static
void
AppendRegisteredThread
(
PSLockRef
UniquePtr
<
RegisteredThread
>
&
&
aRegisteredThread
)
{
MOZ_ASSERT
(
sInstance
)
;
MOZ_RELEASE_ASSERT
(
sInstance
-
>
mRegisteredThreads
.
append
(
std
:
:
move
(
aRegisteredThread
)
)
)
;
}
static
void
RemoveRegisteredThread
(
PSLockRef
RegisteredThread
*
aRegisteredThread
)
{
MOZ_ASSERT
(
sInstance
)
;
for
(
UniquePtr
<
RegisteredThread
>
&
rt
:
sInstance
-
>
mRegisteredThreads
)
{
if
(
rt
.
get
(
)
=
=
aRegisteredThread
)
{
sInstance
-
>
mRegisteredThreads
.
erase
(
&
rt
)
;
return
;
}
}
}
PS_GET
(
Vector
<
RefPtr
<
PageInformation
>
>
&
RegisteredPages
)
static
void
AppendRegisteredPage
(
PSLockRef
RefPtr
<
PageInformation
>
&
&
aRegisteredPage
)
{
MOZ_ASSERT
(
sInstance
)
;
struct
RegisteredPageComparator
{
PageInformation
*
aA
;
bool
operator
(
)
(
PageInformation
*
aB
)
const
{
return
aA
-
>
Equals
(
aB
)
;
}
}
;
auto
foundPageIter
=
std
:
:
find_if
(
sInstance
-
>
mRegisteredPages
.
begin
(
)
sInstance
-
>
mRegisteredPages
.
end
(
)
RegisteredPageComparator
{
aRegisteredPage
.
get
(
)
}
)
;
if
(
foundPageIter
!
=
sInstance
-
>
mRegisteredPages
.
end
(
)
)
{
if
(
(
*
foundPageIter
)
-
>
Url
(
)
=
=
"
about
:
blank
"
)
{
sInstance
-
>
mRegisteredPages
.
erase
(
foundPageIter
)
;
}
else
{
return
;
}
}
MOZ_RELEASE_ASSERT
(
sInstance
-
>
mRegisteredPages
.
append
(
std
:
:
move
(
aRegisteredPage
)
)
)
;
}
static
void
RemoveRegisteredPage
(
PSLockRef
uint64_t
aRegisteredInnerWindowID
)
{
MOZ_ASSERT
(
sInstance
)
;
sInstance
-
>
mRegisteredPages
.
eraseIf
(
[
&
]
(
const
RefPtr
<
PageInformation
>
&
rd
)
{
return
rd
-
>
InnerWindowID
(
)
=
=
aRegisteredInnerWindowID
;
}
)
;
}
static
void
ClearRegisteredPages
(
PSLockRef
)
{
MOZ_ASSERT
(
sInstance
)
;
sInstance
-
>
mRegisteredPages
.
clear
(
)
;
}
PS_GET
(
const
Vector
<
BaseProfilerCount
*
>
&
Counters
)
static
void
AppendCounter
(
PSLockRef
BaseProfilerCount
*
aCounter
)
{
MOZ_ASSERT
(
sInstance
)
;
MOZ_RELEASE_ASSERT
(
sInstance
-
>
mCounters
.
append
(
aCounter
)
)
;
}
static
void
RemoveCounter
(
PSLockRef
BaseProfilerCount
*
aCounter
)
{
if
(
sInstance
)
{
auto
*
counter
=
std
:
:
find
(
sInstance
-
>
mCounters
.
begin
(
)
sInstance
-
>
mCounters
.
end
(
)
aCounter
)
;
MOZ_RELEASE_ASSERT
(
counter
!
=
sInstance
-
>
mCounters
.
end
(
)
)
;
sInstance
-
>
mCounters
.
erase
(
counter
)
;
}
}
#
ifdef
USE_LUL_STACKWALK
static
lul
:
:
LUL
*
Lul
(
PSLockRef
)
{
MOZ_ASSERT
(
sInstance
)
;
return
sInstance
-
>
mLul
.
get
(
)
;
}
static
void
SetLul
(
PSLockRef
UniquePtr
<
lul
:
:
LUL
>
aLul
)
{
MOZ_ASSERT
(
sInstance
)
;
sInstance
-
>
mLul
=
std
:
:
move
(
aLul
)
;
}
#
endif
PS_GET_AND_SET
(
const
std
:
:
string
&
ProcessName
)
PS_GET_AND_SET
(
const
std
:
:
string
&
ETLDplus1
)
private
:
static
CorePS
*
sInstance
;
const
TimeStamp
mProcessStartTime
;
Vector
<
UniquePtr
<
RegisteredThread
>
>
mRegisteredThreads
;
Vector
<
RefPtr
<
PageInformation
>
>
mRegisteredPages
;
Vector
<
BaseProfilerCount
*
>
mCounters
;
#
ifdef
USE_LUL_STACKWALK
UniquePtr
<
lul
:
:
LUL
>
mLul
;
#
endif
std
:
:
string
mProcessName
;
std
:
:
string
mETLDplus1
;
}
;
CorePS
*
CorePS
:
:
sInstance
=
nullptr
;
class
SamplerThread
;
static
SamplerThread
*
NewSamplerThread
(
PSLockRef
aLock
uint32_t
aGeneration
double
aInterval
uint32_t
aFeatures
)
;
struct
LiveProfiledThreadData
{
RegisteredThread
*
mRegisteredThread
;
UniquePtr
<
ProfiledThreadData
>
mProfiledThreadData
;
}
;
constexpr
static
uint32_t
scBytesPerEntry
=
8
;
class
ActivePS
{
private
:
constexpr
static
uint32_t
scMinimumChunkSize
=
2
*
ProfileBufferChunkManager
:
:
scExpectedMaximumStackSize
;
constexpr
static
uint32_t
scMinimumNumberOfChunks
=
4
;
constexpr
static
uint32_t
scMaximumChunkSize
=
1024
*
1024
;
public
:
constexpr
static
uint32_t
scMinimumBufferSize
=
scMinimumNumberOfChunks
*
scMinimumChunkSize
;
constexpr
static
uint32_t
scMinimumBufferEntries
=
scMinimumBufferSize
/
scBytesPerEntry
;
constexpr
static
uint32_t
scMaximumBufferSize
=
2u
*
1024u
*
1024u
*
1024u
;
constexpr
static
uint32_t
scMaximumBufferEntries
=
scMaximumBufferSize
/
scBytesPerEntry
;
constexpr
static
uint32_t
ClampToAllowedEntries
(
uint32_t
aEntries
)
{
if
(
aEntries
<
=
scMinimumBufferEntries
)
{
return
scMinimumBufferEntries
;
}
if
(
aEntries
>
=
scMaximumBufferEntries
)
{
return
scMaximumBufferEntries
;
}
return
aEntries
;
}
private
:
constexpr
static
uint32_t
ChunkSizeForEntries
(
uint32_t
aEntries
)
{
return
uint32_t
(
std
:
:
min
(
size_t
(
ClampToAllowedEntries
(
aEntries
)
)
*
scBytesPerEntry
/
scMinimumNumberOfChunks
size_t
(
scMaximumChunkSize
)
)
)
;
}
static
uint32_t
AdjustFeatures
(
uint32_t
aFeatures
uint32_t
aFilterCount
)
{
aFeatures
&
=
AvailableFeatures
(
)
;
if
(
aFeatures
&
ProfilerFeature
:
:
FileIOAll
)
{
aFeatures
|
=
ProfilerFeature
:
:
MainThreadIO
|
ProfilerFeature
:
:
FileIO
;
}
else
if
(
aFeatures
&
ProfilerFeature
:
:
FileIO
)
{
aFeatures
|
=
ProfilerFeature
:
:
MainThreadIO
;
}
return
aFeatures
;
}
ActivePS
(
PSLockRef
aLock
const
TimeStamp
&
aProfilingStartTime
PowerOfTwo32
aCapacity
double
aInterval
uint32_t
aFeatures
const
char
*
*
aFilters
uint32_t
aFilterCount
const
Maybe
<
double
>
&
aDuration
)
:
mProfilingStartTime
(
aProfilingStartTime
)
mGeneration
(
sNextGeneration
+
+
)
mCapacity
(
aCapacity
)
mDuration
(
aDuration
)
mInterval
(
aInterval
)
mFeatures
(
AdjustFeatures
(
aFeatures
aFilterCount
)
)
mProfileBufferChunkManager
(
MakeUnique
<
ProfileBufferChunkManagerWithLocalLimit
>
(
size_t
(
ClampToAllowedEntries
(
aCapacity
.
Value
(
)
)
)
*
scBytesPerEntry
ChunkSizeForEntries
(
aCapacity
.
Value
(
)
)
)
)
mProfileBuffer
(
[
this
]
(
)
-
>
ProfileChunkedBuffer
&
{
ProfileChunkedBuffer
&
buffer
=
profiler_get_core_buffer
(
)
;
buffer
.
SetChunkManager
(
*
mProfileBufferChunkManager
)
;
return
buffer
;
}
(
)
)
mSamplerThread
(
NewSamplerThread
(
aLock
mGeneration
aInterval
aFeatures
)
)
mIsPaused
(
false
)
mIsSamplingPaused
(
false
)
{
MOZ_ALWAYS_TRUE
(
mFilters
.
resize
(
aFilterCount
)
)
;
MOZ_ALWAYS_TRUE
(
mFiltersLowered
.
resize
(
aFilterCount
)
)
;
for
(
uint32_t
i
=
0
;
i
<
aFilterCount
;
+
+
i
)
{
mFilters
[
i
]
=
aFilters
[
i
]
;
mFiltersLowered
[
i
]
.
reserve
(
mFilters
[
i
]
.
size
(
)
)
;
std
:
:
transform
(
mFilters
[
i
]
.
cbegin
(
)
mFilters
[
i
]
.
cend
(
)
std
:
:
back_inserter
(
mFiltersLowered
[
i
]
)
:
:
tolower
)
;
}
}
~
ActivePS
(
)
{
if
(
mProfileBufferChunkManager
)
{
profiler_get_core_buffer
(
)
.
ResetChunkManager
(
)
;
}
}
bool
ThreadSelected
(
const
char
*
aThreadName
)
{
if
(
mFiltersLowered
.
empty
(
)
)
{
return
true
;
}
std
:
:
string
name
=
aThreadName
;
std
:
:
transform
(
name
.
begin
(
)
name
.
end
(
)
name
.
begin
(
)
:
:
tolower
)
;
for
(
const
auto
&
filter
:
mFiltersLowered
)
{
if
(
filter
=
=
"
*
"
)
{
return
true
;
}
if
(
name
.
find
(
filter
)
!
=
std
:
:
string
:
:
npos
)
{
return
true
;
}
if
(
mozilla
:
:
profiler
:
:
detail
:
:
FilterHasPid
(
filter
.
c_str
(
)
)
)
{
return
true
;
}
}
return
false
;
}
public
:
static
void
Create
(
PSLockRef
aLock
const
TimeStamp
&
aProfilingStartTime
PowerOfTwo32
aCapacity
double
aInterval
uint32_t
aFeatures
const
char
*
*
aFilters
uint32_t
aFilterCount
const
Maybe
<
double
>
&
aDuration
)
{
MOZ_ASSERT
(
!
sInstance
)
;
sInstance
=
new
ActivePS
(
aLock
aProfilingStartTime
aCapacity
aInterval
aFeatures
aFilters
aFilterCount
aDuration
)
;
}
[
[
nodiscard
]
]
static
SamplerThread
*
Destroy
(
PSLockRef
aLock
)
{
MOZ_ASSERT
(
sInstance
)
;
auto
samplerThread
=
sInstance
-
>
mSamplerThread
;
delete
sInstance
;
sInstance
=
nullptr
;
return
samplerThread
;
}
static
bool
Exists
(
PSLockRef
)
{
return
!
!
sInstance
;
}
static
bool
Equals
(
PSLockRef
PowerOfTwo32
aCapacity
const
Maybe
<
double
>
&
aDuration
double
aInterval
uint32_t
aFeatures
const
char
*
*
aFilters
uint32_t
aFilterCount
)
{
MOZ_ASSERT
(
sInstance
)
;
if
(
sInstance
-
>
mCapacity
!
=
aCapacity
|
|
sInstance
-
>
mDuration
!
=
aDuration
|
|
sInstance
-
>
mInterval
!
=
aInterval
|
|
sInstance
-
>
mFeatures
!
=
aFeatures
|
|
sInstance
-
>
mFilters
.
length
(
)
!
=
aFilterCount
)
{
return
false
;
}
for
(
uint32_t
i
=
0
;
i
<
sInstance
-
>
mFilters
.
length
(
)
;
+
+
i
)
{
if
(
strcmp
(
sInstance
-
>
mFilters
[
i
]
.
c_str
(
)
aFilters
[
i
]
)
!
=
0
)
{
return
false
;
}
}
return
true
;
}
static
size_t
SizeOf
(
PSLockRef
MallocSizeOf
aMallocSizeOf
)
{
MOZ_ASSERT
(
sInstance
)
;
size_t
n
=
aMallocSizeOf
(
sInstance
)
;
n
+
=
sInstance
-
>
mProfileBuffer
.
SizeOfExcludingThis
(
aMallocSizeOf
)
;
return
n
;
}
static
UniquePtr
<
ProfileBufferChunkManagerWithLocalLimit
>
ExtractBaseProfilerChunkManager
(
PSLockRef
)
{
MOZ_ASSERT
(
sInstance
)
;
return
std
:
:
move
(
sInstance
-
>
mProfileBufferChunkManager
)
;
}
static
bool
ShouldProfileThread
(
PSLockRef
aLock
ThreadInfo
*
aInfo
)
{
MOZ_ASSERT
(
sInstance
)
;
return
sInstance
-
>
ThreadSelected
(
aInfo
-
>
Name
(
)
)
;
}
PS_GET_LOCKLESS
(
TimeStamp
ProfilingStartTime
)
PS_GET
(
uint32_t
Generation
)
PS_GET
(
PowerOfTwo32
Capacity
)
PS_GET
(
Maybe
<
double
>
Duration
)
PS_GET
(
double
Interval
)
PS_GET
(
uint32_t
Features
)
#
define
PS_GET_FEATURE
(
n_
str_
Name_
desc_
)
\
static
bool
Feature
#
#
Name_
(
PSLockRef
)
{
\
MOZ_ASSERT
(
sInstance
)
;
\
return
ProfilerFeature
:
:
Has
#
#
Name_
(
sInstance
-
>
mFeatures
)
;
\
}
BASE_PROFILER_FOR_EACH_FEATURE
(
PS_GET_FEATURE
)
#
undef
PS_GET_FEATURE
PS_GET
(
const
Vector
<
std
:
:
string
>
&
Filters
)
PS_GET
(
const
Vector
<
std
:
:
string
>
&
FiltersLowered
)
static
void
FulfillChunkRequests
(
PSLockRef
)
{
MOZ_ASSERT
(
sInstance
)
;
if
(
sInstance
-
>
mProfileBufferChunkManager
)
{
sInstance
-
>
mProfileBufferChunkManager
-
>
FulfillChunkRequests
(
)
;
}
}
static
ProfileBuffer
&
Buffer
(
PSLockRef
)
{
MOZ_ASSERT
(
sInstance
)
;
return
sInstance
-
>
mProfileBuffer
;
}
static
const
Vector
<
LiveProfiledThreadData
>
&
LiveProfiledThreads
(
PSLockRef
)
{
MOZ_ASSERT
(
sInstance
)
;
return
sInstance
-
>
mLiveProfiledThreads
;
}
static
Vector
<
std
:
:
pair
<
RegisteredThread
*
ProfiledThreadData
*
>
>
ProfiledThreads
(
PSLockRef
)
{
MOZ_ASSERT
(
sInstance
)
;
Vector
<
std
:
:
pair
<
RegisteredThread
*
ProfiledThreadData
*
>
>
array
;
MOZ_RELEASE_ASSERT
(
array
.
initCapacity
(
sInstance
-
>
mLiveProfiledThreads
.
length
(
)
+
sInstance
-
>
mDeadProfiledThreads
.
length
(
)
)
)
;
for
(
auto
&
t
:
sInstance
-
>
mLiveProfiledThreads
)
{
MOZ_RELEASE_ASSERT
(
array
.
append
(
std
:
:
make_pair
(
t
.
mRegisteredThread
t
.
mProfiledThreadData
.
get
(
)
)
)
)
;
}
for
(
auto
&
t
:
sInstance
-
>
mDeadProfiledThreads
)
{
MOZ_RELEASE_ASSERT
(
array
.
append
(
std
:
:
make_pair
(
(
RegisteredThread
*
)
nullptr
t
.
get
(
)
)
)
)
;
}
std
:
:
sort
(
array
.
begin
(
)
array
.
end
(
)
[
]
(
const
std
:
:
pair
<
RegisteredThread
*
ProfiledThreadData
*
>
&
a
const
std
:
:
pair
<
RegisteredThread
*
ProfiledThreadData
*
>
&
b
)
{
return
a
.
second
-
>
Info
(
)
-
>
RegisterTime
(
)
<
b
.
second
-
>
Info
(
)
-
>
RegisterTime
(
)
;
}
)
;
return
array
;
}
static
Vector
<
RefPtr
<
PageInformation
>
>
ProfiledPages
(
PSLockRef
aLock
)
{
MOZ_ASSERT
(
sInstance
)
;
Vector
<
RefPtr
<
PageInformation
>
>
array
;
for
(
auto
&
d
:
CorePS
:
:
RegisteredPages
(
aLock
)
)
{
MOZ_RELEASE_ASSERT
(
array
.
append
(
d
)
)
;
}
for
(
auto
&
d
:
sInstance
-
>
mDeadProfiledPages
)
{
MOZ_RELEASE_ASSERT
(
array
.
append
(
d
)
)
;
}
return
array
;
}
static
ProfiledThreadData
*
GetProfiledThreadData
(
PSLockRef
RegisteredThread
*
aRegisteredThread
)
{
MOZ_ASSERT
(
sInstance
)
;
for
(
const
LiveProfiledThreadData
&
thread
:
sInstance
-
>
mLiveProfiledThreads
)
{
if
(
thread
.
mRegisteredThread
=
=
aRegisteredThread
)
{
return
thread
.
mProfiledThreadData
.
get
(
)
;
}
}
return
nullptr
;
}
static
ProfiledThreadData
*
AddLiveProfiledThread
(
PSLockRef
RegisteredThread
*
aRegisteredThread
UniquePtr
<
ProfiledThreadData
>
&
&
aProfiledThreadData
)
{
MOZ_ASSERT
(
sInstance
)
;
MOZ_RELEASE_ASSERT
(
sInstance
-
>
mLiveProfiledThreads
.
append
(
LiveProfiledThreadData
{
aRegisteredThread
std
:
:
move
(
aProfiledThreadData
)
}
)
)
;
return
sInstance
-
>
mLiveProfiledThreads
.
back
(
)
.
mProfiledThreadData
.
get
(
)
;
}
static
void
UnregisterThread
(
PSLockRef
aLockRef
RegisteredThread
*
aRegisteredThread
)
{
MOZ_ASSERT
(
sInstance
)
;
DiscardExpiredDeadProfiledThreads
(
aLockRef
)
;
for
(
size_t
i
=
0
;
i
<
sInstance
-
>
mLiveProfiledThreads
.
length
(
)
;
i
+
+
)
{
LiveProfiledThreadData
&
thread
=
sInstance
-
>
mLiveProfiledThreads
[
i
]
;
if
(
thread
.
mRegisteredThread
=
=
aRegisteredThread
)
{
thread
.
mProfiledThreadData
-
>
NotifyUnregistered
(
sInstance
-
>
mProfileBuffer
.
BufferRangeEnd
(
)
)
;
MOZ_RELEASE_ASSERT
(
sInstance
-
>
mDeadProfiledThreads
.
append
(
std
:
:
move
(
thread
.
mProfiledThreadData
)
)
)
;
sInstance
-
>
mLiveProfiledThreads
.
erase
(
&
sInstance
-
>
mLiveProfiledThreads
[
i
]
)
;
return
;
}
}
}
PS_GET_AND_SET
(
bool
IsPaused
)
static
bool
IsSamplingPaused
(
PSLockRef
lock
)
{
MOZ_ASSERT
(
sInstance
)
;
return
IsPaused
(
lock
)
|
|
sInstance
-
>
mIsSamplingPaused
;
}
static
void
SetIsSamplingPaused
(
PSLockRef
bool
aIsSamplingPaused
)
{
MOZ_ASSERT
(
sInstance
)
;
sInstance
-
>
mIsSamplingPaused
=
aIsSamplingPaused
;
}
static
void
DiscardExpiredDeadProfiledThreads
(
PSLockRef
)
{
MOZ_ASSERT
(
sInstance
)
;
uint64_t
bufferRangeStart
=
sInstance
-
>
mProfileBuffer
.
BufferRangeStart
(
)
;
sInstance
-
>
mDeadProfiledThreads
.
eraseIf
(
[
bufferRangeStart
]
(
const
UniquePtr
<
ProfiledThreadData
>
&
aProfiledThreadData
)
{
Maybe
<
uint64_t
>
bufferPosition
=
aProfiledThreadData
-
>
BufferPositionWhenUnregistered
(
)
;
MOZ_RELEASE_ASSERT
(
bufferPosition
"
should
have
unregistered
this
thread
"
)
;
return
*
bufferPosition
<
bufferRangeStart
;
}
)
;
}
static
void
UnregisterPage
(
PSLockRef
aLock
uint64_t
aRegisteredInnerWindowID
)
{
MOZ_ASSERT
(
sInstance
)
;
auto
&
registeredPages
=
CorePS
:
:
RegisteredPages
(
aLock
)
;
for
(
size_t
i
=
0
;
i
<
registeredPages
.
length
(
)
;
i
+
+
)
{
RefPtr
<
PageInformation
>
&
page
=
registeredPages
[
i
]
;
if
(
page
-
>
InnerWindowID
(
)
=
=
aRegisteredInnerWindowID
)
{
page
-
>
NotifyUnregistered
(
sInstance
-
>
mProfileBuffer
.
BufferRangeEnd
(
)
)
;
MOZ_RELEASE_ASSERT
(
sInstance
-
>
mDeadProfiledPages
.
append
(
std
:
:
move
(
page
)
)
)
;
registeredPages
.
erase
(
&
registeredPages
[
i
-
-
]
)
;
}
}
}
static
void
DiscardExpiredPages
(
PSLockRef
)
{
MOZ_ASSERT
(
sInstance
)
;
uint64_t
bufferRangeStart
=
sInstance
-
>
mProfileBuffer
.
BufferRangeStart
(
)
;
sInstance
-
>
mDeadProfiledPages
.
eraseIf
(
[
bufferRangeStart
]
(
const
RefPtr
<
PageInformation
>
&
aProfiledPage
)
{
Maybe
<
uint64_t
>
bufferPosition
=
aProfiledPage
-
>
BufferPositionWhenUnregistered
(
)
;
MOZ_RELEASE_ASSERT
(
bufferPosition
"
should
have
unregistered
this
page
"
)
;
return
*
bufferPosition
<
bufferRangeStart
;
}
)
;
}
static
void
ClearUnregisteredPages
(
PSLockRef
)
{
MOZ_ASSERT
(
sInstance
)
;
sInstance
-
>
mDeadProfiledPages
.
clear
(
)
;
}
static
void
ClearExpiredExitProfiles
(
PSLockRef
)
{
MOZ_ASSERT
(
sInstance
)
;
uint64_t
bufferRangeStart
=
sInstance
-
>
mProfileBuffer
.
BufferRangeStart
(
)
;
sInstance
-
>
mExitProfiles
.
eraseIf
(
[
bufferRangeStart
]
(
const
ExitProfile
&
aExitProfile
)
{
return
aExitProfile
.
mBufferPositionAtGatherTime
<
bufferRangeStart
;
}
)
;
}
static
void
AddExitProfile
(
PSLockRef
aLock
const
std
:
:
string
&
aExitProfile
)
{
MOZ_ASSERT
(
sInstance
)
;
ClearExpiredExitProfiles
(
aLock
)
;
MOZ_RELEASE_ASSERT
(
sInstance
-
>
mExitProfiles
.
append
(
ExitProfile
{
aExitProfile
sInstance
-
>
mProfileBuffer
.
BufferRangeEnd
(
)
}
)
)
;
}
static
Vector
<
std
:
:
string
>
MoveExitProfiles
(
PSLockRef
aLock
)
{
MOZ_ASSERT
(
sInstance
)
;
ClearExpiredExitProfiles
(
aLock
)
;
Vector
<
std
:
:
string
>
profiles
;
MOZ_RELEASE_ASSERT
(
profiles
.
initCapacity
(
sInstance
-
>
mExitProfiles
.
length
(
)
)
)
;
for
(
auto
&
profile
:
sInstance
-
>
mExitProfiles
)
{
MOZ_RELEASE_ASSERT
(
profiles
.
append
(
std
:
:
move
(
profile
.
mJSON
)
)
)
;
}
sInstance
-
>
mExitProfiles
.
clear
(
)
;
return
profiles
;
}
private
:
static
ActivePS
*
sInstance
;
const
TimeStamp
mProfilingStartTime
;
const
uint32_t
mGeneration
;
static
uint32_t
sNextGeneration
;
const
PowerOfTwo32
mCapacity
;
const
Maybe
<
double
>
mDuration
;
const
double
mInterval
;
const
uint32_t
mFeatures
;
Vector
<
std
:
:
string
>
mFilters
;
Vector
<
std
:
:
string
>
mFiltersLowered
;
UniquePtr
<
ProfileBufferChunkManagerWithLocalLimit
>
mProfileBufferChunkManager
;
ProfileBuffer
mProfileBuffer
;
Vector
<
LiveProfiledThreadData
>
mLiveProfiledThreads
;
Vector
<
UniquePtr
<
ProfiledThreadData
>
>
mDeadProfiledThreads
;
Vector
<
RefPtr
<
PageInformation
>
>
mDeadProfiledPages
;
SamplerThread
*
const
mSamplerThread
;
bool
mIsPaused
;
bool
mIsSamplingPaused
;
struct
ExitProfile
{
std
:
:
string
mJSON
;
uint64_t
mBufferPositionAtGatherTime
;
}
;
Vector
<
ExitProfile
>
mExitProfiles
;
}
;
ActivePS
*
ActivePS
:
:
sInstance
=
nullptr
;
uint32_t
ActivePS
:
:
sNextGeneration
=
0
;
#
undef
PS_GET
#
undef
PS_GET_LOCKLESS
#
undef
PS_GET_AND_SET
namespace
detail
{
TimeStamp
GetProfilingStartTime
(
)
{
if
(
!
CorePS
:
:
Exists
(
)
)
{
return
{
}
;
}
PSAutoLock
lock
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
{
}
;
}
return
ActivePS
:
:
ProfilingStartTime
(
)
;
}
[
[
nodiscard
]
]
MFBT_API
UniquePtr
<
ProfileBufferChunkManagerWithLocalLimit
>
ExtractBaseProfilerChunkManager
(
)
{
PSAutoLock
lock
;
if
(
MOZ_UNLIKELY
(
!
ActivePS
:
:
Exists
(
lock
)
)
)
{
return
nullptr
;
}
return
ActivePS
:
:
ExtractBaseProfilerChunkManager
(
lock
)
;
}
}
Atomic
<
uint32_t
MemoryOrdering
:
:
Relaxed
>
RacyFeatures
:
:
sActiveAndFeatures
(
0
)
;
void
RacyFeatures
:
:
SetActive
(
uint32_t
aFeatures
)
{
sActiveAndFeatures
=
Active
|
aFeatures
;
}
void
RacyFeatures
:
:
SetInactive
(
)
{
sActiveAndFeatures
=
0
;
}
bool
RacyFeatures
:
:
IsActive
(
)
{
return
uint32_t
(
sActiveAndFeatures
)
&
Active
;
}
void
RacyFeatures
:
:
SetPaused
(
)
{
sActiveAndFeatures
|
=
Paused
;
}
void
RacyFeatures
:
:
SetUnpaused
(
)
{
sActiveAndFeatures
&
=
~
Paused
;
}
void
RacyFeatures
:
:
SetSamplingPaused
(
)
{
sActiveAndFeatures
|
=
SamplingPaused
;
}
void
RacyFeatures
:
:
SetSamplingUnpaused
(
)
{
sActiveAndFeatures
&
=
~
SamplingPaused
;
}
bool
RacyFeatures
:
:
IsActiveWithFeature
(
uint32_t
aFeature
)
{
uint32_t
af
=
sActiveAndFeatures
;
return
(
af
&
Active
)
&
&
(
af
&
aFeature
)
;
}
bool
RacyFeatures
:
:
IsActiveAndUnpaused
(
)
{
uint32_t
af
=
sActiveAndFeatures
;
return
(
af
&
Active
)
&
&
!
(
af
&
Paused
)
;
}
bool
RacyFeatures
:
:
IsActiveAndSamplingUnpaused
(
)
{
uint32_t
af
=
sActiveAndFeatures
;
return
(
af
&
Active
)
&
&
!
(
af
&
(
Paused
|
SamplingPaused
)
)
;
}
class
TLSRegisteredThread
{
public
:
static
bool
Init
(
PSLockRef
)
{
bool
ok1
=
sRegisteredThread
.
init
(
)
;
bool
ok2
=
AutoProfilerLabel
:
:
sProfilingStack
.
init
(
)
;
return
ok1
&
&
ok2
;
}
static
class
RegisteredThread
*
RegisteredThread
(
PSLockRef
)
{
return
sRegisteredThread
.
get
(
)
;
}
static
class
RacyRegisteredThread
*
RacyRegisteredThread
(
)
{
class
RegisteredThread
*
registeredThread
=
sRegisteredThread
.
get
(
)
;
return
registeredThread
?
&
registeredThread
-
>
RacyRegisteredThread
(
)
:
nullptr
;
}
static
ProfilingStack
*
Stack
(
)
{
return
AutoProfilerLabel
:
:
sProfilingStack
.
get
(
)
;
}
static
void
SetRegisteredThread
(
PSLockRef
class
RegisteredThread
*
aRegisteredThread
)
{
sRegisteredThread
.
set
(
aRegisteredThread
)
;
AutoProfilerLabel
:
:
sProfilingStack
.
set
(
aRegisteredThread
?
&
aRegisteredThread
-
>
RacyRegisteredThread
(
)
.
ProfilingStack
(
)
:
nullptr
)
;
}
private
:
static
MOZ_THREAD_LOCAL
(
class
RegisteredThread
*
)
sRegisteredThread
;
}
;
MOZ_THREAD_LOCAL
(
RegisteredThread
*
)
TLSRegisteredThread
:
:
sRegisteredThread
;
ProfilingStack
*
AutoProfilerLabel
:
:
GetProfilingStack
(
)
{
return
sProfilingStack
.
get
(
)
;
}
MOZ_THREAD_LOCAL
(
ProfilingStack
*
)
AutoProfilerLabel
:
:
sProfilingStack
;
namespace
detail
{
[
[
nodiscard
]
]
MFBT_API
TimeStamp
GetThreadRegistrationTime
(
)
{
if
(
!
CorePS
:
:
Exists
(
)
)
{
return
{
}
;
}
PSAutoLock
lock
;
RegisteredThread
*
registeredThread
=
TLSRegisteredThread
:
:
RegisteredThread
(
lock
)
;
if
(
!
registeredThread
)
{
return
{
}
;
}
return
registeredThread
-
>
Info
(
)
-
>
RegisterTime
(
)
;
}
}
static
const
char
*
const
kMainThreadName
=
"
GeckoMain
"
;
class
Registers
{
public
:
Registers
(
)
:
mPC
{
nullptr
}
mSP
{
nullptr
}
mFP
{
nullptr
}
mLR
{
nullptr
}
{
}
#
if
defined
(
HAVE_NATIVE_UNWIND
)
void
SyncPopulate
(
)
;
#
endif
void
Clear
(
)
{
memset
(
this
0
sizeof
(
*
this
)
)
;
}
Address
mPC
;
Address
mSP
;
Address
mFP
;
Address
mLR
;
#
if
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_android
)
|
|
defined
(
GP_OS_freebsd
)
ucontext_t
*
mContext
;
#
endif
}
;
static
const
size_t
MAX_NATIVE_FRAMES
=
1024
;
struct
NativeStack
{
void
*
mPCs
[
MAX_NATIVE_FRAMES
]
;
void
*
mSPs
[
MAX_NATIVE_FRAMES
]
;
size_t
mCount
;
NativeStack
(
)
:
mPCs
(
)
mSPs
(
)
mCount
(
0
)
{
}
}
;
static
void
MergeStacks
(
uint32_t
aFeatures
bool
aIsSynchronous
const
RegisteredThread
&
aRegisteredThread
const
Registers
&
aRegs
const
NativeStack
&
aNativeStack
ProfilerStackCollector
&
aCollector
)
{
const
ProfilingStack
&
profilingStack
=
aRegisteredThread
.
RacyRegisteredThread
(
)
.
ProfilingStack
(
)
;
const
ProfilingStackFrame
*
profilingStackFrames
=
profilingStack
.
frames
;
uint32_t
profilingStackFrameCount
=
profilingStack
.
stackSize
(
)
;
Maybe
<
uint64_t
>
samplePosInBuffer
;
if
(
!
aIsSynchronous
)
{
samplePosInBuffer
=
aCollector
.
SamplePositionInBuffer
(
)
;
}
uint32_t
profilingStackIndex
=
0
;
int32_t
nativeIndex
=
aNativeStack
.
mCount
-
1
;
uint8_t
*
lastLabelFrameStackAddr
=
nullptr
;
while
(
profilingStackIndex
!
=
profilingStackFrameCount
|
|
nativeIndex
>
=
0
)
{
uint8_t
*
profilingStackAddr
=
nullptr
;
uint8_t
*
nativeStackAddr
=
nullptr
;
if
(
profilingStackIndex
!
=
profilingStackFrameCount
)
{
const
ProfilingStackFrame
&
profilingStackFrame
=
profilingStackFrames
[
profilingStackIndex
]
;
if
(
profilingStackFrame
.
isLabelFrame
(
)
|
|
profilingStackFrame
.
isSpMarkerFrame
(
)
)
{
lastLabelFrameStackAddr
=
(
uint8_t
*
)
profilingStackFrame
.
stackAddress
(
)
;
}
if
(
profilingStackFrame
.
isOSRFrame
(
)
)
{
profilingStackIndex
+
+
;
continue
;
}
MOZ_ASSERT
(
lastLabelFrameStackAddr
)
;
profilingStackAddr
=
lastLabelFrameStackAddr
;
}
if
(
nativeIndex
>
=
0
)
{
nativeStackAddr
=
(
uint8_t
*
)
aNativeStack
.
mSPs
[
nativeIndex
]
;
}
if
(
nativeStackAddr
&
&
(
profilingStackAddr
=
=
nativeStackAddr
)
)
{
nativeStackAddr
=
nullptr
;
nativeIndex
-
-
;
MOZ_ASSERT
(
profilingStackAddr
)
;
}
MOZ_ASSERT_IF
(
profilingStackAddr
profilingStackAddr
!
=
nativeStackAddr
)
;
MOZ_ASSERT_IF
(
nativeStackAddr
nativeStackAddr
!
=
profilingStackAddr
)
;
if
(
profilingStackAddr
>
nativeStackAddr
)
{
MOZ_ASSERT
(
profilingStackIndex
<
profilingStackFrameCount
)
;
const
ProfilingStackFrame
&
profilingStackFrame
=
profilingStackFrames
[
profilingStackIndex
]
;
if
(
!
profilingStackFrame
.
isSpMarkerFrame
(
)
)
{
if
(
aIsSynchronous
&
&
profilingStackFrame
.
categoryPair
(
)
=
=
ProfilingCategoryPair
:
:
PROFILER
)
{
return
;
}
aCollector
.
CollectProfilingStackFrame
(
profilingStackFrame
)
;
}
profilingStackIndex
+
+
;
continue
;
}
if
(
nativeStackAddr
)
{
MOZ_ASSERT
(
nativeIndex
>
=
0
)
;
void
*
addr
=
(
void
*
)
aNativeStack
.
mPCs
[
nativeIndex
]
;
aCollector
.
CollectNativeLeafAddr
(
addr
)
;
}
if
(
nativeIndex
>
=
0
)
{
nativeIndex
-
-
;
}
}
}
#
if
defined
(
GP_OS_windows
)
&
&
defined
(
USE_MOZ_STACK_WALK
)
static
HANDLE
GetThreadHandle
(
PlatformData
*
aData
)
;
#
endif
#
if
defined
(
USE_FRAME_POINTER_STACK_WALK
)
|
|
defined
(
USE_MOZ_STACK_WALK
)
static
void
StackWalkCallback
(
uint32_t
aFrameNumber
void
*
aPC
void
*
aSP
void
*
aClosure
)
{
NativeStack
*
nativeStack
=
static_cast
<
NativeStack
*
>
(
aClosure
)
;
MOZ_ASSERT
(
nativeStack
-
>
mCount
<
MAX_NATIVE_FRAMES
)
;
nativeStack
-
>
mSPs
[
nativeStack
-
>
mCount
]
=
aSP
;
nativeStack
-
>
mPCs
[
nativeStack
-
>
mCount
]
=
aPC
;
nativeStack
-
>
mCount
+
+
;
}
#
endif
#
if
defined
(
USE_FRAME_POINTER_STACK_WALK
)
static
void
DoFramePointerBacktrace
(
PSLockRef
aLock
const
RegisteredThread
&
aRegisteredThread
const
Registers
&
aRegs
NativeStack
&
aNativeStack
)
{
StackWalkCallback
(
0
aRegs
.
mPC
aRegs
.
mSP
&
aNativeStack
)
;
uint32_t
maxFrames
=
uint32_t
(
MAX_NATIVE_FRAMES
-
aNativeStack
.
mCount
)
;
const
void
*
stackEnd
=
aRegisteredThread
.
StackTop
(
)
;
if
(
aRegs
.
mFP
>
=
aRegs
.
mSP
&
&
aRegs
.
mFP
<
=
stackEnd
)
{
FramePointerStackWalk
(
StackWalkCallback
maxFrames
&
aNativeStack
reinterpret_cast
<
void
*
*
>
(
aRegs
.
mFP
)
const_cast
<
void
*
>
(
stackEnd
)
)
;
}
}
#
endif
#
if
defined
(
USE_MOZ_STACK_WALK
)
static
void
DoMozStackWalkBacktrace
(
PSLockRef
aLock
const
RegisteredThread
&
aRegisteredThread
const
Registers
&
aRegs
NativeStack
&
aNativeStack
)
{
StackWalkCallback
(
0
aRegs
.
mPC
aRegs
.
mSP
&
aNativeStack
)
;
uint32_t
maxFrames
=
uint32_t
(
MAX_NATIVE_FRAMES
-
aNativeStack
.
mCount
)
;
HANDLE
thread
=
GetThreadHandle
(
aRegisteredThread
.
GetPlatformData
(
)
)
;
MOZ_ASSERT
(
thread
)
;
MozStackWalkThread
(
StackWalkCallback
maxFrames
&
aNativeStack
thread
nullptr
)
;
}
#
endif
#
ifdef
USE_EHABI_STACKWALK
static
void
DoEHABIBacktrace
(
PSLockRef
aLock
const
RegisteredThread
&
aRegisteredThread
const
Registers
&
aRegs
NativeStack
&
aNativeStack
)
{
aNativeStack
.
mCount
=
EHABIStackWalk
(
aRegs
.
mContext
-
>
uc_mcontext
const_cast
<
void
*
>
(
aRegisteredThread
.
StackTop
(
)
)
aNativeStack
.
mSPs
aNativeStack
.
mPCs
MAX_NATIVE_FRAMES
)
;
}
#
endif
#
ifdef
USE_LUL_STACKWALK
#
if
defined
(
MOZ_HAVE_ASAN_BLACKLIST
)
MOZ_ASAN_BLACKLIST
static
void
ASAN_memcpy
(
void
*
aDst
const
void
*
aSrc
size_t
aLen
)
{
char
*
dst
=
static_cast
<
char
*
>
(
aDst
)
;
const
char
*
src
=
static_cast
<
const
char
*
>
(
aSrc
)
;
for
(
size_t
i
=
0
;
i
<
aLen
;
i
+
+
)
{
dst
[
i
]
=
src
[
i
]
;
}
}
#
endif
static
void
DoLULBacktrace
(
PSLockRef
aLock
const
RegisteredThread
&
aRegisteredThread
const
Registers
&
aRegs
NativeStack
&
aNativeStack
)
{
const
mcontext_t
*
mc
=
&
aRegs
.
mContext
-
>
uc_mcontext
;
lul
:
:
UnwindRegs
startRegs
;
memset
(
&
startRegs
0
sizeof
(
startRegs
)
)
;
#
if
defined
(
GP_PLAT_amd64_linux
)
|
|
defined
(
GP_PLAT_amd64_android
)
startRegs
.
xip
=
lul
:
:
TaggedUWord
(
mc
-
>
gregs
[
REG_RIP
]
)
;
startRegs
.
xsp
=
lul
:
:
TaggedUWord
(
mc
-
>
gregs
[
REG_RSP
]
)
;
startRegs
.
xbp
=
lul
:
:
TaggedUWord
(
mc
-
>
gregs
[
REG_RBP
]
)
;
#
elif
defined
(
GP_PLAT_amd64_freebsd
)
startRegs
.
xip
=
lul
:
:
TaggedUWord
(
mc
-
>
mc_rip
)
;
startRegs
.
xsp
=
lul
:
:
TaggedUWord
(
mc
-
>
mc_rsp
)
;
startRegs
.
xbp
=
lul
:
:
TaggedUWord
(
mc
-
>
mc_rbp
)
;
#
elif
defined
(
GP_PLAT_arm_linux
)
|
|
defined
(
GP_PLAT_arm_android
)
startRegs
.
r15
=
lul
:
:
TaggedUWord
(
mc
-
>
arm_pc
)
;
startRegs
.
r14
=
lul
:
:
TaggedUWord
(
mc
-
>
arm_lr
)
;
startRegs
.
r13
=
lul
:
:
TaggedUWord
(
mc
-
>
arm_sp
)
;
startRegs
.
r12
=
lul
:
:
TaggedUWord
(
mc
-
>
arm_ip
)
;
startRegs
.
r11
=
lul
:
:
TaggedUWord
(
mc
-
>
arm_fp
)
;
startRegs
.
r7
=
lul
:
:
TaggedUWord
(
mc
-
>
arm_r7
)
;
#
elif
defined
(
GP_PLAT_arm64_linux
)
|
|
defined
(
GP_PLAT_arm64_android
)
startRegs
.
pc
=
lul
:
:
TaggedUWord
(
mc
-
>
pc
)
;
startRegs
.
x29
=
lul
:
:
TaggedUWord
(
mc
-
>
regs
[
29
]
)
;
startRegs
.
x30
=
lul
:
:
TaggedUWord
(
mc
-
>
regs
[
30
]
)
;
startRegs
.
sp
=
lul
:
:
TaggedUWord
(
mc
-
>
sp
)
;
#
elif
defined
(
GP_PLAT_arm64_freebsd
)
startRegs
.
pc
=
lul
:
:
TaggedUWord
(
mc
-
>
mc_gpregs
.
gp_elr
)
;
startRegs
.
x29
=
lul
:
:
TaggedUWord
(
mc
-
>
mc_gpregs
.
gp_x
[
29
]
)
;
startRegs
.
x30
=
lul
:
:
TaggedUWord
(
mc
-
>
mc_gpregs
.
gp_lr
)
;
startRegs
.
sp
=
lul
:
:
TaggedUWord
(
mc
-
>
mc_gpregs
.
gp_sp
)
;
#
elif
defined
(
GP_PLAT_x86_linux
)
|
|
defined
(
GP_PLAT_x86_android
)
startRegs
.
xip
=
lul
:
:
TaggedUWord
(
mc
-
>
gregs
[
REG_EIP
]
)
;
startRegs
.
xsp
=
lul
:
:
TaggedUWord
(
mc
-
>
gregs
[
REG_ESP
]
)
;
startRegs
.
xbp
=
lul
:
:
TaggedUWord
(
mc
-
>
gregs
[
REG_EBP
]
)
;
#
elif
defined
(
GP_PLAT_mips64_linux
)
startRegs
.
pc
=
lul
:
:
TaggedUWord
(
mc
-
>
pc
)
;
startRegs
.
sp
=
lul
:
:
TaggedUWord
(
mc
-
>
gregs
[
29
]
)
;
startRegs
.
fp
=
lul
:
:
TaggedUWord
(
mc
-
>
gregs
[
30
]
)
;
#
else
#
error
"
Unknown
plat
"
#
endif
lul
:
:
StackImage
stackImg
;
{
#
if
defined
(
GP_PLAT_amd64_linux
)
|
|
defined
(
GP_PLAT_amd64_android
)
|
|
\
defined
(
GP_PLAT_amd64_freebsd
)
uintptr_t
rEDZONE_SIZE
=
128
;
uintptr_t
start
=
startRegs
.
xsp
.
Value
(
)
-
rEDZONE_SIZE
;
#
elif
defined
(
GP_PLAT_arm_linux
)
|
|
defined
(
GP_PLAT_arm_android
)
uintptr_t
rEDZONE_SIZE
=
0
;
uintptr_t
start
=
startRegs
.
r13
.
Value
(
)
-
rEDZONE_SIZE
;
#
elif
defined
(
GP_PLAT_arm64_linux
)
|
|
defined
(
GP_PLAT_arm64_android
)
|
|
\
defined
(
GP_PLAT_arm64_freebsd
)
uintptr_t
rEDZONE_SIZE
=
0
;
uintptr_t
start
=
startRegs
.
sp
.
Value
(
)
-
rEDZONE_SIZE
;
#
elif
defined
(
GP_PLAT_x86_linux
)
|
|
defined
(
GP_PLAT_x86_android
)
uintptr_t
rEDZONE_SIZE
=
0
;
uintptr_t
start
=
startRegs
.
xsp
.
Value
(
)
-
rEDZONE_SIZE
;
#
elif
defined
(
GP_PLAT_mips64_linux
)
uintptr_t
rEDZONE_SIZE
=
0
;
uintptr_t
start
=
startRegs
.
sp
.
Value
(
)
-
rEDZONE_SIZE
;
#
else
#
error
"
Unknown
plat
"
#
endif
uintptr_t
end
=
reinterpret_cast
<
uintptr_t
>
(
aRegisteredThread
.
StackTop
(
)
)
;
uintptr_t
ws
=
sizeof
(
void
*
)
;
start
&
=
~
(
ws
-
1
)
;
end
&
=
~
(
ws
-
1
)
;
uintptr_t
nToCopy
=
0
;
if
(
start
<
end
)
{
nToCopy
=
end
-
start
;
if
(
nToCopy
>
lul
:
:
N_STACK_BYTES
)
nToCopy
=
lul
:
:
N_STACK_BYTES
;
}
MOZ_ASSERT
(
nToCopy
<
=
lul
:
:
N_STACK_BYTES
)
;
stackImg
.
mLen
=
nToCopy
;
stackImg
.
mStartAvma
=
start
;
if
(
nToCopy
>
0
)
{
#
if
defined
(
MOZ_HAVE_ASAN_BLACKLIST
)
ASAN_memcpy
(
&
stackImg
.
mContents
[
0
]
(
void
*
)
start
nToCopy
)
;
#
else
memcpy
(
&
stackImg
.
mContents
[
0
]
(
void
*
)
start
nToCopy
)
;
#
endif
(
void
)
VALGRIND_MAKE_MEM_DEFINED
(
&
stackImg
.
mContents
[
0
]
nToCopy
)
;
}
}
size_t
framePointerFramesAcquired
=
0
;
lul
:
:
LUL
*
lul
=
CorePS
:
:
Lul
(
aLock
)
;
lul
-
>
Unwind
(
reinterpret_cast
<
uintptr_t
*
>
(
aNativeStack
.
mPCs
)
reinterpret_cast
<
uintptr_t
*
>
(
aNativeStack
.
mSPs
)
&
aNativeStack
.
mCount
&
framePointerFramesAcquired
MAX_NATIVE_FRAMES
&
startRegs
&
stackImg
)
;
lul
-
>
mStats
.
mContext
+
=
1
;
lul
-
>
mStats
.
mCFI
+
=
aNativeStack
.
mCount
-
1
-
framePointerFramesAcquired
;
lul
-
>
mStats
.
mFP
+
=
framePointerFramesAcquired
;
}
#
endif
#
ifdef
HAVE_NATIVE_UNWIND
static
void
DoNativeBacktrace
(
PSLockRef
aLock
const
RegisteredThread
&
aRegisteredThread
const
Registers
&
aRegs
NativeStack
&
aNativeStack
)
{
#
if
defined
(
USE_LUL_STACKWALK
)
DoLULBacktrace
(
aLock
aRegisteredThread
aRegs
aNativeStack
)
;
#
elif
defined
(
USE_EHABI_STACKWALK
)
DoEHABIBacktrace
(
aLock
aRegisteredThread
aRegs
aNativeStack
)
;
#
elif
defined
(
USE_FRAME_POINTER_STACK_WALK
)
DoFramePointerBacktrace
(
aLock
aRegisteredThread
aRegs
aNativeStack
)
;
#
elif
defined
(
USE_MOZ_STACK_WALK
)
DoMozStackWalkBacktrace
(
aLock
aRegisteredThread
aRegs
aNativeStack
)
;
#
else
#
error
"
Invalid
configuration
"
#
endif
}
#
endif
static
inline
void
DoSharedSample
(
PSLockRef
aLock
bool
aIsSynchronous
RegisteredThread
&
aRegisteredThread
const
Registers
&
aRegs
uint64_t
aSamplePos
uint64_t
aBufferRangeStart
ProfileBuffer
&
aBuffer
StackCaptureOptions
aCaptureOptions
=
StackCaptureOptions
:
:
Full
)
{
MOZ_ASSERT
(
!
aBuffer
.
IsThreadSafe
(
)
"
Mutexes
cannot
be
used
inside
this
critical
section
"
)
;
MOZ_RELEASE_ASSERT
(
ActivePS
:
:
Exists
(
aLock
)
)
;
ProfileBufferCollector
collector
(
aBuffer
aSamplePos
aBufferRangeStart
)
;
NativeStack
nativeStack
;
#
if
defined
(
HAVE_NATIVE_UNWIND
)
if
(
ActivePS
:
:
FeatureStackWalk
(
aLock
)
&
&
aCaptureOptions
=
=
StackCaptureOptions
:
:
Full
)
{
DoNativeBacktrace
(
aLock
aRegisteredThread
aRegs
nativeStack
)
;
MergeStacks
(
ActivePS
:
:
Features
(
aLock
)
aIsSynchronous
aRegisteredThread
aRegs
nativeStack
collector
)
;
}
else
#
endif
{
MergeStacks
(
ActivePS
:
:
Features
(
aLock
)
aIsSynchronous
aRegisteredThread
aRegs
nativeStack
collector
)
;
if
(
aCaptureOptions
=
=
StackCaptureOptions
:
:
Full
)
{
aBuffer
.
AddEntry
(
ProfileBufferEntry
:
:
NativeLeafAddr
(
(
void
*
)
aRegs
.
mPC
)
)
;
}
}
}
static
void
DoSyncSample
(
PSLockRef
aLock
RegisteredThread
&
aRegisteredThread
const
TimeStamp
&
aNow
const
Registers
&
aRegs
ProfileBuffer
&
aBuffer
StackCaptureOptions
aCaptureOptions
)
{
MOZ_ASSERT
(
aCaptureOptions
!
=
StackCaptureOptions
:
:
NoStack
"
DoSyncSample
should
not
be
called
when
no
capture
is
needed
"
)
;
const
uint64_t
bufferRangeStart
=
aBuffer
.
BufferRangeStart
(
)
;
const
uint64_t
samplePos
=
aBuffer
.
AddThreadIdEntry
(
aRegisteredThread
.
Info
(
)
-
>
ThreadId
(
)
)
;
TimeDuration
delta
=
aNow
-
CorePS
:
:
ProcessStartTime
(
)
;
aBuffer
.
AddEntry
(
ProfileBufferEntry
:
:
Time
(
delta
.
ToMilliseconds
(
)
)
)
;
DoSharedSample
(
aLock
true
aRegisteredThread
aRegs
samplePos
bufferRangeStart
aBuffer
aCaptureOptions
)
;
}
static
void
DoPeriodicSample
(
PSLockRef
aLock
RegisteredThread
&
aRegisteredThread
ProfiledThreadData
&
aProfiledThreadData
const
Registers
&
aRegs
uint64_t
aSamplePos
uint64_t
aBufferRangeStart
ProfileBuffer
&
aBuffer
)
{
DoSharedSample
(
aLock
false
aRegisteredThread
aRegs
aSamplePos
aBufferRangeStart
aBuffer
)
;
}
const
static
uint64_t
kJS_MAX_SAFE_UINTEGER
=
+
9007199254740991ULL
;
static
int64_t
SafeJSInteger
(
uint64_t
aValue
)
{
return
aValue
<
=
kJS_MAX_SAFE_UINTEGER
?
int64_t
(
aValue
)
:
-
1
;
}
static
void
AddSharedLibraryInfoToStream
(
JSONWriter
&
aWriter
const
SharedLibrary
&
aLib
)
{
aWriter
.
StartObjectElement
(
)
;
aWriter
.
IntProperty
(
"
start
"
SafeJSInteger
(
aLib
.
GetStart
(
)
)
)
;
aWriter
.
IntProperty
(
"
end
"
SafeJSInteger
(
aLib
.
GetEnd
(
)
)
)
;
aWriter
.
IntProperty
(
"
offset
"
SafeJSInteger
(
aLib
.
GetOffset
(
)
)
)
;
aWriter
.
StringProperty
(
"
name
"
aLib
.
GetModuleName
(
)
)
;
aWriter
.
StringProperty
(
"
path
"
aLib
.
GetModulePath
(
)
)
;
aWriter
.
StringProperty
(
"
debugName
"
aLib
.
GetDebugName
(
)
)
;
aWriter
.
StringProperty
(
"
debugPath
"
aLib
.
GetDebugPath
(
)
)
;
aWriter
.
StringProperty
(
"
breakpadId
"
aLib
.
GetBreakpadId
(
)
)
;
aWriter
.
StringProperty
(
"
arch
"
aLib
.
GetArch
(
)
)
;
aWriter
.
EndObject
(
)
;
}
void
AppendSharedLibraries
(
JSONWriter
&
aWriter
)
{
SharedLibraryInfo
info
=
SharedLibraryInfo
:
:
GetInfoForSelf
(
)
;
info
.
SortByAddress
(
)
;
for
(
size_t
i
=
0
;
i
<
info
.
GetSize
(
)
;
i
+
+
)
{
AddSharedLibraryInfoToStream
(
aWriter
info
.
GetEntry
(
i
)
)
;
}
}
static
void
StreamCategories
(
SpliceableJSONWriter
&
aWriter
)
{
#
define
CATEGORY_JSON_BEGIN_CATEGORY
(
name
labelAsString
color
)
\
aWriter
.
Start
(
)
;
\
aWriter
.
StringProperty
(
"
name
"
labelAsString
)
;
\
aWriter
.
StringProperty
(
"
color
"
color
)
;
\
aWriter
.
StartArrayProperty
(
"
subcategories
"
)
;
#
define
CATEGORY_JSON_SUBCATEGORY
(
supercategory
name
labelAsString
)
\
aWriter
.
StringElement
(
labelAsString
)
;
#
define
CATEGORY_JSON_END_CATEGORY
\
aWriter
.
EndArray
(
)
;
\
aWriter
.
EndObject
(
)
;
MOZ_PROFILING_CATEGORY_LIST
(
CATEGORY_JSON_BEGIN_CATEGORY
CATEGORY_JSON_SUBCATEGORY
CATEGORY_JSON_END_CATEGORY
)
#
undef
CATEGORY_JSON_BEGIN_CATEGORY
#
undef
CATEGORY_JSON_SUBCATEGORY
#
undef
CATEGORY_JSON_END_CATEGORY
}
static
void
StreamMarkerSchema
(
SpliceableJSONWriter
&
aWriter
)
{
Span
<
const
base_profiler_markers_detail
:
:
Streaming
:
:
MarkerTypeFunctions
>
markerTypeFunctionsArray
=
base_profiler_markers_detail
:
:
Streaming
:
:
MarkerTypeFunctionsArray
(
)
;
std
:
:
set
<
std
:
:
string
>
names
;
for
(
const
auto
&
markerTypeFunctions
:
markerTypeFunctionsArray
)
{
auto
name
=
markerTypeFunctions
.
mMarkerTypeNameFunction
(
)
;
const
bool
didInsert
=
names
.
insert
(
std
:
:
string
(
name
.
data
(
)
name
.
size
(
)
)
)
.
second
;
if
(
didInsert
)
{
markerTypeFunctions
.
mMarkerSchemaFunction
(
)
.
Stream
(
aWriter
name
)
;
}
}
}
static
int64_t
MicrosecondsSince1970
(
)
;
static
void
StreamMetaJSCustomObject
(
PSLockRef
aLock
SpliceableJSONWriter
&
aWriter
bool
aIsShuttingDown
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
&
&
ActivePS
:
:
Exists
(
aLock
)
)
;
aWriter
.
IntProperty
(
"
version
"
25
)
;
TimeDuration
delta
=
TimeStamp
:
:
Now
(
)
-
CorePS
:
:
ProcessStartTime
(
)
;
aWriter
.
DoubleProperty
(
"
startTime
"
MicrosecondsSince1970
(
)
/
1000
.
0
-
delta
.
ToMilliseconds
(
)
)
;
aWriter
.
DoubleProperty
(
"
profilingStartTime
"
(
ActivePS
:
:
ProfilingStartTime
(
)
-
CorePS
:
:
ProcessStartTime
(
)
)
.
ToMilliseconds
(
)
)
;
if
(
const
TimeStamp
contentEarliestTime
=
ActivePS
:
:
Buffer
(
aLock
)
.
UnderlyingChunkedBuffer
(
)
.
GetEarliestChunkStartTimeStamp
(
)
;
!
contentEarliestTime
.
IsNull
(
)
)
{
aWriter
.
DoubleProperty
(
"
contentEarliestTime
"
(
contentEarliestTime
-
CorePS
:
:
ProcessStartTime
(
)
)
.
ToMilliseconds
(
)
)
;
}
else
{
aWriter
.
NullProperty
(
"
contentEarliestTime
"
)
;
}
const
double
profilingEndTime
=
profiler_time
(
)
;
aWriter
.
DoubleProperty
(
"
profilingEndTime
"
profilingEndTime
)
;
if
(
aIsShuttingDown
)
{
aWriter
.
DoubleProperty
(
"
shutdownTime
"
profilingEndTime
)
;
}
else
{
aWriter
.
NullProperty
(
"
shutdownTime
"
)
;
}
aWriter
.
StartArrayProperty
(
"
categories
"
)
;
StreamCategories
(
aWriter
)
;
aWriter
.
EndArray
(
)
;
aWriter
.
StartArrayProperty
(
"
markerSchema
"
)
;
StreamMarkerSchema
(
aWriter
)
;
aWriter
.
EndArray
(
)
;
if
(
!
profiler_is_main_thread
(
)
)
{
return
;
}
aWriter
.
DoubleProperty
(
"
interval
"
ActivePS
:
:
Interval
(
aLock
)
)
;
aWriter
.
IntProperty
(
"
stackwalk
"
ActivePS
:
:
FeatureStackWalk
(
aLock
)
)
;
#
ifdef
DEBUG
aWriter
.
IntProperty
(
"
debug
"
1
)
;
#
else
aWriter
.
IntProperty
(
"
debug
"
0
)
;
#
endif
aWriter
.
IntProperty
(
"
gcpoison
"
0
)
;
aWriter
.
IntProperty
(
"
asyncstack
"
0
)
;
aWriter
.
IntProperty
(
"
processType
"
0
)
;
}
static
void
StreamPages
(
PSLockRef
aLock
SpliceableJSONWriter
&
aWriter
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
ActivePS
:
:
DiscardExpiredPages
(
aLock
)
;
for
(
const
auto
&
page
:
ActivePS
:
:
ProfiledPages
(
aLock
)
)
{
page
-
>
StreamJSON
(
aWriter
)
;
}
}
static
void
locked_profiler_stream_json_for_this_process
(
PSLockRef
aLock
SpliceableJSONWriter
&
aWriter
double
aSinceTime
bool
aIsShuttingDown
bool
aOnlyThreads
=
false
)
{
LOG
(
"
locked_profiler_stream_json_for_this_process
"
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
&
&
ActivePS
:
:
Exists
(
aLock
)
)
;
AUTO_PROFILER_STATS
(
base_locked_profiler_stream_json_for_this_process
)
;
const
double
collectionStartMs
=
profiler_time
(
)
;
ProfileBuffer
&
buffer
=
ActivePS
:
:
Buffer
(
aLock
)
;
Maybe
<
double
>
durationS
=
ActivePS
:
:
Duration
(
aLock
)
;
if
(
durationS
.
isSome
(
)
)
{
const
double
durationStartMs
=
collectionStartMs
-
*
durationS
*
1000
;
buffer
.
DiscardSamplesBeforeTime
(
durationStartMs
)
;
}
if
(
!
aOnlyThreads
)
{
aWriter
.
StartArrayProperty
(
"
libs
"
)
;
AppendSharedLibraries
(
aWriter
)
;
aWriter
.
EndArray
(
)
;
aWriter
.
StartObjectProperty
(
"
meta
"
)
;
{
StreamMetaJSCustomObject
(
aLock
aWriter
aIsShuttingDown
)
;
}
aWriter
.
EndObject
(
)
;
aWriter
.
StartArrayProperty
(
"
pages
"
)
;
{
StreamPages
(
aLock
aWriter
)
;
}
aWriter
.
EndArray
(
)
;
buffer
.
StreamProfilerOverheadToJSON
(
aWriter
CorePS
:
:
ProcessStartTime
(
)
aSinceTime
)
;
buffer
.
StreamCountersToJSON
(
aWriter
CorePS
:
:
ProcessStartTime
(
)
aSinceTime
)
;
aWriter
.
StartArrayProperty
(
"
threads
"
)
;
}
{
ActivePS
:
:
DiscardExpiredDeadProfiledThreads
(
aLock
)
;
Vector
<
std
:
:
pair
<
RegisteredThread
*
ProfiledThreadData
*
>
>
threads
=
ActivePS
:
:
ProfiledThreads
(
aLock
)
;
for
(
auto
&
thread
:
threads
)
{
ProfiledThreadData
*
profiledThreadData
=
thread
.
second
;
profiledThreadData
-
>
StreamJSON
(
buffer
aWriter
CorePS
:
:
ProcessName
(
aLock
)
CorePS
:
:
ETLDplus1
(
aLock
)
CorePS
:
:
ProcessStartTime
(
)
aSinceTime
)
;
}
}
if
(
!
aOnlyThreads
)
{
aWriter
.
EndArray
(
)
;
aWriter
.
StartArrayProperty
(
"
pausedRanges
"
)
;
{
buffer
.
StreamPausedRangesToJSON
(
aWriter
aSinceTime
)
;
}
aWriter
.
EndArray
(
)
;
}
const
double
collectionEndMs
=
profiler_time
(
)
;
buffer
.
AddEntry
(
ProfileBufferEntry
:
:
CollectionStart
(
collectionStartMs
)
)
;
buffer
.
AddEntry
(
ProfileBufferEntry
:
:
CollectionEnd
(
collectionEndMs
)
)
;
}
bool
profiler_stream_json_for_this_process
(
SpliceableJSONWriter
&
aWriter
double
aSinceTime
bool
aIsShuttingDown
bool
aOnlyThreads
)
{
LOG
(
"
profiler_stream_json_for_this_process
"
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
false
;
}
locked_profiler_stream_json_for_this_process
(
lock
aWriter
aSinceTime
aIsShuttingDown
aOnlyThreads
)
;
return
true
;
}
static
char
FeatureCategory
(
uint32_t
aFeature
)
{
if
(
aFeature
&
DefaultFeatures
(
)
)
{
if
(
aFeature
&
AvailableFeatures
(
)
)
{
return
'
D
'
;
}
return
'
d
'
;
}
if
(
aFeature
&
StartupExtraDefaultFeatures
(
)
)
{
if
(
aFeature
&
AvailableFeatures
(
)
)
{
return
'
S
'
;
}
return
'
s
'
;
}
if
(
aFeature
&
AvailableFeatures
(
)
)
{
return
'
-
'
;
}
return
'
x
'
;
}
static
void
PrintUsage
(
)
{
PrintToConsole
(
"
\
n
"
"
Profiler
environment
variable
usage
:
\
n
"
"
\
n
"
"
MOZ_BASE_PROFILER_HELP
\
n
"
"
If
set
to
any
value
prints
this
message
.
\
n
"
"
(
Only
BaseProfiler
features
are
known
here
;
Use
MOZ_PROFILER_HELP
\
n
"
"
for
Gecko
Profiler
help
with
more
features
)
.
\
n
"
"
\
n
"
"
MOZ_BASE_PROFILER_
{
DEBUG_
VERBOSE
}
LOGGING
\
n
"
"
Enables
BaseProfiler
logging
to
stdout
.
The
levels
of
logging
\
n
"
"
available
are
MOZ_BASE_PROFILER_LOGGING
'
(
least
verbose
)
\
n
"
"
'
.
.
.
_DEBUG_LOGGING
'
'
.
.
.
_VERBOSE_LOGGING
'
(
most
verbose
)
\
n
"
"
\
n
"
"
MOZ_PROFILER_STARTUP
\
n
"
"
If
set
to
any
value
other
than
'
'
or
'
0
'
/
'
N
'
/
'
n
'
starts
the
\
n
"
"
profiler
immediately
on
start
-
up
.
\
n
"
"
Useful
if
you
want
profile
code
that
runs
very
early
.
\
n
"
"
\
n
"
"
MOZ_PROFILER_STARTUP_ENTRIES
=
<
%
u
.
.
%
u
>
\
n
"
"
If
MOZ_PROFILER_STARTUP
is
set
specifies
the
number
of
entries
\
n
"
"
per
process
in
the
profiler
'
s
circular
buffer
when
the
profiler
is
\
n
"
"
first
started
.
\
n
"
"
If
unset
the
platform
default
is
used
:
\
n
"
"
%
u
entries
per
process
or
%
u
when
MOZ_PROFILER_STARTUP
is
set
.
\
n
"
"
(
%
u
bytes
per
entry
-
>
%
u
or
%
u
total
bytes
per
process
)
\
n
"
"
Optional
units
in
bytes
:
KB
KiB
MB
MiB
GB
GiB
\
n
"
"
\
n
"
"
MOZ_PROFILER_STARTUP_DURATION
=
<
1
.
.
>
\
n
"
"
If
MOZ_PROFILER_STARTUP
is
set
specifies
the
maximum
life
time
\
n
"
"
of
entries
in
the
the
profiler
'
s
circular
buffer
when
the
profiler
\
n
"
"
is
first
started
in
seconds
.
\
n
"
"
If
unset
the
life
time
of
the
entries
will
only
be
restricted
by
\
n
"
"
MOZ_PROFILER_STARTUP_ENTRIES
(
or
its
default
value
)
and
no
\
n
"
"
additional
time
duration
restriction
will
be
applied
.
\
n
"
"
\
n
"
"
MOZ_PROFILER_STARTUP_INTERVAL
=
<
1
.
.
1000
>
\
n
"
"
If
MOZ_PROFILER_STARTUP
is
set
specifies
the
sample
interval
\
n
"
"
measured
in
milliseconds
when
the
profiler
is
first
started
.
\
n
"
"
If
unset
the
platform
default
is
used
.
\
n
"
"
\
n
"
"
MOZ_PROFILER_STARTUP_FEATURES_BITFIELD
=
<
Number
>
\
n
"
"
If
MOZ_PROFILER_STARTUP
is
set
specifies
the
profiling
\
n
"
"
features
as
the
integer
value
of
the
features
bitfield
.
\
n
"
"
If
unset
the
value
from
MOZ_PROFILER_STARTUP_FEATURES
is
used
.
\
n
"
"
\
n
"
"
MOZ_PROFILER_STARTUP_FEATURES
=
<
Features
>
\
n
"
"
If
MOZ_PROFILER_STARTUP
is
set
specifies
the
profiling
\
n
"
"
features
as
a
comma
-
separated
list
of
strings
.
\
n
"
"
Ignored
if
MOZ_PROFILER_STARTUP_FEATURES_BITFIELD
is
set
.
\
n
"
"
If
unset
the
platform
default
is
used
.
\
n
"
"
\
n
"
"
Features
:
(
x
=
unavailable
D
/
d
=
default
/
unavailable
\
n
"
"
S
/
s
=
MOZ_PROFILER_STARTUP
extra
"
"
default
/
unavailable
)
\
n
"
unsigned
(
ActivePS
:
:
scMinimumBufferEntries
)
unsigned
(
ActivePS
:
:
scMaximumBufferEntries
)
unsigned
(
BASE_PROFILER_DEFAULT_ENTRIES
.
Value
(
)
)
unsigned
(
BASE_PROFILER_DEFAULT_STARTUP_ENTRIES
.
Value
(
)
)
unsigned
(
scBytesPerEntry
)
unsigned
(
BASE_PROFILER_DEFAULT_ENTRIES
.
Value
(
)
*
scBytesPerEntry
)
unsigned
(
BASE_PROFILER_DEFAULT_STARTUP_ENTRIES
.
Value
(
)
*
scBytesPerEntry
)
)
;
#
define
PRINT_FEATURE
(
n_
str_
Name_
desc_
)
\
PrintToConsole
(
"
%
c
%
7u
:
\
"
%
s
\
"
(
%
s
)
\
n
"
\
FeatureCategory
(
ProfilerFeature
:
:
Name_
)
\
ProfilerFeature
:
:
Name_
str_
desc_
)
;
BASE_PROFILER_FOR_EACH_FEATURE
(
PRINT_FEATURE
)
#
undef
PRINT_FEATURE
PrintToConsole
(
"
-
\
"
default
\
"
(
All
above
D
+
S
defaults
)
\
n
"
"
\
n
"
"
MOZ_PROFILER_STARTUP_FILTERS
=
<
Filters
>
\
n
"
"
If
MOZ_PROFILER_STARTUP
is
set
specifies
the
thread
filters
as
"
"
a
\
n
"
"
comma
-
separated
list
of
strings
.
A
given
thread
will
be
sampled
if
\
n
"
"
any
of
the
filters
is
a
case
-
insensitive
substring
of
the
thread
\
n
"
"
name
.
If
unset
a
default
is
used
.
\
n
"
"
\
n
"
"
MOZ_PROFILER_SHUTDOWN
\
n
"
"
If
set
the
profiler
saves
a
profile
to
the
named
file
on
shutdown
.
\
n
"
"
\
n
"
"
MOZ_PROFILER_SYMBOLICATE
\
n
"
"
If
set
the
profiler
will
pre
-
symbolicate
profiles
.
\
n
"
"
*
Note
*
This
will
add
a
significant
pause
when
gathering
data
and
\
n
"
"
is
intended
mainly
for
local
development
.
\
n
"
"
\
n
"
"
MOZ_PROFILER_LUL_TEST
\
n
"
"
If
set
to
any
value
runs
LUL
unit
tests
at
startup
.
\
n
"
"
\
n
"
"
This
platform
%
s
native
unwinding
.
\
n
"
"
\
n
"
#
if
defined
(
HAVE_NATIVE_UNWIND
)
"
supports
"
#
else
"
does
not
support
"
#
endif
)
;
}
#
if
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_android
)
struct
SigHandlerCoordinator
;
#
endif
class
Sampler
{
public
:
explicit
Sampler
(
PSLockRef
aLock
)
;
void
Disable
(
PSLockRef
aLock
)
;
template
<
typename
Func
>
void
SuspendAndSampleAndResumeThread
(
PSLockRef
aLock
const
RegisteredThread
&
aRegisteredThread
const
TimeStamp
&
aNow
const
Func
&
aProcessRegs
)
;
private
:
#
if
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_android
)
|
|
defined
(
GP_OS_freebsd
)
struct
sigaction
mOldSigprofHandler
;
BaseProfilerProcessId
mMyPid
;
BaseProfilerThreadId
mSamplerTid
;
public
:
static
struct
SigHandlerCoordinator
*
sSigHandlerCoordinator
;
#
endif
}
;
class
SamplerThread
{
public
:
SamplerThread
(
PSLockRef
aLock
uint32_t
aActivityGeneration
double
aIntervalMilliseconds
uint32_t
aFeatures
)
;
~
SamplerThread
(
)
;
void
Run
(
)
;
void
Stop
(
PSLockRef
aLock
)
;
private
:
void
SleepMicro
(
uint32_t
aMicroseconds
)
;
Sampler
mSampler
;
const
uint32_t
mActivityGeneration
;
const
int
mIntervalMicroseconds
;
#
if
defined
(
GP_OS_windows
)
HANDLE
mThread
;
#
elif
defined
(
GP_OS_darwin
)
|
|
defined
(
GP_OS_linux
)
|
|
\
defined
(
GP_OS_android
)
|
|
defined
(
GP_OS_freebsd
)
pthread_t
mThread
;
#
endif
#
if
defined
(
GP_OS_windows
)
bool
mNoTimerResolutionChange
=
true
;
#
endif
SamplerThread
(
const
SamplerThread
&
)
=
delete
;
void
operator
=
(
const
SamplerThread
&
)
=
delete
;
}
;
static
SamplerThread
*
NewSamplerThread
(
PSLockRef
aLock
uint32_t
aGeneration
double
aInterval
uint32_t
aFeatures
)
{
return
new
SamplerThread
(
aLock
aGeneration
aInterval
aFeatures
)
;
}
void
SamplerThread
:
:
Run
(
)
{
const
uint32_t
features
=
[
]
(
)
-
>
uint32_t
{
PSAutoLock
lock
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
0
;
}
return
ActivePS
:
:
Features
(
lock
)
;
}
(
)
;
const
bool
stackSampling
=
!
ProfilerFeature
:
:
HasNoStackSampling
(
features
)
;
ProfileBufferChunkManagerSingle
localChunkManager
(
ProfileBufferChunkManager
:
:
scExpectedMaximumStackSize
)
;
ProfileChunkedBuffer
localBuffer
(
ProfileChunkedBuffer
:
:
ThreadSafety
:
:
WithoutMutex
localChunkManager
)
;
ProfileBuffer
localProfileBuffer
(
localBuffer
)
;
auto
previousState
=
localBuffer
.
GetState
(
)
;
TimeDuration
lastSleepOvershoot
=
0
;
TimeStamp
sampleStart
=
TimeStamp
:
:
Now
(
)
;
while
(
true
)
{
{
PSAutoLock
lock
;
TimeStamp
lockAcquired
=
TimeStamp
:
:
Now
(
)
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
;
}
if
(
ActivePS
:
:
Generation
(
lock
)
!
=
mActivityGeneration
)
{
return
;
}
ActivePS
:
:
ClearExpiredExitProfiles
(
lock
)
;
TimeStamp
expiredMarkersCleaned
=
TimeStamp
:
:
Now
(
)
;
if
(
int
(
gSkipSampling
)
<
=
0
&
&
!
ActivePS
:
:
IsSamplingPaused
(
lock
)
)
{
TimeDuration
delta
=
sampleStart
-
CorePS
:
:
ProcessStartTime
(
)
;
ProfileBuffer
&
buffer
=
ActivePS
:
:
Buffer
(
lock
)
;
const
Vector
<
BaseProfilerCount
*
>
&
counters
=
CorePS
:
:
Counters
(
lock
)
;
for
(
auto
&
counter
:
counters
)
{
buffer
.
AddEntry
(
ProfileBufferEntry
:
:
CounterId
(
counter
)
)
;
buffer
.
AddEntry
(
ProfileBufferEntry
:
:
Time
(
delta
.
ToMilliseconds
(
)
)
)
;
int64_t
count
;
uint64_t
number
;
counter
-
>
Sample
(
count
number
)
;
buffer
.
AddEntry
(
ProfileBufferEntry
:
:
CounterKey
(
0
)
)
;
buffer
.
AddEntry
(
ProfileBufferEntry
:
:
Count
(
count
)
)
;
if
(
number
)
{
buffer
.
AddEntry
(
ProfileBufferEntry
:
:
Number
(
number
)
)
;
}
}
TimeStamp
countersSampled
=
TimeStamp
:
:
Now
(
)
;
if
(
stackSampling
)
{
const
Vector
<
LiveProfiledThreadData
>
&
liveThreads
=
ActivePS
:
:
LiveProfiledThreads
(
lock
)
;
for
(
auto
&
thread
:
liveThreads
)
{
RegisteredThread
*
registeredThread
=
thread
.
mRegisteredThread
;
ProfiledThreadData
*
profiledThreadData
=
thread
.
mProfiledThreadData
.
get
(
)
;
RefPtr
<
ThreadInfo
>
info
=
registeredThread
-
>
Info
(
)
;
if
(
registeredThread
-
>
RacyRegisteredThread
(
)
.
CanDuplicateLastSampleDueToSleep
(
)
)
{
bool
dup_ok
=
ActivePS
:
:
Buffer
(
lock
)
.
DuplicateLastSample
(
info
-
>
ThreadId
(
)
CorePS
:
:
ProcessStartTime
(
)
profiledThreadData
-
>
LastSample
(
)
)
;
if
(
dup_ok
)
{
continue
;
}
}
AUTO_PROFILER_STATS
(
base_SamplerThread_Run_DoPeriodicSample
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
const
uint64_t
bufferRangeStart
=
buffer
.
BufferRangeStart
(
)
;
const
uint64_t
samplePos
=
buffer
.
AddThreadIdEntry
(
registeredThread
-
>
Info
(
)
-
>
ThreadId
(
)
)
;
profiledThreadData
-
>
LastSample
(
)
=
Some
(
samplePos
)
;
TimeDuration
delta
=
now
-
CorePS
:
:
ProcessStartTime
(
)
;
buffer
.
AddEntry
(
ProfileBufferEntry
:
:
Time
(
delta
.
ToMilliseconds
(
)
)
)
;
mSampler
.
SuspendAndSampleAndResumeThread
(
lock
*
registeredThread
now
[
&
]
(
const
Registers
&
aRegs
const
TimeStamp
&
aNow
)
{
DoPeriodicSample
(
lock
*
registeredThread
*
profiledThreadData
aRegs
samplePos
bufferRangeStart
localProfileBuffer
)
;
}
)
;
auto
state
=
localBuffer
.
GetState
(
)
;
if
(
state
.
mClearedBlockCount
!
=
previousState
.
mClearedBlockCount
)
{
LOG
(
"
Stack
sample
too
big
for
local
storage
needed
%
u
bytes
"
unsigned
(
state
.
mRangeEnd
-
previousState
.
mRangeEnd
)
)
;
}
else
if
(
state
.
mRangeEnd
-
previousState
.
mRangeEnd
>
=
*
profiler_get_core_buffer
(
)
.
BufferLength
(
)
)
{
LOG
(
"
Stack
sample
too
big
for
profiler
storage
needed
%
u
bytes
"
unsigned
(
state
.
mRangeEnd
-
previousState
.
mRangeEnd
)
)
;
}
else
{
profiler_get_core_buffer
(
)
.
AppendContents
(
localBuffer
)
;
}
localBuffer
.
Clear
(
)
;
previousState
=
localBuffer
.
GetState
(
)
;
}
}
#
if
defined
(
USE_LUL_STACKWALK
)
lul
:
:
LUL
*
lul
=
CorePS
:
:
Lul
(
lock
)
;
if
(
lul
)
{
lul
-
>
MaybeShowStats
(
)
;
}
#
endif
TimeStamp
threadsSampled
=
TimeStamp
:
:
Now
(
)
;
{
AUTO_PROFILER_STATS
(
Sampler_FulfillChunkRequests
)
;
ActivePS
:
:
FulfillChunkRequests
(
lock
)
;
}
buffer
.
CollectOverheadStats
(
delta
lockAcquired
-
sampleStart
expiredMarkersCleaned
-
lockAcquired
countersSampled
-
expiredMarkersCleaned
threadsSampled
-
countersSampled
)
;
}
}
TimeStamp
targetSleepEndTime
=
sampleStart
+
TimeDuration
:
:
FromMicroseconds
(
mIntervalMicroseconds
)
;
TimeStamp
beforeSleep
=
TimeStamp
:
:
Now
(
)
;
TimeDuration
targetSleepDuration
=
targetSleepEndTime
-
beforeSleep
;
double
sleepTime
=
std
:
:
max
(
0
.
0
(
targetSleepDuration
-
lastSleepOvershoot
)
.
ToMicroseconds
(
)
)
;
SleepMicro
(
static_cast
<
uint32_t
>
(
sleepTime
)
)
;
sampleStart
=
TimeStamp
:
:
Now
(
)
;
lastSleepOvershoot
=
sampleStart
-
(
beforeSleep
+
TimeDuration
:
:
FromMicroseconds
(
sleepTime
)
)
;
}
}
}
}
#
if
defined
(
GP_OS_windows
)
#
include
"
platform
-
win32
.
cpp
"
#
elif
defined
(
GP_OS_darwin
)
#
include
"
platform
-
macos
.
cpp
"
#
elif
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_android
)
|
|
defined
(
GP_OS_freebsd
)
#
include
"
platform
-
linux
-
android
.
cpp
"
#
else
#
error
"
bad
platform
"
#
endif
namespace
mozilla
{
namespace
baseprofiler
{
UniquePlatformData
AllocPlatformData
(
BaseProfilerThreadId
aThreadId
)
{
return
UniquePlatformData
(
new
PlatformData
(
aThreadId
)
)
;
}
void
PlatformDataDestructor
:
:
operator
(
)
(
PlatformData
*
aData
)
{
delete
aData
;
}
static
uint32_t
ParseFeature
(
const
char
*
aFeature
bool
aIsStartup
)
{
if
(
strcmp
(
aFeature
"
default
"
)
=
=
0
)
{
return
(
aIsStartup
?
(
DefaultFeatures
(
)
|
StartupExtraDefaultFeatures
(
)
)
:
DefaultFeatures
(
)
)
&
AvailableFeatures
(
)
;
}
#
define
PARSE_FEATURE_BIT
(
n_
str_
Name_
desc_
)
\
if
(
strcmp
(
aFeature
str_
)
=
=
0
)
{
\
return
ProfilerFeature
:
:
Name_
;
\
}
BASE_PROFILER_FOR_EACH_FEATURE
(
PARSE_FEATURE_BIT
)
#
undef
PARSE_FEATURE_BIT
PrintToConsole
(
"
\
nUnrecognized
feature
\
"
%
s
\
"
.
\
n
\
n
"
aFeature
)
;
PrintUsage
(
)
;
return
0
;
}
uint32_t
ParseFeaturesFromStringArray
(
const
char
*
*
aFeatures
uint32_t
aFeatureCount
bool
aIsStartup
)
{
uint32_t
features
=
0
;
for
(
size_t
i
=
0
;
i
<
aFeatureCount
;
i
+
+
)
{
features
|
=
ParseFeature
(
aFeatures
[
i
]
aIsStartup
)
;
}
return
features
;
}
static
RegisteredThread
*
FindCurrentThreadRegisteredThread
(
PSLockRef
aLock
)
{
BaseProfilerThreadId
id
=
profiler_current_thread_id
(
)
;
const
Vector
<
UniquePtr
<
RegisteredThread
>
>
&
registeredThreads
=
CorePS
:
:
RegisteredThreads
(
aLock
)
;
for
(
auto
&
registeredThread
:
registeredThreads
)
{
if
(
registeredThread
-
>
Info
(
)
-
>
ThreadId
(
)
=
=
id
)
{
return
registeredThread
.
get
(
)
;
}
}
return
nullptr
;
}
static
ProfilingStack
*
locked_register_thread
(
PSLockRef
aLock
const
char
*
aName
void
*
aStackTop
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
MOZ_ASSERT
(
!
FindCurrentThreadRegisteredThread
(
aLock
)
)
;
VTUNE_REGISTER_THREAD
(
aName
)
;
if
(
!
TLSRegisteredThread
:
:
Init
(
aLock
)
)
{
return
nullptr
;
}
RefPtr
<
ThreadInfo
>
info
=
new
ThreadInfo
(
aName
profiler_current_thread_id
(
)
profiler_is_main_thread
(
)
)
;
UniquePtr
<
RegisteredThread
>
registeredThread
=
MakeUnique
<
RegisteredThread
>
(
info
aStackTop
)
;
TLSRegisteredThread
:
:
SetRegisteredThread
(
aLock
registeredThread
.
get
(
)
)
;
if
(
ActivePS
:
:
Exists
(
aLock
)
&
&
ActivePS
:
:
ShouldProfileThread
(
aLock
info
)
)
{
registeredThread
-
>
RacyRegisteredThread
(
)
.
SetIsBeingProfiled
(
true
)
;
ActivePS
:
:
AddLiveProfiledThread
(
aLock
registeredThread
.
get
(
)
MakeUnique
<
ProfiledThreadData
>
(
info
)
)
;
}
ProfilingStack
*
profilingStack
=
&
registeredThread
-
>
RacyRegisteredThread
(
)
.
ProfilingStack
(
)
;
CorePS
:
:
AppendRegisteredThread
(
aLock
std
:
:
move
(
registeredThread
)
)
;
return
profilingStack
;
}
static
void
locked_profiler_start
(
PSLockRef
aLock
PowerOfTwo32
aCapacity
double
aInterval
uint32_t
aFeatures
const
char
*
*
aFilters
uint32_t
aFilterCount
const
Maybe
<
double
>
&
aDuration
)
;
static
Vector
<
const
char
*
>
SplitAtCommas
(
const
char
*
aString
UniquePtr
<
char
[
]
>
&
aStorage
)
{
size_t
len
=
strlen
(
aString
)
;
aStorage
=
MakeUnique
<
char
[
]
>
(
len
+
1
)
;
PodCopy
(
aStorage
.
get
(
)
aString
len
+
1
)
;
Vector
<
const
char
*
>
array
;
size_t
currentElementStart
=
0
;
for
(
size_t
i
=
0
;
i
<
=
len
;
i
+
+
)
{
if
(
aStorage
[
i
]
=
=
'
'
)
{
aStorage
[
i
]
=
'
\
0
'
;
}
if
(
aStorage
[
i
]
=
=
'
\
0
'
)
{
if
(
currentElementStart
!
=
i
)
{
MOZ_RELEASE_ASSERT
(
array
.
append
(
&
aStorage
[
currentElementStart
]
)
)
;
}
currentElementStart
=
i
+
1
;
}
}
return
array
;
}
static
const
char
*
get_size_suffix
(
const
char
*
str
)
{
const
char
*
ptr
=
str
;
while
(
isdigit
(
*
ptr
)
)
{
ptr
+
+
;
}
return
ptr
;
}
void
profiler_init
(
void
*
aStackTop
)
{
LOG
(
"
profiler_init
"
)
;
profiler_init_main_thread_id
(
)
;
VTUNE_INIT
(
)
;
MOZ_RELEASE_ASSERT
(
!
CorePS
:
:
Exists
(
)
)
;
if
(
getenv
(
"
MOZ_BASE_PROFILER_HELP
"
)
)
{
PrintUsage
(
)
;
exit
(
0
)
;
}
SharedLibraryInfo
:
:
Initialize
(
)
;
uint32_t
features
=
DefaultFeatures
(
)
&
AvailableFeatures
(
)
;
UniquePtr
<
char
[
]
>
filterStorage
;
Vector
<
const
char
*
>
filters
;
MOZ_RELEASE_ASSERT
(
filters
.
append
(
kMainThreadName
)
)
;
PowerOfTwo32
capacity
=
BASE_PROFILER_DEFAULT_ENTRIES
;
Maybe
<
double
>
duration
=
Nothing
(
)
;
double
interval
=
BASE_PROFILER_DEFAULT_INTERVAL
;
{
PSAutoLock
lock
;
CorePS
:
:
Create
(
lock
)
;
Unused
<
<
locked_register_thread
(
lock
kMainThreadName
aStackTop
)
;
PlatformInit
(
lock
)
;
const
char
*
startupEnv
=
getenv
(
"
MOZ_PROFILER_STARTUP
"
)
;
if
(
!
startupEnv
|
|
startupEnv
[
0
]
=
=
'
\
0
'
|
|
(
(
startupEnv
[
0
]
=
=
'
0
'
|
|
startupEnv
[
0
]
=
=
'
N
'
|
|
startupEnv
[
0
]
=
=
'
n
'
)
&
&
startupEnv
[
1
]
=
=
'
\
0
'
)
)
{
return
;
}
if
(
getenv
(
"
MOZ_PROFILER_STARTUP_NO_BASE
"
)
)
{
return
;
}
LOG
(
"
-
MOZ_PROFILER_STARTUP
is
set
"
)
;
capacity
=
BASE_PROFILER_DEFAULT_STARTUP_ENTRIES
;
const
char
*
startupCapacity
=
getenv
(
"
MOZ_PROFILER_STARTUP_ENTRIES
"
)
;
if
(
startupCapacity
&
&
startupCapacity
[
0
]
!
=
'
\
0
'
)
{
errno
=
0
;
long
capacityLong
=
strtol
(
startupCapacity
nullptr
10
)
;
std
:
:
string_view
sizeSuffix
=
get_size_suffix
(
startupCapacity
)
;
if
(
sizeSuffix
=
=
"
KB
"
)
{
capacityLong
*
=
1000
/
scBytesPerEntry
;
}
else
if
(
sizeSuffix
=
=
"
KiB
"
)
{
capacityLong
*
=
1024
/
scBytesPerEntry
;
}
else
if
(
sizeSuffix
=
=
"
MB
"
)
{
capacityLong
*
=
(
1000
*
1000
)
/
scBytesPerEntry
;
}
else
if
(
sizeSuffix
=
=
"
MiB
"
)
{
capacityLong
*
=
(
1024
*
1024
)
/
scBytesPerEntry
;
}
else
if
(
sizeSuffix
=
=
"
GB
"
)
{
capacityLong
*
=
(
1000
*
1000
*
1000
)
/
scBytesPerEntry
;
}
else
if
(
sizeSuffix
=
=
"
GiB
"
)
{
capacityLong
*
=
(
1024
*
1024
*
1024
)
/
scBytesPerEntry
;
}
else
if
(
!
sizeSuffix
.
empty
(
)
)
{
PrintToConsole
(
"
-
MOZ_PROFILER_STARTUP_ENTRIES
unit
must
be
one
of
the
"
"
following
:
KB
KiB
MB
MiB
GB
GiB
"
)
;
PrintUsage
(
)
;
exit
(
1
)
;
}
if
(
errno
=
=
0
&
&
capacityLong
>
0
&
&
static_cast
<
uint64_t
>
(
capacityLong
)
<
=
static_cast
<
uint64_t
>
(
INT32_MAX
)
)
{
capacity
=
PowerOfTwo32
(
ActivePS
:
:
ClampToAllowedEntries
(
static_cast
<
uint32_t
>
(
capacityLong
)
)
)
;
LOG
(
"
-
MOZ_PROFILER_STARTUP_ENTRIES
=
%
u
"
unsigned
(
capacity
.
Value
(
)
)
)
;
}
else
{
PrintToConsole
(
"
-
MOZ_PROFILER_STARTUP_ENTRIES
not
a
valid
integer
:
%
s
"
startupCapacity
)
;
PrintUsage
(
)
;
exit
(
1
)
;
}
}
const
char
*
startupDuration
=
getenv
(
"
MOZ_PROFILER_STARTUP_DURATION
"
)
;
if
(
startupDuration
&
&
startupDuration
[
0
]
!
=
'
\
0
'
)
{
auto
durationVal
=
StringToDouble
(
std
:
:
string
(
startupDuration
)
)
;
if
(
durationVal
&
&
*
durationVal
>
=
0
.
0
)
{
if
(
*
durationVal
>
0
.
0
)
{
duration
=
Some
(
*
durationVal
)
;
}
LOG
(
"
-
MOZ_PROFILER_STARTUP_DURATION
=
%
f
"
*
durationVal
)
;
}
else
{
PrintToConsole
(
"
-
MOZ_PROFILER_STARTUP_DURATION
not
a
valid
float
:
%
s
"
startupDuration
)
;
PrintUsage
(
)
;
exit
(
1
)
;
}
}
const
char
*
startupInterval
=
getenv
(
"
MOZ_PROFILER_STARTUP_INTERVAL
"
)
;
if
(
startupInterval
&
&
startupInterval
[
0
]
!
=
'
\
0
'
)
{
auto
intervalValue
=
StringToDouble
(
MakeStringSpan
(
startupInterval
)
)
;
if
(
intervalValue
&
&
*
intervalValue
>
0
.
0
&
&
*
intervalValue
<
=
1000
.
0
)
{
interval
=
*
intervalValue
;
LOG
(
"
-
MOZ_PROFILER_STARTUP_INTERVAL
=
%
f
"
interval
)
;
}
else
{
PrintToConsole
(
"
-
MOZ_PROFILER_STARTUP_INTERVAL
not
a
valid
float
:
%
s
"
startupInterval
)
;
PrintUsage
(
)
;
exit
(
1
)
;
}
}
features
|
=
StartupExtraDefaultFeatures
(
)
&
AvailableFeatures
(
)
;
const
char
*
startupFeaturesBitfield
=
getenv
(
"
MOZ_PROFILER_STARTUP_FEATURES_BITFIELD
"
)
;
if
(
startupFeaturesBitfield
&
&
startupFeaturesBitfield
[
0
]
!
=
'
\
0
'
)
{
errno
=
0
;
features
=
strtol
(
startupFeaturesBitfield
nullptr
10
)
;
if
(
errno
=
=
0
)
{
LOG
(
"
-
MOZ_PROFILER_STARTUP_FEATURES_BITFIELD
=
%
d
"
features
)
;
}
else
{
PrintToConsole
(
"
-
MOZ_PROFILER_STARTUP_FEATURES_BITFIELD
not
a
valid
integer
:
%
s
"
startupFeaturesBitfield
)
;
PrintUsage
(
)
;
exit
(
1
)
;
}
}
else
{
const
char
*
startupFeatures
=
getenv
(
"
MOZ_PROFILER_STARTUP_FEATURES
"
)
;
if
(
startupFeatures
)
{
UniquePtr
<
char
[
]
>
featureStringStorage
;
Vector
<
const
char
*
>
featureStringArray
=
SplitAtCommas
(
startupFeatures
featureStringStorage
)
;
features
=
ParseFeaturesFromStringArray
(
featureStringArray
.
begin
(
)
featureStringArray
.
length
(
)
true
)
;
LOG
(
"
-
MOZ_PROFILER_STARTUP_FEATURES
=
%
d
"
features
)
;
}
}
const
char
*
startupFilters
=
getenv
(
"
MOZ_PROFILER_STARTUP_FILTERS
"
)
;
if
(
startupFilters
&
&
startupFilters
[
0
]
!
=
'
\
0
'
)
{
filters
=
SplitAtCommas
(
startupFilters
filterStorage
)
;
LOG
(
"
-
MOZ_PROFILER_STARTUP_FILTERS
=
%
s
"
startupFilters
)
;
if
(
mozilla
:
:
profiler
:
:
detail
:
:
FiltersExcludePid
(
filters
)
)
{
LOG
(
"
-
>
This
process
is
excluded
and
won
'
t
be
profiled
"
)
;
return
;
}
}
locked_profiler_start
(
lock
capacity
interval
features
filters
.
begin
(
)
filters
.
length
(
)
duration
)
;
}
}
static
void
locked_profiler_save_profile_to_file
(
PSLockRef
aLock
const
char
*
aFilename
bool
aIsShuttingDown
)
;
static
SamplerThread
*
locked_profiler_stop
(
PSLockRef
aLock
)
;
void
profiler_shutdown
(
)
{
LOG
(
"
profiler_shutdown
"
)
;
VTUNE_SHUTDOWN
(
)
;
MOZ_RELEASE_ASSERT
(
profiler_is_main_thread
(
)
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
SamplerThread
*
samplerThread
=
nullptr
;
{
PSAutoLock
lock
;
if
(
ActivePS
:
:
Exists
(
lock
)
)
{
const
char
*
filename
=
getenv
(
"
MOZ_PROFILER_SHUTDOWN
"
)
;
if
(
filename
&
&
filename
[
0
]
!
=
'
\
0
'
)
{
locked_profiler_save_profile_to_file
(
lock
filename
true
)
;
}
samplerThread
=
locked_profiler_stop
(
lock
)
;
}
CorePS
:
:
Destroy
(
lock
)
;
TLSRegisteredThread
:
:
SetRegisteredThread
(
lock
nullptr
)
;
}
if
(
samplerThread
)
{
delete
samplerThread
;
}
}
static
bool
WriteProfileToJSONWriter
(
SpliceableChunkedJSONWriter
&
aWriter
double
aSinceTime
bool
aIsShuttingDown
bool
aOnlyThreads
=
false
)
{
LOG
(
"
WriteProfileToJSONWriter
"
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
if
(
!
aOnlyThreads
)
{
aWriter
.
Start
(
)
;
{
if
(
!
profiler_stream_json_for_this_process
(
aWriter
aSinceTime
aIsShuttingDown
aOnlyThreads
)
)
{
return
false
;
}
aWriter
.
StartArrayProperty
(
"
processes
"
)
;
aWriter
.
EndArray
(
)
;
}
aWriter
.
End
(
)
;
}
else
{
aWriter
.
StartBareList
(
)
;
if
(
!
profiler_stream_json_for_this_process
(
aWriter
aSinceTime
aIsShuttingDown
aOnlyThreads
)
)
{
return
false
;
}
aWriter
.
EndBareList
(
)
;
}
return
true
;
}
void
profiler_set_process_name
(
const
std
:
:
string
&
aProcessName
const
std
:
:
string
*
aETLDplus1
)
{
LOG
(
"
profiler_set_process_name
(
\
"
%
s
\
"
\
"
%
s
\
"
)
"
aProcessName
.
c_str
(
)
aETLDplus1
?
aETLDplus1
-
>
c_str
(
)
:
"
<
none
>
"
)
;
PSAutoLock
lock
;
CorePS
:
:
SetProcessName
(
lock
aProcessName
)
;
if
(
aETLDplus1
)
{
CorePS
:
:
SetETLDplus1
(
lock
*
aETLDplus1
)
;
}
}
UniquePtr
<
char
[
]
>
profiler_get_profile
(
double
aSinceTime
bool
aIsShuttingDown
bool
aOnlyThreads
)
{
LOG
(
"
profiler_get_profile
"
)
;
SpliceableChunkedJSONWriter
b
;
if
(
!
WriteProfileToJSONWriter
(
b
aSinceTime
aIsShuttingDown
aOnlyThreads
)
)
{
return
nullptr
;
}
return
b
.
ChunkedWriteFunc
(
)
.
CopyData
(
)
;
}
void
profiler_get_start_params
(
int
*
aCapacity
Maybe
<
double
>
*
aDuration
double
*
aInterval
uint32_t
*
aFeatures
Vector
<
const
char
*
>
*
aFilters
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
if
(
!
aCapacity
|
|
!
aDuration
|
|
!
aInterval
|
|
!
aFeatures
|
|
!
aFilters
)
{
return
;
}
PSAutoLock
lock
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
*
aCapacity
=
0
;
*
aDuration
=
Nothing
(
)
;
*
aInterval
=
0
;
*
aFeatures
=
0
;
aFilters
-
>
clear
(
)
;
return
;
}
*
aCapacity
=
ActivePS
:
:
Capacity
(
lock
)
.
Value
(
)
;
*
aDuration
=
ActivePS
:
:
Duration
(
lock
)
;
*
aInterval
=
ActivePS
:
:
Interval
(
lock
)
;
*
aFeatures
=
ActivePS
:
:
Features
(
lock
)
;
const
Vector
<
std
:
:
string
>
&
filters
=
ActivePS
:
:
Filters
(
lock
)
;
MOZ_ALWAYS_TRUE
(
aFilters
-
>
resize
(
filters
.
length
(
)
)
)
;
for
(
uint32_t
i
=
0
;
i
<
filters
.
length
(
)
;
+
+
i
)
{
(
*
aFilters
)
[
i
]
=
filters
[
i
]
.
c_str
(
)
;
}
}
void
GetProfilerEnvVarsForChildProcess
(
std
:
:
function
<
void
(
const
char
*
key
const
char
*
value
)
>
&
&
aSetEnv
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
aSetEnv
(
"
MOZ_PROFILER_STARTUP
"
"
"
)
;
return
;
}
aSetEnv
(
"
MOZ_PROFILER_STARTUP
"
"
1
"
)
;
auto
capacityString
=
Smprintf
(
"
%
u
"
unsigned
(
ActivePS
:
:
Capacity
(
lock
)
.
Value
(
)
)
)
;
aSetEnv
(
"
MOZ_PROFILER_STARTUP_ENTRIES
"
capacityString
.
get
(
)
)
;
std
:
:
string
intervalString
=
std
:
:
to_string
(
ActivePS
:
:
Interval
(
lock
)
)
;
aSetEnv
(
"
MOZ_PROFILER_STARTUP_INTERVAL
"
intervalString
.
c_str
(
)
)
;
auto
featuresString
=
Smprintf
(
"
%
d
"
ActivePS
:
:
Features
(
lock
)
)
;
aSetEnv
(
"
MOZ_PROFILER_STARTUP_FEATURES_BITFIELD
"
featuresString
.
get
(
)
)
;
std
:
:
string
filtersString
;
const
Vector
<
std
:
:
string
>
&
filters
=
ActivePS
:
:
Filters
(
lock
)
;
for
(
uint32_t
i
=
0
;
i
<
filters
.
length
(
)
;
+
+
i
)
{
filtersString
+
=
filters
[
i
]
;
if
(
i
!
=
filters
.
length
(
)
-
1
)
{
filtersString
+
=
"
"
;
}
}
aSetEnv
(
"
MOZ_PROFILER_STARTUP_FILTERS
"
filtersString
.
c_str
(
)
)
;
}
void
profiler_received_exit_profile
(
const
std
:
:
string
&
aExitProfile
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
;
}
ActivePS
:
:
AddExitProfile
(
lock
aExitProfile
)
;
}
Vector
<
std
:
:
string
>
profiler_move_exit_profiles
(
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
;
Vector
<
std
:
:
string
>
profiles
;
if
(
ActivePS
:
:
Exists
(
lock
)
)
{
profiles
=
ActivePS
:
:
MoveExitProfiles
(
lock
)
;
}
return
profiles
;
}
static
void
locked_profiler_save_profile_to_file
(
PSLockRef
aLock
const
char
*
aFilename
bool
aIsShuttingDown
=
false
)
{
LOG
(
"
locked_profiler_save_profile_to_file
(
%
s
)
"
aFilename
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
&
&
ActivePS
:
:
Exists
(
aLock
)
)
;
std
:
:
ofstream
stream
;
stream
.
open
(
aFilename
)
;
if
(
stream
.
is_open
(
)
)
{
OStreamJSONWriteFunc
jw
(
stream
)
;
SpliceableJSONWriter
w
(
jw
)
;
w
.
Start
(
)
;
{
locked_profiler_stream_json_for_this_process
(
aLock
w
0
aIsShuttingDown
)
;
w
.
StartArrayProperty
(
"
processes
"
)
;
Vector
<
std
:
:
string
>
exitProfiles
=
ActivePS
:
:
MoveExitProfiles
(
aLock
)
;
for
(
auto
&
exitProfile
:
exitProfiles
)
{
if
(
!
exitProfile
.
empty
(
)
)
{
w
.
Splice
(
exitProfile
)
;
}
}
w
.
EndArray
(
)
;
}
w
.
End
(
)
;
stream
.
close
(
)
;
}
}
void
baseprofiler_save_profile_to_file
(
const
char
*
aFilename
)
{
LOG
(
"
baseprofiler_save_profile_to_file
(
%
s
)
"
aFilename
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
;
}
locked_profiler_save_profile_to_file
(
lock
aFilename
)
;
}
uint32_t
profiler_get_available_features
(
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
return
AvailableFeatures
(
)
;
}
Maybe
<
ProfilerBufferInfo
>
profiler_get_buffer_info
(
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
Nothing
(
)
;
}
return
Some
(
ActivePS
:
:
Buffer
(
lock
)
.
GetProfilerBufferInfo
(
)
)
;
}
static
void
*
MozGlueBaseLabelEnter
(
const
char
*
aLabel
const
char
*
aDynamicString
void
*
aSp
)
{
ProfilingStack
*
profilingStack
=
AutoProfilerLabel
:
:
sProfilingStack
.
get
(
)
;
if
(
profilingStack
)
{
profilingStack
-
>
pushLabelFrame
(
aLabel
aDynamicString
aSp
ProfilingCategoryPair
:
:
OTHER
)
;
}
return
profilingStack
;
}
static
void
MozGlueBaseLabelExit
(
void
*
sProfilingStack
)
{
if
(
sProfilingStack
)
{
reinterpret_cast
<
ProfilingStack
*
>
(
sProfilingStack
)
-
>
pop
(
)
;
}
}
static
void
locked_profiler_start
(
PSLockRef
aLock
PowerOfTwo32
aCapacity
double
aInterval
uint32_t
aFeatures
const
char
*
*
aFilters
uint32_t
aFilterCount
const
Maybe
<
double
>
&
aDuration
)
{
const
TimeStamp
profilingStartTime
=
TimeStamp
:
:
Now
(
)
;
if
(
LOG_TEST
)
{
LOG
(
"
locked_profiler_start
"
)
;
LOG
(
"
-
capacity
=
%
d
"
int
(
aCapacity
.
Value
(
)
)
)
;
LOG
(
"
-
duration
=
%
.
2f
"
aDuration
?
*
aDuration
:
-
1
)
;
LOG
(
"
-
interval
=
%
.
2f
"
aInterval
)
;
#
define
LOG_FEATURE
(
n_
str_
Name_
desc_
)
\
if
(
ProfilerFeature
:
:
Has
#
#
Name_
(
aFeatures
)
)
{
\
LOG
(
"
-
feature
=
%
s
"
str_
)
;
\
}
BASE_PROFILER_FOR_EACH_FEATURE
(
LOG_FEATURE
)
#
undef
LOG_FEATURE
for
(
uint32_t
i
=
0
;
i
<
aFilterCount
;
i
+
+
)
{
LOG
(
"
-
threads
=
%
s
"
aFilters
[
i
]
)
;
}
}
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
&
&
!
ActivePS
:
:
Exists
(
aLock
)
)
;
mozilla
:
:
base_profiler_markers_detail
:
:
EnsureBufferForMainThreadAddMarker
(
)
;
#
if
defined
(
GP_PLAT_amd64_windows
)
InitializeWin64ProfilerHooks
(
)
;
#
endif
PowerOfTwo32
capacity
=
(
aCapacity
.
Value
(
)
>
=
ProfileBufferChunkManager
:
:
scExpectedMaximumStackSize
/
scBytesPerEntry
)
?
aCapacity
:
BASE_PROFILER_DEFAULT_ENTRIES
;
Maybe
<
double
>
duration
=
aDuration
;
if
(
aDuration
&
&
*
aDuration
<
=
0
)
{
duration
=
Nothing
(
)
;
}
double
interval
=
aInterval
>
0
?
aInterval
:
BASE_PROFILER_DEFAULT_INTERVAL
;
ActivePS
:
:
Create
(
aLock
profilingStartTime
capacity
interval
aFeatures
aFilters
aFilterCount
duration
)
;
const
Vector
<
UniquePtr
<
RegisteredThread
>
>
&
registeredThreads
=
CorePS
:
:
RegisteredThreads
(
aLock
)
;
for
(
auto
&
registeredThread
:
registeredThreads
)
{
RefPtr
<
ThreadInfo
>
info
=
registeredThread
-
>
Info
(
)
;
if
(
ActivePS
:
:
ShouldProfileThread
(
aLock
info
)
)
{
registeredThread
-
>
RacyRegisteredThread
(
)
.
SetIsBeingProfiled
(
true
)
;
ActivePS
:
:
AddLiveProfiledThread
(
aLock
registeredThread
.
get
(
)
MakeUnique
<
ProfiledThreadData
>
(
info
)
)
;
registeredThread
-
>
RacyRegisteredThread
(
)
.
ReinitializeOnResume
(
)
;
}
}
RegisterProfilerLabelEnterExit
(
MozGlueBaseLabelEnter
MozGlueBaseLabelExit
)
;
RacyFeatures
:
:
SetActive
(
ActivePS
:
:
Features
(
aLock
)
)
;
}
void
profiler_start
(
PowerOfTwo32
aCapacity
double
aInterval
uint32_t
aFeatures
const
char
*
*
aFilters
uint32_t
aFilterCount
const
Maybe
<
double
>
&
aDuration
)
{
LOG
(
"
profiler_start
"
)
;
SamplerThread
*
samplerThread
=
nullptr
;
{
PSAutoLock
lock
;
if
(
!
CorePS
:
:
Exists
(
)
)
{
profiler_init
(
nullptr
)
;
}
if
(
ActivePS
:
:
Exists
(
lock
)
)
{
samplerThread
=
locked_profiler_stop
(
lock
)
;
}
locked_profiler_start
(
lock
aCapacity
aInterval
aFeatures
aFilters
aFilterCount
aDuration
)
;
}
if
(
samplerThread
)
{
delete
samplerThread
;
}
}
void
profiler_ensure_started
(
PowerOfTwo32
aCapacity
double
aInterval
uint32_t
aFeatures
const
char
*
*
aFilters
uint32_t
aFilterCount
const
Maybe
<
double
>
&
aDuration
)
{
LOG
(
"
profiler_ensure_started
"
)
;
SamplerThread
*
samplerThread
=
nullptr
;
{
PSAutoLock
lock
;
if
(
!
CorePS
:
:
Exists
(
)
)
{
profiler_init
(
nullptr
)
;
}
if
(
ActivePS
:
:
Exists
(
lock
)
)
{
if
(
!
ActivePS
:
:
Equals
(
lock
aCapacity
aDuration
aInterval
aFeatures
aFilters
aFilterCount
)
)
{
samplerThread
=
locked_profiler_stop
(
lock
)
;
locked_profiler_start
(
lock
aCapacity
aInterval
aFeatures
aFilters
aFilterCount
aDuration
)
;
}
}
else
{
locked_profiler_start
(
lock
aCapacity
aInterval
aFeatures
aFilters
aFilterCount
aDuration
)
;
}
}
if
(
samplerThread
)
{
delete
samplerThread
;
}
}
[
[
nodiscard
]
]
static
SamplerThread
*
locked_profiler_stop
(
PSLockRef
aLock
)
{
LOG
(
"
locked_profiler_stop
"
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
&
&
ActivePS
:
:
Exists
(
aLock
)
)
;
RacyFeatures
:
:
SetInactive
(
)
;
RegisterProfilerLabelEnterExit
(
nullptr
nullptr
)
;
const
Vector
<
LiveProfiledThreadData
>
&
liveProfiledThreads
=
ActivePS
:
:
LiveProfiledThreads
(
aLock
)
;
for
(
auto
&
thread
:
liveProfiledThreads
)
{
RegisteredThread
*
registeredThread
=
thread
.
mRegisteredThread
;
registeredThread
-
>
RacyRegisteredThread
(
)
.
SetIsBeingProfiled
(
false
)
;
}
SamplerThread
*
samplerThread
=
ActivePS
:
:
Destroy
(
aLock
)
;
samplerThread
-
>
Stop
(
aLock
)
;
mozilla
:
:
base_profiler_markers_detail
:
:
ReleaseBufferForMainThreadAddMarker
(
)
;
return
samplerThread
;
}
void
profiler_stop
(
)
{
LOG
(
"
profiler_stop
"
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
SamplerThread
*
samplerThread
;
{
PSAutoLock
lock
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
;
}
samplerThread
=
locked_profiler_stop
(
lock
)
;
}
delete
samplerThread
;
}
bool
profiler_is_paused
(
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
false
;
}
return
ActivePS
:
:
IsPaused
(
lock
)
;
}
void
profiler_pause
(
)
{
LOG
(
"
profiler_pause
"
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
{
PSAutoLock
lock
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
;
}
RacyFeatures
:
:
SetPaused
(
)
;
ActivePS
:
:
SetIsPaused
(
lock
true
)
;
ActivePS
:
:
Buffer
(
lock
)
.
AddEntry
(
ProfileBufferEntry
:
:
Pause
(
profiler_time
(
)
)
)
;
}
}
void
profiler_resume
(
)
{
LOG
(
"
profiler_resume
"
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
{
PSAutoLock
lock
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
;
}
ActivePS
:
:
Buffer
(
lock
)
.
AddEntry
(
ProfileBufferEntry
:
:
Resume
(
profiler_time
(
)
)
)
;
ActivePS
:
:
SetIsPaused
(
lock
false
)
;
RacyFeatures
:
:
SetUnpaused
(
)
;
}
}
bool
profiler_is_sampling_paused
(
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
false
;
}
return
ActivePS
:
:
IsSamplingPaused
(
lock
)
;
}
void
profiler_pause_sampling
(
)
{
LOG
(
"
profiler_pause_sampling
"
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
{
PSAutoLock
lock
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
;
}
RacyFeatures
:
:
SetSamplingPaused
(
)
;
ActivePS
:
:
SetIsSamplingPaused
(
lock
true
)
;
ActivePS
:
:
Buffer
(
lock
)
.
AddEntry
(
ProfileBufferEntry
:
:
PauseSampling
(
profiler_time
(
)
)
)
;
}
}
void
profiler_resume_sampling
(
)
{
LOG
(
"
profiler_resume_sampling
"
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
{
PSAutoLock
lock
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
;
}
ActivePS
:
:
Buffer
(
lock
)
.
AddEntry
(
ProfileBufferEntry
:
:
ResumeSampling
(
profiler_time
(
)
)
)
;
ActivePS
:
:
SetIsSamplingPaused
(
lock
false
)
;
RacyFeatures
:
:
SetSamplingUnpaused
(
)
;
}
}
bool
profiler_feature_active
(
uint32_t
aFeature
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
return
RacyFeatures
:
:
IsActiveWithFeature
(
aFeature
)
;
}
void
profiler_add_sampled_counter
(
BaseProfilerCount
*
aCounter
)
{
DEBUG_LOG
(
"
profiler_add_sampled_counter
(
%
s
)
"
aCounter
-
>
mLabel
)
;
PSAutoLock
lock
;
CorePS
:
:
AppendCounter
(
lock
aCounter
)
;
}
void
profiler_remove_sampled_counter
(
BaseProfilerCount
*
aCounter
)
{
DEBUG_LOG
(
"
profiler_remove_sampled_counter
(
%
s
)
"
aCounter
-
>
mLabel
)
;
PSAutoLock
lock
;
CorePS
:
:
RemoveCounter
(
lock
aCounter
)
;
}
ProfilingStack
*
profiler_register_thread
(
const
char
*
aName
void
*
aGuessStackTop
)
{
DEBUG_LOG
(
"
profiler_register_thread
(
%
s
)
"
aName
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
;
if
(
RegisteredThread
*
thread
=
FindCurrentThreadRegisteredThread
(
lock
)
;
thread
)
{
LOG
(
"
profiler_register_thread
(
%
s
)
-
thread
%
"
PRIu64
"
already
registered
as
%
s
"
aName
uint64_t
(
profiler_current_thread_id
(
)
.
ToNumber
(
)
)
thread
-
>
Info
(
)
-
>
Name
(
)
)
;
std
:
:
string
text
(
"
Thread
"
)
;
text
+
=
std
:
:
to_string
(
profiler_current_thread_id
(
)
.
ToNumber
(
)
)
;
text
+
=
"
\
"
"
;
text
+
=
thread
-
>
Info
(
)
-
>
Name
(
)
;
text
+
=
"
\
"
attempted
to
re
-
register
as
\
"
"
;
text
+
=
aName
;
text
+
=
"
\
"
"
;
BASE_PROFILER_MARKER_TEXT
(
"
profiler_register_thread
again
"
OTHER_Profiling
MarkerThreadId
:
:
MainThread
(
)
text
)
;
return
&
thread
-
>
RacyRegisteredThread
(
)
.
ProfilingStack
(
)
;
}
void
*
stackTop
=
GetStackTop
(
aGuessStackTop
)
;
return
locked_register_thread
(
lock
aName
stackTop
)
;
}
void
profiler_unregister_thread
(
)
{
if
(
!
CorePS
:
:
Exists
(
)
)
{
return
;
}
PSAutoLock
lock
;
RegisteredThread
*
registeredThread
=
FindCurrentThreadRegisteredThread
(
lock
)
;
MOZ_RELEASE_ASSERT
(
registeredThread
=
=
TLSRegisteredThread
:
:
RegisteredThread
(
lock
)
)
;
if
(
registeredThread
)
{
RefPtr
<
ThreadInfo
>
info
=
registeredThread
-
>
Info
(
)
;
DEBUG_LOG
(
"
profiler_unregister_thread
:
%
s
"
info
-
>
Name
(
)
)
;
if
(
ActivePS
:
:
Exists
(
lock
)
)
{
ActivePS
:
:
UnregisterThread
(
lock
registeredThread
)
;
}
TLSRegisteredThread
:
:
SetRegisteredThread
(
lock
nullptr
)
;
CorePS
:
:
RemoveRegisteredThread
(
lock
registeredThread
)
;
}
else
{
LOG
(
"
profiler_unregister_thread
(
)
-
thread
%
"
PRIu64
"
already
unregistered
"
uint64_t
(
profiler_current_thread_id
(
)
.
ToNumber
(
)
)
)
;
if
(
BaseProfilerThreadId
tid
=
profiler_current_thread_id
(
)
;
tid
!
=
profiler_main_thread_id
(
)
)
{
BASE_PROFILER_MARKER_TEXT
(
"
profiler_unregister_thread
again
"
OTHER_Profiling
MarkerThreadId
:
:
MainThread
(
)
std
:
:
to_string
(
profiler_current_thread_id
(
)
.
ToNumber
(
)
)
)
;
}
MOZ_RELEASE_ASSERT
(
!
TLSRegisteredThread
:
:
RegisteredThread
(
lock
)
)
;
}
}
void
profiler_register_page
(
uint64_t
aTabID
uint64_t
aInnerWindowID
const
std
:
:
string
&
aUrl
uint64_t
aEmbedderInnerWindowID
)
{
DEBUG_LOG
(
"
profiler_register_page
(
%
"
PRIu64
"
%
"
PRIu64
"
%
s
%
"
PRIu64
"
)
"
aTabID
aInnerWindowID
aUrl
.
c_str
(
)
aEmbedderInnerWindowID
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
;
RefPtr
<
PageInformation
>
pageInfo
=
new
PageInformation
(
aTabID
aInnerWindowID
aUrl
aEmbedderInnerWindowID
)
;
CorePS
:
:
AppendRegisteredPage
(
lock
std
:
:
move
(
pageInfo
)
)
;
if
(
ActivePS
:
:
Exists
(
lock
)
)
{
ActivePS
:
:
DiscardExpiredPages
(
lock
)
;
}
}
void
profiler_unregister_page
(
uint64_t
aRegisteredInnerWindowID
)
{
if
(
!
CorePS
:
:
Exists
(
)
)
{
return
;
}
PSAutoLock
lock
;
if
(
ActivePS
:
:
Exists
(
lock
)
)
{
ActivePS
:
:
UnregisterPage
(
lock
aRegisteredInnerWindowID
)
;
}
else
{
CorePS
:
:
RemoveRegisteredPage
(
lock
aRegisteredInnerWindowID
)
;
}
}
void
profiler_clear_all_pages
(
)
{
if
(
!
CorePS
:
:
Exists
(
)
)
{
return
;
}
{
PSAutoLock
lock
;
CorePS
:
:
ClearRegisteredPages
(
lock
)
;
if
(
ActivePS
:
:
Exists
(
lock
)
)
{
ActivePS
:
:
ClearUnregisteredPages
(
lock
)
;
}
}
}
void
profiler_thread_sleep
(
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
RacyRegisteredThread
*
racyRegisteredThread
=
TLSRegisteredThread
:
:
RacyRegisteredThread
(
)
;
if
(
!
racyRegisteredThread
)
{
return
;
}
racyRegisteredThread
-
>
SetSleeping
(
)
;
}
void
profiler_thread_wake
(
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
RacyRegisteredThread
*
racyRegisteredThread
=
TLSRegisteredThread
:
:
RacyRegisteredThread
(
)
;
if
(
!
racyRegisteredThread
)
{
return
;
}
racyRegisteredThread
-
>
SetAwake
(
)
;
}
bool
detail
:
:
IsThreadBeingProfiled
(
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
const
RacyRegisteredThread
*
racyRegisteredThread
=
TLSRegisteredThread
:
:
RacyRegisteredThread
(
)
;
return
racyRegisteredThread
&
&
racyRegisteredThread
-
>
IsBeingProfiled
(
)
;
}
bool
profiler_thread_is_sleeping
(
)
{
MOZ_RELEASE_ASSERT
(
profiler_is_main_thread
(
)
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
RacyRegisteredThread
*
racyRegisteredThread
=
TLSRegisteredThread
:
:
RacyRegisteredThread
(
)
;
if
(
!
racyRegisteredThread
)
{
return
false
;
}
return
racyRegisteredThread
-
>
IsSleeping
(
)
;
}
double
profiler_time
(
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
TimeDuration
delta
=
TimeStamp
:
:
Now
(
)
-
CorePS
:
:
ProcessStartTime
(
)
;
return
delta
.
ToMilliseconds
(
)
;
}
bool
profiler_capture_backtrace_into
(
ProfileChunkedBuffer
&
aChunkedBuffer
StackCaptureOptions
aCaptureOptions
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
|
|
aCaptureOptions
=
=
StackCaptureOptions
:
:
NoStack
)
{
return
false
;
}
RegisteredThread
*
registeredThread
=
TLSRegisteredThread
:
:
RegisteredThread
(
lock
)
;
if
(
!
registeredThread
)
{
MOZ_ASSERT
(
registeredThread
)
;
return
false
;
}
ProfileBuffer
profileBuffer
(
aChunkedBuffer
)
;
Registers
regs
;
#
if
defined
(
HAVE_NATIVE_UNWIND
)
regs
.
SyncPopulate
(
)
;
#
else
regs
.
Clear
(
)
;
#
endif
DoSyncSample
(
lock
*
registeredThread
TimeStamp
:
:
Now
(
)
regs
profileBuffer
aCaptureOptions
)
;
return
true
;
}
UniquePtr
<
ProfileChunkedBuffer
>
profiler_capture_backtrace
(
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
AUTO_BASE_PROFILER_LABEL
(
"
baseprofiler
:
:
profiler_capture_backtrace
"
PROFILER
)
;
if
(
!
profiler_is_active
(
)
)
{
return
nullptr
;
}
auto
buffer
=
MakeUnique
<
ProfileChunkedBuffer
>
(
ProfileChunkedBuffer
:
:
ThreadSafety
:
:
WithoutMutex
MakeUnique
<
ProfileBufferChunkManagerSingle
>
(
ProfileBufferChunkManager
:
:
scExpectedMaximumStackSize
)
)
;
if
(
!
profiler_capture_backtrace_into
(
*
buffer
StackCaptureOptions
:
:
Full
)
)
{
return
nullptr
;
}
return
buffer
;
}
UniqueProfilerBacktrace
profiler_get_backtrace
(
)
{
UniquePtr
<
ProfileChunkedBuffer
>
buffer
=
profiler_capture_backtrace
(
)
;
if
(
!
buffer
)
{
return
nullptr
;
}
return
UniqueProfilerBacktrace
(
new
ProfilerBacktrace
(
"
SyncProfile
"
std
:
:
move
(
buffer
)
)
)
;
}
void
ProfilerBacktraceDestructor
:
:
operator
(
)
(
ProfilerBacktrace
*
aBacktrace
)
{
delete
aBacktrace
;
}
bool
profiler_is_locked_on_current_thread
(
)
{
return
PSAutoLock
:
:
IsLockedOnCurrentThread
(
)
|
|
profiler_get_core_buffer
(
)
.
IsThreadSafeAndLockedOnCurrentThread
(
)
;
}
void
profiler_add_js_marker
(
const
char
*
aMarkerName
const
char
*
aMarkerText
)
{
BASE_PROFILER_MARKER_TEXT
(
ProfilerString8View
:
:
WrapNullTerminatedString
(
aMarkerName
)
JS
{
}
ProfilerString8View
:
:
WrapNullTerminatedString
(
aMarkerText
)
)
;
}
void
profiler_suspend_and_sample_thread
(
BaseProfilerThreadId
aThreadId
uint32_t
aFeatures
ProfilerStackCollector
&
aCollector
bool
aSampleNative
)
{
const
bool
isSynchronous
=
[
&
aThreadId
]
(
)
{
const
BaseProfilerThreadId
currentThreadId
=
profiler_current_thread_id
(
)
;
if
(
!
aThreadId
.
IsSpecified
(
)
)
{
aThreadId
=
currentThreadId
;
return
true
;
}
return
aThreadId
=
=
currentThreadId
;
}
(
)
;
PSAutoLock
lock
;
const
Vector
<
UniquePtr
<
RegisteredThread
>
>
&
registeredThreads
=
CorePS
:
:
RegisteredThreads
(
lock
)
;
for
(
auto
&
thread
:
registeredThreads
)
{
RefPtr
<
ThreadInfo
>
info
=
thread
-
>
Info
(
)
;
RegisteredThread
&
registeredThread
=
*
thread
.
get
(
)
;
if
(
info
-
>
ThreadId
(
)
=
=
aThreadId
)
{
if
(
info
-
>
IsMainThread
(
)
)
{
aCollector
.
SetIsMainThread
(
)
;
}
NativeStack
nativeStack
;
auto
collectStack
=
[
&
]
(
const
Registers
&
aRegs
const
TimeStamp
&
aNow
)
{
#
if
defined
(
HAVE_FASTINIT_NATIVE_UNWIND
)
if
(
aSampleNative
)
{
#
if
defined
(
USE_FRAME_POINTER_STACK_WALK
)
DoFramePointerBacktrace
(
lock
registeredThread
aRegs
nativeStack
)
;
#
elif
defined
(
USE_MOZ_STACK_WALK
)
DoMozStackWalkBacktrace
(
lock
registeredThread
aRegs
nativeStack
)
;
#
else
#
error
"
Invalid
configuration
"
#
endif
MergeStacks
(
aFeatures
isSynchronous
registeredThread
aRegs
nativeStack
aCollector
)
;
}
else
#
endif
{
MergeStacks
(
aFeatures
isSynchronous
registeredThread
aRegs
nativeStack
aCollector
)
;
aCollector
.
CollectNativeLeafAddr
(
(
void
*
)
aRegs
.
mPC
)
;
}
}
;
if
(
isSynchronous
)
{
Registers
regs
;
#
if
defined
(
HAVE_NATIVE_UNWIND
)
regs
.
SyncPopulate
(
)
;
#
else
regs
.
Clear
(
)
;
#
endif
collectStack
(
regs
TimeStamp
:
:
Now
(
)
)
;
}
else
{
Sampler
sampler
(
lock
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
sampler
.
SuspendAndSampleAndResumeThread
(
lock
registeredThread
now
collectStack
)
;
sampler
.
Disable
(
lock
)
;
}
break
;
}
}
}
}
}
