#
include
<
windows
.
h
>
#
include
"
BaseProfilerSharedLibraries
.
h
"
#
include
"
mozilla
/
glue
/
WindowsUnicode
.
h
"
#
include
"
mozilla
/
NativeNt
.
h
"
#
include
"
mozilla
/
WindowsEnumProcessModules
.
h
"
#
include
"
mozilla
/
WindowsVersion
.
h
"
#
include
<
cctype
>
#
include
<
string
>
static
constexpr
char
uppercaseDigits
[
16
]
=
{
'
0
'
'
1
'
'
2
'
'
3
'
'
4
'
'
5
'
'
6
'
'
7
'
'
8
'
'
9
'
'
A
'
'
B
'
'
C
'
'
D
'
'
E
'
'
F
'
}
;
static
constexpr
char
lowercaseDigits
[
16
]
=
{
'
0
'
'
1
'
'
2
'
'
3
'
'
4
'
'
5
'
'
6
'
'
7
'
'
8
'
'
9
'
'
a
'
'
b
'
'
c
'
'
d
'
'
e
'
'
f
'
}
;
static
void
AppendHex
(
const
unsigned
char
*
aBegin
const
unsigned
char
*
aEnd
std
:
:
string
&
aOut
)
{
for
(
const
unsigned
char
*
p
=
aBegin
;
p
<
aEnd
;
+
+
p
)
{
unsigned
char
c
=
*
p
;
aOut
+
=
uppercaseDigits
[
c
>
>
4
]
;
aOut
+
=
uppercaseDigits
[
c
&
0xFu
]
;
}
}
static
constexpr
bool
WITH_PADDING
=
true
;
static
constexpr
bool
WITHOUT_PADDING
=
false
;
static
constexpr
bool
LOWERCASE
=
true
;
static
constexpr
bool
UPPERCASE
=
false
;
template
<
typename
T
>
static
void
AppendHex
(
T
aValue
std
:
:
string
&
aOut
bool
aWithPadding
bool
aLowercase
=
UPPERCASE
)
{
for
(
int
i
=
sizeof
(
T
)
*
2
-
1
;
i
>
=
0
;
-
-
i
)
{
unsigned
nibble
=
(
aValue
>
>
(
i
*
4
)
)
&
0xFu
;
if
(
!
aWithPadding
&
&
i
!
=
0
)
{
if
(
nibble
=
=
0
)
{
continue
;
}
aWithPadding
=
true
;
}
aOut
+
=
aLowercase
?
lowercaseDigits
[
nibble
]
:
uppercaseDigits
[
nibble
]
;
}
}
static
bool
IsModuleUnsafeToLoad
(
const
std
:
:
string
&
aModuleName
)
{
auto
LowerCaseEqualsLiteral
=
[
]
(
char
aModuleChar
char
aDetouredChar
)
{
return
std
:
:
tolower
(
aModuleChar
)
=
=
aDetouredChar
;
}
;
#
if
defined
(
_M_AMD64
)
|
|
defined
(
_M_IX86
)
#
if
defined
(
_M_AMD64
)
LPCWSTR
kNvidiaShimDriver
=
L
"
nvd3d9wrapx
.
dll
"
;
LPCWSTR
kNvidiaInitDriver
=
L
"
nvinitx
.
dll
"
;
#
elif
defined
(
_M_IX86
)
LPCWSTR
kNvidiaShimDriver
=
L
"
nvd3d9wrap
.
dll
"
;
LPCWSTR
kNvidiaInitDriver
=
L
"
nvinit
.
dll
"
;
#
endif
constexpr
std
:
:
string_view
detoured_dll
=
"
detoured
.
dll
"
;
if
(
std
:
:
equal
(
aModuleName
.
cbegin
(
)
aModuleName
.
cend
(
)
detoured_dll
.
cbegin
(
)
detoured_dll
.
cend
(
)
LowerCaseEqualsLiteral
)
&
&
!
mozilla
:
:
IsWin8OrLater
(
)
&
&
:
:
GetModuleHandleW
(
kNvidiaShimDriver
)
&
&
!
:
:
GetModuleHandleW
(
kNvidiaInitDriver
)
)
{
return
true
;
}
#
endif
constexpr
std
:
:
string_view
vp9_decoder_dll
=
"
msvp9dec_store
.
dll
"
;
if
(
std
:
:
equal
(
aModuleName
.
cbegin
(
)
aModuleName
.
cend
(
)
vp9_decoder_dll
.
cbegin
(
)
vp9_decoder_dll
.
cend
(
)
LowerCaseEqualsLiteral
)
)
{
return
true
;
}
return
false
;
}
void
SharedLibraryInfo
:
:
AddSharedLibraryFromModuleInfo
(
const
wchar_t
*
aModulePath
mozilla
:
:
Maybe
<
HMODULE
>
aModule
)
{
mozilla
:
:
UniquePtr
<
char
[
]
>
utf8ModulePath
(
mozilla
:
:
glue
:
:
WideToUTF8
(
aModulePath
)
)
;
if
(
!
utf8ModulePath
)
{
return
;
}
std
:
:
string
modulePathStr
(
utf8ModulePath
.
get
(
)
)
;
size_t
pos
=
modulePathStr
.
find_last_of
(
"
\
\
/
"
)
;
std
:
:
string
moduleNameStr
=
(
pos
!
=
std
:
:
string
:
:
npos
)
?
modulePathStr
.
substr
(
pos
+
1
)
:
modulePathStr
;
if
(
IsModuleUnsafeToLoad
(
moduleNameStr
)
)
{
return
;
}
nsModuleHandle
handleLock
(
:
:
LoadLibraryExW
(
aModulePath
NULL
LOAD_LIBRARY_AS_IMAGE_RESOURCE
)
)
;
if
(
!
handleLock
)
{
return
;
}
mozilla
:
:
nt
:
:
PEHeaders
headers
(
handleLock
.
get
(
)
)
;
if
(
!
headers
)
{
return
;
}
mozilla
:
:
Maybe
<
mozilla
:
:
Range
<
const
uint8_t
>
>
bounds
=
headers
.
GetBounds
(
)
;
if
(
!
bounds
)
{
return
;
}
const
uintptr_t
modStart
=
aModule
.
isSome
(
)
?
reinterpret_cast
<
uintptr_t
>
(
*
aModule
)
:
reinterpret_cast
<
uintptr_t
>
(
handleLock
.
get
(
)
)
;
const
uintptr_t
modEnd
=
modStart
+
bounds
-
>
length
(
)
;
std
:
:
string
breakpadId
;
std
:
:
string
pdbPathStr
;
std
:
:
string
pdbNameStr
;
if
(
const
auto
*
debugInfo
=
headers
.
GetPdbInfo
(
)
)
{
MOZ_ASSERT
(
breakpadId
.
empty
(
)
)
;
const
GUID
&
pdbSig
=
debugInfo
-
>
pdbSignature
;
AppendHex
(
pdbSig
.
Data1
breakpadId
WITH_PADDING
)
;
AppendHex
(
pdbSig
.
Data2
breakpadId
WITH_PADDING
)
;
AppendHex
(
pdbSig
.
Data3
breakpadId
WITH_PADDING
)
;
AppendHex
(
reinterpret_cast
<
const
unsigned
char
*
>
(
&
pdbSig
.
Data4
)
reinterpret_cast
<
const
unsigned
char
*
>
(
&
pdbSig
.
Data4
)
+
sizeof
(
pdbSig
.
Data4
)
breakpadId
)
;
AppendHex
(
debugInfo
-
>
pdbAge
breakpadId
WITHOUT_PADDING
)
;
pdbPathStr
=
debugInfo
-
>
pdbFileName
;
size_t
pos
=
pdbPathStr
.
find_last_of
(
"
\
\
/
"
)
;
pdbNameStr
=
(
pos
!
=
std
:
:
string
:
:
npos
)
?
pdbPathStr
.
substr
(
pos
+
1
)
:
pdbPathStr
;
}
std
:
:
string
codeId
;
DWORD
timestamp
;
DWORD
imageSize
;
if
(
headers
.
GetTimeStamp
(
timestamp
)
&
&
headers
.
GetImageSize
(
imageSize
)
)
{
AppendHex
(
timestamp
codeId
WITH_PADDING
)
;
AppendHex
(
imageSize
codeId
WITHOUT_PADDING
LOWERCASE
)
;
}
std
:
:
string
versionStr
;
uint64_t
version
;
if
(
headers
.
GetVersionInfo
(
version
)
)
{
versionStr
+
=
std
:
:
to_string
(
(
version
>
>
48
)
&
0xFFFF
)
;
versionStr
+
=
'
.
'
;
versionStr
+
=
std
:
:
to_string
(
(
version
>
>
32
)
&
0xFFFF
)
;
versionStr
+
=
'
.
'
;
versionStr
+
=
std
:
:
to_string
(
(
version
>
>
16
)
&
0xFFFF
)
;
versionStr
+
=
'
.
'
;
versionStr
+
=
std
:
:
to_string
(
version
&
0xFFFF
)
;
}
SharedLibrary
shlib
(
modStart
modEnd
0
breakpadId
codeId
moduleNameStr
modulePathStr
pdbNameStr
pdbPathStr
versionStr
"
"
)
;
AddSharedLibrary
(
shlib
)
;
}
SharedLibraryInfo
SharedLibraryInfo
:
:
GetInfoForSelf
(
)
{
SharedLibraryInfo
sharedLibraryInfo
;
auto
addSharedLibraryFromModuleInfo
=
[
&
sharedLibraryInfo
]
(
const
wchar_t
*
aModulePath
HMODULE
aModule
)
{
sharedLibraryInfo
.
AddSharedLibraryFromModuleInfo
(
aModulePath
mozilla
:
:
Some
(
aModule
)
)
;
}
;
mozilla
:
:
EnumerateProcessModules
(
addSharedLibraryFromModuleInfo
)
;
return
sharedLibraryInfo
;
}
SharedLibraryInfo
SharedLibraryInfo
:
:
GetInfoFromPath
(
const
wchar_t
*
aPath
)
{
SharedLibraryInfo
sharedLibraryInfo
;
sharedLibraryInfo
.
AddSharedLibraryFromModuleInfo
(
aPath
mozilla
:
:
Nothing
(
)
)
;
return
sharedLibraryInfo
;
}
void
SharedLibraryInfo
:
:
Initialize
(
)
{
}
