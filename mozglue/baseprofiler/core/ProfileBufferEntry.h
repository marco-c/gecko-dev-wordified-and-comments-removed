#
ifndef
ProfileBufferEntry_h
#
define
ProfileBufferEntry_h
#
include
"
BaseProfileJSONWriter
.
h
"
#
include
"
gtest
/
MozGtestFriend
.
h
"
#
include
"
BaseProfilingCategory
.
h
"
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
"
mozilla
/
HashTable
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
<
string
>
namespace
mozilla
{
namespace
baseprofiler
{
class
ProfilerMarker
;
#
define
FOR_EACH_PROFILE_BUFFER_ENTRY_KIND
(
MACRO
)
\
MACRO
(
CategoryPair
int
sizeof
(
int
)
)
\
MACRO
(
CollectionStart
double
sizeof
(
double
)
)
\
MACRO
(
CollectionEnd
double
sizeof
(
double
)
)
\
MACRO
(
Label
const
char
*
sizeof
(
const
char
*
)
)
\
MACRO
(
FrameFlags
uint64_t
sizeof
(
uint64_t
)
)
\
MACRO
(
DynamicStringFragment
char
*
ProfileBufferEntry
:
:
kNumChars
)
\
MACRO
(
JitReturnAddr
void
*
sizeof
(
void
*
)
)
\
MACRO
(
LineNumber
int
sizeof
(
int
)
)
\
MACRO
(
ColumnNumber
int
sizeof
(
int
)
)
\
MACRO
(
NativeLeafAddr
void
*
sizeof
(
void
*
)
)
\
MACRO
(
Marker
ProfilerMarker
*
sizeof
(
ProfilerMarker
*
)
)
\
MACRO
(
Pause
double
sizeof
(
double
)
)
\
MACRO
(
Responsiveness
double
sizeof
(
double
)
)
\
MACRO
(
Resume
double
sizeof
(
double
)
)
\
MACRO
(
ThreadId
int
sizeof
(
int
)
)
\
MACRO
(
Time
double
sizeof
(
double
)
)
\
MACRO
(
CounterId
void
*
sizeof
(
void
*
)
)
\
MACRO
(
CounterKey
uint64_t
sizeof
(
uint64_t
)
)
\
MACRO
(
Number
uint64_t
sizeof
(
uint64_t
)
)
\
MACRO
(
Count
int64_t
sizeof
(
int64_t
)
)
\
MACRO
(
ProfilerOverheadTime
double
sizeof
(
double
)
)
\
MACRO
(
ProfilerOverheadDuration
double
sizeof
(
double
)
)
class
ProfileBufferEntry
{
public
:
using
KindUnderlyingType
=
uint8_t
;
enum
class
Kind
:
KindUnderlyingType
{
INVALID
=
0
#
define
KIND
(
KIND
TYPE
SIZE
)
KIND
FOR_EACH_PROFILE_BUFFER_ENTRY_KIND
(
KIND
)
#
undef
KIND
LEGACY_LIMIT
MarkerData
=
LEGACY_LIMIT
MODERN_LIMIT
}
;
ProfileBufferEntry
(
)
;
static
const
size_t
kNumChars
=
8
;
private
:
ProfileBufferEntry
(
Kind
aKind
const
char
*
aString
)
;
ProfileBufferEntry
(
Kind
aKind
char
aChars
[
kNumChars
]
)
;
ProfileBufferEntry
(
Kind
aKind
void
*
aPtr
)
;
ProfileBufferEntry
(
Kind
aKind
ProfilerMarker
*
aMarker
)
;
ProfileBufferEntry
(
Kind
aKind
double
aDouble
)
;
ProfileBufferEntry
(
Kind
aKind
int64_t
aInt64
)
;
ProfileBufferEntry
(
Kind
aKind
uint64_t
aUint64
)
;
ProfileBufferEntry
(
Kind
aKind
int
aInt
)
;
public
:
#
define
CTOR
(
KIND
TYPE
SIZE
)
\
static
ProfileBufferEntry
KIND
(
TYPE
aVal
)
{
\
return
ProfileBufferEntry
(
Kind
:
:
KIND
aVal
)
;
\
}
FOR_EACH_PROFILE_BUFFER_ENTRY_KIND
(
CTOR
)
#
undef
CTOR
Kind
GetKind
(
)
const
{
return
mKind
;
}
#
define
IS_KIND
(
KIND
TYPE
SIZE
)
\
bool
Is
#
#
KIND
(
)
const
{
return
mKind
=
=
Kind
:
:
KIND
;
}
FOR_EACH_PROFILE_BUFFER_ENTRY_KIND
(
IS_KIND
)
#
undef
IS_KIND
private
:
FRIEND_TEST
(
ThreadProfile
InsertOneEntry
)
;
FRIEND_TEST
(
ThreadProfile
InsertOneEntryWithTinyBuffer
)
;
FRIEND_TEST
(
ThreadProfile
InsertEntriesNoWrap
)
;
FRIEND_TEST
(
ThreadProfile
InsertEntriesWrap
)
;
FRIEND_TEST
(
ThreadProfile
MemoryMeasure
)
;
friend
class
ProfileBuffer
;
Kind
mKind
;
uint8_t
mStorage
[
kNumChars
]
;
const
char
*
GetString
(
)
const
;
void
*
GetPtr
(
)
const
;
ProfilerMarker
*
GetMarker
(
)
const
;
double
GetDouble
(
)
const
;
int
GetInt
(
)
const
;
int64_t
GetInt64
(
)
const
;
uint64_t
GetUint64
(
)
const
;
void
CopyCharsInto
(
char
(
&
aOutArray
)
[
kNumChars
]
)
const
;
}
;
static_assert
(
sizeof
(
ProfileBufferEntry
)
=
=
9
"
bad
ProfileBufferEntry
size
"
)
;
class
UniqueJSONStrings
{
public
:
UniqueJSONStrings
(
)
;
explicit
UniqueJSONStrings
(
const
UniqueJSONStrings
&
aOther
)
;
void
SpliceStringTableElements
(
SpliceableJSONWriter
&
aWriter
)
{
aWriter
.
TakeAndSplice
(
mStringTableWriter
.
WriteFunc
(
)
)
;
}
void
WriteProperty
(
JSONWriter
&
aWriter
const
char
*
aName
const
char
*
aStr
)
{
aWriter
.
IntProperty
(
aName
GetOrAddIndex
(
aStr
)
)
;
}
void
WriteElement
(
JSONWriter
&
aWriter
const
char
*
aStr
)
{
aWriter
.
IntElement
(
GetOrAddIndex
(
aStr
)
)
;
}
uint32_t
GetOrAddIndex
(
const
char
*
aStr
)
;
private
:
SpliceableChunkedJSONWriter
mStringTableWriter
;
HashMap
<
HashNumber
uint32_t
>
mStringHashToIndexMap
;
}
;
class
UniqueStacks
{
public
:
struct
FrameKey
{
explicit
FrameKey
(
const
char
*
aLocation
)
:
mData
(
NormalFrameData
{
std
:
:
string
(
aLocation
)
false
Nothing
(
)
Nothing
(
)
}
)
{
}
FrameKey
(
std
:
:
string
&
&
aLocation
bool
aRelevantForJS
const
Maybe
<
unsigned
>
&
aLine
const
Maybe
<
unsigned
>
&
aColumn
const
Maybe
<
ProfilingCategoryPair
>
&
aCategoryPair
)
:
mData
(
NormalFrameData
{
aLocation
aRelevantForJS
aLine
aColumn
aCategoryPair
}
)
{
}
FrameKey
(
const
FrameKey
&
aToCopy
)
=
default
;
uint32_t
Hash
(
)
const
;
bool
operator
=
=
(
const
FrameKey
&
aOther
)
const
{
return
mData
=
=
aOther
.
mData
;
}
struct
NormalFrameData
{
bool
operator
=
=
(
const
NormalFrameData
&
aOther
)
const
;
std
:
:
string
mLocation
;
bool
mRelevantForJS
;
Maybe
<
unsigned
>
mLine
;
Maybe
<
unsigned
>
mColumn
;
Maybe
<
ProfilingCategoryPair
>
mCategoryPair
;
}
;
Variant
<
NormalFrameData
>
mData
;
}
;
struct
FrameKeyHasher
{
using
Lookup
=
FrameKey
;
static
HashNumber
hash
(
const
FrameKey
&
aLookup
)
{
HashNumber
hash
=
0
;
if
(
aLookup
.
mData
.
is
<
FrameKey
:
:
NormalFrameData
>
(
)
)
{
const
FrameKey
:
:
NormalFrameData
&
data
=
aLookup
.
mData
.
as
<
FrameKey
:
:
NormalFrameData
>
(
)
;
if
(
!
data
.
mLocation
.
empty
(
)
)
{
hash
=
AddToHash
(
hash
HashString
(
data
.
mLocation
.
c_str
(
)
)
)
;
}
hash
=
AddToHash
(
hash
data
.
mRelevantForJS
)
;
if
(
data
.
mLine
.
isSome
(
)
)
{
hash
=
AddToHash
(
hash
*
data
.
mLine
)
;
}
if
(
data
.
mColumn
.
isSome
(
)
)
{
hash
=
AddToHash
(
hash
*
data
.
mColumn
)
;
}
if
(
data
.
mCategoryPair
.
isSome
(
)
)
{
hash
=
AddToHash
(
hash
static_cast
<
uint32_t
>
(
*
data
.
mCategoryPair
)
)
;
}
}
return
hash
;
}
static
bool
match
(
const
FrameKey
&
aKey
const
FrameKey
&
aLookup
)
{
return
aKey
=
=
aLookup
;
}
static
void
rekey
(
FrameKey
&
aKey
const
FrameKey
&
aNewKey
)
{
aKey
=
aNewKey
;
}
}
;
struct
StackKey
{
Maybe
<
uint32_t
>
mPrefixStackIndex
;
uint32_t
mFrameIndex
;
explicit
StackKey
(
uint32_t
aFrame
)
:
mFrameIndex
(
aFrame
)
mHash
(
HashGeneric
(
aFrame
)
)
{
}
StackKey
(
const
StackKey
&
aPrefix
uint32_t
aPrefixStackIndex
uint32_t
aFrame
)
:
mPrefixStackIndex
(
Some
(
aPrefixStackIndex
)
)
mFrameIndex
(
aFrame
)
mHash
(
AddToHash
(
aPrefix
.
mHash
aFrame
)
)
{
}
HashNumber
Hash
(
)
const
{
return
mHash
;
}
bool
operator
=
=
(
const
StackKey
&
aOther
)
const
{
return
mPrefixStackIndex
=
=
aOther
.
mPrefixStackIndex
&
&
mFrameIndex
=
=
aOther
.
mFrameIndex
;
}
private
:
HashNumber
mHash
;
}
;
struct
StackKeyHasher
{
using
Lookup
=
StackKey
;
static
HashNumber
hash
(
const
StackKey
&
aLookup
)
{
return
aLookup
.
Hash
(
)
;
}
static
bool
match
(
const
StackKey
&
aKey
const
StackKey
&
aLookup
)
{
return
aKey
=
=
aLookup
;
}
static
void
rekey
(
StackKey
&
aKey
const
StackKey
&
aNewKey
)
{
aKey
=
aNewKey
;
}
}
;
UniqueStacks
(
)
;
MOZ_MUST_USE
StackKey
BeginStack
(
const
FrameKey
&
aFrame
)
;
MOZ_MUST_USE
StackKey
AppendFrame
(
const
StackKey
&
aStack
const
FrameKey
&
aFrame
)
;
MOZ_MUST_USE
uint32_t
GetOrAddFrameIndex
(
const
FrameKey
&
aFrame
)
;
MOZ_MUST_USE
uint32_t
GetOrAddStackIndex
(
const
StackKey
&
aStack
)
;
void
SpliceFrameTableElements
(
SpliceableJSONWriter
&
aWriter
)
;
void
SpliceStackTableElements
(
SpliceableJSONWriter
&
aWriter
)
;
private
:
void
StreamNonJITFrame
(
const
FrameKey
&
aFrame
)
;
void
StreamStack
(
const
StackKey
&
aStack
)
;
public
:
UniquePtr
<
UniqueJSONStrings
>
mUniqueStrings
;
private
:
SpliceableChunkedJSONWriter
mFrameTableWriter
;
HashMap
<
FrameKey
uint32_t
FrameKeyHasher
>
mFrameToIndexMap
;
SpliceableChunkedJSONWriter
mStackTableWriter
;
HashMap
<
StackKey
uint32_t
StackKeyHasher
>
mStackToIndexMap
;
}
;
}
}
#
endif
