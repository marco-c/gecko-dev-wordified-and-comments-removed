#
include
"
BaseProfiler
.
h
"
#
ifdef
MOZ_BASE_PROFILER
#
include
"
ProfileBufferEntry
.
h
"
#
include
"
platform
.
h
"
#
include
"
ProfileBuffer
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
mozilla
/
StackWalk
.
h
"
#
include
<
ostream
>
namespace
mozilla
{
namespace
baseprofiler
{
ProfileBufferEntry
:
:
ProfileBufferEntry
(
)
:
mKind
(
Kind
:
:
INVALID
)
mStorage
{
0
0
0
0
0
0
0
0
}
{
}
ProfileBufferEntry
:
:
ProfileBufferEntry
(
Kind
aKind
const
char
*
aString
)
:
mKind
(
aKind
)
{
memcpy
(
mStorage
&
aString
sizeof
(
aString
)
)
;
}
ProfileBufferEntry
:
:
ProfileBufferEntry
(
Kind
aKind
char
aChars
[
kNumChars
]
)
:
mKind
(
aKind
)
{
memcpy
(
mStorage
aChars
kNumChars
)
;
}
ProfileBufferEntry
:
:
ProfileBufferEntry
(
Kind
aKind
void
*
aPtr
)
:
mKind
(
aKind
)
{
memcpy
(
mStorage
&
aPtr
sizeof
(
aPtr
)
)
;
}
ProfileBufferEntry
:
:
ProfileBufferEntry
(
Kind
aKind
ProfilerMarker
*
aMarker
)
:
mKind
(
aKind
)
{
memcpy
(
mStorage
&
aMarker
sizeof
(
aMarker
)
)
;
}
ProfileBufferEntry
:
:
ProfileBufferEntry
(
Kind
aKind
double
aDouble
)
:
mKind
(
aKind
)
{
memcpy
(
mStorage
&
aDouble
sizeof
(
aDouble
)
)
;
}
ProfileBufferEntry
:
:
ProfileBufferEntry
(
Kind
aKind
int
aInt
)
:
mKind
(
aKind
)
{
memcpy
(
mStorage
&
aInt
sizeof
(
aInt
)
)
;
}
ProfileBufferEntry
:
:
ProfileBufferEntry
(
Kind
aKind
int64_t
aInt64
)
:
mKind
(
aKind
)
{
memcpy
(
mStorage
&
aInt64
sizeof
(
aInt64
)
)
;
}
ProfileBufferEntry
:
:
ProfileBufferEntry
(
Kind
aKind
uint64_t
aUint64
)
:
mKind
(
aKind
)
{
memcpy
(
mStorage
&
aUint64
sizeof
(
aUint64
)
)
;
}
const
char
*
ProfileBufferEntry
:
:
GetString
(
)
const
{
const
char
*
result
;
memcpy
(
&
result
mStorage
sizeof
(
result
)
)
;
return
result
;
}
void
*
ProfileBufferEntry
:
:
GetPtr
(
)
const
{
void
*
result
;
memcpy
(
&
result
mStorage
sizeof
(
result
)
)
;
return
result
;
}
ProfilerMarker
*
ProfileBufferEntry
:
:
GetMarker
(
)
const
{
ProfilerMarker
*
result
;
memcpy
(
&
result
mStorage
sizeof
(
result
)
)
;
return
result
;
}
double
ProfileBufferEntry
:
:
GetDouble
(
)
const
{
double
result
;
memcpy
(
&
result
mStorage
sizeof
(
result
)
)
;
return
result
;
}
int
ProfileBufferEntry
:
:
GetInt
(
)
const
{
int
result
;
memcpy
(
&
result
mStorage
sizeof
(
result
)
)
;
return
result
;
}
int64_t
ProfileBufferEntry
:
:
GetInt64
(
)
const
{
int64_t
result
;
memcpy
(
&
result
mStorage
sizeof
(
result
)
)
;
return
result
;
}
uint64_t
ProfileBufferEntry
:
:
GetUint64
(
)
const
{
uint64_t
result
;
memcpy
(
&
result
mStorage
sizeof
(
result
)
)
;
return
result
;
}
void
ProfileBufferEntry
:
:
CopyCharsInto
(
char
(
&
aOutArray
)
[
kNumChars
]
)
const
{
memcpy
(
aOutArray
mStorage
kNumChars
)
;
}
class
MOZ_RAII
AutoArraySchemaWriter
{
public
:
AutoArraySchemaWriter
(
SpliceableJSONWriter
&
aWriter
UniqueJSONStrings
&
aStrings
)
:
mJSONWriter
(
aWriter
)
mStrings
(
&
aStrings
)
mNextFreeIndex
(
0
)
{
mJSONWriter
.
StartArrayElement
(
SpliceableJSONWriter
:
:
SingleLineStyle
)
;
}
explicit
AutoArraySchemaWriter
(
SpliceableJSONWriter
&
aWriter
)
:
mJSONWriter
(
aWriter
)
mStrings
(
nullptr
)
mNextFreeIndex
(
0
)
{
mJSONWriter
.
StartArrayElement
(
SpliceableJSONWriter
:
:
SingleLineStyle
)
;
}
~
AutoArraySchemaWriter
(
)
{
mJSONWriter
.
EndArray
(
)
;
}
template
<
typename
T
>
void
IntElement
(
uint32_t
aIndex
T
aValue
)
{
static_assert
(
!
IsSame
<
T
uint64_t
>
:
:
value
"
Narrowing
uint64
-
>
int64
conversion
not
allowed
"
)
;
FillUpTo
(
aIndex
)
;
mJSONWriter
.
IntElement
(
static_cast
<
int64_t
>
(
aValue
)
)
;
}
void
DoubleElement
(
uint32_t
aIndex
double
aValue
)
{
FillUpTo
(
aIndex
)
;
mJSONWriter
.
DoubleElement
(
aValue
)
;
}
void
BoolElement
(
uint32_t
aIndex
bool
aValue
)
{
FillUpTo
(
aIndex
)
;
mJSONWriter
.
BoolElement
(
aValue
)
;
}
void
StringElement
(
uint32_t
aIndex
const
char
*
aValue
)
{
MOZ_RELEASE_ASSERT
(
mStrings
)
;
FillUpTo
(
aIndex
)
;
mStrings
-
>
WriteElement
(
mJSONWriter
aValue
)
;
}
template
<
typename
LambdaT
>
void
FreeFormElement
(
uint32_t
aIndex
LambdaT
aCallback
)
{
MOZ_RELEASE_ASSERT
(
mStrings
)
;
FillUpTo
(
aIndex
)
;
aCallback
(
mJSONWriter
*
mStrings
)
;
}
private
:
void
FillUpTo
(
uint32_t
aIndex
)
{
MOZ_ASSERT
(
aIndex
>
=
mNextFreeIndex
)
;
mJSONWriter
.
NullElements
(
aIndex
-
mNextFreeIndex
)
;
mNextFreeIndex
=
aIndex
+
1
;
}
SpliceableJSONWriter
&
mJSONWriter
;
UniqueJSONStrings
*
mStrings
;
uint32_t
mNextFreeIndex
;
}
;
UniqueJSONStrings
:
:
UniqueJSONStrings
(
)
{
mStringTableWriter
.
StartBareList
(
)
;
}
UniqueJSONStrings
:
:
UniqueJSONStrings
(
const
UniqueJSONStrings
&
aOther
)
{
mStringTableWriter
.
StartBareList
(
)
;
uint32_t
count
=
mStringHashToIndexMap
.
count
(
)
;
if
(
count
!
=
0
)
{
MOZ_RELEASE_ASSERT
(
mStringHashToIndexMap
.
reserve
(
count
)
)
;
for
(
auto
iter
=
aOther
.
mStringHashToIndexMap
.
iter
(
)
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
mStringHashToIndexMap
.
putNewInfallible
(
iter
.
get
(
)
.
key
(
)
iter
.
get
(
)
.
value
(
)
)
;
}
UniquePtr
<
char
[
]
>
stringTableJSON
=
aOther
.
mStringTableWriter
.
WriteFunc
(
)
-
>
CopyData
(
)
;
mStringTableWriter
.
Splice
(
stringTableJSON
.
get
(
)
)
;
}
}
uint32_t
UniqueJSONStrings
:
:
GetOrAddIndex
(
const
char
*
aStr
)
{
uint32_t
count
=
mStringHashToIndexMap
.
count
(
)
;
HashNumber
hash
=
HashString
(
aStr
)
;
auto
entry
=
mStringHashToIndexMap
.
lookupForAdd
(
hash
)
;
if
(
entry
)
{
MOZ_ASSERT
(
entry
-
>
value
(
)
<
count
)
;
return
entry
-
>
value
(
)
;
}
MOZ_RELEASE_ASSERT
(
mStringHashToIndexMap
.
add
(
entry
hash
count
)
)
;
mStringTableWriter
.
StringElement
(
aStr
)
;
return
count
;
}
UniqueStacks
:
:
StackKey
UniqueStacks
:
:
BeginStack
(
const
FrameKey
&
aFrame
)
{
return
StackKey
(
GetOrAddFrameIndex
(
aFrame
)
)
;
}
UniqueStacks
:
:
StackKey
UniqueStacks
:
:
AppendFrame
(
const
StackKey
&
aStack
const
FrameKey
&
aFrame
)
{
return
StackKey
(
aStack
GetOrAddStackIndex
(
aStack
)
GetOrAddFrameIndex
(
aFrame
)
)
;
}
bool
UniqueStacks
:
:
FrameKey
:
:
NormalFrameData
:
:
operator
=
=
(
const
NormalFrameData
&
aOther
)
const
{
return
mLocation
=
=
aOther
.
mLocation
&
&
mRelevantForJS
=
=
aOther
.
mRelevantForJS
&
&
mLine
=
=
aOther
.
mLine
&
&
mColumn
=
=
aOther
.
mColumn
&
&
mCategoryPair
=
=
aOther
.
mCategoryPair
;
}
UniqueStacks
:
:
UniqueStacks
(
)
:
mUniqueStrings
(
MakeUnique
<
UniqueJSONStrings
>
(
)
)
{
mFrameTableWriter
.
StartBareList
(
)
;
mStackTableWriter
.
StartBareList
(
)
;
}
uint32_t
UniqueStacks
:
:
GetOrAddStackIndex
(
const
StackKey
&
aStack
)
{
uint32_t
count
=
mStackToIndexMap
.
count
(
)
;
auto
entry
=
mStackToIndexMap
.
lookupForAdd
(
aStack
)
;
if
(
entry
)
{
MOZ_ASSERT
(
entry
-
>
value
(
)
<
count
)
;
return
entry
-
>
value
(
)
;
}
MOZ_RELEASE_ASSERT
(
mStackToIndexMap
.
add
(
entry
aStack
count
)
)
;
StreamStack
(
aStack
)
;
return
count
;
}
template
<
typename
RangeT
typename
PosT
>
struct
PositionInRangeComparator
final
{
bool
Equals
(
const
RangeT
&
aRange
PosT
aPos
)
const
{
return
aRange
.
mRangeStart
<
=
aPos
&
&
aPos
<
aRange
.
mRangeEnd
;
}
bool
LessThan
(
const
RangeT
&
aRange
PosT
aPos
)
const
{
return
aRange
.
mRangeEnd
<
=
aPos
;
}
}
;
uint32_t
UniqueStacks
:
:
GetOrAddFrameIndex
(
const
FrameKey
&
aFrame
)
{
uint32_t
count
=
mFrameToIndexMap
.
count
(
)
;
auto
entry
=
mFrameToIndexMap
.
lookupForAdd
(
aFrame
)
;
if
(
entry
)
{
MOZ_ASSERT
(
entry
-
>
value
(
)
<
count
)
;
return
entry
-
>
value
(
)
;
}
MOZ_RELEASE_ASSERT
(
mFrameToIndexMap
.
add
(
entry
aFrame
count
)
)
;
StreamNonJITFrame
(
aFrame
)
;
return
count
;
}
void
UniqueStacks
:
:
SpliceFrameTableElements
(
SpliceableJSONWriter
&
aWriter
)
{
mFrameTableWriter
.
EndBareList
(
)
;
aWriter
.
TakeAndSplice
(
mFrameTableWriter
.
WriteFunc
(
)
)
;
}
void
UniqueStacks
:
:
SpliceStackTableElements
(
SpliceableJSONWriter
&
aWriter
)
{
mStackTableWriter
.
EndBareList
(
)
;
aWriter
.
TakeAndSplice
(
mStackTableWriter
.
WriteFunc
(
)
)
;
}
void
UniqueStacks
:
:
StreamStack
(
const
StackKey
&
aStack
)
{
enum
Schema
:
uint32_t
{
PREFIX
=
0
FRAME
=
1
}
;
AutoArraySchemaWriter
writer
(
mStackTableWriter
*
mUniqueStrings
)
;
if
(
aStack
.
mPrefixStackIndex
.
isSome
(
)
)
{
writer
.
IntElement
(
PREFIX
*
aStack
.
mPrefixStackIndex
)
;
}
writer
.
IntElement
(
FRAME
aStack
.
mFrameIndex
)
;
}
void
UniqueStacks
:
:
StreamNonJITFrame
(
const
FrameKey
&
aFrame
)
{
using
NormalFrameData
=
FrameKey
:
:
NormalFrameData
;
enum
Schema
:
uint32_t
{
LOCATION
=
0
RELEVANT_FOR_JS
=
1
IMPLEMENTATION
=
2
OPTIMIZATIONS
=
3
LINE
=
4
COLUMN
=
5
CATEGORY
=
6
SUBCATEGORY
=
7
}
;
AutoArraySchemaWriter
writer
(
mFrameTableWriter
*
mUniqueStrings
)
;
const
NormalFrameData
&
data
=
aFrame
.
mData
.
as
<
NormalFrameData
>
(
)
;
writer
.
StringElement
(
LOCATION
data
.
mLocation
.
c_str
(
)
)
;
writer
.
BoolElement
(
RELEVANT_FOR_JS
data
.
mRelevantForJS
)
;
if
(
data
.
mLine
.
isSome
(
)
)
{
writer
.
IntElement
(
LINE
*
data
.
mLine
)
;
}
if
(
data
.
mColumn
.
isSome
(
)
)
{
writer
.
IntElement
(
COLUMN
*
data
.
mColumn
)
;
}
if
(
data
.
mCategoryPair
.
isSome
(
)
)
{
const
ProfilingCategoryPairInfo
&
info
=
GetProfilingCategoryPairInfo
(
*
data
.
mCategoryPair
)
;
writer
.
IntElement
(
CATEGORY
uint32_t
(
info
.
mCategory
)
)
;
writer
.
IntElement
(
SUBCATEGORY
info
.
mSubcategoryIndex
)
;
}
}
struct
CStringWriteFunc
:
public
JSONWriteFunc
{
std
:
:
string
&
mBuffer
;
explicit
CStringWriteFunc
(
std
:
:
string
&
aBuffer
)
:
mBuffer
(
aBuffer
)
{
}
void
Write
(
const
char
*
aStr
)
override
{
mBuffer
+
=
aStr
;
}
}
;
struct
ProfileSample
{
uint32_t
mStack
;
double
mTime
;
Maybe
<
double
>
mResponsiveness
;
}
;
static
void
WriteSample
(
SpliceableJSONWriter
&
aWriter
UniqueJSONStrings
&
aUniqueStrings
const
ProfileSample
&
aSample
)
{
enum
Schema
:
uint32_t
{
STACK
=
0
TIME
=
1
RESPONSIVENESS
=
2
}
;
AutoArraySchemaWriter
writer
(
aWriter
aUniqueStrings
)
;
writer
.
IntElement
(
STACK
aSample
.
mStack
)
;
writer
.
DoubleElement
(
TIME
aSample
.
mTime
)
;
if
(
aSample
.
mResponsiveness
.
isSome
(
)
)
{
writer
.
DoubleElement
(
RESPONSIVENESS
*
aSample
.
mResponsiveness
)
;
}
}
class
EntryGetter
{
public
:
explicit
EntryGetter
(
const
ProfileBuffer
&
aBuffer
uint64_t
aInitialReadPos
=
0
)
:
mBuffer
(
aBuffer
)
mReadPos
(
aBuffer
.
mRangeStart
)
{
if
(
aInitialReadPos
!
=
0
)
{
MOZ_RELEASE_ASSERT
(
aInitialReadPos
>
=
aBuffer
.
mRangeStart
&
&
aInitialReadPos
<
=
aBuffer
.
mRangeEnd
)
;
mReadPos
=
aInitialReadPos
;
}
}
bool
Has
(
)
const
{
return
mReadPos
!
=
mBuffer
.
mRangeEnd
;
}
const
ProfileBufferEntry
&
Get
(
)
const
{
return
mBuffer
.
GetEntry
(
mReadPos
)
;
}
void
Next
(
)
{
mReadPos
+
+
;
}
uint64_t
CurPos
(
)
{
return
mReadPos
;
}
private
:
const
ProfileBuffer
&
mBuffer
;
uint64_t
mReadPos
;
}
;
#
define
ERROR_AND_CONTINUE
(
msg
)
\
{
\
fprintf
(
stderr
"
ProfileBuffer
parse
error
:
%
s
"
msg
)
;
\
MOZ_ASSERT
(
false
msg
)
;
\
continue
;
\
}
void
ProfileBuffer
:
:
StreamSamplesToJSON
(
SpliceableJSONWriter
&
aWriter
int
aThreadId
double
aSinceTime
UniqueStacks
&
aUniqueStacks
)
const
{
UniquePtr
<
char
[
]
>
dynStrBuf
=
MakeUnique
<
char
[
]
>
(
kMaxFrameKeyLength
)
;
EntryGetter
e
(
*
this
)
;
for
(
;
;
)
{
while
(
e
.
Has
(
)
)
{
if
(
e
.
Get
(
)
.
IsThreadId
(
)
)
{
break
;
}
else
{
e
.
Next
(
)
;
}
}
if
(
!
e
.
Has
(
)
)
{
break
;
}
if
(
e
.
Get
(
)
.
IsThreadId
(
)
)
{
int
threadId
=
e
.
Get
(
)
.
GetInt
(
)
;
e
.
Next
(
)
;
if
(
threadId
!
=
aThreadId
)
{
continue
;
}
}
else
{
MOZ_CRASH
(
)
;
}
ProfileSample
sample
;
if
(
e
.
Has
(
)
&
&
e
.
Get
(
)
.
IsTime
(
)
)
{
sample
.
mTime
=
e
.
Get
(
)
.
GetDouble
(
)
;
e
.
Next
(
)
;
if
(
sample
.
mTime
<
aSinceTime
)
{
continue
;
}
}
else
{
ERROR_AND_CONTINUE
(
"
expected
a
Time
entry
"
)
;
}
UniqueStacks
:
:
StackKey
stack
=
aUniqueStacks
.
BeginStack
(
UniqueStacks
:
:
FrameKey
(
"
(
root
)
"
)
)
;
int
numFrames
=
0
;
while
(
e
.
Has
(
)
)
{
if
(
e
.
Get
(
)
.
IsNativeLeafAddr
(
)
)
{
numFrames
+
+
;
void
*
pc
=
e
.
Get
(
)
.
GetPtr
(
)
;
e
.
Next
(
)
;
static
const
uint32_t
BUF_SIZE
=
256
;
char
buf
[
BUF_SIZE
]
;
unsigned
long
long
pcULL
=
(
unsigned
long
long
)
(
uintptr_t
)
pc
;
SprintfLiteral
(
buf
"
%
#
llx
"
pcULL
)
;
static
const
bool
preSymbolicate
=
[
]
(
)
{
const
char
*
symbolicate
=
getenv
(
"
MOZ_BASE_PROFILER_SYMBOLICATE
"
)
;
return
symbolicate
&
&
symbolicate
[
0
]
!
=
'
\
0
'
;
}
(
)
;
if
(
preSymbolicate
)
{
MozCodeAddressDetails
details
;
if
(
MozDescribeCodeAddress
(
pc
&
details
)
)
{
const
uint32_t
pcLen
=
strlen
(
buf
)
;
buf
[
pcLen
]
=
'
'
;
MozFormatCodeAddressDetails
(
buf
+
pcLen
+
1
BUF_SIZE
-
(
pcLen
+
1
)
0
pc
&
details
)
;
}
}
stack
=
aUniqueStacks
.
AppendFrame
(
stack
UniqueStacks
:
:
FrameKey
(
buf
)
)
;
}
else
if
(
e
.
Get
(
)
.
IsLabel
(
)
)
{
numFrames
+
+
;
const
char
*
label
=
e
.
Get
(
)
.
GetString
(
)
;
e
.
Next
(
)
;
using
FrameFlags
=
ProfilingStackFrame
:
:
Flags
;
uint32_t
frameFlags
=
0
;
if
(
e
.
Has
(
)
&
&
e
.
Get
(
)
.
IsFrameFlags
(
)
)
{
frameFlags
=
uint32_t
(
e
.
Get
(
)
.
GetUint64
(
)
)
;
e
.
Next
(
)
;
}
bool
relevantForJS
=
frameFlags
&
uint32_t
(
FrameFlags
:
:
RELEVANT_FOR_JS
)
;
size_t
i
=
0
;
dynStrBuf
[
0
]
=
'
\
0
'
;
while
(
e
.
Has
(
)
)
{
if
(
e
.
Get
(
)
.
IsDynamicStringFragment
(
)
)
{
char
chars
[
ProfileBufferEntry
:
:
kNumChars
]
;
e
.
Get
(
)
.
CopyCharsInto
(
chars
)
;
for
(
char
c
:
chars
)
{
if
(
i
<
kMaxFrameKeyLength
)
{
dynStrBuf
[
i
]
=
c
;
i
+
+
;
}
}
e
.
Next
(
)
;
}
else
{
break
;
}
}
dynStrBuf
[
kMaxFrameKeyLength
-
1
]
=
'
\
0
'
;
bool
hasDynamicString
=
(
i
!
=
0
)
;
std
:
:
string
frameLabel
;
if
(
label
[
0
]
!
=
'
\
0
'
&
&
hasDynamicString
)
{
if
(
frameFlags
&
uint32_t
(
FrameFlags
:
:
STRING_TEMPLATE_METHOD
)
)
{
frameLabel
+
=
label
;
frameLabel
+
=
'
.
'
;
frameLabel
+
=
dynStrBuf
.
get
(
)
;
}
else
if
(
frameFlags
&
uint32_t
(
FrameFlags
:
:
STRING_TEMPLATE_GETTER
)
)
{
frameLabel
+
=
"
get
"
;
frameLabel
+
=
label
;
frameLabel
+
=
'
.
'
;
frameLabel
+
=
dynStrBuf
.
get
(
)
;
}
else
if
(
frameFlags
&
uint32_t
(
FrameFlags
:
:
STRING_TEMPLATE_SETTER
)
)
{
frameLabel
+
=
"
set
"
;
frameLabel
+
=
label
;
frameLabel
+
=
'
.
'
;
frameLabel
+
=
dynStrBuf
.
get
(
)
;
}
else
{
frameLabel
+
=
label
;
frameLabel
+
=
'
'
;
frameLabel
+
=
dynStrBuf
.
get
(
)
;
}
}
else
if
(
hasDynamicString
)
{
frameLabel
+
=
dynStrBuf
.
get
(
)
;
}
else
{
frameLabel
+
=
label
;
}
Maybe
<
unsigned
>
line
;
if
(
e
.
Has
(
)
&
&
e
.
Get
(
)
.
IsLineNumber
(
)
)
{
line
=
Some
(
unsigned
(
e
.
Get
(
)
.
GetInt
(
)
)
)
;
e
.
Next
(
)
;
}
Maybe
<
unsigned
>
column
;
if
(
e
.
Has
(
)
&
&
e
.
Get
(
)
.
IsColumnNumber
(
)
)
{
column
=
Some
(
unsigned
(
e
.
Get
(
)
.
GetInt
(
)
)
)
;
e
.
Next
(
)
;
}
Maybe
<
ProfilingCategoryPair
>
categoryPair
;
if
(
e
.
Has
(
)
&
&
e
.
Get
(
)
.
IsCategoryPair
(
)
)
{
categoryPair
=
Some
(
ProfilingCategoryPair
(
uint32_t
(
e
.
Get
(
)
.
GetInt
(
)
)
)
)
;
e
.
Next
(
)
;
}
stack
=
aUniqueStacks
.
AppendFrame
(
stack
UniqueStacks
:
:
FrameKey
(
std
:
:
move
(
frameLabel
)
relevantForJS
line
column
categoryPair
)
)
;
}
else
{
break
;
}
}
if
(
numFrames
=
=
0
)
{
continue
;
}
sample
.
mStack
=
aUniqueStacks
.
GetOrAddStackIndex
(
stack
)
;
while
(
e
.
Has
(
)
)
{
if
(
e
.
Get
(
)
.
IsMarker
(
)
)
{
e
.
Next
(
)
;
}
else
{
break
;
}
}
if
(
e
.
Has
(
)
&
&
e
.
Get
(
)
.
IsResponsiveness
(
)
)
{
sample
.
mResponsiveness
=
Some
(
e
.
Get
(
)
.
GetDouble
(
)
)
;
e
.
Next
(
)
;
}
WriteSample
(
aWriter
*
aUniqueStacks
.
mUniqueStrings
sample
)
;
}
}
void
ProfileBuffer
:
:
StreamMarkersToJSON
(
SpliceableJSONWriter
&
aWriter
int
aThreadId
const
TimeStamp
&
aProcessStartTime
double
aSinceTime
UniqueStacks
&
aUniqueStacks
)
const
{
EntryGetter
e
(
*
this
)
;
while
(
e
.
Has
(
)
)
{
if
(
e
.
Get
(
)
.
IsMarker
(
)
)
{
const
ProfilerMarker
*
marker
=
e
.
Get
(
)
.
GetMarker
(
)
;
if
(
marker
-
>
GetTime
(
)
>
=
aSinceTime
&
&
marker
-
>
GetThreadId
(
)
=
=
aThreadId
)
{
marker
-
>
StreamJSON
(
aWriter
aProcessStartTime
aUniqueStacks
)
;
}
}
e
.
Next
(
)
;
}
}
void
ProfileBuffer
:
:
StreamProfilerOverheadToJSON
(
SpliceableJSONWriter
&
aWriter
const
TimeStamp
&
aProcessStartTime
double
aSinceTime
)
const
{
enum
Schema
:
uint32_t
{
TIME
=
0
LOCKING
=
1
MARKER_CLEANING
=
2
COUNTERS
=
3
THREADS
=
4
}
;
EntryGetter
e
(
*
this
)
;
aWriter
.
StartObjectProperty
(
"
profilerOverhead_UNSTABLE
"
)
;
{
JSONSchemaWriter
schema
(
aWriter
)
;
schema
.
WriteField
(
"
time
"
)
;
schema
.
WriteField
(
"
locking
"
)
;
schema
.
WriteField
(
"
expiredMarkerCleaning
"
)
;
schema
.
WriteField
(
"
counters
"
)
;
schema
.
WriteField
(
"
threads
"
)
;
}
aWriter
.
StartArrayProperty
(
"
data
"
)
;
double
firstTime
=
0
.
0
;
double
lastTime
=
0
.
0
;
ProfilerStats
intervals
overheads
lockings
cleanings
counters
threads
;
while
(
e
.
Has
(
)
)
{
if
(
e
.
Get
(
)
.
IsProfilerOverheadTime
(
)
)
{
double
time
=
e
.
Get
(
)
.
GetDouble
(
)
;
if
(
time
>
=
aSinceTime
)
{
e
.
Next
(
)
;
if
(
!
e
.
Has
(
)
|
|
!
e
.
Get
(
)
.
IsProfilerOverheadDuration
(
)
)
{
ERROR_AND_CONTINUE
(
"
expected
a
ProfilerOverheadDuration
entry
after
"
"
ProfilerOverheadTime
"
)
;
}
double
locking
=
e
.
Get
(
)
.
GetDouble
(
)
;
e
.
Next
(
)
;
if
(
!
e
.
Has
(
)
|
|
!
e
.
Get
(
)
.
IsProfilerOverheadDuration
(
)
)
{
ERROR_AND_CONTINUE
(
"
expected
a
ProfilerOverheadDuration
entry
after
"
"
ProfilerOverheadTime
ProfilerOverheadDuration
"
)
;
}
double
cleaning
=
e
.
Get
(
)
.
GetDouble
(
)
;
e
.
Next
(
)
;
if
(
!
e
.
Has
(
)
|
|
!
e
.
Get
(
)
.
IsProfilerOverheadDuration
(
)
)
{
ERROR_AND_CONTINUE
(
"
expected
a
ProfilerOverheadDuration
entry
after
"
"
ProfilerOverheadTime
ProfilerOverheadDuration
*
2
"
)
;
}
double
counter
=
e
.
Get
(
)
.
GetDouble
(
)
;
e
.
Next
(
)
;
if
(
!
e
.
Has
(
)
|
|
!
e
.
Get
(
)
.
IsProfilerOverheadDuration
(
)
)
{
ERROR_AND_CONTINUE
(
"
expected
a
ProfilerOverheadDuration
entry
after
"
"
ProfilerOverheadTime
ProfilerOverheadDuration
*
3
"
)
;
}
double
thread
=
e
.
Get
(
)
.
GetDouble
(
)
;
if
(
firstTime
=
=
0
.
0
)
{
firstTime
=
time
;
}
else
{
intervals
.
Count
(
time
-
lastTime
)
;
}
lastTime
=
time
;
overheads
.
Count
(
locking
+
cleaning
+
counter
+
thread
)
;
lockings
.
Count
(
locking
)
;
cleanings
.
Count
(
cleaning
)
;
counters
.
Count
(
counter
)
;
threads
.
Count
(
thread
)
;
AutoArraySchemaWriter
writer
(
aWriter
)
;
writer
.
DoubleElement
(
TIME
time
)
;
writer
.
DoubleElement
(
LOCKING
locking
)
;
writer
.
DoubleElement
(
MARKER_CLEANING
cleaning
)
;
writer
.
DoubleElement
(
COUNTERS
counter
)
;
writer
.
DoubleElement
(
THREADS
thread
)
;
}
}
e
.
Next
(
)
;
}
aWriter
.
EndArray
(
)
;
if
(
intervals
.
n
>
0
)
{
aWriter
.
StartObjectProperty
(
"
statistics
"
)
;
aWriter
.
DoubleProperty
(
"
profiledDuration
"
lastTime
-
firstTime
)
;
aWriter
.
IntProperty
(
"
samplingCount
"
overheads
.
n
)
;
aWriter
.
DoubleProperty
(
"
overheadDurations
"
overheads
.
sum
)
;
aWriter
.
DoubleProperty
(
"
overheadPercentage
"
overheads
.
sum
/
(
lastTime
-
firstTime
)
)
;
#
define
PROFILER_STATS
(
name
var
)
\
aWriter
.
DoubleProperty
(
"
mean
"
name
(
var
)
.
sum
/
(
var
)
.
n
)
;
\
aWriter
.
DoubleProperty
(
"
min
"
name
(
var
)
.
min
)
;
\
aWriter
.
DoubleProperty
(
"
max
"
name
(
var
)
.
max
)
;
PROFILER_STATS
(
"
Interval
"
intervals
)
;
PROFILER_STATS
(
"
Overhead
"
overheads
)
;
PROFILER_STATS
(
"
Lockings
"
lockings
)
;
PROFILER_STATS
(
"
Cleaning
"
cleanings
)
;
PROFILER_STATS
(
"
Counter
"
counters
)
;
PROFILER_STATS
(
"
Thread
"
threads
)
;
#
undef
PROFILER_STATS
aWriter
.
EndObject
(
)
;
}
aWriter
.
EndObject
(
)
;
}
struct
CounterKeyedSample
{
double
mTime
;
uint64_t
mNumber
;
int64_t
mCount
;
}
;
using
CounterKeyedSamples
=
Vector
<
CounterKeyedSample
>
;
using
CounterMap
=
HashMap
<
uint64_t
CounterKeyedSamples
>
;
template
<
typename
HashM
typename
Key
>
static
auto
&
LookupOrAdd
(
HashM
&
aMap
Key
&
&
aKey
)
{
auto
addPtr
=
aMap
.
lookupForAdd
(
aKey
)
;
if
(
!
addPtr
)
{
MOZ_RELEASE_ASSERT
(
aMap
.
add
(
addPtr
std
:
:
forward
<
Key
>
(
aKey
)
typename
HashM
:
:
Entry
:
:
ValueType
{
}
)
)
;
MOZ_ASSERT
(
!
!
addPtr
)
;
}
return
addPtr
-
>
value
(
)
;
}
void
ProfileBuffer
:
:
StreamCountersToJSON
(
SpliceableJSONWriter
&
aWriter
const
TimeStamp
&
aProcessStartTime
double
aSinceTime
)
const
{
EntryGetter
e
(
*
this
)
;
enum
Schema
:
uint32_t
{
TIME
=
0
NUMBER
=
1
COUNT
=
2
}
;
HashMap
<
void
*
CounterMap
>
counters
;
while
(
e
.
Has
(
)
)
{
if
(
e
.
Get
(
)
.
IsCounterId
(
)
)
{
void
*
id
=
e
.
Get
(
)
.
GetPtr
(
)
;
CounterMap
&
counter
=
LookupOrAdd
(
counters
id
)
;
e
.
Next
(
)
;
if
(
!
e
.
Has
(
)
|
|
!
e
.
Get
(
)
.
IsTime
(
)
)
{
ERROR_AND_CONTINUE
(
"
expected
a
Time
entry
"
)
;
}
double
time
=
e
.
Get
(
)
.
GetDouble
(
)
;
if
(
time
>
=
aSinceTime
)
{
e
.
Next
(
)
;
while
(
e
.
Has
(
)
&
&
e
.
Get
(
)
.
IsCounterKey
(
)
)
{
uint64_t
key
=
e
.
Get
(
)
.
GetUint64
(
)
;
CounterKeyedSamples
&
data
=
LookupOrAdd
(
counter
key
)
;
e
.
Next
(
)
;
if
(
!
e
.
Has
(
)
|
|
!
e
.
Get
(
)
.
IsCount
(
)
)
{
ERROR_AND_CONTINUE
(
"
expected
a
Count
entry
"
)
;
}
int64_t
count
=
e
.
Get
(
)
.
GetUint64
(
)
;
e
.
Next
(
)
;
uint64_t
number
;
if
(
!
e
.
Has
(
)
|
|
!
e
.
Get
(
)
.
IsNumber
(
)
)
{
number
=
0
;
}
else
{
number
=
e
.
Get
(
)
.
GetInt64
(
)
;
}
CounterKeyedSample
sample
=
{
time
number
count
}
;
MOZ_RELEASE_ASSERT
(
data
.
append
(
sample
)
)
;
}
}
else
{
}
}
e
.
Next
(
)
;
}
if
(
counters
.
count
(
)
=
=
0
)
{
return
;
}
aWriter
.
StartArrayProperty
(
"
counters
"
)
;
for
(
auto
iter
=
counters
.
iter
(
)
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
CounterMap
&
counter
=
iter
.
get
(
)
.
value
(
)
;
const
BaseProfilerCount
*
base_counter
=
static_cast
<
const
BaseProfilerCount
*
>
(
iter
.
get
(
)
.
key
(
)
)
;
aWriter
.
Start
(
)
;
aWriter
.
StringProperty
(
"
name
"
base_counter
-
>
mLabel
)
;
aWriter
.
StringProperty
(
"
category
"
base_counter
-
>
mCategory
)
;
aWriter
.
StringProperty
(
"
description
"
base_counter
-
>
mDescription
)
;
aWriter
.
StartObjectProperty
(
"
sample_groups
"
)
;
for
(
auto
counter_iter
=
counter
.
iter
(
)
;
!
counter_iter
.
done
(
)
;
counter_iter
.
next
(
)
)
{
CounterKeyedSamples
&
samples
=
counter_iter
.
get
(
)
.
value
(
)
;
uint64_t
key
=
counter_iter
.
get
(
)
.
key
(
)
;
size_t
size
=
samples
.
length
(
)
;
if
(
size
=
=
0
)
{
continue
;
}
aWriter
.
IntProperty
(
"
id
"
static_cast
<
int64_t
>
(
key
)
)
;
aWriter
.
StartObjectProperty
(
"
samples
"
)
;
{
JSONSchemaWriter
schema
(
aWriter
)
;
schema
.
WriteField
(
"
time
"
)
;
schema
.
WriteField
(
"
number
"
)
;
schema
.
WriteField
(
"
count
"
)
;
}
aWriter
.
StartArrayProperty
(
"
data
"
)
;
uint64_t
previousNumber
=
0
;
int64_t
previousCount
=
0
;
for
(
size_t
i
=
0
;
i
<
size
;
i
+
+
)
{
if
(
i
=
=
0
|
|
samples
[
i
]
.
mNumber
!
=
previousNumber
|
|
samples
[
i
]
.
mCount
!
=
previousCount
)
{
MOZ_ASSERT
(
i
=
=
0
|
|
samples
[
i
]
.
mTime
>
=
samples
[
i
-
1
]
.
mTime
)
;
MOZ_ASSERT
(
samples
[
i
]
.
mNumber
>
=
previousNumber
)
;
MOZ_ASSERT
(
samples
[
i
]
.
mNumber
-
previousNumber
<
=
uint64_t
(
std
:
:
numeric_limits
<
int64_t
>
:
:
max
(
)
)
)
;
AutoArraySchemaWriter
writer
(
aWriter
)
;
writer
.
DoubleElement
(
TIME
samples
[
i
]
.
mTime
)
;
writer
.
IntElement
(
NUMBER
static_cast
<
int64_t
>
(
samples
[
i
]
.
mNumber
-
previousNumber
)
)
;
writer
.
IntElement
(
COUNT
samples
[
i
]
.
mCount
-
previousCount
)
;
previousNumber
=
samples
[
i
]
.
mNumber
;
previousCount
=
samples
[
i
]
.
mCount
;
}
}
aWriter
.
EndArray
(
)
;
aWriter
.
EndObject
(
)
;
}
aWriter
.
EndObject
(
)
;
aWriter
.
End
(
)
;
}
aWriter
.
EndArray
(
)
;
}
#
undef
ERROR_AND_CONTINUE
static
void
AddPausedRange
(
SpliceableJSONWriter
&
aWriter
const
char
*
aReason
const
Maybe
<
double
>
&
aStartTime
const
Maybe
<
double
>
&
aEndTime
)
{
aWriter
.
Start
(
)
;
if
(
aStartTime
)
{
aWriter
.
DoubleProperty
(
"
startTime
"
*
aStartTime
)
;
}
else
{
aWriter
.
NullProperty
(
"
startTime
"
)
;
}
if
(
aEndTime
)
{
aWriter
.
DoubleProperty
(
"
endTime
"
*
aEndTime
)
;
}
else
{
aWriter
.
NullProperty
(
"
endTime
"
)
;
}
aWriter
.
StringProperty
(
"
reason
"
aReason
)
;
aWriter
.
End
(
)
;
}
void
ProfileBuffer
:
:
StreamPausedRangesToJSON
(
SpliceableJSONWriter
&
aWriter
double
aSinceTime
)
const
{
EntryGetter
e
(
*
this
)
;
Maybe
<
double
>
currentPauseStartTime
;
Maybe
<
double
>
currentCollectionStartTime
;
while
(
e
.
Has
(
)
)
{
if
(
e
.
Get
(
)
.
IsPause
(
)
)
{
currentPauseStartTime
=
Some
(
e
.
Get
(
)
.
GetDouble
(
)
)
;
}
else
if
(
e
.
Get
(
)
.
IsResume
(
)
)
{
AddPausedRange
(
aWriter
"
profiler
-
paused
"
currentPauseStartTime
Some
(
e
.
Get
(
)
.
GetDouble
(
)
)
)
;
currentPauseStartTime
=
Nothing
(
)
;
}
else
if
(
e
.
Get
(
)
.
IsCollectionStart
(
)
)
{
currentCollectionStartTime
=
Some
(
e
.
Get
(
)
.
GetDouble
(
)
)
;
}
else
if
(
e
.
Get
(
)
.
IsCollectionEnd
(
)
)
{
AddPausedRange
(
aWriter
"
collecting
"
currentCollectionStartTime
Some
(
e
.
Get
(
)
.
GetDouble
(
)
)
)
;
currentCollectionStartTime
=
Nothing
(
)
;
}
e
.
Next
(
)
;
}
if
(
currentPauseStartTime
)
{
AddPausedRange
(
aWriter
"
profiler
-
paused
"
currentPauseStartTime
Nothing
(
)
)
;
}
if
(
currentCollectionStartTime
)
{
AddPausedRange
(
aWriter
"
collecting
"
currentCollectionStartTime
Nothing
(
)
)
;
}
}
bool
ProfileBuffer
:
:
DuplicateLastSample
(
int
aThreadId
const
TimeStamp
&
aProcessStartTime
Maybe
<
uint64_t
>
&
aLastSample
)
{
if
(
aLastSample
&
&
*
aLastSample
<
mRangeStart
)
{
aLastSample
.
reset
(
)
;
}
if
(
!
aLastSample
)
{
return
false
;
}
uint64_t
lastSampleStartPos
=
*
aLastSample
;
MOZ_RELEASE_ASSERT
(
GetEntry
(
lastSampleStartPos
)
.
IsThreadId
(
)
&
&
GetEntry
(
lastSampleStartPos
)
.
GetInt
(
)
=
=
aThreadId
)
;
aLastSample
=
Some
(
AddThreadIdEntry
(
aThreadId
)
)
;
EntryGetter
e
(
*
this
lastSampleStartPos
+
1
)
;
while
(
e
.
Has
(
)
)
{
switch
(
e
.
Get
(
)
.
GetKind
(
)
)
{
case
ProfileBufferEntry
:
:
Kind
:
:
Pause
:
case
ProfileBufferEntry
:
:
Kind
:
:
Resume
:
case
ProfileBufferEntry
:
:
Kind
:
:
CollectionStart
:
case
ProfileBufferEntry
:
:
Kind
:
:
CollectionEnd
:
case
ProfileBufferEntry
:
:
Kind
:
:
ThreadId
:
return
true
;
case
ProfileBufferEntry
:
:
Kind
:
:
Time
:
AddEntry
(
ProfileBufferEntry
:
:
Time
(
(
TimeStamp
:
:
NowUnfuzzed
(
)
-
aProcessStartTime
)
.
ToMilliseconds
(
)
)
)
;
break
;
case
ProfileBufferEntry
:
:
Kind
:
:
Marker
:
case
ProfileBufferEntry
:
:
Kind
:
:
CounterKey
:
case
ProfileBufferEntry
:
:
Kind
:
:
Number
:
case
ProfileBufferEntry
:
:
Kind
:
:
Count
:
case
ProfileBufferEntry
:
:
Kind
:
:
Responsiveness
:
break
;
case
ProfileBufferEntry
:
:
Kind
:
:
CounterId
:
e
.
Next
(
)
;
if
(
e
.
Has
(
)
&
&
e
.
Get
(
)
.
GetKind
(
)
!
=
ProfileBufferEntry
:
:
Kind
:
:
Time
)
{
continue
;
}
break
;
case
ProfileBufferEntry
:
:
Kind
:
:
ProfilerOverheadTime
:
e
.
Next
(
)
;
if
(
e
.
Has
(
)
&
&
e
.
Get
(
)
.
GetKind
(
)
!
=
ProfileBufferEntry
:
:
Kind
:
:
ProfilerOverheadDuration
)
{
continue
;
}
e
.
Next
(
)
;
if
(
e
.
Has
(
)
&
&
e
.
Get
(
)
.
GetKind
(
)
!
=
ProfileBufferEntry
:
:
Kind
:
:
ProfilerOverheadDuration
)
{
continue
;
}
e
.
Next
(
)
;
if
(
e
.
Has
(
)
&
&
e
.
Get
(
)
.
GetKind
(
)
!
=
ProfileBufferEntry
:
:
Kind
:
:
ProfilerOverheadDuration
)
{
continue
;
}
e
.
Next
(
)
;
if
(
e
.
Has
(
)
&
&
e
.
Get
(
)
.
GetKind
(
)
!
=
ProfileBufferEntry
:
:
Kind
:
:
ProfilerOverheadDuration
)
{
continue
;
}
break
;
default
:
{
ProfileBufferEntry
entry
=
e
.
Get
(
)
;
AddEntry
(
entry
)
;
break
;
}
}
e
.
Next
(
)
;
}
return
true
;
}
void
ProfileBuffer
:
:
DiscardSamplesBeforeTime
(
double
aTime
)
{
EntryGetter
e
(
*
this
)
;
for
(
;
;
)
{
while
(
e
.
Has
(
)
)
{
if
(
e
.
Get
(
)
.
IsThreadId
(
)
)
{
break
;
}
else
{
e
.
Next
(
)
;
}
}
if
(
!
e
.
Has
(
)
)
{
break
;
}
MOZ_RELEASE_ASSERT
(
e
.
Get
(
)
.
IsThreadId
(
)
)
;
uint64_t
sampleStartPos
=
e
.
CurPos
(
)
;
e
.
Next
(
)
;
if
(
e
.
Has
(
)
&
&
e
.
Get
(
)
.
IsTime
(
)
)
{
double
sampleTime
=
e
.
Get
(
)
.
GetDouble
(
)
;
if
(
sampleTime
>
=
aTime
)
{
mRangeStart
=
sampleStartPos
;
return
;
}
}
}
}
}
}
#
endif
