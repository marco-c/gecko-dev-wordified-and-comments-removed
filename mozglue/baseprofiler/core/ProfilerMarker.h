#
ifndef
ProfilerMarker_h
#
define
ProfilerMarker_h
#
include
"
ProfileBufferEntry
.
h
"
#
include
"
BaseProfileJSONWriter
.
h
"
#
include
"
BaseProfilerMarkerPayload
.
h
"
#
include
"
mozilla
/
UniquePtrExtensions
.
h
"
namespace
mozilla
{
namespace
baseprofiler
{
template
<
typename
T
>
class
ProfilerLinkedList
;
class
ProfilerMarker
{
friend
class
ProfilerLinkedList
<
ProfilerMarker
>
;
public
:
explicit
ProfilerMarker
(
const
char
*
aMarkerName
ProfilingCategoryPair
aCategoryPair
int
aThreadId
UniquePtr
<
ProfilerMarkerPayload
>
aPayload
=
nullptr
double
aTime
=
0
)
:
mMarkerName
(
strdup
(
aMarkerName
)
)
mPayload
(
std
:
:
move
(
aPayload
)
)
mNext
{
nullptr
}
mTime
(
aTime
)
mPositionInBuffer
{
0
}
mThreadId
{
aThreadId
}
mCategoryPair
{
aCategoryPair
}
{
}
void
SetPositionInBuffer
(
uint64_t
aPosition
)
{
mPositionInBuffer
=
aPosition
;
}
bool
HasExpired
(
uint64_t
aBufferRangeStart
)
const
{
return
mPositionInBuffer
<
aBufferRangeStart
;
}
double
GetTime
(
)
const
{
return
mTime
;
}
int
GetThreadId
(
)
const
{
return
mThreadId
;
}
void
StreamJSON
(
SpliceableJSONWriter
&
aWriter
const
TimeStamp
&
aProcessStartTime
UniqueStacks
&
aUniqueStacks
)
const
{
aWriter
.
StartArrayElement
(
)
;
{
aUniqueStacks
.
mUniqueStrings
-
>
WriteElement
(
aWriter
mMarkerName
.
get
(
)
)
;
aWriter
.
DoubleElement
(
mTime
)
;
const
ProfilingCategoryPairInfo
&
info
=
GetProfilingCategoryPairInfo
(
mCategoryPair
)
;
aWriter
.
IntElement
(
unsigned
(
info
.
mCategory
)
)
;
if
(
mPayload
)
{
aWriter
.
StartObjectElement
(
SpliceableJSONWriter
:
:
SingleLineStyle
)
;
{
mPayload
-
>
StreamPayload
(
aWriter
aProcessStartTime
aUniqueStacks
)
;
}
aWriter
.
EndObject
(
)
;
}
}
aWriter
.
EndArray
(
)
;
}
private
:
UniqueFreePtr
<
char
>
mMarkerName
;
UniquePtr
<
ProfilerMarkerPayload
>
mPayload
;
ProfilerMarker
*
mNext
;
double
mTime
;
uint64_t
mPositionInBuffer
;
int
mThreadId
;
ProfilingCategoryPair
mCategoryPair
;
}
;
template
<
typename
T
>
class
ProfilerLinkedList
{
public
:
ProfilerLinkedList
(
)
:
mHead
(
nullptr
)
mTail
(
nullptr
)
{
}
void
insert
(
T
*
aElem
)
{
if
(
!
mTail
)
{
mHead
=
aElem
;
mTail
=
aElem
;
}
else
{
mTail
-
>
mNext
=
aElem
;
mTail
=
aElem
;
}
aElem
-
>
mNext
=
nullptr
;
}
T
*
popHead
(
)
{
if
(
!
mHead
)
{
MOZ_ASSERT
(
false
)
;
return
nullptr
;
}
T
*
head
=
mHead
;
mHead
=
head
-
>
mNext
;
if
(
!
mHead
)
{
mTail
=
nullptr
;
}
return
head
;
}
const
T
*
peek
(
)
{
return
mHead
;
}
private
:
T
*
mHead
;
T
*
mTail
;
}
;
typedef
ProfilerLinkedList
<
ProfilerMarker
>
ProfilerMarkerLinkedList
;
template
<
typename
T
>
class
ProfilerSignalSafeLinkedList
{
public
:
ProfilerSignalSafeLinkedList
(
)
:
mSignalLock
(
false
)
{
}
~
ProfilerSignalSafeLinkedList
(
)
{
if
(
mSignalLock
)
{
abort
(
)
;
}
while
(
mList
.
peek
(
)
)
{
delete
mList
.
popHead
(
)
;
}
}
void
insert
(
T
*
aElement
)
{
MOZ_ASSERT
(
aElement
)
;
mSignalLock
=
true
;
mList
.
insert
(
aElement
)
;
mSignalLock
=
false
;
}
ProfilerLinkedList
<
T
>
*
accessList
(
)
{
return
mSignalLock
?
nullptr
:
&
mList
;
}
private
:
ProfilerLinkedList
<
T
>
mList
;
Atomic
<
bool
>
mSignalLock
;
}
;
}
}
#
endif
