#
include
"
mozilla
/
BaseProfilerMarkers
.
h
"
#
include
"
mozilla
/
BaseProfilerUtils
.
h
"
#
include
<
limits
>
namespace
mozilla
{
namespace
base_profiler_markers_detail
{
using
DeserializerTagAtomic
=
unsigned
;
static
Atomic
<
DeserializerTagAtomic
MemoryOrdering
:
:
Relaxed
>
sDeserializerCount
{
0
}
;
static
constexpr
DeserializerTagAtomic
DeserializerMax
=
250
;
static_assert
(
DeserializerMax
<
=
std
:
:
numeric_limits
<
Streaming
:
:
DeserializerTag
>
:
:
max
(
)
"
The
maximum
number
of
deserializers
must
fit
in
the
DeserializerTag
type
"
)
;
static
Streaming
:
:
MarkerTypeFunctions
sMarkerTypeFunctions1Based
[
DeserializerMax
]
;
Streaming
:
:
DeserializerTag
Streaming
:
:
TagForMarkerTypeFunctions
(
Streaming
:
:
MarkerDataDeserializer
aDeserializer
Streaming
:
:
MarkerTypeNameFunction
aMarkerTypeNameFunction
Streaming
:
:
MarkerSchemaFunction
aMarkerSchemaFunction
)
{
MOZ_RELEASE_ASSERT
(
!
!
aDeserializer
)
;
MOZ_RELEASE_ASSERT
(
!
!
aMarkerTypeNameFunction
)
;
MOZ_RELEASE_ASSERT
(
!
!
aMarkerSchemaFunction
)
;
DeserializerTagAtomic
tag
=
+
+
sDeserializerCount
;
MOZ_RELEASE_ASSERT
(
tag
<
=
DeserializerMax
"
Too
many
deserializers
consider
increasing
DeserializerMax
.
"
"
Or
is
a
deserializer
stored
again
and
again
?
"
)
;
sMarkerTypeFunctions1Based
[
tag
-
1
]
=
{
aDeserializer
aMarkerTypeNameFunction
aMarkerSchemaFunction
}
;
return
static_cast
<
DeserializerTag
>
(
tag
)
;
}
Streaming
:
:
MarkerDataDeserializer
Streaming
:
:
DeserializerForTag
(
Streaming
:
:
DeserializerTag
aTag
)
{
MOZ_RELEASE_ASSERT
(
aTag
>
0
&
&
static_cast
<
DeserializerTagAtomic
>
(
aTag
)
<
=
static_cast
<
DeserializerTagAtomic
>
(
sDeserializerCount
)
"
Out
-
of
-
range
tag
value
"
)
;
return
sMarkerTypeFunctions1Based
[
aTag
-
1
]
.
mMarkerDataDeserializer
;
}
Span
<
const
Streaming
:
:
MarkerTypeFunctions
>
Streaming
:
:
MarkerTypeFunctionsArray
(
)
{
return
{
sMarkerTypeFunctions1Based
sDeserializerCount
}
;
}
static
int
sBufferForMainThreadAddMarkerRefCount
=
0
;
static
ProfileChunkedBuffer
*
sBufferForMainThreadAddMarker
=
nullptr
;
ProfileChunkedBuffer
*
GetClearedBufferForMainThreadAddMarker
(
)
{
if
(
!
mozilla
:
:
baseprofiler
:
:
profiler_is_main_thread
(
)
)
{
return
nullptr
;
}
if
(
sBufferForMainThreadAddMarker
)
{
sBufferForMainThreadAddMarker
-
>
Clear
(
)
;
}
return
sBufferForMainThreadAddMarker
;
}
MFBT_API
void
EnsureBufferForMainThreadAddMarker
(
)
{
if
(
!
mozilla
:
:
baseprofiler
:
:
profiler_is_main_thread
(
)
)
{
return
;
}
if
(
sBufferForMainThreadAddMarkerRefCount
+
+
=
=
0
)
{
MOZ_ASSERT
(
!
sBufferForMainThreadAddMarker
)
;
sBufferForMainThreadAddMarker
=
new
ProfileChunkedBuffer
(
ProfileChunkedBuffer
:
:
ThreadSafety
:
:
WithoutMutex
MakeUnique
<
ProfileBufferChunkManagerSingle
>
(
ProfileBufferChunkManager
:
:
scExpectedMaximumStackSize
)
)
;
}
}
MFBT_API
void
ReleaseBufferForMainThreadAddMarker
(
)
{
if
(
!
mozilla
:
:
baseprofiler
:
:
profiler_is_main_thread
(
)
)
{
return
;
}
MOZ_ASSERT
(
sBufferForMainThreadAddMarkerRefCount
>
0
)
;
MOZ_ASSERT
(
sBufferForMainThreadAddMarker
)
;
if
(
-
-
sBufferForMainThreadAddMarkerRefCount
=
=
0
)
{
delete
sBufferForMainThreadAddMarker
;
sBufferForMainThreadAddMarker
=
nullptr
;
}
}
}
void
MarkerSchema
:
:
Stream
(
JSONWriter
&
aWriter
const
Span
<
const
char
>
&
aName
)
&
&
{
if
(
mLocations
.
empty
(
)
)
{
return
;
}
aWriter
.
StartObjectElement
(
)
;
{
aWriter
.
StringProperty
(
"
name
"
aName
)
;
if
(
!
mChartLabel
.
empty
(
)
)
{
aWriter
.
StringProperty
(
"
chartLabel
"
mChartLabel
)
;
}
if
(
!
mTooltipLabel
.
empty
(
)
)
{
aWriter
.
StringProperty
(
"
tooltipLabel
"
mTooltipLabel
)
;
}
if
(
!
mTableLabel
.
empty
(
)
)
{
aWriter
.
StringProperty
(
"
tableLabel
"
mTableLabel
)
;
}
aWriter
.
StartArrayProperty
(
"
display
"
)
;
{
for
(
Location
location
:
mLocations
)
{
aWriter
.
StringElement
(
LocationToStringSpan
(
location
)
)
;
}
}
aWriter
.
EndArray
(
)
;
aWriter
.
StartArrayProperty
(
"
data
"
)
;
{
for
(
const
DataRow
&
row
:
mData
)
{
aWriter
.
StartObjectElement
(
)
;
{
row
.
match
(
[
&
aWriter
]
(
const
DynamicData
&
aData
)
{
aWriter
.
StringProperty
(
"
key
"
aData
.
mKey
)
;
if
(
aData
.
mLabel
)
{
aWriter
.
StringProperty
(
"
label
"
*
aData
.
mLabel
)
;
}
aWriter
.
StringProperty
(
"
format
"
FormatToStringSpan
(
aData
.
mFormat
)
)
;
if
(
aData
.
mSearchable
)
{
aWriter
.
BoolProperty
(
"
searchable
"
*
aData
.
mSearchable
=
=
Searchable
:
:
Searchable
)
;
}
}
[
&
aWriter
]
(
const
StaticData
&
aStaticData
)
{
aWriter
.
StringProperty
(
"
label
"
aStaticData
.
mLabel
)
;
aWriter
.
StringProperty
(
"
value
"
aStaticData
.
mValue
)
;
}
)
;
}
aWriter
.
EndObject
(
)
;
}
}
aWriter
.
EndArray
(
)
;
}
aWriter
.
EndObject
(
)
;
}
Span
<
const
char
>
MarkerSchema
:
:
LocationToStringSpan
(
MarkerSchema
:
:
Location
aLocation
)
{
switch
(
aLocation
)
{
case
Location
:
:
MarkerChart
:
return
mozilla
:
:
MakeStringSpan
(
"
marker
-
chart
"
)
;
case
Location
:
:
MarkerTable
:
return
mozilla
:
:
MakeStringSpan
(
"
marker
-
table
"
)
;
case
Location
:
:
TimelineOverview
:
return
mozilla
:
:
MakeStringSpan
(
"
timeline
-
overview
"
)
;
case
Location
:
:
TimelineMemory
:
return
mozilla
:
:
MakeStringSpan
(
"
timeline
-
memory
"
)
;
case
Location
:
:
TimelineIPC
:
return
mozilla
:
:
MakeStringSpan
(
"
timeline
-
ipc
"
)
;
case
Location
:
:
TimelineFileIO
:
return
mozilla
:
:
MakeStringSpan
(
"
timeline
-
fileio
"
)
;
case
Location
:
:
StackChart
:
return
mozilla
:
:
MakeStringSpan
(
"
stack
-
chart
"
)
;
default
:
MOZ_CRASH
(
"
Unexpected
Location
enum
"
)
;
return
{
}
;
}
}
Span
<
const
char
>
MarkerSchema
:
:
FormatToStringSpan
(
MarkerSchema
:
:
Format
aFormat
)
{
switch
(
aFormat
)
{
case
Format
:
:
Url
:
return
mozilla
:
:
MakeStringSpan
(
"
url
"
)
;
case
Format
:
:
FilePath
:
return
mozilla
:
:
MakeStringSpan
(
"
file
-
path
"
)
;
case
Format
:
:
String
:
return
mozilla
:
:
MakeStringSpan
(
"
string
"
)
;
case
Format
:
:
Duration
:
return
mozilla
:
:
MakeStringSpan
(
"
duration
"
)
;
case
Format
:
:
Time
:
return
mozilla
:
:
MakeStringSpan
(
"
time
"
)
;
case
Format
:
:
Seconds
:
return
mozilla
:
:
MakeStringSpan
(
"
seconds
"
)
;
case
Format
:
:
Milliseconds
:
return
mozilla
:
:
MakeStringSpan
(
"
milliseconds
"
)
;
case
Format
:
:
Microseconds
:
return
mozilla
:
:
MakeStringSpan
(
"
microseconds
"
)
;
case
Format
:
:
Nanoseconds
:
return
mozilla
:
:
MakeStringSpan
(
"
nanoseconds
"
)
;
case
Format
:
:
Bytes
:
return
mozilla
:
:
MakeStringSpan
(
"
bytes
"
)
;
case
Format
:
:
Percentage
:
return
mozilla
:
:
MakeStringSpan
(
"
percentage
"
)
;
case
Format
:
:
Integer
:
return
mozilla
:
:
MakeStringSpan
(
"
integer
"
)
;
case
Format
:
:
Decimal
:
return
mozilla
:
:
MakeStringSpan
(
"
decimal
"
)
;
default
:
MOZ_CRASH
(
"
Unexpected
Format
enum
"
)
;
return
{
}
;
}
}
}
namespace
mozilla
:
:
baseprofiler
{
template
MFBT_API
ProfileBufferBlockIndex
AddMarker
(
const
ProfilerString8View
&
const
MarkerCategory
&
MarkerOptions
&
&
markers
:
:
TextMarker
const
std
:
:
string
&
)
;
template
MFBT_API
ProfileBufferBlockIndex
AddMarkerToBuffer
(
ProfileChunkedBuffer
&
const
ProfilerString8View
&
const
MarkerCategory
&
MarkerOptions
&
&
markers
:
:
NoPayload
)
;
template
MFBT_API
ProfileBufferBlockIndex
AddMarkerToBuffer
(
ProfileChunkedBuffer
&
const
ProfilerString8View
&
const
MarkerCategory
&
MarkerOptions
&
&
markers
:
:
TextMarker
const
std
:
:
string
&
)
;
}
