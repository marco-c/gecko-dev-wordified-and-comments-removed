#
include
"
UntrustedDllsHandler
.
h
"
#
include
<
windows
.
h
>
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
ThreadLocal
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsWindowsHelpers
.
h
"
namespace
mozilla
{
namespace
glue
{
static
UniquePtr
<
wchar_t
[
]
>
CopyString
(
const
UniquePtr
<
wchar_t
[
]
>
&
aOther
)
{
if
(
!
aOther
)
{
return
nullptr
;
}
size_t
chars
=
wcslen
(
aOther
.
get
(
)
)
;
auto
ret
=
MakeUnique
<
wchar_t
[
]
>
(
chars
+
1
)
;
if
(
wcsncpy_s
(
ret
.
get
(
)
chars
+
1
aOther
.
get
(
)
chars
)
)
{
return
nullptr
;
}
return
ret
;
}
static
UniquePtr
<
wchar_t
[
]
>
CopyString
(
PCUNICODE_STRING
aOther
)
{
if
(
!
aOther
|
|
!
aOther
-
>
Buffer
)
{
return
nullptr
;
}
size_t
chars
=
aOther
-
>
Length
/
sizeof
(
wchar_t
)
;
auto
ret
=
MakeUnique
<
wchar_t
[
]
>
(
chars
+
1
)
;
if
(
wcsncpy_s
(
ret
.
get
(
)
chars
+
1
aOther
-
>
Buffer
chars
)
)
{
return
nullptr
;
}
return
ret
;
}
static
UniquePtr
<
wchar_t
[
]
>
GetModuleFullPath
(
uintptr_t
aModuleBase
)
{
size_t
allocated
=
MAX_PATH
;
auto
ret
=
MakeUnique
<
wchar_t
[
]
>
(
allocated
)
;
size_t
len
;
while
(
true
)
{
len
=
(
size_t
)
:
:
GetModuleFileNameW
(
(
HMODULE
)
aModuleBase
ret
.
get
(
)
allocated
)
;
if
(
!
len
)
{
return
nullptr
;
}
if
(
len
=
=
allocated
&
&
:
:
GetLastError
(
)
=
=
ERROR_INSUFFICIENT_BUFFER
)
{
allocated
*
=
2
;
ret
=
MakeUnique
<
wchar_t
[
]
>
(
allocated
)
;
continue
;
}
break
;
}
return
CopyString
(
ret
)
;
}
class
TLSData
{
public
:
Vector
<
ModuleLoadEvent
:
:
ModuleInfo
0
InfallibleAllocPolicy
>
mModulesLoaded
;
int
mCallDepth
=
0
;
}
;
static
MOZ_THREAD_LOCAL
(
TLSData
*
)
sTlsData
;
class
UntrustedDllsHandlerImpl
{
Atomic
<
int32_t
>
mRefCnt
;
static
Atomic
<
bool
>
sInstanceHasBeenSet
;
static
StaticRefPtr
<
UntrustedDllsHandlerImpl
>
sInstance
;
Vector
<
ModuleLoadEvent
0
InfallibleAllocPolicy
>
mModuleLoadEvents
;
Vector
<
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
>
mModuleHistory
;
CRITICAL_SECTION
mDataLock
;
UntrustedDllsHandlerImpl
(
)
{
InitializeCriticalSection
(
&
mDataLock
)
;
}
~
UntrustedDllsHandlerImpl
(
)
{
{
AutoCriticalSection
lock
(
&
mDataLock
)
;
}
DeleteCriticalSection
(
&
mDataLock
)
;
}
public
:
static
RefPtr
<
UntrustedDllsHandlerImpl
>
GetInstance
(
)
{
if
(
sInstanceHasBeenSet
)
{
return
sInstance
;
}
sInstance
=
new
UntrustedDllsHandlerImpl
(
)
;
sInstanceHasBeenSet
=
true
;
return
sInstance
;
}
static
void
Shutdown
(
)
{
sInstance
=
nullptr
;
}
int32_t
AddRef
(
)
{
return
+
+
mRefCnt
;
}
int32_t
Release
(
)
{
int32_t
ret
=
-
-
mRefCnt
;
if
(
!
ret
)
{
delete
this
;
}
return
ret
;
}
void
OnAfterTopLevelModuleLoad
(
)
{
RefPtr
<
UntrustedDllsHandlerImpl
>
refHolder
(
this
)
;
if
(
!
refHolder
)
{
return
;
}
ModuleLoadEvent
thisEvent
;
TLSData
*
tlsData
=
sTlsData
.
get
(
)
;
if
(
!
tlsData
)
{
return
;
}
{
AutoCriticalSection
lock
(
&
mDataLock
)
;
for
(
auto
&
module
:
tlsData
-
>
mModulesLoaded
)
{
if
(
module
.
mFullPath
&
&
wcslen
(
module
.
mFullPath
.
get
(
)
)
)
{
bool
foundInHistory
=
false
;
for
(
auto
&
h
:
mModuleHistory
)
{
if
(
!
wcsicmp
(
h
.
get
(
)
module
.
mFullPath
.
get
(
)
)
)
{
foundInHistory
=
true
;
break
;
}
}
if
(
foundInHistory
)
{
continue
;
}
Unused
<
<
mModuleHistory
.
append
(
CopyString
(
module
.
mFullPath
)
)
;
}
Unused
<
<
thisEvent
.
mModules
.
emplaceBack
(
std
:
:
move
(
module
)
)
;
}
}
tlsData
-
>
mModulesLoaded
.
clear
(
)
;
if
(
thisEvent
.
mModules
.
empty
(
)
)
{
return
;
}
thisEvent
.
mThreadID
=
GetCurrentThreadId
(
)
;
TimeStamp
processCreation
=
TimeStamp
:
:
ProcessCreation
(
)
;
TimeDuration
td
=
TimeStamp
:
:
Now
(
)
-
processCreation
;
thisEvent
.
mProcessUptimeMS
=
(
uint64_t
)
td
.
ToMilliseconds
(
)
;
static
const
uint32_t
kMaxFrames
=
500
;
auto
frames
=
MakeUnique
<
void
*
[
]
>
(
kMaxFrames
)
;
USHORT
frameCount
=
CaptureStackBackTrace
(
1
kMaxFrames
frames
.
get
(
)
nullptr
)
;
if
(
thisEvent
.
mStack
.
reserve
(
frameCount
)
)
{
for
(
size_t
i
=
0
;
i
<
frameCount
;
+
+
i
)
{
Unused
<
<
thisEvent
.
mStack
.
append
(
(
uintptr_t
)
frames
[
i
]
)
;
}
}
AutoCriticalSection
lock
(
&
mDataLock
)
;
Unused
<
<
mModuleLoadEvents
.
emplaceBack
(
std
:
:
move
(
thisEvent
)
)
;
}
bool
TakePendingEvents
(
Vector
<
ModuleLoadEvent
0
InfallibleAllocPolicy
>
&
aOut
)
{
RefPtr
<
UntrustedDllsHandlerImpl
>
refHolder
(
this
)
;
if
(
!
refHolder
)
{
return
false
;
}
AutoCriticalSection
lock
(
&
mDataLock
)
;
mModuleLoadEvents
.
swap
(
aOut
)
;
return
!
aOut
.
empty
(
)
;
}
}
;
Atomic
<
bool
>
UntrustedDllsHandlerImpl
:
:
sInstanceHasBeenSet
;
StaticRefPtr
<
UntrustedDllsHandlerImpl
>
UntrustedDllsHandlerImpl
:
:
sInstance
;
void
UntrustedDllsHandler
:
:
Init
(
)
{
Unused
<
<
sTlsData
.
init
(
)
;
}
#
ifdef
DEBUG
void
UntrustedDllsHandler
:
:
Shutdown
(
)
{
UntrustedDllsHandlerImpl
:
:
Shutdown
(
)
;
}
#
endif
void
UntrustedDllsHandler
:
:
EnterLoaderCall
(
)
{
if
(
!
sTlsData
.
initialized
(
)
)
{
return
;
}
if
(
!
sTlsData
.
get
(
)
)
{
sTlsData
.
set
(
new
TLSData
(
)
)
;
}
sTlsData
.
get
(
)
-
>
mCallDepth
+
+
;
}
void
UntrustedDllsHandler
:
:
ExitLoaderCall
(
)
{
if
(
!
sTlsData
.
initialized
(
)
)
{
return
;
}
if
(
!
-
-
(
sTlsData
.
get
(
)
-
>
mCallDepth
)
)
{
delete
sTlsData
.
get
(
)
;
sTlsData
.
set
(
nullptr
)
;
}
}
void
UntrustedDllsHandler
:
:
OnAfterModuleLoad
(
uintptr_t
aBaseAddr
PUNICODE_STRING
aLdrModuleName
double
aLoadDurationMS
)
{
RefPtr
<
UntrustedDllsHandlerImpl
>
p
(
UntrustedDllsHandlerImpl
:
:
GetInstance
(
)
)
;
if
(
!
p
)
{
return
;
}
if
(
!
sTlsData
.
initialized
(
)
)
{
return
;
}
TLSData
*
tlsData
=
sTlsData
.
get
(
)
;
if
(
!
tlsData
)
{
return
;
}
ModuleLoadEvent
:
:
ModuleInfo
moduleInfo
;
moduleInfo
.
mLdrName
=
CopyString
(
aLdrModuleName
)
;
moduleInfo
.
mBase
=
aBaseAddr
;
moduleInfo
.
mFullPath
=
GetModuleFullPath
(
aBaseAddr
)
;
moduleInfo
.
mLoadDurationMS
=
aLoadDurationMS
;
Unused
<
<
tlsData
-
>
mModulesLoaded
.
emplaceBack
(
std
:
:
move
(
moduleInfo
)
)
;
if
(
tlsData
-
>
mCallDepth
>
1
)
{
return
;
}
p
-
>
OnAfterTopLevelModuleLoad
(
)
;
}
bool
UntrustedDllsHandler
:
:
TakePendingEvents
(
Vector
<
ModuleLoadEvent
0
InfallibleAllocPolicy
>
&
aOut
)
{
RefPtr
<
UntrustedDllsHandlerImpl
>
p
(
UntrustedDllsHandlerImpl
:
:
GetInstance
(
)
)
;
if
(
!
p
)
{
return
false
;
}
return
p
-
>
TakePendingEvents
(
aOut
)
;
}
}
}
