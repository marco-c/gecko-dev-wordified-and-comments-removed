#
ifdef
MOZ_MEMORY
#
define
MOZ_MEMORY_IMPL
#
include
"
mozmemory_wrap
.
h
"
#
define
MALLOC_FUNCS
MALLOC_FUNCS_MALLOC
#
define
MALLOC_DECL
(
name
return_type
.
.
.
)
\
MOZ_MEMORY_API
return_type
name
#
#
_impl
(
__VA_ARGS__
)
;
#
include
"
malloc_decls
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
endif
#
include
<
windows
.
h
>
#
include
<
winternl
.
h
>
#
pragma
warning
(
push
)
#
pragma
warning
(
disable
:
4275
4530
)
/
/
See
msvc
-
stl
-
wrapper
.
template
.
h
#
include
<
map
>
#
pragma
warning
(
pop
)
#
include
"
Authenticode
.
h
"
#
include
"
CrashAnnotations
.
h
"
#
include
"
MozglueUtils
.
h
"
#
include
"
UntrustedDllsHandler
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsWindowsDllInterceptor
.
h
"
#
include
"
mozilla
/
CmdLineAndEnvUtils
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
StackWalk_windows
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
mozilla
/
WindowsVersion
.
h
"
#
include
"
nsWindowsHelpers
.
h
"
#
include
"
WindowsDllBlocklist
.
h
"
#
include
"
mozilla
/
AutoProfilerLabel
.
h
"
#
include
"
mozilla
/
glue
/
Debug
.
h
"
#
include
"
mozilla
/
glue
/
WindowsDllServices
.
h
"
using
namespace
mozilla
;
using
CrashReporter
:
:
Annotation
;
using
CrashReporter
:
:
AnnotationToString
;
static
glue
:
:
Win32SRWLock
gDllServicesLock
;
static
glue
:
:
detail
:
:
DllServicesBase
*
gDllServices
;
#
define
DLL_BLOCKLIST_ENTRY
(
name
.
.
.
)
{
name
__VA_ARGS__
}
#
define
DLL_BLOCKLIST_STRING_TYPE
const
char
*
#
include
"
mozilla
/
WindowsDllBlocklistDefs
.
h
"
#
undef
DEBUG_very_verbose
static
uint32_t
sInitFlags
;
static
bool
sBlocklistInitAttempted
;
static
bool
sBlocklistInitFailed
;
static
bool
sUser32BeforeBlocklist
;
inline
static
bool
IsUntrustedDllsHandlerEnabled
(
)
{
#
ifdef
NIGHTLY_BUILD
return
!
(
sInitFlags
&
eDllBlocklistInitFlagIsChildProcess
)
;
#
else
return
false
;
#
endif
}
typedef
MOZ_NORETURN_PTR
void
(
__fastcall
*
BaseThreadInitThunk_func
)
(
BOOL
aIsInitialThread
void
*
aStartAddress
void
*
aThreadParam
)
;
static
WindowsDllInterceptor
:
:
FuncHookType
<
BaseThreadInitThunk_func
>
stub_BaseThreadInitThunk
;
typedef
NTSTATUS
(
NTAPI
*
LdrLoadDll_func
)
(
PWCHAR
filePath
PULONG
flags
PUNICODE_STRING
moduleFileName
PHANDLE
handle
)
;
static
WindowsDllInterceptor
:
:
FuncHookType
<
LdrLoadDll_func
>
stub_LdrLoadDll
;
#
ifdef
_M_AMD64
typedef
decltype
(
RtlInstallFunctionTableCallback
)
*
RtlInstallFunctionTableCallback_func
;
static
WindowsDllInterceptor
:
:
FuncHookType
<
RtlInstallFunctionTableCallback_func
>
stub_RtlInstallFunctionTableCallback
;
extern
uint8_t
*
sMsMpegJitCodeRegionStart
;
extern
size_t
sMsMpegJitCodeRegionSize
;
BOOLEAN
WINAPI
patched_RtlInstallFunctionTableCallback
(
DWORD64
TableIdentifier
DWORD64
BaseAddress
DWORD
Length
PGET_RUNTIME_FUNCTION_CALLBACK
Callback
PVOID
Context
PCWSTR
OutOfProcessCallbackDll
)
{
HMODULE
callbackModule
=
nullptr
;
DWORD
moduleFlags
=
GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS
|
GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT
;
AutoSuppressStackWalking
suppress
;
if
(
GetModuleHandleExW
(
moduleFlags
(
LPWSTR
)
Callback
&
callbackModule
)
&
&
GetModuleHandleW
(
L
"
msmpeg2vdec
.
dll
"
)
=
=
callbackModule
)
{
sMsMpegJitCodeRegionStart
=
(
uint8_t
*
)
BaseAddress
;
sMsMpegJitCodeRegionSize
=
Length
;
}
return
stub_RtlInstallFunctionTableCallback
(
TableIdentifier
BaseAddress
Length
Callback
Context
OutOfProcessCallbackDll
)
;
}
#
endif
template
<
class
T
>
struct
RVAMap
{
RVAMap
(
HANDLE
map
DWORD
offset
)
{
SYSTEM_INFO
info
;
GetSystemInfo
(
&
info
)
;
DWORD
alignedOffset
=
(
offset
/
info
.
dwAllocationGranularity
)
*
info
.
dwAllocationGranularity
;
MOZ_ASSERT
(
offset
-
alignedOffset
<
info
.
dwAllocationGranularity
"
Wtf
"
)
;
mRealView
=
:
:
MapViewOfFile
(
map
FILE_MAP_READ
0
alignedOffset
sizeof
(
T
)
+
(
offset
-
alignedOffset
)
)
;
mMappedView
=
mRealView
?
reinterpret_cast
<
T
*
>
(
(
char
*
)
mRealView
+
(
offset
-
alignedOffset
)
)
:
nullptr
;
}
~
RVAMap
(
)
{
if
(
mRealView
)
{
:
:
UnmapViewOfFile
(
mRealView
)
;
}
}
operator
const
T
*
(
)
const
{
return
mMappedView
;
}
const
T
*
operator
-
>
(
)
const
{
return
mMappedView
;
}
private
:
const
T
*
mMappedView
;
void
*
mRealView
;
}
;
static
DWORD
GetTimestamp
(
const
wchar_t
*
path
)
{
DWORD
timestamp
=
0
;
HANDLE
file
=
:
:
CreateFileW
(
path
GENERIC_READ
FILE_SHARE_READ
nullptr
OPEN_EXISTING
FILE_ATTRIBUTE_NORMAL
nullptr
)
;
if
(
file
!
=
INVALID_HANDLE_VALUE
)
{
HANDLE
map
=
:
:
CreateFileMappingW
(
file
nullptr
PAGE_READONLY
0
0
nullptr
)
;
if
(
map
)
{
RVAMap
<
IMAGE_DOS_HEADER
>
peHeader
(
map
0
)
;
if
(
peHeader
)
{
RVAMap
<
IMAGE_NT_HEADERS
>
ntHeader
(
map
peHeader
-
>
e_lfanew
)
;
if
(
ntHeader
)
{
timestamp
=
ntHeader
-
>
FileHeader
.
TimeDateStamp
;
}
}
:
:
CloseHandle
(
map
)
;
}
:
:
CloseHandle
(
file
)
;
}
return
timestamp
;
}
static
CRITICAL_SECTION
sLock
;
class
ReentrancySentinel
{
public
:
explicit
ReentrancySentinel
(
const
char
*
dllName
)
{
DWORD
currentThreadId
=
GetCurrentThreadId
(
)
;
AutoCriticalSection
lock
(
&
sLock
)
;
mPreviousDllName
=
(
*
sThreadMap
)
[
currentThreadId
]
;
mReentered
=
mPreviousDllName
&
&
!
stricmp
(
mPreviousDllName
dllName
)
;
(
*
sThreadMap
)
[
currentThreadId
]
=
dllName
;
}
~
ReentrancySentinel
(
)
{
DWORD
currentThreadId
=
GetCurrentThreadId
(
)
;
AutoCriticalSection
lock
(
&
sLock
)
;
(
*
sThreadMap
)
[
currentThreadId
]
=
mPreviousDllName
;
}
bool
BailOut
(
)
const
{
return
mReentered
;
}
;
static
void
InitializeStatics
(
)
{
InitializeCriticalSection
(
&
sLock
)
;
sThreadMap
=
new
std
:
:
map
<
DWORD
const
char
*
>
;
}
private
:
static
std
:
:
map
<
DWORD
const
char
*
>
*
sThreadMap
;
const
char
*
mPreviousDllName
;
bool
mReentered
;
}
;
std
:
:
map
<
DWORD
const
char
*
>
*
ReentrancySentinel
:
:
sThreadMap
;
class
DllBlockSet
{
public
:
static
void
Add
(
const
char
*
name
unsigned
long
long
version
)
;
static
void
Write
(
HANDLE
file
)
;
private
:
DllBlockSet
(
const
char
*
name
unsigned
long
long
version
)
:
mName
(
name
)
mVersion
(
version
)
mNext
(
nullptr
)
{
}
const
char
*
mName
;
unsigned
long
long
mVersion
;
DllBlockSet
*
mNext
;
static
DllBlockSet
*
gFirst
;
}
;
DllBlockSet
*
DllBlockSet
:
:
gFirst
;
void
DllBlockSet
:
:
Add
(
const
char
*
name
unsigned
long
long
version
)
{
AutoCriticalSection
lock
(
&
sLock
)
;
for
(
DllBlockSet
*
b
=
gFirst
;
b
;
b
=
b
-
>
mNext
)
{
if
(
0
=
=
strcmp
(
b
-
>
mName
name
)
&
&
b
-
>
mVersion
=
=
version
)
{
return
;
}
}
DllBlockSet
*
n
=
new
DllBlockSet
(
name
version
)
;
n
-
>
mNext
=
gFirst
;
gFirst
=
n
;
}
void
DllBlockSet
:
:
Write
(
HANDLE
file
)
{
:
:
EnterCriticalSection
(
&
sLock
)
;
MOZ_SEH_TRY
{
DWORD
nBytes
;
for
(
DllBlockSet
*
b
=
gFirst
;
b
;
b
=
b
-
>
mNext
)
{
WriteFile
(
file
b
-
>
mName
strlen
(
b
-
>
mName
)
&
nBytes
nullptr
)
;
if
(
b
-
>
mVersion
!
=
ALL_VERSIONS
)
{
WriteFile
(
file
"
"
1
&
nBytes
nullptr
)
;
uint16_t
parts
[
4
]
;
parts
[
0
]
=
b
-
>
mVersion
>
>
48
;
parts
[
1
]
=
(
b
-
>
mVersion
>
>
32
)
&
0xFFFF
;
parts
[
2
]
=
(
b
-
>
mVersion
>
>
16
)
&
0xFFFF
;
parts
[
3
]
=
b
-
>
mVersion
&
0xFFFF
;
for
(
int
p
=
0
;
p
<
4
;
+
+
p
)
{
char
buf
[
32
]
;
ltoa
(
parts
[
p
]
buf
10
)
;
WriteFile
(
file
buf
strlen
(
buf
)
&
nBytes
nullptr
)
;
if
(
p
!
=
3
)
{
WriteFile
(
file
"
.
"
1
&
nBytes
nullptr
)
;
}
}
}
WriteFile
(
file
"
;
"
1
&
nBytes
nullptr
)
;
}
}
MOZ_SEH_EXCEPT
(
EXCEPTION_EXECUTE_HANDLER
)
{
}
:
:
LeaveCriticalSection
(
&
sLock
)
;
}
static
UniquePtr
<
wchar_t
[
]
>
getFullPath
(
PWCHAR
filePath
wchar_t
*
fname
)
{
PWCHAR
sanitizedFilePath
=
nullptr
;
if
(
(
uintptr_t
(
filePath
)
>
=
65536
)
&
&
(
(
uintptr_t
(
filePath
)
&
1
)
=
=
0
)
)
{
sanitizedFilePath
=
filePath
;
}
DWORD
pathlen
=
SearchPathW
(
sanitizedFilePath
fname
L
"
.
dll
"
0
nullptr
nullptr
)
;
if
(
pathlen
=
=
0
)
{
return
nullptr
;
}
auto
full_fname
=
MakeUnique
<
wchar_t
[
]
>
(
pathlen
+
1
)
;
if
(
!
full_fname
)
{
return
nullptr
;
}
SearchPathW
(
sanitizedFilePath
fname
L
"
.
dll
"
pathlen
+
1
full_fname
.
get
(
)
nullptr
)
;
return
full_fname
;
}
static
wchar_t
*
lastslash
(
wchar_t
*
s
int
len
)
{
for
(
wchar_t
*
c
=
s
+
len
-
1
;
c
>
=
s
;
-
-
c
)
{
if
(
*
c
=
=
L
'
\
\
'
|
|
*
c
=
=
L
'
/
'
)
{
return
c
;
}
}
return
nullptr
;
}
#
ifdef
ENABLE_TESTS
DllLoadHookType
gDllLoadHook
=
nullptr
;
void
DllBlocklist_SetDllLoadHook
(
DllLoadHookType
aHook
)
{
gDllLoadHook
=
aHook
;
}
void
CallDllLoadHook
(
bool
aDllLoaded
NTSTATUS
aStatus
HANDLE
aDllBase
PUNICODE_STRING
aDllName
)
{
if
(
gDllLoadHook
)
{
gDllLoadHook
(
aDllLoaded
aStatus
aDllBase
aDllName
)
;
}
}
CreateThreadHookType
gCreateThreadHook
=
nullptr
;
void
DllBlocklist_SetCreateThreadHook
(
CreateThreadHookType
aHook
)
{
gCreateThreadHook
=
aHook
;
}
void
CallCreateThreadHook
(
bool
aWasAllowed
void
*
aStartAddress
)
{
if
(
gCreateThreadHook
)
{
gCreateThreadHook
(
aWasAllowed
aStartAddress
)
;
}
}
const
char
*
DllBlocklist_TestBlocklistIntegrity
(
)
{
mozilla
:
:
Vector
<
DLL_BLOCKLIST_STRING_TYPE
>
dupes
;
DECLARE_POINTER_TO_FIRST_DLL_BLOCKLIST_ENTRY
(
pFirst
)
;
DECLARE_POINTER_TO_LAST_DLL_BLOCKLIST_ENTRY
(
pLast
)
;
if
(
pLast
-
>
name
|
|
pLast
-
>
maxVersion
|
|
pLast
-
>
flags
)
{
return
"
The
last
dll
blocklist
entry
must
be
all
-
null
.
"
;
}
for
(
size_t
i
=
0
;
i
<
mozilla
:
:
ArrayLength
(
gWindowsDllBlocklist
)
-
1
;
+
+
i
)
{
auto
pEntry
=
pFirst
+
i
;
if
(
!
pEntry
-
>
name
)
{
return
"
A
dll
blocklist
entry
contains
a
null
name
.
"
;
}
if
(
strlen
(
pEntry
-
>
name
)
<
=
2
)
{
return
"
Dll
blocklist
entry
names
must
be
longer
than
2
characters
.
"
;
}
for
(
auto
pch
=
pEntry
-
>
name
;
*
pch
!
=
0
;
+
+
pch
)
{
if
(
*
pch
>
=
'
A
'
&
&
*
pch
<
=
'
Z
'
)
{
return
"
Dll
blocklist
entry
names
cannot
contain
uppercase
characters
.
"
;
}
}
for
(
auto
dupe
:
dupes
)
{
if
(
!
stricmp
(
dupe
pEntry
-
>
name
)
)
{
return
"
At
least
one
duplicate
dll
blocklist
entry
was
found
.
"
;
}
}
if
(
!
dupes
.
append
(
pEntry
-
>
name
)
)
{
return
"
Failed
to
append
to
duplicates
list
;
test
unable
to
continue
.
"
;
}
}
return
nullptr
;
}
#
else
#
define
CallDllLoadHook
(
.
.
.
)
#
define
CallCreateThreadHook
(
.
.
.
)
#
endif
static
NTSTATUS
NTAPI
patched_LdrLoadDll
(
PWCHAR
filePath
PULONG
flags
PUNICODE_STRING
moduleFileName
PHANDLE
handle
)
{
if
(
IsUntrustedDllsHandlerEnabled
(
)
)
{
glue
:
:
UntrustedDllsHandler
:
:
EnterLoaderCall
(
)
;
}
auto
exitLoaderCallScopeExit
=
MakeScopeExit
(
[
]
(
)
{
if
(
IsUntrustedDllsHandlerEnabled
(
)
)
{
glue
:
:
UntrustedDllsHandler
:
:
ExitLoaderCall
(
)
;
}
}
)
;
#
define
DLLNAME_MAX
128
char
dllName
[
DLLNAME_MAX
+
1
]
;
wchar_t
*
dll_part
;
char
*
dot
;
int
len
=
moduleFileName
-
>
Length
/
2
;
wchar_t
*
fname
=
moduleFileName
-
>
Buffer
;
UniquePtr
<
wchar_t
[
]
>
full_fname
;
if
(
moduleFileName
-
>
MaximumLength
<
moduleFileName
-
>
Length
+
2
|
|
fname
[
len
]
!
=
0
)
{
#
ifdef
DEBUG
printf_stderr
(
"
LdrLoadDll
:
non
-
null
terminated
string
found
!
\
n
"
)
;
#
endif
goto
continue_loading
;
}
dll_part
=
lastslash
(
fname
len
)
;
if
(
dll_part
)
{
dll_part
=
dll_part
+
1
;
len
-
=
dll_part
-
fname
;
}
else
{
dll_part
=
fname
;
}
#
ifdef
DEBUG_very_verbose
printf_stderr
(
"
LdrLoadDll
:
dll_part
'
%
S
'
%
d
\
n
"
dll_part
len
)
;
#
endif
if
(
len
>
DLLNAME_MAX
)
{
#
ifdef
DEBUG
printf_stderr
(
"
LdrLoadDll
:
len
too
long
!
%
d
\
n
"
len
)
;
#
endif
goto
continue_loading
;
}
for
(
int
i
=
0
;
i
<
len
;
i
+
+
)
{
wchar_t
c
=
dll_part
[
i
]
;
if
(
c
>
0x7f
)
{
goto
continue_loading
;
}
if
(
c
>
=
'
A
'
&
&
c
<
=
'
Z
'
)
c
+
=
'
a
'
-
'
A
'
;
dllName
[
i
]
=
(
char
)
c
;
}
dllName
[
len
]
=
0
;
#
ifdef
DEBUG_very_verbose
printf_stderr
(
"
LdrLoadDll
:
dll
name
'
%
s
'
\
n
"
dllName
)
;
#
endif
if
(
!
(
sInitFlags
&
eDllBlocklistInitFlagWasBootstrapped
)
)
{
dot
=
strchr
(
dllName
'
.
'
)
;
if
(
dot
&
&
(
strchr
(
dot
+
1
'
.
'
)
=
=
dot
+
13
)
)
{
char
*
end
=
nullptr
;
_strtoui64
(
dot
+
1
&
end
16
)
;
if
(
end
=
=
dot
+
13
)
{
CallDllLoadHook
(
false
STATUS_DLL_NOT_FOUND
0
moduleFileName
)
;
return
STATUS_DLL_NOT_FOUND
;
}
}
if
(
dot
&
&
(
(
dot
-
dllName
)
>
=
16
)
)
{
char
*
current
=
dllName
;
while
(
current
<
dot
&
&
isxdigit
(
*
current
)
)
{
current
+
+
;
}
if
(
current
=
=
dot
)
{
CallDllLoadHook
(
false
STATUS_DLL_NOT_FOUND
0
moduleFileName
)
;
return
STATUS_DLL_NOT_FOUND
;
}
}
DECLARE_POINTER_TO_FIRST_DLL_BLOCKLIST_ENTRY
(
info
)
;
while
(
info
-
>
name
)
{
if
(
strcmp
(
info
-
>
name
dllName
)
=
=
0
)
break
;
info
+
+
;
}
if
(
info
-
>
name
)
{
bool
load_ok
=
false
;
#
ifdef
DEBUG_very_verbose
printf_stderr
(
"
LdrLoadDll
:
info
-
>
name
:
'
%
s
'
\
n
"
info
-
>
name
)
;
#
endif
if
(
(
info
-
>
flags
&
DllBlockInfo
:
:
BLOCK_WIN8PLUS_ONLY
)
&
&
!
IsWin8OrLater
(
)
)
{
goto
continue_loading
;
}
if
(
(
info
-
>
flags
&
DllBlockInfo
:
:
BLOCK_WIN8_ONLY
)
&
&
(
!
IsWin8OrLater
(
)
|
|
IsWin8Point1OrLater
(
)
)
)
{
goto
continue_loading
;
}
if
(
(
info
-
>
flags
&
DllBlockInfo
:
:
CHILD_PROCESSES_ONLY
)
&
&
!
(
sInitFlags
&
eDllBlocklistInitFlagIsChildProcess
)
)
{
goto
continue_loading
;
}
unsigned
long
long
fVersion
=
ALL_VERSIONS
;
if
(
info
-
>
maxVersion
!
=
ALL_VERSIONS
)
{
ReentrancySentinel
sentinel
(
dllName
)
;
if
(
sentinel
.
BailOut
(
)
)
{
goto
continue_loading
;
}
full_fname
=
getFullPath
(
filePath
fname
)
;
if
(
!
full_fname
)
{
printf_stderr
(
"
LdrLoadDll
:
Blocking
load
of
'
%
s
'
(
SearchPathW
didn
'
t
find
"
"
it
?
)
\
n
"
dllName
)
;
CallDllLoadHook
(
false
STATUS_DLL_NOT_FOUND
0
moduleFileName
)
;
return
STATUS_DLL_NOT_FOUND
;
}
if
(
info
-
>
flags
&
DllBlockInfo
:
:
USE_TIMESTAMP
)
{
fVersion
=
GetTimestamp
(
full_fname
.
get
(
)
)
;
if
(
fVersion
>
info
-
>
maxVersion
)
{
load_ok
=
true
;
}
}
else
{
DWORD
zero
;
DWORD
infoSize
=
GetFileVersionInfoSizeW
(
full_fname
.
get
(
)
&
zero
)
;
if
(
infoSize
!
=
0
)
{
auto
infoData
=
MakeUnique
<
unsigned
char
[
]
>
(
infoSize
)
;
VS_FIXEDFILEINFO
*
vInfo
;
UINT
vInfoLen
;
if
(
GetFileVersionInfoW
(
full_fname
.
get
(
)
0
infoSize
infoData
.
get
(
)
)
&
&
VerQueryValueW
(
infoData
.
get
(
)
L
"
\
\
"
(
LPVOID
*
)
&
vInfo
&
vInfoLen
)
)
{
fVersion
=
(
(
unsigned
long
long
)
vInfo
-
>
dwFileVersionMS
)
<
<
32
|
(
(
unsigned
long
long
)
vInfo
-
>
dwFileVersionLS
)
;
if
(
fVersion
>
info
-
>
maxVersion
)
load_ok
=
true
;
}
}
}
}
if
(
!
load_ok
)
{
printf_stderr
(
"
LdrLoadDll
:
Blocking
load
of
'
%
s
'
-
-
see
"
"
http
:
/
/
www
.
mozilla
.
com
/
en
-
US
/
blocklist
/
\
n
"
dllName
)
;
DllBlockSet
:
:
Add
(
info
-
>
name
fVersion
)
;
CallDllLoadHook
(
false
STATUS_DLL_NOT_FOUND
0
moduleFileName
)
;
return
STATUS_DLL_NOT_FOUND
;
}
}
}
continue_loading
:
#
ifdef
DEBUG_very_verbose
printf_stderr
(
"
LdrLoadDll
:
continuing
load
.
.
.
(
'
%
S
'
)
\
n
"
moduleFileName
-
>
Buffer
)
;
#
endif
AutoProfilerLabel
label
(
"
WindowsDllBlocklist
:
:
patched_LdrLoadDll
"
dllName
)
;
#
ifdef
_M_AMD64
AutoSuppressStackWalking
suppress
;
#
endif
NTSTATUS
ret
;
HANDLE
myHandle
;
if
(
IsUntrustedDllsHandlerEnabled
(
)
)
{
TimeStamp
loadStart
=
TimeStamp
:
:
Now
(
)
;
ret
=
stub_LdrLoadDll
(
filePath
flags
moduleFileName
&
myHandle
)
;
TimeStamp
loadEnd
=
TimeStamp
:
:
Now
(
)
;
if
(
NT_SUCCESS
(
ret
)
)
{
double
loadDurationMS
=
(
loadEnd
-
loadStart
)
.
ToMilliseconds
(
)
;
glue
:
:
UntrustedDllsHandler
:
:
OnAfterModuleLoad
(
(
uintptr_t
)
myHandle
&
~
(
uintptr_t
)
3
moduleFileName
loadDurationMS
)
;
glue
:
:
AutoSharedLock
lock
(
gDllServicesLock
)
;
if
(
gDllServices
)
{
Vector
<
glue
:
:
ModuleLoadEvent
0
InfallibleAllocPolicy
>
events
;
if
(
glue
:
:
UntrustedDllsHandler
:
:
TakePendingEvents
(
events
)
)
{
gDllServices
-
>
NotifyUntrustedModuleLoads
(
events
)
;
}
}
}
}
else
{
ret
=
stub_LdrLoadDll
(
filePath
flags
moduleFileName
&
myHandle
)
;
}
if
(
handle
)
{
*
handle
=
myHandle
;
}
CallDllLoadHook
(
NT_SUCCESS
(
ret
)
ret
handle
?
*
handle
:
0
moduleFileName
)
;
return
ret
;
}
#
if
defined
(
NIGHTLY_BUILD
)
static
mozilla
:
:
Vector
<
void
*
4
>
*
gStartAddressesToBlock
;
#
endif
static
bool
ShouldBlockThread
(
void
*
aStartAddress
)
{
if
(
aStartAddress
=
=
0
)
return
false
;
#
if
defined
(
NIGHTLY_BUILD
)
for
(
auto
p
:
*
gStartAddressesToBlock
)
{
if
(
p
=
=
aStartAddress
)
{
return
true
;
}
}
#
endif
bool
shouldBlock
=
false
;
MEMORY_BASIC_INFORMATION
startAddressInfo
=
{
0
}
;
if
(
VirtualQuery
(
aStartAddress
&
startAddressInfo
sizeof
(
startAddressInfo
)
)
)
{
shouldBlock
|
=
startAddressInfo
.
State
!
=
MEM_COMMIT
;
shouldBlock
|
=
startAddressInfo
.
Protect
!
=
PAGE_EXECUTE_READ
;
}
return
shouldBlock
;
}
static
DWORD
WINAPI
NopThreadProc
(
void
*
)
{
return
0
;
}
static
MOZ_NORETURN
void
__fastcall
patched_BaseThreadInitThunk
(
BOOL
aIsInitialThread
void
*
aStartAddress
void
*
aThreadParam
)
{
if
(
ShouldBlockThread
(
aStartAddress
)
)
{
CallCreateThreadHook
(
false
aStartAddress
)
;
aStartAddress
=
(
void
*
)
NopThreadProc
;
}
else
{
CallCreateThreadHook
(
true
aStartAddress
)
;
}
stub_BaseThreadInitThunk
(
aIsInitialThread
aStartAddress
aThreadParam
)
;
}
static
WindowsDllInterceptor
NtDllIntercept
;
static
WindowsDllInterceptor
Kernel32Intercept
;
static
void
GetNativeNtBlockSetWriter
(
)
;
MFBT_API
void
DllBlocklist_Initialize
(
uint32_t
aInitFlags
)
{
if
(
sBlocklistInitAttempted
)
{
return
;
}
sInitFlags
=
aInitFlags
;
if
(
sInitFlags
&
eDllBlocklistInitFlagWasBootstrapped
)
{
GetNativeNtBlockSetWriter
(
)
;
}
sBlocklistInitAttempted
=
true
;
#
if
defined
(
NIGHTLY_BUILD
)
gStartAddressesToBlock
=
new
mozilla
:
:
Vector
<
void
*
4
>
;
#
endif
if
(
IsUntrustedDllsHandlerEnabled
(
)
)
{
#
ifdef
ENABLE_TESTS
if
(
mozilla
:
:
EnvHasValue
(
"
XPCSHELL_TEST_PROFILE_DIR
"
)
)
{
wchar_t
dllFullPath
[
MAX_PATH
]
=
{
}
;
static
const
wchar_t
kTestDllName
[
]
=
L
"
\
\
untrusted
-
startup
-
test
-
dll
.
dll
"
;
static
const
DWORD
kBufferDirLen
=
ArrayLength
(
dllFullPath
)
-
ArrayLength
(
kTestDllName
)
;
DWORD
ret
=
:
:
GetCurrentDirectoryW
(
kBufferDirLen
dllFullPath
)
;
if
(
(
ret
>
kBufferDirLen
)
|
|
!
ret
)
{
printf_stderr
(
"
Unable
to
load
%
S
;
GetCurrentDirectoryW
failed
:
%
lu
"
kTestDllName
GetLastError
(
)
)
;
}
else
{
wcscat_s
(
dllFullPath
kTestDllName
)
;
HMODULE
hTestDll
=
:
:
LoadLibraryW
(
dllFullPath
)
;
if
(
!
hTestDll
)
{
printf_stderr
(
"
Unable
to
load
%
S
;
LoadLibraryW
failed
:
%
lu
"
kTestDllName
GetLastError
(
)
)
;
}
}
}
#
endif
glue
:
:
UntrustedDllsHandler
:
:
Init
(
)
;
}
if
(
GetModuleHandleA
(
"
user32
.
dll
"
)
)
{
sUser32BeforeBlocklist
=
true
;
#
ifdef
DEBUG
printf_stderr
(
"
DLL
blocklist
was
unable
to
intercept
AppInit
DLLs
.
\
n
"
)
;
#
endif
}
NtDllIntercept
.
Init
(
"
ntdll
.
dll
"
)
;
ReentrancySentinel
:
:
InitializeStatics
(
)
;
bool
ok
=
stub_LdrLoadDll
.
SetDetour
(
NtDllIntercept
"
LdrLoadDll
"
&
patched_LdrLoadDll
)
;
if
(
!
ok
)
{
sBlocklistInitFailed
=
true
;
#
ifdef
DEBUG
printf_stderr
(
"
LdrLoadDll
hook
failed
no
dll
blocklisting
active
\
n
"
)
;
#
endif
}
if
(
!
sUser32BeforeBlocklist
)
{
:
:
LoadLibraryW
(
L
"
user32
.
dll
"
)
;
}
Kernel32Intercept
.
Init
(
"
kernel32
.
dll
"
)
;
#
ifdef
_M_AMD64
if
(
!
IsWin8OrLater
(
)
)
{
stub_RtlInstallFunctionTableCallback
.
Set
(
Kernel32Intercept
"
RtlInstallFunctionTableCallback
"
&
patched_RtlInstallFunctionTableCallback
)
;
}
#
endif
if
(
!
GetModuleHandleW
(
L
"
WRusr
.
dll
"
)
)
{
if
(
!
stub_BaseThreadInitThunk
.
SetDetour
(
Kernel32Intercept
"
BaseThreadInitThunk
"
&
patched_BaseThreadInitThunk
)
)
{
#
ifdef
DEBUG
printf_stderr
(
"
BaseThreadInitThunk
hook
failed
\
n
"
)
;
#
endif
}
}
#
if
defined
(
NIGHTLY_BUILD
)
HMODULE
hKernel
=
GetModuleHandleW
(
L
"
kernel32
.
dll
"
)
;
if
(
hKernel
)
{
void
*
pProc
;
pProc
=
(
void
*
)
GetProcAddress
(
hKernel
"
LoadLibraryA
"
)
;
if
(
pProc
)
{
Unused
<
<
gStartAddressesToBlock
-
>
append
(
pProc
)
;
}
pProc
=
(
void
*
)
GetProcAddress
(
hKernel
"
LoadLibraryW
"
)
;
if
(
pProc
)
{
Unused
<
<
gStartAddressesToBlock
-
>
append
(
pProc
)
;
}
pProc
=
(
void
*
)
GetProcAddress
(
hKernel
"
LoadLibraryExA
"
)
;
if
(
pProc
)
{
Unused
<
<
gStartAddressesToBlock
-
>
append
(
pProc
)
;
}
pProc
=
(
void
*
)
GetProcAddress
(
hKernel
"
LoadLibraryExW
"
)
;
if
(
pProc
)
{
Unused
<
<
gStartAddressesToBlock
-
>
append
(
pProc
)
;
}
}
#
endif
}
#
ifdef
DEBUG
MFBT_API
void
DllBlocklist_Shutdown
(
)
{
if
(
IsUntrustedDllsHandlerEnabled
(
)
)
{
glue
:
:
UntrustedDllsHandler
:
:
Shutdown
(
)
;
}
}
#
endif
static
void
WriteAnnotation
(
HANDLE
aFile
Annotation
aAnnotation
const
char
*
aValue
DWORD
*
aNumBytes
)
{
const
char
*
str
=
AnnotationToString
(
aAnnotation
)
;
WriteFile
(
aFile
str
strlen
(
str
)
aNumBytes
nullptr
)
;
WriteFile
(
aFile
"
=
"
1
aNumBytes
nullptr
)
;
WriteFile
(
aFile
aValue
strlen
(
aValue
)
aNumBytes
nullptr
)
;
}
static
void
InternalWriteNotes
(
HANDLE
file
)
{
DWORD
nBytes
;
WriteAnnotation
(
file
Annotation
:
:
BlockedDllList
"
"
&
nBytes
)
;
DllBlockSet
:
:
Write
(
file
)
;
WriteFile
(
file
"
\
n
"
1
&
nBytes
nullptr
)
;
if
(
sBlocklistInitFailed
)
{
WriteAnnotation
(
file
Annotation
:
:
BlocklistInitFailed
"
1
\
n
"
&
nBytes
)
;
}
if
(
sUser32BeforeBlocklist
)
{
WriteAnnotation
(
file
Annotation
:
:
User32BeforeBlocklist
"
1
\
n
"
&
nBytes
)
;
}
}
using
WriterFn
=
void
(
*
)
(
HANDLE
)
;
static
WriterFn
gWriterFn
=
&
InternalWriteNotes
;
static
void
GetNativeNtBlockSetWriter
(
)
{
auto
nativeWriter
=
reinterpret_cast
<
WriterFn
>
(
:
:
GetProcAddress
(
:
:
GetModuleHandleW
(
nullptr
)
"
NativeNtBlockSet_Write
"
)
)
;
if
(
nativeWriter
)
{
gWriterFn
=
nativeWriter
;
}
}
MFBT_API
void
DllBlocklist_WriteNotes
(
HANDLE
file
)
{
MOZ_ASSERT
(
gWriterFn
)
;
gWriterFn
(
file
)
;
}
MFBT_API
bool
DllBlocklist_CheckStatus
(
)
{
if
(
sBlocklistInitFailed
|
|
sUser32BeforeBlocklist
)
return
false
;
return
true
;
}
enum
DllNotificationReason
{
LDR_DLL_NOTIFICATION_REASON_LOADED
=
1
LDR_DLL_NOTIFICATION_REASON_UNLOADED
=
2
}
;
typedef
struct
_LDR_DLL_LOADED_NOTIFICATION_DATA
{
ULONG
Flags
;
PCUNICODE_STRING
FullDllName
;
PCUNICODE_STRING
BaseDllName
;
PVOID
DllBase
;
ULONG
SizeOfImage
;
}
LDR_DLL_LOADED_NOTIFICATION_DATA
*
PLDR_DLL_LOADED_NOTIFICATION_DATA
;
typedef
struct
_LDR_DLL_UNLOADED_NOTIFICATION_DATA
{
ULONG
Flags
;
PCUNICODE_STRING
FullDllName
;
PCUNICODE_STRING
BaseDllName
;
PVOID
DllBase
;
ULONG
SizeOfImage
;
}
LDR_DLL_UNLOADED_NOTIFICATION_DATA
*
PLDR_DLL_UNLOADED_NOTIFICATION_DATA
;
typedef
union
_LDR_DLL_NOTIFICATION_DATA
{
LDR_DLL_LOADED_NOTIFICATION_DATA
Loaded
;
LDR_DLL_UNLOADED_NOTIFICATION_DATA
Unloaded
;
}
LDR_DLL_NOTIFICATION_DATA
*
PLDR_DLL_NOTIFICATION_DATA
;
typedef
const
LDR_DLL_NOTIFICATION_DATA
*
PCLDR_DLL_NOTIFICATION_DATA
;
typedef
VOID
(
CALLBACK
*
PLDR_DLL_NOTIFICATION_FUNCTION
)
(
ULONG
aReason
PCLDR_DLL_NOTIFICATION_DATA
aNotificationData
PVOID
aContext
)
;
NTSTATUS
NTAPI
LdrRegisterDllNotification
(
ULONG
aFlags
PLDR_DLL_NOTIFICATION_FUNCTION
aCallback
PVOID
aContext
PVOID
*
aCookie
)
;
static
PVOID
gNotificationCookie
;
static
VOID
CALLBACK
DllLoadNotification
(
ULONG
aReason
PCLDR_DLL_NOTIFICATION_DATA
aNotificationData
PVOID
aContext
)
{
if
(
aReason
!
=
LDR_DLL_NOTIFICATION_REASON_LOADED
)
{
return
;
}
glue
:
:
AutoSharedLock
lock
(
gDllServicesLock
)
;
if
(
!
gDllServices
)
{
return
;
}
PCUNICODE_STRING
fullDllName
=
aNotificationData
-
>
Loaded
.
FullDllName
;
gDllServices
-
>
DispatchDllLoadNotification
(
fullDllName
)
;
}
namespace
mozilla
{
Authenticode
*
GetAuthenticode
(
)
;
}
MFBT_API
void
DllBlocklist_SetFullDllServices
(
mozilla
:
:
glue
:
:
detail
:
:
DllServicesBase
*
aSvc
)
{
glue
:
:
AutoExclusiveLock
lock
(
gDllServicesLock
)
;
if
(
aSvc
)
{
aSvc
-
>
SetAuthenticodeImpl
(
GetAuthenticode
(
)
)
;
if
(
!
gNotificationCookie
)
{
auto
pLdrRegisterDllNotification
=
reinterpret_cast
<
decltype
(
&
:
:
LdrRegisterDllNotification
)
>
(
:
:
GetProcAddress
(
:
:
GetModuleHandleW
(
L
"
ntdll
.
dll
"
)
"
LdrRegisterDllNotification
"
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
pLdrRegisterDllNotification
)
;
mozilla
:
:
DebugOnly
<
NTSTATUS
>
ntStatus
=
pLdrRegisterDllNotification
(
0
&
DllLoadNotification
nullptr
&
gNotificationCookie
)
;
MOZ_ASSERT
(
NT_SUCCESS
(
ntStatus
)
)
;
}
}
gDllServices
=
aSvc
;
if
(
IsUntrustedDllsHandlerEnabled
(
)
&
&
gDllServices
)
{
Vector
<
glue
:
:
ModuleLoadEvent
0
InfallibleAllocPolicy
>
events
;
if
(
glue
:
:
UntrustedDllsHandler
:
:
TakePendingEvents
(
events
)
)
{
gDllServices
-
>
NotifyUntrustedModuleLoads
(
events
)
;
}
}
}
MFBT_API
void
DllBlocklist_SetBasicDllServices
(
mozilla
:
:
glue
:
:
detail
:
:
DllServicesBase
*
aSvc
)
{
if
(
!
aSvc
)
{
return
;
}
aSvc
-
>
SetAuthenticodeImpl
(
GetAuthenticode
(
)
)
;
}
