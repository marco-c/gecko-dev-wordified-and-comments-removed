#
ifndef
mozilla_glue_MozglueUtils_h
#
define
mozilla_glue_MozglueUtils_h
#
include
<
windows
.
h
>
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
namespace
mozilla
{
namespace
glue
{
#
ifdef
DEBUG
class
MOZ_STATIC_CLASS
Win32SRWLock
final
{
public
:
static
const
DWORD
kInvalidThreadId
=
0
;
constexpr
Win32SRWLock
(
)
:
mExclusiveThreadId
(
kInvalidThreadId
)
mLock
(
SRWLOCK_INIT
)
{
}
~
Win32SRWLock
(
)
{
MOZ_ASSERT
(
mExclusiveThreadId
=
=
kInvalidThreadId
)
;
}
void
LockShared
(
)
{
MOZ_ASSERT
(
mExclusiveThreadId
!
=
GetCurrentThreadId
(
)
"
Deadlock
detected
-
A
thread
attempted
to
acquire
a
shared
lock
on
"
"
a
SRWLOCK
when
it
already
owns
the
exclusive
lock
on
it
.
"
)
;
:
:
AcquireSRWLockShared
(
&
mLock
)
;
}
void
UnlockShared
(
)
{
:
:
ReleaseSRWLockShared
(
&
mLock
)
;
}
void
LockExclusive
(
)
{
MOZ_ASSERT
(
mExclusiveThreadId
!
=
GetCurrentThreadId
(
)
"
Deadlock
detected
-
A
thread
attempted
to
acquire
an
exclusive
lock
"
"
on
a
SRWLOCK
when
it
already
owns
the
exclusive
lock
on
it
.
"
)
;
:
:
AcquireSRWLockExclusive
(
&
mLock
)
;
mExclusiveThreadId
=
GetCurrentThreadId
(
)
;
}
void
UnlockExclusive
(
)
{
MOZ_ASSERT
(
mExclusiveThreadId
=
=
GetCurrentThreadId
(
)
)
;
mExclusiveThreadId
=
kInvalidThreadId
;
:
:
ReleaseSRWLockExclusive
(
&
mLock
)
;
}
Win32SRWLock
(
const
Win32SRWLock
&
)
=
delete
;
Win32SRWLock
(
Win32SRWLock
&
&
)
=
delete
;
Win32SRWLock
&
operator
=
(
const
Win32SRWLock
&
)
=
delete
;
Win32SRWLock
&
operator
=
(
Win32SRWLock
&
&
)
=
delete
;
private
:
Atomic
<
DWORD
Relaxed
>
mExclusiveThreadId
;
SRWLOCK
mLock
;
}
;
#
else
class
MOZ_STATIC_CLASS
Win32SRWLock
final
{
public
:
constexpr
Win32SRWLock
(
)
:
mLock
(
SRWLOCK_INIT
)
{
}
void
LockShared
(
)
{
:
:
AcquireSRWLockShared
(
&
mLock
)
;
}
void
UnlockShared
(
)
{
:
:
ReleaseSRWLockShared
(
&
mLock
)
;
}
void
LockExclusive
(
)
{
:
:
AcquireSRWLockExclusive
(
&
mLock
)
;
}
void
UnlockExclusive
(
)
{
:
:
ReleaseSRWLockExclusive
(
&
mLock
)
;
}
~
Win32SRWLock
(
)
=
default
;
Win32SRWLock
(
const
Win32SRWLock
&
)
=
delete
;
Win32SRWLock
(
Win32SRWLock
&
&
)
=
delete
;
Win32SRWLock
&
operator
=
(
const
Win32SRWLock
&
)
=
delete
;
Win32SRWLock
&
operator
=
(
Win32SRWLock
&
&
)
=
delete
;
private
:
SRWLOCK
mLock
;
}
;
#
endif
class
MOZ_RAII
AutoSharedLock
final
{
public
:
explicit
AutoSharedLock
(
Win32SRWLock
&
aLock
)
:
mLock
(
aLock
)
{
mLock
.
LockShared
(
)
;
}
~
AutoSharedLock
(
)
{
mLock
.
UnlockShared
(
)
;
}
AutoSharedLock
(
const
AutoSharedLock
&
)
=
delete
;
AutoSharedLock
(
AutoSharedLock
&
&
)
=
delete
;
AutoSharedLock
&
operator
=
(
const
AutoSharedLock
&
)
=
delete
;
AutoSharedLock
&
operator
=
(
AutoSharedLock
&
&
)
=
delete
;
private
:
Win32SRWLock
&
mLock
;
}
;
class
MOZ_RAII
AutoExclusiveLock
final
{
public
:
explicit
AutoExclusiveLock
(
Win32SRWLock
&
aLock
)
:
mLock
(
aLock
)
{
mLock
.
LockExclusive
(
)
;
}
~
AutoExclusiveLock
(
)
{
mLock
.
UnlockExclusive
(
)
;
}
AutoExclusiveLock
(
const
AutoExclusiveLock
&
)
=
delete
;
AutoExclusiveLock
(
AutoExclusiveLock
&
&
)
=
delete
;
AutoExclusiveLock
&
operator
=
(
const
AutoExclusiveLock
&
)
=
delete
;
AutoExclusiveLock
&
operator
=
(
AutoExclusiveLock
&
&
)
=
delete
;
private
:
Win32SRWLock
&
mLock
;
}
;
}
}
#
endif
