#
ifndef
mozilla_Printf_h
#
define
mozilla_Printf_h
#
include
"
mozilla
/
AllocPolicy
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
IntegerPrintfMacros
.
h
"
#
include
"
mozilla
/
SizePrintfMacros
.
h
"
#
include
"
mozilla
/
Types
.
h
"
#
include
<
stdarg
.
h
>
#
include
<
string
.
h
>
namespace
mozilla
{
class
PrintfTarget
{
public
:
bool
MFBT_API
print
(
const
char
*
format
.
.
.
)
MOZ_FORMAT_PRINTF
(
2
3
)
;
bool
MFBT_API
vprint
(
const
char
*
format
va_list
)
;
protected
:
MFBT_API
PrintfTarget
(
)
;
virtual
~
PrintfTarget
(
)
{
}
virtual
bool
append
(
const
char
*
sp
size_t
len
)
=
0
;
private
:
size_t
mEmitted
;
bool
emit
(
const
char
*
sp
size_t
len
)
{
mEmitted
+
=
len
;
return
append
(
sp
len
)
;
}
bool
fill2
(
const
char
*
src
int
srclen
int
width
int
flags
)
;
bool
fill_n
(
const
char
*
src
int
srclen
int
width
int
prec
int
type
int
flags
)
;
bool
cvt_l
(
long
num
int
width
int
prec
int
radix
int
type
int
flags
const
char
*
hxp
)
;
bool
cvt_ll
(
int64_t
num
int
width
int
prec
int
radix
int
type
int
flags
const
char
*
hexp
)
;
bool
cvt_f
(
double
d
const
char
*
fmt0
const
char
*
fmt1
)
;
bool
cvt_s
(
const
char
*
s
int
width
int
prec
int
flags
)
;
}
;
template
<
typename
AllocPolicy
>
class
MOZ_STACK_CLASS
SprintfState
final
:
private
mozilla
:
:
PrintfTarget
private
AllocPolicy
{
public
:
explicit
SprintfState
(
char
*
base
)
:
mMaxlen
(
base
?
strlen
(
base
)
:
0
)
mBase
(
base
)
mCur
(
base
?
base
+
mMaxlen
:
0
)
{
}
~
SprintfState
(
)
{
this
-
>
free_
(
mBase
)
;
}
bool
vprint
(
const
char
*
format
va_list
ap_list
)
{
return
mozilla
:
:
PrintfTarget
:
:
vprint
(
format
ap_list
)
&
&
append
(
"
"
1
)
;
}
char
*
release
(
)
{
char
*
result
=
mBase
;
mBase
=
nullptr
;
return
result
;
}
protected
:
bool
append
(
const
char
*
sp
size_t
len
)
override
{
ptrdiff_t
off
;
char
*
newbase
;
size_t
newlen
;
off
=
mCur
-
mBase
;
if
(
off
+
len
>
=
mMaxlen
)
{
newlen
=
mMaxlen
+
(
(
len
>
32
)
?
len
:
32
)
;
newbase
=
static_cast
<
char
*
>
(
this
-
>
maybe_pod_realloc
(
mBase
mMaxlen
newlen
)
)
;
if
(
!
newbase
)
{
return
false
;
}
mBase
=
newbase
;
mMaxlen
=
newlen
;
mCur
=
mBase
+
off
;
}
memcpy
(
mCur
sp
len
)
;
mCur
+
=
len
;
MOZ_ASSERT
(
size_t
(
mCur
-
mBase
)
<
=
mMaxlen
)
;
return
true
;
}
private
:
size_t
mMaxlen
;
char
*
mBase
;
char
*
mCur
;
}
;
template
<
typename
AllocPolicy
=
mozilla
:
:
MallocAllocPolicy
>
MOZ_FORMAT_PRINTF
(
1
2
)
char
*
Smprintf
(
const
char
*
fmt
.
.
.
)
{
SprintfState
<
AllocPolicy
>
ss
(
nullptr
)
;
va_list
ap
;
va_start
(
ap
fmt
)
;
bool
r
=
ss
.
vprint
(
fmt
ap
)
;
va_end
(
ap
)
;
if
(
!
r
)
{
return
nullptr
;
}
return
ss
.
release
(
)
;
}
template
<
typename
AllocPolicy
=
mozilla
:
:
MallocAllocPolicy
>
MOZ_FORMAT_PRINTF
(
2
3
)
char
*
SmprintfAppend
(
char
*
last
const
char
*
fmt
.
.
.
)
{
SprintfState
<
AllocPolicy
>
ss
(
last
)
;
va_list
ap
;
va_start
(
ap
fmt
)
;
bool
r
=
ss
.
vprint
(
fmt
ap
)
;
va_end
(
ap
)
;
if
(
!
r
)
{
return
nullptr
;
}
return
ss
.
release
(
)
;
}
template
<
typename
AllocPolicy
=
mozilla
:
:
MallocAllocPolicy
>
char
*
Vsmprintf
(
const
char
*
fmt
va_list
ap
)
{
SprintfState
<
AllocPolicy
>
ss
(
nullptr
)
;
if
(
!
ss
.
vprint
(
fmt
ap
)
)
return
nullptr
;
return
ss
.
release
(
)
;
}
template
<
typename
AllocPolicy
=
mozilla
:
:
MallocAllocPolicy
>
char
*
VsmprintfAppend
(
char
*
last
const
char
*
fmt
va_list
ap
)
{
SprintfState
<
AllocPolicy
>
ss
(
last
)
;
if
(
!
ss
.
vprint
(
fmt
ap
)
)
return
nullptr
;
return
ss
.
release
(
)
;
}
template
<
typename
AllocPolicy
=
mozilla
:
:
MallocAllocPolicy
>
void
SmprintfFree
(
char
*
mem
)
{
AllocPolicy
allocator
;
allocator
.
free_
(
mem
)
;
}
}
#
endif
