#
include
"
PreXULSkeletonUI
.
h
"
#
include
<
algorithm
>
#
include
<
math
.
h
>
#
include
<
limits
.
h
>
#
include
<
cmath
>
#
include
<
locale
>
#
include
<
string
>
#
include
<
objbase
.
h
>
#
include
<
shlobj
.
h
>
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
"
mozilla
/
HelperMacros
.
h
"
#
include
"
mozilla
/
glue
/
Debug
.
h
"
#
include
"
mozilla
/
BaseProfilerMarkers
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
UniquePtrExtensions
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
WindowsDpiAwareness
.
h
"
#
include
"
mozilla
/
WindowsVersion
.
h
"
namespace
mozilla
{
struct
ColorRect
{
uint32_t
color
;
uint32_t
borderColor
;
uint32_t
x
;
uint32_t
y
;
uint32_t
width
;
uint32_t
height
;
uint32_t
borderWidth
;
uint32_t
borderRadius
;
}
;
struct
DrawRect
{
uint32_t
color
;
uint32_t
backgroundColor
;
uint32_t
x
;
uint32_t
y
;
uint32_t
width
;
uint32_t
height
;
uint32_t
borderRadius
;
uint32_t
borderWidth
;
bool
strokeOnly
;
}
;
struct
NormalizedRGB
{
double
r
;
double
g
;
double
b
;
}
;
NormalizedRGB
UintToRGB
(
uint32_t
color
)
{
double
r
=
static_cast
<
double
>
(
color
>
>
16
&
0xff
)
/
255
.
0
;
double
g
=
static_cast
<
double
>
(
color
>
>
8
&
0xff
)
/
255
.
0
;
double
b
=
static_cast
<
double
>
(
color
>
>
0
&
0xff
)
/
255
.
0
;
return
NormalizedRGB
{
r
g
b
}
;
}
uint32_t
RGBToUint
(
const
NormalizedRGB
&
rgb
)
{
return
(
static_cast
<
uint32_t
>
(
rgb
.
r
*
255
.
0
)
<
<
16
)
|
(
static_cast
<
uint32_t
>
(
rgb
.
g
*
255
.
0
)
<
<
8
)
|
(
static_cast
<
uint32_t
>
(
rgb
.
b
*
255
.
0
)
<
<
0
)
;
}
double
Lerp
(
double
a
double
b
double
x
)
{
return
a
+
x
*
(
b
-
a
)
;
}
NormalizedRGB
Lerp
(
const
NormalizedRGB
&
a
const
NormalizedRGB
&
b
double
x
)
{
return
NormalizedRGB
{
Lerp
(
a
.
r
b
.
r
x
)
Lerp
(
a
.
g
b
.
g
x
)
Lerp
(
a
.
b
b
.
b
x
)
}
;
}
double
SmoothStep3
(
double
x
)
{
return
x
*
x
*
(
3
.
0
-
2
.
0
*
x
)
;
}
static
const
wchar_t
kPreXULSkeletonUIKeyPath
[
]
=
L
"
SOFTWARE
"
L
"
\
\
"
MOZ_APP_VENDOR
L
"
\
\
"
MOZ_APP_BASENAME
L
"
\
\
PreXULSkeletonUISettings
"
;
static
bool
sPreXULSkeletonUIEnabled
=
false
;
static
bool
sPreXULSkeletonUIDisallowed
=
false
;
static
HWND
sPreXULSkeletonUIWindow
;
static
LPWSTR
const
gStockApplicationIcon
=
MAKEINTRESOURCEW
(
32512
)
;
static
LPWSTR
const
gIDCWait
=
MAKEINTRESOURCEW
(
32514
)
;
static
HANDLE
sPreXULSKeletonUIAnimationThread
;
static
uint32_t
*
sPixelBuffer
=
nullptr
;
static
Vector
<
ColorRect
>
*
sAnimatedRects
=
nullptr
;
static
int
sTotalChromeHeight
=
0
;
static
volatile
LONG
sAnimationControlFlag
=
0
;
static
bool
sMaximized
=
false
;
static
int
sNonClientVerticalMargins
=
0
;
static
int
sNonClientHorizontalMargins
=
0
;
static
uint32_t
sDpi
=
0
;
static
uint32_t
sAnimationColor
;
static
uint32_t
sToolbarForegroundColor
;
static
ThemeMode
sTheme
=
ThemeMode
:
:
Invalid
;
typedef
BOOL
(
WINAPI
*
EnableNonClientDpiScalingProc
)
(
HWND
)
;
static
EnableNonClientDpiScalingProc
sEnableNonClientDpiScaling
=
NULL
;
typedef
int
(
WINAPI
*
GetSystemMetricsForDpiProc
)
(
int
UINT
)
;
GetSystemMetricsForDpiProc
sGetSystemMetricsForDpi
=
NULL
;
typedef
UINT
(
WINAPI
*
GetDpiForWindowProc
)
(
HWND
)
;
GetDpiForWindowProc
sGetDpiForWindow
=
NULL
;
typedef
ATOM
(
WINAPI
*
RegisterClassWProc
)
(
const
WNDCLASSW
*
)
;
RegisterClassWProc
sRegisterClassW
=
NULL
;
typedef
HICON
(
WINAPI
*
LoadIconWProc
)
(
HINSTANCE
LPCWSTR
)
;
LoadIconWProc
sLoadIconW
=
NULL
;
typedef
HICON
(
WINAPI
*
LoadCursorWProc
)
(
HINSTANCE
LPCWSTR
)
;
LoadCursorWProc
sLoadCursorW
=
NULL
;
typedef
HWND
(
WINAPI
*
CreateWindowExWProc
)
(
DWORD
LPCWSTR
LPCWSTR
DWORD
int
int
int
int
HWND
HMENU
HINSTANCE
LPVOID
)
;
CreateWindowExWProc
sCreateWindowExW
=
NULL
;
typedef
BOOL
(
WINAPI
*
ShowWindowProc
)
(
HWND
int
)
;
ShowWindowProc
sShowWindow
=
NULL
;
typedef
BOOL
(
WINAPI
*
SetWindowPosProc
)
(
HWND
HWND
int
int
int
int
UINT
)
;
SetWindowPosProc
sSetWindowPos
=
NULL
;
typedef
HDC
(
WINAPI
*
GetWindowDCProc
)
(
HWND
)
;
GetWindowDCProc
sGetWindowDC
=
NULL
;
typedef
int
(
WINAPI
*
FillRectProc
)
(
HDC
const
RECT
*
HBRUSH
)
;
FillRectProc
sFillRect
=
NULL
;
typedef
BOOL
(
WINAPI
*
DeleteObjectProc
)
(
HGDIOBJ
)
;
DeleteObjectProc
sDeleteObject
=
NULL
;
typedef
int
(
WINAPI
*
ReleaseDCProc
)
(
HWND
HDC
)
;
ReleaseDCProc
sReleaseDC
=
NULL
;
typedef
HMONITOR
(
WINAPI
*
MonitorFromWindowProc
)
(
HWND
DWORD
)
;
MonitorFromWindowProc
sMonitorFromWindow
=
NULL
;
typedef
BOOL
(
WINAPI
*
GetMonitorInfoWProc
)
(
HMONITOR
LPMONITORINFO
)
;
GetMonitorInfoWProc
sGetMonitorInfoW
=
NULL
;
typedef
LONG_PTR
(
WINAPI
*
SetWindowLongPtrWProc
)
(
HWND
int
LONG_PTR
)
;
SetWindowLongPtrWProc
sSetWindowLongPtrW
=
NULL
;
typedef
int
(
WINAPI
*
StretchDIBitsProc
)
(
HDC
int
int
int
int
int
int
int
int
const
VOID
*
const
BITMAPINFO
*
UINT
DWORD
)
;
StretchDIBitsProc
sStretchDIBits
=
NULL
;
typedef
HBRUSH
(
WINAPI
*
CreateSolidBrushProc
)
(
COLORREF
)
;
CreateSolidBrushProc
sCreateSolidBrush
=
NULL
;
static
uint32_t
sWindowWidth
;
static
uint32_t
sWindowHeight
;
static
double
sCSSToDevPixelScaling
;
static
const
int
kAnimationCSSPixelsPerFrame
=
21
;
static
const
int
kAnimationCSSExtraWindowSize
=
300
;
static
const
wchar_t
*
sEnabledRegSuffix
=
L
"
|
Enabled
"
;
static
const
wchar_t
*
sScreenXRegSuffix
=
L
"
|
ScreenX
"
;
static
const
wchar_t
*
sScreenYRegSuffix
=
L
"
|
ScreenY
"
;
static
const
wchar_t
*
sWidthRegSuffix
=
L
"
|
Width
"
;
static
const
wchar_t
*
sHeightRegSuffix
=
L
"
|
Height
"
;
static
const
wchar_t
*
sMaximizedRegSuffix
=
L
"
|
Maximized
"
;
static
const
wchar_t
*
sUrlbarCSSRegSuffix
=
L
"
|
UrlbarCSSSpan
"
;
static
const
wchar_t
*
sCssToDevPixelScalingRegSuffix
=
L
"
|
CssToDevPixelScaling
"
;
static
const
wchar_t
*
sSearchbarRegSuffix
=
L
"
|
SearchbarCSSSpan
"
;
static
const
wchar_t
*
sSpringsCSSRegSuffix
=
L
"
|
SpringsCSSSpan
"
;
static
const
wchar_t
*
sThemeRegSuffix
=
L
"
|
Theme
"
;
struct
LoadedCoTaskMemFreeDeleter
{
void
operator
(
)
(
void
*
ptr
)
{
static
decltype
(
CoTaskMemFree
)
*
coTaskMemFree
=
nullptr
;
if
(
!
coTaskMemFree
)
{
HMODULE
ole32Dll
=
:
:
LoadLibraryW
(
L
"
ole32
"
)
;
if
(
!
ole32Dll
)
{
printf_stderr
(
"
Could
not
load
ole32
-
will
not
free
with
CoTaskMemFree
"
)
;
return
;
}
coTaskMemFree
=
reinterpret_cast
<
decltype
(
coTaskMemFree
)
>
(
:
:
GetProcAddress
(
ole32Dll
"
CoTaskMemFree
"
)
)
;
if
(
!
coTaskMemFree
)
{
printf_stderr
(
"
Could
not
find
CoTaskMemFree
"
)
;
return
;
}
}
coTaskMemFree
(
ptr
)
;
}
}
;
std
:
:
wstring
GetRegValueName
(
const
wchar_t
*
prefix
const
wchar_t
*
suffix
)
{
std
:
:
wstring
result
(
prefix
)
;
result
.
append
(
suffix
)
;
return
result
;
}
UniquePtr
<
wchar_t
[
]
>
GetBinaryPath
(
)
{
DWORD
bufLen
=
MAX_PATH
;
UniquePtr
<
wchar_t
[
]
>
buf
;
while
(
true
)
{
buf
=
MakeUnique
<
wchar_t
[
]
>
(
bufLen
)
;
DWORD
retLen
=
:
:
GetModuleFileNameW
(
nullptr
buf
.
get
(
)
bufLen
)
;
if
(
!
retLen
)
{
return
nullptr
;
}
if
(
retLen
=
=
bufLen
&
&
:
:
GetLastError
(
)
=
=
ERROR_INSUFFICIENT_BUFFER
)
{
bufLen
*
=
2
;
continue
;
}
break
;
}
return
buf
;
}
static
UniquePtr
<
wchar_t
LoadedCoTaskMemFreeDeleter
>
GetKnownFolderPath
(
REFKNOWNFOLDERID
folderId
)
{
static
decltype
(
SHGetKnownFolderPath
)
*
shGetKnownFolderPath
=
nullptr
;
if
(
!
shGetKnownFolderPath
)
{
HMODULE
shell32Dll
=
:
:
LoadLibraryW
(
L
"
shell32
"
)
;
if
(
!
shell32Dll
)
{
return
nullptr
;
}
shGetKnownFolderPath
=
reinterpret_cast
<
decltype
(
shGetKnownFolderPath
)
>
(
:
:
GetProcAddress
(
shell32Dll
"
SHGetKnownFolderPath
"
)
)
;
if
(
!
shGetKnownFolderPath
)
{
return
nullptr
;
}
}
PWSTR
path
=
nullptr
;
shGetKnownFolderPath
(
folderId
0
nullptr
&
path
)
;
return
UniquePtr
<
wchar_t
LoadedCoTaskMemFreeDeleter
>
(
path
)
;
}
static
void
MutateStringToLowercase
(
wchar_t
*
ptr
)
{
while
(
*
ptr
)
{
wchar_t
ch
=
*
ptr
;
if
(
ch
>
=
L
'
A
'
&
&
ch
<
=
L
'
Z
'
)
{
*
ptr
=
ch
+
(
L
'
a
'
-
L
'
A
'
)
;
}
+
+
ptr
;
}
}
static
bool
TryGetSkeletonUILock
(
)
{
auto
localAppDataPath
=
GetKnownFolderPath
(
FOLDERID_LocalAppData
)
;
if
(
!
localAppDataPath
)
{
return
false
;
}
UniquePtr
<
wchar_t
[
]
>
binPath
=
GetBinaryPath
(
)
;
if
(
!
binPath
)
{
return
false
;
}
MutateStringToLowercase
(
binPath
.
get
(
)
)
;
uint32_t
hexHashSize
=
sizeof
(
uint32_t
)
*
2
+
1
;
UniquePtr
<
wchar_t
[
]
>
installHash
=
MakeUnique
<
wchar_t
[
]
>
(
hexHashSize
)
;
uint32_t
binPathHash
=
HashString
(
binPath
.
get
(
)
)
;
swprintf
(
installHash
.
get
(
)
hexHashSize
L
"
%
08x
"
binPathHash
)
;
std
:
:
wstring
lockFilePath
;
lockFilePath
.
append
(
localAppDataPath
.
get
(
)
)
;
lockFilePath
.
append
(
L
"
\
\
"
MOZ_APP_VENDOR
L
"
\
\
"
MOZ_APP_BASENAME
L
"
\
\
SkeletonUILock
-
"
)
;
lockFilePath
.
append
(
installHash
.
get
(
)
)
;
HANDLE
lockFile
=
:
:
CreateFileW
(
lockFilePath
.
c_str
(
)
GENERIC_READ
|
GENERIC_WRITE
0
nullptr
CREATE_ALWAYS
FILE_FLAG_DELETE_ON_CLOSE
nullptr
)
;
return
lockFile
!
=
INVALID_HANDLE_VALUE
;
}
class
MOZ_RAII
AutoCloseRegKey
{
public
:
explicit
AutoCloseRegKey
(
HKEY
key
)
:
mKey
(
key
)
{
}
~
AutoCloseRegKey
(
)
{
:
:
RegCloseKey
(
mKey
)
;
}
private
:
HKEY
mKey
;
}
;
int
CSSToDevPixels
(
double
cssPixels
double
scaling
)
{
return
floor
(
cssPixels
*
scaling
+
0
.
5
)
;
}
int
CSSToDevPixels
(
int
cssPixels
double
scaling
)
{
return
CSSToDevPixels
(
(
double
)
cssPixels
scaling
)
;
}
int
CSSToDevPixelsFloor
(
double
cssPixels
double
scaling
)
{
return
floor
(
cssPixels
*
scaling
)
;
}
int
CSSToDevPixelsFloor
(
int
cssPixels
double
scaling
)
{
return
CSSToDevPixelsFloor
(
(
double
)
cssPixels
scaling
)
;
}
double
SignedDistanceToCircle
(
double
x
double
y
double
radius
)
{
return
sqrt
(
x
*
x
+
y
*
y
)
-
radius
;
}
double
DistanceAntiAlias
(
double
signedDistance
)
{
const
double
aaRange
=
0
.
5
;
double
dist
=
0
.
5
*
signedDistance
/
aaRange
;
if
(
dist
<
=
-
0
.
5
+
std
:
:
numeric_limits
<
double
>
:
:
epsilon
(
)
)
return
1
.
0
;
if
(
dist
>
=
0
.
5
-
std
:
:
numeric_limits
<
double
>
:
:
epsilon
(
)
)
return
0
.
0
;
return
0
.
5
+
dist
*
(
0
.
8431027
*
dist
*
dist
-
1
.
14453603
)
;
}
void
RasterizeRoundedRectTopAndBottom
(
const
DrawRect
&
rect
)
{
if
(
rect
.
height
<
=
2
*
rect
.
borderRadius
)
{
MOZ_ASSERT
(
false
"
Skeleton
UI
rect
height
too
small
for
border
radius
.
"
)
;
return
;
}
if
(
rect
.
width
<
=
2
*
rect
.
borderRadius
)
{
MOZ_ASSERT
(
false
"
Skeleton
UI
rect
width
too
small
for
border
radius
.
"
)
;
return
;
}
NormalizedRGB
rgbBase
=
UintToRGB
(
rect
.
backgroundColor
)
;
NormalizedRGB
rgbBlend
=
UintToRGB
(
rect
.
color
)
;
for
(
int
rowIndex
=
0
;
rowIndex
<
rect
.
borderRadius
;
+
+
rowIndex
)
{
int
yTop
=
rect
.
y
+
rect
.
borderRadius
-
1
-
rowIndex
;
int
yBottom
=
rect
.
y
+
rect
.
height
-
rect
.
borderRadius
+
rowIndex
;
uint32_t
*
lineStartTop
=
&
sPixelBuffer
[
yTop
*
sWindowWidth
]
;
uint32_t
*
innermostPixelTopLeft
=
lineStartTop
+
rect
.
x
+
rect
.
borderRadius
-
1
;
uint32_t
*
innermostPixelTopRight
=
lineStartTop
+
rect
.
x
+
rect
.
width
-
rect
.
borderRadius
;
uint32_t
*
lineStartBottom
=
&
sPixelBuffer
[
yBottom
*
sWindowWidth
]
;
uint32_t
*
innermostPixelBottomLeft
=
lineStartBottom
+
rect
.
x
+
rect
.
borderRadius
-
1
;
uint32_t
*
innermostPixelBottomRight
=
lineStartBottom
+
rect
.
x
+
rect
.
width
-
rect
.
borderRadius
;
double
pixelY
=
(
double
)
rowIndex
+
0
.
5
;
for
(
int
columnIndex
=
0
;
columnIndex
<
rect
.
borderRadius
;
+
+
columnIndex
)
{
double
pixelX
=
(
double
)
columnIndex
+
0
.
5
;
double
distance
=
SignedDistanceToCircle
(
pixelX
pixelY
(
double
)
rect
.
borderRadius
)
;
double
alpha
=
DistanceAntiAlias
(
distance
)
;
NormalizedRGB
rgb
=
Lerp
(
rgbBase
rgbBlend
alpha
)
;
uint32_t
color
=
RGBToUint
(
rgb
)
;
innermostPixelTopLeft
[
-
columnIndex
]
=
color
;
innermostPixelTopRight
[
columnIndex
]
=
color
;
innermostPixelBottomLeft
[
-
columnIndex
]
=
color
;
innermostPixelBottomRight
[
columnIndex
]
=
color
;
}
std
:
:
fill
(
innermostPixelTopLeft
+
1
innermostPixelTopRight
rect
.
color
)
;
std
:
:
fill
(
innermostPixelBottomLeft
+
1
innermostPixelBottomRight
rect
.
color
)
;
}
}
void
RasterizeAnimatedRoundedRectTopAndBottom
(
const
ColorRect
&
colorRect
const
uint32_t
*
animationLookup
int
priorUpdateAreaMin
int
priorUpdateAreaMax
int
currentUpdateAreaMin
int
currentUpdateAreaMax
int
animationMin
)
{
for
(
int
rowIndex
=
0
;
rowIndex
<
colorRect
.
borderRadius
;
+
+
rowIndex
)
{
int
yTop
=
colorRect
.
y
+
colorRect
.
borderRadius
-
1
-
rowIndex
;
int
yBottom
=
colorRect
.
y
+
colorRect
.
height
-
colorRect
.
borderRadius
+
rowIndex
;
uint32_t
*
lineStartTop
=
&
sPixelBuffer
[
yTop
*
sWindowWidth
]
;
uint32_t
*
lineStartBottom
=
&
sPixelBuffer
[
yBottom
*
sWindowWidth
]
;
double
pixelY
=
(
double
)
rowIndex
+
0
.
5
;
for
(
int
x
=
priorUpdateAreaMin
;
x
<
currentUpdateAreaMax
;
+
+
x
)
{
int
columnIndex
=
std
:
:
max
(
(
int
)
colorRect
.
x
+
(
int
)
colorRect
.
borderRadius
-
x
-
1
x
-
(
(
int
)
colorRect
.
x
+
(
int
)
colorRect
.
width
-
(
int
)
colorRect
.
borderRadius
)
)
;
double
alpha
=
1
.
0
;
if
(
columnIndex
>
=
0
)
{
double
pixelX
=
(
double
)
columnIndex
+
0
.
5
;
double
distance
=
SignedDistanceToCircle
(
pixelX
pixelY
(
double
)
colorRect
.
borderRadius
)
;
alpha
=
DistanceAntiAlias
(
distance
)
;
}
if
(
alpha
>
1
.
0
-
std
:
:
numeric_limits
<
double
>
:
:
epsilon
(
)
)
{
uint32_t
color
=
x
<
priorUpdateAreaMax
?
colorRect
.
color
:
animationLookup
[
x
-
animationMin
]
;
lineStartTop
[
x
]
=
color
;
lineStartBottom
[
x
]
=
color
;
}
}
}
}
void
RasterizeColorRect
(
const
ColorRect
&
colorRect
)
{
Vector
<
DrawRect
2
>
drawRects
;
Unused
<
<
drawRects
.
reserve
(
2
)
;
if
(
colorRect
.
borderWidth
=
=
0
)
{
DrawRect
rect
=
{
}
;
rect
.
color
=
colorRect
.
color
;
rect
.
backgroundColor
=
sPixelBuffer
[
colorRect
.
y
*
sWindowWidth
+
colorRect
.
x
]
;
rect
.
x
=
colorRect
.
x
;
rect
.
y
=
colorRect
.
y
;
rect
.
width
=
colorRect
.
width
;
rect
.
height
=
colorRect
.
height
;
rect
.
borderRadius
=
colorRect
.
borderRadius
;
rect
.
strokeOnly
=
false
;
drawRects
.
infallibleAppend
(
rect
)
;
}
else
{
DrawRect
borderRect
=
{
}
;
borderRect
.
color
=
colorRect
.
borderColor
;
borderRect
.
backgroundColor
=
sPixelBuffer
[
colorRect
.
y
*
sWindowWidth
+
colorRect
.
x
]
;
borderRect
.
x
=
colorRect
.
x
;
borderRect
.
y
=
colorRect
.
y
;
borderRect
.
width
=
colorRect
.
width
;
borderRect
.
height
=
colorRect
.
height
;
borderRect
.
borderRadius
=
colorRect
.
borderRadius
;
borderRect
.
borderWidth
=
colorRect
.
borderWidth
;
borderRect
.
strokeOnly
=
true
;
drawRects
.
infallibleAppend
(
borderRect
)
;
DrawRect
baseRect
=
{
}
;
baseRect
.
color
=
colorRect
.
color
;
baseRect
.
backgroundColor
=
borderRect
.
color
;
baseRect
.
x
=
colorRect
.
x
+
colorRect
.
borderWidth
;
baseRect
.
y
=
colorRect
.
y
+
colorRect
.
borderWidth
;
baseRect
.
width
=
colorRect
.
width
-
2
*
colorRect
.
borderWidth
;
baseRect
.
height
=
colorRect
.
height
-
2
*
colorRect
.
borderWidth
;
baseRect
.
borderRadius
=
std
:
:
max
(
0
(
int
)
colorRect
.
borderRadius
-
(
int
)
colorRect
.
borderWidth
)
;
baseRect
.
borderWidth
=
0
;
baseRect
.
strokeOnly
=
false
;
drawRects
.
infallibleAppend
(
baseRect
)
;
}
for
(
const
DrawRect
&
rect
:
drawRects
)
{
RasterizeRoundedRectTopAndBottom
(
rect
)
;
int
solidRectStartY
=
std
:
:
clamp
(
rect
.
y
+
rect
.
borderRadius
0u
(
uint32_t
)
sTotalChromeHeight
)
;
int
solidRectEndY
=
std
:
:
clamp
(
rect
.
y
+
rect
.
height
-
rect
.
borderRadius
0u
(
uint32_t
)
sTotalChromeHeight
)
;
for
(
int
y
=
solidRectStartY
;
y
<
solidRectEndY
;
+
+
y
)
{
if
(
rect
.
strokeOnly
&
&
y
-
rect
.
y
>
rect
.
borderWidth
&
&
rect
.
y
+
rect
.
height
-
y
>
rect
.
borderWidth
)
{
int
startXLeft
=
std
:
:
clamp
(
rect
.
x
0u
sWindowWidth
)
;
int
endXLeft
=
std
:
:
clamp
(
rect
.
x
+
rect
.
borderWidth
0u
sWindowWidth
)
;
int
startXRight
=
std
:
:
clamp
(
rect
.
x
+
rect
.
width
-
rect
.
borderWidth
0u
sWindowWidth
)
;
int
endXRight
=
std
:
:
clamp
(
rect
.
x
+
rect
.
width
0u
sWindowWidth
)
;
uint32_t
*
lineStart
=
&
sPixelBuffer
[
y
*
sWindowWidth
]
;
uint32_t
*
dataStartLeft
=
lineStart
+
startXLeft
;
uint32_t
*
dataEndLeft
=
lineStart
+
endXLeft
;
uint32_t
*
dataStartRight
=
lineStart
+
startXRight
;
uint32_t
*
dataEndRight
=
lineStart
+
endXRight
;
std
:
:
fill
(
dataStartLeft
dataEndLeft
rect
.
color
)
;
std
:
:
fill
(
dataStartRight
dataEndRight
rect
.
color
)
;
}
else
{
int
startX
=
std
:
:
clamp
(
rect
.
x
0u
sWindowWidth
)
;
int
endX
=
std
:
:
clamp
(
rect
.
x
+
rect
.
width
0u
sWindowWidth
)
;
uint32_t
*
lineStart
=
&
sPixelBuffer
[
y
*
sWindowWidth
]
;
uint32_t
*
dataStart
=
lineStart
+
startX
;
uint32_t
*
dataEnd
=
lineStart
+
endX
;
std
:
:
fill
(
dataStart
dataEnd
rect
.
color
)
;
}
}
}
}
bool
RasterizeAnimatedRect
(
const
ColorRect
&
colorRect
const
uint32_t
*
animationLookup
int
priorAnimationMin
int
animationMin
int
animationMax
)
{
int
rectMin
=
colorRect
.
x
;
int
rectMax
=
colorRect
.
x
+
colorRect
.
width
;
bool
animationWindowOverlaps
=
rectMax
>
=
priorAnimationMin
&
&
rectMin
<
animationMax
;
int
priorUpdateAreaMin
=
std
:
:
max
(
rectMin
priorAnimationMin
)
;
int
priorUpdateAreaMax
=
std
:
:
min
(
rectMax
animationMin
)
;
int
currentUpdateAreaMin
=
std
:
:
max
(
rectMin
animationMin
)
;
int
currentUpdateAreaMax
=
std
:
:
min
(
rectMax
animationMax
)
;
if
(
!
animationWindowOverlaps
)
{
return
false
;
}
bool
animationWindowOverlapsBorderRadius
=
rectMin
+
colorRect
.
borderRadius
>
priorAnimationMin
|
|
rectMax
-
colorRect
.
borderRadius
<
=
animationMax
;
int
borderRadius
=
animationWindowOverlapsBorderRadius
?
colorRect
.
borderRadius
:
0
;
if
(
borderRadius
>
0
)
{
RasterizeAnimatedRoundedRectTopAndBottom
(
colorRect
animationLookup
priorUpdateAreaMin
priorUpdateAreaMax
currentUpdateAreaMin
currentUpdateAreaMax
animationMin
)
;
}
for
(
int
y
=
colorRect
.
y
+
borderRadius
;
y
<
colorRect
.
y
+
colorRect
.
height
-
borderRadius
;
+
+
y
)
{
uint32_t
*
lineStart
=
&
sPixelBuffer
[
y
*
sWindowWidth
]
;
for
(
int
x
=
priorUpdateAreaMin
;
x
<
priorUpdateAreaMax
;
+
+
x
)
{
lineStart
[
x
]
=
colorRect
.
color
;
}
for
(
int
x
=
currentUpdateAreaMin
;
x
<
currentUpdateAreaMax
;
+
+
x
)
{
lineStart
[
x
]
=
animationLookup
[
x
-
animationMin
]
;
}
}
return
true
;
}
void
DrawSkeletonUI
(
HWND
hWnd
CSSPixelSpan
urlbarCSSSpan
CSSPixelSpan
searchbarCSSSpan
const
Vector
<
CSSPixelSpan
>
&
springs
const
ThemeColors
&
currentTheme
)
{
sAnimationColor
=
currentTheme
.
animationColor
;
sToolbarForegroundColor
=
currentTheme
.
toolbarForegroundColor
;
int
chromeHorMargin
=
CSSToDevPixels
(
2
sCSSToDevPixelScaling
)
;
int
verticalOffset
=
sMaximized
?
sNonClientVerticalMargins
:
0
;
int
horizontalOffset
=
sNonClientHorizontalMargins
-
(
sMaximized
?
0
:
chromeHorMargin
)
;
int
topBorderHeight
=
sMaximized
?
0
:
CSSToDevPixels
(
1
sCSSToDevPixelScaling
)
;
int
tabBarHeight
=
CSSToDevPixels
(
33
sCSSToDevPixelScaling
)
+
verticalOffset
;
int
titlebarSpacerWidth
=
(
sMaximized
?
0
:
CSSToDevPixels
(
40
sCSSToDevPixelScaling
)
)
+
horizontalOffset
;
int
tabLineHeight
=
CSSToDevPixels
(
2
sCSSToDevPixelScaling
)
+
verticalOffset
;
int
selectedTabWidth
=
CSSToDevPixels
(
224
sCSSToDevPixelScaling
)
;
int
toolbarHeight
=
CSSToDevPixels
(
39
sCSSToDevPixelScaling
)
;
int
urlbarTopOffset
=
CSSToDevPixels
(
5
sCSSToDevPixelScaling
)
;
int
urlbarHeight
=
CSSToDevPixels
(
30
sCSSToDevPixelScaling
)
;
int
chromeContentDividerHeight
=
CSSToDevPixels
(
1
sCSSToDevPixelScaling
)
;
int
tabPlaceholderBarMarginTop
=
CSSToDevPixels
(
13
sCSSToDevPixelScaling
)
;
int
tabPlaceholderBarMarginLeft
=
CSSToDevPixels
(
10
sCSSToDevPixelScaling
)
;
int
tabPlaceholderBarHeight
=
CSSToDevPixels
(
8
sCSSToDevPixelScaling
)
;
int
tabPlaceholderBarWidth
=
CSSToDevPixels
(
120
sCSSToDevPixelScaling
)
;
int
toolbarPlaceholderMarginLeft
=
CSSToDevPixels
(
9
sCSSToDevPixelScaling
)
;
int
toolbarPlaceholderMarginRight
=
CSSToDevPixels
(
11
sCSSToDevPixelScaling
)
;
int
toolbarPlaceholderHeight
=
CSSToDevPixels
(
10
sCSSToDevPixelScaling
)
;
int
placeholderMargin
=
CSSToDevPixels
(
8
sCSSToDevPixelScaling
)
;
int
urlbarMargin
=
CSSToDevPixels
(
5
sCSSToDevPixelScaling
)
+
horizontalOffset
;
int
urlbarTextPlaceholderMarginTop
=
CSSToDevPixels
(
10
sCSSToDevPixelScaling
)
;
int
urlbarTextPlaceholderMarginLeft
=
CSSToDevPixels
(
10
sCSSToDevPixelScaling
)
;
int
urlbarTextPlaceHolderWidth
=
CSSToDevPixels
(
std
:
:
min
(
(
int
)
(
urlbarCSSSpan
.
end
-
urlbarCSSSpan
.
start
)
-
10
260
)
sCSSToDevPixelScaling
)
;
int
urlbarTextPlaceholderHeight
=
CSSToDevPixels
(
10
sCSSToDevPixelScaling
)
;
int
searchbarTextPlaceholderWidth
=
CSSToDevPixels
(
62
sCSSToDevPixelScaling
)
;
auto
scopeExit
=
MakeScopeExit
(
[
&
]
{
delete
sAnimatedRects
;
sAnimatedRects
=
nullptr
;
return
;
}
)
;
Vector
<
ColorRect
>
rects
;
ColorRect
topBorder
=
{
}
;
topBorder
.
color
=
0x00000000
;
topBorder
.
x
=
0
;
topBorder
.
y
=
0
;
topBorder
.
width
=
sWindowWidth
;
topBorder
.
height
=
topBorderHeight
;
if
(
!
rects
.
append
(
topBorder
)
)
{
return
;
}
int
placeholderBorderRadius
=
CSSToDevPixels
(
2
sCSSToDevPixelScaling
)
;
int
urlbarBorderRadius
=
CSSToDevPixels
(
2
sCSSToDevPixelScaling
)
;
int
urlbarBorderWidth
=
CSSToDevPixelsFloor
(
1
sCSSToDevPixelScaling
)
;
int
urlbarBorderColor
=
0xbebebe
;
ColorRect
tabBar
=
{
}
;
tabBar
.
color
=
currentTheme
.
tabBarColor
;
tabBar
.
x
=
0
;
tabBar
.
y
=
topBorder
.
height
;
tabBar
.
width
=
sWindowWidth
;
tabBar
.
height
=
tabBarHeight
;
if
(
!
rects
.
append
(
tabBar
)
)
{
return
;
}
ColorRect
tabLine
=
{
}
;
tabLine
.
color
=
currentTheme
.
tabLineColor
;
tabLine
.
x
=
titlebarSpacerWidth
;
tabLine
.
y
=
topBorder
.
height
;
tabLine
.
width
=
selectedTabWidth
;
tabLine
.
height
=
tabLineHeight
;
if
(
!
rects
.
append
(
tabLine
)
)
{
return
;
}
ColorRect
selectedTab
=
{
}
;
selectedTab
.
color
=
currentTheme
.
backgroundColor
;
selectedTab
.
x
=
titlebarSpacerWidth
;
selectedTab
.
y
=
tabLine
.
y
+
tabLineHeight
;
selectedTab
.
width
=
selectedTabWidth
;
selectedTab
.
height
=
tabBar
.
y
+
tabBar
.
height
-
selectedTab
.
y
;
if
(
!
rects
.
append
(
selectedTab
)
)
{
return
;
}
ColorRect
tabTextPlaceholder
=
{
}
;
tabTextPlaceholder
.
color
=
sToolbarForegroundColor
;
tabTextPlaceholder
.
x
=
selectedTab
.
x
+
tabPlaceholderBarMarginLeft
;
tabTextPlaceholder
.
y
=
selectedTab
.
y
+
tabPlaceholderBarMarginTop
;
tabTextPlaceholder
.
width
=
tabPlaceholderBarWidth
;
tabTextPlaceholder
.
height
=
tabPlaceholderBarHeight
;
tabTextPlaceholder
.
borderRadius
=
placeholderBorderRadius
;
if
(
!
rects
.
append
(
tabTextPlaceholder
)
)
{
return
;
}
ColorRect
toolbar
=
{
}
;
toolbar
.
color
=
currentTheme
.
backgroundColor
;
toolbar
.
x
=
0
;
toolbar
.
y
=
tabBar
.
y
+
tabBarHeight
;
toolbar
.
width
=
sWindowWidth
;
toolbar
.
height
=
toolbarHeight
;
if
(
!
rects
.
append
(
toolbar
)
)
{
return
;
}
ColorRect
chromeContentDivider
=
{
}
;
chromeContentDivider
.
color
=
currentTheme
.
chromeContentDividerColor
;
chromeContentDivider
.
x
=
0
;
chromeContentDivider
.
y
=
toolbar
.
y
+
toolbar
.
height
;
chromeContentDivider
.
width
=
sWindowWidth
;
chromeContentDivider
.
height
=
chromeContentDividerHeight
;
if
(
!
rects
.
append
(
chromeContentDivider
)
)
{
return
;
}
ColorRect
urlbar
=
{
}
;
urlbar
.
color
=
currentTheme
.
urlbarColor
;
urlbar
.
x
=
CSSToDevPixels
(
urlbarCSSSpan
.
start
sCSSToDevPixelScaling
)
+
horizontalOffset
;
urlbar
.
y
=
tabBar
.
y
+
tabBarHeight
+
urlbarTopOffset
;
urlbar
.
width
=
CSSToDevPixels
(
(
urlbarCSSSpan
.
end
-
urlbarCSSSpan
.
start
)
sCSSToDevPixelScaling
)
;
urlbar
.
height
=
urlbarHeight
;
urlbar
.
borderRadius
=
urlbarBorderRadius
;
urlbar
.
borderWidth
=
urlbarBorderWidth
;
urlbar
.
borderColor
=
urlbarBorderColor
;
if
(
!
rects
.
append
(
urlbar
)
)
{
return
;
}
ColorRect
urlbarTextPlaceholder
=
{
}
;
urlbarTextPlaceholder
.
color
=
sToolbarForegroundColor
;
urlbarTextPlaceholder
.
x
=
urlbar
.
x
+
urlbarTextPlaceholderMarginLeft
;
urlbarTextPlaceholder
.
y
=
urlbar
.
y
+
urlbarTextPlaceholderMarginTop
;
urlbarTextPlaceholder
.
width
=
urlbarTextPlaceHolderWidth
;
urlbarTextPlaceholder
.
height
=
urlbarTextPlaceholderHeight
;
urlbarTextPlaceholder
.
borderRadius
=
placeholderBorderRadius
;
if
(
!
rects
.
append
(
urlbarTextPlaceholder
)
)
{
return
;
}
bool
hasSearchbar
=
searchbarCSSSpan
.
start
!
=
0
&
&
searchbarCSSSpan
.
end
!
=
0
;
ColorRect
searchbarRect
=
{
}
;
if
(
hasSearchbar
=
=
true
)
{
searchbarRect
.
color
=
currentTheme
.
urlbarColor
;
searchbarRect
.
x
=
CSSToDevPixels
(
searchbarCSSSpan
.
start
sCSSToDevPixelScaling
)
+
horizontalOffset
;
searchbarRect
.
y
=
urlbar
.
y
;
searchbarRect
.
width
=
CSSToDevPixels
(
searchbarCSSSpan
.
end
-
searchbarCSSSpan
.
start
sCSSToDevPixelScaling
)
;
searchbarRect
.
height
=
urlbarHeight
;
searchbarRect
.
borderRadius
=
urlbarBorderRadius
;
searchbarRect
.
borderWidth
=
urlbarBorderWidth
;
searchbarRect
.
borderColor
=
urlbarBorderColor
;
if
(
!
rects
.
append
(
searchbarRect
)
)
{
return
;
}
ColorRect
searchbarTextPlaceholder
=
{
}
;
searchbarTextPlaceholder
.
color
=
sToolbarForegroundColor
;
searchbarTextPlaceholder
.
x
=
searchbarRect
.
x
+
urlbarTextPlaceholderMarginLeft
;
searchbarTextPlaceholder
.
y
=
searchbarRect
.
y
+
urlbarTextPlaceholderMarginTop
;
searchbarTextPlaceholder
.
width
=
searchbarTextPlaceholderWidth
;
searchbarTextPlaceholder
.
height
=
urlbarTextPlaceholderHeight
;
if
(
!
rects
.
append
(
searchbarTextPlaceholder
)
|
|
!
sAnimatedRects
-
>
append
(
searchbarTextPlaceholder
)
)
{
return
;
}
}
Vector
<
DevPixelSpan
>
noPlaceholderSpans
;
DevPixelSpan
urlbarSpan
;
urlbarSpan
.
start
=
urlbar
.
x
-
urlbarMargin
;
urlbarSpan
.
end
=
urlbar
.
width
+
urlbar
.
x
+
urlbarMargin
;
DevPixelSpan
searchbarSpan
;
if
(
hasSearchbar
)
{
searchbarSpan
.
start
=
searchbarRect
.
x
-
urlbarMargin
;
searchbarSpan
.
end
=
searchbarRect
.
width
+
searchbarRect
.
x
+
urlbarMargin
;
}
DevPixelSpan
marginLeftPlaceholder
;
marginLeftPlaceholder
.
start
=
toolbarPlaceholderMarginLeft
;
marginLeftPlaceholder
.
end
=
toolbarPlaceholderMarginLeft
;
if
(
!
noPlaceholderSpans
.
append
(
marginLeftPlaceholder
)
)
{
return
;
}
for
(
auto
spring
:
springs
)
{
DevPixelSpan
springDevPixels
;
springDevPixels
.
start
=
CSSToDevPixels
(
spring
.
start
sCSSToDevPixelScaling
)
+
horizontalOffset
;
springDevPixels
.
end
=
CSSToDevPixels
(
spring
.
end
sCSSToDevPixelScaling
)
+
horizontalOffset
;
if
(
!
noPlaceholderSpans
.
append
(
springDevPixels
)
)
{
return
;
}
}
DevPixelSpan
marginRightPlaceholder
;
marginRightPlaceholder
.
start
=
sWindowWidth
-
toolbarPlaceholderMarginRight
;
marginRightPlaceholder
.
end
=
sWindowWidth
-
toolbarPlaceholderMarginRight
;
if
(
!
noPlaceholderSpans
.
append
(
marginRightPlaceholder
)
)
{
return
;
}
Vector
<
DevPixelSpan
2
>
spansToAdd
;
Unused
<
<
spansToAdd
.
reserve
(
2
)
;
spansToAdd
.
infallibleAppend
(
urlbarSpan
)
;
if
(
hasSearchbar
)
{
spansToAdd
.
infallibleAppend
(
searchbarSpan
)
;
}
for
(
auto
&
toAdd
:
spansToAdd
)
{
for
(
auto
&
span
:
noPlaceholderSpans
)
{
if
(
span
.
start
>
toAdd
.
start
)
{
if
(
!
noPlaceholderSpans
.
insert
(
&
span
toAdd
)
)
{
return
;
}
break
;
}
}
}
for
(
int
i
=
1
;
i
<
noPlaceholderSpans
.
length
(
)
;
i
+
+
)
{
int
start
=
noPlaceholderSpans
[
i
-
1
]
.
end
+
placeholderMargin
;
int
end
=
noPlaceholderSpans
[
i
]
.
start
-
placeholderMargin
;
if
(
start
+
2
*
placeholderBorderRadius
>
=
end
)
{
continue
;
}
ColorRect
placeholderRect
=
{
}
;
placeholderRect
.
color
=
sToolbarForegroundColor
;
placeholderRect
.
x
=
start
;
placeholderRect
.
y
=
urlbarTextPlaceholder
.
y
;
placeholderRect
.
width
=
end
-
start
;
placeholderRect
.
height
=
toolbarPlaceholderHeight
;
placeholderRect
.
borderRadius
=
placeholderBorderRadius
;
if
(
!
rects
.
append
(
placeholderRect
)
|
|
!
sAnimatedRects
-
>
append
(
placeholderRect
)
)
{
return
;
}
}
sTotalChromeHeight
=
chromeContentDivider
.
y
+
chromeContentDivider
.
height
;
if
(
sTotalChromeHeight
>
sWindowHeight
)
{
printf_stderr
(
"
Exiting
drawing
skeleton
UI
because
window
is
too
small
.
\
n
"
)
;
return
;
}
if
(
!
sAnimatedRects
-
>
append
(
tabTextPlaceholder
)
|
|
!
sAnimatedRects
-
>
append
(
urlbarTextPlaceholder
)
)
{
return
;
}
sPixelBuffer
=
(
uint32_t
*
)
calloc
(
sWindowWidth
*
sTotalChromeHeight
sizeof
(
uint32_t
)
)
;
for
(
const
auto
&
rect
:
rects
)
{
RasterizeColorRect
(
rect
)
;
}
HDC
hdc
=
sGetWindowDC
(
hWnd
)
;
BITMAPINFO
chromeBMI
=
{
}
;
chromeBMI
.
bmiHeader
.
biSize
=
sizeof
(
chromeBMI
.
bmiHeader
)
;
chromeBMI
.
bmiHeader
.
biWidth
=
sWindowWidth
;
chromeBMI
.
bmiHeader
.
biHeight
=
-
sTotalChromeHeight
;
chromeBMI
.
bmiHeader
.
biPlanes
=
1
;
chromeBMI
.
bmiHeader
.
biBitCount
=
32
;
chromeBMI
.
bmiHeader
.
biCompression
=
BI_RGB
;
sStretchDIBits
(
hdc
0
0
sWindowWidth
sTotalChromeHeight
0
0
sWindowWidth
sTotalChromeHeight
sPixelBuffer
&
chromeBMI
DIB_RGB_COLORS
SRCCOPY
)
;
RECT
rect
=
{
0
sTotalChromeHeight
(
LONG
)
sWindowWidth
(
LONG
)
sWindowHeight
}
;
HBRUSH
brush
=
sCreateSolidBrush
(
currentTheme
.
backgroundColor
)
;
sFillRect
(
hdc
&
rect
brush
)
;
scopeExit
.
release
(
)
;
sReleaseDC
(
hWnd
hdc
)
;
sDeleteObject
(
brush
)
;
}
DWORD
WINAPI
AnimateSkeletonUI
(
void
*
aUnused
)
{
if
(
!
sPixelBuffer
|
|
sAnimatedRects
-
>
empty
(
)
)
{
return
0
;
}
int
animationWidth
=
CSSToDevPixels
(
80
sCSSToDevPixelScaling
)
;
UniquePtr
<
uint32_t
[
]
>
animationLookup
=
MakeUnique
<
uint32_t
[
]
>
(
animationWidth
)
;
uint32_t
animationColor
=
sAnimationColor
;
NormalizedRGB
rgbBlend
=
UintToRGB
(
animationColor
)
;
for
(
int
i
=
0
;
i
<
animationWidth
/
2
;
+
+
i
)
{
uint32_t
baseColor
=
sToolbarForegroundColor
;
double
blendAmountLinear
=
static_cast
<
double
>
(
i
)
/
(
static_cast
<
double
>
(
animationWidth
/
2
)
)
;
double
blendAmount
=
SmoothStep3
(
blendAmountLinear
)
;
NormalizedRGB
rgbBase
=
UintToRGB
(
baseColor
)
;
NormalizedRGB
rgb
=
Lerp
(
rgbBase
rgbBlend
blendAmount
)
;
animationLookup
[
i
]
=
RGBToUint
(
rgb
)
;
}
for
(
int
i
=
animationWidth
/
2
;
i
<
animationWidth
;
+
+
i
)
{
int
j
=
animationWidth
-
1
-
i
;
if
(
j
=
=
animationWidth
/
2
)
{
animationLookup
[
i
]
=
animationColor
;
}
else
{
animationLookup
[
i
]
=
animationLookup
[
j
]
;
}
}
BITMAPINFO
chromeBMI
=
{
}
;
chromeBMI
.
bmiHeader
.
biSize
=
sizeof
(
chromeBMI
.
bmiHeader
)
;
chromeBMI
.
bmiHeader
.
biWidth
=
sWindowWidth
;
chromeBMI
.
bmiHeader
.
biHeight
=
-
sTotalChromeHeight
;
chromeBMI
.
bmiHeader
.
biPlanes
=
1
;
chromeBMI
.
bmiHeader
.
biBitCount
=
32
;
chromeBMI
.
bmiHeader
.
biCompression
=
BI_RGB
;
uint32_t
animationIteration
=
0
;
int
devPixelsPerFrame
=
CSSToDevPixels
(
kAnimationCSSPixelsPerFrame
sCSSToDevPixelScaling
)
;
int
devPixelsExtraWindowSize
=
CSSToDevPixels
(
kAnimationCSSExtraWindowSize
sCSSToDevPixelScaling
)
;
if
(
:
:
InterlockedCompareExchange
(
&
sAnimationControlFlag
0
0
)
)
{
return
0
;
}
while
(
true
)
{
int
animationMin
=
(
(
animationIteration
*
devPixelsPerFrame
)
%
(
sWindowWidth
+
devPixelsExtraWindowSize
)
)
-
devPixelsExtraWindowSize
/
2
;
int
animationMax
=
animationMin
+
animationWidth
;
int
priorAnimationMin
=
animationMin
-
devPixelsPerFrame
;
animationMin
=
std
:
:
max
(
0
animationMin
)
;
priorAnimationMin
=
std
:
:
max
(
0
priorAnimationMin
)
;
animationMax
=
std
:
:
min
(
(
int
)
sWindowWidth
animationMax
)
;
bool
updatedAnything
=
false
;
for
(
ColorRect
rect
:
*
sAnimatedRects
)
{
bool
hadUpdates
=
RasterizeAnimatedRect
(
rect
animationLookup
.
get
(
)
priorAnimationMin
animationMin
animationMax
)
;
updatedAnything
=
updatedAnything
|
|
hadUpdates
;
}
if
(
updatedAnything
)
{
HDC
hdc
=
sGetWindowDC
(
sPreXULSkeletonUIWindow
)
;
sStretchDIBits
(
hdc
priorAnimationMin
0
animationMax
-
priorAnimationMin
sTotalChromeHeight
priorAnimationMin
0
animationMax
-
priorAnimationMin
sTotalChromeHeight
sPixelBuffer
&
chromeBMI
DIB_RGB_COLORS
SRCCOPY
)
;
sReleaseDC
(
sPreXULSkeletonUIWindow
hdc
)
;
}
animationIteration
+
+
;
if
(
InterlockedIncrement
(
&
sAnimationControlFlag
)
!
=
1
)
{
return
0
;
}
:
:
Sleep
(
16
)
;
if
(
InterlockedDecrement
(
&
sAnimationControlFlag
)
!
=
0
)
{
return
0
;
}
}
return
0
;
}
LRESULT
WINAPI
PreXULSkeletonUIProc
(
HWND
hWnd
UINT
msg
WPARAM
wParam
LPARAM
lParam
)
{
if
(
msg
=
=
WM_NCCREATE
&
&
sEnableNonClientDpiScaling
)
{
sEnableNonClientDpiScaling
(
hWnd
)
;
}
if
(
msg
=
=
WM_NCCALCSIZE
)
{
RECT
*
clientRect
=
wParam
?
&
(
reinterpret_cast
<
NCCALCSIZE_PARAMS
*
>
(
lParam
)
)
-
>
rgrc
[
0
]
:
(
reinterpret_cast
<
RECT
*
>
(
lParam
)
)
;
int
horizontalOffset
=
sNonClientHorizontalMargins
-
(
sMaximized
?
0
:
CSSToDevPixels
(
2
sCSSToDevPixelScaling
)
)
;
int
verticalOffset
=
sNonClientHorizontalMargins
-
(
sMaximized
?
0
:
CSSToDevPixels
(
2
sCSSToDevPixelScaling
)
)
;
clientRect
-
>
top
=
clientRect
-
>
top
;
clientRect
-
>
left
+
=
horizontalOffset
;
clientRect
-
>
right
-
=
horizontalOffset
;
clientRect
-
>
bottom
-
=
verticalOffset
;
return
0
;
}
return
:
:
DefWindowProcW
(
hWnd
msg
wParam
lParam
)
;
}
bool
IsSystemDarkThemeEnabled
(
)
{
DWORD
result
;
HKEY
themeKey
;
DWORD
dataLen
=
sizeof
(
uint32_t
)
;
LPCWSTR
keyName
=
L
"
SOFTWARE
\
\
Microsoft
\
\
Windows
\
\
CurrentVersion
\
\
Themes
\
\
Personalize
"
;
result
=
:
:
RegOpenKeyExW
(
HKEY_CURRENT_USER
keyName
0
KEY_READ
&
themeKey
)
;
if
(
result
!
=
ERROR_SUCCESS
)
{
return
false
;
}
AutoCloseRegKey
closeKey
(
themeKey
)
;
uint32_t
lightThemeEnabled
;
result
=
:
:
RegGetValueW
(
themeKey
nullptr
L
"
AppsUseLightTheme
"
RRF_RT_REG_DWORD
nullptr
reinterpret_cast
<
PBYTE
>
(
&
lightThemeEnabled
)
&
dataLen
)
;
if
(
result
!
=
ERROR_SUCCESS
)
{
return
false
;
}
return
!
lightThemeEnabled
;
}
ThemeColors
GetTheme
(
ThemeMode
themeId
)
{
ThemeColors
theme
=
{
}
;
switch
(
themeId
)
{
case
ThemeMode
:
:
Dark
:
theme
.
backgroundColor
=
0x323234
;
theme
.
toolbarForegroundColor
=
0x6a6a6b
;
theme
.
tabBarColor
=
0x0c0c0d
;
theme
.
chromeContentDividerColor
=
0x0c0c0d
;
theme
.
tabLineColor
=
0x0a84ff
;
theme
.
urlbarColor
=
0x474749
;
theme
.
animationColor
=
theme
.
urlbarColor
;
return
theme
;
case
ThemeMode
:
:
Light
:
theme
.
backgroundColor
=
0xf5f6f7
;
theme
.
toolbarForegroundColor
=
0xd9dadb
;
theme
.
tabBarColor
=
0xe3e4e6
;
theme
.
chromeContentDividerColor
=
0x9e9fa1
;
theme
.
tabLineColor
=
0x0a84ff
;
theme
.
urlbarColor
=
0xffffff
;
theme
.
animationColor
=
theme
.
backgroundColor
;
return
theme
;
case
ThemeMode
:
:
Default
:
default
:
MOZ_ASSERT
(
themeId
=
=
ThemeMode
:
:
Default
)
;
theme
.
backgroundColor
=
0xf9f9fa
;
theme
.
toolbarForegroundColor
=
0xe5e5e5
;
theme
.
tabBarColor
=
0x202340
;
theme
.
chromeContentDividerColor
=
0xe2e1e3
;
theme
.
tabLineColor
=
0x0a84ff
;
theme
.
urlbarColor
=
0xffffff
;
theme
.
animationColor
=
theme
.
backgroundColor
;
return
theme
;
}
}
bool
OpenPreXULSkeletonUIRegKey
(
HKEY
&
key
)
{
DWORD
disposition
;
LSTATUS
result
=
:
:
RegCreateKeyExW
(
HKEY_CURRENT_USER
kPreXULSkeletonUIKeyPath
0
nullptr
0
KEY_ALL_ACCESS
nullptr
&
key
&
disposition
)
;
if
(
result
!
=
ERROR_SUCCESS
)
{
return
false
;
}
if
(
disposition
=
=
REG_CREATED_NEW_KEY
)
{
return
false
;
}
if
(
disposition
=
=
REG_OPENED_EXISTING_KEY
)
{
return
true
;
}
:
:
RegCloseKey
(
key
)
;
return
false
;
}
bool
LoadGdi32AndUser32Procedures
(
)
{
HMODULE
user32Dll
=
:
:
LoadLibraryW
(
L
"
user32
"
)
;
HMODULE
gdi32Dll
=
:
:
LoadLibraryW
(
L
"
gdi32
"
)
;
if
(
!
user32Dll
|
|
!
gdi32Dll
)
{
return
false
;
}
auto
getThreadDpiAwarenessContext
=
(
decltype
(
GetThreadDpiAwarenessContext
)
*
)
:
:
GetProcAddress
(
user32Dll
"
GetThreadDpiAwarenessContext
"
)
;
auto
areDpiAwarenessContextsEqual
=
(
decltype
(
AreDpiAwarenessContextsEqual
)
*
)
:
:
GetProcAddress
(
user32Dll
"
AreDpiAwarenessContextsEqual
"
)
;
if
(
getThreadDpiAwarenessContext
&
&
areDpiAwarenessContextsEqual
&
&
areDpiAwarenessContextsEqual
(
getThreadDpiAwarenessContext
(
)
DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE
)
)
{
sEnableNonClientDpiScaling
=
(
EnableNonClientDpiScalingProc
)
:
:
GetProcAddress
(
user32Dll
"
EnableNonClientDpiScaling
"
)
;
}
sGetSystemMetricsForDpi
=
(
GetSystemMetricsForDpiProc
)
:
:
GetProcAddress
(
user32Dll
"
GetSystemMetricsForDpi
"
)
;
if
(
!
sGetSystemMetricsForDpi
)
{
return
false
;
}
sGetDpiForWindow
=
(
GetDpiForWindowProc
)
:
:
GetProcAddress
(
user32Dll
"
GetDpiForWindow
"
)
;
if
(
!
sGetDpiForWindow
)
{
return
false
;
}
sRegisterClassW
=
(
RegisterClassWProc
)
:
:
GetProcAddress
(
user32Dll
"
RegisterClassW
"
)
;
if
(
!
sRegisterClassW
)
{
return
false
;
}
sCreateWindowExW
=
(
CreateWindowExWProc
)
:
:
GetProcAddress
(
user32Dll
"
CreateWindowExW
"
)
;
if
(
!
sCreateWindowExW
)
{
return
false
;
}
sShowWindow
=
(
ShowWindowProc
)
:
:
GetProcAddress
(
user32Dll
"
ShowWindow
"
)
;
if
(
!
sShowWindow
)
{
return
false
;
}
sSetWindowPos
=
(
SetWindowPosProc
)
:
:
GetProcAddress
(
user32Dll
"
SetWindowPos
"
)
;
if
(
!
sSetWindowPos
)
{
return
false
;
}
sGetWindowDC
=
(
GetWindowDCProc
)
:
:
GetProcAddress
(
user32Dll
"
GetWindowDC
"
)
;
if
(
!
sGetWindowDC
)
{
return
false
;
}
sFillRect
=
(
FillRectProc
)
:
:
GetProcAddress
(
user32Dll
"
FillRect
"
)
;
if
(
!
sFillRect
)
{
return
false
;
}
sReleaseDC
=
(
ReleaseDCProc
)
:
:
GetProcAddress
(
user32Dll
"
ReleaseDC
"
)
;
if
(
!
sReleaseDC
)
{
return
false
;
}
sLoadIconW
=
(
LoadIconWProc
)
:
:
GetProcAddress
(
user32Dll
"
LoadIconW
"
)
;
if
(
!
sLoadIconW
)
{
return
false
;
}
sLoadCursorW
=
(
LoadCursorWProc
)
:
:
GetProcAddress
(
user32Dll
"
LoadCursorW
"
)
;
if
(
!
sLoadCursorW
)
{
return
false
;
}
sMonitorFromWindow
=
(
MonitorFromWindowProc
)
:
:
GetProcAddress
(
user32Dll
"
MonitorFromWindow
"
)
;
if
(
!
sMonitorFromWindow
)
{
return
false
;
}
sGetMonitorInfoW
=
(
GetMonitorInfoWProc
)
:
:
GetProcAddress
(
user32Dll
"
GetMonitorInfoW
"
)
;
if
(
!
sGetMonitorInfoW
)
{
return
false
;
}
sSetWindowLongPtrW
=
(
SetWindowLongPtrWProc
)
:
:
GetProcAddress
(
user32Dll
"
SetWindowLongPtrW
"
)
;
if
(
!
sSetWindowLongPtrW
)
{
return
false
;
}
sStretchDIBits
=
(
StretchDIBitsProc
)
:
:
GetProcAddress
(
gdi32Dll
"
StretchDIBits
"
)
;
if
(
!
sStretchDIBits
)
{
return
false
;
}
sCreateSolidBrush
=
(
CreateSolidBrushProc
)
:
:
GetProcAddress
(
gdi32Dll
"
CreateSolidBrush
"
)
;
if
(
!
sCreateSolidBrush
)
{
return
false
;
}
sDeleteObject
=
(
DeleteObjectProc
)
:
:
GetProcAddress
(
gdi32Dll
"
DeleteObject
"
)
;
if
(
!
sDeleteObject
)
{
return
false
;
}
return
true
;
}
const
char
*
NormalizeFlag
(
const
char
*
arg
)
{
if
(
strstr
(
arg
"
-
-
"
)
=
=
arg
)
{
return
arg
+
2
;
}
if
(
arg
[
0
]
=
=
'
-
'
)
{
return
arg
+
1
;
}
if
(
arg
[
0
]
=
=
'
/
'
)
{
return
arg
+
1
;
}
return
nullptr
;
}
static
bool
EnvHasValue
(
const
char
*
name
)
{
const
char
*
val
=
getenv
(
name
)
;
return
(
val
&
&
*
val
)
;
}
bool
AreAllCmdlineArgumentsApproved
(
int
argc
char
*
*
argv
)
{
const
char
*
approvedArgumentsArray
[
]
=
{
"
new
-
instance
"
"
no
-
remote
"
"
browser
"
"
foreground
"
"
setDefaultBrowser
"
"
attach
-
console
"
"
wait
-
for
-
browser
"
"
osint
"
"
new
-
tab
"
"
new
-
window
"
"
marionette
"
"
preferences
"
"
search
"
"
url
"
#
ifndef
MOZILLA_OFFICIAL
"
profile
"
#
endif
}
;
int
approvedArgumentsArraySize
=
sizeof
(
approvedArgumentsArray
)
/
sizeof
(
approvedArgumentsArray
[
0
]
)
;
Vector
<
const
char
*
>
approvedArguments
;
if
(
!
approvedArguments
.
reserve
(
approvedArgumentsArraySize
)
)
{
return
false
;
}
for
(
int
i
=
0
;
i
<
approvedArgumentsArraySize
;
+
+
i
)
{
approvedArguments
.
infallibleAppend
(
approvedArgumentsArray
[
i
]
)
;
}
#
ifdef
MOZILLA_OFFICIAL
for
(
int
i
=
1
;
i
<
argc
;
+
+
i
)
{
const
char
*
flag
=
NormalizeFlag
(
argv
[
i
]
)
;
if
(
flag
&
&
!
strcmp
(
flag
"
marionette
"
)
)
{
if
(
!
approvedArguments
.
append
(
"
profile
"
)
)
{
return
false
;
}
break
;
}
}
#
endif
for
(
int
i
=
1
;
i
<
argc
;
+
+
i
)
{
const
char
*
flag
=
NormalizeFlag
(
argv
[
i
]
)
;
if
(
!
flag
)
{
continue
;
}
bool
approved
=
false
;
for
(
const
char
*
approvedArg
:
approvedArguments
)
{
if
(
!
_stricmp
(
flag
approvedArg
)
)
{
approved
=
true
;
break
;
}
}
if
(
!
approved
)
{
return
false
;
}
}
return
true
;
}
void
CreateAndStorePreXULSkeletonUI
(
HINSTANCE
hInstance
int
argc
char
*
*
argv
)
{
#
ifdef
MOZ_GECKO_PROFILER
const
TimeStamp
skeletonStart
=
TimeStamp
:
:
NowUnfuzzed
(
)
;
#
endif
if
(
!
AreAllCmdlineArgumentsApproved
(
argc
argv
)
|
|
EnvHasValue
(
"
MOZ_SAFE_MODE_RESTART
"
)
|
|
EnvHasValue
(
"
XRE_PROFILE_PATH
"
)
|
|
EnvHasValue
(
"
MOZ_RESET_PROFILE_RESTART
"
)
)
{
sPreXULSkeletonUIDisallowed
=
true
;
return
;
}
HKEY
regKey
;
if
(
!
IsWin10OrLater
(
)
|
|
!
OpenPreXULSkeletonUIRegKey
(
regKey
)
)
{
return
;
}
AutoCloseRegKey
closeKey
(
regKey
)
;
UniquePtr
<
wchar_t
[
]
>
binPath
=
GetBinaryPath
(
)
;
DWORD
dataLen
=
sizeof
(
uint32_t
)
;
uint32_t
enabled
;
LSTATUS
result
=
:
:
RegGetValueW
(
regKey
nullptr
GetRegValueName
(
binPath
.
get
(
)
sEnabledRegSuffix
)
.
c_str
(
)
RRF_RT_REG_DWORD
nullptr
reinterpret_cast
<
PBYTE
>
(
&
enabled
)
&
dataLen
)
;
if
(
result
!
=
ERROR_SUCCESS
|
|
enabled
=
=
0
)
{
return
;
}
sPreXULSkeletonUIEnabled
=
true
;
MOZ_ASSERT
(
!
sAnimatedRects
)
;
sAnimatedRects
=
new
Vector
<
ColorRect
>
(
)
;
if
(
!
LoadGdi32AndUser32Procedures
(
)
)
{
return
;
}
if
(
!
TryGetSkeletonUILock
(
)
)
{
printf_stderr
(
"
Error
trying
to
get
skeleton
UI
lock
%
lu
\
n
"
GetLastError
(
)
)
;
return
;
}
WNDCLASSW
wc
;
wc
.
style
=
CS_DBLCLKS
;
wc
.
lpfnWndProc
=
PreXULSkeletonUIProc
;
wc
.
cbClsExtra
=
0
;
wc
.
cbWndExtra
=
0
;
wc
.
hInstance
=
hInstance
;
wc
.
hIcon
=
sLoadIconW
(
:
:
GetModuleHandleW
(
nullptr
)
gStockApplicationIcon
)
;
wc
.
hCursor
=
sLoadCursorW
(
hInstance
gIDCWait
)
;
wc
.
hbrBackground
=
nullptr
;
wc
.
lpszMenuName
=
nullptr
;
wc
.
lpszClassName
=
L
"
MozillaWindowClass
"
;
if
(
!
sRegisterClassW
(
&
wc
)
)
{
printf_stderr
(
"
RegisterClassW
error
%
lu
\
n
"
GetLastError
(
)
)
;
return
;
}
uint32_t
screenX
;
result
=
:
:
RegGetValueW
(
regKey
nullptr
GetRegValueName
(
binPath
.
get
(
)
sScreenXRegSuffix
)
.
c_str
(
)
RRF_RT_REG_DWORD
nullptr
reinterpret_cast
<
PBYTE
>
(
&
screenX
)
&
dataLen
)
;
if
(
result
!
=
ERROR_SUCCESS
)
{
printf_stderr
(
"
Error
reading
screenX
%
lu
\
n
"
GetLastError
(
)
)
;
return
;
}
uint32_t
screenY
;
result
=
:
:
RegGetValueW
(
regKey
nullptr
GetRegValueName
(
binPath
.
get
(
)
sScreenYRegSuffix
)
.
c_str
(
)
RRF_RT_REG_DWORD
nullptr
reinterpret_cast
<
PBYTE
>
(
&
screenY
)
&
dataLen
)
;
if
(
result
!
=
ERROR_SUCCESS
)
{
printf_stderr
(
"
Error
reading
screenY
%
lu
\
n
"
GetLastError
(
)
)
;
return
;
}
uint32_t
windowWidth
;
result
=
:
:
RegGetValueW
(
regKey
nullptr
GetRegValueName
(
binPath
.
get
(
)
sWidthRegSuffix
)
.
c_str
(
)
RRF_RT_REG_DWORD
nullptr
reinterpret_cast
<
PBYTE
>
(
&
windowWidth
)
&
dataLen
)
;
if
(
result
!
=
ERROR_SUCCESS
)
{
printf_stderr
(
"
Error
reading
width
%
lu
\
n
"
GetLastError
(
)
)
;
return
;
}
uint32_t
windowHeight
;
result
=
:
:
RegGetValueW
(
regKey
nullptr
GetRegValueName
(
binPath
.
get
(
)
sHeightRegSuffix
)
.
c_str
(
)
RRF_RT_REG_DWORD
nullptr
reinterpret_cast
<
PBYTE
>
(
&
windowHeight
)
&
dataLen
)
;
if
(
result
!
=
ERROR_SUCCESS
)
{
printf_stderr
(
"
Error
reading
height
%
lu
\
n
"
GetLastError
(
)
)
;
return
;
}
uint32_t
maximized
;
result
=
:
:
RegGetValueW
(
regKey
nullptr
GetRegValueName
(
binPath
.
get
(
)
sMaximizedRegSuffix
)
.
c_str
(
)
RRF_RT_REG_DWORD
nullptr
reinterpret_cast
<
PBYTE
>
(
&
maximized
)
&
dataLen
)
;
if
(
result
!
=
ERROR_SUCCESS
)
{
printf_stderr
(
"
Error
reading
maximized
%
lu
\
n
"
GetLastError
(
)
)
;
return
;
}
sMaximized
=
maximized
!
=
0
;
dataLen
=
sizeof
(
double
)
;
result
=
:
:
RegGetValueW
(
regKey
nullptr
GetRegValueName
(
binPath
.
get
(
)
sCssToDevPixelScalingRegSuffix
)
.
c_str
(
)
RRF_RT_REG_BINARY
nullptr
reinterpret_cast
<
PBYTE
>
(
&
sCSSToDevPixelScaling
)
&
dataLen
)
;
if
(
result
!
=
ERROR_SUCCESS
|
|
dataLen
!
=
sizeof
(
double
)
)
{
printf_stderr
(
"
Error
reading
cssToDevPixelScaling
%
lu
\
n
"
GetLastError
(
)
)
;
return
;
}
int
showCmd
=
SW_SHOWNORMAL
;
DWORD
windowStyle
=
kPreXULSkeletonUIWindowStyle
;
if
(
sMaximized
)
{
showCmd
=
SW_SHOWMAXIMIZED
;
windowStyle
|
=
WS_MAXIMIZE
;
}
dataLen
=
2
*
sizeof
(
double
)
;
auto
buffer
=
MakeUniqueFallible
<
wchar_t
[
]
>
(
2
*
sizeof
(
double
)
)
;
if
(
!
buffer
)
{
return
;
}
result
=
:
:
RegGetValueW
(
regKey
nullptr
GetRegValueName
(
binPath
.
get
(
)
sUrlbarCSSRegSuffix
)
.
c_str
(
)
RRF_RT_REG_BINARY
nullptr
reinterpret_cast
<
PBYTE
>
(
buffer
.
get
(
)
)
&
dataLen
)
;
if
(
result
!
=
ERROR_SUCCESS
|
|
dataLen
%
(
2
*
sizeof
(
double
)
)
!
=
0
)
{
printf_stderr
(
"
Error
reading
urlbar
%
lu
\
n
"
GetLastError
(
)
)
;
return
;
}
double
*
asDoubles
=
reinterpret_cast
<
double
*
>
(
buffer
.
get
(
)
)
;
CSSPixelSpan
urlbar
;
urlbar
.
start
=
*
(
asDoubles
+
+
)
;
urlbar
.
end
=
*
(
asDoubles
+
+
)
;
result
=
:
:
RegGetValueW
(
regKey
nullptr
GetRegValueName
(
binPath
.
get
(
)
sSearchbarRegSuffix
)
.
c_str
(
)
RRF_RT_REG_BINARY
nullptr
reinterpret_cast
<
PBYTE
>
(
buffer
.
get
(
)
)
&
dataLen
)
;
if
(
result
!
=
ERROR_SUCCESS
|
|
dataLen
%
(
2
*
sizeof
(
double
)
)
!
=
0
)
{
printf_stderr
(
"
Error
reading
searchbar
%
lu
\
n
"
GetLastError
(
)
)
;
return
;
}
asDoubles
=
reinterpret_cast
<
double
*
>
(
buffer
.
get
(
)
)
;
CSSPixelSpan
searchbar
;
searchbar
.
start
=
*
(
asDoubles
+
+
)
;
searchbar
.
end
=
*
(
asDoubles
+
+
)
;
result
=
:
:
RegQueryValueExW
(
regKey
GetRegValueName
(
binPath
.
get
(
)
sSpringsCSSRegSuffix
)
.
c_str
(
)
nullptr
nullptr
nullptr
&
dataLen
)
;
if
(
result
!
=
ERROR_SUCCESS
|
|
dataLen
%
(
2
*
sizeof
(
double
)
)
!
=
0
)
{
printf_stderr
(
"
Error
reading
springsCSS
%
lu
\
n
"
GetLastError
(
)
)
;
return
;
}
buffer
=
MakeUniqueFallible
<
wchar_t
[
]
>
(
dataLen
)
;
if
(
!
buffer
)
{
return
;
}
result
=
:
:
RegGetValueW
(
regKey
nullptr
GetRegValueName
(
binPath
.
get
(
)
sSpringsCSSRegSuffix
)
.
c_str
(
)
RRF_RT_REG_BINARY
nullptr
reinterpret_cast
<
PBYTE
>
(
buffer
.
get
(
)
)
&
dataLen
)
;
if
(
result
!
=
ERROR_SUCCESS
)
{
printf_stderr
(
"
Error
reading
springsCSS
%
lu
\
n
"
GetLastError
(
)
)
;
return
;
}
Vector
<
CSSPixelSpan
>
springs
;
asDoubles
=
reinterpret_cast
<
double
*
>
(
buffer
.
get
(
)
)
;
for
(
int
i
=
0
;
i
<
dataLen
/
(
2
*
sizeof
(
double
)
)
;
i
+
+
)
{
CSSPixelSpan
spring
;
spring
.
start
=
*
(
asDoubles
+
+
)
;
spring
.
end
=
*
(
asDoubles
+
+
)
;
if
(
!
springs
.
append
(
spring
)
)
{
return
;
}
}
dataLen
=
sizeof
(
uint32_t
)
;
uint32_t
theme
;
result
=
:
:
RegGetValueW
(
regKey
nullptr
GetRegValueName
(
binPath
.
get
(
)
sThemeRegSuffix
)
.
c_str
(
)
RRF_RT_REG_DWORD
nullptr
reinterpret_cast
<
PBYTE
>
(
&
theme
)
&
dataLen
)
;
if
(
result
!
=
ERROR_SUCCESS
)
{
printf_stderr
(
"
Error
reading
theme
%
lu
\
n
"
GetLastError
(
)
)
;
return
;
}
ThemeMode
themeMode
=
static_cast
<
ThemeMode
>
(
theme
)
;
if
(
themeMode
=
=
ThemeMode
:
:
Default
)
{
if
(
IsSystemDarkThemeEnabled
(
)
=
=
true
)
{
themeMode
=
ThemeMode
:
:
Dark
;
}
}
ThemeColors
currentTheme
=
GetTheme
(
themeMode
)
;
sPreXULSkeletonUIWindow
=
sCreateWindowExW
(
kPreXULSkeletonUIWindowStyleEx
L
"
MozillaWindowClass
"
L
"
"
windowStyle
screenX
screenY
windowWidth
windowHeight
nullptr
nullptr
hInstance
nullptr
)
;
sShowWindow
(
sPreXULSkeletonUIWindow
showCmd
)
;
sDpi
=
sGetDpiForWindow
(
sPreXULSkeletonUIWindow
)
;
sNonClientHorizontalMargins
=
sGetSystemMetricsForDpi
(
SM_CXFRAME
sDpi
)
+
sGetSystemMetricsForDpi
(
SM_CXPADDEDBORDER
sDpi
)
;
sNonClientVerticalMargins
=
sGetSystemMetricsForDpi
(
SM_CYFRAME
sDpi
)
+
sGetSystemMetricsForDpi
(
SM_CXPADDEDBORDER
sDpi
)
;
if
(
sMaximized
)
{
HMONITOR
monitor
=
sMonitorFromWindow
(
sPreXULSkeletonUIWindow
MONITOR_DEFAULTTONULL
)
;
if
(
!
monitor
)
{
return
;
}
MONITORINFO
mi
=
{
sizeof
(
MONITORINFO
)
}
;
if
(
!
sGetMonitorInfoW
(
monitor
&
mi
)
)
{
return
;
}
sWindowWidth
=
mi
.
rcWork
.
right
-
mi
.
rcWork
.
left
+
sNonClientHorizontalMargins
*
2
;
sWindowHeight
=
mi
.
rcWork
.
bottom
-
mi
.
rcWork
.
top
+
sNonClientVerticalMargins
*
2
;
}
else
{
sWindowWidth
=
windowWidth
;
sWindowHeight
=
windowHeight
;
}
sSetWindowPos
(
sPreXULSkeletonUIWindow
0
0
0
0
0
SWP_FRAMECHANGED
|
SWP_NOACTIVATE
|
SWP_NOMOVE
|
SWP_NOOWNERZORDER
|
SWP_NOSIZE
|
SWP_NOZORDER
)
;
DrawSkeletonUI
(
sPreXULSkeletonUIWindow
urlbar
searchbar
springs
currentTheme
)
;
if
(
sAnimatedRects
)
{
sPreXULSKeletonUIAnimationThread
=
:
:
CreateThread
(
nullptr
256
*
1024
AnimateSkeletonUI
nullptr
0
nullptr
)
;
}
BASE_PROFILER_MARKER_UNTYPED
(
"
CreatePreXULSkeletonUI
"
OTHER
MarkerTiming
:
:
IntervalUntilNowFrom
(
skeletonStart
)
)
;
}
bool
WasPreXULSkeletonUIMaximized
(
)
{
return
sMaximized
;
}
HWND
ConsumePreXULSkeletonUIHandle
(
)
{
if
(
InterlockedIncrement
(
&
sAnimationControlFlag
)
=
=
1
)
{
:
:
WaitForSingleObject
(
sPreXULSKeletonUIAnimationThread
INFINITE
)
;
}
:
:
CloseHandle
(
sPreXULSKeletonUIAnimationThread
)
;
sPreXULSKeletonUIAnimationThread
=
nullptr
;
HWND
result
=
sPreXULSkeletonUIWindow
;
sPreXULSkeletonUIWindow
=
nullptr
;
free
(
sPixelBuffer
)
;
sPixelBuffer
=
nullptr
;
delete
sAnimatedRects
;
sAnimatedRects
=
nullptr
;
return
result
;
}
void
PersistPreXULSkeletonUIValues
(
int
screenX
int
screenY
int
width
int
height
bool
maximized
CSSPixelSpan
urlbar
CSSPixelSpan
searchbar
const
Vector
<
CSSPixelSpan
>
&
springs
double
cssToDevPixelScaling
)
{
if
(
!
sPreXULSkeletonUIEnabled
)
{
return
;
}
HKEY
regKey
;
if
(
!
OpenPreXULSkeletonUIRegKey
(
regKey
)
)
{
return
;
}
AutoCloseRegKey
closeKey
(
regKey
)
;
UniquePtr
<
wchar_t
[
]
>
binPath
=
GetBinaryPath
(
)
;
LSTATUS
result
;
result
=
:
:
RegSetValueExW
(
regKey
GetRegValueName
(
binPath
.
get
(
)
sScreenXRegSuffix
)
.
c_str
(
)
0
REG_DWORD
reinterpret_cast
<
PBYTE
>
(
&
screenX
)
sizeof
(
screenX
)
)
;
if
(
result
!
=
ERROR_SUCCESS
)
{
printf_stderr
(
"
Failed
persisting
screenX
to
Windows
registry
\
n
"
)
;
return
;
}
result
=
:
:
RegSetValueExW
(
regKey
GetRegValueName
(
binPath
.
get
(
)
sScreenYRegSuffix
)
.
c_str
(
)
0
REG_DWORD
reinterpret_cast
<
PBYTE
>
(
&
screenY
)
sizeof
(
screenY
)
)
;
if
(
result
!
=
ERROR_SUCCESS
)
{
printf_stderr
(
"
Failed
persisting
screenY
to
Windows
registry
\
n
"
)
;
return
;
}
result
=
:
:
RegSetValueExW
(
regKey
GetRegValueName
(
binPath
.
get
(
)
sWidthRegSuffix
)
.
c_str
(
)
0
REG_DWORD
reinterpret_cast
<
PBYTE
>
(
&
width
)
sizeof
(
width
)
)
;
if
(
result
!
=
ERROR_SUCCESS
)
{
printf_stderr
(
"
Failed
persisting
width
to
Windows
registry
\
n
"
)
;
return
;
}
result
=
:
:
RegSetValueExW
(
regKey
GetRegValueName
(
binPath
.
get
(
)
sHeightRegSuffix
)
.
c_str
(
)
0
REG_DWORD
reinterpret_cast
<
PBYTE
>
(
&
height
)
sizeof
(
height
)
)
;
if
(
result
!
=
ERROR_SUCCESS
)
{
printf_stderr
(
"
Failed
persisting
height
to
Windows
registry
\
n
"
)
;
return
;
}
DWORD
maximizedDword
=
maximized
?
1
:
0
;
result
=
:
:
RegSetValueExW
(
regKey
GetRegValueName
(
binPath
.
get
(
)
sMaximizedRegSuffix
)
.
c_str
(
)
0
REG_DWORD
reinterpret_cast
<
PBYTE
>
(
&
maximizedDword
)
sizeof
(
maximizedDword
)
)
;
if
(
result
!
=
ERROR_SUCCESS
)
{
printf_stderr
(
"
Failed
persisting
maximized
to
Windows
registry
\
n
"
)
;
}
result
=
:
:
RegSetValueExW
(
regKey
GetRegValueName
(
binPath
.
get
(
)
sCssToDevPixelScalingRegSuffix
)
.
c_str
(
)
0
REG_BINARY
reinterpret_cast
<
PBYTE
>
(
&
cssToDevPixelScaling
)
sizeof
(
cssToDevPixelScaling
)
)
;
if
(
result
!
=
ERROR_SUCCESS
)
{
printf_stderr
(
"
Failed
persisting
cssToDevPixelScaling
to
Windows
registry
\
n
"
)
;
return
;
}
double
urlbarSpan
[
2
]
;
urlbarSpan
[
0
]
=
urlbar
.
start
;
urlbarSpan
[
1
]
=
urlbar
.
end
;
result
=
:
:
RegSetValueExW
(
regKey
GetRegValueName
(
binPath
.
get
(
)
sUrlbarCSSRegSuffix
)
.
c_str
(
)
0
REG_BINARY
reinterpret_cast
<
PBYTE
>
(
urlbarSpan
)
sizeof
(
urlbarSpan
)
)
;
if
(
result
!
=
ERROR_SUCCESS
)
{
printf_stderr
(
"
Failed
persisting
urlbar
to
Windows
registry
\
n
"
)
;
return
;
}
double
searchbarSpan
[
2
]
;
searchbarSpan
[
0
]
=
searchbar
.
start
;
searchbarSpan
[
1
]
=
searchbar
.
end
;
result
=
:
:
RegSetValueExW
(
regKey
GetRegValueName
(
binPath
.
get
(
)
sSearchbarRegSuffix
)
.
c_str
(
)
0
REG_BINARY
reinterpret_cast
<
PBYTE
>
(
searchbarSpan
)
sizeof
(
searchbarSpan
)
)
;
if
(
result
!
=
ERROR_SUCCESS
)
{
printf_stderr
(
"
Failed
persisting
searchbar
to
Windows
registry
\
n
"
)
;
return
;
}
Vector
<
double
>
springValues
;
if
(
!
springValues
.
reserve
(
springs
.
length
(
)
*
2
)
)
{
return
;
}
for
(
auto
spring
:
springs
)
{
springValues
.
infallibleAppend
(
spring
.
start
)
;
springValues
.
infallibleAppend
(
spring
.
end
)
;
}
result
=
:
:
RegSetValueExW
(
regKey
GetRegValueName
(
binPath
.
get
(
)
sSpringsCSSRegSuffix
)
.
c_str
(
)
0
REG_BINARY
reinterpret_cast
<
PBYTE
>
(
springValues
.
begin
(
)
)
springValues
.
length
(
)
*
sizeof
(
double
)
)
;
if
(
result
!
=
ERROR_SUCCESS
)
{
printf_stderr
(
"
Failed
persisting
springsCSS
to
Windows
registry
\
n
"
)
;
return
;
}
}
MFBT_API
bool
GetPreXULSkeletonUIEnabled
(
)
{
return
sPreXULSkeletonUIEnabled
;
}
MFBT_API
void
SetPreXULSkeletonUIEnabledIfAllowed
(
bool
value
)
{
if
(
sPreXULSkeletonUIDisallowed
)
{
return
;
}
HKEY
regKey
;
if
(
!
OpenPreXULSkeletonUIRegKey
(
regKey
)
)
{
return
;
}
AutoCloseRegKey
closeKey
(
regKey
)
;
UniquePtr
<
wchar_t
[
]
>
binPath
=
GetBinaryPath
(
)
;
DWORD
enabled
=
value
;
LSTATUS
result
=
:
:
RegSetValueExW
(
regKey
GetRegValueName
(
binPath
.
get
(
)
sEnabledRegSuffix
)
.
c_str
(
)
0
REG_DWORD
reinterpret_cast
<
PBYTE
>
(
&
enabled
)
sizeof
(
enabled
)
)
;
if
(
result
!
=
ERROR_SUCCESS
)
{
printf_stderr
(
"
Failed
persisting
enabled
to
Windows
registry
\
n
"
)
;
return
;
}
if
(
!
sPreXULSkeletonUIEnabled
&
&
value
)
{
Unused
<
<
TryGetSkeletonUILock
(
)
;
}
sPreXULSkeletonUIEnabled
=
value
;
}
MFBT_API
void
SetPreXULSkeletonUIThemeId
(
ThemeMode
theme
)
{
if
(
theme
=
=
sTheme
)
{
return
;
}
HKEY
regKey
;
if
(
!
OpenPreXULSkeletonUIRegKey
(
regKey
)
)
{
return
;
}
AutoCloseRegKey
closeKey
(
regKey
)
;
UniquePtr
<
wchar_t
[
]
>
binPath
=
GetBinaryPath
(
)
;
uint32_t
themeId
=
(
uint32_t
)
theme
;
LSTATUS
result
;
result
=
:
:
RegSetValueExW
(
regKey
GetRegValueName
(
binPath
.
get
(
)
sThemeRegSuffix
)
.
c_str
(
)
0
REG_DWORD
reinterpret_cast
<
PBYTE
>
(
&
themeId
)
sizeof
(
themeId
)
)
;
if
(
result
!
=
ERROR_SUCCESS
)
{
printf_stderr
(
"
Failed
persisting
theme
to
Windows
registry
\
n
"
)
;
sTheme
=
ThemeMode
:
:
Invalid
;
return
;
}
sTheme
=
static_cast
<
ThemeMode
>
(
themeId
)
;
}
MFBT_API
void
PollPreXULSkeletonUIEvents
(
)
{
if
(
sPreXULSkeletonUIEnabled
&
&
sPreXULSkeletonUIWindow
)
{
MSG
outMsg
=
{
}
;
PeekMessageW
(
&
outMsg
sPreXULSkeletonUIWindow
0
0
0
)
;
}
}
}
