#
include
"
PreXULSkeletonUI
.
h
"
#
include
<
algorithm
>
#
include
<
dwmapi
.
h
>
#
include
<
math
.
h
>
#
include
<
limits
.
h
>
#
include
<
cmath
>
#
include
<
locale
>
#
include
<
string
>
#
include
<
objbase
.
h
>
#
include
<
shlobj
.
h
>
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
BaseProfilerMarkers
.
h
"
#
include
"
mozilla
/
CacheNtDllThunk
.
h
"
#
include
"
mozilla
/
FStream
.
h
"
#
include
"
mozilla
/
GetKnownFolderPath
.
h
"
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
"
mozilla
/
HelperMacros
.
h
"
#
include
"
mozilla
/
glue
/
Debug
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
mscom
/
ProcessRuntime
.
h
"
#
include
"
mozilla
/
ResultVariant
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
Try
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
UniquePtrExtensions
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
WindowsDpiAwareness
.
h
"
#
include
"
mozilla
/
WindowsProcessMitigations
.
h
"
namespace
mozilla
{
struct
ColorRect
{
uint32_t
color
;
uint32_t
borderColor
;
int
x
;
int
y
;
int
width
;
int
height
;
int
borderWidth
;
int
borderRadius
;
bool
flipIfRTL
;
}
;
struct
DrawRect
{
uint32_t
color
;
uint32_t
backgroundColor
;
int
x
;
int
y
;
int
width
;
int
height
;
int
borderRadius
;
int
borderWidth
;
bool
strokeOnly
;
}
;
struct
NormalizedRGB
{
double
r
;
double
g
;
double
b
;
}
;
NormalizedRGB
UintToRGB
(
uint32_t
color
)
{
double
r
=
static_cast
<
double
>
(
color
>
>
16
&
0xff
)
/
255
.
0
;
double
g
=
static_cast
<
double
>
(
color
>
>
8
&
0xff
)
/
255
.
0
;
double
b
=
static_cast
<
double
>
(
color
>
>
0
&
0xff
)
/
255
.
0
;
return
NormalizedRGB
{
r
g
b
}
;
}
uint32_t
RGBToUint
(
const
NormalizedRGB
&
rgb
)
{
return
(
static_cast
<
uint32_t
>
(
rgb
.
r
*
255
.
0
)
<
<
16
)
|
(
static_cast
<
uint32_t
>
(
rgb
.
g
*
255
.
0
)
<
<
8
)
|
(
static_cast
<
uint32_t
>
(
rgb
.
b
*
255
.
0
)
<
<
0
)
;
}
double
Lerp
(
double
a
double
b
double
x
)
{
return
a
+
x
*
(
b
-
a
)
;
}
NormalizedRGB
Lerp
(
const
NormalizedRGB
&
a
const
NormalizedRGB
&
b
double
x
)
{
return
NormalizedRGB
{
Lerp
(
a
.
r
b
.
r
x
)
Lerp
(
a
.
g
b
.
g
x
)
Lerp
(
a
.
b
b
.
b
x
)
}
;
}
double
SmoothStep3
(
double
x
)
{
return
x
*
x
*
(
3
.
0
-
2
.
0
*
x
)
;
}
static
const
wchar_t
kPreXULSkeletonUIKeyPath
[
]
=
L
"
SOFTWARE
"
L
"
\
\
"
MOZ_APP_VENDOR
L
"
\
\
"
MOZ_APP_BASENAME
L
"
\
\
PreXULSkeletonUISettings
"
;
static
bool
sPreXULSkeletonUIShown
=
false
;
static
bool
sPreXULSkeletonUIEnabled
=
false
;
static
HWND
sPreXULSkeletonUIWindow
;
static
LPWSTR
const
gStockApplicationIcon
=
MAKEINTRESOURCEW
(
32512
)
;
static
LPWSTR
const
gIDCWait
=
MAKEINTRESOURCEW
(
32514
)
;
static
HANDLE
sPreXULSKeletonUIAnimationThread
;
static
HANDLE
sPreXULSKeletonUILockFile
=
INVALID_HANDLE_VALUE
;
static
mozilla
:
:
mscom
:
:
ProcessRuntime
*
sProcessRuntime
;
static
uint32_t
*
sPixelBuffer
=
nullptr
;
static
Vector
<
ColorRect
>
*
sAnimatedRects
=
nullptr
;
static
int
sTotalChromeHeight
=
0
;
static
volatile
LONG
sAnimationControlFlag
=
0
;
static
bool
sMaximized
=
false
;
static
int
sNonClientVerticalMargins
=
0
;
static
int
sNonClientHorizontalMargins
=
0
;
static
uint32_t
sDpi
=
0
;
static
uint32_t
sAnimationColor
;
static
uint32_t
sToolbarForegroundColor
;
static
ThemeMode
sTheme
=
ThemeMode
:
:
Invalid
;
#
define
MOZ_DECL_IMPORTED_WIN32_FN
(
name
)
\
static
decltype
(
&
:
:
name
)
s
#
#
name
=
nullptr
MOZ_DECL_IMPORTED_WIN32_FN
(
EnableNonClientDpiScaling
)
;
MOZ_DECL_IMPORTED_WIN32_FN
(
GetSystemMetricsForDpi
)
;
MOZ_DECL_IMPORTED_WIN32_FN
(
GetDpiForWindow
)
;
MOZ_DECL_IMPORTED_WIN32_FN
(
RegisterClassW
)
;
MOZ_DECL_IMPORTED_WIN32_FN
(
LoadIconW
)
;
MOZ_DECL_IMPORTED_WIN32_FN
(
LoadCursorW
)
;
MOZ_DECL_IMPORTED_WIN32_FN
(
CreateWindowExW
)
;
MOZ_DECL_IMPORTED_WIN32_FN
(
ShowWindow
)
;
MOZ_DECL_IMPORTED_WIN32_FN
(
SetWindowPos
)
;
MOZ_DECL_IMPORTED_WIN32_FN
(
GetWindowDC
)
;
MOZ_DECL_IMPORTED_WIN32_FN
(
GetWindowRect
)
;
MOZ_DECL_IMPORTED_WIN32_FN
(
MapWindowPoints
)
;
MOZ_DECL_IMPORTED_WIN32_FN
(
FillRect
)
;
MOZ_DECL_IMPORTED_WIN32_FN
(
DeleteObject
)
;
MOZ_DECL_IMPORTED_WIN32_FN
(
ReleaseDC
)
;
MOZ_DECL_IMPORTED_WIN32_FN
(
MonitorFromWindow
)
;
MOZ_DECL_IMPORTED_WIN32_FN
(
GetMonitorInfoW
)
;
MOZ_DECL_IMPORTED_WIN32_FN
(
SetWindowLongPtrW
)
;
MOZ_DECL_IMPORTED_WIN32_FN
(
StretchDIBits
)
;
MOZ_DECL_IMPORTED_WIN32_FN
(
CreateSolidBrush
)
;
MOZ_DECL_IMPORTED_WIN32_FN
(
DwmGetWindowAttribute
)
;
MOZ_DECL_IMPORTED_WIN32_FN
(
DwmSetWindowAttribute
)
;
#
undef
MOZ_DECL_IMPORTED_WIN32_FN
static
int
sWindowWidth
;
static
int
sWindowHeight
;
static
double
sCSSToDevPixelScaling
;
static
Maybe
<
PreXULSkeletonUIError
>
sErrorReason
;
static
const
int
kAnimationCSSPixelsPerFrame
=
11
;
static
const
int
kAnimationCSSExtraWindowSize
=
300
;
static
const
uint32_t
kMaxWindowWidth
=
1
<
<
16
;
static
const
uint32_t
kMaxWindowHeight
=
1
<
<
16
;
static
const
wchar_t
*
sEnabledRegSuffix
=
L
"
|
Enabled
"
;
static
const
wchar_t
*
sScreenXRegSuffix
=
L
"
|
ScreenX
"
;
static
const
wchar_t
*
sScreenYRegSuffix
=
L
"
|
ScreenY
"
;
static
const
wchar_t
*
sWidthRegSuffix
=
L
"
|
Width
"
;
static
const
wchar_t
*
sHeightRegSuffix
=
L
"
|
Height
"
;
static
const
wchar_t
*
sMaximizedRegSuffix
=
L
"
|
Maximized
"
;
static
const
wchar_t
*
sUrlbarCSSRegSuffix
=
L
"
|
UrlbarCSSSpan
"
;
static
const
wchar_t
*
sCssToDevPixelScalingRegSuffix
=
L
"
|
CssToDevPixelScaling
"
;
static
const
wchar_t
*
sSearchbarRegSuffix
=
L
"
|
SearchbarCSSSpan
"
;
static
const
wchar_t
*
sSpringsCSSRegSuffix
=
L
"
|
SpringsCSSSpan
"
;
static
const
wchar_t
*
sThemeRegSuffix
=
L
"
|
Theme
"
;
static
const
wchar_t
*
sFlagsRegSuffix
=
L
"
|
Flags
"
;
static
const
wchar_t
*
sProgressSuffix
=
L
"
|
Progress
"
;
std
:
:
wstring
GetRegValueName
(
const
wchar_t
*
prefix
const
wchar_t
*
suffix
)
{
std
:
:
wstring
result
(
prefix
)
;
result
.
append
(
suffix
)
;
return
result
;
}
Result
<
UniquePtr
<
wchar_t
[
]
>
PreXULSkeletonUIError
>
GetBinaryPath
(
)
{
DWORD
bufLen
=
MAX_PATH
;
UniquePtr
<
wchar_t
[
]
>
buf
;
while
(
true
)
{
buf
=
MakeUnique
<
wchar_t
[
]
>
(
bufLen
)
;
DWORD
retLen
=
:
:
GetModuleFileNameW
(
nullptr
buf
.
get
(
)
bufLen
)
;
if
(
!
retLen
)
{
return
Err
(
PreXULSkeletonUIError
:
:
FilesystemFailure
)
;
}
if
(
retLen
=
=
bufLen
&
&
:
:
GetLastError
(
)
=
=
ERROR_INSUFFICIENT_BUFFER
)
{
bufLen
*
=
2
;
continue
;
}
break
;
}
return
buf
;
}
static
bool
PreXULSkeletonUIDisallowed
(
)
{
return
sErrorReason
.
isSome
(
)
&
&
(
*
sErrorReason
=
=
PreXULSkeletonUIError
:
:
Cmdline
|
|
*
sErrorReason
=
=
PreXULSkeletonUIError
:
:
EnvVars
)
;
}
static
void
MutateStringToLowercase
(
wchar_t
*
ptr
)
{
while
(
*
ptr
)
{
wchar_t
ch
=
*
ptr
;
if
(
ch
>
=
L
'
A
'
&
&
ch
<
=
L
'
Z
'
)
{
*
ptr
=
ch
+
(
L
'
a
'
-
L
'
A
'
)
;
}
+
+
ptr
;
}
}
static
Result
<
Ok
PreXULSkeletonUIError
>
GetSkeletonUILock
(
)
{
auto
localAppDataPath
=
GetKnownFolderPath
(
FOLDERID_LocalAppData
)
;
if
(
!
localAppDataPath
)
{
return
Err
(
PreXULSkeletonUIError
:
:
FilesystemFailure
)
;
}
if
(
sPreXULSKeletonUILockFile
!
=
INVALID_HANDLE_VALUE
)
{
return
Ok
(
)
;
}
UniquePtr
<
wchar_t
[
]
>
binPath
;
MOZ_TRY_VAR
(
binPath
GetBinaryPath
(
)
)
;
MutateStringToLowercase
(
binPath
.
get
(
)
)
;
uint32_t
hexHashSize
=
sizeof
(
uint32_t
)
*
2
+
1
;
UniquePtr
<
wchar_t
[
]
>
installHash
=
MakeUnique
<
wchar_t
[
]
>
(
hexHashSize
)
;
uint32_t
binPathHash
=
HashString
(
binPath
.
get
(
)
)
;
swprintf
(
installHash
.
get
(
)
hexHashSize
L
"
%
08x
"
binPathHash
)
;
std
:
:
wstring
lockFilePath
;
lockFilePath
.
append
(
localAppDataPath
.
get
(
)
)
;
lockFilePath
.
append
(
L
"
\
\
"
MOZ_APP_VENDOR
L
"
\
\
"
MOZ_APP_BASENAME
L
"
\
\
SkeletonUILock
-
"
)
;
lockFilePath
.
append
(
installHash
.
get
(
)
)
;
sPreXULSKeletonUILockFile
=
:
:
CreateFileW
(
lockFilePath
.
c_str
(
)
GENERIC_READ
|
GENERIC_WRITE
0
nullptr
CREATE_ALWAYS
FILE_FLAG_DELETE_ON_CLOSE
nullptr
)
;
if
(
sPreXULSKeletonUILockFile
=
=
INVALID_HANDLE_VALUE
)
{
return
Err
(
PreXULSkeletonUIError
:
:
FailedGettingLock
)
;
}
return
Ok
(
)
;
}
const
char
kGeneralSection
[
]
=
"
[
General
]
"
;
const
char
kStartWithLastProfile
[
]
=
"
StartWithLastProfile
=
"
;
static
bool
ProfileDbHasStartWithLastProfile
(
IFStream
&
iniContents
)
{
bool
inGeneral
=
false
;
std
:
:
string
line
;
while
(
std
:
:
getline
(
iniContents
line
)
)
{
size_t
whitespace
=
0
;
while
(
line
.
length
(
)
>
whitespace
&
&
(
line
[
whitespace
]
=
=
'
'
|
|
line
[
whitespace
]
=
=
'
\
t
'
)
)
{
whitespace
+
+
;
}
line
.
erase
(
0
whitespace
)
;
if
(
line
.
compare
(
kGeneralSection
)
=
=
0
)
{
inGeneral
=
true
;
}
else
if
(
inGeneral
)
{
if
(
line
[
0
]
=
=
'
[
'
)
{
inGeneral
=
false
;
}
else
{
if
(
line
.
find
(
kStartWithLastProfile
)
=
=
0
)
{
char
val
=
line
.
c_str
(
)
[
sizeof
(
kStartWithLastProfile
)
-
1
]
;
if
(
val
=
=
'
0
'
)
{
return
false
;
}
else
if
(
val
=
=
'
1
'
)
{
return
true
;
}
}
}
}
}
return
true
;
}
static
Result
<
Ok
PreXULSkeletonUIError
>
CheckForStartWithLastProfile
(
)
{
auto
roamingAppData
=
GetKnownFolderPath
(
FOLDERID_RoamingAppData
)
;
if
(
!
roamingAppData
)
{
return
Err
(
PreXULSkeletonUIError
:
:
FilesystemFailure
)
;
}
std
:
:
wstring
profileDbPath
(
roamingAppData
.
get
(
)
)
;
profileDbPath
.
append
(
L
"
\
\
"
MOZ_APP_VENDOR
L
"
\
\
"
MOZ_APP_BASENAME
L
"
\
\
profiles
.
ini
"
)
;
IFStream
profileDb
(
profileDbPath
.
c_str
(
)
)
;
if
(
profileDb
.
fail
(
)
)
{
return
Err
(
PreXULSkeletonUIError
:
:
FilesystemFailure
)
;
}
if
(
!
ProfileDbHasStartWithLastProfile
(
profileDb
)
)
{
return
Err
(
PreXULSkeletonUIError
:
:
NoStartWithLastProfile
)
;
}
return
Ok
(
)
;
}
class
MOZ_RAII
AutoCloseRegKey
{
public
:
explicit
AutoCloseRegKey
(
HKEY
key
)
:
mKey
(
key
)
{
}
~
AutoCloseRegKey
(
)
{
:
:
RegCloseKey
(
mKey
)
;
}
private
:
HKEY
mKey
;
}
;
int
CSSToDevPixels
(
double
cssPixels
double
scaling
)
{
return
floor
(
cssPixels
*
scaling
+
0
.
5
)
;
}
int
CSSToDevPixels
(
int
cssPixels
double
scaling
)
{
return
CSSToDevPixels
(
(
double
)
cssPixels
scaling
)
;
}
int
CSSToDevPixelsFloor
(
double
cssPixels
double
scaling
)
{
return
floor
(
cssPixels
*
scaling
)
;
}
int
CSSToDevPixelsFloor
(
int
cssPixels
double
scaling
)
{
return
CSSToDevPixelsFloor
(
(
double
)
cssPixels
scaling
)
;
}
double
SignedDistanceToCircle
(
double
x
double
y
double
radius
)
{
return
sqrt
(
x
*
x
+
y
*
y
)
-
radius
;
}
double
DistanceAntiAlias
(
double
signedDistance
)
{
const
double
aaRange
=
0
.
5
;
double
dist
=
0
.
5
*
signedDistance
/
aaRange
;
if
(
dist
<
=
-
0
.
5
+
std
:
:
numeric_limits
<
double
>
:
:
epsilon
(
)
)
return
1
.
0
;
if
(
dist
>
=
0
.
5
-
std
:
:
numeric_limits
<
double
>
:
:
epsilon
(
)
)
return
0
.
0
;
return
0
.
5
+
dist
*
(
0
.
8431027
*
dist
*
dist
-
1
.
14453603
)
;
}
void
RasterizeRoundedRectTopAndBottom
(
const
DrawRect
&
rect
)
{
if
(
rect
.
height
<
=
2
*
rect
.
borderRadius
)
{
MOZ_ASSERT
(
false
"
Skeleton
UI
rect
height
too
small
for
border
radius
.
"
)
;
return
;
}
if
(
rect
.
width
<
=
2
*
rect
.
borderRadius
)
{
MOZ_ASSERT
(
false
"
Skeleton
UI
rect
width
too
small
for
border
radius
.
"
)
;
return
;
}
NormalizedRGB
rgbBase
=
UintToRGB
(
rect
.
backgroundColor
)
;
NormalizedRGB
rgbBlend
=
UintToRGB
(
rect
.
color
)
;
for
(
int
rowIndex
=
0
;
rowIndex
<
rect
.
borderRadius
;
+
+
rowIndex
)
{
int
yTop
=
rect
.
y
+
rect
.
borderRadius
-
1
-
rowIndex
;
int
yBottom
=
rect
.
y
+
rect
.
height
-
rect
.
borderRadius
+
rowIndex
;
uint32_t
*
lineStartTop
=
&
sPixelBuffer
[
yTop
*
sWindowWidth
]
;
uint32_t
*
innermostPixelTopLeft
=
lineStartTop
+
rect
.
x
+
rect
.
borderRadius
-
1
;
uint32_t
*
innermostPixelTopRight
=
lineStartTop
+
rect
.
x
+
rect
.
width
-
rect
.
borderRadius
;
uint32_t
*
lineStartBottom
=
&
sPixelBuffer
[
yBottom
*
sWindowWidth
]
;
uint32_t
*
innermostPixelBottomLeft
=
lineStartBottom
+
rect
.
x
+
rect
.
borderRadius
-
1
;
uint32_t
*
innermostPixelBottomRight
=
lineStartBottom
+
rect
.
x
+
rect
.
width
-
rect
.
borderRadius
;
double
pixelY
=
(
double
)
rowIndex
+
0
.
5
;
for
(
int
columnIndex
=
0
;
columnIndex
<
rect
.
borderRadius
;
+
+
columnIndex
)
{
double
pixelX
=
(
double
)
columnIndex
+
0
.
5
;
double
distance
=
SignedDistanceToCircle
(
pixelX
pixelY
(
double
)
rect
.
borderRadius
)
;
double
alpha
=
DistanceAntiAlias
(
distance
)
;
NormalizedRGB
rgb
=
Lerp
(
rgbBase
rgbBlend
alpha
)
;
uint32_t
color
=
RGBToUint
(
rgb
)
;
innermostPixelTopLeft
[
-
columnIndex
]
=
color
;
innermostPixelTopRight
[
columnIndex
]
=
color
;
innermostPixelBottomLeft
[
-
columnIndex
]
=
color
;
innermostPixelBottomRight
[
columnIndex
]
=
color
;
}
std
:
:
fill
(
innermostPixelTopLeft
+
1
innermostPixelTopRight
rect
.
color
)
;
std
:
:
fill
(
innermostPixelBottomLeft
+
1
innermostPixelBottomRight
rect
.
color
)
;
}
}
void
RasterizeAnimatedRoundedRectTopAndBottom
(
const
ColorRect
&
colorRect
const
uint32_t
*
animationLookup
int
priorUpdateAreaMin
int
priorUpdateAreaMax
int
currentUpdateAreaMin
int
currentUpdateAreaMax
int
animationMin
)
{
for
(
int
rowIndex
=
0
;
rowIndex
<
colorRect
.
borderRadius
;
+
+
rowIndex
)
{
int
yTop
=
colorRect
.
y
+
colorRect
.
borderRadius
-
1
-
rowIndex
;
int
yBottom
=
colorRect
.
y
+
colorRect
.
height
-
colorRect
.
borderRadius
+
rowIndex
;
uint32_t
*
lineStartTop
=
&
sPixelBuffer
[
yTop
*
sWindowWidth
]
;
uint32_t
*
lineStartBottom
=
&
sPixelBuffer
[
yBottom
*
sWindowWidth
]
;
double
pixelY
=
(
double
)
rowIndex
+
0
.
5
;
for
(
int
x
=
priorUpdateAreaMin
;
x
<
currentUpdateAreaMax
;
+
+
x
)
{
int
columnIndex
=
std
:
:
max
(
(
int
)
colorRect
.
x
+
(
int
)
colorRect
.
borderRadius
-
x
-
1
x
-
(
(
int
)
colorRect
.
x
+
(
int
)
colorRect
.
width
-
(
int
)
colorRect
.
borderRadius
)
)
;
double
alpha
=
1
.
0
;
if
(
columnIndex
>
=
0
)
{
double
pixelX
=
(
double
)
columnIndex
+
0
.
5
;
double
distance
=
SignedDistanceToCircle
(
pixelX
pixelY
(
double
)
colorRect
.
borderRadius
)
;
alpha
=
DistanceAntiAlias
(
distance
)
;
}
if
(
alpha
>
1
.
0
-
std
:
:
numeric_limits
<
double
>
:
:
epsilon
(
)
)
{
uint32_t
color
=
x
<
priorUpdateAreaMax
?
colorRect
.
color
:
animationLookup
[
x
-
animationMin
]
;
lineStartTop
[
x
]
=
color
;
lineStartBottom
[
x
]
=
color
;
}
}
}
}
void
RasterizeColorRect
(
const
ColorRect
&
colorRect
)
{
Vector
<
DrawRect
2
>
drawRects
;
Unused
<
<
drawRects
.
reserve
(
2
)
;
if
(
colorRect
.
borderWidth
=
=
0
)
{
DrawRect
rect
=
{
}
;
rect
.
color
=
colorRect
.
color
;
rect
.
backgroundColor
=
sPixelBuffer
[
colorRect
.
y
*
sWindowWidth
+
colorRect
.
x
]
;
rect
.
x
=
colorRect
.
x
;
rect
.
y
=
colorRect
.
y
;
rect
.
width
=
colorRect
.
width
;
rect
.
height
=
colorRect
.
height
;
rect
.
borderRadius
=
colorRect
.
borderRadius
;
rect
.
strokeOnly
=
false
;
drawRects
.
infallibleAppend
(
rect
)
;
}
else
{
DrawRect
borderRect
=
{
}
;
borderRect
.
color
=
colorRect
.
borderColor
;
borderRect
.
backgroundColor
=
sPixelBuffer
[
colorRect
.
y
*
sWindowWidth
+
colorRect
.
x
]
;
borderRect
.
x
=
colorRect
.
x
;
borderRect
.
y
=
colorRect
.
y
;
borderRect
.
width
=
colorRect
.
width
;
borderRect
.
height
=
colorRect
.
height
;
borderRect
.
borderRadius
=
colorRect
.
borderRadius
;
borderRect
.
borderWidth
=
colorRect
.
borderWidth
;
borderRect
.
strokeOnly
=
true
;
drawRects
.
infallibleAppend
(
borderRect
)
;
DrawRect
baseRect
=
{
}
;
baseRect
.
color
=
colorRect
.
color
;
baseRect
.
backgroundColor
=
borderRect
.
color
;
baseRect
.
x
=
colorRect
.
x
+
colorRect
.
borderWidth
;
baseRect
.
y
=
colorRect
.
y
+
colorRect
.
borderWidth
;
baseRect
.
width
=
colorRect
.
width
-
2
*
colorRect
.
borderWidth
;
baseRect
.
height
=
colorRect
.
height
-
2
*
colorRect
.
borderWidth
;
baseRect
.
borderRadius
=
std
:
:
max
(
0
(
int
)
colorRect
.
borderRadius
-
(
int
)
colorRect
.
borderWidth
)
;
baseRect
.
borderWidth
=
0
;
baseRect
.
strokeOnly
=
false
;
drawRects
.
infallibleAppend
(
baseRect
)
;
}
for
(
const
DrawRect
&
rect
:
drawRects
)
{
if
(
rect
.
height
<
=
0
|
|
rect
.
width
<
=
0
)
{
continue
;
}
RasterizeRoundedRectTopAndBottom
(
rect
)
;
int
solidRectStartY
=
std
:
:
clamp
(
rect
.
y
+
rect
.
borderRadius
0
sTotalChromeHeight
)
;
int
solidRectEndY
=
std
:
:
clamp
(
rect
.
y
+
rect
.
height
-
rect
.
borderRadius
0
sTotalChromeHeight
)
;
for
(
int
y
=
solidRectStartY
;
y
<
solidRectEndY
;
+
+
y
)
{
if
(
rect
.
strokeOnly
&
&
y
-
rect
.
y
>
rect
.
borderWidth
&
&
rect
.
y
+
rect
.
height
-
y
>
rect
.
borderWidth
)
{
int
startXLeft
=
std
:
:
clamp
(
rect
.
x
0
sWindowWidth
)
;
int
endXLeft
=
std
:
:
clamp
(
rect
.
x
+
rect
.
borderWidth
0
sWindowWidth
)
;
int
startXRight
=
std
:
:
clamp
(
rect
.
x
+
rect
.
width
-
rect
.
borderWidth
0
sWindowWidth
)
;
int
endXRight
=
std
:
:
clamp
(
rect
.
x
+
rect
.
width
0
sWindowWidth
)
;
uint32_t
*
lineStart
=
&
sPixelBuffer
[
y
*
sWindowWidth
]
;
uint32_t
*
dataStartLeft
=
lineStart
+
startXLeft
;
uint32_t
*
dataEndLeft
=
lineStart
+
endXLeft
;
uint32_t
*
dataStartRight
=
lineStart
+
startXRight
;
uint32_t
*
dataEndRight
=
lineStart
+
endXRight
;
std
:
:
fill
(
dataStartLeft
dataEndLeft
rect
.
color
)
;
std
:
:
fill
(
dataStartRight
dataEndRight
rect
.
color
)
;
}
else
{
int
startX
=
std
:
:
clamp
(
rect
.
x
0
sWindowWidth
)
;
int
endX
=
std
:
:
clamp
(
rect
.
x
+
rect
.
width
0
sWindowWidth
)
;
uint32_t
*
lineStart
=
&
sPixelBuffer
[
y
*
sWindowWidth
]
;
uint32_t
*
dataStart
=
lineStart
+
startX
;
uint32_t
*
dataEnd
=
lineStart
+
endX
;
std
:
:
fill
(
dataStart
dataEnd
rect
.
color
)
;
}
}
}
}
bool
RasterizeAnimatedRect
(
const
ColorRect
&
colorRect
const
uint32_t
*
animationLookup
int
priorAnimationMin
int
animationMin
int
animationMax
)
{
int
rectMin
=
colorRect
.
x
;
int
rectMax
=
colorRect
.
x
+
colorRect
.
width
;
bool
animationWindowOverlaps
=
rectMax
>
=
priorAnimationMin
&
&
rectMin
<
animationMax
;
int
priorUpdateAreaMin
=
std
:
:
max
(
rectMin
priorAnimationMin
)
;
int
priorUpdateAreaMax
=
std
:
:
min
(
rectMax
animationMin
)
;
int
currentUpdateAreaMin
=
std
:
:
max
(
rectMin
animationMin
)
;
int
currentUpdateAreaMax
=
std
:
:
min
(
rectMax
animationMax
)
;
if
(
!
animationWindowOverlaps
)
{
return
false
;
}
bool
animationWindowOverlapsBorderRadius
=
rectMin
+
colorRect
.
borderRadius
>
priorAnimationMin
|
|
rectMax
-
colorRect
.
borderRadius
<
=
animationMax
;
int
borderRadius
=
animationWindowOverlapsBorderRadius
?
colorRect
.
borderRadius
:
0
;
if
(
borderRadius
>
0
)
{
RasterizeAnimatedRoundedRectTopAndBottom
(
colorRect
animationLookup
priorUpdateAreaMin
priorUpdateAreaMax
currentUpdateAreaMin
currentUpdateAreaMax
animationMin
)
;
}
for
(
int
y
=
colorRect
.
y
+
borderRadius
;
y
<
colorRect
.
y
+
colorRect
.
height
-
borderRadius
;
+
+
y
)
{
uint32_t
*
lineStart
=
&
sPixelBuffer
[
y
*
sWindowWidth
]
;
for
(
int
x
=
priorUpdateAreaMin
;
x
<
priorUpdateAreaMax
;
+
+
x
)
{
lineStart
[
x
]
=
colorRect
.
color
;
}
for
(
int
x
=
currentUpdateAreaMin
;
x
<
currentUpdateAreaMax
;
+
+
x
)
{
lineStart
[
x
]
=
animationLookup
[
x
-
animationMin
]
;
}
}
return
true
;
}
bool
FillRectWithColor
(
HDC
hdc
LPCRECT
rect
uint32_t
mozColor
)
{
HBRUSH
brush
=
sCreateSolidBrush
(
RGB
(
(
mozColor
&
0xff0000
)
>
>
16
(
mozColor
&
0x00ff00
)
>
>
8
(
mozColor
&
0x0000ff
)
>
>
0
)
)
;
int
fillRectResult
=
sFillRect
(
hdc
rect
brush
)
;
sDeleteObject
(
brush
)
;
return
!
!
fillRectResult
;
}
Result
<
Ok
PreXULSkeletonUIError
>
DrawSkeletonUI
(
HWND
hWnd
CSSPixelSpan
urlbarCSSSpan
CSSPixelSpan
searchbarCSSSpan
Vector
<
CSSPixelSpan
>
&
springs
const
ThemeColors
&
currentTheme
const
EnumSet
<
SkeletonUIFlag
uint32_t
>
&
flags
)
{
sAnimationColor
=
currentTheme
.
animationColor
;
sToolbarForegroundColor
=
currentTheme
.
toolbarForegroundColor
;
bool
menubarShown
=
flags
.
contains
(
SkeletonUIFlag
:
:
MenubarShown
)
;
bool
bookmarksToolbarShown
=
flags
.
contains
(
SkeletonUIFlag
:
:
BookmarksToolbarShown
)
;
bool
rtlEnabled
=
flags
.
contains
(
SkeletonUIFlag
:
:
RtlEnabled
)
;
int
chromeHorMargin
=
CSSToDevPixels
(
2
sCSSToDevPixelScaling
)
;
int
verticalOffset
=
sMaximized
?
sNonClientVerticalMargins
:
0
;
int
horizontalOffset
=
sNonClientHorizontalMargins
-
(
sMaximized
?
0
:
chromeHorMargin
)
;
int
tabBarHeight
=
CSSToDevPixels
(
44
sCSSToDevPixelScaling
)
;
int
selectedTabBorderWidth
=
CSSToDevPixels
(
2
sCSSToDevPixelScaling
)
;
int
titlebarSpacerWidth
=
horizontalOffset
+
CSSToDevPixels
(
2
sCSSToDevPixelScaling
)
-
selectedTabBorderWidth
;
if
(
!
sMaximized
&
&
!
menubarShown
)
{
titlebarSpacerWidth
+
=
CSSToDevPixels
(
40
sCSSToDevPixelScaling
)
;
}
int
selectedTabMarginTop
=
CSSToDevPixels
(
4
sCSSToDevPixelScaling
)
-
selectedTabBorderWidth
;
int
selectedTabMarginBottom
=
CSSToDevPixels
(
4
sCSSToDevPixelScaling
)
-
selectedTabBorderWidth
;
int
selectedTabBorderRadius
=
CSSToDevPixels
(
4
sCSSToDevPixelScaling
)
;
int
selectedTabWidth
=
CSSToDevPixels
(
221
sCSSToDevPixelScaling
)
+
2
*
selectedTabBorderWidth
;
int
toolbarHeight
=
CSSToDevPixels
(
40
sCSSToDevPixelScaling
)
;
int
bookmarkToolbarHeight
=
CSSToDevPixels
(
28
sCSSToDevPixelScaling
)
;
if
(
bookmarksToolbarShown
)
{
toolbarHeight
+
=
bookmarkToolbarHeight
;
}
int
urlbarTopOffset
=
CSSToDevPixels
(
4
sCSSToDevPixelScaling
)
;
int
urlbarHeight
=
CSSToDevPixels
(
32
sCSSToDevPixelScaling
)
;
int
chromeContentDividerHeight
=
CSSToDevPixels
(
1
sCSSToDevPixelScaling
)
;
int
tabPlaceholderBarMarginTop
=
CSSToDevPixels
(
14
sCSSToDevPixelScaling
)
;
int
tabPlaceholderBarMarginLeft
=
CSSToDevPixels
(
10
sCSSToDevPixelScaling
)
;
int
tabPlaceholderBarHeight
=
CSSToDevPixels
(
10
sCSSToDevPixelScaling
)
;
int
tabPlaceholderBarWidth
=
CSSToDevPixels
(
120
sCSSToDevPixelScaling
)
;
int
toolbarPlaceholderHeight
=
CSSToDevPixels
(
10
sCSSToDevPixelScaling
)
;
int
toolbarPlaceholderMarginRight
=
rtlEnabled
?
CSSToDevPixels
(
11
sCSSToDevPixelScaling
)
:
CSSToDevPixels
(
9
sCSSToDevPixelScaling
)
;
int
toolbarPlaceholderMarginLeft
=
rtlEnabled
?
CSSToDevPixels
(
9
sCSSToDevPixelScaling
)
:
CSSToDevPixels
(
11
sCSSToDevPixelScaling
)
;
int
placeholderMargin
=
CSSToDevPixels
(
8
sCSSToDevPixelScaling
)
;
int
menubarHeightDevPixels
=
menubarShown
?
CSSToDevPixels
(
28
sCSSToDevPixelScaling
)
:
0
;
int
urlbarMargin
=
CSSToDevPixels
(
5
sCSSToDevPixelScaling
)
+
horizontalOffset
;
int
urlbarTextPlaceholderMarginTop
=
CSSToDevPixels
(
12
sCSSToDevPixelScaling
)
;
int
urlbarTextPlaceholderMarginLeft
=
CSSToDevPixels
(
12
sCSSToDevPixelScaling
)
;
int
urlbarTextPlaceHolderWidth
=
CSSToDevPixels
(
std
:
:
clamp
(
urlbarCSSSpan
.
end
-
urlbarCSSSpan
.
start
-
10
.
0
0
.
0
260
.
0
)
sCSSToDevPixelScaling
)
;
int
urlbarTextPlaceholderHeight
=
CSSToDevPixels
(
10
sCSSToDevPixelScaling
)
;
int
searchbarTextPlaceholderWidth
=
CSSToDevPixels
(
62
sCSSToDevPixelScaling
)
;
auto
scopeExit
=
MakeScopeExit
(
[
&
]
{
delete
sAnimatedRects
;
sAnimatedRects
=
nullptr
;
}
)
;
Vector
<
ColorRect
>
rects
;
ColorRect
menubar
=
{
}
;
menubar
.
color
=
currentTheme
.
tabBarColor
;
menubar
.
x
=
0
;
menubar
.
y
=
verticalOffset
;
menubar
.
width
=
sWindowWidth
;
menubar
.
height
=
menubarHeightDevPixels
;
menubar
.
flipIfRTL
=
false
;
if
(
!
rects
.
append
(
menubar
)
)
{
return
Err
(
PreXULSkeletonUIError
:
:
OOM
)
;
}
int
placeholderBorderRadius
=
CSSToDevPixels
(
4
sCSSToDevPixelScaling
)
;
int
urlbarBorderRadius
=
CSSToDevPixels
(
4
sCSSToDevPixelScaling
)
;
ColorRect
tabBar
=
{
}
;
tabBar
.
color
=
currentTheme
.
tabBarColor
;
tabBar
.
x
=
0
;
tabBar
.
y
=
menubar
.
y
+
menubar
.
height
;
tabBar
.
width
=
sWindowWidth
;
tabBar
.
height
=
tabBarHeight
;
tabBar
.
flipIfRTL
=
false
;
if
(
!
rects
.
append
(
tabBar
)
)
{
return
Err
(
PreXULSkeletonUIError
:
:
OOM
)
;
}
ColorRect
selectedTab
=
{
}
;
selectedTab
.
color
=
currentTheme
.
tabColor
;
selectedTab
.
x
=
titlebarSpacerWidth
;
selectedTab
.
y
=
menubar
.
y
+
menubar
.
height
+
selectedTabMarginTop
;
selectedTab
.
width
=
selectedTabWidth
;
selectedTab
.
height
=
tabBar
.
y
+
tabBar
.
height
-
selectedTab
.
y
-
selectedTabMarginBottom
;
selectedTab
.
borderColor
=
currentTheme
.
tabOutlineColor
;
selectedTab
.
borderWidth
=
selectedTabBorderWidth
;
selectedTab
.
borderRadius
=
selectedTabBorderRadius
;
selectedTab
.
flipIfRTL
=
true
;
if
(
!
rects
.
append
(
selectedTab
)
)
{
return
Err
(
PreXULSkeletonUIError
:
:
OOM
)
;
}
ColorRect
tabTextPlaceholder
=
{
}
;
tabTextPlaceholder
.
color
=
currentTheme
.
toolbarForegroundColor
;
tabTextPlaceholder
.
x
=
selectedTab
.
x
+
tabPlaceholderBarMarginLeft
;
tabTextPlaceholder
.
y
=
selectedTab
.
y
+
tabPlaceholderBarMarginTop
;
tabTextPlaceholder
.
width
=
tabPlaceholderBarWidth
;
tabTextPlaceholder
.
height
=
tabPlaceholderBarHeight
;
tabTextPlaceholder
.
borderRadius
=
placeholderBorderRadius
;
tabTextPlaceholder
.
flipIfRTL
=
true
;
if
(
!
rects
.
append
(
tabTextPlaceholder
)
)
{
return
Err
(
PreXULSkeletonUIError
:
:
OOM
)
;
}
ColorRect
toolbar
=
{
}
;
toolbar
.
color
=
currentTheme
.
backgroundColor
;
toolbar
.
x
=
0
;
toolbar
.
y
=
tabBar
.
y
+
tabBarHeight
;
toolbar
.
width
=
sWindowWidth
;
toolbar
.
height
=
toolbarHeight
;
toolbar
.
flipIfRTL
=
false
;
if
(
!
rects
.
append
(
toolbar
)
)
{
return
Err
(
PreXULSkeletonUIError
:
:
OOM
)
;
}
ColorRect
chromeContentDivider
=
{
}
;
chromeContentDivider
.
color
=
currentTheme
.
chromeContentDividerColor
;
chromeContentDivider
.
x
=
0
;
chromeContentDivider
.
y
=
toolbar
.
y
+
toolbar
.
height
;
chromeContentDivider
.
width
=
sWindowWidth
;
chromeContentDivider
.
height
=
chromeContentDividerHeight
;
chromeContentDivider
.
flipIfRTL
=
false
;
if
(
!
rects
.
append
(
chromeContentDivider
)
)
{
return
Err
(
PreXULSkeletonUIError
:
:
OOM
)
;
}
ColorRect
urlbar
=
{
}
;
urlbar
.
color
=
currentTheme
.
urlbarColor
;
urlbar
.
x
=
CSSToDevPixels
(
urlbarCSSSpan
.
start
sCSSToDevPixelScaling
)
+
horizontalOffset
;
urlbar
.
y
=
tabBar
.
y
+
tabBarHeight
+
urlbarTopOffset
;
urlbar
.
width
=
CSSToDevPixels
(
(
urlbarCSSSpan
.
end
-
urlbarCSSSpan
.
start
)
sCSSToDevPixelScaling
)
;
urlbar
.
height
=
urlbarHeight
;
urlbar
.
borderColor
=
currentTheme
.
urlbarBorderColor
;
urlbar
.
borderWidth
=
CSSToDevPixels
(
1
sCSSToDevPixelScaling
)
;
urlbar
.
borderRadius
=
urlbarBorderRadius
;
urlbar
.
flipIfRTL
=
false
;
if
(
!
rects
.
append
(
urlbar
)
)
{
return
Err
(
PreXULSkeletonUIError
:
:
OOM
)
;
}
ColorRect
urlbarTextPlaceholder
=
{
}
;
urlbarTextPlaceholder
.
color
=
currentTheme
.
toolbarForegroundColor
;
urlbarTextPlaceholder
.
x
=
rtlEnabled
?
(
(
urlbar
.
x
+
urlbar
.
width
)
-
urlbarTextPlaceholderMarginLeft
-
urlbarTextPlaceHolderWidth
)
:
(
urlbar
.
x
+
urlbarTextPlaceholderMarginLeft
)
;
urlbarTextPlaceholder
.
y
=
urlbar
.
y
+
urlbarTextPlaceholderMarginTop
;
urlbarTextPlaceholder
.
width
=
urlbarTextPlaceHolderWidth
;
urlbarTextPlaceholder
.
height
=
urlbarTextPlaceholderHeight
;
urlbarTextPlaceholder
.
borderRadius
=
placeholderBorderRadius
;
urlbarTextPlaceholder
.
flipIfRTL
=
false
;
if
(
!
rects
.
append
(
urlbarTextPlaceholder
)
)
{
return
Err
(
PreXULSkeletonUIError
:
:
OOM
)
;
}
bool
hasSearchbar
=
searchbarCSSSpan
.
start
!
=
0
&
&
searchbarCSSSpan
.
end
!
=
0
;
ColorRect
searchbarRect
=
{
}
;
if
(
hasSearchbar
=
=
true
)
{
searchbarRect
.
color
=
currentTheme
.
urlbarColor
;
searchbarRect
.
x
=
CSSToDevPixels
(
searchbarCSSSpan
.
start
sCSSToDevPixelScaling
)
+
horizontalOffset
;
searchbarRect
.
y
=
urlbar
.
y
;
searchbarRect
.
width
=
CSSToDevPixels
(
searchbarCSSSpan
.
end
-
searchbarCSSSpan
.
start
sCSSToDevPixelScaling
)
;
searchbarRect
.
height
=
urlbarHeight
;
searchbarRect
.
borderRadius
=
urlbarBorderRadius
;
searchbarRect
.
borderColor
=
currentTheme
.
urlbarBorderColor
;
searchbarRect
.
borderWidth
=
CSSToDevPixels
(
1
sCSSToDevPixelScaling
)
;
searchbarRect
.
flipIfRTL
=
false
;
if
(
!
rects
.
append
(
searchbarRect
)
)
{
return
Err
(
PreXULSkeletonUIError
:
:
OOM
)
;
}
ColorRect
searchbarTextPlaceholder
=
{
}
;
searchbarTextPlaceholder
.
color
=
currentTheme
.
toolbarForegroundColor
;
searchbarTextPlaceholder
.
x
=
rtlEnabled
?
(
(
searchbarRect
.
x
+
searchbarRect
.
width
)
-
urlbarTextPlaceholderMarginLeft
-
searchbarTextPlaceholderWidth
)
:
(
searchbarRect
.
x
+
urlbarTextPlaceholderMarginLeft
)
;
searchbarTextPlaceholder
.
y
=
searchbarRect
.
y
+
urlbarTextPlaceholderMarginTop
;
searchbarTextPlaceholder
.
width
=
searchbarTextPlaceholderWidth
;
searchbarTextPlaceholder
.
height
=
urlbarTextPlaceholderHeight
;
searchbarTextPlaceholder
.
flipIfRTL
=
false
;
if
(
!
rects
.
append
(
searchbarTextPlaceholder
)
|
|
!
sAnimatedRects
-
>
append
(
searchbarTextPlaceholder
)
)
{
return
Err
(
PreXULSkeletonUIError
:
:
OOM
)
;
}
}
Vector
<
DevPixelSpan
>
noPlaceholderSpans
;
DevPixelSpan
urlbarSpan
;
urlbarSpan
.
start
=
urlbar
.
x
-
urlbarMargin
;
urlbarSpan
.
end
=
urlbar
.
width
+
urlbar
.
x
+
urlbarMargin
;
DevPixelSpan
searchbarSpan
;
if
(
hasSearchbar
)
{
searchbarSpan
.
start
=
searchbarRect
.
x
-
urlbarMargin
;
searchbarSpan
.
end
=
searchbarRect
.
width
+
searchbarRect
.
x
+
urlbarMargin
;
}
DevPixelSpan
marginLeftPlaceholder
;
marginLeftPlaceholder
.
start
=
toolbarPlaceholderMarginLeft
;
marginLeftPlaceholder
.
end
=
toolbarPlaceholderMarginLeft
;
if
(
!
noPlaceholderSpans
.
append
(
marginLeftPlaceholder
)
)
{
return
Err
(
PreXULSkeletonUIError
:
:
OOM
)
;
}
if
(
rtlEnabled
)
{
springs
.
reverse
(
)
;
}
for
(
auto
spring
:
springs
)
{
DevPixelSpan
springDevPixels
;
springDevPixels
.
start
=
CSSToDevPixels
(
spring
.
start
sCSSToDevPixelScaling
)
+
horizontalOffset
;
springDevPixels
.
end
=
CSSToDevPixels
(
spring
.
end
sCSSToDevPixelScaling
)
+
horizontalOffset
;
if
(
!
noPlaceholderSpans
.
append
(
springDevPixels
)
)
{
return
Err
(
PreXULSkeletonUIError
:
:
OOM
)
;
}
}
DevPixelSpan
marginRightPlaceholder
;
marginRightPlaceholder
.
start
=
sWindowWidth
-
toolbarPlaceholderMarginRight
;
marginRightPlaceholder
.
end
=
sWindowWidth
-
toolbarPlaceholderMarginRight
;
if
(
!
noPlaceholderSpans
.
append
(
marginRightPlaceholder
)
)
{
return
Err
(
PreXULSkeletonUIError
:
:
OOM
)
;
}
Vector
<
DevPixelSpan
2
>
spansToAdd
;
Unused
<
<
spansToAdd
.
reserve
(
2
)
;
spansToAdd
.
infallibleAppend
(
urlbarSpan
)
;
if
(
hasSearchbar
)
{
spansToAdd
.
infallibleAppend
(
searchbarSpan
)
;
}
for
(
auto
&
toAdd
:
spansToAdd
)
{
for
(
auto
&
span
:
noPlaceholderSpans
)
{
if
(
span
.
start
>
toAdd
.
start
)
{
if
(
!
noPlaceholderSpans
.
insert
(
&
span
toAdd
)
)
{
return
Err
(
PreXULSkeletonUIError
:
:
OOM
)
;
}
break
;
}
}
}
for
(
size_t
i
=
1
;
i
<
noPlaceholderSpans
.
length
(
)
;
i
+
+
)
{
int
start
=
noPlaceholderSpans
[
i
-
1
]
.
end
+
placeholderMargin
;
int
end
=
noPlaceholderSpans
[
i
]
.
start
-
placeholderMargin
;
if
(
start
+
2
*
placeholderBorderRadius
>
=
end
)
{
continue
;
}
ColorRect
placeholderRect
=
{
}
;
placeholderRect
.
color
=
currentTheme
.
toolbarForegroundColor
;
placeholderRect
.
x
=
start
;
placeholderRect
.
y
=
urlbarTextPlaceholder
.
y
;
placeholderRect
.
width
=
end
-
start
;
placeholderRect
.
height
=
toolbarPlaceholderHeight
;
placeholderRect
.
borderRadius
=
placeholderBorderRadius
;
placeholderRect
.
flipIfRTL
=
false
;
if
(
!
rects
.
append
(
placeholderRect
)
|
|
!
sAnimatedRects
-
>
append
(
placeholderRect
)
)
{
return
Err
(
PreXULSkeletonUIError
:
:
OOM
)
;
}
}
sTotalChromeHeight
=
chromeContentDivider
.
y
+
chromeContentDivider
.
height
;
if
(
sTotalChromeHeight
>
sWindowHeight
)
{
return
Err
(
PreXULSkeletonUIError
:
:
BadWindowDimensions
)
;
}
if
(
!
sAnimatedRects
-
>
append
(
tabTextPlaceholder
)
|
|
!
sAnimatedRects
-
>
append
(
urlbarTextPlaceholder
)
)
{
return
Err
(
PreXULSkeletonUIError
:
:
OOM
)
;
}
sPixelBuffer
=
(
uint32_t
*
)
calloc
(
sWindowWidth
*
sTotalChromeHeight
sizeof
(
uint32_t
)
)
;
for
(
auto
&
rect
:
*
sAnimatedRects
)
{
if
(
rtlEnabled
&
&
rect
.
flipIfRTL
)
{
rect
.
x
=
sWindowWidth
-
rect
.
x
-
rect
.
width
;
}
rect
.
x
=
std
:
:
clamp
(
rect
.
x
0
sWindowWidth
)
;
rect
.
width
=
std
:
:
clamp
(
rect
.
width
0
sWindowWidth
-
rect
.
x
)
;
rect
.
y
=
std
:
:
clamp
(
rect
.
y
0
sTotalChromeHeight
)
;
rect
.
height
=
std
:
:
clamp
(
rect
.
height
0
sTotalChromeHeight
-
rect
.
y
)
;
}
for
(
auto
&
rect
:
rects
)
{
if
(
rtlEnabled
&
&
rect
.
flipIfRTL
)
{
rect
.
x
=
sWindowWidth
-
rect
.
x
-
rect
.
width
;
}
rect
.
x
=
std
:
:
clamp
(
rect
.
x
0
sWindowWidth
)
;
rect
.
width
=
std
:
:
clamp
(
rect
.
width
0
sWindowWidth
-
rect
.
x
)
;
rect
.
y
=
std
:
:
clamp
(
rect
.
y
0
sTotalChromeHeight
)
;
rect
.
height
=
std
:
:
clamp
(
rect
.
height
0
sTotalChromeHeight
-
rect
.
y
)
;
RasterizeColorRect
(
rect
)
;
}
HDC
hdc
=
sGetWindowDC
(
hWnd
)
;
if
(
!
hdc
)
{
return
Err
(
PreXULSkeletonUIError
:
:
FailedGettingDC
)
;
}
auto
cleanupDC
=
MakeScopeExit
(
[
=
]
{
sReleaseDC
(
hWnd
hdc
)
;
}
)
;
BITMAPINFO
chromeBMI
=
{
}
;
chromeBMI
.
bmiHeader
.
biSize
=
sizeof
(
chromeBMI
.
bmiHeader
)
;
chromeBMI
.
bmiHeader
.
biWidth
=
sWindowWidth
;
chromeBMI
.
bmiHeader
.
biHeight
=
-
sTotalChromeHeight
;
chromeBMI
.
bmiHeader
.
biPlanes
=
1
;
chromeBMI
.
bmiHeader
.
biBitCount
=
32
;
chromeBMI
.
bmiHeader
.
biCompression
=
BI_RGB
;
int
scanLinesCopied
=
sStretchDIBits
(
hdc
0
0
sWindowWidth
sTotalChromeHeight
0
0
sWindowWidth
sTotalChromeHeight
sPixelBuffer
&
chromeBMI
DIB_RGB_COLORS
SRCCOPY
)
;
if
(
scanLinesCopied
=
=
0
)
{
return
Err
(
PreXULSkeletonUIError
:
:
FailedBlitting
)
;
}
RECT
rect
=
{
0
sTotalChromeHeight
sWindowWidth
sWindowHeight
}
;
bool
const
fillRectOk
=
FillRectWithColor
(
hdc
&
rect
currentTheme
.
backgroundColor
)
;
if
(
!
fillRectOk
)
{
return
Err
(
PreXULSkeletonUIError
:
:
FailedFillingBottomRect
)
;
}
scopeExit
.
release
(
)
;
return
Ok
(
)
;
}
DWORD
WINAPI
AnimateSkeletonUI
(
void
*
aUnused
)
{
if
(
!
sPixelBuffer
|
|
sAnimatedRects
-
>
empty
(
)
)
{
return
0
;
}
if
(
InterlockedIncrement
(
&
sAnimationControlFlag
)
!
=
1
)
{
return
0
;
}
:
:
Sleep
(
2000
)
;
if
(
InterlockedDecrement
(
&
sAnimationControlFlag
)
!
=
0
)
{
return
0
;
}
int
animationWidth
=
CSSToDevPixels
(
80
sCSSToDevPixelScaling
)
;
UniquePtr
<
uint32_t
[
]
>
animationLookup
=
MakeUnique
<
uint32_t
[
]
>
(
animationWidth
)
;
uint32_t
animationColor
=
sAnimationColor
;
NormalizedRGB
rgbBlend
=
UintToRGB
(
animationColor
)
;
for
(
int
i
=
0
;
i
<
animationWidth
/
2
;
+
+
i
)
{
uint32_t
baseColor
=
sToolbarForegroundColor
;
double
blendAmountLinear
=
static_cast
<
double
>
(
i
)
/
(
static_cast
<
double
>
(
animationWidth
/
2
)
)
;
double
blendAmount
=
SmoothStep3
(
blendAmountLinear
)
;
NormalizedRGB
rgbBase
=
UintToRGB
(
baseColor
)
;
NormalizedRGB
rgb
=
Lerp
(
rgbBase
rgbBlend
blendAmount
)
;
animationLookup
[
i
]
=
RGBToUint
(
rgb
)
;
}
for
(
int
i
=
animationWidth
/
2
;
i
<
animationWidth
;
+
+
i
)
{
int
j
=
animationWidth
-
1
-
i
;
if
(
j
=
=
animationWidth
/
2
)
{
animationLookup
[
i
]
=
animationColor
;
}
else
{
animationLookup
[
i
]
=
animationLookup
[
j
]
;
}
}
BITMAPINFO
chromeBMI
=
{
}
;
chromeBMI
.
bmiHeader
.
biSize
=
sizeof
(
chromeBMI
.
bmiHeader
)
;
chromeBMI
.
bmiHeader
.
biWidth
=
sWindowWidth
;
chromeBMI
.
bmiHeader
.
biHeight
=
-
sTotalChromeHeight
;
chromeBMI
.
bmiHeader
.
biPlanes
=
1
;
chromeBMI
.
bmiHeader
.
biBitCount
=
32
;
chromeBMI
.
bmiHeader
.
biCompression
=
BI_RGB
;
uint32_t
animationIteration
=
0
;
int
devPixelsPerFrame
=
CSSToDevPixels
(
kAnimationCSSPixelsPerFrame
sCSSToDevPixelScaling
)
;
int
devPixelsExtraWindowSize
=
CSSToDevPixels
(
kAnimationCSSExtraWindowSize
sCSSToDevPixelScaling
)
;
if
(
:
:
InterlockedCompareExchange
(
&
sAnimationControlFlag
0
0
)
)
{
return
0
;
}
while
(
true
)
{
int
animationMin
=
(
(
animationIteration
*
devPixelsPerFrame
)
%
(
sWindowWidth
+
devPixelsExtraWindowSize
)
)
-
devPixelsExtraWindowSize
/
2
;
int
animationMax
=
animationMin
+
animationWidth
;
int
priorAnimationMin
=
animationMin
-
devPixelsPerFrame
;
animationMin
=
std
:
:
max
(
0
animationMin
)
;
priorAnimationMin
=
std
:
:
max
(
0
priorAnimationMin
)
;
animationMax
=
std
:
:
min
(
(
int
)
sWindowWidth
animationMax
)
;
bool
updatedAnything
=
false
;
for
(
ColorRect
rect
:
*
sAnimatedRects
)
{
bool
hadUpdates
=
RasterizeAnimatedRect
(
rect
animationLookup
.
get
(
)
priorAnimationMin
animationMin
animationMax
)
;
updatedAnything
=
updatedAnything
|
|
hadUpdates
;
}
if
(
updatedAnything
)
{
HDC
hdc
=
sGetWindowDC
(
sPreXULSkeletonUIWindow
)
;
if
(
!
hdc
)
{
return
0
;
}
sStretchDIBits
(
hdc
priorAnimationMin
0
animationMax
-
priorAnimationMin
sTotalChromeHeight
priorAnimationMin
0
animationMax
-
priorAnimationMin
sTotalChromeHeight
sPixelBuffer
&
chromeBMI
DIB_RGB_COLORS
SRCCOPY
)
;
sReleaseDC
(
sPreXULSkeletonUIWindow
hdc
)
;
}
animationIteration
+
+
;
if
(
InterlockedIncrement
(
&
sAnimationControlFlag
)
!
=
1
)
{
return
0
;
}
:
:
Sleep
(
16
)
;
if
(
InterlockedDecrement
(
&
sAnimationControlFlag
)
!
=
0
)
{
return
0
;
}
}
}
LRESULT
WINAPI
PreXULSkeletonUIProc
(
HWND
hWnd
UINT
msg
WPARAM
wParam
LPARAM
lParam
)
{
if
(
msg
=
=
WM_GETOBJECT
&
&
sPreXULSkeletonUIWindow
)
{
return
E_FAIL
;
}
if
(
msg
=
=
WM_NCCREATE
&
&
sEnableNonClientDpiScaling
)
{
sEnableNonClientDpiScaling
(
hWnd
)
;
}
if
(
msg
=
=
WM_NCCALCSIZE
)
{
RECT
*
clientRect
=
wParam
?
&
(
reinterpret_cast
<
NCCALCSIZE_PARAMS
*
>
(
lParam
)
)
-
>
rgrc
[
0
]
:
(
reinterpret_cast
<
RECT
*
>
(
lParam
)
)
;
int
horizontalOffset
=
sNonClientHorizontalMargins
-
(
sMaximized
?
0
:
CSSToDevPixels
(
2
sCSSToDevPixelScaling
)
)
;
int
verticalOffset
=
sNonClientHorizontalMargins
-
(
sMaximized
?
0
:
CSSToDevPixels
(
2
sCSSToDevPixelScaling
)
)
;
clientRect
-
>
top
=
clientRect
-
>
top
;
clientRect
-
>
left
+
=
horizontalOffset
;
clientRect
-
>
right
-
=
horizontalOffset
;
clientRect
-
>
bottom
-
=
verticalOffset
;
return
0
;
}
return
:
:
DefWindowProcW
(
hWnd
msg
wParam
lParam
)
;
}
bool
IsSystemDarkThemeEnabled
(
)
{
DWORD
result
;
HKEY
themeKey
;
DWORD
dataLen
=
sizeof
(
uint32_t
)
;
LPCWSTR
keyName
=
L
"
SOFTWARE
\
\
Microsoft
\
\
Windows
\
\
CurrentVersion
\
\
Themes
\
\
Personalize
"
;
result
=
:
:
RegOpenKeyExW
(
HKEY_CURRENT_USER
keyName
0
KEY_READ
&
themeKey
)
;
if
(
result
!
=
ERROR_SUCCESS
)
{
return
false
;
}
AutoCloseRegKey
closeKey
(
themeKey
)
;
uint32_t
lightThemeEnabled
;
result
=
:
:
RegGetValueW
(
themeKey
nullptr
L
"
AppsUseLightTheme
"
RRF_RT_REG_DWORD
nullptr
reinterpret_cast
<
PBYTE
>
(
&
lightThemeEnabled
)
&
dataLen
)
;
if
(
result
!
=
ERROR_SUCCESS
)
{
return
false
;
}
return
!
lightThemeEnabled
;
}
ThemeColors
GetTheme
(
ThemeMode
themeId
)
{
ThemeColors
theme
=
{
}
;
switch
(
themeId
)
{
case
ThemeMode
:
:
Dark
:
theme
.
backgroundColor
=
0x2b2a33
;
theme
.
tabColor
=
0x42414d
;
theme
.
toolbarForegroundColor
=
0x6a6a6d
;
theme
.
tabOutlineColor
=
0x1c1b22
;
theme
.
tabBarColor
=
0x1c1b22
;
theme
.
chromeContentDividerColor
=
0x0c0c0d
;
theme
.
urlbarColor
=
0x42414d
;
theme
.
urlbarBorderColor
=
0x42414d
;
theme
.
animationColor
=
theme
.
urlbarColor
;
return
theme
;
case
ThemeMode
:
:
Light
:
case
ThemeMode
:
:
Default
:
default
:
theme
.
backgroundColor
=
0xf9f9fb
;
theme
.
tabColor
=
0xf9f9fb
;
theme
.
toolbarForegroundColor
=
0xdddde1
;
theme
.
tabOutlineColor
=
0xdddde1
;
theme
.
tabBarColor
=
0xf0f0f4
;
theme
.
chromeContentDividerColor
=
0xe1e1e2
;
theme
.
urlbarColor
=
0xffffff
;
theme
.
urlbarBorderColor
=
0xdddde1
;
theme
.
animationColor
=
theme
.
backgroundColor
;
return
theme
;
}
}
Result
<
HKEY
PreXULSkeletonUIError
>
OpenPreXULSkeletonUIRegKey
(
)
{
HKEY
key
;
DWORD
disposition
;
LSTATUS
result
=
:
:
RegCreateKeyExW
(
HKEY_CURRENT_USER
kPreXULSkeletonUIKeyPath
0
nullptr
0
KEY_ALL_ACCESS
nullptr
&
key
&
disposition
)
;
if
(
result
!
=
ERROR_SUCCESS
)
{
return
Err
(
PreXULSkeletonUIError
:
:
FailedToOpenRegistryKey
)
;
}
if
(
disposition
=
=
REG_CREATED_NEW_KEY
|
|
disposition
=
=
REG_OPENED_EXISTING_KEY
)
{
return
key
;
}
:
:
RegCloseKey
(
key
)
;
return
Err
(
PreXULSkeletonUIError
:
:
FailedToOpenRegistryKey
)
;
}
Result
<
Ok
PreXULSkeletonUIError
>
LoadGdi32AndUser32Procedures
(
)
{
HMODULE
user32Dll
=
:
:
LoadLibraryW
(
L
"
user32
"
)
;
HMODULE
gdi32Dll
=
:
:
LoadLibraryW
(
L
"
gdi32
"
)
;
HMODULE
dwmapiDll
=
:
:
LoadLibraryW
(
L
"
dwmapi
.
dll
"
)
;
if
(
!
user32Dll
|
|
!
gdi32Dll
|
|
!
dwmapiDll
)
{
return
Err
(
PreXULSkeletonUIError
:
:
FailedLoadingDynamicProcs
)
;
}
#
define
MOZ_LOAD_OR_FAIL
(
dll_handle
name
)
\
do
{
\
s
#
#
name
=
(
decltype
(
&
:
:
name
)
)
:
:
GetProcAddress
(
dll_handle
#
name
)
;
\
if
(
!
s
#
#
name
)
{
\
return
Err
(
PreXULSkeletonUIError
:
:
FailedLoadingDynamicProcs
)
;
\
}
\
}
while
(
0
)
auto
getThreadDpiAwarenessContext
=
(
decltype
(
GetThreadDpiAwarenessContext
)
*
)
:
:
GetProcAddress
(
user32Dll
"
GetThreadDpiAwarenessContext
"
)
;
auto
areDpiAwarenessContextsEqual
=
(
decltype
(
AreDpiAwarenessContextsEqual
)
*
)
:
:
GetProcAddress
(
user32Dll
"
AreDpiAwarenessContextsEqual
"
)
;
if
(
getThreadDpiAwarenessContext
&
&
areDpiAwarenessContextsEqual
&
&
areDpiAwarenessContextsEqual
(
getThreadDpiAwarenessContext
(
)
DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE
)
)
{
Unused
<
<
[
&
]
(
)
-
>
Result
<
Ok
PreXULSkeletonUIError
>
{
MOZ_LOAD_OR_FAIL
(
user32Dll
EnableNonClientDpiScaling
)
;
return
Ok
{
}
;
}
(
)
;
}
MOZ_LOAD_OR_FAIL
(
user32Dll
GetSystemMetricsForDpi
)
;
MOZ_LOAD_OR_FAIL
(
user32Dll
GetDpiForWindow
)
;
MOZ_LOAD_OR_FAIL
(
user32Dll
RegisterClassW
)
;
MOZ_LOAD_OR_FAIL
(
user32Dll
CreateWindowExW
)
;
MOZ_LOAD_OR_FAIL
(
user32Dll
ShowWindow
)
;
MOZ_LOAD_OR_FAIL
(
user32Dll
SetWindowPos
)
;
MOZ_LOAD_OR_FAIL
(
user32Dll
GetWindowDC
)
;
MOZ_LOAD_OR_FAIL
(
user32Dll
GetWindowRect
)
;
MOZ_LOAD_OR_FAIL
(
user32Dll
MapWindowPoints
)
;
MOZ_LOAD_OR_FAIL
(
user32Dll
FillRect
)
;
MOZ_LOAD_OR_FAIL
(
user32Dll
ReleaseDC
)
;
MOZ_LOAD_OR_FAIL
(
user32Dll
LoadIconW
)
;
MOZ_LOAD_OR_FAIL
(
user32Dll
LoadCursorW
)
;
MOZ_LOAD_OR_FAIL
(
user32Dll
MonitorFromWindow
)
;
MOZ_LOAD_OR_FAIL
(
user32Dll
GetMonitorInfoW
)
;
MOZ_LOAD_OR_FAIL
(
user32Dll
SetWindowLongPtrW
)
;
MOZ_LOAD_OR_FAIL
(
gdi32Dll
StretchDIBits
)
;
MOZ_LOAD_OR_FAIL
(
gdi32Dll
CreateSolidBrush
)
;
MOZ_LOAD_OR_FAIL
(
gdi32Dll
DeleteObject
)
;
MOZ_LOAD_OR_FAIL
(
dwmapiDll
DwmGetWindowAttribute
)
;
MOZ_LOAD_OR_FAIL
(
dwmapiDll
DwmSetWindowAttribute
)
;
#
undef
MOZ_LOAD_OR_FAIL
return
Ok
(
)
;
}
const
char
*
NormalizeFlag
(
const
char
*
arg
)
{
if
(
strstr
(
arg
"
-
-
"
)
=
=
arg
)
{
return
arg
+
2
;
}
if
(
arg
[
0
]
=
=
'
-
'
)
{
return
arg
+
1
;
}
if
(
arg
[
0
]
=
=
'
/
'
)
{
return
arg
+
1
;
}
return
nullptr
;
}
static
bool
EnvHasValue
(
const
char
*
name
)
{
const
char
*
val
=
getenv
(
name
)
;
return
(
val
&
&
*
val
)
;
}
static
Result
<
Ok
PreXULSkeletonUIError
>
ValidateCmdlineArguments
(
int
argc
char
*
*
argv
bool
*
explicitProfile
)
{
const
char
*
approvedArgumentsArray
[
]
=
{
"
new
-
instance
"
"
no
-
remote
"
"
browser
"
"
foreground
"
"
setDefaultBrowser
"
"
attach
-
console
"
"
wait
-
for
-
browser
"
"
osint
"
"
new
-
tab
"
"
new
-
window
"
"
marionette
"
"
preferences
"
"
search
"
"
url
"
#
ifndef
MOZILLA_OFFICIAL
"
profile
"
#
endif
}
;
int
approvedArgumentsArraySize
=
sizeof
(
approvedArgumentsArray
)
/
sizeof
(
approvedArgumentsArray
[
0
]
)
;
Vector
<
const
char
*
>
approvedArguments
;
if
(
!
approvedArguments
.
reserve
(
approvedArgumentsArraySize
)
)
{
return
Err
(
PreXULSkeletonUIError
:
:
OOM
)
;
}
for
(
int
i
=
0
;
i
<
approvedArgumentsArraySize
;
+
+
i
)
{
approvedArguments
.
infallibleAppend
(
approvedArgumentsArray
[
i
]
)
;
}
#
ifdef
MOZILLA_OFFICIAL
int
profileArgIndex
=
-
1
;
for
(
int
i
=
1
;
i
<
argc
;
+
+
i
)
{
const
char
*
flag
=
NormalizeFlag
(
argv
[
i
]
)
;
if
(
flag
&
&
!
strcmp
(
flag
"
marionette
"
)
)
{
if
(
!
approvedArguments
.
append
(
"
profile
"
)
)
{
return
Err
(
PreXULSkeletonUIError
:
:
OOM
)
;
}
profileArgIndex
=
approvedArguments
.
length
(
)
-
1
;
break
;
}
}
#
else
int
profileArgIndex
=
approvedArguments
.
length
(
)
-
1
;
#
endif
for
(
int
i
=
1
;
i
<
argc
;
+
+
i
)
{
const
char
*
flag
=
NormalizeFlag
(
argv
[
i
]
)
;
if
(
!
flag
)
{
continue
;
}
bool
approved
=
false
;
for
(
const
char
*
approvedArg
:
approvedArguments
)
{
if
(
!
_stricmp
(
flag
approvedArg
)
)
{
approved
=
true
;
if
(
i
=
=
profileArgIndex
)
{
*
explicitProfile
=
true
;
}
break
;
}
}
if
(
!
approved
)
{
return
Err
(
PreXULSkeletonUIError
:
:
Cmdline
)
;
}
}
return
Ok
(
)
;
}
static
Result
<
Ok
PreXULSkeletonUIError
>
ValidateEnvVars
(
)
{
if
(
EnvHasValue
(
"
MOZ_SAFE_MODE_RESTART
"
)
|
|
EnvHasValue
(
"
MOZ_APP_SILENT_START
"
)
|
|
EnvHasValue
(
"
MOZ_RESET_PROFILE_RESTART
"
)
|
|
EnvHasValue
(
"
MOZ_HEADLESS
"
)
|
|
(
EnvHasValue
(
"
XRE_PROFILE_PATH
"
)
&
&
!
EnvHasValue
(
"
MOZ_SKELETON_UI_RESTARTING
"
)
)
)
{
return
Err
(
PreXULSkeletonUIError
:
:
EnvVars
)
;
}
return
Ok
(
)
;
}
static
bool
VerifyWindowDimensions
(
uint32_t
windowWidth
uint32_t
windowHeight
)
{
return
windowWidth
<
=
kMaxWindowWidth
&
&
windowHeight
<
=
kMaxWindowHeight
;
}
static
Result
<
Vector
<
CSSPixelSpan
>
PreXULSkeletonUIError
>
ReadRegCSSPixelSpans
(
HKEY
regKey
const
std
:
:
wstring
&
valueName
)
{
DWORD
dataLen
=
0
;
LSTATUS
result
=
:
:
RegQueryValueExW
(
regKey
valueName
.
c_str
(
)
nullptr
nullptr
nullptr
&
dataLen
)
;
if
(
result
!
=
ERROR_SUCCESS
)
{
return
Err
(
PreXULSkeletonUIError
:
:
RegistryError
)
;
}
if
(
dataLen
%
(
2
*
sizeof
(
double
)
)
!
=
0
)
{
return
Err
(
PreXULSkeletonUIError
:
:
CorruptData
)
;
}
auto
buffer
=
MakeUniqueFallible
<
wchar_t
[
]
>
(
dataLen
)
;
if
(
!
buffer
)
{
return
Err
(
PreXULSkeletonUIError
:
:
OOM
)
;
}
result
=
:
:
RegGetValueW
(
regKey
nullptr
valueName
.
c_str
(
)
RRF_RT_REG_BINARY
nullptr
reinterpret_cast
<
PBYTE
>
(
buffer
.
get
(
)
)
&
dataLen
)
;
if
(
result
!
=
ERROR_SUCCESS
)
{
return
Err
(
PreXULSkeletonUIError
:
:
RegistryError
)
;
}
Vector
<
CSSPixelSpan
>
resultVector
;
double
*
asDoubles
=
reinterpret_cast
<
double
*
>
(
buffer
.
get
(
)
)
;
for
(
size_t
i
=
0
;
i
<
dataLen
/
(
2
*
sizeof
(
double
)
)
;
i
+
+
)
{
CSSPixelSpan
span
=
{
}
;
span
.
start
=
*
(
asDoubles
+
+
)
;
span
.
end
=
*
(
asDoubles
+
+
)
;
if
(
!
resultVector
.
append
(
span
)
)
{
return
Err
(
PreXULSkeletonUIError
:
:
OOM
)
;
}
}
return
resultVector
;
}
static
Result
<
double
PreXULSkeletonUIError
>
ReadRegDouble
(
HKEY
regKey
const
std
:
:
wstring
&
valueName
)
{
double
value
=
0
;
DWORD
dataLen
=
sizeof
(
double
)
;
LSTATUS
result
=
:
:
RegGetValueW
(
regKey
nullptr
valueName
.
c_str
(
)
RRF_RT_REG_BINARY
nullptr
reinterpret_cast
<
PBYTE
>
(
&
value
)
&
dataLen
)
;
if
(
result
!
=
ERROR_SUCCESS
|
|
dataLen
!
=
sizeof
(
double
)
)
{
return
Err
(
PreXULSkeletonUIError
:
:
RegistryError
)
;
}
return
value
;
}
static
Result
<
uint32_t
PreXULSkeletonUIError
>
ReadRegUint
(
HKEY
regKey
const
std
:
:
wstring
&
valueName
)
{
DWORD
value
=
0
;
DWORD
dataLen
=
sizeof
(
uint32_t
)
;
LSTATUS
result
=
:
:
RegGetValueW
(
regKey
nullptr
valueName
.
c_str
(
)
RRF_RT_REG_DWORD
nullptr
reinterpret_cast
<
PBYTE
>
(
&
value
)
&
dataLen
)
;
if
(
result
!
=
ERROR_SUCCESS
)
{
return
Err
(
PreXULSkeletonUIError
:
:
RegistryError
)
;
}
return
value
;
}
static
Result
<
bool
PreXULSkeletonUIError
>
ReadRegBool
(
HKEY
regKey
const
std
:
:
wstring
&
valueName
)
{
uint32_t
value
;
MOZ_TRY_VAR
(
value
ReadRegUint
(
regKey
valueName
)
)
;
return
!
!
value
;
}
static
Result
<
Ok
PreXULSkeletonUIError
>
WriteRegCSSPixelSpans
(
HKEY
regKey
const
std
:
:
wstring
&
valueName
const
CSSPixelSpan
*
spans
int
spansLength
)
{
auto
doubles
=
MakeUnique
<
double
[
]
>
(
spansLength
*
2
)
;
for
(
int
i
=
0
;
i
<
spansLength
;
+
+
i
)
{
doubles
[
i
*
2
]
=
spans
[
i
]
.
start
;
doubles
[
i
*
2
+
1
]
=
spans
[
i
]
.
end
;
}
LSTATUS
result
=
:
:
RegSetValueExW
(
regKey
valueName
.
c_str
(
)
0
REG_BINARY
reinterpret_cast
<
const
BYTE
*
>
(
doubles
.
get
(
)
)
spansLength
*
sizeof
(
double
)
*
2
)
;
if
(
result
!
=
ERROR_SUCCESS
)
{
return
Err
(
PreXULSkeletonUIError
:
:
RegistryError
)
;
}
return
Ok
(
)
;
}
static
Result
<
Ok
PreXULSkeletonUIError
>
WriteRegDouble
(
HKEY
regKey
const
std
:
:
wstring
&
valueName
double
value
)
{
LSTATUS
result
=
:
:
RegSetValueExW
(
regKey
valueName
.
c_str
(
)
0
REG_BINARY
reinterpret_cast
<
const
BYTE
*
>
(
&
value
)
sizeof
(
value
)
)
;
if
(
result
!
=
ERROR_SUCCESS
)
{
return
Err
(
PreXULSkeletonUIError
:
:
RegistryError
)
;
}
return
Ok
(
)
;
}
static
Result
<
Ok
PreXULSkeletonUIError
>
WriteRegUint
(
HKEY
regKey
const
std
:
:
wstring
&
valueName
uint32_t
value
)
{
LSTATUS
result
=
:
:
RegSetValueExW
(
regKey
valueName
.
c_str
(
)
0
REG_DWORD
reinterpret_cast
<
PBYTE
>
(
&
value
)
sizeof
(
value
)
)
;
if
(
result
!
=
ERROR_SUCCESS
)
{
return
Err
(
PreXULSkeletonUIError
:
:
RegistryError
)
;
}
return
Ok
(
)
;
}
static
Result
<
Ok
PreXULSkeletonUIError
>
WriteRegBool
(
HKEY
regKey
const
std
:
:
wstring
&
valueName
bool
value
)
{
return
WriteRegUint
(
regKey
valueName
value
?
1
:
0
)
;
}
static
Result
<
Ok
PreXULSkeletonUIError
>
CreateAndStorePreXULSkeletonUIImpl
(
HINSTANCE
hInstance
int
argc
char
*
*
argv
)
{
if
(
!
mozilla
:
:
IsEafPlusEnabled
(
)
)
{
CacheNtDllThunk
(
)
;
}
sProcessRuntime
=
new
mscom
:
:
ProcessRuntime
(
mscom
:
:
ProcessRuntime
:
:
ProcessCategory
:
:
GeckoBrowserParent
)
;
const
TimeStamp
skeletonStart
=
TimeStamp
:
:
Now
(
)
;
HKEY
regKey
;
MOZ_TRY_VAR
(
regKey
OpenPreXULSkeletonUIRegKey
(
)
)
;
AutoCloseRegKey
closeKey
(
regKey
)
;
UniquePtr
<
wchar_t
[
]
>
binPath
;
MOZ_TRY_VAR
(
binPath
GetBinaryPath
(
)
)
;
std
:
:
wstring
regProgressName
=
GetRegValueName
(
binPath
.
get
(
)
sProgressSuffix
)
;
auto
progressResult
=
ReadRegUint
(
regKey
regProgressName
)
;
if
(
!
progressResult
.
isErr
(
)
&
&
progressResult
.
unwrap
(
)
!
=
static_cast
<
uint32_t
>
(
PreXULSkeletonUIProgress
:
:
Completed
)
)
{
return
Err
(
PreXULSkeletonUIError
:
:
CrashedOnce
)
;
}
MOZ_TRY
(
WriteRegUint
(
regKey
regProgressName
static_cast
<
uint32_t
>
(
PreXULSkeletonUIProgress
:
:
Started
)
)
)
;
auto
writeCompletion
=
MakeScopeExit
(
[
&
]
{
Unused
<
<
WriteRegUint
(
regKey
regProgressName
static_cast
<
uint32_t
>
(
PreXULSkeletonUIProgress
:
:
Completed
)
)
;
}
)
;
MOZ_TRY
(
GetSkeletonUILock
(
)
)
;
bool
explicitProfile
=
false
;
MOZ_TRY
(
ValidateCmdlineArguments
(
argc
argv
&
explicitProfile
)
)
;
MOZ_TRY
(
ValidateEnvVars
(
)
)
;
auto
enabledResult
=
ReadRegBool
(
regKey
GetRegValueName
(
binPath
.
get
(
)
sEnabledRegSuffix
)
)
;
if
(
enabledResult
.
isErr
(
)
)
{
return
Err
(
PreXULSkeletonUIError
:
:
EnabledKeyDoesNotExist
)
;
}
if
(
!
enabledResult
.
unwrap
(
)
)
{
return
Err
(
PreXULSkeletonUIError
:
:
Disabled
)
;
}
sPreXULSkeletonUIEnabled
=
true
;
MOZ_ASSERT
(
!
sAnimatedRects
)
;
sAnimatedRects
=
new
Vector
<
ColorRect
>
(
)
;
MOZ_TRY
(
LoadGdi32AndUser32Procedures
(
)
)
;
if
(
!
explicitProfile
)
{
MOZ_TRY
(
CheckForStartWithLastProfile
(
)
)
;
}
WNDCLASSW
wc
;
wc
.
style
=
CS_DBLCLKS
;
wc
.
lpfnWndProc
=
PreXULSkeletonUIProc
;
wc
.
cbClsExtra
=
0
;
wc
.
cbWndExtra
=
0
;
wc
.
hInstance
=
hInstance
;
wc
.
hIcon
=
sLoadIconW
(
:
:
GetModuleHandleW
(
nullptr
)
gStockApplicationIcon
)
;
wc
.
hCursor
=
sLoadCursorW
(
hInstance
gIDCWait
)
;
wc
.
hbrBackground
=
nullptr
;
wc
.
lpszMenuName
=
nullptr
;
wc
.
lpszClassName
=
L
"
MozillaWindowClass
"
;
if
(
!
sRegisterClassW
(
&
wc
)
)
{
return
Err
(
PreXULSkeletonUIError
:
:
FailedRegisteringWindowClass
)
;
}
uint32_t
screenX
;
MOZ_TRY_VAR
(
screenX
ReadRegUint
(
regKey
GetRegValueName
(
binPath
.
get
(
)
sScreenXRegSuffix
)
)
)
;
uint32_t
screenY
;
MOZ_TRY_VAR
(
screenY
ReadRegUint
(
regKey
GetRegValueName
(
binPath
.
get
(
)
sScreenYRegSuffix
)
)
)
;
uint32_t
windowWidth
;
MOZ_TRY_VAR
(
windowWidth
ReadRegUint
(
regKey
GetRegValueName
(
binPath
.
get
(
)
sWidthRegSuffix
)
)
)
;
uint32_t
windowHeight
;
MOZ_TRY_VAR
(
windowHeight
ReadRegUint
(
regKey
GetRegValueName
(
binPath
.
get
(
)
sHeightRegSuffix
)
)
)
;
MOZ_TRY_VAR
(
sMaximized
ReadRegBool
(
regKey
GetRegValueName
(
binPath
.
get
(
)
sMaximizedRegSuffix
)
)
)
;
MOZ_TRY_VAR
(
sCSSToDevPixelScaling
ReadRegDouble
(
regKey
GetRegValueName
(
binPath
.
get
(
)
sCssToDevPixelScalingRegSuffix
)
)
)
;
Vector
<
CSSPixelSpan
>
urlbar
;
MOZ_TRY_VAR
(
urlbar
ReadRegCSSPixelSpans
(
regKey
GetRegValueName
(
binPath
.
get
(
)
sUrlbarCSSRegSuffix
)
)
)
;
Vector
<
CSSPixelSpan
>
searchbar
;
MOZ_TRY_VAR
(
searchbar
ReadRegCSSPixelSpans
(
regKey
GetRegValueName
(
binPath
.
get
(
)
sSearchbarRegSuffix
)
)
)
;
Vector
<
CSSPixelSpan
>
springs
;
MOZ_TRY_VAR
(
springs
ReadRegCSSPixelSpans
(
regKey
GetRegValueName
(
binPath
.
get
(
)
sSpringsCSSRegSuffix
)
)
)
;
if
(
urlbar
.
empty
(
)
|
|
searchbar
.
empty
(
)
)
{
return
Err
(
PreXULSkeletonUIError
:
:
CorruptData
)
;
}
EnumSet
<
SkeletonUIFlag
uint32_t
>
flags
;
uint32_t
flagsUint
;
MOZ_TRY_VAR
(
flagsUint
ReadRegUint
(
regKey
GetRegValueName
(
binPath
.
get
(
)
sFlagsRegSuffix
)
)
)
;
flags
.
deserialize
(
flagsUint
)
;
if
(
flags
.
contains
(
SkeletonUIFlag
:
:
TouchDensity
)
|
|
flags
.
contains
(
SkeletonUIFlag
:
:
CompactDensity
)
)
{
return
Err
(
PreXULSkeletonUIError
:
:
BadUIDensity
)
;
}
uint32_t
theme
;
MOZ_TRY_VAR
(
theme
ReadRegUint
(
regKey
GetRegValueName
(
binPath
.
get
(
)
sThemeRegSuffix
)
)
)
;
ThemeMode
themeMode
=
static_cast
<
ThemeMode
>
(
theme
)
;
if
(
themeMode
=
=
ThemeMode
:
:
Default
)
{
if
(
IsSystemDarkThemeEnabled
(
)
=
=
true
)
{
themeMode
=
ThemeMode
:
:
Dark
;
}
}
ThemeColors
currentTheme
=
GetTheme
(
themeMode
)
;
if
(
!
VerifyWindowDimensions
(
windowWidth
windowHeight
)
)
{
return
Err
(
PreXULSkeletonUIError
:
:
BadWindowDimensions
)
;
}
int
showCmd
=
SW_SHOWNORMAL
;
DWORD
windowStyle
=
kPreXULSkeletonUIWindowStyle
;
if
(
sMaximized
)
{
showCmd
=
SW_SHOWMAXIMIZED
;
windowStyle
|
=
WS_MAXIMIZE
;
}
sPreXULSkeletonUIWindow
=
sCreateWindowExW
(
kPreXULSkeletonUIWindowStyleEx
L
"
MozillaWindowClass
"
L
"
"
windowStyle
screenX
screenY
windowWidth
windowHeight
nullptr
nullptr
hInstance
nullptr
)
;
if
(
!
sPreXULSkeletonUIWindow
)
{
return
Err
(
PreXULSkeletonUIError
:
:
CreateWindowFailed
)
;
}
if
(
sDwmGetWindowAttribute
!
=
nullptr
)
{
constexpr
static
auto
const
CloakWindow
=
[
]
(
HWND
hwnd
BOOL
state
)
{
sDwmSetWindowAttribute
(
sPreXULSkeletonUIWindow
DWMWA_CLOAK
&
state
sizeof
(
state
)
)
;
}
;
constexpr
static
auto
const
OffsetRect
=
[
]
(
LPRECT
rect
int
dx
int
dy
)
{
rect
-
>
left
+
=
dx
;
rect
-
>
top
+
=
dy
;
rect
-
>
right
+
=
dx
;
rect
-
>
bottom
+
=
dy
;
}
;
CloakWindow
(
sPreXULSkeletonUIWindow
TRUE
)
;
auto
const
_uncloak
=
MakeScopeExit
(
[
&
]
(
)
{
CloakWindow
(
sPreXULSkeletonUIWindow
FALSE
)
;
}
)
;
sShowWindow
(
sPreXULSkeletonUIWindow
showCmd
)
;
HDC
hdc
=
sGetWindowDC
(
sPreXULSkeletonUIWindow
)
;
if
(
!
hdc
)
{
return
Err
(
PreXULSkeletonUIError
:
:
FailedGettingDC
)
;
}
auto
const
_cleanupDC
=
MakeScopeExit
(
[
&
]
{
sReleaseDC
(
sPreXULSkeletonUIWindow
hdc
)
;
}
)
;
RECT
rect
;
sGetWindowRect
(
sPreXULSkeletonUIWindow
&
rect
)
;
sMapWindowPoints
(
HWND_DESKTOP
sPreXULSkeletonUIWindow
(
LPPOINT
)
&
rect
2
)
;
OffsetRect
(
&
rect
-
rect
.
left
-
rect
.
top
)
;
FillRectWithColor
(
hdc
&
rect
currentTheme
.
backgroundColor
)
;
}
sDpi
=
sGetDpiForWindow
(
sPreXULSkeletonUIWindow
)
;
sNonClientHorizontalMargins
=
sGetSystemMetricsForDpi
(
SM_CXFRAME
sDpi
)
+
sGetSystemMetricsForDpi
(
SM_CXPADDEDBORDER
sDpi
)
;
sNonClientVerticalMargins
=
sGetSystemMetricsForDpi
(
SM_CYFRAME
sDpi
)
+
sGetSystemMetricsForDpi
(
SM_CXPADDEDBORDER
sDpi
)
;
if
(
sMaximized
)
{
HMONITOR
monitor
=
sMonitorFromWindow
(
sPreXULSkeletonUIWindow
MONITOR_DEFAULTTONULL
)
;
if
(
!
monitor
)
{
return
Err
(
PreXULSkeletonUIError
:
:
FailedGettingMonitorInfo
)
;
}
MONITORINFO
mi
=
{
sizeof
(
MONITORINFO
)
}
;
if
(
!
sGetMonitorInfoW
(
monitor
&
mi
)
)
{
return
Err
(
PreXULSkeletonUIError
:
:
FailedGettingMonitorInfo
)
;
}
sWindowWidth
=
mi
.
rcWork
.
right
-
mi
.
rcWork
.
left
+
sNonClientHorizontalMargins
*
2
;
sWindowHeight
=
mi
.
rcWork
.
bottom
-
mi
.
rcWork
.
top
+
sNonClientVerticalMargins
*
2
;
}
else
{
sWindowWidth
=
static_cast
<
int
>
(
windowWidth
)
;
sWindowHeight
=
static_cast
<
int
>
(
windowHeight
)
;
}
sSetWindowPos
(
sPreXULSkeletonUIWindow
0
0
0
0
0
SWP_FRAMECHANGED
|
SWP_NOACTIVATE
|
SWP_NOMOVE
|
SWP_NOOWNERZORDER
|
SWP_NOSIZE
|
SWP_NOZORDER
)
;
MOZ_TRY
(
DrawSkeletonUI
(
sPreXULSkeletonUIWindow
urlbar
[
0
]
searchbar
[
0
]
springs
currentTheme
flags
)
)
;
if
(
sAnimatedRects
)
{
sPreXULSKeletonUIAnimationThread
=
:
:
CreateThread
(
nullptr
256
*
1024
AnimateSkeletonUI
nullptr
0
nullptr
)
;
}
BASE_PROFILER_MARKER_UNTYPED
(
"
CreatePreXULSkeletonUI
"
OTHER
MarkerTiming
:
:
IntervalUntilNowFrom
(
skeletonStart
)
)
;
return
Ok
(
)
;
}
void
CreateAndStorePreXULSkeletonUI
(
HINSTANCE
hInstance
int
argc
char
*
*
argv
)
{
auto
result
=
CreateAndStorePreXULSkeletonUIImpl
(
hInstance
argc
argv
)
;
if
(
result
.
isErr
(
)
)
{
sErrorReason
.
emplace
(
result
.
unwrapErr
(
)
)
;
}
}
void
CleanupProcessRuntime
(
)
{
delete
sProcessRuntime
;
sProcessRuntime
=
nullptr
;
}
bool
WasPreXULSkeletonUIMaximized
(
)
{
return
sMaximized
;
}
bool
GetPreXULSkeletonUIWasShown
(
)
{
return
sPreXULSkeletonUIShown
|
|
!
!
sPreXULSkeletonUIWindow
;
}
HWND
ConsumePreXULSkeletonUIHandle
(
)
{
if
(
InterlockedIncrement
(
&
sAnimationControlFlag
)
=
=
1
)
{
:
:
WaitForSingleObject
(
sPreXULSKeletonUIAnimationThread
INFINITE
)
;
}
:
:
CloseHandle
(
sPreXULSKeletonUIAnimationThread
)
;
sPreXULSKeletonUIAnimationThread
=
nullptr
;
HWND
result
=
sPreXULSkeletonUIWindow
;
sPreXULSkeletonUIWindow
=
nullptr
;
free
(
sPixelBuffer
)
;
sPixelBuffer
=
nullptr
;
delete
sAnimatedRects
;
sAnimatedRects
=
nullptr
;
return
result
;
}
Result
<
Ok
PreXULSkeletonUIError
>
PersistPreXULSkeletonUIValues
(
const
SkeletonUISettings
&
settings
)
{
if
(
!
sPreXULSkeletonUIEnabled
)
{
return
Err
(
PreXULSkeletonUIError
:
:
Disabled
)
;
}
HKEY
regKey
;
MOZ_TRY_VAR
(
regKey
OpenPreXULSkeletonUIRegKey
(
)
)
;
AutoCloseRegKey
closeKey
(
regKey
)
;
UniquePtr
<
wchar_t
[
]
>
binPath
;
MOZ_TRY_VAR
(
binPath
GetBinaryPath
(
)
)
;
MOZ_TRY
(
WriteRegUint
(
regKey
GetRegValueName
(
binPath
.
get
(
)
sScreenXRegSuffix
)
settings
.
screenX
)
)
;
MOZ_TRY
(
WriteRegUint
(
regKey
GetRegValueName
(
binPath
.
get
(
)
sScreenYRegSuffix
)
settings
.
screenY
)
)
;
MOZ_TRY
(
WriteRegUint
(
regKey
GetRegValueName
(
binPath
.
get
(
)
sWidthRegSuffix
)
settings
.
width
)
)
;
MOZ_TRY
(
WriteRegUint
(
regKey
GetRegValueName
(
binPath
.
get
(
)
sHeightRegSuffix
)
settings
.
height
)
)
;
MOZ_TRY
(
WriteRegBool
(
regKey
GetRegValueName
(
binPath
.
get
(
)
sMaximizedRegSuffix
)
settings
.
maximized
)
)
;
EnumSet
<
SkeletonUIFlag
uint32_t
>
flags
;
if
(
settings
.
menubarShown
)
{
flags
+
=
SkeletonUIFlag
:
:
MenubarShown
;
}
if
(
settings
.
bookmarksToolbarShown
)
{
flags
+
=
SkeletonUIFlag
:
:
BookmarksToolbarShown
;
}
if
(
settings
.
rtlEnabled
)
{
flags
+
=
SkeletonUIFlag
:
:
RtlEnabled
;
}
if
(
settings
.
uiDensity
=
=
SkeletonUIDensity
:
:
Touch
)
{
flags
+
=
SkeletonUIFlag
:
:
TouchDensity
;
}
if
(
settings
.
uiDensity
=
=
SkeletonUIDensity
:
:
Compact
)
{
flags
+
=
SkeletonUIFlag
:
:
CompactDensity
;
}
uint32_t
flagsUint
=
flags
.
serialize
(
)
;
MOZ_TRY
(
WriteRegUint
(
regKey
GetRegValueName
(
binPath
.
get
(
)
sFlagsRegSuffix
)
flagsUint
)
)
;
MOZ_TRY
(
WriteRegDouble
(
regKey
GetRegValueName
(
binPath
.
get
(
)
sCssToDevPixelScalingRegSuffix
)
settings
.
cssToDevPixelScaling
)
)
;
MOZ_TRY
(
WriteRegCSSPixelSpans
(
regKey
GetRegValueName
(
binPath
.
get
(
)
sUrlbarCSSRegSuffix
)
&
settings
.
urlbarSpan
1
)
)
;
MOZ_TRY
(
WriteRegCSSPixelSpans
(
regKey
GetRegValueName
(
binPath
.
get
(
)
sSearchbarRegSuffix
)
&
settings
.
searchbarSpan
1
)
)
;
MOZ_TRY
(
WriteRegCSSPixelSpans
(
regKey
GetRegValueName
(
binPath
.
get
(
)
sSpringsCSSRegSuffix
)
settings
.
springs
.
begin
(
)
settings
.
springs
.
length
(
)
)
)
;
return
Ok
(
)
;
}
MFBT_API
bool
GetPreXULSkeletonUIEnabled
(
)
{
return
sPreXULSkeletonUIEnabled
;
}
MFBT_API
Result
<
Ok
PreXULSkeletonUIError
>
SetPreXULSkeletonUIEnabledIfAllowed
(
bool
value
)
{
if
(
PreXULSkeletonUIDisallowed
(
)
)
{
return
Err
(
PreXULSkeletonUIError
:
:
Disabled
)
;
}
HKEY
regKey
;
MOZ_TRY_VAR
(
regKey
OpenPreXULSkeletonUIRegKey
(
)
)
;
AutoCloseRegKey
closeKey
(
regKey
)
;
UniquePtr
<
wchar_t
[
]
>
binPath
;
MOZ_TRY_VAR
(
binPath
GetBinaryPath
(
)
)
;
MOZ_TRY
(
WriteRegBool
(
regKey
GetRegValueName
(
binPath
.
get
(
)
sEnabledRegSuffix
)
value
)
)
;
if
(
!
sPreXULSkeletonUIEnabled
&
&
value
)
{
Unused
<
<
GetSkeletonUILock
(
)
;
}
sPreXULSkeletonUIEnabled
=
value
;
return
Ok
(
)
;
}
MFBT_API
Result
<
Ok
PreXULSkeletonUIError
>
SetPreXULSkeletonUIThemeId
(
ThemeMode
theme
)
{
if
(
theme
=
=
sTheme
)
{
return
Ok
(
)
;
}
sTheme
=
theme
;
auto
invalidateTheme
=
MakeScopeExit
(
[
]
{
sTheme
=
ThemeMode
:
:
Invalid
;
}
)
;
HKEY
regKey
;
MOZ_TRY_VAR
(
regKey
OpenPreXULSkeletonUIRegKey
(
)
)
;
AutoCloseRegKey
closeKey
(
regKey
)
;
UniquePtr
<
wchar_t
[
]
>
binPath
;
MOZ_TRY_VAR
(
binPath
GetBinaryPath
(
)
)
;
MOZ_TRY
(
WriteRegUint
(
regKey
GetRegValueName
(
binPath
.
get
(
)
sThemeRegSuffix
)
static_cast
<
uint32_t
>
(
theme
)
)
)
;
invalidateTheme
.
release
(
)
;
return
Ok
(
)
;
}
MFBT_API
void
PollPreXULSkeletonUIEvents
(
)
{
if
(
sPreXULSkeletonUIEnabled
&
&
sPreXULSkeletonUIWindow
)
{
MSG
outMsg
=
{
}
;
PeekMessageW
(
&
outMsg
sPreXULSkeletonUIWindow
0
0
0
)
;
}
}
Result
<
Ok
PreXULSkeletonUIError
>
NotePreXULSkeletonUIRestarting
(
)
{
if
(
!
sPreXULSkeletonUIEnabled
)
{
return
Err
(
PreXULSkeletonUIError
:
:
Disabled
)
;
}
:
:
SetEnvironmentVariableW
(
L
"
MOZ_SKELETON_UI_RESTARTING
"
L
"
1
"
)
;
if
(
sPreXULSKeletonUILockFile
!
=
INVALID_HANDLE_VALUE
)
{
:
:
CloseHandle
(
sPreXULSKeletonUILockFile
)
;
}
return
Ok
(
)
;
}
}
