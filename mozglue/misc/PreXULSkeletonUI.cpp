#
include
"
PreXULSkeletonUI
.
h
"
#
include
<
algorithm
>
#
include
<
math
.
h
>
#
include
<
limits
.
h
>
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
glue
/
Debug
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
mozilla
/
WindowsDpiAwareness
.
h
"
#
include
"
mozilla
/
WindowsVersion
.
h
"
#
include
"
prthread
.
h
"
namespace
mozilla
{
struct
ColorRect
{
uint32_t
color
;
uint32_t
x
;
uint32_t
y
;
uint32_t
width
;
uint32_t
height
;
}
;
struct
NormalizedRGB
{
double
r
;
double
g
;
double
b
;
}
;
NormalizedRGB
UintToRGB
(
uint32_t
color
)
{
double
r
=
static_cast
<
double
>
(
color
>
>
16
&
0xff
)
/
255
.
0
;
double
g
=
static_cast
<
double
>
(
color
>
>
8
&
0xff
)
/
255
.
0
;
double
b
=
static_cast
<
double
>
(
color
>
>
0
&
0xff
)
/
255
.
0
;
return
NormalizedRGB
{
r
g
b
}
;
}
uint32_t
RGBToUint
(
const
NormalizedRGB
&
rgb
)
{
return
(
static_cast
<
uint32_t
>
(
rgb
.
r
*
255
.
0
)
<
<
16
)
|
(
static_cast
<
uint32_t
>
(
rgb
.
g
*
255
.
0
)
<
<
8
)
|
(
static_cast
<
uint32_t
>
(
rgb
.
b
*
255
.
0
)
<
<
0
)
;
}
double
Lerp
(
double
a
double
b
double
x
)
{
return
a
+
x
*
(
b
-
a
)
;
}
NormalizedRGB
Lerp
(
const
NormalizedRGB
&
a
const
NormalizedRGB
&
b
double
x
)
{
return
NormalizedRGB
{
Lerp
(
a
.
r
b
.
r
x
)
Lerp
(
a
.
g
b
.
g
x
)
Lerp
(
a
.
b
b
.
b
x
)
}
;
}
double
SmoothStep3
(
double
x
)
{
return
x
*
x
*
(
3
.
0
-
2
.
0
*
x
)
;
}
static
const
wchar_t
kPreXULSkeletonUIKeyPath
[
]
=
L
"
SOFTWARE
"
L
"
\
\
"
MOZ_APP_VENDOR
L
"
\
\
"
MOZ_APP_BASENAME
L
"
\
\
PreXULSkeletonUISettings
"
;
static
bool
sPreXULSkeletonUIEnabled
=
false
;
static
HWND
sPreXULSkeletonUIWindow
;
static
LPWSTR
const
gStockApplicationIcon
=
MAKEINTRESOURCEW
(
32512
)
;
static
LPWSTR
const
gIDCWait
=
MAKEINTRESOURCEW
(
32514
)
;
static
HANDLE
sPreXULSKeletonUIAnimationThread
;
static
uint32_t
*
sPixelBuffer
=
nullptr
;
static
Vector
<
ColorRect
>
*
sAnimatedRects
=
nullptr
;
static
int
sTotalChromeHeight
=
0
;
static
volatile
LONG
sAnimationControlFlag
=
0
;
static
uint32_t
sBackgroundColor
;
static
uint32_t
sToolbarForegroundColor
;
typedef
BOOL
(
WINAPI
*
EnableNonClientDpiScalingProc
)
(
HWND
)
;
static
EnableNonClientDpiScalingProc
sEnableNonClientDpiScaling
=
NULL
;
typedef
int
(
WINAPI
*
GetSystemMetricsForDpiProc
)
(
int
UINT
)
;
GetSystemMetricsForDpiProc
sGetSystemMetricsForDpi
=
NULL
;
typedef
UINT
(
WINAPI
*
GetDpiForWindowProc
)
(
HWND
)
;
GetDpiForWindowProc
sGetDpiForWindow
=
NULL
;
typedef
ATOM
(
WINAPI
*
RegisterClassWProc
)
(
const
WNDCLASSW
*
)
;
RegisterClassWProc
sRegisterClassW
=
NULL
;
typedef
HICON
(
WINAPI
*
LoadIconWProc
)
(
HINSTANCE
LPCWSTR
)
;
LoadIconWProc
sLoadIconW
=
NULL
;
typedef
HICON
(
WINAPI
*
LoadCursorWProc
)
(
HINSTANCE
LPCWSTR
)
;
LoadCursorWProc
sLoadCursorW
=
NULL
;
typedef
HWND
(
WINAPI
*
CreateWindowExWProc
)
(
DWORD
LPCWSTR
LPCWSTR
DWORD
int
int
int
int
HWND
HMENU
HINSTANCE
LPVOID
)
;
CreateWindowExWProc
sCreateWindowExW
=
NULL
;
typedef
BOOL
(
WINAPI
*
ShowWindowProc
)
(
HWND
int
)
;
ShowWindowProc
sShowWindow
=
NULL
;
typedef
BOOL
(
WINAPI
*
SetWindowPosProc
)
(
HWND
HWND
int
int
int
int
UINT
)
;
SetWindowPosProc
sSetWindowPos
=
NULL
;
typedef
BOOL
(
WINAPI
*
RedrawWindowProc
)
(
HWND
const
RECT
*
HRGN
UINT
)
;
RedrawWindowProc
sRedrawWindow
=
NULL
;
typedef
HDC
(
WINAPI
*
GetWindowDCProc
)
(
HWND
)
;
GetWindowDCProc
sGetWindowDC
=
NULL
;
typedef
int
(
WINAPI
*
FillRectProc
)
(
HDC
const
RECT
*
HBRUSH
)
;
FillRectProc
sFillRect
=
NULL
;
typedef
BOOL
(
WINAPI
*
DeleteObjectProc
)
(
HGDIOBJ
)
;
DeleteObjectProc
sDeleteObject
=
NULL
;
typedef
int
(
WINAPI
*
ReleaseDCProc
)
(
HWND
HDC
)
;
ReleaseDCProc
sReleaseDC
=
NULL
;
typedef
int
(
WINAPI
*
StretchDIBitsProc
)
(
HDC
int
int
int
int
int
int
int
int
const
VOID
*
const
BITMAPINFO
*
UINT
DWORD
)
;
StretchDIBitsProc
sStretchDIBits
=
NULL
;
typedef
HBRUSH
(
WINAPI
*
CreateSolidBrushProc
)
(
COLORREF
)
;
CreateSolidBrushProc
sCreateSolidBrush
=
NULL
;
static
uint32_t
sWindowWidth
;
static
uint32_t
sWindowHeight
;
static
double
sCSSToDevPixelScaling
;
static
DWORD
sWindowStyle
=
WS_POPUP
;
static
DWORD
sWindowStyleEx
=
WS_EX_WINDOWEDGE
|
WS_EX_TOOLWINDOW
;
static
const
int
kAnimationCSSPixelsPerFrame
=
21
;
static
const
int
kAnimationCSSExtraWindowSize
=
300
;
class
MOZ_RAII
AutoCloseRegKey
{
public
:
explicit
AutoCloseRegKey
(
HKEY
key
)
:
mKey
(
key
)
{
}
~
AutoCloseRegKey
(
)
{
:
:
RegCloseKey
(
mKey
)
;
}
private
:
HKEY
mKey
;
}
;
int
CSSToDevPixels
(
double
cssPixels
double
scaling
)
{
return
floor
(
cssPixels
*
scaling
+
0
.
5
)
;
}
int
CSSToDevPixels
(
int
cssPixels
double
scaling
)
{
return
CSSToDevPixels
(
(
double
)
cssPixels
scaling
)
;
}
void
DrawSkeletonUI
(
HWND
hWnd
double
urlbarHorizontalOffsetCSS
double
urlbarWidthCSS
)
{
sBackgroundColor
=
0xf9f9fa
;
sToolbarForegroundColor
=
0xe5e5e5
;
uint32_t
tabBarColor
=
0x202340
;
uint32_t
chromeContentDividerColor
=
0xe2e1e3
;
uint32_t
tabLineColor
=
0x0a75d3
;
uint32_t
urlbarColor
=
0xffffff
;
int
chromeHorMargin
=
CSSToDevPixels
(
2
sCSSToDevPixelScaling
)
;
int
dpi
=
sGetDpiForWindow
(
hWnd
)
;
int
verticalOffset
=
sGetSystemMetricsForDpi
(
SM_CYBORDER
dpi
)
;
int
nonClientHorMargins
=
sGetSystemMetricsForDpi
(
SM_CXFRAME
dpi
)
+
sGetSystemMetricsForDpi
(
SM_CXPADDEDBORDER
dpi
)
;
int
horizontalOffset
=
nonClientHorMargins
-
chromeHorMargin
;
int
tabBarHeight
=
CSSToDevPixels
(
33
sCSSToDevPixelScaling
)
+
verticalOffset
;
int
titlebarSpacerWidth
=
CSSToDevPixels
(
40
sCSSToDevPixelScaling
)
+
horizontalOffset
;
int
tabLineHeight
=
CSSToDevPixels
(
2
sCSSToDevPixelScaling
)
+
verticalOffset
;
int
selectedTabWidth
=
CSSToDevPixels
(
224
sCSSToDevPixelScaling
)
;
int
toolbarHeight
=
CSSToDevPixels
(
39
sCSSToDevPixelScaling
)
;
int
tabPlaceholderBarMarginTop
=
CSSToDevPixels
(
13
sCSSToDevPixelScaling
)
;
int
tabPlaceholderBarMarginLeft
=
CSSToDevPixels
(
10
sCSSToDevPixelScaling
)
;
int
tabPlaceholderBarHeight
=
CSSToDevPixels
(
8
sCSSToDevPixelScaling
)
;
int
tabPlaceholderBarWidth
=
CSSToDevPixels
(
120
sCSSToDevPixelScaling
)
;
int
toolbarPlaceholderMarginTop
=
CSSToDevPixels
(
16
sCSSToDevPixelScaling
)
;
int
toolbarPlaceholderMarginLeft
=
CSSToDevPixels
(
9
sCSSToDevPixelScaling
)
;
int
toolbarPlaceholderMarginRight
=
CSSToDevPixels
(
11
sCSSToDevPixelScaling
)
;
int
toolbarPlaceholderWidth
=
CSSToDevPixels
(
90
sCSSToDevPixelScaling
)
;
int
toolbarPlaceholderHeight
=
CSSToDevPixels
(
10
sCSSToDevPixelScaling
)
;
int
urlbarTextPlaceholderMarginTop
=
CSSToDevPixels
(
10
sCSSToDevPixelScaling
)
;
int
urlbarTextPlaceholderMarginLeft
=
CSSToDevPixels
(
10
sCSSToDevPixelScaling
)
;
int
urlbarTextPlaceHolderWidth
=
CSSToDevPixels
(
std
:
:
min
(
(
int
)
urlbarWidthCSS
-
10
260
)
sCSSToDevPixelScaling
)
;
int
urlbarTextPlaceholderHeight
=
CSSToDevPixels
(
10
sCSSToDevPixelScaling
)
;
ColorRect
tabBar
=
{
}
;
tabBar
.
color
=
tabBarColor
;
tabBar
.
x
=
0
;
tabBar
.
y
=
0
;
tabBar
.
width
=
sWindowWidth
;
tabBar
.
height
=
tabBarHeight
;
ColorRect
tabLine
=
{
}
;
tabLine
.
color
=
tabLineColor
;
tabLine
.
x
=
titlebarSpacerWidth
;
tabLine
.
y
=
0
;
tabLine
.
width
=
selectedTabWidth
;
tabLine
.
height
=
tabLineHeight
;
ColorRect
selectedTab
=
{
}
;
selectedTab
.
color
=
sBackgroundColor
;
selectedTab
.
x
=
titlebarSpacerWidth
;
selectedTab
.
y
=
tabLineHeight
;
selectedTab
.
width
=
selectedTabWidth
;
selectedTab
.
height
=
tabBarHeight
;
ColorRect
tabTextPlaceholder
=
{
}
;
tabTextPlaceholder
.
color
=
sToolbarForegroundColor
;
tabTextPlaceholder
.
x
=
selectedTab
.
x
+
tabPlaceholderBarMarginLeft
;
tabTextPlaceholder
.
y
=
selectedTab
.
y
+
tabPlaceholderBarMarginTop
;
tabTextPlaceholder
.
width
=
tabPlaceholderBarWidth
;
tabTextPlaceholder
.
height
=
tabPlaceholderBarHeight
;
ColorRect
toolbar
=
{
}
;
toolbar
.
color
=
sBackgroundColor
;
toolbar
.
x
=
0
;
toolbar
.
y
=
tabBarHeight
;
toolbar
.
width
=
sWindowWidth
;
toolbar
.
height
=
toolbarHeight
;
ColorRect
leftToolbarPlaceholder
=
{
}
;
leftToolbarPlaceholder
.
color
=
sToolbarForegroundColor
;
leftToolbarPlaceholder
.
x
=
toolbar
.
x
+
toolbarPlaceholderMarginLeft
+
horizontalOffset
;
leftToolbarPlaceholder
.
y
=
toolbar
.
y
+
toolbarPlaceholderMarginTop
;
leftToolbarPlaceholder
.
width
=
toolbarPlaceholderWidth
;
leftToolbarPlaceholder
.
height
=
toolbarPlaceholderHeight
;
ColorRect
rightToolbarPlaceholder
=
{
}
;
rightToolbarPlaceholder
.
color
=
sToolbarForegroundColor
;
rightToolbarPlaceholder
.
x
=
sWindowWidth
-
horizontalOffset
-
toolbarPlaceholderMarginRight
-
toolbarPlaceholderWidth
;
rightToolbarPlaceholder
.
y
=
toolbar
.
y
+
toolbarPlaceholderMarginTop
;
rightToolbarPlaceholder
.
width
=
toolbarPlaceholderWidth
;
rightToolbarPlaceholder
.
height
=
toolbarPlaceholderHeight
;
ColorRect
chromeContentDivider
=
{
}
;
chromeContentDivider
.
color
=
chromeContentDividerColor
;
chromeContentDivider
.
x
=
0
;
chromeContentDivider
.
y
=
toolbar
.
y
+
toolbar
.
height
;
chromeContentDivider
.
width
=
sWindowWidth
;
chromeContentDivider
.
height
=
1
;
ColorRect
urlbar
=
{
}
;
urlbar
.
color
=
urlbarColor
;
urlbar
.
x
=
CSSToDevPixels
(
urlbarHorizontalOffsetCSS
sCSSToDevPixelScaling
)
+
horizontalOffset
;
urlbar
.
y
=
CSSToDevPixels
(
39
sCSSToDevPixelScaling
)
;
urlbar
.
width
=
CSSToDevPixels
(
urlbarWidthCSS
sCSSToDevPixelScaling
)
;
urlbar
.
height
=
CSSToDevPixels
(
30
sCSSToDevPixelScaling
)
;
ColorRect
urlbarTextPlaceholder
=
{
}
;
urlbarTextPlaceholder
.
color
=
sToolbarForegroundColor
;
urlbarTextPlaceholder
.
x
=
urlbar
.
x
+
urlbarTextPlaceholderMarginLeft
;
urlbarTextPlaceholder
.
y
=
urlbar
.
y
+
urlbarTextPlaceholderMarginTop
;
urlbarTextPlaceholder
.
width
=
urlbarTextPlaceHolderWidth
;
urlbarTextPlaceholder
.
height
=
urlbarTextPlaceholderHeight
;
ColorRect
rects
[
]
=
{
tabBar
tabLine
selectedTab
tabTextPlaceholder
toolbar
leftToolbarPlaceholder
rightToolbarPlaceholder
chromeContentDivider
urlbar
urlbarTextPlaceholder
}
;
if
(
!
sAnimatedRects
-
>
append
(
tabTextPlaceholder
)
|
|
!
sAnimatedRects
-
>
append
(
leftToolbarPlaceholder
)
|
|
!
sAnimatedRects
-
>
append
(
rightToolbarPlaceholder
)
|
|
!
sAnimatedRects
-
>
append
(
urlbarTextPlaceholder
)
)
{
delete
sAnimatedRects
;
sAnimatedRects
=
nullptr
;
return
;
}
sTotalChromeHeight
=
chromeContentDivider
.
y
+
chromeContentDivider
.
height
;
sPixelBuffer
=
(
uint32_t
*
)
calloc
(
sWindowWidth
*
sTotalChromeHeight
sizeof
(
uint32_t
)
)
;
for
(
int
i
=
0
;
i
<
sizeof
(
rects
)
/
sizeof
(
rects
[
0
]
)
;
+
+
i
)
{
ColorRect
rect
=
rects
[
i
]
;
for
(
int
y
=
rect
.
y
;
y
<
rect
.
y
+
rect
.
height
;
+
+
y
)
{
uint32_t
*
lineStart
=
&
sPixelBuffer
[
y
*
sWindowWidth
]
;
uint32_t
*
dataStart
=
lineStart
+
rect
.
x
;
std
:
:
fill_n
(
dataStart
rect
.
width
rect
.
color
)
;
}
}
HDC
hdc
=
sGetWindowDC
(
hWnd
)
;
BITMAPINFO
chromeBMI
=
{
}
;
chromeBMI
.
bmiHeader
.
biSize
=
sizeof
(
chromeBMI
.
bmiHeader
)
;
chromeBMI
.
bmiHeader
.
biWidth
=
sWindowWidth
;
chromeBMI
.
bmiHeader
.
biHeight
=
-
sTotalChromeHeight
;
chromeBMI
.
bmiHeader
.
biPlanes
=
1
;
chromeBMI
.
bmiHeader
.
biBitCount
=
32
;
chromeBMI
.
bmiHeader
.
biCompression
=
BI_RGB
;
sStretchDIBits
(
hdc
0
0
sWindowWidth
sTotalChromeHeight
0
0
sWindowWidth
sTotalChromeHeight
sPixelBuffer
&
chromeBMI
DIB_RGB_COLORS
SRCCOPY
)
;
RECT
rect
=
{
0
sTotalChromeHeight
(
LONG
)
sWindowWidth
(
LONG
)
sWindowHeight
}
;
HBRUSH
brush
=
sCreateSolidBrush
(
sBackgroundColor
)
;
sFillRect
(
hdc
&
rect
brush
)
;
sReleaseDC
(
hWnd
hdc
)
;
sDeleteObject
(
brush
)
;
}
DWORD
WINAPI
AnimateSkeletonUI
(
void
*
aUnused
)
{
if
(
!
sPixelBuffer
|
|
sAnimatedRects
-
>
empty
(
)
)
{
return
0
;
}
int
animationWidth
=
CSSToDevPixels
(
80
sCSSToDevPixelScaling
)
;
UniquePtr
<
uint32_t
[
]
>
animationLookup
=
MakeUnique
<
uint32_t
[
]
>
(
animationWidth
)
;
uint32_t
animationColor
=
sBackgroundColor
;
NormalizedRGB
rgbBlend
=
UintToRGB
(
animationColor
)
;
for
(
int
i
=
0
;
i
<
animationWidth
/
2
;
+
+
i
)
{
uint32_t
baseColor
=
sToolbarForegroundColor
;
double
blendAmountLinear
=
static_cast
<
double
>
(
i
)
/
(
static_cast
<
double
>
(
animationWidth
/
2
)
)
;
double
blendAmount
=
SmoothStep3
(
blendAmountLinear
)
;
NormalizedRGB
rgbBase
=
UintToRGB
(
baseColor
)
;
NormalizedRGB
rgb
=
Lerp
(
rgbBase
rgbBlend
blendAmount
)
;
animationLookup
[
i
]
=
RGBToUint
(
rgb
)
;
}
for
(
int
i
=
animationWidth
/
2
;
i
<
animationWidth
;
+
+
i
)
{
int
j
=
animationWidth
-
1
-
i
;
if
(
j
=
=
animationWidth
/
2
)
{
animationLookup
[
i
]
=
animationColor
;
}
else
{
animationLookup
[
i
]
=
animationLookup
[
j
]
;
}
}
BITMAPINFO
chromeBMI
=
{
}
;
chromeBMI
.
bmiHeader
.
biSize
=
sizeof
(
chromeBMI
.
bmiHeader
)
;
chromeBMI
.
bmiHeader
.
biWidth
=
sWindowWidth
;
chromeBMI
.
bmiHeader
.
biHeight
=
-
sTotalChromeHeight
;
chromeBMI
.
bmiHeader
.
biPlanes
=
1
;
chromeBMI
.
bmiHeader
.
biBitCount
=
32
;
chromeBMI
.
bmiHeader
.
biCompression
=
BI_RGB
;
uint32_t
animationIteration
=
0
;
int
devPixelsPerFrame
=
CSSToDevPixels
(
kAnimationCSSPixelsPerFrame
sCSSToDevPixelScaling
)
;
int
devPixelsExtraWindowSize
=
CSSToDevPixels
(
kAnimationCSSExtraWindowSize
sCSSToDevPixelScaling
)
;
if
(
:
:
InterlockedCompareExchange
(
&
sAnimationControlFlag
0
0
)
)
{
return
0
;
}
while
(
true
)
{
int
animationMin
=
(
(
animationIteration
*
devPixelsPerFrame
)
%
(
sWindowWidth
+
devPixelsExtraWindowSize
)
)
-
devPixelsExtraWindowSize
/
2
;
int
animationMax
=
animationMin
+
animationWidth
;
int
priorAnimationMin
=
animationMin
-
devPixelsPerFrame
;
animationMin
=
std
:
:
max
(
0
animationMin
)
;
priorAnimationMin
=
std
:
:
max
(
0
priorAnimationMin
)
;
animationMax
=
std
:
:
min
(
(
int
)
sWindowWidth
animationMax
)
;
bool
updatedAnything
=
false
;
for
(
ColorRect
rect
:
*
sAnimatedRects
)
{
int
rectMin
=
rect
.
x
;
int
rectMax
=
rect
.
x
+
rect
.
width
;
bool
animationWindowOverlaps
=
rectMax
>
=
priorAnimationMin
&
&
rectMin
<
animationMax
;
int
priorUpdateAreaMin
=
std
:
:
max
(
rectMin
priorAnimationMin
)
;
int
currentUpdateAreaMin
=
std
:
:
max
(
rectMin
animationMin
)
;
int
priorUpdateAreaMax
=
std
:
:
min
(
rectMax
animationMin
)
;
int
currentUpdateAreaMax
=
std
:
:
min
(
rectMax
animationMax
)
;
if
(
animationWindowOverlaps
)
{
updatedAnything
=
true
;
for
(
int
y
=
rect
.
y
;
y
<
rect
.
y
+
rect
.
height
;
+
+
y
)
{
uint32_t
*
lineStart
=
&
sPixelBuffer
[
y
*
sWindowWidth
]
;
for
(
int
x
=
priorUpdateAreaMin
;
x
<
priorUpdateAreaMax
;
+
+
x
)
{
lineStart
[
x
]
=
rect
.
color
;
}
for
(
int
x
=
currentUpdateAreaMin
;
x
<
currentUpdateAreaMax
;
+
+
x
)
{
lineStart
[
x
]
=
animationLookup
[
x
-
animationMin
]
;
}
}
}
}
if
(
updatedAnything
)
{
HDC
hdc
=
sGetWindowDC
(
sPreXULSkeletonUIWindow
)
;
sStretchDIBits
(
hdc
priorAnimationMin
0
animationMax
-
priorAnimationMin
sTotalChromeHeight
priorAnimationMin
0
animationMax
-
priorAnimationMin
sTotalChromeHeight
sPixelBuffer
&
chromeBMI
DIB_RGB_COLORS
SRCCOPY
)
;
sReleaseDC
(
sPreXULSkeletonUIWindow
hdc
)
;
}
animationIteration
+
+
;
if
(
InterlockedIncrement
(
&
sAnimationControlFlag
)
!
=
1
)
{
return
0
;
}
:
:
Sleep
(
16
)
;
if
(
InterlockedDecrement
(
&
sAnimationControlFlag
)
!
=
0
)
{
return
0
;
}
}
return
0
;
}
LRESULT
WINAPI
PreXULSkeletonUIProc
(
HWND
hWnd
UINT
msg
WPARAM
wParam
LPARAM
lParam
)
{
if
(
msg
=
=
WM_NCCREATE
&
&
sEnableNonClientDpiScaling
)
{
sEnableNonClientDpiScaling
(
hWnd
)
;
}
return
:
:
DefWindowProcW
(
hWnd
msg
wParam
lParam
)
;
}
bool
OpenPreXULSkeletonUIRegKey
(
HKEY
&
key
)
{
DWORD
disposition
;
LSTATUS
result
=
:
:
RegCreateKeyExW
(
HKEY_CURRENT_USER
kPreXULSkeletonUIKeyPath
0
nullptr
0
KEY_ALL_ACCESS
nullptr
&
key
&
disposition
)
;
if
(
result
!
=
ERROR_SUCCESS
)
{
return
false
;
}
if
(
disposition
=
=
REG_CREATED_NEW_KEY
)
{
return
false
;
}
if
(
disposition
=
=
REG_OPENED_EXISTING_KEY
)
{
return
true
;
}
:
:
RegCloseKey
(
key
)
;
return
false
;
}
bool
LoadGdi32AndUser32Procedures
(
)
{
HMODULE
user32Dll
=
:
:
LoadLibraryW
(
L
"
user32
"
)
;
HMODULE
gdi32Dll
=
:
:
LoadLibraryW
(
L
"
gdi32
"
)
;
if
(
!
user32Dll
|
|
!
gdi32Dll
)
{
return
false
;
}
auto
getThreadDpiAwarenessContext
=
(
decltype
(
GetThreadDpiAwarenessContext
)
*
)
:
:
GetProcAddress
(
user32Dll
"
GetThreadDpiAwarenessContext
"
)
;
auto
areDpiAwarenessContextsEqual
=
(
decltype
(
AreDpiAwarenessContextsEqual
)
*
)
:
:
GetProcAddress
(
user32Dll
"
AreDpiAwarenessContextsEqual
"
)
;
if
(
getThreadDpiAwarenessContext
&
&
areDpiAwarenessContextsEqual
&
&
areDpiAwarenessContextsEqual
(
getThreadDpiAwarenessContext
(
)
DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE
)
)
{
sEnableNonClientDpiScaling
=
(
EnableNonClientDpiScalingProc
)
:
:
GetProcAddress
(
user32Dll
"
EnableNonClientDpiScaling
"
)
;
}
sGetSystemMetricsForDpi
=
(
GetSystemMetricsForDpiProc
)
:
:
GetProcAddress
(
user32Dll
"
GetSystemMetricsForDpi
"
)
;
if
(
!
sGetSystemMetricsForDpi
)
{
return
false
;
}
sGetDpiForWindow
=
(
GetDpiForWindowProc
)
:
:
GetProcAddress
(
user32Dll
"
GetDpiForWindow
"
)
;
if
(
!
sGetDpiForWindow
)
{
return
false
;
}
sRegisterClassW
=
(
RegisterClassWProc
)
:
:
GetProcAddress
(
user32Dll
"
RegisterClassW
"
)
;
if
(
!
sRegisterClassW
)
{
return
false
;
}
sCreateWindowExW
=
(
CreateWindowExWProc
)
:
:
GetProcAddress
(
user32Dll
"
CreateWindowExW
"
)
;
if
(
!
sCreateWindowExW
)
{
return
false
;
}
sShowWindow
=
(
ShowWindowProc
)
:
:
GetProcAddress
(
user32Dll
"
ShowWindow
"
)
;
if
(
!
sShowWindow
)
{
return
false
;
}
sSetWindowPos
=
(
SetWindowPosProc
)
:
:
GetProcAddress
(
user32Dll
"
SetWindowPos
"
)
;
if
(
!
sSetWindowPos
)
{
return
false
;
}
sRedrawWindow
=
(
RedrawWindowProc
)
:
:
GetProcAddress
(
user32Dll
"
RedrawWindow
"
)
;
if
(
!
sRedrawWindow
)
{
return
false
;
}
sGetWindowDC
=
(
GetWindowDCProc
)
:
:
GetProcAddress
(
user32Dll
"
GetWindowDC
"
)
;
if
(
!
sGetWindowDC
)
{
return
false
;
}
sFillRect
=
(
FillRectProc
)
:
:
GetProcAddress
(
user32Dll
"
FillRect
"
)
;
if
(
!
sFillRect
)
{
return
false
;
}
sReleaseDC
=
(
ReleaseDCProc
)
:
:
GetProcAddress
(
user32Dll
"
ReleaseDC
"
)
;
if
(
!
sReleaseDC
)
{
return
false
;
}
sLoadIconW
=
(
LoadIconWProc
)
:
:
GetProcAddress
(
user32Dll
"
LoadIconW
"
)
;
if
(
!
sLoadIconW
)
{
return
false
;
}
sLoadCursorW
=
(
LoadCursorWProc
)
:
:
GetProcAddress
(
user32Dll
"
LoadCursorW
"
)
;
if
(
!
sLoadCursorW
)
{
return
false
;
}
sStretchDIBits
=
(
StretchDIBitsProc
)
:
:
GetProcAddress
(
gdi32Dll
"
StretchDIBits
"
)
;
if
(
!
sStretchDIBits
)
{
return
false
;
}
sCreateSolidBrush
=
(
CreateSolidBrushProc
)
:
:
GetProcAddress
(
gdi32Dll
"
CreateSolidBrush
"
)
;
if
(
!
sCreateSolidBrush
)
{
return
false
;
}
sDeleteObject
=
(
DeleteObjectProc
)
:
:
GetProcAddress
(
gdi32Dll
"
DeleteObject
"
)
;
if
(
!
sDeleteObject
)
{
return
false
;
}
return
true
;
}
void
CreateAndStorePreXULSkeletonUI
(
HINSTANCE
hInstance
)
{
HKEY
regKey
;
if
(
!
IsWin10OrLater
(
)
|
|
!
OpenPreXULSkeletonUIRegKey
(
regKey
)
)
{
return
;
}
AutoCloseRegKey
closeKey
(
regKey
)
;
DWORD
dataLen
=
sizeof
(
uint32_t
)
;
uint32_t
enabled
;
LSTATUS
result
=
:
:
RegGetValueW
(
regKey
nullptr
L
"
enabled
"
RRF_RT_REG_DWORD
nullptr
reinterpret_cast
<
PBYTE
>
(
&
enabled
)
&
dataLen
)
;
if
(
result
!
=
ERROR_SUCCESS
|
|
enabled
=
=
0
)
{
return
;
}
sPreXULSkeletonUIEnabled
=
true
;
MOZ_ASSERT
(
!
sAnimatedRects
)
;
sAnimatedRects
=
new
Vector
<
ColorRect
>
(
)
;
if
(
!
LoadGdi32AndUser32Procedures
(
)
)
{
return
;
}
WNDCLASSW
wc
;
wc
.
style
=
CS_DBLCLKS
;
wc
.
lpfnWndProc
=
PreXULSkeletonUIProc
;
wc
.
cbClsExtra
=
0
;
wc
.
cbWndExtra
=
0
;
wc
.
hInstance
=
hInstance
;
wc
.
hIcon
=
sLoadIconW
(
:
:
GetModuleHandleW
(
nullptr
)
gStockApplicationIcon
)
;
wc
.
hCursor
=
sLoadCursorW
(
hInstance
gIDCWait
)
;
wc
.
hbrBackground
=
nullptr
;
wc
.
lpszMenuName
=
nullptr
;
wc
.
lpszClassName
=
L
"
MozillaWindowClass
"
;
if
(
!
sRegisterClassW
(
&
wc
)
)
{
printf_stderr
(
"
RegisterClassW
error
%
lu
\
n
"
GetLastError
(
)
)
;
return
;
}
uint32_t
screenX
;
result
=
:
:
RegGetValueW
(
regKey
nullptr
L
"
screenX
"
RRF_RT_REG_DWORD
nullptr
reinterpret_cast
<
PBYTE
>
(
&
screenX
)
&
dataLen
)
;
if
(
result
!
=
ERROR_SUCCESS
)
{
printf_stderr
(
"
Error
reading
screenX
%
lu
\
n
"
GetLastError
(
)
)
;
return
;
}
uint32_t
screenY
;
result
=
:
:
RegGetValueW
(
regKey
nullptr
L
"
screenY
"
RRF_RT_REG_DWORD
nullptr
reinterpret_cast
<
PBYTE
>
(
&
screenY
)
&
dataLen
)
;
if
(
result
!
=
ERROR_SUCCESS
)
{
printf_stderr
(
"
Error
reading
screenY
%
lu
\
n
"
GetLastError
(
)
)
;
return
;
}
result
=
:
:
RegGetValueW
(
regKey
nullptr
L
"
width
"
RRF_RT_REG_DWORD
nullptr
reinterpret_cast
<
PBYTE
>
(
&
sWindowWidth
)
&
dataLen
)
;
if
(
result
!
=
ERROR_SUCCESS
)
{
printf_stderr
(
"
Error
reading
width
%
lu
\
n
"
GetLastError
(
)
)
;
return
;
}
result
=
:
:
RegGetValueW
(
regKey
nullptr
L
"
height
"
RRF_RT_REG_DWORD
nullptr
reinterpret_cast
<
PBYTE
>
(
&
sWindowHeight
)
&
dataLen
)
;
if
(
result
!
=
ERROR_SUCCESS
)
{
printf_stderr
(
"
Error
reading
height
%
lu
\
n
"
GetLastError
(
)
)
;
return
;
}
dataLen
=
sizeof
(
double
)
;
double
urlbarHorizontalOffsetCSS
;
result
=
:
:
RegGetValueW
(
regKey
nullptr
L
"
urlbarHorizontalOffsetCSS
"
RRF_RT_REG_BINARY
nullptr
reinterpret_cast
<
PBYTE
>
(
&
urlbarHorizontalOffsetCSS
)
&
dataLen
)
;
if
(
result
!
=
ERROR_SUCCESS
|
|
dataLen
!
=
sizeof
(
double
)
)
{
printf_stderr
(
"
Error
reading
urlbarHorizontalOffsetCSS
%
lu
\
n
"
GetLastError
(
)
)
;
return
;
}
double
urlbarWidthCSS
;
result
=
:
:
RegGetValueW
(
regKey
nullptr
L
"
urlbarWidthCSS
"
RRF_RT_REG_BINARY
nullptr
reinterpret_cast
<
PBYTE
>
(
&
urlbarWidthCSS
)
&
dataLen
)
;
if
(
result
!
=
ERROR_SUCCESS
|
|
dataLen
!
=
sizeof
(
double
)
)
{
printf_stderr
(
"
Error
reading
urlbarWidthCSS
%
lu
\
n
"
GetLastError
(
)
)
;
return
;
}
result
=
:
:
RegGetValueW
(
regKey
nullptr
L
"
cssToDevPixelScaling
"
RRF_RT_REG_BINARY
nullptr
reinterpret_cast
<
PBYTE
>
(
&
sCSSToDevPixelScaling
)
&
dataLen
)
;
if
(
result
!
=
ERROR_SUCCESS
|
|
dataLen
!
=
sizeof
(
double
)
)
{
printf_stderr
(
"
Error
reading
cssToDevPixelScaling
%
lu
\
n
"
GetLastError
(
)
)
;
return
;
}
sPreXULSkeletonUIWindow
=
sCreateWindowExW
(
sWindowStyleEx
L
"
MozillaWindowClass
"
L
"
"
sWindowStyle
screenX
screenY
sWindowWidth
sWindowHeight
nullptr
nullptr
hInstance
nullptr
)
;
sShowWindow
(
sPreXULSkeletonUIWindow
SW_SHOWNORMAL
)
;
sSetWindowPos
(
sPreXULSkeletonUIWindow
0
0
0
0
0
SWP_FRAMECHANGED
|
SWP_NOACTIVATE
|
SWP_NOMOVE
|
SWP_NOOWNERZORDER
|
SWP_NOSIZE
|
SWP_NOZORDER
)
;
DrawSkeletonUI
(
sPreXULSkeletonUIWindow
urlbarHorizontalOffsetCSS
urlbarWidthCSS
)
;
sRedrawWindow
(
sPreXULSkeletonUIWindow
NULL
NULL
RDW_INVALIDATE
)
;
if
(
sAnimatedRects
)
{
sPreXULSKeletonUIAnimationThread
=
:
:
CreateThread
(
nullptr
256
*
1024
AnimateSkeletonUI
nullptr
0
nullptr
)
;
}
}
HWND
ConsumePreXULSkeletonUIHandle
(
)
{
if
(
InterlockedIncrement
(
&
sAnimationControlFlag
)
=
=
1
)
{
:
:
WaitForSingleObject
(
sPreXULSKeletonUIAnimationThread
INFINITE
)
;
}
:
:
CloseHandle
(
sPreXULSKeletonUIAnimationThread
)
;
sPreXULSKeletonUIAnimationThread
=
nullptr
;
HWND
result
=
sPreXULSkeletonUIWindow
;
sPreXULSkeletonUIWindow
=
nullptr
;
free
(
sPixelBuffer
)
;
sPixelBuffer
=
nullptr
;
delete
sAnimatedRects
;
sAnimatedRects
=
nullptr
;
return
result
;
}
void
PersistPreXULSkeletonUIValues
(
int
screenX
int
screenY
int
width
int
height
double
urlbarHorizontalOffsetCSS
double
urlbarWidthCSS
double
cssToDevPixelScaling
)
{
if
(
!
sPreXULSkeletonUIEnabled
)
{
return
;
}
HKEY
regKey
;
if
(
!
OpenPreXULSkeletonUIRegKey
(
regKey
)
)
{
return
;
}
AutoCloseRegKey
closeKey
(
regKey
)
;
LSTATUS
result
;
result
=
:
:
RegSetValueExW
(
regKey
L
"
screenX
"
0
REG_DWORD
reinterpret_cast
<
PBYTE
>
(
&
screenX
)
sizeof
(
screenX
)
)
;
if
(
result
!
=
ERROR_SUCCESS
)
{
printf_stderr
(
"
Failed
persisting
screenX
to
Windows
registry
\
n
"
)
;
return
;
}
result
=
:
:
RegSetValueExW
(
regKey
L
"
screenY
"
0
REG_DWORD
reinterpret_cast
<
PBYTE
>
(
&
screenY
)
sizeof
(
screenY
)
)
;
if
(
result
!
=
ERROR_SUCCESS
)
{
printf_stderr
(
"
Failed
persisting
screenY
to
Windows
registry
\
n
"
)
;
return
;
}
result
=
:
:
RegSetValueExW
(
regKey
L
"
width
"
0
REG_DWORD
reinterpret_cast
<
PBYTE
>
(
&
width
)
sizeof
(
width
)
)
;
if
(
result
!
=
ERROR_SUCCESS
)
{
printf_stderr
(
"
Failed
persisting
width
to
Windows
registry
\
n
"
)
;
return
;
}
result
=
:
:
RegSetValueExW
(
regKey
L
"
height
"
0
REG_DWORD
reinterpret_cast
<
PBYTE
>
(
&
height
)
sizeof
(
height
)
)
;
if
(
result
!
=
ERROR_SUCCESS
)
{
printf_stderr
(
"
Failed
persisting
height
to
Windows
registry
\
n
"
)
;
return
;
}
result
=
:
:
RegSetValueExW
(
regKey
L
"
urlbarHorizontalOffsetCSS
"
0
REG_BINARY
reinterpret_cast
<
PBYTE
>
(
&
urlbarHorizontalOffsetCSS
)
sizeof
(
urlbarHorizontalOffsetCSS
)
)
;
if
(
result
!
=
ERROR_SUCCESS
)
{
printf_stderr
(
"
Failed
persisting
urlbarHorizontalOffsetCSS
to
Windows
registry
\
n
"
)
;
return
;
}
result
=
:
:
RegSetValueExW
(
regKey
L
"
urlbarWidthCSS
"
0
REG_BINARY
reinterpret_cast
<
PBYTE
>
(
&
urlbarWidthCSS
)
sizeof
(
urlbarWidthCSS
)
)
;
if
(
result
!
=
ERROR_SUCCESS
)
{
printf_stderr
(
"
Failed
persisting
urlbarWidthCSS
to
Windows
registry
\
n
"
)
;
return
;
}
result
=
:
:
RegSetValueExW
(
regKey
L
"
cssToDevPixelScaling
"
0
REG_BINARY
reinterpret_cast
<
PBYTE
>
(
&
cssToDevPixelScaling
)
sizeof
(
cssToDevPixelScaling
)
)
;
if
(
result
!
=
ERROR_SUCCESS
)
{
printf_stderr
(
"
Failed
persisting
cssToDevPixelScaling
to
Windows
registry
\
n
"
)
;
return
;
}
}
MFBT_API
bool
GetPreXULSkeletonUIEnabled
(
)
{
return
sPreXULSkeletonUIEnabled
;
}
MFBT_API
void
SetPreXULSkeletonUIEnabled
(
bool
value
)
{
HKEY
regKey
;
if
(
!
OpenPreXULSkeletonUIRegKey
(
regKey
)
)
{
return
;
}
AutoCloseRegKey
closeKey
(
regKey
)
;
DWORD
enabled
=
value
;
LSTATUS
result
=
:
:
RegSetValueExW
(
regKey
L
"
enabled
"
0
REG_DWORD
reinterpret_cast
<
PBYTE
>
(
&
enabled
)
sizeof
(
enabled
)
)
;
if
(
result
!
=
ERROR_SUCCESS
)
{
printf_stderr
(
"
Failed
persisting
enabled
to
Windows
registry
\
n
"
)
;
return
;
}
sPreXULSkeletonUIEnabled
=
true
;
}
MFBT_API
void
PollPreXULSkeletonUIEvents
(
)
{
if
(
sPreXULSkeletonUIEnabled
&
&
sPreXULSkeletonUIWindow
)
{
MSG
outMsg
=
{
}
;
PeekMessageW
(
&
outMsg
sPreXULSkeletonUIWindow
0
0
0
)
;
}
}
}
