#
ifndef
NS_WINDOWS_DLL_INTERCEPTOR_H_
#
define
NS_WINDOWS_DLL_INTERCEPTOR_H_
#
include
<
wchar
.
h
>
#
include
<
windows
.
h
>
#
include
<
winternl
.
h
>
#
include
<
utility
>
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
NativeNt
.
h
"
#
include
"
mozilla
/
Tuple
.
h
"
#
include
"
mozilla
/
Types
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
mozilla
/
interceptor
/
MMPolicies
.
h
"
#
include
"
mozilla
/
interceptor
/
PatcherDetour
.
h
"
#
include
"
mozilla
/
interceptor
/
PatcherNopSpace
.
h
"
#
include
"
mozilla
/
interceptor
/
VMSharingPolicies
.
h
"
#
include
"
nsWindowsHelpers
.
h
"
#
if
defined
(
_M_IX86
)
&
&
defined
(
__clang__
)
&
&
__has_declspec_attribute
(
guard
)
#
define
INTERCEPTOR_DISABLE_CFGUARD
__declspec
(
guard
(
nocf
)
)
#
else
#
define
INTERCEPTOR_DISABLE_CFGUARD
#
endif
namespace
mozilla
{
namespace
interceptor
{
template
<
typename
T
>
struct
OriginalFunctionPtrTraits
;
template
<
typename
R
typename
.
.
.
Args
>
struct
OriginalFunctionPtrTraits
<
R
(
*
)
(
Args
.
.
.
)
>
{
using
ReturnType
=
R
;
}
;
#
if
defined
(
_M_IX86
)
template
<
typename
R
typename
.
.
.
Args
>
struct
OriginalFunctionPtrTraits
<
R
(
__stdcall
*
)
(
Args
.
.
.
)
>
{
using
ReturnType
=
R
;
}
;
template
<
typename
R
typename
.
.
.
Args
>
struct
OriginalFunctionPtrTraits
<
R
(
__fastcall
*
)
(
Args
.
.
.
)
>
{
using
ReturnType
=
R
;
}
;
#
endif
template
<
typename
InterceptorT
typename
FuncPtrT
>
class
FuncHook
final
{
public
:
using
ThisType
=
FuncHook
<
InterceptorT
FuncPtrT
>
;
using
ReturnType
=
typename
OriginalFunctionPtrTraits
<
FuncPtrT
>
:
:
ReturnType
;
constexpr
FuncHook
(
)
:
mOrigFunc
(
nullptr
)
mInitOnce
(
INIT_ONCE_STATIC_INIT
)
{
}
~
FuncHook
(
)
=
default
;
bool
Set
(
InterceptorT
&
aInterceptor
const
char
*
aName
FuncPtrT
aHookDest
)
{
LPVOID
addHookOk
=
nullptr
;
InitOnceContext
ctx
(
this
&
aInterceptor
aName
aHookDest
false
)
;
return
:
:
InitOnceExecuteOnce
(
&
mInitOnce
&
InitOnceCallback
&
ctx
&
addHookOk
)
&
&
addHookOk
;
}
bool
SetDetour
(
InterceptorT
&
aInterceptor
const
char
*
aName
FuncPtrT
aHookDest
)
{
LPVOID
addHookOk
=
nullptr
;
InitOnceContext
ctx
(
this
&
aInterceptor
aName
aHookDest
true
)
;
return
:
:
InitOnceExecuteOnce
(
&
mInitOnce
&
InitOnceCallback
&
ctx
&
addHookOk
)
&
&
addHookOk
;
}
explicit
operator
bool
(
)
const
{
return
!
!
mOrigFunc
;
}
template
<
typename
.
.
.
ArgsType
>
INTERCEPTOR_DISABLE_CFGUARD
ReturnType
operator
(
)
(
ArgsType
&
&
.
.
.
aArgs
)
const
{
return
mOrigFunc
(
std
:
:
forward
<
ArgsType
>
(
aArgs
)
.
.
.
)
;
}
FuncPtrT
GetStub
(
)
const
{
return
mOrigFunc
;
}
FuncHook
(
const
FuncHook
&
)
=
delete
;
FuncHook
(
FuncHook
&
&
)
=
delete
;
FuncHook
&
operator
=
(
const
FuncHook
&
)
=
delete
;
FuncHook
&
operator
=
(
FuncHook
&
&
aOther
)
=
delete
;
private
:
struct
MOZ_RAII
InitOnceContext
final
{
InitOnceContext
(
ThisType
*
aHook
InterceptorT
*
aInterceptor
const
char
*
aName
FuncPtrT
aHookDest
bool
aForceDetour
)
:
mHook
(
aHook
)
mInterceptor
(
aInterceptor
)
mName
(
aName
)
mHookDest
(
reinterpret_cast
<
void
*
>
(
aHookDest
)
)
mForceDetour
(
aForceDetour
)
{
}
ThisType
*
mHook
;
InterceptorT
*
mInterceptor
;
const
char
*
mName
;
void
*
mHookDest
;
bool
mForceDetour
;
}
;
private
:
bool
Apply
(
InterceptorT
*
aInterceptor
const
char
*
aName
void
*
aHookDest
)
{
return
aInterceptor
-
>
AddHook
(
aName
reinterpret_cast
<
intptr_t
>
(
aHookDest
)
reinterpret_cast
<
void
*
*
>
(
&
mOrigFunc
)
)
;
}
bool
ApplyDetour
(
InterceptorT
*
aInterceptor
const
char
*
aName
void
*
aHookDest
)
{
return
aInterceptor
-
>
AddDetour
(
aName
reinterpret_cast
<
intptr_t
>
(
aHookDest
)
reinterpret_cast
<
void
*
*
>
(
&
mOrigFunc
)
)
;
}
static
BOOL
CALLBACK
InitOnceCallback
(
PINIT_ONCE
aInitOnce
PVOID
aParam
PVOID
*
aOutContext
)
{
MOZ_ASSERT
(
aOutContext
)
;
bool
result
;
auto
ctx
=
reinterpret_cast
<
InitOnceContext
*
>
(
aParam
)
;
if
(
ctx
-
>
mForceDetour
)
{
result
=
ctx
-
>
mHook
-
>
ApplyDetour
(
ctx
-
>
mInterceptor
ctx
-
>
mName
ctx
-
>
mHookDest
)
;
}
else
{
result
=
ctx
-
>
mHook
-
>
Apply
(
ctx
-
>
mInterceptor
ctx
-
>
mName
ctx
-
>
mHookDest
)
;
}
*
aOutContext
=
result
?
reinterpret_cast
<
PVOID
>
(
1U
<
<
INIT_ONCE_CTX_RESERVED_BITS
)
:
nullptr
;
return
TRUE
;
}
private
:
FuncPtrT
mOrigFunc
;
INIT_ONCE
mInitOnce
;
}
;
template
<
typename
InterceptorT
typename
FuncPtrT
>
class
MOZ_ONLY_USED_TO_AVOID_STATIC_CONSTRUCTORS
FuncHookCrossProcess
final
{
public
:
using
ThisType
=
FuncHookCrossProcess
<
InterceptorT
FuncPtrT
>
;
using
ReturnType
=
typename
OriginalFunctionPtrTraits
<
FuncPtrT
>
:
:
ReturnType
;
#
if
defined
(
DEBUG
)
FuncHookCrossProcess
(
)
{
}
#
endif
bool
Set
(
HANDLE
aProcess
InterceptorT
&
aInterceptor
const
char
*
aName
FuncPtrT
aHookDest
)
{
FuncPtrT
origFunc
;
if
(
!
aInterceptor
.
AddHook
(
aName
reinterpret_cast
<
intptr_t
>
(
aHookDest
)
reinterpret_cast
<
void
*
*
>
(
&
origFunc
)
)
)
{
return
false
;
}
return
CopyStubToChildProcess
(
origFunc
aProcess
)
;
}
bool
SetDetour
(
HANDLE
aProcess
InterceptorT
&
aInterceptor
const
char
*
aName
FuncPtrT
aHookDest
)
{
FuncPtrT
origFunc
;
if
(
!
aInterceptor
.
AddDetour
(
aName
reinterpret_cast
<
intptr_t
>
(
aHookDest
)
reinterpret_cast
<
void
*
*
>
(
&
origFunc
)
)
)
{
return
false
;
}
return
CopyStubToChildProcess
(
origFunc
aProcess
)
;
}
explicit
operator
bool
(
)
const
{
return
!
!
mOrigFunc
;
}
template
<
typename
.
.
.
ArgsType
>
ReturnType
operator
(
)
(
ArgsType
&
&
.
.
.
aArgs
)
const
{
return
mOrigFunc
(
std
:
:
forward
<
ArgsType
>
(
aArgs
)
.
.
.
)
;
}
#
if
defined
(
DEBUG
)
FuncHookCrossProcess
(
const
FuncHookCrossProcess
&
)
=
delete
;
FuncHookCrossProcess
(
FuncHookCrossProcess
&
&
)
=
delete
;
FuncHookCrossProcess
&
operator
=
(
const
FuncHookCrossProcess
&
)
=
delete
;
FuncHookCrossProcess
&
operator
=
(
FuncHookCrossProcess
&
&
aOther
)
=
delete
;
#
endif
private
:
bool
CopyStubToChildProcess
(
FuncPtrT
aStub
HANDLE
aProcess
)
{
SIZE_T
bytesWritten
;
return
:
:
WriteProcessMemory
(
aProcess
&
mOrigFunc
&
aStub
sizeof
(
FuncPtrT
)
&
bytesWritten
)
&
&
bytesWritten
=
=
sizeof
(
FuncPtrT
)
;
}
private
:
FuncPtrT
mOrigFunc
;
}
;
template
<
typename
MMPolicyT
typename
InterceptorT
>
struct
TypeResolver
;
template
<
typename
InterceptorT
>
struct
TypeResolver
<
mozilla
:
:
interceptor
:
:
MMPolicyInProcess
InterceptorT
>
{
template
<
typename
FuncPtrT
>
using
FuncHookType
=
FuncHook
<
InterceptorT
FuncPtrT
>
;
}
;
template
<
typename
InterceptorT
>
struct
TypeResolver
<
mozilla
:
:
interceptor
:
:
MMPolicyOutOfProcess
InterceptorT
>
{
template
<
typename
FuncPtrT
>
using
FuncHookType
=
FuncHookCrossProcess
<
InterceptorT
FuncPtrT
>
;
}
;
template
<
typename
VMPolicy
=
mozilla
:
:
interceptor
:
:
VMSharingPolicyShared
>
class
WindowsDllInterceptor
final
:
public
TypeResolver
<
typename
VMPolicy
:
:
MMPolicyT
WindowsDllInterceptor
<
VMPolicy
>
>
{
typedef
WindowsDllInterceptor
<
VMPolicy
>
ThisType
;
interceptor
:
:
WindowsDllDetourPatcher
<
VMPolicy
>
mDetourPatcher
;
#
if
defined
(
_M_IX86
)
interceptor
:
:
WindowsDllNopSpacePatcher
<
typename
VMPolicy
:
:
MMPolicyT
>
mNopSpacePatcher
;
#
endif
HMODULE
mModule
;
public
:
template
<
typename
.
.
.
Args
>
explicit
WindowsDllInterceptor
(
Args
&
&
.
.
.
aArgs
)
:
mDetourPatcher
(
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
#
if
defined
(
_M_IX86
)
mNopSpacePatcher
(
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
#
endif
mModule
(
nullptr
)
{
}
WindowsDllInterceptor
(
const
WindowsDllInterceptor
&
)
=
delete
;
WindowsDllInterceptor
(
WindowsDllInterceptor
&
&
)
=
delete
;
WindowsDllInterceptor
&
operator
=
(
const
WindowsDllInterceptor
&
)
=
delete
;
WindowsDllInterceptor
&
operator
=
(
WindowsDllInterceptor
&
&
)
=
delete
;
~
WindowsDllInterceptor
(
)
{
Clear
(
)
;
}
template
<
size_t
N
>
void
Init
(
const
char
(
&
aModuleName
)
[
N
]
)
{
wchar_t
moduleName
[
N
]
;
for
(
size_t
i
=
0
;
i
<
N
;
+
+
i
)
{
MOZ_ASSERT
(
!
(
aModuleName
[
i
]
&
0x80
)
"
Use
wide
-
character
overload
for
non
-
ASCII
module
names
"
)
;
moduleName
[
i
]
=
aModuleName
[
i
]
;
}
Init
(
moduleName
)
;
}
void
Init
(
const
wchar_t
*
aModuleName
)
{
if
(
mModule
)
{
return
;
}
mModule
=
:
:
LoadLibraryW
(
aModuleName
)
;
}
void
TestOnlyDetourInit
(
const
wchar_t
*
aModuleName
DetourFlags
aFlags
)
{
Init
(
aModuleName
)
;
mDetourPatcher
.
Init
(
aFlags
)
;
}
void
Clear
(
)
{
if
(
!
mModule
)
{
return
;
}
#
if
defined
(
_M_IX86
)
mNopSpacePatcher
.
Clear
(
)
;
#
endif
mDetourPatcher
.
Clear
(
)
;
}
#
if
defined
(
NIGHTLY_BUILD
)
const
Maybe
<
DetourError
>
&
GetLastError
(
)
const
{
return
mDetourPatcher
.
GetLastError
(
)
;
}
#
endif
constexpr
static
uint32_t
GetWorstCaseRequiredBytesToPatch
(
)
{
return
WindowsDllDetourPatcherPrimitive
<
typename
VMPolicy
:
:
MMPolicyT
>
:
:
GetWorstCaseRequiredBytesToPatch
(
)
;
}
private
:
bool
AddHook
(
const
char
*
aName
intptr_t
aHookDest
void
*
*
aOrigFunc
)
{
if
(
!
mModule
)
{
return
false
;
}
FARPROC
proc
=
mDetourPatcher
.
GetProcAddress
(
mModule
aName
)
;
if
(
!
proc
)
{
return
false
;
}
#
if
defined
(
_M_IX86
)
if
(
mNopSpacePatcher
.
AddHook
(
proc
aHookDest
aOrigFunc
)
)
{
return
true
;
}
#
endif
return
AddDetour
(
proc
aHookDest
aOrigFunc
)
;
}
bool
AddDetour
(
const
char
*
aName
intptr_t
aHookDest
void
*
*
aOrigFunc
)
{
if
(
!
mModule
)
{
return
false
;
}
FARPROC
proc
=
mDetourPatcher
.
GetProcAddress
(
mModule
aName
)
;
if
(
!
proc
)
{
return
false
;
}
return
AddDetour
(
proc
aHookDest
aOrigFunc
)
;
}
bool
AddDetour
(
FARPROC
aProc
intptr_t
aHookDest
void
*
*
aOrigFunc
)
{
MOZ_ASSERT
(
mModule
&
&
aProc
)
;
if
(
!
mDetourPatcher
.
Initialized
(
)
)
{
DetourFlags
flags
=
DetourFlags
:
:
eDefault
;
#
if
defined
(
_M_X64
)
bool
needs10BytePatch
=
(
mModule
=
=
:
:
GetModuleHandleW
(
L
"
ntdll
.
dll
"
)
)
;
bool
isWin8Or81
=
IsWin8OrLater
(
)
&
&
(
!
IsWin10OrLater
(
)
)
;
bool
isWin8
=
IsWin8OrLater
(
)
&
&
(
!
IsWin8Point1OrLater
(
)
)
;
bool
isKernel32Dll
=
(
mModule
=
=
:
:
GetModuleHandleW
(
L
"
kernel32
.
dll
"
)
)
;
bool
isDuplicateHandle
=
(
reinterpret_cast
<
void
*
>
(
aProc
)
=
=
reinterpret_cast
<
void
*
>
(
&
:
:
DuplicateHandle
)
)
;
needs10BytePatch
|
=
isWin8Or81
&
&
isKernel32Dll
&
&
(
reinterpret_cast
<
void
*
>
(
aProc
)
=
=
reinterpret_cast
<
void
*
>
(
&
CloseHandle
)
)
;
needs10BytePatch
|
=
isWin8
&
&
isKernel32Dll
&
&
(
(
reinterpret_cast
<
void
*
>
(
aProc
)
=
=
reinterpret_cast
<
void
*
>
(
&
:
:
CreateFileA
)
)
|
|
isDuplicateHandle
)
;
if
(
needs10BytePatch
)
{
flags
|
=
DetourFlags
:
:
eEnable10BytePatch
;
}
if
(
isWin8
&
&
isDuplicateHandle
)
{
flags
|
=
DetourFlags
:
:
eDontResolveRedirection
;
}
#
endif
mDetourPatcher
.
Init
(
flags
)
;
}
return
mDetourPatcher
.
AddHook
(
aProc
aHookDest
aOrigFunc
)
;
}
private
:
template
<
typename
InterceptorT
typename
FuncPtrT
>
friend
class
FuncHook
;
template
<
typename
InterceptorT
typename
FuncPtrT
>
friend
class
FuncHookCrossProcess
;
}
;
class
WindowsIATPatcher
final
{
public
:
template
<
typename
FuncPtrT
>
using
FuncHookType
=
FuncHook
<
WindowsIATPatcher
FuncPtrT
>
;
private
:
static
bool
CheckASCII
(
const
char
*
aInStr
)
{
while
(
*
aInStr
)
{
if
(
*
aInStr
&
0x80
)
{
return
false
;
}
+
+
aInStr
;
}
return
true
;
}
static
bool
AddHook
(
HMODULE
aFromModule
const
char
*
aToModuleName
const
char
*
aTargetFnName
void
*
aHookDest
Atomic
<
void
*
>
*
aOutOrigFunc
)
{
if
(
!
aFromModule
|
|
!
aToModuleName
|
|
!
aTargetFnName
|
|
!
aOutOrigFunc
)
{
return
false
;
}
const
bool
isModuleNameAscii
=
CheckASCII
(
aToModuleName
)
;
MOZ_ASSERT
(
isModuleNameAscii
)
;
if
(
!
isModuleNameAscii
)
{
return
false
;
}
const
bool
isTargetFnNameAscii
=
CheckASCII
(
aTargetFnName
)
;
MOZ_ASSERT
(
isTargetFnNameAscii
)
;
if
(
!
isTargetFnNameAscii
)
{
return
false
;
}
nt
:
:
PEHeaders
headers
(
aFromModule
)
;
if
(
!
headers
)
{
return
false
;
}
PIMAGE_IMPORT_DESCRIPTOR
impDesc
=
headers
.
GetImportDescriptor
(
aToModuleName
)
;
if
(
!
nt
:
:
PEHeaders
:
:
IsValid
(
impDesc
)
)
{
return
false
;
}
auto
firstINTThunk
=
headers
.
template
RVAToPtr
<
PIMAGE_THUNK_DATA
>
(
impDesc
-
>
OriginalFirstThunk
)
;
if
(
!
nt
:
:
PEHeaders
:
:
IsValid
(
firstINTThunk
)
)
{
return
false
;
}
Maybe
<
ptrdiff_t
>
thunkIndex
;
for
(
PIMAGE_THUNK_DATA
curINTThunk
=
firstINTThunk
;
nt
:
:
PEHeaders
:
:
IsValid
(
curINTThunk
)
;
+
+
curINTThunk
)
{
if
(
IMAGE_SNAP_BY_ORDINAL
(
curINTThunk
-
>
u1
.
Ordinal
)
)
{
continue
;
}
PIMAGE_IMPORT_BY_NAME
curThunkFnName
=
headers
.
template
RVAToPtr
<
PIMAGE_IMPORT_BY_NAME
>
(
curINTThunk
-
>
u1
.
AddressOfData
)
;
MOZ_ASSERT
(
curThunkFnName
)
;
if
(
!
curThunkFnName
)
{
continue
;
}
if
(
!
strcmp
(
aTargetFnName
curThunkFnName
-
>
Name
)
)
{
thunkIndex
=
Some
(
curINTThunk
-
firstINTThunk
)
;
break
;
}
}
if
(
thunkIndex
.
isNothing
(
)
)
{
return
false
;
}
if
(
thunkIndex
.
value
(
)
<
0
)
{
return
false
;
}
auto
firstIATThunk
=
headers
.
template
RVAToPtr
<
PIMAGE_THUNK_DATA
>
(
impDesc
-
>
FirstThunk
)
;
if
(
!
nt
:
:
PEHeaders
:
:
IsValid
(
firstIATThunk
)
)
{
return
false
;
}
PIMAGE_THUNK_DATA
targetThunk
=
&
firstIATThunk
[
thunkIndex
.
value
(
)
]
;
if
(
!
nt
:
:
PEHeaders
:
:
IsValid
(
targetThunk
)
)
{
return
false
;
}
auto
fnPtr
=
reinterpret_cast
<
Atomic
<
void
*
>
*
>
(
&
targetThunk
-
>
u1
.
Function
)
;
AutoVirtualProtect
prot
(
fnPtr
sizeof
(
void
*
)
PAGE_EXECUTE_READWRITE
)
;
if
(
!
prot
)
{
return
false
;
}
void
*
tmp
;
do
{
tmp
=
*
fnPtr
;
*
aOutOrigFunc
=
tmp
;
}
while
(
!
fnPtr
-
>
compareExchange
(
tmp
aHookDest
)
)
;
return
true
;
}
template
<
typename
InterceptorT
typename
FuncPtrT
>
friend
class
FuncHook
;
}
;
template
<
typename
FuncPtrT
>
class
MOZ_ONLY_USED_TO_AVOID_STATIC_CONSTRUCTORS
FuncHook
<
WindowsIATPatcher
FuncPtrT
>
final
{
public
:
using
ThisType
=
FuncHook
<
WindowsIATPatcher
FuncPtrT
>
;
using
ReturnType
=
typename
OriginalFunctionPtrTraits
<
FuncPtrT
>
:
:
ReturnType
;
constexpr
FuncHook
(
)
:
mInitOnce
(
INIT_ONCE_STATIC_INIT
)
mFromModule
(
nullptr
)
mOrigFunc
(
nullptr
)
{
}
#
if
defined
(
DEBUG
)
~
FuncHook
(
)
=
default
;
#
endif
bool
Set
(
const
wchar_t
*
aFromModuleName
const
char
*
aToModuleName
const
char
*
aFnName
FuncPtrT
aHookDest
)
{
nsModuleHandle
fromModule
(
:
:
LoadLibraryW
(
aFromModuleName
)
)
;
if
(
!
fromModule
)
{
return
false
;
}
return
Set
(
fromModule
aToModuleName
aFnName
aHookDest
)
;
}
bool
Set
(
nsModuleHandle
&
aFromModule
const
char
*
aToModuleName
const
char
*
aFnName
FuncPtrT
aHookDest
)
{
LPVOID
addHookOk
=
nullptr
;
InitOnceContext
ctx
(
this
aFromModule
aToModuleName
aFnName
aHookDest
)
;
bool
result
=
:
:
InitOnceExecuteOnce
(
&
mInitOnce
&
InitOnceCallback
&
ctx
&
addHookOk
)
&
&
addHookOk
;
if
(
!
result
)
{
return
result
;
}
mFromModule
=
aFromModule
.
disown
(
)
;
return
result
;
}
explicit
operator
bool
(
)
const
{
return
!
!
mOrigFunc
;
}
template
<
typename
.
.
.
ArgsType
>
ReturnType
operator
(
)
(
ArgsType
&
&
.
.
.
aArgs
)
const
{
return
mOrigFunc
(
std
:
:
forward
<
ArgsType
>
(
aArgs
)
.
.
.
)
;
}
FuncPtrT
GetStub
(
)
const
{
return
mOrigFunc
;
}
#
if
defined
(
DEBUG
)
FuncHook
(
const
FuncHook
&
)
=
delete
;
FuncHook
(
FuncHook
&
&
)
=
delete
;
FuncHook
&
operator
=
(
const
FuncHook
&
)
=
delete
;
FuncHook
&
operator
=
(
FuncHook
&
&
aOther
)
=
delete
;
#
endif
private
:
struct
MOZ_RAII
InitOnceContext
final
{
InitOnceContext
(
ThisType
*
aHook
const
nsModuleHandle
&
aFromModule
const
char
*
aToModuleName
const
char
*
aFnName
FuncPtrT
aHookDest
)
:
mHook
(
aHook
)
mFromModule
(
aFromModule
)
mToModuleName
(
aToModuleName
)
mFnName
(
aFnName
)
mHookDest
(
reinterpret_cast
<
void
*
>
(
aHookDest
)
)
{
}
ThisType
*
mHook
;
const
nsModuleHandle
&
mFromModule
;
const
char
*
mToModuleName
;
const
char
*
mFnName
;
void
*
mHookDest
;
}
;
private
:
bool
Apply
(
const
nsModuleHandle
&
aFromModule
const
char
*
aToModuleName
const
char
*
aFnName
void
*
aHookDest
)
{
return
WindowsIATPatcher
:
:
AddHook
(
aFromModule
aToModuleName
aFnName
aHookDest
reinterpret_cast
<
Atomic
<
void
*
>
*
>
(
&
mOrigFunc
)
)
;
}
static
BOOL
CALLBACK
InitOnceCallback
(
PINIT_ONCE
aInitOnce
PVOID
aParam
PVOID
*
aOutContext
)
{
MOZ_ASSERT
(
aOutContext
)
;
auto
ctx
=
reinterpret_cast
<
InitOnceContext
*
>
(
aParam
)
;
bool
result
=
ctx
-
>
mHook
-
>
Apply
(
ctx
-
>
mFromModule
ctx
-
>
mToModuleName
ctx
-
>
mFnName
ctx
-
>
mHookDest
)
;
*
aOutContext
=
result
?
reinterpret_cast
<
PVOID
>
(
1U
<
<
INIT_ONCE_CTX_RESERVED_BITS
)
:
nullptr
;
return
TRUE
;
}
private
:
INIT_ONCE
mInitOnce
;
HMODULE
mFromModule
;
FuncPtrT
mOrigFunc
;
}
;
class
WindowsDllEntryPointInterceptor
final
{
using
DllMainFn
=
BOOL
(
WINAPI
*
)
(
HINSTANCE
DWORD
LPVOID
)
;
using
MMPolicyT
=
MMPolicyInProcessEarlyStage
;
MMPolicyT
mMMPolicy
;
public
:
explicit
WindowsDllEntryPointInterceptor
(
const
MMPolicyT
:
:
Kernel32Exports
&
aK32Exports
)
:
mMMPolicy
(
aK32Exports
)
{
}
bool
Set
(
const
nt
:
:
PEHeaders
&
aHeaders
DllMainFn
aDestination
)
{
if
(
!
aHeaders
)
{
return
false
;
}
WindowsDllDetourPatcherPrimitive
<
MMPolicyT
>
patcher
;
return
patcher
.
AddIrreversibleHook
(
mMMPolicy
aHeaders
.
GetEntryPoint
(
)
reinterpret_cast
<
uintptr_t
>
(
aDestination
)
)
;
}
}
;
}
using
WindowsDllInterceptor
=
interceptor
:
:
WindowsDllInterceptor
<
>
;
using
CrossProcessDllInterceptor
=
interceptor
:
:
WindowsDllInterceptor
<
mozilla
:
:
interceptor
:
:
VMSharingPolicyUnique
<
mozilla
:
:
interceptor
:
:
MMPolicyOutOfProcess
>
>
;
using
WindowsIATPatcher
=
interceptor
:
:
WindowsIATPatcher
;
}
#
endif
