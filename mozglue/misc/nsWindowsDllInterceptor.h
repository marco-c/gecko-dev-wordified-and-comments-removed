#
ifndef
NS_WINDOWS_DLL_INTERCEPTOR_H_
#
define
NS_WINDOWS_DLL_INTERCEPTOR_H_
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
Tuple
.
h
"
#
include
"
mozilla
/
TypeTraits
.
h
"
#
include
"
mozilla
/
Types
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
nsWindowsHelpers
.
h
"
#
include
<
wchar
.
h
>
#
include
<
windows
.
h
>
#
include
<
winternl
.
h
>
#
include
"
mozilla
/
interceptor
/
MMPolicies
.
h
"
#
include
"
mozilla
/
interceptor
/
PatcherDetour
.
h
"
#
include
"
mozilla
/
interceptor
/
PatcherNopSpace
.
h
"
#
include
"
mozilla
/
interceptor
/
VMSharingPolicies
.
h
"
namespace
mozilla
{
namespace
interceptor
{
template
<
typename
T
>
struct
OriginalFunctionPtrTraits
;
template
<
typename
R
typename
.
.
.
Args
>
struct
OriginalFunctionPtrTraits
<
R
(
*
)
(
Args
.
.
.
)
>
{
using
ReturnType
=
R
;
}
;
#
if
defined
(
_M_IX86
)
template
<
typename
R
typename
.
.
.
Args
>
struct
OriginalFunctionPtrTraits
<
R
(
__stdcall
*
)
(
Args
.
.
.
)
>
{
using
ReturnType
=
R
;
}
;
template
<
typename
R
typename
.
.
.
Args
>
struct
OriginalFunctionPtrTraits
<
R
(
__fastcall
*
)
(
Args
.
.
.
)
>
{
using
ReturnType
=
R
;
}
;
#
endif
template
<
typename
InterceptorT
typename
FuncPtrT
>
class
FuncHook
final
{
public
:
using
ThisType
=
FuncHook
<
InterceptorT
FuncPtrT
>
;
using
ReturnType
=
typename
OriginalFunctionPtrTraits
<
FuncPtrT
>
:
:
ReturnType
;
constexpr
FuncHook
(
)
:
mOrigFunc
(
nullptr
)
mInitOnce
(
INIT_ONCE_STATIC_INIT
)
{
}
~
FuncHook
(
)
=
default
;
bool
Set
(
InterceptorT
&
aInterceptor
const
char
*
aName
FuncPtrT
aHookDest
)
{
LPVOID
addHookOk
;
InitOnceContext
ctx
(
this
&
aInterceptor
aName
aHookDest
false
)
;
return
:
:
InitOnceExecuteOnce
(
&
mInitOnce
&
InitOnceCallback
&
ctx
&
addHookOk
)
&
&
addHookOk
;
}
bool
SetDetour
(
InterceptorT
&
aInterceptor
const
char
*
aName
FuncPtrT
aHookDest
)
{
LPVOID
addHookOk
;
InitOnceContext
ctx
(
this
&
aInterceptor
aName
aHookDest
true
)
;
return
:
:
InitOnceExecuteOnce
(
&
mInitOnce
&
InitOnceCallback
&
ctx
&
addHookOk
)
&
&
addHookOk
;
}
explicit
operator
bool
(
)
const
{
return
!
!
mOrigFunc
;
}
template
<
typename
.
.
.
ArgsType
>
ReturnType
operator
(
)
(
ArgsType
.
.
.
aArgs
)
const
{
return
mOrigFunc
(
std
:
:
forward
<
ArgsType
>
(
aArgs
)
.
.
.
)
;
}
FuncPtrT
GetStub
(
)
const
{
return
mOrigFunc
;
}
FuncHook
(
const
FuncHook
&
)
=
delete
;
FuncHook
(
FuncHook
&
&
)
=
delete
;
FuncHook
&
operator
=
(
const
FuncHook
&
)
=
delete
;
FuncHook
&
operator
=
(
FuncHook
&
&
aOther
)
=
delete
;
private
:
struct
MOZ_RAII
InitOnceContext
final
{
InitOnceContext
(
ThisType
*
aHook
InterceptorT
*
aInterceptor
const
char
*
aName
void
*
aHookDest
bool
aForceDetour
)
:
mHook
(
aHook
)
mInterceptor
(
aInterceptor
)
mName
(
aName
)
mHookDest
(
aHookDest
)
mForceDetour
(
aForceDetour
)
{
}
ThisType
*
mHook
;
InterceptorT
*
mInterceptor
;
const
char
*
mName
;
void
*
mHookDest
;
bool
mForceDetour
;
}
;
private
:
bool
Apply
(
InterceptorT
*
aInterceptor
const
char
*
aName
void
*
aHookDest
)
{
return
aInterceptor
-
>
AddHook
(
aName
reinterpret_cast
<
intptr_t
>
(
aHookDest
)
reinterpret_cast
<
void
*
*
>
(
&
mOrigFunc
)
)
;
}
bool
ApplyDetour
(
InterceptorT
*
aInterceptor
const
char
*
aName
void
*
aHookDest
)
{
return
aInterceptor
-
>
AddDetour
(
aName
reinterpret_cast
<
intptr_t
>
(
aHookDest
)
reinterpret_cast
<
void
*
*
>
(
&
mOrigFunc
)
)
;
}
static
BOOL
CALLBACK
InitOnceCallback
(
PINIT_ONCE
aInitOnce
PVOID
aParam
PVOID
*
aOutContext
)
{
MOZ_ASSERT
(
aOutContext
)
;
bool
result
;
auto
ctx
=
reinterpret_cast
<
InitOnceContext
*
>
(
aParam
)
;
if
(
ctx
-
>
mForceDetour
)
{
result
=
ctx
-
>
mHook
-
>
ApplyDetour
(
ctx
-
>
mInterceptor
ctx
-
>
mName
ctx
-
>
mHookDest
)
;
}
else
{
result
=
ctx
-
>
mHook
-
>
Apply
(
ctx
-
>
mInterceptor
ctx
-
>
mName
ctx
-
>
mHookDest
)
;
}
*
aOutContext
=
result
?
reinterpret_cast
<
PVOID
>
(
1U
<
<
INIT_ONCE_CTX_RESERVED_BITS
)
:
nullptr
;
return
TRUE
;
}
private
:
FuncPtrT
mOrigFunc
;
INIT_ONCE
mInitOnce
;
}
;
template
<
typename
InterceptorT
typename
FuncPtrT
>
class
MOZ_ONLY_USED_TO_AVOID_STATIC_CONSTRUCTORS
FuncHookCrossProcess
final
{
public
:
using
ThisType
=
FuncHookCrossProcess
<
InterceptorT
FuncPtrT
>
;
using
ReturnType
=
typename
OriginalFunctionPtrTraits
<
FuncPtrT
>
:
:
ReturnType
;
FuncHookCrossProcess
(
)
=
default
;
~
FuncHookCrossProcess
(
)
=
default
;
bool
Set
(
HANDLE
aProcess
InterceptorT
&
aInterceptor
const
char
*
aName
FuncPtrT
aHookDest
)
{
if
(
!
aInterceptor
.
AddHook
(
aName
reinterpret_cast
<
intptr_t
>
(
aHookDest
)
reinterpret_cast
<
void
*
*
>
(
&
mOrigFunc
)
)
)
{
return
false
;
}
return
CopyStubToChildProcess
(
aProcess
)
;
}
bool
SetDetour
(
HANDLE
aProcess
InterceptorT
&
aInterceptor
const
char
*
aName
FuncPtrT
aHookDest
)
{
if
(
!
aInterceptor
.
AddDetour
(
aName
reinterpret_cast
<
intptr_t
>
(
aHookDest
)
reinterpret_cast
<
void
*
*
>
(
&
mOrigFunc
)
)
)
{
return
false
;
}
return
CopyStubToChildProcess
(
aProcess
)
;
}
explicit
operator
bool
(
)
const
{
return
!
!
mOrigFunc
;
}
template
<
typename
.
.
.
ArgsType
>
ReturnType
operator
(
)
(
ArgsType
.
.
.
aArgs
)
const
{
return
mOrigFunc
(
std
:
:
forward
<
ArgsType
>
(
aArgs
)
.
.
.
)
;
}
FuncHookCrossProcess
(
const
FuncHookCrossProcess
&
)
=
delete
;
FuncHookCrossProcess
(
FuncHookCrossProcess
&
&
)
=
delete
;
FuncHookCrossProcess
&
operator
=
(
const
FuncHookCrossProcess
&
)
=
delete
;
FuncHookCrossProcess
&
operator
=
(
FuncHookCrossProcess
&
&
aOther
)
=
delete
;
private
:
bool
CopyStubToChildProcess
(
HANDLE
aProcess
)
{
SIZE_T
bytesWritten
;
return
!
!
:
:
WriteProcessMemory
(
aProcess
&
mOrigFunc
&
mOrigFunc
sizeof
(
mOrigFunc
)
&
bytesWritten
)
;
}
private
:
FuncPtrT
mOrigFunc
;
}
;
enum
{
kDefaultTrampolineSize
=
128
}
;
template
<
typename
MMPolicyT
typename
InterceptorT
>
struct
TypeResolver
;
template
<
typename
InterceptorT
>
struct
TypeResolver
<
mozilla
:
:
interceptor
:
:
MMPolicyInProcess
InterceptorT
>
{
template
<
typename
FuncPtrT
>
using
FuncHookType
=
FuncHook
<
InterceptorT
FuncPtrT
>
;
}
;
template
<
typename
InterceptorT
>
struct
TypeResolver
<
mozilla
:
:
interceptor
:
:
MMPolicyOutOfProcess
InterceptorT
>
{
template
<
typename
FuncPtrT
>
using
FuncHookType
=
FuncHookCrossProcess
<
InterceptorT
FuncPtrT
>
;
}
;
template
<
typename
VMPolicy
=
mozilla
:
:
interceptor
:
:
VMSharingPolicyShared
<
mozilla
:
:
interceptor
:
:
MMPolicyInProcess
kDefaultTrampolineSize
>
>
class
WindowsDllInterceptor
final
:
public
TypeResolver
<
typename
VMPolicy
:
:
MMPolicyT
WindowsDllInterceptor
<
VMPolicy
>
>
{
typedef
WindowsDllInterceptor
<
VMPolicy
>
ThisType
;
interceptor
:
:
WindowsDllDetourPatcher
<
VMPolicy
>
mDetourPatcher
;
#
if
defined
(
_M_IX86
)
interceptor
:
:
WindowsDllNopSpacePatcher
<
typename
VMPolicy
:
:
MMPolicyT
>
mNopSpacePatcher
;
#
endif
HMODULE
mModule
;
int
mNHooks
;
public
:
template
<
typename
.
.
.
Args
>
explicit
WindowsDllInterceptor
(
Args
.
.
.
aArgs
)
:
mDetourPatcher
(
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
#
if
defined
(
_M_IX86
)
mNopSpacePatcher
(
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
#
endif
mModule
(
nullptr
)
mNHooks
(
0
)
{
}
WindowsDllInterceptor
(
const
WindowsDllInterceptor
&
)
=
delete
;
WindowsDllInterceptor
(
WindowsDllInterceptor
&
&
)
=
delete
;
WindowsDllInterceptor
&
operator
=
(
const
WindowsDllInterceptor
&
)
=
delete
;
WindowsDllInterceptor
&
operator
=
(
WindowsDllInterceptor
&
&
)
=
delete
;
~
WindowsDllInterceptor
(
)
{
Clear
(
)
;
}
template
<
size_t
N
>
void
Init
(
const
char
(
&
aModuleName
)
[
N
]
int
aNumHooks
=
0
)
{
wchar_t
moduleName
[
N
]
;
for
(
size_t
i
=
0
;
i
<
N
;
+
+
i
)
{
MOZ_ASSERT
(
!
(
aModuleName
[
i
]
&
0x80
)
"
Use
wide
-
character
overload
for
non
-
ASCII
module
names
"
)
;
moduleName
[
i
]
=
aModuleName
[
i
]
;
}
Init
(
moduleName
aNumHooks
)
;
}
void
Init
(
const
wchar_t
*
aModuleName
int
aNumHooks
=
0
)
{
if
(
mModule
)
{
return
;
}
mModule
=
:
:
LoadLibraryW
(
aModuleName
)
;
mNHooks
=
aNumHooks
;
}
void
Clear
(
)
{
if
(
!
mModule
)
{
return
;
}
#
if
defined
(
_M_IX86
)
mNopSpacePatcher
.
Clear
(
)
;
#
endif
mDetourPatcher
.
Clear
(
)
;
}
private
:
bool
AddHook
(
const
char
*
aName
intptr_t
aHookDest
void
*
*
aOrigFunc
)
{
if
(
!
mModule
)
{
return
false
;
}
FARPROC
proc
=
:
:
GetProcAddress
(
mModule
aName
)
;
if
(
!
proc
)
{
return
false
;
}
#
if
defined
(
_M_IX86
)
if
(
mNopSpacePatcher
.
AddHook
(
proc
aHookDest
aOrigFunc
)
)
{
return
true
;
}
#
endif
return
AddDetour
(
proc
aHookDest
aOrigFunc
)
;
}
bool
AddDetour
(
const
char
*
aName
intptr_t
aHookDest
void
*
*
aOrigFunc
)
{
if
(
!
mModule
)
{
return
false
;
}
FARPROC
proc
=
:
:
GetProcAddress
(
mModule
aName
)
;
if
(
!
proc
)
{
return
false
;
}
return
AddDetour
(
proc
aHookDest
aOrigFunc
)
;
}
bool
AddDetour
(
FARPROC
aProc
intptr_t
aHookDest
void
*
*
aOrigFunc
)
{
MOZ_ASSERT
(
mModule
&
&
aProc
)
;
if
(
!
mDetourPatcher
.
Initialized
(
)
)
{
mDetourPatcher
.
Init
(
mNHooks
)
;
}
return
mDetourPatcher
.
AddHook
(
aProc
aHookDest
aOrigFunc
)
;
}
private
:
template
<
typename
InterceptorT
typename
FuncPtrT
>
friend
class
FuncHook
;
template
<
typename
InterceptorT
typename
FuncPtrT
>
friend
class
FuncHookCrossProcess
;
}
;
}
using
WindowsDllInterceptor
=
interceptor
:
:
WindowsDllInterceptor
<
>
;
using
CrossProcessDllInterceptor
=
interceptor
:
:
WindowsDllInterceptor
<
mozilla
:
:
interceptor
:
:
VMSharingPolicyUnique
<
mozilla
:
:
interceptor
:
:
MMPolicyOutOfProcess
mozilla
:
:
interceptor
:
:
kDefaultTrampolineSize
>
>
;
}
#
endif
