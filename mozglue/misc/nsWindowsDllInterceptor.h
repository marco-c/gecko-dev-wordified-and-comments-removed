#
ifndef
NS_WINDOWS_DLL_INTERCEPTOR_H_
#
define
NS_WINDOWS_DLL_INTERCEPTOR_H_
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
NotNull
.
h
"
#
include
"
mozilla
/
TypeTraits
.
h
"
#
include
"
mozilla
/
Types
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
nsWindowsHelpers
.
h
"
#
include
<
wchar
.
h
>
#
include
<
windows
.
h
>
#
include
<
winternl
.
h
>
#
include
"
mozilla
/
interceptor
/
MMPolicies
.
h
"
#
include
"
mozilla
/
interceptor
/
PatcherDetour
.
h
"
#
include
"
mozilla
/
interceptor
/
PatcherNopSpace
.
h
"
#
include
"
mozilla
/
interceptor
/
VMSharingPolicies
.
h
"
namespace
mozilla
{
namespace
interceptor
{
enum
{
kDefaultTrampolineSize
=
128
}
;
template
<
typename
VMPolicy
=
mozilla
:
:
interceptor
:
:
VMSharingPolicyShared
<
mozilla
:
:
interceptor
:
:
MMPolicyInProcess
kDefaultTrampolineSize
>
>
class
WindowsDllInterceptor
final
{
interceptor
:
:
WindowsDllDetourPatcher
<
VMPolicy
>
mDetourPatcher
;
#
if
defined
(
_M_IX86
)
interceptor
:
:
WindowsDllNopSpacePatcher
<
typename
VMPolicy
:
:
MMPolicyT
>
mNopSpacePatcher
;
#
endif
HMODULE
mModule
;
int
mNHooks
;
public
:
template
<
typename
.
.
.
Args
>
explicit
WindowsDllInterceptor
(
Args
.
.
.
aArgs
)
:
mDetourPatcher
(
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
#
if
defined
(
_M_IX86
)
mNopSpacePatcher
(
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
#
endif
mModule
(
nullptr
)
mNHooks
(
0
)
{
}
WindowsDllInterceptor
(
const
WindowsDllInterceptor
&
)
=
delete
;
WindowsDllInterceptor
(
WindowsDllInterceptor
&
&
)
=
delete
;
WindowsDllInterceptor
&
operator
=
(
const
WindowsDllInterceptor
&
)
=
delete
;
WindowsDllInterceptor
&
operator
=
(
WindowsDllInterceptor
&
&
)
=
delete
;
~
WindowsDllInterceptor
(
)
{
Clear
(
)
;
}
template
<
size_t
N
>
void
Init
(
const
char
(
&
aModuleName
)
[
N
]
int
aNumHooks
=
0
)
{
wchar_t
moduleName
[
N
]
;
for
(
size_t
i
=
0
;
i
<
N
;
+
+
i
)
{
MOZ_ASSERT
(
!
(
aModuleName
[
i
]
&
0x80
)
"
Use
wide
-
character
overload
for
non
-
ASCII
module
names
"
)
;
moduleName
[
i
]
=
aModuleName
[
i
]
;
}
Init
(
moduleName
aNumHooks
)
;
}
void
Init
(
const
wchar_t
*
aModuleName
int
aNumHooks
=
0
)
{
if
(
mModule
)
{
return
;
}
mModule
=
:
:
LoadLibraryW
(
aModuleName
)
;
mNHooks
=
aNumHooks
;
}
void
Clear
(
)
{
if
(
!
mModule
)
{
return
;
}
#
if
defined
(
_M_IX86
)
mNopSpacePatcher
.
Clear
(
)
;
#
endif
mDetourPatcher
.
Clear
(
)
;
}
bool
AddHook
(
const
char
*
aName
intptr_t
aHookDest
void
*
*
aOrigFunc
)
{
if
(
!
mModule
)
{
return
false
;
}
FARPROC
proc
=
:
:
GetProcAddress
(
mModule
aName
)
;
if
(
!
proc
)
{
return
false
;
}
#
if
defined
(
_M_IX86
)
if
(
mNopSpacePatcher
.
AddHook
(
proc
aHookDest
aOrigFunc
)
)
{
return
true
;
}
#
endif
return
AddDetour
(
proc
aHookDest
aOrigFunc
)
;
}
bool
AddDetour
(
const
char
*
aName
intptr_t
aHookDest
void
*
*
aOrigFunc
)
{
if
(
!
mModule
)
{
return
false
;
}
FARPROC
proc
=
:
:
GetProcAddress
(
mModule
aName
)
;
if
(
!
proc
)
{
return
false
;
}
return
AddDetour
(
proc
aHookDest
aOrigFunc
)
;
}
private
:
bool
AddDetour
(
FARPROC
aProc
intptr_t
aHookDest
void
*
*
aOrigFunc
)
{
MOZ_ASSERT
(
mModule
&
&
aProc
)
;
if
(
!
mDetourPatcher
.
Initialized
(
)
)
{
mDetourPatcher
.
Init
(
mNHooks
)
;
}
return
mDetourPatcher
.
AddHook
(
aProc
aHookDest
aOrigFunc
)
;
}
}
;
}
using
WindowsDllInterceptor
=
interceptor
:
:
WindowsDllInterceptor
<
>
;
using
CrossProcessDllInterceptor
=
interceptor
:
:
WindowsDllInterceptor
<
mozilla
:
:
interceptor
:
:
VMSharingPolicyUnique
<
mozilla
:
:
interceptor
:
:
MMPolicyOutOfProcess
mozilla
:
:
interceptor
:
:
kDefaultTrampolineSize
>
>
;
}
#
endif
