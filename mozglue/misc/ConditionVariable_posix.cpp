#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
<
errno
.
h
>
#
include
<
pthread
.
h
>
#
include
<
time
.
h
>
#
include
"
mozilla
/
PlatformConditionVariable
.
h
"
#
include
"
mozilla
/
PlatformMutex
.
h
"
#
include
"
MutexPlatformData_posix
.
h
"
using
mozilla
:
:
CheckedInt
;
using
mozilla
:
:
TimeDuration
;
static
const
long
NanoSecPerSec
=
1000000000
;
#
if
defined
(
HAVE_CLOCK_MONOTONIC
)
&
&
\
!
(
defined
(
__ANDROID__
)
&
&
__ANDROID_API__
<
21
)
&
&
!
defined
(
__APPLE__
)
#
define
CV_USE_CLOCK_API
#
endif
#
ifdef
CV_USE_CLOCK_API
static
const
clockid_t
WhichClock
=
CLOCK_MONOTONIC
;
static
void
moz_timespecadd
(
struct
timespec
*
lhs
struct
timespec
*
rhs
struct
timespec
*
result
)
{
MOZ_RELEASE_ASSERT
(
lhs
-
>
tv_nsec
<
NanoSecPerSec
)
;
MOZ_RELEASE_ASSERT
(
rhs
-
>
tv_nsec
<
NanoSecPerSec
)
;
result
-
>
tv_nsec
=
lhs
-
>
tv_nsec
+
rhs
-
>
tv_nsec
;
CheckedInt
<
time_t
>
sec
=
CheckedInt
<
time_t
>
(
lhs
-
>
tv_sec
)
+
rhs
-
>
tv_sec
;
if
(
result
-
>
tv_nsec
>
=
NanoSecPerSec
)
{
MOZ_RELEASE_ASSERT
(
result
-
>
tv_nsec
<
2
*
NanoSecPerSec
)
;
result
-
>
tv_nsec
-
=
NanoSecPerSec
;
sec
+
=
1
;
}
MOZ_RELEASE_ASSERT
(
sec
.
isValid
(
)
)
;
result
-
>
tv_sec
=
sec
.
value
(
)
;
}
#
endif
struct
mozilla
:
:
detail
:
:
ConditionVariableImpl
:
:
PlatformData
{
pthread_cond_t
ptCond
;
}
;
mozilla
:
:
detail
:
:
ConditionVariableImpl
:
:
ConditionVariableImpl
(
)
{
pthread_cond_t
*
ptCond
=
&
platformData
(
)
-
>
ptCond
;
#
ifdef
CV_USE_CLOCK_API
pthread_condattr_t
attr
;
int
r0
=
pthread_condattr_init
(
&
attr
)
;
MOZ_RELEASE_ASSERT
(
!
r0
)
;
int
r1
=
pthread_condattr_setclock
(
&
attr
WhichClock
)
;
MOZ_RELEASE_ASSERT
(
!
r1
)
;
int
r2
=
pthread_cond_init
(
ptCond
&
attr
)
;
MOZ_RELEASE_ASSERT
(
!
r2
)
;
int
r3
=
pthread_condattr_destroy
(
&
attr
)
;
MOZ_RELEASE_ASSERT
(
!
r3
)
;
#
else
int
r
=
pthread_cond_init
(
ptCond
NULL
)
;
MOZ_RELEASE_ASSERT
(
!
r
)
;
#
endif
}
mozilla
:
:
detail
:
:
ConditionVariableImpl
:
:
~
ConditionVariableImpl
(
)
{
int
r
=
pthread_cond_destroy
(
&
platformData
(
)
-
>
ptCond
)
;
MOZ_RELEASE_ASSERT
(
r
=
=
0
)
;
}
void
mozilla
:
:
detail
:
:
ConditionVariableImpl
:
:
notify_one
(
)
{
int
r
=
pthread_cond_signal
(
&
platformData
(
)
-
>
ptCond
)
;
MOZ_RELEASE_ASSERT
(
r
=
=
0
)
;
}
void
mozilla
:
:
detail
:
:
ConditionVariableImpl
:
:
notify_all
(
)
{
int
r
=
pthread_cond_broadcast
(
&
platformData
(
)
-
>
ptCond
)
;
MOZ_RELEASE_ASSERT
(
r
=
=
0
)
;
}
void
mozilla
:
:
detail
:
:
ConditionVariableImpl
:
:
wait
(
MutexImpl
&
lock
)
{
pthread_cond_t
*
ptCond
=
&
platformData
(
)
-
>
ptCond
;
pthread_mutex_t
*
ptMutex
=
&
lock
.
platformData
(
)
-
>
ptMutex
;
int
r
=
pthread_cond_wait
(
ptCond
ptMutex
)
;
MOZ_RELEASE_ASSERT
(
r
=
=
0
)
;
}
mozilla
:
:
CVStatus
mozilla
:
:
detail
:
:
ConditionVariableImpl
:
:
wait_for
(
MutexImpl
&
lock
const
TimeDuration
&
a_rel_time
)
{
if
(
a_rel_time
=
=
TimeDuration
:
:
Forever
(
)
)
{
wait
(
lock
)
;
return
CVStatus
:
:
NoTimeout
;
}
pthread_cond_t
*
ptCond
=
&
platformData
(
)
-
>
ptCond
;
pthread_mutex_t
*
ptMutex
=
&
lock
.
platformData
(
)
-
>
ptMutex
;
int
r
;
TimeDuration
rel_time
=
a_rel_time
<
TimeDuration
:
:
FromSeconds
(
0
)
?
TimeDuration
:
:
FromSeconds
(
0
)
:
a_rel_time
;
struct
timespec
rel_ts
;
rel_ts
.
tv_sec
=
static_cast
<
time_t
>
(
rel_time
.
ToSeconds
(
)
)
;
rel_ts
.
tv_nsec
=
static_cast
<
uint64_t
>
(
rel_time
.
ToMicroseconds
(
)
*
1000
.
0
)
%
NanoSecPerSec
;
#
ifdef
CV_USE_CLOCK_API
struct
timespec
now_ts
;
r
=
clock_gettime
(
WhichClock
&
now_ts
)
;
MOZ_RELEASE_ASSERT
(
!
r
)
;
struct
timespec
abs_ts
;
moz_timespecadd
(
&
now_ts
&
rel_ts
&
abs_ts
)
;
r
=
pthread_cond_timedwait
(
ptCond
ptMutex
&
abs_ts
)
;
#
else
r
=
pthread_cond_timedwait_relative_np
(
ptCond
ptMutex
&
rel_ts
)
;
#
endif
if
(
r
=
=
0
)
{
return
CVStatus
:
:
NoTimeout
;
}
MOZ_RELEASE_ASSERT
(
r
=
=
ETIMEDOUT
)
;
return
CVStatus
:
:
Timeout
;
}
mozilla
:
:
detail
:
:
ConditionVariableImpl
:
:
PlatformData
*
mozilla
:
:
detail
:
:
ConditionVariableImpl
:
:
platformData
(
)
{
static_assert
(
sizeof
platformData_
>
=
sizeof
(
PlatformData
)
"
platformData_
is
too
small
"
)
;
return
reinterpret_cast
<
PlatformData
*
>
(
platformData_
)
;
}
