#
include
"
EarlyBlankWindow
.
h
"
#
include
<
algorithm
>
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
glue
/
Debug
.
h
"
#
include
"
mozilla
/
WindowsVersion
.
h
"
namespace
mozilla
{
static
const
wchar_t
kEarlyBlankWindowKeyPath
[
]
=
L
"
SOFTWARE
"
L
"
\
\
"
MOZ_APP_VENDOR
L
"
\
\
"
MOZ_APP_BASENAME
L
"
\
\
EarlyBlankWindowSettings
"
;
static
bool
sEarlyBlankWindowEnabled
=
false
;
static
HWND
sEarlyBlankWindowHandle
;
static
LPWSTR
const
gStockApplicationIcon
=
MAKEINTRESOURCEW
(
32512
)
;
typedef
BOOL
(
WINAPI
*
EnableNonClientDpiScalingProc
)
(
HWND
)
;
static
EnableNonClientDpiScalingProc
sEnableNonClientDpiScaling
=
NULL
;
typedef
int
(
WINAPI
*
GetSystemMetricsForDpiProc
)
(
int
UINT
)
;
GetSystemMetricsForDpiProc
sGetSystemMetricsForDpi
=
NULL
;
typedef
UINT
(
WINAPI
*
GetDpiForWindowProc
)
(
HWND
)
;
GetDpiForWindowProc
sGetDpiForWindow
=
NULL
;
#
if
WINVER
<
0x0605
WINUSERAPI
DPI_AWARENESS_CONTEXT
WINAPI
GetThreadDpiAwarenessContext
(
)
;
WINUSERAPI
BOOL
WINAPI
AreDpiAwarenessContextsEqual
(
DPI_AWARENESS_CONTEXT
DPI_AWARENESS_CONTEXT
)
;
#
endif
static
uint32_t
sWindowWidth
;
static
uint32_t
sWindowHeight
;
static
double
sCSSToDevPixelScaling
;
static
DWORD
sWindowStyle
=
WS_POPUP
;
static
DWORD
sWindowStyleEx
=
WS_EX_WINDOWEDGE
|
WS_EX_TOOLWINDOW
;
class
MOZ_RAII
AutoCloseRegKey
{
public
:
explicit
AutoCloseRegKey
(
HKEY
key
)
:
mKey
(
key
)
{
}
~
AutoCloseRegKey
(
)
{
:
:
RegCloseKey
(
mKey
)
;
}
private
:
HKEY
mKey
;
}
;
int
CSSToDevPixels
(
int
cssPixels
double
scaling
)
{
double
asDouble
=
(
double
)
cssPixels
*
scaling
;
return
floor
(
asDouble
+
0
.
5
)
;
}
struct
ColorRect
{
uint32_t
color
;
uint32_t
x
;
uint32_t
y
;
uint32_t
width
;
uint32_t
height
;
}
;
void
DrawSkeletonUI
(
HWND
hWnd
)
{
if
(
!
sGetSystemMetricsForDpi
|
|
!
sGetDpiForWindow
)
{
return
;
}
uint32_t
tabBarColor
=
0x202340
;
uint32_t
backgroundColor
=
0xf9f9fa
;
uint32_t
chromeContentDividerColor
=
0xe2e1e3
;
uint32_t
toolbarForegroundColor
=
0xe5e5e5
;
uint32_t
tabLineColor
=
0x0a75d3
;
int
chromeHorMargin
=
CSSToDevPixels
(
2
sCSSToDevPixelScaling
)
;
int
dpi
=
sGetDpiForWindow
(
hWnd
)
;
int
topOffset
=
sGetSystemMetricsForDpi
(
SM_CYBORDER
dpi
)
;
int
nonClientHorMargins
=
sGetSystemMetricsForDpi
(
SM_CXFRAME
dpi
)
+
sGetSystemMetricsForDpi
(
SM_CXPADDEDBORDER
dpi
)
;
int
horizontolOffset
=
nonClientHorMargins
-
chromeHorMargin
;
int
tabBarHeight
=
CSSToDevPixels
(
33
sCSSToDevPixelScaling
)
+
topOffset
;
int
titlebarSpacerWidth
=
CSSToDevPixels
(
40
sCSSToDevPixelScaling
)
+
horizontolOffset
;
int
tabLineHeight
=
CSSToDevPixels
(
2
sCSSToDevPixelScaling
)
+
topOffset
;
int
selectedTabWidth
=
CSSToDevPixels
(
224
sCSSToDevPixelScaling
)
;
int
toolbarHeight
=
CSSToDevPixels
(
39
sCSSToDevPixelScaling
)
;
int
tabPlaceholderBarMarginTop
=
CSSToDevPixels
(
13
sCSSToDevPixelScaling
)
;
int
tabPlaceholderBarMarginLeft
=
CSSToDevPixels
(
10
sCSSToDevPixelScaling
)
;
int
tabPlaceholderBarHeight
=
CSSToDevPixels
(
8
sCSSToDevPixelScaling
)
;
int
tabPlaceholderBarWidth
=
CSSToDevPixels
(
120
sCSSToDevPixelScaling
)
;
int
toolbarPlaceholderMarginTop
=
CSSToDevPixels
(
16
sCSSToDevPixelScaling
)
;
int
toolbarPlaceholderMarginLeft
=
CSSToDevPixels
(
9
sCSSToDevPixelScaling
)
;
int
toolbarPlaceholderMarginRight
=
CSSToDevPixels
(
11
sCSSToDevPixelScaling
)
;
int
toolbarPlaceholderWidth
=
CSSToDevPixels
(
90
sCSSToDevPixelScaling
)
;
int
toolbarPlaceholderHeight
=
CSSToDevPixels
(
10
sCSSToDevPixelScaling
)
;
ColorRect
tabBar
=
{
}
;
tabBar
.
color
=
tabBarColor
;
tabBar
.
x
=
0
;
tabBar
.
y
=
0
;
tabBar
.
width
=
sWindowWidth
;
tabBar
.
height
=
tabBarHeight
;
ColorRect
tabLine
=
{
}
;
tabLine
.
color
=
tabLineColor
;
tabLine
.
x
=
titlebarSpacerWidth
;
tabLine
.
y
=
0
;
tabLine
.
width
=
selectedTabWidth
;
tabLine
.
height
=
tabLineHeight
;
ColorRect
selectedTab
=
{
}
;
selectedTab
.
color
=
backgroundColor
;
selectedTab
.
x
=
titlebarSpacerWidth
;
selectedTab
.
y
=
tabLineHeight
;
selectedTab
.
width
=
selectedTabWidth
;
selectedTab
.
height
=
tabBarHeight
;
ColorRect
tabTextPlaceholder
=
{
}
;
tabTextPlaceholder
.
color
=
toolbarForegroundColor
;
tabTextPlaceholder
.
x
=
selectedTab
.
x
+
tabPlaceholderBarMarginLeft
;
tabTextPlaceholder
.
y
=
selectedTab
.
y
+
tabPlaceholderBarMarginTop
;
tabTextPlaceholder
.
width
=
tabPlaceholderBarWidth
;
tabTextPlaceholder
.
height
=
tabPlaceholderBarHeight
;
ColorRect
toolbar
=
{
}
;
toolbar
.
color
=
backgroundColor
;
toolbar
.
x
=
0
;
toolbar
.
y
=
tabBarHeight
;
toolbar
.
width
=
sWindowWidth
;
toolbar
.
height
=
toolbarHeight
;
ColorRect
leftToolbarPlaceholder
=
{
}
;
leftToolbarPlaceholder
.
color
=
toolbarForegroundColor
;
leftToolbarPlaceholder
.
x
=
toolbar
.
x
+
toolbarPlaceholderMarginLeft
+
horizontolOffset
;
leftToolbarPlaceholder
.
y
=
toolbar
.
y
+
toolbarPlaceholderMarginTop
;
leftToolbarPlaceholder
.
width
=
toolbarPlaceholderWidth
;
leftToolbarPlaceholder
.
height
=
toolbarPlaceholderHeight
;
ColorRect
rightToolbarPlaceholder
=
{
}
;
rightToolbarPlaceholder
.
color
=
toolbarForegroundColor
;
rightToolbarPlaceholder
.
x
=
sWindowWidth
-
horizontolOffset
-
toolbarPlaceholderMarginRight
-
toolbarPlaceholderWidth
;
rightToolbarPlaceholder
.
y
=
toolbar
.
y
+
toolbarPlaceholderMarginTop
;
rightToolbarPlaceholder
.
width
=
toolbarPlaceholderWidth
;
rightToolbarPlaceholder
.
height
=
toolbarPlaceholderHeight
;
ColorRect
chromeContentDivider
=
{
}
;
chromeContentDivider
.
color
=
chromeContentDividerColor
;
chromeContentDivider
.
x
=
0
;
chromeContentDivider
.
y
=
toolbar
.
y
+
toolbar
.
height
;
chromeContentDivider
.
width
=
sWindowWidth
;
chromeContentDivider
.
height
=
1
;
ColorRect
rects
[
]
=
{
tabBar
tabLine
selectedTab
tabTextPlaceholder
toolbar
leftToolbarPlaceholder
rightToolbarPlaceholder
chromeContentDivider
}
;
int
totalChromeHeight
=
chromeContentDivider
.
y
+
chromeContentDivider
.
height
;
uint32_t
*
pixelBuffer
=
(
uint32_t
*
)
calloc
(
sWindowWidth
*
totalChromeHeight
sizeof
(
uint32_t
)
)
;
for
(
int
i
=
0
;
i
<
sizeof
(
rects
)
/
sizeof
(
rects
[
0
]
)
;
+
+
i
)
{
ColorRect
rect
=
rects
[
i
]
;
for
(
int
y
=
rect
.
y
;
y
<
rect
.
y
+
rect
.
height
;
+
+
y
)
{
uint32_t
*
lineStart
=
&
pixelBuffer
[
y
*
sWindowWidth
]
;
uint32_t
*
dataStart
=
lineStart
+
rect
.
x
;
std
:
:
fill
(
dataStart
dataStart
+
rect
.
width
rect
.
color
)
;
}
}
HDC
hdc
=
:
:
GetWindowDC
(
hWnd
)
;
BITMAPINFO
chromeBMI
=
{
}
;
chromeBMI
.
bmiHeader
.
biSize
=
sizeof
(
chromeBMI
.
bmiHeader
)
;
chromeBMI
.
bmiHeader
.
biWidth
=
sWindowWidth
;
chromeBMI
.
bmiHeader
.
biHeight
=
-
totalChromeHeight
;
chromeBMI
.
bmiHeader
.
biPlanes
=
1
;
chromeBMI
.
bmiHeader
.
biBitCount
=
32
;
chromeBMI
.
bmiHeader
.
biCompression
=
BI_RGB
;
:
:
StretchDIBits
(
hdc
0
0
sWindowWidth
totalChromeHeight
0
0
sWindowWidth
totalChromeHeight
pixelBuffer
&
chromeBMI
DIB_RGB_COLORS
SRCCOPY
)
;
RECT
rect
=
{
0
totalChromeHeight
(
LONG
)
sWindowWidth
(
LONG
)
sWindowHeight
}
;
HBRUSH
brush
=
:
:
CreateSolidBrush
(
backgroundColor
)
;
:
:
FillRect
(
hdc
&
rect
brush
)
;
:
:
ReleaseDC
(
hWnd
hdc
)
;
free
(
pixelBuffer
)
;
}
LRESULT
WINAPI
EarlyBlankWindowProc
(
HWND
hWnd
UINT
msg
WPARAM
wParam
LPARAM
lParam
)
{
if
(
msg
=
=
WM_NCCREATE
&
&
sEnableNonClientDpiScaling
)
{
sEnableNonClientDpiScaling
(
hWnd
)
;
}
return
:
:
DefWindowProcW
(
hWnd
msg
wParam
lParam
)
;
}
bool
OpenEarlyBlankWindowRegKey
(
HKEY
&
key
)
{
DWORD
disposition
;
LSTATUS
result
=
:
:
RegCreateKeyExW
(
HKEY_CURRENT_USER
kEarlyBlankWindowKeyPath
0
nullptr
0
KEY_ALL_ACCESS
nullptr
&
key
&
disposition
)
;
if
(
result
!
=
ERROR_SUCCESS
)
{
return
false
;
}
if
(
disposition
=
=
REG_CREATED_NEW_KEY
)
{
return
false
;
}
if
(
disposition
=
=
REG_OPENED_EXISTING_KEY
)
{
return
true
;
}
:
:
RegCloseKey
(
key
)
;
return
false
;
}
void
CreateAndStoreEarlyBlankWindow
(
HINSTANCE
hInstance
)
{
HKEY
regKey
;
if
(
!
IsWin10OrLater
(
)
|
|
!
OpenEarlyBlankWindowRegKey
(
regKey
)
)
{
return
;
}
AutoCloseRegKey
closeKey
(
regKey
)
;
DWORD
dataLen
=
sizeof
(
uint32_t
)
;
uint32_t
enabled
;
LSTATUS
result
=
:
:
RegGetValueW
(
regKey
nullptr
L
"
enabled
"
RRF_RT_REG_DWORD
nullptr
reinterpret_cast
<
PBYTE
>
(
&
enabled
)
&
dataLen
)
;
if
(
result
!
=
ERROR_SUCCESS
|
|
enabled
=
=
0
)
{
return
;
}
sEarlyBlankWindowEnabled
=
true
;
HMODULE
user32Dll
=
:
:
GetModuleHandleW
(
L
"
user32
"
)
;
if
(
user32Dll
)
{
auto
getThreadDpiAwarenessContext
=
(
decltype
(
GetThreadDpiAwarenessContext
)
*
)
:
:
GetProcAddress
(
user32Dll
"
GetThreadDpiAwarenessContext
"
)
;
auto
areDpiAwarenessContextsEqual
=
(
decltype
(
AreDpiAwarenessContextsEqual
)
*
)
:
:
GetProcAddress
(
user32Dll
"
AreDpiAwarenessContextsEqual
"
)
;
if
(
getThreadDpiAwarenessContext
&
&
areDpiAwarenessContextsEqual
&
&
areDpiAwarenessContextsEqual
(
getThreadDpiAwarenessContext
(
)
DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE
)
)
{
sEnableNonClientDpiScaling
=
(
EnableNonClientDpiScalingProc
)
:
:
GetProcAddress
(
user32Dll
"
EnableNonClientDpiScaling
"
)
;
}
sGetSystemMetricsForDpi
=
(
GetSystemMetricsForDpiProc
)
:
:
GetProcAddress
(
user32Dll
"
GetSystemMetricsForDpi
"
)
;
sGetDpiForWindow
=
(
GetDpiForWindowProc
)
:
:
GetProcAddress
(
user32Dll
"
GetDpiForWindow
"
)
;
}
WNDCLASSW
wc
;
wc
.
style
=
CS_DBLCLKS
;
wc
.
lpfnWndProc
=
EarlyBlankWindowProc
;
wc
.
cbClsExtra
=
0
;
wc
.
cbWndExtra
=
0
;
wc
.
hInstance
=
hInstance
;
wc
.
hIcon
=
:
:
LoadIconW
(
:
:
GetModuleHandleW
(
nullptr
)
gStockApplicationIcon
)
;
wc
.
hCursor
=
:
:
LoadCursor
(
nullptr
IDC_WAIT
)
;
wc
.
hbrBackground
=
nullptr
;
wc
.
lpszMenuName
=
nullptr
;
wc
.
lpszClassName
=
L
"
MozillaWindowClass
"
;
if
(
!
:
:
RegisterClassW
(
&
wc
)
)
{
printf_stderr
(
"
RegisterClassW
error
%
lu
\
n
"
GetLastError
(
)
)
;
return
;
}
uint32_t
screenX
;
result
=
:
:
RegGetValueW
(
regKey
nullptr
L
"
screenX
"
RRF_RT_REG_DWORD
nullptr
reinterpret_cast
<
PBYTE
>
(
&
screenX
)
&
dataLen
)
;
if
(
result
!
=
ERROR_SUCCESS
)
{
printf_stderr
(
"
Error
reading
screenX
%
lu
\
n
"
GetLastError
(
)
)
;
return
;
}
uint32_t
screenY
;
result
=
:
:
RegGetValueW
(
regKey
nullptr
L
"
screenY
"
RRF_RT_REG_DWORD
nullptr
reinterpret_cast
<
PBYTE
>
(
&
screenY
)
&
dataLen
)
;
if
(
result
!
=
ERROR_SUCCESS
)
{
printf_stderr
(
"
Error
reading
screenY
%
lu
\
n
"
GetLastError
(
)
)
;
return
;
}
result
=
:
:
RegGetValueW
(
regKey
nullptr
L
"
width
"
RRF_RT_REG_DWORD
nullptr
reinterpret_cast
<
PBYTE
>
(
&
sWindowWidth
)
&
dataLen
)
;
if
(
result
!
=
ERROR_SUCCESS
)
{
printf_stderr
(
"
Error
reading
width
%
lu
\
n
"
GetLastError
(
)
)
;
return
;
}
result
=
:
:
RegGetValueW
(
regKey
nullptr
L
"
height
"
RRF_RT_REG_DWORD
nullptr
reinterpret_cast
<
PBYTE
>
(
&
sWindowHeight
)
&
dataLen
)
;
if
(
result
!
=
ERROR_SUCCESS
)
{
printf_stderr
(
"
Error
reading
height
%
lu
\
n
"
GetLastError
(
)
)
;
return
;
}
dataLen
=
sizeof
(
double
)
;
result
=
:
:
RegGetValueW
(
regKey
nullptr
L
"
cssToDevPixelScaling
"
RRF_RT_REG_BINARY
nullptr
reinterpret_cast
<
PBYTE
>
(
&
sCSSToDevPixelScaling
)
&
dataLen
)
;
if
(
result
!
=
ERROR_SUCCESS
|
|
dataLen
!
=
sizeof
(
double
)
)
{
printf_stderr
(
"
Error
reading
cssToDevPixelScaling
%
lu
\
n
"
GetLastError
(
)
)
;
return
;
}
sEarlyBlankWindowHandle
=
:
:
CreateWindowExW
(
sWindowStyleEx
L
"
MozillaWindowClass
"
L
"
"
sWindowStyle
screenX
screenY
sWindowWidth
sWindowHeight
nullptr
nullptr
hInstance
nullptr
)
;
:
:
ShowWindow
(
sEarlyBlankWindowHandle
SW_SHOWNORMAL
)
;
:
:
SetWindowPos
(
sEarlyBlankWindowHandle
0
0
0
0
0
SWP_FRAMECHANGED
|
SWP_NOACTIVATE
|
SWP_NOMOVE
|
SWP_NOOWNERZORDER
|
SWP_NOSIZE
|
SWP_NOZORDER
)
;
DrawSkeletonUI
(
sEarlyBlankWindowHandle
)
;
:
:
RedrawWindow
(
sEarlyBlankWindowHandle
NULL
NULL
RDW_INVALIDATE
)
;
}
HWND
ConsumeEarlyBlankWindowHandle
(
)
{
HWND
result
=
sEarlyBlankWindowHandle
;
sEarlyBlankWindowHandle
=
nullptr
;
return
result
;
}
void
PersistEarlyBlankWindowValues
(
int
screenX
int
screenY
int
width
int
height
double
cssToDevPixelScaling
)
{
if
(
!
sEarlyBlankWindowEnabled
)
{
return
;
}
HKEY
regKey
;
if
(
!
OpenEarlyBlankWindowRegKey
(
regKey
)
)
{
return
;
}
AutoCloseRegKey
closeKey
(
regKey
)
;
LSTATUS
result
;
result
=
:
:
RegSetValueExW
(
regKey
L
"
screenX
"
0
REG_DWORD
reinterpret_cast
<
PBYTE
>
(
&
screenX
)
sizeof
(
screenX
)
)
;
if
(
result
!
=
ERROR_SUCCESS
)
{
printf_stderr
(
"
Failed
persisting
screenX
to
Windows
registry
\
n
"
)
;
return
;
}
result
=
:
:
RegSetValueExW
(
regKey
L
"
screenY
"
0
REG_DWORD
reinterpret_cast
<
PBYTE
>
(
&
screenY
)
sizeof
(
screenY
)
)
;
if
(
result
!
=
ERROR_SUCCESS
)
{
printf_stderr
(
"
Failed
persisting
screenY
to
Windows
registry
\
n
"
)
;
return
;
}
result
=
:
:
RegSetValueExW
(
regKey
L
"
width
"
0
REG_DWORD
reinterpret_cast
<
PBYTE
>
(
&
width
)
sizeof
(
width
)
)
;
if
(
result
!
=
ERROR_SUCCESS
)
{
printf_stderr
(
"
Failed
persisting
width
to
Windows
registry
\
n
"
)
;
return
;
}
result
=
:
:
RegSetValueExW
(
regKey
L
"
height
"
0
REG_DWORD
reinterpret_cast
<
PBYTE
>
(
&
height
)
sizeof
(
height
)
)
;
if
(
result
!
=
ERROR_SUCCESS
)
{
printf_stderr
(
"
Failed
persisting
height
to
Windows
registry
\
n
"
)
;
return
;
}
result
=
:
:
RegSetValueExW
(
regKey
L
"
cssToDevPixelScaling
"
0
REG_BINARY
reinterpret_cast
<
PBYTE
>
(
&
cssToDevPixelScaling
)
sizeof
(
cssToDevPixelScaling
)
)
;
if
(
result
!
=
ERROR_SUCCESS
)
{
printf_stderr
(
"
Failed
persisting
cssToDevPixelScaling
to
Windows
registry
\
n
"
)
;
return
;
}
}
}
