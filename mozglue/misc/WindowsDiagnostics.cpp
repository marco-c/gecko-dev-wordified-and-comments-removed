#
include
"
mozilla
/
WindowsDiagnostics
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Types
.
h
"
#
include
<
windows
.
h
>
#
include
<
winternl
.
h
>
#
if
defined
(
_M_AMD64
)
namespace
mozilla
{
static
OnSingleStepCallback
sOnSingleStepCallback
{
}
;
static
void
*
sOnSingleStepCallbackState
=
nullptr
;
static
bool
sIsSingleStepping
=
false
;
MFBT_API
AutoOnSingleStepCallback
:
:
AutoOnSingleStepCallback
(
OnSingleStepCallback
aOnSingleStepCallback
void
*
aState
)
{
MOZ_RELEASE_ASSERT
(
!
sIsSingleStepping
&
&
!
sOnSingleStepCallback
&
&
!
sOnSingleStepCallbackState
"
Single
-
stepping
is
already
active
"
)
;
sOnSingleStepCallback
=
std
:
:
move
(
aOnSingleStepCallback
)
;
sOnSingleStepCallbackState
=
aState
;
sIsSingleStepping
=
true
;
}
MFBT_API
AutoOnSingleStepCallback
:
:
~
AutoOnSingleStepCallback
(
)
{
sOnSingleStepCallback
=
OnSingleStepCallback
(
)
;
sOnSingleStepCallbackState
=
nullptr
;
sIsSingleStepping
=
false
;
}
MFBT_API
MOZ_NEVER_INLINE
MOZ_NAKED
void
EnableTrapFlag
(
)
{
asm
volatile
(
"
pushfq
;
"
"
orw
0x100
(
%
rsp
)
;
"
"
popfq
;
"
"
retq
;
"
)
;
}
MFBT_API
MOZ_NEVER_INLINE
MOZ_NAKED
void
DisableTrapFlag
(
)
{
asm
volatile
(
"
retq
;
"
)
;
}
MFBT_API
LONG
SingleStepExceptionHandler
(
_EXCEPTION_POINTERS
*
aExceptionInfo
)
{
if
(
sIsSingleStepping
&
&
sOnSingleStepCallback
&
&
aExceptionInfo
-
>
ExceptionRecord
-
>
ExceptionCode
=
=
EXCEPTION_SINGLE_STEP
)
{
auto
instructionPointer
=
aExceptionInfo
-
>
ContextRecord
-
>
Rip
;
bool
keepOnSingleStepping
=
false
;
if
(
instructionPointer
!
=
reinterpret_cast
<
uintptr_t
>
(
&
DisableTrapFlag
)
)
{
keepOnSingleStepping
=
sOnSingleStepCallback
(
sOnSingleStepCallbackState
aExceptionInfo
-
>
ContextRecord
)
;
}
if
(
keepOnSingleStepping
)
{
aExceptionInfo
-
>
ContextRecord
-
>
EFlags
|
=
0x100
;
}
else
{
sIsSingleStepping
=
false
;
}
return
EXCEPTION_CONTINUE_EXECUTION
;
}
return
EXCEPTION_CONTINUE_SEARCH
;
}
}
#
endif
