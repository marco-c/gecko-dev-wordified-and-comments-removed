#
ifndef
mozilla_DynamicallyLinkedFunctionPtr_h
#
define
mozilla_DynamicallyLinkedFunctionPtr_h
#
include
"
mozilla
/
Move
.
h
"
#
include
<
windows
.
h
>
namespace
mozilla
{
template
<
typename
T
>
class
DynamicallyLinkedFunctionPtr
;
template
<
typename
R
typename
.
.
.
Args
>
class
DynamicallyLinkedFunctionPtr
<
R
(
__stdcall
*
)
(
Args
.
.
.
)
>
{
typedef
R
(
__stdcall
*
FunctionPtrT
)
(
Args
.
.
.
)
;
public
:
DynamicallyLinkedFunctionPtr
(
const
wchar_t
*
aLibName
const
char
*
aFuncName
)
:
mModule
(
NULL
)
mFunction
(
nullptr
)
{
mModule
=
:
:
LoadLibraryW
(
aLibName
)
;
if
(
mModule
)
{
mFunction
=
reinterpret_cast
<
FunctionPtrT
>
(
:
:
GetProcAddress
(
mModule
aFuncName
)
)
;
if
(
!
mFunction
)
{
:
:
FreeLibrary
(
mModule
)
;
mModule
=
NULL
;
}
}
}
DynamicallyLinkedFunctionPtr
(
const
DynamicallyLinkedFunctionPtr
&
)
=
delete
;
DynamicallyLinkedFunctionPtr
&
operator
=
(
const
DynamicallyLinkedFunctionPtr
&
)
=
delete
;
DynamicallyLinkedFunctionPtr
(
DynamicallyLinkedFunctionPtr
&
&
)
=
delete
;
DynamicallyLinkedFunctionPtr
&
operator
=
(
DynamicallyLinkedFunctionPtr
&
&
)
=
delete
;
~
DynamicallyLinkedFunctionPtr
(
)
{
if
(
mModule
)
{
:
:
FreeLibrary
(
mModule
)
;
}
}
R
operator
(
)
(
Args
.
.
.
args
)
const
{
return
mFunction
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
explicit
operator
bool
(
)
const
{
return
!
!
mFunction
;
}
private
:
HMODULE
mModule
;
FunctionPtrT
mFunction
;
}
;
}
#
endif
