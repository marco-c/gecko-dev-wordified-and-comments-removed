#
ifndef
mozilla_DynamicallyLinkedFunctionPtr_h
#
define
mozilla_DynamicallyLinkedFunctionPtr_h
#
include
<
windows
.
h
>
#
include
<
utility
>
#
include
"
mozilla
/
Attributes
.
h
"
namespace
mozilla
{
namespace
detail
{
template
<
typename
T
>
struct
FunctionPtrCracker
;
template
<
typename
R
typename
.
.
.
Args
>
struct
FunctionPtrCracker
<
R
(
*
)
(
Args
.
.
.
)
>
{
using
ReturnT
=
R
;
using
FunctionPtrT
=
R
(
*
)
(
Args
.
.
.
)
;
}
;
#
if
defined
(
_M_IX86
)
template
<
typename
R
typename
.
.
.
Args
>
struct
FunctionPtrCracker
<
R
(
__stdcall
*
)
(
Args
.
.
.
)
>
{
using
ReturnT
=
R
;
using
FunctionPtrT
=
R
(
__stdcall
*
)
(
Args
.
.
.
)
;
}
;
template
<
typename
R
typename
.
.
.
Args
>
struct
FunctionPtrCracker
<
R
(
__fastcall
*
)
(
Args
.
.
.
)
>
{
using
ReturnT
=
R
;
using
FunctionPtrT
=
R
(
__fastcall
*
)
(
Args
.
.
.
)
;
}
;
#
endif
template
<
typename
T
>
class
DynamicallyLinkedFunctionPtrBase
{
public
:
using
ReturnT
=
typename
FunctionPtrCracker
<
T
>
:
:
ReturnT
;
using
FunctionPtrT
=
typename
FunctionPtrCracker
<
T
>
:
:
FunctionPtrT
;
DynamicallyLinkedFunctionPtrBase
(
const
wchar_t
*
aLibName
const
char
*
aFuncName
)
:
mModule
(
:
:
LoadLibraryW
(
aLibName
)
)
mFunction
(
nullptr
)
{
if
(
!
mModule
)
{
return
;
}
mFunction
=
reinterpret_cast
<
FunctionPtrT
>
(
:
:
GetProcAddress
(
mModule
aFuncName
)
)
;
if
(
!
mFunction
)
{
:
:
FreeLibrary
(
mModule
)
;
mModule
=
nullptr
;
}
}
DynamicallyLinkedFunctionPtrBase
(
const
DynamicallyLinkedFunctionPtrBase
&
)
=
delete
;
DynamicallyLinkedFunctionPtrBase
&
operator
=
(
const
DynamicallyLinkedFunctionPtrBase
&
)
=
delete
;
DynamicallyLinkedFunctionPtrBase
(
DynamicallyLinkedFunctionPtrBase
&
&
)
=
delete
;
DynamicallyLinkedFunctionPtrBase
&
operator
=
(
DynamicallyLinkedFunctionPtrBase
&
&
)
=
delete
;
template
<
typename
.
.
.
Args
>
ReturnT
operator
(
)
(
Args
&
&
.
.
.
args
)
const
{
return
mFunction
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
explicit
operator
bool
(
)
const
{
return
!
!
mFunction
;
}
protected
:
HMODULE
mModule
;
FunctionPtrT
mFunction
;
}
;
}
template
<
typename
T
>
class
MOZ_STATIC_LOCAL_CLASS
StaticDynamicallyLinkedFunctionPtr
final
:
public
detail
:
:
DynamicallyLinkedFunctionPtrBase
<
T
>
{
public
:
StaticDynamicallyLinkedFunctionPtr
(
const
wchar_t
*
aLibName
const
char
*
aFuncName
)
:
detail
:
:
DynamicallyLinkedFunctionPtrBase
<
T
>
(
aLibName
aFuncName
)
{
}
operator
typename
detail
:
:
DynamicallyLinkedFunctionPtrBase
<
T
>
:
:
FunctionPtrT
(
)
const
{
return
this
-
>
mFunction
;
}
}
;
template
<
typename
T
>
class
MOZ_NON_PARAM
MOZ_NON_TEMPORARY_CLASS
DynamicallyLinkedFunctionPtr
final
:
public
detail
:
:
DynamicallyLinkedFunctionPtrBase
<
T
>
{
public
:
DynamicallyLinkedFunctionPtr
(
const
wchar_t
*
aLibName
const
char
*
aFuncName
)
:
detail
:
:
DynamicallyLinkedFunctionPtrBase
<
T
>
(
aLibName
aFuncName
)
{
}
~
DynamicallyLinkedFunctionPtr
(
)
{
if
(
!
this
-
>
mModule
)
{
return
;
}
:
:
FreeLibrary
(
this
-
>
mModule
)
;
}
}
;
}
#
endif
