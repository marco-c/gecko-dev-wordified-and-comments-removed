#
ifndef
mozilla_WindowsDiagnostics_h
#
define
mozilla_WindowsDiagnostics_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Types
.
h
"
#
if
!
defined
(
IMPL_MFBT
)
#
include
"
mozilla
/
NativeNt
.
h
"
#
endif
#
include
<
windows
.
h
>
#
include
<
winternl
.
h
>
#
include
<
functional
>
namespace
mozilla
{
enum
class
WindowsDiagnosticsError
:
uint32_t
{
None
InternalFailure
DebuggerPresent
ModuleNotFound
BadModule
}
;
struct
WinErrorState
{
DWORD
error
=
~
0
;
NTSTATUS
ntStatus
=
~
0
;
private
:
constexpr
static
size_t
kLastNtStatusOffset
=
sizeof
(
size_t
)
=
=
8
?
0x1250
:
0xbf4
;
static
void
SetLastNtStatus
(
NTSTATUS
status
)
{
auto
*
teb
=
:
:
NtCurrentTeb
(
)
;
*
reinterpret_cast
<
NTSTATUS
*
>
(
reinterpret_cast
<
char
*
>
(
teb
)
+
kLastNtStatusOffset
)
=
status
;
}
static
NTSTATUS
GetLastNtStatus
(
)
{
auto
const
*
teb
=
:
:
NtCurrentTeb
(
)
;
return
*
reinterpret_cast
<
NTSTATUS
const
*
>
(
reinterpret_cast
<
char
const
*
>
(
teb
)
+
kLastNtStatusOffset
)
;
}
public
:
static
void
Apply
(
WinErrorState
const
&
state
)
{
SetLastNtStatus
(
state
.
ntStatus
)
;
:
:
SetLastError
(
state
.
error
)
;
}
static
void
Clear
(
)
{
Apply
(
{
.
error
=
0
.
ntStatus
=
0
}
)
;
}
static
WinErrorState
Get
(
)
{
return
WinErrorState
{
.
error
=
:
:
GetLastError
(
)
.
ntStatus
=
GetLastNtStatus
(
)
}
;
}
bool
operator
=
=
(
WinErrorState
const
&
that
)
const
{
return
this
-
>
error
=
=
that
.
error
&
&
this
-
>
ntStatus
=
=
that
.
ntStatus
;
}
bool
operator
!
=
(
WinErrorState
const
&
that
)
const
{
return
!
operator
=
=
(
that
)
;
}
}
;
#
if
defined
(
MOZ_DIAGNOSTIC_ASSERT_ENABLED
)
&
&
defined
(
_M_X64
)
using
OnSingleStepCallback
=
std
:
:
function
<
bool
(
void
*
CONTEXT
*
)
>
;
class
MOZ_RAII
AutoOnSingleStepCallback
{
public
:
MFBT_API
AutoOnSingleStepCallback
(
OnSingleStepCallback
aOnSingleStepCallback
void
*
aState
)
;
MFBT_API
~
AutoOnSingleStepCallback
(
)
;
AutoOnSingleStepCallback
(
const
AutoOnSingleStepCallback
&
)
=
delete
;
AutoOnSingleStepCallback
(
AutoOnSingleStepCallback
&
&
)
=
delete
;
AutoOnSingleStepCallback
&
operator
=
(
const
AutoOnSingleStepCallback
&
)
=
delete
;
AutoOnSingleStepCallback
&
operator
=
(
AutoOnSingleStepCallback
&
&
)
=
delete
;
}
;
MFBT_API
MOZ_NEVER_INLINE
__attribute__
(
(
naked
)
)
void
EnableTrapFlag
(
)
;
MFBT_API
MOZ_NEVER_INLINE
__attribute__
(
(
naked
)
)
void
DisableTrapFlag
(
)
;
MFBT_API
LONG
SingleStepExceptionHandler
(
_EXCEPTION_POINTERS
*
aExceptionInfo
)
;
#
if
!
defined
(
IMPL_MFBT
)
template
<
typename
CallbackToRun
>
[
[
clang
:
:
optnone
]
]
MOZ_NEVER_INLINE
WindowsDiagnosticsError
CollectSingleStepData
(
CallbackToRun
aCallbackToRun
OnSingleStepCallback
aOnSingleStepCallback
void
*
aOnSingleStepCallbackState
)
{
if
(
:
:
IsDebuggerPresent
(
)
)
{
return
WindowsDiagnosticsError
:
:
DebuggerPresent
;
}
AutoOnSingleStepCallback
setCallback
(
std
:
:
move
(
aOnSingleStepCallback
)
aOnSingleStepCallbackState
)
;
auto
veh
=
:
:
AddVectoredExceptionHandler
(
TRUE
SingleStepExceptionHandler
)
;
if
(
!
veh
)
{
return
WindowsDiagnosticsError
:
:
InternalFailure
;
}
EnableTrapFlag
(
)
;
aCallbackToRun
(
)
;
DisableTrapFlag
(
)
;
:
:
RemoveVectoredExceptionHandler
(
veh
)
;
return
WindowsDiagnosticsError
:
:
None
;
}
template
<
int
NMaxSteps
int
NMaxErrorStates
>
struct
ModuleSingleStepData
{
uint32_t
mStepsLog
[
NMaxSteps
]
{
}
;
WinErrorState
mErrorStatesLog
[
NMaxErrorStates
]
{
}
;
uint16_t
mStepsAtErrorState
[
NMaxErrorStates
]
{
}
;
}
;
template
<
int
NMaxSteps
int
NMaxErrorStates
>
struct
ModuleSingleStepState
{
uintptr_t
mModuleStart
;
uintptr_t
mModuleEnd
;
uint32_t
mSteps
;
uint32_t
mErrorStates
;
WinErrorState
mLastRecordedErrorState
;
ModuleSingleStepData
<
NMaxSteps
NMaxErrorStates
>
mData
;
ModuleSingleStepState
(
uintptr_t
aModuleStart
uintptr_t
aModuleEnd
)
:
mModuleStart
{
aModuleStart
}
mModuleEnd
{
aModuleEnd
}
mSteps
{
}
mErrorStates
{
}
mLastRecordedErrorState
{
}
mData
{
}
{
}
}
;
namespace
InstructionFilter
{
inline
bool
All
(
const
uint8_t
*
aInstructionPointer
)
{
return
true
;
}
inline
bool
CallRet
(
const
uint8_t
*
aInstructionPointer
)
{
auto
firstByte
=
aInstructionPointer
[
0
]
;
if
(
firstByte
=
=
0xe8
)
{
return
true
;
}
else
if
(
firstByte
=
=
0xff
)
{
auto
secondByte
=
aInstructionPointer
[
1
]
;
if
(
(
secondByte
&
0x38
)
=
=
0x10
)
{
return
true
;
}
}
else
if
(
firstByte
=
=
0xc3
)
{
return
true
;
}
else
if
(
firstByte
=
=
0xc2
)
{
return
true
;
}
return
false
;
}
}
template
<
int
NMaxSteps
int
NMaxErrorStates
typename
CallbackToRun
typename
PostCollectionCallback
typename
InstructionFilterCallback
=
decltype
(
&
InstructionFilter
:
:
All
)
>
WindowsDiagnosticsError
CollectModuleSingleStepData
(
const
wchar_t
*
aModulePath
CallbackToRun
aCallbackToRun
PostCollectionCallback
aPostCollectionCallback
InstructionFilterCallback
aInstructionFilter
=
InstructionFilter
:
:
All
)
{
HANDLE
mod
=
:
:
GetModuleHandleW
(
aModulePath
)
;
if
(
!
mod
)
{
return
WindowsDiagnosticsError
:
:
ModuleNotFound
;
}
nt
:
:
PEHeaders
headers
{
mod
}
;
auto
maybeBounds
=
headers
.
GetBounds
(
)
;
if
(
maybeBounds
.
isNothing
(
)
)
{
return
WindowsDiagnosticsError
:
:
BadModule
;
}
auto
&
bounds
=
maybeBounds
.
ref
(
)
;
using
State
=
ModuleSingleStepState
<
NMaxSteps
NMaxErrorStates
>
;
State
state
{
reinterpret_cast
<
uintptr_t
>
(
bounds
.
begin
(
)
.
get
(
)
)
reinterpret_cast
<
uintptr_t
>
(
bounds
.
end
(
)
.
get
(
)
)
}
;
WindowsDiagnosticsError
rv
=
CollectSingleStepData
(
std
:
:
move
(
aCallbackToRun
)
[
&
aInstructionFilter
]
(
void
*
aState
CONTEXT
*
aContextRecord
)
-
>
bool
{
auto
&
state
=
*
reinterpret_cast
<
State
*
>
(
aState
)
;
auto
instructionPointer
=
aContextRecord
-
>
Rip
;
if
(
state
.
mModuleStart
<
=
instructionPointer
&
&
instructionPointer
<
state
.
mModuleEnd
&
&
aInstructionFilter
(
reinterpret_cast
<
const
uint8_t
*
>
(
instructionPointer
)
)
)
{
if
(
state
.
mSteps
<
NMaxSteps
)
{
state
.
mData
.
mStepsLog
[
state
.
mSteps
]
=
static_cast
<
uint32_t
>
(
instructionPointer
-
state
.
mModuleStart
)
;
}
auto
currentErrorState
{
WinErrorState
:
:
Get
(
)
}
;
if
(
currentErrorState
!
=
state
.
mLastRecordedErrorState
)
{
state
.
mLastRecordedErrorState
=
currentErrorState
;
if
(
state
.
mErrorStates
<
NMaxErrorStates
)
{
state
.
mData
.
mErrorStatesLog
[
state
.
mErrorStates
]
=
currentErrorState
;
state
.
mData
.
mStepsAtErrorState
[
state
.
mErrorStates
]
=
state
.
mSteps
;
}
+
+
state
.
mErrorStates
;
}
+
+
state
.
mSteps
;
}
return
true
;
}
reinterpret_cast
<
void
*
>
(
&
state
)
)
;
if
(
rv
!
=
WindowsDiagnosticsError
:
:
None
)
{
return
rv
;
}
aPostCollectionCallback
(
state
.
mData
)
;
return
WindowsDiagnosticsError
:
:
None
;
}
#
endif
#
endif
}
#
endif
