#
ifndef
mozilla_interceptor_PatcherBase_h
#
define
mozilla_interceptor_PatcherBase_h
#
include
"
mozilla
/
interceptor
/
TargetFunction
.
h
"
namespace
mozilla
{
namespace
interceptor
{
template
<
typename
MMPolicy
>
struct
GetProcAddressSelector
;
template
<
>
struct
GetProcAddressSelector
<
MMPolicyOutOfProcess
>
{
FARPROC
operator
(
)
(
HMODULE
aModule
const
char
*
aName
const
MMPolicyOutOfProcess
&
aMMPolicy
)
const
{
auto
exportSection
=
mozilla
:
:
nt
:
:
PEExportSection
<
MMPolicyOutOfProcess
>
:
:
Get
(
aModule
aMMPolicy
)
;
return
exportSection
.
GetProcAddress
(
aName
)
;
}
}
;
template
<
>
struct
GetProcAddressSelector
<
MMPolicyInProcess
>
{
FARPROC
operator
(
)
(
HMODULE
aModule
const
char
*
aName
const
MMPolicyInProcess
&
)
const
{
return
:
:
GetProcAddress
(
aModule
aName
)
;
}
}
;
template
<
typename
VMPolicy
>
class
WindowsDllPatcherBase
{
protected
:
typedef
typename
VMPolicy
:
:
MMPolicyT
MMPolicyT
;
template
<
typename
.
.
.
Args
>
explicit
WindowsDllPatcherBase
(
Args
&
&
.
.
.
aArgs
)
:
mVMPolicy
(
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
{
}
ReadOnlyTargetFunction
<
MMPolicyT
>
ResolveRedirectedAddress
(
FARPROC
aOriginalFunction
)
{
uintptr_t
currAddr
=
reinterpret_cast
<
uintptr_t
>
(
aOriginalFunction
)
;
#
if
defined
(
_M_IX86
)
|
|
defined
(
_M_X64
)
uintptr_t
prevAddr
=
0
;
while
(
prevAddr
!
=
currAddr
)
{
ReadOnlyTargetFunction
<
MMPolicyT
>
currFunc
(
mVMPolicy
currAddr
)
;
prevAddr
=
currAddr
;
uintptr_t
nextAddr
=
0
;
if
(
currFunc
.
IsRelativeShortJump
(
&
nextAddr
)
)
{
int8_t
offset
=
nextAddr
-
currFunc
.
GetAddress
(
)
-
2
;
#
if
defined
(
_M_X64
)
if
(
(
offset
<
0
)
&
&
(
currFunc
.
IsValidAtOffset
(
2
+
offset
)
)
)
{
ReadOnlyTargetFunction
<
MMPolicyT
>
redirectFn
(
mVMPolicy
nextAddr
)
;
if
(
redirectFn
.
IsIndirectNearJump
(
&
nextAddr
)
)
{
return
redirectFn
;
}
}
#
endif
if
(
offset
>
0
)
{
bool
isNopSpace
=
true
;
for
(
int8_t
i
=
0
;
i
<
offset
;
i
+
+
)
{
if
(
currFunc
[
2
+
i
]
!
=
0x90
)
{
isNopSpace
=
false
;
break
;
}
}
if
(
isNopSpace
)
{
currAddr
=
nextAddr
;
}
}
#
if
defined
(
_M_X64
)
}
else
if
(
currFunc
.
IsIndirectNearJump
(
&
nextAddr
)
|
|
currFunc
.
IsRelativeNearJump
(
&
nextAddr
)
)
{
#
else
}
else
if
(
currFunc
.
IsIndirectNearJump
(
&
nextAddr
)
)
{
#
endif
currAddr
=
nextAddr
;
}
}
#
endif
if
(
currAddr
!
=
reinterpret_cast
<
uintptr_t
>
(
aOriginalFunction
)
&
&
!
mVMPolicy
.
IsPageAccessible
(
currAddr
)
)
{
currAddr
=
reinterpret_cast
<
uintptr_t
>
(
aOriginalFunction
)
;
}
return
ReadOnlyTargetFunction
<
MMPolicyT
>
(
mVMPolicy
currAddr
)
;
}
public
:
FARPROC
GetProcAddress
(
HMODULE
aModule
const
char
*
aName
)
const
{
GetProcAddressSelector
<
MMPolicyT
>
selector
;
return
selector
(
aModule
aName
mVMPolicy
)
;
}
bool
IsPageAccessible
(
uintptr_t
aAddress
)
const
{
return
mVMPolicy
.
IsPageAccessible
(
aAddress
)
;
}
#
if
defined
(
NIGHTLY_BUILD
)
const
Maybe
<
DetourError
>
&
GetLastError
(
)
const
{
return
mVMPolicy
.
GetLastError
(
)
;
}
#
endif
template
<
typename
.
.
.
Args
>
void
SetLastError
(
Args
&
&
.
.
.
aArgs
)
{
mVMPolicy
.
SetLastError
(
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
;
}
protected
:
VMPolicy
mVMPolicy
;
}
;
}
}
#
endif
