#
ifndef
mozilla_interceptor_PatcherNopSpace_h
#
define
mozilla_interceptor_PatcherNopSpace_h
#
if
defined
(
_M_IX86
)
#
include
"
mozilla
/
interceptor
/
PatcherBase
.
h
"
namespace
mozilla
{
namespace
interceptor
{
template
<
typename
VMPolicy
>
class
WindowsDllNopSpacePatcher
final
:
public
WindowsDllPatcherBase
<
VMPolicy
>
{
typedef
typename
VMPolicy
:
:
MMPolicyT
MMPolicyT
;
mozilla
:
:
Vector
<
void
*
>
mPatchedFns
;
public
:
template
<
typename
.
.
.
Args
>
explicit
WindowsDllNopSpacePatcher
(
Args
.
.
.
aArgs
)
:
WindowsDllPatcherBase
<
VMPolicy
>
(
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
{
}
~
WindowsDllNopSpacePatcher
(
)
{
Clear
(
)
;
}
WindowsDllNopSpacePatcher
(
const
WindowsDllNopSpacePatcher
&
)
=
delete
;
WindowsDllNopSpacePatcher
(
WindowsDllNopSpacePatcher
&
&
)
=
delete
;
WindowsDllNopSpacePatcher
&
operator
=
(
const
WindowsDllNopSpacePatcher
&
)
=
delete
;
WindowsDllNopSpacePatcher
&
operator
=
(
WindowsDllNopSpacePatcher
&
&
)
=
delete
;
void
Clear
(
)
{
for
(
auto
&
&
ptr
:
mPatchedFns
)
{
WritableTargetFunction
<
MMPolicyT
>
fn
(
mVMPolicy
reinterpret_cast
<
uintptr_t
>
(
ptr
)
sizeof
(
uint16_t
)
)
;
if
(
!
fn
)
{
continue
;
}
fn
.
CommitAndWriteShort
(
0xff8b
)
;
}
mPatchedFns
.
clear
(
)
;
}
static
bool
IsCompatible
(
)
{
const
wchar_t
*
kIncompatibleDLLs
[
]
=
{
L
"
detoured
.
dll
"
L
"
_etoured
.
dll
"
L
"
nvd3d9wrap
.
dll
"
L
"
nvdxgiwrap
.
dll
"
}
;
for
(
unsigned
int
i
=
0
;
i
<
mozilla
:
:
ArrayLength
(
kIncompatibleDLLs
)
;
+
+
i
)
{
if
(
GetModuleHandleW
(
kIncompatibleDLLs
[
i
]
)
)
{
return
false
;
}
}
if
(
GetModuleHandleW
(
L
"
user32
.
dll
"
)
)
{
return
true
;
}
HKEY
hkey
=
NULL
;
if
(
!
RegOpenKeyExW
(
HKEY_LOCAL_MACHINE
L
"
SOFTWARE
\
\
Microsoft
\
\
Windows
NT
\
\
CurrentVersion
\
\
Windows
"
0
KEY_QUERY_VALUE
&
hkey
)
)
{
nsAutoRegKey
key
(
hkey
)
;
DWORD
numBytes
=
0
;
const
wchar_t
kAppInitDLLs
[
]
=
L
"
AppInit_DLLs
"
;
LONG
status
=
RegQueryValueExW
(
hkey
kAppInitDLLs
nullptr
nullptr
nullptr
&
numBytes
)
;
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
data
;
if
(
!
status
)
{
data
=
mozilla
:
:
MakeUnique
<
wchar_t
[
]
>
(
(
numBytes
+
1
)
/
sizeof
(
wchar_t
)
)
;
status
=
RegQueryValueExW
(
hkey
kAppInitDLLs
nullptr
nullptr
(
LPBYTE
)
data
.
get
(
)
&
numBytes
)
;
}
if
(
!
status
)
{
const
wchar_t
kDelimiters
[
]
=
L
"
"
;
wchar_t
*
tokenContext
=
nullptr
;
wchar_t
*
token
=
wcstok_s
(
data
.
get
(
)
kDelimiters
&
tokenContext
)
;
while
(
token
)
{
wchar_t
fname
[
_MAX_FNAME
]
=
{
0
}
;
if
(
!
_wsplitpath_s
(
token
nullptr
0
nullptr
0
fname
mozilla
:
:
ArrayLength
(
fname
)
nullptr
0
)
)
{
const
wchar_t
kNvInitName
[
]
=
L
"
nvinit
"
;
if
(
!
_wcsnicmp
(
fname
kNvInitName
mozilla
:
:
ArrayLength
(
kNvInitName
)
)
)
{
return
false
;
}
}
token
=
wcstok_s
(
nullptr
kDelimiters
&
tokenContext
)
;
}
}
}
return
true
;
}
bool
AddHook
(
FARPROC
aTargetFn
intptr_t
aHookDest
void
*
*
aOrigFunc
)
{
if
(
!
IsCompatible
(
)
)
{
#
if
defined
(
MOZILLA_INTERNAL_API
)
NS_WARNING
(
"
NOP
space
patching
is
unavailable
for
compatibility
reasons
"
)
;
#
endif
return
false
;
}
MOZ_ASSERT
(
aTargetFn
)
;
if
(
!
aTargetFn
)
{
return
false
;
}
ReadOnlyTargetFunction
<
MMPolicyT
>
readOnlyTargetFn
(
ResolveRedirectedAddress
(
aTargetFn
)
)
;
if
(
!
WriteHook
(
readOnlyTargetFn
aHookDest
aOrigFunc
)
)
{
return
false
;
}
mPatchedFns
.
append
(
reinterpret_cast
<
void
*
>
(
readOnlyTargetFn
.
GetBaseAddress
(
)
)
)
;
return
true
;
}
bool
WriteHook
(
const
ReadOnlyTargetFunction
<
MMPolicyT
>
&
aFn
intptr_t
aHookDest
void
*
*
aOrigFunc
)
{
WritableTargetFunction
<
MMPolicyT
>
writableFn
(
aFn
.
Promote
(
7
-
5
)
)
;
if
(
!
writableFn
)
{
return
false
;
}
const
uint8_t
nopOrBp
[
]
=
{
0x90
0xCC
}
;
if
(
!
writableFn
.
VerifyValuesAreOneOf
<
uint8_t
5
>
(
nopOrBp
)
)
{
return
false
;
}
const
uint16_t
possibleEncodings
[
]
=
{
0xFF8B
0xFF89
}
;
if
(
!
writableFn
.
VerifyValuesAreOneOf
<
uint16_t
1
>
(
possibleEncodings
5
)
)
{
return
false
;
}
writableFn
.
WriteByte
(
0xe9
)
;
if
(
!
writableFn
)
{
return
false
;
}
writableFn
.
WriteDisp32
(
aHookDest
)
;
if
(
!
writableFn
)
{
return
false
;
}
*
aOrigFunc
=
reinterpret_cast
<
void
*
>
(
writableFn
.
GetCurrentAddress
(
)
+
sizeof
(
uint16_t
)
)
;
return
writableFn
.
CommitAndWriteShort
(
0xF9EB
)
;
}
}
;
}
}
#
endif
#
endif
