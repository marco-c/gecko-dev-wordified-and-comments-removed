#
ifndef
mozilla_interceptor_PatcherDetour_h
#
define
mozilla_interceptor_PatcherDetour_h
#
include
"
mozilla
/
interceptor
/
PatcherBase
.
h
"
#
include
"
mozilla
/
interceptor
/
Trampoline
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
define
COPY_CODES
(
NBYTES
)
do
{
\
tramp
.
CopyFrom
(
origBytes
.
GetAddress
(
)
NBYTES
)
;
\
origBytes
+
=
NBYTES
;
\
}
while
(
0
)
namespace
mozilla
{
namespace
interceptor
{
template
<
typename
VMPolicy
>
class
WindowsDllDetourPatcher
final
:
public
WindowsDllPatcherBase
<
VMPolicy
>
{
public
:
template
<
typename
.
.
.
Args
>
explicit
WindowsDllDetourPatcher
(
Args
.
.
.
aArgs
)
:
WindowsDllPatcherBase
<
VMPolicy
>
(
mozilla
:
:
Forward
<
Args
>
(
aArgs
)
.
.
.
)
{
}
~
WindowsDllDetourPatcher
(
)
{
Clear
(
)
;
}
WindowsDllDetourPatcher
(
const
WindowsDllDetourPatcher
&
)
=
delete
;
WindowsDllDetourPatcher
(
WindowsDllDetourPatcher
&
&
)
=
delete
;
WindowsDllDetourPatcher
&
operator
=
(
const
WindowsDllDetourPatcher
&
)
=
delete
;
WindowsDllDetourPatcher
&
operator
=
(
WindowsDllDetourPatcher
&
&
)
=
delete
;
void
Clear
(
)
{
if
(
!
mVMPolicy
.
ShouldUnhookUponDestruction
(
)
)
{
return
;
}
#
if
defined
(
_M_IX86
)
size_t
nBytes
=
1
+
sizeof
(
intptr_t
)
;
#
elif
defined
(
_M_X64
)
size_t
nBytes
=
2
+
sizeof
(
intptr_t
)
;
#
else
#
error
"
Unknown
processor
type
"
#
endif
const
auto
&
tramps
=
mVMPolicy
.
Items
(
)
;
for
(
auto
&
&
tramp
:
tramps
)
{
Maybe
<
uintptr_t
>
instance
=
tramp
.
ReadEncodedPointer
(
)
;
if
(
!
instance
)
{
continue
;
}
if
(
instance
.
value
(
)
!
=
reinterpret_cast
<
uintptr_t
>
(
this
)
)
{
continue
;
}
auto
clearInstance
=
MakeScopeExit
(
[
&
tramp
]
(
)
-
>
void
{
tramp
.
Rewind
(
)
;
tramp
.
WriteEncodedPointer
(
nullptr
)
;
}
)
;
Maybe
<
uintptr_t
>
interceptedFn
=
tramp
.
ReadEncodedPointer
(
)
;
if
(
!
interceptedFn
)
{
continue
;
}
WritableTargetFunction
<
MMPolicyT
>
origBytes
(
mVMPolicy
interceptedFn
.
value
(
)
nBytes
)
;
if
(
!
origBytes
)
{
continue
;
}
Maybe
<
uint8_t
>
maybeOpcode1
=
origBytes
.
ReadByte
(
)
;
if
(
!
maybeOpcode1
)
{
continue
;
}
uint8_t
opcode1
=
maybeOpcode1
.
value
(
)
;
#
if
defined
(
_M_IX86
)
MOZ_ASSERT
(
opcode1
=
=
0xE9
)
;
if
(
opcode1
!
=
0xE9
)
{
continue
;
}
intptr_t
startOfTrampInstructions
=
static_cast
<
intptr_t
>
(
tramp
.
GetCurrentRemoteAddress
(
)
)
;
origBytes
.
WriteDisp32
(
startOfTrampInstructions
)
;
if
(
!
origBytes
)
{
continue
;
}
#
elif
defined
(
_M_X64
)
MOZ_ASSERT
(
opcode1
=
=
0x49
)
;
if
(
opcode1
!
=
0x49
)
{
continue
;
}
Maybe
<
uint8_t
>
maybeOpcode2
=
origBytes
.
ReadByte
(
)
;
if
(
!
maybeOpcode2
)
{
continue
;
}
uint8_t
opcode2
=
maybeOpcode2
.
value
(
)
;
if
(
opcode2
!
=
0xBB
)
{
continue
;
}
origBytes
.
WritePointer
(
tramp
.
GetCurrentRemoteAddress
(
)
)
;
if
(
!
origBytes
)
{
continue
;
}
#
else
#
error
"
Unknown
processor
type
"
#
endif
origBytes
.
Commit
(
)
;
}
mVMPolicy
.
Clear
(
)
;
}
void
Init
(
int
aNumHooks
=
0
)
{
if
(
Initialized
(
)
)
{
return
;
}
if
(
aNumHooks
=
=
0
)
{
aNumHooks
=
mVMPolicy
.
GetAllocGranularity
(
)
/
kHookSize
;
}
mVMPolicy
.
Reserve
(
aNumHooks
)
;
}
bool
Initialized
(
)
const
{
return
!
!
mVMPolicy
;
}
bool
AddHook
(
FARPROC
aTargetFn
intptr_t
aHookDest
void
*
*
aOrigFunc
)
{
ReadOnlyTargetFunction
<
MMPolicyT
>
target
(
ResolveRedirectedAddress
(
aTargetFn
)
)
;
CreateTrampoline
(
target
aHookDest
aOrigFunc
)
;
if
(
!
*
aOrigFunc
)
{
return
false
;
}
return
true
;
}
protected
:
const
static
int
kPageSize
=
4096
;
const
static
int
kHookSize
=
128
;
static
const
BYTE
kMaskHighNibble
=
0xF0
;
static
const
BYTE
kRexOpcode
=
0x40
;
static
const
BYTE
kMaskRexW
=
0x08
;
static
const
BYTE
kMaskRexR
=
0x04
;
static
const
BYTE
kMaskRexX
=
0x02
;
static
const
BYTE
kMaskRexB
=
0x01
;
static
const
BYTE
kRegFieldShift
=
3
;
static
const
BYTE
kMaskMod
=
0xC0
;
static
const
BYTE
kMaskReg
=
0x38
;
static
const
BYTE
kMaskRm
=
0x07
;
static
const
BYTE
kRmNeedSib
=
0x04
;
static
const
BYTE
kModReg
=
0xC0
;
static
const
BYTE
kModDisp32
=
0x80
;
static
const
BYTE
kModDisp8
=
0x40
;
static
const
BYTE
kModNoRegDisp
=
0x00
;
static
const
BYTE
kRmNoRegDispDisp32
=
0x05
;
static
const
BYTE
kMaskSibScale
=
0xC0
;
static
const
BYTE
kMaskSibIndex
=
0x38
;
static
const
BYTE
kMaskSibBase
=
0x07
;
static
const
BYTE
kSibBaseEbp
=
0x05
;
static
const
BYTE
kRegAx
=
0x0
;
static
const
BYTE
kRegCx
=
0x1
;
static
const
BYTE
kRegDx
=
0x2
;
static
const
BYTE
kRegBx
=
0x3
;
static
const
BYTE
kRegSp
=
0x4
;
static
const
BYTE
kRegBp
=
0x5
;
static
const
BYTE
kRegSi
=
0x6
;
static
const
BYTE
kRegDi
=
0x7
;
static
const
int
kModOperand64
=
-
2
;
static
const
int
kModUnknown
=
-
1
;
int
CountModRmSib
(
const
ReadOnlyTargetFunction
<
MMPolicyT
>
&
aModRm
BYTE
*
aSubOpcode
=
nullptr
)
{
int
numBytes
=
1
;
switch
(
*
aModRm
&
kMaskMod
)
{
case
kModReg
:
return
numBytes
;
case
kModDisp8
:
numBytes
+
=
1
;
break
;
case
kModDisp32
:
numBytes
+
=
4
;
break
;
case
kModNoRegDisp
:
if
(
(
*
aModRm
&
kMaskRm
)
=
=
kRmNoRegDispDisp32
)
{
#
if
defined
(
_M_X64
)
if
(
aSubOpcode
)
{
*
aSubOpcode
=
(
*
aModRm
&
kMaskReg
)
>
>
kRegFieldShift
;
}
return
kModOperand64
;
#
else
numBytes
+
=
4
;
#
endif
}
else
if
(
(
(
*
aModRm
&
kMaskRm
)
=
=
kRmNeedSib
&
&
(
*
(
aModRm
+
1
)
&
kMaskSibBase
)
=
=
kSibBaseEbp
)
)
{
numBytes
+
=
4
;
}
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Impossible
value
for
modr
/
m
byte
mod
bits
"
)
;
return
kModUnknown
;
}
if
(
(
*
aModRm
&
kMaskRm
)
=
=
kRmNeedSib
)
{
numBytes
+
=
1
;
}
if
(
aSubOpcode
)
{
*
aSubOpcode
=
(
*
aModRm
&
kMaskReg
)
>
>
kRegFieldShift
;
}
return
numBytes
;
}
#
if
defined
(
_M_X64
)
enum
class
JumpType
{
Je
Jne
Jmp
Call
}
;
static
bool
GenerateJump
(
Trampoline
<
MMPolicyT
>
&
aTramp
uintptr_t
aAbsTargetAddress
const
JumpType
aType
)
{
if
(
aType
=
=
JumpType
:
:
Call
)
{
aTramp
.
WriteByte
(
0xff
)
;
aTramp
.
WriteByte
(
0x15
)
;
aTramp
.
WriteInteger
(
2
)
;
aTramp
.
WriteByte
(
0xeb
)
;
aTramp
.
WriteByte
(
8
)
;
aTramp
.
WritePointer
(
aAbsTargetAddress
)
;
return
!
!
aTramp
;
}
if
(
aType
=
=
JumpType
:
:
Je
)
{
aTramp
.
WriteByte
(
0x75
)
;
aTramp
.
WriteByte
(
14
)
;
}
else
if
(
aType
=
=
JumpType
:
:
Jne
)
{
aTramp
.
WriteByte
(
0x74
)
;
aTramp
.
WriteByte
(
14
)
;
}
aTramp
.
WriteByte
(
0xff
)
;
aTramp
.
WriteByte
(
0x25
)
;
aTramp
.
WriteInteger
(
0
)
;
aTramp
.
WritePointer
(
aAbsTargetAddress
)
;
return
!
!
aTramp
;
}
#
endif
enum
ePrefixGroupBits
{
eNoPrefixes
=
0
ePrefixGroup1
=
(
1
<
<
0
)
ePrefixGroup2
=
(
1
<
<
1
)
ePrefixGroup3
=
(
1
<
<
2
)
ePrefixGroup4
=
(
1
<
<
3
)
}
;
int
CountPrefixBytes
(
const
ReadOnlyTargetFunction
<
MMPolicyT
>
&
aBytes
const
int
aBytesIndex
unsigned
char
*
aOutGroupBits
)
{
unsigned
char
&
groupBits
=
*
aOutGroupBits
;
groupBits
=
eNoPrefixes
;
int
index
=
aBytesIndex
;
while
(
true
)
{
switch
(
aBytes
[
index
]
)
{
case
0xF0
:
case
0xF2
:
case
0xF3
:
if
(
groupBits
&
ePrefixGroup1
)
{
return
-
1
;
}
groupBits
|
=
ePrefixGroup1
;
+
+
index
;
break
;
case
0x2E
:
case
0x36
:
case
0x3E
:
case
0x64
:
case
0x65
:
if
(
groupBits
&
ePrefixGroup2
)
{
return
-
1
;
}
groupBits
|
=
ePrefixGroup2
;
+
+
index
;
break
;
case
0x66
:
if
(
groupBits
&
ePrefixGroup3
)
{
return
-
1
;
}
groupBits
|
=
ePrefixGroup3
;
+
+
index
;
break
;
case
0x67
:
if
(
groupBits
&
ePrefixGroup4
)
{
return
-
1
;
}
groupBits
|
=
ePrefixGroup4
;
+
+
index
;
break
;
default
:
return
index
-
aBytesIndex
;
}
}
}
BYTE
BuildModRmByte
(
BYTE
aModBits
BYTE
aReg
BYTE
aRm
)
{
MOZ_ASSERT
(
(
aRm
&
kMaskRm
)
=
=
aRm
)
;
MOZ_ASSERT
(
(
aModBits
&
kMaskMod
)
=
=
aModBits
)
;
MOZ_ASSERT
(
(
(
aReg
<
<
kRegFieldShift
)
&
kMaskReg
)
=
=
(
aReg
<
<
kRegFieldShift
)
)
;
return
aModBits
|
(
aReg
<
<
kRegFieldShift
)
|
aRm
;
}
void
CreateTrampoline
(
ReadOnlyTargetFunction
<
MMPolicyT
>
&
origBytes
intptr_t
aDest
void
*
*
aOutTramp
)
{
*
aOutTramp
=
nullptr
;
Trampoline
<
MMPolicyT
>
tramp
(
mVMPolicy
.
GetNextTrampoline
(
)
)
;
if
(
!
tramp
)
{
return
;
}
tramp
.
WriteEncodedPointer
(
this
)
;
if
(
!
tramp
)
{
return
;
}
auto
clearInstanceOnFailure
=
MakeScopeExit
(
[
aOutTramp
&
tramp
]
(
)
-
>
void
{
if
(
*
aOutTramp
)
{
return
;
}
tramp
.
Rewind
(
)
;
tramp
.
WriteEncodedPointer
(
nullptr
)
;
}
)
;
tramp
.
WritePointer
(
origBytes
.
AsEncodedPtr
(
)
)
;
if
(
!
tramp
)
{
return
;
}
tramp
.
StartExecutableCode
(
)
;
#
if
defined
(
_M_IX86
)
int
pJmp32
=
-
1
;
while
(
origBytes
.
GetOffset
(
)
<
5
)
{
unsigned
char
prefixGroups
;
int
numPrefixBytes
=
CountPrefixBytes
(
origBytes
origBytes
.
GetOffset
(
)
&
prefixGroups
)
;
if
(
numPrefixBytes
<
0
|
|
(
prefixGroups
&
(
ePrefixGroup3
|
ePrefixGroup4
)
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
opcode
sequence
"
)
;
return
;
}
origBytes
+
=
numPrefixBytes
;
if
(
*
origBytes
>
=
0x88
&
&
*
origBytes
<
=
0x8B
)
{
+
+
origBytes
;
int
len
=
CountModRmSib
(
origBytes
)
;
if
(
len
<
0
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
MOV
opcode
sequence
"
)
;
return
;
}
origBytes
+
=
len
;
}
else
if
(
*
origBytes
=
=
0x0f
&
&
(
origBytes
[
1
]
=
=
0x10
|
|
origBytes
[
1
]
=
=
0x11
)
)
{
origBytes
+
=
2
;
int
len
=
CountModRmSib
(
origBytes
)
;
if
(
len
<
0
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
MOV
opcode
sequence
"
)
;
return
;
}
origBytes
+
=
len
;
}
else
if
(
*
origBytes
=
=
0xA1
)
{
origBytes
+
=
5
;
}
else
if
(
*
origBytes
=
=
0xB8
)
{
origBytes
+
=
5
;
}
else
if
(
*
origBytes
=
=
0x33
&
&
(
origBytes
[
1
]
&
kMaskMod
)
=
=
kModReg
)
{
origBytes
+
=
2
;
}
else
if
(
(
*
origBytes
&
0xf8
)
=
=
0x40
)
{
origBytes
+
=
1
;
}
else
if
(
*
origBytes
=
=
0x83
)
{
unsigned
char
b
=
origBytes
[
1
]
;
if
(
(
b
&
0xc0
)
=
=
0xc0
)
{
origBytes
+
=
3
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
bit
opcode
sequence
"
)
;
return
;
}
}
else
if
(
*
origBytes
=
=
0x68
)
{
origBytes
+
=
5
;
}
else
if
(
(
*
origBytes
&
0xf0
)
=
=
0x50
)
{
+
+
origBytes
;
}
else
if
(
*
origBytes
=
=
0x6A
)
{
origBytes
+
=
2
;
}
else
if
(
*
origBytes
=
=
0xe9
)
{
pJmp32
=
origBytes
.
GetOffset
(
)
;
origBytes
+
=
5
;
}
else
if
(
*
origBytes
=
=
0xff
&
&
origBytes
[
1
]
=
=
0x25
)
{
origBytes
+
=
6
;
}
else
if
(
*
origBytes
=
=
0xc2
)
{
#
if
defined
(
MOZILLA_INTERNAL_API
)
NS_WARNING
(
"
Cannot
hook
method
-
-
RET
opcode
found
"
)
;
#
endif
return
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
opcode
sequence
"
)
;
return
;
}
}
tramp
.
CopyFrom
(
origBytes
.
GetBaseAddress
(
)
origBytes
.
GetOffset
(
)
)
;
if
(
!
tramp
)
{
return
;
}
#
elif
defined
(
_M_X64
)
bool
foundJmp
=
false
;
while
(
origBytes
.
GetOffset
(
)
<
13
)
{
if
(
foundJmp
)
{
if
(
*
origBytes
=
=
0x90
|
|
*
origBytes
=
=
0xcc
)
{
+
+
origBytes
;
continue
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Opcode
sequence
includes
commands
after
JMP
"
)
;
return
;
}
if
(
*
origBytes
=
=
0x0f
)
{
COPY_CODES
(
1
)
;
if
(
*
origBytes
=
=
0x1f
)
{
COPY_CODES
(
1
)
;
if
(
(
*
origBytes
&
0xc0
)
=
=
0x40
&
&
(
*
origBytes
&
0x7
)
=
=
0x04
)
{
COPY_CODES
(
3
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
opcode
sequence
"
)
;
return
;
}
}
else
if
(
*
origBytes
=
=
0x05
)
{
COPY_CODES
(
1
)
;
}
else
if
(
*
origBytes
=
=
0x10
|
|
*
origBytes
=
=
0x11
)
{
COPY_CODES
(
1
)
;
int
nModRmSibBytes
=
CountModRmSib
(
origBytes
)
;
if
(
nModRmSibBytes
<
0
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
opcode
sequence
"
)
;
return
;
}
else
{
COPY_CODES
(
nModRmSibBytes
)
;
}
}
else
if
(
*
origBytes
=
=
0x84
)
{
+
+
origBytes
;
-
-
tramp
;
if
(
!
GenerateJump
(
tramp
origBytes
.
ReadDisp32AsAbsolute
(
)
JumpType
:
:
Je
)
)
{
return
;
}
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
opcode
sequence
"
)
;
return
;
}
}
else
if
(
*
origBytes
>
=
0x88
&
&
*
origBytes
<
=
0x8B
)
{
COPY_CODES
(
1
)
;
int
len
=
CountModRmSib
(
origBytes
)
;
if
(
len
<
0
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
MOV
opcode
sequence
"
)
;
return
;
}
COPY_CODES
(
len
)
;
}
else
if
(
*
origBytes
=
=
0x40
|
|
*
origBytes
=
=
0x41
)
{
COPY_CODES
(
1
)
;
if
(
(
*
origBytes
&
0xf0
)
=
=
0x50
)
{
COPY_CODES
(
1
)
;
}
else
if
(
*
origBytes
>
=
0xb8
&
&
*
origBytes
<
=
0xbf
)
{
COPY_CODES
(
5
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
opcode
sequence
"
)
;
return
;
}
}
else
if
(
*
origBytes
=
=
0x44
)
{
COPY_CODES
(
1
)
;
if
(
*
origBytes
=
=
0x89
)
{
COPY_CODES
(
1
)
;
int
len
=
CountModRmSib
(
origBytes
)
;
if
(
len
<
0
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
opcode
sequence
"
)
;
return
;
}
COPY_CODES
(
len
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
opcode
sequence
"
)
;
return
;
}
}
else
if
(
*
origBytes
=
=
0x45
)
{
COPY_CODES
(
1
)
;
if
(
*
origBytes
=
=
0x33
)
{
COPY_CODES
(
2
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
opcode
sequence
"
)
;
return
;
}
}
else
if
(
(
*
origBytes
&
0xfa
)
=
=
0x48
)
{
COPY_CODES
(
1
)
;
if
(
*
origBytes
=
=
0x81
&
&
(
origBytes
[
1
]
&
0xf8
)
=
=
0xe8
)
{
COPY_CODES
(
6
)
;
}
else
if
(
*
origBytes
=
=
0x83
&
&
(
origBytes
[
1
]
&
0xf8
)
=
=
0xe8
)
{
COPY_CODES
(
3
)
;
}
else
if
(
*
origBytes
=
=
0x83
&
&
(
origBytes
[
1
]
&
(
kMaskMod
|
kMaskReg
)
)
=
=
kModReg
)
{
COPY_CODES
(
3
)
;
}
else
if
(
*
origBytes
=
=
0x83
&
&
(
origBytes
[
1
]
&
0xf8
)
=
=
0x60
)
{
COPY_CODES
(
5
)
;
}
else
if
(
*
origBytes
=
=
0x2b
&
&
(
origBytes
[
1
]
&
kMaskMod
)
=
=
kModReg
)
{
COPY_CODES
(
2
)
;
}
else
if
(
*
origBytes
=
=
0x85
)
{
if
(
(
origBytes
[
1
]
&
0xc0
)
=
=
0xc0
)
{
COPY_CODES
(
2
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
opcode
sequence
"
)
;
return
;
}
}
else
if
(
(
*
origBytes
&
0xfd
)
=
=
0x89
)
{
BYTE
reg
;
int
len
=
CountModRmSib
(
origBytes
+
1
&
reg
)
;
if
(
len
<
0
)
{
MOZ_ASSERT
(
len
=
=
kModOperand64
)
;
if
(
len
!
=
kModOperand64
)
{
return
;
}
origBytes
+
=
2
;
uintptr_t
absAddr
=
origBytes
.
ReadDisp32AsAbsolute
(
)
;
if
(
reg
=
=
kRegAx
)
{
tramp
.
WriteByte
(
0xa1
)
;
tramp
.
WritePointer
(
absAddr
)
;
}
else
{
tramp
.
WriteByte
(
0xb8
+
reg
)
;
tramp
.
WritePointer
(
absAddr
)
;
tramp
.
WriteByte
(
0x48
)
;
tramp
.
WriteByte
(
0x8b
)
;
tramp
.
WriteByte
(
BuildModRmByte
(
kModNoRegDisp
reg
reg
)
)
;
}
}
else
{
COPY_CODES
(
len
+
1
)
;
}
}
else
if
(
*
origBytes
=
=
0xc7
)
{
if
(
origBytes
[
1
]
=
=
0x44
)
{
COPY_CODES
(
8
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
opcode
sequence
"
)
;
return
;
}
}
else
if
(
*
origBytes
=
=
0xff
)
{
if
(
(
origBytes
[
1
]
&
0xc0
)
=
=
0x0
&
&
(
origBytes
[
1
]
&
0x07
)
=
=
0x5
)
{
origBytes
+
=
2
;
-
-
tramp
;
if
(
!
GenerateJump
(
tramp
origBytes
.
ChasePointerFromDisp
(
)
JumpType
:
:
Jmp
)
)
{
return
;
}
foundJmp
=
true
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
opcode
sequence
"
)
;
return
;
}
}
else
if
(
*
origBytes
=
=
0x8d
)
{
if
(
(
origBytes
[
1
]
&
kMaskMod
)
=
=
0x0
&
&
(
origBytes
[
1
]
&
kMaskRm
)
=
=
0x5
)
{
BYTE
reg
=
(
origBytes
[
1
]
&
kMaskReg
)
>
>
kRegFieldShift
;
origBytes
+
=
2
;
uintptr_t
absAddr
=
origBytes
.
ReadDisp32AsAbsolute
(
)
;
tramp
.
WriteByte
(
0xb8
+
reg
)
;
tramp
.
WritePointer
(
absAddr
)
;
}
else
{
int
len
=
CountModRmSib
(
origBytes
+
1
)
;
MOZ_ASSERT
(
len
>
0
)
;
COPY_CODES
(
len
+
1
)
;
}
}
else
if
(
*
origBytes
=
=
0x63
&
&
(
origBytes
[
1
]
&
kMaskMod
)
=
=
kModReg
)
{
COPY_CODES
(
2
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
opcode
sequence
"
)
;
return
;
}
}
else
if
(
*
origBytes
=
=
0x66
)
{
COPY_CODES
(
1
)
;
if
(
*
origBytes
>
=
0x88
&
&
*
origBytes
<
=
0x8B
)
{
unsigned
char
b
=
origBytes
[
1
]
;
if
(
(
(
b
&
0xc0
)
=
=
0xc0
)
|
|
(
(
(
b
&
0xc0
)
=
=
0x00
)
&
&
(
(
b
&
0x07
)
!
=
0x04
)
&
&
(
(
b
&
0x07
)
!
=
0x05
)
)
)
{
COPY_CODES
(
2
)
;
}
else
if
(
(
b
&
0xc0
)
=
=
0x40
)
{
if
(
(
b
&
0x07
)
=
=
0x04
)
{
COPY_CODES
(
4
)
;
}
else
{
COPY_CODES
(
3
)
;
}
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
MOV
opcode
sequence
"
)
;
return
;
}
}
else
if
(
*
origBytes
=
=
0x44
&
&
origBytes
[
1
]
=
=
0x89
)
{
COPY_CODES
(
2
)
;
int
len
=
CountModRmSib
(
origBytes
)
;
if
(
len
<
0
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
opcode
sequence
"
)
;
return
;
}
COPY_CODES
(
len
)
;
}
}
else
if
(
(
*
origBytes
&
0xf0
)
=
=
0x50
)
{
COPY_CODES
(
1
)
;
}
else
if
(
*
origBytes
=
=
0x65
)
{
if
(
origBytes
[
1
]
=
=
0x48
&
&
(
origBytes
[
2
]
>
=
0x88
&
&
origBytes
[
2
]
<
=
0x8b
)
)
{
COPY_CODES
(
3
)
;
int
len
=
CountModRmSib
(
origBytes
)
;
if
(
len
<
0
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
opcode
sequence
"
)
;
return
;
}
COPY_CODES
(
len
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
opcode
sequence
"
)
;
return
;
}
}
else
if
(
*
origBytes
=
=
0x80
&
&
origBytes
[
1
]
=
=
0x3d
)
{
origBytes
+
=
2
;
tramp
.
WriteByte
(
0x49
)
;
tramp
.
WriteByte
(
0x53
)
;
uintptr_t
absAddr
=
origBytes
.
ReadDisp32AsAbsolute
(
)
;
tramp
.
WriteByte
(
0x49
)
;
tramp
.
WriteByte
(
0xbb
)
;
tramp
.
WritePointer
(
absAddr
)
;
tramp
.
WriteByte
(
0x41
)
;
tramp
.
WriteByte
(
0x80
)
;
tramp
.
WriteByte
(
0x3b
)
;
COPY_CODES
(
1
)
;
tramp
.
WriteByte
(
0x49
)
;
tramp
.
WriteByte
(
0x5b
)
;
}
else
if
(
*
origBytes
=
=
0x90
)
{
COPY_CODES
(
1
)
;
}
else
if
(
(
*
origBytes
&
0xf8
)
=
=
0xb8
)
{
COPY_CODES
(
5
)
;
}
else
if
(
*
origBytes
=
=
0x33
)
{
COPY_CODES
(
2
)
;
}
else
if
(
*
origBytes
=
=
0xf6
)
{
BYTE
subOpcode
=
0
;
int
nModRmSibBytes
=
CountModRmSib
(
origBytes
+
1
&
subOpcode
)
;
if
(
nModRmSibBytes
<
0
|
|
subOpcode
!
=
0
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
opcode
sequence
"
)
;
return
;
}
COPY_CODES
(
2
+
nModRmSibBytes
)
;
}
else
if
(
*
origBytes
=
=
0x85
)
{
int
nModRmSibBytes
=
CountModRmSib
(
origBytes
+
1
)
;
if
(
nModRmSibBytes
<
0
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
opcode
sequence
"
)
;
return
;
}
COPY_CODES
(
1
+
nModRmSibBytes
)
;
}
else
if
(
*
origBytes
=
=
0xd1
&
&
(
origBytes
[
1
]
&
kMaskMod
)
=
=
kModReg
)
{
COPY_CODES
(
2
)
;
}
else
if
(
*
origBytes
=
=
0xc3
)
{
COPY_CODES
(
1
)
;
}
else
if
(
*
origBytes
=
=
0xcc
)
{
COPY_CODES
(
1
)
;
}
else
if
(
*
origBytes
=
=
0xe8
|
|
*
origBytes
=
=
0xe9
)
{
foundJmp
=
*
origBytes
=
=
0xe9
;
+
+
origBytes
;
if
(
!
GenerateJump
(
tramp
origBytes
.
ReadDisp32AsAbsolute
(
)
foundJmp
?
JumpType
:
:
Jmp
:
JumpType
:
:
Call
)
)
{
return
;
}
}
else
if
(
*
origBytes
=
=
0x74
|
|
*
origBytes
=
=
0x75
)
{
uint8_t
offset
=
origBytes
[
1
]
;
auto
jumpType
=
JumpType
:
:
Je
;
if
(
*
origBytes
=
=
0x75
)
{
jumpType
=
JumpType
:
:
Jne
;
}
origBytes
+
=
2
;
if
(
!
GenerateJump
(
tramp
origBytes
.
OffsetToAbsolute
(
offset
)
jumpType
)
)
{
return
;
}
}
else
if
(
*
origBytes
=
=
0xff
)
{
if
(
(
origBytes
[
1
]
&
(
kMaskMod
|
kMaskReg
)
)
=
=
0xf0
)
{
COPY_CODES
(
2
)
;
}
else
if
(
origBytes
[
1
]
=
=
0x25
)
{
foundJmp
=
true
;
origBytes
+
=
2
;
uintptr_t
jmpDest
=
origBytes
.
ChasePointerFromDisp
(
)
;
if
(
!
GenerateJump
(
tramp
jmpDest
JumpType
:
:
Jmp
)
)
{
return
;
}
}
else
if
(
(
origBytes
[
1
]
&
(
kMaskMod
|
kMaskReg
)
)
=
=
BuildModRmByte
(
kModReg
2
0
)
)
{
COPY_CODES
(
2
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
opcode
sequence
"
)
;
return
;
}
}
else
if
(
*
origBytes
=
=
0x83
&
&
(
origBytes
[
1
]
&
0xf8
)
=
=
0x60
)
{
COPY_CODES
(
5
)
;
}
else
if
(
*
origBytes
=
=
0xc6
)
{
int
len
=
CountModRmSib
(
origBytes
+
1
)
;
if
(
len
<
0
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
opcode
sequence
"
)
;
return
;
}
COPY_CODES
(
len
+
1
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
opcode
sequence
"
)
;
return
;
}
}
#
else
#
error
"
Unknown
processor
type
"
#
endif
if
(
origBytes
.
GetOffset
(
)
>
100
)
{
return
;
}
#
if
defined
(
_M_IX86
)
if
(
pJmp32
>
=
0
)
{
tramp
.
AdjustDisp32AtOffset
(
pJmp32
+
1
origBytes
.
GetBaseAddress
(
)
)
;
}
else
{
tramp
.
WriteByte
(
0xe9
)
;
tramp
.
WriteDisp32
(
origBytes
.
GetAddress
(
)
)
;
}
#
elif
defined
(
_M_X64
)
if
(
!
foundJmp
)
{
if
(
!
GenerateJump
(
tramp
origBytes
.
GetAddress
(
)
JumpType
:
:
Jmp
)
)
{
return
;
}
}
#
endif
*
aOutTramp
=
tramp
.
EndExecutableCode
(
)
;
if
(
!
(
*
aOutTramp
)
)
{
return
;
}
WritableTargetFunction
<
MMPolicyT
>
target
(
origBytes
.
Promote
(
)
)
;
if
(
!
target
)
{
return
;
}
#
if
defined
(
_M_IX86
)
target
.
WriteByte
(
0xe9
)
;
target
.
WriteDisp32
(
aDest
)
;
#
elif
defined
(
_M_X64
)
target
.
WriteByte
(
0x49
)
;
target
.
WriteByte
(
0xbb
)
;
target
.
WritePointer
(
aDest
)
;
target
.
WriteByte
(
0x41
)
;
target
.
WriteByte
(
0xff
)
;
target
.
WriteByte
(
0xe3
)
;
#
endif
target
.
Commit
(
)
;
}
}
;
}
}
#
endif
