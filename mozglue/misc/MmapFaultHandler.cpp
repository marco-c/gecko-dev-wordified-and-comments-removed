#
include
"
MmapFaultHandler
.
h
"
#
if
defined
(
XP_UNIX
)
&
&
!
defined
(
XP_DARWIN
)
#
include
"
PlatformMutex
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
GuardObjects
.
h
"
#
include
"
mozilla
/
ThreadLocal
.
h
"
#
include
<
signal
.
h
>
class
MmapMutex
:
private
mozilla
:
:
detail
:
:
MutexImpl
{
public
:
MmapMutex
(
)
:
mozilla
:
:
detail
:
:
MutexImpl
(
)
{
}
void
Lock
(
)
{
mozilla
:
:
detail
:
:
MutexImpl
:
:
lock
(
)
;
}
void
Unlock
(
)
{
mozilla
:
:
detail
:
:
MutexImpl
:
:
unlock
(
)
;
}
}
;
class
StaticMmapMutex
{
public
:
void
Lock
(
)
{
Mutex
(
)
-
>
Lock
(
)
;
}
void
Unlock
(
)
{
Mutex
(
)
-
>
Unlock
(
)
;
}
private
:
MmapMutex
*
Mutex
(
)
{
if
(
mMutex
)
{
return
mMutex
;
}
MmapMutex
*
mutex
=
new
MmapMutex
(
)
;
if
(
!
mMutex
.
compareExchange
(
nullptr
mutex
)
)
{
delete
mutex
;
}
return
mMutex
;
}
mozilla
:
:
Atomic
<
MmapMutex
*
mozilla
:
:
SequentiallyConsistent
>
mMutex
;
}
;
static
MOZ_THREAD_LOCAL
(
MmapAccessScope
*
)
sMmapAccessScope
;
static
struct
sigaction
sPrevSIGBUSHandler
;
static
void
MmapSIGBUSHandler
(
int
signum
siginfo_t
*
info
void
*
context
)
{
MOZ_RELEASE_ASSERT
(
signum
=
=
SIGBUS
)
;
MmapAccessScope
*
mas
=
sMmapAccessScope
.
get
(
)
;
if
(
mas
&
&
mas
-
>
IsInsideBuffer
(
info
-
>
si_addr
)
)
{
mas
-
>
CrashWithInfo
(
info
-
>
si_addr
)
;
siglongjmp
(
mas
-
>
mJmpBuf
signum
)
;
}
if
(
sPrevSIGBUSHandler
.
sa_flags
&
SA_SIGINFO
)
{
sPrevSIGBUSHandler
.
sa_sigaction
(
signum
info
context
)
;
}
else
if
(
sPrevSIGBUSHandler
.
sa_handler
=
=
SIG_DFL
|
|
sPrevSIGBUSHandler
.
sa_handler
=
=
SIG_IGN
)
{
sigaction
(
signum
&
sPrevSIGBUSHandler
nullptr
)
;
}
else
{
sPrevSIGBUSHandler
.
sa_handler
(
signum
)
;
}
}
mozilla
:
:
Atomic
<
bool
>
gSIGBUSHandlerInstalled
(
false
)
;
StaticMmapMutex
gSIGBUSHandlerMutex
;
class
MOZ_RAII
MmapMutexAutoLock
{
public
:
explicit
MmapMutexAutoLock
(
MOZ_GUARD_OBJECT_NOTIFIER_ONLY_PARAM
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
gSIGBUSHandlerMutex
.
Lock
(
)
;
}
~
MmapMutexAutoLock
(
)
{
gSIGBUSHandlerMutex
.
Unlock
(
)
;
}
private
:
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
void
InstallMmapFaultHandler
(
)
{
if
(
gSIGBUSHandlerInstalled
)
{
return
;
}
MmapMutexAutoLock
lock
;
if
(
gSIGBUSHandlerInstalled
)
{
return
;
}
sMmapAccessScope
.
infallibleInit
(
)
;
struct
sigaction
busHandler
;
busHandler
.
sa_flags
=
SA_SIGINFO
|
SA_NODEFER
|
SA_ONSTACK
;
busHandler
.
sa_sigaction
=
MmapSIGBUSHandler
;
sigemptyset
(
&
busHandler
.
sa_mask
)
;
if
(
sigaction
(
SIGBUS
&
busHandler
&
sPrevSIGBUSHandler
)
)
{
MOZ_CRASH
(
"
Unable
to
install
SIGBUS
handler
"
)
;
}
gSIGBUSHandlerInstalled
=
true
;
}
MmapAccessScope
:
:
MmapAccessScope
(
void
*
aBuf
uint32_t
aBufLen
const
char
*
aFilename
)
{
InstallMmapFaultHandler
(
)
;
mBuf
=
aBuf
;
mBufLen
=
aBufLen
;
mFilename
=
aFilename
;
SetThreadLocalScope
(
)
;
}
MmapAccessScope
:
:
~
MmapAccessScope
(
)
{
MOZ_RELEASE_ASSERT
(
sMmapAccessScope
.
get
(
)
=
=
this
)
;
sMmapAccessScope
.
set
(
mPreviousScope
)
;
}
void
MmapAccessScope
:
:
SetThreadLocalScope
(
)
{
memset
(
mJmpBuf
0
sizeof
(
sigjmp_buf
)
)
;
mPreviousScope
=
sMmapAccessScope
.
get
(
)
;
sMmapAccessScope
.
set
(
this
)
;
}
bool
MmapAccessScope
:
:
IsInsideBuffer
(
void
*
aPtr
)
{
return
aPtr
>
=
mBuf
&
&
aPtr
<
(
void
*
)
(
(
char
*
)
mBuf
+
mBufLen
)
;
}
void
MmapAccessScope
:
:
CrashWithInfo
(
void
*
aPtr
)
{
MOZ_CRASH_UNSAFE_PRINTF
(
"
SIGBUS
received
when
accessing
mmaped
file
[
buffer
=
%
p
"
"
buflen
=
%
u
address
=
%
p
filename
=
%
s
]
"
mBuf
mBufLen
aPtr
mFilename
)
;
}
#
endif
