#
ifndef
mozilla_TimeStamp_h
#
define
mozilla_TimeStamp_h
#
include
<
stdint
.
h
>
#
include
<
algorithm
>
#
include
<
ostream
>
#
include
<
type_traits
>
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
mozilla
/
Types
.
h
"
namespace
IPC
{
template
<
typename
T
>
struct
ParamTraits
;
}
#
ifdef
XP_WIN
#
include
"
TimeStamp_windows
.
h
"
#
endif
namespace
mozilla
{
#
ifndef
XP_WIN
struct
TimeStamp63Bit
{
uint64_t
mUsedCanonicalNow
:
1
;
uint64_t
mTimeStamp
:
63
;
constexpr
TimeStamp63Bit
(
)
:
mUsedCanonicalNow
(
0
)
mTimeStamp
(
0
)
{
}
MOZ_IMPLICIT
constexpr
TimeStamp63Bit
(
const
uint64_t
aValue
)
:
mUsedCanonicalNow
(
0
)
mTimeStamp
(
aValue
)
{
}
constexpr
TimeStamp63Bit
(
const
bool
aUsedCanonicalNow
const
int64_t
aTimeStamp
)
:
mUsedCanonicalNow
(
aUsedCanonicalNow
?
1
:
0
)
mTimeStamp
(
aTimeStamp
)
{
}
bool
operator
=
=
(
const
TimeStamp63Bit
aOther
)
const
{
uint64_t
here
there
;
memcpy
(
&
here
this
sizeof
(
TimeStamp63Bit
)
)
;
memcpy
(
&
there
&
aOther
sizeof
(
TimeStamp63Bit
)
)
;
return
here
=
=
there
;
}
operator
uint64_t
(
)
const
{
return
mTimeStamp
;
}
bool
IsNull
(
)
const
{
return
mTimeStamp
=
=
0
;
}
bool
UsedCanonicalNow
(
)
const
{
return
mUsedCanonicalNow
;
}
void
SetCanonicalNow
(
)
{
mUsedCanonicalNow
=
1
;
}
}
;
typedef
TimeStamp63Bit
TimeStampValue
;
#
endif
class
TimeStamp
;
class
BaseTimeDurationPlatformUtils
{
public
:
static
MFBT_API
double
ToSeconds
(
int64_t
aTicks
)
;
static
MFBT_API
double
ToSecondsSigDigits
(
int64_t
aTicks
)
;
static
MFBT_API
int64_t
TicksFromMilliseconds
(
double
aMilliseconds
)
;
static
MFBT_API
int64_t
ResolutionInTicks
(
)
;
}
;
template
<
typename
ValueCalculator
>
class
BaseTimeDuration
{
public
:
constexpr
BaseTimeDuration
(
)
:
mValue
(
0
)
{
}
struct
_SomethingVeryRandomHere
;
MOZ_IMPLICIT
BaseTimeDuration
(
_SomethingVeryRandomHere
*
aZero
)
:
mValue
(
0
)
{
MOZ_ASSERT
(
!
aZero
"
Who
'
s
playing
funny
games
here
?
"
)
;
}
template
<
typename
E
>
explicit
BaseTimeDuration
(
const
BaseTimeDuration
<
E
>
&
aOther
)
:
mValue
(
aOther
.
mValue
)
{
}
template
<
typename
E
>
BaseTimeDuration
&
operator
=
(
const
BaseTimeDuration
<
E
>
&
aOther
)
{
mValue
=
aOther
.
mValue
;
return
*
this
;
}
double
ToSeconds
(
)
const
{
if
(
mValue
=
=
INT64_MAX
)
{
return
PositiveInfinity
<
double
>
(
)
;
}
if
(
mValue
=
=
INT64_MIN
)
{
return
NegativeInfinity
<
double
>
(
)
;
}
return
BaseTimeDurationPlatformUtils
:
:
ToSeconds
(
mValue
)
;
}
double
ToSecondsSigDigits
(
)
const
{
if
(
mValue
=
=
INT64_MAX
)
{
return
PositiveInfinity
<
double
>
(
)
;
}
if
(
mValue
=
=
INT64_MIN
)
{
return
NegativeInfinity
<
double
>
(
)
;
}
return
BaseTimeDurationPlatformUtils
:
:
ToSecondsSigDigits
(
mValue
)
;
}
double
ToMilliseconds
(
)
const
{
return
ToSeconds
(
)
*
1000
.
0
;
}
double
ToMicroseconds
(
)
const
{
return
ToMilliseconds
(
)
*
1000
.
0
;
}
static
inline
BaseTimeDuration
FromSeconds
(
double
aSeconds
)
{
return
FromMilliseconds
(
aSeconds
*
1000
.
0
)
;
}
static
BaseTimeDuration
FromMilliseconds
(
double
aMilliseconds
)
{
if
(
aMilliseconds
=
=
PositiveInfinity
<
double
>
(
)
)
{
return
Forever
(
)
;
}
if
(
aMilliseconds
=
=
NegativeInfinity
<
double
>
(
)
)
{
return
FromTicks
(
INT64_MIN
)
;
}
return
FromTicks
(
BaseTimeDurationPlatformUtils
:
:
TicksFromMilliseconds
(
aMilliseconds
)
)
;
}
static
inline
BaseTimeDuration
FromMicroseconds
(
double
aMicroseconds
)
{
return
FromMilliseconds
(
aMicroseconds
/
1000
.
0
)
;
}
static
constexpr
BaseTimeDuration
Forever
(
)
{
return
FromTicks
(
INT64_MAX
)
;
}
BaseTimeDuration
operator
+
(
const
BaseTimeDuration
&
aOther
)
const
{
return
FromTicks
(
ValueCalculator
:
:
Add
(
mValue
aOther
.
mValue
)
)
;
}
BaseTimeDuration
operator
-
(
const
BaseTimeDuration
&
aOther
)
const
{
return
FromTicks
(
ValueCalculator
:
:
Subtract
(
mValue
aOther
.
mValue
)
)
;
}
BaseTimeDuration
&
operator
+
=
(
const
BaseTimeDuration
&
aOther
)
{
mValue
=
ValueCalculator
:
:
Add
(
mValue
aOther
.
mValue
)
;
return
*
this
;
}
BaseTimeDuration
&
operator
-
=
(
const
BaseTimeDuration
&
aOther
)
{
mValue
=
ValueCalculator
:
:
Subtract
(
mValue
aOther
.
mValue
)
;
return
*
this
;
}
BaseTimeDuration
operator
-
(
)
const
{
int64_t
ticks
;
if
(
mValue
=
=
INT64_MAX
)
{
ticks
=
INT64_MIN
;
}
else
if
(
mValue
=
=
INT64_MIN
)
{
ticks
=
INT64_MAX
;
}
else
{
ticks
=
-
mValue
;
}
return
FromTicks
(
ticks
)
;
}
static
BaseTimeDuration
Max
(
const
BaseTimeDuration
&
aA
const
BaseTimeDuration
&
aB
)
{
return
FromTicks
(
std
:
:
max
(
aA
.
mValue
aB
.
mValue
)
)
;
}
static
BaseTimeDuration
Min
(
const
BaseTimeDuration
&
aA
const
BaseTimeDuration
&
aB
)
{
return
FromTicks
(
std
:
:
min
(
aA
.
mValue
aB
.
mValue
)
)
;
}
private
:
BaseTimeDuration
operator
*
(
const
double
aMultiplier
)
const
=
delete
;
BaseTimeDuration
operator
/
(
const
double
aDivisor
)
const
=
delete
;
public
:
BaseTimeDuration
MultDouble
(
double
aMultiplier
)
const
{
return
FromTicks
(
ValueCalculator
:
:
Multiply
(
mValue
aMultiplier
)
)
;
}
BaseTimeDuration
operator
*
(
const
int32_t
aMultiplier
)
const
{
return
FromTicks
(
ValueCalculator
:
:
Multiply
(
mValue
aMultiplier
)
)
;
}
BaseTimeDuration
operator
*
(
const
uint32_t
aMultiplier
)
const
{
return
FromTicks
(
ValueCalculator
:
:
Multiply
(
mValue
aMultiplier
)
)
;
}
BaseTimeDuration
operator
*
(
const
int64_t
aMultiplier
)
const
{
return
FromTicks
(
ValueCalculator
:
:
Multiply
(
mValue
aMultiplier
)
)
;
}
BaseTimeDuration
operator
*
(
const
uint64_t
aMultiplier
)
const
{
if
(
aMultiplier
>
INT64_MAX
)
{
return
Forever
(
)
;
}
return
FromTicks
(
ValueCalculator
:
:
Multiply
(
mValue
aMultiplier
)
)
;
}
BaseTimeDuration
operator
/
(
const
int64_t
aDivisor
)
const
{
MOZ_ASSERT
(
aDivisor
!
=
0
"
Division
by
zero
"
)
;
return
FromTicks
(
ValueCalculator
:
:
Divide
(
mValue
aDivisor
)
)
;
}
double
operator
/
(
const
BaseTimeDuration
&
aOther
)
const
{
MOZ_ASSERT
(
aOther
.
mValue
!
=
0
"
Division
by
zero
"
)
;
return
ValueCalculator
:
:
DivideDouble
(
mValue
aOther
.
mValue
)
;
}
BaseTimeDuration
operator
%
(
const
BaseTimeDuration
&
aOther
)
const
{
MOZ_ASSERT
(
aOther
.
mValue
!
=
0
"
Division
by
zero
"
)
;
return
FromTicks
(
ValueCalculator
:
:
Modulo
(
mValue
aOther
.
mValue
)
)
;
}
template
<
typename
E
>
bool
operator
<
(
const
BaseTimeDuration
<
E
>
&
aOther
)
const
{
return
mValue
<
aOther
.
mValue
;
}
template
<
typename
E
>
bool
operator
<
=
(
const
BaseTimeDuration
<
E
>
&
aOther
)
const
{
return
mValue
<
=
aOther
.
mValue
;
}
template
<
typename
E
>
bool
operator
>
=
(
const
BaseTimeDuration
<
E
>
&
aOther
)
const
{
return
mValue
>
=
aOther
.
mValue
;
}
template
<
typename
E
>
bool
operator
>
(
const
BaseTimeDuration
<
E
>
&
aOther
)
const
{
return
mValue
>
aOther
.
mValue
;
}
template
<
typename
E
>
bool
operator
=
=
(
const
BaseTimeDuration
<
E
>
&
aOther
)
const
{
return
mValue
=
=
aOther
.
mValue
;
}
template
<
typename
E
>
bool
operator
!
=
(
const
BaseTimeDuration
<
E
>
&
aOther
)
const
{
return
mValue
!
=
aOther
.
mValue
;
}
bool
IsZero
(
)
const
{
return
mValue
=
=
0
;
}
explicit
operator
bool
(
)
const
{
return
mValue
!
=
0
;
}
friend
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
aStream
const
BaseTimeDuration
&
aDuration
)
{
return
aStream
<
<
aDuration
.
ToMilliseconds
(
)
<
<
"
ms
"
;
}
static
BaseTimeDuration
Resolution
(
)
{
return
FromTicks
(
BaseTimeDurationPlatformUtils
:
:
ResolutionInTicks
(
)
)
;
}
private
:
friend
class
TimeStamp
;
friend
struct
IPC
:
:
ParamTraits
<
mozilla
:
:
BaseTimeDuration
<
ValueCalculator
>
>
;
template
<
typename
>
friend
class
BaseTimeDuration
;
static
BaseTimeDuration
FromTicks
(
int64_t
aTicks
)
{
BaseTimeDuration
t
;
t
.
mValue
=
aTicks
;
return
t
;
}
static
BaseTimeDuration
FromTicks
(
double
aTicks
)
{
if
(
aTicks
>
=
double
(
INT64_MAX
)
)
{
return
FromTicks
(
INT64_MAX
)
;
}
if
(
aTicks
<
=
double
(
INT64_MIN
)
)
{
return
FromTicks
(
INT64_MIN
)
;
}
return
FromTicks
(
int64_t
(
aTicks
)
)
;
}
int64_t
mValue
;
}
;
class
TimeDurationValueCalculator
{
public
:
static
int64_t
Add
(
int64_t
aA
int64_t
aB
)
{
return
aA
+
aB
;
}
static
int64_t
Subtract
(
int64_t
aA
int64_t
aB
)
{
return
aA
-
aB
;
}
template
<
typename
T
>
static
int64_t
Multiply
(
int64_t
aA
T
aB
)
{
static_assert
(
std
:
:
is_integral_v
<
T
>
"
Using
integer
multiplication
routine
with
non
-
integer
type
.
"
"
Further
specialization
required
"
)
;
return
aA
*
static_cast
<
int64_t
>
(
aB
)
;
}
static
int64_t
Divide
(
int64_t
aA
int64_t
aB
)
{
return
aA
/
aB
;
}
static
double
DivideDouble
(
int64_t
aA
int64_t
aB
)
{
return
static_cast
<
double
>
(
aA
)
/
aB
;
}
static
int64_t
Modulo
(
int64_t
aA
int64_t
aB
)
{
return
aA
%
aB
;
}
}
;
template
<
>
inline
int64_t
TimeDurationValueCalculator
:
:
Multiply
<
double
>
(
int64_t
aA
double
aB
)
{
return
static_cast
<
int64_t
>
(
aA
*
aB
)
;
}
typedef
BaseTimeDuration
<
TimeDurationValueCalculator
>
TimeDuration
;
class
TimeStamp
{
public
:
constexpr
TimeStamp
(
)
:
mValue
(
)
{
}
#
if
defined
(
XP_DARWIN
)
|
|
defined
(
MOZ_WIDGET_ANDROID
)
|
|
defined
(
MOZ_WIDGET_GTK
)
static
TimeStamp
FromSystemTime
(
int64_t
aSystemTime
)
{
static_assert
(
sizeof
(
aSystemTime
)
=
=
sizeof
(
TimeStampValue
)
"
System
timestamp
should
be
same
units
as
TimeStampValue
"
)
;
return
TimeStamp
(
TimeStampValue
(
false
aSystemTime
)
)
;
}
#
endif
bool
IsNull
(
)
const
{
return
mValue
.
IsNull
(
)
;
}
explicit
operator
bool
(
)
const
{
return
!
IsNull
(
)
;
}
bool
UsedCanonicalNow
(
)
const
{
return
mValue
.
UsedCanonicalNow
(
)
;
}
static
MFBT_API
bool
GetFuzzyfoxEnabled
(
)
;
static
MFBT_API
void
SetFuzzyfoxEnabled
(
bool
aValue
)
;
static
TimeStamp
Now
(
)
{
return
Now
(
true
)
;
}
static
TimeStamp
NowLoRes
(
)
{
return
Now
(
false
)
;
}
static
TimeStamp
NowUnfuzzed
(
)
{
return
NowUnfuzzed
(
true
)
;
}
static
MFBT_API
int64_t
NowFuzzyTime
(
)
;
static
MFBT_API
TimeStamp
ProcessCreation
(
bool
*
aIsInconsistent
=
nullptr
)
;
static
MFBT_API
void
RecordProcessRestart
(
)
;
TimeDuration
operator
-
(
const
TimeStamp
&
aOther
)
const
{
MOZ_ASSERT
(
!
IsNull
(
)
"
Cannot
compute
with
a
null
value
"
)
;
MOZ_ASSERT
(
!
aOther
.
IsNull
(
)
"
Cannot
compute
with
aOther
null
value
"
)
;
static_assert
(
-
INT64_MAX
>
INT64_MIN
"
int64_t
sanity
check
"
)
;
int64_t
ticks
=
int64_t
(
mValue
-
aOther
.
mValue
)
;
if
(
mValue
>
aOther
.
mValue
)
{
if
(
ticks
<
0
)
{
ticks
=
INT64_MAX
;
}
}
else
{
if
(
ticks
>
0
)
{
ticks
=
INT64_MIN
;
}
}
return
TimeDuration
:
:
FromTicks
(
ticks
)
;
}
TimeStamp
operator
+
(
const
TimeDuration
&
aOther
)
const
{
TimeStamp
result
=
*
this
;
result
+
=
aOther
;
return
result
;
}
TimeStamp
operator
-
(
const
TimeDuration
&
aOther
)
const
{
TimeStamp
result
=
*
this
;
result
-
=
aOther
;
return
result
;
}
TimeStamp
&
operator
+
=
(
const
TimeDuration
&
aOther
)
{
MOZ_ASSERT
(
!
IsNull
(
)
"
Cannot
compute
with
a
null
value
"
)
;
TimeStampValue
value
=
mValue
+
aOther
.
mValue
;
if
(
aOther
.
mValue
<
0
&
&
value
>
mValue
)
{
value
=
TimeStampValue
(
)
;
}
if
(
mValue
.
UsedCanonicalNow
(
)
)
{
value
.
SetCanonicalNow
(
)
;
}
mValue
=
value
;
return
*
this
;
}
TimeStamp
&
operator
-
=
(
const
TimeDuration
&
aOther
)
{
MOZ_ASSERT
(
!
IsNull
(
)
"
Cannot
compute
with
a
null
value
"
)
;
TimeStampValue
value
=
mValue
-
aOther
.
mValue
;
if
(
aOther
.
mValue
>
0
&
&
value
>
mValue
)
{
value
=
TimeStampValue
(
)
;
}
if
(
mValue
.
UsedCanonicalNow
(
)
)
{
value
.
SetCanonicalNow
(
)
;
}
mValue
=
value
;
return
*
this
;
}
bool
operator
<
(
const
TimeStamp
&
aOther
)
const
{
MOZ_ASSERT
(
!
IsNull
(
)
"
Cannot
compute
with
a
null
value
"
)
;
MOZ_ASSERT
(
!
aOther
.
IsNull
(
)
"
Cannot
compute
with
aOther
null
value
"
)
;
return
mValue
<
aOther
.
mValue
;
}
bool
operator
<
=
(
const
TimeStamp
&
aOther
)
const
{
MOZ_ASSERT
(
!
IsNull
(
)
"
Cannot
compute
with
a
null
value
"
)
;
MOZ_ASSERT
(
!
aOther
.
IsNull
(
)
"
Cannot
compute
with
aOther
null
value
"
)
;
return
mValue
<
=
aOther
.
mValue
;
}
bool
operator
>
=
(
const
TimeStamp
&
aOther
)
const
{
MOZ_ASSERT
(
!
IsNull
(
)
"
Cannot
compute
with
a
null
value
"
)
;
MOZ_ASSERT
(
!
aOther
.
IsNull
(
)
"
Cannot
compute
with
aOther
null
value
"
)
;
return
mValue
>
=
aOther
.
mValue
;
}
bool
operator
>
(
const
TimeStamp
&
aOther
)
const
{
MOZ_ASSERT
(
!
IsNull
(
)
"
Cannot
compute
with
a
null
value
"
)
;
MOZ_ASSERT
(
!
aOther
.
IsNull
(
)
"
Cannot
compute
with
aOther
null
value
"
)
;
return
mValue
>
aOther
.
mValue
;
}
bool
operator
=
=
(
const
TimeStamp
&
aOther
)
const
{
return
IsNull
(
)
?
aOther
.
IsNull
(
)
:
!
aOther
.
IsNull
(
)
&
&
mValue
=
=
aOther
.
mValue
;
}
bool
operator
!
=
(
const
TimeStamp
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
static
MFBT_API
void
Startup
(
)
;
static
MFBT_API
void
Shutdown
(
)
;
private
:
friend
struct
IPC
:
:
ParamTraits
<
mozilla
:
:
TimeStamp
>
;
MOZ_IMPLICIT
TimeStamp
(
TimeStampValue
aValue
)
:
mValue
(
aValue
)
{
}
static
MFBT_API
TimeStamp
Now
(
bool
aHighResolution
)
;
static
MFBT_API
TimeStamp
NowUnfuzzed
(
bool
aHighResolution
)
;
static
MFBT_API
TimeStamp
NowFuzzy
(
TimeStampValue
aValue
)
;
static
MFBT_API
void
UpdateFuzzyTime
(
int64_t
aValue
)
;
static
MFBT_API
void
UpdateFuzzyTimeStamp
(
TimeStamp
aValue
)
;
static
MFBT_API
uint64_t
ComputeProcessUptime
(
)
;
TimeStampValue
mValue
;
friend
class
Fuzzyfox
;
}
;
}
#
endif
