#
include
"
Uptime
.
h
"
#
ifdef
XP_WIN
#
include
"
mozilla
/
DynamicallyLinkedFunctionPtr
.
h
"
#
endif
#
include
<
stdint
.
h
>
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
using
namespace
mozilla
;
namespace
{
Maybe
<
uint64_t
>
NowIncludingSuspendMs
(
)
;
Maybe
<
uint64_t
>
NowExcludingSuspendMs
(
)
;
static
Maybe
<
uint64_t
>
mStartExcludingSuspendMs
;
static
Maybe
<
uint64_t
>
mStartIncludingSuspendMs
;
#
if
defined
(
__APPLE__
)
&
&
defined
(
__MACH__
)
#
include
<
time
.
h
>
#
include
<
sys
/
time
.
h
>
#
include
<
sys
/
types
.
h
>
#
include
<
mach
/
mach_time
.
h
>
const
uint64_t
kNSperMS
=
1000000
;
Maybe
<
uint64_t
>
NowExcludingSuspendMs
(
)
{
return
Some
(
clock_gettime_nsec_np
(
CLOCK_UPTIME_RAW
)
/
kNSperMS
)
;
}
Maybe
<
uint64_t
>
NowIncludingSuspendMs
(
)
{
return
Some
(
clock_gettime_nsec_np
(
CLOCK_MONOTONIC_RAW
)
/
kNSperMS
)
;
}
#
elif
defined
(
XP_WIN
)
static
constexpr
uint64_t
kHNSperMS
=
10000
;
Maybe
<
uint64_t
>
NowExcludingSuspendMs
(
)
{
ULONGLONG
interrupt_time
;
if
(
!
QueryUnbiasedInterruptTime
(
&
interrupt_time
)
)
{
return
Nothing
(
)
;
}
return
Some
(
interrupt_time
/
kHNSperMS
)
;
}
Maybe
<
uint64_t
>
NowIncludingSuspendMs
(
)
{
static
const
mozilla
:
:
StaticDynamicallyLinkedFunctionPtr
<
void
(
WINAPI
*
)
(
PULONGLONG
)
>
pQueryInterruptTime
(
L
"
KernelBase
.
dll
"
"
QueryInterruptTime
"
)
;
if
(
!
pQueryInterruptTime
)
{
TimeStamp
processCreation
=
TimeStamp
:
:
ProcessCreation
(
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
if
(
!
processCreation
.
IsNull
(
)
&
&
!
now
.
IsNull
(
)
)
{
return
Some
(
uint64_t
(
(
now
-
processCreation
)
.
ToMilliseconds
(
)
)
)
;
}
else
{
return
Nothing
(
)
;
}
}
ULONGLONG
interrupt_time
;
pQueryInterruptTime
(
&
interrupt_time
)
;
return
Some
(
interrupt_time
/
kHNSperMS
)
;
}
#
elif
defined
(
XP_LINUX
)
#
include
<
time
.
h
>
static
constexpr
uint64_t
kNSperMS
=
1000000
;
uint64_t
TimespecToMilliseconds
(
struct
timespec
aTs
)
{
return
aTs
.
tv_sec
*
1000
+
aTs
.
tv_nsec
/
kNSperMS
;
}
Maybe
<
uint64_t
>
NowExcludingSuspendMs
(
)
{
struct
timespec
ts
=
{
0
}
;
if
(
clock_gettime
(
CLOCK_MONOTONIC
&
ts
)
)
{
return
Nothing
(
)
;
}
return
Some
(
TimespecToMilliseconds
(
ts
)
)
;
}
Maybe
<
uint64_t
>
NowIncludingSuspendMs
(
)
{
#
ifndef
CLOCK_BOOTTIME
return
Nothing
(
)
;
#
else
struct
timespec
ts
=
{
0
}
;
if
(
clock_gettime
(
CLOCK_BOOTTIME
&
ts
)
)
{
return
Nothing
(
)
;
}
return
Some
(
TimespecToMilliseconds
(
ts
)
)
;
#
endif
}
#
else
Maybe
<
uint64_t
>
NowExcludingSuspendMs
(
)
{
return
Nothing
(
)
;
}
Maybe
<
uint64_t
>
NowIncludingSuspendMs
(
)
{
return
Nothing
(
)
;
}
#
endif
}
;
namespace
mozilla
{
void
InitializeUptime
(
)
{
MOZ_RELEASE_ASSERT
(
mStartIncludingSuspendMs
.
isNothing
(
)
&
&
mStartExcludingSuspendMs
.
isNothing
(
)
"
Must
not
be
called
more
than
once
"
)
;
mStartIncludingSuspendMs
=
NowIncludingSuspendMs
(
)
;
mStartExcludingSuspendMs
=
NowExcludingSuspendMs
(
)
;
}
Maybe
<
uint64_t
>
ProcessUptimeMs
(
)
{
if
(
!
mStartIncludingSuspendMs
)
{
return
Nothing
(
)
;
}
Maybe
<
uint64_t
>
maybeNow
=
NowIncludingSuspendMs
(
)
;
if
(
!
maybeNow
)
{
return
Nothing
(
)
;
}
return
Some
(
maybeNow
.
value
(
)
-
mStartIncludingSuspendMs
.
value
(
)
)
;
}
Maybe
<
uint64_t
>
ProcessUptimeExcludingSuspendMs
(
)
{
if
(
!
mStartExcludingSuspendMs
)
{
return
Nothing
(
)
;
}
Maybe
<
uint64_t
>
maybeNow
=
NowExcludingSuspendMs
(
)
;
if
(
!
maybeNow
)
{
return
Nothing
(
)
;
}
return
Some
(
maybeNow
.
value
(
)
-
mStartExcludingSuspendMs
.
value
(
)
)
;
}
}
;
