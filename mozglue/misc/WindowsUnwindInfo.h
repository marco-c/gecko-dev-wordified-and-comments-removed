#
ifndef
mozilla_WindowsUnwindInfo_h
#
define
mozilla_WindowsUnwindInfo_h
#
ifdef
_M_X64
#
include
<
cstdint
>
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
namespace
mozilla
{
enum
UnwindOperationCodes
:
uint8_t
{
UWOP_PUSH_NONVOL
=
0
UWOP_ALLOC_LARGE
=
1
UWOP_ALLOC_SMALL
=
2
UWOP_SET_FPREG
=
3
UWOP_SAVE_NONVOL
=
4
UWOP_SAVE_NONVOL_FAR
=
5
UWOP_SAVE_XMM
=
6
UWOP_EPILOG
=
6
UWOP_SAVE_XMM_FAR
=
7
UWOP_SPARE
=
7
UWOP_SAVE_XMM128
=
8
UWOP_SAVE_XMM128_FAR
=
9
UWOP_PUSH_MACHFRAME
=
10
}
;
union
UnwindCode
{
struct
{
uint8_t
offset_in_prolog
;
UnwindOperationCodes
unwind_operation_code
:
4
;
uint8_t
operation_info
:
4
;
}
;
uint16_t
frame_offset
;
}
;
struct
UnwindInfo
{
uint8_t
version
:
3
;
uint8_t
flags
:
5
;
uint8_t
size_of_prolog
;
uint8_t
count_of_codes
;
uint8_t
frame_register
:
4
;
uint8_t
frame_offset
:
4
;
UnwindCode
unwind_code
[
1
]
;
UnwindInfo
(
const
UnwindInfo
&
)
=
delete
;
UnwindInfo
&
operator
=
(
const
UnwindInfo
&
)
=
delete
;
UnwindInfo
(
UnwindInfo
&
&
)
=
delete
;
UnwindInfo
&
operator
=
(
UnwindInfo
&
&
)
=
delete
;
~
UnwindInfo
(
)
=
delete
;
inline
size_t
Size
(
)
const
{
return
offsetof
(
UnwindInfo
unwind_code
)
+
count_of_codes
*
sizeof
(
UnwindCode
)
;
}
UniquePtr
<
uint8_t
[
]
>
Copy
(
)
const
{
auto
s
=
Size
(
)
;
auto
result
=
MakeUnique
<
uint8_t
[
]
>
(
s
)
;
std
:
:
memcpy
(
result
.
get
(
)
reinterpret_cast
<
const
void
*
>
(
this
)
s
)
;
return
result
;
}
bool
GetSlotsCountForCodeAt
(
uint8_t
aIndex
uint8_t
*
aSlotsCount
)
const
{
if
(
aIndex
>
=
count_of_codes
)
{
MOZ_ASSERT_UNREACHABLE
(
"
The
index
is
out
of
bounds
"
)
;
return
false
;
}
const
UnwindCode
&
unwindCode
=
unwind_code
[
aIndex
]
;
uint8_t
slotsCount
=
0
;
switch
(
unwindCode
.
unwind_operation_code
)
{
case
UWOP_SAVE_NONVOL_FAR
:
case
UWOP_SAVE_XMM128_FAR
:
slotsCount
=
3
;
break
;
case
UWOP_SAVE_NONVOL
:
case
UWOP_SAVE_XMM128
:
slotsCount
=
2
;
break
;
case
UWOP_PUSH_NONVOL
:
case
UWOP_ALLOC_SMALL
:
case
UWOP_SET_FPREG
:
case
UWOP_PUSH_MACHFRAME
:
slotsCount
=
1
;
break
;
case
UWOP_ALLOC_LARGE
:
if
(
unwindCode
.
operation_info
>
1
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Operation
UWOP_ALLOC_LARGE
is
used
but
operation_info
"
"
is
not
0
or
1
"
)
;
return
false
;
}
slotsCount
=
2
+
unwindCode
.
operation_info
;
break
;
case
UWOP_SPARE
:
if
(
version
!
=
2
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Operation
code
UWOP_SPARE
is
used
but
version
is
not
2
"
)
;
return
false
;
}
slotsCount
=
3
;
break
;
case
UWOP_EPILOG
:
if
(
version
!
=
2
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Operation
code
UWOP_EPILOG
is
used
but
version
is
not
2
"
)
;
return
false
;
}
slotsCount
=
2
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
An
unknown
operation
code
is
used
"
)
;
return
false
;
}
if
(
count_of_codes
-
aIndex
<
slotsCount
)
{
MOZ_ASSERT_UNREACHABLE
(
"
A
valid
operation
code
is
used
but
it
spans
too
many
slots
"
)
;
return
false
;
}
*
aSlotsCount
=
slotsCount
;
return
true
;
}
}
;
class
IterableUnwindInfo
{
class
Iterator
{
public
:
UnwindInfo
&
Info
(
)
{
return
mInfo
;
}
uint8_t
Index
(
)
const
{
MOZ_ASSERT
(
IsValid
(
)
)
;
return
mIndex
;
}
uint8_t
SlotsCount
(
)
const
{
MOZ_ASSERT
(
IsValid
(
)
)
;
return
mSlotsCount
;
}
bool
IsValid
(
)
const
{
return
mIsValid
;
}
bool
IsAtEnd
(
)
const
{
return
mIndex
>
=
mInfo
.
count_of_codes
;
}
bool
operator
=
=
(
const
Iterator
&
aOther
)
const
{
if
(
mIsValid
!
=
aOther
.
mIsValid
)
{
return
false
;
}
if
(
!
mIsValid
)
{
return
true
;
}
return
mIndex
=
=
aOther
.
mIndex
;
}
bool
operator
!
=
(
const
Iterator
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
Iterator
&
operator
+
+
(
)
{
MOZ_ASSERT
(
IsValid
(
)
)
;
mIndex
+
=
mSlotsCount
;
if
(
mIndex
<
mInfo
.
count_of_codes
)
{
mIsValid
=
mInfo
.
GetSlotsCountForCodeAt
(
mIndex
&
mSlotsCount
)
;
MOZ_ASSERT
(
IsValid
(
)
)
;
}
else
{
mIsValid
=
false
;
}
return
*
this
;
}
const
UnwindCode
&
operator
*
(
)
{
MOZ_ASSERT
(
IsValid
(
)
)
;
return
mInfo
.
unwind_code
[
mIndex
]
;
}
private
:
friend
class
IterableUnwindInfo
;
Iterator
(
UnwindInfo
&
aInfo
uint8_t
aIndex
uint8_t
aSlotsCount
bool
aIsValid
)
:
mInfo
(
aInfo
)
mIndex
(
aIndex
)
mSlotsCount
(
aSlotsCount
)
mIsValid
(
aIsValid
)
{
}
;
UnwindInfo
&
mInfo
;
uint8_t
mIndex
;
uint8_t
mSlotsCount
;
bool
mIsValid
;
}
;
public
:
explicit
IterableUnwindInfo
(
UnwindInfo
&
aInfo
)
:
mBegin
(
aInfo
0
0
false
)
mEnd
(
aInfo
aInfo
.
count_of_codes
0
false
)
{
if
(
aInfo
.
count_of_codes
)
{
mBegin
.
mIsValid
=
aInfo
.
GetSlotsCountForCodeAt
(
0
&
mBegin
.
mSlotsCount
)
;
MOZ_ASSERT
(
mBegin
.
mIsValid
)
;
}
}
explicit
IterableUnwindInfo
(
uint8_t
*
aInfo
)
:
IterableUnwindInfo
(
*
reinterpret_cast
<
UnwindInfo
*
>
(
aInfo
)
)
{
}
UnwindInfo
&
Info
(
)
{
return
mBegin
.
Info
(
)
;
}
const
Iterator
&
begin
(
)
{
return
mBegin
;
}
const
Iterator
&
end
(
)
{
return
mEnd
;
}
private
:
Iterator
mBegin
;
Iterator
mEnd
;
}
;
}
#
endif
#
endif
