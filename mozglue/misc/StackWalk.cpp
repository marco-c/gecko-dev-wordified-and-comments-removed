#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
StackWalk
.
h
"
#
ifdef
XP_WIN
#
include
"
mozilla
/
StackWalkThread
.
h
"
#
include
<
io
.
h
>
#
else
#
include
<
unistd
.
h
>
#
endif
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
<
string
.
h
>
#
if
defined
(
ANDROID
)
&
&
defined
(
MOZ_LINKER
)
#
include
"
Linker
.
h
"
#
include
<
android
/
log
.
h
>
#
endif
using
namespace
mozilla
;
#
if
defined
(
HAVE__UNWIND_BACKTRACE
)
&
&
!
defined
(
_GNU_SOURCE
)
#
define
_GNU_SOURCE
#
endif
#
if
defined
(
HAVE_DLFCN_H
)
|
|
defined
(
XP_DARWIN
)
#
include
<
dlfcn
.
h
>
#
endif
#
if
(
defined
(
XP_DARWIN
)
&
&
\
(
defined
(
__i386
)
|
|
defined
(
__ppc__
)
|
|
defined
(
HAVE__UNWIND_BACKTRACE
)
)
)
#
define
MOZ_STACKWALK_SUPPORTS_MACOSX
1
#
else
#
define
MOZ_STACKWALK_SUPPORTS_MACOSX
0
#
endif
#
if
(
defined
(
linux
)
&
&
\
(
(
defined
(
__GNUC__
)
&
&
(
defined
(
__i386
)
|
|
defined
(
PPC
)
)
)
|
|
\
defined
(
HAVE__UNWIND_BACKTRACE
)
)
)
#
define
MOZ_STACKWALK_SUPPORTS_LINUX
1
#
else
#
define
MOZ_STACKWALK_SUPPORTS_LINUX
0
#
endif
#
if
__GLIBC__
>
2
|
|
(
__GLIBC__
=
=
2
&
&
__GLIBC_MINOR__
>
=
1
)
#
define
HAVE___LIBC_STACK_END
1
#
else
#
define
HAVE___LIBC_STACK_END
0
#
endif
#
if
HAVE___LIBC_STACK_END
extern
MOZ_EXPORT
void
*
__libc_stack_end
;
#
endif
#
ifdef
ANDROID
#
include
<
algorithm
>
#
include
<
unistd
.
h
>
#
include
<
pthread
.
h
>
#
endif
class
FrameSkipper
{
public
:
constexpr
FrameSkipper
(
)
:
mSkipUntilAddr
(
0
)
{
}
static
uintptr_t
AddressFromPC
(
const
void
*
aPC
)
{
#
ifdef
__arm__
return
uintptr_t
(
aPC
)
&
~
1
;
#
else
return
uintptr_t
(
aPC
)
;
#
endif
}
bool
ShouldSkipPC
(
void
*
aPC
)
{
uintptr_t
instructionAddress
=
AddressFromPC
(
aPC
)
;
if
(
mSkipUntilAddr
!
=
0
)
{
if
(
mSkipUntilAddr
!
=
instructionAddress
)
{
return
true
;
}
mSkipUntilAddr
=
0
;
}
return
false
;
}
explicit
FrameSkipper
(
const
void
*
aPC
)
:
mSkipUntilAddr
(
AddressFromPC
(
aPC
)
)
{
}
private
:
uintptr_t
mSkipUntilAddr
;
}
;
#
ifdef
XP_WIN
#
include
<
windows
.
h
>
#
include
<
process
.
h
>
#
include
<
stdio
.
h
>
#
include
<
malloc
.
h
>
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
StackWalk_windows
.
h
"
#
include
"
mozilla
/
WindowsVersion
.
h
"
#
include
<
imagehlp
.
h
>
#
if
API_VERSION_NUMBER
<
9
#
error
Too
old
imagehlp
.
h
#
endif
CRITICAL_SECTION
gDbgHelpCS
;
#
if
defined
(
_M_AMD64
)
|
|
defined
(
_M_ARM64
)
static
Atomic
<
size_t
>
sStackWalkSuppressions
;
void
SuppressStackWalking
(
)
{
+
+
sStackWalkSuppressions
;
}
void
DesuppressStackWalking
(
)
{
auto
previousValue
=
sStackWalkSuppressions
-
-
;
MOZ_RELEASE_ASSERT
(
previousValue
)
;
}
MFBT_API
AutoSuppressStackWalking
:
:
AutoSuppressStackWalking
(
)
{
SuppressStackWalking
(
)
;
}
MFBT_API
AutoSuppressStackWalking
:
:
~
AutoSuppressStackWalking
(
)
{
DesuppressStackWalking
(
)
;
}
static
uint8_t
*
sJitCodeRegionStart
;
static
size_t
sJitCodeRegionSize
;
uint8_t
*
sMsMpegJitCodeRegionStart
;
size_t
sMsMpegJitCodeRegionSize
;
MFBT_API
void
RegisterJitCodeRegion
(
uint8_t
*
aStart
size_t
aSize
)
{
MOZ_RELEASE_ASSERT
(
!
sJitCodeRegionStart
)
;
sJitCodeRegionStart
=
aStart
;
sJitCodeRegionSize
=
aSize
;
}
MFBT_API
void
UnregisterJitCodeRegion
(
uint8_t
*
aStart
size_t
aSize
)
{
MOZ_RELEASE_ASSERT
(
sJitCodeRegionStart
&
&
sJitCodeRegionStart
=
=
aStart
&
&
sJitCodeRegionSize
=
=
aSize
)
;
sJitCodeRegionStart
=
nullptr
;
sJitCodeRegionSize
=
0
;
}
#
endif
static
void
PrintError
(
const
char
*
aPrefix
)
{
LPSTR
lpMsgBuf
;
DWORD
lastErr
=
GetLastError
(
)
;
FormatMessageA
(
FORMAT_MESSAGE_ALLOCATE_BUFFER
|
FORMAT_MESSAGE_FROM_SYSTEM
|
FORMAT_MESSAGE_IGNORE_INSERTS
nullptr
lastErr
MAKELANGID
(
LANG_NEUTRAL
SUBLANG_DEFAULT
)
(
LPSTR
)
&
lpMsgBuf
0
nullptr
)
;
fprintf
(
stderr
"
#
#
#
ERROR
:
%
s
:
%
s
"
aPrefix
lpMsgBuf
?
lpMsgBuf
:
"
(
null
)
\
n
"
)
;
fflush
(
stderr
)
;
LocalFree
(
lpMsgBuf
)
;
}
enum
class
DbgHelpInitFlags
:
bool
{
BasicInit
WithSymbolSupport
}
;
[
[
nodiscard
]
]
static
bool
InitializeDbgHelp
(
DbgHelpInitFlags
aInitFlags
=
DbgHelpInitFlags
:
:
BasicInit
)
{
static
Atomic
<
DWORD
>
sInitializationThreadId
{
0
}
;
DWORD
currentThreadId
=
:
:
GetCurrentThreadId
(
)
;
if
(
!
currentThreadId
)
{
return
false
;
}
if
(
sInitializationThreadId
=
=
currentThreadId
)
{
return
false
;
}
static
const
bool
sHasInitializedDbgHelp
=
[
currentThreadId
]
(
)
{
sInitializationThreadId
=
currentThreadId
;
:
:
InitializeCriticalSection
(
&
gDbgHelpCS
)
;
bool
dbgHelpLoaded
=
static_cast
<
bool
>
(
:
:
LoadLibraryW
(
L
"
dbghelp
.
dll
"
)
)
;
MOZ_ASSERT
(
dbgHelpLoaded
)
;
sInitializationThreadId
=
0
;
return
dbgHelpLoaded
;
}
(
)
;
if
(
aInitFlags
=
=
DbgHelpInitFlags
:
:
BasicInit
|
|
!
sHasInitializedDbgHelp
)
{
return
sHasInitializedDbgHelp
;
}
static
const
bool
sHasInitializedSymbols
=
[
currentThreadId
]
(
)
{
sInitializationThreadId
=
currentThreadId
;
EnterCriticalSection
(
&
gDbgHelpCS
)
;
SymSetOptions
(
SYMOPT_LOAD_LINES
|
SYMOPT_UNDNAME
)
;
bool
symbolsInitialized
=
SymInitialize
(
GetCurrentProcess
(
)
nullptr
TRUE
)
;
LeaveCriticalSection
(
&
gDbgHelpCS
)
;
if
(
!
symbolsInitialized
)
{
PrintError
(
"
SymInitialize
"
)
;
}
MOZ_ASSERT
(
symbolsInitialized
)
;
sInitializationThreadId
=
0
;
return
symbolsInitialized
;
}
(
)
;
return
sHasInitializedSymbols
;
}
class
CONTEXTGenericAccessors
{
public
:
explicit
CONTEXTGenericAccessors
(
CONTEXT
&
aCONTEXT
)
:
mCONTEXT
(
aCONTEXT
)
{
}
CONTEXT
*
CONTEXTPtr
(
)
{
return
&
mCONTEXT
;
}
inline
auto
&
PC
(
)
{
#
if
defined
(
_M_AMD64
)
return
mCONTEXT
.
Rip
;
#
elif
defined
(
_M_ARM64
)
return
mCONTEXT
.
Pc
;
#
elif
defined
(
_M_IX86
)
return
mCONTEXT
.
Eip
;
#
else
#
error
"
unknown
platform
"
#
endif
}
inline
auto
&
SP
(
)
{
#
if
defined
(
_M_AMD64
)
return
mCONTEXT
.
Rsp
;
#
elif
defined
(
_M_ARM64
)
return
mCONTEXT
.
Sp
;
#
elif
defined
(
_M_IX86
)
return
mCONTEXT
.
Esp
;
#
else
#
error
"
unknown
platform
"
#
endif
}
inline
auto
&
BP
(
)
{
#
if
defined
(
_M_AMD64
)
return
mCONTEXT
.
Rbp
;
#
elif
defined
(
_M_ARM64
)
return
mCONTEXT
.
Fp
;
#
elif
defined
(
_M_IX86
)
return
mCONTEXT
.
Ebp
;
#
else
#
error
"
unknown
platform
"
#
endif
}
private
:
CONTEXT
&
mCONTEXT
;
}
;
static
void
DoMozStackWalkThread
(
MozWalkStackCallback
aCallback
const
void
*
aFirstFramePC
uint32_t
aMaxFrames
void
*
aClosure
HANDLE
aThread
CONTEXT
*
aContext
)
{
#
if
defined
(
_M_IX86
)
if
(
!
InitializeDbgHelp
(
)
)
{
return
;
}
#
endif
HANDLE
targetThread
=
aThread
;
bool
walkCallingThread
;
if
(
!
targetThread
)
{
targetThread
=
:
:
GetCurrentThread
(
)
;
walkCallingThread
=
true
;
}
else
{
DWORD
targetThreadId
=
:
:
GetThreadId
(
targetThread
)
;
DWORD
currentThreadId
=
:
:
GetCurrentThreadId
(
)
;
walkCallingThread
=
(
targetThreadId
=
=
currentThreadId
)
;
}
CONTEXT
context_buf
;
if
(
!
aContext
)
{
memset
(
&
context_buf
0
sizeof
(
CONTEXT
)
)
;
context_buf
.
ContextFlags
=
CONTEXT_FULL
;
if
(
walkCallingThread
)
{
:
:
RtlCaptureContext
(
&
context_buf
)
;
}
else
if
(
!
GetThreadContext
(
targetThread
&
context_buf
)
)
{
return
;
}
}
CONTEXTGenericAccessors
context
{
aContext
?
*
aContext
:
context_buf
}
;
#
if
defined
(
_M_IX86
)
STACKFRAME64
frame64
;
memset
(
&
frame64
0
sizeof
(
frame64
)
)
;
frame64
.
AddrPC
.
Offset
=
context
.
PC
(
)
;
frame64
.
AddrStack
.
Offset
=
context
.
SP
(
)
;
frame64
.
AddrFrame
.
Offset
=
context
.
BP
(
)
;
frame64
.
AddrPC
.
Mode
=
AddrModeFlat
;
frame64
.
AddrStack
.
Mode
=
AddrModeFlat
;
frame64
.
AddrFrame
.
Mode
=
AddrModeFlat
;
frame64
.
AddrReturn
.
Mode
=
AddrModeFlat
;
#
endif
#
if
defined
(
_M_AMD64
)
|
|
defined
(
_M_ARM64
)
if
(
sStackWalkSuppressions
)
{
return
;
}
bool
firstFrame
=
true
;
#
endif
FrameSkipper
skipper
(
aFirstFramePC
)
;
uint32_t
frames
=
0
;
while
(
true
)
{
DWORD64
addr
;
DWORD64
spaddr
;
#
if
defined
(
_M_IX86
)
EnterCriticalSection
(
&
gDbgHelpCS
)
;
BOOL
ok
=
StackWalk64
(
IMAGE_FILE_MACHINE_I386
:
:
GetCurrentProcess
(
)
targetThread
&
frame64
context
.
CONTEXTPtr
(
)
nullptr
SymFunctionTableAccess64
SymGetModuleBase64
0
)
;
LeaveCriticalSection
(
&
gDbgHelpCS
)
;
if
(
ok
)
{
addr
=
frame64
.
AddrPC
.
Offset
;
spaddr
=
frame64
.
AddrStack
.
Offset
;
}
else
{
addr
=
0
;
spaddr
=
0
;
if
(
walkCallingThread
)
{
PrintError
(
"
WalkStack64
"
)
;
}
}
if
(
!
ok
)
{
break
;
}
#
elif
defined
(
_M_AMD64
)
|
|
defined
(
_M_ARM64
)
auto
currentInstr
=
context
.
PC
(
)
;
if
(
sJitCodeRegionStart
&
&
(
uint8_t
*
)
currentInstr
>
=
sJitCodeRegionStart
&
&
(
uint8_t
*
)
currentInstr
<
sJitCodeRegionStart
+
sJitCodeRegionSize
)
{
break
;
}
if
(
sMsMpegJitCodeRegionStart
&
&
(
uint8_t
*
)
currentInstr
>
=
sMsMpegJitCodeRegionStart
&
&
(
uint8_t
*
)
currentInstr
<
sMsMpegJitCodeRegionStart
+
sMsMpegJitCodeRegionSize
)
{
break
;
}
ULONG64
imageBase
;
PRUNTIME_FUNCTION
runtimeFunction
=
RtlLookupFunctionEntry
(
currentInstr
&
imageBase
NULL
)
;
if
(
runtimeFunction
)
{
PVOID
dummyHandlerData
;
ULONG64
dummyEstablisherFrame
;
RtlVirtualUnwind
(
UNW_FLAG_NHANDLER
imageBase
currentInstr
runtimeFunction
context
.
CONTEXTPtr
(
)
&
dummyHandlerData
&
dummyEstablisherFrame
nullptr
)
;
}
else
if
(
firstFrame
)
{
context
.
PC
(
)
=
*
reinterpret_cast
<
DWORD64
*
>
(
context
.
SP
(
)
)
;
context
.
SP
(
)
+
=
sizeof
(
void
*
)
;
}
else
{
break
;
}
addr
=
context
.
PC
(
)
;
spaddr
=
context
.
SP
(
)
;
firstFrame
=
false
;
#
else
#
error
"
unknown
platform
"
#
endif
if
(
addr
=
=
0
)
{
break
;
}
if
(
skipper
.
ShouldSkipPC
(
(
void
*
)
addr
)
)
{
continue
;
}
aCallback
(
+
+
frames
(
void
*
)
addr
(
void
*
)
spaddr
aClosure
)
;
if
(
aMaxFrames
!
=
0
&
&
frames
=
=
aMaxFrames
)
{
break
;
}
#
if
defined
(
_M_IX86
)
if
(
frame64
.
AddrReturn
.
Offset
=
=
0
)
{
break
;
}
#
endif
}
}
MFBT_API
void
MozStackWalkThread
(
MozWalkStackCallback
aCallback
uint32_t
aMaxFrames
void
*
aClosure
HANDLE
aThread
CONTEXT
*
aContext
)
{
DoMozStackWalkThread
(
aCallback
nullptr
aMaxFrames
aClosure
aThread
aContext
)
;
}
MFBT_API
void
MozStackWalk
(
MozWalkStackCallback
aCallback
const
void
*
aFirstFramePC
uint32_t
aMaxFrames
void
*
aClosure
)
{
DoMozStackWalkThread
(
aCallback
aFirstFramePC
?
aFirstFramePC
:
CallerPC
(
)
aMaxFrames
aClosure
nullptr
nullptr
)
;
}
static
BOOL
CALLBACK
callbackEspecial64
(
PCSTR
aModuleName
DWORD64
aModuleBase
ULONG
aModuleSize
PVOID
aUserContext
)
{
BOOL
retval
=
TRUE
;
DWORD64
addr
=
*
(
DWORD64
*
)
aUserContext
;
const
BOOL
addressIncreases
=
TRUE
;
if
(
addressIncreases
?
(
addr
>
=
aModuleBase
&
&
addr
<
=
(
aModuleBase
+
aModuleSize
)
)
:
(
addr
<
=
aModuleBase
&
&
addr
>
=
(
aModuleBase
-
aModuleSize
)
)
)
{
retval
=
!
!
SymLoadModule64
(
GetCurrentProcess
(
)
nullptr
(
PSTR
)
aModuleName
nullptr
aModuleBase
aModuleSize
)
;
if
(
!
retval
)
{
PrintError
(
"
SymLoadModule64
"
)
;
}
}
return
retval
;
}
#
ifdef
SSRVOPT_SETCONTEXT
#
define
NS_IMAGEHLP_MODULE64_SIZE
\
(
(
(
offsetof
(
IMAGEHLP_MODULE64
LoadedPdbName
)
+
sizeof
(
DWORD64
)
-
1
)
/
\
sizeof
(
DWORD64
)
)
*
\
sizeof
(
DWORD64
)
)
#
else
#
define
NS_IMAGEHLP_MODULE64_SIZE
sizeof
(
IMAGEHLP_MODULE64
)
#
endif
BOOL
SymGetModuleInfoEspecial64
(
HANDLE
aProcess
DWORD64
aAddr
PIMAGEHLP_MODULE64
aModuleInfo
PIMAGEHLP_LINE64
aLineInfo
)
{
BOOL
retval
=
FALSE
;
aModuleInfo
-
>
SizeOfStruct
=
NS_IMAGEHLP_MODULE64_SIZE
;
if
(
aLineInfo
)
{
aLineInfo
-
>
SizeOfStruct
=
sizeof
(
IMAGEHLP_LINE64
)
;
}
retval
=
SymGetModuleInfo64
(
aProcess
aAddr
aModuleInfo
)
;
if
(
retval
=
=
FALSE
)
{
BOOL
enumRes
=
EnumerateLoadedModules64
(
aProcess
(
PENUMLOADED_MODULES_CALLBACK64
)
callbackEspecial64
(
PVOID
)
&
aAddr
)
;
if
(
enumRes
!
=
FALSE
)
{
retval
=
SymGetModuleInfo64
(
aProcess
aAddr
aModuleInfo
)
;
}
}
if
(
retval
!
=
FALSE
&
&
aLineInfo
)
{
DWORD
displacement
=
0
;
BOOL
lineRes
=
FALSE
;
lineRes
=
SymGetLineFromAddr64
(
aProcess
aAddr
&
displacement
aLineInfo
)
;
if
(
!
lineRes
)
{
memset
(
aLineInfo
0
sizeof
(
*
aLineInfo
)
)
;
}
}
return
retval
;
}
MFBT_API
bool
MozDescribeCodeAddress
(
void
*
aPC
MozCodeAddressDetails
*
aDetails
)
{
aDetails
-
>
library
[
0
]
=
'
\
0
'
;
aDetails
-
>
loffset
=
0
;
aDetails
-
>
filename
[
0
]
=
'
\
0
'
;
aDetails
-
>
lineno
=
0
;
aDetails
-
>
function
[
0
]
=
'
\
0
'
;
aDetails
-
>
foffset
=
0
;
if
(
!
InitializeDbgHelp
(
DbgHelpInitFlags
:
:
WithSymbolSupport
)
)
{
return
false
;
}
HANDLE
myProcess
=
:
:
GetCurrentProcess
(
)
;
BOOL
ok
;
EnterCriticalSection
(
&
gDbgHelpCS
)
;
DWORD64
addr
=
(
DWORD64
)
aPC
;
IMAGEHLP_MODULE64
modInfo
;
IMAGEHLP_LINE64
lineInfo
;
BOOL
modInfoRes
;
modInfoRes
=
SymGetModuleInfoEspecial64
(
myProcess
addr
&
modInfo
&
lineInfo
)
;
if
(
modInfoRes
)
{
strncpy
(
aDetails
-
>
library
modInfo
.
LoadedImageName
sizeof
(
aDetails
-
>
library
)
)
;
aDetails
-
>
library
[
mozilla
:
:
ArrayLength
(
aDetails
-
>
library
)
-
1
]
=
'
\
0
'
;
aDetails
-
>
loffset
=
(
char
*
)
aPC
-
(
char
*
)
modInfo
.
BaseOfImage
;
if
(
lineInfo
.
FileName
)
{
strncpy
(
aDetails
-
>
filename
lineInfo
.
FileName
sizeof
(
aDetails
-
>
filename
)
)
;
aDetails
-
>
filename
[
mozilla
:
:
ArrayLength
(
aDetails
-
>
filename
)
-
1
]
=
'
\
0
'
;
aDetails
-
>
lineno
=
lineInfo
.
LineNumber
;
}
}
ULONG64
buffer
[
(
sizeof
(
SYMBOL_INFO
)
+
MAX_SYM_NAME
*
sizeof
(
TCHAR
)
+
sizeof
(
ULONG64
)
-
1
)
/
sizeof
(
ULONG64
)
]
;
PSYMBOL_INFO
pSymbol
=
(
PSYMBOL_INFO
)
buffer
;
pSymbol
-
>
SizeOfStruct
=
sizeof
(
SYMBOL_INFO
)
;
pSymbol
-
>
MaxNameLen
=
MAX_SYM_NAME
;
DWORD64
displacement
;
ok
=
SymFromAddr
(
myProcess
addr
&
displacement
pSymbol
)
;
if
(
ok
)
{
strncpy
(
aDetails
-
>
function
pSymbol
-
>
Name
sizeof
(
aDetails
-
>
function
)
)
;
aDetails
-
>
function
[
mozilla
:
:
ArrayLength
(
aDetails
-
>
function
)
-
1
]
=
'
\
0
'
;
aDetails
-
>
foffset
=
static_cast
<
ptrdiff_t
>
(
displacement
)
;
}
LeaveCriticalSection
(
&
gDbgHelpCS
)
;
return
true
;
}
#
elif
HAVE_DLADDR
&
&
\
(
HAVE__UNWIND_BACKTRACE
|
|
MOZ_STACKWALK_SUPPORTS_LINUX
|
|
\
MOZ_STACKWALK_SUPPORTS_MACOSX
)
#
include
<
stdlib
.
h
>
#
include
<
stdio
.
h
>
#
if
(
__GLIBC_MINOR__
>
=
1
)
&
&
!
defined
(
__USE_GNU
)
#
define
__USE_GNU
#
endif
#
if
defined
(
MOZ_DEMANGLE_SYMBOLS
)
#
include
<
cxxabi
.
h
>
#
endif
namespace
mozilla
{
void
DemangleSymbol
(
const
char
*
aSymbol
char
*
aBuffer
int
aBufLen
)
{
aBuffer
[
0
]
=
'
\
0
'
;
#
if
defined
(
MOZ_DEMANGLE_SYMBOLS
)
char
*
demangled
=
abi
:
:
__cxa_demangle
(
aSymbol
0
0
0
)
;
if
(
demangled
)
{
strncpy
(
aBuffer
demangled
aBufLen
)
;
aBuffer
[
aBufLen
-
1
]
=
'
\
0
'
;
free
(
demangled
)
;
}
#
endif
}
}
#
if
(
(
defined
(
__i386
)
|
|
defined
(
PPC
)
|
|
defined
(
__ppc__
)
)
&
&
\
(
MOZ_STACKWALK_SUPPORTS_MACOSX
|
|
MOZ_STACKWALK_SUPPORTS_LINUX
)
)
static
void
DoFramePointerStackWalk
(
MozWalkStackCallback
aCallback
const
void
*
aFirstFramePC
uint32_t
aMaxFrames
void
*
aClosure
void
*
*
aBp
void
*
aStackEnd
)
;
MFBT_API
void
MozStackWalk
(
MozWalkStackCallback
aCallback
const
void
*
aFirstFramePC
uint32_t
aMaxFrames
void
*
aClosure
)
{
void
*
*
bp
=
(
void
*
*
)
__builtin_frame_address
(
0
)
;
void
*
stackEnd
;
#
if
HAVE___LIBC_STACK_END
stackEnd
=
__libc_stack_end
;
#
elif
defined
(
XP_DARWIN
)
stackEnd
=
pthread_get_stackaddr_np
(
pthread_self
(
)
)
;
#
elif
defined
(
ANDROID
)
pthread_attr_t
sattr
;
pthread_attr_init
(
&
sattr
)
;
pthread_getattr_np
(
pthread_self
(
)
&
sattr
)
;
void
*
stackBase
=
stackEnd
=
nullptr
;
size_t
stackSize
=
0
;
if
(
gettid
(
)
!
=
getpid
(
)
)
{
if
(
!
pthread_attr_getstack
(
&
sattr
&
stackBase
&
stackSize
)
)
{
stackEnd
=
static_cast
<
char
*
>
(
stackBase
)
+
stackSize
;
}
else
{
stackEnd
=
nullptr
;
}
}
if
(
!
stackEnd
)
{
static
const
uintptr_t
kMaxStackSize
=
8
*
1024
*
1024
;
uintptr_t
maxStackStart
=
uintptr_t
(
-
1
)
-
kMaxStackSize
;
uintptr_t
stackStart
=
std
:
:
max
(
maxStackStart
uintptr_t
(
bp
)
)
;
stackEnd
=
reinterpret_cast
<
void
*
>
(
stackStart
+
kMaxStackSize
)
;
}
#
else
#
error
Unsupported
configuration
#
endif
DoFramePointerStackWalk
(
aCallback
aFirstFramePC
aMaxFrames
aClosure
bp
stackEnd
)
;
}
#
elif
defined
(
HAVE__UNWIND_BACKTRACE
)
#
include
<
unwind
.
h
>
struct
unwind_info
{
MozWalkStackCallback
callback
;
FrameSkipper
skipper
;
int
maxFrames
;
int
numFrames
;
void
*
closure
;
}
;
static
_Unwind_Reason_Code
unwind_callback
(
struct
_Unwind_Context
*
context
void
*
closure
)
{
unwind_info
*
info
=
static_cast
<
unwind_info
*
>
(
closure
)
;
void
*
pc
=
reinterpret_cast
<
void
*
>
(
_Unwind_GetIP
(
context
)
)
;
if
(
!
info
-
>
skipper
.
ShouldSkipPC
(
pc
)
)
{
info
-
>
numFrames
+
+
;
(
*
info
-
>
callback
)
(
info
-
>
numFrames
pc
nullptr
info
-
>
closure
)
;
if
(
info
-
>
maxFrames
!
=
0
&
&
info
-
>
numFrames
=
=
info
-
>
maxFrames
)
{
return
_URC_FOREIGN_EXCEPTION_CAUGHT
;
}
}
return
_URC_NO_REASON
;
}
MFBT_API
void
MozStackWalk
(
MozWalkStackCallback
aCallback
const
void
*
aFirstFramePC
uint32_t
aMaxFrames
void
*
aClosure
)
{
unwind_info
info
;
info
.
callback
=
aCallback
;
info
.
skipper
=
FrameSkipper
(
aFirstFramePC
?
aFirstFramePC
:
CallerPC
(
)
)
;
info
.
maxFrames
=
aMaxFrames
;
info
.
numFrames
=
0
;
info
.
closure
=
aClosure
;
(
void
)
_Unwind_Backtrace
(
unwind_callback
&
info
)
;
}
#
endif
bool
MFBT_API
MozDescribeCodeAddress
(
void
*
aPC
MozCodeAddressDetails
*
aDetails
)
{
aDetails
-
>
library
[
0
]
=
'
\
0
'
;
aDetails
-
>
loffset
=
0
;
aDetails
-
>
filename
[
0
]
=
'
\
0
'
;
aDetails
-
>
lineno
=
0
;
aDetails
-
>
function
[
0
]
=
'
\
0
'
;
aDetails
-
>
foffset
=
0
;
Dl_info
info
;
#
if
defined
(
ANDROID
)
&
&
defined
(
MOZ_LINKER
)
int
ok
=
__wrap_dladdr
(
aPC
&
info
)
;
#
else
int
ok
=
dladdr
(
aPC
&
info
)
;
#
endif
if
(
!
ok
)
{
return
true
;
}
strncpy
(
aDetails
-
>
library
info
.
dli_fname
sizeof
(
aDetails
-
>
library
)
)
;
aDetails
-
>
library
[
mozilla
:
:
ArrayLength
(
aDetails
-
>
library
)
-
1
]
=
'
\
0
'
;
aDetails
-
>
loffset
=
(
char
*
)
aPC
-
(
char
*
)
info
.
dli_fbase
;
#
if
!
defined
(
XP_FREEBSD
)
const
char
*
symbol
=
info
.
dli_sname
;
if
(
!
symbol
|
|
symbol
[
0
]
=
=
'
\
0
'
)
{
return
true
;
}
DemangleSymbol
(
symbol
aDetails
-
>
function
sizeof
(
aDetails
-
>
function
)
)
;
if
(
aDetails
-
>
function
[
0
]
=
=
'
\
0
'
)
{
strncpy
(
aDetails
-
>
function
symbol
sizeof
(
aDetails
-
>
function
)
)
;
aDetails
-
>
function
[
mozilla
:
:
ArrayLength
(
aDetails
-
>
function
)
-
1
]
=
'
\
0
'
;
}
aDetails
-
>
foffset
=
(
char
*
)
aPC
-
(
char
*
)
info
.
dli_saddr
;
#
endif
return
true
;
}
#
else
MFBT_API
void
MozStackWalk
(
MozWalkStackCallback
aCallback
const
void
*
aFirstFramePC
uint32_t
aMaxFrames
void
*
aClosure
)
{
}
MFBT_API
bool
MozDescribeCodeAddress
(
void
*
aPC
MozCodeAddressDetails
*
aDetails
)
{
aDetails
-
>
library
[
0
]
=
'
\
0
'
;
aDetails
-
>
loffset
=
0
;
aDetails
-
>
filename
[
0
]
=
'
\
0
'
;
aDetails
-
>
lineno
=
0
;
aDetails
-
>
function
[
0
]
=
'
\
0
'
;
aDetails
-
>
foffset
=
0
;
return
false
;
}
#
endif
#
if
defined
(
XP_WIN
)
|
|
defined
(
XP_MACOSX
)
|
|
defined
(
XP_LINUX
)
#
if
defined
(
XP_MACOSX
)
&
&
defined
(
__aarch64__
)
const
uintptr_t
kPointerMask
=
(
uintptr_t
(
1
)
<
<
40
)
-
1
;
#
else
const
uintptr_t
kPointerMask
=
~
uintptr_t
(
0
)
;
#
endif
MOZ_ASAN_IGNORE
static
void
DoFramePointerStackWalk
(
MozWalkStackCallback
aCallback
const
void
*
aFirstFramePC
uint32_t
aMaxFrames
void
*
aClosure
void
*
*
aBp
void
*
aStackEnd
)
{
FrameSkipper
skipper
(
aFirstFramePC
)
;
uint32_t
numFrames
=
0
;
static
const
uintptr_t
kMaxStackSize
=
8
*
1024
*
1024
;
if
(
uintptr_t
(
aBp
)
<
uintptr_t
(
aStackEnd
)
-
std
:
:
min
(
kMaxStackSize
uintptr_t
(
aStackEnd
)
)
|
|
aBp
>
=
aStackEnd
|
|
(
uintptr_t
(
aBp
)
&
3
)
)
{
return
;
}
while
(
aBp
)
{
void
*
*
next
=
(
void
*
*
)
*
aBp
;
if
(
next
<
=
aBp
|
|
next
>
=
aStackEnd
|
|
(
uintptr_t
(
next
)
&
3
)
)
{
break
;
}
#
if
(
defined
(
__ppc__
)
&
&
defined
(
XP_MACOSX
)
)
|
|
defined
(
__powerpc64__
)
void
*
pc
=
*
(
aBp
+
2
)
;
aBp
+
=
3
;
#
else
void
*
pc
=
*
(
aBp
+
1
)
;
aBp
+
=
2
;
#
endif
pc
=
(
void
*
)
(
(
uintptr_t
)
pc
&
kPointerMask
)
;
if
(
!
skipper
.
ShouldSkipPC
(
pc
)
)
{
numFrames
+
+
;
(
*
aCallback
)
(
numFrames
pc
aBp
aClosure
)
;
if
(
aMaxFrames
!
=
0
&
&
numFrames
=
=
aMaxFrames
)
{
break
;
}
}
aBp
=
next
;
}
}
namespace
mozilla
{
MFBT_API
void
FramePointerStackWalk
(
MozWalkStackCallback
aCallback
uint32_t
aMaxFrames
void
*
aClosure
void
*
*
aBp
void
*
aStackEnd
)
{
DoFramePointerStackWalk
(
aCallback
nullptr
aMaxFrames
aClosure
aBp
aStackEnd
)
;
}
}
#
else
namespace
mozilla
{
MFBT_API
void
FramePointerStackWalk
(
MozWalkStackCallback
aCallback
uint32_t
aMaxFrames
void
*
aClosure
void
*
*
aBp
void
*
aStackEnd
)
{
}
}
#
endif
MFBT_API
int
MozFormatCodeAddressDetails
(
char
*
aBuffer
uint32_t
aBufferSize
uint32_t
aFrameNumber
void
*
aPC
const
MozCodeAddressDetails
*
aDetails
)
{
return
MozFormatCodeAddress
(
aBuffer
aBufferSize
aFrameNumber
aPC
aDetails
-
>
function
aDetails
-
>
library
aDetails
-
>
loffset
aDetails
-
>
filename
aDetails
-
>
lineno
)
;
}
MFBT_API
int
MozFormatCodeAddress
(
char
*
aBuffer
uint32_t
aBufferSize
uint32_t
aFrameNumber
const
void
*
aPC
const
char
*
aFunction
const
char
*
aLibrary
ptrdiff_t
aLOffset
const
char
*
aFileName
uint32_t
aLineNo
)
{
const
char
*
function
=
aFunction
&
&
aFunction
[
0
]
?
aFunction
:
"
?
?
?
"
;
if
(
aFileName
&
&
aFileName
[
0
]
)
{
return
SprintfBuf
(
aBuffer
aBufferSize
"
#
%
02u
:
%
s
(
%
s
:
%
u
)
"
aFrameNumber
function
aFileName
aLineNo
)
;
}
else
if
(
aLibrary
&
&
aLibrary
[
0
]
)
{
return
SprintfBuf
(
aBuffer
aBufferSize
"
#
%
02u
:
%
s
[
%
s
+
0x
%
"
PRIxPTR
"
]
"
aFrameNumber
function
aLibrary
static_cast
<
uintptr_t
>
(
aLOffset
)
)
;
}
else
{
return
SprintfBuf
(
aBuffer
aBufferSize
"
#
%
02u
:
?
?
?
(
?
?
?
:
?
?
?
"
"
)
"
aFrameNumber
)
;
}
}
static
void
EnsureWrite
(
FILE
*
aStream
const
char
*
aBuf
size_t
aLen
)
{
#
ifdef
XP_WIN
int
fd
=
_fileno
(
aStream
)
;
#
else
int
fd
=
fileno
(
aStream
)
;
#
endif
while
(
aLen
>
0
)
{
#
ifdef
XP_WIN
auto
written
=
_write
(
fd
aBuf
aLen
)
;
#
else
auto
written
=
write
(
fd
aBuf
aLen
)
;
#
endif
if
(
written
<
=
0
|
|
size_t
(
written
)
>
aLen
)
{
break
;
}
aBuf
+
=
written
;
aLen
-
=
written
;
}
}
template
<
int
N
>
static
int
PrintStackFrameBuf
(
char
(
&
aBuf
)
[
N
]
uint32_t
aFrameNumber
void
*
aPC
void
*
aSP
)
{
MozCodeAddressDetails
details
;
MozDescribeCodeAddress
(
aPC
&
details
)
;
int
len
=
MozFormatCodeAddressDetails
(
aBuf
N
-
1
aFrameNumber
aPC
&
details
)
;
len
=
std
:
:
min
(
len
N
-
2
)
;
aBuf
[
len
+
+
]
=
'
\
n
'
;
aBuf
[
len
]
=
'
\
0
'
;
return
len
;
}
static
void
PrintStackFrame
(
uint32_t
aFrameNumber
void
*
aPC
void
*
aSP
void
*
aClosure
)
{
FILE
*
stream
=
(
FILE
*
)
aClosure
;
char
buf
[
1025
]
;
int
len
=
PrintStackFrameBuf
(
buf
aFrameNumber
aPC
aSP
)
;
fflush
(
stream
)
;
EnsureWrite
(
stream
buf
len
)
;
}
static
bool
WalkTheStackEnabled
(
)
{
static
bool
result
=
[
]
{
char
*
value
=
getenv
(
"
MOZ_DISABLE_WALKTHESTACK
"
)
;
return
!
(
value
&
&
value
[
0
]
)
;
}
(
)
;
return
result
;
}
MFBT_API
void
MozWalkTheStack
(
FILE
*
aStream
const
void
*
aFirstFramePC
uint32_t
aMaxFrames
)
{
if
(
WalkTheStackEnabled
(
)
)
{
MozStackWalk
(
PrintStackFrame
aFirstFramePC
?
aFirstFramePC
:
CallerPC
(
)
aMaxFrames
aStream
)
;
}
}
static
void
WriteStackFrame
(
uint32_t
aFrameNumber
void
*
aPC
void
*
aSP
void
*
aClosure
)
{
auto
writer
=
(
void
(
*
)
(
const
char
*
)
)
aClosure
;
char
buf
[
1024
]
;
PrintStackFrameBuf
(
buf
aFrameNumber
aPC
aSP
)
;
writer
(
buf
)
;
}
MFBT_API
void
MozWalkTheStackWithWriter
(
void
(
*
aWriter
)
(
const
char
*
)
const
void
*
aFirstFramePC
uint32_t
aMaxFrames
)
{
if
(
WalkTheStackEnabled
(
)
)
{
MozStackWalk
(
WriteStackFrame
aFirstFramePC
?
aFirstFramePC
:
CallerPC
(
)
aMaxFrames
(
void
*
)
aWriter
)
;
}
}
