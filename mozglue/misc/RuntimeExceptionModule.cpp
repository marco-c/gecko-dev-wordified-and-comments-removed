#
include
"
RuntimeExceptionModule
.
h
"
#
include
<
cstdint
>
#
include
"
mozilla
/
ProcessType
.
h
"
#
if
defined
(
XP_WIN
)
#
include
<
windows
.
h
>
#
if
defined
(
__MINGW32__
)
|
|
defined
(
__MINGW64__
)
typedef
HANDLE
HREPORT
;
#
define
WerReportSubmit
(
a
b
c
d
)
\
WerReportSubmit
(
a
b
c
WER_SUBMIT_RESULT
*
pSubmitResult
)
#
define
WER_MAX_PREFERRED_MODULES_BUFFER
256
#
endif
#
include
<
werapi
.
h
>
#
if
defined
(
__MINGW32__
)
|
|
defined
(
__MINGW64__
)
#
undef
WerReportSubmit
#
endif
#
include
<
stdlib
.
h
>
#
include
"
mozilla
/
mozalloc_oom
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
using
mozilla
:
:
Unused
;
#
endif
namespace
CrashReporter
{
#
ifdef
XP_WIN
struct
InProcessWindowsErrorReportingData
{
uint32_t
mProcessType
;
size_t
*
mOOMAllocationSizePtr
;
}
;
static
InProcessWindowsErrorReportingData
gInProcessWerData
;
const
static
size_t
kModulePathLength
=
MAX_PATH
+
1
;
static
wchar_t
sModulePath
[
kModulePathLength
]
;
bool
GetRuntimeExceptionModulePath
(
wchar_t
*
aPath
const
size_t
aLength
)
{
const
wchar_t
*
kModuleName
=
L
"
mozwer
.
dll
"
;
DWORD
res
=
:
:
GetModuleFileNameW
(
nullptr
aPath
aLength
)
;
if
(
(
res
>
0
)
&
&
(
res
!
=
aLength
)
)
{
wchar_t
*
last_backslash
=
wcsrchr
(
aPath
L
'
\
\
'
)
;
if
(
last_backslash
)
{
*
(
last_backslash
+
1
)
=
L
'
\
0
'
;
if
(
wcscat_s
(
aPath
aLength
kModuleName
)
=
=
0
)
{
return
true
;
}
}
}
return
false
;
}
#
endif
void
RegisterRuntimeExceptionModule
(
)
{
#
ifdef
XP_WIN
#
if
defined
(
DEBUG
)
const
char
*
envvar
=
getenv
(
"
MOZ_CRASHREPORTER
"
)
;
if
(
!
envvar
|
|
!
*
envvar
)
{
return
;
}
#
else
const
char
*
envvar
=
getenv
(
"
MOZ_CRASHREPORTER_DISABLE
"
)
;
if
(
envvar
&
&
*
envvar
)
{
return
;
}
#
endif
if
(
*
sModulePath
)
{
return
;
}
if
(
!
GetRuntimeExceptionModulePath
(
sModulePath
kModulePathLength
)
)
{
return
;
}
gInProcessWerData
.
mProcessType
=
mozilla
:
:
GetGeckoProcessType
(
)
;
gInProcessWerData
.
mOOMAllocationSizePtr
=
&
gOOMAllocationSize
;
if
(
FAILED
(
:
:
WerRegisterRuntimeExceptionModule
(
sModulePath
&
gInProcessWerData
)
)
)
{
*
sModulePath
=
L
'
\
0
'
;
return
;
}
#
endif
}
void
UnregisterRuntimeExceptionModule
(
)
{
#
ifdef
XP_WIN
if
(
*
sModulePath
)
{
Unused
<
<
:
:
WerUnregisterRuntimeExceptionModule
(
sModulePath
&
gInProcessWerData
)
;
*
sModulePath
=
L
'
\
0
'
;
}
#
endif
}
}
