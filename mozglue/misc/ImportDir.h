#
include
"
mozilla
/
NativeNt
.
h
"
#
include
"
mozilla
/
WinHeaderOnlyUtils
.
h
"
namespace
mozilla
{
namespace
detail
{
inline
LauncherResult
<
nt
:
:
DataDirectoryEntry
>
GetImageDirectoryViaFileIo
(
const
nsAutoHandle
&
aImageFile
const
uint32_t
aOurImportDirectoryRva
)
{
OVERLAPPED
ov
=
{
}
;
ov
.
Offset
=
aOurImportDirectoryRva
;
DWORD
bytesRead
;
nt
:
:
DataDirectoryEntry
result
;
if
(
!
:
:
ReadFile
(
aImageFile
&
result
sizeof
(
result
)
&
bytesRead
&
ov
)
|
|
bytesRead
!
=
sizeof
(
result
)
)
{
return
LAUNCHER_ERROR_FROM_LAST
(
)
;
}
return
result
;
}
}
inline
LauncherVoidResult
RestoreImportDirectory
(
const
wchar_t
*
aFullImagePath
nt
:
:
CrossExecTransferManager
&
aTransferMgr
)
{
uint32_t
importDirEntryRva
;
PIMAGE_DATA_DIRECTORY
importDirEntry
=
aTransferMgr
.
LocalPEHeaders
(
)
.
GetImageDirectoryEntryPtr
(
IMAGE_DIRECTORY_ENTRY_IMPORT
&
importDirEntryRva
)
;
if
(
!
importDirEntry
)
{
return
LAUNCHER_ERROR_FROM_WIN32
(
ERROR_BAD_EXE_FORMAT
)
;
}
nsAutoHandle
file
(
:
:
CreateFileW
(
aFullImagePath
GENERIC_READ
FILE_SHARE_READ
nullptr
OPEN_EXISTING
FILE_ATTRIBUTE_NORMAL
nullptr
)
)
;
if
(
file
.
get
(
)
=
=
INVALID_HANDLE_VALUE
)
{
return
LAUNCHER_ERROR_FROM_LAST
(
)
;
}
LauncherResult
<
nt
:
:
DataDirectoryEntry
>
realImportDirectory
=
detail
:
:
GetImageDirectoryViaFileIo
(
file
importDirEntryRva
)
;
if
(
realImportDirectory
.
isErr
(
)
)
{
return
realImportDirectory
.
propagateErr
(
)
;
}
nt
:
:
DataDirectoryEntry
toWrite
=
realImportDirectory
.
unwrap
(
)
;
{
AutoVirtualProtect
prot
=
aTransferMgr
.
Protect
(
importDirEntry
sizeof
(
IMAGE_DATA_DIRECTORY
)
PAGE_READWRITE
)
;
if
(
!
prot
)
{
return
LAUNCHER_ERROR_FROM_MOZ_WINDOWS_ERROR
(
prot
.
GetError
(
)
)
;
}
LauncherVoidResult
writeResult
=
aTransferMgr
.
Transfer
(
importDirEntry
&
toWrite
sizeof
(
IMAGE_DATA_DIRECTORY
)
)
;
if
(
writeResult
.
isErr
(
)
)
{
return
writeResult
.
propagateErr
(
)
;
}
}
return
Ok
(
)
;
}
}
