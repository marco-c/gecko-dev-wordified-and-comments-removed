#
ifndef
mozilla_DbgMacro_h
#
define
mozilla_DbgMacro_h
#
include
"
mozilla
/
MacroForEach
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
<
stdio
.
h
>
#
include
<
sstream
>
template
<
typename
T
>
class
nsTSubstring
;
#
ifdef
ANDROID
#
include
<
android
/
log
.
h
>
#
endif
namespace
mozilla
{
namespace
detail
{
template
<
typename
T
typename
=
decltype
(
std
:
:
declval
<
std
:
:
ostream
&
>
(
)
<
<
std
:
:
declval
<
T
>
(
)
)
>
std
:
:
true_type
supports_os_test
(
const
T
&
)
;
std
:
:
false_type
supports_os_test
(
.
.
.
)
;
template
<
typename
T
>
using
supports_os
=
decltype
(
supports_os_test
(
std
:
:
declval
<
T
>
(
)
)
)
;
}
template
<
typename
T
>
auto
DebugValue
(
std
:
:
ostream
&
aOut
T
*
aValue
)
-
>
std
:
:
enable_if_t
<
mozilla
:
:
detail
:
:
supports_os
<
T
>
:
:
value
std
:
:
ostream
&
>
{
if
(
aValue
)
{
aOut
<
<
*
aValue
<
<
"
"
<
<
aValue
;
}
else
{
aOut
<
<
"
null
"
;
}
return
aOut
;
}
template
<
typename
T
>
auto
DebugValue
(
std
:
:
ostream
&
aOut
T
*
aValue
)
-
>
std
:
:
enable_if_t
<
!
mozilla
:
:
detail
:
:
supports_os
<
T
>
:
:
value
std
:
:
ostream
&
>
{
return
aOut
<
<
aValue
;
}
template
<
typename
T
>
auto
DebugValue
(
std
:
:
ostream
&
aOut
const
T
&
aValue
)
-
>
std
:
:
enable_if_t
<
std
:
:
is_base_of
<
nsTSubstring
<
char
>
T
>
:
:
value
|
|
std
:
:
is_base_of
<
nsTSubstring
<
char16_t
>
T
>
:
:
value
std
:
:
ostream
&
>
{
return
aOut
<
<
'
"
'
<
<
aValue
<
<
'
"
'
;
}
template
<
typename
T
>
auto
DebugValue
(
std
:
:
ostream
&
aOut
const
T
&
aValue
)
-
>
std
:
:
enable_if_t
<
!
std
:
:
is_base_of
<
nsTSubstring
<
char
>
T
>
:
:
value
&
&
!
std
:
:
is_base_of
<
nsTSubstring
<
char16_t
>
T
>
:
:
value
std
:
:
ostream
&
>
{
return
aOut
<
<
aValue
;
}
namespace
detail
{
template
<
typename
T
>
auto
&
&
MozDbg
(
const
char
*
aFile
int
aLine
const
char
*
aExpression
T
&
&
aValue
)
{
std
:
:
ostringstream
s
;
s
<
<
"
[
MozDbg
]
[
"
<
<
aFile
<
<
'
:
'
<
<
aLine
<
<
"
]
"
<
<
aExpression
<
<
"
=
"
;
mozilla
:
:
DebugValue
(
s
std
:
:
forward
<
T
>
(
aValue
)
)
;
s
<
<
'
\
n
'
;
#
ifdef
ANDROID
__android_log_print
(
ANDROID_LOG_INFO
"
Gecko
"
"
%
s
"
s
.
str
(
)
.
c_str
(
)
)
;
#
else
fputs
(
s
.
str
(
)
.
c_str
(
)
stderr
)
;
#
endif
return
std
:
:
forward
<
T
>
(
aValue
)
;
}
}
}
template
<
class
ElementType
size_t
Extent
>
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
aOut
const
mozilla
:
:
Span
<
ElementType
Extent
>
&
aSpan
)
{
aOut
<
<
'
[
'
;
if
(
!
aSpan
.
IsEmpty
(
)
)
{
aOut
<
<
aSpan
[
0
]
;
for
(
size_t
i
=
1
;
i
<
aSpan
.
Length
(
)
;
+
+
i
)
{
aOut
<
<
"
"
<
<
aSpan
[
i
]
;
}
}
return
aOut
<
<
'
]
'
;
}
template
<
typename
T
size_t
N
typename
=
std
:
:
enable_if_t
<
!
std
:
:
is_same
<
T
char
>
:
:
value
>
>
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
aOut
const
T
(
&
aArray
)
[
N
]
)
{
return
aOut
<
<
mozilla
:
:
MakeSpan
(
aArray
)
;
}
#
ifndef
MOZILLA_OFFICIAL
#
define
MOZ_DBG
(
.
.
.
)
\
mozilla
:
:
detail
:
:
MozDbg
(
__FILE__
__LINE__
#
__VA_ARGS__
__VA_ARGS__
)
#
endif
#
define
MOZ_DBG_FIELD
(
name_
)
<
<
#
name_
<
<
"
=
"
<
<
aValue
.
name_
#
define
MOZ_DEFINE_DBG
(
type_
.
.
.
)
\
friend
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
aOut
const
type_
&
aValue
)
{
\
return
aOut
<
<
#
type_
\
<
<
(
MOZ_ARG_COUNT
(
__VA_ARGS__
)
=
=
0
?
"
"
:
"
{
"
)
\
MOZ_FOR_EACH_SEPARATED
(
MOZ_DBG_FIELD
(
<
<
"
"
)
(
)
\
(
__VA_ARGS__
)
)
\
<
<
(
MOZ_ARG_COUNT
(
__VA_ARGS__
)
=
=
0
?
"
"
:
"
}
"
)
;
\
}
#
endif
