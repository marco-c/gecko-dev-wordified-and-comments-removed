#
ifndef
mozilla_TypeTraits_h
#
define
mozilla_TypeTraits_h
#
include
"
mozilla
/
Types
.
h
"
namespace
mozilla
{
template
<
typename
>
struct
RemoveCV
;
template
<
typename
>
struct
AddRvalueReference
;
template
<
typename
T
>
typename
AddRvalueReference
<
T
>
:
:
Type
DeclVal
(
)
;
template
<
typename
T
T
Value
>
struct
IntegralConstant
{
static
constexpr
T
value
=
Value
;
typedef
T
ValueType
;
typedef
IntegralConstant
<
T
Value
>
Type
;
}
;
typedef
IntegralConstant
<
bool
true
>
TrueType
;
typedef
IntegralConstant
<
bool
false
>
FalseType
;
namespace
detail
{
template
<
typename
T
>
struct
IsVoidHelper
:
FalseType
{
}
;
template
<
>
struct
IsVoidHelper
<
void
>
:
TrueType
{
}
;
}
template
<
typename
T
>
struct
IsVoid
:
detail
:
:
IsVoidHelper
<
typename
RemoveCV
<
T
>
:
:
Type
>
{
}
;
template
<
typename
T
>
struct
IsPod
:
public
FalseType
{
}
;
template
<
>
struct
IsPod
<
char
>
:
TrueType
{
}
;
template
<
>
struct
IsPod
<
signed
char
>
:
TrueType
{
}
;
template
<
>
struct
IsPod
<
unsigned
char
>
:
TrueType
{
}
;
template
<
>
struct
IsPod
<
short
>
:
TrueType
{
}
;
template
<
>
struct
IsPod
<
unsigned
short
>
:
TrueType
{
}
;
template
<
>
struct
IsPod
<
int
>
:
TrueType
{
}
;
template
<
>
struct
IsPod
<
unsigned
int
>
:
TrueType
{
}
;
template
<
>
struct
IsPod
<
long
>
:
TrueType
{
}
;
template
<
>
struct
IsPod
<
unsigned
long
>
:
TrueType
{
}
;
template
<
>
struct
IsPod
<
long
long
>
:
TrueType
{
}
;
template
<
>
struct
IsPod
<
unsigned
long
long
>
:
TrueType
{
}
;
template
<
>
struct
IsPod
<
bool
>
:
TrueType
{
}
;
template
<
>
struct
IsPod
<
float
>
:
TrueType
{
}
;
template
<
>
struct
IsPod
<
double
>
:
TrueType
{
}
;
template
<
>
struct
IsPod
<
wchar_t
>
:
TrueType
{
}
;
template
<
>
struct
IsPod
<
char16_t
>
:
TrueType
{
}
;
template
<
typename
T
>
struct
IsPod
<
T
*
>
:
TrueType
{
}
;
namespace
detail
{
struct
DoIsDestructibleImpl
{
template
<
typename
T
typename
=
decltype
(
DeclVal
<
T
&
>
(
)
.
~
T
(
)
)
>
static
TrueType
test
(
int
)
;
template
<
typename
T
>
static
FalseType
test
(
.
.
.
)
;
}
;
template
<
typename
T
>
struct
IsDestructibleImpl
:
public
DoIsDestructibleImpl
{
typedef
decltype
(
test
<
T
>
(
0
)
)
Type
;
}
;
}
template
<
typename
T
>
struct
IsDestructible
:
public
detail
:
:
IsDestructibleImpl
<
T
>
:
:
Type
{
}
;
template
<
typename
T
typename
U
>
struct
IsSame
:
FalseType
{
}
;
template
<
typename
T
>
struct
IsSame
<
T
T
>
:
TrueType
{
}
;
template
<
typename
T
>
struct
RemoveConst
{
typedef
T
Type
;
}
;
template
<
typename
T
>
struct
RemoveConst
<
const
T
>
{
typedef
T
Type
;
}
;
template
<
typename
T
>
struct
RemoveVolatile
{
typedef
T
Type
;
}
;
template
<
typename
T
>
struct
RemoveVolatile
<
volatile
T
>
{
typedef
T
Type
;
}
;
template
<
typename
T
>
struct
RemoveCV
{
typedef
typename
RemoveConst
<
typename
RemoveVolatile
<
T
>
:
:
Type
>
:
:
Type
Type
;
}
;
namespace
detail
{
enum
Voidness
{
TIsVoid
TIsNotVoid
}
;
template
<
typename
T
Voidness
V
=
IsVoid
<
T
>
:
:
value
?
TIsVoid
:
TIsNotVoid
>
struct
AddRvalueReferenceHelper
;
template
<
typename
T
>
struct
AddRvalueReferenceHelper
<
T
TIsVoid
>
{
typedef
void
Type
;
}
;
template
<
typename
T
>
struct
AddRvalueReferenceHelper
<
T
TIsNotVoid
>
{
typedef
T
&
&
Type
;
}
;
}
template
<
typename
T
>
struct
AddRvalueReference
:
detail
:
:
AddRvalueReferenceHelper
<
T
>
{
}
;
}
#
endif
