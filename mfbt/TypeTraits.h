#
ifndef
mozilla_TypeTraits_h
#
define
mozilla_TypeTraits_h
#
include
"
mozilla
/
Types
.
h
"
namespace
mozilla
{
template
<
typename
>
struct
RemoveCV
;
template
<
typename
>
struct
AddRvalueReference
;
template
<
typename
T
>
typename
AddRvalueReference
<
T
>
:
:
Type
DeclVal
(
)
;
template
<
typename
T
T
Value
>
struct
IntegralConstant
{
static
constexpr
T
value
=
Value
;
typedef
T
ValueType
;
typedef
IntegralConstant
<
T
Value
>
Type
;
}
;
typedef
IntegralConstant
<
bool
true
>
TrueType
;
typedef
IntegralConstant
<
bool
false
>
FalseType
;
namespace
detail
{
template
<
typename
T
>
struct
IsVoidHelper
:
FalseType
{
}
;
template
<
>
struct
IsVoidHelper
<
void
>
:
TrueType
{
}
;
}
template
<
typename
T
>
struct
IsVoid
:
detail
:
:
IsVoidHelper
<
typename
RemoveCV
<
T
>
:
:
Type
>
{
}
;
namespace
detail
{
template
<
typename
T
>
struct
IsIntegralHelper
:
FalseType
{
}
;
template
<
>
struct
IsIntegralHelper
<
char
>
:
TrueType
{
}
;
template
<
>
struct
IsIntegralHelper
<
signed
char
>
:
TrueType
{
}
;
template
<
>
struct
IsIntegralHelper
<
unsigned
char
>
:
TrueType
{
}
;
template
<
>
struct
IsIntegralHelper
<
short
>
:
TrueType
{
}
;
template
<
>
struct
IsIntegralHelper
<
unsigned
short
>
:
TrueType
{
}
;
template
<
>
struct
IsIntegralHelper
<
int
>
:
TrueType
{
}
;
template
<
>
struct
IsIntegralHelper
<
unsigned
int
>
:
TrueType
{
}
;
template
<
>
struct
IsIntegralHelper
<
long
>
:
TrueType
{
}
;
template
<
>
struct
IsIntegralHelper
<
unsigned
long
>
:
TrueType
{
}
;
template
<
>
struct
IsIntegralHelper
<
long
long
>
:
TrueType
{
}
;
template
<
>
struct
IsIntegralHelper
<
unsigned
long
long
>
:
TrueType
{
}
;
template
<
>
struct
IsIntegralHelper
<
bool
>
:
TrueType
{
}
;
template
<
>
struct
IsIntegralHelper
<
wchar_t
>
:
TrueType
{
}
;
template
<
>
struct
IsIntegralHelper
<
char16_t
>
:
TrueType
{
}
;
template
<
>
struct
IsIntegralHelper
<
char32_t
>
:
TrueType
{
}
;
}
template
<
typename
T
>
struct
IsIntegral
:
detail
:
:
IsIntegralHelper
<
typename
RemoveCV
<
T
>
:
:
Type
>
{
}
;
template
<
typename
T
typename
U
>
struct
IsSame
;
namespace
detail
{
template
<
typename
T
>
struct
IsArrayHelper
:
FalseType
{
}
;
template
<
typename
T
decltype
(
sizeof
(
1
)
)
N
>
struct
IsArrayHelper
<
T
[
N
]
>
:
TrueType
{
}
;
template
<
typename
T
>
struct
IsArrayHelper
<
T
[
]
>
:
TrueType
{
}
;
}
template
<
typename
T
>
struct
IsArray
:
detail
:
:
IsArrayHelper
<
typename
RemoveCV
<
T
>
:
:
Type
>
{
}
;
namespace
detail
{
template
<
typename
T
>
struct
IsFunPtr
;
template
<
typename
>
struct
IsFunPtr
:
public
FalseType
{
}
;
template
<
typename
Result
typename
.
.
.
ArgTypes
>
struct
IsFunPtr
<
Result
(
*
)
(
ArgTypes
.
.
.
)
>
:
public
TrueType
{
}
;
}
;
template
<
typename
T
>
struct
IsFunction
:
public
detail
:
:
IsFunPtr
<
typename
RemoveCV
<
T
>
:
:
Type
*
>
{
}
;
template
<
typename
T
>
struct
IsVolatile
:
FalseType
{
}
;
template
<
typename
T
>
struct
IsVolatile
<
volatile
T
>
:
TrueType
{
}
;
template
<
typename
T
>
struct
IsPod
:
public
FalseType
{
}
;
template
<
>
struct
IsPod
<
char
>
:
TrueType
{
}
;
template
<
>
struct
IsPod
<
signed
char
>
:
TrueType
{
}
;
template
<
>
struct
IsPod
<
unsigned
char
>
:
TrueType
{
}
;
template
<
>
struct
IsPod
<
short
>
:
TrueType
{
}
;
template
<
>
struct
IsPod
<
unsigned
short
>
:
TrueType
{
}
;
template
<
>
struct
IsPod
<
int
>
:
TrueType
{
}
;
template
<
>
struct
IsPod
<
unsigned
int
>
:
TrueType
{
}
;
template
<
>
struct
IsPod
<
long
>
:
TrueType
{
}
;
template
<
>
struct
IsPod
<
unsigned
long
>
:
TrueType
{
}
;
template
<
>
struct
IsPod
<
long
long
>
:
TrueType
{
}
;
template
<
>
struct
IsPod
<
unsigned
long
long
>
:
TrueType
{
}
;
template
<
>
struct
IsPod
<
bool
>
:
TrueType
{
}
;
template
<
>
struct
IsPod
<
float
>
:
TrueType
{
}
;
template
<
>
struct
IsPod
<
double
>
:
TrueType
{
}
;
template
<
>
struct
IsPod
<
wchar_t
>
:
TrueType
{
}
;
template
<
>
struct
IsPod
<
char16_t
>
:
TrueType
{
}
;
template
<
typename
T
>
struct
IsPod
<
T
*
>
:
TrueType
{
}
;
namespace
detail
{
struct
DoIsDestructibleImpl
{
template
<
typename
T
typename
=
decltype
(
DeclVal
<
T
&
>
(
)
.
~
T
(
)
)
>
static
TrueType
test
(
int
)
;
template
<
typename
T
>
static
FalseType
test
(
.
.
.
)
;
}
;
template
<
typename
T
>
struct
IsDestructibleImpl
:
public
DoIsDestructibleImpl
{
typedef
decltype
(
test
<
T
>
(
0
)
)
Type
;
}
;
}
template
<
typename
T
>
struct
IsDestructible
:
public
detail
:
:
IsDestructibleImpl
<
T
>
:
:
Type
{
}
;
template
<
typename
T
typename
U
>
struct
IsSame
:
FalseType
{
}
;
template
<
typename
T
>
struct
IsSame
<
T
T
>
:
TrueType
{
}
;
namespace
detail
{
template
<
typename
From
typename
To
>
struct
ConvertibleTester
{
private
:
template
<
typename
To1
>
static
char
test_helper
(
To1
)
;
template
<
typename
From1
typename
To1
>
static
decltype
(
test_helper
<
To1
>
(
DeclVal
<
From1
>
(
)
)
)
test
(
int
)
;
template
<
typename
From1
typename
To1
>
static
int
test
(
.
.
.
)
;
public
:
static
const
bool
value
=
sizeof
(
test
<
From
To
>
(
0
)
)
=
=
sizeof
(
char
)
;
}
;
}
template
<
typename
From
typename
To
>
struct
IsConvertible
:
IntegralConstant
<
bool
detail
:
:
ConvertibleTester
<
From
To
>
:
:
value
>
{
}
;
template
<
typename
B
>
struct
IsConvertible
<
void
B
>
:
IntegralConstant
<
bool
IsVoid
<
B
>
:
:
value
>
{
}
;
template
<
typename
A
>
struct
IsConvertible
<
A
void
>
:
IntegralConstant
<
bool
IsVoid
<
A
>
:
:
value
>
{
}
;
template
<
>
struct
IsConvertible
<
void
void
>
:
TrueType
{
}
;
template
<
typename
T
>
struct
RemoveConst
{
typedef
T
Type
;
}
;
template
<
typename
T
>
struct
RemoveConst
<
const
T
>
{
typedef
T
Type
;
}
;
template
<
typename
T
>
struct
RemoveVolatile
{
typedef
T
Type
;
}
;
template
<
typename
T
>
struct
RemoveVolatile
<
volatile
T
>
{
typedef
T
Type
;
}
;
template
<
typename
T
>
struct
RemoveCV
{
typedef
typename
RemoveConst
<
typename
RemoveVolatile
<
T
>
:
:
Type
>
:
:
Type
Type
;
}
;
template
<
typename
T
>
struct
RemoveReference
{
typedef
T
Type
;
}
;
template
<
typename
T
>
struct
RemoveReference
<
T
&
>
{
typedef
T
Type
;
}
;
template
<
typename
T
>
struct
RemoveReference
<
T
&
&
>
{
typedef
T
Type
;
}
;
namespace
detail
{
enum
Voidness
{
TIsVoid
TIsNotVoid
}
;
template
<
typename
T
Voidness
V
=
IsVoid
<
T
>
:
:
value
?
TIsVoid
:
TIsNotVoid
>
struct
AddRvalueReferenceHelper
;
template
<
typename
T
>
struct
AddRvalueReferenceHelper
<
T
TIsVoid
>
{
typedef
void
Type
;
}
;
template
<
typename
T
>
struct
AddRvalueReferenceHelper
<
T
TIsNotVoid
>
{
typedef
T
&
&
Type
;
}
;
}
template
<
typename
T
>
struct
AddRvalueReference
:
detail
:
:
AddRvalueReferenceHelper
<
T
>
{
}
;
template
<
typename
T
>
struct
RemoveExtent
{
typedef
T
Type
;
}
;
template
<
typename
T
>
struct
RemoveExtent
<
T
[
]
>
{
typedef
T
Type
;
}
;
template
<
typename
T
decltype
(
sizeof
(
1
)
)
N
>
struct
RemoveExtent
<
T
[
N
]
>
{
typedef
T
Type
;
}
;
namespace
detail
{
template
<
typename
T
typename
CVRemoved
>
struct
RemovePointerHelper
{
typedef
T
Type
;
}
;
template
<
typename
T
typename
Pointee
>
struct
RemovePointerHelper
<
T
Pointee
*
>
{
typedef
Pointee
Type
;
}
;
}
template
<
typename
T
>
struct
RemovePointer
:
detail
:
:
RemovePointerHelper
<
T
typename
RemoveCV
<
T
>
:
:
Type
>
{
}
;
template
<
typename
T
>
struct
AddPointer
{
typedef
typename
RemoveReference
<
T
>
:
:
Type
*
Type
;
}
;
template
<
bool
B
typename
T
=
void
>
struct
EnableIf
{
}
;
template
<
typename
T
>
struct
EnableIf
<
true
T
>
{
typedef
T
Type
;
}
;
template
<
bool
Condition
typename
A
typename
B
>
struct
Conditional
{
typedef
A
Type
;
}
;
template
<
class
A
class
B
>
struct
Conditional
<
false
A
B
>
{
typedef
B
Type
;
}
;
namespace
detail
{
template
<
typename
U
bool
IsArray
=
IsArray
<
U
>
:
:
value
bool
IsFunction
=
IsFunction
<
U
>
:
:
value
>
struct
DecaySelector
;
template
<
typename
U
>
struct
DecaySelector
<
U
false
false
>
{
typedef
typename
RemoveCV
<
U
>
:
:
Type
Type
;
}
;
template
<
typename
U
>
struct
DecaySelector
<
U
true
false
>
{
typedef
typename
RemoveExtent
<
U
>
:
:
Type
*
Type
;
}
;
template
<
typename
U
>
struct
DecaySelector
<
U
false
true
>
{
typedef
typename
AddPointer
<
U
>
:
:
Type
Type
;
}
;
}
;
template
<
typename
T
>
class
Decay
:
public
detail
:
:
DecaySelector
<
typename
RemoveReference
<
T
>
:
:
Type
>
{
}
;
}
#
endif
