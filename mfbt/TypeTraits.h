#
ifndef
mozilla_TypeTraits_h
#
define
mozilla_TypeTraits_h
#
include
"
mozilla
/
Types
.
h
"
#
include
<
type_traits
>
#
include
<
utility
>
namespace
mozilla
{
template
<
typename
T
>
struct
IsPod
:
public
std
:
:
false_type
{
}
;
template
<
>
struct
IsPod
<
char
>
:
std
:
:
true_type
{
}
;
template
<
>
struct
IsPod
<
signed
char
>
:
std
:
:
true_type
{
}
;
template
<
>
struct
IsPod
<
unsigned
char
>
:
std
:
:
true_type
{
}
;
template
<
>
struct
IsPod
<
short
>
:
std
:
:
true_type
{
}
;
template
<
>
struct
IsPod
<
unsigned
short
>
:
std
:
:
true_type
{
}
;
template
<
>
struct
IsPod
<
int
>
:
std
:
:
true_type
{
}
;
template
<
>
struct
IsPod
<
unsigned
int
>
:
std
:
:
true_type
{
}
;
template
<
>
struct
IsPod
<
long
>
:
std
:
:
true_type
{
}
;
template
<
>
struct
IsPod
<
unsigned
long
>
:
std
:
:
true_type
{
}
;
template
<
>
struct
IsPod
<
long
long
>
:
std
:
:
true_type
{
}
;
template
<
>
struct
IsPod
<
unsigned
long
long
>
:
std
:
:
true_type
{
}
;
template
<
>
struct
IsPod
<
bool
>
:
std
:
:
true_type
{
}
;
template
<
>
struct
IsPod
<
float
>
:
std
:
:
true_type
{
}
;
template
<
>
struct
IsPod
<
double
>
:
std
:
:
true_type
{
}
;
template
<
>
struct
IsPod
<
wchar_t
>
:
std
:
:
true_type
{
}
;
template
<
>
struct
IsPod
<
char16_t
>
:
std
:
:
true_type
{
}
;
template
<
typename
T
>
struct
IsPod
<
T
*
>
:
std
:
:
true_type
{
}
;
namespace
detail
{
struct
DoIsDestructibleImpl
{
template
<
typename
T
typename
=
decltype
(
std
:
:
declval
<
T
&
>
(
)
.
~
T
(
)
)
>
static
std
:
:
true_type
test
(
int
)
;
template
<
typename
T
>
static
std
:
:
false_type
test
(
.
.
.
)
;
}
;
template
<
typename
T
>
struct
IsDestructibleImpl
:
public
DoIsDestructibleImpl
{
typedef
decltype
(
test
<
T
>
(
0
)
)
Type
;
}
;
}
template
<
typename
T
>
struct
IsDestructible
:
public
detail
:
:
IsDestructibleImpl
<
T
>
:
:
Type
{
}
;
}
#
endif
