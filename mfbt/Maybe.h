#
ifndef
mozilla_Maybe_h
#
define
mozilla_Maybe_h
#
include
<
new
>
#
include
<
ostream
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
mozilla
/
Alignment
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
MemoryChecking
.
h
"
#
include
"
mozilla
/
OperatorNewExtensions
.
h
"
#
include
"
mozilla
/
Poison
.
h
"
#
include
"
mozilla
/
TypeTraits
.
h
"
class
nsCycleCollectionTraversalCallback
;
template
<
typename
T
>
inline
void
CycleCollectionNoteChild
(
nsCycleCollectionTraversalCallback
&
aCallback
T
*
aChild
const
char
*
aName
uint32_t
aFlags
)
;
namespace
mozilla
{
struct
Nothing
{
}
;
inline
constexpr
bool
operator
=
=
(
const
Nothing
&
const
Nothing
&
)
{
return
true
;
}
template
<
class
T
>
class
Maybe
;
namespace
detail
{
template
<
size_t
offset
>
inline
void
WritePoisonAtOffset
(
void
*
p
const
uintptr_t
poisonValue
)
{
memcpy
(
static_cast
<
char
*
>
(
p
)
+
offset
*
sizeof
(
poisonValue
)
&
poisonValue
sizeof
(
poisonValue
)
)
;
}
template
<
size_t
Offset
size_t
NOffsets
>
struct
InlinePoisoner
{
static
void
poison
(
void
*
p
const
uintptr_t
poisonValue
)
{
WritePoisonAtOffset
<
Offset
>
(
p
poisonValue
)
;
InlinePoisoner
<
Offset
+
1
NOffsets
>
:
:
poison
(
p
poisonValue
)
;
}
}
;
template
<
size_t
N
>
struct
InlinePoisoner
<
N
N
>
{
static
void
poison
(
void
*
const
uintptr_t
)
{
}
}
;
template
<
size_t
ObjectSize
>
struct
OutOfLinePoisoner
{
static
MOZ_NEVER_INLINE
void
poison
(
void
*
p
const
uintptr_t
)
{
mozWritePoison
(
p
ObjectSize
)
;
}
}
;
template
<
typename
T
>
inline
void
PoisonObject
(
T
*
p
)
{
const
uintptr_t
POISON
=
mozPoisonValue
(
)
;
Conditional
<
(
sizeof
(
T
)
<
=
8
*
sizeof
(
POISON
)
)
InlinePoisoner
<
0
sizeof
(
T
)
/
sizeof
(
POISON
)
>
OutOfLinePoisoner
<
sizeof
(
T
)
>
>
:
:
Type
:
:
poison
(
p
POISON
)
;
}
template
<
typename
T
>
struct
MaybePoisoner
{
static
const
size_t
N
=
sizeof
(
T
)
;
static
void
poison
(
void
*
aPtr
)
{
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
if
(
N
>
=
sizeof
(
uintptr_t
)
)
{
PoisonObject
(
static_cast
<
typename
RemoveCV
<
T
>
:
:
Type
*
>
(
aPtr
)
)
;
}
#
endif
MOZ_MAKE_MEM_UNDEFINED
(
aPtr
N
)
;
}
}
;
template
<
typename
T
bool
Copyable
=
std
:
:
is_copy_constructible_v
<
T
>
bool
Movable
=
std
:
:
is_move_constructible_v
<
T
>
>
class
Maybe_CopyMove_Enabler
;
#
define
MOZ_MAYBE_COPY_OPS
(
)
\
Maybe_CopyMove_Enabler
(
const
Maybe_CopyMove_Enabler
&
aOther
)
{
\
downcast
(
*
this
)
.
mIsSome
=
false
;
\
if
(
downcast
(
aOther
)
.
mIsSome
)
{
\
downcast
(
*
this
)
.
emplace
(
*
downcast
(
aOther
)
)
;
\
}
\
}
\
\
Maybe_CopyMove_Enabler
&
operator
=
(
const
Maybe_CopyMove_Enabler
&
aOther
)
{
\
return
downcast
(
*
this
)
.
template
operator
=
<
T
>
(
downcast
(
aOther
)
)
;
\
}
#
define
MOZ_MAYBE_MOVE_OPS
(
)
\
Maybe_CopyMove_Enabler
(
Maybe_CopyMove_Enabler
&
&
aOther
)
{
\
downcast
(
*
this
)
.
mIsSome
=
false
;
\
\
if
(
downcast
(
aOther
)
.
mIsSome
)
{
\
downcast
(
*
this
)
.
emplace
(
std
:
:
move
(
*
downcast
(
aOther
)
)
)
;
\
downcast
(
aOther
)
.
reset
(
)
;
\
}
\
}
\
\
Maybe_CopyMove_Enabler
&
operator
=
(
Maybe_CopyMove_Enabler
&
&
aOther
)
{
\
return
downcast
(
*
this
)
.
template
operator
=
<
T
>
(
std
:
:
move
(
downcast
(
aOther
)
)
)
;
\
}
#
define
MOZ_MAYBE_DOWNCAST
(
)
\
static
Maybe
<
T
>
&
downcast
(
Maybe_CopyMove_Enabler
&
aObj
)
{
\
return
static_cast
<
Maybe
<
T
>
&
>
(
aObj
)
;
\
}
\
static
const
Maybe
<
T
>
&
downcast
(
const
Maybe_CopyMove_Enabler
&
aObj
)
{
\
return
static_cast
<
const
Maybe
<
T
>
&
>
(
aObj
)
;
\
}
template
<
typename
T
>
class
Maybe_CopyMove_Enabler
<
T
true
true
>
{
public
:
Maybe_CopyMove_Enabler
(
)
=
default
;
MOZ_MAYBE_COPY_OPS
(
)
MOZ_MAYBE_MOVE_OPS
(
)
private
:
MOZ_MAYBE_DOWNCAST
(
)
}
;
template
<
typename
T
>
class
Maybe_CopyMove_Enabler
<
T
false
true
>
{
public
:
Maybe_CopyMove_Enabler
(
)
=
default
;
MOZ_MAYBE_MOVE_OPS
(
)
private
:
MOZ_MAYBE_DOWNCAST
(
)
}
;
template
<
typename
T
>
class
Maybe_CopyMove_Enabler
<
T
true
false
>
{
public
:
Maybe_CopyMove_Enabler
(
)
=
default
;
MOZ_MAYBE_COPY_OPS
(
)
private
:
MOZ_MAYBE_DOWNCAST
(
)
}
;
template
<
typename
T
>
class
Maybe_CopyMove_Enabler
<
T
false
false
>
{
public
:
Maybe_CopyMove_Enabler
(
)
=
default
;
Maybe_CopyMove_Enabler
(
const
Maybe_CopyMove_Enabler
&
)
=
delete
;
Maybe_CopyMove_Enabler
&
operator
=
(
const
Maybe_CopyMove_Enabler
&
)
=
delete
;
Maybe_CopyMove_Enabler
(
Maybe_CopyMove_Enabler
&
&
)
=
delete
;
Maybe_CopyMove_Enabler
&
operator
=
(
Maybe_CopyMove_Enabler
&
&
)
=
delete
;
}
;
#
undef
MOZ_MAYBE_COPY_OPS
#
undef
MOZ_MAYBE_MOVE_OPS
#
undef
MOZ_MAYBE_DOWNCAST
}
template
<
class
T
>
class
MOZ_INHERIT_TYPE_ANNOTATIONS_FROM_TEMPLATE_ARGS
Maybe
:
public
detail
:
:
Maybe_CopyMove_Enabler
<
T
>
{
template
<
typename
bool
bool
>
friend
class
detail
:
:
Maybe_CopyMove_Enabler
;
using
NonConstT
=
typename
RemoveConst
<
T
>
:
:
Type
;
union
Union
{
Union
(
)
{
}
~
Union
(
)
{
}
Union
(
const
Union
&
)
{
}
Union
&
operator
=
(
const
Union
&
)
{
return
*
this
;
}
Union
(
Union
&
&
)
{
}
Union
&
operator
=
(
Union
&
&
)
{
return
*
this
;
}
NonConstT
val
;
}
mStorage
;
char
mIsSome
;
void
poisonData
(
)
{
detail
:
:
MaybePoisoner
<
T
>
:
:
poison
(
&
mStorage
.
val
)
;
}
public
:
using
ValueType
=
T
;
MOZ_ALLOW_TEMPORARY
Maybe
(
)
:
mIsSome
(
false
)
{
}
~
Maybe
(
)
{
reset
(
)
;
}
MOZ_ALLOW_TEMPORARY
MOZ_IMPLICIT
Maybe
(
Nothing
)
:
mIsSome
(
false
)
{
}
template
<
typename
U
typename
=
std
:
:
enable_if_t
<
std
:
:
is_constructible_v
<
T
const
U
&
>
>
>
MOZ_IMPLICIT
Maybe
(
const
Maybe
<
U
>
&
aOther
)
:
mIsSome
(
false
)
{
if
(
aOther
.
isSome
(
)
)
{
emplace
(
*
aOther
)
;
}
}
template
<
typename
U
typename
=
std
:
:
enable_if_t
<
std
:
:
is_constructible_v
<
T
U
&
&
>
>
>
MOZ_IMPLICIT
Maybe
(
Maybe
<
U
>
&
&
aOther
)
:
mIsSome
(
false
)
{
if
(
aOther
.
isSome
(
)
)
{
emplace
(
std
:
:
move
(
*
aOther
)
)
;
aOther
.
reset
(
)
;
}
}
template
<
typename
U
typename
=
std
:
:
enable_if_t
<
std
:
:
is_constructible_v
<
T
const
U
&
>
>
>
Maybe
&
operator
=
(
const
Maybe
<
U
>
&
aOther
)
{
if
(
aOther
.
isSome
(
)
)
{
if
(
mIsSome
)
{
ref
(
)
=
aOther
.
ref
(
)
;
}
else
{
emplace
(
*
aOther
)
;
}
}
else
{
reset
(
)
;
}
return
*
this
;
}
template
<
typename
U
typename
=
std
:
:
enable_if_t
<
std
:
:
is_constructible_v
<
T
U
&
&
>
>
>
Maybe
&
operator
=
(
Maybe
<
U
>
&
&
aOther
)
{
if
(
aOther
.
isSome
(
)
)
{
if
(
mIsSome
)
{
ref
(
)
=
std
:
:
move
(
aOther
.
ref
(
)
)
;
}
else
{
emplace
(
std
:
:
move
(
*
aOther
)
)
;
}
aOther
.
reset
(
)
;
}
else
{
reset
(
)
;
}
return
*
this
;
}
Maybe
&
operator
=
(
Nothing
)
{
reset
(
)
;
return
*
this
;
}
explicit
operator
bool
(
)
const
{
return
isSome
(
)
;
}
bool
isSome
(
)
const
{
return
mIsSome
;
}
bool
isNothing
(
)
const
{
return
!
mIsSome
;
}
T
value
(
)
const
;
template
<
typename
V
>
T
valueOr
(
V
&
&
aDefault
)
const
{
if
(
isSome
(
)
)
{
return
ref
(
)
;
}
return
std
:
:
forward
<
V
>
(
aDefault
)
;
}
template
<
typename
F
>
T
valueOrFrom
(
F
&
&
aFunc
)
const
{
if
(
isSome
(
)
)
{
return
ref
(
)
;
}
return
aFunc
(
)
;
}
T
*
ptr
(
)
;
const
T
*
ptr
(
)
const
;
T
*
ptrOr
(
T
*
aDefault
)
{
if
(
isSome
(
)
)
{
return
ptr
(
)
;
}
return
aDefault
;
}
const
T
*
ptrOr
(
const
T
*
aDefault
)
const
{
if
(
isSome
(
)
)
{
return
ptr
(
)
;
}
return
aDefault
;
}
template
<
typename
F
>
T
*
ptrOrFrom
(
F
&
&
aFunc
)
{
if
(
isSome
(
)
)
{
return
ptr
(
)
;
}
return
aFunc
(
)
;
}
template
<
typename
F
>
const
T
*
ptrOrFrom
(
F
&
&
aFunc
)
const
{
if
(
isSome
(
)
)
{
return
ptr
(
)
;
}
return
aFunc
(
)
;
}
T
*
operator
-
>
(
)
;
const
T
*
operator
-
>
(
)
const
;
T
&
ref
(
)
;
const
T
&
ref
(
)
const
;
T
&
refOr
(
T
&
aDefault
)
{
if
(
isSome
(
)
)
{
return
ref
(
)
;
}
return
aDefault
;
}
const
T
&
refOr
(
const
T
&
aDefault
)
const
{
if
(
isSome
(
)
)
{
return
ref
(
)
;
}
return
aDefault
;
}
template
<
typename
F
>
T
&
refOrFrom
(
F
&
&
aFunc
)
{
if
(
isSome
(
)
)
{
return
ref
(
)
;
}
return
aFunc
(
)
;
}
template
<
typename
F
>
const
T
&
refOrFrom
(
F
&
&
aFunc
)
const
{
if
(
isSome
(
)
)
{
return
ref
(
)
;
}
return
aFunc
(
)
;
}
T
&
operator
*
(
)
;
const
T
&
operator
*
(
)
const
;
template
<
typename
Func
>
Maybe
&
apply
(
Func
&
&
aFunc
)
{
if
(
isSome
(
)
)
{
std
:
:
forward
<
Func
>
(
aFunc
)
(
ref
(
)
)
;
}
return
*
this
;
}
template
<
typename
Func
>
const
Maybe
&
apply
(
Func
&
&
aFunc
)
const
{
if
(
isSome
(
)
)
{
std
:
:
forward
<
Func
>
(
aFunc
)
(
ref
(
)
)
;
}
return
*
this
;
}
template
<
typename
Func
>
auto
map
(
Func
&
&
aFunc
)
{
Maybe
<
decltype
(
std
:
:
forward
<
Func
>
(
aFunc
)
(
ref
(
)
)
)
>
val
;
if
(
isSome
(
)
)
{
val
.
emplace
(
std
:
:
forward
<
Func
>
(
aFunc
)
(
ref
(
)
)
)
;
}
return
val
;
}
template
<
typename
Func
>
auto
map
(
Func
&
&
aFunc
)
const
{
Maybe
<
decltype
(
std
:
:
forward
<
Func
>
(
aFunc
)
(
ref
(
)
)
)
>
val
;
if
(
isSome
(
)
)
{
val
.
emplace
(
std
:
:
forward
<
Func
>
(
aFunc
)
(
ref
(
)
)
)
;
}
return
val
;
}
void
reset
(
)
{
if
(
isSome
(
)
)
{
ref
(
)
.
T
:
:
~
T
(
)
;
mIsSome
=
false
;
poisonData
(
)
;
}
}
template
<
typename
.
.
.
Args
>
void
emplace
(
Args
&
&
.
.
.
aArgs
)
;
template
<
typename
U
>
std
:
:
enable_if_t
<
std
:
:
is_same_v
<
T
U
>
&
&
std
:
:
is_copy_constructible_v
<
U
>
&
&
!
std
:
:
is_move_constructible_v
<
U
>
>
emplace
(
U
&
&
aArgs
)
{
emplace
(
aArgs
)
;
}
friend
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
aStream
const
Maybe
<
T
>
&
aMaybe
)
{
if
(
aMaybe
)
{
aStream
<
<
aMaybe
.
ref
(
)
;
}
else
{
aStream
<
<
"
<
Nothing
>
"
;
}
return
aStream
;
}
}
;
template
<
typename
T
>
class
Maybe
<
T
&
>
{
public
:
constexpr
Maybe
(
)
=
default
;
constexpr
MOZ_IMPLICIT
Maybe
(
Nothing
)
{
}
void
emplace
(
T
&
aRef
)
{
mValue
=
&
aRef
;
}
explicit
operator
bool
(
)
const
{
return
isSome
(
)
;
}
bool
isSome
(
)
const
{
return
mValue
;
}
bool
isNothing
(
)
const
{
return
!
mValue
;
}
T
&
ref
(
)
const
{
MOZ_DIAGNOSTIC_ASSERT
(
isSome
(
)
)
;
return
*
mValue
;
}
T
*
operator
-
>
(
)
const
{
return
&
ref
(
)
;
}
T
&
operator
*
(
)
const
{
return
ref
(
)
;
}
void
reset
(
)
{
mValue
=
nullptr
;
}
template
<
typename
Func
>
Maybe
&
apply
(
Func
&
&
aFunc
)
{
if
(
isSome
(
)
)
{
std
:
:
forward
<
Func
>
(
aFunc
)
(
ref
(
)
)
;
}
return
*
this
;
}
template
<
typename
Func
>
const
Maybe
&
apply
(
Func
&
&
aFunc
)
const
{
if
(
isSome
(
)
)
{
std
:
:
forward
<
Func
>
(
aFunc
)
(
ref
(
)
)
;
}
return
*
this
;
}
template
<
typename
Func
>
auto
map
(
Func
&
&
aFunc
)
{
Maybe
<
decltype
(
std
:
:
forward
<
Func
>
(
aFunc
)
(
ref
(
)
)
)
>
val
;
if
(
isSome
(
)
)
{
val
.
emplace
(
std
:
:
forward
<
Func
>
(
aFunc
)
(
ref
(
)
)
)
;
}
return
val
;
}
template
<
typename
Func
>
auto
map
(
Func
&
&
aFunc
)
const
{
Maybe
<
decltype
(
std
:
:
forward
<
Func
>
(
aFunc
)
(
ref
(
)
)
)
>
val
;
if
(
isSome
(
)
)
{
val
.
emplace
(
std
:
:
forward
<
Func
>
(
aFunc
)
(
ref
(
)
)
)
;
}
return
val
;
}
private
:
T
*
mValue
=
nullptr
;
}
;
template
<
typename
T
>
T
Maybe
<
T
>
:
:
value
(
)
const
{
MOZ_DIAGNOSTIC_ASSERT
(
mIsSome
)
;
return
ref
(
)
;
}
template
<
typename
T
>
T
*
Maybe
<
T
>
:
:
ptr
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mIsSome
)
;
return
&
ref
(
)
;
}
template
<
typename
T
>
const
T
*
Maybe
<
T
>
:
:
ptr
(
)
const
{
MOZ_DIAGNOSTIC_ASSERT
(
mIsSome
)
;
return
&
ref
(
)
;
}
template
<
typename
T
>
T
*
Maybe
<
T
>
:
:
operator
-
>
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mIsSome
)
;
return
ptr
(
)
;
}
template
<
typename
T
>
const
T
*
Maybe
<
T
>
:
:
operator
-
>
(
)
const
{
MOZ_DIAGNOSTIC_ASSERT
(
mIsSome
)
;
return
ptr
(
)
;
}
template
<
typename
T
>
T
&
Maybe
<
T
>
:
:
ref
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mIsSome
)
;
return
mStorage
.
val
;
}
template
<
typename
T
>
const
T
&
Maybe
<
T
>
:
:
ref
(
)
const
{
MOZ_DIAGNOSTIC_ASSERT
(
mIsSome
)
;
return
mStorage
.
val
;
}
template
<
typename
T
>
T
&
Maybe
<
T
>
:
:
operator
*
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mIsSome
)
;
return
ref
(
)
;
}
template
<
typename
T
>
const
T
&
Maybe
<
T
>
:
:
operator
*
(
)
const
{
MOZ_DIAGNOSTIC_ASSERT
(
mIsSome
)
;
return
ref
(
)
;
}
template
<
typename
T
>
template
<
typename
.
.
.
Args
>
void
Maybe
<
T
>
:
:
emplace
(
Args
&
&
.
.
.
aArgs
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mIsSome
)
;
:
:
new
(
KnownNotNull
&
mStorage
.
val
)
T
(
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
;
mIsSome
=
true
;
}
template
<
typename
T
typename
U
=
typename
std
:
:
remove_cv
<
typename
std
:
:
remove_reference
<
T
>
:
:
type
>
:
:
type
>
Maybe
<
U
>
Some
(
T
&
&
aValue
)
{
Maybe
<
U
>
value
;
value
.
emplace
(
std
:
:
forward
<
T
>
(
aValue
)
)
;
return
value
;
}
template
<
typename
T
>
Maybe
<
T
&
>
SomeRef
(
T
&
aValue
)
{
Maybe
<
T
&
>
value
;
value
.
emplace
(
aValue
)
;
return
value
;
}
template
<
typename
T
>
Maybe
<
typename
RemoveCV
<
typename
RemoveReference
<
T
>
:
:
Type
>
:
:
Type
>
ToMaybe
(
T
*
aPtr
)
{
if
(
aPtr
)
{
return
Some
(
*
aPtr
)
;
}
return
Nothing
(
)
;
}
template
<
typename
T
>
bool
operator
=
=
(
const
Maybe
<
T
>
&
aLHS
const
Maybe
<
T
>
&
aRHS
)
{
static_assert
(
!
std
:
:
is_reference_v
<
T
>
"
operator
=
=
is
not
defined
for
Maybe
<
T
&
>
compare
values
or
"
"
addresses
explicitly
instead
"
)
;
if
(
aLHS
.
isNothing
(
)
!
=
aRHS
.
isNothing
(
)
)
{
return
false
;
}
return
aLHS
.
isNothing
(
)
|
|
*
aLHS
=
=
*
aRHS
;
}
template
<
typename
T
>
bool
operator
!
=
(
const
Maybe
<
T
>
&
aLHS
const
Maybe
<
T
>
&
aRHS
)
{
return
!
(
aLHS
=
=
aRHS
)
;
}
template
<
typename
T
>
bool
operator
=
=
(
const
Maybe
<
T
>
&
aLHS
const
Nothing
&
aRHS
)
{
return
aLHS
.
isNothing
(
)
;
}
template
<
typename
T
>
bool
operator
!
=
(
const
Maybe
<
T
>
&
aLHS
const
Nothing
&
aRHS
)
{
return
!
(
aLHS
=
=
aRHS
)
;
}
template
<
typename
T
>
bool
operator
=
=
(
const
Nothing
&
aLHS
const
Maybe
<
T
>
&
aRHS
)
{
return
aRHS
.
isNothing
(
)
;
}
template
<
typename
T
>
bool
operator
!
=
(
const
Nothing
&
aLHS
const
Maybe
<
T
>
&
aRHS
)
{
return
!
(
aLHS
=
=
aRHS
)
;
}
template
<
typename
T
>
bool
operator
<
(
const
Maybe
<
T
>
&
aLHS
const
Maybe
<
T
>
&
aRHS
)
{
if
(
aLHS
.
isNothing
(
)
)
{
return
aRHS
.
isSome
(
)
;
}
if
(
aRHS
.
isNothing
(
)
)
{
return
false
;
}
return
*
aLHS
<
*
aRHS
;
}
template
<
typename
T
>
bool
operator
>
(
const
Maybe
<
T
>
&
aLHS
const
Maybe
<
T
>
&
aRHS
)
{
return
!
(
aLHS
<
aRHS
|
|
aLHS
=
=
aRHS
)
;
}
template
<
typename
T
>
bool
operator
<
=
(
const
Maybe
<
T
>
&
aLHS
const
Maybe
<
T
>
&
aRHS
)
{
return
aLHS
<
aRHS
|
|
aLHS
=
=
aRHS
;
}
template
<
typename
T
>
bool
operator
>
=
(
const
Maybe
<
T
>
&
aLHS
const
Maybe
<
T
>
&
aRHS
)
{
return
!
(
aLHS
<
aRHS
)
;
}
template
<
typename
T
>
inline
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
aCallback
mozilla
:
:
Maybe
<
T
>
&
aField
const
char
*
aName
uint32_t
aFlags
=
0
)
{
if
(
aField
)
{
ImplCycleCollectionTraverse
(
aCallback
aField
.
ref
(
)
aName
aFlags
)
;
}
}
template
<
typename
T
>
inline
void
ImplCycleCollectionUnlink
(
mozilla
:
:
Maybe
<
T
>
&
aField
)
{
if
(
aField
)
{
ImplCycleCollectionUnlink
(
aField
.
ref
(
)
)
;
}
}
}
#
endif
