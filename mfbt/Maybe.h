#
ifndef
mozilla_Maybe_h
#
define
mozilla_Maybe_h
#
include
"
mozilla
/
Alignment
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
MemoryChecking
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
OperatorNewExtensions
.
h
"
#
include
"
mozilla
/
Poison
.
h
"
#
include
"
mozilla
/
TypeTraits
.
h
"
#
include
<
new
>
#
include
<
ostream
>
#
include
<
type_traits
>
class
nsCycleCollectionTraversalCallback
;
template
<
typename
T
>
inline
void
CycleCollectionNoteChild
(
nsCycleCollectionTraversalCallback
&
aCallback
T
*
aChild
const
char
*
aName
uint32_t
aFlags
)
;
namespace
mozilla
{
struct
Nothing
{
}
;
namespace
detail
{
template
<
size_t
offset
>
inline
void
WritePoisonAtOffset
(
void
*
p
const
uintptr_t
poisonValue
)
{
memcpy
(
static_cast
<
char
*
>
(
p
)
+
offset
*
sizeof
(
poisonValue
)
&
poisonValue
sizeof
(
poisonValue
)
)
;
}
template
<
size_t
Offset
size_t
NOffsets
>
struct
InlinePoisoner
{
static
void
poison
(
void
*
p
const
uintptr_t
poisonValue
)
{
WritePoisonAtOffset
<
Offset
>
(
p
poisonValue
)
;
InlinePoisoner
<
Offset
+
1
NOffsets
>
:
:
poison
(
p
poisonValue
)
;
}
}
;
template
<
size_t
N
>
struct
InlinePoisoner
<
N
N
>
{
static
void
poison
(
void
*
const
uintptr_t
)
{
}
}
;
template
<
size_t
ObjectSize
>
struct
OutOfLinePoisoner
{
static
MOZ_NEVER_INLINE
void
poison
(
void
*
p
const
uintptr_t
)
{
mozWritePoison
(
p
ObjectSize
)
;
}
}
;
template
<
typename
T
>
inline
void
PoisonObject
(
T
*
p
)
{
const
uintptr_t
POISON
=
mozPoisonValue
(
)
;
Conditional
<
(
sizeof
(
T
)
<
=
8
*
sizeof
(
POISON
)
)
InlinePoisoner
<
0
sizeof
(
T
)
/
sizeof
(
POISON
)
>
OutOfLinePoisoner
<
sizeof
(
T
)
>
>
:
:
Type
:
:
poison
(
p
POISON
)
;
}
template
<
typename
T
>
struct
MaybePoisoner
{
static
const
size_t
N
=
sizeof
(
T
)
;
static
void
poison
(
void
*
aPtr
)
{
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
if
(
N
>
=
sizeof
(
uintptr_t
)
)
{
PoisonObject
(
static_cast
<
typename
RemoveCV
<
T
>
:
:
Type
*
>
(
aPtr
)
)
;
}
#
endif
MOZ_MAKE_MEM_UNDEFINED
(
aPtr
N
)
;
}
}
;
}
template
<
class
T
>
class
MOZ_NON_PARAM
MOZ_INHERIT_TYPE_ANNOTATIONS_FROM_TEMPLATE_ARGS
Maybe
{
MOZ_ALIGNAS_IN_STRUCT
(
T
)
unsigned
char
mStorage
[
sizeof
(
T
)
]
;
char
mIsSome
;
void
*
data
(
)
{
return
mStorage
;
}
const
void
*
data
(
)
const
{
return
mStorage
;
}
void
poisonData
(
)
{
detail
:
:
MaybePoisoner
<
T
>
:
:
poison
(
data
(
)
)
;
}
public
:
using
ValueType
=
T
;
MOZ_ALLOW_TEMPORARY
Maybe
(
)
:
mIsSome
(
false
)
{
}
~
Maybe
(
)
{
reset
(
)
;
}
MOZ_ALLOW_TEMPORARY
MOZ_IMPLICIT
Maybe
(
Nothing
)
:
mIsSome
(
false
)
{
}
Maybe
(
const
Maybe
&
aOther
)
:
mIsSome
(
false
)
{
if
(
aOther
.
mIsSome
)
{
emplace
(
*
aOther
)
;
}
}
template
<
typename
U
typename
=
typename
std
:
:
enable_if
<
std
:
:
is_convertible
<
U
T
>
:
:
value
>
:
:
type
>
MOZ_IMPLICIT
Maybe
(
const
Maybe
<
U
>
&
aOther
)
:
mIsSome
(
false
)
{
if
(
aOther
.
isSome
(
)
)
{
emplace
(
*
aOther
)
;
}
}
Maybe
(
Maybe
&
&
aOther
)
:
mIsSome
(
false
)
{
if
(
aOther
.
mIsSome
)
{
emplace
(
std
:
:
move
(
*
aOther
)
)
;
aOther
.
reset
(
)
;
}
}
template
<
typename
U
typename
=
typename
std
:
:
enable_if
<
std
:
:
is_convertible
<
U
T
>
:
:
value
>
:
:
type
>
MOZ_IMPLICIT
Maybe
(
Maybe
<
U
>
&
&
aOther
)
:
mIsSome
(
false
)
{
if
(
aOther
.
isSome
(
)
)
{
emplace
(
std
:
:
move
(
*
aOther
)
)
;
aOther
.
reset
(
)
;
}
}
Maybe
&
operator
=
(
const
Maybe
&
aOther
)
{
if
(
&
aOther
!
=
this
)
{
if
(
aOther
.
mIsSome
)
{
if
(
mIsSome
)
{
ref
(
)
=
aOther
.
ref
(
)
;
}
else
{
emplace
(
*
aOther
)
;
}
}
else
{
reset
(
)
;
}
}
return
*
this
;
}
template
<
typename
U
typename
=
typename
std
:
:
enable_if
<
std
:
:
is_convertible
<
U
T
>
:
:
value
>
:
:
type
>
Maybe
&
operator
=
(
const
Maybe
<
U
>
&
aOther
)
{
if
(
aOther
.
isSome
(
)
)
{
if
(
mIsSome
)
{
ref
(
)
=
aOther
.
ref
(
)
;
}
else
{
emplace
(
*
aOther
)
;
}
}
else
{
reset
(
)
;
}
return
*
this
;
}
Maybe
&
operator
=
(
Maybe
&
&
aOther
)
{
MOZ_ASSERT
(
this
!
=
&
aOther
"
Self
-
moves
are
prohibited
"
)
;
if
(
aOther
.
mIsSome
)
{
if
(
mIsSome
)
{
ref
(
)
=
std
:
:
move
(
aOther
.
ref
(
)
)
;
}
else
{
emplace
(
std
:
:
move
(
*
aOther
)
)
;
}
aOther
.
reset
(
)
;
}
else
{
reset
(
)
;
}
return
*
this
;
}
template
<
typename
U
typename
=
typename
std
:
:
enable_if
<
std
:
:
is_convertible
<
U
T
>
:
:
value
>
:
:
type
>
Maybe
&
operator
=
(
Maybe
<
U
>
&
&
aOther
)
{
if
(
aOther
.
isSome
(
)
)
{
if
(
mIsSome
)
{
ref
(
)
=
std
:
:
move
(
aOther
.
ref
(
)
)
;
}
else
{
emplace
(
std
:
:
move
(
*
aOther
)
)
;
}
aOther
.
reset
(
)
;
}
else
{
reset
(
)
;
}
return
*
this
;
}
explicit
operator
bool
(
)
const
{
return
isSome
(
)
;
}
bool
isSome
(
)
const
{
return
mIsSome
;
}
bool
isNothing
(
)
const
{
return
!
mIsSome
;
}
T
value
(
)
const
;
template
<
typename
V
>
T
valueOr
(
V
&
&
aDefault
)
const
{
if
(
isSome
(
)
)
{
return
ref
(
)
;
}
return
std
:
:
forward
<
V
>
(
aDefault
)
;
}
template
<
typename
F
>
T
valueOrFrom
(
F
&
&
aFunc
)
const
{
if
(
isSome
(
)
)
{
return
ref
(
)
;
}
return
aFunc
(
)
;
}
T
*
ptr
(
)
;
const
T
*
ptr
(
)
const
;
T
*
ptrOr
(
T
*
aDefault
)
{
if
(
isSome
(
)
)
{
return
ptr
(
)
;
}
return
aDefault
;
}
const
T
*
ptrOr
(
const
T
*
aDefault
)
const
{
if
(
isSome
(
)
)
{
return
ptr
(
)
;
}
return
aDefault
;
}
template
<
typename
F
>
T
*
ptrOrFrom
(
F
&
&
aFunc
)
{
if
(
isSome
(
)
)
{
return
ptr
(
)
;
}
return
aFunc
(
)
;
}
template
<
typename
F
>
const
T
*
ptrOrFrom
(
F
&
&
aFunc
)
const
{
if
(
isSome
(
)
)
{
return
ptr
(
)
;
}
return
aFunc
(
)
;
}
T
*
operator
-
>
(
)
;
const
T
*
operator
-
>
(
)
const
;
T
&
ref
(
)
;
const
T
&
ref
(
)
const
;
T
&
refOr
(
T
&
aDefault
)
{
if
(
isSome
(
)
)
{
return
ref
(
)
;
}
return
aDefault
;
}
const
T
&
refOr
(
const
T
&
aDefault
)
const
{
if
(
isSome
(
)
)
{
return
ref
(
)
;
}
return
aDefault
;
}
template
<
typename
F
>
T
&
refOrFrom
(
F
&
&
aFunc
)
{
if
(
isSome
(
)
)
{
return
ref
(
)
;
}
return
aFunc
(
)
;
}
template
<
typename
F
>
const
T
&
refOrFrom
(
F
&
&
aFunc
)
const
{
if
(
isSome
(
)
)
{
return
ref
(
)
;
}
return
aFunc
(
)
;
}
T
&
operator
*
(
)
;
const
T
&
operator
*
(
)
const
;
template
<
typename
Func
>
Maybe
&
apply
(
Func
&
&
aFunc
)
{
if
(
isSome
(
)
)
{
std
:
:
forward
<
Func
>
(
aFunc
)
(
ref
(
)
)
;
}
return
*
this
;
}
template
<
typename
Func
>
const
Maybe
&
apply
(
Func
&
&
aFunc
)
const
{
if
(
isSome
(
)
)
{
std
:
:
forward
<
Func
>
(
aFunc
)
(
ref
(
)
)
;
}
return
*
this
;
}
template
<
typename
Func
>
auto
map
(
Func
&
&
aFunc
)
{
Maybe
<
decltype
(
std
:
:
forward
<
Func
>
(
aFunc
)
(
ref
(
)
)
)
>
val
;
if
(
isSome
(
)
)
{
val
.
emplace
(
std
:
:
forward
<
Func
>
(
aFunc
)
(
ref
(
)
)
)
;
}
return
val
;
}
template
<
typename
Func
>
auto
map
(
Func
&
&
aFunc
)
const
{
Maybe
<
decltype
(
std
:
:
forward
<
Func
>
(
aFunc
)
(
ref
(
)
)
)
>
val
;
if
(
isSome
(
)
)
{
val
.
emplace
(
std
:
:
forward
<
Func
>
(
aFunc
)
(
ref
(
)
)
)
;
}
return
val
;
}
void
reset
(
)
{
if
(
isSome
(
)
)
{
ref
(
)
.
T
:
:
~
T
(
)
;
mIsSome
=
false
;
poisonData
(
)
;
}
}
template
<
typename
.
.
.
Args
>
void
emplace
(
Args
&
&
.
.
.
aArgs
)
;
friend
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
aStream
const
Maybe
<
T
>
&
aMaybe
)
{
if
(
aMaybe
)
{
aStream
<
<
aMaybe
.
ref
(
)
;
}
else
{
aStream
<
<
"
<
Nothing
>
"
;
}
return
aStream
;
}
}
;
template
<
typename
T
>
T
Maybe
<
T
>
:
:
value
(
)
const
{
MOZ_DIAGNOSTIC_ASSERT
(
mIsSome
)
;
return
ref
(
)
;
}
template
<
typename
T
>
T
*
Maybe
<
T
>
:
:
ptr
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mIsSome
)
;
return
&
ref
(
)
;
}
template
<
typename
T
>
const
T
*
Maybe
<
T
>
:
:
ptr
(
)
const
{
MOZ_DIAGNOSTIC_ASSERT
(
mIsSome
)
;
return
&
ref
(
)
;
}
template
<
typename
T
>
T
*
Maybe
<
T
>
:
:
operator
-
>
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mIsSome
)
;
return
ptr
(
)
;
}
template
<
typename
T
>
const
T
*
Maybe
<
T
>
:
:
operator
-
>
(
)
const
{
MOZ_DIAGNOSTIC_ASSERT
(
mIsSome
)
;
return
ptr
(
)
;
}
template
<
typename
T
>
T
&
Maybe
<
T
>
:
:
ref
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mIsSome
)
;
return
*
static_cast
<
T
*
>
(
data
(
)
)
;
}
template
<
typename
T
>
const
T
&
Maybe
<
T
>
:
:
ref
(
)
const
{
MOZ_DIAGNOSTIC_ASSERT
(
mIsSome
)
;
return
*
static_cast
<
const
T
*
>
(
data
(
)
)
;
}
template
<
typename
T
>
T
&
Maybe
<
T
>
:
:
operator
*
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mIsSome
)
;
return
ref
(
)
;
}
template
<
typename
T
>
const
T
&
Maybe
<
T
>
:
:
operator
*
(
)
const
{
MOZ_DIAGNOSTIC_ASSERT
(
mIsSome
)
;
return
ref
(
)
;
}
template
<
typename
T
>
template
<
typename
.
.
.
Args
>
void
Maybe
<
T
>
:
:
emplace
(
Args
&
&
.
.
.
aArgs
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mIsSome
)
;
:
:
new
(
KnownNotNull
data
(
)
)
T
(
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
;
mIsSome
=
true
;
}
template
<
typename
T
typename
U
=
typename
std
:
:
remove_cv
<
typename
std
:
:
remove_reference
<
T
>
:
:
type
>
:
:
type
>
Maybe
<
U
>
Some
(
T
&
&
aValue
)
{
Maybe
<
U
>
value
;
value
.
emplace
(
std
:
:
forward
<
T
>
(
aValue
)
)
;
return
value
;
}
template
<
typename
T
>
Maybe
<
typename
RemoveCV
<
typename
RemoveReference
<
T
>
:
:
Type
>
:
:
Type
>
ToMaybe
(
T
*
aPtr
)
{
if
(
aPtr
)
{
return
Some
(
*
aPtr
)
;
}
return
Nothing
(
)
;
}
template
<
typename
T
>
bool
operator
=
=
(
const
Maybe
<
T
>
&
aLHS
const
Maybe
<
T
>
&
aRHS
)
{
if
(
aLHS
.
isNothing
(
)
!
=
aRHS
.
isNothing
(
)
)
{
return
false
;
}
return
aLHS
.
isNothing
(
)
|
|
*
aLHS
=
=
*
aRHS
;
}
template
<
typename
T
>
bool
operator
!
=
(
const
Maybe
<
T
>
&
aLHS
const
Maybe
<
T
>
&
aRHS
)
{
return
!
(
aLHS
=
=
aRHS
)
;
}
template
<
typename
T
>
bool
operator
=
=
(
const
Maybe
<
T
>
&
aLHS
const
Nothing
&
aRHS
)
{
return
aLHS
.
isNothing
(
)
;
}
template
<
typename
T
>
bool
operator
!
=
(
const
Maybe
<
T
>
&
aLHS
const
Nothing
&
aRHS
)
{
return
!
(
aLHS
=
=
aRHS
)
;
}
template
<
typename
T
>
bool
operator
=
=
(
const
Nothing
&
aLHS
const
Maybe
<
T
>
&
aRHS
)
{
return
aRHS
.
isNothing
(
)
;
}
template
<
typename
T
>
bool
operator
!
=
(
const
Nothing
&
aLHS
const
Maybe
<
T
>
&
aRHS
)
{
return
!
(
aLHS
=
=
aRHS
)
;
}
template
<
typename
T
>
bool
operator
<
(
const
Maybe
<
T
>
&
aLHS
const
Maybe
<
T
>
&
aRHS
)
{
if
(
aLHS
.
isNothing
(
)
)
{
return
aRHS
.
isSome
(
)
;
}
if
(
aRHS
.
isNothing
(
)
)
{
return
false
;
}
return
*
aLHS
<
*
aRHS
;
}
template
<
typename
T
>
bool
operator
>
(
const
Maybe
<
T
>
&
aLHS
const
Maybe
<
T
>
&
aRHS
)
{
return
!
(
aLHS
<
aRHS
|
|
aLHS
=
=
aRHS
)
;
}
template
<
typename
T
>
bool
operator
<
=
(
const
Maybe
<
T
>
&
aLHS
const
Maybe
<
T
>
&
aRHS
)
{
return
aLHS
<
aRHS
|
|
aLHS
=
=
aRHS
;
}
template
<
typename
T
>
bool
operator
>
=
(
const
Maybe
<
T
>
&
aLHS
const
Maybe
<
T
>
&
aRHS
)
{
return
!
(
aLHS
<
aRHS
)
;
}
template
<
typename
T
>
inline
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
aCallback
mozilla
:
:
Maybe
<
T
>
&
aField
const
char
*
aName
uint32_t
aFlags
=
0
)
{
if
(
aField
)
{
ImplCycleCollectionTraverse
(
aCallback
aField
.
ref
(
)
aName
aFlags
)
;
}
}
template
<
typename
T
>
inline
void
ImplCycleCollectionUnlink
(
mozilla
:
:
Maybe
<
T
>
&
aField
)
{
if
(
aField
)
{
ImplCycleCollectionUnlink
(
aField
.
ref
(
)
)
;
}
}
}
#
endif
