#
ifndef
mozilla_RefPtr_h
#
define
mozilla_RefPtr_h
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
RefCounted
.
h
"
#
include
"
mozilla
/
RefCountType
.
h
"
#
include
"
mozilla
/
nsRefPtr
.
h
"
#
include
"
mozilla
/
TypeTraits
.
h
"
#
if
defined
(
MOZILLA_INTERNAL_API
)
#
include
"
nsXPCOM
.
h
"
#
endif
#
if
defined
(
MOZILLA_INTERNAL_API
)
&
&
\
!
defined
(
MOZILLA_XPCOMRT_API
)
&
&
\
(
defined
(
DEBUG
)
|
|
defined
(
FORCE_BUILD_REFCNT_LOGGING
)
)
#
define
MOZ_REFCOUNTED_LEAK_CHECKING
#
endif
namespace
mozilla
{
template
<
typename
T
>
class
OutParamRef
;
template
<
typename
T
>
OutParamRef
<
T
>
byRef
(
RefPtr
<
T
>
&
)
;
template
<
typename
T
>
class
RefPtr
{
friend
class
OutParamRef
<
T
>
;
struct
DontRef
{
}
;
public
:
RefPtr
(
)
:
mPtr
(
0
)
{
}
RefPtr
(
const
RefPtr
&
aOther
)
:
mPtr
(
ref
(
aOther
.
mPtr
)
)
{
}
MOZ_IMPLICIT
RefPtr
(
already_AddRefed
<
T
>
&
aOther
)
:
mPtr
(
aOther
.
take
(
)
)
{
}
MOZ_IMPLICIT
RefPtr
(
already_AddRefed
<
T
>
&
&
aOther
)
:
mPtr
(
aOther
.
take
(
)
)
{
}
MOZ_IMPLICIT
RefPtr
(
T
*
aVal
)
:
mPtr
(
ref
(
aVal
)
)
{
}
template
<
typename
U
>
MOZ_IMPLICIT
RefPtr
(
const
RefPtr
<
U
>
&
aOther
)
:
mPtr
(
ref
(
aOther
.
get
(
)
)
)
{
}
~
RefPtr
(
)
{
unref
(
mPtr
)
;
}
RefPtr
&
operator
=
(
const
RefPtr
&
aOther
)
{
assign
(
ref
(
aOther
.
mPtr
)
)
;
return
*
this
;
}
RefPtr
&
operator
=
(
already_AddRefed
<
T
>
&
aOther
)
{
assign
(
aOther
.
take
(
)
)
;
return
*
this
;
}
RefPtr
&
operator
=
(
already_AddRefed
<
T
>
&
&
aOther
)
{
assign
(
aOther
.
take
(
)
)
;
return
*
this
;
}
RefPtr
&
operator
=
(
T
*
aVal
)
{
assign
(
ref
(
aVal
)
)
;
return
*
this
;
}
template
<
typename
U
>
RefPtr
&
operator
=
(
const
RefPtr
<
U
>
&
aOther
)
{
assign
(
ref
(
aOther
.
get
(
)
)
)
;
return
*
this
;
}
already_AddRefed
<
T
>
forget
(
)
{
T
*
tmp
=
mPtr
;
mPtr
=
nullptr
;
return
already_AddRefed
<
T
>
(
tmp
)
;
}
T
*
get
(
)
const
{
return
mPtr
;
}
operator
T
*
(
)
const
#
ifdef
MOZ_HAVE_REF_QUALIFIERS
&
#
endif
{
return
mPtr
;
}
T
*
operator
-
>
(
)
const
MOZ_NO_ADDREF_RELEASE_ON_RETURN
{
return
mPtr
;
}
T
&
operator
*
(
)
const
{
return
*
mPtr
;
}
#
ifdef
MOZ_HAVE_REF_QUALIFIERS
operator
T
*
(
)
const
&
&
=
delete
;
explicit
operator
bool
(
)
const
{
return
!
!
mPtr
;
}
#
endif
private
:
void
assign
(
T
*
aVal
)
{
T
*
tmp
=
mPtr
;
mPtr
=
aVal
;
unref
(
tmp
)
;
}
T
*
MOZ_OWNING_REF
mPtr
;
static
MOZ_ALWAYS_INLINE
T
*
ref
(
T
*
aVal
)
{
if
(
aVal
)
{
aVal
-
>
AddRef
(
)
;
}
return
aVal
;
}
static
MOZ_ALWAYS_INLINE
void
unref
(
T
*
aVal
)
{
if
(
aVal
)
{
aVal
-
>
Release
(
)
;
}
}
}
;
template
<
typename
T
>
class
OutParamRef
{
friend
OutParamRef
byRef
<
T
>
(
RefPtr
<
T
>
&
)
;
public
:
~
OutParamRef
(
)
{
RefPtr
<
T
>
:
:
unref
(
mRefPtr
.
mPtr
)
;
mRefPtr
.
mPtr
=
mTmp
;
}
operator
T
*
*
(
)
{
return
&
mTmp
;
}
private
:
explicit
OutParamRef
(
RefPtr
<
T
>
&
p
)
:
mRefPtr
(
p
)
mTmp
(
p
.
get
(
)
)
{
}
RefPtr
<
T
>
&
mRefPtr
;
T
*
mTmp
;
OutParamRef
(
)
=
delete
;
OutParamRef
&
operator
=
(
const
OutParamRef
&
)
=
delete
;
}
;
template
<
typename
T
>
OutParamRef
<
T
>
byRef
(
RefPtr
<
T
>
&
aPtr
)
{
return
OutParamRef
<
T
>
(
aPtr
)
;
}
}
template
<
class
T
>
template
<
class
U
>
nsRefPtr
<
T
>
:
:
nsRefPtr
(
mozilla
:
:
RefPtr
<
U
>
&
&
aOther
)
:
nsRefPtr
(
aOther
.
forget
(
)
)
{
}
template
<
class
T
>
template
<
class
U
>
nsRefPtr
<
T
>
&
nsRefPtr
<
T
>
:
:
operator
=
(
mozilla
:
:
RefPtr
<
U
>
&
&
aOther
)
{
assign_assuming_AddRef
(
aOther
.
forget
(
)
.
take
(
)
)
;
return
*
this
;
}
#
endif
