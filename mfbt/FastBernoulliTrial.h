#
ifndef
mozilla_FastBernoulliTrial_h
#
define
mozilla_FastBernoulliTrial_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
XorShift128PlusRNG
.
h
"
#
include
<
cmath
>
#
include
<
stdint
.
h
>
namespace
mozilla
{
class
FastBernoulliTrial
{
public
:
FastBernoulliTrial
(
double
aProbability
uint64_t
aState0
uint64_t
aState1
)
:
mProbability
(
0
)
mInvLogNotProbability
(
0
)
mGenerator
(
aState0
aState1
)
mSkipCount
(
0
)
{
setProbability
(
aProbability
)
;
}
bool
trial
(
)
{
if
(
mSkipCount
)
{
mSkipCount
-
-
;
return
false
;
}
return
chooseSkipCount
(
)
;
}
bool
trial
(
size_t
aCount
)
{
if
(
mSkipCount
>
aCount
)
{
mSkipCount
-
=
aCount
;
return
false
;
}
return
chooseSkipCount
(
)
;
}
void
setRandomState
(
uint64_t
aState0
uint64_t
aState1
)
{
mGenerator
.
setState
(
aState0
aState1
)
;
}
void
setProbability
(
double
aProbability
)
{
MOZ_ASSERT
(
0
<
=
aProbability
&
&
aProbability
<
=
1
)
;
mProbability
=
aProbability
;
if
(
0
<
mProbability
&
&
mProbability
<
1
)
{
double
logNotProbability
=
std
:
:
log
(
1
-
mProbability
)
;
if
(
logNotProbability
=
=
0
.
0
)
mProbability
=
0
.
0
;
else
mInvLogNotProbability
=
1
/
logNotProbability
;
}
chooseSkipCount
(
)
;
}
private
:
double
mProbability
;
double
mInvLogNotProbability
;
non_crypto
:
:
XorShift128PlusRNG
mGenerator
;
size_t
mSkipCount
;
bool
chooseSkipCount
(
)
{
if
(
mProbability
=
=
1
.
0
)
{
mSkipCount
=
0
;
return
true
;
}
if
(
mProbability
=
=
0
.
0
)
{
mSkipCount
=
SIZE_MAX
;
return
false
;
}
double
skipCount
=
std
:
:
floor
(
std
:
:
log
(
mGenerator
.
nextDouble
(
)
)
*
mInvLogNotProbability
)
;
if
(
skipCount
<
double
(
SIZE_MAX
)
)
mSkipCount
=
skipCount
;
else
mSkipCount
=
SIZE_MAX
;
return
true
;
}
}
;
}
#
endif
