#
ifndef
mozilla_HashTable_h
#
define
mozilla_HashTable_h
#
include
"
mozilla
/
AllocPolicy
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
MemoryChecking
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
Opaque
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
mozilla
/
ReentrancyGuard
.
h
"
#
include
"
mozilla
/
TypeTraits
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
namespace
mozilla
{
template
<
class
>
struct
DefaultHasher
;
template
<
class
class
>
class
HashMapEntry
;
namespace
detail
{
template
<
typename
T
>
class
HashTableEntry
;
template
<
class
T
class
HashPolicy
class
AllocPolicy
>
class
HashTable
;
}
using
Generation
=
Opaque
<
uint64_t
>
;
template
<
class
Key
class
Value
class
HashPolicy
=
DefaultHasher
<
Key
>
class
AllocPolicy
=
MallocAllocPolicy
>
class
HashMap
{
using
TableEntry
=
HashMapEntry
<
Key
Value
>
;
struct
MapHashPolicy
:
HashPolicy
{
using
Base
=
HashPolicy
;
using
KeyType
=
Key
;
static
const
Key
&
getKey
(
TableEntry
&
aEntry
)
{
return
aEntry
.
key
(
)
;
}
static
void
setKey
(
TableEntry
&
aEntry
Key
&
aKey
)
{
HashPolicy
:
:
rekey
(
aEntry
.
mutableKey
(
)
aKey
)
;
}
}
;
using
Impl
=
detail
:
:
HashTable
<
TableEntry
MapHashPolicy
AllocPolicy
>
;
Impl
mImpl
;
public
:
using
Lookup
=
typename
HashPolicy
:
:
Lookup
;
using
Entry
=
TableEntry
;
explicit
HashMap
(
AllocPolicy
aPolicy
=
AllocPolicy
(
)
)
:
mImpl
(
aPolicy
)
{
}
MOZ_MUST_USE
bool
init
(
uint32_t
aLen
=
16
)
{
return
mImpl
.
init
(
aLen
)
;
}
bool
initialized
(
)
const
{
return
mImpl
.
initialized
(
)
;
}
using
Ptr
=
typename
Impl
:
:
Ptr
;
MOZ_ALWAYS_INLINE
Ptr
lookup
(
const
Lookup
&
aLookup
)
const
{
return
mImpl
.
lookup
(
aLookup
)
;
}
MOZ_ALWAYS_INLINE
Ptr
readonlyThreadsafeLookup
(
const
Lookup
&
aLookup
)
const
{
return
mImpl
.
readonlyThreadsafeLookup
(
aLookup
)
;
}
void
remove
(
Ptr
aPtr
)
{
mImpl
.
remove
(
aPtr
)
;
}
using
AddPtr
=
typename
Impl
:
:
AddPtr
;
MOZ_ALWAYS_INLINE
AddPtr
lookupForAdd
(
const
Lookup
&
aLookup
)
const
{
return
mImpl
.
lookupForAdd
(
aLookup
)
;
}
template
<
typename
KeyInput
typename
ValueInput
>
MOZ_MUST_USE
bool
add
(
AddPtr
&
aPtr
KeyInput
&
&
aKey
ValueInput
&
&
aValue
)
{
return
mImpl
.
add
(
aPtr
std
:
:
forward
<
KeyInput
>
(
aKey
)
std
:
:
forward
<
ValueInput
>
(
aValue
)
)
;
}
template
<
typename
KeyInput
>
MOZ_MUST_USE
bool
add
(
AddPtr
&
aPtr
KeyInput
&
&
aKey
)
{
return
mImpl
.
add
(
aPtr
std
:
:
forward
<
KeyInput
>
(
aKey
)
Value
(
)
)
;
}
template
<
typename
KeyInput
typename
ValueInput
>
MOZ_MUST_USE
bool
relookupOrAdd
(
AddPtr
&
aPtr
KeyInput
&
&
aKey
ValueInput
&
&
aValue
)
{
return
mImpl
.
relookupOrAdd
(
aPtr
aKey
std
:
:
forward
<
KeyInput
>
(
aKey
)
std
:
:
forward
<
ValueInput
>
(
aValue
)
)
;
}
using
Range
=
typename
Impl
:
:
Range
;
Range
all
(
)
const
{
return
mImpl
.
all
(
)
;
}
using
Enum
=
typename
Impl
:
:
Enum
;
void
clear
(
)
{
mImpl
.
clear
(
)
;
}
void
clearAndShrink
(
)
{
mImpl
.
clearAndShrink
(
)
;
}
void
finish
(
)
{
mImpl
.
finish
(
)
;
}
bool
empty
(
)
const
{
return
mImpl
.
empty
(
)
;
}
uint32_t
count
(
)
const
{
return
mImpl
.
count
(
)
;
}
size_t
capacity
(
)
const
{
return
mImpl
.
capacity
(
)
;
}
size_t
shallowSizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
mImpl
.
shallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
}
size_t
shallowSizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
this
)
+
mImpl
.
shallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
}
Generation
generation
(
)
const
{
return
mImpl
.
generation
(
)
;
}
bool
has
(
const
Lookup
&
aLookup
)
const
{
return
mImpl
.
lookup
(
aLookup
)
.
found
(
)
;
}
template
<
typename
KeyInput
typename
ValueInput
>
MOZ_MUST_USE
bool
put
(
KeyInput
&
&
aKey
ValueInput
&
&
aValue
)
{
AddPtr
p
=
lookupForAdd
(
aKey
)
;
if
(
p
)
{
p
-
>
value
(
)
=
std
:
:
forward
<
ValueInput
>
(
aValue
)
;
return
true
;
}
return
add
(
p
std
:
:
forward
<
KeyInput
>
(
aKey
)
std
:
:
forward
<
ValueInput
>
(
aValue
)
)
;
}
template
<
typename
KeyInput
typename
ValueInput
>
MOZ_MUST_USE
bool
putNew
(
KeyInput
&
&
aKey
ValueInput
&
&
aValue
)
{
return
mImpl
.
putNew
(
aKey
std
:
:
forward
<
KeyInput
>
(
aKey
)
std
:
:
forward
<
ValueInput
>
(
aValue
)
)
;
}
template
<
typename
KeyInput
typename
ValueInput
>
void
putNewInfallible
(
KeyInput
&
&
aKey
ValueInput
&
&
aValue
)
{
mImpl
.
putNewInfallible
(
aKey
std
:
:
forward
<
KeyInput
>
(
aKey
)
std
:
:
forward
<
ValueInput
>
(
aValue
)
)
;
}
Ptr
lookupWithDefault
(
const
Key
&
aKey
const
Value
&
aDefaultValue
)
{
AddPtr
p
=
lookupForAdd
(
aKey
)
;
if
(
p
)
{
return
p
;
}
bool
ok
=
add
(
p
aKey
aDefaultValue
)
;
MOZ_ASSERT_IF
(
!
ok
!
p
)
;
(
void
)
ok
;
return
p
;
}
void
remove
(
const
Lookup
&
aLookup
)
{
if
(
Ptr
p
=
lookup
(
aLookup
)
)
{
remove
(
p
)
;
}
}
void
rekeyIfMoved
(
const
Key
&
aOldKey
const
Key
&
aNewKey
)
{
if
(
aOldKey
!
=
aNewKey
)
{
rekeyAs
(
aOldKey
aNewKey
aNewKey
)
;
}
}
bool
rekeyAs
(
const
Lookup
&
aOldLookup
const
Lookup
&
aNewLookup
const
Key
&
aNewKey
)
{
if
(
Ptr
p
=
lookup
(
aOldLookup
)
)
{
mImpl
.
rekeyAndMaybeRehash
(
p
aNewLookup
aNewKey
)
;
return
true
;
}
return
false
;
}
HashMap
(
HashMap
&
&
aRhs
)
:
mImpl
(
std
:
:
move
(
aRhs
.
mImpl
)
)
{
}
void
operator
=
(
HashMap
&
&
aRhs
)
{
MOZ_ASSERT
(
this
!
=
&
aRhs
"
self
-
move
assignment
is
prohibited
"
)
;
mImpl
=
std
:
:
move
(
aRhs
.
mImpl
)
;
}
private
:
HashMap
(
const
HashMap
&
hm
)
=
delete
;
HashMap
&
operator
=
(
const
HashMap
&
hm
)
=
delete
;
friend
class
Impl
:
:
Enum
;
}
;
template
<
class
T
class
HashPolicy
=
DefaultHasher
<
T
>
class
AllocPolicy
=
MallocAllocPolicy
>
class
HashSet
{
struct
SetOps
:
HashPolicy
{
using
Base
=
HashPolicy
;
using
KeyType
=
T
;
static
const
KeyType
&
getKey
(
const
T
&
aT
)
{
return
aT
;
}
static
void
setKey
(
T
&
aT
KeyType
&
aKey
)
{
HashPolicy
:
:
rekey
(
aT
aKey
)
;
}
}
;
using
Impl
=
detail
:
:
HashTable
<
const
T
SetOps
AllocPolicy
>
;
Impl
mImpl
;
public
:
using
Lookup
=
typename
HashPolicy
:
:
Lookup
;
using
Entry
=
T
;
explicit
HashSet
(
AllocPolicy
a
=
AllocPolicy
(
)
)
:
mImpl
(
a
)
{
}
MOZ_MUST_USE
bool
init
(
uint32_t
aLen
=
16
)
{
return
mImpl
.
init
(
aLen
)
;
}
bool
initialized
(
)
const
{
return
mImpl
.
initialized
(
)
;
}
using
Ptr
=
typename
Impl
:
:
Ptr
;
MOZ_ALWAYS_INLINE
Ptr
lookup
(
const
Lookup
&
aLookup
)
const
{
return
mImpl
.
lookup
(
aLookup
)
;
}
MOZ_ALWAYS_INLINE
Ptr
readonlyThreadsafeLookup
(
const
Lookup
&
aLookup
)
const
{
return
mImpl
.
readonlyThreadsafeLookup
(
aLookup
)
;
}
void
remove
(
Ptr
aPtr
)
{
mImpl
.
remove
(
aPtr
)
;
}
using
AddPtr
=
typename
Impl
:
:
AddPtr
;
MOZ_ALWAYS_INLINE
AddPtr
lookupForAdd
(
const
Lookup
&
aLookup
)
const
{
return
mImpl
.
lookupForAdd
(
aLookup
)
;
}
template
<
typename
U
>
MOZ_MUST_USE
bool
add
(
AddPtr
&
aPtr
U
&
&
aU
)
{
return
mImpl
.
add
(
aPtr
std
:
:
forward
<
U
>
(
aU
)
)
;
}
template
<
typename
U
>
MOZ_MUST_USE
bool
relookupOrAdd
(
AddPtr
&
aPtr
const
Lookup
&
aLookup
U
&
&
aU
)
{
return
mImpl
.
relookupOrAdd
(
aPtr
aLookup
std
:
:
forward
<
U
>
(
aU
)
)
;
}
using
Range
=
typename
Impl
:
:
Range
;
Range
all
(
)
const
{
return
mImpl
.
all
(
)
;
}
using
Enum
=
typename
Impl
:
:
Enum
;
void
clear
(
)
{
mImpl
.
clear
(
)
;
}
void
clearAndShrink
(
)
{
mImpl
.
clearAndShrink
(
)
;
}
void
finish
(
)
{
mImpl
.
finish
(
)
;
}
bool
empty
(
)
const
{
return
mImpl
.
empty
(
)
;
}
uint32_t
count
(
)
const
{
return
mImpl
.
count
(
)
;
}
size_t
capacity
(
)
const
{
return
mImpl
.
capacity
(
)
;
}
size_t
shallowSizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
mImpl
.
shallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
}
size_t
shallowSizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
this
)
+
mImpl
.
shallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
}
Generation
generation
(
)
const
{
return
mImpl
.
generation
(
)
;
}
bool
has
(
const
Lookup
&
aLookup
)
const
{
return
mImpl
.
lookup
(
aLookup
)
.
found
(
)
;
}
template
<
typename
U
>
MOZ_MUST_USE
bool
put
(
U
&
&
aU
)
{
AddPtr
p
=
lookupForAdd
(
aU
)
;
return
p
?
true
:
add
(
p
std
:
:
forward
<
U
>
(
aU
)
)
;
}
template
<
typename
U
>
MOZ_MUST_USE
bool
putNew
(
U
&
&
aU
)
{
return
mImpl
.
putNew
(
aU
std
:
:
forward
<
U
>
(
aU
)
)
;
}
template
<
typename
U
>
MOZ_MUST_USE
bool
putNew
(
const
Lookup
&
aLookup
U
&
&
aU
)
{
return
mImpl
.
putNew
(
aLookup
std
:
:
forward
<
U
>
(
aU
)
)
;
}
template
<
typename
U
>
void
putNewInfallible
(
const
Lookup
&
aLookup
U
&
&
aU
)
{
mImpl
.
putNewInfallible
(
aLookup
std
:
:
forward
<
U
>
(
aU
)
)
;
}
void
remove
(
const
Lookup
&
aLookup
)
{
if
(
Ptr
p
=
lookup
(
aLookup
)
)
{
remove
(
p
)
;
}
}
void
rekeyIfMoved
(
const
Lookup
&
aOldValue
const
T
&
aNewValue
)
{
if
(
aOldValue
!
=
aNewValue
)
{
rekeyAs
(
aOldValue
aNewValue
aNewValue
)
;
}
}
bool
rekeyAs
(
const
Lookup
&
aOldLookup
const
Lookup
&
aNewLookup
const
T
&
aNewValue
)
{
if
(
Ptr
p
=
lookup
(
aOldLookup
)
)
{
mImpl
.
rekeyAndMaybeRehash
(
p
aNewLookup
aNewValue
)
;
return
true
;
}
return
false
;
}
void
replaceKey
(
Ptr
aPtr
const
T
&
aNewValue
)
{
MOZ_ASSERT
(
aPtr
.
found
(
)
)
;
MOZ_ASSERT
(
*
aPtr
!
=
aNewValue
)
;
MOZ_ASSERT
(
HashPolicy
:
:
hash
(
*
aPtr
)
=
=
HashPolicy
:
:
hash
(
aNewValue
)
)
;
MOZ_ASSERT
(
HashPolicy
:
:
match
(
*
aPtr
aNewValue
)
)
;
const_cast
<
T
&
>
(
*
aPtr
)
=
aNewValue
;
}
HashSet
(
HashSet
&
&
aRhs
)
:
mImpl
(
std
:
:
move
(
aRhs
.
mImpl
)
)
{
}
void
operator
=
(
HashSet
&
&
aRhs
)
{
MOZ_ASSERT
(
this
!
=
&
aRhs
"
self
-
move
assignment
is
prohibited
"
)
;
mImpl
=
std
:
:
move
(
aRhs
.
mImpl
)
;
}
private
:
HashSet
(
const
HashSet
&
hs
)
=
delete
;
HashSet
&
operator
=
(
const
HashSet
&
hs
)
=
delete
;
friend
class
Impl
:
:
Enum
;
}
;
template
<
typename
Key
>
struct
PointerHasher
{
using
Lookup
=
Key
;
static
HashNumber
hash
(
const
Lookup
&
aLookup
)
{
size_t
word
=
reinterpret_cast
<
size_t
>
(
aLookup
)
;
return
HashGeneric
(
word
)
;
}
static
bool
match
(
const
Key
&
aKey
const
Lookup
&
aLookup
)
{
return
aKey
=
=
aLookup
;
}
static
void
rekey
(
Key
&
aKey
const
Key
&
aNewKey
)
{
aKey
=
aNewKey
;
}
}
;
template
<
class
Key
>
struct
DefaultHasher
{
using
Lookup
=
Key
;
static
HashNumber
hash
(
const
Lookup
&
aLookup
)
{
return
aLookup
;
}
static
bool
match
(
const
Key
&
aKey
const
Lookup
&
aLookup
)
{
return
aKey
=
=
aLookup
;
}
static
void
rekey
(
Key
&
aKey
const
Key
&
aNewKey
)
{
aKey
=
aNewKey
;
}
}
;
template
<
class
T
>
struct
DefaultHasher
<
T
*
>
:
PointerHasher
<
T
*
>
{
}
;
template
<
class
T
class
D
>
struct
DefaultHasher
<
UniquePtr
<
T
D
>
>
{
using
Lookup
=
UniquePtr
<
T
D
>
;
using
PtrHasher
=
PointerHasher
<
T
*
>
;
static
HashNumber
hash
(
const
Lookup
&
aLookup
)
{
return
PtrHasher
:
:
hash
(
aLookup
.
get
(
)
)
;
}
static
bool
match
(
const
UniquePtr
<
T
D
>
&
aKey
const
Lookup
&
aLookup
)
{
return
PtrHasher
:
:
match
(
aKey
.
get
(
)
aLookup
.
get
(
)
)
;
}
static
void
rekey
(
UniquePtr
<
T
D
>
&
aKey
UniquePtr
<
T
D
>
&
&
aNewKey
)
{
aKey
=
std
:
:
move
(
aNewKey
)
;
}
}
;
template
<
>
struct
DefaultHasher
<
double
>
{
using
Lookup
=
double
;
static
HashNumber
hash
(
double
aVal
)
{
static_assert
(
sizeof
(
HashNumber
)
=
=
4
"
subsequent
code
assumes
a
four
-
byte
hash
"
)
;
uint64_t
u
=
BitwiseCast
<
uint64_t
>
(
aVal
)
;
return
HashNumber
(
u
^
(
u
>
>
32
)
)
;
}
static
bool
match
(
double
aLhs
double
aRhs
)
{
return
BitwiseCast
<
uint64_t
>
(
aLhs
)
=
=
BitwiseCast
<
uint64_t
>
(
aRhs
)
;
}
}
;
template
<
>
struct
DefaultHasher
<
float
>
{
using
Lookup
=
float
;
static
HashNumber
hash
(
float
aVal
)
{
static_assert
(
sizeof
(
HashNumber
)
=
=
4
"
subsequent
code
assumes
a
four
-
byte
hash
"
)
;
return
HashNumber
(
BitwiseCast
<
uint32_t
>
(
aVal
)
)
;
}
static
bool
match
(
float
aLhs
float
aRhs
)
{
return
BitwiseCast
<
uint32_t
>
(
aLhs
)
=
=
BitwiseCast
<
uint32_t
>
(
aRhs
)
;
}
}
;
struct
CStringHasher
{
using
Lookup
=
const
char
*
;
static
HashNumber
hash
(
Lookup
aLookup
)
{
return
HashString
(
aLookup
)
;
}
static
bool
match
(
const
char
*
key
Lookup
lookup
)
{
return
strcmp
(
key
lookup
)
=
=
0
;
}
}
;
template
<
typename
HashPolicy
>
struct
FallibleHashMethods
{
template
<
typename
Lookup
>
static
bool
hasHash
(
Lookup
&
&
aLookup
)
{
return
true
;
}
template
<
typename
Lookup
>
static
bool
ensureHash
(
Lookup
&
&
aLookup
)
{
return
true
;
}
}
;
template
<
typename
HashPolicy
typename
Lookup
>
static
bool
HasHash
(
Lookup
&
&
aLookup
)
{
return
FallibleHashMethods
<
typename
HashPolicy
:
:
Base
>
:
:
hasHash
(
std
:
:
forward
<
Lookup
>
(
aLookup
)
)
;
}
template
<
typename
HashPolicy
typename
Lookup
>
static
bool
EnsureHash
(
Lookup
&
&
aLookup
)
{
return
FallibleHashMethods
<
typename
HashPolicy
:
:
Base
>
:
:
ensureHash
(
std
:
:
forward
<
Lookup
>
(
aLookup
)
)
;
}
template
<
class
Key
class
Value
>
class
HashMapEntry
{
Key
key_
;
Value
value_
;
template
<
class
class
class
>
friend
class
detail
:
:
HashTable
;
template
<
class
>
friend
class
detail
:
:
HashTableEntry
;
template
<
class
class
class
class
>
friend
class
HashMap
;
public
:
template
<
typename
KeyInput
typename
ValueInput
>
HashMapEntry
(
KeyInput
&
&
aKey
ValueInput
&
&
aValue
)
:
key_
(
std
:
:
forward
<
KeyInput
>
(
aKey
)
)
value_
(
std
:
:
forward
<
ValueInput
>
(
aValue
)
)
{
}
HashMapEntry
(
HashMapEntry
&
&
aRhs
)
:
key_
(
std
:
:
move
(
aRhs
.
key_
)
)
value_
(
std
:
:
move
(
aRhs
.
value_
)
)
{
}
void
operator
=
(
HashMapEntry
&
&
aRhs
)
{
key_
=
std
:
:
move
(
aRhs
.
key_
)
;
value_
=
std
:
:
move
(
aRhs
.
value_
)
;
}
using
KeyType
=
Key
;
using
ValueType
=
Value
;
const
Key
&
key
(
)
const
{
return
key_
;
}
Key
&
mutableKey
(
)
{
return
key_
;
}
const
Value
&
value
(
)
const
{
return
value_
;
}
Value
&
value
(
)
{
return
value_
;
}
private
:
HashMapEntry
(
const
HashMapEntry
&
)
=
delete
;
void
operator
=
(
const
HashMapEntry
&
)
=
delete
;
}
;
template
<
typename
K
typename
V
>
struct
IsPod
<
HashMapEntry
<
K
V
>
>
:
IntegralConstant
<
bool
IsPod
<
K
>
:
:
value
&
&
IsPod
<
V
>
:
:
value
>
{
}
;
namespace
detail
{
template
<
class
T
class
HashPolicy
class
AllocPolicy
>
class
HashTable
;
template
<
typename
T
>
class
HashTableEntry
{
private
:
using
NonConstT
=
typename
RemoveConst
<
T
>
:
:
Type
;
static
const
HashNumber
sFreeKey
=
0
;
static
const
HashNumber
sRemovedKey
=
1
;
static
const
HashNumber
sCollisionBit
=
1
;
HashNumber
mKeyHash
=
sFreeKey
;
alignas
(
NonConstT
)
unsigned
char
mValueData
[
sizeof
(
NonConstT
)
]
;
private
:
template
<
class
class
class
>
friend
class
HashTable
;
void
*
rawValuePtr
(
)
{
return
mValueData
;
}
static
bool
isLiveHash
(
HashNumber
hash
)
{
return
hash
>
sRemovedKey
;
}
HashTableEntry
(
const
HashTableEntry
&
)
=
delete
;
void
operator
=
(
const
HashTableEntry
&
)
=
delete
;
NonConstT
*
valuePtr
(
)
{
return
reinterpret_cast
<
NonConstT
*
>
(
rawValuePtr
(
)
)
;
}
void
destroyStoredT
(
)
{
NonConstT
*
ptr
=
valuePtr
(
)
;
ptr
-
>
~
T
(
)
;
MOZ_MAKE_MEM_UNDEFINED
(
ptr
sizeof
(
*
ptr
)
)
;
}
public
:
HashTableEntry
(
)
=
default
;
~
HashTableEntry
(
)
{
if
(
isLive
(
)
)
{
destroyStoredT
(
)
;
}
MOZ_MAKE_MEM_UNDEFINED
(
this
sizeof
(
*
this
)
)
;
}
void
destroy
(
)
{
MOZ_ASSERT
(
isLive
(
)
)
;
destroyStoredT
(
)
;
}
void
swap
(
HashTableEntry
*
aOther
)
{
if
(
this
=
=
aOther
)
{
return
;
}
MOZ_ASSERT
(
isLive
(
)
)
;
if
(
aOther
-
>
isLive
(
)
)
{
Swap
(
*
valuePtr
(
)
*
aOther
-
>
valuePtr
(
)
)
;
}
else
{
*
aOther
-
>
valuePtr
(
)
=
std
:
:
move
(
*
valuePtr
(
)
)
;
destroy
(
)
;
}
Swap
(
mKeyHash
aOther
-
>
mKeyHash
)
;
}
T
&
get
(
)
{
MOZ_ASSERT
(
isLive
(
)
)
;
return
*
valuePtr
(
)
;
}
NonConstT
&
getMutable
(
)
{
MOZ_ASSERT
(
isLive
(
)
)
;
return
*
valuePtr
(
)
;
}
bool
isFree
(
)
const
{
return
mKeyHash
=
=
sFreeKey
;
}
void
clearLive
(
)
{
MOZ_ASSERT
(
isLive
(
)
)
;
mKeyHash
=
sFreeKey
;
destroyStoredT
(
)
;
}
void
clear
(
)
{
if
(
isLive
(
)
)
{
destroyStoredT
(
)
;
}
MOZ_MAKE_MEM_UNDEFINED
(
this
sizeof
(
*
this
)
)
;
mKeyHash
=
sFreeKey
;
}
bool
isRemoved
(
)
const
{
return
mKeyHash
=
=
sRemovedKey
;
}
void
removeLive
(
)
{
MOZ_ASSERT
(
isLive
(
)
)
;
mKeyHash
=
sRemovedKey
;
destroyStoredT
(
)
;
}
bool
isLive
(
)
const
{
return
isLiveHash
(
mKeyHash
)
;
}
void
setCollision
(
)
{
MOZ_ASSERT
(
isLive
(
)
)
;
mKeyHash
|
=
sCollisionBit
;
}
void
unsetCollision
(
)
{
mKeyHash
&
=
~
sCollisionBit
;
}
bool
hasCollision
(
)
const
{
return
mKeyHash
&
sCollisionBit
;
}
bool
matchHash
(
HashNumber
hn
)
{
return
(
mKeyHash
&
~
sCollisionBit
)
=
=
hn
;
}
HashNumber
getKeyHash
(
)
const
{
return
mKeyHash
&
~
sCollisionBit
;
}
template
<
typename
.
.
.
Args
>
void
setLive
(
HashNumber
aHashNumber
Args
&
&
.
.
.
aArgs
)
{
MOZ_ASSERT
(
!
isLive
(
)
)
;
mKeyHash
=
aHashNumber
;
new
(
valuePtr
(
)
)
T
(
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
;
MOZ_ASSERT
(
isLive
(
)
)
;
}
}
;
template
<
class
T
class
HashPolicy
class
AllocPolicy
>
class
HashTable
:
private
AllocPolicy
{
friend
class
mozilla
:
:
ReentrancyGuard
;
using
NonConstT
=
typename
RemoveConst
<
T
>
:
:
Type
;
using
Key
=
typename
HashPolicy
:
:
KeyType
;
using
Lookup
=
typename
HashPolicy
:
:
Lookup
;
public
:
using
Entry
=
HashTableEntry
<
T
>
;
class
Ptr
{
friend
class
HashTable
;
Entry
*
mEntry
;
#
ifdef
DEBUG
const
HashTable
*
mTable
;
Generation
mGeneration
;
#
endif
protected
:
Ptr
(
Entry
&
aEntry
const
HashTable
&
aTable
)
:
mEntry
(
&
aEntry
)
#
ifdef
DEBUG
mTable
(
&
aTable
)
mGeneration
(
aTable
.
generation
(
)
)
#
endif
{
}
public
:
Ptr
(
)
:
mEntry
(
nullptr
)
#
ifdef
DEBUG
mTable
(
nullptr
)
mGeneration
(
0
)
#
endif
{
}
bool
isValid
(
)
const
{
return
!
!
mEntry
;
}
bool
found
(
)
const
{
if
(
!
isValid
(
)
)
{
return
false
;
}
#
ifdef
DEBUG
MOZ_ASSERT
(
mGeneration
=
=
mTable
-
>
generation
(
)
)
;
#
endif
return
mEntry
-
>
isLive
(
)
;
}
explicit
operator
bool
(
)
const
{
return
found
(
)
;
}
bool
operator
=
=
(
const
Ptr
&
aRhs
)
const
{
MOZ_ASSERT
(
found
(
)
&
&
aRhs
.
found
(
)
)
;
return
mEntry
=
=
aRhs
.
mEntry
;
}
bool
operator
!
=
(
const
Ptr
&
aRhs
)
const
{
#
ifdef
DEBUG
MOZ_ASSERT
(
mGeneration
=
=
mTable
-
>
generation
(
)
)
;
#
endif
return
!
(
*
this
=
=
aRhs
)
;
}
T
&
operator
*
(
)
const
{
#
ifdef
DEBUG
MOZ_ASSERT
(
found
(
)
)
;
MOZ_ASSERT
(
mGeneration
=
=
mTable
-
>
generation
(
)
)
;
#
endif
return
mEntry
-
>
get
(
)
;
}
T
*
operator
-
>
(
)
const
{
#
ifdef
DEBUG
MOZ_ASSERT
(
found
(
)
)
;
MOZ_ASSERT
(
mGeneration
=
=
mTable
-
>
generation
(
)
)
;
#
endif
return
&
mEntry
-
>
get
(
)
;
}
}
;
class
AddPtr
:
public
Ptr
{
friend
class
HashTable
;
HashNumber
mKeyHash
;
#
ifdef
DEBUG
uint64_t
mMutationCount
;
#
endif
AddPtr
(
Entry
&
aEntry
const
HashTable
&
aTable
HashNumber
aHashNumber
)
:
Ptr
(
aEntry
aTable
)
mKeyHash
(
aHashNumber
)
#
ifdef
DEBUG
mMutationCount
(
aTable
.
mMutationCount
)
#
endif
{
}
public
:
AddPtr
(
)
:
mKeyHash
(
0
)
{
}
}
;
class
Range
{
protected
:
friend
class
HashTable
;
Range
(
const
HashTable
&
aTable
Entry
*
aCur
Entry
*
aEnd
)
:
mCur
(
aCur
)
mEnd
(
aEnd
)
#
ifdef
DEBUG
mTable
(
aTable
)
mMutationCount
(
aTable
.
mMutationCount
)
mGeneration
(
aTable
.
generation
(
)
)
mValidEntry
(
true
)
#
endif
{
while
(
mCur
<
mEnd
&
&
!
mCur
-
>
isLive
(
)
)
{
+
+
mCur
;
}
}
Entry
*
mCur
;
Entry
*
mEnd
;
#
ifdef
DEBUG
const
HashTable
&
mTable
;
uint64_t
mMutationCount
;
Generation
mGeneration
;
bool
mValidEntry
;
#
endif
public
:
bool
empty
(
)
const
{
#
ifdef
DEBUG
MOZ_ASSERT
(
mGeneration
=
=
mTable
.
generation
(
)
)
;
MOZ_ASSERT
(
mMutationCount
=
=
mTable
.
mMutationCount
)
;
#
endif
return
mCur
=
=
mEnd
;
}
T
&
front
(
)
const
{
MOZ_ASSERT
(
!
empty
(
)
)
;
#
ifdef
DEBUG
MOZ_ASSERT
(
mValidEntry
)
;
MOZ_ASSERT
(
mGeneration
=
=
mTable
.
generation
(
)
)
;
MOZ_ASSERT
(
mMutationCount
=
=
mTable
.
mMutationCount
)
;
#
endif
return
mCur
-
>
get
(
)
;
}
void
popFront
(
)
{
MOZ_ASSERT
(
!
empty
(
)
)
;
#
ifdef
DEBUG
MOZ_ASSERT
(
mGeneration
=
=
mTable
.
generation
(
)
)
;
MOZ_ASSERT
(
mMutationCount
=
=
mTable
.
mMutationCount
)
;
#
endif
while
(
+
+
mCur
<
mEnd
&
&
!
mCur
-
>
isLive
(
)
)
{
continue
;
}
#
ifdef
DEBUG
mValidEntry
=
true
;
#
endif
}
}
;
class
Enum
:
public
Range
{
friend
class
HashTable
;
HashTable
&
mTable
;
bool
mRekeyed
;
bool
mRemoved
;
Enum
(
const
Enum
&
)
=
delete
;
void
operator
=
(
const
Enum
&
)
=
delete
;
public
:
template
<
class
Map
>
explicit
Enum
(
Map
&
map
)
:
Range
(
map
.
all
(
)
)
mTable
(
map
.
mImpl
)
mRekeyed
(
false
)
mRemoved
(
false
)
{
}
MOZ_IMPLICIT
Enum
(
Enum
&
&
aOther
)
:
Range
(
aOther
)
mTable
(
aOther
.
mTable
)
mRekeyed
(
aOther
.
mRekeyed
)
mRemoved
(
aOther
.
mRemoved
)
{
aOther
.
mRekeyed
=
false
;
aOther
.
mRemoved
=
false
;
}
void
removeFront
(
)
{
mTable
.
remove
(
*
this
-
>
mCur
)
;
mRemoved
=
true
;
#
ifdef
DEBUG
this
-
>
mValidEntry
=
false
;
this
-
>
mMutationCount
=
mTable
.
mMutationCount
;
#
endif
}
NonConstT
&
mutableFront
(
)
{
MOZ_ASSERT
(
!
this
-
>
empty
(
)
)
;
#
ifdef
DEBUG
MOZ_ASSERT
(
this
-
>
mValidEntry
)
;
MOZ_ASSERT
(
this
-
>
mGeneration
=
=
this
-
>
Range
:
:
mTable
.
generation
(
)
)
;
MOZ_ASSERT
(
this
-
>
mMutationCount
=
=
this
-
>
Range
:
:
mTable
.
mMutationCount
)
;
#
endif
return
this
-
>
mCur
-
>
getMutable
(
)
;
}
void
rekeyFront
(
const
Lookup
&
aLookup
const
Key
&
aKey
)
{
MOZ_ASSERT
(
&
aKey
!
=
&
HashPolicy
:
:
getKey
(
this
-
>
mCur
-
>
get
(
)
)
)
;
Ptr
p
(
*
this
-
>
mCur
mTable
)
;
mTable
.
rekeyWithoutRehash
(
p
aLookup
aKey
)
;
mRekeyed
=
true
;
#
ifdef
DEBUG
this
-
>
mValidEntry
=
false
;
this
-
>
mMutationCount
=
mTable
.
mMutationCount
;
#
endif
}
void
rekeyFront
(
const
Key
&
aKey
)
{
rekeyFront
(
aKey
aKey
)
;
}
~
Enum
(
)
{
if
(
mRekeyed
)
{
mTable
.
mGen
+
+
;
mTable
.
checkOverRemoved
(
)
;
}
if
(
mRemoved
)
{
mTable
.
compactIfUnderloaded
(
)
;
}
}
}
;
HashTable
(
HashTable
&
&
aRhs
)
:
AllocPolicy
(
aRhs
)
{
PodAssign
(
this
&
aRhs
)
;
aRhs
.
mTable
=
nullptr
;
}
void
operator
=
(
HashTable
&
&
aRhs
)
{
MOZ_ASSERT
(
this
!
=
&
aRhs
"
self
-
move
assignment
is
prohibited
"
)
;
if
(
mTable
)
{
destroyTable
(
*
this
mTable
capacity
(
)
)
;
}
PodAssign
(
this
&
aRhs
)
;
aRhs
.
mTable
=
nullptr
;
}
private
:
HashTable
(
const
HashTable
&
)
=
delete
;
void
operator
=
(
const
HashTable
&
)
=
delete
;
static
const
size_t
CAP_BITS
=
30
;
public
:
uint64_t
mGen
:
56
;
uint64_t
mHashShift
:
8
;
Entry
*
mTable
;
uint32_t
mEntryCount
;
uint32_t
mRemovedCount
;
#
ifdef
DEBUG
uint64_t
mMutationCount
;
mutable
bool
mEntered
;
mutable
struct
Stats
{
uint32_t
mSearches
;
uint32_t
mSteps
;
uint32_t
mHits
;
uint32_t
mMisses
;
uint32_t
mAddOverRemoved
;
uint32_t
mRemoves
;
uint32_t
mRemoveFrees
;
uint32_t
mGrows
;
uint32_t
mShrinks
;
uint32_t
mCompresses
;
uint32_t
mRehashes
;
}
mStats
;
#
define
METER
(
x
)
x
#
else
#
define
METER
(
x
)
#
endif
static
const
uint32_t
sMinCapacity
=
4
;
static
const
uint32_t
sMaxInit
=
1u
<
<
(
CAP_BITS
-
1
)
;
static
const
uint32_t
sMaxCapacity
=
1u
<
<
CAP_BITS
;
static
const
uint8_t
sAlphaDenominator
=
4
;
static
const
uint8_t
sMinAlphaNumerator
=
1
;
static
const
uint8_t
sMaxAlphaNumerator
=
3
;
static
const
HashNumber
sFreeKey
=
Entry
:
:
sFreeKey
;
static
const
HashNumber
sRemovedKey
=
Entry
:
:
sRemovedKey
;
static
const
HashNumber
sCollisionBit
=
Entry
:
:
sCollisionBit
;
void
setTableSizeLog2
(
uint32_t
aSizeLog2
)
{
mHashShift
=
kHashNumberBits
-
aSizeLog2
;
}
static
bool
isLiveHash
(
HashNumber
aHash
)
{
return
Entry
:
:
isLiveHash
(
aHash
)
;
}
static
HashNumber
prepareHash
(
const
Lookup
&
aLookup
)
{
HashNumber
keyHash
=
ScrambleHashCode
(
HashPolicy
:
:
hash
(
aLookup
)
)
;
if
(
!
isLiveHash
(
keyHash
)
)
{
keyHash
-
=
(
sRemovedKey
+
1
)
;
}
return
keyHash
&
~
sCollisionBit
;
}
enum
FailureBehavior
{
DontReportFailure
=
false
ReportFailure
=
true
}
;
static
Entry
*
createTable
(
AllocPolicy
&
aAllocPolicy
uint32_t
aCapacity
FailureBehavior
aReportFailure
=
ReportFailure
)
{
Entry
*
table
=
aReportFailure
?
aAllocPolicy
.
template
pod_malloc
<
Entry
>
(
aCapacity
)
:
aAllocPolicy
.
template
maybe_pod_malloc
<
Entry
>
(
aCapacity
)
;
if
(
table
)
{
for
(
uint32_t
i
=
0
;
i
<
aCapacity
;
i
+
+
)
{
new
(
&
table
[
i
]
)
Entry
(
)
;
}
}
return
table
;
}
static
Entry
*
maybeCreateTable
(
AllocPolicy
&
aAllocPolicy
uint32_t
aCapacity
)
{
Entry
*
table
=
aAllocPolicy
.
template
maybe_pod_malloc
<
Entry
>
(
aCapacity
)
;
if
(
table
)
{
for
(
uint32_t
i
=
0
;
i
<
aCapacity
;
i
+
+
)
{
new
(
&
table
[
i
]
)
Entry
(
)
;
}
}
return
table
;
}
static
void
destroyTable
(
AllocPolicy
&
aAllocPolicy
Entry
*
aOldTable
uint32_t
aCapacity
)
{
Entry
*
end
=
aOldTable
+
aCapacity
;
for
(
Entry
*
e
=
aOldTable
;
e
<
end
;
+
+
e
)
{
e
-
>
~
Entry
(
)
;
}
aAllocPolicy
.
free_
(
aOldTable
aCapacity
)
;
}
public
:
explicit
HashTable
(
AllocPolicy
aAllocPolicy
)
:
AllocPolicy
(
aAllocPolicy
)
mGen
(
0
)
mHashShift
(
kHashNumberBits
)
mTable
(
nullptr
)
mEntryCount
(
0
)
mRemovedCount
(
0
)
#
ifdef
DEBUG
mMutationCount
(
0
)
mEntered
(
false
)
#
endif
{
}
MOZ_MUST_USE
bool
init
(
uint32_t
aLen
)
{
MOZ_ASSERT
(
!
initialized
(
)
)
;
if
(
MOZ_UNLIKELY
(
aLen
>
sMaxInit
)
)
{
this
-
>
reportAllocOverflow
(
)
;
return
false
;
}
static_assert
(
(
sMaxInit
*
sAlphaDenominator
)
/
sAlphaDenominator
=
=
sMaxInit
"
multiplication
in
numerator
below
could
overflow
"
)
;
static_assert
(
sMaxInit
*
sAlphaDenominator
<
=
UINT32_MAX
-
sMaxAlphaNumerator
"
numerator
calculation
below
could
potentially
overflow
"
)
;
uint32_t
newCapacity
=
(
aLen
*
sAlphaDenominator
+
sMaxAlphaNumerator
-
1
)
/
sMaxAlphaNumerator
;
if
(
newCapacity
<
sMinCapacity
)
{
newCapacity
=
sMinCapacity
;
}
uint32_t
log2
=
mozilla
:
:
CeilingLog2
(
newCapacity
)
;
newCapacity
=
1u
<
<
log2
;
MOZ_ASSERT
(
newCapacity
>
=
aLen
)
;
MOZ_ASSERT
(
newCapacity
<
=
sMaxCapacity
)
;
mTable
=
createTable
(
*
this
newCapacity
)
;
if
(
!
mTable
)
{
return
false
;
}
setTableSizeLog2
(
log2
)
;
METER
(
memset
(
&
mStats
0
sizeof
(
mStats
)
)
)
;
return
true
;
}
bool
initialized
(
)
const
{
return
!
!
mTable
;
}
~
HashTable
(
)
{
if
(
mTable
)
{
destroyTable
(
*
this
mTable
capacity
(
)
)
;
}
}
private
:
HashNumber
hash1
(
HashNumber
aHash0
)
const
{
return
aHash0
>
>
mHashShift
;
}
struct
DoubleHash
{
HashNumber
mHash2
;
HashNumber
mSizeMask
;
}
;
DoubleHash
hash2
(
HashNumber
aCurKeyHash
)
const
{
uint32_t
sizeLog2
=
kHashNumberBits
-
mHashShift
;
DoubleHash
dh
=
{
(
(
aCurKeyHash
<
<
sizeLog2
)
>
>
mHashShift
)
|
1
(
HashNumber
(
1
)
<
<
sizeLog2
)
-
1
}
;
return
dh
;
}
static
HashNumber
applyDoubleHash
(
HashNumber
aHash1
const
DoubleHash
&
aDoubleHash
)
{
return
(
aHash1
-
aDoubleHash
.
mHash2
)
&
aDoubleHash
.
mSizeMask
;
}
bool
overloaded
(
)
{
static_assert
(
sMaxCapacity
<
=
UINT32_MAX
/
sMaxAlphaNumerator
"
multiplication
below
could
overflow
"
)
;
return
mEntryCount
+
mRemovedCount
>
=
capacity
(
)
*
sMaxAlphaNumerator
/
sAlphaDenominator
;
}
static
bool
wouldBeUnderloaded
(
uint32_t
aCapacity
uint32_t
aEntryCount
)
{
static_assert
(
sMaxCapacity
<
=
UINT32_MAX
/
sMinAlphaNumerator
"
multiplication
below
could
overflow
"
)
;
return
aCapacity
>
sMinCapacity
&
&
aEntryCount
<
=
aCapacity
*
sMinAlphaNumerator
/
sAlphaDenominator
;
}
bool
underloaded
(
)
{
return
wouldBeUnderloaded
(
capacity
(
)
mEntryCount
)
;
}
static
MOZ_ALWAYS_INLINE
bool
match
(
Entry
&
aEntry
const
Lookup
&
aLookup
)
{
return
HashPolicy
:
:
match
(
HashPolicy
:
:
getKey
(
aEntry
.
get
(
)
)
aLookup
)
;
}
MOZ_ALWAYS_INLINE
Entry
&
lookup
(
const
Lookup
&
aLookup
HashNumber
aKeyHash
uint32_t
aCollisionBit
)
const
{
MOZ_ASSERT
(
isLiveHash
(
aKeyHash
)
)
;
MOZ_ASSERT
(
!
(
aKeyHash
&
sCollisionBit
)
)
;
MOZ_ASSERT
(
aCollisionBit
=
=
0
|
|
aCollisionBit
=
=
sCollisionBit
)
;
MOZ_ASSERT
(
mTable
)
;
METER
(
mStats
.
mSearches
+
+
)
;
HashNumber
h1
=
hash1
(
aKeyHash
)
;
Entry
*
entry
=
&
mTable
[
h1
]
;
if
(
entry
-
>
isFree
(
)
)
{
METER
(
mStats
.
mMisses
+
+
)
;
return
*
entry
;
}
if
(
entry
-
>
matchHash
(
aKeyHash
)
&
&
match
(
*
entry
aLookup
)
)
{
METER
(
mStats
.
mHits
+
+
)
;
return
*
entry
;
}
DoubleHash
dh
=
hash2
(
aKeyHash
)
;
Entry
*
firstRemoved
=
nullptr
;
while
(
true
)
{
if
(
MOZ_UNLIKELY
(
entry
-
>
isRemoved
(
)
)
)
{
if
(
!
firstRemoved
)
{
firstRemoved
=
entry
;
}
}
else
{
if
(
aCollisionBit
=
=
sCollisionBit
)
{
entry
-
>
setCollision
(
)
;
}
}
METER
(
mStats
.
mSteps
+
+
)
;
h1
=
applyDoubleHash
(
h1
dh
)
;
entry
=
&
mTable
[
h1
]
;
if
(
entry
-
>
isFree
(
)
)
{
METER
(
mStats
.
mMisses
+
+
)
;
return
firstRemoved
?
*
firstRemoved
:
*
entry
;
}
if
(
entry
-
>
matchHash
(
aKeyHash
)
&
&
match
(
*
entry
aLookup
)
)
{
METER
(
mStats
.
mHits
+
+
)
;
return
*
entry
;
}
}
}
Entry
&
findFreeEntry
(
HashNumber
aKeyHash
)
{
MOZ_ASSERT
(
!
(
aKeyHash
&
sCollisionBit
)
)
;
MOZ_ASSERT
(
mTable
)
;
METER
(
mStats
.
mSearches
+
+
)
;
HashNumber
h1
=
hash1
(
aKeyHash
)
;
Entry
*
entry
=
&
mTable
[
h1
]
;
if
(
!
entry
-
>
isLive
(
)
)
{
METER
(
mStats
.
mMisses
+
+
)
;
return
*
entry
;
}
DoubleHash
dh
=
hash2
(
aKeyHash
)
;
while
(
true
)
{
MOZ_ASSERT
(
!
entry
-
>
isRemoved
(
)
)
;
entry
-
>
setCollision
(
)
;
METER
(
mStats
.
mSteps
+
+
)
;
h1
=
applyDoubleHash
(
h1
dh
)
;
entry
=
&
mTable
[
h1
]
;
if
(
!
entry
-
>
isLive
(
)
)
{
METER
(
mStats
.
mMisses
+
+
)
;
return
*
entry
;
}
}
}
enum
RebuildStatus
{
NotOverloaded
Rehashed
RehashFailed
}
;
RebuildStatus
changeTableSize
(
int
aDeltaLog2
FailureBehavior
aReportFailure
=
ReportFailure
)
{
Entry
*
oldTable
=
mTable
;
uint32_t
oldCap
=
capacity
(
)
;
uint32_t
newLog2
=
kHashNumberBits
-
mHashShift
+
aDeltaLog2
;
uint32_t
newCapacity
=
1u
<
<
newLog2
;
if
(
MOZ_UNLIKELY
(
newCapacity
>
sMaxCapacity
)
)
{
if
(
aReportFailure
)
{
this
-
>
reportAllocOverflow
(
)
;
}
return
RehashFailed
;
}
Entry
*
newTable
=
createTable
(
*
this
newCapacity
aReportFailure
)
;
if
(
!
newTable
)
{
return
RehashFailed
;
}
setTableSizeLog2
(
newLog2
)
;
mRemovedCount
=
0
;
mGen
+
+
;
mTable
=
newTable
;
Entry
*
end
=
oldTable
+
oldCap
;
for
(
Entry
*
src
=
oldTable
;
src
<
end
;
+
+
src
)
{
if
(
src
-
>
isLive
(
)
)
{
HashNumber
hn
=
src
-
>
getKeyHash
(
)
;
findFreeEntry
(
hn
)
.
setLive
(
hn
std
:
:
move
(
const_cast
<
typename
Entry
:
:
NonConstT
&
>
(
src
-
>
get
(
)
)
)
)
;
}
src
-
>
~
Entry
(
)
;
}
this
-
>
free_
(
oldTable
oldCap
)
;
return
Rehashed
;
}
bool
shouldCompressTable
(
)
{
return
mRemovedCount
>
=
(
capacity
(
)
>
>
2
)
;
}
RebuildStatus
checkOverloaded
(
FailureBehavior
aReportFailure
=
ReportFailure
)
{
if
(
!
overloaded
(
)
)
{
return
NotOverloaded
;
}
int
deltaLog2
;
if
(
shouldCompressTable
(
)
)
{
METER
(
mStats
.
mCompresses
+
+
)
;
deltaLog2
=
0
;
}
else
{
METER
(
mStats
.
mGrows
+
+
)
;
deltaLog2
=
1
;
}
return
changeTableSize
(
deltaLog2
aReportFailure
)
;
}
void
checkOverRemoved
(
)
{
if
(
overloaded
(
)
)
{
if
(
checkOverloaded
(
DontReportFailure
)
=
=
RehashFailed
)
{
rehashTableInPlace
(
)
;
}
}
}
void
remove
(
Entry
&
aEntry
)
{
MOZ_ASSERT
(
mTable
)
;
METER
(
mStats
.
mRemoves
+
+
)
;
if
(
aEntry
.
hasCollision
(
)
)
{
aEntry
.
removeLive
(
)
;
mRemovedCount
+
+
;
}
else
{
METER
(
mStats
.
mRemoveFrees
+
+
)
;
aEntry
.
clearLive
(
)
;
}
mEntryCount
-
-
;
#
ifdef
DEBUG
mMutationCount
+
+
;
#
endif
}
void
checkUnderloaded
(
)
{
if
(
underloaded
(
)
)
{
METER
(
mStats
.
mShrinks
+
+
)
;
(
void
)
changeTableSize
(
-
1
DontReportFailure
)
;
}
}
void
compactIfUnderloaded
(
)
{
int32_t
resizeLog2
=
0
;
uint32_t
newCapacity
=
capacity
(
)
;
while
(
wouldBeUnderloaded
(
newCapacity
mEntryCount
)
)
{
newCapacity
=
newCapacity
>
>
1
;
resizeLog2
-
-
;
}
if
(
resizeLog2
!
=
0
)
{
(
void
)
changeTableSize
(
resizeLog2
DontReportFailure
)
;
}
}
void
rehashTableInPlace
(
)
{
METER
(
mStats
.
mRehashes
+
+
)
;
mRemovedCount
=
0
;
mGen
+
+
;
for
(
size_t
i
=
0
;
i
<
capacity
(
)
;
+
+
i
)
{
mTable
[
i
]
.
unsetCollision
(
)
;
}
for
(
size_t
i
=
0
;
i
<
capacity
(
)
;
)
{
Entry
*
src
=
&
mTable
[
i
]
;
if
(
!
src
-
>
isLive
(
)
|
|
src
-
>
hasCollision
(
)
)
{
+
+
i
;
continue
;
}
HashNumber
keyHash
=
src
-
>
getKeyHash
(
)
;
HashNumber
h1
=
hash1
(
keyHash
)
;
DoubleHash
dh
=
hash2
(
keyHash
)
;
Entry
*
tgt
=
&
mTable
[
h1
]
;
while
(
true
)
{
if
(
!
tgt
-
>
hasCollision
(
)
)
{
src
-
>
swap
(
tgt
)
;
tgt
-
>
setCollision
(
)
;
break
;
}
h1
=
applyDoubleHash
(
h1
dh
)
;
tgt
=
&
mTable
[
h1
]
;
}
}
}
template
<
typename
.
.
.
Args
>
void
putNewInfallibleInternal
(
const
Lookup
&
aLookup
Args
&
&
.
.
.
aArgs
)
{
MOZ_ASSERT
(
mTable
)
;
HashNumber
keyHash
=
prepareHash
(
aLookup
)
;
Entry
*
entry
=
&
findFreeEntry
(
keyHash
)
;
MOZ_ASSERT
(
entry
)
;
if
(
entry
-
>
isRemoved
(
)
)
{
METER
(
mStats
.
mAddOverRemoved
+
+
)
;
mRemovedCount
-
-
;
keyHash
|
=
sCollisionBit
;
}
entry
-
>
setLive
(
keyHash
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
;
mEntryCount
+
+
;
#
ifdef
DEBUG
mMutationCount
+
+
;
#
endif
}
public
:
void
clear
(
)
{
Entry
*
end
=
mTable
+
capacity
(
)
;
for
(
Entry
*
e
=
mTable
;
e
<
end
;
+
+
e
)
{
e
-
>
clear
(
)
;
}
mRemovedCount
=
0
;
mEntryCount
=
0
;
#
ifdef
DEBUG
mMutationCount
+
+
;
#
endif
}
void
clearAndShrink
(
)
{
clear
(
)
;
compactIfUnderloaded
(
)
;
}
void
finish
(
)
{
#
ifdef
DEBUG
MOZ_ASSERT
(
!
mEntered
)
;
#
endif
if
(
!
mTable
)
{
return
;
}
destroyTable
(
*
this
mTable
capacity
(
)
)
;
mTable
=
nullptr
;
mGen
+
+
;
mEntryCount
=
0
;
mRemovedCount
=
0
;
#
ifdef
DEBUG
mMutationCount
+
+
;
#
endif
}
Range
all
(
)
const
{
MOZ_ASSERT
(
mTable
)
;
return
Range
(
*
this
mTable
mTable
+
capacity
(
)
)
;
}
bool
empty
(
)
const
{
MOZ_ASSERT
(
mTable
)
;
return
!
mEntryCount
;
}
uint32_t
count
(
)
const
{
MOZ_ASSERT
(
mTable
)
;
return
mEntryCount
;
}
uint32_t
capacity
(
)
const
{
MOZ_ASSERT
(
mTable
)
;
return
1u
<
<
(
kHashNumberBits
-
mHashShift
)
;
}
Generation
generation
(
)
const
{
MOZ_ASSERT
(
mTable
)
;
return
Generation
(
mGen
)
;
}
size_t
shallowSizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
mTable
)
;
}
size_t
shallowSizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
this
)
+
shallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
}
MOZ_ALWAYS_INLINE
Ptr
lookup
(
const
Lookup
&
aLookup
)
const
{
ReentrancyGuard
g
(
*
this
)
;
if
(
!
HasHash
<
HashPolicy
>
(
aLookup
)
)
{
return
Ptr
(
)
;
}
HashNumber
keyHash
=
prepareHash
(
aLookup
)
;
return
Ptr
(
lookup
(
aLookup
keyHash
0
)
*
this
)
;
}
MOZ_ALWAYS_INLINE
Ptr
readonlyThreadsafeLookup
(
const
Lookup
&
aLookup
)
const
{
if
(
!
HasHash
<
HashPolicy
>
(
aLookup
)
)
{
return
Ptr
(
)
;
}
HashNumber
keyHash
=
prepareHash
(
aLookup
)
;
return
Ptr
(
lookup
(
aLookup
keyHash
0
)
*
this
)
;
}
MOZ_ALWAYS_INLINE
AddPtr
lookupForAdd
(
const
Lookup
&
aLookup
)
const
{
ReentrancyGuard
g
(
*
this
)
;
if
(
!
EnsureHash
<
HashPolicy
>
(
aLookup
)
)
{
return
AddPtr
(
)
;
}
HashNumber
keyHash
=
prepareHash
(
aLookup
)
;
return
AddPtr
(
lookup
(
aLookup
keyHash
sCollisionBit
)
*
this
keyHash
)
;
}
template
<
typename
.
.
.
Args
>
MOZ_MUST_USE
bool
add
(
AddPtr
&
aPtr
Args
&
&
.
.
.
aArgs
)
{
ReentrancyGuard
g
(
*
this
)
;
MOZ_ASSERT
(
mTable
)
;
MOZ_ASSERT_IF
(
aPtr
.
isValid
(
)
aPtr
.
mTable
=
=
this
)
;
MOZ_ASSERT
(
!
aPtr
.
found
(
)
)
;
MOZ_ASSERT
(
!
(
aPtr
.
mKeyHash
&
sCollisionBit
)
)
;
if
(
!
aPtr
.
isValid
(
)
)
{
return
false
;
}
MOZ_ASSERT
(
aPtr
.
mGeneration
=
=
generation
(
)
)
;
#
ifdef
DEBUG
MOZ_ASSERT
(
aPtr
.
mMutationCount
=
=
mMutationCount
)
;
#
endif
if
(
aPtr
.
mEntry
-
>
isRemoved
(
)
)
{
if
(
!
this
-
>
checkSimulatedOOM
(
)
)
{
return
false
;
}
METER
(
mStats
.
mAddOverRemoved
+
+
)
;
mRemovedCount
-
-
;
aPtr
.
mKeyHash
|
=
sCollisionBit
;
}
else
{
RebuildStatus
status
=
checkOverloaded
(
)
;
if
(
status
=
=
RehashFailed
)
{
return
false
;
}
if
(
status
=
=
NotOverloaded
&
&
!
this
-
>
checkSimulatedOOM
(
)
)
{
return
false
;
}
if
(
status
=
=
Rehashed
)
{
aPtr
.
mEntry
=
&
findFreeEntry
(
aPtr
.
mKeyHash
)
;
}
}
aPtr
.
mEntry
-
>
setLive
(
aPtr
.
mKeyHash
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
;
mEntryCount
+
+
;
#
ifdef
DEBUG
mMutationCount
+
+
;
aPtr
.
mGeneration
=
generation
(
)
;
aPtr
.
mMutationCount
=
mMutationCount
;
#
endif
return
true
;
}
template
<
typename
.
.
.
Args
>
void
putNewInfallible
(
const
Lookup
&
aLookup
Args
&
&
.
.
.
aArgs
)
{
MOZ_ASSERT
(
!
lookup
(
aLookup
)
.
found
(
)
)
;
ReentrancyGuard
g
(
*
this
)
;
putNewInfallibleInternal
(
aLookup
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
;
}
template
<
typename
.
.
.
Args
>
MOZ_MUST_USE
bool
putNew
(
const
Lookup
&
aLookup
Args
&
&
.
.
.
aArgs
)
{
if
(
!
this
-
>
checkSimulatedOOM
(
)
)
{
return
false
;
}
if
(
!
EnsureHash
<
HashPolicy
>
(
aLookup
)
)
{
return
false
;
}
if
(
checkOverloaded
(
)
=
=
RehashFailed
)
{
return
false
;
}
putNewInfallible
(
aLookup
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
;
return
true
;
}
template
<
typename
.
.
.
Args
>
MOZ_MUST_USE
bool
relookupOrAdd
(
AddPtr
&
aPtr
const
Lookup
&
aLookup
Args
&
&
.
.
.
aArgs
)
{
if
(
!
aPtr
.
isValid
(
)
)
{
return
false
;
}
#
ifdef
DEBUG
aPtr
.
mGeneration
=
generation
(
)
;
aPtr
.
mMutationCount
=
mMutationCount
;
#
endif
{
ReentrancyGuard
g
(
*
this
)
;
MOZ_ASSERT
(
prepareHash
(
aLookup
)
=
=
aPtr
.
mKeyHash
)
;
aPtr
.
mEntry
=
&
lookup
(
aLookup
aPtr
.
mKeyHash
sCollisionBit
)
;
}
return
aPtr
.
found
(
)
|
|
add
(
aPtr
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
;
}
void
remove
(
Ptr
aPtr
)
{
MOZ_ASSERT
(
mTable
)
;
ReentrancyGuard
g
(
*
this
)
;
MOZ_ASSERT
(
aPtr
.
found
(
)
)
;
MOZ_ASSERT
(
aPtr
.
mGeneration
=
=
generation
(
)
)
;
remove
(
*
aPtr
.
mEntry
)
;
checkUnderloaded
(
)
;
}
void
rekeyWithoutRehash
(
Ptr
aPtr
const
Lookup
&
aLookup
const
Key
&
aKey
)
{
MOZ_ASSERT
(
mTable
)
;
ReentrancyGuard
g
(
*
this
)
;
MOZ_ASSERT
(
aPtr
.
found
(
)
)
;
MOZ_ASSERT
(
aPtr
.
mGeneration
=
=
generation
(
)
)
;
typename
HashTableEntry
<
T
>
:
:
NonConstT
t
(
std
:
:
move
(
*
aPtr
)
)
;
HashPolicy
:
:
setKey
(
t
const_cast
<
Key
&
>
(
aKey
)
)
;
remove
(
*
aPtr
.
mEntry
)
;
putNewInfallibleInternal
(
aLookup
std
:
:
move
(
t
)
)
;
}
void
rekeyAndMaybeRehash
(
Ptr
aPtr
const
Lookup
&
aLookup
const
Key
&
aKey
)
{
rekeyWithoutRehash
(
aPtr
aLookup
aKey
)
;
checkOverRemoved
(
)
;
}
#
undef
METER
}
;
}
}
#
endif
