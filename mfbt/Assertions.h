#
ifndef
mozilla_Assertions_h
#
define
mozilla_Assertions_h
#
if
defined
(
MOZILLA_INTERNAL_API
)
&
&
defined
(
__cplusplus
)
#
define
MOZ_DUMP_ASSERTION_STACK
#
endif
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Compiler
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
MacroArgs
.
h
"
#
include
"
mozilla
/
StaticAnalysisFunctions
.
h
"
#
include
"
mozilla
/
Types
.
h
"
#
ifdef
MOZ_DUMP_ASSERTION_STACK
#
include
"
nsTraceRefcnt
.
h
"
#
endif
MOZ_BEGIN_EXTERN_C
extern
MFBT_DATA
const
char
*
gMozCrashReason
;
MOZ_END_EXTERN_C
#
if
defined
(
MOZ_HAS_MOZGLUE
)
|
|
defined
(
MOZILLA_INTERNAL_API
)
static
inline
void
AnnotateMozCrashReason
(
const
char
*
reason
)
{
gMozCrashReason
=
reason
;
}
#
define
MOZ_CRASH_ANNOTATE
(
.
.
.
)
AnnotateMozCrashReason
(
__VA_ARGS__
)
#
else
#
define
MOZ_CRASH_ANNOTATE
(
.
.
.
)
\
do
{
/
*
nothing
*
/
\
}
while
(
false
)
#
endif
#
include
<
stddef
.
h
>
#
include
<
stdio
.
h
>
#
include
<
stdlib
.
h
>
#
ifdef
_MSC_VER
MOZ_BEGIN_EXTERN_C
__declspec
(
dllimport
)
int
__stdcall
TerminateProcess
(
void
*
hProcess
unsigned
int
uExitCode
)
;
__declspec
(
dllimport
)
void
*
__stdcall
GetCurrentProcess
(
void
)
;
MOZ_END_EXTERN_C
#
else
#
include
<
signal
.
h
>
#
endif
#
ifdef
ANDROID
#
include
<
android
/
log
.
h
>
#
endif
#
ifndef
__cplusplus
#
if
defined
(
__GNUC__
)
#
define
MOZ_STATIC_ASSERT_UNUSED_ATTRIBUTE
__attribute__
(
(
unused
)
)
#
else
#
define
MOZ_STATIC_ASSERT_UNUSED_ATTRIBUTE
#
endif
#
define
MOZ_STATIC_ASSERT_GLUE1
(
x
y
)
x
#
#
y
#
define
MOZ_STATIC_ASSERT_GLUE
(
x
y
)
MOZ_STATIC_ASSERT_GLUE1
(
x
y
)
#
if
defined
(
__SUNPRO_CC
)
#
define
MOZ_STATIC_ASSERT
(
cond
reason
)
\
extern
char
MOZ_STATIC_ASSERT_GLUE
(
moz_static_assert
\
__LINE__
)
[
(
cond
)
?
1
:
-
1
]
#
elif
defined
(
__COUNTER__
)
#
define
MOZ_STATIC_ASSERT
(
cond
reason
)
\
typedef
int
MOZ_STATIC_ASSERT_GLUE
(
\
moz_static_assert
\
__COUNTER__
)
[
(
cond
)
?
1
:
-
1
]
MOZ_STATIC_ASSERT_UNUSED_ATTRIBUTE
#
else
#
define
MOZ_STATIC_ASSERT
(
cond
reason
)
\
extern
void
MOZ_STATIC_ASSERT_GLUE
(
moz_static_assert
__LINE__
)
(
\
int
arg
[
(
cond
)
?
1
:
-
1
]
)
MOZ_STATIC_ASSERT_UNUSED_ATTRIBUTE
#
endif
#
define
MOZ_STATIC_ASSERT_IF
(
cond
expr
reason
)
\
MOZ_STATIC_ASSERT
(
!
(
cond
)
|
|
(
expr
)
reason
)
#
else
#
define
MOZ_STATIC_ASSERT_IF
(
cond
expr
reason
)
\
static_assert
(
!
(
cond
)
|
|
(
expr
)
reason
)
#
endif
MOZ_BEGIN_EXTERN_C
MOZ_MAYBE_UNUSED
static
MOZ_COLD
MOZ_NEVER_INLINE
void
MOZ_ReportAssertionFailure
(
const
char
*
aStr
const
char
*
aFilename
int
aLine
)
MOZ_PRETEND_NORETURN_FOR_STATIC_ANALYSIS
{
#
ifdef
ANDROID
__android_log_print
(
ANDROID_LOG_FATAL
"
MOZ_Assert
"
"
Assertion
failure
:
%
s
at
%
s
:
%
d
\
n
"
aStr
aFilename
aLine
)
;
#
else
fprintf
(
stderr
"
Assertion
failure
:
%
s
at
%
s
:
%
d
\
n
"
aStr
aFilename
aLine
)
;
#
if
defined
(
MOZ_DUMP_ASSERTION_STACK
)
nsTraceRefcnt
:
:
WalkTheStack
(
stderr
)
;
#
endif
fflush
(
stderr
)
;
#
endif
}
MOZ_MAYBE_UNUSED
static
MOZ_COLD
MOZ_NEVER_INLINE
void
MOZ_ReportCrash
(
const
char
*
aStr
const
char
*
aFilename
int
aLine
)
MOZ_PRETEND_NORETURN_FOR_STATIC_ANALYSIS
{
#
ifdef
ANDROID
__android_log_print
(
ANDROID_LOG_FATAL
"
MOZ_CRASH
"
"
Hit
MOZ_CRASH
(
%
s
)
at
%
s
:
%
d
\
n
"
aStr
aFilename
aLine
)
;
#
else
fprintf
(
stderr
"
Hit
MOZ_CRASH
(
%
s
)
at
%
s
:
%
d
\
n
"
aStr
aFilename
aLine
)
;
#
if
defined
(
MOZ_DUMP_ASSERTION_STACK
)
nsTraceRefcnt
:
:
WalkTheStack
(
stderr
)
;
#
endif
fflush
(
stderr
)
;
#
endif
}
#
if
defined
(
_MSC_VER
)
MOZ_MAYBE_UNUSED
static
MOZ_COLD
MOZ_NORETURN
MOZ_NEVER_INLINE
void
MOZ_NoReturn
(
int
aLine
)
{
*
(
(
volatile
int
*
)
NULL
)
=
aLine
;
TerminateProcess
(
GetCurrentProcess
(
)
3
)
;
}
#
define
MOZ_REALLY_CRASH
(
line
)
\
do
{
\
__debugbreak
(
)
;
\
MOZ_NoReturn
(
line
)
;
\
}
while
(
false
)
#
else
#
ifdef
MOZ_UBSAN
#
define
MOZ_CRASH_WRITE_ADDR
0x1
#
else
#
define
MOZ_CRASH_WRITE_ADDR
NULL
#
endif
#
ifdef
__cplusplus
#
define
MOZ_REALLY_CRASH
(
line
)
\
do
{
\
*
(
(
volatile
int
*
)
MOZ_CRASH_WRITE_ADDR
)
=
line
;
\
:
:
abort
(
)
;
\
}
while
(
false
)
#
else
#
define
MOZ_REALLY_CRASH
(
line
)
\
do
{
\
*
(
(
volatile
int
*
)
MOZ_CRASH_WRITE_ADDR
)
=
line
;
\
abort
(
)
;
\
}
while
(
false
)
#
endif
#
endif
#
ifndef
DEBUG
#
define
MOZ_CRASH
(
.
.
.
)
\
do
{
\
MOZ_CRASH_ANNOTATE
(
"
MOZ_CRASH
(
"
__VA_ARGS__
"
)
"
)
;
\
MOZ_REALLY_CRASH
(
__LINE__
)
;
\
}
while
(
false
)
#
else
#
define
MOZ_CRASH
(
.
.
.
)
\
do
{
\
MOZ_ReportCrash
(
"
"
__VA_ARGS__
__FILE__
__LINE__
)
;
\
MOZ_CRASH_ANNOTATE
(
"
MOZ_CRASH
(
"
__VA_ARGS__
"
)
"
)
;
\
MOZ_REALLY_CRASH
(
__LINE__
)
;
\
}
while
(
false
)
#
endif
static
inline
MOZ_COLD
MOZ_NORETURN
void
MOZ_Crash
(
const
char
*
aFilename
int
aLine
const
char
*
aReason
)
{
#
ifdef
DEBUG
MOZ_ReportCrash
(
aReason
aFilename
aLine
)
;
#
endif
MOZ_CRASH_ANNOTATE
(
aReason
)
;
MOZ_REALLY_CRASH
(
aLine
)
;
}
#
define
MOZ_CRASH_UNSAFE
(
reason
)
MOZ_Crash
(
__FILE__
__LINE__
reason
)
static
const
size_t
sPrintfMaxArgs
=
4
;
static
const
size_t
sPrintfCrashReasonSize
=
1024
;
#
ifndef
DEBUG
MFBT_API
MOZ_COLD
MOZ_NORETURN
MOZ_NEVER_INLINE
MOZ_FORMAT_PRINTF
(
2
3
)
void
MOZ_CrashPrintf
(
int
aLine
const
char
*
aFormat
.
.
.
)
;
#
define
MOZ_CALL_CRASH_PRINTF
(
format
.
.
.
)
\
MOZ_CrashPrintf
(
__LINE__
format
__VA_ARGS__
)
#
else
MFBT_API
MOZ_COLD
MOZ_NORETURN
MOZ_NEVER_INLINE
MOZ_FORMAT_PRINTF
(
3
4
)
void
MOZ_CrashPrintf
(
const
char
*
aFilename
int
aLine
const
char
*
aFormat
.
.
.
)
;
#
define
MOZ_CALL_CRASH_PRINTF
(
format
.
.
.
)
\
MOZ_CrashPrintf
(
__FILE__
__LINE__
format
__VA_ARGS__
)
#
endif
#
define
MOZ_CRASH_UNSAFE_PRINTF
(
format
.
.
.
)
\
do
{
\
static_assert
(
MOZ_ARG_COUNT
(
__VA_ARGS__
)
>
0
\
"
Did
you
forget
arguments
to
MOZ_CRASH_UNSAFE_PRINTF
?
"
\
"
Or
maybe
you
want
MOZ_CRASH
instead
?
"
)
;
\
static_assert
(
MOZ_ARG_COUNT
(
__VA_ARGS__
)
<
=
sPrintfMaxArgs
\
"
Only
up
to
4
additional
arguments
are
allowed
!
"
)
;
\
static_assert
(
sizeof
(
format
)
<
=
sPrintfCrashReasonSize
\
"
The
supplied
format
string
is
too
long
!
"
)
;
\
MOZ_CALL_CRASH_PRINTF
(
"
"
format
__VA_ARGS__
)
;
\
}
while
(
false
)
MOZ_END_EXTERN_C
#
ifdef
__cplusplus
#
include
"
mozilla
/
TypeTraits
.
h
"
namespace
mozilla
{
namespace
detail
{
template
<
typename
T
>
struct
AssertionConditionType
{
typedef
typename
RemoveReference
<
T
>
:
:
Type
ValueT
;
static_assert
(
!
IsArray
<
ValueT
>
:
:
value
"
Expected
boolean
assertion
condition
got
an
array
or
a
"
"
string
!
"
)
;
static_assert
(
!
IsFunction
<
ValueT
>
:
:
value
"
Expected
boolean
assertion
condition
got
a
function
!
Did
"
"
you
intend
to
call
that
function
?
"
)
;
static_assert
(
!
IsFloatingPoint
<
ValueT
>
:
:
value
"
It
'
s
often
a
bad
idea
to
assert
that
a
floating
-
point
number
"
"
is
nonzero
because
such
assertions
tend
to
intermittently
"
"
fail
.
Shouldn
'
t
your
code
gracefully
handle
this
case
instead
"
"
of
asserting
?
Anyway
if
you
really
want
to
do
that
write
an
"
"
explicit
boolean
condition
like
!
!
x
or
x
!
=
0
.
"
)
;
static
const
bool
isValid
=
true
;
}
;
}
}
#
define
MOZ_VALIDATE_ASSERT_CONDITION_TYPE
(
x
)
\
static_assert
(
\
mozilla
:
:
detail
:
:
AssertionConditionType
<
decltype
(
x
)
>
:
:
isValid
\
"
invalid
assertion
condition
"
)
#
else
#
define
MOZ_VALIDATE_ASSERT_CONDITION_TYPE
(
x
)
#
endif
#
if
defined
(
DEBUG
)
|
|
defined
(
MOZ_ASAN
)
#
define
MOZ_REPORT_ASSERTION_FAILURE
(
.
.
.
)
\
MOZ_ReportAssertionFailure
(
__VA_ARGS__
)
#
else
#
define
MOZ_REPORT_ASSERTION_FAILURE
(
.
.
.
)
\
do
{
/
*
nothing
*
/
\
}
while
(
false
)
#
endif
#
define
MOZ_ASSERT_HELPER1
(
expr
)
\
do
{
\
MOZ_VALIDATE_ASSERT_CONDITION_TYPE
(
expr
)
;
\
if
(
MOZ_UNLIKELY
(
!
MOZ_CHECK_ASSERT_ASSIGNMENT
(
expr
)
)
)
{
\
MOZ_REPORT_ASSERTION_FAILURE
(
#
expr
__FILE__
__LINE__
)
;
\
MOZ_CRASH_ANNOTATE
(
"
MOZ_RELEASE_ASSERT
(
"
#
expr
"
)
"
)
;
\
MOZ_REALLY_CRASH
(
__LINE__
)
;
\
}
\
}
while
(
false
)
#
define
MOZ_ASSERT_HELPER2
(
expr
explain
)
\
do
{
\
MOZ_VALIDATE_ASSERT_CONDITION_TYPE
(
expr
)
;
\
if
(
MOZ_UNLIKELY
(
!
MOZ_CHECK_ASSERT_ASSIGNMENT
(
expr
)
)
)
{
\
MOZ_REPORT_ASSERTION_FAILURE
(
#
expr
"
(
"
explain
"
)
"
__FILE__
\
__LINE__
)
;
\
MOZ_CRASH_ANNOTATE
(
"
MOZ_RELEASE_ASSERT
(
"
#
expr
"
)
(
"
explain
"
)
"
)
;
\
MOZ_REALLY_CRASH
(
__LINE__
)
;
\
}
\
}
while
(
false
)
#
define
MOZ_RELEASE_ASSERT_GLUE
(
a
b
)
a
b
#
define
MOZ_RELEASE_ASSERT
(
.
.
.
)
\
MOZ_RELEASE_ASSERT_GLUE
(
\
MOZ_PASTE_PREFIX_AND_ARG_COUNT
(
MOZ_ASSERT_HELPER
__VA_ARGS__
)
\
(
__VA_ARGS__
)
)
#
ifdef
DEBUG
#
define
MOZ_ASSERT
(
.
.
.
)
MOZ_RELEASE_ASSERT
(
__VA_ARGS__
)
#
else
#
define
MOZ_ASSERT
(
.
.
.
)
\
do
{
\
}
while
(
false
)
#
endif
#
if
defined
(
NIGHTLY_BUILD
)
|
|
defined
(
MOZ_DEV_EDITION
)
#
define
MOZ_DIAGNOSTIC_ASSERT
MOZ_RELEASE_ASSERT
#
define
MOZ_DIAGNOSTIC_ASSERT_ENABLED
1
#
else
#
define
MOZ_DIAGNOSTIC_ASSERT
MOZ_ASSERT
#
ifdef
DEBUG
#
define
MOZ_DIAGNOSTIC_ASSERT_ENABLED
1
#
endif
#
endif
#
ifdef
DEBUG
#
define
MOZ_ASSERT_IF
(
cond
expr
)
\
do
{
\
if
(
cond
)
{
\
MOZ_ASSERT
(
expr
)
;
\
}
\
}
while
(
false
)
#
else
#
define
MOZ_ASSERT_IF
(
cond
expr
)
\
do
{
\
}
while
(
false
)
#
endif
#
if
defined
(
__clang__
)
|
|
defined
(
__GNUC__
)
#
define
MOZ_ASSUME_UNREACHABLE_MARKER
(
)
__builtin_unreachable
(
)
#
elif
defined
(
_MSC_VER
)
#
define
MOZ_ASSUME_UNREACHABLE_MARKER
(
)
__assume
(
0
)
#
else
#
ifdef
__cplusplus
#
define
MOZ_ASSUME_UNREACHABLE_MARKER
(
)
:
:
abort
(
)
#
else
#
define
MOZ_ASSUME_UNREACHABLE_MARKER
(
)
abort
(
)
#
endif
#
endif
#
define
MOZ_ASSERT_UNREACHABLE
(
reason
)
\
MOZ_ASSERT
(
false
"
MOZ_ASSERT_UNREACHABLE
:
"
reason
)
#
define
MOZ_MAKE_COMPILER_ASSUME_IS_UNREACHABLE
(
reason
)
\
do
{
\
MOZ_ASSERT_UNREACHABLE
(
reason
)
;
\
MOZ_ASSUME_UNREACHABLE_MARKER
(
)
;
\
}
while
(
false
)
#
ifdef
DEBUG
#
define
MOZ_FALLTHROUGH_ASSERT
(
.
.
.
)
\
MOZ_CRASH
(
"
MOZ_FALLTHROUGH_ASSERT
:
"
__VA_ARGS__
)
#
else
#
define
MOZ_FALLTHROUGH_ASSERT
(
.
.
.
)
MOZ_FALLTHROUGH
#
endif
#
ifdef
DEBUG
#
define
MOZ_ALWAYS_TRUE
(
expr
)
\
do
{
\
if
(
(
expr
)
)
{
\
/
*
Do
nothing
.
*
/
\
}
else
{
\
MOZ_ASSERT
(
false
#
expr
)
;
\
}
\
}
while
(
false
)
#
define
MOZ_ALWAYS_FALSE
(
expr
)
\
do
{
\
if
(
(
expr
)
)
{
\
MOZ_ASSERT
(
false
#
expr
)
;
\
}
else
{
\
/
*
Do
nothing
.
*
/
\
}
\
}
while
(
false
)
#
define
MOZ_ALWAYS_OK
(
expr
)
MOZ_ASSERT
(
(
expr
)
.
isOk
(
)
)
#
define
MOZ_ALWAYS_ERR
(
expr
)
MOZ_ASSERT
(
(
expr
)
.
isErr
(
)
)
#
else
#
define
MOZ_ALWAYS_TRUE
(
expr
)
\
do
{
\
if
(
(
expr
)
)
{
\
/
*
Silence
MOZ_MUST_USE
.
*
/
\
}
\
}
while
(
false
)
#
define
MOZ_ALWAYS_FALSE
(
expr
)
\
do
{
\
if
(
(
expr
)
)
{
\
/
*
Silence
MOZ_MUST_USE
.
*
/
\
}
\
}
while
(
false
)
#
define
MOZ_ALWAYS_OK
(
expr
)
\
do
{
\
if
(
(
expr
)
.
isOk
(
)
)
{
\
/
*
Silence
MOZ_MUST_USE
.
*
/
\
}
\
}
while
(
false
)
#
define
MOZ_ALWAYS_ERR
(
expr
)
\
do
{
\
if
(
(
expr
)
.
isErr
(
)
)
{
\
/
*
Silence
MOZ_MUST_USE
.
*
/
\
}
\
}
while
(
false
)
#
endif
#
undef
MOZ_DUMP_ASSERTION_STACK
#
undef
MOZ_CRASH_CRASHREPORT
#
endif
