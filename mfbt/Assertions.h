#
ifndef
mozilla_Assertions_h
#
define
mozilla_Assertions_h
#
if
(
defined
(
MOZ_HAS_MOZGLUE
)
|
|
defined
(
MOZILLA_INTERNAL_API
)
)
&
&
\
!
defined
(
__wasi__
)
#
define
MOZ_DUMP_ASSERTION_STACK
#
endif
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Compiler
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
MacroArgs
.
h
"
#
include
"
mozilla
/
StaticAnalysisFunctions
.
h
"
#
include
"
mozilla
/
Types
.
h
"
#
ifdef
MOZ_DUMP_ASSERTION_STACK
#
include
"
mozilla
/
StackWalk
.
h
"
#
endif
MOZ_BEGIN_EXTERN_C
extern
MFBT_DATA
const
char
*
gMozCrashReason
;
MOZ_END_EXTERN_C
#
if
defined
(
MOZ_HAS_MOZGLUE
)
|
|
defined
(
MOZILLA_INTERNAL_API
)
static
inline
void
AnnotateMozCrashReason
(
const
char
*
reason
)
{
gMozCrashReason
=
reason
;
}
#
define
MOZ_CRASH_ANNOTATE
(
.
.
.
)
AnnotateMozCrashReason
(
__VA_ARGS__
)
#
else
#
define
MOZ_CRASH_ANNOTATE
(
.
.
.
)
\
do
{
/
*
nothing
*
/
\
}
while
(
false
)
#
endif
#
include
<
stddef
.
h
>
#
include
<
stdio
.
h
>
#
include
<
stdlib
.
h
>
#
ifdef
_MSC_VER
MOZ_BEGIN_EXTERN_C
__declspec
(
dllimport
)
int
__stdcall
TerminateProcess
(
void
*
hProcess
unsigned
int
uExitCode
)
;
__declspec
(
dllimport
)
void
*
__stdcall
GetCurrentProcess
(
void
)
;
MOZ_END_EXTERN_C
#
elif
defined
(
__wasi__
)
#
else
#
include
<
signal
.
h
>
#
endif
#
ifdef
ANDROID
#
include
<
android
/
log
.
h
>
#
endif
MOZ_BEGIN_EXTERN_C
#
if
defined
(
ANDROID
)
&
&
defined
(
MOZ_DUMP_ASSERTION_STACK
)
MOZ_MAYBE_UNUSED
static
void
MOZ_ReportAssertionFailurePrintFrame
(
const
char
*
aBuf
)
{
__android_log_print
(
ANDROID_LOG_FATAL
"
MOZ_Assert
"
"
%
s
\
n
"
aBuf
)
;
}
#
endif
MOZ_MAYBE_UNUSED
static
MOZ_COLD
MOZ_NEVER_INLINE
void
MOZ_ReportAssertionFailure
(
const
char
*
aStr
const
char
*
aFilename
int
aLine
)
MOZ_PRETEND_NORETURN_FOR_STATIC_ANALYSIS
{
#
ifdef
ANDROID
__android_log_print
(
ANDROID_LOG_FATAL
"
MOZ_Assert
"
"
Assertion
failure
:
%
s
at
%
s
:
%
d
\
n
"
aStr
aFilename
aLine
)
;
#
if
defined
(
MOZ_DUMP_ASSERTION_STACK
)
MozWalkTheStackWithWriter
(
MOZ_ReportAssertionFailurePrintFrame
CallerPC
(
)
0
)
;
#
endif
#
else
fprintf
(
stderr
"
Assertion
failure
:
%
s
at
%
s
:
%
d
\
n
"
aStr
aFilename
aLine
)
;
#
if
defined
(
MOZ_DUMP_ASSERTION_STACK
)
MozWalkTheStack
(
stderr
CallerPC
(
)
0
)
;
#
endif
fflush
(
stderr
)
;
#
endif
}
MOZ_MAYBE_UNUSED
static
MOZ_COLD
MOZ_NEVER_INLINE
void
MOZ_ReportCrash
(
const
char
*
aStr
const
char
*
aFilename
int
aLine
)
MOZ_PRETEND_NORETURN_FOR_STATIC_ANALYSIS
{
#
ifdef
ANDROID
__android_log_print
(
ANDROID_LOG_FATAL
"
MOZ_CRASH
"
"
Hit
MOZ_CRASH
(
%
s
)
at
%
s
:
%
d
\
n
"
aStr
aFilename
aLine
)
;
#
else
fprintf
(
stderr
"
Hit
MOZ_CRASH
(
%
s
)
at
%
s
:
%
d
\
n
"
aStr
aFilename
aLine
)
;
#
if
defined
(
MOZ_DUMP_ASSERTION_STACK
)
MozWalkTheStack
(
stderr
CallerPC
(
)
0
)
;
#
endif
fflush
(
stderr
)
;
#
endif
}
#
if
defined
(
_MSC_VER
)
MOZ_MAYBE_UNUSED
static
MOZ_COLD
MOZ_NORETURN
MOZ_NEVER_INLINE
void
MOZ_NoReturn
(
int
aLine
)
{
*
(
(
volatile
int
*
)
NULL
)
=
aLine
;
TerminateProcess
(
GetCurrentProcess
(
)
3
)
;
}
#
define
MOZ_REALLY_CRASH
(
line
)
\
do
{
\
__debugbreak
(
)
;
\
MOZ_NoReturn
(
line
)
;
\
}
while
(
false
)
#
elif
__wasi__
#
define
MOZ_REALLY_CRASH
(
line
)
__builtin_trap
(
)
#
else
#
ifdef
MOZ_UBSAN
#
define
MOZ_CRASH_WRITE_ADDR
0x1
#
else
#
define
MOZ_CRASH_WRITE_ADDR
NULL
#
endif
#
ifdef
__cplusplus
#
define
MOZ_REALLY_CRASH
(
line
)
\
do
{
\
*
(
(
volatile
int
*
)
MOZ_CRASH_WRITE_ADDR
)
=
line
;
/
*
NOLINT
*
/
\
:
:
abort
(
)
;
\
}
while
(
false
)
#
else
#
define
MOZ_REALLY_CRASH
(
line
)
\
do
{
\
*
(
(
volatile
int
*
)
MOZ_CRASH_WRITE_ADDR
)
=
line
;
/
*
NOLINT
*
/
\
abort
(
)
;
\
}
while
(
false
)
#
endif
#
endif
#
if
!
(
defined
(
DEBUG
)
|
|
defined
(
FUZZING
)
)
#
define
MOZ_CRASH
(
.
.
.
)
\
do
{
\
MOZ_CRASH_ANNOTATE
(
"
MOZ_CRASH
(
"
__VA_ARGS__
"
)
"
)
;
\
MOZ_REALLY_CRASH
(
__LINE__
)
;
\
}
while
(
false
)
#
else
#
define
MOZ_CRASH
(
.
.
.
)
\
do
{
\
MOZ_ReportCrash
(
"
"
__VA_ARGS__
__FILE__
__LINE__
)
;
\
MOZ_CRASH_ANNOTATE
(
"
MOZ_CRASH
(
"
__VA_ARGS__
"
)
"
)
;
\
MOZ_REALLY_CRASH
(
__LINE__
)
;
\
}
while
(
false
)
#
endif
static
MOZ_ALWAYS_INLINE_EVEN_DEBUG
MOZ_COLD
MOZ_NORETURN
void
MOZ_Crash
(
const
char
*
aFilename
int
aLine
const
char
*
aReason
)
{
#
if
defined
(
DEBUG
)
|
|
defined
(
FUZZING
)
MOZ_ReportCrash
(
aReason
aFilename
aLine
)
;
#
endif
MOZ_CRASH_ANNOTATE
(
aReason
)
;
MOZ_REALLY_CRASH
(
aLine
)
;
}
#
define
MOZ_CRASH_UNSAFE
(
reason
)
MOZ_Crash
(
__FILE__
__LINE__
reason
)
static
const
size_t
sPrintfMaxArgs
=
4
;
static
const
size_t
sPrintfCrashReasonSize
=
1024
;
MFBT_API
MOZ_COLD
MOZ_NEVER_INLINE
MOZ_FORMAT_PRINTF
(
1
2
)
const
char
*
MOZ_CrashPrintf
(
const
char
*
aFormat
.
.
.
)
;
#
define
MOZ_CRASH_UNSAFE_PRINTF
(
format
.
.
.
)
\
do
{
\
static_assert
(
MOZ_ARG_COUNT
(
__VA_ARGS__
)
>
0
\
"
Did
you
forget
arguments
to
MOZ_CRASH_UNSAFE_PRINTF
?
"
\
"
Or
maybe
you
want
MOZ_CRASH
instead
?
"
)
;
\
static_assert
(
MOZ_ARG_COUNT
(
__VA_ARGS__
)
<
=
sPrintfMaxArgs
\
"
Only
up
to
4
additional
arguments
are
allowed
!
"
)
;
\
static_assert
(
sizeof
(
format
)
<
=
sPrintfCrashReasonSize
\
"
The
supplied
format
string
is
too
long
!
"
)
;
\
MOZ_Crash
(
__FILE__
__LINE__
MOZ_CrashPrintf
(
"
"
format
__VA_ARGS__
)
)
;
\
}
while
(
false
)
MOZ_END_EXTERN_C
#
ifdef
__cplusplus
#
include
<
type_traits
>
namespace
mozilla
{
namespace
detail
{
template
<
typename
T
>
struct
AssertionConditionType
{
using
ValueT
=
std
:
:
remove_reference_t
<
T
>
;
static_assert
(
!
std
:
:
is_array_v
<
ValueT
>
"
Expected
boolean
assertion
condition
got
an
array
or
a
"
"
string
!
"
)
;
static_assert
(
!
std
:
:
is_function_v
<
ValueT
>
"
Expected
boolean
assertion
condition
got
a
function
!
Did
"
"
you
intend
to
call
that
function
?
"
)
;
static_assert
(
!
std
:
:
is_floating_point_v
<
ValueT
>
"
It
'
s
often
a
bad
idea
to
assert
that
a
floating
-
point
number
"
"
is
nonzero
because
such
assertions
tend
to
intermittently
"
"
fail
.
Shouldn
'
t
your
code
gracefully
handle
this
case
instead
"
"
of
asserting
?
Anyway
if
you
really
want
to
do
that
write
an
"
"
explicit
boolean
condition
like
!
!
x
or
x
!
=
0
.
"
)
;
static
const
bool
isValid
=
true
;
}
;
}
}
#
define
MOZ_VALIDATE_ASSERT_CONDITION_TYPE
(
x
)
\
static_assert
(
\
mozilla
:
:
detail
:
:
AssertionConditionType
<
decltype
(
x
)
>
:
:
isValid
\
"
invalid
assertion
condition
"
)
#
else
#
define
MOZ_VALIDATE_ASSERT_CONDITION_TYPE
(
x
)
#
endif
#
if
defined
(
DEBUG
)
|
|
defined
(
MOZ_ASAN
)
#
define
MOZ_REPORT_ASSERTION_FAILURE
(
.
.
.
)
\
MOZ_ReportAssertionFailure
(
__VA_ARGS__
)
#
else
#
define
MOZ_REPORT_ASSERTION_FAILURE
(
.
.
.
)
\
do
{
/
*
nothing
*
/
\
}
while
(
false
)
#
endif
#
define
MOZ_ASSERT_HELPER1
(
kind
expr
)
\
do
{
\
MOZ_VALIDATE_ASSERT_CONDITION_TYPE
(
expr
)
;
\
if
(
MOZ_UNLIKELY
(
!
MOZ_CHECK_ASSERT_ASSIGNMENT
(
expr
)
)
)
{
\
MOZ_REPORT_ASSERTION_FAILURE
(
#
expr
__FILE__
__LINE__
)
;
\
MOZ_CRASH_ANNOTATE
(
kind
"
(
"
#
expr
"
)
"
)
;
\
MOZ_REALLY_CRASH
(
__LINE__
)
;
\
}
\
}
while
(
false
)
#
define
MOZ_ASSERT_HELPER2
(
kind
expr
explain
)
\
do
{
\
MOZ_VALIDATE_ASSERT_CONDITION_TYPE
(
expr
)
;
\
if
(
MOZ_UNLIKELY
(
!
MOZ_CHECK_ASSERT_ASSIGNMENT
(
expr
)
)
)
{
\
MOZ_REPORT_ASSERTION_FAILURE
(
#
expr
"
(
"
explain
"
)
"
__FILE__
\
__LINE__
)
;
\
MOZ_CRASH_ANNOTATE
(
kind
"
(
"
#
expr
"
)
(
"
explain
"
)
"
)
;
\
MOZ_REALLY_CRASH
(
__LINE__
)
;
\
}
\
}
while
(
false
)
#
define
MOZ_ASSERT_GLUE
(
a
b
)
a
b
#
define
MOZ_RELEASE_ASSERT
(
.
.
.
)
\
MOZ_ASSERT_GLUE
(
\
MOZ_PASTE_PREFIX_AND_ARG_COUNT
(
MOZ_ASSERT_HELPER
__VA_ARGS__
)
\
(
"
MOZ_RELEASE_ASSERT
"
__VA_ARGS__
)
)
#
ifdef
DEBUG
#
define
MOZ_ASSERT
(
.
.
.
)
\
MOZ_ASSERT_GLUE
(
\
MOZ_PASTE_PREFIX_AND_ARG_COUNT
(
MOZ_ASSERT_HELPER
__VA_ARGS__
)
\
(
"
MOZ_ASSERT
"
__VA_ARGS__
)
)
#
else
#
define
MOZ_ASSERT
(
.
.
.
)
\
do
{
\
}
while
(
false
)
#
endif
#
if
defined
(
NIGHTLY_BUILD
)
|
|
defined
(
MOZ_DEV_EDITION
)
|
|
defined
(
DEBUG
)
#
define
MOZ_DIAGNOSTIC_ASSERT
(
.
.
.
)
\
MOZ_ASSERT_GLUE
(
\
MOZ_PASTE_PREFIX_AND_ARG_COUNT
(
MOZ_ASSERT_HELPER
__VA_ARGS__
)
\
(
"
MOZ_DIAGNOSTIC_ASSERT
"
__VA_ARGS__
)
)
#
define
MOZ_DIAGNOSTIC_ASSERT_ENABLED
1
#
else
#
define
MOZ_DIAGNOSTIC_ASSERT
(
.
.
.
)
\
do
{
\
}
while
(
false
)
#
endif
#
ifdef
DEBUG
#
define
MOZ_ASSERT_IF
(
cond
expr
)
\
do
{
\
if
(
cond
)
{
\
MOZ_ASSERT
(
expr
)
;
\
}
\
}
while
(
false
)
#
else
#
define
MOZ_ASSERT_IF
(
cond
expr
)
\
do
{
\
}
while
(
false
)
#
endif
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
#
define
MOZ_DIAGNOSTIC_ASSERT_IF
(
cond
expr
)
\
do
{
\
if
(
cond
)
{
\
MOZ_DIAGNOSTIC_ASSERT
(
expr
)
;
\
}
\
}
while
(
false
)
#
else
#
define
MOZ_DIAGNOSTIC_ASSERT_IF
(
cond
expr
)
\
do
{
\
}
while
(
false
)
#
endif
#
if
defined
(
__clang__
)
|
|
defined
(
__GNUC__
)
#
define
MOZ_ASSUME_UNREACHABLE_MARKER
(
)
__builtin_unreachable
(
)
#
elif
defined
(
_MSC_VER
)
#
define
MOZ_ASSUME_UNREACHABLE_MARKER
(
)
__assume
(
0
)
#
else
#
ifdef
__cplusplus
#
define
MOZ_ASSUME_UNREACHABLE_MARKER
(
)
:
:
abort
(
)
#
else
#
define
MOZ_ASSUME_UNREACHABLE_MARKER
(
)
abort
(
)
#
endif
#
endif
#
define
MOZ_ASSERT_UNREACHABLE
(
reason
)
\
MOZ_ASSERT
(
false
"
MOZ_ASSERT_UNREACHABLE
:
"
reason
)
#
define
MOZ_MAKE_COMPILER_ASSUME_IS_UNREACHABLE
(
reason
)
\
do
{
\
MOZ_ASSERT_UNREACHABLE
(
reason
)
;
\
MOZ_ASSUME_UNREACHABLE_MARKER
(
)
;
\
}
while
(
false
)
#
ifdef
DEBUG
#
define
MOZ_FALLTHROUGH_ASSERT
(
.
.
.
)
\
MOZ_CRASH
(
"
MOZ_FALLTHROUGH_ASSERT
:
"
__VA_ARGS__
)
#
else
#
define
MOZ_FALLTHROUGH_ASSERT
(
.
.
.
)
[
[
fallthrough
]
]
#
endif
#
define
MOZ_ALWAYS_TRUE
(
expr
)
\
do
{
\
if
(
MOZ_LIKELY
(
expr
)
)
{
\
/
*
Silence
[
[
nodiscard
]
]
.
*
/
\
}
else
{
\
MOZ_DIAGNOSTIC_ASSERT
(
false
#
expr
)
;
\
}
\
}
while
(
false
)
#
define
MOZ_ALWAYS_FALSE
(
expr
)
MOZ_ALWAYS_TRUE
(
!
(
expr
)
)
#
define
MOZ_ALWAYS_OK
(
expr
)
MOZ_ALWAYS_TRUE
(
(
expr
)
.
isOk
(
)
)
#
define
MOZ_ALWAYS_ERR
(
expr
)
MOZ_ALWAYS_TRUE
(
(
expr
)
.
isErr
(
)
)
#
undef
MOZ_DUMP_ASSERTION_STACK
#
undef
MOZ_CRASH_CRASHREPORT
#
ifdef
__cplusplus
namespace
mozilla
:
:
detail
{
MFBT_API
MOZ_NORETURN
MOZ_COLD
void
InvalidArrayIndex_CRASH
(
size_t
aIndex
size_t
aLength
)
;
}
#
endif
#
endif
