#
ifndef
mozilla_EnumTypeTraits_h
#
define
mozilla_EnumTypeTraits_h
#
include
<
stddef
.
h
>
#
include
<
type_traits
>
namespace
mozilla
{
namespace
detail
{
template
<
size_t
EnumSize
bool
EnumSigned
size_t
StorageSize
bool
StorageSigned
>
struct
EnumFitsWithinHelper
;
template
<
size_t
EnumSize
size_t
StorageSize
>
struct
EnumFitsWithinHelper
<
EnumSize
true
StorageSize
true
>
:
public
std
:
:
integral_constant
<
bool
(
EnumSize
<
=
StorageSize
)
>
{
}
;
template
<
size_t
EnumSize
size_t
StorageSize
>
struct
EnumFitsWithinHelper
<
EnumSize
true
StorageSize
false
>
:
public
std
:
:
integral_constant
<
bool
false
>
{
}
;
template
<
size_t
EnumSize
size_t
StorageSize
>
struct
EnumFitsWithinHelper
<
EnumSize
false
StorageSize
true
>
:
public
std
:
:
integral_constant
<
bool
(
EnumSize
*
2
<
=
StorageSize
)
>
{
}
;
template
<
size_t
EnumSize
size_t
StorageSize
>
struct
EnumFitsWithinHelper
<
EnumSize
false
StorageSize
false
>
:
public
std
:
:
integral_constant
<
bool
(
EnumSize
<
=
StorageSize
)
>
{
}
;
}
template
<
typename
T
typename
Storage
>
struct
EnumTypeFitsWithin
:
public
detail
:
:
EnumFitsWithinHelper
<
sizeof
(
T
)
std
:
:
is_signed
<
typename
std
:
:
underlying_type
<
T
>
:
:
type
>
:
:
value
sizeof
(
Storage
)
std
:
:
is_signed
<
Storage
>
:
:
value
>
{
static_assert
(
std
:
:
is_enum
<
T
>
:
:
value
"
must
provide
an
enum
type
"
)
;
static_assert
(
std
:
:
is_integral
<
Storage
>
:
:
value
"
must
provide
an
integral
type
"
)
;
}
;
template
<
typename
T
>
struct
MaxEnumValue
;
template
<
typename
T
>
inline
constexpr
auto
UnderlyingValue
(
const
T
v
)
{
static_assert
(
std
:
:
is_enum_v
<
T
>
)
;
return
static_cast
<
typename
std
:
:
underlying_type
<
T
>
:
:
type
>
(
v
)
;
}
}
#
endif
