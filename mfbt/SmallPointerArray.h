#
ifndef
mozilla_SmallPointerArray_h
#
define
mozilla_SmallPointerArray_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
<
iterator
>
#
include
<
vector
>
namespace
mozilla
{
template
<
typename
T
>
class
SmallPointerArray
{
public
:
SmallPointerArray
(
)
{
mInlineElements
[
0
]
=
mInlineElements
[
1
]
=
nullptr
;
static_assert
(
sizeof
(
SmallPointerArray
<
T
>
)
=
=
(
2
*
sizeof
(
void
*
)
)
"
SmallPointerArray
must
compile
to
the
size
of
2
pointers
"
)
;
static_assert
(
offsetof
(
SmallPointerArray
<
T
>
mArray
)
=
=
offsetof
(
SmallPointerArray
<
T
>
mInlineElements
)
+
sizeof
(
T
*
)
"
mArray
and
mInlineElements
[
1
]
are
expected
to
overlap
in
memory
"
)
;
static_assert
(
offsetof
(
SmallPointerArray
<
T
>
mPadding
)
=
=
offsetof
(
SmallPointerArray
<
T
>
mInlineElements
)
"
mPadding
and
mInlineElements
[
0
]
are
expected
to
overlap
in
memory
"
)
;
}
~
SmallPointerArray
(
)
{
if
(
!
mInlineElements
[
0
]
&
&
mArray
)
{
delete
mArray
;
}
}
void
Clear
(
)
{
if
(
!
mInlineElements
[
0
]
&
&
mArray
)
{
delete
mArray
;
mArray
=
nullptr
;
return
;
}
mInlineElements
[
0
]
=
mInlineElements
[
1
]
=
nullptr
;
}
void
AppendElement
(
T
*
aElement
)
{
MOZ_ASSERT
(
aElement
!
=
nullptr
)
;
if
(
!
mInlineElements
[
0
]
)
{
if
(
!
mArray
)
{
mInlineElements
[
0
]
=
aElement
;
return
;
}
if
(
!
aElement
)
{
return
;
}
mArray
-
>
push_back
(
aElement
)
;
return
;
}
if
(
!
aElement
)
{
return
;
}
if
(
!
mInlineElements
[
1
]
)
{
mInlineElements
[
1
]
=
aElement
;
return
;
}
mArray
=
new
std
:
:
vector
<
T
*
>
(
{
mInlineElements
[
0
]
mInlineElements
[
1
]
aElement
}
)
;
mInlineElements
[
0
]
=
nullptr
;
}
void
RemoveElement
(
T
*
aElement
)
{
MOZ_ASSERT
(
aElement
!
=
nullptr
)
;
if
(
aElement
=
=
nullptr
)
{
return
;
}
if
(
mInlineElements
[
0
]
=
=
aElement
)
{
mInlineElements
[
0
]
=
mInlineElements
[
1
]
;
mInlineElements
[
1
]
=
nullptr
;
return
;
}
if
(
mInlineElements
[
0
]
)
{
if
(
mInlineElements
[
1
]
=
=
aElement
)
{
mInlineElements
[
1
]
=
nullptr
;
}
return
;
}
if
(
mArray
)
{
for
(
auto
iter
=
mArray
-
>
begin
(
)
;
iter
!
=
mArray
-
>
end
(
)
;
iter
+
+
)
{
if
(
*
iter
=
=
aElement
)
{
mArray
-
>
erase
(
iter
)
;
return
;
}
}
}
}
size_t
Length
(
)
const
{
if
(
mInlineElements
[
0
]
)
{
if
(
!
mInlineElements
[
1
]
)
{
return
1
;
}
return
2
;
}
if
(
mArray
)
{
return
mArray
-
>
size
(
)
;
}
return
0
;
}
T
*
ElementAt
(
size_t
aIndex
)
const
{
MOZ_ASSERT
(
aIndex
<
Length
(
)
)
;
if
(
mInlineElements
[
0
]
)
{
return
mInlineElements
[
aIndex
]
;
}
return
(
*
mArray
)
[
aIndex
]
;
}
T
*
operator
[
]
(
size_t
aIndex
)
const
{
return
ElementAt
(
aIndex
)
;
}
typedef
T
*
*
iterator
;
typedef
const
T
*
*
const_iterator
;
iterator
begin
(
)
{
return
beginInternal
(
)
;
}
const_iterator
begin
(
)
const
{
return
beginInternal
(
)
;
}
const_iterator
cbegin
(
)
const
{
return
begin
(
)
;
}
iterator
end
(
)
{
return
beginInternal
(
)
+
Length
(
)
;
}
const_iterator
end
(
)
const
{
return
beginInternal
(
)
+
Length
(
)
;
}
const_iterator
cend
(
)
const
{
return
end
(
)
;
}
private
:
T
*
*
beginInternal
(
)
const
{
if
(
mInlineElements
[
0
]
|
|
!
mArray
)
{
return
const_cast
<
T
*
*
>
(
&
mInlineElements
[
0
]
)
;
}
if
(
mArray
-
>
empty
(
)
)
{
return
nullptr
;
}
return
&
(
*
mArray
)
[
0
]
;
}
union
{
T
*
mInlineElements
[
2
]
;
struct
{
void
*
mPadding
;
std
:
:
vector
<
T
*
>
*
mArray
;
}
;
}
;
}
;
}
#
endif
