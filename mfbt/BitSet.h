#
ifndef
mozilla_BitSet_h
#
define
mozilla_BitSet_h
#
include
"
mozilla
/
Array
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
mozilla
/
Span
.
h
"
namespace
mozilla
{
template
<
size_t
N
typename
Word
=
size_t
>
class
BitSet
{
static_assert
(
std
:
:
is_unsigned_v
<
Word
>
"
The
Word
type
must
be
an
unsigned
integral
type
"
)
;
static_assert
(
N
!
=
0
)
;
private
:
static
constexpr
size_t
kBitsPerWord
=
8
*
sizeof
(
Word
)
;
static
constexpr
size_t
kNumWords
=
(
N
+
kBitsPerWord
-
1
)
/
kBitsPerWord
;
static
constexpr
size_t
kPaddingBits
=
(
kNumWords
*
kBitsPerWord
)
-
N
;
static
constexpr
Word
kPaddingMask
=
Word
(
-
1
)
>
>
kPaddingBits
;
Array
<
Word
kNumWords
>
mStorage
;
constexpr
void
ResetPaddingBits
(
)
{
if
constexpr
(
kPaddingBits
!
=
0
)
{
mStorage
[
kNumWords
-
1
]
&
=
kPaddingMask
;
}
}
public
:
class
Reference
{
public
:
Reference
(
BitSet
<
N
Word
>
&
aBitSet
size_t
aPos
)
:
mBitSet
(
aBitSet
)
mPos
(
aPos
)
{
}
Reference
&
operator
=
(
bool
aValue
)
{
auto
bit
=
Word
(
1
)
<
<
(
mPos
%
kBitsPerWord
)
;
auto
&
word
=
mBitSet
.
mStorage
[
mPos
/
kBitsPerWord
]
;
word
=
(
word
&
~
bit
)
|
(
aValue
?
bit
:
0
)
;
return
*
this
;
}
MOZ_IMPLICIT
operator
bool
(
)
const
{
return
mBitSet
.
test
(
mPos
)
;
}
private
:
BitSet
<
N
Word
>
&
mBitSet
;
size_t
mPos
;
}
;
constexpr
BitSet
(
)
:
mStorage
(
)
{
}
BitSet
(
const
BitSet
&
aOther
)
{
*
this
=
aOther
;
}
BitSet
&
operator
=
(
const
BitSet
&
aOther
)
{
PodCopy
(
mStorage
.
begin
(
)
aOther
.
mStorage
.
begin
(
)
kNumWords
)
;
return
*
this
;
}
explicit
BitSet
(
Span
<
Word
kNumWords
>
aStorage
)
{
PodCopy
(
mStorage
.
begin
(
)
aStorage
.
Elements
(
)
kNumWords
)
;
}
static
constexpr
size_t
size
(
)
{
return
N
;
}
constexpr
bool
test
(
size_t
aPos
)
const
{
MOZ_ASSERT
(
aPos
<
N
)
;
return
mStorage
[
aPos
/
kBitsPerWord
]
&
(
Word
(
1
)
<
<
(
aPos
%
kBitsPerWord
)
)
;
}
constexpr
bool
IsEmpty
(
)
const
{
for
(
const
Word
&
word
:
mStorage
)
{
if
(
word
)
{
return
false
;
}
}
return
true
;
}
explicit
constexpr
operator
bool
(
)
{
return
!
IsEmpty
(
)
;
}
constexpr
bool
operator
[
]
(
size_t
aPos
)
const
{
return
test
(
aPos
)
;
}
Reference
operator
[
]
(
size_t
aPos
)
{
MOZ_ASSERT
(
aPos
<
N
)
;
return
{
*
this
aPos
}
;
}
BitSet
operator
|
(
const
BitSet
<
N
Word
>
&
aOther
)
{
BitSet
result
=
*
this
;
result
|
=
aOther
;
return
result
;
}
BitSet
&
operator
|
=
(
const
BitSet
<
N
Word
>
&
aOther
)
{
for
(
size_t
i
=
0
;
i
<
std
:
:
size
(
mStorage
)
;
i
+
+
)
{
mStorage
[
i
]
|
=
aOther
.
mStorage
[
i
]
;
}
return
*
this
;
}
BitSet
operator
~
(
)
const
{
BitSet
result
=
*
this
;
result
.
Flip
(
)
;
return
result
;
}
BitSet
&
operator
&
=
(
const
BitSet
<
N
Word
>
&
aOther
)
{
for
(
size_t
i
=
0
;
i
<
std
:
:
size
(
mStorage
)
;
i
+
+
)
{
mStorage
[
i
]
&
=
aOther
.
mStorage
[
i
]
;
}
return
*
this
;
}
BitSet
operator
&
(
const
BitSet
<
N
Word
>
&
aOther
)
const
{
BitSet
result
=
*
this
;
result
&
=
aOther
;
return
result
;
}
bool
operator
=
=
(
const
BitSet
<
N
Word
>
&
aOther
)
const
{
return
mStorage
=
=
aOther
.
mStorage
;
}
size_t
Count
(
)
const
{
size_t
count
=
0
;
for
(
const
Word
&
word
:
mStorage
)
{
if
constexpr
(
kBitsPerWord
>
32
)
{
count
+
=
CountPopulation64
(
word
)
;
}
else
{
count
+
=
CountPopulation32
(
word
)
;
}
}
return
count
;
}
void
ResetAll
(
)
{
PodArrayZero
(
mStorage
)
;
}
void
SetAll
(
)
{
memset
(
mStorage
.
begin
(
)
0xff
kNumWords
*
sizeof
(
Word
)
)
;
ResetPaddingBits
(
)
;
}
void
Flip
(
)
{
for
(
Word
&
word
:
mStorage
)
{
word
=
~
word
;
}
ResetPaddingBits
(
)
;
}
size_t
FindFirst
(
)
const
{
return
FindNext
(
0
)
;
}
size_t
FindNext
(
size_t
aFromPos
)
const
{
MOZ_ASSERT
(
aFromPos
<
N
)
;
size_t
wordIndex
=
aFromPos
/
kBitsPerWord
;
size_t
bitIndex
=
aFromPos
%
kBitsPerWord
;
Word
word
=
mStorage
[
wordIndex
]
;
word
&
=
(
Word
(
-
1
)
<
<
bitIndex
)
;
while
(
word
=
=
0
)
{
wordIndex
+
+
;
if
(
wordIndex
=
=
kNumWords
)
{
return
SIZE_MAX
;
}
word
=
mStorage
[
wordIndex
]
;
}
uint_fast8_t
pos
=
CountTrailingZeroes
(
word
)
;
return
wordIndex
*
kBitsPerWord
+
pos
;
}
size_t
FindLast
(
)
const
{
return
FindPrev
(
size
(
)
-
1
)
;
}
size_t
FindPrev
(
size_t
aFromPos
)
const
{
MOZ_ASSERT
(
aFromPos
<
N
)
;
size_t
wordIndex
=
aFromPos
/
kBitsPerWord
;
size_t
bitIndex
=
aFromPos
%
kBitsPerWord
;
Word
word
=
mStorage
[
wordIndex
]
;
word
&
=
Word
(
-
1
)
>
>
(
kBitsPerWord
-
1
-
bitIndex
)
;
while
(
word
=
=
0
)
{
if
(
wordIndex
=
=
0
)
{
return
SIZE_MAX
;
}
wordIndex
-
-
;
word
=
mStorage
[
wordIndex
]
;
}
uint_fast8_t
pos
=
FindMostSignificantBit
(
word
)
;
return
wordIndex
*
kBitsPerWord
+
pos
;
}
Span
<
Word
>
Storage
(
)
{
return
mStorage
;
}
Span
<
const
Word
>
Storage
(
)
const
{
return
mStorage
;
}
}
;
}
#
endif
