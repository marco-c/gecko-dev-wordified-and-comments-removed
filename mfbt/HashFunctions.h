#
ifndef
mozilla_HashFunctions_h
#
define
mozilla_HashFunctions_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Char16
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
Types
.
h
"
#
include
"
mozilla
/
WrappingOperations
.
h
"
#
include
<
stdint
.
h
>
#
include
<
type_traits
>
namespace
mozilla
{
using
HashNumber
=
uint32_t
;
static
const
uint32_t
kHashNumberBits
=
32
;
static
const
HashNumber
kGoldenRatioU32
=
0x9E3779B9U
;
constexpr
HashNumber
ScrambleHashCode
(
HashNumber
h
)
{
return
mozilla
:
:
WrappingMultiply
(
h
kGoldenRatioU32
)
;
}
namespace
detail
{
MOZ_NO_SANITIZE_UNSIGNED_OVERFLOW
constexpr
HashNumber
RotateLeft5
(
HashNumber
aValue
)
{
return
(
aValue
<
<
5
)
|
(
aValue
>
>
27
)
;
}
constexpr
HashNumber
AddU32ToHash
(
HashNumber
aHash
uint32_t
aValue
)
{
return
mozilla
:
:
WrappingMultiply
(
kGoldenRatioU32
RotateLeft5
(
aHash
)
^
aValue
)
;
}
template
<
size_t
Size
>
constexpr
HashNumber
AddUintNToHash
(
HashNumber
aHash
uint64_t
aValue
)
{
return
AddU32ToHash
(
aHash
static_cast
<
uint32_t
>
(
aValue
)
)
;
}
template
<
>
inline
HashNumber
AddUintNToHash
<
8
>
(
HashNumber
aHash
uint64_t
aValue
)
{
uint32_t
v1
=
static_cast
<
uint32_t
>
(
aValue
)
;
uint32_t
v2
=
static_cast
<
uint32_t
>
(
aValue
>
>
32
)
;
return
AddU32ToHash
(
AddU32ToHash
(
aHash
v1
)
v2
)
;
}
}
template
<
typename
T
bool
TypeIsNotIntegral
=
!
std
:
:
is_integral_v
<
T
>
bool
TypeIsNotEnum
=
!
std
:
:
is_enum_v
<
T
>
std
:
:
enable_if_t
<
TypeIsNotIntegral
&
&
TypeIsNotEnum
int
>
=
0
>
[
[
nodiscard
]
]
inline
HashNumber
AddToHash
(
HashNumber
aHash
T
aA
)
{
return
detail
:
:
AddU32ToHash
(
aHash
aA
)
;
}
template
<
typename
A
>
[
[
nodiscard
]
]
inline
HashNumber
AddToHash
(
HashNumber
aHash
A
*
aA
)
{
static_assert
(
sizeof
(
aA
)
=
=
sizeof
(
uintptr_t
)
"
Strange
pointer
!
"
)
;
return
detail
:
:
AddUintNToHash
<
sizeof
(
uintptr_t
)
>
(
aHash
uintptr_t
(
aA
)
)
;
}
template
<
typename
T
std
:
:
enable_if_t
<
std
:
:
is_integral_v
<
T
>
int
>
=
0
>
[
[
nodiscard
]
]
constexpr
HashNumber
AddToHash
(
HashNumber
aHash
T
aA
)
{
return
detail
:
:
AddUintNToHash
<
sizeof
(
T
)
>
(
aHash
aA
)
;
}
template
<
typename
T
std
:
:
enable_if_t
<
std
:
:
is_enum_v
<
T
>
int
>
=
0
>
[
[
nodiscard
]
]
constexpr
HashNumber
AddToHash
(
HashNumber
aHash
T
aA
)
{
using
UnderlyingType
=
typename
std
:
:
underlying_type
<
T
>
:
:
type
;
return
detail
:
:
AddUintNToHash
<
sizeof
(
UnderlyingType
)
>
(
aHash
static_cast
<
UnderlyingType
>
(
aA
)
)
;
}
template
<
typename
A
typename
.
.
.
Args
>
[
[
nodiscard
]
]
HashNumber
AddToHash
(
HashNumber
aHash
A
aArg
Args
.
.
.
aArgs
)
{
return
AddToHash
(
AddToHash
(
aHash
aArg
)
aArgs
.
.
.
)
;
}
template
<
typename
.
.
.
Args
>
[
[
nodiscard
]
]
inline
HashNumber
HashGeneric
(
Args
.
.
.
aArgs
)
{
return
AddToHash
(
0
aArgs
.
.
.
)
;
}
template
<
typename
Iterator
>
[
[
nodiscard
]
]
constexpr
HashNumber
HashStringUntilZero
(
Iterator
aIter
)
{
HashNumber
hash
=
0
;
for
(
;
auto
c
=
*
aIter
;
+
+
aIter
)
{
hash
=
AddToHash
(
hash
c
)
;
}
return
hash
;
}
template
<
typename
Iterator
>
[
[
nodiscard
]
]
constexpr
HashNumber
HashStringKnownLength
(
Iterator
aIter
size_t
aLength
)
{
HashNumber
hash
=
0
;
for
(
size_t
i
=
0
;
i
<
aLength
;
i
+
+
)
{
hash
=
AddToHash
(
hash
aIter
[
i
]
)
;
}
return
hash
;
}
[
[
nodiscard
]
]
inline
HashNumber
HashString
(
const
char
*
aStr
)
{
return
HashStringUntilZero
(
reinterpret_cast
<
const
unsigned
char
*
>
(
aStr
)
)
;
}
[
[
nodiscard
]
]
inline
HashNumber
HashString
(
const
char
*
aStr
size_t
aLength
)
{
return
HashStringKnownLength
(
reinterpret_cast
<
const
unsigned
char
*
>
(
aStr
)
aLength
)
;
}
[
[
nodiscard
]
]
inline
HashNumber
HashString
(
const
unsigned
char
*
aStr
size_t
aLength
)
{
return
HashStringKnownLength
(
aStr
aLength
)
;
}
[
[
nodiscard
]
]
constexpr
HashNumber
HashString
(
const
char16_t
*
aStr
)
{
return
HashStringUntilZero
(
aStr
)
;
}
[
[
nodiscard
]
]
inline
HashNumber
HashString
(
const
char16_t
*
aStr
size_t
aLength
)
{
return
HashStringKnownLength
(
aStr
aLength
)
;
}
template
<
typename
WCharT
typename
=
typename
std
:
:
enable_if
<
std
:
:
is_same
<
WCharT
wchar_t
>
:
:
value
&
&
!
std
:
:
is_same
<
wchar_t
char16_t
>
:
:
value
>
:
:
type
>
[
[
nodiscard
]
]
inline
HashNumber
HashString
(
const
WCharT
*
aStr
)
{
return
HashStringUntilZero
(
aStr
)
;
}
template
<
typename
WCharT
typename
=
typename
std
:
:
enable_if
<
std
:
:
is_same
<
WCharT
wchar_t
>
:
:
value
&
&
!
std
:
:
is_same
<
wchar_t
char16_t
>
:
:
value
>
:
:
type
>
[
[
nodiscard
]
]
inline
HashNumber
HashString
(
const
WCharT
*
aStr
size_t
aLength
)
{
return
HashStringKnownLength
(
aStr
aLength
)
;
}
[
[
nodiscard
]
]
extern
MFBT_API
HashNumber
HashBytes
(
const
void
*
bytes
size_t
aLength
)
;
class
HashCodeScrambler
{
struct
SipHasher
;
uint64_t
mK0
mK1
;
public
:
constexpr
HashCodeScrambler
(
uint64_t
aK0
uint64_t
aK1
)
:
mK0
(
aK0
)
mK1
(
aK1
)
{
}
HashNumber
scramble
(
HashNumber
aHashCode
)
const
{
SipHasher
hasher
(
mK0
mK1
)
;
return
HashNumber
(
hasher
.
sipHash
(
aHashCode
)
)
;
}
static
constexpr
size_t
offsetOfMK0
(
)
{
return
offsetof
(
HashCodeScrambler
mK0
)
;
}
static
constexpr
size_t
offsetOfMK1
(
)
{
return
offsetof
(
HashCodeScrambler
mK1
)
;
}
private
:
struct
SipHasher
{
SipHasher
(
uint64_t
aK0
uint64_t
aK1
)
{
mV0
=
aK0
^
UINT64_C
(
0x736f6d6570736575
)
;
mV1
=
aK1
^
UINT64_C
(
0x646f72616e646f6d
)
;
mV2
=
aK0
^
UINT64_C
(
0x6c7967656e657261
)
;
mV3
=
aK1
^
UINT64_C
(
0x7465646279746573
)
;
}
uint64_t
sipHash
(
uint64_t
aM
)
{
mV3
^
=
aM
;
sipRound
(
)
;
mV0
^
=
aM
;
mV2
^
=
0xff
;
for
(
int
i
=
0
;
i
<
3
;
i
+
+
)
sipRound
(
)
;
return
mV0
^
mV1
^
mV2
^
mV3
;
}
void
sipRound
(
)
{
mV0
=
WrappingAdd
(
mV0
mV1
)
;
mV1
=
RotateLeft
(
mV1
13
)
;
mV1
^
=
mV0
;
mV0
=
RotateLeft
(
mV0
32
)
;
mV2
=
WrappingAdd
(
mV2
mV3
)
;
mV3
=
RotateLeft
(
mV3
16
)
;
mV3
^
=
mV2
;
mV0
=
WrappingAdd
(
mV0
mV3
)
;
mV3
=
RotateLeft
(
mV3
21
)
;
mV3
^
=
mV0
;
mV2
=
WrappingAdd
(
mV2
mV1
)
;
mV1
=
RotateLeft
(
mV1
17
)
;
mV1
^
=
mV2
;
mV2
=
RotateLeft
(
mV2
32
)
;
}
uint64_t
mV0
mV1
mV2
mV3
;
}
;
}
;
}
#
endif
