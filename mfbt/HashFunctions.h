#
ifndef
mozilla_HashFunctions_h
#
define
mozilla_HashFunctions_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Char16
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
Types
.
h
"
#
include
<
stdint
.
h
>
#
ifdef
__cplusplus
namespace
mozilla
{
static
const
uint32_t
kGoldenRatioU32
=
0x9E3779B9U
;
inline
uint32_t
RotateBitsLeft32
(
uint32_t
aValue
uint8_t
aBits
)
{
MOZ_ASSERT
(
aBits
<
32
)
;
return
(
aValue
<
<
aBits
)
|
(
aValue
>
>
(
32
-
aBits
)
)
;
}
namespace
detail
{
inline
uint32_t
AddU32ToHash
(
uint32_t
aHash
uint32_t
aValue
)
{
return
kGoldenRatioU32
*
(
RotateBitsLeft32
(
aHash
5
)
^
aValue
)
;
}
template
<
size_t
PtrSize
>
inline
uint32_t
AddUintptrToHash
(
uint32_t
aHash
uintptr_t
aValue
)
;
template
<
>
inline
uint32_t
AddUintptrToHash
<
4
>
(
uint32_t
aHash
uintptr_t
aValue
)
{
return
AddU32ToHash
(
aHash
static_cast
<
uint32_t
>
(
aValue
)
)
;
}
template
<
>
inline
uint32_t
AddUintptrToHash
<
8
>
(
uint32_t
aHash
uintptr_t
aValue
)
{
uint32_t
v1
=
static_cast
<
uint32_t
>
(
aValue
)
;
uint32_t
v2
=
static_cast
<
uint32_t
>
(
static_cast
<
uint64_t
>
(
aValue
)
>
>
32
)
;
return
AddU32ToHash
(
AddU32ToHash
(
aHash
v1
)
v2
)
;
}
}
template
<
typename
A
>
MOZ_MUST_USE
inline
uint32_t
AddToHash
(
uint32_t
aHash
A
aA
)
{
return
detail
:
:
AddU32ToHash
(
aHash
aA
)
;
}
template
<
typename
A
>
MOZ_MUST_USE
inline
uint32_t
AddToHash
(
uint32_t
aHash
A
*
aA
)
{
static_assert
(
sizeof
(
aA
)
=
=
sizeof
(
uintptr_t
)
"
Strange
pointer
!
"
)
;
return
detail
:
:
AddUintptrToHash
<
sizeof
(
uintptr_t
)
>
(
aHash
uintptr_t
(
aA
)
)
;
}
template
<
>
MOZ_MUST_USE
inline
uint32_t
AddToHash
(
uint32_t
aHash
uintptr_t
aA
)
{
return
detail
:
:
AddUintptrToHash
<
sizeof
(
uintptr_t
)
>
(
aHash
aA
)
;
}
template
<
typename
A
typename
.
.
.
Args
>
MOZ_MUST_USE
uint32_t
AddToHash
(
uint32_t
aHash
A
aArg
Args
.
.
.
aArgs
)
{
return
AddToHash
(
AddToHash
(
aHash
aArg
)
aArgs
.
.
.
)
;
}
template
<
typename
.
.
.
Args
>
MOZ_MUST_USE
inline
uint32_t
HashGeneric
(
Args
.
.
.
aArgs
)
{
return
AddToHash
(
0
aArgs
.
.
.
)
;
}
namespace
detail
{
template
<
typename
T
>
uint32_t
HashUntilZero
(
const
T
*
aStr
)
{
uint32_t
hash
=
0
;
for
(
T
c
;
(
c
=
*
aStr
)
;
aStr
+
+
)
{
hash
=
AddToHash
(
hash
c
)
;
}
return
hash
;
}
template
<
typename
T
>
uint32_t
HashKnownLength
(
const
T
*
aStr
size_t
aLength
)
{
uint32_t
hash
=
0
;
for
(
size_t
i
=
0
;
i
<
aLength
;
i
+
+
)
{
hash
=
AddToHash
(
hash
aStr
[
i
]
)
;
}
return
hash
;
}
}
MOZ_MUST_USE
inline
uint32_t
HashString
(
const
char
*
aStr
)
{
return
detail
:
:
HashUntilZero
(
reinterpret_cast
<
const
unsigned
char
*
>
(
aStr
)
)
;
}
MOZ_MUST_USE
inline
uint32_t
HashString
(
const
char
*
aStr
size_t
aLength
)
{
return
detail
:
:
HashKnownLength
(
reinterpret_cast
<
const
unsigned
char
*
>
(
aStr
)
aLength
)
;
}
MOZ_MUST_USE
inline
uint32_t
HashString
(
const
unsigned
char
*
aStr
size_t
aLength
)
{
return
detail
:
:
HashKnownLength
(
aStr
aLength
)
;
}
MOZ_MUST_USE
inline
uint32_t
HashString
(
const
char16_t
*
aStr
)
{
return
detail
:
:
HashUntilZero
(
aStr
)
;
}
MOZ_MUST_USE
inline
uint32_t
HashString
(
const
char16_t
*
aStr
size_t
aLength
)
{
return
detail
:
:
HashKnownLength
(
aStr
aLength
)
;
}
#
ifdef
WIN32
MOZ_MUST_USE
inline
uint32_t
HashString
(
const
wchar_t
*
aStr
)
{
return
detail
:
:
HashUntilZero
(
aStr
)
;
}
MOZ_MUST_USE
inline
uint32_t
HashString
(
const
wchar_t
*
aStr
size_t
aLength
)
{
return
detail
:
:
HashKnownLength
(
aStr
aLength
)
;
}
#
endif
MOZ_MUST_USE
extern
MFBT_API
uint32_t
HashBytes
(
const
void
*
bytes
size_t
aLength
)
;
class
HashCodeScrambler
{
struct
SipHasher
;
uint64_t
mK0
mK1
;
public
:
constexpr
HashCodeScrambler
(
uint64_t
aK0
uint64_t
aK1
)
:
mK0
(
aK0
)
mK1
(
aK1
)
{
}
uint32_t
scramble
(
uint32_t
aHashCode
)
const
{
SipHasher
hasher
(
mK0
mK1
)
;
return
uint32_t
(
hasher
.
sipHash
(
aHashCode
)
)
;
}
private
:
struct
SipHasher
{
SipHasher
(
uint64_t
aK0
uint64_t
aK1
)
{
mV0
=
aK0
^
UINT64_C
(
0x736f6d6570736575
)
;
mV1
=
aK1
^
UINT64_C
(
0x646f72616e646f6d
)
;
mV2
=
aK0
^
UINT64_C
(
0x6c7967656e657261
)
;
mV3
=
aK1
^
UINT64_C
(
0x7465646279746573
)
;
}
uint64_t
sipHash
(
uint64_t
aM
)
{
mV3
^
=
aM
;
sipRound
(
)
;
mV0
^
=
aM
;
mV2
^
=
0xff
;
for
(
int
i
=
0
;
i
<
3
;
i
+
+
)
sipRound
(
)
;
return
mV0
^
mV1
^
mV2
^
mV3
;
}
void
sipRound
(
)
{
mV0
+
=
mV1
;
mV1
=
RotateLeft
(
mV1
13
)
;
mV1
^
=
mV0
;
mV0
=
RotateLeft
(
mV0
32
)
;
mV2
+
=
mV3
;
mV3
=
RotateLeft
(
mV3
16
)
;
mV3
^
=
mV2
;
mV0
+
=
mV3
;
mV3
=
RotateLeft
(
mV3
21
)
;
mV3
^
=
mV0
;
mV2
+
=
mV1
;
mV1
=
RotateLeft
(
mV1
17
)
;
mV1
^
=
mV2
;
mV2
=
RotateLeft
(
mV2
32
)
;
}
uint64_t
mV0
mV1
mV2
mV3
;
}
;
}
;
}
#
endif
#
endif
