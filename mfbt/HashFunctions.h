#
ifndef
mozilla_HashFunctions_h
#
define
mozilla_HashFunctions_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Char16
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
Types
.
h
"
#
include
"
mozilla
/
WrappingOperations
.
h
"
#
include
<
stdint
.
h
>
namespace
mozilla
{
using
HashNumber
=
uint32_t
;
static
const
uint32_t
kHashNumberBits
=
32
;
static
const
HashNumber
kGoldenRatioU32
=
0x9E3779B9U
;
constexpr
HashNumber
ScrambleHashCode
(
HashNumber
h
)
{
return
mozilla
:
:
WrappingMultiply
(
h
kGoldenRatioU32
)
;
}
namespace
detail
{
MOZ_NO_SANITIZE_UNSIGNED_OVERFLOW
constexpr
HashNumber
RotateLeft5
(
HashNumber
aValue
)
{
return
(
aValue
<
<
5
)
|
(
aValue
>
>
27
)
;
}
constexpr
HashNumber
AddU32ToHash
(
HashNumber
aHash
uint32_t
aValue
)
{
return
mozilla
:
:
WrappingMultiply
(
kGoldenRatioU32
RotateLeft5
(
aHash
)
^
aValue
)
;
}
template
<
size_t
PtrSize
>
constexpr
HashNumber
AddUintptrToHash
(
HashNumber
aHash
uintptr_t
aValue
)
{
return
AddU32ToHash
(
aHash
static_cast
<
uint32_t
>
(
aValue
)
)
;
}
template
<
>
inline
HashNumber
AddUintptrToHash
<
8
>
(
HashNumber
aHash
uintptr_t
aValue
)
{
uint32_t
v1
=
static_cast
<
uint32_t
>
(
aValue
)
;
uint32_t
v2
=
static_cast
<
uint32_t
>
(
static_cast
<
uint64_t
>
(
aValue
)
>
>
32
)
;
return
AddU32ToHash
(
AddU32ToHash
(
aHash
v1
)
v2
)
;
}
}
template
<
typename
T
bool
TypeIsNotIntegral
=
!
mozilla
:
:
IsIntegral
<
T
>
:
:
value
typename
U
=
typename
mozilla
:
:
EnableIf
<
TypeIsNotIntegral
>
:
:
Type
>
MOZ_MUST_USE
inline
HashNumber
AddToHash
(
HashNumber
aHash
T
aA
)
{
return
detail
:
:
AddU32ToHash
(
aHash
aA
)
;
}
template
<
typename
A
>
MOZ_MUST_USE
inline
HashNumber
AddToHash
(
HashNumber
aHash
A
*
aA
)
{
static_assert
(
sizeof
(
aA
)
=
=
sizeof
(
uintptr_t
)
"
Strange
pointer
!
"
)
;
return
detail
:
:
AddUintptrToHash
<
sizeof
(
uintptr_t
)
>
(
aHash
uintptr_t
(
aA
)
)
;
}
template
<
typename
T
typename
U
=
typename
mozilla
:
:
EnableIf
<
mozilla
:
:
IsIntegral
<
T
>
:
:
value
>
:
:
Type
>
MOZ_MUST_USE
constexpr
HashNumber
AddToHash
(
HashNumber
aHash
T
aA
)
{
return
detail
:
:
AddUintptrToHash
<
sizeof
(
T
)
>
(
aHash
aA
)
;
}
template
<
typename
A
typename
.
.
.
Args
>
MOZ_MUST_USE
HashNumber
AddToHash
(
HashNumber
aHash
A
aArg
Args
.
.
.
aArgs
)
{
return
AddToHash
(
AddToHash
(
aHash
aArg
)
aArgs
.
.
.
)
;
}
template
<
typename
.
.
.
Args
>
MOZ_MUST_USE
inline
HashNumber
HashGeneric
(
Args
.
.
.
aArgs
)
{
return
AddToHash
(
0
aArgs
.
.
.
)
;
}
namespace
detail
{
template
<
typename
T
>
HashNumber
HashUntilZero
(
const
T
*
aStr
)
{
HashNumber
hash
=
0
;
for
(
T
c
;
(
c
=
*
aStr
)
;
aStr
+
+
)
{
hash
=
AddToHash
(
hash
c
)
;
}
return
hash
;
}
template
<
typename
T
>
constexpr
HashNumber
ConstExprHashUntilZero
(
const
T
*
aStr
HashNumber
aHash
)
{
return
!
*
aStr
?
aHash
:
ConstExprHashUntilZero
(
aStr
+
1
AddToHash
(
aHash
*
aStr
)
)
;
}
template
<
typename
T
>
HashNumber
HashKnownLength
(
const
T
*
aStr
size_t
aLength
)
{
HashNumber
hash
=
0
;
for
(
size_t
i
=
0
;
i
<
aLength
;
i
+
+
)
{
hash
=
AddToHash
(
hash
aStr
[
i
]
)
;
}
return
hash
;
}
}
MOZ_MUST_USE
inline
HashNumber
HashString
(
const
char
*
aStr
)
{
return
detail
:
:
HashUntilZero
(
reinterpret_cast
<
const
unsigned
char
*
>
(
aStr
)
)
;
}
MOZ_MUST_USE
inline
HashNumber
HashString
(
const
char
*
aStr
size_t
aLength
)
{
return
detail
:
:
HashKnownLength
(
reinterpret_cast
<
const
unsigned
char
*
>
(
aStr
)
aLength
)
;
}
MOZ_MUST_USE
inline
HashNumber
HashString
(
const
unsigned
char
*
aStr
size_t
aLength
)
{
return
detail
:
:
HashKnownLength
(
aStr
aLength
)
;
}
MOZ_MUST_USE
inline
HashNumber
HashString
(
const
char16_t
*
aStr
)
{
return
detail
:
:
HashUntilZero
(
aStr
)
;
}
MOZ_MUST_USE
constexpr
HashNumber
ConstExprHashString
(
const
char16_t
*
aStr
)
{
return
detail
:
:
ConstExprHashUntilZero
(
aStr
0
)
;
}
MOZ_MUST_USE
inline
HashNumber
HashString
(
const
char16_t
*
aStr
size_t
aLength
)
{
return
detail
:
:
HashKnownLength
(
aStr
aLength
)
;
}
#
ifdef
WIN32
MOZ_MUST_USE
inline
HashNumber
HashString
(
const
wchar_t
*
aStr
)
{
return
detail
:
:
HashUntilZero
(
aStr
)
;
}
MOZ_MUST_USE
inline
HashNumber
HashString
(
const
wchar_t
*
aStr
size_t
aLength
)
{
return
detail
:
:
HashKnownLength
(
aStr
aLength
)
;
}
#
endif
MOZ_MUST_USE
extern
MFBT_API
HashNumber
HashBytes
(
const
void
*
bytes
size_t
aLength
)
;
class
HashCodeScrambler
{
struct
SipHasher
;
uint64_t
mK0
mK1
;
public
:
constexpr
HashCodeScrambler
(
uint64_t
aK0
uint64_t
aK1
)
:
mK0
(
aK0
)
mK1
(
aK1
)
{
}
HashNumber
scramble
(
HashNumber
aHashCode
)
const
{
SipHasher
hasher
(
mK0
mK1
)
;
return
HashNumber
(
hasher
.
sipHash
(
aHashCode
)
)
;
}
private
:
struct
SipHasher
{
SipHasher
(
uint64_t
aK0
uint64_t
aK1
)
{
mV0
=
aK0
^
UINT64_C
(
0x736f6d6570736575
)
;
mV1
=
aK1
^
UINT64_C
(
0x646f72616e646f6d
)
;
mV2
=
aK0
^
UINT64_C
(
0x6c7967656e657261
)
;
mV3
=
aK1
^
UINT64_C
(
0x7465646279746573
)
;
}
uint64_t
sipHash
(
uint64_t
aM
)
{
mV3
^
=
aM
;
sipRound
(
)
;
mV0
^
=
aM
;
mV2
^
=
0xff
;
for
(
int
i
=
0
;
i
<
3
;
i
+
+
)
sipRound
(
)
;
return
mV0
^
mV1
^
mV2
^
mV3
;
}
void
sipRound
(
)
{
mV0
=
WrappingAdd
(
mV0
mV1
)
;
mV1
=
RotateLeft
(
mV1
13
)
;
mV1
^
=
mV0
;
mV0
=
RotateLeft
(
mV0
32
)
;
mV2
=
WrappingAdd
(
mV2
mV3
)
;
mV3
=
RotateLeft
(
mV3
16
)
;
mV3
^
=
mV2
;
mV0
=
WrappingAdd
(
mV0
mV3
)
;
mV3
=
RotateLeft
(
mV3
21
)
;
mV3
^
=
mV0
;
mV2
=
WrappingAdd
(
mV2
mV1
)
;
mV1
=
RotateLeft
(
mV1
17
)
;
mV1
^
=
mV2
;
mV2
=
RotateLeft
(
mV2
32
)
;
}
uint64_t
mV0
mV1
mV2
mV3
;
}
;
}
;
}
#
endif
