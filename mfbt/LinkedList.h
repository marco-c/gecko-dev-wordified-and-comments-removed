#
ifndef
mozilla_LinkedList_h
#
define
mozilla_LinkedList_h
#
include
<
utility
>
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
ifdef
__cplusplus
namespace
mozilla
{
template
<
typename
T
>
class
LinkedListElement
;
namespace
detail
{
template
<
typename
T
>
struct
LinkedListElementTraits
{
typedef
T
*
RawType
;
typedef
const
T
*
ConstRawType
;
typedef
T
*
ClientType
;
typedef
const
T
*
ConstClientType
;
static
void
enterList
(
LinkedListElement
<
T
>
*
elt
)
{
}
static
void
exitList
(
LinkedListElement
<
T
>
*
elt
)
{
}
static
void
cleanElement
(
LinkedListElement
<
T
>
*
elt
)
{
delete
elt
-
>
asT
(
)
;
}
}
;
template
<
typename
T
>
struct
LinkedListElementTraits
<
RefPtr
<
T
>
>
{
typedef
T
*
RawType
;
typedef
const
T
*
ConstRawType
;
typedef
RefPtr
<
T
>
ClientType
;
typedef
RefPtr
<
const
T
>
ConstClientType
;
static
void
enterList
(
LinkedListElement
<
RefPtr
<
T
>
>
*
elt
)
{
elt
-
>
asT
(
)
-
>
AddRef
(
)
;
}
static
void
exitList
(
LinkedListElement
<
RefPtr
<
T
>
>
*
elt
)
{
elt
-
>
asT
(
)
-
>
Release
(
)
;
}
static
void
cleanElement
(
LinkedListElement
<
RefPtr
<
T
>
>
*
elt
)
{
}
}
;
}
template
<
typename
T
>
class
LinkedList
;
template
<
typename
T
>
class
LinkedListElement
{
typedef
typename
detail
:
:
LinkedListElementTraits
<
T
>
Traits
;
typedef
typename
Traits
:
:
RawType
RawType
;
typedef
typename
Traits
:
:
ConstRawType
ConstRawType
;
typedef
typename
Traits
:
:
ClientType
ClientType
;
typedef
typename
Traits
:
:
ConstClientType
ConstClientType
;
private
:
LinkedListElement
*
mNext
;
LinkedListElement
*
mPrev
;
const
bool
mIsSentinel
;
public
:
LinkedListElement
(
)
:
mNext
(
this
)
mPrev
(
this
)
mIsSentinel
(
false
)
{
}
LinkedListElement
(
LinkedListElement
<
T
>
&
&
aOther
)
:
mIsSentinel
(
aOther
.
mIsSentinel
)
{
adjustLinkForMove
(
std
:
:
move
(
aOther
)
)
;
}
LinkedListElement
&
operator
=
(
LinkedListElement
<
T
>
&
&
aOther
)
{
MOZ_ASSERT
(
mIsSentinel
=
=
aOther
.
mIsSentinel
"
Mismatch
NodeKind
!
"
)
;
MOZ_ASSERT
(
!
isInList
(
)
"
Assigning
to
an
element
in
a
list
messes
up
that
list
!
"
)
;
adjustLinkForMove
(
std
:
:
move
(
aOther
)
)
;
return
*
this
;
}
~
LinkedListElement
(
)
{
if
(
!
mIsSentinel
&
&
isInList
(
)
)
{
remove
(
)
;
}
}
RawType
getNext
(
)
{
return
mNext
-
>
asT
(
)
;
}
ConstRawType
getNext
(
)
const
{
return
mNext
-
>
asT
(
)
;
}
RawType
getPrevious
(
)
{
return
mPrev
-
>
asT
(
)
;
}
ConstRawType
getPrevious
(
)
const
{
return
mPrev
-
>
asT
(
)
;
}
void
setNext
(
RawType
aElem
)
{
MOZ_ASSERT
(
isInList
(
)
)
;
setNextUnsafe
(
aElem
)
;
}
void
setPrevious
(
RawType
aElem
)
{
MOZ_ASSERT
(
isInList
(
)
)
;
setPreviousUnsafe
(
aElem
)
;
}
void
remove
(
)
{
MOZ_ASSERT
(
isInList
(
)
)
;
mPrev
-
>
mNext
=
mNext
;
mNext
-
>
mPrev
=
mPrev
;
mNext
=
this
;
mPrev
=
this
;
Traits
:
:
exitList
(
this
)
;
}
RawType
removeAndGetNext
(
)
{
RawType
r
=
getNext
(
)
;
remove
(
)
;
return
r
;
}
RawType
removeAndGetPrevious
(
)
{
RawType
r
=
getPrevious
(
)
;
remove
(
)
;
return
r
;
}
void
removeFrom
(
const
LinkedList
<
T
>
&
aList
)
{
aList
.
assertContains
(
asT
(
)
)
;
remove
(
)
;
}
bool
isInList
(
)
const
{
MOZ_ASSERT
(
(
mNext
=
=
this
)
=
=
(
mPrev
=
=
this
)
)
;
return
mNext
!
=
this
;
}
private
:
friend
class
LinkedList
<
T
>
;
friend
struct
detail
:
:
LinkedListElementTraits
<
T
>
;
enum
class
NodeKind
{
Normal
Sentinel
}
;
explicit
LinkedListElement
(
NodeKind
nodeKind
)
:
mNext
(
this
)
mPrev
(
this
)
mIsSentinel
(
nodeKind
=
=
NodeKind
:
:
Sentinel
)
{
}
RawType
asT
(
)
{
return
mIsSentinel
?
nullptr
:
static_cast
<
RawType
>
(
this
)
;
}
ConstRawType
asT
(
)
const
{
return
mIsSentinel
?
nullptr
:
static_cast
<
ConstRawType
>
(
this
)
;
}
void
setNextUnsafe
(
RawType
aElem
)
{
LinkedListElement
*
listElem
=
static_cast
<
LinkedListElement
*
>
(
aElem
)
;
MOZ_ASSERT
(
!
listElem
-
>
isInList
(
)
)
;
listElem
-
>
mNext
=
this
-
>
mNext
;
listElem
-
>
mPrev
=
this
;
this
-
>
mNext
-
>
mPrev
=
listElem
;
this
-
>
mNext
=
listElem
;
Traits
:
:
enterList
(
aElem
)
;
}
void
setPreviousUnsafe
(
RawType
aElem
)
{
LinkedListElement
<
T
>
*
listElem
=
static_cast
<
LinkedListElement
<
T
>
*
>
(
aElem
)
;
MOZ_ASSERT
(
!
listElem
-
>
isInList
(
)
)
;
listElem
-
>
mNext
=
this
;
listElem
-
>
mPrev
=
this
-
>
mPrev
;
this
-
>
mPrev
-
>
mNext
=
listElem
;
this
-
>
mPrev
=
listElem
;
Traits
:
:
enterList
(
aElem
)
;
}
void
adjustLinkForMove
(
LinkedListElement
<
T
>
&
&
aOther
)
{
if
(
!
aOther
.
isInList
(
)
)
{
mNext
=
this
;
mPrev
=
this
;
return
;
}
if
(
!
mIsSentinel
)
{
Traits
:
:
enterList
(
this
)
;
}
MOZ_ASSERT
(
aOther
.
mNext
-
>
mPrev
=
=
&
aOther
)
;
MOZ_ASSERT
(
aOther
.
mPrev
-
>
mNext
=
=
&
aOther
)
;
mNext
=
aOther
.
mNext
;
mPrev
=
aOther
.
mPrev
;
mNext
-
>
mPrev
=
this
;
mPrev
-
>
mNext
=
this
;
aOther
.
mNext
=
&
aOther
;
aOther
.
mPrev
=
&
aOther
;
if
(
!
mIsSentinel
)
{
Traits
:
:
exitList
(
&
aOther
)
;
}
}
LinkedListElement
&
operator
=
(
const
LinkedListElement
<
T
>
&
aOther
)
=
delete
;
LinkedListElement
(
const
LinkedListElement
<
T
>
&
aOther
)
=
delete
;
}
;
template
<
typename
T
>
class
LinkedList
{
private
:
typedef
typename
detail
:
:
LinkedListElementTraits
<
T
>
Traits
;
typedef
typename
Traits
:
:
RawType
RawType
;
typedef
typename
Traits
:
:
ConstRawType
ConstRawType
;
typedef
typename
Traits
:
:
ClientType
ClientType
;
typedef
typename
Traits
:
:
ConstClientType
ConstClientType
;
typedef
LinkedListElement
<
T
>
*
ElementType
;
typedef
const
LinkedListElement
<
T
>
*
ConstElementType
;
LinkedListElement
<
T
>
sentinel
;
public
:
template
<
typename
Type
typename
Element
>
class
Iterator
{
Type
mCurrent
;
public
:
using
iterator_category
=
std
:
:
forward_iterator_tag
;
using
value_type
=
T
;
using
difference_type
=
std
:
:
ptrdiff_t
;
using
pointer
=
T
*
;
using
reference
=
T
&
;
explicit
Iterator
(
Type
aCurrent
)
:
mCurrent
(
aCurrent
)
{
}
Type
operator
*
(
)
const
{
return
mCurrent
;
}
const
Iterator
&
operator
+
+
(
)
{
mCurrent
=
static_cast
<
Element
>
(
mCurrent
)
-
>
getNext
(
)
;
return
*
this
;
}
bool
operator
!
=
(
const
Iterator
&
aOther
)
const
{
return
mCurrent
!
=
aOther
.
mCurrent
;
}
}
;
LinkedList
(
)
:
sentinel
(
LinkedListElement
<
T
>
:
:
NodeKind
:
:
Sentinel
)
{
}
LinkedList
(
LinkedList
<
T
>
&
&
aOther
)
:
sentinel
(
std
:
:
move
(
aOther
.
sentinel
)
)
{
}
LinkedList
&
operator
=
(
LinkedList
<
T
>
&
&
aOther
)
{
MOZ_ASSERT
(
isEmpty
(
)
"
Assigning
to
a
non
-
empty
list
leaks
elements
in
that
list
!
"
)
;
sentinel
=
std
:
:
move
(
aOther
.
sentinel
)
;
return
*
this
;
}
~
LinkedList
(
)
{
MOZ_ASSERT
(
isEmpty
(
)
"
failing
this
assertion
means
this
LinkedList
'
s
creator
is
"
"
buggy
:
it
should
have
removed
all
this
list
'
s
elements
before
"
"
the
list
'
s
destruction
"
)
;
}
void
insertFront
(
RawType
aElem
)
{
sentinel
.
setNextUnsafe
(
aElem
)
;
}
void
insertBack
(
RawType
aElem
)
{
sentinel
.
setPreviousUnsafe
(
aElem
)
;
}
RawType
getFirst
(
)
{
return
sentinel
.
getNext
(
)
;
}
ConstRawType
getFirst
(
)
const
{
return
sentinel
.
getNext
(
)
;
}
RawType
getLast
(
)
{
return
sentinel
.
getPrevious
(
)
;
}
ConstRawType
getLast
(
)
const
{
return
sentinel
.
getPrevious
(
)
;
}
ClientType
popFirst
(
)
{
ClientType
ret
=
sentinel
.
getNext
(
)
;
if
(
ret
)
{
static_cast
<
LinkedListElement
<
T
>
*
>
(
RawType
(
ret
)
)
-
>
remove
(
)
;
}
return
ret
;
}
ClientType
popLast
(
)
{
ClientType
ret
=
sentinel
.
getPrevious
(
)
;
if
(
ret
)
{
static_cast
<
LinkedListElement
<
T
>
*
>
(
RawType
(
ret
)
)
-
>
remove
(
)
;
}
return
ret
;
}
bool
isEmpty
(
)
const
{
return
!
sentinel
.
isInList
(
)
;
}
bool
contains
(
ConstRawType
aElm
)
const
{
return
std
:
:
find
(
begin
(
)
end
(
)
aElm
)
!
=
end
(
)
;
}
void
clear
(
)
{
while
(
popFirst
(
)
)
{
}
}
size_t
length
(
)
const
{
size_t
length
=
0
;
ConstRawType
element
=
getFirst
(
)
;
while
(
element
)
{
length
+
+
;
element
=
element
-
>
getNext
(
)
;
}
return
length
;
}
Iterator
<
RawType
ElementType
>
begin
(
)
{
return
Iterator
<
RawType
ElementType
>
(
getFirst
(
)
)
;
}
Iterator
<
ConstRawType
ConstElementType
>
begin
(
)
const
{
return
Iterator
<
ConstRawType
ConstElementType
>
(
getFirst
(
)
)
;
}
Iterator
<
RawType
ElementType
>
end
(
)
{
return
Iterator
<
RawType
ElementType
>
(
nullptr
)
;
}
Iterator
<
ConstRawType
ConstElementType
>
end
(
)
const
{
return
Iterator
<
ConstRawType
ConstElementType
>
(
nullptr
)
;
}
size_t
sizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
0
;
ConstRawType
t
=
getFirst
(
)
;
while
(
t
)
{
n
+
=
aMallocSizeOf
(
t
)
;
t
=
static_cast
<
const
LinkedListElement
<
T
>
*
>
(
t
)
-
>
getNext
(
)
;
}
return
n
;
}
size_t
sizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
this
)
+
sizeOfExcludingThis
(
aMallocSizeOf
)
;
}
void
debugAssertIsSane
(
)
const
{
#
ifdef
DEBUG
const
LinkedListElement
<
T
>
*
slow
;
const
LinkedListElement
<
T
>
*
fast1
;
const
LinkedListElement
<
T
>
*
fast2
;
for
(
slow
=
sentinel
.
mNext
fast1
=
sentinel
.
mNext
-
>
mNext
fast2
=
sentinel
.
mNext
-
>
mNext
-
>
mNext
;
slow
!
=
&
sentinel
&
&
fast1
!
=
&
sentinel
&
&
fast2
!
=
&
sentinel
;
slow
=
slow
-
>
mNext
fast1
=
fast2
-
>
mNext
fast2
=
fast1
-
>
mNext
)
{
MOZ_ASSERT
(
slow
!
=
fast1
)
;
MOZ_ASSERT
(
slow
!
=
fast2
)
;
}
for
(
slow
=
sentinel
.
mPrev
fast1
=
sentinel
.
mPrev
-
>
mPrev
fast2
=
sentinel
.
mPrev
-
>
mPrev
-
>
mPrev
;
slow
!
=
&
sentinel
&
&
fast1
!
=
&
sentinel
&
&
fast2
!
=
&
sentinel
;
slow
=
slow
-
>
mPrev
fast1
=
fast2
-
>
mPrev
fast2
=
fast1
-
>
mPrev
)
{
MOZ_ASSERT
(
slow
!
=
fast1
)
;
MOZ_ASSERT
(
slow
!
=
fast2
)
;
}
for
(
const
LinkedListElement
<
T
>
*
elem
=
sentinel
.
mNext
;
elem
!
=
&
sentinel
;
elem
=
elem
-
>
mNext
)
{
MOZ_ASSERT
(
!
elem
-
>
mIsSentinel
)
;
}
const
LinkedListElement
<
T
>
*
prev
=
&
sentinel
;
const
LinkedListElement
<
T
>
*
cur
=
sentinel
.
mNext
;
do
{
MOZ_ASSERT
(
cur
-
>
mPrev
=
=
prev
)
;
MOZ_ASSERT
(
prev
-
>
mNext
=
=
cur
)
;
prev
=
cur
;
cur
=
cur
-
>
mNext
;
}
while
(
cur
!
=
&
sentinel
)
;
#
endif
}
private
:
friend
class
LinkedListElement
<
T
>
;
void
assertContains
(
const
RawType
aValue
)
const
{
#
ifdef
DEBUG
for
(
ConstRawType
elem
=
getFirst
(
)
;
elem
;
elem
=
elem
-
>
getNext
(
)
)
{
if
(
elem
=
=
aValue
)
{
return
;
}
}
MOZ_CRASH
(
"
element
wasn
'
t
found
in
this
list
!
"
)
;
#
endif
}
LinkedList
&
operator
=
(
const
LinkedList
<
T
>
&
aOther
)
=
delete
;
LinkedList
(
const
LinkedList
<
T
>
&
aOther
)
=
delete
;
}
;
template
<
typename
T
>
class
AutoCleanLinkedList
:
public
LinkedList
<
T
>
{
private
:
using
Traits
=
detail
:
:
LinkedListElementTraits
<
T
>
;
using
ClientType
=
typename
detail
:
:
LinkedListElementTraits
<
T
>
:
:
ClientType
;
public
:
~
AutoCleanLinkedList
(
)
{
clear
(
)
;
}
AutoCleanLinkedList
&
operator
=
(
AutoCleanLinkedList
&
&
aOther
)
=
default
;
void
clear
(
)
{
while
(
ClientType
element
=
this
-
>
popFirst
(
)
)
{
Traits
:
:
cleanElement
(
element
)
;
}
}
}
;
}
#
endif
#
endif
