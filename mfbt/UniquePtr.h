#
ifndef
mozilla_UniquePtr_h
#
define
mozilla_UniquePtr_h
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
CompactPair
.
h
"
#
include
"
mozilla
/
Compiler
.
h
"
namespace
mozilla
{
template
<
typename
T
>
class
DefaultDelete
;
template
<
typename
T
class
D
=
DefaultDelete
<
T
>
>
class
UniquePtr
;
}
namespace
mozilla
{
namespace
detail
{
struct
HasPointerTypeHelper
{
template
<
class
U
>
static
double
Test
(
.
.
.
)
;
template
<
class
U
>
static
char
Test
(
typename
U
:
:
pointer
*
=
0
)
;
}
;
template
<
class
T
>
class
HasPointerType
:
public
std
:
:
integral_constant
<
bool
sizeof
(
HasPointerTypeHelper
:
:
Test
<
T
>
(
0
)
)
=
=
1
>
{
}
;
template
<
class
T
class
D
bool
=
HasPointerType
<
D
>
:
:
value
>
struct
PointerTypeImpl
{
typedef
typename
D
:
:
pointer
Type
;
}
;
template
<
class
T
class
D
>
struct
PointerTypeImpl
<
T
D
false
>
{
typedef
T
*
Type
;
}
;
template
<
class
T
class
D
>
struct
PointerType
{
typedef
typename
PointerTypeImpl
<
T
std
:
:
remove_reference_t
<
D
>
>
:
:
Type
Type
;
}
;
}
template
<
typename
T
class
D
>
class
UniquePtr
{
public
:
typedef
T
ElementType
;
typedef
D
DeleterType
;
typedef
typename
detail
:
:
PointerType
<
T
DeleterType
>
:
:
Type
Pointer
;
private
:
mozilla
:
:
CompactPair
<
Pointer
DeleterType
>
mTuple
;
Pointer
&
ptr
(
)
{
return
mTuple
.
first
(
)
;
}
const
Pointer
&
ptr
(
)
const
{
return
mTuple
.
first
(
)
;
}
DeleterType
&
del
(
)
{
return
mTuple
.
second
(
)
;
}
const
DeleterType
&
del
(
)
const
{
return
mTuple
.
second
(
)
;
}
public
:
constexpr
UniquePtr
(
)
:
mTuple
(
static_cast
<
Pointer
>
(
nullptr
)
DeleterType
(
)
)
{
static_assert
(
!
std
:
:
is_pointer_v
<
D
>
"
must
provide
a
deleter
instance
"
)
;
static_assert
(
!
std
:
:
is_reference_v
<
D
>
"
must
provide
a
deleter
instance
"
)
;
}
explicit
UniquePtr
(
Pointer
aPtr
)
:
mTuple
(
aPtr
DeleterType
(
)
)
{
static_assert
(
!
std
:
:
is_pointer_v
<
D
>
"
must
provide
a
deleter
instance
"
)
;
static_assert
(
!
std
:
:
is_reference_v
<
D
>
"
must
provide
a
deleter
instance
"
)
;
}
UniquePtr
(
Pointer
aPtr
std
:
:
conditional_t
<
std
:
:
is_reference_v
<
D
>
D
const
D
&
>
aD1
)
:
mTuple
(
aPtr
aD1
)
{
}
UniquePtr
(
Pointer
aPtr
std
:
:
remove_reference_t
<
D
>
&
&
aD2
)
:
mTuple
(
aPtr
std
:
:
move
(
aD2
)
)
{
static_assert
(
!
std
:
:
is_reference_v
<
D
>
"
rvalue
deleter
can
'
t
be
stored
by
reference
"
)
;
}
UniquePtr
(
UniquePtr
&
&
aOther
)
:
mTuple
(
aOther
.
release
(
)
std
:
:
forward
<
DeleterType
>
(
aOther
.
get_deleter
(
)
)
)
{
}
MOZ_IMPLICIT
constexpr
UniquePtr
(
decltype
(
nullptr
)
)
:
UniquePtr
(
)
{
}
template
<
typename
U
class
E
>
MOZ_IMPLICIT
UniquePtr
(
UniquePtr
<
U
E
>
&
&
aOther
std
:
:
enable_if_t
<
std
:
:
is_convertible_v
<
typename
UniquePtr
<
U
E
>
:
:
Pointer
Pointer
>
&
&
!
std
:
:
is_array_v
<
U
>
&
&
(
std
:
:
is_reference_v
<
D
>
?
std
:
:
is_same_v
<
D
E
>
:
std
:
:
is_convertible_v
<
E
D
>
)
int
>
aDummy
=
0
)
:
mTuple
(
aOther
.
release
(
)
std
:
:
forward
<
E
>
(
aOther
.
get_deleter
(
)
)
)
{
}
~
UniquePtr
(
)
{
reset
(
nullptr
)
;
}
UniquePtr
&
operator
=
(
UniquePtr
&
&
aOther
)
{
reset
(
aOther
.
release
(
)
)
;
get_deleter
(
)
=
std
:
:
forward
<
DeleterType
>
(
aOther
.
get_deleter
(
)
)
;
return
*
this
;
}
template
<
typename
U
typename
E
>
UniquePtr
&
operator
=
(
UniquePtr
<
U
E
>
&
&
aOther
)
{
static_assert
(
std
:
:
is_convertible_v
<
typename
UniquePtr
<
U
E
>
:
:
Pointer
Pointer
>
"
incompatible
UniquePtr
pointees
"
)
;
static_assert
(
!
std
:
:
is_array_v
<
U
>
"
can
'
t
assign
from
UniquePtr
holding
an
array
"
)
;
reset
(
aOther
.
release
(
)
)
;
get_deleter
(
)
=
std
:
:
forward
<
E
>
(
aOther
.
get_deleter
(
)
)
;
return
*
this
;
}
UniquePtr
&
operator
=
(
decltype
(
nullptr
)
)
{
reset
(
nullptr
)
;
return
*
this
;
}
std
:
:
add_lvalue_reference_t
<
T
>
operator
*
(
)
const
{
MOZ_ASSERT
(
get
(
)
"
dereferencing
a
UniquePtr
containing
nullptr
with
*
"
)
;
return
*
get
(
)
;
}
Pointer
operator
-
>
(
)
const
{
MOZ_ASSERT
(
get
(
)
"
dereferencing
a
UniquePtr
containing
nullptr
with
-
>
"
)
;
return
get
(
)
;
}
explicit
operator
bool
(
)
const
{
return
get
(
)
!
=
nullptr
;
}
Pointer
get
(
)
const
{
return
ptr
(
)
;
}
DeleterType
&
get_deleter
(
)
{
return
del
(
)
;
}
const
DeleterType
&
get_deleter
(
)
const
{
return
del
(
)
;
}
[
[
nodiscard
]
]
Pointer
release
(
)
{
Pointer
p
=
ptr
(
)
;
ptr
(
)
=
nullptr
;
return
p
;
}
void
reset
(
Pointer
aPtr
=
Pointer
(
)
)
{
Pointer
old
=
ptr
(
)
;
ptr
(
)
=
aPtr
;
if
(
old
!
=
nullptr
)
{
get_deleter
(
)
(
old
)
;
}
}
void
swap
(
UniquePtr
&
aOther
)
{
mTuple
.
swap
(
aOther
.
mTuple
)
;
}
UniquePtr
(
const
UniquePtr
&
aOther
)
=
delete
;
void
operator
=
(
const
UniquePtr
&
aOther
)
=
delete
;
}
;
template
<
typename
T
class
D
>
class
UniquePtr
<
T
[
]
D
>
{
public
:
typedef
T
*
Pointer
;
typedef
T
ElementType
;
typedef
D
DeleterType
;
private
:
mozilla
:
:
CompactPair
<
Pointer
DeleterType
>
mTuple
;
public
:
constexpr
UniquePtr
(
)
:
mTuple
(
static_cast
<
Pointer
>
(
nullptr
)
DeleterType
(
)
)
{
static_assert
(
!
std
:
:
is_pointer_v
<
D
>
"
must
provide
a
deleter
instance
"
)
;
static_assert
(
!
std
:
:
is_reference_v
<
D
>
"
must
provide
a
deleter
instance
"
)
;
}
explicit
UniquePtr
(
Pointer
aPtr
)
:
mTuple
(
aPtr
DeleterType
(
)
)
{
static_assert
(
!
std
:
:
is_pointer_v
<
D
>
"
must
provide
a
deleter
instance
"
)
;
static_assert
(
!
std
:
:
is_reference_v
<
D
>
"
must
provide
a
deleter
instance
"
)
;
}
template
<
typename
U
>
UniquePtr
(
U
&
&
aU
std
:
:
enable_if_t
<
std
:
:
is_pointer_v
<
U
>
&
&
std
:
:
is_convertible_v
<
U
Pointer
>
int
>
aDummy
=
0
)
=
delete
;
UniquePtr
(
Pointer
aPtr
std
:
:
conditional_t
<
std
:
:
is_reference_v
<
D
>
D
const
D
&
>
aD1
)
:
mTuple
(
aPtr
aD1
)
{
}
UniquePtr
(
Pointer
aPtr
std
:
:
remove_reference_t
<
D
>
&
&
aD2
)
:
mTuple
(
aPtr
std
:
:
move
(
aD2
)
)
{
static_assert
(
!
std
:
:
is_reference_v
<
D
>
"
rvalue
deleter
can
'
t
be
stored
by
reference
"
)
;
}
template
<
typename
U
typename
V
>
UniquePtr
(
U
&
&
aU
V
&
&
aV
std
:
:
enable_if_t
<
std
:
:
is_pointer_v
<
U
>
&
&
std
:
:
is_convertible_v
<
U
Pointer
>
int
>
aDummy
=
0
)
=
delete
;
UniquePtr
(
UniquePtr
&
&
aOther
)
:
mTuple
(
aOther
.
release
(
)
std
:
:
forward
<
DeleterType
>
(
aOther
.
get_deleter
(
)
)
)
{
}
MOZ_IMPLICIT
UniquePtr
(
decltype
(
nullptr
)
)
:
mTuple
(
nullptr
DeleterType
(
)
)
{
static_assert
(
!
std
:
:
is_pointer_v
<
D
>
"
must
provide
a
deleter
instance
"
)
;
static_assert
(
!
std
:
:
is_reference_v
<
D
>
"
must
provide
a
deleter
instance
"
)
;
}
~
UniquePtr
(
)
{
reset
(
nullptr
)
;
}
UniquePtr
&
operator
=
(
UniquePtr
&
&
aOther
)
{
reset
(
aOther
.
release
(
)
)
;
get_deleter
(
)
=
std
:
:
forward
<
DeleterType
>
(
aOther
.
get_deleter
(
)
)
;
return
*
this
;
}
UniquePtr
&
operator
=
(
decltype
(
nullptr
)
)
{
reset
(
)
;
return
*
this
;
}
explicit
operator
bool
(
)
const
{
return
get
(
)
!
=
nullptr
;
}
T
&
operator
[
]
(
decltype
(
sizeof
(
int
)
)
aIndex
)
const
{
return
get
(
)
[
aIndex
]
;
}
Pointer
get
(
)
const
{
return
mTuple
.
first
(
)
;
}
DeleterType
&
get_deleter
(
)
{
return
mTuple
.
second
(
)
;
}
const
DeleterType
&
get_deleter
(
)
const
{
return
mTuple
.
second
(
)
;
}
[
[
nodiscard
]
]
Pointer
release
(
)
{
Pointer
p
=
mTuple
.
first
(
)
;
mTuple
.
first
(
)
=
nullptr
;
return
p
;
}
void
reset
(
Pointer
aPtr
=
Pointer
(
)
)
{
Pointer
old
=
mTuple
.
first
(
)
;
mTuple
.
first
(
)
=
aPtr
;
if
(
old
!
=
nullptr
)
{
mTuple
.
second
(
)
(
old
)
;
}
}
void
reset
(
decltype
(
nullptr
)
)
{
Pointer
old
=
mTuple
.
first
(
)
;
mTuple
.
first
(
)
=
nullptr
;
if
(
old
!
=
nullptr
)
{
mTuple
.
second
(
)
(
old
)
;
}
}
template
<
typename
U
>
void
reset
(
U
)
=
delete
;
void
swap
(
UniquePtr
&
aOther
)
{
mTuple
.
swap
(
aOther
.
mTuple
)
;
}
UniquePtr
(
const
UniquePtr
&
aOther
)
=
delete
;
void
operator
=
(
const
UniquePtr
&
aOther
)
=
delete
;
}
;
template
<
typename
T
>
class
DefaultDelete
{
public
:
constexpr
DefaultDelete
(
)
=
default
;
template
<
typename
U
>
MOZ_IMPLICIT
DefaultDelete
(
const
DefaultDelete
<
U
>
&
aOther
std
:
:
enable_if_t
<
std
:
:
is_convertible_v
<
U
*
T
*
>
int
>
aDummy
=
0
)
{
}
void
operator
(
)
(
T
*
aPtr
)
const
{
static_assert
(
sizeof
(
T
)
>
0
"
T
must
be
complete
"
)
;
delete
aPtr
;
}
}
;
template
<
typename
T
>
class
DefaultDelete
<
T
[
]
>
{
public
:
constexpr
DefaultDelete
(
)
=
default
;
void
operator
(
)
(
T
*
aPtr
)
const
{
static_assert
(
sizeof
(
T
)
>
0
"
T
must
be
complete
"
)
;
delete
[
]
aPtr
;
}
template
<
typename
U
>
void
operator
(
)
(
U
*
aPtr
)
const
=
delete
;
}
;
template
<
typename
T
class
D
typename
U
class
E
>
bool
operator
=
=
(
const
UniquePtr
<
T
D
>
&
aX
const
UniquePtr
<
U
E
>
&
aY
)
{
return
aX
.
get
(
)
=
=
aY
.
get
(
)
;
}
template
<
typename
T
class
D
typename
U
class
E
>
bool
operator
!
=
(
const
UniquePtr
<
T
D
>
&
aX
const
UniquePtr
<
U
E
>
&
aY
)
{
return
aX
.
get
(
)
!
=
aY
.
get
(
)
;
}
template
<
typename
T
class
D
>
bool
operator
=
=
(
const
UniquePtr
<
T
D
>
&
aX
const
T
*
aY
)
{
return
aX
.
get
(
)
=
=
aY
;
}
template
<
typename
T
class
D
>
bool
operator
=
=
(
const
T
*
aY
const
UniquePtr
<
T
D
>
&
aX
)
{
return
aY
=
=
aX
.
get
(
)
;
}
template
<
typename
T
class
D
>
bool
operator
!
=
(
const
UniquePtr
<
T
D
>
&
aX
const
T
*
aY
)
{
return
aX
.
get
(
)
!
=
aY
;
}
template
<
typename
T
class
D
>
bool
operator
!
=
(
const
T
*
aY
const
UniquePtr
<
T
D
>
&
aX
)
{
return
aY
!
=
aX
.
get
(
)
;
}
template
<
typename
T
class
D
>
bool
operator
=
=
(
const
UniquePtr
<
T
D
>
&
aX
decltype
(
nullptr
)
)
{
return
!
aX
;
}
template
<
typename
T
class
D
>
bool
operator
=
=
(
decltype
(
nullptr
)
const
UniquePtr
<
T
D
>
&
aX
)
{
return
!
aX
;
}
template
<
typename
T
class
D
>
bool
operator
!
=
(
const
UniquePtr
<
T
D
>
&
aX
decltype
(
nullptr
)
)
{
return
bool
(
aX
)
;
}
template
<
typename
T
class
D
>
bool
operator
!
=
(
decltype
(
nullptr
)
const
UniquePtr
<
T
D
>
&
aX
)
{
return
bool
(
aX
)
;
}
namespace
detail
{
template
<
typename
T
>
struct
UniqueSelector
{
typedef
UniquePtr
<
T
>
SingleObject
;
}
;
template
<
typename
T
>
struct
UniqueSelector
<
T
[
]
>
{
typedef
UniquePtr
<
T
[
]
>
UnknownBound
;
}
;
template
<
typename
T
decltype
(
sizeof
(
int
)
)
N
>
struct
UniqueSelector
<
T
[
N
]
>
{
typedef
UniquePtr
<
T
[
N
]
>
KnownBound
;
}
;
}
template
<
typename
T
typename
.
.
.
Args
>
typename
detail
:
:
UniqueSelector
<
T
>
:
:
SingleObject
MakeUnique
(
Args
&
&
.
.
.
aArgs
)
{
return
UniquePtr
<
T
>
(
new
T
(
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
)
;
}
template
<
typename
T
>
typename
detail
:
:
UniqueSelector
<
T
>
:
:
UnknownBound
MakeUnique
(
decltype
(
sizeof
(
int
)
)
aN
)
{
using
ArrayType
=
std
:
:
remove_extent_t
<
T
>
;
return
UniquePtr
<
T
>
(
new
ArrayType
[
aN
]
(
)
)
;
}
template
<
typename
T
typename
.
.
.
Args
>
typename
detail
:
:
UniqueSelector
<
T
>
:
:
KnownBound
MakeUnique
(
Args
&
&
.
.
.
aArgs
)
=
delete
;
template
<
typename
T
>
typename
detail
:
:
UniqueSelector
<
T
>
:
:
SingleObject
WrapUnique
(
T
*
aPtr
)
{
return
UniquePtr
<
T
>
(
aPtr
)
;
}
}
namespace
std
{
template
<
typename
T
class
D
>
void
swap
(
mozilla
:
:
UniquePtr
<
T
D
>
&
aX
mozilla
:
:
UniquePtr
<
T
D
>
&
aY
)
{
aX
.
swap
(
aY
)
;
}
}
#
endif
