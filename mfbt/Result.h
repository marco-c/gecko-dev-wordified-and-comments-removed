#
ifndef
mozilla_Result_h
#
define
mozilla_Result_h
#
include
"
mozilla
/
Alignment
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Types
.
h
"
#
include
"
mozilla
/
TypeTraits
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
namespace
mozilla
{
struct
Ok
{
}
;
template
<
typename
E
>
class
GenericErrorResult
;
namespace
detail
{
enum
class
VEmptiness
{
IsEmpty
IsNotEmpty
}
;
enum
class
Alignedness
{
IsAligned
IsNotAligned
}
;
template
<
typename
V
typename
E
VEmptiness
EmptinessOfV
Alignedness
Aligned
>
class
ResultImplementation
{
mozilla
:
:
Variant
<
V
E
>
mStorage
;
public
:
explicit
ResultImplementation
(
V
aValue
)
:
mStorage
(
aValue
)
{
}
explicit
ResultImplementation
(
E
aErrorValue
)
:
mStorage
(
aErrorValue
)
{
}
bool
isOk
(
)
const
{
return
mStorage
.
template
is
<
V
>
(
)
;
}
V
unwrap
(
)
const
{
return
mStorage
.
template
as
<
V
>
(
)
;
}
E
unwrapErr
(
)
const
{
return
mStorage
.
template
as
<
E
>
(
)
;
}
}
;
template
<
typename
V
typename
E
VEmptiness
EmptinessOfV
Alignedness
Aligned
>
class
ResultImplementation
<
V
E
&
EmptinessOfV
Aligned
>
{
mozilla
:
:
Variant
<
V
E
*
>
mStorage
;
public
:
explicit
ResultImplementation
(
V
aValue
)
:
mStorage
(
aValue
)
{
}
explicit
ResultImplementation
(
E
&
aErrorValue
)
:
mStorage
(
&
aErrorValue
)
{
}
bool
isOk
(
)
const
{
return
mStorage
.
template
is
<
V
>
(
)
;
}
V
unwrap
(
)
const
{
return
mStorage
.
template
as
<
V
>
(
)
;
}
E
&
unwrapErr
(
)
const
{
return
*
mStorage
.
template
as
<
E
*
>
(
)
;
}
}
;
template
<
typename
V
typename
E
Alignedness
Aligned
>
class
ResultImplementation
<
V
E
&
VEmptiness
:
:
IsEmpty
Aligned
>
{
E
*
mErrorValue
;
public
:
explicit
ResultImplementation
(
V
)
:
mErrorValue
(
nullptr
)
{
}
explicit
ResultImplementation
(
E
&
aErrorValue
)
:
mErrorValue
(
&
aErrorValue
)
{
}
bool
isOk
(
)
const
{
return
mErrorValue
=
=
nullptr
;
}
V
unwrap
(
)
const
{
return
V
(
)
;
}
E
&
unwrapErr
(
)
const
{
return
*
mErrorValue
;
}
}
;
template
<
typename
V
typename
E
VEmptiness
EmptinessOfV
>
class
ResultImplementation
<
V
*
E
&
EmptinessOfV
Alignedness
:
:
IsAligned
>
{
uintptr_t
mBits
;
public
:
explicit
ResultImplementation
(
V
*
aValue
)
:
mBits
(
reinterpret_cast
<
uintptr_t
>
(
aValue
)
)
{
MOZ_ASSERT
(
(
uintptr_t
(
aValue
)
%
MOZ_ALIGNOF
(
V
)
)
=
=
0
"
Result
value
pointers
must
not
be
misaligned
"
)
;
}
explicit
ResultImplementation
(
E
&
aErrorValue
)
:
mBits
(
reinterpret_cast
<
uintptr_t
>
(
&
aErrorValue
)
|
1
)
{
MOZ_ASSERT
(
(
uintptr_t
(
&
aErrorValue
)
%
MOZ_ALIGNOF
(
E
)
)
=
=
0
"
Result
errors
must
not
be
misaligned
"
)
;
}
bool
isOk
(
)
const
{
return
(
mBits
&
1
)
=
=
0
;
}
V
*
unwrap
(
)
const
{
return
reinterpret_cast
<
V
*
>
(
mBits
)
;
}
E
&
unwrapErr
(
)
const
{
return
*
reinterpret_cast
<
E
*
>
(
mBits
&
~
uintptr_t
(
1
)
)
;
}
}
;
template
<
typename
T
>
struct
HasFreeLSB
{
static
const
bool
value
=
false
;
}
;
template
<
typename
T
>
struct
HasFreeLSB
<
T
*
>
{
static
const
bool
value
=
(
MOZ_ALIGNOF
(
T
)
&
1
)
=
=
0
;
}
;
template
<
typename
T
>
struct
HasFreeLSB
<
T
&
>
{
static
const
bool
value
=
HasFreeLSB
<
T
*
>
:
:
value
;
}
;
}
template
<
typename
V
typename
E
>
class
MOZ_MUST_USE_TYPE
Result
final
{
using
Impl
=
detail
:
:
ResultImplementation
<
V
E
IsEmpty
<
V
>
:
:
value
?
detail
:
:
VEmptiness
:
:
IsEmpty
:
detail
:
:
VEmptiness
:
:
IsNotEmpty
(
detail
:
:
HasFreeLSB
<
V
>
:
:
value
&
&
detail
:
:
HasFreeLSB
<
E
>
:
:
value
)
?
detail
:
:
Alignedness
:
:
IsAligned
:
detail
:
:
Alignedness
:
:
IsNotAligned
>
;
Impl
mImpl
;
public
:
MOZ_IMPLICIT
Result
(
V
aValue
)
:
mImpl
(
aValue
)
{
MOZ_ASSERT
(
isOk
(
)
)
;
}
explicit
Result
(
E
aErrorValue
)
:
mImpl
(
aErrorValue
)
{
MOZ_ASSERT
(
isErr
(
)
)
;
}
template
<
typename
E2
>
MOZ_IMPLICIT
Result
(
const
GenericErrorResult
<
E2
>
&
aErrorResult
)
:
mImpl
(
aErrorResult
.
mErrorValue
)
{
static_assert
(
mozilla
:
:
IsConvertible
<
E2
E
>
:
:
value
"
E2
must
be
convertible
to
E
"
)
;
MOZ_ASSERT
(
isErr
(
)
)
;
}
Result
(
const
Result
&
)
=
default
;
Result
&
operator
=
(
const
Result
&
)
=
default
;
bool
isOk
(
)
const
{
return
mImpl
.
isOk
(
)
;
}
bool
isErr
(
)
const
{
return
!
mImpl
.
isOk
(
)
;
}
V
unwrap
(
)
const
{
MOZ_ASSERT
(
isOk
(
)
)
;
return
mImpl
.
unwrap
(
)
;
}
E
unwrapErr
(
)
const
{
MOZ_ASSERT
(
isErr
(
)
)
;
return
mImpl
.
unwrapErr
(
)
;
}
}
;
template
<
typename
E
>
class
MOZ_MUST_USE_TYPE
GenericErrorResult
{
E
mErrorValue
;
template
<
typename
V
typename
E2
>
friend
class
Result
;
public
:
explicit
GenericErrorResult
(
E
aErrorValue
)
:
mErrorValue
(
aErrorValue
)
{
}
}
;
template
<
typename
E
>
inline
GenericErrorResult
<
E
>
MakeGenericErrorResult
(
E
&
&
aErrorValue
)
{
return
GenericErrorResult
<
E
>
(
aErrorValue
)
;
}
}
#
define
MOZ_TRY
(
expr
)
\
do
{
\
auto
mozTryTempResult_
=
(
expr
)
;
\
if
(
mozTryTempResult_
.
isErr
(
)
)
{
\
return
:
:
mozilla
:
:
MakeGenericErrorResult
(
mozTryTempResult_
.
unwrapErr
(
)
)
;
\
}
\
}
while
(
0
)
#
define
MOZ_TRY_VAR
(
target
expr
)
\
do
{
\
auto
mozTryVarTempResult_
=
(
expr
)
;
\
if
(
mozTryVarTempResult_
.
isErr
(
)
)
{
\
return
:
:
mozilla
:
:
MakeGenericErrorResult
(
\
mozTryVarTempResult_
.
unwrapErr
(
)
)
;
\
}
\
(
target
)
=
mozTryVarTempResult_
.
unwrap
(
)
;
\
}
while
(
0
)
#
endif
