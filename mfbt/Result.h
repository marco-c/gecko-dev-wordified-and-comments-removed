#
ifndef
mozilla_Result_h
#
define
mozilla_Result_h
#
include
"
mozilla
/
Alignment
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Types
.
h
"
#
include
"
mozilla
/
TypeTraits
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
namespace
mozilla
{
struct
Ok
{
}
;
template
<
typename
E
>
class
GenericErrorResult
;
template
<
typename
V
typename
E
>
class
Result
;
namespace
detail
{
enum
class
PackingStrategy
{
Variant
NullIsOk
LowBitTagIsError
}
;
template
<
typename
V
typename
E
PackingStrategy
Strategy
>
class
ResultImplementation
;
template
<
typename
V
typename
E
>
class
ResultImplementation
<
V
E
PackingStrategy
:
:
Variant
>
{
mozilla
:
:
Variant
<
V
E
>
mStorage
;
public
:
explicit
ResultImplementation
(
V
aValue
)
:
mStorage
(
aValue
)
{
}
explicit
ResultImplementation
(
E
aErrorValue
)
:
mStorage
(
aErrorValue
)
{
}
bool
isOk
(
)
const
{
return
mStorage
.
template
is
<
V
>
(
)
;
}
V
unwrap
(
)
const
{
return
mStorage
.
template
as
<
V
>
(
)
;
}
E
unwrapErr
(
)
const
{
return
mStorage
.
template
as
<
E
>
(
)
;
}
}
;
template
<
typename
V
typename
E
>
class
ResultImplementation
<
V
E
&
PackingStrategy
:
:
Variant
>
{
mozilla
:
:
Variant
<
V
E
*
>
mStorage
;
public
:
explicit
ResultImplementation
(
V
aValue
)
:
mStorage
(
aValue
)
{
}
explicit
ResultImplementation
(
E
&
aErrorValue
)
:
mStorage
(
&
aErrorValue
)
{
}
bool
isOk
(
)
const
{
return
mStorage
.
template
is
<
V
>
(
)
;
}
V
unwrap
(
)
const
{
return
mStorage
.
template
as
<
V
>
(
)
;
}
E
&
unwrapErr
(
)
const
{
return
*
mStorage
.
template
as
<
E
*
>
(
)
;
}
}
;
template
<
typename
V
typename
E
>
class
ResultImplementation
<
V
E
&
PackingStrategy
:
:
NullIsOk
>
{
E
*
mErrorValue
;
public
:
explicit
ResultImplementation
(
V
)
:
mErrorValue
(
nullptr
)
{
}
explicit
ResultImplementation
(
E
&
aErrorValue
)
:
mErrorValue
(
&
aErrorValue
)
{
}
bool
isOk
(
)
const
{
return
mErrorValue
=
=
nullptr
;
}
V
unwrap
(
)
const
{
return
V
(
)
;
}
E
&
unwrapErr
(
)
const
{
return
*
mErrorValue
;
}
}
;
template
<
typename
V
typename
E
>
class
ResultImplementation
<
V
*
E
&
PackingStrategy
:
:
LowBitTagIsError
>
{
uintptr_t
mBits
;
public
:
explicit
ResultImplementation
(
V
*
aValue
)
:
mBits
(
reinterpret_cast
<
uintptr_t
>
(
aValue
)
)
{
MOZ_ASSERT
(
(
uintptr_t
(
aValue
)
%
MOZ_ALIGNOF
(
V
)
)
=
=
0
"
Result
value
pointers
must
not
be
misaligned
"
)
;
}
explicit
ResultImplementation
(
E
&
aErrorValue
)
:
mBits
(
reinterpret_cast
<
uintptr_t
>
(
&
aErrorValue
)
|
1
)
{
MOZ_ASSERT
(
(
uintptr_t
(
&
aErrorValue
)
%
MOZ_ALIGNOF
(
E
)
)
=
=
0
"
Result
errors
must
not
be
misaligned
"
)
;
}
bool
isOk
(
)
const
{
return
(
mBits
&
1
)
=
=
0
;
}
V
*
unwrap
(
)
const
{
return
reinterpret_cast
<
V
*
>
(
mBits
)
;
}
E
&
unwrapErr
(
)
const
{
return
*
reinterpret_cast
<
E
*
>
(
mBits
^
1
)
;
}
}
;
template
<
typename
T
>
struct
UnusedZero
{
static
const
bool
value
=
false
;
}
;
template
<
typename
T
>
struct
UnusedZero
<
T
&
>
{
static
const
bool
value
=
true
;
}
;
template
<
typename
T
>
struct
HasFreeLSB
{
static
const
bool
value
=
false
;
}
;
template
<
typename
T
>
struct
HasFreeLSB
<
T
*
>
{
static
const
bool
value
=
(
MOZ_ALIGNOF
(
T
)
&
1
)
=
=
0
;
}
;
template
<
typename
T
>
struct
HasFreeLSB
<
T
&
>
{
static
const
bool
value
=
HasFreeLSB
<
T
*
>
:
:
value
;
}
;
template
<
typename
V
typename
E
>
struct
SelectResultImpl
{
static
const
PackingStrategy
value
=
(
IsEmpty
<
V
>
:
:
value
&
&
UnusedZero
<
E
>
:
:
value
)
?
PackingStrategy
:
:
NullIsOk
:
(
detail
:
:
HasFreeLSB
<
V
>
:
:
value
&
&
detail
:
:
HasFreeLSB
<
E
>
:
:
value
)
?
PackingStrategy
:
:
LowBitTagIsError
:
PackingStrategy
:
:
Variant
;
using
Type
=
detail
:
:
ResultImplementation
<
V
E
value
>
;
}
;
template
<
typename
T
>
struct
IsResult
:
FalseType
{
}
;
template
<
typename
V
typename
E
>
struct
IsResult
<
Result
<
V
E
>
>
:
TrueType
{
}
;
}
template
<
typename
V
typename
E
>
class
MOZ_MUST_USE_TYPE
Result
final
{
using
Impl
=
typename
detail
:
:
SelectResultImpl
<
V
E
>
:
:
Type
;
Impl
mImpl
;
public
:
MOZ_IMPLICIT
Result
(
V
aValue
)
:
mImpl
(
aValue
)
{
MOZ_ASSERT
(
isOk
(
)
)
;
}
explicit
Result
(
E
aErrorValue
)
:
mImpl
(
aErrorValue
)
{
MOZ_ASSERT
(
isErr
(
)
)
;
}
template
<
typename
E2
>
MOZ_IMPLICIT
Result
(
const
GenericErrorResult
<
E2
>
&
aErrorResult
)
:
mImpl
(
aErrorResult
.
mErrorValue
)
{
static_assert
(
mozilla
:
:
IsConvertible
<
E2
E
>
:
:
value
"
E2
must
be
convertible
to
E
"
)
;
MOZ_ASSERT
(
isErr
(
)
)
;
}
Result
(
const
Result
&
)
=
default
;
Result
&
operator
=
(
const
Result
&
)
=
default
;
bool
isOk
(
)
const
{
return
mImpl
.
isOk
(
)
;
}
bool
isErr
(
)
const
{
return
!
mImpl
.
isOk
(
)
;
}
V
unwrap
(
)
const
{
MOZ_ASSERT
(
isOk
(
)
)
;
return
mImpl
.
unwrap
(
)
;
}
E
unwrapErr
(
)
const
{
MOZ_ASSERT
(
isErr
(
)
)
;
return
mImpl
.
unwrapErr
(
)
;
}
template
<
typename
F
>
auto
map
(
F
f
)
const
-
>
Result
<
decltype
(
f
(
*
(
(
V
*
)
nullptr
)
)
)
E
>
{
using
RetResult
=
Result
<
decltype
(
f
(
*
(
(
V
*
)
nullptr
)
)
)
E
>
;
return
isOk
(
)
?
RetResult
(
f
(
unwrap
(
)
)
)
:
RetResult
(
unwrapErr
(
)
)
;
}
template
<
typename
F
typename
=
typename
EnableIf
<
detail
:
:
IsResult
<
decltype
(
(
*
(
(
F
*
)
nullptr
)
)
(
*
(
(
V
*
)
nullptr
)
)
)
>
:
:
value
>
:
:
Type
>
auto
andThen
(
F
f
)
const
-
>
decltype
(
f
(
*
(
(
V
*
)
nullptr
)
)
)
{
return
isOk
(
)
?
f
(
unwrap
(
)
)
:
GenericErrorResult
<
E
>
(
unwrapErr
(
)
)
;
}
}
;
template
<
typename
E
>
class
MOZ_MUST_USE_TYPE
GenericErrorResult
{
E
mErrorValue
;
template
<
typename
V
typename
E2
>
friend
class
Result
;
public
:
explicit
GenericErrorResult
(
E
aErrorValue
)
:
mErrorValue
(
aErrorValue
)
{
}
}
;
template
<
typename
E
>
inline
GenericErrorResult
<
E
>
MakeGenericErrorResult
(
E
&
&
aErrorValue
)
{
return
GenericErrorResult
<
E
>
(
aErrorValue
)
;
}
}
#
define
MOZ_TRY
(
expr
)
\
do
{
\
auto
mozTryTempResult_
=
(
expr
)
;
\
if
(
mozTryTempResult_
.
isErr
(
)
)
{
\
return
:
:
mozilla
:
:
MakeGenericErrorResult
(
mozTryTempResult_
.
unwrapErr
(
)
)
;
\
}
\
}
while
(
0
)
#
define
MOZ_TRY_VAR
(
target
expr
)
\
do
{
\
auto
mozTryVarTempResult_
=
(
expr
)
;
\
if
(
mozTryVarTempResult_
.
isErr
(
)
)
{
\
return
:
:
mozilla
:
:
MakeGenericErrorResult
(
\
mozTryVarTempResult_
.
unwrapErr
(
)
)
;
\
}
\
(
target
)
=
mozTryVarTempResult_
.
unwrap
(
)
;
\
}
while
(
0
)
#
endif
