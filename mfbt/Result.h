#
ifndef
mozilla_Result_h
#
define
mozilla_Result_h
#
include
<
algorithm
>
#
include
<
cstdint
>
#
include
<
cstring
>
#
include
<
type_traits
>
#
include
"
mozilla
/
Alignment
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
CompactPair
.
h
"
#
include
"
mozilla
/
Types
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
namespace
mozilla
{
struct
Ok
{
}
;
template
<
typename
E
>
class
GenericErrorResult
;
template
<
typename
V
typename
E
>
class
Result
;
namespace
detail
{
enum
class
PackingStrategy
{
Variant
NullIsOk
LowBitTagIsError
PackedVariant
}
;
template
<
typename
T
>
struct
UnusedZero
;
template
<
typename
V
typename
E
PackingStrategy
Strategy
>
class
ResultImplementation
;
template
<
typename
V
typename
E
>
class
ResultImplementation
<
V
E
PackingStrategy
:
:
Variant
>
{
mozilla
:
:
Variant
<
V
E
>
mStorage
;
public
:
ResultImplementation
(
ResultImplementation
&
&
)
=
default
;
ResultImplementation
(
const
ResultImplementation
&
)
=
delete
;
ResultImplementation
&
operator
=
(
const
ResultImplementation
&
)
=
delete
;
ResultImplementation
&
operator
=
(
ResultImplementation
&
&
)
=
default
;
explicit
ResultImplementation
(
V
&
&
aValue
)
:
mStorage
(
std
:
:
forward
<
V
>
(
aValue
)
)
{
}
explicit
ResultImplementation
(
const
V
&
aValue
)
:
mStorage
(
aValue
)
{
}
template
<
typename
.
.
.
Args
>
explicit
ResultImplementation
(
std
:
:
in_place_t
Args
&
&
.
.
.
aArgs
)
:
mStorage
(
VariantType
<
V
>
{
}
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
{
}
explicit
ResultImplementation
(
const
E
&
aErrorValue
)
:
mStorage
(
aErrorValue
)
{
}
explicit
ResultImplementation
(
E
&
&
aErrorValue
)
:
mStorage
(
std
:
:
forward
<
E
>
(
aErrorValue
)
)
{
}
bool
isOk
(
)
const
{
return
mStorage
.
template
is
<
V
>
(
)
;
}
V
unwrap
(
)
{
return
std
:
:
move
(
mStorage
.
template
as
<
V
>
(
)
)
;
}
const
V
&
inspect
(
)
const
{
return
mStorage
.
template
as
<
V
>
(
)
;
}
E
unwrapErr
(
)
{
return
std
:
:
move
(
mStorage
.
template
as
<
E
>
(
)
)
;
}
const
E
&
inspectErr
(
)
const
{
return
mStorage
.
template
as
<
E
>
(
)
;
}
}
;
template
<
typename
V
>
struct
EmptyWrapper
:
V
{
const
V
*
addr
(
)
const
{
return
this
;
}
V
*
addr
(
)
{
return
this
;
}
}
;
template
<
typename
V
>
using
AlignedStorageOrEmpty
=
std
:
:
conditional_t
<
std
:
:
is_empty_v
<
V
>
EmptyWrapper
<
V
>
AlignedStorage2
<
V
>
>
;
template
<
typename
V
typename
E
>
class
ResultImplementationNullIsOkBase
{
protected
:
using
ErrorStorageType
=
typename
UnusedZero
<
E
>
:
:
StorageType
;
static
constexpr
auto
kNullValue
=
UnusedZero
<
E
>
:
:
nullValue
;
static
inline
auto
GetMovedFromMarker
(
)
{
return
UnusedZero
<
E
>
:
:
GetDefaultValue
(
)
;
}
static_assert
(
std
:
:
is_trivially_copyable_v
<
ErrorStorageType
>
)
;
static_assert
(
kNullValue
=
=
decltype
(
kNullValue
)
(
0
)
)
;
CompactPair
<
AlignedStorageOrEmpty
<
V
>
ErrorStorageType
>
mValue
;
public
:
explicit
ResultImplementationNullIsOkBase
(
const
V
&
aSuccessValue
)
:
mValue
(
std
:
:
piecewise_construct
std
:
:
tuple
<
>
(
)
std
:
:
tuple
(
kNullValue
)
)
{
if
constexpr
(
!
std
:
:
is_empty_v
<
V
>
)
{
new
(
mValue
.
first
(
)
.
addr
(
)
)
V
(
aSuccessValue
)
;
}
}
explicit
ResultImplementationNullIsOkBase
(
V
&
&
aSuccessValue
)
:
mValue
(
std
:
:
piecewise_construct
std
:
:
tuple
<
>
(
)
std
:
:
tuple
(
kNullValue
)
)
{
if
constexpr
(
!
std
:
:
is_empty_v
<
V
>
)
{
new
(
mValue
.
first
(
)
.
addr
(
)
)
V
(
std
:
:
move
(
aSuccessValue
)
)
;
}
}
template
<
typename
.
.
.
Args
>
explicit
ResultImplementationNullIsOkBase
(
std
:
:
in_place_t
Args
&
&
.
.
.
aArgs
)
:
mValue
(
std
:
:
piecewise_construct
std
:
:
tuple
<
>
(
)
std
:
:
tuple
(
kNullValue
)
)
{
if
constexpr
(
!
std
:
:
is_empty_v
<
V
>
)
{
new
(
mValue
.
first
(
)
.
addr
(
)
)
V
(
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
;
}
}
explicit
ResultImplementationNullIsOkBase
(
E
aErrorValue
)
:
mValue
(
std
:
:
piecewise_construct
std
:
:
tuple
<
>
(
)
std
:
:
tuple
(
UnusedZero
<
E
>
:
:
Store
(
std
:
:
move
(
aErrorValue
)
)
)
)
{
MOZ_ASSERT
(
mValue
.
second
(
)
!
=
kNullValue
)
;
}
ResultImplementationNullIsOkBase
(
ResultImplementationNullIsOkBase
&
&
aOther
)
:
mValue
(
std
:
:
piecewise_construct
std
:
:
tuple
<
>
(
)
std
:
:
tuple
(
std
:
:
move
(
aOther
.
mValue
.
second
(
)
)
)
)
{
if
constexpr
(
!
std
:
:
is_empty_v
<
V
>
)
{
if
(
isOk
(
)
)
{
new
(
mValue
.
first
(
)
.
addr
(
)
)
V
(
std
:
:
move
(
*
aOther
.
mValue
.
first
(
)
.
addr
(
)
)
)
;
aOther
.
mValue
.
first
(
)
.
addr
(
)
-
>
~
V
(
)
;
aOther
.
mValue
.
second
(
)
=
GetMovedFromMarker
(
)
;
}
}
}
ResultImplementationNullIsOkBase
&
operator
=
(
ResultImplementationNullIsOkBase
&
&
aOther
)
{
if
constexpr
(
!
std
:
:
is_empty_v
<
V
>
)
{
if
(
isOk
(
)
)
{
mValue
.
first
(
)
.
addr
(
)
-
>
~
V
(
)
;
}
}
mValue
.
second
(
)
=
std
:
:
move
(
aOther
.
mValue
.
second
(
)
)
;
if
constexpr
(
!
std
:
:
is_empty_v
<
V
>
)
{
if
(
isOk
(
)
)
{
new
(
mValue
.
first
(
)
.
addr
(
)
)
V
(
std
:
:
move
(
*
aOther
.
mValue
.
first
(
)
.
addr
(
)
)
)
;
aOther
.
mValue
.
first
(
)
.
addr
(
)
-
>
~
V
(
)
;
aOther
.
mValue
.
second
(
)
=
GetMovedFromMarker
(
)
;
}
}
return
*
this
;
}
bool
isOk
(
)
const
{
return
mValue
.
second
(
)
=
=
kNullValue
;
}
const
V
&
inspect
(
)
const
{
return
*
mValue
.
first
(
)
.
addr
(
)
;
}
V
unwrap
(
)
{
return
std
:
:
move
(
*
mValue
.
first
(
)
.
addr
(
)
)
;
}
const
E
&
inspectErr
(
)
const
{
return
UnusedZero
<
E
>
:
:
Inspect
(
mValue
.
second
(
)
)
;
}
E
unwrapErr
(
)
{
return
UnusedZero
<
E
>
:
:
Unwrap
(
std
:
:
move
(
mValue
.
second
(
)
)
)
;
}
}
;
template
<
typename
V
typename
E
bool
IsVTriviallyDestructible
=
std
:
:
is_trivially_destructible_v
<
V
>
>
class
ResultImplementationNullIsOk
;
template
<
typename
V
typename
E
>
class
ResultImplementationNullIsOk
<
V
E
true
>
:
public
ResultImplementationNullIsOkBase
<
V
E
>
{
public
:
using
ResultImplementationNullIsOkBase
<
V
E
>
:
:
ResultImplementationNullIsOkBase
;
}
;
template
<
typename
V
typename
E
>
class
ResultImplementationNullIsOk
<
V
E
false
>
:
public
ResultImplementationNullIsOkBase
<
V
E
>
{
public
:
using
ResultImplementationNullIsOkBase
<
V
E
>
:
:
ResultImplementationNullIsOkBase
;
ResultImplementationNullIsOk
(
ResultImplementationNullIsOk
&
&
)
=
default
;
ResultImplementationNullIsOk
&
operator
=
(
ResultImplementationNullIsOk
&
&
)
=
default
;
~
ResultImplementationNullIsOk
(
)
{
if
(
this
-
>
isOk
(
)
)
{
this
-
>
mValue
.
first
(
)
.
addr
(
)
-
>
~
V
(
)
;
}
}
}
;
template
<
typename
V
typename
E
>
class
ResultImplementation
<
V
E
PackingStrategy
:
:
NullIsOk
>
:
public
ResultImplementationNullIsOk
<
V
E
>
{
public
:
using
ResultImplementationNullIsOk
<
V
E
>
:
:
ResultImplementationNullIsOk
;
}
;
template
<
size_t
S
>
using
UnsignedIntType
=
std
:
:
conditional_t
<
S
=
=
1
std
:
:
uint8_t
std
:
:
conditional_t
<
S
=
=
2
std
:
:
uint16_t
std
:
:
conditional_t
<
S
=
=
3
|
|
S
=
=
4
std
:
:
uint32_t
std
:
:
conditional_t
<
S
<
=
8
std
:
:
uint64_t
void
>
>
>
>
;
template
<
typename
V
typename
E
>
class
ResultImplementation
<
V
E
PackingStrategy
:
:
LowBitTagIsError
>
{
static_assert
(
std
:
:
is_trivially_copyable_v
<
V
>
&
&
std
:
:
is_trivially_destructible_v
<
V
>
)
;
static_assert
(
std
:
:
is_trivially_copyable_v
<
E
>
&
&
std
:
:
is_trivially_destructible_v
<
E
>
)
;
static
constexpr
size_t
kRequiredSize
=
std
:
:
max
(
sizeof
(
V
)
sizeof
(
E
)
)
;
using
StorageType
=
UnsignedIntType
<
kRequiredSize
>
;
#
if
defined
(
__clang__
)
alignas
(
std
:
:
max
(
alignof
(
V
)
alignof
(
E
)
)
)
StorageType
mBits
;
#
else
alignas
(
alignof
(
V
)
>
alignof
(
E
)
?
alignof
(
V
)
:
alignof
(
E
)
)
StorageType
mBits
;
#
endif
public
:
explicit
ResultImplementation
(
V
aValue
)
{
if
constexpr
(
!
std
:
:
is_empty_v
<
V
>
)
{
std
:
:
memcpy
(
&
mBits
&
aValue
sizeof
(
V
)
)
;
MOZ_ASSERT
(
(
mBits
&
1
)
=
=
0
)
;
}
else
{
(
void
)
aValue
;
mBits
=
0
;
}
}
explicit
ResultImplementation
(
E
aErrorValue
)
{
if
constexpr
(
!
std
:
:
is_empty_v
<
E
>
)
{
std
:
:
memcpy
(
&
mBits
&
aErrorValue
sizeof
(
E
)
)
;
MOZ_ASSERT
(
(
mBits
&
1
)
=
=
0
)
;
mBits
|
=
1
;
}
else
{
(
void
)
aErrorValue
;
mBits
=
1
;
}
}
bool
isOk
(
)
const
{
return
(
mBits
&
1
)
=
=
0
;
}
V
inspect
(
)
const
{
V
res
;
std
:
:
memcpy
(
&
res
&
mBits
sizeof
(
V
)
)
;
return
res
;
}
V
unwrap
(
)
{
return
inspect
(
)
;
}
E
inspectErr
(
)
const
{
const
auto
bits
=
mBits
^
1
;
E
res
;
std
:
:
memcpy
(
&
res
&
bits
sizeof
(
E
)
)
;
return
res
;
}
E
unwrapErr
(
)
{
return
inspectErr
(
)
;
}
}
;
template
<
typename
V
typename
E
>
struct
IsPackableVariant
{
struct
VEbool
{
V
v
;
E
e
;
bool
ok
;
}
;
struct
EVbool
{
E
e
;
V
v
;
bool
ok
;
}
;
using
Impl
=
std
:
:
conditional_t
<
sizeof
(
VEbool
)
<
=
sizeof
(
EVbool
)
VEbool
EVbool
>
;
static
const
bool
value
=
sizeof
(
Impl
)
<
=
sizeof
(
uintptr_t
)
;
}
;
template
<
typename
V
typename
E
>
class
ResultImplementation
<
V
E
PackingStrategy
:
:
PackedVariant
>
{
using
Impl
=
typename
IsPackableVariant
<
V
E
>
:
:
Impl
;
Impl
data
;
public
:
explicit
ResultImplementation
(
V
aValue
)
{
data
.
v
=
std
:
:
move
(
aValue
)
;
data
.
ok
=
true
;
}
explicit
ResultImplementation
(
E
aErrorValue
)
{
data
.
e
=
std
:
:
move
(
aErrorValue
)
;
data
.
ok
=
false
;
}
bool
isOk
(
)
const
{
return
data
.
ok
;
}
const
V
&
inspect
(
)
const
{
return
data
.
v
;
}
V
unwrap
(
)
{
return
std
:
:
move
(
data
.
v
)
;
}
const
E
&
inspectErr
(
)
const
{
return
data
.
e
;
}
E
unwrapErr
(
)
{
return
std
:
:
move
(
data
.
e
)
;
}
}
;
template
<
typename
T
>
struct
UnusedZero
{
static
const
bool
value
=
false
;
}
;
template
<
typename
T
>
struct
HasFreeLSB
{
static
const
bool
value
=
std
:
:
is_empty_v
<
T
>
;
}
;
template
<
>
struct
HasFreeLSB
<
void
*
>
{
static
const
bool
value
=
false
;
}
;
template
<
typename
T
>
struct
HasFreeLSB
<
T
*
>
{
static
const
bool
value
=
(
alignof
(
T
)
&
1
)
=
=
0
;
}
;
template
<
typename
V
typename
E
>
struct
SelectResultImpl
{
static
const
PackingStrategy
value
=
(
HasFreeLSB
<
V
>
:
:
value
&
&
HasFreeLSB
<
E
>
:
:
value
)
?
PackingStrategy
:
:
LowBitTagIsError
:
(
UnusedZero
<
E
>
:
:
value
&
&
sizeof
(
E
)
<
=
sizeof
(
uintptr_t
)
)
?
PackingStrategy
:
:
NullIsOk
:
(
std
:
:
is_default_constructible_v
<
V
>
&
&
std
:
:
is_default_constructible_v
<
E
>
&
&
IsPackableVariant
<
V
E
>
:
:
value
)
?
PackingStrategy
:
:
PackedVariant
:
PackingStrategy
:
:
Variant
;
using
Type
=
ResultImplementation
<
V
E
value
>
;
}
;
template
<
typename
T
>
struct
IsResult
:
std
:
:
false_type
{
}
;
template
<
typename
V
typename
E
>
struct
IsResult
<
Result
<
V
E
>
>
:
std
:
:
true_type
{
}
;
}
template
<
typename
V
typename
E
>
auto
ToResult
(
Result
<
V
E
>
&
&
aValue
)
-
>
decltype
(
std
:
:
forward
<
Result
<
V
E
>
>
(
aValue
)
)
{
return
std
:
:
forward
<
Result
<
V
E
>
>
(
aValue
)
;
}
template
<
typename
V
typename
E
>
class
MOZ_MUST_USE_TYPE
Result
final
{
static_assert
(
!
std
:
:
is_const_v
<
V
>
)
;
static_assert
(
!
std
:
:
is_const_v
<
E
>
)
;
static_assert
(
!
std
:
:
is_reference_v
<
V
>
)
;
static_assert
(
!
std
:
:
is_reference_v
<
E
>
)
;
using
Impl
=
typename
detail
:
:
SelectResultImpl
<
V
E
>
:
:
Type
;
Impl
mImpl
;
public
:
using
ok_type
=
V
;
using
err_type
=
E
;
MOZ_IMPLICIT
Result
(
V
&
&
aValue
)
:
mImpl
(
std
:
:
forward
<
V
>
(
aValue
)
)
{
MOZ_ASSERT
(
isOk
(
)
)
;
}
MOZ_IMPLICIT
Result
(
const
V
&
aValue
)
:
mImpl
(
aValue
)
{
MOZ_ASSERT
(
isOk
(
)
)
;
}
template
<
typename
.
.
.
Args
>
explicit
Result
(
std
:
:
in_place_t
Args
&
&
.
.
.
aArgs
)
:
mImpl
(
std
:
:
in_place
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
{
MOZ_ASSERT
(
isOk
(
)
)
;
}
explicit
Result
(
E
aErrorValue
)
:
mImpl
(
std
:
:
move
(
aErrorValue
)
)
{
MOZ_ASSERT
(
isErr
(
)
)
;
}
template
<
typename
E2
>
MOZ_IMPLICIT
Result
(
GenericErrorResult
<
E2
>
&
&
aErrorResult
)
:
mImpl
(
std
:
:
move
(
aErrorResult
.
mErrorValue
)
)
{
static_assert
(
std
:
:
is_convertible_v
<
E2
E
>
"
E2
must
be
convertible
to
E
"
)
;
MOZ_ASSERT
(
isErr
(
)
)
;
}
template
<
typename
E2
>
MOZ_IMPLICIT
Result
(
const
GenericErrorResult
<
E2
>
&
aErrorResult
)
:
mImpl
(
aErrorResult
.
mErrorValue
)
{
static_assert
(
std
:
:
is_convertible_v
<
E2
E
>
"
E2
must
be
convertible
to
E
"
)
;
MOZ_ASSERT
(
isErr
(
)
)
;
}
Result
(
const
Result
&
)
=
delete
;
Result
(
Result
&
&
)
=
default
;
Result
&
operator
=
(
const
Result
&
)
=
delete
;
Result
&
operator
=
(
Result
&
&
)
=
default
;
bool
isOk
(
)
const
{
return
mImpl
.
isOk
(
)
;
}
bool
isErr
(
)
const
{
return
!
mImpl
.
isOk
(
)
;
}
V
unwrap
(
)
{
MOZ_ASSERT
(
isOk
(
)
)
;
return
mImpl
.
unwrap
(
)
;
}
V
unwrapOr
(
V
aValue
)
{
return
MOZ_LIKELY
(
isOk
(
)
)
?
mImpl
.
unwrap
(
)
:
std
:
:
move
(
aValue
)
;
}
E
unwrapErr
(
)
{
MOZ_ASSERT
(
isErr
(
)
)
;
return
mImpl
.
unwrapErr
(
)
;
}
decltype
(
auto
)
inspect
(
)
const
{
static_assert
(
!
std
:
:
is_reference_v
<
std
:
:
invoke_result_t
<
decltype
(
&
Impl
:
:
inspect
)
Impl
>
>
|
|
std
:
:
is_const_v
<
std
:
:
remove_reference_t
<
std
:
:
invoke_result_t
<
decltype
(
&
Impl
:
:
inspect
)
Impl
>
>
>
)
;
MOZ_ASSERT
(
isOk
(
)
)
;
return
mImpl
.
inspect
(
)
;
}
decltype
(
auto
)
inspectErr
(
)
const
{
static_assert
(
!
std
:
:
is_reference_v
<
std
:
:
invoke_result_t
<
decltype
(
&
Impl
:
:
inspectErr
)
Impl
>
>
|
|
std
:
:
is_const_v
<
std
:
:
remove_reference_t
<
std
:
:
invoke_result_t
<
decltype
(
&
Impl
:
:
inspectErr
)
Impl
>
>
>
)
;
MOZ_ASSERT
(
isErr
(
)
)
;
return
mImpl
.
inspectErr
(
)
;
}
GenericErrorResult
<
E
>
propagateErr
(
)
{
MOZ_ASSERT
(
isErr
(
)
)
;
return
GenericErrorResult
<
E
>
{
mImpl
.
unwrapErr
(
)
}
;
}
template
<
typename
F
>
auto
map
(
F
f
)
-
>
Result
<
std
:
:
result_of_t
<
F
(
V
)
>
E
>
{
using
RetResult
=
Result
<
std
:
:
result_of_t
<
F
(
V
)
>
E
>
;
return
MOZ_LIKELY
(
isOk
(
)
)
?
RetResult
(
f
(
unwrap
(
)
)
)
:
RetResult
(
unwrapErr
(
)
)
;
}
template
<
typename
F
>
auto
mapErr
(
F
f
)
-
>
Result
<
V
std
:
:
result_of_t
<
F
(
E
)
>
>
{
using
RetResult
=
Result
<
V
std
:
:
result_of_t
<
F
(
E
)
>
>
;
return
MOZ_UNLIKELY
(
isErr
(
)
)
?
RetResult
(
f
(
unwrapErr
(
)
)
)
:
RetResult
(
unwrap
(
)
)
;
}
template
<
typename
F
>
auto
orElse
(
F
f
)
-
>
Result
<
V
typename
std
:
:
result_of_t
<
F
(
E
)
>
:
:
err_type
>
{
return
MOZ_UNLIKELY
(
isErr
(
)
)
?
f
(
unwrapErr
(
)
)
:
unwrap
(
)
;
}
template
<
typename
F
typename
=
std
:
:
enable_if_t
<
detail
:
:
IsResult
<
decltype
(
(
*
(
(
F
*
)
nullptr
)
)
(
*
(
(
V
*
)
nullptr
)
)
)
>
:
:
value
>
>
auto
andThen
(
F
f
)
-
>
decltype
(
f
(
*
(
(
V
*
)
nullptr
)
)
)
{
return
MOZ_LIKELY
(
isOk
(
)
)
?
f
(
unwrap
(
)
)
:
propagateErr
(
)
;
}
}
;
template
<
typename
E
>
class
MOZ_MUST_USE_TYPE
GenericErrorResult
{
E
mErrorValue
;
template
<
typename
V
typename
E2
>
friend
class
Result
;
public
:
explicit
GenericErrorResult
(
const
E
&
aErrorValue
)
:
mErrorValue
(
aErrorValue
)
{
}
explicit
GenericErrorResult
(
E
&
&
aErrorValue
)
:
mErrorValue
(
std
:
:
move
(
aErrorValue
)
)
{
}
}
;
template
<
typename
E
>
inline
auto
Err
(
E
&
&
aErrorValue
)
{
return
GenericErrorResult
<
std
:
:
decay_t
<
E
>
>
(
std
:
:
forward
<
E
>
(
aErrorValue
)
)
;
}
}
#
define
MOZ_TRY
(
expr
)
\
do
{
\
auto
mozTryTempResult_
=
:
:
mozilla
:
:
ToResult
(
expr
)
;
\
if
(
MOZ_UNLIKELY
(
mozTryTempResult_
.
isErr
(
)
)
)
{
\
return
mozTryTempResult_
.
propagateErr
(
)
;
\
}
\
}
while
(
0
)
#
define
MOZ_TRY_VAR
(
target
expr
)
\
do
{
\
auto
mozTryVarTempResult_
=
(
expr
)
;
\
if
(
MOZ_UNLIKELY
(
mozTryVarTempResult_
.
isErr
(
)
)
)
{
\
return
mozTryVarTempResult_
.
propagateErr
(
)
;
\
}
\
(
target
)
=
mozTryVarTempResult_
.
unwrap
(
)
;
\
}
while
(
0
)
#
endif
