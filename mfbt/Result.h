#
ifndef
mozilla_Result_h
#
define
mozilla_Result_h
#
include
<
type_traits
>
#
include
"
mozilla
/
Alignment
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Types
.
h
"
#
include
"
mozilla
/
TypeTraits
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
namespace
mozilla
{
struct
Ok
{
}
;
template
<
typename
E
>
class
GenericErrorResult
;
template
<
typename
V
typename
E
>
class
Result
;
namespace
detail
{
enum
class
PackingStrategy
{
Variant
NullIsOk
LowBitTagIsError
PackedVariant
}
;
template
<
typename
V
typename
E
PackingStrategy
Strategy
>
class
ResultImplementation
;
template
<
typename
V
typename
E
>
class
ResultImplementation
<
V
E
PackingStrategy
:
:
Variant
>
{
mozilla
:
:
Variant
<
V
E
>
mStorage
;
public
:
ResultImplementation
(
ResultImplementation
&
&
)
=
default
;
ResultImplementation
(
const
ResultImplementation
&
)
=
default
;
ResultImplementation
&
operator
=
(
const
ResultImplementation
&
)
=
default
;
ResultImplementation
&
operator
=
(
ResultImplementation
&
&
)
=
default
;
explicit
ResultImplementation
(
V
&
&
aValue
)
:
mStorage
(
std
:
:
forward
<
V
>
(
aValue
)
)
{
}
explicit
ResultImplementation
(
const
V
&
aValue
)
:
mStorage
(
aValue
)
{
}
explicit
ResultImplementation
(
const
E
&
aErrorValue
)
:
mStorage
(
aErrorValue
)
{
}
explicit
ResultImplementation
(
E
&
&
aErrorValue
)
:
mStorage
(
std
:
:
forward
<
E
>
(
aErrorValue
)
)
{
}
bool
isOk
(
)
const
{
return
mStorage
.
template
is
<
V
>
(
)
;
}
V
unwrap
(
)
{
return
std
:
:
move
(
mStorage
.
template
as
<
V
>
(
)
)
;
}
const
V
&
inspect
(
)
const
{
return
mStorage
.
template
as
<
V
>
(
)
;
}
E
unwrapErr
(
)
{
return
std
:
:
move
(
mStorage
.
template
as
<
E
>
(
)
)
;
}
const
E
&
inspectErr
(
)
const
{
return
mStorage
.
template
as
<
E
>
(
)
;
}
}
;
template
<
typename
V
typename
E
>
class
ResultImplementation
<
V
E
&
PackingStrategy
:
:
Variant
>
{
mozilla
:
:
Variant
<
V
E
*
>
mStorage
;
public
:
explicit
ResultImplementation
(
V
&
&
aValue
)
:
mStorage
(
std
:
:
forward
<
V
>
(
aValue
)
)
{
}
explicit
ResultImplementation
(
const
V
&
aValue
)
:
mStorage
(
aValue
)
{
}
explicit
ResultImplementation
(
E
&
aErrorValue
)
:
mStorage
(
&
aErrorValue
)
{
}
bool
isOk
(
)
const
{
return
mStorage
.
template
is
<
V
>
(
)
;
}
const
V
&
inspect
(
)
const
{
return
mStorage
.
template
as
<
V
>
(
)
;
}
V
unwrap
(
)
{
return
std
:
:
move
(
mStorage
.
template
as
<
V
>
(
)
)
;
}
E
&
unwrapErr
(
)
{
return
*
mStorage
.
template
as
<
E
*
>
(
)
;
}
const
E
&
inspectErr
(
)
const
{
return
*
mStorage
.
template
as
<
E
*
>
(
)
;
}
}
;
template
<
typename
V
typename
E
>
class
ResultImplementation
<
V
E
&
PackingStrategy
:
:
NullIsOk
>
{
E
*
mErrorValue
;
public
:
explicit
ResultImplementation
(
V
)
:
mErrorValue
(
nullptr
)
{
}
explicit
ResultImplementation
(
E
&
aErrorValue
)
:
mErrorValue
(
&
aErrorValue
)
{
}
bool
isOk
(
)
const
{
return
mErrorValue
=
=
nullptr
;
}
const
V
&
inspect
(
)
const
=
delete
;
V
unwrap
(
)
{
return
V
(
)
;
}
const
E
&
inspectErr
(
)
const
{
return
*
mErrorValue
;
}
E
&
unwrapErr
(
)
{
return
*
mErrorValue
;
}
}
;
template
<
typename
V
typename
E
>
class
ResultImplementation
<
V
E
PackingStrategy
:
:
NullIsOk
>
{
static
constexpr
E
NullValue
=
E
(
0
)
;
E
mErrorValue
;
public
:
explicit
ResultImplementation
(
V
)
:
mErrorValue
(
NullValue
)
{
}
explicit
ResultImplementation
(
E
aErrorValue
)
:
mErrorValue
(
aErrorValue
)
{
MOZ_ASSERT
(
aErrorValue
!
=
NullValue
)
;
}
bool
isOk
(
)
const
{
return
mErrorValue
=
=
NullValue
;
}
const
V
&
inspect
(
)
const
=
delete
;
V
unwrap
(
)
{
return
V
(
)
;
}
const
E
&
inspectErr
(
)
const
{
return
mErrorValue
;
}
E
unwrapErr
(
)
{
return
std
:
:
move
(
mErrorValue
)
;
}
}
;
template
<
typename
V
typename
E
>
class
ResultImplementation
<
V
*
E
&
PackingStrategy
:
:
LowBitTagIsError
>
{
uintptr_t
mBits
;
public
:
explicit
ResultImplementation
(
V
*
aValue
)
:
mBits
(
reinterpret_cast
<
uintptr_t
>
(
aValue
)
)
{
MOZ_ASSERT
(
(
uintptr_t
(
aValue
)
%
MOZ_ALIGNOF
(
V
)
)
=
=
0
"
Result
value
pointers
must
not
be
misaligned
"
)
;
}
explicit
ResultImplementation
(
E
&
aErrorValue
)
:
mBits
(
reinterpret_cast
<
uintptr_t
>
(
&
aErrorValue
)
|
1
)
{
MOZ_ASSERT
(
(
uintptr_t
(
&
aErrorValue
)
%
MOZ_ALIGNOF
(
E
)
)
=
=
0
"
Result
errors
must
not
be
misaligned
"
)
;
}
bool
isOk
(
)
const
{
return
(
mBits
&
1
)
=
=
0
;
}
V
*
inspect
(
)
const
{
return
reinterpret_cast
<
V
*
>
(
mBits
)
;
}
V
*
unwrap
(
)
{
return
inspect
(
)
;
}
E
&
inspectErr
(
)
const
{
return
*
reinterpret_cast
<
E
*
>
(
mBits
^
1
)
;
}
E
&
unwrapErr
(
)
{
return
inspectErr
(
)
;
}
}
;
template
<
typename
V
typename
E
>
struct
IsPackableVariant
{
struct
VEbool
{
V
v
;
E
e
;
bool
ok
;
}
;
struct
EVbool
{
E
e
;
V
v
;
bool
ok
;
}
;
using
Impl
=
std
:
:
conditional_t
<
sizeof
(
VEbool
)
<
=
sizeof
(
EVbool
)
VEbool
EVbool
>
;
static
const
bool
value
=
sizeof
(
Impl
)
<
=
sizeof
(
uintptr_t
)
;
}
;
template
<
typename
V
typename
E
>
class
ResultImplementation
<
V
E
PackingStrategy
:
:
PackedVariant
>
{
using
Impl
=
typename
IsPackableVariant
<
V
E
>
:
:
Impl
;
Impl
data
;
public
:
explicit
ResultImplementation
(
V
aValue
)
{
data
.
v
=
std
:
:
move
(
aValue
)
;
data
.
ok
=
true
;
}
explicit
ResultImplementation
(
E
aErrorValue
)
{
data
.
e
=
std
:
:
move
(
aErrorValue
)
;
data
.
ok
=
false
;
}
bool
isOk
(
)
const
{
return
data
.
ok
;
}
const
V
&
inspect
(
)
const
{
return
data
.
v
;
}
V
unwrap
(
)
{
return
std
:
:
move
(
data
.
v
)
;
}
const
E
&
inspectErr
(
)
const
{
return
data
.
e
;
}
E
unwrapErr
(
)
{
return
std
:
:
move
(
data
.
e
)
;
}
}
;
template
<
typename
T
>
struct
UnusedZero
{
static
const
bool
value
=
false
;
}
;
template
<
typename
T
>
struct
UnusedZero
<
T
&
>
{
static
const
bool
value
=
true
;
}
;
template
<
typename
T
>
struct
HasFreeLSB
{
static
const
bool
value
=
false
;
}
;
template
<
>
struct
HasFreeLSB
<
void
*
>
{
static
const
bool
value
=
false
;
}
;
template
<
typename
T
>
struct
HasFreeLSB
<
T
*
>
{
static
const
bool
value
=
(
alignof
(
T
)
&
1
)
=
=
0
;
}
;
template
<
typename
T
>
struct
HasFreeLSB
<
T
&
>
{
static
const
bool
value
=
HasFreeLSB
<
T
*
>
:
:
value
;
}
;
template
<
typename
V
typename
E
>
struct
SelectResultImpl
{
static
const
PackingStrategy
value
=
(
std
:
:
is_empty_v
<
V
>
&
&
UnusedZero
<
E
>
:
:
value
)
?
PackingStrategy
:
:
NullIsOk
:
(
detail
:
:
HasFreeLSB
<
V
>
:
:
value
&
&
detail
:
:
HasFreeLSB
<
E
>
:
:
value
)
?
PackingStrategy
:
:
LowBitTagIsError
:
(
std
:
:
is_default_constructible_v
<
V
>
&
&
std
:
:
is_default_constructible_v
<
E
>
&
&
IsPackableVariant
<
V
E
>
:
:
value
)
?
PackingStrategy
:
:
PackedVariant
:
PackingStrategy
:
:
Variant
;
using
Type
=
detail
:
:
ResultImplementation
<
V
E
value
>
;
}
;
template
<
typename
T
>
struct
IsResult
:
std
:
:
false_type
{
}
;
template
<
typename
V
typename
E
>
struct
IsResult
<
Result
<
V
E
>
>
:
TrueType
{
}
;
}
template
<
typename
V
typename
E
>
auto
ToResult
(
Result
<
V
E
>
&
&
aValue
)
-
>
decltype
(
std
:
:
forward
<
Result
<
V
E
>
>
(
aValue
)
)
{
return
std
:
:
forward
<
Result
<
V
E
>
>
(
aValue
)
;
}
template
<
typename
V
typename
E
>
class
MOZ_MUST_USE_TYPE
Result
final
{
using
Impl
=
typename
detail
:
:
SelectResultImpl
<
V
E
>
:
:
Type
;
Impl
mImpl
;
public
:
MOZ_IMPLICIT
Result
(
V
&
&
aValue
)
:
mImpl
(
std
:
:
forward
<
V
>
(
aValue
)
)
{
MOZ_ASSERT
(
isOk
(
)
)
;
}
MOZ_IMPLICIT
Result
(
const
V
&
aValue
)
:
mImpl
(
aValue
)
{
MOZ_ASSERT
(
isOk
(
)
)
;
}
explicit
Result
(
E
aErrorValue
)
:
mImpl
(
std
:
:
forward
<
E
>
(
aErrorValue
)
)
{
MOZ_ASSERT
(
isErr
(
)
)
;
}
template
<
typename
E2
>
MOZ_IMPLICIT
Result
(
GenericErrorResult
<
E2
>
&
&
aErrorResult
)
:
mImpl
(
std
:
:
forward
<
E2
>
(
aErrorResult
.
mErrorValue
)
)
{
static_assert
(
std
:
:
is_convertible_v
<
E2
E
>
"
E2
must
be
convertible
to
E
"
)
;
MOZ_ASSERT
(
isErr
(
)
)
;
}
template
<
typename
E2
>
MOZ_IMPLICIT
Result
(
const
GenericErrorResult
<
E2
>
&
aErrorResult
)
:
mImpl
(
aErrorResult
.
mErrorValue
)
{
static_assert
(
std
:
:
is_convertible_v
<
E2
E
>
"
E2
must
be
convertible
to
E
"
)
;
MOZ_ASSERT
(
isErr
(
)
)
;
}
Result
(
const
Result
&
)
=
default
;
Result
(
Result
&
&
)
=
default
;
Result
&
operator
=
(
const
Result
&
)
=
default
;
Result
&
operator
=
(
Result
&
&
)
=
default
;
bool
isOk
(
)
const
{
return
mImpl
.
isOk
(
)
;
}
bool
isErr
(
)
const
{
return
!
mImpl
.
isOk
(
)
;
}
V
unwrap
(
)
{
MOZ_ASSERT
(
isOk
(
)
)
;
return
mImpl
.
unwrap
(
)
;
}
V
unwrapOr
(
V
aValue
)
{
return
MOZ_LIKELY
(
isOk
(
)
)
?
mImpl
.
unwrap
(
)
:
std
:
:
move
(
aValue
)
;
}
E
unwrapErr
(
)
{
MOZ_ASSERT
(
isErr
(
)
)
;
return
mImpl
.
unwrapErr
(
)
;
}
const
V
&
inspect
(
)
const
{
return
mImpl
.
inspect
(
)
;
}
const
E
&
inspectErr
(
)
const
{
MOZ_ASSERT
(
isErr
(
)
)
;
return
mImpl
.
inspectErr
(
)
;
}
template
<
typename
F
>
auto
map
(
F
f
)
-
>
Result
<
decltype
(
f
(
*
(
(
V
*
)
nullptr
)
)
)
E
>
{
using
RetResult
=
Result
<
decltype
(
f
(
*
(
(
V
*
)
nullptr
)
)
)
E
>
;
return
MOZ_LIKELY
(
isOk
(
)
)
?
RetResult
(
f
(
unwrap
(
)
)
)
:
RetResult
(
unwrapErr
(
)
)
;
}
template
<
typename
F
>
auto
mapErr
(
F
f
)
-
>
Result
<
V
std
:
:
result_of_t
<
F
(
E
)
>
>
{
using
RetResult
=
Result
<
V
std
:
:
result_of_t
<
F
(
E
)
>
>
;
return
isOk
(
)
?
RetResult
(
unwrap
(
)
)
:
RetResult
(
f
(
unwrapErr
(
)
)
)
;
}
template
<
typename
F
typename
=
std
:
:
enable_if_t
<
detail
:
:
IsResult
<
decltype
(
(
*
(
(
F
*
)
nullptr
)
)
(
*
(
(
V
*
)
nullptr
)
)
)
>
:
:
value
>
>
auto
andThen
(
F
f
)
-
>
decltype
(
f
(
*
(
(
V
*
)
nullptr
)
)
)
{
return
MOZ_LIKELY
(
isOk
(
)
)
?
f
(
unwrap
(
)
)
:
GenericErrorResult
<
E
>
(
unwrapErr
(
)
)
;
}
}
;
template
<
typename
E
>
class
MOZ_MUST_USE_TYPE
GenericErrorResult
{
E
mErrorValue
;
template
<
typename
V
typename
E2
>
friend
class
Result
;
public
:
explicit
GenericErrorResult
(
E
&
&
aErrorValue
)
:
mErrorValue
(
std
:
:
forward
<
E
>
(
aErrorValue
)
)
{
}
}
;
template
<
typename
E
>
inline
GenericErrorResult
<
E
>
Err
(
E
&
&
aErrorValue
)
{
return
GenericErrorResult
<
E
>
(
std
:
:
forward
<
E
>
(
aErrorValue
)
)
;
}
}
#
define
MOZ_TRY
(
expr
)
\
do
{
\
auto
mozTryTempResult_
=
:
:
mozilla
:
:
ToResult
(
expr
)
;
\
if
(
MOZ_UNLIKELY
(
mozTryTempResult_
.
isErr
(
)
)
)
{
\
return
:
:
mozilla
:
:
Err
(
mozTryTempResult_
.
unwrapErr
(
)
)
;
\
}
\
}
while
(
0
)
#
define
MOZ_TRY_VAR
(
target
expr
)
\
do
{
\
auto
mozTryVarTempResult_
=
(
expr
)
;
\
if
(
MOZ_UNLIKELY
(
mozTryVarTempResult_
.
isErr
(
)
)
)
{
\
return
:
:
mozilla
:
:
Err
(
mozTryVarTempResult_
.
unwrapErr
(
)
)
;
\
}
\
(
target
)
=
mozTryVarTempResult_
.
unwrap
(
)
;
\
}
while
(
0
)
#
endif
