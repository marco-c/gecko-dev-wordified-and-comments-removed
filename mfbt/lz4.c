#
ifndef
LZ4_HEAPMODE
#
define
LZ4_HEAPMODE
0
#
endif
#
define
ACCELERATION_DEFAULT
1
#
ifndef
LZ4_FORCE_MEMORY_ACCESS
#
if
defined
(
__GNUC__
)
&
&
\
(
defined
(
__ARM_ARCH_6__
)
|
|
defined
(
__ARM_ARCH_6J__
)
|
|
defined
(
__ARM_ARCH_6K__
)
\
|
|
defined
(
__ARM_ARCH_6Z__
)
|
|
defined
(
__ARM_ARCH_6ZK__
)
|
|
defined
(
__ARM_ARCH_6T2__
)
)
#
define
LZ4_FORCE_MEMORY_ACCESS
2
#
elif
(
defined
(
__INTEL_COMPILER
)
&
&
!
defined
(
_WIN32
)
)
|
|
defined
(
__GNUC__
)
#
define
LZ4_FORCE_MEMORY_ACCESS
1
#
endif
#
endif
#
if
defined
(
_MSC_VER
)
&
&
defined
(
_WIN32_WCE
)
#
define
LZ4_FORCE_SW_BITCOUNT
#
endif
#
define
LZ4_STATIC_LINKING_ONLY
#
define
LZ4_DISABLE_DEPRECATE_WARNINGS
#
include
"
lz4
.
h
"
#
ifdef
_MSC_VER
#
include
<
intrin
.
h
>
#
pragma
warning
(
disable
:
4127
)
/
*
disable
:
C4127
:
conditional
expression
is
constant
*
/
#
pragma
warning
(
disable
:
4293
)
/
*
disable
:
C4293
:
too
large
shift
(
32
-
bits
)
*
/
#
endif
#
ifndef
LZ4_FORCE_INLINE
#
ifdef
_MSC_VER
#
define
LZ4_FORCE_INLINE
static
__forceinline
#
else
#
if
defined
(
__cplusplus
)
|
|
defined
(
__STDC_VERSION__
)
&
&
__STDC_VERSION__
>
=
199901L
#
ifdef
__GNUC__
#
define
LZ4_FORCE_INLINE
static
inline
__attribute__
(
(
always_inline
)
)
#
else
#
define
LZ4_FORCE_INLINE
static
inline
#
endif
#
else
#
define
LZ4_FORCE_INLINE
static
#
endif
#
endif
#
endif
#
if
defined
(
__PPC64__
)
&
&
defined
(
__LITTLE_ENDIAN__
)
&
&
defined
(
__GNUC__
)
#
define
LZ4_FORCE_O2_GCC_PPC64LE
__attribute__
(
(
optimize
(
"
O2
"
)
)
)
#
define
LZ4_FORCE_O2_INLINE_GCC_PPC64LE
__attribute__
(
(
optimize
(
"
O2
"
)
)
)
LZ4_FORCE_INLINE
#
else
#
define
LZ4_FORCE_O2_GCC_PPC64LE
#
define
LZ4_FORCE_O2_INLINE_GCC_PPC64LE
static
#
endif
#
if
(
defined
(
__GNUC__
)
&
&
(
__GNUC__
>
=
3
)
)
|
|
(
defined
(
__INTEL_COMPILER
)
&
&
(
__INTEL_COMPILER
>
=
800
)
)
|
|
defined
(
__clang__
)
#
define
expect
(
expr
value
)
(
__builtin_expect
(
(
expr
)
(
value
)
)
)
#
else
#
define
expect
(
expr
value
)
(
expr
)
#
endif
#
ifndef
likely
#
define
likely
(
expr
)
expect
(
(
expr
)
!
=
0
1
)
#
endif
#
ifndef
unlikely
#
define
unlikely
(
expr
)
expect
(
(
expr
)
!
=
0
0
)
#
endif
#
include
<
stdlib
.
h
>
#
define
ALLOC
(
s
)
malloc
(
s
)
#
define
ALLOC_AND_ZERO
(
s
)
calloc
(
1
s
)
#
define
FREEMEM
(
p
)
free
(
p
)
#
include
<
string
.
h
>
#
define
MEM_INIT
(
p
v
s
)
memset
(
(
p
)
(
v
)
(
s
)
)
#
if
defined
(
__cplusplus
)
|
|
(
defined
(
__STDC_VERSION__
)
&
&
(
__STDC_VERSION__
>
=
199901L
)
)
#
include
<
stdint
.
h
>
typedef
uint8_t
BYTE
;
typedef
uint16_t
U16
;
typedef
uint32_t
U32
;
typedef
int32_t
S32
;
typedef
uint64_t
U64
;
typedef
uintptr_t
uptrval
;
#
else
typedef
unsigned
char
BYTE
;
typedef
unsigned
short
U16
;
typedef
unsigned
int
U32
;
typedef
signed
int
S32
;
typedef
unsigned
long
long
U64
;
typedef
size_t
uptrval
;
#
endif
#
if
defined
(
__x86_64__
)
typedef
U64
reg_t
;
#
else
typedef
size_t
reg_t
;
#
endif
static
unsigned
LZ4_isLittleEndian
(
void
)
{
const
union
{
U32
u
;
BYTE
c
[
4
]
;
}
one
=
{
1
}
;
return
one
.
c
[
0
]
;
}
#
if
defined
(
LZ4_FORCE_MEMORY_ACCESS
)
&
&
(
LZ4_FORCE_MEMORY_ACCESS
=
=
2
)
static
U16
LZ4_read16
(
const
void
*
memPtr
)
{
return
*
(
const
U16
*
)
memPtr
;
}
static
U32
LZ4_read32
(
const
void
*
memPtr
)
{
return
*
(
const
U32
*
)
memPtr
;
}
static
reg_t
LZ4_read_ARCH
(
const
void
*
memPtr
)
{
return
*
(
const
reg_t
*
)
memPtr
;
}
static
void
LZ4_write16
(
void
*
memPtr
U16
value
)
{
*
(
U16
*
)
memPtr
=
value
;
}
static
void
LZ4_write32
(
void
*
memPtr
U32
value
)
{
*
(
U32
*
)
memPtr
=
value
;
}
#
elif
defined
(
LZ4_FORCE_MEMORY_ACCESS
)
&
&
(
LZ4_FORCE_MEMORY_ACCESS
=
=
1
)
typedef
union
{
U16
u16
;
U32
u32
;
reg_t
uArch
;
}
__attribute__
(
(
packed
)
)
unalign
;
static
U16
LZ4_read16
(
const
void
*
ptr
)
{
return
(
(
const
unalign
*
)
ptr
)
-
>
u16
;
}
static
U32
LZ4_read32
(
const
void
*
ptr
)
{
return
(
(
const
unalign
*
)
ptr
)
-
>
u32
;
}
static
reg_t
LZ4_read_ARCH
(
const
void
*
ptr
)
{
return
(
(
const
unalign
*
)
ptr
)
-
>
uArch
;
}
static
void
LZ4_write16
(
void
*
memPtr
U16
value
)
{
(
(
unalign
*
)
memPtr
)
-
>
u16
=
value
;
}
static
void
LZ4_write32
(
void
*
memPtr
U32
value
)
{
(
(
unalign
*
)
memPtr
)
-
>
u32
=
value
;
}
#
else
static
U16
LZ4_read16
(
const
void
*
memPtr
)
{
U16
val
;
memcpy
(
&
val
memPtr
sizeof
(
val
)
)
;
return
val
;
}
static
U32
LZ4_read32
(
const
void
*
memPtr
)
{
U32
val
;
memcpy
(
&
val
memPtr
sizeof
(
val
)
)
;
return
val
;
}
static
reg_t
LZ4_read_ARCH
(
const
void
*
memPtr
)
{
reg_t
val
;
memcpy
(
&
val
memPtr
sizeof
(
val
)
)
;
return
val
;
}
static
void
LZ4_write16
(
void
*
memPtr
U16
value
)
{
memcpy
(
memPtr
&
value
sizeof
(
value
)
)
;
}
static
void
LZ4_write32
(
void
*
memPtr
U32
value
)
{
memcpy
(
memPtr
&
value
sizeof
(
value
)
)
;
}
#
endif
static
U16
LZ4_readLE16
(
const
void
*
memPtr
)
{
if
(
LZ4_isLittleEndian
(
)
)
{
return
LZ4_read16
(
memPtr
)
;
}
else
{
const
BYTE
*
p
=
(
const
BYTE
*
)
memPtr
;
return
(
U16
)
(
(
U16
)
p
[
0
]
+
(
p
[
1
]
<
<
8
)
)
;
}
}
static
void
LZ4_writeLE16
(
void
*
memPtr
U16
value
)
{
if
(
LZ4_isLittleEndian
(
)
)
{
LZ4_write16
(
memPtr
value
)
;
}
else
{
BYTE
*
p
=
(
BYTE
*
)
memPtr
;
p
[
0
]
=
(
BYTE
)
value
;
p
[
1
]
=
(
BYTE
)
(
value
>
>
8
)
;
}
}
LZ4_FORCE_O2_INLINE_GCC_PPC64LE
void
LZ4_wildCopy
(
void
*
dstPtr
const
void
*
srcPtr
void
*
dstEnd
)
{
BYTE
*
d
=
(
BYTE
*
)
dstPtr
;
const
BYTE
*
s
=
(
const
BYTE
*
)
srcPtr
;
BYTE
*
const
e
=
(
BYTE
*
)
dstEnd
;
do
{
memcpy
(
d
s
8
)
;
d
+
=
8
;
s
+
=
8
;
}
while
(
d
<
e
)
;
}
#
define
MINMATCH
4
#
define
WILDCOPYLENGTH
8
#
define
LASTLITERALS
5
#
define
MFLIMIT
(
WILDCOPYLENGTH
+
MINMATCH
)
static
const
int
LZ4_minLength
=
(
MFLIMIT
+
1
)
;
#
define
KB
*
(
1
<
<
10
)
#
define
MB
*
(
1
<
<
20
)
#
define
GB
*
(
1U
<
<
30
)
#
define
MAXD_LOG
16
#
define
MAX_DISTANCE
(
(
1
<
<
MAXD_LOG
)
-
1
)
#
define
ML_BITS
4
#
define
ML_MASK
(
(
1U
<
<
ML_BITS
)
-
1
)
#
define
RUN_BITS
(
8
-
ML_BITS
)
#
define
RUN_MASK
(
(
1U
<
<
RUN_BITS
)
-
1
)
#
if
defined
(
LZ4_DEBUG
)
&
&
(
LZ4_DEBUG
>
=
1
)
#
include
<
assert
.
h
>
#
else
#
ifndef
assert
#
define
assert
(
condition
)
(
(
void
)
0
)
#
endif
#
endif
#
define
LZ4_STATIC_ASSERT
(
c
)
{
enum
{
LZ4_static_assert
=
1
/
(
int
)
(
!
!
(
c
)
)
}
;
}
/
*
use
after
variable
declarations
*
/
#
if
defined
(
LZ4_DEBUG
)
&
&
(
LZ4_DEBUG
>
=
2
)
#
include
<
stdio
.
h
>
static
int
g_debuglog_enable
=
1
;
#
define
DEBUGLOG
(
l
.
.
.
)
{
\
if
(
(
g_debuglog_enable
)
&
&
(
l
<
=
LZ4_DEBUG
)
)
{
\
fprintf
(
stderr
__FILE__
"
:
"
)
;
\
fprintf
(
stderr
__VA_ARGS__
)
;
\
fprintf
(
stderr
"
\
n
"
)
;
\
}
}
#
else
#
define
DEBUGLOG
(
l
.
.
.
)
{
}
/
*
disabled
*
/
#
endif
static
unsigned
LZ4_NbCommonBytes
(
reg_t
val
)
{
if
(
LZ4_isLittleEndian
(
)
)
{
if
(
sizeof
(
val
)
=
=
8
)
{
#
if
defined
(
_MSC_VER
)
&
&
defined
(
_WIN64
)
&
&
!
defined
(
LZ4_FORCE_SW_BITCOUNT
)
unsigned
long
r
=
0
;
_BitScanForward64
(
&
r
(
U64
)
val
)
;
return
(
int
)
(
r
>
>
3
)
;
#
elif
(
defined
(
__clang__
)
|
|
(
defined
(
__GNUC__
)
&
&
(
__GNUC__
>
=
3
)
)
)
&
&
!
defined
(
LZ4_FORCE_SW_BITCOUNT
)
return
(
__builtin_ctzll
(
(
U64
)
val
)
>
>
3
)
;
#
else
static
const
int
DeBruijnBytePos
[
64
]
=
{
0
0
0
0
0
1
1
2
0
3
1
3
1
4
2
7
0
2
3
6
1
5
3
5
1
3
4
4
2
5
6
7
7
0
1
2
3
3
4
6
2
6
5
5
3
4
5
6
7
1
2
4
6
4
4
5
7
2
6
5
7
6
7
7
}
;
return
DeBruijnBytePos
[
(
(
U64
)
(
(
val
&
-
(
long
long
)
val
)
*
0x0218A392CDABBD3FULL
)
)
>
>
58
]
;
#
endif
}
else
{
#
if
defined
(
_MSC_VER
)
&
&
!
defined
(
LZ4_FORCE_SW_BITCOUNT
)
unsigned
long
r
;
_BitScanForward
(
&
r
(
U32
)
val
)
;
return
(
int
)
(
r
>
>
3
)
;
#
elif
(
defined
(
__clang__
)
|
|
(
defined
(
__GNUC__
)
&
&
(
__GNUC__
>
=
3
)
)
)
&
&
!
defined
(
LZ4_FORCE_SW_BITCOUNT
)
return
(
__builtin_ctz
(
(
U32
)
val
)
>
>
3
)
;
#
else
static
const
int
DeBruijnBytePos
[
32
]
=
{
0
0
3
0
3
1
3
0
3
2
2
1
3
2
0
1
3
3
1
2
2
2
2
0
3
1
2
0
1
0
1
1
}
;
return
DeBruijnBytePos
[
(
(
U32
)
(
(
val
&
-
(
S32
)
val
)
*
0x077CB531U
)
)
>
>
27
]
;
#
endif
}
}
else
{
if
(
sizeof
(
val
)
=
=
8
)
{
#
if
defined
(
_MSC_VER
)
&
&
defined
(
_WIN64
)
&
&
!
defined
(
LZ4_FORCE_SW_BITCOUNT
)
unsigned
long
r
=
0
;
_BitScanReverse64
(
&
r
val
)
;
return
(
unsigned
)
(
r
>
>
3
)
;
#
elif
(
defined
(
__clang__
)
|
|
(
defined
(
__GNUC__
)
&
&
(
__GNUC__
>
=
3
)
)
)
&
&
!
defined
(
LZ4_FORCE_SW_BITCOUNT
)
return
(
__builtin_clzll
(
(
U64
)
val
)
>
>
3
)
;
#
else
static
const
U32
by32
=
sizeof
(
val
)
*
4
;
unsigned
r
;
if
(
!
(
val
>
>
by32
)
)
{
r
=
4
;
}
else
{
r
=
0
;
val
>
>
=
by32
;
}
if
(
!
(
val
>
>
16
)
)
{
r
+
=
2
;
val
>
>
=
8
;
}
else
{
val
>
>
=
24
;
}
r
+
=
(
!
val
)
;
return
r
;
#
endif
}
else
{
#
if
defined
(
_MSC_VER
)
&
&
!
defined
(
LZ4_FORCE_SW_BITCOUNT
)
unsigned
long
r
=
0
;
_BitScanReverse
(
&
r
(
unsigned
long
)
val
)
;
return
(
unsigned
)
(
r
>
>
3
)
;
#
elif
(
defined
(
__clang__
)
|
|
(
defined
(
__GNUC__
)
&
&
(
__GNUC__
>
=
3
)
)
)
&
&
!
defined
(
LZ4_FORCE_SW_BITCOUNT
)
return
(
__builtin_clz
(
(
U32
)
val
)
>
>
3
)
;
#
else
unsigned
r
;
if
(
!
(
val
>
>
16
)
)
{
r
=
2
;
val
>
>
=
8
;
}
else
{
r
=
0
;
val
>
>
=
24
;
}
r
+
=
(
!
val
)
;
return
r
;
#
endif
}
}
}
#
define
STEPSIZE
sizeof
(
reg_t
)
LZ4_FORCE_INLINE
unsigned
LZ4_count
(
const
BYTE
*
pIn
const
BYTE
*
pMatch
const
BYTE
*
pInLimit
)
{
const
BYTE
*
const
pStart
=
pIn
;
if
(
likely
(
pIn
<
pInLimit
-
(
STEPSIZE
-
1
)
)
)
{
reg_t
const
diff
=
LZ4_read_ARCH
(
pMatch
)
^
LZ4_read_ARCH
(
pIn
)
;
if
(
!
diff
)
{
pIn
+
=
STEPSIZE
;
pMatch
+
=
STEPSIZE
;
}
else
{
return
LZ4_NbCommonBytes
(
diff
)
;
}
}
while
(
likely
(
pIn
<
pInLimit
-
(
STEPSIZE
-
1
)
)
)
{
reg_t
const
diff
=
LZ4_read_ARCH
(
pMatch
)
^
LZ4_read_ARCH
(
pIn
)
;
if
(
!
diff
)
{
pIn
+
=
STEPSIZE
;
pMatch
+
=
STEPSIZE
;
continue
;
}
pIn
+
=
LZ4_NbCommonBytes
(
diff
)
;
return
(
unsigned
)
(
pIn
-
pStart
)
;
}
if
(
(
STEPSIZE
=
=
8
)
&
&
(
pIn
<
(
pInLimit
-
3
)
)
&
&
(
LZ4_read32
(
pMatch
)
=
=
LZ4_read32
(
pIn
)
)
)
{
pIn
+
=
4
;
pMatch
+
=
4
;
}
if
(
(
pIn
<
(
pInLimit
-
1
)
)
&
&
(
LZ4_read16
(
pMatch
)
=
=
LZ4_read16
(
pIn
)
)
)
{
pIn
+
=
2
;
pMatch
+
=
2
;
}
if
(
(
pIn
<
pInLimit
)
&
&
(
*
pMatch
=
=
*
pIn
)
)
pIn
+
+
;
return
(
unsigned
)
(
pIn
-
pStart
)
;
}
#
ifndef
LZ4_COMMONDEFS_ONLY
static
const
int
LZ4_64Klimit
=
(
(
64
KB
)
+
(
MFLIMIT
-
1
)
)
;
static
const
U32
LZ4_skipTrigger
=
6
;
typedef
enum
{
notLimited
=
0
limitedOutput
=
1
fillOutput
=
2
}
limitedOutput_directive
;
typedef
enum
{
clearedTable
=
0
byPtr
byU32
byU16
}
tableType_t
;
typedef
enum
{
noDict
=
0
withPrefix64k
usingExtDict
usingDictCtx
}
dict_directive
;
typedef
enum
{
noDictIssue
=
0
dictSmall
}
dictIssue_directive
;
typedef
enum
{
endOnOutputSize
=
0
endOnInputSize
=
1
}
endCondition_directive
;
typedef
enum
{
full
=
0
partial
=
1
}
earlyEnd_directive
;
int
LZ4_versionNumber
(
void
)
{
return
LZ4_VERSION_NUMBER
;
}
const
char
*
LZ4_versionString
(
void
)
{
return
LZ4_VERSION_STRING
;
}
int
LZ4_compressBound
(
int
isize
)
{
return
LZ4_COMPRESSBOUND
(
isize
)
;
}
int
LZ4_sizeofState
(
)
{
return
LZ4_STREAMSIZE
;
}
static
U32
LZ4_hash4
(
U32
sequence
tableType_t
const
tableType
)
{
if
(
tableType
=
=
byU16
)
return
(
(
sequence
*
2654435761U
)
>
>
(
(
MINMATCH
*
8
)
-
(
LZ4_HASHLOG
+
1
)
)
)
;
else
return
(
(
sequence
*
2654435761U
)
>
>
(
(
MINMATCH
*
8
)
-
LZ4_HASHLOG
)
)
;
}
static
U32
LZ4_hash5
(
U64
sequence
tableType_t
const
tableType
)
{
static
const
U64
prime5bytes
=
889523592379ULL
;
static
const
U64
prime8bytes
=
11400714785074694791ULL
;
const
U32
hashLog
=
(
tableType
=
=
byU16
)
?
LZ4_HASHLOG
+
1
:
LZ4_HASHLOG
;
if
(
LZ4_isLittleEndian
(
)
)
return
(
U32
)
(
(
(
sequence
<
<
24
)
*
prime5bytes
)
>
>
(
64
-
hashLog
)
)
;
else
return
(
U32
)
(
(
(
sequence
>
>
24
)
*
prime8bytes
)
>
>
(
64
-
hashLog
)
)
;
}
LZ4_FORCE_INLINE
U32
LZ4_hashPosition
(
const
void
*
const
p
tableType_t
const
tableType
)
{
if
(
(
sizeof
(
reg_t
)
=
=
8
)
&
&
(
tableType
!
=
byU16
)
)
return
LZ4_hash5
(
LZ4_read_ARCH
(
p
)
tableType
)
;
return
LZ4_hash4
(
LZ4_read32
(
p
)
tableType
)
;
}
static
void
LZ4_putIndexOnHash
(
U32
idx
U32
h
void
*
tableBase
tableType_t
const
tableType
)
{
switch
(
tableType
)
{
default
:
case
clearedTable
:
case
byPtr
:
{
assert
(
0
)
;
return
;
}
case
byU32
:
{
U32
*
hashTable
=
(
U32
*
)
tableBase
;
hashTable
[
h
]
=
idx
;
return
;
}
case
byU16
:
{
U16
*
hashTable
=
(
U16
*
)
tableBase
;
assert
(
idx
<
65536
)
;
hashTable
[
h
]
=
(
U16
)
idx
;
return
;
}
}
}
static
void
LZ4_putPositionOnHash
(
const
BYTE
*
p
U32
h
void
*
tableBase
tableType_t
const
tableType
const
BYTE
*
srcBase
)
{
switch
(
tableType
)
{
case
clearedTable
:
{
assert
(
0
)
;
return
;
}
case
byPtr
:
{
const
BYTE
*
*
hashTable
=
(
const
BYTE
*
*
)
tableBase
;
hashTable
[
h
]
=
p
;
return
;
}
case
byU32
:
{
U32
*
hashTable
=
(
U32
*
)
tableBase
;
hashTable
[
h
]
=
(
U32
)
(
p
-
srcBase
)
;
return
;
}
case
byU16
:
{
U16
*
hashTable
=
(
U16
*
)
tableBase
;
hashTable
[
h
]
=
(
U16
)
(
p
-
srcBase
)
;
return
;
}
}
}
LZ4_FORCE_INLINE
void
LZ4_putPosition
(
const
BYTE
*
p
void
*
tableBase
tableType_t
tableType
const
BYTE
*
srcBase
)
{
U32
const
h
=
LZ4_hashPosition
(
p
tableType
)
;
LZ4_putPositionOnHash
(
p
h
tableBase
tableType
srcBase
)
;
}
static
U32
LZ4_getIndexOnHash
(
U32
h
const
void
*
tableBase
tableType_t
tableType
)
{
LZ4_STATIC_ASSERT
(
LZ4_MEMORY_USAGE
>
2
)
;
if
(
tableType
=
=
byU32
)
{
const
U32
*
const
hashTable
=
(
const
U32
*
)
tableBase
;
assert
(
h
<
(
1U
<
<
(
LZ4_MEMORY_USAGE
-
2
)
)
)
;
return
hashTable
[
h
]
;
}
if
(
tableType
=
=
byU16
)
{
const
U16
*
const
hashTable
=
(
const
U16
*
)
tableBase
;
assert
(
h
<
(
1U
<
<
(
LZ4_MEMORY_USAGE
-
1
)
)
)
;
return
hashTable
[
h
]
;
}
assert
(
0
)
;
return
0
;
}
static
const
BYTE
*
LZ4_getPositionOnHash
(
U32
h
const
void
*
tableBase
tableType_t
tableType
const
BYTE
*
srcBase
)
{
if
(
tableType
=
=
byPtr
)
{
const
BYTE
*
const
*
hashTable
=
(
const
BYTE
*
const
*
)
tableBase
;
return
hashTable
[
h
]
;
}
if
(
tableType
=
=
byU32
)
{
const
U32
*
const
hashTable
=
(
const
U32
*
)
tableBase
;
return
hashTable
[
h
]
+
srcBase
;
}
{
const
U16
*
const
hashTable
=
(
const
U16
*
)
tableBase
;
return
hashTable
[
h
]
+
srcBase
;
}
}
LZ4_FORCE_INLINE
const
BYTE
*
LZ4_getPosition
(
const
BYTE
*
p
const
void
*
tableBase
tableType_t
tableType
const
BYTE
*
srcBase
)
{
U32
const
h
=
LZ4_hashPosition
(
p
tableType
)
;
return
LZ4_getPositionOnHash
(
h
tableBase
tableType
srcBase
)
;
}
LZ4_FORCE_INLINE
void
LZ4_prepareTable
(
LZ4_stream_t_internal
*
const
cctx
const
int
inputSize
const
tableType_t
tableType
)
{
if
(
cctx
-
>
tableType
!
=
clearedTable
)
{
if
(
cctx
-
>
tableType
!
=
tableType
|
|
(
tableType
=
=
byU16
&
&
cctx
-
>
currentOffset
+
inputSize
>
=
0xFFFFU
)
|
|
(
tableType
=
=
byU32
&
&
cctx
-
>
currentOffset
>
1
GB
)
|
|
tableType
=
=
byPtr
|
|
inputSize
>
=
4
KB
)
{
DEBUGLOG
(
4
"
LZ4_prepareTable
:
Resetting
table
in
%
p
"
cctx
)
;
MEM_INIT
(
cctx
-
>
hashTable
0
LZ4_HASHTABLESIZE
)
;
cctx
-
>
currentOffset
=
0
;
cctx
-
>
tableType
=
clearedTable
;
}
else
{
DEBUGLOG
(
4
"
LZ4_prepareTable
:
Re
-
use
hash
table
(
no
reset
)
"
)
;
}
}
if
(
cctx
-
>
currentOffset
!
=
0
&
&
tableType
=
=
byU32
)
{
DEBUGLOG
(
5
"
LZ4_prepareTable
:
adding
64KB
to
currentOffset
"
)
;
cctx
-
>
currentOffset
+
=
64
KB
;
}
cctx
-
>
dictCtx
=
NULL
;
cctx
-
>
dictionary
=
NULL
;
cctx
-
>
dictSize
=
0
;
}
LZ4_FORCE_INLINE
int
LZ4_compress_generic
(
LZ4_stream_t_internal
*
const
cctx
const
char
*
const
source
char
*
const
dest
const
int
inputSize
int
*
inputConsumed
const
int
maxOutputSize
const
limitedOutput_directive
outputLimited
const
tableType_t
tableType
const
dict_directive
dictDirective
const
dictIssue_directive
dictIssue
const
U32
acceleration
)
{
const
BYTE
*
ip
=
(
const
BYTE
*
)
source
;
U32
const
startIndex
=
cctx
-
>
currentOffset
;
const
BYTE
*
base
=
(
const
BYTE
*
)
source
-
startIndex
;
const
BYTE
*
lowLimit
;
const
LZ4_stream_t_internal
*
dictCtx
=
(
const
LZ4_stream_t_internal
*
)
cctx
-
>
dictCtx
;
const
BYTE
*
const
dictionary
=
dictDirective
=
=
usingDictCtx
?
dictCtx
-
>
dictionary
:
cctx
-
>
dictionary
;
const
U32
dictSize
=
dictDirective
=
=
usingDictCtx
?
dictCtx
-
>
dictSize
:
cctx
-
>
dictSize
;
const
U32
dictDelta
=
(
dictDirective
=
=
usingDictCtx
)
?
startIndex
-
dictCtx
-
>
currentOffset
:
0
;
int
const
maybe_extMem
=
(
dictDirective
=
=
usingExtDict
)
|
|
(
dictDirective
=
=
usingDictCtx
)
;
U32
const
prefixIdxLimit
=
startIndex
-
dictSize
;
const
BYTE
*
const
dictEnd
=
dictionary
+
dictSize
;
const
BYTE
*
anchor
=
(
const
BYTE
*
)
source
;
const
BYTE
*
const
iend
=
ip
+
inputSize
;
const
BYTE
*
const
mflimitPlusOne
=
iend
-
MFLIMIT
+
1
;
const
BYTE
*
const
matchlimit
=
iend
-
LASTLITERALS
;
const
BYTE
*
dictBase
=
dictDirective
=
=
usingDictCtx
?
dictionary
+
dictSize
-
dictCtx
-
>
currentOffset
:
dictionary
+
dictSize
-
startIndex
;
BYTE
*
op
=
(
BYTE
*
)
dest
;
BYTE
*
const
olimit
=
op
+
maxOutputSize
;
U32
offset
=
0
;
U32
forwardH
;
DEBUGLOG
(
5
"
LZ4_compress_generic
:
srcSize
=
%
i
tableType
=
%
u
"
inputSize
tableType
)
;
if
(
outputLimited
=
=
fillOutput
&
&
maxOutputSize
<
1
)
return
0
;
if
(
(
U32
)
inputSize
>
(
U32
)
LZ4_MAX_INPUT_SIZE
)
return
0
;
if
(
(
tableType
=
=
byU16
)
&
&
(
inputSize
>
=
LZ4_64Klimit
)
)
return
0
;
if
(
tableType
=
=
byPtr
)
assert
(
dictDirective
=
=
noDict
)
;
assert
(
acceleration
>
=
1
)
;
lowLimit
=
(
const
BYTE
*
)
source
-
(
dictDirective
=
=
withPrefix64k
?
dictSize
:
0
)
;
if
(
dictDirective
=
=
usingDictCtx
)
{
cctx
-
>
dictCtx
=
NULL
;
cctx
-
>
dictSize
=
(
U32
)
inputSize
;
}
else
{
cctx
-
>
dictSize
+
=
(
U32
)
inputSize
;
}
cctx
-
>
currentOffset
+
=
(
U32
)
inputSize
;
cctx
-
>
tableType
=
tableType
;
if
(
inputSize
<
LZ4_minLength
)
goto
_last_literals
;
LZ4_putPosition
(
ip
cctx
-
>
hashTable
tableType
base
)
;
ip
+
+
;
forwardH
=
LZ4_hashPosition
(
ip
tableType
)
;
for
(
;
;
)
{
const
BYTE
*
match
;
BYTE
*
token
;
if
(
tableType
=
=
byPtr
)
{
const
BYTE
*
forwardIp
=
ip
;
unsigned
step
=
1
;
unsigned
searchMatchNb
=
acceleration
<
<
LZ4_skipTrigger
;
do
{
U32
const
h
=
forwardH
;
ip
=
forwardIp
;
forwardIp
+
=
step
;
step
=
(
searchMatchNb
+
+
>
>
LZ4_skipTrigger
)
;
if
(
unlikely
(
forwardIp
>
mflimitPlusOne
)
)
goto
_last_literals
;
assert
(
ip
<
mflimitPlusOne
)
;
match
=
LZ4_getPositionOnHash
(
h
cctx
-
>
hashTable
tableType
base
)
;
forwardH
=
LZ4_hashPosition
(
forwardIp
tableType
)
;
LZ4_putPositionOnHash
(
ip
h
cctx
-
>
hashTable
tableType
base
)
;
}
while
(
(
match
+
MAX_DISTANCE
<
ip
)
|
|
(
LZ4_read32
(
match
)
!
=
LZ4_read32
(
ip
)
)
)
;
}
else
{
const
BYTE
*
forwardIp
=
ip
;
unsigned
step
=
1
;
unsigned
searchMatchNb
=
acceleration
<
<
LZ4_skipTrigger
;
do
{
U32
const
h
=
forwardH
;
U32
const
current
=
(
U32
)
(
forwardIp
-
base
)
;
U32
matchIndex
=
LZ4_getIndexOnHash
(
h
cctx
-
>
hashTable
tableType
)
;
assert
(
matchIndex
<
=
current
)
;
assert
(
forwardIp
-
base
<
(
ptrdiff_t
)
(
2
GB
-
1
)
)
;
ip
=
forwardIp
;
forwardIp
+
=
step
;
step
=
(
searchMatchNb
+
+
>
>
LZ4_skipTrigger
)
;
if
(
unlikely
(
forwardIp
>
mflimitPlusOne
)
)
goto
_last_literals
;
assert
(
ip
<
mflimitPlusOne
)
;
if
(
dictDirective
=
=
usingDictCtx
)
{
if
(
matchIndex
<
startIndex
)
{
assert
(
tableType
=
=
byU32
)
;
matchIndex
=
LZ4_getIndexOnHash
(
h
dictCtx
-
>
hashTable
byU32
)
;
match
=
dictBase
+
matchIndex
;
matchIndex
+
=
dictDelta
;
lowLimit
=
dictionary
;
}
else
{
match
=
base
+
matchIndex
;
lowLimit
=
(
const
BYTE
*
)
source
;
}
}
else
if
(
dictDirective
=
=
usingExtDict
)
{
if
(
matchIndex
<
startIndex
)
{
DEBUGLOG
(
7
"
extDict
candidate
:
matchIndex
=
%
5u
<
startIndex
=
%
5u
"
matchIndex
startIndex
)
;
assert
(
startIndex
-
matchIndex
>
=
MINMATCH
)
;
match
=
dictBase
+
matchIndex
;
lowLimit
=
dictionary
;
}
else
{
match
=
base
+
matchIndex
;
lowLimit
=
(
const
BYTE
*
)
source
;
}
}
else
{
match
=
base
+
matchIndex
;
}
forwardH
=
LZ4_hashPosition
(
forwardIp
tableType
)
;
LZ4_putIndexOnHash
(
current
h
cctx
-
>
hashTable
tableType
)
;
if
(
(
dictIssue
=
=
dictSmall
)
&
&
(
matchIndex
<
prefixIdxLimit
)
)
continue
;
assert
(
matchIndex
<
current
)
;
if
(
(
tableType
!
=
byU16
)
&
&
(
matchIndex
+
MAX_DISTANCE
<
current
)
)
continue
;
if
(
tableType
=
=
byU16
)
assert
(
(
current
-
matchIndex
)
<
=
MAX_DISTANCE
)
;
if
(
LZ4_read32
(
match
)
=
=
LZ4_read32
(
ip
)
)
{
if
(
maybe_extMem
)
offset
=
current
-
matchIndex
;
break
;
}
}
while
(
1
)
;
}
while
(
(
(
ip
>
anchor
)
&
(
match
>
lowLimit
)
)
&
&
(
unlikely
(
ip
[
-
1
]
=
=
match
[
-
1
]
)
)
)
{
ip
-
-
;
match
-
-
;
}
{
unsigned
const
litLength
=
(
unsigned
)
(
ip
-
anchor
)
;
token
=
op
+
+
;
if
(
(
outputLimited
=
=
limitedOutput
)
&
&
(
unlikely
(
op
+
litLength
+
(
2
+
1
+
LASTLITERALS
)
+
(
litLength
/
255
)
>
olimit
)
)
)
return
0
;
if
(
(
outputLimited
=
=
fillOutput
)
&
&
(
unlikely
(
op
+
(
litLength
+
240
)
/
255
+
litLength
+
2
+
1
+
MFLIMIT
-
MINMATCH
>
olimit
)
)
)
{
op
-
-
;
goto
_last_literals
;
}
if
(
litLength
>
=
RUN_MASK
)
{
int
len
=
(
int
)
litLength
-
RUN_MASK
;
*
token
=
(
RUN_MASK
<
<
ML_BITS
)
;
for
(
;
len
>
=
255
;
len
-
=
255
)
*
op
+
+
=
255
;
*
op
+
+
=
(
BYTE
)
len
;
}
else
*
token
=
(
BYTE
)
(
litLength
<
<
ML_BITS
)
;
LZ4_wildCopy
(
op
anchor
op
+
litLength
)
;
op
+
=
litLength
;
DEBUGLOG
(
6
"
seq
.
start
:
%
i
literals
=
%
u
match
.
start
:
%
i
"
(
int
)
(
anchor
-
(
const
BYTE
*
)
source
)
litLength
(
int
)
(
ip
-
(
const
BYTE
*
)
source
)
)
;
}
_next_match
:
if
(
(
outputLimited
=
=
fillOutput
)
&
&
(
op
+
2
+
1
+
MFLIMIT
-
MINMATCH
>
olimit
)
)
{
op
=
token
;
goto
_last_literals
;
}
if
(
maybe_extMem
)
{
DEBUGLOG
(
6
"
with
offset
=
%
u
(
ext
if
>
%
i
)
"
offset
(
int
)
(
ip
-
(
const
BYTE
*
)
source
)
)
;
assert
(
offset
<
=
MAX_DISTANCE
&
&
offset
>
0
)
;
LZ4_writeLE16
(
op
(
U16
)
offset
)
;
op
+
=
2
;
}
else
{
DEBUGLOG
(
6
"
with
offset
=
%
u
(
same
segment
)
"
(
U32
)
(
ip
-
match
)
)
;
assert
(
ip
-
match
<
=
MAX_DISTANCE
)
;
LZ4_writeLE16
(
op
(
U16
)
(
ip
-
match
)
)
;
op
+
=
2
;
}
{
unsigned
matchCode
;
if
(
(
dictDirective
=
=
usingExtDict
|
|
dictDirective
=
=
usingDictCtx
)
&
&
(
lowLimit
=
=
dictionary
)
)
{
const
BYTE
*
limit
=
ip
+
(
dictEnd
-
match
)
;
assert
(
dictEnd
>
match
)
;
if
(
limit
>
matchlimit
)
limit
=
matchlimit
;
matchCode
=
LZ4_count
(
ip
+
MINMATCH
match
+
MINMATCH
limit
)
;
ip
+
=
MINMATCH
+
matchCode
;
if
(
ip
=
=
limit
)
{
unsigned
const
more
=
LZ4_count
(
limit
(
const
BYTE
*
)
source
matchlimit
)
;
matchCode
+
=
more
;
ip
+
=
more
;
}
DEBUGLOG
(
6
"
with
matchLength
=
%
u
starting
in
extDict
"
matchCode
+
MINMATCH
)
;
}
else
{
matchCode
=
LZ4_count
(
ip
+
MINMATCH
match
+
MINMATCH
matchlimit
)
;
ip
+
=
MINMATCH
+
matchCode
;
DEBUGLOG
(
6
"
with
matchLength
=
%
u
"
matchCode
+
MINMATCH
)
;
}
if
(
(
outputLimited
)
&
&
(
unlikely
(
op
+
(
1
+
LASTLITERALS
)
+
(
matchCode
>
>
8
)
>
olimit
)
)
)
{
if
(
outputLimited
=
=
limitedOutput
)
return
0
;
if
(
outputLimited
=
=
fillOutput
)
{
U32
newMatchCode
=
15
-
1
+
(
(
U32
)
(
olimit
-
op
)
-
2
-
1
-
LASTLITERALS
)
*
255
;
ip
-
=
matchCode
-
newMatchCode
;
matchCode
=
newMatchCode
;
}
}
if
(
matchCode
>
=
ML_MASK
)
{
*
token
+
=
ML_MASK
;
matchCode
-
=
ML_MASK
;
LZ4_write32
(
op
0xFFFFFFFF
)
;
while
(
matchCode
>
=
4
*
255
)
{
op
+
=
4
;
LZ4_write32
(
op
0xFFFFFFFF
)
;
matchCode
-
=
4
*
255
;
}
op
+
=
matchCode
/
255
;
*
op
+
+
=
(
BYTE
)
(
matchCode
%
255
)
;
}
else
*
token
+
=
(
BYTE
)
(
matchCode
)
;
}
anchor
=
ip
;
if
(
ip
>
=
mflimitPlusOne
)
break
;
LZ4_putPosition
(
ip
-
2
cctx
-
>
hashTable
tableType
base
)
;
if
(
tableType
=
=
byPtr
)
{
match
=
LZ4_getPosition
(
ip
cctx
-
>
hashTable
tableType
base
)
;
LZ4_putPosition
(
ip
cctx
-
>
hashTable
tableType
base
)
;
if
(
(
match
+
MAX_DISTANCE
>
=
ip
)
&
&
(
LZ4_read32
(
match
)
=
=
LZ4_read32
(
ip
)
)
)
{
token
=
op
+
+
;
*
token
=
0
;
goto
_next_match
;
}
}
else
{
U32
const
h
=
LZ4_hashPosition
(
ip
tableType
)
;
U32
const
current
=
(
U32
)
(
ip
-
base
)
;
U32
matchIndex
=
LZ4_getIndexOnHash
(
h
cctx
-
>
hashTable
tableType
)
;
assert
(
matchIndex
<
current
)
;
if
(
dictDirective
=
=
usingDictCtx
)
{
if
(
matchIndex
<
startIndex
)
{
matchIndex
=
LZ4_getIndexOnHash
(
h
dictCtx
-
>
hashTable
byU32
)
;
match
=
dictBase
+
matchIndex
;
lowLimit
=
dictionary
;
matchIndex
+
=
dictDelta
;
}
else
{
match
=
base
+
matchIndex
;
lowLimit
=
(
const
BYTE
*
)
source
;
}
}
else
if
(
dictDirective
=
=
usingExtDict
)
{
if
(
matchIndex
<
startIndex
)
{
match
=
dictBase
+
matchIndex
;
lowLimit
=
dictionary
;
}
else
{
match
=
base
+
matchIndex
;
lowLimit
=
(
const
BYTE
*
)
source
;
}
}
else
{
match
=
base
+
matchIndex
;
}
LZ4_putIndexOnHash
(
current
h
cctx
-
>
hashTable
tableType
)
;
assert
(
matchIndex
<
current
)
;
if
(
(
(
dictIssue
=
=
dictSmall
)
?
(
matchIndex
>
=
prefixIdxLimit
)
:
1
)
&
&
(
(
tableType
=
=
byU16
)
?
1
:
(
matchIndex
+
MAX_DISTANCE
>
=
current
)
)
&
&
(
LZ4_read32
(
match
)
=
=
LZ4_read32
(
ip
)
)
)
{
token
=
op
+
+
;
*
token
=
0
;
if
(
maybe_extMem
)
offset
=
current
-
matchIndex
;
DEBUGLOG
(
6
"
seq
.
start
:
%
i
literals
=
%
u
match
.
start
:
%
i
"
(
int
)
(
anchor
-
(
const
BYTE
*
)
source
)
0
(
int
)
(
ip
-
(
const
BYTE
*
)
source
)
)
;
goto
_next_match
;
}
}
forwardH
=
LZ4_hashPosition
(
+
+
ip
tableType
)
;
}
_last_literals
:
{
size_t
lastRun
=
(
size_t
)
(
iend
-
anchor
)
;
if
(
(
outputLimited
)
&
&
(
op
+
lastRun
+
1
+
(
(
lastRun
+
255
-
RUN_MASK
)
/
255
)
>
olimit
)
)
{
if
(
outputLimited
=
=
fillOutput
)
{
lastRun
=
(
olimit
-
op
)
-
1
;
lastRun
-
=
(
lastRun
+
240
)
/
255
;
}
if
(
outputLimited
=
=
limitedOutput
)
return
0
;
}
if
(
lastRun
>
=
RUN_MASK
)
{
size_t
accumulator
=
lastRun
-
RUN_MASK
;
*
op
+
+
=
RUN_MASK
<
<
ML_BITS
;
for
(
;
accumulator
>
=
255
;
accumulator
-
=
255
)
*
op
+
+
=
255
;
*
op
+
+
=
(
BYTE
)
accumulator
;
}
else
{
*
op
+
+
=
(
BYTE
)
(
lastRun
<
<
ML_BITS
)
;
}
memcpy
(
op
anchor
lastRun
)
;
ip
=
anchor
+
lastRun
;
op
+
=
lastRun
;
}
if
(
outputLimited
=
=
fillOutput
)
{
*
inputConsumed
=
(
int
)
(
(
(
const
char
*
)
ip
)
-
source
)
;
}
DEBUGLOG
(
5
"
LZ4_compress_generic
:
compressed
%
i
bytes
into
%
i
bytes
"
inputSize
(
int
)
(
(
(
char
*
)
op
)
-
dest
)
)
;
return
(
int
)
(
(
(
char
*
)
op
)
-
dest
)
;
}
int
LZ4_compress_fast_extState
(
void
*
state
const
char
*
source
char
*
dest
int
inputSize
int
maxOutputSize
int
acceleration
)
{
LZ4_stream_t_internal
*
ctx
=
&
(
(
LZ4_stream_t
*
)
state
)
-
>
internal_donotuse
;
if
(
acceleration
<
1
)
acceleration
=
ACCELERATION_DEFAULT
;
LZ4_resetStream
(
(
LZ4_stream_t
*
)
state
)
;
if
(
maxOutputSize
>
=
LZ4_compressBound
(
inputSize
)
)
{
if
(
inputSize
<
LZ4_64Klimit
)
{
return
LZ4_compress_generic
(
ctx
source
dest
inputSize
NULL
0
notLimited
byU16
noDict
noDictIssue
acceleration
)
;
}
else
{
const
tableType_t
tableType
=
(
(
sizeof
(
void
*
)
=
=
4
)
&
&
(
(
uptrval
)
source
>
MAX_DISTANCE
)
)
?
byPtr
:
byU32
;
return
LZ4_compress_generic
(
ctx
source
dest
inputSize
NULL
0
notLimited
tableType
noDict
noDictIssue
acceleration
)
;
}
}
else
{
if
(
inputSize
<
LZ4_64Klimit
)
{
;
return
LZ4_compress_generic
(
ctx
source
dest
inputSize
NULL
maxOutputSize
limitedOutput
byU16
noDict
noDictIssue
acceleration
)
;
}
else
{
const
tableType_t
tableType
=
(
(
sizeof
(
void
*
)
=
=
4
)
&
&
(
(
uptrval
)
source
>
MAX_DISTANCE
)
)
?
byPtr
:
byU32
;
return
LZ4_compress_generic
(
ctx
source
dest
inputSize
NULL
maxOutputSize
limitedOutput
tableType
noDict
noDictIssue
acceleration
)
;
}
}
}
int
LZ4_compress_fast_extState_fastReset
(
void
*
state
const
char
*
src
char
*
dst
int
srcSize
int
dstCapacity
int
acceleration
)
{
LZ4_stream_t_internal
*
ctx
=
&
(
(
LZ4_stream_t
*
)
state
)
-
>
internal_donotuse
;
if
(
acceleration
<
1
)
acceleration
=
ACCELERATION_DEFAULT
;
if
(
dstCapacity
>
=
LZ4_compressBound
(
srcSize
)
)
{
if
(
srcSize
<
LZ4_64Klimit
)
{
const
tableType_t
tableType
=
byU16
;
LZ4_prepareTable
(
ctx
srcSize
tableType
)
;
if
(
ctx
-
>
currentOffset
)
{
return
LZ4_compress_generic
(
ctx
src
dst
srcSize
NULL
0
notLimited
tableType
noDict
dictSmall
acceleration
)
;
}
else
{
return
LZ4_compress_generic
(
ctx
src
dst
srcSize
NULL
0
notLimited
tableType
noDict
noDictIssue
acceleration
)
;
}
}
else
{
const
tableType_t
tableType
=
(
(
sizeof
(
void
*
)
=
=
4
)
&
&
(
(
uptrval
)
src
>
MAX_DISTANCE
)
)
?
byPtr
:
byU32
;
LZ4_prepareTable
(
ctx
srcSize
tableType
)
;
return
LZ4_compress_generic
(
ctx
src
dst
srcSize
NULL
0
notLimited
tableType
noDict
noDictIssue
acceleration
)
;
}
}
else
{
if
(
srcSize
<
LZ4_64Klimit
)
{
const
tableType_t
tableType
=
byU16
;
LZ4_prepareTable
(
ctx
srcSize
tableType
)
;
if
(
ctx
-
>
currentOffset
)
{
return
LZ4_compress_generic
(
ctx
src
dst
srcSize
NULL
dstCapacity
limitedOutput
tableType
noDict
dictSmall
acceleration
)
;
}
else
{
return
LZ4_compress_generic
(
ctx
src
dst
srcSize
NULL
dstCapacity
limitedOutput
tableType
noDict
noDictIssue
acceleration
)
;
}
}
else
{
const
tableType_t
tableType
=
(
(
sizeof
(
void
*
)
=
=
4
)
&
&
(
(
uptrval
)
src
>
MAX_DISTANCE
)
)
?
byPtr
:
byU32
;
LZ4_prepareTable
(
ctx
srcSize
tableType
)
;
return
LZ4_compress_generic
(
ctx
src
dst
srcSize
NULL
dstCapacity
limitedOutput
tableType
noDict
noDictIssue
acceleration
)
;
}
}
}
int
LZ4_compress_fast
(
const
char
*
source
char
*
dest
int
inputSize
int
maxOutputSize
int
acceleration
)
{
int
result
;
#
if
(
LZ4_HEAPMODE
)
LZ4_stream_t
*
ctxPtr
=
ALLOC
(
sizeof
(
LZ4_stream_t
)
)
;
if
(
ctxPtr
=
=
NULL
)
return
0
;
#
else
LZ4_stream_t
ctx
;
LZ4_stream_t
*
const
ctxPtr
=
&
ctx
;
#
endif
result
=
LZ4_compress_fast_extState
(
ctxPtr
source
dest
inputSize
maxOutputSize
acceleration
)
;
#
if
(
LZ4_HEAPMODE
)
FREEMEM
(
ctxPtr
)
;
#
endif
return
result
;
}
int
LZ4_compress_default
(
const
char
*
source
char
*
dest
int
inputSize
int
maxOutputSize
)
{
return
LZ4_compress_fast
(
source
dest
inputSize
maxOutputSize
1
)
;
}
int
LZ4_compress_fast_force
(
const
char
*
source
char
*
dest
int
inputSize
int
maxOutputSize
int
acceleration
)
{
LZ4_stream_t
ctx
;
LZ4_resetStream
(
&
ctx
)
;
if
(
inputSize
<
LZ4_64Klimit
)
return
LZ4_compress_generic
(
&
ctx
.
internal_donotuse
source
dest
inputSize
NULL
maxOutputSize
limitedOutput
byU16
noDict
noDictIssue
acceleration
)
;
else
return
LZ4_compress_generic
(
&
ctx
.
internal_donotuse
source
dest
inputSize
NULL
maxOutputSize
limitedOutput
sizeof
(
void
*
)
=
=
8
?
byU32
:
byPtr
noDict
noDictIssue
acceleration
)
;
}
static
int
LZ4_compress_destSize_extState
(
LZ4_stream_t
*
state
const
char
*
src
char
*
dst
int
*
srcSizePtr
int
targetDstSize
)
{
LZ4_resetStream
(
state
)
;
if
(
targetDstSize
>
=
LZ4_compressBound
(
*
srcSizePtr
)
)
{
return
LZ4_compress_fast_extState
(
state
src
dst
*
srcSizePtr
targetDstSize
1
)
;
}
else
{
if
(
*
srcSizePtr
<
LZ4_64Klimit
)
{
return
LZ4_compress_generic
(
&
state
-
>
internal_donotuse
src
dst
*
srcSizePtr
srcSizePtr
targetDstSize
fillOutput
byU16
noDict
noDictIssue
1
)
;
}
else
{
tableType_t
const
tableType
=
(
(
sizeof
(
void
*
)
=
=
4
)
&
&
(
(
uptrval
)
src
>
MAX_DISTANCE
)
)
?
byPtr
:
byU32
;
return
LZ4_compress_generic
(
&
state
-
>
internal_donotuse
src
dst
*
srcSizePtr
srcSizePtr
targetDstSize
fillOutput
tableType
noDict
noDictIssue
1
)
;
}
}
}
int
LZ4_compress_destSize
(
const
char
*
src
char
*
dst
int
*
srcSizePtr
int
targetDstSize
)
{
#
if
(
LZ4_HEAPMODE
)
LZ4_stream_t
*
ctx
=
(
LZ4_stream_t
*
)
ALLOC
(
sizeof
(
LZ4_stream_t
)
)
;
if
(
ctx
=
=
NULL
)
return
0
;
#
else
LZ4_stream_t
ctxBody
;
LZ4_stream_t
*
ctx
=
&
ctxBody
;
#
endif
int
result
=
LZ4_compress_destSize_extState
(
ctx
src
dst
srcSizePtr
targetDstSize
)
;
#
if
(
LZ4_HEAPMODE
)
FREEMEM
(
ctx
)
;
#
endif
return
result
;
}
LZ4_stream_t
*
LZ4_createStream
(
void
)
{
LZ4_stream_t
*
lz4s
=
(
LZ4_stream_t
*
)
ALLOC
(
sizeof
(
LZ4_stream_t
)
)
;
LZ4_STATIC_ASSERT
(
LZ4_STREAMSIZE
>
=
sizeof
(
LZ4_stream_t_internal
)
)
;
DEBUGLOG
(
4
"
LZ4_createStream
%
p
"
lz4s
)
;
if
(
lz4s
=
=
NULL
)
return
NULL
;
LZ4_resetStream
(
lz4s
)
;
return
lz4s
;
}
void
LZ4_resetStream
(
LZ4_stream_t
*
LZ4_stream
)
{
DEBUGLOG
(
5
"
LZ4_resetStream
(
ctx
:
%
p
)
"
LZ4_stream
)
;
MEM_INIT
(
LZ4_stream
0
sizeof
(
LZ4_stream_t
)
)
;
}
void
LZ4_resetStream_fast
(
LZ4_stream_t
*
ctx
)
{
LZ4_prepareTable
(
&
(
ctx
-
>
internal_donotuse
)
0
byU32
)
;
}
int
LZ4_freeStream
(
LZ4_stream_t
*
LZ4_stream
)
{
if
(
!
LZ4_stream
)
return
0
;
DEBUGLOG
(
5
"
LZ4_freeStream
%
p
"
LZ4_stream
)
;
FREEMEM
(
LZ4_stream
)
;
return
(
0
)
;
}
#
define
HASH_UNIT
sizeof
(
reg_t
)
int
LZ4_loadDict
(
LZ4_stream_t
*
LZ4_dict
const
char
*
dictionary
int
dictSize
)
{
LZ4_stream_t_internal
*
dict
=
&
LZ4_dict
-
>
internal_donotuse
;
const
tableType_t
tableType
=
byU32
;
const
BYTE
*
p
=
(
const
BYTE
*
)
dictionary
;
const
BYTE
*
const
dictEnd
=
p
+
dictSize
;
const
BYTE
*
base
;
DEBUGLOG
(
4
"
LZ4_loadDict
(
%
i
bytes
from
%
p
into
%
p
)
"
dictSize
dictionary
LZ4_dict
)
;
LZ4_resetStream
(
LZ4_dict
)
;
if
(
(
dictEnd
-
p
)
>
64
KB
)
p
=
dictEnd
-
64
KB
;
base
=
dictEnd
-
64
KB
-
dict
-
>
currentOffset
;
dict
-
>
dictionary
=
p
;
dict
-
>
dictSize
=
(
U32
)
(
dictEnd
-
p
)
;
dict
-
>
currentOffset
+
=
64
KB
;
dict
-
>
tableType
=
tableType
;
if
(
dictSize
<
(
int
)
HASH_UNIT
)
{
return
0
;
}
while
(
p
<
=
dictEnd
-
HASH_UNIT
)
{
LZ4_putPosition
(
p
dict
-
>
hashTable
tableType
base
)
;
p
+
=
3
;
}
return
dict
-
>
dictSize
;
}
void
LZ4_attach_dictionary
(
LZ4_stream_t
*
working_stream
const
LZ4_stream_t
*
dictionary_stream
)
{
if
(
dictionary_stream
!
=
NULL
)
{
if
(
working_stream
-
>
internal_donotuse
.
currentOffset
=
=
0
)
{
working_stream
-
>
internal_donotuse
.
currentOffset
=
64
KB
;
}
working_stream
-
>
internal_donotuse
.
dictCtx
=
&
(
dictionary_stream
-
>
internal_donotuse
)
;
}
else
{
working_stream
-
>
internal_donotuse
.
dictCtx
=
NULL
;
}
}
static
void
LZ4_renormDictT
(
LZ4_stream_t_internal
*
LZ4_dict
int
nextSize
)
{
if
(
LZ4_dict
-
>
currentOffset
+
nextSize
>
0x80000000
)
{
U32
const
delta
=
LZ4_dict
-
>
currentOffset
-
64
KB
;
const
BYTE
*
dictEnd
=
LZ4_dict
-
>
dictionary
+
LZ4_dict
-
>
dictSize
;
int
i
;
DEBUGLOG
(
4
"
LZ4_renormDictT
"
)
;
for
(
i
=
0
;
i
<
LZ4_HASH_SIZE_U32
;
i
+
+
)
{
if
(
LZ4_dict
-
>
hashTable
[
i
]
<
delta
)
LZ4_dict
-
>
hashTable
[
i
]
=
0
;
else
LZ4_dict
-
>
hashTable
[
i
]
-
=
delta
;
}
LZ4_dict
-
>
currentOffset
=
64
KB
;
if
(
LZ4_dict
-
>
dictSize
>
64
KB
)
LZ4_dict
-
>
dictSize
=
64
KB
;
LZ4_dict
-
>
dictionary
=
dictEnd
-
LZ4_dict
-
>
dictSize
;
}
}
int
LZ4_compress_fast_continue
(
LZ4_stream_t
*
LZ4_stream
const
char
*
source
char
*
dest
int
inputSize
int
maxOutputSize
int
acceleration
)
{
const
tableType_t
tableType
=
byU32
;
LZ4_stream_t_internal
*
streamPtr
=
&
LZ4_stream
-
>
internal_donotuse
;
const
BYTE
*
dictEnd
=
streamPtr
-
>
dictionary
+
streamPtr
-
>
dictSize
;
DEBUGLOG
(
5
"
LZ4_compress_fast_continue
(
inputSize
=
%
i
)
"
inputSize
)
;
if
(
streamPtr
-
>
initCheck
)
return
0
;
LZ4_renormDictT
(
streamPtr
inputSize
)
;
if
(
acceleration
<
1
)
acceleration
=
ACCELERATION_DEFAULT
;
if
(
(
streamPtr
-
>
dictSize
-
1
<
4
)
&
&
(
dictEnd
!
=
(
const
BYTE
*
)
source
)
)
{
DEBUGLOG
(
5
"
LZ4_compress_fast_continue
:
dictSize
(
%
u
)
at
addr
:
%
p
is
too
small
"
streamPtr
-
>
dictSize
streamPtr
-
>
dictionary
)
;
streamPtr
-
>
dictSize
=
0
;
streamPtr
-
>
dictionary
=
(
const
BYTE
*
)
source
;
dictEnd
=
(
const
BYTE
*
)
source
;
}
{
const
BYTE
*
sourceEnd
=
(
const
BYTE
*
)
source
+
inputSize
;
if
(
(
sourceEnd
>
streamPtr
-
>
dictionary
)
&
&
(
sourceEnd
<
dictEnd
)
)
{
streamPtr
-
>
dictSize
=
(
U32
)
(
dictEnd
-
sourceEnd
)
;
if
(
streamPtr
-
>
dictSize
>
64
KB
)
streamPtr
-
>
dictSize
=
64
KB
;
if
(
streamPtr
-
>
dictSize
<
4
)
streamPtr
-
>
dictSize
=
0
;
streamPtr
-
>
dictionary
=
dictEnd
-
streamPtr
-
>
dictSize
;
}
}
if
(
dictEnd
=
=
(
const
BYTE
*
)
source
)
{
if
(
(
streamPtr
-
>
dictSize
<
64
KB
)
&
&
(
streamPtr
-
>
dictSize
<
streamPtr
-
>
currentOffset
)
)
return
LZ4_compress_generic
(
streamPtr
source
dest
inputSize
NULL
maxOutputSize
limitedOutput
tableType
withPrefix64k
dictSmall
acceleration
)
;
else
return
LZ4_compress_generic
(
streamPtr
source
dest
inputSize
NULL
maxOutputSize
limitedOutput
tableType
withPrefix64k
noDictIssue
acceleration
)
;
}
{
int
result
;
if
(
streamPtr
-
>
dictCtx
)
{
if
(
inputSize
>
4
KB
)
{
memcpy
(
streamPtr
streamPtr
-
>
dictCtx
sizeof
(
LZ4_stream_t
)
)
;
result
=
LZ4_compress_generic
(
streamPtr
source
dest
inputSize
NULL
maxOutputSize
limitedOutput
tableType
usingExtDict
noDictIssue
acceleration
)
;
}
else
{
result
=
LZ4_compress_generic
(
streamPtr
source
dest
inputSize
NULL
maxOutputSize
limitedOutput
tableType
usingDictCtx
noDictIssue
acceleration
)
;
}
}
else
{
if
(
(
streamPtr
-
>
dictSize
<
64
KB
)
&
&
(
streamPtr
-
>
dictSize
<
streamPtr
-
>
currentOffset
)
)
{
result
=
LZ4_compress_generic
(
streamPtr
source
dest
inputSize
NULL
maxOutputSize
limitedOutput
tableType
usingExtDict
dictSmall
acceleration
)
;
}
else
{
result
=
LZ4_compress_generic
(
streamPtr
source
dest
inputSize
NULL
maxOutputSize
limitedOutput
tableType
usingExtDict
noDictIssue
acceleration
)
;
}
}
streamPtr
-
>
dictionary
=
(
const
BYTE
*
)
source
;
streamPtr
-
>
dictSize
=
(
U32
)
inputSize
;
return
result
;
}
}
int
LZ4_compress_forceExtDict
(
LZ4_stream_t
*
LZ4_dict
const
char
*
source
char
*
dest
int
srcSize
)
{
LZ4_stream_t_internal
*
streamPtr
=
&
LZ4_dict
-
>
internal_donotuse
;
int
result
;
LZ4_renormDictT
(
streamPtr
srcSize
)
;
if
(
(
streamPtr
-
>
dictSize
<
64
KB
)
&
&
(
streamPtr
-
>
dictSize
<
streamPtr
-
>
currentOffset
)
)
{
result
=
LZ4_compress_generic
(
streamPtr
source
dest
srcSize
NULL
0
notLimited
byU32
usingExtDict
dictSmall
1
)
;
}
else
{
result
=
LZ4_compress_generic
(
streamPtr
source
dest
srcSize
NULL
0
notLimited
byU32
usingExtDict
noDictIssue
1
)
;
}
streamPtr
-
>
dictionary
=
(
const
BYTE
*
)
source
;
streamPtr
-
>
dictSize
=
(
U32
)
srcSize
;
return
result
;
}
int
LZ4_saveDict
(
LZ4_stream_t
*
LZ4_dict
char
*
safeBuffer
int
dictSize
)
{
LZ4_stream_t_internal
*
const
dict
=
&
LZ4_dict
-
>
internal_donotuse
;
const
BYTE
*
const
previousDictEnd
=
dict
-
>
dictionary
+
dict
-
>
dictSize
;
if
(
(
U32
)
dictSize
>
64
KB
)
dictSize
=
64
KB
;
if
(
(
U32
)
dictSize
>
dict
-
>
dictSize
)
dictSize
=
dict
-
>
dictSize
;
memmove
(
safeBuffer
previousDictEnd
-
dictSize
dictSize
)
;
dict
-
>
dictionary
=
(
const
BYTE
*
)
safeBuffer
;
dict
-
>
dictSize
=
(
U32
)
dictSize
;
return
dictSize
;
}
LZ4_FORCE_O2_GCC_PPC64LE
LZ4_FORCE_INLINE
int
LZ4_decompress_generic
(
const
char
*
const
src
char
*
const
dst
int
srcSize
int
outputSize
int
endOnInput
int
partialDecoding
int
targetOutputSize
int
dict
const
BYTE
*
const
lowPrefix
const
BYTE
*
const
dictStart
const
size_t
dictSize
)
{
const
BYTE
*
ip
=
(
const
BYTE
*
)
src
;
const
BYTE
*
const
iend
=
ip
+
srcSize
;
BYTE
*
op
=
(
BYTE
*
)
dst
;
BYTE
*
const
oend
=
op
+
outputSize
;
BYTE
*
cpy
;
BYTE
*
oexit
=
op
+
targetOutputSize
;
const
BYTE
*
const
dictEnd
=
(
const
BYTE
*
)
dictStart
+
dictSize
;
const
unsigned
inc32table
[
8
]
=
{
0
1
2
1
0
4
4
4
}
;
const
int
dec64table
[
8
]
=
{
0
0
0
-
1
-
4
1
2
3
}
;
const
int
safeDecode
=
(
endOnInput
=
=
endOnInputSize
)
;
const
int
checkOffset
=
(
(
safeDecode
)
&
&
(
dictSize
<
(
int
)
(
64
KB
)
)
)
;
const
BYTE
*
const
shortiend
=
iend
-
(
endOnInput
?
14
:
8
)
-
2
;
const
BYTE
*
const
shortoend
=
oend
-
(
endOnInput
?
14
:
8
)
-
18
;
DEBUGLOG
(
5
"
LZ4_decompress_generic
(
srcSize
:
%
i
)
"
srcSize
)
;
if
(
(
partialDecoding
)
&
&
(
oexit
>
oend
-
MFLIMIT
)
)
oexit
=
oend
-
MFLIMIT
;
if
(
(
endOnInput
)
&
&
(
unlikely
(
outputSize
=
=
0
)
)
)
return
(
(
srcSize
=
=
1
)
&
&
(
*
ip
=
=
0
)
)
?
0
:
-
1
;
if
(
(
!
endOnInput
)
&
&
(
unlikely
(
outputSize
=
=
0
)
)
)
return
(
*
ip
=
=
0
?
1
:
-
1
)
;
if
(
(
endOnInput
)
&
&
unlikely
(
srcSize
=
=
0
)
)
return
-
1
;
while
(
1
)
{
const
BYTE
*
match
;
size_t
offset
;
unsigned
const
token
=
*
ip
+
+
;
size_t
length
=
token
>
>
ML_BITS
;
assert
(
!
endOnInput
|
|
ip
<
=
iend
)
;
if
(
(
endOnInput
?
length
!
=
RUN_MASK
:
length
<
=
8
)
&
&
likely
(
(
endOnInput
?
ip
<
shortiend
:
1
)
&
(
op
<
=
shortoend
)
)
)
{
memcpy
(
op
ip
endOnInput
?
16
:
8
)
;
op
+
=
length
;
ip
+
=
length
;
length
=
token
&
ML_MASK
;
offset
=
LZ4_readLE16
(
ip
)
;
ip
+
=
2
;
match
=
op
-
offset
;
if
(
(
length
!
=
ML_MASK
)
&
&
(
offset
>
=
8
)
&
&
(
dict
=
=
withPrefix64k
|
|
match
>
=
lowPrefix
)
)
{
memcpy
(
op
+
0
match
+
0
8
)
;
memcpy
(
op
+
8
match
+
8
8
)
;
memcpy
(
op
+
16
match
+
16
2
)
;
op
+
=
length
+
MINMATCH
;
continue
;
}
goto
_copy_match
;
}
if
(
length
=
=
RUN_MASK
)
{
unsigned
s
;
if
(
unlikely
(
endOnInput
?
ip
>
=
iend
-
RUN_MASK
:
0
)
)
goto
_output_error
;
do
{
s
=
*
ip
+
+
;
length
+
=
s
;
}
while
(
likely
(
endOnInput
?
ip
<
iend
-
RUN_MASK
:
1
)
&
(
s
=
=
255
)
)
;
if
(
(
safeDecode
)
&
&
unlikely
(
(
uptrval
)
(
op
)
+
length
<
(
uptrval
)
(
op
)
)
)
goto
_output_error
;
if
(
(
safeDecode
)
&
&
unlikely
(
(
uptrval
)
(
ip
)
+
length
<
(
uptrval
)
(
ip
)
)
)
goto
_output_error
;
}
cpy
=
op
+
length
;
if
(
(
(
endOnInput
)
&
&
(
(
cpy
>
(
partialDecoding
?
oexit
:
oend
-
MFLIMIT
)
)
|
|
(
ip
+
length
>
iend
-
(
2
+
1
+
LASTLITERALS
)
)
)
)
|
|
(
(
!
endOnInput
)
&
&
(
cpy
>
oend
-
WILDCOPYLENGTH
)
)
)
{
if
(
partialDecoding
)
{
if
(
cpy
>
oend
)
goto
_output_error
;
if
(
(
endOnInput
)
&
&
(
ip
+
length
>
iend
)
)
goto
_output_error
;
}
else
{
if
(
(
!
endOnInput
)
&
&
(
cpy
!
=
oend
)
)
goto
_output_error
;
if
(
(
endOnInput
)
&
&
(
(
ip
+
length
!
=
iend
)
|
|
(
cpy
>
oend
)
)
)
goto
_output_error
;
}
memcpy
(
op
ip
length
)
;
ip
+
=
length
;
op
+
=
length
;
break
;
}
LZ4_wildCopy
(
op
ip
cpy
)
;
ip
+
=
length
;
op
=
cpy
;
offset
=
LZ4_readLE16
(
ip
)
;
ip
+
=
2
;
match
=
op
-
offset
;
length
=
token
&
ML_MASK
;
_copy_match
:
if
(
(
checkOffset
)
&
&
(
unlikely
(
match
+
dictSize
<
lowPrefix
)
)
)
goto
_output_error
;
LZ4_write32
(
op
(
U32
)
offset
)
;
if
(
length
=
=
ML_MASK
)
{
unsigned
s
;
do
{
s
=
*
ip
+
+
;
if
(
(
endOnInput
)
&
&
(
ip
>
iend
-
LASTLITERALS
)
)
goto
_output_error
;
length
+
=
s
;
}
while
(
s
=
=
255
)
;
if
(
(
safeDecode
)
&
&
unlikely
(
(
uptrval
)
(
op
)
+
length
<
(
uptrval
)
op
)
)
goto
_output_error
;
}
length
+
=
MINMATCH
;
if
(
(
dict
=
=
usingExtDict
)
&
&
(
match
<
lowPrefix
)
)
{
if
(
unlikely
(
op
+
length
>
oend
-
LASTLITERALS
)
)
goto
_output_error
;
if
(
length
<
=
(
size_t
)
(
lowPrefix
-
match
)
)
{
memmove
(
op
dictEnd
-
(
lowPrefix
-
match
)
length
)
;
op
+
=
length
;
}
else
{
size_t
const
copySize
=
(
size_t
)
(
lowPrefix
-
match
)
;
size_t
const
restSize
=
length
-
copySize
;
memcpy
(
op
dictEnd
-
copySize
copySize
)
;
op
+
=
copySize
;
if
(
restSize
>
(
size_t
)
(
op
-
lowPrefix
)
)
{
BYTE
*
const
endOfMatch
=
op
+
restSize
;
const
BYTE
*
copyFrom
=
lowPrefix
;
while
(
op
<
endOfMatch
)
*
op
+
+
=
*
copyFrom
+
+
;
}
else
{
memcpy
(
op
lowPrefix
restSize
)
;
op
+
=
restSize
;
}
}
continue
;
}
cpy
=
op
+
length
;
if
(
unlikely
(
offset
<
8
)
)
{
op
[
0
]
=
match
[
0
]
;
op
[
1
]
=
match
[
1
]
;
op
[
2
]
=
match
[
2
]
;
op
[
3
]
=
match
[
3
]
;
match
+
=
inc32table
[
offset
]
;
memcpy
(
op
+
4
match
4
)
;
match
-
=
dec64table
[
offset
]
;
}
else
{
memcpy
(
op
match
8
)
;
match
+
=
8
;
}
op
+
=
8
;
if
(
unlikely
(
cpy
>
oend
-
12
)
)
{
BYTE
*
const
oCopyLimit
=
oend
-
(
WILDCOPYLENGTH
-
1
)
;
if
(
cpy
>
oend
-
LASTLITERALS
)
goto
_output_error
;
if
(
op
<
oCopyLimit
)
{
LZ4_wildCopy
(
op
match
oCopyLimit
)
;
match
+
=
oCopyLimit
-
op
;
op
=
oCopyLimit
;
}
while
(
op
<
cpy
)
*
op
+
+
=
*
match
+
+
;
}
else
{
memcpy
(
op
match
8
)
;
if
(
length
>
16
)
LZ4_wildCopy
(
op
+
8
match
+
8
cpy
)
;
}
op
=
cpy
;
}
if
(
endOnInput
)
return
(
int
)
(
(
(
char
*
)
op
)
-
dst
)
;
else
return
(
int
)
(
(
(
const
char
*
)
ip
)
-
src
)
;
_output_error
:
return
(
int
)
(
-
(
(
(
const
char
*
)
ip
)
-
src
)
)
-
1
;
}
LZ4_FORCE_O2_GCC_PPC64LE
int
LZ4_decompress_safe
(
const
char
*
source
char
*
dest
int
compressedSize
int
maxDecompressedSize
)
{
return
LZ4_decompress_generic
(
source
dest
compressedSize
maxDecompressedSize
endOnInputSize
full
0
noDict
(
BYTE
*
)
dest
NULL
0
)
;
}
LZ4_FORCE_O2_GCC_PPC64LE
int
LZ4_decompress_safe_partial
(
const
char
*
source
char
*
dest
int
compressedSize
int
targetOutputSize
int
maxDecompressedSize
)
{
return
LZ4_decompress_generic
(
source
dest
compressedSize
maxDecompressedSize
endOnInputSize
partial
targetOutputSize
noDict
(
BYTE
*
)
dest
NULL
0
)
;
}
LZ4_FORCE_O2_GCC_PPC64LE
int
LZ4_decompress_fast
(
const
char
*
source
char
*
dest
int
originalSize
)
{
return
LZ4_decompress_generic
(
source
dest
0
originalSize
endOnOutputSize
full
0
withPrefix64k
(
BYTE
*
)
dest
-
64
KB
NULL
0
)
;
}
LZ4_FORCE_O2_GCC_PPC64LE
int
LZ4_decompress_safe_withPrefix64k
(
const
char
*
source
char
*
dest
int
compressedSize
int
maxOutputSize
)
{
return
LZ4_decompress_generic
(
source
dest
compressedSize
maxOutputSize
endOnInputSize
full
0
withPrefix64k
(
BYTE
*
)
dest
-
64
KB
NULL
0
)
;
}
int
LZ4_decompress_fast_withPrefix64k
(
const
char
*
source
char
*
dest
int
originalSize
)
{
return
LZ4_decompress_fast
(
source
dest
originalSize
)
;
}
LZ4_FORCE_O2_GCC_PPC64LE
static
int
LZ4_decompress_safe_withSmallPrefix
(
const
char
*
source
char
*
dest
int
compressedSize
int
maxOutputSize
size_t
prefixSize
)
{
return
LZ4_decompress_generic
(
source
dest
compressedSize
maxOutputSize
endOnInputSize
full
0
noDict
(
BYTE
*
)
dest
-
prefixSize
NULL
0
)
;
}
LZ4_FORCE_O2_GCC_PPC64LE
#
define
LZ4_decompress_safe_extDict
LZ4_decompress_safe_forceExtDict
int
LZ4_decompress_safe_extDict
(
const
char
*
source
char
*
dest
int
compressedSize
int
maxOutputSize
const
void
*
dictStart
size_t
dictSize
)
{
return
LZ4_decompress_generic
(
source
dest
compressedSize
maxOutputSize
endOnInputSize
full
0
usingExtDict
(
BYTE
*
)
dest
(
const
BYTE
*
)
dictStart
dictSize
)
;
}
LZ4_FORCE_O2_GCC_PPC64LE
static
int
LZ4_decompress_fast_extDict
(
const
char
*
source
char
*
dest
int
originalSize
const
void
*
dictStart
size_t
dictSize
)
{
return
LZ4_decompress_generic
(
source
dest
0
originalSize
endOnOutputSize
full
0
usingExtDict
(
BYTE
*
)
dest
(
const
BYTE
*
)
dictStart
dictSize
)
;
}
LZ4_FORCE_INLINE
int
LZ4_decompress_safe_doubleDict
(
const
char
*
source
char
*
dest
int
compressedSize
int
maxOutputSize
size_t
prefixSize
const
void
*
dictStart
size_t
dictSize
)
{
return
LZ4_decompress_generic
(
source
dest
compressedSize
maxOutputSize
endOnInputSize
full
0
usingExtDict
(
BYTE
*
)
dest
-
prefixSize
(
const
BYTE
*
)
dictStart
dictSize
)
;
}
LZ4_FORCE_INLINE
int
LZ4_decompress_fast_doubleDict
(
const
char
*
source
char
*
dest
int
originalSize
size_t
prefixSize
const
void
*
dictStart
size_t
dictSize
)
{
return
LZ4_decompress_generic
(
source
dest
0
originalSize
endOnOutputSize
full
0
usingExtDict
(
BYTE
*
)
dest
-
prefixSize
(
const
BYTE
*
)
dictStart
dictSize
)
;
}
LZ4_streamDecode_t
*
LZ4_createStreamDecode
(
void
)
{
LZ4_streamDecode_t
*
lz4s
=
(
LZ4_streamDecode_t
*
)
ALLOC_AND_ZERO
(
sizeof
(
LZ4_streamDecode_t
)
)
;
return
lz4s
;
}
int
LZ4_freeStreamDecode
(
LZ4_streamDecode_t
*
LZ4_stream
)
{
if
(
!
LZ4_stream
)
return
0
;
FREEMEM
(
LZ4_stream
)
;
return
0
;
}
int
LZ4_setStreamDecode
(
LZ4_streamDecode_t
*
LZ4_streamDecode
const
char
*
dictionary
int
dictSize
)
{
LZ4_streamDecode_t_internal
*
lz4sd
=
&
LZ4_streamDecode
-
>
internal_donotuse
;
lz4sd
-
>
prefixSize
=
(
size_t
)
dictSize
;
lz4sd
-
>
prefixEnd
=
(
const
BYTE
*
)
dictionary
+
dictSize
;
lz4sd
-
>
externalDict
=
NULL
;
lz4sd
-
>
extDictSize
=
0
;
return
1
;
}
int
LZ4_decoderRingBufferSize
(
int
maxBlockSize
)
{
if
(
maxBlockSize
<
0
)
return
0
;
if
(
maxBlockSize
>
LZ4_MAX_INPUT_SIZE
)
return
0
;
if
(
maxBlockSize
<
16
)
maxBlockSize
=
16
;
return
LZ4_DECODER_RING_BUFFER_SIZE
(
maxBlockSize
)
;
}
LZ4_FORCE_O2_GCC_PPC64LE
int
LZ4_decompress_safe_continue
(
LZ4_streamDecode_t
*
LZ4_streamDecode
const
char
*
source
char
*
dest
int
compressedSize
int
maxOutputSize
)
{
LZ4_streamDecode_t_internal
*
lz4sd
=
&
LZ4_streamDecode
-
>
internal_donotuse
;
int
result
;
if
(
lz4sd
-
>
prefixSize
=
=
0
)
{
assert
(
lz4sd
-
>
extDictSize
=
=
0
)
;
result
=
LZ4_decompress_safe
(
source
dest
compressedSize
maxOutputSize
)
;
if
(
result
<
=
0
)
return
result
;
lz4sd
-
>
prefixSize
=
result
;
lz4sd
-
>
prefixEnd
=
(
BYTE
*
)
dest
+
result
;
}
else
if
(
lz4sd
-
>
prefixEnd
=
=
(
BYTE
*
)
dest
)
{
if
(
lz4sd
-
>
prefixSize
>
=
64
KB
-
1
)
result
=
LZ4_decompress_safe_withPrefix64k
(
source
dest
compressedSize
maxOutputSize
)
;
else
if
(
lz4sd
-
>
extDictSize
=
=
0
)
result
=
LZ4_decompress_safe_withSmallPrefix
(
source
dest
compressedSize
maxOutputSize
lz4sd
-
>
prefixSize
)
;
else
result
=
LZ4_decompress_safe_doubleDict
(
source
dest
compressedSize
maxOutputSize
lz4sd
-
>
prefixSize
lz4sd
-
>
externalDict
lz4sd
-
>
extDictSize
)
;
if
(
result
<
=
0
)
return
result
;
lz4sd
-
>
prefixSize
+
=
result
;
lz4sd
-
>
prefixEnd
+
=
result
;
}
else
{
lz4sd
-
>
extDictSize
=
lz4sd
-
>
prefixSize
;
lz4sd
-
>
externalDict
=
lz4sd
-
>
prefixEnd
-
lz4sd
-
>
extDictSize
;
result
=
LZ4_decompress_safe_extDict
(
source
dest
compressedSize
maxOutputSize
lz4sd
-
>
externalDict
lz4sd
-
>
extDictSize
)
;
if
(
result
<
=
0
)
return
result
;
lz4sd
-
>
prefixSize
=
result
;
lz4sd
-
>
prefixEnd
=
(
BYTE
*
)
dest
+
result
;
}
return
result
;
}
LZ4_FORCE_O2_GCC_PPC64LE
int
LZ4_decompress_fast_continue
(
LZ4_streamDecode_t
*
LZ4_streamDecode
const
char
*
source
char
*
dest
int
originalSize
)
{
LZ4_streamDecode_t_internal
*
lz4sd
=
&
LZ4_streamDecode
-
>
internal_donotuse
;
int
result
;
if
(
lz4sd
-
>
prefixSize
=
=
0
)
{
assert
(
lz4sd
-
>
extDictSize
=
=
0
)
;
result
=
LZ4_decompress_fast
(
source
dest
originalSize
)
;
if
(
result
<
=
0
)
return
result
;
lz4sd
-
>
prefixSize
=
originalSize
;
lz4sd
-
>
prefixEnd
=
(
BYTE
*
)
dest
+
originalSize
;
}
else
if
(
lz4sd
-
>
prefixEnd
=
=
(
BYTE
*
)
dest
)
{
if
(
lz4sd
-
>
prefixSize
>
=
64
KB
-
1
|
|
lz4sd
-
>
extDictSize
=
=
0
)
result
=
LZ4_decompress_fast
(
source
dest
originalSize
)
;
else
result
=
LZ4_decompress_fast_doubleDict
(
source
dest
originalSize
lz4sd
-
>
prefixSize
lz4sd
-
>
externalDict
lz4sd
-
>
extDictSize
)
;
if
(
result
<
=
0
)
return
result
;
lz4sd
-
>
prefixSize
+
=
originalSize
;
lz4sd
-
>
prefixEnd
+
=
originalSize
;
}
else
{
lz4sd
-
>
extDictSize
=
lz4sd
-
>
prefixSize
;
lz4sd
-
>
externalDict
=
lz4sd
-
>
prefixEnd
-
lz4sd
-
>
extDictSize
;
result
=
LZ4_decompress_fast_extDict
(
source
dest
originalSize
lz4sd
-
>
externalDict
lz4sd
-
>
extDictSize
)
;
if
(
result
<
=
0
)
return
result
;
lz4sd
-
>
prefixSize
=
originalSize
;
lz4sd
-
>
prefixEnd
=
(
BYTE
*
)
dest
+
originalSize
;
}
return
result
;
}
int
LZ4_decompress_safe_usingDict
(
const
char
*
source
char
*
dest
int
compressedSize
int
maxOutputSize
const
char
*
dictStart
int
dictSize
)
{
if
(
dictSize
=
=
0
)
return
LZ4_decompress_safe
(
source
dest
compressedSize
maxOutputSize
)
;
if
(
dictStart
+
dictSize
=
=
dest
)
{
if
(
dictSize
>
=
64
KB
-
1
)
return
LZ4_decompress_safe_withPrefix64k
(
source
dest
compressedSize
maxOutputSize
)
;
return
LZ4_decompress_safe_withSmallPrefix
(
source
dest
compressedSize
maxOutputSize
dictSize
)
;
}
return
LZ4_decompress_safe_extDict
(
source
dest
compressedSize
maxOutputSize
dictStart
dictSize
)
;
}
int
LZ4_decompress_fast_usingDict
(
const
char
*
source
char
*
dest
int
originalSize
const
char
*
dictStart
int
dictSize
)
{
if
(
dictSize
=
=
0
|
|
dictStart
+
dictSize
=
=
dest
)
return
LZ4_decompress_fast
(
source
dest
originalSize
)
;
return
LZ4_decompress_fast_extDict
(
source
dest
originalSize
dictStart
dictSize
)
;
}
int
LZ4_compress_limitedOutput
(
const
char
*
source
char
*
dest
int
inputSize
int
maxOutputSize
)
{
return
LZ4_compress_default
(
source
dest
inputSize
maxOutputSize
)
;
}
int
LZ4_compress
(
const
char
*
source
char
*
dest
int
inputSize
)
{
return
LZ4_compress_default
(
source
dest
inputSize
LZ4_compressBound
(
inputSize
)
)
;
}
int
LZ4_compress_limitedOutput_withState
(
void
*
state
const
char
*
src
char
*
dst
int
srcSize
int
dstSize
)
{
return
LZ4_compress_fast_extState
(
state
src
dst
srcSize
dstSize
1
)
;
}
int
LZ4_compress_withState
(
void
*
state
const
char
*
src
char
*
dst
int
srcSize
)
{
return
LZ4_compress_fast_extState
(
state
src
dst
srcSize
LZ4_compressBound
(
srcSize
)
1
)
;
}
int
LZ4_compress_limitedOutput_continue
(
LZ4_stream_t
*
LZ4_stream
const
char
*
src
char
*
dst
int
srcSize
int
dstCapacity
)
{
return
LZ4_compress_fast_continue
(
LZ4_stream
src
dst
srcSize
dstCapacity
1
)
;
}
int
LZ4_compress_continue
(
LZ4_stream_t
*
LZ4_stream
const
char
*
source
char
*
dest
int
inputSize
)
{
return
LZ4_compress_fast_continue
(
LZ4_stream
source
dest
inputSize
LZ4_compressBound
(
inputSize
)
1
)
;
}
int
LZ4_uncompress
(
const
char
*
source
char
*
dest
int
outputSize
)
{
return
LZ4_decompress_fast
(
source
dest
outputSize
)
;
}
int
LZ4_uncompress_unknownOutputSize
(
const
char
*
source
char
*
dest
int
isize
int
maxOutputSize
)
{
return
LZ4_decompress_safe
(
source
dest
isize
maxOutputSize
)
;
}
int
LZ4_sizeofStreamState
(
)
{
return
LZ4_STREAMSIZE
;
}
int
LZ4_resetStreamState
(
void
*
state
char
*
inputBuffer
)
{
(
void
)
inputBuffer
;
LZ4_resetStream
(
(
LZ4_stream_t
*
)
state
)
;
return
0
;
}
void
*
LZ4_create
(
char
*
inputBuffer
)
{
(
void
)
inputBuffer
;
return
LZ4_createStream
(
)
;
}
char
*
LZ4_slideInputBuffer
(
void
*
state
)
{
return
(
char
*
)
(
uptrval
)
(
(
LZ4_stream_t
*
)
state
)
-
>
internal_donotuse
.
dictionary
;
}
#
endif
