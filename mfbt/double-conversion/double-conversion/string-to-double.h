#
ifndef
DOUBLE_CONVERSION_STRING_TO_DOUBLE_H_
#
define
DOUBLE_CONVERSION_STRING_TO_DOUBLE_H_
#
include
"
mozilla
/
Types
.
h
"
#
include
"
utils
.
h
"
namespace
double_conversion
{
class
StringToDoubleConverter
{
public
:
enum
Flags
{
NO_FLAGS
=
0
ALLOW_HEX
=
1
ALLOW_OCTALS
=
2
ALLOW_TRAILING_JUNK
=
4
ALLOW_LEADING_SPACES
=
8
ALLOW_TRAILING_SPACES
=
16
ALLOW_SPACES_AFTER_SIGN
=
32
ALLOW_CASE_INSENSITIVITY
=
64
ALLOW_CASE_INSENSIBILITY
=
64
ALLOW_HEX_FLOATS
=
128
}
;
static
const
uc16
kNoSeparator
=
'
\
0
'
;
StringToDoubleConverter
(
int
flags
double
empty_string_value
double
junk_string_value
const
char
*
infinity_symbol
const
char
*
nan_symbol
uc16
separator
=
kNoSeparator
)
:
flags_
(
flags
)
empty_string_value_
(
empty_string_value
)
junk_string_value_
(
junk_string_value
)
infinity_symbol_
(
infinity_symbol
)
nan_symbol_
(
nan_symbol
)
separator_
(
separator
)
{
}
MFBT_API
double
StringToDouble
(
const
char
*
buffer
int
length
int
*
processed_characters_count
)
const
;
MFBT_API
double
StringToDouble
(
const
uc16
*
buffer
int
length
int
*
processed_characters_count
)
const
;
MFBT_API
float
StringToFloat
(
const
char
*
buffer
int
length
int
*
processed_characters_count
)
const
;
MFBT_API
float
StringToFloat
(
const
uc16
*
buffer
int
length
int
*
processed_characters_count
)
const
;
template
<
typename
T
>
T
StringTo
(
const
char
*
buffer
int
length
int
*
processed_characters_count
)
const
;
template
<
typename
T
>
T
StringTo
(
const
uc16
*
buffer
int
length
int
*
processed_characters_count
)
const
;
private
:
const
int
flags_
;
const
double
empty_string_value_
;
const
double
junk_string_value_
;
const
char
*
const
infinity_symbol_
;
const
char
*
const
nan_symbol_
;
const
uc16
separator_
;
template
<
class
Iterator
>
double
StringToIeee
(
Iterator
start_pointer
int
length
bool
read_as_double
int
*
processed_characters_count
)
const
;
DOUBLE_CONVERSION_DISALLOW_IMPLICIT_CONSTRUCTORS
(
StringToDoubleConverter
)
;
}
;
}
#
endif
