#
ifndef
mozilla_RefCounted_h
#
define
mozilla_RefCounted_h
#
include
<
atomic
>
#
include
<
utility
>
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
RefCountType
.
h
"
#
include
"
mozilla
/
TypeTraits
.
h
"
#
if
defined
(
MOZILLA_INTERNAL_API
)
#
include
"
nsXPCOM
.
h
"
#
endif
#
if
defined
(
MOZILLA_INTERNAL_API
)
&
&
\
(
defined
(
DEBUG
)
|
|
defined
(
FORCE_BUILD_REFCNT_LOGGING
)
)
#
define
MOZ_REFCOUNTED_LEAK_CHECKING
#
endif
namespace
mozilla
{
namespace
detail
{
const
MozRefCountType
DEAD
=
0xffffdead
;
#
ifdef
MOZ_REFCOUNTED_LEAK_CHECKING
class
RefCountLogger
{
public
:
static
void
logAddRef
(
const
void
*
aPointer
MozRefCountType
aRefCount
const
char
*
aTypeName
uint32_t
aInstanceSize
)
{
MOZ_ASSERT
(
aRefCount
!
=
DEAD
)
;
NS_LogAddRef
(
const_cast
<
void
*
>
(
aPointer
)
aRefCount
aTypeName
aInstanceSize
)
;
}
static
void
logRelease
(
const
void
*
aPointer
MozRefCountType
aRefCount
const
char
*
aTypeName
)
{
MOZ_ASSERT
(
aRefCount
!
=
DEAD
)
;
NS_LogRelease
(
const_cast
<
void
*
>
(
aPointer
)
aRefCount
aTypeName
)
;
}
}
;
#
endif
enum
RefCountAtomicity
{
AtomicRefCount
NonAtomicRefCount
}
;
template
<
typename
T
RefCountAtomicity
Atomicity
recordreplay
:
:
Behavior
Recording
>
class
RC
{
public
:
explicit
RC
(
T
aCount
)
:
mValue
(
aCount
)
{
}
T
operator
+
+
(
)
{
return
+
+
mValue
;
}
T
operator
-
-
(
)
{
return
-
-
mValue
;
}
void
operator
=
(
const
T
&
aValue
)
{
mValue
=
aValue
;
}
operator
T
(
)
const
{
return
mValue
;
}
private
:
T
mValue
;
}
;
template
<
typename
T
recordreplay
:
:
Behavior
Recording
>
class
RC
<
T
AtomicRefCount
Recording
>
{
public
:
explicit
RC
(
T
aCount
)
:
mValue
(
aCount
)
{
}
T
operator
+
+
(
)
{
AutoRecordAtomicAccess
<
Recording
>
record
(
this
)
;
return
mValue
.
fetch_add
(
1
std
:
:
memory_order_relaxed
)
+
1
;
}
T
operator
-
-
(
)
{
AutoRecordAtomicAccess
<
Recording
>
record
(
this
)
;
T
result
=
mValue
.
fetch_sub
(
1
std
:
:
memory_order_release
)
-
1
;
if
(
result
=
=
0
)
{
#
ifdef
MOZ_TSAN
mValue
.
load
(
std
:
:
memory_order_acquire
)
;
#
else
std
:
:
atomic_thread_fence
(
std
:
:
memory_order_acquire
)
;
#
endif
}
return
result
;
}
void
operator
=
(
const
T
&
aValue
)
{
AutoRecordAtomicAccess
<
Recording
>
record
(
this
)
;
mValue
.
store
(
aValue
std
:
:
memory_order_seq_cst
)
;
}
operator
T
(
)
const
{
AutoRecordAtomicAccess
<
Recording
>
record
(
this
)
;
return
mValue
.
load
(
std
:
:
memory_order_acquire
)
;
}
private
:
std
:
:
atomic
<
T
>
mValue
;
}
;
template
<
typename
T
RefCountAtomicity
Atomicity
recordreplay
:
:
Behavior
Recording
=
recordreplay
:
:
Behavior
:
:
Preserve
>
class
RefCounted
{
protected
:
RefCounted
(
)
:
mRefCnt
(
0
)
{
}
~
RefCounted
(
)
{
MOZ_ASSERT
(
mRefCnt
=
=
detail
:
:
DEAD
)
;
}
public
:
void
AddRef
(
)
const
{
MOZ_ASSERT
(
int32_t
(
mRefCnt
)
>
=
0
)
;
#
ifndef
MOZ_REFCOUNTED_LEAK_CHECKING
+
+
mRefCnt
;
#
else
const
char
*
type
=
static_cast
<
const
T
*
>
(
this
)
-
>
typeName
(
)
;
uint32_t
size
=
static_cast
<
const
T
*
>
(
this
)
-
>
typeSize
(
)
;
const
void
*
ptr
=
static_cast
<
const
T
*
>
(
this
)
;
MozRefCountType
cnt
=
+
+
mRefCnt
;
detail
:
:
RefCountLogger
:
:
logAddRef
(
ptr
cnt
type
size
)
;
#
endif
}
void
Release
(
)
const
{
MOZ_ASSERT
(
int32_t
(
mRefCnt
)
>
0
)
;
#
ifndef
MOZ_REFCOUNTED_LEAK_CHECKING
MozRefCountType
cnt
=
-
-
mRefCnt
;
#
else
const
char
*
type
=
static_cast
<
const
T
*
>
(
this
)
-
>
typeName
(
)
;
const
void
*
ptr
=
static_cast
<
const
T
*
>
(
this
)
;
MozRefCountType
cnt
=
-
-
mRefCnt
;
detail
:
:
RefCountLogger
:
:
logRelease
(
ptr
cnt
type
)
;
#
endif
if
(
0
=
=
cnt
)
{
#
ifdef
DEBUG
mRefCnt
=
detail
:
:
DEAD
;
#
endif
delete
static_cast
<
const
T
*
>
(
this
)
;
}
}
void
ref
(
)
{
AddRef
(
)
;
}
void
deref
(
)
{
Release
(
)
;
}
MozRefCountType
refCount
(
)
const
{
return
mRefCnt
;
}
bool
hasOneRef
(
)
const
{
MOZ_ASSERT
(
mRefCnt
>
0
)
;
return
mRefCnt
=
=
1
;
}
private
:
mutable
RC
<
MozRefCountType
Atomicity
Recording
>
mRefCnt
;
}
;
#
ifdef
MOZ_REFCOUNTED_LEAK_CHECKING
#
define
MOZ_DECLARE_REFCOUNTED_VIRTUAL_TYPENAME
(
T
.
.
.
)
\
virtual
const
char
*
typeName
(
)
const
__VA_ARGS__
{
return
#
T
;
}
\
virtual
size_t
typeSize
(
)
const
__VA_ARGS__
{
return
sizeof
(
*
this
)
;
}
#
else
#
define
MOZ_DECLARE_REFCOUNTED_VIRTUAL_TYPENAME
(
T
.
.
.
)
#
endif
#
define
MOZ_DECLARE_REFCOUNTED_TYPENAME
(
T
)
\
const
char
*
typeName
(
)
const
{
return
#
T
;
}
\
size_t
typeSize
(
)
const
{
return
sizeof
(
*
this
)
;
}
}
template
<
typename
T
>
class
RefCounted
:
public
detail
:
:
RefCounted
<
T
detail
:
:
NonAtomicRefCount
>
{
public
:
~
RefCounted
(
)
{
static_assert
(
std
:
:
is_base_of
<
RefCounted
T
>
:
:
value
"
T
must
derive
from
RefCounted
<
T
>
"
)
;
}
}
;
namespace
external
{
template
<
typename
T
recordreplay
:
:
Behavior
Recording
=
recordreplay
:
:
Behavior
:
:
Preserve
>
class
AtomicRefCounted
:
public
mozilla
:
:
detail
:
:
RefCounted
<
T
mozilla
:
:
detail
:
:
AtomicRefCount
Recording
>
{
public
:
~
AtomicRefCounted
(
)
{
static_assert
(
std
:
:
is_base_of
<
AtomicRefCounted
T
>
:
:
value
"
T
must
derive
from
AtomicRefCounted
<
T
>
"
)
;
}
}
;
}
}
#
endif
