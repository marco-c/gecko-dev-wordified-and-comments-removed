#
ifndef
mozilla_RefCounted_h
#
define
mozilla_RefCounted_h
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
RefCountType
.
h
"
#
include
"
mozilla
/
TypeTraits
.
h
"
#
if
defined
(
MOZILLA_INTERNAL_API
)
#
include
"
nsXPCOM
.
h
"
#
endif
#
if
defined
(
MOZILLA_INTERNAL_API
)
&
&
\
!
defined
(
MOZILLA_XPCOMRT_API
)
&
&
\
(
defined
(
DEBUG
)
|
|
defined
(
FORCE_BUILD_REFCNT_LOGGING
)
)
#
define
MOZ_REFCOUNTED_LEAK_CHECKING
#
endif
namespace
mozilla
{
template
<
typename
T
>
class
RefPtr
;
namespace
detail
{
const
MozRefCountType
DEAD
=
0xffffdead
;
#
ifdef
MOZ_REFCOUNTED_LEAK_CHECKING
class
RefCountLogger
{
public
:
static
void
logAddRef
(
const
void
*
aPointer
MozRefCountType
aRefCount
const
char
*
aTypeName
uint32_t
aInstanceSize
)
{
MOZ_ASSERT
(
aRefCount
!
=
DEAD
)
;
NS_LogAddRef
(
const_cast
<
void
*
>
(
aPointer
)
aRefCount
aTypeName
aInstanceSize
)
;
}
static
void
logRelease
(
const
void
*
aPointer
MozRefCountType
aRefCount
const
char
*
aTypeName
)
{
MOZ_ASSERT
(
aRefCount
!
=
DEAD
)
;
NS_LogRelease
(
const_cast
<
void
*
>
(
aPointer
)
aRefCount
aTypeName
)
;
}
}
;
#
endif
enum
RefCountAtomicity
{
AtomicRefCount
NonAtomicRefCount
}
;
template
<
typename
T
RefCountAtomicity
Atomicity
>
class
RefCounted
{
friend
class
RefPtr
<
T
>
;
protected
:
RefCounted
(
)
:
mRefCnt
(
0
)
{
}
~
RefCounted
(
)
{
MOZ_ASSERT
(
mRefCnt
=
=
detail
:
:
DEAD
)
;
}
public
:
void
AddRef
(
)
const
{
MOZ_ASSERT
(
int32_t
(
mRefCnt
)
>
=
0
)
;
#
ifndef
MOZ_REFCOUNTED_LEAK_CHECKING
+
+
mRefCnt
;
#
else
const
char
*
type
=
static_cast
<
const
T
*
>
(
this
)
-
>
typeName
(
)
;
uint32_t
size
=
static_cast
<
const
T
*
>
(
this
)
-
>
typeSize
(
)
;
const
void
*
ptr
=
static_cast
<
const
T
*
>
(
this
)
;
MozRefCountType
cnt
=
+
+
mRefCnt
;
detail
:
:
RefCountLogger
:
:
logAddRef
(
ptr
cnt
type
size
)
;
#
endif
}
void
Release
(
)
const
{
MOZ_ASSERT
(
int32_t
(
mRefCnt
)
>
0
)
;
#
ifndef
MOZ_REFCOUNTED_LEAK_CHECKING
MozRefCountType
cnt
=
-
-
mRefCnt
;
#
else
const
char
*
type
=
static_cast
<
const
T
*
>
(
this
)
-
>
typeName
(
)
;
const
void
*
ptr
=
static_cast
<
const
T
*
>
(
this
)
;
MozRefCountType
cnt
=
-
-
mRefCnt
;
detail
:
:
RefCountLogger
:
:
logRelease
(
ptr
cnt
type
)
;
#
endif
if
(
0
=
=
cnt
)
{
#
ifdef
DEBUG
mRefCnt
=
detail
:
:
DEAD
;
#
endif
delete
static_cast
<
const
T
*
>
(
this
)
;
}
}
void
ref
(
)
{
AddRef
(
)
;
}
void
deref
(
)
{
Release
(
)
;
}
MozRefCountType
refCount
(
)
const
{
return
mRefCnt
;
}
bool
hasOneRef
(
)
const
{
MOZ_ASSERT
(
mRefCnt
>
0
)
;
return
mRefCnt
=
=
1
;
}
private
:
mutable
typename
Conditional
<
Atomicity
=
=
AtomicRefCount
Atomic
<
MozRefCountType
>
MozRefCountType
>
:
:
Type
mRefCnt
;
}
;
#
ifdef
MOZ_REFCOUNTED_LEAK_CHECKING
#
define
MOZ_DECLARE_REFCOUNTED_VIRTUAL_TYPENAME
(
T
.
.
.
)
\
virtual
const
char
*
typeName
(
)
const
__VA_ARGS__
{
return
#
T
;
}
\
virtual
size_t
typeSize
(
)
const
__VA_ARGS__
{
return
sizeof
(
*
this
)
;
}
#
else
#
define
MOZ_DECLARE_REFCOUNTED_VIRTUAL_TYPENAME
(
T
.
.
.
)
#
endif
#
define
MOZ_DECLARE_REFCOUNTED_TYPENAME
(
T
)
\
const
char
*
typeName
(
)
const
{
return
#
T
;
}
\
size_t
typeSize
(
)
const
{
return
sizeof
(
*
this
)
;
}
}
template
<
typename
T
>
class
RefCounted
:
public
detail
:
:
RefCounted
<
T
detail
:
:
NonAtomicRefCount
>
{
public
:
~
RefCounted
(
)
{
static_assert
(
IsBaseOf
<
RefCounted
T
>
:
:
value
"
T
must
derive
from
RefCounted
<
T
>
"
)
;
}
}
;
namespace
external
{
template
<
typename
T
>
class
AtomicRefCounted
:
public
mozilla
:
:
detail
:
:
RefCounted
<
T
mozilla
:
:
detail
:
:
AtomicRefCount
>
{
public
:
~
AtomicRefCounted
(
)
{
static_assert
(
IsBaseOf
<
AtomicRefCounted
T
>
:
:
value
"
T
must
derive
from
AtomicRefCounted
<
T
>
"
)
;
}
}
;
}
}
#
endif
