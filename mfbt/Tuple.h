#
ifndef
mozilla_Tuple_h
#
define
mozilla_Tuple_h
#
include
<
stddef
.
h
>
#
include
<
utility
>
#
include
"
mozilla
/
Pair
.
h
"
#
include
"
mozilla
/
TemplateLib
.
h
"
#
include
"
mozilla
/
TypeTraits
.
h
"
namespace
mozilla
{
namespace
detail
{
template
<
typename
.
.
.
Ts
>
struct
Group
;
template
<
typename
Source
typename
Target
bool
SameSize
>
struct
CheckConvertibilityImpl
;
template
<
typename
Source
typename
Target
>
struct
CheckConvertibilityImpl
<
Source
Target
false
>
:
FalseType
{
}
;
template
<
typename
.
.
.
SourceTypes
typename
.
.
.
TargetTypes
>
struct
CheckConvertibilityImpl
<
Group
<
SourceTypes
.
.
.
>
Group
<
TargetTypes
.
.
.
>
true
>
:
IntegralConstant
<
bool
tl
:
:
And
<
IsConvertible
<
SourceTypes
TargetTypes
>
:
:
value
.
.
.
>
:
:
value
>
{
}
;
template
<
typename
Source
typename
Target
>
struct
CheckConvertibility
;
template
<
typename
.
.
.
SourceTypes
typename
.
.
.
TargetTypes
>
struct
CheckConvertibility
<
Group
<
SourceTypes
.
.
.
>
Group
<
TargetTypes
.
.
.
>
>
:
CheckConvertibilityImpl
<
Group
<
SourceTypes
.
.
.
>
Group
<
TargetTypes
.
.
.
>
sizeof
.
.
.
(
SourceTypes
)
=
=
sizeof
.
.
.
(
TargetTypes
)
>
{
}
;
template
<
std
:
:
size_t
Index
typename
.
.
.
Elements
>
struct
TupleImpl
;
template
<
std
:
:
size_t
Index
>
struct
TupleImpl
<
Index
>
{
bool
operator
=
=
(
const
TupleImpl
<
Index
>
&
aOther
)
const
{
return
true
;
}
template
<
typename
F
>
void
ForEach
(
const
F
&
aFunc
)
{
}
}
;
template
<
std
:
:
size_t
Index
typename
HeadT
typename
.
.
.
TailT
>
struct
TupleImpl
<
Index
HeadT
TailT
.
.
.
>
:
public
TupleImpl
<
Index
+
1
TailT
.
.
.
>
{
typedef
TupleImpl
<
Index
+
1
TailT
.
.
.
>
Base
;
static
HeadT
&
Head
(
TupleImpl
&
aTuple
)
{
return
aTuple
.
mHead
;
}
static
const
HeadT
&
Head
(
const
TupleImpl
&
aTuple
)
{
return
aTuple
.
mHead
;
}
static
Base
&
Tail
(
TupleImpl
&
aTuple
)
{
return
aTuple
;
}
static
const
Base
&
Tail
(
const
TupleImpl
&
aTuple
)
{
return
aTuple
;
}
TupleImpl
(
)
:
Base
(
)
mHead
(
)
{
}
explicit
TupleImpl
(
const
HeadT
&
aHead
const
TailT
&
.
.
.
aTail
)
:
Base
(
aTail
.
.
.
)
mHead
(
aHead
)
{
}
template
<
typename
OtherHeadT
typename
.
.
.
OtherTailT
typename
=
typename
EnableIf
<
CheckConvertibility
<
Group
<
OtherHeadT
OtherTailT
.
.
.
>
Group
<
HeadT
TailT
.
.
.
>
>
:
:
value
>
:
:
Type
>
explicit
TupleImpl
(
OtherHeadT
&
&
aHead
OtherTailT
&
&
.
.
.
aTail
)
:
Base
(
std
:
:
forward
<
OtherTailT
>
(
aTail
)
.
.
.
)
mHead
(
std
:
:
forward
<
OtherHeadT
>
(
aHead
)
)
{
}
TupleImpl
(
const
TupleImpl
&
aOther
)
:
Base
(
Tail
(
aOther
)
)
mHead
(
Head
(
aOther
)
)
{
}
TupleImpl
(
TupleImpl
&
&
aOther
)
:
Base
(
std
:
:
move
(
Tail
(
aOther
)
)
)
mHead
(
std
:
:
forward
<
HeadT
>
(
Head
(
aOther
)
)
)
{
}
template
<
typename
.
.
.
OtherElements
typename
=
typename
EnableIf
<
sizeof
.
.
.
(
OtherElements
)
=
=
sizeof
.
.
.
(
TailT
)
+
1
>
:
:
Type
>
TupleImpl
&
operator
=
(
const
TupleImpl
<
Index
OtherElements
.
.
.
>
&
aOther
)
{
typedef
TupleImpl
<
Index
OtherElements
.
.
.
>
OtherT
;
Head
(
*
this
)
=
OtherT
:
:
Head
(
aOther
)
;
Tail
(
*
this
)
=
OtherT
:
:
Tail
(
aOther
)
;
return
*
this
;
}
template
<
typename
.
.
.
OtherElements
typename
=
typename
EnableIf
<
sizeof
.
.
.
(
OtherElements
)
=
=
sizeof
.
.
.
(
TailT
)
+
1
>
:
:
Type
>
TupleImpl
&
operator
=
(
TupleImpl
<
Index
OtherElements
.
.
.
>
&
&
aOther
)
{
typedef
TupleImpl
<
Index
OtherElements
.
.
.
>
OtherT
;
Head
(
*
this
)
=
std
:
:
move
(
OtherT
:
:
Head
(
aOther
)
)
;
Tail
(
*
this
)
=
std
:
:
move
(
OtherT
:
:
Tail
(
aOther
)
)
;
return
*
this
;
}
TupleImpl
&
operator
=
(
const
TupleImpl
&
aOther
)
{
Head
(
*
this
)
=
Head
(
aOther
)
;
Tail
(
*
this
)
=
Tail
(
aOther
)
;
return
*
this
;
}
TupleImpl
&
operator
=
(
TupleImpl
&
&
aOther
)
{
Head
(
*
this
)
=
std
:
:
move
(
Head
(
aOther
)
)
;
Tail
(
*
this
)
=
std
:
:
move
(
Tail
(
aOther
)
)
;
return
*
this
;
}
bool
operator
=
=
(
const
TupleImpl
&
aOther
)
const
{
return
Head
(
*
this
)
=
=
Head
(
aOther
)
&
&
Tail
(
*
this
)
=
=
Tail
(
aOther
)
;
}
template
<
typename
F
>
void
ForEach
(
const
F
&
aFunc
)
const
&
{
aFunc
(
Head
(
*
this
)
)
;
Tail
(
*
this
)
.
ForEach
(
aFunc
)
;
}
template
<
typename
F
>
void
ForEach
(
const
F
&
aFunc
)
&
{
aFunc
(
Head
(
*
this
)
)
;
Tail
(
*
this
)
.
ForEach
(
aFunc
)
;
}
template
<
typename
F
>
void
ForEach
(
const
F
&
aFunc
)
&
&
{
aFunc
(
std
:
:
move
(
Head
(
*
this
)
)
)
;
std
:
:
move
(
Tail
(
*
this
)
)
.
ForEach
(
aFunc
)
;
}
private
:
HeadT
mHead
;
}
;
}
template
<
typename
.
.
.
Elements
>
class
Tuple
:
public
detail
:
:
TupleImpl
<
0
Elements
.
.
.
>
{
typedef
detail
:
:
TupleImpl
<
0
Elements
.
.
.
>
Impl
;
public
:
Tuple
(
)
:
Impl
(
)
{
}
explicit
Tuple
(
const
Elements
&
.
.
.
aElements
)
:
Impl
(
aElements
.
.
.
)
{
}
template
<
typename
OtherHead
typename
.
.
.
OtherTail
typename
=
typename
EnableIf
<
detail
:
:
CheckConvertibility
<
detail
:
:
Group
<
OtherHead
OtherTail
.
.
.
>
detail
:
:
Group
<
Elements
.
.
.
>
>
:
:
value
>
:
:
Type
>
explicit
Tuple
(
OtherHead
&
&
aHead
OtherTail
&
&
.
.
.
aTail
)
:
Impl
(
std
:
:
forward
<
OtherHead
>
(
aHead
)
std
:
:
forward
<
OtherTail
>
(
aTail
)
.
.
.
)
{
}
Tuple
(
const
Tuple
&
aOther
)
:
Impl
(
aOther
)
{
}
Tuple
(
Tuple
&
&
aOther
)
:
Impl
(
std
:
:
move
(
aOther
)
)
{
}
template
<
typename
.
.
.
OtherElements
typename
=
typename
EnableIf
<
sizeof
.
.
.
(
OtherElements
)
=
=
sizeof
.
.
.
(
Elements
)
>
:
:
Type
>
Tuple
&
operator
=
(
const
Tuple
<
OtherElements
.
.
.
>
&
aOther
)
{
static_cast
<
Impl
&
>
(
*
this
)
=
aOther
;
return
*
this
;
}
template
<
typename
.
.
.
OtherElements
typename
=
typename
EnableIf
<
sizeof
.
.
.
(
OtherElements
)
=
=
sizeof
.
.
.
(
Elements
)
>
:
:
Type
>
Tuple
&
operator
=
(
Tuple
<
OtherElements
.
.
.
>
&
&
aOther
)
{
static_cast
<
Impl
&
>
(
*
this
)
=
std
:
:
move
(
aOther
)
;
return
*
this
;
}
Tuple
&
operator
=
(
const
Tuple
&
aOther
)
{
static_cast
<
Impl
&
>
(
*
this
)
=
aOther
;
return
*
this
;
}
Tuple
&
operator
=
(
Tuple
&
&
aOther
)
{
static_cast
<
Impl
&
>
(
*
this
)
=
std
:
:
move
(
aOther
)
;
return
*
this
;
}
bool
operator
=
=
(
const
Tuple
&
aOther
)
const
{
return
static_cast
<
const
Impl
&
>
(
*
this
)
=
=
static_cast
<
const
Impl
&
>
(
aOther
)
;
}
}
;
template
<
typename
A
typename
B
>
class
Tuple
<
A
B
>
:
public
detail
:
:
TupleImpl
<
0
A
B
>
{
typedef
detail
:
:
TupleImpl
<
0
A
B
>
Impl
;
public
:
Tuple
(
)
:
Impl
(
)
{
}
explicit
Tuple
(
const
A
&
aA
const
B
&
aB
)
:
Impl
(
aA
aB
)
{
}
template
<
typename
AArg
typename
BArg
typename
=
typename
EnableIf
<
detail
:
:
CheckConvertibility
<
detail
:
:
Group
<
AArg
BArg
>
detail
:
:
Group
<
A
B
>
>
:
:
value
>
:
:
Type
>
explicit
Tuple
(
AArg
&
&
aA
BArg
&
&
aB
)
:
Impl
(
std
:
:
forward
<
AArg
>
(
aA
)
std
:
:
forward
<
BArg
>
(
aB
)
)
{
}
Tuple
(
const
Tuple
&
aOther
)
:
Impl
(
aOther
)
{
}
Tuple
(
Tuple
&
&
aOther
)
:
Impl
(
std
:
:
move
(
aOther
)
)
{
}
explicit
Tuple
(
const
Pair
<
A
B
>
&
aOther
)
:
Impl
(
aOther
.
first
(
)
aOther
.
second
(
)
)
{
}
explicit
Tuple
(
Pair
<
A
B
>
&
&
aOther
)
:
Impl
(
std
:
:
forward
<
A
>
(
aOther
.
first
(
)
)
std
:
:
forward
<
B
>
(
aOther
.
second
(
)
)
)
{
}
explicit
Tuple
(
const
std
:
:
pair
<
A
B
>
&
aOther
)
:
Impl
(
aOther
.
first
aOther
.
second
)
{
}
explicit
Tuple
(
std
:
:
pair
<
A
B
>
&
&
aOther
)
:
Impl
(
std
:
:
forward
<
A
>
(
aOther
.
first
)
std
:
:
forward
<
B
>
(
aOther
.
second
)
)
{
}
template
<
typename
AArg
typename
BArg
>
Tuple
&
operator
=
(
const
Tuple
<
AArg
BArg
>
&
aOther
)
{
static_cast
<
Impl
&
>
(
*
this
)
=
aOther
;
return
*
this
;
}
template
<
typename
AArg
typename
BArg
>
Tuple
&
operator
=
(
Tuple
<
AArg
BArg
>
&
&
aOther
)
{
static_cast
<
Impl
&
>
(
*
this
)
=
std
:
:
move
(
aOther
)
;
return
*
this
;
}
Tuple
&
operator
=
(
const
Tuple
&
aOther
)
{
static_cast
<
Impl
&
>
(
*
this
)
=
aOther
;
return
*
this
;
}
Tuple
&
operator
=
(
Tuple
&
&
aOther
)
{
static_cast
<
Impl
&
>
(
*
this
)
=
std
:
:
move
(
aOther
)
;
return
*
this
;
}
template
<
typename
AArg
typename
BArg
>
Tuple
&
operator
=
(
const
Pair
<
AArg
BArg
>
&
aOther
)
{
Impl
:
:
Head
(
*
this
)
=
aOther
.
first
(
)
;
Impl
:
:
Tail
(
*
this
)
.
Head
(
*
this
)
=
aOther
.
second
(
)
;
return
*
this
;
}
template
<
typename
AArg
typename
BArg
>
Tuple
&
operator
=
(
Pair
<
AArg
BArg
>
&
&
aOther
)
{
Impl
:
:
Head
(
*
this
)
=
std
:
:
forward
<
AArg
>
(
aOther
.
first
(
)
)
;
Impl
:
:
Tail
(
*
this
)
.
Head
(
*
this
)
=
std
:
:
forward
<
BArg
>
(
aOther
.
second
(
)
)
;
return
*
this
;
}
template
<
typename
AArg
typename
BArg
>
Tuple
&
operator
=
(
const
std
:
:
pair
<
AArg
BArg
>
&
aOther
)
{
Impl
:
:
Head
(
*
this
)
=
aOther
.
first
;
Impl
:
:
Tail
(
*
this
)
.
Head
(
*
this
)
=
aOther
.
second
;
return
*
this
;
}
template
<
typename
AArg
typename
BArg
>
Tuple
&
operator
=
(
std
:
:
pair
<
AArg
BArg
>
&
&
aOther
)
{
Impl
:
:
Head
(
*
this
)
=
std
:
:
forward
<
AArg
>
(
aOther
.
first
)
;
Impl
:
:
Tail
(
*
this
)
.
Head
(
*
this
)
=
std
:
:
forward
<
BArg
>
(
aOther
.
second
)
;
return
*
this
;
}
}
;
template
<
>
class
Tuple
<
>
{
}
;
namespace
detail
{
template
<
std
:
:
size_t
Index
typename
.
.
.
Elements
>
auto
TupleGetHelper
(
TupleImpl
<
Index
Elements
.
.
.
>
&
aTuple
)
-
>
decltype
(
TupleImpl
<
Index
Elements
.
.
.
>
:
:
Head
(
aTuple
)
)
{
return
TupleImpl
<
Index
Elements
.
.
.
>
:
:
Head
(
aTuple
)
;
}
template
<
std
:
:
size_t
Index
typename
.
.
.
Elements
>
auto
TupleGetHelper
(
const
TupleImpl
<
Index
Elements
.
.
.
>
&
aTuple
)
-
>
decltype
(
TupleImpl
<
Index
Elements
.
.
.
>
:
:
Head
(
aTuple
)
)
{
return
TupleImpl
<
Index
Elements
.
.
.
>
:
:
Head
(
aTuple
)
;
}
}
template
<
std
:
:
size_t
Index
typename
.
.
.
Elements
>
auto
Get
(
Tuple
<
Elements
.
.
.
>
&
aTuple
)
-
>
decltype
(
detail
:
:
TupleGetHelper
<
Index
>
(
aTuple
)
)
{
return
detail
:
:
TupleGetHelper
<
Index
>
(
aTuple
)
;
}
template
<
std
:
:
size_t
Index
typename
.
.
.
Elements
>
auto
Get
(
const
Tuple
<
Elements
.
.
.
>
&
aTuple
)
-
>
decltype
(
detail
:
:
TupleGetHelper
<
Index
>
(
aTuple
)
)
{
return
detail
:
:
TupleGetHelper
<
Index
>
(
aTuple
)
;
}
template
<
std
:
:
size_t
Index
typename
.
.
.
Elements
>
auto
Get
(
Tuple
<
Elements
.
.
.
>
&
&
aTuple
)
-
>
decltype
(
std
:
:
move
(
mozilla
:
:
Get
<
Index
>
(
aTuple
)
)
)
{
return
std
:
:
move
(
mozilla
:
:
Get
<
Index
>
(
aTuple
)
)
;
}
template
<
typename
F
>
inline
void
ForEach
(
const
Tuple
<
>
&
aTuple
const
F
&
aFunc
)
{
}
template
<
typename
F
>
inline
void
ForEach
(
Tuple
<
>
&
aTuple
const
F
&
aFunc
)
{
}
template
<
typename
F
typename
.
.
.
Elements
>
void
ForEach
(
const
Tuple
<
Elements
.
.
.
>
&
aTuple
const
F
&
aFunc
)
{
aTuple
.
ForEach
(
aTuple
aFunc
)
;
}
template
<
typename
F
typename
.
.
.
Elements
>
void
ForEach
(
Tuple
<
Elements
.
.
.
>
&
aTuple
const
F
&
aFunc
)
{
aTuple
.
ForEach
(
aFunc
)
;
}
template
<
typename
F
typename
.
.
.
Elements
>
void
ForEach
(
Tuple
<
Elements
.
.
.
>
&
&
aTuple
const
F
&
aFunc
)
{
std
:
:
forward
<
Tuple
<
Elements
.
.
.
>
>
(
aTuple
)
.
ForEach
(
aFunc
)
;
}
template
<
typename
.
.
.
Elements
>
inline
Tuple
<
typename
Decay
<
Elements
>
:
:
Type
.
.
.
>
MakeTuple
(
Elements
&
&
.
.
.
aElements
)
{
return
Tuple
<
typename
Decay
<
Elements
>
:
:
Type
.
.
.
>
(
std
:
:
forward
<
Elements
>
(
aElements
)
.
.
.
)
;
}
template
<
typename
.
.
.
Elements
>
inline
Tuple
<
Elements
&
.
.
.
>
Tie
(
Elements
&
.
.
.
aVariables
)
{
return
Tuple
<
Elements
&
.
.
.
>
(
aVariables
.
.
.
)
;
}
}
#
endif
