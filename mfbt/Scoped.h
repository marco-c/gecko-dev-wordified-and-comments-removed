#
ifndef
mozilla_Scoped_h
#
define
mozilla_Scoped_h
#
include
<
utility
>
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
namespace
mozilla
{
template
<
typename
Traits
>
class
MOZ_NON_TEMPORARY_CLASS
Scoped
{
public
:
typedef
typename
Traits
:
:
type
Resource
;
explicit
Scoped
(
)
:
mValue
(
Traits
:
:
empty
(
)
)
{
}
explicit
Scoped
(
const
Resource
&
aValue
)
:
mValue
(
aValue
)
{
}
Scoped
(
Scoped
&
&
aOther
)
:
mValue
(
std
:
:
move
(
aOther
.
mValue
)
)
{
aOther
.
mValue
=
Traits
:
:
empty
(
)
;
}
~
Scoped
(
)
{
Traits
:
:
release
(
mValue
)
;
}
operator
const
Resource
&
(
)
const
{
return
mValue
;
}
const
Resource
&
operator
-
>
(
)
const
{
return
mValue
;
}
const
Resource
&
get
(
)
const
{
return
mValue
;
}
Resource
&
rwget
(
)
{
return
mValue
;
}
Resource
forget
(
)
{
Resource
tmp
=
mValue
;
mValue
=
Traits
:
:
empty
(
)
;
return
tmp
;
}
void
dispose
(
)
{
Traits
:
:
release
(
mValue
)
;
mValue
=
Traits
:
:
empty
(
)
;
}
bool
operator
=
=
(
const
Resource
&
aOther
)
const
{
return
mValue
=
=
aOther
;
}
Scoped
&
operator
=
(
const
Resource
&
aOther
)
{
return
reset
(
aOther
)
;
}
Scoped
&
reset
(
const
Resource
&
aOther
)
{
Traits
:
:
release
(
mValue
)
;
mValue
=
aOther
;
return
*
this
;
}
Scoped
&
operator
=
(
Scoped
&
&
aRhs
)
{
MOZ_ASSERT
(
&
aRhs
!
=
this
"
self
-
move
-
assignment
not
allowed
"
)
;
this
-
>
~
Scoped
(
)
;
new
(
this
)
Scoped
(
std
:
:
move
(
aRhs
)
)
;
return
*
this
;
}
private
:
explicit
Scoped
(
const
Scoped
&
aValue
)
=
delete
;
Scoped
&
operator
=
(
const
Scoped
&
aValue
)
=
delete
;
private
:
Resource
mValue
;
}
;
#
define
SCOPED_TEMPLATE
(
name
Traits
)
\
template
<
typename
Type
>
\
struct
MOZ_NON_TEMPORARY_CLASS
name
\
:
public
mozilla
:
:
Scoped
<
Traits
<
Type
>
>
{
\
typedef
mozilla
:
:
Scoped
<
Traits
<
Type
>
>
Super
;
\
typedef
typename
Super
:
:
Resource
Resource
;
\
name
&
operator
=
(
Resource
aRhs
)
{
\
Super
:
:
operator
=
(
aRhs
)
;
\
return
*
this
;
\
}
\
name
&
operator
=
(
name
&
&
aRhs
)
=
default
;
\
\
explicit
name
(
)
:
Super
(
)
{
}
\
explicit
name
(
Resource
aRhs
)
:
Super
(
aRhs
)
{
}
\
name
(
name
&
&
aRhs
)
:
Super
(
std
:
:
move
(
aRhs
)
)
{
}
\
\
private
:
\
explicit
name
(
const
name
&
)
=
delete
;
\
name
&
operator
=
(
const
name
&
)
=
delete
;
\
}
;
#
define
MOZ_TYPE_SPECIFIC_SCOPED_POINTER_TEMPLATE
(
name
Type
Deleter
)
\
template
<
>
\
inline
void
TypeSpecificDelete
(
Type
*
aValue
)
{
\
Deleter
(
aValue
)
;
\
}
\
typedef
:
:
mozilla
:
:
TypeSpecificScopedPointer
<
Type
>
name
;
template
<
typename
T
>
void
TypeSpecificDelete
(
T
*
aValue
)
;
template
<
typename
T
>
struct
TypeSpecificScopedPointerTraits
{
typedef
T
*
type
;
static
type
empty
(
)
{
return
nullptr
;
}
static
void
release
(
type
aValue
)
{
if
(
aValue
)
{
TypeSpecificDelete
(
aValue
)
;
}
}
}
;
SCOPED_TEMPLATE
(
TypeSpecificScopedPointer
TypeSpecificScopedPointerTraits
)
}
#
endif
