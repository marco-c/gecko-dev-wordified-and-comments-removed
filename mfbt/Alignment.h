#
ifndef
mozilla_Alignment_h
#
define
mozilla_Alignment_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
namespace
mozilla
{
template
<
typename
T
>
class
AlignmentFinder
{
struct
Aligner
{
char
mChar
;
T
mT
;
~
Aligner
(
)
=
delete
;
}
;
public
:
static
const
size_t
alignment
=
sizeof
(
Aligner
)
-
sizeof
(
T
)
;
}
;
#
define
MOZ_ALIGNOF
(
T
)
mozilla
:
:
AlignmentFinder
<
T
>
:
:
alignment
namespace
detail
{
template
<
typename
T
>
struct
AlignasHelper
{
T
mT
;
}
;
}
#
define
MOZ_ALIGNAS_IN_STRUCT
(
T
)
alignas
(
mozilla
:
:
detail
:
:
AlignasHelper
<
T
>
)
#
if
defined
(
__GNUC__
)
#
define
MOZ_ALIGNED_DECL
(
_align
_type
)
_type
__attribute__
(
(
aligned
(
_align
)
)
)
#
elif
defined
(
_MSC_VER
)
#
define
MOZ_ALIGNED_DECL
(
_align
_type
)
__declspec
(
align
(
_align
)
)
_type
#
else
#
warning
"
We
don
'
t
know
how
to
align
variables
on
this
compiler
.
"
#
define
MOZ_ALIGNED_DECL
(
_align
_type
)
_type
#
endif
template
<
size_t
Align
>
struct
AlignedElem
;
template
<
>
struct
AlignedElem
<
1
>
{
MOZ_ALIGNED_DECL
(
1
uint8_t
elem
)
;
}
;
template
<
>
struct
AlignedElem
<
2
>
{
MOZ_ALIGNED_DECL
(
2
uint8_t
elem
)
;
}
;
template
<
>
struct
AlignedElem
<
4
>
{
MOZ_ALIGNED_DECL
(
4
uint8_t
elem
)
;
}
;
template
<
>
struct
AlignedElem
<
8
>
{
MOZ_ALIGNED_DECL
(
8
uint8_t
elem
)
;
}
;
template
<
>
struct
AlignedElem
<
16
>
{
MOZ_ALIGNED_DECL
(
16
uint8_t
elem
)
;
}
;
template
<
typename
T
>
struct
MOZ_INHERIT_TYPE_ANNOTATIONS_FROM_TEMPLATE_ARGS
AlignedStorage2
{
union
U
{
char
mBytes
[
sizeof
(
T
)
]
;
uint64_t
mDummy
;
}
u
;
const
T
*
addr
(
)
const
{
return
reinterpret_cast
<
const
T
*
>
(
u
.
mBytes
)
;
}
T
*
addr
(
)
{
return
static_cast
<
T
*
>
(
static_cast
<
void
*
>
(
u
.
mBytes
)
)
;
}
AlignedStorage2
(
)
=
default
;
AlignedStorage2
(
const
AlignedStorage2
&
)
=
delete
;
void
operator
=
(
const
AlignedStorage2
&
)
=
delete
;
}
;
}
#
endif
