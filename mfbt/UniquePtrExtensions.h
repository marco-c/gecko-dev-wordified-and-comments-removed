#
ifndef
mozilla_UniquePtrExtensions_h
#
define
mozilla_UniquePtrExtensions_h
#
include
<
type_traits
>
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
fallible
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
ifdef
XP_WIN
#
include
<
cstdint
>
#
endif
#
if
defined
(
XP_DARWIN
)
&
&
!
defined
(
RUST_BINDGEN
)
#
include
<
mach
/
mach
.
h
>
#
endif
namespace
mozilla
{
template
<
typename
T
typename
.
.
.
Args
>
typename
detail
:
:
UniqueSelector
<
T
>
:
:
SingleObject
MakeUniqueFallible
(
Args
&
&
.
.
.
aArgs
)
{
return
UniquePtr
<
T
>
(
new
(
fallible
)
T
(
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
)
;
}
template
<
typename
T
>
typename
detail
:
:
UniqueSelector
<
T
>
:
:
UnknownBound
MakeUniqueFallible
(
decltype
(
sizeof
(
int
)
)
aN
)
{
using
ArrayType
=
std
:
:
remove_extent_t
<
T
>
;
return
UniquePtr
<
T
>
(
new
(
fallible
)
ArrayType
[
aN
]
(
)
)
;
}
template
<
typename
T
typename
.
.
.
Args
>
typename
detail
:
:
UniqueSelector
<
T
>
:
:
KnownBound
MakeUniqueFallible
(
Args
&
&
.
.
.
aArgs
)
=
delete
;
template
<
typename
T
typename
.
.
.
Args
>
typename
detail
:
:
UniqueSelector
<
T
>
:
:
SingleObject
MakeUniqueForOverwrite
(
)
{
return
UniquePtr
<
T
>
(
new
T
)
;
}
template
<
typename
T
>
typename
detail
:
:
UniqueSelector
<
T
>
:
:
UnknownBound
MakeUniqueForOverwrite
(
decltype
(
sizeof
(
int
)
)
aN
)
{
using
ArrayType
=
std
:
:
remove_extent_t
<
T
>
;
return
UniquePtr
<
T
>
(
new
ArrayType
[
aN
]
)
;
}
template
<
typename
T
typename
.
.
.
Args
>
typename
detail
:
:
UniqueSelector
<
T
>
:
:
KnownBound
MakeUniqueForOverwrite
(
Args
&
&
.
.
.
aArgs
)
=
delete
;
template
<
typename
T
typename
.
.
.
Args
>
typename
detail
:
:
UniqueSelector
<
T
>
:
:
SingleObject
MakeUniqueForOverwriteFallible
(
)
{
return
UniquePtr
<
T
>
(
new
(
fallible
)
T
)
;
}
template
<
typename
T
>
typename
detail
:
:
UniqueSelector
<
T
>
:
:
UnknownBound
MakeUniqueForOverwriteFallible
(
decltype
(
sizeof
(
int
)
)
aN
)
{
using
ArrayType
=
std
:
:
remove_extent_t
<
T
>
;
return
UniquePtr
<
T
>
(
new
(
fallible
)
ArrayType
[
aN
]
)
;
}
template
<
typename
T
typename
.
.
.
Args
>
typename
detail
:
:
UniqueSelector
<
T
>
:
:
KnownBound
MakeUniqueForOverwriteFallible
(
Args
&
&
.
.
.
aArgs
)
=
delete
;
namespace
detail
{
template
<
typename
T
>
struct
FreePolicy
{
void
operator
(
)
(
const
void
*
ptr
)
{
free
(
const_cast
<
void
*
>
(
ptr
)
)
;
}
}
;
#
if
defined
(
XP_WIN
)
typedef
void
*
FileHandleType
;
#
elif
defined
(
XP_UNIX
)
typedef
int
FileHandleType
;
#
else
#
error
"
Unsupported
OS
?
"
#
endif
struct
FileHandleHelper
{
MOZ_IMPLICIT
FileHandleHelper
(
FileHandleType
aHandle
)
:
mHandle
(
aHandle
)
{
#
if
defined
(
XP_UNIX
)
&
&
(
defined
(
DEBUG
)
|
|
defined
(
FUZZING
)
)
MOZ_RELEASE_ASSERT
(
aHandle
=
=
kInvalidHandle
|
|
aHandle
>
2
)
;
#
endif
}
MOZ_IMPLICIT
constexpr
FileHandleHelper
(
std
:
:
nullptr_t
)
:
mHandle
(
kInvalidHandle
)
{
}
bool
operator
!
=
(
std
:
:
nullptr_t
)
const
{
#
ifdef
XP_WIN
if
(
mHandle
=
=
(
void
*
)
-
1
)
{
return
false
;
}
#
endif
return
mHandle
!
=
kInvalidHandle
;
}
operator
FileHandleType
(
)
const
{
return
mHandle
;
}
#
ifdef
XP_WIN
operator
std
:
:
intptr_t
(
)
const
{
return
reinterpret_cast
<
std
:
:
intptr_t
>
(
mHandle
)
;
}
#
endif
bool
operator
=
=
(
const
FileHandleHelper
&
aOther
)
const
{
return
mHandle
=
=
aOther
.
mHandle
;
}
private
:
FileHandleType
mHandle
;
#
ifdef
XP_WIN
static
constexpr
FileHandleType
kInvalidHandle
=
nullptr
;
#
else
static
constexpr
FileHandleType
kInvalidHandle
=
-
1
;
#
endif
}
;
struct
FileHandleDeleter
{
using
pointer
=
FileHandleHelper
;
using
receiver
=
FileHandleType
;
MFBT_API
void
operator
(
)
(
FileHandleHelper
aHelper
)
;
}
;
#
if
defined
(
XP_DARWIN
)
&
&
!
defined
(
RUST_BINDGEN
)
struct
MachPortHelper
{
MOZ_IMPLICIT
MachPortHelper
(
mach_port_t
aPort
)
:
mPort
(
aPort
)
{
}
MOZ_IMPLICIT
constexpr
MachPortHelper
(
std
:
:
nullptr_t
)
:
mPort
(
MACH_PORT_NULL
)
{
}
bool
operator
!
=
(
std
:
:
nullptr_t
)
const
{
return
mPort
!
=
MACH_PORT_NULL
;
}
operator
const
mach_port_t
&
(
)
const
{
return
mPort
;
}
operator
mach_port_t
&
(
)
{
return
mPort
;
}
private
:
mach_port_t
mPort
;
}
;
struct
MachSendRightDeleter
{
using
pointer
=
MachPortHelper
;
using
receiver
=
mach_port_t
;
MFBT_API
void
operator
(
)
(
MachPortHelper
aHelper
)
{
DebugOnly
<
kern_return_t
>
kr
=
mach_port_deallocate
(
mach_task_self
(
)
aHelper
)
;
MOZ_ASSERT
(
kr
=
=
KERN_SUCCESS
"
failed
to
deallocate
mach
send
right
"
)
;
}
}
;
struct
MachReceiveRightDeleter
{
using
pointer
=
MachPortHelper
;
using
receiver
=
mach_port_t
;
MFBT_API
void
operator
(
)
(
MachPortHelper
aHelper
)
{
DebugOnly
<
kern_return_t
>
kr
=
mach_port_mod_refs
(
mach_task_self
(
)
aHelper
MACH_PORT_RIGHT_RECEIVE
-
1
)
;
MOZ_ASSERT
(
kr
=
=
KERN_SUCCESS
"
failed
to
release
mach
receive
right
"
)
;
}
}
;
struct
MachPortSetDeleter
{
using
pointer
=
MachPortHelper
;
using
receiver
=
mach_port_t
;
MFBT_API
void
operator
(
)
(
MachPortHelper
aHelper
)
{
DebugOnly
<
kern_return_t
>
kr
=
mach_port_mod_refs
(
mach_task_self
(
)
aHelper
MACH_PORT_RIGHT_PORT_SET
-
1
)
;
MOZ_ASSERT
(
kr
=
=
KERN_SUCCESS
"
failed
to
release
mach
port
set
"
)
;
}
}
;
#
endif
}
template
<
typename
T
>
using
UniqueFreePtr
=
UniquePtr
<
T
detail
:
:
FreePolicy
<
T
>
>
;
using
UniqueFileHandle
=
UniquePtr
<
detail
:
:
FileHandleType
detail
:
:
FileHandleDeleter
>
;
#
ifndef
__wasm__
MFBT_API
UniqueFileHandle
DuplicateFileHandle
(
detail
:
:
FileHandleType
aFile
)
;
inline
UniqueFileHandle
DuplicateFileHandle
(
const
UniqueFileHandle
&
aFile
)
{
return
DuplicateFileHandle
(
aFile
.
get
(
)
)
;
}
#
endif
#
if
defined
(
XP_DARWIN
)
&
&
!
defined
(
RUST_BINDGEN
)
using
UniqueMachSendRight
=
UniquePtr
<
mach_port_t
detail
:
:
MachSendRightDeleter
>
;
using
UniqueMachReceiveRight
=
UniquePtr
<
mach_port_t
detail
:
:
MachReceiveRightDeleter
>
;
using
UniqueMachPortSet
=
UniquePtr
<
mach_port_t
detail
:
:
MachPortSetDeleter
>
;
inline
UniqueMachSendRight
RetainMachSendRight
(
mach_port_t
aPort
)
{
kern_return_t
kr
=
mach_port_mod_refs
(
mach_task_self
(
)
aPort
MACH_PORT_RIGHT_SEND
1
)
;
if
(
kr
=
=
KERN_SUCCESS
)
{
return
UniqueMachSendRight
(
aPort
)
;
}
return
nullptr
;
}
#
endif
namespace
detail
{
struct
HasReceiverTypeHelper
{
template
<
class
U
>
static
double
Test
(
.
.
.
)
;
template
<
class
U
>
static
char
Test
(
typename
U
:
:
receiver
*
=
0
)
;
}
;
template
<
class
T
>
class
HasReceiverType
:
public
std
:
:
integral_constant
<
bool
sizeof
(
HasReceiverTypeHelper
:
:
Test
<
T
>
(
0
)
)
=
=
1
>
{
}
;
template
<
class
T
class
D
bool
=
HasReceiverType
<
D
>
:
:
value
>
struct
ReceiverTypeImpl
{
using
Type
=
typename
D
:
:
receiver
;
}
;
template
<
class
T
class
D
>
struct
ReceiverTypeImpl
<
T
D
false
>
{
using
Type
=
typename
PointerType
<
T
D
>
:
:
Type
;
}
;
template
<
class
T
class
D
>
struct
ReceiverType
{
using
Type
=
typename
ReceiverTypeImpl
<
T
std
:
:
remove_reference_t
<
D
>
>
:
:
Type
;
}
;
template
<
typename
T
typename
D
>
class
MOZ_TEMPORARY_CLASS
UniquePtrGetterTransfers
{
public
:
using
Ptr
=
UniquePtr
<
T
D
>
;
using
Receiver
=
typename
detail
:
:
ReceiverType
<
T
D
>
:
:
Type
;
explicit
UniquePtrGetterTransfers
(
Ptr
&
p
)
:
mPtr
(
p
)
mReceiver
(
typename
Ptr
:
:
Pointer
(
nullptr
)
)
{
}
~
UniquePtrGetterTransfers
(
)
{
mPtr
.
reset
(
mReceiver
)
;
}
operator
Receiver
*
(
)
{
return
&
mReceiver
;
}
Receiver
&
operator
*
(
)
{
return
mReceiver
;
}
template
<
typename
U
=
Receiver
std
:
:
enable_if_t
<
std
:
:
is_pointer_v
<
U
>
&
&
std
:
:
is_same_v
<
U
Receiver
>
int
>
=
0
>
operator
void
*
*
(
)
{
return
reinterpret_cast
<
void
*
*
>
(
&
mReceiver
)
;
}
private
:
Ptr
&
mPtr
;
Receiver
mReceiver
;
}
;
}
template
<
typename
T
typename
D
>
auto
getter_Transfers
(
UniquePtr
<
T
D
>
&
up
)
{
return
detail
:
:
UniquePtrGetterTransfers
<
T
D
>
(
up
)
;
}
}
#
endif
