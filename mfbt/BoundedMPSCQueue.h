#
ifndef
mozilla_BoundedMPSCQueue_h
#
define
mozilla_BoundedMPSCQueue_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
<
algorithm
>
#
include
<
atomic
>
#
include
<
cinttypes
>
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
memory
>
#
include
<
optional
>
#
include
<
type_traits
>
namespace
mozilla
{
static
constexpr
bool
MPSC_DEBUG
=
false
;
template
<
typename
T
size_t
kCapacity
>
class
MPSCRingBufferBase
{
static
constexpr
size_t
kMaxCapacity
=
16
;
public
:
explicit
MPSCRingBufferBase
(
)
:
mFree
(
0
)
mOccupied
(
0
)
{
static_assert
(
kCapacity
<
kMaxCapacity
)
;
if
constexpr
(
MPSC_DEBUG
)
{
fprintf
(
stderr
"
[
%
s
]
this
=
%
p
{
mCapacity
=
%
zu
mBits
=
%
"
PRIu64
"
mMask
=
0x
%
"
PRIx64
"
}
\
n
"
__PRETTY_FUNCTION__
this
1
+
kCapacity
mBits
mMask
)
;
}
for
(
uint64_t
i
=
1
;
i
<
StorageCapacity
(
)
;
+
+
i
)
{
MarkSlot
(
mFree
i
)
;
}
mData
=
std
:
:
make_unique
<
T
[
]
>
(
Capacity
(
)
)
;
std
:
:
atomic_thread_fence
(
std
:
:
memory_order_seq_cst
)
;
}
[
[
nodiscard
]
]
int
Send
(
T
&
aElement
)
{
std
:
:
optional
<
uint64_t
>
empty_idx
=
UnmarkSlot
(
mFree
)
;
if
(
empty_idx
.
has_value
(
)
)
{
std
:
:
move
(
&
aElement
&
aElement
+
1
&
mData
[
*
empty_idx
-
1
]
)
;
MarkSlot
(
mOccupied
*
empty_idx
)
;
return
*
empty_idx
;
}
return
0
;
}
[
[
nodiscard
]
]
int
Recv
(
T
*
aElement
)
{
std
:
:
optional
<
uint64_t
>
idx
=
UnmarkSlot
(
mOccupied
)
;
if
(
idx
.
has_value
(
)
)
{
if
(
aElement
)
{
std
:
:
move
(
&
mData
[
*
idx
-
1
]
&
mData
[
*
idx
]
aElement
)
;
}
MarkSlot
(
mFree
*
idx
)
;
return
*
idx
;
}
return
0
;
}
constexpr
size_t
Capacity
(
)
const
{
return
StorageCapacity
(
)
-
1
;
}
private
:
[
[
nodiscard
]
]
uint64_t
Get
(
uint64_t
aNumber
uint64_t
aIndex
)
{
return
(
aNumber
>
>
(
mBits
*
aIndex
)
)
&
mMask
;
}
[
[
nodiscard
]
]
uint64_t
Set
(
uint64_t
aNumber
uint64_t
aIndex
uint64_t
aValue
)
{
return
(
aNumber
&
~
(
mMask
<
<
(
mBits
*
aIndex
)
)
)
|
(
aValue
<
<
(
mBits
*
aIndex
)
)
;
}
void
MarkSlot
(
std
:
:
atomic
<
uint64_t
>
&
aSlotStatus
uint64_t
aIndex
)
{
uint64_t
current
=
aSlotStatus
.
load
(
std
:
:
memory_order_relaxed
)
;
do
{
auto
empty
=
[
&
]
(
)
-
>
std
:
:
optional
<
uint64_t
>
{
for
(
uint64_t
i
=
0
;
i
<
Capacity
(
)
;
+
+
i
)
{
if
(
Get
(
current
i
)
=
=
0
)
{
return
i
;
}
}
return
{
}
;
}
(
)
;
if
(
!
empty
.
has_value
(
)
)
{
MOZ_CRASH
(
"
No
empty
slot
available
"
)
;
}
uint64_t
modified
=
Set
(
current
*
empty
aIndex
)
;
if
(
aSlotStatus
.
compare_exchange_weak
(
current
modified
std
:
:
memory_order_release
std
:
:
memory_order_relaxed
)
)
{
if
constexpr
(
MPSC_DEBUG
)
{
fprintf
(
stderr
"
[
enqueue
]
modified
=
0x
%
"
PRIx64
"
=
>
index
=
%
"
PRIu64
"
\
n
"
modified
aIndex
)
;
}
return
;
}
}
while
(
true
)
;
}
[
[
nodiscard
]
]
std
:
:
optional
<
uint64_t
>
UnmarkSlot
(
std
:
:
atomic
<
uint64_t
>
&
aSlotStatus
)
{
uint64_t
current
=
aSlotStatus
.
load
(
std
:
:
memory_order_relaxed
)
;
do
{
uint64_t
index
=
current
&
mMask
;
if
(
index
=
=
0
)
{
return
{
}
;
}
uint64_t
modified
=
current
>
>
mBits
;
if
(
aSlotStatus
.
compare_exchange_weak
(
current
modified
std
:
:
memory_order_acquire
std
:
:
memory_order_relaxed
)
)
{
if
constexpr
(
MPSC_DEBUG
)
{
fprintf
(
stderr
"
[
dequeue
]
current
=
0x
%
"
PRIx64
"
=
>
index
=
%
"
PRIu64
"
\
n
"
current
index
)
;
}
return
index
;
}
}
while
(
true
)
;
return
{
}
;
}
[
[
nodiscard
]
]
constexpr
size_t
StorageCapacity
(
)
const
{
return
1
+
kCapacity
;
}
std
:
:
atomic
<
uint64_t
>
mFree
;
std
:
:
atomic
<
uint64_t
>
mOccupied
;
std
:
:
unique_ptr
<
T
[
]
>
mData
;
static
constexpr
uint64_t
mBits
=
4
;
static
constexpr
uint64_t
mMask
=
0b1111
;
}
;
template
<
typename
T
size_t
Capacity
>
using
BoundedMPSCQueue
=
MPSCRingBufferBase
<
T
Capacity
>
;
}
#
endif
