#
ifndef
mozilla_Pair_h
#
define
mozilla_Pair_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
TypeTraits
.
h
"
namespace
mozilla
{
namespace
detail
{
enum
StorageType
{
AsBase
AsMember
}
;
template
<
typename
A
typename
B
detail
:
:
StorageType
=
IsEmpty
<
A
>
:
:
value
?
detail
:
:
AsBase
:
detail
:
:
AsMember
detail
:
:
StorageType
=
IsEmpty
<
B
>
:
:
value
&
&
!
IsBaseOf
<
A
B
>
:
:
value
&
&
!
IsBaseOf
<
B
A
>
:
:
value
?
detail
:
:
AsBase
:
detail
:
:
AsMember
>
struct
PairHelper
;
template
<
typename
A
typename
B
>
struct
PairHelper
<
A
B
AsMember
AsMember
>
{
protected
:
template
<
typename
AArg
typename
BArg
>
PairHelper
(
AArg
&
&
aA
BArg
&
&
aB
)
:
mFirstA
(
std
:
:
forward
<
AArg
>
(
aA
)
)
mSecondB
(
std
:
:
forward
<
BArg
>
(
aB
)
)
{
}
A
&
first
(
)
{
return
mFirstA
;
}
const
A
&
first
(
)
const
{
return
mFirstA
;
}
B
&
second
(
)
{
return
mSecondB
;
}
const
B
&
second
(
)
const
{
return
mSecondB
;
}
void
swap
(
PairHelper
&
aOther
)
{
Swap
(
mFirstA
aOther
.
mFirstA
)
;
Swap
(
mSecondB
aOther
.
mSecondB
)
;
}
private
:
A
mFirstA
;
B
mSecondB
;
}
;
template
<
typename
A
typename
B
>
struct
PairHelper
<
A
B
AsMember
AsBase
>
:
private
B
{
protected
:
template
<
typename
AArg
typename
BArg
>
PairHelper
(
AArg
&
&
aA
BArg
&
&
aB
)
:
B
(
std
:
:
forward
<
BArg
>
(
aB
)
)
mFirstA
(
std
:
:
forward
<
AArg
>
(
aA
)
)
{
}
A
&
first
(
)
{
return
mFirstA
;
}
const
A
&
first
(
)
const
{
return
mFirstA
;
}
B
&
second
(
)
{
return
*
this
;
}
const
B
&
second
(
)
const
{
return
*
this
;
}
void
swap
(
PairHelper
&
aOther
)
{
Swap
(
mFirstA
aOther
.
mFirstA
)
;
Swap
(
static_cast
<
B
&
>
(
*
this
)
static_cast
<
B
&
>
(
aOther
)
)
;
}
private
:
A
mFirstA
;
}
;
template
<
typename
A
typename
B
>
struct
PairHelper
<
A
B
AsBase
AsMember
>
:
private
A
{
protected
:
template
<
typename
AArg
typename
BArg
>
PairHelper
(
AArg
&
&
aA
BArg
&
&
aB
)
:
A
(
std
:
:
forward
<
AArg
>
(
aA
)
)
mSecondB
(
std
:
:
forward
<
BArg
>
(
aB
)
)
{
}
A
&
first
(
)
{
return
*
this
;
}
const
A
&
first
(
)
const
{
return
*
this
;
}
B
&
second
(
)
{
return
mSecondB
;
}
const
B
&
second
(
)
const
{
return
mSecondB
;
}
void
swap
(
PairHelper
&
aOther
)
{
Swap
(
static_cast
<
A
&
>
(
*
this
)
static_cast
<
A
&
>
(
aOther
)
)
;
Swap
(
mSecondB
aOther
.
mSecondB
)
;
}
private
:
B
mSecondB
;
}
;
template
<
typename
A
typename
B
>
struct
PairHelper
<
A
B
AsBase
AsBase
>
:
private
A
private
B
{
protected
:
template
<
typename
AArg
typename
BArg
>
PairHelper
(
AArg
&
&
aA
BArg
&
&
aB
)
:
A
(
std
:
:
forward
<
AArg
>
(
aA
)
)
B
(
std
:
:
forward
<
BArg
>
(
aB
)
)
{
}
A
&
first
(
)
{
return
static_cast
<
A
&
>
(
*
this
)
;
}
const
A
&
first
(
)
const
{
return
static_cast
<
A
&
>
(
*
this
)
;
}
B
&
second
(
)
{
return
static_cast
<
B
&
>
(
*
this
)
;
}
const
B
&
second
(
)
const
{
return
static_cast
<
B
&
>
(
*
this
)
;
}
void
swap
(
PairHelper
&
aOther
)
{
Swap
(
static_cast
<
A
&
>
(
*
this
)
static_cast
<
A
&
>
(
aOther
)
)
;
Swap
(
static_cast
<
B
&
>
(
*
this
)
static_cast
<
B
&
>
(
aOther
)
)
;
}
}
;
}
template
<
typename
A
typename
B
>
struct
Pair
:
private
detail
:
:
PairHelper
<
A
B
>
{
typedef
typename
detail
:
:
PairHelper
<
A
B
>
Base
;
public
:
template
<
typename
AArg
typename
BArg
>
Pair
(
AArg
&
&
aA
BArg
&
&
aB
)
:
Base
(
std
:
:
forward
<
AArg
>
(
aA
)
std
:
:
forward
<
BArg
>
(
aB
)
)
{
}
Pair
(
Pair
&
&
aOther
)
:
Base
(
std
:
:
move
(
aOther
.
first
(
)
)
std
:
:
move
(
aOther
.
second
(
)
)
)
{
}
Pair
(
const
Pair
&
aOther
)
=
default
;
Pair
&
operator
=
(
Pair
&
&
aOther
)
{
MOZ_ASSERT
(
this
!
=
&
aOther
"
Self
-
moves
are
prohibited
"
)
;
first
(
)
=
std
:
:
move
(
aOther
.
first
(
)
)
;
second
(
)
=
std
:
:
move
(
aOther
.
second
(
)
)
;
return
*
this
;
}
Pair
&
operator
=
(
const
Pair
&
aOther
)
=
default
;
using
Base
:
:
first
;
using
Base
:
:
second
;
void
swap
(
Pair
&
aOther
)
{
Base
:
:
swap
(
aOther
)
;
}
}
;
template
<
typename
A
class
B
>
void
Swap
(
Pair
<
A
B
>
&
aX
Pair
<
A
B
>
&
aY
)
{
aX
.
swap
(
aY
)
;
}
template
<
typename
A
typename
B
>
Pair
<
typename
RemoveCV
<
typename
RemoveReference
<
A
>
:
:
Type
>
:
:
Type
typename
RemoveCV
<
typename
RemoveReference
<
B
>
:
:
Type
>
:
:
Type
>
MakePair
(
A
&
&
aA
B
&
&
aB
)
{
return
Pair
<
typename
RemoveCV
<
typename
RemoveReference
<
A
>
:
:
Type
>
:
:
Type
typename
RemoveCV
<
typename
RemoveReference
<
B
>
:
:
Type
>
:
:
Type
>
(
std
:
:
forward
<
A
>
(
aA
)
std
:
:
forward
<
B
>
(
aB
)
)
;
}
}
#
endif
