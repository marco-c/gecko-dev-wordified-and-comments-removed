#
ifndef
mozilla_Array_h
#
define
mozilla_Array_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
ReverseIterator
.
h
"
#
include
<
stddef
.
h
>
namespace
mozilla
{
template
<
typename
T
size_t
Length
>
class
Array
{
T
mArr
[
Length
]
;
public
:
Array
(
)
{
}
template
<
typename
.
.
.
Args
>
MOZ_IMPLICIT
Array
(
Args
&
&
.
.
.
aArgs
)
:
mArr
{
mozilla
:
:
Forward
<
Args
>
(
aArgs
)
.
.
.
}
{
static_assert
(
sizeof
.
.
.
(
aArgs
)
=
=
Length
"
The
number
of
arguments
should
be
equal
to
the
template
parameter
Length
"
)
;
}
T
&
operator
[
]
(
size_t
aIndex
)
{
MOZ_ASSERT
(
aIndex
<
Length
)
;
return
mArr
[
aIndex
]
;
}
const
T
&
operator
[
]
(
size_t
aIndex
)
const
{
MOZ_ASSERT
(
aIndex
<
Length
)
;
return
mArr
[
aIndex
]
;
}
typedef
T
*
iterator
;
typedef
const
T
*
const_iterator
;
typedef
ReverseIterator
<
T
*
>
reverse_iterator
;
typedef
ReverseIterator
<
const
T
*
>
const_reverse_iterator
;
iterator
begin
(
)
{
return
mArr
;
}
const_iterator
begin
(
)
const
{
return
mArr
;
}
const_iterator
cbegin
(
)
const
{
return
begin
(
)
;
}
iterator
end
(
)
{
return
mArr
+
Length
;
}
const_iterator
end
(
)
const
{
return
mArr
+
Length
;
}
const_iterator
cend
(
)
const
{
return
end
(
)
;
}
reverse_iterator
rbegin
(
)
{
return
reverse_iterator
(
end
(
)
)
;
}
const_reverse_iterator
rbegin
(
)
const
{
return
const_reverse_iterator
(
end
(
)
)
;
}
const_reverse_iterator
crbegin
(
)
const
{
return
rbegin
(
)
;
}
reverse_iterator
rend
(
)
{
return
reverse_iterator
(
begin
(
)
)
;
}
const_reverse_iterator
rend
(
)
const
{
return
const_reverse_iterator
(
begin
(
)
)
;
}
const_reverse_iterator
crend
(
)
const
{
return
rend
(
)
;
}
}
;
template
<
typename
T
>
class
Array
<
T
0
>
{
public
:
T
&
operator
[
]
(
size_t
aIndex
)
{
MOZ_CRASH
(
"
indexing
into
zero
-
length
array
"
)
;
}
const
T
&
operator
[
]
(
size_t
aIndex
)
const
{
MOZ_CRASH
(
"
indexing
into
zero
-
length
array
"
)
;
}
}
;
}
#
endif
