#
ifndef
mozilla_EnumSet_h
#
define
mozilla_EnumSet_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
<
initializer_list
>
#
include
<
type_traits
>
#
include
<
stdint
.
h
>
namespace
mozilla
{
template
<
typename
T
typename
Serialized
=
typename
std
:
:
make_unsigned
<
typename
std
:
:
underlying_type
<
T
>
:
:
type
>
:
:
type
>
class
EnumSet
{
public
:
using
valueType
=
T
;
using
serializedType
=
Serialized
;
constexpr
EnumSet
(
)
:
mBitField
(
)
{
}
constexpr
MOZ_IMPLICIT
EnumSet
(
T
aEnum
)
:
mBitField
(
bitFor
(
aEnum
)
)
{
}
constexpr
EnumSet
(
T
aEnum1
T
aEnum2
)
:
mBitField
(
bitFor
(
aEnum1
)
|
bitFor
(
aEnum2
)
)
{
}
constexpr
EnumSet
(
T
aEnum1
T
aEnum2
T
aEnum3
)
:
mBitField
(
bitFor
(
aEnum1
)
|
bitFor
(
aEnum2
)
|
bitFor
(
aEnum3
)
)
{
}
constexpr
EnumSet
(
T
aEnum1
T
aEnum2
T
aEnum3
T
aEnum4
)
:
mBitField
(
bitFor
(
aEnum1
)
|
bitFor
(
aEnum2
)
|
bitFor
(
aEnum3
)
|
bitFor
(
aEnum4
)
)
{
}
constexpr
MOZ_IMPLICIT
EnumSet
(
std
:
:
initializer_list
<
T
>
list
)
:
mBitField
(
)
{
for
(
auto
value
:
list
)
{
(
*
this
)
+
=
value
;
}
}
#
ifdef
DEBUG
constexpr
EnumSet
(
const
EnumSet
&
aEnumSet
)
:
mBitField
(
aEnumSet
.
mBitField
)
{
}
constexpr
EnumSet
&
operator
=
(
const
EnumSet
&
aEnumSet
)
{
mBitField
=
aEnumSet
.
mBitField
;
incVersion
(
)
;
return
*
this
;
}
#
endif
constexpr
void
operator
+
=
(
T
aEnum
)
{
incVersion
(
)
;
mBitField
|
=
bitFor
(
aEnum
)
;
}
constexpr
EnumSet
operator
+
(
T
aEnum
)
const
{
EnumSet
result
(
*
this
)
;
result
+
=
aEnum
;
return
result
;
}
void
operator
+
=
(
const
EnumSet
&
aEnumSet
)
{
incVersion
(
)
;
mBitField
|
=
aEnumSet
.
mBitField
;
}
EnumSet
operator
+
(
const
EnumSet
&
aEnumSet
)
const
{
EnumSet
result
(
*
this
)
;
result
+
=
aEnumSet
;
return
result
;
}
void
operator
-
=
(
T
aEnum
)
{
incVersion
(
)
;
mBitField
&
=
~
(
bitFor
(
aEnum
)
)
;
}
EnumSet
operator
-
(
T
aEnum
)
const
{
EnumSet
result
(
*
this
)
;
result
-
=
aEnum
;
return
result
;
}
void
operator
-
=
(
const
EnumSet
&
aEnumSet
)
{
incVersion
(
)
;
mBitField
&
=
~
(
aEnumSet
.
mBitField
)
;
}
EnumSet
operator
-
(
const
EnumSet
&
aEnumSet
)
const
{
EnumSet
result
(
*
this
)
;
result
-
=
aEnumSet
;
return
result
;
}
void
clear
(
)
{
incVersion
(
)
;
mBitField
=
Serialized
(
)
;
}
void
operator
&
=
(
const
EnumSet
&
aEnumSet
)
{
incVersion
(
)
;
mBitField
&
=
aEnumSet
.
mBitField
;
}
EnumSet
operator
&
(
const
EnumSet
&
aEnumSet
)
const
{
EnumSet
result
(
*
this
)
;
result
&
=
aEnumSet
;
return
result
;
}
bool
operator
=
=
(
const
EnumSet
&
aEnumSet
)
const
{
return
mBitField
=
=
aEnumSet
.
mBitField
;
}
bool
operator
=
=
(
T
aEnum
)
const
{
return
mBitField
=
=
bitFor
(
aEnum
)
;
}
bool
operator
!
=
(
const
EnumSet
&
aEnumSet
)
const
{
return
!
operator
=
=
(
aEnumSet
)
;
}
bool
operator
!
=
(
T
aEnum
)
const
{
return
!
operator
=
=
(
aEnum
)
;
}
bool
contains
(
T
aEnum
)
const
{
return
static_cast
<
bool
>
(
mBitField
&
bitFor
(
aEnum
)
)
;
}
bool
contains
(
const
EnumSet
&
aEnumSet
)
const
{
return
(
mBitField
&
aEnumSet
.
mBitField
)
=
=
aEnumSet
.
mBitField
;
}
size_t
size
(
)
const
{
if
constexpr
(
std
:
:
is_unsigned_v
<
Serialized
>
)
{
if
constexpr
(
kMaxBits
>
32
)
{
return
CountPopulation64
(
mBitField
)
;
}
else
{
return
CountPopulation32
(
mBitField
)
;
}
}
else
{
return
mBitField
.
Count
(
)
;
}
}
bool
isEmpty
(
)
const
{
if
constexpr
(
std
:
:
is_unsigned_v
<
Serialized
>
)
{
return
mBitField
=
=
0
;
}
else
{
return
mBitField
.
IsEmpty
(
)
;
}
}
Serialized
serialize
(
)
const
{
return
mBitField
;
}
void
deserialize
(
Serialized
aValue
)
{
incVersion
(
)
;
mBitField
=
aValue
;
}
class
ConstIterator
{
const
EnumSet
*
mSet
;
size_t
mPos
;
#
ifdef
DEBUG
uint64_t
mVersion
;
#
endif
void
checkVersion
(
)
const
{
MOZ_ASSERT_IF
(
mSet
mSet
-
>
mVersion
=
=
mVersion
)
;
}
public
:
ConstIterator
(
const
EnumSet
&
aSet
size_t
aPos
)
:
mSet
(
&
aSet
)
mPos
(
aPos
)
{
#
ifdef
DEBUG
mVersion
=
mSet
-
>
mVersion
;
#
endif
MOZ_ASSERT
(
aPos
<
=
kMaxBits
)
;
if
(
aPos
!
=
kMaxBits
&
&
!
mSet
-
>
contains
(
T
(
mPos
)
)
)
{
+
+
*
this
;
}
}
ConstIterator
(
const
ConstIterator
&
aOther
)
:
mSet
(
aOther
.
mSet
)
mPos
(
aOther
.
mPos
)
{
#
ifdef
DEBUG
mVersion
=
aOther
.
mVersion
;
checkVersion
(
)
;
#
endif
}
ConstIterator
(
ConstIterator
&
&
aOther
)
:
mSet
(
aOther
.
mSet
)
mPos
(
aOther
.
mPos
)
{
#
ifdef
DEBUG
mVersion
=
aOther
.
mVersion
;
checkVersion
(
)
;
#
endif
aOther
.
mSet
=
nullptr
;
}
~
ConstIterator
(
)
{
checkVersion
(
)
;
}
bool
operator
=
=
(
const
ConstIterator
&
other
)
const
{
MOZ_ASSERT
(
mSet
=
=
other
.
mSet
)
;
checkVersion
(
)
;
return
mPos
=
=
other
.
mPos
;
}
bool
operator
!
=
(
const
ConstIterator
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
T
operator
*
(
)
const
{
MOZ_ASSERT
(
mSet
)
;
MOZ_ASSERT
(
mPos
<
kMaxBits
)
;
MOZ_ASSERT
(
mSet
-
>
contains
(
T
(
mPos
)
)
)
;
checkVersion
(
)
;
return
T
(
mPos
)
;
}
ConstIterator
&
operator
+
+
(
)
{
MOZ_ASSERT
(
mSet
)
;
MOZ_ASSERT
(
mPos
<
kMaxBits
)
;
checkVersion
(
)
;
do
{
mPos
+
+
;
}
while
(
mPos
<
kMaxBits
&
&
!
mSet
-
>
contains
(
T
(
mPos
)
)
)
;
return
*
this
;
}
}
;
ConstIterator
begin
(
)
const
{
return
ConstIterator
(
*
this
0
)
;
}
ConstIterator
end
(
)
const
{
return
ConstIterator
(
*
this
kMaxBits
)
;
}
private
:
constexpr
static
Serialized
bitFor
(
T
aEnum
)
{
auto
bitNumber
=
static_cast
<
size_t
>
(
aEnum
)
;
MOZ_DIAGNOSTIC_ASSERT
(
bitNumber
<
kMaxBits
)
;
if
constexpr
(
std
:
:
is_unsigned_v
<
Serialized
>
)
{
return
static_cast
<
Serialized
>
(
Serialized
{
1
}
<
<
bitNumber
)
;
}
else
{
Serialized
bitField
;
bitField
[
bitNumber
]
=
true
;
return
bitField
;
}
}
constexpr
void
incVersion
(
)
{
#
ifdef
DEBUG
mVersion
+
+
;
#
endif
}
static
constexpr
size_t
MaxBits
(
)
{
if
constexpr
(
std
:
:
is_unsigned_v
<
Serialized
>
)
{
return
sizeof
(
Serialized
)
*
8
;
}
else
{
return
Serialized
:
:
Size
(
)
;
}
}
static
constexpr
size_t
kMaxBits
=
MaxBits
(
)
;
Serialized
mBitField
;
#
ifdef
DEBUG
uint64_t
mVersion
=
0
;
#
endif
}
;
}
#
endif
