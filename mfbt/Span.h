#
ifndef
mozilla_Span_h
#
define
mozilla_Span_h
#
include
"
mozilla
/
Array
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
mozilla
/
IntegerTypeTraits
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
TypeTraits
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
<
algorithm
>
#
include
<
array
>
#
include
<
cstring
>
#
include
<
iterator
>
#
define
MOZ_SPAN_ASSERTION_CONSTEXPR
#
define
MOZ_SPAN_GCC_CONSTEXPR
#
define
MOZ_SPAN_EXPLICITLY_DEFAULTED_CONSTEXPR
#
define
MOZ_SPAN_CONSTEXPR_NOT_JUST_RETURN
#
define
MOZ_SPAN_NON_CONST_CONSTEXPR
#
ifdef
_MSC_VER
#
pragma
warning
(
push
)
#
pragma
warning
(
disable
:
4127
)
/
/
conditional
expression
is
constant
#
pragma
warning
(
disable
:
26481
26482
26483
26485
26490
26491
26492
26493
26495
)
#
if
_MSC_VER
<
1910
#
pragma
push_macro
(
"
constexpr
"
)
#
define
constexpr
#
endif
#
endif
namespace
mozilla
{
template
<
class
T
class
U
>
inline
constexpr
T
narrow_cast
(
U
&
&
u
)
{
return
static_cast
<
T
>
(
mozilla
:
:
Forward
<
U
>
(
u
)
)
;
}
constexpr
const
size_t
dynamic_extent
=
mozilla
:
:
MaxValue
<
size_t
>
:
:
value
;
template
<
class
ElementType
size_t
Extent
=
dynamic_extent
>
class
Span
;
namespace
span_details
{
inline
size_t
strlen16
(
const
char16_t
*
aZeroTerminated
)
{
size_t
len
=
0
;
while
(
*
(
aZeroTerminated
+
+
)
)
{
len
+
+
;
}
return
len
;
}
template
<
class
T
>
using
remove_cv_t
=
typename
mozilla
:
:
RemoveCV
<
T
>
:
:
Type
;
template
<
class
T
>
using
remove_const_t
=
typename
mozilla
:
:
RemoveConst
<
T
>
:
:
Type
;
template
<
bool
B
class
T
class
F
>
using
conditional_t
=
typename
mozilla
:
:
Conditional
<
B
T
F
>
:
:
Type
;
template
<
class
T
>
using
add_pointer_t
=
typename
mozilla
:
:
AddPointer
<
T
>
:
:
Type
;
template
<
bool
B
class
T
=
void
>
using
enable_if_t
=
typename
mozilla
:
:
EnableIf
<
B
T
>
:
:
Type
;
template
<
class
T
>
struct
is_span_oracle
:
mozilla
:
:
FalseType
{
}
;
template
<
class
ElementType
size_t
Extent
>
struct
is_span_oracle
<
mozilla
:
:
Span
<
ElementType
Extent
>
>
:
mozilla
:
:
TrueType
{
}
;
template
<
class
T
>
struct
is_span
:
public
is_span_oracle
<
remove_cv_t
<
T
>
>
{
}
;
template
<
class
T
>
struct
is_std_array_oracle
:
mozilla
:
:
FalseType
{
}
;
template
<
class
ElementType
size_t
Extent
>
struct
is_std_array_oracle
<
std
:
:
array
<
ElementType
Extent
>
>
:
mozilla
:
:
TrueType
{
}
;
template
<
class
T
>
struct
is_std_array
:
public
is_std_array_oracle
<
remove_cv_t
<
T
>
>
{
}
;
template
<
size_t
From
size_t
To
>
struct
is_allowed_extent_conversion
:
public
mozilla
:
:
IntegralConstant
<
bool
From
=
=
To
|
|
From
=
=
mozilla
:
:
dynamic_extent
|
|
To
=
=
mozilla
:
:
dynamic_extent
>
{
}
;
template
<
class
From
class
To
>
struct
is_allowed_element_type_conversion
:
public
mozilla
:
:
IntegralConstant
<
bool
mozilla
:
:
IsConvertible
<
From
(
*
)
[
]
To
(
*
)
[
]
>
:
:
value
>
{
}
;
template
<
class
Span
bool
IsConst
>
class
span_iterator
{
using
element_type_
=
typename
Span
:
:
element_type
;
public
:
using
iterator_category
=
std
:
:
random_access_iterator_tag
;
using
value_type
=
remove_const_t
<
element_type_
>
;
using
difference_type
=
typename
Span
:
:
index_type
;
using
reference
=
conditional_t
<
IsConst
const
element_type_
element_type_
>
&
;
using
pointer
=
add_pointer_t
<
reference
>
;
constexpr
span_iterator
(
)
:
span_iterator
(
nullptr
0
)
{
}
MOZ_SPAN_ASSERTION_CONSTEXPR
span_iterator
(
const
Span
*
span
typename
Span
:
:
index_type
index
)
:
span_
(
span
)
index_
(
index
)
{
MOZ_RELEASE_ASSERT
(
span
=
=
nullptr
|
|
(
index_
>
=
0
&
&
index
<
=
span_
-
>
Length
(
)
)
)
;
}
friend
class
span_iterator
<
Span
true
>
;
constexpr
MOZ_IMPLICIT
span_iterator
(
const
span_iterator
<
Span
false
>
&
other
)
:
span_iterator
(
other
.
span_
other
.
index_
)
{
}
MOZ_SPAN_EXPLICITLY_DEFAULTED_CONSTEXPR
span_iterator
<
Span
IsConst
>
&
operator
=
(
const
span_iterator
<
Span
IsConst
>
&
)
=
default
;
MOZ_SPAN_GCC_CONSTEXPR
reference
operator
*
(
)
const
{
MOZ_RELEASE_ASSERT
(
span_
)
;
return
(
*
span_
)
[
index_
]
;
}
MOZ_SPAN_GCC_CONSTEXPR
pointer
operator
-
>
(
)
const
{
MOZ_RELEASE_ASSERT
(
span_
)
;
return
&
(
(
*
span_
)
[
index_
]
)
;
}
MOZ_SPAN_NON_CONST_CONSTEXPR
span_iterator
&
operator
+
+
(
)
{
MOZ_RELEASE_ASSERT
(
span_
&
&
index_
>
=
0
&
&
index_
<
span_
-
>
Length
(
)
)
;
+
+
index_
;
return
*
this
;
}
MOZ_SPAN_NON_CONST_CONSTEXPR
span_iterator
operator
+
+
(
int
)
{
auto
ret
=
*
this
;
+
+
(
*
this
)
;
return
ret
;
}
MOZ_SPAN_NON_CONST_CONSTEXPR
span_iterator
&
operator
-
-
(
)
{
MOZ_RELEASE_ASSERT
(
span_
&
&
index_
>
0
&
&
index_
<
=
span_
-
>
Length
(
)
)
;
-
-
index_
;
return
*
this
;
}
MOZ_SPAN_NON_CONST_CONSTEXPR
span_iterator
operator
-
-
(
int
)
{
auto
ret
=
*
this
;
-
-
(
*
this
)
;
return
ret
;
}
MOZ_SPAN_CONSTEXPR_NOT_JUST_RETURN
span_iterator
operator
+
(
difference_type
n
)
const
{
auto
ret
=
*
this
;
return
ret
+
=
n
;
}
MOZ_SPAN_GCC_CONSTEXPR
span_iterator
&
operator
+
=
(
difference_type
n
)
{
MOZ_RELEASE_ASSERT
(
span_
&
&
(
index_
+
n
)
>
=
0
&
&
(
index_
+
n
)
<
=
span_
-
>
Length
(
)
)
;
index_
+
=
n
;
return
*
this
;
}
MOZ_SPAN_CONSTEXPR_NOT_JUST_RETURN
span_iterator
operator
-
(
difference_type
n
)
const
{
auto
ret
=
*
this
;
return
ret
-
=
n
;
}
MOZ_SPAN_NON_CONST_CONSTEXPR
span_iterator
&
operator
-
=
(
difference_type
n
)
{
return
*
this
+
=
-
n
;
}
MOZ_SPAN_GCC_CONSTEXPR
difference_type
operator
-
(
const
span_iterator
&
rhs
)
const
{
MOZ_RELEASE_ASSERT
(
span_
=
=
rhs
.
span_
)
;
return
index_
-
rhs
.
index_
;
}
constexpr
reference
operator
[
]
(
difference_type
n
)
const
{
return
*
(
*
this
+
n
)
;
}
constexpr
friend
bool
operator
=
=
(
const
span_iterator
&
lhs
const
span_iterator
&
rhs
)
{
return
lhs
.
span_
=
=
rhs
.
span_
&
&
lhs
.
index_
=
=
rhs
.
index_
;
}
constexpr
friend
bool
operator
!
=
(
const
span_iterator
&
lhs
const
span_iterator
&
rhs
)
{
return
!
(
lhs
=
=
rhs
)
;
}
MOZ_SPAN_GCC_CONSTEXPR
friend
bool
operator
<
(
const
span_iterator
&
lhs
const
span_iterator
&
rhs
)
{
MOZ_RELEASE_ASSERT
(
lhs
.
span_
=
=
rhs
.
span_
)
;
return
lhs
.
index_
<
rhs
.
index_
;
}
constexpr
friend
bool
operator
<
=
(
const
span_iterator
&
lhs
const
span_iterator
&
rhs
)
{
return
!
(
rhs
<
lhs
)
;
}
constexpr
friend
bool
operator
>
(
const
span_iterator
&
lhs
const
span_iterator
&
rhs
)
{
return
rhs
<
lhs
;
}
constexpr
friend
bool
operator
>
=
(
const
span_iterator
&
lhs
const
span_iterator
&
rhs
)
{
return
!
(
rhs
>
lhs
)
;
}
void
swap
(
span_iterator
&
rhs
)
{
std
:
:
swap
(
index_
rhs
.
index_
)
;
std
:
:
swap
(
span_
rhs
.
span_
)
;
}
protected
:
const
Span
*
span_
;
size_t
index_
;
}
;
template
<
class
Span
bool
IsConst
>
inline
constexpr
span_iterator
<
Span
IsConst
>
operator
+
(
typename
span_iterator
<
Span
IsConst
>
:
:
difference_type
n
const
span_iterator
<
Span
IsConst
>
&
rhs
)
{
return
rhs
+
n
;
}
template
<
size_t
Ext
>
class
extent_type
{
public
:
using
index_type
=
size_t
;
static_assert
(
Ext
>
=
0
"
A
fixed
-
size
Span
must
be
>
=
0
in
size
.
"
)
;
constexpr
extent_type
(
)
{
}
template
<
index_type
Other
>
MOZ_SPAN_ASSERTION_CONSTEXPR
MOZ_IMPLICIT
extent_type
(
extent_type
<
Other
>
ext
)
{
static_assert
(
Other
=
=
Ext
|
|
Other
=
=
dynamic_extent
"
Mismatch
between
fixed
-
size
extent
and
size
of
initializing
data
.
"
)
;
MOZ_RELEASE_ASSERT
(
ext
.
size
(
)
=
=
Ext
)
;
}
MOZ_SPAN_ASSERTION_CONSTEXPR
MOZ_IMPLICIT
extent_type
(
index_type
length
)
{
MOZ_RELEASE_ASSERT
(
length
=
=
Ext
)
;
}
constexpr
index_type
size
(
)
const
{
return
Ext
;
}
}
;
template
<
>
class
extent_type
<
dynamic_extent
>
{
public
:
using
index_type
=
size_t
;
template
<
index_type
Other
>
explicit
constexpr
extent_type
(
extent_type
<
Other
>
ext
)
:
size_
(
ext
.
size
(
)
)
{
}
explicit
constexpr
extent_type
(
index_type
length
)
:
size_
(
length
)
{
}
constexpr
index_type
size
(
)
const
{
return
size_
;
}
private
:
index_type
size_
;
}
;
}
template
<
class
ElementType
size_t
Extent
>
class
Span
{
public
:
using
element_type
=
ElementType
;
using
index_type
=
size_t
;
using
pointer
=
element_type
*
;
using
reference
=
element_type
&
;
using
iterator
=
span_details
:
:
span_iterator
<
Span
<
ElementType
Extent
>
false
>
;
using
const_iterator
=
span_details
:
:
span_iterator
<
Span
<
ElementType
Extent
>
true
>
;
using
reverse_iterator
=
std
:
:
reverse_iterator
<
iterator
>
;
using
const_reverse_iterator
=
std
:
:
reverse_iterator
<
const_iterator
>
;
constexpr
static
const
index_type
extent
=
Extent
;
template
<
bool
Dependent
=
false
class
=
span_details
:
:
enable_if_t
<
(
Dependent
|
|
Extent
=
=
0
|
|
Extent
=
=
mozilla
:
:
MaxValue
<
size_t
>
:
:
value
)
>
>
constexpr
Span
(
)
:
storage_
(
nullptr
span_details
:
:
extent_type
<
0
>
(
)
)
{
}
constexpr
MOZ_IMPLICIT
Span
(
std
:
:
nullptr_t
)
:
Span
(
)
{
}
constexpr
Span
(
pointer
aPtr
index_type
aLength
)
:
storage_
(
aPtr
aLength
)
{
}
constexpr
Span
(
pointer
aStartPtr
pointer
aEndPtr
)
:
storage_
(
aStartPtr
std
:
:
distance
(
aStartPtr
aEndPtr
)
)
{
}
template
<
size_t
N
>
constexpr
MOZ_IMPLICIT
Span
(
element_type
(
&
aArr
)
[
N
]
)
:
storage_
(
&
aArr
[
0
]
span_details
:
:
extent_type
<
N
>
(
)
)
{
}
template
<
size_t
N
class
ArrayElementType
=
span_details
:
:
remove_const_t
<
element_type
>
>
constexpr
MOZ_IMPLICIT
Span
(
std
:
:
array
<
ArrayElementType
N
>
&
aArr
)
:
storage_
(
&
aArr
[
0
]
span_details
:
:
extent_type
<
N
>
(
)
)
{
}
template
<
size_t
N
>
constexpr
MOZ_IMPLICIT
Span
(
const
std
:
:
array
<
span_details
:
:
remove_const_t
<
element_type
>
N
>
&
aArr
)
:
storage_
(
&
aArr
[
0
]
span_details
:
:
extent_type
<
N
>
(
)
)
{
}
template
<
size_t
N
class
ArrayElementType
=
span_details
:
:
remove_const_t
<
element_type
>
>
constexpr
MOZ_IMPLICIT
Span
(
mozilla
:
:
Array
<
ArrayElementType
N
>
&
aArr
)
:
storage_
(
&
aArr
[
0
]
span_details
:
:
extent_type
<
N
>
(
)
)
{
}
template
<
size_t
N
>
constexpr
MOZ_IMPLICIT
Span
(
const
mozilla
:
:
Array
<
span_details
:
:
remove_const_t
<
element_type
>
N
>
&
aArr
)
:
storage_
(
&
aArr
[
0
]
span_details
:
:
extent_type
<
N
>
(
)
)
{
}
template
<
class
ArrayElementType
=
std
:
:
add_pointer
<
element_type
>
>
constexpr
Span
(
const
mozilla
:
:
UniquePtr
<
ArrayElementType
>
&
aPtr
index_type
aLength
)
:
storage_
(
aPtr
.
get
(
)
aLength
)
{
}
template
<
class
Container
class
=
span_details
:
:
enable_if_t
<
!
span_details
:
:
is_span
<
Container
>
:
:
value
&
&
!
span_details
:
:
is_std_array
<
Container
>
:
:
value
&
&
mozilla
:
:
IsConvertible
<
typename
Container
:
:
pointer
pointer
>
:
:
value
&
&
mozilla
:
:
IsConvertible
<
typename
Container
:
:
pointer
decltype
(
mozilla
:
:
DeclVal
<
Container
>
(
)
.
data
(
)
)
>
:
:
value
>
>
constexpr
MOZ_IMPLICIT
Span
(
Container
&
cont
)
:
Span
(
cont
.
data
(
)
ReleaseAssertedCast
<
index_type
>
(
cont
.
size
(
)
)
)
{
}
template
<
class
Container
class
=
span_details
:
:
enable_if_t
<
mozilla
:
:
IsConst
<
element_type
>
:
:
value
&
&
!
span_details
:
:
is_span
<
Container
>
:
:
value
&
&
mozilla
:
:
IsConvertible
<
typename
Container
:
:
pointer
pointer
>
:
:
value
&
&
mozilla
:
:
IsConvertible
<
typename
Container
:
:
pointer
decltype
(
mozilla
:
:
DeclVal
<
Container
>
(
)
.
data
(
)
)
>
:
:
value
>
>
constexpr
MOZ_IMPLICIT
Span
(
const
Container
&
cont
)
:
Span
(
cont
.
data
(
)
ReleaseAssertedCast
<
index_type
>
(
cont
.
size
(
)
)
)
{
}
constexpr
Span
(
const
Span
&
other
)
=
default
;
constexpr
Span
(
Span
&
&
other
)
=
default
;
template
<
class
OtherElementType
size_t
OtherExtent
class
=
span_details
:
:
enable_if_t
<
span_details
:
:
is_allowed_extent_conversion
<
OtherExtent
Extent
>
:
:
value
&
&
span_details
:
:
is_allowed_element_type_conversion
<
OtherElementType
element_type
>
:
:
value
>
>
constexpr
MOZ_IMPLICIT
Span
(
const
Span
<
OtherElementType
OtherExtent
>
&
other
)
:
storage_
(
other
.
data
(
)
span_details
:
:
extent_type
<
OtherExtent
>
(
other
.
size
(
)
)
)
{
}
template
<
class
OtherElementType
size_t
OtherExtent
class
=
span_details
:
:
enable_if_t
<
span_details
:
:
is_allowed_extent_conversion
<
OtherExtent
Extent
>
:
:
value
&
&
span_details
:
:
is_allowed_element_type_conversion
<
OtherElementType
element_type
>
:
:
value
>
>
constexpr
MOZ_IMPLICIT
Span
(
Span
<
OtherElementType
OtherExtent
>
&
&
other
)
:
storage_
(
other
.
data
(
)
span_details
:
:
extent_type
<
OtherExtent
>
(
other
.
size
(
)
)
)
{
}
~
Span
(
)
=
default
;
MOZ_SPAN_EXPLICITLY_DEFAULTED_CONSTEXPR
Span
&
operator
=
(
const
Span
&
other
)
=
default
;
MOZ_SPAN_EXPLICITLY_DEFAULTED_CONSTEXPR
Span
&
operator
=
(
Span
&
&
other
)
=
default
;
template
<
size_t
Count
>
MOZ_SPAN_GCC_CONSTEXPR
Span
<
element_type
Count
>
First
(
)
const
{
MOZ_RELEASE_ASSERT
(
Count
<
=
size
(
)
)
;
return
{
data
(
)
Count
}
;
}
template
<
size_t
Count
>
MOZ_SPAN_GCC_CONSTEXPR
Span
<
element_type
Count
>
Last
(
)
const
{
MOZ_RELEASE_ASSERT
(
Count
<
=
size
(
)
)
;
return
{
data
(
)
+
(
size
(
)
-
Count
)
Count
}
;
}
template
<
size_t
Offset
size_t
Count
=
dynamic_extent
>
MOZ_SPAN_GCC_CONSTEXPR
Span
<
element_type
Count
>
Subspan
(
)
const
{
MOZ_RELEASE_ASSERT
(
Offset
<
=
size
(
)
&
&
(
Count
=
=
dynamic_extent
|
|
(
Offset
+
Count
<
=
size
(
)
)
)
)
;
return
{
data
(
)
+
Offset
Count
=
=
dynamic_extent
?
size
(
)
-
Offset
:
Count
}
;
}
MOZ_SPAN_GCC_CONSTEXPR
Span
<
element_type
dynamic_extent
>
First
(
index_type
aCount
)
const
{
MOZ_RELEASE_ASSERT
(
aCount
<
=
size
(
)
)
;
return
{
data
(
)
aCount
}
;
}
MOZ_SPAN_GCC_CONSTEXPR
Span
<
element_type
dynamic_extent
>
Last
(
index_type
aCount
)
const
{
MOZ_RELEASE_ASSERT
(
aCount
<
=
size
(
)
)
;
return
{
data
(
)
+
(
size
(
)
-
aCount
)
aCount
}
;
}
MOZ_SPAN_GCC_CONSTEXPR
Span
<
element_type
dynamic_extent
>
Subspan
(
index_type
aStart
index_type
aLength
=
dynamic_extent
)
const
{
MOZ_RELEASE_ASSERT
(
aStart
<
=
size
(
)
&
&
(
aLength
=
=
dynamic_extent
|
|
(
aStart
+
aLength
<
=
size
(
)
)
)
)
;
return
{
data
(
)
+
aStart
aLength
=
=
dynamic_extent
?
size
(
)
-
aStart
:
aLength
}
;
}
MOZ_SPAN_GCC_CONSTEXPR
Span
<
element_type
dynamic_extent
>
From
(
index_type
aStart
)
const
{
return
Subspan
(
aStart
)
;
}
MOZ_SPAN_GCC_CONSTEXPR
Span
<
element_type
dynamic_extent
>
To
(
index_type
aEnd
)
const
{
return
Subspan
(
0
aEnd
)
;
}
MOZ_SPAN_GCC_CONSTEXPR
Span
<
element_type
dynamic_extent
>
FromTo
(
index_type
aStart
index_type
aEnd
)
const
{
MOZ_RELEASE_ASSERT
(
aStart
<
=
aEnd
)
;
return
Subspan
(
aStart
aEnd
-
aStart
)
;
}
constexpr
index_type
Length
(
)
const
{
return
size
(
)
;
}
constexpr
index_type
size
(
)
const
{
return
storage_
.
size
(
)
;
}
constexpr
index_type
LengthBytes
(
)
const
{
return
size_bytes
(
)
;
}
constexpr
index_type
size_bytes
(
)
const
{
return
size
(
)
*
narrow_cast
<
index_type
>
(
sizeof
(
element_type
)
)
;
}
constexpr
bool
IsEmpty
(
)
const
{
return
empty
(
)
;
}
constexpr
bool
empty
(
)
const
{
return
size
(
)
=
=
0
;
}
MOZ_SPAN_GCC_CONSTEXPR
reference
operator
[
]
(
index_type
idx
)
const
{
MOZ_RELEASE_ASSERT
(
idx
<
storage_
.
size
(
)
)
;
return
data
(
)
[
idx
]
;
}
constexpr
reference
at
(
index_type
idx
)
const
{
return
this
-
>
operator
[
]
(
idx
)
;
}
constexpr
reference
operator
(
)
(
index_type
idx
)
const
{
return
this
-
>
operator
[
]
(
idx
)
;
}
constexpr
pointer
Elements
(
)
const
{
return
data
(
)
;
}
constexpr
pointer
data
(
)
const
{
return
storage_
.
data
(
)
;
}
iterator
begin
(
)
const
{
return
{
this
0
}
;
}
iterator
end
(
)
const
{
return
{
this
Length
(
)
}
;
}
const_iterator
cbegin
(
)
const
{
return
{
this
0
}
;
}
const_iterator
cend
(
)
const
{
return
{
this
Length
(
)
}
;
}
reverse_iterator
rbegin
(
)
const
{
return
reverse_iterator
{
end
(
)
}
;
}
reverse_iterator
rend
(
)
const
{
return
reverse_iterator
{
begin
(
)
}
;
}
const_reverse_iterator
crbegin
(
)
const
{
return
const_reverse_iterator
{
cend
(
)
}
;
}
const_reverse_iterator
crend
(
)
const
{
return
const_reverse_iterator
{
cbegin
(
)
}
;
}
private
:
template
<
class
ExtentType
>
class
storage_type
:
public
ExtentType
{
public
:
template
<
class
OtherExtentType
>
MOZ_SPAN_ASSERTION_CONSTEXPR
storage_type
(
pointer
elements
OtherExtentType
ext
)
:
ExtentType
(
ext
)
data_
(
elements
)
{
MOZ_RELEASE_ASSERT
(
(
!
elements
&
&
ExtentType
:
:
size
(
)
=
=
0
)
|
|
(
elements
&
&
ExtentType
:
:
size
(
)
!
=
mozilla
:
:
MaxValue
<
size_t
>
:
:
value
)
)
;
}
constexpr
pointer
data
(
)
const
{
return
data_
;
}
private
:
pointer
data_
;
}
;
storage_type
<
span_details
:
:
extent_type
<
Extent
>
>
storage_
;
}
;
template
<
class
ElementType
size_t
FirstExtent
size_t
SecondExtent
>
inline
constexpr
bool
operator
=
=
(
const
Span
<
ElementType
FirstExtent
>
&
l
const
Span
<
ElementType
SecondExtent
>
&
r
)
{
return
(
l
.
size
(
)
=
=
r
.
size
(
)
)
&
&
std
:
:
equal
(
l
.
begin
(
)
l
.
end
(
)
r
.
begin
(
)
)
;
}
template
<
class
ElementType
size_t
Extent
>
inline
constexpr
bool
operator
!
=
(
const
Span
<
ElementType
Extent
>
&
l
const
Span
<
ElementType
Extent
>
&
r
)
{
return
!
(
l
=
=
r
)
;
}
template
<
class
ElementType
size_t
Extent
>
inline
constexpr
bool
operator
<
(
const
Span
<
ElementType
Extent
>
&
l
const
Span
<
ElementType
Extent
>
&
r
)
{
return
std
:
:
lexicographical_compare
(
l
.
begin
(
)
l
.
end
(
)
r
.
begin
(
)
r
.
end
(
)
)
;
}
template
<
class
ElementType
size_t
Extent
>
inline
constexpr
bool
operator
<
=
(
const
Span
<
ElementType
Extent
>
&
l
const
Span
<
ElementType
Extent
>
&
r
)
{
return
!
(
l
>
r
)
;
}
template
<
class
ElementType
size_t
Extent
>
inline
constexpr
bool
operator
>
(
const
Span
<
ElementType
Extent
>
&
l
const
Span
<
ElementType
Extent
>
&
r
)
{
return
r
<
l
;
}
template
<
class
ElementType
size_t
Extent
>
inline
constexpr
bool
operator
>
=
(
const
Span
<
ElementType
Extent
>
&
l
const
Span
<
ElementType
Extent
>
&
r
)
{
return
!
(
l
<
r
)
;
}
namespace
span_details
{
template
<
class
ElementType
size_t
Extent
>
struct
calculate_byte_size
:
mozilla
:
:
IntegralConstant
<
size_t
static_cast
<
size_t
>
(
sizeof
(
ElementType
)
*
static_cast
<
size_t
>
(
Extent
)
)
>
{
}
;
template
<
class
ElementType
>
struct
calculate_byte_size
<
ElementType
dynamic_extent
>
:
mozilla
:
:
IntegralConstant
<
size_t
dynamic_extent
>
{
}
;
}
template
<
class
ElementType
size_t
Extent
>
Span
<
const
uint8_t
span_details
:
:
calculate_byte_size
<
ElementType
Extent
>
:
:
value
>
AsBytes
(
Span
<
ElementType
Extent
>
s
)
{
return
{
reinterpret_cast
<
const
uint8_t
*
>
(
s
.
data
(
)
)
s
.
size_bytes
(
)
}
;
}
template
<
class
ElementType
size_t
Extent
class
=
span_details
:
:
enable_if_t
<
!
mozilla
:
:
IsConst
<
ElementType
>
:
:
value
>
>
Span
<
uint8_t
span_details
:
:
calculate_byte_size
<
ElementType
Extent
>
:
:
value
>
AsWritableBytes
(
Span
<
ElementType
Extent
>
s
)
{
return
{
reinterpret_cast
<
uint8_t
*
>
(
s
.
data
(
)
)
s
.
size_bytes
(
)
}
;
}
template
<
class
ElementType
>
Span
<
ElementType
>
MakeSpan
(
ElementType
*
aPtr
typename
Span
<
ElementType
>
:
:
index_type
aLength
)
{
return
Span
<
ElementType
>
(
aPtr
aLength
)
;
}
template
<
class
ElementType
>
Span
<
ElementType
>
MakeSpan
(
ElementType
*
aStartPtr
ElementType
*
aEndPtr
)
{
return
Span
<
ElementType
>
(
aStartPtr
aEndPtr
)
;
}
template
<
class
ElementType
size_t
N
>
Span
<
ElementType
>
MakeSpan
(
ElementType
(
&
aArr
)
[
N
]
)
{
return
Span
<
ElementType
>
(
aArr
)
;
}
template
<
class
ElementType
size_t
N
>
Span
<
ElementType
>
MakeSpan
(
mozilla
:
:
Array
<
ElementType
N
>
&
aArr
)
{
return
aArr
;
}
template
<
class
ElementType
size_t
N
>
Span
<
const
ElementType
>
MakeSpan
(
const
mozilla
:
:
Array
<
ElementType
N
>
&
arr
)
{
return
arr
;
}
template
<
class
Container
>
Span
<
typename
Container
:
:
value_type
>
MakeSpan
(
Container
&
cont
)
{
return
Span
<
typename
Container
:
:
value_type
>
(
cont
)
;
}
template
<
class
Container
>
Span
<
const
typename
Container
:
:
value_type
>
MakeSpan
(
const
Container
&
cont
)
{
return
Span
<
const
typename
Container
:
:
value_type
>
(
cont
)
;
}
template
<
class
Ptr
>
Span
<
typename
Ptr
:
:
element_type
>
MakeSpan
(
Ptr
&
aPtr
size_t
aLength
)
{
return
Span
<
typename
Ptr
:
:
element_type
>
(
aPtr
aLength
)
;
}
inline
Span
<
const
char
>
MakeStringSpan
(
const
char
*
aZeroTerminated
)
{
return
Span
<
const
char
>
(
aZeroTerminated
std
:
:
strlen
(
aZeroTerminated
)
)
;
}
inline
Span
<
const
char16_t
>
MakeStringSpan
(
const
char16_t
*
aZeroTerminated
)
{
return
Span
<
const
char16_t
>
(
aZeroTerminated
span_details
:
:
strlen16
(
aZeroTerminated
)
)
;
}
}
#
ifdef
_MSC_VER
#
if
_MSC_VER
<
1910
#
undef
constexpr
#
pragma
pop_macro
(
"
constexpr
"
)
#
endif
#
pragma
warning
(
pop
)
#
endif
#
undef
MOZ_SPAN_ASSERTION_CONSTEXPR
#
undef
MOZ_SPAN_GCC_CONSTEXPR
#
undef
MOZ_SPAN_EXPLICITLY_DEFAULTED_CONSTEXPR
#
undef
MOZ_SPAN_CONSTEXPR_NOT_JUST_RETURN
#
undef
MOZ_SPAN_NON_CONST_CONSTEXPR
#
endif
