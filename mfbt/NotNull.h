#
ifndef
mozilla_NotNull_h
#
define
mozilla_NotNull_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
<
stddef
.
h
>
namespace
mozilla
{
template
<
typename
T
>
class
NotNull
{
template
<
typename
U
>
friend
constexpr
NotNull
<
U
>
WrapNotNull
(
U
aBasePtr
)
;
template
<
typename
U
typename
.
.
.
Args
>
friend
constexpr
NotNull
<
U
>
MakeNotNull
(
Args
&
&
.
.
.
aArgs
)
;
T
mBasePtr
;
template
<
typename
U
>
constexpr
explicit
NotNull
(
U
aBasePtr
)
:
mBasePtr
(
aBasePtr
)
{
}
public
:
NotNull
(
)
=
delete
;
template
<
typename
U
>
constexpr
MOZ_IMPLICIT
NotNull
(
const
NotNull
<
U
>
&
aOther
)
:
mBasePtr
(
aOther
.
get
(
)
)
{
static_assert
(
sizeof
(
T
)
=
=
sizeof
(
NotNull
<
T
>
)
"
NotNull
must
have
zero
space
overhead
.
"
)
;
static_assert
(
offsetof
(
NotNull
<
T
>
mBasePtr
)
=
=
0
"
mBasePtr
must
have
zero
offset
.
"
)
;
}
NotNull
(
const
NotNull
<
T
>
&
)
=
default
;
NotNull
<
T
>
&
operator
=
(
const
NotNull
<
T
>
&
)
=
default
;
NotNull
(
NotNull
<
T
>
&
&
)
=
default
;
NotNull
<
T
>
&
operator
=
(
NotNull
<
T
>
&
&
)
=
default
;
explicit
operator
bool
(
)
const
=
delete
;
constexpr
const
T
&
get
(
)
const
{
return
mBasePtr
;
}
constexpr
operator
const
T
&
(
)
const
{
return
get
(
)
;
}
constexpr
const
T
&
operator
-
>
(
)
const
{
return
get
(
)
;
}
constexpr
decltype
(
*
mBasePtr
)
operator
*
(
)
const
{
return
*
mBasePtr
;
}
}
;
template
<
typename
T
>
constexpr
NotNull
<
T
>
WrapNotNull
(
const
T
aBasePtr
)
{
NotNull
<
T
>
notNull
(
aBasePtr
)
;
MOZ_RELEASE_ASSERT
(
aBasePtr
)
;
return
notNull
;
}
namespace
detail
{
template
<
typename
Pointer
>
struct
PointedTo
{
using
Type
=
typename
RemoveReference
<
decltype
(
*
DeclVal
<
Pointer
>
(
)
)
>
:
:
Type
;
using
NonConstType
=
typename
RemoveConst
<
Type
>
:
:
Type
;
}
;
template
<
typename
T
>
struct
PointedTo
<
T
*
>
{
using
Type
=
T
;
using
NonConstType
=
T
;
}
;
template
<
typename
T
>
struct
PointedTo
<
const
T
*
>
{
using
Type
=
const
T
;
using
NonConstType
=
T
;
}
;
}
template
<
typename
T
typename
.
.
.
Args
>
constexpr
NotNull
<
T
>
MakeNotNull
(
Args
&
&
.
.
.
aArgs
)
{
using
Pointee
=
typename
detail
:
:
PointedTo
<
T
>
:
:
NonConstType
;
static_assert
(
!
IsArray
<
Pointee
>
:
:
value
"
MakeNotNull
cannot
construct
an
array
"
)
;
return
NotNull
<
T
>
(
new
Pointee
(
Forward
<
Args
>
(
aArgs
)
.
.
.
)
)
;
}
template
<
typename
T
typename
U
>
constexpr
bool
operator
=
=
(
const
NotNull
<
T
>
&
aLhs
const
NotNull
<
U
>
&
aRhs
)
{
return
aLhs
.
get
(
)
=
=
aRhs
.
get
(
)
;
}
template
<
typename
T
typename
U
>
constexpr
bool
operator
!
=
(
const
NotNull
<
T
>
&
aLhs
const
NotNull
<
U
>
&
aRhs
)
{
return
aLhs
.
get
(
)
!
=
aRhs
.
get
(
)
;
}
template
<
typename
T
typename
U
>
constexpr
bool
operator
=
=
(
const
NotNull
<
T
>
&
aLhs
const
U
&
aRhs
)
{
return
aLhs
.
get
(
)
=
=
aRhs
;
}
template
<
typename
T
typename
U
>
constexpr
bool
operator
!
=
(
const
NotNull
<
T
>
&
aLhs
const
U
&
aRhs
)
{
return
aLhs
.
get
(
)
!
=
aRhs
;
}
template
<
typename
T
typename
U
>
constexpr
bool
operator
=
=
(
const
T
&
aLhs
const
NotNull
<
U
>
&
aRhs
)
{
return
aLhs
=
=
aRhs
.
get
(
)
;
}
template
<
typename
T
typename
U
>
constexpr
bool
operator
!
=
(
const
T
&
aLhs
const
NotNull
<
U
>
&
aRhs
)
{
return
aLhs
!
=
aRhs
.
get
(
)
;
}
template
<
typename
T
>
bool
operator
=
=
(
const
NotNull
<
T
>
&
decltype
(
nullptr
)
)
=
delete
;
template
<
typename
T
>
bool
operator
!
=
(
const
NotNull
<
T
>
&
decltype
(
nullptr
)
)
=
delete
;
template
<
typename
T
>
bool
operator
=
=
(
decltype
(
nullptr
)
const
NotNull
<
T
>
&
)
=
delete
;
template
<
typename
T
>
bool
operator
!
=
(
decltype
(
nullptr
)
const
NotNull
<
T
>
&
)
=
delete
;
}
#
endif
