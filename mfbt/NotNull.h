#
ifndef
mozilla_NotNull_h
#
define
mozilla_NotNull_h
#
include
<
stddef
.
h
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
mozilla
/
Assertions
.
h
"
namespace
mozilla
{
template
<
typename
T
>
class
NotNull
{
template
<
typename
U
>
friend
constexpr
NotNull
<
U
>
WrapNotNull
(
U
aBasePtr
)
;
template
<
typename
U
typename
.
.
.
Args
>
friend
constexpr
NotNull
<
U
>
MakeNotNull
(
Args
&
&
.
.
.
aArgs
)
;
T
mBasePtr
;
template
<
typename
U
>
constexpr
explicit
NotNull
(
U
aBasePtr
)
:
mBasePtr
(
aBasePtr
)
{
}
public
:
NotNull
(
)
=
delete
;
template
<
typename
U
>
constexpr
MOZ_IMPLICIT
NotNull
(
const
NotNull
<
U
>
&
aOther
)
:
mBasePtr
(
aOther
.
get
(
)
)
{
static_assert
(
sizeof
(
T
)
=
=
sizeof
(
NotNull
<
T
>
)
"
NotNull
must
have
zero
space
overhead
.
"
)
;
static_assert
(
offsetof
(
NotNull
<
T
>
mBasePtr
)
=
=
0
"
mBasePtr
must
have
zero
offset
.
"
)
;
}
explicit
operator
bool
(
)
const
=
delete
;
constexpr
const
T
&
get
(
)
const
{
return
mBasePtr
;
}
constexpr
operator
const
T
&
(
)
const
{
return
get
(
)
;
}
constexpr
auto
*
operator
-
>
(
)
const
MOZ_NONNULL_RETURN
{
return
mBasePtr
.
operator
-
>
(
)
;
}
constexpr
decltype
(
*
mBasePtr
)
operator
*
(
)
const
{
return
*
mBasePtr
;
}
}
;
template
<
typename
T
>
class
NotNull
<
T
*
>
{
template
<
typename
U
>
friend
constexpr
NotNull
<
U
>
WrapNotNull
(
U
aBasePtr
)
;
template
<
typename
U
>
friend
constexpr
NotNull
<
U
*
>
WrapNotNullUnchecked
(
U
*
aBasePtr
)
;
template
<
typename
U
typename
.
.
.
Args
>
friend
constexpr
NotNull
<
U
>
MakeNotNull
(
Args
&
&
.
.
.
aArgs
)
;
T
*
mBasePtr
;
template
<
typename
U
>
constexpr
explicit
NotNull
(
U
*
aBasePtr
)
:
mBasePtr
(
aBasePtr
)
{
}
public
:
NotNull
(
)
=
delete
;
template
<
typename
U
>
constexpr
MOZ_IMPLICIT
NotNull
(
const
NotNull
<
U
>
&
aOther
)
:
mBasePtr
(
aOther
.
get
(
)
)
{
static_assert
(
sizeof
(
T
*
)
=
=
sizeof
(
NotNull
<
T
*
>
)
"
NotNull
must
have
zero
space
overhead
.
"
)
;
static_assert
(
offsetof
(
NotNull
<
T
*
>
mBasePtr
)
=
=
0
"
mBasePtr
must
have
zero
offset
.
"
)
;
}
explicit
operator
bool
(
)
const
=
delete
;
constexpr
T
*
get
(
)
const
MOZ_NONNULL_RETURN
{
return
mBasePtr
;
}
constexpr
operator
T
*
(
)
const
MOZ_NONNULL_RETURN
{
return
get
(
)
;
}
constexpr
T
*
operator
-
>
(
)
const
MOZ_NONNULL_RETURN
{
return
get
(
)
;
}
constexpr
T
&
operator
*
(
)
const
{
return
*
mBasePtr
;
}
}
;
template
<
typename
T
>
constexpr
NotNull
<
T
>
WrapNotNull
(
const
T
aBasePtr
)
{
NotNull
<
T
>
notNull
(
aBasePtr
)
;
MOZ_RELEASE_ASSERT
(
aBasePtr
)
;
return
notNull
;
}
template
<
typename
T
>
MOZ_NONNULL
(
1
)
constexpr
NotNull
<
T
*
>
WrapNotNullUnchecked
(
T
*
const
aBasePtr
)
{
#
if
defined
(
__GNUC__
)
#
pragma
GCC
diagnostic
push
#
pragma
GCC
diagnostic
ignored
"
-
Wnonnull
-
compare
"
#
endif
MOZ_ASSERT
(
aBasePtr
)
;
#
if
defined
(
__GNUC__
)
#
pragma
GCC
diagnostic
pop
#
endif
return
NotNull
<
T
*
>
{
aBasePtr
}
;
}
namespace
detail
{
template
<
typename
Pointer
>
struct
PointedTo
{
using
Type
=
std
:
:
remove_reference_t
<
decltype
(
*
std
:
:
declval
<
Pointer
>
(
)
)
>
;
using
NonConstType
=
std
:
:
remove_const_t
<
Type
>
;
}
;
template
<
typename
T
>
struct
PointedTo
<
T
*
>
{
using
Type
=
T
;
using
NonConstType
=
T
;
}
;
template
<
typename
T
>
struct
PointedTo
<
const
T
*
>
{
using
Type
=
const
T
;
using
NonConstType
=
T
;
}
;
}
template
<
typename
T
typename
.
.
.
Args
>
constexpr
NotNull
<
T
>
MakeNotNull
(
Args
&
&
.
.
.
aArgs
)
{
using
Pointee
=
typename
detail
:
:
PointedTo
<
T
>
:
:
NonConstType
;
static_assert
(
!
std
:
:
is_array_v
<
Pointee
>
"
MakeNotNull
cannot
construct
an
array
"
)
;
return
NotNull
<
T
>
(
new
Pointee
(
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
)
;
}
template
<
typename
T
typename
U
>
constexpr
bool
operator
=
=
(
const
NotNull
<
T
>
&
aLhs
const
NotNull
<
U
>
&
aRhs
)
{
return
aLhs
.
get
(
)
=
=
aRhs
.
get
(
)
;
}
template
<
typename
T
typename
U
>
constexpr
bool
operator
!
=
(
const
NotNull
<
T
>
&
aLhs
const
NotNull
<
U
>
&
aRhs
)
{
return
aLhs
.
get
(
)
!
=
aRhs
.
get
(
)
;
}
template
<
typename
T
typename
U
>
constexpr
bool
operator
=
=
(
const
NotNull
<
T
>
&
aLhs
const
U
&
aRhs
)
{
return
aLhs
.
get
(
)
=
=
aRhs
;
}
template
<
typename
T
typename
U
>
constexpr
bool
operator
!
=
(
const
NotNull
<
T
>
&
aLhs
const
U
&
aRhs
)
{
return
aLhs
.
get
(
)
!
=
aRhs
;
}
template
<
typename
T
typename
U
>
constexpr
bool
operator
=
=
(
const
T
&
aLhs
const
NotNull
<
U
>
&
aRhs
)
{
return
aLhs
=
=
aRhs
.
get
(
)
;
}
template
<
typename
T
typename
U
>
constexpr
bool
operator
!
=
(
const
T
&
aLhs
const
NotNull
<
U
>
&
aRhs
)
{
return
aLhs
!
=
aRhs
.
get
(
)
;
}
template
<
typename
T
>
bool
operator
=
=
(
const
NotNull
<
T
>
&
decltype
(
nullptr
)
)
=
delete
;
template
<
typename
T
>
bool
operator
!
=
(
const
NotNull
<
T
>
&
decltype
(
nullptr
)
)
=
delete
;
template
<
typename
T
>
bool
operator
=
=
(
decltype
(
nullptr
)
const
NotNull
<
T
>
&
)
=
delete
;
template
<
typename
T
>
bool
operator
!
=
(
decltype
(
nullptr
)
const
NotNull
<
T
>
&
)
=
delete
;
}
#
endif
