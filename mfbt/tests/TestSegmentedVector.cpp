#
include
"
mozilla
/
SegmentedVector
.
h
"
#
include
"
mozilla
/
Alignment
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
using
mozilla
:
:
SegmentedVector
;
class
InfallibleAllocPolicy
{
public
:
template
<
typename
T
>
T
*
pod_malloc
(
size_t
aNumElems
)
{
if
(
aNumElems
&
mozilla
:
:
tl
:
:
MulOverflowMask
<
sizeof
(
T
)
>
:
:
value
)
{
MOZ_CRASH
(
"
TestSegmentedVector
.
cpp
:
overflow
"
)
;
}
T
*
rv
=
static_cast
<
T
*
>
(
malloc
(
aNumElems
*
sizeof
(
T
)
)
)
;
if
(
!
rv
)
{
MOZ_CRASH
(
"
TestSegmentedVector
.
cpp
:
out
of
memory
"
)
;
}
return
rv
;
}
void
free_
(
void
*
aPtr
)
{
free
(
aPtr
)
;
}
}
;
static
int
gDummy
;
void
TestBasics
(
)
{
typedef
SegmentedVector
<
int
1024
InfallibleAllocPolicy
>
MyVector
;
MyVector
v
;
int
i
n
;
MOZ_RELEASE_ASSERT
(
v
.
IsEmpty
(
)
)
;
i
=
0
;
for
(
;
i
<
100
;
i
+
+
)
{
gDummy
=
v
.
Append
(
mozilla
:
:
Move
(
i
)
)
;
}
MOZ_RELEASE_ASSERT
(
!
v
.
IsEmpty
(
)
)
;
MOZ_RELEASE_ASSERT
(
v
.
Length
(
)
=
=
100
)
;
n
=
0
;
for
(
auto
iter
=
v
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
MOZ_RELEASE_ASSERT
(
iter
.
Get
(
)
=
=
n
)
;
n
+
+
;
}
MOZ_RELEASE_ASSERT
(
n
=
=
100
)
;
for
(
;
i
<
1000
;
i
+
+
)
{
v
.
InfallibleAppend
(
mozilla
:
:
Move
(
i
)
)
;
}
MOZ_RELEASE_ASSERT
(
!
v
.
IsEmpty
(
)
)
;
MOZ_RELEASE_ASSERT
(
v
.
Length
(
)
=
=
1000
)
;
n
=
0
;
for
(
auto
iter
=
v
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
MOZ_RELEASE_ASSERT
(
iter
.
Get
(
)
=
=
n
)
;
n
+
+
;
}
MOZ_RELEASE_ASSERT
(
n
=
=
1000
)
;
MOZ_RELEASE_ASSERT
(
v
.
Length
(
)
=
=
1000
)
;
for
(
int
len
=
(
int
)
v
.
Length
(
)
;
len
>
0
;
len
-
-
)
{
MOZ_RELEASE_ASSERT
(
v
.
GetLast
(
)
=
=
len
-
1
)
;
v
.
PopLast
(
)
;
}
MOZ_RELEASE_ASSERT
(
v
.
IsEmpty
(
)
)
;
MOZ_RELEASE_ASSERT
(
v
.
Length
(
)
=
=
0
)
;
for
(
i
=
0
;
i
<
1000
;
i
+
+
)
{
v
.
InfallibleAppend
(
mozilla
:
:
Move
(
i
)
)
;
}
MOZ_RELEASE_ASSERT
(
!
v
.
IsEmpty
(
)
)
;
MOZ_RELEASE_ASSERT
(
v
.
Length
(
)
=
=
1000
)
;
v
.
Clear
(
)
;
MOZ_RELEASE_ASSERT
(
v
.
IsEmpty
(
)
)
;
MOZ_RELEASE_ASSERT
(
v
.
Length
(
)
=
=
0
)
;
for
(
i
=
0
;
i
<
1000
;
+
+
i
)
{
v
.
InfallibleAppend
(
mozilla
:
:
Move
(
i
)
)
;
}
MOZ_RELEASE_ASSERT
(
!
v
.
IsEmpty
(
)
)
;
MOZ_RELEASE_ASSERT
(
v
.
Length
(
)
=
=
1000
)
;
v
.
PopLastN
(
300
)
;
MOZ_RELEASE_ASSERT
(
v
.
Length
(
)
=
=
700
)
;
n
=
0
;
for
(
auto
iter
=
v
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
MOZ_RELEASE_ASSERT
(
iter
.
Get
(
)
=
=
n
)
;
n
+
+
;
}
MOZ_RELEASE_ASSERT
(
n
=
=
700
)
;
}
static
size_t
gNumDefaultCtors
;
static
size_t
gNumExplicitCtors
;
static
size_t
gNumCopyCtors
;
static
size_t
gNumMoveCtors
;
static
size_t
gNumDtors
;
struct
NonPOD
{
NonPOD
(
)
{
gNumDefaultCtors
+
+
;
}
explicit
NonPOD
(
int
x
)
{
gNumExplicitCtors
+
+
;
}
NonPOD
(
NonPOD
&
)
{
gNumCopyCtors
+
+
;
}
NonPOD
(
NonPOD
&
&
)
{
gNumMoveCtors
+
+
;
}
~
NonPOD
(
)
{
gNumDtors
+
+
;
}
}
;
void
TestConstructorsAndDestructors
(
)
{
size_t
defaultCtorCalls
=
0
;
size_t
explicitCtorCalls
=
0
;
size_t
copyCtorCalls
=
0
;
size_t
moveCtorCalls
=
0
;
size_t
dtorCalls
=
0
;
{
static
const
size_t
segmentSize
=
64
;
NonPOD
x
(
1
)
;
explicitCtorCalls
+
+
;
SegmentedVector
<
NonPOD
segmentSize
InfallibleAllocPolicy
>
v
;
MOZ_RELEASE_ASSERT
(
v
.
IsEmpty
(
)
)
;
gDummy
=
v
.
Append
(
x
)
;
copyCtorCalls
+
+
;
NonPOD
y
(
1
)
;
explicitCtorCalls
+
+
;
gDummy
=
v
.
Append
(
mozilla
:
:
Move
(
y
)
)
;
moveCtorCalls
+
+
;
NonPOD
z
(
1
)
;
explicitCtorCalls
+
+
;
v
.
InfallibleAppend
(
mozilla
:
:
Move
(
z
)
)
;
moveCtorCalls
+
+
;
v
.
PopLast
(
)
;
dtorCalls
+
+
;
MOZ_RELEASE_ASSERT
(
gNumDtors
=
=
dtorCalls
)
;
v
.
Clear
(
)
;
dtorCalls
+
=
2
;
static_assert
(
sizeof
(
NonPOD
)
=
=
1
"
Fix
length
calculations
!
"
)
;
size_t
nonFullLastSegmentSize
=
segmentSize
-
1
;
for
(
size_t
i
=
0
;
i
<
nonFullLastSegmentSize
;
+
+
i
)
{
gDummy
=
v
.
Append
(
x
)
;
copyCtorCalls
+
+
;
}
MOZ_RELEASE_ASSERT
(
gNumCopyCtors
=
=
copyCtorCalls
)
;
{
size_t
partialPopAmount
=
5
;
MOZ_RELEASE_ASSERT
(
nonFullLastSegmentSize
>
partialPopAmount
)
;
v
.
PopLastN
(
partialPopAmount
)
;
dtorCalls
+
=
partialPopAmount
;
MOZ_RELEASE_ASSERT
(
v
.
Length
(
)
=
=
nonFullLastSegmentSize
-
partialPopAmount
)
;
MOZ_RELEASE_ASSERT
(
!
v
.
IsEmpty
(
)
)
;
MOZ_RELEASE_ASSERT
(
gNumDtors
=
=
dtorCalls
)
;
}
{
size_t
length
=
v
.
Length
(
)
;
v
.
PopLastN
(
length
)
;
dtorCalls
+
=
length
;
MOZ_RELEASE_ASSERT
(
v
.
Length
(
)
=
=
0
)
;
MOZ_RELEASE_ASSERT
(
v
.
IsEmpty
(
)
)
;
MOZ_RELEASE_ASSERT
(
gNumDtors
=
=
dtorCalls
)
;
}
size_t
multipleSegmentsSize
=
(
segmentSize
*
3
)
/
2
;
for
(
size_t
i
=
0
;
i
<
multipleSegmentsSize
;
+
+
i
)
{
gDummy
=
v
.
Append
(
x
)
;
copyCtorCalls
+
+
;
}
MOZ_RELEASE_ASSERT
(
gNumCopyCtors
=
=
copyCtorCalls
)
;
{
v
.
PopLastN
(
segmentSize
)
;
dtorCalls
+
=
segmentSize
;
MOZ_RELEASE_ASSERT
(
v
.
Length
(
)
=
=
(
multipleSegmentsSize
-
segmentSize
)
)
;
MOZ_RELEASE_ASSERT
(
!
v
.
IsEmpty
(
)
)
;
MOZ_RELEASE_ASSERT
(
gNumDtors
=
=
dtorCalls
)
;
}
{
size_t
length
=
v
.
Length
(
)
;
v
.
Clear
(
)
;
dtorCalls
+
=
length
;
MOZ_RELEASE_ASSERT
(
v
.
IsEmpty
(
)
)
;
MOZ_RELEASE_ASSERT
(
gNumDtors
=
=
dtorCalls
)
;
}
MOZ_RELEASE_ASSERT
(
gNumDefaultCtors
=
=
defaultCtorCalls
)
;
MOZ_RELEASE_ASSERT
(
gNumExplicitCtors
=
=
explicitCtorCalls
)
;
MOZ_RELEASE_ASSERT
(
gNumCopyCtors
=
=
copyCtorCalls
)
;
MOZ_RELEASE_ASSERT
(
gNumMoveCtors
=
=
moveCtorCalls
)
;
MOZ_RELEASE_ASSERT
(
gNumDtors
=
=
dtorCalls
)
;
}
dtorCalls
+
=
3
;
MOZ_RELEASE_ASSERT
(
gNumDtors
=
=
dtorCalls
)
;
}
struct
A
{
int
mX
;
int
mY
;
}
;
struct
B
{
int
mX
;
char
mY
;
double
mZ
;
}
;
struct
C
{
A
mA
;
B
mB
;
}
;
struct
D
{
char
mBuf
[
101
]
;
}
;
struct
E
{
}
;
void
TestSegmentCapacitiesAndAlignments
(
)
{
SegmentedVector
<
double
512
>
v1
(
512
)
;
SegmentedVector
<
A
1024
>
v2
(
1024
)
;
SegmentedVector
<
B
999
>
v3
(
999
)
;
SegmentedVector
<
C
10
>
v4
(
10
)
;
SegmentedVector
<
D
1234
>
v5
(
1234
)
;
SegmentedVector
<
E
>
v6
(
4096
)
;
SegmentedVector
<
mozilla
:
:
AlignedElem
<
16
>
100
>
v7
(
100
)
;
}
void
TestIterator
(
)
{
SegmentedVector
<
int
4
>
v
;
auto
iter
=
v
.
Iter
(
)
;
auto
iterFromLast
=
v
.
IterFromLast
(
)
;
MOZ_RELEASE_ASSERT
(
iter
.
Done
(
)
)
;
MOZ_RELEASE_ASSERT
(
iterFromLast
.
Done
(
)
)
;
gDummy
=
v
.
Append
(
1
)
;
iter
=
v
.
Iter
(
)
;
iterFromLast
=
v
.
IterFromLast
(
)
;
MOZ_RELEASE_ASSERT
(
!
iter
.
Done
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
iterFromLast
.
Done
(
)
)
;
iter
.
Next
(
)
;
MOZ_RELEASE_ASSERT
(
iter
.
Done
(
)
)
;
iterFromLast
.
Next
(
)
;
MOZ_RELEASE_ASSERT
(
iterFromLast
.
Done
(
)
)
;
iter
=
v
.
Iter
(
)
;
iterFromLast
=
v
.
IterFromLast
(
)
;
MOZ_RELEASE_ASSERT
(
!
iter
.
Done
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
iterFromLast
.
Done
(
)
)
;
iter
.
Prev
(
)
;
MOZ_RELEASE_ASSERT
(
iter
.
Done
(
)
)
;
iterFromLast
.
Prev
(
)
;
MOZ_RELEASE_ASSERT
(
iterFromLast
.
Done
(
)
)
;
gDummy
=
v
.
Append
(
1
)
;
gDummy
=
v
.
Append
(
1
)
;
gDummy
=
v
.
Append
(
1
)
;
gDummy
=
v
.
Append
(
1
)
;
iter
=
v
.
Iter
(
)
;
iterFromLast
=
v
.
IterFromLast
(
)
;
MOZ_RELEASE_ASSERT
(
!
iter
.
Done
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
iterFromLast
.
Done
(
)
)
;
iter
.
Prev
(
)
;
MOZ_RELEASE_ASSERT
(
iter
.
Done
(
)
)
;
iterFromLast
.
Next
(
)
;
MOZ_RELEASE_ASSERT
(
iterFromLast
.
Done
(
)
)
;
iter
=
v
.
Iter
(
)
;
iterFromLast
=
v
.
IterFromLast
(
)
;
MOZ_RELEASE_ASSERT
(
!
iter
.
Done
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
iterFromLast
.
Done
(
)
)
;
iter
.
Next
(
)
;
MOZ_RELEASE_ASSERT
(
!
iter
.
Done
(
)
)
;
iterFromLast
.
Prev
(
)
;
MOZ_RELEASE_ASSERT
(
!
iterFromLast
.
Done
(
)
)
;
iter
=
v
.
Iter
(
)
;
iterFromLast
=
v
.
IterFromLast
(
)
;
int
count
=
0
;
for
(
;
!
iter
.
Done
(
)
&
&
!
iterFromLast
.
Done
(
)
;
iter
.
Next
(
)
iterFromLast
.
Prev
(
)
)
{
+
+
count
;
}
MOZ_RELEASE_ASSERT
(
count
=
=
5
)
;
iterFromLast
=
v
.
IterFromLast
(
)
;
gDummy
=
v
.
Append
(
2
)
;
gDummy
=
v
.
Append
(
3
)
;
gDummy
=
v
.
Append
(
4
)
;
iterFromLast
.
Next
(
)
;
MOZ_RELEASE_ASSERT
(
!
iterFromLast
.
Done
(
)
)
;
MOZ_RELEASE_ASSERT
(
iterFromLast
.
Get
(
)
=
=
2
)
;
iterFromLast
.
Next
(
)
;
MOZ_RELEASE_ASSERT
(
iterFromLast
.
Get
(
)
=
=
3
)
;
iterFromLast
.
Next
(
)
;
MOZ_RELEASE_ASSERT
(
iterFromLast
.
Get
(
)
=
=
4
)
;
iterFromLast
.
Next
(
)
;
MOZ_RELEASE_ASSERT
(
iterFromLast
.
Done
(
)
)
;
}
int
main
(
void
)
{
TestBasics
(
)
;
TestConstructorsAndDestructors
(
)
;
TestSegmentCapacitiesAndAlignments
(
)
;
TestIterator
(
)
;
return
0
;
}
