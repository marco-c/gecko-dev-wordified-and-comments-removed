#
include
"
gtest
/
gtest
.
h
"
#
include
"
mozilla
/
InitializedOnce
.
h
"
#
include
<
type_traits
>
using
namespace
mozilla
;
namespace
{
template
<
typename
T
>
void
AssertIsSome
(
const
T
&
aVal
)
{
ASSERT_TRUE
(
aVal
)
;
ASSERT_TRUE
(
aVal
.
isSome
(
)
)
;
ASSERT_FALSE
(
aVal
.
isNothing
(
)
)
;
}
template
<
typename
T
>
void
AssertIsNothing
(
const
T
&
aVal
)
{
ASSERT_FALSE
(
aVal
)
;
ASSERT_FALSE
(
aVal
.
isSome
(
)
)
;
ASSERT_TRUE
(
aVal
.
isNothing
(
)
)
;
}
static_assert
(
std
:
:
is_trivially_destructible_v
<
InitializedOnce
<
const
int
>
>
)
;
static_assert
(
std
:
:
is_trivially_destructible_v
<
LazyInitializedOnce
<
const
int
>
>
)
;
static_assert
(
!
std
:
:
is_copy_constructible_v
<
InitializedOnce
<
const
int
>
>
)
;
static_assert
(
!
std
:
:
is_copy_assignable_v
<
InitializedOnce
<
const
int
>
>
)
;
static_assert
(
!
std
:
:
is_default_constructible_v
<
InitializedOnce
<
const
int
>
>
)
;
static_assert
(
std
:
:
is_default_constructible_v
<
LazyInitializedOnce
<
const
int
>
>
)
;
static_assert
(
std
:
:
is_default_constructible_v
<
LazyInitializedOnceEarlyDestructible
<
const
int
>
>
)
;
constexpr
InitializedOnce
<
const
int
>
*
kPtrInitializedOnceIntLazyInitForbid
=
nullptr
;
constexpr
LazyInitializedOnce
<
const
int
>
*
kPtrInitializedOnceIntLazyInitAllow
=
nullptr
;
constexpr
LazyInitializedOnceEarlyDestructible
<
const
int
>
*
kPtrInitializedOnceIntLazyInitAllowResettable
=
nullptr
;
template
<
class
T
typename
=
decltype
(
std
:
:
declval
<
T
*
>
(
)
-
>
destroy
(
)
)
>
constexpr
bool
test_has_destroy_method
(
const
T
*
)
{
return
true
;
}
constexpr
bool
test_has_destroy_method
(
.
.
.
)
{
return
false
;
}
static_assert
(
test_has_destroy_method
(
kPtrInitializedOnceIntLazyInitForbid
)
)
;
static_assert
(
!
test_has_destroy_method
(
kPtrInitializedOnceIntLazyInitAllow
)
)
;
static_assert
(
test_has_destroy_method
(
kPtrInitializedOnceIntLazyInitAllowResettable
)
)
;
template
<
class
T
typename
=
decltype
(
std
:
:
declval
<
T
*
>
(
)
-
>
init
(
std
:
:
declval
<
int
>
(
)
)
)
>
constexpr
bool
test_has_init_method
(
const
T
*
)
{
return
true
;
}
constexpr
bool
test_has_init_method
(
.
.
.
)
{
return
false
;
}
static_assert
(
!
test_has_init_method
(
kPtrInitializedOnceIntLazyInitForbid
)
)
;
static_assert
(
test_has_init_method
(
kPtrInitializedOnceIntLazyInitAllow
)
)
;
static_assert
(
test_has_init_method
(
kPtrInitializedOnceIntLazyInitAllowResettable
)
)
;
struct
MoveOnly
{
explicit
constexpr
MoveOnly
(
int
aValue
)
:
mValue
{
aValue
}
{
}
MoveOnly
(
MoveOnly
&
&
)
=
default
;
MoveOnly
&
operator
=
(
MoveOnly
&
&
)
=
default
;
int
mValue
;
}
;
}
constexpr
int
testValue
=
32
;
TEST
(
InitializedOnce
ImmediateInit
)
{
constexpr
InitializedOnce
<
const
MoveOnly
>
val
{
testValue
}
;
static_assert
(
val
)
;
static_assert
(
val
.
isSome
(
)
)
;
static_assert
(
!
val
.
isNothing
(
)
)
;
static_assert
(
testValue
=
=
(
*
val
)
.
mValue
)
;
static_assert
(
testValue
=
=
val
-
>
mValue
)
;
static_assert
(
testValue
=
=
val
.
ref
(
)
.
mValue
)
;
AssertIsSome
(
val
)
;
ASSERT_EQ
(
testValue
(
*
val
)
.
mValue
)
;
ASSERT_EQ
(
testValue
val
-
>
mValue
)
;
ASSERT_EQ
(
testValue
val
.
ref
(
)
.
mValue
)
;
}
TEST
(
InitializedOnce
ImmediateInitReset
)
{
InitializedOnce
<
const
MoveOnly
>
val
{
testValue
}
;
val
.
destroy
(
)
;
AssertIsNothing
(
val
)
;
}
TEST
(
InitializedOnce
MoveConstruct
)
{
InitializedOnce
<
const
MoveOnly
>
oldVal
{
testValue
}
;
InitializedOnce
<
const
MoveOnly
>
val
{
std
:
:
move
(
oldVal
)
}
;
AssertIsNothing
(
oldVal
)
;
AssertIsSome
(
val
)
;
}
TEST
(
InitializedOnceAllowLazy
DefaultCtor
)
{
LazyInitializedOnce
<
const
MoveOnly
>
val
;
AssertIsNothing
(
val
)
;
}
TEST
(
InitializedOnceAllowLazy
Init
)
{
LazyInitializedOnce
<
const
MoveOnly
>
val
;
val
.
init
(
testValue
)
;
AssertIsSome
(
val
)
;
ASSERT_EQ
(
testValue
(
*
val
)
.
mValue
)
;
ASSERT_EQ
(
testValue
val
-
>
mValue
)
;
ASSERT_EQ
(
testValue
val
.
ref
(
)
.
mValue
)
;
}
TEST
(
InitializedOnceAllowLazy
do_Init
)
{
LazyInitializedOnce
<
const
MoveOnly
>
val
;
do_Init
(
val
)
=
MoveOnly
{
testValue
}
;
AssertIsSome
(
val
)
;
ASSERT_EQ
(
testValue
(
*
val
)
.
mValue
)
;
ASSERT_EQ
(
testValue
val
-
>
mValue
)
;
ASSERT_EQ
(
testValue
val
.
ref
(
)
.
mValue
)
;
}
TEST
(
InitializedOnceAllowLazyResettable
DefaultCtor
)
{
LazyInitializedOnceEarlyDestructible
<
const
MoveOnly
>
val
;
AssertIsNothing
(
val
)
;
}
TEST
(
InitializedOnceAllowLazyResettable
Init
)
{
LazyInitializedOnceEarlyDestructible
<
const
MoveOnly
>
val
;
val
.
init
(
testValue
)
;
AssertIsSome
(
val
)
;
ASSERT_EQ
(
testValue
(
*
val
)
.
mValue
)
;
ASSERT_EQ
(
testValue
val
-
>
mValue
)
;
ASSERT_EQ
(
testValue
val
.
ref
(
)
.
mValue
)
;
}
TEST
(
InitializedOnceAllowLazyResettable
InitReset
)
{
LazyInitializedOnceEarlyDestructible
<
const
MoveOnly
>
val
;
val
.
init
(
testValue
)
;
val
.
destroy
(
)
;
AssertIsNothing
(
val
)
;
}
TEST
(
InitializedOnceAllowLazyResettable
MoveConstruct
)
{
LazyInitializedOnceEarlyDestructible
<
const
MoveOnly
>
oldVal
{
testValue
}
;
LazyInitializedOnceEarlyDestructible
<
const
MoveOnly
>
val
{
std
:
:
move
(
oldVal
)
}
;
AssertIsNothing
(
oldVal
)
;
AssertIsSome
(
val
)
;
}
TEST
(
InitializedOnceAllowLazyResettable
MoveAssign
)
{
LazyInitializedOnceEarlyDestructible
<
const
MoveOnly
>
oldVal
{
testValue
}
;
LazyInitializedOnceEarlyDestructible
<
const
MoveOnly
>
val
;
val
=
std
:
:
move
(
oldVal
)
;
AssertIsNothing
(
oldVal
)
;
AssertIsSome
(
val
)
;
}
