#
include
"
mozilla
/
BufferList
.
h
"
class
InfallibleAllocPolicy
{
public
:
template
<
typename
T
>
T
*
pod_malloc
(
size_t
aNumElems
)
{
if
(
aNumElems
&
mozilla
:
:
tl
:
:
MulOverflowMask
<
sizeof
(
T
)
>
:
:
value
)
{
MOZ_CRASH
(
"
TestBufferList
.
cpp
:
overflow
"
)
;
}
T
*
rv
=
static_cast
<
T
*
>
(
malloc
(
aNumElems
*
sizeof
(
T
)
)
)
;
if
(
!
rv
)
{
MOZ_CRASH
(
"
TestBufferList
.
cpp
:
out
of
memory
"
)
;
}
return
rv
;
}
void
free_
(
void
*
aPtr
)
{
free
(
aPtr
)
;
}
void
reportAllocOverflow
(
)
const
{
}
bool
checkSimulatedOOM
(
)
const
{
return
true
;
}
}
;
typedef
mozilla
:
:
BufferList
<
InfallibleAllocPolicy
>
BufferList
;
int
main
(
void
)
{
const
size_t
kInitialSize
=
16
;
const
size_t
kInitialCapacity
=
24
;
const
size_t
kStandardCapacity
=
32
;
BufferList
bl
(
kInitialSize
kInitialCapacity
kStandardCapacity
)
;
memset
(
bl
.
Start
(
)
0x0c
kInitialSize
)
;
MOZ_RELEASE_ASSERT
(
bl
.
Size
(
)
=
=
kInitialSize
)
;
BufferList
:
:
IterImpl
iter
(
bl
.
Iter
(
)
)
;
MOZ_RELEASE_ASSERT
(
iter
.
RemainingInSegment
(
)
=
=
kInitialSize
)
;
MOZ_RELEASE_ASSERT
(
iter
.
HasRoomFor
(
kInitialSize
)
)
;
MOZ_RELEASE_ASSERT
(
!
iter
.
HasRoomFor
(
kInitialSize
+
1
)
)
;
MOZ_RELEASE_ASSERT
(
!
iter
.
HasRoomFor
(
size_t
(
-
1
)
)
)
;
MOZ_RELEASE_ASSERT
(
*
iter
.
Data
(
)
=
=
0x0c
)
;
MOZ_RELEASE_ASSERT
(
!
iter
.
Done
(
)
)
;
iter
.
Advance
(
bl
4
)
;
MOZ_RELEASE_ASSERT
(
iter
.
RemainingInSegment
(
)
=
=
kInitialSize
-
4
)
;
MOZ_RELEASE_ASSERT
(
iter
.
HasRoomFor
(
kInitialSize
-
4
)
)
;
MOZ_RELEASE_ASSERT
(
*
iter
.
Data
(
)
=
=
0x0c
)
;
MOZ_RELEASE_ASSERT
(
!
iter
.
Done
(
)
)
;
iter
.
Advance
(
bl
11
)
;
MOZ_RELEASE_ASSERT
(
iter
.
RemainingInSegment
(
)
=
=
kInitialSize
-
4
-
11
)
;
MOZ_RELEASE_ASSERT
(
iter
.
HasRoomFor
(
kInitialSize
-
4
-
11
)
)
;
MOZ_RELEASE_ASSERT
(
!
iter
.
HasRoomFor
(
kInitialSize
-
4
-
11
+
1
)
)
;
MOZ_RELEASE_ASSERT
(
*
iter
.
Data
(
)
=
=
0x0c
)
;
MOZ_RELEASE_ASSERT
(
!
iter
.
Done
(
)
)
;
iter
.
Advance
(
bl
kInitialSize
-
4
-
11
)
;
MOZ_RELEASE_ASSERT
(
iter
.
RemainingInSegment
(
)
=
=
0
)
;
MOZ_RELEASE_ASSERT
(
!
iter
.
HasRoomFor
(
1
)
)
;
MOZ_RELEASE_ASSERT
(
iter
.
Done
(
)
)
;
const
size_t
kSmallWrite
=
16
;
char
toWrite
[
kSmallWrite
]
;
memset
(
toWrite
0x0a
kSmallWrite
)
;
bl
.
WriteBytes
(
toWrite
kSmallWrite
)
;
MOZ_RELEASE_ASSERT
(
bl
.
Size
(
)
=
=
kInitialSize
+
kSmallWrite
)
;
iter
=
bl
.
Iter
(
)
;
iter
.
Advance
(
bl
kInitialSize
)
;
MOZ_RELEASE_ASSERT
(
!
iter
.
Done
(
)
)
;
MOZ_RELEASE_ASSERT
(
iter
.
RemainingInSegment
(
)
=
=
kInitialCapacity
-
kInitialSize
)
;
MOZ_RELEASE_ASSERT
(
iter
.
HasRoomFor
(
kInitialCapacity
-
kInitialSize
)
)
;
MOZ_RELEASE_ASSERT
(
*
iter
.
Data
(
)
=
=
0x0a
)
;
iter
=
bl
.
Iter
(
)
;
MOZ_RELEASE_ASSERT
(
iter
.
AdvanceAcrossSegments
(
bl
kInitialCapacity
-
4
)
)
;
MOZ_RELEASE_ASSERT
(
!
iter
.
Done
(
)
)
;
MOZ_RELEASE_ASSERT
(
iter
.
RemainingInSegment
(
)
=
=
4
)
;
MOZ_RELEASE_ASSERT
(
iter
.
HasRoomFor
(
4
)
)
;
MOZ_RELEASE_ASSERT
(
*
iter
.
Data
(
)
=
=
0x0a
)
;
iter
=
bl
.
Iter
(
)
;
MOZ_RELEASE_ASSERT
(
iter
.
AdvanceAcrossSegments
(
bl
kInitialSize
+
kSmallWrite
-
4
)
)
;
MOZ_RELEASE_ASSERT
(
!
iter
.
Done
(
)
)
;
MOZ_RELEASE_ASSERT
(
iter
.
RemainingInSegment
(
)
=
=
4
)
;
MOZ_RELEASE_ASSERT
(
iter
.
HasRoomFor
(
4
)
)
;
MOZ_RELEASE_ASSERT
(
*
iter
.
Data
(
)
=
=
0x0a
)
;
MOZ_RELEASE_ASSERT
(
bl
.
Iter
(
)
.
AdvanceAcrossSegments
(
bl
kInitialSize
+
kSmallWrite
-
1
)
)
;
MOZ_RELEASE_ASSERT
(
bl
.
Iter
(
)
.
AdvanceAcrossSegments
(
bl
kInitialSize
+
kSmallWrite
)
)
;
MOZ_RELEASE_ASSERT
(
!
bl
.
Iter
(
)
.
AdvanceAcrossSegments
(
bl
kInitialSize
+
kSmallWrite
+
1
)
)
;
MOZ_RELEASE_ASSERT
(
!
bl
.
Iter
(
)
.
AdvanceAcrossSegments
(
bl
size_t
(
-
1
)
)
)
;
char
toRead
[
kSmallWrite
]
;
iter
=
bl
.
Iter
(
)
;
iter
.
Advance
(
bl
kInitialSize
)
;
bl
.
ReadBytes
(
iter
toRead
kSmallWrite
)
;
MOZ_RELEASE_ASSERT
(
memcmp
(
toRead
toWrite
kSmallWrite
)
=
=
0
)
;
MOZ_RELEASE_ASSERT
(
iter
.
Done
(
)
)
;
iter
=
bl
.
Iter
(
)
;
bl
.
ReadBytes
(
iter
toRead
kInitialSize
)
;
MOZ_RELEASE_ASSERT
(
!
iter
.
Done
(
)
)
;
MOZ_RELEASE_ASSERT
(
iter
.
RemainingInSegment
(
)
=
=
kInitialCapacity
-
kInitialSize
)
;
const
size_t
kBigWrite
=
1024
;
char
*
toWriteBig
=
static_cast
<
char
*
>
(
malloc
(
kBigWrite
)
)
;
for
(
unsigned
i
=
0
;
i
<
kBigWrite
;
i
+
+
)
{
toWriteBig
[
i
]
=
i
%
37
;
}
bl
.
WriteBytes
(
toWriteBig
kBigWrite
)
;
char
*
toReadBig
=
static_cast
<
char
*
>
(
malloc
(
kBigWrite
)
)
;
iter
=
bl
.
Iter
(
)
;
MOZ_RELEASE_ASSERT
(
iter
.
AdvanceAcrossSegments
(
bl
kInitialSize
+
kSmallWrite
)
)
;
bl
.
ReadBytes
(
iter
toReadBig
kBigWrite
)
;
MOZ_RELEASE_ASSERT
(
memcmp
(
toReadBig
toWriteBig
kBigWrite
)
=
=
0
)
;
MOZ_RELEASE_ASSERT
(
iter
.
Done
(
)
)
;
free
(
toReadBig
)
;
free
(
toWriteBig
)
;
static
size_t
kTotalSize
=
kInitialSize
+
kSmallWrite
+
kBigWrite
;
MOZ_RELEASE_ASSERT
(
bl
.
Size
(
)
=
=
kTotalSize
)
;
static
size_t
kLastSegmentSize
=
(
kTotalSize
-
kInitialCapacity
)
%
kStandardCapacity
;
iter
=
bl
.
Iter
(
)
;
MOZ_RELEASE_ASSERT
(
iter
.
AdvanceAcrossSegments
(
bl
kTotalSize
-
kLastSegmentSize
-
kStandardCapacity
)
)
;
MOZ_RELEASE_ASSERT
(
iter
.
RemainingInSegment
(
)
=
=
kStandardCapacity
)
;
iter
.
Advance
(
bl
kStandardCapacity
)
;
MOZ_RELEASE_ASSERT
(
iter
.
RemainingInSegment
(
)
=
=
kLastSegmentSize
)
;
MOZ_RELEASE_ASSERT
(
unsigned
(
*
iter
.
Data
(
)
)
=
=
(
kTotalSize
-
kLastSegmentSize
-
kInitialSize
-
kSmallWrite
)
%
37
)
;
const
size_t
kFlattenSize
=
1000
;
const
char
*
flat
;
iter
=
bl
.
Iter
(
)
;
MOZ_RELEASE_ASSERT
(
iter
.
AdvanceAcrossSegments
(
bl
kInitialSize
)
)
;
MOZ_RELEASE_ASSERT
(
bl
.
FlattenBytes
(
iter
&
flat
kFlattenSize
)
)
;
MOZ_RELEASE_ASSERT
(
flat
[
0
]
=
=
0x0a
)
;
MOZ_RELEASE_ASSERT
(
flat
[
kSmallWrite
/
2
]
=
=
0x0a
)
;
for
(
size_t
i
=
kSmallWrite
;
i
<
kFlattenSize
;
i
+
+
)
{
MOZ_RELEASE_ASSERT
(
unsigned
(
flat
[
i
]
)
=
=
(
i
-
kSmallWrite
)
%
37
)
;
}
MOZ_RELEASE_ASSERT
(
unsigned
(
*
iter
.
Data
(
)
)
=
=
(
kFlattenSize
-
kSmallWrite
)
%
37
)
;
const
size_t
kSecondFlattenSize
=
40
;
MOZ_RELEASE_ASSERT
(
bl
.
FlattenBytes
(
iter
&
flat
kSecondFlattenSize
)
)
;
for
(
size_t
i
=
0
;
i
<
kSecondFlattenSize
;
i
+
+
)
{
MOZ_RELEASE_ASSERT
(
unsigned
(
flat
[
i
]
)
=
=
(
i
+
kFlattenSize
-
kInitialSize
)
%
37
)
;
}
MOZ_RELEASE_ASSERT
(
iter
.
Done
(
)
)
;
bl
.
Clear
(
)
;
MOZ_RELEASE_ASSERT
(
bl
.
Size
(
)
=
=
0
)
;
MOZ_RELEASE_ASSERT
(
bl
.
Iter
(
)
.
Done
(
)
)
;
const
size_t
kSmallCapacity
=
8
;
BufferList
bl2
(
0
kSmallCapacity
kSmallCapacity
)
;
bl2
.
WriteBytes
(
toWrite
kSmallWrite
)
;
bl2
.
WriteBytes
(
toWrite
kSmallWrite
)
;
bl2
.
WriteBytes
(
toWrite
kSmallWrite
)
;
bl
=
mozilla
:
:
Move
(
bl2
)
;
MOZ_RELEASE_ASSERT
(
bl2
.
Size
(
)
=
=
0
)
;
MOZ_RELEASE_ASSERT
(
bl2
.
Iter
(
)
.
Done
(
)
)
;
iter
=
bl
.
Iter
(
)
;
MOZ_RELEASE_ASSERT
(
iter
.
AdvanceAcrossSegments
(
bl
kSmallWrite
*
3
)
)
;
MOZ_RELEASE_ASSERT
(
iter
.
Done
(
)
)
;
const
size_t
kBorrowStart
=
4
;
const
size_t
kBorrowSize
=
24
;
iter
=
bl
.
Iter
(
)
;
iter
.
Advance
(
bl
kBorrowStart
)
;
bool
success
;
bl2
=
bl
.
Borrow
<
InfallibleAllocPolicy
>
(
iter
kBorrowSize
&
success
)
;
MOZ_RELEASE_ASSERT
(
success
)
;
MOZ_RELEASE_ASSERT
(
bl2
.
Size
(
)
=
=
kBorrowSize
)
;
MOZ_RELEASE_ASSERT
(
iter
.
AdvanceAcrossSegments
(
bl
kSmallWrite
*
3
-
kBorrowSize
-
kBorrowStart
)
)
;
MOZ_RELEASE_ASSERT
(
iter
.
Done
(
)
)
;
iter
=
bl2
.
Iter
(
)
;
MOZ_RELEASE_ASSERT
(
iter
.
AdvanceAcrossSegments
(
bl2
kBorrowSize
)
)
;
MOZ_RELEASE_ASSERT
(
iter
.
Done
(
)
)
;
BufferList
:
:
IterImpl
iter1
(
bl
.
Iter
(
)
)
iter2
(
bl2
.
Iter
(
)
)
;
iter1
.
Advance
(
bl
kBorrowStart
)
;
MOZ_RELEASE_ASSERT
(
iter1
.
Data
(
)
=
=
iter2
.
Data
(
)
)
;
MOZ_RELEASE_ASSERT
(
iter1
.
AdvanceAcrossSegments
(
bl
kBorrowSize
-
5
)
)
;
MOZ_RELEASE_ASSERT
(
iter2
.
AdvanceAcrossSegments
(
bl2
kBorrowSize
-
5
)
)
;
MOZ_RELEASE_ASSERT
(
iter1
.
Data
(
)
=
=
iter2
.
Data
(
)
)
;
return
0
;
}
