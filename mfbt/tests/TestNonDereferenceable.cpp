#
include
"
mozilla
/
NonDereferenceable
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Move
.
h
"
using
mozilla
:
:
NonDereferenceable
;
#
define
CHECK
MOZ_RELEASE_ASSERT
void
TestNonDereferenceableSimple
(
)
{
NonDereferenceable
<
int
>
nd0
;
CHECK
(
!
nd0
)
;
CHECK
(
!
nd0
.
value
(
)
)
;
int
i
=
1
;
int
i2
=
2
;
NonDereferenceable
<
int
>
nd1
(
&
i
)
;
CHECK
(
!
!
nd1
)
;
CHECK
(
nd1
.
value
(
)
=
=
reinterpret_cast
<
uintptr_t
>
(
&
i
)
)
;
nd1
=
&
i2
;
CHECK
(
nd1
.
value
(
)
=
=
reinterpret_cast
<
uintptr_t
>
(
&
i2
)
)
;
NonDereferenceable
<
int
>
nd2
(
nd1
)
;
CHECK
(
nd2
.
value
(
)
=
=
reinterpret_cast
<
uintptr_t
>
(
&
i2
)
)
;
nd2
=
nd0
;
CHECK
(
!
nd2
.
value
(
)
)
;
NonDereferenceable
<
int
>
nd3
{
NonDereferenceable
<
int
>
(
&
i
)
}
;
CHECK
(
nd3
.
value
(
)
=
=
reinterpret_cast
<
uintptr_t
>
(
&
i
)
)
;
nd3
=
std
:
:
move
(
nd1
)
;
CHECK
(
nd3
.
value
(
)
=
=
reinterpret_cast
<
uintptr_t
>
(
&
i2
)
)
;
nd1
=
&
i
;
CHECK
(
nd1
.
value
(
)
=
=
reinterpret_cast
<
uintptr_t
>
(
&
i
)
)
;
}
void
TestNonDereferenceableHierarchy
(
)
{
struct
Base1
{
int
x1
;
}
;
struct
Base2
{
int
x2
;
}
;
struct
Derived
:
Base1
Base2
{
}
;
Derived
d
;
NonDereferenceable
<
Derived
>
ndd
=
NonDereferenceable
<
Derived
>
(
&
d
)
;
CHECK
(
ndd
)
;
CHECK
(
ndd
.
value
(
)
=
=
reinterpret_cast
<
uintptr_t
>
(
&
d
)
)
;
NonDereferenceable
<
Base1
>
ndb1
=
ndd
;
CHECK
(
ndb1
)
;
CHECK
(
ndb1
.
value
(
)
=
=
reinterpret_cast
<
uintptr_t
>
(
static_cast
<
Base1
*
>
(
&
d
)
)
)
;
NonDereferenceable
<
Derived
>
nddb1
=
ndb1
;
CHECK
(
nddb1
.
value
(
)
=
=
reinterpret_cast
<
uintptr_t
>
(
&
d
)
)
;
NonDereferenceable
<
Base2
>
ndb2
=
ndd
;
CHECK
(
ndb2
)
;
CHECK
(
ndb2
.
value
(
)
=
=
reinterpret_cast
<
uintptr_t
>
(
static_cast
<
Base2
*
>
(
&
d
)
)
)
;
CHECK
(
ndb2
.
value
(
)
!
=
ndd
.
value
(
)
)
;
NonDereferenceable
<
Derived
>
nddb2
=
ndb2
;
CHECK
(
nddb2
.
value
(
)
=
=
reinterpret_cast
<
uintptr_t
>
(
&
d
)
)
;
NonDereferenceable
<
Base2
>
ndb22
=
NonDereferenceable
<
Derived
>
(
ndb1
)
;
CHECK
(
ndb22
.
value
(
)
=
=
reinterpret_cast
<
uintptr_t
>
(
static_cast
<
Base2
*
>
(
&
d
)
)
)
;
ndd
=
nullptr
;
CHECK
(
!
ndd
)
;
CHECK
(
!
ndd
.
value
(
)
)
;
ndb1
=
ndd
;
CHECK
(
!
ndb1
)
;
CHECK
(
!
ndb1
.
value
(
)
)
;
ndb2
=
ndd
;
CHECK
(
!
ndb2
)
;
CHECK
(
!
ndb2
.
value
(
)
)
;
nddb2
=
ndb2
;
CHECK
(
!
nddb2
)
;
CHECK
(
!
nddb2
.
value
(
)
)
;
}
template
<
typename
T
size_t
Index
>
struct
CRTPBase
{
CRTPBase
(
)
:
mDerived
(
this
)
{
}
NonDereferenceable
<
T
>
mDerived
;
}
;
void
TestNonDereferenceableCRTP
(
)
{
struct
Derived
:
CRTPBase
<
Derived
1
>
CRTPBase
<
Derived
2
>
{
}
;
using
Base1
=
Derived
:
:
CRTPBase
<
Derived
1
>
;
using
Base2
=
Derived
:
:
CRTPBase
<
Derived
2
>
;
Derived
d
;
CHECK
(
d
.
Base1
:
:
mDerived
.
value
(
)
=
=
reinterpret_cast
<
uintptr_t
>
(
&
d
)
)
;
CHECK
(
d
.
Base2
:
:
mDerived
.
value
(
)
=
=
reinterpret_cast
<
uintptr_t
>
(
&
d
)
)
;
NonDereferenceable
<
Derived
>
ndd
=
NonDereferenceable
<
Derived
>
(
&
d
)
;
CHECK
(
ndd
)
;
CHECK
(
ndd
.
value
(
)
=
=
reinterpret_cast
<
uintptr_t
>
(
&
d
)
)
;
NonDereferenceable
<
Base1
>
ndb1
=
ndd
;
CHECK
(
ndb1
)
;
CHECK
(
ndb1
.
value
(
)
=
=
reinterpret_cast
<
uintptr_t
>
(
static_cast
<
Base1
*
>
(
&
d
)
)
)
;
NonDereferenceable
<
Derived
>
nddb1
=
ndb1
;
CHECK
(
nddb1
.
value
(
)
=
=
reinterpret_cast
<
uintptr_t
>
(
&
d
)
)
;
NonDereferenceable
<
Base2
>
ndb2
=
ndd
;
CHECK
(
ndb2
)
;
CHECK
(
ndb2
.
value
(
)
=
=
reinterpret_cast
<
uintptr_t
>
(
static_cast
<
Base2
*
>
(
&
d
)
)
)
;
CHECK
(
ndb2
.
value
(
)
!
=
ndd
.
value
(
)
)
;
NonDereferenceable
<
Derived
>
nddb2
=
ndb2
;
CHECK
(
nddb2
.
value
(
)
=
=
reinterpret_cast
<
uintptr_t
>
(
&
d
)
)
;
NonDereferenceable
<
Base2
>
ndb22
=
NonDereferenceable
<
Derived
>
(
ndb1
)
;
CHECK
(
ndb22
.
value
(
)
=
=
reinterpret_cast
<
uintptr_t
>
(
static_cast
<
Base2
*
>
(
&
d
)
)
)
;
}
int
main
(
)
{
TestNonDereferenceableSimple
(
)
;
TestNonDereferenceableHierarchy
(
)
;
TestNonDereferenceableCRTP
(
)
;
return
0
;
}
