#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
FastBernoulliTrial
.
h
"
#
include
<
math
.
h
>
static
void
TestProportions
(
)
{
mozilla
:
:
FastBernoulliTrial
bernoulli
(
1
.
0
698079309544035222ULL
6012389156611637584ULL
)
;
for
(
size_t
i
=
0
;
i
<
100
;
i
+
+
)
MOZ_RELEASE_ASSERT
(
bernoulli
.
trial
(
)
)
;
{
bernoulli
.
setProbability
(
0
.
5
)
;
size_t
count
=
0
;
for
(
size_t
i
=
0
;
i
<
1000
;
i
+
+
)
count
+
=
bernoulli
.
trial
(
)
;
MOZ_RELEASE_ASSERT
(
count
=
=
496
)
;
}
{
bernoulli
.
setProbability
(
0
.
001
)
;
size_t
count
=
0
;
for
(
size_t
i
=
0
;
i
<
1000
;
i
+
+
)
count
+
=
bernoulli
.
trial
(
)
;
MOZ_RELEASE_ASSERT
(
count
=
=
2
)
;
}
{
bernoulli
.
setProbability
(
0
.
85
)
;
size_t
count
=
0
;
for
(
size_t
i
=
0
;
i
<
1000
;
i
+
+
)
count
+
=
bernoulli
.
trial
(
)
;
MOZ_RELEASE_ASSERT
(
count
=
=
852
)
;
}
bernoulli
.
setProbability
(
0
.
0
)
;
for
(
size_t
i
=
0
;
i
<
100
;
i
+
+
)
MOZ_RELEASE_ASSERT
(
!
bernoulli
.
trial
(
)
)
;
}
static
void
TestHarmonics
(
)
{
mozilla
:
:
FastBernoulliTrial
bernoulli
(
0
.
1
698079309544035222ULL
6012389156611637584ULL
)
;
const
size_t
n
=
100000
;
bool
trials
[
n
]
;
for
(
size_t
i
=
0
;
i
<
n
;
i
+
+
)
trials
[
i
]
=
bernoulli
.
trial
(
)
;
for
(
size_t
harmonic
=
1
;
harmonic
<
20
;
harmonic
+
+
)
{
size_t
expected
=
n
/
harmonic
/
10
;
size_t
low_expected
=
expected
*
85
/
100
;
size_t
high_expected
=
expected
*
115
/
100
;
for
(
size_t
phase
=
0
;
phase
<
harmonic
;
phase
+
+
)
{
size_t
count
=
0
;
for
(
size_t
i
=
phase
;
i
<
n
;
i
+
=
harmonic
)
count
+
=
trials
[
i
]
;
MOZ_RELEASE_ASSERT
(
low_expected
<
=
count
&
&
count
<
=
high_expected
)
;
}
}
}
static
void
TestTrialN
(
)
{
mozilla
:
:
FastBernoulliTrial
bernoulli
(
0
.
01
0x67ff17e25d855942ULL
0x74f298193fe1c5b1ULL
)
;
{
size_t
count
=
0
;
for
(
size_t
i
=
0
;
i
<
10000
;
i
+
+
)
count
+
=
bernoulli
.
trial
(
1
)
;
MOZ_RELEASE_ASSERT
(
count
=
=
97
)
;
}
{
size_t
count
=
0
;
for
(
size_t
i
=
0
;
i
<
10000
;
i
+
+
)
count
+
=
bernoulli
.
trial
(
3
)
;
MOZ_RELEASE_ASSERT
(
count
=
=
304
)
;
}
{
size_t
count
=
0
;
for
(
size_t
i
=
0
;
i
<
10000
;
i
+
+
)
count
+
=
bernoulli
.
trial
(
10
)
;
MOZ_RELEASE_ASSERT
(
count
=
=
936
)
;
}
{
size_t
count
=
0
;
for
(
size_t
i
=
0
;
i
<
10000
;
i
+
+
)
count
+
=
bernoulli
.
trial
(
100
)
;
MOZ_RELEASE_ASSERT
(
count
=
=
6372
)
;
}
{
size_t
count
=
0
;
for
(
size_t
i
=
0
;
i
<
10000
;
i
+
+
)
count
+
=
bernoulli
.
trial
(
1000
)
;
MOZ_RELEASE_ASSERT
(
count
=
=
9998
)
;
}
}
static
void
TestChangeProbability
(
)
{
mozilla
:
:
FastBernoulliTrial
bernoulli
(
1
.
0
0x67ff17e25d855942ULL
0x74f298193fe1c5b1ULL
)
;
bernoulli
.
setProbability
(
0
.
0
)
;
bernoulli
.
setProbability
(
1
.
0
)
;
MOZ_RELEASE_ASSERT
(
bernoulli
.
trial
(
)
)
;
}
static
void
TestCuspProbabilities
(
)
{
mozilla
:
:
FastBernoulliTrial
bernoulli
(
nextafter
(
1
0
)
0x67ff17e25d855942ULL
0x74f298193fe1c5b1ULL
)
;
for
(
size_t
i
=
0
;
i
<
1000
;
i
+
+
)
MOZ_RELEASE_ASSERT
(
bernoulli
.
trial
(
)
)
;
bernoulli
.
setProbability
(
nextafter
(
0
1
)
)
;
for
(
size_t
i
=
0
;
i
<
1000
;
i
+
+
)
MOZ_RELEASE_ASSERT
(
!
bernoulli
.
trial
(
)
)
;
bernoulli
.
setProbability
(
1
-
nextafter
(
1
0
)
)
;
for
(
size_t
i
=
0
;
i
<
1000
;
i
+
+
)
MOZ_RELEASE_ASSERT
(
!
bernoulli
.
trial
(
)
)
;
}
int
main
(
)
{
TestProportions
(
)
;
TestHarmonics
(
)
;
TestTrialN
(
)
;
TestChangeProbability
(
)
;
TestCuspProbabilities
(
)
;
return
0
;
}
