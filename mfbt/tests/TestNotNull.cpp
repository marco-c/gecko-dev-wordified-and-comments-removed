#
include
"
mozilla
/
NotNull
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
using
mozilla
:
:
WrapNotNull
;
using
mozilla
:
:
MakeUnique
;
using
mozilla
:
:
NotNull
;
using
mozilla
:
:
UniquePtr
;
#
define
CHECK
MOZ_RELEASE_ASSERT
class
Blah
{
public
:
Blah
(
)
:
mX
(
0
)
{
}
void
blah
(
)
{
}
;
int
mX
;
}
;
template
<
typename
T
>
class
MyPtr
{
T
*
mRawPtr
;
public
:
MyPtr
(
)
:
mRawPtr
(
nullptr
)
{
}
MOZ_IMPLICIT
MyPtr
(
T
*
aRawPtr
)
:
mRawPtr
(
aRawPtr
)
{
}
T
*
get
(
)
const
{
return
mRawPtr
;
}
operator
T
*
(
)
const
{
return
get
(
)
;
}
T
*
operator
-
>
(
)
const
{
return
get
(
)
;
}
}
;
class
MyRefType
{
int
mExpectedMaxRefCnt
;
int
mMaxRefCnt
;
int
mRefCnt
;
public
:
explicit
MyRefType
(
int
aExpectedMaxRefCnt
)
:
mExpectedMaxRefCnt
(
aExpectedMaxRefCnt
)
mMaxRefCnt
(
0
)
mRefCnt
(
0
)
{
}
~
MyRefType
(
)
{
CHECK
(
mMaxRefCnt
=
=
mExpectedMaxRefCnt
)
;
}
uint32_t
AddRef
(
)
{
mRefCnt
+
+
;
if
(
mRefCnt
>
mMaxRefCnt
)
{
mMaxRefCnt
=
mRefCnt
;
}
return
mRefCnt
;
}
uint32_t
Release
(
)
{
CHECK
(
mRefCnt
>
0
)
;
mRefCnt
-
-
;
if
(
mRefCnt
=
=
0
)
{
delete
this
;
return
0
;
}
return
mRefCnt
;
}
}
;
void
f_i
(
int
*
aPtr
)
{
}
void
f_my
(
MyPtr
<
int
>
aPtr
)
{
}
void
f_nni
(
NotNull
<
int
*
>
aPtr
)
{
}
void
f_nnmy
(
NotNull
<
MyPtr
<
int
>
>
aPtr
)
{
}
void
TestNotNullWithMyPtr
(
)
{
int
i4
=
4
;
int
i5
=
5
;
MyPtr
<
int
>
my4
=
&
i4
;
MyPtr
<
int
>
my5
=
&
i5
;
NotNull
<
int
*
>
nni4
=
WrapNotNull
(
&
i4
)
;
NotNull
<
int
*
>
nni5
=
WrapNotNull
(
&
i5
)
;
NotNull
<
MyPtr
<
int
>
>
nnmy4
=
WrapNotNull
(
my4
)
;
NotNull
<
int
*
>
nni4b
(
WrapNotNull
(
&
i4
)
)
;
NotNull
<
int
*
>
nni4c
(
WrapNotNull
(
my4
)
)
;
NotNull
<
int
*
>
nni4d
(
nni4
)
;
NotNull
<
int
*
>
nni4e
(
nnmy4
)
;
CHECK
(
*
nni4b
=
=
4
)
;
CHECK
(
*
nni4c
=
=
4
)
;
CHECK
(
*
nni4d
=
=
4
)
;
CHECK
(
*
nni4e
=
=
4
)
;
NotNull
<
MyPtr
<
int
>
>
nnmy4b
(
WrapNotNull
(
&
i4
)
)
;
NotNull
<
MyPtr
<
int
>
>
nnmy4c
(
WrapNotNull
(
my4
)
)
;
NotNull
<
MyPtr
<
int
>
>
nnmy4d
(
nni4
)
;
NotNull
<
MyPtr
<
int
>
>
nnmy4e
(
nnmy4
)
;
CHECK
(
*
nnmy4b
=
=
4
)
;
CHECK
(
*
nnmy4c
=
=
4
)
;
CHECK
(
*
nnmy4d
=
=
4
)
;
CHECK
(
*
nnmy4e
=
=
4
)
;
nni4b
=
WrapNotNull
(
&
i4
)
;
nni4c
=
WrapNotNull
(
my4
)
;
nni4d
=
nni4
;
nni4e
=
nnmy4
;
CHECK
(
*
nni4b
=
=
4
)
;
CHECK
(
*
nni4c
=
=
4
)
;
CHECK
(
*
nni4d
=
=
4
)
;
CHECK
(
*
nni4e
=
=
4
)
;
nnmy4b
=
WrapNotNull
(
&
i4
)
;
nnmy4c
=
WrapNotNull
(
my4
)
;
nnmy4d
=
nni4
;
nnmy4e
=
nnmy4
;
CHECK
(
*
nnmy4b
=
=
4
)
;
CHECK
(
*
nnmy4c
=
=
4
)
;
CHECK
(
*
nnmy4d
=
=
4
)
;
CHECK
(
*
nnmy4e
=
=
4
)
;
NotNull
<
MyPtr
<
int
>
>
nnmy5
=
WrapNotNull
(
&
i5
)
;
CHECK
(
*
nnmy5
=
=
5
)
;
CHECK
(
nnmy5
=
=
&
i5
)
;
CHECK
(
nnmy5
=
=
my5
)
;
CHECK
(
nnmy5
=
=
nni5
)
;
CHECK
(
nnmy5
=
=
nnmy5
)
;
CHECK
(
&
i5
=
=
nnmy5
)
;
CHECK
(
my5
=
=
nnmy5
)
;
CHECK
(
nni5
=
=
nnmy5
)
;
CHECK
(
nnmy5
=
=
nnmy5
)
;
CHECK
(
*
nnmy5
=
=
5
)
;
CHECK
(
nnmy5
!
=
&
i4
)
;
CHECK
(
nnmy5
!
=
my4
)
;
CHECK
(
nnmy5
!
=
nni4
)
;
CHECK
(
nnmy5
!
=
nnmy4
)
;
CHECK
(
&
i4
!
=
nnmy5
)
;
CHECK
(
my4
!
=
nnmy5
)
;
CHECK
(
nni4
!
=
nnmy5
)
;
CHECK
(
nnmy4
!
=
nnmy5
)
;
f_i
(
&
i4
)
;
f_i
(
my4
)
;
f_i
(
my4
.
get
(
)
)
;
f_i
(
nni4
)
;
f_i
(
nni4
.
get
(
)
)
;
f_i
(
nnmy4
.
get
(
)
)
;
f_i
(
nnmy4
.
get
(
)
.
get
(
)
)
;
f_my
(
&
i4
)
;
f_my
(
my4
)
;
f_my
(
my4
.
get
(
)
)
;
f_my
(
nni4
.
get
(
)
)
;
f_my
(
nnmy4
)
;
f_my
(
nnmy4
.
get
(
)
)
;
f_my
(
nnmy4
.
get
(
)
.
get
(
)
)
;
f_nni
(
nni4
)
;
f_nni
(
nnmy4
)
;
f_nnmy
(
nni4
)
;
f_nnmy
(
nnmy4
)
;
Blah
blah
;
MyPtr
<
Blah
>
myblah
=
&
blah
;
NotNull
<
Blah
*
>
nnblah
=
WrapNotNull
(
&
blah
)
;
NotNull
<
MyPtr
<
Blah
>
>
nnmyblah
=
WrapNotNull
(
myblah
)
;
(
&
blah
)
-
>
blah
(
)
;
myblah
-
>
blah
(
)
;
nnblah
-
>
blah
(
)
;
nnmyblah
-
>
blah
(
)
;
(
&
blah
)
-
>
mX
=
1
;
CHECK
(
(
&
blah
)
-
>
mX
=
=
1
)
;
myblah
-
>
mX
=
2
;
CHECK
(
myblah
-
>
mX
=
=
2
)
;
nnblah
-
>
mX
=
3
;
CHECK
(
nnblah
-
>
mX
=
=
3
)
;
nnmyblah
-
>
mX
=
4
;
CHECK
(
nnmyblah
-
>
mX
=
=
4
)
;
*
(
&
i4
)
=
7
;
CHECK
(
*
(
&
i4
)
=
=
7
)
;
*
my4
=
6
;
CHECK
(
*
my4
=
=
6
)
;
*
nni4
=
5
;
CHECK
(
*
nni4
=
=
5
)
;
*
nnmy4
=
4
;
CHECK
(
*
nnmy4
=
=
4
)
;
static
const
int
N
=
20
;
int
a
[
N
]
;
NotNull
<
int
*
>
nna
=
WrapNotNull
(
a
)
;
for
(
int
i
=
0
;
i
<
N
;
i
+
+
)
{
nna
[
i
]
=
i
;
}
for
(
int
i
=
0
;
i
<
N
;
i
+
+
)
{
nna
[
i
]
*
=
2
;
}
for
(
int
i
=
0
;
i
<
N
;
i
+
+
)
{
CHECK
(
nna
[
i
]
=
=
i
*
2
)
;
}
}
void
f_ref
(
NotNull
<
MyRefType
*
>
aR
)
{
NotNull
<
RefPtr
<
MyRefType
>
>
r
=
aR
;
}
void
TestNotNullWithRefPtr
(
)
{
NotNull
<
RefPtr
<
MyRefType
>
>
r1
=
WrapNotNull
(
new
MyRefType
(
5
)
)
;
NotNull
<
RefPtr
<
MyRefType
>
>
r2
=
r1
;
NotNull
<
MyRefType
*
>
r3
=
r2
;
(
void
)
r3
;
RefPtr
<
MyRefType
>
r4
=
r2
;
RefPtr
<
MyRefType
>
r5
=
r3
.
get
(
)
;
f_ref
(
r2
)
;
}
int
main
(
)
{
TestNotNullWithMyPtr
(
)
;
TestNotNullWithRefPtr
(
)
;
return
0
;
}
