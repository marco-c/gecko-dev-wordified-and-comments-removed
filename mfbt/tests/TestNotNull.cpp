#
include
<
type_traits
>
#
include
"
mozilla
/
NotNull
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
using
mozilla
:
:
MakeNotNull
;
using
mozilla
:
:
NotNull
;
using
mozilla
:
:
UniquePtr
;
using
mozilla
:
:
WrapNotNull
;
#
define
CHECK
MOZ_RELEASE_ASSERT
class
Blah
{
public
:
Blah
(
)
:
mX
(
0
)
{
}
void
blah
(
)
{
}
;
int
mX
;
}
;
template
<
typename
T
>
class
MyPtr
{
T
*
mRawPtr
;
public
:
MyPtr
(
)
:
mRawPtr
(
nullptr
)
{
}
MOZ_IMPLICIT
MyPtr
(
T
*
aRawPtr
)
:
mRawPtr
(
aRawPtr
)
{
}
T
*
get
(
)
const
{
return
mRawPtr
;
}
operator
T
*
(
)
const
{
return
get
(
)
;
}
T
*
operator
-
>
(
)
const
{
return
get
(
)
;
}
}
;
class
MyRefType
{
int
mExpectedMaxRefCnt
;
int
mMaxRefCnt
;
int
mRefCnt
;
public
:
explicit
MyRefType
(
int
aExpectedMaxRefCnt
)
:
mExpectedMaxRefCnt
(
aExpectedMaxRefCnt
)
mMaxRefCnt
(
0
)
mRefCnt
(
0
)
{
}
~
MyRefType
(
)
{
CHECK
(
mMaxRefCnt
=
=
mExpectedMaxRefCnt
)
;
}
uint32_t
AddRef
(
)
{
mRefCnt
+
+
;
if
(
mRefCnt
>
mMaxRefCnt
)
{
mMaxRefCnt
=
mRefCnt
;
}
return
mRefCnt
;
}
uint32_t
Release
(
)
{
CHECK
(
mRefCnt
>
0
)
;
mRefCnt
-
-
;
if
(
mRefCnt
=
=
0
)
{
delete
this
;
return
0
;
}
return
mRefCnt
;
}
}
;
void
f_i
(
int
*
aPtr
)
{
}
void
f_my
(
MyPtr
<
int
>
aPtr
)
{
}
void
f_nni
(
NotNull
<
int
*
>
aPtr
)
{
}
void
f_nnmy
(
NotNull
<
MyPtr
<
int
>
>
aPtr
)
{
}
void
TestNotNullWithMyPtr
(
)
{
int
i4
=
4
;
int
i5
=
5
;
MyPtr
<
int
>
my4
=
&
i4
;
MyPtr
<
int
>
my5
=
&
i5
;
NotNull
<
int
*
>
nni4
=
WrapNotNull
(
&
i4
)
;
NotNull
<
int
*
>
nni5
=
WrapNotNull
(
&
i5
)
;
NotNull
<
MyPtr
<
int
>
>
nnmy4
=
WrapNotNull
(
my4
)
;
NotNull
<
int
*
>
nni4b
(
WrapNotNull
(
&
i4
)
)
;
NotNull
<
int
*
>
nni4c
(
WrapNotNull
(
my4
)
)
;
NotNull
<
int
*
>
nni4d
(
nni4
)
;
NotNull
<
int
*
>
nni4e
(
nnmy4
)
;
CHECK
(
*
nni4b
=
=
4
)
;
CHECK
(
*
nni4c
=
=
4
)
;
CHECK
(
*
nni4d
=
=
4
)
;
CHECK
(
*
nni4e
=
=
4
)
;
NotNull
<
MyPtr
<
int
>
>
nnmy4b
(
WrapNotNull
(
&
i4
)
)
;
NotNull
<
MyPtr
<
int
>
>
nnmy4c
(
WrapNotNull
(
my4
)
)
;
NotNull
<
MyPtr
<
int
>
>
nnmy4d
(
nni4
)
;
NotNull
<
MyPtr
<
int
>
>
nnmy4e
(
nnmy4
)
;
CHECK
(
*
nnmy4b
=
=
4
)
;
CHECK
(
*
nnmy4c
=
=
4
)
;
CHECK
(
*
nnmy4d
=
=
4
)
;
CHECK
(
*
nnmy4e
=
=
4
)
;
nni4b
=
WrapNotNull
(
&
i4
)
;
nni4c
=
WrapNotNull
(
my4
)
;
nni4d
=
nni4
;
nni4e
=
nnmy4
;
CHECK
(
*
nni4b
=
=
4
)
;
CHECK
(
*
nni4c
=
=
4
)
;
CHECK
(
*
nni4d
=
=
4
)
;
CHECK
(
*
nni4e
=
=
4
)
;
nnmy4b
=
WrapNotNull
(
&
i4
)
;
nnmy4c
=
WrapNotNull
(
my4
)
;
nnmy4d
=
nni4
;
nnmy4e
=
nnmy4
;
CHECK
(
*
nnmy4b
=
=
4
)
;
CHECK
(
*
nnmy4c
=
=
4
)
;
CHECK
(
*
nnmy4d
=
=
4
)
;
CHECK
(
*
nnmy4e
=
=
4
)
;
NotNull
<
MyPtr
<
int
>
>
nnmy5
=
WrapNotNull
(
&
i5
)
;
CHECK
(
*
nnmy5
=
=
5
)
;
CHECK
(
nnmy5
=
=
&
i5
)
;
CHECK
(
nnmy5
=
=
my5
)
;
CHECK
(
nnmy5
=
=
nni5
)
;
CHECK
(
nnmy5
=
=
nnmy5
)
;
CHECK
(
&
i5
=
=
nnmy5
)
;
CHECK
(
my5
=
=
nnmy5
)
;
CHECK
(
nni5
=
=
nnmy5
)
;
CHECK
(
nnmy5
=
=
nnmy5
)
;
CHECK
(
*
nnmy5
=
=
5
)
;
CHECK
(
nnmy5
!
=
&
i4
)
;
CHECK
(
nnmy5
!
=
my4
)
;
CHECK
(
nnmy5
!
=
nni4
)
;
CHECK
(
nnmy5
!
=
nnmy4
)
;
CHECK
(
&
i4
!
=
nnmy5
)
;
CHECK
(
my4
!
=
nnmy5
)
;
CHECK
(
nni4
!
=
nnmy5
)
;
CHECK
(
nnmy4
!
=
nnmy5
)
;
f_i
(
&
i4
)
;
f_i
(
my4
)
;
f_i
(
my4
.
get
(
)
)
;
f_i
(
nni4
)
;
f_i
(
nni4
.
get
(
)
)
;
f_i
(
nnmy4
.
get
(
)
)
;
f_i
(
nnmy4
.
get
(
)
.
get
(
)
)
;
f_my
(
&
i4
)
;
f_my
(
my4
)
;
f_my
(
my4
.
get
(
)
)
;
f_my
(
nni4
.
get
(
)
)
;
f_my
(
nnmy4
)
;
f_my
(
nnmy4
.
get
(
)
)
;
f_my
(
nnmy4
.
get
(
)
.
get
(
)
)
;
f_nni
(
nni4
)
;
f_nni
(
nnmy4
)
;
f_nnmy
(
nni4
)
;
f_nnmy
(
nnmy4
)
;
Blah
blah
;
MyPtr
<
Blah
>
myblah
=
&
blah
;
NotNull
<
Blah
*
>
nnblah
=
WrapNotNull
(
&
blah
)
;
NotNull
<
MyPtr
<
Blah
>
>
nnmyblah
=
WrapNotNull
(
myblah
)
;
(
&
blah
)
-
>
blah
(
)
;
myblah
-
>
blah
(
)
;
nnblah
-
>
blah
(
)
;
nnmyblah
-
>
blah
(
)
;
(
&
blah
)
-
>
mX
=
1
;
CHECK
(
(
&
blah
)
-
>
mX
=
=
1
)
;
myblah
-
>
mX
=
2
;
CHECK
(
myblah
-
>
mX
=
=
2
)
;
nnblah
-
>
mX
=
3
;
CHECK
(
nnblah
-
>
mX
=
=
3
)
;
nnmyblah
-
>
mX
=
4
;
CHECK
(
nnmyblah
-
>
mX
=
=
4
)
;
*
(
&
i4
)
=
7
;
CHECK
(
*
(
&
i4
)
=
=
7
)
;
*
my4
=
6
;
CHECK
(
*
my4
=
=
6
)
;
*
nni4
=
5
;
CHECK
(
*
nni4
=
=
5
)
;
*
nnmy4
=
4
;
CHECK
(
*
nnmy4
=
=
4
)
;
static
const
int
N
=
20
;
int
a
[
N
]
;
NotNull
<
int
*
>
nna
=
WrapNotNull
(
a
)
;
for
(
int
i
=
0
;
i
<
N
;
i
+
+
)
{
nna
[
i
]
=
i
;
}
for
(
int
i
=
0
;
i
<
N
;
i
+
+
)
{
nna
[
i
]
*
=
2
;
}
for
(
int
i
=
0
;
i
<
N
;
i
+
+
)
{
CHECK
(
nna
[
i
]
=
=
i
*
2
)
;
}
}
void
f_ref
(
NotNull
<
MyRefType
*
>
aR
)
{
NotNull
<
RefPtr
<
MyRefType
>
>
r
=
aR
;
}
void
TestNotNullWithRefPtr
(
)
{
NotNull
<
RefPtr
<
MyRefType
>
>
r1
=
WrapNotNull
(
new
MyRefType
(
5
)
)
;
NotNull
<
RefPtr
<
MyRefType
>
>
r2
=
r1
;
NotNull
<
MyRefType
*
>
r3
=
r2
;
(
void
)
r3
;
RefPtr
<
MyRefType
>
r4
=
r2
;
mozilla
:
:
Unused
<
<
r4
;
RefPtr
<
MyRefType
>
r5
=
r3
.
get
(
)
;
mozilla
:
:
Unused
<
<
r5
;
f_ref
(
r2
)
;
NotNull
<
RefPtr
<
MyRefType
>
>
r6
=
std
:
:
move
(
r2
)
;
mozilla
:
:
Unused
<
<
r6
;
CHECK
(
r2
.
get
(
)
)
;
CHECK
(
r6
.
get
(
)
)
;
}
struct
Base
{
virtual
~
Base
(
)
=
default
;
virtual
bool
IsDerived
(
)
const
{
return
false
;
}
}
;
struct
Derived
:
Base
{
bool
IsDerived
(
)
const
override
{
return
true
;
}
}
;
void
TestMakeNotNull
(
)
{
auto
nni
=
MakeNotNull
<
int
*
>
(
11
)
;
static_assert
(
std
:
:
is_same_v
<
NotNull
<
int
*
>
decltype
(
nni
)
>
"
MakeNotNull
<
int
*
>
should
return
NotNull
<
int
*
>
"
)
;
CHECK
(
*
nni
=
=
11
)
;
delete
nni
;
auto
nnci
=
MakeNotNull
<
const
int
*
>
(
12
)
;
static_assert
(
std
:
:
is_same_v
<
NotNull
<
const
int
*
>
decltype
(
nnci
)
>
"
MakeNotNull
<
const
int
*
>
should
return
NotNull
<
const
int
*
>
"
)
;
CHECK
(
*
nnci
=
=
12
)
;
delete
nnci
;
auto
nnd
=
MakeNotNull
<
Derived
*
>
(
)
;
static_assert
(
std
:
:
is_same_v
<
NotNull
<
Derived
*
>
decltype
(
nnd
)
>
"
MakeNotNull
<
Derived
*
>
should
return
NotNull
<
Derived
*
>
"
)
;
CHECK
(
nnd
-
>
IsDerived
(
)
)
;
delete
nnd
;
NotNull
<
Base
*
>
nnb
=
MakeNotNull
<
Derived
*
>
(
)
;
static_assert
(
std
:
:
is_same_v
<
NotNull
<
Base
*
>
decltype
(
nnb
)
>
"
MakeNotNull
<
Derived
*
>
should
be
assignable
to
NotNull
<
Base
*
>
"
)
;
CHECK
(
nnb
-
>
IsDerived
(
)
)
;
delete
nnb
;
auto
nnmi
=
MakeNotNull
<
MyPtr
<
int
>
>
(
23
)
;
static_assert
(
std
:
:
is_same_v
<
NotNull
<
MyPtr
<
int
>
>
decltype
(
nnmi
)
>
"
MakeNotNull
<
MyPtr
<
int
>
>
should
return
NotNull
<
MyPtr
<
int
>
>
"
)
;
CHECK
(
*
nnmi
=
=
23
)
;
delete
nnmi
.
get
(
)
.
get
(
)
;
auto
nnui
=
MakeNotNull
<
UniquePtr
<
int
>
>
(
24
)
;
static_assert
(
std
:
:
is_same_v
<
NotNull
<
UniquePtr
<
int
>
>
decltype
(
nnui
)
>
"
MakeNotNull
<
UniquePtr
<
int
>
>
should
return
NotNull
<
UniquePtr
<
int
>
>
"
)
;
CHECK
(
*
nnui
=
=
24
)
;
auto
nnr
=
MakeNotNull
<
RefPtr
<
MyRefType
>
>
(
1
)
;
static_assert
(
std
:
:
is_same_v
<
NotNull
<
RefPtr
<
MyRefType
>
>
decltype
(
nnr
)
>
"
MakeNotNull
<
RefPtr
<
MyRefType
>
>
should
return
"
"
NotNull
<
RefPtr
<
MyRefType
>
>
"
)
;
mozilla
:
:
Unused
<
<
nnr
;
}
mozilla
:
:
MovingNotNull
<
UniquePtr
<
int
>
>
CreateNotNullUniquePtr
(
)
{
return
mozilla
:
:
WrapMovingNotNull
(
mozilla
:
:
MakeUnique
<
int
>
(
42
)
)
;
}
void
TestMovingNotNull
(
)
{
UniquePtr
<
int
>
x1
=
CreateNotNullUniquePtr
(
)
;
CHECK
(
x1
)
;
CHECK
(
42
=
=
*
x1
)
;
NotNull
<
UniquePtr
<
int
>
>
x2
=
CreateNotNullUniquePtr
(
)
;
CHECK
(
42
=
=
*
x2
)
;
NotNull
<
UniquePtr
<
Base
>
>
x3
=
mozilla
:
:
WrapMovingNotNull
(
mozilla
:
:
MakeUnique
<
Derived
>
(
)
)
;
}
int
main
(
)
{
TestNotNullWithMyPtr
(
)
;
TestNotNullWithRefPtr
(
)
;
TestMakeNotNull
(
)
;
TestMovingNotNull
(
)
;
return
0
;
}
