#
include
<
type_traits
>
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
CompactPair
.
h
"
using
mozilla
:
:
CompactPair
;
using
mozilla
:
:
MakeCompactPair
;
#
define
INSTANTIATE
(
T1
T2
name
size
)
\
CompactPair
<
T1
T2
>
name
#
#
_1
(
T1
(
0
)
T2
(
0
)
)
;
\
static_assert
(
sizeof
(
name
#
#
_1
.
first
(
)
)
>
0
\
"
first
method
should
work
on
CompactPair
<
"
#
T1
"
"
#
T2
"
>
"
)
;
\
\
static_assert
(
sizeof
(
name
#
#
_1
.
second
(
)
)
>
0
\
"
second
method
should
work
on
CompactPair
<
"
#
T1
"
"
#
T2
"
>
"
)
;
\
\
static_assert
(
sizeof
(
name
#
#
_1
)
=
=
(
size
)
\
"
CompactPair
<
"
#
T1
"
"
#
T2
"
>
has
an
unexpected
size
"
)
;
\
\
CompactPair
<
T2
T1
>
name
#
#
_2
(
T2
(
0
)
T1
(
0
)
)
;
\
static_assert
(
sizeof
(
name
#
#
_2
.
first
(
)
)
>
0
\
"
first
method
should
work
on
CompactPair
<
"
#
T2
"
"
#
T1
"
>
"
)
;
\
\
static_assert
(
sizeof
(
name
#
#
_2
.
second
(
)
)
>
0
\
"
second
method
should
work
on
CompactPair
<
"
#
T2
"
"
#
T1
"
>
"
)
;
\
\
static_assert
(
sizeof
(
name
#
#
_2
)
=
=
(
size
)
\
"
CompactPair
<
"
#
T2
"
"
#
T1
"
>
has
an
unexpected
size
"
)
;
static
constexpr
std
:
:
size_t
sizemax
(
std
:
:
size_t
a
std
:
:
size_t
b
)
{
return
(
a
>
b
)
?
a
:
b
;
}
INSTANTIATE
(
int
int
prim1
2
*
sizeof
(
int
)
)
;
INSTANTIATE
(
int
long
prim2
sizeof
(
long
)
+
sizemax
(
sizeof
(
int
)
alignof
(
long
)
)
)
;
struct
EmptyClass
{
explicit
EmptyClass
(
int
)
{
}
}
;
struct
NonEmpty
{
char
mC
;
explicit
NonEmpty
(
int
)
:
mC
(
'
\
0
'
)
{
}
}
;
INSTANTIATE
(
int
EmptyClass
both1
sizeof
(
int
)
)
;
INSTANTIATE
(
int
NonEmpty
both2
sizeof
(
int
)
+
alignof
(
int
)
)
;
INSTANTIATE
(
EmptyClass
NonEmpty
both3
1
)
;
struct
A
{
char
dummy
;
explicit
A
(
int
)
:
dummy
(
'
\
0
'
)
{
}
}
;
struct
B
:
A
{
explicit
B
(
int
aI
)
:
A
(
aI
)
{
}
}
;
INSTANTIATE
(
A
A
class1
2
)
;
INSTANTIATE
(
A
B
class2
2
)
;
INSTANTIATE
(
A
EmptyClass
class3
1
)
;
struct
EmptyNonMovableNonDefaultConstructible
{
explicit
EmptyNonMovableNonDefaultConstructible
(
int
)
{
}
EmptyNonMovableNonDefaultConstructible
(
const
EmptyNonMovableNonDefaultConstructible
&
)
=
delete
;
EmptyNonMovableNonDefaultConstructible
(
EmptyNonMovableNonDefaultConstructible
&
&
)
=
delete
;
EmptyNonMovableNonDefaultConstructible
&
operator
=
(
const
EmptyNonMovableNonDefaultConstructible
&
)
=
delete
;
EmptyNonMovableNonDefaultConstructible
&
operator
=
(
EmptyNonMovableNonDefaultConstructible
&
&
)
=
delete
;
}
;
static
void
TestInPlaceConstruction
(
)
{
constexpr
int
firstValue
=
42
;
constexpr
int
secondValue
=
43
;
{
const
CompactPair
<
EmptyNonMovableNonDefaultConstructible
int
>
pair
{
std
:
:
piecewise_construct
std
:
:
tuple
(
firstValue
)
std
:
:
tuple
(
secondValue
)
}
;
MOZ_RELEASE_ASSERT
(
pair
.
second
(
)
=
=
secondValue
)
;
}
{
const
CompactPair
<
int
EmptyNonMovableNonDefaultConstructible
>
pair
{
std
:
:
piecewise_construct
std
:
:
tuple
(
firstValue
)
std
:
:
tuple
(
secondValue
)
}
;
MOZ_RELEASE_ASSERT
(
pair
.
first
(
)
=
=
firstValue
)
;
}
{
const
CompactPair
<
int
int
>
pair
{
std
:
:
piecewise_construct
std
:
:
tuple
(
firstValue
)
std
:
:
tuple
(
secondValue
)
}
;
MOZ_RELEASE_ASSERT
(
pair
.
first
(
)
=
=
firstValue
)
;
MOZ_RELEASE_ASSERT
(
pair
.
second
(
)
=
=
secondValue
)
;
}
{
const
CompactPair
<
EmptyNonMovableNonDefaultConstructible
EmptyNonMovableNonDefaultConstructible
>
pair
{
std
:
:
piecewise_construct
std
:
:
tuple
(
firstValue
)
std
:
:
tuple
(
secondValue
)
}
;
}
}
struct
OtherEmpty
:
EmptyClass
{
explicit
OtherEmpty
(
int
aI
)
:
EmptyClass
(
aI
)
{
}
}
;
int
main
(
)
{
A
a
(
0
)
;
B
b
(
0
)
;
const
A
constA
(
0
)
;
const
B
constB
(
0
)
;
static_assert
(
std
:
:
is_same_v
<
decltype
(
MakeCompactPair
(
A
(
0
)
B
(
0
)
)
)
CompactPair
<
A
B
>
>
"
MakeCompactPair
should
strip
rvalue
references
"
)
;
static_assert
(
std
:
:
is_same_v
<
decltype
(
MakeCompactPair
(
a
b
)
)
CompactPair
<
A
B
>
>
"
MakeCompactPair
should
strip
lvalue
references
"
)
;
static_assert
(
std
:
:
is_same_v
<
decltype
(
MakeCompactPair
(
constA
constB
)
)
CompactPair
<
A
B
>
>
"
MakeCompactPair
should
strip
CV
-
qualifiers
"
)
;
a
=
constA
;
a
=
A
(
0
)
;
TestInPlaceConstruction
(
)
;
return
0
;
}
