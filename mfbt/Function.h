#
ifndef
mozilla_Function_h
#
define
mozilla_Function_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
namespace
mozilla
{
namespace
detail
{
template
<
typename
ReturnType
typename
.
.
.
Arguments
>
class
FunctionImplBase
{
public
:
virtual
~
FunctionImplBase
(
)
{
}
virtual
ReturnType
call
(
Arguments
.
.
.
arguments
)
=
0
;
}
;
template
<
typename
Callable
typename
ReturnType
typename
.
.
.
Arguments
>
class
FunctionImpl
:
public
FunctionImplBase
<
ReturnType
Arguments
.
.
.
>
{
public
:
explicit
FunctionImpl
(
const
Callable
&
aCallable
)
:
mCallable
(
aCallable
)
{
}
ReturnType
call
(
Arguments
.
.
.
aArguments
)
override
{
return
mCallable
(
Forward
<
Arguments
>
(
aArguments
)
.
.
.
)
;
}
private
:
Callable
mCallable
;
}
;
}
template
<
typename
Signature
>
class
Function
;
template
<
typename
ReturnType
typename
.
.
.
Arguments
>
class
Function
<
ReturnType
(
Arguments
.
.
.
)
>
{
public
:
Function
(
)
{
}
template
<
typename
Callable
>
MOZ_IMPLICIT
Function
(
const
Callable
&
aCallable
)
:
mImpl
(
MakeUnique
<
detail
:
:
FunctionImpl
<
Callable
ReturnType
Arguments
.
.
.
>
>
(
aCallable
)
)
{
}
Function
(
Function
&
&
aOther
)
:
mImpl
(
Move
(
aOther
.
mImpl
)
)
{
}
Function
&
operator
=
(
Function
&
&
aOther
)
{
mImpl
=
Move
(
aOther
.
mImpl
)
;
return
*
this
;
}
template
<
typename
Callable
>
Function
&
operator
=
(
const
Callable
&
aCallable
)
{
mImpl
=
MakeUnique
<
detail
:
:
FunctionImpl
<
Callable
ReturnType
Arguments
.
.
.
>
>
(
aCallable
)
;
return
*
this
;
}
ReturnType
operator
(
)
(
Arguments
.
.
.
aArguments
)
const
{
MOZ_ASSERT
(
mImpl
)
;
return
mImpl
-
>
call
(
Forward
<
Arguments
>
(
aArguments
)
.
.
.
)
;
}
private
:
UniquePtr
<
detail
:
:
FunctionImplBase
<
ReturnType
Arguments
.
.
.
>
>
mImpl
;
}
;
}
#
endif
