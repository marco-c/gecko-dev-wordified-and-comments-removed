#
ifndef
mozilla_Range_h
#
define
mozilla_Range_h
#
include
"
mozilla
/
RangedPtr
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
<
stddef
.
h
>
#
include
<
type_traits
>
namespace
mozilla
{
template
<
typename
T
>
class
Range
{
template
<
typename
U
>
friend
class
Range
;
const
RangedPtr
<
T
>
mStart
;
const
RangedPtr
<
T
>
mEnd
;
public
:
Range
(
)
:
mStart
(
nullptr
0
)
mEnd
(
nullptr
0
)
{
}
Range
(
T
*
aPtr
size_t
aLength
)
:
mStart
(
aPtr
aPtr
aPtr
+
aLength
)
mEnd
(
aPtr
+
aLength
aPtr
aPtr
+
aLength
)
{
if
(
!
aPtr
)
{
MOZ_ASSERT
(
!
aLength
"
Range
does
not
support
nullptr
with
non
-
zero
length
.
"
)
;
}
}
Range
(
const
RangedPtr
<
T
>
&
aStart
const
RangedPtr
<
T
>
&
aEnd
)
:
mStart
(
aStart
.
get
(
)
aStart
.
get
(
)
aEnd
.
get
(
)
)
mEnd
(
aEnd
.
get
(
)
aStart
.
get
(
)
aEnd
.
get
(
)
)
{
aStart
.
checkIdenticalRange
(
aEnd
)
;
MOZ_ASSERT
(
aStart
<
=
aEnd
)
;
}
template
<
typename
U
class
=
std
:
:
enable_if_t
<
std
:
:
is_convertible_v
<
U
(
*
)
[
]
T
(
*
)
[
]
>
int
>
>
MOZ_IMPLICIT
Range
(
const
Range
<
U
>
&
aOther
)
:
mStart
(
aOther
.
mStart
)
mEnd
(
aOther
.
mEnd
)
{
}
MOZ_IMPLICIT
Range
(
Span
<
T
>
aSpan
)
:
Range
(
aSpan
.
Elements
(
)
aSpan
.
Length
(
)
)
{
}
template
<
typename
U
class
=
std
:
:
enable_if_t
<
std
:
:
is_convertible_v
<
U
(
*
)
[
]
T
(
*
)
[
]
>
int
>
>
MOZ_IMPLICIT
Range
(
const
Span
<
U
>
&
aSpan
)
:
Range
(
aSpan
.
Elements
(
)
aSpan
.
Length
(
)
)
{
}
RangedPtr
<
T
>
begin
(
)
const
{
return
mStart
;
}
RangedPtr
<
T
>
end
(
)
const
{
return
mEnd
;
}
size_t
length
(
)
const
{
return
mEnd
-
mStart
;
}
T
&
operator
[
]
(
size_t
aOffset
)
const
{
return
mStart
[
aOffset
]
;
}
explicit
operator
bool
(
)
const
{
return
mStart
!
=
nullptr
;
}
operator
Span
<
T
>
(
)
{
return
Span
<
T
>
(
mStart
.
get
(
)
length
(
)
)
;
}
operator
Span
<
const
T
>
(
)
const
{
return
Span
<
T
>
(
mStart
.
get
(
)
length
(
)
)
;
}
}
;
template
<
typename
T
>
Span
(
Range
<
T
>
&
)
-
>
Span
<
T
>
;
template
<
typename
T
>
Span
(
const
Range
<
T
>
&
)
-
>
Span
<
const
T
>
;
}
#
endif
