#
ifndef
mozilla_Casting_h
#
define
mozilla_Casting_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
fmt
/
format
.
h
"
#
include
<
cinttypes
>
#
include
<
cstring
>
#
include
<
type_traits
>
#
include
<
limits
>
#
include
<
cmath
>
namespace
mozilla
{
template
<
typename
To
typename
From
>
inline
void
BitwiseCast
(
const
From
aFrom
To
*
aResult
)
{
static_assert
(
sizeof
(
From
)
=
=
sizeof
(
To
)
"
To
and
From
must
have
the
same
size
"
)
;
static_assert
(
std
:
:
is_trivial
<
From
>
:
:
value
"
shouldn
'
t
bitwise
-
copy
a
type
having
non
-
trivial
"
"
initialization
"
)
;
static_assert
(
std
:
:
is_trivial
<
To
>
:
:
value
"
shouldn
'
t
bitwise
-
copy
a
type
having
non
-
trivial
"
"
initialization
"
)
;
std
:
:
memcpy
(
static_cast
<
void
*
>
(
aResult
)
static_cast
<
const
void
*
>
(
&
aFrom
)
sizeof
(
From
)
)
;
}
template
<
typename
To
typename
From
>
inline
To
BitwiseCast
(
const
From
aFrom
)
{
To
temp
;
BitwiseCast
<
To
From
>
(
aFrom
&
temp
)
;
return
temp
;
}
namespace
detail
{
template
<
typename
T
>
constexpr
int64_t
safe_integer
(
)
{
static_assert
(
std
:
:
is_floating_point_v
<
T
>
)
;
return
std
:
:
pow
(
2
std
:
:
numeric_limits
<
T
>
:
:
digits
)
;
}
template
<
typename
T
>
constexpr
uint64_t
safe_integer_unsigned
(
)
{
static_assert
(
std
:
:
is_floating_point_v
<
T
>
)
;
return
std
:
:
pow
(
2
std
:
:
numeric_limits
<
T
>
:
:
digits
)
;
}
template
<
typename
T
>
const
char
*
TypeToStringFallback
(
)
;
template
<
typename
T
>
inline
constexpr
const
char
*
TypeToString
(
)
{
return
TypeToStringFallback
<
T
>
(
)
;
}
#
define
T2S
(
type
)
\
template
<
>
\
inline
constexpr
const
char
*
TypeToString
<
type
>
(
)
{
\
return
#
type
;
\
}
#
define
T2SF
(
type
)
\
template
<
>
\
inline
constexpr
const
char
*
TypeToStringFallback
<
type
>
(
)
{
\
return
#
type
;
\
}
T2S
(
uint8_t
)
;
T2S
(
uint16_t
)
;
T2S
(
uint32_t
)
;
T2S
(
uint64_t
)
;
T2S
(
int8_t
)
;
T2S
(
int16_t
)
;
T2S
(
int32_t
)
;
T2S
(
int64_t
)
;
T2S
(
char16_t
)
;
T2S
(
char32_t
)
;
T2SF
(
int
)
;
T2SF
(
unsigned
int
)
;
T2SF
(
long
)
;
T2SF
(
unsigned
long
)
;
T2S
(
float
)
;
T2S
(
double
)
;
#
undef
T2S
#
undef
T2SF
template
<
typename
In
typename
Out
>
inline
void
DiagnosticMessage
(
In
aIn
char
aDiagnostic
[
1024
]
)
{
if
constexpr
(
std
:
:
is_same_v
<
In
char
>
|
|
std
:
:
is_same_v
<
In
wchar_t
>
|
|
std
:
:
is_same_v
<
In
char16_t
>
|
|
std
:
:
is_same_v
<
In
char32_t
>
)
{
static_assert
(
sizeof
(
wchar_t
)
<
=
sizeof
(
int32_t
)
)
;
auto
[
out
size
]
=
fmt
:
:
format_to_n
(
aDiagnostic
1023
FMT_STRING
(
"
Cannot
cast
{
:
x
}
from
{
}
to
{
}
:
out
of
range
"
)
static_cast
<
int64_t
>
(
aIn
)
TypeToString
<
In
>
(
)
TypeToString
<
Out
>
(
)
)
;
*
out
=
0
;
}
else
{
auto
[
out
size
]
=
fmt
:
:
format_to_n
(
aDiagnostic
1023
FMT_STRING
(
"
Cannot
cast
{
}
from
{
}
to
{
}
:
out
of
range
"
)
aIn
TypeToString
<
In
>
(
)
TypeToString
<
Out
>
(
)
)
;
*
out
=
0
;
}
}
#
pragma
GCC
diagnostic
push
#
pragma
GCC
diagnostic
ignored
"
-
Wunused
-
but
-
set
-
variable
"
template
<
typename
In
typename
Out
>
bool
IsInBounds
(
In
aIn
)
{
constexpr
bool
inSigned
=
std
:
:
is_signed_v
<
In
>
;
constexpr
bool
outSigned
=
std
:
:
is_signed_v
<
Out
>
;
constexpr
bool
bothSigned
=
inSigned
&
&
outSigned
;
constexpr
bool
bothUnsigned
=
!
inSigned
&
&
!
outSigned
;
constexpr
bool
inFloat
=
std
:
:
is_floating_point_v
<
In
>
;
constexpr
bool
outFloat
=
std
:
:
is_floating_point_v
<
Out
>
;
constexpr
bool
bothFloat
=
inFloat
&
&
outFloat
;
constexpr
bool
noneFloat
=
!
inFloat
&
&
!
outFloat
;
constexpr
Out
outMax
=
std
:
:
numeric_limits
<
Out
>
:
:
max
(
)
;
constexpr
Out
outMin
=
std
:
:
numeric_limits
<
Out
>
:
:
lowest
(
)
;
using
select_widest
=
std
:
:
conditional_t
<
(
sizeof
(
In
)
>
sizeof
(
Out
)
)
In
Out
>
;
if
constexpr
(
bothFloat
)
{
if
(
aIn
>
select_widest
(
outMax
)
|
|
aIn
<
select_widest
(
outMin
)
)
{
return
false
;
}
}
if
constexpr
(
inFloat
&
&
!
outFloat
)
{
static_assert
(
sizeof
(
aIn
)
<
=
sizeof
(
int64_t
)
)
;
if
(
aIn
<
static_cast
<
double
>
(
outMin
)
|
|
aIn
>
static_cast
<
double
>
(
outMax
)
)
{
return
false
;
}
if
(
outSigned
)
{
int64_t
asInteger
=
static_cast
<
int64_t
>
(
aIn
)
;
if
(
asInteger
<
outMin
|
|
asInteger
>
outMax
)
{
return
false
;
}
}
else
{
uint64_t
asInteger
=
static_cast
<
uint64_t
>
(
aIn
)
;
if
(
asInteger
>
outMax
)
{
return
false
;
}
}
}
if
constexpr
(
!
inFloat
&
&
outFloat
)
{
if
constexpr
(
inSigned
)
{
if
(
aIn
<
-
safe_integer
<
Out
>
(
)
|
|
aIn
>
safe_integer
<
Out
>
(
)
)
{
return
false
;
}
}
else
{
if
(
aIn
>
=
safe_integer_unsigned
<
Out
>
(
)
)
{
return
false
;
}
}
}
if
constexpr
(
noneFloat
)
{
if
constexpr
(
bothUnsigned
)
{
if
(
aIn
>
select_widest
(
outMax
)
)
{
return
false
;
}
}
if
constexpr
(
bothSigned
)
{
if
(
aIn
>
select_widest
(
outMax
)
|
|
aIn
<
select_widest
(
outMin
)
)
{
return
false
;
}
}
if
constexpr
(
inSigned
&
&
!
outSigned
)
{
if
(
aIn
<
0
|
|
std
:
:
make_unsigned_t
<
In
>
(
aIn
)
>
outMax
)
{
return
false
;
}
}
if
constexpr
(
!
inSigned
&
&
outSigned
)
{
if
(
aIn
>
select_widest
(
outMax
)
)
{
return
false
;
}
}
}
return
true
;
}
#
pragma
GCC
diagnostic
pop
}
template
<
typename
To
typename
From
>
inline
To
AssertedCast
(
const
From
aFrom
)
{
static_assert
(
std
:
:
is_arithmetic_v
<
To
>
&
&
std
:
:
is_arithmetic_v
<
From
>
)
;
#
ifdef
DEBUG
if
(
!
detail
:
:
IsInBounds
<
From
To
>
(
aFrom
)
)
{
char
buf
[
1024
]
;
detail
:
:
DiagnosticMessage
<
From
To
>
(
aFrom
buf
)
;
fprintf
(
stderr
"
AssertedCast
error
:
%
s
\
n
"
buf
)
;
MOZ_CRASH
(
)
;
}
#
endif
return
static_cast
<
To
>
(
aFrom
)
;
}
template
<
typename
To
typename
From
>
inline
To
ReleaseAssertedCast
(
const
From
aFrom
)
{
static_assert
(
std
:
:
is_arithmetic_v
<
To
>
&
&
std
:
:
is_arithmetic_v
<
From
>
)
;
MOZ_RELEASE_ASSERT
(
(
detail
:
:
IsInBounds
<
From
To
>
(
aFrom
)
)
)
;
return
static_cast
<
To
>
(
aFrom
)
;
}
template
<
typename
To
typename
From
>
inline
To
SaturatingCast
(
const
From
aFrom
)
{
static_assert
(
std
:
:
is_arithmetic_v
<
To
>
&
&
std
:
:
is_arithmetic_v
<
From
>
)
;
static_assert
(
sizeof
(
From
)
<
=
8
&
&
sizeof
(
To
)
<
=
8
)
;
constexpr
bool
fromFloat
=
std
:
:
is_floating_point_v
<
From
>
;
constexpr
bool
toFloat
=
std
:
:
is_floating_point_v
<
To
>
;
static_assert
(
(
fromFloat
&
&
!
toFloat
)
|
|
(
!
fromFloat
&
&
!
toFloat
)
"
Handle
manually
depending
on
desired
behaviour
"
)
;
if
constexpr
(
fromFloat
)
{
if
(
aFrom
>
static_cast
<
double
>
(
std
:
:
numeric_limits
<
To
>
:
:
max
(
)
)
)
{
return
std
:
:
numeric_limits
<
To
>
:
:
max
(
)
;
}
if
(
aFrom
<
static_cast
<
double
>
(
std
:
:
numeric_limits
<
To
>
:
:
lowest
(
)
)
)
{
return
std
:
:
numeric_limits
<
To
>
:
:
lowest
(
)
;
}
return
static_cast
<
To
>
(
aFrom
)
;
}
if
constexpr
(
std
:
:
is_signed_v
<
From
>
!
=
std
:
:
is_signed_v
<
To
>
)
{
if
(
std
:
:
is_signed_v
<
From
>
&
&
aFrom
<
0
)
{
return
0
;
}
uint64_t
inflated
=
AssertedCast
<
uint64_t
>
(
aFrom
)
;
if
(
inflated
>
static_cast
<
uint64_t
>
(
std
:
:
numeric_limits
<
To
>
:
:
max
(
)
)
)
{
return
std
:
:
numeric_limits
<
To
>
:
:
max
(
)
;
}
return
static_cast
<
To
>
(
aFrom
)
;
}
else
{
if
(
aFrom
>
std
:
:
numeric_limits
<
To
>
:
:
max
(
)
)
{
return
std
:
:
numeric_limits
<
To
>
:
:
max
(
)
;
}
if
(
aFrom
<
std
:
:
numeric_limits
<
To
>
:
:
lowest
(
)
)
{
return
std
:
:
numeric_limits
<
To
>
:
:
lowest
(
)
;
}
return
static_cast
<
To
>
(
aFrom
)
;
}
}
namespace
detail
{
template
<
typename
From
>
class
LazyAssertedCastT
final
{
const
From
mVal
;
public
:
explicit
LazyAssertedCastT
(
const
From
val
)
:
mVal
(
val
)
{
}
template
<
typename
To
>
operator
To
(
)
const
{
return
AssertedCast
<
To
>
(
mVal
)
;
}
}
;
}
template
<
typename
From
>
inline
auto
LazyAssertedCast
(
const
From
val
)
{
return
detail
:
:
LazyAssertedCastT
<
From
>
(
val
)
;
}
}
#
endif
