#
ifndef
mozilla_Casting_h
#
define
mozilla_Casting_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
<
cstring
>
#
include
<
type_traits
>
#
include
<
limits
>
#
include
<
cmath
>
namespace
mozilla
{
template
<
typename
To
typename
From
>
inline
void
BitwiseCast
(
const
From
aFrom
To
*
aResult
)
{
static_assert
(
sizeof
(
From
)
=
=
sizeof
(
To
)
"
To
and
From
must
have
the
same
size
"
)
;
static_assert
(
std
:
:
is_trivial
<
From
>
:
:
value
"
shouldn
'
t
bitwise
-
copy
a
type
having
non
-
trivial
"
"
initialization
"
)
;
static_assert
(
std
:
:
is_trivial
<
To
>
:
:
value
"
shouldn
'
t
bitwise
-
copy
a
type
having
non
-
trivial
"
"
initialization
"
)
;
std
:
:
memcpy
(
static_cast
<
void
*
>
(
aResult
)
static_cast
<
const
void
*
>
(
&
aFrom
)
sizeof
(
From
)
)
;
}
template
<
typename
To
typename
From
>
inline
To
BitwiseCast
(
const
From
aFrom
)
{
To
temp
;
BitwiseCast
<
To
From
>
(
aFrom
&
temp
)
;
return
temp
;
}
namespace
detail
{
template
<
typename
T
>
constexpr
int64_t
safe_integer
(
)
{
static_assert
(
std
:
:
is_floating_point_v
<
T
>
)
;
return
std
:
:
pow
(
2
std
:
:
numeric_limits
<
T
>
:
:
digits
)
;
}
template
<
typename
T
>
constexpr
uint64_t
safe_integer_unsigned
(
)
{
static_assert
(
std
:
:
is_floating_point_v
<
T
>
)
;
return
std
:
:
pow
(
2
std
:
:
numeric_limits
<
T
>
:
:
digits
)
;
}
#
pragma
GCC
diagnostic
ignored
"
-
Wunused
-
but
-
set
-
variable
"
template
<
typename
In
typename
Out
>
bool
IsInBounds
(
In
aIn
)
{
constexpr
bool
inSigned
=
std
:
:
is_signed_v
<
In
>
;
constexpr
bool
outSigned
=
std
:
:
is_signed_v
<
Out
>
;
constexpr
bool
bothSigned
=
inSigned
&
&
outSigned
;
constexpr
bool
bothUnsigned
=
!
inSigned
&
&
!
outSigned
;
constexpr
bool
inFloat
=
std
:
:
is_floating_point_v
<
In
>
;
constexpr
bool
outFloat
=
std
:
:
is_floating_point_v
<
Out
>
;
constexpr
bool
bothFloat
=
inFloat
&
&
outFloat
;
constexpr
bool
noneFloat
=
!
inFloat
&
&
!
outFloat
;
constexpr
Out
outMax
=
std
:
:
numeric_limits
<
Out
>
:
:
max
(
)
;
constexpr
Out
outMin
=
std
:
:
numeric_limits
<
Out
>
:
:
lowest
(
)
;
using
select_widest
=
std
:
:
conditional_t
<
(
sizeof
(
In
)
>
sizeof
(
Out
)
)
In
Out
>
;
if
constexpr
(
bothFloat
)
{
if
(
aIn
>
select_widest
(
outMax
)
|
|
aIn
<
select_widest
(
outMin
)
)
{
return
false
;
}
}
if
constexpr
(
inFloat
&
&
!
outFloat
)
{
static_assert
(
sizeof
(
aIn
)
<
=
sizeof
(
int64_t
)
)
;
if
(
aIn
<
static_cast
<
double
>
(
outMin
)
|
|
aIn
>
static_cast
<
double
>
(
outMax
)
)
{
return
false
;
}
if
(
outSigned
)
{
int64_t
asInteger
=
static_cast
<
int64_t
>
(
aIn
)
;
if
(
asInteger
<
outMin
|
|
asInteger
>
outMax
)
{
return
false
;
}
}
else
{
uint64_t
asInteger
=
static_cast
<
uint64_t
>
(
aIn
)
;
if
(
asInteger
<
0
|
|
asInteger
>
outMax
)
{
return
false
;
}
}
}
if
constexpr
(
!
inFloat
&
&
outFloat
)
{
if
constexpr
(
inSigned
)
{
if
(
aIn
<
-
safe_integer
<
Out
>
(
)
|
|
aIn
>
safe_integer
<
Out
>
(
)
)
{
return
false
;
}
}
else
{
if
(
aIn
>
=
safe_integer_unsigned
<
Out
>
(
)
)
{
return
false
;
}
}
}
if
constexpr
(
noneFloat
)
{
if
constexpr
(
bothUnsigned
)
{
if
(
aIn
>
select_widest
(
outMax
)
)
{
return
false
;
}
}
if
constexpr
(
bothSigned
)
{
if
(
aIn
>
select_widest
(
outMax
)
|
|
aIn
<
select_widest
(
outMin
)
)
{
return
false
;
}
}
if
constexpr
(
inSigned
&
&
!
outSigned
)
{
if
(
aIn
<
0
|
|
std
:
:
make_unsigned_t
<
In
>
(
aIn
)
>
outMax
)
{
return
false
;
}
}
if
constexpr
(
!
inSigned
&
&
outSigned
)
{
if
(
aIn
>
select_widest
(
outMax
)
)
{
return
false
;
}
}
}
return
true
;
}
#
pragma
GCC
diagnostic
pop
}
template
<
typename
To
typename
From
>
inline
To
AssertedCast
(
const
From
aFrom
)
{
static_assert
(
std
:
:
is_arithmetic_v
<
To
>
&
&
std
:
:
is_arithmetic_v
<
From
>
)
;
MOZ_ASSERT
(
(
detail
:
:
IsInBounds
<
From
To
>
(
aFrom
)
)
)
;
return
static_cast
<
To
>
(
aFrom
)
;
}
template
<
typename
To
typename
From
>
inline
To
ReleaseAssertedCast
(
const
From
aFrom
)
{
static_assert
(
std
:
:
is_arithmetic_v
<
To
>
&
&
std
:
:
is_arithmetic_v
<
From
>
)
;
MOZ_RELEASE_ASSERT
(
(
detail
:
:
IsInBounds
<
From
To
>
(
aFrom
)
)
)
;
return
static_cast
<
To
>
(
aFrom
)
;
}
}
#
endif
