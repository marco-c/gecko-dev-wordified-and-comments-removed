#
ifndef
mozilla_ArrayUtils_h
#
define
mozilla_ArrayUtils_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
<
algorithm
>
#
include
<
stddef
.
h
>
#
ifdef
__cplusplus
#
include
<
type_traits
>
#
include
"
mozilla
/
Alignment
.
h
"
#
include
"
mozilla
/
Array
.
h
"
#
include
"
mozilla
/
EnumeratedArray
.
h
"
namespace
mozilla
{
template
<
class
T
>
MOZ_ALWAYS_INLINE
size_t
PointerRangeSize
(
T
*
aBegin
T
*
aEnd
)
{
MOZ_ASSERT
(
aEnd
>
=
aBegin
)
;
return
(
size_t
(
aEnd
)
-
size_t
(
aBegin
)
)
/
sizeof
(
T
)
;
}
template
<
typename
T
size_t
N
>
constexpr
size_t
ArrayLength
(
T
(
&
aArr
)
[
N
]
)
{
return
N
;
}
template
<
typename
T
size_t
N
>
constexpr
size_t
ArrayLength
(
const
Array
<
T
N
>
&
aArr
)
{
return
N
;
}
template
<
typename
E
E
N
typename
T
>
constexpr
size_t
ArrayLength
(
const
EnumeratedArray
<
E
N
T
>
&
aArr
)
{
return
size_t
(
N
)
;
}
template
<
typename
T
size_t
N
>
constexpr
T
*
ArrayEnd
(
T
(
&
aArr
)
[
N
]
)
{
return
aArr
+
ArrayLength
(
aArr
)
;
}
template
<
typename
T
size_t
N
>
constexpr
T
*
ArrayEnd
(
Array
<
T
N
>
&
aArr
)
{
return
&
aArr
[
0
]
+
ArrayLength
(
aArr
)
;
}
template
<
typename
T
size_t
N
>
constexpr
const
T
*
ArrayEnd
(
const
Array
<
T
N
>
&
aArr
)
{
return
&
aArr
[
0
]
+
ArrayLength
(
aArr
)
;
}
template
<
typename
T
typename
U
size_t
N
>
bool
ArrayEqual
(
const
T
(
&
a
)
[
N
]
const
U
(
&
b
)
[
N
]
)
{
return
std
:
:
equal
(
a
a
+
N
b
)
;
}
template
<
typename
T
typename
U
>
bool
ArrayEqual
(
const
T
*
const
a
const
U
*
const
b
const
size_t
n
)
{
return
std
:
:
equal
(
a
a
+
n
b
)
;
}
namespace
detail
{
template
<
typename
AlignType
typename
Pointee
typename
=
void
>
struct
AlignedChecker
{
static
void
test
(
const
Pointee
*
aPtr
)
{
MOZ_ASSERT
(
(
uintptr_t
(
aPtr
)
%
MOZ_ALIGNOF
(
AlignType
)
)
=
=
0
"
performing
a
range
-
check
with
a
misaligned
pointer
"
)
;
}
}
;
template
<
typename
AlignType
typename
Pointee
>
struct
AlignedChecker
<
AlignType
Pointee
std
:
:
enable_if_t
<
std
:
:
is_void_v
<
AlignType
>
>
>
{
static
void
test
(
const
Pointee
*
aPtr
)
{
}
}
;
}
template
<
typename
T
typename
U
>
inline
std
:
:
enable_if_t
<
std
:
:
is_same_v
<
T
U
>
|
|
std
:
:
is_base_of
<
T
U
>
:
:
value
|
|
std
:
:
is_void_v
<
T
>
bool
>
IsInRange
(
const
T
*
aPtr
const
U
*
aBegin
const
U
*
aEnd
)
{
MOZ_ASSERT
(
aBegin
<
=
aEnd
)
;
detail
:
:
AlignedChecker
<
U
T
>
:
:
test
(
aPtr
)
;
detail
:
:
AlignedChecker
<
U
U
>
:
:
test
(
aBegin
)
;
detail
:
:
AlignedChecker
<
U
U
>
:
:
test
(
aEnd
)
;
return
aBegin
<
=
reinterpret_cast
<
const
U
*
>
(
aPtr
)
&
&
reinterpret_cast
<
const
U
*
>
(
aPtr
)
<
aEnd
;
}
template
<
typename
T
>
inline
bool
IsInRange
(
const
T
*
aPtr
uintptr_t
aBegin
uintptr_t
aEnd
)
{
return
IsInRange
(
aPtr
reinterpret_cast
<
const
T
*
>
(
aBegin
)
reinterpret_cast
<
const
T
*
>
(
aEnd
)
)
;
}
namespace
detail
{
template
<
typename
T
size_t
N
>
char
(
&
ArrayLengthHelper
(
T
(
&
array
)
[
N
]
)
)
[
N
]
;
}
}
#
endif
#
ifdef
__cplusplus
#
define
MOZ_ARRAY_LENGTH
(
array
)
\
sizeof
(
mozilla
:
:
detail
:
:
ArrayLengthHelper
(
array
)
)
#
else
#
define
MOZ_ARRAY_LENGTH
(
array
)
(
sizeof
(
array
)
/
sizeof
(
(
array
)
[
0
]
)
)
#
endif
#
endif
