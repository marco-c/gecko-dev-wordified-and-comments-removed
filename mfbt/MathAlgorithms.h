#
ifndef
mozilla_MathAlgorithms_h
#
define
mozilla_MathAlgorithms_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
<
algorithm
>
#
include
<
cmath
>
#
include
<
limits
>
#
include
<
cstdint
>
#
include
<
type_traits
>
namespace
mozilla
{
namespace
detail
{
template
<
typename
T
typename
=
void
>
struct
AbsReturnType
;
template
<
typename
T
>
struct
AbsReturnType
<
T
std
:
:
enable_if_t
<
std
:
:
is_integral_v
<
T
>
&
&
std
:
:
is_signed_v
<
T
>
>
>
{
using
Type
=
std
:
:
make_unsigned_t
<
T
>
;
}
;
template
<
typename
T
>
struct
AbsReturnType
<
T
std
:
:
enable_if_t
<
std
:
:
is_floating_point_v
<
T
>
>
>
{
using
Type
=
T
;
}
;
}
template
<
class
T
>
constexpr
bool
IsValidAbsArgument
(
T
val
)
{
static_assert
(
std
:
:
is_integral_v
<
T
>
&
&
std
:
:
is_signed_v
<
T
>
"
no
need
to
validate
unsigned
or
floating
point
type
"
)
;
return
val
!
=
std
:
:
numeric_limits
<
T
>
:
:
min
(
)
;
}
template
<
typename
T
>
inline
constexpr
typename
detail
:
:
AbsReturnType
<
T
>
:
:
Type
Abs
(
const
T
aValue
)
{
using
ReturnType
=
typename
detail
:
:
AbsReturnType
<
T
>
:
:
Type
;
return
aValue
>
=
0
?
ReturnType
(
aValue
)
:
~
ReturnType
(
aValue
)
+
1
;
}
template
<
>
inline
float
Abs
<
float
>
(
const
float
aFloat
)
{
return
std
:
:
fabs
(
aFloat
)
;
}
template
<
>
inline
double
Abs
<
double
>
(
const
double
aDouble
)
{
return
std
:
:
fabs
(
aDouble
)
;
}
template
<
>
inline
long
double
Abs
<
long
double
>
(
const
long
double
aLongDouble
)
{
return
std
:
:
fabs
(
aLongDouble
)
;
}
}
namespace
mozilla
{
namespace
detail
{
#
if
defined
(
__clang__
)
|
|
defined
(
__GNUC__
)
#
if
defined
(
__clang__
)
#
if
!
__has_builtin
(
__builtin_ctz
)
|
|
!
__has_builtin
(
__builtin_clz
)
#
error
"
A
clang
providing
__builtin_c
[
lt
]
z
is
required
to
build
"
#
endif
#
else
#
endif
constexpr
uint_fast8_t
CountLeadingZeroes32
(
uint32_t
aValue
)
{
return
static_cast
<
uint_fast8_t
>
(
__builtin_clz
(
aValue
)
)
;
}
constexpr
uint_fast8_t
CountTrailingZeroes32
(
uint32_t
aValue
)
{
return
static_cast
<
uint_fast8_t
>
(
__builtin_ctz
(
aValue
)
)
;
}
constexpr
uint_fast8_t
CountPopulation32
(
uint32_t
aValue
)
{
return
static_cast
<
uint_fast8_t
>
(
__builtin_popcount
(
aValue
)
)
;
}
constexpr
uint_fast8_t
CountPopulation64
(
uint64_t
aValue
)
{
return
static_cast
<
uint_fast8_t
>
(
__builtin_popcountll
(
aValue
)
)
;
}
constexpr
uint_fast8_t
CountLeadingZeroes64
(
uint64_t
aValue
)
{
return
static_cast
<
uint_fast8_t
>
(
__builtin_clzll
(
aValue
)
)
;
}
constexpr
uint_fast8_t
CountTrailingZeroes64
(
uint64_t
aValue
)
{
return
static_cast
<
uint_fast8_t
>
(
__builtin_ctzll
(
aValue
)
)
;
}
#
else
#
error
"
Implement
these
!
"
constexpr
uint_fast8_t
CountLeadingZeroes32
(
uint32_t
aValue
)
=
delete
;
constexpr
uint_fast8_t
CountTrailingZeroes32
(
uint32_t
aValue
)
=
delete
;
constexpr
uint_fast8_t
CountPopulation32
(
uint32_t
aValue
)
=
delete
;
constexpr
uint_fast8_t
CountPopulation64
(
uint64_t
aValue
)
=
delete
;
constexpr
uint_fast8_t
CountLeadingZeroes64
(
uint64_t
aValue
)
=
delete
;
constexpr
uint_fast8_t
CountTrailingZeroes64
(
uint64_t
aValue
)
=
delete
;
#
endif
}
constexpr
uint_fast8_t
CountLeadingZeroes32
(
uint32_t
aValue
)
{
MOZ_ASSERT
(
aValue
!
=
0
)
;
return
detail
:
:
CountLeadingZeroes32
(
aValue
)
;
}
constexpr
uint_fast8_t
CountTrailingZeroes32
(
uint32_t
aValue
)
{
MOZ_ASSERT
(
aValue
!
=
0
)
;
return
detail
:
:
CountTrailingZeroes32
(
aValue
)
;
}
constexpr
uint_fast8_t
CountPopulation32
(
uint32_t
aValue
)
{
return
detail
:
:
CountPopulation32
(
aValue
)
;
}
constexpr
uint_fast8_t
CountPopulation64
(
uint64_t
aValue
)
{
return
detail
:
:
CountPopulation64
(
aValue
)
;
}
constexpr
uint_fast8_t
CountLeadingZeroes64
(
uint64_t
aValue
)
{
MOZ_ASSERT
(
aValue
!
=
0
)
;
return
detail
:
:
CountLeadingZeroes64
(
aValue
)
;
}
constexpr
uint_fast8_t
CountTrailingZeroes64
(
uint64_t
aValue
)
{
MOZ_ASSERT
(
aValue
!
=
0
)
;
return
detail
:
:
CountTrailingZeroes64
(
aValue
)
;
}
namespace
detail
{
template
<
typename
T
size_t
Size
=
sizeof
(
T
)
>
class
CeilingLog2
;
template
<
typename
T
>
class
CeilingLog2
<
T
4
>
{
public
:
static
constexpr
uint_fast8_t
compute
(
const
T
aValue
)
{
return
aValue
<
=
1
?
0u
:
32u
-
CountLeadingZeroes32
(
aValue
-
1
)
;
}
}
;
template
<
typename
T
>
class
CeilingLog2
<
T
8
>
{
public
:
static
constexpr
uint_fast8_t
compute
(
const
T
aValue
)
{
return
aValue
<
=
1
?
0u
:
64u
-
CountLeadingZeroes64
(
aValue
-
1
)
;
}
}
;
}
template
<
typename
T
>
constexpr
uint_fast8_t
CeilingLog2
(
const
T
aValue
)
{
return
detail
:
:
CeilingLog2
<
T
>
:
:
compute
(
aValue
)
;
}
constexpr
uint_fast8_t
CeilingLog2Size
(
size_t
aValue
)
{
return
CeilingLog2
(
aValue
)
;
}
template
<
typename
T
>
constexpr
uint_fast8_t
FindMostSignificantBit
(
T
aValue
)
{
static_assert
(
sizeof
(
T
)
<
=
8
)
;
static_assert
(
std
:
:
is_integral_v
<
T
>
)
;
MOZ_ASSERT
(
aValue
!
=
0
)
;
if
constexpr
(
sizeof
(
T
)
<
=
4
)
{
return
31u
-
CountLeadingZeroes32
(
aValue
)
;
}
if
constexpr
(
sizeof
(
T
)
=
=
8
)
{
return
63u
-
CountLeadingZeroes64
(
aValue
)
;
}
}
template
<
typename
T
>
constexpr
uint_fast8_t
FloorLog2
(
const
T
aValue
)
{
return
FindMostSignificantBit
(
aValue
|
1
)
;
}
constexpr
uint_fast8_t
FloorLog2Size
(
size_t
aValue
)
{
return
FloorLog2
(
aValue
)
;
}
constexpr
size_t
RoundUpPow2
(
size_t
aValue
)
{
MOZ_ASSERT
(
aValue
<
=
(
size_t
(
1
)
<
<
(
sizeof
(
size_t
)
*
std
:
:
numeric_limits
<
unsigned
char
>
:
:
digits
-
1
)
)
"
can
'
t
round
up
-
-
will
overflow
!
"
)
;
return
size_t
(
1
)
<
<
CeilingLog2
(
aValue
)
;
}
template
<
typename
T
>
MOZ_NO_SANITIZE_UNSIGNED_OVERFLOW
constexpr
T
RotateLeft
(
const
T
aValue
uint_fast8_t
aShift
)
{
static_assert
(
std
:
:
is_unsigned_v
<
T
>
"
Rotates
require
unsigned
values
"
)
;
MOZ_ASSERT
(
aShift
<
sizeof
(
T
)
*
std
:
:
numeric_limits
<
unsigned
char
>
:
:
digits
"
Shift
value
is
too
large
!
"
)
;
MOZ_ASSERT
(
aShift
>
0
"
Rotation
by
value
length
is
undefined
behavior
but
compilers
"
"
do
not
currently
fold
a
test
into
the
rotate
instruction
.
"
"
Please
remove
this
restriction
when
compilers
optimize
the
"
"
zero
case
(
http
:
/
/
blog
.
regehr
.
org
/
archives
/
1063
)
.
"
)
;
return
(
aValue
<
<
aShift
)
|
(
aValue
>
>
(
sizeof
(
T
)
*
std
:
:
numeric_limits
<
unsigned
char
>
:
:
digits
-
aShift
)
)
;
}
template
<
typename
T
>
MOZ_NO_SANITIZE_UNSIGNED_OVERFLOW
constexpr
T
RotateRight
(
const
T
aValue
uint_fast8_t
aShift
)
{
static_assert
(
std
:
:
is_unsigned_v
<
T
>
"
Rotates
require
unsigned
values
"
)
;
MOZ_ASSERT
(
aShift
<
sizeof
(
T
)
*
std
:
:
numeric_limits
<
unsigned
char
>
:
:
digits
"
Shift
value
is
too
large
!
"
)
;
MOZ_ASSERT
(
aShift
>
0
"
Rotation
by
value
length
is
undefined
behavior
but
compilers
"
"
do
not
currently
fold
a
test
into
the
rotate
instruction
.
"
"
Please
remove
this
restriction
when
compilers
optimize
the
"
"
zero
case
(
http
:
/
/
blog
.
regehr
.
org
/
archives
/
1063
)
.
"
)
;
return
(
aValue
>
>
aShift
)
|
(
aValue
<
<
(
sizeof
(
T
)
*
std
:
:
numeric_limits
<
unsigned
char
>
:
:
digits
-
aShift
)
)
;
}
template
<
typename
T
>
constexpr
bool
IsPowerOfTwo
(
T
x
)
{
static_assert
(
std
:
:
is_unsigned_v
<
T
>
"
IsPowerOfTwo
requires
unsigned
values
"
)
;
return
x
&
&
(
x
&
(
x
-
1
)
)
=
=
0
;
}
template
<
typename
T
>
constexpr
uint_fast8_t
CountTrailingZeroes
(
T
aValue
)
{
static_assert
(
sizeof
(
T
)
<
=
8
)
;
static_assert
(
std
:
:
is_integral_v
<
T
>
)
;
if
constexpr
(
sizeof
(
T
)
<
=
4
)
{
return
CountTrailingZeroes32
(
aValue
)
;
}
if
constexpr
(
sizeof
(
T
)
=
=
8
)
{
return
CountTrailingZeroes64
(
aValue
)
;
}
}
template
<
typename
T
>
MOZ_ALWAYS_INLINE
T
GCD
(
T
aA
T
aB
)
{
static_assert
(
std
:
:
is_integral_v
<
T
>
)
;
MOZ_ASSERT
(
aA
>
=
0
)
;
MOZ_ASSERT
(
aB
>
=
0
)
;
if
(
aA
=
=
0
)
{
return
aB
;
}
if
(
aB
=
=
0
)
{
return
aA
;
}
T
az
=
CountTrailingZeroes
(
aA
)
;
T
bz
=
CountTrailingZeroes
(
aB
)
;
T
shift
=
std
:
:
min
<
T
>
(
az
bz
)
;
aA
>
>
=
az
;
aB
>
>
=
bz
;
while
(
aA
!
=
0
)
{
if
constexpr
(
!
std
:
:
is_signed_v
<
T
>
)
{
if
(
aA
<
aB
)
{
std
:
:
swap
(
aA
aB
)
;
}
}
T
diff
=
aA
-
aB
;
if
constexpr
(
std
:
:
is_signed_v
<
T
>
)
{
aB
=
std
:
:
min
<
T
>
(
aA
aB
)
;
}
if
constexpr
(
std
:
:
is_signed_v
<
T
>
)
{
aA
=
std
:
:
abs
(
diff
)
;
}
else
{
aA
=
diff
;
}
if
(
aA
)
{
aA
>
>
=
CountTrailingZeroes
(
aA
)
;
}
}
return
aB
<
<
shift
;
}
}
#
endif
