#
ifndef
mozilla_BufferList_h
#
define
mozilla_BufferList_h
#
include
<
algorithm
>
#
include
"
mozilla
/
AllocPolicy
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
Types
.
h
"
#
include
"
mozilla
/
TypeTraits
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
<
string
.
h
>
namespace
mozilla
{
template
<
typename
AllocPolicy
>
class
BufferList
:
private
AllocPolicy
{
struct
Segment
{
char
*
mData
;
size_t
mSize
;
size_t
mCapacity
;
Segment
(
char
*
aData
size_t
aSize
size_t
aCapacity
)
:
mData
(
aData
)
mSize
(
aSize
)
mCapacity
(
aCapacity
)
{
}
Segment
(
const
Segment
&
)
=
delete
;
Segment
&
operator
=
(
const
Segment
&
)
=
delete
;
Segment
(
Segment
&
&
)
=
default
;
Segment
&
operator
=
(
Segment
&
&
)
=
default
;
char
*
Start
(
)
const
{
return
mData
;
}
char
*
End
(
)
const
{
return
mData
+
mSize
;
}
}
;
public
:
static
const
size_t
kSegmentAlignment
=
8
;
BufferList
(
size_t
aInitialSize
size_t
aInitialCapacity
size_t
aStandardCapacity
AllocPolicy
aAP
=
AllocPolicy
(
)
)
:
AllocPolicy
(
aAP
)
mOwning
(
true
)
mSize
(
0
)
mStandardCapacity
(
aStandardCapacity
)
{
MOZ_ASSERT
(
aInitialCapacity
%
kSegmentAlignment
=
=
0
)
;
MOZ_ASSERT
(
aStandardCapacity
%
kSegmentAlignment
=
=
0
)
;
if
(
aInitialCapacity
)
{
AllocateSegment
(
aInitialSize
aInitialCapacity
)
;
}
}
BufferList
(
const
BufferList
&
aOther
)
=
delete
;
BufferList
(
BufferList
&
&
aOther
)
:
mOwning
(
aOther
.
mOwning
)
mSegments
(
Move
(
aOther
.
mSegments
)
)
mSize
(
aOther
.
mSize
)
mStandardCapacity
(
aOther
.
mStandardCapacity
)
{
aOther
.
mSegments
.
clear
(
)
;
aOther
.
mSize
=
0
;
}
BufferList
&
operator
=
(
const
BufferList
&
aOther
)
=
delete
;
BufferList
&
operator
=
(
BufferList
&
&
aOther
)
{
Clear
(
)
;
mOwning
=
aOther
.
mOwning
;
mSegments
=
Move
(
aOther
.
mSegments
)
;
mSize
=
aOther
.
mSize
;
aOther
.
mSegments
.
clear
(
)
;
aOther
.
mSize
=
0
;
return
*
this
;
}
~
BufferList
(
)
{
Clear
(
)
;
}
size_t
Size
(
)
const
{
return
mSize
;
}
void
Clear
(
)
{
if
(
mOwning
)
{
for
(
Segment
&
segment
:
mSegments
)
{
this
-
>
free_
(
segment
.
mData
)
;
}
}
mSegments
.
clear
(
)
;
mSize
=
0
;
}
class
IterImpl
{
uintptr_t
mSegment
;
char
*
mData
;
char
*
mDataEnd
;
friend
class
BufferList
;
public
:
explicit
IterImpl
(
const
BufferList
&
aBuffers
)
:
mSegment
(
0
)
mData
(
nullptr
)
mDataEnd
(
nullptr
)
{
if
(
!
aBuffers
.
mSegments
.
empty
(
)
)
{
mData
=
aBuffers
.
mSegments
[
0
]
.
Start
(
)
;
mDataEnd
=
aBuffers
.
mSegments
[
0
]
.
End
(
)
;
}
}
char
*
Data
(
)
const
{
MOZ_RELEASE_ASSERT
(
!
Done
(
)
)
;
return
mData
;
}
bool
HasRoomFor
(
size_t
aBytes
)
const
{
MOZ_RELEASE_ASSERT
(
mData
<
=
mDataEnd
)
;
return
size_t
(
mDataEnd
-
mData
)
>
=
aBytes
;
}
size_t
RemainingInSegment
(
)
const
{
MOZ_RELEASE_ASSERT
(
mData
<
=
mDataEnd
)
;
return
mDataEnd
-
mData
;
}
void
Advance
(
const
BufferList
&
aBuffers
size_t
aBytes
)
{
const
Segment
&
segment
=
aBuffers
.
mSegments
[
mSegment
]
;
MOZ_RELEASE_ASSERT
(
segment
.
Start
(
)
<
=
mData
)
;
MOZ_RELEASE_ASSERT
(
mData
<
=
mDataEnd
)
;
MOZ_RELEASE_ASSERT
(
mDataEnd
=
=
segment
.
End
(
)
)
;
MOZ_RELEASE_ASSERT
(
HasRoomFor
(
aBytes
)
)
;
mData
+
=
aBytes
;
if
(
mData
=
=
mDataEnd
&
&
mSegment
+
1
<
aBuffers
.
mSegments
.
length
(
)
)
{
mSegment
+
+
;
const
Segment
&
nextSegment
=
aBuffers
.
mSegments
[
mSegment
]
;
mData
=
nextSegment
.
Start
(
)
;
mDataEnd
=
nextSegment
.
End
(
)
;
MOZ_RELEASE_ASSERT
(
mData
<
mDataEnd
)
;
}
}
bool
AdvanceAcrossSegments
(
const
BufferList
&
aBuffers
size_t
aBytes
)
{
size_t
bytes
=
aBytes
;
while
(
bytes
)
{
size_t
toAdvance
=
std
:
:
min
(
bytes
RemainingInSegment
(
)
)
;
if
(
!
toAdvance
)
{
return
false
;
}
Advance
(
aBuffers
toAdvance
)
;
bytes
-
=
toAdvance
;
}
return
true
;
}
bool
Done
(
)
const
{
return
mData
=
=
mDataEnd
;
}
}
;
char
*
Start
(
)
{
return
mSegments
[
0
]
.
mData
;
}
IterImpl
Iter
(
)
const
{
return
IterImpl
(
*
this
)
;
}
inline
bool
WriteBytes
(
const
char
*
aData
size_t
aSize
)
;
inline
bool
ReadBytes
(
IterImpl
&
aIter
char
*
aData
size_t
aSize
)
const
;
inline
bool
FlattenBytes
(
IterImpl
&
aIter
const
char
*
*
aOutData
size_t
aSize
)
;
template
<
typename
BorrowingAllocPolicy
>
BufferList
<
BorrowingAllocPolicy
>
Borrow
(
IterImpl
&
aIter
size_t
aSize
bool
*
aSuccess
BorrowingAllocPolicy
aAP
=
BorrowingAllocPolicy
(
)
)
;
BufferList
Extract
(
IterImpl
&
aIter
size_t
aSize
bool
*
aSuccess
)
;
private
:
explicit
BufferList
(
AllocPolicy
aAP
)
:
AllocPolicy
(
aAP
)
mOwning
(
false
)
mSize
(
0
)
mStandardCapacity
(
0
)
{
}
void
*
AllocateSegment
(
size_t
aSize
size_t
aCapacity
)
{
MOZ_RELEASE_ASSERT
(
mOwning
)
;
char
*
data
=
this
-
>
template
pod_malloc
<
char
>
(
aCapacity
)
;
if
(
!
data
)
{
return
nullptr
;
}
if
(
!
mSegments
.
append
(
Segment
(
data
aSize
aCapacity
)
)
)
{
this
-
>
free_
(
data
)
;
return
nullptr
;
}
mSize
+
=
aSize
;
return
data
;
}
bool
mOwning
;
Vector
<
Segment
1
AllocPolicy
>
mSegments
;
size_t
mSize
;
size_t
mStandardCapacity
;
}
;
template
<
typename
AllocPolicy
>
bool
BufferList
<
AllocPolicy
>
:
:
WriteBytes
(
const
char
*
aData
size_t
aSize
)
{
MOZ_RELEASE_ASSERT
(
mOwning
)
;
MOZ_RELEASE_ASSERT
(
mStandardCapacity
)
;
size_t
copied
=
0
;
size_t
remaining
=
aSize
;
if
(
!
mSegments
.
empty
(
)
)
{
Segment
&
lastSegment
=
mSegments
.
back
(
)
;
size_t
toCopy
=
std
:
:
min
(
aSize
lastSegment
.
mCapacity
-
lastSegment
.
mSize
)
;
memcpy
(
lastSegment
.
mData
+
lastSegment
.
mSize
aData
toCopy
)
;
lastSegment
.
mSize
+
=
toCopy
;
mSize
+
=
toCopy
;
copied
+
=
toCopy
;
remaining
-
=
toCopy
;
}
while
(
remaining
)
{
size_t
toCopy
=
std
:
:
min
(
remaining
mStandardCapacity
)
;
void
*
data
=
AllocateSegment
(
toCopy
mStandardCapacity
)
;
if
(
!
data
)
{
return
false
;
}
memcpy
(
data
aData
+
copied
toCopy
)
;
copied
+
=
toCopy
;
remaining
-
=
toCopy
;
}
return
true
;
}
template
<
typename
AllocPolicy
>
bool
BufferList
<
AllocPolicy
>
:
:
ReadBytes
(
IterImpl
&
aIter
char
*
aData
size_t
aSize
)
const
{
size_t
copied
=
0
;
size_t
remaining
=
aSize
;
while
(
remaining
)
{
size_t
toCopy
=
std
:
:
min
(
aIter
.
RemainingInSegment
(
)
remaining
)
;
if
(
!
toCopy
)
{
return
false
;
}
memcpy
(
aData
+
copied
aIter
.
Data
(
)
toCopy
)
;
copied
+
=
toCopy
;
remaining
-
=
toCopy
;
aIter
.
Advance
(
*
this
toCopy
)
;
}
return
true
;
}
template
<
typename
AllocPolicy
>
bool
BufferList
<
AllocPolicy
>
:
:
FlattenBytes
(
IterImpl
&
aIter
const
char
*
*
aOutData
size_t
aSize
)
{
MOZ_RELEASE_ASSERT
(
aSize
)
;
MOZ_RELEASE_ASSERT
(
mOwning
)
;
if
(
aIter
.
HasRoomFor
(
aSize
)
)
{
*
aOutData
=
aIter
.
Data
(
)
;
aIter
.
Advance
(
*
this
aSize
)
;
return
true
;
}
char
*
buffer
=
this
-
>
template
pod_malloc
<
char
>
(
Size
(
)
)
;
if
(
!
buffer
)
{
return
false
;
}
size_t
copied
=
0
;
size_t
offset
;
bool
found
=
false
;
for
(
size_t
i
=
0
;
i
<
mSegments
.
length
(
)
;
i
+
+
)
{
Segment
&
segment
=
mSegments
[
i
]
;
memcpy
(
buffer
+
copied
segment
.
Start
(
)
segment
.
mSize
)
;
if
(
i
=
=
aIter
.
mSegment
)
{
offset
=
copied
+
(
aIter
.
mData
-
segment
.
Start
(
)
)
;
if
(
Size
(
)
-
offset
>
=
aSize
)
{
found
=
true
;
*
aOutData
=
buffer
+
offset
;
aIter
.
mSegment
=
0
;
aIter
.
mData
=
buffer
+
offset
+
aSize
;
aIter
.
mDataEnd
=
buffer
+
Size
(
)
;
}
}
this
-
>
free_
(
segment
.
mData
)
;
copied
+
=
segment
.
mSize
;
}
mSegments
.
clear
(
)
;
mSegments
.
infallibleAppend
(
Segment
(
buffer
Size
(
)
Size
(
)
)
)
;
if
(
!
found
)
{
aIter
.
mSegment
=
0
;
aIter
.
mData
=
Start
(
)
;
aIter
.
mDataEnd
=
Start
(
)
+
Size
(
)
;
}
return
found
;
}
template
<
typename
AllocPolicy
>
template
<
typename
BorrowingAllocPolicy
>
BufferList
<
BorrowingAllocPolicy
>
BufferList
<
AllocPolicy
>
:
:
Borrow
(
IterImpl
&
aIter
size_t
aSize
bool
*
aSuccess
BorrowingAllocPolicy
aAP
)
{
BufferList
<
BorrowingAllocPolicy
>
result
(
aAP
)
;
size_t
size
=
aSize
;
while
(
size
)
{
size_t
toAdvance
=
std
:
:
min
(
size
aIter
.
RemainingInSegment
(
)
)
;
if
(
!
toAdvance
|
|
!
result
.
mSegments
.
append
(
Segment
(
aIter
.
mData
toAdvance
toAdvance
)
)
)
{
*
aSuccess
=
false
;
return
result
;
}
aIter
.
Advance
(
*
this
toAdvance
)
;
size
-
=
toAdvance
;
}
result
.
mSize
=
aSize
;
*
aSuccess
=
true
;
return
result
;
}
template
<
typename
AllocPolicy
>
BufferList
<
AllocPolicy
>
BufferList
<
AllocPolicy
>
:
:
Extract
(
IterImpl
&
aIter
size_t
aSize
bool
*
aSuccess
)
{
MOZ_RELEASE_ASSERT
(
aSize
)
;
MOZ_RELEASE_ASSERT
(
mOwning
)
;
MOZ_ASSERT
(
aSize
%
kSegmentAlignment
=
=
0
)
;
MOZ_ASSERT
(
intptr_t
(
aIter
.
mData
)
%
kSegmentAlignment
=
=
0
)
;
IterImpl
iter
=
aIter
;
size_t
size
=
aSize
;
size_t
toCopy
=
std
:
:
min
(
size
aIter
.
RemainingInSegment
(
)
)
;
MOZ_ASSERT
(
toCopy
%
kSegmentAlignment
=
=
0
)
;
BufferList
result
(
0
toCopy
mStandardCapacity
)
;
BufferList
error
(
0
0
mStandardCapacity
)
;
if
(
!
result
.
WriteBytes
(
aIter
.
mData
toCopy
)
)
{
*
aSuccess
=
false
;
return
error
;
}
iter
.
Advance
(
*
this
toCopy
)
;
size
-
=
toCopy
;
auto
resultGuard
=
MakeScopeExit
(
[
&
]
{
*
aSuccess
=
false
;
result
.
mSegments
.
erase
(
result
.
mSegments
.
begin
(
)
+
1
result
.
mSegments
.
end
(
)
)
;
}
)
;
size_t
movedSize
=
0
;
uintptr_t
toRemoveStart
=
iter
.
mSegment
;
uintptr_t
toRemoveEnd
=
iter
.
mSegment
;
while
(
!
iter
.
Done
(
)
&
&
!
iter
.
HasRoomFor
(
size
)
)
{
if
(
!
result
.
mSegments
.
append
(
Segment
(
mSegments
[
iter
.
mSegment
]
.
mData
mSegments
[
iter
.
mSegment
]
.
mSize
mSegments
[
iter
.
mSegment
]
.
mCapacity
)
)
)
{
return
error
;
}
movedSize
+
=
iter
.
RemainingInSegment
(
)
;
size
-
=
iter
.
RemainingInSegment
(
)
;
toRemoveEnd
+
+
;
iter
.
Advance
(
*
this
iter
.
RemainingInSegment
(
)
)
;
}
if
(
size
)
{
if
(
!
iter
.
HasRoomFor
(
size
)
|
|
!
result
.
WriteBytes
(
iter
.
Data
(
)
size
)
)
{
return
error
;
}
iter
.
Advance
(
*
this
size
)
;
}
mSegments
.
erase
(
mSegments
.
begin
(
)
+
toRemoveStart
mSegments
.
begin
(
)
+
toRemoveEnd
)
;
mSize
-
=
movedSize
;
aIter
.
mSegment
=
iter
.
mSegment
-
(
toRemoveEnd
-
toRemoveStart
)
;
aIter
.
mData
=
iter
.
mData
;
aIter
.
mDataEnd
=
iter
.
mDataEnd
;
MOZ_ASSERT
(
aIter
.
mDataEnd
=
=
mSegments
[
aIter
.
mSegment
]
.
End
(
)
)
;
result
.
mSize
=
aSize
;
resultGuard
.
release
(
)
;
*
aSuccess
=
true
;
return
result
;
}
}
#
endif
