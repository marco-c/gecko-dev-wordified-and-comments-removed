#
ifndef
mozilla_BufferList_h
#
define
mozilla_BufferList_h
#
include
<
algorithm
>
#
include
"
mozilla
/
AllocPolicy
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
Types
.
h
"
#
include
"
mozilla
/
TypeTraits
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
<
string
.
h
>
class
InfallibleAllocPolicy
;
namespace
mozilla
{
template
<
typename
AllocPolicy
>
class
BufferList
:
private
AllocPolicy
{
struct
Segment
{
char
*
mData
;
size_t
mSize
;
size_t
mCapacity
;
Segment
(
char
*
aData
size_t
aSize
size_t
aCapacity
)
:
mData
(
aData
)
mSize
(
aSize
)
mCapacity
(
aCapacity
)
{
}
Segment
(
const
Segment
&
)
=
delete
;
Segment
&
operator
=
(
const
Segment
&
)
=
delete
;
Segment
(
Segment
&
&
)
=
default
;
Segment
&
operator
=
(
Segment
&
&
)
=
default
;
char
*
Start
(
)
const
{
return
mData
;
}
char
*
End
(
)
const
{
return
mData
+
mSize
;
}
}
;
template
<
typename
OtherAllocPolicy
>
friend
class
BufferList
;
public
:
static
const
size_t
kSegmentAlignment
=
8
;
BufferList
(
size_t
aInitialSize
size_t
aInitialCapacity
size_t
aStandardCapacity
AllocPolicy
aAP
=
AllocPolicy
(
)
)
:
AllocPolicy
(
aAP
)
mOwning
(
true
)
mSegments
(
aAP
)
mSize
(
0
)
mStandardCapacity
(
aStandardCapacity
)
{
MOZ_ASSERT
(
aInitialCapacity
%
kSegmentAlignment
=
=
0
)
;
MOZ_ASSERT
(
aStandardCapacity
%
kSegmentAlignment
=
=
0
)
;
if
(
aInitialCapacity
)
{
MOZ_ASSERT
(
(
aInitialSize
=
=
0
|
|
IsSame
<
AllocPolicy
InfallibleAllocPolicy
>
:
:
value
)
"
BufferList
may
only
be
constructed
with
an
initial
size
when
"
"
using
an
infallible
alloc
policy
"
)
;
AllocateSegment
(
aInitialSize
aInitialCapacity
)
;
}
}
BufferList
(
const
BufferList
&
aOther
)
=
delete
;
BufferList
(
BufferList
&
&
aOther
)
:
mOwning
(
aOther
.
mOwning
)
mSegments
(
std
:
:
move
(
aOther
.
mSegments
)
)
mSize
(
aOther
.
mSize
)
mStandardCapacity
(
aOther
.
mStandardCapacity
)
{
aOther
.
mSegments
.
clear
(
)
;
aOther
.
mSize
=
0
;
}
BufferList
&
operator
=
(
const
BufferList
&
aOther
)
=
delete
;
BufferList
&
operator
=
(
BufferList
&
&
aOther
)
{
Clear
(
)
;
mOwning
=
aOther
.
mOwning
;
mSegments
=
std
:
:
move
(
aOther
.
mSegments
)
;
mSize
=
aOther
.
mSize
;
aOther
.
mSegments
.
clear
(
)
;
aOther
.
mSize
=
0
;
return
*
this
;
}
~
BufferList
(
)
{
Clear
(
)
;
}
bool
Init
(
size_t
aInitialSize
size_t
aInitialCapacity
)
{
MOZ_ASSERT
(
mSegments
.
empty
(
)
)
;
MOZ_ASSERT
(
aInitialCapacity
!
=
0
)
;
MOZ_ASSERT
(
aInitialCapacity
%
kSegmentAlignment
=
=
0
)
;
return
AllocateSegment
(
aInitialSize
aInitialCapacity
)
;
}
size_t
Size
(
)
const
{
return
mSize
;
}
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
{
size_t
size
=
mSegments
.
sizeOfExcludingThis
(
aMallocSizeOf
)
;
for
(
Segment
&
segment
:
mSegments
)
{
size
+
=
aMallocSizeOf
(
segment
.
Start
(
)
)
;
}
return
size
;
}
void
Clear
(
)
{
if
(
mOwning
)
{
for
(
Segment
&
segment
:
mSegments
)
{
this
-
>
free_
(
segment
.
mData
segment
.
mCapacity
)
;
}
}
mSegments
.
clear
(
)
;
mSize
=
0
;
}
class
IterImpl
{
uintptr_t
mSegment
;
char
*
mData
;
char
*
mDataEnd
;
friend
class
BufferList
;
public
:
explicit
IterImpl
(
const
BufferList
&
aBuffers
)
:
mSegment
(
0
)
mData
(
nullptr
)
mDataEnd
(
nullptr
)
{
if
(
!
aBuffers
.
mSegments
.
empty
(
)
)
{
mData
=
aBuffers
.
mSegments
[
0
]
.
Start
(
)
;
mDataEnd
=
aBuffers
.
mSegments
[
0
]
.
End
(
)
;
}
}
char
*
Data
(
)
const
{
MOZ_RELEASE_ASSERT
(
!
Done
(
)
)
;
return
mData
;
}
bool
HasRoomFor
(
size_t
aBytes
)
const
{
MOZ_RELEASE_ASSERT
(
mData
<
=
mDataEnd
)
;
return
size_t
(
mDataEnd
-
mData
)
>
=
aBytes
;
}
size_t
RemainingInSegment
(
)
const
{
MOZ_RELEASE_ASSERT
(
mData
<
=
mDataEnd
)
;
return
mDataEnd
-
mData
;
}
bool
HasBytesAvailable
(
const
BufferList
&
aBuffers
uint32_t
aBytes
)
const
{
if
(
RemainingInSegment
(
)
>
=
aBytes
)
{
return
true
;
}
aBytes
-
=
RemainingInSegment
(
)
;
for
(
size_t
i
=
mSegment
+
1
;
i
<
aBuffers
.
mSegments
.
length
(
)
;
i
+
+
)
{
if
(
aBuffers
.
mSegments
[
i
]
.
mSize
>
=
aBytes
)
{
return
true
;
}
aBytes
-
=
aBuffers
.
mSegments
[
i
]
.
mSize
;
}
return
false
;
}
void
Advance
(
const
BufferList
&
aBuffers
size_t
aBytes
)
{
const
Segment
&
segment
=
aBuffers
.
mSegments
[
mSegment
]
;
MOZ_RELEASE_ASSERT
(
segment
.
Start
(
)
<
=
mData
)
;
MOZ_RELEASE_ASSERT
(
mData
<
=
mDataEnd
)
;
MOZ_RELEASE_ASSERT
(
mDataEnd
=
=
segment
.
End
(
)
)
;
MOZ_RELEASE_ASSERT
(
HasRoomFor
(
aBytes
)
)
;
mData
+
=
aBytes
;
if
(
mData
=
=
mDataEnd
&
&
mSegment
+
1
<
aBuffers
.
mSegments
.
length
(
)
)
{
mSegment
+
+
;
const
Segment
&
nextSegment
=
aBuffers
.
mSegments
[
mSegment
]
;
mData
=
nextSegment
.
Start
(
)
;
mDataEnd
=
nextSegment
.
End
(
)
;
MOZ_RELEASE_ASSERT
(
mData
<
mDataEnd
)
;
}
}
bool
AdvanceAcrossSegments
(
const
BufferList
&
aBuffers
size_t
aBytes
)
{
size_t
bytes
=
aBytes
;
while
(
bytes
)
{
size_t
toAdvance
=
std
:
:
min
(
bytes
RemainingInSegment
(
)
)
;
if
(
!
toAdvance
)
{
return
false
;
}
Advance
(
aBuffers
toAdvance
)
;
bytes
-
=
toAdvance
;
}
return
true
;
}
bool
Done
(
)
const
{
return
mData
=
=
mDataEnd
;
}
private
:
size_t
BytesUntil
(
const
BufferList
&
aBuffers
const
IterImpl
&
aTarget
)
const
{
size_t
offset
=
0
;
MOZ_ASSERT
(
aTarget
.
IsIn
(
aBuffers
)
)
;
char
*
data
=
mData
;
for
(
uintptr_t
segment
=
mSegment
;
segment
<
aTarget
.
mSegment
;
segment
+
+
)
{
offset
+
=
aBuffers
.
mSegments
[
segment
]
.
End
(
)
-
data
;
data
=
aBuffers
.
mSegments
[
segment
]
.
mData
;
}
MOZ_RELEASE_ASSERT
(
IsIn
(
aBuffers
)
)
;
MOZ_RELEASE_ASSERT
(
aTarget
.
mData
>
=
data
)
;
offset
+
=
aTarget
.
mData
-
data
;
return
offset
;
}
bool
IsIn
(
const
BufferList
&
aBuffers
)
const
{
return
mSegment
<
aBuffers
.
mSegments
.
length
(
)
&
&
mData
>
=
aBuffers
.
mSegments
[
mSegment
]
.
mData
&
&
mData
<
aBuffers
.
mSegments
[
mSegment
]
.
End
(
)
;
}
}
;
char
*
Start
(
)
{
MOZ_RELEASE_ASSERT
(
!
mSegments
.
empty
(
)
)
;
return
mSegments
[
0
]
.
mData
;
}
const
char
*
Start
(
)
const
{
return
mSegments
[
0
]
.
mData
;
}
IterImpl
Iter
(
)
const
{
return
IterImpl
(
*
this
)
;
}
inline
bool
WriteBytes
(
const
char
*
aData
size_t
aSize
)
;
inline
char
*
AllocateBytes
(
size_t
aMaxSize
size_t
*
aSize
)
;
inline
bool
ReadBytes
(
IterImpl
&
aIter
char
*
aData
size_t
aSize
)
const
;
template
<
typename
BorrowingAllocPolicy
>
BufferList
<
BorrowingAllocPolicy
>
Borrow
(
IterImpl
&
aIter
size_t
aSize
bool
*
aSuccess
BorrowingAllocPolicy
aAP
=
BorrowingAllocPolicy
(
)
)
const
;
template
<
typename
OtherAllocPolicy
>
BufferList
<
OtherAllocPolicy
>
MoveFallible
(
bool
*
aSuccess
OtherAllocPolicy
aAP
=
OtherAllocPolicy
(
)
)
;
BufferList
Extract
(
IterImpl
&
aIter
size_t
aSize
bool
*
aSuccess
)
;
size_t
RangeLength
(
const
IterImpl
&
start
const
IterImpl
&
end
)
const
{
MOZ_ASSERT
(
start
.
IsIn
(
*
this
)
&
&
end
.
IsIn
(
*
this
)
)
;
return
start
.
BytesUntil
(
*
this
end
)
;
}
void
*
WriteBytesZeroCopy
(
char
*
aData
size_t
aSize
size_t
aCapacity
)
{
MOZ_ASSERT
(
aCapacity
!
=
0
)
;
MOZ_ASSERT
(
aSize
<
=
aCapacity
)
;
MOZ_ASSERT
(
mOwning
)
;
if
(
!
mSegments
.
append
(
Segment
(
aData
aSize
aCapacity
)
)
)
{
this
-
>
free_
(
aData
aCapacity
)
;
return
nullptr
;
}
mSize
+
=
aSize
;
return
aData
;
}
private
:
explicit
BufferList
(
AllocPolicy
aAP
)
:
AllocPolicy
(
aAP
)
mOwning
(
false
)
mSize
(
0
)
mStandardCapacity
(
0
)
{
}
char
*
AllocateSegment
(
size_t
aSize
size_t
aCapacity
)
{
MOZ_RELEASE_ASSERT
(
mOwning
)
;
MOZ_ASSERT
(
aCapacity
!
=
0
)
;
MOZ_ASSERT
(
aSize
<
=
aCapacity
)
;
char
*
data
=
this
-
>
template
pod_malloc
<
char
>
(
aCapacity
)
;
if
(
!
data
)
{
return
nullptr
;
}
if
(
!
mSegments
.
append
(
Segment
(
data
aSize
aCapacity
)
)
)
{
this
-
>
free_
(
data
aCapacity
)
;
return
nullptr
;
}
mSize
+
=
aSize
;
return
data
;
}
bool
mOwning
;
Vector
<
Segment
1
AllocPolicy
>
mSegments
;
size_t
mSize
;
size_t
mStandardCapacity
;
}
;
template
<
typename
AllocPolicy
>
bool
BufferList
<
AllocPolicy
>
:
:
WriteBytes
(
const
char
*
aData
size_t
aSize
)
{
MOZ_RELEASE_ASSERT
(
mOwning
)
;
MOZ_RELEASE_ASSERT
(
mStandardCapacity
)
;
size_t
copied
=
0
;
while
(
copied
<
aSize
)
{
size_t
toCopy
;
char
*
data
=
AllocateBytes
(
aSize
-
copied
&
toCopy
)
;
if
(
!
data
)
{
return
false
;
}
memcpy
(
data
aData
+
copied
toCopy
)
;
copied
+
=
toCopy
;
}
return
true
;
}
template
<
typename
AllocPolicy
>
char
*
BufferList
<
AllocPolicy
>
:
:
AllocateBytes
(
size_t
aMaxSize
size_t
*
aSize
)
{
MOZ_RELEASE_ASSERT
(
mOwning
)
;
MOZ_RELEASE_ASSERT
(
mStandardCapacity
)
;
if
(
!
mSegments
.
empty
(
)
)
{
Segment
&
lastSegment
=
mSegments
.
back
(
)
;
size_t
capacity
=
lastSegment
.
mCapacity
-
lastSegment
.
mSize
;
if
(
capacity
)
{
size_t
size
=
std
:
:
min
(
aMaxSize
capacity
)
;
char
*
data
=
lastSegment
.
mData
+
lastSegment
.
mSize
;
lastSegment
.
mSize
+
=
size
;
mSize
+
=
size
;
*
aSize
=
size
;
return
data
;
}
}
size_t
size
=
std
:
:
min
(
aMaxSize
mStandardCapacity
)
;
char
*
data
=
AllocateSegment
(
size
mStandardCapacity
)
;
if
(
data
)
{
*
aSize
=
size
;
}
return
data
;
}
template
<
typename
AllocPolicy
>
bool
BufferList
<
AllocPolicy
>
:
:
ReadBytes
(
IterImpl
&
aIter
char
*
aData
size_t
aSize
)
const
{
size_t
copied
=
0
;
size_t
remaining
=
aSize
;
while
(
remaining
)
{
size_t
toCopy
=
std
:
:
min
(
aIter
.
RemainingInSegment
(
)
remaining
)
;
if
(
!
toCopy
)
{
return
false
;
}
memcpy
(
aData
+
copied
aIter
.
Data
(
)
toCopy
)
;
copied
+
=
toCopy
;
remaining
-
=
toCopy
;
aIter
.
Advance
(
*
this
toCopy
)
;
}
return
true
;
}
template
<
typename
AllocPolicy
>
template
<
typename
BorrowingAllocPolicy
>
BufferList
<
BorrowingAllocPolicy
>
BufferList
<
AllocPolicy
>
:
:
Borrow
(
IterImpl
&
aIter
size_t
aSize
bool
*
aSuccess
BorrowingAllocPolicy
aAP
)
const
{
BufferList
<
BorrowingAllocPolicy
>
result
(
aAP
)
;
size_t
size
=
aSize
;
while
(
size
)
{
size_t
toAdvance
=
std
:
:
min
(
size
aIter
.
RemainingInSegment
(
)
)
;
if
(
!
toAdvance
|
|
!
result
.
mSegments
.
append
(
typename
BufferList
<
BorrowingAllocPolicy
>
:
:
Segment
(
aIter
.
mData
toAdvance
toAdvance
)
)
)
{
*
aSuccess
=
false
;
return
result
;
}
aIter
.
Advance
(
*
this
toAdvance
)
;
size
-
=
toAdvance
;
}
result
.
mSize
=
aSize
;
*
aSuccess
=
true
;
return
result
;
}
template
<
typename
AllocPolicy
>
template
<
typename
OtherAllocPolicy
>
BufferList
<
OtherAllocPolicy
>
BufferList
<
AllocPolicy
>
:
:
MoveFallible
(
bool
*
aSuccess
OtherAllocPolicy
aAP
)
{
BufferList
<
OtherAllocPolicy
>
result
(
0
0
mStandardCapacity
aAP
)
;
IterImpl
iter
=
Iter
(
)
;
while
(
!
iter
.
Done
(
)
)
{
size_t
toAdvance
=
iter
.
RemainingInSegment
(
)
;
if
(
!
toAdvance
|
|
!
result
.
mSegments
.
append
(
typename
BufferList
<
OtherAllocPolicy
>
:
:
Segment
(
iter
.
mData
toAdvance
toAdvance
)
)
)
{
*
aSuccess
=
false
;
result
.
mSegments
.
clear
(
)
;
return
result
;
}
iter
.
Advance
(
*
this
toAdvance
)
;
}
result
.
mSize
=
mSize
;
mSegments
.
clear
(
)
;
mSize
=
0
;
*
aSuccess
=
true
;
return
result
;
}
template
<
typename
AllocPolicy
>
BufferList
<
AllocPolicy
>
BufferList
<
AllocPolicy
>
:
:
Extract
(
IterImpl
&
aIter
size_t
aSize
bool
*
aSuccess
)
{
MOZ_RELEASE_ASSERT
(
aSize
)
;
MOZ_RELEASE_ASSERT
(
mOwning
)
;
MOZ_ASSERT
(
aSize
%
kSegmentAlignment
=
=
0
)
;
MOZ_ASSERT
(
intptr_t
(
aIter
.
mData
)
%
kSegmentAlignment
=
=
0
)
;
auto
failure
=
[
this
aSuccess
]
(
)
{
*
aSuccess
=
false
;
return
BufferList
(
0
0
mStandardCapacity
)
;
}
;
size_t
segmentsNeeded
=
0
;
Maybe
<
size_t
>
lastSegmentSize
;
{
IterImpl
iter
=
aIter
;
size_t
remaining
=
aSize
;
while
(
!
iter
.
Done
(
)
&
&
remaining
&
&
remaining
>
=
iter
.
RemainingInSegment
(
)
)
{
remaining
-
=
iter
.
RemainingInSegment
(
)
;
iter
.
Advance
(
*
this
iter
.
RemainingInSegment
(
)
)
;
segmentsNeeded
+
+
;
}
if
(
remaining
)
{
if
(
iter
.
Done
(
)
)
{
return
failure
(
)
;
}
lastSegmentSize
.
emplace
(
remaining
)
;
segmentsNeeded
+
+
;
}
}
BufferList
result
(
0
0
mStandardCapacity
)
;
if
(
!
result
.
mSegments
.
reserve
(
segmentsNeeded
+
lastSegmentSize
.
isSome
(
)
)
)
{
return
failure
(
)
;
}
size_t
firstSegmentSize
=
std
:
:
min
(
aSize
aIter
.
RemainingInSegment
(
)
)
;
if
(
!
result
.
WriteBytes
(
aIter
.
Data
(
)
firstSegmentSize
)
)
{
return
failure
(
)
;
}
aIter
.
Advance
(
*
this
firstSegmentSize
)
;
segmentsNeeded
-
-
;
if
(
segmentsNeeded
)
{
char
*
finalSegment
=
nullptr
;
if
(
lastSegmentSize
.
isSome
(
)
)
{
MOZ_RELEASE_ASSERT
(
mStandardCapacity
>
=
*
lastSegmentSize
)
;
finalSegment
=
this
-
>
template
pod_malloc
<
char
>
(
mStandardCapacity
)
;
if
(
!
finalSegment
)
{
return
failure
(
)
;
}
}
size_t
copyStart
=
aIter
.
mSegment
;
size_t
segmentsToCopy
=
segmentsNeeded
-
lastSegmentSize
.
isSome
(
)
;
for
(
size_t
i
=
0
;
i
<
segmentsToCopy
;
+
+
i
)
{
result
.
mSegments
.
infallibleAppend
(
Segment
(
mSegments
[
aIter
.
mSegment
]
.
mData
mSegments
[
aIter
.
mSegment
]
.
mSize
mSegments
[
aIter
.
mSegment
]
.
mCapacity
)
)
;
aIter
.
Advance
(
*
this
aIter
.
RemainingInSegment
(
)
)
;
}
MOZ_RELEASE_ASSERT
(
(
aIter
.
mSegment
=
=
copyStart
+
segmentsToCopy
)
|
|
(
aIter
.
Done
(
)
&
&
aIter
.
mSegment
=
=
copyStart
+
segmentsToCopy
-
1
)
)
;
mSegments
.
erase
(
mSegments
.
begin
(
)
+
copyStart
mSegments
.
begin
(
)
+
copyStart
+
segmentsToCopy
)
;
aIter
.
mSegment
-
=
segmentsToCopy
;
if
(
lastSegmentSize
.
isSome
(
)
)
{
result
.
mSegments
.
infallibleAppend
(
Segment
(
finalSegment
0
mStandardCapacity
)
)
;
bool
r
=
result
.
WriteBytes
(
aIter
.
Data
(
)
*
lastSegmentSize
)
;
MOZ_RELEASE_ASSERT
(
r
)
;
aIter
.
Advance
(
*
this
*
lastSegmentSize
)
;
}
}
mSize
-
=
aSize
;
result
.
mSize
=
aSize
;
*
aSuccess
=
true
;
return
result
;
}
}
#
endif
