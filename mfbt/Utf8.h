#
ifndef
mozilla_Utf8_h
#
define
mozilla_Utf8_h
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
TextUtils
.
h
"
#
include
"
mozilla
/
Types
.
h
"
#
include
<
limits
.
h
>
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
namespace
mozilla
{
union
Utf8Unit
;
static_assert
(
CHAR_BIT
=
=
8
"
Utf8Unit
won
'
t
work
so
well
with
non
-
octet
chars
"
)
;
union
Utf8Unit
{
private
:
char
mValue
;
public
:
explicit
constexpr
Utf8Unit
(
char
aUnit
)
:
mValue
(
aUnit
)
{
}
explicit
constexpr
Utf8Unit
(
unsigned
char
aUnit
)
:
mValue
(
static_cast
<
char
>
(
aUnit
)
)
{
}
constexpr
bool
operator
=
=
(
const
Utf8Unit
&
aOther
)
const
{
return
mValue
=
=
aOther
.
mValue
;
}
constexpr
bool
operator
!
=
(
const
Utf8Unit
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
constexpr
char
toChar
(
)
const
{
return
mValue
;
}
constexpr
unsigned
char
toUnsignedChar
(
)
const
{
return
static_cast
<
unsigned
char
>
(
mValue
)
;
}
constexpr
uint8_t
toUint8
(
)
const
{
return
static_cast
<
uint8_t
>
(
mValue
)
;
}
}
;
inline
bool
IsAscii
(
Utf8Unit
aUnit
)
{
return
IsAscii
(
aUnit
.
toUint8
(
)
)
;
}
extern
MFBT_API
bool
IsValidUtf8
(
const
void
*
aCodeUnits
size_t
aCount
)
;
inline
bool
IsTrailingUnit
(
Utf8Unit
aUnit
)
{
return
(
aUnit
.
toUint8
(
)
&
0b1100
'
0000
)
=
=
0b1000
'
0000
;
}
template
<
typename
Iter
typename
EndIter
class
OnBadLeadUnit
class
OnNotEnoughUnits
class
OnBadTrailingUnit
class
OnBadCodePoint
class
OnNotShortestForm
>
MOZ_ALWAYS_INLINE
Maybe
<
char32_t
>
DecodeOneUtf8CodePointInline
(
const
Utf8Unit
aLeadUnit
Iter
*
aIter
const
EndIter
aEnd
OnBadLeadUnit
aOnBadLeadUnit
OnNotEnoughUnits
aOnNotEnoughUnits
OnBadTrailingUnit
aOnBadTrailingUnit
OnBadCodePoint
aOnBadCodePoint
OnNotShortestForm
aOnNotShortestForm
)
{
MOZ_ASSERT
(
Utf8Unit
(
(
*
aIter
)
[
-
1
]
)
=
=
aLeadUnit
)
;
char32_t
n
=
aLeadUnit
.
toUint8
(
)
;
MOZ_ASSERT
(
!
IsAscii
(
n
)
)
;
uint8_t
remaining
;
uint32_t
min
;
if
(
(
n
&
0b1110
'
0000
)
=
=
0b1100
'
0000
)
{
remaining
=
1
;
min
=
0x80
;
n
&
=
0b0001
'
1111
;
}
else
if
(
(
n
&
0b1111
'
0000
)
=
=
0b1110
'
0000
)
{
remaining
=
2
;
min
=
0x800
;
n
&
=
0b0000
'
1111
;
}
else
if
(
(
n
&
0b1111
'
1000
)
=
=
0b1111
'
0000
)
{
remaining
=
3
;
min
=
0x10000
;
n
&
=
0b0000
'
0111
;
}
else
{
*
aIter
-
=
1
;
aOnBadLeadUnit
(
)
;
return
Nothing
(
)
;
}
auto
actual
=
aEnd
-
*
aIter
;
if
(
MOZ_UNLIKELY
(
actual
<
remaining
)
)
{
*
aIter
-
=
1
;
aOnNotEnoughUnits
(
AssertedCast
<
uint8_t
>
(
actual
+
1
)
remaining
+
1
)
;
return
Nothing
(
)
;
}
for
(
uint8_t
i
=
0
;
i
<
remaining
;
i
+
+
)
{
const
Utf8Unit
unit
(
*
(
*
aIter
)
+
+
)
;
if
(
MOZ_UNLIKELY
(
!
IsTrailingUnit
(
unit
)
)
)
{
uint8_t
unitsObserved
=
i
+
1
+
1
;
*
aIter
-
=
unitsObserved
;
aOnBadTrailingUnit
(
unitsObserved
)
;
return
Nothing
(
)
;
}
n
=
(
n
<
<
6
)
|
(
unit
.
toUint8
(
)
&
0b0011
'
1111
)
;
}
if
(
MOZ_UNLIKELY
(
n
>
0x10FFFF
|
|
(
0xD800
<
=
n
&
&
n
<
=
0xDFFF
)
)
)
{
uint8_t
unitsObserved
=
remaining
+
1
;
*
aIter
-
=
unitsObserved
;
aOnBadCodePoint
(
n
unitsObserved
)
;
return
Nothing
(
)
;
}
if
(
MOZ_UNLIKELY
(
n
<
min
)
)
{
uint8_t
unitsObserved
=
remaining
+
1
;
*
aIter
-
=
unitsObserved
;
aOnNotShortestForm
(
n
unitsObserved
)
;
return
Nothing
(
)
;
}
return
Some
(
n
)
;
}
template
<
typename
Iter
typename
EndIter
class
OnBadLeadUnit
class
OnNotEnoughUnits
class
OnBadTrailingUnit
class
OnBadCodePoint
class
OnNotShortestForm
>
inline
Maybe
<
char32_t
>
DecodeOneUtf8CodePoint
(
const
Utf8Unit
aLeadUnit
Iter
*
aIter
const
EndIter
aEnd
OnBadLeadUnit
aOnBadLeadUnit
OnNotEnoughUnits
aOnNotEnoughUnits
OnBadTrailingUnit
aOnBadTrailingUnit
OnBadCodePoint
aOnBadCodePoint
OnNotShortestForm
aOnNotShortestForm
)
{
return
DecodeOneUtf8CodePointInline
(
aLeadUnit
aIter
aEnd
aOnBadLeadUnit
aOnNotEnoughUnits
aOnBadTrailingUnit
aOnBadCodePoint
aOnNotShortestForm
)
;
}
template
<
typename
Iter
typename
EndIter
>
MOZ_ALWAYS_INLINE
Maybe
<
char32_t
>
DecodeOneUtf8CodePointInline
(
const
Utf8Unit
aLeadUnit
Iter
*
aIter
const
EndIter
aEnd
)
{
auto
onBadLeadUnit
=
[
]
(
)
{
}
;
auto
onNotEnoughUnits
=
[
]
(
uint8_t
aUnitsAvailable
uint8_t
aUnitsNeeded
)
{
}
;
auto
onBadTrailingUnit
=
[
]
(
uint8_t
aUnitsObserved
)
{
}
;
auto
onBadCodePoint
=
[
]
(
char32_t
aBadCodePoint
uint8_t
aUnitsObserved
)
{
}
;
auto
onNotShortestForm
=
[
]
(
char32_t
aBadCodePoint
uint8_t
aUnitsObserved
)
{
}
;
return
DecodeOneUtf8CodePointInline
(
aLeadUnit
aIter
aEnd
onBadLeadUnit
onNotEnoughUnits
onBadTrailingUnit
onBadCodePoint
onNotShortestForm
)
;
}
template
<
typename
Iter
typename
EndIter
>
inline
Maybe
<
char32_t
>
DecodeOneUtf8CodePoint
(
const
Utf8Unit
aLeadUnit
Iter
*
aIter
const
EndIter
aEnd
)
{
return
DecodeOneUtf8CodePointInline
(
aLeadUnit
aIter
aEnd
)
;
}
}
#
endif
