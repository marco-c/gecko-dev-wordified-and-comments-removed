#
ifndef
mozilla_NonDereferenceable_h
#
define
mozilla_NonDereferenceable_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
TypeTraits
.
h
"
#
include
<
cstdint
>
#
if
defined
(
__clang__
)
#
define
NO_POINTEE_CHECKS
__attribute__
(
(
no_sanitize
(
"
vptr
"
)
)
)
#
else
#
define
NO_POINTEE_CHECKS
#
endif
namespace
mozilla
{
template
<
typename
T
>
class
NonDereferenceable
{
public
:
NonDereferenceable
(
)
:
mPtr
(
nullptr
)
{
}
NO_POINTEE_CHECKS
NonDereferenceable
(
const
NonDereferenceable
&
)
=
default
;
NO_POINTEE_CHECKS
NonDereferenceable
<
T
>
&
operator
=
(
const
NonDereferenceable
&
)
=
default
;
NO_POINTEE_CHECKS
explicit
NonDereferenceable
(
T
*
aPtr
)
:
mPtr
(
aPtr
)
{
}
NO_POINTEE_CHECKS
NonDereferenceable
&
operator
=
(
T
*
aPtr
)
{
mPtr
=
aPtr
;
return
*
this
;
}
template
<
typename
U
>
NO_POINTEE_CHECKS
explicit
NonDereferenceable
(
U
*
aOther
)
:
mPtr
(
static_cast
<
T
*
>
(
aOther
)
)
{
}
template
<
typename
U
>
NO_POINTEE_CHECKS
NonDereferenceable
&
operator
=
(
U
*
aOther
)
{
mPtr
=
static_cast
<
T
*
>
(
aOther
)
;
return
*
this
;
}
template
<
typename
U
>
NO_POINTEE_CHECKS
MOZ_IMPLICIT
NonDereferenceable
(
const
NonDereferenceable
<
U
>
&
aOther
)
:
mPtr
(
static_cast
<
T
*
>
(
aOther
.
mPtr
)
)
{
}
template
<
typename
U
>
NO_POINTEE_CHECKS
NonDereferenceable
&
operator
=
(
const
NonDereferenceable
<
U
>
&
aOther
)
{
mPtr
=
static_cast
<
T
*
>
(
aOther
.
mPtr
)
;
return
*
this
;
}
T
&
operator
*
(
)
=
delete
;
T
*
operator
-
>
(
)
=
delete
;
NO_POINTEE_CHECKS
explicit
operator
bool
(
)
const
{
return
!
!
mPtr
;
}
NO_POINTEE_CHECKS
uintptr_t
value
(
)
const
{
return
reinterpret_cast
<
uintptr_t
>
(
mPtr
)
;
}
private
:
template
<
typename
>
friend
class
NonDereferenceable
;
T
*
MOZ_NON_OWNING_REF
mPtr
;
}
;
}
#
undef
NO_POINTEE_CHECKS
#
endif
