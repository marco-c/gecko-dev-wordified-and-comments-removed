#
ifndef
mozilla_PairHash_h
#
define
mozilla_PairHash_h
#
include
"
mozilla
/
CompactPair
.
h
"
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
<
utility
>
namespace
mozilla
{
template
<
typename
U
typename
V
>
[
[
nodiscard
]
]
inline
HashNumber
HashPair
(
const
std
:
:
pair
<
U
V
>
&
pair
)
{
return
HashGeneric
(
pair
.
first
pair
.
second
)
;
}
template
<
typename
U
typename
V
>
[
[
nodiscard
]
]
inline
HashNumber
HashCompactPair
(
const
CompactPair
<
U
V
>
&
pair
)
{
return
HashGeneric
(
pair
.
first
(
)
pair
.
second
(
)
)
;
}
template
<
typename
T
typename
U
>
struct
PairHasher
{
using
Key
=
std
:
:
pair
<
T
U
>
;
using
Lookup
=
Key
;
static
HashNumber
hash
(
const
Lookup
&
aLookup
)
{
return
HashPair
(
aLookup
)
;
}
static
bool
match
(
const
Key
&
aKey
const
Lookup
&
aLookup
)
{
return
aKey
=
=
aLookup
;
}
static
void
rekey
(
Key
&
aKey
const
Key
&
aNewKey
)
{
aKey
=
aNewKey
;
}
}
;
template
<
typename
T
typename
U
>
struct
CompactPairHasher
{
using
Key
=
CompactPair
<
T
U
>
;
using
Lookup
=
Key
;
static
HashNumber
hash
(
const
Lookup
&
aLookup
)
{
return
HashCompactPair
(
aLookup
)
;
}
static
bool
match
(
const
Key
&
aKey
const
Lookup
&
aLookup
)
{
return
aKey
=
=
aLookup
;
}
static
void
rekey
(
Key
&
aKey
const
Key
&
aNewKey
)
{
aKey
=
aNewKey
;
}
}
;
}
#
endif
