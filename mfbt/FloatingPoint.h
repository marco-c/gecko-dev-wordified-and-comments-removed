#
ifndef
mozilla_FloatingPoint_h
#
define
mozilla_FloatingPoint_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
MemoryChecking
.
h
"
#
include
"
mozilla
/
Types
.
h
"
#
include
"
mozilla
/
TypeTraits
.
h
"
#
include
<
limits
>
#
include
<
stdint
.
h
>
namespace
mozilla
{
struct
FloatTypeTraits
{
using
Bits
=
uint32_t
;
static
constexpr
unsigned
kExponentBias
=
127
;
static
constexpr
unsigned
kExponentShift
=
23
;
static
constexpr
Bits
kSignBit
=
0x80000000UL
;
static
constexpr
Bits
kExponentBits
=
0x7F800000UL
;
static
constexpr
Bits
kSignificandBits
=
0x007FFFFFUL
;
}
;
struct
DoubleTypeTraits
{
using
Bits
=
uint64_t
;
static
constexpr
unsigned
kExponentBias
=
1023
;
static
constexpr
unsigned
kExponentShift
=
52
;
static
constexpr
Bits
kSignBit
=
0x8000000000000000ULL
;
static
constexpr
Bits
kExponentBits
=
0x7ff0000000000000ULL
;
static
constexpr
Bits
kSignificandBits
=
0x000fffffffffffffULL
;
}
;
template
<
typename
T
>
struct
SelectTrait
;
template
<
>
struct
SelectTrait
<
float
>
:
public
FloatTypeTraits
{
}
;
template
<
>
struct
SelectTrait
<
double
>
:
public
DoubleTypeTraits
{
}
;
template
<
typename
T
>
struct
FloatingPoint
:
public
SelectTrait
<
T
>
{
using
Base
=
SelectTrait
<
T
>
;
using
Bits
=
typename
Base
:
:
Bits
;
static_assert
(
(
Base
:
:
kSignBit
&
Base
:
:
kExponentBits
)
=
=
0
"
sign
bit
shouldn
'
t
overlap
exponent
bits
"
)
;
static_assert
(
(
Base
:
:
kSignBit
&
Base
:
:
kSignificandBits
)
=
=
0
"
sign
bit
shouldn
'
t
overlap
significand
bits
"
)
;
static_assert
(
(
Base
:
:
kExponentBits
&
Base
:
:
kSignificandBits
)
=
=
0
"
exponent
bits
shouldn
'
t
overlap
significand
bits
"
)
;
static_assert
(
(
Base
:
:
kSignBit
|
Base
:
:
kExponentBits
|
Base
:
:
kSignificandBits
)
=
=
~
Bits
(
0
)
"
all
bits
accounted
for
"
)
;
static_assert
(
sizeof
(
T
)
=
=
sizeof
(
Bits
)
"
Bits
must
be
same
size
as
T
"
)
;
}
;
template
<
typename
T
>
static
MOZ_ALWAYS_INLINE
bool
IsNaN
(
T
aValue
)
{
typedef
FloatingPoint
<
T
>
Traits
;
typedef
typename
Traits
:
:
Bits
Bits
;
return
(
BitwiseCast
<
Bits
>
(
aValue
)
&
Traits
:
:
kExponentBits
)
=
=
Traits
:
:
kExponentBits
&
&
(
BitwiseCast
<
Bits
>
(
aValue
)
&
Traits
:
:
kSignificandBits
)
!
=
0
;
}
template
<
typename
T
>
static
MOZ_ALWAYS_INLINE
bool
IsInfinite
(
T
aValue
)
{
typedef
FloatingPoint
<
T
>
Traits
;
typedef
typename
Traits
:
:
Bits
Bits
;
Bits
bits
=
BitwiseCast
<
Bits
>
(
aValue
)
;
return
(
bits
&
~
Traits
:
:
kSignBit
)
=
=
Traits
:
:
kExponentBits
;
}
template
<
typename
T
>
static
MOZ_ALWAYS_INLINE
bool
IsFinite
(
T
aValue
)
{
typedef
FloatingPoint
<
T
>
Traits
;
typedef
typename
Traits
:
:
Bits
Bits
;
Bits
bits
=
BitwiseCast
<
Bits
>
(
aValue
)
;
return
(
bits
&
Traits
:
:
kExponentBits
)
!
=
Traits
:
:
kExponentBits
;
}
template
<
typename
T
>
static
MOZ_ALWAYS_INLINE
bool
IsNegative
(
T
aValue
)
{
MOZ_ASSERT
(
!
IsNaN
(
aValue
)
"
NaN
does
not
have
a
sign
"
)
;
typedef
FloatingPoint
<
T
>
Traits
;
typedef
typename
Traits
:
:
Bits
Bits
;
Bits
bits
=
BitwiseCast
<
Bits
>
(
aValue
)
;
return
(
bits
&
Traits
:
:
kSignBit
)
!
=
0
;
}
template
<
typename
T
>
static
MOZ_ALWAYS_INLINE
bool
IsNegativeZero
(
T
aValue
)
{
typedef
FloatingPoint
<
T
>
Traits
;
typedef
typename
Traits
:
:
Bits
Bits
;
Bits
bits
=
BitwiseCast
<
Bits
>
(
aValue
)
;
return
bits
=
=
Traits
:
:
kSignBit
;
}
template
<
typename
T
>
static
MOZ_ALWAYS_INLINE
bool
IsPositiveZero
(
T
aValue
)
{
typedef
FloatingPoint
<
T
>
Traits
;
typedef
typename
Traits
:
:
Bits
Bits
;
Bits
bits
=
BitwiseCast
<
Bits
>
(
aValue
)
;
return
bits
=
=
0
;
}
template
<
typename
T
>
static
MOZ_ALWAYS_INLINE
T
ToZeroIfNonfinite
(
T
aValue
)
{
return
IsFinite
(
aValue
)
?
aValue
:
0
;
}
template
<
typename
T
>
static
MOZ_ALWAYS_INLINE
int_fast16_t
ExponentComponent
(
T
aValue
)
{
typedef
FloatingPoint
<
T
>
Traits
;
typedef
typename
Traits
:
:
Bits
Bits
;
Bits
bits
=
BitwiseCast
<
Bits
>
(
aValue
)
;
return
int_fast16_t
(
(
bits
&
Traits
:
:
kExponentBits
)
>
>
Traits
:
:
kExponentShift
)
-
int_fast16_t
(
Traits
:
:
kExponentBias
)
;
}
template
<
typename
T
>
static
MOZ_ALWAYS_INLINE
T
PositiveInfinity
(
)
{
typedef
FloatingPoint
<
T
>
Traits
;
return
BitwiseCast
<
T
>
(
Traits
:
:
kExponentBits
)
;
}
template
<
typename
T
>
static
MOZ_ALWAYS_INLINE
T
NegativeInfinity
(
)
{
typedef
FloatingPoint
<
T
>
Traits
;
return
BitwiseCast
<
T
>
(
Traits
:
:
kSignBit
|
Traits
:
:
kExponentBits
)
;
}
template
<
typename
T
int
SignBit
typename
FloatingPoint
<
T
>
:
:
Bits
Significand
>
struct
SpecificNaNBits
{
using
Traits
=
FloatingPoint
<
T
>
;
static_assert
(
SignBit
=
=
0
|
|
SignBit
=
=
1
"
bad
sign
bit
"
)
;
static_assert
(
(
Significand
&
~
Traits
:
:
kSignificandBits
)
=
=
0
"
significand
must
only
have
significand
bits
set
"
)
;
static_assert
(
Significand
&
Traits
:
:
kSignificandBits
"
significand
must
be
nonzero
"
)
;
static
constexpr
typename
Traits
:
:
Bits
value
=
(
SignBit
*
Traits
:
:
kSignBit
)
|
Traits
:
:
kExponentBits
|
Significand
;
}
;
template
<
typename
T
>
static
MOZ_ALWAYS_INLINE
void
SpecificNaN
(
int
signbit
typename
FloatingPoint
<
T
>
:
:
Bits
significand
T
*
result
)
{
typedef
FloatingPoint
<
T
>
Traits
;
MOZ_ASSERT
(
signbit
=
=
0
|
|
signbit
=
=
1
)
;
MOZ_ASSERT
(
(
significand
&
~
Traits
:
:
kSignificandBits
)
=
=
0
)
;
MOZ_ASSERT
(
significand
&
Traits
:
:
kSignificandBits
)
;
BitwiseCast
<
T
>
(
(
signbit
?
Traits
:
:
kSignBit
:
0
)
|
Traits
:
:
kExponentBits
|
significand
result
)
;
MOZ_ASSERT
(
IsNaN
(
*
result
)
)
;
}
template
<
typename
T
>
static
MOZ_ALWAYS_INLINE
T
SpecificNaN
(
int
signbit
typename
FloatingPoint
<
T
>
:
:
Bits
significand
)
{
T
t
;
SpecificNaN
(
signbit
significand
&
t
)
;
return
t
;
}
template
<
typename
T
>
static
MOZ_ALWAYS_INLINE
T
MinNumberValue
(
)
{
typedef
FloatingPoint
<
T
>
Traits
;
typedef
typename
Traits
:
:
Bits
Bits
;
return
BitwiseCast
<
T
>
(
Bits
(
1
)
)
;
}
namespace
detail
{
template
<
typename
Float
typename
SignedInteger
>
inline
bool
NumberEqualsSignedInteger
(
Float
aValue
SignedInteger
*
aInteger
)
{
static_assert
(
IsSame
<
Float
float
>
:
:
value
|
|
IsSame
<
Float
double
>
:
:
value
"
Float
must
be
an
IEEE
-
754
floating
point
type
"
)
;
static_assert
(
IsSigned
<
SignedInteger
>
:
:
value
"
this
algorithm
only
works
for
signed
types
:
a
different
one
"
"
will
be
required
for
unsigned
types
"
)
;
static_assert
(
sizeof
(
SignedInteger
)
>
=
sizeof
(
int
)
"
this
function
*
might
*
require
some
finessing
for
signed
types
"
"
subject
to
integral
promotion
before
it
can
be
used
on
them
"
)
;
MOZ_MAKE_MEM_UNDEFINED
(
aInteger
sizeof
(
*
aInteger
)
)
;
if
(
!
IsFinite
(
aValue
)
)
{
return
false
;
}
constexpr
SignedInteger
MaxIntValue
=
std
:
:
numeric_limits
<
SignedInteger
>
:
:
max
(
)
;
constexpr
SignedInteger
MinValue
=
std
:
:
numeric_limits
<
SignedInteger
>
:
:
min
(
)
;
static_assert
(
IsPowerOfTwo
(
Abs
(
MinValue
)
)
"
MinValue
should
be
is
a
small
power
of
two
thus
exactly
"
"
representable
in
float
/
double
both
"
)
;
constexpr
unsigned
SignedIntegerWidth
=
CHAR_BIT
*
sizeof
(
SignedInteger
)
;
constexpr
unsigned
ExponentShift
=
FloatingPoint
<
Float
>
:
:
kExponentShift
;
constexpr
unsigned
PrecisionExceededShiftAmount
=
ExponentShift
>
SignedIntegerWidth
-
1
?
0
:
SignedIntegerWidth
-
2
-
ExponentShift
;
constexpr
SignedInteger
MaxValue
=
ExponentShift
>
SignedIntegerWidth
-
1
?
MaxIntValue
:
SignedInteger
(
(
uint64_t
(
1
)
<
<
(
SignedIntegerWidth
-
1
)
)
-
(
uint64_t
(
1
)
<
<
PrecisionExceededShiftAmount
)
)
;
if
(
static_cast
<
Float
>
(
MinValue
)
<
=
aValue
&
&
aValue
<
=
static_cast
<
Float
>
(
MaxValue
)
)
{
auto
possible
=
static_cast
<
SignedInteger
>
(
aValue
)
;
if
(
static_cast
<
Float
>
(
possible
)
=
=
aValue
)
{
*
aInteger
=
possible
;
return
true
;
}
}
return
false
;
}
template
<
typename
Float
typename
SignedInteger
>
inline
bool
NumberIsSignedInteger
(
Float
aValue
SignedInteger
*
aInteger
)
{
static_assert
(
IsSame
<
Float
float
>
:
:
value
|
|
IsSame
<
Float
double
>
:
:
value
"
Float
must
be
an
IEEE
-
754
floating
point
type
"
)
;
static_assert
(
IsSigned
<
SignedInteger
>
:
:
value
"
this
algorithm
only
works
for
signed
types
:
a
different
one
"
"
will
be
required
for
unsigned
types
"
)
;
static_assert
(
sizeof
(
SignedInteger
)
>
=
sizeof
(
int
)
"
this
function
*
might
*
require
some
finessing
for
signed
types
"
"
subject
to
integral
promotion
before
it
can
be
used
on
them
"
)
;
MOZ_MAKE_MEM_UNDEFINED
(
aInteger
sizeof
(
*
aInteger
)
)
;
if
(
IsNegativeZero
(
aValue
)
)
{
return
false
;
}
return
NumberEqualsSignedInteger
(
aValue
aInteger
)
;
}
}
template
<
typename
T
>
static
MOZ_ALWAYS_INLINE
bool
NumberIsInt32
(
T
aValue
int32_t
*
aInt32
)
{
return
detail
:
:
NumberIsSignedInteger
(
aValue
aInt32
)
;
}
template
<
typename
T
>
static
MOZ_ALWAYS_INLINE
bool
NumberEqualsInt32
(
T
aValue
int32_t
*
aInt32
)
{
return
detail
:
:
NumberEqualsSignedInteger
(
aValue
aInt32
)
;
}
template
<
typename
T
>
static
MOZ_ALWAYS_INLINE
T
UnspecifiedNaN
(
)
{
typedef
FloatingPoint
<
T
>
Traits
;
return
SpecificNaN
<
T
>
(
1
Traits
:
:
kSignificandBits
)
;
}
template
<
typename
T
>
static
inline
bool
NumbersAreIdentical
(
T
aValue1
T
aValue2
)
{
typedef
FloatingPoint
<
T
>
Traits
;
typedef
typename
Traits
:
:
Bits
Bits
;
if
(
IsNaN
(
aValue1
)
)
{
return
IsNaN
(
aValue2
)
;
}
return
BitwiseCast
<
Bits
>
(
aValue1
)
=
=
BitwiseCast
<
Bits
>
(
aValue2
)
;
}
namespace
detail
{
template
<
typename
T
>
struct
FuzzyEqualsEpsilon
;
template
<
>
struct
FuzzyEqualsEpsilon
<
float
>
{
static
float
value
(
)
{
return
1
.
0f
/
(
1
<
<
17
)
;
}
}
;
template
<
>
struct
FuzzyEqualsEpsilon
<
double
>
{
static
double
value
(
)
{
return
1
.
0
/
(
1LL
<
<
40
)
;
}
}
;
}
template
<
typename
T
>
static
MOZ_ALWAYS_INLINE
bool
FuzzyEqualsAdditive
(
T
aValue1
T
aValue2
T
aEpsilon
=
detail
:
:
FuzzyEqualsEpsilon
<
T
>
:
:
value
(
)
)
{
static_assert
(
IsFloatingPoint
<
T
>
:
:
value
"
floating
point
type
required
"
)
;
return
Abs
(
aValue1
-
aValue2
)
<
=
aEpsilon
;
}
template
<
typename
T
>
static
MOZ_ALWAYS_INLINE
bool
FuzzyEqualsMultiplicative
(
T
aValue1
T
aValue2
T
aEpsilon
=
detail
:
:
FuzzyEqualsEpsilon
<
T
>
:
:
value
(
)
)
{
static_assert
(
IsFloatingPoint
<
T
>
:
:
value
"
floating
point
type
required
"
)
;
T
smaller
=
Abs
(
aValue1
)
<
Abs
(
aValue2
)
?
Abs
(
aValue1
)
:
Abs
(
aValue2
)
;
return
Abs
(
aValue1
-
aValue2
)
<
=
aEpsilon
*
smaller
;
}
MOZ_MUST_USE
extern
MFBT_API
bool
IsFloat32Representable
(
double
aValue
)
;
}
#
endif
