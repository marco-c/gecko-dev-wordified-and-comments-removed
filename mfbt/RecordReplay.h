#
ifndef
mozilla_RecordReplay_h
#
define
mozilla_RecordReplay_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
GuardObjects
.
h
"
#
include
"
mozilla
/
TemplateLib
.
h
"
#
include
"
mozilla
/
Types
.
h
"
#
include
<
functional
>
#
include
<
stdarg
.
h
>
struct
PLDHashTableOps
;
namespace
mozilla
{
namespace
recordreplay
{
#
if
defined
(
XP_MACOSX
)
&
&
defined
(
NIGHTLY_BUILD
)
extern
MFBT_DATA
bool
gIsRecordingOrReplaying
;
extern
MFBT_DATA
bool
gIsRecording
;
extern
MFBT_DATA
bool
gIsReplaying
;
extern
MFBT_DATA
bool
gIsMiddleman
;
static
inline
bool
IsRecordingOrReplaying
(
)
{
return
gIsRecordingOrReplaying
;
}
static
inline
bool
IsRecording
(
)
{
return
gIsRecording
;
}
static
inline
bool
IsReplaying
(
)
{
return
gIsReplaying
;
}
static
inline
bool
IsMiddleman
(
)
{
return
gIsMiddleman
;
}
#
else
static
inline
bool
IsRecordingOrReplaying
(
)
{
return
false
;
}
static
inline
bool
IsRecording
(
)
{
return
false
;
}
static
inline
bool
IsReplaying
(
)
{
return
false
;
}
static
inline
bool
IsMiddleman
(
)
{
return
false
;
}
#
endif
static
inline
void
BeginOrderedAtomicAccess
(
)
;
static
inline
void
EndOrderedAtomicAccess
(
)
;
struct
MOZ_RAII
AutoOrderedAtomicAccess
{
AutoOrderedAtomicAccess
(
)
{
BeginOrderedAtomicAccess
(
)
;
}
~
AutoOrderedAtomicAccess
(
)
{
EndOrderedAtomicAccess
(
)
;
}
}
;
static
inline
void
BeginPassThroughThreadEvents
(
)
;
static
inline
void
EndPassThroughThreadEvents
(
)
;
static
inline
bool
AreThreadEventsPassedThrough
(
)
;
struct
MOZ_RAII
AutoPassThroughThreadEvents
{
AutoPassThroughThreadEvents
(
)
{
BeginPassThroughThreadEvents
(
)
;
}
~
AutoPassThroughThreadEvents
(
)
{
EndPassThroughThreadEvents
(
)
;
}
}
;
struct
MOZ_RAII
AutoEnsurePassThroughThreadEvents
{
AutoEnsurePassThroughThreadEvents
(
)
:
mPassedThrough
(
AreThreadEventsPassedThrough
(
)
)
{
if
(
!
mPassedThrough
)
BeginPassThroughThreadEvents
(
)
;
}
~
AutoEnsurePassThroughThreadEvents
(
)
{
if
(
!
mPassedThrough
)
EndPassThroughThreadEvents
(
)
;
}
private
:
bool
mPassedThrough
;
}
;
static
inline
void
BeginDisallowThreadEvents
(
)
;
static
inline
void
EndDisallowThreadEvents
(
)
;
static
inline
bool
AreThreadEventsDisallowed
(
)
;
struct
MOZ_RAII
AutoDisallowThreadEvents
{
AutoDisallowThreadEvents
(
)
{
BeginDisallowThreadEvents
(
)
;
}
~
AutoDisallowThreadEvents
(
)
{
EndDisallowThreadEvents
(
)
;
}
}
;
static
inline
void
BeginCaptureEventStacks
(
)
;
static
inline
void
EndCaptureEventStacks
(
)
;
struct
MOZ_RAII
AutoCaptureEventStacks
{
AutoCaptureEventStacks
(
)
{
BeginCaptureEventStacks
(
)
;
}
~
AutoCaptureEventStacks
(
)
{
EndCaptureEventStacks
(
)
;
}
}
;
static
inline
size_t
RecordReplayValue
(
size_t
aValue
)
;
static
inline
void
RecordReplayBytes
(
void
*
aData
size_t
aSize
)
;
static
inline
void
InvalidateRecording
(
const
char
*
aWhy
)
;
static
inline
const
PLDHashTableOps
*
GeneratePLDHashTableCallbacks
(
const
PLDHashTableOps
*
aOps
)
;
static
inline
const
PLDHashTableOps
*
UnwrapPLDHashTableCallbacks
(
const
PLDHashTableOps
*
aOps
)
;
static
inline
void
DestroyPLDHashTableCallbacks
(
const
PLDHashTableOps
*
aOps
)
;
static
inline
void
MovePLDHashTableContents
(
const
PLDHashTableOps
*
aFirstOps
const
PLDHashTableOps
*
aSecondOps
)
;
MFBT_API
void
SetWeakPointerJSRoot
(
const
void
*
aPtr
void
*
aJSObj
)
;
MFBT_API
void
RegisterTrigger
(
void
*
aObj
const
std
:
:
function
<
void
(
)
>
&
aCallback
)
;
MFBT_API
void
UnregisterTrigger
(
void
*
aObj
)
;
MFBT_API
void
ActivateTrigger
(
void
*
aObj
)
;
MFBT_API
void
ExecuteTriggers
(
)
;
static
inline
bool
HasDivergedFromRecording
(
)
;
MFBT_API
void
NotifyUnrecordedWait
(
const
std
:
:
function
<
void
(
)
>
&
aCallback
)
;
MFBT_API
void
MaybeWaitForCheckpointSave
(
)
;
static
inline
void
RecordReplayAssert
(
const
char
*
aFormat
.
.
.
)
;
static
inline
void
RecordReplayAssertBytes
(
const
void
*
aData
size_t
aSize
)
;
static
inline
void
RegisterThing
(
void
*
aThing
)
;
static
inline
void
UnregisterThing
(
void
*
aThing
)
;
static
inline
size_t
ThingIndex
(
void
*
aThing
)
;
static
inline
void
RecordReplayDirective
(
long
aDirective
)
;
static
inline
const
char
*
VirtualThingName
(
void
*
aThing
)
;
enum
class
Behavior
{
DontPreserve
Preserve
}
;
MFBT_API
void
Initialize
(
int
aArgc
char
*
aArgv
[
]
)
;
enum
class
ProcessKind
{
Recording
Replaying
MiddlemanRecording
MiddlemanReplaying
}
;
static
const
char
gProcessKindOption
[
]
=
"
-
recordReplayKind
"
;
static
const
char
gRecordingFileOption
[
]
=
"
-
recordReplayFile
"
;
struct
CheckpointId
{
size_t
mNormal
;
static
const
size_t
Invalid
=
0
;
static
const
size_t
First
=
1
;
size_t
mTemporary
;
explicit
CheckpointId
(
size_t
aNormal
=
Invalid
size_t
aTemporary
=
0
)
:
mNormal
(
aNormal
)
mTemporary
(
aTemporary
)
{
}
inline
bool
operator
=
=
(
const
CheckpointId
&
o
)
const
{
return
mNormal
=
=
o
.
mNormal
&
&
mTemporary
=
=
o
.
mTemporary
;
}
inline
bool
operator
!
=
(
const
CheckpointId
&
o
)
const
{
return
mNormal
!
=
o
.
mNormal
|
|
mTemporary
!
=
o
.
mTemporary
;
}
}
;
typedef
void
(
*
BeforeCheckpointHook
)
(
)
;
typedef
void
(
*
AfterCheckpointHook
)
(
const
CheckpointId
&
aCheckpoint
)
;
MFBT_API
void
SetCheckpointHooks
(
BeforeCheckpointHook
aBeforeCheckpoint
AfterCheckpointHook
aAfterCheckpoint
)
;
MFBT_API
void
ResumeExecution
(
)
;
MFBT_API
void
RestoreCheckpointAndResume
(
const
CheckpointId
&
aCheckpoint
)
;
MFBT_API
void
DivergeFromRecording
(
)
;
MFBT_API
void
DisallowUnhandledDivergeFromRecording
(
)
;
MFBT_API
bool
NewCheckpoint
(
bool
aTemporary
)
;
static
inline
void
Print
(
const
char
*
aFormat
.
.
.
)
;
static
inline
void
PrintSpew
(
const
char
*
aFormat
.
.
.
)
;
MFBT_API
bool
SpewEnabled
(
)
;
typedef
size_t
AllocatedMemoryKind
;
static
const
AllocatedMemoryKind
TrackedMemoryKind
=
0
;
static
const
AllocatedMemoryKind
DebuggerAllocatedMemoryKind
=
1
;
MFBT_API
void
*
AllocateMemory
(
size_t
aSize
AllocatedMemoryKind
aKind
)
;
MFBT_API
void
DeallocateMemory
(
void
*
aAddress
size_t
aSize
AllocatedMemoryKind
aKind
)
;
template
<
AllocatedMemoryKind
Kind
>
class
AllocPolicy
{
public
:
template
<
typename
T
>
T
*
maybe_pod_calloc
(
size_t
aNumElems
)
{
if
(
aNumElems
&
tl
:
:
MulOverflowMask
<
sizeof
(
T
)
>
:
:
value
)
{
MOZ_CRASH
(
)
;
}
return
static_cast
<
T
*
>
(
AllocateMemory
(
aNumElems
*
sizeof
(
T
)
Kind
)
)
;
}
template
<
typename
T
>
void
free_
(
T
*
aPtr
size_t
aSize
)
{
DeallocateMemory
(
aPtr
aSize
*
sizeof
(
T
)
Kind
)
;
}
template
<
typename
T
>
T
*
maybe_pod_realloc
(
T
*
aPtr
size_t
aOldSize
size_t
aNewSize
)
{
T
*
res
=
maybe_pod_calloc
<
T
>
(
aNewSize
)
;
memcpy
(
res
aPtr
aOldSize
*
sizeof
(
T
)
)
;
free_
<
T
>
(
aPtr
aOldSize
)
;
return
res
;
}
template
<
typename
T
>
T
*
maybe_pod_malloc
(
size_t
aNumElems
)
{
return
maybe_pod_calloc
<
T
>
(
aNumElems
)
;
}
template
<
typename
T
>
T
*
pod_malloc
(
size_t
aNumElems
)
{
return
maybe_pod_malloc
<
T
>
(
aNumElems
)
;
}
template
<
typename
T
>
T
*
pod_calloc
(
size_t
aNumElems
)
{
return
maybe_pod_calloc
<
T
>
(
aNumElems
)
;
}
template
<
typename
T
>
T
*
pod_realloc
(
T
*
aPtr
size_t
aOldSize
size_t
aNewSize
)
{
return
maybe_pod_realloc
<
T
>
(
aPtr
aOldSize
aNewSize
)
;
}
void
reportAllocOverflow
(
)
const
{
}
MOZ_MUST_USE
bool
checkSimulatedOOM
(
)
const
{
return
true
;
}
}
;
#
if
defined
(
XP_MACOSX
)
&
&
defined
(
NIGHTLY_BUILD
)
#
define
MOZ_MakeRecordReplayWrapperVoid
(
aName
aFormals
aActuals
)
\
MFBT_API
void
Internal
#
#
aName
aFormals
;
\
static
inline
void
aName
aFormals
\
{
\
if
(
IsRecordingOrReplaying
(
)
)
{
\
Internal
#
#
aName
aActuals
;
\
}
\
}
#
define
MOZ_MakeRecordReplayWrapper
(
aName
aReturnType
aDefaultValue
aFormals
aActuals
)
\
MFBT_API
aReturnType
Internal
#
#
aName
aFormals
;
\
static
inline
aReturnType
aName
aFormals
\
{
\
if
(
IsRecordingOrReplaying
(
)
)
{
\
return
Internal
#
#
aName
aActuals
;
\
}
\
return
aDefaultValue
;
\
}
#
else
#
define
MOZ_MakeRecordReplayWrapperVoid
(
aName
aFormals
aActuals
)
\
static
inline
void
aName
aFormals
{
}
#
define
MOZ_MakeRecordReplayWrapper
(
aName
aReturnType
aDefaultValue
aFormals
aActuals
)
\
static
inline
aReturnType
aName
aFormals
{
return
aDefaultValue
;
}
#
endif
MOZ_MakeRecordReplayWrapperVoid
(
BeginOrderedAtomicAccess
(
)
(
)
)
MOZ_MakeRecordReplayWrapperVoid
(
EndOrderedAtomicAccess
(
)
(
)
)
MOZ_MakeRecordReplayWrapperVoid
(
BeginPassThroughThreadEvents
(
)
(
)
)
MOZ_MakeRecordReplayWrapperVoid
(
EndPassThroughThreadEvents
(
)
(
)
)
MOZ_MakeRecordReplayWrapper
(
AreThreadEventsPassedThrough
bool
false
(
)
(
)
)
MOZ_MakeRecordReplayWrapperVoid
(
BeginDisallowThreadEvents
(
)
(
)
)
MOZ_MakeRecordReplayWrapperVoid
(
EndDisallowThreadEvents
(
)
(
)
)
MOZ_MakeRecordReplayWrapper
(
AreThreadEventsDisallowed
bool
false
(
)
(
)
)
MOZ_MakeRecordReplayWrapperVoid
(
BeginCaptureEventStacks
(
)
(
)
)
MOZ_MakeRecordReplayWrapperVoid
(
EndCaptureEventStacks
(
)
(
)
)
MOZ_MakeRecordReplayWrapper
(
RecordReplayValue
size_t
aValue
(
size_t
aValue
)
(
aValue
)
)
MOZ_MakeRecordReplayWrapperVoid
(
RecordReplayBytes
(
void
*
aData
size_t
aSize
)
(
aData
aSize
)
)
MOZ_MakeRecordReplayWrapper
(
HasDivergedFromRecording
bool
false
(
)
(
)
)
MOZ_MakeRecordReplayWrapper
(
GeneratePLDHashTableCallbacks
const
PLDHashTableOps
*
aOps
(
const
PLDHashTableOps
*
aOps
)
(
aOps
)
)
MOZ_MakeRecordReplayWrapper
(
UnwrapPLDHashTableCallbacks
const
PLDHashTableOps
*
aOps
(
const
PLDHashTableOps
*
aOps
)
(
aOps
)
)
MOZ_MakeRecordReplayWrapperVoid
(
DestroyPLDHashTableCallbacks
(
const
PLDHashTableOps
*
aOps
)
(
aOps
)
)
MOZ_MakeRecordReplayWrapperVoid
(
MovePLDHashTableContents
(
const
PLDHashTableOps
*
aFirstOps
const
PLDHashTableOps
*
aSecondOps
)
(
aFirstOps
aSecondOps
)
)
MOZ_MakeRecordReplayWrapperVoid
(
InvalidateRecording
(
const
char
*
aWhy
)
(
aWhy
)
)
MOZ_MakeRecordReplayWrapperVoid
(
RegisterWeakPointer
(
const
void
*
aPtr
const
std
:
:
function
<
void
(
bool
)
>
&
aCallback
)
(
aPtr
aCallback
)
)
MOZ_MakeRecordReplayWrapperVoid
(
UnregisterWeakPointer
(
const
void
*
aPtr
)
(
aPtr
)
)
MOZ_MakeRecordReplayWrapperVoid
(
WeakPointerAccess
(
const
void
*
aPtr
bool
aSuccess
)
(
aPtr
aSuccess
)
)
MOZ_MakeRecordReplayWrapperVoid
(
RecordReplayAssertBytes
(
const
void
*
aData
size_t
aSize
)
(
aData
aSize
)
)
MOZ_MakeRecordReplayWrapperVoid
(
RegisterThing
(
void
*
aThing
)
(
aThing
)
)
MOZ_MakeRecordReplayWrapperVoid
(
UnregisterThing
(
void
*
aThing
)
(
aThing
)
)
MOZ_MakeRecordReplayWrapper
(
ThingIndex
size_t
0
(
void
*
aThing
)
(
aThing
)
)
MOZ_MakeRecordReplayWrapper
(
VirtualThingName
const
char
*
nullptr
(
void
*
aThing
)
(
aThing
)
)
MOZ_MakeRecordReplayWrapperVoid
(
RecordReplayDirective
(
long
aDirective
)
(
aDirective
)
)
#
undef
MOZ_MakeRecordReplayWrapperVoid
#
undef
MOZ_MakeRecordReplayWrapper
MFBT_API
void
InternalRecordReplayAssert
(
const
char
*
aFormat
va_list
aArgs
)
;
static
inline
void
RecordReplayAssert
(
const
char
*
aFormat
.
.
.
)
{
if
(
IsRecordingOrReplaying
(
)
)
{
va_list
ap
;
va_start
(
ap
aFormat
)
;
InternalRecordReplayAssert
(
aFormat
ap
)
;
va_end
(
ap
)
;
}
}
MFBT_API
void
InternalPrint
(
const
char
*
aFormat
va_list
aArgs
)
;
#
define
MOZ_MakeRecordReplayPrinter
(
aName
aSpewing
)
\
static
inline
void
\
aName
(
const
char
*
aFormat
.
.
.
)
\
{
\
if
(
(
IsRecordingOrReplaying
(
)
|
|
IsMiddleman
(
)
)
&
&
(
!
aSpewing
|
|
SpewEnabled
(
)
)
)
{
\
va_list
ap
;
\
va_start
(
ap
aFormat
)
;
\
InternalPrint
(
aFormat
ap
)
;
\
va_end
(
ap
)
;
\
}
\
}
MOZ_MakeRecordReplayPrinter
(
Print
false
)
MOZ_MakeRecordReplayPrinter
(
PrintSpew
true
)
#
undef
MOZ_MakeRecordReplayPrinter
}
}
#
endif
