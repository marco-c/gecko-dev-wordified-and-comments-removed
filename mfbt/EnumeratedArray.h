#
ifndef
mozilla_EnumeratedArray_h
#
define
mozilla_EnumeratedArray_h
#
include
<
utility
>
#
include
"
mozilla
/
Array
.
h
"
namespace
mozilla
{
template
<
typename
IndexType
IndexType
SizeAsEnumValue
typename
ValueType
>
class
EnumeratedArray
{
public
:
static
const
size_t
kSize
=
size_t
(
SizeAsEnumValue
)
;
private
:
typedef
Array
<
ValueType
kSize
>
ArrayType
;
ArrayType
mArray
;
public
:
EnumeratedArray
(
)
=
default
;
template
<
typename
.
.
.
Args
>
MOZ_IMPLICIT
constexpr
EnumeratedArray
(
Args
&
&
.
.
.
aArgs
)
:
mArray
{
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
}
{
}
ValueType
&
operator
[
]
(
IndexType
aIndex
)
{
return
mArray
[
size_t
(
aIndex
)
]
;
}
const
ValueType
&
operator
[
]
(
IndexType
aIndex
)
const
{
return
mArray
[
size_t
(
aIndex
)
]
;
}
typedef
typename
ArrayType
:
:
iterator
iterator
;
typedef
typename
ArrayType
:
:
const_iterator
const_iterator
;
typedef
typename
ArrayType
:
:
reverse_iterator
reverse_iterator
;
typedef
typename
ArrayType
:
:
const_reverse_iterator
const_reverse_iterator
;
iterator
begin
(
)
{
return
mArray
.
begin
(
)
;
}
const_iterator
begin
(
)
const
{
return
mArray
.
begin
(
)
;
}
const_iterator
cbegin
(
)
const
{
return
mArray
.
cbegin
(
)
;
}
iterator
end
(
)
{
return
mArray
.
end
(
)
;
}
const_iterator
end
(
)
const
{
return
mArray
.
end
(
)
;
}
const_iterator
cend
(
)
const
{
return
mArray
.
cend
(
)
;
}
reverse_iterator
rbegin
(
)
{
return
mArray
.
rbegin
(
)
;
}
const_reverse_iterator
rbegin
(
)
const
{
return
mArray
.
rbegin
(
)
;
}
const_reverse_iterator
crbegin
(
)
const
{
return
mArray
.
crbegin
(
)
;
}
reverse_iterator
rend
(
)
{
return
mArray
.
rend
(
)
;
}
const_reverse_iterator
rend
(
)
const
{
return
mArray
.
rend
(
)
;
}
const_reverse_iterator
crend
(
)
const
{
return
mArray
.
crend
(
)
;
}
}
;
}
#
endif
