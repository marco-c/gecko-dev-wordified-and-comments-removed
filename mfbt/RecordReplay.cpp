#
include
"
RecordReplay
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
<
stdlib
.
h
>
#
if
defined
(
XP_MACOSX
)
&
&
defined
(
NIGHTLY_BUILD
)
#
define
ENABLE_RECORD_REPLAY
#
endif
#
ifdef
ENABLE_RECORD_REPLAY
#
include
<
dlfcn
.
h
>
#
endif
namespace
mozilla
{
namespace
recordreplay
{
#
define
FOR_EACH_INTERFACE
(
Macro
)
\
Macro
(
InternalAreThreadEventsPassedThrough
bool
(
)
(
)
)
\
Macro
(
InternalAreThreadEventsDisallowed
bool
(
)
(
)
)
\
Macro
(
InternalRecordReplayValue
size_t
(
size_t
aValue
)
(
aValue
)
)
\
Macro
(
InternalHasDivergedFromRecording
bool
(
)
(
)
)
\
Macro
(
InternalGeneratePLDHashTableCallbacks
const
PLDHashTableOps
*
\
(
const
PLDHashTableOps
*
aOps
)
(
aOps
)
)
\
Macro
(
InternalUnwrapPLDHashTableCallbacks
const
PLDHashTableOps
*
\
(
const
PLDHashTableOps
*
aOps
)
(
aOps
)
)
\
Macro
(
AllocateMemory
void
*
(
size_t
aSize
AllocatedMemoryKind
aKind
)
(
aSize
aKind
)
)
\
Macro
(
InternalThingIndex
size_t
(
void
*
aThing
)
(
aThing
)
)
\
Macro
(
InternalVirtualThingName
const
char
*
(
void
*
aThing
)
(
aThing
)
)
\
Macro
(
NewCheckpoint
bool
(
bool
aTemporary
)
(
aTemporary
)
)
\
Macro
(
SpewEnabled
bool
(
)
(
)
)
#
define
FOR_EACH_INTERFACE_VOID
(
Macro
)
\
Macro
(
InternalBeginOrderedAtomicAccess
(
)
(
)
)
\
Macro
(
InternalEndOrderedAtomicAccess
(
)
(
)
)
\
Macro
(
InternalBeginPassThroughThreadEvents
(
)
(
)
)
\
Macro
(
InternalEndPassThroughThreadEvents
(
)
(
)
)
\
Macro
(
InternalBeginDisallowThreadEvents
(
)
(
)
)
\
Macro
(
InternalEndDisallowThreadEvents
(
)
(
)
)
\
Macro
(
InternalBeginCaptureEventStacks
(
)
(
)
)
\
Macro
(
InternalEndCaptureEventStacks
(
)
(
)
)
\
Macro
(
InternalRecordReplayBytes
\
(
void
*
aData
size_t
aSize
)
(
aData
aSize
)
)
\
Macro
(
DisallowUnhandledDivergeFromRecording
(
)
(
)
)
\
Macro
(
NotifyUnrecordedWait
\
(
const
std
:
:
function
<
void
(
)
>
&
aCallback
)
(
aCallback
)
)
\
Macro
(
MaybeWaitForCheckpointSave
(
)
(
)
)
\
Macro
(
InternalInvalidateRecording
(
const
char
*
aWhy
)
(
aWhy
)
)
\
Macro
(
InternalDestroyPLDHashTableCallbacks
\
(
const
PLDHashTableOps
*
aOps
)
(
aOps
)
)
\
Macro
(
InternalMovePLDHashTableContents
\
(
const
PLDHashTableOps
*
aFirstOps
const
PLDHashTableOps
*
aSecondOps
)
\
(
aFirstOps
aSecondOps
)
)
\
Macro
(
SetCheckpointHooks
\
(
BeforeCheckpointHook
aBefore
AfterCheckpointHook
aAfter
)
\
(
aBefore
aAfter
)
)
\
Macro
(
ResumeExecution
(
)
(
)
)
\
Macro
(
RestoreCheckpointAndResume
(
const
CheckpointId
&
aId
)
(
aId
)
)
\
Macro
(
DivergeFromRecording
(
)
(
)
)
\
Macro
(
DeallocateMemory
\
(
void
*
aAddress
size_t
aSize
AllocatedMemoryKind
aKind
)
(
aAddress
aSize
aKind
)
)
\
Macro
(
SetWeakPointerJSRoot
\
(
const
void
*
aPtr
void
*
aJSObj
)
(
aPtr
aJSObj
)
)
\
Macro
(
RegisterTrigger
\
(
void
*
aObj
const
std
:
:
function
<
void
(
)
>
&
aCallback
)
\
(
aObj
aCallback
)
)
\
Macro
(
UnregisterTrigger
\
(
void
*
aObj
)
(
aObj
)
)
\
Macro
(
ActivateTrigger
(
void
*
aObj
)
(
aObj
)
)
\
Macro
(
ExecuteTriggers
(
)
(
)
)
\
Macro
(
InternalRecordReplayAssert
(
const
char
*
aFormat
va_list
aArgs
)
(
aFormat
aArgs
)
)
\
Macro
(
InternalRecordReplayAssertBytes
\
(
const
void
*
aData
size_t
aSize
)
(
aData
aSize
)
)
\
Macro
(
InternalRegisterThing
(
void
*
aThing
)
(
aThing
)
)
\
Macro
(
InternalUnregisterThing
(
void
*
aThing
)
(
aThing
)
)
\
Macro
(
InternalRecordReplayDirective
(
long
aDirective
)
(
aDirective
)
)
\
Macro
(
InternalPrint
(
const
char
*
aFormat
va_list
aArgs
)
(
aFormat
aArgs
)
)
#
define
DECLARE_SYMBOL
(
aName
aReturnType
aFormals
_
)
\
static
aReturnType
(
*
gPtr
#
#
aName
)
aFormals
;
#
define
DECLARE_SYMBOL_VOID
(
aName
aFormals
_
)
DECLARE_SYMBOL
(
aName
void
aFormals
_
)
FOR_EACH_INTERFACE
(
DECLARE_SYMBOL
)
FOR_EACH_INTERFACE_VOID
(
DECLARE_SYMBOL_VOID
)
#
undef
DECLARE_SYMBOL
#
undef
DECLARE_SYMBOL_VOID
static
void
*
LoadSymbol
(
const
char
*
aName
)
{
#
ifdef
ENABLE_RECORD_REPLAY
void
*
rv
=
dlsym
(
RTLD_DEFAULT
aName
)
;
MOZ_RELEASE_ASSERT
(
rv
)
;
return
rv
;
#
else
return
nullptr
;
#
endif
}
void
Initialize
(
int
aArgc
char
*
aArgv
[
]
)
{
bool
found
=
false
;
for
(
int
i
=
0
;
i
<
aArgc
;
i
+
+
)
{
if
(
!
strcmp
(
aArgv
[
i
]
gProcessKindOption
)
)
{
found
=
true
;
break
;
}
}
if
(
!
found
)
{
return
;
}
void
(
*
initialize
)
(
int
char
*
*
)
;
BitwiseCast
(
LoadSymbol
(
"
RecordReplayInterface_Initialize
"
)
&
initialize
)
;
if
(
!
initialize
)
{
return
;
}
#
define
INIT_SYMBOL
(
aName
_1
_2
_3
)
\
BitwiseCast
(
LoadSymbol
(
"
RecordReplayInterface_
"
#
aName
)
&
gPtr
#
#
aName
)
;
#
define
INIT_SYMBOL_VOID
(
aName
_2
_3
)
INIT_SYMBOL
(
aName
void
_2
_3
)
FOR_EACH_INTERFACE
(
INIT_SYMBOL
)
FOR_EACH_INTERFACE_VOID
(
INIT_SYMBOL_VOID
)
#
undef
INIT_SYMBOL
#
undef
INIT_SYMBOL_VOID
initialize
(
aArgc
aArgv
)
;
}
#
define
DEFINE_WRAPPER
(
aName
aReturnType
aFormals
aActuals
)
\
aReturnType
aName
aFormals
\
{
\
MOZ_ASSERT
(
IsRecordingOrReplaying
(
)
|
|
IsMiddleman
(
)
)
;
\
return
gPtr
#
#
aName
aActuals
;
\
}
#
define
DEFINE_WRAPPER_VOID
(
aName
aFormals
aActuals
)
\
void
aName
aFormals
\
{
\
MOZ_ASSERT
(
IsRecordingOrReplaying
(
)
|
|
IsMiddleman
(
)
)
;
\
gPtr
#
#
aName
aActuals
;
\
}
FOR_EACH_INTERFACE
(
DEFINE_WRAPPER
)
FOR_EACH_INTERFACE_VOID
(
DEFINE_WRAPPER_VOID
)
#
undef
DEFINE_WRAPPER
#
undef
DEFINE_WRAPPER_VOID
#
ifdef
ENABLE_RECORD_REPLAY
bool
gIsRecordingOrReplaying
;
bool
gIsRecording
;
bool
gIsReplaying
;
bool
gIsMiddleman
;
#
endif
#
undef
ENABLE_RECORD_REPLAY
}
}
