#
ifndef
mozilla_ResultExtensions_h
#
define
mozilla_ResultExtensions_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
nscore
.
h
"
#
include
"
prtypes
.
h
"
namespace
mozilla
{
template
<
>
class
MOZ_MUST_USE_TYPE
GenericErrorResult
<
nsresult
>
{
nsresult
mErrorValue
;
template
<
typename
V
typename
E2
>
friend
class
Result
;
public
:
explicit
GenericErrorResult
(
nsresult
aErrorValue
)
:
mErrorValue
(
aErrorValue
)
{
MOZ_ASSERT
(
NS_FAILED
(
aErrorValue
)
)
;
}
operator
nsresult
(
)
const
{
return
mErrorValue
;
}
}
;
inline
Result
<
Ok
nsresult
>
ToResult
(
PRStatus
aValue
)
;
}
#
include
"
mozilla
/
Result
.
h
"
namespace
mozilla
{
inline
Result
<
Ok
nsresult
>
ToResult
(
nsresult
aValue
)
{
if
(
NS_FAILED
(
aValue
)
)
{
return
Err
(
aValue
)
;
}
return
Ok
(
)
;
}
inline
Result
<
Ok
nsresult
>
ToResult
(
PRStatus
aValue
)
{
if
(
aValue
=
=
PR_SUCCESS
)
{
return
Ok
(
)
;
}
return
Err
(
NS_ERROR_FAILURE
)
;
}
namespace
detail
{
template
<
typename
R
>
auto
ResultRefAsParam
(
R
&
aResult
)
{
return
&
aResult
;
}
template
<
typename
R
typename
RArgMapper
typename
Func
typename
.
.
.
Args
>
Result
<
R
nsresult
>
ToResultInvokeInternal
(
const
Func
&
aFunc
const
RArgMapper
&
aRArgMapper
Args
&
&
.
.
.
aArgs
)
{
static_assert
(
!
std
:
:
is_pointer_v
<
R
>
"
Raw
pointer
results
are
not
supported
please
specify
a
smart
pointer
"
"
result
type
explicitly
so
that
getter_AddRefs
is
used
"
)
;
R
res
;
nsresult
rv
=
aFunc
(
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
aRArgMapper
(
res
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
Err
(
rv
)
;
}
return
res
;
}
template
<
typename
T
>
struct
outparam_as_pointer
;
template
<
typename
T
>
struct
outparam_as_pointer
<
T
*
>
{
using
type
=
T
*
;
}
;
template
<
typename
T
>
struct
outparam_as_reference
;
template
<
typename
T
>
struct
outparam_as_reference
<
T
*
>
{
using
type
=
T
&
;
}
;
template
<
typename
R
template
<
typename
>
typename
RArg
typename
Func
typename
.
.
.
Args
>
using
to_result_retval_t
=
decltype
(
std
:
:
declval
<
Func
&
>
(
)
(
std
:
:
declval
<
Args
&
&
>
(
)
.
.
.
std
:
:
declval
<
typename
RArg
<
decltype
(
ResultRefAsParam
(
std
:
:
declval
<
R
&
>
(
)
)
)
>
:
:
type
>
(
)
)
Result
<
R
nsresult
>
(
Err
(
NS_ERROR_FAILURE
)
)
)
;
template
<
typename
R
typename
Func
typename
.
.
.
Args
>
auto
ToResultInvokeSelector
(
const
Func
&
aFunc
Args
&
&
.
.
.
aArgs
)
-
>
to_result_retval_t
<
R
outparam_as_pointer
Func
Args
.
.
.
>
{
return
ToResultInvokeInternal
<
R
>
(
aFunc
[
]
(
R
&
res
)
-
>
decltype
(
auto
)
{
return
ResultRefAsParam
(
res
)
;
}
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
;
}
template
<
typename
R
typename
Func
typename
.
.
.
Args
>
auto
ToResultInvokeSelector
(
const
Func
&
aFunc
Args
&
&
.
.
.
aArgs
)
-
>
to_result_retval_t
<
R
outparam_as_reference
Func
Args
.
.
.
>
{
return
ToResultInvokeInternal
<
R
>
(
aFunc
[
]
(
R
&
res
)
-
>
decltype
(
auto
)
{
return
*
ResultRefAsParam
(
res
)
;
}
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
;
}
}
template
<
typename
R
typename
Func
typename
.
.
.
Args
>
Result
<
R
nsresult
>
ToResultInvoke
(
const
Func
&
aFunc
Args
&
&
.
.
.
aArgs
)
{
return
detail
:
:
ToResultInvokeSelector
<
R
Func
Args
&
&
.
.
.
>
(
aFunc
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
;
}
namespace
detail
{
template
<
typename
T
>
struct
tag
{
using
type
=
T
;
}
;
template
<
typename
.
.
.
Ts
>
struct
select_last
{
using
type
=
typename
decltype
(
(
tag
<
Ts
>
{
}
.
.
.
)
)
:
:
type
;
}
;
template
<
typename
.
.
.
Ts
>
using
select_last_t
=
typename
select_last
<
Ts
.
.
.
>
:
:
type
;
template
<
>
struct
select_last
<
>
{
using
type
=
void
;
}
;
template
<
typename
RArg
typename
T
typename
Func
typename
.
.
.
Args
>
auto
ToResultInvokeMemberFunction
(
T
&
aObj
const
Func
&
aFunc
Args
&
&
.
.
.
aArgs
)
{
if
constexpr
(
std
:
:
is_pointer_v
<
RArg
>
|
|
(
std
:
:
is_lvalue_reference_v
<
RArg
>
&
&
!
std
:
:
is_const_v
<
std
:
:
remove_reference_t
<
RArg
>
>
)
)
{
auto
lambda
=
[
&
]
(
RArg
res
)
{
return
(
aObj
.
*
aFunc
)
(
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
res
)
;
}
;
return
detail
:
:
ToResultInvokeSelector
<
std
:
:
remove_reference_t
<
std
:
:
remove_pointer_t
<
RArg
>
>
decltype
(
lambda
)
>
(
lambda
)
;
}
else
{
return
mozilla
:
:
ToResult
(
(
aObj
.
*
aFunc
)
(
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
)
;
}
}
template
<
typename
T
>
auto
DerefHelper
(
const
T
&
)
-
>
T
&
;
template
<
typename
T
>
auto
DerefHelper
(
T
*
)
-
>
T
&
;
template
<
template
<
class
>
class
SmartPtr
typename
T
typename
=
decltype
(
*
std
:
:
declval
<
const
SmartPtr
<
T
>
>
(
)
)
>
auto
DerefHelper
(
const
SmartPtr
<
T
>
&
)
-
>
T
&
;
template
<
typename
T
>
using
DerefedType
=
std
:
:
remove_reference_t
<
decltype
(
DerefHelper
(
std
:
:
declval
<
const
T
&
>
(
)
)
)
>
;
}
template
<
typename
T
typename
U
typename
.
.
.
XArgs
typename
.
.
.
Args
typename
=
std
:
:
enable_if_t
<
std
:
:
is_base_of_v
<
U
T
>
>
>
auto
ToResultInvoke
(
T
&
aObj
nsresult
(
U
:
:
*
aFunc
)
(
XArgs
.
.
.
)
Args
&
&
.
.
.
aArgs
)
{
return
detail
:
:
ToResultInvokeMemberFunction
<
detail
:
:
select_last_t
<
XArgs
.
.
.
>
>
(
aObj
aFunc
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
;
}
template
<
typename
T
typename
U
typename
.
.
.
XArgs
typename
.
.
.
Args
typename
=
std
:
:
enable_if_t
<
std
:
:
is_base_of_v
<
U
T
>
>
>
auto
ToResultInvoke
(
const
T
&
aObj
nsresult
(
U
:
:
*
aFunc
)
(
XArgs
.
.
.
)
const
Args
&
&
.
.
.
aArgs
)
{
return
detail
:
:
ToResultInvokeMemberFunction
<
detail
:
:
select_last_t
<
XArgs
.
.
.
>
>
(
aObj
aFunc
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
;
}
template
<
typename
T
typename
U
typename
.
.
.
XArgs
typename
.
.
.
Args
>
auto
ToResultInvoke
(
T
*
const
aObj
nsresult
(
U
:
:
*
aFunc
)
(
XArgs
.
.
.
)
Args
&
&
.
.
.
aArgs
)
{
return
ToResultInvoke
(
*
aObj
aFunc
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
;
}
template
<
typename
T
typename
U
typename
.
.
.
XArgs
typename
.
.
.
Args
>
auto
ToResultInvoke
(
const
T
*
const
aObj
nsresult
(
U
:
:
*
aFunc
)
(
XArgs
.
.
.
)
const
Args
&
&
.
.
.
aArgs
)
{
return
ToResultInvoke
(
*
aObj
aFunc
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
;
}
template
<
template
<
class
>
class
SmartPtr
typename
T
typename
U
typename
.
.
.
XArgs
typename
.
.
.
Args
typename
=
std
:
:
enable_if_t
<
std
:
:
is_base_of_v
<
U
T
>
>
typename
=
decltype
(
*
std
:
:
declval
<
const
SmartPtr
<
T
>
>
(
)
)
>
auto
ToResultInvoke
(
const
SmartPtr
<
T
>
&
aObj
nsresult
(
U
:
:
*
aFunc
)
(
XArgs
.
.
.
)
Args
&
&
.
.
.
aArgs
)
{
return
ToResultInvoke
(
*
aObj
aFunc
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
;
}
template
<
template
<
class
>
class
SmartPtr
typename
T
typename
U
typename
.
.
.
XArgs
typename
.
.
.
Args
typename
=
std
:
:
enable_if_t
<
std
:
:
is_base_of_v
<
U
T
>
>
typename
=
decltype
(
*
std
:
:
declval
<
const
SmartPtr
<
T
>
>
(
)
)
>
auto
ToResultInvoke
(
const
SmartPtr
<
const
T
>
&
aObj
nsresult
(
U
:
:
*
aFunc
)
(
XArgs
.
.
.
)
const
Args
&
&
.
.
.
aArgs
)
{
return
ToResultInvoke
(
*
aObj
aFunc
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
;
}
#
if
defined
(
XP_WIN
)
&
&
!
defined
(
_WIN64
)
template
<
typename
T
typename
U
typename
.
.
.
XArgs
typename
.
.
.
Args
typename
=
std
:
:
enable_if_t
<
std
:
:
is_base_of_v
<
U
T
>
>
>
auto
ToResultInvoke
(
T
&
aObj
nsresult
(
__stdcall
U
:
:
*
aFunc
)
(
XArgs
.
.
.
)
Args
&
&
.
.
.
aArgs
)
{
return
detail
:
:
ToResultInvokeMemberFunction
<
detail
:
:
select_last_t
<
XArgs
.
.
.
>
>
(
aObj
aFunc
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
;
}
template
<
typename
T
typename
U
typename
.
.
.
XArgs
typename
.
.
.
Args
typename
=
std
:
:
enable_if_t
<
std
:
:
is_base_of_v
<
U
T
>
>
>
auto
ToResultInvoke
(
const
T
&
aObj
nsresult
(
__stdcall
U
:
:
*
aFunc
)
(
XArgs
.
.
.
)
const
Args
&
&
.
.
.
aArgs
)
{
return
detail
:
:
ToResultInvokeMemberFunction
<
detail
:
:
select_last_t
<
XArgs
.
.
.
>
>
(
aObj
aFunc
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
;
}
template
<
typename
T
typename
U
typename
.
.
.
XArgs
typename
.
.
.
Args
>
auto
ToResultInvoke
(
T
*
const
aObj
nsresult
(
__stdcall
U
:
:
*
aFunc
)
(
XArgs
.
.
.
)
Args
&
&
.
.
.
aArgs
)
{
return
ToResultInvoke
(
*
aObj
aFunc
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
;
}
template
<
typename
T
typename
U
typename
.
.
.
XArgs
typename
.
.
.
Args
>
auto
ToResultInvoke
(
const
T
*
const
aObj
nsresult
(
__stdcall
U
:
:
*
aFunc
)
(
XArgs
.
.
.
)
const
Args
&
&
.
.
.
aArgs
)
{
return
ToResultInvoke
(
*
aObj
aFunc
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
;
}
template
<
template
<
class
>
class
SmartPtr
typename
T
typename
U
typename
.
.
.
XArgs
typename
.
.
.
Args
typename
=
std
:
:
enable_if_t
<
std
:
:
is_base_of_v
<
U
T
>
>
typename
=
decltype
(
*
std
:
:
declval
<
const
SmartPtr
<
T
>
>
(
)
)
>
auto
ToResultInvoke
(
const
SmartPtr
<
T
>
&
aObj
nsresult
(
__stdcall
U
:
:
*
aFunc
)
(
XArgs
.
.
.
)
Args
&
&
.
.
.
aArgs
)
{
return
ToResultInvoke
(
*
aObj
aFunc
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
;
}
template
<
template
<
class
>
class
SmartPtr
typename
T
typename
U
typename
.
.
.
XArgs
typename
.
.
.
Args
typename
=
std
:
:
enable_if_t
<
std
:
:
is_base_of_v
<
U
T
>
>
typename
=
decltype
(
*
std
:
:
declval
<
const
SmartPtr
<
T
>
>
(
)
)
>
auto
ToResultInvoke
(
const
SmartPtr
<
const
T
>
&
aObj
nsresult
(
__stdcall
U
:
:
*
aFunc
)
(
XArgs
.
.
.
)
const
Args
&
&
.
.
.
aArgs
)
{
return
ToResultInvoke
(
*
aObj
aFunc
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
;
}
#
endif
#
define
MOZ_TO_RESULT_INVOKE
(
obj
methodname
.
.
.
)
\
:
:
mozilla
:
:
ToResultInvoke
(
\
(
obj
)
&
:
:
mozilla
:
:
detail
:
:
DerefedType
<
decltype
(
obj
)
>
:
:
methodname
\
#
#
__VA_ARGS__
)
#
define
MOZ_TO_RESULT_INVOKE_TYPED
(
resultType
obj
methodname
.
.
.
)
\
:
:
mozilla
:
:
ToResultInvoke
<
resultType
>
(
\
:
:
std
:
:
mem_fn
(
\
&
:
:
mozilla
:
:
detail
:
:
DerefedType
<
decltype
(
obj
)
>
:
:
methodname
)
\
(
obj
)
#
#
__VA_ARGS__
)
}
#
endif
