#
ifndef
mozilla_Saturate_h
#
define
mozilla_Saturate_h
#
include
<
limits
>
#
include
<
stdint
.
h
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
mozilla
/
Attributes
.
h
"
namespace
mozilla
{
namespace
detail
{
template
<
typename
T
>
class
SaturateOp
{
public
:
explicit
SaturateOp
(
T
&
aValue
)
:
mValue
(
aValue
)
{
static_assert
(
std
:
:
is_integral_v
<
T
>
"
Integral
type
required
in
instantiation
"
)
;
}
T
operator
+
(
const
T
&
aRhs
)
const
{
return
T
(
mValue
)
+
=
aRhs
;
}
T
operator
-
(
const
T
&
aRhs
)
const
{
return
T
(
mValue
)
-
=
aRhs
;
}
#
if
defined
(
__has_builtin
)
#
if
__has_builtin
(
__builtin_add_overflow
)
#
define
MOZ_ADD_OVERFLOW
__builtin_add_overflow
#
endif
#
if
__has_builtin
(
__builtin_sub_overflow
)
#
define
MOZ_SUB_OVERFLOW
__builtin_sub_overflow
#
endif
#
endif
const
T
&
operator
+
=
(
const
T
&
aRhs
)
const
{
constexpr
T
min
=
std
:
:
numeric_limits
<
T
>
:
:
min
(
)
;
constexpr
T
max
=
std
:
:
numeric_limits
<
T
>
:
:
max
(
)
;
#
ifdef
MOZ_ADD_OVERFLOW
if
(
MOZ_ADD_OVERFLOW
(
mValue
aRhs
&
mValue
)
)
return
mValue
=
(
aRhs
>
0
?
max
:
min
)
;
#
else
if
(
aRhs
>
static_cast
<
T
>
(
0
)
)
{
mValue
=
(
max
-
aRhs
)
<
mValue
?
max
:
mValue
+
aRhs
;
}
else
{
mValue
=
(
min
-
aRhs
)
>
mValue
?
min
:
mValue
+
aRhs
;
}
#
endif
return
mValue
;
}
const
T
&
operator
-
=
(
const
T
&
aRhs
)
const
{
constexpr
T
min
=
std
:
:
numeric_limits
<
T
>
:
:
min
(
)
;
constexpr
T
max
=
std
:
:
numeric_limits
<
T
>
:
:
max
(
)
;
#
ifdef
MOZ_SUB_OVERFLOW
if
(
MOZ_SUB_OVERFLOW
(
mValue
aRhs
&
mValue
)
)
return
mValue
=
(
aRhs
>
0
?
min
:
max
)
;
#
else
if
(
aRhs
>
static_cast
<
T
>
(
0
)
)
{
mValue
=
(
min
+
aRhs
)
>
mValue
?
min
:
mValue
-
aRhs
;
}
else
{
mValue
=
(
max
+
aRhs
)
<
mValue
?
max
:
mValue
-
aRhs
;
}
#
endif
return
mValue
;
}
const
T
&
operator
+
+
(
)
const
{
return
operator
+
=
(
static_cast
<
T
>
(
1
)
)
;
}
T
operator
+
+
(
int
)
const
{
const
T
value
(
mValue
)
;
operator
+
+
(
)
;
return
value
;
}
const
T
&
operator
-
-
(
)
const
{
return
operator
-
=
(
static_cast
<
T
>
(
1
)
)
;
}
T
operator
-
-
(
int
)
const
{
const
T
value
(
mValue
)
;
operator
-
-
(
)
;
return
value
;
}
private
:
SaturateOp
(
const
SaturateOp
<
T
>
&
)
=
delete
;
SaturateOp
(
SaturateOp
<
T
>
&
&
)
=
delete
;
SaturateOp
&
operator
=
(
const
SaturateOp
<
T
>
&
)
=
delete
;
SaturateOp
&
operator
=
(
SaturateOp
<
T
>
&
&
)
=
delete
;
T
&
mValue
;
}
;
template
<
typename
T
>
class
Saturate
{
public
:
Saturate
(
)
=
default
;
MOZ_IMPLICIT
Saturate
(
const
Saturate
<
T
>
&
)
=
default
;
MOZ_IMPLICIT
Saturate
(
Saturate
<
T
>
&
&
aValue
)
{
mValue
=
std
:
:
move
(
aValue
.
mValue
)
;
}
explicit
Saturate
(
const
T
&
aValue
)
:
mValue
(
aValue
)
{
}
const
T
&
value
(
)
const
{
return
mValue
;
}
bool
operator
=
=
(
const
Saturate
<
T
>
&
aRhs
)
const
{
return
mValue
=
=
aRhs
.
mValue
;
}
bool
operator
!
=
(
const
Saturate
<
T
>
&
aRhs
)
const
{
return
!
operator
=
=
(
aRhs
)
;
}
bool
operator
=
=
(
const
T
&
aRhs
)
const
{
return
mValue
=
=
aRhs
;
}
bool
operator
!
=
(
const
T
&
aRhs
)
const
{
return
!
operator
=
=
(
aRhs
)
;
}
Saturate
<
T
>
&
operator
=
(
const
Saturate
<
T
>
&
)
=
default
;
Saturate
<
T
>
&
operator
=
(
Saturate
<
T
>
&
&
aRhs
)
{
mValue
=
std
:
:
move
(
aRhs
.
mValue
)
;
return
*
this
;
}
Saturate
<
T
>
operator
+
(
const
Saturate
<
T
>
&
aRhs
)
const
{
Saturate
<
T
>
lhs
(
mValue
)
;
return
lhs
+
=
aRhs
.
mValue
;
}
Saturate
<
T
>
operator
+
(
const
T
&
aRhs
)
const
{
Saturate
<
T
>
lhs
(
mValue
)
;
return
lhs
+
=
aRhs
;
}
Saturate
<
T
>
operator
-
(
const
Saturate
<
T
>
&
aRhs
)
const
{
Saturate
<
T
>
lhs
(
mValue
)
;
return
lhs
-
=
aRhs
.
mValue
;
}
Saturate
<
T
>
operator
-
(
const
T
&
aRhs
)
const
{
Saturate
<
T
>
lhs
(
mValue
)
;
return
lhs
-
=
aRhs
;
}
Saturate
<
T
>
&
operator
+
=
(
const
Saturate
<
T
>
&
aRhs
)
{
SaturateOp
<
T
>
(
mValue
)
+
=
aRhs
.
mValue
;
return
*
this
;
}
Saturate
<
T
>
&
operator
+
=
(
const
T
&
aRhs
)
{
SaturateOp
<
T
>
(
mValue
)
+
=
aRhs
;
return
*
this
;
}
Saturate
<
T
>
&
operator
-
=
(
const
Saturate
<
T
>
&
aRhs
)
{
SaturateOp
<
T
>
(
mValue
)
-
=
aRhs
.
mValue
;
return
*
this
;
}
Saturate
<
T
>
&
operator
-
=
(
const
T
&
aRhs
)
{
SaturateOp
<
T
>
(
mValue
)
-
=
aRhs
;
return
*
this
;
}
Saturate
<
T
>
&
operator
+
+
(
)
{
+
+
SaturateOp
<
T
>
(
mValue
)
;
return
*
this
;
}
Saturate
<
T
>
operator
+
+
(
int
)
{
return
Saturate
<
T
>
(
SaturateOp
<
T
>
(
mValue
)
+
+
)
;
}
Saturate
<
T
>
&
operator
-
-
(
)
{
-
-
SaturateOp
<
T
>
(
mValue
)
;
return
*
this
;
}
Saturate
<
T
>
operator
-
-
(
int
)
{
return
Saturate
<
T
>
(
SaturateOp
<
T
>
(
mValue
)
-
-
)
;
}
private
:
T
mValue
;
}
;
}
typedef
detail
:
:
Saturate
<
int8_t
>
SaturateInt8
;
typedef
detail
:
:
Saturate
<
int16_t
>
SaturateInt16
;
typedef
detail
:
:
Saturate
<
int32_t
>
SaturateInt32
;
typedef
detail
:
:
Saturate
<
uint8_t
>
SaturateUint8
;
typedef
detail
:
:
Saturate
<
uint16_t
>
SaturateUint16
;
typedef
detail
:
:
Saturate
<
uint32_t
>
SaturateUint32
;
}
template
<
typename
LhsT
typename
RhsT
>
bool
operator
=
=
(
LhsT
aLhs
const
mozilla
:
:
detail
:
:
Saturate
<
RhsT
>
&
aRhs
)
{
return
aRhs
.
operator
=
=
(
static_cast
<
RhsT
>
(
aLhs
)
)
;
}
template
<
typename
LhsT
typename
RhsT
>
bool
operator
!
=
(
LhsT
aLhs
const
mozilla
:
:
detail
:
:
Saturate
<
RhsT
>
&
aRhs
)
{
return
!
(
aLhs
=
=
aRhs
)
;
}
#
endif
