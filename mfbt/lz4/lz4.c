#
ifndef
LZ4_HEAPMODE
#
define
LZ4_HEAPMODE
0
#
endif
#
define
LZ4_ACCELERATION_DEFAULT
1
#
define
LZ4_ACCELERATION_MAX
65537
#
ifndef
LZ4_FORCE_MEMORY_ACCESS
#
if
defined
(
__GNUC__
)
&
&
\
(
defined
(
__ARM_ARCH_6__
)
|
|
defined
(
__ARM_ARCH_6J__
)
|
|
defined
(
__ARM_ARCH_6K__
)
\
|
|
defined
(
__ARM_ARCH_6Z__
)
|
|
defined
(
__ARM_ARCH_6ZK__
)
|
|
defined
(
__ARM_ARCH_6T2__
)
)
#
define
LZ4_FORCE_MEMORY_ACCESS
2
#
elif
(
defined
(
__INTEL_COMPILER
)
&
&
!
defined
(
_WIN32
)
)
|
|
defined
(
__GNUC__
)
|
|
defined
(
_MSC_VER
)
#
define
LZ4_FORCE_MEMORY_ACCESS
1
#
endif
#
endif
#
if
defined
(
_MSC_VER
)
&
&
defined
(
_WIN32_WCE
)
#
undef
LZ4_FORCE_SW_BITCOUNT
/
*
avoid
double
def
*
/
#
define
LZ4_FORCE_SW_BITCOUNT
#
endif
#
ifndef
LZ4_SRC_INCLUDED
#
define
LZ4_SRC_INCLUDED
1
#
endif
#
ifndef
LZ4_DISABLE_DEPRECATE_WARNINGS
#
define
LZ4_DISABLE_DEPRECATE_WARNINGS
#
endif
#
ifndef
LZ4_STATIC_LINKING_ONLY
#
define
LZ4_STATIC_LINKING_ONLY
#
endif
#
include
"
lz4
.
h
"
#
if
defined
(
_MSC_VER
)
&
&
(
_MSC_VER
>
=
1400
)
#
include
<
intrin
.
h
>
#
pragma
warning
(
disable
:
4127
)
/
*
disable
:
C4127
:
conditional
expression
is
constant
*
/
#
pragma
warning
(
disable
:
6237
)
/
*
disable
:
C6237
:
conditional
expression
is
always
0
*
/
#
pragma
warning
(
disable
:
6239
)
/
*
disable
:
C6239
:
(
<
non
-
zero
constant
>
&
&
<
expression
>
)
always
evaluates
to
the
result
of
<
expression
>
*
/
#
pragma
warning
(
disable
:
6240
)
/
*
disable
:
C6240
:
(
<
expression
>
&
&
<
non
-
zero
constant
>
)
always
evaluates
to
the
result
of
<
expression
>
*
/
#
pragma
warning
(
disable
:
6326
)
/
*
disable
:
C6326
:
Potential
comparison
of
a
constant
with
another
constant
*
/
#
endif
#
ifndef
LZ4_FORCE_INLINE
#
if
defined
(
_MSC_VER
)
&
&
!
defined
(
__clang__
)
#
define
LZ4_FORCE_INLINE
static
__forceinline
#
else
#
if
defined
(
__cplusplus
)
|
|
defined
(
__STDC_VERSION__
)
&
&
__STDC_VERSION__
>
=
199901L
#
if
defined
(
__GNUC__
)
|
|
defined
(
__clang__
)
#
define
LZ4_FORCE_INLINE
static
inline
__attribute__
(
(
always_inline
)
)
#
else
#
define
LZ4_FORCE_INLINE
static
inline
#
endif
#
else
#
define
LZ4_FORCE_INLINE
static
#
endif
#
endif
#
endif
#
if
defined
(
__PPC64__
)
&
&
defined
(
__LITTLE_ENDIAN__
)
&
&
defined
(
__GNUC__
)
&
&
!
defined
(
__clang__
)
#
define
LZ4_FORCE_O2
__attribute__
(
(
optimize
(
"
O2
"
)
)
)
#
undef
LZ4_FORCE_INLINE
#
define
LZ4_FORCE_INLINE
static
__inline
__attribute__
(
(
optimize
(
"
O2
"
)
always_inline
)
)
#
else
#
define
LZ4_FORCE_O2
#
endif
#
if
(
defined
(
__GNUC__
)
&
&
(
__GNUC__
>
=
3
)
)
|
|
(
defined
(
__INTEL_COMPILER
)
&
&
(
__INTEL_COMPILER
>
=
800
)
)
|
|
defined
(
__clang__
)
#
define
expect
(
expr
value
)
(
__builtin_expect
(
(
expr
)
(
value
)
)
)
#
else
#
define
expect
(
expr
value
)
(
expr
)
#
endif
#
ifndef
likely
#
define
likely
(
expr
)
expect
(
(
expr
)
!
=
0
1
)
#
endif
#
ifndef
unlikely
#
define
unlikely
(
expr
)
expect
(
(
expr
)
!
=
0
0
)
#
endif
#
ifndef
LZ4_ALIGN_TEST
#
define
LZ4_ALIGN_TEST
1
#
endif
#
if
defined
(
LZ4_STATIC_LINKING_ONLY_DISABLE_MEMORY_ALLOCATION
)
#
define
ALLOC
(
s
)
lz4_error_memory_allocation_is_disabled
#
define
ALLOC_AND_ZERO
(
s
)
lz4_error_memory_allocation_is_disabled
#
define
FREEMEM
(
p
)
lz4_error_memory_allocation_is_disabled
#
elif
defined
(
LZ4_USER_MEMORY_FUNCTIONS
)
void
*
LZ4_malloc
(
size_t
s
)
;
void
*
LZ4_calloc
(
size_t
n
size_t
s
)
;
void
LZ4_free
(
void
*
p
)
;
#
define
ALLOC
(
s
)
LZ4_malloc
(
s
)
#
define
ALLOC_AND_ZERO
(
s
)
LZ4_calloc
(
1
s
)
#
define
FREEMEM
(
p
)
LZ4_free
(
p
)
#
else
#
include
<
stdlib
.
h
>
#
define
ALLOC
(
s
)
malloc
(
s
)
#
define
ALLOC_AND_ZERO
(
s
)
calloc
(
1
s
)
#
define
FREEMEM
(
p
)
free
(
p
)
#
endif
#
if
!
LZ4_FREESTANDING
#
include
<
string
.
h
>
#
endif
#
if
!
defined
(
LZ4_memset
)
#
define
LZ4_memset
(
p
v
s
)
memset
(
(
p
)
(
v
)
(
s
)
)
#
endif
#
define
MEM_INIT
(
p
v
s
)
LZ4_memset
(
(
p
)
(
v
)
(
s
)
)
#
define
MINMATCH
4
#
define
WILDCOPYLENGTH
8
#
define
LASTLITERALS
5
/
*
see
.
.
/
doc
/
lz4_Block_format
.
md
#
parsing
-
restrictions
*
/
#
define
MFLIMIT
12
/
*
see
.
.
/
doc
/
lz4_Block_format
.
md
#
parsing
-
restrictions
*
/
#
define
MATCH_SAFEGUARD_DISTANCE
(
(
2
*
WILDCOPYLENGTH
)
-
MINMATCH
)
/
*
ensure
it
'
s
possible
to
write
2
x
wildcopyLength
without
overflowing
output
buffer
*
/
#
define
FASTLOOP_SAFE_DISTANCE
64
static
const
int
LZ4_minLength
=
(
MFLIMIT
+
1
)
;
#
define
KB
*
(
1
<
<
10
)
#
define
MB
*
(
1
<
<
20
)
#
define
GB
*
(
1U
<
<
30
)
#
define
LZ4_DISTANCE_ABSOLUTE_MAX
65535
#
if
(
LZ4_DISTANCE_MAX
>
LZ4_DISTANCE_ABSOLUTE_MAX
)
#
error
"
LZ4_DISTANCE_MAX
is
too
big
:
must
be
<
=
65535
"
#
endif
#
define
ML_BITS
4
#
define
ML_MASK
(
(
1U
<
<
ML_BITS
)
-
1
)
#
define
RUN_BITS
(
8
-
ML_BITS
)
#
define
RUN_MASK
(
(
1U
<
<
RUN_BITS
)
-
1
)
#
if
defined
(
LZ4_DEBUG
)
&
&
(
LZ4_DEBUG
>
=
1
)
#
include
<
assert
.
h
>
#
else
#
ifndef
assert
#
define
assert
(
condition
)
(
(
void
)
0
)
#
endif
#
endif
#
define
LZ4_STATIC_ASSERT
(
c
)
{
enum
{
LZ4_static_assert
=
1
/
(
int
)
(
!
!
(
c
)
)
}
;
}
/
*
use
after
variable
declarations
*
/
#
if
defined
(
LZ4_DEBUG
)
&
&
(
LZ4_DEBUG
>
=
2
)
#
include
<
stdio
.
h
>
static
int
g_debuglog_enable
=
1
;
#
define
DEBUGLOG
(
l
.
.
.
)
{
\
if
(
(
g_debuglog_enable
)
&
&
(
l
<
=
LZ4_DEBUG
)
)
{
\
fprintf
(
stderr
__FILE__
"
%
i
:
"
__LINE__
)
;
\
fprintf
(
stderr
__VA_ARGS__
)
;
\
fprintf
(
stderr
"
\
n
"
)
;
\
}
}
#
else
#
define
DEBUGLOG
(
l
.
.
.
)
{
}
/
*
disabled
*
/
#
endif
static
int
LZ4_isAligned
(
const
void
*
ptr
size_t
alignment
)
{
return
(
(
size_t
)
ptr
&
(
alignment
-
1
)
)
=
=
0
;
}
#
include
<
limits
.
h
>
#
if
defined
(
__cplusplus
)
|
|
(
defined
(
__STDC_VERSION__
)
&
&
(
__STDC_VERSION__
>
=
199901L
)
)
#
include
<
stdint
.
h
>
typedef
uint8_t
BYTE
;
typedef
uint16_t
U16
;
typedef
uint32_t
U32
;
typedef
int32_t
S32
;
typedef
uint64_t
U64
;
typedef
uintptr_t
uptrval
;
#
else
#
if
UINT_MAX
!
=
4294967295UL
#
error
"
LZ4
code
(
when
not
C
+
+
or
C99
)
assumes
that
sizeof
(
int
)
=
=
4
"
#
endif
typedef
unsigned
char
BYTE
;
typedef
unsigned
short
U16
;
typedef
unsigned
int
U32
;
typedef
signed
int
S32
;
typedef
unsigned
long
long
U64
;
typedef
size_t
uptrval
;
#
endif
#
if
defined
(
__x86_64__
)
typedef
U64
reg_t
;
#
else
typedef
size_t
reg_t
;
#
endif
typedef
enum
{
notLimited
=
0
limitedOutput
=
1
fillOutput
=
2
}
limitedOutput_directive
;
#
if
!
defined
(
LZ4_memcpy
)
#
if
defined
(
__GNUC__
)
&
&
(
__GNUC__
>
=
4
)
#
define
LZ4_memcpy
(
dst
src
size
)
__builtin_memcpy
(
dst
src
size
)
#
else
#
define
LZ4_memcpy
(
dst
src
size
)
memcpy
(
dst
src
size
)
#
endif
#
endif
#
if
!
defined
(
LZ4_memmove
)
#
if
defined
(
__GNUC__
)
&
&
(
__GNUC__
>
=
4
)
#
define
LZ4_memmove
__builtin_memmove
#
else
#
define
LZ4_memmove
memmove
#
endif
#
endif
static
unsigned
LZ4_isLittleEndian
(
void
)
{
const
union
{
U32
u
;
BYTE
c
[
4
]
;
}
one
=
{
1
}
;
return
one
.
c
[
0
]
;
}
#
if
defined
(
__GNUC__
)
|
|
defined
(
__INTEL_COMPILER
)
#
define
LZ4_PACK
(
__Declaration__
)
__Declaration__
__attribute__
(
(
__packed__
)
)
#
elif
defined
(
_MSC_VER
)
#
define
LZ4_PACK
(
__Declaration__
)
__pragma
(
pack
(
push
1
)
)
__Declaration__
__pragma
(
pack
(
pop
)
)
#
endif
#
if
defined
(
LZ4_FORCE_MEMORY_ACCESS
)
&
&
(
LZ4_FORCE_MEMORY_ACCESS
=
=
2
)
static
U16
LZ4_read16
(
const
void
*
memPtr
)
{
return
*
(
const
U16
*
)
memPtr
;
}
static
U32
LZ4_read32
(
const
void
*
memPtr
)
{
return
*
(
const
U32
*
)
memPtr
;
}
static
reg_t
LZ4_read_ARCH
(
const
void
*
memPtr
)
{
return
*
(
const
reg_t
*
)
memPtr
;
}
static
void
LZ4_write16
(
void
*
memPtr
U16
value
)
{
*
(
U16
*
)
memPtr
=
value
;
}
static
void
LZ4_write32
(
void
*
memPtr
U32
value
)
{
*
(
U32
*
)
memPtr
=
value
;
}
#
elif
defined
(
LZ4_FORCE_MEMORY_ACCESS
)
&
&
(
LZ4_FORCE_MEMORY_ACCESS
=
=
1
)
LZ4_PACK
(
typedef
struct
{
U16
u16
;
}
)
LZ4_unalign16
;
LZ4_PACK
(
typedef
struct
{
U32
u32
;
}
)
LZ4_unalign32
;
LZ4_PACK
(
typedef
struct
{
reg_t
uArch
;
}
)
LZ4_unalignST
;
static
U16
LZ4_read16
(
const
void
*
ptr
)
{
return
(
(
const
LZ4_unalign16
*
)
ptr
)
-
>
u16
;
}
static
U32
LZ4_read32
(
const
void
*
ptr
)
{
return
(
(
const
LZ4_unalign32
*
)
ptr
)
-
>
u32
;
}
static
reg_t
LZ4_read_ARCH
(
const
void
*
ptr
)
{
return
(
(
const
LZ4_unalignST
*
)
ptr
)
-
>
uArch
;
}
static
void
LZ4_write16
(
void
*
memPtr
U16
value
)
{
(
(
LZ4_unalign16
*
)
memPtr
)
-
>
u16
=
value
;
}
static
void
LZ4_write32
(
void
*
memPtr
U32
value
)
{
(
(
LZ4_unalign32
*
)
memPtr
)
-
>
u32
=
value
;
}
#
else
static
U16
LZ4_read16
(
const
void
*
memPtr
)
{
U16
val
;
LZ4_memcpy
(
&
val
memPtr
sizeof
(
val
)
)
;
return
val
;
}
static
U32
LZ4_read32
(
const
void
*
memPtr
)
{
U32
val
;
LZ4_memcpy
(
&
val
memPtr
sizeof
(
val
)
)
;
return
val
;
}
static
reg_t
LZ4_read_ARCH
(
const
void
*
memPtr
)
{
reg_t
val
;
LZ4_memcpy
(
&
val
memPtr
sizeof
(
val
)
)
;
return
val
;
}
static
void
LZ4_write16
(
void
*
memPtr
U16
value
)
{
LZ4_memcpy
(
memPtr
&
value
sizeof
(
value
)
)
;
}
static
void
LZ4_write32
(
void
*
memPtr
U32
value
)
{
LZ4_memcpy
(
memPtr
&
value
sizeof
(
value
)
)
;
}
#
endif
static
U16
LZ4_readLE16
(
const
void
*
memPtr
)
{
if
(
LZ4_isLittleEndian
(
)
)
{
return
LZ4_read16
(
memPtr
)
;
}
else
{
const
BYTE
*
p
=
(
const
BYTE
*
)
memPtr
;
return
(
U16
)
(
(
U16
)
p
[
0
]
|
(
p
[
1
]
<
<
8
)
)
;
}
}
#
ifdef
LZ4_STATIC_LINKING_ONLY_ENDIANNESS_INDEPENDENT_OUTPUT
static
U32
LZ4_readLE32
(
const
void
*
memPtr
)
{
if
(
LZ4_isLittleEndian
(
)
)
{
return
LZ4_read32
(
memPtr
)
;
}
else
{
const
BYTE
*
p
=
(
const
BYTE
*
)
memPtr
;
return
(
U32
)
p
[
0
]
|
(
p
[
1
]
<
<
8
)
|
(
p
[
2
]
<
<
16
)
|
(
p
[
3
]
<
<
24
)
;
}
}
#
endif
static
void
LZ4_writeLE16
(
void
*
memPtr
U16
value
)
{
if
(
LZ4_isLittleEndian
(
)
)
{
LZ4_write16
(
memPtr
value
)
;
}
else
{
BYTE
*
p
=
(
BYTE
*
)
memPtr
;
p
[
0
]
=
(
BYTE
)
value
;
p
[
1
]
=
(
BYTE
)
(
value
>
>
8
)
;
}
}
LZ4_FORCE_INLINE
void
LZ4_wildCopy8
(
void
*
dstPtr
const
void
*
srcPtr
void
*
dstEnd
)
{
BYTE
*
d
=
(
BYTE
*
)
dstPtr
;
const
BYTE
*
s
=
(
const
BYTE
*
)
srcPtr
;
BYTE
*
const
e
=
(
BYTE
*
)
dstEnd
;
do
{
LZ4_memcpy
(
d
s
8
)
;
d
+
=
8
;
s
+
=
8
;
}
while
(
d
<
e
)
;
}
static
const
unsigned
inc32table
[
8
]
=
{
0
1
2
1
0
4
4
4
}
;
static
const
int
dec64table
[
8
]
=
{
0
0
0
-
1
-
4
1
2
3
}
;
#
ifndef
LZ4_FAST_DEC_LOOP
#
if
defined
__i386__
|
|
defined
_M_IX86
|
|
defined
__x86_64__
|
|
defined
_M_X64
#
define
LZ4_FAST_DEC_LOOP
1
#
elif
defined
(
__aarch64__
)
&
&
defined
(
__APPLE__
)
#
define
LZ4_FAST_DEC_LOOP
1
#
elif
defined
(
__aarch64__
)
&
&
!
defined
(
__clang__
)
#
define
LZ4_FAST_DEC_LOOP
1
#
else
#
define
LZ4_FAST_DEC_LOOP
0
#
endif
#
endif
#
if
LZ4_FAST_DEC_LOOP
LZ4_FORCE_INLINE
void
LZ4_memcpy_using_offset_base
(
BYTE
*
dstPtr
const
BYTE
*
srcPtr
BYTE
*
dstEnd
const
size_t
offset
)
{
assert
(
srcPtr
+
offset
=
=
dstPtr
)
;
if
(
offset
<
8
)
{
LZ4_write32
(
dstPtr
0
)
;
dstPtr
[
0
]
=
srcPtr
[
0
]
;
dstPtr
[
1
]
=
srcPtr
[
1
]
;
dstPtr
[
2
]
=
srcPtr
[
2
]
;
dstPtr
[
3
]
=
srcPtr
[
3
]
;
srcPtr
+
=
inc32table
[
offset
]
;
LZ4_memcpy
(
dstPtr
+
4
srcPtr
4
)
;
srcPtr
-
=
dec64table
[
offset
]
;
dstPtr
+
=
8
;
}
else
{
LZ4_memcpy
(
dstPtr
srcPtr
8
)
;
dstPtr
+
=
8
;
srcPtr
+
=
8
;
}
LZ4_wildCopy8
(
dstPtr
srcPtr
dstEnd
)
;
}
LZ4_FORCE_INLINE
void
LZ4_wildCopy32
(
void
*
dstPtr
const
void
*
srcPtr
void
*
dstEnd
)
{
BYTE
*
d
=
(
BYTE
*
)
dstPtr
;
const
BYTE
*
s
=
(
const
BYTE
*
)
srcPtr
;
BYTE
*
const
e
=
(
BYTE
*
)
dstEnd
;
do
{
LZ4_memcpy
(
d
s
16
)
;
LZ4_memcpy
(
d
+
16
s
+
16
16
)
;
d
+
=
32
;
s
+
=
32
;
}
while
(
d
<
e
)
;
}
LZ4_FORCE_INLINE
void
LZ4_memcpy_using_offset
(
BYTE
*
dstPtr
const
BYTE
*
srcPtr
BYTE
*
dstEnd
const
size_t
offset
)
{
BYTE
v
[
8
]
;
assert
(
dstEnd
>
=
dstPtr
+
MINMATCH
)
;
switch
(
offset
)
{
case
1
:
MEM_INIT
(
v
*
srcPtr
8
)
;
break
;
case
2
:
LZ4_memcpy
(
v
srcPtr
2
)
;
LZ4_memcpy
(
&
v
[
2
]
srcPtr
2
)
;
#
if
defined
(
_MSC_VER
)
&
&
(
_MSC_VER
<
=
1937
)
#
pragma
warning
(
push
)
#
pragma
warning
(
disable
:
6385
)
/
*
warning
C6385
:
Reading
invalid
data
from
'
v
'
.
*
/
#
endif
LZ4_memcpy
(
&
v
[
4
]
v
4
)
;
#
if
defined
(
_MSC_VER
)
&
&
(
_MSC_VER
<
=
1937
)
#
pragma
warning
(
pop
)
#
endif
break
;
case
4
:
LZ4_memcpy
(
v
srcPtr
4
)
;
LZ4_memcpy
(
&
v
[
4
]
srcPtr
4
)
;
break
;
default
:
LZ4_memcpy_using_offset_base
(
dstPtr
srcPtr
dstEnd
offset
)
;
return
;
}
LZ4_memcpy
(
dstPtr
v
8
)
;
dstPtr
+
=
8
;
while
(
dstPtr
<
dstEnd
)
{
LZ4_memcpy
(
dstPtr
v
8
)
;
dstPtr
+
=
8
;
}
}
#
endif
static
unsigned
LZ4_NbCommonBytes
(
reg_t
val
)
{
assert
(
val
!
=
0
)
;
if
(
LZ4_isLittleEndian
(
)
)
{
if
(
sizeof
(
val
)
=
=
8
)
{
#
if
defined
(
_MSC_VER
)
&
&
(
_MSC_VER
>
=
1800
)
&
&
(
defined
(
_M_AMD64
)
&
&
!
defined
(
_M_ARM64EC
)
)
&
&
!
defined
(
LZ4_FORCE_SW_BITCOUNT
)
#
if
defined
(
__clang__
)
&
&
(
__clang_major__
<
10
)
return
(
unsigned
)
__builtin_ia32_tzcnt_u64
(
val
)
>
>
3
;
#
else
return
(
unsigned
)
_tzcnt_u64
(
val
)
>
>
3
;
#
endif
#
elif
defined
(
_MSC_VER
)
&
&
defined
(
_WIN64
)
&
&
!
defined
(
LZ4_FORCE_SW_BITCOUNT
)
unsigned
long
r
=
0
;
_BitScanForward64
(
&
r
(
U64
)
val
)
;
return
(
unsigned
)
r
>
>
3
;
#
elif
(
defined
(
__clang__
)
|
|
(
defined
(
__GNUC__
)
&
&
(
(
__GNUC__
>
3
)
|
|
\
(
(
__GNUC__
=
=
3
)
&
&
(
__GNUC_MINOR__
>
=
4
)
)
)
)
)
&
&
\
!
defined
(
LZ4_FORCE_SW_BITCOUNT
)
return
(
unsigned
)
__builtin_ctzll
(
(
U64
)
val
)
>
>
3
;
#
else
const
U64
m
=
0x0101010101010101ULL
;
val
^
=
val
-
1
;
return
(
unsigned
)
(
(
(
U64
)
(
(
val
&
(
m
-
1
)
)
*
m
)
)
>
>
56
)
;
#
endif
}
else
{
#
if
defined
(
_MSC_VER
)
&
&
(
_MSC_VER
>
=
1400
)
&
&
!
defined
(
LZ4_FORCE_SW_BITCOUNT
)
unsigned
long
r
;
_BitScanForward
(
&
r
(
U32
)
val
)
;
return
(
unsigned
)
r
>
>
3
;
#
elif
(
defined
(
__clang__
)
|
|
(
defined
(
__GNUC__
)
&
&
(
(
__GNUC__
>
3
)
|
|
\
(
(
__GNUC__
=
=
3
)
&
&
(
__GNUC_MINOR__
>
=
4
)
)
)
)
)
&
&
\
!
defined
(
__TINYC__
)
&
&
!
defined
(
LZ4_FORCE_SW_BITCOUNT
)
return
(
unsigned
)
__builtin_ctz
(
(
U32
)
val
)
>
>
3
;
#
else
const
U32
m
=
0x01010101
;
return
(
unsigned
)
(
(
(
(
val
-
1
)
^
val
)
&
(
m
-
1
)
)
*
m
)
>
>
24
;
#
endif
}
}
else
{
if
(
sizeof
(
val
)
=
=
8
)
{
#
if
(
defined
(
__clang__
)
|
|
(
defined
(
__GNUC__
)
&
&
(
(
__GNUC__
>
3
)
|
|
\
(
(
__GNUC__
=
=
3
)
&
&
(
__GNUC_MINOR__
>
=
4
)
)
)
)
)
&
&
\
!
defined
(
__TINYC__
)
&
&
!
defined
(
LZ4_FORCE_SW_BITCOUNT
)
return
(
unsigned
)
__builtin_clzll
(
(
U64
)
val
)
>
>
3
;
#
else
#
if
1
static
const
unsigned
char
ctz7_tab
[
128
]
=
{
7
0
1
0
2
0
1
0
3
0
1
0
2
0
1
0
4
0
1
0
2
0
1
0
3
0
1
0
2
0
1
0
5
0
1
0
2
0
1
0
3
0
1
0
2
0
1
0
4
0
1
0
2
0
1
0
3
0
1
0
2
0
1
0
6
0
1
0
2
0
1
0
3
0
1
0
2
0
1
0
4
0
1
0
2
0
1
0
3
0
1
0
2
0
1
0
5
0
1
0
2
0
1
0
3
0
1
0
2
0
1
0
4
0
1
0
2
0
1
0
3
0
1
0
2
0
1
0
}
;
U64
const
mask
=
0x0101010101010101ULL
;
U64
const
t
=
(
(
(
val
>
>
8
)
-
mask
)
|
val
)
&
mask
;
return
ctz7_tab
[
(
t
*
0x0080402010080402ULL
)
>
>
57
]
;
#
else
static
const
U32
by32
=
sizeof
(
val
)
*
4
;
unsigned
r
;
if
(
!
(
val
>
>
by32
)
)
{
r
=
4
;
}
else
{
r
=
0
;
val
>
>
=
by32
;
}
if
(
!
(
val
>
>
16
)
)
{
r
+
=
2
;
val
>
>
=
8
;
}
else
{
val
>
>
=
24
;
}
r
+
=
(
!
val
)
;
return
r
;
#
endif
#
endif
}
else
{
#
if
(
defined
(
__clang__
)
|
|
(
defined
(
__GNUC__
)
&
&
(
(
__GNUC__
>
3
)
|
|
\
(
(
__GNUC__
=
=
3
)
&
&
(
__GNUC_MINOR__
>
=
4
)
)
)
)
)
&
&
\
!
defined
(
LZ4_FORCE_SW_BITCOUNT
)
return
(
unsigned
)
__builtin_clz
(
(
U32
)
val
)
>
>
3
;
#
else
val
>
>
=
8
;
val
=
(
(
(
(
val
+
0x00FFFF00
)
|
0x00FFFFFF
)
+
val
)
|
(
val
+
0x00FF0000
)
)
>
>
24
;
return
(
unsigned
)
val
^
3
;
#
endif
}
}
}
#
define
STEPSIZE
sizeof
(
reg_t
)
LZ4_FORCE_INLINE
unsigned
LZ4_count
(
const
BYTE
*
pIn
const
BYTE
*
pMatch
const
BYTE
*
pInLimit
)
{
const
BYTE
*
const
pStart
=
pIn
;
if
(
likely
(
pIn
<
pInLimit
-
(
STEPSIZE
-
1
)
)
)
{
reg_t
const
diff
=
LZ4_read_ARCH
(
pMatch
)
^
LZ4_read_ARCH
(
pIn
)
;
if
(
!
diff
)
{
pIn
+
=
STEPSIZE
;
pMatch
+
=
STEPSIZE
;
}
else
{
return
LZ4_NbCommonBytes
(
diff
)
;
}
}
while
(
likely
(
pIn
<
pInLimit
-
(
STEPSIZE
-
1
)
)
)
{
reg_t
const
diff
=
LZ4_read_ARCH
(
pMatch
)
^
LZ4_read_ARCH
(
pIn
)
;
if
(
!
diff
)
{
pIn
+
=
STEPSIZE
;
pMatch
+
=
STEPSIZE
;
continue
;
}
pIn
+
=
LZ4_NbCommonBytes
(
diff
)
;
return
(
unsigned
)
(
pIn
-
pStart
)
;
}
if
(
(
STEPSIZE
=
=
8
)
&
&
(
pIn
<
(
pInLimit
-
3
)
)
&
&
(
LZ4_read32
(
pMatch
)
=
=
LZ4_read32
(
pIn
)
)
)
{
pIn
+
=
4
;
pMatch
+
=
4
;
}
if
(
(
pIn
<
(
pInLimit
-
1
)
)
&
&
(
LZ4_read16
(
pMatch
)
=
=
LZ4_read16
(
pIn
)
)
)
{
pIn
+
=
2
;
pMatch
+
=
2
;
}
if
(
(
pIn
<
pInLimit
)
&
&
(
*
pMatch
=
=
*
pIn
)
)
pIn
+
+
;
return
(
unsigned
)
(
pIn
-
pStart
)
;
}
#
ifndef
LZ4_COMMONDEFS_ONLY
static
const
int
LZ4_64Klimit
=
(
(
64
KB
)
+
(
MFLIMIT
-
1
)
)
;
static
const
U32
LZ4_skipTrigger
=
6
;
typedef
enum
{
clearedTable
=
0
byPtr
byU32
byU16
}
tableType_t
;
typedef
enum
{
noDict
=
0
withPrefix64k
usingExtDict
usingDictCtx
}
dict_directive
;
typedef
enum
{
noDictIssue
=
0
dictSmall
}
dictIssue_directive
;
int
LZ4_versionNumber
(
void
)
{
return
LZ4_VERSION_NUMBER
;
}
const
char
*
LZ4_versionString
(
void
)
{
return
LZ4_VERSION_STRING
;
}
int
LZ4_compressBound
(
int
isize
)
{
return
LZ4_COMPRESSBOUND
(
isize
)
;
}
int
LZ4_sizeofState
(
void
)
{
return
sizeof
(
LZ4_stream_t
)
;
}
#
if
defined
(
__cplusplus
)
extern
"
C
"
{
#
endif
int
LZ4_compress_forceExtDict
(
LZ4_stream_t
*
LZ4_dict
const
char
*
source
char
*
dest
int
srcSize
)
;
int
LZ4_decompress_safe_forceExtDict
(
const
char
*
source
char
*
dest
int
compressedSize
int
maxOutputSize
const
void
*
dictStart
size_t
dictSize
)
;
int
LZ4_decompress_safe_partial_forceExtDict
(
const
char
*
source
char
*
dest
int
compressedSize
int
targetOutputSize
int
dstCapacity
const
void
*
dictStart
size_t
dictSize
)
;
#
if
defined
(
__cplusplus
)
}
#
endif
LZ4_FORCE_INLINE
U32
LZ4_hash4
(
U32
sequence
tableType_t
const
tableType
)
{
if
(
tableType
=
=
byU16
)
return
(
(
sequence
*
2654435761U
)
>
>
(
(
MINMATCH
*
8
)
-
(
LZ4_HASHLOG
+
1
)
)
)
;
else
return
(
(
sequence
*
2654435761U
)
>
>
(
(
MINMATCH
*
8
)
-
LZ4_HASHLOG
)
)
;
}
LZ4_FORCE_INLINE
U32
LZ4_hash5
(
U64
sequence
tableType_t
const
tableType
)
{
const
U32
hashLog
=
(
tableType
=
=
byU16
)
?
LZ4_HASHLOG
+
1
:
LZ4_HASHLOG
;
if
(
LZ4_isLittleEndian
(
)
)
{
const
U64
prime5bytes
=
889523592379ULL
;
return
(
U32
)
(
(
(
sequence
<
<
24
)
*
prime5bytes
)
>
>
(
64
-
hashLog
)
)
;
}
else
{
const
U64
prime8bytes
=
11400714785074694791ULL
;
return
(
U32
)
(
(
(
sequence
>
>
24
)
*
prime8bytes
)
>
>
(
64
-
hashLog
)
)
;
}
}
LZ4_FORCE_INLINE
U32
LZ4_hashPosition
(
const
void
*
const
p
tableType_t
const
tableType
)
{
if
(
(
sizeof
(
reg_t
)
=
=
8
)
&
&
(
tableType
!
=
byU16
)
)
return
LZ4_hash5
(
LZ4_read_ARCH
(
p
)
tableType
)
;
#
ifdef
LZ4_STATIC_LINKING_ONLY_ENDIANNESS_INDEPENDENT_OUTPUT
return
LZ4_hash4
(
LZ4_readLE32
(
p
)
tableType
)
;
#
else
return
LZ4_hash4
(
LZ4_read32
(
p
)
tableType
)
;
#
endif
}
LZ4_FORCE_INLINE
void
LZ4_clearHash
(
U32
h
void
*
tableBase
tableType_t
const
tableType
)
{
switch
(
tableType
)
{
default
:
case
clearedTable
:
{
assert
(
0
)
;
return
;
}
case
byPtr
:
{
const
BYTE
*
*
hashTable
=
(
const
BYTE
*
*
)
tableBase
;
hashTable
[
h
]
=
NULL
;
return
;
}
case
byU32
:
{
U32
*
hashTable
=
(
U32
*
)
tableBase
;
hashTable
[
h
]
=
0
;
return
;
}
case
byU16
:
{
U16
*
hashTable
=
(
U16
*
)
tableBase
;
hashTable
[
h
]
=
0
;
return
;
}
}
}
LZ4_FORCE_INLINE
void
LZ4_putIndexOnHash
(
U32
idx
U32
h
void
*
tableBase
tableType_t
const
tableType
)
{
switch
(
tableType
)
{
default
:
case
clearedTable
:
case
byPtr
:
{
assert
(
0
)
;
return
;
}
case
byU32
:
{
U32
*
hashTable
=
(
U32
*
)
tableBase
;
hashTable
[
h
]
=
idx
;
return
;
}
case
byU16
:
{
U16
*
hashTable
=
(
U16
*
)
tableBase
;
assert
(
idx
<
65536
)
;
hashTable
[
h
]
=
(
U16
)
idx
;
return
;
}
}
}
LZ4_FORCE_INLINE
void
LZ4_putPositionOnHash
(
const
BYTE
*
p
U32
h
void
*
tableBase
tableType_t
const
tableType
)
{
const
BYTE
*
*
const
hashTable
=
(
const
BYTE
*
*
)
tableBase
;
assert
(
tableType
=
=
byPtr
)
;
(
void
)
tableType
;
hashTable
[
h
]
=
p
;
}
LZ4_FORCE_INLINE
void
LZ4_putPosition
(
const
BYTE
*
p
void
*
tableBase
tableType_t
tableType
)
{
U32
const
h
=
LZ4_hashPosition
(
p
tableType
)
;
LZ4_putPositionOnHash
(
p
h
tableBase
tableType
)
;
}
LZ4_FORCE_INLINE
U32
LZ4_getIndexOnHash
(
U32
h
const
void
*
tableBase
tableType_t
tableType
)
{
LZ4_STATIC_ASSERT
(
LZ4_MEMORY_USAGE
>
2
)
;
if
(
tableType
=
=
byU32
)
{
const
U32
*
const
hashTable
=
(
const
U32
*
)
tableBase
;
assert
(
h
<
(
1U
<
<
(
LZ4_MEMORY_USAGE
-
2
)
)
)
;
return
hashTable
[
h
]
;
}
if
(
tableType
=
=
byU16
)
{
const
U16
*
const
hashTable
=
(
const
U16
*
)
tableBase
;
assert
(
h
<
(
1U
<
<
(
LZ4_MEMORY_USAGE
-
1
)
)
)
;
return
hashTable
[
h
]
;
}
assert
(
0
)
;
return
0
;
}
static
const
BYTE
*
LZ4_getPositionOnHash
(
U32
h
const
void
*
tableBase
tableType_t
tableType
)
{
assert
(
tableType
=
=
byPtr
)
;
(
void
)
tableType
;
{
const
BYTE
*
const
*
hashTable
=
(
const
BYTE
*
const
*
)
tableBase
;
return
hashTable
[
h
]
;
}
}
LZ4_FORCE_INLINE
const
BYTE
*
LZ4_getPosition
(
const
BYTE
*
p
const
void
*
tableBase
tableType_t
tableType
)
{
U32
const
h
=
LZ4_hashPosition
(
p
tableType
)
;
return
LZ4_getPositionOnHash
(
h
tableBase
tableType
)
;
}
LZ4_FORCE_INLINE
void
LZ4_prepareTable
(
LZ4_stream_t_internal
*
const
cctx
const
int
inputSize
const
tableType_t
tableType
)
{
if
(
(
tableType_t
)
cctx
-
>
tableType
!
=
clearedTable
)
{
assert
(
inputSize
>
=
0
)
;
if
(
(
tableType_t
)
cctx
-
>
tableType
!
=
tableType
|
|
(
(
tableType
=
=
byU16
)
&
&
cctx
-
>
currentOffset
+
(
unsigned
)
inputSize
>
=
0xFFFFU
)
|
|
(
(
tableType
=
=
byU32
)
&
&
cctx
-
>
currentOffset
>
1
GB
)
|
|
tableType
=
=
byPtr
|
|
inputSize
>
=
4
KB
)
{
DEBUGLOG
(
4
"
LZ4_prepareTable
:
Resetting
table
in
%
p
"
cctx
)
;
MEM_INIT
(
cctx
-
>
hashTable
0
LZ4_HASHTABLESIZE
)
;
cctx
-
>
currentOffset
=
0
;
cctx
-
>
tableType
=
(
U32
)
clearedTable
;
}
else
{
DEBUGLOG
(
4
"
LZ4_prepareTable
:
Re
-
use
hash
table
(
no
reset
)
"
)
;
}
}
if
(
cctx
-
>
currentOffset
!
=
0
&
&
tableType
=
=
byU32
)
{
DEBUGLOG
(
5
"
LZ4_prepareTable
:
adding
64KB
to
currentOffset
"
)
;
cctx
-
>
currentOffset
+
=
64
KB
;
}
cctx
-
>
dictCtx
=
NULL
;
cctx
-
>
dictionary
=
NULL
;
cctx
-
>
dictSize
=
0
;
}
LZ4_FORCE_INLINE
int
LZ4_compress_generic_validated
(
LZ4_stream_t_internal
*
const
cctx
const
char
*
const
source
char
*
const
dest
const
int
inputSize
int
*
inputConsumed
const
int
maxOutputSize
const
limitedOutput_directive
outputDirective
const
tableType_t
tableType
const
dict_directive
dictDirective
const
dictIssue_directive
dictIssue
const
int
acceleration
)
{
int
result
;
const
BYTE
*
ip
=
(
const
BYTE
*
)
source
;
U32
const
startIndex
=
cctx
-
>
currentOffset
;
const
BYTE
*
base
=
(
const
BYTE
*
)
source
-
startIndex
;
const
BYTE
*
lowLimit
;
const
LZ4_stream_t_internal
*
dictCtx
=
(
const
LZ4_stream_t_internal
*
)
cctx
-
>
dictCtx
;
const
BYTE
*
const
dictionary
=
dictDirective
=
=
usingDictCtx
?
dictCtx
-
>
dictionary
:
cctx
-
>
dictionary
;
const
U32
dictSize
=
dictDirective
=
=
usingDictCtx
?
dictCtx
-
>
dictSize
:
cctx
-
>
dictSize
;
const
U32
dictDelta
=
(
dictDirective
=
=
usingDictCtx
)
?
startIndex
-
dictCtx
-
>
currentOffset
:
0
;
int
const
maybe_extMem
=
(
dictDirective
=
=
usingExtDict
)
|
|
(
dictDirective
=
=
usingDictCtx
)
;
U32
const
prefixIdxLimit
=
startIndex
-
dictSize
;
const
BYTE
*
const
dictEnd
=
dictionary
?
dictionary
+
dictSize
:
dictionary
;
const
BYTE
*
anchor
=
(
const
BYTE
*
)
source
;
const
BYTE
*
const
iend
=
ip
+
inputSize
;
const
BYTE
*
const
mflimitPlusOne
=
iend
-
MFLIMIT
+
1
;
const
BYTE
*
const
matchlimit
=
iend
-
LASTLITERALS
;
const
BYTE
*
dictBase
=
(
dictionary
=
=
NULL
)
?
NULL
:
(
dictDirective
=
=
usingDictCtx
)
?
dictionary
+
dictSize
-
dictCtx
-
>
currentOffset
:
dictionary
+
dictSize
-
startIndex
;
BYTE
*
op
=
(
BYTE
*
)
dest
;
BYTE
*
const
olimit
=
op
+
maxOutputSize
;
U32
offset
=
0
;
U32
forwardH
;
DEBUGLOG
(
5
"
LZ4_compress_generic_validated
:
srcSize
=
%
i
tableType
=
%
u
"
inputSize
tableType
)
;
assert
(
ip
!
=
NULL
)
;
if
(
tableType
=
=
byU16
)
assert
(
inputSize
<
LZ4_64Klimit
)
;
if
(
tableType
=
=
byPtr
)
assert
(
dictDirective
=
=
noDict
)
;
if
(
outputDirective
=
=
fillOutput
&
&
maxOutputSize
<
1
)
{
return
0
;
}
assert
(
acceleration
>
=
1
)
;
lowLimit
=
(
const
BYTE
*
)
source
-
(
dictDirective
=
=
withPrefix64k
?
dictSize
:
0
)
;
if
(
dictDirective
=
=
usingDictCtx
)
{
cctx
-
>
dictCtx
=
NULL
;
cctx
-
>
dictSize
=
(
U32
)
inputSize
;
}
else
{
cctx
-
>
dictSize
+
=
(
U32
)
inputSize
;
}
cctx
-
>
currentOffset
+
=
(
U32
)
inputSize
;
cctx
-
>
tableType
=
(
U32
)
tableType
;
if
(
inputSize
<
LZ4_minLength
)
goto
_last_literals
;
{
U32
const
h
=
LZ4_hashPosition
(
ip
tableType
)
;
if
(
tableType
=
=
byPtr
)
{
LZ4_putPositionOnHash
(
ip
h
cctx
-
>
hashTable
byPtr
)
;
}
else
{
LZ4_putIndexOnHash
(
startIndex
h
cctx
-
>
hashTable
tableType
)
;
}
}
ip
+
+
;
forwardH
=
LZ4_hashPosition
(
ip
tableType
)
;
for
(
;
;
)
{
const
BYTE
*
match
;
BYTE
*
token
;
const
BYTE
*
filledIp
;
if
(
tableType
=
=
byPtr
)
{
const
BYTE
*
forwardIp
=
ip
;
int
step
=
1
;
int
searchMatchNb
=
acceleration
<
<
LZ4_skipTrigger
;
do
{
U32
const
h
=
forwardH
;
ip
=
forwardIp
;
forwardIp
+
=
step
;
step
=
(
searchMatchNb
+
+
>
>
LZ4_skipTrigger
)
;
if
(
unlikely
(
forwardIp
>
mflimitPlusOne
)
)
goto
_last_literals
;
assert
(
ip
<
mflimitPlusOne
)
;
match
=
LZ4_getPositionOnHash
(
h
cctx
-
>
hashTable
tableType
)
;
forwardH
=
LZ4_hashPosition
(
forwardIp
tableType
)
;
LZ4_putPositionOnHash
(
ip
h
cctx
-
>
hashTable
tableType
)
;
}
while
(
(
match
+
LZ4_DISTANCE_MAX
<
ip
)
|
|
(
LZ4_read32
(
match
)
!
=
LZ4_read32
(
ip
)
)
)
;
}
else
{
const
BYTE
*
forwardIp
=
ip
;
int
step
=
1
;
int
searchMatchNb
=
acceleration
<
<
LZ4_skipTrigger
;
do
{
U32
const
h
=
forwardH
;
U32
const
current
=
(
U32
)
(
forwardIp
-
base
)
;
U32
matchIndex
=
LZ4_getIndexOnHash
(
h
cctx
-
>
hashTable
tableType
)
;
assert
(
matchIndex
<
=
current
)
;
assert
(
forwardIp
-
base
<
(
ptrdiff_t
)
(
2
GB
-
1
)
)
;
ip
=
forwardIp
;
forwardIp
+
=
step
;
step
=
(
searchMatchNb
+
+
>
>
LZ4_skipTrigger
)
;
if
(
unlikely
(
forwardIp
>
mflimitPlusOne
)
)
goto
_last_literals
;
assert
(
ip
<
mflimitPlusOne
)
;
if
(
dictDirective
=
=
usingDictCtx
)
{
if
(
matchIndex
<
startIndex
)
{
assert
(
tableType
=
=
byU32
)
;
matchIndex
=
LZ4_getIndexOnHash
(
h
dictCtx
-
>
hashTable
byU32
)
;
match
=
dictBase
+
matchIndex
;
matchIndex
+
=
dictDelta
;
lowLimit
=
dictionary
;
}
else
{
match
=
base
+
matchIndex
;
lowLimit
=
(
const
BYTE
*
)
source
;
}
}
else
if
(
dictDirective
=
=
usingExtDict
)
{
if
(
matchIndex
<
startIndex
)
{
DEBUGLOG
(
7
"
extDict
candidate
:
matchIndex
=
%
5u
<
startIndex
=
%
5u
"
matchIndex
startIndex
)
;
assert
(
startIndex
-
matchIndex
>
=
MINMATCH
)
;
assert
(
dictBase
)
;
match
=
dictBase
+
matchIndex
;
lowLimit
=
dictionary
;
}
else
{
match
=
base
+
matchIndex
;
lowLimit
=
(
const
BYTE
*
)
source
;
}
}
else
{
match
=
base
+
matchIndex
;
}
forwardH
=
LZ4_hashPosition
(
forwardIp
tableType
)
;
LZ4_putIndexOnHash
(
current
h
cctx
-
>
hashTable
tableType
)
;
DEBUGLOG
(
7
"
candidate
at
pos
=
%
u
(
offset
=
%
u
\
n
"
matchIndex
current
-
matchIndex
)
;
if
(
(
dictIssue
=
=
dictSmall
)
&
&
(
matchIndex
<
prefixIdxLimit
)
)
{
continue
;
}
assert
(
matchIndex
<
current
)
;
if
(
(
(
tableType
!
=
byU16
)
|
|
(
LZ4_DISTANCE_MAX
<
LZ4_DISTANCE_ABSOLUTE_MAX
)
)
&
&
(
matchIndex
+
LZ4_DISTANCE_MAX
<
current
)
)
{
continue
;
}
assert
(
(
current
-
matchIndex
)
<
=
LZ4_DISTANCE_MAX
)
;
if
(
LZ4_read32
(
match
)
=
=
LZ4_read32
(
ip
)
)
{
if
(
maybe_extMem
)
offset
=
current
-
matchIndex
;
break
;
}
}
while
(
1
)
;
}
filledIp
=
ip
;
assert
(
ip
>
anchor
)
;
if
(
(
match
>
lowLimit
)
&
&
unlikely
(
ip
[
-
1
]
=
=
match
[
-
1
]
)
)
{
do
{
ip
-
-
;
match
-
-
;
}
while
(
(
(
ip
>
anchor
)
&
(
match
>
lowLimit
)
)
&
&
(
unlikely
(
ip
[
-
1
]
=
=
match
[
-
1
]
)
)
)
;
}
{
unsigned
const
litLength
=
(
unsigned
)
(
ip
-
anchor
)
;
token
=
op
+
+
;
if
(
(
outputDirective
=
=
limitedOutput
)
&
&
(
unlikely
(
op
+
litLength
+
(
2
+
1
+
LASTLITERALS
)
+
(
litLength
/
255
)
>
olimit
)
)
)
{
return
0
;
}
if
(
(
outputDirective
=
=
fillOutput
)
&
&
(
unlikely
(
op
+
(
litLength
+
240
)
/
255
+
litLength
+
2
+
1
+
MFLIMIT
-
MINMATCH
>
olimit
)
)
)
{
op
-
-
;
goto
_last_literals
;
}
if
(
litLength
>
=
RUN_MASK
)
{
unsigned
len
=
litLength
-
RUN_MASK
;
*
token
=
(
RUN_MASK
<
<
ML_BITS
)
;
for
(
;
len
>
=
255
;
len
-
=
255
)
*
op
+
+
=
255
;
*
op
+
+
=
(
BYTE
)
len
;
}
else
*
token
=
(
BYTE
)
(
litLength
<
<
ML_BITS
)
;
LZ4_wildCopy8
(
op
anchor
op
+
litLength
)
;
op
+
=
litLength
;
DEBUGLOG
(
6
"
seq
.
start
:
%
i
literals
=
%
u
match
.
start
:
%
i
"
(
int
)
(
anchor
-
(
const
BYTE
*
)
source
)
litLength
(
int
)
(
ip
-
(
const
BYTE
*
)
source
)
)
;
}
_next_match
:
if
(
(
outputDirective
=
=
fillOutput
)
&
&
(
op
+
2
+
1
+
MFLIMIT
-
MINMATCH
>
olimit
)
)
{
op
=
token
;
goto
_last_literals
;
}
if
(
maybe_extMem
)
{
DEBUGLOG
(
6
"
with
offset
=
%
u
(
ext
if
>
%
i
)
"
offset
(
int
)
(
ip
-
(
const
BYTE
*
)
source
)
)
;
assert
(
offset
<
=
LZ4_DISTANCE_MAX
&
&
offset
>
0
)
;
LZ4_writeLE16
(
op
(
U16
)
offset
)
;
op
+
=
2
;
}
else
{
DEBUGLOG
(
6
"
with
offset
=
%
u
(
same
segment
)
"
(
U32
)
(
ip
-
match
)
)
;
assert
(
ip
-
match
<
=
LZ4_DISTANCE_MAX
)
;
LZ4_writeLE16
(
op
(
U16
)
(
ip
-
match
)
)
;
op
+
=
2
;
}
{
unsigned
matchCode
;
if
(
(
dictDirective
=
=
usingExtDict
|
|
dictDirective
=
=
usingDictCtx
)
&
&
(
lowLimit
=
=
dictionary
)
)
{
const
BYTE
*
limit
=
ip
+
(
dictEnd
-
match
)
;
assert
(
dictEnd
>
match
)
;
if
(
limit
>
matchlimit
)
limit
=
matchlimit
;
matchCode
=
LZ4_count
(
ip
+
MINMATCH
match
+
MINMATCH
limit
)
;
ip
+
=
(
size_t
)
matchCode
+
MINMATCH
;
if
(
ip
=
=
limit
)
{
unsigned
const
more
=
LZ4_count
(
limit
(
const
BYTE
*
)
source
matchlimit
)
;
matchCode
+
=
more
;
ip
+
=
more
;
}
DEBUGLOG
(
6
"
with
matchLength
=
%
u
starting
in
extDict
"
matchCode
+
MINMATCH
)
;
}
else
{
matchCode
=
LZ4_count
(
ip
+
MINMATCH
match
+
MINMATCH
matchlimit
)
;
ip
+
=
(
size_t
)
matchCode
+
MINMATCH
;
DEBUGLOG
(
6
"
with
matchLength
=
%
u
"
matchCode
+
MINMATCH
)
;
}
if
(
(
outputDirective
)
&
&
(
unlikely
(
op
+
(
1
+
LASTLITERALS
)
+
(
matchCode
+
240
)
/
255
>
olimit
)
)
)
{
if
(
outputDirective
=
=
fillOutput
)
{
U32
newMatchCode
=
15
-
1
+
(
(
U32
)
(
olimit
-
op
)
-
1
-
LASTLITERALS
)
*
255
;
ip
-
=
matchCode
-
newMatchCode
;
assert
(
newMatchCode
<
matchCode
)
;
matchCode
=
newMatchCode
;
if
(
unlikely
(
ip
<
=
filledIp
)
)
{
const
BYTE
*
ptr
;
DEBUGLOG
(
5
"
Clearing
%
u
positions
"
(
U32
)
(
filledIp
-
ip
)
)
;
for
(
ptr
=
ip
;
ptr
<
=
filledIp
;
+
+
ptr
)
{
U32
const
h
=
LZ4_hashPosition
(
ptr
tableType
)
;
LZ4_clearHash
(
h
cctx
-
>
hashTable
tableType
)
;
}
}
}
else
{
assert
(
outputDirective
=
=
limitedOutput
)
;
return
0
;
}
}
if
(
matchCode
>
=
ML_MASK
)
{
*
token
+
=
ML_MASK
;
matchCode
-
=
ML_MASK
;
LZ4_write32
(
op
0xFFFFFFFF
)
;
while
(
matchCode
>
=
4
*
255
)
{
op
+
=
4
;
LZ4_write32
(
op
0xFFFFFFFF
)
;
matchCode
-
=
4
*
255
;
}
op
+
=
matchCode
/
255
;
*
op
+
+
=
(
BYTE
)
(
matchCode
%
255
)
;
}
else
*
token
+
=
(
BYTE
)
(
matchCode
)
;
}
assert
(
!
(
outputDirective
=
=
fillOutput
&
&
op
+
1
+
LASTLITERALS
>
olimit
)
)
;
anchor
=
ip
;
if
(
ip
>
=
mflimitPlusOne
)
break
;
{
U32
const
h
=
LZ4_hashPosition
(
ip
-
2
tableType
)
;
if
(
tableType
=
=
byPtr
)
{
LZ4_putPositionOnHash
(
ip
-
2
h
cctx
-
>
hashTable
byPtr
)
;
}
else
{
U32
const
idx
=
(
U32
)
(
(
ip
-
2
)
-
base
)
;
LZ4_putIndexOnHash
(
idx
h
cctx
-
>
hashTable
tableType
)
;
}
}
if
(
tableType
=
=
byPtr
)
{
match
=
LZ4_getPosition
(
ip
cctx
-
>
hashTable
tableType
)
;
LZ4_putPosition
(
ip
cctx
-
>
hashTable
tableType
)
;
if
(
(
match
+
LZ4_DISTANCE_MAX
>
=
ip
)
&
&
(
LZ4_read32
(
match
)
=
=
LZ4_read32
(
ip
)
)
)
{
token
=
op
+
+
;
*
token
=
0
;
goto
_next_match
;
}
}
else
{
U32
const
h
=
LZ4_hashPosition
(
ip
tableType
)
;
U32
const
current
=
(
U32
)
(
ip
-
base
)
;
U32
matchIndex
=
LZ4_getIndexOnHash
(
h
cctx
-
>
hashTable
tableType
)
;
assert
(
matchIndex
<
current
)
;
if
(
dictDirective
=
=
usingDictCtx
)
{
if
(
matchIndex
<
startIndex
)
{
assert
(
tableType
=
=
byU32
)
;
matchIndex
=
LZ4_getIndexOnHash
(
h
dictCtx
-
>
hashTable
byU32
)
;
match
=
dictBase
+
matchIndex
;
lowLimit
=
dictionary
;
matchIndex
+
=
dictDelta
;
}
else
{
match
=
base
+
matchIndex
;
lowLimit
=
(
const
BYTE
*
)
source
;
}
}
else
if
(
dictDirective
=
=
usingExtDict
)
{
if
(
matchIndex
<
startIndex
)
{
assert
(
dictBase
)
;
match
=
dictBase
+
matchIndex
;
lowLimit
=
dictionary
;
}
else
{
match
=
base
+
matchIndex
;
lowLimit
=
(
const
BYTE
*
)
source
;
}
}
else
{
match
=
base
+
matchIndex
;
}
LZ4_putIndexOnHash
(
current
h
cctx
-
>
hashTable
tableType
)
;
assert
(
matchIndex
<
current
)
;
if
(
(
(
dictIssue
=
=
dictSmall
)
?
(
matchIndex
>
=
prefixIdxLimit
)
:
1
)
&
&
(
(
(
tableType
=
=
byU16
)
&
&
(
LZ4_DISTANCE_MAX
=
=
LZ4_DISTANCE_ABSOLUTE_MAX
)
)
?
1
:
(
matchIndex
+
LZ4_DISTANCE_MAX
>
=
current
)
)
&
&
(
LZ4_read32
(
match
)
=
=
LZ4_read32
(
ip
)
)
)
{
token
=
op
+
+
;
*
token
=
0
;
if
(
maybe_extMem
)
offset
=
current
-
matchIndex
;
DEBUGLOG
(
6
"
seq
.
start
:
%
i
literals
=
%
u
match
.
start
:
%
i
"
(
int
)
(
anchor
-
(
const
BYTE
*
)
source
)
0
(
int
)
(
ip
-
(
const
BYTE
*
)
source
)
)
;
goto
_next_match
;
}
}
forwardH
=
LZ4_hashPosition
(
+
+
ip
tableType
)
;
}
_last_literals
:
{
size_t
lastRun
=
(
size_t
)
(
iend
-
anchor
)
;
if
(
(
outputDirective
)
&
&
(
op
+
lastRun
+
1
+
(
(
lastRun
+
255
-
RUN_MASK
)
/
255
)
>
olimit
)
)
{
if
(
outputDirective
=
=
fillOutput
)
{
assert
(
olimit
>
=
op
)
;
lastRun
=
(
size_t
)
(
olimit
-
op
)
-
1
;
lastRun
-
=
(
lastRun
+
256
-
RUN_MASK
)
/
256
;
}
else
{
assert
(
outputDirective
=
=
limitedOutput
)
;
return
0
;
}
}
DEBUGLOG
(
6
"
Final
literal
run
:
%
i
literals
"
(
int
)
lastRun
)
;
if
(
lastRun
>
=
RUN_MASK
)
{
size_t
accumulator
=
lastRun
-
RUN_MASK
;
*
op
+
+
=
RUN_MASK
<
<
ML_BITS
;
for
(
;
accumulator
>
=
255
;
accumulator
-
=
255
)
*
op
+
+
=
255
;
*
op
+
+
=
(
BYTE
)
accumulator
;
}
else
{
*
op
+
+
=
(
BYTE
)
(
lastRun
<
<
ML_BITS
)
;
}
LZ4_memcpy
(
op
anchor
lastRun
)
;
ip
=
anchor
+
lastRun
;
op
+
=
lastRun
;
}
if
(
outputDirective
=
=
fillOutput
)
{
*
inputConsumed
=
(
int
)
(
(
(
const
char
*
)
ip
)
-
source
)
;
}
result
=
(
int
)
(
(
(
char
*
)
op
)
-
dest
)
;
assert
(
result
>
0
)
;
DEBUGLOG
(
5
"
LZ4_compress_generic
:
compressed
%
i
bytes
into
%
i
bytes
"
inputSize
result
)
;
return
result
;
}
LZ4_FORCE_INLINE
int
LZ4_compress_generic
(
LZ4_stream_t_internal
*
const
cctx
const
char
*
const
src
char
*
const
dst
const
int
srcSize
int
*
inputConsumed
const
int
dstCapacity
const
limitedOutput_directive
outputDirective
const
tableType_t
tableType
const
dict_directive
dictDirective
const
dictIssue_directive
dictIssue
const
int
acceleration
)
{
DEBUGLOG
(
5
"
LZ4_compress_generic
:
srcSize
=
%
i
dstCapacity
=
%
i
"
srcSize
dstCapacity
)
;
if
(
(
U32
)
srcSize
>
(
U32
)
LZ4_MAX_INPUT_SIZE
)
{
return
0
;
}
if
(
srcSize
=
=
0
)
{
if
(
outputDirective
!
=
notLimited
&
&
dstCapacity
<
=
0
)
return
0
;
DEBUGLOG
(
5
"
Generating
an
empty
block
"
)
;
assert
(
outputDirective
=
=
notLimited
|
|
dstCapacity
>
=
1
)
;
assert
(
dst
!
=
NULL
)
;
dst
[
0
]
=
0
;
if
(
outputDirective
=
=
fillOutput
)
{
assert
(
inputConsumed
!
=
NULL
)
;
*
inputConsumed
=
0
;
}
return
1
;
}
assert
(
src
!
=
NULL
)
;
return
LZ4_compress_generic_validated
(
cctx
src
dst
srcSize
inputConsumed
dstCapacity
outputDirective
tableType
dictDirective
dictIssue
acceleration
)
;
}
int
LZ4_compress_fast_extState
(
void
*
state
const
char
*
source
char
*
dest
int
inputSize
int
maxOutputSize
int
acceleration
)
{
LZ4_stream_t_internal
*
const
ctx
=
&
LZ4_initStream
(
state
sizeof
(
LZ4_stream_t
)
)
-
>
internal_donotuse
;
assert
(
ctx
!
=
NULL
)
;
if
(
acceleration
<
1
)
acceleration
=
LZ4_ACCELERATION_DEFAULT
;
if
(
acceleration
>
LZ4_ACCELERATION_MAX
)
acceleration
=
LZ4_ACCELERATION_MAX
;
if
(
maxOutputSize
>
=
LZ4_compressBound
(
inputSize
)
)
{
if
(
inputSize
<
LZ4_64Klimit
)
{
return
LZ4_compress_generic
(
ctx
source
dest
inputSize
NULL
0
notLimited
byU16
noDict
noDictIssue
acceleration
)
;
}
else
{
const
tableType_t
tableType
=
(
(
sizeof
(
void
*
)
=
=
4
)
&
&
(
(
uptrval
)
source
>
LZ4_DISTANCE_MAX
)
)
?
byPtr
:
byU32
;
return
LZ4_compress_generic
(
ctx
source
dest
inputSize
NULL
0
notLimited
tableType
noDict
noDictIssue
acceleration
)
;
}
}
else
{
if
(
inputSize
<
LZ4_64Klimit
)
{
return
LZ4_compress_generic
(
ctx
source
dest
inputSize
NULL
maxOutputSize
limitedOutput
byU16
noDict
noDictIssue
acceleration
)
;
}
else
{
const
tableType_t
tableType
=
(
(
sizeof
(
void
*
)
=
=
4
)
&
&
(
(
uptrval
)
source
>
LZ4_DISTANCE_MAX
)
)
?
byPtr
:
byU32
;
return
LZ4_compress_generic
(
ctx
source
dest
inputSize
NULL
maxOutputSize
limitedOutput
tableType
noDict
noDictIssue
acceleration
)
;
}
}
}
int
LZ4_compress_fast_extState_fastReset
(
void
*
state
const
char
*
src
char
*
dst
int
srcSize
int
dstCapacity
int
acceleration
)
{
LZ4_stream_t_internal
*
const
ctx
=
&
(
(
LZ4_stream_t
*
)
state
)
-
>
internal_donotuse
;
if
(
acceleration
<
1
)
acceleration
=
LZ4_ACCELERATION_DEFAULT
;
if
(
acceleration
>
LZ4_ACCELERATION_MAX
)
acceleration
=
LZ4_ACCELERATION_MAX
;
assert
(
ctx
!
=
NULL
)
;
if
(
dstCapacity
>
=
LZ4_compressBound
(
srcSize
)
)
{
if
(
srcSize
<
LZ4_64Klimit
)
{
const
tableType_t
tableType
=
byU16
;
LZ4_prepareTable
(
ctx
srcSize
tableType
)
;
if
(
ctx
-
>
currentOffset
)
{
return
LZ4_compress_generic
(
ctx
src
dst
srcSize
NULL
0
notLimited
tableType
noDict
dictSmall
acceleration
)
;
}
else
{
return
LZ4_compress_generic
(
ctx
src
dst
srcSize
NULL
0
notLimited
tableType
noDict
noDictIssue
acceleration
)
;
}
}
else
{
const
tableType_t
tableType
=
(
(
sizeof
(
void
*
)
=
=
4
)
&
&
(
(
uptrval
)
src
>
LZ4_DISTANCE_MAX
)
)
?
byPtr
:
byU32
;
LZ4_prepareTable
(
ctx
srcSize
tableType
)
;
return
LZ4_compress_generic
(
ctx
src
dst
srcSize
NULL
0
notLimited
tableType
noDict
noDictIssue
acceleration
)
;
}
}
else
{
if
(
srcSize
<
LZ4_64Klimit
)
{
const
tableType_t
tableType
=
byU16
;
LZ4_prepareTable
(
ctx
srcSize
tableType
)
;
if
(
ctx
-
>
currentOffset
)
{
return
LZ4_compress_generic
(
ctx
src
dst
srcSize
NULL
dstCapacity
limitedOutput
tableType
noDict
dictSmall
acceleration
)
;
}
else
{
return
LZ4_compress_generic
(
ctx
src
dst
srcSize
NULL
dstCapacity
limitedOutput
tableType
noDict
noDictIssue
acceleration
)
;
}
}
else
{
const
tableType_t
tableType
=
(
(
sizeof
(
void
*
)
=
=
4
)
&
&
(
(
uptrval
)
src
>
LZ4_DISTANCE_MAX
)
)
?
byPtr
:
byU32
;
LZ4_prepareTable
(
ctx
srcSize
tableType
)
;
return
LZ4_compress_generic
(
ctx
src
dst
srcSize
NULL
dstCapacity
limitedOutput
tableType
noDict
noDictIssue
acceleration
)
;
}
}
}
int
LZ4_compress_fast
(
const
char
*
src
char
*
dest
int
srcSize
int
dstCapacity
int
acceleration
)
{
int
result
;
#
if
(
LZ4_HEAPMODE
)
LZ4_stream_t
*
const
ctxPtr
=
(
LZ4_stream_t
*
)
ALLOC
(
sizeof
(
LZ4_stream_t
)
)
;
if
(
ctxPtr
=
=
NULL
)
return
0
;
#
else
LZ4_stream_t
ctx
;
LZ4_stream_t
*
const
ctxPtr
=
&
ctx
;
#
endif
result
=
LZ4_compress_fast_extState
(
ctxPtr
src
dest
srcSize
dstCapacity
acceleration
)
;
#
if
(
LZ4_HEAPMODE
)
FREEMEM
(
ctxPtr
)
;
#
endif
return
result
;
}
int
LZ4_compress_default
(
const
char
*
src
char
*
dst
int
srcSize
int
dstCapacity
)
{
return
LZ4_compress_fast
(
src
dst
srcSize
dstCapacity
1
)
;
}
static
int
LZ4_compress_destSize_extState_internal
(
LZ4_stream_t
*
state
const
char
*
src
char
*
dst
int
*
srcSizePtr
int
targetDstSize
int
acceleration
)
{
void
*
const
s
=
LZ4_initStream
(
state
sizeof
(
*
state
)
)
;
assert
(
s
!
=
NULL
)
;
(
void
)
s
;
if
(
targetDstSize
>
=
LZ4_compressBound
(
*
srcSizePtr
)
)
{
return
LZ4_compress_fast_extState
(
state
src
dst
*
srcSizePtr
targetDstSize
acceleration
)
;
}
else
{
if
(
*
srcSizePtr
<
LZ4_64Klimit
)
{
return
LZ4_compress_generic
(
&
state
-
>
internal_donotuse
src
dst
*
srcSizePtr
srcSizePtr
targetDstSize
fillOutput
byU16
noDict
noDictIssue
acceleration
)
;
}
else
{
tableType_t
const
addrMode
=
(
(
sizeof
(
void
*
)
=
=
4
)
&
&
(
(
uptrval
)
src
>
LZ4_DISTANCE_MAX
)
)
?
byPtr
:
byU32
;
return
LZ4_compress_generic
(
&
state
-
>
internal_donotuse
src
dst
*
srcSizePtr
srcSizePtr
targetDstSize
fillOutput
addrMode
noDict
noDictIssue
acceleration
)
;
}
}
}
int
LZ4_compress_destSize_extState
(
void
*
state
const
char
*
src
char
*
dst
int
*
srcSizePtr
int
targetDstSize
int
acceleration
)
{
int
const
r
=
LZ4_compress_destSize_extState_internal
(
(
LZ4_stream_t
*
)
state
src
dst
srcSizePtr
targetDstSize
acceleration
)
;
LZ4_initStream
(
state
sizeof
(
LZ4_stream_t
)
)
;
return
r
;
}
int
LZ4_compress_destSize
(
const
char
*
src
char
*
dst
int
*
srcSizePtr
int
targetDstSize
)
{
#
if
(
LZ4_HEAPMODE
)
LZ4_stream_t
*
const
ctx
=
(
LZ4_stream_t
*
)
ALLOC
(
sizeof
(
LZ4_stream_t
)
)
;
if
(
ctx
=
=
NULL
)
return
0
;
#
else
LZ4_stream_t
ctxBody
;
LZ4_stream_t
*
const
ctx
=
&
ctxBody
;
#
endif
int
result
=
LZ4_compress_destSize_extState_internal
(
ctx
src
dst
srcSizePtr
targetDstSize
1
)
;
#
if
(
LZ4_HEAPMODE
)
FREEMEM
(
ctx
)
;
#
endif
return
result
;
}
#
if
!
defined
(
LZ4_STATIC_LINKING_ONLY_DISABLE_MEMORY_ALLOCATION
)
LZ4_stream_t
*
LZ4_createStream
(
void
)
{
LZ4_stream_t
*
const
lz4s
=
(
LZ4_stream_t
*
)
ALLOC
(
sizeof
(
LZ4_stream_t
)
)
;
LZ4_STATIC_ASSERT
(
sizeof
(
LZ4_stream_t
)
>
=
sizeof
(
LZ4_stream_t_internal
)
)
;
DEBUGLOG
(
4
"
LZ4_createStream
%
p
"
lz4s
)
;
if
(
lz4s
=
=
NULL
)
return
NULL
;
LZ4_initStream
(
lz4s
sizeof
(
*
lz4s
)
)
;
return
lz4s
;
}
#
endif
static
size_t
LZ4_stream_t_alignment
(
void
)
{
#
if
LZ4_ALIGN_TEST
typedef
struct
{
char
c
;
LZ4_stream_t
t
;
}
t_a
;
return
sizeof
(
t_a
)
-
sizeof
(
LZ4_stream_t
)
;
#
else
return
1
;
#
endif
}
LZ4_stream_t
*
LZ4_initStream
(
void
*
buffer
size_t
size
)
{
DEBUGLOG
(
5
"
LZ4_initStream
"
)
;
if
(
buffer
=
=
NULL
)
{
return
NULL
;
}
if
(
size
<
sizeof
(
LZ4_stream_t
)
)
{
return
NULL
;
}
if
(
!
LZ4_isAligned
(
buffer
LZ4_stream_t_alignment
(
)
)
)
return
NULL
;
MEM_INIT
(
buffer
0
sizeof
(
LZ4_stream_t_internal
)
)
;
return
(
LZ4_stream_t
*
)
buffer
;
}
void
LZ4_resetStream
(
LZ4_stream_t
*
LZ4_stream
)
{
DEBUGLOG
(
5
"
LZ4_resetStream
(
ctx
:
%
p
)
"
LZ4_stream
)
;
MEM_INIT
(
LZ4_stream
0
sizeof
(
LZ4_stream_t_internal
)
)
;
}
void
LZ4_resetStream_fast
(
LZ4_stream_t
*
ctx
)
{
LZ4_prepareTable
(
&
(
ctx
-
>
internal_donotuse
)
0
byU32
)
;
}
#
if
!
defined
(
LZ4_STATIC_LINKING_ONLY_DISABLE_MEMORY_ALLOCATION
)
int
LZ4_freeStream
(
LZ4_stream_t
*
LZ4_stream
)
{
if
(
!
LZ4_stream
)
return
0
;
DEBUGLOG
(
5
"
LZ4_freeStream
%
p
"
LZ4_stream
)
;
FREEMEM
(
LZ4_stream
)
;
return
(
0
)
;
}
#
endif
typedef
enum
{
_ld_fast
_ld_slow
}
LoadDict_mode_e
;
#
define
HASH_UNIT
sizeof
(
reg_t
)
int
LZ4_loadDict_internal
(
LZ4_stream_t
*
LZ4_dict
const
char
*
dictionary
int
dictSize
LoadDict_mode_e
_ld
)
{
LZ4_stream_t_internal
*
const
dict
=
&
LZ4_dict
-
>
internal_donotuse
;
const
tableType_t
tableType
=
byU32
;
const
BYTE
*
p
=
(
const
BYTE
*
)
dictionary
;
const
BYTE
*
const
dictEnd
=
p
+
dictSize
;
U32
idx32
;
DEBUGLOG
(
4
"
LZ4_loadDict
(
%
i
bytes
from
%
p
into
%
p
)
"
dictSize
dictionary
LZ4_dict
)
;
LZ4_resetStream
(
LZ4_dict
)
;
dict
-
>
currentOffset
+
=
64
KB
;
if
(
dictSize
<
(
int
)
HASH_UNIT
)
{
return
0
;
}
if
(
(
dictEnd
-
p
)
>
64
KB
)
p
=
dictEnd
-
64
KB
;
dict
-
>
dictionary
=
p
;
dict
-
>
dictSize
=
(
U32
)
(
dictEnd
-
p
)
;
dict
-
>
tableType
=
(
U32
)
tableType
;
idx32
=
dict
-
>
currentOffset
-
dict
-
>
dictSize
;
while
(
p
<
=
dictEnd
-
HASH_UNIT
)
{
U32
const
h
=
LZ4_hashPosition
(
p
tableType
)
;
LZ4_putIndexOnHash
(
idx32
h
dict
-
>
hashTable
tableType
)
;
p
+
=
3
;
idx32
+
=
3
;
}
if
(
_ld
=
=
_ld_slow
)
{
p
=
dict
-
>
dictionary
;
idx32
=
dict
-
>
currentOffset
-
dict
-
>
dictSize
;
while
(
p
<
=
dictEnd
-
HASH_UNIT
)
{
U32
const
h
=
LZ4_hashPosition
(
p
tableType
)
;
U32
const
limit
=
dict
-
>
currentOffset
-
64
KB
;
if
(
LZ4_getIndexOnHash
(
h
dict
-
>
hashTable
tableType
)
<
=
limit
)
{
LZ4_putIndexOnHash
(
idx32
h
dict
-
>
hashTable
tableType
)
;
}
p
+
+
;
idx32
+
+
;
}
}
return
(
int
)
dict
-
>
dictSize
;
}
int
LZ4_loadDict
(
LZ4_stream_t
*
LZ4_dict
const
char
*
dictionary
int
dictSize
)
{
return
LZ4_loadDict_internal
(
LZ4_dict
dictionary
dictSize
_ld_fast
)
;
}
int
LZ4_loadDictSlow
(
LZ4_stream_t
*
LZ4_dict
const
char
*
dictionary
int
dictSize
)
{
return
LZ4_loadDict_internal
(
LZ4_dict
dictionary
dictSize
_ld_slow
)
;
}
void
LZ4_attach_dictionary
(
LZ4_stream_t
*
workingStream
const
LZ4_stream_t
*
dictionaryStream
)
{
const
LZ4_stream_t_internal
*
dictCtx
=
(
dictionaryStream
=
=
NULL
)
?
NULL
:
&
(
dictionaryStream
-
>
internal_donotuse
)
;
DEBUGLOG
(
4
"
LZ4_attach_dictionary
(
%
p
%
p
size
%
u
)
"
workingStream
dictionaryStream
dictCtx
!
=
NULL
?
dictCtx
-
>
dictSize
:
0
)
;
if
(
dictCtx
!
=
NULL
)
{
if
(
workingStream
-
>
internal_donotuse
.
currentOffset
=
=
0
)
{
workingStream
-
>
internal_donotuse
.
currentOffset
=
64
KB
;
}
if
(
dictCtx
-
>
dictSize
=
=
0
)
{
dictCtx
=
NULL
;
}
}
workingStream
-
>
internal_donotuse
.
dictCtx
=
dictCtx
;
}
static
void
LZ4_renormDictT
(
LZ4_stream_t_internal
*
LZ4_dict
int
nextSize
)
{
assert
(
nextSize
>
=
0
)
;
if
(
LZ4_dict
-
>
currentOffset
+
(
unsigned
)
nextSize
>
0x80000000
)
{
U32
const
delta
=
LZ4_dict
-
>
currentOffset
-
64
KB
;
const
BYTE
*
dictEnd
=
LZ4_dict
-
>
dictionary
+
LZ4_dict
-
>
dictSize
;
int
i
;
DEBUGLOG
(
4
"
LZ4_renormDictT
"
)
;
for
(
i
=
0
;
i
<
LZ4_HASH_SIZE_U32
;
i
+
+
)
{
if
(
LZ4_dict
-
>
hashTable
[
i
]
<
delta
)
LZ4_dict
-
>
hashTable
[
i
]
=
0
;
else
LZ4_dict
-
>
hashTable
[
i
]
-
=
delta
;
}
LZ4_dict
-
>
currentOffset
=
64
KB
;
if
(
LZ4_dict
-
>
dictSize
>
64
KB
)
LZ4_dict
-
>
dictSize
=
64
KB
;
LZ4_dict
-
>
dictionary
=
dictEnd
-
LZ4_dict
-
>
dictSize
;
}
}
int
LZ4_compress_fast_continue
(
LZ4_stream_t
*
LZ4_stream
const
char
*
source
char
*
dest
int
inputSize
int
maxOutputSize
int
acceleration
)
{
const
tableType_t
tableType
=
byU32
;
LZ4_stream_t_internal
*
const
streamPtr
=
&
LZ4_stream
-
>
internal_donotuse
;
const
char
*
dictEnd
=
streamPtr
-
>
dictSize
?
(
const
char
*
)
streamPtr
-
>
dictionary
+
streamPtr
-
>
dictSize
:
NULL
;
DEBUGLOG
(
5
"
LZ4_compress_fast_continue
(
inputSize
=
%
i
dictSize
=
%
u
)
"
inputSize
streamPtr
-
>
dictSize
)
;
LZ4_renormDictT
(
streamPtr
inputSize
)
;
if
(
acceleration
<
1
)
acceleration
=
LZ4_ACCELERATION_DEFAULT
;
if
(
acceleration
>
LZ4_ACCELERATION_MAX
)
acceleration
=
LZ4_ACCELERATION_MAX
;
if
(
(
streamPtr
-
>
dictSize
<
4
)
&
&
(
dictEnd
!
=
source
)
&
&
(
inputSize
>
0
)
&
&
(
streamPtr
-
>
dictCtx
=
=
NULL
)
)
{
DEBUGLOG
(
5
"
LZ4_compress_fast_continue
:
dictSize
(
%
u
)
at
addr
:
%
p
is
too
small
"
streamPtr
-
>
dictSize
streamPtr
-
>
dictionary
)
;
streamPtr
-
>
dictSize
=
0
;
streamPtr
-
>
dictionary
=
(
const
BYTE
*
)
source
;
dictEnd
=
source
;
}
{
const
char
*
const
sourceEnd
=
source
+
inputSize
;
if
(
(
sourceEnd
>
(
const
char
*
)
streamPtr
-
>
dictionary
)
&
&
(
sourceEnd
<
dictEnd
)
)
{
streamPtr
-
>
dictSize
=
(
U32
)
(
dictEnd
-
sourceEnd
)
;
if
(
streamPtr
-
>
dictSize
>
64
KB
)
streamPtr
-
>
dictSize
=
64
KB
;
if
(
streamPtr
-
>
dictSize
<
4
)
streamPtr
-
>
dictSize
=
0
;
streamPtr
-
>
dictionary
=
(
const
BYTE
*
)
dictEnd
-
streamPtr
-
>
dictSize
;
}
}
if
(
dictEnd
=
=
source
)
{
if
(
(
streamPtr
-
>
dictSize
<
64
KB
)
&
&
(
streamPtr
-
>
dictSize
<
streamPtr
-
>
currentOffset
)
)
return
LZ4_compress_generic
(
streamPtr
source
dest
inputSize
NULL
maxOutputSize
limitedOutput
tableType
withPrefix64k
dictSmall
acceleration
)
;
else
return
LZ4_compress_generic
(
streamPtr
source
dest
inputSize
NULL
maxOutputSize
limitedOutput
tableType
withPrefix64k
noDictIssue
acceleration
)
;
}
{
int
result
;
if
(
streamPtr
-
>
dictCtx
)
{
if
(
inputSize
>
4
KB
)
{
LZ4_memcpy
(
streamPtr
streamPtr
-
>
dictCtx
sizeof
(
*
streamPtr
)
)
;
result
=
LZ4_compress_generic
(
streamPtr
source
dest
inputSize
NULL
maxOutputSize
limitedOutput
tableType
usingExtDict
noDictIssue
acceleration
)
;
}
else
{
result
=
LZ4_compress_generic
(
streamPtr
source
dest
inputSize
NULL
maxOutputSize
limitedOutput
tableType
usingDictCtx
noDictIssue
acceleration
)
;
}
}
else
{
if
(
(
streamPtr
-
>
dictSize
<
64
KB
)
&
&
(
streamPtr
-
>
dictSize
<
streamPtr
-
>
currentOffset
)
)
{
result
=
LZ4_compress_generic
(
streamPtr
source
dest
inputSize
NULL
maxOutputSize
limitedOutput
tableType
usingExtDict
dictSmall
acceleration
)
;
}
else
{
result
=
LZ4_compress_generic
(
streamPtr
source
dest
inputSize
NULL
maxOutputSize
limitedOutput
tableType
usingExtDict
noDictIssue
acceleration
)
;
}
}
streamPtr
-
>
dictionary
=
(
const
BYTE
*
)
source
;
streamPtr
-
>
dictSize
=
(
U32
)
inputSize
;
return
result
;
}
}
int
LZ4_compress_forceExtDict
(
LZ4_stream_t
*
LZ4_dict
const
char
*
source
char
*
dest
int
srcSize
)
{
LZ4_stream_t_internal
*
const
streamPtr
=
&
LZ4_dict
-
>
internal_donotuse
;
int
result
;
LZ4_renormDictT
(
streamPtr
srcSize
)
;
if
(
(
streamPtr
-
>
dictSize
<
64
KB
)
&
&
(
streamPtr
-
>
dictSize
<
streamPtr
-
>
currentOffset
)
)
{
result
=
LZ4_compress_generic
(
streamPtr
source
dest
srcSize
NULL
0
notLimited
byU32
usingExtDict
dictSmall
1
)
;
}
else
{
result
=
LZ4_compress_generic
(
streamPtr
source
dest
srcSize
NULL
0
notLimited
byU32
usingExtDict
noDictIssue
1
)
;
}
streamPtr
-
>
dictionary
=
(
const
BYTE
*
)
source
;
streamPtr
-
>
dictSize
=
(
U32
)
srcSize
;
return
result
;
}
int
LZ4_saveDict
(
LZ4_stream_t
*
LZ4_dict
char
*
safeBuffer
int
dictSize
)
{
LZ4_stream_t_internal
*
const
dict
=
&
LZ4_dict
-
>
internal_donotuse
;
DEBUGLOG
(
5
"
LZ4_saveDict
:
dictSize
=
%
i
safeBuffer
=
%
p
"
dictSize
safeBuffer
)
;
if
(
(
U32
)
dictSize
>
64
KB
)
{
dictSize
=
64
KB
;
}
if
(
(
U32
)
dictSize
>
dict
-
>
dictSize
)
{
dictSize
=
(
int
)
dict
-
>
dictSize
;
}
if
(
safeBuffer
=
=
NULL
)
assert
(
dictSize
=
=
0
)
;
if
(
dictSize
>
0
)
{
const
BYTE
*
const
previousDictEnd
=
dict
-
>
dictionary
+
dict
-
>
dictSize
;
assert
(
dict
-
>
dictionary
)
;
LZ4_memmove
(
safeBuffer
previousDictEnd
-
dictSize
(
size_t
)
dictSize
)
;
}
dict
-
>
dictionary
=
(
const
BYTE
*
)
safeBuffer
;
dict
-
>
dictSize
=
(
U32
)
dictSize
;
return
dictSize
;
}
typedef
enum
{
decode_full_block
=
0
partial_decode
=
1
}
earlyEnd_directive
;
#
undef
MIN
#
define
MIN
(
a
b
)
(
(
a
)
<
(
b
)
?
(
a
)
:
(
b
)
)
static
size_t
read_long_length_no_check
(
const
BYTE
*
*
pp
)
{
size_t
b
l
=
0
;
do
{
b
=
*
*
pp
;
(
*
pp
)
+
+
;
l
+
=
b
;
}
while
(
b
=
=
255
)
;
DEBUGLOG
(
6
"
read_long_length_no_check
:
+
length
=
%
zu
using
%
zu
input
bytes
"
l
l
/
255
+
1
)
return
l
;
}
LZ4_FORCE_INLINE
int
LZ4_decompress_unsafe_generic
(
const
BYTE
*
const
istart
BYTE
*
const
ostart
int
decompressedSize
size_t
prefixSize
const
BYTE
*
const
dictStart
const
size_t
dictSize
)
{
const
BYTE
*
ip
=
istart
;
BYTE
*
op
=
(
BYTE
*
)
ostart
;
BYTE
*
const
oend
=
ostart
+
decompressedSize
;
const
BYTE
*
const
prefixStart
=
ostart
-
prefixSize
;
DEBUGLOG
(
5
"
LZ4_decompress_unsafe_generic
"
)
;
if
(
dictStart
=
=
NULL
)
assert
(
dictSize
=
=
0
)
;
while
(
1
)
{
unsigned
token
=
*
ip
+
+
;
{
size_t
ll
=
token
>
>
ML_BITS
;
if
(
ll
=
=
15
)
{
ll
+
=
read_long_length_no_check
(
&
ip
)
;
}
if
(
(
size_t
)
(
oend
-
op
)
<
ll
)
return
-
1
;
LZ4_memmove
(
op
ip
ll
)
;
op
+
=
ll
;
ip
+
=
ll
;
if
(
(
size_t
)
(
oend
-
op
)
<
MFLIMIT
)
{
if
(
op
=
=
oend
)
break
;
DEBUGLOG
(
5
"
invalid
:
literals
end
at
distance
%
zi
from
end
of
block
"
oend
-
op
)
;
return
-
1
;
}
}
{
size_t
ml
=
token
&
15
;
size_t
const
offset
=
LZ4_readLE16
(
ip
)
;
ip
+
=
2
;
if
(
ml
=
=
15
)
{
ml
+
=
read_long_length_no_check
(
&
ip
)
;
}
ml
+
=
MINMATCH
;
if
(
(
size_t
)
(
oend
-
op
)
<
ml
)
return
-
1
;
{
const
BYTE
*
match
=
op
-
offset
;
if
(
offset
>
(
size_t
)
(
op
-
prefixStart
)
+
dictSize
)
{
DEBUGLOG
(
6
"
offset
out
of
range
"
)
;
return
-
1
;
}
if
(
offset
>
(
size_t
)
(
op
-
prefixStart
)
)
{
const
BYTE
*
const
dictEnd
=
dictStart
+
dictSize
;
const
BYTE
*
extMatch
=
dictEnd
-
(
offset
-
(
size_t
)
(
op
-
prefixStart
)
)
;
size_t
const
extml
=
(
size_t
)
(
dictEnd
-
extMatch
)
;
if
(
extml
>
ml
)
{
LZ4_memmove
(
op
extMatch
ml
)
;
op
+
=
ml
;
ml
=
0
;
}
else
{
LZ4_memmove
(
op
extMatch
extml
)
;
op
+
=
extml
;
ml
-
=
extml
;
}
match
=
prefixStart
;
}
{
size_t
u
;
for
(
u
=
0
;
u
<
ml
;
u
+
+
)
{
op
[
u
]
=
match
[
u
]
;
}
}
}
op
+
=
ml
;
if
(
(
size_t
)
(
oend
-
op
)
<
LASTLITERALS
)
{
DEBUGLOG
(
5
"
invalid
:
match
ends
at
distance
%
zi
from
end
of
block
"
oend
-
op
)
;
return
-
1
;
}
}
}
return
(
int
)
(
ip
-
istart
)
;
}
typedef
size_t
Rvl_t
;
static
const
Rvl_t
rvl_error
=
(
Rvl_t
)
(
-
1
)
;
LZ4_FORCE_INLINE
Rvl_t
read_variable_length
(
const
BYTE
*
*
ip
const
BYTE
*
ilimit
int
initial_check
)
{
Rvl_t
s
length
=
0
;
assert
(
ip
!
=
NULL
)
;
assert
(
*
ip
!
=
NULL
)
;
assert
(
ilimit
!
=
NULL
)
;
if
(
initial_check
&
&
unlikely
(
(
*
ip
)
>
=
ilimit
)
)
{
return
rvl_error
;
}
s
=
*
*
ip
;
(
*
ip
)
+
+
;
length
+
=
s
;
if
(
unlikely
(
(
*
ip
)
>
ilimit
)
)
{
return
rvl_error
;
}
if
(
(
sizeof
(
length
)
<
8
)
&
&
unlikely
(
length
>
(
(
Rvl_t
)
(
-
1
)
/
2
)
)
)
{
return
rvl_error
;
}
if
(
likely
(
s
!
=
255
)
)
return
length
;
do
{
s
=
*
*
ip
;
(
*
ip
)
+
+
;
length
+
=
s
;
if
(
unlikely
(
(
*
ip
)
>
ilimit
)
)
{
return
rvl_error
;
}
if
(
(
sizeof
(
length
)
<
8
)
&
&
unlikely
(
length
>
(
(
Rvl_t
)
(
-
1
)
/
2
)
)
)
{
return
rvl_error
;
}
}
while
(
s
=
=
255
)
;
return
length
;
}
LZ4_FORCE_INLINE
int
LZ4_decompress_generic
(
const
char
*
const
src
char
*
const
dst
int
srcSize
int
outputSize
earlyEnd_directive
partialDecoding
dict_directive
dict
const
BYTE
*
const
lowPrefix
const
BYTE
*
const
dictStart
const
size_t
dictSize
)
{
if
(
(
src
=
=
NULL
)
|
|
(
outputSize
<
0
)
)
{
return
-
1
;
}
{
const
BYTE
*
ip
=
(
const
BYTE
*
)
src
;
const
BYTE
*
const
iend
=
ip
+
srcSize
;
BYTE
*
op
=
(
BYTE
*
)
dst
;
BYTE
*
const
oend
=
op
+
outputSize
;
BYTE
*
cpy
;
const
BYTE
*
const
dictEnd
=
(
dictStart
=
=
NULL
)
?
NULL
:
dictStart
+
dictSize
;
const
int
checkOffset
=
(
dictSize
<
(
int
)
(
64
KB
)
)
;
const
BYTE
*
const
shortiend
=
iend
-
14
-
2
;
const
BYTE
*
const
shortoend
=
oend
-
14
-
18
;
const
BYTE
*
match
;
size_t
offset
;
unsigned
token
;
size_t
length
;
DEBUGLOG
(
5
"
LZ4_decompress_generic
(
srcSize
:
%
i
dstSize
:
%
i
)
"
srcSize
outputSize
)
;
assert
(
lowPrefix
<
=
op
)
;
if
(
unlikely
(
outputSize
=
=
0
)
)
{
if
(
partialDecoding
)
return
0
;
return
(
(
srcSize
=
=
1
)
&
&
(
*
ip
=
=
0
)
)
?
0
:
-
1
;
}
if
(
unlikely
(
srcSize
=
=
0
)
)
{
return
-
1
;
}
#
if
LZ4_FAST_DEC_LOOP
if
(
(
oend
-
op
)
<
FASTLOOP_SAFE_DISTANCE
)
{
DEBUGLOG
(
6
"
move
to
safe
decode
loop
"
)
;
goto
safe_decode
;
}
DEBUGLOG
(
6
"
using
fast
decode
loop
"
)
;
while
(
1
)
{
assert
(
oend
-
op
>
=
FASTLOOP_SAFE_DISTANCE
)
;
assert
(
ip
<
iend
)
;
token
=
*
ip
+
+
;
length
=
token
>
>
ML_BITS
;
DEBUGLOG
(
7
"
blockPos
%
6u
:
litLength
token
=
%
u
"
(
unsigned
)
(
op
-
(
BYTE
*
)
dst
)
(
unsigned
)
length
)
;
if
(
length
=
=
RUN_MASK
)
{
size_t
const
addl
=
read_variable_length
(
&
ip
iend
-
RUN_MASK
1
)
;
if
(
addl
=
=
rvl_error
)
{
DEBUGLOG
(
6
"
error
reading
long
literal
length
"
)
;
goto
_output_error
;
}
length
+
=
addl
;
if
(
unlikely
(
(
uptrval
)
(
op
)
+
length
<
(
uptrval
)
(
op
)
)
)
{
goto
_output_error
;
}
if
(
unlikely
(
(
uptrval
)
(
ip
)
+
length
<
(
uptrval
)
(
ip
)
)
)
{
goto
_output_error
;
}
LZ4_STATIC_ASSERT
(
MFLIMIT
>
=
WILDCOPYLENGTH
)
;
if
(
(
op
+
length
>
oend
-
32
)
|
|
(
ip
+
length
>
iend
-
32
)
)
{
goto
safe_literal_copy
;
}
LZ4_wildCopy32
(
op
ip
op
+
length
)
;
ip
+
=
length
;
op
+
=
length
;
}
else
if
(
ip
<
=
iend
-
(
16
+
1
)
)
{
DEBUGLOG
(
7
"
copy
%
u
bytes
in
a
16
-
bytes
stripe
"
(
unsigned
)
length
)
;
LZ4_memcpy
(
op
ip
16
)
;
ip
+
=
length
;
op
+
=
length
;
}
else
{
goto
safe_literal_copy
;
}
offset
=
LZ4_readLE16
(
ip
)
;
ip
+
=
2
;
DEBUGLOG
(
6
"
blockPos
%
6u
:
offset
=
%
u
"
(
unsigned
)
(
op
-
(
BYTE
*
)
dst
)
(
unsigned
)
offset
)
;
match
=
op
-
offset
;
assert
(
match
<
=
op
)
;
length
=
token
&
ML_MASK
;
DEBUGLOG
(
7
"
match
length
token
=
%
u
(
len
=
=
%
u
)
"
(
unsigned
)
length
(
unsigned
)
length
+
MINMATCH
)
;
if
(
length
=
=
ML_MASK
)
{
size_t
const
addl
=
read_variable_length
(
&
ip
iend
-
LASTLITERALS
+
1
0
)
;
if
(
addl
=
=
rvl_error
)
{
DEBUGLOG
(
5
"
error
reading
long
match
length
"
)
;
goto
_output_error
;
}
length
+
=
addl
;
length
+
=
MINMATCH
;
DEBUGLOG
(
7
"
long
match
length
=
=
%
u
"
(
unsigned
)
length
)
;
if
(
unlikely
(
(
uptrval
)
(
op
)
+
length
<
(
uptrval
)
op
)
)
{
goto
_output_error
;
}
if
(
op
+
length
>
=
oend
-
FASTLOOP_SAFE_DISTANCE
)
{
goto
safe_match_copy
;
}
}
else
{
length
+
=
MINMATCH
;
if
(
op
+
length
>
=
oend
-
FASTLOOP_SAFE_DISTANCE
)
{
DEBUGLOG
(
7
"
moving
to
safe_match_copy
(
ml
=
=
%
u
)
"
(
unsigned
)
length
)
;
goto
safe_match_copy
;
}
if
(
(
dict
=
=
withPrefix64k
)
|
|
(
match
>
=
lowPrefix
)
)
{
if
(
offset
>
=
8
)
{
assert
(
match
>
=
lowPrefix
)
;
assert
(
match
<
=
op
)
;
assert
(
op
+
18
<
=
oend
)
;
LZ4_memcpy
(
op
match
8
)
;
LZ4_memcpy
(
op
+
8
match
+
8
8
)
;
LZ4_memcpy
(
op
+
16
match
+
16
2
)
;
op
+
=
length
;
continue
;
}
}
}
if
(
checkOffset
&
&
(
unlikely
(
match
+
dictSize
<
lowPrefix
)
)
)
{
DEBUGLOG
(
5
"
Error
:
pos
=
%
zi
offset
=
%
zi
=
>
outside
buffers
"
op
-
lowPrefix
op
-
match
)
;
goto
_output_error
;
}
if
(
(
dict
=
=
usingExtDict
)
&
&
(
match
<
lowPrefix
)
)
{
assert
(
dictEnd
!
=
NULL
)
;
if
(
unlikely
(
op
+
length
>
oend
-
LASTLITERALS
)
)
{
if
(
partialDecoding
)
{
DEBUGLOG
(
7
"
partialDecoding
:
dictionary
match
close
to
dstEnd
"
)
;
length
=
MIN
(
length
(
size_t
)
(
oend
-
op
)
)
;
}
else
{
DEBUGLOG
(
6
"
end
-
of
-
block
condition
violated
"
)
goto
_output_error
;
}
}
if
(
length
<
=
(
size_t
)
(
lowPrefix
-
match
)
)
{
LZ4_memmove
(
op
dictEnd
-
(
lowPrefix
-
match
)
length
)
;
op
+
=
length
;
}
else
{
size_t
const
copySize
=
(
size_t
)
(
lowPrefix
-
match
)
;
size_t
const
restSize
=
length
-
copySize
;
LZ4_memcpy
(
op
dictEnd
-
copySize
copySize
)
;
op
+
=
copySize
;
if
(
restSize
>
(
size_t
)
(
op
-
lowPrefix
)
)
{
BYTE
*
const
endOfMatch
=
op
+
restSize
;
const
BYTE
*
copyFrom
=
lowPrefix
;
while
(
op
<
endOfMatch
)
{
*
op
+
+
=
*
copyFrom
+
+
;
}
}
else
{
LZ4_memcpy
(
op
lowPrefix
restSize
)
;
op
+
=
restSize
;
}
}
continue
;
}
cpy
=
op
+
length
;
assert
(
(
op
<
=
oend
)
&
&
(
oend
-
op
>
=
32
)
)
;
if
(
unlikely
(
offset
<
16
)
)
{
LZ4_memcpy_using_offset
(
op
match
cpy
offset
)
;
}
else
{
LZ4_wildCopy32
(
op
match
cpy
)
;
}
op
=
cpy
;
}
safe_decode
:
#
endif
DEBUGLOG
(
6
"
using
safe
decode
loop
"
)
;
while
(
1
)
{
assert
(
ip
<
iend
)
;
token
=
*
ip
+
+
;
length
=
token
>
>
ML_BITS
;
DEBUGLOG
(
7
"
blockPos
%
6u
:
litLength
token
=
%
u
"
(
unsigned
)
(
op
-
(
BYTE
*
)
dst
)
(
unsigned
)
length
)
;
if
(
(
length
!
=
RUN_MASK
)
&
&
likely
(
(
ip
<
shortiend
)
&
(
op
<
=
shortoend
)
)
)
{
LZ4_memcpy
(
op
ip
16
)
;
op
+
=
length
;
ip
+
=
length
;
length
=
token
&
ML_MASK
;
DEBUGLOG
(
7
"
blockPos
%
6u
:
matchLength
token
=
%
u
(
len
=
%
u
)
"
(
unsigned
)
(
op
-
(
BYTE
*
)
dst
)
(
unsigned
)
length
(
unsigned
)
length
+
4
)
;
offset
=
LZ4_readLE16
(
ip
)
;
ip
+
=
2
;
match
=
op
-
offset
;
assert
(
match
<
=
op
)
;
if
(
(
length
!
=
ML_MASK
)
&
&
(
offset
>
=
8
)
&
&
(
dict
=
=
withPrefix64k
|
|
match
>
=
lowPrefix
)
)
{
LZ4_memcpy
(
op
+
0
match
+
0
8
)
;
LZ4_memcpy
(
op
+
8
match
+
8
8
)
;
LZ4_memcpy
(
op
+
16
match
+
16
2
)
;
op
+
=
length
+
MINMATCH
;
continue
;
}
goto
_copy_match
;
}
if
(
length
=
=
RUN_MASK
)
{
size_t
const
addl
=
read_variable_length
(
&
ip
iend
-
RUN_MASK
1
)
;
if
(
addl
=
=
rvl_error
)
{
goto
_output_error
;
}
length
+
=
addl
;
if
(
unlikely
(
(
uptrval
)
(
op
)
+
length
<
(
uptrval
)
(
op
)
)
)
{
goto
_output_error
;
}
if
(
unlikely
(
(
uptrval
)
(
ip
)
+
length
<
(
uptrval
)
(
ip
)
)
)
{
goto
_output_error
;
}
}
#
if
LZ4_FAST_DEC_LOOP
safe_literal_copy
:
#
endif
cpy
=
op
+
length
;
LZ4_STATIC_ASSERT
(
MFLIMIT
>
=
WILDCOPYLENGTH
)
;
if
(
(
cpy
>
oend
-
MFLIMIT
)
|
|
(
ip
+
length
>
iend
-
(
2
+
1
+
LASTLITERALS
)
)
)
{
if
(
partialDecoding
)
{
DEBUGLOG
(
7
"
partialDecoding
:
copying
literals
close
to
input
or
output
end
"
)
DEBUGLOG
(
7
"
partialDecoding
:
literal
length
=
%
u
"
(
unsigned
)
length
)
;
DEBUGLOG
(
7
"
partialDecoding
:
remaining
space
in
dstBuffer
:
%
i
"
(
int
)
(
oend
-
op
)
)
;
DEBUGLOG
(
7
"
partialDecoding
:
remaining
space
in
srcBuffer
:
%
i
"
(
int
)
(
iend
-
ip
)
)
;
if
(
ip
+
length
>
iend
)
{
length
=
(
size_t
)
(
iend
-
ip
)
;
cpy
=
op
+
length
;
}
if
(
cpy
>
oend
)
{
cpy
=
oend
;
assert
(
op
<
=
oend
)
;
length
=
(
size_t
)
(
oend
-
op
)
;
}
}
else
{
if
(
(
ip
+
length
!
=
iend
)
|
|
(
cpy
>
oend
)
)
{
DEBUGLOG
(
5
"
should
have
been
last
run
of
literals
"
)
DEBUGLOG
(
5
"
ip
(
%
p
)
+
length
(
%
i
)
=
%
p
!
=
iend
(
%
p
)
"
ip
(
int
)
length
ip
+
length
iend
)
;
DEBUGLOG
(
5
"
or
cpy
(
%
p
)
>
(
oend
-
MFLIMIT
)
(
%
p
)
"
cpy
oend
-
MFLIMIT
)
;
DEBUGLOG
(
5
"
after
writing
%
u
bytes
/
%
i
bytes
available
"
(
unsigned
)
(
op
-
(
BYTE
*
)
dst
)
outputSize
)
;
goto
_output_error
;
}
}
LZ4_memmove
(
op
ip
length
)
;
ip
+
=
length
;
op
+
=
length
;
if
(
!
partialDecoding
|
|
(
cpy
=
=
oend
)
|
|
(
ip
>
=
(
iend
-
2
)
)
)
{
break
;
}
}
else
{
LZ4_wildCopy8
(
op
ip
cpy
)
;
ip
+
=
length
;
op
=
cpy
;
}
offset
=
LZ4_readLE16
(
ip
)
;
ip
+
=
2
;
match
=
op
-
offset
;
length
=
token
&
ML_MASK
;
DEBUGLOG
(
7
"
blockPos
%
6u
:
matchLength
token
=
%
u
"
(
unsigned
)
(
op
-
(
BYTE
*
)
dst
)
(
unsigned
)
length
)
;
_copy_match
:
if
(
length
=
=
ML_MASK
)
{
size_t
const
addl
=
read_variable_length
(
&
ip
iend
-
LASTLITERALS
+
1
0
)
;
if
(
addl
=
=
rvl_error
)
{
goto
_output_error
;
}
length
+
=
addl
;
if
(
unlikely
(
(
uptrval
)
(
op
)
+
length
<
(
uptrval
)
op
)
)
goto
_output_error
;
}
length
+
=
MINMATCH
;
#
if
LZ4_FAST_DEC_LOOP
safe_match_copy
:
#
endif
if
(
(
checkOffset
)
&
&
(
unlikely
(
match
+
dictSize
<
lowPrefix
)
)
)
goto
_output_error
;
if
(
(
dict
=
=
usingExtDict
)
&
&
(
match
<
lowPrefix
)
)
{
assert
(
dictEnd
!
=
NULL
)
;
if
(
unlikely
(
op
+
length
>
oend
-
LASTLITERALS
)
)
{
if
(
partialDecoding
)
length
=
MIN
(
length
(
size_t
)
(
oend
-
op
)
)
;
else
goto
_output_error
;
}
if
(
length
<
=
(
size_t
)
(
lowPrefix
-
match
)
)
{
LZ4_memmove
(
op
dictEnd
-
(
lowPrefix
-
match
)
length
)
;
op
+
=
length
;
}
else
{
size_t
const
copySize
=
(
size_t
)
(
lowPrefix
-
match
)
;
size_t
const
restSize
=
length
-
copySize
;
LZ4_memcpy
(
op
dictEnd
-
copySize
copySize
)
;
op
+
=
copySize
;
if
(
restSize
>
(
size_t
)
(
op
-
lowPrefix
)
)
{
BYTE
*
const
endOfMatch
=
op
+
restSize
;
const
BYTE
*
copyFrom
=
lowPrefix
;
while
(
op
<
endOfMatch
)
*
op
+
+
=
*
copyFrom
+
+
;
}
else
{
LZ4_memcpy
(
op
lowPrefix
restSize
)
;
op
+
=
restSize
;
}
}
continue
;
}
assert
(
match
>
=
lowPrefix
)
;
cpy
=
op
+
length
;
assert
(
op
<
=
oend
)
;
if
(
partialDecoding
&
&
(
cpy
>
oend
-
MATCH_SAFEGUARD_DISTANCE
)
)
{
size_t
const
mlen
=
MIN
(
length
(
size_t
)
(
oend
-
op
)
)
;
const
BYTE
*
const
matchEnd
=
match
+
mlen
;
BYTE
*
const
copyEnd
=
op
+
mlen
;
if
(
matchEnd
>
op
)
{
while
(
op
<
copyEnd
)
{
*
op
+
+
=
*
match
+
+
;
}
}
else
{
LZ4_memcpy
(
op
match
mlen
)
;
}
op
=
copyEnd
;
if
(
op
=
=
oend
)
{
break
;
}
continue
;
}
if
(
unlikely
(
offset
<
8
)
)
{
LZ4_write32
(
op
0
)
;
op
[
0
]
=
match
[
0
]
;
op
[
1
]
=
match
[
1
]
;
op
[
2
]
=
match
[
2
]
;
op
[
3
]
=
match
[
3
]
;
match
+
=
inc32table
[
offset
]
;
LZ4_memcpy
(
op
+
4
match
4
)
;
match
-
=
dec64table
[
offset
]
;
}
else
{
LZ4_memcpy
(
op
match
8
)
;
match
+
=
8
;
}
op
+
=
8
;
if
(
unlikely
(
cpy
>
oend
-
MATCH_SAFEGUARD_DISTANCE
)
)
{
BYTE
*
const
oCopyLimit
=
oend
-
(
WILDCOPYLENGTH
-
1
)
;
if
(
cpy
>
oend
-
LASTLITERALS
)
{
goto
_output_error
;
}
if
(
op
<
oCopyLimit
)
{
LZ4_wildCopy8
(
op
match
oCopyLimit
)
;
match
+
=
oCopyLimit
-
op
;
op
=
oCopyLimit
;
}
while
(
op
<
cpy
)
{
*
op
+
+
=
*
match
+
+
;
}
}
else
{
LZ4_memcpy
(
op
match
8
)
;
if
(
length
>
16
)
{
LZ4_wildCopy8
(
op
+
8
match
+
8
cpy
)
;
}
}
op
=
cpy
;
}
DEBUGLOG
(
5
"
decoded
%
i
bytes
"
(
int
)
(
(
(
char
*
)
op
)
-
dst
)
)
;
return
(
int
)
(
(
(
char
*
)
op
)
-
dst
)
;
_output_error
:
return
(
int
)
(
-
(
(
(
const
char
*
)
ip
)
-
src
)
)
-
1
;
}
}
LZ4_FORCE_O2
int
LZ4_decompress_safe
(
const
char
*
source
char
*
dest
int
compressedSize
int
maxDecompressedSize
)
{
return
LZ4_decompress_generic
(
source
dest
compressedSize
maxDecompressedSize
decode_full_block
noDict
(
BYTE
*
)
dest
NULL
0
)
;
}
LZ4_FORCE_O2
int
LZ4_decompress_safe_partial
(
const
char
*
src
char
*
dst
int
compressedSize
int
targetOutputSize
int
dstCapacity
)
{
dstCapacity
=
MIN
(
targetOutputSize
dstCapacity
)
;
return
LZ4_decompress_generic
(
src
dst
compressedSize
dstCapacity
partial_decode
noDict
(
BYTE
*
)
dst
NULL
0
)
;
}
LZ4_FORCE_O2
int
LZ4_decompress_fast
(
const
char
*
source
char
*
dest
int
originalSize
)
{
DEBUGLOG
(
5
"
LZ4_decompress_fast
"
)
;
return
LZ4_decompress_unsafe_generic
(
(
const
BYTE
*
)
source
(
BYTE
*
)
dest
originalSize
0
NULL
0
)
;
}
LZ4_FORCE_O2
int
LZ4_decompress_safe_withPrefix64k
(
const
char
*
source
char
*
dest
int
compressedSize
int
maxOutputSize
)
{
return
LZ4_decompress_generic
(
source
dest
compressedSize
maxOutputSize
decode_full_block
withPrefix64k
(
BYTE
*
)
dest
-
64
KB
NULL
0
)
;
}
LZ4_FORCE_O2
static
int
LZ4_decompress_safe_partial_withPrefix64k
(
const
char
*
source
char
*
dest
int
compressedSize
int
targetOutputSize
int
dstCapacity
)
{
dstCapacity
=
MIN
(
targetOutputSize
dstCapacity
)
;
return
LZ4_decompress_generic
(
source
dest
compressedSize
dstCapacity
partial_decode
withPrefix64k
(
BYTE
*
)
dest
-
64
KB
NULL
0
)
;
}
int
LZ4_decompress_fast_withPrefix64k
(
const
char
*
source
char
*
dest
int
originalSize
)
{
return
LZ4_decompress_unsafe_generic
(
(
const
BYTE
*
)
source
(
BYTE
*
)
dest
originalSize
64
KB
NULL
0
)
;
}
LZ4_FORCE_O2
static
int
LZ4_decompress_safe_withSmallPrefix
(
const
char
*
source
char
*
dest
int
compressedSize
int
maxOutputSize
size_t
prefixSize
)
{
return
LZ4_decompress_generic
(
source
dest
compressedSize
maxOutputSize
decode_full_block
noDict
(
BYTE
*
)
dest
-
prefixSize
NULL
0
)
;
}
LZ4_FORCE_O2
static
int
LZ4_decompress_safe_partial_withSmallPrefix
(
const
char
*
source
char
*
dest
int
compressedSize
int
targetOutputSize
int
dstCapacity
size_t
prefixSize
)
{
dstCapacity
=
MIN
(
targetOutputSize
dstCapacity
)
;
return
LZ4_decompress_generic
(
source
dest
compressedSize
dstCapacity
partial_decode
noDict
(
BYTE
*
)
dest
-
prefixSize
NULL
0
)
;
}
LZ4_FORCE_O2
int
LZ4_decompress_safe_forceExtDict
(
const
char
*
source
char
*
dest
int
compressedSize
int
maxOutputSize
const
void
*
dictStart
size_t
dictSize
)
{
DEBUGLOG
(
5
"
LZ4_decompress_safe_forceExtDict
"
)
;
return
LZ4_decompress_generic
(
source
dest
compressedSize
maxOutputSize
decode_full_block
usingExtDict
(
BYTE
*
)
dest
(
const
BYTE
*
)
dictStart
dictSize
)
;
}
LZ4_FORCE_O2
int
LZ4_decompress_safe_partial_forceExtDict
(
const
char
*
source
char
*
dest
int
compressedSize
int
targetOutputSize
int
dstCapacity
const
void
*
dictStart
size_t
dictSize
)
{
dstCapacity
=
MIN
(
targetOutputSize
dstCapacity
)
;
return
LZ4_decompress_generic
(
source
dest
compressedSize
dstCapacity
partial_decode
usingExtDict
(
BYTE
*
)
dest
(
const
BYTE
*
)
dictStart
dictSize
)
;
}
LZ4_FORCE_O2
static
int
LZ4_decompress_fast_extDict
(
const
char
*
source
char
*
dest
int
originalSize
const
void
*
dictStart
size_t
dictSize
)
{
return
LZ4_decompress_unsafe_generic
(
(
const
BYTE
*
)
source
(
BYTE
*
)
dest
originalSize
0
(
const
BYTE
*
)
dictStart
dictSize
)
;
}
LZ4_FORCE_INLINE
int
LZ4_decompress_safe_doubleDict
(
const
char
*
source
char
*
dest
int
compressedSize
int
maxOutputSize
size_t
prefixSize
const
void
*
dictStart
size_t
dictSize
)
{
return
LZ4_decompress_generic
(
source
dest
compressedSize
maxOutputSize
decode_full_block
usingExtDict
(
BYTE
*
)
dest
-
prefixSize
(
const
BYTE
*
)
dictStart
dictSize
)
;
}
#
if
!
defined
(
LZ4_STATIC_LINKING_ONLY_DISABLE_MEMORY_ALLOCATION
)
LZ4_streamDecode_t
*
LZ4_createStreamDecode
(
void
)
{
LZ4_STATIC_ASSERT
(
sizeof
(
LZ4_streamDecode_t
)
>
=
sizeof
(
LZ4_streamDecode_t_internal
)
)
;
return
(
LZ4_streamDecode_t
*
)
ALLOC_AND_ZERO
(
sizeof
(
LZ4_streamDecode_t
)
)
;
}
int
LZ4_freeStreamDecode
(
LZ4_streamDecode_t
*
LZ4_stream
)
{
if
(
LZ4_stream
=
=
NULL
)
{
return
0
;
}
FREEMEM
(
LZ4_stream
)
;
return
0
;
}
#
endif
int
LZ4_setStreamDecode
(
LZ4_streamDecode_t
*
LZ4_streamDecode
const
char
*
dictionary
int
dictSize
)
{
LZ4_streamDecode_t_internal
*
lz4sd
=
&
LZ4_streamDecode
-
>
internal_donotuse
;
lz4sd
-
>
prefixSize
=
(
size_t
)
dictSize
;
if
(
dictSize
)
{
assert
(
dictionary
!
=
NULL
)
;
lz4sd
-
>
prefixEnd
=
(
const
BYTE
*
)
dictionary
+
dictSize
;
}
else
{
lz4sd
-
>
prefixEnd
=
(
const
BYTE
*
)
dictionary
;
}
lz4sd
-
>
externalDict
=
NULL
;
lz4sd
-
>
extDictSize
=
0
;
return
1
;
}
int
LZ4_decoderRingBufferSize
(
int
maxBlockSize
)
{
if
(
maxBlockSize
<
0
)
return
0
;
if
(
maxBlockSize
>
LZ4_MAX_INPUT_SIZE
)
return
0
;
if
(
maxBlockSize
<
16
)
maxBlockSize
=
16
;
return
LZ4_DECODER_RING_BUFFER_SIZE
(
maxBlockSize
)
;
}
LZ4_FORCE_O2
int
LZ4_decompress_safe_continue
(
LZ4_streamDecode_t
*
LZ4_streamDecode
const
char
*
source
char
*
dest
int
compressedSize
int
maxOutputSize
)
{
LZ4_streamDecode_t_internal
*
lz4sd
=
&
LZ4_streamDecode
-
>
internal_donotuse
;
int
result
;
if
(
lz4sd
-
>
prefixSize
=
=
0
)
{
assert
(
lz4sd
-
>
extDictSize
=
=
0
)
;
result
=
LZ4_decompress_safe
(
source
dest
compressedSize
maxOutputSize
)
;
if
(
result
<
=
0
)
return
result
;
lz4sd
-
>
prefixSize
=
(
size_t
)
result
;
lz4sd
-
>
prefixEnd
=
(
BYTE
*
)
dest
+
result
;
}
else
if
(
lz4sd
-
>
prefixEnd
=
=
(
BYTE
*
)
dest
)
{
if
(
lz4sd
-
>
prefixSize
>
=
64
KB
-
1
)
result
=
LZ4_decompress_safe_withPrefix64k
(
source
dest
compressedSize
maxOutputSize
)
;
else
if
(
lz4sd
-
>
extDictSize
=
=
0
)
result
=
LZ4_decompress_safe_withSmallPrefix
(
source
dest
compressedSize
maxOutputSize
lz4sd
-
>
prefixSize
)
;
else
result
=
LZ4_decompress_safe_doubleDict
(
source
dest
compressedSize
maxOutputSize
lz4sd
-
>
prefixSize
lz4sd
-
>
externalDict
lz4sd
-
>
extDictSize
)
;
if
(
result
<
=
0
)
return
result
;
lz4sd
-
>
prefixSize
+
=
(
size_t
)
result
;
lz4sd
-
>
prefixEnd
+
=
result
;
}
else
{
lz4sd
-
>
extDictSize
=
lz4sd
-
>
prefixSize
;
lz4sd
-
>
externalDict
=
lz4sd
-
>
prefixEnd
-
lz4sd
-
>
extDictSize
;
result
=
LZ4_decompress_safe_forceExtDict
(
source
dest
compressedSize
maxOutputSize
lz4sd
-
>
externalDict
lz4sd
-
>
extDictSize
)
;
if
(
result
<
=
0
)
return
result
;
lz4sd
-
>
prefixSize
=
(
size_t
)
result
;
lz4sd
-
>
prefixEnd
=
(
BYTE
*
)
dest
+
result
;
}
return
result
;
}
LZ4_FORCE_O2
int
LZ4_decompress_fast_continue
(
LZ4_streamDecode_t
*
LZ4_streamDecode
const
char
*
source
char
*
dest
int
originalSize
)
{
LZ4_streamDecode_t_internal
*
const
lz4sd
=
(
assert
(
LZ4_streamDecode
!
=
NULL
)
&
LZ4_streamDecode
-
>
internal_donotuse
)
;
int
result
;
DEBUGLOG
(
5
"
LZ4_decompress_fast_continue
(
toDecodeSize
=
%
i
)
"
originalSize
)
;
assert
(
originalSize
>
=
0
)
;
if
(
lz4sd
-
>
prefixSize
=
=
0
)
{
DEBUGLOG
(
5
"
first
invocation
:
no
prefix
nor
extDict
"
)
;
assert
(
lz4sd
-
>
extDictSize
=
=
0
)
;
result
=
LZ4_decompress_fast
(
source
dest
originalSize
)
;
if
(
result
<
=
0
)
return
result
;
lz4sd
-
>
prefixSize
=
(
size_t
)
originalSize
;
lz4sd
-
>
prefixEnd
=
(
BYTE
*
)
dest
+
originalSize
;
}
else
if
(
lz4sd
-
>
prefixEnd
=
=
(
BYTE
*
)
dest
)
{
DEBUGLOG
(
5
"
continue
using
existing
prefix
"
)
;
result
=
LZ4_decompress_unsafe_generic
(
(
const
BYTE
*
)
source
(
BYTE
*
)
dest
originalSize
lz4sd
-
>
prefixSize
lz4sd
-
>
externalDict
lz4sd
-
>
extDictSize
)
;
if
(
result
<
=
0
)
return
result
;
lz4sd
-
>
prefixSize
+
=
(
size_t
)
originalSize
;
lz4sd
-
>
prefixEnd
+
=
originalSize
;
}
else
{
DEBUGLOG
(
5
"
prefix
becomes
extDict
"
)
;
lz4sd
-
>
extDictSize
=
lz4sd
-
>
prefixSize
;
lz4sd
-
>
externalDict
=
lz4sd
-
>
prefixEnd
-
lz4sd
-
>
extDictSize
;
result
=
LZ4_decompress_fast_extDict
(
source
dest
originalSize
lz4sd
-
>
externalDict
lz4sd
-
>
extDictSize
)
;
if
(
result
<
=
0
)
return
result
;
lz4sd
-
>
prefixSize
=
(
size_t
)
originalSize
;
lz4sd
-
>
prefixEnd
=
(
BYTE
*
)
dest
+
originalSize
;
}
return
result
;
}
int
LZ4_decompress_safe_usingDict
(
const
char
*
source
char
*
dest
int
compressedSize
int
maxOutputSize
const
char
*
dictStart
int
dictSize
)
{
if
(
dictSize
=
=
0
)
return
LZ4_decompress_safe
(
source
dest
compressedSize
maxOutputSize
)
;
if
(
dictStart
+
dictSize
=
=
dest
)
{
if
(
dictSize
>
=
64
KB
-
1
)
{
return
LZ4_decompress_safe_withPrefix64k
(
source
dest
compressedSize
maxOutputSize
)
;
}
assert
(
dictSize
>
=
0
)
;
return
LZ4_decompress_safe_withSmallPrefix
(
source
dest
compressedSize
maxOutputSize
(
size_t
)
dictSize
)
;
}
assert
(
dictSize
>
=
0
)
;
return
LZ4_decompress_safe_forceExtDict
(
source
dest
compressedSize
maxOutputSize
dictStart
(
size_t
)
dictSize
)
;
}
int
LZ4_decompress_safe_partial_usingDict
(
const
char
*
source
char
*
dest
int
compressedSize
int
targetOutputSize
int
dstCapacity
const
char
*
dictStart
int
dictSize
)
{
if
(
dictSize
=
=
0
)
return
LZ4_decompress_safe_partial
(
source
dest
compressedSize
targetOutputSize
dstCapacity
)
;
if
(
dictStart
+
dictSize
=
=
dest
)
{
if
(
dictSize
>
=
64
KB
-
1
)
{
return
LZ4_decompress_safe_partial_withPrefix64k
(
source
dest
compressedSize
targetOutputSize
dstCapacity
)
;
}
assert
(
dictSize
>
=
0
)
;
return
LZ4_decompress_safe_partial_withSmallPrefix
(
source
dest
compressedSize
targetOutputSize
dstCapacity
(
size_t
)
dictSize
)
;
}
assert
(
dictSize
>
=
0
)
;
return
LZ4_decompress_safe_partial_forceExtDict
(
source
dest
compressedSize
targetOutputSize
dstCapacity
dictStart
(
size_t
)
dictSize
)
;
}
int
LZ4_decompress_fast_usingDict
(
const
char
*
source
char
*
dest
int
originalSize
const
char
*
dictStart
int
dictSize
)
{
if
(
dictSize
=
=
0
|
|
dictStart
+
dictSize
=
=
dest
)
return
LZ4_decompress_unsafe_generic
(
(
const
BYTE
*
)
source
(
BYTE
*
)
dest
originalSize
(
size_t
)
dictSize
NULL
0
)
;
assert
(
dictSize
>
=
0
)
;
return
LZ4_decompress_fast_extDict
(
source
dest
originalSize
dictStart
(
size_t
)
dictSize
)
;
}
int
LZ4_compress_limitedOutput
(
const
char
*
source
char
*
dest
int
inputSize
int
maxOutputSize
)
{
return
LZ4_compress_default
(
source
dest
inputSize
maxOutputSize
)
;
}
int
LZ4_compress
(
const
char
*
src
char
*
dest
int
srcSize
)
{
return
LZ4_compress_default
(
src
dest
srcSize
LZ4_compressBound
(
srcSize
)
)
;
}
int
LZ4_compress_limitedOutput_withState
(
void
*
state
const
char
*
src
char
*
dst
int
srcSize
int
dstSize
)
{
return
LZ4_compress_fast_extState
(
state
src
dst
srcSize
dstSize
1
)
;
}
int
LZ4_compress_withState
(
void
*
state
const
char
*
src
char
*
dst
int
srcSize
)
{
return
LZ4_compress_fast_extState
(
state
src
dst
srcSize
LZ4_compressBound
(
srcSize
)
1
)
;
}
int
LZ4_compress_limitedOutput_continue
(
LZ4_stream_t
*
LZ4_stream
const
char
*
src
char
*
dst
int
srcSize
int
dstCapacity
)
{
return
LZ4_compress_fast_continue
(
LZ4_stream
src
dst
srcSize
dstCapacity
1
)
;
}
int
LZ4_compress_continue
(
LZ4_stream_t
*
LZ4_stream
const
char
*
source
char
*
dest
int
inputSize
)
{
return
LZ4_compress_fast_continue
(
LZ4_stream
source
dest
inputSize
LZ4_compressBound
(
inputSize
)
1
)
;
}
int
LZ4_uncompress
(
const
char
*
source
char
*
dest
int
outputSize
)
{
return
LZ4_decompress_fast
(
source
dest
outputSize
)
;
}
int
LZ4_uncompress_unknownOutputSize
(
const
char
*
source
char
*
dest
int
isize
int
maxOutputSize
)
{
return
LZ4_decompress_safe
(
source
dest
isize
maxOutputSize
)
;
}
int
LZ4_sizeofStreamState
(
void
)
{
return
sizeof
(
LZ4_stream_t
)
;
}
int
LZ4_resetStreamState
(
void
*
state
char
*
inputBuffer
)
{
(
void
)
inputBuffer
;
LZ4_resetStream
(
(
LZ4_stream_t
*
)
state
)
;
return
0
;
}
#
if
!
defined
(
LZ4_STATIC_LINKING_ONLY_DISABLE_MEMORY_ALLOCATION
)
void
*
LZ4_create
(
char
*
inputBuffer
)
{
(
void
)
inputBuffer
;
return
LZ4_createStream
(
)
;
}
#
endif
char
*
LZ4_slideInputBuffer
(
void
*
state
)
{
return
(
char
*
)
(
uptrval
)
(
(
LZ4_stream_t
*
)
state
)
-
>
internal_donotuse
.
dictionary
;
}
#
endif
