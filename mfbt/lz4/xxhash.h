#
if
defined
(
__cplusplus
)
extern
"
C
"
{
#
endif
#
if
(
defined
(
XXH_INLINE_ALL
)
|
|
defined
(
XXH_PRIVATE_API
)
)
\
&
&
!
defined
(
XXH_INLINE_ALL_31684351384
)
#
define
XXH_INLINE_ALL_31684351384
#
undef
XXH_STATIC_LINKING_ONLY
/
*
avoid
macro
redef
*
/
#
define
XXH_STATIC_LINKING_ONLY
#
undef
XXH_PUBLIC_API
#
if
defined
(
__GNUC__
)
#
define
XXH_PUBLIC_API
static
__inline
__attribute__
(
(
unused
)
)
#
elif
defined
(
__cplusplus
)
|
|
(
defined
(
__STDC_VERSION__
)
&
&
(
__STDC_VERSION__
>
=
199901L
)
)
#
define
XXH_PUBLIC_API
static
inline
#
elif
defined
(
_MSC_VER
)
#
define
XXH_PUBLIC_API
static
__inline
#
else
#
define
XXH_PUBLIC_API
static
#
endif
#
ifdef
XXH_NAMESPACE
#
error
"
XXH_INLINE_ALL
with
XXH_NAMESPACE
is
not
supported
"
#
endif
#
define
XXH_NAMESPACE
XXH_INLINE_
#
define
XXH_IPREF
(
Id
)
XXH_INLINE_
#
#
Id
#
define
XXH_OK
XXH_IPREF
(
XXH_OK
)
#
define
XXH_ERROR
XXH_IPREF
(
XXH_ERROR
)
#
define
XXH_errorcode
XXH_IPREF
(
XXH_errorcode
)
#
define
XXH32_canonical_t
XXH_IPREF
(
XXH32_canonical_t
)
#
define
XXH64_canonical_t
XXH_IPREF
(
XXH64_canonical_t
)
#
define
XXH128_canonical_t
XXH_IPREF
(
XXH128_canonical_t
)
#
define
XXH32_state_s
XXH_IPREF
(
XXH32_state_s
)
#
define
XXH32_state_t
XXH_IPREF
(
XXH32_state_t
)
#
define
XXH64_state_s
XXH_IPREF
(
XXH64_state_s
)
#
define
XXH64_state_t
XXH_IPREF
(
XXH64_state_t
)
#
define
XXH3_state_s
XXH_IPREF
(
XXH3_state_s
)
#
define
XXH3_state_t
XXH_IPREF
(
XXH3_state_t
)
#
define
XXH128_hash_t
XXH_IPREF
(
XXH128_hash_t
)
#
undef
XXHASH_H_5627135585666179
#
undef
XXHASH_H_STATIC_13879238742
#
endif
#
ifndef
XXHASH_H_5627135585666179
#
define
XXHASH_H_5627135585666179
1
#
if
!
defined
(
XXH_INLINE_ALL
)
&
&
!
defined
(
XXH_PRIVATE_API
)
#
if
defined
(
WIN32
)
&
&
defined
(
_MSC_VER
)
&
&
(
defined
(
XXH_IMPORT
)
|
|
defined
(
XXH_EXPORT
)
)
#
ifdef
XXH_EXPORT
#
define
XXH_PUBLIC_API
__declspec
(
dllexport
)
#
elif
XXH_IMPORT
#
define
XXH_PUBLIC_API
__declspec
(
dllimport
)
#
endif
#
else
#
define
XXH_PUBLIC_API
#
endif
#
endif
#
ifdef
XXH_NAMESPACE
#
define
XXH_CAT
(
A
B
)
A
#
#
B
#
define
XXH_NAME2
(
A
B
)
XXH_CAT
(
A
B
)
#
define
XXH_versionNumber
XXH_NAME2
(
XXH_NAMESPACE
XXH_versionNumber
)
#
define
XXH32
XXH_NAME2
(
XXH_NAMESPACE
XXH32
)
#
define
XXH32_createState
XXH_NAME2
(
XXH_NAMESPACE
XXH32_createState
)
#
define
XXH32_freeState
XXH_NAME2
(
XXH_NAMESPACE
XXH32_freeState
)
#
define
XXH32_reset
XXH_NAME2
(
XXH_NAMESPACE
XXH32_reset
)
#
define
XXH32_update
XXH_NAME2
(
XXH_NAMESPACE
XXH32_update
)
#
define
XXH32_digest
XXH_NAME2
(
XXH_NAMESPACE
XXH32_digest
)
#
define
XXH32_copyState
XXH_NAME2
(
XXH_NAMESPACE
XXH32_copyState
)
#
define
XXH32_canonicalFromHash
XXH_NAME2
(
XXH_NAMESPACE
XXH32_canonicalFromHash
)
#
define
XXH32_hashFromCanonical
XXH_NAME2
(
XXH_NAMESPACE
XXH32_hashFromCanonical
)
#
define
XXH64
XXH_NAME2
(
XXH_NAMESPACE
XXH64
)
#
define
XXH64_createState
XXH_NAME2
(
XXH_NAMESPACE
XXH64_createState
)
#
define
XXH64_freeState
XXH_NAME2
(
XXH_NAMESPACE
XXH64_freeState
)
#
define
XXH64_reset
XXH_NAME2
(
XXH_NAMESPACE
XXH64_reset
)
#
define
XXH64_update
XXH_NAME2
(
XXH_NAMESPACE
XXH64_update
)
#
define
XXH64_digest
XXH_NAME2
(
XXH_NAMESPACE
XXH64_digest
)
#
define
XXH64_copyState
XXH_NAME2
(
XXH_NAMESPACE
XXH64_copyState
)
#
define
XXH64_canonicalFromHash
XXH_NAME2
(
XXH_NAMESPACE
XXH64_canonicalFromHash
)
#
define
XXH64_hashFromCanonical
XXH_NAME2
(
XXH_NAMESPACE
XXH64_hashFromCanonical
)
#
endif
#
define
XXH_VERSION_MAJOR
0
#
define
XXH_VERSION_MINOR
7
#
define
XXH_VERSION_RELEASE
3
#
define
XXH_VERSION_NUMBER
(
XXH_VERSION_MAJOR
*
100
*
100
+
XXH_VERSION_MINOR
*
100
+
XXH_VERSION_RELEASE
)
XXH_PUBLIC_API
unsigned
XXH_versionNumber
(
void
)
;
#
include
<
stddef
.
h
>
typedef
enum
{
XXH_OK
=
0
XXH_ERROR
}
XXH_errorcode
;
#
if
!
defined
(
__VMS
)
\
&
&
(
defined
(
__cplusplus
)
\
|
|
(
defined
(
__STDC_VERSION__
)
&
&
(
__STDC_VERSION__
>
=
199901L
)
)
)
#
include
<
stdint
.
h
>
typedef
uint32_t
XXH32_hash_t
;
#
else
#
include
<
limits
.
h
>
#
if
UINT_MAX
=
=
0xFFFFFFFFUL
typedef
unsigned
int
XXH32_hash_t
;
#
else
#
if
ULONG_MAX
=
=
0xFFFFFFFFUL
typedef
unsigned
long
XXH32_hash_t
;
#
else
#
error
"
unsupported
platform
:
need
a
32
-
bit
type
"
#
endif
#
endif
#
endif
XXH_PUBLIC_API
XXH32_hash_t
XXH32
(
const
void
*
input
size_t
length
XXH32_hash_t
seed
)
;
typedef
struct
XXH32_state_s
XXH32_state_t
;
XXH_PUBLIC_API
XXH32_state_t
*
XXH32_createState
(
void
)
;
XXH_PUBLIC_API
XXH_errorcode
XXH32_freeState
(
XXH32_state_t
*
statePtr
)
;
XXH_PUBLIC_API
void
XXH32_copyState
(
XXH32_state_t
*
dst_state
const
XXH32_state_t
*
src_state
)
;
XXH_PUBLIC_API
XXH_errorcode
XXH32_reset
(
XXH32_state_t
*
statePtr
XXH32_hash_t
seed
)
;
XXH_PUBLIC_API
XXH_errorcode
XXH32_update
(
XXH32_state_t
*
statePtr
const
void
*
input
size_t
length
)
;
XXH_PUBLIC_API
XXH32_hash_t
XXH32_digest
(
const
XXH32_state_t
*
statePtr
)
;
typedef
struct
{
unsigned
char
digest
[
4
]
;
}
XXH32_canonical_t
;
XXH_PUBLIC_API
void
XXH32_canonicalFromHash
(
XXH32_canonical_t
*
dst
XXH32_hash_t
hash
)
;
XXH_PUBLIC_API
XXH32_hash_t
XXH32_hashFromCanonical
(
const
XXH32_canonical_t
*
src
)
;
#
ifndef
XXH_NO_LONG_LONG
#
if
!
defined
(
__VMS
)
\
&
&
(
defined
(
__cplusplus
)
\
|
|
(
defined
(
__STDC_VERSION__
)
&
&
(
__STDC_VERSION__
>
=
199901L
)
)
)
#
include
<
stdint
.
h
>
typedef
uint64_t
XXH64_hash_t
;
#
else
typedef
unsigned
long
long
XXH64_hash_t
;
#
endif
XXH_PUBLIC_API
XXH64_hash_t
XXH64
(
const
void
*
input
size_t
length
XXH64_hash_t
seed
)
;
typedef
struct
XXH64_state_s
XXH64_state_t
;
XXH_PUBLIC_API
XXH64_state_t
*
XXH64_createState
(
void
)
;
XXH_PUBLIC_API
XXH_errorcode
XXH64_freeState
(
XXH64_state_t
*
statePtr
)
;
XXH_PUBLIC_API
void
XXH64_copyState
(
XXH64_state_t
*
dst_state
const
XXH64_state_t
*
src_state
)
;
XXH_PUBLIC_API
XXH_errorcode
XXH64_reset
(
XXH64_state_t
*
statePtr
XXH64_hash_t
seed
)
;
XXH_PUBLIC_API
XXH_errorcode
XXH64_update
(
XXH64_state_t
*
statePtr
const
void
*
input
size_t
length
)
;
XXH_PUBLIC_API
XXH64_hash_t
XXH64_digest
(
const
XXH64_state_t
*
statePtr
)
;
typedef
struct
{
unsigned
char
digest
[
8
]
;
}
XXH64_canonical_t
;
XXH_PUBLIC_API
void
XXH64_canonicalFromHash
(
XXH64_canonical_t
*
dst
XXH64_hash_t
hash
)
;
XXH_PUBLIC_API
XXH64_hash_t
XXH64_hashFromCanonical
(
const
XXH64_canonical_t
*
src
)
;
#
endif
#
endif
#
if
defined
(
XXH_STATIC_LINKING_ONLY
)
&
&
!
defined
(
XXHASH_H_STATIC_13879238742
)
#
define
XXHASH_H_STATIC_13879238742
struct
XXH32_state_s
{
XXH32_hash_t
total_len_32
;
XXH32_hash_t
large_len
;
XXH32_hash_t
v1
;
XXH32_hash_t
v2
;
XXH32_hash_t
v3
;
XXH32_hash_t
v4
;
XXH32_hash_t
mem32
[
4
]
;
XXH32_hash_t
memsize
;
XXH32_hash_t
reserved
;
}
;
#
ifndef
XXH_NO_LONG_LONG
struct
XXH64_state_s
{
XXH64_hash_t
total_len
;
XXH64_hash_t
v1
;
XXH64_hash_t
v2
;
XXH64_hash_t
v3
;
XXH64_hash_t
v4
;
XXH64_hash_t
mem64
[
4
]
;
XXH32_hash_t
memsize
;
XXH32_hash_t
reserved32
;
XXH64_hash_t
reserved64
;
}
;
#
ifdef
XXH_NAMESPACE
#
define
XXH3_64bits
XXH_NAME2
(
XXH_NAMESPACE
XXH3_64bits
)
#
define
XXH3_64bits_withSecret
XXH_NAME2
(
XXH_NAMESPACE
XXH3_64bits_withSecret
)
#
define
XXH3_64bits_withSeed
XXH_NAME2
(
XXH_NAMESPACE
XXH3_64bits_withSeed
)
#
define
XXH3_createState
XXH_NAME2
(
XXH_NAMESPACE
XXH3_createState
)
#
define
XXH3_freeState
XXH_NAME2
(
XXH_NAMESPACE
XXH3_freeState
)
#
define
XXH3_copyState
XXH_NAME2
(
XXH_NAMESPACE
XXH3_copyState
)
#
define
XXH3_64bits_reset
XXH_NAME2
(
XXH_NAMESPACE
XXH3_64bits_reset
)
#
define
XXH3_64bits_reset_withSeed
XXH_NAME2
(
XXH_NAMESPACE
XXH3_64bits_reset_withSeed
)
#
define
XXH3_64bits_reset_withSecret
XXH_NAME2
(
XXH_NAMESPACE
XXH3_64bits_reset_withSecret
)
#
define
XXH3_64bits_update
XXH_NAME2
(
XXH_NAMESPACE
XXH3_64bits_update
)
#
define
XXH3_64bits_digest
XXH_NAME2
(
XXH_NAMESPACE
XXH3_64bits_digest
)
#
endif
XXH_PUBLIC_API
XXH64_hash_t
XXH3_64bits
(
const
void
*
data
size_t
len
)
;
#
define
XXH3_SECRET_SIZE_MIN
136
XXH_PUBLIC_API
XXH64_hash_t
XXH3_64bits_withSecret
(
const
void
*
data
size_t
len
const
void
*
secret
size_t
secretSize
)
;
XXH_PUBLIC_API
XXH64_hash_t
XXH3_64bits_withSeed
(
const
void
*
data
size_t
len
XXH64_hash_t
seed
)
;
#
if
defined
(
__STDC_VERSION__
)
&
&
(
__STDC_VERSION__
>
=
201112L
)
#
include
<
stdalign
.
h
>
#
define
XXH_ALIGN
(
n
)
alignas
(
n
)
#
elif
defined
(
__GNUC__
)
#
define
XXH_ALIGN
(
n
)
__attribute__
(
(
aligned
(
n
)
)
)
#
elif
defined
(
_MSC_VER
)
#
define
XXH_ALIGN
(
n
)
__declspec
(
align
(
n
)
)
#
else
#
define
XXH_ALIGN
(
n
)
#
endif
#
if
!
(
defined
(
__STDC_VERSION__
)
&
&
(
__STDC_VERSION__
>
=
201112L
)
)
\
&
&
defined
(
__GNUC__
)
#
define
XXH_ALIGN_MEMBER
(
align
type
)
type
XXH_ALIGN
(
align
)
#
else
#
define
XXH_ALIGN_MEMBER
(
align
type
)
XXH_ALIGN
(
align
)
type
#
endif
typedef
struct
XXH3_state_s
XXH3_state_t
;
#
define
XXH3_SECRET_DEFAULT_SIZE
192
/
*
minimum
XXH3_SECRET_SIZE_MIN
*
/
#
define
XXH3_INTERNALBUFFER_SIZE
256
struct
XXH3_state_s
{
XXH_ALIGN_MEMBER
(
64
XXH64_hash_t
acc
[
8
]
)
;
XXH_ALIGN_MEMBER
(
64
unsigned
char
customSecret
[
XXH3_SECRET_DEFAULT_SIZE
]
)
;
XXH_ALIGN_MEMBER
(
64
unsigned
char
buffer
[
XXH3_INTERNALBUFFER_SIZE
]
)
;
XXH32_hash_t
bufferedSize
;
XXH32_hash_t
nbStripesPerBlock
;
XXH32_hash_t
nbStripesSoFar
;
XXH32_hash_t
secretLimit
;
XXH32_hash_t
reserved32
;
XXH32_hash_t
reserved32_2
;
XXH64_hash_t
totalLen
;
XXH64_hash_t
seed
;
XXH64_hash_t
reserved64
;
const
unsigned
char
*
secret
;
}
;
#
undef
XXH_ALIGN_MEMBER
XXH_PUBLIC_API
XXH3_state_t
*
XXH3_createState
(
void
)
;
XXH_PUBLIC_API
XXH_errorcode
XXH3_freeState
(
XXH3_state_t
*
statePtr
)
;
XXH_PUBLIC_API
void
XXH3_copyState
(
XXH3_state_t
*
dst_state
const
XXH3_state_t
*
src_state
)
;
XXH_PUBLIC_API
XXH_errorcode
XXH3_64bits_reset
(
XXH3_state_t
*
statePtr
)
;
XXH_PUBLIC_API
XXH_errorcode
XXH3_64bits_reset_withSeed
(
XXH3_state_t
*
statePtr
XXH64_hash_t
seed
)
;
XXH_PUBLIC_API
XXH_errorcode
XXH3_64bits_reset_withSecret
(
XXH3_state_t
*
statePtr
const
void
*
secret
size_t
secretSize
)
;
XXH_PUBLIC_API
XXH_errorcode
XXH3_64bits_update
(
XXH3_state_t
*
statePtr
const
void
*
input
size_t
length
)
;
XXH_PUBLIC_API
XXH64_hash_t
XXH3_64bits_digest
(
const
XXH3_state_t
*
statePtr
)
;
#
ifdef
XXH_NAMESPACE
#
define
XXH128
XXH_NAME2
(
XXH_NAMESPACE
XXH128
)
#
define
XXH3_128bits
XXH_NAME2
(
XXH_NAMESPACE
XXH3_128bits
)
#
define
XXH3_128bits_withSeed
XXH_NAME2
(
XXH_NAMESPACE
XXH3_128bits_withSeed
)
#
define
XXH3_128bits_withSecret
XXH_NAME2
(
XXH_NAMESPACE
XXH3_128bits_withSecret
)
#
define
XXH3_128bits_reset
XXH_NAME2
(
XXH_NAMESPACE
XXH3_128bits_reset
)
#
define
XXH3_128bits_reset_withSeed
XXH_NAME2
(
XXH_NAMESPACE
XXH3_128bits_reset_withSeed
)
#
define
XXH3_128bits_reset_withSecret
XXH_NAME2
(
XXH_NAMESPACE
XXH3_128bits_reset_withSecret
)
#
define
XXH3_128bits_update
XXH_NAME2
(
XXH_NAMESPACE
XXH3_128bits_update
)
#
define
XXH3_128bits_digest
XXH_NAME2
(
XXH_NAMESPACE
XXH3_128bits_digest
)
#
define
XXH128_isEqual
XXH_NAME2
(
XXH_NAMESPACE
XXH128_isEqual
)
#
define
XXH128_cmp
XXH_NAME2
(
XXH_NAMESPACE
XXH128_cmp
)
#
define
XXH128_canonicalFromHash
XXH_NAME2
(
XXH_NAMESPACE
XXH128_canonicalFromHash
)
#
define
XXH128_hashFromCanonical
XXH_NAME2
(
XXH_NAMESPACE
XXH128_hashFromCanonical
)
#
endif
typedef
struct
{
XXH64_hash_t
low64
;
XXH64_hash_t
high64
;
}
XXH128_hash_t
;
XXH_PUBLIC_API
XXH128_hash_t
XXH128
(
const
void
*
data
size_t
len
XXH64_hash_t
seed
)
;
XXH_PUBLIC_API
XXH128_hash_t
XXH3_128bits
(
const
void
*
data
size_t
len
)
;
XXH_PUBLIC_API
XXH128_hash_t
XXH3_128bits_withSeed
(
const
void
*
data
size_t
len
XXH64_hash_t
seed
)
;
XXH_PUBLIC_API
XXH128_hash_t
XXH3_128bits_withSecret
(
const
void
*
data
size_t
len
const
void
*
secret
size_t
secretSize
)
;
XXH_PUBLIC_API
XXH_errorcode
XXH3_128bits_reset
(
XXH3_state_t
*
statePtr
)
;
XXH_PUBLIC_API
XXH_errorcode
XXH3_128bits_reset_withSeed
(
XXH3_state_t
*
statePtr
XXH64_hash_t
seed
)
;
XXH_PUBLIC_API
XXH_errorcode
XXH3_128bits_reset_withSecret
(
XXH3_state_t
*
statePtr
const
void
*
secret
size_t
secretSize
)
;
XXH_PUBLIC_API
XXH_errorcode
XXH3_128bits_update
(
XXH3_state_t
*
statePtr
const
void
*
input
size_t
length
)
;
XXH_PUBLIC_API
XXH128_hash_t
XXH3_128bits_digest
(
const
XXH3_state_t
*
statePtr
)
;
XXH_PUBLIC_API
int
XXH128_isEqual
(
XXH128_hash_t
h1
XXH128_hash_t
h2
)
;
XXH_PUBLIC_API
int
XXH128_cmp
(
const
void
*
h128_1
const
void
*
h128_2
)
;
typedef
struct
{
unsigned
char
digest
[
16
]
;
}
XXH128_canonical_t
;
XXH_PUBLIC_API
void
XXH128_canonicalFromHash
(
XXH128_canonical_t
*
dst
XXH128_hash_t
hash
)
;
XXH_PUBLIC_API
XXH128_hash_t
XXH128_hashFromCanonical
(
const
XXH128_canonical_t
*
src
)
;
#
endif
#
if
defined
(
XXH_INLINE_ALL
)
|
|
defined
(
XXH_PRIVATE_API
)
#
define
XXH_IMPLEMENTATION
#
endif
#
endif
#
if
(
defined
(
XXH_INLINE_ALL
)
|
|
defined
(
XXH_PRIVATE_API
)
\
|
|
defined
(
XXH_IMPLEMENTATION
)
)
&
&
!
defined
(
XXH_IMPLEM_13a8737387
)
#
define
XXH_IMPLEM_13a8737387
#
ifndef
XXH_FORCE_MEMORY_ACCESS
#
if
!
defined
(
__clang__
)
&
&
defined
(
__GNUC__
)
&
&
defined
(
__ARM_FEATURE_UNALIGNED
)
&
&
defined
(
__ARM_ARCH
)
&
&
(
__ARM_ARCH
=
=
6
)
#
define
XXH_FORCE_MEMORY_ACCESS
2
#
elif
!
defined
(
__clang__
)
&
&
(
(
defined
(
__INTEL_COMPILER
)
&
&
!
defined
(
_WIN32
)
)
|
|
\
(
defined
(
__GNUC__
)
&
&
(
defined
(
__ARM_ARCH
)
&
&
__ARM_ARCH
>
=
7
)
)
)
#
define
XXH_FORCE_MEMORY_ACCESS
1
#
endif
#
endif
#
ifndef
XXH_ACCEPT_NULL_INPUT_POINTER
#
define
XXH_ACCEPT_NULL_INPUT_POINTER
0
#
endif
#
ifndef
XXH_FORCE_ALIGN_CHECK
#
if
defined
(
__i386
)
|
|
defined
(
_M_IX86
)
|
|
defined
(
__x86_64__
)
|
|
defined
(
_M_X64
)
#
define
XXH_FORCE_ALIGN_CHECK
0
#
else
#
define
XXH_FORCE_ALIGN_CHECK
1
#
endif
#
endif
#
ifndef
XXH_NO_INLINE_HINTS
#
if
defined
(
__OPTIMIZE_SIZE__
)
\
|
|
defined
(
__NO_INLINE__
)
#
define
XXH_NO_INLINE_HINTS
1
#
else
#
define
XXH_NO_INLINE_HINTS
0
#
endif
#
endif
#
ifndef
XXH_REROLL
#
if
defined
(
__OPTIMIZE_SIZE__
)
#
define
XXH_REROLL
1
#
else
#
define
XXH_REROLL
0
#
endif
#
endif
#
include
<
stdlib
.
h
>
static
void
*
XXH_malloc
(
size_t
s
)
{
return
malloc
(
s
)
;
}
static
void
XXH_free
(
void
*
p
)
{
free
(
p
)
;
}
#
include
<
string
.
h
>
static
void
*
XXH_memcpy
(
void
*
dest
const
void
*
src
size_t
size
)
{
return
memcpy
(
dest
src
size
)
;
}
#
include
<
limits
.
h
>
#
ifdef
_MSC_VER
#
pragma
warning
(
disable
:
4127
)
/
*
disable
:
C4127
:
conditional
expression
is
constant
*
/
#
endif
#
if
XXH_NO_INLINE_HINTS
#
define
XXH_FORCE_INLINE
static
#
define
XXH_NO_INLINE
static
#
elif
defined
(
_MSC_VER
)
#
define
XXH_FORCE_INLINE
static
__forceinline
#
define
XXH_NO_INLINE
static
__declspec
(
noinline
)
#
else
#
if
defined
(
__cplusplus
)
\
|
|
defined
(
__STDC_VERSION__
)
&
&
__STDC_VERSION__
>
=
199901L
#
ifdef
__GNUC__
#
define
XXH_FORCE_INLINE
static
inline
__attribute__
(
(
always_inline
)
)
#
define
XXH_NO_INLINE
static
__attribute__
(
(
noinline
)
)
#
else
#
define
XXH_FORCE_INLINE
static
inline
#
define
XXH_NO_INLINE
static
#
endif
#
else
#
define
XXH_FORCE_INLINE
static
#
define
XXH_NO_INLINE
static
#
endif
#
endif
#
ifndef
DEBUGLEVEL
#
define
DEBUGLEVEL
0
#
endif
#
if
(
DEBUGLEVEL
>
=
1
)
#
include
<
assert
.
h
>
#
define
XXH_ASSERT
(
c
)
assert
(
c
)
#
else
#
define
XXH_ASSERT
(
c
)
(
(
void
)
0
)
#
endif
#
define
XXH_STATIC_ASSERT
(
c
)
{
enum
{
XXH_sa
=
1
/
(
int
)
(
!
!
(
c
)
)
}
;
}
#
if
!
defined
(
__VMS
)
\
&
&
(
defined
(
__cplusplus
)
\
|
|
(
defined
(
__STDC_VERSION__
)
&
&
(
__STDC_VERSION__
>
=
199901L
)
)
)
#
include
<
stdint
.
h
>
typedef
uint8_t
xxh_u8
;
#
else
typedef
unsigned
char
xxh_u8
;
#
endif
typedef
XXH32_hash_t
xxh_u32
;
#
if
(
defined
(
XXH_FORCE_MEMORY_ACCESS
)
&
&
(
XXH_FORCE_MEMORY_ACCESS
=
=
3
)
)
#
elif
(
defined
(
XXH_FORCE_MEMORY_ACCESS
)
&
&
(
XXH_FORCE_MEMORY_ACCESS
=
=
2
)
)
static
xxh_u32
XXH_read32
(
const
void
*
memPtr
)
{
return
*
(
const
xxh_u32
*
)
memPtr
;
}
#
elif
(
defined
(
XXH_FORCE_MEMORY_ACCESS
)
&
&
(
XXH_FORCE_MEMORY_ACCESS
=
=
1
)
)
typedef
union
{
xxh_u32
u32
;
}
__attribute__
(
(
packed
)
)
unalign
;
static
xxh_u32
XXH_read32
(
const
void
*
ptr
)
{
return
(
(
const
unalign
*
)
ptr
)
-
>
u32
;
}
#
else
static
xxh_u32
XXH_read32
(
const
void
*
memPtr
)
{
xxh_u32
val
;
memcpy
(
&
val
memPtr
sizeof
(
val
)
)
;
return
val
;
}
#
endif
typedef
enum
{
XXH_bigEndian
=
0
XXH_littleEndian
=
1
}
XXH_endianess
;
#
ifndef
XXH_CPU_LITTLE_ENDIAN
#
if
defined
(
_WIN32
)
\
|
|
defined
(
__LITTLE_ENDIAN__
)
\
|
|
(
defined
(
__BYTE_ORDER__
)
&
&
__BYTE_ORDER__
=
=
__ORDER_LITTLE_ENDIAN__
)
#
define
XXH_CPU_LITTLE_ENDIAN
1
#
elif
defined
(
__BIG_ENDIAN__
)
\
|
|
(
defined
(
__BYTE_ORDER__
)
&
&
__BYTE_ORDER__
=
=
__ORDER_BIG_ENDIAN__
)
#
define
XXH_CPU_LITTLE_ENDIAN
0
#
else
static
int
XXH_isLittleEndian
(
void
)
{
const
union
{
xxh_u32
u
;
xxh_u8
c
[
4
]
;
}
one
=
{
1
}
;
return
one
.
c
[
0
]
;
}
#
define
XXH_CPU_LITTLE_ENDIAN
XXH_isLittleEndian
(
)
#
endif
#
endif
#
define
XXH_GCC_VERSION
(
__GNUC__
*
100
+
__GNUC_MINOR__
)
#
ifndef
__has_builtin
#
define
__has_builtin
(
x
)
0
#
endif
#
if
!
defined
(
NO_CLANG_BUILTIN
)
&
&
__has_builtin
(
__builtin_rotateleft32
)
\
&
&
__has_builtin
(
__builtin_rotateleft64
)
#
define
XXH_rotl32
__builtin_rotateleft32
#
define
XXH_rotl64
__builtin_rotateleft64
#
elif
defined
(
_MSC_VER
)
#
define
XXH_rotl32
(
x
r
)
_rotl
(
x
r
)
#
define
XXH_rotl64
(
x
r
)
_rotl64
(
x
r
)
#
else
#
define
XXH_rotl32
(
x
r
)
(
(
(
x
)
<
<
(
r
)
)
|
(
(
x
)
>
>
(
32
-
(
r
)
)
)
)
#
define
XXH_rotl64
(
x
r
)
(
(
(
x
)
<
<
(
r
)
)
|
(
(
x
)
>
>
(
64
-
(
r
)
)
)
)
#
endif
#
if
defined
(
_MSC_VER
)
#
define
XXH_swap32
_byteswap_ulong
#
elif
XXH_GCC_VERSION
>
=
403
#
define
XXH_swap32
__builtin_bswap32
#
else
static
xxh_u32
XXH_swap32
(
xxh_u32
x
)
{
return
(
(
x
<
<
24
)
&
0xff000000
)
|
(
(
x
<
<
8
)
&
0x00ff0000
)
|
(
(
x
>
>
8
)
&
0x0000ff00
)
|
(
(
x
>
>
24
)
&
0x000000ff
)
;
}
#
endif
typedef
enum
{
XXH_aligned
XXH_unaligned
}
XXH_alignment
;
#
if
(
defined
(
XXH_FORCE_MEMORY_ACCESS
)
&
&
(
XXH_FORCE_MEMORY_ACCESS
=
=
3
)
)
XXH_FORCE_INLINE
xxh_u32
XXH_readLE32
(
const
void
*
memPtr
)
{
const
xxh_u8
*
bytePtr
=
(
const
xxh_u8
*
)
memPtr
;
return
bytePtr
[
0
]
|
(
(
xxh_u32
)
bytePtr
[
1
]
<
<
8
)
|
(
(
xxh_u32
)
bytePtr
[
2
]
<
<
16
)
|
(
(
xxh_u32
)
bytePtr
[
3
]
<
<
24
)
;
}
XXH_FORCE_INLINE
xxh_u32
XXH_readBE32
(
const
void
*
memPtr
)
{
const
xxh_u8
*
bytePtr
=
(
const
xxh_u8
*
)
memPtr
;
return
bytePtr
[
3
]
|
(
(
xxh_u32
)
bytePtr
[
2
]
<
<
8
)
|
(
(
xxh_u32
)
bytePtr
[
1
]
<
<
16
)
|
(
(
xxh_u32
)
bytePtr
[
0
]
<
<
24
)
;
}
#
else
XXH_FORCE_INLINE
xxh_u32
XXH_readLE32
(
const
void
*
ptr
)
{
return
XXH_CPU_LITTLE_ENDIAN
?
XXH_read32
(
ptr
)
:
XXH_swap32
(
XXH_read32
(
ptr
)
)
;
}
static
xxh_u32
XXH_readBE32
(
const
void
*
ptr
)
{
return
XXH_CPU_LITTLE_ENDIAN
?
XXH_swap32
(
XXH_read32
(
ptr
)
)
:
XXH_read32
(
ptr
)
;
}
#
endif
XXH_FORCE_INLINE
xxh_u32
XXH_readLE32_align
(
const
void
*
ptr
XXH_alignment
align
)
{
if
(
align
=
=
XXH_unaligned
)
{
return
XXH_readLE32
(
ptr
)
;
}
else
{
return
XXH_CPU_LITTLE_ENDIAN
?
*
(
const
xxh_u32
*
)
ptr
:
XXH_swap32
(
*
(
const
xxh_u32
*
)
ptr
)
;
}
}
XXH_PUBLIC_API
unsigned
XXH_versionNumber
(
void
)
{
return
XXH_VERSION_NUMBER
;
}
static
const
xxh_u32
PRIME32_1
=
0x9E3779B1U
;
static
const
xxh_u32
PRIME32_2
=
0x85EBCA77U
;
static
const
xxh_u32
PRIME32_3
=
0xC2B2AE3DU
;
static
const
xxh_u32
PRIME32_4
=
0x27D4EB2FU
;
static
const
xxh_u32
PRIME32_5
=
0x165667B1U
;
static
xxh_u32
XXH32_round
(
xxh_u32
acc
xxh_u32
input
)
{
acc
+
=
input
*
PRIME32_2
;
acc
=
XXH_rotl32
(
acc
13
)
;
acc
*
=
PRIME32_1
;
#
if
defined
(
__GNUC__
)
&
&
defined
(
__SSE4_1__
)
&
&
!
defined
(
XXH_ENABLE_AUTOVECTORIZE
)
__asm__
(
"
"
:
"
+
r
"
(
acc
)
)
;
#
endif
return
acc
;
}
static
xxh_u32
XXH32_avalanche
(
xxh_u32
h32
)
{
h32
^
=
h32
>
>
15
;
h32
*
=
PRIME32_2
;
h32
^
=
h32
>
>
13
;
h32
*
=
PRIME32_3
;
h32
^
=
h32
>
>
16
;
return
(
h32
)
;
}
#
define
XXH_get32bits
(
p
)
XXH_readLE32_align
(
p
align
)
static
xxh_u32
XXH32_finalize
(
xxh_u32
h32
const
xxh_u8
*
ptr
size_t
len
XXH_alignment
align
)
{
#
define
PROCESS1
\
h32
+
=
(
*
ptr
+
+
)
*
PRIME32_5
;
\
h32
=
XXH_rotl32
(
h32
11
)
*
PRIME32_1
;
#
define
PROCESS4
\
h32
+
=
XXH_get32bits
(
ptr
)
*
PRIME32_3
;
\
ptr
+
=
4
;
\
h32
=
XXH_rotl32
(
h32
17
)
*
PRIME32_4
;
if
(
XXH_REROLL
)
{
len
&
=
15
;
while
(
len
>
=
4
)
{
PROCESS4
;
len
-
=
4
;
}
while
(
len
>
0
)
{
PROCESS1
;
-
-
len
;
}
return
XXH32_avalanche
(
h32
)
;
}
else
{
switch
(
len
&
15
)
{
case
12
:
PROCESS4
;
case
8
:
PROCESS4
;
case
4
:
PROCESS4
;
return
XXH32_avalanche
(
h32
)
;
case
13
:
PROCESS4
;
case
9
:
PROCESS4
;
case
5
:
PROCESS4
;
PROCESS1
;
return
XXH32_avalanche
(
h32
)
;
case
14
:
PROCESS4
;
case
10
:
PROCESS4
;
case
6
:
PROCESS4
;
PROCESS1
;
PROCESS1
;
return
XXH32_avalanche
(
h32
)
;
case
15
:
PROCESS4
;
case
11
:
PROCESS4
;
case
7
:
PROCESS4
;
case
3
:
PROCESS1
;
case
2
:
PROCESS1
;
case
1
:
PROCESS1
;
case
0
:
return
XXH32_avalanche
(
h32
)
;
}
XXH_ASSERT
(
0
)
;
return
h32
;
}
}
XXH_FORCE_INLINE
xxh_u32
XXH32_endian_align
(
const
xxh_u8
*
input
size_t
len
xxh_u32
seed
XXH_alignment
align
)
{
const
xxh_u8
*
bEnd
=
input
+
len
;
xxh_u32
h32
;
#
if
defined
(
XXH_ACCEPT_NULL_INPUT_POINTER
)
&
&
(
XXH_ACCEPT_NULL_INPUT_POINTER
>
=
1
)
if
(
input
=
=
NULL
)
{
len
=
0
;
bEnd
=
input
=
(
const
xxh_u8
*
)
(
size_t
)
16
;
}
#
endif
if
(
len
>
=
16
)
{
const
xxh_u8
*
const
limit
=
bEnd
-
15
;
xxh_u32
v1
=
seed
+
PRIME32_1
+
PRIME32_2
;
xxh_u32
v2
=
seed
+
PRIME32_2
;
xxh_u32
v3
=
seed
+
0
;
xxh_u32
v4
=
seed
-
PRIME32_1
;
do
{
v1
=
XXH32_round
(
v1
XXH_get32bits
(
input
)
)
;
input
+
=
4
;
v2
=
XXH32_round
(
v2
XXH_get32bits
(
input
)
)
;
input
+
=
4
;
v3
=
XXH32_round
(
v3
XXH_get32bits
(
input
)
)
;
input
+
=
4
;
v4
=
XXH32_round
(
v4
XXH_get32bits
(
input
)
)
;
input
+
=
4
;
}
while
(
input
<
limit
)
;
h32
=
XXH_rotl32
(
v1
1
)
+
XXH_rotl32
(
v2
7
)
+
XXH_rotl32
(
v3
12
)
+
XXH_rotl32
(
v4
18
)
;
}
else
{
h32
=
seed
+
PRIME32_5
;
}
h32
+
=
(
xxh_u32
)
len
;
return
XXH32_finalize
(
h32
input
len
&
15
align
)
;
}
XXH_PUBLIC_API
XXH32_hash_t
XXH32
(
const
void
*
input
size_t
len
XXH32_hash_t
seed
)
{
#
if
0
XXH32_state_t
state
;
XXH32_reset
(
&
state
seed
)
;
XXH32_update
(
&
state
(
const
xxh_u8
*
)
input
len
)
;
return
XXH32_digest
(
&
state
)
;
#
else
if
(
XXH_FORCE_ALIGN_CHECK
)
{
if
(
(
(
(
size_t
)
input
)
&
3
)
=
=
0
)
{
return
XXH32_endian_align
(
(
const
xxh_u8
*
)
input
len
seed
XXH_aligned
)
;
}
}
return
XXH32_endian_align
(
(
const
xxh_u8
*
)
input
len
seed
XXH_unaligned
)
;
#
endif
}
XXH_PUBLIC_API
XXH32_state_t
*
XXH32_createState
(
void
)
{
return
(
XXH32_state_t
*
)
XXH_malloc
(
sizeof
(
XXH32_state_t
)
)
;
}
XXH_PUBLIC_API
XXH_errorcode
XXH32_freeState
(
XXH32_state_t
*
statePtr
)
{
XXH_free
(
statePtr
)
;
return
XXH_OK
;
}
XXH_PUBLIC_API
void
XXH32_copyState
(
XXH32_state_t
*
dstState
const
XXH32_state_t
*
srcState
)
{
memcpy
(
dstState
srcState
sizeof
(
*
dstState
)
)
;
}
XXH_PUBLIC_API
XXH_errorcode
XXH32_reset
(
XXH32_state_t
*
statePtr
XXH32_hash_t
seed
)
{
XXH32_state_t
state
;
memset
(
&
state
0
sizeof
(
state
)
)
;
state
.
v1
=
seed
+
PRIME32_1
+
PRIME32_2
;
state
.
v2
=
seed
+
PRIME32_2
;
state
.
v3
=
seed
+
0
;
state
.
v4
=
seed
-
PRIME32_1
;
memcpy
(
statePtr
&
state
sizeof
(
state
)
-
sizeof
(
state
.
reserved
)
)
;
return
XXH_OK
;
}
XXH_PUBLIC_API
XXH_errorcode
XXH32_update
(
XXH32_state_t
*
state
const
void
*
input
size_t
len
)
{
if
(
input
=
=
NULL
)
#
if
defined
(
XXH_ACCEPT_NULL_INPUT_POINTER
)
&
&
(
XXH_ACCEPT_NULL_INPUT_POINTER
>
=
1
)
return
XXH_OK
;
#
else
return
XXH_ERROR
;
#
endif
{
const
xxh_u8
*
p
=
(
const
xxh_u8
*
)
input
;
const
xxh_u8
*
const
bEnd
=
p
+
len
;
state
-
>
total_len_32
+
=
(
XXH32_hash_t
)
len
;
state
-
>
large_len
|
=
(
XXH32_hash_t
)
(
(
len
>
=
16
)
|
(
state
-
>
total_len_32
>
=
16
)
)
;
if
(
state
-
>
memsize
+
len
<
16
)
{
XXH_memcpy
(
(
xxh_u8
*
)
(
state
-
>
mem32
)
+
state
-
>
memsize
input
len
)
;
state
-
>
memsize
+
=
(
XXH32_hash_t
)
len
;
return
XXH_OK
;
}
if
(
state
-
>
memsize
)
{
XXH_memcpy
(
(
xxh_u8
*
)
(
state
-
>
mem32
)
+
state
-
>
memsize
input
16
-
state
-
>
memsize
)
;
{
const
xxh_u32
*
p32
=
state
-
>
mem32
;
state
-
>
v1
=
XXH32_round
(
state
-
>
v1
XXH_readLE32
(
p32
)
)
;
p32
+
+
;
state
-
>
v2
=
XXH32_round
(
state
-
>
v2
XXH_readLE32
(
p32
)
)
;
p32
+
+
;
state
-
>
v3
=
XXH32_round
(
state
-
>
v3
XXH_readLE32
(
p32
)
)
;
p32
+
+
;
state
-
>
v4
=
XXH32_round
(
state
-
>
v4
XXH_readLE32
(
p32
)
)
;
}
p
+
=
16
-
state
-
>
memsize
;
state
-
>
memsize
=
0
;
}
if
(
p
<
=
bEnd
-
16
)
{
const
xxh_u8
*
const
limit
=
bEnd
-
16
;
xxh_u32
v1
=
state
-
>
v1
;
xxh_u32
v2
=
state
-
>
v2
;
xxh_u32
v3
=
state
-
>
v3
;
xxh_u32
v4
=
state
-
>
v4
;
do
{
v1
=
XXH32_round
(
v1
XXH_readLE32
(
p
)
)
;
p
+
=
4
;
v2
=
XXH32_round
(
v2
XXH_readLE32
(
p
)
)
;
p
+
=
4
;
v3
=
XXH32_round
(
v3
XXH_readLE32
(
p
)
)
;
p
+
=
4
;
v4
=
XXH32_round
(
v4
XXH_readLE32
(
p
)
)
;
p
+
=
4
;
}
while
(
p
<
=
limit
)
;
state
-
>
v1
=
v1
;
state
-
>
v2
=
v2
;
state
-
>
v3
=
v3
;
state
-
>
v4
=
v4
;
}
if
(
p
<
bEnd
)
{
XXH_memcpy
(
state
-
>
mem32
p
(
size_t
)
(
bEnd
-
p
)
)
;
state
-
>
memsize
=
(
unsigned
)
(
bEnd
-
p
)
;
}
}
return
XXH_OK
;
}
XXH_PUBLIC_API
XXH32_hash_t
XXH32_digest
(
const
XXH32_state_t
*
state
)
{
xxh_u32
h32
;
if
(
state
-
>
large_len
)
{
h32
=
XXH_rotl32
(
state
-
>
v1
1
)
+
XXH_rotl32
(
state
-
>
v2
7
)
+
XXH_rotl32
(
state
-
>
v3
12
)
+
XXH_rotl32
(
state
-
>
v4
18
)
;
}
else
{
h32
=
state
-
>
v3
+
PRIME32_5
;
}
h32
+
=
state
-
>
total_len_32
;
return
XXH32_finalize
(
h32
(
const
xxh_u8
*
)
state
-
>
mem32
state
-
>
memsize
XXH_aligned
)
;
}
XXH_PUBLIC_API
void
XXH32_canonicalFromHash
(
XXH32_canonical_t
*
dst
XXH32_hash_t
hash
)
{
XXH_STATIC_ASSERT
(
sizeof
(
XXH32_canonical_t
)
=
=
sizeof
(
XXH32_hash_t
)
)
;
if
(
XXH_CPU_LITTLE_ENDIAN
)
hash
=
XXH_swap32
(
hash
)
;
memcpy
(
dst
&
hash
sizeof
(
*
dst
)
)
;
}
XXH_PUBLIC_API
XXH32_hash_t
XXH32_hashFromCanonical
(
const
XXH32_canonical_t
*
src
)
{
return
XXH_readBE32
(
src
)
;
}
#
ifndef
XXH_NO_LONG_LONG
typedef
XXH64_hash_t
xxh_u64
;
#
ifndef
XXH_REROLL_XXH64
#
if
(
defined
(
__ILP32__
)
|
|
defined
(
_ILP32
)
)
\
|
|
!
(
defined
(
__x86_64__
)
|
|
defined
(
_M_X64
)
|
|
defined
(
_M_AMD64
)
\
|
|
defined
(
_M_ARM64
)
|
|
defined
(
__aarch64__
)
|
|
defined
(
__arm64__
)
\
|
|
defined
(
__PPC64__
)
|
|
defined
(
__PPC64LE__
)
|
|
defined
(
__ppc64__
)
|
|
defined
(
__powerpc64__
)
\
|
|
defined
(
__mips64__
)
|
|
defined
(
__mips64
)
)
\
|
|
(
!
defined
(
SIZE_MAX
)
|
|
SIZE_MAX
<
ULLONG_MAX
)
#
define
XXH_REROLL_XXH64
1
#
else
#
define
XXH_REROLL_XXH64
0
#
endif
#
endif
#
if
(
defined
(
XXH_FORCE_MEMORY_ACCESS
)
&
&
(
XXH_FORCE_MEMORY_ACCESS
=
=
3
)
)
#
elif
(
defined
(
XXH_FORCE_MEMORY_ACCESS
)
&
&
(
XXH_FORCE_MEMORY_ACCESS
=
=
2
)
)
static
xxh_u64
XXH_read64
(
const
void
*
memPtr
)
{
return
*
(
const
xxh_u64
*
)
memPtr
;
}
#
elif
(
defined
(
XXH_FORCE_MEMORY_ACCESS
)
&
&
(
XXH_FORCE_MEMORY_ACCESS
=
=
1
)
)
typedef
union
{
xxh_u32
u32
;
xxh_u64
u64
;
}
__attribute__
(
(
packed
)
)
unalign64
;
static
xxh_u64
XXH_read64
(
const
void
*
ptr
)
{
return
(
(
const
unalign64
*
)
ptr
)
-
>
u64
;
}
#
else
static
xxh_u64
XXH_read64
(
const
void
*
memPtr
)
{
xxh_u64
val
;
memcpy
(
&
val
memPtr
sizeof
(
val
)
)
;
return
val
;
}
#
endif
#
if
defined
(
_MSC_VER
)
#
define
XXH_swap64
_byteswap_uint64
#
elif
XXH_GCC_VERSION
>
=
403
#
define
XXH_swap64
__builtin_bswap64
#
else
static
xxh_u64
XXH_swap64
(
xxh_u64
x
)
{
return
(
(
x
<
<
56
)
&
0xff00000000000000ULL
)
|
(
(
x
<
<
40
)
&
0x00ff000000000000ULL
)
|
(
(
x
<
<
24
)
&
0x0000ff0000000000ULL
)
|
(
(
x
<
<
8
)
&
0x000000ff00000000ULL
)
|
(
(
x
>
>
8
)
&
0x00000000ff000000ULL
)
|
(
(
x
>
>
24
)
&
0x0000000000ff0000ULL
)
|
(
(
x
>
>
40
)
&
0x000000000000ff00ULL
)
|
(
(
x
>
>
56
)
&
0x00000000000000ffULL
)
;
}
#
endif
#
if
(
defined
(
XXH_FORCE_MEMORY_ACCESS
)
&
&
(
XXH_FORCE_MEMORY_ACCESS
=
=
3
)
)
XXH_FORCE_INLINE
xxh_u64
XXH_readLE64
(
const
void
*
memPtr
)
{
const
xxh_u8
*
bytePtr
=
(
const
xxh_u8
*
)
memPtr
;
return
bytePtr
[
0
]
|
(
(
xxh_u64
)
bytePtr
[
1
]
<
<
8
)
|
(
(
xxh_u64
)
bytePtr
[
2
]
<
<
16
)
|
(
(
xxh_u64
)
bytePtr
[
3
]
<
<
24
)
|
(
(
xxh_u64
)
bytePtr
[
4
]
<
<
32
)
|
(
(
xxh_u64
)
bytePtr
[
5
]
<
<
40
)
|
(
(
xxh_u64
)
bytePtr
[
6
]
<
<
48
)
|
(
(
xxh_u64
)
bytePtr
[
7
]
<
<
56
)
;
}
XXH_FORCE_INLINE
xxh_u64
XXH_readBE64
(
const
void
*
memPtr
)
{
const
xxh_u8
*
bytePtr
=
(
const
xxh_u8
*
)
memPtr
;
return
bytePtr
[
7
]
|
(
(
xxh_u64
)
bytePtr
[
6
]
<
<
8
)
|
(
(
xxh_u64
)
bytePtr
[
5
]
<
<
16
)
|
(
(
xxh_u64
)
bytePtr
[
4
]
<
<
24
)
|
(
(
xxh_u64
)
bytePtr
[
3
]
<
<
32
)
|
(
(
xxh_u64
)
bytePtr
[
2
]
<
<
40
)
|
(
(
xxh_u64
)
bytePtr
[
1
]
<
<
48
)
|
(
(
xxh_u64
)
bytePtr
[
0
]
<
<
56
)
;
}
#
else
XXH_FORCE_INLINE
xxh_u64
XXH_readLE64
(
const
void
*
ptr
)
{
return
XXH_CPU_LITTLE_ENDIAN
?
XXH_read64
(
ptr
)
:
XXH_swap64
(
XXH_read64
(
ptr
)
)
;
}
static
xxh_u64
XXH_readBE64
(
const
void
*
ptr
)
{
return
XXH_CPU_LITTLE_ENDIAN
?
XXH_swap64
(
XXH_read64
(
ptr
)
)
:
XXH_read64
(
ptr
)
;
}
#
endif
XXH_FORCE_INLINE
xxh_u64
XXH_readLE64_align
(
const
void
*
ptr
XXH_alignment
align
)
{
if
(
align
=
=
XXH_unaligned
)
return
XXH_readLE64
(
ptr
)
;
else
return
XXH_CPU_LITTLE_ENDIAN
?
*
(
const
xxh_u64
*
)
ptr
:
XXH_swap64
(
*
(
const
xxh_u64
*
)
ptr
)
;
}
static
const
xxh_u64
PRIME64_1
=
0x9E3779B185EBCA87ULL
;
static
const
xxh_u64
PRIME64_2
=
0xC2B2AE3D27D4EB4FULL
;
static
const
xxh_u64
PRIME64_3
=
0x165667B19E3779F9ULL
;
static
const
xxh_u64
PRIME64_4
=
0x85EBCA77C2B2AE63ULL
;
static
const
xxh_u64
PRIME64_5
=
0x27D4EB2F165667C5ULL
;
static
xxh_u64
XXH64_round
(
xxh_u64
acc
xxh_u64
input
)
{
acc
+
=
input
*
PRIME64_2
;
acc
=
XXH_rotl64
(
acc
31
)
;
acc
*
=
PRIME64_1
;
return
acc
;
}
static
xxh_u64
XXH64_mergeRound
(
xxh_u64
acc
xxh_u64
val
)
{
val
=
XXH64_round
(
0
val
)
;
acc
^
=
val
;
acc
=
acc
*
PRIME64_1
+
PRIME64_4
;
return
acc
;
}
static
xxh_u64
XXH64_avalanche
(
xxh_u64
h64
)
{
h64
^
=
h64
>
>
33
;
h64
*
=
PRIME64_2
;
h64
^
=
h64
>
>
29
;
h64
*
=
PRIME64_3
;
h64
^
=
h64
>
>
32
;
return
h64
;
}
#
define
XXH_get64bits
(
p
)
XXH_readLE64_align
(
p
align
)
static
xxh_u64
XXH64_finalize
(
xxh_u64
h64
const
xxh_u8
*
ptr
size_t
len
XXH_alignment
align
)
{
#
define
PROCESS1_64
\
h64
^
=
(
*
ptr
+
+
)
*
PRIME64_5
;
\
h64
=
XXH_rotl64
(
h64
11
)
*
PRIME64_1
;
#
define
PROCESS4_64
\
h64
^
=
(
xxh_u64
)
(
XXH_get32bits
(
ptr
)
)
*
PRIME64_1
;
\
ptr
+
=
4
;
\
h64
=
XXH_rotl64
(
h64
23
)
*
PRIME64_2
+
PRIME64_3
;
#
define
PROCESS8_64
{
\
xxh_u64
const
k1
=
XXH64_round
(
0
XXH_get64bits
(
ptr
)
)
;
\
ptr
+
=
8
;
\
h64
^
=
k1
;
\
h64
=
XXH_rotl64
(
h64
27
)
*
PRIME64_1
+
PRIME64_4
;
\
}
if
(
XXH_REROLL
|
|
XXH_REROLL_XXH64
)
{
len
&
=
31
;
while
(
len
>
=
8
)
{
PROCESS8_64
;
len
-
=
8
;
}
if
(
len
>
=
4
)
{
PROCESS4_64
;
len
-
=
4
;
}
while
(
len
>
0
)
{
PROCESS1_64
;
-
-
len
;
}
return
XXH64_avalanche
(
h64
)
;
}
else
{
switch
(
len
&
31
)
{
case
24
:
PROCESS8_64
;
case
16
:
PROCESS8_64
;
case
8
:
PROCESS8_64
;
return
XXH64_avalanche
(
h64
)
;
case
28
:
PROCESS8_64
;
case
20
:
PROCESS8_64
;
case
12
:
PROCESS8_64
;
case
4
:
PROCESS4_64
;
return
XXH64_avalanche
(
h64
)
;
case
25
:
PROCESS8_64
;
case
17
:
PROCESS8_64
;
case
9
:
PROCESS8_64
;
PROCESS1_64
;
return
XXH64_avalanche
(
h64
)
;
case
29
:
PROCESS8_64
;
case
21
:
PROCESS8_64
;
case
13
:
PROCESS8_64
;
case
5
:
PROCESS4_64
;
PROCESS1_64
;
return
XXH64_avalanche
(
h64
)
;
case
26
:
PROCESS8_64
;
case
18
:
PROCESS8_64
;
case
10
:
PROCESS8_64
;
PROCESS1_64
;
PROCESS1_64
;
return
XXH64_avalanche
(
h64
)
;
case
30
:
PROCESS8_64
;
case
22
:
PROCESS8_64
;
case
14
:
PROCESS8_64
;
case
6
:
PROCESS4_64
;
PROCESS1_64
;
PROCESS1_64
;
return
XXH64_avalanche
(
h64
)
;
case
27
:
PROCESS8_64
;
case
19
:
PROCESS8_64
;
case
11
:
PROCESS8_64
;
PROCESS1_64
;
PROCESS1_64
;
PROCESS1_64
;
return
XXH64_avalanche
(
h64
)
;
case
31
:
PROCESS8_64
;
case
23
:
PROCESS8_64
;
case
15
:
PROCESS8_64
;
case
7
:
PROCESS4_64
;
case
3
:
PROCESS1_64
;
case
2
:
PROCESS1_64
;
case
1
:
PROCESS1_64
;
case
0
:
return
XXH64_avalanche
(
h64
)
;
}
}
XXH_ASSERT
(
0
)
;
return
0
;
}
XXH_FORCE_INLINE
xxh_u64
XXH64_endian_align
(
const
xxh_u8
*
input
size_t
len
xxh_u64
seed
XXH_alignment
align
)
{
const
xxh_u8
*
bEnd
=
input
+
len
;
xxh_u64
h64
;
#
if
defined
(
XXH_ACCEPT_NULL_INPUT_POINTER
)
&
&
(
XXH_ACCEPT_NULL_INPUT_POINTER
>
=
1
)
if
(
input
=
=
NULL
)
{
len
=
0
;
bEnd
=
input
=
(
const
xxh_u8
*
)
(
size_t
)
32
;
}
#
endif
if
(
len
>
=
32
)
{
const
xxh_u8
*
const
limit
=
bEnd
-
32
;
xxh_u64
v1
=
seed
+
PRIME64_1
+
PRIME64_2
;
xxh_u64
v2
=
seed
+
PRIME64_2
;
xxh_u64
v3
=
seed
+
0
;
xxh_u64
v4
=
seed
-
PRIME64_1
;
do
{
v1
=
XXH64_round
(
v1
XXH_get64bits
(
input
)
)
;
input
+
=
8
;
v2
=
XXH64_round
(
v2
XXH_get64bits
(
input
)
)
;
input
+
=
8
;
v3
=
XXH64_round
(
v3
XXH_get64bits
(
input
)
)
;
input
+
=
8
;
v4
=
XXH64_round
(
v4
XXH_get64bits
(
input
)
)
;
input
+
=
8
;
}
while
(
input
<
=
limit
)
;
h64
=
XXH_rotl64
(
v1
1
)
+
XXH_rotl64
(
v2
7
)
+
XXH_rotl64
(
v3
12
)
+
XXH_rotl64
(
v4
18
)
;
h64
=
XXH64_mergeRound
(
h64
v1
)
;
h64
=
XXH64_mergeRound
(
h64
v2
)
;
h64
=
XXH64_mergeRound
(
h64
v3
)
;
h64
=
XXH64_mergeRound
(
h64
v4
)
;
}
else
{
h64
=
seed
+
PRIME64_5
;
}
h64
+
=
(
xxh_u64
)
len
;
return
XXH64_finalize
(
h64
input
len
align
)
;
}
XXH_PUBLIC_API
XXH64_hash_t
XXH64
(
const
void
*
input
size_t
len
XXH64_hash_t
seed
)
{
#
if
0
XXH64_state_t
state
;
XXH64_reset
(
&
state
seed
)
;
XXH64_update
(
&
state
(
const
xxh_u8
*
)
input
len
)
;
return
XXH64_digest
(
&
state
)
;
#
else
if
(
XXH_FORCE_ALIGN_CHECK
)
{
if
(
(
(
(
size_t
)
input
)
&
7
)
=
=
0
)
{
return
XXH64_endian_align
(
(
const
xxh_u8
*
)
input
len
seed
XXH_aligned
)
;
}
}
return
XXH64_endian_align
(
(
const
xxh_u8
*
)
input
len
seed
XXH_unaligned
)
;
#
endif
}
XXH_PUBLIC_API
XXH64_state_t
*
XXH64_createState
(
void
)
{
return
(
XXH64_state_t
*
)
XXH_malloc
(
sizeof
(
XXH64_state_t
)
)
;
}
XXH_PUBLIC_API
XXH_errorcode
XXH64_freeState
(
XXH64_state_t
*
statePtr
)
{
XXH_free
(
statePtr
)
;
return
XXH_OK
;
}
XXH_PUBLIC_API
void
XXH64_copyState
(
XXH64_state_t
*
dstState
const
XXH64_state_t
*
srcState
)
{
memcpy
(
dstState
srcState
sizeof
(
*
dstState
)
)
;
}
XXH_PUBLIC_API
XXH_errorcode
XXH64_reset
(
XXH64_state_t
*
statePtr
XXH64_hash_t
seed
)
{
XXH64_state_t
state
;
memset
(
&
state
0
sizeof
(
state
)
)
;
state
.
v1
=
seed
+
PRIME64_1
+
PRIME64_2
;
state
.
v2
=
seed
+
PRIME64_2
;
state
.
v3
=
seed
+
0
;
state
.
v4
=
seed
-
PRIME64_1
;
memcpy
(
statePtr
&
state
sizeof
(
state
)
-
sizeof
(
state
.
reserved64
)
)
;
return
XXH_OK
;
}
XXH_PUBLIC_API
XXH_errorcode
XXH64_update
(
XXH64_state_t
*
state
const
void
*
input
size_t
len
)
{
if
(
input
=
=
NULL
)
#
if
defined
(
XXH_ACCEPT_NULL_INPUT_POINTER
)
&
&
(
XXH_ACCEPT_NULL_INPUT_POINTER
>
=
1
)
return
XXH_OK
;
#
else
return
XXH_ERROR
;
#
endif
{
const
xxh_u8
*
p
=
(
const
xxh_u8
*
)
input
;
const
xxh_u8
*
const
bEnd
=
p
+
len
;
state
-
>
total_len
+
=
len
;
if
(
state
-
>
memsize
+
len
<
32
)
{
XXH_memcpy
(
(
(
xxh_u8
*
)
state
-
>
mem64
)
+
state
-
>
memsize
input
len
)
;
state
-
>
memsize
+
=
(
xxh_u32
)
len
;
return
XXH_OK
;
}
if
(
state
-
>
memsize
)
{
XXH_memcpy
(
(
(
xxh_u8
*
)
state
-
>
mem64
)
+
state
-
>
memsize
input
32
-
state
-
>
memsize
)
;
state
-
>
v1
=
XXH64_round
(
state
-
>
v1
XXH_readLE64
(
state
-
>
mem64
+
0
)
)
;
state
-
>
v2
=
XXH64_round
(
state
-
>
v2
XXH_readLE64
(
state
-
>
mem64
+
1
)
)
;
state
-
>
v3
=
XXH64_round
(
state
-
>
v3
XXH_readLE64
(
state
-
>
mem64
+
2
)
)
;
state
-
>
v4
=
XXH64_round
(
state
-
>
v4
XXH_readLE64
(
state
-
>
mem64
+
3
)
)
;
p
+
=
32
-
state
-
>
memsize
;
state
-
>
memsize
=
0
;
}
if
(
p
+
32
<
=
bEnd
)
{
const
xxh_u8
*
const
limit
=
bEnd
-
32
;
xxh_u64
v1
=
state
-
>
v1
;
xxh_u64
v2
=
state
-
>
v2
;
xxh_u64
v3
=
state
-
>
v3
;
xxh_u64
v4
=
state
-
>
v4
;
do
{
v1
=
XXH64_round
(
v1
XXH_readLE64
(
p
)
)
;
p
+
=
8
;
v2
=
XXH64_round
(
v2
XXH_readLE64
(
p
)
)
;
p
+
=
8
;
v3
=
XXH64_round
(
v3
XXH_readLE64
(
p
)
)
;
p
+
=
8
;
v4
=
XXH64_round
(
v4
XXH_readLE64
(
p
)
)
;
p
+
=
8
;
}
while
(
p
<
=
limit
)
;
state
-
>
v1
=
v1
;
state
-
>
v2
=
v2
;
state
-
>
v3
=
v3
;
state
-
>
v4
=
v4
;
}
if
(
p
<
bEnd
)
{
XXH_memcpy
(
state
-
>
mem64
p
(
size_t
)
(
bEnd
-
p
)
)
;
state
-
>
memsize
=
(
unsigned
)
(
bEnd
-
p
)
;
}
}
return
XXH_OK
;
}
XXH_PUBLIC_API
XXH64_hash_t
XXH64_digest
(
const
XXH64_state_t
*
state
)
{
xxh_u64
h64
;
if
(
state
-
>
total_len
>
=
32
)
{
xxh_u64
const
v1
=
state
-
>
v1
;
xxh_u64
const
v2
=
state
-
>
v2
;
xxh_u64
const
v3
=
state
-
>
v3
;
xxh_u64
const
v4
=
state
-
>
v4
;
h64
=
XXH_rotl64
(
v1
1
)
+
XXH_rotl64
(
v2
7
)
+
XXH_rotl64
(
v3
12
)
+
XXH_rotl64
(
v4
18
)
;
h64
=
XXH64_mergeRound
(
h64
v1
)
;
h64
=
XXH64_mergeRound
(
h64
v2
)
;
h64
=
XXH64_mergeRound
(
h64
v3
)
;
h64
=
XXH64_mergeRound
(
h64
v4
)
;
}
else
{
h64
=
state
-
>
v3
+
PRIME64_5
;
}
h64
+
=
(
xxh_u64
)
state
-
>
total_len
;
return
XXH64_finalize
(
h64
(
const
xxh_u8
*
)
state
-
>
mem64
(
size_t
)
state
-
>
total_len
XXH_aligned
)
;
}
XXH_PUBLIC_API
void
XXH64_canonicalFromHash
(
XXH64_canonical_t
*
dst
XXH64_hash_t
hash
)
{
XXH_STATIC_ASSERT
(
sizeof
(
XXH64_canonical_t
)
=
=
sizeof
(
XXH64_hash_t
)
)
;
if
(
XXH_CPU_LITTLE_ENDIAN
)
hash
=
XXH_swap64
(
hash
)
;
memcpy
(
dst
&
hash
sizeof
(
*
dst
)
)
;
}
XXH_PUBLIC_API
XXH64_hash_t
XXH64_hashFromCanonical
(
const
XXH64_canonical_t
*
src
)
{
return
XXH_readBE64
(
src
)
;
}
#
include
"
xxh3
.
h
"
#
endif
#
endif
#
if
defined
(
__cplusplus
)
}
#
endif
