#
if
defined
(
__cplusplus
)
extern
"
C
"
{
#
endif
#
if
(
defined
(
XXH_INLINE_ALL
)
|
|
defined
(
XXH_PRIVATE_API
)
)
\
&
&
!
defined
(
XXH_INLINE_ALL_31684351384
)
#
define
XXH_INLINE_ALL_31684351384
#
undef
XXH_STATIC_LINKING_ONLY
/
*
avoid
macro
redef
*
/
#
define
XXH_STATIC_LINKING_ONLY
#
undef
XXH_PUBLIC_API
#
if
defined
(
__GNUC__
)
#
define
XXH_PUBLIC_API
static
__inline
__attribute__
(
(
unused
)
)
#
elif
defined
(
__cplusplus
)
|
|
(
defined
(
__STDC_VERSION__
)
&
&
(
__STDC_VERSION__
>
=
199901L
)
)
#
define
XXH_PUBLIC_API
static
inline
#
elif
defined
(
_MSC_VER
)
#
define
XXH_PUBLIC_API
static
__inline
#
else
#
define
XXH_PUBLIC_API
static
#
endif
#
ifdef
XXH_NAMESPACE
#
error
"
XXH_INLINE_ALL
with
XXH_NAMESPACE
is
not
supported
"
#
endif
#
define
XXH_NAMESPACE
XXH_INLINE_
#
define
XXH_IPREF
(
Id
)
XXH_INLINE_
#
#
Id
#
define
XXH_OK
XXH_IPREF
(
XXH_OK
)
#
define
XXH_ERROR
XXH_IPREF
(
XXH_ERROR
)
#
define
XXH_errorcode
XXH_IPREF
(
XXH_errorcode
)
#
define
XXH32_canonical_t
XXH_IPREF
(
XXH32_canonical_t
)
#
define
XXH64_canonical_t
XXH_IPREF
(
XXH64_canonical_t
)
#
define
XXH128_canonical_t
XXH_IPREF
(
XXH128_canonical_t
)
#
define
XXH32_state_s
XXH_IPREF
(
XXH32_state_s
)
#
define
XXH32_state_t
XXH_IPREF
(
XXH32_state_t
)
#
define
XXH64_state_s
XXH_IPREF
(
XXH64_state_s
)
#
define
XXH64_state_t
XXH_IPREF
(
XXH64_state_t
)
#
define
XXH3_state_s
XXH_IPREF
(
XXH3_state_s
)
#
define
XXH3_state_t
XXH_IPREF
(
XXH3_state_t
)
#
define
XXH128_hash_t
XXH_IPREF
(
XXH128_hash_t
)
#
undef
XXHASH_H_5627135585666179
#
undef
XXHASH_H_STATIC_13879238742
#
endif
#
ifndef
XXHASH_H_5627135585666179
#
define
XXHASH_H_5627135585666179
1
#
if
!
defined
(
XXH_INLINE_ALL
)
&
&
!
defined
(
XXH_PRIVATE_API
)
#
if
defined
(
WIN32
)
&
&
defined
(
_MSC_VER
)
&
&
(
defined
(
XXH_IMPORT
)
|
|
defined
(
XXH_EXPORT
)
)
#
ifdef
XXH_EXPORT
#
define
XXH_PUBLIC_API
__declspec
(
dllexport
)
#
elif
XXH_IMPORT
#
define
XXH_PUBLIC_API
__declspec
(
dllimport
)
#
endif
#
else
#
define
XXH_PUBLIC_API
#
endif
#
endif
#
ifdef
XXH_NAMESPACE
#
define
XXH_CAT
(
A
B
)
A
#
#
B
#
define
XXH_NAME2
(
A
B
)
XXH_CAT
(
A
B
)
#
define
XXH_versionNumber
XXH_NAME2
(
XXH_NAMESPACE
XXH_versionNumber
)
#
define
XXH32
XXH_NAME2
(
XXH_NAMESPACE
XXH32
)
#
define
XXH32_createState
XXH_NAME2
(
XXH_NAMESPACE
XXH32_createState
)
#
define
XXH32_freeState
XXH_NAME2
(
XXH_NAMESPACE
XXH32_freeState
)
#
define
XXH32_reset
XXH_NAME2
(
XXH_NAMESPACE
XXH32_reset
)
#
define
XXH32_update
XXH_NAME2
(
XXH_NAMESPACE
XXH32_update
)
#
define
XXH32_digest
XXH_NAME2
(
XXH_NAMESPACE
XXH32_digest
)
#
define
XXH32_copyState
XXH_NAME2
(
XXH_NAMESPACE
XXH32_copyState
)
#
define
XXH32_canonicalFromHash
XXH_NAME2
(
XXH_NAMESPACE
XXH32_canonicalFromHash
)
#
define
XXH32_hashFromCanonical
XXH_NAME2
(
XXH_NAMESPACE
XXH32_hashFromCanonical
)
#
define
XXH64
XXH_NAME2
(
XXH_NAMESPACE
XXH64
)
#
define
XXH64_createState
XXH_NAME2
(
XXH_NAMESPACE
XXH64_createState
)
#
define
XXH64_freeState
XXH_NAME2
(
XXH_NAMESPACE
XXH64_freeState
)
#
define
XXH64_reset
XXH_NAME2
(
XXH_NAMESPACE
XXH64_reset
)
#
define
XXH64_update
XXH_NAME2
(
XXH_NAMESPACE
XXH64_update
)
#
define
XXH64_digest
XXH_NAME2
(
XXH_NAMESPACE
XXH64_digest
)
#
define
XXH64_copyState
XXH_NAME2
(
XXH_NAMESPACE
XXH64_copyState
)
#
define
XXH64_canonicalFromHash
XXH_NAME2
(
XXH_NAMESPACE
XXH64_canonicalFromHash
)
#
define
XXH64_hashFromCanonical
XXH_NAME2
(
XXH_NAMESPACE
XXH64_hashFromCanonical
)
#
define
XXH3_64bits
XXH_NAME2
(
XXH_NAMESPACE
XXH3_64bits
)
#
define
XXH3_64bits_withSecret
XXH_NAME2
(
XXH_NAMESPACE
XXH3_64bits_withSecret
)
#
define
XXH3_64bits_withSeed
XXH_NAME2
(
XXH_NAMESPACE
XXH3_64bits_withSeed
)
#
define
XXH3_createState
XXH_NAME2
(
XXH_NAMESPACE
XXH3_createState
)
#
define
XXH3_freeState
XXH_NAME2
(
XXH_NAMESPACE
XXH3_freeState
)
#
define
XXH3_copyState
XXH_NAME2
(
XXH_NAMESPACE
XXH3_copyState
)
#
define
XXH3_64bits_reset
XXH_NAME2
(
XXH_NAMESPACE
XXH3_64bits_reset
)
#
define
XXH3_64bits_reset_withSeed
XXH_NAME2
(
XXH_NAMESPACE
XXH3_64bits_reset_withSeed
)
#
define
XXH3_64bits_reset_withSecret
XXH_NAME2
(
XXH_NAMESPACE
XXH3_64bits_reset_withSecret
)
#
define
XXH3_64bits_update
XXH_NAME2
(
XXH_NAMESPACE
XXH3_64bits_update
)
#
define
XXH3_64bits_digest
XXH_NAME2
(
XXH_NAMESPACE
XXH3_64bits_digest
)
#
define
XXH3_generateSecret
XXH_NAME2
(
XXH_NAMESPACE
XXH3_generateSecret
)
#
define
XXH128
XXH_NAME2
(
XXH_NAMESPACE
XXH128
)
#
define
XXH3_128bits
XXH_NAME2
(
XXH_NAMESPACE
XXH3_128bits
)
#
define
XXH3_128bits_withSeed
XXH_NAME2
(
XXH_NAMESPACE
XXH3_128bits_withSeed
)
#
define
XXH3_128bits_withSecret
XXH_NAME2
(
XXH_NAMESPACE
XXH3_128bits_withSecret
)
#
define
XXH3_128bits_reset
XXH_NAME2
(
XXH_NAMESPACE
XXH3_128bits_reset
)
#
define
XXH3_128bits_reset_withSeed
XXH_NAME2
(
XXH_NAMESPACE
XXH3_128bits_reset_withSeed
)
#
define
XXH3_128bits_reset_withSecret
XXH_NAME2
(
XXH_NAMESPACE
XXH3_128bits_reset_withSecret
)
#
define
XXH3_128bits_update
XXH_NAME2
(
XXH_NAMESPACE
XXH3_128bits_update
)
#
define
XXH3_128bits_digest
XXH_NAME2
(
XXH_NAMESPACE
XXH3_128bits_digest
)
#
define
XXH128_isEqual
XXH_NAME2
(
XXH_NAMESPACE
XXH128_isEqual
)
#
define
XXH128_cmp
XXH_NAME2
(
XXH_NAMESPACE
XXH128_cmp
)
#
define
XXH128_canonicalFromHash
XXH_NAME2
(
XXH_NAMESPACE
XXH128_canonicalFromHash
)
#
define
XXH128_hashFromCanonical
XXH_NAME2
(
XXH_NAMESPACE
XXH128_hashFromCanonical
)
#
endif
#
define
XXH_VERSION_MAJOR
0
#
define
XXH_VERSION_MINOR
8
#
define
XXH_VERSION_RELEASE
0
#
define
XXH_VERSION_NUMBER
(
XXH_VERSION_MAJOR
*
100
*
100
+
XXH_VERSION_MINOR
*
100
+
XXH_VERSION_RELEASE
)
XXH_PUBLIC_API
unsigned
XXH_versionNumber
(
void
)
;
#
include
<
stddef
.
h
>
typedef
enum
{
XXH_OK
=
0
XXH_ERROR
}
XXH_errorcode
;
#
if
!
defined
(
__VMS
)
\
&
&
(
defined
(
__cplusplus
)
\
|
|
(
defined
(
__STDC_VERSION__
)
&
&
(
__STDC_VERSION__
>
=
199901L
)
)
)
#
include
<
stdint
.
h
>
typedef
uint32_t
XXH32_hash_t
;
#
else
#
include
<
limits
.
h
>
#
if
UINT_MAX
=
=
0xFFFFFFFFUL
typedef
unsigned
int
XXH32_hash_t
;
#
else
#
if
ULONG_MAX
=
=
0xFFFFFFFFUL
typedef
unsigned
long
XXH32_hash_t
;
#
else
#
error
"
unsupported
platform
:
need
a
32
-
bit
type
"
#
endif
#
endif
#
endif
XXH_PUBLIC_API
XXH32_hash_t
XXH32
(
const
void
*
input
size_t
length
XXH32_hash_t
seed
)
;
typedef
struct
XXH32_state_s
XXH32_state_t
;
XXH_PUBLIC_API
XXH32_state_t
*
XXH32_createState
(
void
)
;
XXH_PUBLIC_API
XXH_errorcode
XXH32_freeState
(
XXH32_state_t
*
statePtr
)
;
XXH_PUBLIC_API
void
XXH32_copyState
(
XXH32_state_t
*
dst_state
const
XXH32_state_t
*
src_state
)
;
XXH_PUBLIC_API
XXH_errorcode
XXH32_reset
(
XXH32_state_t
*
statePtr
XXH32_hash_t
seed
)
;
XXH_PUBLIC_API
XXH_errorcode
XXH32_update
(
XXH32_state_t
*
statePtr
const
void
*
input
size_t
length
)
;
XXH_PUBLIC_API
XXH32_hash_t
XXH32_digest
(
const
XXH32_state_t
*
statePtr
)
;
typedef
struct
{
unsigned
char
digest
[
4
]
;
}
XXH32_canonical_t
;
XXH_PUBLIC_API
void
XXH32_canonicalFromHash
(
XXH32_canonical_t
*
dst
XXH32_hash_t
hash
)
;
XXH_PUBLIC_API
XXH32_hash_t
XXH32_hashFromCanonical
(
const
XXH32_canonical_t
*
src
)
;
#
ifndef
XXH_NO_LONG_LONG
#
if
!
defined
(
__VMS
)
\
&
&
(
defined
(
__cplusplus
)
\
|
|
(
defined
(
__STDC_VERSION__
)
&
&
(
__STDC_VERSION__
>
=
199901L
)
)
)
#
include
<
stdint
.
h
>
typedef
uint64_t
XXH64_hash_t
;
#
else
typedef
unsigned
long
long
XXH64_hash_t
;
#
endif
XXH_PUBLIC_API
XXH64_hash_t
XXH64
(
const
void
*
input
size_t
length
XXH64_hash_t
seed
)
;
typedef
struct
XXH64_state_s
XXH64_state_t
;
XXH_PUBLIC_API
XXH64_state_t
*
XXH64_createState
(
void
)
;
XXH_PUBLIC_API
XXH_errorcode
XXH64_freeState
(
XXH64_state_t
*
statePtr
)
;
XXH_PUBLIC_API
void
XXH64_copyState
(
XXH64_state_t
*
dst_state
const
XXH64_state_t
*
src_state
)
;
XXH_PUBLIC_API
XXH_errorcode
XXH64_reset
(
XXH64_state_t
*
statePtr
XXH64_hash_t
seed
)
;
XXH_PUBLIC_API
XXH_errorcode
XXH64_update
(
XXH64_state_t
*
statePtr
const
void
*
input
size_t
length
)
;
XXH_PUBLIC_API
XXH64_hash_t
XXH64_digest
(
const
XXH64_state_t
*
statePtr
)
;
typedef
struct
{
unsigned
char
digest
[
sizeof
(
XXH64_hash_t
)
]
;
}
XXH64_canonical_t
;
XXH_PUBLIC_API
void
XXH64_canonicalFromHash
(
XXH64_canonical_t
*
dst
XXH64_hash_t
hash
)
;
XXH_PUBLIC_API
XXH64_hash_t
XXH64_hashFromCanonical
(
const
XXH64_canonical_t
*
src
)
;
XXH_PUBLIC_API
XXH64_hash_t
XXH3_64bits
(
const
void
*
data
size_t
len
)
;
XXH_PUBLIC_API
XXH64_hash_t
XXH3_64bits_withSeed
(
const
void
*
data
size_t
len
XXH64_hash_t
seed
)
;
#
define
XXH3_SECRET_SIZE_MIN
136
XXH_PUBLIC_API
XXH64_hash_t
XXH3_64bits_withSecret
(
const
void
*
data
size_t
len
const
void
*
secret
size_t
secretSize
)
;
typedef
struct
XXH3_state_s
XXH3_state_t
;
XXH_PUBLIC_API
XXH3_state_t
*
XXH3_createState
(
void
)
;
XXH_PUBLIC_API
XXH_errorcode
XXH3_freeState
(
XXH3_state_t
*
statePtr
)
;
XXH_PUBLIC_API
void
XXH3_copyState
(
XXH3_state_t
*
dst_state
const
XXH3_state_t
*
src_state
)
;
XXH_PUBLIC_API
XXH_errorcode
XXH3_64bits_reset
(
XXH3_state_t
*
statePtr
)
;
XXH_PUBLIC_API
XXH_errorcode
XXH3_64bits_reset_withSeed
(
XXH3_state_t
*
statePtr
XXH64_hash_t
seed
)
;
XXH_PUBLIC_API
XXH_errorcode
XXH3_64bits_reset_withSecret
(
XXH3_state_t
*
statePtr
const
void
*
secret
size_t
secretSize
)
;
XXH_PUBLIC_API
XXH_errorcode
XXH3_64bits_update
(
XXH3_state_t
*
statePtr
const
void
*
input
size_t
length
)
;
XXH_PUBLIC_API
XXH64_hash_t
XXH3_64bits_digest
(
const
XXH3_state_t
*
statePtr
)
;
typedef
struct
{
XXH64_hash_t
low64
;
XXH64_hash_t
high64
;
}
XXH128_hash_t
;
XXH_PUBLIC_API
XXH128_hash_t
XXH3_128bits
(
const
void
*
data
size_t
len
)
;
XXH_PUBLIC_API
XXH128_hash_t
XXH3_128bits_withSeed
(
const
void
*
data
size_t
len
XXH64_hash_t
seed
)
;
XXH_PUBLIC_API
XXH128_hash_t
XXH3_128bits_withSecret
(
const
void
*
data
size_t
len
const
void
*
secret
size_t
secretSize
)
;
XXH_PUBLIC_API
XXH_errorcode
XXH3_128bits_reset
(
XXH3_state_t
*
statePtr
)
;
XXH_PUBLIC_API
XXH_errorcode
XXH3_128bits_reset_withSeed
(
XXH3_state_t
*
statePtr
XXH64_hash_t
seed
)
;
XXH_PUBLIC_API
XXH_errorcode
XXH3_128bits_reset_withSecret
(
XXH3_state_t
*
statePtr
const
void
*
secret
size_t
secretSize
)
;
XXH_PUBLIC_API
XXH_errorcode
XXH3_128bits_update
(
XXH3_state_t
*
statePtr
const
void
*
input
size_t
length
)
;
XXH_PUBLIC_API
XXH128_hash_t
XXH3_128bits_digest
(
const
XXH3_state_t
*
statePtr
)
;
XXH_PUBLIC_API
int
XXH128_isEqual
(
XXH128_hash_t
h1
XXH128_hash_t
h2
)
;
XXH_PUBLIC_API
int
XXH128_cmp
(
const
void
*
h128_1
const
void
*
h128_2
)
;
typedef
struct
{
unsigned
char
digest
[
sizeof
(
XXH128_hash_t
)
]
;
}
XXH128_canonical_t
;
XXH_PUBLIC_API
void
XXH128_canonicalFromHash
(
XXH128_canonical_t
*
dst
XXH128_hash_t
hash
)
;
XXH_PUBLIC_API
XXH128_hash_t
XXH128_hashFromCanonical
(
const
XXH128_canonical_t
*
src
)
;
#
endif
#
endif
#
if
defined
(
XXH_STATIC_LINKING_ONLY
)
&
&
!
defined
(
XXHASH_H_STATIC_13879238742
)
#
define
XXHASH_H_STATIC_13879238742
struct
XXH32_state_s
{
XXH32_hash_t
total_len_32
;
XXH32_hash_t
large_len
;
XXH32_hash_t
v1
;
XXH32_hash_t
v2
;
XXH32_hash_t
v3
;
XXH32_hash_t
v4
;
XXH32_hash_t
mem32
[
4
]
;
XXH32_hash_t
memsize
;
XXH32_hash_t
reserved
;
}
;
#
ifndef
XXH_NO_LONG_LONG
struct
XXH64_state_s
{
XXH64_hash_t
total_len
;
XXH64_hash_t
v1
;
XXH64_hash_t
v2
;
XXH64_hash_t
v3
;
XXH64_hash_t
v4
;
XXH64_hash_t
mem64
[
4
]
;
XXH32_hash_t
memsize
;
XXH32_hash_t
reserved32
;
XXH64_hash_t
reserved64
;
}
;
#
if
defined
(
__STDC_VERSION__
)
&
&
(
__STDC_VERSION__
>
=
201112L
)
#
include
<
stdalign
.
h
>
#
define
XXH_ALIGN
(
n
)
alignas
(
n
)
#
elif
defined
(
__GNUC__
)
#
define
XXH_ALIGN
(
n
)
__attribute__
(
(
aligned
(
n
)
)
)
#
elif
defined
(
_MSC_VER
)
#
define
XXH_ALIGN
(
n
)
__declspec
(
align
(
n
)
)
#
else
#
define
XXH_ALIGN
(
n
)
#
endif
#
if
!
(
defined
(
__STDC_VERSION__
)
&
&
(
__STDC_VERSION__
>
=
201112L
)
)
\
&
&
defined
(
__GNUC__
)
#
define
XXH_ALIGN_MEMBER
(
align
type
)
type
XXH_ALIGN
(
align
)
#
else
#
define
XXH_ALIGN_MEMBER
(
align
type
)
XXH_ALIGN
(
align
)
type
#
endif
#
define
XXH3_INTERNALBUFFER_SIZE
256
#
define
XXH3_SECRET_DEFAULT_SIZE
192
struct
XXH3_state_s
{
XXH_ALIGN_MEMBER
(
64
XXH64_hash_t
acc
[
8
]
)
;
XXH_ALIGN_MEMBER
(
64
unsigned
char
customSecret
[
XXH3_SECRET_DEFAULT_SIZE
]
)
;
XXH_ALIGN_MEMBER
(
64
unsigned
char
buffer
[
XXH3_INTERNALBUFFER_SIZE
]
)
;
XXH32_hash_t
bufferedSize
;
XXH32_hash_t
reserved32
;
size_t
nbStripesSoFar
;
XXH64_hash_t
totalLen
;
size_t
nbStripesPerBlock
;
size_t
secretLimit
;
XXH64_hash_t
seed
;
XXH64_hash_t
reserved64
;
const
unsigned
char
*
extSecret
;
}
;
#
undef
XXH_ALIGN_MEMBER
#
define
XXH3_INITSTATE
(
XXH3_state_ptr
)
{
(
XXH3_state_ptr
)
-
>
seed
=
0
;
}
XXH_PUBLIC_API
void
XXH3_generateSecret
(
void
*
secretBuffer
const
void
*
customSeed
size_t
customSeedSize
)
;
XXH_PUBLIC_API
XXH128_hash_t
XXH128
(
const
void
*
data
size_t
len
XXH64_hash_t
seed
)
;
#
endif
#
if
defined
(
XXH_INLINE_ALL
)
|
|
defined
(
XXH_PRIVATE_API
)
#
define
XXH_IMPLEMENTATION
#
endif
#
endif
#
if
(
defined
(
XXH_INLINE_ALL
)
|
|
defined
(
XXH_PRIVATE_API
)
\
|
|
defined
(
XXH_IMPLEMENTATION
)
)
&
&
!
defined
(
XXH_IMPLEM_13a8737387
)
#
define
XXH_IMPLEM_13a8737387
#
ifndef
XXH_FORCE_MEMORY_ACCESS
#
if
!
defined
(
__clang__
)
&
&
defined
(
__GNUC__
)
&
&
defined
(
__ARM_FEATURE_UNALIGNED
)
&
&
defined
(
__ARM_ARCH
)
&
&
(
__ARM_ARCH
=
=
6
)
#
define
XXH_FORCE_MEMORY_ACCESS
2
#
elif
!
defined
(
__clang__
)
&
&
(
(
defined
(
__INTEL_COMPILER
)
&
&
!
defined
(
_WIN32
)
)
|
|
\
(
defined
(
__GNUC__
)
&
&
(
defined
(
__ARM_ARCH
)
&
&
__ARM_ARCH
>
=
7
)
)
)
#
define
XXH_FORCE_MEMORY_ACCESS
1
#
endif
#
endif
#
ifndef
XXH_ACCEPT_NULL_INPUT_POINTER
#
define
XXH_ACCEPT_NULL_INPUT_POINTER
0
#
endif
#
ifndef
XXH_FORCE_ALIGN_CHECK
#
if
defined
(
__i386
)
|
|
defined
(
__x86_64__
)
|
|
defined
(
__aarch64__
)
\
|
|
defined
(
_M_IX86
)
|
|
defined
(
_M_X64
)
|
|
defined
(
_M_ARM64
)
#
define
XXH_FORCE_ALIGN_CHECK
0
#
else
#
define
XXH_FORCE_ALIGN_CHECK
1
#
endif
#
endif
#
ifndef
XXH_NO_INLINE_HINTS
#
if
defined
(
__OPTIMIZE_SIZE__
)
\
|
|
defined
(
__NO_INLINE__
)
#
define
XXH_NO_INLINE_HINTS
1
#
else
#
define
XXH_NO_INLINE_HINTS
0
#
endif
#
endif
#
ifndef
XXH_REROLL
#
if
defined
(
__OPTIMIZE_SIZE__
)
#
define
XXH_REROLL
1
#
else
#
define
XXH_REROLL
0
#
endif
#
endif
#
include
<
stdlib
.
h
>
static
void
*
XXH_malloc
(
size_t
s
)
{
return
malloc
(
s
)
;
}
static
void
XXH_free
(
void
*
p
)
{
free
(
p
)
;
}
#
include
<
string
.
h
>
static
void
*
XXH_memcpy
(
void
*
dest
const
void
*
src
size_t
size
)
{
return
memcpy
(
dest
src
size
)
;
}
#
include
<
limits
.
h
>
#
ifdef
_MSC_VER
#
pragma
warning
(
disable
:
4127
)
/
*
disable
:
C4127
:
conditional
expression
is
constant
*
/
#
endif
#
if
XXH_NO_INLINE_HINTS
#
if
defined
(
__GNUC__
)
#
define
XXH_FORCE_INLINE
static
__attribute__
(
(
unused
)
)
#
else
#
define
XXH_FORCE_INLINE
static
#
endif
#
define
XXH_NO_INLINE
static
#
elif
defined
(
_MSC_VER
)
#
define
XXH_FORCE_INLINE
static
__forceinline
#
define
XXH_NO_INLINE
static
__declspec
(
noinline
)
#
elif
defined
(
__GNUC__
)
#
define
XXH_FORCE_INLINE
static
__inline__
__attribute__
(
(
always_inline
unused
)
)
#
define
XXH_NO_INLINE
static
__attribute__
(
(
noinline
)
)
#
elif
defined
(
__cplusplus
)
\
|
|
(
defined
(
__STDC_VERSION__
)
&
&
(
__STDC_VERSION__
>
=
199901L
)
)
#
define
XXH_FORCE_INLINE
static
inline
#
define
XXH_NO_INLINE
static
#
else
#
define
XXH_FORCE_INLINE
static
#
define
XXH_NO_INLINE
static
#
endif
#
ifndef
XXH_DEBUGLEVEL
#
ifdef
DEBUGLEVEL
#
define
XXH_DEBUGLEVEL
DEBUGLEVEL
#
else
#
define
XXH_DEBUGLEVEL
0
#
endif
#
endif
#
if
(
XXH_DEBUGLEVEL
>
=
1
)
#
include
<
assert
.
h
>
#
define
XXH_ASSERT
(
c
)
assert
(
c
)
#
else
#
define
XXH_ASSERT
(
c
)
(
(
void
)
0
)
#
endif
#
define
XXH_STATIC_ASSERT
(
c
)
do
{
enum
{
XXH_sa
=
1
/
(
int
)
(
!
!
(
c
)
)
}
;
}
while
(
0
)
#
if
!
defined
(
__VMS
)
\
&
&
(
defined
(
__cplusplus
)
\
|
|
(
defined
(
__STDC_VERSION__
)
&
&
(
__STDC_VERSION__
>
=
199901L
)
)
)
#
include
<
stdint
.
h
>
typedef
uint8_t
xxh_u8
;
#
else
typedef
unsigned
char
xxh_u8
;
#
endif
typedef
XXH32_hash_t
xxh_u32
;
#
ifdef
XXH_OLD_NAMES
#
define
BYTE
xxh_u8
#
define
U8
xxh_u8
#
define
U32
xxh_u32
#
endif
#
if
(
defined
(
XXH_FORCE_MEMORY_ACCESS
)
&
&
(
XXH_FORCE_MEMORY_ACCESS
=
=
3
)
)
#
elif
(
defined
(
XXH_FORCE_MEMORY_ACCESS
)
&
&
(
XXH_FORCE_MEMORY_ACCESS
=
=
2
)
)
static
xxh_u32
XXH_read32
(
const
void
*
memPtr
)
{
return
*
(
const
xxh_u32
*
)
memPtr
;
}
#
elif
(
defined
(
XXH_FORCE_MEMORY_ACCESS
)
&
&
(
XXH_FORCE_MEMORY_ACCESS
=
=
1
)
)
#
ifdef
XXH_OLD_NAMES
typedef
union
{
xxh_u32
u32
;
}
__attribute__
(
(
packed
)
)
unalign
;
#
endif
static
xxh_u32
XXH_read32
(
const
void
*
ptr
)
{
typedef
union
{
xxh_u32
u32
;
}
__attribute__
(
(
packed
)
)
xxh_unalign
;
return
(
(
const
xxh_unalign
*
)
ptr
)
-
>
u32
;
}
#
else
static
xxh_u32
XXH_read32
(
const
void
*
memPtr
)
{
xxh_u32
val
;
memcpy
(
&
val
memPtr
sizeof
(
val
)
)
;
return
val
;
}
#
endif
typedef
enum
{
XXH_bigEndian
=
0
XXH_littleEndian
=
1
}
XXH_endianess
;
#
ifndef
XXH_CPU_LITTLE_ENDIAN
#
if
defined
(
_WIN32
)
\
|
|
defined
(
__LITTLE_ENDIAN__
)
\
|
|
(
defined
(
__BYTE_ORDER__
)
&
&
__BYTE_ORDER__
=
=
__ORDER_LITTLE_ENDIAN__
)
#
define
XXH_CPU_LITTLE_ENDIAN
1
#
elif
defined
(
__BIG_ENDIAN__
)
\
|
|
(
defined
(
__BYTE_ORDER__
)
&
&
__BYTE_ORDER__
=
=
__ORDER_BIG_ENDIAN__
)
#
define
XXH_CPU_LITTLE_ENDIAN
0
#
else
static
int
XXH_isLittleEndian
(
void
)
{
const
union
{
xxh_u32
u
;
xxh_u8
c
[
4
]
;
}
one
=
{
1
}
;
return
one
.
c
[
0
]
;
}
#
define
XXH_CPU_LITTLE_ENDIAN
XXH_isLittleEndian
(
)
#
endif
#
endif
#
define
XXH_GCC_VERSION
(
__GNUC__
*
100
+
__GNUC_MINOR__
)
#
ifdef
__has_builtin
#
define
XXH_HAS_BUILTIN
(
x
)
__has_builtin
(
x
)
#
else
#
define
XXH_HAS_BUILTIN
(
x
)
0
#
endif
#
if
!
defined
(
NO_CLANG_BUILTIN
)
&
&
XXH_HAS_BUILTIN
(
__builtin_rotateleft32
)
\
&
&
XXH_HAS_BUILTIN
(
__builtin_rotateleft64
)
#
define
XXH_rotl32
__builtin_rotateleft32
#
define
XXH_rotl64
__builtin_rotateleft64
#
elif
defined
(
_MSC_VER
)
#
define
XXH_rotl32
(
x
r
)
_rotl
(
x
r
)
#
define
XXH_rotl64
(
x
r
)
_rotl64
(
x
r
)
#
else
#
define
XXH_rotl32
(
x
r
)
(
(
(
x
)
<
<
(
r
)
)
|
(
(
x
)
>
>
(
32
-
(
r
)
)
)
)
#
define
XXH_rotl64
(
x
r
)
(
(
(
x
)
<
<
(
r
)
)
|
(
(
x
)
>
>
(
64
-
(
r
)
)
)
)
#
endif
#
if
defined
(
_MSC_VER
)
#
define
XXH_swap32
_byteswap_ulong
#
elif
XXH_GCC_VERSION
>
=
403
#
define
XXH_swap32
__builtin_bswap32
#
else
static
xxh_u32
XXH_swap32
(
xxh_u32
x
)
{
return
(
(
x
<
<
24
)
&
0xff000000
)
|
(
(
x
<
<
8
)
&
0x00ff0000
)
|
(
(
x
>
>
8
)
&
0x0000ff00
)
|
(
(
x
>
>
24
)
&
0x000000ff
)
;
}
#
endif
typedef
enum
{
XXH_aligned
XXH_unaligned
}
XXH_alignment
;
#
if
(
defined
(
XXH_FORCE_MEMORY_ACCESS
)
&
&
(
XXH_FORCE_MEMORY_ACCESS
=
=
3
)
)
XXH_FORCE_INLINE
xxh_u32
XXH_readLE32
(
const
void
*
memPtr
)
{
const
xxh_u8
*
bytePtr
=
(
const
xxh_u8
*
)
memPtr
;
return
bytePtr
[
0
]
|
(
(
xxh_u32
)
bytePtr
[
1
]
<
<
8
)
|
(
(
xxh_u32
)
bytePtr
[
2
]
<
<
16
)
|
(
(
xxh_u32
)
bytePtr
[
3
]
<
<
24
)
;
}
XXH_FORCE_INLINE
xxh_u32
XXH_readBE32
(
const
void
*
memPtr
)
{
const
xxh_u8
*
bytePtr
=
(
const
xxh_u8
*
)
memPtr
;
return
bytePtr
[
3
]
|
(
(
xxh_u32
)
bytePtr
[
2
]
<
<
8
)
|
(
(
xxh_u32
)
bytePtr
[
1
]
<
<
16
)
|
(
(
xxh_u32
)
bytePtr
[
0
]
<
<
24
)
;
}
#
else
XXH_FORCE_INLINE
xxh_u32
XXH_readLE32
(
const
void
*
ptr
)
{
return
XXH_CPU_LITTLE_ENDIAN
?
XXH_read32
(
ptr
)
:
XXH_swap32
(
XXH_read32
(
ptr
)
)
;
}
static
xxh_u32
XXH_readBE32
(
const
void
*
ptr
)
{
return
XXH_CPU_LITTLE_ENDIAN
?
XXH_swap32
(
XXH_read32
(
ptr
)
)
:
XXH_read32
(
ptr
)
;
}
#
endif
XXH_FORCE_INLINE
xxh_u32
XXH_readLE32_align
(
const
void
*
ptr
XXH_alignment
align
)
{
if
(
align
=
=
XXH_unaligned
)
{
return
XXH_readLE32
(
ptr
)
;
}
else
{
return
XXH_CPU_LITTLE_ENDIAN
?
*
(
const
xxh_u32
*
)
ptr
:
XXH_swap32
(
*
(
const
xxh_u32
*
)
ptr
)
;
}
}
XXH_PUBLIC_API
unsigned
XXH_versionNumber
(
void
)
{
return
XXH_VERSION_NUMBER
;
}
static
const
xxh_u32
XXH_PRIME32_1
=
0x9E3779B1U
;
static
const
xxh_u32
XXH_PRIME32_2
=
0x85EBCA77U
;
static
const
xxh_u32
XXH_PRIME32_3
=
0xC2B2AE3DU
;
static
const
xxh_u32
XXH_PRIME32_4
=
0x27D4EB2FU
;
static
const
xxh_u32
XXH_PRIME32_5
=
0x165667B1U
;
#
ifdef
XXH_OLD_NAMES
#
define
PRIME32_1
XXH_PRIME32_1
#
define
PRIME32_2
XXH_PRIME32_2
#
define
PRIME32_3
XXH_PRIME32_3
#
define
PRIME32_4
XXH_PRIME32_4
#
define
PRIME32_5
XXH_PRIME32_5
#
endif
static
xxh_u32
XXH32_round
(
xxh_u32
acc
xxh_u32
input
)
{
acc
+
=
input
*
XXH_PRIME32_2
;
acc
=
XXH_rotl32
(
acc
13
)
;
acc
*
=
XXH_PRIME32_1
;
#
if
defined
(
__GNUC__
)
&
&
defined
(
__SSE4_1__
)
&
&
!
defined
(
XXH_ENABLE_AUTOVECTORIZE
)
__asm__
(
"
"
:
"
+
r
"
(
acc
)
)
;
#
endif
return
acc
;
}
static
xxh_u32
XXH32_avalanche
(
xxh_u32
h32
)
{
h32
^
=
h32
>
>
15
;
h32
*
=
XXH_PRIME32_2
;
h32
^
=
h32
>
>
13
;
h32
*
=
XXH_PRIME32_3
;
h32
^
=
h32
>
>
16
;
return
(
h32
)
;
}
#
define
XXH_get32bits
(
p
)
XXH_readLE32_align
(
p
align
)
static
xxh_u32
XXH32_finalize
(
xxh_u32
h32
const
xxh_u8
*
ptr
size_t
len
XXH_alignment
align
)
{
#
define
XXH_PROCESS1
do
{
\
h32
+
=
(
*
ptr
+
+
)
*
XXH_PRIME32_5
;
\
h32
=
XXH_rotl32
(
h32
11
)
*
XXH_PRIME32_1
;
\
}
while
(
0
)
#
define
XXH_PROCESS4
do
{
\
h32
+
=
XXH_get32bits
(
ptr
)
*
XXH_PRIME32_3
;
\
ptr
+
=
4
;
\
h32
=
XXH_rotl32
(
h32
17
)
*
XXH_PRIME32_4
;
\
}
while
(
0
)
if
(
XXH_REROLL
)
{
len
&
=
15
;
while
(
len
>
=
4
)
{
XXH_PROCESS4
;
len
-
=
4
;
}
while
(
len
>
0
)
{
XXH_PROCESS1
;
-
-
len
;
}
return
XXH32_avalanche
(
h32
)
;
}
else
{
switch
(
len
&
15
)
{
case
12
:
XXH_PROCESS4
;
case
8
:
XXH_PROCESS4
;
case
4
:
XXH_PROCESS4
;
return
XXH32_avalanche
(
h32
)
;
case
13
:
XXH_PROCESS4
;
case
9
:
XXH_PROCESS4
;
case
5
:
XXH_PROCESS4
;
XXH_PROCESS1
;
return
XXH32_avalanche
(
h32
)
;
case
14
:
XXH_PROCESS4
;
case
10
:
XXH_PROCESS4
;
case
6
:
XXH_PROCESS4
;
XXH_PROCESS1
;
XXH_PROCESS1
;
return
XXH32_avalanche
(
h32
)
;
case
15
:
XXH_PROCESS4
;
case
11
:
XXH_PROCESS4
;
case
7
:
XXH_PROCESS4
;
case
3
:
XXH_PROCESS1
;
case
2
:
XXH_PROCESS1
;
case
1
:
XXH_PROCESS1
;
case
0
:
return
XXH32_avalanche
(
h32
)
;
}
XXH_ASSERT
(
0
)
;
return
h32
;
}
}
#
ifdef
XXH_OLD_NAMES
#
define
PROCESS1
XXH_PROCESS1
#
define
PROCESS4
XXH_PROCESS4
#
else
#
undef
XXH_PROCESS1
#
undef
XXH_PROCESS4
#
endif
XXH_FORCE_INLINE
xxh_u32
XXH32_endian_align
(
const
xxh_u8
*
input
size_t
len
xxh_u32
seed
XXH_alignment
align
)
{
const
xxh_u8
*
bEnd
=
input
+
len
;
xxh_u32
h32
;
#
if
defined
(
XXH_ACCEPT_NULL_INPUT_POINTER
)
&
&
(
XXH_ACCEPT_NULL_INPUT_POINTER
>
=
1
)
if
(
input
=
=
NULL
)
{
len
=
0
;
bEnd
=
input
=
(
const
xxh_u8
*
)
(
size_t
)
16
;
}
#
endif
if
(
len
>
=
16
)
{
const
xxh_u8
*
const
limit
=
bEnd
-
15
;
xxh_u32
v1
=
seed
+
XXH_PRIME32_1
+
XXH_PRIME32_2
;
xxh_u32
v2
=
seed
+
XXH_PRIME32_2
;
xxh_u32
v3
=
seed
+
0
;
xxh_u32
v4
=
seed
-
XXH_PRIME32_1
;
do
{
v1
=
XXH32_round
(
v1
XXH_get32bits
(
input
)
)
;
input
+
=
4
;
v2
=
XXH32_round
(
v2
XXH_get32bits
(
input
)
)
;
input
+
=
4
;
v3
=
XXH32_round
(
v3
XXH_get32bits
(
input
)
)
;
input
+
=
4
;
v4
=
XXH32_round
(
v4
XXH_get32bits
(
input
)
)
;
input
+
=
4
;
}
while
(
input
<
limit
)
;
h32
=
XXH_rotl32
(
v1
1
)
+
XXH_rotl32
(
v2
7
)
+
XXH_rotl32
(
v3
12
)
+
XXH_rotl32
(
v4
18
)
;
}
else
{
h32
=
seed
+
XXH_PRIME32_5
;
}
h32
+
=
(
xxh_u32
)
len
;
return
XXH32_finalize
(
h32
input
len
&
15
align
)
;
}
XXH_PUBLIC_API
XXH32_hash_t
XXH32
(
const
void
*
input
size_t
len
XXH32_hash_t
seed
)
{
#
if
0
XXH32_state_t
state
;
XXH32_reset
(
&
state
seed
)
;
XXH32_update
(
&
state
(
const
xxh_u8
*
)
input
len
)
;
return
XXH32_digest
(
&
state
)
;
#
else
if
(
XXH_FORCE_ALIGN_CHECK
)
{
if
(
(
(
(
size_t
)
input
)
&
3
)
=
=
0
)
{
return
XXH32_endian_align
(
(
const
xxh_u8
*
)
input
len
seed
XXH_aligned
)
;
}
}
return
XXH32_endian_align
(
(
const
xxh_u8
*
)
input
len
seed
XXH_unaligned
)
;
#
endif
}
XXH_PUBLIC_API
XXH32_state_t
*
XXH32_createState
(
void
)
{
return
(
XXH32_state_t
*
)
XXH_malloc
(
sizeof
(
XXH32_state_t
)
)
;
}
XXH_PUBLIC_API
XXH_errorcode
XXH32_freeState
(
XXH32_state_t
*
statePtr
)
{
XXH_free
(
statePtr
)
;
return
XXH_OK
;
}
XXH_PUBLIC_API
void
XXH32_copyState
(
XXH32_state_t
*
dstState
const
XXH32_state_t
*
srcState
)
{
memcpy
(
dstState
srcState
sizeof
(
*
dstState
)
)
;
}
XXH_PUBLIC_API
XXH_errorcode
XXH32_reset
(
XXH32_state_t
*
statePtr
XXH32_hash_t
seed
)
{
XXH32_state_t
state
;
memset
(
&
state
0
sizeof
(
state
)
)
;
state
.
v1
=
seed
+
XXH_PRIME32_1
+
XXH_PRIME32_2
;
state
.
v2
=
seed
+
XXH_PRIME32_2
;
state
.
v3
=
seed
+
0
;
state
.
v4
=
seed
-
XXH_PRIME32_1
;
memcpy
(
statePtr
&
state
sizeof
(
state
)
-
sizeof
(
state
.
reserved
)
)
;
return
XXH_OK
;
}
XXH_PUBLIC_API
XXH_errorcode
XXH32_update
(
XXH32_state_t
*
state
const
void
*
input
size_t
len
)
{
if
(
input
=
=
NULL
)
#
if
defined
(
XXH_ACCEPT_NULL_INPUT_POINTER
)
&
&
(
XXH_ACCEPT_NULL_INPUT_POINTER
>
=
1
)
return
XXH_OK
;
#
else
return
XXH_ERROR
;
#
endif
{
const
xxh_u8
*
p
=
(
const
xxh_u8
*
)
input
;
const
xxh_u8
*
const
bEnd
=
p
+
len
;
state
-
>
total_len_32
+
=
(
XXH32_hash_t
)
len
;
state
-
>
large_len
|
=
(
XXH32_hash_t
)
(
(
len
>
=
16
)
|
(
state
-
>
total_len_32
>
=
16
)
)
;
if
(
state
-
>
memsize
+
len
<
16
)
{
XXH_memcpy
(
(
xxh_u8
*
)
(
state
-
>
mem32
)
+
state
-
>
memsize
input
len
)
;
state
-
>
memsize
+
=
(
XXH32_hash_t
)
len
;
return
XXH_OK
;
}
if
(
state
-
>
memsize
)
{
XXH_memcpy
(
(
xxh_u8
*
)
(
state
-
>
mem32
)
+
state
-
>
memsize
input
16
-
state
-
>
memsize
)
;
{
const
xxh_u32
*
p32
=
state
-
>
mem32
;
state
-
>
v1
=
XXH32_round
(
state
-
>
v1
XXH_readLE32
(
p32
)
)
;
p32
+
+
;
state
-
>
v2
=
XXH32_round
(
state
-
>
v2
XXH_readLE32
(
p32
)
)
;
p32
+
+
;
state
-
>
v3
=
XXH32_round
(
state
-
>
v3
XXH_readLE32
(
p32
)
)
;
p32
+
+
;
state
-
>
v4
=
XXH32_round
(
state
-
>
v4
XXH_readLE32
(
p32
)
)
;
}
p
+
=
16
-
state
-
>
memsize
;
state
-
>
memsize
=
0
;
}
if
(
p
<
=
bEnd
-
16
)
{
const
xxh_u8
*
const
limit
=
bEnd
-
16
;
xxh_u32
v1
=
state
-
>
v1
;
xxh_u32
v2
=
state
-
>
v2
;
xxh_u32
v3
=
state
-
>
v3
;
xxh_u32
v4
=
state
-
>
v4
;
do
{
v1
=
XXH32_round
(
v1
XXH_readLE32
(
p
)
)
;
p
+
=
4
;
v2
=
XXH32_round
(
v2
XXH_readLE32
(
p
)
)
;
p
+
=
4
;
v3
=
XXH32_round
(
v3
XXH_readLE32
(
p
)
)
;
p
+
=
4
;
v4
=
XXH32_round
(
v4
XXH_readLE32
(
p
)
)
;
p
+
=
4
;
}
while
(
p
<
=
limit
)
;
state
-
>
v1
=
v1
;
state
-
>
v2
=
v2
;
state
-
>
v3
=
v3
;
state
-
>
v4
=
v4
;
}
if
(
p
<
bEnd
)
{
XXH_memcpy
(
state
-
>
mem32
p
(
size_t
)
(
bEnd
-
p
)
)
;
state
-
>
memsize
=
(
unsigned
)
(
bEnd
-
p
)
;
}
}
return
XXH_OK
;
}
XXH_PUBLIC_API
XXH32_hash_t
XXH32_digest
(
const
XXH32_state_t
*
state
)
{
xxh_u32
h32
;
if
(
state
-
>
large_len
)
{
h32
=
XXH_rotl32
(
state
-
>
v1
1
)
+
XXH_rotl32
(
state
-
>
v2
7
)
+
XXH_rotl32
(
state
-
>
v3
12
)
+
XXH_rotl32
(
state
-
>
v4
18
)
;
}
else
{
h32
=
state
-
>
v3
+
XXH_PRIME32_5
;
}
h32
+
=
state
-
>
total_len_32
;
return
XXH32_finalize
(
h32
(
const
xxh_u8
*
)
state
-
>
mem32
state
-
>
memsize
XXH_aligned
)
;
}
XXH_PUBLIC_API
void
XXH32_canonicalFromHash
(
XXH32_canonical_t
*
dst
XXH32_hash_t
hash
)
{
XXH_STATIC_ASSERT
(
sizeof
(
XXH32_canonical_t
)
=
=
sizeof
(
XXH32_hash_t
)
)
;
if
(
XXH_CPU_LITTLE_ENDIAN
)
hash
=
XXH_swap32
(
hash
)
;
memcpy
(
dst
&
hash
sizeof
(
*
dst
)
)
;
}
XXH_PUBLIC_API
XXH32_hash_t
XXH32_hashFromCanonical
(
const
XXH32_canonical_t
*
src
)
{
return
XXH_readBE32
(
src
)
;
}
#
ifndef
XXH_NO_LONG_LONG
typedef
XXH64_hash_t
xxh_u64
;
#
ifdef
XXH_OLD_NAMES
#
define
U64
xxh_u64
#
endif
#
ifndef
XXH_REROLL_XXH64
#
if
(
defined
(
__ILP32__
)
|
|
defined
(
_ILP32
)
)
\
|
|
!
(
defined
(
__x86_64__
)
|
|
defined
(
_M_X64
)
|
|
defined
(
_M_AMD64
)
\
|
|
defined
(
_M_ARM64
)
|
|
defined
(
__aarch64__
)
|
|
defined
(
__arm64__
)
\
|
|
defined
(
__PPC64__
)
|
|
defined
(
__PPC64LE__
)
|
|
defined
(
__ppc64__
)
|
|
defined
(
__powerpc64__
)
\
|
|
defined
(
__mips64__
)
|
|
defined
(
__mips64
)
)
\
|
|
(
!
defined
(
SIZE_MAX
)
|
|
SIZE_MAX
<
ULLONG_MAX
)
#
define
XXH_REROLL_XXH64
1
#
else
#
define
XXH_REROLL_XXH64
0
#
endif
#
endif
#
if
(
defined
(
XXH_FORCE_MEMORY_ACCESS
)
&
&
(
XXH_FORCE_MEMORY_ACCESS
=
=
3
)
)
#
elif
(
defined
(
XXH_FORCE_MEMORY_ACCESS
)
&
&
(
XXH_FORCE_MEMORY_ACCESS
=
=
2
)
)
static
xxh_u64
XXH_read64
(
const
void
*
memPtr
)
{
return
*
(
const
xxh_u64
*
)
memPtr
;
}
#
elif
(
defined
(
XXH_FORCE_MEMORY_ACCESS
)
&
&
(
XXH_FORCE_MEMORY_ACCESS
=
=
1
)
)
#
ifdef
XXH_OLD_NAMES
typedef
union
{
xxh_u32
u32
;
xxh_u64
u64
;
}
__attribute__
(
(
packed
)
)
unalign64
;
#
endif
static
xxh_u64
XXH_read64
(
const
void
*
ptr
)
{
typedef
union
{
xxh_u32
u32
;
xxh_u64
u64
;
}
__attribute__
(
(
packed
)
)
xxh_unalign64
;
return
(
(
const
xxh_unalign64
*
)
ptr
)
-
>
u64
;
}
#
else
static
xxh_u64
XXH_read64
(
const
void
*
memPtr
)
{
xxh_u64
val
;
memcpy
(
&
val
memPtr
sizeof
(
val
)
)
;
return
val
;
}
#
endif
#
if
defined
(
_MSC_VER
)
#
define
XXH_swap64
_byteswap_uint64
#
elif
XXH_GCC_VERSION
>
=
403
#
define
XXH_swap64
__builtin_bswap64
#
else
static
xxh_u64
XXH_swap64
(
xxh_u64
x
)
{
return
(
(
x
<
<
56
)
&
0xff00000000000000ULL
)
|
(
(
x
<
<
40
)
&
0x00ff000000000000ULL
)
|
(
(
x
<
<
24
)
&
0x0000ff0000000000ULL
)
|
(
(
x
<
<
8
)
&
0x000000ff00000000ULL
)
|
(
(
x
>
>
8
)
&
0x00000000ff000000ULL
)
|
(
(
x
>
>
24
)
&
0x0000000000ff0000ULL
)
|
(
(
x
>
>
40
)
&
0x000000000000ff00ULL
)
|
(
(
x
>
>
56
)
&
0x00000000000000ffULL
)
;
}
#
endif
#
if
(
defined
(
XXH_FORCE_MEMORY_ACCESS
)
&
&
(
XXH_FORCE_MEMORY_ACCESS
=
=
3
)
)
XXH_FORCE_INLINE
xxh_u64
XXH_readLE64
(
const
void
*
memPtr
)
{
const
xxh_u8
*
bytePtr
=
(
const
xxh_u8
*
)
memPtr
;
return
bytePtr
[
0
]
|
(
(
xxh_u64
)
bytePtr
[
1
]
<
<
8
)
|
(
(
xxh_u64
)
bytePtr
[
2
]
<
<
16
)
|
(
(
xxh_u64
)
bytePtr
[
3
]
<
<
24
)
|
(
(
xxh_u64
)
bytePtr
[
4
]
<
<
32
)
|
(
(
xxh_u64
)
bytePtr
[
5
]
<
<
40
)
|
(
(
xxh_u64
)
bytePtr
[
6
]
<
<
48
)
|
(
(
xxh_u64
)
bytePtr
[
7
]
<
<
56
)
;
}
XXH_FORCE_INLINE
xxh_u64
XXH_readBE64
(
const
void
*
memPtr
)
{
const
xxh_u8
*
bytePtr
=
(
const
xxh_u8
*
)
memPtr
;
return
bytePtr
[
7
]
|
(
(
xxh_u64
)
bytePtr
[
6
]
<
<
8
)
|
(
(
xxh_u64
)
bytePtr
[
5
]
<
<
16
)
|
(
(
xxh_u64
)
bytePtr
[
4
]
<
<
24
)
|
(
(
xxh_u64
)
bytePtr
[
3
]
<
<
32
)
|
(
(
xxh_u64
)
bytePtr
[
2
]
<
<
40
)
|
(
(
xxh_u64
)
bytePtr
[
1
]
<
<
48
)
|
(
(
xxh_u64
)
bytePtr
[
0
]
<
<
56
)
;
}
#
else
XXH_FORCE_INLINE
xxh_u64
XXH_readLE64
(
const
void
*
ptr
)
{
return
XXH_CPU_LITTLE_ENDIAN
?
XXH_read64
(
ptr
)
:
XXH_swap64
(
XXH_read64
(
ptr
)
)
;
}
static
xxh_u64
XXH_readBE64
(
const
void
*
ptr
)
{
return
XXH_CPU_LITTLE_ENDIAN
?
XXH_swap64
(
XXH_read64
(
ptr
)
)
:
XXH_read64
(
ptr
)
;
}
#
endif
XXH_FORCE_INLINE
xxh_u64
XXH_readLE64_align
(
const
void
*
ptr
XXH_alignment
align
)
{
if
(
align
=
=
XXH_unaligned
)
return
XXH_readLE64
(
ptr
)
;
else
return
XXH_CPU_LITTLE_ENDIAN
?
*
(
const
xxh_u64
*
)
ptr
:
XXH_swap64
(
*
(
const
xxh_u64
*
)
ptr
)
;
}
static
const
xxh_u64
XXH_PRIME64_1
=
0x9E3779B185EBCA87ULL
;
static
const
xxh_u64
XXH_PRIME64_2
=
0xC2B2AE3D27D4EB4FULL
;
static
const
xxh_u64
XXH_PRIME64_3
=
0x165667B19E3779F9ULL
;
static
const
xxh_u64
XXH_PRIME64_4
=
0x85EBCA77C2B2AE63ULL
;
static
const
xxh_u64
XXH_PRIME64_5
=
0x27D4EB2F165667C5ULL
;
#
ifdef
XXH_OLD_NAMES
#
define
PRIME64_1
XXH_PRIME64_1
#
define
PRIME64_2
XXH_PRIME64_2
#
define
PRIME64_3
XXH_PRIME64_3
#
define
PRIME64_4
XXH_PRIME64_4
#
define
PRIME64_5
XXH_PRIME64_5
#
endif
static
xxh_u64
XXH64_round
(
xxh_u64
acc
xxh_u64
input
)
{
acc
+
=
input
*
XXH_PRIME64_2
;
acc
=
XXH_rotl64
(
acc
31
)
;
acc
*
=
XXH_PRIME64_1
;
return
acc
;
}
static
xxh_u64
XXH64_mergeRound
(
xxh_u64
acc
xxh_u64
val
)
{
val
=
XXH64_round
(
0
val
)
;
acc
^
=
val
;
acc
=
acc
*
XXH_PRIME64_1
+
XXH_PRIME64_4
;
return
acc
;
}
static
xxh_u64
XXH64_avalanche
(
xxh_u64
h64
)
{
h64
^
=
h64
>
>
33
;
h64
*
=
XXH_PRIME64_2
;
h64
^
=
h64
>
>
29
;
h64
*
=
XXH_PRIME64_3
;
h64
^
=
h64
>
>
32
;
return
h64
;
}
#
define
XXH_get64bits
(
p
)
XXH_readLE64_align
(
p
align
)
static
xxh_u64
XXH64_finalize
(
xxh_u64
h64
const
xxh_u8
*
ptr
size_t
len
XXH_alignment
align
)
{
#
define
XXH_PROCESS1_64
do
{
\
h64
^
=
(
*
ptr
+
+
)
*
XXH_PRIME64_5
;
\
h64
=
XXH_rotl64
(
h64
11
)
*
XXH_PRIME64_1
;
\
}
while
(
0
)
#
define
XXH_PROCESS4_64
do
{
\
h64
^
=
(
xxh_u64
)
(
XXH_get32bits
(
ptr
)
)
*
XXH_PRIME64_1
;
\
ptr
+
=
4
;
\
h64
=
XXH_rotl64
(
h64
23
)
*
XXH_PRIME64_2
+
XXH_PRIME64_3
;
\
}
while
(
0
)
#
define
XXH_PROCESS8_64
do
{
\
xxh_u64
const
k1
=
XXH64_round
(
0
XXH_get64bits
(
ptr
)
)
;
\
ptr
+
=
8
;
\
h64
^
=
k1
;
\
h64
=
XXH_rotl64
(
h64
27
)
*
XXH_PRIME64_1
+
XXH_PRIME64_4
;
\
}
while
(
0
)
if
(
XXH_REROLL
|
|
XXH_REROLL_XXH64
)
{
len
&
=
31
;
while
(
len
>
=
8
)
{
XXH_PROCESS8_64
;
len
-
=
8
;
}
if
(
len
>
=
4
)
{
XXH_PROCESS4_64
;
len
-
=
4
;
}
while
(
len
>
0
)
{
XXH_PROCESS1_64
;
-
-
len
;
}
return
XXH64_avalanche
(
h64
)
;
}
else
{
switch
(
len
&
31
)
{
case
24
:
XXH_PROCESS8_64
;
case
16
:
XXH_PROCESS8_64
;
case
8
:
XXH_PROCESS8_64
;
return
XXH64_avalanche
(
h64
)
;
case
28
:
XXH_PROCESS8_64
;
case
20
:
XXH_PROCESS8_64
;
case
12
:
XXH_PROCESS8_64
;
case
4
:
XXH_PROCESS4_64
;
return
XXH64_avalanche
(
h64
)
;
case
25
:
XXH_PROCESS8_64
;
case
17
:
XXH_PROCESS8_64
;
case
9
:
XXH_PROCESS8_64
;
XXH_PROCESS1_64
;
return
XXH64_avalanche
(
h64
)
;
case
29
:
XXH_PROCESS8_64
;
case
21
:
XXH_PROCESS8_64
;
case
13
:
XXH_PROCESS8_64
;
case
5
:
XXH_PROCESS4_64
;
XXH_PROCESS1_64
;
return
XXH64_avalanche
(
h64
)
;
case
26
:
XXH_PROCESS8_64
;
case
18
:
XXH_PROCESS8_64
;
case
10
:
XXH_PROCESS8_64
;
XXH_PROCESS1_64
;
XXH_PROCESS1_64
;
return
XXH64_avalanche
(
h64
)
;
case
30
:
XXH_PROCESS8_64
;
case
22
:
XXH_PROCESS8_64
;
case
14
:
XXH_PROCESS8_64
;
case
6
:
XXH_PROCESS4_64
;
XXH_PROCESS1_64
;
XXH_PROCESS1_64
;
return
XXH64_avalanche
(
h64
)
;
case
27
:
XXH_PROCESS8_64
;
case
19
:
XXH_PROCESS8_64
;
case
11
:
XXH_PROCESS8_64
;
XXH_PROCESS1_64
;
XXH_PROCESS1_64
;
XXH_PROCESS1_64
;
return
XXH64_avalanche
(
h64
)
;
case
31
:
XXH_PROCESS8_64
;
case
23
:
XXH_PROCESS8_64
;
case
15
:
XXH_PROCESS8_64
;
case
7
:
XXH_PROCESS4_64
;
case
3
:
XXH_PROCESS1_64
;
case
2
:
XXH_PROCESS1_64
;
case
1
:
XXH_PROCESS1_64
;
case
0
:
return
XXH64_avalanche
(
h64
)
;
}
}
XXH_ASSERT
(
0
)
;
return
0
;
}
#
ifdef
XXH_OLD_NAMES
#
define
PROCESS1_64
XXH_PROCESS1_64
#
define
PROCESS4_64
XXH_PROCESS4_64
#
define
PROCESS8_64
XXH_PROCESS8_64
#
else
#
undef
XXH_PROCESS1_64
#
undef
XXH_PROCESS4_64
#
undef
XXH_PROCESS8_64
#
endif
XXH_FORCE_INLINE
xxh_u64
XXH64_endian_align
(
const
xxh_u8
*
input
size_t
len
xxh_u64
seed
XXH_alignment
align
)
{
const
xxh_u8
*
bEnd
=
input
+
len
;
xxh_u64
h64
;
#
if
defined
(
XXH_ACCEPT_NULL_INPUT_POINTER
)
&
&
(
XXH_ACCEPT_NULL_INPUT_POINTER
>
=
1
)
if
(
input
=
=
NULL
)
{
len
=
0
;
bEnd
=
input
=
(
const
xxh_u8
*
)
(
size_t
)
32
;
}
#
endif
if
(
len
>
=
32
)
{
const
xxh_u8
*
const
limit
=
bEnd
-
32
;
xxh_u64
v1
=
seed
+
XXH_PRIME64_1
+
XXH_PRIME64_2
;
xxh_u64
v2
=
seed
+
XXH_PRIME64_2
;
xxh_u64
v3
=
seed
+
0
;
xxh_u64
v4
=
seed
-
XXH_PRIME64_1
;
do
{
v1
=
XXH64_round
(
v1
XXH_get64bits
(
input
)
)
;
input
+
=
8
;
v2
=
XXH64_round
(
v2
XXH_get64bits
(
input
)
)
;
input
+
=
8
;
v3
=
XXH64_round
(
v3
XXH_get64bits
(
input
)
)
;
input
+
=
8
;
v4
=
XXH64_round
(
v4
XXH_get64bits
(
input
)
)
;
input
+
=
8
;
}
while
(
input
<
=
limit
)
;
h64
=
XXH_rotl64
(
v1
1
)
+
XXH_rotl64
(
v2
7
)
+
XXH_rotl64
(
v3
12
)
+
XXH_rotl64
(
v4
18
)
;
h64
=
XXH64_mergeRound
(
h64
v1
)
;
h64
=
XXH64_mergeRound
(
h64
v2
)
;
h64
=
XXH64_mergeRound
(
h64
v3
)
;
h64
=
XXH64_mergeRound
(
h64
v4
)
;
}
else
{
h64
=
seed
+
XXH_PRIME64_5
;
}
h64
+
=
(
xxh_u64
)
len
;
return
XXH64_finalize
(
h64
input
len
align
)
;
}
XXH_PUBLIC_API
XXH64_hash_t
XXH64
(
const
void
*
input
size_t
len
XXH64_hash_t
seed
)
{
#
if
0
XXH64_state_t
state
;
XXH64_reset
(
&
state
seed
)
;
XXH64_update
(
&
state
(
const
xxh_u8
*
)
input
len
)
;
return
XXH64_digest
(
&
state
)
;
#
else
if
(
XXH_FORCE_ALIGN_CHECK
)
{
if
(
(
(
(
size_t
)
input
)
&
7
)
=
=
0
)
{
return
XXH64_endian_align
(
(
const
xxh_u8
*
)
input
len
seed
XXH_aligned
)
;
}
}
return
XXH64_endian_align
(
(
const
xxh_u8
*
)
input
len
seed
XXH_unaligned
)
;
#
endif
}
XXH_PUBLIC_API
XXH64_state_t
*
XXH64_createState
(
void
)
{
return
(
XXH64_state_t
*
)
XXH_malloc
(
sizeof
(
XXH64_state_t
)
)
;
}
XXH_PUBLIC_API
XXH_errorcode
XXH64_freeState
(
XXH64_state_t
*
statePtr
)
{
XXH_free
(
statePtr
)
;
return
XXH_OK
;
}
XXH_PUBLIC_API
void
XXH64_copyState
(
XXH64_state_t
*
dstState
const
XXH64_state_t
*
srcState
)
{
memcpy
(
dstState
srcState
sizeof
(
*
dstState
)
)
;
}
XXH_PUBLIC_API
XXH_errorcode
XXH64_reset
(
XXH64_state_t
*
statePtr
XXH64_hash_t
seed
)
{
XXH64_state_t
state
;
memset
(
&
state
0
sizeof
(
state
)
)
;
state
.
v1
=
seed
+
XXH_PRIME64_1
+
XXH_PRIME64_2
;
state
.
v2
=
seed
+
XXH_PRIME64_2
;
state
.
v3
=
seed
+
0
;
state
.
v4
=
seed
-
XXH_PRIME64_1
;
memcpy
(
statePtr
&
state
sizeof
(
state
)
-
sizeof
(
state
.
reserved64
)
)
;
return
XXH_OK
;
}
XXH_PUBLIC_API
XXH_errorcode
XXH64_update
(
XXH64_state_t
*
state
const
void
*
input
size_t
len
)
{
if
(
input
=
=
NULL
)
#
if
defined
(
XXH_ACCEPT_NULL_INPUT_POINTER
)
&
&
(
XXH_ACCEPT_NULL_INPUT_POINTER
>
=
1
)
return
XXH_OK
;
#
else
return
XXH_ERROR
;
#
endif
{
const
xxh_u8
*
p
=
(
const
xxh_u8
*
)
input
;
const
xxh_u8
*
const
bEnd
=
p
+
len
;
state
-
>
total_len
+
=
len
;
if
(
state
-
>
memsize
+
len
<
32
)
{
XXH_memcpy
(
(
(
xxh_u8
*
)
state
-
>
mem64
)
+
state
-
>
memsize
input
len
)
;
state
-
>
memsize
+
=
(
xxh_u32
)
len
;
return
XXH_OK
;
}
if
(
state
-
>
memsize
)
{
XXH_memcpy
(
(
(
xxh_u8
*
)
state
-
>
mem64
)
+
state
-
>
memsize
input
32
-
state
-
>
memsize
)
;
state
-
>
v1
=
XXH64_round
(
state
-
>
v1
XXH_readLE64
(
state
-
>
mem64
+
0
)
)
;
state
-
>
v2
=
XXH64_round
(
state
-
>
v2
XXH_readLE64
(
state
-
>
mem64
+
1
)
)
;
state
-
>
v3
=
XXH64_round
(
state
-
>
v3
XXH_readLE64
(
state
-
>
mem64
+
2
)
)
;
state
-
>
v4
=
XXH64_round
(
state
-
>
v4
XXH_readLE64
(
state
-
>
mem64
+
3
)
)
;
p
+
=
32
-
state
-
>
memsize
;
state
-
>
memsize
=
0
;
}
if
(
p
+
32
<
=
bEnd
)
{
const
xxh_u8
*
const
limit
=
bEnd
-
32
;
xxh_u64
v1
=
state
-
>
v1
;
xxh_u64
v2
=
state
-
>
v2
;
xxh_u64
v3
=
state
-
>
v3
;
xxh_u64
v4
=
state
-
>
v4
;
do
{
v1
=
XXH64_round
(
v1
XXH_readLE64
(
p
)
)
;
p
+
=
8
;
v2
=
XXH64_round
(
v2
XXH_readLE64
(
p
)
)
;
p
+
=
8
;
v3
=
XXH64_round
(
v3
XXH_readLE64
(
p
)
)
;
p
+
=
8
;
v4
=
XXH64_round
(
v4
XXH_readLE64
(
p
)
)
;
p
+
=
8
;
}
while
(
p
<
=
limit
)
;
state
-
>
v1
=
v1
;
state
-
>
v2
=
v2
;
state
-
>
v3
=
v3
;
state
-
>
v4
=
v4
;
}
if
(
p
<
bEnd
)
{
XXH_memcpy
(
state
-
>
mem64
p
(
size_t
)
(
bEnd
-
p
)
)
;
state
-
>
memsize
=
(
unsigned
)
(
bEnd
-
p
)
;
}
}
return
XXH_OK
;
}
XXH_PUBLIC_API
XXH64_hash_t
XXH64_digest
(
const
XXH64_state_t
*
state
)
{
xxh_u64
h64
;
if
(
state
-
>
total_len
>
=
32
)
{
xxh_u64
const
v1
=
state
-
>
v1
;
xxh_u64
const
v2
=
state
-
>
v2
;
xxh_u64
const
v3
=
state
-
>
v3
;
xxh_u64
const
v4
=
state
-
>
v4
;
h64
=
XXH_rotl64
(
v1
1
)
+
XXH_rotl64
(
v2
7
)
+
XXH_rotl64
(
v3
12
)
+
XXH_rotl64
(
v4
18
)
;
h64
=
XXH64_mergeRound
(
h64
v1
)
;
h64
=
XXH64_mergeRound
(
h64
v2
)
;
h64
=
XXH64_mergeRound
(
h64
v3
)
;
h64
=
XXH64_mergeRound
(
h64
v4
)
;
}
else
{
h64
=
state
-
>
v3
+
XXH_PRIME64_5
;
}
h64
+
=
(
xxh_u64
)
state
-
>
total_len
;
return
XXH64_finalize
(
h64
(
const
xxh_u8
*
)
state
-
>
mem64
(
size_t
)
state
-
>
total_len
XXH_aligned
)
;
}
XXH_PUBLIC_API
void
XXH64_canonicalFromHash
(
XXH64_canonical_t
*
dst
XXH64_hash_t
hash
)
{
XXH_STATIC_ASSERT
(
sizeof
(
XXH64_canonical_t
)
=
=
sizeof
(
XXH64_hash_t
)
)
;
if
(
XXH_CPU_LITTLE_ENDIAN
)
hash
=
XXH_swap64
(
hash
)
;
memcpy
(
dst
&
hash
sizeof
(
*
dst
)
)
;
}
XXH_PUBLIC_API
XXH64_hash_t
XXH64_hashFromCanonical
(
const
XXH64_canonical_t
*
src
)
{
return
XXH_readBE64
(
src
)
;
}
#
if
defined
(
__STDC_VERSION__
)
&
&
__STDC_VERSION__
>
=
199901L
#
define
XXH_RESTRICT
restrict
#
else
#
define
XXH_RESTRICT
#
endif
#
if
(
defined
(
__GNUC__
)
&
&
(
__GNUC__
>
=
3
)
)
\
|
|
(
defined
(
__INTEL_COMPILER
)
&
&
(
__INTEL_COMPILER
>
=
800
)
)
\
|
|
defined
(
__clang__
)
#
define
XXH_likely
(
x
)
__builtin_expect
(
x
1
)
#
define
XXH_unlikely
(
x
)
__builtin_expect
(
x
0
)
#
else
#
define
XXH_likely
(
x
)
(
x
)
#
define
XXH_unlikely
(
x
)
(
x
)
#
endif
#
if
defined
(
__GNUC__
)
#
if
defined
(
__AVX2__
)
#
include
<
immintrin
.
h
>
#
elif
defined
(
__SSE2__
)
#
include
<
emmintrin
.
h
>
#
elif
defined
(
__ARM_NEON__
)
|
|
defined
(
__ARM_NEON
)
#
define
inline
__inline__
/
*
circumvent
a
clang
bug
*
/
#
include
<
arm_neon
.
h
>
#
undef
inline
#
endif
#
elif
defined
(
_MSC_VER
)
#
include
<
intrin
.
h
>
#
endif
#
if
defined
(
__thumb__
)
&
&
!
defined
(
__thumb2__
)
&
&
defined
(
__ARM_ARCH_ISA_ARM
)
#
warning
"
XXH3
is
highly
inefficient
without
ARM
or
Thumb
-
2
.
"
#
endif
#
define
XXH_SCALAR
0
/
*
Portable
scalar
version
*
/
#
define
XXH_SSE2
1
/
*
SSE2
for
Pentium
4
and
all
x86_64
*
/
#
define
XXH_AVX2
2
/
*
AVX2
for
Haswell
and
Bulldozer
*
/
#
define
XXH_AVX512
3
/
*
AVX512
for
Skylake
and
Icelake
*
/
#
define
XXH_NEON
4
/
*
NEON
for
most
ARMv7
-
A
and
all
AArch64
*
/
#
define
XXH_VSX
5
/
*
VSX
and
ZVector
for
POWER8
/
z13
*
/
#
ifndef
XXH_VECTOR
#
if
defined
(
__AVX512F__
)
#
define
XXH_VECTOR
XXH_AVX512
#
elif
defined
(
__AVX2__
)
#
define
XXH_VECTOR
XXH_AVX2
#
elif
defined
(
__SSE2__
)
|
|
defined
(
_M_AMD64
)
|
|
defined
(
_M_X64
)
|
|
(
defined
(
_M_IX86_FP
)
&
&
(
_M_IX86_FP
=
=
2
)
)
#
define
XXH_VECTOR
XXH_SSE2
#
elif
defined
(
__GNUC__
)
\
&
&
(
defined
(
__ARM_NEON__
)
|
|
defined
(
__ARM_NEON
)
)
\
&
&
(
defined
(
__LITTLE_ENDIAN__
)
\
|
|
(
defined
(
__BYTE_ORDER__
)
&
&
__BYTE_ORDER__
=
=
__ORDER_LITTLE_ENDIAN__
)
)
#
define
XXH_VECTOR
XXH_NEON
#
elif
(
defined
(
__PPC64__
)
&
&
defined
(
__POWER8_VECTOR__
)
)
\
|
|
(
defined
(
__s390x__
)
&
&
defined
(
__VEC__
)
)
\
&
&
defined
(
__GNUC__
)
#
define
XXH_VECTOR
XXH_VSX
#
else
#
define
XXH_VECTOR
XXH_SCALAR
#
endif
#
endif
#
ifndef
XXH_ACC_ALIGN
#
if
defined
(
XXH_X86DISPATCH
)
#
define
XXH_ACC_ALIGN
64
/
*
for
compatibility
with
avx512
*
/
#
elif
XXH_VECTOR
=
=
XXH_SCALAR
#
define
XXH_ACC_ALIGN
8
#
elif
XXH_VECTOR
=
=
XXH_SSE2
#
define
XXH_ACC_ALIGN
16
#
elif
XXH_VECTOR
=
=
XXH_AVX2
#
define
XXH_ACC_ALIGN
32
#
elif
XXH_VECTOR
=
=
XXH_NEON
#
define
XXH_ACC_ALIGN
16
#
elif
XXH_VECTOR
=
=
XXH_VSX
#
define
XXH_ACC_ALIGN
16
#
elif
XXH_VECTOR
=
=
XXH_AVX512
#
define
XXH_ACC_ALIGN
64
#
endif
#
endif
#
if
defined
(
XXH_X86DISPATCH
)
|
|
XXH_VECTOR
=
=
XXH_SSE2
\
|
|
XXH_VECTOR
=
=
XXH_AVX2
|
|
XXH_VECTOR
=
=
XXH_AVX512
#
define
XXH_SEC_ALIGN
XXH_ACC_ALIGN
#
else
#
define
XXH_SEC_ALIGN
8
#
endif
#
if
XXH_VECTOR
=
=
XXH_AVX2
\
&
&
defined
(
__GNUC__
)
&
&
!
defined
(
__clang__
)
\
&
&
defined
(
__OPTIMIZE__
)
&
&
!
defined
(
__OPTIMIZE_SIZE__
)
#
pragma
GCC
push_options
#
pragma
GCC
optimize
(
"
-
O2
"
)
#
endif
#
if
XXH_VECTOR
=
=
XXH_NEON
#
if
!
defined
(
XXH_NO_VZIP_HACK
)
\
&
&
defined
(
__GNUC__
)
\
&
&
!
defined
(
__aarch64__
)
&
&
!
defined
(
__arm64__
)
#
define
XXH_SPLIT_IN_PLACE
(
in
outLo
outHi
)
\
do
{
\
/
*
Undocumented
GCC
/
Clang
operand
modifier
:
%
e0
=
lower
D
half
%
f0
=
upper
D
half
*
/
\
/
*
https
:
/
/
github
.
com
/
gcc
-
mirror
/
gcc
/
blob
/
38cf91e5
/
gcc
/
config
/
arm
/
arm
.
c
#
L22486
*
/
\
/
*
https
:
/
/
github
.
com
/
llvm
-
mirror
/
llvm
/
blob
/
2c4ca683
/
lib
/
Target
/
ARM
/
ARMAsmPrinter
.
cpp
#
L399
*
/
\
__asm__
(
"
vzip
.
32
%
e0
%
f0
"
:
"
+
w
"
(
in
)
)
;
\
(
outLo
)
=
vget_low_u32
(
vreinterpretq_u32_u64
(
in
)
)
;
\
(
outHi
)
=
vget_high_u32
(
vreinterpretq_u32_u64
(
in
)
)
;
\
}
while
(
0
)
#
else
#
define
XXH_SPLIT_IN_PLACE
(
in
outLo
outHi
)
\
do
{
\
(
outLo
)
=
vmovn_u64
(
in
)
;
\
(
outHi
)
=
vshrn_n_u64
(
(
in
)
32
)
;
\
}
while
(
0
)
#
endif
#
endif
#
if
XXH_VECTOR
=
=
XXH_VSX
#
if
defined
(
__s390x__
)
#
include
<
s390intrin
.
h
>
#
else
#
if
defined
(
__GNUC__
)
&
&
!
defined
(
__APPLE_ALTIVEC__
)
#
define
__APPLE_ALTIVEC__
#
endif
#
include
<
altivec
.
h
>
#
endif
typedef
__vector
unsigned
long
long
xxh_u64x2
;
typedef
__vector
unsigned
char
xxh_u8x16
;
typedef
__vector
unsigned
xxh_u32x4
;
#
ifndef
XXH_VSX_BE
#
if
defined
(
__BIG_ENDIAN__
)
\
|
|
(
defined
(
__BYTE_ORDER__
)
&
&
__BYTE_ORDER__
=
=
__ORDER_BIG_ENDIAN__
)
#
define
XXH_VSX_BE
1
#
elif
defined
(
__VEC_ELEMENT_REG_ORDER__
)
&
&
__VEC_ELEMENT_REG_ORDER__
=
=
__ORDER_BIG_ENDIAN__
#
warning
"
-
maltivec
=
be
is
not
recommended
.
Please
use
native
endianness
.
"
#
define
XXH_VSX_BE
1
#
else
#
define
XXH_VSX_BE
0
#
endif
#
endif
#
if
XXH_VSX_BE
#
if
defined
(
__POWER9_VECTOR__
)
|
|
(
defined
(
__clang__
)
&
&
defined
(
__s390x__
)
)
#
define
XXH_vec_revb
vec_revb
#
else
XXH_FORCE_INLINE
xxh_u64x2
XXH_vec_revb
(
xxh_u64x2
val
)
{
xxh_u8x16
const
vByteSwap
=
{
0x07
0x06
0x05
0x04
0x03
0x02
0x01
0x00
0x0F
0x0E
0x0D
0x0C
0x0B
0x0A
0x09
0x08
}
;
return
vec_perm
(
val
val
vByteSwap
)
;
}
#
endif
#
endif
XXH_FORCE_INLINE
xxh_u64x2
XXH_vec_loadu
(
const
void
*
ptr
)
{
xxh_u64x2
ret
;
memcpy
(
&
ret
ptr
sizeof
(
xxh_u64x2
)
)
;
#
if
XXH_VSX_BE
ret
=
XXH_vec_revb
(
ret
)
;
#
endif
return
ret
;
}
#
if
defined
(
__s390x__
)
#
define
XXH_vec_mulo
vec_mulo
#
define
XXH_vec_mule
vec_mule
#
elif
defined
(
__clang__
)
&
&
XXH_HAS_BUILTIN
(
__builtin_altivec_vmuleuw
)
#
define
XXH_vec_mulo
__builtin_altivec_vmulouw
#
define
XXH_vec_mule
__builtin_altivec_vmuleuw
#
else
XXH_FORCE_INLINE
xxh_u64x2
XXH_vec_mulo
(
xxh_u32x4
a
xxh_u32x4
b
)
{
xxh_u64x2
result
;
__asm__
(
"
vmulouw
%
0
%
1
%
2
"
:
"
=
v
"
(
result
)
:
"
v
"
(
a
)
"
v
"
(
b
)
)
;
return
result
;
}
XXH_FORCE_INLINE
xxh_u64x2
XXH_vec_mule
(
xxh_u32x4
a
xxh_u32x4
b
)
{
xxh_u64x2
result
;
__asm__
(
"
vmuleuw
%
0
%
1
%
2
"
:
"
=
v
"
(
result
)
:
"
v
"
(
a
)
"
v
"
(
b
)
)
;
return
result
;
}
#
endif
#
endif
#
if
defined
(
XXH_NO_PREFETCH
)
#
define
XXH_PREFETCH
(
ptr
)
(
void
)
(
ptr
)
/
*
disabled
*
/
#
else
#
if
defined
(
_MSC_VER
)
&
&
(
defined
(
_M_X64
)
|
|
defined
(
_M_I86
)
)
#
include
<
mmintrin
.
h
>
#
define
XXH_PREFETCH
(
ptr
)
_mm_prefetch
(
(
const
char
*
)
(
ptr
)
_MM_HINT_T0
)
#
elif
defined
(
__GNUC__
)
&
&
(
(
__GNUC__
>
=
4
)
|
|
(
(
__GNUC__
=
=
3
)
&
&
(
__GNUC_MINOR__
>
=
1
)
)
)
#
define
XXH_PREFETCH
(
ptr
)
__builtin_prefetch
(
(
ptr
)
0
/
*
rw
=
=
read
*
/
3
/
*
locality
*
/
)
#
else
#
define
XXH_PREFETCH
(
ptr
)
(
void
)
(
ptr
)
/
*
disabled
*
/
#
endif
#
endif
#
define
XXH_SECRET_DEFAULT_SIZE
192
/
*
minimum
XXH3_SECRET_SIZE_MIN
*
/
#
if
(
XXH_SECRET_DEFAULT_SIZE
<
XXH3_SECRET_SIZE_MIN
)
#
error
"
default
keyset
is
not
large
enough
"
#
endif
XXH_ALIGN
(
64
)
static
const
xxh_u8
XXH3_kSecret
[
XXH_SECRET_DEFAULT_SIZE
]
=
{
0xb8
0xfe
0x6c
0x39
0x23
0xa4
0x4b
0xbe
0x7c
0x01
0x81
0x2c
0xf7
0x21
0xad
0x1c
0xde
0xd4
0x6d
0xe9
0x83
0x90
0x97
0xdb
0x72
0x40
0xa4
0xa4
0xb7
0xb3
0x67
0x1f
0xcb
0x79
0xe6
0x4e
0xcc
0xc0
0xe5
0x78
0x82
0x5a
0xd0
0x7d
0xcc
0xff
0x72
0x21
0xb8
0x08
0x46
0x74
0xf7
0x43
0x24
0x8e
0xe0
0x35
0x90
0xe6
0x81
0x3a
0x26
0x4c
0x3c
0x28
0x52
0xbb
0x91
0xc3
0x00
0xcb
0x88
0xd0
0x65
0x8b
0x1b
0x53
0x2e
0xa3
0x71
0x64
0x48
0x97
0xa2
0x0d
0xf9
0x4e
0x38
0x19
0xef
0x46
0xa9
0xde
0xac
0xd8
0xa8
0xfa
0x76
0x3f
0xe3
0x9c
0x34
0x3f
0xf9
0xdc
0xbb
0xc7
0xc7
0x0b
0x4f
0x1d
0x8a
0x51
0xe0
0x4b
0xcd
0xb4
0x59
0x31
0xc8
0x9f
0x7e
0xc9
0xd9
0x78
0x73
0x64
0xea
0xc5
0xac
0x83
0x34
0xd3
0xeb
0xc3
0xc5
0x81
0xa0
0xff
0xfa
0x13
0x63
0xeb
0x17
0x0d
0xdd
0x51
0xb7
0xf0
0xda
0x49
0xd3
0x16
0x55
0x26
0x29
0xd4
0x68
0x9e
0x2b
0x16
0xbe
0x58
0x7d
0x47
0xa1
0xfc
0x8f
0xf8
0xb8
0xd1
0x7a
0xd0
0x31
0xce
0x45
0xcb
0x3a
0x8f
0x95
0x16
0x04
0x28
0xaf
0xd7
0xfb
0xca
0xbb
0x4b
0x40
0x7e
}
;
#
ifdef
XXH_OLD_NAMES
#
define
kSecret
XXH3_kSecret
#
endif
#
if
defined
(
_MSC_VER
)
&
&
defined
(
_M_IX86
)
#
include
<
intrin
.
h
>
#
define
XXH_mult32to64
(
x
y
)
__emulu
(
(
unsigned
)
(
x
)
(
unsigned
)
(
y
)
)
#
else
#
define
XXH_mult32to64
(
x
y
)
(
(
xxh_u64
)
(
xxh_u32
)
(
x
)
*
(
xxh_u64
)
(
xxh_u32
)
(
y
)
)
#
endif
static
XXH128_hash_t
XXH_mult64to128
(
xxh_u64
lhs
xxh_u64
rhs
)
{
#
if
defined
(
__GNUC__
)
&
&
!
defined
(
__wasm__
)
\
&
&
defined
(
__SIZEOF_INT128__
)
\
|
|
(
defined
(
_INTEGRAL_MAX_BITS
)
&
&
_INTEGRAL_MAX_BITS
>
=
128
)
__uint128_t
const
product
=
(
__uint128_t
)
lhs
*
(
__uint128_t
)
rhs
;
XXH128_hash_t
r128
;
r128
.
low64
=
(
xxh_u64
)
(
product
)
;
r128
.
high64
=
(
xxh_u64
)
(
product
>
>
64
)
;
return
r128
;
#
elif
defined
(
_M_X64
)
|
|
defined
(
_M_IA64
)
#
ifndef
_MSC_VER
#
pragma
intrinsic
(
_umul128
)
#
endif
xxh_u64
product_high
;
xxh_u64
const
product_low
=
_umul128
(
lhs
rhs
&
product_high
)
;
XXH128_hash_t
r128
;
r128
.
low64
=
product_low
;
r128
.
high64
=
product_high
;
return
r128
;
#
else
xxh_u64
const
lo_lo
=
XXH_mult32to64
(
lhs
&
0xFFFFFFFF
rhs
&
0xFFFFFFFF
)
;
xxh_u64
const
hi_lo
=
XXH_mult32to64
(
lhs
>
>
32
rhs
&
0xFFFFFFFF
)
;
xxh_u64
const
lo_hi
=
XXH_mult32to64
(
lhs
&
0xFFFFFFFF
rhs
>
>
32
)
;
xxh_u64
const
hi_hi
=
XXH_mult32to64
(
lhs
>
>
32
rhs
>
>
32
)
;
xxh_u64
const
cross
=
(
lo_lo
>
>
32
)
+
(
hi_lo
&
0xFFFFFFFF
)
+
lo_hi
;
xxh_u64
const
upper
=
(
hi_lo
>
>
32
)
+
(
cross
>
>
32
)
+
hi_hi
;
xxh_u64
const
lower
=
(
cross
<
<
32
)
|
(
lo_lo
&
0xFFFFFFFF
)
;
XXH128_hash_t
r128
;
r128
.
low64
=
lower
;
r128
.
high64
=
upper
;
return
r128
;
#
endif
}
static
xxh_u64
XXH3_mul128_fold64
(
xxh_u64
lhs
xxh_u64
rhs
)
{
XXH128_hash_t
product
=
XXH_mult64to128
(
lhs
rhs
)
;
return
product
.
low64
^
product
.
high64
;
}
XXH_FORCE_INLINE
xxh_u64
XXH_xorshift64
(
xxh_u64
v64
int
shift
)
{
XXH_ASSERT
(
0
<
=
shift
&
&
shift
<
64
)
;
return
v64
^
(
v64
>
>
shift
)
;
}
static
XXH64_hash_t
XXH3_avalanche
(
xxh_u64
h64
)
{
h64
=
XXH_xorshift64
(
h64
37
)
;
h64
*
=
0x165667919E3779F9ULL
;
h64
=
XXH_xorshift64
(
h64
32
)
;
return
h64
;
}
static
XXH64_hash_t
XXH3_rrmxmx
(
xxh_u64
h64
xxh_u64
len
)
{
h64
^
=
XXH_rotl64
(
h64
49
)
^
XXH_rotl64
(
h64
24
)
;
h64
*
=
0x9FB21C651E98DF25ULL
;
h64
^
=
(
h64
>
>
35
)
+
len
;
h64
*
=
0x9FB21C651E98DF25ULL
;
return
XXH_xorshift64
(
h64
28
)
;
}
XXH_FORCE_INLINE
XXH64_hash_t
XXH3_len_1to3_64b
(
const
xxh_u8
*
input
size_t
len
const
xxh_u8
*
secret
XXH64_hash_t
seed
)
{
XXH_ASSERT
(
input
!
=
NULL
)
;
XXH_ASSERT
(
1
<
=
len
&
&
len
<
=
3
)
;
XXH_ASSERT
(
secret
!
=
NULL
)
;
{
xxh_u8
const
c1
=
input
[
0
]
;
xxh_u8
const
c2
=
input
[
len
>
>
1
]
;
xxh_u8
const
c3
=
input
[
len
-
1
]
;
xxh_u32
const
combined
=
(
(
xxh_u32
)
c1
<
<
16
)
|
(
(
xxh_u32
)
c2
<
<
24
)
|
(
(
xxh_u32
)
c3
<
<
0
)
|
(
(
xxh_u32
)
len
<
<
8
)
;
xxh_u64
const
bitflip
=
(
XXH_readLE32
(
secret
)
^
XXH_readLE32
(
secret
+
4
)
)
+
seed
;
xxh_u64
const
keyed
=
(
xxh_u64
)
combined
^
bitflip
;
return
XXH64_avalanche
(
keyed
)
;
}
}
XXH_FORCE_INLINE
XXH64_hash_t
XXH3_len_4to8_64b
(
const
xxh_u8
*
input
size_t
len
const
xxh_u8
*
secret
XXH64_hash_t
seed
)
{
XXH_ASSERT
(
input
!
=
NULL
)
;
XXH_ASSERT
(
secret
!
=
NULL
)
;
XXH_ASSERT
(
4
<
=
len
&
&
len
<
8
)
;
seed
^
=
(
xxh_u64
)
XXH_swap32
(
(
xxh_u32
)
seed
)
<
<
32
;
{
xxh_u32
const
input1
=
XXH_readLE32
(
input
)
;
xxh_u32
const
input2
=
XXH_readLE32
(
input
+
len
-
4
)
;
xxh_u64
const
bitflip
=
(
XXH_readLE64
(
secret
+
8
)
^
XXH_readLE64
(
secret
+
16
)
)
-
seed
;
xxh_u64
const
input64
=
input2
+
(
(
(
xxh_u64
)
input1
)
<
<
32
)
;
xxh_u64
const
keyed
=
input64
^
bitflip
;
return
XXH3_rrmxmx
(
keyed
len
)
;
}
}
XXH_FORCE_INLINE
XXH64_hash_t
XXH3_len_9to16_64b
(
const
xxh_u8
*
input
size_t
len
const
xxh_u8
*
secret
XXH64_hash_t
seed
)
{
XXH_ASSERT
(
input
!
=
NULL
)
;
XXH_ASSERT
(
secret
!
=
NULL
)
;
XXH_ASSERT
(
8
<
=
len
&
&
len
<
=
16
)
;
{
xxh_u64
const
bitflip1
=
(
XXH_readLE64
(
secret
+
24
)
^
XXH_readLE64
(
secret
+
32
)
)
+
seed
;
xxh_u64
const
bitflip2
=
(
XXH_readLE64
(
secret
+
40
)
^
XXH_readLE64
(
secret
+
48
)
)
-
seed
;
xxh_u64
const
input_lo
=
XXH_readLE64
(
input
)
^
bitflip1
;
xxh_u64
const
input_hi
=
XXH_readLE64
(
input
+
len
-
8
)
^
bitflip2
;
xxh_u64
const
acc
=
len
+
XXH_swap64
(
input_lo
)
+
input_hi
+
XXH3_mul128_fold64
(
input_lo
input_hi
)
;
return
XXH3_avalanche
(
acc
)
;
}
}
XXH_FORCE_INLINE
XXH64_hash_t
XXH3_len_0to16_64b
(
const
xxh_u8
*
input
size_t
len
const
xxh_u8
*
secret
XXH64_hash_t
seed
)
{
XXH_ASSERT
(
len
<
=
16
)
;
{
if
(
XXH_likely
(
len
>
8
)
)
return
XXH3_len_9to16_64b
(
input
len
secret
seed
)
;
if
(
XXH_likely
(
len
>
=
4
)
)
return
XXH3_len_4to8_64b
(
input
len
secret
seed
)
;
if
(
len
)
return
XXH3_len_1to3_64b
(
input
len
secret
seed
)
;
return
XXH64_avalanche
(
seed
^
(
XXH_readLE64
(
secret
+
56
)
^
XXH_readLE64
(
secret
+
64
)
)
)
;
}
}
XXH_FORCE_INLINE
xxh_u64
XXH3_mix16B
(
const
xxh_u8
*
XXH_RESTRICT
input
const
xxh_u8
*
XXH_RESTRICT
secret
xxh_u64
seed64
)
{
#
if
defined
(
__GNUC__
)
&
&
!
defined
(
__clang__
)
\
&
&
defined
(
__i386__
)
&
&
defined
(
__SSE2__
)
\
&
&
!
defined
(
XXH_ENABLE_AUTOVECTORIZE
)
__asm__
(
"
"
:
"
+
r
"
(
seed64
)
)
;
#
endif
{
xxh_u64
const
input_lo
=
XXH_readLE64
(
input
)
;
xxh_u64
const
input_hi
=
XXH_readLE64
(
input
+
8
)
;
return
XXH3_mul128_fold64
(
input_lo
^
(
XXH_readLE64
(
secret
)
+
seed64
)
input_hi
^
(
XXH_readLE64
(
secret
+
8
)
-
seed64
)
)
;
}
}
XXH_FORCE_INLINE
XXH64_hash_t
XXH3_len_17to128_64b
(
const
xxh_u8
*
XXH_RESTRICT
input
size_t
len
const
xxh_u8
*
XXH_RESTRICT
secret
size_t
secretSize
XXH64_hash_t
seed
)
{
XXH_ASSERT
(
secretSize
>
=
XXH3_SECRET_SIZE_MIN
)
;
(
void
)
secretSize
;
XXH_ASSERT
(
16
<
len
&
&
len
<
=
128
)
;
{
xxh_u64
acc
=
len
*
XXH_PRIME64_1
;
if
(
len
>
32
)
{
if
(
len
>
64
)
{
if
(
len
>
96
)
{
acc
+
=
XXH3_mix16B
(
input
+
48
secret
+
96
seed
)
;
acc
+
=
XXH3_mix16B
(
input
+
len
-
64
secret
+
112
seed
)
;
}
acc
+
=
XXH3_mix16B
(
input
+
32
secret
+
64
seed
)
;
acc
+
=
XXH3_mix16B
(
input
+
len
-
48
secret
+
80
seed
)
;
}
acc
+
=
XXH3_mix16B
(
input
+
16
secret
+
32
seed
)
;
acc
+
=
XXH3_mix16B
(
input
+
len
-
32
secret
+
48
seed
)
;
}
acc
+
=
XXH3_mix16B
(
input
+
0
secret
+
0
seed
)
;
acc
+
=
XXH3_mix16B
(
input
+
len
-
16
secret
+
16
seed
)
;
return
XXH3_avalanche
(
acc
)
;
}
}
#
define
XXH3_MIDSIZE_MAX
240
XXH_NO_INLINE
XXH64_hash_t
XXH3_len_129to240_64b
(
const
xxh_u8
*
XXH_RESTRICT
input
size_t
len
const
xxh_u8
*
XXH_RESTRICT
secret
size_t
secretSize
XXH64_hash_t
seed
)
{
XXH_ASSERT
(
secretSize
>
=
XXH3_SECRET_SIZE_MIN
)
;
(
void
)
secretSize
;
XXH_ASSERT
(
128
<
len
&
&
len
<
=
XXH3_MIDSIZE_MAX
)
;
#
define
XXH3_MIDSIZE_STARTOFFSET
3
#
define
XXH3_MIDSIZE_LASTOFFSET
17
{
xxh_u64
acc
=
len
*
XXH_PRIME64_1
;
int
const
nbRounds
=
(
int
)
len
/
16
;
int
i
;
for
(
i
=
0
;
i
<
8
;
i
+
+
)
{
acc
+
=
XXH3_mix16B
(
input
+
(
16
*
i
)
secret
+
(
16
*
i
)
seed
)
;
}
acc
=
XXH3_avalanche
(
acc
)
;
XXH_ASSERT
(
nbRounds
>
=
8
)
;
#
if
defined
(
__clang__
)
\
&
&
(
defined
(
__ARM_NEON
)
|
|
defined
(
__ARM_NEON__
)
)
\
&
&
!
defined
(
XXH_ENABLE_AUTOVECTORIZE
)
#
pragma
clang
loop
vectorize
(
disable
)
#
endif
for
(
i
=
8
;
i
<
nbRounds
;
i
+
+
)
{
acc
+
=
XXH3_mix16B
(
input
+
(
16
*
i
)
secret
+
(
16
*
(
i
-
8
)
)
+
XXH3_MIDSIZE_STARTOFFSET
seed
)
;
}
acc
+
=
XXH3_mix16B
(
input
+
len
-
16
secret
+
XXH3_SECRET_SIZE_MIN
-
XXH3_MIDSIZE_LASTOFFSET
seed
)
;
return
XXH3_avalanche
(
acc
)
;
}
}
#
define
XXH_STRIPE_LEN
64
#
define
XXH_SECRET_CONSUME_RATE
8
/
*
nb
of
secret
bytes
consumed
at
each
accumulation
*
/
#
define
XXH_ACC_NB
(
XXH_STRIPE_LEN
/
sizeof
(
xxh_u64
)
)
#
ifdef
XXH_OLD_NAMES
#
define
STRIPE_LEN
XXH_STRIPE_LEN
#
define
ACC_NB
XXH_ACC_NB
#
endif
XXH_FORCE_INLINE
void
XXH_writeLE64
(
void
*
dst
xxh_u64
v64
)
{
if
(
!
XXH_CPU_LITTLE_ENDIAN
)
v64
=
XXH_swap64
(
v64
)
;
memcpy
(
dst
&
v64
sizeof
(
v64
)
)
;
}
#
if
!
defined
(
__VMS
)
\
&
&
(
defined
(
__cplusplus
)
\
|
|
(
defined
(
__STDC_VERSION__
)
&
&
(
__STDC_VERSION__
>
=
199901L
)
)
)
typedef
int64_t
xxh_i64
;
#
else
typedef
long
long
xxh_i64
;
#
endif
#
if
(
XXH_VECTOR
=
=
XXH_AVX512
)
|
|
defined
(
XXH_X86DISPATCH
)
#
ifndef
XXH_TARGET_AVX512
#
define
XXH_TARGET_AVX512
#
endif
XXH_FORCE_INLINE
XXH_TARGET_AVX512
void
XXH3_accumulate_512_avx512
(
void
*
XXH_RESTRICT
acc
const
void
*
XXH_RESTRICT
input
const
void
*
XXH_RESTRICT
secret
)
{
XXH_ALIGN
(
64
)
__m512i
*
const
xacc
=
(
__m512i
*
)
acc
;
XXH_ASSERT
(
(
(
(
size_t
)
acc
)
&
63
)
=
=
0
)
;
XXH_STATIC_ASSERT
(
XXH_STRIPE_LEN
=
=
sizeof
(
__m512i
)
)
;
{
__m512i
const
data_vec
=
_mm512_loadu_si512
(
input
)
;
__m512i
const
key_vec
=
_mm512_loadu_si512
(
secret
)
;
__m512i
const
data_key
=
_mm512_xor_si512
(
data_vec
key_vec
)
;
__m512i
const
data_key_lo
=
_mm512_shuffle_epi32
(
data_key
(
_MM_PERM_ENUM
)
_MM_SHUFFLE
(
0
3
0
1
)
)
;
__m512i
const
product
=
_mm512_mul_epu32
(
data_key
data_key_lo
)
;
__m512i
const
data_swap
=
_mm512_shuffle_epi32
(
data_vec
(
_MM_PERM_ENUM
)
_MM_SHUFFLE
(
1
0
3
2
)
)
;
__m512i
const
sum
=
_mm512_add_epi64
(
*
xacc
data_swap
)
;
*
xacc
=
_mm512_add_epi64
(
product
sum
)
;
}
}
XXH_FORCE_INLINE
XXH_TARGET_AVX512
void
XXH3_scrambleAcc_avx512
(
void
*
XXH_RESTRICT
acc
const
void
*
XXH_RESTRICT
secret
)
{
XXH_ASSERT
(
(
(
(
size_t
)
acc
)
&
63
)
=
=
0
)
;
XXH_STATIC_ASSERT
(
XXH_STRIPE_LEN
=
=
sizeof
(
__m512i
)
)
;
{
XXH_ALIGN
(
64
)
__m512i
*
const
xacc
=
(
__m512i
*
)
acc
;
const
__m512i
prime32
=
_mm512_set1_epi32
(
(
int
)
XXH_PRIME32_1
)
;
__m512i
const
acc_vec
=
*
xacc
;
__m512i
const
shifted
=
_mm512_srli_epi64
(
acc_vec
47
)
;
__m512i
const
data_vec
=
_mm512_xor_si512
(
acc_vec
shifted
)
;
__m512i
const
key_vec
=
_mm512_loadu_si512
(
secret
)
;
__m512i
const
data_key
=
_mm512_xor_si512
(
data_vec
key_vec
)
;
__m512i
const
data_key_hi
=
_mm512_shuffle_epi32
(
data_key
(
_MM_PERM_ENUM
)
_MM_SHUFFLE
(
0
3
0
1
)
)
;
__m512i
const
prod_lo
=
_mm512_mul_epu32
(
data_key
prime32
)
;
__m512i
const
prod_hi
=
_mm512_mul_epu32
(
data_key_hi
prime32
)
;
*
xacc
=
_mm512_add_epi64
(
prod_lo
_mm512_slli_epi64
(
prod_hi
32
)
)
;
}
}
XXH_FORCE_INLINE
XXH_TARGET_AVX512
void
XXH3_initCustomSecret_avx512
(
void
*
XXH_RESTRICT
customSecret
xxh_u64
seed64
)
{
XXH_STATIC_ASSERT
(
(
XXH_SECRET_DEFAULT_SIZE
&
63
)
=
=
0
)
;
XXH_STATIC_ASSERT
(
XXH_SEC_ALIGN
=
=
64
)
;
XXH_ASSERT
(
(
(
size_t
)
customSecret
&
63
)
=
=
0
)
;
(
void
)
(
&
XXH_writeLE64
)
;
{
int
const
nbRounds
=
XXH_SECRET_DEFAULT_SIZE
/
sizeof
(
__m512i
)
;
__m512i
const
seed
=
_mm512_mask_set1_epi64
(
_mm512_set1_epi64
(
(
xxh_i64
)
seed64
)
0xAA
-
(
xxh_i64
)
seed64
)
;
XXH_ALIGN
(
64
)
const
__m512i
*
const
src
=
(
const
__m512i
*
)
XXH3_kSecret
;
XXH_ALIGN
(
64
)
__m512i
*
const
dest
=
(
__m512i
*
)
customSecret
;
int
i
;
for
(
i
=
0
;
i
<
nbRounds
;
+
+
i
)
{
union
{
XXH_ALIGN
(
64
)
const
__m512i
*
cp
;
XXH_ALIGN
(
64
)
void
*
p
;
}
remote_const_void
;
remote_const_void
.
cp
=
src
+
i
;
dest
[
i
]
=
_mm512_add_epi64
(
_mm512_stream_load_si512
(
remote_const_void
.
p
)
seed
)
;
}
}
}
#
endif
#
if
(
XXH_VECTOR
=
=
XXH_AVX2
)
|
|
defined
(
XXH_X86DISPATCH
)
#
ifndef
XXH_TARGET_AVX2
#
define
XXH_TARGET_AVX2
#
endif
XXH_FORCE_INLINE
XXH_TARGET_AVX2
void
XXH3_accumulate_512_avx2
(
void
*
XXH_RESTRICT
acc
const
void
*
XXH_RESTRICT
input
const
void
*
XXH_RESTRICT
secret
)
{
XXH_ASSERT
(
(
(
(
size_t
)
acc
)
&
31
)
=
=
0
)
;
{
XXH_ALIGN
(
32
)
__m256i
*
const
xacc
=
(
__m256i
*
)
acc
;
const
__m256i
*
const
xinput
=
(
const
__m256i
*
)
input
;
const
__m256i
*
const
xsecret
=
(
const
__m256i
*
)
secret
;
size_t
i
;
for
(
i
=
0
;
i
<
XXH_STRIPE_LEN
/
sizeof
(
__m256i
)
;
i
+
+
)
{
__m256i
const
data_vec
=
_mm256_loadu_si256
(
xinput
+
i
)
;
__m256i
const
key_vec
=
_mm256_loadu_si256
(
xsecret
+
i
)
;
__m256i
const
data_key
=
_mm256_xor_si256
(
data_vec
key_vec
)
;
__m256i
const
data_key_lo
=
_mm256_shuffle_epi32
(
data_key
_MM_SHUFFLE
(
0
3
0
1
)
)
;
__m256i
const
product
=
_mm256_mul_epu32
(
data_key
data_key_lo
)
;
__m256i
const
data_swap
=
_mm256_shuffle_epi32
(
data_vec
_MM_SHUFFLE
(
1
0
3
2
)
)
;
__m256i
const
sum
=
_mm256_add_epi64
(
xacc
[
i
]
data_swap
)
;
xacc
[
i
]
=
_mm256_add_epi64
(
product
sum
)
;
}
}
}
XXH_FORCE_INLINE
XXH_TARGET_AVX2
void
XXH3_scrambleAcc_avx2
(
void
*
XXH_RESTRICT
acc
const
void
*
XXH_RESTRICT
secret
)
{
XXH_ASSERT
(
(
(
(
size_t
)
acc
)
&
31
)
=
=
0
)
;
{
XXH_ALIGN
(
32
)
__m256i
*
const
xacc
=
(
__m256i
*
)
acc
;
const
__m256i
*
const
xsecret
=
(
const
__m256i
*
)
secret
;
const
__m256i
prime32
=
_mm256_set1_epi32
(
(
int
)
XXH_PRIME32_1
)
;
size_t
i
;
for
(
i
=
0
;
i
<
XXH_STRIPE_LEN
/
sizeof
(
__m256i
)
;
i
+
+
)
{
__m256i
const
acc_vec
=
xacc
[
i
]
;
__m256i
const
shifted
=
_mm256_srli_epi64
(
acc_vec
47
)
;
__m256i
const
data_vec
=
_mm256_xor_si256
(
acc_vec
shifted
)
;
__m256i
const
key_vec
=
_mm256_loadu_si256
(
xsecret
+
i
)
;
__m256i
const
data_key
=
_mm256_xor_si256
(
data_vec
key_vec
)
;
__m256i
const
data_key_hi
=
_mm256_shuffle_epi32
(
data_key
_MM_SHUFFLE
(
0
3
0
1
)
)
;
__m256i
const
prod_lo
=
_mm256_mul_epu32
(
data_key
prime32
)
;
__m256i
const
prod_hi
=
_mm256_mul_epu32
(
data_key_hi
prime32
)
;
xacc
[
i
]
=
_mm256_add_epi64
(
prod_lo
_mm256_slli_epi64
(
prod_hi
32
)
)
;
}
}
}
XXH_FORCE_INLINE
XXH_TARGET_AVX2
void
XXH3_initCustomSecret_avx2
(
void
*
XXH_RESTRICT
customSecret
xxh_u64
seed64
)
{
XXH_STATIC_ASSERT
(
(
XXH_SECRET_DEFAULT_SIZE
&
31
)
=
=
0
)
;
XXH_STATIC_ASSERT
(
(
XXH_SECRET_DEFAULT_SIZE
/
sizeof
(
__m256i
)
)
=
=
6
)
;
XXH_STATIC_ASSERT
(
XXH_SEC_ALIGN
<
=
64
)
;
(
void
)
(
&
XXH_writeLE64
)
;
XXH_PREFETCH
(
customSecret
)
;
{
__m256i
const
seed
=
_mm256_set_epi64x
(
-
(
xxh_i64
)
seed64
(
xxh_i64
)
seed64
-
(
xxh_i64
)
seed64
(
xxh_i64
)
seed64
)
;
XXH_ALIGN
(
64
)
const
__m256i
*
const
src
=
(
const
__m256i
*
)
XXH3_kSecret
;
XXH_ALIGN
(
64
)
__m256i
*
dest
=
(
__m256i
*
)
customSecret
;
#
if
defined
(
__GNUC__
)
|
|
defined
(
__clang__
)
__asm__
(
"
"
:
"
+
r
"
(
dest
)
)
;
#
endif
dest
[
0
]
=
_mm256_add_epi64
(
_mm256_stream_load_si256
(
src
+
0
)
seed
)
;
dest
[
1
]
=
_mm256_add_epi64
(
_mm256_stream_load_si256
(
src
+
1
)
seed
)
;
dest
[
2
]
=
_mm256_add_epi64
(
_mm256_stream_load_si256
(
src
+
2
)
seed
)
;
dest
[
3
]
=
_mm256_add_epi64
(
_mm256_stream_load_si256
(
src
+
3
)
seed
)
;
dest
[
4
]
=
_mm256_add_epi64
(
_mm256_stream_load_si256
(
src
+
4
)
seed
)
;
dest
[
5
]
=
_mm256_add_epi64
(
_mm256_stream_load_si256
(
src
+
5
)
seed
)
;
}
}
#
endif
#
if
(
XXH_VECTOR
=
=
XXH_SSE2
)
|
|
defined
(
XXH_X86DISPATCH
)
#
ifndef
XXH_TARGET_SSE2
#
define
XXH_TARGET_SSE2
#
endif
XXH_FORCE_INLINE
XXH_TARGET_SSE2
void
XXH3_accumulate_512_sse2
(
void
*
XXH_RESTRICT
acc
const
void
*
XXH_RESTRICT
input
const
void
*
XXH_RESTRICT
secret
)
{
XXH_ASSERT
(
(
(
(
size_t
)
acc
)
&
15
)
=
=
0
)
;
{
XXH_ALIGN
(
16
)
__m128i
*
const
xacc
=
(
__m128i
*
)
acc
;
const
__m128i
*
const
xinput
=
(
const
__m128i
*
)
input
;
const
__m128i
*
const
xsecret
=
(
const
__m128i
*
)
secret
;
size_t
i
;
for
(
i
=
0
;
i
<
XXH_STRIPE_LEN
/
sizeof
(
__m128i
)
;
i
+
+
)
{
__m128i
const
data_vec
=
_mm_loadu_si128
(
xinput
+
i
)
;
__m128i
const
key_vec
=
_mm_loadu_si128
(
xsecret
+
i
)
;
__m128i
const
data_key
=
_mm_xor_si128
(
data_vec
key_vec
)
;
__m128i
const
data_key_lo
=
_mm_shuffle_epi32
(
data_key
_MM_SHUFFLE
(
0
3
0
1
)
)
;
__m128i
const
product
=
_mm_mul_epu32
(
data_key
data_key_lo
)
;
__m128i
const
data_swap
=
_mm_shuffle_epi32
(
data_vec
_MM_SHUFFLE
(
1
0
3
2
)
)
;
__m128i
const
sum
=
_mm_add_epi64
(
xacc
[
i
]
data_swap
)
;
xacc
[
i
]
=
_mm_add_epi64
(
product
sum
)
;
}
}
}
XXH_FORCE_INLINE
XXH_TARGET_SSE2
void
XXH3_scrambleAcc_sse2
(
void
*
XXH_RESTRICT
acc
const
void
*
XXH_RESTRICT
secret
)
{
XXH_ASSERT
(
(
(
(
size_t
)
acc
)
&
15
)
=
=
0
)
;
{
XXH_ALIGN
(
16
)
__m128i
*
const
xacc
=
(
__m128i
*
)
acc
;
const
__m128i
*
const
xsecret
=
(
const
__m128i
*
)
secret
;
const
__m128i
prime32
=
_mm_set1_epi32
(
(
int
)
XXH_PRIME32_1
)
;
size_t
i
;
for
(
i
=
0
;
i
<
XXH_STRIPE_LEN
/
sizeof
(
__m128i
)
;
i
+
+
)
{
__m128i
const
acc_vec
=
xacc
[
i
]
;
__m128i
const
shifted
=
_mm_srli_epi64
(
acc_vec
47
)
;
__m128i
const
data_vec
=
_mm_xor_si128
(
acc_vec
shifted
)
;
__m128i
const
key_vec
=
_mm_loadu_si128
(
xsecret
+
i
)
;
__m128i
const
data_key
=
_mm_xor_si128
(
data_vec
key_vec
)
;
__m128i
const
data_key_hi
=
_mm_shuffle_epi32
(
data_key
_MM_SHUFFLE
(
0
3
0
1
)
)
;
__m128i
const
prod_lo
=
_mm_mul_epu32
(
data_key
prime32
)
;
__m128i
const
prod_hi
=
_mm_mul_epu32
(
data_key_hi
prime32
)
;
xacc
[
i
]
=
_mm_add_epi64
(
prod_lo
_mm_slli_epi64
(
prod_hi
32
)
)
;
}
}
}
XXH_FORCE_INLINE
XXH_TARGET_SSE2
void
XXH3_initCustomSecret_sse2
(
void
*
XXH_RESTRICT
customSecret
xxh_u64
seed64
)
{
XXH_STATIC_ASSERT
(
(
XXH_SECRET_DEFAULT_SIZE
&
15
)
=
=
0
)
;
(
void
)
(
&
XXH_writeLE64
)
;
{
int
const
nbRounds
=
XXH_SECRET_DEFAULT_SIZE
/
sizeof
(
__m128i
)
;
#
if
defined
(
_MSC_VER
)
&
&
defined
(
_M_IX86
)
&
&
_MSC_VER
<
1900
XXH_ALIGN
(
16
)
const
xxh_i64
seed64x2
[
2
]
=
{
(
xxh_i64
)
seed64
-
(
xxh_i64
)
seed64
}
;
__m128i
const
seed
=
_mm_load_si128
(
(
__m128i
const
*
)
seed64x2
)
;
#
else
__m128i
const
seed
=
_mm_set_epi64x
(
-
(
xxh_i64
)
seed64
(
xxh_i64
)
seed64
)
;
#
endif
int
i
;
XXH_ALIGN
(
64
)
const
float
*
const
src
=
(
float
const
*
)
XXH3_kSecret
;
XXH_ALIGN
(
XXH_SEC_ALIGN
)
__m128i
*
dest
=
(
__m128i
*
)
customSecret
;
#
if
defined
(
__GNUC__
)
|
|
defined
(
__clang__
)
__asm__
(
"
"
:
"
+
r
"
(
dest
)
)
;
#
endif
for
(
i
=
0
;
i
<
nbRounds
;
+
+
i
)
{
dest
[
i
]
=
_mm_add_epi64
(
_mm_castps_si128
(
_mm_load_ps
(
src
+
i
*
4
)
)
seed
)
;
}
}
}
#
endif
#
if
(
XXH_VECTOR
=
=
XXH_NEON
)
XXH_FORCE_INLINE
void
XXH3_accumulate_512_neon
(
void
*
XXH_RESTRICT
acc
const
void
*
XXH_RESTRICT
input
const
void
*
XXH_RESTRICT
secret
)
{
XXH_ASSERT
(
(
(
(
size_t
)
acc
)
&
15
)
=
=
0
)
;
{
XXH_ALIGN
(
16
)
uint64x2_t
*
const
xacc
=
(
uint64x2_t
*
)
acc
;
uint8_t
const
*
const
xinput
=
(
const
uint8_t
*
)
input
;
uint8_t
const
*
const
xsecret
=
(
const
uint8_t
*
)
secret
;
size_t
i
;
for
(
i
=
0
;
i
<
XXH_STRIPE_LEN
/
sizeof
(
uint64x2_t
)
;
i
+
+
)
{
uint8x16_t
data_vec
=
vld1q_u8
(
xinput
+
(
i
*
16
)
)
;
uint8x16_t
key_vec
=
vld1q_u8
(
xsecret
+
(
i
*
16
)
)
;
uint64x2_t
data_key
;
uint32x2_t
data_key_lo
data_key_hi
;
uint64x2_t
const
data64
=
vreinterpretq_u64_u8
(
data_vec
)
;
uint64x2_t
const
swapped
=
vextq_u64
(
data64
data64
1
)
;
xacc
[
i
]
=
vaddq_u64
(
xacc
[
i
]
swapped
)
;
data_key
=
vreinterpretq_u64_u8
(
veorq_u8
(
data_vec
key_vec
)
)
;
XXH_SPLIT_IN_PLACE
(
data_key
data_key_lo
data_key_hi
)
;
xacc
[
i
]
=
vmlal_u32
(
xacc
[
i
]
data_key_lo
data_key_hi
)
;
}
}
}
XXH_FORCE_INLINE
void
XXH3_scrambleAcc_neon
(
void
*
XXH_RESTRICT
acc
const
void
*
XXH_RESTRICT
secret
)
{
XXH_ASSERT
(
(
(
(
size_t
)
acc
)
&
15
)
=
=
0
)
;
{
uint64x2_t
*
xacc
=
(
uint64x2_t
*
)
acc
;
uint8_t
const
*
xsecret
=
(
uint8_t
const
*
)
secret
;
uint32x2_t
prime
=
vdup_n_u32
(
XXH_PRIME32_1
)
;
size_t
i
;
for
(
i
=
0
;
i
<
XXH_STRIPE_LEN
/
sizeof
(
uint64x2_t
)
;
i
+
+
)
{
uint64x2_t
acc_vec
=
xacc
[
i
]
;
uint64x2_t
shifted
=
vshrq_n_u64
(
acc_vec
47
)
;
uint64x2_t
data_vec
=
veorq_u64
(
acc_vec
shifted
)
;
uint8x16_t
key_vec
=
vld1q_u8
(
xsecret
+
(
i
*
16
)
)
;
uint64x2_t
data_key
=
veorq_u64
(
data_vec
vreinterpretq_u64_u8
(
key_vec
)
)
;
uint32x2_t
data_key_lo
data_key_hi
;
XXH_SPLIT_IN_PLACE
(
data_key
data_key_lo
data_key_hi
)
;
{
uint64x2_t
prod_hi
=
vmull_u32
(
data_key_hi
prime
)
;
xacc
[
i
]
=
vshlq_n_u64
(
prod_hi
32
)
;
xacc
[
i
]
=
vmlal_u32
(
xacc
[
i
]
data_key_lo
prime
)
;
}
}
}
}
#
endif
#
if
(
XXH_VECTOR
=
=
XXH_VSX
)
XXH_FORCE_INLINE
void
XXH3_accumulate_512_vsx
(
void
*
XXH_RESTRICT
acc
const
void
*
XXH_RESTRICT
input
const
void
*
XXH_RESTRICT
secret
)
{
xxh_u64x2
*
const
xacc
=
(
xxh_u64x2
*
)
acc
;
xxh_u64x2
const
*
const
xinput
=
(
xxh_u64x2
const
*
)
input
;
xxh_u64x2
const
*
const
xsecret
=
(
xxh_u64x2
const
*
)
secret
;
xxh_u64x2
const
v32
=
{
32
32
}
;
size_t
i
;
for
(
i
=
0
;
i
<
XXH_STRIPE_LEN
/
sizeof
(
xxh_u64x2
)
;
i
+
+
)
{
xxh_u64x2
const
data_vec
=
XXH_vec_loadu
(
xinput
+
i
)
;
xxh_u64x2
const
key_vec
=
XXH_vec_loadu
(
xsecret
+
i
)
;
xxh_u64x2
const
data_key
=
data_vec
^
key_vec
;
xxh_u32x4
const
shuffled
=
(
xxh_u32x4
)
vec_rl
(
data_key
v32
)
;
xxh_u64x2
const
product
=
XXH_vec_mulo
(
(
xxh_u32x4
)
data_key
shuffled
)
;
xacc
[
i
]
+
=
product
;
#
ifdef
__s390x__
xacc
[
i
]
+
=
vec_permi
(
data_vec
data_vec
2
)
;
#
else
xacc
[
i
]
+
=
vec_xxpermdi
(
data_vec
data_vec
2
)
;
#
endif
}
}
XXH_FORCE_INLINE
void
XXH3_scrambleAcc_vsx
(
void
*
XXH_RESTRICT
acc
const
void
*
XXH_RESTRICT
secret
)
{
XXH_ASSERT
(
(
(
(
size_t
)
acc
)
&
15
)
=
=
0
)
;
{
xxh_u64x2
*
const
xacc
=
(
xxh_u64x2
*
)
acc
;
const
xxh_u64x2
*
const
xsecret
=
(
const
xxh_u64x2
*
)
secret
;
xxh_u64x2
const
v32
=
{
32
32
}
;
xxh_u64x2
const
v47
=
{
47
47
}
;
xxh_u32x4
const
prime
=
{
XXH_PRIME32_1
XXH_PRIME32_1
XXH_PRIME32_1
XXH_PRIME32_1
}
;
size_t
i
;
for
(
i
=
0
;
i
<
XXH_STRIPE_LEN
/
sizeof
(
xxh_u64x2
)
;
i
+
+
)
{
xxh_u64x2
const
acc_vec
=
xacc
[
i
]
;
xxh_u64x2
const
data_vec
=
acc_vec
^
(
acc_vec
>
>
v47
)
;
xxh_u64x2
const
key_vec
=
XXH_vec_loadu
(
xsecret
+
i
)
;
xxh_u64x2
const
data_key
=
data_vec
^
key_vec
;
xxh_u64x2
const
prod_even
=
XXH_vec_mule
(
(
xxh_u32x4
)
data_key
prime
)
;
xxh_u64x2
const
prod_odd
=
XXH_vec_mulo
(
(
xxh_u32x4
)
data_key
prime
)
;
xacc
[
i
]
=
prod_odd
+
(
prod_even
<
<
v32
)
;
}
}
}
#
endif
XXH_FORCE_INLINE
void
XXH3_accumulate_512_scalar
(
void
*
XXH_RESTRICT
acc
const
void
*
XXH_RESTRICT
input
const
void
*
XXH_RESTRICT
secret
)
{
XXH_ALIGN
(
XXH_ACC_ALIGN
)
xxh_u64
*
const
xacc
=
(
xxh_u64
*
)
acc
;
const
xxh_u8
*
const
xinput
=
(
const
xxh_u8
*
)
input
;
const
xxh_u8
*
const
xsecret
=
(
const
xxh_u8
*
)
secret
;
size_t
i
;
XXH_ASSERT
(
(
(
size_t
)
acc
&
(
XXH_ACC_ALIGN
-
1
)
)
=
=
0
)
;
for
(
i
=
0
;
i
<
XXH_ACC_NB
;
i
+
+
)
{
xxh_u64
const
data_val
=
XXH_readLE64
(
xinput
+
8
*
i
)
;
xxh_u64
const
data_key
=
data_val
^
XXH_readLE64
(
xsecret
+
i
*
8
)
;
xacc
[
i
^
1
]
+
=
data_val
;
xacc
[
i
]
+
=
XXH_mult32to64
(
data_key
&
0xFFFFFFFF
data_key
>
>
32
)
;
}
}
XXH_FORCE_INLINE
void
XXH3_scrambleAcc_scalar
(
void
*
XXH_RESTRICT
acc
const
void
*
XXH_RESTRICT
secret
)
{
XXH_ALIGN
(
XXH_ACC_ALIGN
)
xxh_u64
*
const
xacc
=
(
xxh_u64
*
)
acc
;
const
xxh_u8
*
const
xsecret
=
(
const
xxh_u8
*
)
secret
;
size_t
i
;
XXH_ASSERT
(
(
(
(
size_t
)
acc
)
&
(
XXH_ACC_ALIGN
-
1
)
)
=
=
0
)
;
for
(
i
=
0
;
i
<
XXH_ACC_NB
;
i
+
+
)
{
xxh_u64
const
key64
=
XXH_readLE64
(
xsecret
+
8
*
i
)
;
xxh_u64
acc64
=
xacc
[
i
]
;
acc64
=
XXH_xorshift64
(
acc64
47
)
;
acc64
^
=
key64
;
acc64
*
=
XXH_PRIME32_1
;
xacc
[
i
]
=
acc64
;
}
}
XXH_FORCE_INLINE
void
XXH3_initCustomSecret_scalar
(
void
*
XXH_RESTRICT
customSecret
xxh_u64
seed64
)
{
const
xxh_u8
*
kSecretPtr
=
XXH3_kSecret
;
XXH_STATIC_ASSERT
(
(
XXH_SECRET_DEFAULT_SIZE
&
15
)
=
=
0
)
;
#
if
defined
(
__clang__
)
&
&
defined
(
__aarch64__
)
__asm__
(
"
"
:
"
+
r
"
(
kSecretPtr
)
)
;
#
endif
XXH_ASSERT
(
kSecretPtr
=
=
XXH3_kSecret
)
;
{
int
const
nbRounds
=
XXH_SECRET_DEFAULT_SIZE
/
16
;
int
i
;
for
(
i
=
0
;
i
<
nbRounds
;
i
+
+
)
{
xxh_u64
lo
=
XXH_readLE64
(
kSecretPtr
+
16
*
i
)
+
seed64
;
xxh_u64
hi
=
XXH_readLE64
(
kSecretPtr
+
16
*
i
+
8
)
-
seed64
;
XXH_writeLE64
(
(
xxh_u8
*
)
customSecret
+
16
*
i
lo
)
;
XXH_writeLE64
(
(
xxh_u8
*
)
customSecret
+
16
*
i
+
8
hi
)
;
}
}
}
typedef
void
(
*
XXH3_f_accumulate_512
)
(
void
*
XXH_RESTRICT
const
void
*
const
void
*
)
;
typedef
void
(
*
XXH3_f_scrambleAcc
)
(
void
*
XXH_RESTRICT
const
void
*
)
;
typedef
void
(
*
XXH3_f_initCustomSecret
)
(
void
*
XXH_RESTRICT
xxh_u64
)
;
#
if
(
XXH_VECTOR
=
=
XXH_AVX512
)
#
define
XXH3_accumulate_512
XXH3_accumulate_512_avx512
#
define
XXH3_scrambleAcc
XXH3_scrambleAcc_avx512
#
define
XXH3_initCustomSecret
XXH3_initCustomSecret_avx512
#
elif
(
XXH_VECTOR
=
=
XXH_AVX2
)
#
define
XXH3_accumulate_512
XXH3_accumulate_512_avx2
#
define
XXH3_scrambleAcc
XXH3_scrambleAcc_avx2
#
define
XXH3_initCustomSecret
XXH3_initCustomSecret_avx2
#
elif
(
XXH_VECTOR
=
=
XXH_SSE2
)
#
define
XXH3_accumulate_512
XXH3_accumulate_512_sse2
#
define
XXH3_scrambleAcc
XXH3_scrambleAcc_sse2
#
define
XXH3_initCustomSecret
XXH3_initCustomSecret_sse2
#
elif
(
XXH_VECTOR
=
=
XXH_NEON
)
#
define
XXH3_accumulate_512
XXH3_accumulate_512_neon
#
define
XXH3_scrambleAcc
XXH3_scrambleAcc_neon
#
define
XXH3_initCustomSecret
XXH3_initCustomSecret_scalar
#
elif
(
XXH_VECTOR
=
=
XXH_VSX
)
#
define
XXH3_accumulate_512
XXH3_accumulate_512_vsx
#
define
XXH3_scrambleAcc
XXH3_scrambleAcc_vsx
#
define
XXH3_initCustomSecret
XXH3_initCustomSecret_scalar
#
else
#
define
XXH3_accumulate_512
XXH3_accumulate_512_scalar
#
define
XXH3_scrambleAcc
XXH3_scrambleAcc_scalar
#
define
XXH3_initCustomSecret
XXH3_initCustomSecret_scalar
#
endif
#
ifndef
XXH_PREFETCH_DIST
#
ifdef
__clang__
#
define
XXH_PREFETCH_DIST
320
#
else
#
if
(
XXH_VECTOR
=
=
XXH_AVX512
)
#
define
XXH_PREFETCH_DIST
512
#
else
#
define
XXH_PREFETCH_DIST
384
#
endif
#
endif
#
endif
XXH_FORCE_INLINE
void
XXH3_accumulate
(
xxh_u64
*
XXH_RESTRICT
acc
const
xxh_u8
*
XXH_RESTRICT
input
const
xxh_u8
*
XXH_RESTRICT
secret
size_t
nbStripes
XXH3_f_accumulate_512
f_acc512
)
{
size_t
n
;
for
(
n
=
0
;
n
<
nbStripes
;
n
+
+
)
{
const
xxh_u8
*
const
in
=
input
+
n
*
XXH_STRIPE_LEN
;
XXH_PREFETCH
(
in
+
XXH_PREFETCH_DIST
)
;
f_acc512
(
acc
in
secret
+
n
*
XXH_SECRET_CONSUME_RATE
)
;
}
}
XXH_FORCE_INLINE
void
XXH3_hashLong_internal_loop
(
xxh_u64
*
XXH_RESTRICT
acc
const
xxh_u8
*
XXH_RESTRICT
input
size_t
len
const
xxh_u8
*
XXH_RESTRICT
secret
size_t
secretSize
XXH3_f_accumulate_512
f_acc512
XXH3_f_scrambleAcc
f_scramble
)
{
size_t
const
nbStripesPerBlock
=
(
secretSize
-
XXH_STRIPE_LEN
)
/
XXH_SECRET_CONSUME_RATE
;
size_t
const
block_len
=
XXH_STRIPE_LEN
*
nbStripesPerBlock
;
size_t
const
nb_blocks
=
(
len
-
1
)
/
block_len
;
size_t
n
;
XXH_ASSERT
(
secretSize
>
=
XXH3_SECRET_SIZE_MIN
)
;
for
(
n
=
0
;
n
<
nb_blocks
;
n
+
+
)
{
XXH3_accumulate
(
acc
input
+
n
*
block_len
secret
nbStripesPerBlock
f_acc512
)
;
f_scramble
(
acc
secret
+
secretSize
-
XXH_STRIPE_LEN
)
;
}
XXH_ASSERT
(
len
>
XXH_STRIPE_LEN
)
;
{
size_t
const
nbStripes
=
(
(
len
-
1
)
-
(
block_len
*
nb_blocks
)
)
/
XXH_STRIPE_LEN
;
XXH_ASSERT
(
nbStripes
<
=
(
secretSize
/
XXH_SECRET_CONSUME_RATE
)
)
;
XXH3_accumulate
(
acc
input
+
nb_blocks
*
block_len
secret
nbStripes
f_acc512
)
;
{
const
xxh_u8
*
const
p
=
input
+
len
-
XXH_STRIPE_LEN
;
#
define
XXH_SECRET_LASTACC_START
7
/
*
not
aligned
on
8
last
secret
is
different
from
acc
&
scrambler
*
/
f_acc512
(
acc
p
secret
+
secretSize
-
XXH_STRIPE_LEN
-
XXH_SECRET_LASTACC_START
)
;
}
}
}
XXH_FORCE_INLINE
xxh_u64
XXH3_mix2Accs
(
const
xxh_u64
*
XXH_RESTRICT
acc
const
xxh_u8
*
XXH_RESTRICT
secret
)
{
return
XXH3_mul128_fold64
(
acc
[
0
]
^
XXH_readLE64
(
secret
)
acc
[
1
]
^
XXH_readLE64
(
secret
+
8
)
)
;
}
static
XXH64_hash_t
XXH3_mergeAccs
(
const
xxh_u64
*
XXH_RESTRICT
acc
const
xxh_u8
*
XXH_RESTRICT
secret
xxh_u64
start
)
{
xxh_u64
result64
=
start
;
size_t
i
=
0
;
for
(
i
=
0
;
i
<
4
;
i
+
+
)
{
result64
+
=
XXH3_mix2Accs
(
acc
+
2
*
i
secret
+
16
*
i
)
;
#
if
defined
(
__clang__
)
\
&
&
(
defined
(
__arm__
)
|
|
defined
(
__thumb__
)
)
\
&
&
(
defined
(
__ARM_NEON
)
|
|
defined
(
__ARM_NEON__
)
)
\
&
&
!
defined
(
XXH_ENABLE_AUTOVECTORIZE
)
__asm__
(
"
"
:
"
+
r
"
(
result64
)
)
;
#
endif
}
return
XXH3_avalanche
(
result64
)
;
}
#
define
XXH3_INIT_ACC
{
XXH_PRIME32_3
XXH_PRIME64_1
XXH_PRIME64_2
XXH_PRIME64_3
\
XXH_PRIME64_4
XXH_PRIME32_2
XXH_PRIME64_5
XXH_PRIME32_1
}
XXH_FORCE_INLINE
XXH64_hash_t
XXH3_hashLong_64b_internal
(
const
void
*
XXH_RESTRICT
input
size_t
len
const
void
*
XXH_RESTRICT
secret
size_t
secretSize
XXH3_f_accumulate_512
f_acc512
XXH3_f_scrambleAcc
f_scramble
)
{
XXH_ALIGN
(
XXH_ACC_ALIGN
)
xxh_u64
acc
[
XXH_ACC_NB
]
=
XXH3_INIT_ACC
;
XXH3_hashLong_internal_loop
(
acc
(
const
xxh_u8
*
)
input
len
(
const
xxh_u8
*
)
secret
secretSize
f_acc512
f_scramble
)
;
XXH_STATIC_ASSERT
(
sizeof
(
acc
)
=
=
64
)
;
#
define
XXH_SECRET_MERGEACCS_START
11
XXH_ASSERT
(
secretSize
>
=
sizeof
(
acc
)
+
XXH_SECRET_MERGEACCS_START
)
;
return
XXH3_mergeAccs
(
acc
(
const
xxh_u8
*
)
secret
+
XXH_SECRET_MERGEACCS_START
(
xxh_u64
)
len
*
XXH_PRIME64_1
)
;
}
XXH_NO_INLINE
XXH64_hash_t
XXH3_hashLong_64b_withSecret
(
const
void
*
XXH_RESTRICT
input
size_t
len
XXH64_hash_t
seed64
const
xxh_u8
*
XXH_RESTRICT
secret
size_t
secretLen
)
{
(
void
)
seed64
;
return
XXH3_hashLong_64b_internal
(
input
len
secret
secretLen
XXH3_accumulate_512
XXH3_scrambleAcc
)
;
}
XXH_NO_INLINE
XXH64_hash_t
XXH3_hashLong_64b_default
(
const
void
*
XXH_RESTRICT
input
size_t
len
XXH64_hash_t
seed64
const
xxh_u8
*
XXH_RESTRICT
secret
size_t
secretLen
)
{
(
void
)
seed64
;
(
void
)
secret
;
(
void
)
secretLen
;
return
XXH3_hashLong_64b_internal
(
input
len
XXH3_kSecret
sizeof
(
XXH3_kSecret
)
XXH3_accumulate_512
XXH3_scrambleAcc
)
;
}
XXH_FORCE_INLINE
XXH64_hash_t
XXH3_hashLong_64b_withSeed_internal
(
const
void
*
input
size_t
len
XXH64_hash_t
seed
XXH3_f_accumulate_512
f_acc512
XXH3_f_scrambleAcc
f_scramble
XXH3_f_initCustomSecret
f_initSec
)
{
if
(
seed
=
=
0
)
return
XXH3_hashLong_64b_internal
(
input
len
XXH3_kSecret
sizeof
(
XXH3_kSecret
)
f_acc512
f_scramble
)
;
{
XXH_ALIGN
(
XXH_SEC_ALIGN
)
xxh_u8
secret
[
XXH_SECRET_DEFAULT_SIZE
]
;
f_initSec
(
secret
seed
)
;
return
XXH3_hashLong_64b_internal
(
input
len
secret
sizeof
(
secret
)
f_acc512
f_scramble
)
;
}
}
XXH_NO_INLINE
XXH64_hash_t
XXH3_hashLong_64b_withSeed
(
const
void
*
input
size_t
len
XXH64_hash_t
seed
const
xxh_u8
*
secret
size_t
secretLen
)
{
(
void
)
secret
;
(
void
)
secretLen
;
return
XXH3_hashLong_64b_withSeed_internal
(
input
len
seed
XXH3_accumulate_512
XXH3_scrambleAcc
XXH3_initCustomSecret
)
;
}
typedef
XXH64_hash_t
(
*
XXH3_hashLong64_f
)
(
const
void
*
XXH_RESTRICT
size_t
XXH64_hash_t
const
xxh_u8
*
XXH_RESTRICT
size_t
)
;
XXH_FORCE_INLINE
XXH64_hash_t
XXH3_64bits_internal
(
const
void
*
XXH_RESTRICT
input
size_t
len
XXH64_hash_t
seed64
const
void
*
XXH_RESTRICT
secret
size_t
secretLen
XXH3_hashLong64_f
f_hashLong
)
{
XXH_ASSERT
(
secretLen
>
=
XXH3_SECRET_SIZE_MIN
)
;
if
(
len
<
=
16
)
return
XXH3_len_0to16_64b
(
(
const
xxh_u8
*
)
input
len
(
const
xxh_u8
*
)
secret
seed64
)
;
if
(
len
<
=
128
)
return
XXH3_len_17to128_64b
(
(
const
xxh_u8
*
)
input
len
(
const
xxh_u8
*
)
secret
secretLen
seed64
)
;
if
(
len
<
=
XXH3_MIDSIZE_MAX
)
return
XXH3_len_129to240_64b
(
(
const
xxh_u8
*
)
input
len
(
const
xxh_u8
*
)
secret
secretLen
seed64
)
;
return
f_hashLong
(
input
len
seed64
(
const
xxh_u8
*
)
secret
secretLen
)
;
}
XXH_PUBLIC_API
XXH64_hash_t
XXH3_64bits
(
const
void
*
input
size_t
len
)
{
return
XXH3_64bits_internal
(
input
len
0
XXH3_kSecret
sizeof
(
XXH3_kSecret
)
XXH3_hashLong_64b_default
)
;
}
XXH_PUBLIC_API
XXH64_hash_t
XXH3_64bits_withSecret
(
const
void
*
input
size_t
len
const
void
*
secret
size_t
secretSize
)
{
return
XXH3_64bits_internal
(
input
len
0
secret
secretSize
XXH3_hashLong_64b_withSecret
)
;
}
XXH_PUBLIC_API
XXH64_hash_t
XXH3_64bits_withSeed
(
const
void
*
input
size_t
len
XXH64_hash_t
seed
)
{
return
XXH3_64bits_internal
(
input
len
seed
XXH3_kSecret
sizeof
(
XXH3_kSecret
)
XXH3_hashLong_64b_withSeed
)
;
}
static
void
*
XXH_alignedMalloc
(
size_t
s
size_t
align
)
{
XXH_ASSERT
(
align
<
=
128
&
&
align
>
=
8
)
;
XXH_ASSERT
(
(
align
&
(
align
-
1
)
)
=
=
0
)
;
XXH_ASSERT
(
s
!
=
0
&
&
s
<
(
s
+
align
)
)
;
{
xxh_u8
*
base
=
(
xxh_u8
*
)
XXH_malloc
(
s
+
align
)
;
if
(
base
!
=
NULL
)
{
size_t
offset
=
align
-
(
(
size_t
)
base
&
(
align
-
1
)
)
;
xxh_u8
*
ptr
=
base
+
offset
;
XXH_ASSERT
(
(
size_t
)
ptr
%
align
=
=
0
)
;
ptr
[
-
1
]
=
(
xxh_u8
)
offset
;
return
ptr
;
}
return
NULL
;
}
}
static
void
XXH_alignedFree
(
void
*
p
)
{
if
(
p
!
=
NULL
)
{
xxh_u8
*
ptr
=
(
xxh_u8
*
)
p
;
xxh_u8
offset
=
ptr
[
-
1
]
;
xxh_u8
*
base
=
ptr
-
offset
;
XXH_free
(
base
)
;
}
}
XXH_PUBLIC_API
XXH3_state_t
*
XXH3_createState
(
void
)
{
XXH3_state_t
*
const
state
=
(
XXH3_state_t
*
)
XXH_alignedMalloc
(
sizeof
(
XXH3_state_t
)
64
)
;
if
(
state
=
=
NULL
)
return
NULL
;
XXH3_INITSTATE
(
state
)
;
return
state
;
}
XXH_PUBLIC_API
XXH_errorcode
XXH3_freeState
(
XXH3_state_t
*
statePtr
)
{
XXH_alignedFree
(
statePtr
)
;
return
XXH_OK
;
}
XXH_PUBLIC_API
void
XXH3_copyState
(
XXH3_state_t
*
dst_state
const
XXH3_state_t
*
src_state
)
{
memcpy
(
dst_state
src_state
sizeof
(
*
dst_state
)
)
;
}
static
void
XXH3_64bits_reset_internal
(
XXH3_state_t
*
statePtr
XXH64_hash_t
seed
const
void
*
secret
size_t
secretSize
)
{
size_t
const
initStart
=
offsetof
(
XXH3_state_t
bufferedSize
)
;
size_t
const
initLength
=
offsetof
(
XXH3_state_t
nbStripesPerBlock
)
-
initStart
;
XXH_ASSERT
(
offsetof
(
XXH3_state_t
nbStripesPerBlock
)
>
initStart
)
;
XXH_ASSERT
(
statePtr
!
=
NULL
)
;
memset
(
(
char
*
)
statePtr
+
initStart
0
initLength
)
;
statePtr
-
>
acc
[
0
]
=
XXH_PRIME32_3
;
statePtr
-
>
acc
[
1
]
=
XXH_PRIME64_1
;
statePtr
-
>
acc
[
2
]
=
XXH_PRIME64_2
;
statePtr
-
>
acc
[
3
]
=
XXH_PRIME64_3
;
statePtr
-
>
acc
[
4
]
=
XXH_PRIME64_4
;
statePtr
-
>
acc
[
5
]
=
XXH_PRIME32_2
;
statePtr
-
>
acc
[
6
]
=
XXH_PRIME64_5
;
statePtr
-
>
acc
[
7
]
=
XXH_PRIME32_1
;
statePtr
-
>
seed
=
seed
;
statePtr
-
>
extSecret
=
(
const
unsigned
char
*
)
secret
;
XXH_ASSERT
(
secretSize
>
=
XXH3_SECRET_SIZE_MIN
)
;
statePtr
-
>
secretLimit
=
secretSize
-
XXH_STRIPE_LEN
;
statePtr
-
>
nbStripesPerBlock
=
statePtr
-
>
secretLimit
/
XXH_SECRET_CONSUME_RATE
;
}
XXH_PUBLIC_API
XXH_errorcode
XXH3_64bits_reset
(
XXH3_state_t
*
statePtr
)
{
if
(
statePtr
=
=
NULL
)
return
XXH_ERROR
;
XXH3_64bits_reset_internal
(
statePtr
0
XXH3_kSecret
XXH_SECRET_DEFAULT_SIZE
)
;
return
XXH_OK
;
}
XXH_PUBLIC_API
XXH_errorcode
XXH3_64bits_reset_withSecret
(
XXH3_state_t
*
statePtr
const
void
*
secret
size_t
secretSize
)
{
if
(
statePtr
=
=
NULL
)
return
XXH_ERROR
;
XXH3_64bits_reset_internal
(
statePtr
0
secret
secretSize
)
;
if
(
secret
=
=
NULL
)
return
XXH_ERROR
;
if
(
secretSize
<
XXH3_SECRET_SIZE_MIN
)
return
XXH_ERROR
;
return
XXH_OK
;
}
XXH_PUBLIC_API
XXH_errorcode
XXH3_64bits_reset_withSeed
(
XXH3_state_t
*
statePtr
XXH64_hash_t
seed
)
{
if
(
statePtr
=
=
NULL
)
return
XXH_ERROR
;
if
(
seed
=
=
0
)
return
XXH3_64bits_reset
(
statePtr
)
;
if
(
seed
!
=
statePtr
-
>
seed
)
XXH3_initCustomSecret
(
statePtr
-
>
customSecret
seed
)
;
XXH3_64bits_reset_internal
(
statePtr
seed
NULL
XXH_SECRET_DEFAULT_SIZE
)
;
return
XXH_OK
;
}
XXH_FORCE_INLINE
void
XXH3_consumeStripes
(
xxh_u64
*
XXH_RESTRICT
acc
size_t
*
XXH_RESTRICT
nbStripesSoFarPtr
size_t
nbStripesPerBlock
const
xxh_u8
*
XXH_RESTRICT
input
size_t
nbStripes
const
xxh_u8
*
XXH_RESTRICT
secret
size_t
secretLimit
XXH3_f_accumulate_512
f_acc512
XXH3_f_scrambleAcc
f_scramble
)
{
XXH_ASSERT
(
nbStripes
<
=
nbStripesPerBlock
)
;
XXH_ASSERT
(
*
nbStripesSoFarPtr
<
nbStripesPerBlock
)
;
if
(
nbStripesPerBlock
-
*
nbStripesSoFarPtr
<
=
nbStripes
)
{
size_t
const
nbStripesToEndofBlock
=
nbStripesPerBlock
-
*
nbStripesSoFarPtr
;
size_t
const
nbStripesAfterBlock
=
nbStripes
-
nbStripesToEndofBlock
;
XXH3_accumulate
(
acc
input
secret
+
nbStripesSoFarPtr
[
0
]
*
XXH_SECRET_CONSUME_RATE
nbStripesToEndofBlock
f_acc512
)
;
f_scramble
(
acc
secret
+
secretLimit
)
;
XXH3_accumulate
(
acc
input
+
nbStripesToEndofBlock
*
XXH_STRIPE_LEN
secret
nbStripesAfterBlock
f_acc512
)
;
*
nbStripesSoFarPtr
=
nbStripesAfterBlock
;
}
else
{
XXH3_accumulate
(
acc
input
secret
+
nbStripesSoFarPtr
[
0
]
*
XXH_SECRET_CONSUME_RATE
nbStripes
f_acc512
)
;
*
nbStripesSoFarPtr
+
=
nbStripes
;
}
}
XXH_FORCE_INLINE
XXH_errorcode
XXH3_update
(
XXH3_state_t
*
state
const
xxh_u8
*
input
size_t
len
XXH3_f_accumulate_512
f_acc512
XXH3_f_scrambleAcc
f_scramble
)
{
if
(
input
=
=
NULL
)
#
if
defined
(
XXH_ACCEPT_NULL_INPUT_POINTER
)
&
&
(
XXH_ACCEPT_NULL_INPUT_POINTER
>
=
1
)
return
XXH_OK
;
#
else
return
XXH_ERROR
;
#
endif
{
const
xxh_u8
*
const
bEnd
=
input
+
len
;
const
unsigned
char
*
const
secret
=
(
state
-
>
extSecret
=
=
NULL
)
?
state
-
>
customSecret
:
state
-
>
extSecret
;
state
-
>
totalLen
+
=
len
;
if
(
state
-
>
bufferedSize
+
len
<
=
XXH3_INTERNALBUFFER_SIZE
)
{
XXH_memcpy
(
state
-
>
buffer
+
state
-
>
bufferedSize
input
len
)
;
state
-
>
bufferedSize
+
=
(
XXH32_hash_t
)
len
;
return
XXH_OK
;
}
#
define
XXH3_INTERNALBUFFER_STRIPES
(
XXH3_INTERNALBUFFER_SIZE
/
XXH_STRIPE_LEN
)
XXH_STATIC_ASSERT
(
XXH3_INTERNALBUFFER_SIZE
%
XXH_STRIPE_LEN
=
=
0
)
;
if
(
state
-
>
bufferedSize
)
{
size_t
const
loadSize
=
XXH3_INTERNALBUFFER_SIZE
-
state
-
>
bufferedSize
;
XXH_memcpy
(
state
-
>
buffer
+
state
-
>
bufferedSize
input
loadSize
)
;
input
+
=
loadSize
;
XXH3_consumeStripes
(
state
-
>
acc
&
state
-
>
nbStripesSoFar
state
-
>
nbStripesPerBlock
state
-
>
buffer
XXH3_INTERNALBUFFER_STRIPES
secret
state
-
>
secretLimit
f_acc512
f_scramble
)
;
state
-
>
bufferedSize
=
0
;
}
XXH_ASSERT
(
input
<
bEnd
)
;
if
(
input
+
XXH3_INTERNALBUFFER_SIZE
<
bEnd
)
{
const
xxh_u8
*
const
limit
=
bEnd
-
XXH3_INTERNALBUFFER_SIZE
;
do
{
XXH3_consumeStripes
(
state
-
>
acc
&
state
-
>
nbStripesSoFar
state
-
>
nbStripesPerBlock
input
XXH3_INTERNALBUFFER_STRIPES
secret
state
-
>
secretLimit
f_acc512
f_scramble
)
;
input
+
=
XXH3_INTERNALBUFFER_SIZE
;
}
while
(
input
<
limit
)
;
memcpy
(
state
-
>
buffer
+
sizeof
(
state
-
>
buffer
)
-
XXH_STRIPE_LEN
input
-
XXH_STRIPE_LEN
XXH_STRIPE_LEN
)
;
}
XXH_ASSERT
(
input
<
bEnd
)
;
XXH_memcpy
(
state
-
>
buffer
input
(
size_t
)
(
bEnd
-
input
)
)
;
state
-
>
bufferedSize
=
(
XXH32_hash_t
)
(
bEnd
-
input
)
;
}
return
XXH_OK
;
}
XXH_PUBLIC_API
XXH_errorcode
XXH3_64bits_update
(
XXH3_state_t
*
state
const
void
*
input
size_t
len
)
{
return
XXH3_update
(
state
(
const
xxh_u8
*
)
input
len
XXH3_accumulate_512
XXH3_scrambleAcc
)
;
}
XXH_FORCE_INLINE
void
XXH3_digest_long
(
XXH64_hash_t
*
acc
const
XXH3_state_t
*
state
const
unsigned
char
*
secret
)
{
memcpy
(
acc
state
-
>
acc
sizeof
(
state
-
>
acc
)
)
;
if
(
state
-
>
bufferedSize
>
=
XXH_STRIPE_LEN
)
{
size_t
const
nbStripes
=
(
state
-
>
bufferedSize
-
1
)
/
XXH_STRIPE_LEN
;
size_t
nbStripesSoFar
=
state
-
>
nbStripesSoFar
;
XXH3_consumeStripes
(
acc
&
nbStripesSoFar
state
-
>
nbStripesPerBlock
state
-
>
buffer
nbStripes
secret
state
-
>
secretLimit
XXH3_accumulate_512
XXH3_scrambleAcc
)
;
XXH3_accumulate_512
(
acc
state
-
>
buffer
+
state
-
>
bufferedSize
-
XXH_STRIPE_LEN
secret
+
state
-
>
secretLimit
-
XXH_SECRET_LASTACC_START
)
;
}
else
{
xxh_u8
lastStripe
[
XXH_STRIPE_LEN
]
;
size_t
const
catchupSize
=
XXH_STRIPE_LEN
-
state
-
>
bufferedSize
;
XXH_ASSERT
(
state
-
>
bufferedSize
>
0
)
;
memcpy
(
lastStripe
state
-
>
buffer
+
sizeof
(
state
-
>
buffer
)
-
catchupSize
catchupSize
)
;
memcpy
(
lastStripe
+
catchupSize
state
-
>
buffer
state
-
>
bufferedSize
)
;
XXH3_accumulate_512
(
acc
lastStripe
secret
+
state
-
>
secretLimit
-
XXH_SECRET_LASTACC_START
)
;
}
}
XXH_PUBLIC_API
XXH64_hash_t
XXH3_64bits_digest
(
const
XXH3_state_t
*
state
)
{
const
unsigned
char
*
const
secret
=
(
state
-
>
extSecret
=
=
NULL
)
?
state
-
>
customSecret
:
state
-
>
extSecret
;
if
(
state
-
>
totalLen
>
XXH3_MIDSIZE_MAX
)
{
XXH_ALIGN
(
XXH_ACC_ALIGN
)
XXH64_hash_t
acc
[
XXH_ACC_NB
]
;
XXH3_digest_long
(
acc
state
secret
)
;
return
XXH3_mergeAccs
(
acc
secret
+
XXH_SECRET_MERGEACCS_START
(
xxh_u64
)
state
-
>
totalLen
*
XXH_PRIME64_1
)
;
}
if
(
state
-
>
seed
)
return
XXH3_64bits_withSeed
(
state
-
>
buffer
(
size_t
)
state
-
>
totalLen
state
-
>
seed
)
;
return
XXH3_64bits_withSecret
(
state
-
>
buffer
(
size_t
)
(
state
-
>
totalLen
)
secret
state
-
>
secretLimit
+
XXH_STRIPE_LEN
)
;
}
#
define
XXH_MIN
(
x
y
)
(
(
(
x
)
>
(
y
)
)
?
(
y
)
:
(
x
)
)
XXH_PUBLIC_API
void
XXH3_generateSecret
(
void
*
secretBuffer
const
void
*
customSeed
size_t
customSeedSize
)
{
XXH_ASSERT
(
secretBuffer
!
=
NULL
)
;
if
(
customSeedSize
=
=
0
)
{
memcpy
(
secretBuffer
XXH3_kSecret
XXH_SECRET_DEFAULT_SIZE
)
;
return
;
}
XXH_ASSERT
(
customSeed
!
=
NULL
)
;
{
size_t
const
segmentSize
=
sizeof
(
XXH128_hash_t
)
;
size_t
const
nbSegments
=
XXH_SECRET_DEFAULT_SIZE
/
segmentSize
;
XXH128_canonical_t
scrambler
;
XXH64_hash_t
seeds
[
12
]
;
size_t
segnb
;
XXH_ASSERT
(
nbSegments
=
=
12
)
;
XXH_ASSERT
(
segmentSize
*
nbSegments
=
=
XXH_SECRET_DEFAULT_SIZE
)
;
XXH128_canonicalFromHash
(
&
scrambler
XXH128
(
customSeed
customSeedSize
0
)
)
;
{
size_t
toFill
=
XXH_MIN
(
customSeedSize
sizeof
(
seeds
)
)
;
size_t
filled
=
toFill
;
memcpy
(
seeds
customSeed
toFill
)
;
while
(
filled
<
sizeof
(
seeds
)
)
{
toFill
=
XXH_MIN
(
filled
sizeof
(
seeds
)
-
filled
)
;
memcpy
(
(
char
*
)
seeds
+
filled
seeds
toFill
)
;
filled
+
=
toFill
;
}
}
memcpy
(
secretBuffer
&
scrambler
sizeof
(
scrambler
)
)
;
for
(
segnb
=
1
;
segnb
<
nbSegments
;
segnb
+
+
)
{
size_t
const
segmentStart
=
segnb
*
segmentSize
;
XXH128_canonical_t
segment
;
XXH128_canonicalFromHash
(
&
segment
XXH128
(
&
scrambler
sizeof
(
scrambler
)
XXH_readLE64
(
seeds
+
segnb
)
+
segnb
)
)
;
memcpy
(
(
char
*
)
secretBuffer
+
segmentStart
&
segment
sizeof
(
segment
)
)
;
}
}
}
XXH_FORCE_INLINE
XXH128_hash_t
XXH3_len_1to3_128b
(
const
xxh_u8
*
input
size_t
len
const
xxh_u8
*
secret
XXH64_hash_t
seed
)
{
XXH_ASSERT
(
input
!
=
NULL
)
;
XXH_ASSERT
(
1
<
=
len
&
&
len
<
=
3
)
;
XXH_ASSERT
(
secret
!
=
NULL
)
;
{
xxh_u8
const
c1
=
input
[
0
]
;
xxh_u8
const
c2
=
input
[
len
>
>
1
]
;
xxh_u8
const
c3
=
input
[
len
-
1
]
;
xxh_u32
const
combinedl
=
(
(
xxh_u32
)
c1
<
<
16
)
|
(
(
xxh_u32
)
c2
<
<
24
)
|
(
(
xxh_u32
)
c3
<
<
0
)
|
(
(
xxh_u32
)
len
<
<
8
)
;
xxh_u32
const
combinedh
=
XXH_rotl32
(
XXH_swap32
(
combinedl
)
13
)
;
xxh_u64
const
bitflipl
=
(
XXH_readLE32
(
secret
)
^
XXH_readLE32
(
secret
+
4
)
)
+
seed
;
xxh_u64
const
bitfliph
=
(
XXH_readLE32
(
secret
+
8
)
^
XXH_readLE32
(
secret
+
12
)
)
-
seed
;
xxh_u64
const
keyed_lo
=
(
xxh_u64
)
combinedl
^
bitflipl
;
xxh_u64
const
keyed_hi
=
(
xxh_u64
)
combinedh
^
bitfliph
;
XXH128_hash_t
h128
;
h128
.
low64
=
XXH64_avalanche
(
keyed_lo
)
;
h128
.
high64
=
XXH64_avalanche
(
keyed_hi
)
;
return
h128
;
}
}
XXH_FORCE_INLINE
XXH128_hash_t
XXH3_len_4to8_128b
(
const
xxh_u8
*
input
size_t
len
const
xxh_u8
*
secret
XXH64_hash_t
seed
)
{
XXH_ASSERT
(
input
!
=
NULL
)
;
XXH_ASSERT
(
secret
!
=
NULL
)
;
XXH_ASSERT
(
4
<
=
len
&
&
len
<
=
8
)
;
seed
^
=
(
xxh_u64
)
XXH_swap32
(
(
xxh_u32
)
seed
)
<
<
32
;
{
xxh_u32
const
input_lo
=
XXH_readLE32
(
input
)
;
xxh_u32
const
input_hi
=
XXH_readLE32
(
input
+
len
-
4
)
;
xxh_u64
const
input_64
=
input_lo
+
(
(
xxh_u64
)
input_hi
<
<
32
)
;
xxh_u64
const
bitflip
=
(
XXH_readLE64
(
secret
+
16
)
^
XXH_readLE64
(
secret
+
24
)
)
+
seed
;
xxh_u64
const
keyed
=
input_64
^
bitflip
;
XXH128_hash_t
m128
=
XXH_mult64to128
(
keyed
XXH_PRIME64_1
+
(
len
<
<
2
)
)
;
m128
.
high64
+
=
(
m128
.
low64
<
<
1
)
;
m128
.
low64
^
=
(
m128
.
high64
>
>
3
)
;
m128
.
low64
=
XXH_xorshift64
(
m128
.
low64
35
)
;
m128
.
low64
*
=
0x9FB21C651E98DF25ULL
;
m128
.
low64
=
XXH_xorshift64
(
m128
.
low64
28
)
;
m128
.
high64
=
XXH3_avalanche
(
m128
.
high64
)
;
return
m128
;
}
}
XXH_FORCE_INLINE
XXH128_hash_t
XXH3_len_9to16_128b
(
const
xxh_u8
*
input
size_t
len
const
xxh_u8
*
secret
XXH64_hash_t
seed
)
{
XXH_ASSERT
(
input
!
=
NULL
)
;
XXH_ASSERT
(
secret
!
=
NULL
)
;
XXH_ASSERT
(
9
<
=
len
&
&
len
<
=
16
)
;
{
xxh_u64
const
bitflipl
=
(
XXH_readLE64
(
secret
+
32
)
^
XXH_readLE64
(
secret
+
40
)
)
-
seed
;
xxh_u64
const
bitfliph
=
(
XXH_readLE64
(
secret
+
48
)
^
XXH_readLE64
(
secret
+
56
)
)
+
seed
;
xxh_u64
const
input_lo
=
XXH_readLE64
(
input
)
;
xxh_u64
input_hi
=
XXH_readLE64
(
input
+
len
-
8
)
;
XXH128_hash_t
m128
=
XXH_mult64to128
(
input_lo
^
input_hi
^
bitflipl
XXH_PRIME64_1
)
;
m128
.
low64
+
=
(
xxh_u64
)
(
len
-
1
)
<
<
54
;
input_hi
^
=
bitfliph
;
if
(
sizeof
(
void
*
)
<
sizeof
(
xxh_u64
)
)
{
m128
.
high64
+
=
(
input_hi
&
0xFFFFFFFF00000000ULL
)
+
XXH_mult32to64
(
(
xxh_u32
)
input_hi
XXH_PRIME32_2
)
;
}
else
{
m128
.
high64
+
=
input_hi
+
XXH_mult32to64
(
(
xxh_u32
)
input_hi
XXH_PRIME32_2
-
1
)
;
}
m128
.
low64
^
=
XXH_swap64
(
m128
.
high64
)
;
{
XXH128_hash_t
h128
=
XXH_mult64to128
(
m128
.
low64
XXH_PRIME64_2
)
;
h128
.
high64
+
=
m128
.
high64
*
XXH_PRIME64_2
;
h128
.
low64
=
XXH3_avalanche
(
h128
.
low64
)
;
h128
.
high64
=
XXH3_avalanche
(
h128
.
high64
)
;
return
h128
;
}
}
}
XXH_FORCE_INLINE
XXH128_hash_t
XXH3_len_0to16_128b
(
const
xxh_u8
*
input
size_t
len
const
xxh_u8
*
secret
XXH64_hash_t
seed
)
{
XXH_ASSERT
(
len
<
=
16
)
;
{
if
(
len
>
8
)
return
XXH3_len_9to16_128b
(
input
len
secret
seed
)
;
if
(
len
>
=
4
)
return
XXH3_len_4to8_128b
(
input
len
secret
seed
)
;
if
(
len
)
return
XXH3_len_1to3_128b
(
input
len
secret
seed
)
;
{
XXH128_hash_t
h128
;
xxh_u64
const
bitflipl
=
XXH_readLE64
(
secret
+
64
)
^
XXH_readLE64
(
secret
+
72
)
;
xxh_u64
const
bitfliph
=
XXH_readLE64
(
secret
+
80
)
^
XXH_readLE64
(
secret
+
88
)
;
h128
.
low64
=
XXH64_avalanche
(
seed
^
bitflipl
)
;
h128
.
high64
=
XXH64_avalanche
(
seed
^
bitfliph
)
;
return
h128
;
}
}
}
XXH_FORCE_INLINE
XXH128_hash_t
XXH128_mix32B
(
XXH128_hash_t
acc
const
xxh_u8
*
input_1
const
xxh_u8
*
input_2
const
xxh_u8
*
secret
XXH64_hash_t
seed
)
{
acc
.
low64
+
=
XXH3_mix16B
(
input_1
secret
+
0
seed
)
;
acc
.
low64
^
=
XXH_readLE64
(
input_2
)
+
XXH_readLE64
(
input_2
+
8
)
;
acc
.
high64
+
=
XXH3_mix16B
(
input_2
secret
+
16
seed
)
;
acc
.
high64
^
=
XXH_readLE64
(
input_1
)
+
XXH_readLE64
(
input_1
+
8
)
;
return
acc
;
}
XXH_FORCE_INLINE
XXH128_hash_t
XXH3_len_17to128_128b
(
const
xxh_u8
*
XXH_RESTRICT
input
size_t
len
const
xxh_u8
*
XXH_RESTRICT
secret
size_t
secretSize
XXH64_hash_t
seed
)
{
XXH_ASSERT
(
secretSize
>
=
XXH3_SECRET_SIZE_MIN
)
;
(
void
)
secretSize
;
XXH_ASSERT
(
16
<
len
&
&
len
<
=
128
)
;
{
XXH128_hash_t
acc
;
acc
.
low64
=
len
*
XXH_PRIME64_1
;
acc
.
high64
=
0
;
if
(
len
>
32
)
{
if
(
len
>
64
)
{
if
(
len
>
96
)
{
acc
=
XXH128_mix32B
(
acc
input
+
48
input
+
len
-
64
secret
+
96
seed
)
;
}
acc
=
XXH128_mix32B
(
acc
input
+
32
input
+
len
-
48
secret
+
64
seed
)
;
}
acc
=
XXH128_mix32B
(
acc
input
+
16
input
+
len
-
32
secret
+
32
seed
)
;
}
acc
=
XXH128_mix32B
(
acc
input
input
+
len
-
16
secret
seed
)
;
{
XXH128_hash_t
h128
;
h128
.
low64
=
acc
.
low64
+
acc
.
high64
;
h128
.
high64
=
(
acc
.
low64
*
XXH_PRIME64_1
)
+
(
acc
.
high64
*
XXH_PRIME64_4
)
+
(
(
len
-
seed
)
*
XXH_PRIME64_2
)
;
h128
.
low64
=
XXH3_avalanche
(
h128
.
low64
)
;
h128
.
high64
=
(
XXH64_hash_t
)
0
-
XXH3_avalanche
(
h128
.
high64
)
;
return
h128
;
}
}
}
XXH_NO_INLINE
XXH128_hash_t
XXH3_len_129to240_128b
(
const
xxh_u8
*
XXH_RESTRICT
input
size_t
len
const
xxh_u8
*
XXH_RESTRICT
secret
size_t
secretSize
XXH64_hash_t
seed
)
{
XXH_ASSERT
(
secretSize
>
=
XXH3_SECRET_SIZE_MIN
)
;
(
void
)
secretSize
;
XXH_ASSERT
(
128
<
len
&
&
len
<
=
XXH3_MIDSIZE_MAX
)
;
{
XXH128_hash_t
acc
;
int
const
nbRounds
=
(
int
)
len
/
32
;
int
i
;
acc
.
low64
=
len
*
XXH_PRIME64_1
;
acc
.
high64
=
0
;
for
(
i
=
0
;
i
<
4
;
i
+
+
)
{
acc
=
XXH128_mix32B
(
acc
input
+
(
32
*
i
)
input
+
(
32
*
i
)
+
16
secret
+
(
32
*
i
)
seed
)
;
}
acc
.
low64
=
XXH3_avalanche
(
acc
.
low64
)
;
acc
.
high64
=
XXH3_avalanche
(
acc
.
high64
)
;
XXH_ASSERT
(
nbRounds
>
=
4
)
;
for
(
i
=
4
;
i
<
nbRounds
;
i
+
+
)
{
acc
=
XXH128_mix32B
(
acc
input
+
(
32
*
i
)
input
+
(
32
*
i
)
+
16
secret
+
XXH3_MIDSIZE_STARTOFFSET
+
(
32
*
(
i
-
4
)
)
seed
)
;
}
acc
=
XXH128_mix32B
(
acc
input
+
len
-
16
input
+
len
-
32
secret
+
XXH3_SECRET_SIZE_MIN
-
XXH3_MIDSIZE_LASTOFFSET
-
16
0ULL
-
seed
)
;
{
XXH128_hash_t
h128
;
h128
.
low64
=
acc
.
low64
+
acc
.
high64
;
h128
.
high64
=
(
acc
.
low64
*
XXH_PRIME64_1
)
+
(
acc
.
high64
*
XXH_PRIME64_4
)
+
(
(
len
-
seed
)
*
XXH_PRIME64_2
)
;
h128
.
low64
=
XXH3_avalanche
(
h128
.
low64
)
;
h128
.
high64
=
(
XXH64_hash_t
)
0
-
XXH3_avalanche
(
h128
.
high64
)
;
return
h128
;
}
}
}
XXH_FORCE_INLINE
XXH128_hash_t
XXH3_hashLong_128b_internal
(
const
void
*
XXH_RESTRICT
input
size_t
len
const
xxh_u8
*
XXH_RESTRICT
secret
size_t
secretSize
XXH3_f_accumulate_512
f_acc512
XXH3_f_scrambleAcc
f_scramble
)
{
XXH_ALIGN
(
XXH_ACC_ALIGN
)
xxh_u64
acc
[
XXH_ACC_NB
]
=
XXH3_INIT_ACC
;
XXH3_hashLong_internal_loop
(
acc
(
const
xxh_u8
*
)
input
len
secret
secretSize
f_acc512
f_scramble
)
;
XXH_STATIC_ASSERT
(
sizeof
(
acc
)
=
=
64
)
;
XXH_ASSERT
(
secretSize
>
=
sizeof
(
acc
)
+
XXH_SECRET_MERGEACCS_START
)
;
{
XXH128_hash_t
h128
;
h128
.
low64
=
XXH3_mergeAccs
(
acc
secret
+
XXH_SECRET_MERGEACCS_START
(
xxh_u64
)
len
*
XXH_PRIME64_1
)
;
h128
.
high64
=
XXH3_mergeAccs
(
acc
secret
+
secretSize
-
sizeof
(
acc
)
-
XXH_SECRET_MERGEACCS_START
~
(
(
xxh_u64
)
len
*
XXH_PRIME64_2
)
)
;
return
h128
;
}
}
XXH_NO_INLINE
XXH128_hash_t
XXH3_hashLong_128b_default
(
const
void
*
XXH_RESTRICT
input
size_t
len
XXH64_hash_t
seed64
const
void
*
XXH_RESTRICT
secret
size_t
secretLen
)
{
(
void
)
seed64
;
(
void
)
secret
;
(
void
)
secretLen
;
return
XXH3_hashLong_128b_internal
(
input
len
XXH3_kSecret
sizeof
(
XXH3_kSecret
)
XXH3_accumulate_512
XXH3_scrambleAcc
)
;
}
XXH_NO_INLINE
XXH128_hash_t
XXH3_hashLong_128b_withSecret
(
const
void
*
XXH_RESTRICT
input
size_t
len
XXH64_hash_t
seed64
const
void
*
XXH_RESTRICT
secret
size_t
secretLen
)
{
(
void
)
seed64
;
return
XXH3_hashLong_128b_internal
(
input
len
(
const
xxh_u8
*
)
secret
secretLen
XXH3_accumulate_512
XXH3_scrambleAcc
)
;
}
XXH_FORCE_INLINE
XXH128_hash_t
XXH3_hashLong_128b_withSeed_internal
(
const
void
*
XXH_RESTRICT
input
size_t
len
XXH64_hash_t
seed64
XXH3_f_accumulate_512
f_acc512
XXH3_f_scrambleAcc
f_scramble
XXH3_f_initCustomSecret
f_initSec
)
{
if
(
seed64
=
=
0
)
return
XXH3_hashLong_128b_internal
(
input
len
XXH3_kSecret
sizeof
(
XXH3_kSecret
)
f_acc512
f_scramble
)
;
{
XXH_ALIGN
(
XXH_SEC_ALIGN
)
xxh_u8
secret
[
XXH_SECRET_DEFAULT_SIZE
]
;
f_initSec
(
secret
seed64
)
;
return
XXH3_hashLong_128b_internal
(
input
len
(
const
xxh_u8
*
)
secret
sizeof
(
secret
)
f_acc512
f_scramble
)
;
}
}
XXH_NO_INLINE
XXH128_hash_t
XXH3_hashLong_128b_withSeed
(
const
void
*
input
size_t
len
XXH64_hash_t
seed64
const
void
*
XXH_RESTRICT
secret
size_t
secretLen
)
{
(
void
)
secret
;
(
void
)
secretLen
;
return
XXH3_hashLong_128b_withSeed_internal
(
input
len
seed64
XXH3_accumulate_512
XXH3_scrambleAcc
XXH3_initCustomSecret
)
;
}
typedef
XXH128_hash_t
(
*
XXH3_hashLong128_f
)
(
const
void
*
XXH_RESTRICT
size_t
XXH64_hash_t
const
void
*
XXH_RESTRICT
size_t
)
;
XXH_FORCE_INLINE
XXH128_hash_t
XXH3_128bits_internal
(
const
void
*
input
size_t
len
XXH64_hash_t
seed64
const
void
*
XXH_RESTRICT
secret
size_t
secretLen
XXH3_hashLong128_f
f_hl128
)
{
XXH_ASSERT
(
secretLen
>
=
XXH3_SECRET_SIZE_MIN
)
;
if
(
len
<
=
16
)
return
XXH3_len_0to16_128b
(
(
const
xxh_u8
*
)
input
len
(
const
xxh_u8
*
)
secret
seed64
)
;
if
(
len
<
=
128
)
return
XXH3_len_17to128_128b
(
(
const
xxh_u8
*
)
input
len
(
const
xxh_u8
*
)
secret
secretLen
seed64
)
;
if
(
len
<
=
XXH3_MIDSIZE_MAX
)
return
XXH3_len_129to240_128b
(
(
const
xxh_u8
*
)
input
len
(
const
xxh_u8
*
)
secret
secretLen
seed64
)
;
return
f_hl128
(
input
len
seed64
secret
secretLen
)
;
}
XXH_PUBLIC_API
XXH128_hash_t
XXH3_128bits
(
const
void
*
input
size_t
len
)
{
return
XXH3_128bits_internal
(
input
len
0
XXH3_kSecret
sizeof
(
XXH3_kSecret
)
XXH3_hashLong_128b_default
)
;
}
XXH_PUBLIC_API
XXH128_hash_t
XXH3_128bits_withSecret
(
const
void
*
input
size_t
len
const
void
*
secret
size_t
secretSize
)
{
return
XXH3_128bits_internal
(
input
len
0
(
const
xxh_u8
*
)
secret
secretSize
XXH3_hashLong_128b_withSecret
)
;
}
XXH_PUBLIC_API
XXH128_hash_t
XXH3_128bits_withSeed
(
const
void
*
input
size_t
len
XXH64_hash_t
seed
)
{
return
XXH3_128bits_internal
(
input
len
seed
XXH3_kSecret
sizeof
(
XXH3_kSecret
)
XXH3_hashLong_128b_withSeed
)
;
}
XXH_PUBLIC_API
XXH128_hash_t
XXH128
(
const
void
*
input
size_t
len
XXH64_hash_t
seed
)
{
return
XXH3_128bits_withSeed
(
input
len
seed
)
;
}
static
void
XXH3_128bits_reset_internal
(
XXH3_state_t
*
statePtr
XXH64_hash_t
seed
const
void
*
secret
size_t
secretSize
)
{
XXH3_64bits_reset_internal
(
statePtr
seed
secret
secretSize
)
;
}
XXH_PUBLIC_API
XXH_errorcode
XXH3_128bits_reset
(
XXH3_state_t
*
statePtr
)
{
if
(
statePtr
=
=
NULL
)
return
XXH_ERROR
;
XXH3_128bits_reset_internal
(
statePtr
0
XXH3_kSecret
XXH_SECRET_DEFAULT_SIZE
)
;
return
XXH_OK
;
}
XXH_PUBLIC_API
XXH_errorcode
XXH3_128bits_reset_withSecret
(
XXH3_state_t
*
statePtr
const
void
*
secret
size_t
secretSize
)
{
if
(
statePtr
=
=
NULL
)
return
XXH_ERROR
;
XXH3_128bits_reset_internal
(
statePtr
0
secret
secretSize
)
;
if
(
secret
=
=
NULL
)
return
XXH_ERROR
;
if
(
secretSize
<
XXH3_SECRET_SIZE_MIN
)
return
XXH_ERROR
;
return
XXH_OK
;
}
XXH_PUBLIC_API
XXH_errorcode
XXH3_128bits_reset_withSeed
(
XXH3_state_t
*
statePtr
XXH64_hash_t
seed
)
{
if
(
statePtr
=
=
NULL
)
return
XXH_ERROR
;
if
(
seed
=
=
0
)
return
XXH3_128bits_reset
(
statePtr
)
;
if
(
seed
!
=
statePtr
-
>
seed
)
XXH3_initCustomSecret
(
statePtr
-
>
customSecret
seed
)
;
XXH3_128bits_reset_internal
(
statePtr
seed
NULL
XXH_SECRET_DEFAULT_SIZE
)
;
return
XXH_OK
;
}
XXH_PUBLIC_API
XXH_errorcode
XXH3_128bits_update
(
XXH3_state_t
*
state
const
void
*
input
size_t
len
)
{
return
XXH3_update
(
state
(
const
xxh_u8
*
)
input
len
XXH3_accumulate_512
XXH3_scrambleAcc
)
;
}
XXH_PUBLIC_API
XXH128_hash_t
XXH3_128bits_digest
(
const
XXH3_state_t
*
state
)
{
const
unsigned
char
*
const
secret
=
(
state
-
>
extSecret
=
=
NULL
)
?
state
-
>
customSecret
:
state
-
>
extSecret
;
if
(
state
-
>
totalLen
>
XXH3_MIDSIZE_MAX
)
{
XXH_ALIGN
(
XXH_ACC_ALIGN
)
XXH64_hash_t
acc
[
XXH_ACC_NB
]
;
XXH3_digest_long
(
acc
state
secret
)
;
XXH_ASSERT
(
state
-
>
secretLimit
+
XXH_STRIPE_LEN
>
=
sizeof
(
acc
)
+
XXH_SECRET_MERGEACCS_START
)
;
{
XXH128_hash_t
h128
;
h128
.
low64
=
XXH3_mergeAccs
(
acc
secret
+
XXH_SECRET_MERGEACCS_START
(
xxh_u64
)
state
-
>
totalLen
*
XXH_PRIME64_1
)
;
h128
.
high64
=
XXH3_mergeAccs
(
acc
secret
+
state
-
>
secretLimit
+
XXH_STRIPE_LEN
-
sizeof
(
acc
)
-
XXH_SECRET_MERGEACCS_START
~
(
(
xxh_u64
)
state
-
>
totalLen
*
XXH_PRIME64_2
)
)
;
return
h128
;
}
}
if
(
state
-
>
seed
)
return
XXH3_128bits_withSeed
(
state
-
>
buffer
(
size_t
)
state
-
>
totalLen
state
-
>
seed
)
;
return
XXH3_128bits_withSecret
(
state
-
>
buffer
(
size_t
)
(
state
-
>
totalLen
)
secret
state
-
>
secretLimit
+
XXH_STRIPE_LEN
)
;
}
#
include
<
string
.
h
>
XXH_PUBLIC_API
int
XXH128_isEqual
(
XXH128_hash_t
h1
XXH128_hash_t
h2
)
{
return
!
(
memcmp
(
&
h1
&
h2
sizeof
(
h1
)
)
)
;
}
XXH_PUBLIC_API
int
XXH128_cmp
(
const
void
*
h128_1
const
void
*
h128_2
)
{
XXH128_hash_t
const
h1
=
*
(
const
XXH128_hash_t
*
)
h128_1
;
XXH128_hash_t
const
h2
=
*
(
const
XXH128_hash_t
*
)
h128_2
;
int
const
hcmp
=
(
h1
.
high64
>
h2
.
high64
)
-
(
h2
.
high64
>
h1
.
high64
)
;
if
(
hcmp
)
return
hcmp
;
return
(
h1
.
low64
>
h2
.
low64
)
-
(
h2
.
low64
>
h1
.
low64
)
;
}
XXH_PUBLIC_API
void
XXH128_canonicalFromHash
(
XXH128_canonical_t
*
dst
XXH128_hash_t
hash
)
{
XXH_STATIC_ASSERT
(
sizeof
(
XXH128_canonical_t
)
=
=
sizeof
(
XXH128_hash_t
)
)
;
if
(
XXH_CPU_LITTLE_ENDIAN
)
{
hash
.
high64
=
XXH_swap64
(
hash
.
high64
)
;
hash
.
low64
=
XXH_swap64
(
hash
.
low64
)
;
}
memcpy
(
dst
&
hash
.
high64
sizeof
(
hash
.
high64
)
)
;
memcpy
(
(
char
*
)
dst
+
sizeof
(
hash
.
high64
)
&
hash
.
low64
sizeof
(
hash
.
low64
)
)
;
}
XXH_PUBLIC_API
XXH128_hash_t
XXH128_hashFromCanonical
(
const
XXH128_canonical_t
*
src
)
{
XXH128_hash_t
h
;
h
.
high64
=
XXH_readBE64
(
src
)
;
h
.
low64
=
XXH_readBE64
(
src
-
>
digest
+
8
)
;
return
h
;
}
#
if
XXH_VECTOR
=
=
XXH_AVX2
\
&
&
defined
(
__GNUC__
)
&
&
!
defined
(
__clang__
)
\
&
&
defined
(
__OPTIMIZE__
)
&
&
!
defined
(
__OPTIMIZE_SIZE__
)
#
pragma
GCC
pop_options
#
endif
#
endif
#
endif
#
if
defined
(
__cplusplus
)
}
#
endif
