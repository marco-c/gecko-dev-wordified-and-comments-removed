#
ifndef
mozilla_ThreadSafeWeakPtr_h
#
define
mozilla_ThreadSafeWeakPtr_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
RefCounted
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
namespace
mozilla
{
template
<
typename
T
>
class
ThreadSafeWeakPtr
;
template
<
typename
T
>
class
SupportsThreadSafeWeakPtr
;
#
ifdef
MOZ_REFCOUNTED_LEAK_CHECKING
#
define
MOZ_DECLARE_THREADSAFEWEAKREFERENCE_TYPENAME
(
T
)
\
static
const
char
*
threadSafeWeakReferenceTypeName
(
)
{
\
return
"
ThreadSafeWeakReference
<
"
#
T
"
>
"
;
\
}
#
else
#
define
MOZ_DECLARE_THREADSAFEWEAKREFERENCE_TYPENAME
(
T
)
#
endif
namespace
detail
{
template
<
typename
T
>
class
ThreadSafeWeakReference
:
public
external
:
:
AtomicRefCounted
<
ThreadSafeWeakReference
<
T
>
>
{
public
:
typedef
T
ElementType
;
explicit
ThreadSafeWeakReference
(
T
*
aPtr
)
:
mPtr
(
aPtr
)
{
}
#
ifdef
MOZ_REFCOUNTED_LEAK_CHECKING
const
char
*
typeName
(
)
const
{
return
T
:
:
threadSafeWeakReferenceTypeName
(
)
;
}
size_t
typeSize
(
)
const
{
return
sizeof
(
*
this
)
;
}
#
endif
private
:
friend
class
mozilla
:
:
SupportsThreadSafeWeakPtr
<
T
>
;
template
<
typename
U
>
friend
class
mozilla
:
:
ThreadSafeWeakPtr
;
already_AddRefed
<
T
>
getRefPtr
(
)
{
MozRefCountType
cnt
=
mStrongCnt
.
IncrementIfNonzero
(
)
;
if
(
cnt
=
=
0
)
{
return
nullptr
;
}
RefPtr
<
T
>
result
{
already_AddRefed
(
mPtr
)
}
;
detail
:
:
RefCountLogger
:
:
logAddRef
(
result
.
get
(
)
cnt
)
;
return
result
.
forget
(
)
;
}
RC
<
MozRefCountType
AtomicRefCount
>
mStrongCnt
{
0
}
;
T
*
MOZ_NON_OWNING_REF
mPtr
;
}
;
}
template
<
typename
T
>
class
SupportsThreadSafeWeakPtr
{
protected
:
typedef
detail
:
:
ThreadSafeWeakReference
<
T
>
ThreadSafeWeakReference
;
SupportsThreadSafeWeakPtr
(
)
:
mWeakRef
(
new
ThreadSafeWeakReference
(
static_cast
<
T
*
>
(
this
)
)
)
{
static_assert
(
std
:
:
is_base_of_v
<
SupportsThreadSafeWeakPtr
<
T
>
T
>
"
T
must
derive
from
SupportsThreadSafeWeakPtr
<
T
>
"
)
;
}
public
:
void
AddRef
(
)
const
{
auto
&
refCnt
=
mWeakRef
-
>
mStrongCnt
;
MOZ_ASSERT
(
int32_t
(
refCnt
)
>
=
0
)
;
MozRefCountType
cnt
=
+
+
refCnt
;
detail
:
:
RefCountLogger
:
:
logAddRef
(
static_cast
<
const
T
*
>
(
this
)
cnt
)
;
}
void
Release
(
)
const
{
auto
&
refCnt
=
mWeakRef
-
>
mStrongCnt
;
MOZ_ASSERT
(
int32_t
(
refCnt
)
>
0
)
;
detail
:
:
RefCountLogger
:
:
ReleaseLogger
logger
(
static_cast
<
const
T
*
>
(
this
)
)
;
MozRefCountType
cnt
=
-
-
refCnt
;
logger
.
logRelease
(
cnt
)
;
if
(
0
=
=
cnt
)
{
delete
static_cast
<
const
T
*
>
(
this
)
;
}
}
void
ref
(
)
{
AddRef
(
)
;
}
void
deref
(
)
{
Release
(
)
;
}
MozRefCountType
refCount
(
)
const
{
return
mWeakRef
-
>
mStrongCnt
;
}
private
:
template
<
typename
U
>
friend
class
ThreadSafeWeakPtr
;
ThreadSafeWeakReference
*
getThreadSafeWeakReference
(
)
const
{
return
mWeakRef
;
}
const
RefPtr
<
ThreadSafeWeakReference
>
mWeakRef
;
}
;
template
<
typename
T
>
class
ThreadSafeWeakPtr
{
typedef
typename
T
:
:
ThreadSafeWeakReference
ThreadSafeWeakReference
;
public
:
ThreadSafeWeakPtr
(
)
=
default
;
ThreadSafeWeakPtr
&
operator
=
(
const
ThreadSafeWeakPtr
&
aOther
)
=
default
;
ThreadSafeWeakPtr
(
const
ThreadSafeWeakPtr
&
aOther
)
=
default
;
ThreadSafeWeakPtr
&
operator
=
(
ThreadSafeWeakPtr
&
&
aOther
)
=
default
;
ThreadSafeWeakPtr
(
ThreadSafeWeakPtr
&
&
aOther
)
=
default
;
ThreadSafeWeakPtr
&
operator
=
(
const
RefPtr
<
T
>
&
aOther
)
{
if
(
aOther
)
{
mRef
=
aOther
-
>
getThreadSafeWeakReference
(
)
;
}
else
{
mRef
=
nullptr
;
}
return
*
this
;
}
explicit
ThreadSafeWeakPtr
(
const
RefPtr
<
T
>
&
aOther
)
{
*
this
=
aOther
;
}
ThreadSafeWeakPtr
&
operator
=
(
decltype
(
nullptr
)
)
{
mRef
=
nullptr
;
return
*
this
;
}
explicit
ThreadSafeWeakPtr
(
decltype
(
nullptr
)
)
{
}
explicit
operator
bool
(
)
const
=
delete
;
bool
IsNull
(
)
const
{
return
!
mRef
;
}
bool
IsDead
(
)
const
{
return
IsNull
(
)
|
|
size_t
(
mRef
-
>
mStrongCnt
)
=
=
0
;
}
bool
operator
=
=
(
const
ThreadSafeWeakPtr
&
aOther
)
const
{
return
mRef
=
=
aOther
.
mRef
;
}
bool
operator
=
=
(
const
RefPtr
<
T
>
&
aOther
)
const
{
return
*
this
=
=
aOther
.
get
(
)
;
}
bool
operator
=
=
(
const
T
*
aOther
)
const
{
if
(
!
mRef
)
{
return
!
aOther
;
}
return
aOther
&
&
aOther
-
>
getThreadSafeWeakReference
(
)
=
=
mRef
;
}
template
<
typename
U
>
bool
operator
!
=
(
const
U
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
explicit
operator
RefPtr
<
T
>
(
)
const
{
return
getRefPtr
(
)
;
}
private
:
already_AddRefed
<
T
>
getRefPtr
(
)
const
{
static_assert
(
std
:
:
is_base_of
<
typename
ThreadSafeWeakReference
:
:
ElementType
T
>
:
:
value
"
T
must
derive
from
ThreadSafeWeakReference
:
:
ElementType
"
)
;
return
mRef
?
mRef
-
>
getRefPtr
(
)
.
template
downcast
<
T
>
(
)
:
nullptr
;
}
RefPtr
<
ThreadSafeWeakReference
>
mRef
;
}
;
}
template
<
typename
T
>
inline
already_AddRefed
<
T
>
do_AddRef
(
const
mozilla
:
:
ThreadSafeWeakPtr
<
T
>
&
aObj
)
{
RefPtr
<
T
>
ref
(
aObj
)
;
return
ref
.
forget
(
)
;
}
#
endif
