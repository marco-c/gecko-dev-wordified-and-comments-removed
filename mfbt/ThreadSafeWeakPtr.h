#
ifndef
mozilla_ThreadSafeWeakPtr_h
#
define
mozilla_ThreadSafeWeakPtr_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
RefCounted
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
TypeTraits
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
<
limits
>
namespace
mozilla
{
template
<
typename
T
>
class
ThreadSafeWeakPtr
;
template
<
typename
T
>
class
SupportsThreadSafeWeakPtr
;
#
ifdef
MOZ_REFCOUNTED_LEAK_CHECKING
#
define
MOZ_DECLARE_THREADSAFEWEAKREFERENCE_TYPENAME
(
T
)
\
static
const
char
*
threadSafeWeakReferenceTypeName
(
)
{
\
return
"
ThreadSafeWeakReference
<
"
#
T
"
>
"
;
\
}
#
else
#
define
MOZ_DECLARE_THREADSAFEWEAKREFERENCE_TYPENAME
(
T
)
#
endif
namespace
detail
{
class
ReadWriteSpinLock
{
typedef
int32_t
CounterType
;
public
:
void
readLock
(
)
{
for
(
;
;
)
{
CounterType
oldCounter
=
mCounter
&
std
:
:
numeric_limits
<
CounterType
>
:
:
max
(
)
;
CounterType
newCounter
=
oldCounter
+
1
;
if
(
mCounter
.
compareExchange
(
oldCounter
newCounter
)
)
{
break
;
}
}
}
void
readUnlock
(
)
{
mCounter
-
-
;
}
void
writeLock
(
)
{
while
(
true
)
{
if
(
mCounter
.
compareExchange
(
0
std
:
:
numeric_limits
<
CounterType
>
:
:
min
(
)
)
)
{
return
;
}
}
}
void
writeUnlock
(
)
{
mCounter
=
0
;
}
private
:
Atomic
<
CounterType
>
mCounter
;
}
;
template
<
typename
T
>
class
ThreadSafeWeakReference
:
public
external
:
:
AtomicRefCounted
<
ThreadSafeWeakReference
<
T
>
>
{
public
:
typedef
T
ElementType
;
explicit
ThreadSafeWeakReference
(
T
*
aPtr
)
{
mPtr
=
aPtr
;
}
#
ifdef
MOZ_REFCOUNTED_LEAK_CHECKING
const
char
*
typeName
(
)
const
{
return
T
:
:
threadSafeWeakReferenceTypeName
(
)
;
}
size_t
typeSize
(
)
const
{
return
sizeof
(
*
this
)
;
}
#
endif
private
:
friend
class
mozilla
:
:
SupportsThreadSafeWeakPtr
<
T
>
;
template
<
typename
U
>
friend
class
mozilla
:
:
ThreadSafeWeakPtr
;
T
*
get
(
)
const
{
return
mPtr
;
}
already_AddRefed
<
T
>
getRefPtr
(
)
{
mLock
.
readLock
(
)
;
RefPtr
<
T
>
result
(
get
(
)
)
;
mLock
.
readUnlock
(
)
;
return
result
.
forget
(
)
;
}
void
tryDetach
(
const
SupportsThreadSafeWeakPtr
<
T
>
*
aOwner
)
{
mLock
.
writeLock
(
)
;
if
(
aOwner
-
>
hasOneRef
(
)
)
{
mPtr
=
nullptr
;
}
mLock
.
writeUnlock
(
)
;
}
ReadWriteSpinLock
mLock
;
Atomic
<
T
*
>
mPtr
;
}
;
}
template
<
typename
T
>
class
SupportsThreadSafeWeakPtr
:
public
external
:
:
AtomicRefCounted
<
T
>
{
protected
:
typedef
external
:
:
AtomicRefCounted
<
T
>
AtomicRefCounted
;
typedef
detail
:
:
ThreadSafeWeakReference
<
T
>
ThreadSafeWeakReference
;
public
:
~
SupportsThreadSafeWeakPtr
(
)
{
if
(
ThreadSafeWeakReference
*
ptr
=
mRef
)
{
ptr
-
>
Release
(
)
;
}
}
void
Release
(
)
const
{
if
(
AtomicRefCounted
:
:
hasOneRef
(
)
)
{
if
(
ThreadSafeWeakReference
*
ptr
=
mRef
)
{
ptr
-
>
tryDetach
(
this
)
;
}
}
AtomicRefCounted
:
:
Release
(
)
;
}
private
:
template
<
typename
U
>
friend
class
ThreadSafeWeakPtr
;
already_AddRefed
<
ThreadSafeWeakReference
>
getThreadSafeWeakReference
(
)
{
static_assert
(
std
:
:
is_base_of
<
SupportsThreadSafeWeakPtr
<
T
>
T
>
:
:
value
"
T
must
derive
from
SupportsThreadSafeWeakPtr
<
T
>
"
)
;
if
(
!
mRef
)
{
RefPtr
<
ThreadSafeWeakReference
>
ptr
(
new
ThreadSafeWeakReference
(
static_cast
<
T
*
>
(
this
)
)
)
;
if
(
mRef
.
compareExchange
(
nullptr
ptr
)
)
{
Unused
<
<
ptr
.
forget
(
)
;
}
}
RefPtr
<
ThreadSafeWeakReference
>
ptr
(
mRef
)
;
return
ptr
.
forget
(
)
;
}
Atomic
<
ThreadSafeWeakReference
*
>
mRef
;
}
;
template
<
typename
T
>
class
ThreadSafeWeakPtr
{
typedef
typename
T
:
:
ThreadSafeWeakReference
ThreadSafeWeakReference
;
public
:
ThreadSafeWeakPtr
(
)
{
}
ThreadSafeWeakPtr
&
operator
=
(
const
ThreadSafeWeakPtr
&
aOther
)
{
mRef
=
aOther
.
mRef
;
return
*
this
;
}
ThreadSafeWeakPtr
(
const
ThreadSafeWeakPtr
&
aOther
)
:
mRef
(
aOther
.
mRef
)
{
}
ThreadSafeWeakPtr
&
operator
=
(
ThreadSafeWeakPtr
&
&
aOther
)
{
mRef
=
std
:
:
move
(
aOther
.
mRef
)
;
return
*
this
;
}
ThreadSafeWeakPtr
(
ThreadSafeWeakPtr
&
&
aOther
)
:
mRef
(
std
:
:
move
(
aOther
.
mRef
)
)
{
}
ThreadSafeWeakPtr
&
operator
=
(
const
RefPtr
<
T
>
&
aOther
)
{
if
(
aOther
)
{
mRef
=
aOther
-
>
getThreadSafeWeakReference
(
)
;
}
else
{
mRef
=
nullptr
;
}
return
*
this
;
}
explicit
ThreadSafeWeakPtr
(
const
RefPtr
<
T
>
&
aOther
)
{
*
this
=
aOther
;
}
ThreadSafeWeakPtr
&
operator
=
(
decltype
(
nullptr
)
)
{
mRef
=
nullptr
;
return
*
this
;
}
explicit
ThreadSafeWeakPtr
(
decltype
(
nullptr
)
)
{
}
explicit
operator
bool
(
)
const
{
return
!
!
get
(
)
;
}
bool
operator
=
=
(
const
ThreadSafeWeakPtr
&
aOther
)
const
{
return
get
(
)
=
=
aOther
.
get
(
)
;
}
bool
operator
=
=
(
const
RefPtr
<
T
>
&
aOther
)
const
{
return
get
(
)
=
=
aOther
.
get
(
)
;
}
bool
operator
=
=
(
const
T
*
aOther
)
const
{
return
get
(
)
=
=
aOther
;
}
template
<
typename
U
>
bool
operator
!
=
(
const
U
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
explicit
operator
RefPtr
<
T
>
(
)
const
{
return
getRefPtr
(
)
;
}
private
:
already_AddRefed
<
T
>
getRefPtr
(
)
const
{
static_assert
(
std
:
:
is_base_of
<
typename
ThreadSafeWeakReference
:
:
ElementType
T
>
:
:
value
"
T
must
derive
from
ThreadSafeWeakReference
:
:
ElementType
"
)
;
return
mRef
?
mRef
-
>
getRefPtr
(
)
.
template
downcast
<
T
>
(
)
:
nullptr
;
}
T
*
get
(
)
const
{
static_assert
(
std
:
:
is_base_of
<
typename
ThreadSafeWeakReference
:
:
ElementType
T
>
:
:
value
"
T
must
derive
from
ThreadSafeWeakReference
:
:
ElementType
"
)
;
return
mRef
?
static_cast
<
T
*
>
(
mRef
-
>
get
(
)
)
:
nullptr
;
}
RefPtr
<
ThreadSafeWeakReference
>
mRef
;
}
;
}
template
<
typename
T
>
inline
already_AddRefed
<
T
>
do_AddRef
(
const
mozilla
:
:
ThreadSafeWeakPtr
<
T
>
&
aObj
)
{
RefPtr
<
T
>
ref
(
aObj
)
;
return
ref
.
forget
(
)
;
}
#
endif
