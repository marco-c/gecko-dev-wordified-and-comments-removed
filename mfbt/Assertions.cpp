#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
<
stdarg
.
h
>
#
include
<
string
.
h
>
#
include
"
fmt
/
format
.
h
"
MOZ_BEGIN_EXTERN_C
MFBT_DATA
const
char
*
gMozCrashReason
=
nullptr
;
static
char
sPrintfCrashReason
[
sPrintfCrashReasonSize
]
=
{
}
;
static
mozilla
:
:
Atomic
<
bool
mozilla
:
:
SequentiallyConsistent
>
sCrashing
(
false
)
;
MFBT_API
MOZ_COLD
MOZ_NEVER_INLINE
MOZ_FORMAT_PRINTF
(
1
2
)
const
char
*
MOZ_CrashPrintf
(
const
char
*
aFormat
.
.
.
)
{
if
(
!
sCrashing
.
compareExchange
(
false
true
)
)
{
MOZ_RELEASE_ASSERT
(
false
)
;
}
va_list
aArgs
;
va_start
(
aArgs
aFormat
)
;
int
ret
=
VsprintfLiteral
(
sPrintfCrashReason
aFormat
aArgs
)
;
va_end
(
aArgs
)
;
MOZ_RELEASE_ASSERT
(
ret
>
=
0
&
&
size_t
(
ret
)
<
sPrintfCrashReasonSize
"
Could
not
write
the
explanation
string
to
the
supplied
buffer
!
"
)
;
return
sPrintfCrashReason
;
}
MOZ_END_EXTERN_C
#
ifdef
__cplusplus
namespace
mozilla
:
:
detail
{
template
<
typename
.
.
.
Args
>
const
char
*
CrashFmtImpl
(
const
char
*
format
Args
&
&
.
.
.
args
)
{
if
(
!
sCrashing
.
compareExchange
(
false
true
)
)
{
MOZ_RELEASE_ASSERT
(
false
)
;
}
auto
result
=
fmt
:
:
vformat_to_n
(
sPrintfCrashReason
sPrintfCrashReasonSize
-
1
format
fmt
:
:
make_format_args
(
args
.
.
.
)
)
;
sPrintfCrashReason
[
result
.
size
]
=
'
\
0
'
;
return
sPrintfCrashReason
;
}
}
#
endif
MFBT_API
MOZ_NORETURN
MOZ_COLD
void
mozilla
:
:
detail
:
:
InvalidArrayIndex_CRASH
(
size_t
aIndex
size_t
aLength
)
{
MOZ_CRASH_UNSAFE_PRINTF
(
"
ElementAt
(
aIndex
=
%
zu
aLength
=
%
zu
)
"
aIndex
aLength
)
;
}
