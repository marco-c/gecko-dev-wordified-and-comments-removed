#
ifndef
mfbt_MaybeStorageBase_h
#
define
mfbt_MaybeStorageBase_h
#
include
<
type_traits
>
#
include
<
utility
>
namespace
mozilla
:
:
detail
{
template
<
typename
T
>
constexpr
bool
IsTriviallyDestructibleAndCopyable
=
std
:
:
is_trivially_destructible_v
<
T
>
&
&
(
std
:
:
is_trivially_copy_constructible_v
<
T
>
|
|
!
std
:
:
is_copy_constructible_v
<
T
>
)
;
template
<
typename
T
bool
TriviallyDestructibleAndCopyable
=
IsTriviallyDestructibleAndCopyable
<
T
>
>
struct
MaybeStorageBase
;
struct
Dummy
{
}
;
template
<
typename
T
>
struct
MaybeStorageBase
<
T
false
>
{
protected
:
using
NonConstT
=
std
:
:
remove_const_t
<
T
>
;
union
Union
{
Union
(
)
{
}
explicit
Union
(
const
T
&
aVal
)
:
val
{
aVal
}
{
}
template
<
typename
U
typename
=
std
:
:
enable_if_t
<
std
:
:
is_move_constructible_v
<
U
>
>
>
explicit
Union
(
U
&
&
aVal
)
:
val
{
std
:
:
forward
<
U
>
(
aVal
)
}
{
}
template
<
typename
.
.
.
Args
>
explicit
Union
(
std
:
:
in_place_t
Args
&
&
.
.
.
aArgs
)
:
val
{
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
}
{
}
~
Union
(
)
{
}
NonConstT
val
;
}
mStorage
;
public
:
MaybeStorageBase
(
)
=
default
;
explicit
MaybeStorageBase
(
const
T
&
aVal
)
:
mStorage
{
aVal
}
{
}
explicit
MaybeStorageBase
(
T
&
&
aVal
)
:
mStorage
{
std
:
:
move
(
aVal
)
}
{
}
template
<
typename
.
.
.
Args
>
explicit
MaybeStorageBase
(
std
:
:
in_place_t
Args
&
&
.
.
.
aArgs
)
:
mStorage
{
std
:
:
in_place
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
}
{
}
const
T
*
addr
(
)
const
{
return
&
mStorage
.
val
;
}
T
*
addr
(
)
{
return
&
mStorage
.
val
;
}
}
;
template
<
typename
T
>
struct
MaybeStorageBase
<
T
true
>
{
protected
:
using
NonConstT
=
std
:
:
remove_const_t
<
T
>
;
union
Union
{
constexpr
Union
(
)
:
dummy
(
)
{
}
constexpr
explicit
Union
(
const
T
&
aVal
)
:
val
{
aVal
}
{
}
constexpr
explicit
Union
(
T
&
&
aVal
)
:
val
{
std
:
:
move
(
aVal
)
}
{
}
template
<
typename
.
.
.
Args
>
constexpr
explicit
Union
(
std
:
:
in_place_t
Args
&
&
.
.
.
aArgs
)
:
val
{
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
}
{
}
NonConstT
val
;
Dummy
dummy
;
}
mStorage
;
public
:
constexpr
MaybeStorageBase
(
)
=
default
;
constexpr
explicit
MaybeStorageBase
(
const
T
&
aVal
)
:
mStorage
{
aVal
}
{
}
constexpr
explicit
MaybeStorageBase
(
T
&
&
aVal
)
:
mStorage
{
std
:
:
move
(
aVal
)
}
{
}
template
<
typename
.
.
.
Args
>
constexpr
explicit
MaybeStorageBase
(
std
:
:
in_place_t
Args
&
&
.
.
.
aArgs
)
:
mStorage
{
std
:
:
in_place
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
}
{
}
constexpr
const
T
*
addr
(
)
const
{
return
&
mStorage
.
val
;
}
constexpr
T
*
addr
(
)
{
return
&
mStorage
.
val
;
}
}
;
}
#
endif
