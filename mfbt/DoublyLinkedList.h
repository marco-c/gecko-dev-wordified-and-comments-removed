#
ifndef
mozilla_DoublyLinkedList_h
#
define
mozilla_DoublyLinkedList_h
#
include
<
algorithm
>
#
include
<
iterator
>
#
include
"
mozilla
/
Assertions
.
h
"
namespace
mozilla
{
template
<
typename
T
>
struct
DoublyLinkedSiblingAccess
{
static
void
SetNext
(
T
*
aElm
T
*
aNext
)
{
aElm
-
>
mNext
=
aNext
;
}
static
T
*
GetNext
(
T
*
aElm
)
{
return
aElm
-
>
mNext
;
}
static
void
SetPrev
(
T
*
aElm
T
*
aPrev
)
{
aElm
-
>
mPrev
=
aPrev
;
}
static
T
*
GetPrev
(
T
*
aElm
)
{
return
aElm
-
>
mPrev
;
}
}
;
template
<
typename
T
>
struct
DoublyLinkedListElement
{
friend
struct
DoublyLinkedSiblingAccess
<
T
>
;
T
*
mNext
;
T
*
mPrev
;
public
:
DoublyLinkedListElement
(
)
:
mNext
(
nullptr
)
mPrev
(
nullptr
)
{
}
}
;
template
<
typename
T
typename
SiblingAccess
=
DoublyLinkedSiblingAccess
<
T
>
>
class
DoublyLinkedList
final
{
T
*
mHead
;
T
*
mTail
;
bool
isStateValid
(
)
const
{
return
(
mHead
!
=
nullptr
)
=
=
(
mTail
!
=
nullptr
)
;
}
bool
ElementNotInList
(
T
*
aElm
)
{
if
(
!
SiblingAccess
:
:
GetNext
(
aElm
)
&
&
!
SiblingAccess
:
:
GetPrev
(
aElm
)
)
{
return
mHead
!
=
aElm
;
}
return
false
;
}
public
:
DoublyLinkedList
(
)
:
mHead
(
nullptr
)
mTail
(
nullptr
)
{
}
class
Iterator
final
{
T
*
mCurrent
;
public
:
using
iterator_category
=
std
:
:
forward_iterator_tag
;
using
value_type
=
T
;
using
difference_type
=
std
:
:
ptrdiff_t
;
using
pointer
=
T
*
;
using
reference
=
T
&
;
Iterator
(
)
:
mCurrent
(
nullptr
)
{
}
explicit
Iterator
(
T
*
aCurrent
)
:
mCurrent
(
aCurrent
)
{
}
T
&
operator
*
(
)
const
{
return
*
mCurrent
;
}
T
*
operator
-
>
(
)
const
{
return
mCurrent
;
}
Iterator
&
operator
+
+
(
)
{
mCurrent
=
SiblingAccess
:
:
GetNext
(
mCurrent
)
;
return
*
this
;
}
Iterator
operator
+
+
(
int
)
{
Iterator
result
=
*
this
;
+
+
(
*
this
)
;
return
result
;
}
Iterator
&
operator
-
-
(
)
{
mCurrent
=
SiblingAccess
:
:
GetPrev
(
mCurrent
)
;
return
*
this
;
}
Iterator
operator
-
-
(
int
)
{
Iterator
result
=
*
this
;
-
-
(
*
this
)
;
return
result
;
}
bool
operator
!
=
(
const
Iterator
&
aOther
)
const
{
return
mCurrent
!
=
aOther
.
mCurrent
;
}
bool
operator
=
=
(
const
Iterator
&
aOther
)
const
{
return
mCurrent
=
=
aOther
.
mCurrent
;
}
explicit
operator
bool
(
)
const
{
return
mCurrent
;
}
}
;
Iterator
begin
(
)
{
return
Iterator
(
mHead
)
;
}
const
Iterator
begin
(
)
const
{
return
Iterator
(
mHead
)
;
}
const
Iterator
cbegin
(
)
const
{
return
Iterator
(
mHead
)
;
}
Iterator
end
(
)
{
return
Iterator
(
)
;
}
const
Iterator
end
(
)
const
{
return
Iterator
(
)
;
}
const
Iterator
cend
(
)
const
{
return
Iterator
(
)
;
}
bool
isEmpty
(
)
const
{
MOZ_ASSERT
(
isStateValid
(
)
)
;
return
mHead
=
=
nullptr
;
}
void
pushFront
(
T
*
aElm
)
{
MOZ_ASSERT
(
aElm
)
;
MOZ_ASSERT
(
ElementNotInList
(
aElm
)
)
;
MOZ_ASSERT
(
isStateValid
(
)
)
;
SiblingAccess
:
:
SetNext
(
aElm
mHead
)
;
if
(
mHead
)
{
MOZ_ASSERT
(
!
SiblingAccess
:
:
GetPrev
(
mHead
)
)
;
SiblingAccess
:
:
SetPrev
(
mHead
aElm
)
;
}
mHead
=
aElm
;
if
(
!
mTail
)
{
mTail
=
aElm
;
}
}
T
*
popFront
(
)
{
MOZ_ASSERT
(
!
isEmpty
(
)
)
;
MOZ_ASSERT
(
isStateValid
(
)
)
;
T
*
result
=
mHead
;
mHead
=
result
?
SiblingAccess
:
:
GetNext
(
result
)
:
nullptr
;
if
(
mHead
)
{
SiblingAccess
:
:
SetPrev
(
mHead
nullptr
)
;
}
if
(
mTail
=
=
result
)
{
mTail
=
nullptr
;
}
if
(
result
)
{
SiblingAccess
:
:
SetNext
(
result
nullptr
)
;
SiblingAccess
:
:
SetPrev
(
result
nullptr
)
;
}
return
result
;
}
void
pushBack
(
T
*
aElm
)
{
MOZ_ASSERT
(
aElm
)
;
MOZ_ASSERT
(
ElementNotInList
(
aElm
)
)
;
MOZ_ASSERT
(
isStateValid
(
)
)
;
SiblingAccess
:
:
SetNext
(
aElm
nullptr
)
;
SiblingAccess
:
:
SetPrev
(
aElm
mTail
)
;
if
(
mTail
)
{
MOZ_ASSERT
(
!
SiblingAccess
:
:
GetNext
(
mTail
)
)
;
SiblingAccess
:
:
SetNext
(
mTail
aElm
)
;
}
mTail
=
aElm
;
if
(
!
mHead
)
{
mHead
=
aElm
;
}
}
T
*
popBack
(
)
{
MOZ_ASSERT
(
!
isEmpty
(
)
)
;
MOZ_ASSERT
(
isStateValid
(
)
)
;
T
*
result
=
mTail
;
mTail
=
result
?
SiblingAccess
:
:
GetPrev
(
result
)
:
nullptr
;
if
(
mTail
)
{
SiblingAccess
:
:
SetNext
(
mTail
nullptr
)
;
}
if
(
mHead
=
=
result
)
{
mHead
=
nullptr
;
}
if
(
result
)
{
SiblingAccess
:
:
SetNext
(
result
nullptr
)
;
SiblingAccess
:
:
SetPrev
(
result
nullptr
)
;
}
return
result
;
}
void
insertBefore
(
const
Iterator
&
aIter
T
*
aElm
)
{
MOZ_ASSERT
(
aElm
)
;
MOZ_ASSERT
(
ElementNotInList
(
aElm
)
)
;
MOZ_ASSERT
(
isStateValid
(
)
)
;
if
(
!
aIter
)
{
return
pushBack
(
aElm
)
;
}
else
if
(
aIter
=
=
begin
(
)
)
{
return
pushFront
(
aElm
)
;
}
T
*
after
=
&
(
*
aIter
)
;
T
*
before
=
SiblingAccess
:
:
GetPrev
(
after
)
;
MOZ_ASSERT
(
before
)
;
SiblingAccess
:
:
SetNext
(
before
aElm
)
;
SiblingAccess
:
:
SetPrev
(
aElm
before
)
;
SiblingAccess
:
:
SetNext
(
aElm
after
)
;
SiblingAccess
:
:
SetPrev
(
after
aElm
)
;
}
void
remove
(
T
*
aElm
)
{
MOZ_ASSERT
(
aElm
)
;
MOZ_ASSERT
(
SiblingAccess
:
:
GetNext
(
aElm
)
|
|
SiblingAccess
:
:
GetPrev
(
aElm
)
|
|
(
aElm
=
=
mHead
&
&
aElm
=
=
mTail
)
"
Attempted
to
remove
element
not
in
this
list
"
)
;
if
(
T
*
prev
=
SiblingAccess
:
:
GetPrev
(
aElm
)
)
{
SiblingAccess
:
:
SetNext
(
prev
SiblingAccess
:
:
GetNext
(
aElm
)
)
;
}
else
{
MOZ_ASSERT
(
mHead
=
=
aElm
)
;
mHead
=
SiblingAccess
:
:
GetNext
(
aElm
)
;
}
if
(
T
*
next
=
SiblingAccess
:
:
GetNext
(
aElm
)
)
{
SiblingAccess
:
:
SetPrev
(
next
SiblingAccess
:
:
GetPrev
(
aElm
)
)
;
}
else
{
MOZ_ASSERT
(
mTail
=
=
aElm
)
;
mTail
=
SiblingAccess
:
:
GetPrev
(
aElm
)
;
}
SiblingAccess
:
:
SetNext
(
aElm
nullptr
)
;
SiblingAccess
:
:
SetPrev
(
aElm
nullptr
)
;
}
Iterator
find
(
const
T
&
aElm
)
{
return
std
:
:
find
(
begin
(
)
end
(
)
aElm
)
;
}
bool
contains
(
const
T
&
aElm
)
{
return
find
(
aElm
)
!
=
Iterator
(
)
;
}
}
;
}
#
endif
