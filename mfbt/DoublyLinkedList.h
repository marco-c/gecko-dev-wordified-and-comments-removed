#
ifndef
mozilla_DoublyLinkedList_h
#
define
mozilla_DoublyLinkedList_h
#
include
<
algorithm
>
#
include
<
iosfwd
>
#
include
<
iterator
>
#
include
<
type_traits
>
#
include
"
mozilla
/
Assertions
.
h
"
namespace
mozilla
{
template
<
typename
T
>
class
DoublyLinkedListElement
{
template
<
typename
U
typename
E
>
friend
class
DoublyLinkedList
;
friend
T
;
T
*
mNext
;
T
*
mPrev
;
public
:
DoublyLinkedListElement
(
)
:
mNext
(
nullptr
)
mPrev
(
nullptr
)
{
}
}
;
template
<
typename
T
>
struct
GetDoublyLinkedListElement
{
static_assert
(
std
:
:
is_base_of
<
DoublyLinkedListElement
<
T
>
T
>
:
:
value
"
You
need
your
own
specialization
of
GetDoublyLinkedListElement
"
"
or
use
a
separate
Trait
.
"
)
;
static
DoublyLinkedListElement
<
T
>
&
Get
(
T
*
aThis
)
{
return
*
aThis
;
}
}
;
template
<
typename
T
typename
ElementAccess
=
GetDoublyLinkedListElement
<
T
>
>
class
DoublyLinkedList
final
{
T
*
mHead
;
T
*
mTail
;
bool
isStateValid
(
)
const
{
return
(
mHead
!
=
nullptr
)
=
=
(
mTail
!
=
nullptr
)
;
}
bool
ElementNotInList
(
T
*
aElm
)
{
if
(
!
ElementAccess
:
:
Get
(
aElm
)
.
mNext
&
&
!
ElementAccess
:
:
Get
(
aElm
)
.
mPrev
)
{
return
mHead
!
=
aElm
;
}
return
false
;
}
public
:
DoublyLinkedList
(
)
:
mHead
(
nullptr
)
mTail
(
nullptr
)
{
}
class
Iterator
final
{
T
*
mCurrent
;
public
:
using
iterator_category
=
std
:
:
forward_iterator_tag
;
using
value_type
=
T
;
using
difference_type
=
std
:
:
ptrdiff_t
;
using
pointer
=
T
*
;
using
reference
=
T
&
;
Iterator
(
)
:
mCurrent
(
nullptr
)
{
}
explicit
Iterator
(
T
*
aCurrent
)
:
mCurrent
(
aCurrent
)
{
}
T
&
operator
*
(
)
const
{
return
*
mCurrent
;
}
T
*
operator
-
>
(
)
const
{
return
mCurrent
;
}
Iterator
&
operator
+
+
(
)
{
mCurrent
=
ElementAccess
:
:
Get
(
mCurrent
)
.
mNext
;
return
*
this
;
}
Iterator
operator
+
+
(
int
)
{
Iterator
result
=
*
this
;
+
+
(
*
this
)
;
return
result
;
}
Iterator
&
operator
-
-
(
)
{
mCurrent
=
ElementAccess
:
:
Get
(
mCurrent
)
.
mPrev
;
return
*
this
;
}
Iterator
operator
-
-
(
int
)
{
Iterator
result
=
*
this
;
-
-
(
*
this
)
;
return
result
;
}
bool
operator
!
=
(
const
Iterator
&
aOther
)
const
{
return
mCurrent
!
=
aOther
.
mCurrent
;
}
bool
operator
=
=
(
const
Iterator
&
aOther
)
const
{
return
mCurrent
=
=
aOther
.
mCurrent
;
}
explicit
operator
bool
(
)
const
{
return
mCurrent
;
}
}
;
Iterator
begin
(
)
{
return
Iterator
(
mHead
)
;
}
const
Iterator
begin
(
)
const
{
return
Iterator
(
mHead
)
;
}
const
Iterator
cbegin
(
)
const
{
return
Iterator
(
mHead
)
;
}
Iterator
end
(
)
{
return
Iterator
(
)
;
}
const
Iterator
end
(
)
const
{
return
Iterator
(
)
;
}
const
Iterator
cend
(
)
const
{
return
Iterator
(
)
;
}
bool
isEmpty
(
)
const
{
MOZ_ASSERT
(
isStateValid
(
)
)
;
return
mHead
=
=
nullptr
;
}
void
pushFront
(
T
*
aElm
)
{
MOZ_ASSERT
(
aElm
)
;
MOZ_ASSERT
(
ElementNotInList
(
aElm
)
)
;
MOZ_ASSERT
(
isStateValid
(
)
)
;
ElementAccess
:
:
Get
(
aElm
)
.
mNext
=
mHead
;
if
(
mHead
)
{
MOZ_ASSERT
(
!
ElementAccess
:
:
Get
(
mHead
)
.
mPrev
)
;
ElementAccess
:
:
Get
(
mHead
)
.
mPrev
=
aElm
;
}
mHead
=
aElm
;
if
(
!
mTail
)
{
mTail
=
aElm
;
}
}
T
*
popFront
(
)
{
MOZ_ASSERT
(
!
isEmpty
(
)
)
;
MOZ_ASSERT
(
isStateValid
(
)
)
;
T
*
result
=
mHead
;
mHead
=
result
?
ElementAccess
:
:
Get
(
result
)
.
mNext
:
nullptr
;
if
(
mHead
)
{
ElementAccess
:
:
Get
(
mHead
)
.
mPrev
=
nullptr
;
}
if
(
mTail
=
=
result
)
{
mTail
=
nullptr
;
}
if
(
result
)
{
ElementAccess
:
:
Get
(
result
)
.
mNext
=
nullptr
;
ElementAccess
:
:
Get
(
result
)
.
mPrev
=
nullptr
;
}
return
result
;
}
void
pushBack
(
T
*
aElm
)
{
MOZ_ASSERT
(
aElm
)
;
MOZ_ASSERT
(
ElementNotInList
(
aElm
)
)
;
MOZ_ASSERT
(
isStateValid
(
)
)
;
ElementAccess
:
:
Get
(
aElm
)
.
mNext
=
nullptr
;
ElementAccess
:
:
Get
(
aElm
)
.
mPrev
=
mTail
;
if
(
mTail
)
{
MOZ_ASSERT
(
!
ElementAccess
:
:
Get
(
mTail
)
.
mNext
)
;
ElementAccess
:
:
Get
(
mTail
)
.
mNext
=
aElm
;
}
mTail
=
aElm
;
if
(
!
mHead
)
{
mHead
=
aElm
;
}
}
T
*
popBack
(
)
{
MOZ_ASSERT
(
!
isEmpty
(
)
)
;
MOZ_ASSERT
(
isStateValid
(
)
)
;
T
*
result
=
mTail
;
mTail
=
result
?
ElementAccess
:
:
Get
(
result
)
.
mPrev
:
nullptr
;
if
(
mTail
)
{
ElementAccess
:
:
Get
(
mTail
)
.
mNext
=
nullptr
;
}
if
(
mHead
=
=
result
)
{
mHead
=
nullptr
;
}
if
(
result
)
{
ElementAccess
:
:
Get
(
result
)
.
mNext
=
nullptr
;
ElementAccess
:
:
Get
(
result
)
.
mPrev
=
nullptr
;
}
return
result
;
}
void
insertBefore
(
const
Iterator
&
aIter
T
*
aElm
)
{
MOZ_ASSERT
(
aElm
)
;
MOZ_ASSERT
(
ElementNotInList
(
aElm
)
)
;
MOZ_ASSERT
(
isStateValid
(
)
)
;
if
(
!
aIter
)
{
return
pushBack
(
aElm
)
;
}
else
if
(
aIter
=
=
begin
(
)
)
{
return
pushFront
(
aElm
)
;
}
T
*
after
=
&
(
*
aIter
)
;
T
*
before
=
ElementAccess
:
:
Get
(
after
)
.
mPrev
;
MOZ_ASSERT
(
before
)
;
ElementAccess
:
:
Get
(
before
)
.
mNext
=
aElm
;
ElementAccess
:
:
Get
(
aElm
)
.
mPrev
=
before
;
ElementAccess
:
:
Get
(
aElm
)
.
mNext
=
after
;
ElementAccess
:
:
Get
(
after
)
.
mPrev
=
aElm
;
}
void
remove
(
T
*
aElm
)
{
MOZ_ASSERT
(
aElm
)
;
MOZ_ASSERT
(
ElementAccess
:
:
Get
(
aElm
)
.
mNext
|
|
ElementAccess
:
:
Get
(
aElm
)
.
mPrev
|
|
(
aElm
=
=
mHead
&
&
aElm
=
=
mTail
)
"
Attempted
to
remove
element
not
in
this
list
"
)
;
if
(
T
*
prev
=
ElementAccess
:
:
Get
(
aElm
)
.
mPrev
)
{
ElementAccess
:
:
Get
(
prev
)
.
mNext
=
ElementAccess
:
:
Get
(
aElm
)
.
mNext
;
}
else
{
MOZ_ASSERT
(
mHead
=
=
aElm
)
;
mHead
=
ElementAccess
:
:
Get
(
aElm
)
.
mNext
;
}
if
(
T
*
next
=
ElementAccess
:
:
Get
(
aElm
)
.
mNext
)
{
ElementAccess
:
:
Get
(
next
)
.
mPrev
=
ElementAccess
:
:
Get
(
aElm
)
.
mPrev
;
}
else
{
MOZ_ASSERT
(
mTail
=
=
aElm
)
;
mTail
=
ElementAccess
:
:
Get
(
aElm
)
.
mPrev
;
}
ElementAccess
:
:
Get
(
aElm
)
.
mNext
=
nullptr
;
ElementAccess
:
:
Get
(
aElm
)
.
mPrev
=
nullptr
;
}
Iterator
find
(
const
T
&
aElm
)
{
return
std
:
:
find
(
begin
(
)
end
(
)
aElm
)
;
}
bool
contains
(
const
T
&
aElm
)
{
return
find
(
aElm
)
!
=
Iterator
(
)
;
}
bool
ElementProbablyInList
(
T
*
aElm
)
{
if
(
isEmpty
(
)
)
{
return
false
;
}
return
!
ElementNotInList
(
aElm
)
;
}
}
;
}
#
endif
