#
ifndef
mozilla_Algorithm_h
#
define
mozilla_Algorithm_h
#
include
"
mozilla
/
Result
.
h
"
#
include
<
iterator
>
#
include
<
type_traits
>
namespace
mozilla
{
template
<
class
Iter
class
Pred
>
constexpr
bool
AllOf
(
Iter
aFirst
Iter
aLast
Pred
aPred
)
{
for
(
;
aFirst
!
=
aLast
;
+
+
aFirst
)
{
if
(
!
aPred
(
*
aFirst
)
)
{
return
false
;
}
}
return
true
;
}
namespace
detail
{
template
<
typename
Transform
typename
SrcIter
>
using
ArrayElementTransformType
=
typename
std
:
:
invoke_result_t
<
Transform
typename
std
:
:
iterator_traits
<
SrcIter
>
:
:
reference
>
;
template
<
typename
Transform
typename
SrcIter
>
struct
TransformTraits
{
using
result_type
=
ArrayElementTransformType
<
Transform
SrcIter
>
;
using
result_ok_type
=
typename
result_type
:
:
ok_type
;
using
result_err_type
=
typename
result_type
:
:
err_type
;
}
;
}
template
<
typename
SrcIter
typename
DstIter
typename
Cond
typename
Transform
>
Result
<
Ok
typename
detail
:
:
TransformTraits
<
Transform
SrcIter
>
:
:
result_err_type
>
TransformIfAbortOnErr
(
SrcIter
aIter
SrcIter
aEnd
DstIter
aDst
Cond
aCond
Transform
aTransform
)
{
for
(
;
aIter
!
=
aEnd
;
+
+
aIter
)
{
if
(
!
aCond
(
static_cast
<
std
:
:
add_const_t
<
typename
std
:
:
iterator_traits
<
SrcIter
>
:
:
value_type
>
&
>
(
*
aIter
)
)
)
{
continue
;
}
auto
res
=
aTransform
(
*
aIter
)
;
if
(
res
.
isErr
(
)
)
{
return
Err
(
res
.
unwrapErr
(
)
)
;
}
*
aDst
+
+
=
res
.
unwrap
(
)
;
}
return
Ok
{
}
;
}
template
<
typename
SrcRange
typename
DstIter
typename
Cond
typename
Transform
>
auto
TransformIfAbortOnErr
(
SrcRange
&
aRange
DstIter
aDst
Cond
aCond
Transform
aTransform
)
{
using
std
:
:
begin
;
using
std
:
:
end
;
return
TransformIfAbortOnErr
(
begin
(
aRange
)
end
(
aRange
)
aDst
aCond
aTransform
)
;
}
template
<
typename
SrcIter
typename
DstIter
typename
Transform
>
Result
<
Ok
typename
detail
:
:
TransformTraits
<
Transform
SrcIter
>
:
:
result_err_type
>
TransformAbortOnErr
(
SrcIter
aIter
SrcIter
aEnd
DstIter
aDst
Transform
aTransform
)
{
return
TransformIfAbortOnErr
(
aIter
aEnd
aDst
[
]
(
const
auto
&
)
{
return
true
;
}
aTransform
)
;
}
template
<
typename
SrcRange
typename
DstIter
typename
Transform
>
auto
TransformAbortOnErr
(
SrcRange
&
aRange
DstIter
aDst
Transform
aTransform
)
{
using
std
:
:
begin
;
using
std
:
:
end
;
return
TransformIfAbortOnErr
(
begin
(
aRange
)
end
(
aRange
)
aDst
[
]
(
const
auto
&
)
{
return
true
;
}
aTransform
)
;
}
}
#
endif
