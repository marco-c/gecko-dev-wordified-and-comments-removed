#
include
<
new
>
#
include
"
mozilla
/
Alignment
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
ifndef
mozilla_Variant_h
#
define
mozilla_Variant_h
namespace
mozilla
{
template
<
typename
.
.
.
Ts
>
class
Variant
;
namespace
detail
{
template
<
typename
T
typename
.
.
.
Ts
>
struct
MaxSizeOf
{
static
const
size_t
size
=
sizeof
(
T
)
>
MaxSizeOf
<
Ts
.
.
.
>
:
:
size
?
sizeof
(
T
)
:
MaxSizeOf
<
Ts
.
.
.
>
:
:
size
;
}
;
template
<
typename
T
>
struct
MaxSizeOf
<
T
>
{
static
const
size_t
size
=
sizeof
(
T
)
;
}
;
template
<
typename
Needle
typename
.
.
.
Haystack
>
struct
IsVariant
;
template
<
typename
Needle
>
struct
IsVariant
<
Needle
>
{
static
const
bool
value
=
false
;
}
;
template
<
typename
Needle
typename
.
.
.
Haystack
>
struct
IsVariant
<
Needle
Needle
Haystack
.
.
.
>
{
static
const
bool
value
=
true
;
}
;
template
<
typename
Needle
typename
T
typename
.
.
.
Haystack
>
struct
IsVariant
<
Needle
T
Haystack
.
.
.
>
:
public
IsVariant
<
Needle
Haystack
.
.
.
>
{
}
;
template
<
typename
T
typename
.
.
.
Variants
>
struct
SelectVariantTypeHelper
;
template
<
typename
T
>
struct
SelectVariantTypeHelper
<
T
>
{
}
;
template
<
typename
T
typename
.
.
.
Variants
>
struct
SelectVariantTypeHelper
<
T
T
Variants
.
.
.
>
{
typedef
T
Type
;
}
;
template
<
typename
T
typename
.
.
.
Variants
>
struct
SelectVariantTypeHelper
<
T
const
T
Variants
.
.
.
>
{
typedef
const
T
Type
;
}
;
template
<
typename
T
typename
.
.
.
Variants
>
struct
SelectVariantTypeHelper
<
T
const
T
&
Variants
.
.
.
>
{
typedef
const
T
&
Type
;
}
;
template
<
typename
T
typename
.
.
.
Variants
>
struct
SelectVariantTypeHelper
<
T
T
&
&
Variants
.
.
.
>
{
typedef
T
&
&
Type
;
}
;
template
<
typename
T
typename
Head
typename
.
.
.
Variants
>
struct
SelectVariantTypeHelper
<
T
Head
Variants
.
.
.
>
:
public
SelectVariantTypeHelper
<
T
Variants
.
.
.
>
{
}
;
template
<
typename
T
typename
.
.
.
Variants
>
struct
SelectVariantType
:
public
SelectVariantTypeHelper
<
typename
RemoveConst
<
typename
RemoveReference
<
T
>
:
:
Type
>
:
:
Type
Variants
.
.
.
>
{
}
;
template
<
size_t
N
typename
T
typename
U
typename
Next
bool
isMatch
>
struct
TagHelper
;
template
<
size_t
N
typename
T
typename
U
typename
Next
>
struct
TagHelper
<
N
T
U
Next
false
>
{
static
size_t
tag
(
)
{
return
Next
:
:
template
tag
<
U
>
(
)
;
}
}
;
template
<
size_t
N
typename
T
typename
U
typename
Next
>
struct
TagHelper
<
N
T
U
Next
true
>
{
static
size_t
tag
(
)
{
return
N
;
}
}
;
template
<
size_t
N
typename
.
.
.
Ts
>
struct
VariantImplementation
;
template
<
size_t
N
typename
T
>
struct
VariantImplementation
<
N
T
>
{
template
<
typename
U
>
static
size_t
tag
(
)
{
static_assert
(
mozilla
:
:
IsSame
<
T
U
>
:
:
value
"
mozilla
:
:
Variant
:
tag
:
bad
type
!
"
)
;
return
N
;
}
template
<
typename
Variant
>
static
void
copyConstruct
(
void
*
aLhs
const
Variant
&
aRhs
)
{
new
(
aLhs
)
T
(
aRhs
.
template
as
<
T
>
(
)
)
;
}
template
<
typename
Variant
>
static
void
moveConstruct
(
void
*
aLhs
Variant
&
&
aRhs
)
{
new
(
aLhs
)
T
(
aRhs
.
template
extract
<
T
>
(
)
)
;
}
template
<
typename
Variant
>
static
void
destroy
(
Variant
&
aV
)
{
aV
.
template
as
<
T
>
(
)
.
~
T
(
)
;
}
template
<
typename
Variant
>
static
bool
equal
(
const
Variant
&
aLhs
const
Variant
&
aRhs
)
{
return
aLhs
.
template
as
<
T
>
(
)
=
=
aRhs
.
template
as
<
T
>
(
)
;
}
template
<
typename
Matcher
typename
ConcreteVariant
>
static
typename
Matcher
:
:
ReturnType
match
(
Matcher
&
aMatcher
ConcreteVariant
&
aV
)
{
return
aMatcher
.
match
(
aV
.
template
as
<
T
>
(
)
)
;
}
}
;
template
<
size_t
N
typename
T
typename
.
.
.
Ts
>
struct
VariantImplementation
<
N
T
Ts
.
.
.
>
{
using
Next
=
VariantImplementation
<
N
+
1
Ts
.
.
.
>
;
template
<
typename
U
>
static
size_t
tag
(
)
{
return
TagHelper
<
N
T
U
Next
IsSame
<
T
U
>
:
:
value
>
:
:
tag
(
)
;
}
template
<
typename
Variant
>
static
void
copyConstruct
(
void
*
aLhs
const
Variant
&
aRhs
)
{
if
(
aRhs
.
template
is
<
T
>
(
)
)
{
new
(
aLhs
)
T
(
aRhs
.
template
as
<
T
>
(
)
)
;
}
else
{
Next
:
:
copyConstruct
(
aLhs
aRhs
)
;
}
}
template
<
typename
Variant
>
static
void
moveConstruct
(
void
*
aLhs
Variant
&
&
aRhs
)
{
if
(
aRhs
.
template
is
<
T
>
(
)
)
{
new
(
aLhs
)
T
(
aRhs
.
template
extract
<
T
>
(
)
)
;
}
else
{
Next
:
:
moveConstruct
(
aLhs
aRhs
)
;
}
}
template
<
typename
Variant
>
static
void
destroy
(
Variant
&
aV
)
{
if
(
aV
.
template
is
<
T
>
(
)
)
{
aV
.
template
as
<
T
>
(
)
.
~
T
(
)
;
}
else
{
Next
:
:
destroy
(
aV
)
;
}
}
template
<
typename
Variant
>
static
bool
equal
(
const
Variant
&
aLhs
const
Variant
&
aRhs
)
{
if
(
aLhs
.
template
is
<
T
>
(
)
)
{
MOZ_ASSERT
(
aRhs
.
template
is
<
T
>
(
)
)
;
return
aLhs
.
template
as
<
T
>
(
)
=
=
aRhs
.
template
as
<
T
>
(
)
;
}
else
{
return
Next
:
:
equal
(
aLhs
aRhs
)
;
}
}
template
<
typename
Matcher
typename
ConcreteVariant
>
static
typename
Matcher
:
:
ReturnType
match
(
Matcher
&
aMatcher
ConcreteVariant
&
aV
)
{
if
(
aV
.
template
is
<
T
>
(
)
)
{
return
aMatcher
.
match
(
aV
.
template
as
<
T
>
(
)
)
;
}
else
{
return
Next
:
:
match
(
aMatcher
aV
)
;
}
}
}
;
}
template
<
typename
.
.
.
Ts
>
class
Variant
{
using
Impl
=
detail
:
:
VariantImplementation
<
0
Ts
.
.
.
>
;
using
RawData
=
AlignedStorage
<
detail
:
:
MaxSizeOf
<
Ts
.
.
.
>
:
:
size
>
;
size_t
tag
;
RawData
raw
;
void
*
ptr
(
)
{
return
reinterpret_cast
<
void
*
>
(
&
raw
)
;
}
public
:
template
<
typename
RefT
typename
T
=
typename
detail
:
:
SelectVariantType
<
RefT
Ts
.
.
.
>
:
:
Type
>
explicit
Variant
(
RefT
&
&
aT
)
:
tag
(
Impl
:
:
template
tag
<
T
>
(
)
)
{
new
(
ptr
(
)
)
T
(
Forward
<
T
>
(
aT
)
)
;
}
Variant
(
const
Variant
&
aRhs
)
:
tag
(
aRhs
.
tag
)
{
Impl
:
:
copyConstruct
(
ptr
(
)
aRhs
)
;
}
Variant
(
Variant
&
&
aRhs
)
:
tag
(
aRhs
.
tag
)
{
Impl
:
:
moveConstruct
(
ptr
(
)
Move
(
aRhs
)
)
;
}
Variant
&
operator
=
(
const
Variant
&
aRhs
)
{
MOZ_ASSERT
(
&
aRhs
!
=
this
"
self
-
assign
disallowed
"
)
;
this
-
>
~
Variant
(
)
;
new
(
this
)
Variant
(
aRhs
)
;
return
*
this
;
}
Variant
&
operator
=
(
Variant
&
&
aRhs
)
{
MOZ_ASSERT
(
&
aRhs
!
=
this
"
self
-
assign
disallowed
"
)
;
this
-
>
~
Variant
(
)
;
new
(
this
)
Variant
(
Move
(
aRhs
)
)
;
return
*
this
;
}
~
Variant
(
)
{
Impl
:
:
destroy
(
*
this
)
;
}
template
<
typename
T
>
bool
is
(
)
const
{
static_assert
(
detail
:
:
IsVariant
<
T
Ts
.
.
.
>
:
:
value
"
provided
a
type
not
found
in
this
Variant
'
s
type
list
"
)
;
return
Impl
:
:
template
tag
<
T
>
(
)
=
=
tag
;
}
bool
operator
=
=
(
const
Variant
&
aRhs
)
const
{
return
tag
=
=
aRhs
.
tag
&
&
Impl
:
:
equal
(
*
this
aRhs
)
;
}
bool
operator
!
=
(
const
Variant
&
aRhs
)
const
{
return
!
(
*
this
=
=
aRhs
)
;
}
template
<
typename
T
>
T
&
as
(
)
{
static_assert
(
detail
:
:
IsVariant
<
T
Ts
.
.
.
>
:
:
value
"
provided
a
type
not
found
in
this
Variant
'
s
type
list
"
)
;
MOZ_ASSERT
(
is
<
T
>
(
)
)
;
return
*
reinterpret_cast
<
T
*
>
(
&
raw
)
;
}
template
<
typename
T
>
const
T
&
as
(
)
const
{
static_assert
(
detail
:
:
IsVariant
<
T
Ts
.
.
.
>
:
:
value
"
provided
a
type
not
found
in
this
Variant
'
s
type
list
"
)
;
MOZ_ASSERT
(
is
<
T
>
(
)
)
;
return
*
reinterpret_cast
<
const
T
*
>
(
&
raw
)
;
}
template
<
typename
T
>
T
extract
(
)
{
static_assert
(
detail
:
:
IsVariant
<
T
Ts
.
.
.
>
:
:
value
"
provided
a
type
not
found
in
this
Variant
'
s
type
list
"
)
;
MOZ_ASSERT
(
is
<
T
>
(
)
)
;
return
T
(
Move
(
as
<
T
>
(
)
)
)
;
}
template
<
typename
Matcher
>
typename
Matcher
:
:
ReturnType
match
(
Matcher
&
aMatcher
)
const
{
return
Impl
:
:
match
(
aMatcher
*
this
)
;
}
template
<
typename
Matcher
>
typename
Matcher
:
:
ReturnType
match
(
Matcher
&
aMatcher
)
{
return
Impl
:
:
match
(
aMatcher
*
this
)
;
}
}
;
}
#
endif
