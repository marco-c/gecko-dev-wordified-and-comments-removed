#
ifndef
mozilla_WeakPtr_h
#
define
mozilla_WeakPtr_h
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
RefCounted
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
TypeTraits
.
h
"
#
include
<
string
.
h
>
namespace
mozilla
{
template
<
typename
T
>
class
WeakPtr
;
template
<
typename
T
>
class
SupportsWeakPtr
;
#
ifdef
MOZ_REFCOUNTED_LEAK_CHECKING
#
define
MOZ_DECLARE_WEAKREFERENCE_TYPENAME
(
T
)
\
static
const
char
*
weakReferenceTypeName
(
)
{
return
"
WeakReference
<
"
#
T
"
>
"
;
}
#
else
#
define
MOZ_DECLARE_WEAKREFERENCE_TYPENAME
(
T
)
#
endif
namespace
detail
{
template
<
class
T
>
class
WeakReference
:
public
:
:
mozilla
:
:
RefCounted
<
WeakReference
<
T
>
>
{
public
:
explicit
WeakReference
(
T
*
p
)
:
mPtr
(
p
)
{
}
~
WeakReference
(
)
{
if
(
mPtr
)
{
mPtr
-
>
NoticeSelfReferencingDestruction
(
)
;
}
}
T
*
get
(
)
const
{
return
mPtr
;
}
#
ifdef
MOZ_REFCOUNTED_LEAK_CHECKING
const
char
*
typeName
(
)
const
{
return
T
:
:
weakReferenceTypeName
(
)
;
}
size_t
typeSize
(
)
const
{
return
sizeof
(
*
this
)
;
}
#
endif
private
:
friend
class
mozilla
:
:
SupportsWeakPtr
<
T
>
;
void
detach
(
)
{
mPtr
=
nullptr
;
}
T
*
MOZ_NON_OWNING_REF
mPtr
;
}
;
}
template
<
typename
T
>
class
SupportsWeakPtr
{
protected
:
SupportsWeakPtr
(
)
:
mSelfReferencingWeakPtr
(
nullptr
)
{
}
~
SupportsWeakPtr
(
)
{
static_assert
(
IsBaseOf
<
SupportsWeakPtr
<
T
>
T
>
:
:
value
"
T
must
derive
from
SupportsWeakPtr
<
T
>
"
)
;
if
(
mSelfReferencingWeakPtr
)
{
mSelfReferencingWeakPtr
-
>
detach
(
)
;
mSelfReferencingWeakPtr
=
nullptr
;
}
}
private
:
detail
:
:
WeakReference
<
T
>
*
SelfReferencingWeakPtr
(
)
{
if
(
!
mSelfReferencingWeakPtr
)
{
mSelfReferencingWeakPtr
=
new
detail
:
:
WeakReference
<
T
>
(
static_cast
<
T
*
>
(
this
)
)
;
}
return
mSelfReferencingWeakPtr
;
}
detail
:
:
WeakReference
<
const
T
>
*
SelfReferencingWeakPtr
(
)
const
{
detail
:
:
WeakReference
<
T
>
*
p
=
const_cast
<
SupportsWeakPtr
*
>
(
this
)
-
>
SelfReferencingWeakPtr
(
)
;
return
reinterpret_cast
<
detail
:
:
WeakReference
<
const
T
>
*
>
(
p
)
;
}
void
NoticeSelfReferencingDestruction
(
)
const
{
mSelfReferencingWeakPtr
=
nullptr
;
}
friend
class
WeakPtr
<
T
>
;
friend
class
WeakPtr
<
const
T
>
;
friend
class
detail
:
:
WeakReference
<
T
>
;
friend
class
detail
:
:
WeakReference
<
const
T
>
;
mutable
detail
:
:
WeakReference
<
T
>
*
mSelfReferencingWeakPtr
;
}
;
template
<
typename
T
>
class
WeakPtr
{
typedef
detail
:
:
WeakReference
<
T
>
WeakReference
;
public
:
WeakPtr
&
operator
=
(
const
WeakPtr
&
aOther
)
{
mRef
=
aOther
.
mRef
;
return
*
this
;
}
WeakPtr
(
const
WeakPtr
&
aOther
)
{
*
this
=
aOther
;
}
WeakPtr
&
operator
=
(
T
*
aOther
)
{
if
(
aOther
)
{
mRef
=
aOther
-
>
SelfReferencingWeakPtr
(
)
;
}
else
if
(
!
mRef
|
|
mRef
-
>
get
(
)
)
{
mRef
=
new
WeakReference
(
nullptr
)
;
}
return
*
this
;
}
MOZ_IMPLICIT
WeakPtr
(
T
*
aOther
)
{
*
this
=
aOther
;
}
WeakPtr
(
)
:
mRef
(
new
WeakReference
(
nullptr
)
)
{
}
operator
T
*
(
)
const
{
return
mRef
-
>
get
(
)
;
}
T
&
operator
*
(
)
const
{
return
*
mRef
-
>
get
(
)
;
}
T
*
operator
-
>
(
)
const
MOZ_NO_ADDREF_RELEASE_ON_RETURN
{
return
mRef
-
>
get
(
)
;
}
T
*
get
(
)
const
{
return
mRef
-
>
get
(
)
;
}
private
:
RefPtr
<
WeakReference
>
mRef
;
}
;
}
#
endif
