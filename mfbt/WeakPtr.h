#
ifndef
mozilla_WeakPtr_h
#
define
mozilla_WeakPtr_h
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
RefCounted
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
TypeTraits
.
h
"
#
include
<
string
.
h
>
#
if
defined
(
MOZILLA_INTERNAL_API
)
#
include
"
nsISupportsImpl
.
h
"
#
endif
#
if
defined
(
MOZILLA_INTERNAL_API
)
&
&
defined
(
MOZ_THREAD_SAFETY_OWNERSHIP_CHECKS_SUPPORTED
)
#
define
MOZ_WEAKPTR_DECLARE_THREAD_SAFETY_CHECK
\
Maybe
<
nsAutoOwningThread
>
_owningThread
;
#
define
MOZ_WEAKPTR_INIT_THREAD_SAFETY_CHECK
(
)
\
do
{
\
if
(
p
)
{
\
_owningThread
.
emplace
(
)
;
\
}
\
}
while
(
false
)
#
define
MOZ_WEAKPTR_ASSERT_THREAD_SAFETY
(
)
\
do
{
\
if
(
_owningThread
.
isSome
(
)
&
&
!
_owningThread
.
ref
(
)
.
IsCurrentThread
(
)
)
{
\
WeakPtrTraits
<
T
>
:
:
AssertSafeToAccessFromNonOwningThread
(
)
;
\
}
\
}
while
(
false
)
#
define
MOZ_WEAKPTR_ASSERT_THREAD_SAFETY_DELEGATED
(
that
)
\
(
that
)
-
>
AssertThreadSafety
(
)
;
#
define
MOZ_WEAKPTR_THREAD_SAFETY_CHECKING
1
#
else
#
define
MOZ_WEAKPTR_DECLARE_THREAD_SAFETY_CHECK
#
define
MOZ_WEAKPTR_INIT_THREAD_SAFETY_CHECK
(
)
do
{
}
while
(
false
)
#
define
MOZ_WEAKPTR_ASSERT_THREAD_SAFETY
(
)
do
{
}
while
(
false
)
#
define
MOZ_WEAKPTR_ASSERT_THREAD_SAFETY_DELEGATED
(
that
)
do
{
}
while
(
false
)
#
endif
namespace
mozilla
{
template
<
typename
T
>
class
WeakPtr
;
template
<
typename
T
>
class
SupportsWeakPtr
;
#
ifdef
MOZ_REFCOUNTED_LEAK_CHECKING
#
define
MOZ_DECLARE_WEAKREFERENCE_TYPENAME
(
T
)
\
static
const
char
*
weakReferenceTypeName
(
)
{
return
"
WeakReference
<
"
#
T
"
>
"
;
}
#
else
#
define
MOZ_DECLARE_WEAKREFERENCE_TYPENAME
(
T
)
#
endif
template
<
class
T
>
struct
WeakPtrTraits
{
static
void
AssertSafeToAccessFromNonOwningThread
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
false
"
WeakPtr
accessed
from
multiple
threads
"
)
;
}
}
;
namespace
detail
{
template
<
class
T
>
class
WeakReference
:
public
:
:
mozilla
:
:
RefCounted
<
WeakReference
<
T
>
>
{
public
:
explicit
WeakReference
(
T
*
p
)
:
mPtr
(
p
)
{
MOZ_WEAKPTR_INIT_THREAD_SAFETY_CHECK
(
)
;
}
T
*
get
(
)
const
{
MOZ_WEAKPTR_ASSERT_THREAD_SAFETY
(
)
;
return
mPtr
;
}
#
ifdef
MOZ_REFCOUNTED_LEAK_CHECKING
const
char
*
typeName
(
)
const
{
return
T
:
:
weakReferenceTypeName
(
)
;
}
size_t
typeSize
(
)
const
{
return
sizeof
(
*
this
)
;
}
#
endif
#
ifdef
MOZ_WEAKPTR_THREAD_SAFETY_CHECKING
void
AssertThreadSafety
(
)
{
MOZ_WEAKPTR_ASSERT_THREAD_SAFETY
(
)
;
}
#
endif
private
:
friend
class
mozilla
:
:
SupportsWeakPtr
<
T
>
;
void
detach
(
)
{
MOZ_WEAKPTR_ASSERT_THREAD_SAFETY
(
)
;
mPtr
=
nullptr
;
}
T
*
MOZ_NON_OWNING_REF
mPtr
;
MOZ_WEAKPTR_DECLARE_THREAD_SAFETY_CHECK
}
;
}
template
<
typename
T
>
class
SupportsWeakPtr
{
protected
:
~
SupportsWeakPtr
(
)
{
static_assert
(
IsBaseOf
<
SupportsWeakPtr
<
T
>
T
>
:
:
value
"
T
must
derive
from
SupportsWeakPtr
<
T
>
"
)
;
if
(
mSelfReferencingWeakPtr
)
{
mSelfReferencingWeakPtr
.
mRef
-
>
detach
(
)
;
}
}
private
:
const
WeakPtr
<
T
>
&
SelfReferencingWeakPtr
(
)
{
if
(
!
mSelfReferencingWeakPtr
)
{
mSelfReferencingWeakPtr
.
mRef
=
new
detail
:
:
WeakReference
<
T
>
(
static_cast
<
T
*
>
(
this
)
)
;
}
else
{
MOZ_WEAKPTR_ASSERT_THREAD_SAFETY_DELEGATED
(
mSelfReferencingWeakPtr
.
mRef
)
;
}
return
mSelfReferencingWeakPtr
;
}
const
WeakPtr
<
const
T
>
&
SelfReferencingWeakPtr
(
)
const
{
const
WeakPtr
<
T
>
&
p
=
const_cast
<
SupportsWeakPtr
*
>
(
this
)
-
>
SelfReferencingWeakPtr
(
)
;
return
reinterpret_cast
<
const
WeakPtr
<
const
T
>
&
>
(
p
)
;
}
friend
class
WeakPtr
<
T
>
;
friend
class
WeakPtr
<
const
T
>
;
WeakPtr
<
T
>
mSelfReferencingWeakPtr
;
}
;
template
<
typename
T
>
class
WeakPtr
{
typedef
detail
:
:
WeakReference
<
T
>
WeakReference
;
public
:
WeakPtr
&
operator
=
(
const
WeakPtr
&
aOther
)
{
mRef
=
aOther
.
mRef
;
MOZ_WEAKPTR_ASSERT_THREAD_SAFETY_DELEGATED
(
mRef
)
;
return
*
this
;
}
WeakPtr
(
const
WeakPtr
&
aOther
)
{
*
this
=
aOther
;
}
WeakPtr
&
operator
=
(
T
*
aOther
)
{
if
(
aOther
)
{
*
this
=
aOther
-
>
SelfReferencingWeakPtr
(
)
;
}
else
if
(
!
mRef
|
|
mRef
-
>
get
(
)
)
{
mRef
=
new
WeakReference
(
nullptr
)
;
}
return
*
this
;
}
MOZ_IMPLICIT
WeakPtr
(
T
*
aOther
)
{
*
this
=
aOther
;
MOZ_WEAKPTR_ASSERT_THREAD_SAFETY_DELEGATED
(
mRef
)
;
}
WeakPtr
(
)
:
mRef
(
new
WeakReference
(
nullptr
)
)
{
}
operator
T
*
(
)
const
{
return
mRef
-
>
get
(
)
;
}
T
&
operator
*
(
)
const
{
return
*
mRef
-
>
get
(
)
;
}
T
*
operator
-
>
(
)
const
MOZ_NO_ADDREF_RELEASE_ON_RETURN
{
return
mRef
-
>
get
(
)
;
}
T
*
get
(
)
const
{
return
mRef
-
>
get
(
)
;
}
private
:
friend
class
SupportsWeakPtr
<
T
>
;
explicit
WeakPtr
(
const
RefPtr
<
WeakReference
>
&
aOther
)
:
mRef
(
aOther
)
{
}
RefPtr
<
WeakReference
>
mRef
;
}
;
}
#
endif
