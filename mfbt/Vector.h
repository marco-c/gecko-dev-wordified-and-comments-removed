#
ifndef
mozilla_Vector_h
#
define
mozilla_Vector_h
#
include
"
mozilla
/
Alignment
.
h
"
#
include
"
mozilla
/
AllocPolicy
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
ReentrancyGuard
.
h
"
#
include
"
mozilla
/
TemplateLib
.
h
"
#
include
"
mozilla
/
TypeTraits
.
h
"
#
include
<
new
>
#
ifdef
_MSC_VER
#
pragma
warning
(
push
)
#
pragma
warning
(
disable
:
4345
)
#
endif
namespace
mozilla
{
template
<
typename
T
size_t
N
class
AllocPolicy
>
class
Vector
;
namespace
detail
{
template
<
typename
T
>
static
bool
CapacityHasExcessSpace
(
size_t
aCapacity
)
{
size_t
size
=
aCapacity
*
sizeof
(
T
)
;
return
RoundUpPow2
(
size
)
-
size
>
=
sizeof
(
T
)
;
}
template
<
typename
T
size_t
N
class
AP
bool
IsPod
>
struct
VectorImpl
{
MOZ_NONNULL
(
1
)
static
inline
void
new_
(
T
*
aDst
)
{
new
(
aDst
)
T
(
)
;
}
template
<
typename
U
>
MOZ_NONNULL
(
1
)
static
inline
void
new_
(
T
*
aDst
U
&
&
aU
)
{
new
(
aDst
)
T
(
Forward
<
U
>
(
aU
)
)
;
}
static
inline
void
destroy
(
T
*
aBegin
T
*
aEnd
)
{
MOZ_ASSERT
(
aBegin
<
=
aEnd
)
;
for
(
T
*
p
=
aBegin
;
p
<
aEnd
;
+
+
p
)
{
p
-
>
~
T
(
)
;
}
}
static
inline
void
initialize
(
T
*
aBegin
T
*
aEnd
)
{
MOZ_ASSERT
(
aBegin
<
=
aEnd
)
;
for
(
T
*
p
=
aBegin
;
p
<
aEnd
;
+
+
p
)
{
new_
(
p
)
;
}
}
template
<
typename
U
>
static
inline
void
copyConstruct
(
T
*
aDst
const
U
*
aSrcStart
const
U
*
aSrcEnd
)
{
MOZ_ASSERT
(
aSrcStart
<
=
aSrcEnd
)
;
for
(
const
U
*
p
=
aSrcStart
;
p
<
aSrcEnd
;
+
+
p
+
+
aDst
)
{
new_
(
aDst
*
p
)
;
}
}
template
<
typename
U
>
static
inline
void
moveConstruct
(
T
*
aDst
U
*
aSrcStart
U
*
aSrcEnd
)
{
MOZ_ASSERT
(
aSrcStart
<
=
aSrcEnd
)
;
for
(
U
*
p
=
aSrcStart
;
p
<
aSrcEnd
;
+
+
p
+
+
aDst
)
{
new_
(
aDst
Move
(
*
p
)
)
;
}
}
template
<
typename
U
>
static
inline
void
copyConstructN
(
T
*
aDst
size_t
aN
const
U
&
aU
)
{
for
(
T
*
end
=
aDst
+
aN
;
aDst
<
end
;
+
+
aDst
)
{
new_
(
aDst
aU
)
;
}
}
static
inline
bool
growTo
(
Vector
<
T
N
AP
>
&
aV
size_t
aNewCap
)
{
MOZ_ASSERT
(
!
aV
.
usingInlineStorage
(
)
)
;
MOZ_ASSERT
(
!
CapacityHasExcessSpace
<
T
>
(
aNewCap
)
)
;
T
*
newbuf
=
aV
.
template
pod_malloc
<
T
>
(
aNewCap
)
;
if
(
MOZ_UNLIKELY
(
!
newbuf
)
)
{
return
false
;
}
T
*
dst
=
newbuf
;
T
*
src
=
aV
.
beginNoCheck
(
)
;
for
(
;
src
<
aV
.
endNoCheck
(
)
;
+
+
dst
+
+
src
)
{
new_
(
dst
Move
(
*
src
)
)
;
}
VectorImpl
:
:
destroy
(
aV
.
beginNoCheck
(
)
aV
.
endNoCheck
(
)
)
;
aV
.
free_
(
aV
.
mBegin
)
;
aV
.
mBegin
=
newbuf
;
aV
.
mCapacity
=
aNewCap
;
return
true
;
}
}
;
template
<
typename
T
size_t
N
class
AP
>
struct
VectorImpl
<
T
N
AP
true
>
{
static
inline
void
new_
(
T
*
aDst
)
{
*
aDst
=
T
(
)
;
}
template
<
typename
U
>
static
inline
void
new_
(
T
*
aDst
U
&
&
aU
)
{
*
aDst
=
Forward
<
U
>
(
aU
)
;
}
static
inline
void
destroy
(
T
*
T
*
)
{
}
static
inline
void
initialize
(
T
*
aBegin
T
*
aEnd
)
{
MOZ_ASSERT
(
aBegin
<
=
aEnd
)
;
for
(
T
*
p
=
aBegin
;
p
<
aEnd
;
+
+
p
)
{
new_
(
p
)
;
}
}
template
<
typename
U
>
static
inline
void
copyConstruct
(
T
*
aDst
const
U
*
aSrcStart
const
U
*
aSrcEnd
)
{
MOZ_ASSERT
(
aSrcStart
<
=
aSrcEnd
)
;
for
(
const
U
*
p
=
aSrcStart
;
p
<
aSrcEnd
;
+
+
p
+
+
aDst
)
{
new_
(
aDst
*
p
)
;
}
}
template
<
typename
U
>
static
inline
void
moveConstruct
(
T
*
aDst
const
U
*
aSrcStart
const
U
*
aSrcEnd
)
{
copyConstruct
(
aDst
aSrcStart
aSrcEnd
)
;
}
static
inline
void
copyConstructN
(
T
*
aDst
size_t
aN
const
T
&
aT
)
{
for
(
T
*
end
=
aDst
+
aN
;
aDst
<
end
;
+
+
aDst
)
{
new_
(
aDst
aT
)
;
}
}
static
inline
bool
growTo
(
Vector
<
T
N
AP
>
&
aV
size_t
aNewCap
)
{
MOZ_ASSERT
(
!
aV
.
usingInlineStorage
(
)
)
;
MOZ_ASSERT
(
!
CapacityHasExcessSpace
<
T
>
(
aNewCap
)
)
;
T
*
newbuf
=
aV
.
template
pod_realloc
<
T
>
(
aV
.
mBegin
aV
.
mCapacity
aNewCap
)
;
if
(
MOZ_UNLIKELY
(
!
newbuf
)
)
{
return
false
;
}
aV
.
mBegin
=
newbuf
;
aV
.
mCapacity
=
aNewCap
;
return
true
;
}
}
;
struct
VectorTesting
;
}
template
<
typename
T
size_t
MinInlineCapacity
=
0
class
AllocPolicy
=
MallocAllocPolicy
>
class
Vector
final
:
private
AllocPolicy
{
static
const
bool
kElemIsPod
=
IsPod
<
T
>
:
:
value
;
typedef
detail
:
:
VectorImpl
<
T
MinInlineCapacity
AllocPolicy
kElemIsPod
>
Impl
;
friend
struct
detail
:
:
VectorImpl
<
T
MinInlineCapacity
AllocPolicy
kElemIsPod
>
;
friend
struct
detail
:
:
VectorTesting
;
MOZ_WARN_UNUSED_RESULT
bool
growStorageBy
(
size_t
aIncr
)
;
MOZ_WARN_UNUSED_RESULT
bool
convertToHeapStorage
(
size_t
aNewCap
)
;
static
const
int
kMaxInlineBytes
=
1024
;
template
<
int
M
int
Dummy
>
struct
ElemSize
{
static
const
size_t
value
=
sizeof
(
T
)
;
}
;
template
<
int
Dummy
>
struct
ElemSize
<
0
Dummy
>
{
static
const
size_t
value
=
1
;
}
;
static
const
size_t
kInlineCapacity
=
tl
:
:
Min
<
MinInlineCapacity
kMaxInlineBytes
/
ElemSize
<
MinInlineCapacity
0
>
:
:
value
>
:
:
value
;
static
const
size_t
kInlineBytes
=
tl
:
:
Max
<
1
kInlineCapacity
*
ElemSize
<
MinInlineCapacity
0
>
:
:
value
>
:
:
value
;
T
*
mBegin
;
size_t
mLength
;
size_t
mCapacity
;
#
ifdef
DEBUG
size_t
mReserved
;
#
endif
AlignedStorage
<
kInlineBytes
>
mStorage
;
#
ifdef
DEBUG
friend
class
ReentrancyGuard
;
bool
mEntered
;
#
endif
bool
usingInlineStorage
(
)
const
{
return
mBegin
=
=
const_cast
<
Vector
*
>
(
this
)
-
>
inlineStorage
(
)
;
}
T
*
inlineStorage
(
)
{
return
static_cast
<
T
*
>
(
mStorage
.
addr
(
)
)
;
}
T
*
beginNoCheck
(
)
const
{
return
mBegin
;
}
T
*
endNoCheck
(
)
{
return
mBegin
+
mLength
;
}
const
T
*
endNoCheck
(
)
const
{
return
mBegin
+
mLength
;
}
#
ifdef
DEBUG
size_t
reserved
(
)
const
{
MOZ_ASSERT
(
mLength
<
=
mReserved
)
;
MOZ_ASSERT
(
mReserved
<
=
mCapacity
)
;
return
mReserved
;
}
#
endif
template
<
typename
U
>
void
internalAppend
(
U
&
&
aU
)
;
template
<
typename
U
size_t
O
class
BP
>
void
internalAppendAll
(
const
Vector
<
U
O
BP
>
&
aU
)
;
void
internalAppendN
(
const
T
&
aT
size_t
aN
)
;
template
<
typename
U
>
void
internalAppend
(
const
U
*
aBegin
size_t
aLength
)
;
public
:
static
const
size_t
sMaxInlineStorage
=
MinInlineCapacity
;
typedef
T
ElementType
;
explicit
Vector
(
AllocPolicy
=
AllocPolicy
(
)
)
;
Vector
(
Vector
&
&
)
;
Vector
&
operator
=
(
Vector
&
&
)
;
~
Vector
(
)
;
const
AllocPolicy
&
allocPolicy
(
)
const
{
return
*
this
;
}
AllocPolicy
&
allocPolicy
(
)
{
return
*
this
;
}
enum
{
InlineLength
=
MinInlineCapacity
}
;
size_t
length
(
)
const
{
return
mLength
;
}
bool
empty
(
)
const
{
return
mLength
=
=
0
;
}
size_t
capacity
(
)
const
{
return
mCapacity
;
}
T
*
begin
(
)
{
MOZ_ASSERT
(
!
mEntered
)
;
return
mBegin
;
}
const
T
*
begin
(
)
const
{
MOZ_ASSERT
(
!
mEntered
)
;
return
mBegin
;
}
T
*
end
(
)
{
MOZ_ASSERT
(
!
mEntered
)
;
return
mBegin
+
mLength
;
}
const
T
*
end
(
)
const
{
MOZ_ASSERT
(
!
mEntered
)
;
return
mBegin
+
mLength
;
}
T
&
operator
[
]
(
size_t
aIndex
)
{
MOZ_ASSERT
(
!
mEntered
)
;
MOZ_ASSERT
(
aIndex
<
mLength
)
;
return
begin
(
)
[
aIndex
]
;
}
const
T
&
operator
[
]
(
size_t
aIndex
)
const
{
MOZ_ASSERT
(
!
mEntered
)
;
MOZ_ASSERT
(
aIndex
<
mLength
)
;
return
begin
(
)
[
aIndex
]
;
}
T
&
back
(
)
{
MOZ_ASSERT
(
!
mEntered
)
;
MOZ_ASSERT
(
!
empty
(
)
)
;
return
*
(
end
(
)
-
1
)
;
}
const
T
&
back
(
)
const
{
MOZ_ASSERT
(
!
mEntered
)
;
MOZ_ASSERT
(
!
empty
(
)
)
;
return
*
(
end
(
)
-
1
)
;
}
class
Range
{
friend
class
Vector
;
T
*
mCur
;
T
*
mEnd
;
Range
(
T
*
aCur
T
*
aEnd
)
:
mCur
(
aCur
)
mEnd
(
aEnd
)
{
MOZ_ASSERT
(
aCur
<
=
aEnd
)
;
}
public
:
bool
empty
(
)
const
{
return
mCur
=
=
mEnd
;
}
size_t
remain
(
)
const
{
return
PointerRangeSize
(
mCur
mEnd
)
;
}
T
&
front
(
)
const
{
MOZ_ASSERT
(
!
empty
(
)
)
;
return
*
mCur
;
}
void
popFront
(
)
{
MOZ_ASSERT
(
!
empty
(
)
)
;
+
+
mCur
;
}
T
popCopyFront
(
)
{
MOZ_ASSERT
(
!
empty
(
)
)
;
return
*
mCur
+
+
;
}
}
;
class
ConstRange
{
friend
class
Vector
;
const
T
*
mCur
;
const
T
*
mEnd
;
ConstRange
(
const
T
*
aCur
const
T
*
aEnd
)
:
mCur
(
aCur
)
mEnd
(
aEnd
)
{
MOZ_ASSERT
(
aCur
<
=
aEnd
)
;
}
public
:
bool
empty
(
)
const
{
return
mCur
=
=
mEnd
;
}
size_t
remain
(
)
const
{
return
PointerRangeSize
(
mCur
mEnd
)
;
}
const
T
&
front
(
)
const
{
MOZ_ASSERT
(
!
empty
(
)
)
;
return
*
mCur
;
}
void
popFront
(
)
{
MOZ_ASSERT
(
!
empty
(
)
)
;
+
+
mCur
;
}
T
popCopyFront
(
)
{
MOZ_ASSERT
(
!
empty
(
)
)
;
return
*
mCur
+
+
;
}
}
;
Range
all
(
)
{
return
Range
(
begin
(
)
end
(
)
)
;
}
ConstRange
all
(
)
const
{
return
ConstRange
(
begin
(
)
end
(
)
)
;
}
MOZ_WARN_UNUSED_RESULT
bool
initCapacity
(
size_t
aRequest
)
;
MOZ_WARN_UNUSED_RESULT
bool
reserve
(
size_t
aRequest
)
;
void
shrinkBy
(
size_t
aIncr
)
;
void
shrinkTo
(
size_t
aNewLength
)
;
MOZ_WARN_UNUSED_RESULT
bool
growBy
(
size_t
aIncr
)
;
MOZ_WARN_UNUSED_RESULT
bool
resize
(
size_t
aNewLength
)
;
MOZ_WARN_UNUSED_RESULT
bool
growByUninitialized
(
size_t
aIncr
)
;
void
infallibleGrowByUninitialized
(
size_t
aIncr
)
;
MOZ_WARN_UNUSED_RESULT
bool
resizeUninitialized
(
size_t
aNewLength
)
;
void
clear
(
)
;
void
clearAndFree
(
)
;
bool
canAppendWithoutRealloc
(
size_t
aNeeded
)
const
;
template
<
typename
U
>
MOZ_WARN_UNUSED_RESULT
bool
append
(
U
&
&
aU
)
;
template
<
typename
.
.
.
Args
>
MOZ_WARN_UNUSED_RESULT
bool
emplaceBack
(
Args
&
&
.
.
.
aArgs
)
{
if
(
!
growByUninitialized
(
1
)
)
return
false
;
new
(
&
back
(
)
)
T
(
Forward
<
Args
>
(
aArgs
)
.
.
.
)
;
return
true
;
}
template
<
typename
U
size_t
O
class
BP
>
MOZ_WARN_UNUSED_RESULT
bool
appendAll
(
const
Vector
<
U
O
BP
>
&
aU
)
;
MOZ_WARN_UNUSED_RESULT
bool
appendN
(
const
T
&
aT
size_t
aN
)
;
template
<
typename
U
>
MOZ_WARN_UNUSED_RESULT
bool
append
(
const
U
*
aBegin
const
U
*
aEnd
)
;
template
<
typename
U
>
MOZ_WARN_UNUSED_RESULT
bool
append
(
const
U
*
aBegin
size_t
aLength
)
;
template
<
typename
U
>
void
infallibleAppend
(
U
&
&
aU
)
{
internalAppend
(
Forward
<
U
>
(
aU
)
)
;
}
void
infallibleAppendN
(
const
T
&
aT
size_t
aN
)
{
internalAppendN
(
aT
aN
)
;
}
template
<
typename
U
>
void
infallibleAppend
(
const
U
*
aBegin
const
U
*
aEnd
)
{
internalAppend
(
aBegin
PointerRangeSize
(
aBegin
aEnd
)
)
;
}
template
<
typename
U
>
void
infallibleAppend
(
const
U
*
aBegin
size_t
aLength
)
{
internalAppend
(
aBegin
aLength
)
;
}
template
<
typename
.
.
.
Args
>
void
infallibleEmplaceBack
(
Args
&
&
.
.
.
aArgs
)
{
infallibleGrowByUninitialized
(
1
)
;
new
(
&
back
(
)
)
T
(
Forward
<
Args
>
(
aArgs
)
.
.
.
)
;
}
void
popBack
(
)
;
T
popCopy
(
)
;
MOZ_WARN_UNUSED_RESULT
T
*
extractRawBuffer
(
)
;
void
replaceRawBuffer
(
T
*
aP
size_t
aLength
)
;
template
<
typename
U
>
MOZ_WARN_UNUSED_RESULT
T
*
insert
(
T
*
aP
U
&
&
aVal
)
;
void
erase
(
T
*
aT
)
;
void
erase
(
T
*
aBegin
T
*
aEnd
)
;
size_t
sizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
;
size_t
sizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
;
void
swap
(
Vector
&
aOther
)
;
private
:
Vector
(
const
Vector
&
)
=
delete
;
void
operator
=
(
const
Vector
&
)
=
delete
;
}
;
#
define
MOZ_REENTRANCY_GUARD_ET_AL
\
ReentrancyGuard
g
(
*
this
)
;
\
MOZ_ASSERT_IF
(
usingInlineStorage
(
)
mCapacity
=
=
kInlineCapacity
)
;
\
MOZ_ASSERT
(
reserved
(
)
<
=
mCapacity
)
;
\
MOZ_ASSERT
(
mLength
<
=
reserved
(
)
)
;
\
MOZ_ASSERT
(
mLength
<
=
mCapacity
)
template
<
typename
T
size_t
N
class
AP
>
MOZ_ALWAYS_INLINE
Vector
<
T
N
AP
>
:
:
Vector
(
AP
aAP
)
:
AP
(
aAP
)
mLength
(
0
)
mCapacity
(
kInlineCapacity
)
#
ifdef
DEBUG
mReserved
(
0
)
mEntered
(
false
)
#
endif
{
mBegin
=
static_cast
<
T
*
>
(
mStorage
.
addr
(
)
)
;
}
template
<
typename
T
size_t
N
class
AllocPolicy
>
MOZ_ALWAYS_INLINE
Vector
<
T
N
AllocPolicy
>
:
:
Vector
(
Vector
&
&
aRhs
)
:
AllocPolicy
(
Move
(
aRhs
)
)
#
ifdef
DEBUG
mEntered
(
false
)
#
endif
{
mLength
=
aRhs
.
mLength
;
mCapacity
=
aRhs
.
mCapacity
;
#
ifdef
DEBUG
mReserved
=
aRhs
.
mReserved
;
#
endif
if
(
aRhs
.
usingInlineStorage
(
)
)
{
mBegin
=
static_cast
<
T
*
>
(
mStorage
.
addr
(
)
)
;
Impl
:
:
moveConstruct
(
mBegin
aRhs
.
beginNoCheck
(
)
aRhs
.
endNoCheck
(
)
)
;
}
else
{
mBegin
=
aRhs
.
mBegin
;
aRhs
.
mBegin
=
static_cast
<
T
*
>
(
aRhs
.
mStorage
.
addr
(
)
)
;
aRhs
.
mCapacity
=
kInlineCapacity
;
aRhs
.
mLength
=
0
;
#
ifdef
DEBUG
aRhs
.
mReserved
=
0
;
#
endif
}
}
template
<
typename
T
size_t
N
class
AP
>
MOZ_ALWAYS_INLINE
Vector
<
T
N
AP
>
&
Vector
<
T
N
AP
>
:
:
operator
=
(
Vector
&
&
aRhs
)
{
MOZ_ASSERT
(
this
!
=
&
aRhs
"
self
-
move
assignment
is
prohibited
"
)
;
this
-
>
~
Vector
(
)
;
new
(
this
)
Vector
(
Move
(
aRhs
)
)
;
return
*
this
;
}
template
<
typename
T
size_t
N
class
AP
>
MOZ_ALWAYS_INLINE
Vector
<
T
N
AP
>
:
:
~
Vector
(
)
{
MOZ_REENTRANCY_GUARD_ET_AL
;
Impl
:
:
destroy
(
beginNoCheck
(
)
endNoCheck
(
)
)
;
if
(
!
usingInlineStorage
(
)
)
{
this
-
>
free_
(
beginNoCheck
(
)
)
;
}
}
template
<
typename
T
size_t
N
class
AP
>
inline
bool
Vector
<
T
N
AP
>
:
:
convertToHeapStorage
(
size_t
aNewCap
)
{
MOZ_ASSERT
(
usingInlineStorage
(
)
)
;
MOZ_ASSERT
(
!
detail
:
:
CapacityHasExcessSpace
<
T
>
(
aNewCap
)
)
;
T
*
newBuf
=
this
-
>
template
pod_malloc
<
T
>
(
aNewCap
)
;
if
(
MOZ_UNLIKELY
(
!
newBuf
)
)
{
return
false
;
}
Impl
:
:
moveConstruct
(
newBuf
beginNoCheck
(
)
endNoCheck
(
)
)
;
Impl
:
:
destroy
(
beginNoCheck
(
)
endNoCheck
(
)
)
;
mBegin
=
newBuf
;
mCapacity
=
aNewCap
;
return
true
;
}
template
<
typename
T
size_t
N
class
AP
>
MOZ_NEVER_INLINE
bool
Vector
<
T
N
AP
>
:
:
growStorageBy
(
size_t
aIncr
)
{
MOZ_ASSERT
(
mLength
+
aIncr
>
mCapacity
)
;
size_t
newCap
;
if
(
aIncr
=
=
1
)
{
if
(
usingInlineStorage
(
)
)
{
size_t
newSize
=
tl
:
:
RoundUpPow2
<
(
kInlineCapacity
+
1
)
*
sizeof
(
T
)
>
:
:
value
;
newCap
=
newSize
/
sizeof
(
T
)
;
goto
convert
;
}
if
(
mLength
=
=
0
)
{
newCap
=
1
;
goto
grow
;
}
if
(
MOZ_UNLIKELY
(
mLength
&
tl
:
:
MulOverflowMask
<
4
*
sizeof
(
T
)
>
:
:
value
)
)
{
this
-
>
reportAllocOverflow
(
)
;
return
false
;
}
newCap
=
mLength
*
2
;
if
(
detail
:
:
CapacityHasExcessSpace
<
T
>
(
newCap
)
)
{
newCap
+
=
1
;
}
}
else
{
size_t
newMinCap
=
mLength
+
aIncr
;
if
(
MOZ_UNLIKELY
(
newMinCap
<
mLength
|
|
newMinCap
&
tl
:
:
MulOverflowMask
<
2
*
sizeof
(
T
)
>
:
:
value
)
)
{
this
-
>
reportAllocOverflow
(
)
;
return
false
;
}
size_t
newMinSize
=
newMinCap
*
sizeof
(
T
)
;
size_t
newSize
=
RoundUpPow2
(
newMinSize
)
;
newCap
=
newSize
/
sizeof
(
T
)
;
}
if
(
usingInlineStorage
(
)
)
{
convert
:
return
convertToHeapStorage
(
newCap
)
;
}
grow
:
return
Impl
:
:
growTo
(
*
this
newCap
)
;
}
template
<
typename
T
size_t
N
class
AP
>
inline
bool
Vector
<
T
N
AP
>
:
:
initCapacity
(
size_t
aRequest
)
{
MOZ_ASSERT
(
empty
(
)
)
;
MOZ_ASSERT
(
usingInlineStorage
(
)
)
;
if
(
aRequest
=
=
0
)
{
return
true
;
}
T
*
newbuf
=
this
-
>
template
pod_malloc
<
T
>
(
aRequest
)
;
if
(
MOZ_UNLIKELY
(
!
newbuf
)
)
{
return
false
;
}
mBegin
=
newbuf
;
mCapacity
=
aRequest
;
#
ifdef
DEBUG
mReserved
=
aRequest
;
#
endif
return
true
;
}
template
<
typename
T
size_t
N
class
AP
>
inline
bool
Vector
<
T
N
AP
>
:
:
reserve
(
size_t
aRequest
)
{
MOZ_REENTRANCY_GUARD_ET_AL
;
if
(
aRequest
>
mCapacity
)
{
if
(
MOZ_UNLIKELY
(
!
growStorageBy
(
aRequest
-
mLength
)
)
)
{
return
false
;
}
}
else
if
(
aRequest
>
N
)
{
if
(
!
allocPolicy
(
)
.
checkSimulatedOOM
(
)
)
{
return
false
;
}
}
#
ifdef
DEBUG
if
(
aRequest
>
mReserved
)
{
mReserved
=
aRequest
;
}
MOZ_ASSERT
(
mLength
<
=
mReserved
)
;
MOZ_ASSERT
(
mReserved
<
=
mCapacity
)
;
#
endif
return
true
;
}
template
<
typename
T
size_t
N
class
AP
>
inline
void
Vector
<
T
N
AP
>
:
:
shrinkBy
(
size_t
aIncr
)
{
MOZ_REENTRANCY_GUARD_ET_AL
;
MOZ_ASSERT
(
aIncr
<
=
mLength
)
;
Impl
:
:
destroy
(
endNoCheck
(
)
-
aIncr
endNoCheck
(
)
)
;
mLength
-
=
aIncr
;
}
template
<
typename
T
size_t
N
class
AP
>
MOZ_ALWAYS_INLINE
void
Vector
<
T
N
AP
>
:
:
shrinkTo
(
size_t
aNewLength
)
{
MOZ_ASSERT
(
aNewLength
<
=
mLength
)
;
shrinkBy
(
mLength
-
aNewLength
)
;
}
template
<
typename
T
size_t
N
class
AP
>
MOZ_ALWAYS_INLINE
bool
Vector
<
T
N
AP
>
:
:
growBy
(
size_t
aIncr
)
{
MOZ_REENTRANCY_GUARD_ET_AL
;
if
(
aIncr
>
mCapacity
-
mLength
)
{
if
(
MOZ_UNLIKELY
(
!
growStorageBy
(
aIncr
)
)
)
{
return
false
;
}
}
else
if
(
aIncr
+
mLength
>
N
)
{
bool
checkSimulatedOOM
=
#
ifdef
DEBUG
aIncr
+
mLength
>
mReserved
;
#
else
true
;
#
endif
if
(
checkSimulatedOOM
&
&
!
allocPolicy
(
)
.
checkSimulatedOOM
(
)
)
{
return
false
;
}
}
MOZ_ASSERT
(
mLength
+
aIncr
<
=
mCapacity
)
;
T
*
newend
=
endNoCheck
(
)
+
aIncr
;
Impl
:
:
initialize
(
endNoCheck
(
)
newend
)
;
mLength
+
=
aIncr
;
#
ifdef
DEBUG
if
(
mLength
>
mReserved
)
{
mReserved
=
mLength
;
}
#
endif
return
true
;
}
template
<
typename
T
size_t
N
class
AP
>
MOZ_ALWAYS_INLINE
bool
Vector
<
T
N
AP
>
:
:
growByUninitialized
(
size_t
aIncr
)
{
MOZ_REENTRANCY_GUARD_ET_AL
;
if
(
aIncr
>
mCapacity
-
mLength
)
{
if
(
MOZ_UNLIKELY
(
!
growStorageBy
(
aIncr
)
)
)
{
return
false
;
}
}
else
if
(
aIncr
+
mLength
>
N
)
{
if
(
!
allocPolicy
(
)
.
checkSimulatedOOM
(
)
)
{
return
false
;
}
}
infallibleGrowByUninitialized
(
aIncr
)
;
return
true
;
}
template
<
typename
T
size_t
N
class
AP
>
MOZ_ALWAYS_INLINE
void
Vector
<
T
N
AP
>
:
:
infallibleGrowByUninitialized
(
size_t
aIncr
)
{
MOZ_ASSERT
(
mLength
+
aIncr
<
=
mCapacity
)
;
mLength
+
=
aIncr
;
#
ifdef
DEBUG
if
(
mLength
>
mReserved
)
{
mReserved
=
mLength
;
}
#
endif
}
template
<
typename
T
size_t
N
class
AP
>
inline
bool
Vector
<
T
N
AP
>
:
:
resize
(
size_t
aNewLength
)
{
size_t
curLength
=
mLength
;
if
(
aNewLength
>
curLength
)
{
return
growBy
(
aNewLength
-
curLength
)
;
}
shrinkBy
(
curLength
-
aNewLength
)
;
return
true
;
}
template
<
typename
T
size_t
N
class
AP
>
MOZ_ALWAYS_INLINE
bool
Vector
<
T
N
AP
>
:
:
resizeUninitialized
(
size_t
aNewLength
)
{
size_t
curLength
=
mLength
;
if
(
aNewLength
>
curLength
)
{
return
growByUninitialized
(
aNewLength
-
curLength
)
;
}
shrinkBy
(
curLength
-
aNewLength
)
;
return
true
;
}
template
<
typename
T
size_t
N
class
AP
>
inline
void
Vector
<
T
N
AP
>
:
:
clear
(
)
{
MOZ_REENTRANCY_GUARD_ET_AL
;
Impl
:
:
destroy
(
beginNoCheck
(
)
endNoCheck
(
)
)
;
mLength
=
0
;
}
template
<
typename
T
size_t
N
class
AP
>
inline
void
Vector
<
T
N
AP
>
:
:
clearAndFree
(
)
{
clear
(
)
;
if
(
usingInlineStorage
(
)
)
{
return
;
}
this
-
>
free_
(
beginNoCheck
(
)
)
;
mBegin
=
static_cast
<
T
*
>
(
mStorage
.
addr
(
)
)
;
mCapacity
=
kInlineCapacity
;
#
ifdef
DEBUG
mReserved
=
0
;
#
endif
}
template
<
typename
T
size_t
N
class
AP
>
inline
bool
Vector
<
T
N
AP
>
:
:
canAppendWithoutRealloc
(
size_t
aNeeded
)
const
{
return
mLength
+
aNeeded
<
=
mCapacity
;
}
template
<
typename
T
size_t
N
class
AP
>
template
<
typename
U
size_t
O
class
BP
>
MOZ_ALWAYS_INLINE
void
Vector
<
T
N
AP
>
:
:
internalAppendAll
(
const
Vector
<
U
O
BP
>
&
aOther
)
{
internalAppend
(
aOther
.
begin
(
)
aOther
.
length
(
)
)
;
}
template
<
typename
T
size_t
N
class
AP
>
template
<
typename
U
>
MOZ_ALWAYS_INLINE
void
Vector
<
T
N
AP
>
:
:
internalAppend
(
U
&
&
aU
)
{
MOZ_ASSERT
(
mLength
+
1
<
=
mReserved
)
;
MOZ_ASSERT
(
mReserved
<
=
mCapacity
)
;
Impl
:
:
new_
(
endNoCheck
(
)
Forward
<
U
>
(
aU
)
)
;
+
+
mLength
;
}
template
<
typename
T
size_t
N
class
AP
>
MOZ_ALWAYS_INLINE
bool
Vector
<
T
N
AP
>
:
:
appendN
(
const
T
&
aT
size_t
aNeeded
)
{
MOZ_REENTRANCY_GUARD_ET_AL
;
if
(
mLength
+
aNeeded
>
mCapacity
)
{
if
(
MOZ_UNLIKELY
(
!
growStorageBy
(
aNeeded
)
)
)
{
return
false
;
}
}
else
if
(
mLength
+
aNeeded
>
N
)
{
if
(
!
allocPolicy
(
)
.
checkSimulatedOOM
(
)
)
return
false
;
}
#
ifdef
DEBUG
if
(
mLength
+
aNeeded
>
mReserved
)
{
mReserved
=
mLength
+
aNeeded
;
}
#
endif
internalAppendN
(
aT
aNeeded
)
;
return
true
;
}
template
<
typename
T
size_t
N
class
AP
>
MOZ_ALWAYS_INLINE
void
Vector
<
T
N
AP
>
:
:
internalAppendN
(
const
T
&
aT
size_t
aNeeded
)
{
MOZ_ASSERT
(
mLength
+
aNeeded
<
=
mReserved
)
;
MOZ_ASSERT
(
mReserved
<
=
mCapacity
)
;
Impl
:
:
copyConstructN
(
endNoCheck
(
)
aNeeded
aT
)
;
mLength
+
=
aNeeded
;
}
template
<
typename
T
size_t
N
class
AP
>
template
<
typename
U
>
inline
T
*
Vector
<
T
N
AP
>
:
:
insert
(
T
*
aP
U
&
&
aVal
)
{
MOZ_ASSERT
(
begin
(
)
<
=
aP
)
;
MOZ_ASSERT
(
aP
<
=
end
(
)
)
;
size_t
pos
=
aP
-
begin
(
)
;
MOZ_ASSERT
(
pos
<
=
mLength
)
;
size_t
oldLength
=
mLength
;
if
(
pos
=
=
oldLength
)
{
if
(
!
append
(
Forward
<
U
>
(
aVal
)
)
)
{
return
nullptr
;
}
}
else
{
T
oldBack
=
Move
(
back
(
)
)
;
if
(
!
append
(
Move
(
oldBack
)
)
)
{
return
nullptr
;
}
for
(
size_t
i
=
oldLength
;
i
>
pos
;
-
-
i
)
{
(
*
this
)
[
i
]
=
Move
(
(
*
this
)
[
i
-
1
]
)
;
}
(
*
this
)
[
pos
]
=
Forward
<
U
>
(
aVal
)
;
}
return
begin
(
)
+
pos
;
}
template
<
typename
T
size_t
N
class
AP
>
inline
void
Vector
<
T
N
AP
>
:
:
erase
(
T
*
aIt
)
{
MOZ_ASSERT
(
begin
(
)
<
=
aIt
)
;
MOZ_ASSERT
(
aIt
<
end
(
)
)
;
while
(
aIt
+
1
<
end
(
)
)
{
*
aIt
=
Move
(
*
(
aIt
+
1
)
)
;
+
+
aIt
;
}
popBack
(
)
;
}
template
<
typename
T
size_t
N
class
AP
>
inline
void
Vector
<
T
N
AP
>
:
:
erase
(
T
*
aBegin
T
*
aEnd
)
{
MOZ_ASSERT
(
begin
(
)
<
=
aBegin
)
;
MOZ_ASSERT
(
aBegin
<
=
aEnd
)
;
MOZ_ASSERT
(
aEnd
<
=
end
(
)
)
;
while
(
aEnd
<
end
(
)
)
{
*
aBegin
+
+
=
Move
(
*
aEnd
+
+
)
;
}
shrinkBy
(
aEnd
-
aBegin
)
;
}
template
<
typename
T
size_t
N
class
AP
>
template
<
typename
U
>
MOZ_ALWAYS_INLINE
bool
Vector
<
T
N
AP
>
:
:
append
(
const
U
*
aInsBegin
const
U
*
aInsEnd
)
{
MOZ_REENTRANCY_GUARD_ET_AL
;
size_t
aNeeded
=
PointerRangeSize
(
aInsBegin
aInsEnd
)
;
if
(
mLength
+
aNeeded
>
mCapacity
)
{
if
(
MOZ_UNLIKELY
(
!
growStorageBy
(
aNeeded
)
)
)
{
return
false
;
}
}
else
if
(
mLength
+
aNeeded
>
N
)
{
if
(
!
allocPolicy
(
)
.
checkSimulatedOOM
(
)
)
return
false
;
}
#
ifdef
DEBUG
if
(
mLength
+
aNeeded
>
mReserved
)
{
mReserved
=
mLength
+
aNeeded
;
}
#
endif
internalAppend
(
aInsBegin
aNeeded
)
;
return
true
;
}
template
<
typename
T
size_t
N
class
AP
>
template
<
typename
U
>
MOZ_ALWAYS_INLINE
void
Vector
<
T
N
AP
>
:
:
internalAppend
(
const
U
*
aInsBegin
size_t
aInsLength
)
{
MOZ_ASSERT
(
mLength
+
aInsLength
<
=
mReserved
)
;
MOZ_ASSERT
(
mReserved
<
=
mCapacity
)
;
Impl
:
:
copyConstruct
(
endNoCheck
(
)
aInsBegin
aInsBegin
+
aInsLength
)
;
mLength
+
=
aInsLength
;
}
template
<
typename
T
size_t
N
class
AP
>
template
<
typename
U
>
MOZ_ALWAYS_INLINE
bool
Vector
<
T
N
AP
>
:
:
append
(
U
&
&
aU
)
{
MOZ_REENTRANCY_GUARD_ET_AL
;
if
(
mLength
=
=
mCapacity
)
{
if
(
MOZ_UNLIKELY
(
!
growStorageBy
(
1
)
)
)
{
return
false
;
}
}
else
if
(
mLength
+
1
>
N
)
{
if
(
!
allocPolicy
(
)
.
checkSimulatedOOM
(
)
)
return
false
;
}
#
ifdef
DEBUG
if
(
mLength
+
1
>
mReserved
)
{
mReserved
=
mLength
+
1
;
}
#
endif
internalAppend
(
Forward
<
U
>
(
aU
)
)
;
return
true
;
}
template
<
typename
T
size_t
N
class
AP
>
template
<
typename
U
size_t
O
class
BP
>
MOZ_ALWAYS_INLINE
bool
Vector
<
T
N
AP
>
:
:
appendAll
(
const
Vector
<
U
O
BP
>
&
aOther
)
{
return
append
(
aOther
.
begin
(
)
aOther
.
length
(
)
)
;
}
template
<
typename
T
size_t
N
class
AP
>
template
<
class
U
>
MOZ_ALWAYS_INLINE
bool
Vector
<
T
N
AP
>
:
:
append
(
const
U
*
aInsBegin
size_t
aInsLength
)
{
return
append
(
aInsBegin
aInsBegin
+
aInsLength
)
;
}
template
<
typename
T
size_t
N
class
AP
>
MOZ_ALWAYS_INLINE
void
Vector
<
T
N
AP
>
:
:
popBack
(
)
{
MOZ_REENTRANCY_GUARD_ET_AL
;
MOZ_ASSERT
(
!
empty
(
)
)
;
-
-
mLength
;
endNoCheck
(
)
-
>
~
T
(
)
;
}
template
<
typename
T
size_t
N
class
AP
>
MOZ_ALWAYS_INLINE
T
Vector
<
T
N
AP
>
:
:
popCopy
(
)
{
T
ret
=
back
(
)
;
popBack
(
)
;
return
ret
;
}
template
<
typename
T
size_t
N
class
AP
>
inline
T
*
Vector
<
T
N
AP
>
:
:
extractRawBuffer
(
)
{
T
*
ret
;
if
(
usingInlineStorage
(
)
)
{
ret
=
this
-
>
template
pod_malloc
<
T
>
(
mLength
)
;
if
(
!
ret
)
{
return
nullptr
;
}
Impl
:
:
copyConstruct
(
ret
beginNoCheck
(
)
endNoCheck
(
)
)
;
Impl
:
:
destroy
(
beginNoCheck
(
)
endNoCheck
(
)
)
;
mLength
=
0
;
}
else
{
ret
=
mBegin
;
mBegin
=
static_cast
<
T
*
>
(
mStorage
.
addr
(
)
)
;
mLength
=
0
;
mCapacity
=
kInlineCapacity
;
#
ifdef
DEBUG
mReserved
=
0
;
#
endif
}
return
ret
;
}
template
<
typename
T
size_t
N
class
AP
>
inline
void
Vector
<
T
N
AP
>
:
:
replaceRawBuffer
(
T
*
aP
size_t
aLength
)
{
MOZ_REENTRANCY_GUARD_ET_AL
;
Impl
:
:
destroy
(
beginNoCheck
(
)
endNoCheck
(
)
)
;
if
(
!
usingInlineStorage
(
)
)
{
this
-
>
free_
(
beginNoCheck
(
)
)
;
}
if
(
aLength
<
=
kInlineCapacity
)
{
mBegin
=
static_cast
<
T
*
>
(
mStorage
.
addr
(
)
)
;
mLength
=
aLength
;
mCapacity
=
kInlineCapacity
;
Impl
:
:
moveConstruct
(
mBegin
aP
aP
+
aLength
)
;
Impl
:
:
destroy
(
aP
aP
+
aLength
)
;
this
-
>
free_
(
aP
)
;
}
else
{
mBegin
=
aP
;
mLength
=
aLength
;
mCapacity
=
aLength
;
}
#
ifdef
DEBUG
mReserved
=
aLength
;
#
endif
}
template
<
typename
T
size_t
N
class
AP
>
inline
size_t
Vector
<
T
N
AP
>
:
:
sizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
usingInlineStorage
(
)
?
0
:
aMallocSizeOf
(
beginNoCheck
(
)
)
;
}
template
<
typename
T
size_t
N
class
AP
>
inline
size_t
Vector
<
T
N
AP
>
:
:
sizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
this
)
+
sizeOfExcludingThis
(
aMallocSizeOf
)
;
}
template
<
typename
T
size_t
N
class
AP
>
inline
void
Vector
<
T
N
AP
>
:
:
swap
(
Vector
&
aOther
)
{
static_assert
(
N
=
=
0
"
still
need
to
implement
this
for
N
!
=
0
"
)
;
if
(
!
usingInlineStorage
(
)
&
&
aOther
.
usingInlineStorage
(
)
)
{
aOther
.
mBegin
=
mBegin
;
mBegin
=
inlineStorage
(
)
;
}
else
if
(
usingInlineStorage
(
)
&
&
!
aOther
.
usingInlineStorage
(
)
)
{
mBegin
=
aOther
.
mBegin
;
aOther
.
mBegin
=
aOther
.
inlineStorage
(
)
;
}
else
if
(
!
usingInlineStorage
(
)
&
&
!
aOther
.
usingInlineStorage
(
)
)
{
Swap
(
mBegin
aOther
.
mBegin
)
;
}
else
{
}
Swap
(
mLength
aOther
.
mLength
)
;
Swap
(
mCapacity
aOther
.
mCapacity
)
;
#
ifdef
DEBUG
Swap
(
mReserved
aOther
.
mReserved
)
;
#
endif
}
}
#
ifdef
_MSC_VER
#
pragma
warning
(
pop
)
#
endif
#
endif
