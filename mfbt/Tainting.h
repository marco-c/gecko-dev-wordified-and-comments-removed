#
ifndef
mozilla_Tainting_h
#
define
mozilla_Tainting_h
#
include
<
utility
>
#
include
"
mozilla
/
MacroArgs
.
h
"
namespace
mozilla
{
template
<
typename
T
>
class
Tainted
;
namespace
ipc
{
template
<
typename
>
struct
IPDLParamTraits
;
}
template
<
typename
T
>
class
Tainted
{
private
:
T
mValue
;
public
:
explicit
Tainted
(
)
=
default
;
template
<
typename
U
>
explicit
Tainted
(
U
&
&
aValue
)
:
mValue
(
std
:
:
forward
<
U
>
(
aValue
)
)
{
}
T
&
Coerce
(
)
{
return
this
-
>
mValue
;
}
const
T
&
Coerce
(
)
const
{
return
this
-
>
mValue
;
}
friend
struct
mozilla
:
:
ipc
:
:
IPDLParamTraits
<
Tainted
<
T
>
>
;
}
;
#
define
MOZ_TAINT_GLUE
(
a
b
)
a
b
#
define
MOZ_VALIDATE_AND_GET_HELPER3
(
tainted_value
condition
\
assertionstring
)
\
[
&
]
(
)
{
\
auto
&
tmp
=
tainted_value
.
Coerce
(
)
;
\
auto
&
tainted_value
=
tmp
;
\
bool
test
=
(
condition
)
;
\
MOZ_RELEASE_ASSERT
(
test
assertionstring
)
;
\
return
tmp
;
\
}
(
)
#
define
MOZ_VALIDATE_AND_GET_HELPER2
(
tainted_value
condition
)
\
MOZ_VALIDATE_AND_GET_HELPER3
(
tainted_value
condition
\
"
MOZ_VALIDATE_AND_GET
(
"
#
tainted_value
\
"
"
#
condition
"
)
has
failed
"
)
#
define
MOZ_VALIDATE_AND_GET
(
.
.
.
)
\
MOZ_TAINT_GLUE
(
MOZ_PASTE_PREFIX_AND_ARG_COUNT
(
MOZ_VALIDATE_AND_GET_HELPER
\
__VA_ARGS__
)
\
(
__VA_ARGS__
)
)
#
define
MOZ_IS_VALID
(
tainted_value
condition
)
\
[
&
]
(
)
{
\
auto
&
tmp
=
tainted_value
.
Coerce
(
)
;
\
auto
&
tainted_value
=
tmp
;
\
return
(
condition
)
;
\
}
(
)
#
define
MOZ_VALIDATE_OR
(
tainted_value
condition
alternate_value
)
\
(
MOZ_IS_VALID
(
tainted_value
condition
)
?
tainted_value
.
Coerce
(
)
\
:
alternate_value
)
#
define
MOZ_NO_VALIDATE
(
tainted_value
justification
)
\
[
&
tainted_value
]
{
\
static_assert
(
sizeof
(
justification
)
>
3
\
"
Must
provide
a
justification
string
.
"
)
;
\
return
tainted_value
.
Coerce
(
)
;
\
}
(
)
}
#
endif
