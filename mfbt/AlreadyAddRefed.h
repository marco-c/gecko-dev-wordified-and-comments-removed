#
ifndef
AlreadyAddRefed_h
#
define
AlreadyAddRefed_h
#
include
<
utility
>
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
namespace
mozilla
{
struct
unused_t
;
}
template
<
class
T
>
struct
#
if
!
defined
(
MOZ_CLANG_PLUGIN
)
&
&
!
defined
(
XGILL_PLUGIN
)
[
[
nodiscard
]
]
#
endif
MOZ_NON_AUTOABLE
already_AddRefed
{
already_AddRefed
(
)
:
mRawPtr
(
nullptr
)
{
}
MOZ_IMPLICIT
already_AddRefed
(
decltype
(
nullptr
)
)
:
mRawPtr
(
nullptr
)
{
}
explicit
already_AddRefed
(
T
*
aRawPtr
)
:
mRawPtr
(
aRawPtr
)
{
}
already_AddRefed
(
const
already_AddRefed
<
T
>
&
aOther
)
=
delete
;
already_AddRefed
<
T
>
&
operator
=
(
const
already_AddRefed
<
T
>
&
aOther
)
=
delete
;
already_AddRefed
(
already_AddRefed
<
T
>
&
&
aOther
)
#
ifdef
DEBUG
:
mRawPtr
(
aOther
.
take
(
)
)
{
}
#
else
=
default
;
#
endif
already_AddRefed
<
T
>
&
operator
=
(
already_AddRefed
<
T
>
&
&
aOther
)
{
mRawPtr
=
aOther
.
take
(
)
;
return
*
this
;
}
template
<
typename
U
>
MOZ_IMPLICIT
already_AddRefed
(
already_AddRefed
<
U
>
&
&
aOther
)
:
mRawPtr
(
aOther
.
take
(
)
)
{
}
~
already_AddRefed
(
)
#
ifdef
DEBUG
{
MOZ_ASSERT
(
!
mRawPtr
)
;
}
#
else
=
default
;
#
endif
friend
void
operator
<
<
(
const
mozilla
:
:
unused_t
&
aUnused
const
already_AddRefed
<
T
>
&
aRhs
)
{
auto
mutableAlreadyAddRefed
=
const_cast
<
already_AddRefed
<
T
>
*
>
(
&
aRhs
)
;
aUnused
<
<
mutableAlreadyAddRefed
-
>
take
(
)
;
}
[
[
nodiscard
]
]
T
*
take
(
)
{
T
*
rawPtr
=
mRawPtr
;
mRawPtr
=
nullptr
;
return
rawPtr
;
}
template
<
class
U
>
already_AddRefed
<
U
>
downcast
(
)
{
U
*
tmp
=
static_cast
<
U
*
>
(
mRawPtr
)
;
mRawPtr
=
nullptr
;
return
already_AddRefed
<
U
>
(
tmp
)
;
}
private
:
T
*
MOZ_OWNING_REF
mRawPtr
;
}
;
#
endif
