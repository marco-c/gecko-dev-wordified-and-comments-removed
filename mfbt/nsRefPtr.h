#
ifndef
mozilla_nsRefPtr_h
#
define
mozilla_nsRefPtr_h
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
class
nsCOMPtr_helper
;
namespace
mozilla
{
template
<
class
T
>
class
OwningNonNull
;
}
template
<
class
T
>
class
nsRefPtr
{
private
:
void
assign_with_AddRef
(
T
*
aRawPtr
)
{
if
(
aRawPtr
)
{
AddRefTraits
<
T
>
:
:
AddRef
(
aRawPtr
)
;
}
assign_assuming_AddRef
(
aRawPtr
)
;
}
void
assign_assuming_AddRef
(
T
*
aNewPtr
)
{
T
*
oldPtr
=
mRawPtr
;
mRawPtr
=
aNewPtr
;
if
(
oldPtr
)
{
AddRefTraits
<
T
>
:
:
Release
(
oldPtr
)
;
}
}
private
:
T
*
MOZ_OWNING_REF
mRawPtr
;
public
:
typedef
T
element_type
;
~
nsRefPtr
(
)
{
if
(
mRawPtr
)
{
AddRefTraits
<
T
>
:
:
Release
(
mRawPtr
)
;
}
}
nsRefPtr
(
)
:
mRawPtr
(
0
)
{
}
nsRefPtr
(
const
nsRefPtr
<
T
>
&
aSmartPtr
)
:
mRawPtr
(
aSmartPtr
.
mRawPtr
)
{
if
(
mRawPtr
)
{
AddRefTraits
<
T
>
:
:
AddRef
(
mRawPtr
)
;
}
}
nsRefPtr
(
nsRefPtr
<
T
>
&
&
aRefPtr
)
:
mRawPtr
(
aRefPtr
.
mRawPtr
)
{
aRefPtr
.
mRawPtr
=
nullptr
;
}
MOZ_IMPLICIT
nsRefPtr
(
T
*
aRawPtr
)
:
mRawPtr
(
aRawPtr
)
{
if
(
mRawPtr
)
{
AddRefTraits
<
T
>
:
:
AddRef
(
mRawPtr
)
;
}
}
template
<
typename
I
>
MOZ_IMPLICIT
nsRefPtr
(
already_AddRefed
<
I
>
&
aSmartPtr
)
:
mRawPtr
(
aSmartPtr
.
take
(
)
)
{
}
template
<
typename
I
>
MOZ_IMPLICIT
nsRefPtr
(
already_AddRefed
<
I
>
&
&
aSmartPtr
)
:
mRawPtr
(
aSmartPtr
.
take
(
)
)
{
}
template
<
typename
I
>
MOZ_IMPLICIT
nsRefPtr
(
const
nsRefPtr
<
I
>
&
aSmartPtr
)
:
mRawPtr
(
aSmartPtr
.
get
(
)
)
{
if
(
mRawPtr
)
{
AddRefTraits
<
T
>
:
:
AddRef
(
mRawPtr
)
;
}
}
template
<
typename
I
>
MOZ_IMPLICIT
nsRefPtr
(
nsRefPtr
<
I
>
&
&
aSmartPtr
)
:
mRawPtr
(
aSmartPtr
.
forget
(
)
.
take
(
)
)
{
}
MOZ_IMPLICIT
nsRefPtr
(
const
nsCOMPtr_helper
&
aHelper
)
;
template
<
class
U
>
MOZ_IMPLICIT
nsRefPtr
(
const
mozilla
:
:
OwningNonNull
<
U
>
&
aOther
)
;
nsRefPtr
<
T
>
&
operator
=
(
const
nsRefPtr
<
T
>
&
aRhs
)
{
assign_with_AddRef
(
aRhs
.
mRawPtr
)
;
return
*
this
;
}
template
<
typename
I
>
nsRefPtr
<
T
>
&
operator
=
(
const
nsRefPtr
<
I
>
&
aRhs
)
{
assign_with_AddRef
(
aRhs
.
get
(
)
)
;
return
*
this
;
}
nsRefPtr
<
T
>
&
operator
=
(
T
*
aRhs
)
{
assign_with_AddRef
(
aRhs
)
;
return
*
this
;
}
template
<
typename
I
>
nsRefPtr
<
T
>
&
operator
=
(
already_AddRefed
<
I
>
&
aRhs
)
{
assign_assuming_AddRef
(
aRhs
.
take
(
)
)
;
return
*
this
;
}
template
<
typename
I
>
nsRefPtr
<
T
>
&
operator
=
(
already_AddRefed
<
I
>
&
&
aRhs
)
{
assign_assuming_AddRef
(
aRhs
.
take
(
)
)
;
return
*
this
;
}
nsRefPtr
<
T
>
&
operator
=
(
const
nsCOMPtr_helper
&
aHelper
)
;
nsRefPtr
<
T
>
&
operator
=
(
nsRefPtr
<
T
>
&
&
aRefPtr
)
{
assign_assuming_AddRef
(
aRefPtr
.
mRawPtr
)
;
aRefPtr
.
mRawPtr
=
nullptr
;
return
*
this
;
}
template
<
class
U
>
nsRefPtr
<
T
>
&
operator
=
(
const
mozilla
:
:
OwningNonNull
<
U
>
&
aOther
)
;
void
swap
(
nsRefPtr
<
T
>
&
aRhs
)
{
T
*
temp
=
aRhs
.
mRawPtr
;
aRhs
.
mRawPtr
=
mRawPtr
;
mRawPtr
=
temp
;
}
void
swap
(
T
*
&
aRhs
)
{
T
*
temp
=
aRhs
;
aRhs
=
mRawPtr
;
mRawPtr
=
temp
;
}
already_AddRefed
<
T
>
forget
(
)
{
T
*
temp
=
0
;
swap
(
temp
)
;
return
already_AddRefed
<
T
>
(
temp
)
;
}
template
<
typename
I
>
void
forget
(
I
*
*
aRhs
)
{
MOZ_ASSERT
(
aRhs
"
Null
pointer
passed
to
forget
!
"
)
;
*
aRhs
=
mRawPtr
;
mRawPtr
=
0
;
}
T
*
get
(
)
const
{
return
const_cast
<
T
*
>
(
mRawPtr
)
;
}
operator
T
*
(
)
const
#
ifdef
MOZ_HAVE_REF_QUALIFIERS
&
#
endif
{
return
get
(
)
;
}
#
ifdef
MOZ_HAVE_REF_QUALIFIERS
operator
T
*
(
)
const
&
&
=
delete
;
explicit
operator
bool
(
)
const
{
return
!
!
mRawPtr
;
}
bool
operator
!
(
)
const
{
return
!
mRawPtr
;
}
#
endif
T
*
operator
-
>
(
)
const
MOZ_NO_ADDREF_RELEASE_ON_RETURN
{
MOZ_ASSERT
(
mRawPtr
!
=
0
"
You
can
'
t
dereference
a
NULL
nsRefPtr
with
operator
-
>
(
)
.
"
)
;
return
get
(
)
;
}
template
<
typename
R
typename
.
.
.
Args
>
class
Proxy
{
typedef
R
(
T
:
:
*
member_function
)
(
Args
.
.
.
)
;
T
*
mRawPtr
;
member_function
mFunction
;
public
:
Proxy
(
T
*
aRawPtr
member_function
aFunction
)
:
mRawPtr
(
aRawPtr
)
mFunction
(
aFunction
)
{
}
template
<
typename
.
.
.
ActualArgs
>
R
operator
(
)
(
ActualArgs
&
&
.
.
.
aArgs
)
{
return
(
(
*
mRawPtr
)
.
*
mFunction
)
(
mozilla
:
:
Forward
<
ActualArgs
>
(
aArgs
)
.
.
.
)
;
}
}
;
template
<
typename
R
typename
.
.
.
Args
>
Proxy
<
R
Args
.
.
.
>
operator
-
>
*
(
R
(
T
:
:
*
aFptr
)
(
Args
.
.
.
)
)
const
{
MOZ_ASSERT
(
mRawPtr
!
=
0
"
You
can
'
t
dereference
a
NULL
nsRefPtr
with
operator
-
>
*
(
)
.
"
)
;
return
Proxy
<
R
Args
.
.
.
>
(
get
(
)
aFptr
)
;
}
nsRefPtr
<
T
>
*
get_address
(
)
{
return
this
;
}
const
nsRefPtr
<
T
>
*
get_address
(
)
const
{
return
this
;
}
public
:
T
&
operator
*
(
)
const
{
MOZ_ASSERT
(
mRawPtr
!
=
0
"
You
can
'
t
dereference
a
NULL
nsRefPtr
with
operator
*
(
)
.
"
)
;
return
*
get
(
)
;
}
T
*
*
StartAssignment
(
)
{
assign_assuming_AddRef
(
0
)
;
return
reinterpret_cast
<
T
*
*
>
(
&
mRawPtr
)
;
}
private
:
template
<
class
U
>
struct
AddRefTraits
{
static
void
AddRef
(
U
*
aPtr
)
{
aPtr
-
>
AddRef
(
)
;
}
static
void
Release
(
U
*
aPtr
)
{
aPtr
-
>
Release
(
)
;
}
}
;
template
<
class
U
>
struct
AddRefTraits
<
const
U
>
{
static
void
AddRef
(
const
U
*
aPtr
)
{
const_cast
<
U
*
>
(
aPtr
)
-
>
AddRef
(
)
;
}
static
void
Release
(
const
U
*
aPtr
)
{
const_cast
<
U
*
>
(
aPtr
)
-
>
Release
(
)
;
}
}
;
}
;
class
nsCycleCollectionTraversalCallback
;
template
<
typename
T
>
void
CycleCollectionNoteChild
(
nsCycleCollectionTraversalCallback
&
aCallback
T
*
aChild
const
char
*
aName
uint32_t
aFlags
)
;
template
<
typename
T
>
inline
void
ImplCycleCollectionUnlink
(
nsRefPtr
<
T
>
&
aField
)
{
aField
=
nullptr
;
}
template
<
typename
T
>
inline
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
aCallback
nsRefPtr
<
T
>
&
aField
const
char
*
aName
uint32_t
aFlags
=
0
)
{
CycleCollectionNoteChild
(
aCallback
aField
.
get
(
)
aName
aFlags
)
;
}
template
<
class
T
>
inline
nsRefPtr
<
T
>
*
address_of
(
nsRefPtr
<
T
>
&
aPtr
)
{
return
aPtr
.
get_address
(
)
;
}
template
<
class
T
>
inline
const
nsRefPtr
<
T
>
*
address_of
(
const
nsRefPtr
<
T
>
&
aPtr
)
{
return
aPtr
.
get_address
(
)
;
}
template
<
class
T
>
class
nsRefPtrGetterAddRefs
{
public
:
explicit
nsRefPtrGetterAddRefs
(
nsRefPtr
<
T
>
&
aSmartPtr
)
:
mTargetSmartPtr
(
aSmartPtr
)
{
}
operator
void
*
*
(
)
{
return
reinterpret_cast
<
void
*
*
>
(
mTargetSmartPtr
.
StartAssignment
(
)
)
;
}
operator
T
*
*
(
)
{
return
mTargetSmartPtr
.
StartAssignment
(
)
;
}
T
*
&
operator
*
(
)
{
return
*
(
mTargetSmartPtr
.
StartAssignment
(
)
)
;
}
private
:
nsRefPtr
<
T
>
&
mTargetSmartPtr
;
}
;
template
<
class
T
>
inline
nsRefPtrGetterAddRefs
<
T
>
getter_AddRefs
(
nsRefPtr
<
T
>
&
aSmartPtr
)
{
return
nsRefPtrGetterAddRefs
<
T
>
(
aSmartPtr
)
;
}
template
<
class
T
class
U
>
inline
bool
operator
=
=
(
const
nsRefPtr
<
T
>
&
aLhs
const
nsRefPtr
<
U
>
&
aRhs
)
{
return
static_cast
<
const
T
*
>
(
aLhs
.
get
(
)
)
=
=
static_cast
<
const
U
*
>
(
aRhs
.
get
(
)
)
;
}
template
<
class
T
class
U
>
inline
bool
operator
!
=
(
const
nsRefPtr
<
T
>
&
aLhs
const
nsRefPtr
<
U
>
&
aRhs
)
{
return
static_cast
<
const
T
*
>
(
aLhs
.
get
(
)
)
!
=
static_cast
<
const
U
*
>
(
aRhs
.
get
(
)
)
;
}
template
<
class
T
class
U
>
inline
bool
operator
=
=
(
const
nsRefPtr
<
T
>
&
aLhs
const
U
*
aRhs
)
{
return
static_cast
<
const
T
*
>
(
aLhs
.
get
(
)
)
=
=
static_cast
<
const
U
*
>
(
aRhs
)
;
}
template
<
class
T
class
U
>
inline
bool
operator
=
=
(
const
U
*
aLhs
const
nsRefPtr
<
T
>
&
aRhs
)
{
return
static_cast
<
const
U
*
>
(
aLhs
)
=
=
static_cast
<
const
T
*
>
(
aRhs
.
get
(
)
)
;
}
template
<
class
T
class
U
>
inline
bool
operator
!
=
(
const
nsRefPtr
<
T
>
&
aLhs
const
U
*
aRhs
)
{
return
static_cast
<
const
T
*
>
(
aLhs
.
get
(
)
)
!
=
static_cast
<
const
U
*
>
(
aRhs
)
;
}
template
<
class
T
class
U
>
inline
bool
operator
!
=
(
const
U
*
aLhs
const
nsRefPtr
<
T
>
&
aRhs
)
{
return
static_cast
<
const
U
*
>
(
aLhs
)
!
=
static_cast
<
const
T
*
>
(
aRhs
.
get
(
)
)
;
}
template
<
class
T
class
U
>
inline
bool
operator
=
=
(
const
nsRefPtr
<
T
>
&
aLhs
U
*
aRhs
)
{
return
static_cast
<
const
T
*
>
(
aLhs
.
get
(
)
)
=
=
const_cast
<
const
U
*
>
(
aRhs
)
;
}
template
<
class
T
class
U
>
inline
bool
operator
=
=
(
U
*
aLhs
const
nsRefPtr
<
T
>
&
aRhs
)
{
return
const_cast
<
const
U
*
>
(
aLhs
)
=
=
static_cast
<
const
T
*
>
(
aRhs
.
get
(
)
)
;
}
template
<
class
T
class
U
>
inline
bool
operator
!
=
(
const
nsRefPtr
<
T
>
&
aLhs
U
*
aRhs
)
{
return
static_cast
<
const
T
*
>
(
aLhs
.
get
(
)
)
!
=
const_cast
<
const
U
*
>
(
aRhs
)
;
}
template
<
class
T
class
U
>
inline
bool
operator
!
=
(
U
*
aLhs
const
nsRefPtr
<
T
>
&
aRhs
)
{
return
const_cast
<
const
U
*
>
(
aLhs
)
!
=
static_cast
<
const
T
*
>
(
aRhs
.
get
(
)
)
;
}
template
<
class
T
>
inline
bool
operator
=
=
(
const
nsRefPtr
<
T
>
&
aLhs
decltype
(
nullptr
)
)
{
return
aLhs
.
get
(
)
=
=
nullptr
;
}
template
<
class
T
>
inline
bool
operator
=
=
(
decltype
(
nullptr
)
const
nsRefPtr
<
T
>
&
aRhs
)
{
return
nullptr
=
=
aRhs
.
get
(
)
;
}
template
<
class
T
>
inline
bool
operator
!
=
(
const
nsRefPtr
<
T
>
&
aLhs
decltype
(
nullptr
)
)
{
return
aLhs
.
get
(
)
!
=
nullptr
;
}
template
<
class
T
>
inline
bool
operator
!
=
(
decltype
(
nullptr
)
const
nsRefPtr
<
T
>
&
aRhs
)
{
return
nullptr
!
=
aRhs
.
get
(
)
;
}
template
<
class
T
>
inline
already_AddRefed
<
T
>
do_AddRef
(
T
*
&
&
aObj
)
{
nsRefPtr
<
T
>
ref
(
aObj
)
;
return
ref
.
forget
(
)
;
}
namespace
mozilla
{
template
<
typename
T
typename
.
.
.
Args
>
already_AddRefed
<
T
>
MakeAndAddRef
(
Args
&
&
.
.
.
aArgs
)
{
nsRefPtr
<
T
>
p
(
new
T
(
Forward
<
Args
>
(
aArgs
)
.
.
.
)
)
;
return
p
.
forget
(
)
;
}
}
#
endif
