#
ifndef
mozilla_mozalloc_h
#
define
mozilla_mozalloc_h
#
if
defined
(
__cplusplus
)
#
include
<
new
>
#
include
<
cstdlib
>
#
else
#
include
<
stdlib
.
h
>
#
endif
#
if
defined
(
__cplusplus
)
#
include
"
mozilla
/
fallible
.
h
"
#
include
"
mozilla
/
mozalloc_abort
.
h
"
#
include
"
mozilla
/
TemplateLib
.
h
"
#
endif
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Types
.
h
"
MOZ_BEGIN_EXTERN_C
#
ifndef
free_impl
#
define
free_impl
free
#
define
free_impl_
#
endif
#
ifndef
malloc_impl
#
define
malloc_impl
malloc
#
define
malloc_impl_
#
endif
MFBT_API
void
*
moz_xmalloc
(
size_t
size
)
MOZ_ALLOCATOR
;
MFBT_API
void
*
moz_xcalloc
(
size_t
nmemb
size_t
size
)
MOZ_ALLOCATOR
;
MFBT_API
void
*
moz_xrealloc
(
void
*
ptr
size_t
size
)
MOZ_ALLOCATOR
;
MFBT_API
char
*
moz_xstrdup
(
const
char
*
str
)
MOZ_ALLOCATOR
;
MFBT_API
size_t
moz_malloc_usable_size
(
void
*
ptr
)
;
MFBT_API
size_t
moz_malloc_size_of
(
const
void
*
ptr
)
;
MFBT_API
size_t
moz_malloc_enclosing_size_of
(
const
void
*
ptr
)
;
#
if
defined
(
HAVE_STRNDUP
)
MFBT_API
char
*
moz_xstrndup
(
const
char
*
str
size_t
strsize
)
MOZ_ALLOCATOR
;
#
endif
MFBT_API
void
*
moz_xmemalign
(
size_t
boundary
size_t
size
)
MOZ_ALLOCATOR
;
MOZ_END_EXTERN_C
#
ifdef
__cplusplus
#
if
defined
(
XP_MACOSX
)
#
define
MOZALLOC_EXPORT_NEW
MFBT_API
#
else
#
define
MOZALLOC_EXPORT_NEW
#
endif
MOZALLOC_EXPORT_NEW
#
if
defined
(
__GNUC__
)
&
&
!
defined
(
__clang__
)
&
&
defined
(
__SANITIZE_ADDRESS__
)
__attribute__
(
(
gnu_inline
)
)
inline
#
else
MOZ_ALWAYS_INLINE_EVEN_DEBUG
#
endif
void
*
operator
new
(
size_t
size
)
noexcept
(
false
)
{
return
moz_xmalloc
(
size
)
;
}
MOZALLOC_EXPORT_NEW
MOZ_ALWAYS_INLINE_EVEN_DEBUG
void
*
operator
new
(
size_t
size
const
std
:
:
nothrow_t
&
)
noexcept
(
true
)
{
return
malloc_impl
(
size
)
;
}
MOZALLOC_EXPORT_NEW
MOZ_ALWAYS_INLINE_EVEN_DEBUG
void
*
operator
new
[
]
(
size_t
size
)
noexcept
(
false
)
{
return
moz_xmalloc
(
size
)
;
}
MOZALLOC_EXPORT_NEW
MOZ_ALWAYS_INLINE_EVEN_DEBUG
void
*
operator
new
[
]
(
size_t
size
const
std
:
:
nothrow_t
&
)
noexcept
(
true
)
{
return
malloc_impl
(
size
)
;
}
MOZALLOC_EXPORT_NEW
MOZ_ALWAYS_INLINE_EVEN_DEBUG
void
operator
delete
(
void
*
ptr
)
noexcept
(
true
)
{
return
free_impl
(
ptr
)
;
}
MOZALLOC_EXPORT_NEW
MOZ_ALWAYS_INLINE_EVEN_DEBUG
void
operator
delete
(
void
*
ptr
const
std
:
:
nothrow_t
&
)
noexcept
(
true
)
{
return
free_impl
(
ptr
)
;
}
MOZALLOC_EXPORT_NEW
MOZ_ALWAYS_INLINE_EVEN_DEBUG
void
operator
delete
[
]
(
void
*
ptr
)
noexcept
(
true
)
{
return
free_impl
(
ptr
)
;
}
MOZALLOC_EXPORT_NEW
MOZ_ALWAYS_INLINE_EVEN_DEBUG
void
operator
delete
[
]
(
void
*
ptr
const
std
:
:
nothrow_t
&
)
noexcept
(
true
)
{
return
free_impl
(
ptr
)
;
}
#
if
defined
(
XP_WIN
)
MOZALLOC_EXPORT_NEW
MOZ_ALWAYS_INLINE_EVEN_DEBUG
void
operator
delete
(
void
*
ptr
size_t
)
noexcept
(
true
)
{
return
free_impl
(
ptr
)
;
}
MOZALLOC_EXPORT_NEW
MOZ_ALWAYS_INLINE_EVEN_DEBUG
void
operator
delete
[
]
(
void
*
ptr
size_t
)
noexcept
(
true
)
{
return
free_impl
(
ptr
)
;
}
#
endif
class
InfallibleAllocPolicy
{
public
:
template
<
typename
T
>
T
*
maybe_pod_malloc
(
size_t
aNumElems
)
{
return
pod_malloc
<
T
>
(
aNumElems
)
;
}
template
<
typename
T
>
T
*
maybe_pod_calloc
(
size_t
aNumElems
)
{
return
pod_calloc
<
T
>
(
aNumElems
)
;
}
template
<
typename
T
>
T
*
maybe_pod_realloc
(
T
*
aPtr
size_t
aOldSize
size_t
aNewSize
)
{
return
pod_realloc
<
T
>
(
aPtr
aOldSize
aNewSize
)
;
}
template
<
typename
T
>
T
*
pod_malloc
(
size_t
aNumElems
)
{
if
(
aNumElems
&
mozilla
:
:
tl
:
:
MulOverflowMask
<
sizeof
(
T
)
>
:
:
value
)
{
reportAllocOverflow
(
)
;
}
return
static_cast
<
T
*
>
(
moz_xmalloc
(
aNumElems
*
sizeof
(
T
)
)
)
;
}
template
<
typename
T
>
T
*
pod_calloc
(
size_t
aNumElems
)
{
return
static_cast
<
T
*
>
(
moz_xcalloc
(
aNumElems
sizeof
(
T
)
)
)
;
}
template
<
typename
T
>
T
*
pod_realloc
(
T
*
aPtr
size_t
aOldSize
size_t
aNewSize
)
{
if
(
aNewSize
&
mozilla
:
:
tl
:
:
MulOverflowMask
<
sizeof
(
T
)
>
:
:
value
)
{
reportAllocOverflow
(
)
;
}
return
static_cast
<
T
*
>
(
moz_xrealloc
(
aPtr
aNewSize
*
sizeof
(
T
)
)
)
;
}
template
<
typename
T
>
void
free_
(
T
*
aPtr
size_t
aNumElems
=
0
)
{
free_impl
(
aPtr
)
;
}
void
reportAllocOverflow
(
)
const
{
mozalloc_abort
(
"
alloc
overflow
"
)
;
}
bool
checkSimulatedOOM
(
)
const
{
return
true
;
}
}
;
#
endif
#
ifdef
malloc_impl_
#
undef
malloc_impl_
#
undef
malloc_impl
#
endif
#
ifdef
free_impl_
#
undef
free_impl_
#
undef
free_impl
#
endif
#
endif
