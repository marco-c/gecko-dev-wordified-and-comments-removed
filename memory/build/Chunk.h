#
ifndef
CHUNK_H
#
define
CHUNK_H
#
include
"
rb
.
h
"
#
ifdef
XP_DARWIN
#
define
MALLOC_DOUBLE_PURGE
#
endif
#
ifdef
XP_WIN
#
define
MALLOC_DECOMMIT
#
endif
#
include
"
mozilla
/
DoublyLinkedList
.
h
"
struct
arena_t
;
enum
ChunkType
{
UNKNOWN_CHUNK
ZEROED_CHUNK
ARENA_CHUNK
HUGE_CHUNK
RECYCLED_CHUNK
}
;
struct
arena_chunk_map_t
{
RedBlackTreeNode
<
arena_chunk_map_t
>
link
;
size_t
bits
;
#
define
CHUNK_MAP_BUSY
(
(
size_t
)
0x100U
)
#
define
CHUNK_MAP_FRESH
(
(
size_t
)
0x80U
)
#
define
CHUNK_MAP_MADVISED
(
(
size_t
)
0x40U
)
#
define
CHUNK_MAP_DECOMMITTED
(
(
size_t
)
0x20U
)
#
define
CHUNK_MAP_MADVISED_OR_DECOMMITTED
\
(
CHUNK_MAP_MADVISED
|
CHUNK_MAP_DECOMMITTED
)
#
define
CHUNK_MAP_FRESH_MADVISED_OR_DECOMMITTED
\
(
CHUNK_MAP_FRESH
|
CHUNK_MAP_MADVISED
|
CHUNK_MAP_DECOMMITTED
)
#
define
CHUNK_MAP_FRESH_MADVISED_DECOMMITTED_OR_BUSY
\
(
CHUNK_MAP_FRESH
|
CHUNK_MAP_MADVISED
|
CHUNK_MAP_DECOMMITTED
|
\
CHUNK_MAP_BUSY
)
#
define
CHUNK_MAP_KEY
(
(
size_t
)
0x10U
)
#
define
CHUNK_MAP_DIRTY
(
(
size_t
)
0x08U
)
#
define
CHUNK_MAP_ZEROED
(
(
size_t
)
0x04U
)
#
define
CHUNK_MAP_LARGE
(
(
size_t
)
0x02U
)
#
define
CHUNK_MAP_ALLOCATED
(
(
size_t
)
0x01U
)
}
;
struct
arena_chunk_t
{
arena_t
*
arena
;
RedBlackTreeNode
<
arena_chunk_t
>
link_dirty
;
#
ifdef
MALLOC_DOUBLE_PURGE
mozilla
:
:
DoublyLinkedListElement
<
arena_chunk_t
>
chunks_madvised_elem
;
#
endif
size_t
ndirty
;
bool
mIsPurging
;
bool
mDying
;
arena_chunk_map_t
map
[
]
;
bool
IsEmpty
(
)
;
}
;
#
endif
