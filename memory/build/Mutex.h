#
ifndef
Mutex_h
#
define
Mutex_h
#
if
defined
(
XP_WIN
)
#
include
<
windows
.
h
>
#
elif
defined
(
XP_DARWIN
)
#
include
"
mozilla
/
Assertions
.
h
"
#
include
<
os
/
lock
.
h
>
#
else
#
include
<
pthread
.
h
>
#
endif
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
ThreadSafety
.
h
"
#
if
defined
(
XP_DARWIN
)
#
define
OS_UNFAIR_LOCK_DATA_SYNCHRONIZATION
(
0x00010000
)
#
define
OS_UNFAIR_LOCK_ADAPTIVE_SPIN
(
0x00040000
)
extern
"
C
"
{
typedef
uint32_t
os_unfair_lock_options_t
;
OS_UNFAIR_LOCK_AVAILABILITY
OS_EXPORT
OS_NOTHROW
OS_NONNULL_ALL
void
os_unfair_lock_lock_with_options
(
os_unfair_lock_t
lock
os_unfair_lock_options_t
options
)
;
}
#
endif
struct
MOZ_CAPABILITY
Mutex
{
#
if
defined
(
XP_WIN
)
CRITICAL_SECTION
mMutex
;
#
elif
defined
(
XP_DARWIN
)
os_unfair_lock
mMutex
;
#
else
pthread_mutex_t
mMutex
;
#
endif
inline
bool
Init
(
)
{
#
if
defined
(
XP_WIN
)
if
(
!
InitializeCriticalSectionAndSpinCount
(
&
mMutex
5000
)
)
{
return
false
;
}
#
elif
defined
(
XP_DARWIN
)
mMutex
=
OS_UNFAIR_LOCK_INIT
;
#
elif
defined
(
XP_LINUX
)
&
&
!
defined
(
ANDROID
)
pthread_mutexattr_t
attr
;
if
(
pthread_mutexattr_init
(
&
attr
)
!
=
0
)
{
return
false
;
}
pthread_mutexattr_settype
(
&
attr
PTHREAD_MUTEX_ADAPTIVE_NP
)
;
if
(
pthread_mutex_init
(
&
mMutex
&
attr
)
!
=
0
)
{
pthread_mutexattr_destroy
(
&
attr
)
;
return
false
;
}
pthread_mutexattr_destroy
(
&
attr
)
;
#
else
if
(
pthread_mutex_init
(
&
mMutex
nullptr
)
!
=
0
)
{
return
false
;
}
#
endif
return
true
;
}
inline
void
Lock
(
)
MOZ_CAPABILITY_ACQUIRE
(
)
{
#
if
defined
(
XP_WIN
)
EnterCriticalSection
(
&
mMutex
)
;
#
elif
defined
(
XP_DARWIN
)
if
(
Mutex
:
:
gSpinInKernelSpace
)
{
os_unfair_lock_lock_with_options
(
&
mMutex
OS_UNFAIR_LOCK_DATA_SYNCHRONIZATION
|
OS_UNFAIR_LOCK_ADAPTIVE_SPIN
)
;
}
else
{
#
if
defined
(
__x86_64__
)
uint32_t
retries
=
100
;
do
{
if
(
os_unfair_lock_trylock
(
&
mMutex
)
)
{
return
;
}
__asm__
__volatile__
(
"
pause
"
)
;
}
while
(
retries
-
-
)
;
os_unfair_lock_lock_with_options
(
&
mMutex
OS_UNFAIR_LOCK_DATA_SYNCHRONIZATION
)
;
#
else
MOZ_CRASH
(
"
User
-
space
spin
-
locks
should
never
be
used
on
ARM
"
)
;
#
endif
}
#
else
pthread_mutex_lock
(
&
mMutex
)
;
#
endif
}
inline
void
Unlock
(
)
MOZ_CAPABILITY_RELEASE
(
)
{
#
if
defined
(
XP_WIN
)
LeaveCriticalSection
(
&
mMutex
)
;
#
elif
defined
(
XP_DARWIN
)
os_unfair_lock_unlock
(
&
mMutex
)
;
#
else
pthread_mutex_unlock
(
&
mMutex
)
;
#
endif
}
#
if
defined
(
XP_DARWIN
)
static
bool
SpinInKernelSpace
(
)
;
static
bool
gSpinInKernelSpace
;
#
endif
}
;
#
if
defined
(
XP_WIN
)
struct
MOZ_CAPABILITY
StaticMutex
{
SRWLOCK
mMutex
;
inline
void
Lock
(
)
MOZ_CAPABILITY_ACQUIRE
(
)
{
AcquireSRWLockExclusive
(
&
mMutex
)
;
}
inline
void
Unlock
(
)
MOZ_CAPABILITY_RELEASE
(
)
{
ReleaseSRWLockExclusive
(
&
mMutex
)
;
}
}
;
#
define
STATIC_MUTEX_INIT
SRWLOCK_INIT
#
else
typedef
Mutex
StaticMutex
;
#
if
defined
(
XP_DARWIN
)
#
define
STATIC_MUTEX_INIT
OS_UNFAIR_LOCK_INIT
#
elif
defined
(
XP_LINUX
)
&
&
!
defined
(
ANDROID
)
#
define
STATIC_MUTEX_INIT
PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP
#
else
#
define
STATIC_MUTEX_INIT
PTHREAD_MUTEX_INITIALIZER
#
endif
#
endif
template
<
typename
T
>
struct
MOZ_SCOPED_CAPABILITY
MOZ_RAII
AutoLock
{
explicit
AutoLock
(
T
&
aMutex
)
MOZ_CAPABILITY_ACQUIRE
(
aMutex
)
:
mMutex
(
aMutex
)
{
mMutex
.
Lock
(
)
;
}
~
AutoLock
(
)
MOZ_CAPABILITY_RELEASE
(
)
{
mMutex
.
Unlock
(
)
;
}
AutoLock
(
const
AutoLock
&
)
=
delete
;
AutoLock
(
AutoLock
&
&
)
=
delete
;
private
:
T
&
mMutex
;
}
;
using
MutexAutoLock
=
AutoLock
<
Mutex
>
;
#
endif
