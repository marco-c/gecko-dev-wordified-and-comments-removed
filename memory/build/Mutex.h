#
ifndef
Mutex_h
#
define
Mutex_h
#
if
defined
(
XP_WIN
)
#
include
<
windows
.
h
>
#
else
#
include
<
pthread
.
h
>
#
endif
#
if
defined
(
XP_DARWIN
)
#
include
<
os
/
lock
.
h
>
#
endif
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
MaybeStorageBase
.
h
"
#
include
"
mozilla
/
ThreadSafety
.
h
"
#
if
defined
(
XP_DARWIN
)
#
define
OS_UNFAIR_LOCK_DATA_SYNCHRONIZATION
(
0x00010000
)
#
define
OS_UNFAIR_LOCK_ADAPTIVE_SPIN
(
0x00040000
)
extern
"
C
"
{
typedef
uint32_t
os_unfair_lock_options_t
;
OS_UNFAIR_LOCK_AVAILABILITY
OS_EXPORT
OS_NOTHROW
OS_NONNULL_ALL
void
os_unfair_lock_lock_with_options
(
os_unfair_lock_t
lock
os_unfair_lock_options_t
options
)
;
}
#
endif
struct
MOZ_CAPABILITY
(
"
mutex
"
)
Mutex
{
#
if
defined
(
XP_WIN
)
mozilla
:
:
detail
:
:
MaybeStorageBase
<
CRITICAL_SECTION
>
mMutex
;
#
elif
defined
(
XP_DARWIN
)
os_unfair_lock
mMutex
=
OS_UNFAIR_LOCK_INIT
;
#
elif
defined
(
XP_LINUX
)
&
&
!
defined
(
ANDROID
)
pthread_mutex_t
mMutex
=
PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP
;
#
else
pthread_mutex_t
mMutex
=
PTHREAD_MUTEX_INITIALIZER
;
#
endif
#
ifdef
MOZ_DEBUG
bool
mInitialised
=
false
;
explicit
constexpr
Mutex
(
bool
aInitialised
)
:
mInitialised
(
aInitialised
)
{
}
#
else
explicit
constexpr
Mutex
(
bool
aIgnored
)
{
}
#
endif
constexpr
Mutex
(
)
{
}
inline
bool
Init
(
)
{
#
ifdef
MOZ_DEBUG
mInitialised
=
true
;
#
endif
#
if
defined
(
XP_WIN
)
if
(
!
InitializeCriticalSectionAndSpinCount
(
mMutex
.
addr
(
)
5000
)
)
{
return
false
;
}
#
elif
defined
(
XP_DARWIN
)
mMutex
=
OS_UNFAIR_LOCK_INIT
;
#
elif
defined
(
XP_LINUX
)
&
&
!
defined
(
ANDROID
)
pthread_mutexattr_t
attr
;
if
(
pthread_mutexattr_init
(
&
attr
)
!
=
0
)
{
return
false
;
}
pthread_mutexattr_settype
(
&
attr
PTHREAD_MUTEX_ADAPTIVE_NP
)
;
if
(
pthread_mutex_init
(
&
mMutex
&
attr
)
!
=
0
)
{
pthread_mutexattr_destroy
(
&
attr
)
;
return
false
;
}
pthread_mutexattr_destroy
(
&
attr
)
;
#
else
if
(
pthread_mutex_init
(
&
mMutex
nullptr
)
!
=
0
)
{
return
false
;
}
#
endif
return
true
;
}
inline
void
Lock
(
)
MOZ_CAPABILITY_ACQUIRE
(
)
{
MOZ_ASSERT
(
mInitialised
)
;
#
if
defined
(
XP_WIN
)
EnterCriticalSection
(
mMutex
.
addr
(
)
)
;
#
elif
defined
(
XP_DARWIN
)
os_unfair_lock_lock_with_options
(
&
mMutex
OS_UNFAIR_LOCK_DATA_SYNCHRONIZATION
|
OS_UNFAIR_LOCK_ADAPTIVE_SPIN
)
;
#
else
pthread_mutex_lock
(
&
mMutex
)
;
#
endif
}
[
[
nodiscard
]
]
bool
TryLock
(
)
MOZ_TRY_ACQUIRE
(
true
)
;
inline
void
Unlock
(
)
MOZ_CAPABILITY_RELEASE
(
)
{
MOZ_ASSERT
(
mInitialised
)
;
#
if
defined
(
XP_WIN
)
LeaveCriticalSection
(
mMutex
.
addr
(
)
)
;
#
elif
defined
(
XP_DARWIN
)
os_unfair_lock_unlock
(
&
mMutex
)
;
#
else
pthread_mutex_unlock
(
&
mMutex
)
;
#
endif
}
#
if
defined
(
XP_DARWIN
)
static
bool
SpinInKernelSpace
(
)
;
static
const
bool
gSpinInKernelSpace
;
#
endif
}
;
#
if
defined
(
XP_WIN
)
struct
MOZ_CAPABILITY
(
"
mutex
"
)
StaticMutex
{
SRWLOCK
mMutex
;
constexpr
StaticMutex
(
)
:
mMutex
(
SRWLOCK_INIT
)
{
}
inline
void
Lock
(
)
MOZ_CAPABILITY_ACQUIRE
(
)
{
AcquireSRWLockExclusive
(
&
mMutex
)
;
}
inline
void
Unlock
(
)
MOZ_CAPABILITY_RELEASE
(
)
{
ReleaseSRWLockExclusive
(
&
mMutex
)
;
}
}
;
#
else
struct
MOZ_CAPABILITY
(
"
mutex
"
)
StaticMutex
:
public
Mutex
{
constexpr
StaticMutex
(
)
:
Mutex
(
true
)
{
}
}
;
#
endif
#
ifdef
XP_WIN
typedef
DWORD
ThreadId
;
inline
ThreadId
GetThreadId
(
)
{
return
GetCurrentThreadId
(
)
;
}
inline
bool
ThreadIdEqual
(
ThreadId
a
ThreadId
b
)
{
return
a
=
=
b
;
}
#
else
typedef
pthread_t
ThreadId
;
inline
ThreadId
GetThreadId
(
)
{
return
pthread_self
(
)
;
}
inline
bool
ThreadIdEqual
(
ThreadId
a
ThreadId
b
)
{
return
pthread_equal
(
a
b
)
;
}
#
endif
class
MOZ_CAPABILITY
(
"
mutex
"
)
MaybeMutex
:
public
Mutex
{
public
:
enum
DoLock
{
MUST_LOCK
AVOID_LOCK_UNSAFE
}
;
bool
Init
(
DoLock
aDoLock
)
{
mDoLock
=
aDoLock
;
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
mThreadId
=
GetThreadId
(
)
;
#
endif
return
Mutex
:
:
Init
(
)
;
}
#
ifndef
XP_WIN
void
Reinit
(
pthread_t
aForkingThread
)
{
if
(
mDoLock
=
=
MUST_LOCK
)
{
Mutex
:
:
Init
(
)
;
return
;
}
#
ifdef
MOZ_DEBUG
if
(
pthread_equal
(
mThreadId
aForkingThread
)
)
{
mThreadId
=
GetThreadId
(
)
;
Mutex
:
:
Init
(
)
;
}
else
{
mDeniedAfterFork
=
true
;
}
#
endif
}
#
endif
inline
void
Lock
(
)
MOZ_CAPABILITY_ACQUIRE
(
)
{
if
(
ShouldLock
(
)
)
{
Mutex
:
:
Lock
(
)
;
}
}
inline
void
Unlock
(
)
MOZ_CAPABILITY_RELEASE
(
)
{
if
(
ShouldLock
(
)
)
{
Mutex
:
:
Unlock
(
)
;
}
}
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
bool
SafeOnThisThread
(
)
const
{
return
mDoLock
=
=
MUST_LOCK
|
|
ThreadIdEqual
(
GetThreadId
(
)
mThreadId
)
;
}
#
endif
bool
LockIsEnabled
(
)
const
{
return
mDoLock
=
=
MUST_LOCK
;
}
private
:
bool
ShouldLock
(
)
{
#
ifndef
XP_WIN
MOZ_ASSERT
(
!
mDeniedAfterFork
)
;
#
endif
if
(
mDoLock
=
=
MUST_LOCK
)
{
return
true
;
}
MOZ_ASSERT
(
SafeOnThisThread
(
)
)
;
return
false
;
}
DoLock
mDoLock
;
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
ThreadId
mThreadId
;
#
endif
#
if
(
!
defined
(
XP_WIN
)
&
&
defined
(
DEBUG
)
)
bool
mDeniedAfterFork
=
false
;
#
endif
}
;
template
<
typename
T
>
struct
MOZ_SCOPED_CAPABILITY
MOZ_RAII
AutoLock
{
explicit
AutoLock
(
T
&
aMutex
)
MOZ_CAPABILITY_ACQUIRE
(
aMutex
)
:
mMutex
(
aMutex
)
{
mMutex
.
Lock
(
)
;
}
~
AutoLock
(
)
MOZ_CAPABILITY_RELEASE
(
)
{
mMutex
.
Unlock
(
)
;
}
AutoLock
(
const
AutoLock
&
)
=
delete
;
AutoLock
(
AutoLock
&
&
)
=
delete
;
private
:
T
&
mMutex
;
}
;
using
MutexAutoLock
=
AutoLock
<
Mutex
>
;
using
MaybeMutexAutoLock
=
AutoLock
<
MaybeMutex
>
;
extern
StaticMutex
gInitLock
MOZ_UNANNOTATED
;
#
endif
