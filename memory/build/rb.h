#
ifndef
RB_H_
#
define
RB_H_
enum
NodeColor
{
Black
=
0
Red
=
1
}
;
template
<
typename
T
>
class
RedBlackTreeNode
{
T
*
mLeft
;
T
*
mRightAndColor
;
public
:
T
*
Left
(
)
{
return
mLeft
;
}
void
SetLeft
(
T
*
aValue
)
{
mLeft
=
aValue
;
}
T
*
Right
(
)
{
return
reinterpret_cast
<
T
*
>
(
reinterpret_cast
<
uintptr_t
>
(
mRightAndColor
)
&
uintptr_t
(
~
1
)
)
;
}
void
SetRight
(
T
*
aValue
)
{
mRightAndColor
=
reinterpret_cast
<
T
*
>
(
(
reinterpret_cast
<
uintptr_t
>
(
aValue
)
&
uintptr_t
(
~
1
)
)
|
Color
(
)
)
;
}
NodeColor
Color
(
)
{
return
static_cast
<
NodeColor
>
(
reinterpret_cast
<
uintptr_t
>
(
mRightAndColor
)
&
1
)
;
}
bool
IsBlack
(
)
{
return
Color
(
)
=
=
NodeColor
:
:
Black
;
}
bool
IsRed
(
)
{
return
Color
(
)
=
=
NodeColor
:
:
Red
;
}
void
SetColor
(
NodeColor
aColor
)
{
mRightAndColor
=
reinterpret_cast
<
T
*
>
(
(
reinterpret_cast
<
uintptr_t
>
(
mRightAndColor
)
&
uintptr_t
(
~
1
)
)
|
aColor
)
;
}
}
;
#
define
rbp_lean_left
(
a_type
a_field
a_node
r_node
)
\
do
{
\
NodeColor
rbp_ll_color
;
\
r_node
=
RotateLeft
(
a_node
)
;
\
rbp_ll_color
=
a_field
(
a_node
)
.
Color
(
)
;
\
a_field
(
r_node
)
.
SetColor
(
rbp_ll_color
)
;
\
a_field
(
a_node
)
.
SetColor
(
NodeColor
:
:
Red
)
;
\
}
while
(
0
)
#
define
rbp_lean_right
(
a_type
a_field
a_node
r_node
)
\
do
{
\
NodeColor
rbp_lr_color
;
\
r_node
=
RotateRight
(
a_node
)
;
\
rbp_lr_color
=
a_field
(
a_node
)
.
Color
(
)
;
\
a_field
(
r_node
)
.
SetColor
(
rbp_lr_color
)
;
\
a_field
(
a_node
)
.
SetColor
(
NodeColor
:
:
Red
)
;
\
}
while
(
0
)
#
define
rbp_move_red_left
(
a_type
a_field
a_node
r_node
)
\
do
{
\
a_type
*
rbp_mrl_t
*
rbp_mrl_u
;
\
rbp_mrl_t
=
a_field
(
a_node
)
.
Left
(
)
;
\
a_field
(
rbp_mrl_t
)
.
SetColor
(
NodeColor
:
:
Red
)
;
\
rbp_mrl_t
=
a_field
(
a_node
)
.
Right
(
)
;
\
rbp_mrl_u
=
a_field
(
rbp_mrl_t
)
.
Left
(
)
;
\
if
(
a_field
(
rbp_mrl_u
)
.
IsRed
(
)
)
{
\
rbp_mrl_u
=
RotateRight
(
rbp_mrl_t
)
;
\
a_field
(
a_node
)
.
SetRight
(
rbp_mrl_u
)
;
\
r_node
=
RotateLeft
(
a_node
)
;
\
rbp_mrl_t
=
a_field
(
a_node
)
.
Right
(
)
;
\
if
(
a_field
(
rbp_mrl_t
)
.
IsRed
(
)
)
{
\
a_field
(
rbp_mrl_t
)
.
SetColor
(
NodeColor
:
:
Black
)
;
\
a_field
(
a_node
)
.
SetColor
(
NodeColor
:
:
Red
)
;
\
rbp_mrl_t
=
RotateLeft
(
a_node
)
;
\
a_field
(
r_node
)
.
SetLeft
(
rbp_mrl_t
)
;
\
}
else
{
\
a_field
(
a_node
)
.
SetColor
(
NodeColor
:
:
Black
)
;
\
}
\
}
else
{
\
a_field
(
a_node
)
.
SetColor
(
NodeColor
:
:
Red
)
;
\
r_node
=
RotateLeft
(
a_node
)
;
\
}
\
}
while
(
0
)
#
define
rbp_move_red_right
(
a_type
a_field
a_node
r_node
)
\
do
{
\
a_type
*
rbp_mrr_t
;
\
rbp_mrr_t
=
a_field
(
a_node
)
.
Left
(
)
;
\
if
(
a_field
(
rbp_mrr_t
)
.
IsRed
(
)
)
{
\
a_type
*
rbp_mrr_u
*
rbp_mrr_v
;
\
rbp_mrr_u
=
a_field
(
rbp_mrr_t
)
.
Right
(
)
;
\
rbp_mrr_v
=
a_field
(
rbp_mrr_u
)
.
Left
(
)
;
\
if
(
a_field
(
rbp_mrr_v
)
.
IsRed
(
)
)
{
\
a_field
(
rbp_mrr_u
)
.
SetColor
(
a_field
(
a_node
)
.
Color
(
)
)
;
\
a_field
(
rbp_mrr_v
)
.
SetColor
(
NodeColor
:
:
Black
)
;
\
rbp_mrr_u
=
RotateLeft
(
rbp_mrr_t
)
;
\
a_field
(
a_node
)
.
SetLeft
(
rbp_mrr_u
)
;
\
r_node
=
RotateRight
(
a_node
)
;
\
rbp_mrr_t
=
RotateLeft
(
a_node
)
;
\
a_field
(
r_node
)
.
SetRight
(
rbp_mrr_t
)
;
\
}
else
{
\
a_field
(
rbp_mrr_t
)
.
SetColor
(
a_field
(
a_node
)
.
Color
(
)
)
;
\
a_field
(
rbp_mrr_u
)
.
SetColor
(
NodeColor
:
:
Red
)
;
\
r_node
=
RotateRight
(
a_node
)
;
\
rbp_mrr_t
=
RotateLeft
(
a_node
)
;
\
a_field
(
r_node
)
.
SetRight
(
rbp_mrr_t
)
;
\
}
\
a_field
(
a_node
)
.
SetColor
(
NodeColor
:
:
Red
)
;
\
}
else
{
\
a_field
(
rbp_mrr_t
)
.
SetColor
(
NodeColor
:
:
Red
)
;
\
rbp_mrr_t
=
a_field
(
rbp_mrr_t
)
.
Left
(
)
;
\
if
(
a_field
(
rbp_mrr_t
)
.
IsRed
(
)
)
{
\
a_field
(
rbp_mrr_t
)
.
SetColor
(
NodeColor
:
:
Black
)
;
\
r_node
=
RotateRight
(
a_node
)
;
\
rbp_mrr_t
=
RotateLeft
(
a_node
)
;
\
a_field
(
r_node
)
.
SetRight
(
rbp_mrr_t
)
;
\
}
else
{
\
r_node
=
RotateLeft
(
a_node
)
;
\
}
\
}
\
}
while
(
0
)
template
<
typename
T
typename
Trait
>
struct
RedBlackTree
{
T
*
rbt_root
;
T
rbt_nil
;
void
Init
(
)
{
rbt_root
=
&
rbt_nil
;
Trait
:
:
GetTreeNode
(
&
rbt_nil
)
.
SetLeft
(
&
rbt_nil
)
;
Trait
:
:
GetTreeNode
(
&
rbt_nil
)
.
SetRight
(
&
rbt_nil
)
;
Trait
:
:
GetTreeNode
(
&
rbt_nil
)
.
SetColor
(
NodeColor
:
:
Black
)
;
}
T
*
First
(
T
*
aStart
=
nullptr
)
{
T
*
ret
;
for
(
ret
=
aStart
?
aStart
:
rbt_root
;
Trait
:
:
GetTreeNode
(
ret
)
.
Left
(
)
!
=
&
rbt_nil
;
ret
=
Trait
:
:
GetTreeNode
(
ret
)
.
Left
(
)
)
{
}
return
(
ret
=
=
&
rbt_nil
)
?
nullptr
:
ret
;
}
T
*
Last
(
T
*
aStart
=
nullptr
)
{
T
*
ret
;
for
(
ret
=
aStart
?
aStart
:
rbt_root
;
Trait
:
:
GetTreeNode
(
ret
)
.
Right
(
)
!
=
&
rbt_nil
;
ret
=
Trait
:
:
GetTreeNode
(
ret
)
.
Right
(
)
)
{
}
return
(
ret
=
=
&
rbt_nil
)
?
nullptr
:
ret
;
}
T
*
Next
(
T
*
aNode
)
{
T
*
ret
;
if
(
Trait
:
:
GetTreeNode
(
aNode
)
.
Right
(
)
!
=
&
rbt_nil
)
{
ret
=
First
(
Trait
:
:
GetTreeNode
(
aNode
)
.
Right
(
)
)
;
}
else
{
T
*
rbp_n_t
=
rbt_root
;
MOZ_ASSERT
(
rbp_n_t
!
=
&
rbt_nil
)
;
ret
=
&
rbt_nil
;
while
(
true
)
{
int
rbp_n_cmp
=
Trait
:
:
Compare
(
aNode
rbp_n_t
)
;
if
(
rbp_n_cmp
<
0
)
{
ret
=
rbp_n_t
;
rbp_n_t
=
Trait
:
:
GetTreeNode
(
rbp_n_t
)
.
Left
(
)
;
}
else
if
(
rbp_n_cmp
>
0
)
{
rbp_n_t
=
Trait
:
:
GetTreeNode
(
rbp_n_t
)
.
Right
(
)
;
}
else
{
break
;
}
MOZ_ASSERT
(
rbp_n_t
!
=
&
rbt_nil
)
;
}
}
return
(
ret
=
=
&
rbt_nil
)
?
nullptr
:
ret
;
}
T
*
Prev
(
T
*
aNode
)
{
T
*
ret
;
if
(
Trait
:
:
GetTreeNode
(
aNode
)
.
Left
(
)
!
=
&
rbt_nil
)
{
ret
=
Last
(
Trait
:
:
GetTreeNode
(
aNode
)
.
Left
(
)
)
;
}
else
{
T
*
rbp_p_t
=
rbt_root
;
MOZ_ASSERT
(
rbp_p_t
!
=
&
rbt_nil
)
;
ret
=
&
rbt_nil
;
while
(
true
)
{
int
rbp_p_cmp
=
Trait
:
:
Compare
(
aNode
rbp_p_t
)
;
if
(
rbp_p_cmp
<
0
)
{
rbp_p_t
=
Trait
:
:
GetTreeNode
(
rbp_p_t
)
.
Left
(
)
;
}
else
if
(
rbp_p_cmp
>
0
)
{
ret
=
rbp_p_t
;
rbp_p_t
=
Trait
:
:
GetTreeNode
(
rbp_p_t
)
.
Right
(
)
;
}
else
{
break
;
}
MOZ_ASSERT
(
rbp_p_t
!
=
&
rbt_nil
)
;
}
}
return
(
ret
=
=
&
rbt_nil
)
?
nullptr
:
ret
;
}
T
*
Search
(
T
*
aKey
)
{
T
*
ret
=
rbt_root
;
int
rbp_se_cmp
;
while
(
ret
!
=
&
rbt_nil
&
&
(
rbp_se_cmp
=
Trait
:
:
Compare
(
aKey
ret
)
)
!
=
0
)
{
if
(
rbp_se_cmp
<
0
)
{
ret
=
Trait
:
:
GetTreeNode
(
ret
)
.
Left
(
)
;
}
else
{
ret
=
Trait
:
:
GetTreeNode
(
ret
)
.
Right
(
)
;
}
}
return
(
ret
=
=
&
rbt_nil
)
?
nullptr
:
ret
;
}
T
*
SearchOrNext
(
T
*
aKey
)
{
T
*
ret
=
nullptr
;
T
*
rbp_ns_t
=
rbt_root
;
while
(
rbp_ns_t
!
=
&
rbt_nil
)
{
int
rbp_ns_cmp
=
Trait
:
:
Compare
(
aKey
rbp_ns_t
)
;
if
(
rbp_ns_cmp
<
0
)
{
ret
=
rbp_ns_t
;
rbp_ns_t
=
Trait
:
:
GetTreeNode
(
rbp_ns_t
)
.
Left
(
)
;
}
else
if
(
rbp_ns_cmp
>
0
)
{
rbp_ns_t
=
Trait
:
:
GetTreeNode
(
rbp_ns_t
)
.
Right
(
)
;
}
else
{
ret
=
rbp_ns_t
;
break
;
}
}
return
ret
;
}
void
Insert
(
T
*
aNode
)
{
T
rbp_i_s
;
T
*
rbp_i_g
*
rbp_i_p
*
rbp_i_c
*
rbp_i_t
*
rbp_i_u
;
int
rbp_i_cmp
=
0
;
rbp_i_g
=
&
rbt_nil
;
Trait
:
:
GetTreeNode
(
&
rbp_i_s
)
.
SetLeft
(
rbt_root
)
;
Trait
:
:
GetTreeNode
(
&
rbp_i_s
)
.
SetRight
(
&
rbt_nil
)
;
Trait
:
:
GetTreeNode
(
&
rbp_i_s
)
.
SetColor
(
NodeColor
:
:
Black
)
;
rbp_i_p
=
&
rbp_i_s
;
rbp_i_c
=
rbt_root
;
while
(
rbp_i_c
!
=
&
rbt_nil
)
{
rbp_i_t
=
Trait
:
:
GetTreeNode
(
rbp_i_c
)
.
Left
(
)
;
rbp_i_u
=
Trait
:
:
GetTreeNode
(
rbp_i_t
)
.
Left
(
)
;
if
(
Trait
:
:
GetTreeNode
(
rbp_i_t
)
.
IsRed
(
)
&
&
Trait
:
:
GetTreeNode
(
rbp_i_u
)
.
IsRed
(
)
)
{
rbp_i_t
=
RotateRight
(
rbp_i_c
)
;
rbp_i_u
=
Trait
:
:
GetTreeNode
(
rbp_i_t
)
.
Left
(
)
;
Trait
:
:
GetTreeNode
(
rbp_i_u
)
.
SetColor
(
NodeColor
:
:
Black
)
;
if
(
Trait
:
:
GetTreeNode
(
rbp_i_p
)
.
Left
(
)
=
=
rbp_i_c
)
{
Trait
:
:
GetTreeNode
(
rbp_i_p
)
.
SetLeft
(
rbp_i_t
)
;
rbp_i_c
=
rbp_i_t
;
}
else
{
MOZ_ASSERT
(
Trait
:
:
GetTreeNode
(
rbp_i_p
)
.
Right
(
)
=
=
rbp_i_c
)
;
Trait
:
:
GetTreeNode
(
rbp_i_p
)
.
SetRight
(
rbp_i_t
)
;
rbp_lean_left
(
T
Trait
:
:
GetTreeNode
rbp_i_p
rbp_i_u
)
;
if
(
Trait
:
:
GetTreeNode
(
rbp_i_g
)
.
Left
(
)
=
=
rbp_i_p
)
{
Trait
:
:
GetTreeNode
(
rbp_i_g
)
.
SetLeft
(
rbp_i_u
)
;
}
else
{
MOZ_ASSERT
(
Trait
:
:
GetTreeNode
(
rbp_i_g
)
.
Right
(
)
=
=
rbp_i_p
)
;
Trait
:
:
GetTreeNode
(
rbp_i_g
)
.
SetRight
(
rbp_i_u
)
;
}
rbp_i_p
=
rbp_i_u
;
rbp_i_cmp
=
Trait
:
:
Compare
(
aNode
rbp_i_p
)
;
if
(
rbp_i_cmp
<
0
)
{
rbp_i_c
=
Trait
:
:
GetTreeNode
(
rbp_i_p
)
.
Left
(
)
;
}
else
{
MOZ_ASSERT
(
rbp_i_cmp
>
0
)
;
rbp_i_c
=
Trait
:
:
GetTreeNode
(
rbp_i_p
)
.
Right
(
)
;
}
continue
;
}
}
rbp_i_g
=
rbp_i_p
;
rbp_i_p
=
rbp_i_c
;
rbp_i_cmp
=
Trait
:
:
Compare
(
aNode
rbp_i_c
)
;
if
(
rbp_i_cmp
<
0
)
{
rbp_i_c
=
Trait
:
:
GetTreeNode
(
rbp_i_c
)
.
Left
(
)
;
}
else
{
MOZ_ASSERT
(
rbp_i_cmp
>
0
)
;
rbp_i_c
=
Trait
:
:
GetTreeNode
(
rbp_i_c
)
.
Right
(
)
;
}
}
Trait
:
:
GetTreeNode
(
aNode
)
.
SetLeft
(
&
rbt_nil
)
;
Trait
:
:
GetTreeNode
(
aNode
)
.
SetRight
(
&
rbt_nil
)
;
Trait
:
:
GetTreeNode
(
aNode
)
.
SetColor
(
NodeColor
:
:
Red
)
;
if
(
rbp_i_cmp
>
0
)
{
Trait
:
:
GetTreeNode
(
rbp_i_p
)
.
SetRight
(
aNode
)
;
rbp_lean_left
(
T
Trait
:
:
GetTreeNode
rbp_i_p
rbp_i_t
)
;
if
(
Trait
:
:
GetTreeNode
(
rbp_i_g
)
.
Left
(
)
=
=
rbp_i_p
)
{
Trait
:
:
GetTreeNode
(
rbp_i_g
)
.
SetLeft
(
rbp_i_t
)
;
}
else
if
(
Trait
:
:
GetTreeNode
(
rbp_i_g
)
.
Right
(
)
=
=
rbp_i_p
)
{
Trait
:
:
GetTreeNode
(
rbp_i_g
)
.
SetRight
(
rbp_i_t
)
;
}
}
else
{
Trait
:
:
GetTreeNode
(
rbp_i_p
)
.
SetLeft
(
aNode
)
;
}
rbt_root
=
Trait
:
:
GetTreeNode
(
&
rbp_i_s
)
.
Left
(
)
;
Trait
:
:
GetTreeNode
(
rbt_root
)
.
SetColor
(
NodeColor
:
:
Black
)
;
}
void
Remove
(
T
*
aNode
)
{
T
rbp_r_s
;
T
*
rbp_r_p
*
rbp_r_c
*
rbp_r_xp
*
rbp_r_t
*
rbp_r_u
;
int
rbp_r_cmp
;
Trait
:
:
GetTreeNode
(
&
rbp_r_s
)
.
SetLeft
(
rbt_root
)
;
Trait
:
:
GetTreeNode
(
&
rbp_r_s
)
.
SetRight
(
&
rbt_nil
)
;
Trait
:
:
GetTreeNode
(
&
rbp_r_s
)
.
SetColor
(
NodeColor
:
:
Black
)
;
rbp_r_p
=
&
rbp_r_s
;
rbp_r_c
=
rbt_root
;
rbp_r_xp
=
&
rbt_nil
;
rbp_r_cmp
=
Trait
:
:
Compare
(
aNode
rbp_r_c
)
;
if
(
rbp_r_cmp
<
0
)
{
rbp_r_t
=
Trait
:
:
GetTreeNode
(
rbp_r_c
)
.
Left
(
)
;
rbp_r_u
=
Trait
:
:
GetTreeNode
(
rbp_r_t
)
.
Left
(
)
;
if
(
Trait
:
:
GetTreeNode
(
rbp_r_t
)
.
IsBlack
(
)
&
&
Trait
:
:
GetTreeNode
(
rbp_r_u
)
.
IsBlack
(
)
)
{
rbp_move_red_left
(
T
Trait
:
:
GetTreeNode
rbp_r_c
rbp_r_t
)
;
Trait
:
:
GetTreeNode
(
rbp_r_t
)
.
SetColor
(
NodeColor
:
:
Black
)
;
Trait
:
:
GetTreeNode
(
rbp_r_p
)
.
SetLeft
(
rbp_r_t
)
;
rbp_r_c
=
rbp_r_t
;
}
else
{
rbp_r_p
=
rbp_r_c
;
rbp_r_c
=
Trait
:
:
GetTreeNode
(
rbp_r_c
)
.
Left
(
)
;
}
}
else
{
if
(
rbp_r_cmp
=
=
0
)
{
MOZ_ASSERT
(
aNode
=
=
rbp_r_c
)
;
if
(
Trait
:
:
GetTreeNode
(
rbp_r_c
)
.
Right
(
)
=
=
&
rbt_nil
)
{
if
(
Trait
:
:
GetTreeNode
(
rbp_r_c
)
.
Left
(
)
!
=
&
rbt_nil
)
{
rbp_lean_right
(
T
Trait
:
:
GetTreeNode
rbp_r_c
rbp_r_t
)
;
Trait
:
:
GetTreeNode
(
rbp_r_t
)
.
SetRight
(
&
rbt_nil
)
;
}
else
{
rbp_r_t
=
&
rbt_nil
;
}
Trait
:
:
GetTreeNode
(
rbp_r_p
)
.
SetLeft
(
rbp_r_t
)
;
}
else
{
rbp_r_xp
=
rbp_r_p
;
rbp_r_cmp
=
1
;
}
}
if
(
rbp_r_cmp
=
=
1
)
{
if
(
Trait
:
:
GetTreeNode
(
Trait
:
:
GetTreeNode
(
Trait
:
:
GetTreeNode
(
rbp_r_c
)
.
Right
(
)
)
.
Left
(
)
)
.
IsBlack
(
)
)
{
rbp_r_t
=
Trait
:
:
GetTreeNode
(
rbp_r_c
)
.
Left
(
)
;
if
(
Trait
:
:
GetTreeNode
(
rbp_r_t
)
.
IsRed
(
)
)
{
rbp_move_red_right
(
T
Trait
:
:
GetTreeNode
rbp_r_c
rbp_r_t
)
;
}
else
{
Trait
:
:
GetTreeNode
(
rbp_r_c
)
.
SetColor
(
NodeColor
:
:
Red
)
;
rbp_r_u
=
Trait
:
:
GetTreeNode
(
rbp_r_t
)
.
Left
(
)
;
if
(
Trait
:
:
GetTreeNode
(
rbp_r_u
)
.
IsRed
(
)
)
{
Trait
:
:
GetTreeNode
(
rbp_r_u
)
.
SetColor
(
NodeColor
:
:
Black
)
;
rbp_r_t
=
RotateRight
(
rbp_r_c
)
;
rbp_r_u
=
RotateLeft
(
rbp_r_c
)
;
Trait
:
:
GetTreeNode
(
rbp_r_t
)
.
SetRight
(
rbp_r_u
)
;
}
else
{
Trait
:
:
GetTreeNode
(
rbp_r_t
)
.
SetColor
(
NodeColor
:
:
Red
)
;
rbp_r_t
=
RotateLeft
(
rbp_r_c
)
;
}
}
Trait
:
:
GetTreeNode
(
rbp_r_p
)
.
SetLeft
(
rbp_r_t
)
;
rbp_r_c
=
rbp_r_t
;
}
else
{
rbp_r_p
=
rbp_r_c
;
rbp_r_c
=
Trait
:
:
GetTreeNode
(
rbp_r_c
)
.
Right
(
)
;
}
}
}
if
(
rbp_r_cmp
!
=
0
)
{
while
(
true
)
{
MOZ_ASSERT
(
rbp_r_p
!
=
&
rbt_nil
)
;
rbp_r_cmp
=
Trait
:
:
Compare
(
aNode
rbp_r_c
)
;
if
(
rbp_r_cmp
<
0
)
{
rbp_r_t
=
Trait
:
:
GetTreeNode
(
rbp_r_c
)
.
Left
(
)
;
if
(
rbp_r_t
=
=
&
rbt_nil
)
{
if
(
Trait
:
:
GetTreeNode
(
rbp_r_xp
)
.
Left
(
)
=
=
(
aNode
)
)
{
Trait
:
:
GetTreeNode
(
rbp_r_xp
)
.
SetLeft
(
rbp_r_c
)
;
}
else
{
MOZ_ASSERT
(
Trait
:
:
GetTreeNode
(
rbp_r_xp
)
.
Right
(
)
=
=
(
aNode
)
)
;
Trait
:
:
GetTreeNode
(
rbp_r_xp
)
.
SetRight
(
rbp_r_c
)
;
}
Trait
:
:
GetTreeNode
(
rbp_r_c
)
.
SetLeft
(
Trait
:
:
GetTreeNode
(
aNode
)
.
Left
(
)
)
;
Trait
:
:
GetTreeNode
(
rbp_r_c
)
.
SetRight
(
Trait
:
:
GetTreeNode
(
aNode
)
.
Right
(
)
)
;
Trait
:
:
GetTreeNode
(
rbp_r_c
)
.
SetColor
(
Trait
:
:
GetTreeNode
(
aNode
)
.
Color
(
)
)
;
if
(
Trait
:
:
GetTreeNode
(
rbp_r_p
)
.
Left
(
)
=
=
rbp_r_c
)
{
Trait
:
:
GetTreeNode
(
rbp_r_p
)
.
SetLeft
(
&
rbt_nil
)
;
}
else
{
MOZ_ASSERT
(
Trait
:
:
GetTreeNode
(
rbp_r_p
)
.
Right
(
)
=
=
rbp_r_c
)
;
Trait
:
:
GetTreeNode
(
rbp_r_p
)
.
SetRight
(
&
rbt_nil
)
;
}
break
;
}
rbp_r_u
=
Trait
:
:
GetTreeNode
(
rbp_r_t
)
.
Left
(
)
;
if
(
Trait
:
:
GetTreeNode
(
rbp_r_t
)
.
IsBlack
(
)
&
&
Trait
:
:
GetTreeNode
(
rbp_r_u
)
.
IsBlack
(
)
)
{
rbp_move_red_left
(
T
Trait
:
:
GetTreeNode
rbp_r_c
rbp_r_t
)
;
if
(
Trait
:
:
GetTreeNode
(
rbp_r_p
)
.
Left
(
)
=
=
rbp_r_c
)
{
Trait
:
:
GetTreeNode
(
rbp_r_p
)
.
SetLeft
(
rbp_r_t
)
;
}
else
{
Trait
:
:
GetTreeNode
(
rbp_r_p
)
.
SetRight
(
rbp_r_t
)
;
}
rbp_r_c
=
rbp_r_t
;
}
else
{
rbp_r_p
=
rbp_r_c
;
rbp_r_c
=
Trait
:
:
GetTreeNode
(
rbp_r_c
)
.
Left
(
)
;
}
}
else
{
if
(
rbp_r_cmp
=
=
0
)
{
MOZ_ASSERT
(
aNode
=
=
rbp_r_c
)
;
if
(
Trait
:
:
GetTreeNode
(
rbp_r_c
)
.
Right
(
)
=
=
&
rbt_nil
)
{
if
(
Trait
:
:
GetTreeNode
(
rbp_r_c
)
.
Left
(
)
!
=
&
rbt_nil
)
{
rbp_lean_right
(
T
Trait
:
:
GetTreeNode
rbp_r_c
rbp_r_t
)
;
Trait
:
:
GetTreeNode
(
rbp_r_t
)
.
SetRight
(
&
rbt_nil
)
;
}
else
{
rbp_r_t
=
&
rbt_nil
;
}
if
(
Trait
:
:
GetTreeNode
(
rbp_r_p
)
.
Left
(
)
=
=
rbp_r_c
)
{
Trait
:
:
GetTreeNode
(
rbp_r_p
)
.
SetLeft
(
rbp_r_t
)
;
}
else
{
Trait
:
:
GetTreeNode
(
rbp_r_p
)
.
SetRight
(
rbp_r_t
)
;
}
break
;
}
else
{
rbp_r_xp
=
rbp_r_p
;
}
}
rbp_r_t
=
Trait
:
:
GetTreeNode
(
rbp_r_c
)
.
Right
(
)
;
rbp_r_u
=
Trait
:
:
GetTreeNode
(
rbp_r_t
)
.
Left
(
)
;
if
(
Trait
:
:
GetTreeNode
(
rbp_r_u
)
.
IsBlack
(
)
)
{
rbp_move_red_right
(
T
Trait
:
:
GetTreeNode
rbp_r_c
rbp_r_t
)
;
if
(
Trait
:
:
GetTreeNode
(
rbp_r_p
)
.
Left
(
)
=
=
rbp_r_c
)
{
Trait
:
:
GetTreeNode
(
rbp_r_p
)
.
SetLeft
(
rbp_r_t
)
;
}
else
{
Trait
:
:
GetTreeNode
(
rbp_r_p
)
.
SetRight
(
rbp_r_t
)
;
}
rbp_r_c
=
rbp_r_t
;
}
else
{
rbp_r_p
=
rbp_r_c
;
rbp_r_c
=
Trait
:
:
GetTreeNode
(
rbp_r_c
)
.
Right
(
)
;
}
}
}
}
rbt_root
=
Trait
:
:
GetTreeNode
(
&
rbp_r_s
)
.
Left
(
)
;
}
private
:
T
*
RotateLeft
(
T
*
aNode
)
{
T
*
node
=
Trait
:
:
GetTreeNode
(
aNode
)
.
Right
(
)
;
Trait
:
:
GetTreeNode
(
aNode
)
.
SetRight
(
Trait
:
:
GetTreeNode
(
node
)
.
Left
(
)
)
;
Trait
:
:
GetTreeNode
(
node
)
.
SetLeft
(
aNode
)
;
return
node
;
}
T
*
RotateRight
(
T
*
aNode
)
{
T
*
node
=
Trait
:
:
GetTreeNode
(
aNode
)
.
Left
(
)
;
Trait
:
:
GetTreeNode
(
aNode
)
.
SetLeft
(
Trait
:
:
GetTreeNode
(
node
)
.
Right
(
)
)
;
Trait
:
:
GetTreeNode
(
node
)
.
SetRight
(
aNode
)
;
return
node
;
}
}
;
#
define
rbp_f_height
(
3
*
(
(
SIZEOF_PTR
<
<
3
)
-
(
SIZEOF_PTR_2POW
+
1
)
)
)
#
define
rb_foreach_begin
(
a_type
a_field
a_tree
a_var
)
\
{
\
{
\
/
*
Initialize
the
path
to
contain
the
left
spine
.
*
/
\
a_type
*
rbp_f_path
[
rbp_f_height
]
;
\
a_type
*
rbp_f_node
;
\
bool
rbp_f_synced
=
false
;
\
unsigned
rbp_f_depth
=
0
;
\
if
(
(
a_tree
)
-
>
rbt_root
!
=
&
(
a_tree
)
-
>
rbt_nil
)
{
\
rbp_f_path
[
rbp_f_depth
]
=
(
a_tree
)
-
>
rbt_root
;
\
rbp_f_depth
+
+
;
\
while
(
(
rbp_f_node
=
a_field
(
rbp_f_path
[
rbp_f_depth
-
1
]
)
.
Left
(
)
)
!
=
\
&
(
a_tree
)
-
>
rbt_nil
)
{
\
rbp_f_path
[
rbp_f_depth
]
=
rbp_f_node
;
\
rbp_f_depth
+
+
;
\
}
\
}
\
/
*
While
the
path
is
non
-
empty
iterate
.
*
/
\
while
(
rbp_f_depth
>
0
)
{
\
(
a_var
)
=
rbp_f_path
[
rbp_f_depth
-
1
]
;
#
define
rb_foreach_end
(
a_type
a_field
a_tree
a_var
)
\
if
(
rbp_f_synced
)
{
\
rbp_f_synced
=
false
;
\
continue
;
\
}
\
/
*
Find
the
successor
.
*
/
\
if
(
(
rbp_f_node
=
a_field
(
rbp_f_path
[
rbp_f_depth
-
1
]
)
.
Right
(
)
)
!
=
\
&
(
a_tree
)
-
>
rbt_nil
)
{
\
/
*
The
successor
is
the
left
-
most
node
in
the
right
*
/
\
/
*
subtree
.
*
/
\
rbp_f_path
[
rbp_f_depth
]
=
rbp_f_node
;
\
rbp_f_depth
+
+
;
\
while
(
(
rbp_f_node
=
a_field
(
rbp_f_path
[
rbp_f_depth
-
1
]
)
.
Left
(
)
)
!
=
\
&
(
a_tree
)
-
>
rbt_nil
)
{
\
rbp_f_path
[
rbp_f_depth
]
=
rbp_f_node
;
\
rbp_f_depth
+
+
;
\
}
\
}
else
{
\
/
*
The
successor
is
above
the
current
node
.
Unwind
*
/
\
/
*
until
a
left
-
leaning
edge
is
removed
from
the
*
/
\
/
*
path
or
the
path
is
empty
.
*
/
\
for
(
rbp_f_depth
-
-
;
rbp_f_depth
>
0
;
rbp_f_depth
-
-
)
{
\
if
(
a_field
(
rbp_f_path
[
rbp_f_depth
-
1
]
)
.
Left
(
)
=
=
\
rbp_f_path
[
rbp_f_depth
]
)
{
\
break
;
\
}
\
}
\
}
\
}
\
}
\
}
#
endif
