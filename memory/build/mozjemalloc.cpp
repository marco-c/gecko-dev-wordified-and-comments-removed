#
include
"
mozmemory_wrap
.
h
"
#
include
"
mozjemalloc
.
h
"
#
include
"
mozjemalloc_types
.
h
"
#
include
<
cstring
>
#
include
<
cerrno
>
#
ifdef
XP_WIN
#
include
<
io
.
h
>
#
include
<
windows
.
h
>
#
else
#
include
<
sys
/
mman
.
h
>
#
include
<
unistd
.
h
>
#
endif
#
ifdef
XP_DARWIN
#
include
<
libkern
/
OSAtomic
.
h
>
#
include
<
mach
/
mach_init
.
h
>
#
include
<
mach
/
vm_map
.
h
>
#
endif
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Alignment
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
DoublyLinkedList
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
mozilla
/
TaggedAnonymousMemory
.
h
"
#
include
"
mozilla
/
ThreadLocal
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
fallible
.
h
"
#
include
"
rb
.
h
"
#
include
"
Mutex
.
h
"
#
include
"
Utils
.
h
"
using
namespace
mozilla
;
#
ifdef
XP_DARWIN
#
define
MALLOC_DOUBLE_PURGE
#
endif
#
ifdef
XP_WIN
#
define
MALLOC_DECOMMIT
#
endif
#
ifndef
MOZ_DEBUG
#
if
!
defined
(
__ia64__
)
&
&
!
defined
(
__sparc__
)
&
&
!
defined
(
__mips__
)
&
&
\
!
defined
(
__aarch64__
)
#
define
MALLOC_STATIC_PAGESIZE
1
#
endif
#
endif
#
ifdef
XP_WIN
#
define
STDERR_FILENO
2
static
char
mozillaMallocOptionsBuf
[
64
]
;
#
define
getenv
xgetenv
static
char
*
getenv
(
const
char
*
name
)
{
if
(
GetEnvironmentVariableA
(
name
mozillaMallocOptionsBuf
sizeof
(
mozillaMallocOptionsBuf
)
)
>
0
)
{
return
mozillaMallocOptionsBuf
;
}
return
nullptr
;
}
#
endif
#
ifndef
XP_WIN
#
ifndef
MADV_FREE
#
define
MADV_FREE
MADV_DONTNEED
#
endif
#
endif
#
if
(
defined
(
XP_LINUX
)
&
&
!
defined
(
__alpha__
)
)
|
|
\
(
defined
(
__FreeBSD_kernel__
)
&
&
defined
(
__GLIBC__
)
)
#
include
<
sys
/
syscall
.
h
>
#
if
defined
(
SYS_mmap
)
|
|
defined
(
SYS_mmap2
)
static
inline
void
*
_mmap
(
void
*
addr
size_t
length
int
prot
int
flags
int
fd
off_t
offset
)
{
#
ifdef
__s390__
struct
{
void
*
addr
;
size_t
length
;
long
prot
;
long
flags
;
long
fd
;
off_t
offset
;
}
args
=
{
addr
length
prot
flags
fd
offset
}
;
return
(
void
*
)
syscall
(
SYS_mmap
&
args
)
;
#
else
#
if
defined
(
ANDROID
)
&
&
defined
(
__aarch64__
)
&
&
defined
(
SYS_mmap2
)
#
undef
SYS_mmap2
#
endif
#
ifdef
SYS_mmap2
return
(
void
*
)
syscall
(
SYS_mmap2
addr
length
prot
flags
fd
offset
>
>
12
)
;
#
else
return
(
void
*
)
syscall
(
SYS_mmap
addr
length
prot
flags
fd
offset
)
;
#
endif
#
endif
}
#
define
mmap
_mmap
#
define
munmap
(
a
l
)
syscall
(
SYS_munmap
a
l
)
#
endif
#
endif
struct
arena_t
;
struct
arena_chunk_map_t
{
RedBlackTreeNode
<
arena_chunk_map_t
>
link
;
size_t
bits
;
#
define
CHUNK_MAP_MADVISED
(
(
size_t
)
0x40U
)
#
define
CHUNK_MAP_DECOMMITTED
(
(
size_t
)
0x20U
)
#
define
CHUNK_MAP_MADVISED_OR_DECOMMITTED
\
(
CHUNK_MAP_MADVISED
|
CHUNK_MAP_DECOMMITTED
)
#
define
CHUNK_MAP_KEY
(
(
size_t
)
0x10U
)
#
define
CHUNK_MAP_DIRTY
(
(
size_t
)
0x08U
)
#
define
CHUNK_MAP_ZEROED
(
(
size_t
)
0x04U
)
#
define
CHUNK_MAP_LARGE
(
(
size_t
)
0x02U
)
#
define
CHUNK_MAP_ALLOCATED
(
(
size_t
)
0x01U
)
}
;
struct
arena_chunk_t
{
arena_t
*
arena
;
RedBlackTreeNode
<
arena_chunk_t
>
link_dirty
;
#
ifdef
MALLOC_DOUBLE_PURGE
DoublyLinkedListElement
<
arena_chunk_t
>
chunks_madvised_elem
;
#
endif
size_t
ndirty
;
arena_chunk_map_t
map
[
1
]
;
}
;
static
const
size_t
kCacheLineSize
=
64
;
#
ifdef
XP_WIN
static
const
size_t
kMinTinyClass
=
sizeof
(
void
*
)
*
2
;
#
else
static
const
size_t
kMinTinyClass
=
sizeof
(
void
*
)
;
#
endif
static
const
size_t
kMaxTinyClass
=
8
;
static
const
size_t
kQuantum
=
16
;
static
const
size_t
kQuantumMask
=
kQuantum
-
1
;
static
const
size_t
kMinQuantumClass
=
kMaxTinyClass
*
2
;
static
const
size_t
kMaxQuantumClass
=
512
;
static_assert
(
kMaxQuantumClass
%
kQuantum
=
=
0
"
kMaxQuantumClass
is
not
a
multiple
of
kQuantum
"
)
;
static
const
size_t
kNumTinyClasses
=
LOG2
(
kMinQuantumClass
)
-
LOG2
(
kMinTinyClass
)
;
static
const
size_t
kNumQuantumClasses
=
kMaxQuantumClass
/
kQuantum
;
static
const
size_t
kChunkSize
=
1_MiB
;
static
const
size_t
kChunkSizeMask
=
kChunkSize
-
1
;
#
ifdef
MALLOC_STATIC_PAGESIZE
#
if
(
defined
(
SOLARIS
)
|
|
defined
(
__FreeBSD__
)
)
&
&
\
(
defined
(
__sparc
)
|
|
defined
(
__sparcv9
)
|
|
defined
(
__ia64
)
)
static
const
size_t
gPageSize
=
8_KiB
;
#
elif
defined
(
__powerpc64__
)
static
const
size_t
gPageSize
=
64_KiB
;
#
else
static
const
size_t
gPageSize
=
4_KiB
;
#
endif
#
else
static
size_t
gPageSize
;
#
endif
#
ifdef
MALLOC_STATIC_PAGESIZE
#
define
DECLARE_GLOBAL
(
type
name
)
#
define
DEFINE_GLOBALS
#
define
END_GLOBALS
#
define
DEFINE_GLOBAL
(
type
)
static
const
type
#
define
GLOBAL_LOG2
LOG2
#
define
GLOBAL_ASSERT_HELPER1
(
x
)
static_assert
(
x
#
x
)
#
define
GLOBAL_ASSERT_HELPER2
(
x
y
)
static_assert
(
x
y
)
#
define
GLOBAL_ASSERT
(
.
.
.
)
\
MACRO_CALL
(
\
MOZ_PASTE_PREFIX_AND_ARG_COUNT
(
GLOBAL_ASSERT_HELPER
__VA_ARGS__
)
\
(
__VA_ARGS__
)
)
#
else
#
define
DECLARE_GLOBAL
(
type
name
)
static
type
name
;
#
define
DEFINE_GLOBALS
\
static
void
DefineGlobals
(
)
\
{
#
define
END_GLOBALS
}
#
define
DEFINE_GLOBAL
(
type
)
#
define
GLOBAL_LOG2
FloorLog2
#
define
GLOBAL_ASSERT
MOZ_RELEASE_ASSERT
#
endif
DECLARE_GLOBAL
(
size_t
gMaxSubPageClass
)
DECLARE_GLOBAL
(
uint8_t
gNumSubPageClasses
)
DECLARE_GLOBAL
(
uint8_t
gPageSize2Pow
)
DECLARE_GLOBAL
(
size_t
gPageSizeMask
)
DECLARE_GLOBAL
(
size_t
gChunkNumPages
)
DECLARE_GLOBAL
(
size_t
gChunkHeaderNumPages
)
DECLARE_GLOBAL
(
size_t
gMaxLargeClass
)
DEFINE_GLOBALS
DEFINE_GLOBAL
(
size_t
)
gMaxSubPageClass
=
gPageSize
/
2
;
#
define
gMaxBinClass
gMaxSubPageClass
DEFINE_GLOBAL
(
uint8_t
)
gNumSubPageClasses
=
GLOBAL_LOG2
(
gMaxSubPageClass
)
-
LOG2
(
kMaxQuantumClass
)
;
DEFINE_GLOBAL
(
uint8_t
)
gPageSize2Pow
=
GLOBAL_LOG2
(
gPageSize
)
;
DEFINE_GLOBAL
(
size_t
)
gPageSizeMask
=
gPageSize
-
1
;
DEFINE_GLOBAL
(
size_t
)
gChunkNumPages
=
kChunkSize
>
>
gPageSize2Pow
;
DEFINE_GLOBAL
(
size_t
)
gChunkHeaderNumPages
=
(
(
sizeof
(
arena_chunk_t
)
+
sizeof
(
arena_chunk_map_t
)
*
(
gChunkNumPages
-
1
)
+
gPageSizeMask
)
&
~
gPageSizeMask
)
>
>
gPageSize2Pow
;
DEFINE_GLOBAL
(
size_t
)
gMaxLargeClass
=
kChunkSize
-
(
gChunkHeaderNumPages
<
<
gPageSize2Pow
)
;
GLOBAL_ASSERT
(
1ULL
<
<
gPageSize2Pow
=
=
gPageSize
"
Page
size
is
not
a
power
of
two
"
)
;
GLOBAL_ASSERT
(
kQuantum
>
=
sizeof
(
void
*
)
)
;
GLOBAL_ASSERT
(
kQuantum
<
=
gPageSize
)
;
GLOBAL_ASSERT
(
kChunkSize
>
=
gPageSize
)
;
GLOBAL_ASSERT
(
kQuantum
*
4
<
=
kChunkSize
)
;
END_GLOBALS
static
const
size_t
gRecycleLimit
=
128_MiB
;
static
Atomic
<
size_t
ReleaseAcquire
recordreplay
:
:
Behavior
:
:
DontPreserve
>
gRecycledSize
;
#
define
DIRTY_MAX_DEFAULT
(
1U
<
<
8
)
static
size_t
opt_dirty_max
=
DIRTY_MAX_DEFAULT
;
#
define
CHUNK_CEILING
(
s
)
(
(
(
s
)
+
kChunkSizeMask
)
&
~
kChunkSizeMask
)
#
define
CACHELINE_CEILING
(
s
)
\
(
(
(
s
)
+
(
kCacheLineSize
-
1
)
)
&
~
(
kCacheLineSize
-
1
)
)
#
define
QUANTUM_CEILING
(
a
)
(
(
(
a
)
+
(
kQuantumMask
)
)
&
~
(
kQuantumMask
)
)
#
define
PAGE_CEILING
(
s
)
(
(
(
s
)
+
gPageSizeMask
)
&
~
gPageSizeMask
)
#
if
defined
(
MALLOC_DECOMMIT
)
&
&
defined
(
MALLOC_DOUBLE_PURGE
)
#
error
MALLOC_DECOMMIT
and
MALLOC_DOUBLE_PURGE
are
mutually
exclusive
.
#
endif
static
void
*
base_alloc
(
size_t
aSize
)
;
#
if
defined
(
_MSC_VER
)
&
&
!
defined
(
__clang__
)
static
bool
malloc_initialized
;
#
else
static
Atomic
<
bool
SequentiallyConsistent
recordreplay
:
:
Behavior
:
:
DontPreserve
>
malloc_initialized
;
#
endif
static
StaticMutex
gInitLock
=
{
STATIC_MUTEX_INIT
}
;
struct
arena_stats_t
{
size_t
mapped
;
size_t
committed
;
size_t
allocated_small
;
size_t
allocated_large
;
}
;
enum
ChunkType
{
UNKNOWN_CHUNK
ZEROED_CHUNK
ARENA_CHUNK
HUGE_CHUNK
RECYCLED_CHUNK
}
;
struct
extent_node_t
{
RedBlackTreeNode
<
extent_node_t
>
mLinkBySize
;
RedBlackTreeNode
<
extent_node_t
>
mLinkByAddr
;
void
*
mAddr
;
size_t
mSize
;
union
{
ChunkType
mChunkType
;
arena_t
*
mArena
;
}
;
}
;
struct
ExtentTreeSzTrait
{
static
RedBlackTreeNode
<
extent_node_t
>
&
GetTreeNode
(
extent_node_t
*
aThis
)
{
return
aThis
-
>
mLinkBySize
;
}
static
inline
Order
Compare
(
extent_node_t
*
aNode
extent_node_t
*
aOther
)
{
Order
ret
=
CompareInt
(
aNode
-
>
mSize
aOther
-
>
mSize
)
;
return
(
ret
!
=
Order
:
:
eEqual
)
?
ret
:
CompareAddr
(
aNode
-
>
mAddr
aOther
-
>
mAddr
)
;
}
}
;
struct
ExtentTreeTrait
{
static
RedBlackTreeNode
<
extent_node_t
>
&
GetTreeNode
(
extent_node_t
*
aThis
)
{
return
aThis
-
>
mLinkByAddr
;
}
static
inline
Order
Compare
(
extent_node_t
*
aNode
extent_node_t
*
aOther
)
{
return
CompareAddr
(
aNode
-
>
mAddr
aOther
-
>
mAddr
)
;
}
}
;
struct
ExtentTreeBoundsTrait
:
public
ExtentTreeTrait
{
static
inline
Order
Compare
(
extent_node_t
*
aKey
extent_node_t
*
aNode
)
{
uintptr_t
key_addr
=
reinterpret_cast
<
uintptr_t
>
(
aKey
-
>
mAddr
)
;
uintptr_t
node_addr
=
reinterpret_cast
<
uintptr_t
>
(
aNode
-
>
mAddr
)
;
size_t
node_size
=
aNode
-
>
mSize
;
if
(
node_addr
<
=
key_addr
&
&
key_addr
<
node_addr
+
node_size
)
{
return
Order
:
:
eEqual
;
}
return
CompareAddr
(
aKey
-
>
mAddr
aNode
-
>
mAddr
)
;
}
}
;
class
SizeClass
{
public
:
enum
ClassType
{
Tiny
Quantum
SubPage
Large
}
;
explicit
inline
SizeClass
(
size_t
aSize
)
{
if
(
aSize
<
=
kMaxTinyClass
)
{
mType
=
Tiny
;
mSize
=
std
:
:
max
(
RoundUpPow2
(
aSize
)
kMinTinyClass
)
;
}
else
if
(
aSize
<
=
kMaxQuantumClass
)
{
mType
=
Quantum
;
mSize
=
QUANTUM_CEILING
(
aSize
)
;
}
else
if
(
aSize
<
=
gMaxSubPageClass
)
{
mType
=
SubPage
;
mSize
=
RoundUpPow2
(
aSize
)
;
}
else
if
(
aSize
<
=
gMaxLargeClass
)
{
mType
=
Large
;
mSize
=
PAGE_CEILING
(
aSize
)
;
}
else
{
MOZ_MAKE_COMPILER_ASSUME_IS_UNREACHABLE
(
"
Invalid
size
"
)
;
}
}
SizeClass
&
operator
=
(
const
SizeClass
&
aOther
)
=
default
;
bool
operator
=
=
(
const
SizeClass
&
aOther
)
{
return
aOther
.
mSize
=
=
mSize
;
}
size_t
Size
(
)
{
return
mSize
;
}
ClassType
Type
(
)
{
return
mType
;
}
SizeClass
Next
(
)
{
return
SizeClass
(
mSize
+
1
)
;
}
private
:
ClassType
mType
;
size_t
mSize
;
}
;
template
<
size_t
Bits
>
class
AddressRadixTree
{
#
ifdef
HAVE_64BIT_BUILD
static
const
size_t
kNodeSize
=
kCacheLineSize
;
#
else
static
const
size_t
kNodeSize
=
16_KiB
;
#
endif
static
const
size_t
kBitsPerLevel
=
LOG2
(
kNodeSize
)
-
LOG2
(
sizeof
(
void
*
)
)
;
static
const
size_t
kBitsAtLevel1
=
(
Bits
%
kBitsPerLevel
)
?
Bits
%
kBitsPerLevel
:
kBitsPerLevel
;
static
const
size_t
kHeight
=
(
Bits
+
kBitsPerLevel
-
1
)
/
kBitsPerLevel
;
static_assert
(
kBitsAtLevel1
+
(
kHeight
-
1
)
*
kBitsPerLevel
=
=
Bits
"
AddressRadixTree
parameters
don
'
t
work
out
"
)
;
Mutex
mLock
;
void
*
*
mRoot
;
public
:
bool
Init
(
)
;
inline
void
*
Get
(
void
*
aAddr
)
;
inline
bool
Set
(
void
*
aAddr
void
*
aValue
)
;
inline
bool
Unset
(
void
*
aAddr
)
{
return
Set
(
aAddr
nullptr
)
;
}
private
:
inline
void
*
*
GetSlot
(
void
*
aAddr
bool
aCreate
=
false
)
;
}
;
struct
arena_bin_t
;
struct
ArenaChunkMapLink
{
static
RedBlackTreeNode
<
arena_chunk_map_t
>
&
GetTreeNode
(
arena_chunk_map_t
*
aThis
)
{
return
aThis
-
>
link
;
}
}
;
struct
ArenaRunTreeTrait
:
public
ArenaChunkMapLink
{
static
inline
Order
Compare
(
arena_chunk_map_t
*
aNode
arena_chunk_map_t
*
aOther
)
{
MOZ_ASSERT
(
aNode
)
;
MOZ_ASSERT
(
aOther
)
;
return
CompareAddr
(
aNode
aOther
)
;
}
}
;
struct
ArenaAvailTreeTrait
:
public
ArenaChunkMapLink
{
static
inline
Order
Compare
(
arena_chunk_map_t
*
aNode
arena_chunk_map_t
*
aOther
)
{
size_t
size1
=
aNode
-
>
bits
&
~
gPageSizeMask
;
size_t
size2
=
aOther
-
>
bits
&
~
gPageSizeMask
;
Order
ret
=
CompareInt
(
size1
size2
)
;
return
(
ret
!
=
Order
:
:
eEqual
)
?
ret
:
CompareAddr
(
(
aNode
-
>
bits
&
CHUNK_MAP_KEY
)
?
nullptr
:
aNode
aOther
)
;
}
}
;
struct
ArenaDirtyChunkTrait
{
static
RedBlackTreeNode
<
arena_chunk_t
>
&
GetTreeNode
(
arena_chunk_t
*
aThis
)
{
return
aThis
-
>
link_dirty
;
}
static
inline
Order
Compare
(
arena_chunk_t
*
aNode
arena_chunk_t
*
aOther
)
{
MOZ_ASSERT
(
aNode
)
;
MOZ_ASSERT
(
aOther
)
;
return
CompareAddr
(
aNode
aOther
)
;
}
}
;
#
ifdef
MALLOC_DOUBLE_PURGE
namespace
mozilla
{
template
<
>
struct
GetDoublyLinkedListElement
<
arena_chunk_t
>
{
static
DoublyLinkedListElement
<
arena_chunk_t
>
&
Get
(
arena_chunk_t
*
aThis
)
{
return
aThis
-
>
chunks_madvised_elem
;
}
}
;
}
#
endif
struct
arena_run_t
{
#
if
defined
(
MOZ_DIAGNOSTIC_ASSERT_ENABLED
)
uint32_t
mMagic
;
#
define
ARENA_RUN_MAGIC
0x384adf93
unsigned
mNumFree
;
#
endif
arena_bin_t
*
mBin
;
unsigned
mRegionsMinElement
;
#
if
!
defined
(
MOZ_DIAGNOSTIC_ASSERT_ENABLED
)
unsigned
mNumFree
;
#
endif
unsigned
mRegionsMask
[
1
]
;
}
;
struct
arena_bin_t
{
arena_run_t
*
mCurrentRun
;
RedBlackTree
<
arena_chunk_map_t
ArenaRunTreeTrait
>
mNonFullRuns
;
size_t
mSizeClass
;
size_t
mRunSize
;
uint32_t
mRunNumRegions
;
uint32_t
mRunNumRegionsMask
;
uint32_t
mRunFirstRegionOffset
;
unsigned
long
mNumRuns
;
static
constexpr
double
kRunOverhead
=
1
.
6_percent
;
static
constexpr
double
kRunRelaxedOverhead
=
2
.
4_percent
;
inline
void
Init
(
SizeClass
aSizeClass
)
;
}
;
struct
arena_t
{
#
if
defined
(
MOZ_DIAGNOSTIC_ASSERT_ENABLED
)
uint32_t
mMagic
;
#
define
ARENA_MAGIC
0x947d3d24
#
endif
arena_id_t
mId
;
RedBlackTreeNode
<
arena_t
>
mLink
;
Mutex
mLock
;
arena_stats_t
mStats
;
private
:
RedBlackTree
<
arena_chunk_t
ArenaDirtyChunkTrait
>
mChunksDirty
;
#
ifdef
MALLOC_DOUBLE_PURGE
DoublyLinkedList
<
arena_chunk_t
>
mChunksMAdvised
;
#
endif
arena_chunk_t
*
mSpare
;
public
:
size_t
mNumDirty
;
size_t
mMaxDirty
;
private
:
RedBlackTree
<
arena_chunk_map_t
ArenaAvailTreeTrait
>
mRunsAvail
;
public
:
arena_bin_t
mBins
[
1
]
;
explicit
arena_t
(
arena_params_t
*
aParams
)
;
private
:
void
InitChunk
(
arena_chunk_t
*
aChunk
bool
aZeroed
)
;
void
DeallocChunk
(
arena_chunk_t
*
aChunk
)
;
arena_run_t
*
AllocRun
(
size_t
aSize
bool
aLarge
bool
aZero
)
;
void
DallocRun
(
arena_run_t
*
aRun
bool
aDirty
)
;
MOZ_MUST_USE
bool
SplitRun
(
arena_run_t
*
aRun
size_t
aSize
bool
aLarge
bool
aZero
)
;
void
TrimRunHead
(
arena_chunk_t
*
aChunk
arena_run_t
*
aRun
size_t
aOldSize
size_t
aNewSize
)
;
void
TrimRunTail
(
arena_chunk_t
*
aChunk
arena_run_t
*
aRun
size_t
aOldSize
size_t
aNewSize
bool
dirty
)
;
arena_run_t
*
GetNonFullBinRun
(
arena_bin_t
*
aBin
)
;
inline
void
*
MallocSmall
(
size_t
aSize
bool
aZero
)
;
void
*
MallocLarge
(
size_t
aSize
bool
aZero
)
;
void
*
MallocHuge
(
size_t
aSize
bool
aZero
)
;
void
*
PallocLarge
(
size_t
aAlignment
size_t
aSize
size_t
aAllocSize
)
;
void
*
PallocHuge
(
size_t
aSize
size_t
aAlignment
bool
aZero
)
;
void
RallocShrinkLarge
(
arena_chunk_t
*
aChunk
void
*
aPtr
size_t
aSize
size_t
aOldSize
)
;
bool
RallocGrowLarge
(
arena_chunk_t
*
aChunk
void
*
aPtr
size_t
aSize
size_t
aOldSize
)
;
void
*
RallocSmallOrLarge
(
void
*
aPtr
size_t
aSize
size_t
aOldSize
)
;
void
*
RallocHuge
(
void
*
aPtr
size_t
aSize
size_t
aOldSize
)
;
public
:
inline
void
*
Malloc
(
size_t
aSize
bool
aZero
)
;
void
*
Palloc
(
size_t
aAlignment
size_t
aSize
)
;
inline
void
DallocSmall
(
arena_chunk_t
*
aChunk
void
*
aPtr
arena_chunk_map_t
*
aMapElm
)
;
void
DallocLarge
(
arena_chunk_t
*
aChunk
void
*
aPtr
)
;
void
*
Ralloc
(
void
*
aPtr
size_t
aSize
size_t
aOldSize
)
;
void
Purge
(
bool
aAll
)
;
void
HardPurge
(
)
;
void
*
operator
new
(
size_t
aCount
)
=
delete
;
void
*
operator
new
(
size_t
aCount
const
fallible_t
&
)
#
if
!
defined
(
_MSC_VER
)
|
|
defined
(
_CPPUNWIND
)
noexcept
#
endif
{
MOZ_ASSERT
(
aCount
=
=
sizeof
(
arena_t
)
)
;
return
base_alloc
(
aCount
+
(
sizeof
(
arena_bin_t
)
*
(
kNumTinyClasses
+
kNumQuantumClasses
+
gNumSubPageClasses
-
1
)
)
)
;
}
void
operator
delete
(
void
*
)
=
delete
;
}
;
struct
ArenaTreeTrait
{
static
RedBlackTreeNode
<
arena_t
>
&
GetTreeNode
(
arena_t
*
aThis
)
{
return
aThis
-
>
mLink
;
}
static
inline
Order
Compare
(
arena_t
*
aNode
arena_t
*
aOther
)
{
MOZ_ASSERT
(
aNode
)
;
MOZ_ASSERT
(
aOther
)
;
return
CompareInt
(
aNode
-
>
mId
aOther
-
>
mId
)
;
}
}
;
class
ArenaCollection
{
public
:
bool
Init
(
)
{
mArenas
.
Init
(
)
;
mPrivateArenas
.
Init
(
)
;
arena_params_t
params
;
params
.
mMaxDirty
=
opt_dirty_max
;
mDefaultArena
=
mLock
.
Init
(
)
?
CreateArena
(
false
&
params
)
:
nullptr
;
return
bool
(
mDefaultArena
)
;
}
inline
arena_t
*
GetById
(
arena_id_t
aArenaId
bool
aIsPrivate
)
;
arena_t
*
CreateArena
(
bool
aIsPrivate
arena_params_t
*
aParams
)
;
void
DisposeArena
(
arena_t
*
aArena
)
{
MutexAutoLock
lock
(
mLock
)
;
(
mPrivateArenas
.
Search
(
aArena
)
?
mPrivateArenas
:
mArenas
)
.
Remove
(
aArena
)
;
}
using
Tree
=
RedBlackTree
<
arena_t
ArenaTreeTrait
>
;
struct
Iterator
:
Tree
:
:
Iterator
{
explicit
Iterator
(
Tree
*
aTree
Tree
*
aSecondTree
)
:
Tree
:
:
Iterator
(
aTree
)
mNextTree
(
aSecondTree
)
{
}
Item
<
Iterator
>
begin
(
)
{
return
Item
<
Iterator
>
(
this
*
Tree
:
:
Iterator
:
:
begin
(
)
)
;
}
Item
<
Iterator
>
end
(
)
{
return
Item
<
Iterator
>
(
this
nullptr
)
;
}
arena_t
*
Next
(
)
{
arena_t
*
result
=
Tree
:
:
Iterator
:
:
Next
(
)
;
if
(
!
result
&
&
mNextTree
)
{
new
(
this
)
Iterator
(
mNextTree
nullptr
)
;
result
=
*
Tree
:
:
Iterator
:
:
begin
(
)
;
}
return
result
;
}
private
:
Tree
*
mNextTree
;
}
;
Iterator
iter
(
)
{
return
Iterator
(
&
mArenas
&
mPrivateArenas
)
;
}
inline
arena_t
*
GetDefault
(
)
{
return
mDefaultArena
;
}
Mutex
mLock
;
private
:
arena_t
*
mDefaultArena
;
arena_id_t
mLastArenaId
;
Tree
mArenas
;
Tree
mPrivateArenas
;
}
;
static
ArenaCollection
gArenas
;
static
AddressRadixTree
<
(
sizeof
(
void
*
)
<
<
3
)
-
LOG2
(
kChunkSize
)
>
gChunkRTree
;
static
Mutex
chunks_mtx
;
static
RedBlackTree
<
extent_node_t
ExtentTreeSzTrait
>
gChunksBySize
;
static
RedBlackTree
<
extent_node_t
ExtentTreeTrait
>
gChunksByAddress
;
static
Mutex
huge_mtx
;
static
RedBlackTree
<
extent_node_t
ExtentTreeTrait
>
huge
;
static
size_t
huge_allocated
;
static
size_t
huge_mapped
;
static
void
*
base_pages
;
static
void
*
base_next_addr
;
static
void
*
base_next_decommitted
;
static
void
*
base_past_addr
;
static
extent_node_t
*
base_nodes
;
static
Mutex
base_mtx
;
static
size_t
base_mapped
;
static
size_t
base_committed
;
#
if
!
defined
(
XP_DARWIN
)
static
MOZ_THREAD_LOCAL
(
arena_t
*
)
thread_arena
;
#
else
static
detail
:
:
ThreadLocal
<
arena_t
*
detail
:
:
ThreadLocalKeyStorage
>
thread_arena
;
#
endif
const
uint8_t
kAllocJunk
=
0xe4
;
const
uint8_t
kAllocPoison
=
0xe5
;
#
ifdef
MOZ_DEBUG
static
bool
opt_junk
=
true
;
static
bool
opt_zero
=
false
;
#
else
static
const
bool
opt_junk
=
false
;
static
const
bool
opt_zero
=
false
;
#
endif
static
void
*
chunk_alloc
(
size_t
aSize
size_t
aAlignment
bool
aBase
bool
*
aZeroed
=
nullptr
)
;
static
void
chunk_dealloc
(
void
*
aChunk
size_t
aSize
ChunkType
aType
)
;
static
void
chunk_ensure_zero
(
void
*
aPtr
size_t
aSize
bool
aZeroed
)
;
static
void
huge_dalloc
(
void
*
aPtr
arena_t
*
aArena
)
;
static
bool
malloc_init_hard
(
)
;
#
ifdef
XP_DARWIN
#
define
FORK_HOOK
extern
"
C
"
#
else
#
define
FORK_HOOK
static
#
endif
FORK_HOOK
void
_malloc_prefork
(
void
)
;
FORK_HOOK
void
_malloc_postfork_parent
(
void
)
;
FORK_HOOK
void
_malloc_postfork_child
(
void
)
;
static
inline
bool
malloc_init
(
)
{
if
(
malloc_initialized
=
=
false
)
{
return
malloc_init_hard
(
)
;
}
return
true
;
}
static
void
_malloc_message
(
const
char
*
p
)
{
#
if
!
defined
(
XP_WIN
)
#
define
_write
write
#
endif
if
(
_write
(
STDERR_FILENO
p
(
unsigned
int
)
strlen
(
p
)
)
<
0
)
{
return
;
}
}
template
<
typename
.
.
.
Args
>
static
void
_malloc_message
(
const
char
*
p
Args
.
.
.
args
)
{
_malloc_message
(
p
)
;
_malloc_message
(
args
.
.
.
)
;
}
#
ifdef
ANDROID
extern
"
C
"
MOZ_EXPORT
int
pthread_atfork
(
void
(
*
)
(
void
)
void
(
*
)
(
void
)
void
(
*
)
(
void
)
)
;
#
endif
static
inline
arena_chunk_t
*
GetChunkForPtr
(
const
void
*
aPtr
)
{
return
(
arena_chunk_t
*
)
(
uintptr_t
(
aPtr
)
&
~
kChunkSizeMask
)
;
}
static
inline
size_t
GetChunkOffsetForPtr
(
const
void
*
aPtr
)
{
return
(
size_t
)
(
uintptr_t
(
aPtr
)
&
kChunkSizeMask
)
;
}
static
inline
const
char
*
_getprogname
(
void
)
{
return
"
<
jemalloc
>
"
;
}
static
inline
void
ApplyZeroOrJunk
(
void
*
aPtr
size_t
aSize
)
{
if
(
opt_junk
)
{
memset
(
aPtr
kAllocJunk
aSize
)
;
}
else
if
(
opt_zero
)
{
memset
(
aPtr
0
aSize
)
;
}
}
static
inline
void
pages_decommit
(
void
*
aAddr
size_t
aSize
)
{
#
ifdef
XP_WIN
size_t
pages_size
=
std
:
:
min
(
aSize
kChunkSize
-
GetChunkOffsetForPtr
(
aAddr
)
)
;
while
(
aSize
>
0
)
{
if
(
!
VirtualFree
(
aAddr
pages_size
MEM_DECOMMIT
)
)
{
MOZ_CRASH
(
)
;
}
aAddr
=
(
void
*
)
(
(
uintptr_t
)
aAddr
+
pages_size
)
;
aSize
-
=
pages_size
;
pages_size
=
std
:
:
min
(
aSize
kChunkSize
)
;
}
#
else
if
(
mmap
(
aAddr
aSize
PROT_NONE
MAP_FIXED
|
MAP_PRIVATE
|
MAP_ANON
-
1
0
)
=
=
MAP_FAILED
)
{
MOZ_CRASH
(
)
;
}
MozTagAnonymousMemory
(
aAddr
aSize
"
jemalloc
-
decommitted
"
)
;
#
endif
}
MOZ_MUST_USE
static
inline
bool
pages_commit
(
void
*
aAddr
size_t
aSize
)
{
#
ifdef
XP_WIN
size_t
pages_size
=
std
:
:
min
(
aSize
kChunkSize
-
GetChunkOffsetForPtr
(
aAddr
)
)
;
while
(
aSize
>
0
)
{
if
(
!
VirtualAlloc
(
aAddr
pages_size
MEM_COMMIT
PAGE_READWRITE
)
)
{
return
false
;
}
aAddr
=
(
void
*
)
(
(
uintptr_t
)
aAddr
+
pages_size
)
;
aSize
-
=
pages_size
;
pages_size
=
std
:
:
min
(
aSize
kChunkSize
)
;
}
#
else
if
(
mmap
(
aAddr
aSize
PROT_READ
|
PROT_WRITE
MAP_FIXED
|
MAP_PRIVATE
|
MAP_ANON
-
1
0
)
=
=
MAP_FAILED
)
{
return
false
;
}
MozTagAnonymousMemory
(
aAddr
aSize
"
jemalloc
"
)
;
#
endif
return
true
;
}
static
bool
base_pages_alloc
(
size_t
minsize
)
{
size_t
csize
;
size_t
pminsize
;
MOZ_ASSERT
(
minsize
!
=
0
)
;
csize
=
CHUNK_CEILING
(
minsize
)
;
base_pages
=
chunk_alloc
(
csize
kChunkSize
true
)
;
if
(
!
base_pages
)
{
return
true
;
}
base_next_addr
=
base_pages
;
base_past_addr
=
(
void
*
)
(
(
uintptr_t
)
base_pages
+
csize
)
;
pminsize
=
PAGE_CEILING
(
minsize
)
;
base_next_decommitted
=
(
void
*
)
(
(
uintptr_t
)
base_pages
+
pminsize
)
;
#
if
defined
(
MALLOC_DECOMMIT
)
if
(
pminsize
<
csize
)
{
pages_decommit
(
base_next_decommitted
csize
-
pminsize
)
;
}
#
endif
base_mapped
+
=
csize
;
base_committed
+
=
pminsize
;
return
false
;
}
static
void
*
base_alloc
(
size_t
aSize
)
{
void
*
ret
;
size_t
csize
;
csize
=
CACHELINE_CEILING
(
aSize
)
;
MutexAutoLock
lock
(
base_mtx
)
;
if
(
(
uintptr_t
)
base_next_addr
+
csize
>
(
uintptr_t
)
base_past_addr
)
{
if
(
base_pages_alloc
(
csize
)
)
{
return
nullptr
;
}
}
ret
=
base_next_addr
;
base_next_addr
=
(
void
*
)
(
(
uintptr_t
)
base_next_addr
+
csize
)
;
if
(
(
uintptr_t
)
base_next_addr
>
(
uintptr_t
)
base_next_decommitted
)
{
void
*
pbase_next_addr
=
(
void
*
)
(
PAGE_CEILING
(
(
uintptr_t
)
base_next_addr
)
)
;
#
ifdef
MALLOC_DECOMMIT
if
(
!
pages_commit
(
base_next_decommitted
(
uintptr_t
)
pbase_next_addr
-
(
uintptr_t
)
base_next_decommitted
)
)
{
return
nullptr
;
}
#
endif
base_committed
+
=
(
uintptr_t
)
pbase_next_addr
-
(
uintptr_t
)
base_next_decommitted
;
base_next_decommitted
=
pbase_next_addr
;
}
return
ret
;
}
static
void
*
base_calloc
(
size_t
aNumber
size_t
aSize
)
{
void
*
ret
=
base_alloc
(
aNumber
*
aSize
)
;
if
(
ret
)
{
memset
(
ret
0
aNumber
*
aSize
)
;
}
return
ret
;
}
static
extent_node_t
*
base_node_alloc
(
void
)
{
extent_node_t
*
ret
;
base_mtx
.
Lock
(
)
;
if
(
base_nodes
)
{
ret
=
base_nodes
;
base_nodes
=
*
(
extent_node_t
*
*
)
ret
;
base_mtx
.
Unlock
(
)
;
}
else
{
base_mtx
.
Unlock
(
)
;
ret
=
(
extent_node_t
*
)
base_alloc
(
sizeof
(
extent_node_t
)
)
;
}
return
ret
;
}
static
void
base_node_dealloc
(
extent_node_t
*
aNode
)
{
MutexAutoLock
lock
(
base_mtx
)
;
*
(
extent_node_t
*
*
)
aNode
=
base_nodes
;
base_nodes
=
aNode
;
}
struct
BaseNodeFreePolicy
{
void
operator
(
)
(
extent_node_t
*
aPtr
)
{
base_node_dealloc
(
aPtr
)
;
}
}
;
using
UniqueBaseNode
=
UniquePtr
<
extent_node_t
BaseNodeFreePolicy
>
;
#
ifdef
XP_WIN
static
void
*
pages_map
(
void
*
aAddr
size_t
aSize
)
{
void
*
ret
=
nullptr
;
ret
=
VirtualAlloc
(
aAddr
aSize
MEM_COMMIT
|
MEM_RESERVE
PAGE_READWRITE
)
;
return
ret
;
}
static
void
pages_unmap
(
void
*
aAddr
size_t
aSize
)
{
if
(
VirtualFree
(
aAddr
0
MEM_RELEASE
)
=
=
0
)
{
_malloc_message
(
_getprogname
(
)
"
:
(
malloc
)
Error
in
VirtualFree
(
)
\
n
"
)
;
}
}
#
else
static
void
pages_unmap
(
void
*
aAddr
size_t
aSize
)
{
if
(
munmap
(
aAddr
aSize
)
=
=
-
1
)
{
char
buf
[
64
]
;
if
(
strerror_r
(
errno
buf
sizeof
(
buf
)
)
=
=
0
)
{
_malloc_message
(
_getprogname
(
)
"
:
(
malloc
)
Error
in
munmap
(
)
:
"
buf
"
\
n
"
)
;
}
}
}
static
void
*
pages_map
(
void
*
aAddr
size_t
aSize
)
{
void
*
ret
;
#
if
defined
(
__ia64__
)
|
|
\
(
defined
(
__sparc__
)
&
&
defined
(
__arch64__
)
&
&
defined
(
__linux__
)
)
bool
check_placement
=
true
;
if
(
!
aAddr
)
{
aAddr
=
(
void
*
)
0x0000070000000000
;
check_placement
=
false
;
}
#
endif
#
if
defined
(
__sparc__
)
&
&
defined
(
__arch64__
)
&
&
defined
(
__linux__
)
const
uintptr_t
start
=
0x0000070000000000ULL
;
const
uintptr_t
end
=
0x0000800000000000ULL
;
uintptr_t
hint
;
void
*
region
=
MAP_FAILED
;
for
(
hint
=
start
;
region
=
=
MAP_FAILED
&
&
hint
+
aSize
<
=
end
;
hint
+
=
kChunkSize
)
{
region
=
mmap
(
(
void
*
)
hint
aSize
PROT_READ
|
PROT_WRITE
MAP_PRIVATE
|
MAP_ANON
-
1
0
)
;
if
(
region
!
=
MAP_FAILED
)
{
if
(
(
(
size_t
)
region
+
(
aSize
-
1
)
)
&
0xffff800000000000
)
{
if
(
munmap
(
region
aSize
)
)
{
MOZ_ASSERT
(
errno
=
=
ENOMEM
)
;
}
region
=
MAP_FAILED
;
}
}
}
ret
=
region
;
#
else
ret
=
mmap
(
aAddr
aSize
PROT_READ
|
PROT_WRITE
MAP_PRIVATE
|
MAP_ANON
-
1
0
)
;
MOZ_ASSERT
(
ret
)
;
#
endif
if
(
ret
=
=
MAP_FAILED
)
{
ret
=
nullptr
;
}
#
if
defined
(
__ia64__
)
|
|
\
(
defined
(
__sparc__
)
&
&
defined
(
__arch64__
)
&
&
defined
(
__linux__
)
)
else
if
(
(
long
long
)
ret
&
0xffff800000000000
)
{
munmap
(
ret
aSize
)
;
ret
=
nullptr
;
}
else
if
(
check_placement
&
&
ret
!
=
aAddr
)
{
#
else
else
if
(
aAddr
&
&
ret
!
=
aAddr
)
{
#
endif
pages_unmap
(
ret
aSize
)
;
ret
=
nullptr
;
}
if
(
ret
)
{
MozTagAnonymousMemory
(
ret
aSize
"
jemalloc
"
)
;
}
#
if
defined
(
__ia64__
)
|
|
\
(
defined
(
__sparc__
)
&
&
defined
(
__arch64__
)
&
&
defined
(
__linux__
)
)
MOZ_ASSERT
(
!
ret
|
|
(
!
check_placement
&
&
ret
)
|
|
(
check_placement
&
&
ret
=
=
aAddr
)
)
;
#
else
MOZ_ASSERT
(
!
ret
|
|
(
!
aAddr
&
&
ret
!
=
aAddr
)
|
|
(
aAddr
&
&
ret
=
=
aAddr
)
)
;
#
endif
return
ret
;
}
#
endif
#
ifdef
XP_DARWIN
#
define
VM_COPY_MIN
(
gPageSize
*
32
)
static
inline
void
pages_copy
(
void
*
dest
const
void
*
src
size_t
n
)
{
MOZ_ASSERT
(
(
void
*
)
(
(
uintptr_t
)
dest
&
~
gPageSizeMask
)
=
=
dest
)
;
MOZ_ASSERT
(
n
>
=
VM_COPY_MIN
)
;
MOZ_ASSERT
(
(
void
*
)
(
(
uintptr_t
)
src
&
~
gPageSizeMask
)
=
=
src
)
;
kern_return_t
r
=
vm_copy
(
mach_task_self
(
)
(
vm_address_t
)
src
(
vm_size_t
)
n
(
vm_address_t
)
dest
)
;
if
(
r
!
=
KERN_SUCCESS
)
{
MOZ_CRASH
(
"
vm_copy
(
)
failed
"
)
;
}
}
#
endif
template
<
size_t
Bits
>
bool
AddressRadixTree
<
Bits
>
:
:
Init
(
)
{
mLock
.
Init
(
)
;
mRoot
=
(
void
*
*
)
base_calloc
(
1
<
<
kBitsAtLevel1
sizeof
(
void
*
)
)
;
return
mRoot
;
}
template
<
size_t
Bits
>
void
*
*
AddressRadixTree
<
Bits
>
:
:
GetSlot
(
void
*
aKey
bool
aCreate
)
{
uintptr_t
key
=
reinterpret_cast
<
uintptr_t
>
(
aKey
)
;
uintptr_t
subkey
;
unsigned
i
lshift
height
bits
;
void
*
*
node
;
void
*
*
child
;
for
(
i
=
lshift
=
0
height
=
kHeight
node
=
mRoot
;
i
<
height
-
1
;
i
+
+
lshift
+
=
bits
node
=
child
)
{
bits
=
i
?
kBitsPerLevel
:
kBitsAtLevel1
;
subkey
=
(
key
<
<
lshift
)
>
>
(
(
sizeof
(
void
*
)
<
<
3
)
-
bits
)
;
child
=
(
void
*
*
)
node
[
subkey
]
;
if
(
!
child
&
&
aCreate
)
{
child
=
(
void
*
*
)
base_calloc
(
1
<
<
kBitsPerLevel
sizeof
(
void
*
)
)
;
if
(
child
)
{
node
[
subkey
]
=
child
;
}
}
if
(
!
child
)
{
return
nullptr
;
}
}
bits
=
i
?
kBitsPerLevel
:
kBitsAtLevel1
;
subkey
=
(
key
<
<
lshift
)
>
>
(
(
sizeof
(
void
*
)
<
<
3
)
-
bits
)
;
return
&
node
[
subkey
]
;
}
template
<
size_t
Bits
>
void
*
AddressRadixTree
<
Bits
>
:
:
Get
(
void
*
aKey
)
{
void
*
ret
=
nullptr
;
void
*
*
slot
=
GetSlot
(
aKey
)
;
if
(
slot
)
{
ret
=
*
slot
;
}
#
ifdef
MOZ_DEBUG
MutexAutoLock
lock
(
mLock
)
;
if
(
!
slot
)
{
slot
=
GetSlot
(
aKey
)
;
}
if
(
slot
)
{
MOZ_ASSERT
(
ret
=
=
*
slot
)
;
}
else
{
MOZ_ASSERT
(
ret
=
=
nullptr
)
;
}
#
endif
return
ret
;
}
template
<
size_t
Bits
>
bool
AddressRadixTree
<
Bits
>
:
:
Set
(
void
*
aKey
void
*
aValue
)
{
MutexAutoLock
lock
(
mLock
)
;
void
*
*
slot
=
GetSlot
(
aKey
true
)
;
if
(
slot
)
{
*
slot
=
aValue
;
}
return
slot
;
}
#
define
ALIGNMENT_ADDR2OFFSET
(
a
alignment
)
\
(
(
size_t
)
(
(
uintptr_t
)
(
a
)
&
(
alignment
-
1
)
)
)
#
define
ALIGNMENT_CEILING
(
s
alignment
)
\
(
(
(
s
)
+
(
alignment
-
1
)
)
&
(
~
(
alignment
-
1
)
)
)
static
void
*
pages_trim
(
void
*
addr
size_t
alloc_size
size_t
leadsize
size_t
size
)
{
void
*
ret
=
(
void
*
)
(
(
uintptr_t
)
addr
+
leadsize
)
;
MOZ_ASSERT
(
alloc_size
>
=
leadsize
+
size
)
;
#
ifdef
XP_WIN
{
void
*
new_addr
;
pages_unmap
(
addr
alloc_size
)
;
new_addr
=
pages_map
(
ret
size
)
;
if
(
new_addr
=
=
ret
)
{
return
ret
;
}
if
(
new_addr
)
{
pages_unmap
(
new_addr
size
)
;
}
return
nullptr
;
}
#
else
{
size_t
trailsize
=
alloc_size
-
leadsize
-
size
;
if
(
leadsize
!
=
0
)
{
pages_unmap
(
addr
leadsize
)
;
}
if
(
trailsize
!
=
0
)
{
pages_unmap
(
(
void
*
)
(
(
uintptr_t
)
ret
+
size
)
trailsize
)
;
}
return
ret
;
}
#
endif
}
static
void
*
chunk_alloc_mmap_slow
(
size_t
size
size_t
alignment
)
{
void
*
ret
*
pages
;
size_t
alloc_size
leadsize
;
alloc_size
=
size
+
alignment
-
gPageSize
;
if
(
alloc_size
<
size
)
{
return
nullptr
;
}
do
{
pages
=
pages_map
(
nullptr
alloc_size
)
;
if
(
!
pages
)
{
return
nullptr
;
}
leadsize
=
ALIGNMENT_CEILING
(
(
uintptr_t
)
pages
alignment
)
-
(
uintptr_t
)
pages
;
ret
=
pages_trim
(
pages
alloc_size
leadsize
size
)
;
}
while
(
!
ret
)
;
MOZ_ASSERT
(
ret
)
;
return
ret
;
}
static
void
*
chunk_alloc_mmap
(
size_t
size
size_t
alignment
)
{
void
*
ret
;
size_t
offset
;
ret
=
pages_map
(
nullptr
size
)
;
if
(
!
ret
)
{
return
nullptr
;
}
offset
=
ALIGNMENT_ADDR2OFFSET
(
ret
alignment
)
;
if
(
offset
!
=
0
)
{
pages_unmap
(
ret
size
)
;
return
chunk_alloc_mmap_slow
(
size
alignment
)
;
}
MOZ_ASSERT
(
ret
)
;
return
ret
;
}
static
bool
pages_purge
(
void
*
addr
size_t
length
bool
force_zero
)
{
#
ifdef
MALLOC_DECOMMIT
pages_decommit
(
addr
length
)
;
return
true
;
#
else
#
ifndef
XP_LINUX
if
(
force_zero
)
{
memset
(
addr
0
length
)
;
}
#
endif
#
ifdef
XP_WIN
size_t
pages_size
=
std
:
:
min
(
length
kChunkSize
-
GetChunkOffsetForPtr
(
addr
)
)
;
while
(
length
>
0
)
{
VirtualAlloc
(
addr
pages_size
MEM_RESET
PAGE_READWRITE
)
;
addr
=
(
void
*
)
(
(
uintptr_t
)
addr
+
pages_size
)
;
length
-
=
pages_size
;
pages_size
=
std
:
:
min
(
length
kChunkSize
)
;
}
return
force_zero
;
#
else
#
ifdef
XP_LINUX
#
define
JEMALLOC_MADV_PURGE
MADV_DONTNEED
#
define
JEMALLOC_MADV_ZEROS
true
#
else
#
define
JEMALLOC_MADV_PURGE
MADV_FREE
#
define
JEMALLOC_MADV_ZEROS
force_zero
#
endif
int
err
=
madvise
(
addr
length
JEMALLOC_MADV_PURGE
)
;
return
JEMALLOC_MADV_ZEROS
&
&
err
=
=
0
;
#
undef
JEMALLOC_MADV_PURGE
#
undef
JEMALLOC_MADV_ZEROS
#
endif
#
endif
}
static
void
*
chunk_recycle
(
size_t
aSize
size_t
aAlignment
bool
*
aZeroed
)
{
extent_node_t
key
;
size_t
alloc_size
=
aSize
+
aAlignment
-
kChunkSize
;
if
(
alloc_size
<
aSize
)
{
return
nullptr
;
}
key
.
mAddr
=
nullptr
;
key
.
mSize
=
alloc_size
;
chunks_mtx
.
Lock
(
)
;
extent_node_t
*
node
=
gChunksBySize
.
SearchOrNext
(
&
key
)
;
if
(
!
node
)
{
chunks_mtx
.
Unlock
(
)
;
return
nullptr
;
}
size_t
leadsize
=
ALIGNMENT_CEILING
(
(
uintptr_t
)
node
-
>
mAddr
aAlignment
)
-
(
uintptr_t
)
node
-
>
mAddr
;
MOZ_ASSERT
(
node
-
>
mSize
>
=
leadsize
+
aSize
)
;
size_t
trailsize
=
node
-
>
mSize
-
leadsize
-
aSize
;
void
*
ret
=
(
void
*
)
(
(
uintptr_t
)
node
-
>
mAddr
+
leadsize
)
;
ChunkType
chunk_type
=
node
-
>
mChunkType
;
if
(
aZeroed
)
{
*
aZeroed
=
(
chunk_type
=
=
ZEROED_CHUNK
)
;
}
gChunksBySize
.
Remove
(
node
)
;
gChunksByAddress
.
Remove
(
node
)
;
if
(
leadsize
!
=
0
)
{
node
-
>
mSize
=
leadsize
;
gChunksBySize
.
Insert
(
node
)
;
gChunksByAddress
.
Insert
(
node
)
;
node
=
nullptr
;
}
if
(
trailsize
!
=
0
)
{
if
(
!
node
)
{
chunks_mtx
.
Unlock
(
)
;
node
=
base_node_alloc
(
)
;
if
(
!
node
)
{
chunk_dealloc
(
ret
aSize
chunk_type
)
;
return
nullptr
;
}
chunks_mtx
.
Lock
(
)
;
}
node
-
>
mAddr
=
(
void
*
)
(
(
uintptr_t
)
(
ret
)
+
aSize
)
;
node
-
>
mSize
=
trailsize
;
node
-
>
mChunkType
=
chunk_type
;
gChunksBySize
.
Insert
(
node
)
;
gChunksByAddress
.
Insert
(
node
)
;
node
=
nullptr
;
}
gRecycledSize
-
=
aSize
;
chunks_mtx
.
Unlock
(
)
;
if
(
node
)
{
base_node_dealloc
(
node
)
;
}
#
ifdef
MALLOC_DECOMMIT
if
(
!
pages_commit
(
ret
aSize
)
)
{
return
nullptr
;
}
if
(
aZeroed
)
{
*
aZeroed
=
true
;
}
#
endif
return
ret
;
}
#
ifdef
XP_WIN
#
define
CAN_RECYCLE
(
size
)
(
size
=
=
kChunkSize
)
#
else
#
define
CAN_RECYCLE
(
size
)
true
#
endif
static
void
*
chunk_alloc
(
size_t
aSize
size_t
aAlignment
bool
aBase
bool
*
aZeroed
)
{
void
*
ret
=
nullptr
;
MOZ_ASSERT
(
aSize
!
=
0
)
;
MOZ_ASSERT
(
(
aSize
&
kChunkSizeMask
)
=
=
0
)
;
MOZ_ASSERT
(
aAlignment
!
=
0
)
;
MOZ_ASSERT
(
(
aAlignment
&
kChunkSizeMask
)
=
=
0
)
;
if
(
CAN_RECYCLE
(
aSize
)
&
&
!
aBase
)
{
ret
=
chunk_recycle
(
aSize
aAlignment
aZeroed
)
;
}
if
(
!
ret
)
{
ret
=
chunk_alloc_mmap
(
aSize
aAlignment
)
;
if
(
aZeroed
)
{
*
aZeroed
=
true
;
}
}
if
(
ret
&
&
!
aBase
)
{
if
(
!
gChunkRTree
.
Set
(
ret
ret
)
)
{
chunk_dealloc
(
ret
aSize
UNKNOWN_CHUNK
)
;
return
nullptr
;
}
}
MOZ_ASSERT
(
GetChunkOffsetForPtr
(
ret
)
=
=
0
)
;
return
ret
;
}
static
void
chunk_ensure_zero
(
void
*
aPtr
size_t
aSize
bool
aZeroed
)
{
if
(
aZeroed
=
=
false
)
{
memset
(
aPtr
0
aSize
)
;
}
#
ifdef
MOZ_DEBUG
else
{
size_t
i
;
size_t
*
p
=
(
size_t
*
)
(
uintptr_t
)
aPtr
;
for
(
i
=
0
;
i
<
aSize
/
sizeof
(
size_t
)
;
i
+
+
)
{
MOZ_ASSERT
(
p
[
i
]
=
=
0
)
;
}
}
#
endif
}
static
void
chunk_record
(
void
*
aChunk
size_t
aSize
ChunkType
aType
)
{
extent_node_t
key
;
if
(
aType
!
=
ZEROED_CHUNK
)
{
if
(
pages_purge
(
aChunk
aSize
aType
=
=
HUGE_CHUNK
)
)
{
aType
=
ZEROED_CHUNK
;
}
}
UniqueBaseNode
xnode
(
base_node_alloc
(
)
)
;
UniqueBaseNode
xprev
;
MutexAutoLock
lock
(
chunks_mtx
)
;
key
.
mAddr
=
(
void
*
)
(
(
uintptr_t
)
aChunk
+
aSize
)
;
extent_node_t
*
node
=
gChunksByAddress
.
SearchOrNext
(
&
key
)
;
if
(
node
&
&
node
-
>
mAddr
=
=
key
.
mAddr
)
{
gChunksBySize
.
Remove
(
node
)
;
node
-
>
mAddr
=
aChunk
;
node
-
>
mSize
+
=
aSize
;
if
(
node
-
>
mChunkType
!
=
aType
)
{
node
-
>
mChunkType
=
RECYCLED_CHUNK
;
}
gChunksBySize
.
Insert
(
node
)
;
}
else
{
if
(
!
xnode
)
{
return
;
}
node
=
xnode
.
release
(
)
;
node
-
>
mAddr
=
aChunk
;
node
-
>
mSize
=
aSize
;
node
-
>
mChunkType
=
aType
;
gChunksByAddress
.
Insert
(
node
)
;
gChunksBySize
.
Insert
(
node
)
;
}
extent_node_t
*
prev
=
gChunksByAddress
.
Prev
(
node
)
;
if
(
prev
&
&
(
void
*
)
(
(
uintptr_t
)
prev
-
>
mAddr
+
prev
-
>
mSize
)
=
=
aChunk
)
{
gChunksBySize
.
Remove
(
prev
)
;
gChunksByAddress
.
Remove
(
prev
)
;
gChunksBySize
.
Remove
(
node
)
;
node
-
>
mAddr
=
prev
-
>
mAddr
;
node
-
>
mSize
+
=
prev
-
>
mSize
;
if
(
node
-
>
mChunkType
!
=
prev
-
>
mChunkType
)
{
node
-
>
mChunkType
=
RECYCLED_CHUNK
;
}
gChunksBySize
.
Insert
(
node
)
;
xprev
.
reset
(
prev
)
;
}
gRecycledSize
+
=
aSize
;
}
static
void
chunk_dealloc
(
void
*
aChunk
size_t
aSize
ChunkType
aType
)
{
MOZ_ASSERT
(
aChunk
)
;
MOZ_ASSERT
(
GetChunkOffsetForPtr
(
aChunk
)
=
=
0
)
;
MOZ_ASSERT
(
aSize
!
=
0
)
;
MOZ_ASSERT
(
(
aSize
&
kChunkSizeMask
)
=
=
0
)
;
gChunkRTree
.
Unset
(
aChunk
)
;
if
(
CAN_RECYCLE
(
aSize
)
)
{
size_t
recycled_so_far
=
gRecycledSize
;
if
(
recycled_so_far
<
gRecycleLimit
)
{
size_t
recycle_remaining
=
gRecycleLimit
-
recycled_so_far
;
size_t
to_recycle
;
if
(
aSize
>
recycle_remaining
)
{
to_recycle
=
recycle_remaining
;
pages_trim
(
aChunk
aSize
0
to_recycle
)
;
}
else
{
to_recycle
=
aSize
;
}
chunk_record
(
aChunk
to_recycle
aType
)
;
return
;
}
}
pages_unmap
(
aChunk
aSize
)
;
}
#
undef
CAN_RECYCLE
static
inline
arena_t
*
thread_local_arena
(
bool
enabled
)
{
arena_t
*
arena
;
if
(
enabled
)
{
arena
=
gArenas
.
CreateArena
(
false
nullptr
)
;
}
else
{
arena
=
gArenas
.
GetDefault
(
)
;
}
thread_arena
.
set
(
arena
)
;
return
arena
;
}
template
<
>
inline
void
MozJemalloc
:
:
jemalloc_thread_local_arena
(
bool
aEnabled
)
{
if
(
malloc_init
(
)
)
{
thread_local_arena
(
aEnabled
)
;
}
}
static
inline
arena_t
*
choose_arena
(
size_t
size
)
{
arena_t
*
ret
=
nullptr
;
if
(
size
>
kMaxQuantumClass
)
{
ret
=
gArenas
.
GetDefault
(
)
;
}
else
{
ret
=
thread_arena
.
get
(
)
;
if
(
!
ret
)
{
ret
=
thread_local_arena
(
false
)
;
}
}
MOZ_DIAGNOSTIC_ASSERT
(
ret
)
;
return
ret
;
}
static
inline
void
*
arena_run_reg_alloc
(
arena_run_t
*
run
arena_bin_t
*
bin
)
{
void
*
ret
;
unsigned
i
mask
bit
regind
;
MOZ_DIAGNOSTIC_ASSERT
(
run
-
>
mMagic
=
=
ARENA_RUN_MAGIC
)
;
MOZ_ASSERT
(
run
-
>
mRegionsMinElement
<
bin
-
>
mRunNumRegionsMask
)
;
i
=
run
-
>
mRegionsMinElement
;
mask
=
run
-
>
mRegionsMask
[
i
]
;
if
(
mask
!
=
0
)
{
bit
=
CountTrailingZeroes32
(
mask
)
;
regind
=
(
(
i
<
<
(
LOG2
(
sizeof
(
int
)
)
+
3
)
)
+
bit
)
;
MOZ_ASSERT
(
regind
<
bin
-
>
mRunNumRegions
)
;
ret
=
(
void
*
)
(
(
(
uintptr_t
)
run
)
+
bin
-
>
mRunFirstRegionOffset
+
(
bin
-
>
mSizeClass
*
regind
)
)
;
mask
^
=
(
1U
<
<
bit
)
;
run
-
>
mRegionsMask
[
i
]
=
mask
;
return
ret
;
}
for
(
i
+
+
;
i
<
bin
-
>
mRunNumRegionsMask
;
i
+
+
)
{
mask
=
run
-
>
mRegionsMask
[
i
]
;
if
(
mask
!
=
0
)
{
bit
=
CountTrailingZeroes32
(
mask
)
;
regind
=
(
(
i
<
<
(
LOG2
(
sizeof
(
int
)
)
+
3
)
)
+
bit
)
;
MOZ_ASSERT
(
regind
<
bin
-
>
mRunNumRegions
)
;
ret
=
(
void
*
)
(
(
(
uintptr_t
)
run
)
+
bin
-
>
mRunFirstRegionOffset
+
(
bin
-
>
mSizeClass
*
regind
)
)
;
mask
^
=
(
1U
<
<
bit
)
;
run
-
>
mRegionsMask
[
i
]
=
mask
;
run
-
>
mRegionsMinElement
=
i
;
return
ret
;
}
}
MOZ_DIAGNOSTIC_ASSERT
(
0
)
;
return
nullptr
;
}
static
inline
void
arena_run_reg_dalloc
(
arena_run_t
*
run
arena_bin_t
*
bin
void
*
ptr
size_t
size
)
{
#
define
SIZE_INV_SHIFT
21
#
define
SIZE_INV
(
s
)
(
(
(
1U
<
<
SIZE_INV_SHIFT
)
/
(
s
*
kQuantum
)
)
+
1
)
static
const
unsigned
size_invs
[
]
=
{
SIZE_INV
(
3
)
SIZE_INV
(
4
)
SIZE_INV
(
5
)
SIZE_INV
(
6
)
SIZE_INV
(
7
)
SIZE_INV
(
8
)
SIZE_INV
(
9
)
SIZE_INV
(
10
)
SIZE_INV
(
11
)
SIZE_INV
(
12
)
SIZE_INV
(
13
)
SIZE_INV
(
14
)
SIZE_INV
(
15
)
SIZE_INV
(
16
)
SIZE_INV
(
17
)
SIZE_INV
(
18
)
SIZE_INV
(
19
)
SIZE_INV
(
20
)
SIZE_INV
(
21
)
SIZE_INV
(
22
)
SIZE_INV
(
23
)
SIZE_INV
(
24
)
SIZE_INV
(
25
)
SIZE_INV
(
26
)
SIZE_INV
(
27
)
SIZE_INV
(
28
)
SIZE_INV
(
29
)
SIZE_INV
(
30
)
SIZE_INV
(
31
)
}
;
unsigned
diff
regind
elm
bit
;
MOZ_DIAGNOSTIC_ASSERT
(
run
-
>
mMagic
=
=
ARENA_RUN_MAGIC
)
;
static_assert
(
(
(
sizeof
(
size_invs
)
)
/
sizeof
(
unsigned
)
)
+
3
>
=
kNumQuantumClasses
"
size_invs
doesn
'
t
have
enough
values
"
)
;
diff
=
(
unsigned
)
(
(
uintptr_t
)
ptr
-
(
uintptr_t
)
run
-
bin
-
>
mRunFirstRegionOffset
)
;
if
(
mozilla
:
:
IsPowerOfTwo
(
size
)
)
{
regind
=
diff
>
>
FloorLog2
(
size
)
;
}
else
if
(
size
<
=
(
(
sizeof
(
size_invs
)
/
sizeof
(
unsigned
)
)
*
kQuantum
)
+
2
)
{
regind
=
size_invs
[
(
size
/
kQuantum
)
-
3
]
*
diff
;
regind
>
>
=
SIZE_INV_SHIFT
;
}
else
{
regind
=
diff
/
size
;
}
;
MOZ_DIAGNOSTIC_ASSERT
(
diff
=
=
regind
*
size
)
;
MOZ_DIAGNOSTIC_ASSERT
(
regind
<
bin
-
>
mRunNumRegions
)
;
elm
=
regind
>
>
(
LOG2
(
sizeof
(
int
)
)
+
3
)
;
if
(
elm
<
run
-
>
mRegionsMinElement
)
{
run
-
>
mRegionsMinElement
=
elm
;
}
bit
=
regind
-
(
elm
<
<
(
LOG2
(
sizeof
(
int
)
)
+
3
)
)
;
MOZ_RELEASE_ASSERT
(
(
run
-
>
mRegionsMask
[
elm
]
&
(
1U
<
<
bit
)
)
=
=
0
"
Double
-
free
?
"
)
;
run
-
>
mRegionsMask
[
elm
]
|
=
(
1U
<
<
bit
)
;
#
undef
SIZE_INV
#
undef
SIZE_INV_SHIFT
}
bool
arena_t
:
:
SplitRun
(
arena_run_t
*
aRun
size_t
aSize
bool
aLarge
bool
aZero
)
{
arena_chunk_t
*
chunk
;
size_t
old_ndirty
run_ind
total_pages
need_pages
rem_pages
i
;
chunk
=
GetChunkForPtr
(
aRun
)
;
old_ndirty
=
chunk
-
>
ndirty
;
run_ind
=
(
unsigned
)
(
(
uintptr_t
(
aRun
)
-
uintptr_t
(
chunk
)
)
>
>
gPageSize2Pow
)
;
total_pages
=
(
chunk
-
>
map
[
run_ind
]
.
bits
&
~
gPageSizeMask
)
>
>
gPageSize2Pow
;
need_pages
=
(
aSize
>
>
gPageSize2Pow
)
;
MOZ_ASSERT
(
need_pages
>
0
)
;
MOZ_ASSERT
(
need_pages
<
=
total_pages
)
;
rem_pages
=
total_pages
-
need_pages
;
for
(
i
=
0
;
i
<
need_pages
;
i
+
+
)
{
if
(
chunk
-
>
map
[
run_ind
+
i
]
.
bits
&
CHUNK_MAP_MADVISED_OR_DECOMMITTED
)
{
size_t
j
;
for
(
j
=
0
;
i
+
j
<
need_pages
&
&
(
chunk
-
>
map
[
run_ind
+
i
+
j
]
.
bits
&
CHUNK_MAP_MADVISED_OR_DECOMMITTED
)
;
j
+
+
)
{
MOZ_ASSERT
(
!
(
chunk
-
>
map
[
run_ind
+
i
+
j
]
.
bits
&
CHUNK_MAP_DECOMMITTED
&
&
chunk
-
>
map
[
run_ind
+
i
+
j
]
.
bits
&
CHUNK_MAP_MADVISED
)
)
;
chunk
-
>
map
[
run_ind
+
i
+
j
]
.
bits
&
=
~
CHUNK_MAP_MADVISED_OR_DECOMMITTED
;
}
#
ifdef
MALLOC_DECOMMIT
bool
committed
=
pages_commit
(
(
void
*
)
(
uintptr_t
(
chunk
)
+
(
(
run_ind
+
i
)
<
<
gPageSize2Pow
)
)
j
<
<
gPageSize2Pow
)
;
for
(
size_t
k
=
0
;
k
<
j
;
k
+
+
)
{
chunk
-
>
map
[
run_ind
+
i
+
k
]
.
bits
|
=
committed
?
CHUNK_MAP_ZEROED
:
CHUNK_MAP_DECOMMITTED
;
}
if
(
!
committed
)
{
return
false
;
}
#
endif
mStats
.
committed
+
=
j
;
}
}
mRunsAvail
.
Remove
(
&
chunk
-
>
map
[
run_ind
]
)
;
if
(
rem_pages
>
0
)
{
chunk
-
>
map
[
run_ind
+
need_pages
]
.
bits
=
(
rem_pages
<
<
gPageSize2Pow
)
|
(
chunk
-
>
map
[
run_ind
+
need_pages
]
.
bits
&
gPageSizeMask
)
;
chunk
-
>
map
[
run_ind
+
total_pages
-
1
]
.
bits
=
(
rem_pages
<
<
gPageSize2Pow
)
|
(
chunk
-
>
map
[
run_ind
+
total_pages
-
1
]
.
bits
&
gPageSizeMask
)
;
mRunsAvail
.
Insert
(
&
chunk
-
>
map
[
run_ind
+
need_pages
]
)
;
}
for
(
i
=
0
;
i
<
need_pages
;
i
+
+
)
{
if
(
aZero
)
{
if
(
(
chunk
-
>
map
[
run_ind
+
i
]
.
bits
&
CHUNK_MAP_ZEROED
)
=
=
0
)
{
memset
(
(
void
*
)
(
uintptr_t
(
chunk
)
+
(
(
run_ind
+
i
)
<
<
gPageSize2Pow
)
)
0
gPageSize
)
;
}
}
if
(
chunk
-
>
map
[
run_ind
+
i
]
.
bits
&
CHUNK_MAP_DIRTY
)
{
chunk
-
>
ndirty
-
-
;
mNumDirty
-
-
;
}
if
(
aLarge
)
{
chunk
-
>
map
[
run_ind
+
i
]
.
bits
=
CHUNK_MAP_LARGE
|
CHUNK_MAP_ALLOCATED
;
}
else
{
chunk
-
>
map
[
run_ind
+
i
]
.
bits
=
size_t
(
aRun
)
|
CHUNK_MAP_ALLOCATED
;
}
}
if
(
aLarge
)
{
chunk
-
>
map
[
run_ind
]
.
bits
|
=
aSize
;
}
if
(
chunk
-
>
ndirty
=
=
0
&
&
old_ndirty
>
0
)
{
mChunksDirty
.
Remove
(
chunk
)
;
}
return
true
;
}
void
arena_t
:
:
InitChunk
(
arena_chunk_t
*
aChunk
bool
aZeroed
)
{
size_t
i
;
size_t
flags
=
aZeroed
?
CHUNK_MAP_DECOMMITTED
|
CHUNK_MAP_ZEROED
:
CHUNK_MAP_MADVISED
;
mStats
.
mapped
+
=
kChunkSize
;
aChunk
-
>
arena
=
this
;
aChunk
-
>
ndirty
=
0
;
#
ifdef
MALLOC_DECOMMIT
arena_run_t
*
run
=
(
arena_run_t
*
)
(
uintptr_t
(
aChunk
)
+
(
gChunkHeaderNumPages
<
<
gPageSize2Pow
)
)
;
#
endif
for
(
i
=
0
;
i
<
gChunkHeaderNumPages
;
i
+
+
)
{
aChunk
-
>
map
[
i
]
.
bits
=
0
;
}
aChunk
-
>
map
[
i
]
.
bits
=
gMaxLargeClass
|
flags
;
for
(
i
+
+
;
i
<
gChunkNumPages
-
1
;
i
+
+
)
{
aChunk
-
>
map
[
i
]
.
bits
=
flags
;
}
aChunk
-
>
map
[
gChunkNumPages
-
1
]
.
bits
=
gMaxLargeClass
|
flags
;
#
ifdef
MALLOC_DECOMMIT
pages_decommit
(
run
gMaxLargeClass
)
;
#
endif
mStats
.
committed
+
=
gChunkHeaderNumPages
;
mRunsAvail
.
Insert
(
&
aChunk
-
>
map
[
gChunkHeaderNumPages
]
)
;
#
ifdef
MALLOC_DOUBLE_PURGE
new
(
&
aChunk
-
>
chunks_madvised_elem
)
DoublyLinkedListElement
<
arena_chunk_t
>
(
)
;
#
endif
}
void
arena_t
:
:
DeallocChunk
(
arena_chunk_t
*
aChunk
)
{
if
(
mSpare
)
{
if
(
mSpare
-
>
ndirty
>
0
)
{
aChunk
-
>
arena
-
>
mChunksDirty
.
Remove
(
mSpare
)
;
mNumDirty
-
=
mSpare
-
>
ndirty
;
mStats
.
committed
-
=
mSpare
-
>
ndirty
;
}
#
ifdef
MALLOC_DOUBLE_PURGE
if
(
mChunksMAdvised
.
ElementProbablyInList
(
mSpare
)
)
{
mChunksMAdvised
.
remove
(
mSpare
)
;
}
#
endif
chunk_dealloc
(
(
void
*
)
mSpare
kChunkSize
ARENA_CHUNK
)
;
mStats
.
mapped
-
=
kChunkSize
;
mStats
.
committed
-
=
gChunkHeaderNumPages
;
}
mRunsAvail
.
Remove
(
&
aChunk
-
>
map
[
gChunkHeaderNumPages
]
)
;
mSpare
=
aChunk
;
}
arena_run_t
*
arena_t
:
:
AllocRun
(
size_t
aSize
bool
aLarge
bool
aZero
)
{
arena_run_t
*
run
;
arena_chunk_map_t
*
mapelm
;
arena_chunk_map_t
key
;
MOZ_ASSERT
(
aSize
<
=
gMaxLargeClass
)
;
MOZ_ASSERT
(
(
aSize
&
gPageSizeMask
)
=
=
0
)
;
key
.
bits
=
aSize
|
CHUNK_MAP_KEY
;
mapelm
=
mRunsAvail
.
SearchOrNext
(
&
key
)
;
if
(
mapelm
)
{
arena_chunk_t
*
chunk
=
GetChunkForPtr
(
mapelm
)
;
size_t
pageind
=
(
uintptr_t
(
mapelm
)
-
uintptr_t
(
chunk
-
>
map
)
)
/
sizeof
(
arena_chunk_map_t
)
;
run
=
(
arena_run_t
*
)
(
uintptr_t
(
chunk
)
+
(
pageind
<
<
gPageSize2Pow
)
)
;
}
else
if
(
mSpare
)
{
arena_chunk_t
*
chunk
=
mSpare
;
mSpare
=
nullptr
;
run
=
(
arena_run_t
*
)
(
uintptr_t
(
chunk
)
+
(
gChunkHeaderNumPages
<
<
gPageSize2Pow
)
)
;
mRunsAvail
.
Insert
(
&
chunk
-
>
map
[
gChunkHeaderNumPages
]
)
;
}
else
{
bool
zeroed
;
arena_chunk_t
*
chunk
=
(
arena_chunk_t
*
)
chunk_alloc
(
kChunkSize
kChunkSize
false
&
zeroed
)
;
if
(
!
chunk
)
{
return
nullptr
;
}
InitChunk
(
chunk
zeroed
)
;
run
=
(
arena_run_t
*
)
(
uintptr_t
(
chunk
)
+
(
gChunkHeaderNumPages
<
<
gPageSize2Pow
)
)
;
}
return
SplitRun
(
run
aSize
aLarge
aZero
)
?
run
:
nullptr
;
}
void
arena_t
:
:
Purge
(
bool
aAll
)
{
arena_chunk_t
*
chunk
;
size_t
i
npages
;
size_t
dirty_max
=
aAll
?
1
:
mMaxDirty
;
#
ifdef
MOZ_DEBUG
size_t
ndirty
=
0
;
for
(
auto
chunk
:
mChunksDirty
.
iter
(
)
)
{
ndirty
+
=
chunk
-
>
ndirty
;
}
MOZ_ASSERT
(
ndirty
=
=
mNumDirty
)
;
#
endif
MOZ_DIAGNOSTIC_ASSERT
(
aAll
|
|
(
mNumDirty
>
mMaxDirty
)
)
;
while
(
mNumDirty
>
(
dirty_max
>
>
1
)
)
{
#
ifdef
MALLOC_DOUBLE_PURGE
bool
madvised
=
false
;
#
endif
chunk
=
mChunksDirty
.
Last
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
chunk
)
;
for
(
i
=
gChunkNumPages
-
1
;
chunk
-
>
ndirty
>
0
;
i
-
-
)
{
MOZ_DIAGNOSTIC_ASSERT
(
i
>
=
gChunkHeaderNumPages
)
;
if
(
chunk
-
>
map
[
i
]
.
bits
&
CHUNK_MAP_DIRTY
)
{
#
ifdef
MALLOC_DECOMMIT
const
size_t
free_operation
=
CHUNK_MAP_DECOMMITTED
;
#
else
const
size_t
free_operation
=
CHUNK_MAP_MADVISED
;
#
endif
MOZ_ASSERT
(
(
chunk
-
>
map
[
i
]
.
bits
&
CHUNK_MAP_MADVISED_OR_DECOMMITTED
)
=
=
0
)
;
chunk
-
>
map
[
i
]
.
bits
^
=
free_operation
|
CHUNK_MAP_DIRTY
;
for
(
npages
=
1
;
i
>
gChunkHeaderNumPages
&
&
(
chunk
-
>
map
[
i
-
1
]
.
bits
&
CHUNK_MAP_DIRTY
)
;
npages
+
+
)
{
i
-
-
;
MOZ_ASSERT
(
(
chunk
-
>
map
[
i
]
.
bits
&
CHUNK_MAP_MADVISED_OR_DECOMMITTED
)
=
=
0
)
;
chunk
-
>
map
[
i
]
.
bits
^
=
free_operation
|
CHUNK_MAP_DIRTY
;
}
chunk
-
>
ndirty
-
=
npages
;
mNumDirty
-
=
npages
;
#
ifdef
MALLOC_DECOMMIT
pages_decommit
(
(
void
*
)
(
uintptr_t
(
chunk
)
+
(
i
<
<
gPageSize2Pow
)
)
(
npages
<
<
gPageSize2Pow
)
)
;
#
endif
mStats
.
committed
-
=
npages
;
#
ifndef
MALLOC_DECOMMIT
madvise
(
(
void
*
)
(
uintptr_t
(
chunk
)
+
(
i
<
<
gPageSize2Pow
)
)
(
npages
<
<
gPageSize2Pow
)
MADV_FREE
)
;
#
ifdef
MALLOC_DOUBLE_PURGE
madvised
=
true
;
#
endif
#
endif
if
(
mNumDirty
<
=
(
dirty_max
>
>
1
)
)
{
break
;
}
}
}
if
(
chunk
-
>
ndirty
=
=
0
)
{
mChunksDirty
.
Remove
(
chunk
)
;
}
#
ifdef
MALLOC_DOUBLE_PURGE
if
(
madvised
)
{
if
(
mChunksMAdvised
.
ElementProbablyInList
(
chunk
)
)
{
mChunksMAdvised
.
remove
(
chunk
)
;
}
mChunksMAdvised
.
pushFront
(
chunk
)
;
}
#
endif
}
}
void
arena_t
:
:
DallocRun
(
arena_run_t
*
aRun
bool
aDirty
)
{
arena_chunk_t
*
chunk
;
size_t
size
run_ind
run_pages
;
chunk
=
GetChunkForPtr
(
aRun
)
;
run_ind
=
(
size_t
)
(
(
uintptr_t
(
aRun
)
-
uintptr_t
(
chunk
)
)
>
>
gPageSize2Pow
)
;
MOZ_DIAGNOSTIC_ASSERT
(
run_ind
>
=
gChunkHeaderNumPages
)
;
MOZ_DIAGNOSTIC_ASSERT
(
run_ind
<
gChunkNumPages
)
;
if
(
(
chunk
-
>
map
[
run_ind
]
.
bits
&
CHUNK_MAP_LARGE
)
!
=
0
)
{
size
=
chunk
-
>
map
[
run_ind
]
.
bits
&
~
gPageSizeMask
;
}
else
{
size
=
aRun
-
>
mBin
-
>
mRunSize
;
}
run_pages
=
(
size
>
>
gPageSize2Pow
)
;
if
(
aDirty
)
{
size_t
i
;
for
(
i
=
0
;
i
<
run_pages
;
i
+
+
)
{
MOZ_DIAGNOSTIC_ASSERT
(
(
chunk
-
>
map
[
run_ind
+
i
]
.
bits
&
CHUNK_MAP_DIRTY
)
=
=
0
)
;
chunk
-
>
map
[
run_ind
+
i
]
.
bits
=
CHUNK_MAP_DIRTY
;
}
if
(
chunk
-
>
ndirty
=
=
0
)
{
mChunksDirty
.
Insert
(
chunk
)
;
}
chunk
-
>
ndirty
+
=
run_pages
;
mNumDirty
+
=
run_pages
;
}
else
{
size_t
i
;
for
(
i
=
0
;
i
<
run_pages
;
i
+
+
)
{
chunk
-
>
map
[
run_ind
+
i
]
.
bits
&
=
~
(
CHUNK_MAP_LARGE
|
CHUNK_MAP_ALLOCATED
)
;
}
}
chunk
-
>
map
[
run_ind
]
.
bits
=
size
|
(
chunk
-
>
map
[
run_ind
]
.
bits
&
gPageSizeMask
)
;
chunk
-
>
map
[
run_ind
+
run_pages
-
1
]
.
bits
=
size
|
(
chunk
-
>
map
[
run_ind
+
run_pages
-
1
]
.
bits
&
gPageSizeMask
)
;
if
(
run_ind
+
run_pages
<
gChunkNumPages
&
&
(
chunk
-
>
map
[
run_ind
+
run_pages
]
.
bits
&
CHUNK_MAP_ALLOCATED
)
=
=
0
)
{
size_t
nrun_size
=
chunk
-
>
map
[
run_ind
+
run_pages
]
.
bits
&
~
gPageSizeMask
;
mRunsAvail
.
Remove
(
&
chunk
-
>
map
[
run_ind
+
run_pages
]
)
;
size
+
=
nrun_size
;
run_pages
=
size
>
>
gPageSize2Pow
;
MOZ_DIAGNOSTIC_ASSERT
(
(
chunk
-
>
map
[
run_ind
+
run_pages
-
1
]
.
bits
&
~
gPageSizeMask
)
=
=
nrun_size
)
;
chunk
-
>
map
[
run_ind
]
.
bits
=
size
|
(
chunk
-
>
map
[
run_ind
]
.
bits
&
gPageSizeMask
)
;
chunk
-
>
map
[
run_ind
+
run_pages
-
1
]
.
bits
=
size
|
(
chunk
-
>
map
[
run_ind
+
run_pages
-
1
]
.
bits
&
gPageSizeMask
)
;
}
if
(
run_ind
>
gChunkHeaderNumPages
&
&
(
chunk
-
>
map
[
run_ind
-
1
]
.
bits
&
CHUNK_MAP_ALLOCATED
)
=
=
0
)
{
size_t
prun_size
=
chunk
-
>
map
[
run_ind
-
1
]
.
bits
&
~
gPageSizeMask
;
run_ind
-
=
prun_size
>
>
gPageSize2Pow
;
mRunsAvail
.
Remove
(
&
chunk
-
>
map
[
run_ind
]
)
;
size
+
=
prun_size
;
run_pages
=
size
>
>
gPageSize2Pow
;
MOZ_DIAGNOSTIC_ASSERT
(
(
chunk
-
>
map
[
run_ind
]
.
bits
&
~
gPageSizeMask
)
=
=
prun_size
)
;
chunk
-
>
map
[
run_ind
]
.
bits
=
size
|
(
chunk
-
>
map
[
run_ind
]
.
bits
&
gPageSizeMask
)
;
chunk
-
>
map
[
run_ind
+
run_pages
-
1
]
.
bits
=
size
|
(
chunk
-
>
map
[
run_ind
+
run_pages
-
1
]
.
bits
&
gPageSizeMask
)
;
}
mRunsAvail
.
Insert
(
&
chunk
-
>
map
[
run_ind
]
)
;
if
(
(
chunk
-
>
map
[
gChunkHeaderNumPages
]
.
bits
&
(
~
gPageSizeMask
|
CHUNK_MAP_ALLOCATED
)
)
=
=
gMaxLargeClass
)
{
DeallocChunk
(
chunk
)
;
}
if
(
mNumDirty
>
mMaxDirty
)
{
Purge
(
false
)
;
}
}
void
arena_t
:
:
TrimRunHead
(
arena_chunk_t
*
aChunk
arena_run_t
*
aRun
size_t
aOldSize
size_t
aNewSize
)
{
size_t
pageind
=
(
uintptr_t
(
aRun
)
-
uintptr_t
(
aChunk
)
)
>
>
gPageSize2Pow
;
size_t
head_npages
=
(
aOldSize
-
aNewSize
)
>
>
gPageSize2Pow
;
MOZ_ASSERT
(
aOldSize
>
aNewSize
)
;
aChunk
-
>
map
[
pageind
]
.
bits
=
(
aOldSize
-
aNewSize
)
|
CHUNK_MAP_LARGE
|
CHUNK_MAP_ALLOCATED
;
aChunk
-
>
map
[
pageind
+
head_npages
]
.
bits
=
aNewSize
|
CHUNK_MAP_LARGE
|
CHUNK_MAP_ALLOCATED
;
DallocRun
(
aRun
false
)
;
}
void
arena_t
:
:
TrimRunTail
(
arena_chunk_t
*
aChunk
arena_run_t
*
aRun
size_t
aOldSize
size_t
aNewSize
bool
aDirty
)
{
size_t
pageind
=
(
uintptr_t
(
aRun
)
-
uintptr_t
(
aChunk
)
)
>
>
gPageSize2Pow
;
size_t
npages
=
aNewSize
>
>
gPageSize2Pow
;
MOZ_ASSERT
(
aOldSize
>
aNewSize
)
;
aChunk
-
>
map
[
pageind
]
.
bits
=
aNewSize
|
CHUNK_MAP_LARGE
|
CHUNK_MAP_ALLOCATED
;
aChunk
-
>
map
[
pageind
+
npages
]
.
bits
=
(
aOldSize
-
aNewSize
)
|
CHUNK_MAP_LARGE
|
CHUNK_MAP_ALLOCATED
;
DallocRun
(
(
arena_run_t
*
)
(
uintptr_t
(
aRun
)
+
aNewSize
)
aDirty
)
;
}
arena_run_t
*
arena_t
:
:
GetNonFullBinRun
(
arena_bin_t
*
aBin
)
{
arena_chunk_map_t
*
mapelm
;
arena_run_t
*
run
;
unsigned
i
remainder
;
mapelm
=
aBin
-
>
mNonFullRuns
.
First
(
)
;
if
(
mapelm
)
{
aBin
-
>
mNonFullRuns
.
Remove
(
mapelm
)
;
run
=
(
arena_run_t
*
)
(
mapelm
-
>
bits
&
~
gPageSizeMask
)
;
return
run
;
}
run
=
AllocRun
(
aBin
-
>
mRunSize
false
false
)
;
if
(
!
run
)
{
return
nullptr
;
}
if
(
run
=
=
aBin
-
>
mCurrentRun
)
{
return
run
;
}
run
-
>
mBin
=
aBin
;
for
(
i
=
0
;
i
<
aBin
-
>
mRunNumRegionsMask
-
1
;
i
+
+
)
{
run
-
>
mRegionsMask
[
i
]
=
UINT_MAX
;
}
remainder
=
aBin
-
>
mRunNumRegions
&
(
(
1U
<
<
(
LOG2
(
sizeof
(
int
)
)
+
3
)
)
-
1
)
;
if
(
remainder
=
=
0
)
{
run
-
>
mRegionsMask
[
i
]
=
UINT_MAX
;
}
else
{
run
-
>
mRegionsMask
[
i
]
=
(
UINT_MAX
>
>
(
(
1U
<
<
(
LOG2
(
sizeof
(
int
)
)
+
3
)
)
-
remainder
)
)
;
}
run
-
>
mRegionsMinElement
=
0
;
run
-
>
mNumFree
=
aBin
-
>
mRunNumRegions
;
#
if
defined
(
MOZ_DIAGNOSTIC_ASSERT_ENABLED
)
run
-
>
mMagic
=
ARENA_RUN_MAGIC
;
#
endif
aBin
-
>
mNumRuns
+
+
;
return
run
;
}
void
arena_bin_t
:
:
Init
(
SizeClass
aSizeClass
)
{
size_t
try_run_size
;
unsigned
try_nregs
try_mask_nelms
try_reg0_offset
;
static
const
size_t
kFixedHeaderSize
=
offsetof
(
arena_run_t
mRegionsMask
)
;
MOZ_ASSERT
(
aSizeClass
.
Size
(
)
<
=
gMaxBinClass
)
;
try_run_size
=
gPageSize
;
mCurrentRun
=
nullptr
;
mNonFullRuns
.
Init
(
)
;
mSizeClass
=
aSizeClass
.
Size
(
)
;
mNumRuns
=
0
;
while
(
true
)
{
try_nregs
=
(
(
try_run_size
-
kFixedHeaderSize
)
/
mSizeClass
)
+
1
;
do
{
try_nregs
-
-
;
try_mask_nelms
=
(
try_nregs
>
>
(
LOG2
(
sizeof
(
int
)
)
+
3
)
)
+
(
(
try_nregs
&
(
(
1U
<
<
(
LOG2
(
sizeof
(
int
)
)
+
3
)
)
-
1
)
)
?
1
:
0
)
;
try_reg0_offset
=
try_run_size
-
(
try_nregs
*
mSizeClass
)
;
}
while
(
kFixedHeaderSize
+
(
sizeof
(
unsigned
)
*
try_mask_nelms
)
>
try_reg0_offset
)
;
if
(
try_run_size
>
gMaxLargeClass
)
{
break
;
}
if
(
Fraction
(
try_reg0_offset
try_run_size
)
<
=
kRunOverhead
)
{
break
;
}
if
(
try_reg0_offset
>
mSizeClass
)
{
if
(
Fraction
(
try_reg0_offset
try_run_size
)
<
=
kRunRelaxedOverhead
)
{
break
;
}
}
if
(
try_mask_nelms
*
sizeof
(
unsigned
)
>
=
kFixedHeaderSize
)
{
break
;
}
try_run_size
+
=
gPageSize
;
}
MOZ_ASSERT
(
kFixedHeaderSize
+
(
sizeof
(
unsigned
)
*
try_mask_nelms
)
<
=
try_reg0_offset
)
;
MOZ_ASSERT
(
(
try_mask_nelms
<
<
(
LOG2
(
sizeof
(
int
)
)
+
3
)
)
>
=
try_nregs
)
;
mRunSize
=
try_run_size
;
mRunNumRegions
=
try_nregs
;
mRunNumRegionsMask
=
try_mask_nelms
;
mRunFirstRegionOffset
=
try_reg0_offset
;
}
void
*
arena_t
:
:
MallocSmall
(
size_t
aSize
bool
aZero
)
{
void
*
ret
;
arena_bin_t
*
bin
;
arena_run_t
*
run
;
SizeClass
sizeClass
(
aSize
)
;
aSize
=
sizeClass
.
Size
(
)
;
switch
(
sizeClass
.
Type
(
)
)
{
case
SizeClass
:
:
Tiny
:
bin
=
&
mBins
[
FloorLog2
(
aSize
/
kMinTinyClass
)
]
;
break
;
case
SizeClass
:
:
Quantum
:
bin
=
&
mBins
[
kNumTinyClasses
+
(
aSize
/
kQuantum
)
-
1
]
;
break
;
case
SizeClass
:
:
SubPage
:
bin
=
&
mBins
[
kNumTinyClasses
+
kNumQuantumClasses
+
(
FloorLog2
(
aSize
/
kMaxQuantumClass
)
-
1
)
]
;
break
;
default
:
MOZ_MAKE_COMPILER_ASSUME_IS_UNREACHABLE
(
"
Unexpected
size
class
type
"
)
;
}
MOZ_DIAGNOSTIC_ASSERT
(
aSize
=
=
bin
-
>
mSizeClass
)
;
{
MutexAutoLock
lock
(
mLock
)
;
run
=
bin
-
>
mCurrentRun
;
if
(
MOZ_UNLIKELY
(
!
run
|
|
run
-
>
mNumFree
=
=
0
)
)
{
run
=
bin
-
>
mCurrentRun
=
GetNonFullBinRun
(
bin
)
;
}
if
(
MOZ_UNLIKELY
(
!
run
)
)
{
return
nullptr
;
}
MOZ_DIAGNOSTIC_ASSERT
(
run
-
>
mMagic
=
=
ARENA_RUN_MAGIC
)
;
MOZ_DIAGNOSTIC_ASSERT
(
run
-
>
mNumFree
>
0
)
;
ret
=
arena_run_reg_alloc
(
run
bin
)
;
MOZ_DIAGNOSTIC_ASSERT
(
ret
)
;
run
-
>
mNumFree
-
-
;
if
(
!
ret
)
{
return
nullptr
;
}
mStats
.
allocated_small
+
=
aSize
;
}
if
(
!
aZero
)
{
ApplyZeroOrJunk
(
ret
aSize
)
;
}
else
{
memset
(
ret
0
aSize
)
;
}
return
ret
;
}
void
*
arena_t
:
:
MallocLarge
(
size_t
aSize
bool
aZero
)
{
void
*
ret
;
aSize
=
PAGE_CEILING
(
aSize
)
;
{
MutexAutoLock
lock
(
mLock
)
;
ret
=
AllocRun
(
aSize
true
aZero
)
;
if
(
!
ret
)
{
return
nullptr
;
}
mStats
.
allocated_large
+
=
aSize
;
}
if
(
!
aZero
)
{
ApplyZeroOrJunk
(
ret
aSize
)
;
}
return
ret
;
}
void
*
arena_t
:
:
Malloc
(
size_t
aSize
bool
aZero
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mMagic
=
=
ARENA_MAGIC
)
;
MOZ_ASSERT
(
aSize
!
=
0
)
;
if
(
aSize
<
=
gMaxBinClass
)
{
return
MallocSmall
(
aSize
aZero
)
;
}
if
(
aSize
<
=
gMaxLargeClass
)
{
return
MallocLarge
(
aSize
aZero
)
;
}
return
MallocHuge
(
aSize
aZero
)
;
}
void
*
arena_t
:
:
PallocLarge
(
size_t
aAlignment
size_t
aSize
size_t
aAllocSize
)
{
void
*
ret
;
size_t
offset
;
arena_chunk_t
*
chunk
;
MOZ_ASSERT
(
(
aSize
&
gPageSizeMask
)
=
=
0
)
;
MOZ_ASSERT
(
(
aAlignment
&
gPageSizeMask
)
=
=
0
)
;
{
MutexAutoLock
lock
(
mLock
)
;
ret
=
AllocRun
(
aAllocSize
true
false
)
;
if
(
!
ret
)
{
return
nullptr
;
}
chunk
=
GetChunkForPtr
(
ret
)
;
offset
=
uintptr_t
(
ret
)
&
(
aAlignment
-
1
)
;
MOZ_ASSERT
(
(
offset
&
gPageSizeMask
)
=
=
0
)
;
MOZ_ASSERT
(
offset
<
aAllocSize
)
;
if
(
offset
=
=
0
)
{
TrimRunTail
(
chunk
(
arena_run_t
*
)
ret
aAllocSize
aSize
false
)
;
}
else
{
size_t
leadsize
trailsize
;
leadsize
=
aAlignment
-
offset
;
if
(
leadsize
>
0
)
{
TrimRunHead
(
chunk
(
arena_run_t
*
)
ret
aAllocSize
aAllocSize
-
leadsize
)
;
ret
=
(
void
*
)
(
uintptr_t
(
ret
)
+
leadsize
)
;
}
trailsize
=
aAllocSize
-
leadsize
-
aSize
;
if
(
trailsize
!
=
0
)
{
MOZ_ASSERT
(
trailsize
<
aAllocSize
)
;
TrimRunTail
(
chunk
(
arena_run_t
*
)
ret
aSize
+
trailsize
aSize
false
)
;
}
}
mStats
.
allocated_large
+
=
aSize
;
}
ApplyZeroOrJunk
(
ret
aSize
)
;
return
ret
;
}
void
*
arena_t
:
:
Palloc
(
size_t
aAlignment
size_t
aSize
)
{
void
*
ret
;
size_t
ceil_size
;
ceil_size
=
ALIGNMENT_CEILING
(
aSize
aAlignment
)
;
if
(
ceil_size
<
aSize
)
{
return
nullptr
;
}
if
(
ceil_size
<
=
gPageSize
|
|
(
aAlignment
<
=
gPageSize
&
&
ceil_size
<
=
gMaxLargeClass
)
)
{
ret
=
Malloc
(
ceil_size
false
)
;
}
else
{
size_t
run_size
;
aAlignment
=
PAGE_CEILING
(
aAlignment
)
;
ceil_size
=
PAGE_CEILING
(
aSize
)
;
if
(
ceil_size
<
aSize
|
|
ceil_size
+
aAlignment
<
ceil_size
)
{
return
nullptr
;
}
if
(
ceil_size
>
=
aAlignment
)
{
run_size
=
ceil_size
+
aAlignment
-
gPageSize
;
}
else
{
run_size
=
(
aAlignment
<
<
1
)
-
gPageSize
;
}
if
(
run_size
<
=
gMaxLargeClass
)
{
ret
=
PallocLarge
(
aAlignment
ceil_size
run_size
)
;
}
else
if
(
aAlignment
<
=
kChunkSize
)
{
ret
=
MallocHuge
(
ceil_size
false
)
;
}
else
{
ret
=
PallocHuge
(
ceil_size
aAlignment
false
)
;
}
}
MOZ_ASSERT
(
(
uintptr_t
(
ret
)
&
(
aAlignment
-
1
)
)
=
=
0
)
;
return
ret
;
}
static
size_t
arena_salloc
(
const
void
*
ptr
)
{
size_t
ret
;
arena_chunk_t
*
chunk
;
size_t
pageind
mapbits
;
MOZ_ASSERT
(
ptr
)
;
MOZ_ASSERT
(
GetChunkOffsetForPtr
(
ptr
)
!
=
0
)
;
chunk
=
GetChunkForPtr
(
ptr
)
;
pageind
=
(
(
(
uintptr_t
)
ptr
-
(
uintptr_t
)
chunk
)
>
>
gPageSize2Pow
)
;
mapbits
=
chunk
-
>
map
[
pageind
]
.
bits
;
MOZ_DIAGNOSTIC_ASSERT
(
(
mapbits
&
CHUNK_MAP_ALLOCATED
)
!
=
0
)
;
if
(
(
mapbits
&
CHUNK_MAP_LARGE
)
=
=
0
)
{
arena_run_t
*
run
=
(
arena_run_t
*
)
(
mapbits
&
~
gPageSizeMask
)
;
MOZ_DIAGNOSTIC_ASSERT
(
run
-
>
mMagic
=
=
ARENA_RUN_MAGIC
)
;
ret
=
run
-
>
mBin
-
>
mSizeClass
;
}
else
{
ret
=
mapbits
&
~
gPageSizeMask
;
MOZ_DIAGNOSTIC_ASSERT
(
ret
!
=
0
)
;
}
return
ret
;
}
class
AllocInfo
{
public
:
template
<
bool
Validate
=
false
>
static
inline
AllocInfo
Get
(
const
void
*
aPtr
)
{
if
(
Validate
&
&
malloc_initialized
=
=
false
)
{
return
AllocInfo
(
)
;
}
auto
chunk
=
GetChunkForPtr
(
aPtr
)
;
if
(
Validate
)
{
if
(
!
chunk
|
|
!
gChunkRTree
.
Get
(
chunk
)
)
{
return
AllocInfo
(
)
;
}
}
if
(
chunk
!
=
aPtr
)
{
MOZ_DIAGNOSTIC_ASSERT
(
chunk
-
>
arena
-
>
mMagic
=
=
ARENA_MAGIC
)
;
return
AllocInfo
(
arena_salloc
(
aPtr
)
chunk
)
;
}
extent_node_t
key
;
key
.
mAddr
=
chunk
;
MutexAutoLock
lock
(
huge_mtx
)
;
extent_node_t
*
node
=
huge
.
Search
(
&
key
)
;
if
(
Validate
&
&
!
node
)
{
return
AllocInfo
(
)
;
}
return
AllocInfo
(
node
-
>
mSize
node
)
;
}
static
inline
AllocInfo
GetValidated
(
const
void
*
aPtr
)
{
return
Get
<
true
>
(
aPtr
)
;
}
AllocInfo
(
)
:
mSize
(
0
)
mChunk
(
nullptr
)
{
}
explicit
AllocInfo
(
size_t
aSize
arena_chunk_t
*
aChunk
)
:
mSize
(
aSize
)
mChunk
(
aChunk
)
{
MOZ_ASSERT
(
mSize
<
=
gMaxLargeClass
)
;
}
explicit
AllocInfo
(
size_t
aSize
extent_node_t
*
aNode
)
:
mSize
(
aSize
)
mNode
(
aNode
)
{
MOZ_ASSERT
(
mSize
>
gMaxLargeClass
)
;
}
size_t
Size
(
)
{
return
mSize
;
}
arena_t
*
Arena
(
)
{
return
(
mSize
<
=
gMaxLargeClass
)
?
mChunk
-
>
arena
:
mNode
-
>
mArena
;
}
private
:
size_t
mSize
;
union
{
arena_chunk_t
*
mChunk
;
extent_node_t
*
mNode
;
}
;
}
;
template
<
>
inline
void
MozJemalloc
:
:
jemalloc_ptr_info
(
const
void
*
aPtr
jemalloc_ptr_info_t
*
aInfo
)
{
arena_chunk_t
*
chunk
=
GetChunkForPtr
(
aPtr
)
;
if
(
!
chunk
|
|
!
malloc_initialized
)
{
*
aInfo
=
{
TagUnknown
nullptr
0
}
;
return
;
}
extent_node_t
*
node
;
extent_node_t
key
;
{
MutexAutoLock
lock
(
huge_mtx
)
;
key
.
mAddr
=
const_cast
<
void
*
>
(
aPtr
)
;
node
=
reinterpret_cast
<
RedBlackTree
<
extent_node_t
ExtentTreeBoundsTrait
>
*
>
(
&
huge
)
-
>
Search
(
&
key
)
;
if
(
node
)
{
*
aInfo
=
{
TagLiveHuge
node
-
>
mAddr
node
-
>
mSize
}
;
return
;
}
}
if
(
!
gChunkRTree
.
Get
(
chunk
)
)
{
*
aInfo
=
{
TagUnknown
nullptr
0
}
;
return
;
}
MOZ_DIAGNOSTIC_ASSERT
(
chunk
-
>
arena
-
>
mMagic
=
=
ARENA_MAGIC
)
;
size_t
pageind
=
(
(
(
uintptr_t
)
aPtr
-
(
uintptr_t
)
chunk
)
>
>
gPageSize2Pow
)
;
if
(
pageind
<
gChunkHeaderNumPages
)
{
*
aInfo
=
{
TagUnknown
nullptr
0
}
;
return
;
}
size_t
mapbits
=
chunk
-
>
map
[
pageind
]
.
bits
;
if
(
!
(
mapbits
&
CHUNK_MAP_ALLOCATED
)
)
{
PtrInfoTag
tag
=
TagFreedPageDirty
;
if
(
mapbits
&
CHUNK_MAP_DIRTY
)
{
tag
=
TagFreedPageDirty
;
}
else
if
(
mapbits
&
CHUNK_MAP_DECOMMITTED
)
{
tag
=
TagFreedPageDecommitted
;
}
else
if
(
mapbits
&
CHUNK_MAP_MADVISED
)
{
tag
=
TagFreedPageMadvised
;
}
else
if
(
mapbits
&
CHUNK_MAP_ZEROED
)
{
tag
=
TagFreedPageZeroed
;
}
else
{
MOZ_CRASH
(
)
;
}
void
*
pageaddr
=
(
void
*
)
(
uintptr_t
(
aPtr
)
&
~
gPageSizeMask
)
;
*
aInfo
=
{
tag
pageaddr
gPageSize
}
;
return
;
}
if
(
mapbits
&
CHUNK_MAP_LARGE
)
{
size_t
size
;
while
(
true
)
{
size
=
mapbits
&
~
gPageSizeMask
;
if
(
size
!
=
0
)
{
break
;
}
pageind
-
-
;
MOZ_DIAGNOSTIC_ASSERT
(
pageind
>
=
gChunkHeaderNumPages
)
;
if
(
pageind
<
gChunkHeaderNumPages
)
{
*
aInfo
=
{
TagUnknown
nullptr
0
}
;
return
;
}
mapbits
=
chunk
-
>
map
[
pageind
]
.
bits
;
MOZ_DIAGNOSTIC_ASSERT
(
mapbits
&
CHUNK_MAP_LARGE
)
;
if
(
!
(
mapbits
&
CHUNK_MAP_LARGE
)
)
{
*
aInfo
=
{
TagUnknown
nullptr
0
}
;
return
;
}
}
void
*
addr
=
(
(
char
*
)
chunk
)
+
(
pageind
<
<
gPageSize2Pow
)
;
*
aInfo
=
{
TagLiveLarge
addr
size
}
;
return
;
}
auto
run
=
(
arena_run_t
*
)
(
mapbits
&
~
gPageSizeMask
)
;
MOZ_DIAGNOSTIC_ASSERT
(
run
-
>
mMagic
=
=
ARENA_RUN_MAGIC
)
;
size_t
size
=
run
-
>
mBin
-
>
mSizeClass
;
uintptr_t
reg0_addr
=
(
uintptr_t
)
run
+
run
-
>
mBin
-
>
mRunFirstRegionOffset
;
if
(
aPtr
<
(
void
*
)
reg0_addr
)
{
*
aInfo
=
{
TagUnknown
nullptr
0
}
;
return
;
}
unsigned
regind
=
(
(
uintptr_t
)
aPtr
-
reg0_addr
)
/
size
;
void
*
addr
=
(
void
*
)
(
reg0_addr
+
regind
*
size
)
;
unsigned
elm
=
regind
>
>
(
LOG2
(
sizeof
(
int
)
)
+
3
)
;
unsigned
bit
=
regind
-
(
elm
<
<
(
LOG2
(
sizeof
(
int
)
)
+
3
)
)
;
PtrInfoTag
tag
=
(
(
run
-
>
mRegionsMask
[
elm
]
&
(
1U
<
<
bit
)
)
)
?
TagFreedSmall
:
TagLiveSmall
;
*
aInfo
=
{
tag
addr
size
}
;
}
namespace
Debug
{
MOZ_NEVER_INLINE
jemalloc_ptr_info_t
*
jemalloc_ptr_info
(
const
void
*
aPtr
)
{
static
jemalloc_ptr_info_t
info
;
MozJemalloc
:
:
jemalloc_ptr_info
(
aPtr
&
info
)
;
return
&
info
;
}
}
void
arena_t
:
:
DallocSmall
(
arena_chunk_t
*
aChunk
void
*
aPtr
arena_chunk_map_t
*
aMapElm
)
{
arena_run_t
*
run
;
arena_bin_t
*
bin
;
size_t
size
;
run
=
(
arena_run_t
*
)
(
aMapElm
-
>
bits
&
~
gPageSizeMask
)
;
MOZ_DIAGNOSTIC_ASSERT
(
run
-
>
mMagic
=
=
ARENA_RUN_MAGIC
)
;
bin
=
run
-
>
mBin
;
size
=
bin
-
>
mSizeClass
;
MOZ_DIAGNOSTIC_ASSERT
(
uintptr_t
(
aPtr
)
>
=
uintptr_t
(
run
)
+
bin
-
>
mRunFirstRegionOffset
)
;
MOZ_DIAGNOSTIC_ASSERT
(
(
uintptr_t
(
aPtr
)
-
(
uintptr_t
(
run
)
+
bin
-
>
mRunFirstRegionOffset
)
)
%
size
=
=
0
)
;
memset
(
aPtr
kAllocPoison
size
)
;
arena_run_reg_dalloc
(
run
bin
aPtr
size
)
;
run
-
>
mNumFree
+
+
;
if
(
run
-
>
mNumFree
=
=
bin
-
>
mRunNumRegions
)
{
if
(
run
=
=
bin
-
>
mCurrentRun
)
{
bin
-
>
mCurrentRun
=
nullptr
;
}
else
if
(
bin
-
>
mRunNumRegions
!
=
1
)
{
size_t
run_pageind
=
(
uintptr_t
(
run
)
-
uintptr_t
(
aChunk
)
)
>
>
gPageSize2Pow
;
arena_chunk_map_t
*
run_mapelm
=
&
aChunk
-
>
map
[
run_pageind
]
;
MOZ_DIAGNOSTIC_ASSERT
(
bin
-
>
mNonFullRuns
.
Search
(
run_mapelm
)
=
=
run_mapelm
)
;
bin
-
>
mNonFullRuns
.
Remove
(
run_mapelm
)
;
}
#
if
defined
(
MOZ_DIAGNOSTIC_ASSERT_ENABLED
)
run
-
>
mMagic
=
0
;
#
endif
DallocRun
(
run
true
)
;
bin
-
>
mNumRuns
-
-
;
}
else
if
(
run
-
>
mNumFree
=
=
1
&
&
run
!
=
bin
-
>
mCurrentRun
)
{
if
(
!
bin
-
>
mCurrentRun
)
{
bin
-
>
mCurrentRun
=
run
;
}
else
if
(
uintptr_t
(
run
)
<
uintptr_t
(
bin
-
>
mCurrentRun
)
)
{
if
(
bin
-
>
mCurrentRun
-
>
mNumFree
>
0
)
{
arena_chunk_t
*
runcur_chunk
=
GetChunkForPtr
(
bin
-
>
mCurrentRun
)
;
size_t
runcur_pageind
=
(
uintptr_t
(
bin
-
>
mCurrentRun
)
-
uintptr_t
(
runcur_chunk
)
)
>
>
gPageSize2Pow
;
arena_chunk_map_t
*
runcur_mapelm
=
&
runcur_chunk
-
>
map
[
runcur_pageind
]
;
MOZ_DIAGNOSTIC_ASSERT
(
!
bin
-
>
mNonFullRuns
.
Search
(
runcur_mapelm
)
)
;
bin
-
>
mNonFullRuns
.
Insert
(
runcur_mapelm
)
;
}
bin
-
>
mCurrentRun
=
run
;
}
else
{
size_t
run_pageind
=
(
uintptr_t
(
run
)
-
uintptr_t
(
aChunk
)
)
>
>
gPageSize2Pow
;
arena_chunk_map_t
*
run_mapelm
=
&
aChunk
-
>
map
[
run_pageind
]
;
MOZ_DIAGNOSTIC_ASSERT
(
bin
-
>
mNonFullRuns
.
Search
(
run_mapelm
)
=
=
nullptr
)
;
bin
-
>
mNonFullRuns
.
Insert
(
run_mapelm
)
;
}
}
mStats
.
allocated_small
-
=
size
;
}
void
arena_t
:
:
DallocLarge
(
arena_chunk_t
*
aChunk
void
*
aPtr
)
{
MOZ_DIAGNOSTIC_ASSERT
(
(
uintptr_t
(
aPtr
)
&
gPageSizeMask
)
=
=
0
)
;
size_t
pageind
=
(
uintptr_t
(
aPtr
)
-
uintptr_t
(
aChunk
)
)
>
>
gPageSize2Pow
;
size_t
size
=
aChunk
-
>
map
[
pageind
]
.
bits
&
~
gPageSizeMask
;
memset
(
aPtr
kAllocPoison
size
)
;
mStats
.
allocated_large
-
=
size
;
DallocRun
(
(
arena_run_t
*
)
aPtr
true
)
;
}
static
inline
void
arena_dalloc
(
void
*
aPtr
size_t
aOffset
arena_t
*
aArena
)
{
MOZ_ASSERT
(
aPtr
)
;
MOZ_ASSERT
(
aOffset
!
=
0
)
;
MOZ_ASSERT
(
GetChunkOffsetForPtr
(
aPtr
)
=
=
aOffset
)
;
auto
chunk
=
(
arena_chunk_t
*
)
(
(
uintptr_t
)
aPtr
-
aOffset
)
;
auto
arena
=
chunk
-
>
arena
;
MOZ_ASSERT
(
arena
)
;
MOZ_DIAGNOSTIC_ASSERT
(
arena
-
>
mMagic
=
=
ARENA_MAGIC
)
;
MOZ_RELEASE_ASSERT
(
!
aArena
|
|
arena
=
=
aArena
)
;
MutexAutoLock
lock
(
arena
-
>
mLock
)
;
size_t
pageind
=
aOffset
>
>
gPageSize2Pow
;
arena_chunk_map_t
*
mapelm
=
&
chunk
-
>
map
[
pageind
]
;
MOZ_RELEASE_ASSERT
(
(
mapelm
-
>
bits
&
CHUNK_MAP_ALLOCATED
)
!
=
0
"
Double
-
free
?
"
)
;
if
(
(
mapelm
-
>
bits
&
CHUNK_MAP_LARGE
)
=
=
0
)
{
arena
-
>
DallocSmall
(
chunk
aPtr
mapelm
)
;
}
else
{
arena
-
>
DallocLarge
(
chunk
aPtr
)
;
}
}
static
inline
void
idalloc
(
void
*
ptr
arena_t
*
aArena
)
{
size_t
offset
;
MOZ_ASSERT
(
ptr
)
;
offset
=
GetChunkOffsetForPtr
(
ptr
)
;
if
(
offset
!
=
0
)
{
arena_dalloc
(
ptr
offset
aArena
)
;
}
else
{
huge_dalloc
(
ptr
aArena
)
;
}
}
void
arena_t
:
:
RallocShrinkLarge
(
arena_chunk_t
*
aChunk
void
*
aPtr
size_t
aSize
size_t
aOldSize
)
{
MOZ_ASSERT
(
aSize
<
aOldSize
)
;
MutexAutoLock
lock
(
mLock
)
;
TrimRunTail
(
aChunk
(
arena_run_t
*
)
aPtr
aOldSize
aSize
true
)
;
mStats
.
allocated_large
-
=
aOldSize
-
aSize
;
}
bool
arena_t
:
:
RallocGrowLarge
(
arena_chunk_t
*
aChunk
void
*
aPtr
size_t
aSize
size_t
aOldSize
)
{
size_t
pageind
=
(
uintptr_t
(
aPtr
)
-
uintptr_t
(
aChunk
)
)
>
>
gPageSize2Pow
;
size_t
npages
=
aOldSize
>
>
gPageSize2Pow
;
MutexAutoLock
lock
(
mLock
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aOldSize
=
=
(
aChunk
-
>
map
[
pageind
]
.
bits
&
~
gPageSizeMask
)
)
;
MOZ_ASSERT
(
aSize
>
aOldSize
)
;
if
(
pageind
+
npages
<
gChunkNumPages
&
&
(
aChunk
-
>
map
[
pageind
+
npages
]
.
bits
&
CHUNK_MAP_ALLOCATED
)
=
=
0
&
&
(
aChunk
-
>
map
[
pageind
+
npages
]
.
bits
&
~
gPageSizeMask
)
>
=
aSize
-
aOldSize
)
{
if
(
!
SplitRun
(
(
arena_run_t
*
)
(
uintptr_t
(
aChunk
)
+
(
(
pageind
+
npages
)
<
<
gPageSize2Pow
)
)
aSize
-
aOldSize
true
false
)
)
{
return
false
;
}
aChunk
-
>
map
[
pageind
]
.
bits
=
aSize
|
CHUNK_MAP_LARGE
|
CHUNK_MAP_ALLOCATED
;
aChunk
-
>
map
[
pageind
+
npages
]
.
bits
=
CHUNK_MAP_LARGE
|
CHUNK_MAP_ALLOCATED
;
mStats
.
allocated_large
+
=
aSize
-
aOldSize
;
return
true
;
}
return
false
;
}
void
*
arena_t
:
:
RallocSmallOrLarge
(
void
*
aPtr
size_t
aSize
size_t
aOldSize
)
{
void
*
ret
;
size_t
copysize
;
SizeClass
sizeClass
(
aSize
)
;
if
(
aOldSize
<
=
gMaxLargeClass
&
&
sizeClass
.
Size
(
)
=
=
aOldSize
)
{
if
(
aSize
<
aOldSize
)
{
memset
(
(
void
*
)
(
uintptr_t
(
aPtr
)
+
aSize
)
kAllocPoison
aOldSize
-
aSize
)
;
}
return
aPtr
;
}
if
(
sizeClass
.
Type
(
)
=
=
SizeClass
:
:
Large
&
&
aOldSize
>
gMaxBinClass
&
&
aOldSize
<
=
gMaxLargeClass
)
{
arena_chunk_t
*
chunk
=
GetChunkForPtr
(
aPtr
)
;
if
(
sizeClass
.
Size
(
)
<
aOldSize
)
{
memset
(
(
void
*
)
(
(
uintptr_t
)
aPtr
+
aSize
)
kAllocPoison
aOldSize
-
aSize
)
;
RallocShrinkLarge
(
chunk
aPtr
sizeClass
.
Size
(
)
aOldSize
)
;
return
aPtr
;
}
if
(
RallocGrowLarge
(
chunk
aPtr
sizeClass
.
Size
(
)
aOldSize
)
)
{
ApplyZeroOrJunk
(
(
void
*
)
(
(
uintptr_t
)
aPtr
+
aOldSize
)
aSize
-
aOldSize
)
;
return
aPtr
;
}
}
ret
=
Malloc
(
aSize
false
)
;
if
(
!
ret
)
{
return
nullptr
;
}
copysize
=
(
aSize
<
aOldSize
)
?
aSize
:
aOldSize
;
#
ifdef
VM_COPY_MIN
if
(
copysize
>
=
VM_COPY_MIN
)
{
pages_copy
(
ret
aPtr
copysize
)
;
}
else
#
endif
{
memcpy
(
ret
aPtr
copysize
)
;
}
idalloc
(
aPtr
this
)
;
return
ret
;
}
void
*
arena_t
:
:
Ralloc
(
void
*
aPtr
size_t
aSize
size_t
aOldSize
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mMagic
=
=
ARENA_MAGIC
)
;
MOZ_ASSERT
(
aPtr
)
;
MOZ_ASSERT
(
aSize
!
=
0
)
;
return
(
aSize
<
=
gMaxLargeClass
)
?
RallocSmallOrLarge
(
aPtr
aSize
aOldSize
)
:
RallocHuge
(
aPtr
aSize
aOldSize
)
;
}
arena_t
:
:
arena_t
(
arena_params_t
*
aParams
)
{
unsigned
i
;
MOZ_RELEASE_ASSERT
(
mLock
.
Init
(
)
)
;
memset
(
&
mLink
0
sizeof
(
mLink
)
)
;
memset
(
&
mStats
0
sizeof
(
arena_stats_t
)
)
;
mChunksDirty
.
Init
(
)
;
#
ifdef
MALLOC_DOUBLE_PURGE
new
(
&
mChunksMAdvised
)
DoublyLinkedList
<
arena_chunk_t
>
(
)
;
#
endif
mSpare
=
nullptr
;
mNumDirty
=
0
;
mMaxDirty
=
(
aParams
&
&
aParams
-
>
mMaxDirty
)
?
aParams
-
>
mMaxDirty
:
(
opt_dirty_max
/
8
)
;
mRunsAvail
.
Init
(
)
;
SizeClass
sizeClass
(
1
)
;
for
(
i
=
0
;
;
i
+
+
)
{
arena_bin_t
&
bin
=
mBins
[
i
]
;
bin
.
Init
(
sizeClass
)
;
if
(
sizeClass
.
Size
(
)
=
=
gMaxSubPageClass
)
{
break
;
}
sizeClass
=
sizeClass
.
Next
(
)
;
}
MOZ_ASSERT
(
i
=
=
kNumTinyClasses
+
kNumQuantumClasses
+
gNumSubPageClasses
-
1
)
;
#
if
defined
(
MOZ_DIAGNOSTIC_ASSERT_ENABLED
)
mMagic
=
ARENA_MAGIC
;
#
endif
}
arena_t
*
ArenaCollection
:
:
CreateArena
(
bool
aIsPrivate
arena_params_t
*
aParams
)
{
fallible_t
fallible
;
arena_t
*
ret
=
new
(
fallible
)
arena_t
(
aParams
)
;
if
(
!
ret
)
{
_malloc_message
(
_getprogname
(
)
"
:
(
malloc
)
Error
initializing
arena
\
n
"
)
;
return
mDefaultArena
;
}
MutexAutoLock
lock
(
mLock
)
;
ret
-
>
mId
=
mLastArenaId
+
+
;
(
aIsPrivate
?
mPrivateArenas
:
mArenas
)
.
Insert
(
ret
)
;
return
ret
;
}
void
*
arena_t
:
:
MallocHuge
(
size_t
aSize
bool
aZero
)
{
return
PallocHuge
(
aSize
kChunkSize
aZero
)
;
}
void
*
arena_t
:
:
PallocHuge
(
size_t
aSize
size_t
aAlignment
bool
aZero
)
{
void
*
ret
;
size_t
csize
;
size_t
psize
;
extent_node_t
*
node
;
bool
zeroed
;
csize
=
CHUNK_CEILING
(
aSize
)
;
if
(
csize
=
=
0
)
{
return
nullptr
;
}
node
=
base_node_alloc
(
)
;
if
(
!
node
)
{
return
nullptr
;
}
ret
=
chunk_alloc
(
csize
aAlignment
false
&
zeroed
)
;
if
(
!
ret
)
{
base_node_dealloc
(
node
)
;
return
nullptr
;
}
if
(
aZero
)
{
chunk_ensure_zero
(
ret
csize
zeroed
)
;
}
node
-
>
mAddr
=
ret
;
psize
=
PAGE_CEILING
(
aSize
)
;
node
-
>
mSize
=
psize
;
node
-
>
mArena
=
this
;
{
MutexAutoLock
lock
(
huge_mtx
)
;
huge
.
Insert
(
node
)
;
huge_allocated
+
=
psize
;
huge_mapped
+
=
csize
;
}
#
ifdef
MALLOC_DECOMMIT
if
(
csize
-
psize
>
0
)
{
pages_decommit
(
(
void
*
)
(
(
uintptr_t
)
ret
+
psize
)
csize
-
psize
)
;
}
#
endif
if
(
!
aZero
)
{
#
ifdef
MALLOC_DECOMMIT
ApplyZeroOrJunk
(
ret
psize
)
;
#
else
ApplyZeroOrJunk
(
ret
csize
)
;
#
endif
}
return
ret
;
}
void
*
arena_t
:
:
RallocHuge
(
void
*
aPtr
size_t
aSize
size_t
aOldSize
)
{
void
*
ret
;
size_t
copysize
;
if
(
aOldSize
>
gMaxLargeClass
&
&
CHUNK_CEILING
(
aSize
)
=
=
CHUNK_CEILING
(
aOldSize
)
)
{
size_t
psize
=
PAGE_CEILING
(
aSize
)
;
if
(
aSize
<
aOldSize
)
{
memset
(
(
void
*
)
(
(
uintptr_t
)
aPtr
+
aSize
)
kAllocPoison
aOldSize
-
aSize
)
;
}
#
ifdef
MALLOC_DECOMMIT
if
(
psize
<
aOldSize
)
{
extent_node_t
key
;
pages_decommit
(
(
void
*
)
(
(
uintptr_t
)
aPtr
+
psize
)
aOldSize
-
psize
)
;
MutexAutoLock
lock
(
huge_mtx
)
;
key
.
mAddr
=
const_cast
<
void
*
>
(
aPtr
)
;
extent_node_t
*
node
=
huge
.
Search
(
&
key
)
;
MOZ_ASSERT
(
node
)
;
MOZ_ASSERT
(
node
-
>
mSize
=
=
aOldSize
)
;
MOZ_RELEASE_ASSERT
(
node
-
>
mArena
=
=
this
)
;
huge_allocated
-
=
aOldSize
-
psize
;
node
-
>
mSize
=
psize
;
}
else
if
(
psize
>
aOldSize
)
{
if
(
!
pages_commit
(
(
void
*
)
(
(
uintptr_t
)
aPtr
+
aOldSize
)
psize
-
aOldSize
)
)
{
return
nullptr
;
}
}
#
endif
if
(
psize
>
aOldSize
)
{
extent_node_t
key
;
MutexAutoLock
lock
(
huge_mtx
)
;
key
.
mAddr
=
const_cast
<
void
*
>
(
aPtr
)
;
extent_node_t
*
node
=
huge
.
Search
(
&
key
)
;
MOZ_ASSERT
(
node
)
;
MOZ_ASSERT
(
node
-
>
mSize
=
=
aOldSize
)
;
MOZ_RELEASE_ASSERT
(
node
-
>
mArena
=
=
this
)
;
huge_allocated
+
=
psize
-
aOldSize
;
node
-
>
mSize
=
psize
;
}
if
(
aSize
>
aOldSize
)
{
ApplyZeroOrJunk
(
(
void
*
)
(
(
uintptr_t
)
aPtr
+
aOldSize
)
aSize
-
aOldSize
)
;
}
return
aPtr
;
}
ret
=
MallocHuge
(
aSize
false
)
;
if
(
!
ret
)
{
return
nullptr
;
}
copysize
=
(
aSize
<
aOldSize
)
?
aSize
:
aOldSize
;
#
ifdef
VM_COPY_MIN
if
(
copysize
>
=
VM_COPY_MIN
)
{
pages_copy
(
ret
aPtr
copysize
)
;
}
else
#
endif
{
memcpy
(
ret
aPtr
copysize
)
;
}
idalloc
(
aPtr
this
)
;
return
ret
;
}
static
void
huge_dalloc
(
void
*
aPtr
arena_t
*
aArena
)
{
extent_node_t
*
node
;
{
extent_node_t
key
;
MutexAutoLock
lock
(
huge_mtx
)
;
key
.
mAddr
=
aPtr
;
node
=
huge
.
Search
(
&
key
)
;
MOZ_RELEASE_ASSERT
(
node
"
Double
-
free
?
"
)
;
MOZ_ASSERT
(
node
-
>
mAddr
=
=
aPtr
)
;
MOZ_RELEASE_ASSERT
(
!
aArena
|
|
node
-
>
mArena
=
=
aArena
)
;
huge
.
Remove
(
node
)
;
huge_allocated
-
=
node
-
>
mSize
;
huge_mapped
-
=
CHUNK_CEILING
(
node
-
>
mSize
)
;
}
chunk_dealloc
(
node
-
>
mAddr
CHUNK_CEILING
(
node
-
>
mSize
)
HUGE_CHUNK
)
;
base_node_dealloc
(
node
)
;
}
static
size_t
GetKernelPageSize
(
)
{
static
size_t
kernel_page_size
=
(
[
]
(
)
{
#
ifdef
XP_WIN
SYSTEM_INFO
info
;
GetSystemInfo
(
&
info
)
;
return
info
.
dwPageSize
;
#
else
long
result
=
sysconf
(
_SC_PAGESIZE
)
;
MOZ_ASSERT
(
result
!
=
-
1
)
;
return
result
;
#
endif
}
)
(
)
;
return
kernel_page_size
;
}
static
bool
malloc_init_hard
(
)
{
unsigned
i
;
const
char
*
opts
;
long
result
;
AutoLock
<
StaticMutex
>
lock
(
gInitLock
)
;
if
(
malloc_initialized
)
{
return
true
;
}
if
(
!
thread_arena
.
init
(
)
)
{
return
true
;
}
result
=
GetKernelPageSize
(
)
;
MOZ_ASSERT
(
(
(
result
-
1
)
&
result
)
=
=
0
)
;
#
ifdef
MALLOC_STATIC_PAGESIZE
if
(
gPageSize
%
(
size_t
)
result
)
{
_malloc_message
(
_getprogname
(
)
"
Compile
-
time
page
size
does
not
divide
the
runtime
one
.
\
n
"
)
;
MOZ_CRASH
(
)
;
}
#
else
gPageSize
=
(
size_t
)
result
;
DefineGlobals
(
)
;
#
endif
if
(
(
opts
=
getenv
(
"
MALLOC_OPTIONS
"
)
)
)
{
for
(
i
=
0
;
opts
[
i
]
!
=
'
\
0
'
;
i
+
+
)
{
unsigned
j
nreps
;
bool
nseen
;
for
(
nreps
=
0
nseen
=
false
;
;
i
+
+
nseen
=
true
)
{
switch
(
opts
[
i
]
)
{
case
'
0
'
:
case
'
1
'
:
case
'
2
'
:
case
'
3
'
:
case
'
4
'
:
case
'
5
'
:
case
'
6
'
:
case
'
7
'
:
case
'
8
'
:
case
'
9
'
:
nreps
*
=
10
;
nreps
+
=
opts
[
i
]
-
'
0
'
;
break
;
default
:
goto
MALLOC_OUT
;
}
}
MALLOC_OUT
:
if
(
nseen
=
=
false
)
{
nreps
=
1
;
}
for
(
j
=
0
;
j
<
nreps
;
j
+
+
)
{
switch
(
opts
[
i
]
)
{
case
'
f
'
:
opt_dirty_max
>
>
=
1
;
break
;
case
'
F
'
:
if
(
opt_dirty_max
=
=
0
)
{
opt_dirty_max
=
1
;
}
else
if
(
(
opt_dirty_max
<
<
1
)
!
=
0
)
{
opt_dirty_max
<
<
=
1
;
}
break
;
#
ifdef
MOZ_DEBUG
case
'
j
'
:
opt_junk
=
false
;
break
;
case
'
J
'
:
opt_junk
=
true
;
break
;
#
endif
#
ifdef
MOZ_DEBUG
case
'
z
'
:
opt_zero
=
false
;
break
;
case
'
Z
'
:
opt_zero
=
true
;
break
;
#
endif
default
:
{
char
cbuf
[
2
]
;
cbuf
[
0
]
=
opts
[
i
]
;
cbuf
[
1
]
=
'
\
0
'
;
_malloc_message
(
_getprogname
(
)
"
:
(
malloc
)
Unsupported
character
"
"
in
malloc
options
:
'
"
cbuf
"
'
\
n
"
)
;
}
}
}
}
}
gRecycledSize
=
0
;
chunks_mtx
.
Init
(
)
;
gChunksBySize
.
Init
(
)
;
gChunksByAddress
.
Init
(
)
;
huge_mtx
.
Init
(
)
;
huge
.
Init
(
)
;
huge_allocated
=
0
;
huge_mapped
=
0
;
base_mapped
=
0
;
base_committed
=
0
;
base_nodes
=
nullptr
;
base_mtx
.
Init
(
)
;
if
(
!
gArenas
.
Init
(
)
)
{
return
false
;
}
thread_arena
.
set
(
gArenas
.
GetDefault
(
)
)
;
if
(
!
gChunkRTree
.
Init
(
)
)
{
return
false
;
}
malloc_initialized
=
true
;
Debug
:
:
jemalloc_ptr_info
(
nullptr
)
;
#
if
!
defined
(
XP_WIN
)
&
&
!
defined
(
XP_DARWIN
)
pthread_atfork
(
_malloc_prefork
_malloc_postfork_parent
_malloc_postfork_child
)
;
#
endif
return
true
;
}
struct
BaseAllocator
{
#
define
MALLOC_DECL
(
name
return_type
.
.
.
)
\
inline
return_type
name
(
__VA_ARGS__
)
;
#
define
MALLOC_FUNCS
MALLOC_FUNCS_MALLOC_BASE
#
include
"
malloc_decls
.
h
"
explicit
BaseAllocator
(
arena_t
*
aArena
)
:
mArena
(
aArena
)
{
}
private
:
arena_t
*
mArena
;
}
;
#
define
MALLOC_DECL
(
name
return_type
.
.
.
)
\
template
<
>
\
inline
return_type
MozJemalloc
:
:
name
(
ARGS_HELPER
(
TYPED_ARGS
#
#
__VA_ARGS__
)
)
\
{
\
BaseAllocator
allocator
(
nullptr
)
;
\
return
allocator
.
name
(
ARGS_HELPER
(
ARGS
#
#
__VA_ARGS__
)
)
;
\
}
#
define
MALLOC_FUNCS
MALLOC_FUNCS_MALLOC_BASE
#
include
"
malloc_decls
.
h
"
inline
void
*
BaseAllocator
:
:
malloc
(
size_t
aSize
)
{
void
*
ret
;
arena_t
*
arena
;
if
(
!
malloc_init
(
)
)
{
ret
=
nullptr
;
goto
RETURN
;
}
if
(
aSize
=
=
0
)
{
aSize
=
1
;
}
arena
=
mArena
?
mArena
:
choose_arena
(
aSize
)
;
ret
=
arena
-
>
Malloc
(
aSize
false
)
;
RETURN
:
if
(
!
ret
)
{
errno
=
ENOMEM
;
}
return
ret
;
}
inline
void
*
BaseAllocator
:
:
memalign
(
size_t
aAlignment
size_t
aSize
)
{
MOZ_ASSERT
(
(
(
aAlignment
-
1
)
&
aAlignment
)
=
=
0
)
;
if
(
!
malloc_init
(
)
)
{
return
nullptr
;
}
if
(
aSize
=
=
0
)
{
aSize
=
1
;
}
aAlignment
=
aAlignment
<
sizeof
(
void
*
)
?
sizeof
(
void
*
)
:
aAlignment
;
arena_t
*
arena
=
mArena
?
mArena
:
choose_arena
(
aSize
)
;
return
arena
-
>
Palloc
(
aAlignment
aSize
)
;
}
inline
void
*
BaseAllocator
:
:
calloc
(
size_t
aNum
size_t
aSize
)
{
void
*
ret
;
if
(
malloc_init
(
)
)
{
CheckedInt
<
size_t
>
checkedSize
=
CheckedInt
<
size_t
>
(
aNum
)
*
aSize
;
if
(
checkedSize
.
isValid
(
)
)
{
size_t
allocSize
=
checkedSize
.
value
(
)
;
if
(
allocSize
=
=
0
)
{
allocSize
=
1
;
}
arena_t
*
arena
=
mArena
?
mArena
:
choose_arena
(
allocSize
)
;
ret
=
arena
-
>
Malloc
(
allocSize
true
)
;
}
else
{
ret
=
nullptr
;
}
}
else
{
ret
=
nullptr
;
}
if
(
!
ret
)
{
errno
=
ENOMEM
;
}
return
ret
;
}
inline
void
*
BaseAllocator
:
:
realloc
(
void
*
aPtr
size_t
aSize
)
{
void
*
ret
;
if
(
aSize
=
=
0
)
{
aSize
=
1
;
}
if
(
aPtr
)
{
MOZ_RELEASE_ASSERT
(
malloc_initialized
)
;
auto
info
=
AllocInfo
:
:
Get
(
aPtr
)
;
auto
arena
=
info
.
Arena
(
)
;
MOZ_RELEASE_ASSERT
(
!
mArena
|
|
arena
=
=
mArena
)
;
ret
=
arena
-
>
Ralloc
(
aPtr
aSize
info
.
Size
(
)
)
;
if
(
!
ret
)
{
errno
=
ENOMEM
;
}
}
else
{
if
(
!
malloc_init
(
)
)
{
ret
=
nullptr
;
}
else
{
arena_t
*
arena
=
mArena
?
mArena
:
choose_arena
(
aSize
)
;
ret
=
arena
-
>
Malloc
(
aSize
false
)
;
}
if
(
!
ret
)
{
errno
=
ENOMEM
;
}
}
return
ret
;
}
inline
void
BaseAllocator
:
:
free
(
void
*
aPtr
)
{
size_t
offset
;
offset
=
GetChunkOffsetForPtr
(
aPtr
)
;
if
(
offset
!
=
0
)
{
MOZ_RELEASE_ASSERT
(
malloc_initialized
)
;
arena_dalloc
(
aPtr
offset
mArena
)
;
}
else
if
(
aPtr
)
{
MOZ_RELEASE_ASSERT
(
malloc_initialized
)
;
huge_dalloc
(
aPtr
mArena
)
;
}
}
template
<
void
*
(
*
memalign
)
(
size_t
size_t
)
>
struct
AlignedAllocator
{
static
inline
int
posix_memalign
(
void
*
*
aMemPtr
size_t
aAlignment
size_t
aSize
)
{
void
*
result
;
if
(
(
(
aAlignment
-
1
)
&
aAlignment
)
!
=
0
|
|
aAlignment
<
sizeof
(
void
*
)
)
{
return
EINVAL
;
}
result
=
memalign
(
aAlignment
aSize
)
;
if
(
!
result
)
{
return
ENOMEM
;
}
*
aMemPtr
=
result
;
return
0
;
}
static
inline
void
*
aligned_alloc
(
size_t
aAlignment
size_t
aSize
)
{
if
(
aSize
%
aAlignment
)
{
return
nullptr
;
}
return
memalign
(
aAlignment
aSize
)
;
}
static
inline
void
*
valloc
(
size_t
aSize
)
{
return
memalign
(
GetKernelPageSize
(
)
aSize
)
;
}
}
;
template
<
>
inline
int
MozJemalloc
:
:
posix_memalign
(
void
*
*
aMemPtr
size_t
aAlignment
size_t
aSize
)
{
return
AlignedAllocator
<
memalign
>
:
:
posix_memalign
(
aMemPtr
aAlignment
aSize
)
;
}
template
<
>
inline
void
*
MozJemalloc
:
:
aligned_alloc
(
size_t
aAlignment
size_t
aSize
)
{
return
AlignedAllocator
<
memalign
>
:
:
aligned_alloc
(
aAlignment
aSize
)
;
}
template
<
>
inline
void
*
MozJemalloc
:
:
valloc
(
size_t
aSize
)
{
return
AlignedAllocator
<
memalign
>
:
:
valloc
(
aSize
)
;
}
template
<
>
inline
size_t
MozJemalloc
:
:
malloc_good_size
(
size_t
aSize
)
{
if
(
aSize
<
=
gMaxLargeClass
)
{
aSize
=
SizeClass
(
aSize
)
.
Size
(
)
;
}
else
{
aSize
=
PAGE_CEILING
(
aSize
)
;
}
return
aSize
;
}
template
<
>
inline
size_t
MozJemalloc
:
:
malloc_usable_size
(
usable_ptr_t
aPtr
)
{
return
AllocInfo
:
:
GetValidated
(
aPtr
)
.
Size
(
)
;
}
template
<
>
inline
void
MozJemalloc
:
:
jemalloc_stats
(
jemalloc_stats_t
*
aStats
)
{
size_t
non_arena_mapped
chunk_header_size
;
if
(
!
aStats
)
{
return
;
}
if
(
!
malloc_init
(
)
)
{
memset
(
aStats
0
sizeof
(
*
aStats
)
)
;
return
;
}
aStats
-
>
opt_junk
=
opt_junk
;
aStats
-
>
opt_zero
=
opt_zero
;
aStats
-
>
quantum
=
kQuantum
;
aStats
-
>
small_max
=
kMaxQuantumClass
;
aStats
-
>
large_max
=
gMaxLargeClass
;
aStats
-
>
chunksize
=
kChunkSize
;
aStats
-
>
page_size
=
gPageSize
;
aStats
-
>
dirty_max
=
opt_dirty_max
;
aStats
-
>
narenas
=
0
;
aStats
-
>
mapped
=
0
;
aStats
-
>
allocated
=
0
;
aStats
-
>
waste
=
0
;
aStats
-
>
page_cache
=
0
;
aStats
-
>
bookkeeping
=
0
;
aStats
-
>
bin_unused
=
0
;
non_arena_mapped
=
0
;
{
MutexAutoLock
lock
(
huge_mtx
)
;
non_arena_mapped
+
=
huge_mapped
;
aStats
-
>
allocated
+
=
huge_allocated
;
MOZ_ASSERT
(
huge_mapped
>
=
huge_allocated
)
;
}
{
MutexAutoLock
lock
(
base_mtx
)
;
non_arena_mapped
+
=
base_mapped
;
aStats
-
>
bookkeeping
+
=
base_committed
;
MOZ_ASSERT
(
base_mapped
>
=
base_committed
)
;
}
gArenas
.
mLock
.
Lock
(
)
;
for
(
auto
arena
:
gArenas
.
iter
(
)
)
{
size_t
arena_mapped
arena_allocated
arena_committed
arena_dirty
j
arena_unused
arena_headers
;
arena_run_t
*
run
;
arena_headers
=
0
;
arena_unused
=
0
;
{
MutexAutoLock
lock
(
arena
-
>
mLock
)
;
arena_mapped
=
arena
-
>
mStats
.
mapped
;
arena_committed
=
arena
-
>
mStats
.
committed
<
<
gPageSize2Pow
;
arena_allocated
=
arena
-
>
mStats
.
allocated_small
+
arena
-
>
mStats
.
allocated_large
;
arena_dirty
=
arena
-
>
mNumDirty
<
<
gPageSize2Pow
;
for
(
j
=
0
;
j
<
kNumTinyClasses
+
kNumQuantumClasses
+
gNumSubPageClasses
;
j
+
+
)
{
arena_bin_t
*
bin
=
&
arena
-
>
mBins
[
j
]
;
size_t
bin_unused
=
0
;
for
(
auto
mapelm
:
bin
-
>
mNonFullRuns
.
iter
(
)
)
{
run
=
(
arena_run_t
*
)
(
mapelm
-
>
bits
&
~
gPageSizeMask
)
;
bin_unused
+
=
run
-
>
mNumFree
*
bin
-
>
mSizeClass
;
}
if
(
bin
-
>
mCurrentRun
)
{
bin_unused
+
=
bin
-
>
mCurrentRun
-
>
mNumFree
*
bin
-
>
mSizeClass
;
}
arena_unused
+
=
bin_unused
;
arena_headers
+
=
bin
-
>
mNumRuns
*
bin
-
>
mRunFirstRegionOffset
;
}
}
MOZ_ASSERT
(
arena_mapped
>
=
arena_committed
)
;
MOZ_ASSERT
(
arena_committed
>
=
arena_allocated
+
arena_dirty
)
;
aStats
-
>
mapped
+
=
arena_mapped
;
aStats
-
>
allocated
+
=
arena_allocated
;
aStats
-
>
page_cache
+
=
arena_dirty
;
aStats
-
>
waste
+
=
arena_committed
-
arena_allocated
-
arena_dirty
-
arena_unused
-
arena_headers
;
aStats
-
>
bin_unused
+
=
arena_unused
;
aStats
-
>
bookkeeping
+
=
arena_headers
;
aStats
-
>
narenas
+
+
;
}
gArenas
.
mLock
.
Unlock
(
)
;
chunk_header_size
=
(
(
aStats
-
>
mapped
/
aStats
-
>
chunksize
)
*
gChunkHeaderNumPages
)
<
<
gPageSize2Pow
;
aStats
-
>
mapped
+
=
non_arena_mapped
;
aStats
-
>
bookkeeping
+
=
chunk_header_size
;
aStats
-
>
waste
-
=
chunk_header_size
;
MOZ_ASSERT
(
aStats
-
>
mapped
>
=
aStats
-
>
allocated
+
aStats
-
>
waste
+
aStats
-
>
page_cache
+
aStats
-
>
bookkeeping
)
;
}
#
ifdef
MALLOC_DOUBLE_PURGE
static
void
hard_purge_chunk
(
arena_chunk_t
*
aChunk
)
{
for
(
size_t
i
=
gChunkHeaderNumPages
;
i
<
gChunkNumPages
;
i
+
+
)
{
size_t
npages
;
for
(
npages
=
0
;
aChunk
-
>
map
[
i
+
npages
]
.
bits
&
CHUNK_MAP_MADVISED
&
&
i
+
npages
<
gChunkNumPages
;
npages
+
+
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
(
aChunk
-
>
map
[
i
+
npages
]
.
bits
&
CHUNK_MAP_DECOMMITTED
)
)
;
aChunk
-
>
map
[
i
+
npages
]
.
bits
^
=
CHUNK_MAP_MADVISED_OR_DECOMMITTED
;
}
if
(
npages
>
0
)
{
pages_decommit
(
(
(
char
*
)
aChunk
)
+
(
i
<
<
gPageSize2Pow
)
npages
<
<
gPageSize2Pow
)
;
Unused
<
<
pages_commit
(
(
(
char
*
)
aChunk
)
+
(
i
<
<
gPageSize2Pow
)
npages
<
<
gPageSize2Pow
)
;
}
i
+
=
npages
;
}
}
void
arena_t
:
:
HardPurge
(
)
{
MutexAutoLock
lock
(
mLock
)
;
while
(
!
mChunksMAdvised
.
isEmpty
(
)
)
{
arena_chunk_t
*
chunk
=
mChunksMAdvised
.
popFront
(
)
;
hard_purge_chunk
(
chunk
)
;
}
}
template
<
>
inline
void
MozJemalloc
:
:
jemalloc_purge_freed_pages
(
)
{
if
(
malloc_initialized
)
{
MutexAutoLock
lock
(
gArenas
.
mLock
)
;
for
(
auto
arena
:
gArenas
.
iter
(
)
)
{
arena
-
>
HardPurge
(
)
;
}
}
}
#
else
template
<
>
inline
void
MozJemalloc
:
:
jemalloc_purge_freed_pages
(
)
{
}
#
endif
template
<
>
inline
void
MozJemalloc
:
:
jemalloc_free_dirty_pages
(
void
)
{
if
(
malloc_initialized
)
{
MutexAutoLock
lock
(
gArenas
.
mLock
)
;
for
(
auto
arena
:
gArenas
.
iter
(
)
)
{
MutexAutoLock
arena_lock
(
arena
-
>
mLock
)
;
arena
-
>
Purge
(
true
)
;
}
}
}
inline
arena_t
*
ArenaCollection
:
:
GetById
(
arena_id_t
aArenaId
bool
aIsPrivate
)
{
if
(
!
malloc_initialized
)
{
return
nullptr
;
}
mozilla
:
:
AlignedStorage2
<
arena_t
>
key
;
key
.
addr
(
)
-
>
mId
=
aArenaId
;
MutexAutoLock
lock
(
mLock
)
;
arena_t
*
result
=
(
aIsPrivate
?
mPrivateArenas
:
mArenas
)
.
Search
(
key
.
addr
(
)
)
;
MOZ_RELEASE_ASSERT
(
result
)
;
return
result
;
}
template
<
>
inline
arena_id_t
MozJemalloc
:
:
moz_create_arena_with_params
(
arena_params_t
*
aParams
)
{
if
(
malloc_init
(
)
)
{
arena_t
*
arena
=
gArenas
.
CreateArena
(
true
aParams
)
;
return
arena
-
>
mId
;
}
return
0
;
}
template
<
>
inline
void
MozJemalloc
:
:
moz_dispose_arena
(
arena_id_t
aArenaId
)
{
MOZ_CRASH
(
"
Do
not
call
moz_dispose_arena
until
Bug
1364359
is
fixed
.
"
)
;
arena_t
*
arena
=
gArenas
.
GetById
(
aArenaId
true
)
;
MOZ_RELEASE_ASSERT
(
arena
)
;
gArenas
.
DisposeArena
(
arena
)
;
}
#
define
MALLOC_DECL
(
name
return_type
.
.
.
)
\
template
<
>
\
inline
return_type
MozJemalloc
:
:
moz_arena_
#
#
name
(
\
arena_id_t
aArenaId
ARGS_HELPER
(
TYPED_ARGS
#
#
__VA_ARGS__
)
)
\
{
\
BaseAllocator
allocator
(
\
gArenas
.
GetById
(
aArenaId
/
*
IsPrivate
=
*
/
true
)
)
;
\
return
allocator
.
name
(
ARGS_HELPER
(
ARGS
#
#
__VA_ARGS__
)
)
;
\
}
#
define
MALLOC_FUNCS
MALLOC_FUNCS_MALLOC_BASE
#
include
"
malloc_decls
.
h
"
#
ifndef
XP_DARWIN
static
#
endif
void
_malloc_prefork
(
void
)
{
gArenas
.
mLock
.
Lock
(
)
;
for
(
auto
arena
:
gArenas
.
iter
(
)
)
{
arena
-
>
mLock
.
Lock
(
)
;
}
base_mtx
.
Lock
(
)
;
huge_mtx
.
Lock
(
)
;
}
#
ifndef
XP_DARWIN
static
#
endif
void
_malloc_postfork_parent
(
void
)
{
huge_mtx
.
Unlock
(
)
;
base_mtx
.
Unlock
(
)
;
for
(
auto
arena
:
gArenas
.
iter
(
)
)
{
arena
-
>
mLock
.
Unlock
(
)
;
}
gArenas
.
mLock
.
Unlock
(
)
;
}
#
ifndef
XP_DARWIN
static
#
endif
void
_malloc_postfork_child
(
void
)
{
huge_mtx
.
Init
(
)
;
base_mtx
.
Init
(
)
;
for
(
auto
arena
:
gArenas
.
iter
(
)
)
{
arena
-
>
mLock
.
Init
(
)
;
}
gArenas
.
mLock
.
Init
(
)
;
}
#
ifdef
MOZ_REPLACE_MALLOC
#
ifdef
XP_DARWIN
#
define
MOZ_REPLACE_WEAK
__attribute__
(
(
weak_import
)
)
#
elif
defined
(
XP_WIN
)
|
|
defined
(
ANDROID
)
#
define
MOZ_DYNAMIC_REPLACE_INIT
#
define
replace_init
replace_init_decl
#
elif
defined
(
__GNUC__
)
#
define
MOZ_REPLACE_WEAK
__attribute__
(
(
weak
)
)
#
endif
#
include
"
replace_malloc
.
h
"
#
define
MALLOC_DECL
(
name
return_type
.
.
.
)
MozJemalloc
:
:
name
static
malloc_table_t
gReplaceMallocTable
=
{
#
include
"
malloc_decls
.
h
"
}
;
#
ifdef
MOZ_DYNAMIC_REPLACE_INIT
#
undef
replace_init
typedef
decltype
(
replace_init_decl
)
replace_init_impl_t
;
static
replace_init_impl_t
*
replace_init
=
nullptr
;
#
endif
#
ifdef
XP_WIN
typedef
HMODULE
replace_malloc_handle_t
;
static
replace_malloc_handle_t
replace_malloc_handle
(
)
{
wchar_t
replace_malloc_lib
[
1024
]
;
if
(
GetEnvironmentVariableW
(
L
"
MOZ_REPLACE_MALLOC_LIB
"
replace_malloc_lib
ArrayLength
(
replace_malloc_lib
)
)
>
0
)
{
return
LoadLibraryW
(
replace_malloc_lib
)
;
}
return
nullptr
;
}
#
define
REPLACE_MALLOC_GET_INIT_FUNC
(
handle
)
\
(
replace_init_impl_t
*
)
GetProcAddress
(
handle
"
replace_init
"
)
#
elif
defined
(
ANDROID
)
#
include
<
dlfcn
.
h
>
typedef
void
*
replace_malloc_handle_t
;
static
replace_malloc_handle_t
replace_malloc_handle
(
)
{
const
char
*
replace_malloc_lib
=
getenv
(
"
MOZ_REPLACE_MALLOC_LIB
"
)
;
if
(
replace_malloc_lib
&
&
*
replace_malloc_lib
)
{
return
dlopen
(
replace_malloc_lib
RTLD_LAZY
)
;
}
return
nullptr
;
}
#
define
REPLACE_MALLOC_GET_INIT_FUNC
(
handle
)
\
(
replace_init_impl_t
*
)
dlsym
(
handle
"
replace_init
"
)
#
endif
static
void
replace_malloc_init_funcs
(
)
;
#
ifdef
MOZ_REPLACE_MALLOC_STATIC
extern
"
C
"
void
logalloc_init
(
malloc_table_t
*
ReplaceMallocBridge
*
*
)
;
extern
"
C
"
void
dmd_init
(
malloc_table_t
*
ReplaceMallocBridge
*
*
)
;
#
endif
bool
Equals
(
malloc_table_t
&
aTable1
malloc_table_t
&
aTable2
)
{
return
memcmp
(
&
aTable1
&
aTable2
sizeof
(
malloc_table_t
)
)
=
=
0
;
}
static
bool
gReplaceMallocInitialized
=
false
;
static
ReplaceMallocBridge
*
gReplaceMallocBridge
=
nullptr
;
static
void
init
(
)
{
#
ifdef
MOZ_REPLACE_MALLOC_STATIC
malloc_table_t
initialTable
=
gReplaceMallocTable
;
#
endif
#
ifdef
MOZ_DYNAMIC_REPLACE_INIT
replace_malloc_handle_t
handle
=
replace_malloc_handle
(
)
;
if
(
handle
)
{
replace_init
=
REPLACE_MALLOC_GET_INIT_FUNC
(
handle
)
;
}
#
endif
gReplaceMallocInitialized
=
true
;
if
(
replace_init
)
{
replace_init
(
&
gReplaceMallocTable
&
gReplaceMallocBridge
)
;
}
#
ifdef
MOZ_REPLACE_MALLOC_STATIC
if
(
Equals
(
initialTable
gReplaceMallocTable
)
)
{
logalloc_init
(
&
gReplaceMallocTable
&
gReplaceMallocBridge
)
;
}
#
ifdef
MOZ_DMD
if
(
Equals
(
initialTable
gReplaceMallocTable
)
)
{
dmd_init
(
&
gReplaceMallocTable
&
gReplaceMallocBridge
)
;
}
#
endif
#
endif
replace_malloc_init_funcs
(
)
;
}
#
define
MALLOC_DECL
(
name
return_type
.
.
.
)
\
template
<
>
\
inline
return_type
ReplaceMalloc
:
:
name
(
\
ARGS_HELPER
(
TYPED_ARGS
#
#
__VA_ARGS__
)
)
\
{
\
if
(
MOZ_UNLIKELY
(
!
gReplaceMallocInitialized
)
)
{
\
init
(
)
;
\
}
\
return
gReplaceMallocTable
.
name
(
ARGS_HELPER
(
ARGS
#
#
__VA_ARGS__
)
)
;
\
}
#
include
"
malloc_decls
.
h
"
MOZ_JEMALLOC_API
struct
ReplaceMallocBridge
*
get_bridge
(
void
)
{
if
(
MOZ_UNLIKELY
(
!
gReplaceMallocInitialized
)
)
{
init
(
)
;
}
return
gReplaceMallocBridge
;
}
static
void
replace_malloc_init_funcs
(
)
{
if
(
gReplaceMallocTable
.
posix_memalign
=
=
MozJemalloc
:
:
posix_memalign
&
&
gReplaceMallocTable
.
memalign
!
=
MozJemalloc
:
:
memalign
)
{
gReplaceMallocTable
.
posix_memalign
=
AlignedAllocator
<
ReplaceMalloc
:
:
memalign
>
:
:
posix_memalign
;
}
if
(
gReplaceMallocTable
.
aligned_alloc
=
=
MozJemalloc
:
:
aligned_alloc
&
&
gReplaceMallocTable
.
memalign
!
=
MozJemalloc
:
:
memalign
)
{
gReplaceMallocTable
.
aligned_alloc
=
AlignedAllocator
<
ReplaceMalloc
:
:
memalign
>
:
:
aligned_alloc
;
}
if
(
gReplaceMallocTable
.
valloc
=
=
MozJemalloc
:
:
valloc
&
&
gReplaceMallocTable
.
memalign
!
=
MozJemalloc
:
:
memalign
)
{
gReplaceMallocTable
.
valloc
=
AlignedAllocator
<
ReplaceMalloc
:
:
memalign
>
:
:
valloc
;
}
if
(
gReplaceMallocTable
.
moz_create_arena_with_params
=
=
MozJemalloc
:
:
moz_create_arena_with_params
&
&
gReplaceMallocTable
.
malloc
!
=
MozJemalloc
:
:
malloc
)
{
#
define
MALLOC_DECL
(
name
.
.
.
)
\
gReplaceMallocTable
.
name
=
DummyArenaAllocator
<
ReplaceMalloc
>
:
:
name
;
#
define
MALLOC_FUNCS
MALLOC_FUNCS_ARENA
#
include
"
malloc_decls
.
h
"
}
}
#
endif
#
define
GENERIC_MALLOC_DECL2
(
name
name_impl
return_type
.
.
.
)
\
return_type
name_impl
(
ARGS_HELPER
(
TYPED_ARGS
#
#
__VA_ARGS__
)
)
\
{
\
return
DefaultMalloc
:
:
name
(
ARGS_HELPER
(
ARGS
#
#
__VA_ARGS__
)
)
;
\
}
#
define
GENERIC_MALLOC_DECL
(
name
return_type
.
.
.
)
\
GENERIC_MALLOC_DECL2
(
name
name
#
#
_impl
return_type
#
#
__VA_ARGS__
)
#
define
MALLOC_DECL
(
.
.
.
)
\
MOZ_MEMORY_API
MACRO_CALL
(
GENERIC_MALLOC_DECL
(
__VA_ARGS__
)
)
#
define
MALLOC_FUNCS
MALLOC_FUNCS_MALLOC
#
include
"
malloc_decls
.
h
"
#
undef
GENERIC_MALLOC_DECL
#
define
GENERIC_MALLOC_DECL
(
name
return_type
.
.
.
)
\
GENERIC_MALLOC_DECL2
(
name
name
return_type
#
#
__VA_ARGS__
)
#
define
MALLOC_DECL
(
.
.
.
)
\
MOZ_JEMALLOC_API
MACRO_CALL
(
GENERIC_MALLOC_DECL
(
__VA_ARGS__
)
)
#
define
MALLOC_FUNCS
(
MALLOC_FUNCS_JEMALLOC
|
MALLOC_FUNCS_ARENA
)
#
include
"
malloc_decls
.
h
"
#
ifdef
HAVE_DLOPEN
#
include
<
dlfcn
.
h
>
#
endif
#
if
defined
(
__GLIBC__
)
&
&
!
defined
(
__UCLIBC__
)
extern
"
C
"
{
MOZ_EXPORT
void
(
*
__free_hook
)
(
void
*
)
=
free_impl
;
MOZ_EXPORT
void
*
(
*
__malloc_hook
)
(
size_t
)
=
malloc_impl
;
MOZ_EXPORT
void
*
(
*
__realloc_hook
)
(
void
*
size_t
)
=
realloc_impl
;
MOZ_EXPORT
void
*
(
*
__memalign_hook
)
(
size_t
size_t
)
=
memalign_impl
;
}
#
elif
defined
(
RTLD_DEEPBIND
)
#
error
"
Interposing
malloc
is
unsafe
on
this
system
without
libc
malloc
hooks
.
"
#
endif
#
ifdef
XP_WIN
void
*
_recalloc
(
void
*
aPtr
size_t
aCount
size_t
aSize
)
{
size_t
oldsize
=
aPtr
?
AllocInfo
:
:
Get
(
aPtr
)
.
Size
(
)
:
0
;
CheckedInt
<
size_t
>
checkedSize
=
CheckedInt
<
size_t
>
(
aCount
)
*
aSize
;
if
(
!
checkedSize
.
isValid
(
)
)
{
return
nullptr
;
}
size_t
newsize
=
checkedSize
.
value
(
)
;
aPtr
=
DefaultMalloc
:
:
realloc
(
aPtr
newsize
)
;
if
(
aPtr
&
&
oldsize
<
newsize
)
{
memset
(
(
void
*
)
(
(
uintptr_t
)
aPtr
+
oldsize
)
0
newsize
-
oldsize
)
;
}
return
aPtr
;
}
void
*
_expand
(
void
*
aPtr
size_t
newsize
)
{
if
(
AllocInfo
:
:
Get
(
aPtr
)
.
Size
(
)
>
=
newsize
)
{
return
aPtr
;
}
return
nullptr
;
}
size_t
_msize
(
void
*
aPtr
)
{
return
DefaultMalloc
:
:
malloc_usable_size
(
aPtr
)
;
}
#
endif
