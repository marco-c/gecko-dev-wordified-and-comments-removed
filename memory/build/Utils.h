#
ifndef
Utils_h
#
define
Utils_h
#
include
<
type_traits
>
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
TemplateLib
.
h
"
template
<
size_t
N
>
struct
Log2
:
mozilla
:
:
tl
:
:
CeilingLog2
<
N
>
{
using
mozilla
:
:
tl
:
:
CeilingLog2
<
N
>
:
:
value
;
static_assert
(
1ULL
<
<
value
=
=
N
"
Number
is
not
a
power
of
2
"
)
;
}
;
#
define
LOG2
(
N
)
Log2
<
N
>
:
:
value
enum
class
Order
{
eLess
=
-
1
eEqual
=
0
eGreater
=
1
}
;
template
<
typename
T
>
Order
CompareInt
(
T
aValue1
T
aValue2
)
{
static_assert
(
std
:
:
is_integral_v
<
T
>
"
Type
must
be
integral
"
)
;
if
(
aValue1
<
aValue2
)
{
return
Order
:
:
eLess
;
}
if
(
aValue1
>
aValue2
)
{
return
Order
:
:
eGreater
;
}
return
Order
:
:
eEqual
;
}
template
<
typename
T
>
Order
CompareAddr
(
T
*
aAddr1
T
*
aAddr2
)
{
return
CompareInt
(
uintptr_t
(
aAddr1
)
uintptr_t
(
aAddr2
)
)
;
}
constexpr
size_t
operator
"
"
_KiB
(
unsigned
long
long
int
aNum
)
{
return
size_t
(
aNum
)
*
1024
;
}
constexpr
size_t
operator
"
"
_KiB
(
long
double
aNum
)
{
return
size_t
(
aNum
*
1024
)
;
}
constexpr
size_t
operator
"
"
_MiB
(
unsigned
long
long
int
aNum
)
{
return
size_t
(
aNum
)
*
1024_KiB
;
}
constexpr
size_t
operator
"
"
_MiB
(
long
double
aNum
)
{
return
size_t
(
aNum
*
1024_KiB
)
;
}
constexpr
double
operator
"
"
_percent
(
long
double
aPercent
)
{
return
double
(
aPercent
)
/
100
;
}
class
Fraction
{
public
:
explicit
constexpr
Fraction
(
size_t
aNumerator
size_t
aDenominator
)
:
mNumerator
(
aNumerator
)
mDenominator
(
aDenominator
)
{
}
MOZ_IMPLICIT
constexpr
Fraction
(
long
double
aValue
)
:
mNumerator
(
aValue
*
4096
)
mDenominator
(
4096
)
{
}
inline
bool
operator
<
(
const
Fraction
&
aOther
)
const
{
#
ifndef
MOZ_DEBUG
return
mNumerator
*
aOther
.
mDenominator
<
aOther
.
mNumerator
*
mDenominator
;
#
else
mozilla
:
:
CheckedInt
<
size_t
>
numerator
(
mNumerator
)
;
mozilla
:
:
CheckedInt
<
size_t
>
denominator
(
mDenominator
)
;
size_t
lhs
=
(
numerator
*
aOther
.
mDenominator
)
.
value
(
)
;
size_t
rhs
=
(
aOther
.
mNumerator
*
denominator
)
.
value
(
)
;
return
lhs
<
rhs
;
#
endif
}
inline
bool
operator
>
(
const
Fraction
&
aOther
)
const
{
return
aOther
<
*
this
;
}
inline
bool
operator
>
=
(
const
Fraction
&
aOther
)
const
{
return
!
(
*
this
<
aOther
)
;
}
inline
bool
operator
<
=
(
const
Fraction
&
aOther
)
const
{
return
!
(
*
this
>
aOther
)
;
}
inline
bool
operator
=
=
(
const
Fraction
&
aOther
)
const
{
#
ifndef
MOZ_DEBUG
return
mNumerator
*
aOther
.
mDenominator
=
=
aOther
.
mNumerator
*
mDenominator
;
#
else
mozilla
:
:
CheckedInt
<
size_t
>
numerator
(
mNumerator
)
;
mozilla
:
:
CheckedInt
<
size_t
>
denominator
(
mDenominator
)
;
size_t
lhs
=
(
numerator
*
aOther
.
mDenominator
)
.
value
(
)
;
size_t
rhs
=
(
aOther
.
mNumerator
*
denominator
)
.
value
(
)
;
return
lhs
=
=
rhs
;
#
endif
}
inline
bool
operator
!
=
(
const
Fraction
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
private
:
size_t
mNumerator
;
size_t
mDenominator
;
}
;
#
endif
