#
ifndef
_JEMALLOC_TYPES_H_
#
define
_JEMALLOC_TYPES_H_
#
ifdef
_MSC_VER
#
include
<
crtdefs
.
h
>
#
else
#
include
<
stddef
.
h
>
#
endif
#
include
<
stdbool
.
h
>
#
ifdef
__cplusplus
extern
"
C
"
{
#
endif
#
ifndef
MALLOC_USABLE_SIZE_CONST_PTR
#
define
MALLOC_USABLE_SIZE_CONST_PTR
const
#
endif
typedef
MALLOC_USABLE_SIZE_CONST_PTR
void
*
usable_ptr_t
;
typedef
size_t
arena_id_t
;
typedef
struct
arena_params_s
{
size_t
mMaxDirty
;
#
ifdef
__cplusplus
arena_params_s
(
)
:
mMaxDirty
(
0
)
{
}
#
endif
}
arena_params_t
;
typedef
struct
{
bool
opt_junk
;
bool
opt_zero
;
size_t
narenas
;
size_t
quantum
;
size_t
small_max
;
size_t
large_max
;
size_t
chunksize
;
size_t
page_size
;
size_t
dirty_max
;
size_t
mapped
;
size_t
allocated
;
size_t
waste
;
size_t
page_cache
;
size_t
bookkeeping
;
size_t
bin_unused
;
}
jemalloc_stats_t
;
enum
PtrInfoTag
{
TagUnknown
TagLiveAlloc
TagFreedAlloc
TagFreedPage
}
;
typedef
struct
jemalloc_ptr_info_s
{
enum
PtrInfoTag
tag
;
void
*
addr
;
size_t
size
;
#
ifdef
MOZ_DEBUG
arena_id_t
arenaId
;
#
endif
#
ifdef
__cplusplus
jemalloc_ptr_info_s
(
)
=
default
;
jemalloc_ptr_info_s
(
enum
PtrInfoTag
aTag
void
*
aAddr
size_t
aSize
arena_id_t
aArenaId
)
:
tag
(
aTag
)
addr
(
aAddr
)
size
(
aSize
)
#
ifdef
MOZ_DEBUG
arenaId
(
aArenaId
)
#
endif
{
}
#
endif
}
jemalloc_ptr_info_t
;
static
inline
bool
jemalloc_ptr_is_live
(
jemalloc_ptr_info_t
*
info
)
{
return
info
-
>
tag
=
=
TagLiveAlloc
;
}
static
inline
bool
jemalloc_ptr_is_freed
(
jemalloc_ptr_info_t
*
info
)
{
return
info
-
>
tag
=
=
TagFreedAlloc
|
|
info
-
>
tag
=
=
TagFreedPage
;
}
static
inline
bool
jemalloc_ptr_is_freed_page
(
jemalloc_ptr_info_t
*
info
)
{
return
info
-
>
tag
=
=
TagFreedPage
;
}
#
ifdef
__cplusplus
}
#
endif
#
endif
