#
ifndef
PHC_h
#
define
PHC_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
<
stdint
.
h
>
#
include
<
stdlib
.
h
>
#
include
"
mozmemory_wrap
.
h
"
namespace
mozilla
{
namespace
phc
{
struct
StackTrace
{
public
:
static
const
size_t
kMaxFrames
=
16
;
size_t
mLength
;
const
void
*
mPcs
[
kMaxFrames
]
;
public
:
StackTrace
(
)
:
mLength
(
0
)
{
}
}
;
class
AddrInfo
{
public
:
enum
class
Kind
{
Unknown
=
0
NeverAllocatedPage
=
1
InUsePage
=
2
FreedPage
=
3
GuardPage
=
4
}
;
Kind
mKind
;
const
void
*
mBaseAddr
;
size_t
mUsableSize
;
mozilla
:
:
Maybe
<
StackTrace
>
mAllocStack
;
mozilla
:
:
Maybe
<
StackTrace
>
mFreeStack
;
bool
mPhcWasLocked
=
false
;
AddrInfo
(
)
:
mKind
(
Kind
:
:
Unknown
)
mBaseAddr
(
nullptr
)
mUsableSize
(
0
)
{
}
}
;
extern
AddrInfo
gAddrInfo
;
MOZ_JEMALLOC_API
bool
IsPHCAllocation
(
const
void
*
AddrInfo
*
)
;
MOZ_JEMALLOC_API
void
DisablePHCOnCurrentThread
(
)
;
MOZ_JEMALLOC_API
void
ReenablePHCOnCurrentThread
(
)
;
MOZ_JEMALLOC_API
bool
IsPHCEnabledOnCurrentThread
(
)
;
enum
PHCState
{
OnlyFree
Enabled
}
;
MOZ_JEMALLOC_API
void
SetPHCState
(
PHCState
aState
)
;
MOZ_JEMALLOC_API
void
SetPHCSize
(
size_t
aNumPHCBytes
)
;
MOZ_JEMALLOC_API
void
SetPHCProbabilities
(
int64_t
aAvgDelayFirst
int64_t
aAvgDelayNormal
int64_t
aAvgDelayPageReuse
)
;
struct
MemoryUsage
{
size_t
mMetadataBytes
=
0
;
size_t
mFragmentationBytes
=
0
;
size_t
mAllocatedBytes
=
0
;
}
;
MOZ_JEMALLOC_API
void
PHCMemoryUsage
(
MemoryUsage
&
aMemoryUsage
)
;
struct
PHCStats
{
size_t
mSlotsAllocated
=
0
;
size_t
mSlotsFreed
=
0
;
size_t
mSlotsUnused
=
0
;
}
;
MOZ_JEMALLOC_API
void
GetPHCStats
(
PHCStats
&
aStats
)
;
}
}
void
phc_init
(
)
;
#
endif
