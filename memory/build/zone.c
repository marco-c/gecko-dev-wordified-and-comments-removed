#
include
"
mozmemory_wrap
.
h
"
#
include
<
stdlib
.
h
>
#
include
<
malloc
/
malloc
.
h
>
#
include
"
mozilla
/
Assertions
.
h
"
#
define
MALLOC_DECL
(
name
return_type
.
.
.
)
\
MOZ_MEMORY_API
return_type
name
#
#
_impl
(
__VA_ARGS__
)
;
#
define
MALLOC_FUNCS
MALLOC_FUNCS_MALLOC
#
include
"
malloc_decls
.
h
"
#
define
MALLOC_DECL
(
name
return_type
.
.
.
)
\
MOZ_JEMALLOC_API
return_type
name
#
#
_impl
(
__VA_ARGS__
)
;
#
define
MALLOC_FUNCS
MALLOC_FUNCS_JEMALLOC
#
include
"
malloc_decls
.
h
"
static
size_t
zone_size
(
malloc_zone_t
*
zone
void
*
ptr
)
{
return
malloc_usable_size_impl
(
ptr
)
;
}
static
void
*
zone_malloc
(
malloc_zone_t
*
zone
size_t
size
)
{
return
malloc_impl
(
size
)
;
}
static
void
*
zone_calloc
(
malloc_zone_t
*
zone
size_t
num
size_t
size
)
{
return
calloc_impl
(
num
size
)
;
}
static
void
*
zone_realloc
(
malloc_zone_t
*
zone
void
*
ptr
size_t
size
)
{
if
(
malloc_usable_size_impl
(
ptr
)
)
return
realloc_impl
(
ptr
size
)
;
return
realloc
(
ptr
size
)
;
}
static
void
zone_free
(
malloc_zone_t
*
zone
void
*
ptr
)
{
if
(
malloc_usable_size_impl
(
ptr
)
)
{
free_impl
(
ptr
)
;
return
;
}
free
(
ptr
)
;
}
static
void
zone_free_definite_size
(
malloc_zone_t
*
zone
void
*
ptr
size_t
size
)
{
size_t
current_size
=
malloc_usable_size_impl
(
ptr
)
;
if
(
current_size
)
{
MOZ_ASSERT
(
current_size
=
=
size
)
;
free_impl
(
ptr
)
;
return
;
}
free
(
ptr
)
;
}
static
void
*
zone_memalign
(
malloc_zone_t
*
zone
size_t
alignment
size_t
size
)
{
void
*
ptr
;
if
(
posix_memalign_impl
(
&
ptr
alignment
size
)
=
=
0
)
return
ptr
;
return
NULL
;
}
static
void
*
zone_valloc
(
malloc_zone_t
*
zone
size_t
size
)
{
return
valloc_impl
(
size
)
;
}
static
void
*
zone_destroy
(
malloc_zone_t
*
zone
)
{
MOZ_CRASH
(
)
;
}
static
size_t
zone_good_size
(
malloc_zone_t
*
zone
size_t
size
)
{
return
malloc_good_size_impl
(
size
)
;
}
#
ifdef
MOZ_JEMALLOC
#
include
"
jemalloc
/
internal
/
jemalloc_internal
.
h
"
static
void
zone_force_lock
(
malloc_zone_t
*
zone
)
{
if
(
isthreaded
)
jemalloc_prefork
(
)
;
}
static
void
zone_force_unlock
(
malloc_zone_t
*
zone
)
{
if
(
isthreaded
)
jemalloc_postfork_parent
(
)
;
}
#
else
#
define
JEMALLOC_ZONE_VERSION
6
extern
void
_malloc_prefork
(
void
)
;
extern
void
_malloc_postfork
(
void
)
;
static
void
zone_force_lock
(
malloc_zone_t
*
zone
)
{
_malloc_prefork
(
)
;
}
static
void
zone_force_unlock
(
malloc_zone_t
*
zone
)
{
_malloc_postfork
(
)
;
}
#
endif
static
malloc_zone_t
zone
;
static
struct
malloc_introspection_t
zone_introspect
;
static
malloc_zone_t
*
get_default_zone
(
)
{
malloc_zone_t
*
*
zones
=
NULL
;
unsigned
int
num_zones
=
0
;
if
(
KERN_SUCCESS
!
=
malloc_get_all_zones
(
0
NULL
(
vm_address_t
*
*
)
&
zones
&
num_zones
)
)
{
num_zones
=
0
;
}
if
(
num_zones
)
{
return
zones
[
0
]
;
}
return
malloc_default_zone
(
)
;
}
__attribute__
(
(
constructor
)
)
void
register_zone
(
void
)
{
malloc_zone_t
*
default_zone
=
get_default_zone
(
)
;
zone
.
size
=
(
void
*
)
zone_size
;
zone
.
malloc
=
(
void
*
)
zone_malloc
;
zone
.
calloc
=
(
void
*
)
zone_calloc
;
zone
.
valloc
=
(
void
*
)
zone_valloc
;
zone
.
free
=
(
void
*
)
zone_free
;
zone
.
realloc
=
(
void
*
)
zone_realloc
;
zone
.
destroy
=
(
void
*
)
zone_destroy
;
zone
.
zone_name
=
"
replace_malloc_zone
"
;
zone
.
batch_malloc
=
NULL
;
zone
.
batch_free
=
NULL
;
zone
.
introspect
=
&
zone_introspect
;
zone
.
version
=
JEMALLOC_ZONE_VERSION
;
zone
.
memalign
=
zone_memalign
;
zone
.
free_definite_size
=
zone_free_definite_size
;
#
if
(
JEMALLOC_ZONE_VERSION
>
=
8
)
zone
.
pressure_relief
=
NULL
;
#
endif
zone_introspect
.
enumerator
=
NULL
;
zone_introspect
.
good_size
=
(
void
*
)
zone_good_size
;
zone_introspect
.
check
=
NULL
;
zone_introspect
.
print
=
NULL
;
zone_introspect
.
log
=
NULL
;
zone_introspect
.
force_lock
=
(
void
*
)
zone_force_lock
;
zone_introspect
.
force_unlock
=
(
void
*
)
zone_force_unlock
;
zone_introspect
.
statistics
=
NULL
;
zone_introspect
.
zone_locked
=
NULL
;
#
if
(
JEMALLOC_ZONE_VERSION
>
=
7
)
zone_introspect
.
enable_discharge_checking
=
NULL
;
zone_introspect
.
disable_discharge_checking
=
NULL
;
zone_introspect
.
discharge
=
NULL
;
#
ifdef
__BLOCKS__
zone_introspect
.
enumerate_discharged_pointers
=
NULL
;
#
else
zone_introspect
.
enumerate_unavailable_without_blocks
=
NULL
;
#
endif
#
endif
malloc_zone_t
*
purgeable_zone
=
malloc_default_purgeable_zone
(
)
;
malloc_zone_register
(
&
zone
)
;
do
{
malloc_zone_unregister
(
default_zone
)
;
malloc_zone_register
(
default_zone
)
;
malloc_zone_unregister
(
purgeable_zone
)
;
malloc_zone_register
(
purgeable_zone
)
;
default_zone
=
get_default_zone
(
)
;
}
while
(
default_zone
!
=
&
zone
)
;
}
