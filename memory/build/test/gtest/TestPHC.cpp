#
include
"
gtest
/
gtest
.
h
"
#
include
"
mozmemory
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
mozilla
/
StaticPrefs_memory
.
h
"
#
include
"
PHC
.
h
"
using
namespace
mozilla
;
bool
PHCInfoEq
(
phc
:
:
AddrInfo
&
aInfo
phc
:
:
AddrInfo
:
:
Kind
aKind
void
*
aBaseAddr
size_t
aUsableSize
bool
aHasAllocStack
bool
aHasFreeStack
)
{
return
aInfo
.
mKind
=
=
aKind
&
&
aInfo
.
mBaseAddr
=
=
aBaseAddr
&
&
aInfo
.
mUsableSize
=
=
aUsableSize
&
&
(
aHasAllocStack
?
(
aInfo
.
mAllocStack
-
>
mLength
>
2
)
:
(
aInfo
.
mAllocStack
.
isNothing
(
)
)
)
&
&
(
aHasFreeStack
?
(
aInfo
.
mFreeStack
-
>
mLength
>
2
)
:
(
aInfo
.
mFreeStack
.
isNothing
(
)
)
)
;
}
bool
JeInfoEq
(
jemalloc_ptr_info_t
&
aInfo
PtrInfoTag
aTag
void
*
aAddr
size_t
aSize
arena_id_t
arenaId
)
{
return
aInfo
.
tag
=
=
aTag
&
&
aInfo
.
addr
=
=
aAddr
&
&
aInfo
.
size
=
=
aSize
#
ifdef
MOZ_DEBUG
&
&
aInfo
.
arenaId
=
=
arenaId
#
endif
;
}
uint8_t
*
GetPHCAllocation
(
size_t
aSize
size_t
aAlignment
=
1
)
{
for
(
int
i
=
0
;
i
<
2000000
;
i
+
+
)
{
void
*
p
=
(
aAlignment
=
=
1
)
?
moz_xmalloc
(
aSize
)
:
moz_xmemalign
(
aAlignment
aSize
)
;
if
(
mozilla
:
:
phc
:
:
IsPHCAllocation
(
p
nullptr
)
)
{
return
(
uint8_t
*
)
p
;
}
free
(
p
)
;
}
return
nullptr
;
}
#
if
defined
(
XP_DARWIN
)
&
&
defined
(
__aarch64__
)
static
const
size_t
kPageSize
=
16384
;
#
else
static
const
size_t
kPageSize
=
4096
;
#
endif
TEST
(
PHC
TestPHCAllocations
)
{
mozilla
:
:
phc
:
:
SetPHCState
(
phc
:
:
PHCState
:
:
Enabled
)
;
#
define
ASSERT_POS
(
n1
n2
)
\
p
=
(
uint8_t
*
)
moz_xrealloc
(
p
(
n1
)
)
;
\
ASSERT_EQ
(
(
reinterpret_cast
<
uintptr_t
>
(
p
)
&
(
kPageSize
-
1
)
)
\
kPageSize
-
(
n2
)
)
;
\
ASSERT_EQ
(
moz_malloc_usable_size
(
p
)
(
n2
)
)
;
uint8_t
*
p
=
GetPHCAllocation
(
1
)
;
if
(
!
p
)
{
MOZ_CRASH
(
"
failed
to
get
a
PHC
allocation
"
)
;
}
#
if
defined
(
XP_WIN
)
&
&
defined
(
HAVE_64BIT_BUILD
)
ASSERT_POS
(
8U
16U
)
;
#
else
ASSERT_POS
(
8U
8U
)
;
#
endif
for
(
unsigned
i
=
16
;
i
<
=
kPageSize
;
i
*
=
2
)
{
ASSERT_POS
(
i
i
)
;
}
free
(
p
)
;
#
undef
ASSERT_POS
#
define
ASSERT_ALIGN
(
a1
a2
)
\
p
=
(
uint8_t
*
)
GetPHCAllocation
(
8
(
a1
)
)
;
\
ASSERT_EQ
(
(
reinterpret_cast
<
uintptr_t
>
(
p
)
&
(
kPageSize
-
1
)
)
\
kPageSize
-
(
a2
)
)
;
\
ASSERT_EQ
(
moz_malloc_usable_size
(
p
)
(
a2
)
)
;
\
free
(
p
)
;
\
p
=
(
uint8_t
*
)
moz_xmemalign
(
(
a1
)
8
)
;
\
ASSERT_EQ
(
moz_malloc_usable_size
(
p
)
(
a2
)
)
;
\
free
(
p
)
;
#
if
defined
(
XP_WIN
)
&
&
defined
(
HAVE_64BIT_BUILD
)
ASSERT_ALIGN
(
8U
16U
)
;
#
else
ASSERT_ALIGN
(
8U
8U
)
;
#
endif
for
(
unsigned
i
=
16
;
i
<
=
kPageSize
;
i
*
=
2
)
{
ASSERT_ALIGN
(
i
i
)
;
}
#
undef
ASSERT_ALIGN
}
static
void
TestInUseAllocation
(
uint8_t
*
aPtr
size_t
aSize
)
{
phc
:
:
AddrInfo
phcInfo
;
jemalloc_ptr_info_t
jeInfo
;
ASSERT_TRUE
(
mozilla
:
:
phc
:
:
IsPHCAllocation
(
aPtr
&
phcInfo
)
)
;
ASSERT_TRUE
(
PHCInfoEq
(
phcInfo
phc
:
:
AddrInfo
:
:
Kind
:
:
InUsePage
aPtr
aSize
true
false
)
)
;
ASSERT_EQ
(
moz_malloc_usable_size
(
aPtr
)
aSize
)
;
jemalloc_ptr_info
(
aPtr
&
jeInfo
)
;
ASSERT_TRUE
(
JeInfoEq
(
jeInfo
TagLiveAlloc
aPtr
aSize
0
)
)
;
ASSERT_TRUE
(
mozilla
:
:
phc
:
:
IsPHCAllocation
(
aPtr
+
aSize
-
1
&
phcInfo
)
)
;
ASSERT_TRUE
(
PHCInfoEq
(
phcInfo
phc
:
:
AddrInfo
:
:
Kind
:
:
InUsePage
aPtr
aSize
true
false
)
)
;
ASSERT_EQ
(
moz_malloc_usable_size
(
aPtr
+
aSize
-
1
)
aSize
)
;
jemalloc_ptr_info
(
aPtr
+
aSize
-
1
&
jeInfo
)
;
ASSERT_TRUE
(
JeInfoEq
(
jeInfo
TagLiveAlloc
aPtr
aSize
0
)
)
;
ASSERT_TRUE
(
mozilla
:
:
phc
:
:
IsPHCAllocation
(
aPtr
-
1
&
phcInfo
)
)
;
ASSERT_TRUE
(
PHCInfoEq
(
phcInfo
phc
:
:
AddrInfo
:
:
Kind
:
:
InUsePage
aPtr
aSize
true
false
)
)
;
ASSERT_EQ
(
moz_malloc_usable_size
(
aPtr
-
1
)
0ul
)
;
jemalloc_ptr_info
(
aPtr
-
1
&
jeInfo
)
;
ASSERT_TRUE
(
JeInfoEq
(
jeInfo
TagUnknown
nullptr
0
0
)
)
;
ASSERT_TRUE
(
mozilla
:
:
phc
:
:
IsPHCAllocation
(
aPtr
+
aSize
-
kPageSize
&
phcInfo
)
)
;
ASSERT_TRUE
(
PHCInfoEq
(
phcInfo
phc
:
:
AddrInfo
:
:
Kind
:
:
InUsePage
aPtr
aSize
true
false
)
)
;
jemalloc_ptr_info
(
aPtr
+
aSize
-
kPageSize
&
jeInfo
)
;
ASSERT_TRUE
(
JeInfoEq
(
jeInfo
TagUnknown
nullptr
0
0
)
)
;
ASSERT_TRUE
(
mozilla
:
:
phc
:
:
IsPHCAllocation
(
aPtr
+
aSize
&
phcInfo
)
)
;
ASSERT_TRUE
(
PHCInfoEq
(
phcInfo
phc
:
:
AddrInfo
:
:
Kind
:
:
GuardPage
aPtr
aSize
true
false
)
)
;
jemalloc_ptr_info
(
aPtr
+
aSize
&
jeInfo
)
;
ASSERT_TRUE
(
JeInfoEq
(
jeInfo
TagUnknown
nullptr
0
0
)
)
;
ASSERT_TRUE
(
mozilla
:
:
phc
:
:
IsPHCAllocation
(
aPtr
+
aSize
+
(
kPageSize
/
2
-
1
)
&
phcInfo
)
)
;
ASSERT_TRUE
(
PHCInfoEq
(
phcInfo
phc
:
:
AddrInfo
:
:
Kind
:
:
GuardPage
aPtr
aSize
true
false
)
)
;
jemalloc_ptr_info
(
aPtr
+
aSize
+
(
kPageSize
/
2
-
1
)
&
jeInfo
)
;
ASSERT_TRUE
(
JeInfoEq
(
jeInfo
TagUnknown
nullptr
0
0
)
)
;
ASSERT_TRUE
(
mozilla
:
:
phc
:
:
IsPHCAllocation
(
aPtr
+
aSize
-
1
-
kPageSize
&
phcInfo
)
)
;
ASSERT_TRUE
(
PHCInfoEq
(
phcInfo
phc
:
:
AddrInfo
:
:
Kind
:
:
GuardPage
aPtr
aSize
true
false
)
)
;
jemalloc_ptr_info
(
aPtr
+
aSize
-
1
-
kPageSize
&
jeInfo
)
;
ASSERT_TRUE
(
JeInfoEq
(
jeInfo
TagUnknown
nullptr
0
0
)
)
;
ASSERT_TRUE
(
mozilla
:
:
phc
:
:
IsPHCAllocation
(
aPtr
+
aSize
-
1
-
kPageSize
-
(
kPageSize
/
2
-
1
)
&
phcInfo
)
)
;
ASSERT_TRUE
(
PHCInfoEq
(
phcInfo
phc
:
:
AddrInfo
:
:
Kind
:
:
GuardPage
aPtr
aSize
true
false
)
)
;
jemalloc_ptr_info
(
aPtr
+
aSize
-
1
-
kPageSize
-
(
kPageSize
/
2
-
1
)
&
jeInfo
)
;
ASSERT_TRUE
(
JeInfoEq
(
jeInfo
TagUnknown
nullptr
0
0
)
)
;
}
static
void
TestFreedAllocation
(
uint8_t
*
aPtr
size_t
aSize
)
{
phc
:
:
AddrInfo
phcInfo
;
jemalloc_ptr_info_t
jeInfo
;
ASSERT_TRUE
(
mozilla
:
:
phc
:
:
IsPHCAllocation
(
aPtr
&
phcInfo
)
)
;
ASSERT_TRUE
(
PHCInfoEq
(
phcInfo
phc
:
:
AddrInfo
:
:
Kind
:
:
FreedPage
aPtr
aSize
true
true
)
)
;
jemalloc_ptr_info
(
aPtr
&
jeInfo
)
;
ASSERT_TRUE
(
JeInfoEq
(
jeInfo
TagFreedAlloc
aPtr
aSize
0
)
)
;
ASSERT_TRUE
(
mozilla
:
:
phc
:
:
IsPHCAllocation
(
aPtr
+
aSize
-
1
&
phcInfo
)
)
;
ASSERT_TRUE
(
PHCInfoEq
(
phcInfo
phc
:
:
AddrInfo
:
:
Kind
:
:
FreedPage
aPtr
aSize
true
true
)
)
;
jemalloc_ptr_info
(
aPtr
+
aSize
-
1
&
jeInfo
)
;
ASSERT_TRUE
(
JeInfoEq
(
jeInfo
TagFreedAlloc
aPtr
aSize
0
)
)
;
ASSERT_TRUE
(
mozilla
:
:
phc
:
:
IsPHCAllocation
(
aPtr
-
1
&
phcInfo
)
)
;
ASSERT_TRUE
(
PHCInfoEq
(
phcInfo
phc
:
:
AddrInfo
:
:
Kind
:
:
FreedPage
aPtr
aSize
true
true
)
)
;
jemalloc_ptr_info
(
aPtr
-
1
&
jeInfo
)
;
ASSERT_TRUE
(
JeInfoEq
(
jeInfo
TagUnknown
nullptr
0
0
)
)
;
ASSERT_TRUE
(
mozilla
:
:
phc
:
:
IsPHCAllocation
(
aPtr
+
aSize
-
kPageSize
&
phcInfo
)
)
;
ASSERT_TRUE
(
PHCInfoEq
(
phcInfo
phc
:
:
AddrInfo
:
:
Kind
:
:
FreedPage
aPtr
aSize
true
true
)
)
;
jemalloc_ptr_info
(
aPtr
+
aSize
-
kPageSize
&
jeInfo
)
;
ASSERT_TRUE
(
JeInfoEq
(
jeInfo
TagUnknown
nullptr
0
0
)
)
;
ASSERT_TRUE
(
mozilla
:
:
phc
:
:
IsPHCAllocation
(
aPtr
+
aSize
&
phcInfo
)
)
;
ASSERT_TRUE
(
PHCInfoEq
(
phcInfo
phc
:
:
AddrInfo
:
:
Kind
:
:
GuardPage
aPtr
aSize
true
true
)
)
;
jemalloc_ptr_info
(
aPtr
+
aSize
&
jeInfo
)
;
ASSERT_TRUE
(
JeInfoEq
(
jeInfo
TagUnknown
nullptr
0
0
)
)
;
ASSERT_TRUE
(
mozilla
:
:
phc
:
:
IsPHCAllocation
(
aPtr
+
aSize
+
(
kPageSize
/
2
-
1
)
&
phcInfo
)
)
;
ASSERT_TRUE
(
PHCInfoEq
(
phcInfo
phc
:
:
AddrInfo
:
:
Kind
:
:
GuardPage
aPtr
aSize
true
true
)
)
;
jemalloc_ptr_info
(
aPtr
+
aSize
+
(
kPageSize
/
2
-
1
)
&
jeInfo
)
;
ASSERT_TRUE
(
JeInfoEq
(
jeInfo
TagUnknown
nullptr
0
0
)
)
;
ASSERT_TRUE
(
mozilla
:
:
phc
:
:
IsPHCAllocation
(
aPtr
+
aSize
-
1
-
kPageSize
&
phcInfo
)
)
;
ASSERT_TRUE
(
PHCInfoEq
(
phcInfo
phc
:
:
AddrInfo
:
:
Kind
:
:
GuardPage
aPtr
aSize
true
true
)
)
;
jemalloc_ptr_info
(
aPtr
+
aSize
-
1
-
kPageSize
&
jeInfo
)
;
ASSERT_TRUE
(
JeInfoEq
(
jeInfo
TagUnknown
nullptr
0
0
)
)
;
ASSERT_TRUE
(
mozilla
:
:
phc
:
:
IsPHCAllocation
(
aPtr
+
aSize
-
1
-
kPageSize
-
(
kPageSize
/
2
-
1
)
&
phcInfo
)
)
;
ASSERT_TRUE
(
PHCInfoEq
(
phcInfo
phc
:
:
AddrInfo
:
:
Kind
:
:
GuardPage
aPtr
aSize
true
true
)
)
;
jemalloc_ptr_info
(
aPtr
+
aSize
-
1
-
kPageSize
-
(
kPageSize
/
2
-
1
)
&
jeInfo
)
;
ASSERT_TRUE
(
JeInfoEq
(
jeInfo
TagUnknown
nullptr
0
0
)
)
;
}
TEST
(
PHC
TestPHCInfo
)
{
mozilla
:
:
phc
:
:
SetPHCState
(
phc
:
:
PHCState
:
:
Enabled
)
;
int
stackVar
=
0
;
phc
:
:
AddrInfo
phcInfo
;
ASSERT_TRUE
(
PHCInfoEq
(
phcInfo
phc
:
:
AddrInfo
:
:
Kind
:
:
Unknown
nullptr
0ul
false
false
)
)
;
ASSERT_FALSE
(
mozilla
:
:
phc
:
:
IsPHCAllocation
(
nullptr
&
phcInfo
)
)
;
ASSERT_TRUE
(
PHCInfoEq
(
phcInfo
phc
:
:
AddrInfo
:
:
Kind
:
:
Unknown
nullptr
0
false
false
)
)
;
ASSERT_FALSE
(
mozilla
:
:
phc
:
:
IsPHCAllocation
(
&
stackVar
&
phcInfo
)
)
;
ASSERT_TRUE
(
PHCInfoEq
(
phcInfo
phc
:
:
AddrInfo
:
:
Kind
:
:
Unknown
nullptr
0
false
false
)
)
;
uint8_t
*
p
=
GetPHCAllocation
(
32
)
;
if
(
!
p
)
{
MOZ_CRASH
(
"
failed
to
get
a
PHC
allocation
"
)
;
}
TestInUseAllocation
(
p
32
)
;
free
(
p
)
;
TestFreedAllocation
(
p
32
)
;
}
TEST
(
PHC
TestPHCDisablingThread
)
{
mozilla
:
:
phc
:
:
SetPHCState
(
phc
:
:
PHCState
:
:
Enabled
)
;
uint8_t
*
p
=
GetPHCAllocation
(
32
)
;
uint8_t
*
q
=
GetPHCAllocation
(
32
)
;
if
(
!
p
|
|
!
q
)
{
MOZ_CRASH
(
"
failed
to
get
a
PHC
allocation
"
)
;
}
ASSERT_TRUE
(
mozilla
:
:
phc
:
:
IsPHCEnabledOnCurrentThread
(
)
)
;
mozilla
:
:
phc
:
:
DisablePHCOnCurrentThread
(
)
;
ASSERT_FALSE
(
mozilla
:
:
phc
:
:
IsPHCEnabledOnCurrentThread
(
)
)
;
uint8_t
*
p2
=
(
uint8_t
*
)
realloc
(
p
128
)
;
ASSERT_TRUE
(
p2
=
=
p
-
96
)
;
ASSERT_TRUE
(
mozilla
:
:
phc
:
:
IsPHCAllocation
(
p2
nullptr
)
)
;
uint8_t
*
p3
=
(
uint8_t
*
)
realloc
(
p2
2
*
kPageSize
)
;
ASSERT_TRUE
(
p3
!
=
p2
)
;
ASSERT_FALSE
(
mozilla
:
:
phc
:
:
IsPHCAllocation
(
p3
nullptr
)
)
;
free
(
p3
)
;
free
(
q
)
;
uint8_t
*
r
=
GetPHCAllocation
(
32
)
;
ASSERT_FALSE
(
!
!
r
)
;
mozilla
:
:
phc
:
:
ReenablePHCOnCurrentThread
(
)
;
ASSERT_TRUE
(
mozilla
:
:
phc
:
:
IsPHCEnabledOnCurrentThread
(
)
)
;
uint8_t
*
s
=
GetPHCAllocation
(
32
)
;
ASSERT_TRUE
(
!
!
s
)
;
free
(
s
)
;
}
TEST
(
PHC
TestPHCDisablingGlobal
)
{
mozilla
:
:
phc
:
:
SetPHCState
(
phc
:
:
PHCState
:
:
Enabled
)
;
uint8_t
*
p1
=
GetPHCAllocation
(
32
)
;
uint8_t
*
p2
=
GetPHCAllocation
(
32
)
;
uint8_t
*
q
=
GetPHCAllocation
(
32
)
;
if
(
!
p1
|
|
!
p2
|
|
!
q
)
{
MOZ_CRASH
(
"
failed
to
get
a
PHC
allocation
"
)
;
}
mozilla
:
:
phc
:
:
SetPHCState
(
phc
:
:
PHCState
:
:
OnlyFree
)
;
uint8_t
*
p3
=
(
uint8_t
*
)
realloc
(
p1
128
)
;
ASSERT_TRUE
(
p3
!
=
p1
)
;
ASSERT_FALSE
(
mozilla
:
:
phc
:
:
IsPHCAllocation
(
p3
nullptr
)
)
;
free
(
p3
)
;
uint8_t
*
p4
=
(
uint8_t
*
)
realloc
(
p2
2
*
kPageSize
)
;
ASSERT_TRUE
(
p4
!
=
p2
)
;
ASSERT_FALSE
(
mozilla
:
:
phc
:
:
IsPHCAllocation
(
p4
nullptr
)
)
;
free
(
p4
)
;
free
(
q
)
;
uint8_t
*
r
=
GetPHCAllocation
(
32
)
;
ASSERT_FALSE
(
!
!
r
)
;
mozilla
:
:
phc
:
:
SetPHCState
(
phc
:
:
PHCState
:
:
Enabled
)
;
uint8_t
*
s
=
GetPHCAllocation
(
32
)
;
ASSERT_TRUE
(
!
!
s
)
;
free
(
s
)
;
}
size_t
GetNumAvailable
(
)
{
mozilla
:
:
phc
:
:
PHCStats
stats
;
GetPHCStats
(
stats
)
;
return
stats
.
mSlotsFreed
+
stats
.
mSlotsUnused
;
}
TEST
(
PHC
TestPHCExhaustion
)
{
size_t
num_allocations
=
GetNumAvailable
(
)
;
mozilla
:
:
phc
:
:
DisablePHCOnCurrentThread
(
)
;
std
:
:
vector
<
uint8_t
*
>
allocations
(
num_allocations
)
;
mozilla
:
:
phc
:
:
ReenablePHCOnCurrentThread
(
)
;
mozilla
:
:
phc
:
:
SetPHCProbabilities
(
64
64
0
)
;
for
(
auto
&
a
:
allocations
)
{
a
=
GetPHCAllocation
(
128
)
;
ASSERT_TRUE
(
a
)
;
TestInUseAllocation
(
a
128
)
;
}
ASSERT_EQ
(
0ul
GetNumAvailable
(
)
)
;
ASSERT_FALSE
(
GetPHCAllocation
(
128
)
)
;
for
(
auto
&
a
:
allocations
)
{
free
(
a
)
;
TestFreedAllocation
(
a
128
)
;
}
ASSERT_TRUE
(
GetNumAvailable
(
)
!
=
0
)
;
uint8_t
*
r
=
GetPHCAllocation
(
128
)
;
ASSERT_TRUE
(
!
!
r
)
;
free
(
r
)
;
mozilla
:
:
phc
:
:
SetPHCProbabilities
(
StaticPrefs
:
:
memory_phc_avg_delay_first
(
)
StaticPrefs
:
:
memory_phc_avg_delay_normal
(
)
StaticPrefs
:
:
memory_phc_avg_delay_page_reuse
(
)
)
;
}
