#
ifndef
RADIX_TREE_H
#
define
RADIX_TREE_H
#
include
"
mozilla
/
ThreadSafety
.
h
"
#
include
"
Constants
.
h
"
#
include
"
Utils
.
h
"
#
include
"
BaseAlloc
.
h
"
#
include
"
Mutex
.
h
"
template
<
size_t
Bits
>
class
AddressRadixTree
{
#
ifdef
HAVE_64BIT_BUILD
static
const
size_t
kNodeSize
=
kCacheLineSize
;
#
else
static
const
size_t
kNodeSize
=
16_KiB
;
#
endif
static
const
size_t
kBitsPerLevel
=
LOG2
(
kNodeSize
)
-
LOG2
(
sizeof
(
void
*
)
)
;
static
const
size_t
kBitsAtLevel1
=
(
Bits
%
kBitsPerLevel
)
?
Bits
%
kBitsPerLevel
:
kBitsPerLevel
;
static
const
size_t
kHeight
=
(
Bits
+
kBitsPerLevel
-
1
)
/
kBitsPerLevel
;
static_assert
(
kBitsAtLevel1
+
(
kHeight
-
1
)
*
kBitsPerLevel
=
=
Bits
"
AddressRadixTree
parameters
don
'
t
work
out
"
)
;
Mutex
mLock
MOZ_UNANNOTATED
;
void
*
*
mRoot
=
nullptr
;
public
:
constexpr
AddressRadixTree
(
)
{
}
bool
Init
(
)
MOZ_REQUIRES
(
gInitLock
)
MOZ_EXCLUDES
(
mLock
)
;
inline
void
*
Get
(
void
*
aAddr
)
MOZ_EXCLUDES
(
mLock
)
;
inline
bool
Set
(
void
*
aAddr
void
*
aValue
)
MOZ_EXCLUDES
(
mLock
)
;
inline
bool
Unset
(
void
*
aAddr
)
MOZ_EXCLUDES
(
mLock
)
{
return
Set
(
aAddr
nullptr
)
;
}
private
:
inline
void
*
*
GetSlotInternal
(
void
*
aAddr
bool
aCreate
)
;
inline
void
*
*
GetSlotIfExists
(
void
*
aAddr
)
MOZ_EXCLUDES
(
mLock
)
{
return
GetSlotInternal
(
aAddr
false
)
;
}
inline
void
*
*
GetOrCreateSlot
(
void
*
aAddr
)
MOZ_REQUIRES
(
mLock
)
{
return
GetSlotInternal
(
aAddr
true
)
;
}
}
;
template
<
size_t
Bits
>
bool
AddressRadixTree
<
Bits
>
:
:
Init
(
)
{
mLock
.
Init
(
)
;
mRoot
=
(
void
*
*
)
base_calloc
(
1
<
<
kBitsAtLevel1
sizeof
(
void
*
)
)
;
return
mRoot
;
}
template
<
size_t
Bits
>
void
*
*
AddressRadixTree
<
Bits
>
:
:
GetSlotInternal
(
void
*
aAddr
bool
aCreate
)
{
uintptr_t
key
=
reinterpret_cast
<
uintptr_t
>
(
aAddr
)
;
uintptr_t
subkey
;
unsigned
i
lshift
height
bits
;
void
*
*
node
;
void
*
*
child
;
for
(
i
=
lshift
=
0
height
=
kHeight
node
=
mRoot
;
i
<
height
-
1
;
i
+
+
lshift
+
=
bits
node
=
child
)
{
bits
=
i
?
kBitsPerLevel
:
kBitsAtLevel1
;
subkey
=
(
key
<
<
lshift
)
>
>
(
(
sizeof
(
void
*
)
<
<
3
)
-
bits
)
;
child
=
(
void
*
*
)
node
[
subkey
]
;
if
(
!
child
&
&
aCreate
)
{
child
=
(
void
*
*
)
base_calloc
(
1
<
<
kBitsPerLevel
sizeof
(
void
*
)
)
;
if
(
child
)
{
node
[
subkey
]
=
child
;
}
}
if
(
!
child
)
{
return
nullptr
;
}
}
bits
=
i
?
kBitsPerLevel
:
kBitsAtLevel1
;
subkey
=
(
key
<
<
lshift
)
>
>
(
(
sizeof
(
void
*
)
<
<
3
)
-
bits
)
;
return
&
node
[
subkey
]
;
}
template
<
size_t
Bits
>
void
*
AddressRadixTree
<
Bits
>
:
:
Get
(
void
*
aAddr
)
{
void
*
ret
=
nullptr
;
void
*
*
slot
=
GetSlotIfExists
(
aAddr
)
;
if
(
slot
)
{
ret
=
*
slot
;
}
#
ifdef
MOZ_DEBUG
MutexAutoLock
lock
(
mLock
)
;
if
(
!
slot
)
{
slot
=
GetSlotInternal
(
aAddr
false
)
;
}
if
(
slot
)
{
MOZ_ASSERT
(
ret
=
=
*
slot
)
;
}
else
{
MOZ_ASSERT
(
ret
=
=
nullptr
)
;
}
#
endif
return
ret
;
}
template
<
size_t
Bits
>
bool
AddressRadixTree
<
Bits
>
:
:
Set
(
void
*
aAddr
void
*
aValue
)
{
MutexAutoLock
lock
(
mLock
)
;
void
*
*
slot
=
GetOrCreateSlot
(
aAddr
)
;
if
(
slot
)
{
*
slot
=
aValue
;
}
return
slot
;
}
#
endif
