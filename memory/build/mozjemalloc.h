#
ifndef
mozjemalloc_h
#
define
mozjemalloc_h
#
include
<
errno
.
h
>
#
include
"
mozjemalloc_types
.
h
"
#
include
"
mozilla
/
MacroArgs
.
h
"
#
define
MACRO_CALL
(
a
b
)
a
b
#
define
MACRO_CALL2
(
a
b
)
a
b
#
define
ARGS_HELPER
(
name
.
.
.
)
\
MACRO_CALL2
(
MOZ_PASTE_PREFIX_AND_ARG_COUNT
(
name
#
#
__VA_ARGS__
)
\
(
__VA_ARGS__
)
)
#
define
TYPED_ARGS0
(
)
#
define
TYPED_ARGS1
(
t1
)
t1
arg1
#
define
TYPED_ARGS2
(
t1
t2
)
TYPED_ARGS1
(
t1
)
t2
arg2
#
define
TYPED_ARGS3
(
t1
t2
t3
)
TYPED_ARGS2
(
t1
t2
)
t3
arg3
#
define
ARGS0
(
)
#
define
ARGS1
(
t1
)
arg1
#
define
ARGS2
(
t1
t2
)
ARGS1
(
t1
)
arg2
#
define
ARGS3
(
t1
t2
t3
)
ARGS2
(
t1
t2
)
arg3
#
ifdef
MOZ_MEMORY
size_t
GetKernelPageSize
(
)
;
template
<
void
*
(
*
memalign
)
(
size_t
size_t
)
>
struct
AlignedAllocator
{
static
inline
int
posix_memalign
(
void
*
*
aMemPtr
size_t
aAlignment
size_t
aSize
)
{
void
*
result
;
if
(
(
(
aAlignment
-
1
)
&
aAlignment
)
!
=
0
|
|
aAlignment
<
sizeof
(
void
*
)
)
{
return
EINVAL
;
}
result
=
memalign
(
aAlignment
aSize
)
;
if
(
!
result
)
{
return
ENOMEM
;
}
*
aMemPtr
=
result
;
return
0
;
}
static
inline
void
*
aligned_alloc
(
size_t
aAlignment
size_t
aSize
)
{
if
(
aSize
%
aAlignment
)
{
return
nullptr
;
}
return
memalign
(
aAlignment
aSize
)
;
}
static
inline
void
*
valloc
(
size_t
aSize
)
{
return
memalign
(
GetKernelPageSize
(
)
aSize
)
;
}
}
;
struct
MozJemalloc
{
#
define
MALLOC_DECL
(
name
return_type
.
.
.
)
\
static
inline
return_type
name
(
__VA_ARGS__
)
;
#
include
"
malloc_decls
.
h
"
}
;
#
ifdef
MOZ_PHC
struct
MozJemallocPHC
:
public
MozJemalloc
{
#
define
MALLOC_DECL
(
name
return_type
.
.
.
)
\
static
return_type
name
(
__VA_ARGS__
)
;
#
define
MALLOC_FUNCS
MALLOC_FUNCS_MALLOC_BASE
#
include
"
malloc_decls
.
h
"
static
inline
int
posix_memalign
(
void
*
*
aMemPtr
size_t
aAlignment
size_t
aSize
)
{
return
AlignedAllocator
<
memalign
>
:
:
posix_memalign
(
aMemPtr
aAlignment
aSize
)
;
}
static
inline
void
*
aligned_alloc
(
size_t
aAlignment
size_t
aSize
)
{
return
AlignedAllocator
<
memalign
>
:
:
aligned_alloc
(
aAlignment
aSize
)
;
}
static
inline
void
*
valloc
(
size_t
aSize
)
{
return
AlignedAllocator
<
memalign
>
:
:
valloc
(
aSize
)
;
}
static
size_t
malloc_usable_size
(
usable_ptr_t
)
;
static
void
jemalloc_stats_internal
(
jemalloc_stats_t
*
jemalloc_bin_stats_t
*
)
;
static
void
jemalloc_ptr_info
(
const
void
*
jemalloc_ptr_info_t
*
)
;
#
define
MALLOC_DECL
(
name
return_type
.
.
.
)
\
static
return_type
name
(
__VA_ARGS__
)
;
#
define
MALLOC_FUNCS
MALLOC_FUNCS_ARENA_ALLOC
#
include
"
malloc_decls
.
h
"
}
;
#
endif
#
ifdef
MOZ_REPLACE_MALLOC
struct
ReplaceMalloc
{
#
define
MALLOC_DECL
(
name
return_type
.
.
.
)
\
static
return_type
name
(
__VA_ARGS__
)
;
#
include
"
malloc_decls
.
h
"
}
;
#
endif
#
ifdef
MOZ_PHC
using
CanonicalMalloc
=
MozJemallocPHC
;
#
else
using
CanonicalMalloc
=
MozJemalloc
;
#
endif
#
ifdef
MOZ_REPLACE_MALLOC
using
DefaultMalloc
=
ReplaceMalloc
;
#
else
using
DefaultMalloc
=
CanonicalMalloc
;
#
endif
constexpr
uint8_t
kAllocPoison
=
0xe5
;
constexpr
uint8_t
kAllocJunk
=
0xe4
;
constexpr
size_t
kCacheLineSize
=
#
if
defined
(
XP_DARWIN
)
&
&
defined
(
__aarch64__
)
128
#
else
64
#
endif
;
#
endif
template
<
typename
T
>
struct
DummyArenaAllocator
{
static
arena_id_t
moz_create_arena_with_params
(
arena_params_t
*
)
{
return
0
;
}
static
void
moz_dispose_arena
(
arena_id_t
)
{
}
static
void
moz_set_max_dirty_page_modifier
(
int32_t
)
{
}
#
define
MALLOC_DECL
(
name
return_type
.
.
.
)
\
static
return_type
moz_arena_
#
#
name
(
\
arena_id_t
ARGS_HELPER
(
TYPED_ARGS
#
#
__VA_ARGS__
)
)
{
\
return
T
:
:
name
(
ARGS_HELPER
(
ARGS
#
#
__VA_ARGS__
)
)
;
\
}
#
define
MALLOC_FUNCS
MALLOC_FUNCS_MALLOC_BASE
#
include
"
malloc_decls
.
h
"
}
;
#
endif
