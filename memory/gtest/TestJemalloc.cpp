#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
mozmemory
.
h
"
#
include
"
gtest
/
gtest
.
h
"
using
namespace
mozilla
;
static
inline
void
TestOne
(
size_t
size
)
{
size_t
req
=
size
;
size_t
adv
=
malloc_good_size
(
req
)
;
char
*
p
=
(
char
*
)
malloc
(
req
)
;
size_t
usable
=
moz_malloc_usable_size
(
p
)
;
EXPECT_EQ
(
adv
usable
)
<
<
"
malloc_good_size
(
"
<
<
req
<
<
"
)
-
-
>
"
<
<
adv
<
<
"
;
"
"
malloc_usable_size
(
"
<
<
req
<
<
"
)
-
-
>
"
<
<
usable
;
free
(
p
)
;
}
static
inline
void
TestThree
(
size_t
size
)
{
ASSERT_NO_FATAL_FAILURE
(
TestOne
(
size
-
1
)
)
;
ASSERT_NO_FATAL_FAILURE
(
TestOne
(
size
)
)
;
ASSERT_NO_FATAL_FAILURE
(
TestOne
(
size
+
1
)
)
;
}
#
define
K
*
1024
#
define
M
*
1024
*
1024
TEST
(
Jemalloc
UsableSizeInAdvance
)
{
for
(
size_t
n
=
0
;
n
<
16
K
;
n
+
+
)
ASSERT_NO_FATAL_FAILURE
(
TestOne
(
n
)
)
;
for
(
size_t
n
=
16
K
;
n
<
1
M
;
n
+
=
4
K
)
ASSERT_NO_FATAL_FAILURE
(
TestThree
(
n
)
)
;
for
(
size_t
n
=
1
M
;
n
<
8
M
;
n
+
=
128
K
)
ASSERT_NO_FATAL_FAILURE
(
TestThree
(
n
)
)
;
}
static
int
gStaticVar
;
bool
InfoEq
(
jemalloc_ptr_info_t
&
aInfo
PtrInfoTag
aTag
void
*
aAddr
size_t
aSize
)
{
return
aInfo
.
tag
=
=
aTag
&
&
aInfo
.
addr
=
=
aAddr
&
&
aInfo
.
size
=
=
aSize
;
}
bool
InfoEqFreedPage
(
jemalloc_ptr_info_t
&
aInfo
void
*
aAddr
size_t
aPageSize
)
{
size_t
pageSizeMask
=
aPageSize
-
1
;
return
jemalloc_ptr_is_freed_page
(
&
aInfo
)
&
&
aInfo
.
addr
=
=
(
void
*
)
(
uintptr_t
(
aAddr
)
&
~
pageSizeMask
)
&
&
aInfo
.
size
=
=
aPageSize
;
}
TEST
(
Jemalloc
PtrInfo
)
{
jemalloc_stats_t
stats
;
jemalloc_stats
(
&
stats
)
;
jemalloc_ptr_info_t
info
;
Vector
<
char
*
>
small
large
huge
;
size_t
small_max
=
stats
.
page_size
/
2
;
for
(
size_t
n
=
0
;
n
<
=
small_max
;
n
+
=
8
)
{
auto
p
=
(
char
*
)
malloc
(
n
)
;
size_t
usable
=
moz_malloc_size_of
(
p
)
;
ASSERT_TRUE
(
small
.
append
(
p
)
)
;
for
(
size_t
j
=
0
;
j
<
usable
;
j
+
+
)
{
jemalloc_ptr_info
(
&
p
[
j
]
&
info
)
;
ASSERT_TRUE
(
InfoEq
(
info
TagLiveSmall
p
usable
)
)
;
}
}
for
(
size_t
n
=
small_max
+
1
K
;
n
<
=
stats
.
large_max
;
n
+
=
1
K
)
{
auto
p
=
(
char
*
)
malloc
(
n
)
;
size_t
usable
=
moz_malloc_size_of
(
p
)
;
ASSERT_TRUE
(
large
.
append
(
p
)
)
;
for
(
size_t
j
=
0
;
j
<
usable
;
j
+
=
347
)
{
jemalloc_ptr_info
(
&
p
[
j
]
&
info
)
;
ASSERT_TRUE
(
InfoEq
(
info
TagLiveLarge
p
usable
)
)
;
}
}
for
(
size_t
n
=
stats
.
chunksize
;
n
<
=
10
M
;
n
+
=
512
K
)
{
auto
p
=
(
char
*
)
malloc
(
n
)
;
size_t
usable
=
moz_malloc_size_of
(
p
)
;
ASSERT_TRUE
(
huge
.
append
(
p
)
)
;
for
(
size_t
j
=
0
;
j
<
usable
;
j
+
=
567
)
{
jemalloc_ptr_info
(
&
p
[
j
]
&
info
)
;
ASSERT_TRUE
(
InfoEq
(
info
TagLiveHuge
p
usable
)
)
;
}
}
size_t
len
;
int
isFreedSmall
=
0
isFreedPage
=
0
;
len
=
small
.
length
(
)
;
for
(
size_t
i
=
0
j
=
0
;
i
<
len
;
i
+
+
j
=
(
j
+
19
)
%
len
)
{
char
*
p
=
small
[
j
]
;
size_t
usable
=
moz_malloc_size_of
(
p
)
;
free
(
p
)
;
for
(
size_t
k
=
0
;
k
<
usable
;
k
+
+
)
{
jemalloc_ptr_info
(
&
p
[
k
]
&
info
)
;
if
(
InfoEq
(
info
TagFreedSmall
p
usable
)
)
{
isFreedSmall
+
+
;
}
else
if
(
InfoEqFreedPage
(
info
&
p
[
k
]
stats
.
page_size
)
)
{
isFreedPage
+
+
;
}
else
{
ASSERT_TRUE
(
false
)
;
}
}
}
ASSERT_TRUE
(
isFreedSmall
/
isFreedPage
>
10
)
;
len
=
large
.
length
(
)
;
for
(
size_t
i
=
0
j
=
0
;
i
<
len
;
i
+
+
j
=
(
j
+
31
)
%
len
)
{
char
*
p
=
large
[
j
]
;
size_t
usable
=
moz_malloc_size_of
(
p
)
;
free
(
p
)
;
for
(
size_t
k
=
0
;
k
<
usable
;
k
+
=
357
)
{
jemalloc_ptr_info
(
&
p
[
k
]
&
info
)
;
ASSERT_TRUE
(
InfoEqFreedPage
(
info
&
p
[
k
]
stats
.
page_size
)
)
;
}
}
len
=
huge
.
length
(
)
;
for
(
size_t
i
=
0
j
=
0
;
i
<
len
;
i
+
+
j
=
(
j
+
7
)
%
len
)
{
char
*
p
=
huge
[
j
]
;
size_t
usable
=
moz_malloc_size_of
(
p
)
;
free
(
p
)
;
for
(
size_t
k
=
0
;
k
<
usable
;
k
+
=
587
)
{
jemalloc_ptr_info
(
&
p
[
k
]
&
info
)
;
ASSERT_TRUE
(
InfoEq
(
info
TagUnknown
nullptr
0U
)
)
;
}
}
jemalloc_ptr_info
(
nullptr
&
info
)
;
ASSERT_TRUE
(
InfoEq
(
info
TagUnknown
nullptr
0U
)
)
;
jemalloc_ptr_info
(
(
void
*
)
0x123
&
info
)
;
ASSERT_TRUE
(
InfoEq
(
info
TagUnknown
nullptr
0U
)
)
;
jemalloc_ptr_info
(
(
void
*
)
uintptr_t
(
-
1
)
&
info
)
;
ASSERT_TRUE
(
InfoEq
(
info
TagUnknown
nullptr
0U
)
)
;
int
stackVar
;
jemalloc_ptr_info
(
&
stackVar
&
info
)
;
ASSERT_TRUE
(
InfoEq
(
info
TagUnknown
nullptr
0U
)
)
;
jemalloc_ptr_info
(
(
const
void
*
)
&
jemalloc_ptr_info
&
info
)
;
ASSERT_TRUE
(
InfoEq
(
info
TagUnknown
nullptr
0U
)
)
;
jemalloc_ptr_info
(
&
gStaticVar
&
info
)
;
ASSERT_TRUE
(
InfoEq
(
info
TagUnknown
nullptr
0U
)
)
;
UniquePtr
<
int
>
p
=
MakeUnique
<
int
>
(
)
;
size_t
chunksizeMask
=
stats
.
chunksize
-
1
;
char
*
chunk
=
(
char
*
)
(
uintptr_t
(
p
.
get
(
)
)
&
~
chunksizeMask
)
;
size_t
chunkHeaderSize
=
stats
.
chunksize
-
stats
.
large_max
;
for
(
size_t
i
=
0
;
i
<
chunkHeaderSize
;
i
+
=
64
)
{
jemalloc_ptr_info
(
&
chunk
[
i
]
&
info
)
;
ASSERT_TRUE
(
InfoEq
(
info
TagUnknown
nullptr
0U
)
)
;
}
size_t
page_sizeMask
=
stats
.
page_size
-
1
;
char
*
run
=
(
char
*
)
(
uintptr_t
(
p
.
get
(
)
)
&
~
page_sizeMask
)
;
for
(
size_t
i
=
0
;
i
<
4
*
sizeof
(
void
*
)
;
i
+
+
)
{
jemalloc_ptr_info
(
&
run
[
i
]
&
info
)
;
ASSERT_TRUE
(
InfoEq
(
info
TagUnknown
nullptr
0U
)
)
;
}
for
(
size_t
i
=
0
;
i
<
stats
.
chunksize
;
i
+
=
256
)
{
jemalloc_ptr_info
(
&
chunk
[
i
]
&
info
)
;
}
}
#
undef
K
#
undef
M
