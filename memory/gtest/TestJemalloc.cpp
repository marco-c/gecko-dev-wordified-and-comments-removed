#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
mozmemory
.
h
"
#
include
"
Utils
.
h
"
#
include
"
gtest
/
gtest
.
h
"
#
ifdef
MOZ_CRASHREPORTER
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsICrashReporter
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
endif
#
ifdef
NIGHTLY_BUILD
#
if
defined
(
DEBUG
)
&
&
!
defined
(
XP_WIN
)
&
&
!
defined
(
ANDROID
)
#
define
HAS_GDB_SLEEP_DURATION
1
extern
unsigned
int
_gdb_sleep_duration
;
#
endif
#
ifndef
XP_DARWIN
static
void
DisableCrashReporter
(
)
{
#
ifdef
MOZ_CRASHREPORTER
nsCOMPtr
<
nsICrashReporter
>
crashreporter
=
do_GetService
(
"
mozilla
.
org
/
toolkit
/
crash
-
reporter
;
1
"
)
;
if
(
crashreporter
)
{
crashreporter
-
>
SetEnabled
(
false
)
;
}
#
endif
}
#
define
ASSERT_DEATH_WRAP
(
a
b
)
\
ASSERT_DEATH_IF_SUPPORTED
(
{
DisableCrashReporter
(
)
;
a
;
}
b
)
#
else
#
define
ASSERT_DEATH_WRAP
(
a
b
)
#
endif
#
endif
using
namespace
mozilla
;
static
inline
void
TestOne
(
size_t
size
)
{
size_t
req
=
size
;
size_t
adv
=
malloc_good_size
(
req
)
;
char
*
p
=
(
char
*
)
malloc
(
req
)
;
size_t
usable
=
moz_malloc_usable_size
(
p
)
;
EXPECT_EQ
(
adv
usable
)
<
<
"
malloc_good_size
(
"
<
<
req
<
<
"
)
-
-
>
"
<
<
adv
<
<
"
;
"
"
malloc_usable_size
(
"
<
<
req
<
<
"
)
-
-
>
"
<
<
usable
;
free
(
p
)
;
}
static
inline
void
TestThree
(
size_t
size
)
{
ASSERT_NO_FATAL_FAILURE
(
TestOne
(
size
-
1
)
)
;
ASSERT_NO_FATAL_FAILURE
(
TestOne
(
size
)
)
;
ASSERT_NO_FATAL_FAILURE
(
TestOne
(
size
+
1
)
)
;
}
TEST
(
Jemalloc
UsableSizeInAdvance
)
{
for
(
size_t
n
=
0
;
n
<
16_KiB
;
n
+
+
)
ASSERT_NO_FATAL_FAILURE
(
TestOne
(
n
)
)
;
for
(
size_t
n
=
16_KiB
;
n
<
1_MiB
;
n
+
=
4_KiB
)
ASSERT_NO_FATAL_FAILURE
(
TestThree
(
n
)
)
;
for
(
size_t
n
=
1_MiB
;
n
<
8_MiB
;
n
+
=
128_KiB
)
ASSERT_NO_FATAL_FAILURE
(
TestThree
(
n
)
)
;
}
static
int
gStaticVar
;
bool
InfoEq
(
jemalloc_ptr_info_t
&
aInfo
PtrInfoTag
aTag
void
*
aAddr
size_t
aSize
)
{
return
aInfo
.
tag
=
=
aTag
&
&
aInfo
.
addr
=
=
aAddr
&
&
aInfo
.
size
=
=
aSize
;
}
bool
InfoEqFreedPage
(
jemalloc_ptr_info_t
&
aInfo
void
*
aAddr
size_t
aPageSize
)
{
size_t
pageSizeMask
=
aPageSize
-
1
;
return
jemalloc_ptr_is_freed_page
(
&
aInfo
)
&
&
aInfo
.
addr
=
=
(
void
*
)
(
uintptr_t
(
aAddr
)
&
~
pageSizeMask
)
&
&
aInfo
.
size
=
=
aPageSize
;
}
TEST
(
Jemalloc
PtrInfo
)
{
jemalloc_thread_local_arena
(
true
)
;
jemalloc_stats_t
stats
;
jemalloc_stats
(
&
stats
)
;
jemalloc_ptr_info_t
info
;
Vector
<
char
*
>
small
large
huge
;
size_t
small_max
=
stats
.
page_size
/
2
;
for
(
size_t
n
=
0
;
n
<
=
small_max
;
n
+
=
8
)
{
auto
p
=
(
char
*
)
malloc
(
n
)
;
size_t
usable
=
moz_malloc_size_of
(
p
)
;
ASSERT_TRUE
(
small
.
append
(
p
)
)
;
for
(
size_t
j
=
0
;
j
<
usable
;
j
+
+
)
{
jemalloc_ptr_info
(
&
p
[
j
]
&
info
)
;
ASSERT_TRUE
(
InfoEq
(
info
TagLiveSmall
p
usable
)
)
;
}
}
for
(
size_t
n
=
small_max
+
1_KiB
;
n
<
=
stats
.
large_max
;
n
+
=
1_KiB
)
{
auto
p
=
(
char
*
)
malloc
(
n
)
;
size_t
usable
=
moz_malloc_size_of
(
p
)
;
ASSERT_TRUE
(
large
.
append
(
p
)
)
;
for
(
size_t
j
=
0
;
j
<
usable
;
j
+
=
347
)
{
jemalloc_ptr_info
(
&
p
[
j
]
&
info
)
;
ASSERT_TRUE
(
InfoEq
(
info
TagLiveLarge
p
usable
)
)
;
}
}
for
(
size_t
n
=
stats
.
chunksize
;
n
<
=
10_MiB
;
n
+
=
512_KiB
)
{
auto
p
=
(
char
*
)
malloc
(
n
)
;
size_t
usable
=
moz_malloc_size_of
(
p
)
;
ASSERT_TRUE
(
huge
.
append
(
p
)
)
;
for
(
size_t
j
=
0
;
j
<
usable
;
j
+
=
567
)
{
jemalloc_ptr_info
(
&
p
[
j
]
&
info
)
;
ASSERT_TRUE
(
InfoEq
(
info
TagLiveHuge
p
usable
)
)
;
}
}
size_t
len
;
int
isFreedSmall
=
0
isFreedPage
=
0
;
len
=
small
.
length
(
)
;
for
(
size_t
i
=
0
j
=
0
;
i
<
len
;
i
+
+
j
=
(
j
+
19
)
%
len
)
{
char
*
p
=
small
[
j
]
;
size_t
usable
=
moz_malloc_size_of
(
p
)
;
free
(
p
)
;
for
(
size_t
k
=
0
;
k
<
usable
;
k
+
+
)
{
jemalloc_ptr_info
(
&
p
[
k
]
&
info
)
;
if
(
InfoEq
(
info
TagFreedSmall
p
usable
)
)
{
isFreedSmall
+
+
;
}
else
if
(
InfoEqFreedPage
(
info
&
p
[
k
]
stats
.
page_size
)
)
{
isFreedPage
+
+
;
}
else
{
ASSERT_TRUE
(
false
)
;
}
}
}
ASSERT_TRUE
(
isFreedSmall
!
=
0
)
;
ASSERT_TRUE
(
isFreedPage
!
=
0
)
;
ASSERT_TRUE
(
isFreedSmall
/
isFreedPage
>
10
)
;
len
=
large
.
length
(
)
;
for
(
size_t
i
=
0
j
=
0
;
i
<
len
;
i
+
+
j
=
(
j
+
31
)
%
len
)
{
char
*
p
=
large
[
j
]
;
size_t
usable
=
moz_malloc_size_of
(
p
)
;
free
(
p
)
;
for
(
size_t
k
=
0
;
k
<
usable
;
k
+
=
357
)
{
jemalloc_ptr_info
(
&
p
[
k
]
&
info
)
;
ASSERT_TRUE
(
InfoEqFreedPage
(
info
&
p
[
k
]
stats
.
page_size
)
)
;
}
}
len
=
huge
.
length
(
)
;
for
(
size_t
i
=
0
j
=
0
;
i
<
len
;
i
+
+
j
=
(
j
+
7
)
%
len
)
{
char
*
p
=
huge
[
j
]
;
size_t
usable
=
moz_malloc_size_of
(
p
)
;
free
(
p
)
;
for
(
size_t
k
=
0
;
k
<
usable
;
k
+
=
587
)
{
jemalloc_ptr_info
(
&
p
[
k
]
&
info
)
;
ASSERT_TRUE
(
InfoEq
(
info
TagUnknown
nullptr
0U
)
)
;
}
}
jemalloc_ptr_info
(
nullptr
&
info
)
;
ASSERT_TRUE
(
InfoEq
(
info
TagUnknown
nullptr
0U
)
)
;
jemalloc_ptr_info
(
(
void
*
)
0x123
&
info
)
;
ASSERT_TRUE
(
InfoEq
(
info
TagUnknown
nullptr
0U
)
)
;
jemalloc_ptr_info
(
(
void
*
)
uintptr_t
(
-
1
)
&
info
)
;
ASSERT_TRUE
(
InfoEq
(
info
TagUnknown
nullptr
0U
)
)
;
int
stackVar
;
jemalloc_ptr_info
(
&
stackVar
&
info
)
;
ASSERT_TRUE
(
InfoEq
(
info
TagUnknown
nullptr
0U
)
)
;
jemalloc_ptr_info
(
(
const
void
*
)
&
jemalloc_ptr_info
&
info
)
;
ASSERT_TRUE
(
InfoEq
(
info
TagUnknown
nullptr
0U
)
)
;
jemalloc_ptr_info
(
&
gStaticVar
&
info
)
;
ASSERT_TRUE
(
InfoEq
(
info
TagUnknown
nullptr
0U
)
)
;
UniquePtr
<
int
>
p
=
MakeUnique
<
int
>
(
)
;
size_t
chunksizeMask
=
stats
.
chunksize
-
1
;
char
*
chunk
=
(
char
*
)
(
uintptr_t
(
p
.
get
(
)
)
&
~
chunksizeMask
)
;
size_t
chunkHeaderSize
=
stats
.
chunksize
-
stats
.
large_max
;
for
(
size_t
i
=
0
;
i
<
chunkHeaderSize
;
i
+
=
64
)
{
jemalloc_ptr_info
(
&
chunk
[
i
]
&
info
)
;
ASSERT_TRUE
(
InfoEq
(
info
TagUnknown
nullptr
0U
)
)
;
}
size_t
page_sizeMask
=
stats
.
page_size
-
1
;
char
*
run
=
(
char
*
)
(
uintptr_t
(
p
.
get
(
)
)
&
~
page_sizeMask
)
;
for
(
size_t
i
=
0
;
i
<
4
*
sizeof
(
void
*
)
;
i
+
+
)
{
jemalloc_ptr_info
(
&
run
[
i
]
&
info
)
;
ASSERT_TRUE
(
InfoEq
(
info
TagUnknown
nullptr
0U
)
)
;
}
for
(
size_t
i
=
0
;
i
<
stats
.
chunksize
;
i
+
=
256
)
{
jemalloc_ptr_info
(
&
chunk
[
i
]
&
info
)
;
}
jemalloc_thread_local_arena
(
false
)
;
}
#
ifdef
NIGHTLY_BUILD
TEST
(
Jemalloc
Arenas
)
{
arena_id_t
arena
=
moz_create_arena
(
)
;
ASSERT_TRUE
(
arena
!
=
0
)
;
void
*
ptr
=
moz_arena_malloc
(
arena
42
)
;
ASSERT_TRUE
(
ptr
!
=
nullptr
)
;
ptr
=
moz_arena_realloc
(
arena
ptr
64
)
;
ASSERT_TRUE
(
ptr
!
=
nullptr
)
;
moz_arena_free
(
arena
ptr
)
;
ptr
=
moz_arena_calloc
(
arena
24
2
)
;
free
(
ptr
)
;
moz_dispose_arena
(
arena
)
;
#
ifdef
HAS_GDB_SLEEP_DURATION
unsigned
int
old_gdb_sleep_duration
=
_gdb_sleep_duration
;
_gdb_sleep_duration
=
0
;
#
endif
ASSERT_DEATH_WRAP
(
moz_arena_malloc
(
arena
80
)
"
"
)
;
ASSERT_DEATH_WRAP
(
moz_arena_malloc
(
0
80
)
"
"
)
;
arena
=
moz_create_arena
(
)
;
arena_id_t
arena2
=
moz_create_arena
(
)
;
size_t
sizes
[
]
=
{
1
42
80
1_KiB
1
.
5_KiB
72_KiB
129_KiB
2
.
5_MiB
5
.
1_MiB
}
;
for
(
size_t
from_size
:
sizes
)
{
for
(
size_t
to_size
:
sizes
)
{
ptr
=
moz_arena_malloc
(
arena
from_size
)
;
ptr
=
realloc
(
ptr
to_size
)
;
ASSERT_DEATH_WRAP
(
moz_arena_free
(
arena2
ptr
)
"
"
)
;
ASSERT_DEATH_WRAP
(
moz_arena_realloc
(
arena2
ptr
from_size
)
"
"
)
;
moz_arena_free
(
arena
ptr
)
;
}
}
moz_dispose_arena
(
arena2
)
;
moz_dispose_arena
(
arena
)
;
#
ifdef
HAS_GDB_SLEEP_DURATION
_gdb_sleep_duration
=
old_gdb_sleep_duration
;
#
endif
}
#
endif
