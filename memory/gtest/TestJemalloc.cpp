#
include
"
mozilla
/
Literals
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
mozilla
/
gtest
/
MozHelpers
.
h
"
#
include
"
mozmemory
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
Utils
.
h
"
#
include
"
gtest
/
gtest
.
h
"
#
ifdef
MOZ_PHC
#
include
"
PHC
.
h
"
#
endif
using
namespace
mozilla
;
class
AutoDisablePHCOnCurrentThread
{
public
:
AutoDisablePHCOnCurrentThread
(
)
{
#
ifdef
MOZ_PHC
mozilla
:
:
phc
:
:
DisablePHCOnCurrentThread
(
)
;
#
endif
}
~
AutoDisablePHCOnCurrentThread
(
)
{
#
ifdef
MOZ_PHC
mozilla
:
:
phc
:
:
ReenablePHCOnCurrentThread
(
)
;
#
endif
}
}
;
static
inline
void
TestOne
(
size_t
size
)
{
size_t
req
=
size
;
size_t
adv
=
malloc_good_size
(
req
)
;
char
*
p
=
(
char
*
)
malloc
(
req
)
;
size_t
usable
=
moz_malloc_usable_size
(
p
)
;
EXPECT_EQ
(
adv
usable
)
<
<
"
malloc_good_size
(
"
<
<
req
<
<
"
)
-
-
>
"
<
<
adv
<
<
"
;
"
"
malloc_usable_size
(
"
<
<
req
<
<
"
)
-
-
>
"
<
<
usable
;
free
(
p
)
;
}
static
inline
void
TestThree
(
size_t
size
)
{
ASSERT_NO_FATAL_FAILURE
(
TestOne
(
size
-
1
)
)
;
ASSERT_NO_FATAL_FAILURE
(
TestOne
(
size
)
)
;
ASSERT_NO_FATAL_FAILURE
(
TestOne
(
size
+
1
)
)
;
}
TEST
(
Jemalloc
UsableSizeInAdvance
)
{
for
(
size_t
n
=
0
;
n
<
16_KiB
;
n
+
+
)
ASSERT_NO_FATAL_FAILURE
(
TestOne
(
n
)
)
;
for
(
size_t
n
=
16_KiB
;
n
<
1_MiB
;
n
+
=
4_KiB
)
ASSERT_NO_FATAL_FAILURE
(
TestThree
(
n
)
)
;
for
(
size_t
n
=
1_MiB
;
n
<
8_MiB
;
n
+
=
128_KiB
)
ASSERT_NO_FATAL_FAILURE
(
TestThree
(
n
)
)
;
}
static
int
gStaticVar
;
bool
InfoEq
(
jemalloc_ptr_info_t
&
aInfo
PtrInfoTag
aTag
void
*
aAddr
size_t
aSize
arena_id_t
arenaId
)
{
return
aInfo
.
tag
=
=
aTag
&
&
aInfo
.
addr
=
=
aAddr
&
&
aInfo
.
size
=
=
aSize
#
ifdef
MOZ_DEBUG
&
&
aInfo
.
arenaId
=
=
arenaId
#
endif
;
}
bool
InfoEqFreedPage
(
jemalloc_ptr_info_t
&
aInfo
void
*
aAddr
size_t
aPageSize
arena_id_t
arenaId
)
{
size_t
pageSizeMask
=
aPageSize
-
1
;
return
jemalloc_ptr_is_freed_page
(
&
aInfo
)
&
&
aInfo
.
addr
=
=
(
void
*
)
(
uintptr_t
(
aAddr
)
&
~
pageSizeMask
)
&
&
aInfo
.
size
=
=
aPageSize
#
ifdef
MOZ_DEBUG
&
&
aInfo
.
arenaId
=
=
arenaId
#
endif
;
}
TEST
(
Jemalloc
PtrInfo
)
{
arena_id_t
arenaId
=
moz_create_arena
(
)
;
ASSERT_TRUE
(
arenaId
!
=
0
)
;
jemalloc_stats_t
stats
;
jemalloc_stats
(
&
stats
)
;
jemalloc_ptr_info_t
info
;
Vector
<
char
*
>
small
large
huge
;
size_t
small_max
=
stats
.
subpage_max
?
stats
.
subpage_max
:
stats
.
quantum_wide_max
;
for
(
size_t
n
=
0
;
n
<
=
small_max
;
n
+
=
8
)
{
auto
p
=
(
char
*
)
moz_arena_malloc
(
arenaId
n
)
;
size_t
usable
=
moz_malloc_size_of
(
p
)
;
ASSERT_TRUE
(
small
.
append
(
p
)
)
;
for
(
size_t
j
=
0
;
j
<
usable
;
j
+
+
)
{
jemalloc_ptr_info
(
&
p
[
j
]
&
info
)
;
ASSERT_TRUE
(
InfoEq
(
info
TagLiveAlloc
p
usable
arenaId
)
)
;
}
}
for
(
size_t
n
=
small_max
+
1_KiB
;
n
<
=
stats
.
large_max
;
n
+
=
1_KiB
)
{
auto
p
=
(
char
*
)
moz_arena_malloc
(
arenaId
n
)
;
size_t
usable
=
moz_malloc_size_of
(
p
)
;
ASSERT_TRUE
(
large
.
append
(
p
)
)
;
for
(
size_t
j
=
0
;
j
<
usable
;
j
+
=
347
)
{
jemalloc_ptr_info
(
&
p
[
j
]
&
info
)
;
ASSERT_TRUE
(
InfoEq
(
info
TagLiveAlloc
p
usable
arenaId
)
)
;
}
}
for
(
size_t
n
=
stats
.
chunksize
;
n
<
=
10_MiB
;
n
+
=
512_KiB
)
{
auto
p
=
(
char
*
)
moz_arena_malloc
(
arenaId
n
)
;
size_t
usable
=
moz_malloc_size_of
(
p
)
;
ASSERT_TRUE
(
huge
.
append
(
p
)
)
;
for
(
size_t
j
=
0
;
j
<
usable
;
j
+
=
567
)
{
jemalloc_ptr_info
(
&
p
[
j
]
&
info
)
;
ASSERT_TRUE
(
InfoEq
(
info
TagLiveAlloc
p
usable
arenaId
)
)
;
}
}
size_t
len
;
int
isFreedAlloc
=
0
isFreedPage
=
0
;
len
=
small
.
length
(
)
;
for
(
size_t
i
=
0
j
=
0
;
i
<
len
;
i
+
+
j
=
(
j
+
19
)
%
len
)
{
char
*
p
=
small
[
j
]
;
size_t
usable
=
moz_malloc_size_of
(
p
)
;
free
(
p
)
;
for
(
size_t
k
=
0
;
k
<
usable
;
k
+
+
)
{
jemalloc_ptr_info
(
&
p
[
k
]
&
info
)
;
if
(
InfoEq
(
info
TagFreedAlloc
p
usable
arenaId
)
)
{
isFreedAlloc
+
+
;
}
else
if
(
InfoEqFreedPage
(
info
&
p
[
k
]
stats
.
page_size
arenaId
)
)
{
isFreedPage
+
+
;
}
else
{
ASSERT_TRUE
(
false
)
;
}
}
}
ASSERT_TRUE
(
isFreedAlloc
!
=
0
)
;
ASSERT_TRUE
(
isFreedPage
!
=
0
)
;
ASSERT_TRUE
(
isFreedAlloc
/
isFreedPage
>
8
)
;
len
=
large
.
length
(
)
;
for
(
size_t
i
=
0
j
=
0
;
i
<
len
;
i
+
+
j
=
(
j
+
31
)
%
len
)
{
char
*
p
=
large
[
j
]
;
size_t
usable
=
moz_malloc_size_of
(
p
)
;
free
(
p
)
;
for
(
size_t
k
=
0
;
k
<
usable
;
k
+
=
357
)
{
jemalloc_ptr_info
(
&
p
[
k
]
&
info
)
;
ASSERT_TRUE
(
InfoEqFreedPage
(
info
&
p
[
k
]
stats
.
page_size
arenaId
)
)
;
}
}
len
=
huge
.
length
(
)
;
for
(
size_t
i
=
0
j
=
0
;
i
<
len
;
i
+
+
j
=
(
j
+
7
)
%
len
)
{
char
*
p
=
huge
[
j
]
;
size_t
usable
=
moz_malloc_size_of
(
p
)
;
free
(
p
)
;
for
(
size_t
k
=
0
;
k
<
usable
;
k
+
=
587
)
{
jemalloc_ptr_info
(
&
p
[
k
]
&
info
)
;
ASSERT_TRUE
(
InfoEq
(
info
TagUnknown
nullptr
0U
0U
)
)
;
}
}
jemalloc_ptr_info
(
nullptr
&
info
)
;
ASSERT_TRUE
(
InfoEq
(
info
TagUnknown
nullptr
0U
0U
)
)
;
jemalloc_ptr_info
(
(
void
*
)
0x123
&
info
)
;
ASSERT_TRUE
(
InfoEq
(
info
TagUnknown
nullptr
0U
0U
)
)
;
jemalloc_ptr_info
(
(
void
*
)
uintptr_t
(
-
1
)
&
info
)
;
ASSERT_TRUE
(
InfoEq
(
info
TagUnknown
nullptr
0U
0U
)
)
;
int
stackVar
=
0
;
jemalloc_ptr_info
(
&
stackVar
&
info
)
;
ASSERT_TRUE
(
InfoEq
(
info
TagUnknown
nullptr
0U
0U
)
)
;
jemalloc_ptr_info
(
(
const
void
*
)
&
jemalloc_ptr_info
&
info
)
;
ASSERT_TRUE
(
InfoEq
(
info
TagUnknown
nullptr
0U
0U
)
)
;
jemalloc_ptr_info
(
&
gStaticVar
&
info
)
;
ASSERT_TRUE
(
InfoEq
(
info
TagUnknown
nullptr
0U
0U
)
)
;
UniquePtr
<
int
>
p
=
MakeUnique
<
int
>
(
)
;
size_t
chunksizeMask
=
stats
.
chunksize
-
1
;
char
*
chunk
=
(
char
*
)
(
uintptr_t
(
p
.
get
(
)
)
&
~
chunksizeMask
)
;
size_t
chunkHeaderSize
=
stats
.
chunksize
-
stats
.
large_max
-
stats
.
page_size
;
for
(
size_t
i
=
0
;
i
<
chunkHeaderSize
;
i
+
=
64
)
{
jemalloc_ptr_info
(
&
chunk
[
i
]
&
info
)
;
ASSERT_TRUE
(
InfoEq
(
info
TagUnknown
nullptr
0U
0U
)
)
;
}
size_t
page_sizeMask
=
stats
.
page_size
-
1
;
char
*
run
=
(
char
*
)
(
uintptr_t
(
p
.
get
(
)
)
&
~
page_sizeMask
)
;
for
(
size_t
i
=
0
;
i
<
4
*
sizeof
(
void
*
)
;
i
+
+
)
{
jemalloc_ptr_info
(
&
run
[
i
]
&
info
)
;
ASSERT_TRUE
(
InfoEq
(
info
TagUnknown
nullptr
0U
0U
)
)
;
}
for
(
size_t
i
=
0
;
i
<
stats
.
chunksize
;
i
+
=
256
)
{
jemalloc_ptr_info
(
&
chunk
[
i
]
&
info
)
;
}
moz_dispose_arena
(
arenaId
)
;
}
size_t
sSizes
[
]
=
{
1
42
79
918
1
.
4_KiB
73_KiB
129_KiB
1
.
1_MiB
2
.
6_MiB
5
.
1_MiB
}
;
TEST
(
Jemalloc
Arenas
)
{
arena_id_t
arena
=
moz_create_arena
(
)
;
ASSERT_TRUE
(
arena
!
=
0
)
;
void
*
ptr
=
moz_arena_malloc
(
arena
42
)
;
ASSERT_TRUE
(
ptr
!
=
nullptr
)
;
ptr
=
moz_arena_realloc
(
arena
ptr
64
)
;
ASSERT_TRUE
(
ptr
!
=
nullptr
)
;
moz_arena_free
(
arena
ptr
)
;
ptr
=
moz_arena_calloc
(
arena
24
2
)
;
free
(
ptr
)
;
moz_dispose_arena
(
arena
)
;
SAVE_GDB_SLEEP_LOCAL
(
)
;
ASSERT_DEATH_WRAP
(
moz_arena_malloc
(
0
80
)
"
"
)
;
arena
=
moz_create_arena
(
)
;
arena_id_t
arena2
=
moz_create_arena
(
)
;
(
void
)
arena2
;
for
(
size_t
from_size
:
sSizes
)
{
SCOPED_TRACE
(
testing
:
:
Message
(
)
<
<
"
from_size
=
"
<
<
from_size
)
;
for
(
size_t
to_size
:
sSizes
)
{
SCOPED_TRACE
(
testing
:
:
Message
(
)
<
<
"
to_size
=
"
<
<
to_size
)
;
ptr
=
moz_arena_malloc
(
arena
from_size
)
;
ptr
=
realloc
(
ptr
to_size
)
;
ASSERT_DEATH_WRAP
(
moz_arena_free
(
arena2
ptr
)
"
"
)
;
ASSERT_DEATH_WRAP
(
moz_arena_realloc
(
arena2
ptr
from_size
)
"
"
)
;
moz_arena_free
(
arena
ptr
)
;
}
}
moz_dispose_arena
(
arena2
)
;
moz_dispose_arena
(
arena
)
;
RESTORE_GDB_SLEEP_LOCAL
(
)
;
}
static
void
bulk_compare
(
char
*
aPtr
size_t
aOffset
size_t
aSize
char
*
aReference
size_t
aReferenceSize
)
{
for
(
size_t
i
=
aOffset
;
i
<
aSize
;
i
+
=
aReferenceSize
)
{
size_t
length
=
std
:
:
min
(
aSize
-
i
aReferenceSize
)
;
if
(
memcmp
(
aPtr
+
i
aReference
length
)
)
{
for
(
size_t
j
=
i
;
j
<
i
+
length
;
j
+
+
)
{
ASSERT_EQ
(
aPtr
[
j
]
*
aReference
)
;
}
}
}
}
class
SizeClassesBetween
{
public
:
SizeClassesBetween
(
size_t
aStart
size_t
aEnd
)
:
mStart
(
aStart
)
mEnd
(
aEnd
)
{
}
class
Iterator
{
public
:
explicit
Iterator
(
size_t
aValue
)
:
mValue
(
malloc_good_size
(
aValue
)
)
{
}
operator
size_t
(
)
const
{
return
mValue
;
}
size_t
operator
*
(
)
const
{
return
mValue
;
}
Iterator
&
operator
+
+
(
)
{
mValue
=
malloc_good_size
(
mValue
+
1
)
;
return
*
this
;
}
private
:
size_t
mValue
;
}
;
Iterator
begin
(
)
{
return
Iterator
(
mStart
)
;
}
Iterator
end
(
)
{
return
Iterator
(
mEnd
)
;
}
private
:
size_t
mStart
mEnd
;
}
;
#
define
ALIGNMENT_CEILING
(
s
alignment
)
\
(
(
(
s
)
+
(
(
alignment
)
-
1
)
)
&
(
~
(
(
alignment
)
-
1
)
)
)
#
define
ALIGNMENT_FLOOR
(
s
alignment
)
(
(
s
)
&
(
~
(
(
alignment
)
-
1
)
)
)
static
bool
IsSameRoundedHugeClass
(
size_t
aSize1
size_t
aSize2
jemalloc_stats_t
&
aStats
)
{
return
(
aSize1
>
aStats
.
large_max
&
&
aSize2
>
aStats
.
large_max
&
&
ALIGNMENT_CEILING
(
aSize1
+
aStats
.
page_size
aStats
.
chunksize
)
=
=
ALIGNMENT_CEILING
(
aSize2
+
aStats
.
page_size
aStats
.
chunksize
)
)
;
}
static
bool
CanReallocInPlace
(
size_t
aFromSize
size_t
aToSize
jemalloc_stats_t
&
aStats
)
{
#
ifdef
MOZ_PHC
MOZ_RELEASE_ASSERT
(
!
mozilla
:
:
phc
:
:
IsPHCEnabledOnCurrentThread
(
)
)
;
#
endif
if
(
aFromSize
=
=
malloc_good_size
(
aToSize
)
)
{
return
true
;
}
if
(
aFromSize
>
=
aStats
.
page_size
&
&
aFromSize
<
=
aStats
.
large_max
&
&
aToSize
>
=
aStats
.
page_size
&
&
aToSize
<
=
aStats
.
large_max
)
{
return
true
;
}
if
(
IsSameRoundedHugeClass
(
aFromSize
aToSize
aStats
)
)
{
return
true
;
}
return
false
;
}
TEST
(
Jemalloc
InPlace
)
{
AutoDisablePHCOnCurrentThread
disable
;
jemalloc_stats_t
stats
;
jemalloc_stats
(
&
stats
)
;
arena_id_t
arena
=
moz_create_arena
(
)
;
for
(
size_t
from_size
:
SizeClassesBetween
(
1
2
*
stats
.
chunksize
)
)
{
SCOPED_TRACE
(
testing
:
:
Message
(
)
<
<
"
from_size
=
"
<
<
from_size
)
;
for
(
size_t
to_size
:
sSizes
)
{
SCOPED_TRACE
(
testing
:
:
Message
(
)
<
<
"
to_size
=
"
<
<
to_size
)
;
char
*
ptr
=
(
char
*
)
moz_arena_malloc
(
arena
from_size
)
;
char
*
ptr2
=
(
char
*
)
moz_arena_realloc
(
arena
ptr
to_size
)
;
if
(
CanReallocInPlace
(
from_size
to_size
stats
)
)
{
EXPECT_EQ
(
ptr
ptr2
)
;
}
else
{
EXPECT_NE
(
ptr
ptr2
)
;
}
moz_arena_free
(
arena
ptr2
)
;
}
}
moz_dispose_arena
(
arena
)
;
}
#
if
!
defined
(
XP_WIN
)
|
|
!
defined
(
MOZ_CODE_COVERAGE
)
TEST
(
Jemalloc
JunkPoison
)
{
AutoDisablePHCOnCurrentThread
disable
;
jemalloc_stats_t
stats
;
jemalloc_stats
(
&
stats
)
;
SAVE_GDB_SLEEP_LOCAL
(
)
;
arena_id_t
buf_arena
=
moz_create_arena
(
)
;
char
*
junk_buf
=
(
char
*
)
moz_arena_malloc
(
buf_arena
stats
.
page_size
)
;
char
junk
=
stats
.
opt_junk
?
'
\
xe4
'
:
'
\
0
'
;
for
(
size_t
i
=
0
;
i
<
stats
.
page_size
;
i
+
+
)
{
ASSERT_EQ
(
junk_buf
[
i
]
junk
)
;
}
char
*
poison_buf
=
(
char
*
)
moz_arena_malloc
(
buf_arena
stats
.
page_size
)
;
memset
(
poison_buf
0xe5
stats
.
page_size
)
;
static
const
char
fill
=
0x42
;
char
*
fill_buf
=
(
char
*
)
moz_arena_malloc
(
buf_arena
stats
.
page_size
)
;
memset
(
fill_buf
fill
stats
.
page_size
)
;
arena_params_t
params
;
params
.
mMaxDirty
=
size_t
(
-
1
)
;
arena_id_t
arena
=
moz_create_arena_with_params
(
&
params
)
;
const
size_t
poison_check_len
=
256
;
for
(
size_t
size
:
sSizes
)
{
if
(
size
<
=
stats
.
large_max
)
{
SCOPED_TRACE
(
testing
:
:
Message
(
)
<
<
"
size
=
"
<
<
size
)
;
char
*
buf
=
(
char
*
)
moz_arena_malloc
(
arena
size
)
;
size_t
allocated
=
moz_malloc_usable_size
(
buf
)
;
if
(
stats
.
opt_junk
|
|
stats
.
opt_zero
)
{
ASSERT_NO_FATAL_FAILURE
(
bulk_compare
(
buf
0
allocated
junk_buf
stats
.
page_size
)
)
;
}
moz_arena_free
(
arena
buf
)
;
ASSERT_NO_FATAL_FAILURE
(
bulk_compare
(
buf
0
std
:
:
min
(
allocated
poison_check_len
)
poison_buf
stats
.
page_size
)
)
;
}
}
size_t
prev
=
0
;
for
(
size_t
size
:
SizeClassesBetween
(
1
2
*
stats
.
chunksize
)
)
{
SCOPED_TRACE
(
testing
:
:
Message
(
)
<
<
"
size
=
"
<
<
size
)
;
SCOPED_TRACE
(
testing
:
:
Message
(
)
<
<
"
prev
=
"
<
<
prev
)
;
char
*
ptr
=
(
char
*
)
moz_arena_malloc
(
arena
size
)
;
memset
(
ptr
fill
moz_malloc_usable_size
(
ptr
)
)
;
char
*
ptr2
=
(
char
*
)
moz_arena_realloc
(
arena
ptr
prev
+
1
)
;
ASSERT_EQ
(
ptr
ptr2
)
;
ASSERT_NO_FATAL_FAILURE
(
bulk_compare
(
ptr
0
prev
+
1
fill_buf
stats
.
page_size
)
)
;
ASSERT_NO_FATAL_FAILURE
(
bulk_compare
(
ptr
prev
+
1
std
:
:
min
(
size
poison_check_len
)
poison_buf
stats
.
page_size
)
)
;
moz_arena_free
(
arena
ptr
)
;
prev
=
size
;
}
for
(
size_t
from_size
:
SizeClassesBetween
(
1
2
*
stats
.
chunksize
)
)
{
SCOPED_TRACE
(
testing
:
:
Message
(
)
<
<
"
from_size
=
"
<
<
from_size
)
;
for
(
size_t
to_size
:
sSizes
)
{
SCOPED_TRACE
(
testing
:
:
Message
(
)
<
<
"
to_size
=
"
<
<
to_size
)
;
if
(
CanReallocInPlace
(
from_size
to_size
stats
)
)
{
char
*
ptr
=
(
char
*
)
moz_arena_malloc
(
arena
from_size
)
;
memset
(
ptr
fill
moz_malloc_usable_size
(
ptr
)
)
;
char
*
ptr2
=
(
char
*
)
moz_arena_realloc
(
arena
ptr
to_size
)
;
ASSERT_EQ
(
ptr
ptr2
)
;
if
(
from_size
>
=
to_size
)
{
ASSERT_NO_FATAL_FAILURE
(
bulk_compare
(
ptr
0
to_size
fill_buf
stats
.
page_size
)
)
;
if
(
to_size
>
stats
.
large_max
)
{
size_t
page_limit
=
ALIGNMENT_CEILING
(
to_size
stats
.
page_size
)
;
ASSERT_NO_FATAL_FAILURE
(
bulk_compare
(
ptr
to_size
std
:
:
min
(
page_limit
poison_check_len
)
poison_buf
stats
.
page_size
)
)
;
ASSERT_DEATH_WRAP
(
ptr
[
page_limit
]
=
0
"
"
)
;
}
else
{
ASSERT_NO_FATAL_FAILURE
(
bulk_compare
(
ptr
to_size
std
:
:
min
(
from_size
poison_check_len
)
poison_buf
stats
.
page_size
)
)
;
}
}
else
{
ASSERT_NO_FATAL_FAILURE
(
bulk_compare
(
ptr
0
from_size
fill_buf
stats
.
page_size
)
)
;
if
(
stats
.
opt_junk
|
|
stats
.
opt_zero
)
{
ASSERT_NO_FATAL_FAILURE
(
bulk_compare
(
ptr
from_size
to_size
junk_buf
stats
.
page_size
)
)
;
}
if
(
to_size
>
stats
.
large_max
)
{
ASSERT_DEATH_WRAP
(
ptr
[
ALIGNMENT_CEILING
(
to_size
stats
.
page_size
)
]
=
0
"
"
)
;
}
}
moz_arena_free
(
arena
ptr2
)
;
}
}
}
for
(
size_t
from_size
:
SizeClassesBetween
(
1
2
*
stats
.
chunksize
)
)
{
SCOPED_TRACE
(
testing
:
:
Message
(
)
<
<
"
from_size
=
"
<
<
from_size
)
;
for
(
size_t
to_size
:
sSizes
)
{
if
(
from_size
<
to_size
&
&
malloc_good_size
(
to_size
)
!
=
from_size
&
&
!
IsSameRoundedHugeClass
(
from_size
to_size
stats
)
)
{
SCOPED_TRACE
(
testing
:
:
Message
(
)
<
<
"
to_size
=
"
<
<
to_size
)
;
char
*
ptr
=
(
char
*
)
moz_arena_malloc
(
arena
from_size
)
;
memset
(
ptr
fill
moz_malloc_usable_size
(
ptr
)
)
;
char
*
avoid_inplace
=
nullptr
;
if
(
from_size
>
=
stats
.
page_size
&
&
from_size
<
stats
.
large_max
)
{
avoid_inplace
=
(
char
*
)
moz_arena_malloc
(
arena
stats
.
page_size
)
;
ASSERT_EQ
(
ptr
+
from_size
avoid_inplace
)
;
}
char
*
ptr2
=
(
char
*
)
moz_arena_realloc
(
arena
ptr
to_size
)
;
ASSERT_NE
(
ptr
ptr2
)
;
if
(
from_size
<
=
stats
.
large_max
)
{
ASSERT_NO_FATAL_FAILURE
(
bulk_compare
(
ptr
0
std
:
:
min
(
from_size
poison_check_len
)
poison_buf
stats
.
page_size
)
)
;
}
ASSERT_NO_FATAL_FAILURE
(
bulk_compare
(
ptr2
0
from_size
fill_buf
stats
.
page_size
)
)
;
if
(
stats
.
opt_junk
|
|
stats
.
opt_zero
)
{
size_t
rounded_to_size
=
malloc_good_size
(
to_size
)
;
ASSERT_NE
(
to_size
rounded_to_size
)
;
ASSERT_NO_FATAL_FAILURE
(
bulk_compare
(
ptr2
from_size
rounded_to_size
junk_buf
stats
.
page_size
)
)
;
}
moz_arena_free
(
arena
ptr2
)
;
moz_arena_free
(
arena
avoid_inplace
)
;
}
}
}
for
(
size_t
from_size
:
SizeClassesBetween
(
1
2
*
stats
.
chunksize
)
)
{
SCOPED_TRACE
(
testing
:
:
Message
(
)
<
<
"
from_size
=
"
<
<
from_size
)
;
for
(
size_t
to_size
:
sSizes
)
{
if
(
from_size
>
to_size
&
&
!
CanReallocInPlace
(
from_size
to_size
stats
)
)
{
SCOPED_TRACE
(
testing
:
:
Message
(
)
<
<
"
to_size
=
"
<
<
to_size
)
;
char
*
ptr
=
(
char
*
)
moz_arena_malloc
(
arena
from_size
)
;
memset
(
ptr
fill
from_size
)
;
char
*
ptr2
=
(
char
*
)
moz_arena_realloc
(
arena
ptr
to_size
)
;
ASSERT_NE
(
ptr
ptr2
)
;
if
(
from_size
<
=
stats
.
large_max
)
{
ASSERT_NO_FATAL_FAILURE
(
bulk_compare
(
ptr
0
std
:
:
min
(
from_size
poison_check_len
)
poison_buf
stats
.
page_size
)
)
;
}
ASSERT_NO_FATAL_FAILURE
(
bulk_compare
(
ptr2
0
to_size
fill_buf
stats
.
page_size
)
)
;
if
(
stats
.
opt_junk
|
|
stats
.
opt_zero
)
{
size_t
rounded_to_size
=
malloc_good_size
(
to_size
)
;
ASSERT_NE
(
to_size
rounded_to_size
)
;
ASSERT_NO_FATAL_FAILURE
(
bulk_compare
(
ptr2
from_size
rounded_to_size
junk_buf
stats
.
page_size
)
)
;
}
moz_arena_free
(
arena
ptr2
)
;
}
}
}
moz_dispose_arena
(
arena
)
;
moz_arena_free
(
buf_arena
poison_buf
)
;
moz_arena_free
(
buf_arena
junk_buf
)
;
moz_arena_free
(
buf_arena
fill_buf
)
;
moz_dispose_arena
(
buf_arena
)
;
RESTORE_GDB_SLEEP_LOCAL
(
)
;
}
#
endif
TEST
(
Jemalloc
TrailingGuard
)
{
AutoDisablePHCOnCurrentThread
disable
;
jemalloc_stats_t
stats
;
jemalloc_stats
(
&
stats
)
;
SAVE_GDB_SLEEP_LOCAL
(
)
;
arena_id_t
arena
=
moz_create_arena
(
)
;
ASSERT_TRUE
(
arena
!
=
0
)
;
Vector
<
void
*
>
ptr_list
;
for
(
size_t
cnt
=
0
;
cnt
<
stats
.
large_max
/
stats
.
page_size
;
cnt
+
+
)
{
void
*
ptr
=
moz_arena_malloc
(
arena
stats
.
page_size
)
;
ASSERT_TRUE
(
ptr
!
=
nullptr
)
;
ASSERT_TRUE
(
ptr_list
.
append
(
ptr
)
)
;
}
void
*
last_ptr_in_chunk
=
ptr_list
[
ptr_list
.
length
(
)
-
1
]
;
void
*
extra_ptr
=
moz_arena_malloc
(
arena
stats
.
page_size
)
;
void
*
guard_page
=
(
void
*
)
ALIGNMENT_CEILING
(
(
uintptr_t
)
last_ptr_in_chunk
+
stats
.
page_size
stats
.
page_size
)
;
jemalloc_ptr_info_t
info
;
jemalloc_ptr_info
(
guard_page
&
info
)
;
ASSERT_TRUE
(
jemalloc_ptr_is_freed_page
(
&
info
)
)
;
ASSERT_DEATH_WRAP
(
*
(
char
*
)
guard_page
=
0
"
"
)
;
for
(
void
*
ptr
:
ptr_list
)
{
moz_arena_free
(
arena
ptr
)
;
}
moz_arena_free
(
arena
extra_ptr
)
;
moz_dispose_arena
(
arena
)
;
RESTORE_GDB_SLEEP_LOCAL
(
)
;
}
TEST
(
Jemalloc
LeadingGuard
)
{
AutoDisablePHCOnCurrentThread
disable
;
jemalloc_stats_t
stats
;
jemalloc_stats
(
&
stats
)
;
SAVE_GDB_SLEEP_LOCAL
(
)
;
arena_id_t
arena
=
moz_create_arena
(
)
;
ASSERT_TRUE
(
arena
!
=
0
)
;
void
*
ptr
=
moz_arena_malloc
(
arena
stats
.
large_max
)
;
ASSERT_TRUE
(
ptr
!
=
nullptr
)
;
void
*
chunk_start
=
(
void
*
)
ALIGNMENT_FLOOR
(
(
uintptr_t
)
ptr
stats
.
chunksize
)
;
ASSERT_NE
(
(
uintptr_t
)
ptr
(
uintptr_t
)
chunk_start
)
;
ASSERT_NE
(
(
uintptr_t
)
ptr
(
uintptr_t
)
chunk_start
+
stats
.
page_size
)
;
void
*
guard_page
=
(
void
*
)
(
(
(
uintptr_t
)
ptr
)
-
sizeof
(
void
*
)
)
;
jemalloc_ptr_info_t
info
;
jemalloc_ptr_info
(
guard_page
&
info
)
;
ASSERT_TRUE
(
info
.
tag
=
=
TagUnknown
)
;
ASSERT_DEATH_WRAP
(
*
(
char
*
)
guard_page
=
0
"
"
)
;
moz_arena_free
(
arena
ptr
)
;
moz_dispose_arena
(
arena
)
;
RESTORE_GDB_SLEEP_LOCAL
(
)
;
}
TEST
(
Jemalloc
DisposeArena
)
{
jemalloc_stats_t
stats
;
jemalloc_stats
(
&
stats
)
;
SAVE_GDB_SLEEP_LOCAL
(
)
;
arena_id_t
arena
=
moz_create_arena
(
)
;
void
*
ptr
=
moz_arena_malloc
(
arena
42
)
;
ASSERT_DEATH_WRAP
(
moz_dispose_arena
(
arena
)
"
"
)
;
moz_arena_free
(
arena
ptr
)
;
moz_dispose_arena
(
arena
)
;
arena
=
moz_create_arena
(
)
;
ptr
=
moz_arena_malloc
(
arena
stats
.
page_size
*
2
)
;
ASSERT_DEATH_WRAP
(
moz_dispose_arena
(
arena
)
"
"
)
;
moz_arena_free
(
arena
ptr
)
;
moz_dispose_arena
(
arena
)
;
arena
=
moz_create_arena
(
)
;
ptr
=
moz_arena_malloc
(
arena
stats
.
chunksize
*
2
)
;
#
ifdef
MOZ_DEBUG
ASSERT_DEATH_WRAP
(
moz_dispose_arena
(
arena
)
"
"
)
;
moz_arena_free
(
arena
ptr
)
;
moz_dispose_arena
(
arena
)
;
#
else
moz_dispose_arena
(
arena
)
;
ASSERT_DEATH_WRAP
(
free
(
ptr
)
"
"
)
;
ASSERT_DEATH_WRAP
(
ptr
=
realloc
(
ptr
stats
.
chunksize
*
3
)
"
"
)
;
#
endif
ASSERT_DEATH_WRAP
(
moz_arena_malloc
(
arena
42
)
"
"
)
;
RESTORE_GDB_SLEEP_LOCAL
(
)
;
}
static
void
CheckPtr
(
void
*
ptr
size_t
size
)
{
EXPECT_TRUE
(
ptr
)
;
jemalloc_ptr_info_t
info
;
jemalloc_ptr_info
(
ptr
&
info
)
;
EXPECT_EQ
(
info
.
tag
TagLiveAlloc
)
;
EXPECT_EQ
(
info
.
size
malloc_good_size
(
size
)
)
;
}
static
void
CheckStats
(
const
char
*
operation
unsigned
iteration
jemalloc_stats_lite_t
&
baseline
jemalloc_stats_lite_t
&
stats
size_t
num_ops
ptrdiff_t
bytes_diff
)
{
if
(
(
baseline
.
allocated_bytes
+
bytes_diff
!
=
stats
.
allocated_bytes
|
|
baseline
.
num_operations
+
num_ops
!
=
stats
.
num_operations
)
)
{
fprintf
(
stderr
"
Check
stats
failed
after
iteration
%
u
operation
%
s
\
n
"
iteration
operation
)
;
EXPECT_EQ
(
baseline
.
allocated_bytes
+
bytes_diff
stats
.
allocated_bytes
)
;
EXPECT_EQ
(
baseline
.
num_operations
+
num_ops
stats
.
num_operations
)
;
}
}
TEST
(
Jemalloc
StatsLite
)
{
AutoDisablePHCOnCurrentThread
disable
;
struct
{
size_t
initial
;
size_t
next
;
size_t
next_ops
;
size_t
last
;
size_t
last_ops
;
}
TestData
[
]
=
{
{
16
15
0
256
2
}
{
128_KiB
64_KiB
1
68_KiB
1
}
{
4_MiB
16_MiB
2
3_MiB
2
}
{
16_KiB
512
2
32_MiB
2
}
}
;
arena_id_t
my_arena
=
moz_create_arena
(
)
;
unsigned
i
=
0
;
for
(
auto
data
:
TestData
)
{
jemalloc_stats_lite_t
baseline
;
jemalloc_stats_lite
(
&
baseline
)
;
void
*
ptr
=
moz_arena_malloc
(
my_arena
data
.
initial
)
;
CheckPtr
(
ptr
data
.
initial
)
;
jemalloc_stats_lite_t
stats1
;
jemalloc_stats_lite
(
&
stats1
)
;
CheckStats
(
"
malloc
(
)
"
i
baseline
stats1
1
malloc_good_size
(
data
.
initial
)
)
;
ptr
=
moz_arena_realloc
(
my_arena
ptr
data
.
next
)
;
CheckPtr
(
ptr
data
.
next
)
;
jemalloc_stats_lite_t
stats2
;
jemalloc_stats_lite
(
&
stats2
)
;
CheckStats
(
"
realloc
(
)
1
"
i
stats1
stats2
data
.
next_ops
malloc_good_size
(
data
.
next
)
-
malloc_good_size
(
data
.
initial
)
)
;
ptr
=
moz_arena_realloc
(
my_arena
ptr
data
.
last
)
;
CheckPtr
(
ptr
data
.
last
)
;
jemalloc_stats_lite_t
stats3
;
jemalloc_stats_lite
(
&
stats3
)
;
CheckStats
(
"
realloc
(
)
2
"
i
stats2
stats3
data
.
last_ops
malloc_good_size
(
data
.
last
)
-
malloc_good_size
(
data
.
next
)
)
;
moz_arena_free
(
my_arena
ptr
)
;
jemalloc_stats_lite_t
stats4
;
jemalloc_stats_lite
(
&
stats4
)
;
CheckStats
(
"
free
(
)
"
i
stats3
stats4
1
-
malloc_good_size
(
data
.
last
)
)
;
i
+
+
;
}
moz_dispose_arena
(
my_arena
)
;
}
