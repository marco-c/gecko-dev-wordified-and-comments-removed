#
include
<
cstdlib
>
#
include
<
cstdio
>
#
include
<
fcntl
.
h
>
#
ifdef
_WIN32
#
include
<
windows
.
h
>
#
include
<
io
.
h
>
#
include
<
process
.
h
>
#
else
#
include
<
unistd
.
h
>
#
include
<
pthread
.
h
>
#
endif
#
include
"
replace_malloc
.
h
"
#
include
"
FdPrintf
.
h
"
#
include
"
Mutex
.
h
"
static
malloc_table_t
sFuncs
;
static
intptr_t
sFd
=
0
;
static
bool
sStdoutOrStderr
=
false
;
static
Mutex
sMutex
;
static
void
prefork
(
)
{
sMutex
.
Lock
(
)
;
}
static
void
postfork
(
)
{
sMutex
.
Unlock
(
)
;
}
static
size_t
GetPid
(
)
{
return
size_t
(
getpid
(
)
)
;
}
static
size_t
GetTid
(
)
{
#
if
defined
(
_WIN32
)
return
size_t
(
GetCurrentThreadId
(
)
)
;
#
else
return
size_t
(
pthread_self
(
)
)
;
#
endif
}
#
ifdef
ANDROID
extern
"
C
"
MOZ_EXPORT
__attribute__
(
(
weak
)
)
void
*
__dso_handle
;
extern
"
C
"
MOZ_EXPORT
int
pthread_atfork
(
void
(
*
)
(
void
)
void
(
*
)
(
void
)
void
(
*
)
(
void
)
)
;
#
endif
class
LogAllocBridge
:
public
ReplaceMallocBridge
{
virtual
void
InitDebugFd
(
mozilla
:
:
DebugFdRegistry
&
aRegistry
)
override
{
if
(
!
sStdoutOrStderr
)
{
aRegistry
.
RegisterHandle
(
sFd
)
;
}
}
}
;
static
void
*
replace_malloc
(
size_t
aSize
)
{
MutexAutoLock
lock
(
sMutex
)
;
void
*
ptr
=
sFuncs
.
malloc
(
aSize
)
;
if
(
ptr
)
{
FdPrintf
(
sFd
"
%
zu
%
zu
malloc
(
%
zu
)
=
%
p
\
n
"
GetPid
(
)
GetTid
(
)
aSize
ptr
)
;
}
return
ptr
;
}
#
ifndef
LOGALLOC_MINIMAL
static
int
replace_posix_memalign
(
void
*
*
aPtr
size_t
aAlignment
size_t
aSize
)
{
MutexAutoLock
lock
(
sMutex
)
;
int
ret
=
sFuncs
.
posix_memalign
(
aPtr
aAlignment
aSize
)
;
if
(
ret
=
=
0
)
{
FdPrintf
(
sFd
"
%
zu
%
zu
posix_memalign
(
%
zu
%
zu
)
=
%
p
\
n
"
GetPid
(
)
GetTid
(
)
aAlignment
aSize
*
aPtr
)
;
}
return
ret
;
}
static
void
*
replace_aligned_alloc
(
size_t
aAlignment
size_t
aSize
)
{
MutexAutoLock
lock
(
sMutex
)
;
void
*
ptr
=
sFuncs
.
aligned_alloc
(
aAlignment
aSize
)
;
if
(
ptr
)
{
FdPrintf
(
sFd
"
%
zu
%
zu
aligned_alloc
(
%
zu
%
zu
)
=
%
p
\
n
"
GetPid
(
)
GetTid
(
)
aAlignment
aSize
ptr
)
;
}
return
ptr
;
}
#
endif
static
void
*
replace_calloc
(
size_t
aNum
size_t
aSize
)
{
MutexAutoLock
lock
(
sMutex
)
;
void
*
ptr
=
sFuncs
.
calloc
(
aNum
aSize
)
;
if
(
ptr
)
{
FdPrintf
(
sFd
"
%
zu
%
zu
calloc
(
%
zu
%
zu
)
=
%
p
\
n
"
GetPid
(
)
GetTid
(
)
aNum
aSize
ptr
)
;
}
return
ptr
;
}
static
void
*
replace_realloc
(
void
*
aPtr
size_t
aSize
)
{
MutexAutoLock
lock
(
sMutex
)
;
void
*
new_ptr
=
sFuncs
.
realloc
(
aPtr
aSize
)
;
if
(
new_ptr
|
|
!
aSize
)
{
FdPrintf
(
sFd
"
%
zu
%
zu
realloc
(
%
p
%
zu
)
=
%
p
\
n
"
GetPid
(
)
GetTid
(
)
aPtr
aSize
new_ptr
)
;
}
return
new_ptr
;
}
static
void
replace_free
(
void
*
aPtr
)
{
MutexAutoLock
lock
(
sMutex
)
;
if
(
aPtr
)
{
FdPrintf
(
sFd
"
%
zu
%
zu
free
(
%
p
)
\
n
"
GetPid
(
)
GetTid
(
)
aPtr
)
;
}
sFuncs
.
free
(
aPtr
)
;
}
static
void
*
replace_memalign
(
size_t
aAlignment
size_t
aSize
)
{
MutexAutoLock
lock
(
sMutex
)
;
void
*
ptr
=
sFuncs
.
memalign
(
aAlignment
aSize
)
;
if
(
ptr
)
{
FdPrintf
(
sFd
"
%
zu
%
zu
memalign
(
%
zu
%
zu
)
=
%
p
\
n
"
GetPid
(
)
GetTid
(
)
aAlignment
aSize
ptr
)
;
}
return
ptr
;
}
#
ifndef
LOGALLOC_MINIMAL
static
void
*
replace_valloc
(
size_t
aSize
)
{
MutexAutoLock
lock
(
sMutex
)
;
void
*
ptr
=
sFuncs
.
valloc
(
aSize
)
;
if
(
ptr
)
{
FdPrintf
(
sFd
"
%
zu
%
zu
valloc
(
%
zu
)
=
%
p
\
n
"
GetPid
(
)
GetTid
(
)
aSize
ptr
)
;
}
return
ptr
;
}
#
endif
static
void
replace_jemalloc_stats
(
jemalloc_stats_t
*
aStats
)
{
MutexAutoLock
lock
(
sMutex
)
;
sFuncs
.
jemalloc_stats
(
aStats
)
;
FdPrintf
(
sFd
"
%
zu
%
zu
jemalloc_stats
(
)
\
n
"
GetPid
(
)
GetTid
(
)
)
;
}
void
replace_init
(
malloc_table_t
*
aTable
ReplaceMallocBridge
*
*
aBridge
)
{
char
*
log
=
getenv
(
"
MALLOC_LOG
"
)
;
if
(
log
&
&
*
log
)
{
int
fd
=
0
;
const
char
*
fd_num
=
log
;
while
(
*
fd_num
)
{
if
(
*
fd_num
<
'
0
'
|
|
*
fd_num
>
'
9
'
)
{
fd
=
-
1
;
break
;
}
fd
=
fd
*
10
+
(
*
fd_num
-
'
0
'
)
;
if
(
fd
>
=
10000
)
{
fd
=
-
1
;
break
;
}
fd_num
+
+
;
}
if
(
fd
=
=
1
|
|
fd
=
=
2
)
{
sStdoutOrStderr
=
true
;
}
#
ifdef
_WIN32
HANDLE
handle
;
if
(
fd
>
0
)
{
handle
=
reinterpret_cast
<
HANDLE
>
(
_get_osfhandle
(
fd
)
)
;
}
else
{
handle
=
CreateFileA
(
log
FILE_APPEND_DATA
FILE_SHARE_READ
|
FILE_SHARE_WRITE
nullptr
OPEN_ALWAYS
FILE_ATTRIBUTE_NORMAL
nullptr
)
;
}
if
(
handle
!
=
INVALID_HANDLE_VALUE
)
{
sFd
=
reinterpret_cast
<
intptr_t
>
(
handle
)
;
}
#
else
if
(
fd
=
=
-
1
)
{
fd
=
open
(
log
O_WRONLY
|
O_CREAT
|
O_APPEND
0644
)
;
}
if
(
fd
>
0
)
{
sFd
=
fd
;
}
#
endif
}
if
(
sFd
=
=
0
)
{
return
;
}
sMutex
.
Init
(
)
;
static
LogAllocBridge
bridge
;
sFuncs
=
*
aTable
;
#
define
MALLOC_FUNCS
MALLOC_FUNCS_MALLOC_BASE
#
define
MALLOC_DECL
(
name
.
.
.
)
aTable
-
>
name
=
replace_
#
#
name
;
#
include
"
malloc_decls
.
h
"
aTable
-
>
jemalloc_stats
=
replace_jemalloc_stats
;
#
ifndef
LOGALLOC_MINIMAL
aTable
-
>
posix_memalign
=
replace_posix_memalign
;
aTable
-
>
aligned_alloc
=
replace_aligned_alloc
;
aTable
-
>
valloc
=
replace_valloc
;
#
endif
*
aBridge
=
&
bridge
;
#
ifndef
_WIN32
sFuncs
.
malloc
(
-
1
)
;
pthread_atfork
(
prefork
postfork
postfork
)
;
#
endif
}
