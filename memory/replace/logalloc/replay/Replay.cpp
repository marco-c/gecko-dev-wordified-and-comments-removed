#
define
MOZ_MEMORY_IMPL
#
include
"
mozmemory_wrap
.
h
"
#
ifdef
_WIN32
#
include
<
windows
.
h
>
#
include
<
io
.
h
>
typedef
intptr_t
ssize_t
;
#
else
#
include
<
sys
/
mman
.
h
>
#
include
<
unistd
.
h
>
#
endif
#
include
<
algorithm
>
#
include
<
cmath
>
#
include
<
cstdio
>
#
include
<
cstring
>
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
FdPrintf
.
h
"
static
void
die
(
const
char
*
message
)
{
fprintf
(
stderr
"
%
s
\
n
"
message
)
;
exit
(
1
)
;
}
template
<
typename
T
size_t
Len
>
class
MappedArray
{
public
:
MappedArray
(
)
:
mPtr
(
nullptr
)
{
}
~
MappedArray
(
)
{
if
(
mPtr
)
{
#
ifdef
_WIN32
VirtualFree
(
mPtr
sizeof
(
T
)
*
Len
MEM_RELEASE
)
;
#
else
munmap
(
mPtr
sizeof
(
T
)
*
Len
)
;
#
endif
}
}
T
&
operator
[
]
(
size_t
aIndex
)
const
{
if
(
mPtr
)
{
return
mPtr
[
aIndex
]
;
}
#
ifdef
_WIN32
mPtr
=
reinterpret_cast
<
T
*
>
(
VirtualAlloc
(
nullptr
sizeof
(
T
)
*
Len
MEM_COMMIT
|
MEM_RESERVE
PAGE_READWRITE
)
)
;
if
(
mPtr
=
=
nullptr
)
{
die
(
"
VirtualAlloc
error
"
)
;
}
#
else
mPtr
=
reinterpret_cast
<
T
*
>
(
mmap
(
nullptr
sizeof
(
T
)
*
Len
PROT_READ
|
PROT_WRITE
MAP_ANON
|
MAP_PRIVATE
-
1
0
)
)
;
if
(
mPtr
=
=
MAP_FAILED
)
{
die
(
"
Mmap
error
"
)
;
}
#
endif
return
mPtr
[
aIndex
]
;
}
private
:
mutable
T
*
mPtr
;
}
;
struct
MemSlot
{
void
*
mPtr
;
}
;
class
MemSlotList
{
static
const
size_t
kGroups
=
1024
-
1
;
static
const
size_t
kGroupSize
=
(
1024
*
1024
)
/
sizeof
(
MemSlot
)
;
MappedArray
<
MemSlot
kGroupSize
>
mSlots
[
kGroups
]
;
MappedArray
<
MemSlotList
1
>
mNext
;
public
:
MemSlot
&
operator
[
]
(
size_t
aIndex
)
const
{
if
(
aIndex
<
kGroupSize
*
kGroups
)
{
return
mSlots
[
aIndex
/
kGroupSize
]
[
aIndex
%
kGroupSize
]
;
}
aIndex
-
=
kGroupSize
*
kGroups
;
return
mNext
[
0
]
[
aIndex
]
;
}
}
;
class
Buffer
{
public
:
Buffer
(
)
:
mBuf
(
nullptr
)
mLength
(
0
)
{
}
Buffer
(
const
void
*
aBuf
size_t
aLength
)
:
mBuf
(
reinterpret_cast
<
const
char
*
>
(
aBuf
)
)
mLength
(
aLength
)
{
}
template
<
size_t
Size
>
explicit
Buffer
(
const
char
(
&
aStr
)
[
Size
]
)
:
mBuf
(
aStr
)
mLength
(
Size
-
1
)
{
}
Buffer
SplitChar
(
char
aNeedle
)
{
char
*
buf
=
const_cast
<
char
*
>
(
mBuf
)
;
char
*
c
=
reinterpret_cast
<
char
*
>
(
memchr
(
buf
aNeedle
mLength
)
)
;
if
(
!
c
)
{
return
Split
(
mLength
)
;
}
Buffer
result
=
Split
(
c
-
buf
)
;
Split
(
1
)
;
return
result
;
}
Buffer
Split
(
size_t
aLength
)
{
Buffer
result
(
mBuf
std
:
:
min
(
aLength
mLength
)
)
;
mLength
-
=
result
.
mLength
;
mBuf
+
=
result
.
mLength
;
return
result
;
}
void
Slide
(
Buffer
aOther
)
{
memmove
(
const_cast
<
char
*
>
(
aOther
.
mBuf
)
mBuf
mLength
)
;
mBuf
=
aOther
.
mBuf
;
}
bool
operator
=
=
(
Buffer
aOther
)
{
return
mLength
=
=
aOther
.
mLength
&
&
(
mBuf
=
=
aOther
.
mBuf
|
|
!
strncmp
(
mBuf
aOther
.
mBuf
mLength
)
)
;
}
explicit
operator
bool
(
)
{
return
mLength
;
}
const
char
*
get
(
)
{
return
mBuf
;
}
const
char
*
GetEnd
(
)
{
return
mBuf
+
mLength
;
}
void
Extend
(
Buffer
aOther
)
{
MOZ_ASSERT
(
aOther
.
mBuf
=
=
GetEnd
(
)
)
;
mLength
+
=
aOther
.
mLength
;
}
private
:
const
char
*
mBuf
;
size_t
mLength
;
}
;
class
FdReader
{
public
:
explicit
FdReader
(
int
aFd
)
:
mFd
(
aFd
)
mData
(
&
mRawBuf
0
)
mBuf
(
&
mRawBuf
sizeof
(
mRawBuf
)
)
{
}
Buffer
ReadLine
(
)
{
while
(
true
)
{
Buffer
result
=
mData
.
SplitChar
(
'
\
n
'
)
;
if
(
result
.
GetEnd
(
)
!
=
mData
.
GetEnd
(
)
)
{
return
result
;
}
mData
=
result
;
mData
.
Slide
(
mBuf
)
;
FillBuffer
(
)
;
if
(
!
mData
)
{
return
Buffer
(
)
;
}
}
}
private
:
void
FillBuffer
(
)
{
size_t
size
=
mBuf
.
GetEnd
(
)
-
mData
.
GetEnd
(
)
;
Buffer
remainder
(
mData
.
GetEnd
(
)
size
)
;
ssize_t
len
=
1
;
while
(
remainder
&
&
len
>
0
)
{
len
=
:
:
read
(
mFd
const_cast
<
char
*
>
(
remainder
.
get
(
)
)
size
)
;
if
(
len
<
0
)
{
die
(
"
Read
error
"
)
;
}
size
-
=
len
;
mData
.
Extend
(
remainder
.
Split
(
len
)
)
;
}
}
int
mFd
;
Buffer
mData
;
Buffer
mBuf
;
char
mRawBuf
[
4096
]
;
}
;
MOZ_BEGIN_EXTERN_C
#
define
MALLOC_DECL
(
name
return_type
.
.
.
)
\
return_type
name
#
#
_impl
(
__VA_ARGS__
)
;
#
define
MALLOC_FUNCS
MALLOC_FUNCS_MALLOC
#
include
"
malloc_decls
.
h
"
#
define
MALLOC_DECL
(
name
return_type
.
.
.
)
return_type
name
(
__VA_ARGS__
)
;
#
define
MALLOC_FUNCS
MALLOC_FUNCS_JEMALLOC
#
include
"
malloc_decls
.
h
"
#
ifdef
ANDROID
int
pthread_atfork
(
void
(
*
aPrepare
)
(
void
)
void
(
*
aParent
)
(
void
)
void
(
*
aChild
)
(
void
)
)
{
return
0
;
}
#
endif
MOZ_END_EXTERN_C
size_t
parseNumber
(
Buffer
aBuf
)
{
if
(
!
aBuf
)
{
die
(
"
Malformed
input
"
)
;
}
size_t
result
=
0
;
for
(
const
char
*
c
=
aBuf
.
get
(
)
*
end
=
aBuf
.
GetEnd
(
)
;
c
<
end
;
c
+
+
)
{
if
(
*
c
<
'
0
'
|
|
*
c
>
'
9
'
)
{
die
(
"
Malformed
input
"
)
;
}
result
*
=
10
;
result
+
=
*
c
-
'
0
'
;
}
return
result
;
}
class
Replay
{
public
:
Replay
(
)
:
mOps
(
0
)
{
#
ifdef
_WIN32
mStdErr
=
reinterpret_cast
<
intptr_t
>
(
GetStdHandle
(
STD_ERROR_HANDLE
)
)
;
#
else
mStdErr
=
fileno
(
stderr
)
;
#
endif
}
MemSlot
&
operator
[
]
(
size_t
index
)
const
{
return
mSlots
[
index
]
;
}
void
malloc
(
Buffer
&
aArgs
Buffer
&
aResult
)
{
MemSlot
&
aSlot
=
SlotForResult
(
aResult
)
;
mOps
+
+
;
size_t
size
=
parseNumber
(
aArgs
)
;
aSlot
.
mPtr
=
:
:
malloc_impl
(
size
)
;
}
void
posix_memalign
(
Buffer
&
aArgs
Buffer
&
aResult
)
{
MemSlot
&
aSlot
=
SlotForResult
(
aResult
)
;
mOps
+
+
;
size_t
alignment
=
parseNumber
(
aArgs
.
SplitChar
(
'
'
)
)
;
size_t
size
=
parseNumber
(
aArgs
)
;
void
*
ptr
;
if
(
:
:
posix_memalign_impl
(
&
ptr
alignment
size
)
=
=
0
)
{
aSlot
.
mPtr
=
ptr
;
}
else
{
aSlot
.
mPtr
=
nullptr
;
}
}
void
aligned_alloc
(
Buffer
&
aArgs
Buffer
&
aResult
)
{
MemSlot
&
aSlot
=
SlotForResult
(
aResult
)
;
mOps
+
+
;
size_t
alignment
=
parseNumber
(
aArgs
.
SplitChar
(
'
'
)
)
;
size_t
size
=
parseNumber
(
aArgs
)
;
aSlot
.
mPtr
=
:
:
aligned_alloc_impl
(
alignment
size
)
;
}
void
calloc
(
Buffer
&
aArgs
Buffer
&
aResult
)
{
MemSlot
&
aSlot
=
SlotForResult
(
aResult
)
;
mOps
+
+
;
size_t
num
=
parseNumber
(
aArgs
.
SplitChar
(
'
'
)
)
;
size_t
size
=
parseNumber
(
aArgs
)
;
aSlot
.
mPtr
=
:
:
calloc_impl
(
num
size
)
;
}
void
realloc
(
Buffer
&
aArgs
Buffer
&
aResult
)
{
MemSlot
&
aSlot
=
SlotForResult
(
aResult
)
;
mOps
+
+
;
Buffer
dummy
=
aArgs
.
SplitChar
(
'
#
'
)
;
if
(
dummy
)
{
die
(
"
Malformed
input
"
)
;
}
size_t
slot_id
=
parseNumber
(
aArgs
.
SplitChar
(
'
'
)
)
;
size_t
size
=
parseNumber
(
aArgs
)
;
MemSlot
&
old_slot
=
(
*
this
)
[
slot_id
]
;
void
*
old_ptr
=
old_slot
.
mPtr
;
old_slot
.
mPtr
=
nullptr
;
aSlot
.
mPtr
=
:
:
realloc_impl
(
old_ptr
size
)
;
}
void
free
(
Buffer
&
aArgs
Buffer
&
aResult
)
{
if
(
aResult
)
{
die
(
"
Malformed
input
"
)
;
}
mOps
+
+
;
Buffer
dummy
=
aArgs
.
SplitChar
(
'
#
'
)
;
if
(
dummy
)
{
die
(
"
Malformed
input
"
)
;
}
size_t
slot_id
=
parseNumber
(
aArgs
)
;
MemSlot
&
slot
=
(
*
this
)
[
slot_id
]
;
:
:
free_impl
(
slot
.
mPtr
)
;
slot
.
mPtr
=
nullptr
;
}
void
memalign
(
Buffer
&
aArgs
Buffer
&
aResult
)
{
MemSlot
&
aSlot
=
SlotForResult
(
aResult
)
;
mOps
+
+
;
size_t
alignment
=
parseNumber
(
aArgs
.
SplitChar
(
'
'
)
)
;
size_t
size
=
parseNumber
(
aArgs
)
;
aSlot
.
mPtr
=
:
:
memalign_impl
(
alignment
size
)
;
}
void
valloc
(
Buffer
&
aArgs
Buffer
&
aResult
)
{
MemSlot
&
aSlot
=
SlotForResult
(
aResult
)
;
mOps
+
+
;
size_t
size
=
parseNumber
(
aArgs
)
;
aSlot
.
mPtr
=
:
:
valloc_impl
(
size
)
;
}
void
jemalloc_stats
(
Buffer
&
aArgs
Buffer
&
aResult
)
{
if
(
aArgs
|
|
aResult
)
{
die
(
"
Malformed
input
"
)
;
}
mOps
+
+
;
jemalloc_stats_t
stats
;
jemalloc_bin_stats_t
bin_stats
[
JEMALLOC_MAX_STATS_BINS
]
;
:
:
jemalloc_stats_internal
(
&
stats
bin_stats
)
;
FdPrintf
(
mStdErr
"
\
n
"
)
;
FdPrintf
(
mStdErr
"
Ops
:
%
9zu
\
n
"
mOps
)
;
FdPrintf
(
mStdErr
"
mapped
:
%
9zu
\
n
"
stats
.
mapped
)
;
FdPrintf
(
mStdErr
"
allocated
:
%
9zu
\
n
"
stats
.
allocated
)
;
FdPrintf
(
mStdErr
"
waste
:
%
9zu
\
n
"
stats
.
waste
)
;
FdPrintf
(
mStdErr
"
dirty
:
%
9zu
\
n
"
stats
.
page_cache
)
;
FdPrintf
(
mStdErr
"
bookkeep
:
%
9zu
\
n
"
stats
.
bookkeeping
)
;
FdPrintf
(
mStdErr
"
bin
-
unused
:
%
9zu
\
n
"
stats
.
bin_unused
)
;
FdPrintf
(
mStdErr
"
quantum
-
max
:
%
9zu
\
n
"
stats
.
quantum_max
)
;
FdPrintf
(
mStdErr
"
subpage
-
max
:
%
9zu
\
n
"
stats
.
page_size
/
2
)
;
FdPrintf
(
mStdErr
"
large
-
max
:
%
9zu
\
n
"
stats
.
large_max
)
;
FdPrintf
(
mStdErr
"
\
n
%
8s
%
11s
%
10s
%
8s
%
9s
%
9s
%
8s
\
n
"
"
bin
-
size
"
"
unused
(
c
)
"
"
total
(
c
)
"
"
used
(
c
)
"
"
non
-
full
(
r
)
"
"
total
(
r
)
"
"
used
(
r
)
"
)
;
for
(
auto
&
bin
:
bin_stats
)
{
if
(
bin
.
size
)
{
FdPrintf
(
mStdErr
"
%
8zu
%
8zuKiB
%
7zuKiB
%
7zu
%
%
%
12zu
%
9zu
%
7zu
%
%
\
n
"
bin
.
size
bin
.
bytes_unused
/
1024
bin
.
bytes_total
/
1024
percent
(
bin
.
bytes_total
-
bin
.
bytes_unused
bin
.
bytes_total
)
bin
.
num_non_full_runs
bin
.
num_runs
percent
(
bin
.
num_runs
-
bin
.
num_non_full_runs
bin
.
num_runs
)
)
;
}
}
}
private
:
static
size_t
percent
(
size_t
a
size_t
b
)
{
if
(
!
b
)
{
return
0
;
}
return
size_t
(
round
(
double
(
a
)
/
double
(
b
)
*
100
.
0
)
)
;
}
MemSlot
&
SlotForResult
(
Buffer
&
aResult
)
{
Buffer
dummy
=
aResult
.
SplitChar
(
'
=
'
)
;
Buffer
dummy2
=
aResult
.
SplitChar
(
'
#
'
)
;
if
(
dummy
|
|
dummy2
)
{
die
(
"
Malformed
input
"
)
;
}
size_t
slot_id
=
parseNumber
(
aResult
)
;
return
mSlots
[
slot_id
]
;
}
intptr_t
mStdErr
;
size_t
mOps
;
MemSlotList
mSlots
;
}
;
int
main
(
)
{
size_t
first_pid
=
0
;
FdReader
reader
(
0
)
;
Replay
replay
;
while
(
true
)
{
Buffer
line
=
reader
.
ReadLine
(
)
;
if
(
!
line
)
{
break
;
}
size_t
pid
=
parseNumber
(
line
.
SplitChar
(
'
'
)
)
;
if
(
!
first_pid
)
{
first_pid
=
pid
;
}
if
(
first_pid
!
=
pid
)
{
continue
;
}
parseNumber
(
line
.
SplitChar
(
'
'
)
)
;
Buffer
func
=
line
.
SplitChar
(
'
(
'
)
;
Buffer
args
=
line
.
SplitChar
(
'
)
'
)
;
if
(
func
=
=
Buffer
(
"
jemalloc_stats
"
)
)
{
replay
.
jemalloc_stats
(
args
line
)
;
}
else
if
(
func
=
=
Buffer
(
"
free
"
)
)
{
replay
.
free
(
args
line
)
;
}
else
if
(
func
=
=
Buffer
(
"
malloc
"
)
)
{
replay
.
malloc
(
args
line
)
;
}
else
if
(
func
=
=
Buffer
(
"
posix_memalign
"
)
)
{
replay
.
posix_memalign
(
args
line
)
;
}
else
if
(
func
=
=
Buffer
(
"
aligned_alloc
"
)
)
{
replay
.
aligned_alloc
(
args
line
)
;
}
else
if
(
func
=
=
Buffer
(
"
calloc
"
)
)
{
replay
.
calloc
(
args
line
)
;
}
else
if
(
func
=
=
Buffer
(
"
realloc
"
)
)
{
replay
.
realloc
(
args
line
)
;
}
else
if
(
func
=
=
Buffer
(
"
memalign
"
)
)
{
replay
.
memalign
(
args
line
)
;
}
else
if
(
func
=
=
Buffer
(
"
valloc
"
)
)
{
replay
.
valloc
(
args
line
)
;
}
else
{
die
(
"
Malformed
input
"
)
;
}
}
return
0
;
}
