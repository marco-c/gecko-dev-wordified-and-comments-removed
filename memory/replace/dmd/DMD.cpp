#
include
<
ctype
.
h
>
#
include
<
errno
.
h
>
#
include
<
limits
.
h
>
#
include
<
stdarg
.
h
>
#
include
<
stdio
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
string
.
h
>
#
if
!
defined
(
MOZ_PROFILING
)
#
error
"
DMD
requires
MOZ_PROFILING
"
#
endif
#
ifdef
XP_WIN
#
include
<
windows
.
h
>
#
include
<
process
.
h
>
#
else
#
include
<
pthread
.
h
>
#
include
<
sys
/
types
.
h
>
#
include
<
unistd
.
h
>
#
endif
#
ifdef
ANDROID
#
include
<
android
/
log
.
h
>
#
endif
#
include
"
nscore
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
FastBernoulliTrial
.
h
"
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
"
mozilla
/
HashTable
.
h
"
#
include
"
mozilla
/
IntegerPrintfMacros
.
h
"
#
include
"
mozilla
/
JSONWriter
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
StackWalk
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
CodeAddressService
.
h
"
#
include
"
replace_malloc
.
h
"
#
include
"
DMD
.
h
"
namespace
mozilla
{
namespace
dmd
{
class
DMDBridge
:
public
ReplaceMallocBridge
{
virtual
DMDFuncs
*
GetDMDFuncs
(
)
override
;
}
;
static
DMDBridge
*
gDMDBridge
;
static
DMDFuncs
gDMDFuncs
;
DMDFuncs
*
DMDBridge
:
:
GetDMDFuncs
(
)
{
return
&
gDMDFuncs
;
}
MOZ_FORMAT_PRINTF
(
1
2
)
inline
void
StatusMsg
(
const
char
*
aFmt
.
.
.
)
{
va_list
ap
;
va_start
(
ap
aFmt
)
;
gDMDFuncs
.
StatusMsg
(
aFmt
ap
)
;
va_end
(
ap
)
;
}
#
ifndef
DISALLOW_COPY_AND_ASSIGN
#
define
DISALLOW_COPY_AND_ASSIGN
(
T
)
\
T
(
const
T
&
)
;
\
void
operator
=
(
const
T
&
)
#
endif
static
malloc_table_t
gMallocTable
;
class
InfallibleAllocPolicy
{
static
void
ExitOnFailure
(
const
void
*
aP
)
;
public
:
template
<
typename
T
>
static
T
*
maybe_pod_malloc
(
size_t
aNumElems
)
{
if
(
aNumElems
&
mozilla
:
:
tl
:
:
MulOverflowMask
<
sizeof
(
T
)
>
:
:
value
)
return
nullptr
;
return
(
T
*
)
gMallocTable
.
malloc
(
aNumElems
*
sizeof
(
T
)
)
;
}
template
<
typename
T
>
static
T
*
maybe_pod_calloc
(
size_t
aNumElems
)
{
return
(
T
*
)
gMallocTable
.
calloc
(
aNumElems
sizeof
(
T
)
)
;
}
template
<
typename
T
>
static
T
*
maybe_pod_realloc
(
T
*
aPtr
size_t
aOldSize
size_t
aNewSize
)
{
if
(
aNewSize
&
mozilla
:
:
tl
:
:
MulOverflowMask
<
sizeof
(
T
)
>
:
:
value
)
return
nullptr
;
return
(
T
*
)
gMallocTable
.
realloc
(
aPtr
aNewSize
*
sizeof
(
T
)
)
;
}
static
void
*
malloc_
(
size_t
aSize
)
{
void
*
p
=
gMallocTable
.
malloc
(
aSize
)
;
ExitOnFailure
(
p
)
;
return
p
;
}
template
<
typename
T
>
static
T
*
pod_malloc
(
size_t
aNumElems
)
{
T
*
p
=
maybe_pod_malloc
<
T
>
(
aNumElems
)
;
ExitOnFailure
(
p
)
;
return
p
;
}
static
void
*
calloc_
(
size_t
aSize
)
{
void
*
p
=
gMallocTable
.
calloc
(
1
aSize
)
;
ExitOnFailure
(
p
)
;
return
p
;
}
template
<
typename
T
>
static
T
*
pod_calloc
(
size_t
aNumElems
)
{
T
*
p
=
maybe_pod_calloc
<
T
>
(
aNumElems
)
;
ExitOnFailure
(
p
)
;
return
p
;
}
static
void
*
realloc_
(
void
*
aPtr
size_t
aNewSize
)
{
void
*
p
=
gMallocTable
.
realloc
(
aPtr
aNewSize
)
;
ExitOnFailure
(
p
)
;
return
p
;
}
template
<
typename
T
>
static
T
*
pod_realloc
(
T
*
aPtr
size_t
aOldSize
size_t
aNewSize
)
{
T
*
p
=
maybe_pod_realloc
(
aPtr
aOldSize
aNewSize
)
;
ExitOnFailure
(
p
)
;
return
p
;
}
static
void
*
memalign_
(
size_t
aAlignment
size_t
aSize
)
{
void
*
p
=
gMallocTable
.
memalign
(
aAlignment
aSize
)
;
ExitOnFailure
(
p
)
;
return
p
;
}
template
<
typename
T
>
static
void
free_
(
T
*
aPtr
size_t
aSize
=
0
)
{
gMallocTable
.
free
(
aPtr
)
;
}
static
char
*
strdup_
(
const
char
*
aStr
)
{
char
*
s
=
(
char
*
)
InfallibleAllocPolicy
:
:
malloc_
(
strlen
(
aStr
)
+
1
)
;
strcpy
(
s
aStr
)
;
return
s
;
}
template
<
class
T
>
static
T
*
new_
(
)
{
void
*
mem
=
malloc_
(
sizeof
(
T
)
)
;
return
new
(
mem
)
T
;
}
template
<
class
T
typename
P1
>
static
T
*
new_
(
P1
aP1
)
{
void
*
mem
=
malloc_
(
sizeof
(
T
)
)
;
return
new
(
mem
)
T
(
aP1
)
;
}
template
<
class
T
>
static
void
delete_
(
T
*
aPtr
)
{
if
(
aPtr
)
{
aPtr
-
>
~
T
(
)
;
InfallibleAllocPolicy
:
:
free_
(
aPtr
)
;
}
}
static
void
reportAllocOverflow
(
)
{
ExitOnFailure
(
nullptr
)
;
}
bool
checkSimulatedOOM
(
)
const
{
return
true
;
}
}
;
static
size_t
MallocSizeOf
(
const
void
*
aPtr
)
{
return
gMallocTable
.
malloc_usable_size
(
const_cast
<
void
*
>
(
aPtr
)
)
;
}
void
DMDFuncs
:
:
StatusMsg
(
const
char
*
aFmt
va_list
aAp
)
{
#
ifdef
ANDROID
__android_log_vprint
(
ANDROID_LOG_INFO
"
DMD
"
aFmt
aAp
)
;
#
else
char
*
fmt
=
(
char
*
)
InfallibleAllocPolicy
:
:
malloc_
(
strlen
(
aFmt
)
+
64
)
;
sprintf
(
fmt
"
DMD
[
%
d
]
%
s
"
getpid
(
)
aFmt
)
;
vfprintf
(
stderr
fmt
aAp
)
;
InfallibleAllocPolicy
:
:
free_
(
fmt
)
;
#
endif
}
void
InfallibleAllocPolicy
:
:
ExitOnFailure
(
const
void
*
aP
)
{
if
(
!
aP
)
{
MOZ_CRASH
(
"
DMD
out
of
memory
;
aborting
"
)
;
}
}
static
double
Percent
(
size_t
part
size_t
whole
)
{
return
(
whole
=
=
0
)
?
0
:
100
*
(
double
)
part
/
whole
;
}
static
char
*
Show
(
size_t
n
char
*
buf
size_t
buflen
)
{
int
nc
=
0
i
=
0
lasti
=
buflen
-
2
;
buf
[
lasti
+
1
]
=
'
\
0
'
;
if
(
n
=
=
0
)
{
buf
[
lasti
-
i
]
=
'
0
'
;
i
+
+
;
}
else
{
while
(
n
>
0
)
{
if
(
(
(
i
-
nc
)
%
3
)
=
=
0
&
&
i
!
=
0
)
{
buf
[
lasti
-
i
]
=
'
'
;
i
+
+
;
nc
+
+
;
}
buf
[
lasti
-
i
]
=
static_cast
<
char
>
(
(
n
%
10
)
+
'
0
'
)
;
i
+
+
;
n
/
=
10
;
}
}
int
firstCharIndex
=
lasti
-
i
+
1
;
MOZ_ASSERT
(
firstCharIndex
>
=
0
)
;
return
&
buf
[
firstCharIndex
]
;
}
class
Options
{
template
<
typename
T
>
struct
NumOption
{
const
T
mDefault
;
const
T
mMax
;
T
mActual
;
NumOption
(
T
aDefault
T
aMax
)
:
mDefault
(
aDefault
)
mMax
(
aMax
)
mActual
(
aDefault
)
{
}
}
;
enum
class
Mode
{
Live
DarkMatter
Cumulative
Scan
}
;
enum
class
Stacks
{
Full
Partial
}
;
char
*
mDMDEnvVar
;
Mode
mMode
;
Stacks
mStacks
;
bool
mShowDumpStats
;
void
BadArg
(
const
char
*
aArg
)
;
static
const
char
*
ValueIfMatch
(
const
char
*
aArg
const
char
*
aOptionName
)
;
static
bool
GetLong
(
const
char
*
aArg
const
char
*
aOptionName
long
aMin
long
aMax
long
*
aValue
)
;
static
bool
GetBool
(
const
char
*
aArg
const
char
*
aOptionName
bool
*
aValue
)
;
public
:
explicit
Options
(
const
char
*
aDMDEnvVar
)
;
bool
IsLiveMode
(
)
const
{
return
mMode
=
=
Mode
:
:
Live
;
}
bool
IsDarkMatterMode
(
)
const
{
return
mMode
=
=
Mode
:
:
DarkMatter
;
}
bool
IsCumulativeMode
(
)
const
{
return
mMode
=
=
Mode
:
:
Cumulative
;
}
bool
IsScanMode
(
)
const
{
return
mMode
=
=
Mode
:
:
Scan
;
}
const
char
*
ModeString
(
)
const
;
const
char
*
DMDEnvVar
(
)
const
{
return
mDMDEnvVar
;
}
bool
DoFullStacks
(
)
const
{
return
mStacks
=
=
Stacks
:
:
Full
;
}
size_t
ShowDumpStats
(
)
const
{
return
mShowDumpStats
;
}
}
;
static
Options
*
gOptions
;
#
ifdef
XP_WIN
class
MutexBase
{
CRITICAL_SECTION
mCS
;
DISALLOW_COPY_AND_ASSIGN
(
MutexBase
)
;
public
:
MutexBase
(
)
{
InitializeCriticalSection
(
&
mCS
)
;
}
~
MutexBase
(
)
{
DeleteCriticalSection
(
&
mCS
)
;
}
void
Lock
(
)
{
EnterCriticalSection
(
&
mCS
)
;
}
void
Unlock
(
)
{
LeaveCriticalSection
(
&
mCS
)
;
}
}
;
#
else
class
MutexBase
{
pthread_mutex_t
mMutex
;
DISALLOW_COPY_AND_ASSIGN
(
MutexBase
)
;
public
:
MutexBase
(
)
{
pthread_mutex_init
(
&
mMutex
nullptr
)
;
}
void
Lock
(
)
{
pthread_mutex_lock
(
&
mMutex
)
;
}
void
Unlock
(
)
{
pthread_mutex_unlock
(
&
mMutex
)
;
}
}
;
#
endif
class
Mutex
:
private
MutexBase
{
bool
mIsLocked
;
DISALLOW_COPY_AND_ASSIGN
(
Mutex
)
;
public
:
Mutex
(
)
:
mIsLocked
(
false
)
{
}
void
Lock
(
)
{
MutexBase
:
:
Lock
(
)
;
MOZ_ASSERT
(
!
mIsLocked
)
;
mIsLocked
=
true
;
}
void
Unlock
(
)
{
MOZ_ASSERT
(
mIsLocked
)
;
mIsLocked
=
false
;
MutexBase
:
:
Unlock
(
)
;
}
bool
IsLocked
(
)
{
return
mIsLocked
;
}
}
;
static
Mutex
*
gStateLock
=
nullptr
;
class
AutoLockState
{
DISALLOW_COPY_AND_ASSIGN
(
AutoLockState
)
;
public
:
AutoLockState
(
)
{
gStateLock
-
>
Lock
(
)
;
}
~
AutoLockState
(
)
{
gStateLock
-
>
Unlock
(
)
;
}
}
;
class
AutoUnlockState
{
DISALLOW_COPY_AND_ASSIGN
(
AutoUnlockState
)
;
public
:
AutoUnlockState
(
)
{
gStateLock
-
>
Unlock
(
)
;
}
~
AutoUnlockState
(
)
{
gStateLock
-
>
Lock
(
)
;
}
}
;
#
ifdef
XP_WIN
#
define
DMD_TLS_INDEX_TYPE
DWORD
#
define
DMD_CREATE_TLS_INDEX
(
i_
)
do
{
\
(
i_
)
=
TlsAlloc
(
)
;
\
}
while
(
0
)
#
define
DMD_DESTROY_TLS_INDEX
(
i_
)
TlsFree
(
(
i_
)
)
#
define
DMD_GET_TLS_DATA
(
i_
)
TlsGetValue
(
(
i_
)
)
#
define
DMD_SET_TLS_DATA
(
i_
v_
)
TlsSetValue
(
(
i_
)
(
v_
)
)
#
else
#
define
DMD_TLS_INDEX_TYPE
pthread_key_t
#
define
DMD_CREATE_TLS_INDEX
(
i_
)
pthread_key_create
(
&
(
i_
)
nullptr
)
#
define
DMD_DESTROY_TLS_INDEX
(
i_
)
pthread_key_delete
(
(
i_
)
)
#
define
DMD_GET_TLS_DATA
(
i_
)
pthread_getspecific
(
(
i_
)
)
#
define
DMD_SET_TLS_DATA
(
i_
v_
)
pthread_setspecific
(
(
i_
)
(
v_
)
)
#
endif
static
DMD_TLS_INDEX_TYPE
gTlsIndex
;
class
Thread
{
friend
class
InfallibleAllocPolicy
;
bool
mBlockIntercepts
;
Thread
(
)
:
mBlockIntercepts
(
false
)
{
}
DISALLOW_COPY_AND_ASSIGN
(
Thread
)
;
public
:
static
Thread
*
Fetch
(
)
;
bool
BlockIntercepts
(
)
{
MOZ_ASSERT
(
!
mBlockIntercepts
)
;
return
mBlockIntercepts
=
true
;
}
bool
UnblockIntercepts
(
)
{
MOZ_ASSERT
(
mBlockIntercepts
)
;
return
mBlockIntercepts
=
false
;
}
bool
InterceptsAreBlocked
(
)
const
{
return
mBlockIntercepts
;
}
}
;
Thread
*
Thread
:
:
Fetch
(
)
{
Thread
*
t
=
static_cast
<
Thread
*
>
(
DMD_GET_TLS_DATA
(
gTlsIndex
)
)
;
if
(
MOZ_UNLIKELY
(
!
t
)
)
{
t
=
InfallibleAllocPolicy
:
:
new_
<
Thread
>
(
)
;
DMD_SET_TLS_DATA
(
gTlsIndex
t
)
;
}
return
t
;
}
class
AutoBlockIntercepts
{
Thread
*
const
mT
;
DISALLOW_COPY_AND_ASSIGN
(
AutoBlockIntercepts
)
;
public
:
explicit
AutoBlockIntercepts
(
Thread
*
aT
)
:
mT
(
aT
)
{
mT
-
>
BlockIntercepts
(
)
;
}
~
AutoBlockIntercepts
(
)
{
MOZ_ASSERT
(
mT
-
>
InterceptsAreBlocked
(
)
)
;
mT
-
>
UnblockIntercepts
(
)
;
}
}
;
class
StringTable
{
public
:
StringTable
(
)
{
MOZ_ALWAYS_TRUE
(
mSet
.
init
(
64
)
)
;
}
const
char
*
Intern
(
const
char
*
aString
)
{
StringHashSet
:
:
AddPtr
p
=
mSet
.
lookupForAdd
(
aString
)
;
if
(
p
)
{
return
*
p
;
}
const
char
*
newString
=
InfallibleAllocPolicy
:
:
strdup_
(
aString
)
;
MOZ_ALWAYS_TRUE
(
mSet
.
add
(
p
newString
)
)
;
return
newString
;
}
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
0
;
n
+
=
mSet
.
shallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
for
(
auto
iter
=
mSet
.
iter
(
)
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
n
+
=
aMallocSizeOf
(
iter
.
get
(
)
)
;
}
return
n
;
}
private
:
struct
StringHasher
{
typedef
const
char
*
Lookup
;
static
mozilla
:
:
HashNumber
hash
(
const
char
*
const
&
aS
)
{
return
HashString
(
aS
)
;
}
static
bool
match
(
const
char
*
const
&
aA
const
char
*
const
&
aB
)
{
return
strcmp
(
aA
aB
)
=
=
0
;
}
}
;
typedef
mozilla
:
:
HashSet
<
const
char
*
StringHasher
InfallibleAllocPolicy
>
StringHashSet
;
StringHashSet
mSet
;
}
;
class
StringAlloc
{
public
:
static
char
*
copy
(
const
char
*
aString
)
{
return
InfallibleAllocPolicy
:
:
strdup_
(
aString
)
;
}
static
void
free
(
char
*
aString
)
{
InfallibleAllocPolicy
:
:
free_
(
aString
)
;
}
}
;
struct
DescribeCodeAddressLock
{
static
void
Unlock
(
)
{
gStateLock
-
>
Unlock
(
)
;
}
static
void
Lock
(
)
{
gStateLock
-
>
Lock
(
)
;
}
static
bool
IsLocked
(
)
{
return
gStateLock
-
>
IsLocked
(
)
;
}
}
;
typedef
CodeAddressService
<
StringTable
StringAlloc
DescribeCodeAddressLock
>
CodeAddressService
;
class
StackTrace
{
public
:
static
const
uint32_t
MaxFrames
=
24
;
private
:
uint32_t
mLength
;
const
void
*
mPcs
[
MaxFrames
]
;
public
:
StackTrace
(
)
:
mLength
(
0
)
{
}
uint32_t
Length
(
)
const
{
return
mLength
;
}
const
void
*
Pc
(
uint32_t
i
)
const
{
MOZ_ASSERT
(
i
<
mLength
)
;
return
mPcs
[
i
]
;
}
uint32_t
Size
(
)
const
{
return
mLength
*
sizeof
(
mPcs
[
0
]
)
;
}
static
const
StackTrace
*
Get
(
Thread
*
aT
)
;
typedef
StackTrace
*
Lookup
;
static
mozilla
:
:
HashNumber
hash
(
const
StackTrace
*
const
&
aSt
)
{
return
mozilla
:
:
HashBytes
(
aSt
-
>
mPcs
aSt
-
>
Size
(
)
)
;
}
static
bool
match
(
const
StackTrace
*
const
&
aA
const
StackTrace
*
const
&
aB
)
{
return
aA
-
>
mLength
=
=
aB
-
>
mLength
&
&
memcmp
(
aA
-
>
mPcs
aB
-
>
mPcs
aA
-
>
Size
(
)
)
=
=
0
;
}
private
:
static
void
StackWalkCallback
(
uint32_t
aFrameNumber
void
*
aPc
void
*
aSp
void
*
aClosure
)
{
StackTrace
*
st
=
(
StackTrace
*
)
aClosure
;
MOZ_ASSERT
(
st
-
>
mLength
<
MaxFrames
)
;
st
-
>
mPcs
[
st
-
>
mLength
]
=
aPc
;
st
-
>
mLength
+
+
;
MOZ_ASSERT
(
st
-
>
mLength
=
=
aFrameNumber
)
;
}
}
;
typedef
mozilla
:
:
HashSet
<
StackTrace
*
StackTrace
InfallibleAllocPolicy
>
StackTraceTable
;
static
StackTraceTable
*
gStackTraceTable
=
nullptr
;
typedef
mozilla
:
:
HashSet
<
const
StackTrace
*
mozilla
:
:
DefaultHasher
<
const
StackTrace
*
>
InfallibleAllocPolicy
>
StackTraceSet
;
typedef
mozilla
:
:
HashSet
<
const
void
*
mozilla
:
:
DefaultHasher
<
const
void
*
>
InfallibleAllocPolicy
>
PointerSet
;
typedef
mozilla
:
:
HashMap
<
const
void
*
uint32_t
mozilla
:
:
DefaultHasher
<
const
void
*
>
InfallibleAllocPolicy
>
PointerIdMap
;
static
uint32_t
gGCStackTraceTableWhenSizeExceeds
=
4
*
1024
;
const
StackTrace
*
StackTrace
:
:
Get
(
Thread
*
aT
)
{
MOZ_ASSERT
(
gStateLock
-
>
IsLocked
(
)
)
;
MOZ_ASSERT
(
aT
-
>
InterceptsAreBlocked
(
)
)
;
StackTrace
tmp
;
{
AutoUnlockState
unlock
;
#
if
defined
(
XP_WIN
)
&
&
defined
(
_M_IX86
)
CONTEXT
context
;
RtlCaptureContext
(
&
context
)
;
void
*
*
fp
=
reinterpret_cast
<
void
*
*
>
(
context
.
Ebp
)
;
PNT_TIB
pTib
=
reinterpret_cast
<
PNT_TIB
>
(
NtCurrentTeb
(
)
)
;
void
*
stackEnd
=
static_cast
<
void
*
>
(
pTib
-
>
StackBase
)
;
FramePointerStackWalk
(
StackWalkCallback
0
MaxFrames
&
tmp
fp
stackEnd
)
;
#
elif
defined
(
XP_MACOSX
)
void
*
*
fp
;
asm
(
"
movq
(
%
%
rbp
)
%
0
\
n
\
t
"
:
"
=
r
"
(
fp
)
)
;
void
*
stackEnd
=
pthread_get_stackaddr_np
(
pthread_self
(
)
)
;
FramePointerStackWalk
(
StackWalkCallback
0
MaxFrames
&
tmp
fp
stackEnd
)
;
#
else
#
if
defined
(
XP_WIN
)
&
&
defined
(
_M_X64
)
int
skipFrames
=
1
;
#
else
int
skipFrames
=
2
;
#
endif
MozStackWalk
(
StackWalkCallback
skipFrames
MaxFrames
&
tmp
)
;
#
endif
}
StackTraceTable
:
:
AddPtr
p
=
gStackTraceTable
-
>
lookupForAdd
(
&
tmp
)
;
if
(
!
p
)
{
StackTrace
*
stnew
=
InfallibleAllocPolicy
:
:
new_
<
StackTrace
>
(
tmp
)
;
MOZ_ALWAYS_TRUE
(
gStackTraceTable
-
>
add
(
p
stnew
)
)
;
}
return
*
p
;
}
template
<
typename
T
>
class
TaggedPtr
{
union
{
T
mPtr
;
uintptr_t
mUint
;
}
;
static
const
uintptr_t
kTagMask
=
uintptr_t
(
0x1
)
;
static
const
uintptr_t
kPtrMask
=
~
kTagMask
;
static
bool
IsTwoByteAligned
(
T
aPtr
)
{
return
(
uintptr_t
(
aPtr
)
&
kTagMask
)
=
=
0
;
}
public
:
TaggedPtr
(
)
:
mPtr
(
nullptr
)
{
}
TaggedPtr
(
T
aPtr
bool
aBool
)
:
mPtr
(
aPtr
)
{
MOZ_ASSERT
(
IsTwoByteAligned
(
aPtr
)
)
;
uintptr_t
tag
=
uintptr_t
(
aBool
)
;
MOZ_ASSERT
(
tag
<
=
kTagMask
)
;
mUint
|
=
(
tag
&
kTagMask
)
;
}
void
Set
(
T
aPtr
bool
aBool
)
{
MOZ_ASSERT
(
IsTwoByteAligned
(
aPtr
)
)
;
mPtr
=
aPtr
;
uintptr_t
tag
=
uintptr_t
(
aBool
)
;
MOZ_ASSERT
(
tag
<
=
kTagMask
)
;
mUint
|
=
(
tag
&
kTagMask
)
;
}
T
Ptr
(
)
const
{
return
reinterpret_cast
<
T
>
(
mUint
&
kPtrMask
)
;
}
bool
Tag
(
)
const
{
return
bool
(
mUint
&
kTagMask
)
;
}
}
;
class
LiveBlock
{
const
void
*
mPtr
;
const
size_t
mReqSize
;
const
StackTrace
*
const
mAllocStackTrace
;
mutable
TaggedPtr
<
const
StackTrace
*
>
mReportStackTrace_mReportedOnAlloc
[
2
]
;
public
:
LiveBlock
(
const
void
*
aPtr
size_t
aReqSize
const
StackTrace
*
aAllocStackTrace
)
:
mPtr
(
aPtr
)
mReqSize
(
aReqSize
)
mAllocStackTrace
(
aAllocStackTrace
)
mReportStackTrace_mReportedOnAlloc
(
)
{
}
const
void
*
Address
(
)
const
{
return
mPtr
;
}
size_t
ReqSize
(
)
const
{
return
mReqSize
;
}
size_t
SlopSize
(
)
const
{
return
MallocSizeOf
(
mPtr
)
-
mReqSize
;
}
const
StackTrace
*
AllocStackTrace
(
)
const
{
return
mAllocStackTrace
;
}
const
StackTrace
*
ReportStackTrace1
(
)
const
{
MOZ_ASSERT
(
gOptions
-
>
IsDarkMatterMode
(
)
)
;
return
mReportStackTrace_mReportedOnAlloc
[
0
]
.
Ptr
(
)
;
}
const
StackTrace
*
ReportStackTrace2
(
)
const
{
MOZ_ASSERT
(
gOptions
-
>
IsDarkMatterMode
(
)
)
;
return
mReportStackTrace_mReportedOnAlloc
[
1
]
.
Ptr
(
)
;
}
bool
ReportedOnAlloc1
(
)
const
{
MOZ_ASSERT
(
gOptions
-
>
IsDarkMatterMode
(
)
)
;
return
mReportStackTrace_mReportedOnAlloc
[
0
]
.
Tag
(
)
;
}
bool
ReportedOnAlloc2
(
)
const
{
MOZ_ASSERT
(
gOptions
-
>
IsDarkMatterMode
(
)
)
;
return
mReportStackTrace_mReportedOnAlloc
[
1
]
.
Tag
(
)
;
}
void
AddStackTracesToTable
(
StackTraceSet
&
aStackTraces
)
const
{
if
(
AllocStackTrace
(
)
)
{
MOZ_ALWAYS_TRUE
(
aStackTraces
.
put
(
AllocStackTrace
(
)
)
)
;
}
if
(
gOptions
-
>
IsDarkMatterMode
(
)
)
{
if
(
ReportStackTrace1
(
)
)
{
MOZ_ALWAYS_TRUE
(
aStackTraces
.
put
(
ReportStackTrace1
(
)
)
)
;
}
if
(
ReportStackTrace2
(
)
)
{
MOZ_ALWAYS_TRUE
(
aStackTraces
.
put
(
ReportStackTrace2
(
)
)
)
;
}
}
}
uint32_t
NumReports
(
)
const
{
MOZ_ASSERT
(
gOptions
-
>
IsDarkMatterMode
(
)
)
;
if
(
ReportStackTrace2
(
)
)
{
MOZ_ASSERT
(
ReportStackTrace1
(
)
)
;
return
2
;
}
if
(
ReportStackTrace1
(
)
)
{
return
1
;
}
return
0
;
}
void
Report
(
Thread
*
aT
bool
aReportedOnAlloc
)
const
{
MOZ_ASSERT
(
gOptions
-
>
IsDarkMatterMode
(
)
)
;
uint32_t
numReports
=
NumReports
(
)
;
if
(
numReports
<
2
)
{
mReportStackTrace_mReportedOnAlloc
[
numReports
]
.
Set
(
StackTrace
:
:
Get
(
aT
)
aReportedOnAlloc
)
;
}
}
void
UnreportIfNotReportedOnAlloc
(
)
const
{
MOZ_ASSERT
(
gOptions
-
>
IsDarkMatterMode
(
)
)
;
if
(
!
ReportedOnAlloc1
(
)
&
&
!
ReportedOnAlloc2
(
)
)
{
mReportStackTrace_mReportedOnAlloc
[
0
]
.
Set
(
nullptr
0
)
;
mReportStackTrace_mReportedOnAlloc
[
1
]
.
Set
(
nullptr
0
)
;
}
else
if
(
!
ReportedOnAlloc1
(
)
&
&
ReportedOnAlloc2
(
)
)
{
mReportStackTrace_mReportedOnAlloc
[
0
]
=
mReportStackTrace_mReportedOnAlloc
[
1
]
;
mReportStackTrace_mReportedOnAlloc
[
1
]
.
Set
(
nullptr
0
)
;
}
else
if
(
ReportedOnAlloc1
(
)
&
&
!
ReportedOnAlloc2
(
)
)
{
mReportStackTrace_mReportedOnAlloc
[
1
]
.
Set
(
nullptr
0
)
;
}
}
typedef
const
void
*
Lookup
;
static
mozilla
:
:
HashNumber
hash
(
const
void
*
const
&
aPtr
)
{
return
mozilla
:
:
HashGeneric
(
aPtr
)
;
}
static
bool
match
(
const
LiveBlock
&
aB
const
void
*
const
&
aPtr
)
{
return
aB
.
mPtr
=
=
aPtr
;
}
}
;
typedef
mozilla
:
:
HashSet
<
LiveBlock
LiveBlock
InfallibleAllocPolicy
>
LiveBlockTable
;
static
LiveBlockTable
*
gLiveBlockTable
=
nullptr
;
class
AggregatedLiveBlockHashPolicy
{
public
:
typedef
const
LiveBlock
*
const
Lookup
;
static
mozilla
:
:
HashNumber
hash
(
const
LiveBlock
*
const
&
aB
)
{
return
gOptions
-
>
IsDarkMatterMode
(
)
?
mozilla
:
:
HashGeneric
(
aB
-
>
ReqSize
(
)
aB
-
>
SlopSize
(
)
aB
-
>
AllocStackTrace
(
)
aB
-
>
ReportedOnAlloc1
(
)
aB
-
>
ReportedOnAlloc2
(
)
)
:
mozilla
:
:
HashGeneric
(
aB
-
>
ReqSize
(
)
aB
-
>
SlopSize
(
)
aB
-
>
AllocStackTrace
(
)
)
;
}
static
bool
match
(
const
LiveBlock
*
const
&
aA
const
LiveBlock
*
const
&
aB
)
{
return
gOptions
-
>
IsDarkMatterMode
(
)
?
aA
-
>
ReqSize
(
)
=
=
aB
-
>
ReqSize
(
)
&
&
aA
-
>
SlopSize
(
)
=
=
aB
-
>
SlopSize
(
)
&
&
aA
-
>
AllocStackTrace
(
)
=
=
aB
-
>
AllocStackTrace
(
)
&
&
aA
-
>
ReportStackTrace1
(
)
=
=
aB
-
>
ReportStackTrace1
(
)
&
&
aA
-
>
ReportStackTrace2
(
)
=
=
aB
-
>
ReportStackTrace2
(
)
:
aA
-
>
ReqSize
(
)
=
=
aB
-
>
ReqSize
(
)
&
&
aA
-
>
SlopSize
(
)
=
=
aB
-
>
SlopSize
(
)
&
&
aA
-
>
AllocStackTrace
(
)
=
=
aB
-
>
AllocStackTrace
(
)
;
}
}
;
typedef
mozilla
:
:
HashMap
<
const
LiveBlock
*
size_t
AggregatedLiveBlockHashPolicy
InfallibleAllocPolicy
>
AggregatedLiveBlockTable
;
class
DeadBlock
{
const
size_t
mReqSize
;
const
size_t
mSlopSize
;
const
StackTrace
*
const
mAllocStackTrace
;
public
:
DeadBlock
(
)
:
mReqSize
(
0
)
mSlopSize
(
0
)
mAllocStackTrace
(
nullptr
)
{
}
explicit
DeadBlock
(
const
LiveBlock
&
aLb
)
:
mReqSize
(
aLb
.
ReqSize
(
)
)
mSlopSize
(
aLb
.
SlopSize
(
)
)
mAllocStackTrace
(
aLb
.
AllocStackTrace
(
)
)
{
}
~
DeadBlock
(
)
{
}
size_t
ReqSize
(
)
const
{
return
mReqSize
;
}
size_t
SlopSize
(
)
const
{
return
mSlopSize
;
}
const
StackTrace
*
AllocStackTrace
(
)
const
{
return
mAllocStackTrace
;
}
void
AddStackTracesToTable
(
StackTraceSet
&
aStackTraces
)
const
{
if
(
AllocStackTrace
(
)
)
{
MOZ_ALWAYS_TRUE
(
aStackTraces
.
put
(
AllocStackTrace
(
)
)
)
;
}
}
typedef
DeadBlock
Lookup
;
static
mozilla
:
:
HashNumber
hash
(
const
DeadBlock
&
aB
)
{
return
mozilla
:
:
HashGeneric
(
aB
.
ReqSize
(
)
aB
.
SlopSize
(
)
aB
.
AllocStackTrace
(
)
)
;
}
static
bool
match
(
const
DeadBlock
&
aA
const
DeadBlock
&
aB
)
{
return
aA
.
ReqSize
(
)
=
=
aB
.
ReqSize
(
)
&
&
aA
.
SlopSize
(
)
=
=
aB
.
SlopSize
(
)
&
&
aA
.
AllocStackTrace
(
)
=
=
aB
.
AllocStackTrace
(
)
;
}
}
;
typedef
mozilla
:
:
HashMap
<
DeadBlock
size_t
DeadBlock
InfallibleAllocPolicy
>
DeadBlockTable
;
static
DeadBlockTable
*
gDeadBlockTable
=
nullptr
;
void
MaybeAddToDeadBlockTable
(
const
DeadBlock
&
aDb
)
{
if
(
gOptions
-
>
IsCumulativeMode
(
)
&
&
aDb
.
AllocStackTrace
(
)
)
{
AutoLockState
lock
;
if
(
DeadBlockTable
:
:
AddPtr
p
=
gDeadBlockTable
-
>
lookupForAdd
(
aDb
)
)
{
p
-
>
value
(
)
+
=
1
;
}
else
{
MOZ_ALWAYS_TRUE
(
gDeadBlockTable
-
>
add
(
p
aDb
1
)
)
;
}
}
}
static
void
GatherUsedStackTraces
(
StackTraceSet
&
aStackTraces
)
{
MOZ_ASSERT
(
gStateLock
-
>
IsLocked
(
)
)
;
MOZ_ASSERT
(
Thread
:
:
Fetch
(
)
-
>
InterceptsAreBlocked
(
)
)
;
aStackTraces
.
finish
(
)
;
MOZ_ALWAYS_TRUE
(
aStackTraces
.
init
(
512
)
)
;
for
(
auto
iter
=
gLiveBlockTable
-
>
iter
(
)
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
iter
.
get
(
)
.
AddStackTracesToTable
(
aStackTraces
)
;
}
for
(
auto
iter
=
gDeadBlockTable
-
>
iter
(
)
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
iter
.
get
(
)
.
key
(
)
.
AddStackTracesToTable
(
aStackTraces
)
;
}
}
static
void
GCStackTraces
(
)
{
MOZ_ASSERT
(
gStateLock
-
>
IsLocked
(
)
)
;
MOZ_ASSERT
(
Thread
:
:
Fetch
(
)
-
>
InterceptsAreBlocked
(
)
)
;
StackTraceSet
usedStackTraces
;
GatherUsedStackTraces
(
usedStackTraces
)
;
for
(
auto
iter
=
gStackTraceTable
-
>
modIter
(
)
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
StackTrace
*
const
&
st
=
iter
.
get
(
)
;
if
(
!
usedStackTraces
.
has
(
st
)
)
{
iter
.
remove
(
)
;
InfallibleAllocPolicy
:
:
delete_
(
st
)
;
}
}
gGCStackTraceTableWhenSizeExceeds
=
2
*
gStackTraceTable
-
>
count
(
)
;
}
static
FastBernoulliTrial
*
gBernoulli
;
static
void
ResetBernoulli
(
)
{
new
(
gBernoulli
)
FastBernoulliTrial
(
0
.
003
0x8e26eeee166bc8ca
0x56820f304a9c9ae0
)
;
}
static
void
AllocCallback
(
void
*
aPtr
size_t
aReqSize
Thread
*
aT
)
{
if
(
!
aPtr
)
{
return
;
}
AutoLockState
lock
;
AutoBlockIntercepts
block
(
aT
)
;
size_t
actualSize
=
gMallocTable
.
malloc_usable_size
(
aPtr
)
;
bool
getTrace
=
gOptions
-
>
DoFullStacks
(
)
|
|
gBernoulli
-
>
trial
(
actualSize
)
;
LiveBlock
b
(
aPtr
aReqSize
getTrace
?
StackTrace
:
:
Get
(
aT
)
:
nullptr
)
;
MOZ_ALWAYS_TRUE
(
gLiveBlockTable
-
>
putNew
(
aPtr
b
)
)
;
}
static
void
FreeCallback
(
void
*
aPtr
Thread
*
aT
DeadBlock
*
aDeadBlock
)
{
if
(
!
aPtr
)
{
return
;
}
AutoLockState
lock
;
AutoBlockIntercepts
block
(
aT
)
;
if
(
LiveBlockTable
:
:
Ptr
lb
=
gLiveBlockTable
-
>
lookup
(
aPtr
)
)
{
if
(
gOptions
-
>
IsCumulativeMode
(
)
)
{
new
(
aDeadBlock
)
DeadBlock
(
*
lb
)
;
}
gLiveBlockTable
-
>
remove
(
lb
)
;
}
else
{
}
if
(
gStackTraceTable
-
>
count
(
)
>
gGCStackTraceTableWhenSizeExceeds
)
{
GCStackTraces
(
)
;
}
}
static
bool
Init
(
malloc_table_t
*
aMallocTable
)
;
}
}
static
void
*
replace_malloc
(
size_t
aSize
)
{
using
namespace
mozilla
:
:
dmd
;
Thread
*
t
=
Thread
:
:
Fetch
(
)
;
if
(
t
-
>
InterceptsAreBlocked
(
)
)
{
return
InfallibleAllocPolicy
:
:
malloc_
(
aSize
)
;
}
void
*
ptr
=
gMallocTable
.
malloc
(
aSize
)
;
AllocCallback
(
ptr
aSize
t
)
;
return
ptr
;
}
static
void
*
replace_calloc
(
size_t
aCount
size_t
aSize
)
{
using
namespace
mozilla
:
:
dmd
;
Thread
*
t
=
Thread
:
:
Fetch
(
)
;
if
(
t
-
>
InterceptsAreBlocked
(
)
)
{
return
InfallibleAllocPolicy
:
:
calloc_
(
aCount
*
aSize
)
;
}
void
*
ptr
=
gMallocTable
.
calloc
(
aCount
aSize
)
;
AllocCallback
(
ptr
aCount
*
aSize
t
)
;
return
ptr
;
}
static
void
*
replace_realloc
(
void
*
aOldPtr
size_t
aSize
)
{
using
namespace
mozilla
:
:
dmd
;
Thread
*
t
=
Thread
:
:
Fetch
(
)
;
if
(
t
-
>
InterceptsAreBlocked
(
)
)
{
return
InfallibleAllocPolicy
:
:
realloc_
(
aOldPtr
aSize
)
;
}
if
(
!
aOldPtr
)
{
return
replace_malloc
(
aSize
)
;
}
DeadBlock
db
;
FreeCallback
(
aOldPtr
t
&
db
)
;
void
*
ptr
=
gMallocTable
.
realloc
(
aOldPtr
aSize
)
;
if
(
ptr
)
{
AllocCallback
(
ptr
aSize
t
)
;
MaybeAddToDeadBlockTable
(
db
)
;
}
else
{
AllocCallback
(
aOldPtr
gMallocTable
.
malloc_usable_size
(
aOldPtr
)
t
)
;
}
return
ptr
;
}
static
void
*
replace_memalign
(
size_t
aAlignment
size_t
aSize
)
{
using
namespace
mozilla
:
:
dmd
;
Thread
*
t
=
Thread
:
:
Fetch
(
)
;
if
(
t
-
>
InterceptsAreBlocked
(
)
)
{
return
InfallibleAllocPolicy
:
:
memalign_
(
aAlignment
aSize
)
;
}
void
*
ptr
=
gMallocTable
.
memalign
(
aAlignment
aSize
)
;
AllocCallback
(
ptr
aSize
t
)
;
return
ptr
;
}
static
void
replace_free
(
void
*
aPtr
)
{
using
namespace
mozilla
:
:
dmd
;
Thread
*
t
=
Thread
:
:
Fetch
(
)
;
if
(
t
-
>
InterceptsAreBlocked
(
)
)
{
return
InfallibleAllocPolicy
:
:
free_
(
aPtr
)
;
}
DeadBlock
db
;
FreeCallback
(
aPtr
t
&
db
)
;
MaybeAddToDeadBlockTable
(
db
)
;
gMallocTable
.
free
(
aPtr
)
;
}
void
replace_init
(
malloc_table_t
*
aMallocTable
ReplaceMallocBridge
*
*
aBridge
)
{
if
(
mozilla
:
:
dmd
:
:
Init
(
aMallocTable
)
)
{
#
define
MALLOC_FUNCS
MALLOC_FUNCS_MALLOC_BASE
#
define
MALLOC_DECL
(
name
.
.
.
)
aMallocTable
-
>
name
=
replace_
#
#
name
;
#
include
"
malloc_decls
.
h
"
*
aBridge
=
mozilla
:
:
dmd
:
:
gDMDBridge
;
}
}
namespace
mozilla
{
namespace
dmd
{
const
char
*
Options
:
:
ValueIfMatch
(
const
char
*
aArg
const
char
*
aOptionName
)
{
MOZ_ASSERT
(
!
isspace
(
*
aArg
)
)
;
size_t
optionLen
=
strlen
(
aOptionName
)
;
if
(
strncmp
(
aArg
aOptionName
optionLen
)
=
=
0
&
&
aArg
[
optionLen
]
=
=
'
=
'
&
&
aArg
[
optionLen
+
1
]
)
{
return
aArg
+
optionLen
+
1
;
}
return
nullptr
;
}
bool
Options
:
:
GetLong
(
const
char
*
aArg
const
char
*
aOptionName
long
aMin
long
aMax
long
*
aValue
)
{
if
(
const
char
*
optionValue
=
ValueIfMatch
(
aArg
aOptionName
)
)
{
char
*
endPtr
;
*
aValue
=
strtol
(
optionValue
&
endPtr
10
)
;
if
(
!
*
endPtr
&
&
aMin
<
=
*
aValue
&
&
*
aValue
<
=
aMax
&
&
*
aValue
!
=
LONG_MIN
&
&
*
aValue
!
=
LONG_MAX
)
{
return
true
;
}
}
return
false
;
}
bool
Options
:
:
GetBool
(
const
char
*
aArg
const
char
*
aOptionName
bool
*
aValue
)
{
if
(
const
char
*
optionValue
=
ValueIfMatch
(
aArg
aOptionName
)
)
{
if
(
strcmp
(
optionValue
"
yes
"
)
=
=
0
)
{
*
aValue
=
true
;
return
true
;
}
if
(
strcmp
(
optionValue
"
no
"
)
=
=
0
)
{
*
aValue
=
false
;
return
true
;
}
}
return
false
;
}
Options
:
:
Options
(
const
char
*
aDMDEnvVar
)
:
mDMDEnvVar
(
aDMDEnvVar
?
InfallibleAllocPolicy
:
:
strdup_
(
aDMDEnvVar
)
:
nullptr
)
mMode
(
Mode
:
:
DarkMatter
)
mStacks
(
Stacks
:
:
Partial
)
mShowDumpStats
(
false
)
{
char
*
e
=
mDMDEnvVar
;
if
(
e
&
&
strcmp
(
e
"
1
"
)
!
=
0
)
{
bool
isEnd
=
false
;
while
(
!
isEnd
)
{
while
(
isspace
(
*
e
)
)
{
e
+
+
;
}
const
char
*
arg
=
e
;
while
(
!
isspace
(
*
e
)
&
&
*
e
!
=
'
\
0
'
)
{
e
+
+
;
}
char
replacedChar
=
*
e
;
isEnd
=
replacedChar
=
=
'
\
0
'
;
*
e
=
'
\
0
'
;
bool
myBool
;
if
(
strcmp
(
arg
"
-
-
mode
=
live
"
)
=
=
0
)
{
mMode
=
Mode
:
:
Live
;
}
else
if
(
strcmp
(
arg
"
-
-
mode
=
dark
-
matter
"
)
=
=
0
)
{
mMode
=
Mode
:
:
DarkMatter
;
}
else
if
(
strcmp
(
arg
"
-
-
mode
=
cumulative
"
)
=
=
0
)
{
mMode
=
Mode
:
:
Cumulative
;
}
else
if
(
strcmp
(
arg
"
-
-
mode
=
scan
"
)
=
=
0
)
{
mMode
=
Mode
:
:
Scan
;
}
else
if
(
strcmp
(
arg
"
-
-
stacks
=
full
"
)
=
=
0
)
{
mStacks
=
Stacks
:
:
Full
;
}
else
if
(
strcmp
(
arg
"
-
-
stacks
=
partial
"
)
=
=
0
)
{
mStacks
=
Stacks
:
:
Partial
;
}
else
if
(
GetBool
(
arg
"
-
-
show
-
dump
-
stats
"
&
myBool
)
)
{
mShowDumpStats
=
myBool
;
}
else
if
(
strcmp
(
arg
"
"
)
=
=
0
)
{
MOZ_ASSERT
(
isEnd
)
;
}
else
{
BadArg
(
arg
)
;
}
*
e
=
replacedChar
;
}
}
if
(
mMode
=
=
Mode
:
:
Scan
)
{
mStacks
=
Stacks
:
:
Full
;
}
}
void
Options
:
:
BadArg
(
const
char
*
aArg
)
{
StatusMsg
(
"
\
n
"
)
;
StatusMsg
(
"
Bad
entry
in
the
DMD
environment
variable
:
'
%
s
'
.
\
n
"
aArg
)
;
StatusMsg
(
"
See
the
output
of
|
mach
help
run
|
for
the
allowed
options
.
\
n
"
)
;
exit
(
1
)
;
}
const
char
*
Options
:
:
ModeString
(
)
const
{
switch
(
mMode
)
{
case
Mode
:
:
Live
:
return
"
live
"
;
case
Mode
:
:
DarkMatter
:
return
"
dark
-
matter
"
;
case
Mode
:
:
Cumulative
:
return
"
cumulative
"
;
case
Mode
:
:
Scan
:
return
"
scan
"
;
default
:
MOZ_ASSERT
(
false
)
;
return
"
(
unknown
DMD
mode
)
"
;
}
}
static
void
prefork
(
)
{
if
(
gStateLock
)
{
gStateLock
-
>
Lock
(
)
;
}
}
static
void
postfork
(
)
{
if
(
gStateLock
)
{
gStateLock
-
>
Unlock
(
)
;
}
}
static
bool
Init
(
malloc_table_t
*
aMallocTable
)
{
const
char
*
e
=
getenv
(
"
DMD
"
)
;
if
(
!
e
)
{
return
false
;
}
gMallocTable
=
*
aMallocTable
;
StatusMsg
(
"
DMD
=
'
%
s
'
\
n
"
e
)
;
gDMDBridge
=
InfallibleAllocPolicy
:
:
new_
<
DMDBridge
>
(
)
;
#
ifndef
XP_WIN
pthread_atfork
(
prefork
postfork
postfork
)
;
#
endif
gOptions
=
InfallibleAllocPolicy
:
:
new_
<
Options
>
(
e
)
;
gStateLock
=
InfallibleAllocPolicy
:
:
new_
<
Mutex
>
(
)
;
gBernoulli
=
(
FastBernoulliTrial
*
)
InfallibleAllocPolicy
:
:
malloc_
(
sizeof
(
FastBernoulliTrial
)
)
;
ResetBernoulli
(
)
;
DMD_CREATE_TLS_INDEX
(
gTlsIndex
)
;
{
AutoLockState
lock
;
gStackTraceTable
=
InfallibleAllocPolicy
:
:
new_
<
StackTraceTable
>
(
)
;
MOZ_ALWAYS_TRUE
(
gStackTraceTable
-
>
init
(
8192
)
)
;
gLiveBlockTable
=
InfallibleAllocPolicy
:
:
new_
<
LiveBlockTable
>
(
)
;
MOZ_ALWAYS_TRUE
(
gLiveBlockTable
-
>
init
(
8192
)
)
;
gDeadBlockTable
=
InfallibleAllocPolicy
:
:
new_
<
DeadBlockTable
>
(
)
;
size_t
tableSize
=
gOptions
-
>
IsCumulativeMode
(
)
?
8192
:
4
;
MOZ_ALWAYS_TRUE
(
gDeadBlockTable
-
>
init
(
tableSize
)
)
;
}
return
true
;
}
static
void
ReportHelper
(
const
void
*
aPtr
bool
aReportedOnAlloc
)
{
if
(
!
gOptions
-
>
IsDarkMatterMode
(
)
|
|
!
aPtr
)
{
return
;
}
Thread
*
t
=
Thread
:
:
Fetch
(
)
;
AutoBlockIntercepts
block
(
t
)
;
AutoLockState
lock
;
if
(
LiveBlockTable
:
:
Ptr
p
=
gLiveBlockTable
-
>
lookup
(
aPtr
)
)
{
p
-
>
Report
(
t
aReportedOnAlloc
)
;
}
else
{
StatusMsg
(
"
Unknown
pointer
%
p
\
n
"
aPtr
)
;
}
}
void
DMDFuncs
:
:
Report
(
const
void
*
aPtr
)
{
ReportHelper
(
aPtr
false
)
;
}
void
DMDFuncs
:
:
ReportOnAlloc
(
const
void
*
aPtr
)
{
ReportHelper
(
aPtr
true
)
;
}
static
const
int
kOutputVersionNumber
=
5
;
static
void
SizeOfInternal
(
Sizes
*
aSizes
)
{
MOZ_ASSERT
(
gStateLock
-
>
IsLocked
(
)
)
;
MOZ_ASSERT
(
Thread
:
:
Fetch
(
)
-
>
InterceptsAreBlocked
(
)
)
;
aSizes
-
>
Clear
(
)
;
StackTraceSet
usedStackTraces
;
GatherUsedStackTraces
(
usedStackTraces
)
;
for
(
auto
iter
=
gStackTraceTable
-
>
iter
(
)
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
StackTrace
*
const
&
st
=
iter
.
get
(
)
;
if
(
usedStackTraces
.
has
(
st
)
)
{
aSizes
-
>
mStackTracesUsed
+
=
MallocSizeOf
(
st
)
;
}
else
{
aSizes
-
>
mStackTracesUnused
+
=
MallocSizeOf
(
st
)
;
}
}
aSizes
-
>
mStackTraceTable
=
gStackTraceTable
-
>
shallowSizeOfIncludingThis
(
MallocSizeOf
)
;
aSizes
-
>
mLiveBlockTable
=
gLiveBlockTable
-
>
shallowSizeOfIncludingThis
(
MallocSizeOf
)
;
aSizes
-
>
mDeadBlockTable
=
gDeadBlockTable
-
>
shallowSizeOfIncludingThis
(
MallocSizeOf
)
;
}
void
DMDFuncs
:
:
SizeOf
(
Sizes
*
aSizes
)
{
aSizes
-
>
Clear
(
)
;
AutoBlockIntercepts
block
(
Thread
:
:
Fetch
(
)
)
;
AutoLockState
lock
;
SizeOfInternal
(
aSizes
)
;
}
void
DMDFuncs
:
:
ClearReports
(
)
{
if
(
!
gOptions
-
>
IsDarkMatterMode
(
)
)
{
return
;
}
AutoLockState
lock
;
for
(
auto
iter
=
gLiveBlockTable
-
>
iter
(
)
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
iter
.
get
(
)
.
UnreportIfNotReportedOnAlloc
(
)
;
}
}
class
ToIdStringConverter
final
{
public
:
ToIdStringConverter
(
)
:
mNextId
(
0
)
{
MOZ_ALWAYS_TRUE
(
mIdMap
.
init
(
512
)
)
;
}
const
char
*
ToIdString
(
const
void
*
aPtr
)
{
uint32_t
id
;
PointerIdMap
:
:
AddPtr
p
=
mIdMap
.
lookupForAdd
(
aPtr
)
;
if
(
!
p
)
{
id
=
mNextId
+
+
;
MOZ_ALWAYS_TRUE
(
mIdMap
.
add
(
p
aPtr
id
)
)
;
}
else
{
id
=
p
-
>
value
(
)
;
}
return
Base32
(
id
)
;
}
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
return
mIdMap
.
shallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
}
private
:
char
*
Base32
(
uint32_t
aN
)
{
static
const
char
digits
[
]
=
"
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef
"
;
char
*
b
=
mIdBuf
+
kIdBufLen
-
1
;
*
b
=
'
\
0
'
;
do
{
b
-
-
;
if
(
b
=
=
mIdBuf
)
{
MOZ_CRASH
(
"
Base32
buffer
too
small
"
)
;
}
*
b
=
digits
[
aN
%
32
]
;
aN
/
=
32
;
}
while
(
aN
)
;
return
b
;
}
PointerIdMap
mIdMap
;
uint32_t
mNextId
;
static
const
size_t
kIdBufLen
=
16
;
char
mIdBuf
[
kIdBufLen
]
;
}
;
class
ToStringConverter
{
public
:
const
char
*
ToPtrString
(
const
void
*
aPtr
)
{
snprintf
(
kPtrBuf
sizeof
(
kPtrBuf
)
-
1
"
%
"
PRIxPTR
(
uintptr_t
)
aPtr
)
;
return
kPtrBuf
;
}
private
:
char
kPtrBuf
[
32
]
;
}
;
static
void
WriteBlockContents
(
JSONWriter
&
aWriter
const
LiveBlock
&
aBlock
)
{
size_t
numWords
=
aBlock
.
ReqSize
(
)
/
sizeof
(
uintptr_t
*
)
;
if
(
numWords
=
=
0
)
{
return
;
}
aWriter
.
StartArrayProperty
(
"
contents
"
aWriter
.
SingleLineStyle
)
;
{
const
uintptr_t
*
*
block
=
(
const
uintptr_t
*
*
)
aBlock
.
Address
(
)
;
ToStringConverter
sc
;
for
(
size_t
i
=
0
;
i
<
numWords
;
+
+
i
)
{
aWriter
.
StringElement
(
sc
.
ToPtrString
(
block
[
i
]
)
)
;
}
}
aWriter
.
EndArray
(
)
;
}
static
void
AnalyzeImpl
(
UniquePtr
<
JSONWriteFunc
>
aWriter
)
{
JSONWriter
writer
(
std
:
:
move
(
aWriter
)
)
;
AutoBlockIntercepts
block
(
Thread
:
:
Fetch
(
)
)
;
AutoLockState
lock
;
auto
locService
=
InfallibleAllocPolicy
:
:
new_
<
CodeAddressService
>
(
)
;
StackTraceSet
usedStackTraces
;
MOZ_ALWAYS_TRUE
(
usedStackTraces
.
init
(
512
)
)
;
PointerSet
usedPcs
;
MOZ_ALWAYS_TRUE
(
usedPcs
.
init
(
512
)
)
;
size_t
iscSize
;
static
int
analysisCount
=
1
;
StatusMsg
(
"
Dump
%
d
{
\
n
"
analysisCount
+
+
)
;
writer
.
Start
(
)
;
{
writer
.
IntProperty
(
"
version
"
kOutputVersionNumber
)
;
writer
.
StartObjectProperty
(
"
invocation
"
)
;
{
const
char
*
var
=
gOptions
-
>
DMDEnvVar
(
)
;
if
(
var
)
{
writer
.
StringProperty
(
"
dmdEnvVar
"
var
)
;
}
else
{
writer
.
NullProperty
(
"
dmdEnvVar
"
)
;
}
writer
.
StringProperty
(
"
mode
"
gOptions
-
>
ModeString
(
)
)
;
}
writer
.
EndObject
(
)
;
StatusMsg
(
"
Constructing
the
heap
block
list
.
.
.
\
n
"
)
;
ToIdStringConverter
isc
;
ToStringConverter
sc
;
writer
.
StartArrayProperty
(
"
blockList
"
)
;
{
auto
writeLiveBlock
=
[
&
]
(
const
LiveBlock
&
aB
size_t
aNum
)
{
aB
.
AddStackTracesToTable
(
usedStackTraces
)
;
MOZ_ASSERT_IF
(
gOptions
-
>
IsScanMode
(
)
aNum
=
=
1
)
;
writer
.
StartObjectElement
(
writer
.
SingleLineStyle
)
;
{
if
(
gOptions
-
>
IsScanMode
(
)
)
{
writer
.
StringProperty
(
"
addr
"
sc
.
ToPtrString
(
aB
.
Address
(
)
)
)
;
WriteBlockContents
(
writer
aB
)
;
}
writer
.
IntProperty
(
"
req
"
aB
.
ReqSize
(
)
)
;
if
(
aB
.
SlopSize
(
)
>
0
)
{
writer
.
IntProperty
(
"
slop
"
aB
.
SlopSize
(
)
)
;
}
if
(
aB
.
AllocStackTrace
(
)
)
{
writer
.
StringProperty
(
"
alloc
"
isc
.
ToIdString
(
aB
.
AllocStackTrace
(
)
)
)
;
}
if
(
gOptions
-
>
IsDarkMatterMode
(
)
&
&
aB
.
NumReports
(
)
>
0
)
{
writer
.
StartArrayProperty
(
"
reps
"
)
;
{
if
(
aB
.
ReportStackTrace1
(
)
)
{
writer
.
StringElement
(
isc
.
ToIdString
(
aB
.
ReportStackTrace1
(
)
)
)
;
}
if
(
aB
.
ReportStackTrace2
(
)
)
{
writer
.
StringElement
(
isc
.
ToIdString
(
aB
.
ReportStackTrace2
(
)
)
)
;
}
}
writer
.
EndArray
(
)
;
}
if
(
aNum
>
1
)
{
writer
.
IntProperty
(
"
num
"
aNum
)
;
}
}
writer
.
EndObject
(
)
;
}
;
if
(
!
gOptions
-
>
IsScanMode
(
)
)
{
AggregatedLiveBlockTable
agg
;
MOZ_ALWAYS_TRUE
(
agg
.
init
(
8192
)
)
;
for
(
auto
iter
=
gLiveBlockTable
-
>
iter
(
)
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
const
LiveBlock
&
b
=
iter
.
get
(
)
;
b
.
AddStackTracesToTable
(
usedStackTraces
)
;
if
(
AggregatedLiveBlockTable
:
:
AddPtr
p
=
agg
.
lookupForAdd
(
&
b
)
)
{
p
-
>
value
(
)
+
=
1
;
}
else
{
MOZ_ALWAYS_TRUE
(
agg
.
add
(
p
&
b
1
)
)
;
}
}
for
(
auto
iter
=
agg
.
iter
(
)
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
const
LiveBlock
&
b
=
*
iter
.
get
(
)
.
key
(
)
;
size_t
num
=
iter
.
get
(
)
.
value
(
)
;
writeLiveBlock
(
b
num
)
;
}
}
else
{
for
(
auto
iter
=
gLiveBlockTable
-
>
iter
(
)
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
const
LiveBlock
&
b
=
iter
.
get
(
)
;
b
.
AddStackTracesToTable
(
usedStackTraces
)
;
writeLiveBlock
(
b
1
)
;
}
}
for
(
auto
iter
=
gDeadBlockTable
-
>
iter
(
)
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
const
DeadBlock
&
b
=
iter
.
get
(
)
.
key
(
)
;
b
.
AddStackTracesToTable
(
usedStackTraces
)
;
size_t
num
=
iter
.
get
(
)
.
value
(
)
;
MOZ_ASSERT
(
num
>
0
)
;
writer
.
StartObjectElement
(
writer
.
SingleLineStyle
)
;
{
writer
.
IntProperty
(
"
req
"
b
.
ReqSize
(
)
)
;
if
(
b
.
SlopSize
(
)
>
0
)
{
writer
.
IntProperty
(
"
slop
"
b
.
SlopSize
(
)
)
;
}
if
(
b
.
AllocStackTrace
(
)
)
{
writer
.
StringProperty
(
"
alloc
"
isc
.
ToIdString
(
b
.
AllocStackTrace
(
)
)
)
;
}
if
(
num
>
1
)
{
writer
.
IntProperty
(
"
num
"
num
)
;
}
}
writer
.
EndObject
(
)
;
}
}
writer
.
EndArray
(
)
;
StatusMsg
(
"
Constructing
the
stack
trace
table
.
.
.
\
n
"
)
;
writer
.
StartObjectProperty
(
"
traceTable
"
)
;
{
for
(
auto
iter
=
usedStackTraces
.
iter
(
)
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
const
StackTrace
*
const
st
=
iter
.
get
(
)
;
writer
.
StartArrayProperty
(
isc
.
ToIdString
(
st
)
writer
.
SingleLineStyle
)
;
{
for
(
uint32_t
i
=
0
;
i
<
st
-
>
Length
(
)
;
i
+
+
)
{
const
void
*
pc
=
st
-
>
Pc
(
i
)
;
writer
.
StringElement
(
isc
.
ToIdString
(
pc
)
)
;
MOZ_ALWAYS_TRUE
(
usedPcs
.
put
(
pc
)
)
;
}
}
writer
.
EndArray
(
)
;
}
}
writer
.
EndObject
(
)
;
StatusMsg
(
"
Constructing
the
stack
frame
table
.
.
.
\
n
"
)
;
writer
.
StartObjectProperty
(
"
frameTable
"
)
;
{
static
const
size_t
locBufLen
=
1024
;
char
locBuf
[
locBufLen
]
;
for
(
auto
iter
=
usedPcs
.
iter
(
)
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
const
void
*
const
pc
=
iter
.
get
(
)
;
locService
-
>
GetLocation
(
0
pc
locBuf
locBufLen
)
;
writer
.
StringProperty
(
isc
.
ToIdString
(
pc
)
locBuf
)
;
}
}
writer
.
EndObject
(
)
;
iscSize
=
isc
.
sizeOfExcludingThis
(
MallocSizeOf
)
;
}
writer
.
End
(
)
;
if
(
gOptions
-
>
ShowDumpStats
(
)
)
{
Sizes
sizes
;
SizeOfInternal
(
&
sizes
)
;
static
const
size_t
kBufLen
=
64
;
char
buf1
[
kBufLen
]
;
char
buf2
[
kBufLen
]
;
char
buf3
[
kBufLen
]
;
StatusMsg
(
"
Execution
measurements
{
\
n
"
)
;
StatusMsg
(
"
Data
structures
that
persist
after
Dump
(
)
ends
{
\
n
"
)
;
StatusMsg
(
"
Used
stack
traces
:
%
10s
bytes
\
n
"
Show
(
sizes
.
mStackTracesUsed
buf1
kBufLen
)
)
;
StatusMsg
(
"
Unused
stack
traces
:
%
10s
bytes
\
n
"
Show
(
sizes
.
mStackTracesUnused
buf1
kBufLen
)
)
;
StatusMsg
(
"
Stack
trace
table
:
%
10s
bytes
(
%
s
entries
%
s
used
)
\
n
"
Show
(
sizes
.
mStackTraceTable
buf1
kBufLen
)
Show
(
gStackTraceTable
-
>
capacity
(
)
buf2
kBufLen
)
Show
(
gStackTraceTable
-
>
count
(
)
buf3
kBufLen
)
)
;
StatusMsg
(
"
Live
block
table
:
%
10s
bytes
(
%
s
entries
%
s
used
)
\
n
"
Show
(
sizes
.
mLiveBlockTable
buf1
kBufLen
)
Show
(
gLiveBlockTable
-
>
capacity
(
)
buf2
kBufLen
)
Show
(
gLiveBlockTable
-
>
count
(
)
buf3
kBufLen
)
)
;
StatusMsg
(
"
Dead
block
table
:
%
10s
bytes
(
%
s
entries
%
s
used
)
\
n
"
Show
(
sizes
.
mDeadBlockTable
buf1
kBufLen
)
Show
(
gDeadBlockTable
-
>
capacity
(
)
buf2
kBufLen
)
Show
(
gDeadBlockTable
-
>
count
(
)
buf3
kBufLen
)
)
;
StatusMsg
(
"
}
\
n
"
)
;
StatusMsg
(
"
Data
structures
that
are
destroyed
after
Dump
(
)
ends
{
\
n
"
)
;
StatusMsg
(
"
Location
service
:
%
10s
bytes
\
n
"
Show
(
locService
-
>
SizeOfIncludingThis
(
MallocSizeOf
)
buf1
kBufLen
)
)
;
StatusMsg
(
"
Used
stack
traces
set
:
%
10s
bytes
\
n
"
Show
(
usedStackTraces
.
shallowSizeOfExcludingThis
(
MallocSizeOf
)
buf1
kBufLen
)
)
;
StatusMsg
(
"
Used
PCs
set
:
%
10s
bytes
\
n
"
Show
(
usedPcs
.
shallowSizeOfExcludingThis
(
MallocSizeOf
)
buf1
kBufLen
)
)
;
StatusMsg
(
"
Pointer
ID
map
:
%
10s
bytes
\
n
"
Show
(
iscSize
buf1
kBufLen
)
)
;
StatusMsg
(
"
}
\
n
"
)
;
StatusMsg
(
"
Counts
{
\
n
"
)
;
size_t
hits
=
locService
-
>
NumCacheHits
(
)
;
size_t
misses
=
locService
-
>
NumCacheMisses
(
)
;
size_t
requests
=
hits
+
misses
;
StatusMsg
(
"
Location
service
:
%
10s
requests
\
n
"
Show
(
requests
buf1
kBufLen
)
)
;
size_t
count
=
locService
-
>
CacheCount
(
)
;
size_t
capacity
=
locService
-
>
CacheCapacity
(
)
;
StatusMsg
(
"
Location
service
cache
:
"
"
%
4
.
1f
%
%
hit
rate
%
.
1f
%
%
occupancy
at
end
\
n
"
Percent
(
hits
requests
)
Percent
(
count
capacity
)
)
;
StatusMsg
(
"
}
\
n
"
)
;
StatusMsg
(
"
}
\
n
"
)
;
}
InfallibleAllocPolicy
:
:
delete_
(
locService
)
;
StatusMsg
(
"
}
\
n
"
)
;
}
void
DMDFuncs
:
:
Analyze
(
UniquePtr
<
JSONWriteFunc
>
aWriter
)
{
AnalyzeImpl
(
std
:
:
move
(
aWriter
)
)
;
ClearReports
(
)
;
}
void
DMDFuncs
:
:
ResetEverything
(
const
char
*
aOptions
)
{
AutoLockState
lock
;
InfallibleAllocPolicy
:
:
delete_
(
gOptions
)
;
gOptions
=
InfallibleAllocPolicy
:
:
new_
<
Options
>
(
aOptions
)
;
gLiveBlockTable
-
>
clear
(
)
;
gDeadBlockTable
-
>
clear
(
)
;
ResetBernoulli
(
)
;
}
}
}
