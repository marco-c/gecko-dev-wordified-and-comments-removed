#
include
"
jemalloc
/
internal
/
jemalloc_internal
.
h
"
#
ifndef
JEMALLOC_ZONE
#
error
"
This
source
file
is
for
zones
on
Darwin
(
OS
X
)
.
"
#
endif
extern
malloc_zone_t
*
malloc_default_purgeable_zone
(
void
)
JEMALLOC_ATTR
(
weak_import
)
;
static
malloc_zone_t
*
default_zone
*
purgeable_zone
;
static
malloc_zone_t
jemalloc_zone
;
static
struct
malloc_introspection_t
jemalloc_zone_introspect
;
static
size_t
zone_size
(
malloc_zone_t
*
zone
void
*
ptr
)
;
static
void
*
zone_malloc
(
malloc_zone_t
*
zone
size_t
size
)
;
static
void
*
zone_calloc
(
malloc_zone_t
*
zone
size_t
num
size_t
size
)
;
static
void
*
zone_valloc
(
malloc_zone_t
*
zone
size_t
size
)
;
static
void
zone_free
(
malloc_zone_t
*
zone
void
*
ptr
)
;
static
void
*
zone_realloc
(
malloc_zone_t
*
zone
void
*
ptr
size_t
size
)
;
#
if
(
JEMALLOC_ZONE_VERSION
>
=
5
)
static
void
*
zone_memalign
(
malloc_zone_t
*
zone
size_t
alignment
#
endif
#
if
(
JEMALLOC_ZONE_VERSION
>
=
6
)
size_t
size
)
;
static
void
zone_free_definite_size
(
malloc_zone_t
*
zone
void
*
ptr
size_t
size
)
;
#
endif
static
void
*
zone_destroy
(
malloc_zone_t
*
zone
)
;
static
size_t
zone_good_size
(
malloc_zone_t
*
zone
size_t
size
)
;
static
void
zone_force_lock
(
malloc_zone_t
*
zone
)
;
static
void
zone_force_unlock
(
malloc_zone_t
*
zone
)
;
static
size_t
zone_size
(
malloc_zone_t
*
zone
void
*
ptr
)
{
return
(
ivsalloc
(
tsdn_fetch
(
)
ptr
config_prof
)
)
;
}
static
void
*
zone_malloc
(
malloc_zone_t
*
zone
size_t
size
)
{
return
(
je_malloc
(
size
)
)
;
}
static
void
*
zone_calloc
(
malloc_zone_t
*
zone
size_t
num
size_t
size
)
{
return
(
je_calloc
(
num
size
)
)
;
}
static
void
*
zone_valloc
(
malloc_zone_t
*
zone
size_t
size
)
{
void
*
ret
=
NULL
;
je_posix_memalign
(
&
ret
PAGE
size
)
;
return
(
ret
)
;
}
static
void
zone_free
(
malloc_zone_t
*
zone
void
*
ptr
)
{
if
(
ivsalloc
(
tsdn_fetch
(
)
ptr
config_prof
)
!
=
0
)
{
je_free
(
ptr
)
;
return
;
}
free
(
ptr
)
;
}
static
void
*
zone_realloc
(
malloc_zone_t
*
zone
void
*
ptr
size_t
size
)
{
if
(
ivsalloc
(
tsdn_fetch
(
)
ptr
config_prof
)
!
=
0
)
return
(
je_realloc
(
ptr
size
)
)
;
return
(
realloc
(
ptr
size
)
)
;
}
#
if
(
JEMALLOC_ZONE_VERSION
>
=
5
)
static
void
*
zone_memalign
(
malloc_zone_t
*
zone
size_t
alignment
size_t
size
)
{
void
*
ret
=
NULL
;
je_posix_memalign
(
&
ret
alignment
size
)
;
return
(
ret
)
;
}
#
endif
#
if
(
JEMALLOC_ZONE_VERSION
>
=
6
)
static
void
zone_free_definite_size
(
malloc_zone_t
*
zone
void
*
ptr
size_t
size
)
{
size_t
alloc_size
;
alloc_size
=
ivsalloc
(
tsdn_fetch
(
)
ptr
config_prof
)
;
if
(
alloc_size
!
=
0
)
{
assert
(
alloc_size
=
=
size
)
;
je_free
(
ptr
)
;
return
;
}
free
(
ptr
)
;
}
#
endif
static
void
*
zone_destroy
(
malloc_zone_t
*
zone
)
{
not_reached
(
)
;
return
(
NULL
)
;
}
static
size_t
zone_good_size
(
malloc_zone_t
*
zone
size_t
size
)
{
if
(
size
=
=
0
)
size
=
1
;
return
(
s2u
(
size
)
)
;
}
static
void
zone_force_lock
(
malloc_zone_t
*
zone
)
{
if
(
isthreaded
)
jemalloc_prefork
(
)
;
}
static
void
zone_force_unlock
(
malloc_zone_t
*
zone
)
{
if
(
isthreaded
)
jemalloc_postfork_child
(
)
;
}
static
void
zone_init
(
void
)
{
jemalloc_zone
.
size
=
(
void
*
)
zone_size
;
jemalloc_zone
.
malloc
=
(
void
*
)
zone_malloc
;
jemalloc_zone
.
calloc
=
(
void
*
)
zone_calloc
;
jemalloc_zone
.
valloc
=
(
void
*
)
zone_valloc
;
jemalloc_zone
.
free
=
(
void
*
)
zone_free
;
jemalloc_zone
.
realloc
=
(
void
*
)
zone_realloc
;
jemalloc_zone
.
destroy
=
(
void
*
)
zone_destroy
;
jemalloc_zone
.
zone_name
=
"
jemalloc_zone
"
;
jemalloc_zone
.
batch_malloc
=
NULL
;
jemalloc_zone
.
batch_free
=
NULL
;
jemalloc_zone
.
introspect
=
&
jemalloc_zone_introspect
;
jemalloc_zone
.
version
=
JEMALLOC_ZONE_VERSION
;
#
if
(
JEMALLOC_ZONE_VERSION
>
=
5
)
jemalloc_zone
.
memalign
=
zone_memalign
;
#
endif
#
if
(
JEMALLOC_ZONE_VERSION
>
=
6
)
jemalloc_zone
.
free_definite_size
=
zone_free_definite_size
;
#
endif
#
if
(
JEMALLOC_ZONE_VERSION
>
=
8
)
jemalloc_zone
.
pressure_relief
=
NULL
;
#
endif
jemalloc_zone_introspect
.
enumerator
=
NULL
;
jemalloc_zone_introspect
.
good_size
=
(
void
*
)
zone_good_size
;
jemalloc_zone_introspect
.
check
=
NULL
;
jemalloc_zone_introspect
.
print
=
NULL
;
jemalloc_zone_introspect
.
log
=
NULL
;
jemalloc_zone_introspect
.
force_lock
=
(
void
*
)
zone_force_lock
;
jemalloc_zone_introspect
.
force_unlock
=
(
void
*
)
zone_force_unlock
;
jemalloc_zone_introspect
.
statistics
=
NULL
;
#
if
(
JEMALLOC_ZONE_VERSION
>
=
6
)
jemalloc_zone_introspect
.
zone_locked
=
NULL
;
#
endif
#
if
(
JEMALLOC_ZONE_VERSION
>
=
7
)
jemalloc_zone_introspect
.
enable_discharge_checking
=
NULL
;
jemalloc_zone_introspect
.
disable_discharge_checking
=
NULL
;
jemalloc_zone_introspect
.
discharge
=
NULL
;
#
ifdef
__BLOCKS__
jemalloc_zone_introspect
.
enumerate_discharged_pointers
=
NULL
;
#
else
jemalloc_zone_introspect
.
enumerate_unavailable_without_blocks
=
NULL
;
#
endif
#
endif
}
static
malloc_zone_t
*
zone_default_get
(
void
)
{
malloc_zone_t
*
*
zones
=
NULL
;
unsigned
int
num_zones
=
0
;
if
(
KERN_SUCCESS
!
=
malloc_get_all_zones
(
0
NULL
(
vm_address_t
*
*
)
&
zones
&
num_zones
)
)
{
num_zones
=
0
;
}
if
(
num_zones
)
return
(
zones
[
0
]
)
;
return
(
malloc_default_zone
(
)
)
;
}
static
void
zone_promote
(
void
)
{
malloc_zone_t
*
zone
;
do
{
malloc_zone_unregister
(
default_zone
)
;
malloc_zone_register
(
default_zone
)
;
if
(
purgeable_zone
!
=
NULL
)
{
malloc_zone_unregister
(
purgeable_zone
)
;
malloc_zone_register
(
purgeable_zone
)
;
}
zone
=
zone_default_get
(
)
;
}
while
(
zone
!
=
&
jemalloc_zone
)
;
}
JEMALLOC_ATTR
(
constructor
)
void
zone_register
(
void
)
{
default_zone
=
zone_default_get
(
)
;
if
(
!
default_zone
-
>
zone_name
|
|
strcmp
(
default_zone
-
>
zone_name
"
DefaultMallocZone
"
)
!
=
0
)
return
;
purgeable_zone
=
(
malloc_default_purgeable_zone
=
=
NULL
)
?
NULL
:
malloc_default_purgeable_zone
(
)
;
zone_init
(
)
;
malloc_zone_register
(
&
jemalloc_zone
)
;
zone_promote
(
)
;
}
