this
.
FirefoxMonitor
=
{
domainMap
:
new
Map
(
)
warnedHostsSet
:
new
Set
(
)
kWarnedHostsPref
:
"
extensions
.
fxmonitor
.
warnedHosts
"
extension
:
null
observerAdded
:
false
strings
:
null
enabled
:
null
kEnabledPref
:
"
extensions
.
fxmonitor
.
enabled
"
kNotificationID
:
"
fxmonitor
"
FirefoxMonitorURL
:
null
kFirefoxMonitorURLPref
:
"
extensions
.
fxmonitor
.
FirefoxMonitorURL
"
kDefaultFirefoxMonitorURL
:
"
https
:
/
/
monitor
.
firefox
.
com
"
firstAlertShown
:
null
kFirstAlertShownPref
:
"
extensions
.
fxmonitor
.
firstAlertShown
"
disable
(
)
{
Preferences
.
set
(
this
.
kEnabledPref
false
)
;
}
getURL
(
aPath
)
{
return
this
.
extension
.
getURL
(
aPath
)
;
}
getString
(
aKey
)
{
return
this
.
strings
.
GetStringFromName
(
aKey
)
;
}
getFormattedString
(
aKey
args
)
{
return
this
.
strings
.
formatStringFromName
(
aKey
args
args
.
length
)
;
}
init
(
aExtension
)
{
this
.
extension
=
aExtension
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
enabled
"
this
.
kEnabledPref
false
(
pref
oldVal
newVal
)
=
>
{
if
(
newVal
)
{
this
.
startObserving
(
)
;
}
else
{
this
.
stopObserving
(
)
;
}
}
)
;
if
(
this
.
enabled
)
{
this
.
startObserving
(
)
;
}
}
_delayedInited
:
false
async
delayedInit
(
)
{
if
(
this
.
_delayedInited
)
{
return
;
}
Services
.
scriptloader
.
loadSubScript
(
this
.
getURL
(
"
privileged
/
subscripts
/
Globals
.
jsm
"
)
)
;
Services
.
scriptloader
.
loadSubScript
(
this
.
getURL
(
"
privileged
/
subscripts
/
EveryWindow
.
jsm
"
)
)
;
Services
.
scriptloader
.
loadSubScript
(
this
.
getURL
(
"
privileged
/
subscripts
/
PanelUI
.
jsm
"
)
)
;
Services
.
telemetry
.
registerEvents
(
"
fxmonitor
"
{
"
interaction
"
:
{
methods
:
[
"
interaction
"
]
objects
:
[
"
doorhanger_shown
"
"
doorhanger_removed
"
"
check_btn
"
"
dismiss_btn
"
"
never_show_btn
"
]
record_on_release
:
false
}
}
)
;
Services
.
telemetry
.
setEventRecordingEnabled
(
"
fxmonitor
"
false
)
;
let
warnedHostsJSON
=
Preferences
.
get
(
this
.
kWarnedHostsPref
"
"
)
;
if
(
warnedHostsJSON
)
{
try
{
let
json
=
JSON
.
parse
(
warnedHostsJSON
)
;
this
.
warnedHostsSet
=
new
Set
(
json
)
;
}
catch
(
ex
)
{
Preferences
.
reset
(
this
.
kWarnedHostsPref
)
;
}
}
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
FirefoxMonitorURL
"
this
.
kFirefoxMonitorURLPref
this
.
kDefaultFirefoxMonitorURL
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
firstAlertShown
"
this
.
kFirstAlertShownPref
false
)
;
await
this
.
loadStrings
(
)
;
await
this
.
loadBreaches
(
)
;
this
.
_delayedInited
=
true
;
}
async
loadStrings
(
)
{
let
response
;
let
locale
=
Services
.
locale
.
defaultLocale
;
try
{
response
=
await
fetch
(
this
.
getURL
(
locale
/
{
locale
}
/
strings
.
properties
)
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
Firefox
Monitor
:
no
strings
available
for
{
locale
}
.
Falling
back
to
en
-
US
.
)
;
response
=
await
fetch
(
this
.
getURL
(
locale
/
en
-
US
/
strings
.
properties
)
)
;
}
let
buffer
=
await
response
.
arrayBuffer
(
)
;
let
binary
=
"
"
;
let
bytes
=
new
Uint8Array
(
buffer
)
;
let
len
=
bytes
.
byteLength
;
for
(
let
i
=
0
;
i
<
len
;
i
+
+
)
{
binary
+
=
String
.
fromCharCode
(
bytes
[
i
]
)
;
}
let
b64
=
btoa
(
binary
)
;
this
.
strings
=
Services
.
strings
.
createBundle
(
data
:
text
/
plain
;
base64
{
b64
}
)
;
}
kRemoteSettingsKey
:
"
fxmonitor
-
breaches
"
async
loadBreaches
(
)
{
let
populateSites
=
(
data
)
=
>
{
this
.
domainMap
.
clear
(
)
;
data
.
forEach
(
site
=
>
{
if
(
!
site
.
Domain
|
|
!
site
.
Name
|
|
!
site
.
PwnCount
|
|
!
site
.
BreachDate
|
|
!
site
.
AddedDate
)
{
Cu
.
reportError
(
Firefox
Monitor
:
malformed
breach
entry
.
\
nSite
:
\
n
{
JSON
.
stringify
(
site
)
}
)
;
return
;
}
try
{
this
.
domainMap
.
set
(
site
.
Domain
{
Name
:
site
.
Name
PwnCount
:
site
.
PwnCount
Year
:
(
new
Date
(
site
.
BreachDate
)
)
.
getFullYear
(
)
AddedDate
:
site
.
AddedDate
.
split
(
"
T
"
)
[
0
]
}
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
Firefox
Monitor
:
malformed
breach
entry
.
\
nSite
:
\
n
{
JSON
.
stringify
(
site
)
}
\
nError
:
\
n
{
e
}
)
;
}
}
)
;
}
;
RemoteSettings
(
this
.
kRemoteSettingsKey
)
.
on
(
"
sync
"
(
event
)
=
>
{
let
{
data
:
{
current
}
}
=
event
;
populateSites
(
current
)
;
}
)
;
let
data
=
await
RemoteSettings
(
this
.
kRemoteSettingsKey
)
.
get
(
)
;
if
(
data
&
&
data
.
length
)
{
populateSites
(
data
)
;
}
}
onStateChange
(
aBrowser
aWebProgress
aRequest
aStateFlags
aStatus
)
{
if
(
!
(
aStateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_STOP
)
|
|
(
!
aWebProgress
.
isTopLevel
|
|
aWebProgress
.
isLoadingDocument
|
|
!
Components
.
isSuccessCode
(
aStatus
)
)
)
{
return
;
}
let
host
;
try
{
host
=
Services
.
eTLD
.
getBaseDomain
(
aRequest
.
URI
)
;
}
catch
(
e
)
{
return
;
}
this
.
warnIfNeeded
(
aBrowser
host
)
;
}
async
startObserving
(
)
{
if
(
this
.
observerAdded
)
{
return
;
}
await
this
.
delayedInit
(
)
;
EveryWindow
.
registerCallback
(
this
.
kNotificationID
(
win
)
=
>
{
let
DOMWindowUtils
=
win
.
windowUtils
;
DOMWindowUtils
.
loadSheetUsingURIString
(
this
.
getURL
(
"
privileged
/
FirefoxMonitor
.
css
"
)
DOMWindowUtils
.
AUTHOR_SHEET
)
;
win
.
FirefoxMonitorUtils
=
{
notifications
:
new
Set
(
)
disable
:
(
)
=
>
{
this
.
disable
(
)
;
}
getString
:
(
aKey
)
=
>
{
return
this
.
getString
(
aKey
)
;
}
getFormattedString
:
(
aKey
args
)
=
>
{
return
this
.
getFormattedString
(
aKey
args
)
;
}
getFirefoxMonitorURL
:
(
aSiteName
)
=
>
{
return
{
this
.
FirefoxMonitorURL
}
/
?
breach
=
{
encodeURIComponent
(
aSiteName
)
}
&
utm_source
=
firefox
&
utm_medium
=
popup
;
}
}
;
let
doc
=
win
.
document
;
let
notificationBox
=
doc
.
getElementById
(
"
notification
-
popup
-
box
"
)
;
let
anchorBox
=
doc
.
createElementNS
(
XUL_NS
"
box
"
)
;
anchorBox
.
setAttribute
(
"
id
"
{
this
.
kNotificationID
}
-
notification
-
anchor
)
;
anchorBox
.
classList
.
add
(
"
notification
-
anchor
-
icon
"
)
;
let
img
=
doc
.
createElementNS
(
XUL_NS
"
image
"
)
;
img
.
setAttribute
(
"
role
"
"
button
"
)
;
img
.
classList
.
add
(
{
this
.
kNotificationID
}
-
icon
)
;
img
.
style
.
listStyleImage
=
url
(
{
this
.
getURL
(
"
assets
/
monitor32
.
svg
"
)
}
)
;
anchorBox
.
appendChild
(
img
)
;
notificationBox
.
appendChild
(
anchorBox
)
;
img
.
setAttribute
(
"
tooltiptext
"
this
.
getFormattedString
(
"
fxmonitor
.
anchorIcon
.
tooltiptext
"
[
this
.
getString
(
"
fxmonitor
.
brandName
"
)
]
)
)
;
let
parentElt
=
doc
.
defaultView
.
PopupNotifications
.
panel
.
parentNode
;
let
pn
=
doc
.
createElementNS
(
XUL_NS
"
popupnotification
"
)
;
let
pnContent
=
doc
.
createElementNS
(
XUL_NS
"
popupnotificationcontent
"
)
;
let
panelUI
=
new
PanelUI
(
doc
)
;
pnContent
.
appendChild
(
panelUI
.
box
)
;
pn
.
appendChild
(
pnContent
)
;
pn
.
setAttribute
(
"
id
"
{
this
.
kNotificationID
}
-
notification
)
;
pn
.
setAttribute
(
"
hidden
"
"
true
"
)
;
parentElt
.
appendChild
(
pn
)
;
win
.
FirefoxMonitorPanelUI
=
panelUI
;
win
.
gBrowser
.
addTabsProgressListener
(
this
)
;
}
(
win
)
=
>
{
if
(
!
win
.
gBrowser
)
{
return
;
}
let
DOMWindowUtils
=
win
.
windowUtils
;
if
(
!
DOMWindowUtils
)
{
DOMWindowUtils
=
win
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
}
DOMWindowUtils
.
removeSheetUsingURIString
(
this
.
getURL
(
"
privileged
/
FirefoxMonitor
.
css
"
)
DOMWindowUtils
.
AUTHOR_SHEET
)
;
win
.
FirefoxMonitorUtils
.
notifications
.
forEach
(
n
=
>
{
n
.
remove
(
)
;
}
)
;
delete
win
.
FirefoxMonitorUtils
;
let
doc
=
win
.
document
;
doc
.
getElementById
(
{
this
.
kNotificationID
}
-
notification
-
anchor
)
.
remove
(
)
;
doc
.
getElementById
(
{
this
.
kNotificationID
}
-
notification
)
.
remove
(
)
;
delete
win
.
FirefoxMonitorPanelUI
;
win
.
gBrowser
.
removeTabsProgressListener
(
this
)
;
}
)
;
this
.
observerAdded
=
true
;
}
stopObserving
(
)
{
if
(
!
this
.
observerAdded
)
{
return
;
}
EveryWindow
.
unregisterCallback
(
this
.
kNotificationID
)
;
this
.
observerAdded
=
false
;
}
warnIfNeeded
(
browser
host
)
{
if
(
!
this
.
enabled
|
|
this
.
warnedHostsSet
.
has
(
host
)
|
|
!
this
.
domainMap
.
has
(
host
)
)
{
return
;
}
let
site
=
this
.
domainMap
.
get
(
host
)
;
let
breachDateThreshold
=
new
Date
(
)
;
if
(
this
.
firstAlertShown
)
{
breachDateThreshold
.
setMonth
(
breachDateThreshold
.
getMonth
(
)
-
2
)
;
}
else
{
breachDateThreshold
.
setFullYear
(
breachDateThreshold
.
getFullYear
(
)
-
1
)
;
}
if
(
new
Date
(
site
.
AddedDate
)
.
getTime
(
)
<
breachDateThreshold
.
getTime
(
)
)
{
return
;
}
else
if
(
!
this
.
firstAlertShown
)
{
Preferences
.
set
(
this
.
kFirstAlertShownPref
true
)
;
}
this
.
warnedHostsSet
.
add
(
host
)
;
Preferences
.
set
(
this
.
kWarnedHostsPref
JSON
.
stringify
(
[
.
.
.
this
.
warnedHostsSet
]
)
)
;
let
doc
=
browser
.
ownerDocument
;
let
win
=
doc
.
defaultView
;
let
panelUI
=
doc
.
defaultView
.
FirefoxMonitorPanelUI
;
let
animatedOnce
=
false
;
let
populatePanel
=
(
event
)
=
>
{
switch
(
event
)
{
case
"
showing
"
:
panelUI
.
refresh
(
site
)
;
if
(
animatedOnce
)
{
doc
.
getElementById
(
"
notification
-
popup
"
)
.
setAttribute
(
"
fxmonitoranimationdone
"
"
true
"
)
;
doc
.
getElementById
(
{
this
.
kNotificationID
}
-
notification
-
anchor
)
.
setAttribute
(
"
fxmonitoranimationdone
"
"
true
"
)
;
break
;
}
doc
.
getElementById
(
"
notification
-
popup
"
)
.
removeAttribute
(
"
fxmonitoranimationdone
"
)
;
doc
.
getElementById
(
{
this
.
kNotificationID
}
-
notification
-
anchor
)
.
removeAttribute
(
"
fxmonitoranimationdone
"
)
;
break
;
case
"
shown
"
:
animatedOnce
=
true
;
break
;
case
"
removed
"
:
win
.
FirefoxMonitorUtils
.
notifications
.
delete
(
win
.
PopupNotifications
.
getNotification
(
this
.
kNotificationID
browser
)
)
;
Services
.
telemetry
.
recordEvent
(
"
fxmonitor
"
"
interaction
"
"
doorhanger_removed
"
)
;
break
;
}
}
;
let
n
=
win
.
PopupNotifications
.
show
(
browser
this
.
kNotificationID
"
"
{
this
.
kNotificationID
}
-
notification
-
anchor
panelUI
.
primaryAction
panelUI
.
secondaryActions
{
persistent
:
true
hideClose
:
true
eventCallback
:
populatePanel
popupIconURL
:
this
.
getURL
(
"
assets
/
monitor32
.
svg
"
)
}
)
;
Services
.
telemetry
.
recordEvent
(
"
fxmonitor
"
"
interaction
"
"
doorhanger_shown
"
)
;
win
.
FirefoxMonitorUtils
.
notifications
.
add
(
n
)
;
}
}
;
