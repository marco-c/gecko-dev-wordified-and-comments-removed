this
.
FirefoxMonitor
=
{
domainMap
:
new
Map
(
)
warnedHostsSet
:
new
Set
(
)
kWarnedHostsPref
:
"
extensions
.
fxmonitor
.
warnedHosts
"
extension
:
null
observerAdded
:
false
strings
:
null
enabled
:
null
kEnabledPref
:
"
extensions
.
fxmonitor
.
enabled
"
kTelemetryDisabledPref
:
"
extensions
.
fxmonitor
.
telemetryDisabled
"
kNotificationID
:
"
fxmonitor
"
FirefoxMonitorURL
:
null
kFirefoxMonitorURLPref
:
"
extensions
.
fxmonitor
.
FirefoxMonitorURL
"
kDefaultFirefoxMonitorURL
:
"
https
:
/
/
monitor
.
firefox
.
com
"
firstAlertShown
:
null
kFirstAlertShownPref
:
"
extensions
.
fxmonitor
.
firstAlertShown
"
disable
(
)
{
Preferences
.
set
(
this
.
kEnabledPref
false
)
;
}
getURL
(
aPath
)
{
return
this
.
extension
.
getURL
(
aPath
)
;
}
getString
(
aKey
)
{
return
this
.
strings
.
GetStringFromName
(
aKey
)
;
}
getFormattedString
(
aKey
args
)
{
return
this
.
strings
.
formatStringFromName
(
aKey
args
args
.
length
)
;
}
init
(
aExtension
)
{
this
.
extension
=
aExtension
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
enabled
"
this
.
kEnabledPref
true
(
pref
oldVal
newVal
)
=
>
{
if
(
newVal
)
{
this
.
startObserving
(
)
;
}
else
{
this
.
stopObserving
(
)
;
}
}
)
;
if
(
this
.
enabled
)
{
this
.
startObserving
(
)
;
}
}
_delayedInited
:
false
async
delayedInit
(
)
{
if
(
this
.
_delayedInited
)
{
return
;
}
this
.
_delayedInited
=
true
;
Services
.
scriptloader
.
loadSubScript
(
this
.
getURL
(
"
privileged
/
subscripts
/
Globals
.
jsm
"
)
)
;
Services
.
scriptloader
.
loadSubScript
(
this
.
getURL
(
"
privileged
/
subscripts
/
EveryWindow
.
jsm
"
)
)
;
let
telemetryExpiryDate
=
new
Date
(
2019
10
1
)
;
let
today
=
new
Date
(
)
;
let
expired
=
today
.
getTime
(
)
>
telemetryExpiryDate
.
getTime
(
)
;
Services
.
telemetry
.
registerEvents
(
"
fxmonitor
"
{
"
interaction
"
:
{
methods
:
[
"
interaction
"
]
objects
:
[
"
doorhanger_shown
"
"
doorhanger_removed
"
"
check_btn
"
"
dismiss_btn
"
"
never_show_btn
"
]
record_on_release
:
true
expired
}
}
)
;
let
telemetryEnabled
=
!
Preferences
.
get
(
this
.
kTelemetryDisabledPref
)
;
Services
.
telemetry
.
setEventRecordingEnabled
(
"
fxmonitor
"
telemetryEnabled
)
;
let
warnedHostsJSON
=
Preferences
.
get
(
this
.
kWarnedHostsPref
"
"
)
;
if
(
warnedHostsJSON
)
{
try
{
let
json
=
JSON
.
parse
(
warnedHostsJSON
)
;
this
.
warnedHostsSet
=
new
Set
(
json
)
;
}
catch
(
ex
)
{
Preferences
.
reset
(
this
.
kWarnedHostsPref
)
;
}
}
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
FirefoxMonitorURL
"
this
.
kFirefoxMonitorURLPref
this
.
kDefaultFirefoxMonitorURL
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
firstAlertShown
"
this
.
kFirstAlertShownPref
false
)
;
await
this
.
loadStrings
(
)
;
await
this
.
loadBreaches
(
)
;
}
loadStrings
(
)
{
let
l10nManifest
;
if
(
this
.
extension
.
rootURI
instanceof
Ci
.
nsIJARURI
)
{
l10nManifest
=
this
.
extension
.
rootURI
.
JARFile
.
QueryInterface
(
Ci
.
nsIFileURL
)
.
file
;
}
else
if
(
this
.
extension
.
rootURI
instanceof
Ci
.
nsIFileURL
)
{
l10nManifest
=
this
.
extension
.
rootURI
.
file
;
}
if
(
l10nManifest
)
{
Components
.
manager
.
addBootstrappedManifestLocation
(
l10nManifest
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
strings
"
(
)
=
>
{
return
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
fxmonitor
/
locale
/
fxmonitor
.
properties
"
)
;
}
)
;
}
else
{
throw
new
Error
(
"
Cannot
find
fxmonitor
chrome
.
manifest
for
registering
translated
strings
"
)
;
}
}
kRemoteSettingsKey
:
"
fxmonitor
-
breaches
"
async
loadBreaches
(
)
{
let
populateSites
=
(
data
)
=
>
{
this
.
domainMap
.
clear
(
)
;
data
.
forEach
(
site
=
>
{
if
(
!
site
.
Domain
|
|
!
site
.
Name
|
|
!
site
.
PwnCount
|
|
!
site
.
BreachDate
|
|
!
site
.
AddedDate
)
{
Cu
.
reportError
(
Firefox
Monitor
:
malformed
breach
entry
.
\
nSite
:
\
n
{
JSON
.
stringify
(
site
)
}
)
;
return
;
}
try
{
this
.
domainMap
.
set
(
site
.
Domain
{
Name
:
site
.
Name
PwnCount
:
site
.
PwnCount
Year
:
(
new
Date
(
site
.
BreachDate
)
)
.
getFullYear
(
)
AddedDate
:
site
.
AddedDate
.
split
(
"
T
"
)
[
0
]
}
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
Firefox
Monitor
:
malformed
breach
entry
.
\
nSite
:
\
n
{
JSON
.
stringify
(
site
)
}
\
nError
:
\
n
{
e
}
)
;
}
}
)
;
}
;
RemoteSettings
(
this
.
kRemoteSettingsKey
)
.
on
(
"
sync
"
(
event
)
=
>
{
let
{
data
:
{
current
}
}
=
event
;
populateSites
(
current
)
;
}
)
;
let
data
=
await
RemoteSettings
(
this
.
kRemoteSettingsKey
)
.
get
(
)
;
if
(
data
&
&
data
.
length
)
{
populateSites
(
data
)
;
}
}
onStateChange
(
aBrowser
aWebProgress
aRequest
aStateFlags
aStatus
)
{
if
(
!
(
aStateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_STOP
)
|
|
(
!
aWebProgress
.
isTopLevel
|
|
aWebProgress
.
isLoadingDocument
|
|
!
Components
.
isSuccessCode
(
aStatus
)
)
)
{
return
;
}
let
host
;
try
{
host
=
Services
.
eTLD
.
getBaseDomain
(
aRequest
.
URI
)
;
}
catch
(
e
)
{
return
;
}
this
.
warnIfNeeded
(
aBrowser
host
)
;
}
notificationsByWindow
:
new
WeakMap
(
)
panelUIsByWindow
:
new
WeakMap
(
)
async
startObserving
(
)
{
if
(
this
.
observerAdded
)
{
return
;
}
EveryWindow
.
registerCallback
(
this
.
kNotificationID
(
win
)
=
>
{
if
(
this
.
notificationsByWindow
.
has
(
win
)
)
{
return
;
}
this
.
notificationsByWindow
.
set
(
win
new
Set
(
)
)
;
this
.
delayedInit
(
)
.
then
(
(
)
=
>
{
win
.
gBrowser
.
addTabsProgressListener
(
this
)
;
}
)
;
}
(
win
closing
)
=
>
{
if
(
closing
)
{
return
;
}
let
DOMWindowUtils
=
win
.
windowUtils
;
DOMWindowUtils
.
removeSheetUsingURIString
(
this
.
getURL
(
"
privileged
/
FirefoxMonitor
.
css
"
)
DOMWindowUtils
.
AUTHOR_SHEET
)
;
this
.
notificationsByWindow
.
get
(
win
)
.
forEach
(
n
=
>
{
n
.
remove
(
)
;
}
)
;
this
.
notificationsByWindow
.
delete
(
win
)
;
let
doc
=
win
.
document
;
doc
.
getElementById
(
{
this
.
kNotificationID
}
-
notification
-
anchor
)
.
remove
(
)
;
doc
.
getElementById
(
{
this
.
kNotificationID
}
-
notification
)
.
remove
(
)
;
this
.
panelUIsByWindow
.
delete
(
win
)
;
win
.
gBrowser
.
removeTabsProgressListener
(
this
)
;
}
)
;
this
.
observerAdded
=
true
;
}
setupPanelUI
(
win
)
{
let
DOMWindowUtils
=
win
.
windowUtils
;
DOMWindowUtils
.
loadSheetUsingURIString
(
this
.
getURL
(
"
privileged
/
FirefoxMonitor
.
css
"
)
DOMWindowUtils
.
AUTHOR_SHEET
)
;
let
doc
=
win
.
document
;
let
notificationBox
=
doc
.
getElementById
(
"
notification
-
popup
-
box
"
)
;
let
anchorBox
=
doc
.
createElementNS
(
XUL_NS
"
box
"
)
;
anchorBox
.
setAttribute
(
"
id
"
{
this
.
kNotificationID
}
-
notification
-
anchor
)
;
anchorBox
.
classList
.
add
(
"
notification
-
anchor
-
icon
"
)
;
let
img
=
doc
.
createElementNS
(
XUL_NS
"
image
"
)
;
img
.
setAttribute
(
"
role
"
"
button
"
)
;
img
.
classList
.
add
(
{
this
.
kNotificationID
}
-
icon
)
;
img
.
style
.
listStyleImage
=
url
(
{
this
.
getURL
(
"
assets
/
monitor32
.
svg
"
)
}
)
;
anchorBox
.
appendChild
(
img
)
;
notificationBox
.
appendChild
(
anchorBox
)
;
img
.
setAttribute
(
"
tooltiptext
"
this
.
getFormattedString
(
"
fxmonitor
.
anchorIcon
.
tooltiptext
"
[
this
.
getString
(
"
fxmonitor
.
brandName
"
)
]
)
)
;
let
parentElt
=
doc
.
defaultView
.
PopupNotifications
.
panel
.
parentNode
;
let
pn
=
doc
.
createElementNS
(
XUL_NS
"
popupnotification
"
)
;
let
pnContent
=
doc
.
createElementNS
(
XUL_NS
"
popupnotificationcontent
"
)
;
let
panelUI
=
new
PanelUI
(
doc
)
;
pnContent
.
appendChild
(
panelUI
.
box
)
;
pn
.
appendChild
(
pnContent
)
;
pn
.
setAttribute
(
"
id
"
{
this
.
kNotificationID
}
-
notification
)
;
pn
.
setAttribute
(
"
hidden
"
"
true
"
)
;
parentElt
.
appendChild
(
pn
)
;
this
.
panelUIsByWindow
.
set
(
win
panelUI
)
;
return
panelUI
;
}
stopObserving
(
)
{
if
(
!
this
.
observerAdded
)
{
return
;
}
EveryWindow
.
unregisterCallback
(
this
.
kNotificationID
)
;
this
.
observerAdded
=
false
;
}
warnIfNeeded
(
browser
host
)
{
if
(
!
this
.
enabled
|
|
this
.
warnedHostsSet
.
has
(
host
)
|
|
!
this
.
domainMap
.
has
(
host
)
)
{
return
;
}
let
site
=
this
.
domainMap
.
get
(
host
)
;
let
breachDateThreshold
=
new
Date
(
)
;
if
(
this
.
firstAlertShown
)
{
breachDateThreshold
.
setMonth
(
breachDateThreshold
.
getMonth
(
)
-
2
)
;
}
else
{
breachDateThreshold
.
setFullYear
(
breachDateThreshold
.
getFullYear
(
)
-
1
)
;
}
if
(
new
Date
(
site
.
AddedDate
)
.
getTime
(
)
<
breachDateThreshold
.
getTime
(
)
)
{
return
;
}
else
if
(
!
this
.
firstAlertShown
)
{
Preferences
.
set
(
this
.
kFirstAlertShownPref
true
)
;
}
this
.
warnedHostsSet
.
add
(
host
)
;
Preferences
.
set
(
this
.
kWarnedHostsPref
JSON
.
stringify
(
[
.
.
.
this
.
warnedHostsSet
]
)
)
;
let
doc
=
browser
.
ownerDocument
;
let
win
=
doc
.
defaultView
;
let
panelUI
=
this
.
panelUIsByWindow
.
get
(
win
)
;
if
(
!
panelUI
)
{
panelUI
=
this
.
setupPanelUI
(
win
)
;
}
let
animatedOnce
=
false
;
let
populatePanel
=
(
event
)
=
>
{
switch
(
event
)
{
case
"
showing
"
:
panelUI
.
refresh
(
site
)
;
if
(
animatedOnce
)
{
doc
.
getElementById
(
"
notification
-
popup
"
)
.
setAttribute
(
"
fxmonitoranimationdone
"
"
true
"
)
;
doc
.
getElementById
(
{
this
.
kNotificationID
}
-
notification
-
anchor
)
.
setAttribute
(
"
fxmonitoranimationdone
"
"
true
"
)
;
break
;
}
doc
.
getElementById
(
"
notification
-
popup
"
)
.
removeAttribute
(
"
fxmonitoranimationdone
"
)
;
doc
.
getElementById
(
{
this
.
kNotificationID
}
-
notification
-
anchor
)
.
removeAttribute
(
"
fxmonitoranimationdone
"
)
;
break
;
case
"
shown
"
:
animatedOnce
=
true
;
break
;
case
"
removed
"
:
this
.
notificationsByWindow
.
get
(
win
)
.
delete
(
win
.
PopupNotifications
.
getNotification
(
this
.
kNotificationID
browser
)
)
;
Services
.
telemetry
.
recordEvent
(
"
fxmonitor
"
"
interaction
"
"
doorhanger_removed
"
)
;
break
;
}
}
;
let
n
=
win
.
PopupNotifications
.
show
(
browser
this
.
kNotificationID
"
"
{
this
.
kNotificationID
}
-
notification
-
anchor
panelUI
.
primaryAction
panelUI
.
secondaryActions
{
persistent
:
true
hideClose
:
true
eventCallback
:
populatePanel
popupIconURL
:
this
.
getURL
(
"
assets
/
monitor32
.
svg
"
)
}
)
;
Services
.
telemetry
.
recordEvent
(
"
fxmonitor
"
"
interaction
"
"
doorhanger_shown
"
)
;
this
.
notificationsByWindow
.
get
(
win
)
.
add
(
n
)
;
}
}
;
function
PanelUI
(
doc
)
{
this
.
site
=
null
;
this
.
doc
=
doc
;
let
box
=
doc
.
createElementNS
(
XUL_NS
"
vbox
"
)
;
let
elt
=
doc
.
createElementNS
(
XUL_NS
"
description
"
)
;
elt
.
textContent
=
this
.
getString
(
"
fxmonitor
.
popupHeader
"
)
;
elt
.
classList
.
add
(
"
headerText
"
)
;
box
.
appendChild
(
elt
)
;
elt
=
doc
.
createElementNS
(
XUL_NS
"
description
"
)
;
elt
.
classList
.
add
(
"
popupText
"
)
;
box
.
appendChild
(
elt
)
;
this
.
box
=
box
;
}
PanelUI
.
prototype
=
{
getString
(
aKey
)
{
return
FirefoxMonitor
.
getString
(
aKey
)
;
}
getFormattedString
(
aKey
args
)
{
return
FirefoxMonitor
.
getFormattedString
(
aKey
args
)
;
}
get
brandString
(
)
{
if
(
this
.
_brandString
)
{
return
this
.
_brandString
;
}
return
this
.
_brandString
=
this
.
getString
(
"
fxmonitor
.
brandName
"
)
;
}
getFirefoxMonitorURL
:
(
aSiteName
)
=
>
{
return
{
FirefoxMonitor
.
FirefoxMonitorURL
}
/
?
breach
=
{
encodeURIComponent
(
aSiteName
)
}
&
utm_source
=
firefox
&
utm_medium
=
popup
;
}
get
primaryAction
(
)
{
if
(
this
.
_primaryAction
)
{
return
this
.
_primaryAction
;
}
return
this
.
_primaryAction
=
{
label
:
this
.
getFormattedString
(
"
fxmonitor
.
checkButton
.
label
"
[
this
.
brandString
]
)
accessKey
:
this
.
getString
(
"
fxmonitor
.
checkButton
.
accessKey
"
)
callback
:
(
)
=
>
{
let
win
=
this
.
doc
.
defaultView
;
win
.
openTrustedLinkIn
(
this
.
getFirefoxMonitorURL
(
this
.
site
.
Name
)
"
tab
"
{
}
)
;
Services
.
telemetry
.
recordEvent
(
"
fxmonitor
"
"
interaction
"
"
check_btn
"
)
;
}
}
;
}
get
secondaryActions
(
)
{
if
(
this
.
_secondaryActions
)
{
return
this
.
_secondaryActions
;
}
return
this
.
_secondaryActions
=
[
{
label
:
this
.
getString
(
"
fxmonitor
.
dismissButton
.
label
"
)
accessKey
:
this
.
getString
(
"
fxmonitor
.
dismissButton
.
accessKey
"
)
callback
:
(
)
=
>
{
Services
.
telemetry
.
recordEvent
(
"
fxmonitor
"
"
interaction
"
"
dismiss_btn
"
)
;
}
}
{
label
:
this
.
getFormattedString
(
"
fxmonitor
.
neverShowButton
.
label
"
[
this
.
brandString
]
)
accessKey
:
this
.
getString
(
"
fxmonitor
.
neverShowButton
.
accessKey
"
)
callback
:
(
)
=
>
{
FirefoxMonitor
.
disable
(
)
;
Services
.
telemetry
.
recordEvent
(
"
fxmonitor
"
"
interaction
"
"
never_show_btn
"
)
;
}
}
]
;
}
refresh
(
site
)
{
this
.
site
=
site
;
let
elt
=
this
.
box
.
querySelector
(
"
.
popupText
"
)
;
let
k100k
=
100000
;
let
pwnCount
=
site
.
PwnCount
;
let
stringName
=
"
fxmonitor
.
popupText
"
;
if
(
pwnCount
>
k100k
)
{
let
multiplier
=
1
;
while
(
pwnCount
>
=
10
)
{
pwnCount
/
=
10
;
multiplier
*
=
10
;
}
pwnCount
=
Math
.
floor
(
pwnCount
)
*
multiplier
;
stringName
=
"
fxmonitor
.
popupTextRounded
"
;
}
elt
.
textContent
=
PluralForm
.
get
(
pwnCount
this
.
getString
(
stringName
)
)
.
replace
(
"
#
1
"
pwnCount
.
toLocaleString
(
)
)
.
replace
(
"
#
2
"
site
.
Name
)
.
replace
(
"
#
3
"
site
.
Year
)
.
replace
(
"
#
4
"
this
.
brandString
)
;
}
}
;
