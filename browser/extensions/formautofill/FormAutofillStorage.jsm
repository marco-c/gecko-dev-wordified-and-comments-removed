"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
formAutofillStorage
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
formautofill
/
FormAutofill
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
CreditCard
"
"
resource
:
/
/
gre
/
modules
/
CreditCard
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
JSONFile
"
"
resource
:
/
/
gre
/
modules
/
JSONFile
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
FormAutofillNameUtils
"
"
resource
:
/
/
formautofill
/
FormAutofillNameUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
FormAutofillUtils
"
"
resource
:
/
/
formautofill
/
FormAutofillUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
MasterPassword
"
"
resource
:
/
/
formautofill
/
MasterPassword
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PhoneNumber
"
"
resource
:
/
/
formautofill
/
phonenumberutils
/
PhoneNumber
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
gUUIDGenerator
"
"
mozilla
.
org
/
uuid
-
generator
;
1
"
"
nsIUUIDGenerator
"
)
;
const
CryptoHash
=
Components
.
Constructor
(
"
mozilla
.
org
/
security
/
hash
;
1
"
"
nsICryptoHash
"
"
initWithString
"
)
;
const
PROFILE_JSON_FILE_NAME
=
"
autofill
-
profiles
.
json
"
;
const
STORAGE_SCHEMA_VERSION
=
1
;
const
ADDRESS_SCHEMA_VERSION
=
1
;
const
CREDIT_CARD_SCHEMA_VERSION
=
1
;
const
VALID_ADDRESS_FIELDS
=
[
"
given
-
name
"
"
additional
-
name
"
"
family
-
name
"
"
organization
"
"
street
-
address
"
"
address
-
level2
"
"
address
-
level1
"
"
postal
-
code
"
"
country
"
"
tel
"
"
email
"
]
;
const
STREET_ADDRESS_COMPONENTS
=
[
"
address
-
line1
"
"
address
-
line2
"
"
address
-
line3
"
]
;
const
TEL_COMPONENTS
=
[
"
tel
-
country
-
code
"
"
tel
-
national
"
"
tel
-
area
-
code
"
"
tel
-
local
"
"
tel
-
local
-
prefix
"
"
tel
-
local
-
suffix
"
]
;
const
VALID_ADDRESS_COMPUTED_FIELDS
=
[
"
name
"
"
country
-
name
"
]
.
concat
(
STREET_ADDRESS_COMPONENTS
TEL_COMPONENTS
)
;
const
VALID_CREDIT_CARD_FIELDS
=
[
"
billingAddressGUID
"
"
cc
-
name
"
"
cc
-
number
"
"
cc
-
exp
-
month
"
"
cc
-
exp
-
year
"
]
;
const
VALID_CREDIT_CARD_COMPUTED_FIELDS
=
[
"
cc
-
given
-
name
"
"
cc
-
additional
-
name
"
"
cc
-
family
-
name
"
"
cc
-
number
-
encrypted
"
"
cc
-
exp
"
]
;
const
INTERNAL_FIELDS
=
[
"
guid
"
"
version
"
"
timeCreated
"
"
timeLastUsed
"
"
timeLastModified
"
"
timesUsed
"
]
;
function
sha512
(
string
)
{
if
(
string
=
=
null
)
{
return
null
;
}
let
encoder
=
new
TextEncoder
(
"
utf
-
8
"
)
;
let
bytes
=
encoder
.
encode
(
string
)
;
let
hash
=
new
CryptoHash
(
"
sha512
"
)
;
hash
.
update
(
bytes
bytes
.
length
)
;
return
hash
.
finish
(
true
)
;
}
class
AutofillRecords
{
constructor
(
store
collectionName
validFields
validComputedFields
schemaVersion
)
{
FormAutofill
.
defineLazyLogGetter
(
this
"
AutofillRecords
:
"
+
collectionName
)
;
this
.
VALID_FIELDS
=
validFields
;
this
.
VALID_COMPUTED_FIELDS
=
validComputedFields
;
this
.
_store
=
store
;
this
.
_collectionName
=
collectionName
;
this
.
_schemaVersion
=
schemaVersion
;
let
hasChanges
=
(
result
record
)
=
>
this
.
_migrateRecord
(
record
)
|
|
result
;
if
(
this
.
_data
.
reduce
(
hasChanges
false
)
)
{
this
.
_store
.
saveSoon
(
)
;
}
}
get
version
(
)
{
return
this
.
_schemaVersion
;
}
get
_data
(
)
{
return
this
.
_store
.
data
[
this
.
_collectionName
]
;
}
_ensureMatchingVersion
(
record
)
{
if
(
record
.
version
!
=
this
.
version
)
{
throw
new
Error
(
Got
unknown
record
version
{
record
.
version
}
;
want
{
this
.
version
}
)
;
}
}
add
(
record
{
sourceSync
=
false
}
=
{
}
)
{
this
.
log
.
debug
(
"
add
:
"
record
)
;
let
recordToSave
=
this
.
_clone
(
record
)
;
if
(
sourceSync
)
{
let
index
=
this
.
_findIndexByGUID
(
recordToSave
.
guid
{
includeDeleted
:
true
}
)
;
if
(
index
>
-
1
)
{
let
existing
=
this
.
_data
[
index
]
;
if
(
existing
.
deleted
)
{
this
.
_data
.
splice
(
index
1
)
;
}
else
{
throw
new
Error
(
Record
{
recordToSave
.
guid
}
already
exists
)
;
}
}
}
else
if
(
!
recordToSave
.
deleted
)
{
this
.
_normalizeRecord
(
recordToSave
)
;
this
.
_validateFields
(
recordToSave
)
;
recordToSave
.
guid
=
this
.
_generateGUID
(
)
;
recordToSave
.
version
=
this
.
version
;
let
now
=
Date
.
now
(
)
;
recordToSave
.
timeCreated
=
now
;
recordToSave
.
timeLastModified
=
now
;
recordToSave
.
timeLastUsed
=
0
;
recordToSave
.
timesUsed
=
0
;
}
return
this
.
_saveRecord
(
recordToSave
{
sourceSync
}
)
;
}
_saveRecord
(
record
{
sourceSync
=
false
}
=
{
}
)
{
if
(
!
record
.
guid
)
{
throw
new
Error
(
"
Record
missing
GUID
"
)
;
}
let
recordToSave
;
if
(
record
.
deleted
)
{
if
(
this
.
_findByGUID
(
record
.
guid
{
includeDeleted
:
true
}
)
)
{
throw
new
Error
(
"
a
record
with
this
GUID
already
exists
"
)
;
}
recordToSave
=
{
guid
:
record
.
guid
timeLastModified
:
record
.
timeLastModified
|
|
Date
.
now
(
)
deleted
:
true
}
;
}
else
{
this
.
_ensureMatchingVersion
(
record
)
;
recordToSave
=
record
;
this
.
computeFields
(
recordToSave
)
;
}
if
(
sourceSync
)
{
let
sync
=
this
.
_getSyncMetaData
(
recordToSave
true
)
;
sync
.
changeCounter
=
0
;
}
this
.
_data
.
push
(
recordToSave
)
;
this
.
_store
.
saveSoon
(
)
;
Services
.
obs
.
notifyObservers
(
{
wrappedJSObject
:
{
sourceSync
guid
:
record
.
guid
collectionName
:
this
.
_collectionName
}
}
"
formautofill
-
storage
-
changed
"
"
add
"
)
;
return
recordToSave
.
guid
;
}
_generateGUID
(
)
{
let
guid
;
while
(
!
guid
|
|
this
.
_findByGUID
(
guid
)
)
{
guid
=
gUUIDGenerator
.
generateUUID
(
)
.
toString
(
)
.
replace
(
/
[
{
}
-
]
/
g
"
"
)
.
substring
(
0
12
)
;
}
return
guid
;
}
update
(
guid
record
preserveOldProperties
=
false
)
{
this
.
log
.
debug
(
"
update
:
"
guid
record
)
;
let
recordFoundIndex
=
this
.
_findIndexByGUID
(
guid
)
;
if
(
recordFoundIndex
=
=
-
1
)
{
throw
new
Error
(
"
No
matching
record
.
"
)
;
}
let
recordFound
=
this
.
_clone
(
this
.
_data
[
recordFoundIndex
]
)
;
this
.
_stripComputedFields
(
recordFound
)
;
let
recordToUpdate
=
this
.
_clone
(
record
)
;
this
.
_normalizeRecord
(
recordToUpdate
true
)
;
let
hasValidField
=
false
;
for
(
let
field
of
this
.
VALID_FIELDS
)
{
let
oldValue
=
recordFound
[
field
]
;
let
newValue
=
recordToUpdate
[
field
]
;
if
(
preserveOldProperties
&
&
newValue
=
=
=
undefined
)
{
newValue
=
oldValue
;
}
if
(
newValue
=
=
=
undefined
|
|
newValue
=
=
=
"
"
)
{
delete
recordFound
[
field
]
;
}
else
{
hasValidField
=
true
;
recordFound
[
field
]
=
newValue
;
}
this
.
_maybeStoreLastSyncedField
(
recordFound
field
oldValue
)
;
}
if
(
!
hasValidField
)
{
throw
new
Error
(
"
Record
contains
no
valid
field
.
"
)
;
}
this
.
_validateFields
(
recordFound
)
;
recordFound
.
timeLastModified
=
Date
.
now
(
)
;
let
syncMetadata
=
this
.
_getSyncMetaData
(
recordFound
)
;
if
(
syncMetadata
)
{
syncMetadata
.
changeCounter
+
=
1
;
}
this
.
computeFields
(
recordFound
)
;
this
.
_data
[
recordFoundIndex
]
=
recordFound
;
this
.
_store
.
saveSoon
(
)
;
Services
.
obs
.
notifyObservers
(
{
wrappedJSObject
:
{
guid
collectionName
:
this
.
_collectionName
}
}
"
formautofill
-
storage
-
changed
"
"
update
"
)
;
}
notifyUsed
(
guid
)
{
this
.
log
.
debug
(
"
notifyUsed
:
"
guid
)
;
let
recordFound
=
this
.
_findByGUID
(
guid
)
;
if
(
!
recordFound
)
{
throw
new
Error
(
"
No
matching
record
.
"
)
;
}
recordFound
.
timesUsed
+
+
;
recordFound
.
timeLastUsed
=
Date
.
now
(
)
;
this
.
_store
.
saveSoon
(
)
;
Services
.
obs
.
notifyObservers
(
{
wrappedJSObject
:
{
guid
collectionName
:
this
.
_collectionName
}
}
"
formautofill
-
storage
-
changed
"
"
notifyUsed
"
)
;
}
remove
(
guid
{
sourceSync
=
false
}
=
{
}
)
{
this
.
log
.
debug
(
"
remove
:
"
guid
)
;
if
(
sourceSync
)
{
this
.
_removeSyncedRecord
(
guid
)
;
}
else
{
let
index
=
this
.
_findIndexByGUID
(
guid
{
includeDeleted
:
false
}
)
;
if
(
index
=
=
-
1
)
{
this
.
log
.
warn
(
"
attempting
to
remove
non
-
existing
entry
"
guid
)
;
return
;
}
let
existing
=
this
.
_data
[
index
]
;
if
(
existing
.
deleted
)
{
return
;
}
let
existingSync
=
this
.
_getSyncMetaData
(
existing
)
;
if
(
existingSync
)
{
this
.
_data
[
index
]
=
{
guid
timeLastModified
:
Date
.
now
(
)
deleted
:
true
_sync
:
existingSync
}
;
existingSync
.
changeCounter
+
+
;
}
else
{
this
.
_data
.
splice
(
index
1
)
;
}
}
this
.
_store
.
saveSoon
(
)
;
Services
.
obs
.
notifyObservers
(
{
wrappedJSObject
:
{
sourceSync
guid
collectionName
:
this
.
_collectionName
}
}
"
formautofill
-
storage
-
changed
"
"
remove
"
)
;
}
get
(
guid
{
rawData
=
false
}
=
{
}
)
{
this
.
log
.
debug
(
"
get
:
"
guid
rawData
)
;
let
recordFound
=
this
.
_findByGUID
(
guid
)
;
if
(
!
recordFound
)
{
return
null
;
}
let
clonedRecord
=
this
.
_cloneAndCleanUp
(
recordFound
)
;
if
(
rawData
)
{
this
.
_stripComputedFields
(
clonedRecord
)
;
}
else
{
this
.
_recordReadProcessor
(
clonedRecord
)
;
}
return
clonedRecord
;
}
getAll
(
{
rawData
=
false
includeDeleted
=
false
}
=
{
}
)
{
this
.
log
.
debug
(
"
getAll
"
rawData
includeDeleted
)
;
let
records
=
this
.
_data
.
filter
(
r
=
>
!
r
.
deleted
|
|
includeDeleted
)
;
let
clonedRecords
=
records
.
map
(
r
=
>
this
.
_cloneAndCleanUp
(
r
)
)
;
clonedRecords
.
forEach
(
record
=
>
{
if
(
rawData
)
{
this
.
_stripComputedFields
(
record
)
;
}
else
{
this
.
_recordReadProcessor
(
record
)
;
}
}
)
;
return
clonedRecords
;
}
_maybeStoreLastSyncedField
(
record
field
lastSyncedValue
)
{
let
sync
=
this
.
_getSyncMetaData
(
record
)
;
if
(
!
sync
)
{
return
;
}
let
alreadyChanged
=
field
in
sync
.
lastSyncedFields
;
if
(
alreadyChanged
)
{
return
;
}
let
newValue
=
record
[
field
]
;
if
(
lastSyncedValue
!
=
newValue
)
{
sync
.
lastSyncedFields
[
field
]
=
sha512
(
lastSyncedValue
)
;
}
}
_mergeSyncedRecords
(
strippedLocalRecord
remoteRecord
)
{
let
sync
=
this
.
_getSyncMetaData
(
strippedLocalRecord
true
)
;
let
mergedRecord
=
{
}
;
for
(
let
field
of
INTERNAL_FIELDS
)
{
if
(
remoteRecord
[
field
]
!
=
null
)
{
mergedRecord
[
field
]
=
remoteRecord
[
field
]
;
}
}
for
(
let
field
of
this
.
VALID_FIELDS
)
{
let
isLocalSame
=
false
;
let
isRemoteSame
=
false
;
if
(
field
in
sync
.
lastSyncedFields
)
{
let
lastSyncedValue
=
sync
.
lastSyncedFields
[
field
]
;
isLocalSame
=
lastSyncedValue
=
=
sha512
(
strippedLocalRecord
[
field
]
)
;
isRemoteSame
=
lastSyncedValue
=
=
sha512
(
remoteRecord
[
field
]
)
;
}
else
{
isLocalSame
=
true
;
isRemoteSame
=
strippedLocalRecord
[
field
]
=
=
remoteRecord
[
field
]
;
}
let
value
;
if
(
isLocalSame
&
&
isRemoteSame
)
{
value
=
strippedLocalRecord
[
field
]
;
}
else
if
(
isLocalSame
&
&
!
isRemoteSame
)
{
value
=
remoteRecord
[
field
]
;
}
else
if
(
!
isLocalSame
&
&
isRemoteSame
)
{
value
=
strippedLocalRecord
[
field
]
;
}
else
if
(
strippedLocalRecord
[
field
]
=
=
remoteRecord
[
field
]
)
{
value
=
strippedLocalRecord
[
field
]
;
}
else
{
return
null
;
}
if
(
value
!
=
null
)
{
mergedRecord
[
field
]
=
value
;
}
}
return
mergedRecord
;
}
_replaceRecordAt
(
index
remoteRecord
{
keepSyncMetadata
=
false
}
=
{
}
)
{
let
localRecord
=
this
.
_data
[
index
]
;
let
newRecord
=
this
.
_clone
(
remoteRecord
)
;
this
.
_stripComputedFields
(
newRecord
)
;
this
.
_data
[
index
]
=
newRecord
;
if
(
keepSyncMetadata
)
{
newRecord
.
_sync
=
localRecord
.
_sync
;
}
else
{
let
sync
=
this
.
_getSyncMetaData
(
newRecord
true
)
;
sync
.
changeCounter
=
0
;
}
if
(
!
newRecord
.
timeCreated
|
|
localRecord
.
timeCreated
<
newRecord
.
timeCreated
)
{
newRecord
.
timeCreated
=
localRecord
.
timeCreated
;
}
if
(
!
newRecord
.
timeLastModified
|
|
localRecord
.
timeLastModified
>
newRecord
.
timeLastModified
)
{
newRecord
.
timeLastModified
=
localRecord
.
timeLastModified
;
}
for
(
let
field
of
[
"
timeLastUsed
"
"
timesUsed
"
]
)
{
if
(
localRecord
[
field
]
!
=
null
)
{
newRecord
[
field
]
=
localRecord
[
field
]
;
}
}
this
.
computeFields
(
newRecord
)
;
}
_forkLocalRecord
(
strippedLocalRecord
)
{
let
forkedLocalRecord
=
this
.
_cloneAndCleanUp
(
strippedLocalRecord
)
;
forkedLocalRecord
.
guid
=
this
.
_generateGUID
(
)
;
this
.
_getSyncMetaData
(
forkedLocalRecord
true
)
;
this
.
computeFields
(
forkedLocalRecord
)
;
this
.
_data
.
push
(
forkedLocalRecord
)
;
return
forkedLocalRecord
;
}
reconcile
(
remoteRecord
)
{
this
.
_ensureMatchingVersion
(
remoteRecord
)
;
if
(
remoteRecord
.
deleted
)
{
throw
new
Error
(
Can
'
t
reconcile
tombstone
{
remoteRecord
.
guid
}
)
;
}
let
localIndex
=
this
.
_findIndexByGUID
(
remoteRecord
.
guid
)
;
if
(
localIndex
<
0
)
{
throw
new
Error
(
Record
{
remoteRecord
.
guid
}
not
found
)
;
}
let
localRecord
=
this
.
_data
[
localIndex
]
;
let
sync
=
this
.
_getSyncMetaData
(
localRecord
true
)
;
let
forkedGUID
=
null
;
if
(
sync
.
changeCounter
=
=
=
0
)
{
this
.
_replaceRecordAt
(
localIndex
remoteRecord
{
keepSyncMetadata
:
false
}
)
;
}
else
{
let
strippedLocalRecord
=
this
.
_clone
(
localRecord
)
;
this
.
_stripComputedFields
(
strippedLocalRecord
)
;
let
mergedRecord
=
this
.
_mergeSyncedRecords
(
strippedLocalRecord
remoteRecord
)
;
if
(
mergedRecord
)
{
this
.
_replaceRecordAt
(
localIndex
mergedRecord
{
keepSyncMetadata
:
true
}
)
;
}
else
{
let
forkedLocalRecord
=
this
.
_forkLocalRecord
(
strippedLocalRecord
)
;
forkedGUID
=
forkedLocalRecord
.
guid
;
this
.
_replaceRecordAt
(
localIndex
remoteRecord
{
keepSyncMetadata
:
false
}
)
;
}
}
this
.
_store
.
saveSoon
(
)
;
Services
.
obs
.
notifyObservers
(
{
wrappedJSObject
:
{
sourceSync
:
true
guid
:
remoteRecord
.
guid
forkedGUID
collectionName
:
this
.
_collectionName
}
}
"
formautofill
-
storage
-
changed
"
"
reconcile
"
)
;
return
{
forkedGUID
}
;
}
_removeSyncedRecord
(
guid
)
{
let
index
=
this
.
_findIndexByGUID
(
guid
{
includeDeleted
:
true
}
)
;
if
(
index
=
=
-
1
)
{
let
tombstone
=
{
guid
timeLastModified
:
Date
.
now
(
)
deleted
:
true
}
;
let
sync
=
this
.
_getSyncMetaData
(
tombstone
true
)
;
sync
.
changeCounter
=
0
;
this
.
_data
.
push
(
tombstone
)
;
return
;
}
let
existing
=
this
.
_data
[
index
]
;
let
sync
=
this
.
_getSyncMetaData
(
existing
true
)
;
if
(
sync
.
changeCounter
>
0
)
{
this
.
log
.
info
(
"
Ignoring
deletion
for
record
with
local
changes
"
existing
)
;
return
;
}
if
(
existing
.
deleted
)
{
this
.
log
.
info
(
"
Ignoring
deletion
for
tombstone
"
existing
)
;
return
;
}
this
.
_data
[
index
]
=
{
guid
timeLastModified
:
Date
.
now
(
)
deleted
:
true
_sync
:
sync
}
;
}
pullSyncChanges
(
)
{
let
changes
=
{
}
;
let
profiles
=
this
.
_data
;
for
(
let
profile
of
profiles
)
{
let
sync
=
this
.
_getSyncMetaData
(
profile
true
)
;
if
(
sync
.
changeCounter
<
1
)
{
if
(
sync
.
changeCounter
!
=
0
)
{
this
.
log
.
error
(
"
negative
change
counter
"
profile
)
;
}
continue
;
}
changes
[
profile
.
guid
]
=
{
profile
counter
:
sync
.
changeCounter
modified
:
profile
.
timeLastModified
synced
:
false
}
;
}
this
.
_store
.
saveSoon
(
)
;
return
changes
;
}
pushSyncChanges
(
changes
)
{
for
(
let
[
guid
{
counter
synced
}
]
of
Object
.
entries
(
changes
)
)
{
if
(
!
synced
)
{
continue
;
}
let
recordFound
=
this
.
_findByGUID
(
guid
{
includeDeleted
:
true
}
)
;
if
(
!
recordFound
)
{
this
.
log
.
warn
(
"
No
profile
found
to
persist
changes
for
guid
"
+
guid
)
;
continue
;
}
let
sync
=
this
.
_getSyncMetaData
(
recordFound
true
)
;
sync
.
changeCounter
=
Math
.
max
(
0
sync
.
changeCounter
-
counter
)
;
if
(
sync
.
changeCounter
=
=
=
0
)
{
sync
.
lastSyncedFields
=
{
}
;
}
}
this
.
_store
.
saveSoon
(
)
;
}
resetSync
(
)
{
for
(
let
record
of
this
.
_data
)
{
delete
record
.
_sync
;
}
this
.
log
.
info
(
"
All
sync
metadata
was
reset
"
)
;
}
changeGUID
(
oldID
newID
)
{
this
.
log
.
debug
(
"
changeGUID
:
"
oldID
newID
)
;
if
(
oldID
=
=
newID
)
{
throw
new
Error
(
"
changeGUID
:
old
and
new
IDs
are
the
same
"
)
;
}
if
(
this
.
_findIndexByGUID
(
newID
)
>
=
0
)
{
throw
new
Error
(
"
changeGUID
:
record
with
destination
id
exists
already
"
)
;
}
let
index
=
this
.
_findIndexByGUID
(
oldID
)
;
let
profile
=
this
.
_data
[
index
]
;
if
(
!
profile
)
{
throw
new
Error
(
"
changeGUID
:
no
source
record
"
)
;
}
if
(
this
.
_getSyncMetaData
(
profile
)
)
{
throw
new
Error
(
"
changeGUID
:
existing
record
has
already
been
synced
"
)
;
}
profile
.
guid
=
newID
;
this
.
_store
.
saveSoon
(
)
;
}
_getSyncMetaData
(
record
forceCreate
=
false
)
{
if
(
!
record
.
_sync
&
&
forceCreate
)
{
record
.
_sync
=
{
changeCounter
:
1
lastSyncedFields
:
{
}
}
;
this
.
_store
.
saveSoon
(
)
;
}
return
record
.
_sync
;
}
findDuplicateGUID
(
remoteRecord
)
{
if
(
!
remoteRecord
.
guid
)
{
throw
new
Error
(
"
Record
missing
GUID
"
)
;
}
this
.
_ensureMatchingVersion
(
remoteRecord
)
;
if
(
remoteRecord
.
deleted
)
{
throw
new
Error
(
"
Tombstones
can
'
t
have
duplicates
"
)
;
}
let
localRecords
=
this
.
_data
;
for
(
let
localRecord
of
localRecords
)
{
if
(
localRecord
.
deleted
)
{
continue
;
}
if
(
localRecord
.
guid
=
=
remoteRecord
.
guid
)
{
throw
new
Error
(
Record
{
remoteRecord
.
guid
}
already
exists
)
;
}
if
(
this
.
_getSyncMetaData
(
localRecord
)
)
{
continue
;
}
let
strippedLocalRecord
=
this
.
_clone
(
localRecord
)
;
this
.
_stripComputedFields
(
strippedLocalRecord
)
;
let
keys
=
new
Set
(
Object
.
keys
(
remoteRecord
)
)
;
for
(
let
key
of
Object
.
keys
(
strippedLocalRecord
)
)
{
keys
.
add
(
key
)
;
}
for
(
let
field
of
INTERNAL_FIELDS
)
{
keys
.
delete
(
field
)
;
}
if
(
!
keys
.
size
)
{
continue
;
}
let
same
=
true
;
for
(
let
key
of
keys
)
{
same
=
key
in
strippedLocalRecord
=
=
key
in
remoteRecord
&
&
strippedLocalRecord
[
key
]
=
=
remoteRecord
[
key
]
;
if
(
!
same
)
{
break
;
}
}
if
(
same
)
{
return
strippedLocalRecord
.
guid
;
}
}
return
null
;
}
_clone
(
record
)
{
return
Object
.
assign
(
{
}
record
)
;
}
_cloneAndCleanUp
(
record
)
{
let
result
=
{
}
;
for
(
let
key
in
record
)
{
if
(
!
key
.
startsWith
(
"
_
"
)
&
&
record
[
key
]
!
=
=
"
"
)
{
result
[
key
]
=
record
[
key
]
;
}
}
return
result
;
}
_findByGUID
(
guid
{
includeDeleted
=
false
}
=
{
}
)
{
let
found
=
this
.
_findIndexByGUID
(
guid
{
includeDeleted
}
)
;
return
found
<
0
?
undefined
:
this
.
_data
[
found
]
;
}
_findIndexByGUID
(
guid
{
includeDeleted
=
false
}
=
{
}
)
{
return
this
.
_data
.
findIndex
(
record
=
>
{
return
record
.
guid
=
=
guid
&
&
(
!
record
.
deleted
|
|
includeDeleted
)
;
}
)
;
}
_migrateRecord
(
record
)
{
let
hasChanges
=
false
;
if
(
record
.
deleted
)
{
return
hasChanges
;
}
if
(
!
record
.
version
|
|
isNaN
(
record
.
version
)
|
|
record
.
version
<
1
)
{
this
.
log
.
warn
(
"
Invalid
record
version
:
"
record
.
version
)
;
record
.
version
=
0
;
}
if
(
record
.
version
<
this
.
version
)
{
hasChanges
=
true
;
record
.
version
=
this
.
version
;
this
.
_stripComputedFields
(
record
)
;
}
hasChanges
|
=
this
.
computeFields
(
record
)
;
return
hasChanges
;
}
_normalizeRecord
(
record
preserveEmptyFields
=
false
)
{
this
.
_normalizeFields
(
record
)
;
for
(
let
key
in
record
)
{
if
(
!
this
.
VALID_FIELDS
.
includes
(
key
)
)
{
throw
new
Error
(
"
{
key
}
"
is
not
a
valid
field
.
)
;
}
if
(
typeof
record
[
key
]
!
=
=
"
string
"
&
&
typeof
record
[
key
]
!
=
=
"
number
"
)
{
throw
new
Error
(
"
{
key
}
"
contains
invalid
data
type
:
{
typeof
record
[
key
]
}
)
;
}
if
(
!
preserveEmptyFields
&
&
record
[
key
]
=
=
=
"
"
)
{
delete
record
[
key
]
;
}
}
if
(
!
Object
.
keys
(
record
)
.
length
)
{
throw
new
Error
(
"
Record
contains
no
valid
field
.
"
)
;
}
}
mergeToStorage
(
targetRecord
strict
=
false
)
{
let
mergedGUIDs
=
[
]
;
for
(
let
record
of
this
.
_data
)
{
if
(
!
record
.
deleted
&
&
this
.
mergeIfPossible
(
record
.
guid
targetRecord
strict
)
)
{
mergedGUIDs
.
push
(
record
.
guid
)
;
}
}
this
.
log
.
debug
(
"
Existing
records
matching
and
merging
count
is
"
mergedGUIDs
.
length
)
;
return
mergedGUIDs
;
}
removeAll
(
{
sourceSync
=
false
}
=
{
}
)
{
this
.
_store
.
data
[
this
.
_collectionName
]
=
[
]
;
this
.
_store
.
saveSoon
(
)
;
Services
.
obs
.
notifyObservers
(
{
wrappedJSObject
:
{
sourceSync
collectionName
:
this
.
_collectionName
}
}
"
formautofill
-
storage
-
changed
"
"
removeAll
"
)
;
}
_stripComputedFields
(
record
)
{
this
.
VALID_COMPUTED_FIELDS
.
forEach
(
field
=
>
delete
record
[
field
]
)
;
}
_recordReadProcessor
(
record
)
{
}
computeFields
(
record
)
{
}
_normalizeFields
(
partialRecord
)
{
}
_validateFields
(
record
)
{
}
mergeIfPossible
(
guid
record
strict
)
{
}
}
class
Addresses
extends
AutofillRecords
{
constructor
(
store
)
{
super
(
store
"
addresses
"
VALID_ADDRESS_FIELDS
VALID_ADDRESS_COMPUTED_FIELDS
ADDRESS_SCHEMA_VERSION
)
;
}
_recordReadProcessor
(
address
)
{
if
(
address
.
country
&
&
!
FormAutofill
.
supportedCountries
.
includes
(
address
.
country
)
)
{
delete
address
.
country
;
delete
address
[
"
country
-
name
"
]
;
}
}
computeFields
(
address
)
{
let
hasNewComputedFields
=
false
;
if
(
address
.
deleted
)
{
return
hasNewComputedFields
;
}
if
(
!
(
"
name
"
in
address
)
)
{
let
name
=
FormAutofillNameUtils
.
joinNameParts
(
{
given
:
address
[
"
given
-
name
"
]
middle
:
address
[
"
additional
-
name
"
]
family
:
address
[
"
family
-
name
"
]
}
)
;
address
.
name
=
name
;
hasNewComputedFields
=
true
;
}
if
(
!
(
"
address
-
line1
"
in
address
)
)
{
let
streetAddress
=
[
]
;
if
(
address
[
"
street
-
address
"
]
)
{
streetAddress
=
address
[
"
street
-
address
"
]
.
split
(
"
\
n
"
)
.
map
(
s
=
>
s
.
trim
(
)
)
;
}
for
(
let
i
=
0
;
i
<
3
;
i
+
+
)
{
address
[
"
address
-
line
"
+
(
i
+
1
)
]
=
streetAddress
[
i
]
|
|
"
"
;
}
if
(
streetAddress
.
length
>
3
)
{
address
[
"
address
-
line3
"
]
=
FormAutofillUtils
.
toOneLineAddress
(
streetAddress
.
splice
(
2
)
)
;
}
hasNewComputedFields
=
true
;
}
if
(
!
(
"
country
-
name
"
in
address
)
)
{
if
(
address
.
country
)
{
try
{
address
[
"
country
-
name
"
]
=
Services
.
intl
.
getRegionDisplayNames
(
undefined
[
address
.
country
]
)
;
}
catch
(
e
)
{
address
[
"
country
-
name
"
]
=
"
"
;
}
}
else
{
address
[
"
country
-
name
"
]
=
"
"
;
}
hasNewComputedFields
=
true
;
}
if
(
!
(
"
tel
-
national
"
in
address
)
)
{
if
(
address
.
tel
)
{
let
tel
=
PhoneNumber
.
Parse
(
address
.
tel
address
.
country
|
|
FormAutofill
.
DEFAULT_REGION
)
;
if
(
tel
)
{
if
(
tel
.
countryCode
)
{
address
[
"
tel
-
country
-
code
"
]
=
tel
.
countryCode
;
}
if
(
tel
.
nationalNumber
)
{
address
[
"
tel
-
national
"
]
=
tel
.
nationalNumber
;
}
if
(
tel
.
nationalNumber
&
&
tel
.
countryCode
=
=
"
+
1
"
)
{
let
telComponents
=
tel
.
nationalNumber
.
match
(
/
(
\
d
{
3
}
)
(
(
\
d
{
3
}
)
(
\
d
{
4
}
)
)
/
)
;
if
(
telComponents
)
{
address
[
"
tel
-
area
-
code
"
]
=
telComponents
[
1
]
;
address
[
"
tel
-
local
"
]
=
telComponents
[
2
]
;
address
[
"
tel
-
local
-
prefix
"
]
=
telComponents
[
3
]
;
address
[
"
tel
-
local
-
suffix
"
]
=
telComponents
[
4
]
;
}
}
}
else
{
address
[
"
tel
-
national
"
]
=
address
.
tel
;
}
}
TEL_COMPONENTS
.
forEach
(
c
=
>
{
address
[
c
]
=
address
[
c
]
|
|
"
"
;
}
)
;
}
return
hasNewComputedFields
;
}
_normalizeFields
(
address
)
{
this
.
_normalizeName
(
address
)
;
this
.
_normalizeAddress
(
address
)
;
this
.
_normalizeCountry
(
address
)
;
this
.
_normalizeTel
(
address
)
;
}
_normalizeName
(
address
)
{
if
(
address
.
name
)
{
let
nameParts
=
FormAutofillNameUtils
.
splitName
(
address
.
name
)
;
if
(
!
address
[
"
given
-
name
"
]
&
&
nameParts
.
given
)
{
address
[
"
given
-
name
"
]
=
nameParts
.
given
;
}
if
(
!
address
[
"
additional
-
name
"
]
&
&
nameParts
.
middle
)
{
address
[
"
additional
-
name
"
]
=
nameParts
.
middle
;
}
if
(
!
address
[
"
family
-
name
"
]
&
&
nameParts
.
family
)
{
address
[
"
family
-
name
"
]
=
nameParts
.
family
;
}
}
delete
address
.
name
;
}
_normalizeAddress
(
address
)
{
if
(
STREET_ADDRESS_COMPONENTS
.
some
(
c
=
>
!
!
address
[
c
]
)
)
{
if
(
!
address
[
"
address
-
line1
"
]
&
&
address
[
"
street
-
address
"
]
&
&
!
address
[
"
street
-
address
"
]
.
includes
(
"
\
n
"
)
)
{
address
[
"
address
-
line1
"
]
=
address
[
"
street
-
address
"
]
;
delete
address
[
"
street
-
address
"
]
;
}
if
(
!
address
[
"
street
-
address
"
]
)
{
address
[
"
street
-
address
"
]
=
STREET_ADDRESS_COMPONENTS
.
map
(
c
=
>
address
[
c
]
)
.
join
(
"
\
n
"
)
.
replace
(
/
\
n
+
/
"
"
)
;
}
}
STREET_ADDRESS_COMPONENTS
.
forEach
(
c
=
>
delete
address
[
c
]
)
;
}
_normalizeCountry
(
address
)
{
let
country
;
if
(
address
.
country
)
{
country
=
address
.
country
.
toUpperCase
(
)
;
}
else
if
(
address
[
"
country
-
name
"
]
)
{
country
=
FormAutofillUtils
.
identifyCountryCode
(
address
[
"
country
-
name
"
]
)
;
}
let
hasLocalizedName
=
false
;
try
{
if
(
country
)
{
let
localizedName
=
Services
.
intl
.
getRegionDisplayNames
(
undefined
[
country
]
)
;
hasLocalizedName
=
localizedName
!
=
country
;
}
}
catch
(
e
)
{
}
if
(
country
&
&
hasLocalizedName
)
{
address
.
country
=
country
;
}
else
{
delete
address
.
country
;
}
delete
address
[
"
country
-
name
"
]
;
}
_normalizeTel
(
address
)
{
if
(
address
.
tel
|
|
TEL_COMPONENTS
.
some
(
c
=
>
!
!
address
[
c
]
)
)
{
FormAutofillUtils
.
compressTel
(
address
)
;
let
possibleRegion
=
address
.
country
|
|
FormAutofill
.
DEFAULT_REGION
;
let
tel
=
PhoneNumber
.
Parse
(
address
.
tel
possibleRegion
)
;
if
(
tel
&
&
tel
.
internationalNumber
)
{
address
.
tel
=
tel
.
internationalNumber
;
}
}
TEL_COMPONENTS
.
forEach
(
c
=
>
delete
address
[
c
]
)
;
}
mergeIfPossible
(
guid
address
strict
)
{
this
.
log
.
debug
(
"
mergeIfPossible
:
"
guid
address
)
;
let
addressFound
=
this
.
_findByGUID
(
guid
)
;
if
(
!
addressFound
)
{
throw
new
Error
(
"
No
matching
address
.
"
)
;
}
let
addressToMerge
=
this
.
_clone
(
address
)
;
this
.
_normalizeRecord
(
addressToMerge
strict
)
;
let
hasMatchingField
=
false
;
for
(
let
field
of
this
.
VALID_FIELDS
)
{
let
existingField
=
addressFound
[
field
]
;
let
incomingField
=
addressToMerge
[
field
]
;
if
(
incomingField
!
=
=
undefined
&
&
existingField
!
=
=
undefined
)
{
if
(
incomingField
!
=
existingField
)
{
if
(
field
=
=
"
street
-
address
"
&
&
FormAutofillUtils
.
toOneLineAddress
(
existingField
)
=
=
FormAutofillUtils
.
toOneLineAddress
(
incomingField
)
)
{
if
(
existingField
.
split
(
"
\
n
"
)
.
length
>
=
incomingField
.
split
(
"
\
n
"
)
.
length
)
{
addressToMerge
[
field
]
=
existingField
;
}
}
else
{
this
.
log
.
debug
(
"
Conflicts
:
field
"
field
"
has
different
value
.
"
)
;
return
false
;
}
}
hasMatchingField
=
true
;
}
}
if
(
!
hasMatchingField
)
{
this
.
log
.
debug
(
"
Unable
to
merge
because
no
field
has
the
same
value
"
)
;
return
false
;
}
let
noNeedToUpdate
=
this
.
VALID_FIELDS
.
every
(
(
field
)
=
>
{
if
(
addressFound
[
field
]
=
=
=
undefined
)
{
return
!
addressToMerge
[
field
]
;
}
return
(
addressToMerge
[
field
]
=
=
=
undefined
)
|
|
(
addressFound
[
field
]
=
=
=
addressToMerge
[
field
]
)
;
}
)
;
if
(
noNeedToUpdate
)
{
return
true
;
}
this
.
update
(
guid
addressToMerge
true
)
;
return
true
;
}
}
class
CreditCards
extends
AutofillRecords
{
constructor
(
store
)
{
super
(
store
"
creditCards
"
VALID_CREDIT_CARD_FIELDS
VALID_CREDIT_CARD_COMPUTED_FIELDS
CREDIT_CARD_SCHEMA_VERSION
)
;
}
computeFields
(
creditCard
)
{
let
hasNewComputedFields
=
false
;
if
(
creditCard
.
deleted
)
{
return
hasNewComputedFields
;
}
if
(
!
(
"
cc
-
given
-
name
"
in
creditCard
)
)
{
let
nameParts
=
FormAutofillNameUtils
.
splitName
(
creditCard
[
"
cc
-
name
"
]
)
;
creditCard
[
"
cc
-
given
-
name
"
]
=
nameParts
.
given
;
creditCard
[
"
cc
-
additional
-
name
"
]
=
nameParts
.
middle
;
creditCard
[
"
cc
-
family
-
name
"
]
=
nameParts
.
family
;
hasNewComputedFields
=
true
;
}
if
(
!
(
"
cc
-
exp
"
in
creditCard
)
)
{
if
(
creditCard
[
"
cc
-
exp
-
month
"
]
&
&
creditCard
[
"
cc
-
exp
-
year
"
]
)
{
creditCard
[
"
cc
-
exp
"
]
=
String
(
creditCard
[
"
cc
-
exp
-
year
"
]
)
+
"
-
"
+
String
(
creditCard
[
"
cc
-
exp
-
month
"
]
)
.
padStart
(
2
"
0
"
)
;
}
else
{
creditCard
[
"
cc
-
exp
"
]
=
"
"
;
}
hasNewComputedFields
=
true
;
}
if
(
!
(
"
cc
-
number
-
encrypted
"
in
creditCard
)
)
{
if
(
"
cc
-
number
"
in
creditCard
)
{
let
ccNumber
=
creditCard
[
"
cc
-
number
"
]
;
creditCard
[
"
cc
-
number
"
]
=
CreditCard
.
getLongMaskedNumber
(
ccNumber
)
;
creditCard
[
"
cc
-
number
-
encrypted
"
]
=
MasterPassword
.
encryptSync
(
ccNumber
)
;
}
else
{
creditCard
[
"
cc
-
number
-
encrypted
"
]
=
"
"
;
}
}
return
hasNewComputedFields
;
}
_stripComputedFields
(
creditCard
)
{
if
(
creditCard
[
"
cc
-
number
-
encrypted
"
]
)
{
creditCard
[
"
cc
-
number
"
]
=
MasterPassword
.
decryptSync
(
creditCard
[
"
cc
-
number
-
encrypted
"
]
)
;
}
super
.
_stripComputedFields
(
creditCard
)
;
}
_normalizeFields
(
creditCard
)
{
this
.
_normalizeCCName
(
creditCard
)
;
this
.
_normalizeCCNumber
(
creditCard
)
;
this
.
_normalizeCCExpirationDate
(
creditCard
)
;
}
_normalizeCCName
(
creditCard
)
{
if
(
creditCard
[
"
cc
-
given
-
name
"
]
|
|
creditCard
[
"
cc
-
additional
-
name
"
]
|
|
creditCard
[
"
cc
-
family
-
name
"
]
)
{
if
(
!
creditCard
[
"
cc
-
name
"
]
)
{
creditCard
[
"
cc
-
name
"
]
=
FormAutofillNameUtils
.
joinNameParts
(
{
given
:
creditCard
[
"
cc
-
given
-
name
"
]
middle
:
creditCard
[
"
cc
-
additional
-
name
"
]
family
:
creditCard
[
"
cc
-
family
-
name
"
]
}
)
;
}
}
delete
creditCard
[
"
cc
-
given
-
name
"
]
;
delete
creditCard
[
"
cc
-
additional
-
name
"
]
;
delete
creditCard
[
"
cc
-
family
-
name
"
]
;
}
_normalizeCCNumber
(
creditCard
)
{
if
(
creditCard
[
"
cc
-
number
"
]
)
{
let
card
=
new
CreditCard
(
{
number
:
creditCard
[
"
cc
-
number
"
]
}
)
;
creditCard
[
"
cc
-
number
"
]
=
card
.
number
;
if
(
!
card
.
isValidNumber
(
)
)
{
delete
creditCard
[
"
cc
-
number
"
]
;
}
}
}
_normalizeCCExpirationDate
(
creditCard
)
{
let
card
=
new
CreditCard
(
{
expirationMonth
:
creditCard
[
"
cc
-
exp
-
month
"
]
expirationYear
:
creditCard
[
"
cc
-
exp
-
year
"
]
expirationString
:
creditCard
[
"
cc
-
exp
"
]
}
)
;
if
(
card
.
expirationMonth
)
{
creditCard
[
"
cc
-
exp
-
month
"
]
=
card
.
expirationMonth
;
}
else
{
delete
creditCard
[
"
cc
-
exp
-
month
"
]
;
}
if
(
card
.
expirationYear
)
{
creditCard
[
"
cc
-
exp
-
year
"
]
=
card
.
expirationYear
;
}
else
{
delete
creditCard
[
"
cc
-
exp
-
year
"
]
;
}
delete
creditCard
[
"
cc
-
exp
"
]
;
}
_validateFields
(
creditCard
)
{
if
(
!
creditCard
[
"
cc
-
number
"
]
)
{
throw
new
Error
(
"
Missing
/
invalid
cc
-
number
"
)
;
}
}
getDuplicateGuid
(
targetCreditCard
)
{
let
clonedTargetCreditCard
=
this
.
_clone
(
targetCreditCard
)
;
this
.
_normalizeRecord
(
clonedTargetCreditCard
)
;
for
(
let
creditCard
of
this
.
_data
)
{
let
isDuplicate
=
this
.
VALID_FIELDS
.
every
(
field
=
>
{
if
(
!
clonedTargetCreditCard
[
field
]
)
{
return
!
creditCard
[
field
]
;
}
if
(
field
=
=
"
cc
-
number
"
&
&
creditCard
[
field
]
)
{
if
(
MasterPassword
.
isEnabled
)
{
return
CreditCard
.
getLongMaskedNumber
(
clonedTargetCreditCard
[
field
]
)
=
=
creditCard
[
field
]
;
}
return
clonedTargetCreditCard
[
field
]
=
=
MasterPassword
.
decryptSync
(
creditCard
[
"
cc
-
number
-
encrypted
"
]
)
;
}
return
clonedTargetCreditCard
[
field
]
=
=
creditCard
[
field
]
;
}
)
;
if
(
isDuplicate
)
{
return
creditCard
.
guid
;
}
}
return
null
;
}
mergeIfPossible
(
guid
creditCard
)
{
this
.
log
.
debug
(
"
mergeIfPossible
:
"
guid
creditCard
)
;
let
creditCardFound
=
this
.
get
(
guid
{
rawData
:
true
}
)
;
if
(
!
creditCardFound
)
{
throw
new
Error
(
"
No
matching
credit
card
.
"
)
;
}
let
creditCardToMerge
=
this
.
_clone
(
creditCard
)
;
this
.
_normalizeRecord
(
creditCardToMerge
)
;
for
(
let
field
of
this
.
VALID_FIELDS
)
{
let
existingField
=
creditCardFound
[
field
]
;
if
(
field
=
=
"
cc
-
number
"
&
&
(
!
existingField
|
|
!
creditCardToMerge
[
field
]
)
)
{
return
false
;
}
if
(
!
creditCardToMerge
[
field
]
&
&
typeof
(
existingField
)
!
=
"
undefined
"
)
{
creditCardToMerge
[
field
]
=
existingField
;
}
let
incomingField
=
creditCardToMerge
[
field
]
;
if
(
incomingField
&
&
existingField
)
{
if
(
incomingField
!
=
existingField
)
{
this
.
log
.
debug
(
"
Conflicts
:
field
"
field
"
has
different
value
.
"
)
;
return
false
;
}
}
}
let
exactlyMatch
=
this
.
VALID_FIELDS
.
every
(
(
field
)
=
>
creditCardFound
[
field
]
=
=
=
creditCardToMerge
[
field
]
)
;
if
(
exactlyMatch
)
{
return
true
;
}
this
.
update
(
guid
creditCardToMerge
true
)
;
return
true
;
}
}
function
FormAutofillStorage
(
path
)
{
this
.
_path
=
path
;
this
.
_initializePromise
=
null
;
this
.
INTERNAL_FIELDS
=
INTERNAL_FIELDS
;
}
FormAutofillStorage
.
prototype
=
{
get
version
(
)
{
return
STORAGE_SCHEMA_VERSION
;
}
get
addresses
(
)
{
if
(
!
this
.
_addresses
)
{
this
.
_store
.
ensureDataReady
(
)
;
this
.
_addresses
=
new
Addresses
(
this
.
_store
)
;
}
return
this
.
_addresses
;
}
get
creditCards
(
)
{
if
(
!
this
.
_creditCards
)
{
this
.
_store
.
ensureDataReady
(
)
;
this
.
_creditCards
=
new
CreditCards
(
this
.
_store
)
;
}
return
this
.
_creditCards
;
}
initialize
(
)
{
if
(
!
this
.
_initializePromise
)
{
this
.
_store
=
new
JSONFile
(
{
path
:
this
.
_path
dataPostProcessor
:
this
.
_dataPostProcessor
.
bind
(
this
)
}
)
;
this
.
_initializePromise
=
this
.
_store
.
load
(
)
;
}
return
this
.
_initializePromise
;
}
_dataPostProcessor
(
data
)
{
data
.
version
=
this
.
version
;
if
(
!
data
.
addresses
)
{
data
.
addresses
=
[
]
;
}
if
(
!
data
.
creditCards
)
{
data
.
creditCards
=
[
]
;
}
return
data
;
}
_saveImmediately
(
)
{
return
this
.
_store
.
_save
(
)
;
}
}
;
this
.
formAutofillStorage
=
new
FormAutofillStorage
(
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
PROFILE_JSON_FILE_NAME
)
)
;
