"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
FormAutofillHeuristics
"
]
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
formautofill
/
FormAutofillUtils
.
jsm
"
)
;
this
.
log
=
null
;
FormAutofillUtils
.
defineLazyLogGetter
(
this
this
.
EXPORTED_SYMBOLS
[
0
]
)
;
const
PREF_HEURISTICS_ENABLED
=
"
extensions
.
formautofill
.
heuristics
.
enabled
"
;
class
FieldScanner
{
constructor
(
elements
)
{
this
.
_elementsWeakRef
=
Cu
.
getWeakReference
(
elements
)
;
this
.
fieldDetails
=
[
]
;
this
.
_parsingIndex
=
0
;
}
get
_elements
(
)
{
return
this
.
_elementsWeakRef
.
get
(
)
;
}
get
parsingIndex
(
)
{
return
this
.
_parsingIndex
;
}
set
parsingIndex
(
index
)
{
if
(
index
>
this
.
fieldDetails
.
length
)
{
throw
new
Error
(
"
The
parsing
index
is
out
of
range
.
"
)
;
}
this
.
_parsingIndex
=
index
;
}
getFieldDetailByIndex
(
index
)
{
if
(
index
>
=
this
.
_elements
.
length
)
{
throw
new
Error
(
The
index
{
index
}
is
out
of
range
.
(
{
this
.
_elements
.
length
}
)
)
;
}
if
(
index
<
this
.
fieldDetails
.
length
)
{
return
this
.
fieldDetails
[
index
]
;
}
for
(
let
i
=
this
.
fieldDetails
.
length
;
i
<
(
index
+
1
)
;
i
+
+
)
{
this
.
pushDetail
(
)
;
}
return
this
.
fieldDetails
[
index
]
;
}
get
parsingFinished
(
)
{
return
this
.
parsingIndex
>
=
this
.
_elements
.
length
;
}
pushDetail
(
)
{
let
elementIndex
=
this
.
fieldDetails
.
length
;
if
(
elementIndex
>
=
this
.
_elements
.
length
)
{
throw
new
Error
(
"
Try
to
push
the
non
-
existing
element
info
.
"
)
;
}
let
element
=
this
.
_elements
[
elementIndex
]
;
let
info
=
FormAutofillHeuristics
.
getInfo
(
element
)
;
if
(
!
info
)
{
info
=
{
}
;
}
let
fieldInfo
=
{
section
:
info
.
section
addressType
:
info
.
addressType
contactType
:
info
.
contactType
fieldName
:
info
.
fieldName
elementWeakRef
:
Cu
.
getWeakReference
(
element
)
}
;
if
(
info
.
_reason
)
{
fieldInfo
.
_reason
=
info
.
_reason
;
}
if
(
this
.
findSameField
(
info
)
!
=
-
1
)
{
log
.
debug
(
"
Not
collecting
a
field
matching
another
with
the
same
info
:
"
info
)
;
fieldInfo
.
_duplicated
=
true
;
}
this
.
fieldDetails
.
push
(
fieldInfo
)
;
}
updateFieldName
(
index
fieldName
)
{
if
(
index
>
=
this
.
fieldDetails
.
length
)
{
throw
new
Error
(
"
Try
to
update
the
non
-
existing
field
detail
.
"
)
;
}
this
.
fieldDetails
[
index
]
.
fieldName
=
fieldName
;
delete
this
.
fieldDetails
[
index
]
.
_duplicated
;
let
indexSame
=
this
.
findSameField
(
this
.
fieldDetails
[
index
]
)
;
if
(
indexSame
!
=
index
&
&
indexSame
!
=
-
1
)
{
this
.
fieldDetails
[
index
]
.
_duplicated
=
true
;
}
}
findSameField
(
info
)
{
return
this
.
fieldDetails
.
findIndex
(
f
=
>
f
.
section
=
=
info
.
section
&
&
f
.
addressType
=
=
info
.
addressType
&
&
f
.
contactType
=
=
info
.
contactType
&
&
f
.
fieldName
=
=
info
.
fieldName
)
;
}
get
trimmedFieldDetail
(
)
{
return
this
.
fieldDetails
.
filter
(
f
=
>
f
.
fieldName
&
&
!
f
.
_duplicated
)
;
}
elementExisting
(
index
)
{
return
index
<
this
.
_elements
.
length
;
}
}
this
.
FormAutofillHeuristics
=
{
RULES
:
null
_parsePhoneFields
(
fieldScanner
)
{
let
matchingResult
;
const
GRAMMARS
=
this
.
PHONE_FIELD_GRAMMARS
;
for
(
let
i
=
0
;
i
<
GRAMMARS
.
length
;
i
+
+
)
{
let
detailStart
=
fieldScanner
.
parsingIndex
;
let
ruleStart
=
i
;
for
(
;
i
<
GRAMMARS
.
length
&
&
GRAMMARS
[
i
]
[
0
]
&
&
fieldScanner
.
elementExisting
(
detailStart
)
;
i
+
+
detailStart
+
+
)
{
let
detail
=
fieldScanner
.
getFieldDetailByIndex
(
detailStart
)
;
if
(
!
detail
|
|
GRAMMARS
[
i
]
[
0
]
!
=
detail
.
fieldName
|
|
detail
.
_reason
=
=
"
autocomplete
"
)
{
break
;
}
let
element
=
detail
.
elementWeakRef
.
get
(
)
;
if
(
!
element
)
{
break
;
}
if
(
GRAMMARS
[
i
]
[
2
]
&
&
(
!
element
.
maxLength
|
|
GRAMMARS
[
i
]
[
2
]
<
element
.
maxLength
)
)
{
break
;
}
}
if
(
i
>
=
GRAMMARS
.
length
)
{
break
;
}
if
(
!
GRAMMARS
[
i
]
[
0
]
)
{
matchingResult
=
{
ruleFrom
:
ruleStart
ruleTo
:
i
}
;
break
;
}
for
(
;
i
<
GRAMMARS
.
length
;
i
+
+
)
{
if
(
!
GRAMMARS
[
i
]
[
0
]
)
{
break
;
}
}
}
let
parsedField
=
false
;
if
(
matchingResult
)
{
let
{
ruleFrom
ruleTo
}
=
matchingResult
;
let
detailStart
=
fieldScanner
.
parsingIndex
;
for
(
let
i
=
ruleFrom
;
i
<
ruleTo
;
i
+
+
)
{
fieldScanner
.
updateFieldName
(
detailStart
GRAMMARS
[
i
]
[
1
]
)
;
fieldScanner
.
parsingIndex
+
+
;
detailStart
+
+
;
parsedField
=
true
;
}
}
if
(
fieldScanner
.
parsingFinished
)
{
return
parsedField
;
}
let
nextField
=
fieldScanner
.
getFieldDetailByIndex
(
fieldScanner
.
parsingIndex
)
;
if
(
nextField
&
&
nextField
.
fieldName
=
=
"
tel
-
extension
"
)
{
fieldScanner
.
parsingIndex
+
+
;
parsedField
=
true
;
}
return
parsedField
;
}
_parseAddressFields
(
fieldScanner
)
{
let
parsedFields
=
false
;
let
addressLines
=
[
"
address
-
line1
"
"
address
-
line2
"
"
address
-
line3
"
]
;
for
(
let
i
=
0
;
!
fieldScanner
.
parsingFinished
&
&
i
<
addressLines
.
length
;
i
+
+
)
{
let
detail
=
fieldScanner
.
getFieldDetailByIndex
(
fieldScanner
.
parsingIndex
)
;
if
(
!
detail
|
|
!
addressLines
.
includes
(
detail
.
fieldName
)
)
{
break
;
}
fieldScanner
.
updateFieldName
(
fieldScanner
.
parsingIndex
addressLines
[
i
]
)
;
fieldScanner
.
parsingIndex
+
+
;
parsedFields
=
true
;
}
return
parsedFields
;
}
getFormInfo
(
form
allowDuplicates
=
false
)
{
if
(
form
.
autocomplete
=
=
"
off
"
|
|
form
.
elements
.
length
<
=
0
)
{
return
[
]
;
}
let
fieldScanner
=
new
FieldScanner
(
form
.
elements
)
;
while
(
!
fieldScanner
.
parsingFinished
)
{
let
parsedPhoneFields
=
this
.
_parsePhoneFields
(
fieldScanner
)
;
let
parsedAddressFields
=
this
.
_parseAddressFields
(
fieldScanner
)
;
if
(
!
parsedPhoneFields
&
&
!
parsedAddressFields
)
{
fieldScanner
.
parsingIndex
+
+
;
}
}
if
(
allowDuplicates
)
{
return
fieldScanner
.
fieldDetails
;
}
else
{
return
fieldScanner
.
trimmedFieldDetail
;
}
}
getInfo
(
element
)
{
if
(
!
FormAutofillUtils
.
isFieldEligibleForAutofill
(
element
)
)
{
return
null
;
}
let
info
=
element
.
getAutocompleteInfo
(
)
;
if
(
info
&
&
info
.
fieldName
&
&
info
.
fieldName
!
=
"
on
"
)
{
info
.
_reason
=
"
autocomplete
"
;
return
info
;
}
if
(
!
this
.
_prefEnabled
)
{
return
null
;
}
if
(
element
.
type
=
=
"
email
"
)
{
return
{
fieldName
:
"
email
"
section
:
"
"
addressType
:
"
"
contactType
:
"
"
}
;
}
let
regexps
=
Object
.
keys
(
this
.
RULES
)
;
let
labelStrings
;
let
getElementStrings
=
{
}
;
getElementStrings
[
Symbol
.
iterator
]
=
function
*
(
)
{
yield
element
.
id
;
yield
element
.
name
;
if
(
!
labelStrings
)
{
labelStrings
=
[
]
;
let
labels
=
FormAutofillUtils
.
findLabelElements
(
element
)
;
for
(
let
label
of
labels
)
{
labelStrings
.
push
(
.
.
.
FormAutofillUtils
.
extractLabelStrings
(
label
)
)
;
}
}
yield
*
labelStrings
;
}
;
for
(
let
regexp
of
regexps
)
{
for
(
let
string
of
getElementStrings
)
{
if
(
[
"
address
-
level1
"
"
address
-
line2
"
"
address
-
line3
"
]
.
includes
(
regexp
)
)
{
string
=
string
.
toLowerCase
(
)
.
split
(
"
united
state
"
)
.
join
(
"
"
)
;
}
if
(
this
.
RULES
[
regexp
]
.
test
(
string
)
)
{
return
{
fieldName
:
regexp
section
:
"
"
addressType
:
"
"
contactType
:
"
"
}
;
}
}
}
return
null
;
}
PHONE_FIELD_GRAMMARS
:
[
[
"
tel
"
"
tel
-
country
-
code
"
3
]
[
"
tel
"
"
tel
-
area
-
code
"
3
]
[
"
tel
"
"
tel
-
local
-
prefix
"
3
]
[
"
tel
"
"
tel
-
local
-
suffix
"
4
]
[
null
null
0
]
[
"
tel
"
"
tel
-
area
-
code
"
0
]
[
"
tel
"
"
tel
-
local
-
prefix
"
3
]
[
"
tel
"
"
tel
-
local
-
suffix
"
4
]
[
null
null
0
]
]
}
;
XPCOMUtils
.
defineLazyGetter
(
this
.
FormAutofillHeuristics
"
RULES
"
(
)
=
>
{
let
sandbox
=
{
}
;
let
scriptLoader
=
Cc
[
"
mozilla
.
org
/
moz
/
jssubscript
-
loader
;
1
"
]
.
getService
(
Ci
.
mozIJSSubScriptLoader
)
;
const
HEURISTICS_REGEXP
=
"
chrome
:
/
/
formautofill
/
content
/
heuristicsRegexp
.
js
"
;
scriptLoader
.
loadSubScript
(
HEURISTICS_REGEXP
sandbox
"
utf
-
8
"
)
;
return
sandbox
.
HeuristicsRegExp
.
RULES
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
.
FormAutofillHeuristics
"
_prefEnabled
"
(
)
=
>
{
return
Services
.
prefs
.
getBoolPref
(
PREF_HEURISTICS_ENABLED
)
;
}
)
;
Services
.
prefs
.
addObserver
(
PREF_HEURISTICS_ENABLED
(
)
=
>
{
this
.
FormAutofillHeuristics
.
_prefEnabled
=
Services
.
prefs
.
getBoolPref
(
PREF_HEURISTICS_ENABLED
)
;
}
)
;
