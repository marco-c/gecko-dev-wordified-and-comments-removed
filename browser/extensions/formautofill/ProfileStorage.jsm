"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
profileStorage
"
]
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
formautofill
/
FormAutofillUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
JSONFile
"
"
resource
:
/
/
gre
/
modules
/
JSONFile
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
FormAutofillNameUtils
"
"
resource
:
/
/
formautofill
/
FormAutofillNameUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
gUUIDGenerator
"
"
mozilla
.
org
/
uuid
-
generator
;
1
"
"
nsIUUIDGenerator
"
)
;
this
.
log
=
null
;
FormAutofillUtils
.
defineLazyLogGetter
(
this
this
.
EXPORTED_SYMBOLS
[
0
]
)
;
const
PROFILE_JSON_FILE_NAME
=
"
autofill
-
profiles
.
json
"
;
const
SCHEMA_VERSION
=
1
;
const
VALID_FIELDS
=
[
"
given
-
name
"
"
additional
-
name
"
"
family
-
name
"
"
organization
"
"
street
-
address
"
"
address
-
level2
"
"
address
-
level1
"
"
postal
-
code
"
"
country
"
"
tel
"
"
email
"
]
;
function
ProfileStorage
(
path
)
{
this
.
_path
=
path
;
this
.
_initializePromise
=
null
;
}
ProfileStorage
.
prototype
=
{
INTERNAL_FIELDS
:
[
"
guid
"
"
timeCreated
"
"
timeLastUsed
"
"
timeLastModified
"
"
timesUsed
"
]
initialize
(
)
{
if
(
!
this
.
_initializePromise
)
{
this
.
_store
=
new
JSONFile
(
{
path
:
this
.
_path
dataPostProcessor
:
this
.
_dataPostProcessor
.
bind
(
this
)
}
)
;
this
.
_initializePromise
=
this
.
_store
.
load
(
)
;
}
return
this
.
_initializePromise
;
}
add
(
address
)
{
log
.
debug
(
"
add
:
"
address
)
;
this
.
_store
.
ensureDataReady
(
)
;
let
addressToSave
=
this
.
_clone
(
address
)
;
this
.
_normalizeAddress
(
addressToSave
)
;
addressToSave
.
guid
=
gUUIDGenerator
.
generateUUID
(
)
.
toString
(
)
.
replace
(
/
[
{
}
-
]
/
g
"
"
)
.
substring
(
0
12
)
;
let
now
=
Date
.
now
(
)
;
addressToSave
.
timeCreated
=
now
;
addressToSave
.
timeLastModified
=
now
;
addressToSave
.
timeLastUsed
=
0
;
addressToSave
.
timesUsed
=
0
;
this
.
_store
.
data
.
addresses
.
push
(
addressToSave
)
;
this
.
_store
.
saveSoon
(
)
;
Services
.
obs
.
notifyObservers
(
null
"
formautofill
-
storage
-
changed
"
"
add
"
)
;
}
update
(
guid
address
)
{
log
.
debug
(
"
update
:
"
guid
address
)
;
this
.
_store
.
ensureDataReady
(
)
;
let
addressFound
=
this
.
_findByGUID
(
guid
)
;
if
(
!
addressFound
)
{
throw
new
Error
(
"
No
matching
record
.
"
)
;
}
let
addressToUpdate
=
this
.
_clone
(
address
)
;
this
.
_normalizeAddress
(
addressToUpdate
)
;
for
(
let
field
of
VALID_FIELDS
)
{
if
(
addressToUpdate
[
field
]
!
=
=
undefined
)
{
addressFound
[
field
]
=
addressToUpdate
[
field
]
;
}
else
{
delete
addressFound
[
field
]
;
}
}
addressFound
.
timeLastModified
=
Date
.
now
(
)
;
this
.
_store
.
saveSoon
(
)
;
Services
.
obs
.
notifyObservers
(
null
"
formautofill
-
storage
-
changed
"
"
update
"
)
;
}
notifyUsed
(
guid
)
{
this
.
_store
.
ensureDataReady
(
)
;
let
addressFound
=
this
.
_findByGUID
(
guid
)
;
if
(
!
addressFound
)
{
throw
new
Error
(
"
No
matching
record
.
"
)
;
}
addressFound
.
timesUsed
+
+
;
addressFound
.
timeLastUsed
=
Date
.
now
(
)
;
this
.
_store
.
saveSoon
(
)
;
Services
.
obs
.
notifyObservers
(
null
"
formautofill
-
storage
-
changed
"
"
notifyUsed
"
)
;
}
remove
(
guid
)
{
log
.
debug
(
"
remove
:
"
guid
)
;
this
.
_store
.
ensureDataReady
(
)
;
this
.
_store
.
data
.
addresses
=
this
.
_store
.
data
.
addresses
.
filter
(
address
=
>
address
.
guid
!
=
guid
)
;
this
.
_store
.
saveSoon
(
)
;
Services
.
obs
.
notifyObservers
(
null
"
formautofill
-
storage
-
changed
"
"
remove
"
)
;
}
get
(
guid
)
{
log
.
debug
(
"
get
:
"
guid
)
;
this
.
_store
.
ensureDataReady
(
)
;
let
addressFound
=
this
.
_findByGUID
(
guid
)
;
if
(
!
addressFound
)
{
throw
new
Error
(
"
No
matching
record
.
"
)
;
}
let
clonedAddress
=
this
.
_clone
(
addressFound
)
;
this
.
_computeFields
(
clonedAddress
)
;
return
clonedAddress
;
}
getAll
(
)
{
log
.
debug
(
"
getAll
"
)
;
this
.
_store
.
ensureDataReady
(
)
;
let
clonedAddresses
=
this
.
_store
.
data
.
addresses
.
map
(
this
.
_clone
)
;
clonedAddresses
.
forEach
(
this
.
_computeFields
)
;
return
clonedAddresses
;
}
getByFilter
(
{
info
searchString
}
)
{
log
.
debug
(
"
getByFilter
:
"
info
searchString
)
;
let
lcSearchString
=
searchString
.
toLowerCase
(
)
;
let
result
=
this
.
getAll
(
)
.
filter
(
address
=
>
{
let
name
=
address
[
info
.
fieldName
]
;
if
(
!
searchString
)
{
return
!
!
name
;
}
return
name
.
toLowerCase
(
)
.
startsWith
(
lcSearchString
)
;
}
)
;
log
.
debug
(
"
getByFilter
:
Returning
"
result
.
length
"
result
(
s
)
"
)
;
return
result
;
}
_clone
(
record
)
{
return
Object
.
assign
(
{
}
record
)
;
}
_findByGUID
(
guid
)
{
return
this
.
_store
.
data
.
addresses
.
find
(
address
=
>
address
.
guid
=
=
guid
)
;
}
_computeFields
(
address
)
{
address
.
name
=
FormAutofillNameUtils
.
joinNameParts
(
{
given
:
address
[
"
given
-
name
"
]
middle
:
address
[
"
additional
-
name
"
]
family
:
address
[
"
family
-
name
"
]
}
)
;
if
(
address
[
"
street
-
address
"
]
)
{
let
streetAddress
=
address
[
"
street
-
address
"
]
.
split
(
"
\
n
"
)
;
for
(
let
i
=
0
;
i
<
3
;
i
+
+
)
{
if
(
streetAddress
[
i
]
)
{
address
[
"
address
-
line
"
+
(
i
+
1
)
]
=
streetAddress
[
i
]
;
}
}
}
}
_normalizeAddressLines
(
address
)
{
if
(
address
[
"
address
-
line1
"
]
|
|
address
[
"
address
-
line2
"
]
|
|
address
[
"
address
-
line3
"
]
)
{
if
(
!
address
[
"
address
-
line1
"
]
&
&
address
[
"
street
-
address
"
]
&
&
!
address
[
"
street
-
address
"
]
.
includes
(
"
\
n
"
)
)
{
address
[
"
address
-
line1
"
]
=
address
[
"
street
-
address
"
]
;
delete
address
[
"
street
-
address
"
]
;
}
let
addressLines
=
[
1
2
3
]
.
map
(
i
=
>
{
let
value
=
address
[
"
address
-
line
"
+
i
]
;
delete
address
[
"
address
-
line
"
+
i
]
;
return
value
;
}
)
;
if
(
!
address
[
"
street
-
address
"
]
)
{
address
[
"
street
-
address
"
]
=
addressLines
.
join
(
"
\
n
"
)
;
}
}
}
_normalizeName
(
address
)
{
if
(
!
address
.
name
)
{
return
;
}
let
nameParts
=
FormAutofillNameUtils
.
splitName
(
address
.
name
)
;
if
(
!
address
[
"
given
-
name
"
]
&
&
nameParts
.
given
)
{
address
[
"
given
-
name
"
]
=
nameParts
.
given
;
}
if
(
!
address
[
"
additional
-
name
"
]
&
&
nameParts
.
middle
)
{
address
[
"
additional
-
name
"
]
=
nameParts
.
middle
;
}
if
(
!
address
[
"
family
-
name
"
]
&
&
nameParts
.
family
)
{
address
[
"
family
-
name
"
]
=
nameParts
.
family
;
}
delete
address
.
name
;
}
_normalizeAddress
(
address
)
{
this
.
_normalizeName
(
address
)
;
this
.
_normalizeAddressLines
(
address
)
;
for
(
let
key
in
address
)
{
if
(
!
VALID_FIELDS
.
includes
(
key
)
)
{
throw
new
Error
(
"
{
key
}
"
is
not
a
valid
field
.
)
;
}
if
(
typeof
address
[
key
]
!
=
=
"
string
"
&
&
typeof
address
[
key
]
!
=
=
"
number
"
)
{
throw
new
Error
(
"
{
key
}
"
contains
invalid
data
type
.
)
;
}
}
}
_dataPostProcessor
(
data
)
{
data
.
version
=
SCHEMA_VERSION
;
if
(
!
data
.
addresses
)
{
data
.
addresses
=
[
]
;
}
return
data
;
}
_saveImmediately
(
)
{
return
this
.
_store
.
_save
(
)
;
}
}
;
this
.
profileStorage
=
new
ProfileStorage
(
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
PROFILE_JSON_FILE_NAME
)
)
;
