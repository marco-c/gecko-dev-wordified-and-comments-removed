"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
profileStorage
"
]
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
formautofill
/
FormAutofillUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
JSONFile
"
"
resource
:
/
/
gre
/
modules
/
JSONFile
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
FormAutofillNameUtils
"
"
resource
:
/
/
formautofill
/
FormAutofillNameUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PhoneNumber
"
"
resource
:
/
/
formautofill
/
phonenumberutils
/
PhoneNumber
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
gUUIDGenerator
"
"
mozilla
.
org
/
uuid
-
generator
;
1
"
"
nsIUUIDGenerator
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
REGION_NAMES
"
function
(
)
{
let
regionNames
=
{
}
;
let
countries
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
global
/
locale
/
regionNames
.
properties
"
)
.
getSimpleEnumeration
(
)
;
while
(
countries
.
hasMoreElements
(
)
)
{
let
country
=
countries
.
getNext
(
)
.
QueryInterface
(
Components
.
interfaces
.
nsIPropertyElement
)
;
regionNames
[
country
.
key
.
toUpperCase
(
)
]
=
country
.
value
;
}
return
regionNames
;
}
)
;
const
CryptoHash
=
Components
.
Constructor
(
"
mozilla
.
org
/
security
/
hash
;
1
"
"
nsICryptoHash
"
"
initWithString
"
)
;
const
PROFILE_JSON_FILE_NAME
=
"
autofill
-
profiles
.
json
"
;
const
STORAGE_SCHEMA_VERSION
=
1
;
const
ADDRESS_SCHEMA_VERSION
=
1
;
const
CREDIT_CARD_SCHEMA_VERSION
=
1
;
const
VALID_ADDRESS_FIELDS
=
[
"
given
-
name
"
"
additional
-
name
"
"
family
-
name
"
"
organization
"
"
street
-
address
"
"
address
-
level2
"
"
address
-
level1
"
"
postal
-
code
"
"
country
"
"
tel
"
"
email
"
]
;
const
STREET_ADDRESS_COMPONENTS
=
[
"
address
-
line1
"
"
address
-
line2
"
"
address
-
line3
"
]
;
const
TEL_COMPONENTS
=
[
"
tel
-
country
-
code
"
"
tel
-
national
"
"
tel
-
area
-
code
"
"
tel
-
local
"
"
tel
-
local
-
prefix
"
"
tel
-
local
-
suffix
"
]
;
const
VALID_ADDRESS_COMPUTED_FIELDS
=
[
"
name
"
"
country
-
name
"
]
.
concat
(
STREET_ADDRESS_COMPONENTS
TEL_COMPONENTS
)
;
const
VALID_CREDIT_CARD_FIELDS
=
[
"
cc
-
name
"
"
cc
-
number
"
"
cc
-
number
-
encrypted
"
"
cc
-
exp
-
month
"
"
cc
-
exp
-
year
"
]
;
const
VALID_CREDIT_CARD_COMPUTED_FIELDS
=
[
"
cc
-
given
-
name
"
"
cc
-
additional
-
name
"
"
cc
-
family
-
name
"
]
;
const
INTERNAL_FIELDS
=
[
"
guid
"
"
version
"
"
timeCreated
"
"
timeLastUsed
"
"
timeLastModified
"
"
timesUsed
"
]
;
function
sha512
(
string
)
{
if
(
string
=
=
null
)
{
return
null
;
}
let
encoder
=
new
TextEncoder
(
"
utf
-
8
"
)
;
let
bytes
=
encoder
.
encode
(
string
)
;
let
hash
=
new
CryptoHash
(
"
sha512
"
)
;
hash
.
update
(
bytes
bytes
.
length
)
;
return
hash
.
finish
(
true
)
;
}
class
AutofillRecords
{
constructor
(
store
collectionName
validFields
validComputedFields
schemaVersion
)
{
FormAutofillUtils
.
defineLazyLogGetter
(
this
"
AutofillRecords
:
"
+
collectionName
)
;
this
.
VALID_FIELDS
=
validFields
;
this
.
VALID_COMPUTED_FIELDS
=
validComputedFields
;
this
.
_store
=
store
;
this
.
_collectionName
=
collectionName
;
this
.
_schemaVersion
=
schemaVersion
;
let
hasChanges
=
(
result
record
)
=
>
this
.
_migrateRecord
(
record
)
|
|
result
;
if
(
this
.
_store
.
data
[
this
.
_collectionName
]
.
reduce
(
hasChanges
false
)
)
{
this
.
_store
.
saveSoon
(
)
;
}
}
get
version
(
)
{
return
this
.
_schemaVersion
;
}
_ensureMatchingVersion
(
record
)
{
if
(
record
.
version
!
=
this
.
version
)
{
throw
new
Error
(
Got
unknown
record
version
{
record
.
version
}
;
want
{
this
.
version
}
)
;
}
}
add
(
record
{
sourceSync
=
false
}
=
{
}
)
{
this
.
log
.
debug
(
"
add
:
"
record
)
;
if
(
sourceSync
)
{
let
index
=
this
.
_findIndexByGUID
(
record
.
guid
{
includeDeleted
:
true
}
)
;
if
(
index
>
-
1
)
{
let
existing
=
this
.
_store
.
data
[
this
.
_collectionName
]
[
index
]
;
if
(
existing
.
deleted
)
{
this
.
_store
.
data
[
this
.
_collectionName
]
.
splice
(
index
1
)
;
}
else
{
throw
new
Error
(
Record
{
record
.
guid
}
already
exists
)
;
}
}
let
recordToSave
=
this
.
_clone
(
record
)
;
return
this
.
_saveRecord
(
recordToSave
{
sourceSync
}
)
;
}
if
(
record
.
deleted
)
{
return
this
.
_saveRecord
(
record
)
;
}
let
recordToSave
=
this
.
_clone
(
record
)
;
this
.
_normalizeRecord
(
recordToSave
)
;
recordToSave
.
guid
=
this
.
_generateGUID
(
)
;
recordToSave
.
version
=
this
.
version
;
let
now
=
Date
.
now
(
)
;
recordToSave
.
timeCreated
=
now
;
recordToSave
.
timeLastModified
=
now
;
recordToSave
.
timeLastUsed
=
0
;
recordToSave
.
timesUsed
=
0
;
return
this
.
_saveRecord
(
recordToSave
)
;
}
_saveRecord
(
record
{
sourceSync
=
false
}
=
{
}
)
{
if
(
!
record
.
guid
)
{
throw
new
Error
(
"
Record
missing
GUID
"
)
;
}
let
recordToSave
;
if
(
record
.
deleted
)
{
if
(
this
.
_findByGUID
(
record
.
guid
{
includeDeleted
:
true
}
)
)
{
throw
new
Error
(
"
a
record
with
this
GUID
already
exists
"
)
;
}
recordToSave
=
{
guid
:
record
.
guid
timeLastModified
:
record
.
timeLastModified
|
|
Date
.
now
(
)
deleted
:
true
}
;
}
else
{
this
.
_ensureMatchingVersion
(
record
)
;
recordToSave
=
record
;
}
if
(
sourceSync
)
{
let
sync
=
this
.
_getSyncMetaData
(
recordToSave
true
)
;
sync
.
changeCounter
=
0
;
}
this
.
_computeFields
(
recordToSave
)
;
this
.
_store
.
data
[
this
.
_collectionName
]
.
push
(
recordToSave
)
;
this
.
_store
.
saveSoon
(
)
;
Services
.
obs
.
notifyObservers
(
{
wrappedJSObject
:
{
sourceSync
}
}
"
formautofill
-
storage
-
changed
"
"
add
"
)
;
return
recordToSave
.
guid
;
}
_generateGUID
(
)
{
let
guid
;
while
(
!
guid
|
|
this
.
_findByGUID
(
guid
)
)
{
guid
=
gUUIDGenerator
.
generateUUID
(
)
.
toString
(
)
.
replace
(
/
[
{
}
-
]
/
g
"
"
)
.
substring
(
0
12
)
;
}
return
guid
;
}
update
(
guid
record
)
{
this
.
log
.
debug
(
"
update
:
"
guid
record
)
;
let
recordFound
=
this
.
_findByGUID
(
guid
)
;
if
(
!
recordFound
)
{
throw
new
Error
(
"
No
matching
record
.
"
)
;
}
let
recordToUpdate
=
this
.
_clone
(
record
)
;
this
.
_normalizeRecord
(
recordToUpdate
)
;
for
(
let
field
of
this
.
VALID_FIELDS
)
{
let
oldValue
=
recordFound
[
field
]
;
let
newValue
=
recordToUpdate
[
field
]
;
if
(
newValue
!
=
null
)
{
recordFound
[
field
]
=
newValue
;
}
else
{
delete
recordFound
[
field
]
;
}
this
.
_maybeStoreLastSyncedField
(
recordFound
field
oldValue
)
;
}
recordFound
.
timeLastModified
=
Date
.
now
(
)
;
let
syncMetadata
=
this
.
_getSyncMetaData
(
recordFound
)
;
if
(
syncMetadata
)
{
syncMetadata
.
changeCounter
+
=
1
;
}
this
.
_stripComputedFields
(
recordFound
)
;
this
.
_computeFields
(
recordFound
)
;
this
.
_store
.
saveSoon
(
)
;
Services
.
obs
.
notifyObservers
(
null
"
formautofill
-
storage
-
changed
"
"
update
"
)
;
}
notifyUsed
(
guid
)
{
this
.
log
.
debug
(
"
notifyUsed
:
"
guid
)
;
let
recordFound
=
this
.
_findByGUID
(
guid
)
;
if
(
!
recordFound
)
{
throw
new
Error
(
"
No
matching
record
.
"
)
;
}
recordFound
.
timesUsed
+
+
;
recordFound
.
timeLastUsed
=
Date
.
now
(
)
;
this
.
_store
.
saveSoon
(
)
;
Services
.
obs
.
notifyObservers
(
null
"
formautofill
-
storage
-
changed
"
"
notifyUsed
"
)
;
}
remove
(
guid
{
sourceSync
=
false
}
=
{
}
)
{
this
.
log
.
debug
(
"
remove
:
"
guid
)
;
if
(
sourceSync
)
{
this
.
_removeSyncedRecord
(
guid
)
;
}
else
{
let
index
=
this
.
_findIndexByGUID
(
guid
{
includeDeleted
:
false
}
)
;
if
(
index
=
=
-
1
)
{
this
.
log
.
warn
(
"
attempting
to
remove
non
-
existing
entry
"
guid
)
;
return
;
}
let
existing
=
this
.
_store
.
data
[
this
.
_collectionName
]
[
index
]
;
if
(
existing
.
deleted
)
{
return
;
}
let
existingSync
=
this
.
_getSyncMetaData
(
existing
)
;
if
(
existingSync
)
{
this
.
_store
.
data
[
this
.
_collectionName
]
[
index
]
=
{
guid
timeLastModified
:
Date
.
now
(
)
deleted
:
true
_sync
:
existingSync
}
;
existingSync
.
changeCounter
+
+
;
}
else
{
this
.
_store
.
data
[
this
.
_collectionName
]
.
splice
(
index
1
)
;
}
}
this
.
_store
.
saveSoon
(
)
;
Services
.
obs
.
notifyObservers
(
{
wrappedJSObject
:
{
sourceSync
}
}
"
formautofill
-
storage
-
changed
"
"
remove
"
)
;
}
get
(
guid
{
rawData
=
false
}
=
{
}
)
{
this
.
log
.
debug
(
"
get
:
"
guid
rawData
)
;
let
recordFound
=
this
.
_findByGUID
(
guid
)
;
if
(
!
recordFound
)
{
return
null
;
}
let
clonedRecord
=
this
.
_clone
(
recordFound
)
;
if
(
rawData
)
{
this
.
_stripComputedFields
(
clonedRecord
)
;
}
else
{
this
.
_recordReadProcessor
(
clonedRecord
)
;
}
return
clonedRecord
;
}
getAll
(
{
rawData
=
false
includeDeleted
=
false
}
=
{
}
)
{
this
.
log
.
debug
(
"
getAll
"
rawData
includeDeleted
)
;
let
records
=
this
.
_store
.
data
[
this
.
_collectionName
]
.
filter
(
r
=
>
!
r
.
deleted
|
|
includeDeleted
)
;
let
clonedRecords
=
records
.
map
(
r
=
>
this
.
_clone
(
r
)
)
;
clonedRecords
.
forEach
(
record
=
>
{
if
(
rawData
)
{
this
.
_stripComputedFields
(
record
)
;
}
else
{
this
.
_recordReadProcessor
(
record
)
;
}
}
)
;
return
clonedRecords
;
}
getByFilter
(
{
info
searchString
}
)
{
this
.
log
.
debug
(
"
getByFilter
:
"
info
searchString
)
;
let
lcSearchString
=
searchString
.
toLowerCase
(
)
;
let
result
=
this
.
getAll
(
)
.
filter
(
record
=
>
{
let
name
=
record
[
info
.
fieldName
]
;
if
(
!
searchString
)
{
return
!
!
name
;
}
return
name
&
&
name
.
toLowerCase
(
)
.
startsWith
(
lcSearchString
)
;
}
)
;
this
.
log
.
debug
(
"
getByFilter
:
"
"
Returning
"
result
.
length
"
result
(
s
)
"
)
;
return
result
;
}
_maybeStoreLastSyncedField
(
record
field
lastSyncedValue
)
{
let
sync
=
this
.
_getSyncMetaData
(
record
)
;
if
(
!
sync
)
{
return
;
}
let
alreadyChanged
=
field
in
sync
.
lastSyncedFields
;
if
(
alreadyChanged
)
{
return
;
}
let
newValue
=
record
[
field
]
;
if
(
lastSyncedValue
!
=
newValue
)
{
sync
.
lastSyncedFields
[
field
]
=
sha512
(
lastSyncedValue
)
;
}
}
_mergeSyncedRecords
(
localRecord
remoteRecord
)
{
let
sync
=
this
.
_getSyncMetaData
(
localRecord
true
)
;
let
mergedRecord
=
{
}
;
for
(
let
field
of
INTERNAL_FIELDS
)
{
if
(
remoteRecord
[
field
]
!
=
null
)
{
mergedRecord
[
field
]
=
remoteRecord
[
field
]
;
}
}
for
(
let
field
of
this
.
VALID_FIELDS
)
{
let
isLocalSame
=
false
;
let
isRemoteSame
=
false
;
if
(
field
in
sync
.
lastSyncedFields
)
{
let
lastSyncedValue
=
sync
.
lastSyncedFields
[
field
]
;
isLocalSame
=
lastSyncedValue
=
=
sha512
(
localRecord
[
field
]
)
;
isRemoteSame
=
lastSyncedValue
=
=
sha512
(
remoteRecord
[
field
]
)
;
}
else
{
isLocalSame
=
true
;
isRemoteSame
=
localRecord
[
field
]
=
=
remoteRecord
[
field
]
;
}
let
value
;
if
(
isLocalSame
&
&
isRemoteSame
)
{
value
=
localRecord
[
field
]
;
}
else
if
(
isLocalSame
&
&
!
isRemoteSame
)
{
value
=
remoteRecord
[
field
]
;
}
else
if
(
!
isLocalSame
&
&
isRemoteSame
)
{
value
=
localRecord
[
field
]
;
}
else
if
(
localRecord
[
field
]
=
=
remoteRecord
[
field
]
)
{
value
=
localRecord
[
field
]
;
}
else
{
return
null
;
}
if
(
value
!
=
null
)
{
mergedRecord
[
field
]
=
value
;
}
}
return
mergedRecord
;
}
_replaceRecordAt
(
index
remoteRecord
{
keepSyncMetadata
=
false
}
=
{
}
)
{
let
localRecord
=
this
.
_store
.
data
[
this
.
_collectionName
]
[
index
]
;
let
newRecord
=
this
.
_clone
(
remoteRecord
)
;
this
.
_stripComputedFields
(
newRecord
)
;
this
.
_store
.
data
[
this
.
_collectionName
]
[
index
]
=
newRecord
;
if
(
keepSyncMetadata
)
{
newRecord
.
_sync
=
localRecord
.
_sync
;
}
else
{
let
sync
=
this
.
_getSyncMetaData
(
newRecord
true
)
;
sync
.
changeCounter
=
0
;
}
if
(
!
newRecord
.
timeCreated
|
|
localRecord
.
timeCreated
<
newRecord
.
timeCreated
)
{
newRecord
.
timeCreated
=
localRecord
.
timeCreated
;
}
if
(
!
newRecord
.
timeLastModified
|
|
localRecord
.
timeLastModified
>
newRecord
.
timeLastModified
)
{
newRecord
.
timeLastModified
=
localRecord
.
timeLastModified
;
}
for
(
let
field
of
[
"
timeLastUsed
"
"
timesUsed
"
]
)
{
if
(
localRecord
[
field
]
!
=
null
)
{
newRecord
[
field
]
=
localRecord
[
field
]
;
}
}
this
.
_computeFields
(
newRecord
)
;
}
_forkLocalRecord
(
localRecord
)
{
let
forkedLocalRecord
=
this
.
_clone
(
localRecord
)
;
this
.
_stripComputedFields
(
forkedLocalRecord
)
;
forkedLocalRecord
.
guid
=
this
.
_generateGUID
(
)
;
this
.
_store
.
data
[
this
.
_collectionName
]
.
push
(
forkedLocalRecord
)
;
this
.
_getSyncMetaData
(
forkedLocalRecord
true
)
;
this
.
_computeFields
(
forkedLocalRecord
)
;
return
forkedLocalRecord
;
}
reconcile
(
remoteRecord
)
{
this
.
_ensureMatchingVersion
(
remoteRecord
)
;
if
(
remoteRecord
.
deleted
)
{
throw
new
Error
(
Can
'
t
reconcile
tombstone
{
remoteRecord
.
guid
}
)
;
}
let
localIndex
=
this
.
_findIndexByGUID
(
remoteRecord
.
guid
)
;
if
(
localIndex
<
0
)
{
throw
new
Error
(
Record
{
remoteRecord
.
guid
}
not
found
)
;
}
let
localRecord
=
this
.
_store
.
data
[
this
.
_collectionName
]
[
localIndex
]
;
let
sync
=
this
.
_getSyncMetaData
(
localRecord
true
)
;
let
forkedGUID
=
null
;
if
(
sync
.
changeCounter
=
=
=
0
)
{
this
.
_replaceRecordAt
(
localIndex
remoteRecord
{
keepSyncMetadata
:
false
}
)
;
}
else
{
let
mergedRecord
=
this
.
_mergeSyncedRecords
(
localRecord
remoteRecord
)
;
if
(
mergedRecord
)
{
this
.
_replaceRecordAt
(
localIndex
mergedRecord
{
keepSyncMetadata
:
true
}
)
;
}
else
{
let
forkedLocalRecord
=
this
.
_forkLocalRecord
(
localRecord
)
;
forkedGUID
=
forkedLocalRecord
.
guid
;
this
.
_replaceRecordAt
(
localIndex
remoteRecord
{
keepSyncMetadata
:
false
}
)
;
}
}
this
.
_store
.
saveSoon
(
)
;
Services
.
obs
.
notifyObservers
(
{
wrappedJSObject
:
{
sourceSync
:
true
}
}
"
formautofill
-
storage
-
changed
"
"
reconcile
"
)
;
return
{
forkedGUID
}
;
}
_removeSyncedRecord
(
guid
)
{
let
index
=
this
.
_findIndexByGUID
(
guid
{
includeDeleted
:
true
}
)
;
if
(
index
=
=
-
1
)
{
let
tombstone
=
{
guid
timeLastModified
:
Date
.
now
(
)
deleted
:
true
}
;
let
sync
=
this
.
_getSyncMetaData
(
tombstone
true
)
;
sync
.
changeCounter
=
0
;
this
.
_store
.
data
[
this
.
_collectionName
]
.
push
(
tombstone
)
;
return
;
}
let
existing
=
this
.
_store
.
data
[
this
.
_collectionName
]
[
index
]
;
let
sync
=
this
.
_getSyncMetaData
(
existing
true
)
;
if
(
sync
.
changeCounter
>
0
)
{
this
.
log
.
info
(
"
Ignoring
deletion
for
record
with
local
changes
"
existing
)
;
return
;
}
if
(
existing
.
deleted
)
{
this
.
log
.
info
(
"
Ignoring
deletion
for
tombstone
"
existing
)
;
return
;
}
this
.
_store
.
data
[
this
.
_collectionName
]
[
index
]
=
{
guid
timeLastModified
:
Date
.
now
(
)
deleted
:
true
_sync
:
sync
}
;
}
pullSyncChanges
(
)
{
let
changes
=
{
}
;
let
profiles
=
this
.
_store
.
data
[
this
.
_collectionName
]
;
for
(
let
profile
of
profiles
)
{
let
sync
=
this
.
_getSyncMetaData
(
profile
true
)
;
if
(
sync
.
changeCounter
<
1
)
{
if
(
sync
.
changeCounter
!
=
0
)
{
this
.
log
.
error
(
"
negative
change
counter
"
profile
)
;
}
continue
;
}
changes
[
profile
.
guid
]
=
{
profile
counter
:
sync
.
changeCounter
modified
:
profile
.
timeLastModified
synced
:
false
}
;
}
this
.
_store
.
saveSoon
(
)
;
return
changes
;
}
pushSyncChanges
(
changes
)
{
for
(
let
[
guid
{
counter
synced
}
]
of
Object
.
entries
(
changes
)
)
{
if
(
!
synced
)
{
continue
;
}
let
recordFound
=
this
.
_findByGUID
(
guid
{
includeDeleted
:
true
}
)
;
if
(
!
recordFound
)
{
this
.
log
.
warn
(
"
No
profile
found
to
persist
changes
for
guid
"
+
guid
)
;
continue
;
}
let
sync
=
this
.
_getSyncMetaData
(
recordFound
true
)
;
sync
.
changeCounter
=
Math
.
max
(
0
sync
.
changeCounter
-
counter
)
;
if
(
sync
.
changeCounter
=
=
=
0
)
{
sync
.
lastSyncedFields
=
{
}
;
}
}
this
.
_store
.
saveSoon
(
)
;
}
resetSync
(
)
{
for
(
let
record
of
this
.
_store
.
data
[
this
.
_collectionName
]
)
{
delete
record
.
_sync
;
}
this
.
log
.
info
(
"
All
sync
metadata
was
reset
"
)
;
}
changeGUID
(
oldID
newID
)
{
this
.
log
.
debug
(
"
changeGUID
:
"
oldID
newID
)
;
if
(
oldID
=
=
newID
)
{
throw
new
Error
(
"
changeGUID
:
old
and
new
IDs
are
the
same
"
)
;
}
if
(
this
.
_findIndexByGUID
(
newID
)
>
=
0
)
{
throw
new
Error
(
"
changeGUID
:
record
with
destination
id
exists
already
"
)
;
}
let
index
=
this
.
_findIndexByGUID
(
oldID
)
;
let
profile
=
this
.
_store
.
data
[
this
.
_collectionName
]
[
index
]
;
if
(
!
profile
)
{
throw
new
Error
(
"
changeGUID
:
no
source
record
"
)
;
}
if
(
this
.
_getSyncMetaData
(
profile
)
)
{
throw
new
Error
(
"
changeGUID
:
existing
record
has
already
been
synced
"
)
;
}
profile
.
guid
=
newID
;
this
.
_store
.
saveSoon
(
)
;
}
_getSyncMetaData
(
record
forceCreate
=
false
)
{
if
(
!
record
.
_sync
&
&
forceCreate
)
{
record
.
_sync
=
{
changeCounter
:
1
lastSyncedFields
:
{
}
}
;
this
.
_store
.
saveSoon
(
)
;
}
return
record
.
_sync
;
}
findDuplicateGUID
(
record
)
{
if
(
!
record
.
guid
)
{
throw
new
Error
(
"
Record
missing
GUID
"
)
;
}
this
.
_ensureMatchingVersion
(
record
)
;
if
(
record
.
deleted
)
{
throw
new
Error
(
"
Tombstones
can
'
t
have
duplicates
"
)
;
}
let
records
=
this
.
_store
.
data
[
this
.
_collectionName
]
;
for
(
let
profile
of
records
)
{
if
(
profile
.
deleted
)
{
continue
;
}
if
(
profile
.
guid
=
=
record
.
guid
)
{
throw
new
Error
(
Record
{
record
.
guid
}
already
exists
)
;
}
if
(
this
.
_getSyncMetaData
(
profile
)
)
{
continue
;
}
let
keys
=
new
Set
(
Object
.
keys
(
record
)
)
;
for
(
let
key
of
Object
.
keys
(
profile
)
)
{
keys
.
add
(
key
)
;
}
for
(
let
field
of
INTERNAL_FIELDS
)
{
keys
.
delete
(
field
)
;
}
for
(
let
field
of
this
.
VALID_COMPUTED_FIELDS
)
{
keys
.
delete
(
field
)
;
}
if
(
!
keys
.
size
)
{
continue
;
}
let
same
=
true
;
for
(
let
key
of
keys
)
{
same
=
key
in
profile
=
=
key
in
record
&
&
profile
[
key
]
=
=
record
[
key
]
;
if
(
!
same
)
{
break
;
}
}
if
(
same
)
{
return
profile
.
guid
;
}
}
return
null
;
}
_clone
(
record
)
{
let
result
=
{
}
;
for
(
let
key
in
record
)
{
if
(
!
key
.
startsWith
(
"
_
"
)
)
{
result
[
key
]
=
record
[
key
]
;
}
}
return
result
;
}
_findByGUID
(
guid
{
includeDeleted
=
false
}
=
{
}
)
{
let
found
=
this
.
_findIndexByGUID
(
guid
{
includeDeleted
}
)
;
return
found
<
0
?
undefined
:
this
.
_store
.
data
[
this
.
_collectionName
]
[
found
]
;
}
_findIndexByGUID
(
guid
{
includeDeleted
=
false
}
=
{
}
)
{
return
this
.
_store
.
data
[
this
.
_collectionName
]
.
findIndex
(
record
=
>
{
return
record
.
guid
=
=
guid
&
&
(
!
record
.
deleted
|
|
includeDeleted
)
;
}
)
;
}
_migrateRecord
(
record
)
{
let
hasChanges
=
false
;
if
(
!
record
.
version
|
|
isNaN
(
record
.
version
)
|
|
record
.
version
<
1
)
{
this
.
log
.
warn
(
"
Invalid
record
version
:
"
record
.
version
)
;
record
.
version
=
0
;
}
if
(
record
.
version
<
this
.
version
)
{
hasChanges
=
true
;
record
.
version
=
this
.
version
;
this
.
_stripComputedFields
(
record
)
;
}
hasChanges
|
=
this
.
_computeFields
(
record
)
;
return
hasChanges
;
}
_normalizeRecord
(
record
)
{
this
.
_normalizeFields
(
record
)
;
for
(
let
key
in
record
)
{
if
(
!
this
.
VALID_FIELDS
.
includes
(
key
)
)
{
throw
new
Error
(
"
{
key
}
"
is
not
a
valid
field
.
)
;
}
if
(
typeof
record
[
key
]
!
=
=
"
string
"
&
&
typeof
record
[
key
]
!
=
=
"
number
"
)
{
throw
new
Error
(
"
{
key
}
"
contains
invalid
data
type
.
)
;
}
}
}
_nukeAllRecords
(
)
{
this
.
_store
.
data
[
this
.
_collectionName
]
=
[
]
;
}
_stripComputedFields
(
record
)
{
this
.
VALID_COMPUTED_FIELDS
.
forEach
(
field
=
>
delete
record
[
field
]
)
;
}
_recordReadProcessor
(
record
)
{
}
_computeFields
(
record
)
{
}
_normalizeFields
(
record
)
{
}
mergeIfPossible
(
guid
record
)
{
}
mergeToStorage
(
targetRecord
)
{
}
}
class
Addresses
extends
AutofillRecords
{
constructor
(
store
)
{
super
(
store
"
addresses
"
VALID_ADDRESS_FIELDS
VALID_ADDRESS_COMPUTED_FIELDS
ADDRESS_SCHEMA_VERSION
)
;
}
_recordReadProcessor
(
address
)
{
if
(
address
.
country
&
&
address
.
country
!
=
"
US
"
)
{
address
[
"
country
-
name
"
]
=
"
"
;
delete
address
.
country
;
}
}
_computeFields
(
address
)
{
let
hasNewComputedFields
=
false
;
if
(
!
(
"
name
"
in
address
)
)
{
let
name
=
FormAutofillNameUtils
.
joinNameParts
(
{
given
:
address
[
"
given
-
name
"
]
middle
:
address
[
"
additional
-
name
"
]
family
:
address
[
"
family
-
name
"
]
}
)
;
address
.
name
=
name
;
hasNewComputedFields
=
true
;
}
if
(
!
(
"
address
-
line1
"
in
address
)
)
{
let
streetAddress
=
[
]
;
if
(
address
[
"
street
-
address
"
]
)
{
streetAddress
=
address
[
"
street
-
address
"
]
.
split
(
"
\
n
"
)
.
map
(
s
=
>
s
.
trim
(
)
)
;
}
for
(
let
i
=
0
;
i
<
3
;
i
+
+
)
{
address
[
"
address
-
line
"
+
(
i
+
1
)
]
=
streetAddress
[
i
]
|
|
"
"
;
}
if
(
streetAddress
.
length
>
3
)
{
address
[
"
address
-
line3
"
]
=
FormAutofillUtils
.
toOneLineAddress
(
streetAddress
.
splice
(
2
)
)
;
}
hasNewComputedFields
=
true
;
}
if
(
!
(
"
country
-
name
"
in
address
)
)
{
if
(
address
.
country
&
&
REGION_NAMES
[
address
.
country
]
)
{
address
[
"
country
-
name
"
]
=
REGION_NAMES
[
address
.
country
]
;
}
else
{
address
[
"
country
-
name
"
]
=
"
"
;
}
hasNewComputedFields
=
true
;
}
if
(
!
(
"
tel
-
national
"
in
address
)
)
{
if
(
address
.
tel
)
{
let
browserCountryCode
=
Services
.
prefs
.
getCharPref
(
"
browser
.
search
.
countryCode
"
"
US
"
)
;
let
tel
=
PhoneNumber
.
Parse
(
address
.
tel
address
.
country
|
|
browserCountryCode
)
;
if
(
tel
)
{
if
(
tel
.
countryCode
)
{
address
[
"
tel
-
country
-
code
"
]
=
tel
.
countryCode
;
}
if
(
tel
.
nationalNumber
)
{
address
[
"
tel
-
national
"
]
=
tel
.
nationalNumber
;
}
if
(
tel
.
nationalNumber
&
&
tel
.
countryCode
=
=
"
+
1
"
)
{
let
telComponents
=
tel
.
nationalNumber
.
match
(
/
(
\
d
{
3
}
)
(
(
\
d
{
3
}
)
(
\
d
{
4
}
)
)
/
)
;
if
(
telComponents
)
{
address
[
"
tel
-
area
-
code
"
]
=
telComponents
[
1
]
;
address
[
"
tel
-
local
"
]
=
telComponents
[
2
]
;
address
[
"
tel
-
local
-
prefix
"
]
=
telComponents
[
3
]
;
address
[
"
tel
-
local
-
suffix
"
]
=
telComponents
[
4
]
;
}
}
}
else
{
address
[
"
tel
-
national
"
]
=
address
.
tel
;
}
}
TEL_COMPONENTS
.
forEach
(
c
=
>
{
address
[
c
]
=
address
[
c
]
|
|
"
"
;
}
)
;
}
return
hasNewComputedFields
;
}
_normalizeFields
(
address
)
{
this
.
_normalizeName
(
address
)
;
this
.
_normalizeAddress
(
address
)
;
this
.
_normalizeCountry
(
address
)
;
this
.
_normalizeTel
(
address
)
;
}
_normalizeName
(
address
)
{
if
(
!
address
.
name
)
{
return
;
}
let
nameParts
=
FormAutofillNameUtils
.
splitName
(
address
.
name
)
;
if
(
!
address
[
"
given
-
name
"
]
&
&
nameParts
.
given
)
{
address
[
"
given
-
name
"
]
=
nameParts
.
given
;
}
if
(
!
address
[
"
additional
-
name
"
]
&
&
nameParts
.
middle
)
{
address
[
"
additional
-
name
"
]
=
nameParts
.
middle
;
}
if
(
!
address
[
"
family
-
name
"
]
&
&
nameParts
.
family
)
{
address
[
"
family
-
name
"
]
=
nameParts
.
family
;
}
delete
address
.
name
;
}
_normalizeAddress
(
address
)
{
if
(
STREET_ADDRESS_COMPONENTS
.
every
(
c
=
>
!
address
[
c
]
)
)
{
return
;
}
if
(
!
address
[
"
address
-
line1
"
]
&
&
address
[
"
street
-
address
"
]
&
&
!
address
[
"
street
-
address
"
]
.
includes
(
"
\
n
"
)
)
{
address
[
"
address
-
line1
"
]
=
address
[
"
street
-
address
"
]
;
delete
address
[
"
street
-
address
"
]
;
}
if
(
!
address
[
"
street
-
address
"
]
)
{
address
[
"
street
-
address
"
]
=
STREET_ADDRESS_COMPONENTS
.
map
(
c
=
>
address
[
c
]
)
.
join
(
"
\
n
"
)
;
}
STREET_ADDRESS_COMPONENTS
.
forEach
(
c
=
>
delete
address
[
c
]
)
;
}
_normalizeCountry
(
address
)
{
if
(
address
.
country
)
{
let
country
=
address
.
country
.
toUpperCase
(
)
;
if
(
REGION_NAMES
[
country
]
)
{
address
.
country
=
country
;
}
else
{
delete
address
.
country
;
}
}
else
if
(
address
[
"
country
-
name
"
]
)
{
for
(
let
region
in
REGION_NAMES
)
{
if
(
REGION_NAMES
[
region
]
.
toLowerCase
(
)
=
=
address
[
"
country
-
name
"
]
.
toLowerCase
(
)
)
{
address
.
country
=
region
;
break
;
}
}
}
delete
address
[
"
country
-
name
"
]
;
}
_normalizeTel
(
address
)
{
if
(
!
address
.
tel
&
&
TEL_COMPONENTS
.
every
(
c
=
>
!
address
[
c
]
)
)
{
return
;
}
let
browserCountryCode
=
Services
.
prefs
.
getCharPref
(
"
browser
.
search
.
countryCode
"
"
US
"
)
;
let
region
=
address
[
"
tel
-
country
-
code
"
]
|
|
address
.
country
|
|
browserCountryCode
;
let
number
;
if
(
address
.
tel
)
{
number
=
address
.
tel
;
}
else
if
(
address
[
"
tel
-
national
"
]
)
{
number
=
address
[
"
tel
-
national
"
]
;
}
else
if
(
address
[
"
tel
-
local
"
]
)
{
number
=
(
address
[
"
tel
-
area
-
code
"
]
|
|
"
"
)
+
address
[
"
tel
-
local
"
]
;
}
else
if
(
address
[
"
tel
-
local
-
prefix
"
]
&
&
address
[
"
tel
-
local
-
suffix
"
]
)
{
number
=
(
address
[
"
tel
-
area
-
code
"
]
|
|
"
"
)
+
address
[
"
tel
-
local
-
prefix
"
]
+
address
[
"
tel
-
local
-
suffix
"
]
;
}
let
tel
=
PhoneNumber
.
Parse
(
number
region
)
;
if
(
tel
&
&
tel
.
internationalNumber
)
{
address
.
tel
=
tel
.
internationalNumber
;
}
else
if
(
!
address
.
tel
)
{
address
.
tel
=
number
;
}
TEL_COMPONENTS
.
forEach
(
c
=
>
delete
address
[
c
]
)
;
}
mergeIfPossible
(
guid
address
)
{
this
.
log
.
debug
(
"
mergeIfPossible
:
"
guid
address
)
;
let
addressFound
=
this
.
_findByGUID
(
guid
)
;
if
(
!
addressFound
)
{
throw
new
Error
(
"
No
matching
address
.
"
)
;
}
let
addressToMerge
=
this
.
_clone
(
address
)
;
this
.
_normalizeRecord
(
addressToMerge
)
;
let
hasMatchingField
=
false
;
for
(
let
field
of
this
.
VALID_FIELDS
)
{
if
(
addressToMerge
[
field
]
!
=
=
undefined
&
&
addressFound
[
field
]
!
=
=
undefined
)
{
if
(
addressToMerge
[
field
]
!
=
addressFound
[
field
]
)
{
this
.
log
.
debug
(
"
Conflicts
:
field
"
field
"
has
different
value
.
"
)
;
return
false
;
}
hasMatchingField
=
true
;
}
}
if
(
!
hasMatchingField
)
{
this
.
log
.
debug
(
"
Unable
to
merge
because
no
field
has
the
same
value
"
)
;
return
false
;
}
let
exactlyMatch
=
this
.
VALID_FIELDS
.
every
(
(
field
)
=
>
addressFound
[
field
]
=
=
=
addressToMerge
[
field
]
)
;
if
(
exactlyMatch
)
{
return
true
;
}
for
(
let
field
in
addressToMerge
)
{
if
(
this
.
VALID_FIELDS
.
includes
(
field
)
)
{
addressFound
[
field
]
=
addressToMerge
[
field
]
;
}
}
addressFound
.
timeLastModified
=
Date
.
now
(
)
;
this
.
_stripComputedFields
(
addressFound
)
;
this
.
_computeFields
(
addressFound
)
;
this
.
_store
.
saveSoon
(
)
;
let
str
=
Cc
[
"
mozilla
.
org
/
supports
-
string
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsString
)
;
str
.
data
=
guid
;
Services
.
obs
.
notifyObservers
(
str
"
formautofill
-
storage
-
changed
"
"
merge
"
)
;
return
true
;
}
mergeToStorage
(
targetAddress
)
{
let
mergedGUIDs
=
[
]
;
for
(
let
address
of
this
.
_store
.
data
[
this
.
_collectionName
]
)
{
if
(
!
address
.
deleted
&
&
this
.
mergeIfPossible
(
address
.
guid
targetAddress
)
)
{
mergedGUIDs
.
push
(
address
.
guid
)
;
}
}
this
.
log
.
debug
(
"
Existing
records
matching
and
merging
count
is
"
mergedGUIDs
.
length
)
;
return
mergedGUIDs
;
}
}
class
CreditCards
extends
AutofillRecords
{
constructor
(
store
)
{
super
(
store
"
creditCards
"
VALID_CREDIT_CARD_FIELDS
VALID_CREDIT_CARD_COMPUTED_FIELDS
CREDIT_CARD_SCHEMA_VERSION
)
;
}
_computeFields
(
creditCard
)
{
let
hasNewComputedFields
=
false
;
if
(
!
(
"
cc
-
given
-
name
"
in
creditCard
)
)
{
let
nameParts
=
FormAutofillNameUtils
.
splitName
(
creditCard
[
"
cc
-
name
"
]
)
;
creditCard
[
"
cc
-
given
-
name
"
]
=
nameParts
.
given
;
creditCard
[
"
cc
-
additional
-
name
"
]
=
nameParts
.
middle
;
creditCard
[
"
cc
-
family
-
name
"
]
=
nameParts
.
family
;
hasNewComputedFields
=
true
;
}
return
hasNewComputedFields
;
}
_normalizeFields
(
creditCard
)
{
delete
creditCard
[
"
cc
-
number
-
encrypted
"
]
;
if
(
creditCard
[
"
cc
-
number
"
]
)
{
let
ccNumber
=
creditCard
[
"
cc
-
number
"
]
.
replace
(
/
\
s
/
g
"
"
)
;
delete
creditCard
[
"
cc
-
number
"
]
;
if
(
!
/
^
\
d
+
/
.
test
(
ccNumber
)
)
{
throw
new
Error
(
"
Credit
card
number
contains
invalid
characters
.
"
)
;
}
if
(
ccNumber
.
length
>
4
)
{
creditCard
[
"
cc
-
number
"
]
=
"
*
"
.
repeat
(
ccNumber
.
length
-
4
)
+
ccNumber
.
substr
(
-
4
)
;
}
else
{
creditCard
[
"
cc
-
number
"
]
=
ccNumber
;
}
}
if
(
creditCard
[
"
cc
-
given
-
name
"
]
|
|
creditCard
[
"
cc
-
additional
-
name
"
]
|
|
creditCard
[
"
cc
-
family
-
name
"
]
)
{
if
(
!
creditCard
[
"
cc
-
name
"
]
)
{
creditCard
[
"
cc
-
name
"
]
=
FormAutofillNameUtils
.
joinNameParts
(
{
given
:
creditCard
[
"
cc
-
given
-
name
"
]
middle
:
creditCard
[
"
cc
-
additional
-
name
"
]
family
:
creditCard
[
"
cc
-
family
-
name
"
]
}
)
;
}
delete
creditCard
[
"
cc
-
given
-
name
"
]
;
delete
creditCard
[
"
cc
-
additional
-
name
"
]
;
delete
creditCard
[
"
cc
-
family
-
name
"
]
;
}
if
(
creditCard
[
"
cc
-
exp
-
month
"
]
)
{
let
expMonth
=
parseInt
(
creditCard
[
"
cc
-
exp
-
month
"
]
10
)
;
if
(
isNaN
(
expMonth
)
|
|
expMonth
<
1
|
|
expMonth
>
12
)
{
delete
creditCard
[
"
cc
-
exp
-
month
"
]
;
}
else
{
creditCard
[
"
cc
-
exp
-
month
"
]
=
expMonth
;
}
}
if
(
creditCard
[
"
cc
-
exp
-
year
"
]
)
{
let
expYear
=
parseInt
(
creditCard
[
"
cc
-
exp
-
year
"
]
10
)
;
if
(
isNaN
(
expYear
)
|
|
expYear
<
0
)
{
delete
creditCard
[
"
cc
-
exp
-
year
"
]
;
}
else
if
(
expYear
<
100
)
{
creditCard
[
"
cc
-
exp
-
year
"
]
=
expYear
+
2000
;
}
else
{
creditCard
[
"
cc
-
exp
-
year
"
]
=
expYear
;
}
}
}
}
function
ProfileStorage
(
path
)
{
this
.
_path
=
path
;
this
.
_initializePromise
=
null
;
this
.
INTERNAL_FIELDS
=
INTERNAL_FIELDS
;
}
ProfileStorage
.
prototype
=
{
get
version
(
)
{
return
STORAGE_SCHEMA_VERSION
;
}
get
addresses
(
)
{
if
(
!
this
.
_addresses
)
{
this
.
_store
.
ensureDataReady
(
)
;
this
.
_addresses
=
new
Addresses
(
this
.
_store
)
;
}
return
this
.
_addresses
;
}
get
creditCards
(
)
{
if
(
!
this
.
_creditCards
)
{
this
.
_store
.
ensureDataReady
(
)
;
this
.
_creditCards
=
new
CreditCards
(
this
.
_store
)
;
}
return
this
.
_creditCards
;
}
initialize
(
)
{
if
(
!
this
.
_initializePromise
)
{
this
.
_store
=
new
JSONFile
(
{
path
:
this
.
_path
dataPostProcessor
:
this
.
_dataPostProcessor
.
bind
(
this
)
}
)
;
this
.
_initializePromise
=
this
.
_store
.
load
(
)
;
}
return
this
.
_initializePromise
;
}
_dataPostProcessor
(
data
)
{
data
.
version
=
this
.
version
;
if
(
!
data
.
addresses
)
{
data
.
addresses
=
[
]
;
}
if
(
!
data
.
creditCards
)
{
data
.
creditCards
=
[
]
;
}
return
data
;
}
_saveImmediately
(
)
{
return
this
.
_store
.
_save
(
)
;
}
}
;
this
.
profileStorage
=
new
ProfileStorage
(
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
PROFILE_JSON_FILE_NAME
)
)
;
