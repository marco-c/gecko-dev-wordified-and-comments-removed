"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
ProfileStorage
"
]
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
formautofill
/
FormAutofillUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
JSONFile
"
"
resource
:
/
/
gre
/
modules
/
JSONFile
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
FormAutofillNameUtils
"
"
resource
:
/
/
formautofill
/
FormAutofillNameUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
gUUIDGenerator
"
"
mozilla
.
org
/
uuid
-
generator
;
1
"
"
nsIUUIDGenerator
"
)
;
this
.
log
=
null
;
FormAutofillUtils
.
defineLazyLogGetter
(
this
this
.
EXPORTED_SYMBOLS
[
0
]
)
;
const
SCHEMA_VERSION
=
1
;
const
VALID_FIELDS
=
[
"
given
-
name
"
"
additional
-
name
"
"
family
-
name
"
"
organization
"
"
street
-
address
"
"
address
-
level2
"
"
address
-
level1
"
"
postal
-
code
"
"
country
"
"
tel
"
"
email
"
]
;
const
MOCK_MODE
=
false
;
const
MOCK_STORAGE
=
[
{
guid
:
"
test
-
guid
-
1
"
organization
:
"
Sesame
Street
"
"
street
-
address
"
:
"
123
Sesame
Street
.
"
tel
:
"
1
-
345
-
345
-
3456
"
}
{
guid
:
"
test
-
guid
-
2
"
organization
:
"
Mozilla
"
"
street
-
address
"
:
"
331
E
.
Evelyn
Avenue
"
tel
:
"
1
-
650
-
903
-
0800
"
}
]
;
function
ProfileStorage
(
path
)
{
this
.
_path
=
path
;
}
ProfileStorage
.
prototype
=
{
INTERNAL_FIELDS
:
[
"
guid
"
"
timeCreated
"
"
timeLastUsed
"
"
timeLastModified
"
"
timesUsed
"
]
initialize
(
)
{
this
.
_store
=
new
JSONFile
(
{
path
:
this
.
_path
dataPostProcessor
:
this
.
_dataPostProcessor
.
bind
(
this
)
}
)
;
return
this
.
_store
.
load
(
)
;
}
add
(
profile
)
{
log
.
debug
(
"
add
:
"
profile
)
;
this
.
_store
.
ensureDataReady
(
)
;
let
profileToSave
=
this
.
_clone
(
profile
)
;
this
.
_normalizeProfile
(
profileToSave
)
;
profileToSave
.
guid
=
gUUIDGenerator
.
generateUUID
(
)
.
toString
(
)
.
replace
(
/
[
{
}
-
]
/
g
"
"
)
.
substring
(
0
12
)
;
let
now
=
Date
.
now
(
)
;
profileToSave
.
timeCreated
=
now
;
profileToSave
.
timeLastModified
=
now
;
profileToSave
.
timeLastUsed
=
0
;
profileToSave
.
timesUsed
=
0
;
this
.
_store
.
data
.
profiles
.
push
(
profileToSave
)
;
this
.
_store
.
saveSoon
(
)
;
Services
.
obs
.
notifyObservers
(
null
"
formautofill
-
storage
-
changed
"
"
add
"
)
;
}
update
(
guid
profile
)
{
log
.
debug
(
"
update
:
"
guid
profile
)
;
this
.
_store
.
ensureDataReady
(
)
;
let
profileFound
=
this
.
_findByGUID
(
guid
)
;
if
(
!
profileFound
)
{
throw
new
Error
(
"
No
matching
profile
.
"
)
;
}
let
profileToUpdate
=
this
.
_clone
(
profile
)
;
this
.
_normalizeProfile
(
profileToUpdate
)
;
for
(
let
field
of
VALID_FIELDS
)
{
if
(
profileToUpdate
[
field
]
!
=
=
undefined
)
{
profileFound
[
field
]
=
profileToUpdate
[
field
]
;
}
else
{
delete
profileFound
[
field
]
;
}
}
profileFound
.
timeLastModified
=
Date
.
now
(
)
;
this
.
_store
.
saveSoon
(
)
;
Services
.
obs
.
notifyObservers
(
null
"
formautofill
-
storage
-
changed
"
"
update
"
)
;
}
notifyUsed
(
guid
)
{
this
.
_store
.
ensureDataReady
(
)
;
let
profileFound
=
this
.
_findByGUID
(
guid
)
;
if
(
!
profileFound
)
{
throw
new
Error
(
"
No
matching
profile
.
"
)
;
}
profileFound
.
timesUsed
+
+
;
profileFound
.
timeLastUsed
=
Date
.
now
(
)
;
this
.
_store
.
saveSoon
(
)
;
Services
.
obs
.
notifyObservers
(
null
"
formautofill
-
storage
-
changed
"
"
notifyUsed
"
)
;
}
remove
(
guid
)
{
log
.
debug
(
"
remove
:
"
guid
)
;
this
.
_store
.
ensureDataReady
(
)
;
this
.
_store
.
data
.
profiles
=
this
.
_store
.
data
.
profiles
.
filter
(
profile
=
>
profile
.
guid
!
=
guid
)
;
this
.
_store
.
saveSoon
(
)
;
Services
.
obs
.
notifyObservers
(
null
"
formautofill
-
storage
-
changed
"
"
remove
"
)
;
}
get
(
guid
)
{
log
.
debug
(
"
get
:
"
guid
)
;
this
.
_store
.
ensureDataReady
(
)
;
let
profileFound
=
this
.
_findByGUID
(
guid
)
;
if
(
!
profileFound
)
{
throw
new
Error
(
"
No
matching
profile
.
"
)
;
}
let
clonedProfile
=
this
.
_clone
(
profileFound
)
;
this
.
_computeFields
(
clonedProfile
)
;
return
clonedProfile
;
}
getAll
(
)
{
log
.
debug
(
"
getAll
"
)
;
this
.
_store
.
ensureDataReady
(
)
;
let
clonedProfiles
=
this
.
_store
.
data
.
profiles
.
map
(
this
.
_clone
)
;
clonedProfiles
.
forEach
(
this
.
_computeFields
)
;
return
clonedProfiles
;
}
getByFilter
(
{
info
searchString
}
)
{
log
.
debug
(
"
getByFilter
:
"
info
searchString
)
;
let
lcSearchString
=
searchString
.
toLowerCase
(
)
;
let
result
=
this
.
getAll
(
)
.
filter
(
profile
=
>
{
let
name
=
profile
[
info
.
fieldName
]
;
if
(
!
searchString
)
{
return
!
!
name
;
}
return
name
&
&
name
.
toLowerCase
(
)
.
startsWith
(
lcSearchString
)
;
}
)
;
log
.
debug
(
"
getByFilter
:
Returning
"
result
.
length
"
result
(
s
)
"
)
;
return
result
;
}
_clone
(
profile
)
{
return
Object
.
assign
(
{
}
profile
)
;
}
_findByGUID
(
guid
)
{
return
this
.
_store
.
data
.
profiles
.
find
(
profile
=
>
profile
.
guid
=
=
guid
)
;
}
_computeFields
(
profile
)
{
profile
.
name
=
FormAutofillNameUtils
.
joinNameParts
(
{
given
:
profile
[
"
given
-
name
"
]
middle
:
profile
[
"
additional
-
name
"
]
family
:
profile
[
"
family
-
name
"
]
}
)
;
if
(
profile
[
"
street
-
address
"
]
)
{
let
streetAddress
=
profile
[
"
street
-
address
"
]
.
split
(
"
\
n
"
)
;
for
(
let
i
=
0
;
i
<
3
;
i
+
+
)
{
if
(
streetAddress
[
i
]
)
{
profile
[
"
address
-
line
"
+
(
i
+
1
)
]
=
streetAddress
[
i
]
;
}
}
}
}
_normalizeAddress
(
profile
)
{
if
(
profile
[
"
address
-
line1
"
]
|
|
profile
[
"
address
-
line2
"
]
|
|
profile
[
"
address
-
line3
"
]
)
{
if
(
!
profile
[
"
address
-
line1
"
]
&
&
profile
[
"
street
-
address
"
]
&
&
!
profile
[
"
street
-
address
"
]
.
includes
(
"
\
n
"
)
)
{
profile
[
"
address
-
line1
"
]
=
profile
[
"
street
-
address
"
]
;
delete
profile
[
"
street
-
address
"
]
;
}
let
addressLines
=
[
1
2
3
]
.
map
(
i
=
>
{
let
value
=
profile
[
"
address
-
line
"
+
i
]
;
delete
profile
[
"
address
-
line
"
+
i
]
;
return
value
;
}
)
;
if
(
!
profile
[
"
street
-
address
"
]
)
{
profile
[
"
street
-
address
"
]
=
addressLines
.
join
(
"
\
n
"
)
;
}
}
}
_normalizeName
(
profile
)
{
if
(
!
profile
.
name
)
{
return
;
}
let
nameParts
=
FormAutofillNameUtils
.
splitName
(
profile
.
name
)
;
if
(
!
profile
[
"
given
-
name
"
]
&
&
nameParts
.
given
)
{
profile
[
"
given
-
name
"
]
=
nameParts
.
given
;
}
if
(
!
profile
[
"
additional
-
name
"
]
&
&
nameParts
.
middle
)
{
profile
[
"
additional
-
name
"
]
=
nameParts
.
middle
;
}
if
(
!
profile
[
"
family
-
name
"
]
&
&
nameParts
.
family
)
{
profile
[
"
family
-
name
"
]
=
nameParts
.
family
;
}
delete
profile
.
name
;
}
_normalizeProfile
(
profile
)
{
this
.
_normalizeName
(
profile
)
;
this
.
_normalizeAddress
(
profile
)
;
for
(
let
key
in
profile
)
{
if
(
!
VALID_FIELDS
.
includes
(
key
)
)
{
throw
new
Error
(
"
{
key
}
"
is
not
a
valid
field
.
)
;
}
if
(
typeof
profile
[
key
]
!
=
=
"
string
"
&
&
typeof
profile
[
key
]
!
=
=
"
number
"
)
{
throw
new
Error
(
"
{
key
}
"
contains
invalid
data
type
.
)
;
}
}
}
_dataPostProcessor
(
data
)
{
data
.
version
=
SCHEMA_VERSION
;
if
(
!
data
.
profiles
)
{
data
.
profiles
=
MOCK_MODE
?
MOCK_STORAGE
:
[
]
;
}
return
data
;
}
_saveImmediately
(
)
{
return
this
.
_store
.
_save
(
)
;
}
}
;
