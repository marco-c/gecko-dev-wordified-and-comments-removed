"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
profileStorage
"
]
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
formautofill
/
FormAutofillUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
JSONFile
"
"
resource
:
/
/
gre
/
modules
/
JSONFile
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
FormAutofillNameUtils
"
"
resource
:
/
/
formautofill
/
FormAutofillNameUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
gUUIDGenerator
"
"
mozilla
.
org
/
uuid
-
generator
;
1
"
"
nsIUUIDGenerator
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
REGION_NAMES
"
function
(
)
{
let
regionNames
=
{
}
;
let
countries
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
global
/
locale
/
regionNames
.
properties
"
)
.
getSimpleEnumeration
(
)
;
while
(
countries
.
hasMoreElements
(
)
)
{
let
country
=
countries
.
getNext
(
)
.
QueryInterface
(
Components
.
interfaces
.
nsIPropertyElement
)
;
regionNames
[
country
.
key
.
toUpperCase
(
)
]
=
country
.
value
;
}
return
regionNames
;
}
)
;
const
PROFILE_JSON_FILE_NAME
=
"
autofill
-
profiles
.
json
"
;
const
STORAGE_SCHEMA_VERSION
=
1
;
const
ADDRESS_SCHEMA_VERSION
=
1
;
const
CREDIT_CARD_SCHEMA_VERSION
=
1
;
const
VALID_PROFILE_FIELDS
=
[
"
given
-
name
"
"
additional
-
name
"
"
family
-
name
"
"
organization
"
"
street
-
address
"
"
address
-
level2
"
"
address
-
level1
"
"
postal
-
code
"
"
country
"
"
tel
"
"
email
"
]
;
const
VALID_CREDIT_CARD_FIELDS
=
[
"
cc
-
name
"
"
cc
-
number
-
encrypted
"
"
cc
-
number
-
masked
"
"
cc
-
exp
-
month
"
"
cc
-
exp
-
year
"
]
;
const
INTERNAL_FIELDS
=
[
"
guid
"
"
version
"
"
timeCreated
"
"
timeLastUsed
"
"
timeLastModified
"
"
timesUsed
"
]
;
class
AutofillRecords
{
constructor
(
store
collectionName
validFields
schemaVersion
)
{
FormAutofillUtils
.
defineLazyLogGetter
(
this
"
AutofillRecords
:
"
+
collectionName
)
;
this
.
VALID_FIELDS
=
validFields
;
this
.
_store
=
store
;
this
.
_collectionName
=
collectionName
;
this
.
_schemaVersion
=
schemaVersion
;
}
get
version
(
)
{
return
this
.
_schemaVersion
;
}
add
(
record
)
{
this
.
log
.
debug
(
"
add
:
"
record
)
;
let
recordToSave
=
this
.
_clone
(
record
)
;
this
.
_normalizeRecord
(
recordToSave
)
;
let
guid
;
while
(
!
guid
|
|
this
.
_findByGUID
(
guid
)
)
{
guid
=
gUUIDGenerator
.
generateUUID
(
)
.
toString
(
)
.
replace
(
/
[
{
}
-
]
/
g
"
"
)
.
substring
(
0
12
)
;
}
recordToSave
.
guid
=
guid
;
recordToSave
.
version
=
this
.
version
;
let
now
=
Date
.
now
(
)
;
recordToSave
.
timeCreated
=
now
;
recordToSave
.
timeLastModified
=
now
;
recordToSave
.
timeLastUsed
=
0
;
recordToSave
.
timesUsed
=
0
;
this
.
_store
.
data
[
this
.
_collectionName
]
.
push
(
recordToSave
)
;
this
.
_store
.
saveSoon
(
)
;
Services
.
obs
.
notifyObservers
(
null
"
formautofill
-
storage
-
changed
"
"
add
"
)
;
return
recordToSave
.
guid
;
}
update
(
guid
record
)
{
this
.
log
.
debug
(
"
update
:
"
guid
record
)
;
let
recordFound
=
this
.
_findByGUID
(
guid
)
;
if
(
!
recordFound
)
{
throw
new
Error
(
"
No
matching
record
.
"
)
;
}
let
recordToUpdate
=
this
.
_clone
(
record
)
;
this
.
_normalizeRecord
(
recordToUpdate
)
;
for
(
let
field
of
this
.
VALID_FIELDS
)
{
if
(
recordToUpdate
[
field
]
!
=
=
undefined
)
{
recordFound
[
field
]
=
recordToUpdate
[
field
]
;
}
else
{
delete
recordFound
[
field
]
;
}
}
recordFound
.
timeLastModified
=
Date
.
now
(
)
;
this
.
_store
.
saveSoon
(
)
;
Services
.
obs
.
notifyObservers
(
null
"
formautofill
-
storage
-
changed
"
"
update
"
)
;
}
notifyUsed
(
guid
)
{
this
.
log
.
debug
(
"
notifyUsed
:
"
guid
)
;
let
recordFound
=
this
.
_findByGUID
(
guid
)
;
if
(
!
recordFound
)
{
throw
new
Error
(
"
No
matching
record
.
"
)
;
}
recordFound
.
timesUsed
+
+
;
recordFound
.
timeLastUsed
=
Date
.
now
(
)
;
this
.
_store
.
saveSoon
(
)
;
Services
.
obs
.
notifyObservers
(
null
"
formautofill
-
storage
-
changed
"
"
notifyUsed
"
)
;
}
remove
(
guid
)
{
this
.
log
.
debug
(
"
remove
:
"
guid
)
;
this
.
_store
.
data
[
this
.
_collectionName
]
=
this
.
_store
.
data
[
this
.
_collectionName
]
.
filter
(
record
=
>
record
.
guid
!
=
guid
)
;
this
.
_store
.
saveSoon
(
)
;
Services
.
obs
.
notifyObservers
(
null
"
formautofill
-
storage
-
changed
"
"
remove
"
)
;
}
get
(
guid
)
{
this
.
log
.
debug
(
"
get
:
"
guid
)
;
let
recordFound
=
this
.
_findByGUID
(
guid
)
;
if
(
!
recordFound
)
{
return
null
;
}
let
clonedRecord
=
this
.
_clone
(
recordFound
)
;
this
.
_recordReadProcessor
(
clonedRecord
)
;
return
clonedRecord
;
}
getAll
(
config
=
{
}
)
{
this
.
log
.
debug
(
"
getAll
"
config
)
;
let
clonedRecords
=
this
.
_store
.
data
[
this
.
_collectionName
]
.
map
(
this
.
_clone
)
;
clonedRecords
.
forEach
(
record
=
>
this
.
_recordReadProcessor
(
record
config
)
)
;
return
clonedRecords
;
}
getByFilter
(
{
info
searchString
}
)
{
this
.
log
.
debug
(
"
getByFilter
:
"
info
searchString
)
;
let
lcSearchString
=
searchString
.
toLowerCase
(
)
;
let
result
=
this
.
getAll
(
)
.
filter
(
record
=
>
{
let
name
=
record
[
info
.
fieldName
]
;
if
(
!
searchString
)
{
return
!
!
name
;
}
return
name
&
&
name
.
toLowerCase
(
)
.
startsWith
(
lcSearchString
)
;
}
)
;
this
.
log
.
debug
(
"
getByFilter
:
"
"
Returning
"
result
.
length
"
result
(
s
)
"
)
;
return
result
;
}
_clone
(
record
)
{
return
Object
.
assign
(
{
}
record
)
;
}
_findByGUID
(
guid
)
{
let
found
=
this
.
_findIndexByGUID
(
guid
)
;
return
found
<
0
?
undefined
:
this
.
_store
.
data
[
this
.
_collectionName
]
[
found
]
;
}
_findIndexByGUID
(
guid
)
{
return
this
.
_store
.
data
[
this
.
_collectionName
]
.
findIndex
(
record
=
>
record
.
guid
=
=
guid
)
;
}
_normalizeRecord
(
record
)
{
this
.
_recordWriteProcessor
(
record
)
;
for
(
let
key
in
record
)
{
if
(
!
this
.
VALID_FIELDS
.
includes
(
key
)
)
{
throw
new
Error
(
"
{
key
}
"
is
not
a
valid
field
.
)
;
}
if
(
typeof
record
[
key
]
!
=
=
"
string
"
&
&
typeof
record
[
key
]
!
=
=
"
number
"
)
{
throw
new
Error
(
"
{
key
}
"
contains
invalid
data
type
.
)
;
}
}
}
_recordReadProcessor
(
record
config
)
{
}
_recordWriteProcessor
(
record
)
{
}
mergeIfPossible
(
guid
record
)
{
}
mergeToStorage
(
targetRecord
)
{
}
}
class
Addresses
extends
AutofillRecords
{
constructor
(
store
)
{
super
(
store
"
addresses
"
VALID_PROFILE_FIELDS
ADDRESS_SCHEMA_VERSION
)
;
}
_recordReadProcessor
(
profile
{
noComputedFields
}
=
{
}
)
{
if
(
noComputedFields
)
{
return
;
}
let
name
=
FormAutofillNameUtils
.
joinNameParts
(
{
given
:
profile
[
"
given
-
name
"
]
middle
:
profile
[
"
additional
-
name
"
]
family
:
profile
[
"
family
-
name
"
]
}
)
;
if
(
name
)
{
profile
.
name
=
name
;
}
if
(
profile
[
"
street
-
address
"
]
)
{
let
streetAddress
=
profile
[
"
street
-
address
"
]
.
split
(
"
\
n
"
)
.
map
(
s
=
>
s
.
trim
(
)
)
;
for
(
let
i
=
0
;
i
<
2
;
i
+
+
)
{
if
(
streetAddress
[
i
]
)
{
profile
[
"
address
-
line
"
+
(
i
+
1
)
]
=
streetAddress
[
i
]
;
}
}
if
(
streetAddress
.
length
>
2
)
{
profile
[
"
address
-
line3
"
]
=
FormAutofillUtils
.
toOneLineAddress
(
streetAddress
.
splice
(
2
)
)
;
}
}
if
(
profile
.
country
)
{
if
(
profile
.
country
=
=
"
US
"
)
{
let
countryName
=
REGION_NAMES
[
profile
.
country
]
;
if
(
countryName
)
{
profile
[
"
country
-
name
"
]
=
countryName
;
}
}
else
{
delete
profile
.
country
;
}
}
}
_recordWriteProcessor
(
profile
)
{
if
(
profile
.
name
)
{
let
nameParts
=
FormAutofillNameUtils
.
splitName
(
profile
.
name
)
;
if
(
!
profile
[
"
given
-
name
"
]
&
&
nameParts
.
given
)
{
profile
[
"
given
-
name
"
]
=
nameParts
.
given
;
}
if
(
!
profile
[
"
additional
-
name
"
]
&
&
nameParts
.
middle
)
{
profile
[
"
additional
-
name
"
]
=
nameParts
.
middle
;
}
if
(
!
profile
[
"
family
-
name
"
]
&
&
nameParts
.
family
)
{
profile
[
"
family
-
name
"
]
=
nameParts
.
family
;
}
delete
profile
.
name
;
}
if
(
profile
[
"
address
-
line1
"
]
|
|
profile
[
"
address
-
line2
"
]
|
|
profile
[
"
address
-
line3
"
]
)
{
if
(
!
profile
[
"
address
-
line1
"
]
&
&
profile
[
"
street
-
address
"
]
&
&
!
profile
[
"
street
-
address
"
]
.
includes
(
"
\
n
"
)
)
{
profile
[
"
address
-
line1
"
]
=
profile
[
"
street
-
address
"
]
;
delete
profile
[
"
street
-
address
"
]
;
}
let
addressLines
=
[
1
2
3
]
.
map
(
i
=
>
{
let
value
=
profile
[
"
address
-
line
"
+
i
]
;
delete
profile
[
"
address
-
line
"
+
i
]
;
return
value
;
}
)
;
if
(
!
profile
[
"
street
-
address
"
]
)
{
profile
[
"
street
-
address
"
]
=
addressLines
.
join
(
"
\
n
"
)
;
}
}
if
(
profile
.
country
)
{
let
country
=
profile
.
country
.
toUpperCase
(
)
;
if
(
REGION_NAMES
[
country
]
)
{
profile
.
country
=
country
;
}
else
{
delete
profile
.
country
;
}
}
else
if
(
profile
[
"
country
-
name
"
]
)
{
for
(
let
region
in
REGION_NAMES
)
{
if
(
REGION_NAMES
[
region
]
.
toLowerCase
(
)
=
=
profile
[
"
country
-
name
"
]
.
toLowerCase
(
)
)
{
profile
.
country
=
region
;
break
;
}
}
}
delete
profile
[
"
country
-
name
"
]
;
}
mergeIfPossible
(
guid
address
)
{
this
.
log
.
debug
(
"
mergeIfPossible
:
"
guid
address
)
;
let
addressFound
=
this
.
_findByGUID
(
guid
)
;
if
(
!
addressFound
)
{
throw
new
Error
(
"
No
matching
address
.
"
)
;
}
let
addressToMerge
=
this
.
_clone
(
address
)
;
this
.
_normalizeRecord
(
addressToMerge
)
;
let
hasMatchingField
=
false
;
for
(
let
field
of
this
.
VALID_FIELDS
)
{
if
(
addressToMerge
[
field
]
!
=
=
undefined
&
&
addressFound
[
field
]
!
=
=
undefined
)
{
if
(
addressToMerge
[
field
]
!
=
addressFound
[
field
]
)
{
this
.
log
.
debug
(
"
Conflicts
:
field
"
field
"
has
different
value
.
"
)
;
return
false
;
}
hasMatchingField
=
true
;
}
}
if
(
!
hasMatchingField
)
{
this
.
log
.
debug
(
"
Unable
to
merge
because
no
field
has
the
same
value
"
)
;
return
false
;
}
let
exactlyMatch
=
this
.
VALID_FIELDS
.
every
(
(
field
)
=
>
addressFound
[
field
]
=
=
=
addressToMerge
[
field
]
)
;
if
(
exactlyMatch
)
{
return
true
;
}
for
(
let
field
in
addressToMerge
)
{
if
(
this
.
VALID_FIELDS
.
includes
(
field
)
)
{
addressFound
[
field
]
=
addressToMerge
[
field
]
;
}
}
addressFound
.
timeLastModified
=
Date
.
now
(
)
;
this
.
_store
.
saveSoon
(
)
;
let
str
=
Cc
[
"
mozilla
.
org
/
supports
-
string
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsString
)
;
str
.
data
=
guid
;
Services
.
obs
.
notifyObservers
(
str
"
formautofill
-
storage
-
changed
"
"
merge
"
)
;
return
true
;
}
mergeToStorage
(
targetAddress
)
{
let
mergedGUIDs
=
[
]
;
for
(
let
address
of
this
.
_store
.
data
[
this
.
_collectionName
]
)
{
if
(
this
.
mergeIfPossible
(
address
.
guid
targetAddress
)
)
{
mergedGUIDs
.
push
(
address
.
guid
)
;
}
}
this
.
log
.
debug
(
"
Existing
records
matching
and
merging
count
is
"
mergedGUIDs
.
length
)
;
return
mergedGUIDs
;
}
}
class
CreditCards
extends
AutofillRecords
{
constructor
(
store
)
{
super
(
store
"
creditCards
"
VALID_CREDIT_CARD_FIELDS
CREDIT_CARD_SCHEMA_VERSION
)
;
}
_recordReadProcessor
(
creditCard
{
noComputedFields
}
=
{
}
)
{
if
(
noComputedFields
)
{
return
;
}
if
(
creditCard
[
"
cc
-
name
"
]
)
{
let
nameParts
=
FormAutofillNameUtils
.
splitName
(
creditCard
[
"
cc
-
name
"
]
)
;
if
(
nameParts
.
given
)
{
creditCard
[
"
cc
-
given
-
name
"
]
=
nameParts
.
given
;
}
if
(
nameParts
.
middle
)
{
creditCard
[
"
cc
-
additional
-
name
"
]
=
nameParts
.
middle
;
}
if
(
nameParts
.
family
)
{
creditCard
[
"
cc
-
family
-
name
"
]
=
nameParts
.
family
;
}
}
}
_recordWriteProcessor
(
creditCard
)
{
delete
creditCard
[
"
cc
-
number
-
encrypted
"
]
;
delete
creditCard
[
"
cc
-
number
-
masked
"
]
;
if
(
creditCard
[
"
cc
-
number
"
]
)
{
let
ccNumber
=
creditCard
[
"
cc
-
number
"
]
.
replace
(
/
\
s
/
g
"
"
)
;
delete
creditCard
[
"
cc
-
number
"
]
;
if
(
!
/
^
\
d
+
/
.
test
(
ccNumber
)
)
{
throw
new
Error
(
"
Credit
card
number
contains
invalid
characters
.
"
)
;
}
if
(
ccNumber
.
length
>
4
)
{
creditCard
[
"
cc
-
number
-
masked
"
]
=
"
*
"
.
repeat
(
ccNumber
.
length
-
4
)
+
ccNumber
.
substr
(
-
4
)
;
}
else
{
creditCard
[
"
cc
-
number
-
masked
"
]
=
ccNumber
;
}
}
if
(
creditCard
[
"
cc
-
given
-
name
"
]
|
|
creditCard
[
"
cc
-
additional
-
name
"
]
|
|
creditCard
[
"
cc
-
family
-
name
"
]
)
{
if
(
!
creditCard
[
"
cc
-
name
"
]
)
{
creditCard
[
"
cc
-
name
"
]
=
FormAutofillNameUtils
.
joinNameParts
(
{
given
:
creditCard
[
"
cc
-
given
-
name
"
]
middle
:
creditCard
[
"
cc
-
additional
-
name
"
]
family
:
creditCard
[
"
cc
-
family
-
name
"
]
}
)
;
}
delete
creditCard
[
"
cc
-
given
-
name
"
]
;
delete
creditCard
[
"
cc
-
additional
-
name
"
]
;
delete
creditCard
[
"
cc
-
family
-
name
"
]
;
}
if
(
creditCard
[
"
cc
-
exp
-
month
"
]
)
{
let
expMonth
=
parseInt
(
creditCard
[
"
cc
-
exp
-
month
"
]
10
)
;
if
(
isNaN
(
expMonth
)
|
|
expMonth
<
1
|
|
expMonth
>
12
)
{
delete
creditCard
[
"
cc
-
exp
-
month
"
]
;
}
else
{
creditCard
[
"
cc
-
exp
-
month
"
]
=
expMonth
;
}
}
if
(
creditCard
[
"
cc
-
exp
-
year
"
]
)
{
let
expYear
=
parseInt
(
creditCard
[
"
cc
-
exp
-
year
"
]
10
)
;
if
(
isNaN
(
expYear
)
|
|
expYear
<
0
)
{
delete
creditCard
[
"
cc
-
exp
-
year
"
]
;
}
else
if
(
expYear
<
100
)
{
creditCard
[
"
cc
-
exp
-
year
"
]
=
expYear
+
2000
;
}
else
{
creditCard
[
"
cc
-
exp
-
year
"
]
=
expYear
;
}
}
}
}
function
ProfileStorage
(
path
)
{
this
.
_path
=
path
;
this
.
_initializePromise
=
null
;
this
.
INTERNAL_FIELDS
=
INTERNAL_FIELDS
;
}
ProfileStorage
.
prototype
=
{
get
version
(
)
{
return
STORAGE_SCHEMA_VERSION
;
}
get
addresses
(
)
{
if
(
!
this
.
_addresses
)
{
this
.
_store
.
ensureDataReady
(
)
;
this
.
_addresses
=
new
Addresses
(
this
.
_store
)
;
}
return
this
.
_addresses
;
}
get
creditCards
(
)
{
if
(
!
this
.
_creditCards
)
{
this
.
_store
.
ensureDataReady
(
)
;
this
.
_creditCards
=
new
CreditCards
(
this
.
_store
)
;
}
return
this
.
_creditCards
;
}
initialize
(
)
{
if
(
!
this
.
_initializePromise
)
{
this
.
_store
=
new
JSONFile
(
{
path
:
this
.
_path
dataPostProcessor
:
this
.
_dataPostProcessor
.
bind
(
this
)
}
)
;
this
.
_initializePromise
=
this
.
_store
.
load
(
)
;
}
return
this
.
_initializePromise
;
}
_dataPostProcessor
(
data
)
{
data
.
version
=
this
.
version
;
if
(
!
data
.
addresses
)
{
data
.
addresses
=
[
]
;
}
if
(
!
data
.
creditCards
)
{
data
.
creditCards
=
[
]
;
}
return
data
;
}
_saveImmediately
(
)
{
return
this
.
_store
.
_save
(
)
;
}
}
;
this
.
profileStorage
=
new
ProfileStorage
(
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
PROFILE_JSON_FILE_NAME
)
)
;
