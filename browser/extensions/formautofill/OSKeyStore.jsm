"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
OSKeyStore
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
AppConstants
"
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
nativeOSKeyStore
"
"
mozilla
.
org
/
security
/
oskeystore
;
1
"
Ci
.
nsIOSKeyStore
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
osReauthenticator
"
"
mozilla
.
org
/
security
/
osreauthenticator
;
1
"
Ci
.
nsIOSReauthenticator
)
;
const
TEST_ONLY_REAUTH
=
"
extensions
.
formautofill
.
osKeyStore
.
unofficialBuildOnlyLogin
"
;
var
OSKeyStore
=
{
STORE_LABEL
:
AppConstants
.
MOZ_APP_NAME
_isLocked
:
true
_pendingUnlockPromise
:
null
get
isLoggedIn
(
)
{
return
!
this
.
_isLocked
;
}
get
isUIBusy
(
)
{
return
!
!
this
.
_pendingUnlockPromise
;
}
async
_reauthInTests
(
)
{
log
.
debug
(
"
_ensureReauth
:
_testReauth
:
"
this
.
_testReauth
)
;
switch
(
this
.
_testReauth
)
{
case
"
pass
"
:
Services
.
obs
.
notifyObservers
(
null
"
oskeystore
-
testonly
-
reauth
"
"
pass
"
)
;
break
;
case
"
cancel
"
:
Services
.
obs
.
notifyObservers
(
null
"
oskeystore
-
testonly
-
reauth
"
"
cancel
"
)
;
throw
new
Components
.
Exception
(
"
Simulating
user
cancelling
login
dialog
"
Cr
.
NS_ERROR_FAILURE
)
;
default
:
throw
new
Components
.
Exception
(
"
Unknown
test
pref
value
"
Cr
.
NS_ERROR_FAILURE
)
;
}
}
async
ensureLoggedIn
(
reauth
=
false
)
{
if
(
this
.
_pendingUnlockPromise
)
{
log
.
debug
(
"
ensureLoggedIn
:
Has
a
pending
unlock
operation
"
)
;
return
this
.
_pendingUnlockPromise
;
}
log
.
debug
(
"
ensureLoggedIn
:
Creating
new
pending
unlock
promise
.
reauth
:
"
reauth
)
;
let
unlockPromise
;
if
(
!
this
.
_reauthEnabledByUser
|
|
(
typeof
reauth
=
=
"
boolean
"
&
&
!
reauth
)
)
{
unlockPromise
=
Promise
.
resolve
(
)
;
}
else
if
(
!
AppConstants
.
MOZILLA_OFFICIAL
&
&
this
.
_testReauth
)
{
unlockPromise
=
this
.
_reauthInTests
(
)
;
}
else
if
(
AppConstants
.
platform
=
=
"
win
"
|
|
AppConstants
.
platform
=
=
"
macosx
"
)
{
let
reauthLabel
=
typeof
reauth
=
=
"
string
"
?
reauth
:
"
"
;
unlockPromise
=
osReauthenticator
.
asyncReauthenticateUser
(
reauthLabel
)
.
then
(
reauthResult
=
>
{
if
(
typeof
reauthResult
=
=
"
boolean
"
&
&
!
reauthResult
)
{
throw
new
Components
.
Exception
(
"
User
canceled
OS
reauth
entry
"
Cr
.
NS_ERROR_FAILURE
)
;
}
}
)
;
}
else
{
log
.
debug
(
"
ensureLoggedIn
:
Skipping
reauth
on
unsupported
platforms
"
)
;
unlockPromise
=
Promise
.
resolve
(
)
;
}
unlockPromise
=
unlockPromise
.
then
(
async
(
)
=
>
{
if
(
!
await
nativeOSKeyStore
.
asyncSecretAvailable
(
this
.
STORE_LABEL
)
)
{
log
.
debug
(
"
ensureLoggedIn
:
Secret
unavailable
attempt
to
generate
new
secret
.
"
)
;
let
recoveryPhrase
=
await
nativeOSKeyStore
.
asyncGenerateSecret
(
this
.
STORE_LABEL
)
;
log
.
debug
(
"
ensureLoggedIn
:
Secret
generated
.
Recovery
phrase
length
:
"
+
recoveryPhrase
.
length
)
;
}
}
)
;
if
(
nativeOSKeyStore
.
isNSSKeyStore
)
{
unlockPromise
=
unlockPromise
.
then
(
(
)
=
>
{
log
.
debug
(
"
ensureLoggedIn
:
isNSSKeyStore
:
"
reauth
Services
.
logins
.
isLoggedIn
)
;
if
(
!
Services
.
logins
.
isLoggedIn
)
{
throw
Components
.
Exception
(
"
User
canceled
OS
unlock
entry
(
Workaround
)
"
Cr
.
NS_ERROR_FAILURE
)
;
}
}
)
;
}
unlockPromise
=
unlockPromise
.
then
(
(
)
=
>
{
log
.
debug
(
"
ensureLoggedIn
:
Logged
in
"
)
;
this
.
_pendingUnlockPromise
=
null
;
this
.
_isLocked
=
false
;
return
true
;
}
(
err
)
=
>
{
log
.
debug
(
"
ensureLoggedIn
:
Not
logged
in
"
err
)
;
this
.
_pendingUnlockPromise
=
null
;
this
.
_isLocked
=
true
;
return
false
;
}
)
;
this
.
_pendingUnlockPromise
=
unlockPromise
;
return
this
.
_pendingUnlockPromise
;
}
async
decrypt
(
cipherText
reauth
=
false
)
{
if
(
!
await
this
.
ensureLoggedIn
(
reauth
)
)
{
throw
Components
.
Exception
(
"
User
canceled
OS
unlock
entry
"
Cr
.
NS_ERROR_ABORT
)
;
}
let
bytes
=
await
nativeOSKeyStore
.
asyncDecryptBytes
(
this
.
STORE_LABEL
cipherText
)
;
return
String
.
fromCharCode
.
apply
(
String
bytes
)
;
}
async
encrypt
(
plainText
)
{
if
(
!
await
this
.
ensureLoggedIn
(
)
)
{
throw
Components
.
Exception
(
"
User
canceled
OS
unlock
entry
"
Cr
.
NS_ERROR_ABORT
)
;
}
plainText
=
unescape
(
encodeURIComponent
(
plainText
)
)
;
let
textArr
=
[
]
;
for
(
let
char
of
plainText
)
{
textArr
.
push
(
char
.
charCodeAt
(
0
)
)
;
}
let
rawEncryptedText
=
await
nativeOSKeyStore
.
asyncEncryptBytes
(
this
.
STORE_LABEL
textArr
.
length
textArr
)
;
return
rawEncryptedText
;
}
async
waitForExistingDialog
(
)
{
if
(
this
.
isUIBusy
)
{
return
this
.
_pendingUnlockPromise
;
}
return
this
.
isLoggedIn
;
}
async
cleanup
(
)
{
return
nativeOSKeyStore
.
asyncDeleteSecret
(
this
.
STORE_LABEL
)
;
}
}
;
XPCOMUtils
.
defineLazyGetter
(
this
"
log
"
(
)
=
>
{
let
ConsoleAPI
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Console
.
jsm
"
{
}
)
.
ConsoleAPI
;
return
new
ConsoleAPI
(
{
maxLogLevelPref
:
"
extensions
.
formautofill
.
loglevel
"
prefix
:
"
OSKeyStore
"
}
)
;
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
OSKeyStore
"
_testReauth
"
TEST_ONLY_REAUTH
"
"
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
OSKeyStore
"
_reauthEnabledByUser
"
"
extensions
.
formautofill
.
reauth
.
enabled
"
false
)
;
