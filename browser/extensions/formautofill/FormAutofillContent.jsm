"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
FormAutofillContent
"
]
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
manager
:
Cm
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
formautofill
/
FormAutofillUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
ProfileAutoCompleteResult
"
"
resource
:
/
/
formautofill
/
ProfileAutoCompleteResult
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
FormAutofillHandler
"
"
resource
:
/
/
formautofill
/
FormAutofillHandler
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
FormLikeFactory
"
"
resource
:
/
/
gre
/
modules
/
FormLikeFactory
.
jsm
"
)
;
const
formFillController
=
Cc
[
"
mozilla
.
org
/
satchel
/
form
-
fill
-
controller
;
1
"
]
.
getService
(
Ci
.
nsIFormFillController
)
;
const
AUTOFILL_FIELDS_THRESHOLD
=
3
;
function
AutocompleteFactory
(
)
{
}
AutocompleteFactory
.
prototype
=
{
register
(
targetConstructor
)
{
let
proto
=
targetConstructor
.
prototype
;
this
.
_classID
=
proto
.
classID
;
let
factory
=
XPCOMUtils
.
_getFactory
(
targetConstructor
)
;
this
.
_factory
=
factory
;
let
registrar
=
Cm
.
QueryInterface
(
Ci
.
nsIComponentRegistrar
)
;
registrar
.
registerFactory
(
proto
.
classID
proto
.
classDescription
proto
.
contractID
factory
)
;
if
(
proto
.
classID2
)
{
this
.
_classID2
=
proto
.
classID2
;
registrar
.
registerFactory
(
proto
.
classID2
proto
.
classDescription
proto
.
contractID2
factory
)
;
}
}
unregister
(
)
{
let
registrar
=
Cm
.
QueryInterface
(
Ci
.
nsIComponentRegistrar
)
;
registrar
.
unregisterFactory
(
this
.
_classID
this
.
_factory
)
;
if
(
this
.
_classID2
)
{
registrar
.
unregisterFactory
(
this
.
_classID2
this
.
_factory
)
;
}
this
.
_factory
=
null
;
}
}
;
function
AutofillProfileAutoCompleteSearch
(
)
{
FormAutofillUtils
.
defineLazyLogGetter
(
this
"
AutofillProfileAutoCompleteSearch
"
)
;
}
AutofillProfileAutoCompleteSearch
.
prototype
=
{
classID
:
Components
.
ID
(
"
4f9f1e4c
-
7f2c
-
439e
-
9c9e
-
566b68bc187d
"
)
contractID
:
"
mozilla
.
org
/
autocomplete
/
search
;
1
?
name
=
autofill
-
profiles
"
classDescription
:
"
AutofillProfileAutoCompleteSearch
"
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIAutoCompleteSearch
]
)
startSearch
(
searchString
searchParam
previousResult
listener
)
{
this
.
log
.
debug
(
"
startSearch
:
for
"
searchString
"
with
input
"
formFillController
.
focusedInput
)
;
let
focusedInput
=
formFillController
.
focusedInput
;
this
.
forceStop
=
false
;
let
info
=
FormAutofillContent
.
getInputDetails
(
focusedInput
)
;
if
(
!
FormAutofillContent
.
savedFieldNames
.
has
(
info
.
fieldName
)
|
|
FormAutofillContent
.
getFormHandler
(
focusedInput
)
.
filledProfileGUID
)
{
let
formHistory
=
Cc
[
"
mozilla
.
org
/
autocomplete
/
search
;
1
?
name
=
form
-
history
"
]
.
createInstance
(
Ci
.
nsIAutoCompleteSearch
)
;
formHistory
.
startSearch
(
searchString
searchParam
previousResult
{
onSearchResult
:
(
search
result
)
=
>
{
listener
.
onSearchResult
(
this
result
)
;
ProfileAutocomplete
.
setProfileAutoCompleteResult
(
result
)
;
}
}
)
;
return
;
}
this
.
_getAddresses
(
{
info
searchString
}
)
.
then
(
(
addresses
)
=
>
{
if
(
this
.
forceStop
)
{
return
;
}
addresses
.
sort
(
(
a
b
)
=
>
b
.
timeLastUsed
-
a
.
timeLastUsed
)
;
let
handler
=
FormAutofillContent
.
getFormHandler
(
focusedInput
)
;
let
adaptedAddresses
=
handler
.
getAdaptedProfiles
(
addresses
)
;
let
allFieldNames
=
FormAutofillContent
.
getAllFieldNames
(
focusedInput
)
;
let
result
=
new
ProfileAutoCompleteResult
(
searchString
info
.
fieldName
allFieldNames
adaptedAddresses
{
}
)
;
listener
.
onSearchResult
(
this
result
)
;
ProfileAutocomplete
.
setProfileAutoCompleteResult
(
result
)
;
}
)
;
}
stopSearch
(
)
{
ProfileAutocomplete
.
setProfileAutoCompleteResult
(
null
)
;
this
.
forceStop
=
true
;
}
_getAddresses
(
data
)
{
this
.
log
.
debug
(
"
_getAddresses
with
data
:
"
data
)
;
return
new
Promise
(
(
resolve
)
=
>
{
Services
.
cpmm
.
addMessageListener
(
"
FormAutofill
:
Addresses
"
function
getResult
(
result
)
{
Services
.
cpmm
.
removeMessageListener
(
"
FormAutofill
:
Addresses
"
getResult
)
;
resolve
(
result
.
data
)
;
}
)
;
Services
.
cpmm
.
sendAsyncMessage
(
"
FormAutofill
:
GetAddresses
"
data
)
;
}
)
;
}
}
;
this
.
NSGetFactory
=
XPCOMUtils
.
generateNSGetFactory
(
[
AutofillProfileAutoCompleteSearch
]
)
;
let
ProfileAutocomplete
=
{
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIObserver
]
)
_lastAutoCompleteResult
:
null
_lastAutoCompleteFocusedInput
:
null
_registered
:
false
_factory
:
null
ensureRegistered
(
)
{
if
(
this
.
_registered
)
{
return
;
}
FormAutofillUtils
.
defineLazyLogGetter
(
this
"
ProfileAutocomplete
"
)
;
this
.
log
.
debug
(
"
ensureRegistered
"
)
;
this
.
_factory
=
new
AutocompleteFactory
(
)
;
this
.
_factory
.
register
(
AutofillProfileAutoCompleteSearch
)
;
this
.
_registered
=
true
;
Services
.
obs
.
addObserver
(
this
"
autocomplete
-
will
-
enter
-
text
"
)
;
}
ensureUnregistered
(
)
{
if
(
!
this
.
_registered
)
{
return
;
}
this
.
log
.
debug
(
"
ensureUnregistered
"
)
;
this
.
_factory
.
unregister
(
)
;
this
.
_factory
=
null
;
this
.
_registered
=
false
;
this
.
_lastAutoCompleteResult
=
null
;
Services
.
obs
.
removeObserver
(
this
"
autocomplete
-
will
-
enter
-
text
"
)
;
}
getProfileAutoCompleteResult
(
)
{
return
this
.
_lastAutoCompleteResult
;
}
setProfileAutoCompleteResult
(
result
)
{
this
.
_lastAutoCompleteResult
=
result
;
this
.
_lastAutoCompleteFocusedInput
=
formFillController
.
focusedInput
;
}
observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
"
autocomplete
-
will
-
enter
-
text
"
:
{
if
(
!
formFillController
.
focusedInput
)
{
break
;
}
this
.
_fillFromAutocompleteRow
(
formFillController
.
focusedInput
)
;
break
;
}
}
}
_frameMMFromWindow
(
contentWindow
)
{
return
contentWindow
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDocShell
)
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIContentFrameMessageManager
)
;
}
_getSelectedIndex
(
contentWindow
)
{
let
mm
=
this
.
_frameMMFromWindow
(
contentWindow
)
;
let
selectedIndexResult
=
mm
.
sendSyncMessage
(
"
FormAutoComplete
:
GetSelectedIndex
"
{
}
)
;
if
(
selectedIndexResult
.
length
!
=
1
|
|
!
Number
.
isInteger
(
selectedIndexResult
[
0
]
)
)
{
throw
new
Error
(
"
Invalid
autocomplete
selectedIndex
"
)
;
}
return
selectedIndexResult
[
0
]
;
}
_fillFromAutocompleteRow
(
focusedInput
)
{
this
.
log
.
debug
(
"
_fillFromAutocompleteRow
:
"
focusedInput
)
;
let
formDetails
=
FormAutofillContent
.
getFormDetails
(
focusedInput
)
;
if
(
!
formDetails
)
{
return
;
}
let
selectedIndex
=
this
.
_getSelectedIndex
(
focusedInput
.
ownerGlobal
)
;
if
(
selectedIndex
=
=
-
1
|
|
!
this
.
_lastAutoCompleteResult
|
|
this
.
_lastAutoCompleteResult
.
getStyleAt
(
selectedIndex
)
!
=
"
autofill
-
profile
"
)
{
return
;
}
let
profile
=
JSON
.
parse
(
this
.
_lastAutoCompleteResult
.
getCommentAt
(
selectedIndex
)
)
;
let
formHandler
=
FormAutofillContent
.
getFormHandler
(
focusedInput
)
;
formHandler
.
autofillFormFields
(
profile
focusedInput
)
;
}
_clearProfilePreview
(
)
{
let
focusedInput
=
formFillController
.
focusedInput
|
|
this
.
_lastAutoCompleteFocusedInput
;
if
(
!
focusedInput
|
|
!
FormAutofillContent
.
getFormDetails
(
focusedInput
)
)
{
return
;
}
let
formHandler
=
FormAutofillContent
.
getFormHandler
(
focusedInput
)
;
formHandler
.
clearPreviewedFormFields
(
)
;
}
_previewSelectedProfile
(
selectedIndex
)
{
let
focusedInput
=
formFillController
.
focusedInput
;
if
(
!
focusedInput
|
|
!
FormAutofillContent
.
getFormDetails
(
focusedInput
)
)
{
return
;
}
if
(
!
this
.
_lastAutoCompleteResult
|
|
this
.
_lastAutoCompleteResult
.
getStyleAt
(
selectedIndex
)
!
=
"
autofill
-
profile
"
)
{
return
;
}
let
profile
=
JSON
.
parse
(
this
.
_lastAutoCompleteResult
.
getCommentAt
(
selectedIndex
)
)
;
let
formHandler
=
FormAutofillContent
.
getFormHandler
(
focusedInput
)
;
formHandler
.
previewFormFields
(
profile
)
;
}
}
;
var
FormAutofillContent
=
{
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIFormSubmitObserver
]
)
_formsDetails
:
new
WeakMap
(
)
savedFieldNames
:
null
init
(
)
{
FormAutofillUtils
.
defineLazyLogGetter
(
this
"
FormAutofillContent
"
)
;
Services
.
cpmm
.
addMessageListener
(
"
FormAutofill
:
enabledStatus
"
this
)
;
Services
.
cpmm
.
addMessageListener
(
"
FormAutofill
:
savedFieldNames
"
this
)
;
Services
.
obs
.
addObserver
(
this
"
earlyformsubmit
"
)
;
let
autofillEnabled
=
Services
.
cpmm
.
initialProcessData
.
autofillEnabled
;
if
(
autofillEnabled
|
|
(
autofillEnabled
=
=
=
undefined
&
&
Services
.
prefs
.
getBoolPref
(
"
extensions
.
formautofill
.
addresses
.
enabled
"
)
)
)
{
ProfileAutocomplete
.
ensureRegistered
(
)
;
}
this
.
savedFieldNames
=
Services
.
cpmm
.
initialProcessData
.
autofillSavedFieldNames
;
}
_onFormSubmit
(
profile
domWin
)
{
let
mm
=
this
.
_messageManagerFromWindow
(
domWin
)
;
mm
.
sendAsyncMessage
(
"
FormAutofill
:
OnFormSubmit
"
profile
)
;
}
notify
(
formElement
domWin
)
{
this
.
log
.
debug
(
"
Notifying
form
early
submission
"
)
;
if
(
domWin
&
&
PrivateBrowsingUtils
.
isContentWindowPrivate
(
domWin
)
)
{
this
.
log
.
debug
(
"
Ignoring
submission
in
a
private
window
"
)
;
return
true
;
}
let
handler
=
this
.
_formsDetails
.
get
(
formElement
)
;
if
(
!
handler
)
{
this
.
log
.
debug
(
"
Form
element
could
not
map
to
an
existing
handler
"
)
;
return
true
;
}
let
pendingAddress
=
handler
.
createProfile
(
)
;
if
(
Object
.
keys
(
pendingAddress
)
.
length
<
AUTOFILL_FIELDS_THRESHOLD
)
{
this
.
log
.
debug
(
Not
saving
since
there
are
only
{
Object
.
keys
(
pendingAddress
)
.
length
}
usable
fields
)
;
return
true
;
}
this
.
_onFormSubmit
(
{
address
:
{
guid
:
handler
.
filledProfileGUID
record
:
pendingAddress
}
}
domWin
)
;
return
true
;
}
receiveMessage
(
{
name
data
}
)
{
switch
(
name
)
{
case
"
FormAutofill
:
enabledStatus
"
:
{
if
(
data
)
{
ProfileAutocomplete
.
ensureRegistered
(
)
;
}
else
{
ProfileAutocomplete
.
ensureUnregistered
(
)
;
}
break
;
}
case
"
FormAutofill
:
savedFieldNames
"
:
{
this
.
savedFieldNames
=
data
;
}
}
}
getInputDetails
(
element
)
{
let
formDetails
=
this
.
getFormDetails
(
element
)
;
for
(
let
detail
of
formDetails
)
{
let
detailElement
=
detail
.
elementWeakRef
.
get
(
)
;
if
(
detailElement
&
&
element
=
=
detailElement
)
{
return
detail
;
}
}
return
null
;
}
getFormHandler
(
element
)
{
let
rootElement
=
FormLikeFactory
.
findRootForField
(
element
)
;
return
this
.
_formsDetails
.
get
(
rootElement
)
;
}
getFormDetails
(
element
)
{
let
formHandler
=
this
.
getFormHandler
(
element
)
;
return
formHandler
?
formHandler
.
fieldDetails
:
null
;
}
getAllFieldNames
(
element
)
{
let
formHandler
=
this
.
getFormHandler
(
element
)
;
return
formHandler
?
formHandler
.
allFieldNames
:
null
;
}
identifyAutofillFields
(
element
)
{
this
.
log
.
debug
(
"
identifyAutofillFields
:
"
"
"
+
element
.
ownerDocument
.
location
)
;
if
(
!
this
.
savedFieldNames
)
{
this
.
log
.
debug
(
"
identifyAutofillFields
:
savedFieldNames
are
not
known
yet
"
)
;
Services
.
cpmm
.
sendAsyncMessage
(
"
FormAutofill
:
InitStorage
"
)
;
}
if
(
!
FormAutofillUtils
.
isFieldEligibleForAutofill
(
element
)
)
{
this
.
log
.
debug
(
"
Not
an
eligible
field
.
"
)
;
return
;
}
let
formHandler
=
this
.
getFormHandler
(
element
)
;
if
(
!
formHandler
)
{
let
formLike
=
FormLikeFactory
.
createFromField
(
element
)
;
formHandler
=
new
FormAutofillHandler
(
formLike
)
;
}
else
if
(
!
formHandler
.
isFormChangedSinceLastCollection
)
{
this
.
log
.
debug
(
"
No
control
is
removed
or
inserted
since
last
collection
.
"
)
;
return
;
}
formHandler
.
collectFormFields
(
)
;
this
.
_formsDetails
.
set
(
formHandler
.
form
.
rootElement
formHandler
)
;
this
.
log
.
debug
(
"
Adding
form
handler
to
_formsDetails
:
"
formHandler
)
;
if
(
formHandler
.
fieldDetails
.
length
<
AUTOFILL_FIELDS_THRESHOLD
)
{
this
.
log
.
debug
(
"
Ignoring
form
since
it
has
only
"
formHandler
.
fieldDetails
.
length
"
field
(
s
)
"
)
;
return
;
}
formHandler
.
fieldDetails
.
forEach
(
detail
=
>
this
.
_markAsAutofillField
(
detail
.
elementWeakRef
.
get
(
)
)
)
;
}
_markAsAutofillField
(
field
)
{
if
(
!
field
|
|
!
(
field
instanceof
Ci
.
nsIDOMHTMLInputElement
)
)
{
return
;
}
formFillController
.
markAsAutofillField
(
field
)
;
}
_previewProfile
(
doc
)
{
let
selectedIndex
=
ProfileAutocomplete
.
_getSelectedIndex
(
doc
.
ownerGlobal
)
;
let
lastAutoCompleteResult
=
ProfileAutocomplete
.
getProfileAutoCompleteResult
(
)
;
if
(
selectedIndex
=
=
=
-
1
|
|
!
lastAutoCompleteResult
|
|
lastAutoCompleteResult
.
getStyleAt
(
selectedIndex
)
!
=
"
autofill
-
profile
"
)
{
ProfileAutocomplete
.
_clearProfilePreview
(
)
;
}
else
{
ProfileAutocomplete
.
_previewSelectedProfile
(
selectedIndex
)
;
}
}
_messageManagerFromWindow
(
win
)
{
return
win
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebNavigation
)
.
QueryInterface
(
Ci
.
nsIDocShell
)
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIContentFrameMessageManager
)
;
}
_onKeyDown
(
e
)
{
let
lastAutoCompleteResult
=
ProfileAutocomplete
.
getProfileAutoCompleteResult
(
)
;
let
focusedInput
=
formFillController
.
focusedInput
;
if
(
e
.
keyCode
!
=
Ci
.
nsIDOMKeyEvent
.
DOM_VK_RETURN
|
|
!
lastAutoCompleteResult
|
|
!
focusedInput
)
{
return
;
}
let
selectedIndex
=
ProfileAutocomplete
.
_getSelectedIndex
(
e
.
target
.
ownerGlobal
)
;
let
selectedRowStyle
=
lastAutoCompleteResult
.
getStyleAt
(
selectedIndex
)
;
if
(
selectedRowStyle
=
=
"
autofill
-
footer
"
)
{
focusedInput
.
addEventListener
(
"
DOMAutoComplete
"
(
)
=
>
{
Services
.
cpmm
.
sendAsyncMessage
(
"
FormAutofill
:
OpenPreferences
"
)
;
}
{
once
:
true
}
)
;
}
}
}
;
FormAutofillContent
.
init
(
)
;
