"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
PhoneNumber
"
]
;
ChromeUtils
.
defineModuleGetter
(
this
"
PHONE_NUMBER_META_DATA
"
"
resource
:
/
/
formautofill
/
phonenumberutils
/
PhoneNumberMetaData
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PhoneNumberNormalizer
"
"
resource
:
/
/
formautofill
/
phonenumberutils
/
PhoneNumberNormalizer
.
jsm
"
)
;
var
PhoneNumber
=
(
function
(
dataBase
)
{
const
MAX_PHONE_NUMBER_LENGTH
=
50
;
const
NON_ALPHA_CHARS
=
/
[
^
a
-
zA
-
Z
]
/
g
;
const
NON_DIALABLE_CHARS
=
/
[
^
#
+
\
*
\
d
]
/
g
;
const
NON_DIALABLE_CHARS_ONCE
=
new
RegExp
(
NON_DIALABLE_CHARS
.
source
)
;
const
SPLIT_FIRST_GROUP
=
/
^
(
\
d
+
)
(
.
*
)
/
;
const
LEADING_PLUS_CHARS_PATTERN
=
/
^
[
+
\
uFF0B
]
+
/
g
;
const
META_DATA_ENCODING
=
[
"
region
"
"
^
(
?
:
internationalPrefix
)
"
"
nationalPrefix
"
"
^
(
?
:
nationalPrefixForParsing
)
"
"
nationalPrefixTransformRule
"
"
nationalPrefixFormattingRule
"
"
^
possiblePattern
"
"
^
nationalPattern
"
"
formats
"
]
;
const
FORMAT_ENCODING
=
[
"
^
pattern
"
"
nationalFormat
"
"
^
leadingDigits
"
"
nationalPrefixFormattingRule
"
"
internationalFormat
"
]
;
let
regionCache
=
Object
.
create
(
null
)
;
function
ParseArray
(
array
encoding
obj
)
{
for
(
let
n
=
0
;
n
<
encoding
.
length
;
+
+
n
)
{
let
value
=
array
[
n
]
;
if
(
!
value
)
{
continue
;
}
let
field
=
encoding
[
n
]
;
let
fieldAlpha
=
field
.
replace
(
NON_ALPHA_CHARS
"
"
)
;
if
(
field
!
=
fieldAlpha
)
{
value
=
new
RegExp
(
field
.
replace
(
fieldAlpha
value
)
)
;
}
obj
[
fieldAlpha
]
=
value
;
}
return
obj
;
}
function
ParseMetaData
(
countryCode
md
)
{
let
array
=
JSON
.
parse
(
md
)
;
md
=
ParseArray
(
array
META_DATA_ENCODING
{
countryCode
}
)
;
regionCache
[
md
.
region
]
=
md
;
return
md
;
}
function
ParseFormat
(
md
)
{
let
formats
=
md
.
formats
;
if
(
!
formats
)
{
return
;
}
if
(
!
(
Array
.
isArray
(
formats
[
0
]
)
)
)
{
return
;
}
for
(
let
n
=
0
;
n
<
formats
.
length
;
+
+
n
)
{
formats
[
n
]
=
ParseArray
(
formats
[
n
]
FORMAT_ENCODING
{
}
)
;
}
}
function
FindMetaDataForRegion
(
region
)
{
let
md
=
regionCache
[
region
]
;
if
(
md
)
{
return
md
;
}
for
(
let
countryCode
in
dataBase
)
{
let
entry
=
dataBase
[
countryCode
]
;
if
(
Array
.
isArray
(
entry
)
)
{
for
(
let
n
=
0
;
n
<
entry
.
length
;
n
+
+
)
{
if
(
typeof
entry
[
n
]
=
=
"
string
"
&
&
entry
[
n
]
.
substr
(
2
2
)
=
=
region
)
{
if
(
n
>
0
)
{
if
(
typeof
entry
[
0
]
=
=
"
string
"
)
{
entry
[
0
]
=
ParseMetaData
(
countryCode
entry
[
0
]
)
;
}
let
formats
=
entry
[
0
]
.
formats
;
let
current
=
ParseMetaData
(
countryCode
entry
[
n
]
)
;
current
.
formats
=
formats
;
entry
[
n
]
=
current
;
return
entry
[
n
]
;
}
entry
[
n
]
=
ParseMetaData
(
countryCode
entry
[
n
]
)
;
return
entry
[
n
]
;
}
}
continue
;
}
if
(
typeof
entry
=
=
"
string
"
&
&
entry
.
substr
(
2
2
)
=
=
region
)
{
dataBase
[
countryCode
]
=
ParseMetaData
(
countryCode
entry
)
;
return
dataBase
[
countryCode
]
;
}
}
}
function
FormatNumber
(
regionMetaData
number
intl
)
{
ParseFormat
(
regionMetaData
)
;
let
formats
=
regionMetaData
.
formats
;
if
(
!
formats
)
{
return
null
;
}
for
(
let
n
=
0
;
n
<
formats
.
length
;
+
+
n
)
{
let
format
=
formats
[
n
]
;
if
(
format
.
leadingDigits
&
&
!
format
.
leadingDigits
.
test
(
number
)
)
{
continue
;
}
if
(
!
format
.
pattern
.
test
(
number
)
)
{
continue
;
}
if
(
intl
)
{
let
internationalFormat
=
format
.
internationalFormat
;
if
(
!
internationalFormat
)
{
internationalFormat
=
format
.
nationalFormat
;
}
if
(
internationalFormat
=
=
"
NA
"
)
{
return
null
;
}
number
=
"
+
"
+
regionMetaData
.
countryCode
+
"
"
+
number
.
replace
(
format
.
pattern
internationalFormat
)
;
}
else
{
number
=
number
.
replace
(
format
.
pattern
format
.
nationalFormat
)
;
let
nationalPrefixFormattingRule
=
regionMetaData
.
nationalPrefixFormattingRule
;
if
(
format
.
nationalPrefixFormattingRule
)
{
nationalPrefixFormattingRule
=
format
.
nationalPrefixFormattingRule
;
}
if
(
nationalPrefixFormattingRule
)
{
let
match
=
number
.
match
(
SPLIT_FIRST_GROUP
)
;
if
(
match
)
{
let
firstGroup
=
match
[
1
]
;
let
rest
=
match
[
2
]
;
let
prefix
=
nationalPrefixFormattingRule
;
prefix
=
prefix
.
replace
(
"
NP
"
regionMetaData
.
nationalPrefix
)
;
prefix
=
prefix
.
replace
(
"
FG
"
firstGroup
)
;
number
=
prefix
+
rest
;
}
}
}
return
(
number
=
=
"
NA
"
)
?
null
:
number
;
}
return
null
;
}
function
NationalNumber
(
regionMetaData
number
)
{
this
.
region
=
regionMetaData
.
region
;
this
.
regionMetaData
=
regionMetaData
;
this
.
number
=
number
;
}
NationalNumber
.
prototype
=
{
get
internationalFormat
(
)
{
let
value
=
FormatNumber
(
this
.
regionMetaData
this
.
number
true
)
;
Object
.
defineProperty
(
this
"
internationalFormat
"
{
value
enumerable
:
true
}
)
;
return
value
;
}
get
nationalFormat
(
)
{
let
value
=
FormatNumber
(
this
.
regionMetaData
this
.
number
false
)
;
Object
.
defineProperty
(
this
"
nationalFormat
"
{
value
enumerable
:
true
}
)
;
return
value
;
}
get
internationalNumber
(
)
{
let
value
=
this
.
internationalFormat
?
this
.
internationalFormat
.
replace
(
NON_DIALABLE_CHARS
"
"
)
:
null
;
Object
.
defineProperty
(
this
"
internationalNumber
"
{
value
enumerable
:
true
}
)
;
return
value
;
}
get
nationalNumber
(
)
{
let
value
=
this
.
nationalFormat
?
this
.
nationalFormat
.
replace
(
NON_DIALABLE_CHARS
"
"
)
:
null
;
Object
.
defineProperty
(
this
"
nationalNumber
"
{
value
enumerable
:
true
}
)
;
return
value
;
}
get
countryName
(
)
{
let
value
=
this
.
region
?
this
.
region
:
null
;
Object
.
defineProperty
(
this
"
countryName
"
{
value
enumerable
:
true
}
)
;
return
value
;
}
get
countryCode
(
)
{
let
value
=
this
.
regionMetaData
.
countryCode
?
"
+
"
+
this
.
regionMetaData
.
countryCode
:
null
;
Object
.
defineProperty
(
this
"
countryCode
"
{
value
enumerable
:
true
}
)
;
return
value
;
}
}
;
function
IsValidNumber
(
number
md
)
{
return
md
.
possiblePattern
.
test
(
number
)
;
}
function
IsNationalNumber
(
number
md
)
{
return
IsValidNumber
(
number
md
)
&
&
md
.
nationalPattern
.
test
(
number
)
;
}
function
ParseCountryCode
(
number
)
{
for
(
let
n
=
1
;
n
<
=
3
;
+
+
n
)
{
let
cc
=
number
.
substr
(
0
n
)
;
if
(
dataBase
[
cc
]
)
{
return
cc
;
}
}
return
null
;
}
function
ParseNationalNumber
(
number
md
)
{
if
(
!
md
.
possiblePattern
.
test
(
number
)
|
|
!
md
.
nationalPattern
.
test
(
number
)
)
{
return
null
;
}
return
new
NationalNumber
(
md
number
)
;
}
function
ParseNationalNumberAndCheckNationalPrefix
(
number
md
)
{
let
ret
;
if
(
md
.
nationalPrefixForParsing
)
{
let
withoutPrefix
=
number
.
replace
(
md
.
nationalPrefixForParsing
md
.
nationalPrefixTransformRule
|
|
"
"
)
;
ret
=
ParseNationalNumber
(
withoutPrefix
md
)
;
if
(
ret
)
{
return
ret
;
}
}
else
{
let
nationalPrefix
=
md
.
nationalPrefix
;
if
(
nationalPrefix
&
&
number
.
indexOf
(
nationalPrefix
)
=
=
0
&
&
(
ret
=
ParseNationalNumber
(
number
.
substr
(
nationalPrefix
.
length
)
md
)
)
)
{
return
ret
;
}
}
ret
=
ParseNationalNumber
(
number
md
)
;
if
(
ret
)
{
return
ret
;
}
}
function
ParseNumberByCountryCode
(
number
countryCode
)
{
let
ret
;
let
entry
=
dataBase
[
countryCode
]
;
if
(
Array
.
isArray
(
entry
)
)
{
for
(
let
n
=
0
;
n
<
entry
.
length
;
+
+
n
)
{
if
(
typeof
entry
[
n
]
=
=
"
string
"
)
{
entry
[
n
]
=
ParseMetaData
(
countryCode
entry
[
n
]
)
;
}
if
(
n
>
0
)
{
entry
[
n
]
.
formats
=
entry
[
0
]
.
formats
;
}
ret
=
ParseNationalNumberAndCheckNationalPrefix
(
number
entry
[
n
]
)
;
if
(
ret
)
{
return
ret
;
}
}
return
null
;
}
if
(
typeof
entry
=
=
"
string
"
)
{
entry
=
dataBase
[
countryCode
]
=
ParseMetaData
(
countryCode
entry
)
;
}
return
ParseNationalNumberAndCheckNationalPrefix
(
number
entry
)
;
}
function
ParseInternationalNumber
(
number
)
{
let
countryCode
=
ParseCountryCode
(
number
)
;
if
(
!
countryCode
)
{
return
null
;
}
number
=
number
.
substr
(
countryCode
.
length
)
;
return
ParseNumberByCountryCode
(
number
countryCode
)
;
}
function
ParseNumber
(
number
defaultRegion
)
{
let
ret
;
number
=
PhoneNumberNormalizer
.
Normalize
(
number
)
;
if
(
(
!
defaultRegion
|
|
defaultRegion
=
=
=
"
001
"
)
&
&
number
[
0
]
!
=
=
"
+
"
)
{
return
null
;
}
if
(
number
[
0
]
=
=
=
"
+
"
)
{
return
ParseInternationalNumber
(
number
.
replace
(
LEADING_PLUS_CHARS_PATTERN
"
"
)
)
;
}
let
matches
=
String
(
defaultRegion
)
.
match
(
/
^
\
+
?
(
\
d
+
)
/
)
;
if
(
matches
)
{
let
countryCode
=
ParseCountryCode
(
matches
[
1
]
)
;
if
(
!
countryCode
)
{
return
null
;
}
return
ParseNumberByCountryCode
(
number
countryCode
)
;
}
let
md
=
FindMetaDataForRegion
(
defaultRegion
.
toUpperCase
(
)
)
;
if
(
!
md
)
{
dump
(
"
Couldn
'
t
find
Meta
Data
for
region
:
"
+
defaultRegion
+
"
\
n
"
)
;
return
null
;
}
if
(
md
.
internationalPrefix
.
test
(
number
)
)
{
let
possibleNumber
=
number
.
replace
(
md
.
internationalPrefix
"
"
)
;
ret
=
ParseInternationalNumber
(
possibleNumber
)
;
if
(
ret
)
{
return
ret
;
}
}
ret
=
ParseNationalNumberAndCheckNationalPrefix
(
number
md
)
;
if
(
ret
)
{
return
ret
;
}
ret
=
ParseInternationalNumber
(
number
)
;
if
(
ret
)
{
return
ret
;
}
if
(
md
.
possiblePattern
.
test
(
number
)
)
{
return
new
NationalNumber
(
md
number
)
;
}
return
null
;
}
function
IsPlainPhoneNumber
(
number
)
{
if
(
typeof
number
!
=
=
"
string
"
)
{
return
false
;
}
let
length
=
number
.
length
;
let
isTooLong
=
(
length
>
MAX_PHONE_NUMBER_LENGTH
)
;
let
isEmpty
=
(
length
=
=
=
0
)
;
return
!
(
isTooLong
|
|
isEmpty
|
|
NON_DIALABLE_CHARS_ONCE
.
test
(
number
)
)
;
}
return
{
IsPlain
:
IsPlainPhoneNumber
Parse
:
ParseNumber
}
;
}
)
(
PHONE_NUMBER_META_DATA
)
;
