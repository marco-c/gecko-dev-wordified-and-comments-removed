"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
AddressResult
"
"
CreditCardResult
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
formautofill
/
FormAutofill
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
FormAutofillUtils
"
"
resource
:
/
/
formautofill
/
FormAutofillUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
CreditCard
"
"
resource
:
/
/
gre
/
modules
/
CreditCard
.
jsm
"
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
insecureWarningEnabled
"
"
security
.
insecure_field_warning
.
contextual
.
enabled
"
)
;
this
.
log
=
null
;
FormAutofill
.
defineLazyLogGetter
(
this
EXPORTED_SYMBOLS
[
0
]
)
;
class
ProfileAutoCompleteResult
{
constructor
(
searchString
focusedFieldName
allFieldNames
matchingProfiles
{
resultCode
=
null
isSecure
=
true
isInputAutofilled
=
false
}
)
{
log
.
debug
(
"
Constructing
new
ProfileAutoCompleteResult
:
"
[
.
.
.
arguments
]
)
;
this
.
QueryInterface
=
ChromeUtils
.
generateQI
(
[
Ci
.
nsIAutoCompleteResult
]
)
;
this
.
searchString
=
searchString
;
this
.
_focusedFieldName
=
focusedFieldName
;
this
.
_matchingProfiles
=
matchingProfiles
;
this
.
defaultIndex
=
0
;
this
.
errorDescription
=
"
"
;
this
.
_isSecure
=
isSecure
;
this
.
_isInputAutofilled
=
isInputAutofilled
;
this
.
_allFieldNames
=
[
.
.
.
this
.
_matchingProfiles
.
reduce
(
(
fieldSet
curProfile
)
=
>
{
for
(
let
field
of
Object
.
keys
(
curProfile
)
)
{
fieldSet
.
add
(
field
)
;
}
return
fieldSet
;
}
new
Set
(
)
)
]
.
filter
(
field
=
>
allFieldNames
.
includes
(
field
)
)
;
if
(
isInputAutofilled
)
{
resultCode
=
Ci
.
nsIAutoCompleteResult
.
RESULT_SUCCESS
;
}
if
(
resultCode
)
{
this
.
searchResult
=
resultCode
;
}
else
if
(
matchingProfiles
.
length
>
0
)
{
this
.
searchResult
=
Ci
.
nsIAutoCompleteResult
.
RESULT_SUCCESS
;
}
else
{
this
.
searchResult
=
Ci
.
nsIAutoCompleteResult
.
RESULT_NOMATCH
;
}
this
.
_popupLabels
=
this
.
_generateLabels
(
this
.
_focusedFieldName
this
.
_allFieldNames
this
.
_matchingProfiles
)
;
}
get
matchCount
(
)
{
return
this
.
_popupLabels
.
length
;
}
_checkIndexBounds
(
index
)
{
if
(
index
<
0
|
|
index
>
=
this
.
_popupLabels
.
length
)
{
throw
Components
.
Exception
(
"
Index
out
of
range
.
"
Cr
.
NS_ERROR_ILLEGAL_VALUE
)
;
}
}
_getSecondaryLabel
(
focusedFieldName
allFieldNames
profile
)
{
return
"
"
;
}
_generateLabels
(
focusedFieldName
allFieldNames
profiles
)
{
}
getValueAt
(
index
)
{
this
.
_checkIndexBounds
(
index
)
;
return
"
"
;
}
getLabelAt
(
index
)
{
this
.
_checkIndexBounds
(
index
)
;
let
label
=
this
.
_popupLabels
[
index
]
;
if
(
typeof
label
=
=
"
string
"
)
{
return
label
;
}
return
JSON
.
stringify
(
label
)
;
}
getCommentAt
(
index
)
{
this
.
_checkIndexBounds
(
index
)
;
return
JSON
.
stringify
(
this
.
_matchingProfiles
[
index
]
)
;
}
getStyleAt
(
index
)
{
this
.
_checkIndexBounds
(
index
)
;
if
(
index
=
=
this
.
matchCount
-
1
)
{
return
"
autofill
-
footer
"
;
}
if
(
this
.
_isInputAutofilled
)
{
return
"
autofill
-
clear
-
button
"
;
}
return
"
autofill
-
profile
"
;
}
getImageAt
(
index
)
{
this
.
_checkIndexBounds
(
index
)
;
return
"
"
;
}
getFinalCompleteValueAt
(
index
)
{
return
this
.
getValueAt
(
index
)
;
}
removeValueAt
(
index
removeFromDatabase
)
{
}
}
class
AddressResult
extends
ProfileAutoCompleteResult
{
constructor
(
.
.
.
args
)
{
super
(
.
.
.
args
)
;
}
_getSecondaryLabel
(
focusedFieldName
allFieldNames
profile
)
{
const
GROUP_FIELDS
=
{
"
name
"
:
[
"
name
"
"
given
-
name
"
"
additional
-
name
"
"
family
-
name
"
]
"
street
-
address
"
:
[
"
street
-
address
"
"
address
-
line1
"
"
address
-
line2
"
"
address
-
line3
"
]
"
country
-
name
"
:
[
"
country
"
"
country
-
name
"
]
"
tel
"
:
[
"
tel
"
"
tel
-
country
-
code
"
"
tel
-
national
"
"
tel
-
area
-
code
"
"
tel
-
local
"
"
tel
-
local
-
prefix
"
"
tel
-
local
-
suffix
"
]
}
;
const
secondaryLabelOrder
=
[
"
street
-
address
"
"
name
"
"
address
-
level2
"
"
organization
"
"
address
-
level1
"
"
country
-
name
"
"
postal
-
code
"
"
tel
"
"
email
"
]
;
for
(
let
field
in
GROUP_FIELDS
)
{
if
(
GROUP_FIELDS
[
field
]
.
includes
(
focusedFieldName
)
)
{
focusedFieldName
=
field
;
break
;
}
}
for
(
const
currentFieldName
of
secondaryLabelOrder
)
{
if
(
focusedFieldName
=
=
currentFieldName
|
|
!
profile
[
currentFieldName
]
)
{
continue
;
}
let
matching
=
GROUP_FIELDS
[
currentFieldName
]
?
allFieldNames
.
some
(
fieldName
=
>
GROUP_FIELDS
[
currentFieldName
]
.
includes
(
fieldName
)
)
:
allFieldNames
.
includes
(
currentFieldName
)
;
if
(
matching
)
{
if
(
currentFieldName
=
=
"
street
-
address
"
&
&
profile
[
"
-
moz
-
street
-
address
-
one
-
line
"
]
)
{
return
profile
[
"
-
moz
-
street
-
address
-
one
-
line
"
]
;
}
return
profile
[
currentFieldName
]
;
}
}
return
"
"
;
}
_generateLabels
(
focusedFieldName
allFieldNames
profiles
)
{
if
(
this
.
_isInputAutofilled
)
{
return
[
{
primary
:
"
"
secondary
:
"
"
}
{
primary
:
"
"
secondary
:
"
"
}
]
;
}
let
labels
=
profiles
.
filter
(
profile
=
>
{
return
!
!
profile
[
focusedFieldName
]
;
}
)
.
map
(
profile
=
>
{
let
primaryLabel
=
profile
[
focusedFieldName
]
;
if
(
focusedFieldName
=
=
"
street
-
address
"
&
&
profile
[
"
-
moz
-
street
-
address
-
one
-
line
"
]
)
{
primaryLabel
=
profile
[
"
-
moz
-
street
-
address
-
one
-
line
"
]
;
}
return
{
primary
:
primaryLabel
secondary
:
this
.
_getSecondaryLabel
(
focusedFieldName
allFieldNames
profile
)
}
;
}
)
;
labels
.
push
(
{
primary
:
"
"
secondary
:
"
"
categories
:
FormAutofillUtils
.
getCategoriesFromFieldNames
(
this
.
_allFieldNames
)
focusedCategory
:
FormAutofillUtils
.
getCategoryFromFieldName
(
this
.
_focusedFieldName
)
}
)
;
return
labels
;
}
}
class
CreditCardResult
extends
ProfileAutoCompleteResult
{
constructor
(
.
.
.
args
)
{
super
(
.
.
.
args
)
;
}
_getSecondaryLabel
(
focusedFieldName
allFieldNames
profile
)
{
const
GROUP_FIELDS
=
{
"
cc
-
name
"
:
[
"
cc
-
name
"
"
cc
-
given
-
name
"
"
cc
-
additional
-
name
"
"
cc
-
family
-
name
"
]
"
cc
-
exp
"
:
[
"
cc
-
exp
"
"
cc
-
exp
-
month
"
"
cc
-
exp
-
year
"
]
}
;
const
secondaryLabelOrder
=
[
"
cc
-
number
"
"
cc
-
name
"
"
cc
-
exp
"
]
;
for
(
let
field
in
GROUP_FIELDS
)
{
if
(
GROUP_FIELDS
[
field
]
.
includes
(
focusedFieldName
)
)
{
focusedFieldName
=
field
;
break
;
}
}
for
(
const
currentFieldName
of
secondaryLabelOrder
)
{
if
(
focusedFieldName
=
=
currentFieldName
|
|
!
profile
[
currentFieldName
]
)
{
continue
;
}
let
matching
=
GROUP_FIELDS
[
currentFieldName
]
?
allFieldNames
.
some
(
fieldName
=
>
GROUP_FIELDS
[
currentFieldName
]
.
includes
(
fieldName
)
)
:
allFieldNames
.
includes
(
currentFieldName
)
;
if
(
matching
)
{
if
(
currentFieldName
=
=
"
cc
-
number
"
)
{
let
{
affix
label
}
=
CreditCard
.
formatMaskedNumber
(
profile
[
currentFieldName
]
)
;
return
affix
+
label
;
}
return
profile
[
currentFieldName
]
;
}
}
return
"
"
;
}
_generateLabels
(
focusedFieldName
allFieldNames
profiles
)
{
if
(
!
this
.
_isSecure
)
{
if
(
!
insecureWarningEnabled
)
{
return
[
]
;
}
let
brandName
=
FormAutofillUtils
.
brandBundle
.
GetStringFromName
(
"
brandShortName
"
)
;
return
[
FormAutofillUtils
.
stringBundle
.
formatStringFromName
(
"
insecureFieldWarningDescription
"
[
brandName
]
1
)
]
;
}
if
(
this
.
_isInputAutofilled
)
{
return
[
{
primary
:
"
"
secondary
:
"
"
}
{
primary
:
"
"
secondary
:
"
"
}
]
;
}
let
labels
=
profiles
.
filter
(
profile
=
>
{
return
!
!
profile
[
focusedFieldName
]
;
}
)
.
map
(
profile
=
>
{
let
primaryAffix
;
let
primary
=
profile
[
focusedFieldName
]
;
if
(
focusedFieldName
=
=
"
cc
-
number
"
)
{
let
{
affix
label
}
=
CreditCard
.
formatMaskedNumber
(
primary
)
;
primaryAffix
=
affix
;
primary
=
label
;
}
return
{
primaryAffix
primary
secondary
:
this
.
_getSecondaryLabel
(
focusedFieldName
allFieldNames
profile
)
}
;
}
)
;
labels
.
push
(
{
primary
:
"
"
secondary
:
"
"
}
)
;
return
labels
;
}
getStyleAt
(
index
)
{
this
.
_checkIndexBounds
(
index
)
;
if
(
!
this
.
_isSecure
&
&
insecureWarningEnabled
)
{
return
"
autofill
-
insecureWarning
"
;
}
return
super
.
getStyleAt
(
index
)
;
}
getImageAt
(
index
)
{
this
.
_checkIndexBounds
(
index
)
;
return
"
chrome
:
/
/
formautofill
/
content
/
icon
-
credit
-
card
-
generic
.
svg
"
;
}
}
