"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
ProfileAutoCompleteResult
"
]
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
formautofill
/
FormAutofillUtils
.
jsm
"
)
;
this
.
log
=
null
;
FormAutofillUtils
.
defineLazyLogGetter
(
this
this
.
EXPORTED_SYMBOLS
[
0
]
)
;
class
ProfileAutoCompleteResult
{
constructor
(
searchString
focusedFieldName
allFieldNames
matchingProfiles
{
resultCode
=
null
}
)
{
log
.
debug
(
"
Constructing
new
ProfileAutoCompleteResult
:
"
[
.
.
.
arguments
]
)
;
this
.
QueryInterface
=
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIAutoCompleteResult
]
)
;
this
.
searchString
=
searchString
;
this
.
_focusedFieldName
=
focusedFieldName
;
this
.
_allFieldNames
=
allFieldNames
;
this
.
_matchingProfiles
=
matchingProfiles
;
this
.
defaultIndex
=
0
;
this
.
errorDescription
=
"
"
;
if
(
resultCode
)
{
this
.
searchResult
=
resultCode
;
}
else
if
(
matchingProfiles
.
length
>
0
)
{
this
.
searchResult
=
Ci
.
nsIAutoCompleteResult
.
RESULT_SUCCESS
;
}
else
{
this
.
searchResult
=
Ci
.
nsIAutoCompleteResult
.
RESULT_NOMATCH
;
}
this
.
_popupLabels
=
this
.
_generateLabels
(
this
.
_focusedFieldName
this
.
_allFieldNames
this
.
_matchingProfiles
)
;
this
.
_popupLabels
.
push
(
{
primary
:
"
"
secondary
:
"
"
categories
:
FormAutofillUtils
.
getCategoriesFromFieldNames
(
allFieldNames
)
focusedCategory
:
FormAutofillUtils
.
getCategoryFromFieldName
(
focusedFieldName
)
}
)
;
}
get
matchCount
(
)
{
return
this
.
_popupLabels
.
length
;
}
_checkIndexBounds
(
index
)
{
if
(
index
<
0
|
|
index
>
=
this
.
_popupLabels
.
length
)
{
throw
Components
.
Exception
(
"
Index
out
of
range
.
"
Cr
.
NS_ERROR_ILLEGAL_VALUE
)
;
}
}
_getSecondaryLabel
(
focusedFieldName
allFieldNames
profile
)
{
const
GROUP_FIELDS
=
{
"
name
"
:
[
"
name
"
"
given
-
name
"
"
additional
-
name
"
"
family
-
name
"
]
"
street
-
address
"
:
[
"
street
-
address
"
"
address
-
line1
"
"
address
-
line2
"
"
address
-
line3
"
]
"
country
-
name
"
:
[
"
country
"
"
country
-
name
"
]
}
;
const
secondaryLabelOrder
=
[
"
street
-
address
"
"
name
"
"
address
-
level2
"
"
organization
"
"
address
-
level1
"
"
country
-
name
"
"
postal
-
code
"
"
tel
"
"
email
"
]
;
for
(
let
field
in
GROUP_FIELDS
)
{
if
(
GROUP_FIELDS
[
field
]
.
includes
(
focusedFieldName
)
)
{
focusedFieldName
=
field
;
break
;
}
}
for
(
const
currentFieldName
of
secondaryLabelOrder
)
{
if
(
focusedFieldName
=
=
currentFieldName
|
|
!
profile
[
currentFieldName
]
)
{
continue
;
}
let
matching
=
GROUP_FIELDS
[
currentFieldName
]
?
allFieldNames
.
some
(
fieldName
=
>
GROUP_FIELDS
[
currentFieldName
]
.
includes
(
fieldName
)
)
:
allFieldNames
.
includes
(
currentFieldName
)
;
if
(
matching
)
{
if
(
currentFieldName
=
=
"
street
-
address
"
&
&
profile
[
"
-
moz
-
street
-
address
-
one
-
line
"
]
)
{
return
profile
[
"
-
moz
-
street
-
address
-
one
-
line
"
]
;
}
return
profile
[
currentFieldName
]
;
}
}
return
"
"
;
}
_generateLabels
(
focusedFieldName
allFieldNames
profiles
)
{
return
profiles
.
filter
(
profile
=
>
{
return
!
!
profile
[
focusedFieldName
]
;
}
)
.
map
(
profile
=
>
{
let
primaryLabel
=
profile
[
focusedFieldName
]
;
if
(
focusedFieldName
=
=
"
street
-
address
"
&
&
profile
[
"
-
moz
-
street
-
address
-
one
-
line
"
]
)
{
primaryLabel
=
profile
[
"
-
moz
-
street
-
address
-
one
-
line
"
]
;
}
return
{
primary
:
primaryLabel
secondary
:
this
.
_getSecondaryLabel
(
focusedFieldName
allFieldNames
profile
)
}
;
}
)
;
}
getValueAt
(
index
)
{
this
.
_checkIndexBounds
(
index
)
;
return
this
.
_popupLabels
[
index
]
.
primary
;
}
getLabelAt
(
index
)
{
this
.
_checkIndexBounds
(
index
)
;
return
JSON
.
stringify
(
this
.
_popupLabels
[
index
]
)
;
}
getCommentAt
(
index
)
{
this
.
_checkIndexBounds
(
index
)
;
return
JSON
.
stringify
(
this
.
_matchingProfiles
[
index
]
)
;
}
getStyleAt
(
index
)
{
this
.
_checkIndexBounds
(
index
)
;
if
(
index
=
=
this
.
matchCount
-
1
)
{
return
"
autofill
-
footer
"
;
}
return
"
autofill
-
profile
"
;
}
getImageAt
(
index
)
{
this
.
_checkIndexBounds
(
index
)
;
return
"
"
;
}
getFinalCompleteValueAt
(
index
)
{
return
this
.
getValueAt
(
index
)
;
}
removeValueAt
(
index
removeFromDatabase
)
{
}
}
