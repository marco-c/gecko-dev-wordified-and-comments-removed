"
use
strict
"
;
const
{
FormAutofill
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
autofill
/
FormAutofill
.
jsm
"
)
;
const
{
FormAutofillUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
autofill
/
FormAutofillUtils
.
jsm
"
)
;
class
EditAutofillForm
{
constructor
(
elements
)
{
this
.
_elements
=
elements
;
}
loadRecord
(
record
=
{
}
)
{
for
(
let
field
of
this
.
_elements
.
form
.
elements
)
{
let
value
=
record
[
field
.
id
]
;
value
=
typeof
value
=
=
"
undefined
"
?
"
"
:
value
;
if
(
record
.
guid
)
{
field
.
value
=
value
;
}
else
if
(
field
.
localName
=
=
"
select
"
)
{
this
.
setDefaultSelectedOptionByValue
(
field
value
)
;
}
else
{
field
.
defaultValue
=
value
;
}
}
if
(
!
record
.
guid
)
{
this
.
_elements
.
form
.
reset
(
)
;
}
else
{
for
(
let
field
of
this
.
_elements
.
form
.
elements
)
{
this
.
updatePopulatedState
(
field
)
;
this
.
updateCustomValidity
(
field
)
;
}
}
}
setDefaultSelectedOptionByValue
(
select
value
)
{
for
(
let
option
of
select
.
options
)
{
option
.
defaultSelected
=
option
.
value
=
=
value
;
}
}
buildFormObject
(
)
{
let
initialObject
=
{
}
;
if
(
this
.
hasMailingAddressFields
)
{
initialObject
=
{
"
street
-
address
"
:
"
"
"
address
-
level3
"
:
"
"
"
address
-
level2
"
:
"
"
"
address
-
level1
"
:
"
"
"
postal
-
code
"
:
"
"
}
;
}
return
Array
.
from
(
this
.
_elements
.
form
.
elements
)
.
reduce
(
(
obj
input
)
=
>
{
if
(
!
input
.
disabled
)
{
obj
[
input
.
id
]
=
input
.
value
;
}
return
obj
;
}
initialObject
)
;
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
change
"
:
{
this
.
handleChange
(
event
)
;
break
;
}
case
"
input
"
:
{
this
.
handleInput
(
event
)
;
break
;
}
}
}
handleChange
(
event
)
{
this
.
updatePopulatedState
(
event
.
target
)
;
}
handleInput
(
event
)
{
}
attachEventListeners
(
)
{
this
.
_elements
.
form
.
addEventListener
(
"
input
"
this
)
;
}
updatePopulatedState
(
field
)
{
let
span
=
field
.
parentNode
.
querySelector
(
"
.
label
-
text
"
)
;
if
(
!
span
)
{
return
;
}
span
.
toggleAttribute
(
"
field
-
populated
"
!
!
field
.
value
.
trim
(
)
)
;
}
updateCustomValidity
(
field
)
{
}
}
class
EditAddress
extends
EditAutofillForm
{
constructor
(
elements
record
config
)
{
super
(
elements
)
;
Object
.
assign
(
this
config
)
;
let
{
form
}
=
this
.
_elements
;
Object
.
assign
(
this
.
_elements
{
addressLevel3Label
:
form
.
querySelector
(
"
#
address
-
level3
-
container
>
.
label
-
text
"
)
addressLevel2Label
:
form
.
querySelector
(
"
#
address
-
level2
-
container
>
.
label
-
text
"
)
addressLevel1Label
:
form
.
querySelector
(
"
#
address
-
level1
-
container
>
.
label
-
text
"
)
postalCodeLabel
:
form
.
querySelector
(
"
#
postal
-
code
-
container
>
.
label
-
text
"
)
country
:
form
.
querySelector
(
"
#
country
"
)
}
)
;
this
.
populateCountries
(
)
;
this
.
loadRecord
(
record
)
;
this
.
attachEventListeners
(
)
;
form
.
noValidate
=
!
!
config
.
noValidate
;
}
loadRecord
(
record
)
{
this
.
_record
=
record
;
if
(
!
record
)
{
record
=
{
country
:
FormAutofill
.
DEFAULT_REGION
}
;
}
let
{
addressLevel1Options
}
=
FormAutofillUtils
.
getFormFormat
(
record
.
country
)
;
this
.
populateAddressLevel1
(
addressLevel1Options
record
.
country
)
;
super
.
loadRecord
(
record
)
;
this
.
loadAddressLevel1
(
record
[
"
address
-
level1
"
]
record
.
country
)
;
this
.
formatForm
(
record
.
country
)
;
}
get
hasMailingAddressFields
(
)
{
let
{
addressFields
}
=
this
.
_elements
.
form
.
dataset
;
return
(
!
addressFields
|
|
addressFields
.
trim
(
)
.
split
(
/
\
s
+
/
)
.
includes
(
"
mailing
-
address
"
)
)
;
}
static
computeVisibleFields
(
mailingFieldsOrder
addressFields
)
{
if
(
addressFields
)
{
let
requestedFieldClasses
=
addressFields
.
trim
(
)
.
split
(
/
\
s
+
/
)
;
let
fieldClasses
=
[
]
;
if
(
requestedFieldClasses
.
includes
(
"
mailing
-
address
"
)
)
{
fieldClasses
=
fieldClasses
.
concat
(
mailingFieldsOrder
)
;
requestedFieldClasses
.
splice
(
requestedFieldClasses
.
indexOf
(
"
mailing
-
address
"
)
1
"
country
"
)
;
}
for
(
let
fieldClassName
of
requestedFieldClasses
)
{
fieldClasses
.
push
(
{
fieldId
:
fieldClassName
newLine
:
fieldClassName
=
=
"
name
"
}
)
;
}
return
fieldClasses
;
}
return
mailingFieldsOrder
.
concat
(
[
{
fieldId
:
"
country
"
}
{
fieldId
:
"
tel
"
}
{
fieldId
:
"
email
"
newLine
:
true
}
]
)
;
}
formatForm
(
country
)
{
const
{
addressLevel3L10nId
addressLevel2L10nId
addressLevel1L10nId
addressLevel1Options
postalCodeL10nId
fieldsOrder
:
mailingFieldsOrder
postalCodePattern
countryRequiredFields
}
=
FormAutofillUtils
.
getFormFormat
(
country
)
;
document
.
l10n
.
setAttributes
(
this
.
_elements
.
addressLevel3Label
addressLevel3L10nId
)
;
document
.
l10n
.
setAttributes
(
this
.
_elements
.
addressLevel2Label
addressLevel2L10nId
)
;
document
.
l10n
.
setAttributes
(
this
.
_elements
.
addressLevel1Label
addressLevel1L10nId
)
;
document
.
l10n
.
setAttributes
(
this
.
_elements
.
postalCodeLabel
postalCodeL10nId
)
;
let
addressFields
=
this
.
_elements
.
form
.
dataset
.
addressFields
;
let
extraRequiredFields
=
this
.
_elements
.
form
.
dataset
.
extraRequiredFields
;
let
fieldClasses
=
EditAddress
.
computeVisibleFields
(
mailingFieldsOrder
addressFields
)
;
let
requiredFields
=
new
Set
(
countryRequiredFields
)
;
if
(
extraRequiredFields
)
{
for
(
let
extraRequiredField
of
extraRequiredFields
.
trim
(
)
.
split
(
/
\
s
+
/
)
)
{
requiredFields
.
add
(
extraRequiredField
)
;
}
}
this
.
arrangeFields
(
fieldClasses
requiredFields
)
;
this
.
updatePostalCodeValidation
(
postalCodePattern
)
;
this
.
populateAddressLevel1
(
addressLevel1Options
country
)
;
}
arrangeFields
(
fieldsOrder
requiredFields
)
{
let
fields
=
[
"
name
"
"
organization
"
"
street
-
address
"
"
address
-
level3
"
"
address
-
level2
"
"
address
-
level1
"
"
postal
-
code
"
"
country
"
"
tel
"
"
email
"
]
;
let
inputs
=
[
]
;
for
(
let
i
=
0
;
i
<
fieldsOrder
.
length
;
i
+
+
)
{
let
{
fieldId
newLine
}
=
fieldsOrder
[
i
]
;
let
container
=
this
.
_elements
.
form
.
querySelector
(
#
{
fieldId
}
-
container
)
;
let
containerInputs
=
[
.
.
.
container
.
querySelectorAll
(
"
input
textarea
select
"
)
]
;
containerInputs
.
forEach
(
function
(
input
)
{
input
.
disabled
=
false
;
input
.
required
=
(
fieldId
=
=
"
country
"
|
|
fieldId
=
=
"
name
"
|
|
requiredFields
.
has
(
fieldId
)
)
&
&
input
.
id
!
=
"
additional
-
name
"
;
}
)
;
inputs
.
push
(
.
.
.
containerInputs
)
;
container
.
style
.
display
=
"
flex
"
;
container
.
style
.
order
=
i
;
container
.
style
.
pageBreakAfter
=
newLine
?
"
always
"
:
"
auto
"
;
fields
.
splice
(
fields
.
indexOf
(
fieldId
)
1
)
;
}
for
(
let
i
=
0
;
i
<
inputs
.
length
;
i
+
+
)
{
inputs
[
i
]
.
tabIndex
=
i
+
1
;
}
for
(
let
field
of
fields
)
{
let
container
=
this
.
_elements
.
form
.
querySelector
(
#
{
field
}
-
container
)
;
container
.
style
.
display
=
"
none
"
;
for
(
let
input
of
[
.
.
.
container
.
querySelectorAll
(
"
input
textarea
select
"
)
]
)
{
input
.
disabled
=
true
;
}
}
}
updatePostalCodeValidation
(
postalCodePattern
)
{
let
postalCodeInput
=
this
.
_elements
.
form
.
querySelector
(
"
#
postal
-
code
"
)
;
if
(
postalCodePattern
&
&
postalCodeInput
.
style
.
display
!
=
"
none
"
)
{
postalCodeInput
.
setAttribute
(
"
pattern
"
postalCodePattern
)
;
}
else
{
postalCodeInput
.
removeAttribute
(
"
pattern
"
)
;
}
}
loadAddressLevel1
(
addressLevel1Value
country
)
{
let
field
=
this
.
_elements
.
form
.
querySelector
(
"
#
address
-
level1
"
)
;
if
(
field
.
localName
=
=
"
input
"
)
{
field
.
value
=
addressLevel1Value
|
|
"
"
;
return
;
}
let
matchedSelectOption
=
FormAutofillUtils
.
findAddressSelectOption
(
field
{
country
"
address
-
level1
"
:
addressLevel1Value
}
"
address
-
level1
"
)
;
if
(
matchedSelectOption
&
&
!
matchedSelectOption
.
selected
)
{
field
.
value
=
matchedSelectOption
.
value
;
field
.
dispatchEvent
(
new
Event
(
"
input
"
{
bubbles
:
true
}
)
)
;
field
.
dispatchEvent
(
new
Event
(
"
change
"
{
bubbles
:
true
}
)
)
;
}
else
if
(
addressLevel1Value
)
{
field
.
insertBefore
(
new
Option
(
addressLevel1Value
addressLevel1Value
true
true
)
field
.
firstChild
)
;
}
}
populateAddressLevel1
(
options
country
)
{
let
field
=
this
.
_elements
.
form
.
querySelector
(
"
#
address
-
level1
"
)
;
if
(
field
.
dataset
.
country
=
=
country
)
{
return
;
}
if
(
!
options
)
{
if
(
field
.
localName
=
=
"
input
"
)
{
return
;
}
let
input
=
document
.
createElement
(
"
input
"
)
;
input
.
setAttribute
(
"
type
"
"
text
"
)
;
input
.
id
=
"
address
-
level1
"
;
input
.
required
=
field
.
required
;
input
.
disabled
=
field
.
disabled
;
input
.
tabIndex
=
field
.
tabIndex
;
field
.
replaceWith
(
input
)
;
return
;
}
if
(
field
.
localName
=
=
"
input
"
)
{
let
select
=
document
.
createElement
(
"
select
"
)
;
select
.
id
=
"
address
-
level1
"
;
select
.
required
=
field
.
required
;
select
.
disabled
=
field
.
disabled
;
select
.
tabIndex
=
field
.
tabIndex
;
field
.
replaceWith
(
select
)
;
field
=
select
;
}
field
.
textContent
=
"
"
;
field
.
dataset
.
country
=
country
;
let
fragment
=
document
.
createDocumentFragment
(
)
;
fragment
.
appendChild
(
new
Option
(
undefined
undefined
true
true
)
)
;
for
(
let
[
regionCode
regionName
]
of
options
)
{
let
option
=
new
Option
(
regionName
regionCode
)
;
fragment
.
appendChild
(
option
)
;
}
field
.
appendChild
(
fragment
)
;
}
populateCountries
(
)
{
let
fragment
=
document
.
createDocumentFragment
(
)
;
let
countries
=
[
.
.
.
FormAutofill
.
countries
.
entries
(
)
]
.
sort
(
(
e1
e2
)
=
>
e1
[
1
]
.
localeCompare
(
e2
[
1
]
)
)
;
for
(
let
[
country
]
of
countries
)
{
const
countryName
=
Services
.
intl
.
getRegionDisplayNames
(
undefined
[
country
.
toLowerCase
(
)
]
)
;
const
option
=
new
Option
(
countryName
country
)
;
fragment
.
appendChild
(
option
)
;
}
this
.
_elements
.
country
.
appendChild
(
fragment
)
;
}
handleChange
(
event
)
{
if
(
event
.
target
=
=
this
.
_elements
.
country
)
{
this
.
formatForm
(
event
.
target
.
value
)
;
}
super
.
handleChange
(
event
)
;
}
attachEventListeners
(
)
{
this
.
_elements
.
form
.
addEventListener
(
"
change
"
this
)
;
super
.
attachEventListeners
(
)
;
}
}
class
EditCreditCard
extends
EditAutofillForm
{
constructor
(
elements
record
addresses
)
{
super
(
elements
)
;
this
.
_addresses
=
addresses
;
Object
.
assign
(
this
.
_elements
{
ccNumber
:
this
.
_elements
.
form
.
querySelector
(
"
#
cc
-
number
"
)
invalidCardNumberStringElement
:
this
.
_elements
.
form
.
querySelector
(
"
#
invalidCardNumberString
"
)
month
:
this
.
_elements
.
form
.
querySelector
(
"
#
cc
-
exp
-
month
"
)
year
:
this
.
_elements
.
form
.
querySelector
(
"
#
cc
-
exp
-
year
"
)
billingAddress
:
this
.
_elements
.
form
.
querySelector
(
"
#
billingAddressGUID
"
)
billingAddressRow
:
this
.
_elements
.
form
.
querySelector
(
"
.
billingAddressRow
"
)
}
)
;
this
.
attachEventListeners
(
)
;
this
.
loadRecord
(
record
addresses
)
;
}
loadRecord
(
record
addresses
preserveFieldValues
)
{
this
.
_record
=
record
;
this
.
_addresses
=
addresses
;
this
.
generateBillingAddressOptions
(
preserveFieldValues
)
;
if
(
!
preserveFieldValues
)
{
this
.
generateMonths
(
)
;
this
.
generateYears
(
)
;
super
.
loadRecord
(
record
)
;
}
}
generateMonths
(
)
{
const
count
=
12
;
this
.
_elements
.
month
.
textContent
=
"
"
;
this
.
_elements
.
month
.
appendChild
(
new
Option
(
)
)
;
let
dateFormat
=
new
Intl
.
DateTimeFormat
(
navigator
.
language
{
month
:
"
long
"
}
)
.
format
;
for
(
let
i
=
0
;
i
<
count
;
i
+
+
)
{
let
monthNumber
=
(
i
+
1
)
.
toString
(
)
;
let
monthName
=
dateFormat
(
new
Date
(
1970
i
)
)
;
let
option
=
new
Option
(
)
;
option
.
value
=
monthNumber
;
option
.
textContent
=
{
monthNumber
.
padStart
(
2
"
0
"
)
}
-
{
monthName
}
;
this
.
_elements
.
month
.
appendChild
(
option
)
;
}
}
generateYears
(
)
{
const
count
=
11
;
const
currentYear
=
new
Date
(
)
.
getFullYear
(
)
;
const
ccExpYear
=
this
.
_record
&
&
this
.
_record
[
"
cc
-
exp
-
year
"
]
;
this
.
_elements
.
year
.
textContent
=
"
"
;
this
.
_elements
.
year
.
appendChild
(
new
Option
(
)
)
;
if
(
ccExpYear
&
&
ccExpYear
<
currentYear
)
{
this
.
_elements
.
year
.
appendChild
(
new
Option
(
ccExpYear
)
)
;
}
for
(
let
i
=
0
;
i
<
count
;
i
+
+
)
{
let
year
=
currentYear
+
i
;
let
option
=
new
Option
(
year
)
;
this
.
_elements
.
year
.
appendChild
(
option
)
;
}
if
(
ccExpYear
&
&
ccExpYear
>
currentYear
+
count
)
{
this
.
_elements
.
year
.
appendChild
(
new
Option
(
ccExpYear
)
)
;
}
}
generateBillingAddressOptions
(
preserveFieldValues
)
{
let
billingAddressGUID
;
if
(
preserveFieldValues
&
&
this
.
_elements
.
billingAddress
.
value
)
{
billingAddressGUID
=
this
.
_elements
.
billingAddress
.
value
;
}
else
if
(
this
.
_record
)
{
billingAddressGUID
=
this
.
_record
.
billingAddressGUID
;
}
this
.
_elements
.
billingAddress
.
textContent
=
"
"
;
this
.
_elements
.
billingAddress
.
appendChild
(
new
Option
(
"
"
"
"
)
)
;
let
hasAddresses
=
false
;
for
(
let
[
guid
address
]
of
Object
.
entries
(
this
.
_addresses
)
)
{
hasAddresses
=
true
;
let
selected
=
guid
=
=
billingAddressGUID
;
let
option
=
new
Option
(
FormAutofillUtils
.
getAddressLabel
(
address
)
guid
selected
selected
)
;
this
.
_elements
.
billingAddress
.
appendChild
(
option
)
;
}
this
.
_elements
.
billingAddressRow
.
hidden
=
!
hasAddresses
;
}
attachEventListeners
(
)
{
this
.
_elements
.
form
.
addEventListener
(
"
change
"
this
)
;
super
.
attachEventListeners
(
)
;
}
handleInput
(
event
)
{
if
(
event
.
target
=
=
this
.
_elements
.
ccNumber
&
&
FormAutofillUtils
.
isCCNumber
(
this
.
_elements
.
ccNumber
.
value
)
)
{
this
.
_elements
.
ccNumber
.
setCustomValidity
(
"
"
)
;
}
super
.
handleInput
(
event
)
;
}
updateCustomValidity
(
field
)
{
super
.
updateCustomValidity
(
field
)
;
if
(
field
=
=
this
.
_elements
.
ccNumber
&
&
!
FormAutofillUtils
.
isCCNumber
(
field
.
value
)
)
{
let
invalidCardNumberString
=
this
.
_elements
.
invalidCardNumberStringElement
.
textContent
;
field
.
setCustomValidity
(
invalidCardNumberString
|
|
"
"
)
;
}
}
}
