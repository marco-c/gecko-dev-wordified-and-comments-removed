"
use
strict
"
;
class
EditAutofillForm
{
constructor
(
elements
)
{
this
.
_elements
=
elements
;
}
loadRecord
(
record
=
{
}
)
{
for
(
let
field
of
this
.
_elements
.
form
.
elements
)
{
let
value
=
record
[
field
.
id
]
;
value
=
typeof
(
value
)
=
=
"
undefined
"
?
"
"
:
value
;
if
(
record
.
guid
)
{
field
.
value
=
value
;
}
else
if
(
field
.
localName
=
=
"
select
"
)
{
this
.
setDefaultSelectedOptionByValue
(
field
value
)
;
}
else
{
field
.
defaultValue
=
value
;
}
}
if
(
!
record
.
guid
)
{
this
.
_elements
.
form
.
reset
(
)
;
}
for
(
let
field
of
this
.
_elements
.
form
.
elements
)
{
this
.
updatePopulatedState
(
field
)
;
}
}
setDefaultSelectedOptionByValue
(
select
value
)
{
for
(
let
option
of
select
.
options
)
{
option
.
defaultSelected
=
option
.
value
=
=
value
;
}
}
buildFormObject
(
)
{
return
Array
.
from
(
this
.
_elements
.
form
.
elements
)
.
reduce
(
(
obj
input
)
=
>
{
if
(
!
input
.
disabled
)
{
obj
[
input
.
id
]
=
input
.
value
;
}
return
obj
;
}
{
}
)
;
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
change
"
:
{
this
.
handleChange
(
event
)
;
break
;
}
case
"
input
"
:
{
this
.
handleInput
(
event
)
;
break
;
}
}
}
handleChange
(
event
)
{
this
.
updatePopulatedState
(
event
.
target
)
;
}
handleInput
(
event
)
{
}
attachEventListeners
(
)
{
this
.
_elements
.
form
.
addEventListener
(
"
input
"
this
)
;
}
updatePopulatedState
(
field
)
{
let
span
=
field
.
parentNode
.
querySelector
(
"
.
label
-
text
"
)
;
if
(
!
span
)
{
return
;
}
span
.
toggleAttribute
(
"
field
-
populated
"
!
!
field
.
value
.
trim
(
)
)
;
}
}
class
EditAddress
extends
EditAutofillForm
{
constructor
(
elements
record
config
)
{
super
(
elements
)
;
Object
.
assign
(
this
config
)
;
Object
.
assign
(
this
.
_elements
{
addressLevel1Label
:
this
.
_elements
.
form
.
querySelector
(
"
#
address
-
level1
-
container
>
span
"
)
postalCodeLabel
:
this
.
_elements
.
form
.
querySelector
(
"
#
postal
-
code
-
container
>
span
"
)
country
:
this
.
_elements
.
form
.
querySelector
(
"
#
country
"
)
}
)
;
this
.
populateCountries
(
)
;
this
.
loadRecord
(
record
)
;
this
.
attachEventListeners
(
)
;
if
(
config
.
novalidate
)
{
this
.
form
.
setAttribute
(
"
novalidate
"
"
true
"
)
;
}
}
loadRecord
(
record
)
{
this
.
_record
=
record
;
if
(
!
record
)
{
record
=
{
country
:
this
.
supportedCountries
.
find
(
supported
=
>
supported
=
=
this
.
DEFAULT_REGION
)
}
;
}
super
.
loadRecord
(
record
)
;
this
.
formatForm
(
record
.
country
)
;
}
computeVisibleFields
(
mailingFieldsOrder
)
{
let
addressFields
=
this
.
_elements
.
form
.
dataset
.
addressFields
;
if
(
addressFields
)
{
let
requestedFieldClasses
=
addressFields
.
trim
(
)
.
split
(
/
\
s
+
/
)
;
let
fieldClasses
=
[
]
;
if
(
requestedFieldClasses
.
includes
(
"
mailing
-
address
"
)
)
{
fieldClasses
=
fieldClasses
.
concat
(
mailingFieldsOrder
)
;
requestedFieldClasses
.
splice
(
requestedFieldClasses
.
indexOf
(
"
mailing
-
address
"
)
1
"
country
"
)
;
}
for
(
let
fieldClassName
of
requestedFieldClasses
)
{
fieldClasses
.
push
(
{
fieldId
:
fieldClassName
newLine
:
fieldClassName
=
=
"
name
"
}
)
;
}
return
fieldClasses
;
}
return
mailingFieldsOrder
.
concat
(
[
{
fieldId
:
"
country
"
}
{
fieldId
:
"
tel
"
}
{
fieldId
:
"
email
"
newLine
:
true
}
]
)
;
}
formatForm
(
country
)
{
const
{
addressLevel1Label
postalCodeLabel
fieldsOrder
:
mailingFieldsOrder
postalCodePattern
}
=
this
.
getFormFormat
(
country
)
;
this
.
_elements
.
addressLevel1Label
.
dataset
.
localization
=
addressLevel1Label
;
this
.
_elements
.
postalCodeLabel
.
dataset
.
localization
=
postalCodeLabel
;
let
fieldClasses
=
this
.
computeVisibleFields
(
mailingFieldsOrder
)
;
this
.
arrangeFields
(
fieldClasses
)
;
this
.
updatePostalCodeValidation
(
postalCodePattern
)
;
}
arrangeFields
(
fieldsOrder
)
{
let
fields
=
[
"
name
"
"
organization
"
"
street
-
address
"
"
address
-
level2
"
"
address
-
level1
"
"
postal
-
code
"
"
country
"
"
tel
"
"
email
"
]
;
let
inputs
=
[
]
;
for
(
let
i
=
0
;
i
<
fieldsOrder
.
length
;
i
+
+
)
{
let
{
fieldId
newLine
}
=
fieldsOrder
[
i
]
;
let
container
=
this
.
_elements
.
form
.
querySelector
(
#
{
fieldId
}
-
container
)
;
let
containerInputs
=
[
.
.
.
container
.
querySelectorAll
(
"
input
textarea
select
"
)
]
;
containerInputs
.
forEach
(
function
(
input
)
{
input
.
disabled
=
false
;
}
)
;
inputs
.
push
(
.
.
.
containerInputs
)
;
container
.
style
.
display
=
"
flex
"
;
container
.
style
.
order
=
i
;
container
.
style
.
pageBreakAfter
=
newLine
?
"
always
"
:
"
auto
"
;
fields
.
splice
(
fields
.
indexOf
(
fieldId
)
1
)
;
}
for
(
let
i
=
0
;
i
<
inputs
.
length
;
i
+
+
)
{
inputs
[
i
]
.
tabIndex
=
i
+
1
;
}
for
(
let
field
of
fields
)
{
let
container
=
this
.
_elements
.
form
.
querySelector
(
#
{
field
}
-
container
)
;
container
.
style
.
display
=
"
none
"
;
for
(
let
input
of
[
.
.
.
container
.
querySelectorAll
(
"
input
textarea
select
"
)
]
)
{
input
.
disabled
=
true
;
}
}
}
updatePostalCodeValidation
(
postalCodePattern
)
{
let
postalCodeInput
=
this
.
_elements
.
form
.
querySelector
(
"
#
postal
-
code
"
)
;
if
(
postalCodePattern
&
&
postalCodeInput
.
style
.
display
!
=
"
none
"
)
{
postalCodeInput
.
setAttribute
(
"
pattern
"
postalCodePattern
)
;
}
else
{
postalCodeInput
.
removeAttribute
(
"
pattern
"
)
;
}
}
populateCountries
(
)
{
let
fragment
=
document
.
createDocumentFragment
(
)
;
for
(
let
country
of
this
.
supportedCountries
)
{
let
option
=
new
Option
(
)
;
option
.
value
=
country
;
option
.
dataset
.
localizationRegion
=
country
.
toLowerCase
(
)
;
fragment
.
appendChild
(
option
)
;
}
this
.
_elements
.
country
.
appendChild
(
fragment
)
;
}
handleChange
(
event
)
{
if
(
event
.
target
=
=
this
.
_elements
.
country
)
{
this
.
formatForm
(
event
.
target
.
value
)
;
}
super
.
handleChange
(
event
)
;
}
attachEventListeners
(
)
{
this
.
_elements
.
form
.
addEventListener
(
"
change
"
this
)
;
super
.
attachEventListeners
(
)
;
}
}
class
EditCreditCard
extends
EditAutofillForm
{
constructor
(
elements
record
addresses
config
)
{
super
(
elements
)
;
this
.
_addresses
=
addresses
;
Object
.
assign
(
this
config
)
;
Object
.
assign
(
this
.
_elements
{
ccNumber
:
this
.
_elements
.
form
.
querySelector
(
"
#
cc
-
number
"
)
invalidCardNumberStringElement
:
this
.
_elements
.
form
.
querySelector
(
"
#
invalidCardNumberString
"
)
month
:
this
.
_elements
.
form
.
querySelector
(
"
#
cc
-
exp
-
month
"
)
year
:
this
.
_elements
.
form
.
querySelector
(
"
#
cc
-
exp
-
year
"
)
ccType
:
this
.
_elements
.
form
.
querySelector
(
"
#
cc
-
type
"
)
billingAddress
:
this
.
_elements
.
form
.
querySelector
(
"
#
billingAddressGUID
"
)
billingAddressRow
:
this
.
_elements
.
form
.
querySelector
(
"
.
billingAddressRow
"
)
}
)
;
this
.
loadRecord
(
record
addresses
)
;
this
.
attachEventListeners
(
)
;
}
loadRecord
(
record
addresses
preserveFieldValues
)
{
this
.
_record
=
record
;
this
.
_addresses
=
addresses
;
this
.
generateBillingAddressOptions
(
)
;
if
(
!
preserveFieldValues
)
{
this
.
populateNetworks
(
)
;
this
.
generateYears
(
)
;
super
.
loadRecord
(
record
)
;
this
.
_elements
.
ccNumber
.
setCustomValidity
(
"
"
)
;
}
}
generateYears
(
)
{
const
count
=
11
;
const
currentYear
=
new
Date
(
)
.
getFullYear
(
)
;
const
ccExpYear
=
this
.
_record
&
&
this
.
_record
[
"
cc
-
exp
-
year
"
]
;
this
.
_elements
.
year
.
textContent
=
"
"
;
this
.
_elements
.
year
.
appendChild
(
new
Option
(
)
)
;
if
(
ccExpYear
&
&
ccExpYear
<
currentYear
)
{
this
.
_elements
.
year
.
appendChild
(
new
Option
(
ccExpYear
)
)
;
}
for
(
let
i
=
0
;
i
<
count
;
i
+
+
)
{
let
year
=
currentYear
+
i
;
let
option
=
new
Option
(
year
)
;
this
.
_elements
.
year
.
appendChild
(
option
)
;
}
if
(
ccExpYear
&
&
ccExpYear
>
currentYear
+
count
)
{
this
.
_elements
.
year
.
appendChild
(
new
Option
(
ccExpYear
)
)
;
}
}
populateNetworks
(
)
{
this
.
_elements
.
ccType
.
textContent
=
"
"
;
let
frag
=
document
.
createDocumentFragment
(
)
;
frag
.
appendChild
(
new
Option
(
"
"
"
"
)
)
;
let
supportedNetworks
=
this
.
getSupportedNetworks
(
)
;
for
(
let
id
of
supportedNetworks
)
{
let
option
=
new
Option
(
)
;
option
.
value
=
id
;
option
.
dataset
.
localization
=
"
cardNetwork
.
"
+
id
;
frag
.
appendChild
(
option
)
;
}
this
.
_elements
.
ccType
.
appendChild
(
frag
)
;
}
generateBillingAddressOptions
(
)
{
let
billingAddressGUID
=
this
.
_record
&
&
this
.
_record
.
billingAddressGUID
;
this
.
_elements
.
billingAddress
.
textContent
=
"
"
;
this
.
_elements
.
billingAddress
.
appendChild
(
new
Option
(
"
"
"
"
)
)
;
let
hasAddresses
=
false
;
for
(
let
[
guid
address
]
of
Object
.
entries
(
this
.
_addresses
)
)
{
hasAddresses
=
true
;
let
selected
=
guid
=
=
billingAddressGUID
;
let
option
=
new
Option
(
this
.
getAddressLabel
(
address
)
guid
selected
selected
)
;
this
.
_elements
.
billingAddress
.
appendChild
(
option
)
;
}
this
.
_elements
.
billingAddressRow
.
hidden
=
!
hasAddresses
;
}
attachEventListeners
(
)
{
this
.
_elements
.
form
.
addEventListener
(
"
change
"
this
)
;
super
.
attachEventListeners
(
)
;
}
handleChange
(
event
)
{
super
.
handleChange
(
event
)
;
if
(
event
.
target
!
=
this
.
_elements
.
ccNumber
)
{
return
;
}
let
ccNumberField
=
this
.
_elements
.
ccNumber
;
if
(
!
this
.
isCCNumber
(
ccNumberField
.
value
)
)
{
let
invalidCardNumberString
=
this
.
_elements
.
invalidCardNumberStringElement
.
textContent
;
ccNumberField
.
setCustomValidity
(
invalidCardNumberString
|
|
"
"
)
;
}
}
handleInput
(
event
)
{
if
(
event
.
target
=
=
this
.
_elements
.
ccNumber
&
&
this
.
isCCNumber
(
this
.
_elements
.
ccNumber
.
value
)
)
{
this
.
_elements
.
ccNumber
.
setCustomValidity
(
"
"
)
;
}
super
.
handleInput
(
event
)
;
}
}
