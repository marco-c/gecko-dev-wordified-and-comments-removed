"
use
strict
"
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
}
=
Components
;
const
EDIT_PROFILE_URL
=
"
chrome
:
/
/
formautofill
/
content
/
editProfile
.
xhtml
"
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
formautofill
/
FormAutofillUtils
.
jsm
"
)
;
this
.
log
=
null
;
FormAutofillUtils
.
defineLazyLogGetter
(
this
"
manageProfiles
"
)
;
function
ManageProfileDialog
(
)
{
this
.
prefWin
=
window
.
opener
;
window
.
addEventListener
(
"
DOMContentLoaded
"
this
{
once
:
true
}
)
;
}
ManageProfileDialog
.
prototype
=
{
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsISupports
Ci
.
nsIObserver
]
)
_elements
:
{
}
_pendingChangeCount
:
0
get
_selectedOptions
(
)
{
return
Array
.
from
(
this
.
_elements
.
addresses
.
selectedOptions
)
;
}
init
(
)
{
this
.
_elements
=
{
addresses
:
document
.
getElementById
(
"
profiles
"
)
controlsContainer
:
document
.
getElementById
(
"
controls
-
container
"
)
remove
:
document
.
getElementById
(
"
remove
"
)
add
:
document
.
getElementById
(
"
add
"
)
edit
:
document
.
getElementById
(
"
edit
"
)
}
;
this
.
attachEventListeners
(
)
;
}
uninit
(
)
{
log
.
debug
(
"
uninit
"
)
;
this
.
detachEventListeners
(
)
;
this
.
_elements
=
null
;
}
loadAddresses
(
)
{
return
this
.
getAddresses
(
)
.
then
(
addresses
=
>
{
log
.
debug
(
"
addresses
:
"
addresses
)
;
addresses
.
sort
(
(
a
b
)
=
>
b
.
timeLastModified
-
a
.
timeLastModified
)
;
this
.
renderAddressElements
(
addresses
)
;
this
.
updateButtonsStates
(
this
.
_selectedOptions
.
length
)
;
}
)
;
}
getAddresses
(
)
{
return
new
Promise
(
resolve
=
>
{
Services
.
cpmm
.
addMessageListener
(
"
FormAutofill
:
Addresses
"
function
getResult
(
result
)
{
Services
.
cpmm
.
removeMessageListener
(
"
FormAutofill
:
Addresses
"
getResult
)
;
resolve
(
result
.
data
)
;
}
)
;
Services
.
cpmm
.
sendAsyncMessage
(
"
FormAutofill
:
GetAddresses
"
{
}
)
;
}
)
;
}
renderAddressElements
(
addresses
)
{
let
selectedGuids
=
this
.
_selectedOptions
.
map
(
option
=
>
option
.
value
)
;
this
.
clearAddressElements
(
)
;
for
(
let
address
of
addresses
)
{
let
option
=
new
Option
(
this
.
getAddressLabel
(
address
)
address
.
guid
false
selectedGuids
.
includes
(
address
.
guid
)
)
;
option
.
address
=
address
;
this
.
_elements
.
addresses
.
appendChild
(
option
)
;
}
}
clearAddressElements
(
)
{
let
parent
=
this
.
_elements
.
addresses
;
while
(
parent
.
lastChild
)
{
parent
.
removeChild
(
parent
.
lastChild
)
;
}
}
removeAddresses
(
guids
)
{
this
.
_pendingChangeCount
+
=
guids
.
length
-
1
;
Services
.
cpmm
.
sendAsyncMessage
(
"
FormAutofill
:
RemoveAddresses
"
{
guids
}
)
;
}
getAddressLabel
(
address
)
{
const
fieldOrder
=
[
"
name
"
"
street
-
address
"
"
address
-
level2
"
"
organization
"
"
address
-
level1
"
"
country
-
name
"
"
postal
-
code
"
"
tel
"
"
email
"
]
;
let
parts
=
[
]
;
if
(
address
[
"
street
-
address
"
]
)
{
address
[
"
street
-
address
"
]
=
FormAutofillUtils
.
toOneLineAddress
(
address
[
"
street
-
address
"
]
)
;
}
for
(
const
fieldName
of
fieldOrder
)
{
let
string
=
address
[
fieldName
]
;
if
(
string
)
{
parts
.
push
(
string
)
;
}
if
(
parts
.
length
=
=
2
)
{
break
;
}
}
return
parts
.
join
(
"
"
)
;
}
openEditDialog
(
address
)
{
this
.
prefWin
.
gSubDialog
.
open
(
EDIT_PROFILE_URL
null
address
)
;
}
updateButtonsStates
(
selectedCount
)
{
log
.
debug
(
"
updateButtonsStates
:
"
selectedCount
)
;
if
(
selectedCount
=
=
0
)
{
this
.
_elements
.
edit
.
setAttribute
(
"
disabled
"
"
disabled
"
)
;
this
.
_elements
.
remove
.
setAttribute
(
"
disabled
"
"
disabled
"
)
;
}
else
if
(
selectedCount
=
=
1
)
{
this
.
_elements
.
edit
.
removeAttribute
(
"
disabled
"
)
;
this
.
_elements
.
remove
.
removeAttribute
(
"
disabled
"
)
;
}
else
if
(
selectedCount
>
1
)
{
this
.
_elements
.
edit
.
setAttribute
(
"
disabled
"
"
disabled
"
)
;
this
.
_elements
.
remove
.
removeAttribute
(
"
disabled
"
)
;
}
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
DOMContentLoaded
"
:
{
this
.
init
(
)
;
this
.
loadAddresses
(
)
;
break
;
}
case
"
click
"
:
{
this
.
handleClick
(
event
)
;
break
;
}
case
"
change
"
:
{
this
.
updateButtonsStates
(
this
.
_selectedOptions
.
length
)
;
break
;
}
case
"
unload
"
:
{
this
.
uninit
(
)
;
break
;
}
case
"
keypress
"
:
{
this
.
handleKeyPress
(
event
)
;
break
;
}
}
}
handleClick
(
event
)
{
if
(
event
.
target
=
=
this
.
_elements
.
remove
)
{
this
.
removeAddresses
(
this
.
_selectedOptions
.
map
(
option
=
>
option
.
value
)
)
;
}
else
if
(
event
.
target
=
=
this
.
_elements
.
add
)
{
this
.
openEditDialog
(
)
;
}
else
if
(
event
.
target
=
=
this
.
_elements
.
edit
)
{
this
.
openEditDialog
(
this
.
_selectedOptions
[
0
]
.
address
)
;
}
}
handleKeyPress
(
event
)
{
if
(
event
.
keyCode
=
=
KeyEvent
.
DOM_VK_ESCAPE
)
{
window
.
close
(
)
;
}
}
observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
"
formautofill
-
storage
-
changed
"
:
{
if
(
this
.
_pendingChangeCount
)
{
this
.
_pendingChangeCount
-
=
1
;
return
;
}
this
.
loadAddresses
(
)
;
}
}
}
attachEventListeners
(
)
{
window
.
addEventListener
(
"
unload
"
this
{
once
:
true
}
)
;
window
.
addEventListener
(
"
keypress
"
this
)
;
this
.
_elements
.
addresses
.
addEventListener
(
"
change
"
this
)
;
this
.
_elements
.
controlsContainer
.
addEventListener
(
"
click
"
this
)
;
Services
.
obs
.
addObserver
(
this
"
formautofill
-
storage
-
changed
"
)
;
}
detachEventListeners
(
)
{
window
.
removeEventListener
(
"
keypress
"
this
)
;
this
.
_elements
.
addresses
.
removeEventListener
(
"
change
"
this
)
;
this
.
_elements
.
controlsContainer
.
removeEventListener
(
"
click
"
this
)
;
Services
.
obs
.
removeObserver
(
this
"
formautofill
-
storage
-
changed
"
)
;
}
}
;
new
ManageProfileDialog
(
)
;
