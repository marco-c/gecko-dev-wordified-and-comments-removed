"
use
strict
"
;
const
{
ManageAddresses
}
=
ChromeUtils
.
importESModule
(
"
chrome
:
/
/
formautofill
/
content
/
manageDialog
.
mjs
"
)
;
const
{
OSKeyStore
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
OSKeyStore
.
sys
.
mjs
"
)
;
const
{
OSKeyStoreTestUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
OSKeyStoreTestUtils
.
sys
.
mjs
"
)
;
const
{
FormAutofillParent
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
autofill
/
FormAutofillParent
.
sys
.
mjs
"
)
;
const
{
AutofillDoorhanger
AddressEditDoorhanger
AddressSaveDoorhanger
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
autofill
/
FormAutofillPrompter
.
sys
.
mjs
"
)
;
const
{
FormAutofillNameUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
shared
/
FormAutofillNameUtils
.
sys
.
mjs
"
)
;
const
{
FormAutofillUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
shared
/
FormAutofillUtils
.
sys
.
mjs
"
)
;
let
{
sinon
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
Sinon
.
sys
.
mjs
"
)
;
if
(
gTestPath
.
includes
(
"
browser
/
creditCard
"
)
&
&
OSKeyStoreTestUtils
.
canTestOSKeyStoreLogin
(
)
&
&
OSKeyStore
.
canReauth
(
)
)
{
info
(
"
Stubbing
out
getOSAuthEnabled
so
it
always
returns
true
"
)
;
sinon
.
stub
(
FormAutofillUtils
"
getOSAuthEnabled
"
)
.
returns
(
true
)
;
registerCleanupFunction
(
(
)
=
>
{
sinon
.
restore
(
)
;
}
)
;
}
const
MANAGE_ADDRESSES_DIALOG_URL
=
"
chrome
:
/
/
formautofill
/
content
/
manageAddresses
.
xhtml
"
;
const
MANAGE_CREDIT_CARDS_DIALOG_URL
=
"
chrome
:
/
/
formautofill
/
content
/
manageCreditCards
.
xhtml
"
;
const
EDIT_ADDRESS_DIALOG_URL
=
"
chrome
:
/
/
formautofill
/
content
/
editAddress
.
xhtml
"
;
const
EDIT_CREDIT_CARD_DIALOG_URL
=
"
chrome
:
/
/
formautofill
/
content
/
editCreditCard
.
xhtml
"
;
const
PRIVACY_PREF_URL
=
"
about
:
preferences
#
privacy
"
;
const
HTTP_TEST_PATH
=
"
/
browser
/
browser
/
extensions
/
formautofill
/
test
/
browser
/
"
;
const
BASE_URL
=
"
http
:
/
/
mochi
.
test
:
8888
"
+
HTTP_TEST_PATH
;
const
FORM_URL
=
BASE_URL
+
"
autocomplete_basic
.
html
"
;
const
ADDRESS_FORM_URL
=
"
https
:
/
/
example
.
org
"
+
HTTP_TEST_PATH
+
"
address
/
autocomplete_address_basic
.
html
"
;
const
ADDRESS_FORM_WITHOUT_AUTOCOMPLETE_URL
=
"
https
:
/
/
example
.
org
"
+
HTTP_TEST_PATH
+
"
address
/
without_autocomplete_address_basic
.
html
"
;
const
ADDRESS_FORM_WITH_PAGE_NAVIGATION_BUTTONS
=
"
https
:
/
/
example
.
org
"
+
HTTP_TEST_PATH
+
"
address
/
capture_address_on_page_navigation
.
html
"
;
const
FORM_IFRAME_SANDBOXED_URL
=
"
https
:
/
/
example
.
org
"
+
HTTP_TEST_PATH
+
"
autocomplete_iframe_sandboxed
.
html
"
;
const
CREDITCARD_FORM_URL
=
"
https
:
/
/
example
.
org
"
+
HTTP_TEST_PATH
+
"
creditCard
/
autocomplete_creditcard_basic
.
html
"
;
const
CREDITCARD_FORM_IFRAME_URL
=
"
https
:
/
/
example
.
org
"
+
HTTP_TEST_PATH
+
"
creditCard
/
autocomplete_creditcard_iframe
.
html
"
;
const
CREDITCARD_FORM_COMBINED_EXPIRY_URL
=
"
https
:
/
/
example
.
org
"
+
HTTP_TEST_PATH
+
"
creditCard
/
autocomplete_creditcard_cc_exp_field
.
html
"
;
const
CREDITCARD_FORM_WITHOUT_AUTOCOMPLETE_URL
=
"
https
:
/
/
example
.
org
"
+
HTTP_TEST_PATH
+
"
creditCard
/
without_autocomplete_creditcard_basic
.
html
"
;
const
CREDITCARD_FORM_WITH_PAGE_NAVIGATION_BUTTONS
=
"
https
:
/
/
example
.
org
"
+
HTTP_TEST_PATH
+
"
creditCard
/
capture_creditCard_on_page_navigation
.
html
"
;
const
EMPTY_URL
=
"
https
:
/
/
example
.
org
"
+
HTTP_TEST_PATH
+
"
empty
.
html
"
;
const
ENABLED_AUTOFILL_ADDRESSES_PREF
=
"
extensions
.
formautofill
.
addresses
.
enabled
"
;
const
ENABLED_AUTOFILL_ADDRESSES_CAPTURE_PREF
=
"
extensions
.
formautofill
.
addresses
.
capture
.
enabled
"
;
const
AUTOFILL_ADDRESSES_AVAILABLE_PREF
=
"
extensions
.
formautofill
.
addresses
.
supported
"
;
const
ENABLED_AUTOFILL_ADDRESSES_SUPPORTED_COUNTRIES_PREF
=
"
extensions
.
formautofill
.
addresses
.
supportedCountries
"
;
const
AUTOFILL_CREDITCARDS_AVAILABLE_PREF
=
"
extensions
.
formautofill
.
creditCards
.
supported
"
;
const
ENABLED_AUTOFILL_CREDITCARDS_PREF
=
"
extensions
.
formautofill
.
creditCards
.
enabled
"
;
const
SUPPORTED_COUNTRIES_PREF
=
"
extensions
.
formautofill
.
supportedCountries
"
;
const
SYNC_USERNAME_PREF
=
"
services
.
sync
.
username
"
;
const
SYNC_ADDRESSES_PREF
=
"
services
.
sync
.
engine
.
addresses
"
;
const
SYNC_CREDITCARDS_PREF
=
"
services
.
sync
.
engine
.
creditcards
"
;
const
SYNC_CREDITCARDS_AVAILABLE_PREF
=
"
services
.
sync
.
engine
.
creditcards
.
available
"
;
const
TEST_ADDRESS_1
=
{
"
given
-
name
"
:
"
John
"
"
additional
-
name
"
:
"
R
.
"
"
family
-
name
"
:
"
Smith
"
organization
:
"
World
Wide
Web
Consortium
"
"
street
-
address
"
:
"
32
Vassar
Street
\
nMIT
Room
32
-
G524
"
"
address
-
level2
"
:
"
Cambridge
"
"
address
-
level1
"
:
"
MA
"
"
postal
-
code
"
:
"
02139
"
country
:
"
US
"
tel
:
"
+
16172535702
"
email
:
"
timbl
w3
.
org
"
}
;
const
TEST_ADDRESS_2
=
{
"
given
-
name
"
:
"
Anonymouse
"
"
street
-
address
"
:
"
Some
Address
"
country
:
"
US
"
}
;
const
TEST_ADDRESS_3
=
{
"
given
-
name
"
:
"
John
"
"
street
-
address
"
:
"
Other
Address
"
"
postal
-
code
"
:
"
12345
"
}
;
const
TEST_ADDRESS_4
=
{
"
given
-
name
"
:
"
Timothy
"
"
family
-
name
"
:
"
Berners
-
Lee
"
organization
:
"
World
Wide
Web
Consortium
"
"
street
-
address
"
:
"
32
Vassar
Street
\
nMIT
Room
32
-
G524
"
country
:
"
US
"
email
:
"
timbl
w3
.
org
"
}
;
const
TEST_ADDRESS_5
=
{
tel
:
"
+
16172535702
"
}
;
const
TEST_ADDRESS_CA_1
=
{
"
given
-
name
"
:
"
John
"
"
additional
-
name
"
:
"
R
.
"
"
family
-
name
"
:
"
Smith
"
organization
:
"
Mozilla
"
"
street
-
address
"
:
"
163
W
Hastings
\
nSuite
209
"
"
address
-
level2
"
:
"
Vancouver
"
"
address
-
level1
"
:
"
BC
"
"
postal
-
code
"
:
"
V6B
1H5
"
country
:
"
CA
"
tel
:
"
+
17787851540
"
email
:
"
timbl
w3
.
org
"
}
;
const
TEST_ADDRESS_DE_1
=
{
"
given
-
name
"
:
"
John
"
"
additional
-
name
"
:
"
R
.
"
"
family
-
name
"
:
"
Smith
"
organization
:
"
Mozilla
"
"
street
-
address
"
:
"
Geb
\
u00E4ude
3
4
.
Obergeschoss
\
nSchlesische
Stra
\
u00DFe
27
"
"
address
-
level2
"
:
"
Berlin
"
"
postal
-
code
"
:
"
10997
"
country
:
"
DE
"
tel
:
"
+
4930983333000
"
email
:
"
timbl
w3
.
org
"
}
;
const
TEST_ADDRESS_IE_1
=
{
"
given
-
name
"
:
"
Bob
"
"
additional
-
name
"
:
"
Z
.
"
"
family
-
name
"
:
"
Builder
"
organization
:
"
Best
Co
.
"
"
street
-
address
"
:
"
123
Kilkenny
St
.
"
"
address
-
level3
"
:
"
Some
Townland
"
"
address
-
level2
"
:
"
Dublin
"
"
address
-
level1
"
:
"
Co
.
Dublin
"
"
postal
-
code
"
:
"
A65
F4E2
"
country
:
"
IE
"
tel
:
"
+
13534564947391
"
email
:
"
ie
example
.
com
"
}
;
const
TEST_CREDIT_CARD_1
=
{
"
cc
-
name
"
:
"
John
Doe
"
"
cc
-
number
"
:
"
4111111111111111
"
"
cc
-
exp
-
month
"
:
4
"
cc
-
exp
-
year
"
:
new
Date
(
)
.
getFullYear
(
)
}
;
const
TEST_CREDIT_CARD_2
=
{
"
cc
-
name
"
:
"
Timothy
Berners
-
Lee
"
"
cc
-
number
"
:
"
4929001587121045
"
"
cc
-
exp
-
month
"
:
12
"
cc
-
exp
-
year
"
:
new
Date
(
)
.
getFullYear
(
)
+
10
}
;
const
TEST_CREDIT_CARD_3
=
{
"
cc
-
number
"
:
"
5103059495477870
"
"
cc
-
exp
-
month
"
:
1
"
cc
-
exp
-
year
"
:
2000
}
;
const
TEST_CREDIT_CARD_4
=
{
"
cc
-
number
"
:
"
5105105105105100
"
}
;
const
TEST_CREDIT_CARD_5
=
{
"
cc
-
name
"
:
"
Chris
P
.
Bacon
"
"
cc
-
number
"
:
"
4012888888881881
"
}
;
const
MAIN_BUTTON
=
"
button
"
;
const
SECONDARY_BUTTON
=
"
secondaryButton
"
;
const
MENU_BUTTON
=
"
menubutton
"
;
const
EDIT_ADDRESS_BUTTON
=
"
edit
"
;
const
ADDRESS_MENU_BUTTON
=
"
addressMenuButton
"
;
const
ADDRESS_MENU_LEARN_MORE
=
"
learnMore
"
;
const
ADDRESS_MENU_PREFENCE
=
"
preference
"
;
const
TIMEOUT_ENSURE_PROFILE_NOT_SAVED
=
1000
;
const
TIMEOUT_ENSURE_CC_DIALOG_NOT_CLOSED
=
500
;
const
TIMEOUT_ENSURE_AUTOCOMPLETE_NOT_SHOWN
=
1000
;
const
TIMEOUT_ENSURE_DOORHANGER_NOT_SHOWN
=
1000
;
async
function
ensureCreditCardDialogNotClosed
(
win
)
{
const
unloadHandler
=
(
)
=
>
{
ok
(
false
"
Credit
card
dialog
shouldn
'
t
be
closed
"
)
;
}
;
win
.
addEventListener
(
"
unload
"
unloadHandler
)
;
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
TIMEOUT_ENSURE_CC_DIALOG_NOT_CLOSED
)
)
;
win
.
removeEventListener
(
"
unload
"
unloadHandler
)
;
}
function
getDisplayedPopupItems
(
browser
selector
=
"
.
autocomplete
-
richlistitem
"
)
{
info
(
"
getDisplayedPopupItems
"
)
;
const
{
autoCompletePopup
:
{
richlistbox
:
itemsBox
}
}
=
browser
;
const
listItemElems
=
itemsBox
.
querySelectorAll
(
selector
)
;
return
[
.
.
.
listItemElems
]
.
filter
(
item
=
>
item
.
getAttribute
(
"
collapsed
"
)
!
=
"
true
"
)
;
}
async
function
sleep
(
ms
=
500
)
{
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
ms
)
)
;
}
async
function
ensureNoAutocompletePopup
(
browser
)
{
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
TIMEOUT_ENSURE_AUTOCOMPLETE_NOT_SHOWN
)
)
;
const
items
=
getDisplayedPopupItems
(
browser
)
;
ok
(
!
items
.
length
"
Should
not
find
autocomplete
items
"
)
;
}
async
function
ensureNoDoorhanger
(
)
{
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
TIMEOUT_ENSURE_DOORHANGER_NOT_SHOWN
)
)
;
let
notifications
=
PopupNotifications
.
panel
.
childNodes
;
ok
(
!
notifications
.
length
"
Should
not
find
a
doorhanger
"
)
;
}
async
function
waitForStorageChangedEvents
(
.
.
.
eventTypes
)
{
return
Promise
.
all
(
eventTypes
.
map
(
type
=
>
TestUtils
.
topicObserved
(
"
formautofill
-
storage
-
changed
"
(
subject
data
)
=
>
{
return
data
=
=
type
;
}
)
)
)
;
}
async
function
waitForAutofill
(
target
selector
value
)
{
await
SpecialPowers
.
spawn
(
target
[
selector
value
]
async
function
(
selector
val
)
{
await
ContentTaskUtils
.
waitForCondition
(
(
)
=
>
{
let
element
=
content
.
document
.
querySelector
(
selector
)
;
return
element
.
value
=
=
val
;
}
"
Autofill
never
fills
"
)
;
}
)
;
}
function
waitForSubDialogLoad
(
win
dialogUrl
)
{
return
new
Promise
(
resolve
=
>
{
win
.
gSubDialog
.
_dialogStack
.
addEventListener
(
"
dialogopen
"
async
function
dialogopen
(
evt
)
{
let
cwin
=
evt
.
detail
.
dialog
.
_frame
.
contentWindow
;
if
(
cwin
.
location
!
=
dialogUrl
)
{
return
;
}
content
.
gSubDialog
.
_dialogStack
.
removeEventListener
(
"
dialogopen
"
dialogopen
)
;
resolve
(
cwin
)
;
}
)
;
}
)
;
}
async
function
focusUpdateSubmitForm
(
target
args
submit
=
true
)
{
let
fieldsIdentifiedPromiseResolver
;
let
fieldsIdentifiedObserver
=
{
fieldsIdentified
(
)
{
FormAutofillParent
.
removeMessageObserver
(
fieldsIdentifiedObserver
)
;
fieldsIdentifiedPromiseResolver
(
)
;
}
}
;
let
fieldsIdentifiedPromise
=
new
Promise
(
resolve
=
>
{
fieldsIdentifiedPromiseResolver
=
resolve
;
FormAutofillParent
.
addMessageObserver
(
fieldsIdentifiedObserver
)
;
}
)
;
let
alreadyFocused
=
await
SpecialPowers
.
spawn
(
target
[
args
]
obj
=
>
{
let
focused
=
false
;
let
form
;
if
(
obj
.
formSelector
)
{
form
=
content
.
document
.
querySelector
(
obj
.
formSelector
)
;
}
else
{
form
=
content
.
document
.
getElementById
(
obj
.
formId
?
?
"
form
"
)
;
}
let
element
=
form
.
querySelector
(
obj
.
focusSelector
)
;
if
(
element
!
=
content
.
document
.
activeElement
)
{
info
(
focus
on
element
(
id
=
{
element
.
id
}
)
)
;
element
.
focus
(
)
;
}
else
{
focused
=
true
;
}
for
(
const
[
selector
value
]
of
Object
.
entries
(
obj
.
newValues
)
)
{
element
=
form
.
querySelector
(
selector
)
;
if
(
content
.
HTMLInputElement
.
isInstance
(
element
)
)
{
element
.
setUserInput
(
value
)
;
}
else
if
(
content
.
HTMLSelectElement
.
isInstance
(
element
)
&
&
Array
.
isArray
(
value
)
)
{
element
.
multiple
=
true
;
[
.
.
.
element
.
options
]
.
forEach
(
option
=
>
{
option
.
selected
=
value
.
includes
(
option
.
value
)
;
}
)
;
}
else
{
element
.
value
=
value
;
}
}
return
focused
;
}
)
;
if
(
alreadyFocused
)
{
FormAutofillParent
.
removeMessageObserver
(
fieldsIdentifiedObserver
)
;
fieldsIdentifiedPromiseResolver
(
)
;
}
await
fieldsIdentifiedPromise
;
if
(
submit
)
{
await
SpecialPowers
.
spawn
(
target
[
args
]
obj
=
>
{
let
form
;
if
(
obj
.
formSelector
)
{
form
=
content
.
document
.
querySelector
(
obj
.
formSelector
)
;
}
else
{
form
=
content
.
document
.
getElementById
(
obj
.
formId
?
?
"
form
"
)
;
}
info
(
submit
form
(
id
=
{
form
.
id
}
)
)
;
form
.
querySelector
(
"
input
[
type
=
submit
]
"
)
.
click
(
)
;
}
)
;
}
}
async
function
focusAndWaitForFieldsIdentified
(
browserOrContext
selector
)
{
info
(
"
expecting
the
target
input
being
focused
and
identified
"
)
;
let
fieldsIdentifiedPromiseResolver
;
let
fieldsIdentifiedObserver
=
{
fieldsIdentified
(
)
{
fieldsIdentifiedPromiseResolver
(
)
;
}
}
;
let
fieldsIdentifiedPromise
=
new
Promise
(
resolve
=
>
{
fieldsIdentifiedPromiseResolver
=
resolve
;
FormAutofillParent
.
addMessageObserver
(
fieldsIdentifiedObserver
)
;
}
)
;
const
{
previouslyFocused
previouslyIdentified
}
=
await
SpecialPowers
.
spawn
(
browserOrContext
[
selector
]
async
function
(
selector
)
{
const
{
FormLikeFactory
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
FormLikeFactory
.
sys
.
mjs
"
)
;
const
input
=
content
.
document
.
querySelector
(
selector
)
;
const
rootElement
=
FormLikeFactory
.
findRootForField
(
input
)
;
const
previouslyFocused
=
content
.
document
.
activeElement
=
=
input
;
const
previouslyIdentified
=
rootElement
.
hasAttribute
(
"
test
-
formautofill
-
identified
"
)
;
input
.
focus
(
)
;
return
{
previouslyFocused
previouslyIdentified
}
;
}
)
;
if
(
previouslyFocused
)
{
fieldsIdentifiedPromiseResolver
(
)
;
}
else
{
info
(
"
!
previouslyFocused
"
)
;
}
if
(
BrowsingContext
.
isInstance
(
browserOrContext
)
&
&
browserOrContext
.
parent
!
=
browserOrContext
)
{
await
SpecialPowers
.
spawn
(
browserOrContext
.
parent
[
browserOrContext
]
async
function
(
browsingContext
)
{
browsingContext
.
embedderElement
.
focus
(
)
;
}
)
;
}
if
(
previouslyIdentified
)
{
info
(
"
previouslyIdentified
"
)
;
FormAutofillParent
.
removeMessageObserver
(
fieldsIdentifiedObserver
)
;
return
;
}
await
fieldsIdentifiedPromise
;
info
(
"
FieldsIdentified
"
)
;
FormAutofillParent
.
removeMessageObserver
(
fieldsIdentifiedObserver
)
;
await
sleep
(
)
;
await
SpecialPowers
.
spawn
(
browserOrContext
[
]
async
function
(
)
{
const
{
FormLikeFactory
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
FormLikeFactory
.
sys
.
mjs
"
)
;
FormLikeFactory
.
findRootForField
(
content
.
document
.
activeElement
)
.
setAttribute
(
"
test
-
formautofill
-
identified
"
"
true
"
)
;
}
)
;
}
async
function
runAndWaitForAutocompletePopupOpen
(
browser
taskFunction
)
{
info
(
"
runAndWaitForAutocompletePopupOpen
"
)
;
let
popupShown
=
BrowserTestUtils
.
waitForPopupEvent
(
browser
.
autoCompletePopup
"
shown
"
)
;
await
taskFunction
(
)
;
await
popupShown
;
}
async
function
waitForPopupEnabled
(
browser
)
{
const
{
autoCompletePopup
:
{
richlistbox
:
itemsBox
}
}
=
browser
;
info
(
"
Wait
for
list
elements
to
become
enabled
"
)
;
await
BrowserTestUtils
.
waitForMutationCondition
(
itemsBox
{
subtree
:
true
attributes
:
true
attributeFilter
:
[
"
disabled
"
]
}
(
)
=
>
!
itemsBox
.
querySelectorAll
(
"
.
autocomplete
-
richlistitem
"
)
[
0
]
.
disabled
)
;
}
async
function
waitForAutoCompletePopupOpen
(
browser
taskFunction
)
{
const
popupShown
=
BrowserTestUtils
.
waitForPopupEvent
(
browser
.
autoCompletePopup
"
shown
"
)
;
if
(
taskFunction
)
{
await
taskFunction
(
)
;
}
return
popupShown
;
}
async
function
openPopupOn
(
browser
selector
)
{
const
popupOpenPromise
=
waitForAutoCompletePopupOpen
(
browser
)
;
await
SimpleTest
.
promiseFocus
(
browser
)
;
await
runAndWaitForAutocompletePopupOpen
(
browser
async
(
)
=
>
{
await
focusAndWaitForFieldsIdentified
(
browser
selector
)
;
if
(
!
selector
.
includes
(
"
cc
-
"
)
)
{
info
(
openPopupOn
:
before
VK_DOWN
on
{
selector
}
)
;
await
BrowserTestUtils
.
synthesizeKey
(
"
VK_DOWN
"
{
}
browser
)
;
}
}
)
;
await
popupOpenPromise
;
}
async
function
openPopupOnSubframe
(
browser
frameBrowsingContext
selector
)
{
const
popupOpenPromise
=
waitForAutoCompletePopupOpen
(
browser
)
;
await
SimpleTest
.
promiseFocus
(
browser
)
;
await
runAndWaitForAutocompletePopupOpen
(
browser
async
(
)
=
>
{
await
focusAndWaitForFieldsIdentified
(
frameBrowsingContext
selector
)
;
if
(
!
selector
.
includes
(
"
cc
-
"
)
)
{
info
(
openPopupOnSubframe
:
before
VK_DOWN
on
{
selector
}
)
;
await
BrowserTestUtils
.
synthesizeKey
(
"
VK_DOWN
"
{
}
frameBrowsingContext
)
;
}
}
)
;
await
popupOpenPromise
;
}
async
function
closePopup
(
browser
)
{
if
(
!
browser
.
autoCompletePopup
.
popupOpen
)
{
return
;
}
let
popupClosePromise
=
BrowserTestUtils
.
waitForPopupEvent
(
browser
.
autoCompletePopup
"
hidden
"
)
;
await
SpecialPowers
.
spawn
(
browser
[
]
async
function
(
)
{
content
.
document
.
activeElement
.
blur
(
)
;
}
)
;
await
popupClosePromise
;
}
async
function
closePopupForSubframe
(
browser
frameBrowsingContext
)
{
const
popupClosePromise
=
BrowserTestUtils
.
waitForPopupEvent
(
browser
.
autoCompletePopup
"
hidden
"
)
;
await
SpecialPowers
.
spawn
(
frameBrowsingContext
[
]
async
function
(
)
{
content
.
document
.
activeElement
.
blur
(
)
;
}
)
;
await
popupClosePromise
;
}
function
emulateMessageToBrowser
(
name
data
)
{
let
actor
=
gBrowser
.
selectedBrowser
.
browsingContext
.
currentWindowGlobal
.
getActor
(
"
FormAutofill
"
)
;
return
actor
.
receiveMessage
(
{
name
data
}
)
;
}
function
getRecords
(
data
)
{
info
(
expecting
record
retrievals
:
{
data
.
collectionName
}
)
;
return
emulateMessageToBrowser
(
"
FormAutofill
:
GetRecords
"
data
)
.
then
(
result
=
>
result
.
records
)
;
}
function
getAddresses
(
)
{
return
getRecords
(
{
collectionName
:
"
addresses
"
}
)
;
}
async
function
ensureNoAddressSaved
(
)
{
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
TIMEOUT_ENSURE_PROFILE_NOT_SAVED
)
)
;
const
addresses
=
await
getAddresses
(
)
;
is
(
addresses
.
length
0
"
No
address
was
saved
"
)
;
}
function
getCreditCards
(
)
{
return
getRecords
(
{
collectionName
:
"
creditCards
"
}
)
;
}
async
function
saveAddress
(
address
)
{
info
(
"
expecting
address
saved
"
)
;
let
observePromise
=
TestUtils
.
topicObserved
(
"
formautofill
-
storage
-
changed
"
)
;
await
emulateMessageToBrowser
(
"
FormAutofill
:
SaveAddress
"
{
address
}
)
;
await
observePromise
;
}
async
function
saveCreditCard
(
creditcard
)
{
info
(
"
expecting
credit
card
saved
"
)
;
let
creditcardClone
=
Object
.
assign
(
{
}
creditcard
)
;
let
observePromise
=
TestUtils
.
topicObserved
(
"
formautofill
-
storage
-
changed
"
)
;
await
emulateMessageToBrowser
(
"
FormAutofill
:
SaveCreditCard
"
{
creditcard
:
creditcardClone
}
)
;
await
observePromise
;
}
async
function
removeAddresses
(
guids
)
{
info
(
"
expecting
address
removed
"
)
;
let
observePromise
=
TestUtils
.
topicObserved
(
"
formautofill
-
storage
-
changed
"
)
;
await
emulateMessageToBrowser
(
"
FormAutofill
:
RemoveAddresses
"
{
guids
}
)
;
await
observePromise
;
}
async
function
removeCreditCards
(
guids
)
{
info
(
"
expecting
credit
card
removed
"
)
;
let
observePromise
=
TestUtils
.
topicObserved
(
"
formautofill
-
storage
-
changed
"
)
;
await
emulateMessageToBrowser
(
"
FormAutofill
:
RemoveCreditCards
"
{
guids
}
)
;
await
observePromise
;
}
function
getNotification
(
index
=
0
)
{
let
notifications
=
PopupNotifications
.
panel
.
childNodes
;
ok
(
!
!
notifications
.
length
"
at
least
one
notification
displayed
"
)
;
ok
(
true
notifications
.
length
+
"
notification
(
s
)
"
)
;
return
notifications
[
index
]
;
}
function
waitForPopupShown
(
)
{
return
BrowserTestUtils
.
waitForEvent
(
PopupNotifications
.
panel
"
popupshown
"
)
;
}
async
function
clickDoorhangerButton
(
buttonType
index
=
0
)
{
let
popuphidden
=
BrowserTestUtils
.
waitForEvent
(
PopupNotifications
.
panel
"
popuphidden
"
)
;
let
button
;
if
(
buttonType
=
=
MAIN_BUTTON
|
|
buttonType
=
=
SECONDARY_BUTTON
)
{
button
=
getNotification
(
)
[
buttonType
]
;
}
else
if
(
buttonType
=
=
MENU_BUTTON
)
{
info
(
"
expecting
notification
menu
button
present
"
)
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
getNotification
(
)
.
menubutton
)
;
await
sleep
(
2000
)
;
let
notification
=
getNotification
(
)
;
ok
(
notification
.
menubutton
"
notification
menupopup
displayed
"
)
;
let
dropdownPromise
=
BrowserTestUtils
.
waitForEvent
(
notification
.
menupopup
"
popupshown
"
)
;
notification
.
menubutton
.
click
(
)
;
info
(
"
expecting
notification
popup
show
up
"
)
;
await
dropdownPromise
;
button
=
notification
.
querySelectorAll
(
"
menuitem
"
)
[
index
]
;
}
button
.
click
(
)
;
info
(
"
expecting
notification
popup
hidden
"
)
;
await
popuphidden
;
}
async
function
clickAddressDoorhangerButton
(
buttonType
subType
)
{
const
notification
=
getNotification
(
)
;
let
button
;
if
(
buttonType
=
=
EDIT_ADDRESS_BUTTON
)
{
button
=
AddressSaveDoorhanger
.
editButton
(
notification
)
;
}
else
if
(
buttonType
=
=
ADDRESS_MENU_BUTTON
)
{
const
menu
=
AutofillDoorhanger
.
menuButton
(
notification
)
;
const
menupopup
=
AutofillDoorhanger
.
menuPopup
(
notification
)
;
const
promise
=
BrowserTestUtils
.
waitForEvent
(
menupopup
"
popupshown
"
)
;
menu
.
click
(
)
;
await
promise
;
if
(
subType
=
=
ADDRESS_MENU_PREFENCE
)
{
button
=
AutofillDoorhanger
.
preferenceButton
(
notification
)
;
}
else
if
(
subType
=
=
ADDRESS_MENU_LEARN_MORE
)
{
button
=
AutofillDoorhanger
.
learnMoreButton
(
notification
)
;
}
}
else
{
await
clickDoorhangerButton
(
buttonType
)
;
return
;
}
EventUtils
.
synthesizeMouseAtCenter
(
button
{
}
)
;
}
function
getDoorhangerCheckbox
(
)
{
return
getNotification
(
)
.
checkbox
;
}
function
getDoorhangerButton
(
button
)
{
return
getNotification
(
)
[
button
]
;
}
async
function
removeAllRecords
(
)
{
let
addresses
=
await
getAddresses
(
)
;
if
(
addresses
.
length
)
{
await
removeAddresses
(
addresses
.
map
(
address
=
>
address
.
guid
)
)
;
}
let
creditCards
=
await
getCreditCards
(
)
;
if
(
creditCards
.
length
)
{
await
removeCreditCards
(
creditCards
.
map
(
cc
=
>
cc
.
guid
)
)
;
}
}
async
function
waitForFocusAndFormReady
(
win
)
{
return
Promise
.
all
(
[
new
Promise
(
resolve
=
>
waitForFocus
(
resolve
win
)
)
BrowserTestUtils
.
waitForEvent
(
win
"
FormReadyForTests
"
)
]
)
;
}
async
function
expectWarningText
(
browser
expectedText
)
{
const
{
autoCompletePopup
:
{
richlistbox
:
itemsBox
}
}
=
browser
;
let
warningBox
=
itemsBox
.
querySelector
(
"
.
ac
-
status
"
)
;
ok
(
warningBox
.
parentNode
.
disabled
"
Got
warning
box
and
is
disabled
"
)
;
await
BrowserTestUtils
.
waitForMutationCondition
(
warningBox
{
childList
:
true
characterData
:
true
}
(
)
=
>
warningBox
.
textContent
=
=
expectedText
)
;
ok
(
true
Got
expected
warning
text
:
{
expectedText
}
)
;
}
async
function
testDialog
(
url
testFn
arg
=
undefined
)
{
if
(
url
=
=
EDIT_CREDIT_CARD_DIALOG_URL
&
&
arg
&
&
arg
.
record
&
&
arg
.
record
[
"
cc
-
number
-
encrypted
"
]
)
{
arg
.
record
=
Object
.
assign
(
{
}
arg
.
record
{
"
cc
-
number
"
:
await
OSKeyStore
.
decrypt
(
arg
.
record
[
"
cc
-
number
-
encrypted
"
]
)
}
)
;
}
const
win
=
window
.
openDialog
(
url
null
"
width
=
600
height
=
600
"
{
.
.
.
arg
l10nStrings
:
ManageAddresses
.
getAddressL10nStrings
(
)
}
)
;
await
waitForFocusAndFormReady
(
win
)
;
const
unloadPromise
=
BrowserTestUtils
.
waitForEvent
(
win
"
unload
"
)
;
await
testFn
(
win
)
;
return
unloadPromise
;
}
async
function
setStorage
(
.
.
.
items
)
{
for
(
let
item
of
items
)
{
if
(
item
[
"
cc
-
number
"
]
)
{
await
saveCreditCard
(
item
)
;
}
else
{
await
saveAddress
(
item
)
;
}
}
}
function
verifySectionAutofillResult
(
section
result
expectedSection
)
{
const
fieldDetails
=
section
.
fieldDetails
;
const
expectedFieldDetails
=
expectedSection
.
fields
;
fieldDetails
.
forEach
(
(
field
fieldIndex
)
=
>
{
const
expected
=
expectedFieldDetails
[
fieldIndex
]
;
Assert
.
equal
(
result
[
field
.
elementId
]
.
value
expected
.
autofill
?
?
"
"
Autofilled
value
for
element
(
identifier
:
{
field
.
identifier
}
field
name
:
{
field
.
fieldName
}
)
should
be
equal
)
;
}
)
;
}
function
verifySectionFieldDetails
(
sections
expectedSectionsInfo
)
{
sections
.
forEach
(
(
section
index
)
=
>
{
const
expectedSection
=
expectedSectionsInfo
[
index
]
;
const
fieldDetails
=
section
.
fieldDetails
;
const
expectedFieldDetails
=
expectedSection
.
fields
;
info
(
section
[
{
index
}
]
{
expectedSection
.
description
?
?
"
"
}
:
)
;
info
(
FieldName
Prediction
Results
:
{
fieldDetails
.
map
(
i
=
>
i
.
fieldName
)
}
)
;
info
(
FieldName
Expected
Results
:
{
expectedFieldDetails
.
map
(
detail
=
>
detail
.
fieldName
)
}
)
;
Assert
.
equal
(
fieldDetails
.
length
expectedFieldDetails
.
length
Expected
field
count
.
)
;
fieldDetails
.
forEach
(
(
fieldDetail
fieldIndex
)
=
>
{
const
expectedFieldDetail
=
expectedFieldDetails
[
fieldIndex
]
;
const
expected
=
{
.
.
.
{
reason
:
"
autocomplete
"
section
:
"
"
contactType
:
"
"
addressType
:
"
"
part
:
undefined
}
.
.
.
expectedSection
.
default
.
.
.
expectedFieldDetail
}
;
const
keys
=
[
"
reason
"
"
section
"
"
contactType
"
"
addressType
"
"
fieldName
"
"
part
"
]
;
for
(
const
key
of
keys
)
{
const
expectedValue
=
expected
[
key
]
;
const
actualValue
=
fieldDetail
[
key
]
;
Assert
.
equal
(
actualValue
expectedValue
[
{
fieldDetail
.
fieldName
}
]
:
{
key
}
should
be
equal
expect
{
expectedValue
}
got
{
actualValue
}
)
;
}
}
)
;
Assert
.
equal
(
section
.
isValidSection
(
)
!
expectedSection
.
invalid
Should
be
an
{
expectedSection
.
invalid
?
"
invalid
"
:
"
valid
"
}
section
)
;
}
)
;
}
async
function
clearGleanTelemetry
(
onlyInParent
=
false
)
{
if
(
!
onlyInParent
)
{
await
Services
.
fog
.
testFlushAllChildren
(
)
;
}
Services
.
fog
.
testResetFOG
(
)
;
}
async
function
add_heuristic_tests
(
patterns
fixturePathPrefix
=
"
"
options
=
{
testAutofill
:
false
}
)
{
async
function
runTest
(
testPattern
)
{
const
TEST_URL
=
testPattern
.
fixtureData
?
data
:
text
/
html
{
testPattern
.
fixtureData
}
:
{
BASE_URL
}
.
.
/
{
fixturePathPrefix
}
{
testPattern
.
fixturePath
}
;
if
(
testPattern
.
fixtureData
)
{
info
(
Starting
test
with
fixture
data
)
;
}
else
{
info
(
Starting
test
fixture
:
{
testPattern
.
fixturePath
?
?
"
"
}
)
;
}
if
(
testPattern
.
description
)
{
info
(
Test
"
{
testPattern
.
description
}
"
)
;
}
if
(
testPattern
.
prefs
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
testPattern
.
prefs
}
)
;
}
await
BrowserTestUtils
.
withNewTab
(
TEST_URL
async
browser
=
>
{
await
SpecialPowers
.
spawn
(
browser
[
]
async
function
(
)
{
const
elements
=
Array
.
from
(
content
.
document
.
querySelectorAll
(
"
input
select
"
)
)
;
elements
.
forEach
(
element
=
>
element
.
focus
(
)
)
;
}
)
;
const
actor
=
browser
.
browsingContext
.
currentWindowGlobal
.
getActor
(
"
FormAutofill
"
)
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
{
return
actor
.
getSections
(
)
.
length
=
=
testPattern
.
expectedResult
.
length
;
}
"
Expected
section
count
.
"
)
;
const
sections
=
actor
.
getSections
(
)
;
verifySectionFieldDetails
(
sections
testPattern
.
expectedResult
)
;
if
(
options
.
testAutofill
)
{
for
(
let
index
=
0
;
index
<
sections
.
length
;
index
+
+
)
{
const
section
=
sections
[
index
]
;
if
(
!
section
.
isValidSection
(
)
)
{
continue
;
}
const
elementId
=
section
.
fieldDetails
[
0
]
.
elementId
;
const
result
=
await
actor
.
autofillFields
(
elementId
testPattern
.
profile
)
;
verifySectionAutofillResult
(
section
result
testPattern
.
expectedResult
[
index
]
)
;
}
}
}
)
;
if
(
testPattern
.
prefs
)
{
await
SpecialPowers
.
popPrefEnv
(
)
;
}
}
patterns
.
forEach
(
testPattern
=
>
{
add_task
(
(
)
=
>
runTest
(
testPattern
)
)
;
}
)
;
}
async
function
add_autofill_heuristic_tests
(
patterns
fixturePathPrefix
=
"
"
)
{
add_heuristic_tests
(
patterns
fixturePathPrefix
{
testAutofill
:
true
}
)
;
}
function
fillEditDoorhanger
(
record
)
{
const
notification
=
getNotification
(
)
;
for
(
const
[
key
value
]
of
Object
.
entries
(
record
)
)
{
const
id
=
AddressEditDoorhanger
.
getInputId
(
key
)
;
const
element
=
notification
.
querySelector
(
#
{
id
}
)
;
element
.
value
=
value
;
}
}
function
normalizeAddressFields
(
record
)
{
let
normalized
=
{
.
.
.
record
}
;
if
(
normalized
.
name
!
=
undefined
)
{
let
nameParts
=
FormAutofillNameUtils
.
splitName
(
normalized
.
name
)
;
normalized
[
"
given
-
name
"
]
=
nameParts
.
given
;
normalized
[
"
additional
-
name
"
]
=
nameParts
.
middle
;
normalized
[
"
family
-
name
"
]
=
nameParts
.
family
;
delete
normalized
.
name
;
}
return
normalized
;
}
async
function
verifyConfirmationHint
(
browser
forceClose
anchorID
=
"
identity
-
icon
-
box
"
)
{
let
hintElem
=
browser
.
ownerGlobal
.
ConfirmationHint
.
_panel
;
await
BrowserTestUtils
.
waitForPopupEvent
(
hintElem
"
shown
"
)
;
try
{
Assert
.
equal
(
hintElem
.
state
"
open
"
"
hint
popup
is
open
"
)
;
Assert
.
ok
(
BrowserTestUtils
.
isVisible
(
hintElem
.
anchorNode
)
"
hint
anchorNode
is
visible
"
)
;
Assert
.
equal
(
hintElem
.
anchorNode
.
id
anchorID
"
Hint
should
be
anchored
on
the
expected
notification
icon
"
)
;
info
(
"
verifyConfirmationHint
hint
is
shown
and
has
its
anchorNode
"
)
;
if
(
forceClose
)
{
await
closePopup
(
hintElem
)
;
}
else
{
info
(
"
verifyConfirmationHint
assertion
ok
wait
for
poopuphidden
"
)
;
await
BrowserTestUtils
.
waitForPopupEvent
(
hintElem
"
hidden
"
)
;
info
(
"
verifyConfirmationHint
hintElem
popup
is
hidden
"
)
;
}
}
catch
(
ex
)
{
Assert
.
ok
(
false
"
Confirmation
hint
not
shown
:
"
+
ex
.
message
)
;
}
finally
{
info
(
"
verifyConfirmationHint
promise
finalized
"
)
;
}
}
async
function
showAddressDoorhanger
(
browser
values
=
null
)
{
const
defaultValues
=
{
"
#
given
-
name
"
:
"
John
"
"
#
family
-
name
"
:
"
Doe
"
"
#
organization
"
:
"
Mozilla
"
"
#
street
-
address
"
:
"
123
Sesame
Street
"
}
;
const
onPopupShown
=
waitForPopupShown
(
)
;
const
promise
=
BrowserTestUtils
.
browserLoaded
(
browser
)
;
await
focusUpdateSubmitForm
(
browser
{
focusSelector
:
"
#
given
-
name
"
newValues
:
values
?
?
defaultValues
}
)
;
await
promise
;
await
onPopupShown
;
}
add_setup
(
function
(
)
{
OSKeyStoreTestUtils
.
setup
(
)
;
}
)
;
registerCleanupFunction
(
async
(
)
=
>
{
await
removeAllRecords
(
)
;
await
OSKeyStoreTestUtils
.
cleanup
(
)
;
}
)
;
