"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
FormAutofillHandler
"
]
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
formautofill
/
FormAutofillUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
FormAutofillHeuristics
"
"
resource
:
/
/
formautofill
/
FormAutofillHeuristics
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
FormLikeFactory
"
"
resource
:
/
/
gre
/
modules
/
FormLikeFactory
.
jsm
"
)
;
this
.
log
=
null
;
FormAutofillUtils
.
defineLazyLogGetter
(
this
this
.
EXPORTED_SYMBOLS
[
0
]
)
;
const
{
FIELD_STATES
}
=
FormAutofillUtils
;
class
FormAutofillSection
{
constructor
(
fieldDetails
winUtils
)
{
this
.
address
=
{
fieldDetails
:
[
]
filledRecordGUID
:
null
}
;
this
.
creditCard
=
{
fieldDetails
:
[
]
filledRecordGUID
:
null
}
;
this
.
_FIELD_STATE_ENUM
=
{
[
FIELD_STATES
.
NORMAL
]
:
null
[
FIELD_STATES
.
AUTO_FILLED
]
:
"
-
moz
-
autofill
"
[
FIELD_STATES
.
PREVIEW
]
:
"
-
moz
-
autofill
-
preview
"
}
;
this
.
winUtils
=
winUtils
;
this
.
address
.
fieldDetails
=
fieldDetails
.
filter
(
detail
=
>
FormAutofillUtils
.
isAddressField
(
detail
.
fieldName
)
)
;
if
(
this
.
address
.
fieldDetails
.
length
<
FormAutofillUtils
.
AUTOFILL_FIELDS_THRESHOLD
)
{
log
.
debug
(
"
Ignoring
address
related
fields
since
the
section
has
only
"
this
.
address
.
fieldDetails
.
length
"
field
(
s
)
"
)
;
this
.
address
.
fieldDetails
=
[
]
;
}
this
.
creditCard
.
fieldDetails
=
fieldDetails
.
filter
(
detail
=
>
FormAutofillUtils
.
isCreditCardField
(
detail
.
fieldName
)
)
;
if
(
!
this
.
_isValidCreditCardForm
(
this
.
creditCard
.
fieldDetails
)
)
{
log
.
debug
(
"
Invalid
credit
card
section
.
"
)
;
this
.
creditCard
.
fieldDetails
=
[
]
;
}
this
.
_cacheValue
=
{
allFieldNames
:
null
oneLineStreetAddress
:
null
matchingSelectOption
:
null
}
;
this
.
_validDetails
=
Array
.
of
(
.
.
.
(
this
.
address
.
fieldDetails
)
.
.
.
(
this
.
creditCard
.
fieldDetails
)
)
;
log
.
debug
(
this
.
_validDetails
.
length
"
valid
fields
in
the
section
is
collected
.
"
)
;
}
get
validDetails
(
)
{
return
this
.
_validDetails
;
}
getFieldDetailByElement
(
element
)
{
return
this
.
_validDetails
.
find
(
detail
=
>
detail
.
elementWeakRef
.
get
(
)
=
=
element
)
;
}
_isValidCreditCardForm
(
fieldDetails
)
{
let
ccNumberReason
=
"
"
;
let
hasCCNumber
=
false
;
let
hasExpiryDate
=
false
;
for
(
let
detail
of
fieldDetails
)
{
switch
(
detail
.
fieldName
)
{
case
"
cc
-
number
"
:
hasCCNumber
=
true
;
ccNumberReason
=
detail
.
_reason
;
break
;
case
"
cc
-
exp
"
:
case
"
cc
-
exp
-
month
"
:
case
"
cc
-
exp
-
year
"
:
hasExpiryDate
=
true
;
break
;
}
}
return
hasCCNumber
&
&
(
ccNumberReason
=
=
"
autocomplete
"
|
|
hasExpiryDate
)
;
}
get
allFieldNames
(
)
{
if
(
!
this
.
_cacheValue
.
allFieldNames
)
{
this
.
_cacheValue
.
allFieldNames
=
this
.
_validDetails
.
map
(
record
=
>
record
.
fieldName
)
;
}
return
this
.
_cacheValue
.
allFieldNames
;
}
getFieldDetailByName
(
fieldName
)
{
return
this
.
_validDetails
.
find
(
detail
=
>
detail
.
fieldName
=
=
fieldName
)
;
}
_getTargetSet
(
element
)
{
let
fieldDetail
=
this
.
getFieldDetailByElement
(
element
)
;
if
(
!
fieldDetail
)
{
return
null
;
}
if
(
FormAutofillUtils
.
isAddressField
(
fieldDetail
.
fieldName
)
)
{
return
this
.
address
;
}
if
(
FormAutofillUtils
.
isCreditCardField
(
fieldDetail
.
fieldName
)
)
{
return
this
.
creditCard
;
}
return
null
;
}
getFieldDetailsByElement
(
element
)
{
let
targetSet
=
this
.
_getTargetSet
(
element
)
;
return
targetSet
?
targetSet
.
fieldDetails
:
[
]
;
}
getFilledRecordGUID
(
element
)
{
let
targetSet
=
this
.
_getTargetSet
(
element
)
;
return
targetSet
?
targetSet
.
filledRecordGUID
:
null
;
}
_getOneLineStreetAddress
(
address
)
{
if
(
!
this
.
_cacheValue
.
oneLineStreetAddress
)
{
this
.
_cacheValue
.
oneLineStreetAddress
=
{
}
;
}
if
(
!
this
.
_cacheValue
.
oneLineStreetAddress
[
address
]
)
{
this
.
_cacheValue
.
oneLineStreetAddress
[
address
]
=
FormAutofillUtils
.
toOneLineAddress
(
address
)
;
}
return
this
.
_cacheValue
.
oneLineStreetAddress
[
address
]
;
}
_addressTransformer
(
profile
)
{
if
(
profile
[
"
street
-
address
"
]
)
{
profile
[
"
-
moz
-
street
-
address
-
one
-
line
"
]
=
this
.
_getOneLineStreetAddress
(
profile
[
"
street
-
address
"
]
)
;
let
streetAddressDetail
=
this
.
getFieldDetailByName
(
"
street
-
address
"
)
;
if
(
streetAddressDetail
&
&
(
streetAddressDetail
.
elementWeakRef
.
get
(
)
instanceof
Ci
.
nsIDOMHTMLInputElement
)
)
{
profile
[
"
street
-
address
"
]
=
profile
[
"
-
moz
-
street
-
address
-
one
-
line
"
]
;
}
let
waitForConcat
=
[
]
;
for
(
let
f
of
[
"
address
-
line3
"
"
address
-
line2
"
"
address
-
line1
"
]
)
{
waitForConcat
.
unshift
(
profile
[
f
]
)
;
if
(
this
.
getFieldDetailByName
(
f
)
)
{
if
(
waitForConcat
.
length
>
1
)
{
profile
[
f
]
=
FormAutofillUtils
.
toOneLineAddress
(
waitForConcat
)
;
}
waitForConcat
=
[
]
;
}
}
}
}
_telTransformer
(
profile
)
{
if
(
!
profile
.
tel
|
|
!
profile
[
"
tel
-
national
"
]
)
{
return
;
}
let
detail
=
this
.
getFieldDetailByName
(
"
tel
"
)
;
if
(
!
detail
)
{
return
;
}
let
element
=
detail
.
elementWeakRef
.
get
(
)
;
let
_pattern
;
let
testPattern
=
str
=
>
{
if
(
!
_pattern
)
{
_pattern
=
new
RegExp
(
"
^
(
?
:
"
+
element
.
pattern
+
"
)
"
"
u
"
)
;
}
return
_pattern
.
test
(
str
)
;
}
;
if
(
element
.
pattern
)
{
if
(
testPattern
(
profile
.
tel
)
)
{
return
;
}
}
else
if
(
element
.
maxLength
)
{
if
(
detail
.
_reason
=
=
"
autocomplete
"
&
&
profile
.
tel
.
length
<
=
element
.
maxLength
)
{
return
;
}
}
if
(
detail
.
_reason
!
=
"
autocomplete
"
)
{
profile
.
tel
=
profile
[
"
tel
-
national
"
]
;
}
else
if
(
element
.
pattern
)
{
if
(
testPattern
(
profile
[
"
tel
-
national
"
]
)
)
{
profile
.
tel
=
profile
[
"
tel
-
national
"
]
;
}
}
else
if
(
element
.
maxLength
)
{
if
(
profile
[
"
tel
-
national
"
]
.
length
<
=
element
.
maxLength
)
{
profile
.
tel
=
profile
[
"
tel
-
national
"
]
;
}
}
}
_matchSelectOptions
(
profile
)
{
if
(
!
this
.
_cacheValue
.
matchingSelectOption
)
{
this
.
_cacheValue
.
matchingSelectOption
=
new
WeakMap
(
)
;
}
for
(
let
fieldName
in
profile
)
{
let
fieldDetail
=
this
.
getFieldDetailByName
(
fieldName
)
;
if
(
!
fieldDetail
)
{
continue
;
}
let
element
=
fieldDetail
.
elementWeakRef
.
get
(
)
;
if
(
ChromeUtils
.
getClassName
(
element
)
!
=
=
"
HTMLSelectElement
"
)
{
continue
;
}
let
cache
=
this
.
_cacheValue
.
matchingSelectOption
.
get
(
element
)
|
|
{
}
;
let
value
=
profile
[
fieldName
]
;
if
(
cache
[
value
]
&
&
cache
[
value
]
.
get
(
)
)
{
continue
;
}
let
option
=
FormAutofillUtils
.
findSelectOption
(
element
profile
fieldName
)
;
if
(
option
)
{
cache
[
value
]
=
Cu
.
getWeakReference
(
option
)
;
this
.
_cacheValue
.
matchingSelectOption
.
set
(
element
cache
)
;
}
else
{
if
(
cache
[
value
]
)
{
delete
cache
[
value
]
;
this
.
_cacheValue
.
matchingSelectOption
.
set
(
element
cache
)
;
}
delete
profile
[
fieldName
]
;
}
}
}
_creditCardExpDateTransformer
(
profile
)
{
if
(
!
profile
[
"
cc
-
exp
"
]
)
{
return
;
}
let
detail
=
this
.
getFieldDetailByName
(
"
cc
-
exp
"
)
;
if
(
!
detail
)
{
return
;
}
let
element
=
detail
.
elementWeakRef
.
get
(
)
;
if
(
element
.
tagName
!
=
"
INPUT
"
|
|
!
element
.
placeholder
)
{
return
;
}
let
result
ccExpMonth
=
profile
[
"
cc
-
exp
-
month
"
]
ccExpYear
=
profile
[
"
cc
-
exp
-
year
"
]
placeholder
=
element
.
placeholder
;
result
=
/
(
?
:
[
^
m
]
|
\
b
)
(
m
{
1
2
}
)
\
s
*
(
[
-
/
\
\
]
*
)
\
s
*
(
y
{
2
4
}
)
(
?
!
y
)
/
i
.
exec
(
placeholder
)
;
if
(
result
)
{
profile
[
"
cc
-
exp
"
]
=
String
(
ccExpMonth
)
.
padStart
(
result
[
1
]
.
length
"
0
"
)
+
result
[
2
]
+
String
(
ccExpYear
)
.
substr
(
-
1
*
result
[
3
]
.
length
)
;
return
;
}
result
=
/
(
?
:
[
^
y
]
|
\
b
)
(
y
{
2
4
}
)
\
s
*
(
[
-
/
\
\
]
*
)
\
s
*
(
m
{
1
2
}
)
(
?
!
m
)
/
i
.
exec
(
placeholder
)
;
if
(
result
)
{
profile
[
"
cc
-
exp
"
]
=
String
(
ccExpYear
)
.
substr
(
-
1
*
result
[
1
]
.
length
)
+
result
[
2
]
+
String
(
ccExpMonth
)
.
padStart
(
result
[
3
]
.
length
"
0
"
)
;
}
}
getAdaptedProfiles
(
originalProfiles
)
{
for
(
let
profile
of
originalProfiles
)
{
this
.
_addressTransformer
(
profile
)
;
this
.
_telTransformer
(
profile
)
;
this
.
_matchSelectOptions
(
profile
)
;
this
.
_creditCardExpDateTransformer
(
profile
)
;
}
return
originalProfiles
;
}
async
autofillFields
(
profile
focusedInput
)
{
let
focusedDetail
=
this
.
getFieldDetailByElement
(
focusedInput
)
;
if
(
!
focusedDetail
)
{
throw
new
Error
(
"
No
fieldDetail
for
the
focused
input
.
"
)
;
}
let
targetSet
=
this
.
_getTargetSet
(
focusedInput
)
;
if
(
FormAutofillUtils
.
isCreditCardField
(
focusedDetail
.
fieldName
)
)
{
if
(
profile
[
"
cc
-
number
-
encrypted
"
]
)
{
let
decrypted
=
await
this
.
_decrypt
(
profile
[
"
cc
-
number
-
encrypted
"
]
true
)
;
if
(
!
decrypted
)
{
return
;
}
profile
[
"
cc
-
number
"
]
=
decrypted
;
}
}
log
.
debug
(
"
profile
in
autofillFields
:
"
profile
)
;
targetSet
.
filledRecordGUID
=
profile
.
guid
;
for
(
let
fieldDetail
of
targetSet
.
fieldDetails
)
{
let
element
=
fieldDetail
.
elementWeakRef
.
get
(
)
;
if
(
!
element
)
{
continue
;
}
element
.
previewValue
=
"
"
;
let
value
=
profile
[
fieldDetail
.
fieldName
]
;
if
(
element
instanceof
Ci
.
nsIDOMHTMLInputElement
&
&
value
)
{
if
(
element
=
=
focusedInput
|
|
(
element
!
=
focusedInput
&
&
!
element
.
value
)
)
{
element
.
setUserInput
(
value
)
;
this
.
changeFieldState
(
fieldDetail
FIELD_STATES
.
AUTO_FILLED
)
;
continue
;
}
}
if
(
ChromeUtils
.
getClassName
(
element
)
=
=
=
"
HTMLSelectElement
"
)
{
let
cache
=
this
.
_cacheValue
.
matchingSelectOption
.
get
(
element
)
|
|
{
}
;
let
option
=
cache
[
value
]
&
&
cache
[
value
]
.
get
(
)
;
if
(
!
option
)
{
continue
;
}
if
(
!
option
.
selected
)
{
option
.
selected
=
true
;
element
.
dispatchEvent
(
new
element
.
ownerGlobal
.
UIEvent
(
"
input
"
{
bubbles
:
true
}
)
)
;
element
.
dispatchEvent
(
new
element
.
ownerGlobal
.
Event
(
"
change
"
{
bubbles
:
true
}
)
)
;
}
this
.
changeFieldState
(
fieldDetail
FIELD_STATES
.
AUTO_FILLED
)
;
}
}
}
previewFormFields
(
profile
focusedInput
)
{
log
.
debug
(
"
preview
profile
:
"
profile
)
;
if
(
profile
[
"
cc
-
number
-
decrypted
"
]
)
{
profile
[
"
cc
-
number
"
]
=
profile
[
"
cc
-
number
-
decrypted
"
]
;
}
let
fieldDetails
=
this
.
getFieldDetailsByElement
(
focusedInput
)
;
for
(
let
fieldDetail
of
fieldDetails
)
{
let
element
=
fieldDetail
.
elementWeakRef
.
get
(
)
;
let
value
=
profile
[
fieldDetail
.
fieldName
]
|
|
"
"
;
if
(
!
element
)
{
continue
;
}
if
(
ChromeUtils
.
getClassName
(
element
)
=
=
=
"
HTMLSelectElement
"
)
{
if
(
value
)
{
let
cache
=
this
.
_cacheValue
.
matchingSelectOption
.
get
(
element
)
|
|
{
}
;
let
option
=
cache
[
value
]
&
&
cache
[
value
]
.
get
(
)
;
if
(
option
)
{
value
=
option
.
text
|
|
"
"
;
}
else
{
value
=
"
"
;
}
}
}
else
if
(
element
.
value
)
{
continue
;
}
element
.
previewValue
=
value
;
this
.
changeFieldState
(
fieldDetail
value
?
FIELD_STATES
.
PREVIEW
:
FIELD_STATES
.
NORMAL
)
;
}
}
clearPreviewedFormFields
(
focusedInput
)
{
log
.
debug
(
"
clear
previewed
fields
in
:
"
this
.
form
)
;
let
fieldDetails
=
this
.
getFieldDetailsByElement
(
focusedInput
)
;
for
(
let
fieldDetail
of
fieldDetails
)
{
let
element
=
fieldDetail
.
elementWeakRef
.
get
(
)
;
if
(
!
element
)
{
log
.
warn
(
fieldDetail
.
fieldName
"
is
unreachable
"
)
;
continue
;
}
element
.
previewValue
=
"
"
;
if
(
fieldDetail
.
state
=
=
FIELD_STATES
.
AUTO_FILLED
)
{
continue
;
}
this
.
changeFieldState
(
fieldDetail
FIELD_STATES
.
NORMAL
)
;
}
}
clearPopulatedForm
(
focusedInput
)
{
let
fieldDetails
=
this
.
getFieldDetailsByElement
(
focusedInput
)
;
for
(
let
fieldDetail
of
fieldDetails
)
{
let
element
=
fieldDetail
.
elementWeakRef
.
get
(
)
;
if
(
!
element
)
{
log
.
warn
(
fieldDetail
.
fieldName
"
is
unreachable
"
)
;
continue
;
}
if
(
fieldDetail
.
state
=
=
FIELD_STATES
.
AUTO_FILLED
&
&
element
instanceof
Ci
.
nsIDOMHTMLInputElement
)
{
element
.
setUserInput
(
"
"
)
;
}
this
.
changeFieldState
(
fieldDetail
FIELD_STATES
.
NORMAL
)
;
}
}
changeFieldState
(
fieldDetail
nextState
)
{
let
element
=
fieldDetail
.
elementWeakRef
.
get
(
)
;
if
(
!
element
)
{
log
.
warn
(
fieldDetail
.
fieldName
"
is
unreachable
while
changing
state
"
)
;
return
;
}
if
(
!
(
nextState
in
this
.
_FIELD_STATE_ENUM
)
)
{
log
.
warn
(
fieldDetail
.
fieldName
"
is
trying
to
change
to
an
invalid
state
"
)
;
return
;
}
for
(
let
[
state
mmStateValue
]
of
Object
.
entries
(
this
.
_FIELD_STATE_ENUM
)
)
{
if
(
!
mmStateValue
)
{
continue
;
}
if
(
state
=
=
nextState
)
{
this
.
winUtils
.
addManuallyManagedState
(
element
mmStateValue
)
;
}
else
{
this
.
winUtils
.
removeManuallyManagedState
(
element
mmStateValue
)
;
}
}
fieldDetail
.
state
=
nextState
;
}
clearFieldState
(
focusedInput
)
{
let
fieldDetail
=
this
.
getFieldDetailByElement
(
focusedInput
)
;
this
.
changeFieldState
(
fieldDetail
FIELD_STATES
.
NORMAL
)
;
let
targetSet
=
this
.
_getTargetSet
(
focusedInput
)
;
if
(
!
targetSet
.
fieldDetails
.
some
(
detail
=
>
detail
.
state
=
=
FIELD_STATES
.
AUTO_FILLED
)
)
{
targetSet
.
filledRecordGUID
=
null
;
}
}
resetFieldStates
(
)
{
for
(
let
fieldDetail
of
this
.
_validDetails
)
{
this
.
changeFieldState
(
fieldDetail
FIELD_STATES
.
NORMAL
)
;
}
this
.
address
.
filledRecordGUID
=
null
;
this
.
creditCard
.
filledRecordGUID
=
null
;
}
isFilled
(
)
{
return
!
!
(
this
.
address
.
filledRecordGUID
|
|
this
.
creditCard
.
filledRecordGUID
)
;
}
_isAddressRecordCreatable
(
record
)
{
let
hasName
=
0
;
let
length
=
0
;
for
(
let
key
of
Object
.
keys
(
record
)
)
{
if
(
!
record
[
key
]
)
{
continue
;
}
if
(
FormAutofillUtils
.
getCategoryFromFieldName
(
key
)
=
=
"
name
"
)
{
hasName
=
1
;
continue
;
}
length
+
+
;
}
return
(
length
+
hasName
)
>
=
FormAutofillUtils
.
AUTOFILL_FIELDS_THRESHOLD
;
}
_isCreditCardRecordCreatable
(
record
)
{
return
record
[
"
cc
-
number
"
]
&
&
FormAutofillUtils
.
isCCNumber
(
record
[
"
cc
-
number
"
]
)
;
}
createRecords
(
)
{
let
data
=
{
}
;
let
target
=
[
]
;
if
(
FormAutofillUtils
.
isAutofillAddressesEnabled
)
{
target
.
push
(
"
address
"
)
;
}
if
(
FormAutofillUtils
.
isAutofillCreditCardsEnabled
)
{
target
.
push
(
"
creditCard
"
)
;
}
target
.
forEach
(
type
=
>
{
let
details
=
this
[
type
]
.
fieldDetails
;
if
(
!
details
|
|
details
.
length
=
=
0
)
{
return
;
}
data
[
type
]
=
{
guid
:
this
[
type
]
.
filledRecordGUID
record
:
{
}
untouchedFields
:
[
]
}
;
details
.
forEach
(
detail
=
>
{
let
element
=
detail
.
elementWeakRef
.
get
(
)
;
let
value
=
element
&
&
element
.
value
.
trim
(
)
;
if
(
type
=
=
"
address
"
&
&
detail
.
fieldName
=
=
"
address
-
level1
"
&
&
ChromeUtils
.
getClassName
(
element
)
=
=
=
"
HTMLSelectElement
"
)
{
if
(
!
value
|
|
element
.
selectedOptions
.
length
!
=
1
)
{
data
[
type
]
.
record
[
detail
.
fieldName
]
=
"
"
;
return
;
}
let
text
=
element
.
selectedOptions
[
0
]
.
text
.
trim
(
)
;
value
=
FormAutofillUtils
.
getAbbreviatedStateName
(
[
value
text
]
)
|
|
text
;
}
if
(
!
value
|
|
value
.
length
>
FormAutofillUtils
.
MAX_FIELD_VALUE_LENGTH
)
{
data
[
type
]
.
record
[
detail
.
fieldName
]
=
"
"
;
return
;
}
data
[
type
]
.
record
[
detail
.
fieldName
]
=
value
;
if
(
detail
.
state
=
=
FIELD_STATES
.
AUTO_FILLED
)
{
data
[
type
]
.
untouchedFields
.
push
(
detail
.
fieldName
)
;
}
}
)
;
}
)
;
this
.
_normalizeAddress
(
data
.
address
)
;
if
(
data
.
address
&
&
!
this
.
_isAddressRecordCreatable
(
data
.
address
.
record
)
)
{
log
.
debug
(
"
No
address
record
saving
since
there
are
only
"
Object
.
keys
(
data
.
address
.
record
)
.
length
"
usable
fields
"
)
;
delete
data
.
address
;
}
if
(
data
.
creditCard
&
&
!
this
.
_isCreditCardRecordCreatable
(
data
.
creditCard
.
record
)
)
{
log
.
debug
(
"
No
credit
card
record
saving
since
card
number
is
invalid
"
)
;
delete
data
.
creditCard
;
}
if
(
data
.
address
&
&
data
.
creditCard
)
{
this
.
timeStartedFillingMS
=
null
;
}
return
data
;
}
_normalizeAddress
(
address
)
{
if
(
!
address
)
{
return
;
}
if
(
address
.
record
.
country
)
{
let
detail
=
this
.
getFieldDetailByName
(
"
country
"
)
;
if
(
detail
.
_reason
!
=
"
autocomplete
"
)
{
let
countryCode
=
FormAutofillUtils
.
identifyCountryCode
(
address
.
record
.
country
)
;
if
(
countryCode
)
{
address
.
record
.
country
=
countryCode
;
}
}
}
FormAutofillUtils
.
compressTel
(
address
.
record
)
;
if
(
address
.
record
.
tel
)
{
let
allTelComponentsAreUntouched
=
Object
.
keys
(
address
.
record
)
.
filter
(
field
=
>
FormAutofillUtils
.
getCategoryFromFieldName
(
field
)
=
=
"
tel
"
)
.
every
(
field
=
>
address
.
untouchedFields
.
includes
(
field
)
)
;
if
(
allTelComponentsAreUntouched
)
{
if
(
!
address
.
untouchedFields
.
includes
(
"
tel
"
)
)
{
address
.
untouchedFields
.
push
(
"
tel
"
)
;
}
}
else
{
let
strippedNumber
=
address
.
record
.
tel
.
replace
(
/
[
\
s
\
(
\
)
-
]
/
g
"
"
)
;
if
(
!
/
^
(
\
+
?
)
[
\
da
-
zA
-
Z
]
{
5
15
}
/
.
test
(
strippedNumber
)
)
{
address
.
record
.
tel
=
"
"
;
}
}
}
}
async
_decrypt
(
cipherText
reauth
)
{
return
new
Promise
(
(
resolve
)
=
>
{
Services
.
cpmm
.
addMessageListener
(
"
FormAutofill
:
DecryptedString
"
function
getResult
(
result
)
{
Services
.
cpmm
.
removeMessageListener
(
"
FormAutofill
:
DecryptedString
"
getResult
)
;
resolve
(
result
.
data
)
;
}
)
;
Services
.
cpmm
.
sendAsyncMessage
(
"
FormAutofill
:
GetDecryptedString
"
{
cipherText
reauth
}
)
;
}
)
;
}
}
class
FormAutofillHandler
{
constructor
(
form
)
{
this
.
_updateForm
(
form
)
;
this
.
winUtils
=
this
.
form
.
rootElement
.
ownerGlobal
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
this
.
timeStartedFillingMS
=
null
;
}
updateFormIfNeeded
(
element
)
{
let
_formLike
;
let
getFormLike
=
(
)
=
>
{
if
(
!
_formLike
)
{
_formLike
=
FormLikeFactory
.
createFromField
(
element
)
;
}
return
_formLike
;
}
;
let
currentForm
=
element
.
form
;
if
(
!
currentForm
)
{
currentForm
=
getFormLike
(
)
;
}
if
(
currentForm
.
elements
.
length
!
=
this
.
form
.
elements
.
length
)
{
log
.
debug
(
"
The
count
of
form
elements
is
changed
.
"
)
;
this
.
_updateForm
(
getFormLike
(
)
)
;
return
true
;
}
if
(
this
.
form
.
elements
.
indexOf
(
element
)
=
=
=
-
1
)
{
log
.
debug
(
"
The
element
can
not
be
found
in
the
current
form
.
"
)
;
this
.
_updateForm
(
getFormLike
(
)
)
;
return
true
;
}
return
false
;
}
_updateForm
(
form
)
{
this
.
form
=
form
;
this
.
fieldDetails
=
null
;
this
.
sections
=
[
]
;
this
.
_sectionCache
=
new
WeakMap
(
)
;
}
collectFormFields
(
allowDuplicates
=
false
)
{
let
sections
=
FormAutofillHeuristics
.
getFormInfo
(
this
.
form
allowDuplicates
)
;
let
allValidDetails
=
[
]
;
for
(
let
fieldDetails
of
sections
)
{
let
section
=
new
FormAutofillSection
(
fieldDetails
this
.
winUtils
)
;
this
.
sections
.
push
(
section
)
;
allValidDetails
.
push
(
.
.
.
section
.
validDetails
)
;
}
for
(
let
detail
of
allValidDetails
)
{
let
input
=
detail
.
elementWeakRef
.
get
(
)
;
if
(
!
input
)
{
continue
;
}
input
.
addEventListener
(
"
input
"
this
)
;
}
this
.
fieldDetails
=
allValidDetails
;
return
allValidDetails
;
}
getSectionByElement
(
element
)
{
let
section
=
this
.
_sectionCache
.
get
(
element
)
;
if
(
!
section
)
{
section
=
this
.
sections
.
find
(
s
=
>
s
.
getFieldDetailByElement
(
element
)
)
;
this
.
_sectionCache
.
set
(
element
section
)
;
}
return
section
;
}
getAllFieldNames
(
focusedInput
)
{
let
section
=
this
.
getSectionByElement
(
focusedInput
)
;
return
section
.
allFieldNames
;
}
previewFormFields
(
profile
focusedInput
)
{
let
section
=
this
.
getSectionByElement
(
focusedInput
)
;
section
.
previewFormFields
(
profile
focusedInput
)
;
}
clearPreviewedFormFields
(
focusedInput
)
{
let
section
=
this
.
getSectionByElement
(
focusedInput
)
;
section
.
clearPreviewedFormFields
(
focusedInput
)
;
}
clearPopulatedForm
(
focusedInput
)
{
let
section
=
this
.
getSectionByElement
(
focusedInput
)
;
section
.
clearPopulatedForm
(
focusedInput
)
;
}
getFilledRecordGUID
(
focusedInput
)
{
let
section
=
this
.
getSectionByElement
(
focusedInput
)
;
return
section
.
getFilledRecordGUID
(
focusedInput
)
;
}
getAdaptedProfiles
(
originalProfiles
focusedInput
)
{
let
section
=
this
.
getSectionByElement
(
focusedInput
)
;
section
.
getAdaptedProfiles
(
originalProfiles
)
;
return
originalProfiles
;
}
hasFilledSection
(
)
{
return
this
.
sections
.
some
(
section
=
>
section
.
isFilled
(
)
)
;
}
async
autofillFormFields
(
profile
focusedInput
)
{
let
noFilledSections
=
!
this
.
hasFilledSection
(
)
;
await
this
.
getSectionByElement
(
focusedInput
)
.
autofillFields
(
profile
focusedInput
)
;
log
.
debug
(
"
register
change
handler
for
filled
form
:
"
this
.
form
)
;
const
onChangeHandler
=
e
=
>
{
if
(
!
e
.
isTrusted
)
{
return
;
}
if
(
e
.
type
=
=
"
input
"
)
{
let
section
=
this
.
getSectionByElement
(
e
.
target
)
;
section
.
clearFieldState
(
e
.
target
)
;
}
else
if
(
e
.
type
=
=
"
reset
"
)
{
for
(
let
section
of
this
.
sections
)
{
section
.
resetFieldStates
(
)
;
}
}
if
(
!
this
.
hasFilledSection
(
)
)
{
this
.
form
.
rootElement
.
removeEventListener
(
"
input
"
onChangeHandler
)
;
this
.
form
.
rootElement
.
removeEventListener
(
"
reset
"
onChangeHandler
)
;
}
}
;
if
(
noFilledSections
)
{
this
.
form
.
rootElement
.
addEventListener
(
"
input
"
onChangeHandler
)
;
this
.
form
.
rootElement
.
addEventListener
(
"
reset
"
onChangeHandler
)
;
}
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
input
"
:
if
(
!
event
.
isTrusted
)
{
return
;
}
for
(
let
detail
of
this
.
fieldDetails
)
{
let
input
=
detail
.
elementWeakRef
.
get
(
)
;
if
(
!
input
)
{
continue
;
}
input
.
removeEventListener
(
"
input
"
this
)
;
}
this
.
timeStartedFillingMS
=
Date
.
now
(
)
;
break
;
}
}
createRecords
(
)
{
if
(
this
.
sections
.
length
>
0
)
{
return
this
.
sections
[
0
]
.
createRecords
(
)
;
}
return
null
;
}
}
