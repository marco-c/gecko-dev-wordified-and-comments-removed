"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
FormAutofillHandler
"
]
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
formautofill
/
FormAutofillUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
FormAutofillHeuristics
"
"
resource
:
/
/
formautofill
/
FormAutofillHeuristics
.
jsm
"
)
;
this
.
log
=
null
;
FormAutofillUtils
.
defineLazyLogGetter
(
this
this
.
EXPORTED_SYMBOLS
[
0
]
)
;
function
FormAutofillHandler
(
form
)
{
this
.
form
=
form
;
this
.
fieldDetails
=
[
]
;
this
.
winUtils
=
this
.
form
.
rootElement
.
ownerGlobal
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
}
FormAutofillHandler
.
prototype
=
{
form
:
null
_formFieldCount
:
0
fieldDetails
:
null
filledProfileGUID
:
null
winUtils
:
null
fieldStateEnum
:
{
NORMAL
:
null
AUTO_FILLED
:
"
-
moz
-
autofill
"
PREVIEW
:
"
-
moz
-
autofill
-
preview
"
}
get
isFormChangedSinceLastCollection
(
)
{
return
this
.
_formFieldCount
!
=
this
.
form
.
elements
.
length
;
}
collectFormFields
(
)
{
this
.
_formFieldCount
=
this
.
form
.
elements
.
length
;
let
fieldDetails
=
FormAutofillHeuristics
.
getFormInfo
(
this
.
form
)
;
this
.
fieldDetails
=
fieldDetails
?
fieldDetails
:
[
]
;
log
.
debug
(
"
Collected
details
on
"
this
.
fieldDetails
.
length
"
fields
"
)
;
}
autofillFormFields
(
profile
focusedInput
)
{
log
.
debug
(
"
profile
in
autofillFormFields
:
"
profile
)
;
this
.
filledProfileGUID
=
profile
.
guid
;
for
(
let
fieldDetail
of
this
.
fieldDetails
)
{
let
element
=
fieldDetail
.
elementWeakRef
.
get
(
)
;
if
(
!
element
)
{
continue
;
}
let
value
=
profile
[
fieldDetail
.
fieldName
]
;
if
(
element
instanceof
Ci
.
nsIDOMHTMLInputElement
&
&
!
element
.
value
&
&
value
)
{
if
(
element
!
=
=
focusedInput
)
{
element
.
setUserInput
(
value
)
;
}
this
.
changeFieldState
(
fieldDetail
"
AUTO_FILLED
"
)
;
}
else
if
(
element
instanceof
Ci
.
nsIDOMHTMLSelectElement
)
{
let
option
=
FormAutofillUtils
.
findSelectOption
(
element
profile
fieldDetail
.
fieldName
)
;
if
(
!
option
)
{
continue
;
}
if
(
!
option
.
selected
)
{
option
.
selected
=
true
;
element
.
dispatchEvent
(
new
element
.
ownerGlobal
.
UIEvent
(
"
input
"
{
bubbles
:
true
}
)
)
;
element
.
dispatchEvent
(
new
element
.
ownerGlobal
.
Event
(
"
change
"
{
bubbles
:
true
}
)
)
;
}
this
.
changeFieldState
(
fieldDetail
"
AUTO_FILLED
"
)
;
}
if
(
element
=
=
=
focusedInput
)
{
const
suppressFirstInputHandler
=
e
=
>
{
if
(
e
.
isTrusted
)
{
e
.
stopPropagation
(
)
;
element
.
removeEventListener
(
"
input
"
suppressFirstInputHandler
)
;
}
}
;
element
.
addEventListener
(
"
input
"
suppressFirstInputHandler
)
;
}
element
.
previewValue
=
"
"
;
}
log
.
debug
(
"
register
change
handler
for
filled
form
:
"
this
.
form
)
;
const
onChangeHandler
=
e
=
>
{
let
hasFilledFields
;
if
(
!
e
.
isTrusted
)
{
return
;
}
for
(
let
fieldDetail
of
this
.
fieldDetails
)
{
let
element
=
fieldDetail
.
elementWeakRef
.
get
(
)
;
if
(
!
element
)
{
return
;
}
if
(
e
.
target
=
=
element
|
|
(
e
.
target
=
=
element
.
form
&
&
e
.
type
=
=
"
reset
"
)
)
{
this
.
changeFieldState
(
fieldDetail
"
NORMAL
"
)
;
}
hasFilledFields
|
=
(
fieldDetail
.
state
=
=
"
AUTO_FILLED
"
)
;
}
if
(
!
hasFilledFields
)
{
this
.
form
.
rootElement
.
removeEventListener
(
"
input
"
onChangeHandler
)
;
this
.
form
.
rootElement
.
removeEventListener
(
"
reset
"
onChangeHandler
)
;
this
.
filledProfileGUID
=
null
;
}
}
;
this
.
form
.
rootElement
.
addEventListener
(
"
input
"
onChangeHandler
)
;
this
.
form
.
rootElement
.
addEventListener
(
"
reset
"
onChangeHandler
)
;
}
previewFormFields
(
profile
)
{
log
.
debug
(
"
preview
profile
in
autofillFormFields
:
"
profile
)
;
for
(
let
fieldDetail
of
this
.
fieldDetails
)
{
let
element
=
fieldDetail
.
elementWeakRef
.
get
(
)
;
let
value
=
profile
[
fieldDetail
.
fieldName
]
|
|
"
"
;
if
(
!
element
)
{
continue
;
}
if
(
element
instanceof
Ci
.
nsIDOMHTMLSelectElement
)
{
let
option
=
FormAutofillUtils
.
findSelectOption
(
element
profile
fieldDetail
.
fieldName
)
;
element
.
previewValue
=
option
?
option
.
text
:
"
"
;
this
.
changeFieldState
(
fieldDetail
option
?
"
PREVIEW
"
:
"
NORMAL
"
)
;
}
else
{
if
(
element
.
value
)
{
continue
;
}
element
.
previewValue
=
value
;
this
.
changeFieldState
(
fieldDetail
value
?
"
PREVIEW
"
:
"
NORMAL
"
)
;
}
}
}
clearPreviewedFormFields
(
)
{
log
.
debug
(
"
clear
previewed
fields
in
:
"
this
.
form
)
;
for
(
let
fieldDetail
of
this
.
fieldDetails
)
{
let
element
=
fieldDetail
.
elementWeakRef
.
get
(
)
;
if
(
!
element
)
{
log
.
warn
(
fieldDetail
.
fieldName
"
is
unreachable
"
)
;
continue
;
}
element
.
previewValue
=
"
"
;
if
(
fieldDetail
.
state
=
=
=
"
AUTO_FILLED
"
)
{
continue
;
}
this
.
changeFieldState
(
fieldDetail
"
NORMAL
"
)
;
}
}
changeFieldState
(
fieldDetail
nextState
)
{
let
element
=
fieldDetail
.
elementWeakRef
.
get
(
)
;
if
(
!
element
)
{
log
.
warn
(
fieldDetail
.
fieldName
"
is
unreachable
while
changing
state
"
)
;
return
;
}
if
(
!
(
nextState
in
this
.
fieldStateEnum
)
)
{
log
.
warn
(
fieldDetail
.
fieldName
"
is
trying
to
change
to
an
invalid
state
"
)
;
return
;
}
for
(
let
[
state
mmStateValue
]
of
Object
.
entries
(
this
.
fieldStateEnum
)
)
{
if
(
!
mmStateValue
)
{
continue
;
}
if
(
state
=
=
nextState
)
{
this
.
winUtils
.
addManuallyManagedState
(
element
mmStateValue
)
;
}
else
{
this
.
winUtils
.
removeManuallyManagedState
(
element
mmStateValue
)
;
}
}
fieldDetail
.
state
=
nextState
;
}
createProfile
(
)
{
let
profile
=
{
}
;
this
.
fieldDetails
.
forEach
(
detail
=
>
{
let
element
=
detail
.
elementWeakRef
.
get
(
)
;
let
value
=
element
&
&
element
.
value
.
trim
(
)
;
if
(
!
value
)
{
return
;
}
profile
[
detail
.
fieldName
]
=
value
;
}
)
;
return
profile
;
}
}
;
