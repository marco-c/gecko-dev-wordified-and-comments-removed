"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
FormAutofillHandler
"
]
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
formautofill
/
FormAutofillUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
FormAutofillHeuristics
"
"
resource
:
/
/
formautofill
/
FormAutofillHeuristics
.
jsm
"
)
;
this
.
log
=
null
;
FormAutofillUtils
.
defineLazyLogGetter
(
this
this
.
EXPORTED_SYMBOLS
[
0
]
)
;
function
FormAutofillHandler
(
form
)
{
this
.
form
=
form
;
this
.
fieldDetails
=
[
]
;
this
.
winUtils
=
this
.
form
.
rootElement
.
ownerGlobal
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
this
.
address
=
{
fieldDetails
:
[
]
filledRecordGUID
:
null
}
;
this
.
creditCard
=
{
fieldDetails
:
[
]
filledRecordGUID
:
null
}
;
this
.
_cacheValue
=
{
allFieldNames
:
null
oneLineStreetAddress
:
null
matchingSelectOption
:
null
}
;
}
FormAutofillHandler
.
prototype
=
{
form
:
null
_formFieldCount
:
0
fieldDetails
:
null
address
:
null
creditCard
:
null
winUtils
:
null
fieldStateEnum
:
{
NORMAL
:
null
AUTO_FILLED
:
"
-
moz
-
autofill
"
PREVIEW
:
"
-
moz
-
autofill
-
preview
"
}
get
isFormChangedSinceLastCollection
(
)
{
return
this
.
_formFieldCount
!
=
this
.
form
.
elements
.
length
;
}
timeStartedFillingMS
:
null
collectFormFields
(
allowDuplicates
=
false
)
{
this
.
_cacheValue
.
allFieldNames
=
null
;
this
.
_formFieldCount
=
this
.
form
.
elements
.
length
;
let
fieldDetails
=
FormAutofillHeuristics
.
getFormInfo
(
this
.
form
allowDuplicates
)
;
this
.
fieldDetails
=
fieldDetails
?
fieldDetails
:
[
]
;
log
.
debug
(
"
Collected
details
on
"
this
.
fieldDetails
.
length
"
fields
"
)
;
this
.
address
.
fieldDetails
=
this
.
fieldDetails
.
filter
(
detail
=
>
FormAutofillUtils
.
isAddressField
(
detail
.
fieldName
)
)
;
this
.
creditCard
.
fieldDetails
=
this
.
fieldDetails
.
filter
(
detail
=
>
FormAutofillUtils
.
isCreditCardField
(
detail
.
fieldName
)
)
;
if
(
this
.
address
.
fieldDetails
.
length
<
FormAutofillUtils
.
AUTOFILL_FIELDS_THRESHOLD
)
{
log
.
debug
(
"
Ignoring
address
related
fields
since
it
has
only
"
this
.
address
.
fieldDetails
.
length
"
field
(
s
)
"
)
;
this
.
address
.
fieldDetails
=
[
]
;
}
if
(
!
this
.
creditCard
.
fieldDetails
.
some
(
i
=
>
i
.
fieldName
=
=
"
cc
-
number
"
)
)
{
log
.
debug
(
"
Ignoring
credit
card
related
fields
since
it
'
s
without
credit
card
number
field
"
)
;
this
.
creditCard
.
fieldDetails
=
[
]
;
}
let
validDetails
=
Array
.
of
(
.
.
.
(
this
.
address
.
fieldDetails
)
.
.
.
(
this
.
creditCard
.
fieldDetails
)
)
;
for
(
let
detail
of
validDetails
)
{
let
input
=
detail
.
elementWeakRef
.
get
(
)
;
if
(
!
input
)
{
continue
;
}
input
.
addEventListener
(
"
input
"
this
)
;
}
return
validDetails
;
}
getFieldDetailByName
(
fieldName
)
{
return
this
.
fieldDetails
.
find
(
detail
=
>
detail
.
fieldName
=
=
fieldName
)
;
}
getFieldDetailByElement
(
element
)
{
return
this
.
fieldDetails
.
find
(
detail
=
>
detail
.
elementWeakRef
.
get
(
)
=
=
element
)
;
}
getFieldDetailsByElement
(
element
)
{
let
fieldDetail
=
this
.
getFieldDetailByElement
(
element
)
;
if
(
!
fieldDetail
)
{
return
[
]
;
}
if
(
FormAutofillUtils
.
isAddressField
(
fieldDetail
.
fieldName
)
)
{
return
this
.
address
.
fieldDetails
;
}
if
(
FormAutofillUtils
.
isCreditCardField
(
fieldDetail
.
fieldName
)
)
{
return
this
.
creditCard
.
fieldDetails
;
}
return
[
]
;
}
get
allFieldNames
(
)
{
if
(
!
this
.
_cacheValue
.
allFieldNames
)
{
this
.
_cacheValue
.
allFieldNames
=
this
.
fieldDetails
.
map
(
record
=
>
record
.
fieldName
)
;
}
return
this
.
_cacheValue
.
allFieldNames
;
}
_getOneLineStreetAddress
(
address
)
{
if
(
!
this
.
_cacheValue
.
oneLineStreetAddress
)
{
this
.
_cacheValue
.
oneLineStreetAddress
=
{
}
;
}
if
(
!
this
.
_cacheValue
.
oneLineStreetAddress
[
address
]
)
{
this
.
_cacheValue
.
oneLineStreetAddress
[
address
]
=
FormAutofillUtils
.
toOneLineAddress
(
address
)
;
}
return
this
.
_cacheValue
.
oneLineStreetAddress
[
address
]
;
}
_addressTransformer
(
profile
)
{
if
(
profile
[
"
street
-
address
"
]
)
{
profile
[
"
-
moz
-
street
-
address
-
one
-
line
"
]
=
this
.
_getOneLineStreetAddress
(
profile
[
"
street
-
address
"
]
)
;
let
streetAddressDetail
=
this
.
getFieldDetailByName
(
"
street
-
address
"
)
;
if
(
streetAddressDetail
&
&
(
streetAddressDetail
.
elementWeakRef
.
get
(
)
instanceof
Ci
.
nsIDOMHTMLInputElement
)
)
{
profile
[
"
street
-
address
"
]
=
profile
[
"
-
moz
-
street
-
address
-
one
-
line
"
]
;
}
let
waitForConcat
=
[
]
;
for
(
let
f
of
[
"
address
-
line3
"
"
address
-
line2
"
"
address
-
line1
"
]
)
{
waitForConcat
.
unshift
(
profile
[
f
]
)
;
if
(
this
.
getFieldDetailByName
(
f
)
)
{
if
(
waitForConcat
.
length
>
1
)
{
profile
[
f
]
=
FormAutofillUtils
.
toOneLineAddress
(
waitForConcat
)
;
}
waitForConcat
=
[
]
;
}
}
}
}
_matchSelectOptions
(
profile
)
{
if
(
!
this
.
_cacheValue
.
matchingSelectOption
)
{
this
.
_cacheValue
.
matchingSelectOption
=
new
WeakMap
(
)
;
}
for
(
let
fieldName
in
profile
)
{
let
fieldDetail
=
this
.
getFieldDetailByName
(
fieldName
)
;
if
(
!
fieldDetail
)
{
continue
;
}
let
element
=
fieldDetail
.
elementWeakRef
.
get
(
)
;
if
(
!
(
element
instanceof
Ci
.
nsIDOMHTMLSelectElement
)
)
{
continue
;
}
let
cache
=
this
.
_cacheValue
.
matchingSelectOption
.
get
(
element
)
|
|
{
}
;
let
value
=
profile
[
fieldName
]
;
if
(
cache
[
value
]
&
&
cache
[
value
]
.
get
(
)
)
{
continue
;
}
let
option
=
FormAutofillUtils
.
findSelectOption
(
element
profile
fieldName
)
;
if
(
option
)
{
cache
[
value
]
=
Cu
.
getWeakReference
(
option
)
;
this
.
_cacheValue
.
matchingSelectOption
.
set
(
element
cache
)
;
}
else
{
if
(
cache
[
value
]
)
{
delete
cache
[
value
]
;
this
.
_cacheValue
.
matchingSelectOption
.
set
(
element
cache
)
;
}
delete
profile
[
fieldName
]
;
}
}
}
getAdaptedProfiles
(
originalProfiles
)
{
for
(
let
profile
of
originalProfiles
)
{
this
.
_addressTransformer
(
profile
)
;
this
.
_matchSelectOptions
(
profile
)
;
}
return
originalProfiles
;
}
async
autofillFormFields
(
profile
focusedInput
)
{
let
focusedDetail
=
this
.
fieldDetails
.
find
(
detail
=
>
detail
.
elementWeakRef
.
get
(
)
=
=
focusedInput
)
;
let
targetSet
;
if
(
FormAutofillUtils
.
isCreditCardField
(
focusedDetail
.
fieldName
)
)
{
if
(
profile
[
"
cc
-
number
-
encrypted
"
]
)
{
let
decrypted
=
await
this
.
_decrypt
(
profile
[
"
cc
-
number
-
encrypted
"
]
true
)
;
if
(
!
decrypted
)
{
return
;
}
profile
[
"
cc
-
number
"
]
=
decrypted
;
}
targetSet
=
this
.
creditCard
;
}
else
if
(
FormAutofillUtils
.
isAddressField
(
focusedDetail
.
fieldName
)
)
{
targetSet
=
this
.
address
;
}
else
{
throw
new
Error
(
"
Unknown
form
fields
"
)
;
}
log
.
debug
(
"
profile
in
autofillFormFields
:
"
profile
)
;
targetSet
.
filledRecordGUID
=
profile
.
guid
;
for
(
let
fieldDetail
of
targetSet
.
fieldDetails
)
{
let
element
=
fieldDetail
.
elementWeakRef
.
get
(
)
;
if
(
!
element
)
{
continue
;
}
element
.
previewValue
=
"
"
;
let
value
=
profile
[
fieldDetail
.
fieldName
]
;
if
(
element
instanceof
Ci
.
nsIDOMHTMLInputElement
&
&
value
)
{
if
(
element
=
=
focusedInput
|
|
(
element
!
=
focusedInput
&
&
!
element
.
value
)
)
{
element
.
setUserInput
(
value
)
;
this
.
changeFieldState
(
fieldDetail
"
AUTO_FILLED
"
)
;
continue
;
}
}
if
(
element
instanceof
Ci
.
nsIDOMHTMLSelectElement
)
{
let
cache
=
this
.
_cacheValue
.
matchingSelectOption
.
get
(
element
)
|
|
{
}
;
let
option
=
cache
[
value
]
&
&
cache
[
value
]
.
get
(
)
;
if
(
!
option
)
{
continue
;
}
if
(
!
option
.
selected
)
{
option
.
selected
=
true
;
element
.
dispatchEvent
(
new
element
.
ownerGlobal
.
UIEvent
(
"
input
"
{
bubbles
:
true
}
)
)
;
element
.
dispatchEvent
(
new
element
.
ownerGlobal
.
Event
(
"
change
"
{
bubbles
:
true
}
)
)
;
}
this
.
changeFieldState
(
fieldDetail
"
AUTO_FILLED
"
)
;
}
}
log
.
debug
(
"
register
change
handler
for
filled
form
:
"
this
.
form
)
;
const
onChangeHandler
=
e
=
>
{
let
hasFilledFields
;
if
(
!
e
.
isTrusted
)
{
return
;
}
for
(
let
fieldDetail
of
targetSet
.
fieldDetails
)
{
let
element
=
fieldDetail
.
elementWeakRef
.
get
(
)
;
if
(
!
element
)
{
return
;
}
if
(
e
.
target
=
=
element
|
|
(
e
.
target
=
=
element
.
form
&
&
e
.
type
=
=
"
reset
"
)
)
{
this
.
changeFieldState
(
fieldDetail
"
NORMAL
"
)
;
}
hasFilledFields
|
=
(
fieldDetail
.
state
=
=
"
AUTO_FILLED
"
)
;
}
if
(
!
hasFilledFields
)
{
this
.
form
.
rootElement
.
removeEventListener
(
"
input
"
onChangeHandler
)
;
this
.
form
.
rootElement
.
removeEventListener
(
"
reset
"
onChangeHandler
)
;
targetSet
.
filledRecordGUID
=
null
;
}
}
;
this
.
form
.
rootElement
.
addEventListener
(
"
input
"
onChangeHandler
)
;
this
.
form
.
rootElement
.
addEventListener
(
"
reset
"
onChangeHandler
)
;
}
previewFormFields
(
profile
focusedInput
)
{
log
.
debug
(
"
preview
profile
in
autofillFormFields
:
"
profile
)
;
if
(
profile
[
"
cc
-
number
-
decrypted
"
]
)
{
profile
[
"
cc
-
number
"
]
=
profile
[
"
cc
-
number
-
decrypted
"
]
;
}
let
fieldDetails
=
this
.
getFieldDetailsByElement
(
focusedInput
)
;
for
(
let
fieldDetail
of
fieldDetails
)
{
let
element
=
fieldDetail
.
elementWeakRef
.
get
(
)
;
let
value
=
profile
[
fieldDetail
.
fieldName
]
|
|
"
"
;
if
(
!
element
)
{
continue
;
}
if
(
element
instanceof
Ci
.
nsIDOMHTMLSelectElement
)
{
if
(
value
)
{
let
cache
=
this
.
_cacheValue
.
matchingSelectOption
.
get
(
element
)
|
|
{
}
;
let
option
=
cache
[
value
]
&
&
cache
[
value
]
.
get
(
)
;
if
(
option
)
{
value
=
option
.
text
|
|
"
"
;
}
else
{
value
=
"
"
;
}
}
}
else
if
(
element
.
value
)
{
continue
;
}
element
.
previewValue
=
value
;
this
.
changeFieldState
(
fieldDetail
value
?
"
PREVIEW
"
:
"
NORMAL
"
)
;
}
}
clearPreviewedFormFields
(
focusedInput
)
{
log
.
debug
(
"
clear
previewed
fields
in
:
"
this
.
form
)
;
let
fieldDetails
=
this
.
getFieldDetailsByElement
(
focusedInput
)
;
for
(
let
fieldDetail
of
fieldDetails
)
{
let
element
=
fieldDetail
.
elementWeakRef
.
get
(
)
;
if
(
!
element
)
{
log
.
warn
(
fieldDetail
.
fieldName
"
is
unreachable
"
)
;
continue
;
}
element
.
previewValue
=
"
"
;
if
(
fieldDetail
.
state
=
=
=
"
AUTO_FILLED
"
)
{
continue
;
}
this
.
changeFieldState
(
fieldDetail
"
NORMAL
"
)
;
}
}
changeFieldState
(
fieldDetail
nextState
)
{
let
element
=
fieldDetail
.
elementWeakRef
.
get
(
)
;
if
(
!
element
)
{
log
.
warn
(
fieldDetail
.
fieldName
"
is
unreachable
while
changing
state
"
)
;
return
;
}
if
(
!
(
nextState
in
this
.
fieldStateEnum
)
)
{
log
.
warn
(
fieldDetail
.
fieldName
"
is
trying
to
change
to
an
invalid
state
"
)
;
return
;
}
for
(
let
[
state
mmStateValue
]
of
Object
.
entries
(
this
.
fieldStateEnum
)
)
{
if
(
!
mmStateValue
)
{
continue
;
}
if
(
state
=
=
nextState
)
{
this
.
winUtils
.
addManuallyManagedState
(
element
mmStateValue
)
;
}
else
{
this
.
winUtils
.
removeManuallyManagedState
(
element
mmStateValue
)
;
}
}
fieldDetail
.
state
=
nextState
;
}
_isAddressRecordCreatable
(
record
)
{
let
hasName
=
0
;
let
length
=
0
;
for
(
let
key
of
Object
.
keys
(
record
)
)
{
if
(
!
record
[
key
]
)
{
continue
;
}
if
(
FormAutofillUtils
.
getCategoryFromFieldName
(
key
)
=
=
"
name
"
)
{
hasName
=
1
;
continue
;
}
length
+
+
;
}
return
(
length
+
hasName
)
>
=
FormAutofillUtils
.
AUTOFILL_FIELDS_THRESHOLD
;
}
_isCreditCardRecordCreatable
(
record
)
{
return
record
[
"
cc
-
number
"
]
&
&
FormAutofillUtils
.
isCCNumber
(
record
[
"
cc
-
number
"
]
)
;
}
createRecords
(
)
{
let
data
=
{
}
;
[
"
address
"
"
creditCard
"
]
.
forEach
(
type
=
>
{
let
details
=
this
[
type
]
.
fieldDetails
;
if
(
!
details
|
|
details
.
length
=
=
0
)
{
return
;
}
data
[
type
]
=
{
guid
:
this
[
type
]
.
filledRecordGUID
record
:
{
}
untouchedFields
:
[
]
}
;
details
.
forEach
(
detail
=
>
{
let
element
=
detail
.
elementWeakRef
.
get
(
)
;
let
value
=
element
&
&
element
.
value
.
trim
(
)
;
if
(
type
=
=
"
address
"
&
&
detail
.
fieldName
=
=
"
address
-
level1
"
&
&
element
instanceof
Ci
.
nsIDOMHTMLSelectElement
)
{
if
(
!
value
|
|
element
.
selectedOptions
.
length
!
=
1
)
{
data
[
type
]
.
record
[
detail
.
fieldName
]
=
"
"
;
return
;
}
let
text
=
element
.
selectedOptions
[
0
]
.
text
.
trim
(
)
;
value
=
FormAutofillUtils
.
getAbbreviatedStateName
(
[
value
text
]
)
|
|
text
;
}
if
(
!
value
)
{
data
[
type
]
.
record
[
detail
.
fieldName
]
=
"
"
;
return
;
}
data
[
type
]
.
record
[
detail
.
fieldName
]
=
value
;
if
(
detail
.
state
=
=
"
AUTO_FILLED
"
)
{
data
[
type
]
.
untouchedFields
.
push
(
detail
.
fieldName
)
;
}
}
)
;
}
)
;
this
.
_normalizeAddress
(
data
.
address
)
;
if
(
data
.
address
&
&
!
this
.
_isAddressRecordCreatable
(
data
.
address
.
record
)
)
{
log
.
debug
(
"
No
address
record
saving
since
there
are
only
"
Object
.
keys
(
data
.
address
.
record
)
.
length
"
usable
fields
"
)
;
delete
data
.
address
;
}
if
(
data
.
creditCard
&
&
!
this
.
_isCreditCardRecordCreatable
(
data
.
creditCard
.
record
)
)
{
log
.
debug
(
"
No
credit
card
record
saving
since
card
number
is
invalid
"
)
;
delete
data
.
creditCard
;
}
if
(
data
.
address
&
&
data
.
creditCard
)
{
this
.
timeStartedFillingMS
=
null
;
}
return
data
;
}
_normalizeAddress
(
address
)
{
if
(
!
address
)
{
return
;
}
if
(
address
.
record
.
country
)
{
let
detail
=
this
.
getFieldDetailByName
(
"
country
"
)
;
if
(
detail
.
_reason
!
=
"
autocomplete
"
)
{
let
countryCode
=
FormAutofillUtils
.
identifyCountryCode
(
address
.
record
.
country
)
;
if
(
countryCode
)
{
address
.
record
.
country
=
countryCode
;
}
}
}
FormAutofillUtils
.
compressTel
(
address
.
record
)
;
if
(
address
.
record
.
tel
)
{
let
allTelComponentsAreUntouched
=
Object
.
keys
(
address
.
record
)
.
filter
(
field
=
>
FormAutofillUtils
.
getCategoryFromFieldName
(
field
)
=
=
"
tel
"
)
.
every
(
field
=
>
address
.
untouchedFields
.
includes
(
field
)
)
;
if
(
allTelComponentsAreUntouched
)
{
if
(
!
address
.
untouchedFields
.
includes
(
"
tel
"
)
)
{
address
.
untouchedFields
.
push
(
"
tel
"
)
;
}
}
else
{
let
strippedNumber
=
address
.
record
.
tel
.
replace
(
/
[
\
s
\
(
\
)
-
]
/
g
"
"
)
;
if
(
!
/
^
(
\
+
?
)
[
\
da
-
zA
-
Z
]
{
5
15
}
/
.
test
(
strippedNumber
)
)
{
address
.
record
.
tel
=
"
"
;
}
}
}
}
async
_decrypt
(
cipherText
reauth
)
{
return
new
Promise
(
(
resolve
)
=
>
{
Services
.
cpmm
.
addMessageListener
(
"
FormAutofill
:
DecryptedString
"
function
getResult
(
result
)
{
Services
.
cpmm
.
removeMessageListener
(
"
FormAutofill
:
DecryptedString
"
getResult
)
;
resolve
(
result
.
data
)
;
}
)
;
Services
.
cpmm
.
sendAsyncMessage
(
"
FormAutofill
:
GetDecryptedString
"
{
cipherText
reauth
}
)
;
}
)
;
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
input
"
:
if
(
!
event
.
isTrusted
)
{
return
;
}
for
(
let
detail
of
this
.
fieldDetails
)
{
let
input
=
detail
.
elementWeakRef
.
get
(
)
;
if
(
!
input
)
{
continue
;
}
input
.
removeEventListener
(
"
input
"
this
)
;
}
this
.
timeStartedFillingMS
=
Date
.
now
(
)
;
break
;
}
}
}
;
