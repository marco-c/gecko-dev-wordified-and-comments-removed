var
loop
=
loop
|
|
{
}
;
loop
.
StandaloneMozLoop
=
(
function
(
mozL10n
)
{
"
use
strict
"
;
var
ROOM_MAX_CLIENTS
=
2
;
var
PUSH_SUBSCRIPTION
=
"
pushSubscription
"
;
var
BATCH_MESSAGE
=
"
Batch
"
;
var
MAX_LOOP_COUNT
=
10
;
function
cloneableError
(
err
)
{
if
(
typeof
err
=
=
"
string
"
)
{
err
=
new
Error
(
err
)
;
}
err
.
isError
=
true
;
return
err
;
}
function
validate
(
data
schema
)
{
if
(
!
schema
)
{
return
{
}
;
}
return
new
loop
.
validate
.
Validator
(
schema
)
.
validate
(
data
)
;
}
function
failureHandler
(
callback
xhrReq
)
{
var
jsonErr
=
JSON
.
parse
(
xhrReq
.
responseText
&
&
xhrReq
.
responseText
|
|
"
{
}
"
)
;
var
message
=
"
HTTP
"
+
xhrReq
.
status
+
"
"
+
xhrReq
.
statusText
;
var
err
=
new
Error
(
message
)
;
err
.
errno
=
jsonErr
.
errno
;
callback
(
err
)
;
}
var
StandaloneLoopRooms
=
{
baseServerUrl
:
"
"
get
:
function
(
roomToken
callback
)
{
var
url
=
this
.
baseServerUrl
+
"
/
rooms
/
"
+
roomToken
;
this
.
_xhrReq
=
new
XMLHttpRequest
(
)
;
this
.
_xhrReq
.
open
(
"
GET
"
url
true
)
;
this
.
_xhrReq
.
setRequestHeader
(
"
Content
-
type
"
"
application
/
json
"
)
;
if
(
this
.
sessionToken
)
{
this
.
_xhrReq
.
setRequestHeader
(
"
Authorization
"
"
Basic
"
+
btoa
(
this
.
sessionToken
)
)
;
}
this
.
_xhrReq
.
onload
=
function
(
)
{
var
request
=
this
.
_xhrReq
;
var
responseJSON
=
JSON
.
parse
(
request
.
responseText
|
|
"
{
}
"
)
;
if
(
request
.
readyState
=
=
=
4
&
&
request
.
status
>
=
200
&
&
request
.
status
<
300
)
{
try
{
callback
(
null
validate
(
responseJSON
{
roomUrl
:
String
}
)
)
;
}
catch
(
err
)
{
console
.
error
(
"
Error
requesting
call
info
"
err
.
message
)
;
callback
(
err
)
;
}
}
else
{
failureHandler
(
callback
request
)
;
}
}
.
bind
(
this
)
;
this
.
_xhrReq
.
onerror
=
function
(
)
{
var
request
=
this
.
_xhrReq
;
failureHandler
(
callback
request
)
;
}
.
bind
(
this
)
;
this
.
_xhrReq
.
send
(
)
;
}
_postToRoom
:
function
(
roomToken
sessionToken
roomData
expectedProps
async
callback
)
{
var
url
=
this
.
baseServerUrl
+
"
/
rooms
/
"
+
roomToken
;
var
xhrReq
=
new
XMLHttpRequest
(
)
;
xhrReq
.
open
(
"
POST
"
url
async
)
;
xhrReq
.
setRequestHeader
(
"
Content
-
type
"
"
application
/
json
"
)
;
if
(
sessionToken
)
{
xhrReq
.
setRequestHeader
(
"
Authorization
"
"
Basic
"
+
btoa
(
sessionToken
)
)
;
}
xhrReq
.
onload
=
function
(
)
{
var
request
=
xhrReq
;
var
responseJSON
=
JSON
.
parse
(
request
.
responseText
|
|
null
)
;
if
(
request
.
readyState
=
=
=
4
&
&
request
.
status
>
=
200
&
&
request
.
status
<
300
)
{
try
{
callback
(
null
validate
(
responseJSON
expectedProps
)
)
;
}
catch
(
err
)
{
console
.
error
(
"
Error
requesting
call
info
"
err
.
message
)
;
callback
(
err
)
;
}
}
else
{
failureHandler
(
callback
request
)
;
}
}
.
bind
(
this
xhrReq
)
;
xhrReq
.
send
(
JSON
.
stringify
(
roomData
)
)
;
}
join
:
function
(
roomToken
callback
)
{
function
callbackWrapper
(
err
result
)
{
if
(
result
)
{
this
.
sessionToken
=
result
.
sessionToken
;
}
callback
(
err
result
)
;
}
this
.
_postToRoom
(
roomToken
null
{
action
:
"
join
"
displayName
:
mozL10n
.
get
(
"
rooms_display_name_guest
"
)
clientMaxSize
:
ROOM_MAX_CLIENTS
}
{
apiKey
:
String
sessionId
:
String
sessionToken
:
String
expires
:
Number
}
true
callbackWrapper
.
bind
(
this
)
)
;
}
refreshMembership
:
function
(
roomToken
sessionToken
callback
)
{
this
.
_postToRoom
(
roomToken
sessionToken
{
action
:
"
refresh
"
sessionToken
:
sessionToken
}
{
expires
:
Number
}
true
callback
)
;
}
leave
:
function
(
roomToken
sessionToken
callback
)
{
if
(
!
callback
)
{
callback
=
function
(
error
)
{
if
(
error
)
{
console
.
error
(
error
)
;
}
}
;
}
this
.
_postToRoom
(
roomToken
sessionToken
{
action
:
"
leave
"
sessionToken
:
sessionToken
}
null
false
callback
)
;
}
sendConnectionStatus
:
function
(
roomToken
sessionToken
status
)
{
this
.
_postToRoom
(
roomToken
sessionToken
{
action
:
"
status
"
event
:
status
.
event
state
:
status
.
state
connections
:
status
.
connections
sendStreams
:
status
.
sendStreams
recvStreams
:
status
.
recvStreams
}
null
true
function
(
error
)
{
if
(
error
)
{
console
.
error
(
error
)
;
}
}
)
;
}
}
;
var
kMessageHandlers
=
{
AddConversationContext
:
function
(
)
{
}
HangupNow
:
function
(
data
reply
)
{
var
roomToken
=
data
[
0
]
;
var
sessionToken
=
data
[
1
]
;
StandaloneLoopRooms
.
leave
(
roomToken
sessionToken
reply
)
;
}
"
Rooms
:
*
"
:
function
(
action
data
reply
)
{
var
funcName
=
action
.
split
(
"
:
"
)
.
pop
(
)
;
funcName
=
funcName
.
charAt
(
0
)
.
toLowerCase
(
)
+
funcName
.
substr
(
1
)
;
if
(
funcName
=
=
=
PUSH_SUBSCRIPTION
)
{
return
;
}
if
(
typeof
StandaloneLoopRooms
[
funcName
]
!
=
=
"
function
"
)
{
reply
(
cloneableError
(
"
Sorry
function
'
"
+
funcName
+
"
'
does
not
exist
!
"
)
)
;
return
;
}
data
.
push
(
function
(
err
result
)
{
reply
(
err
?
cloneableError
(
err
)
:
result
)
;
}
)
;
StandaloneLoopRooms
[
funcName
]
.
apply
(
StandaloneLoopRooms
data
)
;
}
SetLoopPref
:
function
(
data
reply
)
{
var
prefName
=
data
[
0
]
;
var
value
=
data
[
1
]
;
localStorage
.
setItem
(
prefName
value
)
;
reply
(
)
;
}
GetLoopPref
:
function
(
data
reply
)
{
var
prefName
=
data
[
0
]
;
reply
(
localStorage
.
getItem
(
prefName
)
)
;
}
}
;
function
handleBatchMessage
(
name
seq
data
reply
)
{
var
actions
=
data
[
0
]
;
if
(
!
actions
.
length
)
{
throw
new
Error
(
"
Ough
a
batch
call
with
no
actions
is
not
much
"
+
"
of
a
batch
now
is
it
?
"
)
;
}
if
(
!
(
"
loopCount
"
in
reply
)
)
{
reply
.
loopCount
=
0
;
}
else
if
(
+
+
reply
.
loopCount
>
MAX_LOOP_COUNT
)
{
reply
(
cloneableError
(
"
Too
many
nested
calls
"
)
)
;
return
;
}
var
resultSet
=
{
}
;
var
done
=
0
;
actions
.
forEach
(
function
(
actionSet
)
{
var
actionSeq
=
actionSet
[
0
]
;
window
.
sendAsyncMessage
(
name
actionSet
function
(
result
)
{
resultSet
[
actionSeq
]
=
result
;
if
(
+
+
done
=
=
=
actions
.
length
)
{
reply
(
resultSet
)
;
}
}
)
;
}
)
;
}
var
messageListeners
=
{
}
;
return
function
(
options
)
{
options
=
options
|
|
{
}
;
if
(
!
options
.
baseServerUrl
)
{
throw
new
Error
(
"
missing
required
baseServerUrl
"
)
;
}
StandaloneLoopRooms
.
baseServerUrl
=
options
.
baseServerUrl
;
window
.
sendAsyncMessage
=
function
(
name
data
reply
)
{
if
(
name
!
=
=
"
Loop
:
Message
"
)
{
return
;
}
var
seq
=
data
.
shift
(
)
;
var
action
=
data
.
shift
(
)
;
var
actionParts
=
action
.
split
(
"
:
"
)
;
var
handlerName
=
actionParts
.
shift
(
)
;
if
(
!
reply
)
{
reply
=
function
(
result
)
{
var
listeners
=
messageListeners
[
name
]
;
if
(
!
listeners
|
|
!
listeners
.
length
)
{
return
;
}
var
message
=
{
data
:
[
seq
result
]
}
;
listeners
.
forEach
(
function
(
listener
)
{
listener
(
message
)
;
}
)
;
}
;
}
if
(
handlerName
=
=
=
BATCH_MESSAGE
)
{
handleBatchMessage
(
name
seq
data
reply
)
;
return
;
}
var
wildcardName
=
handlerName
+
"
:
*
"
;
if
(
kMessageHandlers
[
wildcardName
]
)
{
kMessageHandlers
[
wildcardName
]
(
action
data
reply
)
;
return
;
}
if
(
!
kMessageHandlers
[
handlerName
]
)
{
var
msg
=
"
Ouch
no
message
handler
available
for
'
"
+
handlerName
+
"
'
"
;
console
.
error
(
msg
)
;
reply
(
cloneableError
(
msg
)
)
;
return
;
}
kMessageHandlers
[
handlerName
]
(
data
reply
)
;
}
;
window
.
addMessageListener
=
function
(
name
func
)
{
if
(
!
messageListeners
[
name
]
)
{
messageListeners
[
name
]
=
[
]
;
}
if
(
messageListeners
[
name
]
.
indexOf
(
func
)
=
=
=
-
1
)
{
messageListeners
[
name
]
.
push
(
func
)
;
}
}
;
window
.
removeMessageListener
=
function
(
name
func
)
{
if
(
!
messageListeners
[
name
]
)
{
return
;
}
var
idx
=
messageListeners
[
name
]
.
indexOf
(
func
)
;
if
(
idx
!
=
=
-
1
)
{
messageListeners
[
name
]
.
splice
(
idx
1
)
;
}
if
(
!
messageListeners
[
name
]
.
length
)
{
delete
messageListeners
[
name
]
;
}
}
;
}
;
}
)
(
navigator
.
mozL10n
)
;
