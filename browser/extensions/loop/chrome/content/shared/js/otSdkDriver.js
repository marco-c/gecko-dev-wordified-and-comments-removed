var
loop
=
loop
|
|
{
}
;
loop
.
OTSdkDriver
=
(
function
(
)
{
"
use
strict
"
;
var
sharedActions
=
loop
.
shared
.
actions
;
var
FAILURE_DETAILS
=
loop
.
shared
.
utils
.
FAILURE_DETAILS
;
var
STREAM_PROPERTIES
=
loop
.
shared
.
utils
.
STREAM_PROPERTIES
;
var
SCREEN_SHARE_STATES
=
loop
.
shared
.
utils
.
SCREEN_SHARE_STATES
;
var
CURSOR_MESSAGE_TYPES
=
loop
.
shared
.
utils
.
CURSOR_MESSAGE_TYPES
;
var
OTSdkDriver
=
function
(
options
)
{
if
(
!
options
.
constants
)
{
throw
new
Error
(
"
Missing
option
constants
"
)
;
}
if
(
!
options
.
dispatcher
)
{
throw
new
Error
(
"
Missing
option
dispatcher
"
)
;
}
if
(
!
options
.
sdk
)
{
throw
new
Error
(
"
Missing
option
sdk
"
)
;
}
this
.
dispatcher
=
options
.
dispatcher
;
this
.
sdk
=
options
.
sdk
;
this
.
_constants
=
options
.
constants
;
this
.
_useDataChannels
=
!
!
options
.
useDataChannels
;
this
.
_isDesktop
=
!
!
options
.
isDesktop
;
this
.
connections
=
{
}
;
this
.
_resetMetrics
(
)
;
this
.
dispatcher
.
register
(
this
[
"
setupStreamElements
"
"
setMute
"
"
toggleBrowserSharing
"
]
)
;
loop
.
shared
.
utils
.
getBoolPreference
(
"
debug
.
twoWayMediaTelemetry
"
function
(
enabled
)
{
this
.
_debugTwoWayMediaTelemetry
=
enabled
;
}
.
bind
(
this
)
)
;
if
(
this
.
_isDesktop
)
{
window
.
MediaStreamTrack
.
getSources
=
function
(
callback
)
{
navigator
.
mediaDevices
.
enumerateDevices
(
)
.
then
(
function
(
devices
)
{
var
result
=
[
]
;
devices
.
forEach
(
function
(
device
)
{
if
(
device
.
kind
=
=
=
"
audioinput
"
)
{
result
.
push
(
{
kind
:
"
audio
"
}
)
;
}
if
(
device
.
kind
=
=
=
"
videoinput
"
)
{
result
.
push
(
{
kind
:
"
video
"
}
)
;
}
}
)
;
callback
(
result
)
;
}
)
;
}
;
}
}
;
OTSdkDriver
.
prototype
=
{
get
_getCopyPublisherConfig
(
)
{
return
_
.
extend
(
{
}
this
.
publisherConfig
)
;
}
get
_getDataChannelSettings
(
)
{
return
{
channels
:
{
text
:
{
}
cursor
:
{
reliable
:
true
}
}
}
;
}
_resetMetrics
:
function
(
)
{
this
.
_metrics
=
{
connections
:
0
sendStreams
:
0
recvStreams
:
0
}
;
}
setupStreamElements
:
function
(
actionData
)
{
this
.
publisherConfig
=
actionData
.
publisherConfig
;
this
.
sdk
.
on
(
"
exception
"
this
.
_onOTException
.
bind
(
this
)
)
;
this
.
_mockPublisherEl
=
document
.
createElement
(
"
div
"
)
;
this
.
publisher
=
this
.
sdk
.
initPublisher
(
this
.
_mockPublisherEl
_
.
extend
(
this
.
_getDataChannelSettings
this
.
_getCopyPublisherConfig
)
this
.
_onPublishComplete
.
bind
(
this
)
)
;
this
.
publisher
.
on
(
"
streamCreated
"
this
.
_onLocalStreamCreated
.
bind
(
this
)
)
;
this
.
publisher
.
on
(
"
streamDestroyed
"
this
.
_onLocalStreamDestroyed
.
bind
(
this
)
)
;
this
.
publisher
.
on
(
"
accessAllowed
"
this
.
_onPublishAllowed
.
bind
(
this
)
)
;
this
.
publisher
.
on
(
"
accessDenied
"
this
.
_onPublishDenied
.
bind
(
this
)
)
;
this
.
publisher
.
on
(
"
accessDialogOpened
"
this
.
_onAccessDialogOpened
.
bind
(
this
)
)
;
}
setMute
:
function
(
actionData
)
{
if
(
actionData
.
type
=
=
=
"
audio
"
)
{
this
.
publisher
.
publishAudio
(
actionData
.
enabled
)
;
}
else
{
this
.
publisher
.
publishVideo
(
actionData
.
enabled
)
;
}
}
startScreenShare
:
function
(
options
)
{
if
(
options
.
videoSource
=
=
=
"
browser
"
)
{
this
.
_windowId
=
options
.
constraints
.
browserWindow
;
}
var
config
=
_
.
extend
(
this
.
_getCopyPublisherConfig
options
)
;
this
.
_mockScreenSharePreviewEl
=
document
.
createElement
(
"
div
"
)
;
this
.
screenshare
=
this
.
sdk
.
initPublisher
(
this
.
_mockScreenSharePreviewEl
config
this
.
_onScreenSharePublishComplete
.
bind
(
this
)
)
;
this
.
screenshare
.
on
(
"
accessAllowed
"
this
.
_onScreenShareGranted
.
bind
(
this
)
)
;
this
.
screenshare
.
on
(
"
accessDenied
"
this
.
_onScreenSharePublishError
.
bind
(
this
)
)
;
this
.
screenshare
.
on
(
"
streamCreated
"
this
.
_onScreenShareStreamCreated
.
bind
(
this
)
)
;
}
switchAcquiredWindow
:
function
(
windowId
)
{
if
(
windowId
=
=
=
this
.
_windowId
)
{
return
;
}
this
.
_windowId
=
windowId
;
this
.
screenshare
.
_
.
switchAcquiredWindow
(
windowId
)
;
}
endScreenShare
:
function
(
)
{
if
(
!
this
.
screenshare
)
{
return
false
;
}
this
.
_notifyMetricsEvent
(
"
Publisher
.
streamDestroyed
"
)
;
this
.
session
.
unpublish
(
this
.
screenshare
)
;
this
.
screenshare
.
off
(
"
accessAllowed
accessDenied
streamCreated
"
)
;
this
.
screenshare
.
destroy
(
)
;
delete
this
.
screenshare
;
delete
this
.
_mockScreenSharePreviewEl
;
delete
this
.
_windowId
;
return
true
;
}
toggleBrowserSharing
:
function
(
actionData
)
{
this
.
screenshare
.
publishVideo
(
actionData
.
enabled
)
;
}
connectSession
:
function
(
sessionData
)
{
this
.
session
=
this
.
sdk
.
initSession
(
sessionData
.
sessionId
)
;
this
.
_sendTwoWayMediaTelemetry
=
!
!
sessionData
.
sendTwoWayMediaTelemetry
;
this
.
_setTwoWayMediaStartTime
(
this
.
CONNECTION_START_TIME_UNINITIALIZED
)
;
this
.
session
.
on
(
"
sessionDisconnected
"
this
.
_onSessionDisconnected
.
bind
(
this
)
)
;
this
.
session
.
on
(
"
connectionCreated
"
this
.
_onConnectionCreated
.
bind
(
this
)
)
;
this
.
session
.
on
(
"
connectionDestroyed
"
this
.
_onConnectionDestroyed
.
bind
(
this
)
)
;
this
.
session
.
on
(
"
streamCreated
"
this
.
_onRemoteStreamCreated
.
bind
(
this
)
)
;
this
.
session
.
on
(
"
streamDestroyed
"
this
.
_onRemoteStreamDestroyed
.
bind
(
this
)
)
;
this
.
session
.
on
(
"
streamPropertyChanged
"
this
.
_onStreamPropertyChanged
.
bind
(
this
)
)
;
this
.
session
.
on
(
"
signal
:
readyForDataChannel
"
this
.
_onReadyForDataChannel
.
bind
(
this
)
)
;
this
.
session
.
connect
(
sessionData
.
apiKey
sessionData
.
sessionToken
this
.
_onSessionConnectionCompleted
.
bind
(
this
)
)
;
}
disconnectSession
:
function
(
)
{
this
.
endScreenShare
(
)
;
this
.
dispatcher
.
dispatch
(
new
sharedActions
.
DataChannelsAvailable
(
{
available
:
false
}
)
)
;
this
.
dispatcher
.
dispatch
(
new
sharedActions
.
MediaStreamDestroyed
(
{
isLocal
:
true
}
)
)
;
this
.
dispatcher
.
dispatch
(
new
sharedActions
.
MediaStreamDestroyed
(
{
isLocal
:
false
}
)
)
;
if
(
this
.
session
)
{
this
.
session
.
off
(
"
sessionDisconnected
streamCreated
streamDestroyed
"
+
"
connectionCreated
connectionDestroyed
"
+
"
streamPropertyChanged
signal
:
readyForDataChannel
"
)
;
this
.
session
.
disconnect
(
)
;
delete
this
.
session
;
this
.
_notifyMetricsEvent
(
"
Session
.
connectionDestroyed
"
"
local
"
)
;
}
if
(
this
.
publisher
)
{
this
.
publisher
.
off
(
"
accessAllowed
accessDenied
accessDialogOpened
"
+
"
streamCreated
streamDestroyed
"
)
;
this
.
publisher
.
destroy
(
)
;
delete
this
.
publisher
;
}
this
.
_resetMetrics
(
)
;
this
.
_noteConnectionLengthIfNeeded
(
this
.
_getTwoWayMediaStartTime
(
)
performance
.
now
(
)
)
;
delete
this
.
_sessionConnected
;
delete
this
.
_publisherReady
;
delete
this
.
_publishedLocalStream
;
delete
this
.
_subscribedRemoteStream
;
delete
this
.
_mockPublisherEl
;
delete
this
.
_publisherChannel
;
delete
this
.
_subscriberChannel
;
this
.
connections
=
{
}
;
this
.
_setTwoWayMediaStartTime
(
this
.
CONNECTION_START_TIME_UNINITIALIZED
)
;
}
forceDisconnectAll
:
function
(
callback
)
{
if
(
!
this
.
_sessionConnected
)
{
callback
(
)
;
return
;
}
var
connectionNames
=
Object
.
keys
(
this
.
connections
)
;
if
(
connectionNames
.
length
=
=
=
0
)
{
callback
(
)
;
return
;
}
var
disconnectCount
=
0
;
connectionNames
.
forEach
(
function
(
id
)
{
var
connection
=
this
.
connections
[
id
]
;
this
.
session
.
forceDisconnect
(
connection
function
(
)
{
if
(
+
+
disconnectCount
=
=
=
connectionNames
.
length
)
{
callback
(
)
;
}
}
)
;
}
this
)
;
}
_onSessionConnectionCompleted
:
function
(
error
)
{
if
(
error
)
{
console
.
error
(
"
Failed
to
complete
connection
"
error
)
;
this
.
_notifyMetricsEvent
(
"
sdk
.
exception
.
"
+
error
.
code
)
;
this
.
dispatcher
.
dispatch
(
new
sharedActions
.
ConnectionFailure
(
{
reason
:
FAILURE_DETAILS
.
COULD_NOT_CONNECT
}
)
)
;
return
;
}
this
.
dispatcher
.
dispatch
(
new
sharedActions
.
ConnectedToSdkServers
(
)
)
;
this
.
_sessionConnected
=
true
;
this
.
_maybePublishLocalStream
(
)
;
}
_onConnectionDestroyed
:
function
(
event
)
{
var
connection
=
event
.
connection
;
if
(
connection
&
&
(
connection
.
id
in
this
.
connections
)
)
{
delete
this
.
connections
[
connection
.
id
]
;
}
this
.
_notifyMetricsEvent
(
"
Session
.
connectionDestroyed
"
"
peer
"
)
;
this
.
_noteConnectionLengthIfNeeded
(
this
.
_getTwoWayMediaStartTime
(
)
performance
.
now
(
)
)
;
this
.
dispatcher
.
dispatch
(
new
sharedActions
.
RemotePeerDisconnected
(
{
peerHungup
:
event
.
reason
=
=
=
"
clientDisconnected
"
}
)
)
;
}
_onSessionDisconnected
:
function
(
event
)
{
var
reason
;
switch
(
event
.
reason
)
{
case
"
networkDisconnected
"
:
reason
=
FAILURE_DETAILS
.
NETWORK_DISCONNECTED
;
break
;
case
"
forceDisconnected
"
:
reason
=
FAILURE_DETAILS
.
EXPIRED_OR_INVALID
;
break
;
default
:
return
;
}
this
.
_noteConnectionLengthIfNeeded
(
this
.
_getTwoWayMediaStartTime
(
)
performance
.
now
(
)
)
;
this
.
_notifyMetricsEvent
(
"
Session
.
"
+
event
.
reason
)
;
this
.
dispatcher
.
dispatch
(
new
sharedActions
.
ConnectionFailure
(
{
reason
:
reason
}
)
)
;
}
_onConnectionCreated
:
function
(
event
)
{
var
connection
=
event
.
connection
;
if
(
this
.
session
.
connection
.
id
=
=
=
connection
.
id
)
{
this
.
_notifyMetricsEvent
(
"
Session
.
connectionCreated
"
"
local
"
)
;
return
;
}
this
.
connections
[
connection
.
id
]
=
connection
;
this
.
_notifyMetricsEvent
(
"
Session
.
connectionCreated
"
"
peer
"
)
;
this
.
dispatcher
.
dispatch
(
new
sharedActions
.
RemotePeerConnected
(
)
)
;
}
_getConnectionState
:
function
(
)
{
if
(
this
.
_metrics
.
sendStreams
)
{
return
this
.
_metrics
.
recvStreams
?
"
sendrecv
"
:
"
sending
"
;
}
if
(
this
.
_metrics
.
recvStreams
)
{
return
"
receiving
"
;
}
return
"
starting
"
;
}
_notifyMetricsEvent
:
function
(
eventName
clientType
)
{
if
(
!
eventName
)
{
return
;
}
var
state
;
switch
(
eventName
)
{
case
"
Session
.
connectionCreated
"
:
this
.
_metrics
.
connections
+
+
;
if
(
clientType
=
=
=
"
local
"
)
{
state
=
"
waiting
"
;
}
break
;
case
"
Session
.
connectionDestroyed
"
:
this
.
_metrics
.
connections
-
-
;
if
(
clientType
=
=
=
"
local
"
)
{
return
;
}
else
if
(
!
this
.
_metrics
.
connections
)
{
state
=
"
waiting
"
;
}
break
;
case
"
Publisher
.
streamCreated
"
:
this
.
_metrics
.
sendStreams
+
+
;
break
;
case
"
Publisher
.
streamDestroyed
"
:
this
.
_metrics
.
sendStreams
-
-
;
break
;
case
"
Session
.
streamCreated
"
:
this
.
_metrics
.
recvStreams
+
+
;
break
;
case
"
Session
.
streamDestroyed
"
:
this
.
_metrics
.
recvStreams
-
-
;
break
;
case
"
Session
.
networkDisconnected
"
:
case
"
Session
.
forceDisconnected
"
:
break
;
default
:
if
(
!
/
^
sdk
\
.
(
exception
|
datachannel
)
/
.
test
(
eventName
)
)
{
console
.
error
(
"
Unexpected
event
name
"
eventName
)
;
return
;
}
}
if
(
!
state
)
{
state
=
this
.
_getConnectionState
(
)
;
}
this
.
dispatcher
.
dispatch
(
new
sharedActions
.
ConnectionStatus
(
{
event
:
eventName
state
:
state
connections
:
this
.
_metrics
.
connections
sendStreams
:
this
.
_metrics
.
sendStreams
recvStreams
:
this
.
_metrics
.
recvStreams
}
)
)
;
}
_handleRemoteScreenShareCreated
:
function
(
stream
)
{
this
.
dispatcher
.
dispatch
(
new
sharedActions
.
ReceivingScreenShare
(
{
receiving
:
true
}
)
)
;
this
.
_mockScreenShareEl
=
document
.
createElement
(
"
div
"
)
;
this
.
session
.
subscribe
(
stream
this
.
_mockScreenShareEl
this
.
_getCopyPublisherConfig
this
.
_onScreenShareSubscribeCompleted
.
bind
(
this
)
)
;
}
_onRemoteStreamCreated
:
function
(
event
)
{
this
.
_notifyMetricsEvent
(
"
Session
.
streamCreated
"
)
;
if
(
event
.
stream
[
STREAM_PROPERTIES
.
HAS_VIDEO
]
)
{
this
.
dispatcher
.
dispatch
(
new
sharedActions
.
VideoDimensionsChanged
(
{
isLocal
:
false
videoType
:
event
.
stream
.
videoType
dimensions
:
event
.
stream
[
STREAM_PROPERTIES
.
VIDEO_DIMENSIONS
]
}
)
)
;
}
if
(
event
.
stream
.
videoType
=
=
=
"
screen
"
)
{
this
.
_handleRemoteScreenShareCreated
(
event
.
stream
)
;
return
;
}
this
.
_mockSubscribeEl
=
document
.
createElement
(
"
div
"
)
;
this
.
subscriber
=
this
.
session
.
subscribe
(
event
.
stream
this
.
_mockSubscribeEl
this
.
_getCopyPublisherConfig
this
.
_onSubscribeCompleted
.
bind
(
this
)
)
;
}
_onSubscribeCompleted
:
function
(
err
sdkSubscriberObject
subscriberVideo
)
{
if
(
err
)
{
console
.
log
(
"
subscribe
error
:
"
err
)
;
return
;
}
var
sdkSubscriberVideo
=
subscriberVideo
?
subscriberVideo
:
this
.
_mockSubscribeEl
.
querySelector
(
"
video
"
)
;
if
(
!
sdkSubscriberVideo
)
{
console
.
error
(
"
sdkSubscriberVideo
unexpectedly
falsy
!
"
)
;
}
sdkSubscriberObject
.
on
(
"
videoEnabled
"
this
.
_onVideoEnabled
.
bind
(
this
)
)
;
sdkSubscriberObject
.
on
(
"
videoDisabled
"
this
.
_onVideoDisabled
.
bind
(
this
)
)
;
this
.
dispatcher
.
dispatch
(
new
sharedActions
.
MediaStreamCreated
(
{
hasVideo
:
sdkSubscriberObject
.
stream
[
STREAM_PROPERTIES
.
HAS_VIDEO
]
isLocal
:
false
srcMediaElement
:
sdkSubscriberVideo
}
)
)
;
this
.
_subscribedRemoteStream
=
true
;
if
(
this
.
_checkAllStreamsConnected
(
)
)
{
this
.
_setTwoWayMediaStartTime
(
performance
.
now
(
)
)
;
this
.
dispatcher
.
dispatch
(
new
sharedActions
.
MediaConnected
(
)
)
;
}
this
.
_setupDataChannelIfNeeded
(
sdkSubscriberObject
)
;
}
_onScreenShareSubscribeCompleted
:
function
(
err
sdkSubscriberObject
subscriberVideo
)
{
if
(
err
)
{
console
.
log
(
"
subscribe
error
:
"
err
)
;
return
;
}
var
sdkSubscriberVideo
=
subscriberVideo
?
subscriberVideo
:
this
.
_mockScreenShareEl
.
querySelector
(
"
video
"
)
;
this
.
dispatcher
.
dispatch
(
new
sharedActions
.
ReceivingScreenShare
(
{
receiving
:
true
srcMediaElement
:
sdkSubscriberVideo
}
)
)
;
}
_setupDataChannelIfNeeded
:
function
(
sdkSubscriberObject
)
{
if
(
!
this
.
_useDataChannels
)
{
return
;
}
this
.
session
.
signal
(
{
type
:
"
readyForDataChannel
"
to
:
sdkSubscriberObject
.
stream
.
connection
}
function
(
signalError
)
{
if
(
signalError
)
{
console
.
error
(
signalError
)
;
}
}
)
;
var
dataChannels
=
[
[
"
text
"
function
(
message
)
{
message
.
receivedTimestamp
=
(
new
Date
(
)
)
.
toISOString
(
)
;
this
.
dispatcher
.
dispatch
(
new
sharedActions
.
ReceivedTextChatMessage
(
message
)
)
;
}
.
bind
(
this
)
function
(
channel
)
{
this
.
_subscriberChannel
=
channel
;
this
.
_checkDataChannelsAvailable
(
)
;
}
.
bind
(
this
)
]
[
"
cursor
"
function
(
message
)
{
switch
(
message
.
type
)
{
case
CURSOR_MESSAGE_TYPES
.
POSITION
:
this
.
dispatcher
.
dispatch
(
new
sharedActions
.
ReceivedCursorData
(
message
)
)
;
break
;
}
}
.
bind
(
this
)
function
(
channel
)
{
this
.
_subscriberCursorChannel
=
channel
;
}
.
bind
(
this
)
]
]
;
dataChannels
.
forEach
(
function
(
args
)
{
var
type
=
args
[
0
]
onMessage
=
args
[
1
]
onChannel
=
args
[
2
]
;
sdkSubscriberObject
.
_
.
getDataChannel
(
type
{
}
function
(
err
channel
)
{
if
(
err
)
{
console
.
error
(
err
)
;
this
.
_notifyMetricsEvent
(
"
sdk
.
datachannel
.
sub
.
"
+
type
+
"
.
"
+
err
.
message
)
;
return
;
}
channel
.
on
(
{
message
:
function
(
ev
)
{
try
{
var
message
=
JSON
.
parse
(
ev
.
data
)
;
onMessage
(
message
)
;
}
catch
(
ex
)
{
console
.
error
(
"
Failed
to
process
incoming
chat
message
"
ex
)
;
}
}
close
:
function
(
)
{
console
.
log
(
"
Subscribed
"
+
type
+
"
data
channel
closed
!
"
)
;
}
}
)
;
onChannel
(
channel
)
;
}
.
bind
(
this
)
)
;
}
.
bind
(
this
)
)
;
}
_onReadyForDataChannel
:
function
(
)
{
if
(
!
this
.
_useDataChannels
)
{
return
;
}
var
dataChannels
=
[
[
"
text
"
function
(
channel
)
{
this
.
_publisherChannel
=
channel
;
this
.
_checkDataChannelsAvailable
(
)
;
}
.
bind
(
this
)
]
[
"
cursor
"
function
(
channel
)
{
this
.
_publisherCursorChannel
=
channel
;
}
.
bind
(
this
)
]
]
;
dataChannels
.
forEach
(
function
(
args
)
{
var
type
=
args
[
0
]
onChannel
=
args
[
1
]
;
this
.
publisher
.
_
.
getDataChannel
(
type
{
}
function
(
err
channel
)
{
if
(
err
)
{
console
.
error
(
err
)
;
this
.
_notifyMetricsEvent
(
"
sdk
.
datachannel
.
pub
.
"
+
type
+
"
.
"
+
err
.
message
)
;
return
;
}
channel
.
on
(
{
close
:
function
(
)
{
console
.
log
(
"
Published
"
+
type
+
"
data
channel
closed
!
"
)
;
}
}
)
;
onChannel
(
channel
)
;
}
.
bind
(
this
)
)
;
}
.
bind
(
this
)
)
;
}
_checkDataChannelsAvailable
:
function
(
)
{
if
(
this
.
_publisherChannel
&
&
this
.
_subscriberChannel
)
{
this
.
dispatcher
.
dispatch
(
new
sharedActions
.
DataChannelsAvailable
(
{
available
:
true
}
)
)
;
}
}
sendTextChatMessage
:
function
(
message
)
{
this
.
_publisherChannel
.
send
(
JSON
.
stringify
(
message
)
)
;
}
sendCursorMessage
:
function
(
message
)
{
if
(
!
this
.
_publisherCursorChannel
|
|
!
this
.
_subscriberCursorChannel
)
{
return
;
}
message
.
userID
=
this
.
session
.
sessionId
;
this
.
_publisherCursorChannel
.
send
(
JSON
.
stringify
(
message
)
)
;
}
_onLocalStreamCreated
:
function
(
event
)
{
this
.
_notifyMetricsEvent
(
"
Publisher
.
streamCreated
"
)
;
var
sdkLocalVideo
=
this
.
_mockPublisherEl
.
querySelector
(
"
video
"
)
;
var
hasVideo
=
event
.
stream
[
STREAM_PROPERTIES
.
HAS_VIDEO
]
;
this
.
dispatcher
.
dispatch
(
new
sharedActions
.
MediaStreamCreated
(
{
hasVideo
:
hasVideo
isLocal
:
true
srcMediaElement
:
sdkLocalVideo
}
)
)
;
if
(
hasVideo
)
{
this
.
dispatcher
.
dispatch
(
new
sharedActions
.
VideoDimensionsChanged
(
{
isLocal
:
true
videoType
:
event
.
stream
.
videoType
dimensions
:
event
.
stream
[
STREAM_PROPERTIES
.
VIDEO_DIMENSIONS
]
}
)
)
;
}
}
__twoWayMediaStartTime
:
undefined
CONNECTION_START_TIME_UNINITIALIZED
:
-
1
CONNECTION_START_TIME_ALREADY_NOTED
:
-
2
_setTwoWayMediaStartTime
:
function
(
start
)
{
if
(
!
this
.
_sendTwoWayMediaTelemetry
)
{
return
;
}
this
.
__twoWayMediaStartTime
=
start
;
if
(
this
.
_debugTwoWayMediaTelemetry
)
{
console
.
log
(
"
Loop
Telemetry
:
noted
two
-
way
connection
start
"
+
"
start
time
in
ms
:
"
start
)
;
}
}
_getTwoWayMediaStartTime
:
function
(
)
{
return
this
.
__twoWayMediaStartTime
;
}
_onRemoteStreamDestroyed
:
function
(
event
)
{
this
.
_notifyMetricsEvent
(
"
Session
.
streamDestroyed
"
)
;
if
(
event
.
stream
.
videoType
!
=
=
"
screen
"
)
{
this
.
dispatcher
.
dispatch
(
new
sharedActions
.
DataChannelsAvailable
(
{
available
:
false
}
)
)
;
this
.
dispatcher
.
dispatch
(
new
sharedActions
.
MediaStreamDestroyed
(
{
isLocal
:
false
}
)
)
;
delete
this
.
_subscriberChannel
;
delete
this
.
_mockSubscribeEl
;
return
;
}
this
.
dispatcher
.
dispatch
(
new
sharedActions
.
ReceivingScreenShare
(
{
receiving
:
false
}
)
)
;
delete
this
.
_mockScreenShareEl
;
}
_onLocalStreamDestroyed
:
function
(
)
{
this
.
_notifyMetricsEvent
(
"
Publisher
.
streamDestroyed
"
)
;
this
.
dispatcher
.
dispatch
(
new
sharedActions
.
DataChannelsAvailable
(
{
available
:
false
}
)
)
;
this
.
dispatcher
.
dispatch
(
new
sharedActions
.
MediaStreamDestroyed
(
{
isLocal
:
true
}
)
)
;
delete
this
.
_publisherChannel
;
delete
this
.
_mockPublisherEl
;
}
_onAccessDialogOpened
:
function
(
event
)
{
event
.
preventDefault
(
)
;
}
_onPublishAllowed
:
function
(
event
)
{
event
.
preventDefault
(
)
;
this
.
_publisherReady
=
true
;
this
.
dispatcher
.
dispatch
(
new
sharedActions
.
GotMediaPermission
(
)
)
;
this
.
_maybePublishLocalStream
(
)
;
}
_onPublishComplete
:
function
(
error
)
{
if
(
!
error
)
{
return
;
}
if
(
!
(
error
.
message
&
&
error
.
message
=
=
=
"
DENIED
"
)
)
{
if
(
this
.
publisher
)
{
this
.
publisher
.
off
(
"
accessAllowed
accessDenied
accessDialogOpened
streamCreated
"
)
;
this
.
publisher
.
destroy
(
)
;
delete
this
.
publisher
;
delete
this
.
_mockPublisherEl
;
}
this
.
dispatcher
.
dispatch
(
new
sharedActions
.
ConnectionFailure
(
{
reason
:
FAILURE_DETAILS
.
UNABLE_TO_PUBLISH_MEDIA
}
)
)
;
this
.
_notifyMetricsEvent
(
"
sdk
.
exception
.
"
+
error
.
code
+
"
.
"
+
error
.
message
)
;
}
}
_onPublishDenied
:
function
(
event
)
{
event
.
preventDefault
(
)
;
this
.
dispatcher
.
dispatch
(
new
sharedActions
.
ConnectionFailure
(
{
reason
:
FAILURE_DETAILS
.
MEDIA_DENIED
}
)
)
;
delete
this
.
_mockPublisherEl
;
}
_onOTException
:
function
(
event
)
{
switch
(
event
.
code
)
{
case
OT
.
ExceptionCodes
.
PUBLISHER_ICE_WORKFLOW_FAILED
:
case
OT
.
ExceptionCodes
.
SUBSCRIBER_ICE_WORKFLOW_FAILED
:
this
.
dispatcher
.
dispatch
(
new
sharedActions
.
ConnectionFailure
(
{
reason
:
FAILURE_DETAILS
.
ICE_FAILED
}
)
)
;
this
.
_notifyMetricsEvent
(
"
sdk
.
exception
.
"
+
event
.
code
)
;
break
;
case
OT
.
ExceptionCodes
.
TERMS_OF_SERVICE_FAILURE
:
this
.
dispatcher
.
dispatch
(
new
sharedActions
.
ConnectionFailure
(
{
reason
:
FAILURE_DETAILS
.
TOS_FAILURE
}
)
)
;
this
.
_notifyMetricsEvent
(
"
sdk
.
exception
.
"
+
event
.
code
)
;
break
;
default
:
this
.
_notifyMetricsEvent
(
"
sdk
.
exception
.
"
+
event
.
code
)
;
break
;
}
}
_onStreamPropertyChanged
:
function
(
event
)
{
switch
(
event
.
changedProperty
)
{
case
STREAM_PROPERTIES
.
VIDEO_DIMENSIONS
:
this
.
dispatcher
.
dispatch
(
new
sharedActions
.
VideoDimensionsChanged
(
{
isLocal
:
event
.
stream
.
connection
.
id
=
=
=
this
.
session
.
connection
.
id
videoType
:
event
.
stream
.
videoType
dimensions
:
event
.
stream
[
STREAM_PROPERTIES
.
VIDEO_DIMENSIONS
]
}
)
)
;
break
;
case
STREAM_PROPERTIES
.
HAS_VIDEO
:
if
(
event
.
stream
.
videoType
=
=
=
"
screen
"
)
{
this
.
dispatcher
.
dispatch
(
new
sharedActions
.
VideoScreenStreamChanged
(
{
hasVideo
:
event
.
newValue
}
)
)
;
}
break
;
}
}
_onVideoEnabled
:
function
(
)
{
var
sdkSubscriberVideo
=
this
.
_mockSubscribeEl
.
querySelector
(
"
video
"
)
;
if
(
!
sdkSubscriberVideo
)
{
console
.
error
(
"
sdkSubscriberVideo
unexpectedly
falsy
!
"
)
;
}
this
.
dispatcher
.
dispatch
(
new
sharedActions
.
RemoteVideoStatus
(
{
videoEnabled
:
true
}
)
)
;
}
_onVideoDisabled
:
function
(
)
{
this
.
dispatcher
.
dispatch
(
new
sharedActions
.
RemoteVideoStatus
(
{
videoEnabled
:
false
}
)
)
;
}
_maybePublishLocalStream
:
function
(
)
{
if
(
this
.
_sessionConnected
&
&
this
.
_publisherReady
)
{
this
.
session
.
publish
(
this
.
publisher
)
;
this
.
_publishedLocalStream
=
true
;
if
(
this
.
_checkAllStreamsConnected
(
)
)
{
this
.
_setTwoWayMediaStartTime
(
performance
.
now
(
)
)
;
this
.
dispatcher
.
dispatch
(
new
sharedActions
.
MediaConnected
(
)
)
;
}
}
}
_checkAllStreamsConnected
:
function
(
)
{
return
this
.
_publishedLocalStream
&
&
this
.
_subscribedRemoteStream
;
}
_onScreenShareGranted
:
function
(
)
{
this
.
session
.
publish
(
this
.
screenshare
)
;
this
.
dispatcher
.
dispatch
(
new
sharedActions
.
ScreenSharingState
(
{
state
:
SCREEN_SHARE_STATES
.
ACTIVE
}
)
)
;
}
_onScreenSharePublishComplete
:
function
(
error
)
{
if
(
!
error
)
{
return
;
}
this
.
screenshare
.
off
(
"
accessAllowed
accessDenied
streamCreated
"
)
;
this
.
screenshare
.
destroy
(
)
;
delete
this
.
screenshare
;
delete
this
.
_mockScreenSharePreviewEl
;
this
.
dispatcher
.
dispatch
(
new
sharedActions
.
ScreenSharingState
(
{
state
:
SCREEN_SHARE_STATES
.
INACTIVE
}
)
)
;
this
.
_notifyMetricsEvent
(
"
sdk
.
exception
.
screen
.
"
+
error
.
code
+
"
.
"
+
error
.
message
)
;
}
_onScreenSharePublishError
:
function
(
)
{
this
.
dispatcher
.
dispatch
(
new
sharedActions
.
ScreenSharingState
(
{
state
:
SCREEN_SHARE_STATES
.
INACTIVE
}
)
)
;
this
.
screenshare
.
off
(
"
accessAllowed
accessDenied
streamCreated
"
)
;
this
.
screenshare
.
destroy
(
)
;
delete
this
.
screenshare
;
delete
this
.
_mockScreenSharePreviewEl
;
}
_onScreenShareStreamCreated
:
function
(
)
{
this
.
_notifyMetricsEvent
(
"
Publisher
.
streamCreated
"
)
;
}
_connectionLengthNotedCalls
:
0
_noteConnectionLength
:
function
(
callLengthSeconds
)
{
var
buckets
=
this
.
_constants
.
TWO_WAY_MEDIA_CONN_LENGTH
;
var
bucket
=
buckets
.
SHORTER_THAN_10S
;
if
(
callLengthSeconds
>
=
10
&
&
callLengthSeconds
<
=
30
)
{
bucket
=
buckets
.
BETWEEN_10S_AND_30S
;
}
else
if
(
callLengthSeconds
>
30
&
&
callLengthSeconds
<
=
300
)
{
bucket
=
buckets
.
BETWEEN_30S_AND_5M
;
}
else
if
(
callLengthSeconds
>
300
)
{
bucket
=
buckets
.
MORE_THAN_5M
;
}
loop
.
request
(
"
TelemetryAddValue
"
"
LOOP_TWO_WAY_MEDIA_CONN_LENGTH_1
"
bucket
)
;
this
.
_setTwoWayMediaStartTime
(
this
.
CONNECTION_START_TIME_ALREADY_NOTED
)
;
this
.
_connectionLengthNotedCalls
+
+
;
if
(
this
.
_debugTwoWayMediaTelemetry
)
{
console
.
log
(
"
Loop
Telemetry
:
noted
two
-
way
media
connection
"
+
"
in
bucket
:
"
bucket
)
;
}
}
_noteConnectionLengthIfNeeded
:
function
(
startTime
endTime
)
{
if
(
!
this
.
_sendTwoWayMediaTelemetry
)
{
return
;
}
if
(
startTime
=
=
=
this
.
CONNECTION_START_TIME_ALREADY_NOTED
|
|
startTime
=
=
=
this
.
CONNECTION_START_TIME_UNINITIALIZED
|
|
startTime
>
endTime
)
{
if
(
this
.
_debugTwoWayMediaTelemetry
)
{
console
.
log
(
"
_noteConnectionLengthIfNeeded
called
with
"
+
"
invalid
params
either
the
calls
were
never
"
+
"
connected
or
there
is
a
bug
;
startTime
:
"
startTime
"
endTime
:
"
endTime
)
;
}
return
;
}
var
callLengthSeconds
=
(
endTime
-
startTime
)
/
1000
;
this
.
_noteConnectionLength
(
callLengthSeconds
)
;
}
_debugTwoWayMediaTelemetry
:
false
}
;
return
OTSdkDriver
;
}
)
(
)
;
