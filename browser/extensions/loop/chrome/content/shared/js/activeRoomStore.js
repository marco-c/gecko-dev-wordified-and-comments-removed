"
use
strict
"
;
var
loop
=
loop
|
|
{
}
;
loop
.
store
=
loop
.
store
|
|
{
}
;
loop
.
store
.
ROOM_STATES
=
{
INIT
:
"
room
-
init
"
GATHER
:
"
room
-
gather
"
READY
:
"
room
-
ready
"
MEDIA_WAIT
:
"
room
-
media
-
wait
"
JOINING
:
"
room
-
joining
"
JOINED
:
"
room
-
joined
"
SESSION_CONNECTED
:
"
room
-
session
-
connected
"
HAS_PARTICIPANTS
:
"
room
-
has
-
participants
"
FAILED
:
"
room
-
failed
"
FULL
:
"
room
-
full
"
ENDED
:
"
room
-
ended
"
CLOSING
:
"
room
-
closing
"
}
;
loop
.
store
.
ActiveRoomStore
=
function
(
mozL10n
)
{
"
use
strict
"
;
var
sharedActions
=
loop
.
shared
.
actions
;
var
crypto
=
loop
.
crypto
;
var
CHAT_CONTENT_TYPES
=
loop
.
shared
.
utils
.
CHAT_CONTENT_TYPES
;
var
FAILURE_DETAILS
=
loop
.
shared
.
utils
.
FAILURE_DETAILS
;
var
SCREEN_SHARE_STATES
=
loop
.
shared
.
utils
.
SCREEN_SHARE_STATES
;
var
REST_ERRNOS
=
loop
.
shared
.
utils
.
REST_ERRNOS
;
var
ROOM_STATES
=
loop
.
store
.
ROOM_STATES
;
var
ROOM_INFO_FAILURES
=
loop
.
shared
.
utils
.
ROOM_INFO_FAILURES
;
var
OPTIONAL_ROOMINFO_FIELDS
=
{
participants
:
"
participants
"
roomContextUrls
:
"
roomContextUrls
"
roomDescription
:
"
roomDescription
"
roomInfoFailure
:
"
roomInfoFailure
"
roomName
:
"
roomName
"
roomState
:
"
roomState
"
}
;
var
updateContextTimer
=
null
;
var
ActiveRoomStore
=
loop
.
store
.
createStore
(
{
expiresTimeFactor
:
0
.
9
actions
:
[
"
setupWindowData
"
"
fetchServerData
"
]
initialize
:
function
initialize
(
options
)
{
if
(
!
options
.
sdkDriver
)
{
throw
new
Error
(
"
Missing
option
sdkDriver
"
)
;
}
this
.
_sdkDriver
=
options
.
sdkDriver
;
this
.
_isDesktop
=
options
.
isDesktop
|
|
false
;
}
_statesToResetOnLeave
:
[
"
audioMuted
"
"
chatMessageExchanged
"
"
localSrcMediaElement
"
"
localVideoDimensions
"
"
mediaConnected
"
"
receivingScreenShare
"
"
remoteAudioEnabled
"
"
remotePeerDisconnected
"
"
remoteSrcMediaElement
"
"
remoteVideoDimensions
"
"
remoteVideoEnabled
"
"
streamPaused
"
"
screenSharingState
"
"
screenShareMediaElement
"
"
videoMuted
"
]
getInitialStoreState
:
function
getInitialStoreState
(
)
{
return
{
roomState
:
ROOM_STATES
.
INIT
audioMuted
:
false
videoMuted
:
false
remoteAudioEnabled
:
false
remoteVideoEnabled
:
false
failureReason
:
undefined
userAgentHandlesRoom
:
undefined
used
:
false
localVideoDimensions
:
{
}
remoteVideoDimensions
:
{
}
screenSharingState
:
SCREEN_SHARE_STATES
.
INACTIVE
sharingPaused
:
false
receivingScreenShare
:
false
remotePeerDisconnected
:
false
roomContextUrls
:
null
roomDescription
:
null
roomInfoFailure
:
null
roomName
:
null
streamPaused
:
false
mediaConnected
:
false
chatMessageExchanged
:
false
}
;
}
roomFailure
:
function
roomFailure
(
actionData
)
{
function
getReason
(
serverCode
)
{
switch
(
serverCode
)
{
case
REST_ERRNOS
.
INVALID_TOKEN
:
case
REST_ERRNOS
.
EXPIRED
:
return
FAILURE_DETAILS
.
EXPIRED_OR_INVALID
;
case
undefined
:
return
FAILURE_DETAILS
.
COULD_NOT_CONNECT
;
default
:
return
FAILURE_DETAILS
.
UNKNOWN
;
}
}
console
.
error
(
"
Error
in
state
"
+
this
.
_storeState
.
roomState
+
"
:
"
actionData
.
error
)
;
var
exitState
=
this
.
_storeState
.
roomState
!
=
=
ROOM_STATES
.
FAILED
?
this
.
_storeState
.
roomState
:
this
.
_storeState
.
failureExitState
;
this
.
setStoreState
(
{
error
:
actionData
.
error
failureReason
:
getReason
(
actionData
.
error
.
errno
)
failureExitState
:
exitState
}
)
;
this
.
_leaveRoom
(
actionData
.
error
.
errno
=
=
=
REST_ERRNOS
.
ROOM_FULL
?
ROOM_STATES
.
FULL
:
ROOM_STATES
.
FAILED
actionData
.
failedJoinRequest
)
;
}
retryAfterRoomFailure
:
function
retryAfterRoomFailure
(
)
{
if
(
this
.
_storeState
.
failureReason
=
=
=
FAILURE_DETAILS
.
EXPIRED_OR_INVALID
)
{
console
.
error
(
"
Invalid
retry
attempt
for
expired
or
invalid
url
"
)
;
return
;
}
switch
(
this
.
_storeState
.
failureExitState
)
{
case
ROOM_STATES
.
GATHER
:
this
.
dispatchAction
(
new
sharedActions
.
FetchServerData
(
{
cryptoKey
:
this
.
_storeState
.
roomCryptoKey
token
:
this
.
_storeState
.
roomToken
windowType
:
"
room
"
}
)
)
;
return
;
case
ROOM_STATES
.
INIT
:
case
ROOM_STATES
.
ENDED
:
case
ROOM_STATES
.
CLOSING
:
console
.
error
(
"
Unexpected
retry
for
exit
state
"
this
.
_storeState
.
failureExitState
)
;
return
;
default
:
this
.
joinRoom
(
)
;
return
;
}
}
_registerPostSetupActions
:
function
_registerPostSetupActions
(
)
{
if
(
this
.
_registeredActions
)
{
return
;
}
this
.
_registeredActions
=
true
;
var
actions
=
[
"
roomFailure
"
"
retryAfterRoomFailure
"
"
updateRoomInfo
"
"
userAgentHandlesRoom
"
"
gotMediaPermission
"
"
joinRoom
"
"
joinedRoom
"
"
connectedToSdkServers
"
"
connectionFailure
"
"
setMute
"
"
screenSharingState
"
"
receivingScreenShare
"
"
remotePeerDisconnected
"
"
remotePeerConnected
"
"
windowUnload
"
"
leaveRoom
"
"
feedbackComplete
"
"
mediaStreamCreated
"
"
mediaStreamDestroyed
"
"
remoteVideoStatus
"
"
videoDimensionsChanged
"
"
startBrowserShare
"
"
endScreenShare
"
"
toggleBrowserSharing
"
"
connectionStatus
"
"
mediaConnected
"
"
videoScreenStreamChanged
"
]
;
if
(
this
.
_isDesktop
)
{
actions
.
push
(
"
receivedTextChatMessage
"
"
sendTextChatMessage
"
)
;
}
this
.
dispatcher
.
register
(
this
actions
)
;
this
.
_onUpdateListener
=
this
.
_handleRoomUpdate
.
bind
(
this
)
;
this
.
_onDeleteListener
=
this
.
_handleRoomDelete
.
bind
(
this
)
;
var
roomToken
=
this
.
_storeState
.
roomToken
;
loop
.
request
(
"
Rooms
:
PushSubscription
"
[
"
delete
:
"
+
roomToken
"
update
:
"
+
roomToken
]
)
;
loop
.
subscribe
(
"
Rooms
:
Delete
:
"
+
roomToken
this
.
_handleRoomDelete
.
bind
(
this
)
)
;
loop
.
subscribe
(
"
Rooms
:
Update
:
"
+
roomToken
this
.
_handleRoomUpdate
.
bind
(
this
)
)
;
}
setupWindowData
:
function
setupWindowData
(
actionData
)
{
if
(
actionData
.
type
!
=
=
"
room
"
)
{
return
Promise
.
resolve
(
)
;
}
this
.
setStoreState
(
{
roomState
:
ROOM_STATES
.
GATHER
roomToken
:
actionData
.
roomToken
windowId
:
actionData
.
windowId
}
)
;
this
.
_registerPostSetupActions
(
)
;
return
loop
.
request
(
"
Rooms
:
Get
"
actionData
.
roomToken
)
.
then
(
function
(
result
)
{
var
room
=
result
;
if
(
result
.
isError
)
{
this
.
dispatchAction
(
new
sharedActions
.
RoomFailure
(
{
error
:
result
failedJoinRequest
:
false
}
)
)
;
return
;
}
this
.
dispatchAction
(
new
sharedActions
.
UpdateRoomInfo
(
{
participants
:
room
.
participants
roomContextUrls
:
room
.
decryptedContext
.
urls
roomDescription
:
room
.
decryptedContext
.
description
roomName
:
room
.
decryptedContext
.
roomName
roomState
:
ROOM_STATES
.
READY
roomUrl
:
room
.
roomUrl
}
)
)
;
this
.
dispatchAction
(
new
sharedActions
.
JoinRoom
(
)
)
;
}
.
bind
(
this
)
)
;
}
fetchServerData
:
function
fetchServerData
(
actionData
)
{
if
(
actionData
.
windowType
!
=
=
"
room
"
)
{
return
Promise
.
resolve
(
)
;
}
this
.
setStoreState
(
{
roomState
:
ROOM_STATES
.
GATHER
roomToken
:
actionData
.
token
roomCryptoKey
:
actionData
.
cryptoKey
standalone
:
true
}
)
;
this
.
_registerPostSetupActions
(
)
;
var
dataPromise
=
this
.
_getRoomDataForStandalone
(
actionData
.
cryptoKey
)
;
var
userAgentHandlesPromise
=
this
.
_promiseDetectUserAgentHandles
(
)
;
return
Promise
.
all
(
[
dataPromise
userAgentHandlesPromise
]
)
.
then
(
function
(
results
)
{
results
.
forEach
(
function
(
result
)
{
this
.
dispatcher
.
dispatch
(
result
)
;
}
.
bind
(
this
)
)
;
}
.
bind
(
this
)
)
;
}
_getRoomDataForStandalone
:
function
_getRoomDataForStandalone
(
roomCryptoKey
)
{
return
new
Promise
(
function
(
resolve
)
{
loop
.
request
(
"
Rooms
:
Get
"
this
.
_storeState
.
roomToken
)
.
then
(
function
(
result
)
{
if
(
result
.
isError
)
{
resolve
(
new
sharedActions
.
RoomFailure
(
{
error
:
result
failedJoinRequest
:
false
}
)
)
;
return
;
}
var
roomInfoData
=
new
sharedActions
.
UpdateRoomInfo
(
{
roomState
:
ROOM_STATES
.
READY
roomUrl
:
result
.
roomUrl
}
)
;
if
(
!
result
.
context
&
&
!
result
.
roomName
)
{
roomInfoData
.
roomInfoFailure
=
ROOM_INFO_FAILURES
.
NO_DATA
;
resolve
(
roomInfoData
)
;
return
;
}
if
(
result
.
roomName
&
&
!
result
.
context
)
{
roomInfoData
.
roomName
=
result
.
roomName
;
resolve
(
roomInfoData
)
;
return
;
}
if
(
!
crypto
.
isSupported
(
)
)
{
roomInfoData
.
roomInfoFailure
=
ROOM_INFO_FAILURES
.
WEB_CRYPTO_UNSUPPORTED
;
resolve
(
roomInfoData
)
;
return
;
}
if
(
!
roomCryptoKey
)
{
roomInfoData
.
roomInfoFailure
=
ROOM_INFO_FAILURES
.
NO_CRYPTO_KEY
;
resolve
(
roomInfoData
)
;
return
;
}
crypto
.
decryptBytes
(
roomCryptoKey
result
.
context
.
value
)
.
then
(
function
(
decryptedResult
)
{
var
realResult
=
JSON
.
parse
(
decryptedResult
)
;
roomInfoData
.
roomDescription
=
realResult
.
description
;
roomInfoData
.
roomContextUrls
=
realResult
.
urls
;
roomInfoData
.
roomName
=
realResult
.
roomName
;
resolve
(
roomInfoData
)
;
}
function
(
)
{
roomInfoData
.
roomInfoFailure
=
ROOM_INFO_FAILURES
.
DECRYPT_FAILED
;
resolve
(
roomInfoData
)
;
}
)
;
}
.
bind
(
this
)
)
;
}
.
bind
(
this
)
)
;
}
_promiseDetectUserAgentHandles
:
function
_promiseDetectUserAgentHandles
(
)
{
return
new
Promise
(
function
(
resolve
)
{
function
resolveWithNotHandlingResponse
(
)
{
resolve
(
new
sharedActions
.
UserAgentHandlesRoom
(
{
handlesRoom
:
false
}
)
)
;
}
if
(
!
loop
.
shared
.
utils
.
isFirefox
(
navigator
.
userAgent
)
)
{
resolveWithNotHandlingResponse
(
)
;
return
;
}
var
timer
=
setTimeout
(
resolveWithNotHandlingResponse
250
)
;
var
webChannelListenerFunc
;
function
webChannelListener
(
e
)
{
if
(
e
.
detail
.
id
!
=
=
"
loop
-
link
-
clicker
"
)
{
return
;
}
clearTimeout
(
timer
)
;
window
.
removeEventListener
(
"
WebChannelMessageToContent
"
webChannelListenerFunc
)
;
resolve
(
new
sharedActions
.
UserAgentHandlesRoom
(
{
handlesRoom
:
!
!
e
.
detail
.
message
&
&
e
.
detail
.
message
.
response
}
)
)
;
}
webChannelListenerFunc
=
webChannelListener
.
bind
(
this
)
;
window
.
addEventListener
(
"
WebChannelMessageToContent
"
webChannelListenerFunc
)
;
window
.
dispatchEvent
(
new
window
.
CustomEvent
(
"
WebChannelMessageToChrome
"
{
detail
:
JSON
.
stringify
(
{
id
:
"
loop
-
link
-
clicker
"
message
:
{
command
:
"
checkWillOpenRoom
"
roomToken
:
this
.
_storeState
.
roomToken
}
}
)
}
)
)
;
}
.
bind
(
this
)
)
;
}
updateRoomInfo
:
function
updateRoomInfo
(
actionData
)
{
var
newState
=
{
roomUrl
:
actionData
.
roomUrl
}
;
Object
.
keys
(
OPTIONAL_ROOMINFO_FIELDS
)
.
forEach
(
function
(
field
)
{
if
(
actionData
[
field
]
!
=
=
undefined
)
{
newState
[
OPTIONAL_ROOMINFO_FIELDS
[
field
]
]
=
actionData
[
field
]
;
}
}
)
;
this
.
setStoreState
(
newState
)
;
}
userAgentHandlesRoom
:
function
userAgentHandlesRoom
(
actionData
)
{
this
.
setStoreState
(
{
userAgentHandlesRoom
:
actionData
.
handlesRoom
}
)
;
}
_handleRoomUpdate
:
function
_handleRoomUpdate
(
roomData
)
{
this
.
dispatchAction
(
new
sharedActions
.
UpdateRoomInfo
(
{
roomContextUrls
:
roomData
.
decryptedContext
.
urls
roomDescription
:
roomData
.
decryptedContext
.
description
participants
:
roomData
.
participants
roomName
:
roomData
.
decryptedContext
.
roomName
roomUrl
:
roomData
.
roomUrl
}
)
)
;
}
_handleRoomDelete
:
function
_handleRoomDelete
(
)
{
this
.
_sdkDriver
.
forceDisconnectAll
(
function
(
)
{
window
.
close
(
)
;
}
)
;
}
_checkDevicesAndJoinRoom
:
function
_checkDevicesAndJoinRoom
(
)
{
loop
.
shared
.
utils
.
hasAudioOrVideoDevices
(
function
(
hasDevices
)
{
if
(
hasDevices
)
{
this
.
setStoreState
(
{
roomState
:
ROOM_STATES
.
MEDIA_WAIT
}
)
;
}
else
{
this
.
dispatchAction
(
new
sharedActions
.
ConnectionFailure
(
{
reason
:
FAILURE_DETAILS
.
NO_MEDIA
}
)
)
;
}
}
.
bind
(
this
)
)
;
}
_handoffRoomJoin
:
function
_handoffRoomJoin
(
)
{
var
channelListener
;
function
handleRoomJoinResponse
(
e
)
{
if
(
e
.
detail
.
id
!
=
=
"
loop
-
link
-
clicker
"
)
{
return
;
}
window
.
removeEventListener
(
"
WebChannelMessageToContent
"
channelListener
)
;
if
(
!
e
.
detail
.
message
|
|
!
e
.
detail
.
message
.
response
)
{
console
.
error
(
"
Firefox
didn
'
t
handle
room
it
said
it
could
.
"
)
;
}
else
if
(
e
.
detail
.
message
.
alreadyOpen
)
{
this
.
dispatcher
.
dispatch
(
new
sharedActions
.
ConnectionFailure
(
{
reason
:
FAILURE_DETAILS
.
ROOM_ALREADY_OPEN
}
)
)
;
}
else
{
this
.
dispatcher
.
dispatch
(
new
sharedActions
.
JoinedRoom
(
{
apiKey
:
"
"
sessionToken
:
"
"
sessionId
:
"
"
expires
:
0
}
)
)
;
}
}
channelListener
=
handleRoomJoinResponse
.
bind
(
this
)
;
window
.
addEventListener
(
"
WebChannelMessageToContent
"
channelListener
)
;
window
.
dispatchEvent
(
new
window
.
CustomEvent
(
"
WebChannelMessageToChrome
"
{
detail
:
JSON
.
stringify
(
{
id
:
"
loop
-
link
-
clicker
"
message
:
{
command
:
"
openRoom
"
roomToken
:
this
.
_storeState
.
roomToken
}
}
)
}
)
)
;
}
joinRoom
:
function
joinRoom
(
)
{
if
(
this
.
getStoreState
(
)
.
failureReason
)
{
this
.
setStoreState
(
{
failureReason
:
undefined
}
)
;
}
if
(
this
.
_storeState
.
standalone
&
&
this
.
_storeState
.
userAgentHandlesRoom
)
{
this
.
dispatcher
.
dispatch
(
new
sharedActions
.
MetricsLogJoinRoom
(
{
userAgentHandledRoom
:
true
ownRoom
:
true
}
)
)
;
this
.
_handoffRoomJoin
(
)
;
return
;
}
this
.
dispatcher
.
dispatch
(
new
sharedActions
.
MetricsLogJoinRoom
(
{
userAgentHandledRoom
:
false
}
)
)
;
this
.
_checkDevicesAndJoinRoom
(
)
;
}
gotMediaPermission
:
function
gotMediaPermission
(
)
{
this
.
setStoreState
(
{
roomState
:
ROOM_STATES
.
JOINING
}
)
;
loop
.
request
(
"
Rooms
:
Join
"
this
.
_storeState
.
roomToken
mozL10n
.
get
(
"
display_name_guest
"
)
)
.
then
(
function
(
result
)
{
if
(
result
.
isError
)
{
this
.
dispatchAction
(
new
sharedActions
.
RoomFailure
(
{
error
:
result
failedJoinRequest
:
true
}
)
)
;
return
;
}
this
.
dispatchAction
(
new
sharedActions
.
JoinedRoom
(
{
apiKey
:
result
.
apiKey
sessionToken
:
result
.
sessionToken
sessionId
:
result
.
sessionId
expires
:
result
.
expires
}
)
)
;
}
.
bind
(
this
)
)
;
}
joinedRoom
:
function
joinedRoom
(
actionData
)
{
if
(
this
.
_storeState
.
standalone
&
&
this
.
_storeState
.
userAgentHandlesRoom
)
{
this
.
setStoreState
(
{
roomState
:
ROOM_STATES
.
JOINED
}
)
;
return
;
}
this
.
setStoreState
(
{
apiKey
:
actionData
.
apiKey
sessionToken
:
actionData
.
sessionToken
sessionId
:
actionData
.
sessionId
roomState
:
ROOM_STATES
.
JOINED
}
)
;
this
.
_setRefreshTimeout
(
actionData
.
expires
)
;
this
.
_sdkDriver
.
connectSession
(
actionData
)
;
this
.
_browserSharingListener
=
this
.
_handleSwitchBrowserShare
.
bind
(
this
)
;
loop
.
subscribe
(
"
BrowserSwitch
"
this
.
_browserSharingListener
)
;
loop
.
requestMulti
(
[
"
AddConversationContext
"
this
.
_storeState
.
windowId
actionData
.
sessionId
"
"
]
[
"
AddBrowserSharingListener
"
this
.
getStoreState
(
)
.
windowId
]
)
;
}
connectedToSdkServers
:
function
connectedToSdkServers
(
)
{
this
.
setStoreState
(
{
roomState
:
ROOM_STATES
.
SESSION_CONNECTED
}
)
;
}
connectionFailure
:
function
connectionFailure
(
actionData
)
{
var
exitState
=
this
.
_storeState
.
roomState
=
=
=
ROOM_STATES
.
FAILED
?
this
.
_storeState
.
failureExitState
:
this
.
_storeState
.
roomState
;
this
.
setStoreState
(
{
failureReason
:
actionData
.
reason
failureExitState
:
exitState
}
)
;
this
.
_leaveRoom
(
ROOM_STATES
.
FAILED
)
;
}
setMute
:
function
setMute
(
actionData
)
{
var
muteState
=
{
}
;
muteState
[
actionData
.
type
+
"
Muted
"
]
=
!
actionData
.
enabled
;
this
.
setStoreState
(
muteState
)
;
}
mediaStreamCreated
:
function
mediaStreamCreated
(
actionData
)
{
if
(
actionData
.
isLocal
)
{
this
.
setStoreState
(
{
localAudioEnabled
:
actionData
.
hasAudio
localVideoEnabled
:
actionData
.
hasVideo
localSrcMediaElement
:
actionData
.
srcMediaElement
}
)
;
return
;
}
this
.
setStoreState
(
{
remoteAudioEnabled
:
actionData
.
hasAudio
remoteVideoEnabled
:
actionData
.
hasVideo
remoteSrcMediaElement
:
actionData
.
srcMediaElement
}
)
;
if
(
this
.
_isDesktop
)
{
this
.
startBrowserShare
(
)
;
}
}
mediaStreamDestroyed
:
function
mediaStreamDestroyed
(
actionData
)
{
if
(
actionData
.
isLocal
)
{
this
.
setStoreState
(
{
localSrcMediaElement
:
null
}
)
;
return
;
}
this
.
setStoreState
(
{
remoteSrcMediaElement
:
null
}
)
;
}
remoteVideoStatus
:
function
remoteVideoStatus
(
actionData
)
{
this
.
setStoreState
(
{
remoteVideoEnabled
:
actionData
.
videoEnabled
}
)
;
}
mediaConnected
:
function
mediaConnected
(
)
{
this
.
setStoreState
(
{
mediaConnected
:
true
}
)
;
}
screenSharingState
:
function
screenSharingState
(
actionData
)
{
this
.
setStoreState
(
{
screenSharingState
:
actionData
.
state
}
)
;
loop
.
request
(
"
SetScreenShareState
"
this
.
getStoreState
(
)
.
windowId
actionData
.
state
=
=
=
SCREEN_SHARE_STATES
.
ACTIVE
)
;
}
receivingScreenShare
:
function
receivingScreenShare
(
actionData
)
{
if
(
!
actionData
.
receiving
&
&
this
.
getStoreState
(
)
.
remoteVideoDimensions
.
screen
)
{
var
newDimensions
=
_
.
extend
(
this
.
getStoreState
(
)
.
remoteVideoDimensions
)
;
delete
newDimensions
.
screen
;
this
.
setStoreState
(
{
receivingScreenShare
:
actionData
.
receiving
remoteVideoDimensions
:
newDimensions
screenShareMediaElement
:
null
}
)
;
}
else
{
this
.
setStoreState
(
{
receivingScreenShare
:
actionData
.
receiving
screenShareMediaElement
:
actionData
.
srcMediaElement
?
actionData
.
srcMediaElement
:
null
}
)
;
}
}
_handleSwitchBrowserShare
:
function
_handleSwitchBrowserShare
(
windowId
)
{
if
(
Array
.
isArray
(
windowId
)
)
{
windowId
=
windowId
[
0
]
;
}
if
(
windowId
&
&
windowId
.
isError
)
{
console
.
error
(
"
Error
getting
the
windowId
:
"
+
windowId
.
message
)
;
this
.
dispatchAction
(
new
sharedActions
.
ScreenSharingState
(
{
state
:
SCREEN_SHARE_STATES
.
INACTIVE
}
)
)
;
return
;
}
if
(
!
windowId
)
{
if
(
!
this
.
_savedWindowId
)
{
return
;
}
windowId
=
this
.
_savedWindowId
;
delete
this
.
_savedWindowId
;
}
var
screenSharingState
=
this
.
getStoreState
(
)
.
screenSharingState
;
if
(
screenSharingState
=
=
=
SCREEN_SHARE_STATES
.
INACTIVE
|
|
this
.
_storeState
.
sharingPaused
)
{
this
.
_savedWindowId
=
windowId
;
return
;
}
if
(
screenSharingState
=
=
=
SCREEN_SHARE_STATES
.
PENDING
)
{
var
options
=
{
videoSource
:
"
browser
"
constraints
:
{
browserWindow
:
windowId
scrollWithPage
:
true
}
}
;
this
.
_sdkDriver
.
startScreenShare
(
options
)
;
}
else
if
(
screenSharingState
=
=
=
SCREEN_SHARE_STATES
.
ACTIVE
)
{
this
.
_sdkDriver
.
switchAcquiredWindow
(
windowId
)
;
}
else
{
console
.
error
(
"
Unexpectedly
received
windowId
for
browser
sharing
when
pending
"
)
;
}
if
(
!
this
.
getStoreState
(
)
.
sharingPaused
&
&
this
.
_hasParticipants
(
)
)
{
this
.
_checkTabContext
(
)
;
}
}
_checkTabContext
:
function
_checkTabContext
(
)
{
loop
.
request
(
"
GetSelectedTabMetadata
"
)
.
then
(
function
(
meta
)
{
if
(
!
meta
|
|
!
meta
.
url
)
{
return
;
}
if
(
updateContextTimer
)
{
clearTimeout
(
updateContextTimer
)
;
}
updateContextTimer
=
setTimeout
(
function
(
)
{
this
.
dispatchAction
(
new
sharedActions
.
UpdateRoomContext
(
{
newRoomDescription
:
meta
.
title
|
|
meta
.
description
|
|
meta
.
url
newRoomThumbnail
:
meta
.
favicon
newRoomURL
:
meta
.
url
roomToken
:
this
.
getStoreState
(
)
.
roomToken
}
)
)
;
updateContextTimer
=
null
;
}
.
bind
(
this
)
500
)
;
}
.
bind
(
this
)
)
;
}
startBrowserShare
:
function
startBrowserShare
(
)
{
if
(
this
.
_storeState
.
screenSharingState
!
=
=
SCREEN_SHARE_STATES
.
INACTIVE
)
{
console
.
error
(
"
Attempting
to
start
browser
sharing
when
already
running
.
"
)
;
return
;
}
this
.
setStoreState
(
{
screenSharingState
:
SCREEN_SHARE_STATES
.
PENDING
}
)
;
this
.
dispatchAction
(
new
sharedActions
.
ScreenSharingState
(
{
state
:
SCREEN_SHARE_STATES
.
PENDING
}
)
)
;
this
.
_handleSwitchBrowserShare
(
)
;
}
endScreenShare
:
function
endScreenShare
(
)
{
if
(
this
.
_browserSharingListener
)
{
loop
.
request
(
"
RemoveBrowserSharingListener
"
this
.
getStoreState
(
)
.
windowId
)
;
loop
.
unsubscribe
(
"
BrowserSwitch
"
this
.
_browserSharingListener
)
;
this
.
_browserSharingListener
=
null
;
}
if
(
this
.
_sdkDriver
.
endScreenShare
(
)
)
{
this
.
dispatchAction
(
new
sharedActions
.
ScreenSharingState
(
{
state
:
SCREEN_SHARE_STATES
.
INACTIVE
}
)
)
;
}
}
toggleBrowserSharing
:
function
toggleBrowserSharing
(
actionData
)
{
this
.
setStoreState
(
{
sharingPaused
:
!
actionData
.
enabled
}
)
;
if
(
actionData
.
enabled
&
&
this
.
_storeState
.
screenSharingState
=
=
=
SCREEN_SHARE_STATES
.
PENDING
)
{
this
.
_handleSwitchBrowserShare
(
)
;
}
else
{
this
.
_sdkDriver
.
toggleBrowserSharing
(
actionData
.
enabled
)
;
}
if
(
actionData
.
enabled
)
{
this
.
_checkTabContext
(
)
;
}
}
remotePeerConnected
:
function
remotePeerConnected
(
)
{
this
.
setStoreState
(
{
remotePeerDisconnected
:
false
roomState
:
ROOM_STATES
.
HAS_PARTICIPANTS
used
:
true
}
)
;
}
remotePeerDisconnected
:
function
remotePeerDisconnected
(
)
{
var
participants
=
this
.
getStoreState
(
"
participants
"
)
;
if
(
participants
)
{
participants
=
participants
.
filter
(
function
(
participant
)
{
return
participant
.
owner
;
}
)
;
}
this
.
setStoreState
(
{
mediaConnected
:
false
participants
:
participants
roomState
:
ROOM_STATES
.
SESSION_CONNECTED
remotePeerDisconnected
:
true
remoteSrcMediaElement
:
null
streamPaused
:
false
}
)
;
}
connectionStatus
:
function
connectionStatus
(
actionData
)
{
loop
.
request
(
"
Rooms
:
SendConnectionStatus
"
this
.
getStoreState
(
"
roomToken
"
)
this
.
getStoreState
(
"
sessionToken
"
)
actionData
)
;
}
windowUnload
:
function
windowUnload
(
)
{
this
.
_leaveRoom
(
ROOM_STATES
.
CLOSING
)
;
if
(
!
this
.
_onUpdateListener
)
{
return
;
}
var
roomToken
=
this
.
getStoreState
(
)
.
roomToken
;
loop
.
unsubscribe
(
"
Rooms
:
Update
:
"
+
roomToken
this
.
_onUpdateListener
)
;
loop
.
unsubscribe
(
"
Rooms
:
Delete
:
"
+
roomToken
this
.
_onDeleteListener
)
;
loop
.
unsubscribe
(
"
SocialProvidersChanged
"
this
.
_onSocialProvidersUpdate
)
;
delete
this
.
_onUpdateListener
;
delete
this
.
_onDeleteListener
;
delete
this
.
_onShareWidgetUpdate
;
delete
this
.
_onSocialProvidersUpdate
;
}
leaveRoom
:
function
leaveRoom
(
actionData
)
{
this
.
_leaveRoom
(
ROOM_STATES
.
ENDED
false
actionData
&
&
actionData
.
windowStayingOpen
)
;
}
_setRefreshTimeout
:
function
_setRefreshTimeout
(
expireTime
)
{
this
.
_timeout
=
setTimeout
(
this
.
_refreshMembership
.
bind
(
this
)
expireTime
*
this
.
expiresTimeFactor
*
1000
)
;
}
_refreshMembership
:
function
_refreshMembership
(
)
{
loop
.
request
(
"
Rooms
:
RefreshMembership
"
this
.
_storeState
.
roomToken
this
.
_storeState
.
sessionToken
)
.
then
(
function
(
result
)
{
if
(
result
.
isError
)
{
this
.
dispatchAction
(
new
sharedActions
.
RoomFailure
(
{
error
:
result
failedJoinRequest
:
false
}
)
)
;
return
;
}
this
.
_setRefreshTimeout
(
result
.
expires
)
;
}
.
bind
(
this
)
)
;
}
_leaveRoom
:
function
_leaveRoom
(
nextState
failedJoinRequest
windowStayingOpen
)
{
if
(
this
.
_storeState
.
standalone
&
&
this
.
_storeState
.
userAgentHandlesRoom
)
{
this
.
setStoreState
(
{
roomState
:
nextState
}
)
;
return
;
}
if
(
this
.
_browserSharingListener
)
{
loop
.
unsubscribe
(
"
BrowserSwitch
"
this
.
_browserSharingListener
)
;
this
.
_browserSharingListener
=
null
;
}
this
.
_sdkDriver
.
disconnectSession
(
)
;
var
originalStoreState
=
this
.
getInitialStoreState
(
)
;
var
newStoreState
=
{
}
;
this
.
_statesToResetOnLeave
.
forEach
(
function
(
state
)
{
newStoreState
[
state
]
=
originalStoreState
[
state
]
;
}
)
;
this
.
setStoreState
(
newStoreState
)
;
if
(
this
.
_timeout
)
{
clearTimeout
(
this
.
_timeout
)
;
delete
this
.
_timeout
;
}
if
(
(
nextState
=
=
=
ROOM_STATES
.
FAILED
|
|
windowStayingOpen
|
|
!
this
.
_isDesktop
)
&
&
!
failedJoinRequest
)
{
loop
.
request
(
"
HangupNow
"
this
.
_storeState
.
roomToken
this
.
_storeState
.
sessionToken
this
.
_storeState
.
windowId
)
;
}
this
.
setStoreState
(
{
roomState
:
nextState
}
)
;
}
feedbackComplete
:
function
feedbackComplete
(
)
{
this
.
setStoreState
(
{
roomState
:
ROOM_STATES
.
READY
used
:
false
}
)
;
}
videoDimensionsChanged
:
function
videoDimensionsChanged
(
actionData
)
{
var
storeProp
=
(
actionData
.
isLocal
?
"
local
"
:
"
remote
"
)
+
"
VideoDimensions
"
;
var
nextState
=
{
}
;
nextState
[
storeProp
]
=
this
.
getStoreState
(
)
[
storeProp
]
;
nextState
[
storeProp
]
[
actionData
.
videoType
]
=
actionData
.
dimensions
;
this
.
setStoreState
(
nextState
)
;
}
videoScreenStreamChanged
:
function
videoScreenStreamChanged
(
actionData
)
{
this
.
setStoreState
(
{
streamPaused
:
!
actionData
.
hasVideo
}
)
;
}
_handleTextChatMessage
:
function
_handleTextChatMessage
(
actionData
)
{
if
(
!
this
.
_isDesktop
|
|
this
.
getStoreState
(
)
.
chatMessageExchanged
|
|
actionData
.
contentType
!
=
=
CHAT_CONTENT_TYPES
.
TEXT
)
{
return
;
}
this
.
setStoreState
(
{
chatMessageExchanged
:
true
}
)
;
this
.
dispatcher
.
unregister
(
this
[
"
receivedTextChatMessage
"
"
sendTextChatMessage
"
]
)
;
}
receivedTextChatMessage
:
function
receivedTextChatMessage
(
actionData
)
{
this
.
_handleTextChatMessage
(
actionData
)
;
}
sendTextChatMessage
:
function
sendTextChatMessage
(
actionData
)
{
this
.
_handleTextChatMessage
(
actionData
)
;
}
_hasParticipants
:
function
_hasParticipants
(
)
{
var
participants
=
this
.
getStoreState
(
"
participants
"
)
;
if
(
participants
)
{
participants
=
participants
.
filter
(
function
(
participant
)
{
return
!
participant
.
owner
;
}
)
;
return
participants
.
length
>
0
;
}
return
false
;
}
}
)
;
return
ActiveRoomStore
;
}
(
navigator
.
mozL10n
|
|
document
.
mozL10n
)
;
