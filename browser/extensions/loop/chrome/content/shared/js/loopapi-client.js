"
use
strict
"
;
var
loop
=
loop
|
|
{
}
;
(
function
(
)
{
"
use
strict
"
;
var
_slice
=
Array
.
prototype
.
slice
;
var
kMessageName
=
"
Loop
:
Message
"
;
var
kPushMessageName
=
"
Loop
:
Message
:
Push
"
;
var
kBatchMessage
=
"
Batch
"
;
var
gListeningForMessages
=
false
;
var
gListenersMap
=
{
}
;
var
gListeningForPushMessages
=
false
;
var
gSubscriptionsMap
=
{
}
;
var
gRootObj
=
window
;
loop
.
_lastMessageID
=
0
;
function
buildRequestArray
(
args
)
{
var
command
=
args
.
shift
(
)
;
command
=
command
.
charAt
(
0
)
.
toUpperCase
(
)
+
command
.
substr
(
1
)
;
var
seq
=
+
+
loop
.
_lastMessageID
;
args
.
unshift
(
seq
command
)
;
return
args
;
}
loop
.
request
=
function
request
(
)
{
var
args
=
_slice
.
call
(
arguments
)
;
return
new
Promise
(
function
(
resolve
)
{
var
payload
=
buildRequestArray
(
args
)
;
var
seq
=
payload
[
0
]
;
if
(
!
gListeningForMessages
)
{
gListeningForMessages
=
function
listener
(
message
)
{
var
replySeq
=
message
.
data
[
0
]
;
if
(
!
gListenersMap
[
replySeq
]
)
{
return
;
}
gListenersMap
[
replySeq
]
(
message
.
data
[
1
]
)
;
delete
gListenersMap
[
replySeq
]
;
}
;
gRootObj
.
addMessageListener
(
kMessageName
gListeningForMessages
)
;
}
gListenersMap
[
seq
]
=
resolve
;
gRootObj
.
sendAsyncMessage
(
kMessageName
payload
)
;
}
)
;
}
;
loop
.
request
.
inspect
=
function
(
)
{
return
_
.
extend
(
{
}
gListenersMap
)
;
}
;
loop
.
request
.
reset
=
function
(
)
{
gListeningForMessages
=
false
;
gListenersMap
=
{
}
;
}
;
loop
.
storedRequests
=
{
}
;
loop
.
storeRequest
=
function
(
request
result
)
{
loop
.
storedRequests
[
request
.
join
(
"
|
"
)
]
=
result
;
}
;
loop
.
getStoredRequest
=
function
(
request
)
{
var
key
=
request
.
join
(
"
|
"
)
;
if
(
!
(
key
in
loop
.
storedRequests
)
)
{
console
.
error
(
"
This
request
has
not
been
stored
!
"
request
)
;
return
null
;
}
return
loop
.
storedRequests
[
key
]
;
}
;
loop
.
requestMulti
=
function
requestMulti
(
)
{
if
(
!
arguments
.
length
)
{
throw
new
Error
(
"
loop
.
requestMulti
:
please
pass
in
a
list
of
calls
to
process
in
parallel
.
"
)
;
}
var
calls
=
_slice
.
call
(
arguments
)
;
calls
.
forEach
(
function
(
call
)
{
if
(
!
Array
.
isArray
(
call
)
)
{
throw
new
Error
(
"
loop
.
requestMulti
:
each
call
must
be
an
array
of
options
"
+
"
exactly
the
same
as
the
argument
signature
of
loop
.
request
(
)
"
)
;
}
buildRequestArray
(
call
)
;
}
)
;
return
new
Promise
(
function
(
resolve
)
{
loop
.
request
(
kBatchMessage
calls
)
.
then
(
function
(
resultSet
)
{
if
(
!
resultSet
)
{
resolve
(
)
;
return
;
}
var
result
=
Object
.
getOwnPropertyNames
(
resultSet
)
.
map
(
function
(
seq
)
{
return
resultSet
[
seq
]
;
}
)
;
resolve
(
result
)
;
}
)
;
}
)
;
}
;
loop
.
subscribe
=
function
subscribe
(
name
callback
)
{
if
(
!
gListeningForPushMessages
)
{
gRootObj
.
addMessageListener
(
kPushMessageName
gListeningForPushMessages
=
function
gListeningForPushMessages
(
message
)
{
var
eventName
=
message
.
data
[
0
]
;
if
(
!
gSubscriptionsMap
[
eventName
]
)
{
return
;
}
gSubscriptionsMap
[
eventName
]
.
forEach
(
function
(
cb
)
{
var
data
=
message
.
data
[
1
]
;
if
(
!
Array
.
isArray
(
data
)
)
{
data
=
[
data
]
;
}
cb
.
apply
(
null
data
)
;
}
)
;
}
)
;
}
if
(
!
gSubscriptionsMap
[
name
]
)
{
gSubscriptionsMap
[
name
]
=
[
]
;
}
gSubscriptionsMap
[
name
]
.
push
(
callback
)
;
}
;
loop
.
subscribe
.
inspect
=
function
(
)
{
return
_
.
extend
(
{
}
gSubscriptionsMap
)
;
}
;
loop
.
subscribe
.
reset
=
function
(
)
{
gListeningForPushMessages
=
false
;
gSubscriptionsMap
=
{
}
;
}
;
loop
.
unsubscribe
=
function
unsubscribe
(
name
callback
)
{
if
(
!
gSubscriptionsMap
[
name
]
)
{
return
;
}
var
idx
=
gSubscriptionsMap
[
name
]
.
indexOf
(
callback
)
;
if
(
idx
=
=
=
-
1
)
{
return
;
}
gSubscriptionsMap
[
name
]
.
splice
(
idx
1
)
;
}
;
loop
.
unsubscribeAll
=
function
unsubscribeAll
(
)
{
gSubscriptionsMap
=
{
}
;
if
(
gListeningForPushMessages
)
{
gRootObj
.
removeMessageListener
(
kPushMessageName
gListeningForPushMessages
)
;
gListeningForPushMessages
=
false
;
}
}
;
}
)
(
)
;
