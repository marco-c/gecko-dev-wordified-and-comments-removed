"
use
strict
"
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
services
-
common
/
utils
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
chrome
:
/
/
loop
/
content
/
modules
/
MozLoopService
.
jsm
"
)
;
Cu
.
import
(
"
chrome
:
/
/
loop
/
content
/
modules
/
LoopRooms
.
jsm
"
)
;
Cu
.
importGlobalProperties
(
[
"
Blob
"
]
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
NewTabURL
"
"
resource
:
/
/
/
modules
/
NewTabURL
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PageMetadata
"
"
resource
:
/
/
gre
/
modules
/
PageMetadata
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PluralForm
"
"
resource
:
/
/
gre
/
modules
/
PluralForm
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
UpdateUtils
"
"
resource
:
/
/
gre
/
modules
/
UpdateUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
UITour
"
"
resource
:
/
/
/
modules
/
UITour
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Social
"
"
resource
:
/
/
/
modules
/
Social
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Promise
"
"
resource
:
/
/
gre
/
modules
/
Promise
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
appInfo
"
function
(
)
{
return
Cc
[
"
mozilla
.
org
/
xre
/
app
-
info
;
1
"
]
.
getService
(
Ci
.
nsIXULAppInfo
)
.
QueryInterface
(
Ci
.
nsIXULRuntime
)
;
}
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
clipboardHelper
"
"
mozilla
.
org
/
widget
/
clipboardhelper
;
1
"
"
nsIClipboardHelper
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
extProtocolSvc
"
"
mozilla
.
org
/
uriloader
/
external
-
protocol
-
service
;
1
"
"
nsIExternalProtocolService
"
)
;
this
.
EXPORTED_SYMBOLS
=
[
"
LoopAPI
"
]
;
const
cloneableError
=
function
(
source
)
{
let
error
=
{
}
;
if
(
typeof
source
=
=
"
string
"
)
{
source
=
new
Error
(
source
)
;
}
let
props
=
Object
.
getOwnPropertyNames
(
source
)
;
if
(
!
props
.
length
)
{
props
.
push
(
"
message
"
"
filename
"
"
lineNumber
"
"
columnNumber
"
"
stack
"
)
;
}
for
(
let
prop
of
props
)
{
let
value
=
source
[
prop
]
;
let
type
=
typeof
value
;
if
(
type
=
=
"
function
"
|
|
type
=
=
"
undefined
"
)
{
continue
;
}
if
(
/
boolean
|
number
|
string
/
.
test
(
type
)
)
{
error
[
prop
]
=
value
;
}
else
{
error
[
prop
]
=
"
"
+
value
;
}
}
error
.
isError
=
true
;
return
error
;
}
;
const
getObjectAPIFunctionName
=
function
(
action
)
{
let
funcName
=
action
.
split
(
"
:
"
)
.
pop
(
)
;
return
funcName
.
charAt
(
0
)
.
toLowerCase
(
)
+
funcName
.
substr
(
1
)
;
}
;
const
updateSocialProvidersCache
=
function
(
)
{
let
providers
=
[
]
;
for
(
let
provider
of
Social
.
providers
)
{
if
(
!
provider
.
shareURL
)
{
continue
;
}
providers
.
push
(
{
iconURL
:
provider
.
iconURL
name
:
provider
.
name
origin
:
provider
.
origin
}
)
;
}
let
providersWasSet
=
!
!
gSocialProviders
;
gSocialProviders
=
providers
.
sort
(
(
a
b
)
=
>
a
.
name
.
toLowerCase
(
)
.
localeCompare
(
b
.
name
.
toLowerCase
(
)
)
)
;
if
(
!
providersWasSet
)
{
Services
.
obs
.
addObserver
(
updateSocialProvidersCache
"
social
:
providers
-
changed
"
false
)
;
}
else
{
LoopAPIInternal
.
broadcastPushMessage
(
"
SocialProvidersChanged
"
)
;
}
return
gSocialProviders
;
}
;
var
gAppVersionInfo
=
null
;
var
gBrowserSharingListeners
=
new
Set
(
)
;
var
gBrowserSharingWindows
=
new
Set
(
)
;
var
gPageListeners
=
null
;
var
gOriginalPageListeners
=
null
;
var
gSocialProviders
=
null
;
var
gStringBundle
=
null
;
var
gStubbedMessageHandlers
=
null
;
const
kBatchMessage
=
"
Batch
"
;
const
kMaxLoopCount
=
10
;
const
kMessageName
=
"
Loop
:
Message
"
;
const
kPushMessageName
=
"
Loop
:
Message
:
Push
"
;
const
kPushSubscription
=
"
pushSubscription
"
;
const
kRoomsPushPrefix
=
"
Rooms
:
"
;
const
kMauPrefMap
=
new
Map
(
Object
.
getOwnPropertyNames
(
LOOP_MAU_TYPE
)
.
map
(
name
=
>
{
let
parts
=
name
.
toLowerCase
(
)
.
split
(
"
_
"
)
;
return
[
LOOP_MAU_TYPE
[
name
]
parts
[
0
]
+
parts
[
1
]
.
charAt
(
0
)
.
toUpperCase
(
)
+
parts
[
1
]
.
substr
(
1
)
]
;
}
)
)
;
const
kMessageHandlers
=
{
AddBrowserSharingListener
:
function
(
message
reply
)
{
let
win
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
let
browser
=
win
&
&
win
.
gBrowser
.
selectedBrowser
;
if
(
!
win
|
|
!
browser
)
{
let
err
=
new
Error
(
"
No
tabs
available
to
share
.
"
)
;
MozLoopService
.
log
.
error
(
err
)
;
reply
(
cloneableError
(
err
)
)
;
return
;
}
let
autoStart
=
MozLoopService
.
getLoopPref
(
"
remote
.
autostart
"
)
;
if
(
!
autoStart
&
&
browser
.
getAttribute
(
"
remote
"
)
=
=
"
true
"
)
{
let
err
=
new
Error
(
"
Tab
sharing
is
not
supported
for
e10s
-
enabled
browsers
"
)
;
MozLoopService
.
log
.
error
(
err
)
;
reply
(
cloneableError
(
err
)
)
;
return
;
}
let
[
windowId
]
=
message
.
data
;
win
.
LoopUI
.
startBrowserSharing
(
)
;
NewTabURL
.
override
(
"
about
:
home
"
)
;
gBrowserSharingWindows
.
add
(
Cu
.
getWeakReference
(
win
)
)
;
gBrowserSharingListeners
.
add
(
windowId
)
;
reply
(
)
;
}
AddRemoteCursorOverlay
:
function
(
message
reply
)
{
let
win
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
if
(
win
)
{
win
.
LoopUI
.
addRemoteCursor
(
message
.
data
[
0
]
)
;
}
reply
(
)
;
}
AddConversationContext
:
function
(
message
reply
)
{
let
[
windowId
sessionId
callid
]
=
message
.
data
;
MozLoopService
.
addConversationContext
(
windowId
{
sessionId
:
sessionId
callId
:
callid
}
)
;
reply
(
)
;
}
AddSocialShareProvider
:
function
(
message
reply
)
{
let
win
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
if
(
!
win
|
|
!
win
.
SocialShare
)
{
reply
(
)
;
return
;
}
win
.
SocialShare
.
showDirectory
(
win
.
LoopUI
.
toolbarButton
.
anchor
)
;
reply
(
)
;
}
ComposeEmail
:
function
(
message
reply
)
{
let
[
subject
body
recipient
]
=
message
.
data
;
recipient
=
recipient
|
|
"
"
;
let
mailtoURL
=
"
mailto
:
"
+
encodeURIComponent
(
recipient
)
+
"
?
subject
=
"
+
encodeURIComponent
(
subject
)
+
"
&
body
=
"
+
encodeURIComponent
(
body
)
;
extProtocolSvc
.
loadURI
(
CommonUtils
.
makeURI
(
mailtoURL
)
)
;
reply
(
)
;
}
Confirm
:
function
(
message
reply
)
{
let
options
=
message
.
data
[
0
]
;
let
buttonFlags
;
if
(
options
.
okButton
&
&
options
.
cancelButton
)
{
buttonFlags
=
(
Ci
.
nsIPrompt
.
BUTTON_POS_0
*
Ci
.
nsIPrompt
.
BUTTON_TITLE_IS_STRING
)
+
(
Ci
.
nsIPrompt
.
BUTTON_POS_1
*
Ci
.
nsIPrompt
.
BUTTON_TITLE_IS_STRING
)
;
}
else
if
(
!
options
.
okButton
&
&
!
options
.
cancelButton
)
{
buttonFlags
=
Services
.
prompt
.
STD_YES_NO_BUTTONS
;
}
else
{
reply
(
cloneableError
(
"
confirm
:
missing
button
options
"
)
)
;
return
;
}
try
{
let
chosenButton
=
Services
.
prompt
.
confirmEx
(
null
"
"
options
.
message
buttonFlags
options
.
okButton
options
.
cancelButton
null
null
{
}
)
;
reply
(
chosenButton
=
=
0
)
;
}
catch
(
ex
)
{
reply
(
ex
)
;
}
}
CopyString
:
function
(
message
reply
)
{
let
str
=
message
.
data
[
0
]
;
clipboardHelper
.
copyString
(
str
)
;
reply
(
)
;
}
GenerateUUID
:
function
(
message
reply
)
{
reply
(
MozLoopService
.
generateUUID
(
)
)
;
}
GetAllStrings
:
function
(
message
reply
)
{
if
(
gStringBundle
)
{
reply
(
gStringBundle
)
;
return
;
}
let
strings
=
MozLoopService
.
getStrings
(
)
;
gStringBundle
=
{
}
;
for
(
let
[
key
value
]
of
strings
.
entries
(
)
)
{
gStringBundle
[
key
]
=
value
;
}
reply
(
gStringBundle
)
;
}
GetAllConstants
:
function
(
message
reply
)
{
reply
(
{
LOOP_SESSION_TYPE
:
LOOP_SESSION_TYPE
LOOP_MAU_TYPE
:
LOOP_MAU_TYPE
ROOM_CREATE
:
ROOM_CREATE
ROOM_DELETE
:
ROOM_DELETE
SHARING_ROOM_URL
:
SHARING_ROOM_URL
SHARING_SCREEN
:
SHARING_SCREEN
TWO_WAY_MEDIA_CONN_LENGTH
:
TWO_WAY_MEDIA_CONN_LENGTH
}
)
;
}
GetAppVersionInfo
:
function
(
message
reply
)
{
if
(
!
gAppVersionInfo
)
{
try
{
gAppVersionInfo
=
{
channel
:
UpdateUtils
.
UpdateChannel
version
:
appInfo
.
version
OS
:
appInfo
.
OS
}
;
}
catch
(
ex
)
{
}
}
reply
(
gAppVersionInfo
)
;
}
GetAudioBlob
:
function
(
message
reply
)
{
let
name
=
message
.
data
[
0
]
;
let
request
=
Cc
[
"
mozilla
.
org
/
xmlextras
/
xmlhttprequest
;
1
"
]
.
createInstance
(
Ci
.
nsIXMLHttpRequest
)
;
let
url
=
chrome
:
/
/
loop
/
content
/
shared
/
sounds
/
{
name
}
.
ogg
;
request
.
open
(
"
GET
"
url
true
)
;
request
.
responseType
=
"
arraybuffer
"
;
request
.
onload
=
(
)
=
>
{
if
(
request
.
status
<
200
|
|
request
.
status
>
=
300
)
{
reply
(
cloneableError
(
request
.
status
+
"
"
+
request
.
statusText
)
)
;
return
;
}
let
blob
=
new
Blob
(
[
request
.
response
]
{
type
:
"
audio
/
ogg
"
}
)
;
reply
(
blob
)
;
}
;
request
.
send
(
)
;
}
GetConversationWindowData
:
function
(
message
reply
)
{
reply
(
MozLoopService
.
getConversationWindowData
(
message
.
data
[
0
]
)
)
;
}
GetDoNotDisturb
:
function
(
message
reply
)
{
reply
(
MozLoopService
.
doNotDisturb
)
;
}
GetErrors
:
function
(
message
reply
)
{
let
errors
=
{
}
;
for
(
let
[
type
error
]
of
MozLoopService
.
errors
)
{
if
(
error
.
error
instanceof
Ci
.
nsIException
)
{
MozLoopService
.
log
.
debug
(
"
Warning
:
Some
errors
were
omitted
from
MozLoopAPI
.
errors
"
+
"
due
to
issues
copying
nsIException
across
boundaries
.
"
error
.
error
)
;
delete
error
.
error
;
}
errors
[
type
]
=
cloneableError
(
error
)
;
}
return
reply
(
errors
)
;
}
GetFxAEnabled
:
function
(
message
reply
)
{
reply
(
MozLoopService
.
fxAEnabled
)
;
}
GetHasEncryptionKey
:
function
(
message
reply
)
{
reply
(
MozLoopService
.
hasEncryptionKey
)
;
}
GetLocale
:
function
(
message
reply
)
{
reply
(
MozLoopService
.
locale
)
;
}
GetLoopPref
:
function
(
message
reply
)
{
let
[
prefName
prefType
]
=
message
.
data
;
reply
(
MozLoopService
.
getLoopPref
(
prefName
prefType
)
)
;
}
GetPluralRule
:
function
(
message
reply
)
{
reply
(
PluralForm
.
ruleNum
)
;
}
GetSelectedTabMetadata
:
function
(
message
reply
)
{
let
win
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
win
.
messageManager
.
addMessageListener
(
"
PageMetadata
:
PageDataResult
"
function
onPageDataResult
(
msg
)
{
win
.
messageManager
.
removeMessageListener
(
"
PageMetadata
:
PageDataResult
"
onPageDataResult
)
;
let
pageData
=
msg
.
json
;
win
.
LoopUI
.
getFavicon
(
function
(
err
favicon
)
{
if
(
err
&
&
err
!
=
=
"
favicon
not
found
for
uri
"
)
{
MozLoopService
.
log
.
error
(
"
Error
occurred
whilst
fetching
favicon
"
err
)
;
}
pageData
.
favicon
=
favicon
|
|
null
;
reply
(
pageData
)
;
}
)
;
}
)
;
win
.
gBrowser
.
selectedBrowser
.
messageManager
.
sendAsyncMessage
(
"
PageMetadata
:
GetPageData
"
)
;
}
GetSocialShareProviders
:
function
(
message
reply
)
{
if
(
!
gSocialProviders
)
{
updateSocialProvidersCache
(
)
;
}
reply
(
gSocialProviders
)
;
}
GetUserProfile
:
function
(
message
reply
)
{
if
(
!
MozLoopService
.
userProfile
)
{
reply
(
null
)
;
return
;
}
reply
(
{
email
:
MozLoopService
.
userProfile
.
email
uid
:
MozLoopService
.
userProfile
.
uid
}
)
;
}
HangupAllChatWindows
:
function
(
message
reply
)
{
MozLoopService
.
hangupAllChatWindows
(
)
;
reply
(
)
;
}
HangupNow
:
function
(
message
reply
)
{
let
[
roomToken
sessionToken
windowId
]
=
message
.
data
;
if
(
!
windowId
)
{
windowId
=
sessionToken
;
}
LoopRooms
.
leave
(
roomToken
)
;
MozLoopService
.
setScreenShareState
(
windowId
false
)
;
LoopAPI
.
sendMessageToHandler
(
{
name
:
"
RemoveBrowserSharingListener
"
data
:
[
windowId
]
}
)
;
reply
(
)
;
}
IsMultiProcessActive
:
function
(
message
reply
)
{
let
win
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
let
browser
=
win
&
&
win
.
gBrowser
.
selectedBrowser
;
reply
(
!
!
(
browser
&
&
browser
.
getAttribute
(
"
remote
"
)
=
=
"
true
"
)
)
;
}
LoginToFxA
:
function
(
message
reply
)
{
let
forceReAuth
=
message
.
data
[
0
]
;
MozLoopService
.
logInToFxA
(
forceReAuth
)
;
reply
(
)
;
}
LogoutFromFxA
:
function
(
message
reply
)
{
MozLoopService
.
logOutFromFxA
(
)
;
reply
(
)
;
}
NotifyUITour
:
function
(
message
reply
)
{
let
[
subject
params
]
=
message
.
data
;
UITour
.
notify
(
subject
params
)
;
reply
(
)
;
}
OpenGettingStartedTour
:
function
(
message
reply
)
{
MozLoopService
.
openGettingStartedTour
(
)
;
reply
(
)
;
}
GettingStartedURL
:
function
(
message
reply
)
{
let
aSrc
=
message
.
data
[
0
]
|
|
null
;
let
aAdditionalParams
=
message
.
data
[
1
]
|
|
{
}
;
reply
(
MozLoopService
.
getTourURL
(
aSrc
aAdditionalParams
)
.
href
)
;
}
OpenFxASettings
:
function
(
message
reply
)
{
MozLoopService
.
openFxASettings
(
)
;
reply
(
)
;
}
OpenNonE10sWindow
:
function
(
message
reply
)
{
let
win
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
let
url
=
message
.
data
[
0
]
?
message
.
data
[
0
]
:
"
about
:
home
"
;
win
.
openDialog
(
"
chrome
:
/
/
browser
/
content
/
"
"
_blank
"
"
chrome
all
dialog
=
no
non
-
remote
"
url
)
;
reply
(
)
;
}
OpenURL
:
function
(
message
reply
)
{
let
url
=
message
.
data
[
0
]
;
MozLoopService
.
openURL
(
url
)
;
reply
(
)
;
}
RemoveBrowserSharingListener
:
function
(
message
reply
)
{
if
(
!
gBrowserSharingListeners
.
size
)
{
reply
(
)
;
return
;
}
let
[
windowId
]
=
message
.
data
;
gBrowserSharingListeners
.
delete
(
windowId
)
;
if
(
gBrowserSharingListeners
.
size
>
0
)
{
reply
(
)
;
return
;
}
for
(
let
win
of
gBrowserSharingWindows
)
{
win
=
win
.
get
(
)
;
if
(
!
win
)
{
continue
;
}
win
.
LoopUI
.
stopBrowserSharing
(
)
;
}
NewTabURL
.
reset
(
)
;
gBrowserSharingWindows
.
clear
(
)
;
reply
(
)
;
}
"
Rooms
:
*
"
:
function
(
action
message
reply
)
{
LoopAPIInternal
.
handleObjectAPIMessage
(
LoopRooms
kRoomsPushPrefix
action
message
reply
)
;
}
SetDoNotDisturb
:
function
(
message
reply
)
{
MozLoopService
.
doNotDisturb
=
message
.
data
[
0
]
;
reply
(
)
;
}
SetLoopPref
:
function
(
message
reply
)
{
let
[
prefName
value
prefType
]
=
message
.
data
;
MozLoopService
.
setLoopPref
(
prefName
value
prefType
)
;
reply
(
)
;
}
SetScreenShareState
:
function
(
message
reply
)
{
let
[
windowId
active
]
=
message
.
data
;
MozLoopService
.
setScreenShareState
(
windowId
active
)
;
reply
(
)
;
}
SocialShareRoom
:
function
(
message
reply
)
{
let
win
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
if
(
!
win
|
|
!
win
.
SocialShare
)
{
reply
(
)
;
return
;
}
let
[
providerOrigin
roomURL
title
body
]
=
message
.
data
;
let
graphData
=
{
url
:
roomURL
title
:
title
}
;
if
(
body
)
{
graphData
.
body
=
body
;
}
win
.
SocialShare
.
sharePage
(
providerOrigin
graphData
null
win
.
LoopUI
.
toolbarButton
.
anchor
)
;
reply
(
)
;
}
TelemetryAddValue
:
function
(
message
reply
)
{
let
[
histogramId
value
]
=
message
.
data
;
if
(
histogramId
=
=
=
"
LOOP_MAU
"
)
{
let
pref
=
"
mau
.
"
+
kMauPrefMap
.
get
(
value
)
;
let
prefDate
=
MozLoopService
.
getLoopPref
(
pref
)
*
1000
;
let
delta
=
Date
.
now
(
)
-
prefDate
;
if
(
pref
=
=
=
0
|
|
delta
>
=
2592000
*
1000
)
{
try
{
Services
.
telemetry
.
getHistogramById
(
histogramId
)
.
add
(
value
)
;
}
catch
(
ex
)
{
MozLoopService
.
log
.
error
(
"
TelemetryAddValue
failed
for
histogram
'
"
+
histogramId
+
"
'
"
ex
)
;
}
MozLoopService
.
setLoopPref
(
pref
Math
.
floor
(
Date
.
now
(
)
/
1000
)
)
;
}
}
else
{
try
{
Services
.
telemetry
.
getHistogramById
(
histogramId
)
.
add
(
value
)
;
}
catch
(
ex
)
{
MozLoopService
.
log
.
error
(
"
TelemetryAddValue
failed
for
histogram
'
"
+
histogramId
+
"
'
"
ex
)
;
}
}
reply
(
)
;
}
}
;
const
LoopAPIInternal
=
{
initialize
:
function
(
)
{
if
(
gPageListeners
)
{
return
;
}
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
RemotePageManager
.
jsm
"
)
;
gPageListeners
=
[
new
RemotePages
(
"
about
:
looppanel
"
)
new
RemotePages
(
"
about
:
loopconversation
"
)
new
RemotePages
(
"
chrome
:
/
/
loop
/
content
/
panels
/
slideshow
.
html
"
)
]
;
for
(
let
page
of
gPageListeners
)
{
page
.
addMessageListener
(
kMessageName
this
.
handleMessage
.
bind
(
this
)
)
;
}
Services
.
obs
.
addObserver
(
this
.
handleStatusChanged
"
loop
-
status
-
changed
"
false
)
;
}
handleMessage
:
function
(
message
reply
)
{
let
seq
=
message
.
data
.
shift
(
)
;
let
action
=
message
.
data
.
shift
(
)
;
let
actionParts
=
action
.
split
(
"
:
"
)
;
let
handlerName
=
actionParts
.
shift
(
)
;
if
(
!
reply
)
{
reply
=
result
=
>
{
try
{
message
.
target
.
sendAsyncMessage
(
message
.
name
[
seq
result
]
)
;
}
catch
(
ex
)
{
MozLoopService
.
log
.
error
(
"
Failed
to
send
reply
back
to
content
:
"
ex
)
;
}
}
;
}
if
(
handlerName
=
=
kBatchMessage
)
{
this
.
handleBatchMessage
(
seq
message
reply
)
;
return
;
}
let
wildcardName
=
handlerName
+
"
:
*
"
;
if
(
kMessageHandlers
[
wildcardName
]
)
{
if
(
gStubbedMessageHandlers
&
&
gStubbedMessageHandlers
[
wildcardName
]
)
{
gStubbedMessageHandlers
[
wildcardName
]
(
action
message
reply
)
;
}
else
{
kMessageHandlers
[
wildcardName
]
(
action
message
reply
)
;
}
return
;
}
if
(
gStubbedMessageHandlers
&
&
gStubbedMessageHandlers
[
handlerName
]
)
{
gStubbedMessageHandlers
[
handlerName
]
(
message
reply
)
;
return
;
}
if
(
!
kMessageHandlers
[
handlerName
]
)
{
let
msg
=
"
Ouch
no
message
handler
available
for
'
"
+
handlerName
+
"
'
"
;
MozLoopService
.
log
.
error
(
msg
)
;
reply
(
cloneableError
(
msg
)
)
;
return
;
}
kMessageHandlers
[
handlerName
]
(
message
reply
)
;
}
handleBatchMessage
:
function
(
seq
message
reply
)
{
let
requests
=
message
.
data
[
0
]
;
if
(
!
requests
.
length
)
{
MozLoopService
.
log
.
error
(
"
Ough
a
batch
call
with
no
requests
is
not
much
"
+
"
of
a
batch
now
is
it
?
"
)
;
return
;
}
if
(
!
(
"
loopCount
"
in
reply
)
)
{
reply
.
loopCount
=
0
;
}
else
if
(
+
+
reply
.
loopCount
>
kMaxLoopCount
)
{
reply
(
cloneableError
(
"
Too
many
nested
calls
"
)
)
;
return
;
}
let
resultSet
=
{
}
;
Promise
.
all
(
requests
.
map
(
requestSet
=
>
{
let
requestSeq
=
requestSet
[
0
]
;
return
new
Promise
(
resolve
=
>
this
.
handleMessage
(
{
data
:
requestSet
}
result
=
>
{
resultSet
[
requestSeq
]
=
result
;
resolve
(
)
;
}
)
)
;
}
)
)
.
then
(
(
)
=
>
reply
(
resultSet
)
)
;
}
handleObjectAPIMessage
:
function
(
api
pushMessagePrefix
action
message
reply
)
{
let
funcName
=
getObjectAPIFunctionName
(
action
)
;
if
(
funcName
=
=
kPushSubscription
)
{
let
events
=
message
.
data
[
0
]
;
if
(
!
events
|
|
!
events
.
length
)
{
let
msg
=
"
Oops
don
'
t
forget
to
pass
in
event
names
when
you
try
to
"
+
"
subscribe
to
them
!
"
;
MozLoopService
.
log
.
error
(
msg
)
;
reply
(
cloneableError
(
msg
)
)
;
return
;
}
let
handlerFunc
=
(
e
.
.
.
data
)
=
>
{
let
prettyEventName
=
e
.
charAt
(
0
)
.
toUpperCase
(
)
+
e
.
substr
(
1
)
;
try
{
message
.
target
.
sendAsyncMessage
(
kPushMessageName
[
pushMessagePrefix
+
prettyEventName
data
]
)
;
}
catch
(
ex
)
{
MozLoopService
.
log
.
debug
(
"
Unable
to
send
event
through
to
target
:
"
+
ex
.
message
)
;
for
(
let
eventName
of
events
)
{
api
.
off
(
eventName
handlerFunc
)
;
}
}
}
;
for
(
let
eventName
of
events
)
{
api
.
on
(
eventName
handlerFunc
)
;
}
reply
(
)
;
return
;
}
if
(
typeof
api
[
funcName
]
!
=
"
function
"
)
{
reply
(
cloneableError
(
"
Sorry
function
'
"
+
funcName
+
"
'
does
not
exist
!
"
)
)
;
return
;
}
api
[
funcName
]
(
.
.
.
message
.
data
(
err
result
)
=
>
{
reply
(
err
?
cloneableError
(
err
)
:
result
)
;
}
)
;
}
handleStatusChanged
:
function
(
)
{
LoopAPIInternal
.
broadcastPushMessage
(
"
LoopStatusChanged
"
)
;
}
broadcastPushMessage
:
function
(
name
data
)
{
if
(
!
gPageListeners
)
{
return
;
}
for
(
let
page
of
gPageListeners
)
{
try
{
page
.
sendAsyncMessage
(
kPushMessageName
[
name
data
]
)
;
}
catch
(
ex
)
{
if
(
ex
.
result
!
=
Components
.
results
.
NS_ERROR_NOT_INITIALIZED
)
{
throw
ex
;
}
}
}
}
destroy
:
function
(
)
{
if
(
!
gPageListeners
)
{
return
;
}
for
(
let
listener
of
gPageListeners
)
{
listener
.
destroy
(
)
;
}
gPageListeners
=
null
;
Services
.
obs
.
removeObserver
(
this
.
handleStatusChanged
"
loop
-
status
-
changed
"
)
;
if
(
gSocialProviders
)
{
Services
.
obs
.
removeObserver
(
updateSocialProvidersCache
"
social
:
providers
-
changed
"
)
;
}
}
}
;
this
.
LoopAPI
=
Object
.
freeze
(
{
initialize
:
function
(
)
{
LoopAPIInternal
.
initialize
(
)
;
}
broadcastPushMessage
:
function
(
name
data
)
{
LoopAPIInternal
.
broadcastPushMessage
(
name
data
)
;
}
destroy
:
function
(
)
{
LoopAPIInternal
.
destroy
(
)
;
}
sendMessageToHandler
:
function
(
message
reply
)
{
reply
=
reply
|
|
function
(
)
{
}
;
let
handlerName
=
message
.
name
;
let
handler
=
kMessageHandlers
[
handlerName
]
;
if
(
gStubbedMessageHandlers
&
&
gStubbedMessageHandlers
[
handlerName
]
)
{
handler
=
gStubbedMessageHandlers
[
handlerName
]
;
}
if
(
!
handler
)
{
let
msg
=
"
Ouch
no
message
handler
available
for
'
"
+
handlerName
+
"
'
"
;
MozLoopService
.
log
.
error
(
msg
)
;
reply
(
cloneableError
(
msg
)
)
;
return
;
}
if
(
!
message
.
data
)
{
message
.
data
=
[
]
;
}
if
(
handlerName
.
endsWith
(
"
*
"
)
)
{
handler
(
message
.
action
message
reply
)
;
}
else
{
handler
(
message
reply
)
;
}
}
inspect
:
function
(
)
{
return
[
Object
.
create
(
LoopAPIInternal
)
Object
.
create
(
kMessageHandlers
)
gPageListeners
?
[
.
.
.
gPageListeners
]
:
null
]
;
}
stub
:
function
(
pageListeners
)
{
if
(
!
gOriginalPageListeners
)
{
gOriginalPageListeners
=
gPageListeners
;
}
gPageListeners
=
pageListeners
;
}
stubMessageHandlers
:
function
(
handlers
)
{
gStubbedMessageHandlers
=
handlers
;
}
restore
:
function
(
)
{
if
(
gOriginalPageListeners
)
{
gPageListeners
=
gOriginalPageListeners
;
}
gStubbedMessageHandlers
=
null
;
}
}
)
;
