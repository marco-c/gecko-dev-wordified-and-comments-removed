"
use
strict
"
;
var
_slicedToArray
=
function
(
)
{
function
sliceIterator
(
arr
i
)
{
var
_arr
=
[
]
;
var
_n
=
true
;
var
_d
=
false
;
var
_e
=
undefined
;
try
{
for
(
var
_i
=
arr
[
Symbol
.
iterator
]
(
)
_s
;
!
(
_n
=
(
_s
=
_i
.
next
(
)
)
.
done
)
;
_n
=
true
)
{
_arr
.
push
(
_s
.
value
)
;
if
(
i
&
&
_arr
.
length
=
=
=
i
)
break
;
}
}
catch
(
err
)
{
_d
=
true
;
_e
=
err
;
}
finally
{
try
{
if
(
!
_n
&
&
_i
[
"
return
"
]
)
_i
[
"
return
"
]
(
)
;
}
finally
{
if
(
_d
)
throw
_e
;
}
}
return
_arr
;
}
return
function
(
arr
i
)
{
if
(
Array
.
isArray
(
arr
)
)
{
return
arr
;
}
else
if
(
Symbol
.
iterator
in
Object
(
arr
)
)
{
return
sliceIterator
(
arr
i
)
;
}
else
{
throw
new
TypeError
(
"
Invalid
attempt
to
destructure
non
-
iterable
instance
"
)
;
}
}
;
}
(
)
;
function
_toConsumableArray
(
arr
)
{
if
(
Array
.
isArray
(
arr
)
)
{
for
(
var
i
=
0
arr2
=
Array
(
arr
.
length
)
;
i
<
arr
.
length
;
i
+
+
)
{
arr2
[
i
]
=
arr
[
i
]
;
}
return
arr2
;
}
else
{
return
Array
.
from
(
arr
)
;
}
}
var
_Components
=
Components
;
var
Cu
=
_Components
.
utils
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
var
_Cu
import
=
Cu
.
import
(
"
chrome
:
/
/
loop
/
content
/
modules
/
MozLoopService
.
jsm
"
{
}
)
;
var
MozLoopService
=
_Cu
import
.
MozLoopService
;
var
LOOP_SESSION_TYPE
=
_Cu
import
.
LOOP_SESSION_TYPE
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Promise
"
"
resource
:
/
/
gre
/
modules
/
Promise
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
CommonUtils
"
"
resource
:
/
/
services
-
common
/
utils
.
js
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
WebChannel
"
"
resource
:
/
/
gre
/
modules
/
WebChannel
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
eventEmitter
"
function
(
)
{
var
_Cu
import2
=
Cu
.
import
(
"
resource
:
/
/
devtools
/
shared
/
event
-
emitter
.
js
"
{
}
)
;
var
EventEmitter
=
_Cu
import2
.
EventEmitter
;
return
new
EventEmitter
(
)
;
}
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
DomainWhitelist
"
"
chrome
:
/
/
loop
/
content
/
modules
/
DomainWhitelist
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
LoopRoomsCache
"
"
chrome
:
/
/
loop
/
content
/
modules
/
LoopRoomsCache
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
loopUtils
"
"
chrome
:
/
/
loop
/
content
/
modules
/
utils
.
js
"
"
utils
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
loopCrypto
"
"
chrome
:
/
/
loop
/
content
/
shared
/
js
/
crypto
.
js
"
"
LoopCrypto
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
ObjectUtils
"
"
resource
:
/
/
gre
/
modules
/
ObjectUtils
.
jsm
"
)
;
this
.
EXPORTED_SYMBOLS
=
[
"
LoopRooms
"
"
roomsPushNotification
"
]
;
var
CLIENT_MAX_SIZE
=
2
;
var
MIN_TIME_BEFORE_ENCRYPTION
=
5
*
1000
;
var
MAX_TIME_BEFORE_ENCRYPTION
=
30
*
60
*
1000
;
var
TIME_BETWEEN_ENCRYPTIONS
=
1000
;
var
LINKCLICKER_URL_PREFNAME
=
"
loop
.
linkClicker
.
url
"
;
var
roomsPushNotification
=
function
roomsPushNotification
(
version
channelID
)
{
return
LoopRoomsInternal
.
onNotification
(
version
channelID
)
;
}
;
var
gDirty
=
true
;
var
gCurrentUser
=
null
;
var
gRoomsCache
=
null
;
var
gLinkClickerChannel
=
null
;
var
gGetAllPromise
=
null
;
var
extend
=
function
extend
(
target
source
)
{
var
_iteratorNormalCompletion
=
true
;
var
_didIteratorError
=
false
;
var
_iteratorError
=
undefined
;
try
{
for
(
var
_iterator
=
Object
.
getOwnPropertyNames
(
source
)
[
Symbol
.
iterator
]
(
)
_step
;
!
(
_iteratorNormalCompletion
=
(
_step
=
_iterator
.
next
(
)
)
.
done
)
;
_iteratorNormalCompletion
=
true
)
{
var
key
=
_step
.
value
;
target
[
key
]
=
source
[
key
]
;
}
}
catch
(
err
)
{
_didIteratorError
=
true
;
_iteratorError
=
err
;
}
finally
{
try
{
if
(
!
_iteratorNormalCompletion
&
&
_iterator
.
return
)
{
_iterator
.
return
(
)
;
}
}
finally
{
if
(
_didIteratorError
)
{
throw
_iteratorError
;
}
}
}
return
target
;
}
;
var
containsParticipant
=
function
containsParticipant
(
room
participant
)
{
var
_iteratorNormalCompletion2
=
true
;
var
_didIteratorError2
=
false
;
var
_iteratorError2
=
undefined
;
try
{
for
(
var
_iterator2
=
room
.
participants
[
Symbol
.
iterator
]
(
)
_step2
;
!
(
_iteratorNormalCompletion2
=
(
_step2
=
_iterator2
.
next
(
)
)
.
done
)
;
_iteratorNormalCompletion2
=
true
)
{
var
user
=
_step2
.
value
;
if
(
user
.
roomConnectionId
=
=
participant
.
roomConnectionId
)
{
return
true
;
}
}
}
catch
(
err
)
{
_didIteratorError2
=
true
;
_iteratorError2
=
err
;
}
finally
{
try
{
if
(
!
_iteratorNormalCompletion2
&
&
_iterator2
.
return
)
{
_iterator2
.
return
(
)
;
}
}
finally
{
if
(
_didIteratorError2
)
{
throw
_iteratorError2
;
}
}
}
return
false
;
}
;
var
checkForParticipantsUpdate
=
function
checkForParticipantsUpdate
(
room
updatedRoom
)
{
if
(
!
(
"
participants
"
in
room
)
)
{
return
;
}
var
participant
=
void
0
;
var
_iteratorNormalCompletion3
=
true
;
var
_didIteratorError3
=
false
;
var
_iteratorError3
=
undefined
;
try
{
for
(
var
_iterator3
=
updatedRoom
.
participants
[
Symbol
.
iterator
]
(
)
_step3
;
!
(
_iteratorNormalCompletion3
=
(
_step3
=
_iterator3
.
next
(
)
)
.
done
)
;
_iteratorNormalCompletion3
=
true
)
{
participant
=
_step3
.
value
;
if
(
!
containsParticipant
(
room
participant
)
)
{
eventEmitter
.
emit
(
"
joined
"
room
participant
)
;
eventEmitter
.
emit
(
"
joined
:
"
+
room
.
roomToken
participant
)
;
}
}
}
catch
(
err
)
{
_didIteratorError3
=
true
;
_iteratorError3
=
err
;
}
finally
{
try
{
if
(
!
_iteratorNormalCompletion3
&
&
_iterator3
.
return
)
{
_iterator3
.
return
(
)
;
}
}
finally
{
if
(
_didIteratorError3
)
{
throw
_iteratorError3
;
}
}
}
var
_iteratorNormalCompletion4
=
true
;
var
_didIteratorError4
=
false
;
var
_iteratorError4
=
undefined
;
try
{
for
(
var
_iterator4
=
room
.
participants
[
Symbol
.
iterator
]
(
)
_step4
;
!
(
_iteratorNormalCompletion4
=
(
_step4
=
_iterator4
.
next
(
)
)
.
done
)
;
_iteratorNormalCompletion4
=
true
)
{
participant
=
_step4
.
value
;
if
(
!
containsParticipant
(
updatedRoom
participant
)
)
{
eventEmitter
.
emit
(
"
left
"
room
participant
)
;
eventEmitter
.
emit
(
"
left
:
"
+
room
.
roomToken
participant
)
;
}
}
}
catch
(
err
)
{
_didIteratorError4
=
true
;
_iteratorError4
=
err
;
}
finally
{
try
{
if
(
!
_iteratorNormalCompletion4
&
&
_iterator4
.
return
)
{
_iterator4
.
return
(
)
;
}
}
finally
{
if
(
_didIteratorError4
)
{
throw
_iteratorError4
;
}
}
}
}
;
var
timerHandlers
=
{
startTimer
:
function
startTimer
(
callback
delay
)
{
return
setTimeout
(
callback
delay
)
;
}
}
;
var
LoopRoomsInternal
=
{
rooms
:
new
Map
(
)
get
roomsCache
(
)
{
if
(
!
gRoomsCache
)
{
gRoomsCache
=
new
LoopRoomsCache
(
)
;
}
return
gRoomsCache
;
}
encryptionQueue
:
{
queue
:
[
]
timer
:
null
reset
:
function
reset
(
)
{
this
.
queue
=
[
]
;
this
.
timer
=
null
;
}
}
init
:
function
init
(
)
{
Services
.
prefs
.
addObserver
(
LINKCLICKER_URL_PREFNAME
this
.
setupLinkClickerListener
.
bind
(
this
)
false
)
;
this
.
setupLinkClickerListener
(
)
;
}
setupLinkClickerListener
:
function
setupLinkClickerListener
(
)
{
if
(
gLinkClickerChannel
)
{
gLinkClickerChannel
.
stopListening
(
)
;
gLinkClickerChannel
=
null
;
}
var
linkClickerUrl
=
Services
.
prefs
.
getCharPref
(
LINKCLICKER_URL_PREFNAME
)
;
if
(
!
linkClickerUrl
)
{
return
;
}
var
uri
=
Services
.
io
.
newURI
(
linkClickerUrl
null
null
)
;
gLinkClickerChannel
=
new
WebChannel
(
"
loop
-
link
-
clicker
"
uri
)
;
gLinkClickerChannel
.
listen
(
this
.
_handleLinkClickerMessage
.
bind
(
this
)
)
;
}
get
sessionType
(
)
{
return
MozLoopService
.
userProfile
?
LOOP_SESSION_TYPE
.
FXA
:
LOOP_SESSION_TYPE
.
GUEST
;
}
get
participantsCount
(
)
{
var
count
=
0
;
var
_iteratorNormalCompletion5
=
true
;
var
_didIteratorError5
=
false
;
var
_iteratorError5
=
undefined
;
try
{
for
(
var
_iterator5
=
this
.
rooms
.
values
(
)
[
Symbol
.
iterator
]
(
)
_step5
;
!
(
_iteratorNormalCompletion5
=
(
_step5
=
_iterator5
.
next
(
)
)
.
done
)
;
_iteratorNormalCompletion5
=
true
)
{
var
room
=
_step5
.
value
;
if
(
room
.
deleted
|
|
!
(
"
participants
"
in
room
)
)
{
continue
;
}
count
+
=
room
.
participants
.
length
;
}
}
catch
(
err
)
{
_didIteratorError5
=
true
;
_iteratorError5
=
err
;
}
finally
{
try
{
if
(
!
_iteratorNormalCompletion5
&
&
_iterator5
.
return
)
{
_iterator5
.
return
(
)
;
}
}
finally
{
if
(
_didIteratorError5
)
{
throw
_iteratorError5
;
}
}
}
return
count
;
}
processEncryptionQueue
:
Task
.
async
(
function
*
(
)
{
var
roomToken
=
this
.
encryptionQueue
.
queue
.
shift
(
)
;
var
roomData
=
this
.
rooms
.
get
(
roomToken
)
;
if
(
roomData
)
{
try
{
yield
LoopRooms
.
promise
(
"
update
"
roomToken
{
}
)
;
}
catch
(
error
)
{
MozLoopService
.
log
.
error
(
"
Upgrade
encryption
of
room
failed
"
error
)
;
}
}
if
(
this
.
encryptionQueue
.
queue
.
length
)
{
this
.
encryptionQueue
.
timer
=
timerHandlers
.
startTimer
(
this
.
processEncryptionQueue
.
bind
(
this
)
TIME_BETWEEN_ENCRYPTIONS
)
;
}
else
{
this
.
encryptionQueue
.
timer
=
null
;
}
}
)
queueForEncryption
:
function
queueForEncryption
(
roomToken
)
{
if
(
this
.
encryptionQueue
.
queue
.
indexOf
(
roomToken
)
=
=
-
1
)
{
this
.
encryptionQueue
.
queue
.
push
(
roomToken
)
;
}
if
(
!
this
.
encryptionQueue
.
timer
)
{
var
waitTime
=
(
MAX_TIME_BEFORE_ENCRYPTION
-
MIN_TIME_BEFORE_ENCRYPTION
)
*
Math
.
random
(
)
+
MIN_TIME_BEFORE_ENCRYPTION
;
this
.
encryptionQueue
.
timer
=
timerHandlers
.
startTimer
(
this
.
processEncryptionQueue
.
bind
(
this
)
waitTime
)
;
}
}
promiseGetOrCreateRoomKey
:
Task
.
async
(
function
*
(
roomData
)
{
if
(
roomData
.
roomKey
)
{
return
roomData
.
roomKey
;
}
return
yield
loopCrypto
.
generateKey
(
)
;
}
)
promiseEncryptedRoomKey
:
Task
.
async
(
function
*
(
key
)
{
var
profileKey
=
yield
MozLoopService
.
promiseProfileEncryptionKey
(
)
;
var
encryptedRoomKey
=
yield
loopCrypto
.
encryptBytes
(
profileKey
key
)
;
return
encryptedRoomKey
;
}
)
promiseDecryptRoomKey
:
Task
.
async
(
function
*
(
encryptedKey
)
{
var
profileKey
=
yield
MozLoopService
.
promiseProfileEncryptionKey
(
)
;
var
decryptedRoomKey
=
yield
loopCrypto
.
decryptBytes
(
profileKey
encryptedKey
)
;
return
decryptedRoomKey
;
}
)
refreshRoomUrlWithNewKey
:
function
refreshRoomUrlWithNewKey
(
roomUrl
roomKey
)
{
roomUrl
=
roomUrl
.
split
(
"
#
"
)
[
0
]
;
return
roomUrl
+
"
#
"
+
roomKey
;
}
promiseEncryptRoomData
:
Task
.
async
(
function
*
(
roomData
)
{
var
newRoomData
=
extend
(
{
}
roomData
)
;
if
(
!
newRoomData
.
context
)
{
newRoomData
.
context
=
{
}
;
}
var
key
=
yield
this
.
promiseGetOrCreateRoomKey
(
newRoomData
)
;
newRoomData
.
context
.
wrappedKey
=
yield
this
.
promiseEncryptedRoomKey
(
key
)
;
newRoomData
.
context
.
value
=
yield
loopCrypto
.
encryptBytes
(
key
JSON
.
stringify
(
newRoomData
.
decryptedContext
)
)
;
newRoomData
.
context
.
alg
=
"
AES
-
GCM
"
;
newRoomData
.
roomKey
=
key
;
var
serverRoomData
=
extend
(
{
}
newRoomData
)
;
delete
serverRoomData
.
decryptedContext
;
delete
serverRoomData
.
roomKey
;
return
{
encrypted
:
serverRoomData
all
:
newRoomData
}
;
}
)
promiseDecryptRoomData
:
Task
.
async
(
function
*
(
roomData
)
{
if
(
!
roomData
.
context
)
{
return
roomData
;
}
if
(
!
roomData
.
context
.
wrappedKey
)
{
throw
new
Error
(
"
Missing
wrappedKey
"
)
;
}
var
savedRoomKey
=
yield
this
.
roomsCache
.
getKey
(
this
.
sessionType
roomData
.
roomToken
)
;
var
fallback
=
false
;
var
key
=
void
0
;
try
{
key
=
yield
this
.
promiseDecryptRoomKey
(
roomData
.
context
.
wrappedKey
)
;
}
catch
(
error
)
{
if
(
!
savedRoomKey
)
{
throw
error
;
}
key
=
savedRoomKey
;
fallback
=
true
;
}
var
decryptedData
=
yield
loopCrypto
.
decryptBytes
(
key
roomData
.
context
.
value
)
;
if
(
fallback
)
{
MozLoopService
.
log
.
debug
(
"
Fell
back
to
saved
key
queuing
for
encryption
"
roomData
.
roomToken
)
;
this
.
queueForEncryption
(
roomData
.
roomToken
)
;
}
else
if
(
!
savedRoomKey
|
|
key
!
=
savedRoomKey
)
{
try
{
yield
this
.
roomsCache
.
setKey
(
this
.
sessionType
roomData
.
roomToken
key
)
;
}
catch
(
error
)
{
MozLoopService
.
log
.
error
(
"
Failed
to
save
room
key
:
"
error
)
;
}
}
roomData
.
roomKey
=
key
;
roomData
.
decryptedContext
=
JSON
.
parse
(
decryptedData
)
;
roomData
.
roomUrl
=
this
.
refreshRoomUrlWithNewKey
(
roomData
.
roomUrl
roomData
.
roomKey
)
;
return
roomData
;
}
)
saveAndNotifyUpdate
:
function
saveAndNotifyUpdate
(
roomData
isUpdate
)
{
this
.
rooms
.
set
(
roomData
.
roomToken
roomData
)
;
var
eventName
=
isUpdate
?
"
update
"
:
"
add
"
;
eventEmitter
.
emit
(
eventName
roomData
)
;
eventEmitter
.
emit
(
eventName
+
"
:
"
+
roomData
.
roomToken
roomData
)
;
}
addOrUpdateRoom
:
Task
.
async
(
function
*
(
room
isUpdate
)
{
if
(
!
room
.
context
)
{
room
.
decryptedContext
=
{
roomName
:
room
.
roomName
}
;
delete
room
.
roomName
;
this
.
queueForEncryption
(
room
.
roomToken
)
;
this
.
saveAndNotifyUpdate
(
room
isUpdate
)
;
}
else
{
try
{
var
roomData
=
yield
this
.
promiseDecryptRoomData
(
room
)
;
this
.
saveAndNotifyUpdate
(
roomData
isUpdate
)
;
}
catch
(
error
)
{
MozLoopService
.
log
.
error
(
"
Failed
to
decrypt
room
data
:
"
error
)
;
room
.
decryptedContext
=
{
}
;
this
.
saveAndNotifyUpdate
(
room
isUpdate
)
;
}
}
}
)
getAll
:
function
getAll
(
version
)
{
if
(
gGetAllPromise
&
&
!
version
)
{
return
gGetAllPromise
;
}
if
(
!
gDirty
)
{
return
Promise
.
resolve
(
[
]
.
concat
(
_toConsumableArray
(
this
.
rooms
.
values
(
)
)
)
)
;
}
gGetAllPromise
=
Task
.
spawn
(
function
*
(
)
{
var
url
=
"
/
rooms
"
+
(
version
?
"
?
version
=
"
+
encodeURIComponent
(
version
)
:
"
"
)
;
var
response
=
yield
MozLoopService
.
hawkRequest
(
this
.
sessionType
url
"
GET
"
)
;
var
roomsList
=
JSON
.
parse
(
response
.
body
)
;
if
(
!
Array
.
isArray
(
roomsList
)
)
{
throw
new
Error
(
"
Missing
array
of
rooms
in
response
.
"
)
;
}
var
_iteratorNormalCompletion6
=
true
;
var
_didIteratorError6
=
false
;
var
_iteratorError6
=
undefined
;
try
{
for
(
var
_iterator6
=
roomsList
[
Symbol
.
iterator
]
(
)
_step6
;
!
(
_iteratorNormalCompletion6
=
(
_step6
=
_iterator6
.
next
(
)
)
.
done
)
;
_iteratorNormalCompletion6
=
true
)
{
var
room
=
_step6
.
value
;
var
orig
=
this
.
rooms
.
get
(
room
.
roomToken
)
;
if
(
room
.
deleted
)
{
if
(
orig
)
{
this
.
rooms
.
delete
(
room
.
roomToken
)
;
}
eventEmitter
.
emit
(
"
delete
"
room
)
;
eventEmitter
.
emit
(
"
delete
:
"
+
room
.
roomToken
room
)
;
}
else
{
yield
this
.
addOrUpdateRoom
(
room
!
!
orig
)
;
if
(
orig
)
{
checkForParticipantsUpdate
(
orig
room
)
;
}
}
}
}
catch
(
err
)
{
_didIteratorError6
=
true
;
_iteratorError6
=
err
;
}
finally
{
try
{
if
(
!
_iteratorNormalCompletion6
&
&
_iterator6
.
return
)
{
_iterator6
.
return
(
)
;
}
}
finally
{
if
(
_didIteratorError6
)
{
throw
_iteratorError6
;
}
}
}
if
(
this
.
sessionType
=
=
LOOP_SESSION_TYPE
.
GUEST
&
&
!
this
.
rooms
.
size
)
{
this
.
setGuestCreatedRoom
(
false
)
;
}
gDirty
=
false
;
gGetAllPromise
=
null
;
return
[
]
.
concat
(
_toConsumableArray
(
this
.
rooms
.
values
(
)
)
)
;
}
.
bind
(
this
)
)
.
catch
(
function
(
error
)
{
gGetAllPromise
=
null
;
throw
error
;
}
)
;
return
gGetAllPromise
;
}
getNumParticipants
:
function
getNumParticipants
(
roomToken
)
{
try
{
if
(
this
.
rooms
&
&
this
.
rooms
.
has
(
roomToken
)
)
{
return
this
.
rooms
.
get
(
roomToken
)
.
participants
.
length
;
}
return
0
;
}
catch
(
ex
)
{
MozLoopService
.
log
.
error
(
"
No
room
found
in
current
session
:
"
ex
)
;
return
0
;
}
}
get
:
function
get
(
roomToken
callback
)
{
var
room
=
this
.
rooms
.
has
(
roomToken
)
?
this
.
rooms
.
get
(
roomToken
)
:
{
}
;
var
needsUpdate
=
!
(
"
participants
"
in
room
)
;
if
(
!
gDirty
&
&
!
needsUpdate
)
{
callback
(
null
room
)
;
return
;
}
Task
.
spawn
(
function
*
(
)
{
var
response
=
yield
MozLoopService
.
hawkRequest
(
this
.
sessionType
"
/
rooms
/
"
+
encodeURIComponent
(
roomToken
)
"
GET
"
)
;
var
data
=
JSON
.
parse
(
response
.
body
)
;
room
.
roomToken
=
roomToken
;
if
(
data
.
deleted
)
{
this
.
rooms
.
delete
(
room
.
roomToken
)
;
extend
(
room
data
)
;
eventEmitter
.
emit
(
"
delete
"
room
)
;
eventEmitter
.
emit
(
"
delete
:
"
+
room
.
roomToken
room
)
;
}
else
{
yield
this
.
addOrUpdateRoom
(
data
!
needsUpdate
)
;
checkForParticipantsUpdate
(
room
data
)
;
}
callback
(
null
room
)
;
}
.
bind
(
this
)
)
.
catch
(
callback
)
;
}
create
:
function
create
(
room
callback
)
{
if
(
!
(
"
decryptedContext
"
in
room
)
|
|
!
(
"
maxSize
"
in
room
)
)
{
callback
(
new
Error
(
"
Missing
required
property
to
create
a
room
"
)
)
;
return
;
}
if
(
!
(
"
roomOwner
"
in
room
)
)
{
room
.
roomOwner
=
"
-
"
;
}
Task
.
spawn
(
function
*
(
)
{
var
_ref
=
yield
this
.
promiseEncryptRoomData
(
room
)
;
var
all
=
_ref
.
all
;
var
encrypted
=
_ref
.
encrypted
;
room
=
all
;
var
response
=
yield
MozLoopService
.
hawkRequest
(
this
.
sessionType
"
/
rooms
"
"
POST
"
encrypted
)
;
extend
(
room
JSON
.
parse
(
response
.
body
)
)
;
delete
room
.
expiresIn
;
room
.
roomUrl
=
this
.
refreshRoomUrlWithNewKey
(
room
.
roomUrl
room
.
roomKey
)
;
this
.
rooms
.
set
(
room
.
roomToken
room
)
;
if
(
this
.
sessionType
=
=
LOOP_SESSION_TYPE
.
GUEST
)
{
this
.
setGuestCreatedRoom
(
true
)
;
}
yield
this
.
roomsCache
.
setKey
(
this
.
sessionType
room
.
roomToken
room
.
roomKey
)
;
eventEmitter
.
emit
(
"
add
"
room
)
;
callback
(
null
room
)
;
}
.
bind
(
this
)
)
.
catch
(
callback
)
;
}
setGuestCreatedRoom
:
function
setGuestCreatedRoom
(
created
)
{
if
(
created
)
{
Services
.
prefs
.
setBoolPref
(
"
loop
.
createdRoom
"
created
)
;
}
else
{
Services
.
prefs
.
clearUserPref
(
"
loop
.
createdRoom
"
)
;
}
}
getGuestCreatedRoom
:
function
getGuestCreatedRoom
(
)
{
try
{
return
Services
.
prefs
.
getBoolPref
(
"
loop
.
createdRoom
"
)
;
}
catch
(
x
)
{
return
false
;
}
}
open
:
function
open
(
roomToken
)
{
var
windowData
=
{
roomToken
:
roomToken
type
:
"
room
"
}
;
eventEmitter
.
emit
(
"
open
"
roomToken
)
;
return
MozLoopService
.
openChatWindow
(
windowData
function
(
)
{
eventEmitter
.
emit
(
"
close
"
)
;
}
)
;
}
delete
:
function
_delete
(
roomToken
callback
)
{
var
_this
=
this
;
var
room
=
this
.
rooms
.
get
(
roomToken
)
;
var
url
=
"
/
rooms
/
"
+
encodeURIComponent
(
roomToken
)
;
MozLoopService
.
hawkRequest
(
this
.
sessionType
url
"
DELETE
"
)
.
then
(
function
(
)
{
_this
.
rooms
.
delete
(
roomToken
)
;
eventEmitter
.
emit
(
"
delete
"
room
)
;
eventEmitter
.
emit
(
"
delete
:
"
+
room
.
roomToken
room
)
;
callback
(
null
room
)
;
}
function
(
error
)
{
return
callback
(
error
)
;
}
)
.
catch
(
function
(
error
)
{
return
callback
(
error
)
;
}
)
;
}
_postToRoom
:
function
_postToRoom
(
roomToken
postData
callback
)
{
var
_this2
=
this
;
var
url
=
"
/
rooms
/
"
+
encodeURIComponent
(
roomToken
)
;
MozLoopService
.
hawkRequest
(
this
.
sessionType
url
"
POST
"
postData
)
.
then
(
function
(
response
)
{
var
joinData
=
response
.
body
?
JSON
.
parse
(
response
.
body
)
:
{
}
;
if
(
"
sessionToken
"
in
joinData
)
{
var
room
=
_this2
.
rooms
.
get
(
roomToken
)
;
room
.
sessionToken
=
joinData
.
sessionToken
;
}
callback
(
null
joinData
)
;
}
function
(
error
)
{
return
callback
(
error
)
;
}
)
.
catch
(
function
(
error
)
{
return
callback
(
error
)
;
}
)
;
}
join
:
function
join
(
roomToken
displayName
callback
)
{
this
.
_postToRoom
(
roomToken
{
action
:
"
join
"
displayName
:
displayName
clientMaxSize
:
CLIENT_MAX_SIZE
}
callback
)
;
}
refreshMembership
:
function
refreshMembership
(
roomToken
sessionToken
callback
)
{
this
.
_postToRoom
(
roomToken
{
action
:
"
refresh
"
sessionToken
:
sessionToken
}
callback
)
;
}
leave
:
function
leave
(
roomToken
sessionToken
callback
)
{
if
(
!
callback
)
{
callback
=
function
callback
(
error
)
{
if
(
error
)
{
MozLoopService
.
log
.
error
(
error
)
;
}
}
;
}
var
room
=
this
.
rooms
.
get
(
roomToken
)
;
if
(
!
sessionToken
&
&
room
&
&
room
.
sessionToken
)
{
if
(
!
room
|
|
!
room
.
sessionToken
)
{
return
;
}
sessionToken
=
room
.
sessionToken
;
delete
room
.
sessionToken
;
}
this
.
_postToRoom
(
roomToken
{
action
:
"
leave
"
sessionToken
:
sessionToken
}
callback
)
;
}
sendConnectionStatus
:
function
sendConnectionStatus
(
roomToken
sessionToken
status
callback
)
{
if
(
!
callback
)
{
callback
=
function
callback
(
error
)
{
if
(
error
)
{
MozLoopService
.
log
.
error
(
error
)
;
}
}
;
}
this
.
_postToRoom
(
roomToken
{
action
:
"
status
"
event
:
status
.
event
state
:
status
.
state
connections
:
status
.
connections
sendStreams
:
status
.
sendStreams
recvStreams
:
status
.
recvStreams
sessionToken
:
sessionToken
}
callback
)
;
}
_domainLog
:
{
domainMap
:
new
Map
(
)
roomToken
:
null
}
_recordUrl
:
function
_recordUrl
(
roomToken
url
)
{
if
(
this
.
_domainLog
.
roomToken
!
=
=
roomToken
)
{
this
.
_domainLog
.
roomToken
=
roomToken
;
this
.
_domainLog
.
domainMap
.
clear
(
)
;
}
var
domain
=
void
0
;
try
{
domain
=
Services
.
eTLD
.
getBaseDomain
(
Services
.
io
.
newURI
(
url
null
null
)
)
;
}
catch
(
ex
)
{
return
;
}
if
(
!
DomainWhitelist
.
check
(
domain
)
)
{
return
;
}
if
(
this
.
_domainLog
.
domainMap
.
has
(
domain
)
)
{
this
.
_domainLog
.
domainMap
.
get
(
domain
)
.
count
+
+
;
}
else
{
this
.
_domainLog
.
domainMap
.
set
(
domain
{
count
:
1
domain
:
domain
}
)
;
}
}
logDomains
:
function
logDomains
(
roomToken
callback
)
{
if
(
!
callback
)
{
callback
=
function
callback
(
error
)
{
if
(
error
)
{
MozLoopService
.
log
.
error
(
error
)
;
}
}
;
}
if
(
this
.
_domainLog
.
roomToken
=
=
=
roomToken
&
&
this
.
_domainLog
.
domainMap
.
size
>
0
)
{
this
.
_postToRoom
(
roomToken
{
action
:
"
logDomain
"
domains
:
[
]
.
concat
(
_toConsumableArray
(
this
.
_domainLog
.
domainMap
.
values
(
)
)
)
}
callback
)
;
this
.
_domainLog
.
domainMap
.
clear
(
)
;
}
else
{
callback
(
null
)
;
}
}
update
:
function
update
(
roomToken
roomData
callback
)
{
var
room
=
this
.
rooms
.
get
(
roomToken
)
;
var
url
=
"
/
rooms
/
"
+
encodeURIComponent
(
roomToken
)
;
if
(
!
room
.
decryptedContext
)
{
room
.
decryptedContext
=
{
roomName
:
roomData
.
roomName
|
|
room
.
roomName
}
;
}
else
{
room
.
decryptedContext
.
roomName
=
roomData
.
roomName
|
|
room
.
decryptedContext
.
roomName
|
|
room
.
roomName
;
}
if
(
roomData
.
urls
&
&
roomData
.
urls
.
length
)
{
var
context
=
roomData
.
urls
[
0
]
;
room
.
decryptedContext
.
urls
=
[
context
]
;
if
(
Services
.
prefs
.
getBoolPref
(
"
loop
.
logDomains
"
)
)
{
this
.
_recordUrl
(
roomToken
context
.
location
)
;
}
}
Task
.
spawn
(
function
*
(
)
{
var
_ref2
=
yield
this
.
promiseEncryptRoomData
(
room
)
;
var
all
=
_ref2
.
all
;
var
encrypted
=
_ref2
.
encrypted
;
var
sendData
=
{
context
:
encrypted
.
context
}
;
yield
this
.
roomsCache
.
setKey
(
this
.
sessionType
all
.
roomToken
all
.
roomKey
)
;
var
response
=
yield
MozLoopService
.
hawkRequest
(
this
.
sessionType
url
"
PATCH
"
sendData
)
;
var
newRoomData
=
all
;
extend
(
newRoomData
JSON
.
parse
(
response
.
body
)
)
;
this
.
rooms
.
set
(
roomToken
newRoomData
)
;
callback
(
null
newRoomData
)
;
}
.
bind
(
this
)
)
.
catch
(
callback
)
;
}
onNotification
:
function
onNotification
(
version
channelID
)
{
var
channelIDs
=
MozLoopService
.
channelIDs
;
if
(
this
.
sessionType
=
=
LOOP_SESSION_TYPE
.
GUEST
&
&
channelID
!
=
channelIDs
.
roomsGuest
|
|
this
.
sessionType
=
=
LOOP_SESSION_TYPE
.
FXA
&
&
channelID
!
=
channelIDs
.
roomsFxA
)
{
return
;
}
var
oldDirty
=
gDirty
;
gDirty
=
true
;
this
.
getAll
(
oldDirty
?
null
:
version
function
(
)
{
}
)
;
}
maybeRefresh
:
function
maybeRefresh
(
)
{
var
user
=
arguments
.
length
<
=
0
|
|
arguments
[
0
]
=
=
=
undefined
?
null
:
arguments
[
0
]
;
if
(
gCurrentUser
=
=
user
)
{
return
;
}
gCurrentUser
=
user
;
if
(
!
gDirty
)
{
gDirty
=
true
;
this
.
rooms
.
clear
(
)
;
eventEmitter
.
emit
(
"
refresh
"
)
;
this
.
getAll
(
null
function
(
)
{
}
)
;
}
}
_handleLinkClickerMessage
:
function
_handleLinkClickerMessage
(
id
message
sendingContext
)
{
if
(
!
message
)
{
return
;
}
var
sendResponse
=
function
sendResponse
(
response
alreadyOpen
)
{
gLinkClickerChannel
.
send
(
{
response
:
response
alreadyOpen
:
alreadyOpen
}
sendingContext
)
;
}
;
var
hasRoom
=
this
.
rooms
.
has
(
message
.
roomToken
)
;
switch
(
message
.
command
)
{
case
"
checkWillOpenRoom
"
:
sendResponse
(
hasRoom
false
)
;
break
;
case
"
openRoom
"
:
if
(
hasRoom
)
{
if
(
MozLoopService
.
isChatWindowOpen
(
message
.
roomToken
)
)
{
sendResponse
(
hasRoom
true
)
;
}
else
{
this
.
open
(
message
.
roomToken
)
;
sendResponse
(
hasRoom
false
)
;
}
}
else
{
sendResponse
(
hasRoom
false
)
;
}
break
;
default
:
sendResponse
(
false
false
)
;
break
;
}
}
}
;
Object
.
freeze
(
LoopRoomsInternal
)
;
this
.
LoopRooms
=
{
init
:
function
init
(
)
{
LoopRoomsInternal
.
init
(
)
;
}
get
participantsCount
(
)
{
return
LoopRoomsInternal
.
participantsCount
;
}
getAll
:
function
getAll
(
version
callback
)
{
if
(
!
callback
)
{
callback
=
version
;
version
=
null
;
}
LoopRoomsInternal
.
getAll
(
version
)
.
then
(
function
(
result
)
{
return
callback
(
null
result
)
;
}
)
.
catch
(
function
(
error
)
{
return
callback
(
error
)
;
}
)
;
}
get
:
function
get
(
roomToken
callback
)
{
return
LoopRoomsInternal
.
get
(
roomToken
callback
)
;
}
create
:
function
create
(
options
callback
)
{
return
LoopRoomsInternal
.
create
(
options
callback
)
;
}
open
:
function
open
(
roomToken
)
{
return
LoopRoomsInternal
.
open
(
roomToken
)
;
}
delete
:
function
_delete
(
roomToken
callback
)
{
return
LoopRoomsInternal
.
delete
(
roomToken
callback
)
;
}
join
:
function
join
(
roomToken
displayName
callback
)
{
return
LoopRoomsInternal
.
join
(
roomToken
displayName
callback
)
;
}
refreshMembership
:
function
refreshMembership
(
roomToken
sessionToken
callback
)
{
return
LoopRoomsInternal
.
refreshMembership
(
roomToken
sessionToken
callback
)
;
}
leave
:
function
leave
(
roomToken
sessionToken
callback
)
{
return
LoopRoomsInternal
.
leave
(
roomToken
sessionToken
callback
)
;
}
sendConnectionStatus
:
function
sendConnectionStatus
(
roomToken
sessionToken
status
callback
)
{
return
LoopRoomsInternal
.
sendConnectionStatus
(
roomToken
sessionToken
status
callback
)
;
}
logDomains
:
function
logDomains
(
roomToken
callback
)
{
return
LoopRoomsInternal
.
logDomains
(
roomToken
callback
)
;
}
update
:
function
update
(
roomToken
roomData
callback
)
{
return
LoopRoomsInternal
.
update
(
roomToken
roomData
callback
)
;
}
getGuestCreatedRoom
:
function
getGuestCreatedRoom
(
)
{
return
LoopRoomsInternal
.
getGuestCreatedRoom
(
)
;
}
maybeRefresh
:
function
maybeRefresh
(
user
)
{
return
LoopRoomsInternal
.
maybeRefresh
(
user
)
;
}
getNumParticipants
:
function
getNumParticipants
(
roomToken
)
{
return
LoopRoomsInternal
.
getNumParticipants
(
roomToken
)
;
}
stubCache
:
function
stubCache
(
stub
)
{
LoopRoomsInternal
.
rooms
.
clear
(
)
;
if
(
stub
)
{
var
_iteratorNormalCompletion7
=
true
;
var
_didIteratorError7
=
false
;
var
_iteratorError7
=
undefined
;
try
{
for
(
var
_iterator7
=
stub
.
entries
(
)
[
Symbol
.
iterator
]
(
)
_step7
;
!
(
_iteratorNormalCompletion7
=
(
_step7
=
_iterator7
.
next
(
)
)
.
done
)
;
_iteratorNormalCompletion7
=
true
)
{
var
_ref3
=
_step7
.
value
;
var
_ref4
=
_slicedToArray
(
_ref3
2
)
;
var
key
=
_ref4
[
0
]
;
var
value
=
_ref4
[
1
]
;
LoopRoomsInternal
.
rooms
.
set
(
key
value
)
;
}
}
catch
(
err
)
{
_didIteratorError7
=
true
;
_iteratorError7
=
err
;
}
finally
{
try
{
if
(
!
_iteratorNormalCompletion7
&
&
_iterator7
.
return
)
{
_iterator7
.
return
(
)
;
}
}
finally
{
if
(
_didIteratorError7
)
{
throw
_iteratorError7
;
}
}
}
gDirty
=
false
;
}
else
{
gDirty
=
true
;
}
}
promise
:
function
promise
(
method
)
{
var
_this3
=
this
;
for
(
var
_len
=
arguments
.
length
params
=
Array
(
_len
>
1
?
_len
-
1
:
0
)
_key
=
1
;
_key
<
_len
;
_key
+
+
)
{
params
[
_key
-
1
]
=
arguments
[
_key
]
;
}
if
(
method
=
=
"
getAll
"
)
{
return
LoopRoomsInternal
.
getAll
.
apply
(
LoopRoomsInternal
params
)
;
}
return
new
Promise
(
function
(
resolve
reject
)
{
_this3
[
method
]
.
apply
(
_this3
params
.
concat
(
[
function
(
error
result
)
{
if
(
error
)
{
reject
(
error
)
;
}
else
{
resolve
(
result
)
;
}
}
]
)
)
;
}
)
;
}
on
:
function
on
(
)
{
var
_eventEmitter
;
return
(
_eventEmitter
=
eventEmitter
)
.
on
.
apply
(
_eventEmitter
arguments
)
;
}
once
:
function
once
(
)
{
var
_eventEmitter2
;
return
(
_eventEmitter2
=
eventEmitter
)
.
once
.
apply
(
_eventEmitter2
arguments
)
;
}
off
:
function
off
(
)
{
var
_eventEmitter3
;
return
(
_eventEmitter3
=
eventEmitter
)
.
off
.
apply
(
_eventEmitter3
arguments
)
;
}
_setRoomsCache
:
function
_setRoomsCache
(
roomsCache
orig
)
{
LoopRoomsInternal
.
rooms
.
clear
(
)
;
gDirty
=
true
;
if
(
roomsCache
)
{
var
_iteratorNormalCompletion8
=
true
;
var
_didIteratorError8
=
false
;
var
_iteratorError8
=
undefined
;
try
{
for
(
var
_iterator8
=
roomsCache
[
Symbol
.
iterator
]
(
)
_step8
;
!
(
_iteratorNormalCompletion8
=
(
_step8
=
_iterator8
.
next
(
)
)
.
done
)
;
_iteratorNormalCompletion8
=
true
)
{
var
_ref5
=
_step8
.
value
;
var
_ref6
=
_slicedToArray
(
_ref5
2
)
;
var
key
=
_ref6
[
0
]
;
var
value
=
_ref6
[
1
]
;
LoopRoomsInternal
.
rooms
.
set
(
key
value
)
;
if
(
orig
)
{
checkForParticipantsUpdate
(
orig
value
)
;
}
}
}
catch
(
err
)
{
_didIteratorError8
=
true
;
_iteratorError8
=
err
;
}
finally
{
try
{
if
(
!
_iteratorNormalCompletion8
&
&
_iterator8
.
return
)
{
_iterator8
.
return
(
)
;
}
}
finally
{
if
(
_didIteratorError8
)
{
throw
_iteratorError8
;
}
}
}
gGetAllPromise
=
null
;
gDirty
=
false
;
}
}
}
;
Object
.
freeze
(
this
.
LoopRooms
)
;
