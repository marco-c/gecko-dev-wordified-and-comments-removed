"
use
strict
"
;
var
_typeof
=
typeof
Symbol
=
=
=
"
function
"
&
&
typeof
Symbol
.
iterator
=
=
=
"
symbol
"
?
function
(
obj
)
{
return
typeof
obj
;
}
:
function
(
obj
)
{
return
obj
&
&
typeof
Symbol
=
=
=
"
function
"
&
&
obj
.
constructor
=
=
=
Symbol
?
"
symbol
"
:
typeof
obj
;
}
;
function
_toConsumableArray
(
arr
)
{
if
(
Array
.
isArray
(
arr
)
)
{
for
(
var
i
=
0
arr2
=
Array
(
arr
.
length
)
;
i
<
arr
.
length
;
i
+
+
)
{
arr2
[
i
]
=
arr
[
i
]
;
}
return
arr2
;
}
else
{
return
Array
.
from
(
arr
)
;
}
}
var
_Components
=
Components
;
var
Ci
=
_Components
.
interfaces
;
var
Cu
=
_Components
.
utils
;
var
Cr
=
_Components
.
results
;
var
LOOP_SESSION_TYPE
=
{
GUEST
:
1
FXA
:
2
}
;
var
TWO_WAY_MEDIA_CONN_LENGTH
=
{
SHORTER_THAN_10S
:
0
BETWEEN_10S_AND_30S
:
1
BETWEEN_30S_AND_5M
:
2
MORE_THAN_5M
:
3
}
;
var
SHARING_ROOM_URL
=
{
COPY_FROM_PANEL
:
0
COPY_FROM_CONVERSATION
:
1
EMAIL_FROM_CALLFAILED
:
2
EMAIL_FROM_CONVERSATION
:
3
FACEBOOK_FROM_CONVERSATION
:
4
EMAIL_FROM_PANEL
:
5
}
;
var
ROOM_CREATE
=
{
CREATE_SUCCESS
:
0
CREATE_FAIL
:
1
}
;
var
ROOM_DELETE
=
{
DELETE_SUCCESS
:
0
DELETE_FAIL
:
1
}
;
var
SHARING_SCREEN
=
{
PAUSED
:
0
RESUMED
:
1
}
;
var
COPY_PANEL
=
{
SHOWN
:
0
NO_AGAIN
:
1
NO_NEVER
:
2
YES_AGAIN
:
3
YES_NEVER
:
4
}
;
var
LOOP_MAU_TYPE
=
{
OPEN_PANEL
:
0
OPEN_CONVERSATION
:
1
ROOM_OPEN
:
2
ROOM_SHARE
:
3
ROOM_DELETE
:
4
}
;
var
PREF_LOG_LEVEL
=
"
loop
.
debug
.
loglevel
"
;
var
kChatboxHangupButton
=
{
id
:
"
loop
-
hangup
"
visibleWhenUndocked
:
false
onCommand
:
function
onCommand
(
e
chatbox
)
{
var
mm
=
chatbox
.
content
.
messageManager
;
mm
.
sendAsyncMessage
(
"
Social
:
CustomEvent
"
{
name
:
"
LoopHangupNow
"
}
)
;
}
}
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Promise
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
this
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
FxAccountsOAuthClient
.
jsm
"
)
;
Cu
.
importGlobalProperties
(
[
"
URL
"
]
)
;
this
.
EXPORTED_SYMBOLS
=
[
"
MozLoopService
"
"
LOOP_SESSION_TYPE
"
"
LOOP_MAU_TYPE
"
"
TWO_WAY_MEDIA_CONN_LENGTH
"
"
SHARING_ROOM_URL
"
"
SHARING_SCREEN
"
"
COPY_PANEL
"
"
ROOM_CREATE
"
"
ROOM_DELETE
"
]
;
XPCOMUtils
.
defineConstant
(
this
"
LOOP_SESSION_TYPE
"
LOOP_SESSION_TYPE
)
;
XPCOMUtils
.
defineConstant
(
this
"
TWO_WAY_MEDIA_CONN_LENGTH
"
TWO_WAY_MEDIA_CONN_LENGTH
)
;
XPCOMUtils
.
defineConstant
(
this
"
SHARING_ROOM_URL
"
SHARING_ROOM_URL
)
;
XPCOMUtils
.
defineConstant
(
this
"
SHARING_SCREEN
"
SHARING_SCREEN
)
;
XPCOMUtils
.
defineConstant
(
this
"
COPY_PANEL
"
COPY_PANEL
)
;
XPCOMUtils
.
defineConstant
(
this
"
ROOM_CREATE
"
ROOM_CREATE
)
;
XPCOMUtils
.
defineConstant
(
this
"
ROOM_DELETE
"
ROOM_DELETE
)
;
XPCOMUtils
.
defineConstant
(
this
"
LOOP_MAU_TYPE
"
LOOP_MAU_TYPE
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
LoopAPI
"
"
chrome
:
/
/
loop
/
content
/
modules
/
MozLoopAPI
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
convertToRTCStatsReport
"
"
resource
:
/
/
gre
/
modules
/
media
/
RTCStatsReport
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
loopUtils
"
"
chrome
:
/
/
loop
/
content
/
modules
/
utils
.
js
"
"
utils
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
loopCrypto
"
"
chrome
:
/
/
loop
/
content
/
shared
/
js
/
crypto
.
js
"
"
LoopCrypto
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Chat
"
"
resource
:
/
/
/
modules
/
Chat
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
CommonUtils
"
"
resource
:
/
/
services
-
common
/
utils
.
js
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
CryptoUtils
"
"
resource
:
/
/
services
-
crypto
/
utils
.
js
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
FxAccountsProfileClient
"
"
resource
:
/
/
gre
/
modules
/
FxAccountsProfileClient
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
HawkClient
"
"
resource
:
/
/
services
-
common
/
hawkclient
.
js
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
deriveHawkCredentials
"
"
resource
:
/
/
services
-
common
/
hawkrequest
.
js
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
LoopRooms
"
"
chrome
:
/
/
loop
/
content
/
modules
/
LoopRooms
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
roomsPushNotification
"
"
chrome
:
/
/
loop
/
content
/
modules
/
LoopRooms
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
MozLoopPushHandler
"
"
chrome
:
/
/
loop
/
content
/
modules
/
MozLoopPushHandler
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
UITour
"
"
resource
:
/
/
/
modules
/
UITour
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
uuidgen
"
"
mozilla
.
org
/
uuid
-
generator
;
1
"
"
nsIUUIDGenerator
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
gDNSService
"
"
mozilla
.
org
/
network
/
dns
-
service
;
1
"
"
nsIDNSService
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
gWM
"
"
mozilla
.
org
/
appshell
/
window
-
mediator
;
1
"
"
nsIWindowMediator
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
log
"
function
(
)
{
var
ConsoleAPI
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Console
.
jsm
"
{
}
)
.
ConsoleAPI
;
var
consoleOptions
=
{
maxLogLevelPref
:
PREF_LOG_LEVEL
prefix
:
"
Loop
"
}
;
return
new
ConsoleAPI
(
consoleOptions
)
;
}
)
;
function
setJSONPref
(
aName
aValue
)
{
var
value
=
aValue
?
JSON
.
stringify
(
aValue
)
:
"
"
;
Services
.
prefs
.
setCharPref
(
aName
value
)
;
}
function
getJSONPref
(
aName
)
{
var
value
=
Services
.
prefs
.
getCharPref
(
aName
)
;
return
value
?
JSON
.
parse
(
value
)
:
null
;
}
var
gHawkClient
=
null
;
var
gLocalizedStrings
=
new
Map
(
)
;
var
gFxAOAuthClientPromise
=
null
;
var
gFxAOAuthClient
=
null
;
var
gErrors
=
new
Map
(
)
;
var
gConversationWindowData
=
new
Map
(
)
;
var
gAddonVersion
=
"
unknown
"
;
var
MozLoopServiceInternal
=
{
conversationContexts
:
new
Map
(
)
pushURLs
:
new
Map
(
)
mocks
:
{
pushHandler
:
undefined
isChatWindowOpen
:
undefined
}
deferredRegistrations
:
new
Map
(
)
get
pushHandler
(
)
{
return
this
.
mocks
.
pushHandler
|
|
MozLoopPushHandler
;
}
get
loopServerUri
(
)
{
return
Services
.
prefs
.
getCharPref
(
"
loop
.
server
"
)
;
}
get
initialRegistrationDelayMilliseconds
(
)
{
try
{
return
Services
.
prefs
.
getIntPref
(
"
loop
.
initialDelay
"
)
;
}
catch
(
x
)
{
return
5000
;
}
}
get
fxAOAuthTokenData
(
)
{
return
getJSONPref
(
"
loop
.
fxa_oauth
.
tokendata
"
)
;
}
set
fxAOAuthTokenData
(
aTokenData
)
{
setJSONPref
(
"
loop
.
fxa_oauth
.
tokendata
"
aTokenData
)
;
if
(
!
aTokenData
)
{
this
.
fxAOAuthProfile
=
null
;
}
}
set
fxAOAuthProfile
(
aProfileData
)
{
setJSONPref
(
"
loop
.
fxa_oauth
.
profile
"
aProfileData
)
;
this
.
notifyStatusChanged
(
aProfileData
?
"
login
"
:
undefined
)
;
}
get
doNotDisturb
(
)
{
return
Services
.
prefs
.
getBoolPref
(
"
loop
.
do_not_disturb
"
)
;
}
set
doNotDisturb
(
aFlag
)
{
Services
.
prefs
.
setBoolPref
(
"
loop
.
do_not_disturb
"
Boolean
(
aFlag
)
)
;
this
.
notifyStatusChanged
(
)
;
}
notifyStatusChanged
:
function
notifyStatusChanged
(
)
{
var
aReason
=
arguments
.
length
<
=
0
|
|
arguments
[
0
]
=
=
=
undefined
?
null
:
arguments
[
0
]
;
log
.
debug
(
"
notifyStatusChanged
with
reason
:
"
aReason
)
;
var
profile
=
MozLoopService
.
userProfile
;
LoopRooms
.
maybeRefresh
(
profile
&
&
profile
.
uid
)
;
Services
.
obs
.
notifyObservers
(
null
"
loop
-
status
-
changed
"
aReason
)
;
}
setError
:
function
setError
(
errorType
error
)
{
var
actionCallback
=
arguments
.
length
<
=
2
|
|
arguments
[
2
]
=
=
=
undefined
?
null
:
arguments
[
2
]
;
log
.
debug
(
"
setError
"
errorType
error
)
;
log
.
trace
(
)
;
var
messageString
=
void
0
detailsString
=
void
0
detailsButtonLabelString
=
void
0
detailsButtonCallback
=
void
0
;
var
NETWORK_ERRORS
=
[
Cr
.
NS_ERROR_CONNECTION_REFUSED
Cr
.
NS_ERROR_NET_INTERRUPT
Cr
.
NS_ERROR_NET_RESET
Cr
.
NS_ERROR_NET_TIMEOUT
Cr
.
NS_ERROR_OFFLINE
Cr
.
NS_ERROR_PROXY_CONNECTION_REFUSED
Cr
.
NS_ERROR_UNKNOWN_HOST
Cr
.
NS_ERROR_UNKNOWN_PROXY_HOST
]
;
if
(
error
.
code
=
=
=
null
&
&
error
.
errno
=
=
=
null
&
&
error
.
error
instanceof
Ci
.
nsIException
&
&
NETWORK_ERRORS
.
indexOf
(
error
.
error
.
result
)
!
=
-
1
)
{
errorType
=
"
network
"
;
messageString
=
"
could_not_connect
"
;
detailsString
=
"
check_internet_connection
"
;
detailsButtonLabelString
=
"
retry_button
"
;
}
else
if
(
errorType
=
=
"
profile
"
&
&
error
.
code
>
=
500
&
&
error
.
code
<
600
)
{
messageString
=
"
problem_accessing_account
"
;
}
else
if
(
error
.
code
=
=
401
)
{
if
(
errorType
=
=
"
login
"
)
{
messageString
=
"
could_not_authenticate
"
;
detailsString
=
"
password_changed_question
"
;
detailsButtonLabelString
=
"
retry_button
"
;
detailsButtonCallback
=
function
detailsButtonCallback
(
)
{
return
MozLoopService
.
logInToFxA
(
)
;
}
;
}
else
{
messageString
=
"
session_expired_error_description
"
;
}
}
else
if
(
error
.
code
>
=
500
&
&
error
.
code
<
600
)
{
messageString
=
"
service_not_available
"
;
detailsString
=
"
try_again_later
"
;
detailsButtonLabelString
=
"
retry_button
"
;
}
else
{
messageString
=
"
generic_failure_message
"
;
}
error
.
friendlyMessage
=
this
.
localizedStrings
.
get
(
messageString
)
;
error
.
friendlyDetailsButtonLabel
=
detailsButtonLabelString
?
this
.
localizedStrings
.
get
(
detailsButtonLabelString
)
:
this
.
localizedStrings
.
get
(
"
retry_button
"
)
;
error
.
friendlyDetailsButtonCallback
=
actionCallback
|
|
detailsButtonCallback
|
|
null
;
if
(
detailsString
)
{
error
.
friendlyDetails
=
this
.
localizedStrings
.
get
(
detailsString
)
;
}
else
if
(
error
.
friendlyDetailsButtonCallback
)
{
error
.
friendlyDetails
=
this
.
localizedStrings
.
get
(
"
generic_failure_no_reason2
"
)
;
}
else
{
error
.
friendlyDetails
=
null
;
}
gErrors
.
set
(
errorType
error
)
;
this
.
notifyStatusChanged
(
)
;
}
clearError
:
function
clearError
(
errorType
)
{
if
(
gErrors
.
has
(
errorType
)
)
{
gErrors
.
delete
(
errorType
)
;
this
.
notifyStatusChanged
(
)
;
}
}
get
errors
(
)
{
return
gErrors
;
}
createNotificationChannel
:
function
createNotificationChannel
(
channelID
sessionType
serviceType
onNotification
)
{
var
_this
=
this
;
log
.
debug
(
"
createNotificationChannel
"
channelID
sessionType
serviceType
)
;
return
new
Promise
(
function
(
resolve
reject
)
{
var
onRegistered
=
function
onRegistered
(
error
pushURL
chID
)
{
log
.
debug
(
"
createNotificationChannel
onRegistered
:
"
error
pushURL
chID
)
;
if
(
error
)
{
reject
(
Error
(
error
)
)
;
}
else
{
resolve
(
_this
.
registerWithLoopServer
(
sessionType
serviceType
pushURL
)
)
;
}
}
;
_this
.
pushHandler
.
register
(
channelID
onRegistered
onNotification
)
;
}
)
;
}
promiseRegisteredWithServers
:
function
promiseRegisteredWithServers
(
)
{
var
_this2
=
this
;
var
sessionType
=
arguments
.
length
<
=
0
|
|
arguments
[
0
]
=
=
=
undefined
?
LOOP_SESSION_TYPE
.
GUEST
:
arguments
[
0
]
;
if
(
sessionType
!
=
=
LOOP_SESSION_TYPE
.
GUEST
&
&
sessionType
!
=
=
LOOP_SESSION_TYPE
.
FXA
)
{
return
Promise
.
reject
(
new
Error
(
"
promiseRegisteredWithServers
:
Invalid
sessionType
"
)
)
;
}
if
(
this
.
deferredRegistrations
.
has
(
sessionType
)
)
{
log
.
debug
(
"
promiseRegisteredWithServers
:
registration
already
completed
or
in
progress
:
"
sessionType
)
;
return
this
.
deferredRegistrations
.
get
(
sessionType
)
;
}
var
options
=
this
.
mocks
.
webSocket
?
{
mockWebSocket
:
this
.
mocks
.
webSocket
}
:
{
}
;
this
.
pushHandler
.
initialize
(
options
)
;
var
regPromise
=
void
0
;
if
(
sessionType
=
=
LOOP_SESSION_TYPE
.
GUEST
)
{
regPromise
=
this
.
createNotificationChannel
(
MozLoopService
.
channelIDs
.
roomsGuest
sessionType
"
rooms
"
roomsPushNotification
)
;
}
else
{
regPromise
=
this
.
createNotificationChannel
(
MozLoopService
.
channelIDs
.
roomsFxA
sessionType
"
rooms
"
roomsPushNotification
)
;
}
log
.
debug
(
"
assigning
to
deferredRegistrations
for
sessionType
:
"
sessionType
)
;
this
.
deferredRegistrations
.
set
(
sessionType
regPromise
)
;
regPromise
.
catch
(
function
(
error
)
{
log
.
error
(
"
Failed
to
register
with
Loop
server
with
sessionType
"
sessionType
error
)
;
_this2
.
deferredRegistrations
.
delete
(
sessionType
)
;
log
.
debug
(
"
Cleared
deferredRegistration
for
sessionType
:
"
sessionType
)
;
}
)
;
return
regPromise
;
}
registerWithLoopServer
:
function
registerWithLoopServer
(
sessionType
serviceType
pushURL
)
{
var
_this3
=
this
;
var
retry
=
arguments
.
length
<
=
3
|
|
arguments
[
3
]
=
=
=
undefined
?
true
:
arguments
[
3
]
;
log
.
debug
(
"
registerWithLoopServer
with
sessionType
:
"
sessionType
serviceType
retry
)
;
if
(
!
pushURL
|
|
!
sessionType
|
|
!
serviceType
)
{
return
Promise
.
reject
(
new
Error
(
"
Invalid
or
missing
parameters
for
registerWithLoopServer
"
)
)
;
}
var
pushURLs
=
this
.
pushURLs
.
get
(
sessionType
)
;
if
(
!
pushURLs
)
{
pushURLs
=
{
rooms
:
undefined
}
;
this
.
pushURLs
.
set
(
sessionType
pushURLs
)
;
}
if
(
pushURLs
[
serviceType
]
=
=
pushURL
)
{
return
Promise
.
resolve
(
pushURL
)
;
}
var
newURLs
=
{
rooms
:
pushURLs
.
rooms
}
;
newURLs
[
serviceType
]
=
pushURL
;
return
this
.
hawkRequestInternal
(
sessionType
"
/
registration
"
"
POST
"
{
simplePushURLs
:
newURLs
}
)
.
then
(
function
(
response
)
{
if
(
!
_this3
.
storeSessionToken
(
sessionType
response
.
headers
)
)
{
throw
new
Error
(
"
session
-
token
-
wrong
-
size
"
)
;
}
pushURLs
[
serviceType
]
=
pushURL
;
log
.
debug
(
"
Successfully
registered
with
server
for
sessionType
"
sessionType
)
;
_this3
.
clearError
(
"
registration
"
)
;
return
pushURL
;
}
function
(
error
)
{
if
(
error
.
code
=
=
=
401
)
{
if
(
retry
)
{
return
_this3
.
registerWithLoopServer
(
sessionType
serviceType
pushURL
false
)
;
}
}
log
.
error
(
"
Failed
to
register
with
the
loop
server
.
Error
:
"
error
)
;
throw
error
;
}
)
;
}
unregisterFromLoopServer
:
function
unregisterFromLoopServer
(
sessionType
)
{
var
prefType
=
Services
.
prefs
.
getPrefType
(
this
.
getSessionTokenPrefName
(
sessionType
)
)
;
if
(
prefType
=
=
Services
.
prefs
.
PREF_INVALID
)
{
log
.
debug
(
"
already
unregistered
from
LoopServer
"
sessionType
)
;
return
Promise
.
resolve
(
"
already
unregistered
"
)
;
}
var
error
=
void
0
pushURLs
=
this
.
pushURLs
.
get
(
sessionType
)
roomsPushURL
=
pushURLs
?
pushURLs
.
rooms
:
null
;
this
.
pushURLs
.
delete
(
sessionType
)
;
if
(
!
roomsPushURL
)
{
return
Promise
.
resolve
(
"
no
pushURL
of
this
type
to
unregister
"
)
;
}
var
unregisterURL
=
"
/
registration
?
simplePushURL
=
"
+
encodeURIComponent
(
roomsPushURL
)
;
return
this
.
hawkRequestInternal
(
sessionType
unregisterURL
"
DELETE
"
)
.
then
(
function
(
)
{
log
.
debug
(
"
Successfully
unregistered
from
server
for
sessionType
=
"
sessionType
)
;
return
"
unregistered
sessionType
"
+
sessionType
;
}
function
(
err
)
{
if
(
err
.
code
=
=
=
401
)
{
log
.
debug
(
"
already
unregistered
-
invalid
token
"
sessionType
)
;
return
"
already
unregistered
sessionType
=
"
+
sessionType
;
}
log
.
error
(
"
Failed
to
unregister
with
the
loop
server
.
Error
:
"
error
)
;
throw
err
;
}
)
;
}
hawkRequestInternal
:
function
hawkRequestInternal
(
sessionType
path
method
payloadObj
)
{
var
_this4
=
this
;
var
retryOn401
=
arguments
.
length
<
=
4
|
|
arguments
[
4
]
=
=
=
undefined
?
true
:
arguments
[
4
]
;
log
.
debug
(
"
hawkRequestInternal
:
"
sessionType
path
method
)
;
if
(
!
gHawkClient
)
{
gHawkClient
=
new
HawkClient
(
this
.
loopServerUri
)
;
}
var
sessionToken
=
void
0
credentials
=
void
0
;
try
{
sessionToken
=
Services
.
prefs
.
getCharPref
(
this
.
getSessionTokenPrefName
(
sessionType
)
)
;
}
catch
(
x
)
{
}
if
(
sessionToken
)
{
credentials
=
deriveHawkCredentials
(
sessionToken
"
sessionToken
"
2
*
32
true
)
;
}
if
(
!
gHawkClient
.
willUTF8EncodeRequests
&
&
payloadObj
)
{
var
newPayloadObj
=
{
}
;
var
_iteratorNormalCompletion
=
true
;
var
_didIteratorError
=
false
;
var
_iteratorError
=
undefined
;
try
{
for
(
var
_iterator
=
Object
.
getOwnPropertyNames
(
payloadObj
)
[
Symbol
.
iterator
]
(
)
_step
;
!
(
_iteratorNormalCompletion
=
(
_step
=
_iterator
.
next
(
)
)
.
done
)
;
_iteratorNormalCompletion
=
true
)
{
var
property
=
_step
.
value
;
if
(
typeof
payloadObj
[
property
]
=
=
"
string
"
)
{
newPayloadObj
[
property
]
=
CommonUtils
.
encodeUTF8
(
payloadObj
[
property
]
)
;
}
else
{
newPayloadObj
[
property
]
=
payloadObj
[
property
]
;
}
}
}
catch
(
err
)
{
_didIteratorError
=
true
;
_iteratorError
=
err
;
}
finally
{
try
{
if
(
!
_iteratorNormalCompletion
&
&
_iterator
.
return
)
{
_iterator
.
return
(
)
;
}
}
finally
{
if
(
_didIteratorError
)
{
throw
_iteratorError
;
}
}
}
payloadObj
=
newPayloadObj
;
}
var
handle401Error
=
function
handle401Error
(
error
)
{
if
(
sessionType
=
=
=
LOOP_SESSION_TYPE
.
FXA
)
{
return
MozLoopService
.
logOutFromFxA
(
)
.
then
(
function
(
)
{
_this4
.
setError
(
"
login
"
error
)
;
throw
error
;
}
)
;
}
_this4
.
setError
(
"
registration
"
error
)
;
throw
error
;
}
;
var
extraHeaders
=
{
"
x
-
loop
-
addon
-
ver
"
:
gAddonVersion
}
;
return
gHawkClient
.
request
(
path
method
credentials
payloadObj
extraHeaders
)
.
then
(
function
(
result
)
{
_this4
.
clearError
(
"
network
"
)
;
return
result
;
}
function
(
error
)
{
if
(
error
.
code
&
&
error
.
code
=
=
401
)
{
_this4
.
clearSessionToken
(
sessionType
)
;
if
(
retryOn401
&
&
sessionType
=
=
=
LOOP_SESSION_TYPE
.
GUEST
)
{
log
.
info
(
"
401
and
INVALID_AUTH_TOKEN
-
retry
registration
"
)
;
return
_this4
.
registerWithLoopServer
(
sessionType
false
)
.
then
(
function
(
)
{
return
_this4
.
hawkRequestInternal
(
sessionType
path
method
payloadObj
false
)
;
}
function
(
)
{
return
handle401Error
(
error
)
;
}
)
;
}
return
handle401Error
(
error
)
;
}
throw
error
;
}
)
;
}
hawkRequest
:
function
hawkRequest
(
sessionType
path
method
payloadObj
)
{
var
_this5
=
this
;
log
.
debug
(
"
hawkRequest
:
"
+
path
sessionType
)
;
return
new
Promise
(
function
(
resolve
reject
)
{
MozLoopService
.
promiseRegisteredWithServers
(
sessionType
)
.
then
(
function
(
)
{
_this5
.
hawkRequestInternal
(
sessionType
path
method
payloadObj
)
.
then
(
resolve
reject
)
;
}
function
(
err
)
{
reject
(
err
)
;
}
)
.
catch
(
reject
)
;
}
)
;
}
_hawkRequestError
:
function
_hawkRequestError
(
error
)
{
log
.
error
(
"
Loop
hawkRequest
error
:
"
error
)
;
throw
error
;
}
getSessionTokenPrefName
:
function
getSessionTokenPrefName
(
sessionType
)
{
var
suffix
=
void
0
;
switch
(
sessionType
)
{
case
LOOP_SESSION_TYPE
.
GUEST
:
suffix
=
"
"
;
break
;
case
LOOP_SESSION_TYPE
.
FXA
:
suffix
=
"
.
fxa
"
;
break
;
default
:
throw
new
Error
(
"
Unknown
LOOP_SESSION_TYPE
"
)
;
}
return
"
loop
.
hawk
-
session
-
token
"
+
suffix
;
}
storeSessionToken
:
function
storeSessionToken
(
sessionType
headers
)
{
var
sessionToken
=
headers
[
"
hawk
-
session
-
token
"
]
;
if
(
sessionToken
)
{
if
(
sessionToken
.
length
=
=
=
64
)
{
Services
.
prefs
.
setCharPref
(
this
.
getSessionTokenPrefName
(
sessionType
)
sessionToken
)
;
log
.
debug
(
"
Stored
a
hawk
session
token
for
sessionType
"
sessionType
)
;
}
else
{
log
.
warn
(
"
Loop
server
sent
an
invalid
session
token
"
)
;
return
false
;
}
}
return
true
;
}
clearSessionToken
:
function
clearSessionToken
(
sessionType
)
{
Services
.
prefs
.
clearUserPref
(
this
.
getSessionTokenPrefName
(
sessionType
)
)
;
log
.
debug
(
"
Cleared
hawk
session
token
for
sessionType
"
sessionType
)
;
}
get
localizedStrings
(
)
{
if
(
gLocalizedStrings
.
size
)
{
return
gLocalizedStrings
;
}
function
loadAllStrings
(
location
)
{
var
bundle
=
Services
.
strings
.
createBundle
(
location
)
;
var
enumerator
=
bundle
.
getSimpleEnumeration
(
)
;
while
(
enumerator
.
hasMoreElements
(
)
)
{
var
string
=
enumerator
.
getNext
(
)
.
QueryInterface
(
Ci
.
nsIPropertyElement
)
;
gLocalizedStrings
.
set
(
string
.
key
string
.
value
)
;
}
}
loadAllStrings
(
"
chrome
:
/
/
loop
-
locale
-
fallback
/
content
/
loop
.
properties
"
)
;
loadAllStrings
(
"
chrome
:
/
/
loop
/
locale
/
loop
.
properties
"
)
;
var
brandBundle
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
branding
/
locale
/
brand
.
properties
"
)
;
gLocalizedStrings
.
set
(
"
brandShortname
"
brandBundle
.
GetStringFromName
(
"
brandShortName
"
)
)
;
return
gLocalizedStrings
;
}
stageForTelemetryUpload
:
function
stageForTelemetryUpload
(
window
details
)
{
var
mm
=
window
.
messageManager
;
mm
.
addMessageListener
(
"
Loop
:
GetAllWebrtcStats
"
function
getAllStats
(
message
)
{
mm
.
removeMessageListener
(
"
Loop
:
GetAllWebrtcStats
"
getAllStats
)
;
var
_message
data
=
message
.
data
;
var
allStats
=
_message
data
.
allStats
;
var
logs
=
_message
data
.
logs
;
var
internalFormat
=
allStats
.
reports
[
0
]
;
var
report
=
convertToRTCStatsReport
(
internalFormat
)
;
var
logStr
=
"
"
;
logs
.
forEach
(
function
(
s
)
{
logStr
+
=
s
+
"
\
n
"
;
}
)
;
var
ai
=
Services
.
appinfo
;
var
uuid
=
uuidgen
.
generateUUID
(
)
.
toString
(
)
;
uuid
=
uuid
.
substr
(
1
uuid
.
length
-
2
)
;
var
directory
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
"
saved
-
telemetry
-
pings
"
)
;
var
job
=
{
directory
:
directory
filename
:
uuid
+
"
.
json
"
ping
:
{
reason
:
"
loop
"
slug
:
uuid
payload
:
{
ver
:
1
info
:
{
appUpdateChannel
:
ai
.
defaultUpdateChannel
appBuildID
:
ai
.
appBuildID
appName
:
ai
.
name
appVersion
:
ai
.
version
reason
:
"
loop
"
OS
:
ai
.
OS
version
:
Services
.
sysinfo
.
getProperty
(
"
version
"
)
}
report
:
"
ice
failure
"
connectionstate
:
details
.
iceConnectionState
stats
:
report
localSdp
:
internalFormat
.
localSdp
remoteSdp
:
internalFormat
.
remoteSdp
log
:
logStr
}
}
}
;
var
worker
=
new
ChromeWorker
(
"
MozLoopWorker
.
js
"
)
;
worker
.
onmessage
=
function
(
e
)
{
log
.
info
(
e
.
data
.
ok
?
"
Successfully
staged
loop
report
for
telemetry
upload
.
"
:
"
Failed
to
stage
loop
report
.
Error
:
"
+
e
.
data
.
fail
)
;
}
;
worker
.
postMessage
(
job
)
;
}
)
;
mm
.
sendAsyncMessage
(
"
Loop
:
GetAllWebrtcStats
"
{
peerConnectionID
:
details
.
peerConnectionID
}
)
;
}
getChatWindowID
:
function
getChatWindowID
(
conversationWindowData
)
{
return
conversationWindowData
.
roomToken
;
}
getChatURL
:
function
getChatURL
(
chatWindowId
)
{
return
"
about
:
loopconversation
#
"
+
chatWindowId
;
}
getChatWindows
:
function
getChatWindows
(
)
{
var
isLoopURL
=
function
isLoopURL
(
_ref
)
{
var
src
=
_ref
.
src
;
return
(
/
^
about
:
loopconversation
#
/
.
test
(
src
)
)
;
}
;
return
[
]
.
concat
(
_toConsumableArray
(
Chat
.
chatboxes
)
)
.
filter
(
isLoopURL
)
;
}
hangupAllChatWindows
:
function
hangupAllChatWindows
(
)
{
var
_iteratorNormalCompletion2
=
true
;
var
_didIteratorError2
=
false
;
var
_iteratorError2
=
undefined
;
try
{
for
(
var
_iterator2
=
this
.
getChatWindows
(
)
[
Symbol
.
iterator
]
(
)
_step2
;
!
(
_iteratorNormalCompletion2
=
(
_step2
=
_iterator2
.
next
(
)
)
.
done
)
;
_iteratorNormalCompletion2
=
true
)
{
var
chatbox
=
_step2
.
value
;
var
mm
=
chatbox
.
content
.
messageManager
;
mm
.
sendAsyncMessage
(
"
Social
:
CustomEvent
"
{
name
:
"
LoopHangupNow
"
}
)
;
}
}
catch
(
err
)
{
_didIteratorError2
=
true
;
_iteratorError2
=
err
;
}
finally
{
try
{
if
(
!
_iteratorNormalCompletion2
&
&
_iterator2
.
return
)
{
_iterator2
.
return
(
)
;
}
}
finally
{
if
(
_didIteratorError2
)
{
throw
_iteratorError2
;
}
}
}
}
toggleBrowserSharing
:
function
toggleBrowserSharing
(
)
{
var
on
=
arguments
.
length
<
=
0
|
|
arguments
[
0
]
=
=
=
undefined
?
true
:
arguments
[
0
]
;
var
_iteratorNormalCompletion3
=
true
;
var
_didIteratorError3
=
false
;
var
_iteratorError3
=
undefined
;
try
{
for
(
var
_iterator3
=
this
.
getChatWindows
(
)
[
Symbol
.
iterator
]
(
)
_step3
;
!
(
_iteratorNormalCompletion3
=
(
_step3
=
_iterator3
.
next
(
)
)
.
done
)
;
_iteratorNormalCompletion3
=
true
)
{
var
chatbox
=
_step3
.
value
;
var
mm
=
chatbox
.
content
.
messageManager
;
mm
.
sendAsyncMessage
(
"
Social
:
CustomEvent
"
{
name
:
"
ToggleBrowserSharing
"
detail
:
on
}
)
;
}
}
catch
(
err
)
{
_didIteratorError3
=
true
;
_iteratorError3
=
err
;
}
finally
{
try
{
if
(
!
_iteratorNormalCompletion3
&
&
_iterator3
.
return
)
{
_iterator3
.
return
(
)
;
}
}
finally
{
if
(
_didIteratorError3
)
{
throw
_iteratorError3
;
}
}
}
}
isChatWindowOpen
:
function
isChatWindowOpen
(
chatWindowId
)
{
if
(
this
.
mocks
.
isChatWindowOpen
!
=
=
undefined
)
{
return
this
.
mocks
.
isChatWindowOpen
;
}
var
chatUrl
=
this
.
getChatURL
(
chatWindowId
)
;
return
[
]
.
concat
(
_toConsumableArray
(
Chat
.
chatboxes
)
)
.
some
(
function
(
chatbox
)
{
return
chatbox
.
src
=
=
chatUrl
;
}
)
;
}
openChatWindow
:
function
openChatWindow
(
conversationWindowData
windowCloseCallback
)
{
var
_this6
=
this
;
return
new
Promise
(
function
(
resolve
)
{
var
origin
=
_this6
.
loopServerUri
;
var
windowId
=
_this6
.
getChatWindowID
(
conversationWindowData
)
;
gConversationWindowData
.
set
(
windowId
conversationWindowData
)
;
var
url
=
_this6
.
getChatURL
(
windowId
)
;
Services
.
perms
.
add
(
Services
.
io
.
newURI
(
url
null
null
)
"
camera
"
Services
.
perms
.
ALLOW_ACTION
Services
.
perms
.
EXPIRE_SESSION
)
;
Chat
.
registerButton
(
kChatboxHangupButton
)
;
var
callback
=
function
callback
(
chatbox
)
{
var
mm
=
chatbox
.
content
.
messageManager
;
var
loaded
=
function
loaded
(
)
{
mm
.
removeMessageListener
(
"
DOMContentLoaded
"
loaded
)
;
mm
.
sendAsyncMessage
(
"
Social
:
ListenForEvents
"
{
eventNames
:
[
"
LoopChatEnabled
"
"
LoopChatMessageAppended
"
"
LoopChatDisabledMessageAppended
"
"
socialFrameAttached
"
"
socialFrameDetached
"
"
socialFrameHide
"
"
socialFrameShow
"
]
}
)
;
var
kEventNamesMap
=
{
socialFrameAttached
:
"
Loop
:
ChatWindowAttached
"
socialFrameDetached
:
"
Loop
:
ChatWindowDetached
"
socialFrameHide
:
"
Loop
:
ChatWindowHidden
"
socialFrameShow
:
"
Loop
:
ChatWindowShown
"
unload
:
"
Loop
:
ChatWindowClosed
"
}
;
var
kSizeMap
=
{
LoopChatEnabled
:
"
loopChatEnabled
"
LoopChatDisabledMessageAppended
:
"
loopChatDisabledMessageAppended
"
LoopChatMessageAppended
:
"
loopChatMessageAppended
"
}
;
var
listeners
=
{
}
;
var
messageName
=
"
Social
:
CustomEvent
"
;
mm
.
addMessageListener
(
messageName
listeners
[
messageName
]
=
function
(
message
)
{
var
eventName
=
message
.
data
.
name
;
if
(
kEventNamesMap
[
eventName
]
)
{
eventName
=
kEventNamesMap
[
eventName
]
;
if
(
"
clearAvailableTargetsCache
"
in
UITour
)
{
UITour
.
clearAvailableTargetsCache
(
)
;
}
else
{
UITour
.
availableTargetsCache
.
clear
(
)
;
}
UITour
.
notify
(
eventName
)
;
}
else
{
var
customSize
=
kSizeMap
[
eventName
]
;
var
currSize
=
chatbox
.
getAttribute
(
"
customSize
"
)
;
if
(
customSize
&
&
currSize
!
=
customSize
&
&
currSize
!
=
"
loopChatMessageAppended
"
)
{
chatbox
.
setAttribute
(
"
customSize
"
customSize
)
;
chatbox
.
parentNode
.
setAttribute
(
"
customSize
"
customSize
)
;
}
}
}
)
;
if
(
!
MozLoopService
.
getLoopPref
(
"
conversationPopOut
.
enabled
"
)
)
{
var
document
=
chatbox
.
ownerDocument
;
var
titlebarNode
=
document
.
getAnonymousElementByAttribute
(
chatbox
"
class
"
"
chat
-
titlebar
"
)
;
titlebarNode
.
addEventListener
(
"
dragend
"
function
(
event
)
{
event
.
stopPropagation
(
)
;
return
false
;
}
)
;
}
mm
.
sendAsyncMessage
(
"
Social
:
HookWindowCloseForPanelClose
"
)
;
messageName
=
"
Social
:
DOMWindowClose
"
;
mm
.
addMessageListener
(
messageName
listeners
[
messageName
]
=
function
(
)
{
chatbox
.
close
(
)
;
}
)
;
mm
.
sendAsyncMessage
(
"
Loop
:
MonitorPeerConnectionLifecycle
"
)
;
messageName
=
"
Loop
:
PeerConnectionLifecycleChange
"
;
mm
.
addMessageListener
(
messageName
listeners
[
messageName
]
=
function
(
message
)
{
var
chatWindowId
=
message
.
data
.
locationHash
.
slice
(
1
)
;
var
context
=
_this6
.
conversationContexts
.
get
(
chatWindowId
)
;
var
peerConnectionID
=
message
.
data
.
peerConnectionID
;
var
exists
=
peerConnectionID
.
match
(
/
session
=
(
\
S
+
)
/
)
;
if
(
context
&
&
!
exists
)
{
var
pair
=
peerConnectionID
.
split
(
"
(
"
)
;
if
(
pair
.
length
=
=
2
)
{
peerConnectionID
=
pair
[
0
]
+
"
(
session
=
"
+
context
.
sessionId
+
(
context
.
callId
?
"
call
=
"
+
context
.
callId
:
"
"
)
+
"
"
+
pair
[
1
]
;
}
}
if
(
message
.
data
.
type
=
=
"
iceconnectionstatechange
"
)
{
switch
(
message
.
data
.
iceConnectionState
)
{
case
"
failed
"
:
case
"
disconnected
"
:
if
(
Services
.
telemetry
.
canRecordExtended
)
{
_this6
.
stageForTelemetryUpload
(
chatbox
.
content
message
.
data
)
;
}
break
;
}
}
}
)
;
var
closeListener
=
function
closeListener
(
)
{
this
.
removeEventListener
(
"
ChatboxClosed
"
closeListener
)
;
var
_iteratorNormalCompletion4
=
true
;
var
_didIteratorError4
=
false
;
var
_iteratorError4
=
undefined
;
try
{
for
(
var
_iterator4
=
Object
.
getOwnPropertyNames
(
listeners
)
[
Symbol
.
iterator
]
(
)
_step4
;
!
(
_iteratorNormalCompletion4
=
(
_step4
=
_iterator4
.
next
(
)
)
.
done
)
;
_iteratorNormalCompletion4
=
true
)
{
var
name
=
_step4
.
value
;
mm
.
removeMessageListener
(
name
listeners
[
name
]
)
;
}
}
catch
(
err
)
{
_didIteratorError4
=
true
;
_iteratorError4
=
err
;
}
finally
{
try
{
if
(
!
_iteratorNormalCompletion4
&
&
_iterator4
.
return
)
{
_iterator4
.
return
(
)
;
}
}
finally
{
if
(
_didIteratorError4
)
{
throw
_iteratorError4
;
}
}
}
listeners
=
{
}
;
windowCloseCallback
(
)
;
if
(
conversationWindowData
.
type
=
=
"
room
"
)
{
LoopAPI
.
sendMessageToHandler
(
{
name
:
"
HangupNow
"
data
:
[
conversationWindowData
.
roomToken
windowId
]
}
)
;
}
}
;
chatbox
.
content
.
addEventListener
(
"
SwapDocShells
"
function
swapped
(
ev
)
{
this
.
removeEventListener
(
"
SwapDocShells
"
swapped
)
;
this
.
removeEventListener
(
"
ChatboxClosed
"
closeListener
)
;
var
otherBrowser
=
ev
.
detail
;
chatbox
=
otherBrowser
.
ownerDocument
.
getBindingParent
(
otherBrowser
)
;
mm
=
otherBrowser
.
messageManager
;
otherBrowser
.
addEventListener
(
"
SwapDocShells
"
swapped
)
;
chatbox
.
addEventListener
(
"
ChatboxClosed
"
closeListener
)
;
var
_iteratorNormalCompletion5
=
true
;
var
_didIteratorError5
=
false
;
var
_iteratorError5
=
undefined
;
try
{
for
(
var
_iterator5
=
Object
.
getOwnPropertyNames
(
listeners
)
[
Symbol
.
iterator
]
(
)
_step5
;
!
(
_iteratorNormalCompletion5
=
(
_step5
=
_iterator5
.
next
(
)
)
.
done
)
;
_iteratorNormalCompletion5
=
true
)
{
var
name
=
_step5
.
value
;
mm
.
addMessageListener
(
name
listeners
[
name
]
)
;
}
}
catch
(
err
)
{
_didIteratorError5
=
true
;
_iteratorError5
=
err
;
}
finally
{
try
{
if
(
!
_iteratorNormalCompletion5
&
&
_iterator5
.
return
)
{
_iterator5
.
return
(
)
;
}
}
finally
{
if
(
_didIteratorError5
)
{
throw
_iteratorError5
;
}
}
}
}
)
;
chatbox
.
addEventListener
(
"
ChatboxClosed
"
closeListener
)
;
UITour
.
notify
(
"
Loop
:
ChatWindowOpened
"
)
;
resolve
(
windowId
)
;
}
;
mm
.
sendAsyncMessage
(
"
WaitForDOMContentLoaded
"
)
;
mm
.
addMessageListener
(
"
DOMContentLoaded
"
loaded
)
;
}
;
LoopAPI
.
initialize
(
)
;
var
chatboxInstance
=
Chat
.
open
(
null
{
origin
:
origin
title
:
"
"
url
:
url
remote
:
MozLoopService
.
getLoopPref
(
"
remote
.
autostart
"
)
}
callback
)
;
if
(
!
chatboxInstance
)
{
resolve
(
null
)
;
}
else
if
(
chatboxInstance
.
setAttribute
)
{
chatboxInstance
.
setAttribute
(
"
customSize
"
"
loopDefault
"
)
;
chatboxInstance
.
parentNode
.
setAttribute
(
"
customSize
"
"
loopDefault
"
)
;
var
buttons
=
"
minimize
"
;
if
(
MozLoopService
.
getLoopPref
(
"
conversationPopOut
.
enabled
"
)
)
{
buttons
+
=
"
swap
"
;
}
Chat
.
loadButtonSet
(
chatboxInstance
buttons
+
kChatboxHangupButton
.
id
)
;
}
else
{
resolve
(
windowId
)
;
}
}
)
;
}
promiseFxAOAuthParameters
:
function
promiseFxAOAuthParameters
(
)
{
var
_this7
=
this
;
var
SESSION_TYPE
=
LOOP_SESSION_TYPE
.
FXA
;
return
this
.
hawkRequestInternal
(
SESSION_TYPE
"
/
fxa
-
oauth
/
params
"
"
POST
"
)
.
then
(
function
(
response
)
{
if
(
!
_this7
.
storeSessionToken
(
SESSION_TYPE
response
.
headers
)
)
{
throw
new
Error
(
"
Invalid
FxA
hawk
token
returned
"
)
;
}
var
prefType
=
Services
.
prefs
.
getPrefType
(
_this7
.
getSessionTokenPrefName
(
SESSION_TYPE
)
)
;
if
(
prefType
=
=
Services
.
prefs
.
PREF_INVALID
)
{
throw
new
Error
(
"
No
FxA
hawk
token
returned
and
we
don
'
t
have
one
saved
"
)
;
}
return
JSON
.
parse
(
response
.
body
)
;
}
function
(
error
)
{
_this7
.
_hawkRequestError
(
error
)
;
}
)
;
}
promiseFxAOAuthClient
:
Task
.
async
(
function
*
(
forceReAuth
)
{
if
(
gFxAOAuthClientPromise
)
{
return
gFxAOAuthClientPromise
;
}
gFxAOAuthClientPromise
=
this
.
promiseFxAOAuthParameters
(
)
.
then
(
function
(
parameters
)
{
parameters
.
keys
=
true
;
if
(
forceReAuth
)
{
parameters
.
action
=
"
force_auth
"
;
parameters
.
email
=
MozLoopService
.
userProfile
.
email
;
}
try
{
gFxAOAuthClient
=
new
FxAccountsOAuthClient
(
{
parameters
:
parameters
}
)
;
}
catch
(
ex
)
{
gFxAOAuthClientPromise
=
null
;
throw
ex
;
}
return
gFxAOAuthClient
;
}
function
(
error
)
{
gFxAOAuthClientPromise
=
null
;
throw
error
;
}
)
;
return
gFxAOAuthClientPromise
;
}
)
promiseFxAOAuthAuthorization
:
function
promiseFxAOAuthAuthorization
(
forceReAuth
)
{
var
_this8
=
this
;
var
deferred
=
Promise
.
defer
(
)
;
this
.
promiseFxAOAuthClient
(
forceReAuth
)
.
then
(
function
(
client
)
{
client
.
onComplete
=
_this8
.
_fxAOAuthComplete
.
bind
(
_this8
deferred
)
;
client
.
onError
=
_this8
.
_fxAOAuthError
.
bind
(
_this8
deferred
)
;
client
.
launchWebFlow
(
)
;
}
function
(
error
)
{
log
.
error
(
error
)
;
deferred
.
reject
(
error
)
;
}
)
;
return
deferred
.
promise
;
}
promiseFxAOAuthToken
:
function
promiseFxAOAuthToken
(
code
state
)
{
var
_this9
=
this
;
if
(
!
code
|
|
!
state
)
{
throw
new
Error
(
"
promiseFxAOAuthToken
:
code
and
state
are
required
.
"
)
;
}
var
payload
=
{
code
:
code
state
:
state
}
;
return
this
.
hawkRequestInternal
(
LOOP_SESSION_TYPE
.
FXA
"
/
fxa
-
oauth
/
token
"
"
POST
"
payload
)
.
then
(
function
(
response
)
{
return
JSON
.
parse
(
response
.
body
)
;
}
function
(
error
)
{
return
_this9
.
_hawkRequestError
(
error
)
;
}
)
;
}
_fxAOAuthComplete
:
function
_fxAOAuthComplete
(
deferred
result
keys
)
{
if
(
keys
.
kBr
)
{
Services
.
prefs
.
setCharPref
(
"
loop
.
key
.
fxa
"
keys
.
kBr
.
k
.
replace
(
/
=
/
g
"
"
)
)
;
}
gFxAOAuthClientPromise
=
null
;
deferred
.
resolve
(
result
)
;
}
_fxAOAuthError
:
function
_fxAOAuthError
(
deferred
err
)
{
gFxAOAuthClientPromise
=
null
;
deferred
.
reject
(
err
)
;
}
}
;
Object
.
freeze
(
MozLoopServiceInternal
)
;
var
gInitializeTimerFunc
=
function
gInitializeTimerFunc
(
deferredInitialization
)
{
setTimeout
(
MozLoopService
.
delayedInitialize
.
bind
(
MozLoopService
deferredInitialization
)
MozLoopServiceInternal
.
initialRegistrationDelayMilliseconds
)
;
}
;
var
gServiceInitialized
=
false
;
this
.
MozLoopService
=
{
_DNSService
:
gDNSService
_activeScreenShares
:
new
Set
(
)
get
channelIDs
(
)
{
return
{
roomsFxA
:
"
6add272a
-
d316
-
477c
-
8335
-
f00f73dfde71
"
roomsGuest
:
"
19d3f799
-
a8f3
-
4328
-
9822
-
b7cd02765832
"
}
;
}
set
initializeTimerFunc
(
value
)
{
gInitializeTimerFunc
=
value
;
}
resetServiceInitialized
:
function
resetServiceInitialized
(
)
{
gServiceInitialized
=
false
;
}
get
roomsParticipantsCount
(
)
{
return
LoopRooms
.
participantsCount
;
}
initialize
:
Task
.
async
(
function
*
(
addonVersion
)
{
if
(
gServiceInitialized
)
{
return
Promise
.
resolve
(
)
;
}
gAddonVersion
=
addonVersion
;
gServiceInitialized
=
true
;
Object
.
freeze
(
this
)
;
LoopRooms
.
init
(
)
;
if
(
!
Services
.
prefs
.
getBoolPref
(
"
loop
.
enabled
"
)
)
{
return
Promise
.
reject
(
new
Error
(
"
loop
is
not
enabled
"
)
)
;
}
var
onRoomsChange
=
function
onRoomsChange
(
e
)
{
MozLoopServiceInternal
.
notifyStatusChanged
(
"
room
-
"
+
e
)
;
}
;
LoopRooms
.
on
(
"
add
"
onRoomsChange
)
;
LoopRooms
.
on
(
"
update
"
onRoomsChange
)
;
LoopRooms
.
on
(
"
delete
"
onRoomsChange
)
;
LoopRooms
.
on
(
"
joined
"
function
(
e
room
participant
)
{
if
(
MozLoopServiceInternal
.
doNotDisturb
|
|
participant
.
owner
)
{
return
;
}
var
window
=
gWM
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
if
(
window
)
{
var
isOwnerInRoom
=
room
.
participants
.
concat
(
participant
)
.
some
(
function
(
p
)
{
return
p
.
owner
;
}
)
;
var
bundle
=
MozLoopServiceInternal
.
localizedStrings
;
var
localizedString
=
void
0
;
if
(
isOwnerInRoom
)
{
localizedString
=
bundle
.
get
(
"
rooms_room_joined_owner_connected_label2
"
)
;
}
else
{
var
l10nString
=
bundle
.
get
(
"
rooms_room_joined_owner_not_connected_label
"
)
;
var
roomUrlHostname
=
new
URL
(
room
.
decryptedContext
.
urls
[
0
]
.
location
)
.
hostname
.
replace
(
/
^
www
\
.
/
"
"
)
;
localizedString
=
l10nString
.
replace
(
"
{
{
roomURLHostname
}
}
"
roomUrlHostname
)
;
}
window
.
LoopUI
.
showNotification
(
{
sound
:
"
room
-
joined
"
title
:
room
.
roomName
|
|
MozLoopServiceInternal
.
localizedStrings
.
get
(
"
clientShortname2
"
)
message
:
localizedString
selectTab
:
"
rooms
"
}
)
;
}
}
)
;
LoopRooms
.
on
(
"
joined
"
this
.
maybeResumeTourOnRoomJoined
.
bind
(
this
)
)
;
if
(
!
LoopRooms
.
getGuestCreatedRoom
(
)
&
&
!
MozLoopServiceInternal
.
fxAOAuthTokenData
)
{
return
Promise
.
resolve
(
"
registration
not
needed
"
)
;
}
var
deferredInitialization
=
Promise
.
defer
(
)
;
gInitializeTimerFunc
(
deferredInitialization
)
;
return
deferredInitialization
.
promise
;
}
)
maybeResumeTourOnRoomJoined
:
function
maybeResumeTourOnRoomJoined
(
e
room
participant
)
{
var
isOwnerInRoom
=
false
;
var
isOtherInRoom
=
false
;
if
(
!
this
.
getLoopPref
(
"
gettingStarted
.
resumeOnFirstJoin
"
)
)
{
return
;
}
if
(
!
room
.
participants
)
{
return
;
}
var
_iteratorNormalCompletion6
=
true
;
var
_didIteratorError6
=
false
;
var
_iteratorError6
=
undefined
;
try
{
for
(
var
_iterator6
=
room
.
participants
.
concat
(
participant
)
[
Symbol
.
iterator
]
(
)
_step6
;
!
(
_iteratorNormalCompletion6
=
(
_step6
=
_iterator6
.
next
(
)
)
.
done
)
;
_iteratorNormalCompletion6
=
true
)
{
var
roomParticipant
=
_step6
.
value
;
if
(
roomParticipant
.
owner
)
{
isOwnerInRoom
=
true
;
}
else
{
isOtherInRoom
=
true
;
}
}
}
catch
(
err
)
{
_didIteratorError6
=
true
;
_iteratorError6
=
err
;
}
finally
{
try
{
if
(
!
_iteratorNormalCompletion6
&
&
_iterator6
.
return
)
{
_iterator6
.
return
(
)
;
}
}
finally
{
if
(
_didIteratorError6
)
{
throw
_iteratorError6
;
}
}
}
if
(
!
isOwnerInRoom
|
|
!
isOtherInRoom
)
{
return
;
}
var
chatboxesForRoom
=
[
]
.
concat
(
_toConsumableArray
(
Chat
.
chatboxes
)
)
.
filter
(
function
(
chatbox
)
{
return
(
chatbox
.
src
=
=
MozLoopServiceInternal
.
getChatURL
(
room
.
roomToken
)
)
;
}
)
;
if
(
!
chatboxesForRoom
.
length
)
{
log
.
warn
(
"
Tried
to
resume
the
tour
from
a
join
when
the
chatbox
was
closed
"
room
)
;
return
;
}
this
.
resumeTour
(
"
open
"
)
;
}
delayedInitialize
:
Task
.
async
(
function
*
(
deferredInitialization
)
{
log
.
debug
(
"
delayedInitialize
"
)
;
var
completedPromise
=
deferredInitialization
.
promise
.
then
(
function
(
result
)
{
MozLoopServiceInternal
.
clearError
(
"
initialization
"
)
;
return
result
;
}
function
(
error
)
{
if
(
(
typeof
error
=
=
=
"
undefined
"
?
"
undefined
"
:
_typeof
(
error
)
)
=
=
"
object
"
)
{
MozLoopServiceInternal
.
setError
(
"
initialization
"
error
function
(
)
{
return
MozLoopService
.
delayedInitialize
(
Promise
.
defer
(
)
)
;
}
)
;
}
}
)
;
try
{
if
(
LoopRooms
.
getGuestCreatedRoom
(
)
)
{
yield
this
.
promiseRegisteredWithServers
(
LOOP_SESSION_TYPE
.
GUEST
)
;
}
else
{
log
.
debug
(
"
delayedInitialize
:
Guest
Room
hasn
'
t
been
created
so
not
registering
as
a
guest
"
)
;
}
}
catch
(
ex
)
{
log
.
debug
(
"
MozLoopService
:
Failure
of
guest
registration
"
ex
)
;
deferredInitialization
.
reject
(
ex
)
;
yield
completedPromise
;
return
;
}
if
(
!
MozLoopServiceInternal
.
fxAOAuthTokenData
)
{
log
.
debug
(
"
delayedInitialize
:
Initialized
without
an
already
logged
-
in
account
"
)
;
deferredInitialization
.
resolve
(
"
initialized
without
FxA
status
"
)
;
yield
completedPromise
;
return
;
}
log
.
debug
(
"
MozLoopService
:
Initializing
with
already
logged
-
in
account
"
)
;
MozLoopServiceInternal
.
promiseRegisteredWithServers
(
LOOP_SESSION_TYPE
.
FXA
)
.
then
(
function
(
)
{
deferredInitialization
.
resolve
(
"
initialized
to
logged
-
in
status
"
)
;
}
function
(
error
)
{
log
.
debug
(
"
MozLoopService
:
error
logging
in
using
cached
auth
token
"
)
;
var
retryFunc
=
function
retryFunc
(
)
{
return
MozLoopServiceInternal
.
promiseRegisteredWithServers
(
LOOP_SESSION_TYPE
.
FXA
)
;
}
;
MozLoopServiceInternal
.
setError
(
"
login
"
error
retryFunc
)
;
deferredInitialization
.
reject
(
"
error
logging
in
using
cached
auth
token
"
)
;
}
)
;
yield
completedPromise
;
}
)
hangupAllChatWindows
:
function
hangupAllChatWindows
(
)
{
return
MozLoopServiceInternal
.
hangupAllChatWindows
(
)
;
}
toggleBrowserSharing
:
function
toggleBrowserSharing
(
on
)
{
return
MozLoopServiceInternal
.
toggleBrowserSharing
(
on
)
;
}
openChatWindow
:
function
openChatWindow
(
conversationWindowData
windowCloseCallback
)
{
return
MozLoopServiceInternal
.
openChatWindow
(
conversationWindowData
windowCloseCallback
)
;
}
isChatWindowOpen
:
function
isChatWindowOpen
(
chatWindowId
)
{
return
MozLoopServiceInternal
.
isChatWindowOpen
(
chatWindowId
)
;
}
promiseRegisteredWithServers
:
function
promiseRegisteredWithServers
(
)
{
var
sessionType
=
arguments
.
length
<
=
0
|
|
arguments
[
0
]
=
=
=
undefined
?
LOOP_SESSION_TYPE
.
GUEST
:
arguments
[
0
]
;
return
MozLoopServiceInternal
.
promiseRegisteredWithServers
(
sessionType
)
;
}
getStrings
:
function
getStrings
(
key
)
{
var
stringData
=
MozLoopServiceInternal
.
localizedStrings
;
if
(
!
key
)
{
return
stringData
;
}
if
(
!
stringData
.
has
(
key
)
)
{
log
.
error
(
"
No
string
found
for
key
:
"
key
)
;
return
"
"
;
}
return
JSON
.
stringify
(
{
textContent
:
stringData
.
get
(
key
)
}
)
;
}
get
addonVersion
(
)
{
var
numericAddonVersion
=
gAddonVersion
.
replace
(
/
[
^
0
-
9
\
.
]
/
g
"
"
)
;
return
numericAddonVersion
;
}
generateUUID
:
function
generateUUID
(
)
{
return
uuidgen
.
generateUUID
(
)
.
toString
(
)
;
}
get
doNotDisturb
(
)
{
return
MozLoopServiceInternal
.
doNotDisturb
;
}
set
doNotDisturb
(
aFlag
)
{
MozLoopServiceInternal
.
doNotDisturb
=
aFlag
;
}
get
userProfile
(
)
{
var
profile
=
getJSONPref
(
"
loop
.
fxa_oauth
.
tokendata
"
)
&
&
getJSONPref
(
"
loop
.
fxa_oauth
.
profile
"
)
;
return
profile
;
}
promiseProfileEncryptionKey
:
function
promiseProfileEncryptionKey
(
)
{
var
_this10
=
this
;
return
new
Promise
(
function
(
resolve
reject
)
{
if
(
_this10
.
userProfile
)
{
if
(
Services
.
prefs
.
prefHasUserValue
(
"
loop
.
key
.
fxa
"
)
)
{
resolve
(
MozLoopService
.
getLoopPref
(
"
key
.
fxa
"
)
)
;
return
;
}
reject
(
new
Error
(
"
No
FxA
key
available
"
)
)
;
return
;
}
if
(
!
Services
.
prefs
.
prefHasUserValue
(
"
loop
.
key
"
)
)
{
loopCrypto
.
generateKey
(
)
.
then
(
function
(
key
)
{
Services
.
prefs
.
setCharPref
(
"
loop
.
key
"
key
)
;
resolve
(
key
)
;
}
)
.
catch
(
function
(
error
)
{
MozLoopService
.
log
.
error
(
error
)
;
reject
(
error
)
;
}
)
;
return
;
}
resolve
(
MozLoopService
.
getLoopPref
(
"
key
"
)
)
;
}
)
;
}
get
hasEncryptionKey
(
)
{
return
!
this
.
userProfile
|
|
Services
.
prefs
.
prefHasUserValue
(
"
loop
.
key
.
fxa
"
)
;
}
get
errors
(
)
{
return
MozLoopServiceInternal
.
errors
;
}
get
log
(
)
{
return
log
;
}
get
locale
(
)
{
try
{
return
Services
.
prefs
.
getComplexValue
(
"
general
.
useragent
.
locale
"
Ci
.
nsISupportsString
)
.
data
;
}
catch
(
ex
)
{
return
"
en
-
US
"
;
}
}
get
FTU_VERSION
(
)
{
return
2
;
}
setLoopPref
:
function
setLoopPref
(
prefSuffix
value
prefType
)
{
var
prefName
=
"
loop
.
"
+
prefSuffix
;
try
{
if
(
!
prefType
)
{
prefType
=
Services
.
prefs
.
getPrefType
(
prefName
)
;
}
switch
(
prefType
)
{
case
Ci
.
nsIPrefBranch
.
PREF_STRING
:
Services
.
prefs
.
setCharPref
(
prefName
value
)
;
break
;
case
Ci
.
nsIPrefBranch
.
PREF_INT
:
Services
.
prefs
.
setIntPref
(
prefName
value
)
;
break
;
case
Ci
.
nsIPrefBranch
.
PREF_BOOL
:
Services
.
prefs
.
setBoolPref
(
prefName
value
)
;
break
;
default
:
log
.
error
(
"
invalid
preference
type
setting
"
+
prefName
)
;
break
;
}
}
catch
(
ex
)
{
log
.
error
(
"
setLoopPref
had
trouble
setting
"
+
prefName
+
"
;
exception
:
"
+
ex
)
;
}
}
getLoopPref
:
function
getLoopPref
(
prefSuffix
prefType
)
{
var
prefName
=
"
loop
.
"
+
prefSuffix
;
try
{
if
(
!
prefType
)
{
prefType
=
Services
.
prefs
.
getPrefType
(
prefName
)
;
}
else
if
(
prefType
!
=
Services
.
prefs
.
getPrefType
(
prefName
)
)
{
log
.
error
(
"
invalid
type
specified
for
preference
"
)
;
return
null
;
}
switch
(
prefType
)
{
case
Ci
.
nsIPrefBranch
.
PREF_STRING
:
return
Services
.
prefs
.
getCharPref
(
prefName
)
;
case
Ci
.
nsIPrefBranch
.
PREF_INT
:
return
Services
.
prefs
.
getIntPref
(
prefName
)
;
case
Ci
.
nsIPrefBranch
.
PREF_BOOL
:
return
Services
.
prefs
.
getBoolPref
(
prefName
)
;
default
:
log
.
error
(
"
invalid
preference
type
getting
"
+
prefName
)
;
return
null
;
}
}
catch
(
ex
)
{
log
.
error
(
"
getLoopPref
had
trouble
getting
"
+
prefName
+
"
;
exception
:
"
+
ex
)
;
return
null
;
}
}
logInToFxA
:
function
logInToFxA
(
forceReAuth
)
{
log
.
debug
(
"
logInToFxA
with
fxAOAuthTokenData
:
"
!
!
MozLoopServiceInternal
.
fxAOAuthTokenData
)
;
if
(
!
forceReAuth
&
&
MozLoopServiceInternal
.
fxAOAuthTokenData
)
{
return
Promise
.
resolve
(
MozLoopServiceInternal
.
fxAOAuthTokenData
)
;
}
return
MozLoopServiceInternal
.
promiseFxAOAuthAuthorization
(
forceReAuth
)
.
then
(
function
(
response
)
{
return
(
MozLoopServiceInternal
.
promiseFxAOAuthToken
(
response
.
code
response
.
state
)
)
;
}
)
.
then
(
function
(
tokenData
)
{
MozLoopServiceInternal
.
fxAOAuthTokenData
=
tokenData
;
return
MozLoopServiceInternal
.
promiseRegisteredWithServers
(
LOOP_SESSION_TYPE
.
FXA
)
.
then
(
function
(
)
{
MozLoopServiceInternal
.
clearError
(
"
login
"
)
;
MozLoopServiceInternal
.
clearError
(
"
profile
"
)
;
return
MozLoopServiceInternal
.
fxAOAuthTokenData
;
}
)
;
}
)
.
then
(
Task
.
async
(
function
*
fetchProfile
(
tokenData
)
{
yield
MozLoopService
.
fetchFxAProfile
(
tokenData
)
;
return
tokenData
;
}
)
)
.
catch
(
function
(
error
)
{
MozLoopServiceInternal
.
fxAOAuthTokenData
=
null
;
MozLoopServiceInternal
.
fxAOAuthProfile
=
null
;
MozLoopServiceInternal
.
deferredRegistrations
.
delete
(
LOOP_SESSION_TYPE
.
FXA
)
;
throw
error
;
}
)
.
catch
(
function
(
error
)
{
MozLoopServiceInternal
.
setError
(
"
login
"
error
function
(
)
{
return
MozLoopService
.
logInToFxA
(
)
;
}
)
;
throw
error
;
}
)
;
}
logOutFromFxA
:
Task
.
async
(
function
*
(
)
{
log
.
debug
(
"
logOutFromFxA
"
)
;
try
{
yield
MozLoopServiceInternal
.
unregisterFromLoopServer
(
LOOP_SESSION_TYPE
.
FXA
)
;
}
catch
(
err
)
{
throw
err
;
}
finally
{
MozLoopServiceInternal
.
clearSessionToken
(
LOOP_SESSION_TYPE
.
FXA
)
;
MozLoopServiceInternal
.
fxAOAuthTokenData
=
null
;
MozLoopServiceInternal
.
fxAOAuthProfile
=
null
;
MozLoopServiceInternal
.
deferredRegistrations
.
delete
(
LOOP_SESSION_TYPE
.
FXA
)
;
MozLoopServiceInternal
.
pushHandler
.
unregister
(
MozLoopService
.
channelIDs
.
roomsFxA
)
;
gFxAOAuthClient
=
null
;
gFxAOAuthClientPromise
=
null
;
MozLoopServiceInternal
.
clearError
(
"
registration
"
)
;
MozLoopServiceInternal
.
clearError
(
"
login
"
)
;
MozLoopServiceInternal
.
clearError
(
"
profile
"
)
;
}
}
)
fetchFxAProfile
:
function
fetchFxAProfile
(
)
{
var
_this11
=
this
;
log
.
debug
(
"
fetchFxAProfile
"
)
;
var
client
=
new
FxAccountsProfileClient
(
{
serverURL
:
gFxAOAuthClient
.
parameters
.
profile_uri
token
:
MozLoopServiceInternal
.
fxAOAuthTokenData
.
access_token
}
)
;
return
client
.
fetchProfile
(
)
.
then
(
function
(
result
)
{
MozLoopServiceInternal
.
fxAOAuthProfile
=
result
;
MozLoopServiceInternal
.
clearError
(
"
profile
"
)
;
}
function
(
error
)
{
log
.
error
(
"
Failed
to
retrieve
profile
"
error
_this11
.
fetchFxAProfile
.
bind
(
_this11
)
)
;
MozLoopServiceInternal
.
setError
(
"
profile
"
error
)
;
MozLoopServiceInternal
.
fxAOAuthProfile
=
null
;
MozLoopServiceInternal
.
notifyStatusChanged
(
)
;
}
)
;
}
openFxASettings
:
Task
.
async
(
function
*
(
)
{
try
{
var
fxAOAuthClient
=
yield
MozLoopServiceInternal
.
promiseFxAOAuthClient
(
)
;
if
(
!
fxAOAuthClient
)
{
log
.
error
(
"
Could
not
get
the
OAuth
client
"
)
;
return
;
}
var
url
=
new
URL
(
"
/
settings
"
fxAOAuthClient
.
parameters
.
content_uri
)
;
if
(
this
.
userProfile
)
{
var
fxAProfileUid
=
MozLoopService
.
userProfile
.
uid
;
url
=
new
URL
(
"
/
settings
?
uid
=
"
+
fxAProfileUid
fxAOAuthClient
.
parameters
.
content_uri
)
;
}
var
win
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
win
.
switchToTabHavingURI
(
url
.
toString
(
)
true
)
;
}
catch
(
ex
)
{
log
.
error
(
"
Error
opening
FxA
settings
"
ex
)
;
}
}
)
getTourURL
:
function
getTourURL
(
)
{
var
aSrc
=
arguments
.
length
<
=
0
|
|
arguments
[
0
]
=
=
=
undefined
?
null
:
arguments
[
0
]
;
var
aAdditionalParams
=
arguments
.
length
<
=
1
|
|
arguments
[
1
]
=
=
=
undefined
?
{
}
:
arguments
[
1
]
;
var
urlStr
=
this
.
getLoopPref
(
"
gettingStarted
.
url
"
)
;
var
url
=
new
URL
(
Services
.
urlFormatter
.
formatURL
(
urlStr
)
)
;
Object
.
keys
(
aAdditionalParams
)
.
forEach
(
function
(
paramName
)
{
url
.
searchParams
.
set
(
paramName
aAdditionalParams
[
paramName
]
)
;
}
)
;
if
(
aSrc
)
{
url
.
searchParams
.
set
(
"
utm_source
"
"
firefox
-
browser
"
)
;
url
.
searchParams
.
set
(
"
utm_medium
"
"
firefox
-
browser
"
)
;
url
.
searchParams
.
set
(
"
utm_campaign
"
aSrc
)
;
}
var
mostRecentLoopPageID
=
{
id
:
null
lastSeen
:
null
}
;
var
_iteratorNormalCompletion7
=
true
;
var
_didIteratorError7
=
false
;
var
_iteratorError7
=
undefined
;
try
{
for
(
var
_iterator7
=
UITour
.
pageIDsForSession
[
Symbol
.
iterator
]
(
)
_step7
;
!
(
_iteratorNormalCompletion7
=
(
_step7
=
_iterator7
.
next
(
)
)
.
done
)
;
_iteratorNormalCompletion7
=
true
)
{
var
pageID
=
_step7
.
value
;
if
(
pageID
[
0
]
&
&
pageID
[
0
]
.
startsWith
(
"
hello
-
tour_OpenPanel_
"
)
&
&
pageID
[
1
]
&
&
pageID
[
1
]
.
lastSeen
>
mostRecentLoopPageID
.
lastSeen
)
{
mostRecentLoopPageID
.
id
=
pageID
[
0
]
;
mostRecentLoopPageID
.
lastSeen
=
pageID
[
1
]
.
lastSeen
;
}
}
}
catch
(
err
)
{
_didIteratorError7
=
true
;
_iteratorError7
=
err
;
}
finally
{
try
{
if
(
!
_iteratorNormalCompletion7
&
&
_iterator7
.
return
)
{
_iterator7
.
return
(
)
;
}
}
finally
{
if
(
_didIteratorError7
)
{
throw
_iteratorError7
;
}
}
}
var
PAGE_ID_EXPIRATION_MS
=
60
*
60
*
1000
;
if
(
mostRecentLoopPageID
.
id
&
&
mostRecentLoopPageID
.
lastSeen
>
Date
.
now
(
)
-
PAGE_ID_EXPIRATION_MS
)
{
url
.
searchParams
.
set
(
"
utm_content
"
mostRecentLoopPageID
.
id
)
;
}
return
url
;
}
resumeTour
:
function
resumeTour
(
aIncomingConversationState
)
{
if
(
!
this
.
getLoopPref
(
"
gettingStarted
.
resumeOnFirstJoin
"
)
)
{
return
;
}
var
url
=
this
.
getTourURL
(
"
resume
-
with
-
conversation
"
{
incomingConversation
:
aIncomingConversationState
}
)
;
var
win
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
this
.
setLoopPref
(
"
gettingStarted
.
resumeOnFirstJoin
"
false
)
;
var
hadExistingTab
=
win
.
switchToTabHavingURI
(
url
true
{
ignoreFragment
:
true
ignoreQueryString
:
true
}
)
;
if
(
hadExistingTab
)
{
UITour
.
notify
(
"
Loop
:
IncomingConversation
"
{
conversationOpen
:
aIncomingConversationState
=
=
=
"
open
"
}
)
;
}
}
openGettingStartedTour
:
Task
.
async
(
function
(
)
{
var
kNSXUL
=
"
http
:
/
/
www
.
mozilla
.
org
/
keymaster
/
gatekeeper
/
there
.
is
.
only
.
xul
"
;
var
xulWin
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
var
xulDoc
=
xulWin
.
document
;
var
box
=
xulDoc
.
createElementNS
(
kNSXUL
"
box
"
)
;
box
.
setAttribute
(
"
id
"
"
loop
-
slideshow
-
container
"
)
;
var
appContent
=
xulDoc
.
getElementById
(
"
appcontent
"
)
;
var
tabBrowser
=
xulDoc
.
getElementById
(
"
content
"
)
;
appContent
.
insertBefore
(
box
tabBrowser
)
;
var
xulBrowser
=
xulDoc
.
createElementNS
(
kNSXUL
"
browser
"
)
;
xulBrowser
.
setAttribute
(
"
id
"
"
loop
-
slideshow
-
browser
"
)
;
xulBrowser
.
setAttribute
(
"
flex
"
"
1
"
)
;
xulBrowser
.
setAttribute
(
"
type
"
"
content
"
)
;
box
.
appendChild
(
xulBrowser
)
;
xulWin
.
LoopUI
.
isSlideshowOpen
=
true
;
var
removeSlideshow
=
function
(
)
{
try
{
appContent
.
removeChild
(
box
)
;
}
catch
(
ex
)
{
log
.
error
(
ex
)
;
}
this
.
setLoopPref
(
"
gettingStarted
.
latestFTUVersion
"
this
.
FTU_VERSION
)
;
xulWin
.
LoopUI
.
isSlideshowOpen
=
false
;
xulWin
.
LoopUI
.
openPanel
(
)
;
xulWin
.
removeEventListener
(
"
CloseSlideshow
"
removeSlideshow
)
;
log
.
info
(
"
slideshow
removed
"
)
;
}
.
bind
(
this
)
;
function
xulLoadListener
(
)
{
xulBrowser
.
contentWindow
.
addEventListener
(
"
CloseSlideshow
"
removeSlideshow
)
;
log
.
info
(
"
CloseSlideshow
handler
added
"
)
;
xulBrowser
.
removeEventListener
(
"
load
"
xulLoadListener
true
)
;
}
xulBrowser
.
addEventListener
(
"
load
"
xulLoadListener
true
)
;
xulBrowser
.
setAttribute
(
"
src
"
"
chrome
:
/
/
loop
/
content
/
panels
/
slideshow
.
html
"
)
;
}
)
openURL
:
function
openURL
(
url
)
{
var
win
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
win
.
openUILinkIn
(
Services
.
urlFormatter
.
formatURL
(
url
)
"
tab
"
)
;
}
hawkRequest
:
function
hawkRequest
(
sessionType
path
method
payloadObj
)
{
return
MozLoopServiceInternal
.
hawkRequest
(
sessionType
path
method
payloadObj
)
.
catch
(
function
(
error
)
{
return
MozLoopServiceInternal
.
_hawkRequestError
(
error
)
;
}
)
;
}
getConversationWindowData
:
function
getConversationWindowData
(
conversationWindowId
)
{
if
(
gConversationWindowData
.
has
(
conversationWindowId
)
)
{
var
conversationData
=
gConversationWindowData
.
get
(
conversationWindowId
)
;
gConversationWindowData
.
delete
(
conversationWindowId
)
;
return
conversationData
;
}
log
.
error
(
"
Window
data
was
already
fetched
before
.
Possible
race
condition
!
"
)
;
return
null
;
}
getConversationContext
:
function
getConversationContext
(
winId
)
{
return
MozLoopServiceInternal
.
conversationContexts
.
get
(
winId
)
;
}
addConversationContext
:
function
addConversationContext
(
windowId
context
)
{
MozLoopServiceInternal
.
conversationContexts
.
set
(
windowId
context
)
;
}
setScreenShareState
:
function
setScreenShareState
(
windowId
active
)
{
if
(
active
)
{
this
.
_activeScreenShares
.
add
(
windowId
)
;
}
else
if
(
this
.
_activeScreenShares
.
has
(
windowId
)
)
{
this
.
_activeScreenShares
.
delete
(
windowId
)
;
}
MozLoopServiceInternal
.
notifyStatusChanged
(
)
;
}
get
screenShareActive
(
)
{
return
this
.
_activeScreenShares
.
size
>
0
;
}
}
;
