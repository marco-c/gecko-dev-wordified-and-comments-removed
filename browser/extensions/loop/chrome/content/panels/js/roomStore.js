"
use
strict
"
;
var
loop
=
loop
|
|
{
}
;
loop
.
store
=
loop
.
store
|
|
{
}
;
(
function
(
mozL10n
)
{
"
use
strict
"
;
var
sharedActions
=
loop
.
shared
.
actions
;
var
MAX_ROOM_CREATION_SIZE
=
loop
.
store
.
MAX_ROOM_CREATION_SIZE
=
2
;
var
roomSchema
=
{
roomToken
:
String
roomUrl
:
String
maxSize
:
Number
participants
:
Array
ctime
:
Number
}
;
function
Room
(
values
)
{
var
_this
=
this
;
var
validatedData
=
new
loop
.
validate
.
Validator
(
roomSchema
|
|
{
}
)
.
validate
(
values
|
|
{
}
)
;
Object
.
keys
(
validatedData
)
.
forEach
(
function
(
prop
)
{
_this
[
prop
]
=
validatedData
[
prop
]
;
}
)
;
}
loop
.
store
.
Room
=
Room
;
loop
.
store
.
RoomStore
=
loop
.
store
.
createStore
(
{
maxRoomCreationSize
:
MAX_ROOM_CREATION_SIZE
actions
:
[
"
createRoom
"
"
createdRoom
"
"
createRoomError
"
"
copyRoomUrl
"
"
deleteRoom
"
"
deleteRoomError
"
"
emailRoomUrl
"
"
facebookShareRoomUrl
"
"
getAllRooms
"
"
getAllRoomsError
"
"
openRoom
"
"
updateRoomContext
"
"
updateRoomContextDone
"
"
updateRoomContextError
"
"
updateRoomList
"
]
initialize
:
function
initialize
(
options
)
{
if
(
!
options
.
constants
)
{
throw
new
Error
(
"
Missing
option
constants
"
)
;
}
this
.
_notifications
=
options
.
notifications
;
this
.
_constants
=
options
.
constants
;
this
.
_gotAllRooms
=
false
;
if
(
options
.
activeRoomStore
)
{
this
.
activeRoomStore
=
options
.
activeRoomStore
;
this
.
activeRoomStore
.
on
(
"
change
"
this
.
_onActiveRoomStoreChange
.
bind
(
this
)
)
;
}
}
getInitialStoreState
:
function
getInitialStoreState
(
)
{
return
{
activeRoom
:
this
.
activeRoomStore
?
this
.
activeRoomStore
.
getStoreState
(
)
:
{
}
closingNewRoom
:
false
error
:
null
lastCreatedRoom
:
null
openedRoom
:
null
pendingCreation
:
false
pendingInitialRetrieval
:
true
rooms
:
[
]
savingContext
:
false
}
;
}
startListeningToRoomEvents
:
function
startListeningToRoomEvents
(
)
{
loop
.
request
(
"
Rooms
:
PushSubscription
"
[
"
add
"
"
close
"
"
delete
"
"
open
"
"
refresh
"
"
update
"
]
)
;
loop
.
subscribe
(
"
Rooms
:
Add
"
this
.
_onRoomAdded
.
bind
(
this
)
)
;
loop
.
subscribe
(
"
Rooms
:
Close
"
this
.
_onRoomClose
.
bind
(
this
)
)
;
loop
.
subscribe
(
"
Rooms
:
Open
"
this
.
_onRoomOpen
.
bind
(
this
)
)
;
loop
.
subscribe
(
"
Rooms
:
Update
"
this
.
_onRoomUpdated
.
bind
(
this
)
)
;
loop
.
subscribe
(
"
Rooms
:
Delete
"
this
.
_onRoomRemoved
.
bind
(
this
)
)
;
loop
.
subscribe
(
"
Rooms
:
Refresh
"
this
.
_onRoomsRefresh
.
bind
(
this
)
)
;
}
_onActiveRoomStoreChange
:
function
_onActiveRoomStoreChange
(
)
{
this
.
setStoreState
(
{
activeRoom
:
this
.
activeRoomStore
.
getStoreState
(
)
}
)
;
}
_onRoomAdded
:
function
_onRoomAdded
(
addedRoomData
)
{
addedRoomData
.
participants
=
addedRoomData
.
participants
|
|
[
]
;
addedRoomData
.
ctime
=
addedRoomData
.
ctime
|
|
new
Date
(
)
.
getTime
(
)
;
this
.
dispatchAction
(
new
sharedActions
.
UpdateRoomList
(
{
roomList
:
this
.
_storeState
.
rooms
.
filter
(
function
(
room
)
{
return
addedRoomData
.
roomToken
!
=
=
room
.
roomToken
;
}
)
.
concat
(
new
Room
(
addedRoomData
)
)
}
)
)
;
}
_onRoomClose
:
function
_onRoomClose
(
)
{
var
state
=
this
.
getStoreState
(
)
;
if
(
state
.
lastCreatedRoom
&
&
state
.
openedRoom
=
=
=
state
.
lastCreatedRoom
)
{
this
.
setStoreState
(
{
closingNewRoom
:
true
}
)
;
loop
.
request
(
"
SetNameNewRoom
"
)
;
}
this
.
setStoreState
(
{
closingNewRoom
:
false
lastCreatedRoom
:
null
openedRoom
:
null
}
)
;
}
_onRoomOpen
:
function
_onRoomOpen
(
roomToken
)
{
this
.
setStoreState
(
{
openedRoom
:
roomToken
}
)
;
}
_onRoomUpdated
:
function
_onRoomUpdated
(
updatedRoomData
)
{
this
.
dispatchAction
(
new
sharedActions
.
UpdateRoomList
(
{
roomList
:
this
.
_storeState
.
rooms
.
map
(
function
(
room
)
{
return
room
.
roomToken
=
=
=
updatedRoomData
.
roomToken
?
updatedRoomData
:
room
;
}
)
}
)
)
;
}
_onRoomRemoved
:
function
_onRoomRemoved
(
removedRoomData
)
{
this
.
dispatchAction
(
new
sharedActions
.
UpdateRoomList
(
{
roomList
:
this
.
_storeState
.
rooms
.
filter
(
function
(
room
)
{
return
room
.
roomToken
!
=
=
removedRoomData
.
roomToken
;
}
)
}
)
)
;
}
_onRoomsRefresh
:
function
_onRoomsRefresh
(
)
{
this
.
dispatchAction
(
new
sharedActions
.
UpdateRoomList
(
{
roomList
:
[
]
}
)
)
;
}
_processRoomList
:
function
_processRoomList
(
rawRoomList
)
{
if
(
!
rawRoomList
)
{
return
[
]
;
}
return
rawRoomList
.
map
(
function
(
rawRoom
)
{
return
new
Room
(
rawRoom
)
;
}
)
.
slice
(
)
.
sort
(
function
(
a
b
)
{
return
b
.
ctime
-
a
.
ctime
;
}
)
;
}
createRoom
:
function
createRoom
(
actionData
)
{
this
.
setStoreState
(
{
pendingCreation
:
true
error
:
null
}
)
;
var
roomCreationData
=
{
decryptedContext
:
{
}
maxSize
:
this
.
maxRoomCreationSize
}
;
if
(
"
urls
"
in
actionData
)
{
roomCreationData
.
decryptedContext
.
urls
=
actionData
.
urls
;
}
this
.
_notifications
.
remove
(
"
create
-
room
-
error
"
)
;
loop
.
request
(
"
Rooms
:
Create
"
roomCreationData
)
.
then
(
function
(
result
)
{
var
buckets
=
this
.
_constants
.
ROOM_CREATE
;
if
(
!
result
|
|
result
.
isError
)
{
loop
.
request
(
"
TelemetryAddValue
"
"
LOOP_ROOM_CREATE
"
buckets
.
CREATE_FAIL
)
;
this
.
dispatchAction
(
new
sharedActions
.
CreateRoomError
(
{
error
:
result
?
result
:
new
Error
(
"
no
result
"
)
}
)
)
;
return
;
}
this
.
setStoreState
(
{
lastCreatedRoom
:
result
.
roomToken
}
)
;
this
.
dispatchAction
(
new
sharedActions
.
CreatedRoom
(
{
decryptedContext
:
result
.
decryptedContext
roomToken
:
result
.
roomToken
roomUrl
:
result
.
roomUrl
}
)
)
;
loop
.
request
(
"
TelemetryAddValue
"
"
LOOP_ROOM_CREATE
"
buckets
.
CREATE_SUCCESS
)
;
}
.
bind
(
this
)
)
;
}
createdRoom
:
function
createdRoom
(
actionData
)
{
this
.
setStoreState
(
{
activeRoom
:
{
decryptedContext
:
actionData
.
decryptedContext
roomToken
:
actionData
.
roomToken
roomUrl
:
actionData
.
roomUrl
}
pendingCreation
:
false
}
)
;
}
createRoomError
:
function
createRoomError
(
actionData
)
{
this
.
setStoreState
(
{
error
:
actionData
.
error
pendingCreation
:
false
}
)
;
this
.
_notifications
.
set
(
{
id
:
"
create
-
room
-
error
"
level
:
"
error
"
message
:
mozL10n
.
get
(
"
generic_failure_message
"
)
}
)
;
}
copyRoomUrl
:
function
copyRoomUrl
(
actionData
)
{
loop
.
requestMulti
(
[
"
CopyString
"
actionData
.
roomUrl
]
[
"
NotifyUITour
"
"
Loop
:
RoomURLCopied
"
]
)
;
var
from
=
actionData
.
from
;
var
bucket
=
this
.
_constants
.
SHARING_ROOM_URL
[
"
COPY_FROM_
"
+
from
.
toUpperCase
(
)
]
;
if
(
typeof
bucket
=
=
=
"
undefined
"
)
{
console
.
error
(
"
No
URL
sharing
type
bucket
found
for
'
"
+
from
+
"
'
"
)
;
return
;
}
loop
.
request
(
"
TelemetryAddValue
"
"
LOOP_ACTIVITY_COUNTER
"
this
.
_constants
.
LOOP_MAU_TYPE
.
ROOM_SHARE
)
;
}
emailRoomUrl
:
function
emailRoomUrl
(
actionData
)
{
var
from
=
actionData
.
from
;
loop
.
shared
.
utils
.
composeCallUrlEmail
(
actionData
.
roomUrl
null
actionData
.
roomDescription
)
;
var
bucket
=
this
.
_constants
.
SHARING_ROOM_URL
[
"
EMAIL_FROM_
"
+
(
from
|
|
"
"
)
.
toUpperCase
(
)
]
;
if
(
typeof
bucket
=
=
=
"
undefined
"
)
{
console
.
error
(
"
No
URL
sharing
type
bucket
found
for
'
"
+
from
+
"
'
"
)
;
return
;
}
loop
.
requestMulti
(
[
"
NotifyUITour
"
"
Loop
:
RoomURLEmailed
"
]
[
"
TelemetryAddValue
"
"
LOOP_ACTIVITY_COUNTER
"
this
.
_constants
.
LOOP_MAU_TYPE
.
ROOM_SHARE
]
)
;
}
facebookShareRoomUrl
:
function
facebookShareRoomUrl
(
actionData
)
{
var
encodedRoom
=
encodeURIComponent
(
actionData
.
roomUrl
)
;
loop
.
requestMulti
(
[
"
GetLoopPref
"
"
facebook
.
appId
"
]
[
"
GetLoopPref
"
"
facebook
.
fallbackUrl
"
]
[
"
GetLoopPref
"
"
facebook
.
shareUrl
"
]
)
.
then
(
function
(
results
)
{
var
app_id
=
results
[
0
]
;
var
fallback_url
=
results
[
1
]
;
var
redirect_url
=
encodeURIComponent
(
actionData
.
originUrl
|
|
fallback_url
)
;
var
finalURL
=
results
[
2
]
.
replace
(
"
%
ROOM_URL
%
"
encodedRoom
)
.
replace
(
"
%
APP_ID
%
"
app_id
)
.
replace
(
"
%
REDIRECT_URI
%
"
redirect_url
)
;
return
loop
.
request
(
"
OpenURL
"
finalURL
)
;
}
)
.
then
(
function
(
)
{
loop
.
request
(
"
NotifyUITour
"
"
Loop
:
RoomURLShared
"
)
;
}
)
;
var
from
=
actionData
.
from
;
var
bucket
=
this
.
_constants
.
SHARING_ROOM_URL
[
"
FACEBOOK_FROM_
"
+
from
.
toUpperCase
(
)
]
;
if
(
typeof
bucket
=
=
=
"
undefined
"
)
{
console
.
error
(
"
No
URL
sharing
type
bucket
found
for
'
"
+
from
+
"
'
"
)
;
return
;
}
loop
.
request
(
"
TelemetryAddValue
"
"
LOOP_ACTIVITY_COUNTER
"
this
.
_constants
.
LOOP_MAU_TYPE
.
ROOM_SHARE
)
;
}
deleteRoom
:
function
deleteRoom
(
actionData
)
{
loop
.
request
(
"
Rooms
:
Delete
"
actionData
.
roomToken
)
.
then
(
function
(
result
)
{
var
isError
=
result
&
&
result
.
isError
;
if
(
isError
)
{
this
.
dispatchAction
(
new
sharedActions
.
DeleteRoomError
(
{
error
:
result
}
)
)
;
}
loop
.
request
(
"
TelemetryAddValue
"
"
LOOP_ACTIVITY_COUNTER
"
this
.
_constants
.
LOOP_MAU_TYPE
.
ROOM_DELETE
)
;
}
.
bind
(
this
)
)
;
}
deleteRoomError
:
function
deleteRoomError
(
actionData
)
{
this
.
setStoreState
(
{
error
:
actionData
.
error
}
)
;
}
getAllRooms
:
function
getAllRooms
(
)
{
if
(
this
.
_gotAllRooms
)
{
return
;
}
loop
.
request
(
"
Rooms
:
GetAll
"
null
)
.
then
(
function
(
result
)
{
var
action
;
this
.
setStoreState
(
{
pendingInitialRetrieval
:
false
}
)
;
if
(
result
&
&
result
.
isError
)
{
action
=
new
sharedActions
.
GetAllRoomsError
(
{
error
:
result
}
)
;
}
else
{
action
=
new
sharedActions
.
UpdateRoomList
(
{
roomList
:
result
}
)
;
}
this
.
dispatchAction
(
action
)
;
this
.
_gotAllRooms
=
true
;
this
.
startListeningToRoomEvents
(
)
;
}
.
bind
(
this
)
)
;
}
getAllRoomsError
:
function
getAllRoomsError
(
actionData
)
{
this
.
setStoreState
(
{
error
:
actionData
.
error
}
)
;
}
updateRoomList
:
function
updateRoomList
(
actionData
)
{
this
.
setStoreState
(
{
error
:
undefined
rooms
:
this
.
_processRoomList
(
actionData
.
roomList
)
}
)
;
}
openRoom
:
function
openRoom
(
actionData
)
{
loop
.
requestMulti
(
[
"
Rooms
:
Open
"
actionData
.
roomToken
]
[
"
TelemetryAddValue
"
"
LOOP_ACTIVITY_COUNTER
"
this
.
_constants
.
LOOP_MAU_TYPE
.
ROOM_OPEN
]
)
;
}
updateRoomContext
:
function
updateRoomContext
(
actionData
)
{
this
.
setStoreState
(
{
savingContext
:
true
}
)
;
loop
.
request
(
"
Rooms
:
Get
"
actionData
.
roomToken
)
.
then
(
function
(
result
)
{
if
(
result
.
isError
)
{
this
.
dispatchAction
(
new
sharedActions
.
UpdateRoomContextError
(
{
error
:
result
}
)
)
;
return
;
}
var
roomData
=
{
}
;
var
context
=
result
.
decryptedContext
;
var
oldRoomName
=
context
.
roomName
;
var
newRoomName
=
(
actionData
.
newRoomName
|
|
"
"
)
.
trim
(
)
;
if
(
newRoomName
&
&
oldRoomName
!
=
=
newRoomName
)
{
roomData
.
roomName
=
newRoomName
;
}
var
oldRoomURLs
=
context
.
urls
;
var
oldRoomURL
=
oldRoomURLs
&
&
oldRoomURLs
[
0
]
;
var
newRoomURL
=
loop
.
shared
.
utils
.
stripFalsyValues
(
{
location
:
(
actionData
.
newRoomURL
|
|
"
"
)
.
trim
(
)
thumbnail
:
(
actionData
.
newRoomThumbnail
|
|
"
"
)
.
trim
(
)
description
:
(
actionData
.
newRoomDescription
|
|
"
"
)
.
trim
(
)
}
)
;
var
diff
=
loop
.
shared
.
utils
.
objectDiff
(
oldRoomURL
newRoomURL
)
;
if
(
diff
.
added
.
length
|
|
diff
.
updated
.
length
)
{
newRoomURL
=
_
.
extend
(
oldRoomURL
|
|
{
}
newRoomURL
)
;
var
isValidURL
=
false
;
try
{
isValidURL
=
new
URL
(
newRoomURL
.
location
)
;
}
catch
(
ex
)
{
}
if
(
isValidURL
)
{
roomData
.
urls
=
[
newRoomURL
]
;
}
}
if
(
!
Object
.
getOwnPropertyNames
(
roomData
)
.
length
)
{
setTimeout
(
function
(
)
{
this
.
dispatchAction
(
new
sharedActions
.
UpdateRoomContextDone
(
)
)
;
}
.
bind
(
this
)
0
)
;
return
;
}
this
.
setStoreState
(
{
error
:
null
}
)
;
loop
.
request
(
"
Rooms
:
Update
"
actionData
.
roomToken
roomData
)
.
then
(
function
(
result2
)
{
var
isError
=
result2
&
&
result2
.
isError
;
var
action
=
isError
?
new
sharedActions
.
UpdateRoomContextError
(
{
error
:
result2
}
)
:
new
sharedActions
.
UpdateRoomContextDone
(
)
;
this
.
dispatchAction
(
action
)
;
}
.
bind
(
this
)
)
;
}
.
bind
(
this
)
)
;
}
updateRoomContextDone
:
function
updateRoomContextDone
(
)
{
this
.
setStoreState
(
{
savingContext
:
false
}
)
;
}
updateRoomContextError
:
function
updateRoomContextError
(
actionData
)
{
this
.
setStoreState
(
{
error
:
actionData
.
error
savingContext
:
false
}
)
;
}
}
)
;
}
)
(
document
.
mozL10n
|
|
navigator
.
mozL10n
)
;
