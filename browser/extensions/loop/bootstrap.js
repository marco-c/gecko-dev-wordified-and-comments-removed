"
use
strict
"
;
const
{
interfaces
:
Ci
utils
:
Cu
classes
:
Cc
}
=
Components
;
const
kNSXUL
=
"
http
:
/
/
www
.
mozilla
.
org
/
keymaster
/
gatekeeper
/
there
.
is
.
only
.
xul
"
;
const
kBrowserSharingNotificationId
=
"
loop
-
sharing
-
notification
"
;
const
CURSOR_MIN_DELTA
=
3
;
const
CURSOR_MIN_INTERVAL
=
100
;
const
CURSOR_CLICK_DELAY
=
1000
;
const
FRAME_SCRIPT
=
"
chrome
:
/
/
loop
/
content
/
modules
/
tabFrame
.
js
?
"
+
Math
.
random
(
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PrivateBrowsingUtils
"
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
CustomizableUI
"
"
resource
:
/
/
/
modules
/
CustomizableUI
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Task
"
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
const
PREF_LOG_LEVEL
=
"
loop
.
debug
.
loglevel
"
;
XPCOMUtils
.
defineLazyGetter
(
this
"
log
"
(
)
=
>
{
let
ConsoleAPI
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Console
.
jsm
"
{
}
)
.
ConsoleAPI
;
let
consoleOptions
=
{
maxLogLevelPref
:
PREF_LOG_LEVEL
prefix
:
"
Loop
"
}
;
return
new
ConsoleAPI
(
consoleOptions
)
;
}
)
;
var
WindowListener
=
{
addonVersion
:
"
unknown
"
setupBrowserUI
:
function
(
window
)
{
let
document
=
window
.
document
;
let
{
gBrowser
gURLBar
}
=
window
;
let
xhrClass
=
Cc
[
"
mozilla
.
org
/
xmlextras
/
xmlhttprequest
;
1
"
]
;
let
FileReader
=
window
.
FileReader
;
let
menuItem
=
null
;
let
isSlideshowOpen
=
false
;
let
titleChangedListener
=
null
;
var
LoopUI
=
{
get
toolbarButton
(
)
{
delete
this
.
toolbarButton
;
return
(
this
.
toolbarButton
=
CustomizableUI
.
getWidget
(
"
loop
-
button
"
)
.
forWindow
(
window
)
)
;
}
get
panel
(
)
{
delete
this
.
panel
;
return
(
this
.
panel
=
document
.
getElementById
(
"
loop
-
notification
-
panel
"
)
)
;
}
get
browser
(
)
{
let
browser
=
document
.
querySelector
(
"
#
loop
-
notification
-
panel
>
#
loop
-
panel
-
iframe
"
)
;
if
(
browser
)
{
delete
this
.
browser
;
this
.
browser
=
browser
;
}
return
browser
;
}
get
isSlideshowOpen
(
)
{
return
isSlideshowOpen
;
}
set
isSlideshowOpen
(
aOpen
)
{
isSlideshowOpen
=
aOpen
;
this
.
updateToolbarState
(
)
;
}
get
constants
(
)
{
if
(
!
this
.
_constants
)
{
this
.
LoopAPI
.
sendMessageToHandler
(
{
name
:
"
GetAllConstants
"
}
result
=
>
{
this
.
_constants
=
result
;
}
)
;
}
return
this
.
_constants
;
}
get
mm
(
)
{
return
window
.
getGroupMessageManager
(
"
browsers
"
)
;
}
promiseDocumentVisible
(
aDocument
)
{
if
(
!
aDocument
.
hidden
)
{
return
Promise
.
resolve
(
aDocument
)
;
}
return
new
Promise
(
(
resolve
)
=
>
{
aDocument
.
addEventListener
(
"
visibilitychange
"
function
onVisibilityChanged
(
)
{
aDocument
.
removeEventListener
(
"
visibilitychange
"
onVisibilityChanged
)
;
resolve
(
aDocument
)
;
}
)
;
}
)
;
}
togglePanel
:
function
(
event
)
{
if
(
!
this
.
panel
)
{
let
obs
=
win
=
>
{
Services
.
obs
.
removeObserver
(
obs
"
browser
-
delayed
-
startup
-
finished
"
)
;
win
.
LoopUI
.
togglePanel
(
event
)
;
}
;
Services
.
obs
.
addObserver
(
obs
"
browser
-
delayed
-
startup
-
finished
"
false
)
;
return
window
.
OpenBrowserWindow
(
)
;
}
if
(
this
.
panel
.
state
=
=
"
open
"
)
{
return
new
Promise
(
resolve
=
>
{
this
.
panel
.
hidePopup
(
)
;
resolve
(
)
;
}
)
;
}
if
(
this
.
isSlideshowOpen
)
{
return
Promise
.
resolve
(
)
;
}
return
this
.
openPanel
(
event
)
.
then
(
mm
=
>
{
if
(
mm
)
{
mm
.
sendAsyncMessage
(
"
Social
:
EnsureFocusElement
"
)
;
}
}
)
.
catch
(
err
=
>
{
Cu
.
reportError
(
err
)
;
}
)
;
}
renameRoom
:
function
(
)
{
this
.
openPanel
(
)
;
}
openPanel
:
function
(
event
)
{
if
(
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
{
return
Promise
.
reject
(
)
;
}
return
new
Promise
(
(
resolve
)
=
>
{
let
callback
=
iframe
=
>
{
let
mm
=
iframe
.
QueryInterface
(
Ci
.
nsIFrameLoaderOwner
)
.
frameLoader
.
messageManager
;
if
(
!
(
"
messageManager
"
in
iframe
)
)
{
iframe
.
messageManager
=
mm
;
}
if
(
!
this
.
_panelInitialized
)
{
this
.
hookWindowCloseForPanelClose
(
iframe
)
;
this
.
_panelInitialized
=
true
;
}
mm
.
sendAsyncMessage
(
"
Social
:
WaitForDocumentVisible
"
)
;
mm
.
addMessageListener
(
"
Social
:
DocumentVisible
"
function
onDocumentVisible
(
)
{
mm
.
removeMessageListener
(
"
Social
:
DocumentVisible
"
onDocumentVisible
)
;
resolve
(
mm
)
;
}
)
;
let
buckets
=
this
.
constants
.
LOOP_MAU_TYPE
;
this
.
LoopAPI
.
sendMessageToHandler
(
{
name
:
"
TelemetryAddValue
"
data
:
[
"
LOOP_ACTIVITY_COUNTER
"
buckets
.
OPEN_PANEL
]
}
)
;
}
;
Services
.
obs
.
notifyObservers
(
null
"
loop
-
status
-
changed
"
null
)
;
this
.
shouldResumeTour
(
)
.
then
(
(
resume
)
=
>
{
if
(
resume
)
{
this
.
MozLoopService
.
resumeTour
(
"
waiting
"
)
;
resolve
(
null
)
;
return
;
}
this
.
LoopAPI
.
initialize
(
)
;
let
anchor
=
event
?
event
.
target
:
this
.
toolbarButton
.
anchor
;
this
.
PanelFrame
.
showPopup
(
window
anchor
"
loop
"
null
"
about
:
looppanel
"
null
callback
)
;
}
)
;
}
)
;
}
openCallPanel
:
function
(
event
)
{
return
this
.
openPanel
(
event
)
;
}
shouldResumeTour
:
Task
.
async
(
function
*
(
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
"
loop
.
gettingStarted
.
resumeOnFirstJoin
"
)
)
{
return
false
;
}
if
(
!
this
.
LoopRooms
.
participantsCount
)
{
return
false
;
}
let
roomsWithNonOwners
=
yield
this
.
roomsWithNonOwners
(
)
;
if
(
!
roomsWithNonOwners
.
length
)
{
return
false
;
}
return
true
;
}
)
roomsWithNonOwners
:
function
(
)
{
return
new
Promise
(
resolve
=
>
{
this
.
LoopRooms
.
getAll
(
(
error
rooms
)
=
>
{
let
roomsWithNonOwners
=
[
]
;
for
(
let
room
of
rooms
)
{
if
(
!
(
"
participants
"
in
room
)
)
{
continue
;
}
let
numNonOwners
=
room
.
participants
.
filter
(
participant
=
>
!
participant
.
owner
)
.
length
;
if
(
!
numNonOwners
)
{
continue
;
}
roomsWithNonOwners
.
push
(
room
)
;
}
resolve
(
roomsWithNonOwners
)
;
}
)
;
}
)
;
}
init
:
function
(
)
{
this
.
MozLoopService
.
initialize
(
WindowListener
.
addonVersion
)
.
catch
(
ex
=
>
{
if
(
!
ex
.
message
|
|
(
!
ex
.
message
.
contains
(
"
not
enabled
"
)
&
&
!
ex
.
message
.
contains
(
"
not
needed
"
)
)
)
{
console
.
error
(
ex
)
;
}
}
)
;
if
(
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
{
return
;
}
this
.
addMenuItem
(
)
;
if
(
window
=
=
Services
.
appShell
.
hiddenDOMWindow
)
{
return
;
}
this
.
mm
.
loadFrameScript
(
FRAME_SCRIPT
true
)
;
window
.
addEventListener
(
"
unload
"
(
)
=
>
{
Services
.
obs
.
removeObserver
(
this
"
loop
-
status
-
changed
"
)
;
}
)
;
Services
.
obs
.
addObserver
(
this
"
loop
-
status
-
changed
"
false
)
;
this
.
maybeAddCopyPanel
(
)
;
this
.
updateToolbarState
(
)
;
}
addMenuItem
:
function
(
)
{
let
menu
=
document
.
getElementById
(
"
menu_ToolsPopup
"
)
;
if
(
!
menu
|
|
menuItem
)
{
return
;
}
menuItem
=
document
.
createElementNS
(
kNSXUL
"
menuitem
"
)
;
menuItem
.
setAttribute
(
"
id
"
"
menu_openLoop
"
)
;
menuItem
.
setAttribute
(
"
label
"
this
.
_getString
(
"
loopMenuItem_label
"
)
)
;
menuItem
.
setAttribute
(
"
accesskey
"
this
.
_getString
(
"
loopMenuItem_accesskey
"
)
)
;
menuItem
.
addEventListener
(
"
command
"
(
)
=
>
this
.
togglePanel
(
)
)
;
menu
.
insertBefore
(
menuItem
document
.
getElementById
(
"
sync
-
setup
"
)
)
;
}
removeMenuItem
:
function
(
)
{
if
(
menuItem
)
{
menuItem
.
parentNode
.
removeChild
(
menuItem
)
;
}
}
maybeAddCopyPanel
(
)
{
if
(
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
|
|
Services
.
prefs
.
getBoolPref
(
"
loop
.
copy
.
shown
"
)
|
|
Services
.
prefs
.
getIntPref
(
"
loop
.
copy
.
showLimit
"
)
<
=
0
)
{
return
Promise
.
resolve
(
)
;
}
return
Throttler
.
check
(
"
loop
.
copy
"
)
.
then
(
(
)
=
>
this
.
addCopyPanel
(
)
)
;
}
addCopyPanel
(
onClickHandled
)
{
let
copy
=
this
.
panel
.
cloneNode
(
false
)
;
copy
.
id
=
"
loop
-
copy
-
notification
-
panel
"
;
this
.
panel
.
parentNode
.
appendChild
(
copy
)
;
let
addTelemetry
=
bucket
=
>
{
this
.
LoopAPI
.
sendMessageToHandler
(
{
data
:
[
"
LOOP_COPY_PANEL_ACTIONS
"
this
.
constants
.
COPY_PANEL
[
bucket
]
]
name
:
"
TelemetryAddValue
"
}
)
;
}
;
let
onIframe
=
iframe
=
>
{
iframe
.
addEventListener
(
"
DOMContentLoaded
"
function
onLoad
(
)
{
iframe
.
removeEventListener
(
"
DOMContentLoaded
"
onLoad
)
;
iframe
.
contentWindow
.
requestAnimationFrame
(
(
)
=
>
{
let
height
=
iframe
.
contentDocument
.
documentElement
.
offsetHeight
;
height
+
=
copy
.
boxObject
.
height
-
iframe
.
boxObject
.
height
;
copy
.
style
.
height
=
height
+
"
px
"
;
}
)
;
iframe
.
contentWindow
.
addEventListener
(
"
CopyPanelClick
"
event
=
>
{
iframe
.
parentNode
.
hidePopup
(
)
;
let
{
accept
stop
}
=
event
.
detail
;
if
(
accept
)
{
LoopUI
.
openPanel
(
)
;
}
if
(
stop
)
{
LoopUI
.
removeCopyPanel
(
)
;
Services
.
prefs
.
setBoolPref
(
"
loop
.
copy
.
shown
"
true
)
;
}
let
probe
=
(
accept
?
"
YES
"
:
"
NO
"
)
+
"
_
"
+
(
stop
?
"
NEVER
"
:
"
AGAIN
"
)
;
addTelemetry
(
probe
)
;
try
{
onClickHandled
(
event
.
detail
)
;
}
catch
(
ex
)
{
}
}
)
;
}
)
;
}
;
let
controller
=
gURLBar
.
_copyCutController
;
controller
.
_doCommand
=
controller
.
doCommand
;
controller
.
doCommand
=
(
)
=
>
{
controller
.
_doCommand
.
apply
(
controller
arguments
)
;
let
showLimit
=
Services
.
prefs
.
getIntPref
(
"
loop
.
copy
.
showLimit
"
)
;
if
(
showLimit
<
=
0
)
{
LoopUI
.
removeCopyPanel
(
)
;
return
;
}
if
(
this
.
MozLoopService
.
screenShareActive
)
{
return
;
}
Services
.
prefs
.
setIntPref
(
"
loop
.
copy
.
showLimit
"
showLimit
-
1
)
;
addTelemetry
(
"
SHOWN
"
)
;
LoopUI
.
PanelFrame
.
showPopup
(
window
LoopUI
.
toolbarButton
.
anchor
"
loop
-
copy
"
null
"
chrome
:
/
/
loop
/
content
/
panels
/
copy
.
html
"
null
onIframe
)
;
}
;
}
removeCopyPanel
(
)
{
let
controller
=
gURLBar
&
&
gURLBar
.
_copyCutController
;
if
(
controller
&
&
controller
.
_doCommand
)
{
controller
.
doCommand
=
controller
.
_doCommand
;
delete
controller
.
_doCommand
;
}
let
copy
=
document
.
getElementById
(
"
loop
-
copy
-
notification
-
panel
"
)
;
if
(
copy
)
{
copy
.
parentNode
.
removeChild
(
copy
)
;
}
}
observe
:
function
(
subject
topic
data
)
{
if
(
topic
!
=
"
loop
-
status
-
changed
"
)
{
return
;
}
this
.
updateToolbarState
(
data
)
;
}
updateToolbarState
:
function
(
aReason
=
null
)
{
if
(
!
this
.
toolbarButton
.
node
)
{
return
;
}
let
state
=
"
"
;
let
mozL10nId
=
"
loop
-
call
-
button3
"
;
let
suffix
=
"
.
tooltiptext
"
;
if
(
this
.
MozLoopService
.
errors
.
size
)
{
state
=
"
error
"
;
mozL10nId
+
=
"
-
error
"
;
}
else
if
(
this
.
isSlideshowOpen
)
{
state
=
"
slideshow
"
;
}
else
if
(
this
.
MozLoopService
.
screenShareActive
)
{
state
=
"
action
"
;
mozL10nId
+
=
"
-
screensharing
"
;
}
else
if
(
aReason
=
=
"
login
"
&
&
this
.
MozLoopService
.
userProfile
)
{
state
=
"
active
"
;
mozL10nId
+
=
"
-
active
"
;
suffix
+
=
"
2
"
;
}
else
if
(
this
.
MozLoopService
.
doNotDisturb
)
{
state
=
"
disabled
"
;
mozL10nId
+
=
"
-
donotdisturb
"
;
}
else
if
(
this
.
MozLoopService
.
roomsParticipantsCount
>
0
)
{
state
=
"
active
"
;
this
.
roomsWithNonOwners
(
)
.
then
(
roomsWithNonOwners
=
>
{
if
(
roomsWithNonOwners
.
length
>
0
)
{
mozL10nId
+
=
"
-
participantswaiting
"
;
}
else
{
mozL10nId
+
=
"
-
active
"
;
}
suffix
+
=
"
2
"
;
this
.
updateTooltiptext
(
mozL10nId
+
suffix
)
;
this
.
toolbarButton
.
node
.
setAttribute
(
"
state
"
state
)
;
}
)
;
return
;
}
else
{
suffix
+
=
"
2
"
;
}
this
.
toolbarButton
.
node
.
setAttribute
(
"
state
"
state
)
;
this
.
updateTooltiptext
(
mozL10nId
+
suffix
)
;
}
updateTooltiptext
:
function
(
mozL10nId
)
{
this
.
toolbarButton
.
node
.
setAttribute
(
"
tooltiptext
"
mozL10nId
)
;
var
tooltiptext
=
CustomizableUI
.
getLocalizedProperty
(
this
.
toolbarButton
"
tooltiptext
"
)
;
this
.
toolbarButton
.
node
.
setAttribute
(
"
tooltiptext
"
tooltiptext
)
;
}
showNotification
:
function
(
options
)
{
if
(
this
.
MozLoopService
.
doNotDisturb
)
{
return
;
}
if
(
!
options
.
title
)
{
throw
new
Error
(
"
Missing
title
can
not
display
notification
"
)
;
}
let
notificationOptions
=
{
body
:
options
.
message
|
|
"
"
}
;
if
(
options
.
icon
)
{
notificationOptions
.
icon
=
options
.
icon
;
}
if
(
options
.
sound
)
{
notificationOptions
.
mozbehavior
=
{
soundFile
:
"
"
}
;
this
.
playSound
(
options
.
sound
)
;
}
let
notification
=
new
window
.
Notification
(
options
.
title
notificationOptions
)
;
notification
.
addEventListener
(
"
click
"
(
)
=
>
{
if
(
window
.
closed
)
{
return
;
}
try
{
window
.
focus
(
)
;
}
catch
(
ex
)
{
}
window
.
setTimeout
(
(
)
=
>
{
if
(
typeof
options
.
onclick
=
=
"
function
"
)
{
options
.
onclick
(
)
;
}
else
{
this
.
openPanel
(
null
options
.
selectTab
|
|
null
)
;
}
}
0
)
;
}
)
;
}
playSound
:
function
(
name
)
{
if
(
this
.
ActiveSound
|
|
this
.
MozLoopService
.
doNotDisturb
)
{
return
;
}
this
.
activeSound
=
new
window
.
Audio
(
)
;
this
.
activeSound
.
src
=
chrome
:
/
/
loop
/
content
/
shared
/
sounds
/
{
name
}
.
ogg
;
this
.
activeSound
.
load
(
)
;
this
.
activeSound
.
play
(
)
;
this
.
activeSound
.
addEventListener
(
"
ended
"
(
)
=
>
{
this
.
activeSound
=
undefined
;
}
false
)
;
}
startBrowserSharing
:
function
(
roomToken
)
{
if
(
!
this
.
_listeningToTabSelect
)
{
gBrowser
.
tabContainer
.
addEventListener
(
"
TabSelect
"
this
)
;
this
.
_listeningToTabSelect
=
true
;
titleChangedListener
=
this
.
handleDOMTitleChanged
.
bind
(
this
)
;
this
.
_roomsListener
=
this
.
handleRoomJoinedOrLeft
.
bind
(
this
)
;
this
.
LoopRooms
.
on
(
"
joined
"
this
.
_roomsListener
)
;
this
.
LoopRooms
.
on
(
"
left
"
this
.
_roomsListener
)
;
this
.
mm
.
addMessageListener
(
"
loop
mozilla
.
org
:
DOMTitleChanged
"
titleChangedListener
)
;
this
.
_browserSharePaused
=
false
;
gBrowser
.
addEventListener
(
"
mousemove
"
this
)
;
gBrowser
.
addEventListener
(
"
click
"
this
)
;
}
this
.
_currentRoomToken
=
roomToken
;
this
.
_maybeShowBrowserSharingInfoBar
(
roomToken
)
;
let
browser
=
gBrowser
.
selectedBrowser
;
return
new
Promise
(
resolve
=
>
{
if
(
browser
.
outerWindowID
)
{
resolve
(
browser
.
outerWindowID
)
;
return
;
}
browser
.
messageManager
.
addMessageListener
(
"
Browser
:
Init
"
function
initListener
(
)
{
browser
.
messageManager
.
removeMessageListener
(
"
Browser
:
Init
"
initListener
)
;
resolve
(
browser
.
outerWindowID
)
;
}
)
;
}
)
.
then
(
outerWindowID
=
>
this
.
LoopAPI
.
broadcastPushMessage
(
"
BrowserSwitch
"
outerWindowID
)
)
;
}
stopBrowserSharing
:
function
(
)
{
if
(
!
this
.
_listeningToTabSelect
)
{
return
;
}
this
.
_hideBrowserSharingInfoBar
(
)
;
gBrowser
.
tabContainer
.
removeEventListener
(
"
TabSelect
"
this
)
;
this
.
LoopRooms
.
off
(
"
joined
"
this
.
_roomsListener
)
;
this
.
LoopRooms
.
off
(
"
left
"
this
.
_roomsListener
)
;
if
(
titleChangedListener
)
{
this
.
mm
.
removeMessageListener
(
"
loop
mozilla
.
org
:
DOMTitleChanged
"
titleChangedListener
)
;
titleChangedListener
=
null
;
}
gBrowser
.
removeEventListener
(
"
mousemove
"
this
)
;
gBrowser
.
removeEventListener
(
"
click
"
this
)
;
this
.
removeRemoteCursor
(
)
;
this
.
_listeningToTabSelect
=
false
;
this
.
_browserSharePaused
=
false
;
this
.
_currentRoomToken
=
null
;
this
.
_sendTelemetryEventsIfNeeded
(
)
;
}
_sendTelemetryEventsIfNeeded
:
function
(
)
{
if
(
!
this
.
_pauseButtonClicked
)
{
return
;
}
let
buckets
=
this
.
constants
.
SHARING_SCREEN
;
this
.
LoopAPI
.
sendMessageToHandler
(
{
name
:
"
TelemetryAddValue
"
data
:
[
"
LOOP_INFOBAR_ACTION_BUTTONS
"
buckets
.
PAUSED
]
}
)
;
if
(
this
.
_resumeButtonClicked
)
{
this
.
LoopAPI
.
sendMessageToHandler
(
{
name
:
"
TelemetryAddValue
"
data
:
[
"
LOOP_INFOBAR_ACTION_BUTTONS
"
buckets
.
RESUMED
]
}
)
;
}
this
.
_pauseButtonClicked
=
false
;
this
.
_resumeButtonClicked
=
false
;
}
addRemoteCursor
:
function
(
cursorData
)
{
if
(
this
.
_browserSharePaused
|
|
!
this
.
_listeningToTabSelect
)
{
return
;
}
let
browser
=
gBrowser
.
selectedBrowser
;
let
cursor
=
document
.
getElementById
(
"
loop
-
remote
-
cursor
"
)
;
if
(
!
cursor
)
{
let
cursorContainer
=
document
.
createElement
(
"
div
"
)
;
cursorContainer
.
setAttribute
(
"
id
"
"
loop
-
remote
-
cursor
-
container
"
)
;
cursor
=
document
.
createElement
(
"
img
"
)
;
cursor
.
setAttribute
(
"
id
"
"
loop
-
remote
-
cursor
"
)
;
cursorContainer
.
appendChild
(
cursor
)
;
browser
.
parentNode
.
appendChild
(
cursorContainer
)
;
}
cursor
.
style
.
left
=
Math
.
abs
(
cursorData
.
ratioX
*
browser
.
boxObject
.
width
)
+
"
px
"
;
cursor
.
style
.
top
=
Math
.
abs
(
cursorData
.
ratioY
*
browser
.
boxObject
.
height
)
+
"
px
"
;
}
clickRemoteCursor
:
function
(
clickData
)
{
if
(
!
clickData
|
|
!
this
.
_listeningToTabSelect
)
{
return
;
}
let
class_name
=
"
clicked
"
;
let
cursor
=
document
.
getElementById
(
"
loop
-
remote
-
cursor
"
)
;
if
(
!
cursor
)
{
return
;
}
cursor
.
classList
.
add
(
class_name
)
;
window
.
setTimeout
(
(
)
=
>
{
cursor
.
classList
.
remove
(
class_name
)
;
}
CURSOR_CLICK_DELAY
)
;
}
removeRemoteCursor
:
function
(
)
{
let
cursor
=
document
.
getElementById
(
"
loop
-
remote
-
cursor
"
)
;
if
(
cursor
)
{
cursor
.
parentNode
.
removeChild
(
cursor
)
;
}
}
_getString
:
function
(
key
)
{
let
str
=
this
.
MozLoopService
.
getStrings
(
key
)
;
if
(
str
)
{
str
=
JSON
.
parse
(
str
)
.
textContent
;
}
return
str
;
}
_setInfoBarStrings
:
function
(
nonOwnerParticipants
sharePaused
)
{
let
message
;
if
(
nonOwnerParticipants
)
{
message
=
this
.
_getString
(
sharePaused
?
"
infobar_screenshare_stop_sharing_message2
"
:
"
infobar_screenshare_browser_message3
"
)
;
}
else
{
message
=
this
.
_getString
(
sharePaused
?
"
infobar_screenshare_stop_no_guest_message
"
:
"
infobar_screenshare_no_guest_message
"
)
;
}
let
label
=
this
.
_getString
(
sharePaused
?
"
infobar_button_restart_label2
"
:
"
infobar_button_stop_label2
"
)
;
let
accessKey
=
this
.
_getString
(
sharePaused
?
"
infobar_button_restart_accesskey
"
:
"
infobar_button_stop_accesskey
"
)
;
return
{
message
:
message
label
:
label
accesskey
:
accessKey
}
;
}
_browserSharePaused
:
false
_maybeShowBrowserSharingInfoBar
:
function
(
currentRoomToken
)
{
this
.
_hideBrowserSharingInfoBar
(
)
;
let
participantsCount
=
this
.
LoopRooms
.
getNumParticipants
(
currentRoomToken
)
;
let
initStrings
=
this
.
_setInfoBarStrings
(
participantsCount
>
1
this
.
_browserSharePaused
)
;
let
box
=
gBrowser
.
getNotificationBox
(
)
;
let
bar
=
box
.
appendNotification
(
initStrings
.
message
kBrowserSharingNotificationId
null
box
.
PRIORITY_WARNING_LOW
[
{
label
:
initStrings
.
label
accessKey
:
initStrings
.
accesskey
isDefault
:
false
callback
:
(
event
buttonInfo
buttonNode
)
=
>
{
this
.
_browserSharePaused
=
!
this
.
_browserSharePaused
;
let
guestPresent
=
this
.
LoopRooms
.
getNumParticipants
(
this
.
_currentRoomToken
)
>
1
;
let
stringObj
=
this
.
_setInfoBarStrings
(
guestPresent
this
.
_browserSharePaused
)
;
bar
.
label
=
stringObj
.
message
;
bar
.
classList
.
toggle
(
"
paused
"
this
.
_browserSharePaused
)
;
buttonNode
.
label
=
stringObj
.
label
;
buttonNode
.
accessKey
=
stringObj
.
accesskey
;
LoopUI
.
MozLoopService
.
toggleBrowserSharing
(
this
.
_browserSharePaused
)
;
if
(
this
.
_browserSharePaused
)
{
this
.
_pauseButtonClicked
=
true
;
this
.
removeRemoteCursor
(
)
;
}
else
{
this
.
_resumeButtonClicked
=
true
;
}
return
true
;
}
type
:
"
pause
"
}
{
label
:
this
.
_getString
(
"
infobar_button_disconnect_label
"
)
accessKey
:
this
.
_getString
(
"
infobar_button_disconnect_accesskey
"
)
isDefault
:
true
callback
:
(
)
=
>
{
this
.
removeRemoteCursor
(
)
;
this
.
_hideBrowserSharingInfoBar
(
)
;
LoopUI
.
MozLoopService
.
hangupAllChatWindows
(
)
;
}
type
:
"
stop
"
}
]
)
;
bar
.
classList
.
toggle
(
"
paused
"
!
!
this
.
_browserSharePaused
)
;
bar
.
persistence
=
-
1
;
}
_hideBrowserSharingInfoBar
:
function
(
browser
)
{
browser
=
browser
|
|
gBrowser
.
selectedBrowser
;
let
box
=
gBrowser
.
getNotificationBox
(
browser
)
;
let
notification
=
box
.
getNotificationWithValue
(
kBrowserSharingNotificationId
)
;
let
removed
=
false
;
if
(
notification
)
{
box
.
removeNotification
(
notification
)
;
removed
=
true
;
}
return
removed
;
}
_notifyBrowserSwitch
:
function
(
)
{
this
.
LoopAPI
.
broadcastPushMessage
(
"
BrowserSwitch
"
gBrowser
.
selectedBrowser
.
outerWindowID
)
;
}
handleRoomJoinedOrLeft
:
function
(
)
{
if
(
!
this
.
_listeningToTabSelect
)
{
return
;
}
this
.
_maybeShowBrowserSharingInfoBar
(
this
.
_currentRoomToken
)
;
}
handleDOMTitleChanged
:
function
(
message
)
{
if
(
!
this
.
_listeningToTabSelect
|
|
this
.
_browserSharePaused
)
{
return
;
}
if
(
gBrowser
.
selectedBrowser
=
=
message
.
target
)
{
this
.
_notifyBrowserSwitch
(
)
;
}
}
handleEvent
:
function
(
event
)
{
switch
(
event
.
type
)
{
case
"
TabSelect
"
:
{
let
wasVisible
=
false
;
if
(
event
.
detail
.
previousTab
)
{
wasVisible
=
this
.
_hideBrowserSharingInfoBar
(
event
.
detail
.
previousTab
.
linkedBrowser
)
;
this
.
removeRemoteCursor
(
)
;
}
this
.
_notifyBrowserSwitch
(
)
;
if
(
wasVisible
)
{
this
.
_maybeShowBrowserSharingInfoBar
(
this
.
_currentRoomToken
)
;
}
break
;
}
case
"
mousemove
"
:
this
.
handleMousemove
(
event
)
;
break
;
case
"
click
"
:
this
.
handleMouseClick
(
event
)
;
break
;
}
}
handleMousemove
:
function
(
event
)
{
if
(
this
.
_browserSharePaused
|
|
!
this
.
_listeningToTabSelect
)
{
return
;
}
let
now
=
Date
.
now
(
)
;
if
(
now
-
this
.
lastCursorTime
<
CURSOR_MIN_INTERVAL
)
{
return
;
}
this
.
lastCursorTime
=
now
;
let
browserBox
=
gBrowser
.
selectedBrowser
.
boxObject
;
let
deltaX
=
event
.
screenX
-
browserBox
.
screenX
;
let
deltaY
=
event
.
screenY
-
browserBox
.
screenY
;
if
(
deltaX
<
0
|
|
deltaX
>
browserBox
.
width
|
|
deltaY
<
0
|
|
deltaY
>
browserBox
.
height
|
|
(
Math
.
abs
(
deltaX
-
this
.
lastCursorX
)
<
CURSOR_MIN_DELTA
&
&
Math
.
abs
(
deltaY
-
this
.
lastCursorY
)
<
CURSOR_MIN_DELTA
)
)
{
return
;
}
this
.
lastCursorX
=
deltaX
;
this
.
lastCursorY
=
deltaY
;
this
.
LoopAPI
.
broadcastPushMessage
(
"
CursorPositionChange
"
{
ratioX
:
deltaX
/
browserBox
.
width
ratioY
:
deltaY
/
browserBox
.
height
}
)
;
}
handleMouseClick
:
function
(
)
{
if
(
this
.
_browserSharePaused
)
{
return
;
}
this
.
LoopAPI
.
broadcastPushMessage
(
"
CursorClick
"
)
;
}
getFavicon
:
function
(
callback
)
{
let
pageURI
=
gBrowser
.
selectedTab
.
linkedBrowser
.
currentURI
.
spec
;
if
(
!
/
^
https
?
:
/
.
test
(
pageURI
)
)
{
callback
(
)
;
return
;
}
this
.
PlacesUtils
.
promiseFaviconLinkUrl
(
pageURI
)
.
then
(
uri
=
>
{
let
xhr
=
xhrClass
.
createInstance
(
Ci
.
nsIXMLHttpRequest
)
;
xhr
.
open
(
"
get
"
uri
.
spec
true
)
;
xhr
.
responseType
=
"
blob
"
;
xhr
.
overrideMimeType
(
"
image
/
x
-
icon
"
)
;
xhr
.
onload
=
(
)
=
>
{
if
(
xhr
.
status
!
=
200
)
{
callback
(
new
Error
(
"
Invalid
status
code
received
for
favicon
XHR
:
"
+
xhr
.
status
)
)
;
return
;
}
let
reader
=
new
FileReader
(
)
;
reader
.
onload
=
reader
.
onload
=
(
)
=
>
callback
(
null
reader
.
result
)
;
reader
.
onerror
=
callback
;
reader
.
readAsDataURL
(
xhr
.
response
)
;
}
;
xhr
.
onerror
=
callback
;
xhr
.
send
(
)
;
}
)
.
catch
(
err
=
>
{
callback
(
err
|
|
new
Error
(
"
No
favicon
found
"
)
)
;
}
)
;
}
}
;
XPCOMUtils
.
defineLazyModuleGetter
(
LoopUI
"
hookWindowCloseForPanelClose
"
"
resource
:
/
/
gre
/
modules
/
MozSocialAPI
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
LoopUI
"
LoopAPI
"
"
chrome
:
/
/
loop
/
content
/
modules
/
MozLoopAPI
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
LoopUI
"
LoopRooms
"
"
chrome
:
/
/
loop
/
content
/
modules
/
LoopRooms
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
LoopUI
"
MozLoopService
"
"
chrome
:
/
/
loop
/
content
/
modules
/
MozLoopService
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
LoopUI
"
PanelFrame
"
"
resource
:
/
/
/
modules
/
PanelFrame
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
LoopUI
"
PlacesUtils
"
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
LoopUI
.
init
(
)
;
window
.
LoopUI
=
LoopUI
;
window
.
LoopThrottler
=
Throttler
;
}
tearDownBrowserUI
:
function
(
window
)
{
if
(
window
.
LoopUI
)
{
window
.
LoopUI
.
removeCopyPanel
(
)
;
window
.
LoopUI
.
removeMenuItem
(
)
;
window
.
LoopUI
.
mm
.
removeDelayedFrameScript
(
FRAME_SCRIPT
)
;
}
}
onOpenWindow
:
function
(
xulWindow
)
{
let
domWindow
=
xulWindow
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindow
)
;
domWindow
.
addEventListener
(
"
load
"
function
listener
(
)
{
domWindow
.
removeEventListener
(
"
load
"
listener
false
)
;
if
(
domWindow
.
document
.
documentElement
.
getAttribute
(
"
windowtype
"
)
=
=
"
navigator
:
browser
"
)
{
WindowListener
.
setupBrowserUI
(
domWindow
)
;
}
}
false
)
;
}
onCloseWindow
:
function
(
)
{
}
onWindowTitleChange
:
function
(
)
{
}
}
;
let
Throttler
=
{
TICKET_LIMIT
:
255
_dns
:
Cc
[
"
mozilla
.
org
/
network
/
dns
-
service
;
1
"
]
.
getService
(
Ci
.
nsIDNSService
)
check
(
prefPrefix
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
prefTicket
=
prefPrefix
+
"
.
ticket
"
;
let
ticket
=
Services
.
prefs
.
getIntPref
(
prefTicket
)
;
if
(
ticket
<
0
)
{
ticket
=
Math
.
floor
(
Math
.
random
(
)
*
this
.
TICKET_LIMIT
)
;
Services
.
prefs
.
setIntPref
(
prefTicket
ticket
)
;
}
else
if
(
ticket
>
=
this
.
TICKET_LIMIT
)
{
resolve
(
)
;
return
;
}
let
onDNS
=
(
request
record
)
=
>
{
if
(
record
=
=
=
null
)
{
reject
(
)
;
return
;
}
let
ipBlocks
=
record
.
getNextAddrAsString
(
)
.
split
(
"
.
"
)
;
if
(
ipBlocks
[
0
]
!
=
=
"
127
"
)
{
reject
(
)
;
return
;
}
let
index
=
1
;
switch
(
Services
.
prefs
.
getCharPref
(
"
app
.
update
.
channel
"
)
)
{
case
"
beta
"
:
index
=
2
;
break
;
case
"
aurora
"
:
case
"
nightly
"
:
index
=
3
;
break
;
}
if
(
ticket
<
ipBlocks
[
index
]
)
{
Services
.
prefs
.
setIntPref
(
prefTicket
this
.
TICKET_LIMIT
)
;
resolve
(
)
;
}
else
{
reject
(
)
;
}
}
;
this
.
_dns
.
asyncResolve
(
Services
.
prefs
.
getCharPref
(
prefPrefix
+
"
.
throttler
"
)
this
.
_dns
.
RESOLVE_DISABLE_IPV6
onDNS
Services
.
tm
.
mainThread
)
;
}
)
;
}
}
;
function
createLoopButton
(
)
{
CustomizableUI
.
createWidget
(
{
id
:
"
loop
-
button
"
type
:
"
custom
"
label
:
"
loop
-
call
-
button3
.
label
"
tooltiptext
:
"
loop
-
call
-
button3
.
tooltiptext2
"
privateBrowsingTooltiptext
:
"
loop
-
call
-
button3
-
pb
.
tooltiptext
"
defaultArea
:
CustomizableUI
.
AREA_NAVBAR
removable
:
true
onBuild
:
function
(
aDocument
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
"
loop
.
enabled
"
)
)
{
return
null
;
}
let
isWindowPrivate
=
PrivateBrowsingUtils
.
isWindowPrivate
(
aDocument
.
defaultView
)
;
let
node
=
aDocument
.
createElementNS
(
kNSXUL
"
toolbarbutton
"
)
;
node
.
setAttribute
(
"
id
"
this
.
id
)
;
node
.
classList
.
add
(
"
toolbarbutton
-
1
"
)
;
node
.
classList
.
add
(
"
chromeclass
-
toolbar
-
additional
"
)
;
node
.
classList
.
add
(
"
badged
-
button
"
)
;
node
.
setAttribute
(
"
label
"
CustomizableUI
.
getLocalizedProperty
(
this
"
label
"
)
)
;
if
(
isWindowPrivate
)
{
node
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
let
tooltiptext
=
isWindowPrivate
?
CustomizableUI
.
getLocalizedProperty
(
this
"
privateBrowsingTooltiptext
"
[
CustomizableUI
.
getLocalizedProperty
(
this
"
label
"
)
]
)
:
CustomizableUI
.
getLocalizedProperty
(
this
"
tooltiptext
"
)
;
node
.
setAttribute
(
"
tooltiptext
"
tooltiptext
)
;
node
.
setAttribute
(
"
removable
"
"
true
"
)
;
node
.
addEventListener
(
"
command
"
function
(
event
)
{
aDocument
.
defaultView
.
LoopUI
.
togglePanel
(
event
)
;
}
)
;
return
node
;
}
}
)
;
}
function
loadDefaultPrefs
(
)
{
var
branch
=
Services
.
prefs
.
getDefaultBranch
(
"
"
)
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
loop
/
content
/
preferences
/
prefs
.
js
"
{
pref
:
(
key
val
)
=
>
{
if
(
branch
.
getPrefType
(
key
)
!
=
branch
.
PREF_INVALID
)
{
return
;
}
switch
(
typeof
val
)
{
case
"
boolean
"
:
branch
.
setBoolPref
(
key
val
)
;
break
;
case
"
number
"
:
branch
.
setIntPref
(
key
val
)
;
break
;
case
"
string
"
:
branch
.
setCharPref
(
key
val
)
;
break
;
}
}
}
)
;
if
(
Services
.
vc
.
compare
(
Services
.
appinfo
.
version
"
47
.
0a1
"
)
<
0
)
{
branch
.
setBoolPref
(
"
loop
.
remote
.
autostart
"
false
)
;
}
if
(
Services
.
vc
.
compare
(
Services
.
appinfo
.
version
"
47
.
0a1
"
)
>
=
0
&
&
Services
.
vc
.
compare
(
Services
.
appinfo
.
version
"
48
.
0a1
"
)
<
0
)
{
branch
.
setBoolPref
(
"
loop
.
conversationPopOut
.
enabled
"
false
)
;
}
}
function
startup
(
data
)
{
WindowListener
.
addonVersion
=
data
.
version
;
loadDefaultPrefs
(
)
;
if
(
!
Services
.
prefs
.
getBoolPref
(
"
loop
.
enabled
"
)
)
{
return
;
}
createLoopButton
(
)
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
try
{
WindowListener
.
setupBrowserUI
(
Services
.
appShell
.
hiddenDOMWindow
)
;
}
catch
(
ex
)
{
let
topic
=
"
browser
-
delayed
-
startup
-
finished
"
;
Services
.
obs
.
addObserver
(
function
observer
(
)
{
Services
.
obs
.
removeObserver
(
observer
topic
)
;
WindowListener
.
setupBrowserUI
(
Services
.
appShell
.
hiddenDOMWindow
)
;
}
topic
false
)
;
}
}
let
wm
=
Cc
[
"
mozilla
.
org
/
appshell
/
window
-
mediator
;
1
"
]
.
getService
(
Ci
.
nsIWindowMediator
)
;
let
windows
=
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
;
while
(
windows
.
hasMoreElements
(
)
)
{
let
domWindow
=
windows
.
getNext
(
)
.
QueryInterface
(
Ci
.
nsIDOMWindow
)
;
WindowListener
.
setupBrowserUI
(
domWindow
)
;
}
wm
.
addListener
(
WindowListener
)
;
let
styleSheetService
=
Cc
[
"
mozilla
.
org
/
content
/
style
-
sheet
-
service
;
1
"
]
.
getService
(
Components
.
interfaces
.
nsIStyleSheetService
)
;
let
sheets
=
[
"
chrome
:
/
/
loop
-
shared
/
skin
/
loop
.
css
"
]
;
if
(
AppConstants
.
platform
!
=
"
linux
"
)
{
sheets
.
push
(
"
chrome
:
/
/
loop
/
skin
/
platform
.
css
"
)
;
}
for
(
let
sheet
of
sheets
)
{
let
styleSheetURI
=
Services
.
io
.
newURI
(
sheet
null
null
)
;
styleSheetService
.
loadAndRegisterSheet
(
styleSheetURI
styleSheetService
.
AUTHOR_SHEET
)
;
}
}
function
shutdown
(
data
reason
)
{
Cu
.
import
(
"
resource
:
/
/
/
modules
/
Chat
.
jsm
"
)
;
let
isLoopURL
=
(
{
src
}
)
=
>
/
^
about
:
loopconversation
#
/
.
test
(
src
)
;
[
.
.
.
Chat
.
chatboxes
]
.
filter
(
isLoopURL
)
.
forEach
(
chatbox
=
>
{
chatbox
.
content
.
contentWindow
.
close
(
)
;
}
)
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
WindowListener
.
tearDownBrowserUI
(
Services
.
appShell
.
hiddenDOMWindow
)
;
}
let
wm
=
Cc
[
"
mozilla
.
org
/
appshell
/
window
-
mediator
;
1
"
]
.
getService
(
Ci
.
nsIWindowMediator
)
;
let
windows
=
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
;
while
(
windows
.
hasMoreElements
(
)
)
{
let
domWindow
=
windows
.
getNext
(
)
.
QueryInterface
(
Ci
.
nsIDOMWindow
)
;
WindowListener
.
tearDownBrowserUI
(
domWindow
)
;
}
wm
.
removeListener
(
WindowListener
)
;
if
(
reason
=
=
APP_SHUTDOWN
)
{
return
;
}
CustomizableUI
.
destroyWidget
(
"
loop
-
button
"
)
;
let
styleSheetService
=
Cc
[
"
mozilla
.
org
/
content
/
style
-
sheet
-
service
;
1
"
]
.
getService
(
Components
.
interfaces
.
nsIStyleSheetService
)
;
let
sheets
=
[
"
chrome
:
/
/
loop
/
content
/
addon
/
css
/
loop
.
css
"
"
chrome
:
/
/
loop
/
skin
/
platform
.
css
"
]
;
for
(
let
sheet
of
sheets
)
{
let
styleSheetURI
=
Services
.
io
.
newURI
(
sheet
null
null
)
;
if
(
styleSheetService
.
sheetRegistered
(
styleSheetURI
styleSheetService
.
AUTHOR_SHEET
)
)
{
styleSheetService
.
unregisterSheet
(
styleSheetURI
styleSheetService
.
AUTHOR_SHEET
)
;
}
}
Cu
.
unload
(
"
chrome
:
/
/
loop
/
content
/
modules
/
MozLoopAPI
.
jsm
"
)
;
Cu
.
unload
(
"
chrome
:
/
/
loop
/
content
/
modules
/
LoopRooms
.
jsm
"
)
;
Cu
.
unload
(
"
chrome
:
/
/
loop
/
content
/
modules
/
MozLoopService
.
jsm
"
)
;
}
function
install
(
)
{
}
function
uninstall
(
)
{
}
