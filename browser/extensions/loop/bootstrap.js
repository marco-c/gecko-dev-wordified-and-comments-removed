"
use
strict
"
;
var
_typeof
=
typeof
Symbol
=
=
=
"
function
"
&
&
typeof
Symbol
.
iterator
=
=
=
"
symbol
"
?
function
(
obj
)
{
return
typeof
obj
;
}
:
function
(
obj
)
{
return
obj
&
&
typeof
Symbol
=
=
=
"
function
"
&
&
obj
.
constructor
=
=
=
Symbol
?
"
symbol
"
:
typeof
obj
;
}
;
function
_toConsumableArray
(
arr
)
{
if
(
Array
.
isArray
(
arr
)
)
{
for
(
var
i
=
0
arr2
=
Array
(
arr
.
length
)
;
i
<
arr
.
length
;
i
+
+
)
{
arr2
[
i
]
=
arr
[
i
]
;
}
return
arr2
;
}
else
{
return
Array
.
from
(
arr
)
;
}
}
var
_Components
=
Components
;
var
Ci
=
_Components
.
interfaces
;
var
Cu
=
_Components
.
utils
;
var
Cc
=
_Components
.
classes
;
var
kNSXUL
=
"
http
:
/
/
www
.
mozilla
.
org
/
keymaster
/
gatekeeper
/
there
.
is
.
only
.
xul
"
;
var
kBrowserSharingNotificationId
=
"
loop
-
sharing
-
notification
"
;
var
CURSOR_MIN_DELTA
=
3
;
var
CURSOR_MIN_INTERVAL
=
100
;
var
CURSOR_CLICK_DELAY
=
1000
;
var
FRAME_SCRIPT
=
"
chrome
:
/
/
loop
/
content
/
modules
/
tabFrame
.
js
?
"
+
Math
.
random
(
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PrivateBrowsingUtils
"
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
CustomizableUI
"
"
resource
:
/
/
/
modules
/
CustomizableUI
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Task
"
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
var
PREF_LOG_LEVEL
=
"
loop
.
debug
.
loglevel
"
;
XPCOMUtils
.
defineLazyGetter
(
this
"
log
"
function
(
)
{
var
ConsoleAPI
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Console
.
jsm
"
{
}
)
.
ConsoleAPI
;
var
consoleOptions
=
{
maxLogLevelPref
:
PREF_LOG_LEVEL
prefix
:
"
Loop
"
}
;
return
new
ConsoleAPI
(
consoleOptions
)
;
}
)
;
var
WindowListener
=
{
addonVersion
:
"
unknown
"
setupBrowserUI
:
function
setupBrowserUI
(
window
)
{
var
document
=
window
.
document
;
var
gBrowser
=
window
.
gBrowser
;
var
gURLBar
=
window
.
gURLBar
;
var
xhrClass
=
Cc
[
"
mozilla
.
org
/
xmlextras
/
xmlhttprequest
;
1
"
]
;
var
FileReader
=
window
.
FileReader
;
var
menuItem
=
null
;
var
isSlideshowOpen
=
false
;
var
titleChangedListener
=
null
;
var
LoopUI
=
{
get
toolbarButton
(
)
{
delete
this
.
toolbarButton
;
return
this
.
toolbarButton
=
CustomizableUI
.
getWidget
(
"
loop
-
button
"
)
.
forWindow
(
window
)
;
}
get
panel
(
)
{
delete
this
.
panel
;
return
this
.
panel
=
document
.
getElementById
(
"
loop
-
notification
-
panel
"
)
;
}
get
browser
(
)
{
var
browser
=
document
.
querySelector
(
"
#
loop
-
notification
-
panel
>
#
loop
-
panel
-
iframe
"
)
;
if
(
browser
)
{
delete
this
.
browser
;
this
.
browser
=
browser
;
}
return
browser
;
}
get
isSlideshowOpen
(
)
{
return
isSlideshowOpen
;
}
set
isSlideshowOpen
(
aOpen
)
{
isSlideshowOpen
=
aOpen
;
this
.
updateToolbarState
(
)
;
}
get
constants
(
)
{
var
_this
=
this
;
if
(
!
this
.
_constants
)
{
this
.
LoopAPI
.
sendMessageToHandler
(
{
name
:
"
GetAllConstants
"
}
function
(
result
)
{
_this
.
_constants
=
result
;
}
)
;
}
return
this
.
_constants
;
}
get
mm
(
)
{
return
window
.
getGroupMessageManager
(
"
browsers
"
)
;
}
promiseDocumentVisible
:
function
promiseDocumentVisible
(
aDocument
)
{
if
(
!
aDocument
.
hidden
)
{
return
Promise
.
resolve
(
aDocument
)
;
}
return
new
Promise
(
function
(
resolve
)
{
aDocument
.
addEventListener
(
"
visibilitychange
"
function
onVisibilityChanged
(
)
{
aDocument
.
removeEventListener
(
"
visibilitychange
"
onVisibilityChanged
)
;
resolve
(
aDocument
)
;
}
)
;
}
)
;
}
togglePanel
:
function
togglePanel
(
event
)
{
var
_this2
=
this
;
if
(
!
this
.
panel
)
{
var
_ret
=
function
(
)
{
var
obs
=
function
obs
(
win
)
{
Services
.
obs
.
removeObserver
(
obs
"
browser
-
delayed
-
startup
-
finished
"
)
;
win
.
LoopUI
.
togglePanel
(
event
)
;
}
;
Services
.
obs
.
addObserver
(
obs
"
browser
-
delayed
-
startup
-
finished
"
false
)
;
return
{
v
:
window
.
OpenBrowserWindow
(
)
}
;
}
(
)
;
if
(
(
typeof
_ret
=
=
=
"
undefined
"
?
"
undefined
"
:
_typeof
(
_ret
)
)
=
=
=
"
object
"
)
return
_ret
.
v
;
}
if
(
this
.
panel
.
state
=
=
"
open
"
)
{
return
new
Promise
(
function
(
resolve
)
{
_this2
.
panel
.
hidePopup
(
)
;
resolve
(
)
;
}
)
;
}
if
(
this
.
isSlideshowOpen
)
{
return
Promise
.
resolve
(
)
;
}
return
this
.
openPanel
(
event
)
.
then
(
function
(
mm
)
{
if
(
mm
)
{
mm
.
sendAsyncMessage
(
"
Social
:
EnsureFocusElement
"
)
;
}
}
)
.
catch
(
function
(
err
)
{
Cu
.
reportError
(
err
)
;
}
)
;
}
renameRoom
:
function
renameRoom
(
)
{
this
.
openPanel
(
)
;
}
openPanel
:
function
openPanel
(
event
)
{
var
_this3
=
this
;
if
(
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
{
return
Promise
.
reject
(
)
;
}
return
new
Promise
(
function
(
resolve
)
{
var
callback
=
function
callback
(
iframe
)
{
var
mm
=
iframe
.
QueryInterface
(
Ci
.
nsIFrameLoaderOwner
)
.
frameLoader
.
messageManager
;
if
(
!
(
"
messageManager
"
in
iframe
)
)
{
iframe
.
messageManager
=
mm
;
}
if
(
!
_this3
.
_panelInitialized
)
{
_this3
.
hookWindowCloseForPanelClose
(
iframe
)
;
_this3
.
_panelInitialized
=
true
;
}
mm
.
sendAsyncMessage
(
"
Social
:
WaitForDocumentVisible
"
)
;
mm
.
addMessageListener
(
"
Social
:
DocumentVisible
"
function
onDocumentVisible
(
)
{
mm
.
removeMessageListener
(
"
Social
:
DocumentVisible
"
onDocumentVisible
)
;
resolve
(
mm
)
;
}
)
;
var
buckets
=
_this3
.
constants
.
LOOP_MAU_TYPE
;
_this3
.
LoopAPI
.
sendMessageToHandler
(
{
name
:
"
TelemetryAddValue
"
data
:
[
"
LOOP_ACTIVITY_COUNTER
"
buckets
.
OPEN_PANEL
]
}
)
;
}
;
Services
.
obs
.
notifyObservers
(
null
"
loop
-
status
-
changed
"
null
)
;
_this3
.
shouldResumeTour
(
)
.
then
(
function
(
resume
)
{
if
(
resume
)
{
_this3
.
MozLoopService
.
resumeTour
(
"
waiting
"
)
;
resolve
(
null
)
;
return
;
}
_this3
.
LoopAPI
.
initialize
(
)
;
var
anchor
=
event
?
event
.
target
:
_this3
.
toolbarButton
.
anchor
;
_this3
.
PanelFrame
.
showPopup
(
window
anchor
"
loop
"
null
"
about
:
looppanel
"
null
callback
)
;
}
)
;
}
)
;
}
openCallPanel
:
function
openCallPanel
(
event
)
{
return
this
.
openPanel
(
event
)
;
}
shouldResumeTour
:
Task
.
async
(
function
*
(
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
"
loop
.
gettingStarted
.
resumeOnFirstJoin
"
)
)
{
return
false
;
}
if
(
!
this
.
LoopRooms
.
participantsCount
)
{
return
false
;
}
var
roomsWithNonOwners
=
yield
this
.
roomsWithNonOwners
(
)
;
if
(
!
roomsWithNonOwners
.
length
)
{
return
false
;
}
return
true
;
}
)
roomsWithNonOwners
:
function
roomsWithNonOwners
(
)
{
var
_this4
=
this
;
return
new
Promise
(
function
(
resolve
)
{
_this4
.
LoopRooms
.
getAll
(
function
(
error
rooms
)
{
var
roomsWithNonOwners
=
[
]
;
var
_iteratorNormalCompletion
=
true
;
var
_didIteratorError
=
false
;
var
_iteratorError
=
undefined
;
try
{
for
(
var
_iterator
=
rooms
[
Symbol
.
iterator
]
(
)
_step
;
!
(
_iteratorNormalCompletion
=
(
_step
=
_iterator
.
next
(
)
)
.
done
)
;
_iteratorNormalCompletion
=
true
)
{
var
room
=
_step
.
value
;
if
(
!
(
"
participants
"
in
room
)
)
{
continue
;
}
var
numNonOwners
=
room
.
participants
.
filter
(
function
(
participant
)
{
return
!
participant
.
owner
;
}
)
.
length
;
if
(
!
numNonOwners
)
{
continue
;
}
roomsWithNonOwners
.
push
(
room
)
;
}
}
catch
(
err
)
{
_didIteratorError
=
true
;
_iteratorError
=
err
;
}
finally
{
try
{
if
(
!
_iteratorNormalCompletion
&
&
_iterator
.
return
)
{
_iterator
.
return
(
)
;
}
}
finally
{
if
(
_didIteratorError
)
{
throw
_iteratorError
;
}
}
}
resolve
(
roomsWithNonOwners
)
;
}
)
;
}
)
;
}
init
:
function
init
(
)
{
var
_this5
=
this
;
this
.
MozLoopService
.
initialize
(
WindowListener
.
addonVersion
)
.
catch
(
function
(
ex
)
{
if
(
!
ex
.
message
|
|
!
ex
.
message
.
contains
(
"
not
enabled
"
)
&
&
!
ex
.
message
.
contains
(
"
not
needed
"
)
)
{
console
.
error
(
ex
)
;
}
}
)
;
if
(
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
{
return
;
}
this
.
addMenuItem
(
)
;
if
(
window
=
=
Services
.
appShell
.
hiddenDOMWindow
)
{
return
;
}
this
.
mm
.
loadFrameScript
(
FRAME_SCRIPT
true
)
;
window
.
addEventListener
(
"
unload
"
function
(
)
{
Services
.
obs
.
removeObserver
(
_this5
"
loop
-
status
-
changed
"
)
;
}
)
;
Services
.
obs
.
addObserver
(
this
"
loop
-
status
-
changed
"
false
)
;
this
.
maybeAddCopyPanel
(
)
;
this
.
updateToolbarState
(
)
;
}
addMenuItem
:
function
addMenuItem
(
)
{
var
_this6
=
this
;
var
menu
=
document
.
getElementById
(
"
menu_ToolsPopup
"
)
;
if
(
!
menu
|
|
menuItem
)
{
return
;
}
menuItem
=
document
.
createElementNS
(
kNSXUL
"
menuitem
"
)
;
menuItem
.
setAttribute
(
"
id
"
"
menu_openLoop
"
)
;
menuItem
.
setAttribute
(
"
label
"
this
.
_getString
(
"
loopMenuItem_label
"
)
)
;
menuItem
.
setAttribute
(
"
accesskey
"
this
.
_getString
(
"
loopMenuItem_accesskey
"
)
)
;
menuItem
.
addEventListener
(
"
command
"
function
(
)
{
return
_this6
.
togglePanel
(
)
;
}
)
;
menu
.
insertBefore
(
menuItem
document
.
getElementById
(
"
sync
-
setup
"
)
)
;
}
removeMenuItem
:
function
removeMenuItem
(
)
{
if
(
menuItem
)
{
menuItem
.
parentNode
.
removeChild
(
menuItem
)
;
}
}
maybeAddCopyPanel
:
function
maybeAddCopyPanel
(
)
{
var
_this7
=
this
;
if
(
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
|
|
Services
.
prefs
.
getBoolPref
(
"
loop
.
copy
.
shown
"
)
|
|
Services
.
prefs
.
getIntPref
(
"
loop
.
copy
.
showLimit
"
)
<
=
0
)
{
return
Promise
.
resolve
(
)
;
}
return
Throttler
.
check
(
"
loop
.
copy
"
)
.
then
(
function
(
)
{
return
_this7
.
addCopyPanel
(
)
;
}
)
;
}
addCopyPanel
:
function
addCopyPanel
(
onClickHandled
)
{
var
_this8
=
this
_arguments
=
arguments
;
var
copy
=
this
.
panel
.
cloneNode
(
false
)
;
copy
.
id
=
"
loop
-
copy
-
notification
-
panel
"
;
this
.
panel
.
parentNode
.
appendChild
(
copy
)
;
var
addTelemetry
=
function
addTelemetry
(
bucket
)
{
_this8
.
LoopAPI
.
sendMessageToHandler
(
{
data
:
[
"
LOOP_COPY_PANEL_ACTIONS
"
_this8
.
constants
.
COPY_PANEL
[
bucket
]
]
name
:
"
TelemetryAddValue
"
}
)
;
}
;
var
onIframe
=
function
onIframe
(
iframe
)
{
iframe
.
addEventListener
(
"
DOMContentLoaded
"
function
onLoad
(
)
{
iframe
.
removeEventListener
(
"
DOMContentLoaded
"
onLoad
)
;
iframe
.
contentWindow
.
requestAnimationFrame
(
function
(
)
{
var
height
=
iframe
.
contentDocument
.
documentElement
.
offsetHeight
;
height
+
=
copy
.
boxObject
.
height
-
iframe
.
boxObject
.
height
;
copy
.
style
.
height
=
height
+
"
px
"
;
}
)
;
iframe
.
contentWindow
.
addEventListener
(
"
CopyPanelClick
"
function
(
event
)
{
iframe
.
parentNode
.
hidePopup
(
)
;
var
_event
detail
=
event
.
detail
;
var
accept
=
_event
detail
.
accept
;
var
stop
=
_event
detail
.
stop
;
if
(
accept
)
{
LoopUI
.
openPanel
(
)
;
}
if
(
stop
)
{
LoopUI
.
removeCopyPanel
(
)
;
Services
.
prefs
.
setBoolPref
(
"
loop
.
copy
.
shown
"
true
)
;
}
var
probe
=
(
accept
?
"
YES
"
:
"
NO
"
)
+
"
_
"
+
(
stop
?
"
NEVER
"
:
"
AGAIN
"
)
;
addTelemetry
(
probe
)
;
try
{
onClickHandled
(
event
.
detail
)
;
}
catch
(
ex
)
{
}
}
)
;
}
)
;
}
;
var
controller
=
gURLBar
.
_copyCutController
;
controller
.
_doCommand
=
controller
.
doCommand
;
controller
.
doCommand
=
function
(
)
{
controller
.
_doCommand
.
apply
(
controller
_arguments
)
;
var
showLimit
=
Services
.
prefs
.
getIntPref
(
"
loop
.
copy
.
showLimit
"
)
;
if
(
showLimit
<
=
0
)
{
LoopUI
.
removeCopyPanel
(
)
;
return
;
}
if
(
_this8
.
MozLoopService
.
screenShareActive
)
{
return
;
}
Services
.
prefs
.
setIntPref
(
"
loop
.
copy
.
showLimit
"
showLimit
-
1
)
;
addTelemetry
(
"
SHOWN
"
)
;
LoopUI
.
PanelFrame
.
showPopup
(
window
LoopUI
.
toolbarButton
.
anchor
"
loop
-
copy
"
null
"
chrome
:
/
/
loop
/
content
/
panels
/
copy
.
html
"
null
onIframe
)
;
}
;
}
removeCopyPanel
:
function
removeCopyPanel
(
)
{
var
controller
=
gURLBar
&
&
gURLBar
.
_copyCutController
;
if
(
controller
&
&
controller
.
_doCommand
)
{
controller
.
doCommand
=
controller
.
_doCommand
;
delete
controller
.
_doCommand
;
}
var
copy
=
document
.
getElementById
(
"
loop
-
copy
-
notification
-
panel
"
)
;
if
(
copy
)
{
copy
.
parentNode
.
removeChild
(
copy
)
;
}
}
observe
:
function
observe
(
subject
topic
data
)
{
if
(
topic
!
=
"
loop
-
status
-
changed
"
)
{
return
;
}
this
.
updateToolbarState
(
data
)
;
}
updateToolbarState
:
function
updateToolbarState
(
)
{
var
_this9
=
this
;
var
aReason
=
arguments
.
length
<
=
0
|
|
arguments
[
0
]
=
=
=
undefined
?
null
:
arguments
[
0
]
;
if
(
!
this
.
toolbarButton
.
node
)
{
return
;
}
var
state
=
"
"
;
var
mozL10nId
=
"
loop
-
call
-
button3
"
;
var
suffix
=
"
.
tooltiptext
"
;
if
(
this
.
MozLoopService
.
errors
.
size
)
{
state
=
"
error
"
;
mozL10nId
+
=
"
-
error
"
;
}
else
if
(
this
.
isSlideshowOpen
)
{
state
=
"
slideshow
"
;
suffix
=
"
.
label
"
;
}
else
if
(
this
.
MozLoopService
.
screenShareActive
)
{
state
=
"
action
"
;
mozL10nId
+
=
"
-
screensharing
"
;
}
else
if
(
aReason
=
=
"
login
"
&
&
this
.
MozLoopService
.
userProfile
)
{
state
=
"
active
"
;
mozL10nId
+
=
"
-
active
"
;
suffix
+
=
"
2
"
;
}
else
if
(
this
.
MozLoopService
.
doNotDisturb
)
{
state
=
"
disabled
"
;
mozL10nId
+
=
"
-
donotdisturb
"
;
}
else
if
(
this
.
MozLoopService
.
roomsParticipantsCount
>
0
)
{
state
=
"
active
"
;
this
.
roomsWithNonOwners
(
)
.
then
(
function
(
roomsWithNonOwners
)
{
if
(
roomsWithNonOwners
.
length
>
0
)
{
mozL10nId
+
=
"
-
participantswaiting
"
;
}
else
{
mozL10nId
+
=
"
-
active
"
;
}
suffix
+
=
"
2
"
;
_this9
.
updateTooltiptext
(
mozL10nId
+
suffix
)
;
_this9
.
toolbarButton
.
node
.
setAttribute
(
"
state
"
state
)
;
}
)
;
return
;
}
else
{
suffix
+
=
"
2
"
;
}
this
.
toolbarButton
.
node
.
setAttribute
(
"
state
"
state
)
;
this
.
updateTooltiptext
(
mozL10nId
+
suffix
)
;
}
updateTooltiptext
:
function
updateTooltiptext
(
mozL10nId
)
{
this
.
toolbarButton
.
node
.
setAttribute
(
"
tooltiptext
"
mozL10nId
)
;
var
tooltiptext
=
CustomizableUI
.
getLocalizedProperty
(
this
.
toolbarButton
"
tooltiptext
"
)
;
this
.
toolbarButton
.
node
.
setAttribute
(
"
tooltiptext
"
tooltiptext
)
;
}
showNotification
:
function
showNotification
(
options
)
{
var
_this10
=
this
;
if
(
this
.
MozLoopService
.
doNotDisturb
)
{
return
;
}
if
(
!
options
.
title
)
{
throw
new
Error
(
"
Missing
title
can
not
display
notification
"
)
;
}
var
notificationOptions
=
{
body
:
options
.
message
|
|
"
"
}
;
if
(
options
.
icon
)
{
notificationOptions
.
icon
=
options
.
icon
;
}
if
(
options
.
sound
)
{
notificationOptions
.
mozbehavior
=
{
soundFile
:
"
"
}
;
this
.
playSound
(
options
.
sound
)
;
}
var
notification
=
new
window
.
Notification
(
options
.
title
notificationOptions
)
;
notification
.
addEventListener
(
"
click
"
function
(
)
{
if
(
window
.
closed
)
{
return
;
}
try
{
window
.
focus
(
)
;
}
catch
(
ex
)
{
}
window
.
setTimeout
(
function
(
)
{
if
(
typeof
options
.
onclick
=
=
"
function
"
)
{
options
.
onclick
(
)
;
}
else
{
_this10
.
openPanel
(
null
options
.
selectTab
|
|
null
)
;
}
}
0
)
;
}
)
;
}
playSound
:
function
playSound
(
name
)
{
var
_this11
=
this
;
if
(
this
.
ActiveSound
|
|
this
.
MozLoopService
.
doNotDisturb
)
{
return
;
}
this
.
activeSound
=
new
window
.
Audio
(
)
;
this
.
activeSound
.
src
=
"
chrome
:
/
/
loop
/
content
/
shared
/
sounds
/
"
+
name
+
"
.
ogg
"
;
this
.
activeSound
.
load
(
)
;
this
.
activeSound
.
play
(
)
;
this
.
activeSound
.
addEventListener
(
"
ended
"
function
(
)
{
_this11
.
activeSound
=
undefined
;
}
false
)
;
}
startBrowserSharing
:
function
startBrowserSharing
(
roomToken
)
{
var
_this12
=
this
;
if
(
!
this
.
_listeningToTabSelect
)
{
gBrowser
.
tabContainer
.
addEventListener
(
"
TabSelect
"
this
)
;
this
.
_listeningToTabSelect
=
true
;
titleChangedListener
=
this
.
handleDOMTitleChanged
.
bind
(
this
)
;
this
.
_roomsListener
=
this
.
handleRoomJoinedOrLeft
.
bind
(
this
)
;
this
.
LoopRooms
.
on
(
"
joined
"
this
.
_roomsListener
)
;
this
.
LoopRooms
.
on
(
"
left
"
this
.
_roomsListener
)
;
this
.
mm
.
addMessageListener
(
"
loop
mozilla
.
org
:
DOMTitleChanged
"
titleChangedListener
)
;
this
.
_browserSharePaused
=
false
;
gBrowser
.
addEventListener
(
"
mousemove
"
this
)
;
gBrowser
.
addEventListener
(
"
click
"
this
)
;
}
this
.
_currentRoomToken
=
roomToken
;
this
.
_maybeShowBrowserSharingInfoBar
(
roomToken
)
;
var
browser
=
gBrowser
.
selectedBrowser
;
return
new
Promise
(
function
(
resolve
)
{
if
(
browser
.
outerWindowID
)
{
resolve
(
browser
.
outerWindowID
)
;
return
;
}
browser
.
messageManager
.
addMessageListener
(
"
Browser
:
Init
"
function
initListener
(
)
{
browser
.
messageManager
.
removeMessageListener
(
"
Browser
:
Init
"
initListener
)
;
resolve
(
browser
.
outerWindowID
)
;
}
)
;
}
)
.
then
(
function
(
outerWindowID
)
{
return
(
_this12
.
LoopAPI
.
broadcastPushMessage
(
"
BrowserSwitch
"
outerWindowID
)
)
;
}
)
;
}
stopBrowserSharing
:
function
stopBrowserSharing
(
)
{
if
(
!
this
.
_listeningToTabSelect
)
{
return
;
}
this
.
_hideBrowserSharingInfoBar
(
)
;
gBrowser
.
tabContainer
.
removeEventListener
(
"
TabSelect
"
this
)
;
this
.
LoopRooms
.
off
(
"
joined
"
this
.
_roomsListener
)
;
this
.
LoopRooms
.
off
(
"
left
"
this
.
_roomsListener
)
;
if
(
titleChangedListener
)
{
this
.
mm
.
removeMessageListener
(
"
loop
mozilla
.
org
:
DOMTitleChanged
"
titleChangedListener
)
;
titleChangedListener
=
null
;
}
gBrowser
.
removeEventListener
(
"
mousemove
"
this
)
;
gBrowser
.
removeEventListener
(
"
click
"
this
)
;
this
.
removeRemoteCursor
(
)
;
this
.
_listeningToTabSelect
=
false
;
this
.
_browserSharePaused
=
false
;
this
.
_currentRoomToken
=
null
;
}
addRemoteCursor
:
function
addRemoteCursor
(
cursorData
)
{
if
(
this
.
_browserSharePaused
|
|
!
this
.
_listeningToTabSelect
)
{
return
;
}
var
browser
=
gBrowser
.
selectedBrowser
;
var
cursor
=
document
.
getElementById
(
"
loop
-
remote
-
cursor
"
)
;
if
(
!
cursor
)
{
var
cursorContainer
=
document
.
createElement
(
"
div
"
)
;
cursorContainer
.
setAttribute
(
"
id
"
"
loop
-
remote
-
cursor
-
container
"
)
;
cursor
=
document
.
createElement
(
"
img
"
)
;
cursor
.
setAttribute
(
"
id
"
"
loop
-
remote
-
cursor
"
)
;
cursorContainer
.
appendChild
(
cursor
)
;
browser
.
parentNode
.
appendChild
(
cursorContainer
)
;
}
cursor
.
style
.
left
=
Math
.
abs
(
cursorData
.
ratioX
*
browser
.
boxObject
.
width
)
+
"
px
"
;
cursor
.
style
.
top
=
Math
.
abs
(
cursorData
.
ratioY
*
browser
.
boxObject
.
height
)
+
"
px
"
;
}
clickRemoteCursor
:
function
clickRemoteCursor
(
clickData
)
{
if
(
!
clickData
|
|
!
this
.
_listeningToTabSelect
)
{
return
;
}
var
class_name
=
"
clicked
"
;
var
cursor
=
document
.
getElementById
(
"
loop
-
remote
-
cursor
"
)
;
if
(
!
cursor
)
{
return
;
}
cursor
.
classList
.
add
(
class_name
)
;
window
.
setTimeout
(
function
(
)
{
cursor
.
classList
.
remove
(
class_name
)
;
}
CURSOR_CLICK_DELAY
)
;
}
removeRemoteCursor
:
function
removeRemoteCursor
(
)
{
var
cursor
=
document
.
getElementById
(
"
loop
-
remote
-
cursor
"
)
;
if
(
cursor
)
{
cursor
.
parentNode
.
removeChild
(
cursor
)
;
}
}
_getString
:
function
_getString
(
key
)
{
var
str
=
this
.
MozLoopService
.
getStrings
(
key
)
;
if
(
str
)
{
str
=
JSON
.
parse
(
str
)
.
textContent
;
}
return
str
;
}
_setInfoBarStrings
:
function
_setInfoBarStrings
(
nonOwnerParticipants
sharePaused
)
{
var
message
=
void
0
;
if
(
nonOwnerParticipants
)
{
message
=
this
.
_getString
(
sharePaused
?
"
infobar_screenshare_stop_sharing_message2
"
:
"
infobar_screenshare_browser_message3
"
)
;
}
else
{
message
=
this
.
_getString
(
sharePaused
?
"
infobar_screenshare_stop_no_guest_message
"
:
"
infobar_screenshare_no_guest_message
"
)
;
}
var
label
=
this
.
_getString
(
sharePaused
?
"
infobar_button_restart_label2
"
:
"
infobar_button_stop_label2
"
)
;
var
accessKey
=
this
.
_getString
(
sharePaused
?
"
infobar_button_restart_accesskey
"
:
"
infobar_button_stop_accesskey
"
)
;
return
{
message
:
message
label
:
label
accesskey
:
accessKey
}
;
}
_browserSharePaused
:
false
_lastNotification
:
{
}
_showingBrowserSharingInfoBar
:
function
_showingBrowserSharingInfoBar
(
)
{
var
browser
=
gBrowser
.
selectedBrowser
;
var
box
=
gBrowser
.
getNotificationBox
(
browser
)
;
var
notification
=
box
.
getNotificationWithValue
(
kBrowserSharingNotificationId
)
;
return
!
!
notification
;
}
_maybeShowBrowserSharingInfoBar
:
function
_maybeShowBrowserSharingInfoBar
(
currentRoomToken
)
{
var
_this13
=
this
;
var
participantsCount
=
this
.
LoopRooms
.
getNumParticipants
(
currentRoomToken
)
;
if
(
this
.
_showingBrowserSharingInfoBar
(
)
)
{
var
notAlone
=
participantsCount
>
1
;
var
previousNotAlone
=
this
.
_lastNotification
.
participantsCount
<
=
1
;
if
(
notAlone
!
=
=
previousNotAlone
&
&
this
.
_browserSharePaused
=
=
=
this
.
_lastNotification
.
paused
)
{
return
;
}
this
.
_hideBrowserSharingInfoBar
(
)
;
}
var
initStrings
=
this
.
_setInfoBarStrings
(
participantsCount
>
1
this
.
_browserSharePaused
)
;
var
box
=
gBrowser
.
getNotificationBox
(
)
;
var
bar
=
box
.
appendNotification
(
initStrings
.
message
kBrowserSharingNotificationId
null
box
.
PRIORITY_WARNING_LOW
[
{
label
:
initStrings
.
label
accessKey
:
initStrings
.
accesskey
isDefault
:
false
callback
:
function
callback
(
event
buttonInfo
buttonNode
)
{
_this13
.
_browserSharePaused
=
!
_this13
.
_browserSharePaused
;
var
guestPresent
=
_this13
.
LoopRooms
.
getNumParticipants
(
_this13
.
_currentRoomToken
)
>
1
;
var
stringObj
=
_this13
.
_setInfoBarStrings
(
guestPresent
_this13
.
_browserSharePaused
)
;
bar
.
label
=
stringObj
.
message
;
bar
.
classList
.
toggle
(
"
paused
"
_this13
.
_browserSharePaused
)
;
buttonNode
.
label
=
stringObj
.
label
;
buttonNode
.
accessKey
=
stringObj
.
accesskey
;
LoopUI
.
MozLoopService
.
toggleBrowserSharing
(
_this13
.
_browserSharePaused
)
;
if
(
_this13
.
_browserSharePaused
)
{
_this13
.
removeRemoteCursor
(
)
;
}
return
true
;
}
type
:
"
pause
"
}
{
label
:
this
.
_getString
(
"
infobar_button_disconnect_label
"
)
accessKey
:
this
.
_getString
(
"
infobar_button_disconnect_accesskey
"
)
isDefault
:
true
callback
:
function
callback
(
)
{
_this13
.
removeRemoteCursor
(
)
;
_this13
.
_hideBrowserSharingInfoBar
(
)
;
LoopUI
.
MozLoopService
.
hangupAllChatWindows
(
)
;
}
type
:
"
stop
"
}
]
)
;
bar
.
classList
.
toggle
(
"
paused
"
!
!
this
.
_browserSharePaused
)
;
bar
.
persistence
=
-
1
;
this
.
_lastNotification
.
participantsCount
=
participantsCount
;
this
.
_lastNotification
.
paused
=
this
.
_browserSharePaused
;
}
_hideBrowserSharingInfoBar
:
function
_hideBrowserSharingInfoBar
(
browser
)
{
browser
=
browser
|
|
gBrowser
.
selectedBrowser
;
var
box
=
gBrowser
.
getNotificationBox
(
browser
)
;
var
notification
=
box
.
getNotificationWithValue
(
kBrowserSharingNotificationId
)
;
var
removed
=
false
;
if
(
notification
)
{
box
.
removeNotification
(
notification
)
;
removed
=
true
;
}
return
removed
;
}
_notifyBrowserSwitch
:
function
_notifyBrowserSwitch
(
)
{
this
.
LoopAPI
.
broadcastPushMessage
(
"
BrowserSwitch
"
gBrowser
.
selectedBrowser
.
outerWindowID
)
;
}
handleRoomJoinedOrLeft
:
function
handleRoomJoinedOrLeft
(
)
{
if
(
!
this
.
_listeningToTabSelect
)
{
return
;
}
this
.
_maybeShowBrowserSharingInfoBar
(
this
.
_currentRoomToken
)
;
}
handleDOMTitleChanged
:
function
handleDOMTitleChanged
(
message
)
{
if
(
!
this
.
_listeningToTabSelect
|
|
this
.
_browserSharePaused
)
{
return
;
}
if
(
gBrowser
.
selectedBrowser
=
=
message
.
target
)
{
this
.
_notifyBrowserSwitch
(
)
;
}
}
handleEvent
:
function
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
TabSelect
"
:
{
var
wasVisible
=
false
;
if
(
event
.
detail
.
previousTab
)
{
wasVisible
=
this
.
_hideBrowserSharingInfoBar
(
event
.
detail
.
previousTab
.
linkedBrowser
)
;
this
.
removeRemoteCursor
(
)
;
}
this
.
_notifyBrowserSwitch
(
)
;
if
(
wasVisible
)
{
this
.
_maybeShowBrowserSharingInfoBar
(
this
.
_currentRoomToken
)
;
}
break
;
}
case
"
mousemove
"
:
this
.
handleMousemove
(
event
)
;
break
;
case
"
click
"
:
this
.
handleMouseClick
(
event
)
;
break
;
}
}
handleMousemove
:
function
handleMousemove
(
event
)
{
if
(
this
.
_browserSharePaused
|
|
!
this
.
_listeningToTabSelect
)
{
return
;
}
var
now
=
Date
.
now
(
)
;
if
(
now
-
this
.
lastCursorTime
<
CURSOR_MIN_INTERVAL
)
{
return
;
}
this
.
lastCursorTime
=
now
;
var
browserBox
=
gBrowser
.
selectedBrowser
.
boxObject
;
var
deltaX
=
event
.
screenX
-
browserBox
.
screenX
;
var
deltaY
=
event
.
screenY
-
browserBox
.
screenY
;
if
(
deltaX
<
0
|
|
deltaX
>
browserBox
.
width
|
|
deltaY
<
0
|
|
deltaY
>
browserBox
.
height
|
|
Math
.
abs
(
deltaX
-
this
.
lastCursorX
)
<
CURSOR_MIN_DELTA
&
&
Math
.
abs
(
deltaY
-
this
.
lastCursorY
)
<
CURSOR_MIN_DELTA
)
{
return
;
}
this
.
lastCursorX
=
deltaX
;
this
.
lastCursorY
=
deltaY
;
this
.
LoopAPI
.
broadcastPushMessage
(
"
CursorPositionChange
"
{
ratioX
:
deltaX
/
browserBox
.
width
ratioY
:
deltaY
/
browserBox
.
height
}
)
;
}
handleMouseClick
:
function
handleMouseClick
(
)
{
if
(
this
.
_browserSharePaused
)
{
return
;
}
this
.
LoopAPI
.
broadcastPushMessage
(
"
CursorClick
"
)
;
}
getFavicon
:
function
getFavicon
(
callback
)
{
var
pageURI
=
gBrowser
.
selectedTab
.
linkedBrowser
.
currentURI
.
spec
;
if
(
!
/
^
https
?
:
/
.
test
(
pageURI
)
)
{
callback
(
)
;
return
;
}
this
.
PlacesUtils
.
promiseFaviconLinkUrl
(
pageURI
)
.
then
(
function
(
uri
)
{
var
xhr
=
xhrClass
.
createInstance
(
Ci
.
nsIXMLHttpRequest
)
;
xhr
.
open
(
"
get
"
uri
.
spec
true
)
;
xhr
.
responseType
=
"
blob
"
;
xhr
.
overrideMimeType
(
"
image
/
x
-
icon
"
)
;
xhr
.
onload
=
function
(
)
{
if
(
xhr
.
status
!
=
200
)
{
callback
(
new
Error
(
"
Invalid
status
code
received
for
favicon
XHR
:
"
+
xhr
.
status
)
)
;
return
;
}
var
reader
=
new
FileReader
(
)
;
reader
.
onload
=
reader
.
onload
=
function
(
)
{
return
callback
(
null
reader
.
result
)
;
}
;
reader
.
onerror
=
callback
;
reader
.
readAsDataURL
(
xhr
.
response
)
;
}
;
xhr
.
onerror
=
callback
;
xhr
.
send
(
)
;
}
)
.
catch
(
function
(
err
)
{
callback
(
err
|
|
new
Error
(
"
No
favicon
found
"
)
)
;
}
)
;
}
}
;
XPCOMUtils
.
defineLazyModuleGetter
(
LoopUI
"
hookWindowCloseForPanelClose
"
"
resource
:
/
/
gre
/
modules
/
MozSocialAPI
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
LoopUI
"
LoopAPI
"
"
chrome
:
/
/
loop
/
content
/
modules
/
MozLoopAPI
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
LoopUI
"
LoopRooms
"
"
chrome
:
/
/
loop
/
content
/
modules
/
LoopRooms
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
LoopUI
"
MozLoopService
"
"
chrome
:
/
/
loop
/
content
/
modules
/
MozLoopService
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
LoopUI
"
PanelFrame
"
"
resource
:
/
/
/
modules
/
PanelFrame
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
LoopUI
"
PlacesUtils
"
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
LoopUI
.
init
(
)
;
window
.
LoopUI
=
LoopUI
;
window
.
LoopThrottler
=
Throttler
;
}
tearDownBrowserUI
:
function
tearDownBrowserUI
(
window
)
{
if
(
window
.
LoopUI
)
{
window
.
LoopUI
.
removeCopyPanel
(
)
;
window
.
LoopUI
.
removeMenuItem
(
)
;
window
.
LoopUI
.
mm
.
removeDelayedFrameScript
(
FRAME_SCRIPT
)
;
}
}
onOpenWindow
:
function
onOpenWindow
(
xulWindow
)
{
var
domWindow
=
xulWindow
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindow
)
;
domWindow
.
addEventListener
(
"
load
"
function
listener
(
)
{
domWindow
.
removeEventListener
(
"
load
"
listener
false
)
;
if
(
domWindow
.
document
.
documentElement
.
getAttribute
(
"
windowtype
"
)
=
=
"
navigator
:
browser
"
)
{
WindowListener
.
setupBrowserUI
(
domWindow
)
;
}
}
false
)
;
}
onCloseWindow
:
function
onCloseWindow
(
)
{
}
onWindowTitleChange
:
function
onWindowTitleChange
(
)
{
}
}
;
var
Throttler
=
{
TICKET_LIMIT
:
255
_dns
:
Cc
[
"
mozilla
.
org
/
network
/
dns
-
service
;
1
"
]
.
getService
(
Ci
.
nsIDNSService
)
check
:
function
check
(
prefPrefix
)
{
var
_this14
=
this
;
return
new
Promise
(
function
(
resolve
reject
)
{
var
prefTicket
=
prefPrefix
+
"
.
ticket
"
;
var
ticket
=
Services
.
prefs
.
getIntPref
(
prefTicket
)
;
if
(
ticket
<
0
)
{
ticket
=
Math
.
floor
(
Math
.
random
(
)
*
_this14
.
TICKET_LIMIT
)
;
Services
.
prefs
.
setIntPref
(
prefTicket
ticket
)
;
}
else
if
(
ticket
>
=
_this14
.
TICKET_LIMIT
)
{
resolve
(
)
;
return
;
}
var
onDNS
=
function
onDNS
(
request
record
)
{
if
(
record
=
=
=
null
)
{
reject
(
)
;
return
;
}
var
ipBlocks
=
record
.
getNextAddrAsString
(
)
.
split
(
"
.
"
)
;
if
(
ipBlocks
[
0
]
!
=
=
"
127
"
)
{
reject
(
)
;
return
;
}
var
index
=
1
;
switch
(
Services
.
prefs
.
getCharPref
(
"
app
.
update
.
channel
"
)
)
{
case
"
beta
"
:
index
=
2
;
break
;
case
"
aurora
"
:
case
"
nightly
"
:
index
=
3
;
break
;
}
if
(
ticket
<
ipBlocks
[
index
]
)
{
Services
.
prefs
.
setIntPref
(
prefTicket
_this14
.
TICKET_LIMIT
)
;
resolve
(
)
;
}
else
{
reject
(
)
;
}
}
;
_this14
.
_dns
.
asyncResolve
(
Services
.
prefs
.
getCharPref
(
prefPrefix
+
"
.
throttler
"
)
_this14
.
_dns
.
RESOLVE_DISABLE_IPV6
onDNS
Services
.
tm
.
mainThread
)
;
}
)
;
}
}
;
function
createLoopButton
(
)
{
CustomizableUI
.
createWidget
(
{
id
:
"
loop
-
button
"
type
:
"
custom
"
label
:
"
loop
-
call
-
button3
.
label
"
tooltiptext
:
"
loop
-
call
-
button3
.
tooltiptext2
"
privateBrowsingTooltiptext
:
"
loop
-
call
-
button3
-
pb
.
tooltiptext
"
defaultArea
:
CustomizableUI
.
AREA_NAVBAR
removable
:
true
onBuild
:
function
onBuild
(
aDocument
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
"
loop
.
enabled
"
)
)
{
return
null
;
}
var
isWindowPrivate
=
PrivateBrowsingUtils
.
isWindowPrivate
(
aDocument
.
defaultView
)
;
var
node
=
aDocument
.
createElementNS
(
kNSXUL
"
toolbarbutton
"
)
;
node
.
setAttribute
(
"
id
"
this
.
id
)
;
node
.
classList
.
add
(
"
toolbarbutton
-
1
"
)
;
node
.
classList
.
add
(
"
chromeclass
-
toolbar
-
additional
"
)
;
node
.
classList
.
add
(
"
badged
-
button
"
)
;
node
.
setAttribute
(
"
label
"
CustomizableUI
.
getLocalizedProperty
(
this
"
label
"
)
)
;
if
(
isWindowPrivate
)
{
node
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
var
tooltiptext
=
isWindowPrivate
?
CustomizableUI
.
getLocalizedProperty
(
this
"
privateBrowsingTooltiptext
"
[
CustomizableUI
.
getLocalizedProperty
(
this
"
label
"
)
]
)
:
CustomizableUI
.
getLocalizedProperty
(
this
"
tooltiptext
"
)
;
node
.
setAttribute
(
"
tooltiptext
"
tooltiptext
)
;
node
.
setAttribute
(
"
removable
"
"
true
"
)
;
node
.
addEventListener
(
"
command
"
function
(
event
)
{
aDocument
.
defaultView
.
LoopUI
.
togglePanel
(
event
)
;
}
)
;
return
node
;
}
}
)
;
}
function
loadDefaultPrefs
(
)
{
var
branch
=
Services
.
prefs
.
getDefaultBranch
(
"
"
)
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
loop
/
content
/
preferences
/
prefs
.
js
"
{
pref
:
function
pref
(
key
val
)
{
if
(
branch
.
getPrefType
(
key
)
!
=
branch
.
PREF_INVALID
)
{
return
;
}
switch
(
typeof
val
=
=
=
"
undefined
"
?
"
undefined
"
:
_typeof
(
val
)
)
{
case
"
boolean
"
:
branch
.
setBoolPref
(
key
val
)
;
break
;
case
"
number
"
:
branch
.
setIntPref
(
key
val
)
;
break
;
case
"
string
"
:
branch
.
setCharPref
(
key
val
)
;
break
;
}
}
}
)
;
if
(
Services
.
vc
.
compare
(
Services
.
appinfo
.
version
"
47
.
0a1
"
)
<
0
)
{
branch
.
setBoolPref
(
"
loop
.
remote
.
autostart
"
false
)
;
}
}
function
startup
(
data
)
{
WindowListener
.
addonVersion
=
data
.
version
;
loadDefaultPrefs
(
)
;
if
(
!
Services
.
prefs
.
getBoolPref
(
"
loop
.
enabled
"
)
)
{
return
;
}
createLoopButton
(
)
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
try
{
WindowListener
.
setupBrowserUI
(
Services
.
appShell
.
hiddenDOMWindow
)
;
}
catch
(
ex
)
{
(
function
(
)
{
var
topic
=
"
browser
-
delayed
-
startup
-
finished
"
;
Services
.
obs
.
addObserver
(
function
observer
(
)
{
Services
.
obs
.
removeObserver
(
observer
topic
)
;
WindowListener
.
setupBrowserUI
(
Services
.
appShell
.
hiddenDOMWindow
)
;
}
topic
false
)
;
}
)
(
)
;
}
}
var
wm
=
Cc
[
"
mozilla
.
org
/
appshell
/
window
-
mediator
;
1
"
]
.
getService
(
Ci
.
nsIWindowMediator
)
;
var
windows
=
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
;
while
(
windows
.
hasMoreElements
(
)
)
{
var
domWindow
=
windows
.
getNext
(
)
.
QueryInterface
(
Ci
.
nsIDOMWindow
)
;
WindowListener
.
setupBrowserUI
(
domWindow
)
;
}
wm
.
addListener
(
WindowListener
)
;
var
styleSheetService
=
Cc
[
"
mozilla
.
org
/
content
/
style
-
sheet
-
service
;
1
"
]
.
getService
(
Components
.
interfaces
.
nsIStyleSheetService
)
;
var
sheets
=
[
"
chrome
:
/
/
loop
-
shared
/
skin
/
loop
.
css
"
"
chrome
:
/
/
loop
/
skin
/
platform
.
css
"
]
;
var
_iteratorNormalCompletion2
=
true
;
var
_didIteratorError2
=
false
;
var
_iteratorError2
=
undefined
;
try
{
for
(
var
_iterator2
=
sheets
[
Symbol
.
iterator
]
(
)
_step2
;
!
(
_iteratorNormalCompletion2
=
(
_step2
=
_iterator2
.
next
(
)
)
.
done
)
;
_iteratorNormalCompletion2
=
true
)
{
var
sheet
=
_step2
.
value
;
var
styleSheetURI
=
Services
.
io
.
newURI
(
sheet
null
null
)
;
styleSheetService
.
loadAndRegisterSheet
(
styleSheetURI
styleSheetService
.
AUTHOR_SHEET
)
;
}
}
catch
(
err
)
{
_didIteratorError2
=
true
;
_iteratorError2
=
err
;
}
finally
{
try
{
if
(
!
_iteratorNormalCompletion2
&
&
_iterator2
.
return
)
{
_iterator2
.
return
(
)
;
}
}
finally
{
if
(
_didIteratorError2
)
{
throw
_iteratorError2
;
}
}
}
}
function
shutdown
(
data
reason
)
{
Cu
.
import
(
"
resource
:
/
/
/
modules
/
Chat
.
jsm
"
)
;
var
isLoopURL
=
function
isLoopURL
(
_ref
)
{
var
src
=
_ref
.
src
;
return
(
/
^
about
:
loopconversation
#
/
.
test
(
src
)
)
;
}
;
[
]
.
concat
(
_toConsumableArray
(
Chat
.
chatboxes
)
)
.
filter
(
isLoopURL
)
.
forEach
(
function
(
chatbox
)
{
chatbox
.
content
.
contentWindow
.
close
(
)
;
}
)
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
WindowListener
.
tearDownBrowserUI
(
Services
.
appShell
.
hiddenDOMWindow
)
;
}
var
wm
=
Cc
[
"
mozilla
.
org
/
appshell
/
window
-
mediator
;
1
"
]
.
getService
(
Ci
.
nsIWindowMediator
)
;
var
windows
=
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
;
while
(
windows
.
hasMoreElements
(
)
)
{
var
domWindow
=
windows
.
getNext
(
)
.
QueryInterface
(
Ci
.
nsIDOMWindow
)
;
WindowListener
.
tearDownBrowserUI
(
domWindow
)
;
}
wm
.
removeListener
(
WindowListener
)
;
if
(
reason
=
=
APP_SHUTDOWN
)
{
return
;
}
CustomizableUI
.
destroyWidget
(
"
loop
-
button
"
)
;
var
styleSheetService
=
Cc
[
"
mozilla
.
org
/
content
/
style
-
sheet
-
service
;
1
"
]
.
getService
(
Components
.
interfaces
.
nsIStyleSheetService
)
;
var
sheets
=
[
"
chrome
:
/
/
loop
/
content
/
addon
/
css
/
loop
.
css
"
"
chrome
:
/
/
loop
/
skin
/
platform
.
css
"
]
;
var
_iteratorNormalCompletion3
=
true
;
var
_didIteratorError3
=
false
;
var
_iteratorError3
=
undefined
;
try
{
for
(
var
_iterator3
=
sheets
[
Symbol
.
iterator
]
(
)
_step3
;
!
(
_iteratorNormalCompletion3
=
(
_step3
=
_iterator3
.
next
(
)
)
.
done
)
;
_iteratorNormalCompletion3
=
true
)
{
var
sheet
=
_step3
.
value
;
var
styleSheetURI
=
Services
.
io
.
newURI
(
sheet
null
null
)
;
if
(
styleSheetService
.
sheetRegistered
(
styleSheetURI
styleSheetService
.
AUTHOR_SHEET
)
)
{
styleSheetService
.
unregisterSheet
(
styleSheetURI
styleSheetService
.
AUTHOR_SHEET
)
;
}
}
}
catch
(
err
)
{
_didIteratorError3
=
true
;
_iteratorError3
=
err
;
}
finally
{
try
{
if
(
!
_iteratorNormalCompletion3
&
&
_iterator3
.
return
)
{
_iterator3
.
return
(
)
;
}
}
finally
{
if
(
_didIteratorError3
)
{
throw
_iteratorError3
;
}
}
}
Cu
.
unload
(
"
chrome
:
/
/
loop
/
content
/
modules
/
MozLoopAPI
.
jsm
"
)
;
Cu
.
unload
(
"
chrome
:
/
/
loop
/
content
/
modules
/
LoopRooms
.
jsm
"
)
;
Cu
.
unload
(
"
chrome
:
/
/
loop
/
content
/
modules
/
MozLoopService
.
jsm
"
)
;
}
function
install
(
)
{
}
function
uninstall
(
)
{
}
