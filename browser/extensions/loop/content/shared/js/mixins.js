var
loop
=
loop
|
|
{
}
;
loop
.
shared
=
loop
.
shared
|
|
{
}
;
loop
.
shared
.
mixins
=
(
function
(
)
{
"
use
strict
"
;
var
rootObject
=
window
;
function
setRootObject
(
obj
)
{
rootObject
=
obj
;
}
var
UrlHashChangeMixin
=
{
componentDidMount
:
function
(
)
{
rootObject
.
addEventListener
(
"
hashchange
"
this
.
onUrlHashChange
false
)
;
}
componentWillUnmount
:
function
(
)
{
rootObject
.
removeEventListener
(
"
hashchange
"
this
.
onUrlHashChange
false
)
;
}
}
;
var
DocumentLocationMixin
=
{
locationReload
:
function
(
)
{
rootObject
.
location
.
reload
(
)
;
}
}
;
var
DocumentTitleMixin
=
{
setTitle
:
function
(
newTitle
)
{
rootObject
.
document
.
title
=
newTitle
;
}
}
;
var
WindowCloseMixin
=
{
closeWindow
:
function
(
)
{
rootObject
.
close
(
)
;
}
}
;
var
DropdownMenuMixin
=
function
(
boundingBoxSelector
)
{
return
{
get
documentBody
(
)
{
return
rootObject
.
document
.
body
;
}
getInitialState
:
function
(
)
{
return
{
showMenu
:
false
}
;
}
_onBodyClick
:
function
(
event
)
{
var
menuButton
=
this
.
refs
[
"
menu
-
button
"
]
&
&
this
.
refs
[
"
menu
-
button
"
]
.
getDOMNode
(
)
;
if
(
this
.
refs
.
anchor
)
{
menuButton
=
this
.
refs
.
anchor
.
getDOMNode
(
)
;
}
if
(
event
.
target
.
classList
.
contains
(
"
dropdown
-
menu
-
item
"
)
|
|
event
.
target
.
classList
.
contains
(
"
dropdown
-
menu
-
button
"
)
)
{
return
;
}
if
(
event
.
target
!
=
=
menuButton
)
{
this
.
setState
(
{
showMenu
:
false
}
)
;
}
}
_correctMenuPosition
:
function
(
)
{
var
menu
=
this
.
refs
.
menu
&
&
this
.
refs
.
menu
.
getDOMNode
(
)
;
if
(
!
menu
)
{
return
;
}
if
(
menu
.
style
.
maxWidth
)
{
menu
.
style
.
maxWidth
=
"
none
"
;
}
if
(
menu
.
style
.
maxHeight
)
{
menu
.
style
.
maxHeight
=
"
none
"
;
}
var
x
y
boundingBox
boundingRect
;
var
boundOffset
=
4
;
var
menuNodeRect
=
menu
.
getBoundingClientRect
(
)
;
if
(
boundingBoxSelector
)
{
boundingBox
=
this
.
documentBody
.
querySelector
(
boundingBoxSelector
)
;
if
(
boundingBox
)
{
boundingRect
=
boundingBox
.
getBoundingClientRect
(
)
;
}
}
if
(
!
boundingRect
)
{
boundingRect
=
{
height
:
this
.
documentBody
.
offsetHeight
left
:
0
top
:
0
width
:
this
.
documentBody
.
offsetWidth
}
;
}
boundingRect
.
width
-
=
boundOffset
;
boundingRect
.
height
-
=
boundOffset
;
x
=
menuNodeRect
.
left
;
y
=
menuNodeRect
.
top
;
var
anchor
=
this
.
refs
.
anchor
&
&
this
.
refs
.
anchor
.
getDOMNode
(
)
;
if
(
anchor
)
{
var
anchorNodeRect
=
anchor
.
getBoundingClientRect
(
)
;
x
=
Math
.
floor
(
anchorNodeRect
.
left
-
(
menuNodeRect
.
width
/
2
)
+
(
anchorNodeRect
.
width
/
2
)
)
;
y
=
Math
.
floor
(
anchorNodeRect
.
top
-
menuNodeRect
.
height
-
anchorNodeRect
.
height
)
;
}
var
overflowX
=
false
;
var
overflowY
=
false
;
if
(
x
+
menuNodeRect
.
width
>
boundingRect
.
width
)
{
x
=
Math
.
floor
(
boundingRect
.
width
-
(
(
anchor
?
0
:
x
)
+
menuNodeRect
.
width
)
)
;
overflowX
=
true
;
}
if
(
y
+
menuNodeRect
.
height
>
boundingRect
.
height
)
{
y
=
Math
.
floor
(
boundingRect
.
height
-
(
(
anchor
?
0
:
y
)
+
menuNodeRect
.
height
)
)
;
overflowY
=
true
;
}
if
(
anchor
|
|
overflowX
)
{
if
(
menuNodeRect
.
width
>
boundingRect
.
width
)
{
menu
.
classList
.
add
(
"
overflow
"
)
;
menu
.
style
.
maxWidth
=
boundingRect
.
width
+
"
px
"
;
}
menu
.
style
.
marginLeft
=
x
+
"
px
"
;
}
else
if
(
!
menu
.
style
.
marginLeft
)
{
menu
.
style
.
marginLeft
=
"
auto
"
;
}
if
(
anchor
|
|
overflowY
)
{
if
(
menuNodeRect
.
height
>
(
boundingRect
.
height
+
y
)
)
{
menu
.
classList
.
add
(
"
overflow
"
)
;
menu
.
style
.
maxHeight
=
(
boundingRect
.
height
+
y
)
+
"
px
"
;
y
+
=
menuNodeRect
.
height
-
(
boundingRect
.
height
+
y
)
;
}
menu
.
style
.
marginTop
=
y
+
"
px
"
;
}
else
if
(
!
menu
.
style
.
marginLeft
)
{
menu
.
style
.
marginTop
=
"
auto
"
;
}
if
(
this
.
_repositionMenu
)
{
this
.
_repositionMenu
(
)
;
}
menu
.
style
.
visibility
=
"
visible
"
;
}
componentDidMount
:
function
(
)
{
this
.
documentBody
.
addEventListener
(
"
click
"
this
.
_onBodyClick
)
;
rootObject
.
addEventListener
(
"
blur
"
this
.
hideDropdownMenu
)
;
}
componentWillUnmount
:
function
(
)
{
this
.
documentBody
.
removeEventListener
(
"
click
"
this
.
_onBodyClick
)
;
rootObject
.
removeEventListener
(
"
blur
"
this
.
hideDropdownMenu
)
;
}
showDropdownMenu
:
function
(
)
{
this
.
setState
(
{
showMenu
:
true
}
this
.
_correctMenuPosition
)
;
}
hideDropdownMenu
:
function
(
)
{
this
.
setState
(
{
showMenu
:
false
}
function
(
)
{
var
menu
=
this
.
refs
.
menu
&
&
this
.
refs
.
menu
.
getDOMNode
(
)
;
if
(
menu
)
{
menu
.
style
.
visibility
=
"
hidden
"
;
}
}
)
;
}
toggleDropdownMenu
:
function
(
)
{
this
[
this
.
state
.
showMenu
?
"
hideDropdownMenu
"
:
"
showDropdownMenu
"
]
(
)
;
}
}
;
}
;
var
DocumentVisibilityMixin
=
{
_onDocumentVisibilityChanged
:
function
(
event
)
{
if
(
!
this
.
isMounted
(
)
)
{
return
;
}
var
hidden
=
event
.
target
.
hidden
;
if
(
hidden
&
&
typeof
this
.
onDocumentHidden
=
=
=
"
function
"
)
{
this
.
onDocumentHidden
(
)
;
}
if
(
!
hidden
&
&
typeof
this
.
onDocumentVisible
=
=
=
"
function
"
)
{
this
.
onDocumentVisible
(
)
;
}
}
componentDidMount
:
function
(
)
{
rootObject
.
document
.
addEventListener
(
"
visibilitychange
"
this
.
_onDocumentVisibilityChanged
)
;
this
.
_onDocumentVisibilityChanged
(
{
target
:
rootObject
.
document
}
)
;
}
componentWillUnmount
:
function
(
)
{
rootObject
.
document
.
removeEventListener
(
"
visibilitychange
"
this
.
_onDocumentVisibilityChanged
)
;
}
}
;
var
MediaSetupMixin
=
{
getDefaultPublisherConfig
:
function
(
options
)
{
options
=
options
|
|
{
}
;
if
(
!
(
"
publishVideo
"
in
options
)
)
{
throw
new
Error
(
"
missing
option
publishVideo
"
)
;
}
return
{
insertMode
:
"
append
"
fitMode
:
"
contain
"
width
:
"
100
%
"
height
:
"
100
%
"
publishVideo
:
options
.
publishVideo
showControls
:
false
}
;
}
}
;
var
AudioMixin
=
{
audio
:
null
_audioRequest
:
null
_isLoopDesktop
:
function
(
)
{
var
isUIShowcase
=
!
!
(
rootObject
.
document
.
querySelector
&
&
rootObject
.
document
.
querySelector
(
"
#
main
>
.
showcase
"
)
)
;
return
loop
.
shared
.
utils
.
isDesktop
(
)
|
|
isUIShowcase
;
}
_canPlay
:
function
(
)
{
return
new
Promise
(
function
(
resolve
)
{
if
(
!
this
.
_isLoopDesktop
(
)
)
{
resolve
(
true
)
;
return
;
}
loop
.
request
(
"
GetDoNotDisturb
"
)
.
then
(
function
(
mayNotDisturb
)
{
resolve
(
!
mayNotDisturb
)
;
}
)
;
}
.
bind
(
this
)
)
;
}
play
:
function
(
name
options
)
{
this
.
_canPlay
(
)
.
then
(
function
(
canPlay
)
{
if
(
!
canPlay
)
{
return
;
}
options
=
options
|
|
{
}
;
options
.
loop
=
options
.
loop
|
|
false
;
this
.
_ensureAudioStopped
(
)
;
this
.
_getAudioBlob
(
name
function
(
error
blob
)
{
if
(
error
)
{
console
.
error
(
error
)
;
return
;
}
if
(
!
blob
)
{
return
;
}
var
url
=
URL
.
createObjectURL
(
blob
)
;
this
.
audio
=
new
Audio
(
url
)
;
this
.
audio
.
loop
=
options
.
loop
;
this
.
audio
.
play
(
)
;
}
.
bind
(
this
)
)
;
}
.
bind
(
this
)
)
;
}
_getAudioBlob
:
function
(
name
callback
)
{
this
.
_canPlay
(
)
.
then
(
function
(
canPlay
)
{
if
(
!
canPlay
)
{
callback
(
)
;
return
;
}
if
(
this
.
_isLoopDesktop
(
)
)
{
loop
.
request
(
"
GetAudioBlob
"
name
)
.
then
(
function
(
result
)
{
if
(
result
&
&
result
.
isError
)
{
callback
(
result
)
;
return
;
}
callback
(
null
result
)
;
}
)
;
return
;
}
var
url
=
"
shared
/
sounds
/
"
+
name
+
"
.
ogg
"
;
this
.
_audioRequest
=
new
XMLHttpRequest
(
)
;
this
.
_audioRequest
.
open
(
"
GET
"
url
true
)
;
this
.
_audioRequest
.
responseType
=
"
arraybuffer
"
;
this
.
_audioRequest
.
onload
=
function
(
)
{
var
request
=
this
.
_audioRequest
;
var
error
;
if
(
request
.
status
<
200
|
|
request
.
status
>
=
300
)
{
error
=
new
Error
(
request
.
status
+
"
"
+
request
.
statusText
)
;
callback
(
error
)
;
return
;
}
var
type
=
request
.
getResponseHeader
(
"
Content
-
Type
"
)
;
var
blob
=
new
Blob
(
[
request
.
response
]
{
type
:
type
}
)
;
callback
(
null
blob
)
;
}
.
bind
(
this
)
;
this
.
_audioRequest
.
send
(
null
)
;
}
.
bind
(
this
)
)
;
}
_ensureAudioStopped
:
function
(
)
{
if
(
this
.
_audioRequest
)
{
this
.
_audioRequest
.
abort
(
)
;
delete
this
.
_audioRequest
;
}
if
(
this
.
audio
)
{
this
.
audio
.
pause
(
)
;
this
.
audio
.
removeAttribute
(
"
src
"
)
;
delete
this
.
audio
;
}
}
componentWillUnmount
:
function
(
)
{
this
.
_ensureAudioStopped
(
)
;
}
}
;
var
RoomsAudioMixin
=
{
mixins
:
[
AudioMixin
]
componentWillUpdate
:
function
(
nextProps
nextState
)
{
var
ROOM_STATES
=
loop
.
store
.
ROOM_STATES
;
function
isConnectedToRoom
(
state
)
{
return
state
=
=
=
ROOM_STATES
.
HAS_PARTICIPANTS
|
|
state
=
=
=
ROOM_STATES
.
SESSION_CONNECTED
;
}
function
notConnectedToRoom
(
state
)
{
return
state
=
=
=
ROOM_STATES
.
INIT
|
|
state
=
=
=
ROOM_STATES
.
GATHER
|
|
state
=
=
=
ROOM_STATES
.
READY
|
|
state
=
=
=
ROOM_STATES
.
JOINED
|
|
state
=
=
=
ROOM_STATES
.
ENDED
;
}
if
(
notConnectedToRoom
(
this
.
state
.
roomState
)
&
&
isConnectedToRoom
(
nextState
.
roomState
)
)
{
this
.
play
(
"
room
-
joined
"
)
;
}
if
(
this
.
state
.
roomState
=
=
=
ROOM_STATES
.
SESSION_CONNECTED
&
&
nextState
.
roomState
=
=
=
ROOM_STATES
.
HAS_PARTICIPANTS
)
{
this
.
play
(
"
room
-
joined
-
in
"
)
;
}
if
(
this
.
state
.
roomState
=
=
=
ROOM_STATES
.
HAS_PARTICIPANTS
&
&
nextState
.
roomState
=
=
=
ROOM_STATES
.
SESSION_CONNECTED
)
{
this
.
play
(
"
room
-
left
"
)
;
}
if
(
isConnectedToRoom
(
this
.
state
.
roomState
)
&
&
notConnectedToRoom
(
nextState
.
roomState
)
)
{
this
.
play
(
"
room
-
left
"
)
;
}
if
(
nextState
.
roomState
=
=
=
ROOM_STATES
.
FAILED
|
|
nextState
.
roomState
=
=
=
ROOM_STATES
.
FULL
)
{
this
.
play
(
"
failure
"
)
;
}
}
}
;
return
{
AudioMixin
:
AudioMixin
RoomsAudioMixin
:
RoomsAudioMixin
setRootObject
:
setRootObject
DropdownMenuMixin
:
DropdownMenuMixin
DocumentVisibilityMixin
:
DocumentVisibilityMixin
DocumentLocationMixin
:
DocumentLocationMixin
DocumentTitleMixin
:
DocumentTitleMixin
MediaSetupMixin
:
MediaSetupMixin
UrlHashChangeMixin
:
UrlHashChangeMixin
WindowCloseMixin
:
WindowCloseMixin
}
;
}
)
(
)
;
