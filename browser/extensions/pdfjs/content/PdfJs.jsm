"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
PdfJs
"
]
;
const
PREF_PREFIX
=
"
pdfjs
"
;
const
PREF_DISABLED
=
PREF_PREFIX
+
"
.
disabled
"
;
const
PREF_MIGRATION_VERSION
=
PREF_PREFIX
+
"
.
migrationVersion
"
;
const
PREF_PREVIOUS_ACTION
=
PREF_PREFIX
+
"
.
previousHandler
.
preferredAction
"
;
const
PREF_PREVIOUS_ASK
=
PREF_PREFIX
+
"
.
previousHandler
.
alwaysAskBeforeHandling
"
;
const
PREF_ENABLED_CACHE_STATE
=
PREF_PREFIX
+
"
.
enabledCache
.
state
"
;
const
TOPIC_PDFJS_HANDLER_CHANGED
=
"
pdfjs
:
handlerChanged
"
;
const
PDF_CONTENT_TYPE
=
"
application
/
pdf
"
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
var
Svc
=
{
}
;
XPCOMUtils
.
defineLazyServiceGetter
(
Svc
"
mime
"
"
mozilla
.
org
/
mime
;
1
"
"
nsIMIMEService
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
Svc
"
handlerService
"
"
mozilla
.
org
/
uriloader
/
handler
-
service
;
1
"
"
nsIHandlerService
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PdfjsChromeUtils
"
"
resource
:
/
/
pdf
.
js
/
PdfjsChromeUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PdfJsDefaultPreferences
"
"
resource
:
/
/
pdf
.
js
/
PdfJsDefaultPreferences
.
jsm
"
)
;
function
initializeDefaultPreferences
(
)
{
var
defaultBranch
=
Services
.
prefs
.
getDefaultBranch
(
PREF_PREFIX
+
"
.
"
)
;
var
defaultValue
;
for
(
var
key
in
PdfJsDefaultPreferences
)
{
defaultValue
=
PdfJsDefaultPreferences
[
key
]
;
switch
(
typeof
defaultValue
)
{
case
"
boolean
"
:
defaultBranch
.
setBoolPref
(
key
defaultValue
)
;
break
;
case
"
number
"
:
defaultBranch
.
setIntPref
(
key
defaultValue
)
;
break
;
case
"
string
"
:
defaultBranch
.
setCharPref
(
key
defaultValue
)
;
break
;
}
}
}
const
gPdfFakeHandlerInfo
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIMIMEInfo
]
)
getFileExtensions
(
)
{
return
[
"
pdf
"
]
;
}
possibleApplicationHandlers
:
Cc
[
"
mozilla
.
org
/
array
;
1
"
]
.
createInstance
(
Ci
.
nsIMutableArray
)
extensionExists
(
ext
)
{
return
ext
=
=
"
pdf
"
;
}
alwaysAskBeforeHandling
:
false
preferredAction
:
Ci
.
nsIHandlerInfo
.
handleInternally
type
:
PDF_CONTENT_TYPE
}
;
var
PdfJs
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIObserver
]
)
_initialized
:
false
init
:
function
init
(
isNewProfile
)
{
if
(
Services
.
appinfo
.
processType
!
=
=
Services
.
appinfo
.
PROCESS_TYPE_DEFAULT
)
{
throw
new
Error
(
"
PdfJs
.
init
should
only
get
called
in
the
parent
process
.
"
)
;
}
PdfjsChromeUtils
.
init
(
)
;
this
.
initPrefs
(
)
;
Services
.
ppmm
.
sharedData
.
set
(
"
pdfjs
.
enabled
"
this
.
checkEnabled
(
isNewProfile
)
)
;
}
earlyInit
(
isNewProfile
)
{
Services
.
ppmm
.
sharedData
.
set
(
"
pdfjs
.
enabled
"
this
.
checkEnabled
(
isNewProfile
)
)
;
}
initPrefs
:
function
initPrefs
(
)
{
if
(
this
.
_initialized
)
{
return
;
}
this
.
_initialized
=
true
;
if
(
Services
.
prefs
.
getBoolPref
(
PREF_DISABLED
false
)
)
{
this
.
_unbecomeHandler
(
)
;
}
else
{
this
.
_migrate
(
)
;
}
Services
.
prefs
.
addObserver
(
PREF_DISABLED
this
)
;
Services
.
obs
.
addObserver
(
this
TOPIC_PDFJS_HANDLER_CHANGED
)
;
initializeDefaultPreferences
(
)
;
}
uninit
:
function
uninit
(
)
{
if
(
this
.
_initialized
)
{
Services
.
prefs
.
removeObserver
(
PREF_DISABLED
this
)
;
Services
.
obs
.
removeObserver
(
this
TOPIC_PDFJS_HANDLER_CHANGED
)
;
this
.
_initialized
=
false
;
}
}
_migrate
:
function
migrate
(
)
{
const
VERSION
=
2
;
var
currentVersion
=
Services
.
prefs
.
getIntPref
(
PREF_MIGRATION_VERSION
0
)
;
if
(
currentVersion
>
=
VERSION
)
{
return
;
}
if
(
currentVersion
<
1
)
{
this
.
_becomeHandler
(
)
;
}
if
(
currentVersion
<
2
)
{
Services
.
prefs
.
clearUserPref
(
PREF_PREFIX
+
"
.
database
"
)
;
}
Services
.
prefs
.
setIntPref
(
PREF_MIGRATION_VERSION
VERSION
)
;
}
_becomeHandler
:
function
_becomeHandler
(
)
{
if
(
!
Svc
.
handlerService
.
exists
(
gPdfFakeHandlerInfo
)
)
{
Svc
.
handlerService
.
store
(
gPdfFakeHandlerInfo
)
;
}
else
{
let
handlerInfo
=
Svc
.
mime
.
getFromTypeAndExtension
(
PDF_CONTENT_TYPE
"
pdf
"
)
;
let
prefs
=
Services
.
prefs
;
if
(
handlerInfo
.
preferredAction
!
=
=
Ci
.
nsIHandlerInfo
.
handleInternally
&
&
handlerInfo
.
alwaysAskBeforeHandling
!
=
=
false
)
{
prefs
.
setIntPref
(
PREF_PREVIOUS_ACTION
handlerInfo
.
preferredAction
)
;
prefs
.
setBoolPref
(
PREF_PREVIOUS_ASK
handlerInfo
.
alwaysAskBeforeHandling
)
;
}
handlerInfo
.
alwaysAskBeforeHandling
=
false
;
handlerInfo
.
preferredAction
=
Ci
.
nsIHandlerInfo
.
handleInternally
;
Svc
.
handlerService
.
store
(
handlerInfo
)
;
}
}
_unbecomeHandler
:
function
_unbecomeHandler
(
)
{
let
handlerInfo
=
Svc
.
mime
.
getFromTypeAndExtension
(
PDF_CONTENT_TYPE
"
pdf
"
)
;
if
(
handlerInfo
.
preferredAction
=
=
=
Ci
.
nsIHandlerInfo
.
handleInternally
)
{
if
(
Services
.
prefs
.
prefHasUserValue
(
PREF_PREVIOUS_ACTION
)
)
{
handlerInfo
.
preferredAction
=
Services
.
prefs
.
getIntPref
(
PREF_PREVIOUS_ACTION
)
;
handlerInfo
.
alwaysAskBeforeHandling
=
Services
.
prefs
.
getBoolPref
(
PREF_PREVIOUS_ASK
)
;
Svc
.
handlerService
.
store
(
handlerInfo
)
;
}
else
{
Svc
.
handlerService
.
remove
(
handlerInfo
)
;
Services
.
prefs
.
clearIntPref
(
PREF_MIGRATION_VERSION
)
;
}
}
}
_isEnabled
(
isNewProfile
)
{
let
{
processType
PROCESS_TYPE_DEFAULT
}
=
Services
.
appinfo
;
if
(
processType
!
=
=
PROCESS_TYPE_DEFAULT
)
{
throw
new
Error
(
"
isEnabled
should
only
get
called
in
the
parent
process
.
"
)
;
}
if
(
Services
.
prefs
.
getBoolPref
(
PREF_DISABLED
true
)
)
{
return
false
;
}
if
(
isNewProfile
)
{
return
true
;
}
let
handlerInfo
=
Svc
.
mime
.
getFromTypeAndExtension
(
PDF_CONTENT_TYPE
"
pdf
"
)
;
return
(
!
handlerInfo
.
alwaysAskBeforeHandling
&
&
handlerInfo
.
preferredAction
=
=
=
Ci
.
nsIHandlerInfo
.
handleInternally
)
;
}
checkEnabled
(
isNewProfile
)
{
let
isEnabled
=
this
.
_isEnabled
(
isNewProfile
)
;
Services
.
prefs
.
setBoolPref
(
PREF_ENABLED_CACHE_STATE
isEnabled
)
;
return
isEnabled
;
}
observe
:
function
observe
(
aSubject
aTopic
aData
)
{
if
(
Services
.
appinfo
.
processType
!
=
=
Services
.
appinfo
.
PROCESS_TYPE_DEFAULT
)
{
throw
new
Error
(
"
Only
the
parent
process
should
be
observing
PDF
handler
changes
.
"
)
;
}
Services
.
ppmm
.
sharedData
.
set
(
"
pdfjs
.
enabled
"
this
.
checkEnabled
(
)
)
;
}
}
;
