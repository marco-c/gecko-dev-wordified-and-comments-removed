"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
PdfJs
"
]
;
const
PREF_PREFIX
=
"
pdfjs
"
;
const
PREF_DISABLED
=
PREF_PREFIX
+
"
.
disabled
"
;
const
PREF_MIGRATION_VERSION
=
PREF_PREFIX
+
"
.
migrationVersion
"
;
const
PREF_PREVIOUS_ACTION
=
PREF_PREFIX
+
"
.
previousHandler
.
preferredAction
"
;
const
PREF_PREVIOUS_ASK
=
PREF_PREFIX
+
"
.
previousHandler
.
alwaysAskBeforeHandling
"
;
const
PREF_DISABLED_PLUGIN_TYPES
=
"
plugin
.
disable_full_page_plugin_for_types
"
;
const
PREF_ENABLED_CACHE_STATE
=
PREF_PREFIX
+
"
.
enabledCache
.
state
"
;
const
PREF_ENABLED_CACHE_INITIALIZED
=
PREF_PREFIX
+
"
.
enabledCache
.
initialized
"
;
const
PREF_APP_UPDATE_POSTUPDATE
=
"
app
.
update
.
postupdate
"
;
const
TOPIC_PDFJS_HANDLER_CHANGED
=
"
pdfjs
:
handlerChanged
"
;
const
TOPIC_PLUGINS_LIST_UPDATED
=
"
plugins
-
list
-
updated
"
;
const
TOPIC_PLUGIN_INFO_UPDATED
=
"
plugin
-
info
-
updated
"
;
const
PDF_CONTENT_TYPE
=
"
application
/
pdf
"
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
var
Svc
=
{
}
;
XPCOMUtils
.
defineLazyServiceGetter
(
Svc
"
mime
"
"
mozilla
.
org
/
mime
;
1
"
"
nsIMIMEService
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
Svc
"
pluginHost
"
"
mozilla
.
org
/
plugin
/
host
;
1
"
"
nsIPluginHost
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PdfjsChromeUtils
"
"
resource
:
/
/
pdf
.
js
/
PdfjsChromeUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PdfJsDefaultPreferences
"
"
resource
:
/
/
pdf
.
js
/
PdfJsDefaultPreferences
.
jsm
"
)
;
function
getBoolPref
(
aPref
aDefaultValue
)
{
try
{
return
Services
.
prefs
.
getBoolPref
(
aPref
)
;
}
catch
(
ex
)
{
return
aDefaultValue
;
}
}
function
getIntPref
(
aPref
aDefaultValue
)
{
try
{
return
Services
.
prefs
.
getIntPref
(
aPref
)
;
}
catch
(
ex
)
{
return
aDefaultValue
;
}
}
function
isDefaultHandler
(
)
{
if
(
Services
.
appinfo
.
processType
!
=
=
Services
.
appinfo
.
PROCESS_TYPE_DEFAULT
)
{
throw
new
Error
(
"
isDefaultHandler
should
only
get
called
in
the
parent
"
+
"
process
.
"
)
;
}
return
PdfjsChromeUtils
.
isDefaultHandlerApp
(
)
;
}
function
initializeDefaultPreferences
(
)
{
var
defaultBranch
=
Services
.
prefs
.
getDefaultBranch
(
PREF_PREFIX
+
"
.
"
)
;
var
defaultValue
;
for
(
var
key
in
PdfJsDefaultPreferences
)
{
defaultValue
=
PdfJsDefaultPreferences
[
key
]
;
switch
(
typeof
defaultValue
)
{
case
"
boolean
"
:
defaultBranch
.
setBoolPref
(
key
defaultValue
)
;
break
;
case
"
number
"
:
defaultBranch
.
setIntPref
(
key
defaultValue
)
;
break
;
case
"
string
"
:
defaultBranch
.
setCharPref
(
key
defaultValue
)
;
break
;
}
}
}
var
PdfJs
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIObserver
]
)
_initialized
:
false
init
:
function
init
(
remote
)
{
if
(
Services
.
appinfo
.
processType
!
=
=
Services
.
appinfo
.
PROCESS_TYPE_DEFAULT
)
{
throw
new
Error
(
"
PdfJs
.
init
should
only
get
called
"
+
"
in
the
parent
process
.
"
)
;
}
PdfjsChromeUtils
.
init
(
)
;
this
.
initPrefs
(
)
;
Services
.
ppmm
.
sharedData
.
set
(
"
pdfjs
.
enabled
"
this
.
checkEnabled
(
)
)
;
}
initPrefs
:
function
initPrefs
(
)
{
if
(
this
.
_initialized
)
{
return
;
}
this
.
_initialized
=
true
;
if
(
!
getBoolPref
(
PREF_DISABLED
true
)
)
{
this
.
_migrate
(
)
;
}
Services
.
prefs
.
addObserver
(
PREF_DISABLED
this
)
;
Services
.
prefs
.
addObserver
(
PREF_DISABLED_PLUGIN_TYPES
this
)
;
Services
.
obs
.
addObserver
(
this
TOPIC_PDFJS_HANDLER_CHANGED
)
;
Services
.
obs
.
addObserver
(
this
TOPIC_PLUGINS_LIST_UPDATED
)
;
Services
.
obs
.
addObserver
(
this
TOPIC_PLUGIN_INFO_UPDATED
)
;
initializeDefaultPreferences
(
)
;
}
uninit
:
function
uninit
(
)
{
if
(
this
.
_initialized
)
{
Services
.
prefs
.
removeObserver
(
PREF_DISABLED
this
)
;
Services
.
prefs
.
removeObserver
(
PREF_DISABLED_PLUGIN_TYPES
this
)
;
Services
.
obs
.
removeObserver
(
this
TOPIC_PDFJS_HANDLER_CHANGED
)
;
Services
.
obs
.
removeObserver
(
this
TOPIC_PLUGINS_LIST_UPDATED
)
;
Services
.
obs
.
removeObserver
(
this
TOPIC_PLUGIN_INFO_UPDATED
)
;
this
.
_initialized
=
false
;
}
}
_migrate
:
function
migrate
(
)
{
const
VERSION
=
2
;
var
currentVersion
=
getIntPref
(
PREF_MIGRATION_VERSION
0
)
;
if
(
currentVersion
>
=
VERSION
)
{
return
;
}
if
(
currentVersion
<
1
)
{
this
.
_becomeHandler
(
)
;
}
if
(
currentVersion
<
2
)
{
Services
.
prefs
.
clearUserPref
(
PREF_PREFIX
+
"
.
database
"
)
;
}
Services
.
prefs
.
setIntPref
(
PREF_MIGRATION_VERSION
VERSION
)
;
}
_becomeHandler
:
function
_becomeHandler
(
)
{
let
handlerInfo
=
Svc
.
mime
.
getFromTypeAndExtension
(
PDF_CONTENT_TYPE
"
pdf
"
)
;
let
prefs
=
Services
.
prefs
;
if
(
handlerInfo
.
preferredAction
!
=
=
Ci
.
nsIHandlerInfo
.
handleInternally
&
&
handlerInfo
.
preferredAction
!
=
=
false
)
{
prefs
.
setIntPref
(
PREF_PREVIOUS_ACTION
handlerInfo
.
preferredAction
)
;
prefs
.
setBoolPref
(
PREF_PREVIOUS_ASK
handlerInfo
.
alwaysAskBeforeHandling
)
;
}
let
handlerService
=
Cc
[
"
mozilla
.
org
/
uriloader
/
handler
-
service
;
1
"
]
.
getService
(
Ci
.
nsIHandlerService
)
;
handlerInfo
.
alwaysAskBeforeHandling
=
false
;
handlerInfo
.
preferredAction
=
Ci
.
nsIHandlerInfo
.
handleInternally
;
handlerService
.
store
(
handlerInfo
)
;
var
stringTypes
=
"
"
;
var
types
=
[
]
;
if
(
prefs
.
prefHasUserValue
(
PREF_DISABLED_PLUGIN_TYPES
)
)
{
stringTypes
=
prefs
.
getCharPref
(
PREF_DISABLED_PLUGIN_TYPES
)
;
}
if
(
stringTypes
!
=
=
"
"
)
{
types
=
stringTypes
.
split
(
"
"
)
;
}
if
(
!
types
.
includes
(
PDF_CONTENT_TYPE
)
)
{
types
.
push
(
PDF_CONTENT_TYPE
)
;
}
prefs
.
setCharPref
(
PREF_DISABLED_PLUGIN_TYPES
types
.
join
(
"
"
)
)
;
let
categoryManager
=
Cc
[
"
mozilla
.
org
/
categorymanager
;
1
"
]
;
categoryManager
.
getService
(
Ci
.
nsICategoryManager
)
.
deleteCategoryEntry
(
"
Gecko
-
Content
-
Viewers
"
PDF_CONTENT_TYPE
false
)
;
}
_isEnabled
:
function
_isEnabled
(
)
{
var
disabled
=
getBoolPref
(
PREF_DISABLED
true
)
;
if
(
disabled
)
{
return
false
;
}
if
(
!
isDefaultHandler
(
)
)
{
return
false
;
}
if
(
Services
.
prefs
.
prefHasUserValue
(
PREF_DISABLED_PLUGIN_TYPES
)
)
{
let
disabledPluginTypes
=
Services
.
prefs
.
getCharPref
(
PREF_DISABLED_PLUGIN_TYPES
)
.
split
(
"
"
)
;
if
(
disabledPluginTypes
.
includes
(
PDF_CONTENT_TYPE
)
)
{
return
true
;
}
}
let
tags
=
Cc
[
"
mozilla
.
org
/
plugin
/
host
;
1
"
]
.
getService
(
Ci
.
nsIPluginHost
)
.
getPluginTags
(
)
;
let
enabledPluginFound
=
tags
.
some
(
function
(
tag
)
{
if
(
tag
.
disabled
)
{
return
false
;
}
let
mimeTypes
=
tag
.
getMimeTypes
(
)
;
return
mimeTypes
.
some
(
function
(
mimeType
)
{
return
mimeType
=
=
=
PDF_CONTENT_TYPE
;
}
)
;
}
)
;
return
!
enabledPluginFound
;
}
checkEnabled
:
function
checkEnabled
(
)
{
let
isEnabled
=
this
.
_isEnabled
(
)
;
Services
.
prefs
.
setBoolPref
(
PREF_ENABLED_CACHE_STATE
isEnabled
)
;
return
isEnabled
;
}
observe
:
function
observe
(
aSubject
aTopic
aData
)
{
if
(
Services
.
appinfo
.
processType
!
=
=
Services
.
appinfo
.
PROCESS_TYPE_DEFAULT
)
{
throw
new
Error
(
"
Only
the
parent
process
should
be
observing
PDF
"
+
"
handler
changes
.
"
)
;
}
Services
.
ppmm
.
sharedData
.
set
(
"
pdfjs
.
enabled
"
this
.
checkEnabled
(
)
)
;
}
get
enabled
(
)
{
if
(
!
Services
.
policies
.
isAllowed
(
"
PDF
.
js
"
)
)
{
return
false
;
}
if
(
!
Services
.
prefs
.
getBoolPref
(
PREF_ENABLED_CACHE_INITIALIZED
false
)
)
{
if
(
Services
.
prefs
.
prefHasUserValue
(
PREF_APP_UPDATE_POSTUPDATE
)
)
{
this
.
checkEnabled
(
)
;
}
Services
.
prefs
.
setBoolPref
(
PREF_ENABLED_CACHE_INITIALIZED
true
)
;
}
return
Services
.
prefs
.
getBoolPref
(
PREF_ENABLED_CACHE_STATE
true
)
;
}
}
;
