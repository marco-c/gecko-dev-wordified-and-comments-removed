"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
PdfStreamConverter
"
]
;
const
PDFJS_EVENT_ID
=
"
pdf
.
js
.
message
"
;
const
PREF_PREFIX
=
"
pdfjs
"
;
const
PDF_VIEWER_ORIGIN
=
"
resource
:
/
/
pdf
.
js
"
;
const
PDF_VIEWER_WEB_PAGE
=
"
resource
:
/
/
pdf
.
js
/
web
/
viewer
.
html
"
;
const
MAX_NUMBER_OF_PREFS
=
50
;
const
MAX_STRING_PREF_LENGTH
=
128
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
NetUtil
"
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
NetworkManager
"
"
resource
:
/
/
pdf
.
js
/
PdfJsNetwork
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PrivateBrowsingUtils
"
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PdfJsTelemetry
"
"
resource
:
/
/
pdf
.
js
/
PdfJsTelemetry
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PdfjsContentUtils
"
"
resource
:
/
/
pdf
.
js
/
PdfjsContentUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
XMLHttpRequest
"
]
)
;
var
Svc
=
{
}
;
XPCOMUtils
.
defineLazyServiceGetter
(
Svc
"
mime
"
"
mozilla
.
org
/
mime
;
1
"
"
nsIMIMEService
"
)
;
function
getBoolPref
(
pref
def
)
{
try
{
return
Services
.
prefs
.
getBoolPref
(
pref
)
;
}
catch
(
ex
)
{
return
def
;
}
}
function
getIntPref
(
pref
def
)
{
try
{
return
Services
.
prefs
.
getIntPref
(
pref
)
;
}
catch
(
ex
)
{
return
def
;
}
}
function
getStringPref
(
pref
def
)
{
try
{
return
Services
.
prefs
.
getStringPref
(
pref
)
;
}
catch
(
ex
)
{
return
def
;
}
}
function
log
(
aMsg
)
{
if
(
!
getBoolPref
(
PREF_PREFIX
+
"
.
pdfBugEnabled
"
false
)
)
{
return
;
}
var
msg
=
"
PdfStreamConverter
.
js
:
"
+
(
aMsg
.
join
?
aMsg
.
join
(
"
"
)
:
aMsg
)
;
Services
.
console
.
logStringMessage
(
msg
)
;
dump
(
msg
+
"
\
n
"
)
;
}
function
getDOMWindow
(
aChannel
aPrincipal
)
{
var
requestor
=
aChannel
.
notificationCallbacks
?
aChannel
.
notificationCallbacks
:
aChannel
.
loadGroup
.
notificationCallbacks
;
var
win
=
requestor
.
getInterface
(
Ci
.
nsIDOMWindow
)
;
if
(
!
win
.
document
.
nodePrincipal
.
equals
(
aPrincipal
)
)
{
return
null
;
}
return
win
;
}
function
getLocalizedStrings
(
path
)
{
var
stringBundle
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
pdf
.
js
/
locale
/
"
+
path
)
;
var
map
=
{
}
;
for
(
let
string
of
stringBundle
.
getSimpleEnumeration
(
)
)
{
var
key
=
string
.
key
property
=
"
textContent
"
;
var
i
=
key
.
lastIndexOf
(
"
.
"
)
;
if
(
i
>
=
0
)
{
property
=
key
.
substring
(
i
+
1
)
;
key
=
key
.
substring
(
0
i
)
;
}
if
(
!
(
key
in
map
)
)
{
map
[
key
]
=
{
}
;
}
map
[
key
]
[
property
]
=
string
.
value
;
}
return
map
;
}
function
getLocalizedString
(
strings
id
property
)
{
property
=
property
|
|
"
textContent
"
;
if
(
id
in
strings
)
{
return
strings
[
id
]
[
property
]
;
}
return
id
;
}
function
isValidMatchesCount
(
data
)
{
if
(
typeof
data
!
=
=
"
object
"
|
|
data
=
=
=
null
)
{
return
false
;
}
const
{
current
total
}
=
data
;
if
(
typeof
total
!
=
=
"
number
"
|
|
total
<
0
|
|
typeof
current
!
=
=
"
number
"
|
|
current
<
0
|
|
current
>
total
)
{
return
false
;
}
return
true
;
}
function
PdfDataListener
(
length
)
{
this
.
length
=
length
;
this
.
buffers
=
[
]
;
this
.
loaded
=
0
;
}
PdfDataListener
.
prototype
=
{
append
:
function
PdfDataListener_append
(
chunk
)
{
this
.
buffers
.
push
(
chunk
)
;
this
.
loaded
+
=
chunk
.
length
;
if
(
this
.
length
>
=
0
&
&
this
.
length
<
this
.
loaded
)
{
this
.
length
=
-
1
;
}
this
.
onprogress
(
this
.
loaded
this
.
length
>
=
0
?
this
.
length
:
void
0
)
;
}
readData
:
function
PdfDataListener_readData
(
)
{
if
(
this
.
buffers
.
length
=
=
=
0
)
{
return
null
;
}
if
(
this
.
buffers
.
length
=
=
=
1
)
{
return
this
.
buffers
.
pop
(
)
;
}
let
combinedLength
=
0
;
for
(
let
buffer
of
this
.
buffers
)
{
combinedLength
+
=
buffer
.
length
;
}
let
combinedArray
=
new
Uint8Array
(
combinedLength
)
;
let
writeOffset
=
0
;
while
(
this
.
buffers
.
length
)
{
let
buffer
=
this
.
buffers
.
shift
(
)
;
combinedArray
.
set
(
buffer
writeOffset
)
;
writeOffset
+
=
buffer
.
length
;
}
return
combinedArray
;
}
get
isDone
(
)
{
return
!
!
this
.
isDataReady
;
}
finish
:
function
PdfDataListener_finish
(
)
{
this
.
isDataReady
=
true
;
if
(
this
.
oncompleteCallback
)
{
this
.
oncompleteCallback
(
this
.
readData
(
)
)
;
}
}
error
:
function
PdfDataListener_error
(
errorCode
)
{
this
.
errorCode
=
errorCode
;
if
(
this
.
oncompleteCallback
)
{
this
.
oncompleteCallback
(
null
errorCode
)
;
}
}
onprogress
(
)
{
}
get
oncomplete
(
)
{
return
this
.
oncompleteCallback
;
}
set
oncomplete
(
value
)
{
this
.
oncompleteCallback
=
value
;
if
(
this
.
isDataReady
)
{
value
(
this
.
readData
(
)
)
;
}
if
(
this
.
errorCode
)
{
value
(
null
this
.
errorCode
)
;
}
}
}
;
class
ChromeActions
{
constructor
(
domWindow
contentDispositionFilename
)
{
this
.
domWindow
=
domWindow
;
this
.
contentDispositionFilename
=
contentDispositionFilename
;
this
.
telemetryState
=
{
documentInfo
:
false
firstPageInfo
:
false
streamTypesUsed
:
{
}
fontTypesUsed
:
{
}
}
;
}
isInPrivateBrowsing
(
)
{
return
PrivateBrowsingUtils
.
isContentWindowPrivate
(
this
.
domWindow
)
;
}
getWindowOriginAttributes
(
)
{
try
{
return
this
.
domWindow
.
document
.
nodePrincipal
.
originAttributes
;
}
catch
(
err
)
{
return
{
}
;
}
}
download
(
data
sendResponse
)
{
var
self
=
this
;
var
originalUrl
=
data
.
originalUrl
;
var
blobUrl
=
data
.
blobUrl
|
|
originalUrl
;
var
originalUri
=
NetUtil
.
newURI
(
originalUrl
)
;
var
filename
=
data
.
filename
;
if
(
typeof
filename
!
=
=
"
string
"
|
|
(
!
/
\
.
pdf
/
i
.
test
(
filename
)
&
&
!
data
.
isAttachment
)
)
{
filename
=
"
document
.
pdf
"
;
}
var
blobUri
=
NetUtil
.
newURI
(
blobUrl
)
;
var
extHelperAppSvc
=
Cc
[
"
mozilla
.
org
/
uriloader
/
external
-
helper
-
app
-
service
;
1
"
]
.
getService
(
Ci
.
nsIExternalHelperAppService
)
;
var
docIsPrivate
=
this
.
isInPrivateBrowsing
(
)
;
var
netChannel
=
NetUtil
.
newChannel
(
{
uri
:
blobUri
loadUsingSystemPrincipal
:
true
}
)
;
if
(
"
nsIPrivateBrowsingChannel
"
in
Ci
&
&
netChannel
instanceof
Ci
.
nsIPrivateBrowsingChannel
)
{
netChannel
.
setPrivate
(
docIsPrivate
)
;
}
NetUtil
.
asyncFetch
(
netChannel
function
(
aInputStream
aResult
)
{
if
(
!
Components
.
isSuccessCode
(
aResult
)
)
{
if
(
sendResponse
)
{
sendResponse
(
true
)
;
}
return
;
}
var
channel
=
Cc
[
"
mozilla
.
org
/
network
/
input
-
stream
-
channel
;
1
"
]
.
createInstance
(
Ci
.
nsIInputStreamChannel
)
;
channel
.
QueryInterface
(
Ci
.
nsIChannel
)
;
try
{
channel
.
contentDisposition
=
Ci
.
nsIChannel
.
DISPOSITION_ATTACHMENT
;
if
(
self
.
contentDispositionFilename
&
&
!
data
.
isAttachment
)
{
channel
.
contentDispositionFilename
=
self
.
contentDispositionFilename
;
}
else
{
channel
.
contentDispositionFilename
=
filename
;
}
}
catch
(
e
)
{
}
channel
.
setURI
(
originalUri
)
;
channel
.
loadInfo
=
netChannel
.
loadInfo
;
channel
.
contentStream
=
aInputStream
;
if
(
"
nsIPrivateBrowsingChannel
"
in
Ci
&
&
channel
instanceof
Ci
.
nsIPrivateBrowsingChannel
)
{
channel
.
setPrivate
(
docIsPrivate
)
;
}
var
listener
=
{
extListener
:
null
onStartRequest
(
aRequest
)
{
var
loadContext
=
self
.
domWindow
.
docShell
.
QueryInterface
(
Ci
.
nsILoadContext
)
;
this
.
extListener
=
extHelperAppSvc
.
doContent
(
data
.
isAttachment
?
"
application
/
octet
-
stream
"
:
"
application
/
pdf
"
aRequest
loadContext
false
)
;
this
.
extListener
.
onStartRequest
(
aRequest
)
;
}
onStopRequest
(
aRequest
aStatusCode
)
{
if
(
this
.
extListener
)
{
this
.
extListener
.
onStopRequest
(
aRequest
aStatusCode
)
;
}
if
(
sendResponse
)
{
sendResponse
(
false
)
;
}
}
onDataAvailable
(
aRequest
aDataInputStream
aOffset
aCount
)
{
this
.
extListener
.
onDataAvailable
(
aRequest
aDataInputStream
aOffset
aCount
)
;
}
}
;
channel
.
asyncOpen
(
listener
)
;
}
)
;
}
getLocale
(
)
{
return
Services
.
locale
.
requestedLocale
|
|
"
en
-
US
"
;
}
getStrings
(
data
)
{
try
{
if
(
!
(
"
localizedStrings
"
in
this
)
)
{
this
.
localizedStrings
=
getLocalizedStrings
(
"
viewer
.
properties
"
)
;
}
var
result
=
this
.
localizedStrings
[
data
]
;
return
JSON
.
stringify
(
result
|
|
null
)
;
}
catch
(
e
)
{
log
(
"
Unable
to
retrieve
localized
strings
:
"
+
e
)
;
return
"
null
"
;
}
}
supportsIntegratedFind
(
)
{
return
this
.
domWindow
.
frameElement
=
=
=
null
;
}
supportsDocumentFonts
(
)
{
var
prefBrowser
=
getIntPref
(
"
browser
.
display
.
use_document_fonts
"
1
)
;
var
prefGfx
=
getBoolPref
(
"
gfx
.
downloadable_fonts
.
enabled
"
true
)
;
return
!
!
prefBrowser
&
&
prefGfx
;
}
supportedMouseWheelZoomModifierKeys
(
)
{
return
{
ctrlKey
:
getIntPref
(
"
mousewheel
.
with_control
.
action
"
3
)
=
=
=
3
metaKey
:
getIntPref
(
"
mousewheel
.
with_meta
.
action
"
1
)
=
=
=
3
}
;
}
isInAutomation
(
)
{
return
Cu
.
isInAutomation
;
}
reportTelemetry
(
data
)
{
var
probeInfo
=
JSON
.
parse
(
data
)
;
switch
(
probeInfo
.
type
)
{
case
"
documentInfo
"
:
if
(
!
this
.
telemetryState
.
documentInfo
)
{
PdfJsTelemetry
.
onDocumentVersion
(
probeInfo
.
version
)
;
PdfJsTelemetry
.
onDocumentGenerator
(
probeInfo
.
generator
)
;
if
(
probeInfo
.
formType
)
{
PdfJsTelemetry
.
onForm
(
probeInfo
.
formType
)
;
}
this
.
telemetryState
.
documentInfo
=
true
;
}
break
;
case
"
pageInfo
"
:
if
(
!
this
.
telemetryState
.
firstPageInfo
)
{
PdfJsTelemetry
.
onTimeToView
(
probeInfo
.
timestamp
)
;
this
.
telemetryState
.
firstPageInfo
=
true
;
}
break
;
case
"
documentStats
"
:
var
documentStats
=
probeInfo
.
stats
;
if
(
!
documentStats
|
|
typeof
documentStats
!
=
=
"
object
"
)
{
break
;
}
var
i
streamTypes
=
documentStats
.
streamTypes
key
;
var
STREAM_TYPE_ID_LIMIT
=
20
;
i
=
0
;
for
(
key
in
streamTypes
)
{
if
(
+
+
i
>
STREAM_TYPE_ID_LIMIT
)
{
break
;
}
if
(
!
this
.
telemetryState
.
streamTypesUsed
[
key
]
)
{
PdfJsTelemetry
.
onStreamType
(
key
)
;
this
.
telemetryState
.
streamTypesUsed
[
key
]
=
true
;
}
}
var
fontTypes
=
documentStats
.
fontTypes
;
var
FONT_TYPE_ID_LIMIT
=
20
;
i
=
0
;
for
(
key
in
fontTypes
)
{
if
(
+
+
i
>
FONT_TYPE_ID_LIMIT
)
{
break
;
}
if
(
!
this
.
telemetryState
.
fontTypesUsed
[
key
]
)
{
PdfJsTelemetry
.
onFontType
(
key
)
;
this
.
telemetryState
.
fontTypesUsed
[
key
]
=
true
;
}
}
break
;
case
"
print
"
:
PdfJsTelemetry
.
onPrint
(
)
;
break
;
}
}
fallback
(
args
sendResponse
)
{
var
featureId
=
args
.
featureId
;
var
domWindow
=
this
.
domWindow
;
var
strings
=
getLocalizedStrings
(
"
chrome
.
properties
"
)
;
var
message
;
if
(
featureId
=
=
=
"
forms
"
)
{
message
=
getLocalizedString
(
strings
"
unsupported_feature_forms
"
)
;
}
else
{
message
=
getLocalizedString
(
strings
"
unsupported_feature
"
)
;
}
PdfJsTelemetry
.
onFallback
(
)
;
PdfjsContentUtils
.
displayWarning
(
domWindow
message
getLocalizedString
(
strings
"
open_with_different_viewer
"
)
getLocalizedString
(
strings
"
open_with_different_viewer
"
"
accessKey
"
)
)
;
let
winmm
=
domWindow
.
docShell
.
messageManager
;
winmm
.
addMessageListener
(
"
PDFJS
:
Child
:
fallbackDownload
"
function
fallbackDownload
(
msg
)
{
let
data
=
msg
.
data
;
sendResponse
(
data
.
download
)
;
winmm
.
removeMessageListener
(
"
PDFJS
:
Child
:
fallbackDownload
"
fallbackDownload
)
;
}
)
;
}
updateFindControlState
(
data
)
{
if
(
!
this
.
supportsIntegratedFind
(
)
)
{
return
;
}
var
result
=
data
.
result
;
var
findPrevious
=
data
.
findPrevious
;
var
findPreviousType
=
typeof
findPrevious
;
if
(
typeof
result
!
=
=
"
number
"
|
|
result
<
0
|
|
result
>
3
|
|
(
findPreviousType
!
=
=
"
undefined
"
&
&
findPreviousType
!
=
=
"
boolean
"
)
)
{
return
;
}
let
matchesCount
=
null
;
if
(
isValidMatchesCount
(
data
.
matchesCount
)
)
{
matchesCount
=
data
.
matchesCount
;
}
var
winmm
=
this
.
domWindow
.
docShell
.
messageManager
;
winmm
.
sendAsyncMessage
(
"
PDFJS
:
Parent
:
updateControlState
"
{
result
findPrevious
matchesCount
}
)
;
}
updateFindMatchesCount
(
data
)
{
if
(
!
this
.
supportsIntegratedFind
(
)
)
{
return
;
}
if
(
!
isValidMatchesCount
(
data
)
)
{
return
;
}
const
winmm
=
this
.
domWindow
.
docShell
.
messageManager
;
winmm
.
sendAsyncMessage
(
"
PDFJS
:
Parent
:
updateMatchesCount
"
data
)
;
}
setPreferences
(
prefs
sendResponse
)
{
var
defaultBranch
=
Services
.
prefs
.
getDefaultBranch
(
PREF_PREFIX
+
"
.
"
)
;
var
numberOfPrefs
=
0
;
var
prefValue
prefName
;
for
(
var
key
in
prefs
)
{
if
(
+
+
numberOfPrefs
>
MAX_NUMBER_OF_PREFS
)
{
log
(
"
setPreferences
-
Exceeded
the
maximum
number
of
preferences
"
+
"
that
is
allowed
to
be
set
at
once
.
"
)
;
break
;
}
else
if
(
!
defaultBranch
.
getPrefType
(
key
)
)
{
continue
;
}
prefValue
=
prefs
[
key
]
;
prefName
=
PREF_PREFIX
+
"
.
"
+
key
;
switch
(
typeof
prefValue
)
{
case
"
boolean
"
:
PdfjsContentUtils
.
setBoolPref
(
prefName
prefValue
)
;
break
;
case
"
number
"
:
PdfjsContentUtils
.
setIntPref
(
prefName
prefValue
)
;
break
;
case
"
string
"
:
if
(
prefValue
.
length
>
MAX_STRING_PREF_LENGTH
)
{
log
(
"
setPreferences
-
Exceeded
the
maximum
allowed
length
"
+
"
for
a
string
preference
.
"
)
;
}
else
{
PdfjsContentUtils
.
setStringPref
(
prefName
prefValue
)
;
}
break
;
}
}
if
(
sendResponse
)
{
sendResponse
(
true
)
;
}
}
getPreferences
(
prefs
sendResponse
)
{
var
defaultBranch
=
Services
.
prefs
.
getDefaultBranch
(
PREF_PREFIX
+
"
.
"
)
;
var
currentPrefs
=
{
}
numberOfPrefs
=
0
;
var
prefValue
prefName
;
for
(
var
key
in
prefs
)
{
if
(
+
+
numberOfPrefs
>
MAX_NUMBER_OF_PREFS
)
{
log
(
"
getPreferences
-
Exceeded
the
maximum
number
of
preferences
"
+
"
that
is
allowed
to
be
fetched
at
once
.
"
)
;
break
;
}
else
if
(
!
defaultBranch
.
getPrefType
(
key
)
)
{
continue
;
}
prefValue
=
prefs
[
key
]
;
prefName
=
PREF_PREFIX
+
"
.
"
+
key
;
switch
(
typeof
prefValue
)
{
case
"
boolean
"
:
currentPrefs
[
key
]
=
getBoolPref
(
prefName
prefValue
)
;
break
;
case
"
number
"
:
currentPrefs
[
key
]
=
getIntPref
(
prefName
prefValue
)
;
break
;
case
"
string
"
:
currentPrefs
[
key
]
=
getStringPref
(
prefName
prefValue
)
;
break
;
}
}
let
result
=
JSON
.
stringify
(
currentPrefs
)
;
if
(
sendResponse
)
{
sendResponse
(
result
)
;
}
return
result
;
}
}
class
RangedChromeActions
extends
ChromeActions
{
constructor
(
domWindow
contentDispositionFilename
originalRequest
rangeEnabled
streamingEnabled
dataListener
)
{
super
(
domWindow
contentDispositionFilename
)
;
this
.
dataListener
=
dataListener
;
this
.
originalRequest
=
originalRequest
;
this
.
rangeEnabled
=
rangeEnabled
;
this
.
streamingEnabled
=
streamingEnabled
;
this
.
pdfUrl
=
originalRequest
.
URI
.
spec
;
this
.
contentLength
=
originalRequest
.
contentLength
;
var
httpHeaderVisitor
=
{
headers
:
{
}
visitHeader
(
aHeader
aValue
)
{
if
(
aHeader
=
=
=
"
Range
"
)
{
return
;
}
this
.
headers
[
aHeader
]
=
aValue
;
}
}
;
if
(
originalRequest
.
visitRequestHeaders
)
{
originalRequest
.
visitRequestHeaders
(
httpHeaderVisitor
)
;
}
var
self
=
this
;
var
xhr_onreadystatechange
=
function
xhr_onreadystatechange
(
)
{
if
(
this
.
readyState
=
=
=
1
)
{
var
netChannel
=
this
.
channel
;
this
.
setOriginAttributes
(
self
.
getWindowOriginAttributes
(
)
)
;
if
(
"
nsIPrivateBrowsingChannel
"
in
Ci
&
&
netChannel
instanceof
Ci
.
nsIPrivateBrowsingChannel
)
{
var
docIsPrivate
=
self
.
isInPrivateBrowsing
(
)
;
netChannel
.
setPrivate
(
docIsPrivate
)
;
}
}
}
;
var
getXhr
=
function
getXhr
(
)
{
var
xhr
=
new
XMLHttpRequest
(
)
;
xhr
.
addEventListener
(
"
readystatechange
"
xhr_onreadystatechange
)
;
return
xhr
;
}
;
this
.
networkManager
=
new
NetworkManager
(
this
.
pdfUrl
{
httpHeaders
:
httpHeaderVisitor
.
headers
getXhr
}
)
;
domWindow
.
addEventListener
(
"
unload
"
function
unload
(
e
)
{
domWindow
.
removeEventListener
(
e
.
type
unload
)
;
self
.
abortLoading
(
)
;
}
)
;
}
initPassiveLoading
(
)
{
let
data
done
;
if
(
!
this
.
streamingEnabled
)
{
this
.
originalRequest
.
cancel
(
Cr
.
NS_BINDING_ABORTED
)
;
this
.
originalRequest
=
null
;
data
=
this
.
dataListener
.
readData
(
)
;
done
=
this
.
dataListener
.
isDone
;
this
.
dataListener
=
null
;
}
else
{
data
=
this
.
dataListener
.
readData
(
)
;
done
=
this
.
dataListener
.
isDone
;
this
.
dataListener
.
onprogress
=
(
loaded
total
)
=
>
{
this
.
domWindow
.
postMessage
(
{
pdfjsLoadAction
:
"
progressiveRead
"
loaded
total
chunk
:
this
.
dataListener
.
readData
(
)
}
PDF_VIEWER_ORIGIN
)
;
}
;
this
.
dataListener
.
oncomplete
=
(
)
=
>
{
if
(
!
done
&
&
this
.
dataListener
.
isDone
)
{
this
.
domWindow
.
postMessage
(
{
pdfjsLoadAction
:
"
progressiveDone
"
}
PDF_VIEWER_ORIGIN
)
;
}
this
.
dataListener
=
null
;
}
;
}
this
.
domWindow
.
postMessage
(
{
pdfjsLoadAction
:
"
supportsRangedLoading
"
rangeEnabled
:
this
.
rangeEnabled
streamingEnabled
:
this
.
streamingEnabled
pdfUrl
:
this
.
pdfUrl
length
:
this
.
contentLength
data
done
}
PDF_VIEWER_ORIGIN
)
;
return
true
;
}
requestDataRange
(
args
)
{
if
(
!
this
.
rangeEnabled
)
{
return
;
}
var
begin
=
args
.
begin
;
var
end
=
args
.
end
;
var
domWindow
=
this
.
domWindow
;
this
.
networkManager
.
requestRange
(
begin
end
{
onDone
:
function
RangedChromeActions_onDone
(
aArgs
)
{
domWindow
.
postMessage
(
{
pdfjsLoadAction
:
"
range
"
begin
:
aArgs
.
begin
chunk
:
aArgs
.
chunk
}
PDF_VIEWER_ORIGIN
)
;
}
onProgress
:
function
RangedChromeActions_onProgress
(
evt
)
{
domWindow
.
postMessage
(
{
pdfjsLoadAction
:
"
rangeProgress
"
loaded
:
evt
.
loaded
}
PDF_VIEWER_ORIGIN
)
;
}
}
)
;
}
abortLoading
(
)
{
this
.
networkManager
.
abortAllRequests
(
)
;
if
(
this
.
originalRequest
)
{
this
.
originalRequest
.
cancel
(
Cr
.
NS_BINDING_ABORTED
)
;
this
.
originalRequest
=
null
;
}
this
.
dataListener
=
null
;
}
}
class
StandardChromeActions
extends
ChromeActions
{
constructor
(
domWindow
contentDispositionFilename
originalRequest
dataListener
)
{
super
(
domWindow
contentDispositionFilename
)
;
this
.
originalRequest
=
originalRequest
;
this
.
dataListener
=
dataListener
;
}
initPassiveLoading
(
)
{
if
(
!
this
.
dataListener
)
{
return
false
;
}
this
.
dataListener
.
onprogress
=
(
loaded
total
)
=
>
{
this
.
domWindow
.
postMessage
(
{
pdfjsLoadAction
:
"
progress
"
loaded
total
}
PDF_VIEWER_ORIGIN
)
;
}
;
this
.
dataListener
.
oncomplete
=
(
data
errorCode
)
=
>
{
this
.
domWindow
.
postMessage
(
{
pdfjsLoadAction
:
"
complete
"
data
errorCode
}
PDF_VIEWER_ORIGIN
)
;
this
.
dataListener
=
null
;
this
.
originalRequest
=
null
;
}
;
return
true
;
}
abortLoading
(
)
{
if
(
this
.
originalRequest
)
{
this
.
originalRequest
.
cancel
(
Cr
.
NS_BINDING_ABORTED
)
;
this
.
originalRequest
=
null
;
}
this
.
dataListener
=
null
;
}
}
class
RequestListener
{
constructor
(
actions
)
{
this
.
actions
=
actions
;
}
receive
(
event
)
{
var
message
=
event
.
target
;
var
doc
=
message
.
ownerDocument
;
var
action
=
event
.
detail
.
action
;
var
data
=
event
.
detail
.
data
;
var
sync
=
event
.
detail
.
sync
;
var
actions
=
this
.
actions
;
if
(
!
(
action
in
actions
)
)
{
log
(
"
Unknown
action
:
"
+
action
)
;
return
;
}
var
response
;
if
(
sync
)
{
response
=
actions
[
action
]
.
call
(
this
.
actions
data
)
;
event
.
detail
.
response
=
Cu
.
cloneInto
(
response
doc
.
defaultView
)
;
}
else
{
if
(
!
event
.
detail
.
responseExpected
)
{
doc
.
documentElement
.
removeChild
(
message
)
;
response
=
null
;
}
else
{
response
=
function
sendResponse
(
aResponse
)
{
try
{
var
listener
=
doc
.
createEvent
(
"
CustomEvent
"
)
;
let
detail
=
Cu
.
cloneInto
(
{
response
:
aResponse
}
doc
.
defaultView
)
;
listener
.
initCustomEvent
(
"
pdf
.
js
.
response
"
true
false
detail
)
;
return
message
.
dispatchEvent
(
listener
)
;
}
catch
(
e
)
{
return
false
;
}
}
;
}
actions
[
action
]
.
call
(
this
.
actions
data
response
)
;
}
}
}
class
FindEventManager
{
constructor
(
contentWindow
)
{
this
.
contentWindow
=
contentWindow
;
this
.
winmm
=
contentWindow
.
docShell
.
messageManager
;
}
bind
(
)
{
this
.
contentWindow
.
addEventListener
(
"
unload
"
evt
=
>
{
this
.
unbind
(
)
;
}
{
once
:
true
}
)
;
this
.
winmm
.
sendAsyncMessage
(
"
PDFJS
:
Parent
:
addEventListener
"
)
;
this
.
winmm
.
addMessageListener
(
"
PDFJS
:
Child
:
handleEvent
"
this
)
;
}
receiveMessage
(
msg
)
{
var
detail
=
msg
.
data
.
detail
;
var
type
=
msg
.
data
.
type
;
var
contentWindow
=
this
.
contentWindow
;
detail
=
Cu
.
cloneInto
(
detail
contentWindow
)
;
var
forward
=
contentWindow
.
document
.
createEvent
(
"
CustomEvent
"
)
;
forward
.
initCustomEvent
(
type
true
true
detail
)
;
contentWindow
.
dispatchEvent
(
forward
)
;
}
unbind
(
)
{
this
.
winmm
.
sendAsyncMessage
(
"
PDFJS
:
Parent
:
removeEventListener
"
)
;
this
.
winmm
.
removeMessageListener
(
"
PDFJS
:
Child
:
handleEvent
"
this
)
;
}
}
class
ZoomEventManager
{
constructor
(
contentWindow
)
{
this
.
contentWindow
=
contentWindow
;
this
.
winmm
=
contentWindow
.
docShell
.
messageManager
;
}
bind
(
)
{
this
.
contentWindow
.
addEventListener
(
"
unload
"
evt
=
>
{
this
.
unbind
(
)
;
}
{
once
:
true
}
)
;
this
.
winmm
.
addMessageListener
(
"
PDFJS
:
ZoomIn
"
this
)
;
this
.
winmm
.
addMessageListener
(
"
PDFJS
:
ZoomOut
"
this
)
;
this
.
winmm
.
addMessageListener
(
"
PDFJS
:
ZoomReset
"
this
)
;
}
receiveMessage
(
msg
)
{
const
type
=
msg
.
name
.
split
(
"
PDFJS
:
"
)
[
1
]
.
toLowerCase
(
)
;
const
contentWindow
=
this
.
contentWindow
;
const
forward
=
contentWindow
.
document
.
createEvent
(
"
CustomEvent
"
)
;
forward
.
initCustomEvent
(
type
true
true
null
)
;
contentWindow
.
dispatchEvent
(
forward
)
;
}
unbind
(
)
{
this
.
winmm
.
removeMessageListener
(
"
PDFJS
:
ZoomIn
"
this
)
;
this
.
winmm
.
removeMessageListener
(
"
PDFJS
:
ZoomOut
"
this
)
;
this
.
winmm
.
removeMessageListener
(
"
PDFJS
:
ZoomReset
"
this
)
;
}
}
function
PdfStreamConverter
(
)
{
}
PdfStreamConverter
.
prototype
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIStreamConverter
Ci
.
nsIStreamListener
Ci
.
nsIRequestObserver
]
)
convert
(
aFromStream
aFromType
aToType
aCtxt
)
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_NOT_IMPLEMENTED
)
;
}
asyncConvertData
(
aFromType
aToType
aListener
aCtxt
)
{
this
.
listener
=
aListener
;
}
getConvertedType
(
aFromType
)
{
return
"
text
/
html
"
;
}
onDataAvailable
(
aRequest
aInputStream
aOffset
aCount
)
{
if
(
!
this
.
dataListener
)
{
return
;
}
var
binaryStream
=
this
.
binaryStream
;
binaryStream
.
setInputStream
(
aInputStream
)
;
let
chunk
=
new
ArrayBuffer
(
aCount
)
;
binaryStream
.
readArrayBuffer
(
aCount
chunk
)
;
this
.
dataListener
.
append
(
new
Uint8Array
(
chunk
)
)
;
}
onStartRequest
(
aRequest
)
{
var
isHttpRequest
=
false
;
try
{
aRequest
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
isHttpRequest
=
true
;
}
catch
(
e
)
{
}
var
rangeRequest
=
false
;
var
streamRequest
=
false
;
if
(
isHttpRequest
)
{
var
contentEncoding
=
"
identity
"
;
try
{
contentEncoding
=
aRequest
.
getResponseHeader
(
"
Content
-
Encoding
"
)
;
}
catch
(
e
)
{
}
var
acceptRanges
;
try
{
acceptRanges
=
aRequest
.
getResponseHeader
(
"
Accept
-
Ranges
"
)
;
}
catch
(
e
)
{
}
var
hash
=
aRequest
.
URI
.
ref
;
var
isPDFBugEnabled
=
getBoolPref
(
PREF_PREFIX
+
"
.
pdfBugEnabled
"
false
)
;
rangeRequest
=
contentEncoding
=
=
=
"
identity
"
&
&
acceptRanges
=
=
=
"
bytes
"
&
&
aRequest
.
contentLength
>
=
0
&
&
!
getBoolPref
(
PREF_PREFIX
+
"
.
disableRange
"
false
)
&
&
(
!
isPDFBugEnabled
|
|
!
hash
.
toLowerCase
(
)
.
includes
(
"
disablerange
=
true
"
)
)
;
streamRequest
=
contentEncoding
=
=
=
"
identity
"
&
&
aRequest
.
contentLength
>
=
0
&
&
!
getBoolPref
(
PREF_PREFIX
+
"
.
disableStream
"
false
)
&
&
(
!
isPDFBugEnabled
|
|
!
hash
.
toLowerCase
(
)
.
includes
(
"
disablestream
=
true
"
)
)
;
}
aRequest
.
QueryInterface
(
Ci
.
nsIChannel
)
;
aRequest
.
QueryInterface
(
Ci
.
nsIWritablePropertyBag
)
;
var
contentDispositionFilename
;
try
{
contentDispositionFilename
=
aRequest
.
contentDispositionFilename
;
}
catch
(
e
)
{
}
aRequest
.
setProperty
(
"
contentType
"
aRequest
.
contentType
)
;
aRequest
.
contentType
=
"
text
/
html
"
;
if
(
isHttpRequest
)
{
aRequest
.
setResponseHeader
(
"
Content
-
Security
-
Policy
"
"
"
false
)
;
aRequest
.
setResponseHeader
(
"
Content
-
Security
-
Policy
-
Report
-
Only
"
"
"
false
)
;
aRequest
.
setResponseHeader
(
"
Refresh
"
"
"
false
)
;
}
PdfJsTelemetry
.
onViewerIsUsed
(
)
;
PdfJsTelemetry
.
onDocumentSize
(
aRequest
.
contentLength
)
;
var
contentLength
=
aRequest
.
contentLength
;
this
.
dataListener
=
new
PdfDataListener
(
contentLength
)
;
this
.
binaryStream
=
Cc
[
"
mozilla
.
org
/
binaryinputstream
;
1
"
]
.
createInstance
(
Ci
.
nsIBinaryInputStream
)
;
var
channel
=
NetUtil
.
newChannel
(
{
uri
:
PDF_VIEWER_WEB_PAGE
loadUsingSystemPrincipal
:
true
}
)
;
var
listener
=
this
.
listener
;
var
dataListener
=
this
.
dataListener
;
var
proxy
=
{
onStartRequest
(
request
)
{
listener
.
onStartRequest
(
aRequest
)
;
}
onDataAvailable
(
request
inputStream
offset
count
)
{
listener
.
onDataAvailable
(
aRequest
inputStream
offset
count
)
;
}
onStopRequest
(
request
statusCode
)
{
var
domWindow
=
getDOMWindow
(
channel
resourcePrincipal
)
;
if
(
!
Components
.
isSuccessCode
(
statusCode
)
|
|
!
domWindow
)
{
listener
.
onStopRequest
(
aRequest
statusCode
)
;
return
;
}
var
actions
;
if
(
rangeRequest
|
|
streamRequest
)
{
actions
=
new
RangedChromeActions
(
domWindow
contentDispositionFilename
aRequest
rangeRequest
streamRequest
dataListener
)
;
}
else
{
actions
=
new
StandardChromeActions
(
domWindow
contentDispositionFilename
aRequest
dataListener
)
;
}
var
requestListener
=
new
RequestListener
(
actions
)
;
domWindow
.
document
.
addEventListener
(
PDFJS_EVENT_ID
function
(
event
)
{
requestListener
.
receive
(
event
)
;
}
false
true
)
;
if
(
actions
.
supportsIntegratedFind
(
)
)
{
var
findEventManager
=
new
FindEventManager
(
domWindow
)
;
findEventManager
.
bind
(
)
;
}
const
zoomEventManager
=
new
ZoomEventManager
(
domWindow
)
;
zoomEventManager
.
bind
(
)
;
listener
.
onStopRequest
(
aRequest
statusCode
)
;
if
(
domWindow
.
frameElement
)
{
var
isObjectEmbed
=
domWindow
.
frameElement
.
tagName
!
=
=
"
IFRAME
"
|
|
domWindow
.
frameElement
.
className
=
=
=
"
previewPluginContentFrame
"
;
PdfJsTelemetry
.
onEmbed
(
isObjectEmbed
)
;
}
}
}
;
channel
.
originalURI
=
aRequest
.
URI
;
channel
.
loadGroup
=
aRequest
.
loadGroup
;
channel
.
loadInfo
.
originAttributes
=
aRequest
.
loadInfo
.
originAttributes
;
var
uri
=
NetUtil
.
newURI
(
PDF_VIEWER_WEB_PAGE
)
;
var
resourcePrincipal
=
Services
.
scriptSecurityManager
.
createContentPrincipal
(
uri
aRequest
.
loadInfo
.
originAttributes
)
;
let
originalPrincipal
=
Services
.
scriptSecurityManager
.
getChannelResultPrincipal
(
aRequest
)
;
aRequest
.
owner
=
resourcePrincipal
;
aRequest
.
setProperty
(
"
noPDFJSPrincipal
"
originalPrincipal
)
;
channel
.
asyncOpen
(
proxy
)
;
}
onStopRequest
(
aRequest
aStatusCode
)
{
if
(
!
this
.
dataListener
)
{
return
;
}
if
(
Components
.
isSuccessCode
(
aStatusCode
)
)
{
this
.
dataListener
.
finish
(
)
;
}
else
{
this
.
dataListener
.
error
(
aStatusCode
)
;
}
delete
this
.
dataListener
;
delete
this
.
binaryStream
;
}
}
;
