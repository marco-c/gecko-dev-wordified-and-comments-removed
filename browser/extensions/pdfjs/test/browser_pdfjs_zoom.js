Components
.
utils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Promise
.
jsm
"
this
)
;
const
RELATIVE_DIR
=
"
browser
/
extensions
/
pdfjs
/
test
/
"
;
const
TESTROOT
=
"
http
:
/
/
example
.
com
/
browser
/
"
+
RELATIVE_DIR
;
const
TESTS
=
[
{
action
:
{
selector
:
"
button
#
zoomIn
"
event
:
"
click
"
}
expectedZoom
:
1
message
:
"
Zoomed
in
using
the
'
+
'
(
zoom
in
)
button
"
}
{
action
:
{
selector
:
"
button
#
zoomOut
"
event
:
"
click
"
}
expectedZoom
:
-
1
message
:
"
Zoomed
out
using
the
'
-
'
(
zoom
out
)
button
"
}
{
action
:
{
keyboard
:
true
keyCode
:
61
event
:
"
+
"
}
expectedZoom
:
1
message
:
"
Zoomed
in
using
the
CTRL
+
+
keys
"
}
{
action
:
{
keyboard
:
true
keyCode
:
109
event
:
"
-
"
}
expectedZoom
:
-
1
message
:
"
Zoomed
out
using
the
CTRL
+
-
keys
"
}
{
action
:
{
selector
:
"
select
#
scaleSelect
"
index
:
5
event
:
"
change
"
}
expectedZoom
:
-
1
message
:
"
Zoomed
using
the
zoom
picker
"
}
]
;
add_task
(
function
*
test
(
)
{
let
handlerService
=
Cc
[
"
mozilla
.
org
/
uriloader
/
handler
-
service
;
1
"
]
.
getService
(
Ci
.
nsIHandlerService
)
;
let
mimeService
=
Cc
[
"
mozilla
.
org
/
mime
;
1
"
]
.
getService
(
Ci
.
nsIMIMEService
)
;
let
handlerInfo
=
mimeService
.
getFromTypeAndExtension
(
'
application
/
pdf
'
'
pdf
'
)
;
is
(
handlerInfo
.
alwaysAskBeforeHandling
false
'
pdf
handler
defaults
to
always
-
ask
is
false
'
)
;
is
(
handlerInfo
.
preferredAction
Ci
.
nsIHandlerInfo
.
handleInternally
'
pdf
handler
defaults
to
internal
'
)
;
info
(
'
Pref
action
:
'
+
handlerInfo
.
preferredAction
)
;
yield
BrowserTestUtils
.
withNewTab
(
{
gBrowser
url
:
TESTROOT
+
"
file_pdfjs_test
.
pdf
"
+
"
#
zoom
=
100
"
}
function
*
(
newTabBrowser
)
{
yield
waitForPdfJS
(
newTabBrowser
)
;
yield
ContentTask
.
spawn
(
newTabBrowser
TESTS
function
*
(
TESTS
)
{
let
document
=
content
.
document
;
function
waitForRender
(
)
{
return
new
Promise
(
(
resolve
)
=
>
{
document
.
addEventListener
(
"
pagerendered
"
function
onPageRendered
(
e
)
{
if
(
e
.
detail
.
pageNumber
!
=
=
1
)
{
return
;
}
document
.
removeEventListener
(
"
pagerendered
"
onPageRendered
true
)
;
resolve
(
)
;
}
true
)
;
}
)
;
}
ok
(
content
.
document
.
querySelector
(
'
div
#
viewer
'
)
"
document
content
has
viewer
UI
"
)
;
ok
(
'
PDFJS
'
in
content
.
wrappedJSObject
"
window
content
has
PDFJS
object
"
)
;
let
initialWidth
previousWidth
;
initialWidth
=
previousWidth
=
parseInt
(
content
.
document
.
querySelector
(
"
div
#
pageContainer1
"
)
.
style
.
width
)
;
for
(
let
test
of
TESTS
)
{
var
ev
;
if
(
test
.
action
.
selector
)
{
var
el
=
document
.
querySelector
(
test
.
action
.
selector
)
;
ok
(
el
"
Element
'
"
+
test
.
action
.
selector
+
"
'
has
been
found
"
)
;
if
(
test
.
action
.
index
)
{
el
.
selectedIndex
=
test
.
action
.
index
;
}
ev
=
new
Event
(
test
.
action
.
event
)
;
}
else
{
ev
=
new
content
.
KeyboardEvent
(
"
keydown
"
{
key
:
test
.
action
.
event
keyCode
:
test
.
action
.
keyCode
ctrlKey
:
true
}
)
;
el
=
content
;
}
el
.
dispatchEvent
(
ev
)
;
yield
waitForRender
(
)
;
var
pageZoomScale
=
content
.
document
.
querySelector
(
'
select
#
scaleSelect
'
)
;
var
zoomValue
=
pageZoomScale
.
options
[
pageZoomScale
.
selectedIndex
]
.
innerHTML
;
let
pageContainer
=
content
.
document
.
querySelector
(
'
div
#
pageContainer1
'
)
;
let
actualWidth
=
parseInt
(
pageContainer
.
style
.
width
)
;
let
computedZoomValue
=
parseInt
(
(
(
actualWidth
/
initialWidth
)
.
toFixed
(
2
)
)
*
100
)
+
"
%
"
;
is
(
computedZoomValue
zoomValue
"
Content
has
correct
zoom
"
)
;
let
zoom
=
(
actualWidth
-
previousWidth
)
*
test
.
expectedZoom
;
ok
(
zoom
>
0
test
.
message
)
;
previousWidth
=
actualWidth
;
}
var
viewer
=
content
.
wrappedJSObject
.
PDFViewerApplication
;
yield
viewer
.
close
(
)
;
}
)
;
}
)
;
}
)
;
