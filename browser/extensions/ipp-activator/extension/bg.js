class
IPPAddonActivator
{
#
initialized
=
false
;
#
tabBaseBreakages
;
#
webrequestBaseBreakages
;
#
tabBreakages
;
#
webrequestBreakages
;
#
pendingTabs
=
new
Set
(
)
;
/
/
pending
due
to
tab
URL
change
while
inactive
#
pendingWebRequests
=
new
Map
(
)
;
/
/
tabId
-
>
Set
of
pending
request
URLs
#
shownDomainByTab
=
new
Map
(
)
;
/
/
tabId
-
>
baseDomain
of
currently
shown
notification
constructor
(
)
{
this
.
tabUpdated
=
this
.
#
tabUpdated
.
bind
(
this
)
;
this
.
tabActivated
=
this
.
#
tabActivated
.
bind
(
this
)
;
this
.
tabRemoved
=
this
.
#
tabRemoved
.
bind
(
this
)
;
this
.
onRequest
=
this
.
#
onRequest
.
bind
(
this
)
;
browser
.
ippActivator
.
isTesting
(
)
.
then
(
async
isTesting
=
>
{
await
this
.
#
loadAndRebuildBreakages
(
)
;
browser
.
ippActivator
.
onDynamicTabBreakagesUpdated
.
addListener
(
(
)
=
>
this
.
#
loadAndRebuildBreakages
(
)
)
;
browser
.
ippActivator
.
onDynamicWebRequestBreakagesUpdated
.
addListener
(
(
)
=
>
this
.
#
loadAndRebuildBreakages
(
)
)
;
if
(
isTesting
)
{
this
.
#
init
(
)
;
return
;
}
if
(
await
browser
.
ippActivator
.
isIPPActive
(
)
)
{
this
.
#
init
(
)
;
}
browser
.
ippActivator
.
onIPPActivated
.
addListener
(
async
(
)
=
>
{
if
(
await
browser
.
ippActivator
.
isIPPActive
(
)
)
{
this
.
#
init
(
)
;
}
else
{
this
.
#
uninit
(
)
;
}
}
)
;
}
)
;
}
async
#
init
(
)
{
if
(
this
.
#
initialized
)
{
return
;
}
this
.
#
registerListeners
(
)
;
this
.
#
initialized
=
true
;
}
async
#
uninit
(
)
{
if
(
!
this
.
#
initialized
)
{
return
;
}
this
.
#
unregisterListeners
(
)
;
const
ids
=
Array
.
from
(
this
.
#
shownDomainByTab
.
keys
(
)
)
;
await
Promise
.
allSettled
(
ids
.
map
(
id
=
>
browser
.
ippActivator
.
hideMessage
(
id
)
)
)
;
this
.
#
shownDomainByTab
.
clear
(
)
;
this
.
#
initialized
=
false
;
}
async
#
loadAndRebuildBreakages
(
)
{
if
(
!
this
.
#
tabBaseBreakages
)
{
try
{
const
url
=
browser
.
runtime
.
getURL
(
"
breakages
/
tab
.
json
"
)
;
const
res
=
await
fetch
(
url
)
;
const
base
=
await
res
.
json
(
)
;
this
.
#
tabBaseBreakages
=
Array
.
isArray
(
base
)
?
base
:
[
]
;
}
catch
(
e
)
{
this
.
#
tabBaseBreakages
=
[
]
;
}
}
if
(
!
this
.
#
webrequestBaseBreakages
)
{
try
{
const
url
=
browser
.
runtime
.
getURL
(
"
breakages
/
webrequest
.
json
"
)
;
const
res
=
await
fetch
(
url
)
;
const
base
=
await
res
.
json
(
)
;
this
.
#
webrequestBaseBreakages
=
Array
.
isArray
(
base
)
?
base
:
[
]
;
}
catch
(
e
)
{
this
.
#
webrequestBaseBreakages
=
[
]
;
}
}
let
dynamicTab
=
[
]
;
try
{
const
dynT
=
await
browser
.
ippActivator
.
getDynamicTabBreakages
(
)
;
dynamicTab
=
Array
.
isArray
(
dynT
)
?
dynT
:
[
]
;
}
catch
(
_
)
{
console
.
warn
(
"
Unable
to
retrieve
dynamicTabBreakages
"
)
;
}
let
dynamicWr
=
[
]
;
try
{
const
dynW
=
await
browser
.
ippActivator
.
getDynamicWebRequestBreakages
(
)
;
dynamicWr
=
Array
.
isArray
(
dynW
)
?
dynW
:
[
]
;
}
catch
(
_
)
{
console
.
warn
(
"
Unable
to
retrieve
dynamicWebRequestBreakages
"
)
;
}
this
.
#
tabBreakages
=
[
.
.
.
(
this
.
#
tabBaseBreakages
|
|
[
]
)
.
.
.
dynamicTab
]
;
this
.
#
webrequestBreakages
=
[
.
.
.
(
this
.
#
webrequestBaseBreakages
|
|
[
]
)
.
.
.
dynamicWr
]
;
if
(
this
.
#
initialized
)
{
this
.
#
registerListeners
(
)
;
}
}
#
registerListeners
(
)
{
this
.
#
unregisterListeners
(
)
;
const
needTabUpdated
=
Array
.
isArray
(
this
.
#
tabBreakages
)
&
&
!
!
this
.
#
tabBreakages
.
length
;
const
needWebRequest
=
Array
.
isArray
(
this
.
#
webrequestBreakages
)
&
&
!
!
this
.
#
webrequestBreakages
.
length
;
const
needActivation
=
needTabUpdated
|
|
needWebRequest
;
if
(
needTabUpdated
)
{
browser
.
tabs
.
onUpdated
.
addListener
(
this
.
tabUpdated
{
properties
:
[
"
url
"
"
status
"
]
}
)
;
}
if
(
needWebRequest
)
{
browser
.
webRequest
.
onBeforeRequest
.
addListener
(
this
.
onRequest
{
urls
:
[
"
<
all_urls
>
"
]
types
:
[
"
media
"
"
sub_frame
"
"
xmlhttprequest
"
]
}
[
]
)
;
}
if
(
needActivation
)
{
browser
.
tabs
.
onActivated
.
addListener
(
this
.
tabActivated
)
;
browser
.
tabs
.
onRemoved
.
addListener
(
this
.
tabRemoved
)
;
}
}
#
unregisterListeners
(
)
{
if
(
browser
.
tabs
.
onUpdated
.
hasListener
(
this
.
tabUpdated
)
)
{
browser
.
tabs
.
onUpdated
.
removeListener
(
this
.
tabUpdated
)
;
}
if
(
browser
.
tabs
.
onActivated
.
hasListener
(
this
.
tabActivated
)
)
{
browser
.
tabs
.
onActivated
.
removeListener
(
this
.
tabActivated
)
;
}
if
(
browser
.
tabs
.
onRemoved
.
hasListener
(
this
.
tabRemoved
)
)
{
browser
.
tabs
.
onRemoved
.
removeListener
(
this
.
tabRemoved
)
;
}
if
(
browser
.
webRequest
.
onBeforeRequest
.
hasListener
(
this
.
onRequest
)
)
{
browser
.
webRequest
.
onBeforeRequest
.
removeListener
(
this
.
onRequest
)
;
}
this
.
#
pendingTabs
.
clear
(
)
;
this
.
#
pendingWebRequests
.
clear
(
)
;
}
async
#
tabUpdated
(
tabId
changeInfo
tab
)
{
if
(
!
(
"
url
"
in
changeInfo
)
&
&
changeInfo
.
status
!
=
=
"
complete
"
)
{
return
;
}
if
(
"
url
"
in
changeInfo
)
{
try
{
const
info
=
await
browser
.
ippActivator
.
getBaseDomainFromURL
(
changeInfo
.
url
|
|
tab
?
.
url
|
|
"
"
)
;
const
shownBase
=
this
.
#
shownDomainByTab
.
get
(
tabId
)
;
if
(
shownBase
&
&
shownBase
!
=
=
info
.
baseDomain
)
{
await
browser
.
ippActivator
.
hideMessage
(
tabId
)
;
this
.
#
shownDomainByTab
.
delete
(
tabId
)
;
}
}
catch
(
_
)
{
}
this
.
#
pendingWebRequests
.
delete
(
tabId
)
;
}
if
(
changeInfo
.
status
&
&
changeInfo
.
status
!
=
=
"
complete
"
)
{
if
(
!
tab
.
active
)
{
this
.
#
pendingTabs
.
add
(
tabId
)
;
}
return
;
}
if
(
!
tab
.
active
)
{
this
.
#
pendingTabs
.
add
(
tabId
)
;
return
;
}
await
this
.
#
maybeNotify
(
tab
this
.
#
tabBreakages
tab
.
url
)
;
}
async
#
tabActivated
(
activeInfo
)
{
const
{
tabId
}
=
activeInfo
|
|
{
}
;
const
hadTabPending
=
this
.
#
pendingTabs
.
has
(
tabId
)
;
const
wrSet
=
this
.
#
pendingWebRequests
.
get
(
tabId
)
;
const
pendingWrUrls
=
wrSet
?
Array
.
from
(
wrSet
)
:
[
]
;
if
(
!
hadTabPending
&
&
pendingWrUrls
.
length
=
=
=
0
)
{
return
;
}
this
.
#
pendingTabs
.
delete
(
tabId
)
;
this
.
#
pendingWebRequests
.
delete
(
tabId
)
;
let
tab
;
try
{
tab
=
await
browser
.
tabs
.
get
(
tabId
)
;
if
(
!
tab
|
|
!
tab
.
active
)
{
return
;
}
}
catch
(
_
)
{
return
;
}
if
(
hadTabPending
&
&
(
await
this
.
#
maybeNotify
(
tab
this
.
#
tabBreakages
tab
.
url
)
)
)
{
return
;
}
for
(
const
url
of
pendingWrUrls
)
{
if
(
await
this
.
#
maybeNotify
(
tab
this
.
#
webrequestBreakages
url
)
)
{
return
;
}
}
}
async
#
maybeNotify
(
tab
breakages
url
)
{
const
info
=
await
browser
.
ippActivator
.
getBaseDomainFromURL
(
url
)
;
if
(
!
info
.
baseDomain
&
&
!
info
.
host
)
{
return
false
;
}
const
shown
=
await
browser
.
ippActivator
.
getNotifiedDomains
(
)
;
if
(
info
.
baseDomain
&
&
Array
.
isArray
(
shown
)
&
&
shown
.
includes
(
info
.
baseDomain
)
)
{
return
false
;
}
const
breakage
=
breakages
.
find
(
b
=
>
Array
.
isArray
(
b
.
domains
)
&
&
(
b
.
domains
.
includes
(
info
.
baseDomain
)
|
|
b
.
domains
.
includes
(
info
.
host
)
)
)
;
if
(
!
breakage
)
{
return
false
;
}
if
(
!
(
await
ConditionFactory
.
run
(
breakage
.
condition
{
tabId
:
tab
.
id
url
}
)
)
)
{
return
false
;
}
await
browser
.
ippActivator
.
showMessage
(
breakage
.
message
tab
.
id
)
;
this
.
#
shownDomainByTab
.
set
(
tab
.
id
info
.
baseDomain
)
;
await
browser
.
ippActivator
.
addNotifiedDomain
(
info
.
baseDomain
)
;
return
true
;
}
async
#
onRequest
(
details
)
{
if
(
typeof
details
.
tabId
!
=
=
"
number
"
|
|
details
.
tabId
<
0
|
|
!
details
.
url
)
{
return
;
}
try
{
const
tab
=
await
browser
.
tabs
.
get
(
details
.
tabId
)
;
if
(
!
tab
)
{
return
;
}
if
(
tab
.
active
)
{
await
this
.
#
maybeNotify
(
tab
this
.
#
webrequestBreakages
details
.
url
)
;
}
else
{
const
set
=
this
.
#
pendingWebRequests
.
get
(
details
.
tabId
)
|
|
new
Set
(
)
;
set
.
add
(
details
.
url
)
;
this
.
#
pendingWebRequests
.
set
(
details
.
tabId
set
)
;
}
}
catch
(
_
)
{
}
}
async
#
tabRemoved
(
tabId
_removeInfo
)
{
this
.
#
pendingTabs
.
delete
(
tabId
)
;
this
.
#
pendingWebRequests
.
delete
(
tabId
)
;
this
.
#
shownDomainByTab
.
delete
(
tabId
)
;
}
}
new
IPPAddonActivator
(
)
;
