"
use
strict
"
;
this
.
MAIN_MESSAGE_TYPE
=
"
ActivityStream
:
Main
"
;
this
.
CONTENT_MESSAGE_TYPE
=
"
ActivityStream
:
Content
"
;
this
.
UI_CODE
=
1
;
this
.
BACKGROUND_PROCESS
=
2
;
const
globalImportContext
=
typeof
Window
=
=
=
"
undefined
"
?
BACKGROUND_PROCESS
:
UI_CODE
;
this
.
globalImportContext
=
globalImportContext
;
const
actionTypes
=
[
"
BLOCK_URL
"
"
BOOKMARK_URL
"
"
DELETE_BOOKMARK_BY_ID
"
"
DELETE_HISTORY_URL
"
"
INIT
"
"
LOCALE_UPDATED
"
"
NEW_TAB_INITIAL_STATE
"
"
NEW_TAB_LOAD
"
"
NEW_TAB_UNLOAD
"
"
NEW_TAB_VISIBLE
"
"
OPEN_NEW_WINDOW
"
"
OPEN_PRIVATE_WINDOW
"
"
PERFORM_SEARCH
"
"
PLACES_BOOKMARK_ADDED
"
"
PLACES_BOOKMARK_CHANGED
"
"
PLACES_BOOKMARK_REMOVED
"
"
PLACES_HISTORY_CLEARED
"
"
PLACES_LINK_BLOCKED
"
"
PLACES_LINK_DELETED
"
"
SCREENSHOT_UPDATED
"
"
SEARCH_STATE_UPDATED
"
"
TELEMETRY_PERFORMANCE_EVENT
"
"
TELEMETRY_UNDESIRED_EVENT
"
"
TELEMETRY_USER_EVENT
"
"
TOP_SITES_UPDATED
"
"
UNINIT
"
]
.
reduce
(
(
obj
type
)
=
>
{
obj
[
type
]
=
type
;
return
obj
;
}
{
}
)
;
function
_RouteMessage
(
action
options
)
{
const
meta
=
action
.
meta
?
Object
.
assign
(
{
}
action
.
meta
)
:
{
}
;
if
(
!
options
|
|
!
options
.
from
|
|
!
options
.
to
)
{
throw
new
Error
(
"
Routed
Messages
must
have
options
as
the
second
parameter
and
must
at
least
include
a
.
from
and
.
to
property
.
"
)
;
}
[
"
from
"
"
to
"
"
toTarget
"
"
fromTarget
"
"
skipOrigin
"
]
.
forEach
(
o
=
>
{
if
(
typeof
options
[
o
]
!
=
=
"
undefined
"
)
{
meta
[
o
]
=
options
[
o
]
;
}
else
if
(
meta
[
o
]
)
{
delete
meta
[
o
]
;
}
}
)
;
return
Object
.
assign
(
{
}
action
{
meta
}
)
;
}
function
SendToMain
(
action
fromTarget
)
{
return
_RouteMessage
(
action
{
from
:
CONTENT_MESSAGE_TYPE
to
:
MAIN_MESSAGE_TYPE
fromTarget
}
)
;
}
function
BroadcastToContent
(
action
)
{
return
_RouteMessage
(
action
{
from
:
MAIN_MESSAGE_TYPE
to
:
CONTENT_MESSAGE_TYPE
}
)
;
}
function
SendToContent
(
action
target
)
{
if
(
!
target
)
{
throw
new
Error
(
"
You
must
provide
a
target
ID
as
the
second
parameter
of
SendToContent
.
If
you
want
to
send
to
all
content
processes
use
BroadcastToContent
"
)
;
}
return
_RouteMessage
(
action
{
from
:
MAIN_MESSAGE_TYPE
to
:
CONTENT_MESSAGE_TYPE
toTarget
:
target
}
)
;
}
function
UserEvent
(
data
)
{
return
SendToMain
(
{
type
:
actionTypes
.
TELEMETRY_USER_EVENT
data
}
)
;
}
function
UndesiredEvent
(
data
importContext
=
globalImportContext
)
{
const
action
=
{
type
:
actionTypes
.
TELEMETRY_UNDESIRED_EVENT
data
}
;
return
importContext
=
=
=
UI_CODE
?
SendToMain
(
action
)
:
action
;
}
function
PerfEvent
(
data
importContext
=
globalImportContext
)
{
const
action
=
{
type
:
actionTypes
.
TELEMETRY_PERFORMANCE_EVENT
data
}
;
return
importContext
=
=
=
UI_CODE
?
SendToMain
(
action
)
:
action
;
}
this
.
actionTypes
=
actionTypes
;
this
.
actionCreators
=
{
BroadcastToContent
UserEvent
UndesiredEvent
PerfEvent
SendToContent
SendToMain
}
;
this
.
actionUtils
=
{
isSendToMain
(
action
)
{
if
(
!
action
.
meta
)
{
return
false
;
}
return
action
.
meta
.
to
=
=
=
MAIN_MESSAGE_TYPE
&
&
action
.
meta
.
from
=
=
=
CONTENT_MESSAGE_TYPE
;
}
isBroadcastToContent
(
action
)
{
if
(
!
action
.
meta
)
{
return
false
;
}
if
(
action
.
meta
.
to
=
=
=
CONTENT_MESSAGE_TYPE
&
&
!
action
.
meta
.
toTarget
)
{
return
true
;
}
return
false
;
}
isSendToContent
(
action
)
{
if
(
!
action
.
meta
)
{
return
false
;
}
if
(
action
.
meta
.
to
=
=
=
CONTENT_MESSAGE_TYPE
&
&
action
.
meta
.
toTarget
)
{
return
true
;
}
return
false
;
}
getPortIdOfSender
(
action
)
{
return
(
action
.
meta
&
&
action
.
meta
.
fromTarget
)
|
|
null
;
}
_RouteMessage
}
;
this
.
EXPORTED_SYMBOLS
=
[
"
actionTypes
"
"
actionCreators
"
"
actionUtils
"
"
globalImportContext
"
"
UI_CODE
"
"
BACKGROUND_PROCESS
"
"
MAIN_MESSAGE_TYPE
"
"
CONTENT_MESSAGE_TYPE
"
]
;
