#
!
/
usr
/
bin
/
env
node
"
use
strict
"
;
const
Task
=
require
(
"
co
-
task
"
)
;
const
process
=
require
(
"
process
"
)
;
const
path
=
require
(
"
path
"
)
;
const
GitHubApi
=
require
(
"
octokit
/
rest
"
)
;
const
shelljs
=
require
(
"
shelljs
"
)
;
const
child_process
=
require
(
"
child_process
"
)
;
const
github
=
new
GitHubApi
(
)
;
let
token
=
process
.
env
.
AS_PINE_TOKEN
;
github
.
authenticate
(
{
type
:
"
token
"
token
}
)
;
const
AS_REPO_OWNER
=
process
.
env
.
AS_REPO_OWNER
|
|
"
mozilla
"
;
const
AS_REPO_NAME
=
process
.
env
.
AS_REPO_NAME
|
|
"
activity
-
stream
"
;
const
AS_REPO
=
{
AS_REPO_OWNER
}
/
{
AS_REPO_NAME
}
;
const
OLDEST_PR_DATE
=
"
2017
-
03
-
17
"
;
const
HG
=
"
hg
"
;
const
HG_BRANCH_NAME
=
"
pine
"
;
const
ALREADY_PUSHED_LABEL
=
"
pushed
-
to
-
pine
"
;
const
TREEHERDER_PREFIX
=
"
https
:
/
/
treeherder
.
mozilla
.
org
/
#
/
jobs
?
repo
=
pine
&
revision
=
"
;
const
{
AS_PINE_TEST_DIR
}
=
process
.
env
;
const
TESTING_LOCAL_MC
=
path
.
join
(
AS_PINE_TEST_DIR
"
mozilla
-
central
"
)
;
const
SimpleGit
=
require
(
"
simple
-
git
"
)
;
const
TESTING_LOCAL_GIT
=
path
.
join
(
AS_PINE_TEST_DIR
AS_REPO_NAME
)
;
const
git
=
new
SimpleGit
(
TESTING_LOCAL_GIT
)
;
const
AS_GIT_BIN_REPO
=
process
.
env
.
AS_GIT_BIN_REPO
|
|
TESTING_LOCAL_GIT
;
const
PREPARE_MOCHITESTS_DEV
=
path
.
join
(
AS_GIT_BIN_REPO
"
bin
"
"
prepare
-
mochitests
-
dev
"
)
;
function
findNewlyMergedPRs
(
)
{
const
searchTerms
=
[
repo
:
{
AS_REPO
}
"
type
:
pr
"
"
state
:
closed
"
"
is
:
merged
"
merged
:
>
=
{
OLDEST_PR_DATE
}
"
base
:
master
"
-
label
:
{
ALREADY_PUSHED_LABEL
}
]
;
console
.
log
(
Searching
{
AS_REPO
}
for
newly
merged
PRs
)
;
return
github
.
search
.
issues
(
{
q
:
searchTerms
.
join
(
"
+
"
)
}
)
;
}
function
getPRMergeCommitId
(
prNumber
)
{
return
github
.
issues
.
getEvents
(
{
owner
:
AS_REPO_OWNER
repo
:
AS_REPO_NAME
issue_number
:
prNumber
}
)
.
then
(
(
{
data
}
)
=
>
{
if
(
data
.
incomplete_results
)
{
throw
new
Error
(
"
data
.
incomplete_results
is
true
aborting
"
)
;
}
let
mergeEvents
=
data
.
filter
(
item
=
>
item
.
event
=
=
=
"
merged
"
)
;
if
(
mergeEvents
.
length
>
1
)
{
throw
new
Error
(
"
more
than
one
merge
event
aborting
"
)
;
}
else
if
(
!
mergeEvents
.
length
)
{
throw
new
Error
(
Github
returned
no
merge
events
for
PR
{
prNumber
}
aborting
.
Workaround
:
mark
this
PR
as
pushed
-
to
-
pine
so
it
gets
skipped
)
;
}
let
[
mergeEvent
]
=
mergeEvents
;
if
(
!
mergeEvent
.
commit_id
)
{
throw
new
Error
(
"
merge
event
has
no
commit
id
attached
aborted
"
)
;
}
return
mergeEvent
.
commit_id
;
}
)
.
catch
(
err
=
>
{
throw
err
;
}
)
;
}
function
checkoutGitCommit
(
commitId
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
console
.
log
(
Fetching
changes
from
github
remote
{
AS_REPO
}
.
.
.
)
;
git
.
fetch
(
{
}
(
err
data
)
=
>
{
if
(
err
)
{
reject
(
err
)
;
return
;
}
console
.
log
(
Starting
github
checkout
of
{
commitId
}
.
.
.
)
;
git
.
checkout
(
commitId
(
err2
data2
)
=
>
{
if
(
err2
)
{
reject
(
err2
)
;
return
;
}
git
.
show
(
[
"
-
s
"
"
-
-
format
=
%
B
"
]
(
err3
data3
)
=
>
{
if
(
err3
)
{
reject
(
err3
)
;
return
;
}
resolve
(
[
commitId
data3
.
trim
(
)
]
)
;
}
)
;
}
)
;
}
)
;
}
)
;
}
function
exportToLocalMC
(
commitId
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
console
.
log
(
"
Preparing
mochitest
dev
environment
.
.
.
"
)
;
shelljs
.
exec
(
echo
yes
|
\
env
AS_GIT_BIN_REPO
=
{
AS_GIT_BIN_REPO
}
SYMLINK_TESTS
=
false
\
ENABLE_MC_AS
=
1
{
PREPARE_MOCHITESTS_DEV
}
{
async
:
true
cwd
:
TESTING_LOCAL_GIT
silent
:
false
}
(
code
stdout
stderr
)
=
>
{
if
(
code
)
{
reject
(
new
Error
(
{
PREPARE_MOCHITESTS_DEV
}
failed
exit
code
:
{
code
}
)
)
;
return
;
}
resolve
(
commitId
)
;
}
)
;
}
)
;
}
function
commitToHg
(
[
commitId
commitMsg
]
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
console
.
log
(
Committing
exported
{
commitId
}
to
{
AS_REPO_NAME
}
.
.
.
)
;
child_process
.
execFile
(
HG
[
"
commit
"
"
-
-
addremove
"
"
-
m
"
{
commitMsg
}
\
n
\
nExport
of
{
commitId
}
from
{
AS_REPO_OWNER
}
/
{
AS_REPO_NAME
}
"
.
"
]
{
cwd
:
TESTING_LOCAL_MC
env
:
process
.
env
timeout
:
5
*
60
*
1000
}
(
code
stdout
stderr
)
=
>
{
if
(
code
)
{
reject
(
new
Error
(
{
HG
}
commit
failed
output
:
{
stderr
}
)
)
;
return
;
}
resolve
(
code
)
;
}
)
;
}
)
;
}
function
pushToHgProjectBranch
(
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
shelljs
.
exec
(
{
HG
}
push
-
f
{
HG_BRANCH_NAME
}
{
async
:
true
cwd
:
TESTING_LOCAL_MC
}
(
code
stdout
stderr
)
=
>
{
if
(
code
)
{
reject
(
new
Error
(
{
HG
}
failed
exit
code
:
{
code
}
)
)
;
return
;
}
const
[
rev
]
=
stdout
.
split
(
/
(
?
:
\
/
rev
\
/
|
changeset
=
)
/
)
.
slice
(
-
1
)
[
0
]
.
split
(
"
\
n
"
)
;
resolve
(
[
Treeherder
:
{
rev
}
]
(
{
TREEHERDER_PREFIX
}
{
rev
}
)
)
;
}
)
;
}
)
;
}
function
stripTipFromHg
(
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
console
.
log
(
"
Stripping
tip
commit
from
mozilla
-
central
so
the
next
artifact
build
will
work
.
.
.
"
)
;
shelljs
.
exec
(
{
HG
}
strip
-
-
force
-
-
rev
-
1
{
async
:
true
cwd
:
TESTING_LOCAL_MC
}
(
code
stdout
stderr
)
=
>
{
if
(
code
)
{
reject
(
new
Error
(
{
HG
}
strip
failed
output
:
{
stderr
}
)
)
;
return
;
}
resolve
(
code
)
;
}
)
;
}
)
;
}
function
annotateGithubPR
(
prNumber
annotation
)
{
console
.
log
(
Annotating
{
prNumber
}
with
{
annotation
}
.
.
.
)
;
return
github
.
issues
.
createComment
(
{
owner
:
AS_REPO_OWNER
repo
:
AS_REPO_NAME
number
:
prNumber
body
:
annotation
}
)
.
catch
(
reason
=
>
console
.
log
(
reason
)
)
;
}
function
labelGithubPR
(
prNumber
)
{
console
.
log
(
Labeling
PR
{
prNumber
}
with
{
ALREADY_PUSHED_LABEL
}
.
.
.
)
;
return
github
.
issues
.
addLabels
(
{
owner
:
AS_REPO_OWNER
repo
:
AS_REPO_NAME
number
:
prNumber
labels
:
[
ALREADY_PUSHED_LABEL
]
}
)
.
catch
(
reason
=
>
console
.
log
(
reason
)
)
;
}
function
pushPR
(
pr
)
{
return
getPRMergeCommitId
(
pr
.
number
)
.
then
(
checkoutGitCommit
)
.
then
(
exportToLocalMC
)
.
then
(
commitToHg
)
.
then
(
(
)
=
>
pushToHgProjectBranch
(
)
.
catch
(
(
)
=
>
{
stripTipFromHg
(
)
;
throw
new
Error
(
"
pushToHgProjectBranch
failed
;
tip
stripped
from
hg
"
)
;
}
)
)
.
then
(
annotation
=
>
annotateGithubPR
(
pr
.
number
annotation
)
)
.
then
(
(
)
=
>
stripTipFromHg
(
)
)
.
then
(
(
)
=
>
labelGithubPR
(
pr
.
number
)
)
.
catch
(
err
=
>
{
console
.
log
(
err
)
;
throw
err
;
}
)
;
}
function
main
(
)
{
findNewlyMergedPRs
(
)
.
then
(
(
{
data
}
)
=
>
{
if
(
data
.
incomplete_results
)
{
throw
new
Error
(
"
data
.
incomplete_results
is
true
aborting
"
)
;
}
if
(
data
.
items
.
length
=
=
=
0
)
{
console
.
log
(
"
No
newly
merged
PRs
to
test
"
)
;
return
;
}
function
*
executePush
(
)
{
for
(
let
pr
of
data
.
items
)
{
yield
pushPR
(
pr
)
;
}
}
Task
.
spawn
(
executePush
)
.
then
(
(
)
=
>
{
console
.
log
(
"
Processed
all
new
merges
.
"
)
;
}
)
.
catch
(
reason
=
>
{
console
.
log
(
"
Something
went
wrong
processing
the
merges
:
"
reason
)
;
process
.
exitCode
=
-
1
;
}
)
;
}
)
.
catch
(
reason
=
>
{
console
.
error
(
reason
)
;
process
.
exitCode
=
-
1
;
}
)
;
}
main
(
)
;
