(
function
(
modules
)
{
var
installedModules
=
{
}
;
function
__webpack_require__
(
moduleId
)
{
if
(
installedModules
[
moduleId
]
)
return
installedModules
[
moduleId
]
.
exports
;
var
module
=
installedModules
[
moduleId
]
=
{
i
:
moduleId
l
:
false
exports
:
{
}
}
;
modules
[
moduleId
]
.
call
(
module
.
exports
module
module
.
exports
__webpack_require__
)
;
module
.
l
=
true
;
return
module
.
exports
;
}
__webpack_require__
.
m
=
modules
;
__webpack_require__
.
c
=
installedModules
;
__webpack_require__
.
i
=
function
(
value
)
{
return
value
;
}
;
__webpack_require__
.
d
=
function
(
exports
name
getter
)
{
if
(
!
__webpack_require__
.
o
(
exports
name
)
)
{
Object
.
defineProperty
(
exports
name
{
configurable
:
false
enumerable
:
true
get
:
getter
}
)
;
}
}
;
__webpack_require__
.
n
=
function
(
module
)
{
var
getter
=
module
&
&
module
.
__esModule
?
function
getDefault
(
)
{
return
module
[
'
default
'
]
;
}
:
function
getModuleExports
(
)
{
return
module
;
}
;
__webpack_require__
.
d
(
getter
'
a
'
getter
)
;
return
getter
;
}
;
__webpack_require__
.
o
=
function
(
object
property
)
{
return
Object
.
prototype
.
hasOwnProperty
.
call
(
object
property
)
;
}
;
__webpack_require__
.
p
=
"
"
;
return
__webpack_require__
(
__webpack_require__
.
s
=
25
)
;
}
)
(
[
(
function
(
module
exports
)
{
module
.
exports
=
React
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
var
MAIN_MESSAGE_TYPE
=
"
ActivityStream
:
Main
"
;
var
CONTENT_MESSAGE_TYPE
=
"
ActivityStream
:
Content
"
;
var
UI_CODE
=
1
;
var
BACKGROUND_PROCESS
=
2
;
const
globalImportContext
=
typeof
Window
=
=
=
"
undefined
"
?
BACKGROUND_PROCESS
:
UI_CODE
;
const
actionTypes
=
{
}
;
for
(
const
type
of
[
"
BLOCK_URL
"
"
BOOKMARK_URL
"
"
DELETE_BOOKMARK_BY_ID
"
"
DELETE_HISTORY_URL
"
"
DELETE_HISTORY_URL_CONFIRM
"
"
DIALOG_CANCEL
"
"
DIALOG_OPEN
"
"
FEED_INIT
"
"
INIT
"
"
LOCALE_UPDATED
"
"
MIGRATION_CANCEL
"
"
MIGRATION_START
"
"
NEW_TAB_INIT
"
"
NEW_TAB_INITIAL_STATE
"
"
NEW_TAB_LOAD
"
"
NEW_TAB_UNLOAD
"
"
OPEN_LINK
"
"
OPEN_NEW_WINDOW
"
"
OPEN_PRIVATE_WINDOW
"
"
PINNED_SITES_UPDATED
"
"
PLACES_BOOKMARK_ADDED
"
"
PLACES_BOOKMARK_CHANGED
"
"
PLACES_BOOKMARK_REMOVED
"
"
PLACES_HISTORY_CLEARED
"
"
PLACES_LINK_BLOCKED
"
"
PLACES_LINK_DELETED
"
"
PREFS_INITIAL_VALUES
"
"
PREF_CHANGED
"
"
SAVE_SESSION_PERF_DATA
"
"
SAVE_TO_POCKET
"
"
SCREENSHOT_UPDATED
"
"
SECTION_DEREGISTER
"
"
SECTION_REGISTER
"
"
SECTION_ROWS_UPDATE
"
"
SET_PREF
"
"
SNIPPETS_DATA
"
"
SNIPPETS_RESET
"
"
SYSTEM_TICK
"
"
TELEMETRY_IMPRESSION_STATS
"
"
TELEMETRY_PERFORMANCE_EVENT
"
"
TELEMETRY_UNDESIRED_EVENT
"
"
TELEMETRY_USER_EVENT
"
"
TOP_SITES_EDIT_CLOSE
"
"
TOP_SITES_EDIT_OPEN
"
"
TOP_SITES_PIN
"
"
TOP_SITES_UNPIN
"
"
TOP_SITES_UPDATED
"
"
UNINIT
"
]
)
{
actionTypes
[
type
]
=
type
;
}
function
_RouteMessage
(
action
options
)
{
const
meta
=
action
.
meta
?
Object
.
assign
(
{
}
action
.
meta
)
:
{
}
;
if
(
!
options
|
|
!
options
.
from
|
|
!
options
.
to
)
{
throw
new
Error
(
"
Routed
Messages
must
have
options
as
the
second
parameter
and
must
at
least
include
a
.
from
and
.
to
property
.
"
)
;
}
[
"
from
"
"
to
"
"
toTarget
"
"
fromTarget
"
"
skipOrigin
"
]
.
forEach
(
o
=
>
{
if
(
typeof
options
[
o
]
!
=
=
"
undefined
"
)
{
meta
[
o
]
=
options
[
o
]
;
}
else
if
(
meta
[
o
]
)
{
delete
meta
[
o
]
;
}
}
)
;
return
Object
.
assign
(
{
}
action
{
meta
}
)
;
}
function
SendToMain
(
action
fromTarget
)
{
return
_RouteMessage
(
action
{
from
:
CONTENT_MESSAGE_TYPE
to
:
MAIN_MESSAGE_TYPE
fromTarget
}
)
;
}
function
BroadcastToContent
(
action
)
{
return
_RouteMessage
(
action
{
from
:
MAIN_MESSAGE_TYPE
to
:
CONTENT_MESSAGE_TYPE
}
)
;
}
function
SendToContent
(
action
target
)
{
if
(
!
target
)
{
throw
new
Error
(
"
You
must
provide
a
target
ID
as
the
second
parameter
of
SendToContent
.
If
you
want
to
send
to
all
content
processes
use
BroadcastToContent
"
)
;
}
return
_RouteMessage
(
action
{
from
:
MAIN_MESSAGE_TYPE
to
:
CONTENT_MESSAGE_TYPE
toTarget
:
target
}
)
;
}
function
UserEvent
(
data
)
{
return
SendToMain
(
{
type
:
actionTypes
.
TELEMETRY_USER_EVENT
data
}
)
;
}
function
UndesiredEvent
(
data
)
{
let
importContext
=
arguments
.
length
>
1
&
&
arguments
[
1
]
!
=
=
undefined
?
arguments
[
1
]
:
globalImportContext
;
const
action
=
{
type
:
actionTypes
.
TELEMETRY_UNDESIRED_EVENT
data
}
;
return
importContext
=
=
=
UI_CODE
?
SendToMain
(
action
)
:
action
;
}
function
PerfEvent
(
data
)
{
let
importContext
=
arguments
.
length
>
1
&
&
arguments
[
1
]
!
=
=
undefined
?
arguments
[
1
]
:
globalImportContext
;
const
action
=
{
type
:
actionTypes
.
TELEMETRY_PERFORMANCE_EVENT
data
}
;
return
importContext
=
=
=
UI_CODE
?
SendToMain
(
action
)
:
action
;
}
function
ImpressionStats
(
data
)
{
let
importContext
=
arguments
.
length
>
1
&
&
arguments
[
1
]
!
=
=
undefined
?
arguments
[
1
]
:
globalImportContext
;
const
action
=
{
type
:
actionTypes
.
TELEMETRY_IMPRESSION_STATS
data
}
;
return
importContext
=
=
=
UI_CODE
?
SendToMain
(
action
)
:
action
;
}
function
SetPref
(
name
value
)
{
let
importContext
=
arguments
.
length
>
2
&
&
arguments
[
2
]
!
=
=
undefined
?
arguments
[
2
]
:
globalImportContext
;
const
action
=
{
type
:
actionTypes
.
SET_PREF
data
:
{
name
value
}
}
;
return
importContext
=
=
=
UI_CODE
?
SendToMain
(
action
)
:
action
;
}
var
actionCreators
=
{
BroadcastToContent
UserEvent
UndesiredEvent
PerfEvent
ImpressionStats
SendToContent
SendToMain
SetPref
}
;
var
actionUtils
=
{
isSendToMain
(
action
)
{
if
(
!
action
.
meta
)
{
return
false
;
}
return
action
.
meta
.
to
=
=
=
MAIN_MESSAGE_TYPE
&
&
action
.
meta
.
from
=
=
=
CONTENT_MESSAGE_TYPE
;
}
isBroadcastToContent
(
action
)
{
if
(
!
action
.
meta
)
{
return
false
;
}
if
(
action
.
meta
.
to
=
=
=
CONTENT_MESSAGE_TYPE
&
&
!
action
.
meta
.
toTarget
)
{
return
true
;
}
return
false
;
}
isSendToContent
(
action
)
{
if
(
!
action
.
meta
)
{
return
false
;
}
if
(
action
.
meta
.
to
=
=
=
CONTENT_MESSAGE_TYPE
&
&
action
.
meta
.
toTarget
)
{
return
true
;
}
return
false
;
}
getPortIdOfSender
(
action
)
{
return
action
.
meta
&
&
action
.
meta
.
fromTarget
|
|
null
;
}
_RouteMessage
}
;
module
.
exports
=
{
actionTypes
actionCreators
actionUtils
globalImportContext
UI_CODE
BACKGROUND_PROCESS
MAIN_MESSAGE_TYPE
CONTENT_MESSAGE_TYPE
}
;
}
)
(
function
(
module
exports
)
{
module
.
exports
=
ReactIntl
;
}
)
(
function
(
module
exports
)
{
module
.
exports
=
ReactRedux
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
React
=
__webpack_require__
(
0
)
;
var
_require
=
__webpack_require__
(
2
)
;
const
injectIntl
=
_require
.
injectIntl
;
const
ContextMenu
=
__webpack_require__
(
16
)
;
var
_require2
=
__webpack_require__
(
1
)
;
const
ac
=
_require2
.
actionCreators
;
const
linkMenuOptions
=
__webpack_require__
(
23
)
;
const
DEFAULT_SITE_MENU_OPTIONS
=
[
"
CheckPinTopSite
"
"
Separator
"
"
OpenInNewWindow
"
"
OpenInPrivateWindow
"
"
Separator
"
"
BlockUrl
"
]
;
class
LinkMenu
extends
React
.
Component
{
getOptions
(
)
{
const
props
=
this
.
props
;
const
site
=
props
.
site
index
=
props
.
index
source
=
props
.
source
;
const
propOptions
=
!
site
.
isDefault
?
props
.
options
:
DEFAULT_SITE_MENU_OPTIONS
;
const
options
=
propOptions
.
map
(
o
=
>
linkMenuOptions
[
o
]
(
site
index
source
)
)
.
map
(
option
=
>
{
const
action
=
option
.
action
impression
=
option
.
impression
id
=
option
.
id
type
=
option
.
type
userEvent
=
option
.
userEvent
;
if
(
!
type
&
&
id
)
{
option
.
label
=
props
.
intl
.
formatMessage
(
option
)
;
option
.
onClick
=
(
)
=
>
{
props
.
dispatch
(
action
)
;
if
(
userEvent
)
{
props
.
dispatch
(
ac
.
UserEvent
(
{
event
:
userEvent
source
action_position
:
index
}
)
)
;
}
if
(
impression
)
{
props
.
dispatch
(
impression
)
;
}
}
;
}
return
option
;
}
)
;
options
[
0
]
.
first
=
true
;
options
[
options
.
length
-
1
]
.
last
=
true
;
return
options
;
}
render
(
)
{
return
React
.
createElement
(
ContextMenu
{
visible
:
this
.
props
.
visible
onUpdate
:
this
.
props
.
onUpdate
options
:
this
.
getOptions
(
)
}
)
;
}
}
module
.
exports
=
injectIntl
(
LinkMenu
)
;
module
.
exports
.
_unconnected
=
LinkMenu
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
let
usablePerfObj
;
let
Cu
;
const
isRunningInChrome
=
typeof
Window
=
=
=
"
undefined
"
;
if
(
isRunningInChrome
)
{
Cu
=
Components
.
utils
;
}
else
{
Cu
=
{
import
(
)
{
}
}
;
}
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
if
(
isRunningInChrome
)
{
usablePerfObj
=
Services
.
appShell
.
hiddenDOMWindow
.
performance
;
}
else
{
usablePerfObj
=
performance
;
}
var
_PerfService
=
function
_PerfService
(
options
)
{
if
(
options
&
&
options
.
performanceObj
)
{
this
.
_perf
=
options
.
performanceObj
;
}
else
{
this
.
_perf
=
usablePerfObj
;
}
}
;
_PerfService
.
prototype
=
{
mark
:
function
mark
(
str
)
{
this
.
_perf
.
mark
(
str
)
;
}
getEntriesByName
:
function
getEntriesByName
(
name
type
)
{
return
this
.
_perf
.
getEntriesByName
(
name
type
)
;
}
get
timeOrigin
(
)
{
return
this
.
_perf
.
timeOrigin
;
}
absNow
:
function
absNow
(
)
{
return
this
.
timeOrigin
+
this
.
_perf
.
now
(
)
;
}
getMostRecentAbsMarkStartByName
(
name
)
{
let
entries
=
this
.
getEntriesByName
(
name
"
mark
"
)
;
if
(
!
entries
.
length
)
{
throw
new
Error
(
No
marks
with
the
name
{
name
}
)
;
}
let
mostRecentEntry
=
entries
[
entries
.
length
-
1
]
;
return
this
.
_perf
.
timeOrigin
+
mostRecentEntry
.
startTime
;
}
}
;
var
perfService
=
new
_PerfService
(
)
;
module
.
exports
=
{
_PerfService
perfService
}
;
}
)
(
function
(
module
exports
)
{
var
g
;
g
=
(
function
(
)
{
return
this
;
}
)
(
)
;
try
{
g
=
g
|
|
Function
(
"
return
this
"
)
(
)
|
|
(
1
eval
)
(
"
this
"
)
;
}
catch
(
e
)
{
if
(
typeof
window
=
=
=
"
object
"
)
g
=
window
;
}
module
.
exports
=
g
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
React
=
__webpack_require__
(
0
)
;
var
_require
=
__webpack_require__
(
3
)
;
const
connect
=
_require
.
connect
;
var
_require2
=
__webpack_require__
(
2
)
;
const
addLocaleData
=
_require2
.
addLocaleData
IntlProvider
=
_require2
.
IntlProvider
;
const
TopSites
=
__webpack_require__
(
21
)
;
const
Search
=
__webpack_require__
(
19
)
;
const
ConfirmDialog
=
__webpack_require__
(
15
)
;
const
ManualMigration
=
__webpack_require__
(
17
)
;
const
PreferencesPane
=
__webpack_require__
(
18
)
;
const
Sections
=
__webpack_require__
(
20
)
;
const
RTL_LIST
=
[
"
ar
"
"
he
"
"
fa
"
"
ur
"
]
;
function
addLocaleDataForReactIntl
(
_ref
)
{
let
locale
=
_ref
.
locale
;
addLocaleData
(
[
{
locale
parentLocale
:
"
en
"
}
]
)
;
document
.
documentElement
.
lang
=
locale
;
document
.
documentElement
.
dir
=
RTL_LIST
.
indexOf
(
locale
.
split
(
"
-
"
)
[
0
]
)
>
=
0
?
"
rtl
"
:
"
ltr
"
;
}
class
Base
extends
React
.
Component
{
componentDidMount
(
)
{
addEventListener
(
"
visibilitychange
"
(
)
=
>
{
this
.
updateTitle
(
this
.
props
.
App
)
;
document
.
getElementById
(
"
favicon
"
)
.
href
+
=
"
#
"
;
}
{
once
:
true
}
)
;
}
componentWillUpdate
(
_ref2
)
{
let
App
=
_ref2
.
App
;
if
(
App
.
locale
&
&
App
.
locale
!
=
=
this
.
props
.
App
.
locale
)
{
addLocaleDataForReactIntl
(
App
)
;
this
.
updateTitle
(
App
)
;
}
}
updateTitle
(
_ref3
)
{
let
strings
=
_ref3
.
strings
;
if
(
strings
)
{
document
.
title
=
strings
.
newtab_page_title
;
}
}
render
(
)
{
const
props
=
this
.
props
;
var
_props
App
=
props
.
App
;
const
locale
=
_props
App
.
locale
strings
=
_props
App
.
strings
initialized
=
_props
App
.
initialized
;
const
prefs
=
props
.
Prefs
.
values
;
if
(
!
initialized
|
|
!
strings
)
{
return
null
;
}
return
React
.
createElement
(
IntlProvider
{
key
:
locale
locale
:
locale
messages
:
strings
}
React
.
createElement
(
"
div
"
{
className
:
"
outer
-
wrapper
"
}
React
.
createElement
(
"
main
"
null
prefs
.
showSearch
&
&
React
.
createElement
(
Search
null
)
!
prefs
.
migrationExpired
&
&
React
.
createElement
(
ManualMigration
null
)
prefs
.
showTopSites
&
&
React
.
createElement
(
TopSites
null
)
React
.
createElement
(
Sections
null
)
React
.
createElement
(
ConfirmDialog
null
)
)
React
.
createElement
(
PreferencesPane
null
)
)
)
;
}
}
module
.
exports
=
connect
(
state
=
>
(
{
App
:
state
.
App
Prefs
:
state
.
Prefs
}
)
)
(
Base
)
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
var
_require
=
__webpack_require__
(
1
)
;
const
at
=
_require
.
actionTypes
;
var
_require2
=
__webpack_require__
(
5
)
;
const
perfSvc
=
_require2
.
perfService
;
const
VISIBLE
=
"
visible
"
;
const
VISIBILITY_CHANGE_EVENT
=
"
visibilitychange
"
;
module
.
exports
=
class
DetectUserSessionStart
{
constructor
(
)
{
let
options
=
arguments
.
length
>
0
&
&
arguments
[
0
]
!
=
=
undefined
?
arguments
[
0
]
:
{
}
;
this
.
sendAsyncMessage
=
options
.
sendAsyncMessage
|
|
window
.
sendAsyncMessage
;
this
.
document
=
options
.
document
|
|
document
;
this
.
_perfService
=
options
.
perfService
|
|
perfSvc
;
this
.
_onVisibilityChange
=
this
.
_onVisibilityChange
.
bind
(
this
)
;
}
sendEventOrAddListener
(
)
{
if
(
this
.
document
.
visibilityState
=
=
=
VISIBLE
)
{
this
.
_sendEvent
(
)
;
}
else
{
this
.
document
.
addEventListener
(
VISIBILITY_CHANGE_EVENT
this
.
_onVisibilityChange
)
;
}
}
_sendEvent
(
)
{
this
.
_perfService
.
mark
(
"
visibility_event_rcvd_ts
"
)
;
try
{
let
visibility_event_rcvd_ts
=
this
.
_perfService
.
getMostRecentAbsMarkStartByName
(
"
visibility_event_rcvd_ts
"
)
;
this
.
sendAsyncMessage
(
"
ActivityStream
:
ContentToMain
"
{
type
:
at
.
SAVE_SESSION_PERF_DATA
data
:
{
visibility_event_rcvd_ts
}
}
)
;
}
catch
(
ex
)
{
}
}
_onVisibilityChange
(
)
{
if
(
this
.
document
.
visibilityState
=
=
=
VISIBLE
)
{
this
.
_sendEvent
(
)
;
this
.
document
.
removeEventListener
(
VISIBILITY_CHANGE_EVENT
this
.
_onVisibilityChange
)
;
}
}
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
var
_require
=
__webpack_require__
(
24
)
;
const
createStore
=
_require
.
createStore
combineReducers
=
_require
.
combineReducers
applyMiddleware
=
_require
.
applyMiddleware
;
var
_require2
=
__webpack_require__
(
1
)
;
const
au
=
_require2
.
actionUtils
;
const
MERGE_STORE_ACTION
=
"
NEW_TAB_INITIAL_STATE
"
;
const
OUTGOING_MESSAGE_NAME
=
"
ActivityStream
:
ContentToMain
"
;
const
INCOMING_MESSAGE_NAME
=
"
ActivityStream
:
MainToContent
"
;
function
mergeStateReducer
(
mainReducer
)
{
return
(
prevState
action
)
=
>
{
if
(
action
.
type
=
=
=
MERGE_STORE_ACTION
)
{
return
Object
.
assign
(
{
}
prevState
action
.
data
)
;
}
return
mainReducer
(
prevState
action
)
;
}
;
}
const
messageMiddleware
=
store
=
>
next
=
>
action
=
>
{
if
(
au
.
isSendToMain
(
action
)
)
{
sendAsyncMessage
(
OUTGOING_MESSAGE_NAME
action
)
;
}
next
(
action
)
;
}
;
module
.
exports
=
function
initStore
(
reducers
)
{
const
store
=
createStore
(
mergeStateReducer
(
combineReducers
(
reducers
)
)
applyMiddleware
(
messageMiddleware
)
)
;
addMessageListener
(
INCOMING_MESSAGE_NAME
msg
=
>
{
try
{
store
.
dispatch
(
msg
.
data
)
;
}
catch
(
ex
)
{
console
.
error
(
"
Content
msg
:
"
msg
"
Dispatch
error
:
"
ex
)
;
dump
(
Content
msg
:
{
JSON
.
stringify
(
msg
)
}
\
nDispatch
error
:
{
ex
}
\
n
{
ex
.
stack
}
)
;
}
}
)
;
return
store
;
}
;
module
.
exports
.
MERGE_STORE_ACTION
=
MERGE_STORE_ACTION
;
module
.
exports
.
OUTGOING_MESSAGE_NAME
=
OUTGOING_MESSAGE_NAME
;
module
.
exports
.
INCOMING_MESSAGE_NAME
=
INCOMING_MESSAGE_NAME
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
(
function
(
global
)
{
const
DATABASE_NAME
=
"
snippets_db
"
;
const
DATABASE_VERSION
=
1
;
const
SNIPPETS_OBJECTSTORE_NAME
=
"
snippets
"
;
const
SNIPPETS_UPDATE_INTERVAL_MS
=
14400000
;
class
SnippetsMap
extends
Map
{
constructor
(
)
{
super
(
.
.
.
arguments
)
;
this
.
_db
=
null
;
}
set
(
key
value
)
{
super
.
set
(
key
value
)
;
return
this
.
_dbTransaction
(
db
=
>
db
.
put
(
value
key
)
)
;
}
delete
(
key
)
{
super
.
delete
(
key
)
;
return
this
.
_dbTransaction
(
db
=
>
db
.
delete
(
key
)
)
;
}
clear
(
)
{
super
.
clear
(
)
;
return
this
.
_dbTransaction
(
db
=
>
db
.
clear
(
)
)
;
}
get
blockList
(
)
{
return
this
.
get
(
"
blockList
"
)
|
|
[
]
;
}
async
blockSnippetById
(
id
)
{
if
(
!
id
)
{
return
;
}
let
blockList
=
this
.
blockList
;
if
(
!
blockList
.
includes
(
id
)
)
{
blockList
.
push
(
id
)
;
}
await
this
.
set
(
"
blockList
"
blockList
)
;
}
async
connect
(
)
{
const
db
=
await
this
.
_openDB
(
)
;
await
this
.
_restoreFromDb
(
db
)
;
this
.
_db
=
db
;
}
_dbTransaction
(
modifier
)
{
if
(
!
this
.
_db
)
{
return
Promise
.
resolve
(
)
;
}
return
new
Promise
(
(
resolve
reject
)
=
>
{
const
transaction
=
modifier
(
this
.
_db
.
transaction
(
SNIPPETS_OBJECTSTORE_NAME
"
readwrite
"
)
.
objectStore
(
SNIPPETS_OBJECTSTORE_NAME
)
)
;
transaction
.
onsuccess
=
event
=
>
resolve
(
)
;
transaction
.
onerror
=
event
=
>
reject
(
transaction
.
error
)
;
}
)
;
}
_openDB
(
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
const
openRequest
=
indexedDB
.
open
(
DATABASE_NAME
DATABASE_VERSION
)
;
openRequest
.
onerror
=
event
=
>
{
indexedDB
.
deleteDatabase
(
DATABASE_NAME
)
;
reject
(
event
)
;
}
;
openRequest
.
onupgradeneeded
=
event
=
>
{
const
db
=
event
.
target
.
result
;
if
(
!
db
.
objectStoreNames
.
contains
(
SNIPPETS_OBJECTSTORE_NAME
)
)
{
db
.
createObjectStore
(
SNIPPETS_OBJECTSTORE_NAME
)
;
}
}
;
openRequest
.
onsuccess
=
event
=
>
{
let
db
=
event
.
target
.
result
;
db
.
onerror
=
err
=
>
console
.
error
(
err
)
;
db
.
onversionchange
=
versionChangeEvent
=
>
versionChangeEvent
.
target
.
close
(
)
;
resolve
(
db
)
;
}
;
}
)
;
}
_restoreFromDb
(
db
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
cursorRequest
;
try
{
cursorRequest
=
db
.
transaction
(
SNIPPETS_OBJECTSTORE_NAME
)
.
objectStore
(
SNIPPETS_OBJECTSTORE_NAME
)
.
openCursor
(
)
;
}
catch
(
err
)
{
reject
(
err
)
;
return
;
}
cursorRequest
.
onerror
=
event
=
>
reject
(
event
)
;
cursorRequest
.
onsuccess
=
event
=
>
{
let
cursor
=
event
.
target
.
result
;
if
(
cursor
)
{
this
.
set
(
cursor
.
key
cursor
.
value
)
;
cursor
.
continue
(
)
;
}
else
{
resolve
(
)
;
}
}
;
}
)
;
}
}
class
SnippetsProvider
{
constructor
(
)
{
global
.
gSnippetsMap
=
new
SnippetsMap
(
)
;
}
get
snippetsMap
(
)
{
return
global
.
gSnippetsMap
;
}
async
_refreshSnippets
(
)
{
const
cachedVersion
=
this
.
snippetsMap
.
get
(
"
snippets
-
cached
-
version
"
)
;
if
(
cachedVersion
!
=
=
this
.
appData
.
version
)
{
this
.
snippetsMap
.
clear
(
)
;
}
const
lastUpdate
=
this
.
snippetsMap
.
get
(
"
snippets
-
last
-
update
"
)
;
const
needsUpdate
=
!
(
lastUpdate
>
=
0
)
|
|
Date
.
now
(
)
-
lastUpdate
>
SNIPPETS_UPDATE_INTERVAL_MS
;
if
(
needsUpdate
&
&
this
.
appData
.
snippetsURL
)
{
this
.
snippetsMap
.
set
(
"
snippets
-
last
-
update
"
Date
.
now
(
)
)
;
try
{
const
response
=
await
fetch
(
this
.
appData
.
snippetsURL
)
;
if
(
response
.
status
=
=
=
200
)
{
const
payload
=
await
response
.
text
(
)
;
this
.
snippetsMap
.
set
(
"
snippets
"
payload
)
;
this
.
snippetsMap
.
set
(
"
snippets
-
cached
-
version
"
this
.
appData
.
version
)
;
}
}
catch
(
e
)
{
console
.
error
(
e
)
;
}
}
}
_showDefaultSnippets
(
)
{
}
_showRemoteSnippets
(
)
{
const
snippetsEl
=
document
.
getElementById
(
this
.
elementId
)
;
const
payload
=
this
.
snippetsMap
.
get
(
"
snippets
"
)
;
if
(
!
snippetsEl
)
{
throw
new
Error
(
No
element
was
found
with
id
'
{
this
.
elementId
}
'
.
)
;
}
if
(
!
payload
)
{
throw
new
Error
(
"
No
remote
snippets
were
found
in
gSnippetsMap
.
"
)
;
}
snippetsEl
.
innerHTML
=
payload
;
for
(
const
scriptEl
of
snippetsEl
.
getElementsByTagName
(
"
script
"
)
)
{
const
relocatedScript
=
document
.
createElement
(
"
script
"
)
;
relocatedScript
.
text
=
scriptEl
.
text
;
scriptEl
.
parentNode
.
replaceChild
(
relocatedScript
scriptEl
)
;
}
}
async
init
(
options
)
{
Object
.
assign
(
this
{
appData
:
{
}
elementId
:
"
snippets
"
connect
:
true
}
options
)
;
if
(
this
.
connect
)
{
try
{
await
this
.
snippetsMap
.
connect
(
)
;
}
catch
(
e
)
{
console
.
error
(
e
)
;
}
}
for
(
const
key
of
Object
.
keys
(
this
.
appData
)
)
{
this
.
snippetsMap
.
set
(
appData
.
{
key
}
this
.
appData
[
key
]
)
;
}
await
this
.
_refreshSnippets
(
)
;
try
{
this
.
_showRemoteSnippets
(
)
;
}
catch
(
e
)
{
this
.
_showDefaultSnippets
(
e
)
;
}
}
}
function
addSnippetsSubscriber
(
store
)
{
const
snippets
=
new
SnippetsProvider
(
)
;
const
unsubscribe
=
store
.
subscribe
(
(
)
=
>
{
const
state
=
store
.
getState
(
)
;
if
(
state
.
Snippets
.
initialized
)
{
if
(
state
.
Snippets
.
onboardingFinished
)
{
snippets
.
init
(
{
appData
:
state
.
Snippets
}
)
;
}
unsubscribe
(
)
;
}
}
)
;
return
snippets
;
}
module
.
exports
=
{
addSnippetsSubscriber
SnippetsMap
SnippetsProvider
SNIPPETS_UPDATE_INTERVAL_MS
}
;
}
.
call
(
exports
__webpack_require__
(
6
)
)
)
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
var
_require
=
__webpack_require__
(
1
)
;
const
at
=
_require
.
actionTypes
;
const
TOP_SITES_SHOWMORE_LENGTH
=
12
;
const
INITIAL_STATE
=
{
App
:
{
initialized
:
false
locale
:
"
"
strings
:
null
version
:
null
}
Snippets
:
{
initialized
:
false
}
TopSites
:
{
initialized
:
false
rows
:
[
]
}
Prefs
:
{
initialized
:
false
values
:
{
}
}
Dialog
:
{
visible
:
false
data
:
{
}
}
Sections
:
[
]
}
;
function
App
(
)
{
let
prevState
=
arguments
.
length
>
0
&
&
arguments
[
0
]
!
=
=
undefined
?
arguments
[
0
]
:
INITIAL_STATE
.
App
;
let
action
=
arguments
[
1
]
;
switch
(
action
.
type
)
{
case
at
.
INIT
:
return
Object
.
assign
(
{
}
prevState
action
.
data
|
|
{
}
{
initialized
:
true
}
)
;
case
at
.
LOCALE_UPDATED
:
{
if
(
!
action
.
data
)
{
return
prevState
;
}
var
_action
data
=
action
.
data
;
let
locale
=
_action
data
.
locale
strings
=
_action
data
.
strings
;
return
Object
.
assign
(
{
}
prevState
{
locale
strings
}
)
;
}
default
:
return
prevState
;
}
}
function
insertPinned
(
links
pinned
)
{
const
pinnedUrls
=
pinned
.
map
(
link
=
>
link
&
&
link
.
url
)
;
let
newLinks
=
links
.
filter
(
link
=
>
link
?
!
pinnedUrls
.
includes
(
link
.
url
)
:
false
)
;
newLinks
=
newLinks
.
map
(
link
=
>
{
if
(
link
&
&
link
.
isPinned
)
{
delete
link
.
isPinned
;
delete
link
.
pinIndex
;
}
return
link
;
}
)
;
pinned
.
forEach
(
(
val
index
)
=
>
{
if
(
!
val
)
{
return
;
}
let
link
=
Object
.
assign
(
{
}
val
{
isPinned
:
true
pinIndex
:
index
}
)
;
if
(
index
>
newLinks
.
length
)
{
newLinks
[
index
]
=
link
;
}
else
{
newLinks
.
splice
(
index
0
link
)
;
}
}
)
;
return
newLinks
;
}
function
TopSites
(
)
{
let
prevState
=
arguments
.
length
>
0
&
&
arguments
[
0
]
!
=
=
undefined
?
arguments
[
0
]
:
INITIAL_STATE
.
TopSites
;
let
action
=
arguments
[
1
]
;
let
hasMatch
;
let
newRows
;
let
pinned
;
switch
(
action
.
type
)
{
case
at
.
TOP_SITES_UPDATED
:
if
(
!
action
.
data
)
{
return
prevState
;
}
return
Object
.
assign
(
{
}
prevState
{
initialized
:
true
rows
:
action
.
data
}
)
;
case
at
.
SCREENSHOT_UPDATED
:
newRows
=
prevState
.
rows
.
map
(
row
=
>
{
if
(
row
&
&
row
.
url
=
=
=
action
.
data
.
url
)
{
hasMatch
=
true
;
return
Object
.
assign
(
{
}
row
{
screenshot
:
action
.
data
.
screenshot
}
)
;
}
return
row
;
}
)
;
return
hasMatch
?
Object
.
assign
(
{
}
prevState
{
rows
:
newRows
}
)
:
prevState
;
case
at
.
PLACES_BOOKMARK_ADDED
:
if
(
!
action
.
data
)
{
return
prevState
;
}
newRows
=
prevState
.
rows
.
map
(
site
=
>
{
if
(
site
&
&
site
.
url
=
=
=
action
.
data
.
url
)
{
var
_action
data2
=
action
.
data
;
const
bookmarkGuid
=
_action
data2
.
bookmarkGuid
bookmarkTitle
=
_action
data2
.
bookmarkTitle
lastModified
=
_action
data2
.
lastModified
;
return
Object
.
assign
(
{
}
site
{
bookmarkGuid
bookmarkTitle
bookmarkDateCreated
:
lastModified
}
)
;
}
return
site
;
}
)
;
return
Object
.
assign
(
{
}
prevState
{
rows
:
newRows
}
)
;
case
at
.
PLACES_BOOKMARK_REMOVED
:
if
(
!
action
.
data
)
{
return
prevState
;
}
newRows
=
prevState
.
rows
.
map
(
site
=
>
{
if
(
site
&
&
site
.
url
=
=
=
action
.
data
.
url
)
{
const
newSite
=
Object
.
assign
(
{
}
site
)
;
delete
newSite
.
bookmarkGuid
;
delete
newSite
.
bookmarkTitle
;
delete
newSite
.
bookmarkDateCreated
;
return
newSite
;
}
return
site
;
}
)
;
return
Object
.
assign
(
{
}
prevState
{
rows
:
newRows
}
)
;
case
at
.
PLACES_LINK_DELETED
:
case
at
.
PLACES_LINK_BLOCKED
:
newRows
=
prevState
.
rows
.
filter
(
val
=
>
val
&
&
val
.
url
!
=
=
action
.
data
.
url
)
;
return
Object
.
assign
(
{
}
prevState
{
rows
:
newRows
}
)
;
case
at
.
PINNED_SITES_UPDATED
:
pinned
=
action
.
data
;
newRows
=
insertPinned
(
prevState
.
rows
pinned
)
.
slice
(
0
TOP_SITES_SHOWMORE_LENGTH
)
;
return
Object
.
assign
(
{
}
prevState
{
rows
:
newRows
}
)
;
default
:
return
prevState
;
}
}
function
Dialog
(
)
{
let
prevState
=
arguments
.
length
>
0
&
&
arguments
[
0
]
!
=
=
undefined
?
arguments
[
0
]
:
INITIAL_STATE
.
Dialog
;
let
action
=
arguments
[
1
]
;
switch
(
action
.
type
)
{
case
at
.
DIALOG_OPEN
:
return
Object
.
assign
(
{
}
prevState
{
visible
:
true
data
:
action
.
data
}
)
;
case
at
.
DIALOG_CANCEL
:
return
Object
.
assign
(
{
}
prevState
{
visible
:
false
}
)
;
case
at
.
DELETE_HISTORY_URL
:
return
Object
.
assign
(
{
}
INITIAL_STATE
.
Dialog
)
;
default
:
return
prevState
;
}
}
function
Prefs
(
)
{
let
prevState
=
arguments
.
length
>
0
&
&
arguments
[
0
]
!
=
=
undefined
?
arguments
[
0
]
:
INITIAL_STATE
.
Prefs
;
let
action
=
arguments
[
1
]
;
let
newValues
;
switch
(
action
.
type
)
{
case
at
.
PREFS_INITIAL_VALUES
:
return
Object
.
assign
(
{
}
prevState
{
initialized
:
true
values
:
action
.
data
}
)
;
case
at
.
PREF_CHANGED
:
newValues
=
Object
.
assign
(
{
}
prevState
.
values
)
;
newValues
[
action
.
data
.
name
]
=
action
.
data
.
value
;
return
Object
.
assign
(
{
}
prevState
{
values
:
newValues
}
)
;
default
:
return
prevState
;
}
}
function
Sections
(
)
{
let
prevState
=
arguments
.
length
>
0
&
&
arguments
[
0
]
!
=
=
undefined
?
arguments
[
0
]
:
INITIAL_STATE
.
Sections
;
let
action
=
arguments
[
1
]
;
let
hasMatch
;
let
newState
;
switch
(
action
.
type
)
{
case
at
.
SECTION_DEREGISTER
:
return
prevState
.
filter
(
section
=
>
section
.
id
!
=
=
action
.
data
)
;
case
at
.
SECTION_REGISTER
:
newState
=
prevState
.
map
(
section
=
>
{
if
(
section
&
&
section
.
id
=
=
=
action
.
data
.
id
)
{
hasMatch
=
true
;
return
Object
.
assign
(
{
}
section
action
.
data
)
;
}
return
section
;
}
)
;
if
(
!
hasMatch
)
{
const
initialized
=
action
.
data
.
rows
&
&
action
.
data
.
rows
.
length
>
0
;
newState
.
push
(
Object
.
assign
(
{
title
:
"
"
initialized
rows
:
[
]
}
action
.
data
)
)
;
}
return
newState
;
case
at
.
SECTION_ROWS_UPDATE
:
return
prevState
.
map
(
section
=
>
{
if
(
section
&
&
section
.
id
=
=
=
action
.
data
.
id
)
{
return
Object
.
assign
(
{
}
section
action
.
data
)
;
}
return
section
;
}
)
;
case
at
.
PLACES_BOOKMARK_ADDED
:
if
(
!
action
.
data
)
{
return
prevState
;
}
return
prevState
.
map
(
section
=
>
Object
.
assign
(
{
}
section
{
rows
:
section
.
rows
.
map
(
item
=
>
{
if
(
item
.
url
=
=
=
action
.
data
.
url
)
{
var
_action
data3
=
action
.
data
;
const
bookmarkGuid
=
_action
data3
.
bookmarkGuid
bookmarkTitle
=
_action
data3
.
bookmarkTitle
lastModified
=
_action
data3
.
lastModified
;
Object
.
assign
(
item
{
bookmarkGuid
bookmarkTitle
bookmarkDateCreated
:
lastModified
}
)
;
}
return
item
;
}
)
}
)
)
;
case
at
.
PLACES_BOOKMARK_REMOVED
:
if
(
!
action
.
data
)
{
return
prevState
;
}
return
prevState
.
map
(
section
=
>
Object
.
assign
(
{
}
section
{
rows
:
section
.
rows
.
map
(
item
=
>
{
if
(
item
.
url
=
=
=
action
.
data
.
url
)
{
const
newSite
=
Object
.
assign
(
{
}
item
)
;
delete
newSite
.
bookmarkGuid
;
delete
newSite
.
bookmarkTitle
;
delete
newSite
.
bookmarkDateCreated
;
return
newSite
;
}
return
item
;
}
)
}
)
)
;
case
at
.
PLACES_LINK_DELETED
:
case
at
.
PLACES_LINK_BLOCKED
:
return
prevState
.
map
(
section
=
>
Object
.
assign
(
{
}
section
{
rows
:
section
.
rows
.
filter
(
site
=
>
site
.
url
!
=
=
action
.
data
.
url
)
}
)
)
;
default
:
return
prevState
;
}
}
function
Snippets
(
)
{
let
prevState
=
arguments
.
length
>
0
&
&
arguments
[
0
]
!
=
=
undefined
?
arguments
[
0
]
:
INITIAL_STATE
.
Snippets
;
let
action
=
arguments
[
1
]
;
switch
(
action
.
type
)
{
case
at
.
SNIPPETS_DATA
:
return
Object
.
assign
(
{
}
prevState
{
initialized
:
true
}
action
.
data
)
;
case
at
.
SNIPPETS_RESET
:
return
INITIAL_STATE
.
Snippets
;
default
:
return
prevState
;
}
}
var
reducers
=
{
TopSites
App
Snippets
Prefs
Dialog
Sections
}
;
module
.
exports
=
{
reducers
INITIAL_STATE
insertPinned
TOP_SITES_SHOWMORE_LENGTH
}
;
}
)
(
function
(
module
exports
)
{
module
.
exports
=
ReactDOM
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
React
=
__webpack_require__
(
0
)
;
const
LinkMenu
=
__webpack_require__
(
4
)
;
var
_require
=
__webpack_require__
(
2
)
;
const
FormattedMessage
=
_require
.
FormattedMessage
;
const
cardContextTypes
=
__webpack_require__
(
14
)
;
var
_require2
=
__webpack_require__
(
1
)
;
const
ac
=
_require2
.
actionCreators
at
=
_require2
.
actionTypes
;
class
Card
extends
React
.
Component
{
constructor
(
props
)
{
super
(
props
)
;
this
.
state
=
{
showContextMenu
:
false
activeCard
:
null
}
;
this
.
onMenuButtonClick
=
this
.
onMenuButtonClick
.
bind
(
this
)
;
this
.
onMenuUpdate
=
this
.
onMenuUpdate
.
bind
(
this
)
;
this
.
onLinkClick
=
this
.
onLinkClick
.
bind
(
this
)
;
}
onMenuButtonClick
(
event
)
{
event
.
preventDefault
(
)
;
this
.
setState
(
{
activeCard
:
this
.
props
.
index
showContextMenu
:
true
}
)
;
}
onLinkClick
(
event
)
{
event
.
preventDefault
(
)
;
const
altKey
=
event
.
altKey
button
=
event
.
button
ctrlKey
=
event
.
ctrlKey
metaKey
=
event
.
metaKey
shiftKey
=
event
.
shiftKey
;
this
.
props
.
dispatch
(
ac
.
SendToMain
(
{
type
:
at
.
OPEN_LINK
data
:
Object
.
assign
(
this
.
props
.
link
{
event
:
{
altKey
button
ctrlKey
metaKey
shiftKey
}
}
)
}
)
)
;
this
.
props
.
dispatch
(
ac
.
UserEvent
(
{
event
:
"
CLICK
"
source
:
this
.
props
.
eventSource
action_position
:
this
.
props
.
index
}
)
)
;
this
.
props
.
dispatch
(
ac
.
ImpressionStats
(
{
source
:
this
.
props
.
eventSource
click
:
0
incognito
:
true
tiles
:
[
{
id
:
this
.
props
.
link
.
guid
pos
:
this
.
props
.
index
}
]
}
)
)
;
}
onMenuUpdate
(
showContextMenu
)
{
this
.
setState
(
{
showContextMenu
}
)
;
}
render
(
)
{
var
_props
=
this
.
props
;
const
index
=
_props
.
index
link
=
_props
.
link
dispatch
=
_props
.
dispatch
contextMenuOptions
=
_props
.
contextMenuOptions
eventSource
=
_props
.
eventSource
;
const
isContextMenuOpen
=
this
.
state
.
showContextMenu
&
&
this
.
state
.
activeCard
=
=
=
index
;
var
_ref
=
link
.
type
?
cardContextTypes
[
link
.
type
]
:
{
}
;
const
icon
=
_ref
.
icon
intlID
=
_ref
.
intlID
;
return
React
.
createElement
(
"
li
"
{
className
:
card
-
outer
{
isContextMenuOpen
?
"
active
"
:
"
"
}
}
React
.
createElement
(
"
a
"
{
href
:
link
.
url
onClick
:
this
.
onLinkClick
}
React
.
createElement
(
"
div
"
{
className
:
"
card
"
}
link
.
image
&
&
React
.
createElement
(
"
div
"
{
className
:
"
card
-
preview
-
image
"
style
:
{
backgroundImage
:
url
(
{
link
.
image
}
)
}
}
)
React
.
createElement
(
"
div
"
{
className
:
card
-
details
{
link
.
image
?
"
"
:
"
no
-
image
"
}
}
link
.
hostname
&
&
React
.
createElement
(
"
div
"
{
className
:
"
card
-
host
-
name
"
}
link
.
hostname
)
React
.
createElement
(
"
div
"
{
className
:
card
-
text
{
link
.
image
?
"
"
:
"
no
-
image
"
}
{
link
.
hostname
?
"
"
:
"
no
-
host
-
name
"
}
{
icon
?
"
"
:
"
no
-
context
"
}
}
React
.
createElement
(
"
h4
"
{
className
:
"
card
-
title
"
dir
:
"
auto
"
}
link
.
title
)
React
.
createElement
(
"
p
"
{
className
:
"
card
-
description
"
dir
:
"
auto
"
}
link
.
description
)
)
icon
&
&
React
.
createElement
(
"
div
"
{
className
:
"
card
-
context
"
}
React
.
createElement
(
"
span
"
{
className
:
card
-
context
-
icon
icon
icon
-
{
icon
}
}
)
React
.
createElement
(
"
div
"
{
className
:
"
card
-
context
-
label
"
}
React
.
createElement
(
FormattedMessage
{
id
:
intlID
defaultMessage
:
"
Visited
"
}
)
)
)
)
)
)
React
.
createElement
(
"
button
"
{
className
:
"
context
-
menu
-
button
"
onClick
:
this
.
onMenuButtonClick
}
React
.
createElement
(
"
span
"
{
className
:
"
sr
-
only
"
}
Open
context
menu
for
{
link
.
title
}
)
)
React
.
createElement
(
LinkMenu
{
dispatch
:
dispatch
index
:
index
source
:
eventSource
onUpdate
:
this
.
onMenuUpdate
options
:
link
.
context_menu_options
|
|
contextMenuOptions
site
:
link
visible
:
isContextMenuOpen
}
)
)
;
}
}
module
.
exports
=
Card
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
module
.
exports
=
{
history
:
{
intlID
:
"
type_label_visited
"
icon
:
"
historyItem
"
}
bookmark
:
{
intlID
:
"
type_label_bookmarked
"
icon
:
"
bookmark
"
}
trending
:
{
intlID
:
"
type_label_recommended
"
icon
:
"
trending
"
}
now
:
{
intlID
:
"
type_label_now
"
icon
:
"
now
"
}
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
React
=
__webpack_require__
(
0
)
;
var
_require
=
__webpack_require__
(
3
)
;
const
connect
=
_require
.
connect
;
var
_require2
=
__webpack_require__
(
2
)
;
const
FormattedMessage
=
_require2
.
FormattedMessage
;
var
_require3
=
__webpack_require__
(
1
)
;
const
actionTypes
=
_require3
.
actionTypes
ac
=
_require3
.
actionCreators
;
const
ConfirmDialog
=
React
.
createClass
(
{
displayName
:
"
ConfirmDialog
"
getDefaultProps
(
)
{
return
{
visible
:
false
data
:
{
}
}
;
}
_handleCancelBtn
(
)
{
this
.
props
.
dispatch
(
{
type
:
actionTypes
.
DIALOG_CANCEL
}
)
;
this
.
props
.
dispatch
(
ac
.
UserEvent
(
{
event
:
actionTypes
.
DIALOG_CANCEL
}
)
)
;
}
_handleConfirmBtn
(
)
{
this
.
props
.
data
.
onConfirm
.
forEach
(
this
.
props
.
dispatch
)
;
}
_renderModalMessage
(
)
{
const
message_body
=
this
.
props
.
data
.
body_string_id
;
if
(
!
message_body
)
{
return
null
;
}
return
React
.
createElement
(
"
span
"
null
message_body
.
map
(
msg
=
>
React
.
createElement
(
"
p
"
{
key
:
msg
}
React
.
createElement
(
FormattedMessage
{
id
:
msg
}
)
)
)
)
;
}
render
(
)
{
if
(
!
this
.
props
.
visible
)
{
return
null
;
}
return
React
.
createElement
(
"
div
"
{
className
:
"
confirmation
-
dialog
"
}
React
.
createElement
(
"
div
"
{
className
:
"
modal
-
overlay
"
onClick
:
this
.
_handleCancelBtn
}
)
React
.
createElement
(
"
div
"
{
className
:
"
modal
"
ref
:
"
modal
"
}
React
.
createElement
(
"
section
"
{
className
:
"
modal
-
message
"
}
this
.
_renderModalMessage
(
)
)
React
.
createElement
(
"
section
"
{
className
:
"
actions
"
}
React
.
createElement
(
"
button
"
{
ref
:
"
cancelButton
"
onClick
:
this
.
_handleCancelBtn
}
React
.
createElement
(
FormattedMessage
{
id
:
"
topsites_form_cancel_button
"
}
)
)
React
.
createElement
(
"
button
"
{
ref
:
"
confirmButton
"
className
:
"
done
"
onClick
:
this
.
_handleConfirmBtn
}
React
.
createElement
(
FormattedMessage
{
id
:
this
.
props
.
data
.
confirm_button_string_id
}
)
)
)
)
)
;
}
}
)
;
module
.
exports
=
connect
(
state
=
>
state
.
Dialog
)
(
ConfirmDialog
)
;
module
.
exports
.
_unconnected
=
ConfirmDialog
;
module
.
exports
.
Dialog
=
ConfirmDialog
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
React
=
__webpack_require__
(
0
)
;
class
ContextMenu
extends
React
.
Component
{
constructor
(
props
)
{
super
(
props
)
;
this
.
hideContext
=
this
.
hideContext
.
bind
(
this
)
;
}
hideContext
(
)
{
this
.
props
.
onUpdate
(
false
)
;
}
componentWillMount
(
)
{
this
.
hideContext
(
)
;
}
componentDidUpdate
(
prevProps
)
{
if
(
this
.
props
.
visible
&
&
!
prevProps
.
visible
)
{
setTimeout
(
(
)
=
>
{
window
.
addEventListener
(
"
click
"
this
.
hideContext
)
;
}
0
)
;
}
if
(
!
this
.
props
.
visible
&
&
prevProps
.
visible
)
{
window
.
removeEventListener
(
"
click
"
this
.
hideContext
)
;
}
}
componentWillUnmount
(
)
{
window
.
removeEventListener
(
"
click
"
this
.
hideContext
)
;
}
render
(
)
{
return
React
.
createElement
(
"
span
"
{
hidden
:
!
this
.
props
.
visible
className
:
"
context
-
menu
"
}
React
.
createElement
(
"
ul
"
{
role
:
"
menu
"
className
:
"
context
-
menu
-
list
"
}
this
.
props
.
options
.
map
(
(
option
i
)
=
>
option
.
type
=
=
=
"
separator
"
?
React
.
createElement
(
"
li
"
{
key
:
i
className
:
"
separator
"
}
)
:
React
.
createElement
(
ContextMenuItem
{
key
:
i
option
:
option
hideContext
:
this
.
hideContext
}
)
)
)
)
;
}
}
class
ContextMenuItem
extends
React
.
Component
{
constructor
(
props
)
{
super
(
props
)
;
this
.
onClick
=
this
.
onClick
.
bind
(
this
)
;
this
.
onKeyDown
=
this
.
onKeyDown
.
bind
(
this
)
;
}
onClick
(
)
{
this
.
props
.
hideContext
(
)
;
this
.
props
.
option
.
onClick
(
)
;
}
onKeyDown
(
event
)
{
const
option
=
this
.
props
.
option
;
switch
(
event
.
key
)
{
case
"
Tab
"
:
if
(
event
.
shiftKey
&
&
option
.
first
|
|
!
event
.
shiftKey
&
&
option
.
last
)
{
this
.
props
.
hideContext
(
)
;
}
break
;
case
"
Enter
"
:
this
.
props
.
hideContext
(
)
;
option
.
onClick
(
)
;
break
;
}
}
render
(
)
{
const
option
=
this
.
props
.
option
;
return
React
.
createElement
(
"
li
"
{
role
:
"
menuitem
"
className
:
"
context
-
menu
-
item
"
}
React
.
createElement
(
"
a
"
{
onClick
:
this
.
onClick
onKeyDown
:
this
.
onKeyDown
tabIndex
:
"
0
"
}
option
.
icon
&
&
React
.
createElement
(
"
span
"
{
className
:
icon
icon
-
spacer
icon
-
{
option
.
icon
}
}
)
option
.
label
)
)
;
}
}
module
.
exports
=
ContextMenu
;
module
.
exports
.
ContextMenu
=
ContextMenu
;
module
.
exports
.
ContextMenuItem
=
ContextMenuItem
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
React
=
__webpack_require__
(
0
)
;
var
_require
=
__webpack_require__
(
3
)
;
const
connect
=
_require
.
connect
;
var
_require2
=
__webpack_require__
(
2
)
;
const
FormattedMessage
=
_require2
.
FormattedMessage
;
var
_require3
=
__webpack_require__
(
1
)
;
const
at
=
_require3
.
actionTypes
ac
=
_require3
.
actionCreators
;
class
ManualMigration
extends
React
.
Component
{
constructor
(
props
)
{
super
(
props
)
;
this
.
onLaunchTour
=
this
.
onLaunchTour
.
bind
(
this
)
;
this
.
onCancelTour
=
this
.
onCancelTour
.
bind
(
this
)
;
}
onLaunchTour
(
)
{
this
.
props
.
dispatch
(
ac
.
SendToMain
(
{
type
:
at
.
MIGRATION_START
}
)
)
;
this
.
props
.
dispatch
(
ac
.
UserEvent
(
{
event
:
at
.
MIGRATION_START
}
)
)
;
}
onCancelTour
(
)
{
this
.
props
.
dispatch
(
ac
.
SendToMain
(
{
type
:
at
.
MIGRATION_CANCEL
}
)
)
;
this
.
props
.
dispatch
(
ac
.
UserEvent
(
{
event
:
at
.
MIGRATION_CANCEL
}
)
)
;
}
render
(
)
{
return
React
.
createElement
(
"
div
"
{
className
:
"
manual
-
migration
-
container
"
}
React
.
createElement
(
"
p
"
null
React
.
createElement
(
"
span
"
{
className
:
"
icon
icon
-
info
"
}
)
React
.
createElement
(
FormattedMessage
{
id
:
"
manual_migration_explanation
"
}
)
)
React
.
createElement
(
"
div
"
{
className
:
"
manual
-
migration
-
actions
actions
"
}
React
.
createElement
(
"
button
"
{
onClick
:
this
.
onCancelTour
}
React
.
createElement
(
FormattedMessage
{
id
:
"
manual_migration_cancel_button
"
}
)
)
React
.
createElement
(
"
button
"
{
className
:
"
done
"
onClick
:
this
.
onLaunchTour
}
React
.
createElement
(
FormattedMessage
{
id
:
"
manual_migration_import_button
"
}
)
)
)
)
;
}
}
module
.
exports
=
connect
(
)
(
ManualMigration
)
;
module
.
exports
.
_unconnected
=
ManualMigration
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
React
=
__webpack_require__
(
0
)
;
var
_require
=
__webpack_require__
(
3
)
;
const
connect
=
_require
.
connect
;
var
_require2
=
__webpack_require__
(
2
)
;
const
injectIntl
=
_require2
.
injectIntl
FormattedMessage
=
_require2
.
FormattedMessage
;
var
_require3
=
__webpack_require__
(
1
)
;
const
ac
=
_require3
.
actionCreators
;
const
PreferencesInput
=
props
=
>
React
.
createElement
(
"
section
"
null
React
.
createElement
(
"
input
"
{
type
:
"
checkbox
"
id
:
props
.
prefName
name
:
props
.
prefName
checked
:
props
.
value
onChange
:
props
.
onChange
className
:
props
.
className
}
)
React
.
createElement
(
"
label
"
{
htmlFor
:
props
.
prefName
}
React
.
createElement
(
FormattedMessage
{
id
:
props
.
titleStringId
values
:
props
.
titleStringValues
}
)
)
props
.
descStringId
&
&
React
.
createElement
(
"
p
"
{
className
:
"
prefs
-
input
-
description
"
}
React
.
createElement
(
FormattedMessage
{
id
:
props
.
descStringId
}
)
)
)
;
class
PreferencesPane
extends
React
.
Component
{
constructor
(
props
)
{
super
(
props
)
;
this
.
state
=
{
visible
:
false
}
;
this
.
handleClickOutside
=
this
.
handleClickOutside
.
bind
(
this
)
;
this
.
handleChange
=
this
.
handleChange
.
bind
(
this
)
;
this
.
togglePane
=
this
.
togglePane
.
bind
(
this
)
;
const
optionJSON
=
props
.
Prefs
.
values
[
"
feeds
.
section
.
topstories
.
options
"
]
;
if
(
optionJSON
)
{
try
{
this
.
topStoriesOptions
=
JSON
.
parse
(
optionJSON
)
;
}
catch
(
e
)
{
console
.
error
(
"
Problem
parsing
feeds
.
section
.
topstories
.
options
"
e
)
;
}
}
}
componentDidMount
(
)
{
document
.
addEventListener
(
"
click
"
this
.
handleClickOutside
)
;
}
componentWillUnmount
(
)
{
document
.
removeEventListener
(
"
click
"
this
.
handleClickOutside
)
;
}
handleClickOutside
(
event
)
{
if
(
this
.
state
.
visible
&
&
!
this
.
refs
.
wrapper
.
contains
(
event
.
target
)
)
{
this
.
togglePane
(
)
;
}
}
handleChange
(
event
)
{
const
target
=
event
.
target
;
this
.
props
.
dispatch
(
ac
.
SetPref
(
target
.
name
target
.
checked
)
)
;
}
togglePane
(
)
{
this
.
setState
(
{
visible
:
!
this
.
state
.
visible
}
)
;
const
event
=
this
.
state
.
visible
?
"
CLOSE_NEWTAB_PREFS
"
:
"
OPEN_NEWTAB_PREFS
"
;
this
.
props
.
dispatch
(
ac
.
UserEvent
(
{
event
}
)
)
;
}
render
(
)
{
const
props
=
this
.
props
;
const
prefs
=
props
.
Prefs
.
values
;
const
isVisible
=
this
.
state
.
visible
;
return
React
.
createElement
(
"
div
"
{
className
:
"
prefs
-
pane
-
wrapper
"
ref
:
"
wrapper
"
}
React
.
createElement
(
"
div
"
{
className
:
"
prefs
-
pane
-
button
"
}
React
.
createElement
(
"
button
"
{
className
:
prefs
-
button
icon
{
isVisible
?
"
icon
-
dismiss
"
:
"
icon
-
settings
"
}
title
:
props
.
intl
.
formatMessage
(
{
id
:
isVisible
?
"
settings_pane_done_button
"
:
"
settings_pane_button_label
"
}
)
onClick
:
this
.
togglePane
}
)
)
React
.
createElement
(
"
div
"
{
className
:
"
prefs
-
pane
"
}
React
.
createElement
(
"
div
"
{
className
:
sidebar
{
isVisible
?
"
"
:
"
hidden
"
}
}
React
.
createElement
(
"
div
"
{
className
:
"
prefs
-
modal
-
inner
-
wrapper
"
}
React
.
createElement
(
"
h1
"
null
React
.
createElement
(
FormattedMessage
{
id
:
"
settings_pane_header
"
}
)
)
React
.
createElement
(
"
p
"
null
React
.
createElement
(
FormattedMessage
{
id
:
"
settings_pane_body
"
}
)
)
React
.
createElement
(
PreferencesInput
{
className
:
"
showSearch
"
prefName
:
"
showSearch
"
value
:
prefs
.
showSearch
onChange
:
this
.
handleChange
titleStringId
:
"
settings_pane_search_header
"
descStringId
:
"
settings_pane_search_body
"
}
)
React
.
createElement
(
PreferencesInput
{
className
:
"
showTopSites
"
prefName
:
"
showTopSites
"
value
:
prefs
.
showTopSites
onChange
:
this
.
handleChange
titleStringId
:
"
settings_pane_topsites_header
"
descStringId
:
"
settings_pane_topsites_body
"
}
)
this
.
topStoriesOptions
&
&
!
this
.
topStoriesOptions
.
hidden
&
&
React
.
createElement
(
PreferencesInput
{
className
:
"
showTopStories
"
prefName
:
"
feeds
.
section
.
topstories
"
value
:
prefs
[
"
feeds
.
section
.
topstories
"
]
onChange
:
this
.
handleChange
titleStringId
:
"
header_recommended_by
"
titleStringValues
:
{
provider
:
this
.
topStoriesOptions
.
provider_name
}
descStringId
:
this
.
topStoriesOptions
.
provider_description
}
)
)
React
.
createElement
(
"
section
"
{
className
:
"
actions
"
}
React
.
createElement
(
"
button
"
{
className
:
"
done
"
onClick
:
this
.
togglePane
}
React
.
createElement
(
FormattedMessage
{
id
:
"
settings_pane_done_button
"
}
)
)
)
)
)
)
;
}
}
module
.
exports
=
connect
(
state
=
>
(
{
Prefs
:
state
.
Prefs
}
)
)
(
injectIntl
(
PreferencesPane
)
)
;
module
.
exports
.
PreferencesPane
=
PreferencesPane
;
module
.
exports
.
PreferencesInput
=
PreferencesInput
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
React
=
__webpack_require__
(
0
)
;
var
_require
=
__webpack_require__
(
3
)
;
const
connect
=
_require
.
connect
;
var
_require2
=
__webpack_require__
(
2
)
;
const
FormattedMessage
=
_require2
.
FormattedMessage
injectIntl
=
_require2
.
injectIntl
;
var
_require3
=
__webpack_require__
(
1
)
;
const
ac
=
_require3
.
actionCreators
;
class
Search
extends
React
.
Component
{
constructor
(
props
)
{
super
(
props
)
;
this
.
onClick
=
this
.
onClick
.
bind
(
this
)
;
this
.
onInputMount
=
this
.
onInputMount
.
bind
(
this
)
;
}
handleEvent
(
event
)
{
if
(
event
.
detail
.
type
=
=
=
"
Search
"
)
{
this
.
props
.
dispatch
(
ac
.
UserEvent
(
{
event
:
"
SEARCH
"
}
)
)
;
}
}
onClick
(
event
)
{
this
.
controller
.
search
(
event
)
;
}
onInputMount
(
input
)
{
if
(
input
)
{
this
.
controller
=
new
ContentSearchUIController
(
input
input
.
parentNode
"
newtab
"
"
newtab
"
)
;
addEventListener
(
"
ContentSearchClient
"
this
)
;
}
else
{
this
.
controller
=
null
;
removeEventListener
(
"
ContentSearchClient
"
this
)
;
}
}
render
(
)
{
return
React
.
createElement
(
"
form
"
{
className
:
"
search
-
wrapper
"
}
React
.
createElement
(
"
label
"
{
htmlFor
:
"
newtab
-
search
-
text
"
className
:
"
search
-
label
"
}
React
.
createElement
(
"
span
"
{
className
:
"
sr
-
only
"
}
React
.
createElement
(
FormattedMessage
{
id
:
"
search_web_placeholder
"
}
)
)
)
React
.
createElement
(
"
input
"
{
id
:
"
newtab
-
search
-
text
"
maxLength
:
"
256
"
placeholder
:
this
.
props
.
intl
.
formatMessage
(
{
id
:
"
search_web_placeholder
"
}
)
ref
:
this
.
onInputMount
title
:
this
.
props
.
intl
.
formatMessage
(
{
id
:
"
search_web_placeholder
"
}
)
type
:
"
search
"
}
)
React
.
createElement
(
"
button
"
{
className
:
"
search
-
button
"
onClick
:
this
.
onClick
title
:
this
.
props
.
intl
.
formatMessage
(
{
id
:
"
search_button
"
}
)
}
React
.
createElement
(
"
span
"
{
className
:
"
sr
-
only
"
}
React
.
createElement
(
FormattedMessage
{
id
:
"
search_button
"
}
)
)
)
)
;
}
}
module
.
exports
=
connect
(
)
(
injectIntl
(
Search
)
)
;
module
.
exports
.
_unconnected
=
Search
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
(
function
(
global
)
{
var
_extends
=
Object
.
assign
|
|
function
(
target
)
{
for
(
var
i
=
1
;
i
<
arguments
.
length
;
i
+
+
)
{
var
source
=
arguments
[
i
]
;
for
(
var
key
in
source
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
source
key
)
)
{
target
[
key
]
=
source
[
key
]
;
}
}
}
return
target
;
}
;
const
React
=
__webpack_require__
(
0
)
;
var
_require
=
__webpack_require__
(
3
)
;
const
connect
=
_require
.
connect
;
var
_require2
=
__webpack_require__
(
2
)
;
const
injectIntl
=
_require2
.
injectIntl
FormattedMessage
=
_require2
.
FormattedMessage
;
const
Card
=
__webpack_require__
(
13
)
;
const
Topics
=
__webpack_require__
(
22
)
;
var
_require3
=
__webpack_require__
(
1
)
;
const
ac
=
_require3
.
actionCreators
;
const
VISIBLE
=
"
visible
"
;
const
VISIBILITY_CHANGE_EVENT
=
"
visibilitychange
"
;
class
Section
extends
React
.
Component
{
constructor
(
props
)
{
super
(
props
)
;
this
.
onInfoEnter
=
this
.
onInfoEnter
.
bind
(
this
)
;
this
.
onInfoLeave
=
this
.
onInfoLeave
.
bind
(
this
)
;
this
.
state
=
{
infoActive
:
false
}
;
}
_setInfoState
(
nextActive
)
{
const
infoActive
=
!
!
nextActive
;
if
(
infoActive
!
=
=
this
.
state
.
infoActive
)
{
this
.
setState
(
{
infoActive
}
)
;
}
}
onInfoEnter
(
)
{
this
.
_setInfoState
(
true
)
;
}
onInfoLeave
(
event
)
{
this
.
_setInfoState
(
event
&
&
event
.
relatedTarget
&
&
(
event
.
relatedTarget
=
=
=
event
.
currentTarget
|
|
event
.
relatedTarget
.
compareDocumentPosition
(
event
.
currentTarget
)
&
Node
.
DOCUMENT_POSITION_CONTAINS
)
)
;
}
getFormattedMessage
(
message
)
{
return
typeof
message
=
=
=
"
string
"
?
React
.
createElement
(
"
span
"
null
message
)
:
React
.
createElement
(
FormattedMessage
message
)
;
}
_dispatchImpressionStats
(
)
{
const
props
=
this
.
props
;
const
maxCards
=
3
*
props
.
maxRows
;
props
.
dispatch
(
ac
.
ImpressionStats
(
{
source
:
props
.
eventSource
tiles
:
props
.
rows
.
slice
(
0
maxCards
)
.
map
(
link
=
>
(
{
id
:
link
.
guid
}
)
)
}
)
)
;
}
sendImpressionStatsOrAddListener
(
)
{
const
props
=
this
.
props
;
if
(
!
props
.
dispatch
)
{
return
;
}
if
(
props
.
document
.
visibilityState
=
=
=
VISIBLE
)
{
this
.
_dispatchImpressionStats
(
)
;
}
else
{
if
(
this
.
_onVisibilityChange
)
{
props
.
document
.
removeEventListener
(
VISIBILITY_CHANGE_EVENT
this
.
_onVisibilityChange
)
;
}
this
.
_onVisibilityChange
=
(
)
=
>
{
if
(
props
.
document
.
visibilityState
=
=
=
VISIBLE
)
{
this
.
_dispatchImpressionStats
(
)
;
props
.
document
.
removeEventListener
(
VISIBILITY_CHANGE_EVENT
this
.
_onVisibilityChange
)
;
}
}
;
props
.
document
.
addEventListener
(
VISIBILITY_CHANGE_EVENT
this
.
_onVisibilityChange
)
;
}
}
componentDidMount
(
)
{
if
(
this
.
props
.
rows
.
length
)
{
this
.
sendImpressionStatsOrAddListener
(
)
;
}
}
componentDidUpdate
(
prevProps
)
{
const
props
=
this
.
props
;
if
(
props
.
rows
.
length
&
&
props
.
rows
!
=
=
prevProps
.
rows
)
{
this
.
sendImpressionStatsOrAddListener
(
)
;
}
}
render
(
)
{
var
_props
=
this
.
props
;
const
id
=
_props
.
id
eventSource
=
_props
.
eventSource
title
=
_props
.
title
icon
=
_props
.
icon
rows
=
_props
.
rows
infoOption
=
_props
.
infoOption
emptyState
=
_props
.
emptyState
dispatch
=
_props
.
dispatch
maxRows
=
_props
.
maxRows
contextMenuOptions
=
_props
.
contextMenuOptions
intl
=
_props
.
intl
;
const
maxCards
=
3
*
maxRows
;
const
initialized
=
rows
&
&
rows
.
length
>
0
;
const
shouldShowTopics
=
id
=
=
=
"
TopStories
"
&
&
this
.
props
.
topics
&
&
this
.
props
.
read_more_endpoint
;
const
infoOptionIconA11yAttrs
=
{
"
aria
-
haspopup
"
:
"
true
"
"
aria
-
controls
"
:
"
info
-
option
"
"
aria
-
expanded
"
:
this
.
state
.
infoActive
?
"
true
"
:
"
false
"
"
role
"
:
"
note
"
"
tabIndex
"
:
0
}
;
const
sectionInfoTitle
=
intl
.
formatMessage
(
{
id
:
"
section_info_option
"
}
)
;
return
React
.
createElement
(
"
section
"
null
React
.
createElement
(
"
div
"
{
className
:
"
section
-
top
-
bar
"
}
React
.
createElement
(
"
h3
"
{
className
:
"
section
-
title
"
}
icon
&
&
icon
.
startsWith
(
"
moz
-
extension
:
/
/
"
)
?
React
.
createElement
(
"
span
"
{
className
:
"
icon
icon
-
small
-
spacer
"
style
:
{
"
background
-
image
"
:
url
(
'
{
icon
}
'
)
}
}
)
:
React
.
createElement
(
"
span
"
{
className
:
icon
icon
-
small
-
spacer
icon
-
{
icon
|
|
"
webextension
"
}
}
)
this
.
getFormattedMessage
(
title
)
)
infoOption
&
&
React
.
createElement
(
"
span
"
{
className
:
"
section
-
info
-
option
"
onBlur
:
this
.
onInfoLeave
onFocus
:
this
.
onInfoEnter
onMouseOut
:
this
.
onInfoLeave
onMouseOver
:
this
.
onInfoEnter
}
React
.
createElement
(
"
img
"
_extends
(
{
className
:
"
info
-
option
-
icon
"
title
:
sectionInfoTitle
}
infoOptionIconA11yAttrs
)
)
React
.
createElement
(
"
div
"
{
className
:
"
info
-
option
"
}
infoOption
.
header
&
&
React
.
createElement
(
"
div
"
{
className
:
"
info
-
option
-
header
"
role
:
"
heading
"
}
this
.
getFormattedMessage
(
infoOption
.
header
)
)
infoOption
.
body
&
&
React
.
createElement
(
"
p
"
{
className
:
"
info
-
option
-
body
"
}
this
.
getFormattedMessage
(
infoOption
.
body
)
)
infoOption
.
link
&
&
React
.
createElement
(
"
a
"
{
href
:
infoOption
.
link
.
href
target
:
"
_blank
"
rel
:
"
noopener
noreferrer
"
className
:
"
info
-
option
-
link
"
}
this
.
getFormattedMessage
(
infoOption
.
link
.
title
|
|
infoOption
.
link
)
)
)
)
)
React
.
createElement
(
"
ul
"
{
className
:
"
section
-
list
"
style
:
{
padding
:
0
}
}
rows
.
slice
(
0
maxCards
)
.
map
(
(
link
index
)
=
>
link
&
&
React
.
createElement
(
Card
{
index
:
index
dispatch
:
dispatch
link
:
link
contextMenuOptions
:
contextMenuOptions
eventSource
:
eventSource
}
)
)
)
!
initialized
&
&
React
.
createElement
(
"
div
"
{
className
:
"
section
-
empty
-
state
"
}
React
.
createElement
(
"
div
"
{
className
:
"
empty
-
state
"
}
React
.
createElement
(
"
img
"
{
className
:
empty
-
state
-
icon
icon
icon
-
{
emptyState
.
icon
}
}
)
React
.
createElement
(
"
p
"
{
className
:
"
empty
-
state
-
message
"
}
this
.
getFormattedMessage
(
emptyState
.
message
)
)
)
)
shouldShowTopics
&
&
React
.
createElement
(
Topics
{
topics
:
this
.
props
.
topics
read_more_endpoint
:
this
.
props
.
read_more_endpoint
}
)
)
;
}
}
Section
.
defaultProps
=
{
document
:
global
.
document
}
;
const
SectionIntl
=
injectIntl
(
Section
)
;
class
Sections
extends
React
.
Component
{
render
(
)
{
const
sections
=
this
.
props
.
Sections
;
return
React
.
createElement
(
"
div
"
{
className
:
"
sections
-
list
"
}
sections
.
map
(
section
=
>
React
.
createElement
(
SectionIntl
_extends
(
{
key
:
section
.
id
}
section
{
dispatch
:
this
.
props
.
dispatch
}
)
)
)
)
;
}
}
module
.
exports
=
connect
(
state
=
>
(
{
Sections
:
state
.
Sections
}
)
)
(
Sections
)
;
module
.
exports
.
_unconnected
=
Sections
;
module
.
exports
.
SectionIntl
=
SectionIntl
;
module
.
exports
.
_unconnectedSection
=
Section
;
}
.
call
(
exports
__webpack_require__
(
6
)
)
)
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
React
=
__webpack_require__
(
0
)
;
var
_require
=
__webpack_require__
(
3
)
;
const
connect
=
_require
.
connect
;
var
_require2
=
__webpack_require__
(
2
)
;
const
FormattedMessage
=
_require2
.
FormattedMessage
injectIntl
=
_require2
.
injectIntl
;
const
LinkMenu
=
__webpack_require__
(
4
)
;
var
_require3
=
__webpack_require__
(
1
)
;
const
ac
=
_require3
.
actionCreators
at
=
_require3
.
actionTypes
;
var
_require4
=
__webpack_require__
(
5
)
;
const
perfSvc
=
_require4
.
perfService
;
const
TOP_SITES_SOURCE
=
"
TOP_SITES
"
;
const
TOP_SITES_CONTEXT_MENU_OPTIONS
=
[
"
CheckPinTopSite
"
"
Separator
"
"
OpenInNewWindow
"
"
OpenInPrivateWindow
"
"
Separator
"
"
BlockUrl
"
"
DeleteUrl
"
]
;
class
TopSite
extends
React
.
Component
{
constructor
(
props
)
{
super
(
props
)
;
this
.
state
=
{
showContextMenu
:
false
activeTile
:
null
}
;
this
.
onLinkClick
=
this
.
onLinkClick
.
bind
(
this
)
;
this
.
onMenuButtonClick
=
this
.
onMenuButtonClick
.
bind
(
this
)
;
this
.
onMenuUpdate
=
this
.
onMenuUpdate
.
bind
(
this
)
;
this
.
onDismissButtonClick
=
this
.
onDismissButtonClick
.
bind
(
this
)
;
this
.
onPinButtonClick
=
this
.
onPinButtonClick
.
bind
(
this
)
;
}
toggleContextMenu
(
event
index
)
{
this
.
setState
(
{
activeTile
:
index
showContextMenu
:
true
}
)
;
}
userEvent
(
event
)
{
this
.
props
.
dispatch
(
ac
.
UserEvent
(
{
event
source
:
TOP_SITES_SOURCE
action_position
:
this
.
props
.
index
}
)
)
;
}
onLinkClick
(
ev
)
{
if
(
this
.
props
.
editMode
)
{
ev
.
preventDefault
(
)
;
return
;
}
this
.
userEvent
(
"
CLICK
"
)
;
}
onMenuButtonClick
(
event
)
{
event
.
preventDefault
(
)
;
this
.
toggleContextMenu
(
event
this
.
props
.
index
)
;
}
onMenuUpdate
(
showContextMenu
)
{
this
.
setState
(
{
showContextMenu
}
)
;
}
onDismissButtonClick
(
)
{
const
link
=
this
.
props
.
link
;
if
(
link
.
isPinned
)
{
this
.
props
.
dispatch
(
ac
.
SendToMain
(
{
type
:
at
.
TOP_SITES_UNPIN
data
:
{
site
:
{
url
:
link
.
url
}
}
}
)
)
;
}
this
.
props
.
dispatch
(
ac
.
SendToMain
(
{
type
:
at
.
BLOCK_URL
data
:
link
.
url
}
)
)
;
this
.
userEvent
(
"
BLOCK
"
)
;
}
onPinButtonClick
(
)
{
var
_props
=
this
.
props
;
const
link
=
_props
.
link
index
=
_props
.
index
;
if
(
link
.
isPinned
)
{
this
.
props
.
dispatch
(
ac
.
SendToMain
(
{
type
:
at
.
TOP_SITES_UNPIN
data
:
{
site
:
{
url
:
link
.
url
}
}
}
)
)
;
this
.
userEvent
(
"
UNPIN
"
)
;
}
else
{
this
.
props
.
dispatch
(
ac
.
SendToMain
(
{
type
:
at
.
TOP_SITES_PIN
data
:
{
site
:
{
url
:
link
.
url
}
index
}
}
)
)
;
this
.
userEvent
(
"
PIN
"
)
;
}
}
render
(
)
{
var
_props2
=
this
.
props
;
const
link
=
_props2
.
link
index
=
_props2
.
index
dispatch
=
_props2
.
dispatch
editMode
=
_props2
.
editMode
;
const
isContextMenuOpen
=
this
.
state
.
showContextMenu
&
&
this
.
state
.
activeTile
=
=
=
index
;
const
title
=
link
.
hostname
;
const
topSiteOuterClassName
=
top
-
site
-
outer
{
isContextMenuOpen
?
"
active
"
:
"
"
}
;
const
tippyTopIcon
=
link
.
tippyTopIcon
;
let
imageClassName
;
let
imageStyle
;
if
(
tippyTopIcon
)
{
imageClassName
=
"
tippy
-
top
-
icon
"
;
imageStyle
=
{
backgroundColor
:
link
.
backgroundColor
backgroundImage
:
url
(
{
tippyTopIcon
}
)
}
;
}
else
{
imageClassName
=
screenshot
{
link
.
screenshot
?
"
active
"
:
"
"
}
;
imageStyle
=
{
backgroundImage
:
link
.
screenshot
?
url
(
{
link
.
screenshot
}
)
:
"
none
"
}
;
}
return
React
.
createElement
(
"
li
"
{
className
:
topSiteOuterClassName
key
:
link
.
guid
|
|
link
.
url
}
React
.
createElement
(
"
a
"
{
href
:
link
.
url
onClick
:
this
.
onLinkClick
}
React
.
createElement
(
"
div
"
{
className
:
"
tile
"
"
aria
-
hidden
"
:
true
}
React
.
createElement
(
"
span
"
{
className
:
"
letter
-
fallback
"
}
title
[
0
]
)
React
.
createElement
(
"
div
"
{
className
:
imageClassName
style
:
imageStyle
}
)
)
React
.
createElement
(
"
div
"
{
className
:
title
{
link
.
isPinned
?
"
pinned
"
:
"
"
}
}
link
.
isPinned
&
&
React
.
createElement
(
"
div
"
{
className
:
"
icon
icon
-
pin
-
small
"
}
)
React
.
createElement
(
"
span
"
{
dir
:
"
auto
"
}
title
)
)
)
!
editMode
&
&
React
.
createElement
(
"
div
"
null
React
.
createElement
(
"
button
"
{
className
:
"
context
-
menu
-
button
"
onClick
:
this
.
onMenuButtonClick
}
React
.
createElement
(
"
span
"
{
className
:
"
sr
-
only
"
}
Open
context
menu
for
{
title
}
)
)
React
.
createElement
(
LinkMenu
{
dispatch
:
dispatch
index
:
index
onUpdate
:
this
.
onMenuUpdate
options
:
TOP_SITES_CONTEXT_MENU_OPTIONS
site
:
link
source
:
TOP_SITES_SOURCE
visible
:
isContextMenuOpen
}
)
)
editMode
&
&
React
.
createElement
(
"
div
"
{
className
:
"
edit
-
menu
"
}
React
.
createElement
(
"
button
"
{
className
:
icon
icon
-
{
link
.
isPinned
?
"
unpin
"
:
"
pin
"
}
title
:
this
.
props
.
intl
.
formatMessage
(
{
id
:
edit_topsites_
{
link
.
isPinned
?
"
unpin
"
:
"
pin
"
}
_button
}
)
onClick
:
this
.
onPinButtonClick
}
)
React
.
createElement
(
"
button
"
{
className
:
"
icon
icon
-
dismiss
"
title
:
this
.
props
.
intl
.
formatMessage
(
{
id
:
"
edit_topsites_dismiss_button
"
}
)
onClick
:
this
.
onDismissButtonClick
}
)
)
)
;
}
}
TopSite
.
defaultProps
=
{
editMode
:
false
}
;
class
TopSitesPerfTimer
extends
React
.
Component
{
constructor
(
props
)
{
super
(
props
)
;
this
.
perfSvc
=
this
.
props
.
perfSvc
|
|
perfSvc
;
this
.
_sendPaintedEvent
=
this
.
_sendPaintedEvent
.
bind
(
this
)
;
this
.
_timestampHandled
=
false
;
}
componentDidMount
(
)
{
this
.
_maybeSendPaintedEvent
(
)
;
}
componentDidUpdate
(
)
{
this
.
_maybeSendPaintedEvent
(
)
;
}
_afterFramePaint
(
callback
)
{
requestAnimationFrame
(
(
)
=
>
setTimeout
(
callback
0
)
)
;
}
_maybeSendPaintedEvent
(
)
{
if
(
!
this
.
props
.
TopSites
.
initialized
)
{
return
;
}
if
(
this
.
_timestampHandled
)
{
return
;
}
this
.
_timestampHandled
=
true
;
this
.
_afterFramePaint
(
this
.
_sendPaintedEvent
)
;
}
_sendPaintedEvent
(
)
{
this
.
perfSvc
.
mark
(
"
topsites_first_painted_ts
"
)
;
try
{
let
topsites_first_painted_ts
=
this
.
perfSvc
.
getMostRecentAbsMarkStartByName
(
"
topsites_first_painted_ts
"
)
;
this
.
props
.
dispatch
(
ac
.
SendToMain
(
{
type
:
at
.
SAVE_SESSION_PERF_DATA
data
:
{
topsites_first_painted_ts
}
}
)
)
;
}
catch
(
ex
)
{
}
}
render
(
)
{
return
React
.
createElement
(
TopSites
this
.
props
)
;
}
}
const
TopSites
=
props
=
>
React
.
createElement
(
"
section
"
{
className
:
"
top
-
sites
"
}
React
.
createElement
(
"
h3
"
{
className
:
"
section
-
title
"
}
React
.
createElement
(
"
span
"
{
className
:
icon
icon
-
small
-
spacer
icon
-
topsites
}
)
React
.
createElement
(
FormattedMessage
{
id
:
"
header_top_sites
"
}
)
)
React
.
createElement
(
"
ul
"
{
className
:
"
top
-
sites
-
list
"
}
props
.
TopSites
.
rows
.
map
(
(
link
index
)
=
>
link
&
&
React
.
createElement
(
TopSite
{
key
:
link
.
guid
|
|
link
.
url
dispatch
:
props
.
dispatch
link
:
link
index
:
index
intl
:
props
.
intl
}
)
)
)
React
.
createElement
(
TopSitesEditIntl
props
)
)
;
class
TopSitesEdit
extends
React
.
Component
{
constructor
(
props
)
{
super
(
props
)
;
this
.
state
=
{
showEditModal
:
false
}
;
this
.
onEditButtonClick
=
this
.
onEditButtonClick
.
bind
(
this
)
;
}
onEditButtonClick
(
)
{
this
.
setState
(
{
showEditModal
:
!
this
.
state
.
showEditModal
}
)
;
const
event
=
this
.
state
.
showEditModal
?
"
TOP_SITES_EDIT_OPEN
"
:
"
TOP_SITES_EDIT_CLOSE
"
;
this
.
props
.
dispatch
(
ac
.
UserEvent
(
{
source
:
TOP_SITES_SOURCE
event
}
)
)
;
}
render
(
)
{
return
React
.
createElement
(
"
div
"
{
className
:
"
edit
-
topsites
-
wrapper
"
}
React
.
createElement
(
"
div
"
{
className
:
"
edit
-
topsites
-
button
"
}
React
.
createElement
(
"
button
"
{
className
:
"
edit
"
title
:
this
.
props
.
intl
.
formatMessage
(
{
id
:
"
edit_topsites_button_label
"
}
)
onClick
:
this
.
onEditButtonClick
}
React
.
createElement
(
FormattedMessage
{
id
:
"
edit_topsites_button_text
"
}
)
)
)
this
.
state
.
showEditModal
&
&
React
.
createElement
(
"
div
"
{
className
:
"
edit
-
topsites
"
}
React
.
createElement
(
"
div
"
{
className
:
"
modal
-
overlay
"
}
)
React
.
createElement
(
"
div
"
{
className
:
"
modal
"
}
React
.
createElement
(
"
section
"
{
className
:
"
edit
-
topsites
-
inner
-
wrapper
"
}
React
.
createElement
(
"
h3
"
{
className
:
"
section
-
title
"
}
React
.
createElement
(
"
span
"
{
className
:
icon
icon
-
small
-
spacer
icon
-
topsites
}
)
React
.
createElement
(
FormattedMessage
{
id
:
"
header_top_sites
"
}
)
)
React
.
createElement
(
"
ul
"
{
className
:
"
top
-
sites
-
list
"
}
this
.
props
.
TopSites
.
rows
.
map
(
(
link
index
)
=
>
link
&
&
React
.
createElement
(
TopSite
{
key
:
link
.
guid
|
|
link
.
url
dispatch
:
this
.
props
.
dispatch
link
:
link
index
:
index
intl
:
this
.
props
.
intl
editMode
:
true
}
)
)
)
)
React
.
createElement
(
"
section
"
{
className
:
"
actions
"
}
React
.
createElement
(
"
button
"
{
className
:
"
done
"
onClick
:
this
.
onEditButtonClick
}
React
.
createElement
(
FormattedMessage
{
id
:
"
edit_topsites_done_button
"
}
)
)
)
)
)
)
;
}
}
const
TopSitesEditIntl
=
injectIntl
(
TopSitesEdit
)
;
module
.
exports
=
connect
(
state
=
>
(
{
TopSites
:
state
.
TopSites
}
)
)
(
TopSitesPerfTimer
)
;
module
.
exports
.
_unconnected
=
TopSitesPerfTimer
;
module
.
exports
.
TopSite
=
TopSite
;
module
.
exports
.
TopSites
=
TopSites
;
module
.
exports
.
TopSitesEdit
=
TopSitesEdit
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
React
=
__webpack_require__
(
0
)
;
var
_require
=
__webpack_require__
(
2
)
;
const
FormattedMessage
=
_require
.
FormattedMessage
;
class
Topic
extends
React
.
Component
{
render
(
)
{
var
_props
=
this
.
props
;
const
url
=
_props
.
url
name
=
_props
.
name
;
return
React
.
createElement
(
"
li
"
null
React
.
createElement
(
"
a
"
{
key
:
name
className
:
"
topic
-
link
"
href
:
url
}
name
)
)
;
}
}
class
Topics
extends
React
.
Component
{
render
(
)
{
var
_props2
=
this
.
props
;
const
topics
=
_props2
.
topics
read_more_endpoint
=
_props2
.
read_more_endpoint
;
return
React
.
createElement
(
"
div
"
{
className
:
"
topic
"
}
React
.
createElement
(
"
span
"
null
React
.
createElement
(
FormattedMessage
{
id
:
"
pocket_read_more
"
}
)
)
React
.
createElement
(
"
ul
"
null
topics
.
map
(
t
=
>
React
.
createElement
(
Topic
{
key
:
t
.
name
url
:
t
.
url
name
:
t
.
name
}
)
)
)
React
.
createElement
(
"
a
"
{
className
:
"
topic
-
read
-
more
"
href
:
read_more_endpoint
}
React
.
createElement
(
FormattedMessage
{
id
:
"
pocket_read_even_more
"
}
)
React
.
createElement
(
"
span
"
{
className
:
"
topic
-
read
-
more
-
logo
"
}
)
)
)
;
}
}
module
.
exports
=
Topics
;
module
.
exports
.
_unconnected
=
Topics
;
module
.
exports
.
Topic
=
Topic
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
var
_require
=
__webpack_require__
(
1
)
;
const
at
=
_require
.
actionTypes
ac
=
_require
.
actionCreators
;
module
.
exports
=
{
Separator
:
(
)
=
>
(
{
type
:
"
separator
"
}
)
RemoveBookmark
:
site
=
>
(
{
id
:
"
menu_action_remove_bookmark
"
icon
:
"
bookmark
-
remove
"
action
:
ac
.
SendToMain
(
{
type
:
at
.
DELETE_BOOKMARK_BY_ID
data
:
site
.
bookmarkGuid
}
)
userEvent
:
"
BOOKMARK_DELETE
"
}
)
AddBookmark
:
site
=
>
(
{
id
:
"
menu_action_bookmark
"
icon
:
"
bookmark
"
action
:
ac
.
SendToMain
(
{
type
:
at
.
BOOKMARK_URL
data
:
{
url
:
site
.
url
title
:
site
.
title
}
}
)
userEvent
:
"
BOOKMARK_ADD
"
}
)
OpenInNewWindow
:
site
=
>
(
{
id
:
"
menu_action_open_new_window
"
icon
:
"
new
-
window
"
action
:
ac
.
SendToMain
(
{
type
:
at
.
OPEN_NEW_WINDOW
data
:
{
url
:
site
.
url
referrer
:
site
.
referrer
}
}
)
userEvent
:
"
OPEN_NEW_WINDOW
"
}
)
OpenInPrivateWindow
:
site
=
>
(
{
id
:
"
menu_action_open_private_window
"
icon
:
"
new
-
window
-
private
"
action
:
ac
.
SendToMain
(
{
type
:
at
.
OPEN_PRIVATE_WINDOW
data
:
{
url
:
site
.
url
referrer
:
site
.
referrer
}
}
)
userEvent
:
"
OPEN_PRIVATE_WINDOW
"
}
)
BlockUrl
:
(
site
index
eventSource
)
=
>
(
{
id
:
"
menu_action_dismiss
"
icon
:
"
dismiss
"
action
:
ac
.
SendToMain
(
{
type
:
at
.
BLOCK_URL
data
:
site
.
url
}
)
impression
:
ac
.
ImpressionStats
(
{
source
:
eventSource
block
:
0
incognito
:
true
tiles
:
[
{
id
:
site
.
guid
pos
:
index
}
]
}
)
userEvent
:
"
BLOCK
"
}
)
DeleteUrl
:
site
=
>
(
{
id
:
"
menu_action_delete
"
icon
:
"
delete
"
action
:
{
type
:
at
.
DIALOG_OPEN
data
:
{
onConfirm
:
[
ac
.
SendToMain
(
{
type
:
at
.
DELETE_HISTORY_URL
data
:
site
.
url
}
)
ac
.
UserEvent
(
{
event
:
"
DELETE
"
}
)
]
body_string_id
:
[
"
confirm_history_delete_p1
"
"
confirm_history_delete_notice_p2
"
]
confirm_button_string_id
:
"
menu_action_delete
"
}
}
userEvent
:
"
DIALOG_OPEN
"
}
)
PinTopSite
:
(
site
index
)
=
>
(
{
id
:
"
menu_action_pin
"
icon
:
"
pin
"
action
:
ac
.
SendToMain
(
{
type
:
at
.
TOP_SITES_PIN
data
:
{
site
:
{
url
:
site
.
url
}
index
}
}
)
userEvent
:
"
PIN
"
}
)
UnpinTopSite
:
site
=
>
(
{
id
:
"
menu_action_unpin
"
icon
:
"
unpin
"
action
:
ac
.
SendToMain
(
{
type
:
at
.
TOP_SITES_UNPIN
data
:
{
site
:
{
url
:
site
.
url
}
}
}
)
userEvent
:
"
UNPIN
"
}
)
SaveToPocket
:
(
site
index
eventSource
)
=
>
(
{
id
:
"
menu_action_save_to_pocket
"
icon
:
"
pocket
"
action
:
ac
.
SendToMain
(
{
type
:
at
.
SAVE_TO_POCKET
data
:
{
site
:
{
url
:
site
.
url
title
:
site
.
title
}
}
}
)
impression
:
ac
.
ImpressionStats
(
{
source
:
eventSource
pocket
:
0
incognito
:
true
tiles
:
[
{
id
:
site
.
guid
pos
:
index
}
]
}
)
userEvent
:
"
SAVE_TO_POCKET
"
}
)
}
;
module
.
exports
.
CheckBookmark
=
site
=
>
site
.
bookmarkGuid
?
module
.
exports
.
RemoveBookmark
(
site
)
:
module
.
exports
.
AddBookmark
(
site
)
;
module
.
exports
.
CheckPinTopSite
=
(
site
index
)
=
>
site
.
isPinned
?
module
.
exports
.
UnpinTopSite
(
site
)
:
module
.
exports
.
PinTopSite
(
site
index
)
;
}
)
(
function
(
module
exports
)
{
module
.
exports
=
Redux
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
React
=
__webpack_require__
(
0
)
;
const
ReactDOM
=
__webpack_require__
(
12
)
;
const
Base
=
__webpack_require__
(
7
)
;
var
_require
=
__webpack_require__
(
3
)
;
const
Provider
=
_require
.
Provider
;
const
initStore
=
__webpack_require__
(
9
)
;
var
_require2
=
__webpack_require__
(
11
)
;
const
reducers
=
_require2
.
reducers
;
const
DetectUserSessionStart
=
__webpack_require__
(
8
)
;
var
_require3
=
__webpack_require__
(
10
)
;
const
addSnippetsSubscriber
=
_require3
.
addSnippetsSubscriber
;
new
DetectUserSessionStart
(
)
.
sendEventOrAddListener
(
)
;
const
store
=
initStore
(
reducers
)
;
ReactDOM
.
render
(
React
.
createElement
(
Provider
{
store
:
store
}
React
.
createElement
(
Base
null
)
)
document
.
getElementById
(
"
root
"
)
)
;
addSnippetsSubscriber
(
store
)
;
}
)
]
)
;
