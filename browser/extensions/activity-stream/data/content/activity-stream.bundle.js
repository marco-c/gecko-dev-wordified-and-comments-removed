(
function
(
modules
)
{
var
installedModules
=
{
}
;
function
__webpack_require__
(
moduleId
)
{
if
(
installedModules
[
moduleId
]
)
return
installedModules
[
moduleId
]
.
exports
;
var
module
=
installedModules
[
moduleId
]
=
{
i
:
moduleId
l
:
false
exports
:
{
}
}
;
modules
[
moduleId
]
.
call
(
module
.
exports
module
module
.
exports
__webpack_require__
)
;
module
.
l
=
true
;
return
module
.
exports
;
}
__webpack_require__
.
m
=
modules
;
__webpack_require__
.
c
=
installedModules
;
__webpack_require__
.
i
=
function
(
value
)
{
return
value
;
}
;
__webpack_require__
.
d
=
function
(
exports
name
getter
)
{
if
(
!
__webpack_require__
.
o
(
exports
name
)
)
{
Object
.
defineProperty
(
exports
name
{
configurable
:
false
enumerable
:
true
get
:
getter
}
)
;
}
}
;
__webpack_require__
.
n
=
function
(
module
)
{
var
getter
=
module
&
&
module
.
__esModule
?
function
getDefault
(
)
{
return
module
[
'
default
'
]
;
}
:
function
getModuleExports
(
)
{
return
module
;
}
;
__webpack_require__
.
d
(
getter
'
a
'
getter
)
;
return
getter
;
}
;
__webpack_require__
.
o
=
function
(
object
property
)
{
return
Object
.
prototype
.
hasOwnProperty
.
call
(
object
property
)
;
}
;
__webpack_require__
.
p
=
"
"
;
return
__webpack_require__
(
__webpack_require__
.
s
=
18
)
;
}
)
(
[
(
function
(
module
exports
)
{
module
.
exports
=
React
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
var
MAIN_MESSAGE_TYPE
=
"
ActivityStream
:
Main
"
;
var
CONTENT_MESSAGE_TYPE
=
"
ActivityStream
:
Content
"
;
var
UI_CODE
=
1
;
var
BACKGROUND_PROCESS
=
2
;
const
globalImportContext
=
typeof
Window
=
=
=
"
undefined
"
?
BACKGROUND_PROCESS
:
UI_CODE
;
const
actionTypes
=
[
"
BLOCK_URL
"
"
BOOKMARK_URL
"
"
DELETE_BOOKMARK_BY_ID
"
"
DELETE_HISTORY_URL
"
"
INIT
"
"
LOCALE_UPDATED
"
"
NEW_TAB_INITIAL_STATE
"
"
NEW_TAB_LOAD
"
"
NEW_TAB_UNLOAD
"
"
NEW_TAB_VISIBLE
"
"
OPEN_NEW_WINDOW
"
"
OPEN_PRIVATE_WINDOW
"
"
PLACES_BOOKMARK_ADDED
"
"
PLACES_BOOKMARK_CHANGED
"
"
PLACES_BOOKMARK_REMOVED
"
"
PLACES_HISTORY_CLEARED
"
"
PLACES_LINK_BLOCKED
"
"
PLACES_LINK_DELETED
"
"
PREFS_INITIAL_VALUES
"
"
PREF_CHANGED
"
"
SCREENSHOT_UPDATED
"
"
SET_PREF
"
"
TELEMETRY_PERFORMANCE_EVENT
"
"
TELEMETRY_UNDESIRED_EVENT
"
"
TELEMETRY_USER_EVENT
"
"
TOP_SITES_UPDATED
"
"
UNINIT
"
]
.
reduce
(
(
obj
type
)
=
>
{
obj
[
type
]
=
type
;
return
obj
;
}
{
}
)
;
function
_RouteMessage
(
action
options
)
{
const
meta
=
action
.
meta
?
Object
.
assign
(
{
}
action
.
meta
)
:
{
}
;
if
(
!
options
|
|
!
options
.
from
|
|
!
options
.
to
)
{
throw
new
Error
(
"
Routed
Messages
must
have
options
as
the
second
parameter
and
must
at
least
include
a
.
from
and
.
to
property
.
"
)
;
}
[
"
from
"
"
to
"
"
toTarget
"
"
fromTarget
"
"
skipOrigin
"
]
.
forEach
(
o
=
>
{
if
(
typeof
options
[
o
]
!
=
=
"
undefined
"
)
{
meta
[
o
]
=
options
[
o
]
;
}
else
if
(
meta
[
o
]
)
{
delete
meta
[
o
]
;
}
}
)
;
return
Object
.
assign
(
{
}
action
{
meta
}
)
;
}
function
SendToMain
(
action
fromTarget
)
{
return
_RouteMessage
(
action
{
from
:
CONTENT_MESSAGE_TYPE
to
:
MAIN_MESSAGE_TYPE
fromTarget
}
)
;
}
function
BroadcastToContent
(
action
)
{
return
_RouteMessage
(
action
{
from
:
MAIN_MESSAGE_TYPE
to
:
CONTENT_MESSAGE_TYPE
}
)
;
}
function
SendToContent
(
action
target
)
{
if
(
!
target
)
{
throw
new
Error
(
"
You
must
provide
a
target
ID
as
the
second
parameter
of
SendToContent
.
If
you
want
to
send
to
all
content
processes
use
BroadcastToContent
"
)
;
}
return
_RouteMessage
(
action
{
from
:
MAIN_MESSAGE_TYPE
to
:
CONTENT_MESSAGE_TYPE
toTarget
:
target
}
)
;
}
function
UserEvent
(
data
)
{
return
SendToMain
(
{
type
:
actionTypes
.
TELEMETRY_USER_EVENT
data
}
)
;
}
function
UndesiredEvent
(
data
)
{
let
importContext
=
arguments
.
length
>
1
&
&
arguments
[
1
]
!
=
=
undefined
?
arguments
[
1
]
:
globalImportContext
;
const
action
=
{
type
:
actionTypes
.
TELEMETRY_UNDESIRED_EVENT
data
}
;
return
importContext
=
=
=
UI_CODE
?
SendToMain
(
action
)
:
action
;
}
function
PerfEvent
(
data
)
{
let
importContext
=
arguments
.
length
>
1
&
&
arguments
[
1
]
!
=
=
undefined
?
arguments
[
1
]
:
globalImportContext
;
const
action
=
{
type
:
actionTypes
.
TELEMETRY_PERFORMANCE_EVENT
data
}
;
return
importContext
=
=
=
UI_CODE
?
SendToMain
(
action
)
:
action
;
}
function
SetPref
(
name
value
)
{
let
importContext
=
arguments
.
length
>
2
&
&
arguments
[
2
]
!
=
=
undefined
?
arguments
[
2
]
:
globalImportContext
;
const
action
=
{
type
:
actionTypes
.
SET_PREF
data
:
{
name
value
}
}
;
return
importContext
=
=
=
UI_CODE
?
SendToMain
(
action
)
:
action
;
}
var
actionCreators
=
{
BroadcastToContent
UserEvent
UndesiredEvent
PerfEvent
SendToContent
SendToMain
SetPref
}
;
var
actionUtils
=
{
isSendToMain
(
action
)
{
if
(
!
action
.
meta
)
{
return
false
;
}
return
action
.
meta
.
to
=
=
=
MAIN_MESSAGE_TYPE
&
&
action
.
meta
.
from
=
=
=
CONTENT_MESSAGE_TYPE
;
}
isBroadcastToContent
(
action
)
{
if
(
!
action
.
meta
)
{
return
false
;
}
if
(
action
.
meta
.
to
=
=
=
CONTENT_MESSAGE_TYPE
&
&
!
action
.
meta
.
toTarget
)
{
return
true
;
}
return
false
;
}
isSendToContent
(
action
)
{
if
(
!
action
.
meta
)
{
return
false
;
}
if
(
action
.
meta
.
to
=
=
=
CONTENT_MESSAGE_TYPE
&
&
action
.
meta
.
toTarget
)
{
return
true
;
}
return
false
;
}
getPortIdOfSender
(
action
)
{
return
action
.
meta
&
&
action
.
meta
.
fromTarget
|
|
null
;
}
_RouteMessage
}
;
module
.
exports
=
{
actionTypes
actionCreators
actionUtils
globalImportContext
UI_CODE
BACKGROUND_PROCESS
MAIN_MESSAGE_TYPE
CONTENT_MESSAGE_TYPE
}
;
}
)
(
function
(
module
exports
)
{
module
.
exports
=
ReactRedux
;
}
)
(
function
(
module
exports
)
{
module
.
exports
=
ReactIntl
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
React
=
__webpack_require__
(
0
)
;
var
_require
=
__webpack_require__
(
2
)
;
const
connect
=
_require
.
connect
;
var
_require2
=
__webpack_require__
(
3
)
;
const
addLocaleData
=
_require2
.
addLocaleData
IntlProvider
=
_require2
.
IntlProvider
;
const
TopSites
=
__webpack_require__
(
13
)
;
const
Search
=
__webpack_require__
(
12
)
;
const
PreferencesPane
=
__webpack_require__
(
11
)
;
const
RTL_LIST
=
[
"
ar
"
"
he
"
"
fa
"
"
ur
"
]
;
function
addLocaleDataForReactIntl
(
_ref
)
{
let
locale
=
_ref
.
locale
;
addLocaleData
(
[
{
locale
parentLocale
:
"
en
"
}
]
)
;
document
.
documentElement
.
lang
=
locale
;
document
.
documentElement
.
dir
=
RTL_LIST
.
indexOf
(
locale
.
split
(
"
-
"
)
[
0
]
)
>
=
0
?
"
rtl
"
:
"
ltr
"
;
}
class
Base
extends
React
.
Component
{
componentDidMount
(
)
{
addEventListener
(
"
visibilitychange
"
(
)
=
>
this
.
updateTitle
(
this
.
props
.
App
)
{
once
:
true
}
)
;
}
componentWillUpdate
(
_ref2
)
{
let
App
=
_ref2
.
App
;
if
(
App
.
locale
!
=
=
this
.
props
.
App
.
locale
)
{
addLocaleDataForReactIntl
(
App
)
;
this
.
updateTitle
(
App
)
;
}
}
updateTitle
(
_ref3
)
{
let
strings
=
_ref3
.
strings
;
document
.
title
=
strings
.
newtab_page_title
;
}
render
(
)
{
const
props
=
this
.
props
;
var
_props
App
=
props
.
App
;
const
locale
=
_props
App
.
locale
strings
=
_props
App
.
strings
initialized
=
_props
App
.
initialized
;
const
prefs
=
props
.
Prefs
.
values
;
if
(
!
initialized
)
{
return
null
;
}
return
React
.
createElement
(
IntlProvider
{
key
:
locale
locale
:
locale
messages
:
strings
}
React
.
createElement
(
"
div
"
{
className
:
"
outer
-
wrapper
"
}
React
.
createElement
(
"
main
"
null
prefs
.
showSearch
&
&
React
.
createElement
(
Search
null
)
prefs
.
showTopSites
&
&
React
.
createElement
(
TopSites
null
)
)
React
.
createElement
(
PreferencesPane
null
)
)
)
;
}
}
module
.
exports
=
connect
(
state
=
>
(
{
App
:
state
.
App
Prefs
:
state
.
Prefs
}
)
)
(
Base
)
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
var
_require
=
__webpack_require__
(
1
)
;
const
at
=
_require
.
actionTypes
;
var
_require2
=
__webpack_require__
(
15
)
;
const
perfSvc
=
_require2
.
perfService
;
const
VISIBLE
=
"
visible
"
;
const
VISIBILITY_CHANGE_EVENT
=
"
visibilitychange
"
;
module
.
exports
=
class
DetectUserSessionStart
{
constructor
(
)
{
let
options
=
arguments
.
length
>
0
&
&
arguments
[
0
]
!
=
=
undefined
?
arguments
[
0
]
:
{
}
;
this
.
sendAsyncMessage
=
options
.
sendAsyncMessage
|
|
window
.
sendAsyncMessage
;
this
.
document
=
options
.
document
|
|
document
;
this
.
_perfService
=
options
.
perfService
|
|
perfSvc
;
this
.
_onVisibilityChange
=
this
.
_onVisibilityChange
.
bind
(
this
)
;
}
sendEventOrAddListener
(
)
{
if
(
this
.
document
.
visibilityState
=
=
=
VISIBLE
)
{
this
.
_sendEvent
(
)
;
}
else
{
this
.
document
.
addEventListener
(
VISIBILITY_CHANGE_EVENT
this
.
_onVisibilityChange
)
;
}
}
_sendEvent
(
)
{
this
.
_perfService
.
mark
(
"
visibility
-
change
-
event
"
)
;
let
absVisChangeTime
=
this
.
_perfService
.
getMostRecentAbsMarkStartByName
(
"
visibility
-
change
-
event
"
)
;
this
.
sendAsyncMessage
(
"
ActivityStream
:
ContentToMain
"
{
type
:
at
.
NEW_TAB_VISIBLE
data
:
{
absVisibilityChangeTime
:
absVisChangeTime
}
}
)
;
}
_onVisibilityChange
(
)
{
if
(
this
.
document
.
visibilityState
=
=
=
VISIBLE
)
{
this
.
_sendEvent
(
)
;
this
.
document
.
removeEventListener
(
VISIBILITY_CHANGE_EVENT
this
.
_onVisibilityChange
)
;
}
}
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
var
_require
=
__webpack_require__
(
17
)
;
const
createStore
=
_require
.
createStore
combineReducers
=
_require
.
combineReducers
applyMiddleware
=
_require
.
applyMiddleware
;
var
_require2
=
__webpack_require__
(
1
)
;
const
au
=
_require2
.
actionUtils
;
const
MERGE_STORE_ACTION
=
"
NEW_TAB_INITIAL_STATE
"
;
const
OUTGOING_MESSAGE_NAME
=
"
ActivityStream
:
ContentToMain
"
;
const
INCOMING_MESSAGE_NAME
=
"
ActivityStream
:
MainToContent
"
;
function
mergeStateReducer
(
mainReducer
)
{
return
(
prevState
action
)
=
>
{
if
(
action
.
type
=
=
=
MERGE_STORE_ACTION
)
{
return
Object
.
assign
(
{
}
prevState
action
.
data
)
;
}
return
mainReducer
(
prevState
action
)
;
}
;
}
const
messageMiddleware
=
store
=
>
next
=
>
action
=
>
{
if
(
au
.
isSendToMain
(
action
)
)
{
sendAsyncMessage
(
OUTGOING_MESSAGE_NAME
action
)
;
}
next
(
action
)
;
}
;
module
.
exports
=
function
initStore
(
reducers
)
{
const
store
=
createStore
(
mergeStateReducer
(
combineReducers
(
reducers
)
)
applyMiddleware
(
messageMiddleware
)
)
;
addMessageListener
(
INCOMING_MESSAGE_NAME
msg
=
>
{
store
.
dispatch
(
msg
.
data
)
;
}
)
;
return
store
;
}
;
module
.
exports
.
MERGE_STORE_ACTION
=
MERGE_STORE_ACTION
;
module
.
exports
.
OUTGOING_MESSAGE_NAME
=
OUTGOING_MESSAGE_NAME
;
module
.
exports
.
INCOMING_MESSAGE_NAME
=
INCOMING_MESSAGE_NAME
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
var
_require
=
__webpack_require__
(
1
)
;
const
at
=
_require
.
actionTypes
;
const
INITIAL_STATE
=
{
App
:
{
initialized
:
false
locale
:
"
"
strings
:
{
}
version
:
null
}
TopSites
:
{
initialized
:
false
rows
:
[
]
}
Prefs
:
{
initialized
:
false
values
:
{
}
}
}
;
function
App
(
)
{
let
prevState
=
arguments
.
length
>
0
&
&
arguments
[
0
]
!
=
=
undefined
?
arguments
[
0
]
:
INITIAL_STATE
.
App
;
let
action
=
arguments
[
1
]
;
switch
(
action
.
type
)
{
case
at
.
INIT
:
return
Object
.
assign
(
{
}
action
.
data
|
|
{
}
{
initialized
:
true
}
)
;
case
at
.
LOCALE_UPDATED
:
{
if
(
!
action
.
data
)
{
return
prevState
;
}
var
_action
data
=
action
.
data
;
let
locale
=
_action
data
.
locale
strings
=
_action
data
.
strings
;
return
Object
.
assign
(
{
}
prevState
{
locale
strings
}
)
;
}
default
:
return
prevState
;
}
}
function
TopSites
(
)
{
let
prevState
=
arguments
.
length
>
0
&
&
arguments
[
0
]
!
=
=
undefined
?
arguments
[
0
]
:
INITIAL_STATE
.
TopSites
;
let
action
=
arguments
[
1
]
;
let
hasMatch
;
let
newRows
;
switch
(
action
.
type
)
{
case
at
.
TOP_SITES_UPDATED
:
if
(
!
action
.
data
)
{
return
prevState
;
}
return
Object
.
assign
(
{
}
prevState
{
initialized
:
true
rows
:
action
.
data
}
)
;
case
at
.
SCREENSHOT_UPDATED
:
newRows
=
prevState
.
rows
.
map
(
row
=
>
{
if
(
row
.
url
=
=
=
action
.
data
.
url
)
{
hasMatch
=
true
;
return
Object
.
assign
(
{
}
row
{
screenshot
:
action
.
data
.
screenshot
}
)
;
}
return
row
;
}
)
;
return
hasMatch
?
Object
.
assign
(
{
}
prevState
{
rows
:
newRows
}
)
:
prevState
;
case
at
.
PLACES_BOOKMARK_ADDED
:
newRows
=
prevState
.
rows
.
map
(
site
=
>
{
if
(
site
.
url
=
=
=
action
.
data
.
url
)
{
var
_action
data2
=
action
.
data
;
const
bookmarkGuid
=
_action
data2
.
bookmarkGuid
bookmarkTitle
=
_action
data2
.
bookmarkTitle
lastModified
=
_action
data2
.
lastModified
;
return
Object
.
assign
(
{
}
site
{
bookmarkGuid
bookmarkTitle
bookmarkDateCreated
:
lastModified
}
)
;
}
return
site
;
}
)
;
return
Object
.
assign
(
{
}
prevState
{
rows
:
newRows
}
)
;
case
at
.
PLACES_BOOKMARK_REMOVED
:
newRows
=
prevState
.
rows
.
map
(
site
=
>
{
if
(
site
.
url
=
=
=
action
.
data
.
url
)
{
const
newSite
=
Object
.
assign
(
{
}
site
)
;
delete
newSite
.
bookmarkGuid
;
delete
newSite
.
bookmarkTitle
;
delete
newSite
.
bookmarkDateCreated
;
return
newSite
;
}
return
site
;
}
)
;
return
Object
.
assign
(
{
}
prevState
{
rows
:
newRows
}
)
;
case
at
.
PLACES_LINK_DELETED
:
case
at
.
PLACES_LINK_BLOCKED
:
newRows
=
prevState
.
rows
.
filter
(
val
=
>
val
.
url
!
=
=
action
.
data
.
url
)
;
return
Object
.
assign
(
{
}
prevState
{
rows
:
newRows
}
)
;
default
:
return
prevState
;
}
}
function
Prefs
(
)
{
let
prevState
=
arguments
.
length
>
0
&
&
arguments
[
0
]
!
=
=
undefined
?
arguments
[
0
]
:
INITIAL_STATE
.
Prefs
;
let
action
=
arguments
[
1
]
;
let
newValues
;
switch
(
action
.
type
)
{
case
at
.
PREFS_INITIAL_VALUES
:
return
Object
.
assign
(
{
}
prevState
{
initialized
:
true
values
:
action
.
data
}
)
;
case
at
.
PREF_CHANGED
:
newValues
=
Object
.
assign
(
{
}
prevState
.
values
)
;
newValues
[
action
.
data
.
name
]
=
action
.
data
.
value
;
return
Object
.
assign
(
{
}
prevState
{
values
:
newValues
}
)
;
default
:
return
prevState
;
}
}
var
reducers
=
{
TopSites
App
Prefs
}
;
module
.
exports
=
{
reducers
INITIAL_STATE
}
;
}
)
(
function
(
module
exports
)
{
module
.
exports
=
ReactDOM
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
React
=
__webpack_require__
(
0
)
;
class
ContextMenu
extends
React
.
Component
{
constructor
(
props
)
{
super
(
props
)
;
this
.
hideContext
=
this
.
hideContext
.
bind
(
this
)
;
}
hideContext
(
)
{
this
.
props
.
onUpdate
(
false
)
;
}
componentWillMount
(
)
{
this
.
hideContext
(
)
;
}
componentDidUpdate
(
prevProps
)
{
if
(
this
.
props
.
visible
&
&
!
prevProps
.
visible
)
{
setTimeout
(
(
)
=
>
{
window
.
addEventListener
(
"
click
"
this
.
hideContext
)
;
}
0
)
;
}
if
(
!
this
.
props
.
visible
&
&
prevProps
.
visible
)
{
window
.
removeEventListener
(
"
click
"
this
.
hideContext
)
;
}
}
componentDidUnmount
(
)
{
window
.
removeEventListener
(
"
click
"
this
.
hideContext
)
;
}
onKeyDown
(
event
option
)
{
switch
(
event
.
key
)
{
case
"
Tab
"
:
if
(
event
.
shiftKey
&
&
option
.
first
|
|
!
event
.
shiftKey
&
&
option
.
last
)
{
this
.
hideContext
(
)
;
}
break
;
case
"
Enter
"
:
this
.
hideContext
(
)
;
option
.
onClick
(
)
;
break
;
}
}
render
(
)
{
return
React
.
createElement
(
"
span
"
{
hidden
:
!
this
.
props
.
visible
className
:
"
context
-
menu
"
}
React
.
createElement
(
"
ul
"
{
role
:
"
menu
"
className
:
"
context
-
menu
-
list
"
}
this
.
props
.
options
.
map
(
(
option
i
)
=
>
{
if
(
option
.
type
=
=
=
"
separator
"
)
{
return
React
.
createElement
(
"
li
"
{
key
:
i
className
:
"
separator
"
}
)
;
}
return
React
.
createElement
(
"
li
"
{
role
:
"
menuitem
"
className
:
"
context
-
menu
-
item
"
key
:
i
}
React
.
createElement
(
"
a
"
{
tabIndex
:
"
0
"
onKeyDown
:
e
=
>
this
.
onKeyDown
(
e
option
)
onClick
:
(
)
=
>
{
this
.
hideContext
(
)
;
option
.
onClick
(
)
;
}
}
option
.
icon
&
&
React
.
createElement
(
"
span
"
{
className
:
icon
icon
-
spacer
icon
-
{
option
.
icon
}
}
)
option
.
label
)
)
;
}
)
)
)
;
}
}
module
.
exports
=
ContextMenu
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
React
=
__webpack_require__
(
0
)
;
var
_require
=
__webpack_require__
(
3
)
;
const
injectIntl
=
_require
.
injectIntl
;
const
ContextMenu
=
__webpack_require__
(
9
)
;
var
_require2
=
__webpack_require__
(
1
)
;
const
actionTypes
=
_require2
.
actionTypes
ac
=
_require2
.
actionCreators
;
class
LinkMenu
extends
React
.
Component
{
getBookmarkStatus
(
site
)
{
return
site
.
bookmarkGuid
?
{
id
:
"
menu_action_remove_bookmark
"
icon
:
"
bookmark
-
remove
"
action
:
"
DELETE_BOOKMARK_BY_ID
"
data
:
site
.
bookmarkGuid
userEvent
:
"
BOOKMARK_DELETE
"
}
:
{
id
:
"
menu_action_bookmark
"
icon
:
"
bookmark
"
action
:
"
BOOKMARK_URL
"
data
:
site
.
url
userEvent
:
"
BOOKMARK_ADD
"
}
;
}
getDefaultContextMenu
(
site
)
{
return
[
{
id
:
"
menu_action_open_new_window
"
icon
:
"
new
-
window
"
action
:
"
OPEN_NEW_WINDOW
"
data
:
{
url
:
site
.
url
}
userEvent
:
"
OPEN_NEW_WINDOW
"
}
{
id
:
"
menu_action_open_private_window
"
icon
:
"
new
-
window
-
private
"
action
:
"
OPEN_PRIVATE_WINDOW
"
data
:
{
url
:
site
.
url
}
userEvent
:
"
OPEN_PRIVATE_WINDOW
"
}
]
;
}
getOptions
(
)
{
var
_props
=
this
.
props
;
const
dispatch
=
_props
.
dispatch
site
=
_props
.
site
index
=
_props
.
index
source
=
_props
.
source
;
let
options
=
this
.
getDefaultContextMenu
(
site
)
;
if
(
!
site
.
isDefault
)
{
options
=
[
this
.
getBookmarkStatus
(
site
)
{
type
:
"
separator
"
}
.
.
.
options
{
type
:
"
separator
"
}
{
id
:
"
menu_action_dismiss
"
icon
:
"
dismiss
"
action
:
"
BLOCK_URL
"
data
:
site
.
url
userEvent
:
"
BLOCK
"
}
{
id
:
"
menu_action_delete
"
icon
:
"
delete
"
action
:
"
DELETE_HISTORY_URL
"
data
:
site
.
url
userEvent
:
"
DELETE
"
}
]
;
}
options
.
forEach
(
option
=
>
{
const
action
=
option
.
action
data
=
option
.
data
id
=
option
.
id
type
=
option
.
type
userEvent
=
option
.
userEvent
;
if
(
!
type
&
&
id
)
{
option
.
label
=
this
.
props
.
intl
.
formatMessage
(
option
)
;
option
.
onClick
=
(
)
=
>
{
dispatch
(
ac
.
SendToMain
(
{
type
:
actionTypes
[
action
]
data
}
)
)
;
dispatch
(
ac
.
UserEvent
(
{
event
:
userEvent
source
action_position
:
index
}
)
)
;
}
;
}
}
)
;
options
[
0
]
.
first
=
true
;
options
[
options
.
length
-
1
]
.
last
=
true
;
return
options
;
}
render
(
)
{
return
React
.
createElement
(
ContextMenu
{
visible
:
this
.
props
.
visible
onUpdate
:
this
.
props
.
onUpdate
options
:
this
.
getOptions
(
)
}
)
;
}
}
module
.
exports
=
injectIntl
(
LinkMenu
)
;
module
.
exports
.
_unconnected
=
LinkMenu
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
React
=
__webpack_require__
(
0
)
;
var
_require
=
__webpack_require__
(
2
)
;
const
connect
=
_require
.
connect
;
var
_require2
=
__webpack_require__
(
3
)
;
const
injectIntl
=
_require2
.
injectIntl
FormattedMessage
=
_require2
.
FormattedMessage
;
const
classNames
=
__webpack_require__
(
16
)
;
var
_require3
=
__webpack_require__
(
1
)
;
const
ac
=
_require3
.
actionCreators
;
const
PreferencesInput
=
props
=
>
React
.
createElement
(
"
section
"
null
React
.
createElement
(
"
input
"
{
type
:
"
checkbox
"
id
:
props
.
prefName
name
:
props
.
prefName
checked
:
props
.
value
onChange
:
props
.
onChange
className
:
props
.
className
}
)
React
.
createElement
(
"
label
"
{
htmlFor
:
props
.
prefName
}
React
.
createElement
(
FormattedMessage
{
id
:
props
.
titleStringId
}
)
)
props
.
descStringId
&
&
React
.
createElement
(
"
p
"
{
className
:
"
prefs
-
input
-
description
"
}
React
.
createElement
(
FormattedMessage
{
id
:
props
.
descStringId
}
)
)
)
;
class
PreferencesPane
extends
React
.
Component
{
constructor
(
props
)
{
super
(
props
)
;
this
.
state
=
{
visible
:
false
}
;
this
.
handleClickOutside
=
this
.
handleClickOutside
.
bind
(
this
)
;
this
.
handleChange
=
this
.
handleChange
.
bind
(
this
)
;
this
.
togglePane
=
this
.
togglePane
.
bind
(
this
)
;
}
componentDidMount
(
)
{
document
.
addEventListener
(
"
click
"
this
.
handleClickOutside
)
;
}
componentWillUnmount
(
)
{
document
.
removeEventListener
(
"
click
"
this
.
handleClickOutside
)
;
}
handleClickOutside
(
event
)
{
if
(
this
.
state
.
visible
&
&
!
this
.
refs
.
wrapper
.
contains
(
event
.
target
)
)
{
this
.
togglePane
(
)
;
}
}
handleChange
(
event
)
{
const
target
=
event
.
target
;
this
.
props
.
dispatch
(
ac
.
SetPref
(
target
.
name
target
.
checked
)
)
;
}
togglePane
(
)
{
this
.
setState
(
{
visible
:
!
this
.
state
.
visible
}
)
;
const
event
=
this
.
state
.
visible
?
"
CLOSE_NEWTAB_PREFS
"
:
"
OPEN_NEWTAB_PREFS
"
;
this
.
props
.
dispatch
(
ac
.
UserEvent
(
{
event
}
)
)
;
}
render
(
)
{
const
props
=
this
.
props
;
const
prefs
=
props
.
Prefs
.
values
;
const
isVisible
=
this
.
state
.
visible
;
return
React
.
createElement
(
"
div
"
{
className
:
"
prefs
-
pane
-
wrapper
"
ref
:
"
wrapper
"
}
React
.
createElement
(
"
div
"
{
className
:
"
prefs
-
pane
-
button
"
}
React
.
createElement
(
"
button
"
{
className
:
classNames
(
"
prefs
-
button
icon
"
isVisible
?
"
icon
-
dismiss
"
:
"
icon
-
settings
"
)
title
:
props
.
intl
.
formatMessage
(
{
id
:
isVisible
?
"
settings_pane_done_button
"
:
"
settings_pane_button_label
"
}
)
onClick
:
this
.
togglePane
}
)
)
React
.
createElement
(
"
div
"
{
className
:
"
prefs
-
pane
"
}
React
.
createElement
(
"
div
"
{
className
:
classNames
(
"
sidebar
"
{
hidden
:
!
isVisible
}
)
}
React
.
createElement
(
"
div
"
{
className
:
"
prefs
-
modal
-
inner
-
wrapper
"
}
React
.
createElement
(
"
h1
"
null
React
.
createElement
(
FormattedMessage
{
id
:
"
settings_pane_header
"
}
)
)
React
.
createElement
(
"
p
"
null
React
.
createElement
(
FormattedMessage
{
id
:
"
settings_pane_body
"
}
)
)
React
.
createElement
(
PreferencesInput
{
className
:
"
showSearch
"
prefName
:
"
showSearch
"
value
:
prefs
.
showSearch
onChange
:
this
.
handleChange
titleStringId
:
"
settings_pane_search_header
"
descStringId
:
"
settings_pane_search_body
"
}
)
React
.
createElement
(
PreferencesInput
{
className
:
"
showTopSites
"
prefName
:
"
showTopSites
"
value
:
prefs
.
showTopSites
onChange
:
this
.
handleChange
titleStringId
:
"
settings_pane_topsites_header
"
descStringId
:
"
settings_pane_topsites_body
"
}
)
)
React
.
createElement
(
"
section
"
{
className
:
"
actions
"
}
React
.
createElement
(
"
button
"
{
className
:
"
done
"
onClick
:
this
.
togglePane
}
React
.
createElement
(
FormattedMessage
{
id
:
"
settings_pane_done_button
"
}
)
)
)
)
)
)
;
}
}
module
.
exports
=
connect
(
state
=
>
(
{
Prefs
:
state
.
Prefs
}
)
)
(
injectIntl
(
PreferencesPane
)
)
;
module
.
exports
.
PreferencesPane
=
PreferencesPane
;
module
.
exports
.
PreferencesInput
=
PreferencesInput
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
React
=
__webpack_require__
(
0
)
;
var
_require
=
__webpack_require__
(
2
)
;
const
connect
=
_require
.
connect
;
var
_require2
=
__webpack_require__
(
3
)
;
const
FormattedMessage
=
_require2
.
FormattedMessage
injectIntl
=
_require2
.
injectIntl
;
var
_require3
=
__webpack_require__
(
1
)
;
const
ac
=
_require3
.
actionCreators
;
class
Search
extends
React
.
Component
{
constructor
(
props
)
{
super
(
props
)
;
this
.
onClick
=
this
.
onClick
.
bind
(
this
)
;
this
.
onInputMount
=
this
.
onInputMount
.
bind
(
this
)
;
}
handleEvent
(
event
)
{
if
(
event
.
detail
.
type
=
=
=
"
Search
"
)
{
this
.
props
.
dispatch
(
ac
.
UserEvent
(
{
event
:
"
SEARCH
"
}
)
)
;
}
}
onClick
(
event
)
{
this
.
controller
.
search
(
event
)
;
}
onInputMount
(
input
)
{
if
(
input
)
{
this
.
controller
=
new
ContentSearchUIController
(
input
input
.
parentNode
"
newtab
"
"
newtab
"
)
;
addEventListener
(
"
ContentSearchClient
"
this
)
;
}
else
{
this
.
controller
=
null
;
removeEventListener
(
"
ContentSearchClient
"
this
)
;
}
}
render
(
)
{
return
React
.
createElement
(
"
form
"
{
className
:
"
search
-
wrapper
"
}
React
.
createElement
(
"
label
"
{
htmlFor
:
"
newtab
-
search
-
text
"
className
:
"
search
-
label
"
}
React
.
createElement
(
"
span
"
{
className
:
"
sr
-
only
"
}
React
.
createElement
(
FormattedMessage
{
id
:
"
search_web_placeholder
"
}
)
)
)
React
.
createElement
(
"
input
"
{
id
:
"
newtab
-
search
-
text
"
maxLength
:
"
256
"
placeholder
:
this
.
props
.
intl
.
formatMessage
(
{
id
:
"
search_web_placeholder
"
}
)
ref
:
this
.
onInputMount
title
:
this
.
props
.
intl
.
formatMessage
(
{
id
:
"
search_web_placeholder
"
}
)
type
:
"
search
"
}
)
React
.
createElement
(
"
button
"
{
className
:
"
search
-
button
"
onClick
:
this
.
onClick
title
:
this
.
props
.
intl
.
formatMessage
(
{
id
:
"
search_button
"
}
)
}
React
.
createElement
(
"
span
"
{
className
:
"
sr
-
only
"
}
React
.
createElement
(
FormattedMessage
{
id
:
"
search_button
"
}
)
)
)
)
;
}
}
module
.
exports
=
connect
(
)
(
injectIntl
(
Search
)
)
;
module
.
exports
.
_unconnected
=
Search
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
React
=
__webpack_require__
(
0
)
;
var
_require
=
__webpack_require__
(
2
)
;
const
connect
=
_require
.
connect
;
var
_require2
=
__webpack_require__
(
3
)
;
const
FormattedMessage
=
_require2
.
FormattedMessage
;
const
shortURL
=
__webpack_require__
(
14
)
;
const
LinkMenu
=
__webpack_require__
(
10
)
;
var
_require3
=
__webpack_require__
(
1
)
;
const
ac
=
_require3
.
actionCreators
;
const
TOP_SITES_SOURCE
=
"
TOP_SITES
"
;
class
TopSite
extends
React
.
Component
{
constructor
(
props
)
{
super
(
props
)
;
this
.
state
=
{
showContextMenu
:
false
activeTile
:
null
}
;
}
toggleContextMenu
(
event
index
)
{
this
.
setState
(
{
showContextMenu
:
true
activeTile
:
index
}
)
;
}
trackClick
(
)
{
this
.
props
.
dispatch
(
ac
.
UserEvent
(
{
event
:
"
CLICK
"
source
:
TOP_SITES_SOURCE
action_position
:
this
.
props
.
index
}
)
)
;
}
render
(
)
{
var
_props
=
this
.
props
;
const
link
=
_props
.
link
index
=
_props
.
index
dispatch
=
_props
.
dispatch
;
const
isContextMenuOpen
=
this
.
state
.
showContextMenu
&
&
this
.
state
.
activeTile
=
=
=
index
;
const
title
=
shortURL
(
link
)
;
const
screenshotClassName
=
screenshot
{
link
.
screenshot
?
"
active
"
:
"
"
}
;
const
topSiteOuterClassName
=
top
-
site
-
outer
{
isContextMenuOpen
?
"
active
"
:
"
"
}
;
const
style
=
{
backgroundImage
:
link
.
screenshot
?
url
(
{
link
.
screenshot
}
)
:
"
none
"
}
;
return
React
.
createElement
(
"
li
"
{
className
:
topSiteOuterClassName
key
:
link
.
url
}
React
.
createElement
(
"
a
"
{
onClick
:
(
)
=
>
this
.
trackClick
(
)
href
:
link
.
url
}
React
.
createElement
(
"
div
"
{
className
:
"
tile
"
"
aria
-
hidden
"
:
true
}
React
.
createElement
(
"
span
"
{
className
:
"
letter
-
fallback
"
}
title
[
0
]
)
React
.
createElement
(
"
div
"
{
className
:
screenshotClassName
style
:
style
}
)
)
React
.
createElement
(
"
div
"
{
className
:
"
title
"
}
title
)
)
React
.
createElement
(
"
button
"
{
className
:
"
context
-
menu
-
button
"
onClick
:
e
=
>
{
e
.
preventDefault
(
)
;
this
.
toggleContextMenu
(
e
index
)
;
}
}
React
.
createElement
(
"
span
"
{
className
:
"
sr
-
only
"
}
Open
context
menu
for
{
title
}
)
)
React
.
createElement
(
LinkMenu
{
dispatch
:
dispatch
visible
:
isContextMenuOpen
onUpdate
:
val
=
>
this
.
setState
(
{
showContextMenu
:
val
}
)
site
:
link
index
:
index
source
:
TOP_SITES_SOURCE
}
)
)
;
}
}
const
TopSites
=
props
=
>
React
.
createElement
(
"
section
"
null
React
.
createElement
(
"
h3
"
{
className
:
"
section
-
title
"
}
React
.
createElement
(
FormattedMessage
{
id
:
"
header_top_sites
"
}
)
)
React
.
createElement
(
"
ul
"
{
className
:
"
top
-
sites
-
list
"
}
props
.
TopSites
.
rows
.
map
(
(
link
index
)
=
>
React
.
createElement
(
TopSite
{
key
:
link
.
url
dispatch
:
props
.
dispatch
link
:
link
index
:
index
}
)
)
)
)
;
module
.
exports
=
connect
(
state
=
>
(
{
TopSites
:
state
.
TopSites
}
)
)
(
TopSites
)
;
module
.
exports
.
_unconnected
=
TopSites
;
module
.
exports
.
TopSite
=
TopSite
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
module
.
exports
=
function
shortURL
(
link
)
{
if
(
!
link
.
url
&
&
!
link
.
hostname
)
{
return
"
"
;
}
const
eTLD
=
link
.
eTLD
;
const
hostname
=
(
link
.
hostname
|
|
new
URL
(
link
.
url
)
.
hostname
)
.
replace
(
/
^
www
\
.
/
i
"
"
)
;
const
eTLDLength
=
(
eTLD
|
|
"
"
)
.
length
|
|
hostname
.
match
(
/
\
.
com
/
)
&
&
3
;
const
eTLDExtra
=
eTLDLength
>
0
?
-
(
eTLDLength
+
1
)
:
Infinity
;
return
hostname
.
slice
(
0
eTLDExtra
)
.
toLowerCase
(
)
;
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
let
usablePerfObj
;
let
Cu
;
const
isRunningInChrome
=
typeof
Window
=
=
=
"
undefined
"
;
if
(
isRunningInChrome
)
{
Cu
=
Components
.
utils
;
}
else
{
Cu
=
{
import
(
)
{
}
}
;
}
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
if
(
isRunningInChrome
)
{
usablePerfObj
=
Services
.
appShell
.
hiddenDOMWindow
.
performance
;
}
else
{
usablePerfObj
=
performance
;
}
var
_PerfService
=
function
_PerfService
(
options
)
{
if
(
options
&
&
options
.
performanceObj
)
{
this
.
_perf
=
options
.
performanceObj
;
}
else
{
this
.
_perf
=
usablePerfObj
;
}
}
;
_PerfService
.
prototype
=
{
mark
:
function
mark
(
str
)
{
this
.
_perf
.
mark
(
str
)
;
}
getEntriesByName
:
function
getEntriesByName
(
name
type
)
{
return
this
.
_perf
.
getEntriesByName
(
name
type
)
;
}
get
timeOrigin
(
)
{
return
this
.
_perf
.
timeOrigin
;
}
getMostRecentAbsMarkStartByName
(
name
)
{
let
entries
=
this
.
getEntriesByName
(
name
"
mark
"
)
;
if
(
!
entries
.
length
)
{
throw
new
Error
(
No
marks
with
the
name
{
name
}
)
;
}
let
mostRecentEntry
=
entries
[
entries
.
length
-
1
]
;
return
this
.
_perf
.
timeOrigin
+
mostRecentEntry
.
startTime
;
}
}
;
var
perfService
=
new
_PerfService
(
)
;
module
.
exports
=
{
_PerfService
perfService
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_ARRAY__
__WEBPACK_AMD_DEFINE_RESULT__
;
(
function
(
)
{
'
use
strict
'
;
var
hasOwn
=
{
}
.
hasOwnProperty
;
function
classNames
(
)
{
var
classes
=
[
]
;
for
(
var
i
=
0
;
i
<
arguments
.
length
;
i
+
+
)
{
var
arg
=
arguments
[
i
]
;
if
(
!
arg
)
continue
;
var
argType
=
typeof
arg
;
if
(
argType
=
=
=
'
string
'
|
|
argType
=
=
=
'
number
'
)
{
classes
.
push
(
arg
)
;
}
else
if
(
Array
.
isArray
(
arg
)
)
{
classes
.
push
(
classNames
.
apply
(
null
arg
)
)
;
}
else
if
(
argType
=
=
=
'
object
'
)
{
for
(
var
key
in
arg
)
{
if
(
hasOwn
.
call
(
arg
key
)
&
&
arg
[
key
]
)
{
classes
.
push
(
key
)
;
}
}
}
}
return
classes
.
join
(
'
'
)
;
}
if
(
typeof
module
!
=
=
'
undefined
'
&
&
module
.
exports
)
{
module
.
exports
=
classNames
;
}
else
if
(
true
)
{
!
(
__WEBPACK_AMD_DEFINE_ARRAY__
=
[
]
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
)
{
return
classNames
;
}
.
apply
(
exports
__WEBPACK_AMD_DEFINE_ARRAY__
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
else
{
window
.
classNames
=
classNames
;
}
}
(
)
)
;
}
)
(
function
(
module
exports
)
{
module
.
exports
=
Redux
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
React
=
__webpack_require__
(
0
)
;
const
ReactDOM
=
__webpack_require__
(
8
)
;
const
Base
=
__webpack_require__
(
4
)
;
var
_require
=
__webpack_require__
(
2
)
;
const
Provider
=
_require
.
Provider
;
const
initStore
=
__webpack_require__
(
6
)
;
var
_require2
=
__webpack_require__
(
7
)
;
const
reducers
=
_require2
.
reducers
;
const
DetectUserSessionStart
=
__webpack_require__
(
5
)
;
new
DetectUserSessionStart
(
)
.
sendEventOrAddListener
(
)
;
const
store
=
initStore
(
reducers
)
;
ReactDOM
.
render
(
React
.
createElement
(
Provider
{
store
:
store
}
React
.
createElement
(
Base
null
)
)
document
.
getElementById
(
"
root
"
)
)
;
}
)
]
)
;
