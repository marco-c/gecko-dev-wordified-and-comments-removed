import
{
IntlProvider
intlShape
}
from
"
react
-
intl
"
;
import
{
mount
shallow
}
from
"
enzyme
"
;
import
React
from
"
react
"
;
const
messages
=
require
(
"
data
/
locales
.
json
"
)
[
"
en
-
US
"
]
;
const
intlProvider
=
new
IntlProvider
(
{
locale
:
"
en
-
US
"
messages
}
)
;
const
{
intl
}
=
intlProvider
.
getChildContext
(
)
;
export
class
GlobalOverrider
{
constructor
(
)
{
this
.
originalGlobals
=
new
Map
(
)
;
this
.
sandbox
=
sinon
.
sandbox
.
create
(
)
;
}
_override
(
key
value
)
{
if
(
!
this
.
originalGlobals
.
has
(
key
)
)
{
this
.
originalGlobals
.
set
(
key
global
[
key
]
)
;
}
global
[
key
]
=
value
;
}
set
(
key
value
)
{
if
(
!
value
&
&
typeof
key
=
=
=
"
object
"
)
{
const
overrides
=
key
;
Object
.
keys
(
overrides
)
.
forEach
(
k
=
>
this
.
_override
(
k
overrides
[
k
]
)
)
;
}
else
{
this
.
_override
(
key
value
)
;
}
return
value
;
}
reset
(
)
{
this
.
sandbox
.
reset
(
)
;
}
restore
(
)
{
this
.
sandbox
.
restore
(
)
;
this
.
originalGlobals
.
forEach
(
(
value
key
)
=
>
{
global
[
key
]
=
value
;
}
)
;
}
}
export
class
FakensIPrefBranch
{
constructor
(
args
)
{
if
(
args
)
{
if
(
"
initHook
"
in
args
)
{
args
.
initHook
.
call
(
this
)
;
}
}
this
.
_prefBranch
=
{
}
;
this
.
observers
=
{
}
;
}
addObserver
(
prefName
callback
)
{
this
.
observers
[
prefName
]
=
callback
;
}
removeObserver
(
prefName
callback
)
{
if
(
prefName
in
this
.
observers
)
{
delete
this
.
observers
[
prefName
]
;
}
}
observeBranch
(
listener
)
{
}
ignoreBranch
(
listener
)
{
}
setStringPref
(
prefName
)
{
}
getStringPref
(
prefName
)
{
return
this
.
get
(
prefName
)
;
}
getBoolPref
(
prefName
)
{
return
this
.
get
(
prefName
)
;
}
get
(
prefName
)
{
return
this
.
prefs
[
prefName
]
;
}
setBoolPref
(
prefName
value
)
{
this
.
prefs
[
prefName
]
=
value
;
if
(
prefName
in
this
.
observers
)
{
this
.
observers
[
prefName
]
(
"
"
"
"
prefName
)
;
}
}
}
FakensIPrefBranch
.
prototype
.
prefs
=
{
}
;
export
class
FakePrefs
extends
FakensIPrefBranch
{
observe
(
prefName
callback
)
{
super
.
addObserver
(
prefName
callback
)
;
}
ignore
(
prefName
callback
)
{
super
.
removeObserver
(
prefName
callback
)
;
}
set
(
prefName
value
)
{
this
.
prefs
[
prefName
]
=
value
;
if
(
prefName
in
this
.
observers
)
{
this
.
observers
[
prefName
]
(
value
)
;
}
}
}
export
function
EventEmitter
(
)
{
}
EventEmitter
.
decorate
=
function
(
objectToDecorate
)
{
let
emitter
=
new
EventEmitter
(
)
;
objectToDecorate
.
on
=
emitter
.
on
.
bind
(
emitter
)
;
objectToDecorate
.
off
=
emitter
.
off
.
bind
(
emitter
)
;
objectToDecorate
.
once
=
emitter
.
once
.
bind
(
emitter
)
;
objectToDecorate
.
emit
=
emitter
.
emit
.
bind
(
emitter
)
;
}
;
EventEmitter
.
prototype
=
{
on
(
event
listener
)
{
if
(
!
this
.
_eventEmitterListeners
)
{
this
.
_eventEmitterListeners
=
new
Map
(
)
;
}
if
(
!
this
.
_eventEmitterListeners
.
has
(
event
)
)
{
this
.
_eventEmitterListeners
.
set
(
event
[
]
)
;
}
this
.
_eventEmitterListeners
.
get
(
event
)
.
push
(
listener
)
;
}
off
(
event
listener
)
{
if
(
!
this
.
_eventEmitterListeners
)
{
return
;
}
let
listeners
=
this
.
_eventEmitterListeners
.
get
(
event
)
;
if
(
listeners
)
{
this
.
_eventEmitterListeners
.
set
(
event
listeners
.
filter
(
l
=
>
l
!
=
=
listener
&
&
l
.
_originalListener
!
=
=
listener
)
)
;
}
}
once
(
event
listener
)
{
return
new
Promise
(
resolve
=
>
{
let
handler
=
(
_
first
.
.
.
rest
)
=
>
{
this
.
off
(
event
handler
)
;
if
(
listener
)
{
listener
(
event
first
.
.
.
rest
)
;
}
resolve
(
first
)
;
}
;
handler
.
_originalListener
=
listener
;
this
.
on
(
event
handler
)
;
}
)
;
}
emit
(
event
.
.
.
args
)
{
if
(
!
this
.
_eventEmitterListeners
|
|
!
this
.
_eventEmitterListeners
.
has
(
event
)
)
{
return
;
}
let
originalListeners
=
this
.
_eventEmitterListeners
.
get
(
event
)
;
for
(
let
listener
of
this
.
_eventEmitterListeners
.
get
(
event
)
)
{
if
(
!
this
.
_eventEmitterListeners
)
{
break
;
}
if
(
originalListeners
=
=
=
this
.
_eventEmitterListeners
.
get
(
event
)
|
|
this
.
_eventEmitterListeners
.
get
(
event
)
.
some
(
l
=
>
l
=
=
=
listener
)
)
{
try
{
listener
(
event
.
.
.
args
)
;
}
catch
(
ex
)
{
}
}
}
}
}
;
export
function
FakePerformance
(
)
{
}
FakePerformance
.
prototype
=
{
marks
:
new
Map
(
)
now
(
)
{
return
window
.
performance
.
now
(
)
;
}
timing
:
{
navigationStart
:
222222
.
123
}
get
timeOrigin
(
)
{
return
10000
.
234
;
}
getEntriesByName
(
name
type
)
{
if
(
this
.
marks
.
has
(
name
)
)
{
return
this
.
marks
.
get
(
name
)
;
}
return
[
]
;
}
callsToMark
:
0
mark
(
name
)
{
let
markObj
=
{
name
"
entryType
"
:
"
mark
"
"
startTime
"
:
+
+
this
.
callsToMark
"
duration
"
:
0
}
;
if
(
this
.
marks
.
has
(
name
)
)
{
this
.
marks
.
get
(
name
)
.
push
(
markObj
)
;
return
;
}
this
.
marks
.
set
(
name
[
markObj
]
)
;
}
}
;
export
function
addNumberReducer
(
prevState
=
0
action
)
{
return
action
.
type
=
=
=
"
ADD
"
?
prevState
+
action
.
data
:
prevState
;
}
function
nodeWithIntlProp
(
node
)
{
return
React
.
cloneElement
(
node
{
intl
}
)
;
}
export
function
shallowWithIntl
(
node
options
=
{
}
)
{
return
shallow
(
nodeWithIntlProp
(
node
)
Object
.
assign
(
{
}
options
{
context
:
{
intl
}
}
)
)
;
}
export
function
mountWithIntl
(
node
options
=
{
}
)
{
return
mount
(
nodeWithIntlProp
(
node
)
Object
.
assign
(
{
}
options
{
context
:
{
intl
}
childContextTypes
:
{
intl
:
intlShape
}
}
)
)
;
}
