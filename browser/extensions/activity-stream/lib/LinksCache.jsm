"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
LinksCache
"
]
;
const
EXPIRATION_TIME
=
5
*
60
*
1000
;
this
.
LinksCache
=
class
LinksCache
{
constructor
(
linkObject
linkProperty
migrator
=
(
)
=
>
{
}
shouldRefresh
=
(
)
=
>
{
}
)
{
this
.
clear
(
)
;
this
.
linkGetter
=
options
=
>
{
const
ret
=
linkObject
[
linkProperty
]
;
return
typeof
ret
=
=
=
"
function
"
?
ret
.
call
(
linkObject
options
)
:
ret
;
}
;
this
.
migrator
=
migrator
;
this
.
shouldRefresh
=
shouldRefresh
;
}
clear
(
)
{
this
.
cache
=
Promise
.
resolve
(
[
]
)
;
this
.
lastOptions
=
{
}
;
this
.
expire
(
)
;
}
expire
(
)
{
delete
this
.
lastUpdate
;
}
async
request
(
options
=
{
}
)
{
const
now
=
Date
.
now
(
)
;
if
(
this
.
lastUpdate
=
=
=
undefined
|
|
now
>
this
.
lastUpdate
+
EXPIRATION_TIME
|
|
this
.
shouldRefresh
(
this
.
lastOptions
options
)
)
{
this
.
lastOptions
=
options
;
this
.
lastUpdate
=
now
;
this
.
cache
=
new
Promise
(
async
resolve
=
>
{
const
toMigrate
=
new
Map
(
)
;
for
(
const
oldLink
of
await
this
.
cache
)
{
if
(
oldLink
)
{
toMigrate
.
set
(
oldLink
.
url
oldLink
)
;
}
}
const
copied
=
(
await
this
.
linkGetter
(
options
)
)
.
map
(
link
=
>
link
&
&
Object
.
assign
(
{
}
link
)
)
;
for
(
const
newLink
of
copied
)
{
if
(
newLink
)
{
const
oldLink
=
toMigrate
.
get
(
newLink
.
url
)
;
if
(
oldLink
)
{
this
.
migrator
(
oldLink
newLink
)
;
}
newLink
.
__updateCache
=
function
(
prop
)
{
const
val
=
this
[
prop
]
;
if
(
val
=
=
=
undefined
)
{
delete
newLink
[
prop
]
;
}
else
{
newLink
[
prop
]
=
val
;
}
}
;
}
}
resolve
(
copied
)
;
}
)
;
}
return
this
.
cache
;
}
}
;
