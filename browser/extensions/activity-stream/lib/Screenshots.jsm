"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
Screenshots
"
]
;
const
{
utils
:
Cu
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
BackgroundPageThumbs
"
"
resource
:
/
/
gre
/
modules
/
BackgroundPageThumbs
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PageThumbs
"
"
resource
:
/
/
gre
/
modules
/
PageThumbs
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
FileUtils
"
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
MIMEService
"
"
mozilla
.
org
/
mime
;
1
"
"
nsIMIMEService
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
OS
"
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
const
GREY_10
=
"
#
F9F9FA
"
;
this
.
Screenshots
=
{
_bytesToString
(
bytes
)
{
const
ARGS_LENGTH_MAX
=
500
*
1000
;
let
i
=
0
;
let
str
=
"
"
;
let
{
length
}
=
bytes
;
while
(
i
<
length
)
{
const
start
=
i
;
i
+
=
ARGS_LENGTH_MAX
;
str
+
=
String
.
fromCharCode
.
apply
(
null
bytes
.
slice
(
start
i
)
)
;
}
return
str
;
}
async
getScreenshotForURL
(
url
)
{
let
screenshot
=
null
;
try
{
await
BackgroundPageThumbs
.
captureIfMissing
(
url
{
backgroundColor
:
GREY_10
}
)
;
const
imgPath
=
PageThumbs
.
getThumbnailPath
(
url
)
;
const
file
=
await
OS
.
File
.
open
(
imgPath
{
read
:
true
existing
:
true
}
)
;
const
nsFile
=
FileUtils
.
File
(
imgPath
)
;
const
contentType
=
MIMEService
.
getTypeFromFile
(
nsFile
)
;
const
bytes
=
await
file
.
read
(
)
;
const
encodedData
=
btoa
(
this
.
_bytesToString
(
bytes
)
)
;
file
.
close
(
)
;
screenshot
=
data
:
{
contentType
}
;
base64
{
encodedData
}
;
}
catch
(
err
)
{
Cu
.
reportError
(
getScreenshot
error
:
{
err
}
)
;
}
return
screenshot
;
}
async
maybeGetAndSetScreenshot
(
link
url
property
onScreenshot
)
{
const
updateCache
=
link
.
__updateCache
?
link
.
__updateCache
.
bind
(
link
)
:
(
)
=
>
{
}
;
if
(
!
link
.
__fetchingScreenshot
)
{
link
.
__fetchingScreenshot
=
this
.
getScreenshotForURL
(
url
)
;
updateCache
(
"
__fetchingScreenshot
"
)
;
link
.
__fetchingScreenshot
.
then
(
onScreenshot
)
.
catch
(
)
;
}
const
screenshot
=
await
link
.
__fetchingScreenshot
;
delete
link
.
__fetchingScreenshot
;
updateCache
(
"
__fetchingScreenshot
"
)
;
if
(
screenshot
)
{
link
[
property
]
=
screenshot
;
updateCache
(
property
)
;
}
}
}
;
