"
use
strict
"
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
actionCreators
:
ac
actionTypes
:
at
}
=
Cu
.
import
(
"
resource
:
/
/
activity
-
stream
/
common
/
Actions
.
jsm
"
{
}
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
NewTabUtils
"
"
resource
:
/
/
gre
/
modules
/
NewTabUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PlacesUtils
"
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Pocket
"
"
chrome
:
/
/
pocket
/
content
/
Pocket
.
jsm
"
)
;
const
LINK_BLOCKED_EVENT
=
"
newtab
-
linkBlocked
"
;
class
Observer
{
constructor
(
dispatch
observerInterface
)
{
this
.
dispatch
=
dispatch
;
this
.
QueryInterface
=
XPCOMUtils
.
generateQI
(
[
observerInterface
Ci
.
nsISupportsWeakReference
]
)
;
}
}
class
HistoryObserver
extends
Observer
{
constructor
(
dispatch
)
{
super
(
dispatch
Ci
.
nsINavHistoryObserver
)
;
}
async
onDeleteURI
(
uri
)
{
const
{
spec
}
=
uri
;
if
(
this
.
_deletedLinks
)
{
this
.
_deletedLinks
.
push
(
spec
)
;
}
else
{
this
.
_deletedLinks
=
[
spec
]
;
await
Promise
.
resolve
(
)
.
then
(
(
)
=
>
{
this
.
dispatch
(
{
type
:
at
.
PLACES_LINKS_DELETED
data
:
this
.
_deletedLinks
}
)
;
delete
this
.
_deletedLinks
;
}
)
;
}
}
onClearHistory
(
)
{
this
.
dispatch
(
{
type
:
at
.
PLACES_HISTORY_CLEARED
}
)
;
}
onBeginUpdateBatch
(
)
{
}
onEndUpdateBatch
(
)
{
}
onVisits
(
)
{
}
onTitleChanged
(
)
{
}
onFrecencyChanged
(
)
{
}
onManyFrecenciesChanged
(
)
{
}
onPageChanged
(
)
{
}
onDeleteVisits
(
)
{
}
}
class
BookmarksObserver
extends
Observer
{
constructor
(
dispatch
)
{
super
(
dispatch
Ci
.
nsINavBookmarkObserver
)
;
}
onItemAdded
(
.
.
.
args
)
{
const
type
=
args
[
3
]
;
const
source
=
args
[
9
]
;
const
uri
=
args
[
4
]
;
if
(
type
!
=
=
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
|
|
source
=
=
=
PlacesUtils
.
bookmarks
.
SOURCES
.
IMPORT_REPLACE
|
|
(
uri
.
scheme
!
=
=
"
http
"
&
&
uri
.
scheme
!
=
=
"
https
"
)
)
{
return
;
}
const
bookmarkTitle
=
args
[
5
]
;
const
dateAdded
=
args
[
6
]
;
const
bookmarkGuid
=
args
[
7
]
;
this
.
dispatch
(
{
type
:
at
.
PLACES_BOOKMARK_ADDED
data
:
{
bookmarkGuid
bookmarkTitle
dateAdded
url
:
uri
.
spec
}
}
)
;
}
onItemRemoved
(
id
folderId
index
type
uri
guid
)
{
if
(
type
=
=
=
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
)
{
this
.
dispatch
(
{
type
:
at
.
PLACES_BOOKMARK_REMOVED
data
:
{
url
:
uri
.
spec
bookmarkGuid
:
guid
}
}
)
;
}
}
async
onItemChanged
(
.
.
.
args
)
{
}
onBeginUpdateBatch
(
)
{
}
onEndUpdateBatch
(
)
{
}
onItemVisited
(
)
{
}
onItemMoved
(
)
{
}
}
class
PlacesFeed
{
constructor
(
)
{
this
.
historyObserver
=
new
HistoryObserver
(
action
=
>
this
.
store
.
dispatch
(
ac
.
BroadcastToContent
(
action
)
)
)
;
this
.
bookmarksObserver
=
new
BookmarksObserver
(
action
=
>
this
.
store
.
dispatch
(
ac
.
BroadcastToContent
(
action
)
)
)
;
}
addObservers
(
)
{
Cc
[
"
mozilla
.
org
/
browser
/
nav
-
history
-
service
;
1
"
]
.
getService
(
Ci
.
nsINavHistoryService
)
.
addObserver
(
this
.
historyObserver
true
)
;
Cc
[
"
mozilla
.
org
/
browser
/
nav
-
bookmarks
-
service
;
1
"
]
.
getService
(
Ci
.
nsINavBookmarksService
)
.
addObserver
(
this
.
bookmarksObserver
true
)
;
Services
.
obs
.
addObserver
(
this
LINK_BLOCKED_EVENT
)
;
}
removeObservers
(
)
{
PlacesUtils
.
history
.
removeObserver
(
this
.
historyObserver
)
;
PlacesUtils
.
bookmarks
.
removeObserver
(
this
.
bookmarksObserver
)
;
Services
.
obs
.
removeObserver
(
this
LINK_BLOCKED_EVENT
)
;
}
observe
(
subject
topic
value
)
{
if
(
topic
=
=
=
LINK_BLOCKED_EVENT
)
{
this
.
store
.
dispatch
(
ac
.
BroadcastToContent
(
{
type
:
at
.
PLACES_LINK_BLOCKED
data
:
{
url
:
value
}
}
)
)
;
}
}
openNewWindow
(
action
isPrivate
=
false
)
{
const
win
=
action
.
_target
.
browser
.
ownerGlobal
;
const
privateParam
=
{
private
:
isPrivate
}
;
const
params
=
(
action
.
data
.
referrer
)
?
Object
.
assign
(
privateParam
{
referrerURI
:
Services
.
io
.
newURI
(
action
.
data
.
referrer
)
}
)
:
privateParam
;
win
.
openLinkIn
(
action
.
data
.
url
"
window
"
params
)
;
}
onAction
(
action
)
{
switch
(
action
.
type
)
{
case
at
.
INIT
:
Services
.
tm
.
dispatchToMainThread
(
(
)
=
>
this
.
addObservers
(
)
)
;
break
;
case
at
.
UNINIT
:
this
.
removeObservers
(
)
;
break
;
case
at
.
BLOCK_URL
:
NewTabUtils
.
activityStreamLinks
.
blockURL
(
{
url
:
action
.
data
}
)
;
break
;
case
at
.
BOOKMARK_URL
:
NewTabUtils
.
activityStreamLinks
.
addBookmark
(
action
.
data
action
.
_target
.
browser
)
;
break
;
case
at
.
DELETE_BOOKMARK_BY_ID
:
NewTabUtils
.
activityStreamLinks
.
deleteBookmark
(
action
.
data
)
;
break
;
case
at
.
DELETE_HISTORY_URL
:
{
const
{
url
forceBlock
}
=
action
.
data
;
NewTabUtils
.
activityStreamLinks
.
deleteHistoryEntry
(
url
)
;
if
(
forceBlock
)
{
NewTabUtils
.
activityStreamLinks
.
blockURL
(
{
url
}
)
;
}
break
;
}
case
at
.
OPEN_NEW_WINDOW
:
this
.
openNewWindow
(
action
)
;
break
;
case
at
.
OPEN_PRIVATE_WINDOW
:
this
.
openNewWindow
(
action
true
)
;
break
;
case
at
.
SAVE_TO_POCKET
:
Pocket
.
savePage
(
action
.
_target
.
browser
action
.
data
.
site
.
url
action
.
data
.
site
.
title
)
;
break
;
case
at
.
OPEN_LINK
:
{
const
win
=
action
.
_target
.
browser
.
ownerGlobal
;
const
where
=
win
.
whereToOpenLink
(
action
.
data
.
event
)
;
if
(
action
.
data
.
referrer
)
{
win
.
openLinkIn
(
action
.
data
.
url
where
{
referrerURI
:
Services
.
io
.
newURI
(
action
.
data
.
referrer
)
}
)
;
}
else
{
win
.
openLinkIn
(
action
.
data
.
url
where
{
}
)
;
}
break
;
}
}
}
}
this
.
PlacesFeed
=
PlacesFeed
;
PlacesFeed
.
HistoryObserver
=
HistoryObserver
;
PlacesFeed
.
BookmarksObserver
=
BookmarksObserver
;
this
.
EXPORTED_SYMBOLS
=
[
"
PlacesFeed
"
]
;
