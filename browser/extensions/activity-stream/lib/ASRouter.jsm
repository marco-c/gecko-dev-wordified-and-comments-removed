ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
importGlobalProperties
(
[
"
fetch
"
]
)
;
const
INCOMING_MESSAGE_NAME
=
"
ASRouter
:
child
-
to
-
parent
"
;
const
OUTGOING_MESSAGE_NAME
=
"
ASRouter
:
parent
-
to
-
child
"
;
const
ONE_HOUR_IN_MS
=
60
*
60
*
1000
;
const
SNIPPETS_ENDPOINT
=
"
https
:
/
/
activity
-
stream
-
icons
.
services
.
mozilla
.
com
/
v1
/
messages
.
json
.
br
"
;
const
LOCAL_TEST_MESSAGES
=
[
{
id
:
"
LOCAL_TEST_THEMES
"
template
:
"
simple_snippet
"
content
:
{
text
:
"
Your
browser
is
ready
for
a
makeover
.
Don
'
t
worry
you
'
ve
got
tons
of
options
.
"
button_label
:
"
Check
them
out
here
"
button_url
:
"
https
:
/
/
addons
.
mozilla
.
org
/
en
-
US
/
firefox
/
themes
"
}
}
]
;
const
MessageLoaderUtils
=
{
_localLoader
(
provider
)
{
return
provider
.
messages
;
}
async
_remoteLoader
(
provider
)
{
let
remoteMessages
=
[
]
;
if
(
provider
.
url
)
{
try
{
remoteMessages
=
(
await
(
await
fetch
(
provider
.
url
)
)
.
json
(
)
)
.
messages
.
map
(
msg
=
>
(
Object
.
assign
(
{
}
msg
{
provider_url
:
provider
.
url
}
)
)
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
return
remoteMessages
;
}
_getMessageLoader
(
provider
)
{
switch
(
provider
.
type
)
{
case
"
remote
"
:
return
this
.
_remoteLoader
;
case
"
local
"
:
default
:
return
this
.
_localLoader
;
}
}
shouldProviderUpdate
(
provider
currentTime
=
Date
.
now
(
)
)
{
return
(
!
(
provider
.
lastUpdated
>
=
0
)
|
|
currentTime
-
provider
.
lastUpdated
>
provider
.
updateCycleInMs
)
;
}
async
loadMessagesForProvider
(
provider
)
{
const
messages
=
(
await
this
.
_getMessageLoader
(
provider
)
(
provider
)
)
.
map
(
msg
=
>
Object
.
assign
(
{
}
msg
{
provider
:
provider
.
id
}
)
)
;
const
lastUpdated
=
Date
.
now
(
)
;
return
{
messages
lastUpdated
}
;
}
}
;
this
.
MessageLoaderUtils
=
MessageLoaderUtils
;
function
getRandomItemFromArray
(
arr
)
{
const
index
=
Math
.
floor
(
Math
.
random
(
)
*
arr
.
length
)
;
return
arr
[
index
]
;
}
class
_ASRouter
{
constructor
(
initialState
=
{
}
)
{
this
.
initialized
=
false
;
this
.
messageChannel
=
null
;
this
.
_storage
=
null
;
this
.
_resetInitialization
(
)
;
this
.
_state
=
Object
.
assign
(
{
currentId
:
null
providers
:
[
]
blockList
:
[
]
messages
:
[
]
}
initialState
)
;
this
.
onMessage
=
this
.
onMessage
.
bind
(
this
)
;
}
get
state
(
)
{
return
this
.
_state
;
}
set
state
(
value
)
{
throw
new
Error
(
"
Do
not
modify
this
.
state
directy
.
Instead
call
this
.
setState
(
newState
)
"
)
;
}
_resetInitialization
(
)
{
this
.
initialized
=
false
;
this
.
waitForInitialized
=
new
Promise
(
resolve
=
>
{
this
.
_finishInitializing
=
(
)
=
>
{
this
.
initialized
=
true
;
resolve
(
)
;
}
;
}
)
;
}
async
loadMessagesFromAllProviders
(
)
{
const
needsUpdate
=
this
.
state
.
providers
.
filter
(
provider
=
>
MessageLoaderUtils
.
shouldProviderUpdate
(
provider
)
)
;
if
(
needsUpdate
.
length
)
{
let
newState
=
{
messages
:
[
]
providers
:
[
]
}
;
for
(
const
provider
of
this
.
state
.
providers
)
{
if
(
needsUpdate
.
includes
(
provider
)
)
{
const
{
messages
lastUpdated
}
=
await
MessageLoaderUtils
.
loadMessagesForProvider
(
provider
)
;
newState
.
providers
.
push
(
(
Object
.
assign
(
{
}
provider
{
lastUpdated
}
)
)
)
;
newState
.
messages
=
[
.
.
.
newState
.
messages
.
.
.
messages
]
;
}
else
{
let
messages
=
this
.
state
.
messages
.
filter
(
msg
=
>
msg
.
provider
=
=
=
provider
.
id
)
;
newState
.
providers
.
push
(
provider
)
;
newState
.
messages
=
[
.
.
.
newState
.
messages
.
.
.
messages
]
;
}
}
await
this
.
setState
(
newState
)
;
}
}
async
init
(
channel
storage
)
{
this
.
messageChannel
=
channel
;
this
.
messageChannel
.
addMessageListener
(
INCOMING_MESSAGE_NAME
this
.
onMessage
)
;
await
this
.
loadMessagesFromAllProviders
(
)
;
this
.
_storage
=
storage
;
const
blockList
=
await
this
.
_storage
.
get
(
"
blockList
"
)
|
|
[
]
;
await
this
.
setState
(
{
blockList
}
)
;
this
.
_finishInitializing
(
)
;
}
uninit
(
)
{
this
.
messageChannel
.
sendAsyncMessage
(
OUTGOING_MESSAGE_NAME
{
type
:
"
CLEAR_MESSAGE
"
}
)
;
this
.
messageChannel
.
removeMessageListener
(
INCOMING_MESSAGE_NAME
this
.
onMessage
)
;
this
.
messageChannel
=
null
;
this
.
_resetInitialization
(
)
;
}
setState
(
callbackOrObj
)
{
const
newState
=
(
typeof
callbackOrObj
=
=
=
"
function
"
)
?
callbackOrObj
(
this
.
state
)
:
callbackOrObj
;
this
.
_state
=
Object
.
assign
(
{
}
this
.
state
newState
)
;
return
new
Promise
(
resolve
=
>
{
this
.
_onStateChanged
(
this
.
state
)
;
resolve
(
)
;
}
)
;
}
getMessageById
(
id
)
{
return
this
.
state
.
messages
.
find
(
message
=
>
message
.
id
=
=
=
id
)
;
}
_onStateChanged
(
state
)
{
this
.
messageChannel
.
sendAsyncMessage
(
OUTGOING_MESSAGE_NAME
{
type
:
"
ADMIN_SET_STATE
"
data
:
state
}
)
;
}
async
sendNextMessage
(
target
id
)
{
let
message
;
await
this
.
setState
(
state
=
>
{
message
=
getRandomItemFromArray
(
state
.
messages
.
filter
(
item
=
>
item
.
id
!
=
=
state
.
currentId
&
&
!
state
.
blockList
.
includes
(
item
.
id
)
)
)
;
return
{
currentId
:
message
?
message
.
id
:
null
}
;
}
)
;
if
(
message
)
{
target
.
sendAsyncMessage
(
OUTGOING_MESSAGE_NAME
{
type
:
"
SET_MESSAGE
"
data
:
message
}
)
;
}
else
{
target
.
sendAsyncMessage
(
OUTGOING_MESSAGE_NAME
{
type
:
"
CLEAR_MESSAGE
"
}
)
;
}
}
async
setMessageById
(
id
)
{
await
this
.
setState
(
{
currentId
:
id
}
)
;
const
newMessage
=
this
.
getMessageById
(
id
)
;
if
(
newMessage
)
{
this
.
messageChannel
.
sendAsyncMessage
(
OUTGOING_MESSAGE_NAME
{
type
:
"
SET_MESSAGE
"
data
:
newMessage
}
)
;
}
}
async
clearMessage
(
target
id
)
{
if
(
this
.
state
.
currentId
=
=
=
id
)
{
await
this
.
setState
(
{
currentId
:
null
}
)
;
}
target
.
sendAsyncMessage
(
OUTGOING_MESSAGE_NAME
{
type
:
"
CLEAR_MESSAGE
"
}
)
;
}
async
onMessage
(
{
data
:
action
target
}
)
{
switch
(
action
.
type
)
{
case
"
CONNECT_UI_REQUEST
"
:
case
"
GET_NEXT_MESSAGE
"
:
await
this
.
waitForInitialized
;
await
this
.
loadMessagesFromAllProviders
(
)
;
await
this
.
sendNextMessage
(
target
)
;
break
;
case
"
BLOCK_MESSAGE_BY_ID
"
:
await
this
.
setState
(
state
=
>
{
const
blockList
=
[
.
.
.
state
.
blockList
]
;
blockList
.
push
(
action
.
data
.
id
)
;
this
.
_storage
.
set
(
"
blockList
"
blockList
)
;
return
{
blockList
}
;
}
)
;
await
this
.
clearMessage
(
target
action
.
data
.
id
)
;
break
;
case
"
UNBLOCK_MESSAGE_BY_ID
"
:
await
this
.
setState
(
state
=
>
{
const
blockList
=
[
.
.
.
state
.
blockList
]
;
blockList
.
splice
(
blockList
.
indexOf
(
action
.
data
.
id
)
1
)
;
this
.
_storage
.
set
(
"
blockList
"
blockList
)
;
return
{
blockList
}
;
}
)
;
break
;
case
"
OVERRIDE_MESSAGE
"
:
await
this
.
setMessageById
(
action
.
data
.
id
)
;
break
;
case
"
ADMIN_CONNECT_STATE
"
:
target
.
sendAsyncMessage
(
OUTGOING_MESSAGE_NAME
{
type
:
"
ADMIN_SET_STATE
"
data
:
this
.
state
}
)
;
break
;
}
}
}
this
.
_ASRouter
=
_ASRouter
;
this
.
ASRouter
=
new
_ASRouter
(
{
providers
:
[
{
id
:
"
onboarding
"
type
:
"
local
"
messages
:
LOCAL_TEST_MESSAGES
}
{
id
:
"
snippets
"
type
:
"
remote
"
url
:
SNIPPETS_ENDPOINT
updateCycleInMs
:
ONE_HOUR_IN_MS
*
4
}
]
}
)
;
const
EXPORTED_SYMBOLS
=
[
"
_ASRouter
"
"
ASRouter
"
"
MessageLoaderUtils
"
]
;
