"
use
strict
"
;
ChromeUtils
.
defineESModuleGetters
(
this
{
sinon
:
"
resource
:
/
/
testing
-
common
/
Sinon
.
sys
.
mjs
"
}
)
;
add_task
(
async
function
test_weightedSampleTopSites_no_guid_last
(
)
{
const
Ranker
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
newtab
/
lib
/
SmartShortcutsRanker
/
RankShortcuts
.
mjs
"
)
;
const
provider
=
new
Ranker
.
RankShortcutsProvider
(
)
;
const
{
NewTabUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
NewTabUtils
.
sys
.
mjs
"
)
;
await
NewTabUtils
.
init
(
)
;
const
sandbox
=
sinon
.
createSandbox
(
)
;
sandbox
.
stub
(
NewTabUtils
.
activityStreamProvider
"
executePlacesQuery
"
)
.
resolves
(
[
[
"
a
"
5
10
]
[
"
b
"
2
10
]
]
)
;
const
input
=
[
{
url
:
"
no
-
guid
.
com
"
}
{
guid
:
"
a
"
url
:
"
a
.
com
"
}
{
guid
:
"
b
"
url
:
"
b
.
com
"
}
]
;
const
prefValues
=
{
trainhopConfig
:
{
smartShortcuts
:
{
eta
:
0
click_bonus
:
10
positive_prior
:
1
negative_prior
:
1
fset
:
1
}
}
}
;
const
result
=
await
provider
.
rankTopSites
(
input
prefValues
{
isStartup
:
false
}
)
;
Assert
.
ok
(
Array
.
isArray
(
result
)
"
returns
an
array
"
)
;
Assert
.
equal
(
result
[
result
.
length
-
1
]
.
url
"
no
-
guid
.
com
"
"
top
-
site
without
GUID
is
last
"
)
;
sandbox
.
restore
(
)
;
}
)
;
add_task
(
async
function
test_sumNorm
(
)
{
const
Ranker
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
newtab
/
lib
/
SmartShortcutsRanker
/
RankShortcutsWorkerClass
.
mjs
"
)
;
let
vec
=
[
1
1
]
;
let
result
=
Ranker
.
sumNorm
(
vec
)
;
Assert
.
ok
(
result
.
every
(
(
v
i
)
=
>
Math
.
abs
(
v
-
[
0
.
5
0
.
5
]
[
i
]
)
<
1e
-
6
)
"
sum
norm
works
as
expected
for
dense
array
"
)
;
vec
=
[
0
0
]
;
result
=
Ranker
.
sumNorm
(
vec
)
;
Assert
.
ok
(
result
.
every
(
(
v
i
)
=
>
Math
.
abs
(
v
-
[
0
.
0
0
.
0
]
[
i
]
)
<
1e
-
6
)
"
if
sum
is
0
.
0
it
should
return
the
original
vector
input
is
zeros
"
)
;
vec
=
[
1
-
1
]
;
result
=
Ranker
.
sumNorm
(
vec
)
;
Assert
.
ok
(
result
.
every
(
(
v
i
)
=
>
Math
.
abs
(
v
-
[
1
.
0
-
1
.
0
]
[
i
]
)
<
1e
-
6
)
"
if
sum
is
0
.
0
it
should
return
the
original
vector
input
contains
negatives
"
)
;
}
)
;
add_task
(
async
function
test_computeLinearScore
(
)
{
const
Ranker
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
newtab
/
lib
/
SmartShortcutsRanker
/
RankShortcutsWorkerClass
.
mjs
"
)
;
let
entry
=
{
a
:
1
b
:
0
bias
:
1
}
;
let
weights
=
{
a
:
1
b
:
0
bias
:
0
}
;
let
result
=
Ranker
.
computeLinearScore
(
entry
weights
)
;
Assert
.
equal
(
result
1
"
check
linear
score
with
one
non
-
zero
weight
"
)
;
entry
=
{
a
:
1
b
:
1
bias
:
1
}
;
weights
=
{
a
:
1
b
:
1
bias
:
1
}
;
result
=
Ranker
.
computeLinearScore
(
entry
weights
)
;
Assert
.
equal
(
result
3
"
check
linear
score
with
1
everywhere
"
)
;
entry
=
{
bias
:
1
}
;
weights
=
{
a
:
1
b
:
1
bias
:
1
}
;
result
=
Ranker
.
computeLinearScore
(
entry
weights
)
;
Assert
.
equal
(
result
1
"
check
linear
score
with
empty
entry
get
bias
"
)
;
entry
=
{
a
:
1
b
:
1
bias
:
1
}
;
weights
=
{
}
;
result
=
Ranker
.
computeLinearScore
(
entry
weights
)
;
Assert
.
equal
(
result
0
"
check
linear
score
with
empty
weights
"
)
;
entry
=
{
a
:
1
b
:
1
bias
:
1
}
;
weights
=
{
a
:
3
}
;
result
=
Ranker
.
computeLinearScore
(
entry
weights
)
;
Assert
.
equal
(
result
3
"
check
linear
score
with
a
missing
weight
"
)
;
}
)
;
add_task
(
async
function
test_interpolateWrappedHistogram
(
)
{
const
Ranker
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
newtab
/
lib
/
SmartShortcutsRanker
/
RankShortcutsWorkerClass
.
mjs
"
)
;
let
hist
=
[
1
2
]
;
let
t
=
0
.
5
;
let
result
=
Ranker
.
interpolateWrappedHistogram
(
hist
t
)
;
Assert
.
equal
(
result
1
.
5
"
test
linear
interpolation
square
in
the
middle
"
)
;
hist
=
[
1
2
5
]
;
t
=
2
.
5
;
result
=
Ranker
.
interpolateWrappedHistogram
(
hist
t
)
;
Assert
.
equal
(
result
(
hist
[
0
]
+
hist
[
2
]
)
/
2
"
test
linear
interpolation
correctly
wraps
around
"
)
;
hist
=
[
1
2
5
]
;
t
=
5
;
result
=
Ranker
.
interpolateWrappedHistogram
(
hist
t
)
;
Assert
.
equal
(
result
hist
[
2
]
"
linear
interpolation
will
wrap
around
to
the
last
index
"
)
;
}
)
;
add_task
(
async
function
test_bayesHist
(
)
{
const
Ranker
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
newtab
/
lib
/
SmartShortcutsRanker
/
RankShortcutsWorkerClass
.
mjs
"
)
;
let
vec
=
[
1
2
]
;
let
pvec
=
[
0
.
5
0
.
5
]
;
let
tau
=
2
;
let
result
=
Ranker
.
bayesHist
(
vec
pvec
tau
)
;
Assert
.
ok
(
result
.
every
(
(
v
i
)
=
>
Math
.
abs
(
v
-
[
0
.
4
0
.
6
]
[
i
]
)
<
1e
-
6
)
"
bayes
histogram
is
expected
for
typical
input
"
)
;
vec
=
[
1
2
]
;
pvec
=
[
0
.
5
0
.
5
]
;
tau
=
0
.
0
;
result
=
Ranker
.
bayesHist
(
vec
pvec
tau
)
;
Assert
.
ok
(
result
.
every
(
(
v
i
)
=
>
Math
.
abs
(
v
-
vec
[
i
]
/
3
)
<
1e
-
6
)
"
bayes
histogram
is
a
sum
norming
function
if
tau
is
0
"
)
;
}
)
;
add_task
(
async
function
test_normSites
(
)
{
const
Ranker
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
newtab
/
lib
/
SmartShortcutsRanker
/
RankShortcutsWorkerClass
.
mjs
"
)
;
let
Y
=
{
a
:
[
2
2
]
b
:
[
3
3
]
}
;
let
result
=
Ranker
.
normHistDict
(
Y
)
;
Assert
.
ok
(
result
.
a
.
every
(
(
v
i
)
=
>
Math
.
abs
(
v
-
[
4
/
(
4
+
9
)
4
/
(
4
+
9
)
]
[
i
]
)
<
1e
-
6
)
"
normSites
basic
input
first
array
"
)
;
Assert
.
ok
(
result
.
b
.
every
(
(
v
i
)
=
>
Math
.
abs
(
v
-
[
9
/
(
4
+
9
)
9
/
(
4
+
9
)
]
[
i
]
)
<
1e
-
6
)
"
normSites
basic
input
second
array
"
)
;
Y
=
[
]
;
result
=
Ranker
.
normHistDict
(
Y
)
;
Assert
.
deepEqual
(
result
[
]
"
normSites
handles
empty
array
"
)
;
}
)
;
add_task
(
async
function
test_clampWeights
(
)
{
const
Ranker
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
newtab
/
lib
/
SmartShortcutsRanker
/
RankShortcutsWorkerClass
.
mjs
"
)
;
let
weights
=
{
a
:
0
b
:
1000
bias
:
0
}
;
let
result
=
Ranker
.
clampWeights
(
weights
100
)
;
info
(
"
clampWeights
clamps
a
big
weight
vector
"
)
;
Assert
.
equal
(
result
.
a
0
)
;
Assert
.
equal
(
result
.
b
100
)
;
Assert
.
equal
(
result
.
bias
0
)
;
weights
=
{
a
:
1
b
:
1
bias
:
1
}
;
result
=
Ranker
.
clampWeights
(
weights
100
)
;
info
(
"
clampWeights
ignores
a
small
weight
vector
"
)
;
Assert
.
equal
(
result
.
a
1
)
;
Assert
.
equal
(
result
.
b
1
)
;
Assert
.
equal
(
result
.
bias
1
)
;
}
)
;
add_task
(
async
function
test_updateWeights_batch
(
)
{
const
Ranker
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
newtab
/
lib
/
SmartShortcutsRanker
/
RankShortcutsWorkerClass
.
mjs
"
)
;
const
eta
=
1
;
const
click_bonus
=
1
;
const
features
=
[
"
a
"
"
b
"
"
bias
"
]
;
function
sigmoid
(
x
)
{
return
1
/
(
1
+
Math
.
exp
(
-
x
)
)
;
}
function
approxEqual
(
actual
expected
eps
=
1e
-
12
)
{
Assert
.
lessOrEqual
(
Math
.
abs
(
actual
-
expected
)
eps
expected
{
actual
}
{
expected
}
)
;
}
const
initial1
=
{
a
:
0
b
:
1
bias
:
0
.
1
}
;
const
scores1
=
{
guid_A
:
{
final
:
1
.
1
a
:
1
b
:
1
bias
:
1
}
}
;
let
updated
=
await
Ranker
.
updateWeights
(
{
data
:
{
guid_A
:
{
clicks
:
1
impressions
:
0
}
}
scores
:
scores1
features
weights
:
{
.
.
.
initial1
}
eta
click_bonus
}
false
)
;
const
delta
=
sigmoid
(
1
.
1
)
-
1
;
approxEqual
(
updated
.
a
0
-
Number
(
delta
)
*
1
)
;
approxEqual
(
updated
.
b
1
-
Number
(
delta
)
*
1
)
;
approxEqual
(
updated
.
bias
0
.
1
-
Number
(
delta
)
*
1
)
;
const
initial2
=
{
a
:
0
b
:
1000
bias
:
0
}
;
const
scores2
=
{
guid_A
:
{
final
:
1
a
:
1
b
:
1e
-
3
bias
:
1
}
}
;
updated
=
await
Ranker
.
updateWeights
(
{
data
:
{
guid_B
:
{
clicks
:
1
impressions
:
0
}
}
scores
:
scores2
features
weights
:
{
.
.
.
initial2
}
eta
click_bonus
}
false
)
;
Assert
.
equal
(
updated
.
a
0
)
;
Assert
.
equal
(
updated
.
b
1000
)
;
Assert
.
equal
(
updated
.
bias
0
)
;
}
)
;
add_task
(
async
function
test_buildFrecencyFeatures_shape_and_empty
(
)
{
const
Ranker
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
newtab
/
lib
/
SmartShortcutsRanker
/
RankShortcutsWorkerClass
.
mjs
"
)
;
let
out
=
await
Ranker
.
buildFrecencyFeatures
(
{
}
{
}
)
;
Assert
.
ok
(
out
&
&
"
refre
"
in
out
&
&
"
rece
"
in
out
&
&
"
freq
"
in
out
"
returns
transposed
object
with
feature
keys
"
)
;
Assert
.
deepEqual
(
out
.
refre
{
}
"
refre
empty
"
)
;
Assert
.
deepEqual
(
out
.
rece
{
}
"
rece
empty
"
)
;
Assert
.
deepEqual
(
out
.
freq
{
}
"
freq
empty
"
)
;
out
=
await
Ranker
.
buildFrecencyFeatures
(
{
guidA
:
[
]
}
{
guidA
:
42
}
)
;
Assert
.
equal
(
out
.
refre
.
guidA
0
"
refre
zero
with
no
visits
"
)
;
Assert
.
equal
(
out
.
freq
.
guidA
0
"
freq
zero
with
no
visits
"
)
;
Assert
.
equal
(
out
.
rece
.
guidA
0
"
rece
zero
with
no
visits
"
)
;
}
)
;
add_task
(
async
function
test_buildFrecencyFeatures_recency_monotonic
(
)
{
const
Ranker
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
newtab
/
lib
/
SmartShortcutsRanker
/
RankShortcutsWorkerClass
.
mjs
"
)
;
const
sandbox
=
sinon
.
createSandbox
(
)
;
const
nowMs
=
Date
.
UTC
(
2025
0
1
)
;
const
clock
=
sandbox
.
useFakeTimers
(
{
now
:
nowMs
}
)
;
const
dayMs
=
864e5
;
const
us
=
v
=
>
Math
.
round
(
v
*
1000
)
;
const
visitsByGuid
=
{
recent
:
[
{
visit_date_us
:
us
(
nowMs
)
visit_type
:
2
}
]
old
:
[
{
visit_date_us
:
us
(
nowMs
-
10
*
dayMs
)
visit_type
:
2
}
]
both
:
[
{
visit_date_us
:
us
(
nowMs
)
visit_type
:
2
}
{
visit_date_us
:
us
(
nowMs
-
10
*
dayMs
)
visit_type
:
2
}
]
}
;
const
visitCounts
=
{
recent
:
10
old
:
10
both
:
10
}
;
const
out
=
await
Ranker
.
buildFrecencyFeatures
(
visitsByGuid
visitCounts
{
halfLifeDays
:
28
}
)
;
Assert
.
greater
(
out
.
rece
.
recent
out
.
rece
.
old
"
more
recent
visit
larger
recency
score
"
)
;
Assert
.
greater
(
out
.
rece
.
both
out
.
rece
.
recent
"
two
visits
(
recent
+
old
)
larger
recency
sum
than
just
recent
"
)
;
clock
.
restore
(
)
;
sandbox
.
restore
(
)
;
}
)
;
add_task
(
async
function
test_buildFrecencyFeatures_log_scaling_and_interaction
(
)
{
const
Ranker
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
newtab
/
lib
/
SmartShortcutsRanker
/
RankShortcutsWorkerClass
.
mjs
"
)
;
const
sandbox
=
sinon
.
createSandbox
(
)
;
const
clock
=
sandbox
.
useFakeTimers
(
{
now
:
Date
.
UTC
(
2025
0
1
)
}
)
;
const
nowMs
=
Date
.
now
(
)
;
const
us
=
v
=
>
Math
.
round
(
v
*
1000
)
;
const
visitsByGuid
=
{
A
:
[
{
visit_date_us
:
us
(
nowMs
)
visit_type
:
2
}
]
B
:
[
{
visit_date_us
:
us
(
nowMs
)
visit_type
:
2
}
]
}
;
const
visitCounts
=
{
A
:
9
B
:
99
}
;
const
out
=
await
Ranker
.
buildFrecencyFeatures
(
visitsByGuid
visitCounts
)
;
Assert
.
equal
(
out
.
rece
.
A
out
.
rece
.
B
"
recency
is
independent
of
visit_count
"
)
;
const
ratio
=
Math
.
log1p
(
visitCounts
.
B
)
/
Math
.
log1p
(
visitCounts
.
A
)
;
const
approxEqual
=
(
a
b
eps
=
1e
-
9
)
=
>
Assert
.
lessOrEqual
(
Math
.
abs
(
a
-
b
)
eps
)
;
approxEqual
(
out
.
freq
.
B
/
out
.
freq
.
A
ratio
1e
-
9
)
;
approxEqual
(
out
.
refre
.
B
/
out
.
refre
.
A
ratio
1e
-
9
)
;
clock
.
restore
(
)
;
sandbox
.
restore
(
)
;
}
)
;
add_task
(
async
function
test_buildFrecencyFeatures_halfLife_effect
(
)
{
const
Ranker
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
newtab
/
lib
/
SmartShortcutsRanker
/
RankShortcutsWorkerClass
.
mjs
"
)
;
const
sandbox
=
sinon
.
createSandbox
(
)
;
const
nowMs
=
Date
.
UTC
(
2025
0
1
)
;
const
clock
=
sandbox
.
useFakeTimers
(
{
now
:
nowMs
}
)
;
const
dayMs
=
864e5
;
const
us
=
v
=
>
Math
.
round
(
v
*
1000
)
;
const
visits
=
[
{
visit_date_us
:
us
(
nowMs
)
visit_type
:
1
}
{
visit_date_us
:
us
(
nowMs
-
28
*
dayMs
)
visit_type
:
1
}
]
;
const
visitsByGuid
=
{
X
:
visits
}
;
const
visitCounts
=
{
X
:
10
}
;
const
outShort
=
await
Ranker
.
buildFrecencyFeatures
(
visitsByGuid
visitCounts
{
halfLifeDays
:
7
}
)
;
const
outLong
=
await
Ranker
.
buildFrecencyFeatures
(
visitsByGuid
visitCounts
{
halfLifeDays
:
56
}
)
;
Assert
.
greater
(
outLong
.
rece
.
X
outShort
.
rece
.
X
"
larger
half
-
life
slower
decay
bigger
recency
sum
"
)
;
clock
.
restore
(
)
;
sandbox
.
restore
(
)
;
}
)
;
add_task
(
async
function
test_buildFrecencyFeatures_unknown_types_are_zero_bonus
(
)
{
const
Ranker
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
newtab
/
lib
/
SmartShortcutsRanker
/
RankShortcutsWorkerClass
.
mjs
"
)
;
const
sandbox
=
sinon
.
createSandbox
(
)
;
const
clock
=
sandbox
.
useFakeTimers
(
{
now
:
Date
.
UTC
(
2025
0
1
)
}
)
;
const
nowMs
=
Date
.
now
(
)
;
const
us
=
v
=
>
Math
.
round
(
v
*
1000
)
;
const
visitsByGuid
=
{
U
:
[
{
visit_date_us
:
us
(
nowMs
)
visit_type
:
99999
}
]
}
;
const
visitCounts
=
{
U
:
100
}
;
const
out
=
await
Ranker
.
buildFrecencyFeatures
(
visitsByGuid
visitCounts
)
;
Assert
.
equal
(
out
.
freq
.
U
0
"
unknown
visit_type
zero
frequency
bonus
"
)
;
Assert
.
equal
(
out
.
refre
.
U
0
"
unknown
visit_type
zero
interaction
"
)
;
Assert
.
greater
(
out
.
rece
.
U
0
"
recency
is
still
>
0
for
a
recent
visit
"
)
;
clock
.
restore
(
)
;
sandbox
.
restore
(
)
;
}
)
;
add_task
(
async
function
test_weightedSampleTopSites_new_features_scores_and_norms
(
)
{
const
Ranker
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
newtab
/
lib
/
SmartShortcutsRanker
/
RankShortcutsWorkerClass
.
mjs
"
)
;
const
guids
=
[
"
g1
"
"
g2
"
]
;
const
input
=
{
guid
:
guids
features
:
[
"
bmark
"
"
rece
"
"
freq
"
"
refre
"
"
bias
"
]
bmark_scores
:
{
g1
:
1
g2
:
0
}
rece_scores
:
{
g1
:
2
.
0
g2
:
1
.
0
}
freq_scores
:
{
g1
:
0
.
5
g2
:
0
.
25
}
refre_scores
:
{
g1
:
10
g2
:
5
}
norms
:
{
bmark
:
null
rece
:
null
freq
:
null
refre
:
null
}
weights
:
{
bmark
:
1
rece
:
1
freq
:
1
refre
:
1
bias
:
0
}
clicks
:
[
]
impressions
:
[
]
alpha
:
1
beta
:
1
tau
:
0
hourly_seasonality
:
{
}
daily_seasonality
:
{
}
}
;
const
vecBmark
=
guids
.
map
(
g
=
>
input
.
bmark_scores
[
g
]
)
;
const
vecRece
=
guids
.
map
(
g
=
>
input
.
rece_scores
[
g
]
)
;
const
vecFreq
=
guids
.
map
(
g
=
>
input
.
freq_scores
[
g
]
)
;
const
vecRefre
=
guids
.
map
(
g
=
>
input
.
refre_scores
[
g
]
)
;
const
[
expBmark
expBmarkNorm
]
=
Ranker
.
normUpdate
(
vecBmark
input
.
norms
.
bmark
)
;
const
[
expRece
expReceNorm
]
=
Ranker
.
normUpdate
(
vecRece
input
.
norms
.
rece
)
;
const
[
expFreq
expFreqNorm
]
=
Ranker
.
normUpdate
(
vecFreq
input
.
norms
.
freq
)
;
const
[
expRefre
expRefreNorm
]
=
Ranker
.
normUpdate
(
vecRefre
input
.
norms
.
refre
)
;
const
result
=
await
Ranker
.
weightedSampleTopSites
(
input
)
;
Assert
.
ok
(
result
&
&
result
.
score_map
&
&
result
.
norms
"
returns
{
score_map
norms
}
"
)
;
Assert
.
equal
(
result
.
score_map
.
g1
.
bmark
expBmark
[
0
]
"
bmark
g1
normalized
value
"
)
;
Assert
.
equal
(
result
.
score_map
.
g2
.
bmark
expBmark
[
1
]
"
bmark
g2
normalized
value
"
)
;
Assert
.
equal
(
result
.
score_map
.
g1
.
rece
expRece
[
0
]
"
rece
g1
normalized
value
"
)
;
Assert
.
equal
(
result
.
score_map
.
g2
.
rece
expRece
[
1
]
"
rece
g2
normalized
value
"
)
;
Assert
.
equal
(
result
.
score_map
.
g1
.
freq
expFreq
[
0
]
"
freq
g1
normalized
value
"
)
;
Assert
.
equal
(
result
.
score_map
.
g2
.
freq
expFreq
[
1
]
"
freq
g2
normalized
value
"
)
;
Assert
.
equal
(
result
.
score_map
.
g1
.
refre
expRefre
[
0
]
"
refre
g1
normalized
value
"
)
;
Assert
.
equal
(
result
.
score_map
.
g2
.
refre
expRefre
[
1
]
"
refre
g2
normalized
value
"
)
;
Assert
.
deepEqual
(
result
.
norms
.
bmark
expBmarkNorm
"
bmark
norms
updated
"
)
;
Assert
.
deepEqual
(
result
.
norms
.
rece
expReceNorm
"
rece
norms
updated
"
)
;
Assert
.
deepEqual
(
result
.
norms
.
freq
expFreqNorm
"
freq
norms
updated
"
)
;
Assert
.
deepEqual
(
result
.
norms
.
refre
expRefreNorm
"
refre
norms
updated
"
)
;
const
expectedFinalG1
=
Ranker
.
computeLinearScore
(
result
.
score_map
.
g1
input
.
weights
)
;
const
expectedFinalG2
=
Ranker
.
computeLinearScore
(
result
.
score_map
.
g2
input
.
weights
)
;
Assert
.
equal
(
result
.
score_map
.
g1
.
final
expectedFinalG1
"
final
matches
linear
score
(
g1
)
"
)
;
Assert
.
equal
(
result
.
score_map
.
g2
.
final
expectedFinalG2
"
final
matches
linear
score
(
g2
)
"
)
;
Assert
.
greaterOrEqual
(
result
.
score_map
.
g1
.
final
result
.
score_map
.
g2
.
final
"
g1
final
g2
final
as
all
contributing
features
favor
g1
"
)
;
}
)
;
add_task
(
async
function
test_rankshortcuts_queries_returning_nothing
(
)
{
const
Ranker
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
newtab
/
lib
/
SmartShortcutsRanker
/
RankShortcuts
.
mjs
"
)
;
const
{
NewTabUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
NewTabUtils
.
sys
.
mjs
"
)
;
await
NewTabUtils
.
init
(
)
;
const
sandbox
=
sinon
.
createSandbox
(
)
;
const
stub
=
sandbox
.
stub
(
NewTabUtils
.
activityStreamProvider
"
executePlacesQuery
"
)
.
resolves
(
[
]
)
;
const
topsites
=
[
{
guid
:
"
g1
"
}
{
guid
:
"
g2
"
}
]
;
const
places
=
"
moz_places
"
;
const
hist
=
"
moz_historyvisits
"
;
{
const
out
=
await
Ranker
.
fetchVisitCountsByGuid
(
topsites
places
)
;
Assert
.
deepEqual
(
out
{
}
"
visit
counts
:
empty
rows
empty
map
"
)
;
}
{
const
out
=
await
Ranker
.
fetchLast10VisitsByGuid
(
topsites
hist
places
)
;
Assert
.
deepEqual
(
out
{
g1
:
[
]
g2
:
[
]
}
"
last
10
visits
:
empty
rows
each
guid
has
[
]
"
)
;
}
{
const
out
=
await
Ranker
.
fetchBookmarkedFlags
(
topsites
"
moz_bookmarks
"
places
)
;
Assert
.
deepEqual
(
out
{
g1
:
false
g2
:
false
}
"
bookmarks
:
empty
rows
every
guid
is
false
"
)
;
}
{
const
out
=
await
Ranker
.
fetchDailyVisitsSpecific
(
topsites
hist
places
)
;
Assert
.
ok
(
Array
.
isArray
(
out
.
g1
)
&
&
out
.
g1
.
length
=
=
=
7
"
daily
specific
:
7
bins
"
)
;
Assert
.
ok
(
Array
.
isArray
(
out
.
g2
)
&
&
out
.
g2
.
length
=
=
=
7
"
daily
specific
:
7
bins
"
)
;
Assert
.
ok
(
out
.
g1
.
every
(
v
=
>
v
=
=
=
0
)
&
&
out
.
g2
.
every
(
v
=
>
v
=
=
=
0
)
"
daily
specific
:
all
zeros
"
)
;
}
{
const
out
=
await
Ranker
.
fetchDailyVisitsAll
(
hist
)
;
Assert
.
ok
(
Array
.
isArray
(
out
)
&
&
out
.
length
=
=
=
7
"
daily
all
:
7
bins
"
)
;
Assert
.
ok
(
out
.
every
(
v
=
>
v
=
=
=
0
)
"
daily
all
:
all
zeros
"
)
;
}
{
const
out
=
await
Ranker
.
fetchHourlyVisitsSpecific
(
topsites
hist
places
)
;
Assert
.
ok
(
Array
.
isArray
(
out
.
g1
)
&
&
out
.
g1
.
length
=
=
=
24
"
hourly
specific
:
24
bins
"
)
;
Assert
.
ok
(
Array
.
isArray
(
out
.
g2
)
&
&
out
.
g2
.
length
=
=
=
24
"
hourly
specific
:
24
bins
"
)
;
Assert
.
ok
(
out
.
g1
.
every
(
v
=
>
v
=
=
=
0
)
&
&
out
.
g2
.
every
(
v
=
>
v
=
=
=
0
)
"
hourly
specific
:
all
zeros
"
)
;
}
{
const
out
=
await
Ranker
.
fetchHourlyVisitsAll
(
hist
)
;
Assert
.
ok
(
Array
.
isArray
(
out
)
&
&
out
.
length
=
=
=
24
"
hourly
all
:
24
bins
"
)
;
Assert
.
ok
(
out
.
every
(
v
=
>
v
=
=
=
0
)
"
hourly
all
:
all
zeros
"
)
;
}
Assert
.
greater
(
stub
.
callCount
0
"
executePlacesQuery
was
called
"
)
;
sandbox
.
restore
(
)
;
}
)
;
add_task
(
async
function
test_rankshortcuts_no_topsites_inputs
(
)
{
const
Ranker
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
newtab
/
lib
/
SmartShortcutsRanker
/
RankShortcuts
.
mjs
"
)
;
const
{
NewTabUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
NewTabUtils
.
sys
.
mjs
"
)
;
await
NewTabUtils
.
init
(
)
;
const
sandbox
=
sinon
.
createSandbox
(
)
;
const
stub
=
sandbox
.
stub
(
NewTabUtils
.
activityStreamProvider
"
executePlacesQuery
"
)
.
resolves
(
[
]
)
;
Assert
.
deepEqual
(
await
Ranker
.
fetchVisitCountsByGuid
(
[
]
"
moz_places
"
)
{
}
"
visit
counts
early
return
{
}
"
)
;
Assert
.
deepEqual
(
await
Ranker
.
fetchLast10VisitsByGuid
(
[
]
"
moz_historyvisits
"
"
moz_places
"
)
{
}
"
last10
early
return
{
}
"
)
;
Assert
.
deepEqual
(
await
Ranker
.
fetchBookmarkedFlags
(
[
]
"
moz_bookmarks
"
"
moz_places
"
)
{
}
"
bookmarks
early
return
{
}
"
)
;
Assert
.
deepEqual
(
await
Ranker
.
fetchDailyVisitsSpecific
(
[
]
"
moz_historyvisits
"
"
moz_places
"
)
{
}
"
daily
specific
early
return
{
}
"
)
;
Assert
.
deepEqual
(
await
Ranker
.
fetchHourlyVisitsSpecific
(
[
]
"
moz_historyvisits
"
"
moz_places
"
)
{
}
"
hourly
specific
early
return
{
}
"
)
;
Assert
.
equal
(
stub
.
callCount
0
"
no
DB
calls
for
early
-
return
functions
"
)
;
sandbox
.
restore
(
)
;
}
)
;
add_task
(
async
function
test_rankTopSites_sql_pipeline_happy_path
(
)
{
const
Ranker
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
newtab
/
lib
/
SmartShortcutsRanker
/
RankShortcuts
.
mjs
"
)
;
const
{
NewTabUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
NewTabUtils
.
sys
.
mjs
"
)
;
await
NewTabUtils
.
init
(
)
;
const
sandbox
=
sinon
.
createSandbox
(
)
;
const
nowFixed
=
Date
.
UTC
(
2025
0
1
12
0
0
)
;
const
clock
=
sandbox
.
useFakeTimers
(
{
now
:
nowFixed
}
)
;
const
topsites
=
[
{
guid
:
"
g1
"
url
:
"
https
:
/
/
g1
.
com
"
frecency
:
1000
}
{
guid
:
"
g2
"
url
:
"
https
:
/
/
g2
.
com
"
frecency
:
10
}
{
url
:
"
https
:
/
/
no
-
guid
.
com
"
}
]
;
const
provider
=
new
Ranker
.
RankShortcutsProvider
(
)
;
const
initialWeights
=
{
bmark
:
1
rece
:
1
freq
:
1
refre
:
1
hour
:
1
daily
:
1
bias
:
0
frec
:
0
}
;
const
fakeCache
=
{
weights
:
{
.
.
.
initialWeights
}
init_weights
:
{
.
.
.
initialWeights
}
norms
:
null
score_map
:
{
g1
:
{
final
:
0
}
g2
:
{
final
:
0
}
}
}
;
sandbox
.
stub
(
provider
.
sc_obj
"
get
"
)
.
resolves
(
fakeCache
)
;
const
setSpy
=
sandbox
.
stub
(
provider
.
sc_obj
"
set
"
)
.
resolves
(
)
;
const
execStub
=
sandbox
.
stub
(
NewTabUtils
.
activityStreamProvider
"
executePlacesQuery
"
)
.
callsFake
(
async
sql
=
>
{
const
s
=
String
(
sql
)
;
if
(
s
.
includes
(
"
FROM
moz_bookmarks
"
)
)
{
return
[
[
"
g1
"
2
]
[
"
g2
"
0
]
]
;
}
if
(
s
.
includes
(
"
COALESCE
(
p
.
visit_count
"
)
)
{
return
[
[
"
g1
"
42
]
[
"
g2
"
3
]
]
;
}
if
(
s
.
includes
(
"
LIMIT
10
"
)
&
&
s
.
includes
(
"
ORDER
BY
vv
.
visit_date
DESC
"
)
)
{
const
nowUs
=
nowFixed
*
1000
;
const
dayUs
=
864e8
;
return
[
[
"
g1
"
nowUs
2
]
[
"
g1
"
nowUs
-
1
*
Number
(
dayUs
)
1
]
[
"
g2
"
nowUs
-
10
*
Number
(
dayUs
)
1
]
]
;
}
if
(
s
.
includes
(
"
strftime
(
'
%
w
'
"
)
&
&
s
.
includes
(
"
GROUP
BY
place_ids
.
guid
"
)
)
{
return
[
[
"
g1
"
1
3
]
[
"
g1
"
2
2
]
[
"
g2
"
1
1
]
]
;
}
if
(
s
.
includes
(
"
strftime
(
'
%
w
'
"
)
&
&
!
s
.
includes
(
"
place_ids
.
guid
"
)
)
{
return
[
[
0
10
]
[
1
20
]
[
2
15
]
[
3
12
]
[
4
8
]
[
5
5
]
[
6
4
]
]
;
}
if
(
s
.
includes
(
"
strftime
(
'
%
H
'
"
)
&
&
s
.
includes
(
"
GROUP
BY
place_ids
.
guid
"
)
)
{
return
[
[
"
g1
"
9
5
]
[
"
g1
"
10
3
]
[
"
g2
"
9
1
]
]
;
}
if
(
s
.
includes
(
"
strftime
(
'
%
H
'
"
)
&
&
!
s
.
includes
(
"
place_ids
.
guid
"
)
)
{
return
Array
.
from
(
{
length
:
24
}
(
_
h
)
=
>
[
h
h
>
=
8
&
&
h
<
=
18
?
10
:
2
]
)
;
}
if
(
s
.
toLowerCase
(
)
.
includes
(
"
shortcut
"
)
|
|
s
.
toLowerCase
(
)
.
includes
(
"
smartshortcuts
"
)
)
{
return
[
]
;
}
return
[
]
;
}
)
;
const
prefValues
=
{
trainhopConfig
:
{
smartShortcuts
:
{
eta
:
0
click_bonus
:
10
positive_prior
:
1
negative_prior
:
1
fset
:
8
}
}
}
;
const
out
=
await
provider
.
rankTopSites
(
topsites
prefValues
{
isStartup
:
false
}
)
;
Assert
.
ok
(
Array
.
isArray
(
out
)
"
returns
an
array
"
)
;
Assert
.
equal
(
out
[
out
.
length
-
1
]
.
url
"
https
:
/
/
no
-
guid
.
com
"
"
no
-
guid
item
is
last
"
)
;
const
rankedGuids
=
out
.
filter
(
x
=
>
x
.
guid
)
.
map
(
x
=
>
x
.
guid
)
;
if
(
rankedGuids
.
length
=
=
=
2
)
{
Assert
.
strictEqual
(
rankedGuids
[
0
]
"
g1
"
expected
g1
to
outrank
g2
when
feature
set
includes
(
bmark
/
rece
/
freq
/
refre
/
hour
/
daily
)
;
got
{
rankedGuids
}
)
;
}
Assert
.
ok
(
setSpy
.
calledWith
(
"
norms
"
)
"
norms
written
to
cache
"
)
;
Assert
.
ok
(
setSpy
.
calledWith
(
"
score_map
"
)
"
score_map
written
to
cache
"
)
;
Assert
.
greater
(
execStub
.
callCount
0
"
executePlacesQuery
was
called
"
)
;
clock
.
restore
(
)
;
sandbox
.
restore
(
)
;
}
)
;
add_task
(
async
function
test_weightedSampleTopSites_open_feature_basic
(
)
{
const
Worker
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
newtab
/
lib
/
SmartShortcutsRanker
/
RankShortcutsWorkerClass
.
mjs
"
)
;
const
guid
=
[
"
g1
"
"
g2
"
"
g3
"
]
;
const
input
=
{
features
:
[
"
open
"
"
bias
"
]
guid
weights
:
{
open
:
1
bias
:
0
}
norms
:
{
open
:
null
}
open_scores
:
{
g1
:
1
g2
:
0
g3
:
1
}
}
;
const
out
=
await
Worker
.
weightedSampleTopSites
(
input
)
;
Assert
.
ok
(
out
&
&
out
.
score_map
&
&
out
.
norms
"
returns
{
score_map
norms
}
"
)
;
Assert
.
ok
(
out
.
norms
.
open
"
norms
include
'
open
'
"
)
;
const
s1
=
out
.
score_map
.
g1
.
open
;
const
s2
=
out
.
score_map
.
g2
.
open
;
const
s3
=
out
.
score_map
.
g3
.
open
;
Assert
.
greater
(
s1
s2
"
an
open
guid
should
score
higher
than
a
closed
one
"
)
;
Assert
.
greater
(
s3
s2
"
another
open
guid
should
score
higher
than
closed
"
)
;
Assert
.
equal
(
Math
.
abs
(
s1
-
s3
)
<
1e
-
12
true
"
two
open
guids
with
identical
inputs
get
identical
normalized
scores
"
)
;
Assert
.
equal
(
out
.
score_map
.
g1
.
final
s1
"
final
=
open
(
g1
)
"
)
;
Assert
.
equal
(
out
.
score_map
.
g2
.
final
s2
"
final
=
open
(
g2
)
"
)
;
Assert
.
equal
(
out
.
score_map
.
g3
.
final
s3
"
final
=
open
(
g3
)
"
)
;
}
)
;
add_task
(
async
function
test_weightedSampleTopSites_open_with_existing_norms
(
)
{
const
Worker
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
newtab
/
lib
/
SmartShortcutsRanker
/
RankShortcutsWorkerClass
.
mjs
"
)
;
const
guid
=
[
"
A
"
"
B
"
"
C
"
"
D
"
]
;
const
open_scores
=
{
A
:
0
B
:
1
C
:
0
D
:
1
}
;
const
prior
=
{
beta
:
1e
-
3
mean
:
0
.
5
var
:
1
.
0
}
;
const
input
=
{
features
:
[
"
open
"
"
bias
"
]
guid
weights
:
{
open
:
1
bias
:
0
}
norms
:
{
open
:
prior
}
open_scores
}
;
const
out
=
await
Worker
.
weightedSampleTopSites
(
input
)
;
Assert
.
ok
(
out
.
norms
.
open
"
open
norm
returned
"
)
;
Assert
.
notEqual
(
out
.
norms
.
open
.
mean
prior
.
mean
"
running
mean
updated
"
)
;
Assert
.
greater
(
out
.
norms
.
open
.
var
0
"
variance
stays
positive
"
)
;
const
finals
=
guid
.
map
(
g
=
>
out
.
score_map
[
g
]
.
final
)
;
const
maxClosed
=
Math
.
max
(
finals
[
0
]
finals
[
2
]
)
;
const
minOpen
=
Math
.
min
(
finals
[
1
]
finals
[
3
]
)
;
Assert
.
greater
(
minOpen
maxClosed
"
open
>
closed
after
normalization
"
)
;
}
)
;
add_task
(
async
function
test_buildFrecencyFeatures_unid_counts_unique_days
(
)
{
const
Ranker
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
newtab
/
lib
/
SmartShortcutsRanker
/
RankShortcutsWorkerClass
.
mjs
"
)
;
const
sandbox
=
sinon
.
createSandbox
(
)
;
const
nowMs
=
Date
.
UTC
(
2025
0
10
)
;
const
clock
=
sandbox
.
useFakeTimers
(
{
now
:
nowMs
}
)
;
const
us
=
ms
=
>
Math
.
round
(
ms
*
1000
)
;
const
dayMs
=
864e5
;
const
visitsByGuid
=
{
g1
:
[
{
visit_date_us
:
us
(
nowMs
)
visit_type
:
1
}
{
visit_date_us
:
us
(
nowMs
-
2
*
dayMs
)
visit_type
:
1
}
{
visit_date_us
:
us
(
nowMs
-
2
*
dayMs
)
visit_type
:
1
}
]
g2
:
[
{
visit_date_us
:
us
(
nowMs
-
7
*
dayMs
)
visit_type
:
1
}
]
}
;
const
visitCounts
=
{
g1
:
3
g2
:
1
}
;
const
out
=
await
Ranker
.
buildFrecencyFeatures
(
visitsByGuid
visitCounts
)
;
Assert
.
equal
(
out
.
unid
.
g1
2
"
g1
has
visits
on
2
unique
days
"
)
;
Assert
.
equal
(
out
.
unid
.
g2
1
"
g2
has
visits
on
1
unique
day
"
)
;
clock
.
restore
(
)
;
sandbox
.
restore
(
)
;
}
)
;
add_task
(
async
function
test_weightedSampleTopSites_unid_feature
(
)
{
const
Worker
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
newtab
/
lib
/
SmartShortcutsRanker
/
RankShortcutsWorkerClass
.
mjs
"
)
;
const
guids
=
[
"
a
"
"
b
"
]
;
const
input
=
{
features
:
[
"
unid
"
"
bias
"
]
guid
:
guids
unid_scores
:
{
a
:
5
b
:
1
}
norms
:
{
unid
:
null
}
weights
:
{
unid
:
1
bias
:
0
}
}
;
const
result
=
await
Worker
.
weightedSampleTopSites
(
input
)
;
Assert
.
ok
(
result
.
norms
.
unid
"
norms
include
'
unid
'
"
)
;
const
ua
=
result
.
score_map
.
a
.
unid
;
const
ub
=
result
.
score_map
.
b
.
unid
;
Assert
.
greater
(
ua
ub
"
site
with
more
unique
days
visited
scores
higher
"
)
;
Assert
.
equal
(
result
.
score_map
.
a
.
final
ua
"
final
equals
unid
score
(
a
)
"
)
;
Assert
.
equal
(
result
.
score_map
.
b
.
final
ub
"
final
equals
unid
score
(
b
)
"
)
;
}
)
;
add_task
(
async
function
test_weightedSampleTopSites_ctr_basic
(
)
{
const
Worker
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
newtab
/
lib
/
SmartShortcutsRanker
/
RankShortcutsWorkerClass
.
mjs
"
)
;
const
input
=
{
features
:
[
"
ctr
"
"
bias
"
]
guid
:
[
"
g1
"
"
g2
"
"
g3
"
]
clicks
:
[
9
1
0
]
impressions
:
[
10
10
0
]
norms
:
{
ctr
:
null
}
weights
:
{
ctr
:
1
bias
:
0
}
}
;
const
out
=
await
Worker
.
weightedSampleTopSites
(
input
)
;
Assert
.
ok
(
out
&
&
out
.
score_map
&
&
out
.
norms
"
returns
{
score_map
norms
}
"
)
;
Assert
.
ok
(
out
.
norms
.
ctr
"
returns
ctr
norms
"
)
;
const
s1
=
out
.
score_map
.
g1
.
ctr
;
const
s2
=
out
.
score_map
.
g2
.
ctr
;
const
s3
=
out
.
score_map
.
g3
.
ctr
;
Assert
.
greater
(
s3
s1
"
g3
(
1
.
0
smoothed
)
>
g1
(
~
0
.
909
)
"
)
;
Assert
.
greater
(
s1
s2
"
g1
(
~
0
.
909
)
>
g2
(
0
.
1
)
"
)
;
Assert
.
equal
(
out
.
score_map
.
g1
.
final
s1
"
final
equals
ctr
(
g1
)
"
)
;
Assert
.
equal
(
out
.
score_map
.
g2
.
final
s2
"
final
equals
ctr
(
g2
)
"
)
;
Assert
.
equal
(
out
.
score_map
.
g3
.
final
s3
"
final
equals
ctr
(
g3
)
"
)
;
}
)
;
add_task
(
async
function
test_weightedSampleTopSites_ctr_smoothing_zero_imps
(
)
{
const
Worker
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
newtab
/
lib
/
SmartShortcutsRanker
/
RankShortcutsWorkerClass
.
mjs
"
)
;
const
input
=
{
features
:
[
"
ctr
"
]
guid
:
[
"
gA
"
"
gB
"
]
clicks
:
[
0
5
]
impressions
:
[
0
0
]
norms
:
{
ctr
:
null
}
weights
:
{
ctr
:
1
}
}
;
const
out
=
await
Worker
.
weightedSampleTopSites
(
input
)
;
const
a
=
out
.
score_map
.
gA
.
ctr
;
const
b
=
out
.
score_map
.
gB
.
ctr
;
Assert
.
greater
(
b
a
"
higher
smoothed
CTR
should
score
higher
"
)
;
Assert
.
ok
(
Number
.
isFinite
(
a
)
&
&
Number
.
isFinite
(
b
)
"
scores
are
finite
"
)
;
}
)
;
add_task
(
async
function
test_weightedSampleTopSites_ctr_with_prior_norm
(
)
{
const
Worker
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
newtab
/
lib
/
SmartShortcutsRanker
/
RankShortcutsWorkerClass
.
mjs
"
)
;
const
prior
=
{
beta
:
1e
-
3
mean
:
0
.
3
var
:
1
.
0
}
;
const
input
=
{
features
:
[
"
ctr
"
]
guid
:
[
"
x
"
"
y
"
]
clicks
:
[
3
0
]
impressions
:
[
10
10
]
norms
:
{
ctr
:
prior
}
weights
:
{
ctr
:
1
}
}
;
const
out
=
await
Worker
.
weightedSampleTopSites
(
input
)
;
Assert
.
ok
(
out
.
norms
.
ctr
"
ctr
norm
returned
"
)
;
Assert
.
notEqual
(
out
.
norms
.
ctr
.
mean
prior
.
mean
"
running
mean
updated
"
)
;
Assert
.
greater
(
out
.
norms
.
ctr
.
var
0
"
variance
positive
"
)
;
const
x
=
out
.
score_map
.
x
.
ctr
;
const
y
=
out
.
score_map
.
y
.
ctr
;
Assert
.
greater
(
x
y
"
higher
ctr
ranks
higher
under
prior
normalization
"
)
;
}
)
;
add_task
(
async
function
test_fetchShortcutLastClickPositions_empty
(
)
{
const
Ranker
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
newtab
/
lib
/
SmartShortcutsRanker
/
RankShortcuts
.
mjs
"
)
;
const
out
=
await
Ranker
.
fetchShortcutLastClickPositions
(
[
]
"
smart_shortcuts
"
"
moz_places
"
)
;
Assert
.
deepEqual
(
out
[
]
"
empty
guid
list
empty
result
"
)
;
}
)
;
add_task
(
async
function
test_fetchShortcutLastClickPositions_happy_path_and_numImps
(
)
{
const
Ranker
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
newtab
/
lib
/
SmartShortcutsRanker
/
RankShortcuts
.
mjs
"
)
;
const
{
NewTabUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
NewTabUtils
.
sys
.
mjs
"
)
;
await
NewTabUtils
.
init
(
)
;
const
sandbox
=
sinon
.
createSandbox
(
)
;
const
guids
=
[
"
g1
"
"
g2
"
"
g3
"
]
;
const
numImps
=
7
;
const
execStub
=
sandbox
.
stub
(
NewTabUtils
.
activityStreamProvider
"
executePlacesQuery
"
)
.
callsFake
(
async
_sql
=
>
{
return
[
[
"
g1
"
3
]
[
"
g2
"
null
]
]
;
}
)
;
const
out
=
await
Ranker
.
fetchShortcutLastClickPositions
(
guids
"
smart_shortcuts
"
"
moz_places
"
numImps
)
;
Assert
.
deepEqual
(
out
[
3
null
null
]
"
aligned
array
:
g1
=
3
g2
=
null
g3
=
null
(
missing
null
)
"
)
;
Assert
.
greater
(
execStub
.
callCount
0
"
DB
was
queried
"
)
;
sandbox
.
restore
(
)
;
}
)
;
add_task
(
async
function
test_placeGuidsByPositions_basic_and_collisions
(
)
{
const
Ranker
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
newtab
/
lib
/
SmartShortcutsRanker
/
RankShortcutsWorkerClass
.
mjs
"
)
;
const
guids
=
[
"
a
"
"
b
"
"
c
"
"
d
"
]
;
const
pos
=
new
Map
(
Object
.
entries
(
{
a
:
1
b
:
1
c
:
3
d
:
null
}
)
)
;
const
out
=
Ranker
.
placeGuidsByPositions
(
guids
pos
)
;
Assert
.
deepEqual
(
out
[
"
b
"
"
a
"
"
d
"
"
c
"
]
"
collision
resolved
by
first
-
come
;
others
fill
holes
stably
"
)
;
}
)
;
add_task
(
async
function
test_placeGuidsByPositions_inferred_size
(
)
{
const
Ranker
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
newtab
/
lib
/
SmartShortcutsRanker
/
RankShortcutsWorkerClass
.
mjs
"
)
;
const
guids
=
[
"
p
"
"
q
"
]
;
const
pos
=
new
Map
(
Object
.
entries
(
{
p
:
0
q
:
null
}
)
)
;
const
out
=
Ranker
.
placeGuidsByPositions
(
guids
pos
)
;
Assert
.
equal
(
out
.
length
guids
.
length
"
default
size
inferred
to
guids
.
length
"
)
;
Assert
.
deepEqual
(
out
[
"
p
"
"
q
"
]
)
;
}
)
;
add_task
(
async
function
test_fetchShortcutLastClickPositions_empty
(
)
{
const
Ranker
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
newtab
/
lib
/
SmartShortcutsRanker
/
RankShortcuts
.
mjs
"
)
;
const
{
NewTabUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
NewTabUtils
.
sys
.
mjs
"
)
;
await
NewTabUtils
.
init
(
)
;
const
sandbox
=
sinon
.
createSandbox
(
)
;
const
stub
=
sandbox
.
stub
(
NewTabUtils
.
activityStreamProvider
"
executePlacesQuery
"
)
.
resolves
(
[
]
)
;
const
out
=
await
Ranker
.
fetchShortcutLastClickPositions
(
[
]
"
smart_shortcuts
"
"
moz_places
"
10
)
;
Assert
.
deepEqual
(
out
[
]
"
empty
guid
list
empty
result
"
)
;
Assert
.
equal
(
stub
.
callCount
0
"
no
DB
query
for
empty
input
"
)
;
sandbox
.
restore
(
)
;
}
)
;
add_task
(
async
function
test_placeGuidsByPositions_empty_inputs
(
)
{
const
Ranker
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
newtab
/
lib
/
SmartShortcutsRanker
/
RankShortcutsWorkerClass
.
mjs
"
)
;
{
const
out
=
Ranker
.
placeGuidsByPositions
(
[
]
new
Map
(
)
)
;
Assert
.
deepEqual
(
out
[
]
"
empty
empty
"
)
;
}
{
const
pos
=
new
Map
(
Object
.
entries
(
{
x
:
5
y
:
0
}
)
)
;
const
out
=
Ranker
.
placeGuidsByPositions
(
[
]
pos
)
;
Assert
.
deepEqual
(
out
[
]
"
no
guids
to
place
empty
result
"
)
;
}
}
)
;
add_task
(
async
function
test_placeGuidsByPositions_all_null_positions
(
)
{
const
Ranker
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
newtab
/
lib
/
SmartShortcutsRanker
/
RankShortcutsWorkerClass
.
mjs
"
)
;
const
guids
=
[
"
a
"
"
b
"
"
c
"
]
;
const
pos
=
new
Map
(
Object
.
entries
(
{
a
:
null
b
:
null
c
:
null
}
)
)
;
const
out
=
Ranker
.
placeGuidsByPositions
(
guids
pos
)
;
Assert
.
deepEqual
(
out
guids
"
all
null
stable
original
order
"
)
;
}
)
;
add_task
(
async
function
test_placeGuidsByPositions_plain_object_positions
(
)
{
const
Ranker
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
newtab
/
lib
/
SmartShortcutsRanker
/
RankShortcutsWorkerClass
.
mjs
"
)
;
const
guids
=
[
"
a
"
"
b
"
"
c
"
]
;
const
pos
=
new
Map
(
Object
.
entries
(
{
a
:
2
b
:
0
c
:
1
}
)
)
;
const
out
=
Ranker
.
placeGuidsByPositions
(
guids
pos
)
;
Assert
.
deepEqual
(
out
[
"
b
"
"
c
"
"
a
"
]
"
plain
object
map
works
"
)
;
}
)
;
add_task
(
async
function
test_placeGuidsByPositions_negative_and_noninteger
(
)
{
const
Ranker
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
newtab
/
lib
/
SmartShortcutsRanker
/
RankShortcutsWorkerClass
.
mjs
"
)
;
const
guids
=
[
"
a
"
"
b
"
"
c
"
"
d
"
]
;
const
pos
=
new
Map
(
Object
.
entries
(
{
a
:
-
1
b
:
1
.
7
c
:
0
d
:
null
}
)
)
;
const
out
=
Ranker
.
placeGuidsByPositions
(
guids
pos
)
;
Assert
.
deepEqual
(
out
[
"
c
"
"
a
"
"
b
"
"
d
"
]
"
negative
&
non
-
integer
treated
as
unpositioned
"
)
;
}
)
;
add_task
(
async
function
test_placeGuidsByPositions_large_position_goes_lastish
(
)
{
const
Ranker
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
newtab
/
lib
/
SmartShortcutsRanker
/
RankShortcutsWorkerClass
.
mjs
"
)
;
const
guids
=
[
"
a
"
"
b
"
"
c
"
]
;
const
pos
=
new
Map
(
Object
.
entries
(
{
a
:
5
b
:
null
c
:
null
}
)
)
;
const
out
=
Ranker
.
placeGuidsByPositions
(
guids
pos
)
;
const
nonNull
=
out
.
filter
(
x
=
>
x
!
=
=
null
)
;
Assert
.
ok
(
nonNull
.
includes
(
"
a
"
)
"
contains
'
a
'
"
)
;
const
idxB
=
nonNull
.
indexOf
(
"
b
"
)
;
const
idxC
=
nonNull
.
indexOf
(
"
c
"
)
;
Assert
.
greater
(
idxC
idxB
"
unpositioned
items
stay
in
input
order
(
b
before
c
)
"
)
;
}
)
;
add_task
(
async
function
test_applyStickyClicks_preserves_null_and_clamps_negative
(
)
{
const
Worker
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
newtab
/
lib
/
SmartShortcutsRanker
/
RankShortcutsWorkerClass
.
mjs
"
)
;
const
guids
=
[
"
g1
"
"
g2
"
"
g3
"
]
;
const
positions
=
[
3
null
1
]
;
const
numSponsored
=
2
;
const
out
=
Worker
.
applyStickyClicks
(
positions
guids
numSponsored
)
;
Assert
.
deepEqual
(
out
[
"
g3
"
"
g1
"
"
g2
"
]
"
null
preserved
negatives
clamped
to
0
"
)
;
}
)
;
add_task
(
async
function
test_applyStickyClicks_undefined_numSponsored_defaults_zero
(
)
{
const
Worker
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
newtab
/
lib
/
SmartShortcutsRanker
/
RankShortcutsWorkerClass
.
mjs
"
)
;
const
guids
=
[
"
g1
"
"
g2
"
]
;
const
positions
=
[
4
null
]
;
const
out
=
Worker
.
applyStickyClicks
(
positions
guids
undefined
)
;
Assert
.
ok
(
out
.
includes
(
"
g1
"
)
&
&
out
.
includes
(
"
g2
"
)
"
both
guids
present
"
)
;
}
)
;
function
prefsFor
(
features
extra
=
{
}
)
{
const
baseWeights
=
{
thom_weight
:
0
frec_weight
:
0
hour_weight
:
0
daily_weight
:
0
bmark_weight
:
0
rece_weight
:
0
freq_weight
:
0
refre_weight
:
0
open_weight
:
0
unid_weight
:
0
ctr_weight
:
0
bias_weight
:
100
}
;
for
(
const
f
of
features
)
{
const
key
=
{
thom
:
"
thom_weight
"
frec
:
"
frec_weight
"
hour
:
"
hour_weight
"
daily
:
"
daily_weight
"
bmark
:
"
bmark_weight
"
rece
:
"
rece_weight
"
freq
:
"
freq_weight
"
refre
:
"
refre_weight
"
open
:
"
open_weight
"
unid
:
"
unid_weight
"
ctr
:
"
ctr_weight
"
bias
:
"
bias_weight
"
}
[
f
]
;
if
(
key
)
{
baseWeights
[
key
]
=
100
;
}
}
return
{
trainhopConfig
:
{
smartShortcuts
:
{
features
eta
:
0
click_bonus
:
10
positive_prior
:
1
negative_prior
:
1
sticky_numimps
:
0
.
.
.
baseWeights
.
.
.
extra
}
}
}
;
}
function
attachLocalWorker
(
provider
WorkerMod
)
{
provider
.
_rankShortcutsWorker
=
{
async
post
(
name
args
)
{
const
fn
=
WorkerMod
[
name
]
|
|
new
WorkerMod
.
RankShortcutsWorker
(
)
[
name
]
;
if
(
typeof
fn
=
=
=
"
function
"
)
{
return
Array
.
isArray
(
args
)
?
fn
(
.
.
.
args
)
:
fn
(
args
)
;
}
throw
new
Error
(
No
worker
function
for
{
name
}
)
;
}
}
;
}
function
stubDB
(
sinon
NewTabUtils
nowFixed
)
{
return
sinon
.
stub
(
NewTabUtils
.
activityStreamProvider
"
executePlacesQuery
"
)
.
callsFake
(
async
sql
=
>
{
const
s
=
String
(
sql
)
;
if
(
s
.
includes
(
"
FROM
moz_bookmarks
"
)
)
{
return
[
[
"
g1
"
1
]
[
"
g2
"
0
]
[
"
g3
"
0
]
]
;
}
if
(
s
.
includes
(
"
COALESCE
(
p
.
visit_count
"
)
)
{
return
[
[
"
g1
"
20
]
[
"
g2
"
10
]
[
"
g3
"
5
]
]
;
}
if
(
s
.
includes
(
"
LIMIT
10
"
)
&
&
s
.
includes
(
"
ORDER
BY
vv
.
visit_date
DESC
"
)
)
{
const
us
=
ms
=
>
Math
.
round
(
ms
*
1000
)
;
const
day
=
864e5
;
return
[
[
"
g1
"
us
(
nowFixed
)
2
]
[
"
g1
"
us
(
nowFixed
-
day
)
1
]
[
"
g2
"
us
(
nowFixed
-
2
*
day
)
1
]
[
"
g3
"
us
(
nowFixed
-
10
*
day
)
1
]
]
;
}
if
(
s
.
includes
(
"
strftime
(
'
%
w
'
"
)
&
&
s
.
includes
(
"
GROUP
BY
place_ids
.
guid
"
)
)
{
return
[
[
"
g1
"
1
3
]
[
"
g2
"
1
1
]
]
;
}
if
(
s
.
includes
(
"
strftime
(
'
%
w
'
"
)
&
&
!
s
.
includes
(
"
place_ids
.
guid
"
)
)
{
return
[
[
0
10
]
[
1
20
]
[
2
15
]
[
3
12
]
[
4
8
]
[
5
5
]
[
6
4
]
]
;
}
if
(
s
.
includes
(
"
strftime
(
'
%
H
'
"
)
&
&
s
.
includes
(
"
GROUP
BY
place_ids
.
guid
"
)
)
{
return
[
[
"
g1
"
9
5
]
[
"
g2
"
10
1
]
]
;
}
if
(
s
.
includes
(
"
strftime
(
'
%
H
'
"
)
&
&
!
s
.
includes
(
"
place_ids
.
guid
"
)
)
{
return
Array
.
from
(
{
length
:
24
}
(
_
h
)
=
>
[
h
h
>
=
8
&
&
h
<
=
18
?
10
:
2
]
)
;
}
if
(
s
.
includes
(
"
moz_newtab_shortcuts_interaction
"
)
&
&
s
.
includes
(
"
SUM
(
"
)
)
{
return
[
[
"
g1
"
5
10
]
[
"
g2
"
1
10
]
[
"
g3
"
0
0
]
]
;
}
if
(
s
.
includes
(
"
ROW_NUMBER
(
)
"
)
&
&
s
.
includes
(
"
tile_position
"
)
)
{
return
[
[
"
g1
"
3
]
[
"
g2
"
null
]
[
"
g3
"
null
]
]
;
}
return
[
]
;
}
)
;
}
add_task
(
async
function
test_rankTopSites_feature_matrix
(
)
{
const
Ranker
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
newtab
/
lib
/
SmartShortcutsRanker
/
RankShortcuts
.
mjs
"
)
;
const
Worker
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
newtab
/
lib
/
SmartShortcutsRanker
/
RankShortcutsWorkerClass
.
mjs
"
)
;
const
{
NewTabUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
NewTabUtils
.
sys
.
mjs
"
)
;
const
{
sinon
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
Sinon
.
sys
.
mjs
"
)
;
await
NewTabUtils
.
init
(
)
;
const
sandbox
=
sinon
.
createSandbox
(
)
;
const
nowFixed
=
Date
.
UTC
(
2025
0
1
12
0
0
)
;
const
clock
=
sandbox
.
useFakeTimers
(
{
now
:
nowFixed
}
)
;
const
provider
=
new
Ranker
.
RankShortcutsProvider
(
)
;
attachLocalWorker
(
provider
Worker
)
;
const
fakeCache
=
{
weights
:
{
}
init_weights
:
{
}
norms
:
null
score_map
:
{
g1
:
{
final
:
0
}
g2
:
{
final
:
0
}
g3
:
{
final
:
0
}
}
time_last_update
:
0
}
;
sandbox
.
stub
(
provider
.
sc_obj
"
get
"
)
.
resolves
(
fakeCache
)
;
sandbox
.
stub
(
provider
.
sc_obj
"
set
"
)
.
resolves
(
)
;
const
dbStub
=
stubDB
(
sandbox
NewTabUtils
nowFixed
)
;
const
topsites
=
[
{
guid
:
"
g1
"
url
:
"
https
:
/
/
g1
"
frecency
:
100
}
{
guid
:
"
g2
"
url
:
"
https
:
/
/
g2
"
frecency
:
10
}
{
guid
:
"
g3
"
url
:
"
https
:
/
/
g3
"
frecency
:
1
}
{
url
:
"
https
:
/
/
no
-
guid
"
}
]
;
const
ALL
=
[
"
thom
"
"
frec
"
"
hour
"
"
daily
"
"
bmark
"
"
rece
"
"
freq
"
"
refre
"
"
unid
"
"
ctr
"
"
bias
"
]
;
const
singles
=
ALL
.
map
(
f
=
>
[
f
]
)
;
const
pairs
=
[
[
"
frec
"
"
bias
"
]
[
"
thom
"
"
bias
"
]
[
"
ctr
"
"
bias
"
]
[
"
bmark
"
"
bias
"
]
[
"
rece
"
"
freq
"
]
]
;
const
triples
=
[
[
"
frec
"
"
thom
"
"
bias
"
]
[
"
rece
"
"
freq
"
"
refre
"
]
]
;
const
cases
=
[
.
.
.
singles
.
.
.
pairs
.
.
.
triples
]
;
for
(
const
features
of
cases
)
{
const
prefs
=
prefsFor
(
features
{
sticky_numimps
:
0
}
)
;
const
out
=
await
provider
.
rankTopSites
(
topsites
prefs
{
isStartup
:
true
}
0
)
;
Assert
.
ok
(
Array
.
isArray
(
out
)
(
{
features
}
)
returns
array
)
;
Assert
.
equal
(
out
.
length
topsites
.
length
(
{
features
}
)
length
stable
)
;
Assert
.
equal
(
out
[
out
.
length
-
1
]
.
url
"
https
:
/
/
no
-
guid
"
(
{
features
}
)
no
-
guid
item
is
last
)
;
const
inGuids
=
topsites
.
filter
(
x
=
>
x
.
guid
)
.
map
(
x
=
>
x
.
guid
)
.
sort
(
)
;
const
outGuids
=
out
.
filter
(
x
=
>
x
.
guid
)
.
map
(
x
=
>
x
.
guid
)
.
sort
(
)
;
Assert
.
deepEqual
(
outGuids
inGuids
(
{
features
}
)
guids
preserved
)
;
}
Assert
.
greater
(
dbStub
.
callCount
0
"
DB
stub
used
at
least
once
"
)
;
clock
.
restore
(
)
;
sandbox
.
restore
(
)
;
}
)
;
