var
NewtabRenderUtils
;
(
(
)
=
>
{
"
use
strict
"
;
var
__webpack_require__
=
{
}
;
(
(
)
=
>
{
__webpack_require__
.
n
=
(
module
)
=
>
{
var
getter
=
module
&
&
module
.
__esModule
?
(
)
=
>
(
module
[
'
default
'
]
)
:
(
)
=
>
(
module
)
;
__webpack_require__
.
d
(
getter
{
a
:
getter
}
)
;
return
getter
;
}
;
}
)
(
)
;
(
(
)
=
>
{
__webpack_require__
.
d
=
(
exports
definition
)
=
>
{
for
(
var
key
in
definition
)
{
if
(
__webpack_require__
.
o
(
definition
key
)
&
&
!
__webpack_require__
.
o
(
exports
key
)
)
{
Object
.
defineProperty
(
exports
key
{
enumerable
:
true
get
:
definition
[
key
]
}
)
;
}
}
}
;
}
)
(
)
;
(
(
)
=
>
{
__webpack_require__
.
g
=
(
function
(
)
{
if
(
typeof
globalThis
=
=
=
'
object
'
)
return
globalThis
;
try
{
return
this
|
|
new
Function
(
'
return
this
'
)
(
)
;
}
catch
(
e
)
{
if
(
typeof
window
=
=
=
'
object
'
)
return
window
;
}
}
)
(
)
;
}
)
(
)
;
(
(
)
=
>
{
__webpack_require__
.
o
=
(
obj
prop
)
=
>
(
Object
.
prototype
.
hasOwnProperty
.
call
(
obj
prop
)
)
}
)
(
)
;
(
(
)
=
>
{
__webpack_require__
.
r
=
(
exports
)
=
>
{
if
(
typeof
Symbol
!
=
=
'
undefined
'
&
&
Symbol
.
toStringTag
)
{
Object
.
defineProperty
(
exports
Symbol
.
toStringTag
{
value
:
'
Module
'
}
)
;
}
Object
.
defineProperty
(
exports
'
__esModule
'
{
value
:
true
}
)
;
}
;
}
)
(
)
;
var
__webpack_exports__
=
{
}
;
__webpack_require__
.
r
(
__webpack_exports__
)
;
__webpack_require__
.
d
(
__webpack_exports__
{
NewTab
:
(
)
=
>
(
NewTab
)
renderCache
:
(
)
=
>
(
renderCache
)
renderWithoutState
:
(
)
=
>
(
renderWithoutState
)
}
)
;
;
const
MAIN_MESSAGE_TYPE
=
"
ActivityStream
:
Main
"
;
const
CONTENT_MESSAGE_TYPE
=
"
ActivityStream
:
Content
"
;
const
PRELOAD_MESSAGE_TYPE
=
"
ActivityStream
:
PreloadedBrowser
"
;
const
UI_CODE
=
1
;
const
BACKGROUND_PROCESS
=
2
;
const
globalImportContext
=
typeof
Window
=
=
=
"
undefined
"
?
BACKGROUND_PROCESS
:
UI_CODE
;
const
actionTypes
=
{
}
;
for
(
const
type
of
[
"
ABOUT_SPONSORED_TOP_SITES
"
"
ADDONS_INFO_REQUEST
"
"
ADDONS_INFO_RESPONSE
"
"
ADS_FEED_UPDATE
"
"
ADS_INIT
"
"
ADS_RESET
"
"
ADS_UPDATE_SPOCS
"
"
ADS_UPDATE_TILES
"
"
BLOCK_SECTION
"
"
BLOCK_URL
"
"
BOOKMARK_URL
"
"
CARD_SECTION_IMPRESSION
"
"
CLEAR_PREF
"
"
COPY_DOWNLOAD_LINK
"
"
DELETE_BOOKMARK_BY_ID
"
"
DELETE_HISTORY_URL
"
"
DIALOG_CANCEL
"
"
DIALOG_CLOSE
"
"
DIALOG_OPEN
"
"
DISABLE_SEARCH
"
"
DISCOVERY_STREAM_COLLECTION_DISMISSIBLE_TOGGLE
"
"
DISCOVERY_STREAM_CONFIG_CHANGE
"
"
DISCOVERY_STREAM_CONFIG_RESET
"
"
DISCOVERY_STREAM_CONFIG_RESET_DEFAULTS
"
"
DISCOVERY_STREAM_CONFIG_SETUP
"
"
DISCOVERY_STREAM_CONFIG_SET_VALUE
"
"
DISCOVERY_STREAM_DEV_BLOCKS
"
"
DISCOVERY_STREAM_DEV_BLOCKS_RESET
"
"
DISCOVERY_STREAM_DEV_EXPIRE_CACHE
"
"
DISCOVERY_STREAM_DEV_IDLE_DAILY
"
"
DISCOVERY_STREAM_DEV_IMPRESSIONS
"
"
DISCOVERY_STREAM_DEV_SHOW_PLACEHOLDER
"
"
DISCOVERY_STREAM_DEV_SYNC_RS
"
"
DISCOVERY_STREAM_DEV_SYSTEM_TICK
"
"
DISCOVERY_STREAM_EXPERIMENT_DATA
"
"
DISCOVERY_STREAM_FEEDS_UPDATE
"
"
DISCOVERY_STREAM_FEED_UPDATE
"
"
DISCOVERY_STREAM_IMPRESSION_STATS
"
"
DISCOVERY_STREAM_LAYOUT_RESET
"
"
DISCOVERY_STREAM_LAYOUT_UPDATE
"
"
DISCOVERY_STREAM_LINK_BLOCKED
"
"
DISCOVERY_STREAM_LOADED_CONTENT
"
"
DISCOVERY_STREAM_PERSONALIZATION_INIT
"
"
DISCOVERY_STREAM_PERSONALIZATION_LAST_UPDATED
"
"
DISCOVERY_STREAM_PERSONALIZATION_OVERRIDE
"
"
DISCOVERY_STREAM_PERSONALIZATION_RESET
"
"
DISCOVERY_STREAM_PERSONALIZATION_TOGGLE
"
"
DISCOVERY_STREAM_PERSONALIZATION_UPDATED
"
"
DISCOVERY_STREAM_POCKET_STATE_INIT
"
"
DISCOVERY_STREAM_POCKET_STATE_SET
"
"
DISCOVERY_STREAM_PREFS_SETUP
"
"
DISCOVERY_STREAM_RECENT_SAVES
"
"
DISCOVERY_STREAM_RETRY_FEED
"
"
DISCOVERY_STREAM_SPOCS_CAPS
"
"
DISCOVERY_STREAM_SPOCS_ENDPOINT
"
"
DISCOVERY_STREAM_SPOCS_PLACEMENTS
"
"
DISCOVERY_STREAM_SPOCS_UPDATE
"
"
DISCOVERY_STREAM_SPOC_BLOCKED
"
"
DISCOVERY_STREAM_SPOC_IMPRESSION
"
"
DISCOVERY_STREAM_TOPICS_LOADING
"
"
DISCOVERY_STREAM_USER_EVENT
"
"
DOWNLOAD_CHANGED
"
"
FAKESPOT_CTA_CLICK
"
"
FAKESPOT_DISMISS
"
"
FAKE_FOCUS_SEARCH
"
"
FILL_SEARCH_TERM
"
"
FOLLOW_SECTION
"
"
HANDOFF_SEARCH_TO_AWESOMEBAR
"
"
HIDE_PERSONALIZE
"
"
HIDE_PRIVACY_INFO
"
"
HIDE_TOAST_MESSAGE
"
"
INFERRED_PERSONALIZATION_MODEL_UPDATE
"
"
INFERRED_PERSONALIZATION_REFRESH
"
"
INFERRED_PERSONALIZATION_RESET
"
"
INFERRED_PERSONALIZATION_UPDATE
"
"
INIT
"
"
INLINE_SELECTION_CLICK
"
"
INLINE_SELECTION_IMPRESSION
"
"
MESSAGE_BLOCK
"
"
MESSAGE_CLICK
"
"
MESSAGE_DISMISS
"
"
MESSAGE_IMPRESSION
"
"
MESSAGE_NOTIFY_VISIBILITY
"
"
MESSAGE_SET
"
"
MESSAGE_TOGGLE_VISIBILITY
"
"
NEW_TAB_INIT
"
"
NEW_TAB_INITIAL_STATE
"
"
NEW_TAB_LOAD
"
"
NEW_TAB_REHYDRATED
"
"
NEW_TAB_STATE_REQUEST
"
"
NEW_TAB_STATE_REQUEST_STARTUPCACHE
"
"
NEW_TAB_STATE_REQUEST_WITHOUT_STARTUPCACHE
"
"
NEW_TAB_UNLOAD
"
"
OPEN_ABOUT_FAKESPOT
"
"
OPEN_DOWNLOAD_FILE
"
"
OPEN_LINK
"
"
OPEN_NEW_WINDOW
"
"
OPEN_PRIVATE_WINDOW
"
"
OPEN_WEBEXT_SETTINGS
"
"
PARTNER_LINK_ATTRIBUTION
"
"
PLACES_BOOKMARKS_REMOVED
"
"
PLACES_BOOKMARK_ADDED
"
"
PLACES_HISTORY_CLEARED
"
"
PLACES_LINKS_CHANGED
"
"
PLACES_LINKS_DELETED
"
"
PLACES_LINK_BLOCKED
"
"
POCKET_CTA
"
"
POCKET_LOGGED_IN
"
"
POCKET_THUMBS_DOWN
"
"
POCKET_THUMBS_UP
"
"
POCKET_WAITING_FOR_SPOC
"
"
PREFS_INITIAL_VALUES
"
"
PREF_CHANGED
"
"
PREVIEW_REQUEST
"
"
PREVIEW_REQUEST_CANCEL
"
"
PREVIEW_RESPONSE
"
"
REMOVE_DOWNLOAD_FILE
"
"
REPORT_AD_OPEN
"
"
REPORT_AD_SUBMIT
"
"
REPORT_CLOSE
"
"
REPORT_CONTENT_OPEN
"
"
REPORT_CONTENT_SUBMIT
"
"
RICH_ICON_MISSING
"
"
SAVE_SESSION_PERF_DATA
"
"
SCREENSHOT_UPDATED
"
"
SECTION_DEREGISTER
"
"
SECTION_DISABLE
"
"
SECTION_ENABLE
"
"
SECTION_OPTIONS_CHANGED
"
"
SECTION_PERSONALIZATION_SET
"
"
SECTION_PERSONALIZATION_UPDATE
"
"
SECTION_REGISTER
"
"
SECTION_UPDATE
"
"
SECTION_UPDATE_CARD
"
"
SETTINGS_CLOSE
"
"
SETTINGS_OPEN
"
"
SET_PREF
"
"
SHOW_DOWNLOAD_FILE
"
"
SHOW_FIREFOX_ACCOUNTS
"
"
SHOW_PERSONALIZE
"
"
SHOW_PRIVACY_INFO
"
"
SHOW_SEARCH
"
"
SHOW_TOAST_MESSAGE
"
"
SKIPPED_SIGNIN
"
"
SOV_UPDATED
"
"
SUBMIT_EMAIL
"
"
SUBMIT_SIGNIN
"
"
SYSTEM_TICK
"
"
TELEMETRY_IMPRESSION_STATS
"
"
TELEMETRY_USER_EVENT
"
"
TOPIC_SELECTION_IMPRESSION
"
"
TOPIC_SELECTION_MAYBE_LATER
"
"
TOPIC_SELECTION_SPOTLIGHT_CLOSE
"
"
TOPIC_SELECTION_SPOTLIGHT_OPEN
"
"
TOPIC_SELECTION_USER_DISMISS
"
"
TOPIC_SELECTION_USER_OPEN
"
"
TOPIC_SELECTION_USER_SAVE
"
"
TOP_SITES_ADD
"
"
TOP_SITES_CANCEL_EDIT
"
"
TOP_SITES_CLOSE_SEARCH_SHORTCUTS_MODAL
"
"
TOP_SITES_EDIT
"
"
TOP_SITES_INSERT
"
"
TOP_SITES_OPEN_SEARCH_SHORTCUTS_MODAL
"
"
TOP_SITES_ORGANIC_IMPRESSION_STATS
"
"
TOP_SITES_PIN
"
"
TOP_SITES_PREFS_UPDATED
"
"
TOP_SITES_SPONSORED_IMPRESSION_STATS
"
"
TOP_SITES_UNPIN
"
"
TOP_SITES_UPDATED
"
"
TOTAL_BOOKMARKS_REQUEST
"
"
TOTAL_BOOKMARKS_RESPONSE
"
"
TRENDING_SEARCH_IMPRESSION
"
"
TRENDING_SEARCH_SUGGESTION_OPEN
"
"
TRENDING_SEARCH_TOGGLE_COLLAPSE
"
"
TRENDING_SEARCH_UPDATE
"
"
UNBLOCK_SECTION
"
"
UNFOLLOW_SECTION
"
"
UNINIT
"
"
UPDATE_PINNED_SEARCH_SHORTCUTS
"
"
UPDATE_SEARCH_SHORTCUTS
"
"
WALLPAPERS_CATEGORY_SET
"
"
WALLPAPERS_CUSTOM_SET
"
"
WALLPAPERS_FEATURE_HIGHLIGHT_COUNTER_INCREMENT
"
"
WALLPAPERS_FEATURE_HIGHLIGHT_CTA_CLICKED
"
"
WALLPAPERS_FEATURE_HIGHLIGHT_DISMISSED
"
"
WALLPAPERS_FEATURE_HIGHLIGHT_SEEN
"
"
WALLPAPERS_SET
"
"
WALLPAPER_CATEGORY_CLICK
"
"
WALLPAPER_CLICK
"
"
WALLPAPER_REMOVE_UPLOAD
"
"
WALLPAPER_UPLOAD
"
"
WEATHER_IMPRESSION
"
"
WEATHER_LOAD_ERROR
"
"
WEATHER_LOCATION_DATA_UPDATE
"
"
WEATHER_LOCATION_SEARCH_UPDATE
"
"
WEATHER_LOCATION_SUGGESTIONS_UPDATE
"
"
WEATHER_OPEN_PROVIDER_URL
"
"
WEATHER_QUERY_UPDATE
"
"
WEATHER_SEARCH_ACTIVE
"
"
WEATHER_UPDATE
"
"
WEBEXT_CLICK
"
"
WEBEXT_DISMISS
"
"
WIDGETS_LISTS_CHANGE_SELECTED
"
"
WIDGETS_LISTS_SET
"
"
WIDGETS_LISTS_SET_SELECTED
"
"
WIDGETS_LISTS_UPDATE
"
"
WIDGETS_LISTS_USER_EVENT
"
"
WIDGETS_LISTS_USER_IMPRESSION
"
"
WIDGETS_TIMER_END
"
"
WIDGETS_TIMER_PAUSE
"
"
WIDGETS_TIMER_PLAY
"
"
WIDGETS_TIMER_RESET
"
"
WIDGETS_TIMER_SET
"
"
WIDGETS_TIMER_SET_DURATION
"
"
WIDGETS_TIMER_SET_TYPE
"
"
WIDGETS_TIMER_USER_EVENT
"
"
WIDGETS_TIMER_USER_IMPRESSION
"
]
)
{
actionTypes
[
type
]
=
type
;
}
function
_RouteMessage
(
action
options
)
{
const
meta
=
action
.
meta
?
{
.
.
.
action
.
meta
}
:
{
}
;
if
(
!
options
|
|
!
options
.
from
|
|
!
options
.
to
)
{
throw
new
Error
(
"
Routed
Messages
must
have
options
as
the
second
parameter
and
must
at
least
include
a
.
from
and
.
to
property
.
"
)
;
}
[
"
from
"
"
to
"
"
toTarget
"
"
fromTarget
"
"
skipMain
"
"
skipLocal
"
]
.
forEach
(
o
=
>
{
if
(
typeof
options
[
o
]
!
=
=
"
undefined
"
)
{
meta
[
o
]
=
options
[
o
]
;
}
else
if
(
meta
[
o
]
)
{
delete
meta
[
o
]
;
}
}
)
;
return
{
.
.
.
action
meta
}
;
}
function
AlsoToMain
(
action
fromTarget
skipLocal
)
{
return
_RouteMessage
(
action
{
from
:
CONTENT_MESSAGE_TYPE
to
:
MAIN_MESSAGE_TYPE
fromTarget
skipLocal
}
)
;
}
function
OnlyToMain
(
action
fromTarget
)
{
return
AlsoToMain
(
action
fromTarget
true
)
;
}
function
BroadcastToContent
(
action
)
{
return
_RouteMessage
(
action
{
from
:
MAIN_MESSAGE_TYPE
to
:
CONTENT_MESSAGE_TYPE
}
)
;
}
function
AlsoToOneContent
(
action
target
skipMain
)
{
if
(
!
target
)
{
throw
new
Error
(
"
You
must
provide
a
target
ID
as
the
second
parameter
of
AlsoToOneContent
.
If
you
want
to
send
to
all
content
processes
use
BroadcastToContent
"
)
;
}
return
_RouteMessage
(
action
{
from
:
MAIN_MESSAGE_TYPE
to
:
CONTENT_MESSAGE_TYPE
toTarget
:
target
skipMain
}
)
;
}
function
OnlyToOneContent
(
action
target
)
{
return
AlsoToOneContent
(
action
target
true
)
;
}
function
AlsoToPreloaded
(
action
)
{
return
_RouteMessage
(
action
{
from
:
MAIN_MESSAGE_TYPE
to
:
PRELOAD_MESSAGE_TYPE
}
)
;
}
function
UserEvent
(
data
)
{
return
AlsoToMain
(
{
type
:
actionTypes
.
TELEMETRY_USER_EVENT
data
}
)
;
}
function
DiscoveryStreamUserEvent
(
data
)
{
return
AlsoToMain
(
{
type
:
actionTypes
.
DISCOVERY_STREAM_USER_EVENT
data
}
)
;
}
function
ImpressionStats
(
data
importContext
=
globalImportContext
)
{
const
action
=
{
type
:
actionTypes
.
TELEMETRY_IMPRESSION_STATS
data
}
;
return
importContext
=
=
=
UI_CODE
?
AlsoToMain
(
action
)
:
action
;
}
function
DiscoveryStreamImpressionStats
(
data
importContext
=
globalImportContext
)
{
const
action
=
{
type
:
actionTypes
.
DISCOVERY_STREAM_IMPRESSION_STATS
data
}
;
return
importContext
=
=
=
UI_CODE
?
AlsoToMain
(
action
)
:
action
;
}
function
DiscoveryStreamLoadedContent
(
data
importContext
=
globalImportContext
)
{
const
action
=
{
type
:
actionTypes
.
DISCOVERY_STREAM_LOADED_CONTENT
data
}
;
return
importContext
=
=
=
UI_CODE
?
AlsoToMain
(
action
)
:
action
;
}
function
SetPref
(
prefName
value
importContext
=
globalImportContext
)
{
const
action
=
{
type
:
actionTypes
.
SET_PREF
data
:
{
name
:
prefName
value
}
}
;
return
importContext
=
=
=
UI_CODE
?
AlsoToMain
(
action
)
:
action
;
}
function
WebExtEvent
(
type
data
importContext
=
globalImportContext
)
{
if
(
!
data
|
|
!
data
.
source
)
{
throw
new
Error
(
'
WebExtEvent
actions
should
include
a
property
"
source
"
the
id
of
the
webextension
that
should
receive
the
event
.
'
)
;
}
const
action
=
{
type
data
}
;
return
importContext
=
=
=
UI_CODE
?
AlsoToMain
(
action
)
:
action
;
}
const
actionCreators
=
{
BroadcastToContent
UserEvent
DiscoveryStreamUserEvent
ImpressionStats
AlsoToOneContent
OnlyToOneContent
AlsoToMain
OnlyToMain
AlsoToPreloaded
SetPref
WebExtEvent
DiscoveryStreamImpressionStats
DiscoveryStreamLoadedContent
}
;
const
actionUtils
=
{
isSendToMain
(
action
)
{
if
(
!
action
.
meta
)
{
return
false
;
}
return
(
action
.
meta
.
to
=
=
=
MAIN_MESSAGE_TYPE
&
&
action
.
meta
.
from
=
=
=
CONTENT_MESSAGE_TYPE
)
;
}
isBroadcastToContent
(
action
)
{
if
(
!
action
.
meta
)
{
return
false
;
}
if
(
action
.
meta
.
to
=
=
=
CONTENT_MESSAGE_TYPE
&
&
!
action
.
meta
.
toTarget
)
{
return
true
;
}
return
false
;
}
isSendToOneContent
(
action
)
{
if
(
!
action
.
meta
)
{
return
false
;
}
if
(
action
.
meta
.
to
=
=
=
CONTENT_MESSAGE_TYPE
&
&
action
.
meta
.
toTarget
)
{
return
true
;
}
return
false
;
}
isSendToPreloaded
(
action
)
{
if
(
!
action
.
meta
)
{
return
false
;
}
return
(
action
.
meta
.
to
=
=
=
PRELOAD_MESSAGE_TYPE
&
&
action
.
meta
.
from
=
=
=
MAIN_MESSAGE_TYPE
)
;
}
isFromMain
(
action
)
{
if
(
!
action
.
meta
)
{
return
false
;
}
return
(
action
.
meta
.
from
=
=
=
MAIN_MESSAGE_TYPE
&
&
action
.
meta
.
to
=
=
=
CONTENT_MESSAGE_TYPE
)
;
}
getPortIdOfSender
(
action
)
{
return
(
action
.
meta
&
&
action
.
meta
.
fromTarget
)
|
|
null
;
}
_RouteMessage
}
;
;
const
external_ReactRedux_namespaceObject
=
ReactRedux
;
;
const
external_React_namespaceObject
=
React
;
var
external_React_default
=
__webpack_require__
.
n
(
external_React_namespaceObject
)
;
;
class
SimpleHashRouter
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
onHashChange
=
this
.
onHashChange
.
bind
(
this
)
;
this
.
state
=
{
hash
:
globalThis
.
location
.
hash
}
;
}
onHashChange
(
)
{
this
.
setState
(
{
hash
:
globalThis
.
location
.
hash
}
)
;
}
componentWillMount
(
)
{
globalThis
.
addEventListener
(
"
hashchange
"
this
.
onHashChange
)
;
}
componentWillUnmount
(
)
{
globalThis
.
removeEventListener
(
"
hashchange
"
this
.
onHashChange
)
;
}
render
(
)
{
const
[
.
.
.
routes
]
=
this
.
state
.
hash
.
split
(
"
-
"
)
;
return
external_React_default
(
)
.
cloneElement
(
this
.
props
.
children
{
location
:
{
hash
:
this
.
state
.
hash
routes
}
}
)
;
}
}
;
function
_extends
(
)
{
return
_extends
=
Object
.
assign
?
Object
.
assign
.
bind
(
)
:
function
(
n
)
{
for
(
var
e
=
1
;
e
<
arguments
.
length
;
e
+
+
)
{
var
t
=
arguments
[
e
]
;
for
(
var
r
in
t
)
(
{
}
)
.
hasOwnProperty
.
call
(
t
r
)
&
&
(
n
[
r
]
=
t
[
r
]
)
;
}
return
n
;
}
_extends
.
apply
(
null
arguments
)
;
}
const
PREF_AD_SIZE_MEDIUM_RECTANGLE
=
"
newtabAdSize
.
mediumRectangle
"
;
const
PREF_AD_SIZE_BILLBOARD
=
"
newtabAdSize
.
billboard
"
;
const
PREF_AD_SIZE_LEADERBOARD
=
"
newtabAdSize
.
leaderboard
"
;
const
PREF_CONTEXTUAL_CONTENT_SELECTED_FEED
=
"
discoverystream
.
contextualContent
.
selectedFeed
"
;
const
PREF_CONTEXTUAL_CONTENT_FEEDS
=
"
discoverystream
.
contextualContent
.
feeds
"
;
const
PREF_SECTIONS_ENABLED
=
"
discoverystream
.
sections
.
enabled
"
;
const
PREF_SPOC_PLACEMENTS
=
"
discoverystream
.
placements
.
spocs
"
;
const
PREF_SPOC_COUNTS
=
"
discoverystream
.
placements
.
spocs
.
counts
"
;
const
PREF_CONTEXTUAL_ADS_ENABLED
=
"
discoverystream
.
sections
.
contextualAds
.
enabled
"
;
const
PREF_CONTEXTUAL_BANNER_PLACEMENTS
=
"
discoverystream
.
placements
.
contextualBanners
"
;
const
PREF_CONTEXTUAL_BANNER_COUNTS
=
"
discoverystream
.
placements
.
contextualBanners
.
counts
"
;
const
Row
=
props
=
>
external_React_default
(
)
.
createElement
(
"
tr
"
_extends
(
{
className
:
"
message
-
item
"
}
props
)
props
.
children
)
;
function
relativeTime
(
timestamp
)
{
if
(
!
timestamp
)
{
return
"
"
;
}
const
seconds
=
Math
.
floor
(
(
Date
.
now
(
)
-
timestamp
)
/
1000
)
;
const
minutes
=
Math
.
floor
(
(
Date
.
now
(
)
-
timestamp
)
/
60000
)
;
if
(
seconds
<
2
)
{
return
"
just
now
"
;
}
else
if
(
seconds
<
60
)
{
return
{
seconds
}
seconds
ago
;
}
else
if
(
minutes
=
=
=
1
)
{
return
"
1
minute
ago
"
;
}
else
if
(
minutes
<
600
)
{
return
{
minutes
}
minutes
ago
;
}
return
new
Date
(
timestamp
)
.
toLocaleString
(
)
;
}
class
ToggleStoryButton
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
handleClick
=
this
.
handleClick
.
bind
(
this
)
;
}
handleClick
(
)
{
this
.
props
.
onClick
(
this
.
props
.
story
)
;
}
render
(
)
{
return
external_React_default
(
)
.
createElement
(
"
button
"
{
onClick
:
this
.
handleClick
}
"
collapse
/
open
"
)
;
}
}
class
TogglePrefCheckbox
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
onChange
=
this
.
onChange
.
bind
(
this
)
;
}
onChange
(
event
)
{
this
.
props
.
onChange
(
this
.
props
.
pref
event
.
target
.
checked
)
;
}
render
(
)
{
return
external_React_default
(
)
.
createElement
(
(
external_React_default
(
)
)
.
Fragment
null
external_React_default
(
)
.
createElement
(
"
input
"
{
type
:
"
checkbox
"
checked
:
this
.
props
.
checked
onChange
:
this
.
onChange
disabled
:
this
.
props
.
disabled
}
)
"
"
this
.
props
.
pref
"
"
)
;
}
}
class
Personalization
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
togglePersonalization
=
this
.
togglePersonalization
.
bind
(
this
)
;
}
togglePersonalization
(
)
{
this
.
props
.
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
DISCOVERY_STREAM_PERSONALIZATION_TOGGLE
}
)
)
;
}
render
(
)
{
const
{
lastUpdated
initialized
}
=
this
.
props
.
state
.
Personalization
;
return
external_React_default
(
)
.
createElement
(
(
external_React_default
(
)
)
.
Fragment
null
external_React_default
(
)
.
createElement
(
"
table
"
null
external_React_default
(
)
.
createElement
(
"
tbody
"
null
external_React_default
(
)
.
createElement
(
Row
null
external_React_default
(
)
.
createElement
(
"
td
"
{
colSpan
:
"
2
"
}
external_React_default
(
)
.
createElement
(
TogglePrefCheckbox
{
checked
:
this
.
props
.
personalized
pref
:
"
personalized
"
onChange
:
this
.
togglePersonalization
}
)
)
)
external_React_default
(
)
.
createElement
(
Row
null
external_React_default
(
)
.
createElement
(
"
td
"
{
className
:
"
min
"
}
"
Personalization
Last
Updated
"
)
external_React_default
(
)
.
createElement
(
"
td
"
null
relativeTime
(
lastUpdated
)
|
|
"
(
no
data
)
"
)
)
external_React_default
(
)
.
createElement
(
Row
null
external_React_default
(
)
.
createElement
(
"
td
"
{
className
:
"
min
"
}
"
Personalization
Initialized
"
)
external_React_default
(
)
.
createElement
(
"
td
"
null
initialized
?
"
true
"
:
"
false
"
)
)
)
)
)
;
}
}
class
DiscoveryStreamAdminUI
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
restorePrefDefaults
=
this
.
restorePrefDefaults
.
bind
(
this
)
;
this
.
setConfigValue
=
this
.
setConfigValue
.
bind
(
this
)
;
this
.
expireCache
=
this
.
expireCache
.
bind
(
this
)
;
this
.
refreshCache
=
this
.
refreshCache
.
bind
(
this
)
;
this
.
showPlaceholder
=
this
.
showPlaceholder
.
bind
(
this
)
;
this
.
idleDaily
=
this
.
idleDaily
.
bind
(
this
)
;
this
.
systemTick
=
this
.
systemTick
.
bind
(
this
)
;
this
.
syncRemoteSettings
=
this
.
syncRemoteSettings
.
bind
(
this
)
;
this
.
onStoryToggle
=
this
.
onStoryToggle
.
bind
(
this
)
;
this
.
handleWeatherSubmit
=
this
.
handleWeatherSubmit
.
bind
(
this
)
;
this
.
handleWeatherUpdate
=
this
.
handleWeatherUpdate
.
bind
(
this
)
;
this
.
resetBlocks
=
this
.
resetBlocks
.
bind
(
this
)
;
this
.
refreshInferredPersonalization
=
this
.
refreshInferredPersonalization
.
bind
(
this
)
;
this
.
refreshTopicSelectionCache
=
this
.
refreshTopicSelectionCache
.
bind
(
this
)
;
this
.
toggleTBRFeed
=
this
.
toggleTBRFeed
.
bind
(
this
)
;
this
.
handleSectionsToggle
=
this
.
handleSectionsToggle
.
bind
(
this
)
;
this
.
toggleIABBanners
=
this
.
toggleIABBanners
.
bind
(
this
)
;
this
.
state
=
{
toggledStories
:
{
}
weatherQuery
:
"
"
}
;
}
setConfigValue
(
configName
configValue
)
{
this
.
props
.
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
DISCOVERY_STREAM_CONFIG_SET_VALUE
data
:
{
name
:
configName
value
:
configValue
}
}
)
)
;
}
restorePrefDefaults
(
)
{
this
.
props
.
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
DISCOVERY_STREAM_CONFIG_RESET_DEFAULTS
}
)
)
;
}
refreshCache
(
)
{
const
{
config
}
=
this
.
props
.
state
.
DiscoveryStream
;
this
.
props
.
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
DISCOVERY_STREAM_CONFIG_CHANGE
data
:
config
}
)
)
;
}
refreshInferredPersonalization
(
)
{
this
.
props
.
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
INFERRED_PERSONALIZATION_REFRESH
}
)
)
;
}
refreshTopicSelectionCache
(
)
{
this
.
props
.
dispatch
(
actionCreators
.
SetPref
(
"
discoverystream
.
topicSelection
.
onboarding
.
displayCount
"
0
)
)
;
this
.
props
.
dispatch
(
actionCreators
.
SetPref
(
"
discoverystream
.
topicSelection
.
onboarding
.
maybeDisplay
"
true
)
)
;
}
dispatchSimpleAction
(
type
)
{
this
.
props
.
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
}
)
)
;
}
resetBlocks
(
)
{
this
.
props
.
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
DISCOVERY_STREAM_DEV_BLOCKS_RESET
}
)
)
;
}
systemTick
(
)
{
this
.
dispatchSimpleAction
(
actionTypes
.
DISCOVERY_STREAM_DEV_SYSTEM_TICK
)
;
}
expireCache
(
)
{
this
.
dispatchSimpleAction
(
actionTypes
.
DISCOVERY_STREAM_DEV_EXPIRE_CACHE
)
;
}
showPlaceholder
(
)
{
this
.
dispatchSimpleAction
(
actionTypes
.
DISCOVERY_STREAM_DEV_SHOW_PLACEHOLDER
)
;
}
toggleTBRFeed
(
e
)
{
const
feed
=
e
.
target
.
value
;
const
selectedFeed
=
PREF_CONTEXTUAL_CONTENT_SELECTED_FEED
;
this
.
props
.
dispatch
(
actionCreators
.
SetPref
(
selectedFeed
feed
)
)
;
}
idleDaily
(
)
{
this
.
dispatchSimpleAction
(
actionTypes
.
DISCOVERY_STREAM_DEV_IDLE_DAILY
)
;
}
syncRemoteSettings
(
)
{
this
.
dispatchSimpleAction
(
actionTypes
.
DISCOVERY_STREAM_DEV_SYNC_RS
)
;
}
handleWeatherUpdate
(
e
)
{
this
.
setState
(
{
weatherQuery
:
e
.
target
.
value
|
|
"
"
}
)
;
}
handleWeatherSubmit
(
e
)
{
e
.
preventDefault
(
)
;
const
{
weatherQuery
}
=
this
.
state
;
this
.
props
.
dispatch
(
actionCreators
.
SetPref
(
"
weather
.
query
"
weatherQuery
)
)
;
}
toggleIABBanners
(
e
)
{
const
{
pressed
id
}
=
e
.
target
;
switch
(
id
)
{
case
"
newtab_billboard
"
:
this
.
props
.
dispatch
(
actionCreators
.
SetPref
(
PREF_AD_SIZE_BILLBOARD
pressed
)
)
;
break
;
case
"
newtab_leaderboard
"
:
this
.
props
.
dispatch
(
actionCreators
.
SetPref
(
PREF_AD_SIZE_LEADERBOARD
pressed
)
)
;
break
;
case
"
newtab_rectangle
"
:
this
.
props
.
dispatch
(
actionCreators
.
SetPref
(
PREF_AD_SIZE_MEDIUM_RECTANGLE
pressed
)
)
;
break
;
}
const
generateSpocPrefValues
=
(
)
=
>
{
const
placements
=
this
.
props
.
otherPrefs
[
PREF_SPOC_PLACEMENTS
]
?
.
split
(
"
"
)
.
map
(
item
=
>
item
.
trim
(
)
)
.
filter
(
item
=
>
item
)
|
|
[
]
;
const
counts
=
this
.
props
.
otherPrefs
[
PREF_SPOC_COUNTS
]
?
.
split
(
"
"
)
.
map
(
item
=
>
item
.
trim
(
)
)
.
filter
(
item
=
>
item
)
|
|
[
]
;
const
supportIABAdTypes
=
[
"
newtab_leaderboard
"
"
newtab_rectangle
"
"
newtab_billboard
"
]
;
let
countValue
;
if
(
supportIABAdTypes
.
includes
(
id
)
)
{
countValue
=
"
1
"
;
}
else
{
throw
new
Error
(
"
IAB
ad
type
not
supported
"
)
;
}
if
(
pressed
)
{
if
(
!
placements
.
includes
(
id
)
)
{
placements
.
push
(
id
)
;
counts
.
push
(
countValue
)
;
}
}
else
{
const
index
=
placements
.
indexOf
(
id
)
;
if
(
index
!
=
=
-
1
)
{
placements
.
splice
(
index
1
)
;
counts
.
splice
(
index
1
)
;
}
}
return
{
placements
:
placements
.
join
(
"
"
)
counts
:
counts
.
join
(
"
"
)
}
;
}
;
const
{
placements
counts
}
=
generateSpocPrefValues
(
)
;
this
.
props
.
dispatch
(
actionCreators
.
SetPref
(
PREF_SPOC_PLACEMENTS
placements
)
)
;
this
.
props
.
dispatch
(
actionCreators
.
SetPref
(
PREF_SPOC_COUNTS
counts
)
)
;
if
(
PREF_CONTEXTUAL_ADS_ENABLED
&
&
PREF_SECTIONS_ENABLED
)
{
if
(
PREF_AD_SIZE_BILLBOARD
&
&
placements
.
includes
(
"
newtab_billboard
"
)
)
{
this
.
props
.
dispatch
(
actionCreators
.
SetPref
(
PREF_CONTEXTUAL_BANNER_PLACEMENTS
"
newtab_billboard
"
)
)
;
this
.
props
.
dispatch
(
actionCreators
.
SetPref
(
PREF_CONTEXTUAL_BANNER_COUNTS
"
1
"
)
)
;
}
else
if
(
PREF_AD_SIZE_LEADERBOARD
&
&
placements
.
includes
(
"
newtab_leaderboard
"
)
)
{
this
.
props
.
dispatch
(
actionCreators
.
SetPref
(
PREF_CONTEXTUAL_BANNER_PLACEMENTS
"
newtab_leaderboard
"
)
)
;
this
.
props
.
dispatch
(
actionCreators
.
SetPref
(
PREF_CONTEXTUAL_BANNER_COUNTS
"
1
"
)
)
;
}
else
{
this
.
props
.
dispatch
(
actionCreators
.
SetPref
(
PREF_CONTEXTUAL_BANNER_PLACEMENTS
"
"
)
)
;
this
.
props
.
dispatch
(
actionCreators
.
SetPref
(
PREF_CONTEXTUAL_BANNER_COUNTS
"
"
)
)
;
}
}
}
handleSectionsToggle
(
e
)
{
const
{
pressed
}
=
e
.
target
;
this
.
props
.
dispatch
(
actionCreators
.
SetPref
(
PREF_SECTIONS_ENABLED
pressed
)
)
;
this
.
props
.
dispatch
(
actionCreators
.
SetPref
(
"
discoverystream
.
sections
.
cards
.
enabled
"
pressed
)
)
;
this
.
props
.
dispatch
(
actionCreators
.
SetPref
(
"
discoverystream
.
sections
.
cards
.
thumbsUpDown
.
enabled
"
pressed
)
)
;
}
renderComponent
(
width
component
)
{
return
external_React_default
(
)
.
createElement
(
"
table
"
null
external_React_default
(
)
.
createElement
(
"
tbody
"
null
external_React_default
(
)
.
createElement
(
Row
null
external_React_default
(
)
.
createElement
(
"
td
"
{
className
:
"
min
"
}
"
Type
"
)
external_React_default
(
)
.
createElement
(
"
td
"
null
component
.
type
)
)
external_React_default
(
)
.
createElement
(
Row
null
external_React_default
(
)
.
createElement
(
"
td
"
{
className
:
"
min
"
}
"
Width
"
)
external_React_default
(
)
.
createElement
(
"
td
"
null
width
)
)
component
.
feed
&
&
this
.
renderFeed
(
component
.
feed
)
)
)
;
}
renderWeatherData
(
)
{
const
{
suggestions
}
=
this
.
props
.
state
.
Weather
;
let
weatherTable
;
if
(
suggestions
)
{
weatherTable
=
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
weather
-
section
"
}
external_React_default
(
)
.
createElement
(
"
form
"
{
onSubmit
:
this
.
handleWeatherSubmit
}
external_React_default
(
)
.
createElement
(
"
label
"
{
htmlFor
:
"
weather
-
query
"
}
"
Weather
query
"
)
external_React_default
(
)
.
createElement
(
"
input
"
{
type
:
"
text
"
min
:
"
3
"
max
:
"
10
"
id
:
"
weather
-
query
"
onChange
:
this
.
handleWeatherUpdate
value
:
this
.
weatherQuery
}
)
external_React_default
(
)
.
createElement
(
"
button
"
{
type
:
"
submit
"
}
"
Submit
"
)
)
external_React_default
(
)
.
createElement
(
"
table
"
null
external_React_default
(
)
.
createElement
(
"
tbody
"
null
suggestions
.
map
(
suggestion
=
>
external_React_default
(
)
.
createElement
(
"
tr
"
{
className
:
"
message
-
item
"
key
:
suggestion
.
city_name
}
external_React_default
(
)
.
createElement
(
"
td
"
{
className
:
"
message
-
id
"
}
external_React_default
(
)
.
createElement
(
"
span
"
null
suggestion
.
city_name
"
"
external_React_default
(
)
.
createElement
(
"
br
"
null
)
)
)
external_React_default
(
)
.
createElement
(
"
td
"
{
className
:
"
message
-
summary
"
}
external_React_default
(
)
.
createElement
(
"
pre
"
null
JSON
.
stringify
(
suggestion
null
2
)
)
)
)
)
)
)
)
;
}
return
weatherTable
;
}
renderPersonalizationData
(
)
{
const
{
inferredInterests
coarseInferredInterests
coarsePrivateInferredInterests
}
=
this
.
props
.
state
.
InferredPersonalization
;
return
external_React_default
(
)
.
createElement
(
"
div
"
null
"
"
"
Inferred
Intrests
:
"
external_React_default
(
)
.
createElement
(
"
pre
"
null
JSON
.
stringify
(
inferredInterests
null
2
)
)
"
Coarse
Inferred
Interests
:
"
external_React_default
(
)
.
createElement
(
"
pre
"
null
JSON
.
stringify
(
coarseInferredInterests
null
2
)
)
"
Coarse
Inferred
Interests
With
Differential
Privacy
:
"
external_React_default
(
)
.
createElement
(
"
pre
"
null
JSON
.
stringify
(
coarsePrivateInferredInterests
null
2
)
)
)
;
}
renderFeedData
(
url
)
{
const
{
feeds
}
=
this
.
props
.
state
.
DiscoveryStream
;
const
feed
=
feeds
.
data
[
url
]
.
data
;
return
external_React_default
(
)
.
createElement
(
(
external_React_default
(
)
)
.
Fragment
null
external_React_default
(
)
.
createElement
(
"
h4
"
null
"
Feed
url
:
"
url
)
external_React_default
(
)
.
createElement
(
"
table
"
null
external_React_default
(
)
.
createElement
(
"
tbody
"
null
feed
.
recommendations
?
.
map
(
story
=
>
this
.
renderStoryData
(
story
)
)
)
)
)
;
}
renderFeedsData
(
)
{
const
{
feeds
}
=
this
.
props
.
state
.
DiscoveryStream
;
return
external_React_default
(
)
.
createElement
(
(
external_React_default
(
)
)
.
Fragment
null
Object
.
keys
(
feeds
.
data
)
.
map
(
url
=
>
this
.
renderFeedData
(
url
)
)
)
;
}
renderImpressionsData
(
)
{
const
{
impressions
}
=
this
.
props
.
state
.
DiscoveryStream
;
return
external_React_default
(
)
.
createElement
(
(
external_React_default
(
)
)
.
Fragment
null
external_React_default
(
)
.
createElement
(
"
h4
"
null
"
Feed
Impressions
"
)
external_React_default
(
)
.
createElement
(
"
table
"
null
external_React_default
(
)
.
createElement
(
"
tbody
"
null
Object
.
keys
(
impressions
.
feed
)
.
map
(
key
=
>
{
return
external_React_default
(
)
.
createElement
(
Row
{
key
:
key
}
external_React_default
(
)
.
createElement
(
"
td
"
{
className
:
"
min
"
}
key
)
external_React_default
(
)
.
createElement
(
"
td
"
null
relativeTime
(
impressions
.
feed
[
key
]
)
|
|
"
(
no
data
)
"
)
)
;
}
)
)
)
)
;
}
renderBlocksData
(
)
{
const
{
blocks
}
=
this
.
props
.
state
.
DiscoveryStream
;
return
external_React_default
(
)
.
createElement
(
(
external_React_default
(
)
)
.
Fragment
null
external_React_default
(
)
.
createElement
(
"
h4
"
null
"
Blocks
"
)
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
"
button
"
onClick
:
this
.
resetBlocks
}
"
Reset
Blocks
"
)
"
"
external_React_default
(
)
.
createElement
(
"
table
"
null
external_React_default
(
)
.
createElement
(
"
tbody
"
null
Object
.
keys
(
blocks
)
.
map
(
key
=
>
{
return
external_React_default
(
)
.
createElement
(
Row
{
key
:
key
}
external_React_default
(
)
.
createElement
(
"
td
"
{
className
:
"
min
"
}
key
)
)
;
}
)
)
)
)
;
}
renderSpocs
(
)
{
const
{
spocs
}
=
this
.
props
.
state
.
DiscoveryStream
;
const
unifiedAdsSpocsEnabled
=
this
.
props
.
otherPrefs
[
"
unifiedAds
.
spocs
.
enabled
"
]
;
const
PREF_UNIFIED_ADS_ADSFEED_ENABLED
=
"
unifiedAds
.
adsFeed
.
enabled
"
;
const
adsFeedEnabled
=
this
.
props
.
otherPrefs
[
PREF_UNIFIED_ADS_ADSFEED_ENABLED
]
;
const
unifiedAdsEndpoint
=
this
.
props
.
otherPrefs
[
"
unifiedAds
.
endpoint
"
]
;
let
spocsData
=
[
]
;
if
(
spocs
.
data
&
&
spocs
.
data
.
newtab_spocs
&
&
spocs
.
data
.
newtab_spocs
.
items
)
{
spocsData
=
spocs
.
data
.
newtab_spocs
.
items
|
|
[
]
;
}
return
external_React_default
(
)
.
createElement
(
(
external_React_default
(
)
)
.
Fragment
null
external_React_default
(
)
.
createElement
(
"
table
"
null
external_React_default
(
)
.
createElement
(
"
tbody
"
null
external_React_default
(
)
.
createElement
(
Row
null
external_React_default
(
)
.
createElement
(
"
td
"
{
className
:
"
min
"
}
"
adsfeed
enabled
"
)
external_React_default
(
)
.
createElement
(
"
td
"
null
adsFeedEnabled
?
"
true
"
:
"
false
"
)
)
external_React_default
(
)
.
createElement
(
Row
null
external_React_default
(
)
.
createElement
(
"
td
"
{
className
:
"
min
"
}
"
spocs_endpoint
"
)
external_React_default
(
)
.
createElement
(
"
td
"
null
unifiedAdsSpocsEnabled
?
unifiedAdsEndpoint
:
spocs
.
spocs_endpoint
)
)
external_React_default
(
)
.
createElement
(
Row
null
external_React_default
(
)
.
createElement
(
"
td
"
{
className
:
"
min
"
}
"
Data
last
fetched
"
)
external_React_default
(
)
.
createElement
(
"
td
"
null
relativeTime
(
spocs
.
lastUpdated
)
)
)
)
)
external_React_default
(
)
.
createElement
(
"
h4
"
null
"
Spoc
data
"
)
external_React_default
(
)
.
createElement
(
"
table
"
null
external_React_default
(
)
.
createElement
(
"
tbody
"
null
spocsData
.
map
(
spoc
=
>
this
.
renderStoryData
(
spoc
)
)
)
)
external_React_default
(
)
.
createElement
(
"
h4
"
null
"
Spoc
frequency
caps
"
)
external_React_default
(
)
.
createElement
(
"
table
"
null
external_React_default
(
)
.
createElement
(
"
tbody
"
null
spocs
.
frequency_caps
.
map
(
spoc
=
>
this
.
renderStoryData
(
spoc
)
)
)
)
)
;
}
onStoryToggle
(
story
)
{
const
{
toggledStories
}
=
this
.
state
;
this
.
setState
(
{
toggledStories
:
{
.
.
.
toggledStories
[
story
.
id
]
:
!
toggledStories
[
story
.
id
]
}
}
)
;
}
renderStoryData
(
story
)
{
let
storyData
=
"
"
;
if
(
this
.
state
.
toggledStories
[
story
.
id
]
)
{
storyData
=
JSON
.
stringify
(
story
null
2
)
;
}
return
external_React_default
(
)
.
createElement
(
"
tr
"
{
className
:
"
message
-
item
"
key
:
story
.
id
}
external_React_default
(
)
.
createElement
(
"
td
"
{
className
:
"
message
-
id
"
}
external_React_default
(
)
.
createElement
(
"
span
"
null
story
.
id
"
"
external_React_default
(
)
.
createElement
(
"
br
"
null
)
)
external_React_default
(
)
.
createElement
(
ToggleStoryButton
{
story
:
story
onClick
:
this
.
onStoryToggle
}
)
)
external_React_default
(
)
.
createElement
(
"
td
"
{
className
:
"
message
-
summary
"
}
external_React_default
(
)
.
createElement
(
"
pre
"
null
storyData
)
)
)
;
}
renderFeed
(
feed
)
{
const
{
feeds
}
=
this
.
props
.
state
.
DiscoveryStream
;
if
(
!
feed
.
url
)
{
return
null
;
}
return
external_React_default
(
)
.
createElement
(
(
external_React_default
(
)
)
.
Fragment
null
external_React_default
(
)
.
createElement
(
Row
null
external_React_default
(
)
.
createElement
(
"
td
"
{
className
:
"
min
"
}
"
Feed
url
"
)
external_React_default
(
)
.
createElement
(
"
td
"
null
feed
.
url
)
)
external_React_default
(
)
.
createElement
(
Row
null
external_React_default
(
)
.
createElement
(
"
td
"
{
className
:
"
min
"
}
"
Data
last
fetched
"
)
external_React_default
(
)
.
createElement
(
"
td
"
null
relativeTime
(
feeds
.
data
[
feed
.
url
]
?
feeds
.
data
[
feed
.
url
]
.
lastUpdated
:
null
)
|
|
"
(
no
data
)
"
)
)
)
;
}
render
(
)
{
const
prefToggles
=
"
enabled
collapsible
"
.
split
(
"
"
)
;
const
{
config
layout
}
=
this
.
props
.
state
.
DiscoveryStream
;
const
personalized
=
this
.
props
.
otherPrefs
[
"
discoverystream
.
personalization
.
enabled
"
]
;
const
selectedFeed
=
this
.
props
.
otherPrefs
[
PREF_CONTEXTUAL_CONTENT_SELECTED_FEED
]
;
const
sectionsEnabled
=
this
.
props
.
otherPrefs
[
PREF_SECTIONS_ENABLED
]
;
const
TBRFeeds
=
this
.
props
.
otherPrefs
[
PREF_CONTEXTUAL_CONTENT_FEEDS
]
.
split
(
"
"
)
.
map
(
s
=
>
s
.
trim
(
)
)
.
filter
(
item
=
>
item
)
;
const
mediumRectangleEnabled
=
this
.
props
.
otherPrefs
[
PREF_AD_SIZE_MEDIUM_RECTANGLE
]
;
const
billboardsEnabled
=
this
.
props
.
otherPrefs
[
PREF_AD_SIZE_BILLBOARD
]
;
const
leaderboardEnabled
=
this
.
props
.
otherPrefs
[
PREF_AD_SIZE_LEADERBOARD
]
;
const
spocPlacements
=
this
.
props
.
otherPrefs
[
PREF_SPOC_PLACEMENTS
]
;
const
mediumRectangleEnabledPressed
=
mediumRectangleEnabled
&
&
spocPlacements
.
includes
(
"
newtab_rectangle
"
)
;
const
billboardPressed
=
billboardsEnabled
&
&
spocPlacements
.
includes
(
"
newtab_billboard
"
)
;
const
leaderboardPressed
=
leaderboardEnabled
&
&
spocPlacements
.
includes
(
"
newtab_leaderboard
"
)
;
return
external_React_default
(
)
.
createElement
(
"
div
"
null
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
"
button
"
onClick
:
this
.
restorePrefDefaults
}
"
Restore
Pref
Defaults
"
)
"
"
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
"
button
"
onClick
:
this
.
refreshCache
}
"
Refresh
Cache
"
)
external_React_default
(
)
.
createElement
(
"
br
"
null
)
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
"
button
"
onClick
:
this
.
expireCache
}
"
Expire
Cache
"
)
"
"
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
"
button
"
onClick
:
this
.
systemTick
}
"
Trigger
System
Tick
"
)
"
"
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
"
button
"
onClick
:
this
.
idleDaily
}
"
Trigger
Idle
Daily
"
)
external_React_default
(
)
.
createElement
(
"
br
"
null
)
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
"
button
"
onClick
:
this
.
refreshInferredPersonalization
}
"
Refresh
Inferred
Personalization
"
)
external_React_default
(
)
.
createElement
(
"
br
"
null
)
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
"
button
"
onClick
:
this
.
syncRemoteSettings
}
"
Sync
Remote
Settings
"
)
"
"
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
"
button
"
onClick
:
this
.
refreshTopicSelectionCache
}
"
Refresh
Topic
selection
count
"
)
external_React_default
(
)
.
createElement
(
"
br
"
null
)
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
"
button
"
onClick
:
this
.
showPlaceholder
}
"
Show
Placeholder
Cards
"
)
"
"
external_React_default
(
)
.
createElement
(
"
select
"
{
className
:
"
button
"
onChange
:
this
.
toggleTBRFeed
value
:
selectedFeed
}
TBRFeeds
.
map
(
feed
=
>
external_React_default
(
)
.
createElement
(
"
option
"
{
key
:
feed
value
:
feed
}
feed
)
)
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
toggle
-
wrapper
"
}
external_React_default
(
)
.
createElement
(
"
moz
-
toggle
"
{
id
:
"
sections
-
toggle
"
pressed
:
sectionsEnabled
|
|
null
onToggle
:
this
.
handleSectionsToggle
label
:
"
Toggle
DS
Sections
"
}
)
)
external_React_default
(
)
.
createElement
(
"
details
"
{
className
:
"
details
-
section
"
}
external_React_default
(
)
.
createElement
(
"
summary
"
null
"
IAB
Banner
Ad
Sizes
"
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
toggle
-
wrapper
"
}
external_React_default
(
)
.
createElement
(
"
moz
-
toggle
"
{
id
:
"
newtab_leaderboard
"
pressed
:
leaderboardPressed
|
|
null
onToggle
:
this
.
toggleIABBanners
label
:
"
Enable
IAB
Leaderboard
"
}
)
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
toggle
-
wrapper
"
}
external_React_default
(
)
.
createElement
(
"
moz
-
toggle
"
{
id
:
"
newtab_billboard
"
pressed
:
billboardPressed
|
|
null
onToggle
:
this
.
toggleIABBanners
label
:
"
Enable
IAB
Billboard
"
}
)
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
toggle
-
wrapper
"
}
external_React_default
(
)
.
createElement
(
"
moz
-
toggle
"
{
id
:
"
newtab_rectangle
"
pressed
:
mediumRectangleEnabledPressed
|
|
null
onToggle
:
this
.
toggleIABBanners
label
:
"
Enable
IAB
Medium
Rectangle
(
MREC
)
"
}
)
)
)
external_React_default
(
)
.
createElement
(
"
table
"
null
external_React_default
(
)
.
createElement
(
"
tbody
"
null
prefToggles
.
map
(
pref
=
>
external_React_default
(
)
.
createElement
(
Row
{
key
:
pref
}
external_React_default
(
)
.
createElement
(
"
td
"
null
external_React_default
(
)
.
createElement
(
TogglePrefCheckbox
{
checked
:
config
[
pref
]
pref
:
pref
onChange
:
this
.
setConfigValue
}
)
)
)
)
)
)
external_React_default
(
)
.
createElement
(
"
h3
"
null
"
Layout
"
)
layout
.
map
(
(
row
rowIndex
)
=
>
external_React_default
(
)
.
createElement
(
"
div
"
{
key
:
row
-
{
rowIndex
}
}
row
.
components
.
map
(
(
component
componentIndex
)
=
>
external_React_default
(
)
.
createElement
(
"
div
"
{
key
:
component
-
{
componentIndex
}
className
:
"
ds
-
component
"
}
this
.
renderComponent
(
row
.
width
component
)
)
)
)
)
external_React_default
(
)
.
createElement
(
"
h3
"
null
"
Personalization
"
)
external_React_default
(
)
.
createElement
(
Personalization
{
personalized
:
personalized
dispatch
:
this
.
props
.
dispatch
state
:
{
Personalization
:
this
.
props
.
state
.
Personalization
}
}
)
external_React_default
(
)
.
createElement
(
"
h3
"
null
"
Spocs
"
)
this
.
renderSpocs
(
)
external_React_default
(
)
.
createElement
(
"
h3
"
null
"
Feeds
Data
"
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
large
-
data
-
container
"
}
this
.
renderFeedsData
(
)
)
external_React_default
(
)
.
createElement
(
"
h3
"
null
"
Impressions
Data
"
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
large
-
data
-
container
"
}
this
.
renderImpressionsData
(
)
)
external_React_default
(
)
.
createElement
(
"
h3
"
null
"
Blocked
Data
"
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
large
-
data
-
container
"
}
this
.
renderBlocksData
(
)
)
external_React_default
(
)
.
createElement
(
"
h3
"
null
"
Weather
Data
"
)
this
.
renderWeatherData
(
)
external_React_default
(
)
.
createElement
(
"
h3
"
null
"
Personalization
Data
"
)
this
.
renderPersonalizationData
(
)
)
;
}
}
class
DiscoveryStreamAdminInner
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
setState
=
this
.
setState
.
bind
(
this
)
;
}
render
(
)
{
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
discoverystream
-
admin
{
this
.
props
.
collapsed
?
"
collapsed
"
:
"
expanded
"
}
}
external_React_default
(
)
.
createElement
(
"
main
"
{
className
:
"
main
-
panel
"
}
external_React_default
(
)
.
createElement
(
"
h1
"
null
"
Discovery
Stream
Admin
"
)
external_React_default
(
)
.
createElement
(
"
p
"
{
className
:
"
helpLink
"
}
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
icon
icon
-
small
-
spacer
icon
-
info
"
}
)
"
"
external_React_default
(
)
.
createElement
(
"
span
"
null
"
Need
to
access
the
ASRouter
Admin
dev
tools
?
"
"
"
external_React_default
(
)
.
createElement
(
"
a
"
{
target
:
"
blank
"
href
:
"
about
:
asrouter
"
}
"
Click
here
"
)
)
)
external_React_default
(
)
.
createElement
(
(
external_React_default
(
)
)
.
Fragment
null
external_React_default
(
)
.
createElement
(
DiscoveryStreamAdminUI
{
state
:
{
DiscoveryStream
:
this
.
props
.
DiscoveryStream
Personalization
:
this
.
props
.
Personalization
Weather
:
this
.
props
.
Weather
InferredPersonalization
:
this
.
props
.
InferredPersonalization
}
otherPrefs
:
this
.
props
.
Prefs
.
values
dispatch
:
this
.
props
.
dispatch
}
)
)
)
)
;
}
}
class
CollapseToggle
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
onCollapseToggle
=
this
.
onCollapseToggle
.
bind
(
this
)
;
this
.
state
=
{
collapsed
:
false
}
;
}
get
renderAdmin
(
)
{
const
{
props
}
=
this
;
return
props
.
location
.
hash
&
&
props
.
location
.
hash
.
startsWith
(
"
#
devtools
"
)
;
}
onCollapseToggle
(
e
)
{
e
.
preventDefault
(
)
;
this
.
setState
(
state
=
>
(
{
collapsed
:
!
state
.
collapsed
}
)
)
;
}
setBodyClass
(
)
{
if
(
this
.
renderAdmin
&
&
!
this
.
state
.
collapsed
)
{
globalThis
.
document
.
body
.
classList
.
add
(
"
no
-
scroll
"
)
;
}
else
{
globalThis
.
document
.
body
.
classList
.
remove
(
"
no
-
scroll
"
)
;
}
}
componentDidMount
(
)
{
this
.
setBodyClass
(
)
;
}
componentDidUpdate
(
)
{
this
.
setBodyClass
(
)
;
}
componentWillUnmount
(
)
{
globalThis
.
document
.
body
.
classList
.
remove
(
"
no
-
scroll
"
)
;
}
render
(
)
{
const
{
props
}
=
this
;
const
{
renderAdmin
}
=
this
;
const
isCollapsed
=
this
.
state
.
collapsed
|
|
!
renderAdmin
;
const
label
=
{
isCollapsed
?
"
Expand
"
:
"
Collapse
"
}
devtools
;
return
external_React_default
(
)
.
createElement
(
(
external_React_default
(
)
)
.
Fragment
null
external_React_default
(
)
.
createElement
(
"
a
"
{
href
:
"
#
devtools
"
title
:
label
"
aria
-
label
"
:
label
className
:
discoverystream
-
admin
-
toggle
{
isCollapsed
?
"
collapsed
"
:
"
expanded
"
}
onClick
:
this
.
renderAdmin
?
this
.
onCollapseToggle
:
null
}
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
icon
icon
-
devtools
"
}
)
)
renderAdmin
?
external_React_default
(
)
.
createElement
(
DiscoveryStreamAdminInner
_extends
(
{
}
props
{
collapsed
:
this
.
state
.
collapsed
}
)
)
:
null
)
;
}
}
const
_DiscoveryStreamAdmin
=
props
=
>
external_React_default
(
)
.
createElement
(
SimpleHashRouter
null
external_React_default
(
)
.
createElement
(
CollapseToggle
props
)
)
;
const
DiscoveryStreamAdmin
=
(
0
external_ReactRedux_namespaceObject
.
connect
)
(
state
=
>
(
{
Sections
:
state
.
Sections
DiscoveryStream
:
state
.
DiscoveryStream
Personalization
:
state
.
Personalization
InferredPersonalization
:
state
.
InferredPersonalization
Prefs
:
state
.
Prefs
Weather
:
state
.
Weather
}
)
)
(
_DiscoveryStreamAdmin
)
;
;
class
_ConfirmDialog
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
_handleCancelBtn
=
this
.
_handleCancelBtn
.
bind
(
this
)
;
this
.
_handleConfirmBtn
=
this
.
_handleConfirmBtn
.
bind
(
this
)
;
}
_handleCancelBtn
(
)
{
this
.
props
.
dispatch
(
{
type
:
actionTypes
.
DIALOG_CANCEL
}
)
;
this
.
props
.
dispatch
(
actionCreators
.
UserEvent
(
{
event
:
actionTypes
.
DIALOG_CANCEL
source
:
this
.
props
.
data
.
eventSource
}
)
)
;
}
_handleConfirmBtn
(
)
{
this
.
props
.
data
.
onConfirm
.
forEach
(
this
.
props
.
dispatch
)
;
}
_renderModalMessage
(
)
{
const
message_body
=
this
.
props
.
data
.
body_string_id
;
if
(
!
message_body
)
{
return
null
;
}
return
external_React_default
(
)
.
createElement
(
"
span
"
null
message_body
.
map
(
msg
=
>
external_React_default
(
)
.
createElement
(
"
p
"
{
key
:
msg
"
data
-
l10n
-
id
"
:
msg
}
)
)
)
;
}
render
(
)
{
if
(
!
this
.
props
.
visible
)
{
return
null
;
}
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
confirmation
-
dialog
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
modal
-
overlay
"
onClick
:
this
.
_handleCancelBtn
role
:
"
presentation
"
}
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
modal
"
}
external_React_default
(
)
.
createElement
(
"
section
"
{
className
:
"
modal
-
message
"
}
this
.
props
.
data
.
icon
&
&
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
icon
icon
-
spacer
icon
-
{
this
.
props
.
data
.
icon
}
}
)
this
.
_renderModalMessage
(
)
)
external_React_default
(
)
.
createElement
(
"
section
"
{
className
:
"
actions
"
}
external_React_default
(
)
.
createElement
(
"
button
"
{
onClick
:
this
.
_handleCancelBtn
"
data
-
l10n
-
id
"
:
this
.
props
.
data
.
cancel_button_string_id
}
)
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
"
done
"
onClick
:
this
.
_handleConfirmBtn
"
data
-
l10n
-
id
"
:
this
.
props
.
data
.
confirm_button_string_id
"
data
-
l10n
-
args
"
:
JSON
.
stringify
(
this
.
props
.
data
.
confirm_button_string_args
)
}
)
)
)
)
;
}
}
const
ConfirmDialog
=
(
0
external_ReactRedux_namespaceObject
.
connect
)
(
state
=
>
state
.
Dialog
)
(
_ConfirmDialog
)
;
;
const
PLACEHOLDER_IMAGE_DATA_ARRAY
=
[
{
rotation
:
"
0deg
"
offsetx
:
"
20px
"
offsety
:
"
8px
"
scale
:
"
45
%
"
}
{
rotation
:
"
54deg
"
offsetx
:
"
-
26px
"
offsety
:
"
62px
"
scale
:
"
55
%
"
}
{
rotation
:
"
-
30deg
"
offsetx
:
"
78px
"
offsety
:
"
30px
"
scale
:
"
68
%
"
}
{
rotation
:
"
-
22deg
"
offsetx
:
"
0
"
offsety
:
"
92px
"
scale
:
"
60
%
"
}
{
rotation
:
"
-
65deg
"
offsetx
:
"
66px
"
offsety
:
"
28px
"
scale
:
"
60
%
"
}
{
rotation
:
"
22deg
"
offsetx
:
"
-
35px
"
offsety
:
"
62px
"
scale
:
"
52
%
"
}
{
rotation
:
"
-
25deg
"
offsetx
:
"
86px
"
offsety
:
"
-
15px
"
scale
:
"
68
%
"
}
]
;
const
PLACEHOLDER_IMAGE_COLORS_ARRAY
=
"
#
0090ED
#
FF4F5F
#
2AC3A2
#
FF7139
#
A172FF
#
FFA437
#
FF2A8A
"
.
split
(
"
"
)
;
function
generateIndex
(
{
keyCode
max
}
)
{
if
(
!
keyCode
)
{
return
Math
.
floor
(
Math
.
random
(
)
*
max
)
;
}
const
hashStr
=
str
=
>
{
let
hash
=
0
;
for
(
let
i
=
0
;
i
<
str
.
length
;
i
+
+
)
{
let
charCode
=
str
.
charCodeAt
(
i
)
;
hash
+
=
charCode
;
}
return
hash
;
}
;
const
hash
=
hashStr
(
keyCode
)
;
return
hash
%
max
;
}
function
PlaceholderImage
(
{
urlKey
titleKey
}
)
{
const
dataIndex
=
generateIndex
(
{
keyCode
:
urlKey
max
:
PLACEHOLDER_IMAGE_DATA_ARRAY
.
length
}
)
;
const
colorIndex
=
generateIndex
(
{
keyCode
:
titleKey
max
:
PLACEHOLDER_IMAGE_COLORS_ARRAY
.
length
}
)
;
const
{
rotation
offsetx
offsety
scale
}
=
PLACEHOLDER_IMAGE_DATA_ARRAY
[
dataIndex
]
;
const
color
=
PLACEHOLDER_IMAGE_COLORS_ARRAY
[
colorIndex
]
;
const
style
=
{
"
-
-
placeholderBackgroundColor
"
:
color
"
-
-
placeholderBackgroundRotation
"
:
rotation
"
-
-
placeholderBackgroundOffsetx
"
:
offsetx
"
-
-
placeholderBackgroundOffsety
"
:
offsety
"
-
-
placeholderBackgroundScale
"
:
scale
}
;
return
external_React_default
(
)
.
createElement
(
"
div
"
{
style
:
style
className
:
"
placeholder
-
image
"
}
)
;
}
class
DSImage
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
onOptimizedImageError
=
this
.
onOptimizedImageError
.
bind
(
this
)
;
this
.
onNonOptimizedImageError
=
this
.
onNonOptimizedImageError
.
bind
(
this
)
;
this
.
onLoad
=
this
.
onLoad
.
bind
(
this
)
;
this
.
state
=
{
isLoaded
:
false
optimizedImageFailed
:
false
useTransition
:
false
}
;
}
onIdleCallback
(
)
{
if
(
!
this
.
state
.
isLoaded
)
{
this
.
setState
(
{
useTransition
:
true
}
)
;
}
}
reformatImageURL
(
url
width
height
)
{
const
smart
=
this
.
props
.
smartCrop
?
"
smart
/
"
:
"
"
;
const
formattedUrl
=
https
:
/
/
img
-
getpocket
.
cdn
.
mozilla
.
net
/
{
width
}
x
{
height
}
/
{
smart
}
filters
:
format
(
jpeg
)
:
quality
(
60
)
:
no_upscale
(
)
:
strip_exif
(
)
/
{
encodeURIComponent
(
url
)
}
;
return
this
.
secureImageURL
(
formattedUrl
)
;
}
secureImageURL
(
url
)
{
if
(
!
this
.
props
.
secureImage
)
{
return
url
;
}
return
moz
-
cached
-
ohttp
:
/
/
newtab
-
image
/
?
url
=
{
encodeURIComponent
(
url
)
}
;
}
componentDidMount
(
)
{
this
.
idleCallbackId
=
this
.
props
.
windowObj
.
requestIdleCallback
(
this
.
onIdleCallback
.
bind
(
this
)
)
;
}
componentWillUnmount
(
)
{
if
(
this
.
idleCallbackId
)
{
this
.
props
.
windowObj
.
cancelIdleCallback
(
this
.
idleCallbackId
)
;
}
}
render
(
)
{
let
classNames
=
ds
-
image
{
this
.
props
.
extraClassNames
?
{
this
.
props
.
extraClassNames
}
:
}
{
this
.
state
&
&
this
.
state
.
useTransition
?
use
-
transition
:
}
{
this
.
state
&
&
this
.
state
.
isLoaded
?
loaded
:
}
;
let
img
;
if
(
this
.
state
)
{
if
(
this
.
props
.
optimize
&
&
this
.
props
.
rawSource
&
&
!
this
.
state
.
optimizedImageFailed
)
{
const
baseSource
=
this
.
props
.
rawSource
;
const
securedSource
=
this
.
secureImageURL
(
baseSource
)
;
let
sizeRules
=
[
]
;
let
srcSetRules
=
[
]
;
for
(
let
rule
of
this
.
props
.
sizes
)
{
let
{
mediaMatcher
width
height
}
=
rule
;
let
sizeRule
=
{
mediaMatcher
}
{
width
}
px
;
sizeRules
.
push
(
sizeRule
)
;
let
srcSetRule
=
{
this
.
reformatImageURL
(
baseSource
width
height
)
}
{
width
}
w
;
let
srcSetRule2x
=
{
this
.
reformatImageURL
(
baseSource
width
*
2
height
*
2
)
}
{
width
*
2
}
w
;
srcSetRules
.
push
(
srcSetRule
)
;
srcSetRules
.
push
(
srcSetRule2x
)
;
}
if
(
this
.
props
.
sizes
.
length
)
{
sizeRules
.
push
(
{
this
.
props
.
sizes
[
this
.
props
.
sizes
.
length
-
1
]
.
width
}
px
)
;
}
img
=
external_React_default
(
)
.
createElement
(
"
img
"
{
loading
:
"
lazy
"
alt
:
this
.
props
.
alt_text
crossOrigin
:
"
anonymous
"
onLoad
:
this
.
onLoad
onError
:
this
.
onOptimizedImageError
sizes
:
sizeRules
.
join
(
"
"
)
src
:
securedSource
srcSet
:
srcSetRules
.
join
(
"
"
)
}
)
;
}
else
if
(
this
.
props
.
source
&
&
!
this
.
state
.
nonOptimizedImageFailed
)
{
img
=
external_React_default
(
)
.
createElement
(
"
img
"
{
loading
:
"
lazy
"
alt
:
this
.
props
.
alt_text
crossOrigin
:
"
anonymous
"
onLoad
:
this
.
onLoad
onError
:
this
.
onNonOptimizedImageError
src
:
this
.
props
.
source
}
)
;
}
else
{
classNames
=
{
classNames
}
loaded
;
if
(
this
.
props
.
isRecentSave
&
&
!
this
.
props
.
rawSource
&
&
!
this
.
props
.
source
)
{
img
=
external_React_default
(
)
.
createElement
(
PlaceholderImage
{
urlKey
:
this
.
props
.
url
titleKey
:
this
.
props
.
title
}
)
;
}
else
{
img
=
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
broken
-
image
"
}
)
;
}
}
}
return
external_React_default
(
)
.
createElement
(
"
picture
"
{
className
:
classNames
}
img
)
;
}
onOptimizedImageError
(
)
{
this
.
setState
(
{
optimizedImageFailed
:
true
}
)
;
}
onNonOptimizedImageError
(
)
{
this
.
setState
(
{
nonOptimizedImageFailed
:
true
}
)
;
}
onLoad
(
)
{
this
.
setState
(
{
isLoaded
:
true
}
)
;
}
}
DSImage
.
defaultProps
=
{
source
:
null
rawSource
:
null
extraClassNames
:
null
optimize
:
true
alt_text
:
null
windowObj
:
window
sizes
:
[
]
}
;
;
class
ContextMenu
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
hideContext
=
this
.
hideContext
.
bind
(
this
)
;
this
.
onShow
=
this
.
onShow
.
bind
(
this
)
;
this
.
onClick
=
this
.
onClick
.
bind
(
this
)
;
}
hideContext
(
)
{
this
.
props
.
onUpdate
(
false
)
;
}
onShow
(
)
{
if
(
this
.
props
.
onShow
)
{
this
.
props
.
onShow
(
)
;
}
}
componentDidMount
(
)
{
this
.
onShow
(
)
;
setTimeout
(
(
)
=
>
{
globalThis
.
addEventListener
(
"
click
"
this
.
hideContext
)
;
}
0
)
;
}
componentWillUnmount
(
)
{
globalThis
.
removeEventListener
(
"
click
"
this
.
hideContext
)
;
}
onClick
(
event
)
{
event
.
stopPropagation
(
)
;
}
render
(
)
{
return
(
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
context
-
menu
"
}
external_React_default
(
)
.
createElement
(
"
ul
"
{
role
:
"
menu
"
onClick
:
this
.
onClick
onKeyDown
:
this
.
onClick
className
:
"
context
-
menu
-
list
"
}
this
.
props
.
options
.
map
(
(
option
i
)
=
>
option
.
type
=
=
=
"
separator
"
?
external_React_default
(
)
.
createElement
(
"
li
"
{
key
:
i
className
:
"
separator
"
role
:
"
separator
"
}
)
:
option
.
type
!
=
=
"
empty
"
&
&
external_React_default
(
)
.
createElement
(
ContextMenuItem
{
key
:
i
option
:
option
hideContext
:
this
.
hideContext
keyboardAccess
:
this
.
props
.
keyboardAccess
}
)
)
)
)
)
;
}
}
class
_ContextMenuItem
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
onClick
=
this
.
onClick
.
bind
(
this
)
;
this
.
onKeyDown
=
this
.
onKeyDown
.
bind
(
this
)
;
this
.
onKeyUp
=
this
.
onKeyUp
.
bind
(
this
)
;
this
.
focusFirst
=
this
.
focusFirst
.
bind
(
this
)
;
}
onClick
(
event
)
{
this
.
props
.
hideContext
(
)
;
this
.
props
.
option
.
onClick
(
event
)
;
}
focusFirst
(
button
)
{
if
(
this
.
props
.
keyboardAccess
&
&
button
)
{
button
.
focus
(
)
;
}
}
focusSibling
(
target
key
)
{
const
{
parentNode
}
=
target
;
const
closestSiblingSelector
=
key
=
=
=
"
ArrowUp
"
?
"
previousSibling
"
:
"
nextSibling
"
;
if
(
!
parentNode
[
closestSiblingSelector
]
)
{
return
;
}
if
(
parentNode
[
closestSiblingSelector
]
.
firstElementChild
)
{
parentNode
[
closestSiblingSelector
]
.
firstElementChild
.
focus
(
)
;
}
else
{
parentNode
[
closestSiblingSelector
]
[
closestSiblingSelector
]
.
firstElementChild
.
focus
(
)
;
}
}
onKeyDown
(
event
)
{
const
{
option
}
=
this
.
props
;
switch
(
event
.
key
)
{
case
"
Tab
"
:
if
(
event
.
shiftKey
&
&
option
.
first
|
|
!
event
.
shiftKey
&
&
option
.
last
)
{
this
.
props
.
hideContext
(
)
;
}
break
;
case
"
ArrowUp
"
:
case
"
ArrowDown
"
:
event
.
preventDefault
(
)
;
this
.
focusSibling
(
event
.
target
event
.
key
)
;
break
;
case
"
Enter
"
:
case
"
"
:
event
.
preventDefault
(
)
;
this
.
props
.
hideContext
(
)
;
option
.
onClick
(
)
;
break
;
case
"
Escape
"
:
this
.
props
.
hideContext
(
)
;
break
;
}
}
onKeyUp
(
event
)
{
if
(
event
.
key
=
=
=
"
"
)
{
event
.
preventDefault
(
)
;
}
}
render
(
)
{
const
{
option
}
=
this
.
props
;
const
className
=
[
option
.
disabled
?
"
disabled
"
:
"
"
]
.
join
(
"
"
)
;
return
external_React_default
(
)
.
createElement
(
"
li
"
{
role
:
"
presentation
"
className
:
"
context
-
menu
-
item
"
}
external_React_default
(
)
.
createElement
(
"
button
"
{
role
:
"
menuitem
"
className
:
className
onClick
:
this
.
onClick
onKeyDown
:
this
.
onKeyDown
onKeyUp
:
this
.
onKeyUp
ref
:
option
.
first
?
this
.
focusFirst
:
null
"
aria
-
haspopup
"
:
option
.
id
=
=
=
"
newtab
-
menu
-
edit
-
topsites
"
?
"
dialog
"
:
null
}
external_React_default
(
)
.
createElement
(
"
span
"
{
"
data
-
l10n
-
id
"
:
option
.
string_id
|
|
option
.
id
}
)
)
)
;
}
}
const
ContextMenuItem
=
(
0
external_ReactRedux_namespaceObject
.
connect
)
(
state
=
>
(
{
Prefs
:
state
.
Prefs
}
)
)
(
_ContextMenuItem
)
;
;
const
_OpenInPrivateWindow
=
site
=
>
(
{
id
:
"
newtab
-
menu
-
open
-
new
-
private
-
window
"
icon
:
"
new
-
window
-
private
"
action
:
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
OPEN_PRIVATE_WINDOW
data
:
{
url
:
site
.
url
referrer
:
site
.
referrer
event_source
:
"
CONTEXT_MENU
"
}
}
)
userEvent
:
"
OPEN_PRIVATE_WINDOW
"
}
)
;
const
LinkMenuOptions
=
{
Separator
:
(
)
=
>
(
{
type
:
"
separator
"
}
)
EmptyItem
:
(
)
=
>
(
{
type
:
"
empty
"
}
)
ShowPrivacyInfo
:
(
)
=
>
(
{
id
:
"
newtab
-
menu
-
show
-
privacy
-
info
"
icon
:
"
info
"
action
:
{
type
:
actionTypes
.
SHOW_PRIVACY_INFO
}
userEvent
:
"
SHOW_PRIVACY_INFO
"
}
)
AboutSponsored
:
site
=
>
(
{
id
:
"
newtab
-
menu
-
show
-
privacy
-
info
"
icon
:
"
info
"
action
:
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
ABOUT_SPONSORED_TOP_SITES
data
:
{
advertiser_name
:
(
site
.
label
|
|
site
.
hostname
)
.
toLocaleLowerCase
(
)
position
:
site
.
sponsored_position
tile_id
:
site
.
sponsored_tile_id
block_key
:
site
.
block_key
}
}
)
userEvent
:
"
TOPSITE_SPONSOR_INFO
"
}
)
RemoveBookmark
:
site
=
>
(
{
id
:
"
newtab
-
menu
-
remove
-
bookmark
"
icon
:
"
bookmark
-
added
"
action
:
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
DELETE_BOOKMARK_BY_ID
data
:
site
.
bookmarkGuid
}
)
userEvent
:
"
BOOKMARK_DELETE
"
}
)
AddBookmark
:
site
=
>
(
{
id
:
"
newtab
-
menu
-
bookmark
"
icon
:
"
bookmark
-
hollow
"
action
:
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
BOOKMARK_URL
data
:
{
url
:
site
.
url
title
:
site
.
title
type
:
site
.
type
}
}
)
userEvent
:
"
BOOKMARK_ADD
"
}
)
OpenInNewWindow
:
site
=
>
(
{
id
:
"
newtab
-
menu
-
open
-
new
-
window
"
icon
:
"
new
-
window
"
action
:
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
OPEN_NEW_WINDOW
data
:
{
card_type
:
site
.
card_type
referrer
:
site
.
referrer
typedBonus
:
site
.
typedBonus
url
:
site
.
url
sponsored_tile_id
:
site
.
sponsored_tile_id
event_source
:
"
CONTEXT_MENU
"
topic
:
site
.
topic
firstVisibleTimestamp
:
site
.
firstVisibleTimestamp
tile_id
:
site
.
tile_id
recommendation_id
:
site
.
recommendation_id
scheduled_corpus_item_id
:
site
.
scheduled_corpus_item_id
corpus_item_id
:
site
.
corpus_item_id
received_rank
:
site
.
received_rank
recommended_at
:
site
.
recommended_at
format
:
site
.
format
.
.
.
(
site
.
flight_id
?
{
flight_id
:
site
.
flight_id
}
:
{
}
)
is_pocket_card
:
site
.
type
=
=
=
"
CardGrid
"
is_list_card
:
site
.
is_list_card
.
.
.
(
site
.
section
?
{
section
:
site
.
section
section_position
:
site
.
section_position
is_section_followed
:
site
.
is_section_followed
}
:
{
}
)
}
}
)
userEvent
:
"
OPEN_NEW_WINDOW
"
}
)
BlockUrl
:
(
site
index
eventSource
)
=
>
{
return
LinkMenuOptions
.
BlockUrls
(
[
site
]
index
eventSource
)
;
}
BlockUrls
:
(
tiles
pos
eventSource
)
=
>
(
{
id
:
"
newtab
-
menu
-
dismiss
"
icon
:
"
dismiss
"
action
:
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
BLOCK_URL
source
:
eventSource
data
:
tiles
.
map
(
site
=
>
(
{
url
:
site
.
original_url
|
|
site
.
open_url
|
|
site
.
url
pocket_id
:
site
.
pocket_id
tile_id
:
site
.
tile_id
.
.
.
(
site
.
block_key
?
{
block_key
:
site
.
block_key
}
:
{
}
)
recommendation_id
:
site
.
recommendation_id
scheduled_corpus_item_id
:
site
.
scheduled_corpus_item_id
corpus_item_id
:
site
.
corpus_item_id
received_rank
:
site
.
received_rank
recommended_at
:
site
.
recommended_at
isSponsoredTopSite
:
site
.
sponsored_position
type
:
site
.
type
card_type
:
site
.
card_type
.
.
.
(
site
.
shim
&
&
site
.
shim
.
delete
?
{
shim
:
site
.
shim
.
delete
}
:
{
}
)
.
.
.
(
site
.
flight_id
?
{
flight_id
:
site
.
flight_id
}
:
{
}
)
.
.
.
(
site
.
sponsored_position
?
{
advertiser_name
:
(
site
.
label
|
|
site
.
hostname
)
?
.
toLocaleLowerCase
(
)
}
:
{
}
)
position
:
pos
.
.
.
(
site
.
sponsored_tile_id
?
{
tile_id
:
site
.
sponsored_tile_id
}
:
{
}
)
is_pocket_card
:
site
.
type
=
=
=
"
CardGrid
"
is_list_card
:
site
.
is_list_card
.
.
.
(
site
.
format
?
{
format
:
site
.
format
}
:
{
}
)
.
.
.
(
site
.
section
?
{
section
:
site
.
section
section_position
:
site
.
section_position
is_section_followed
:
site
.
is_section_followed
}
:
{
}
)
}
)
)
}
)
impression
:
actionCreators
.
ImpressionStats
(
{
source
:
eventSource
block
:
0
tiles
:
tiles
.
map
(
(
site
index
)
=
>
(
{
id
:
site
.
guid
pos
:
pos
+
index
.
.
.
(
site
.
shim
&
&
site
.
shim
.
delete
?
{
shim
:
site
.
shim
.
delete
}
:
{
}
)
}
)
)
}
)
userEvent
:
"
BLOCK
"
}
)
BlockAdUrl
:
(
site
pos
eventSource
)
=
>
(
{
id
:
"
newtab
-
menu
-
dismiss
"
icon
:
"
dismiss
"
action
:
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
BLOCK_URL
data
:
[
site
]
}
)
impression
:
actionCreators
.
ImpressionStats
(
{
source
:
eventSource
block
:
0
tiles
:
[
{
id
:
site
.
guid
pos
.
.
.
(
site
.
shim
&
&
site
.
shim
.
save
?
{
shim
:
site
.
shim
.
save
}
:
{
}
)
}
]
}
)
userEvent
:
"
BLOCK
"
}
)
WebExtDismiss
:
(
site
index
eventSource
)
=
>
(
{
id
:
"
menu_action_webext_dismiss
"
string_id
:
"
newtab
-
menu
-
dismiss
"
icon
:
"
dismiss
"
action
:
actionCreators
.
WebExtEvent
(
actionTypes
.
WEBEXT_DISMISS
{
source
:
eventSource
url
:
site
.
url
action_position
:
index
}
)
}
)
DeleteUrl
:
(
site
index
eventSource
isEnabled
siteInfo
)
=
>
(
{
id
:
"
newtab
-
menu
-
delete
-
history
"
icon
:
"
delete
"
action
:
{
type
:
actionTypes
.
DIALOG_OPEN
data
:
{
onConfirm
:
[
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
DELETE_HISTORY_URL
data
:
{
url
:
site
.
url
pocket_id
:
site
.
pocket_id
forceBlock
:
site
.
bookmarkGuid
}
}
)
actionCreators
.
UserEvent
(
Object
.
assign
(
{
event
:
"
DELETE
"
source
:
eventSource
action_position
:
index
}
siteInfo
)
)
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
DIALOG_CLOSE
}
)
]
eventSource
body_string_id
:
[
"
newtab
-
confirm
-
delete
-
history
-
p1
"
"
newtab
-
confirm
-
delete
-
history
-
p2
"
]
confirm_button_string_id
:
"
newtab
-
topsites
-
delete
-
history
-
button
"
cancel_button_string_id
:
"
newtab
-
topsites
-
cancel
-
button
"
icon
:
"
modal
-
delete
"
}
}
userEvent
:
"
DIALOG_OPEN
"
}
)
ShowFile
:
site
=
>
(
{
id
:
"
newtab
-
menu
-
show
-
file
"
icon
:
"
search
"
action
:
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
SHOW_DOWNLOAD_FILE
data
:
{
url
:
site
.
url
}
}
)
}
)
OpenFile
:
site
=
>
(
{
id
:
"
newtab
-
menu
-
open
-
file
"
icon
:
"
open
-
file
"
action
:
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
OPEN_DOWNLOAD_FILE
data
:
{
url
:
site
.
url
}
}
)
}
)
CopyDownloadLink
:
site
=
>
(
{
id
:
"
newtab
-
menu
-
copy
-
download
-
link
"
icon
:
"
copy
"
action
:
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
COPY_DOWNLOAD_LINK
data
:
{
url
:
site
.
url
}
}
)
}
)
GoToDownloadPage
:
site
=
>
(
{
id
:
"
newtab
-
menu
-
go
-
to
-
download
-
page
"
icon
:
"
download
"
action
:
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
OPEN_LINK
data
:
{
url
:
site
.
referrer
}
}
)
disabled
:
!
site
.
referrer
}
)
RemoveDownload
:
site
=
>
(
{
id
:
"
newtab
-
menu
-
remove
-
download
"
icon
:
"
delete
"
action
:
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
REMOVE_DOWNLOAD_FILE
data
:
{
url
:
site
.
url
}
}
)
}
)
PinTopSite
:
(
site
index
)
=
>
(
{
id
:
"
newtab
-
menu
-
pin
"
icon
:
"
pin
"
action
:
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
TOP_SITES_PIN
data
:
{
site
index
}
}
)
userEvent
:
"
PIN
"
}
)
UnpinTopSite
:
site
=
>
(
{
id
:
"
newtab
-
menu
-
unpin
"
icon
:
"
unpin
"
action
:
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
TOP_SITES_UNPIN
data
:
{
site
:
{
url
:
site
.
url
}
}
}
)
userEvent
:
"
UNPIN
"
}
)
EditTopSite
:
(
site
index
)
=
>
(
{
id
:
"
newtab
-
menu
-
edit
-
topsites
"
icon
:
"
edit
"
action
:
{
type
:
actionTypes
.
TOP_SITES_EDIT
data
:
{
index
}
}
}
)
CheckBookmark
:
site
=
>
site
.
bookmarkGuid
?
LinkMenuOptions
.
RemoveBookmark
(
site
)
:
LinkMenuOptions
.
AddBookmark
(
site
)
CheckPinTopSite
:
(
site
index
)
=
>
site
.
isPinned
?
LinkMenuOptions
.
UnpinTopSite
(
site
)
:
LinkMenuOptions
.
PinTopSite
(
site
index
)
OpenInPrivateWindow
:
(
site
index
eventSource
isEnabled
)
=
>
isEnabled
?
_OpenInPrivateWindow
(
site
)
:
LinkMenuOptions
.
EmptyItem
(
)
ChangeWeatherLocation
:
(
)
=
>
(
{
id
:
"
newtab
-
weather
-
menu
-
change
-
location
"
action
:
actionCreators
.
BroadcastToContent
(
{
type
:
actionTypes
.
WEATHER_SEARCH_ACTIVE
data
:
true
}
)
}
)
ChangeWeatherDisplaySimple
:
(
)
=
>
(
{
id
:
"
newtab
-
weather
-
menu
-
change
-
weather
-
display
-
simple
"
action
:
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
SET_PREF
data
:
{
name
:
"
weather
.
display
"
value
:
"
simple
"
}
}
)
}
)
ChangeWeatherDisplayDetailed
:
(
)
=
>
(
{
id
:
"
newtab
-
weather
-
menu
-
change
-
weather
-
display
-
detailed
"
action
:
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
SET_PREF
data
:
{
name
:
"
weather
.
display
"
value
:
"
detailed
"
}
}
)
}
)
ChangeTempUnitFahrenheit
:
(
)
=
>
(
{
id
:
"
newtab
-
weather
-
menu
-
change
-
temperature
-
units
-
fahrenheit
"
action
:
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
SET_PREF
data
:
{
name
:
"
weather
.
temperatureUnits
"
value
:
"
f
"
}
}
)
}
)
ChangeTempUnitCelsius
:
(
)
=
>
(
{
id
:
"
newtab
-
weather
-
menu
-
change
-
temperature
-
units
-
celsius
"
action
:
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
SET_PREF
data
:
{
name
:
"
weather
.
temperatureUnits
"
value
:
"
c
"
}
}
)
}
)
HideWeather
:
(
)
=
>
(
{
id
:
"
newtab
-
weather
-
menu
-
hide
-
weather
"
action
:
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
SET_PREF
data
:
{
name
:
"
showWeather
"
value
:
false
}
}
)
}
)
OpenLearnMoreURL
:
site
=
>
(
{
id
:
"
newtab
-
weather
-
menu
-
learn
-
more
"
action
:
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
OPEN_LINK
data
:
{
url
:
site
.
url
}
}
)
}
)
FakespotDismiss
:
(
)
=
>
(
{
id
:
"
newtab
-
menu
-
dismiss
"
action
:
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
SET_PREF
data
:
{
name
:
"
discoverystream
.
contextualContent
.
fakespot
.
enabled
"
value
:
false
}
}
)
impression
:
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
FAKESPOT_DISMISS
}
)
}
)
AboutFakespot
:
site
=
>
(
{
id
:
"
newtab
-
menu
-
about
-
fakespot
"
action
:
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
OPEN_LINK
data
:
{
url
:
site
.
url
}
}
)
impression
:
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
OPEN_ABOUT_FAKESPOT
}
)
}
)
SectionBlock
:
(
{
sectionPersonalization
sectionKey
sectionPosition
title
}
)
=
>
(
{
id
:
"
newtab
-
menu
-
section
-
block
"
icon
:
"
delete
"
action
:
{
type
:
actionTypes
.
DIALOG_OPEN
data
:
{
onConfirm
:
[
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
SECTION_PERSONALIZATION_SET
data
:
{
.
.
.
sectionPersonalization
[
sectionKey
]
:
{
isBlocked
:
true
isFollowed
:
false
}
}
}
)
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
BLOCK_SECTION
data
:
{
section
:
sectionKey
section_position
:
sectionPosition
event_source
:
"
CONTEXT_MENU
"
}
}
)
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
DIALOG_CLOSE
}
)
]
body_string_id
:
[
"
newtab
-
section
-
confirm
-
block
-
topic
-
p1
"
"
newtab
-
section
-
confirm
-
block
-
topic
-
p2
"
]
confirm_button_string_id
:
"
newtab
-
section
-
block
-
topic
-
button
"
confirm_button_string_args
:
{
topic
:
title
}
cancel_button_string_id
:
"
newtab
-
section
-
cancel
-
button
"
}
}
userEvent
:
"
DIALOG_OPEN
"
}
)
SectionUnfollow
:
(
{
sectionPersonalization
sectionKey
sectionPosition
}
)
=
>
(
{
id
:
"
newtab
-
menu
-
section
-
unfollow
"
action
:
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
SECTION_PERSONALIZATION_SET
data
:
(
(
{
sectionKey
:
_sectionKey
.
.
.
remaining
}
)
=
>
remaining
)
(
sectionPersonalization
)
}
)
impression
:
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
UNFOLLOW_SECTION
data
:
{
section
:
sectionKey
section_position
:
sectionPosition
event_source
:
"
CONTEXT_MENU
"
}
}
)
}
)
ManageSponsoredContent
:
(
)
=
>
(
{
id
:
"
newtab
-
menu
-
manage
-
sponsored
-
content
"
action
:
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
SETTINGS_OPEN
}
)
userEvent
:
"
OPEN_NEWTAB_PREFS
"
}
)
OurSponsorsAndYourPrivacy
:
(
)
=
>
(
{
id
:
"
newtab
-
menu
-
our
-
sponsors
-
and
-
your
-
privacy
"
action
:
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
OPEN_LINK
data
:
{
url
:
"
https
:
/
/
support
.
mozilla
.
org
/
kb
/
pocket
-
sponsored
-
stories
-
new
-
tabs
"
}
}
)
userEvent
:
"
CLICK_PRIVACY_INFO
"
}
)
ReportAd
:
site
=
>
{
return
{
id
:
"
newtab
-
menu
-
report
-
this
-
ad
"
action
:
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
REPORT_AD_OPEN
data
:
{
card_type
:
site
.
card_type
position
:
site
.
position
reporting_url
:
site
.
shim
.
report
url
:
site
.
url
}
}
)
}
;
}
ReportContent
:
site
=
>
{
return
{
id
:
"
newtab
-
menu
-
report
"
action
:
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
REPORT_CONTENT_OPEN
data
:
{
card_type
:
site
.
card_type
corpus_item_id
:
site
.
corpus_item_id
scheduled_corpus_item_id
:
site
.
scheduled_corpus_item_id
section_position
:
site
.
section_position
section
:
site
.
section
title
:
site
.
title
topic
:
site
.
topic
url
:
site
.
url
}
}
)
}
;
}
TrendingSearchLearnMore
:
site
=
>
(
{
id
:
"
newtab
-
trending
-
searches
-
learn
-
more
"
action
:
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
OPEN_LINK
data
:
{
url
:
site
.
url
}
}
)
impression
:
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
TRENDING_SEARCH_LEARN_MORE
data
:
{
variant
:
site
.
variant
}
}
)
}
)
TrendingSearchDismiss
:
site
=
>
(
{
id
:
"
newtab
-
trending
-
searches
-
dismiss
"
action
:
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
SET_PREF
data
:
{
name
:
"
trendingSearch
.
enabled
"
value
:
false
}
}
)
impression
:
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
TRENDING_SEARCH_DISMISS
data
:
{
variant
:
site
.
variant
}
}
)
}
)
}
;
;
const
DEFAULT_SITE_MENU_OPTIONS
=
[
"
CheckPinTopSite
"
"
EditTopSite
"
"
Separator
"
"
OpenInNewWindow
"
"
OpenInPrivateWindow
"
"
Separator
"
"
BlockUrl
"
]
;
class
_LinkMenu
extends
(
external_React_default
(
)
)
.
PureComponent
{
getOptions
(
)
{
const
{
props
}
=
this
;
const
{
site
index
source
isPrivateBrowsingEnabled
siteInfo
platform
dispatch
options
shouldSendImpressionStats
userEvent
=
actionCreators
.
UserEvent
}
=
props
;
const
propOptions
=
site
.
isDefault
&
&
!
site
.
searchTopSite
&
&
!
site
.
sponsored_position
?
DEFAULT_SITE_MENU_OPTIONS
:
options
;
const
linkMenuOptions
=
propOptions
.
map
(
o
=
>
LinkMenuOptions
[
o
]
(
site
index
source
isPrivateBrowsingEnabled
siteInfo
platform
)
)
.
map
(
option
=
>
{
const
{
action
impression
id
type
userEvent
:
eventName
}
=
option
;
if
(
!
type
&
&
id
)
{
option
.
onClick
=
(
event
=
{
}
)
=
>
{
const
{
ctrlKey
metaKey
shiftKey
button
}
=
event
;
if
(
ctrlKey
|
|
metaKey
|
|
shiftKey
|
|
button
=
=
=
1
)
{
action
.
data
=
Object
.
assign
(
{
event
:
{
ctrlKey
metaKey
shiftKey
button
}
}
action
.
data
)
;
}
dispatch
(
action
)
;
if
(
eventName
)
{
let
value
;
if
(
action
.
type
=
=
=
"
OPEN_NEW_WINDOW
"
)
{
const
{
card_type
corpus_item_id
event_source
fetchTimestamp
firstVisibleTimestamp
format
is_list_card
is_section_followed
received_rank
recommendation_id
recommended_at
scheduled_corpus_item_id
section_position
section
selected_topics
tile_id
topic
}
=
action
.
data
;
value
=
{
card_type
corpus_item_id
event_source
fetchTimestamp
firstVisibleTimestamp
format
is_list_card
received_rank
recommendation_id
recommended_at
scheduled_corpus_item_id
.
.
.
(
section
?
{
is_section_followed
section_position
section
}
:
{
}
)
selected_topics
:
selected_topics
?
selected_topics
:
"
"
tile_id
topic
}
;
}
else
{
value
=
{
card_type
:
site
.
flight_id
?
"
spoc
"
:
"
organic
"
}
;
}
const
userEventData
=
Object
.
assign
(
{
event
:
eventName
source
action_position
:
index
value
}
siteInfo
)
;
dispatch
(
userEvent
(
userEventData
)
)
;
if
(
impression
&
&
shouldSendImpressionStats
)
{
dispatch
(
impression
)
;
}
}
}
;
}
return
option
;
}
)
;
linkMenuOptions
[
0
]
.
first
=
true
;
linkMenuOptions
[
linkMenuOptions
.
length
-
1
]
.
last
=
true
;
return
linkMenuOptions
;
}
render
(
)
{
return
external_React_default
(
)
.
createElement
(
ContextMenu
{
onUpdate
:
this
.
props
.
onUpdate
onShow
:
this
.
props
.
onShow
options
:
this
.
getOptions
(
)
keyboardAccess
:
this
.
props
.
keyboardAccess
}
)
;
}
}
const
getState
=
state
=
>
(
{
isPrivateBrowsingEnabled
:
state
.
Prefs
.
values
.
isPrivateBrowsingEnabled
platform
:
state
.
Prefs
.
values
.
platform
}
)
;
const
LinkMenu
=
(
0
external_ReactRedux_namespaceObject
.
connect
)
(
getState
)
(
_LinkMenu
)
;
;
class
ContextMenuButton
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
state
=
{
showContextMenu
:
false
contextMenuKeyboard
:
false
}
;
this
.
onClick
=
this
.
onClick
.
bind
(
this
)
;
this
.
onKeyDown
=
this
.
onKeyDown
.
bind
(
this
)
;
this
.
onUpdate
=
this
.
onUpdate
.
bind
(
this
)
;
}
openContextMenu
(
isKeyBoard
)
{
if
(
this
.
props
.
onUpdate
)
{
this
.
props
.
onUpdate
(
true
)
;
}
this
.
setState
(
{
showContextMenu
:
true
contextMenuKeyboard
:
isKeyBoard
}
)
;
}
onClick
(
event
)
{
event
.
preventDefault
(
)
;
this
.
openContextMenu
(
false
event
)
;
}
onKeyDown
(
event
)
{
if
(
event
.
key
=
=
=
"
Enter
"
|
|
event
.
key
=
=
=
"
"
)
{
event
.
preventDefault
(
)
;
this
.
openContextMenu
(
true
event
)
;
}
}
onUpdate
(
showContextMenu
)
{
if
(
this
.
props
.
onUpdate
)
{
this
.
props
.
onUpdate
(
showContextMenu
)
;
}
this
.
setState
(
{
showContextMenu
}
)
;
}
render
(
)
{
const
{
tooltipArgs
tooltip
children
refFunction
}
=
this
.
props
;
const
{
showContextMenu
contextMenuKeyboard
}
=
this
.
state
;
return
external_React_default
(
)
.
createElement
(
(
external_React_default
(
)
)
.
Fragment
null
external_React_default
(
)
.
createElement
(
"
button
"
{
"
aria
-
haspopup
"
:
"
true
"
"
data
-
l10n
-
id
"
:
tooltip
"
data
-
l10n
-
args
"
:
tooltipArgs
?
JSON
.
stringify
(
tooltipArgs
)
:
null
className
:
"
context
-
menu
-
button
icon
"
onKeyDown
:
this
.
onKeyDown
onClick
:
this
.
onClick
ref
:
refFunction
tabIndex
:
this
.
props
.
tabIndex
|
|
0
onFocus
:
this
.
props
.
onFocus
}
)
showContextMenu
?
external_React_default
(
)
.
cloneElement
(
children
{
keyboardAccess
:
contextMenuKeyboard
onUpdate
:
this
.
onUpdate
}
)
:
null
)
;
}
}
;
class
_DSLinkMenu
extends
(
external_React_default
(
)
)
.
PureComponent
{
render
(
)
{
const
{
index
dispatch
}
=
this
.
props
;
let
TOP_STORIES_CONTEXT_MENU_OPTIONS
;
const
PREF_REPORT_ADS_ENABLED
=
"
discoverystream
.
reportAds
.
enabled
"
;
const
prefs
=
this
.
props
.
Prefs
.
values
;
const
showAdsReporting
=
prefs
[
PREF_REPORT_ADS_ENABLED
]
;
const
isSpoc
=
this
.
props
.
card_type
=
=
=
"
spoc
"
;
if
(
isSpoc
)
{
TOP_STORIES_CONTEXT_MENU_OPTIONS
=
[
"
BlockUrl
"
.
.
.
(
showAdsReporting
?
[
"
ReportAd
"
]
:
[
]
)
"
ManageSponsoredContent
"
"
OurSponsorsAndYourPrivacy
"
]
;
}
else
{
TOP_STORIES_CONTEXT_MENU_OPTIONS
=
[
"
CheckBookmark
"
"
Separator
"
"
OpenInNewWindow
"
"
OpenInPrivateWindow
"
"
Separator
"
"
BlockUrl
"
.
.
.
(
this
.
props
.
section
?
[
"
ReportContent
"
]
:
[
]
)
]
;
}
const
type
=
this
.
props
.
type
|
|
"
DISCOVERY_STREAM
"
;
const
title
=
this
.
props
.
title
|
|
this
.
props
.
source
;
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
context
-
menu
-
position
-
container
"
}
external_React_default
(
)
.
createElement
(
ContextMenuButton
{
tooltip
:
"
newtab
-
menu
-
content
-
tooltip
"
tooltipArgs
:
{
title
}
onUpdate
:
this
.
props
.
onMenuUpdate
}
external_React_default
(
)
.
createElement
(
LinkMenu
{
dispatch
:
dispatch
index
:
index
source
:
type
.
toUpperCase
(
)
onShow
:
this
.
props
.
onMenuShow
options
:
TOP_STORIES_CONTEXT_MENU_OPTIONS
shouldSendImpressionStats
:
true
userEvent
:
actionCreators
.
DiscoveryStreamUserEvent
site
:
{
referrer
:
"
https
:
/
/
getpocket
.
com
/
recommendations
"
title
:
this
.
props
.
title
type
:
this
.
props
.
type
url
:
this
.
props
.
url
guid
:
this
.
props
.
id
pocket_id
:
this
.
props
.
pocket_id
card_type
:
this
.
props
.
card_type
shim
:
this
.
props
.
shim
bookmarkGuid
:
this
.
props
.
bookmarkGuid
flight_id
:
this
.
props
.
flightId
tile_id
:
this
.
props
.
tile_id
recommendation_id
:
this
.
props
.
recommendation_id
corpus_item_id
:
this
.
props
.
corpus_item_id
scheduled_corpus_item_id
:
this
.
props
.
scheduled_corpus_item_id
firstVisibleTimestamp
:
this
.
props
.
firstVisibleTimestamp
recommended_at
:
this
.
props
.
recommended_at
received_rank
:
this
.
props
.
received_rank
topic
:
this
.
props
.
topic
is_list_card
:
this
.
props
.
is_list_card
position
:
index
.
.
.
(
this
.
props
.
format
?
{
format
:
this
.
props
.
format
}
:
{
}
)
.
.
.
(
this
.
props
.
section
?
{
section
:
this
.
props
.
section
section_position
:
this
.
props
.
section_position
is_section_followed
:
this
.
props
.
is_section_followed
}
:
{
}
)
}
}
)
)
)
;
}
}
const
DSLinkMenu
=
(
0
external_ReactRedux_namespaceObject
.
connect
)
(
state
=
>
(
{
Prefs
:
state
.
Prefs
}
)
)
(
_DSLinkMenu
)
;
;
function
useIntersectionObserver
(
callback
threshold
=
0
.
3
)
{
const
elementsRef
=
(
0
external_React_namespaceObject
.
useRef
)
(
[
]
)
;
const
triggeredElements
=
(
0
external_React_namespaceObject
.
useRef
)
(
new
WeakSet
(
)
)
;
(
0
external_React_namespaceObject
.
useEffect
)
(
(
)
=
>
{
const
observer
=
new
IntersectionObserver
(
entries
=
>
{
entries
.
forEach
(
entry
=
>
{
if
(
entry
.
isIntersecting
&
&
!
triggeredElements
.
current
.
has
(
entry
.
target
)
)
{
triggeredElements
.
current
.
add
(
entry
.
target
)
;
callback
(
entry
.
target
)
;
observer
.
unobserve
(
entry
.
target
)
;
}
}
)
;
}
{
threshold
}
)
;
elementsRef
.
current
.
forEach
(
el
=
>
{
if
(
el
&
&
!
triggeredElements
.
current
.
has
(
el
)
)
{
observer
.
observe
(
el
)
;
}
}
)
;
return
(
)
=
>
observer
.
disconnect
(
)
;
}
[
callback
threshold
]
)
;
return
elementsRef
;
}
function
getActiveCardSize
(
screenWidth
classNames
sectionsEnabled
flightId
)
{
if
(
flightId
)
{
return
"
spoc
"
;
}
if
(
!
sectionsEnabled
)
{
return
"
medium
-
card
"
;
}
if
(
!
screenWidth
|
|
!
classNames
)
{
return
null
;
}
const
classList
=
classNames
.
split
(
"
"
)
;
const
breakpoints
=
[
{
min
:
1374
column
:
"
col
-
4
"
}
{
min
:
1122
column
:
"
col
-
3
"
}
{
min
:
724
column
:
"
col
-
2
"
}
{
min
:
0
column
:
"
col
-
1
"
}
]
;
const
cardTypes
=
[
"
small
"
"
medium
"
"
large
"
]
;
const
currColumnCount
=
breakpoints
.
find
(
bp
=
>
screenWidth
>
=
bp
.
min
)
.
column
;
for
(
let
type
of
cardTypes
)
{
const
className
=
{
currColumnCount
}
-
{
type
}
;
if
(
classList
.
includes
(
className
)
)
{
if
(
screenWidth
<
610
&
&
currColumnCount
=
=
=
"
col
-
1
"
&
&
type
=
=
=
"
small
"
)
{
return
"
medium
-
card
"
;
}
return
{
type
}
-
card
;
}
}
return
null
;
}
;
const
TOP_SITES_SOURCE
=
"
TOP_SITES
"
;
const
TOP_SITES_CONTEXT_MENU_OPTIONS
=
[
"
CheckPinTopSite
"
"
EditTopSite
"
"
Separator
"
"
OpenInNewWindow
"
"
OpenInPrivateWindow
"
"
Separator
"
"
BlockUrl
"
"
DeleteUrl
"
]
;
const
TOP_SITES_SPOC_CONTEXT_MENU_OPTIONS
=
[
"
OpenInNewWindow
"
"
OpenInPrivateWindow
"
"
Separator
"
"
BlockUrl
"
"
ShowPrivacyInfo
"
]
;
const
TOP_SITES_SPONSORED_POSITION_CONTEXT_MENU_OPTIONS
=
[
"
OpenInNewWindow
"
"
OpenInPrivateWindow
"
"
Separator
"
"
BlockUrl
"
"
AboutSponsored
"
]
;
const
TOP_SITES_SEARCH_SHORTCUTS_CONTEXT_MENU_OPTIONS
=
[
"
CheckPinTopSite
"
"
Separator
"
"
BlockUrl
"
]
;
const
MIN_RICH_FAVICON_SIZE
=
96
;
const
MIN_SMALL_FAVICON_SIZE
=
16
;
;
const
VISIBLE
=
"
visible
"
;
const
VISIBILITY_CHANGE_EVENT
=
"
visibilitychange
"
;
const
INTERSECTION_RATIO
=
0
.
5
;
class
ImpressionStats_ImpressionStats
extends
(
external_React_default
(
)
)
.
PureComponent
{
_needsImpressionStats
(
cards
)
{
if
(
!
this
.
impressionCardGuids
|
|
this
.
impressionCardGuids
.
length
!
=
=
cards
.
length
)
{
return
true
;
}
for
(
let
i
=
0
;
i
<
cards
.
length
;
i
+
+
)
{
if
(
cards
[
i
]
.
id
!
=
=
this
.
impressionCardGuids
[
i
]
)
{
return
true
;
}
}
return
false
;
}
_dispatchImpressionStats
(
)
{
const
{
props
}
=
this
;
const
{
isFakespot
}
=
props
;
const
cards
=
props
.
rows
;
if
(
this
.
props
.
flightId
)
{
this
.
props
.
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
DISCOVERY_STREAM_SPOC_IMPRESSION
data
:
{
flightId
:
this
.
props
.
flightId
}
}
)
)
;
if
(
this
.
props
.
source
=
=
=
TOP_SITES_SOURCE
)
{
for
(
const
card
of
cards
)
{
this
.
props
.
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
TOP_SITES_SPONSORED_IMPRESSION_STATS
data
:
{
type
:
"
impression
"
tile_id
:
card
.
id
source
:
"
newtab
"
advertiser
:
card
.
advertiser
position
:
card
.
pos
}
}
)
)
;
}
}
}
if
(
this
.
_needsImpressionStats
(
cards
)
)
{
if
(
isFakespot
)
{
props
.
dispatch
(
actionCreators
.
DiscoveryStreamImpressionStats
(
{
source
:
props
.
source
.
toUpperCase
(
)
window_inner_width
:
window
.
innerWidth
window_inner_height
:
window
.
innerHeight
tiles
:
cards
.
map
(
link
=
>
(
{
id
:
link
.
id
type
:
"
fakespot
"
category
:
link
.
category
}
)
)
}
)
)
;
}
else
{
props
.
dispatch
(
actionCreators
.
DiscoveryStreamImpressionStats
(
{
source
:
props
.
source
.
toUpperCase
(
)
window_inner_width
:
window
.
innerWidth
window_inner_height
:
window
.
innerHeight
tiles
:
cards
.
map
(
link
=
>
(
{
id
:
link
.
id
pos
:
link
.
pos
type
:
props
.
flightId
?
"
spoc
"
:
"
organic
"
.
.
.
(
link
.
shim
?
{
shim
:
link
.
shim
}
:
{
}
)
recommendation_id
:
link
.
recommendation_id
fetchTimestamp
:
link
.
fetchTimestamp
corpus_item_id
:
link
.
corpus_item_id
scheduled_corpus_item_id
:
link
.
scheduled_corpus_item_id
recommended_at
:
link
.
recommended_at
received_rank
:
link
.
received_rank
topic
:
link
.
topic
features
:
link
.
features
is_list_card
:
link
.
is_list_card
.
.
.
(
link
.
format
?
{
format
:
link
.
format
}
:
{
format
:
getActiveCardSize
(
window
.
innerWidth
link
.
class_names
link
.
section
link
.
flightId
)
}
)
.
.
.
(
link
.
section
?
{
section
:
link
.
section
section_position
:
link
.
section_position
is_section_followed
:
link
.
is_section_followed
}
:
{
}
)
}
)
)
firstVisibleTimestamp
:
props
.
firstVisibleTimestamp
}
)
)
;
this
.
impressionCardGuids
=
cards
.
map
(
link
=
>
link
.
id
)
;
}
}
}
_needsLoadedContent
(
cards
)
{
if
(
!
this
.
loadedContentGuids
|
|
this
.
loadedContentGuids
.
length
!
=
=
cards
.
length
)
{
return
true
;
}
for
(
let
i
=
0
;
i
<
cards
.
length
;
i
+
+
)
{
if
(
cards
[
i
]
.
id
!
=
=
this
.
loadedContentGuids
[
i
]
)
{
return
true
;
}
}
return
false
;
}
_dispatchLoadedContent
(
)
{
const
{
props
}
=
this
;
const
cards
=
props
.
rows
;
if
(
this
.
_needsLoadedContent
(
cards
)
)
{
props
.
dispatch
(
actionCreators
.
DiscoveryStreamLoadedContent
(
{
source
:
props
.
source
.
toUpperCase
(
)
tiles
:
cards
.
map
(
link
=
>
(
{
id
:
link
.
id
pos
:
link
.
pos
}
)
)
}
)
)
;
this
.
loadedContentGuids
=
cards
.
map
(
link
=
>
link
.
id
)
;
}
}
setImpressionObserverOrAddListener
(
)
{
const
{
props
}
=
this
;
if
(
!
props
.
dispatch
)
{
return
;
}
if
(
props
.
document
.
visibilityState
=
=
=
VISIBLE
)
{
this
.
_dispatchLoadedContent
(
)
;
this
.
setImpressionObserver
(
)
;
}
else
{
if
(
this
.
_onVisibilityChange
)
{
props
.
document
.
removeEventListener
(
VISIBILITY_CHANGE_EVENT
this
.
_onVisibilityChange
)
;
}
this
.
_onVisibilityChange
=
(
)
=
>
{
if
(
props
.
document
.
visibilityState
=
=
=
VISIBLE
)
{
this
.
_dispatchLoadedContent
(
)
;
this
.
setImpressionObserver
(
)
;
props
.
document
.
removeEventListener
(
VISIBILITY_CHANGE_EVENT
this
.
_onVisibilityChange
)
;
}
}
;
props
.
document
.
addEventListener
(
VISIBILITY_CHANGE_EVENT
this
.
_onVisibilityChange
)
;
}
}
setImpressionObserver
(
)
{
const
{
props
}
=
this
;
if
(
!
props
.
rows
.
length
)
{
return
;
}
this
.
_handleIntersect
=
entries
=
>
{
if
(
entries
.
some
(
entry
=
>
entry
.
isIntersecting
&
&
entry
.
intersectionRatio
>
=
INTERSECTION_RATIO
)
)
{
this
.
_dispatchImpressionStats
(
)
;
this
.
impressionObserver
.
unobserve
(
this
.
refs
.
impression
)
;
}
}
;
const
options
=
{
threshold
:
INTERSECTION_RATIO
}
;
this
.
impressionObserver
=
new
props
.
IntersectionObserver
(
this
.
_handleIntersect
options
)
;
this
.
impressionObserver
.
observe
(
this
.
refs
.
impression
)
;
}
componentDidMount
(
)
{
if
(
this
.
props
.
rows
.
length
)
{
this
.
setImpressionObserverOrAddListener
(
)
;
}
}
componentWillUnmount
(
)
{
if
(
this
.
_handleIntersect
&
&
this
.
impressionObserver
)
{
this
.
impressionObserver
.
unobserve
(
this
.
refs
.
impression
)
;
}
if
(
this
.
_onVisibilityChange
)
{
this
.
props
.
document
.
removeEventListener
(
VISIBILITY_CHANGE_EVENT
this
.
_onVisibilityChange
)
;
}
}
render
(
)
{
return
external_React_default
(
)
.
createElement
(
"
div
"
{
ref
:
"
impression
"
className
:
"
impression
-
observer
"
}
this
.
props
.
children
)
;
}
}
ImpressionStats_ImpressionStats
.
defaultProps
=
{
IntersectionObserver
:
globalThis
.
IntersectionObserver
document
:
globalThis
.
document
rows
:
[
]
source
:
"
"
}
;
;
function
SafeAnchor_extends
(
)
{
return
SafeAnchor_extends
=
Object
.
assign
?
Object
.
assign
.
bind
(
)
:
function
(
n
)
{
for
(
var
e
=
1
;
e
<
arguments
.
length
;
e
+
+
)
{
var
t
=
arguments
[
e
]
;
for
(
var
r
in
t
)
(
{
}
)
.
hasOwnProperty
.
call
(
t
r
)
&
&
(
n
[
r
]
=
t
[
r
]
)
;
}
return
n
;
}
SafeAnchor_extends
.
apply
(
null
arguments
)
;
}
class
SafeAnchor
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
onClick
=
this
.
onClick
.
bind
(
this
)
;
}
onClick
(
event
)
{
if
(
this
.
props
.
dispatch
)
{
event
.
preventDefault
(
)
;
const
{
altKey
button
ctrlKey
metaKey
shiftKey
}
=
event
;
this
.
props
.
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
OPEN_LINK
data
:
{
event
:
{
altKey
button
ctrlKey
metaKey
shiftKey
}
referrer
:
this
.
props
.
referrer
|
|
"
https
:
/
/
getpocket
.
com
/
recommendations
"
url
:
event
.
currentTarget
.
href
}
}
)
)
;
}
if
(
this
.
props
.
onLinkClick
)
{
this
.
props
.
onLinkClick
(
event
)
;
}
}
safeURI
(
url
)
{
let
protocol
=
null
;
try
{
protocol
=
new
URL
(
url
)
.
protocol
;
}
catch
(
e
)
{
return
"
"
;
}
const
isAllowed
=
[
"
http
:
"
"
https
:
"
]
.
includes
(
protocol
)
;
if
(
!
isAllowed
)
{
console
.
warn
(
{
url
}
is
not
allowed
for
anchor
targets
.
)
;
return
"
"
;
}
return
url
;
}
render
(
)
{
const
{
url
className
title
}
=
this
.
props
;
let
anchor
=
external_React_default
(
)
.
createElement
(
"
a
"
SafeAnchor_extends
(
{
href
:
this
.
safeURI
(
url
)
title
:
title
className
:
className
onClick
:
this
.
onClick
}
this
.
props
.
tabIndex
=
=
=
0
|
|
this
.
props
.
tabIndex
?
{
ref
:
this
.
props
.
setRef
tabIndex
:
this
.
props
.
tabIndex
}
:
{
}
)
this
.
props
.
children
)
;
return
anchor
;
}
}
;
const
cardContextTypes
=
{
history
:
{
fluentID
:
"
newtab
-
label
-
visited
"
icon
:
"
history
-
item
"
}
removedBookmark
:
{
fluentID
:
"
newtab
-
label
-
removed
-
bookmark
"
icon
:
"
bookmark
-
removed
"
}
bookmark
:
{
fluentID
:
"
newtab
-
label
-
bookmarked
"
icon
:
"
bookmark
-
added
"
}
trending
:
{
fluentID
:
"
newtab
-
label
-
recommended
"
icon
:
"
trending
"
}
pocket
:
{
fluentID
:
"
newtab
-
label
-
saved
"
icon
:
"
pocket
"
}
download
:
{
fluentID
:
"
newtab
-
label
-
download
"
icon
:
"
download
"
}
}
;
;
function
FeatureHighlight
(
{
message
icon
toggle
arrowPosition
=
"
"
position
=
"
top
-
left
"
verticalPosition
=
"
"
title
ariaLabel
feature
=
"
FEATURE_HIGHLIGHT_DEFAULT
"
dispatch
=
(
)
=
>
{
}
windowObj
=
__webpack_require__
.
g
openedOverride
=
false
showButtonIcon
=
true
dismissCallback
=
(
)
=
>
{
}
outsideClickCallback
=
(
)
=
>
{
}
}
)
{
const
[
opened
setOpened
]
=
(
0
external_React_namespaceObject
.
useState
)
(
openedOverride
)
;
const
ref
=
(
0
external_React_namespaceObject
.
useRef
)
(
null
)
;
(
0
external_React_namespaceObject
.
useEffect
)
(
(
)
=
>
{
const
handleOutsideClick
=
e
=
>
{
if
(
!
ref
?
.
current
?
.
contains
(
e
.
target
)
)
{
setOpened
(
false
)
;
outsideClickCallback
(
)
;
}
}
;
const
handleKeyDown
=
e
=
>
{
if
(
e
.
key
=
=
=
"
Escape
"
)
{
outsideClickCallback
(
)
;
}
}
;
windowObj
.
document
.
addEventListener
(
"
click
"
handleOutsideClick
)
;
windowObj
.
document
.
addEventListener
(
"
keydown
"
handleKeyDown
)
;
return
(
)
=
>
{
windowObj
.
document
.
removeEventListener
(
"
click
"
handleOutsideClick
)
;
windowObj
.
document
.
removeEventListener
(
"
keydown
"
handleKeyDown
)
;
}
;
}
[
windowObj
outsideClickCallback
]
)
;
const
onToggleClick
=
(
0
external_React_namespaceObject
.
useCallback
)
(
(
)
=
>
{
if
(
!
opened
)
{
dispatch
(
actionCreators
.
DiscoveryStreamUserEvent
(
{
event
:
"
CLICK
"
source
:
"
FEATURE_HIGHLIGHT
"
value
:
{
feature
}
}
)
)
;
}
setOpened
(
!
opened
)
;
}
[
dispatch
feature
opened
]
)
;
const
onDismissClick
=
(
0
external_React_namespaceObject
.
useCallback
)
(
(
)
=
>
{
setOpened
(
false
)
;
dismissCallback
(
)
;
}
[
dismissCallback
]
)
;
const
hideButtonClass
=
showButtonIcon
?
:
isHidden
;
const
openedClassname
=
opened
?
opened
:
closed
;
return
external_React_default
(
)
.
createElement
(
"
div
"
{
ref
:
ref
className
:
feature
-
highlight
{
verticalPosition
}
}
external_React_default
(
)
.
createElement
(
"
button
"
{
title
:
title
"
aria
-
haspopup
"
:
"
true
"
"
aria
-
label
"
:
ariaLabel
className
:
toggle
-
button
{
hideButtonClass
}
onClick
:
onToggleClick
}
toggle
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
feature
-
highlight
-
modal
{
position
}
{
arrowPosition
}
{
openedClassname
}
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
message
-
icon
"
}
icon
)
external_React_default
(
)
.
createElement
(
"
p
"
{
className
:
"
content
-
wrapper
"
}
message
)
external_React_default
(
)
.
createElement
(
"
moz
-
button
"
{
type
:
"
icon
ghost
"
size
:
"
small
"
"
data
-
l10n
-
id
"
:
"
feature
-
highlight
-
dismiss
-
button
"
iconsrc
:
"
chrome
:
/
/
global
/
skin
/
icons
/
close
.
svg
"
onClick
:
onDismissClick
onKeyDown
:
onDismissClick
}
)
)
)
;
}
;
function
SponsoredContentHighlight
(
{
position
dispatch
}
)
{
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
sponsored
-
content
-
highlight
"
}
external_React_default
(
)
.
createElement
(
FeatureHighlight
{
position
:
position
ariaLabel
:
"
Sponsored
content
supports
our
mission
to
build
a
better
web
.
"
title
:
"
Sponsored
content
more
info
"
feature
:
"
SPONSORED_CONTENT_INFO
"
dispatch
:
dispatch
message
:
external_React_default
(
)
.
createElement
(
"
span
"
null
"
Sponsored
content
supports
our
mission
to
build
a
better
web
.
"
"
"
external_React_default
(
)
.
createElement
(
SafeAnchor
{
dispatch
:
dispatch
url
:
"
https
:
/
/
support
.
mozilla
.
org
/
kb
/
pocket
-
sponsored
-
stories
-
new
-
tabs
"
}
"
Find
out
how
"
)
)
icon
:
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
sponsored
-
message
-
icon
"
}
)
toggle
:
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
icon
icon
-
help
"
}
)
}
)
)
;
}
;
const
external_ReactTransitionGroup_namespaceObject
=
ReactTransitionGroup
;
;
class
FluentOrText
extends
(
external_React_default
(
)
)
.
PureComponent
{
render
(
)
{
const
{
children
message
}
=
this
.
props
;
const
child
=
children
?
external_React_default
(
)
.
Children
.
only
(
children
)
:
external_React_default
(
)
.
createElement
(
"
span
"
null
)
;
let
grandChildren
=
message
;
let
extraProps
;
if
(
typeof
message
=
=
=
"
object
"
)
{
const
args
=
message
.
args
|
|
message
.
values
;
extraProps
=
{
"
data
-
l10n
-
args
"
:
args
&
&
JSON
.
stringify
(
args
)
"
data
-
l10n
-
id
"
:
message
.
id
|
|
message
.
string_id
}
;
grandChildren
=
child
.
props
.
children
;
}
return
external_React_default
(
)
.
cloneElement
(
child
extraProps
grandChildren
)
;
}
}
;
const
ANIMATION_DURATION
=
3000
;
const
DSMessageLabel
=
props
=
>
{
const
{
context
context_type
mayHaveSectionsCards
}
=
props
;
const
{
icon
fluentID
}
=
cardContextTypes
[
context_type
]
|
|
{
}
;
if
(
!
context
&
&
context_type
&
&
!
mayHaveSectionsCards
)
{
return
external_React_default
(
)
.
createElement
(
external_ReactTransitionGroup_namespaceObject
.
TransitionGroup
{
component
:
null
}
external_React_default
(
)
.
createElement
(
external_ReactTransitionGroup_namespaceObject
.
CSSTransition
{
key
:
fluentID
timeout
:
ANIMATION_DURATION
classNames
:
"
story
-
animate
"
}
external_React_default
(
)
.
createElement
(
StatusMessage
{
icon
:
icon
fluentID
:
fluentID
}
)
)
)
;
}
return
null
;
}
;
const
StatusMessage
=
(
{
icon
fluentID
}
)
=
>
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
status
-
message
"
}
external_React_default
(
)
.
createElement
(
"
span
"
{
"
aria
-
haspopup
"
:
"
true
"
className
:
story
-
badge
-
icon
icon
icon
-
{
icon
}
}
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
story
-
context
-
label
"
"
data
-
l10n
-
id
"
:
fluentID
}
)
)
;
const
SponsorLabel
=
(
{
sponsored_by_override
sponsor
context
newSponsoredLabel
}
)
=
>
{
const
classList
=
story
-
sponsored
-
label
{
newSponsoredLabel
|
|
"
"
}
clamp
;
if
(
sponsored_by_override
)
{
return
external_React_default
(
)
.
createElement
(
"
p
"
{
className
:
classList
}
sponsored_by_override
)
;
}
else
if
(
sponsored_by_override
=
=
=
"
"
)
{
return
null
;
}
else
if
(
sponsor
)
{
return
external_React_default
(
)
.
createElement
(
"
p
"
{
className
:
classList
}
external_React_default
(
)
.
createElement
(
FluentOrText
{
message
:
{
id
:
newtab
-
label
-
sponsored
-
by
values
:
{
sponsor
}
}
}
)
)
;
}
else
if
(
context
)
{
return
external_React_default
(
)
.
createElement
(
"
p
"
{
className
:
classList
}
context
)
;
}
return
null
;
}
;
class
DSContextFooter
extends
(
external_React_default
(
)
)
.
PureComponent
{
render
(
)
{
const
{
context
context_type
sponsor
sponsored_by_override
cta_button_variant
source
spocMessageVariant
dispatch
mayHaveSectionsCards
}
=
this
.
props
;
const
sponsorLabel
=
SponsorLabel
(
{
sponsored_by_override
sponsor
context
}
)
;
const
dsMessageLabel
=
DSMessageLabel
(
{
context
context_type
mayHaveSectionsCards
}
)
;
if
(
cta_button_variant
=
=
=
"
variant
-
a
"
)
{
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
story
-
footer
"
}
external_React_default
(
)
.
createElement
(
"
button
"
{
"
aria
-
hidden
"
:
"
true
"
className
:
"
story
-
cta
-
button
"
}
"
Shop
Now
"
)
sponsorLabel
)
;
}
if
(
cta_button_variant
=
=
=
"
variant
-
b
"
)
{
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
story
-
footer
"
}
sponsorLabel
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
source
clamp
cta
-
footer
-
source
"
}
source
)
)
;
}
if
(
sponsorLabel
|
|
dsMessageLabel
&
&
context_type
!
=
=
"
pocket
"
)
{
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
story
-
footer
"
}
sponsorLabel
sponsorLabel
&
&
spocMessageVariant
=
=
=
"
variant
-
b
"
&
&
external_React_default
(
)
.
createElement
(
SponsoredContentHighlight
{
dispatch
:
dispatch
position
:
"
inset
-
block
-
end
inset
-
inline
-
start
"
}
)
dsMessageLabel
)
;
}
return
null
;
}
}
const
DSMessageFooter
=
props
=
>
{
const
{
context
context_type
}
=
props
;
const
dsMessageLabel
=
DSMessageLabel
(
{
context
context_type
}
)
;
if
(
!
dsMessageLabel
)
{
return
null
;
}
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
story
-
footer
"
}
dsMessageLabel
)
;
}
;
;
function
DSThumbsUpDownButtons
(
{
sponsor
onThumbsUpClick
onThumbsDownClick
isThumbsUpActive
isThumbsDownActive
refinedCardsLayout
}
)
{
let
thumbsButtons
=
external_React_default
(
)
.
createElement
(
(
external_React_default
(
)
)
.
Fragment
null
external_React_default
(
)
.
createElement
(
"
button
"
{
onClick
:
onThumbsUpClick
className
:
card
-
stp
-
thumbs
-
button
icon
icon
-
thumbs
-
up
{
isThumbsUpActive
?
"
is
-
active
"
:
null
}
"
data
-
l10n
-
id
"
:
"
newtab
-
pocket
-
thumbs
-
up
-
tooltip
"
}
)
external_React_default
(
)
.
createElement
(
"
button
"
{
onClick
:
onThumbsDownClick
className
:
card
-
stp
-
thumbs
-
button
icon
icon
-
thumbs
-
down
{
isThumbsDownActive
?
"
is
-
active
"
:
null
}
"
data
-
l10n
-
id
"
:
"
newtab
-
pocket
-
thumbs
-
down
-
tooltip
"
}
)
)
;
if
(
refinedCardsLayout
)
{
thumbsButtons
=
external_React_default
(
)
.
createElement
(
(
external_React_default
(
)
)
.
Fragment
null
external_React_default
(
)
.
createElement
(
"
moz
-
button
"
{
iconsrc
:
"
chrome
:
/
/
global
/
skin
/
icons
/
thumbs
-
up
-
20
.
svg
"
onClick
:
onThumbsUpClick
className
:
card
-
stp
-
thumbs
-
button
icon
icon
-
thumbs
-
up
refined
-
layout
{
isThumbsUpActive
?
"
is
-
active
"
:
null
}
"
data
-
l10n
-
id
"
:
"
newtab
-
pocket
-
thumbs
-
up
-
tooltip
"
type
:
"
icon
ghost
"
}
)
external_React_default
(
)
.
createElement
(
"
moz
-
button
"
{
iconsrc
:
"
chrome
:
/
/
global
/
skin
/
icons
/
thumbs
-
down
-
20
.
svg
"
onClick
:
onThumbsDownClick
className
:
card
-
stp
-
thumbs
-
button
icon
icon
-
thumbs
-
down
{
isThumbsDownActive
?
"
is
-
active
"
:
null
}
"
data
-
l10n
-
id
"
:
"
newtab
-
pocket
-
thumbs
-
down
-
tooltip
"
type
:
"
icon
ghost
"
}
)
)
;
}
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
card
-
stp
-
thumbs
-
buttons
-
wrapper
"
}
!
sponsor
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
card
-
stp
-
thumbs
-
buttons
"
}
thumbsButtons
)
)
;
}
;
const
READING_WPM
=
220
;
const
PREF_OHTTP_MERINO
=
"
discoverystream
.
merino
-
provider
.
ohttp
.
enabled
"
;
const
PREF_OHTTP_UNIFIED_ADS
=
"
unifiedAds
.
ohttp
.
enabled
"
;
const
PREF_CONTEXTUAL_ADS
=
"
discoverystream
.
sections
.
contextualAds
.
enabled
"
;
const
PREF_INFERRED_PERSONALIZATION_SYSTEM
=
"
discoverystream
.
sections
.
personalization
.
inferred
.
enabled
"
;
const
PREF_INFERRED_PERSONALIZATION_USER
=
"
discoverystream
.
sections
.
personalization
.
inferred
.
user
.
enabled
"
;
const
DSCard_PREF_SECTIONS_ENABLED
=
"
discoverystream
.
sections
.
enabled
"
;
const
PREF_FAVICONS_ENABLED
=
"
discoverystream
.
publisherFavicon
.
enabled
"
;
function
readTimeFromWordCount
(
wordCount
)
{
if
(
!
wordCount
)
{
return
false
;
}
return
Math
.
ceil
(
parseInt
(
wordCount
10
)
/
READING_WPM
)
;
}
const
DSSource
=
(
{
source
timeToRead
newSponsoredLabel
context
sponsor
sponsored_by_override
icon_src
refinedCardsLayout
}
)
=
>
{
const
faviconSize
=
refinedCardsLayout
?
20
:
16
;
if
(
newSponsoredLabel
)
{
if
(
sponsored_by_override
|
|
sponsor
|
|
context
)
{
return
external_React_default
(
)
.
createElement
(
SponsorLabel
{
context
:
context
sponsor
:
sponsor
sponsored_by_override
:
sponsored_by_override
newSponsoredLabel
:
"
new
-
sponsored
-
label
"
}
)
;
}
}
if
(
source
&
&
timeToRead
)
{
return
external_React_default
(
)
.
createElement
(
"
p
"
{
className
:
"
source
clamp
time
-
to
-
read
"
}
external_React_default
(
)
.
createElement
(
FluentOrText
{
message
:
{
id
:
newtab
-
label
-
source
-
read
-
time
values
:
{
source
timeToRead
}
}
}
)
)
;
}
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
source
-
wrapper
"
}
icon_src
&
&
external_React_default
(
)
.
createElement
(
"
img
"
{
src
:
icon_src
height
:
faviconSize
width
:
faviconSize
alt
:
"
"
}
)
external_React_default
(
)
.
createElement
(
"
p
"
{
className
:
"
source
clamp
"
}
source
)
)
;
}
;
const
DefaultMeta
=
(
{
source
title
excerpt
timeToRead
newSponsoredLabel
context
context_type
sponsor
sponsored_by_override
ctaButtonVariant
dispatch
spocMessageVariant
mayHaveSectionsCards
mayHaveThumbsUpDown
onThumbsUpClick
onThumbsDownClick
isListCard
state
format
topic
isSectionsCard
showTopics
icon_src
refinedCardsLayout
}
)
=
>
{
const
shouldHaveThumbs
=
!
isListCard
&
&
format
!
=
=
"
rectangle
"
&
&
mayHaveSectionsCards
&
&
mayHaveThumbsUpDown
;
const
shouldHaveFooterSection
=
isSectionsCard
&
&
(
shouldHaveThumbs
|
|
showTopics
)
;
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
meta
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
info
-
wrap
"
}
ctaButtonVariant
!
=
=
"
variant
-
b
"
&
&
format
!
=
=
"
rectangle
"
&
&
!
refinedCardsLayout
&
&
external_React_default
(
)
.
createElement
(
DSSource
{
source
:
source
timeToRead
:
timeToRead
newSponsoredLabel
:
newSponsoredLabel
context
:
context
sponsor
:
sponsor
sponsored_by_override
:
sponsored_by_override
icon_src
:
icon_src
}
)
external_React_default
(
)
.
createElement
(
"
h3
"
{
className
:
"
title
clamp
"
}
format
=
=
=
"
rectangle
"
?
"
Sponsored
"
:
title
)
format
=
=
=
"
rectangle
"
?
external_React_default
(
)
.
createElement
(
"
p
"
{
className
:
"
excerpt
clamp
"
}
"
Sponsored
content
supports
our
mission
to
build
a
better
web
.
"
)
:
excerpt
&
&
external_React_default
(
)
.
createElement
(
"
p
"
{
className
:
"
excerpt
clamp
"
}
excerpt
)
)
!
isListCard
&
&
format
!
=
=
"
rectangle
"
&
&
!
mayHaveSectionsCards
&
&
mayHaveThumbsUpDown
&
&
!
refinedCardsLayout
&
&
external_React_default
(
)
.
createElement
(
DSThumbsUpDownButtons
{
onThumbsDownClick
:
onThumbsDownClick
onThumbsUpClick
:
onThumbsUpClick
sponsor
:
sponsor
isThumbsDownActive
:
state
.
isThumbsDownActive
isThumbsUpActive
:
state
.
isThumbsUpActive
}
)
(
shouldHaveFooterSection
|
|
refinedCardsLayout
)
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
sections
-
card
-
footer
"
}
refinedCardsLayout
&
&
format
!
=
=
"
rectangle
"
&
&
format
!
=
=
"
spoc
"
&
&
external_React_default
(
)
.
createElement
(
DSSource
{
source
:
source
timeToRead
:
timeToRead
newSponsoredLabel
:
newSponsoredLabel
context
:
context
sponsor
:
sponsor
sponsored_by_override
:
sponsored_by_override
icon_src
:
icon_src
refinedCardsLayout
:
refinedCardsLayout
}
)
(
shouldHaveThumbs
|
|
refinedCardsLayout
)
&
&
external_React_default
(
)
.
createElement
(
DSThumbsUpDownButtons
{
onThumbsDownClick
:
onThumbsDownClick
onThumbsUpClick
:
onThumbsUpClick
sponsor
:
sponsor
isThumbsDownActive
:
state
.
isThumbsDownActive
isThumbsUpActive
:
state
.
isThumbsUpActive
refinedCardsLayout
:
refinedCardsLayout
}
)
showTopics
&
&
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
ds
-
card
-
topic
"
"
data
-
l10n
-
id
"
:
newtab
-
topic
-
label
-
{
topic
}
}
)
)
!
newSponsoredLabel
&
&
external_React_default
(
)
.
createElement
(
DSContextFooter
{
context_type
:
context_type
context
:
context
sponsor
:
sponsor
sponsored_by_override
:
sponsored_by_override
cta_button_variant
:
ctaButtonVariant
source
:
source
dispatch
:
dispatch
spocMessageVariant
:
spocMessageVariant
mayHaveSectionsCards
:
mayHaveSectionsCards
}
)
newSponsoredLabel
&
&
external_React_default
(
)
.
createElement
(
DSMessageFooter
{
context_type
:
context_type
context
:
null
}
)
)
;
}
;
class
_DSCard
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
onLinkClick
=
this
.
onLinkClick
.
bind
(
this
)
;
this
.
doesLinkTopicMatchSelectedTopic
=
this
.
doesLinkTopicMatchSelectedTopic
.
bind
(
this
)
;
this
.
onMenuUpdate
=
this
.
onMenuUpdate
.
bind
(
this
)
;
this
.
onMenuShow
=
this
.
onMenuShow
.
bind
(
this
)
;
this
.
onThumbsUpClick
=
this
.
onThumbsUpClick
.
bind
(
this
)
;
this
.
onThumbsDownClick
=
this
.
onThumbsDownClick
.
bind
(
this
)
;
const
refinedCardsLayout
=
this
.
props
.
Prefs
.
values
[
"
discoverystream
.
refinedCardsLayout
.
enabled
"
]
;
this
.
setContextMenuButtonHostRef
=
element
=
>
{
this
.
contextMenuButtonHostElement
=
element
;
}
;
this
.
setPlaceholderRef
=
element
=
>
{
this
.
placeholderElement
=
element
;
}
;
this
.
state
=
{
isSeen
:
false
isThumbsUpActive
:
false
isThumbsDownActive
:
false
}
;
if
(
props
.
App
.
isForStartupCache
.
App
)
{
this
.
state
.
isSeen
=
true
;
}
this
.
dsImageSizes
=
[
{
mediaMatcher
:
"
(
min
-
width
:
1122px
)
"
width
:
296
height
:
148
}
{
mediaMatcher
:
"
(
min
-
width
:
866px
)
"
width
:
218
height
:
109
}
{
mediaMatcher
:
"
(
max
-
width
:
610px
)
"
width
:
202
height
:
101
}
]
;
this
.
standardCardImageSizes
=
[
{
mediaMatcher
:
"
default
"
width
:
296
height
:
148
}
]
;
this
.
listCardImageSizes
=
[
{
mediaMatcher
:
"
(
min
-
width
:
1122px
)
"
width
:
75
height
:
75
}
{
mediaMatcher
:
"
default
"
width
:
50
height
:
50
}
]
;
this
.
sectionsCardImagesSizes
=
{
small
:
{
width
:
110
height
:
117
}
medium
:
{
width
:
300
height
:
refinedCardsLayout
?
160
:
150
}
large
:
{
width
:
190
height
:
250
}
}
;
this
.
sectionsColumnMediaMatcher
=
{
1
:
"
default
"
2
:
"
(
min
-
width
:
724px
)
"
3
:
"
(
min
-
width
:
1122px
)
"
4
:
"
(
min
-
width
:
1390px
)
"
}
;
}
getSectionImageSize
(
column
size
)
{
const
cardImageSize
=
{
mediaMatcher
:
this
.
sectionsColumnMediaMatcher
[
column
]
width
:
this
.
sectionsCardImagesSizes
[
size
]
.
width
height
:
this
.
sectionsCardImagesSizes
[
size
]
.
height
}
;
return
cardImageSize
;
}
doesLinkTopicMatchSelectedTopic
(
)
{
if
(
!
this
.
props
.
selectedTopics
)
{
return
"
not
-
set
"
;
}
if
(
!
this
.
props
.
availableTopics
.
includes
(
this
.
props
.
topic
)
)
{
return
"
topic
-
not
-
selectable
"
;
}
if
(
this
.
props
.
selectedTopics
.
includes
(
this
.
props
.
topic
)
)
{
return
"
true
"
;
}
return
"
false
"
;
}
onLinkClick
(
)
{
const
matchesSelectedTopic
=
this
.
doesLinkTopicMatchSelectedTopic
(
)
;
if
(
this
.
props
.
dispatch
)
{
if
(
this
.
props
.
isFakespot
)
{
this
.
props
.
dispatch
(
actionCreators
.
DiscoveryStreamUserEvent
(
{
event
:
"
FAKESPOT_CLICK
"
value
:
{
product_id
:
this
.
props
.
id
category
:
this
.
props
.
category
|
|
"
"
}
}
)
)
;
}
else
{
this
.
props
.
dispatch
(
actionCreators
.
DiscoveryStreamUserEvent
(
{
event
:
"
CLICK
"
source
:
this
.
props
.
type
.
toUpperCase
(
)
action_position
:
this
.
props
.
pos
value
:
{
event_source
:
"
card
"
card_type
:
this
.
props
.
flightId
?
"
spoc
"
:
"
organic
"
recommendation_id
:
this
.
props
.
recommendation_id
tile_id
:
this
.
props
.
id
.
.
.
(
this
.
props
.
shim
&
&
this
.
props
.
shim
.
click
?
{
shim
:
this
.
props
.
shim
.
click
}
:
{
}
)
fetchTimestamp
:
this
.
props
.
fetchTimestamp
firstVisibleTimestamp
:
this
.
props
.
firstVisibleTimestamp
corpus_item_id
:
this
.
props
.
corpus_item_id
scheduled_corpus_item_id
:
this
.
props
.
scheduled_corpus_item_id
recommended_at
:
this
.
props
.
recommended_at
received_rank
:
this
.
props
.
received_rank
topic
:
this
.
props
.
topic
features
:
this
.
props
.
features
matches_selected_topic
:
matchesSelectedTopic
selected_topics
:
this
.
props
.
selectedTopics
is_list_card
:
this
.
props
.
isListCard
.
.
.
(
this
.
props
.
format
?
{
format
:
this
.
props
.
format
}
:
{
format
:
getActiveCardSize
(
window
.
innerWidth
this
.
props
.
sectionsClassNames
this
.
props
.
section
this
.
props
.
flightId
)
}
)
.
.
.
(
this
.
props
.
section
?
{
section
:
this
.
props
.
section
section_position
:
this
.
props
.
sectionPosition
is_section_followed
:
this
.
props
.
sectionFollowed
}
:
{
}
)
}
}
)
)
;
this
.
props
.
dispatch
(
actionCreators
.
ImpressionStats
(
{
source
:
this
.
props
.
type
.
toUpperCase
(
)
click
:
0
window_inner_width
:
this
.
props
.
windowObj
.
innerWidth
window_inner_height
:
this
.
props
.
windowObj
.
innerHeight
tiles
:
[
{
id
:
this
.
props
.
id
pos
:
this
.
props
.
pos
.
.
.
(
this
.
props
.
shim
&
&
this
.
props
.
shim
.
click
?
{
shim
:
this
.
props
.
shim
.
click
}
:
{
}
)
type
:
this
.
props
.
flightId
?
"
spoc
"
:
"
organic
"
recommendation_id
:
this
.
props
.
recommendation_id
topic
:
this
.
props
.
topic
selected_topics
:
this
.
props
.
selectedTopics
is_list_card
:
this
.
props
.
isListCard
.
.
.
(
this
.
props
.
format
?
{
format
:
this
.
props
.
format
}
:
{
format
:
getActiveCardSize
(
window
.
innerWidth
this
.
props
.
sectionsClassNames
this
.
props
.
section
this
.
props
.
flightId
)
}
)
.
.
.
(
this
.
props
.
section
?
{
section
:
this
.
props
.
section
section_position
:
this
.
props
.
sectionPosition
is_section_followed
:
this
.
props
.
sectionFollowed
}
:
{
}
)
}
]
}
)
)
;
}
}
}
onThumbsUpClick
(
event
)
{
event
.
stopPropagation
(
)
;
event
.
preventDefault
(
)
;
const
currentState
=
this
.
state
.
isThumbsUpActive
;
if
(
currentState
)
{
return
;
}
this
.
setState
(
{
isThumbsUpActive
:
!
currentState
}
)
;
this
.
props
.
dispatch
(
actionCreators
.
DiscoveryStreamUserEvent
(
{
event
:
"
POCKET_THUMBS_UP
"
source
:
"
THUMBS_UI
"
value
:
{
recommendation_id
:
this
.
props
.
recommendation_id
tile_id
:
this
.
props
.
id
corpus_item_id
:
this
.
props
.
corpus_item_id
scheduled_corpus_item_id
:
this
.
props
.
scheduled_corpus_item_id
recommended_at
:
this
.
props
.
recommended_at
received_rank
:
this
.
props
.
received_rank
thumbs_up
:
true
thumbs_down
:
false
topic
:
this
.
props
.
topic
format
:
getActiveCardSize
(
window
.
innerWidth
this
.
props
.
sectionsClassNames
this
.
props
.
section
false
)
.
.
.
(
this
.
props
.
section
?
{
section
:
this
.
props
.
section
section_position
:
this
.
props
.
sectionPosition
is_section_followed
:
this
.
props
.
sectionFollowed
}
:
{
}
)
}
}
)
)
;
this
.
props
.
dispatch
(
actionCreators
.
OnlyToOneContent
(
{
type
:
actionTypes
.
SHOW_TOAST_MESSAGE
data
:
{
showNotifications
:
true
toastId
:
"
thumbsUpToast
"
}
}
"
ActivityStream
:
Content
"
)
)
;
}
onThumbsDownClick
(
event
)
{
event
.
stopPropagation
(
)
;
event
.
preventDefault
(
)
;
const
currentState
=
this
.
state
.
isThumbsDownActive
;
this
.
setState
(
{
isThumbsDownActive
:
!
currentState
}
)
;
if
(
this
.
props
.
dispatch
&
&
this
.
props
.
type
&
&
this
.
props
.
id
&
&
this
.
props
.
url
)
{
const
index
=
this
.
props
.
pos
;
const
source
=
this
.
props
.
type
.
toUpperCase
(
)
;
const
spocData
=
{
url
:
this
.
props
.
url
guid
:
this
.
props
.
id
type
:
"
CardGrid
"
card_type
:
"
organic
"
recommendation_id
:
this
.
props
.
recommendation_id
tile_id
:
this
.
props
.
id
corpus_item_id
:
this
.
props
.
corpus_item_id
scheduled_corpus_item_id
:
this
.
props
.
scheduled_corpus_item_id
recommended_at
:
this
.
props
.
recommended_at
received_rank
:
this
.
props
.
received_rank
}
;
const
blockUrlOption
=
LinkMenuOptions
.
BlockUrl
(
spocData
index
source
)
;
const
{
action
impression
userEvent
}
=
blockUrlOption
;
setTimeout
(
(
)
=
>
{
this
.
props
.
dispatch
(
action
)
;
this
.
props
.
dispatch
(
actionCreators
.
DiscoveryStreamUserEvent
(
{
event
:
userEvent
source
action_position
:
index
}
)
)
;
}
500
)
;
if
(
impression
)
{
this
.
props
.
dispatch
(
impression
)
;
}
this
.
props
.
dispatch
(
actionCreators
.
DiscoveryStreamUserEvent
(
{
event
:
"
POCKET_THUMBS_DOWN
"
source
:
"
THUMBS_UI
"
value
:
{
recommendation_id
:
this
.
props
.
recommendation_id
tile_id
:
this
.
props
.
id
corpus_item_id
:
this
.
props
.
corpus_item_id
scheduled_corpus_item_id
:
this
.
props
.
scheduled_corpus_item_id
recommended_at
:
this
.
props
.
recommended_at
received_rank
:
this
.
props
.
received_rank
thumbs_up
:
false
thumbs_down
:
true
topic
:
this
.
props
.
topic
format
:
getActiveCardSize
(
window
.
innerWidth
this
.
props
.
sectionsClassNames
this
.
props
.
section
false
)
.
.
.
(
this
.
props
.
section
?
{
section
:
this
.
props
.
section
section_position
:
this
.
props
.
sectionPosition
is_section_followed
:
this
.
props
.
sectionFollowed
}
:
{
}
)
}
}
)
)
;
this
.
props
.
dispatch
(
actionCreators
.
OnlyToOneContent
(
{
type
:
actionTypes
.
SHOW_TOAST_MESSAGE
data
:
{
showNotifications
:
true
toastId
:
"
thumbsDownToast
"
}
}
"
ActivityStream
:
Content
"
)
)
;
}
}
onMenuUpdate
(
showContextMenu
)
{
if
(
!
showContextMenu
)
{
const
dsLinkMenuHostDiv
=
this
.
contextMenuButtonHostElement
;
if
(
dsLinkMenuHostDiv
)
{
dsLinkMenuHostDiv
.
classList
.
remove
(
"
active
"
"
last
-
item
"
)
;
}
}
}
async
onMenuShow
(
)
{
const
dsLinkMenuHostDiv
=
this
.
contextMenuButtonHostElement
;
if
(
dsLinkMenuHostDiv
)
{
await
this
.
props
.
windowObj
.
document
.
l10n
.
translateFragment
(
dsLinkMenuHostDiv
)
;
if
(
this
.
props
.
windowObj
.
scrollMaxX
>
0
)
{
dsLinkMenuHostDiv
.
classList
.
add
(
"
last
-
item
"
)
;
}
dsLinkMenuHostDiv
.
classList
.
add
(
"
active
"
)
;
}
}
onSeen
(
entries
)
{
if
(
this
.
state
)
{
const
entry
=
entries
.
find
(
e
=
>
e
.
isIntersecting
)
;
if
(
entry
)
{
if
(
this
.
placeholderElement
)
{
this
.
observer
.
unobserve
(
this
.
placeholderElement
)
;
}
this
.
setState
(
{
isSeen
:
true
}
)
;
}
}
}
onIdleCallback
(
)
{
if
(
!
this
.
state
.
isSeen
)
{
if
(
!
this
.
secureImage
)
{
if
(
this
.
observer
&
&
this
.
placeholderElement
)
{
this
.
observer
.
unobserve
(
this
.
placeholderElement
)
;
}
this
.
setState
(
{
isSeen
:
true
}
)
;
}
}
}
componentDidMount
(
)
{
this
.
idleCallbackId
=
this
.
props
.
windowObj
.
requestIdleCallback
(
this
.
onIdleCallback
.
bind
(
this
)
)
;
if
(
this
.
placeholderElement
)
{
this
.
observer
=
new
IntersectionObserver
(
this
.
onSeen
.
bind
(
this
)
)
;
this
.
observer
.
observe
(
this
.
placeholderElement
)
;
}
}
componentWillUnmount
(
)
{
if
(
this
.
observer
&
&
this
.
placeholderElement
)
{
this
.
observer
.
unobserve
(
this
.
placeholderElement
)
;
}
if
(
this
.
idleCallbackId
)
{
this
.
props
.
windowObj
.
cancelIdleCallback
(
this
.
idleCallbackId
)
;
}
}
secureImageURL
(
url
)
{
return
moz
-
cached
-
ohttp
:
/
/
newtab
-
image
/
?
url
=
{
encodeURIComponent
(
url
)
}
;
}
getRawImageSrc
(
)
{
let
rawImageSrc
=
"
"
;
if
(
!
this
.
props
.
App
.
isForStartupCache
.
App
)
{
rawImageSrc
=
this
.
props
.
raw_image_src
;
}
return
rawImageSrc
;
}
getFaviconSrc
(
)
{
let
faviconSrc
=
"
"
;
const
faviconEnabled
=
this
.
props
.
Prefs
.
values
[
PREF_FAVICONS_ENABLED
]
;
if
(
!
this
.
props
.
App
.
isForStartupCache
.
App
&
&
faviconEnabled
&
&
this
.
props
.
icon_src
)
{
faviconSrc
=
this
.
props
.
icon_src
;
if
(
this
.
secureImage
)
{
faviconSrc
=
this
.
secureImageURL
(
this
.
props
.
icon_src
)
;
}
}
return
faviconSrc
;
}
get
secureImage
(
)
{
const
{
Prefs
flightId
}
=
this
.
props
;
let
ohttpEnabled
=
false
;
if
(
flightId
)
{
ohttpEnabled
=
Prefs
.
values
[
PREF_CONTEXTUAL_ADS
]
&
&
Prefs
.
values
[
PREF_OHTTP_UNIFIED_ADS
]
;
}
else
{
ohttpEnabled
=
Prefs
.
values
[
PREF_OHTTP_MERINO
]
;
}
const
inferredPersonalizationUser
=
Prefs
.
values
[
PREF_INFERRED_PERSONALIZATION_USER
]
;
const
inferredPersonalizationSystem
=
Prefs
.
values
[
PREF_INFERRED_PERSONALIZATION_SYSTEM
]
;
const
inferredPersonalization
=
inferredPersonalizationSystem
&
&
inferredPersonalizationUser
;
const
ohttpImagesEnabled
=
Prefs
.
values
.
ohttpImagesConfig
?
.
enabled
;
const
includeTopStoriesSection
=
Prefs
.
values
.
ohttpImagesConfig
?
.
includeTopStoriesSection
;
const
sectionsEnabled
=
Prefs
.
values
[
DSCard_PREF_SECTIONS_ENABLED
]
;
const
nonPersonalizedSections
=
[
"
top_stories_section
"
]
;
const
sectionPersonalized
=
!
nonPersonalizedSections
.
includes
(
this
.
props
.
section
)
|
|
includeTopStoriesSection
;
const
secureImage
=
sectionsEnabled
&
&
ohttpImagesEnabled
&
&
ohttpEnabled
&
&
sectionPersonalized
&
&
inferredPersonalization
;
return
secureImage
;
}
render
(
)
{
const
{
isRecentSave
DiscoveryStream
Prefs
isListCard
isFakespot
mayHaveSectionsCards
format
alt_text
}
=
this
.
props
;
const
refinedCardsLayout
=
Prefs
.
values
[
"
discoverystream
.
refinedCardsLayout
.
enabled
"
]
;
const
refinedCardsClassName
=
refinedCardsLayout
?
refined
-
cards
:
;
if
(
this
.
props
.
placeholder
|
|
!
this
.
state
.
isSeen
)
{
const
placeholderClassName
=
this
.
state
.
isSeen
?
placeholder
-
seen
:
;
let
placeholderElements
=
external_React_default
(
)
.
createElement
(
(
external_React_default
(
)
)
.
Fragment
null
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
placeholder
-
image
placeholder
-
fill
"
}
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
placeholder
-
label
placeholder
-
fill
"
}
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
placeholder
-
header
placeholder
-
fill
"
}
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
placeholder
-
description
placeholder
-
fill
"
}
)
)
;
if
(
refinedCardsLayout
)
{
placeholderElements
=
external_React_default
(
)
.
createElement
(
(
external_React_default
(
)
)
.
Fragment
null
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
placeholder
-
image
placeholder
-
fill
"
}
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
placeholder
-
description
placeholder
-
fill
"
}
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
placeholder
-
header
placeholder
-
fill
"
}
)
)
;
}
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
ds
-
card
placeholder
{
placeholderClassName
}
{
isListCard
?
"
list
-
card
-
placeholder
"
:
"
"
}
{
refinedCardsClassName
}
ref
:
this
.
setPlaceholderRef
}
placeholderElements
)
;
}
let
source
=
this
.
props
.
source
|
|
this
.
props
.
publisher
;
if
(
!
source
)
{
try
{
source
=
new
URL
(
this
.
props
.
url
)
.
hostname
;
}
catch
(
e
)
{
}
}
const
{
hideDescriptions
compactImages
imageGradient
newSponsoredLabel
titleLines
=
3
descLines
=
3
readTime
:
displayReadTime
}
=
DiscoveryStream
;
const
sectionsEnabled
=
Prefs
.
values
[
DSCard_PREF_SECTIONS_ENABLED
]
;
const
smartCrop
=
Prefs
.
values
[
"
images
.
smart
"
]
;
const
excerpt
=
!
hideDescriptions
|
|
sectionsEnabled
&
&
refinedCardsLayout
?
this
.
props
.
excerpt
:
"
"
;
let
timeToRead
;
if
(
displayReadTime
)
{
timeToRead
=
this
.
props
.
time_to_read
|
|
readTimeFromWordCount
(
this
.
props
.
word_count
)
;
}
const
ctaButtonEnabled
=
this
.
props
.
ctaButtonSponsors
?
.
includes
(
this
.
props
.
sponsor
?
.
toLowerCase
(
)
)
;
let
ctaButtonVariant
=
"
"
;
if
(
ctaButtonEnabled
)
{
ctaButtonVariant
=
this
.
props
.
ctaButtonVariant
;
}
let
ctaButtonVariantClassName
=
ctaButtonVariant
;
const
ctaButtonClassName
=
ctaButtonEnabled
?
ds
-
card
-
cta
-
button
:
;
const
compactImagesClassName
=
compactImages
?
ds
-
card
-
compact
-
image
:
;
const
imageGradientClassName
=
imageGradient
?
ds
-
card
-
image
-
gradient
:
;
const
listCardClassName
=
isListCard
?
list
-
feed
-
card
:
;
const
fakespotClassName
=
isFakespot
?
fakespot
:
;
const
sectionsCardsClassName
=
[
mayHaveSectionsCards
?
sections
-
card
-
ui
:
this
.
props
.
sectionsClassNames
]
.
join
(
"
"
)
;
const
sectionsCardsImageSizes
=
this
.
props
.
sectionsCardImageSizes
;
const
titleLinesName
=
ds
-
card
-
title
-
lines
-
{
titleLines
}
;
const
descLinesClassName
=
ds
-
card
-
desc
-
lines
-
{
descLines
}
;
const
isMediumRectangle
=
format
=
=
=
"
rectangle
"
;
const
spocFormatClassName
=
isMediumRectangle
?
ds
-
spoc
-
rectangle
:
;
const
rawImageSrc
=
this
.
getRawImageSrc
(
)
;
const
faviconSrc
=
this
.
getFaviconSrc
(
)
;
let
sizes
=
[
]
;
if
(
!
isMediumRectangle
)
{
sizes
=
this
.
dsImageSizes
;
if
(
sectionsEnabled
)
{
sizes
=
[
this
.
getSectionImageSize
(
"
4
"
sectionsCardsImageSizes
[
"
4
"
]
)
this
.
getSectionImageSize
(
"
3
"
sectionsCardsImageSizes
[
"
3
"
]
)
this
.
getSectionImageSize
(
"
2
"
sectionsCardsImageSizes
[
"
2
"
]
)
this
.
getSectionImageSize
(
"
1
"
sectionsCardsImageSizes
[
"
1
"
]
)
]
;
}
else
{
sizes
=
this
.
standardCardImageSizes
;
}
if
(
isListCard
)
{
sizes
=
this
.
listCardImageSizes
;
}
}
return
external_React_default
(
)
.
createElement
(
"
article
"
{
className
:
ds
-
card
{
listCardClassName
}
{
fakespotClassName
}
{
sectionsCardsClassName
}
{
compactImagesClassName
}
{
imageGradientClassName
}
{
titleLinesName
}
{
descLinesClassName
}
{
spocFormatClassName
}
{
ctaButtonClassName
}
{
ctaButtonVariantClassName
}
{
refinedCardsClassName
}
ref
:
this
.
setContextMenuButtonHostRef
"
data
-
position
-
one
"
:
this
.
props
[
"
data
-
position
-
one
"
]
"
data
-
position
-
two
"
:
this
.
props
[
"
data
-
position
-
one
"
]
"
data
-
position
-
three
"
:
this
.
props
[
"
data
-
position
-
one
"
]
"
data
-
position
-
four
"
:
this
.
props
[
"
data
-
position
-
one
"
]
}
external_React_default
(
)
.
createElement
(
SafeAnchor
{
className
:
"
ds
-
card
-
link
"
dispatch
:
this
.
props
.
dispatch
onLinkClick
:
!
this
.
props
.
placeholder
?
this
.
onLinkClick
:
undefined
url
:
this
.
props
.
url
title
:
this
.
props
.
title
}
this
.
props
.
showTopics
&
&
!
this
.
props
.
mayHaveSectionsCards
&
&
this
.
props
.
topic
&
&
!
isListCard
&
&
!
refinedCardsLayout
&
&
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
ds
-
card
-
topic
"
"
data
-
l10n
-
id
"
:
newtab
-
topic
-
label
-
{
this
.
props
.
topic
}
}
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
img
-
wrapper
"
}
external_React_default
(
)
.
createElement
(
DSImage
{
extraClassNames
:
"
img
"
source
:
this
.
props
.
image_src
rawSource
:
rawImageSrc
sizes
:
sizes
url
:
this
.
props
.
url
title
:
this
.
props
.
title
isRecentSave
:
isRecentSave
alt_text
:
alt_text
smartCrop
:
smartCrop
secureImage
:
this
.
secureImage
}
)
)
external_React_default
(
)
.
createElement
(
ImpressionStats_ImpressionStats
{
flightId
:
this
.
props
.
flightId
rows
:
[
{
id
:
this
.
props
.
id
pos
:
this
.
props
.
pos
.
.
.
(
this
.
props
.
shim
&
&
this
.
props
.
shim
.
impression
?
{
shim
:
this
.
props
.
shim
.
impression
}
:
{
}
)
recommendation_id
:
this
.
props
.
recommendation_id
fetchTimestamp
:
this
.
props
.
fetchTimestamp
corpus_item_id
:
this
.
props
.
corpus_item_id
scheduled_corpus_item_id
:
this
.
props
.
scheduled_corpus_item_id
recommended_at
:
this
.
props
.
recommended_at
received_rank
:
this
.
props
.
received_rank
topic
:
this
.
props
.
topic
features
:
this
.
props
.
features
is_list_card
:
isListCard
.
.
.
(
format
?
{
format
}
:
{
}
)
isFakespot
category
:
this
.
props
.
category
.
.
.
(
this
.
props
.
section
?
{
section
:
this
.
props
.
section
section_position
:
this
.
props
.
sectionPosition
is_section_followed
:
this
.
props
.
sectionFollowed
}
:
{
}
)
.
.
.
(
!
format
&
&
this
.
props
.
section
?
{
class_names
:
sectionsCardsClassName
}
:
{
}
)
}
]
dispatch
:
this
.
props
.
dispatch
isFakespot
:
isFakespot
source
:
this
.
props
.
type
firstVisibleTimestamp
:
this
.
props
.
firstVisibleTimestamp
}
)
ctaButtonVariant
=
=
=
"
variant
-
b
"
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
cta
-
header
"
}
"
Shop
Now
"
)
isFakespot
?
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
meta
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
info
-
wrap
"
}
external_React_default
(
)
.
createElement
(
"
h3
"
{
className
:
"
title
clamp
"
}
this
.
props
.
title
)
)
)
:
external_React_default
(
)
.
createElement
(
DefaultMeta
{
source
:
source
title
:
this
.
props
.
title
excerpt
:
excerpt
newSponsoredLabel
:
newSponsoredLabel
timeToRead
:
timeToRead
context
:
this
.
props
.
context
context_type
:
this
.
props
.
context_type
sponsor
:
this
.
props
.
sponsor
sponsored_by_override
:
this
.
props
.
sponsored_by_override
ctaButtonVariant
:
ctaButtonVariant
dispatch
:
this
.
props
.
dispatch
spocMessageVariant
:
this
.
props
.
spocMessageVariant
mayHaveThumbsUpDown
:
this
.
props
.
mayHaveThumbsUpDown
mayHaveSectionsCards
:
this
.
props
.
mayHaveSectionsCards
onThumbsUpClick
:
this
.
onThumbsUpClick
onThumbsDownClick
:
this
.
onThumbsDownClick
state
:
this
.
state
isListCard
:
isListCard
showTopics
:
!
refinedCardsLayout
&
&
this
.
props
.
showTopics
isSectionsCard
:
this
.
props
.
mayHaveSectionsCards
&
&
this
.
props
.
topic
&
&
!
isListCard
format
:
format
topic
:
this
.
props
.
topic
icon_src
:
faviconSrc
refinedCardsLayout
:
refinedCardsLayout
}
)
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
card
-
stp
-
button
-
hover
-
background
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
card
-
stp
-
button
-
position
-
wrapper
"
}
!
isFakespot
&
&
external_React_default
(
)
.
createElement
(
DSLinkMenu
{
id
:
this
.
props
.
id
index
:
this
.
props
.
pos
dispatch
:
this
.
props
.
dispatch
url
:
this
.
props
.
url
title
:
this
.
props
.
title
source
:
source
type
:
this
.
props
.
type
card_type
:
this
.
props
.
flightId
?
"
spoc
"
:
"
organic
"
pocket_id
:
this
.
props
.
pocket_id
shim
:
this
.
props
.
shim
bookmarkGuid
:
this
.
props
.
bookmarkGuid
flightId
:
!
this
.
props
.
is_collection
?
this
.
props
.
flightId
:
undefined
showPrivacyInfo
:
!
!
this
.
props
.
flightId
onMenuUpdate
:
this
.
onMenuUpdate
onMenuShow
:
this
.
onMenuShow
isRecentSave
:
isRecentSave
recommendation_id
:
this
.
props
.
recommendation_id
tile_id
:
this
.
props
.
id
block_key
:
this
.
props
.
id
corpus_item_id
:
this
.
props
.
corpus_item_id
scheduled_corpus_item_id
:
this
.
props
.
scheduled_corpus_item_id
recommended_at
:
this
.
props
.
recommended_at
received_rank
:
this
.
props
.
received_rank
is_list_card
:
this
.
props
.
isListCard
section
:
this
.
props
.
section
section_position
:
this
.
props
.
sectionPosition
is_section_followed
:
this
.
props
.
sectionFollowed
fetchTimestamp
:
this
.
props
.
fetchTimestamp
firstVisibleTimestamp
:
this
.
props
.
firstVisibleTimestamp
format
:
format
?
format
:
getActiveCardSize
(
window
.
innerWidth
this
.
props
.
sectionsClassNames
this
.
props
.
section
this
.
props
.
flightId
)
isSectionsCard
:
this
.
props
.
mayHaveSectionsCards
topic
:
this
.
props
.
topic
selected_topics
:
this
.
props
.
selected_topics
}
)
)
)
)
;
}
}
_DSCard
.
defaultProps
=
{
windowObj
:
window
}
;
const
DSCard
=
(
0
external_ReactRedux_namespaceObject
.
connect
)
(
state
=
>
(
{
App
:
state
.
App
DiscoveryStream
:
state
.
DiscoveryStream
Prefs
:
state
.
Prefs
}
)
)
(
_DSCard
)
;
const
PlaceholderDSCard
=
(
)
=
>
external_React_default
(
)
.
createElement
(
DSCard
{
placeholder
:
true
}
)
;
;
class
DSEmptyState
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
onReset
=
this
.
onReset
.
bind
(
this
)
;
this
.
state
=
{
}
;
}
componentWillUnmount
(
)
{
if
(
this
.
timeout
)
{
clearTimeout
(
this
.
timeout
)
;
}
}
onReset
(
)
{
if
(
this
.
props
.
dispatch
&
&
this
.
props
.
feed
)
{
const
{
feed
}
=
this
.
props
;
const
{
url
}
=
feed
;
this
.
props
.
dispatch
(
{
type
:
actionTypes
.
DISCOVERY_STREAM_FEED_UPDATE
data
:
{
feed
:
{
.
.
.
feed
data
:
{
.
.
.
feed
.
data
status
:
"
waiting
"
}
}
url
}
}
)
;
this
.
setState
(
{
waiting
:
true
}
)
;
this
.
timeout
=
setTimeout
(
(
)
=
>
{
this
.
timeout
=
null
;
this
.
setState
(
{
waiting
:
false
}
)
;
}
300
)
;
this
.
props
.
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
DISCOVERY_STREAM_RETRY_FEED
data
:
{
feed
}
}
)
)
;
}
}
renderButton
(
)
{
if
(
this
.
props
.
status
=
=
=
"
waiting
"
|
|
this
.
state
.
waiting
)
{
return
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
"
try
-
again
-
button
waiting
"
"
data
-
l10n
-
id
"
:
"
newtab
-
discovery
-
empty
-
section
-
topstories
-
loading
"
}
)
;
}
return
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
"
try
-
again
-
button
"
onClick
:
this
.
onReset
"
data
-
l10n
-
id
"
:
"
newtab
-
discovery
-
empty
-
section
-
topstories
-
try
-
again
-
button
"
}
)
;
}
renderState
(
)
{
if
(
this
.
props
.
status
=
=
=
"
waiting
"
|
|
this
.
props
.
status
=
=
=
"
failed
"
)
{
return
external_React_default
(
)
.
createElement
(
(
external_React_default
(
)
)
.
Fragment
null
external_React_default
(
)
.
createElement
(
"
h2
"
{
"
data
-
l10n
-
id
"
:
"
newtab
-
discovery
-
empty
-
section
-
topstories
-
timed
-
out
"
}
)
this
.
renderButton
(
)
)
;
}
return
external_React_default
(
)
.
createElement
(
(
external_React_default
(
)
)
.
Fragment
null
external_React_default
(
)
.
createElement
(
"
h2
"
{
"
data
-
l10n
-
id
"
:
"
newtab
-
discovery
-
empty
-
section
-
topstories
-
header
"
}
)
external_React_default
(
)
.
createElement
(
"
p
"
{
"
data
-
l10n
-
id
"
:
"
newtab
-
discovery
-
empty
-
section
-
topstories
-
content
"
}
)
)
;
}
render
(
)
{
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
section
-
empty
-
state
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
empty
-
state
-
message
"
}
this
.
renderState
(
)
)
)
;
}
}
;
class
DSDismiss
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
onDismissClick
=
this
.
onDismissClick
.
bind
(
this
)
;
this
.
onHover
=
this
.
onHover
.
bind
(
this
)
;
this
.
offHover
=
this
.
offHover
.
bind
(
this
)
;
this
.
state
=
{
hovering
:
false
}
;
}
onDismissClick
(
)
{
if
(
this
.
props
.
onDismissClick
)
{
this
.
props
.
onDismissClick
(
)
;
}
}
onHover
(
)
{
this
.
setState
(
{
hovering
:
true
}
)
;
}
offHover
(
)
{
this
.
setState
(
{
hovering
:
false
}
)
;
}
render
(
)
{
let
className
=
ds
-
dismiss
{
this
.
state
.
hovering
?
hovering
:
}
{
this
.
props
.
extraClasses
?
{
this
.
props
.
extraClasses
}
:
}
;
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
className
}
this
.
props
.
children
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
"
ds
-
dismiss
-
button
"
"
data
-
l10n
-
id
"
:
"
newtab
-
dismiss
-
button
-
tooltip
"
onClick
:
this
.
onDismissClick
onMouseEnter
:
this
.
onHover
onMouseLeave
:
this
.
offHover
}
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
icon
icon
-
dismiss
"
}
)
)
)
;
}
}
;
function
_TopicsWidget
(
props
)
{
const
{
id
source
position
DiscoveryStream
dispatch
}
=
props
;
const
{
utmCampaign
utmContent
utmSource
}
=
DiscoveryStream
.
experimentData
;
let
queryParams
=
?
utm_source
=
{
utmSource
}
;
if
(
utmCampaign
&
&
utmContent
)
{
queryParams
+
=
&
utm_content
=
{
utmContent
}
&
utm_campaign
=
{
utmCampaign
}
;
}
const
topics
=
[
{
label
:
"
Technology
"
name
:
"
technology
"
}
{
label
:
"
Science
"
name
:
"
science
"
}
{
label
:
"
Self
-
Improvement
"
name
:
"
self
-
improvement
"
}
{
label
:
"
Travel
"
name
:
"
travel
"
}
{
label
:
"
Career
"
name
:
"
career
"
}
{
label
:
"
Entertainment
"
name
:
"
entertainment
"
}
{
label
:
"
Food
"
name
:
"
food
"
}
{
label
:
"
Health
"
name
:
"
health
"
}
{
label
:
"
Must
-
Reads
"
name
:
"
must
-
reads
"
url
:
https
:
/
/
getpocket
.
com
/
collections
{
queryParams
}
}
]
;
function
onLinkClick
(
topic
positionInCard
)
{
if
(
dispatch
)
{
dispatch
(
actionCreators
.
DiscoveryStreamUserEvent
(
{
event
:
"
CLICK
"
source
action_position
:
position
value
:
{
card_type
:
"
topics_widget
"
topic
.
.
.
(
positionInCard
|
|
positionInCard
=
=
=
0
?
{
position_in_card
:
positionInCard
}
:
{
}
)
section_position
:
position
}
}
)
)
;
dispatch
(
actionCreators
.
ImpressionStats
(
{
source
click
:
0
window_inner_width
:
props
.
windowObj
.
innerWidth
window_inner_height
:
props
.
windowObj
.
innerHeight
tiles
:
[
{
id
pos
:
position
}
]
}
)
)
;
}
}
function
mapTopicItem
(
topic
index
)
{
return
external_React_default
(
)
.
createElement
(
"
li
"
{
key
:
topic
.
name
className
:
topic
.
overflow
?
"
ds
-
topics
-
widget
-
list
-
overflow
-
item
"
:
"
"
}
external_React_default
(
)
.
createElement
(
SafeAnchor
{
url
:
topic
.
url
|
|
https
:
/
/
getpocket
.
com
/
explore
/
{
topic
.
name
}
{
queryParams
}
dispatch
:
dispatch
onLinkClick
:
(
)
=
>
onLinkClick
(
topic
.
name
index
)
}
topic
.
label
)
)
;
}
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
ds
-
topics
-
widget
"
}
external_React_default
(
)
.
createElement
(
"
header
"
{
className
:
"
ds
-
topics
-
widget
-
header
"
}
"
Popular
Topics
"
)
external_React_default
(
)
.
createElement
(
"
hr
"
null
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
ds
-
topics
-
widget
-
list
-
container
"
}
external_React_default
(
)
.
createElement
(
"
ul
"
null
topics
.
map
(
mapTopicItem
)
)
)
external_React_default
(
)
.
createElement
(
SafeAnchor
{
className
:
"
ds
-
topics
-
widget
-
button
button
primary
"
url
:
https
:
/
/
getpocket
.
com
/
{
queryParams
}
dispatch
:
dispatch
onLinkClick
:
(
)
=
>
onLinkClick
(
"
more
-
topics
"
)
}
"
More
Topics
"
)
external_React_default
(
)
.
createElement
(
ImpressionStats_ImpressionStats
{
dispatch
:
dispatch
rows
:
[
{
id
pos
:
position
}
]
source
:
source
}
)
)
;
}
_TopicsWidget
.
defaultProps
=
{
windowObj
:
window
}
;
const
TopicsWidget
=
(
0
external_ReactRedux_namespaceObject
.
connect
)
(
state
=
>
(
{
DiscoveryStream
:
state
.
DiscoveryStream
}
)
)
(
_TopicsWidget
)
;
;
const
PREF_LISTFEED_TITLE
=
"
discoverystream
.
contextualContent
.
listFeedTitle
"
;
const
PREF_FAKESPOT_CATEGROY
=
"
discoverystream
.
contextualContent
.
fakespot
.
defaultCategoryTitle
"
;
const
PREF_FAKESPOT_FOOTER
=
"
discoverystream
.
contextualContent
.
fakespot
.
footerCopy
"
;
const
PREF_FAKESPOT_CTA_COPY
=
"
discoverystream
.
contextualContent
.
fakespot
.
ctaCopy
"
;
const
PREF_FAKESPOT_CTA_URL
=
"
discoverystream
.
contextualContent
.
fakespot
.
ctaUrl
"
;
const
ListFeed_PREF_CONTEXTUAL_CONTENT_SELECTED_FEED
=
"
discoverystream
.
contextualContent
.
selectedFeed
"
;
function
ListFeed
(
{
type
firstVisibleTimestamp
recs
categories
dispatch
}
)
{
const
[
selectedFakespotFeed
setSelectedFakespotFeed
]
=
(
0
external_React_namespaceObject
.
useState
)
(
"
"
)
;
const
prefs
=
(
0
external_ReactRedux_namespaceObject
.
useSelector
)
(
state
=
>
state
.
Prefs
.
values
)
;
const
listFeedTitle
=
prefs
[
PREF_LISTFEED_TITLE
]
;
const
categoryTitle
=
prefs
[
PREF_FAKESPOT_CATEGROY
]
;
const
footerCopy
=
prefs
[
PREF_FAKESPOT_FOOTER
]
;
const
ctaCopy
=
prefs
[
PREF_FAKESPOT_CTA_COPY
]
;
const
ctaUrl
=
prefs
[
PREF_FAKESPOT_CTA_URL
]
;
const
isFakespot
=
prefs
[
ListFeed_PREF_CONTEXTUAL_CONTENT_SELECTED_FEED
]
=
=
=
"
fakespot
"
;
let
listFeedRecs
=
selectedFakespotFeed
?
recs
.
filter
(
rec
=
>
rec
.
category
=
=
=
selectedFakespotFeed
)
:
recs
;
function
handleCtaClick
(
)
{
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
"
FAKESPOT_CTA_CLICK
"
}
)
)
;
}
function
handleChange
(
e
)
{
setSelectedFakespotFeed
(
e
.
target
.
value
)
;
dispatch
(
actionCreators
.
DiscoveryStreamUserEvent
(
{
event
:
"
FAKESPOT_CATEGORY
"
value
:
{
category
:
e
.
target
.
value
|
|
"
"
}
}
)
)
;
}
const
contextMenuOptions
=
[
"
FakespotDismiss
"
"
AboutFakespot
"
]
;
const
{
length
:
listLength
}
=
listFeedRecs
;
const
fullList
=
listLength
>
=
5
;
return
listLength
>
0
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
list
-
feed
{
fullList
?
"
full
-
height
"
:
"
"
}
{
listLength
>
2
?
"
span
-
2
"
:
"
span
-
1
"
}
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
list
-
feed
-
inner
-
wrapper
"
}
isFakespot
?
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
fakespot
-
heading
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
dropdown
-
wrapper
"
}
external_React_default
(
)
.
createElement
(
"
select
"
{
className
:
"
fakespot
-
dropdown
"
name
:
"
fakespot
-
categories
"
value
:
selectedFakespotFeed
onChange
:
handleChange
}
external_React_default
(
)
.
createElement
(
"
option
"
{
value
:
"
"
}
categoryTitle
|
|
"
Holiday
Gift
Guide
"
)
categories
.
map
(
category
=
>
external_React_default
(
)
.
createElement
(
"
option
"
{
key
:
category
value
:
category
}
category
)
)
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
context
-
menu
-
wrapper
"
}
external_React_default
(
)
.
createElement
(
ContextMenuButton
null
external_React_default
(
)
.
createElement
(
LinkMenu
{
dispatch
:
dispatch
options
:
contextMenuOptions
shouldSendImpressionStats
:
true
site
:
{
url
:
"
https
:
/
/
www
.
fakespot
.
com
"
}
}
)
)
)
)
external_React_default
(
)
.
createElement
(
"
p
"
{
className
:
"
fakespot
-
desc
"
}
listFeedTitle
)
)
:
external_React_default
(
)
.
createElement
(
"
h1
"
{
className
:
"
list
-
feed
-
title
"
id
:
"
list
-
feed
-
title
"
}
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
icon
icon
-
newsfeed
"
}
)
listFeedTitle
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
list
-
feed
-
content
"
role
:
"
menu
"
"
aria
-
labelledby
"
:
"
list
-
feed
-
title
"
}
listFeedRecs
.
slice
(
0
5
)
.
map
(
(
rec
index
)
=
>
{
if
(
!
rec
|
|
rec
.
placeholder
)
{
return
external_React_default
(
)
.
createElement
(
DSCard
{
key
:
list
-
card
-
{
index
}
placeholder
:
true
isListCard
:
true
}
)
;
}
return
external_React_default
(
)
.
createElement
(
DSCard
{
key
:
list
-
card
-
{
index
}
pos
:
index
flightId
:
rec
.
flight_id
image_src
:
rec
.
image_src
raw_image_src
:
rec
.
raw_image_src
word_count
:
rec
.
word_count
time_to_read
:
rec
.
time_to_read
title
:
rec
.
title
topic
:
rec
.
topic
excerpt
:
rec
.
excerpt
url
:
rec
.
url
id
:
rec
.
id
shim
:
rec
.
shim
type
:
type
context
:
rec
.
context
sponsor
:
rec
.
sponsor
sponsored_by_override
:
rec
.
sponsored_by_override
dispatch
:
dispatch
source
:
rec
.
domain
publisher
:
rec
.
publisher
pocket_id
:
rec
.
pocket_id
context_type
:
rec
.
context_type
bookmarkGuid
:
rec
.
bookmarkGuid
firstVisibleTimestamp
:
firstVisibleTimestamp
corpus_item_id
:
rec
.
corpus_item_id
scheduled_corpus_item_id
:
rec
.
scheduled_corpus_item_id
recommended_at
:
rec
.
recommended_at
received_rank
:
rec
.
received_rank
isListCard
:
true
isFakespot
:
isFakespot
category
:
rec
.
category
}
)
;
}
)
isFakespot
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
fakespot
-
footer
"
}
external_React_default
(
)
.
createElement
(
"
p
"
null
footerCopy
)
external_React_default
(
)
.
createElement
(
SafeAnchor
{
className
:
"
fakespot
-
cta
"
url
:
ctaUrl
referrer
:
"
"
onLinkClick
:
handleCtaClick
dispatch
:
dispatch
}
ctaCopy
)
)
)
)
)
;
}
;
function
AdBannerContextMenu
(
{
dispatch
spoc
position
type
showAdReporting
toggleActive
=
(
)
=
>
{
}
}
)
{
const
ADBANNER_CONTEXT_MENU_OPTIONS
=
[
"
BlockAdUrl
"
.
.
.
(
showAdReporting
?
[
"
ReportAd
"
]
:
[
]
)
"
ManageSponsoredContent
"
"
OurSponsorsAndYourPrivacy
"
]
;
const
[
showContextMenu
setShowContextMenu
]
=
(
0
external_React_namespaceObject
.
useState
)
(
false
)
;
const
[
contextMenuClassNames
setContextMenuClassNames
]
=
(
0
external_React_namespaceObject
.
useState
)
(
"
ads
-
context
-
menu
"
)
;
const
[
isKeyboardAccess
setIsKeyboardAccess
]
=
(
0
external_React_namespaceObject
.
useState
)
(
false
)
;
const
toggleContextMenuStyleSwitch
=
contextMenuOpen
=
>
{
if
(
contextMenuOpen
)
{
setContextMenuClassNames
(
"
ads
-
context
-
menu
context
-
menu
-
open
"
)
;
}
else
{
setContextMenuClassNames
(
"
ads
-
context
-
menu
"
)
;
}
}
;
const
toggleContextMenu
=
isKeyBoard
=
>
{
toggleContextMenuStyleSwitch
(
!
showContextMenu
)
;
toggleActive
(
!
showContextMenu
)
;
setShowContextMenu
(
!
showContextMenu
)
;
setIsKeyboardAccess
(
isKeyBoard
)
;
}
;
const
onClick
=
e
=
>
{
e
.
preventDefault
(
)
;
toggleContextMenu
(
false
)
;
}
;
const
onKeyDown
=
e
=
>
{
if
(
e
.
key
=
=
=
"
Enter
"
|
|
e
.
key
=
=
=
"
"
)
{
e
.
preventDefault
(
)
;
toggleContextMenu
(
true
)
;
}
}
;
const
onUpdate
=
(
)
=
>
{
toggleContextMenuStyleSwitch
(
!
showContextMenu
)
;
toggleActive
(
!
showContextMenu
)
;
setShowContextMenu
(
!
showContextMenu
)
;
}
;
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
ads
-
context
-
menu
-
wrapper
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
contextMenuClassNames
}
external_React_default
(
)
.
createElement
(
"
moz
-
button
"
{
type
:
"
icon
"
size
:
"
default
"
"
data
-
l10n
-
id
"
:
"
newtab
-
menu
-
content
-
tooltip
"
"
data
-
l10n
-
args
"
:
JSON
.
stringify
(
{
title
:
spoc
.
title
|
|
spoc
.
sponsor
|
|
spoc
.
alt_text
}
)
iconsrc
:
"
chrome
:
/
/
global
/
skin
/
icons
/
more
.
svg
"
onClick
:
onClick
onKeyDown
:
onKeyDown
}
)
showContextMenu
&
&
external_React_default
(
)
.
createElement
(
LinkMenu
{
onUpdate
:
onUpdate
dispatch
:
dispatch
keyboardAccess
:
isKeyboardAccess
options
:
ADBANNER_CONTEXT_MENU_OPTIONS
shouldSendImpressionStats
:
true
userEvent
:
actionCreators
.
DiscoveryStreamUserEvent
site
:
{
block_key
:
spoc
.
block_key
fetchTimestamp
:
spoc
.
fetchTimestamp
flight_id
:
spoc
.
flight_id
format
:
spoc
.
format
id
:
spoc
.
id
guid
:
spoc
.
guid
card_type
:
"
spoc
"
is_pocket_card
:
true
position
sponsor
:
spoc
.
sponsor
title
:
spoc
.
title
url
:
spoc
.
url
|
|
spoc
.
shim
.
url
personalization_models
:
spoc
.
personalization_models
priority
:
spoc
.
priority
score
:
spoc
.
score
alt_text
:
spoc
.
alt_text
shim
:
spoc
.
shim
}
index
:
position
source
:
type
.
toUpperCase
(
)
}
)
)
)
;
}
;
const
AdBanner_PREF_SECTIONS_ENABLED
=
"
discoverystream
.
sections
.
enabled
"
;
const
AdBanner_PREF_OHTTP_UNIFIED_ADS
=
"
unifiedAds
.
ohttp
.
enabled
"
;
const
AdBanner_PREF_CONTEXTUAL_ADS
=
"
discoverystream
.
sections
.
contextualAds
.
enabled
"
;
const
PREF_USER_INFERRED_PERSONALIZATION
=
"
discoverystream
.
sections
.
personalization
.
inferred
.
user
.
enabled
"
;
const
PREF_SYSTEM_INFERRED_PERSONALIZATION
=
"
discoverystream
.
sections
.
personalization
.
inferred
.
enabled
"
;
const
PREF_REPORT_ADS_ENABLED
=
"
discoverystream
.
reportAds
.
enabled
"
;
const
AdBanner
=
(
{
spoc
dispatch
firstVisibleTimestamp
row
type
prefs
}
)
=
>
{
const
getDimensions
=
format
=
>
{
switch
(
format
)
{
case
"
leaderboard
"
:
return
{
width
:
"
728
"
height
:
"
90
"
}
;
case
"
billboard
"
:
return
{
width
:
"
970
"
height
:
"
250
"
}
;
}
return
{
width
:
undefined
height
:
undefined
}
;
}
;
const
sectionsEnabled
=
prefs
[
AdBanner_PREF_SECTIONS_ENABLED
]
;
const
ohttpEnabled
=
prefs
[
AdBanner_PREF_OHTTP_UNIFIED_ADS
]
;
const
contextualAds
=
prefs
[
AdBanner_PREF_CONTEXTUAL_ADS
]
;
const
inferredPersonalization
=
prefs
[
PREF_USER_INFERRED_PERSONALIZATION
]
&
&
prefs
[
PREF_SYSTEM_INFERRED_PERSONALIZATION
]
;
const
showAdReporting
=
prefs
[
PREF_REPORT_ADS_ENABLED
]
;
const
ohttpImagesEnabled
=
prefs
.
ohttpImagesConfig
?
.
enabled
;
const
[
menuActive
setMenuActive
]
=
(
0
external_React_namespaceObject
.
useState
)
(
false
)
;
const
adBannerWrapperClassName
=
ad
-
banner
-
wrapper
{
menuActive
?
"
active
"
:
"
"
}
;
const
{
width
:
imgWidth
height
:
imgHeight
}
=
getDimensions
(
spoc
.
format
)
;
const
onLinkClick
=
(
)
=
>
{
dispatch
(
actionCreators
.
DiscoveryStreamUserEvent
(
{
event
:
"
CLICK
"
source
:
type
.
toUpperCase
(
)
action_position
:
parseInt
(
row
10
)
value
:
{
card_type
:
"
spoc
"
tile_id
:
spoc
.
id
.
.
.
(
spoc
.
shim
?
.
click
?
{
shim
:
spoc
.
shim
.
click
}
:
{
}
)
fetchTimestamp
:
spoc
.
fetchTimestamp
firstVisibleTimestamp
format
:
spoc
.
format
.
.
.
(
sectionsEnabled
?
{
section
:
spoc
.
format
section_position
:
parseInt
(
row
10
)
}
:
{
}
)
}
}
)
)
;
}
;
const
toggleActive
=
active
=
>
{
setMenuActive
(
active
)
;
}
;
const
clampedRow
=
Math
.
max
(
1
Math
.
min
(
9
row
)
)
;
const
secureImage
=
ohttpImagesEnabled
&
&
ohttpEnabled
&
&
contextualAds
&
&
inferredPersonalization
&
&
sectionsEnabled
;
let
rawImageSrc
=
spoc
.
raw_image_src
;
if
(
secureImage
)
{
rawImageSrc
=
moz
-
cached
-
ohttp
:
/
/
newtab
-
image
/
?
url
=
{
encodeURIComponent
(
spoc
.
raw_image_src
)
}
;
}
return
external_React_default
(
)
.
createElement
(
"
aside
"
{
className
:
adBannerWrapperClassName
style
:
{
gridRow
:
clampedRow
}
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
ad
-
banner
-
inner
{
spoc
.
format
}
}
external_React_default
(
)
.
createElement
(
SafeAnchor
{
className
:
"
ad
-
banner
-
link
"
url
:
spoc
.
url
title
:
spoc
.
title
|
|
spoc
.
sponsor
|
|
spoc
.
alt_text
onLinkClick
:
onLinkClick
dispatch
:
dispatch
}
external_React_default
(
)
.
createElement
(
ImpressionStats_ImpressionStats
{
flightId
:
spoc
.
flight_id
rows
:
[
{
id
:
spoc
.
id
card_type
:
"
spoc
"
pos
:
row
recommended_at
:
spoc
.
recommended_at
received_rank
:
spoc
.
received_rank
format
:
spoc
.
format
.
.
.
(
spoc
.
shim
?
.
impression
?
{
shim
:
spoc
.
shim
.
impression
}
:
{
}
)
}
]
dispatch
:
dispatch
firstVisibleTimestamp
:
firstVisibleTimestamp
}
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
ad
-
banner
-
content
"
}
external_React_default
(
)
.
createElement
(
"
img
"
{
src
:
rawImageSrc
alt
:
spoc
.
alt_text
loading
:
"
eager
"
width
:
imgWidth
height
:
imgHeight
}
)
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
ad
-
banner
-
sponsored
"
}
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
ad
-
banner
-
sponsored
-
label
"
"
data
-
l10n
-
id
"
:
"
newtab
-
label
-
sponsored
-
fixed
"
}
)
)
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
ad
-
banner
-
hover
-
background
"
}
external_React_default
(
)
.
createElement
(
AdBannerContextMenu
{
dispatch
:
dispatch
spoc
:
spoc
position
:
row
type
:
type
showAdReporting
:
showAdReporting
toggleActive
:
toggleActive
}
)
)
)
)
;
}
;
;
const
PREF_PROMO_CARD_DISMISSED
=
"
discoverystream
.
promoCard
.
visible
"
;
const
PromoCard
=
(
)
=
>
{
const
dispatch
=
(
0
external_ReactRedux_namespaceObject
.
useDispatch
)
(
)
;
const
onDismissClick
=
(
0
external_React_namespaceObject
.
useCallback
)
(
(
)
=
>
{
dispatch
(
actionCreators
.
SetPref
(
PREF_PROMO_CARD_DISMISSED
false
)
)
;
}
[
dispatch
]
)
;
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
promo
-
card
-
wrapper
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
promo
-
card
-
dismiss
-
button
"
}
external_React_default
(
)
.
createElement
(
"
moz
-
button
"
{
type
:
"
icon
ghost
"
size
:
"
small
"
"
data
-
l10n
-
id
"
:
"
promo
-
card
-
dismiss
-
button
"
iconsrc
:
"
chrome
:
/
/
global
/
skin
/
icons
/
close
.
svg
"
onClick
:
onDismissClick
onKeyDown
:
onDismissClick
}
)
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
promo
-
card
-
inner
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
img
-
wrapper
"
}
external_React_default
(
)
.
createElement
(
"
img
"
{
src
:
"
chrome
:
/
/
newtab
/
content
/
data
/
content
/
assets
/
puzzle
-
fox
.
svg
"
alt
:
"
"
}
)
)
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
promo
-
card
-
title
"
"
data
-
l10n
-
id
"
:
"
newtab
-
promo
-
card
-
title
"
}
)
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
promo
-
card
-
body
"
"
data
-
l10n
-
id
"
:
"
newtab
-
promo
-
card
-
body
"
}
)
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
promo
-
card
-
cta
-
wrapper
"
}
external_React_default
(
)
.
createElement
(
"
a
"
{
href
:
"
https
:
/
/
support
.
mozilla
.
org
/
kb
/
sponsor
-
privacy
"
"
data
-
l10n
-
id
"
:
"
newtab
-
promo
-
card
-
cta
"
target
:
"
_blank
"
rel
:
"
noreferrer
"
}
)
)
)
)
;
}
;
;
const
PREF_TRENDING_VARIANT
=
"
trendingSearch
.
variant
"
;
const
PREF_REFINED_CARDS_LAYOUT
=
"
discoverystream
.
refinedCardsLayout
.
enabled
"
;
function
TrendingSearches
(
)
{
const
[
showContextMenu
setShowContextMenu
]
=
(
0
external_React_namespaceObject
.
useState
)
(
false
)
;
const
[
isKeyboardAccess
setIsKeyboardAccess
]
=
(
0
external_React_namespaceObject
.
useState
)
(
false
)
;
const
dispatch
=
(
0
external_ReactRedux_namespaceObject
.
useDispatch
)
(
)
;
const
{
TrendingSearch
Prefs
}
=
(
0
external_ReactRedux_namespaceObject
.
useSelector
)
(
state
=
>
state
)
;
const
{
values
:
prefs
}
=
Prefs
;
const
{
suggestions
collapsed
}
=
TrendingSearch
;
const
variant
=
prefs
[
PREF_TRENDING_VARIANT
]
;
const
refinedCards
=
prefs
[
PREF_REFINED_CARDS_LAYOUT
]
;
let
resultRef
=
(
0
external_React_namespaceObject
.
useRef
)
(
[
]
)
;
let
contextMenuHost
=
(
0
external_React_namespaceObject
.
useRef
)
(
null
)
;
const
TRENDING_SEARCH_CONTEXT_MENU_OPTIONS
=
[
"
TrendingSearchDismiss
"
"
TrendingSearchLearnMore
"
]
;
function
onArrowClick
(
)
{
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
TRENDING_SEARCH_TOGGLE_COLLAPSE
data
:
{
collapsed
:
!
collapsed
variant
}
}
)
)
;
}
function
handleLinkOpen
(
)
{
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
TRENDING_SEARCH_SUGGESTION_OPEN
data
:
{
variant
}
}
)
)
;
}
const
handleContextMenuShow
=
(
)
=
>
{
const
host
=
contextMenuHost
.
current
;
const
isRTL
=
document
.
dir
=
=
=
"
rtl
"
;
const
checkRect
=
host
.
getBoundingClientRect
(
)
;
const
maxBounds
=
200
;
const
checkBounds
=
isRTL
?
checkRect
.
left
<
=
maxBounds
:
window
.
innerWidth
-
checkRect
.
right
<
=
maxBounds
;
if
(
checkBounds
)
{
host
.
classList
.
add
(
"
last
-
item
"
)
;
}
}
;
const
handleContextMenuUpdate
=
(
)
=
>
{
const
host
=
contextMenuHost
.
current
;
if
(
!
host
)
{
return
;
}
host
.
classList
.
remove
(
"
last
-
item
"
)
;
}
;
const
toggleContextMenu
=
isKeyBoard
=
>
{
setShowContextMenu
(
!
showContextMenu
)
;
setIsKeyboardAccess
(
isKeyBoard
)
;
if
(
!
showContextMenu
)
{
handleContextMenuShow
(
)
;
}
else
{
handleContextMenuUpdate
(
)
;
}
}
;
function
onContextMenuClick
(
e
)
{
e
.
preventDefault
(
)
;
toggleContextMenu
(
false
)
;
}
function
onContextMenuKeyDown
(
e
)
{
if
(
e
.
key
=
=
=
"
Enter
"
|
|
e
.
key
=
=
=
"
"
)
{
e
.
preventDefault
(
)
;
toggleContextMenu
(
true
)
;
}
}
function
onUpdate
(
)
{
setShowContextMenu
(
!
showContextMenu
)
;
}
function
handleResultKeyDown
(
event
index
)
{
const
maxResults
=
suggestions
.
length
;
let
nextIndex
=
index
;
if
(
event
.
key
=
=
=
"
ArrowDown
"
)
{
event
.
preventDefault
(
)
;
if
(
index
<
maxResults
-
1
)
{
nextIndex
=
index
+
1
;
}
else
{
return
;
}
}
else
if
(
event
.
key
=
=
=
"
ArrowUp
"
)
{
event
.
preventDefault
(
)
;
if
(
index
>
0
)
{
nextIndex
=
index
-
1
;
}
else
{
return
;
}
}
resultRef
.
current
[
index
]
.
tabIndex
=
-
1
;
resultRef
.
current
[
nextIndex
]
.
tabIndex
=
0
;
resultRef
.
current
[
nextIndex
]
.
focus
(
)
;
}
const
handleIntersection
=
(
0
external_React_namespaceObject
.
useCallback
)
(
(
)
=
>
{
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
TRENDING_SEARCH_IMPRESSION
data
:
{
variant
}
}
)
)
;
}
[
dispatch
variant
]
)
;
const
ref
=
useIntersectionObserver
(
handleIntersection
)
;
if
(
!
suggestions
?
.
length
)
{
return
null
;
}
else
if
(
variant
=
=
=
"
a
"
|
|
variant
=
=
=
"
c
"
)
{
return
external_React_default
(
)
.
createElement
(
"
section
"
{
ref
:
el
=
>
{
ref
.
current
=
[
el
]
;
}
className
:
trending
-
searches
-
pill
-
wrapper
{
variant
=
=
=
"
c
"
?
"
hover
-
only
"
:
"
"
}
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
trending
-
searches
-
title
-
wrapper
"
}
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
trending
-
searches
-
icon
icon
icon
-
arrow
-
trending
"
}
)
external_React_default
(
)
.
createElement
(
"
h2
"
{
className
:
"
trending
-
searches
-
title
"
"
data
-
l10n
-
id
"
:
"
newtab
-
trending
-
searches
-
title
"
}
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
close
-
open
-
trending
-
searches
"
}
external_React_default
(
)
.
createElement
(
"
moz
-
button
"
{
iconsrc
:
chrome
:
/
/
global
/
skin
/
icons
/
arrow
-
{
collapsed
?
"
down
"
:
"
up
"
}
.
svg
onClick
:
onArrowClick
className
:
icon
icon
-
arrowhead
-
up
type
:
"
icon
ghost
"
"
data
-
l10n
-
id
"
:
newtab
-
trending
-
searches
-
{
collapsed
?
"
show
"
:
"
hide
"
}
-
trending
}
)
)
)
!
collapsed
&
&
external_React_default
(
)
.
createElement
(
"
ul
"
{
className
:
"
trending
-
searches
-
list
"
}
suggestions
.
map
(
(
result
index
)
=
>
{
return
external_React_default
(
)
.
createElement
(
"
li
"
{
key
:
result
.
suggestion
className
:
"
trending
-
search
-
item
"
onKeyDown
:
e
=
>
handleResultKeyDown
(
e
index
)
}
external_React_default
(
)
.
createElement
(
SafeAnchor
{
url
:
result
.
searchUrl
onLinkClick
:
handleLinkOpen
title
:
result
.
suggestion
setRef
:
item
=
>
resultRef
.
current
[
index
]
=
item
tabIndex
:
index
=
=
=
0
?
0
:
-
1
}
result
.
lowerCaseSuggestion
)
)
;
}
)
)
)
;
}
else
if
(
variant
=
=
=
"
b
"
)
{
return
external_React_default
(
)
.
createElement
(
"
div
"
{
ref
:
el
=
>
{
ref
.
current
=
[
el
]
;
contextMenuHost
.
current
=
el
;
}
className
:
"
trending
-
searches
-
list
-
view
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
trending
-
searches
-
list
-
view
-
header
"
}
external_React_default
(
)
.
createElement
(
"
h3
"
{
"
data
-
l10n
-
id
"
:
"
newtab
-
trending
-
searches
-
title
"
}
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
trending
-
searches
-
context
-
menu
-
wrapper
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
trending
-
searches
-
context
-
menu
{
showContextMenu
?
"
context
-
menu
-
open
"
:
"
"
}
}
external_React_default
(
)
.
createElement
(
"
moz
-
button
"
{
type
:
"
icon
ghost
"
size
:
"
default
"
"
data
-
l10n
-
id
"
:
"
newtab
-
menu
-
section
-
tooltip
"
iconsrc
:
"
chrome
:
/
/
global
/
skin
/
icons
/
more
.
svg
"
onClick
:
onContextMenuClick
onKeyDown
:
onContextMenuKeyDown
}
)
showContextMenu
&
&
external_React_default
(
)
.
createElement
(
LinkMenu
{
onUpdate
:
onUpdate
dispatch
:
dispatch
keyboardAccess
:
isKeyboardAccess
options
:
TRENDING_SEARCH_CONTEXT_MENU_OPTIONS
shouldSendImpressionStats
:
true
site
:
{
url
:
"
https
:
/
/
support
.
mozilla
.
org
/
1
/
firefox
/
%
VERSION
%
/
%
OS
%
/
%
LOCALE
%
/
trending
-
searches
-
new
-
tab
"
variant
}
}
)
)
)
)
external_React_default
(
)
.
createElement
(
"
ul
"
{
className
:
"
trending
-
searches
-
list
-
items
"
}
suggestions
.
slice
(
0
6
)
.
map
(
(
result
index
)
=
>
{
return
external_React_default
(
)
.
createElement
(
"
li
"
{
key
:
result
.
suggestion
className
:
trending
-
searches
-
list
-
item
{
refinedCards
?
"
compact
"
:
"
"
}
onKeyDown
:
e
=
>
handleResultKeyDown
(
e
index
)
}
external_React_default
(
)
.
createElement
(
SafeAnchor
{
url
:
result
.
searchUrl
onLinkClick
:
handleLinkOpen
title
:
result
.
suggestion
setRef
:
item
=
>
resultRef
.
current
[
index
]
=
item
tabIndex
:
index
=
=
=
0
?
0
:
-
1
}
result
.
icon
?
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
trending
-
icon
-
wrapper
"
}
external_React_default
(
)
.
createElement
(
"
img
"
{
src
:
result
.
icon
alt
:
"
"
className
:
"
trending
-
icon
"
}
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
trending
-
info
-
wrapper
"
}
result
.
lowerCaseSuggestion
external_React_default
(
)
.
createElement
(
"
small
"
null
result
.
description
)
)
)
:
external_React_default
(
)
.
createElement
(
(
external_React_default
(
)
)
.
Fragment
null
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
trending
-
searches
-
icon
icon
icon
-
arrow
-
trending
"
}
)
result
.
lowerCaseSuggestion
)
)
)
;
}
)
)
)
;
}
}
;
const
PREF_ONBOARDING_EXPERIENCE_DISMISSED
=
"
discoverystream
.
onboardingExperience
.
dismissed
"
;
const
PREF_SECTIONS_CARDS_ENABLED
=
"
discoverystream
.
sections
.
cards
.
enabled
"
;
const
PREF_THUMBS_UP_DOWN_ENABLED
=
"
discoverystream
.
thumbsUpDown
.
enabled
"
;
const
PREF_TOPICS_ENABLED
=
"
discoverystream
.
topicLabels
.
enabled
"
;
const
PREF_TOPICS_SELECTED
=
"
discoverystream
.
topicSelection
.
selectedTopics
"
;
const
PREF_TOPICS_AVAILABLE
=
"
discoverystream
.
topicSelection
.
topics
"
;
const
PREF_SPOCS_STARTUPCACHE_ENABLED
=
"
discoverystream
.
spocs
.
startupCache
.
enabled
"
;
const
PREF_LIST_FEED_ENABLED
=
"
discoverystream
.
contextualContent
.
enabled
"
;
const
PREF_LIST_FEED_SELECTED_FEED
=
"
discoverystream
.
contextualContent
.
selectedFeed
"
;
const
PREF_FAKESPOT_ENABLED
=
"
discoverystream
.
contextualContent
.
fakespot
.
enabled
"
;
const
PREF_BILLBOARD_ENABLED
=
"
newtabAdSize
.
billboard
"
;
const
PREF_BILLBOARD_POSITION
=
"
newtabAdSize
.
billboard
.
position
"
;
const
PREF_PROMOCARD_ENABLED
=
"
discoverystream
.
promoCard
.
enabled
"
;
const
PREF_PROMOCARD_VISIBLE
=
"
discoverystream
.
promoCard
.
visible
"
;
const
PREF_LEADERBOARD_ENABLED
=
"
newtabAdSize
.
leaderboard
"
;
const
PREF_LEADERBOARD_POSITION
=
"
newtabAdSize
.
leaderboard
.
position
"
;
const
PREF_TRENDING_SEARCH
=
"
trendingSearch
.
enabled
"
;
const
PREF_TRENDING_SEARCH_SYSTEM
=
"
system
.
trendingSearch
.
enabled
"
;
const
PREF_SEARCH_ENGINE
=
"
trendingSearch
.
defaultSearchEngine
"
;
const
PREF_TRENDING_SEARCH_VARIANT
=
"
trendingSearch
.
variant
"
;
const
CardGrid_INTERSECTION_RATIO
=
0
.
5
;
const
CardGrid_VISIBLE
=
"
visible
"
;
const
CardGrid_VISIBILITY_CHANGE_EVENT
=
"
visibilitychange
"
;
const
WIDGET_IDS
=
{
TOPICS
:
1
}
;
function
DSSubHeader
(
{
children
}
)
{
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
section
-
top
-
bar
ds
-
sub
-
header
"
}
external_React_default
(
)
.
createElement
(
"
h3
"
{
className
:
"
section
-
title
-
container
"
}
children
)
)
;
}
function
OnboardingExperience
(
{
dispatch
windowObj
=
globalThis
}
)
{
const
[
dismissed
setDismissed
]
=
(
0
external_React_namespaceObject
.
useState
)
(
false
)
;
const
[
maxHeight
setMaxHeight
]
=
(
0
external_React_namespaceObject
.
useState
)
(
null
)
;
const
heightElement
=
(
0
external_React_namespaceObject
.
useRef
)
(
null
)
;
const
onDismissClick
=
(
0
external_React_namespaceObject
.
useCallback
)
(
(
)
=
>
{
setDismissed
(
true
)
;
dispatch
(
actionCreators
.
SetPref
(
PREF_ONBOARDING_EXPERIENCE_DISMISSED
true
)
)
;
dispatch
(
actionCreators
.
DiscoveryStreamUserEvent
(
{
event
:
"
BLOCK
"
source
:
"
POCKET_ONBOARDING
"
}
)
)
;
}
[
dispatch
]
)
;
(
0
external_React_namespaceObject
.
useEffect
)
(
(
)
=
>
{
const
resizeObserver
=
new
windowObj
.
ResizeObserver
(
(
)
=
>
{
if
(
heightElement
.
current
)
{
setMaxHeight
(
heightElement
.
current
.
offsetHeight
)
;
}
}
)
;
const
options
=
{
threshold
:
CardGrid_INTERSECTION_RATIO
}
;
const
intersectionObserver
=
new
windowObj
.
IntersectionObserver
(
entries
=
>
{
if
(
entries
.
some
(
entry
=
>
entry
.
isIntersecting
&
&
entry
.
intersectionRatio
>
=
CardGrid_INTERSECTION_RATIO
)
)
{
dispatch
(
actionCreators
.
DiscoveryStreamUserEvent
(
{
event
:
"
IMPRESSION
"
source
:
"
POCKET_ONBOARDING
"
}
)
)
;
intersectionObserver
.
unobserve
(
heightElement
.
current
)
;
}
}
options
)
;
const
onVisibilityChange
=
(
)
=
>
{
intersectionObserver
.
observe
(
heightElement
.
current
)
;
windowObj
.
document
.
removeEventListener
(
CardGrid_VISIBILITY_CHANGE_EVENT
onVisibilityChange
)
;
}
;
if
(
heightElement
.
current
)
{
resizeObserver
.
observe
(
heightElement
.
current
)
;
if
(
windowObj
.
document
.
visibilityState
=
=
=
CardGrid_VISIBLE
)
{
intersectionObserver
.
observe
(
heightElement
.
current
)
;
}
else
{
windowObj
.
document
.
addEventListener
(
CardGrid_VISIBILITY_CHANGE_EVENT
onVisibilityChange
)
;
}
setMaxHeight
(
heightElement
.
current
.
offsetHeight
)
;
}
return
(
)
=
>
{
resizeObserver
?
.
disconnect
(
)
;
intersectionObserver
?
.
disconnect
(
)
;
windowObj
.
document
.
removeEventListener
(
CardGrid_VISIBILITY_CHANGE_EVENT
onVisibilityChange
)
;
}
;
}
[
dispatch
windowObj
]
)
;
const
style
=
{
}
;
if
(
dismissed
)
{
style
.
maxHeight
=
"
0
"
;
style
.
opacity
=
"
0
"
;
style
.
transition
=
"
max
-
height
0
.
26s
ease
opacity
0
.
26s
ease
"
;
}
else
if
(
maxHeight
)
{
style
.
maxHeight
=
{
maxHeight
}
px
;
}
return
external_React_default
(
)
.
createElement
(
"
div
"
{
style
:
style
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
ds
-
onboarding
-
ref
"
ref
:
heightElement
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
ds
-
onboarding
-
container
"
}
external_React_default
(
)
.
createElement
(
DSDismiss
{
onDismissClick
:
onDismissClick
extraClasses
:
ds
-
onboarding
}
external_React_default
(
)
.
createElement
(
"
div
"
null
external_React_default
(
)
.
createElement
(
"
header
"
null
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
icon
icon
-
pocket
"
}
)
external_React_default
(
)
.
createElement
(
"
span
"
{
"
data
-
l10n
-
id
"
:
"
newtab
-
pocket
-
onboarding
-
discover
"
}
)
)
external_React_default
(
)
.
createElement
(
"
p
"
{
"
data
-
l10n
-
id
"
:
"
newtab
-
pocket
-
onboarding
-
cta
"
}
)
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
ds
-
onboarding
-
graphic
"
}
)
)
)
)
)
;
}
function
CardGrid_IntersectionObserver
(
{
children
windowObj
=
window
onIntersecting
}
)
{
const
intersectionElement
=
(
0
external_React_namespaceObject
.
useRef
)
(
null
)
;
(
0
external_React_namespaceObject
.
useEffect
)
(
(
)
=
>
{
let
observer
;
if
(
!
observer
&
&
onIntersecting
&
&
intersectionElement
.
current
)
{
observer
=
new
windowObj
.
IntersectionObserver
(
entries
=
>
{
const
entry
=
entries
.
find
(
e
=
>
e
.
isIntersecting
)
;
if
(
entry
)
{
if
(
observer
&
&
intersectionElement
.
current
)
{
observer
.
unobserve
(
intersectionElement
.
current
)
;
}
onIntersecting
(
)
;
}
}
)
;
observer
.
observe
(
intersectionElement
.
current
)
;
}
return
(
)
=
>
observer
?
.
disconnect
(
)
;
}
[
windowObj
onIntersecting
]
)
;
return
external_React_default
(
)
.
createElement
(
"
div
"
{
ref
:
intersectionElement
}
children
)
;
}
function
RecentSavesContainer
(
{
gridClassName
=
"
"
dispatch
windowObj
=
window
items
=
3
source
=
"
CARDGRID_RECENT_SAVES
"
}
)
{
const
{
recentSavesData
isUserLoggedIn
experimentData
:
{
utmCampaign
utmContent
utmSource
}
}
=
(
0
external_ReactRedux_namespaceObject
.
useSelector
)
(
state
=
>
state
.
DiscoveryStream
)
;
const
[
visible
setVisible
]
=
(
0
external_React_namespaceObject
.
useState
)
(
false
)
;
const
onIntersecting
=
(
0
external_React_namespaceObject
.
useCallback
)
(
(
)
=
>
setVisible
(
true
)
[
]
)
;
(
0
external_React_namespaceObject
.
useEffect
)
(
(
)
=
>
{
if
(
visible
)
{
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
DISCOVERY_STREAM_POCKET_STATE_INIT
}
)
)
;
}
}
[
visible
dispatch
]
)
;
if
(
!
visible
)
{
return
external_React_default
(
)
.
createElement
(
CardGrid_IntersectionObserver
{
windowObj
:
windowObj
onIntersecting
:
onIntersecting
}
)
;
}
if
(
visible
&
&
!
isUserLoggedIn
)
{
return
null
;
}
let
queryParams
=
?
utm_source
=
{
utmSource
}
;
if
(
utmCampaign
&
&
utmContent
)
{
queryParams
+
=
&
utm_content
=
{
utmContent
}
&
utm_campaign
=
{
utmCampaign
}
;
}
function
renderCard
(
rec
index
)
{
const
url
=
new
URL
(
rec
.
url
)
;
const
urlSearchParams
=
new
URLSearchParams
(
queryParams
)
;
if
(
rec
?
.
id
&
&
!
url
.
href
.
match
(
/
getpocket
\
.
com
\
/
read
/
)
)
{
url
.
href
=
https
:
/
/
getpocket
.
com
/
read
/
{
rec
.
id
}
;
}
for
(
let
[
key
val
]
of
urlSearchParams
.
entries
(
)
)
{
url
.
searchParams
.
set
(
key
val
)
;
}
return
external_React_default
(
)
.
createElement
(
DSCard
{
key
:
dscard
-
{
rec
?
.
id
|
|
index
}
id
:
rec
.
id
pos
:
index
type
:
source
image_src
:
rec
.
image_src
raw_image_src
:
rec
.
raw_image_src
icon_src
:
rec
.
icon_src
word_count
:
rec
.
word_count
time_to_read
:
rec
.
time_to_read
title
:
rec
.
title
excerpt
:
rec
.
excerpt
url
:
url
.
href
source
:
rec
.
domain
isRecentSave
:
true
dispatch
:
dispatch
}
)
;
}
function
onMyListClicked
(
)
{
dispatch
(
actionCreators
.
DiscoveryStreamUserEvent
(
{
event
:
"
CLICK
"
source
:
{
source
}
_VIEW_LIST
}
)
)
;
}
const
recentSavesCards
=
[
]
;
for
(
let
index
=
0
;
index
<
items
;
index
+
+
)
{
const
recentSave
=
recentSavesData
[
index
]
;
if
(
!
recentSave
)
{
recentSavesCards
.
push
(
external_React_default
(
)
.
createElement
(
PlaceholderDSCard
{
key
:
dscard
-
{
index
}
}
)
)
;
}
else
{
recentSavesCards
.
push
(
renderCard
(
{
id
:
recentSave
.
id
image_src
:
recentSave
.
top_image_url
raw_image_src
:
recentSave
.
top_image_url
word_count
:
recentSave
.
word_count
time_to_read
:
recentSave
.
time_to_read
title
:
recentSave
.
resolved_title
|
|
recentSave
.
given_title
url
:
recentSave
.
resolved_url
|
|
recentSave
.
given_url
domain
:
recentSave
.
domain_metadata
?
.
name
excerpt
:
recentSave
.
excerpt
}
index
)
)
;
}
}
return
external_React_default
(
)
.
createElement
(
(
external_React_default
(
)
)
.
Fragment
null
external_React_default
(
)
.
createElement
(
DSSubHeader
null
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
section
-
title
"
}
external_React_default
(
)
.
createElement
(
FluentOrText
{
message
:
"
Recently
Saved
to
your
List
"
}
)
)
external_React_default
(
)
.
createElement
(
SafeAnchor
{
onLinkClick
:
onMyListClicked
className
:
"
section
-
sub
-
link
"
url
:
https
:
/
/
getpocket
.
com
/
a
{
queryParams
}
}
external_React_default
(
)
.
createElement
(
FluentOrText
{
message
:
"
View
My
List
"
}
)
)
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
ds
-
card
-
grid
-
recent
-
saves
{
gridClassName
}
}
recentSavesCards
)
)
;
}
class
_CardGrid
extends
(
external_React_default
(
)
)
.
PureComponent
{
renderCards
(
)
{
const
prefs
=
this
.
props
.
Prefs
.
values
;
const
{
items
fourCardLayout
essentialReadsHeader
editorsPicksHeader
onboardingExperience
ctaButtonSponsors
ctaButtonVariant
spocMessageVariant
widgets
recentSavesEnabled
DiscoveryStream
}
=
this
.
props
;
const
{
topicsLoading
}
=
DiscoveryStream
;
const
showRecentSaves
=
prefs
.
showRecentSaves
&
&
recentSavesEnabled
;
const
isOnboardingExperienceDismissed
=
prefs
[
PREF_ONBOARDING_EXPERIENCE_DISMISSED
]
;
const
mayHaveSectionsCards
=
prefs
[
PREF_SECTIONS_CARDS_ENABLED
]
;
const
mayHaveThumbsUpDown
=
prefs
[
PREF_THUMBS_UP_DOWN_ENABLED
]
;
const
showTopics
=
prefs
[
PREF_TOPICS_ENABLED
]
;
const
selectedTopics
=
prefs
[
PREF_TOPICS_SELECTED
]
;
const
availableTopics
=
prefs
[
PREF_TOPICS_AVAILABLE
]
;
const
spocsStartupCacheEnabled
=
prefs
[
PREF_SPOCS_STARTUPCACHE_ENABLED
]
;
const
listFeedEnabled
=
prefs
[
PREF_LIST_FEED_ENABLED
]
;
const
listFeedSelectedFeed
=
prefs
[
PREF_LIST_FEED_SELECTED_FEED
]
;
const
billboardEnabled
=
prefs
[
PREF_BILLBOARD_ENABLED
]
;
const
promoCardEnabled
=
prefs
[
PREF_PROMOCARD_ENABLED
]
&
&
prefs
[
PREF_PROMOCARD_VISIBLE
]
;
const
leaderboardEnabled
=
prefs
[
PREF_LEADERBOARD_ENABLED
]
;
const
trendingEnabled
=
prefs
[
PREF_TRENDING_SEARCH
]
&
&
prefs
[
PREF_TRENDING_SEARCH_SYSTEM
]
&
&
prefs
[
PREF_SEARCH_ENGINE
]
?
.
toLowerCase
(
)
=
=
=
"
google
"
;
const
trendingVariant
=
prefs
[
PREF_TRENDING_SEARCH_VARIANT
]
;
const
recs
=
this
.
props
.
data
.
recommendations
.
filter
(
item
=
>
!
item
.
feedName
)
.
slice
(
0
items
)
;
const
cards
=
[
]
;
let
essentialReadsCards
=
[
]
;
let
editorsPicksCards
=
[
]
;
for
(
let
index
=
0
;
index
<
items
;
index
+
+
)
{
const
rec
=
recs
[
index
]
;
cards
.
push
(
topicsLoading
|
|
!
rec
|
|
rec
.
placeholder
|
|
rec
.
flight_id
&
&
!
spocsStartupCacheEnabled
&
&
this
.
props
.
App
.
isForStartupCache
.
DiscoveryStream
?
external_React_default
(
)
.
createElement
(
PlaceholderDSCard
{
key
:
dscard
-
{
index
}
}
)
:
external_React_default
(
)
.
createElement
(
DSCard
{
key
:
dscard
-
{
rec
.
id
}
pos
:
rec
.
pos
flightId
:
rec
.
flight_id
image_src
:
rec
.
image_src
raw_image_src
:
rec
.
raw_image_src
icon_src
:
rec
.
icon_src
word_count
:
rec
.
word_count
time_to_read
:
rec
.
time_to_read
title
:
rec
.
title
topic
:
rec
.
topic
features
:
rec
.
features
showTopics
:
showTopics
selectedTopics
:
selectedTopics
excerpt
:
rec
.
excerpt
availableTopics
:
availableTopics
url
:
rec
.
url
id
:
rec
.
id
shim
:
rec
.
shim
fetchTimestamp
:
rec
.
fetchTimestamp
type
:
this
.
props
.
type
context
:
rec
.
context
sponsor
:
rec
.
sponsor
sponsored_by_override
:
rec
.
sponsored_by_override
dispatch
:
this
.
props
.
dispatch
source
:
rec
.
domain
publisher
:
rec
.
publisher
pocket_id
:
rec
.
pocket_id
context_type
:
rec
.
context_type
bookmarkGuid
:
rec
.
bookmarkGuid
is_collection
:
this
.
props
.
is_collection
ctaButtonSponsors
:
ctaButtonSponsors
ctaButtonVariant
:
ctaButtonVariant
spocMessageVariant
:
spocMessageVariant
recommendation_id
:
rec
.
recommendation_id
firstVisibleTimestamp
:
this
.
props
.
firstVisibleTimestamp
mayHaveThumbsUpDown
:
mayHaveThumbsUpDown
mayHaveSectionsCards
:
mayHaveSectionsCards
corpus_item_id
:
rec
.
corpus_item_id
scheduled_corpus_item_id
:
rec
.
scheduled_corpus_item_id
recommended_at
:
rec
.
recommended_at
received_rank
:
rec
.
received_rank
format
:
rec
.
format
alt_text
:
rec
.
alt_text
isTimeSensitive
:
rec
.
isTimeSensitive
}
)
)
;
}
if
(
widgets
?
.
positions
?
.
length
&
&
widgets
?
.
data
?
.
length
)
{
let
positionIndex
=
0
;
const
source
=
"
CARDGRID_WIDGET
"
;
for
(
const
widget
of
widgets
.
data
)
{
let
widgetComponent
=
null
;
const
position
=
widgets
.
positions
[
positionIndex
]
;
if
(
!
position
)
{
break
;
}
switch
(
widget
?
.
type
)
{
case
"
TopicsWidget
"
:
widgetComponent
=
external_React_default
(
)
.
createElement
(
TopicsWidget
{
position
:
position
.
index
dispatch
:
this
.
props
.
dispatch
source
:
source
id
:
WIDGET_IDS
.
TOPICS
}
)
;
break
;
}
if
(
widgetComponent
)
{
positionIndex
+
+
;
cards
.
splice
(
position
.
index
1
widgetComponent
)
;
}
}
}
if
(
listFeedEnabled
)
{
const
isFakespot
=
listFeedSelectedFeed
=
=
=
"
fakespot
"
;
const
fakespotEnabled
=
prefs
[
PREF_FAKESPOT_ENABLED
]
;
if
(
!
isFakespot
|
|
isFakespot
&
&
fakespotEnabled
)
{
cards
.
splice
(
2
1
this
.
renderListFeed
(
this
.
props
.
data
.
recommendations
listFeedSelectedFeed
)
)
;
}
}
if
(
trendingEnabled
&
&
trendingVariant
=
=
=
"
b
"
)
{
const
firstSpocPosition
=
this
.
props
.
spocPositions
[
0
]
?
.
index
;
const
format
=
cards
[
firstSpocPosition
]
?
.
props
?
.
format
;
const
isSpoc
=
format
=
=
=
"
spoc
"
|
|
format
=
=
=
"
rectangle
"
;
cards
.
splice
(
isSpoc
?
firstSpocPosition
+
1
:
2
1
external_React_default
(
)
.
createElement
(
TrendingSearches
null
)
)
;
}
const
{
spocs
}
=
this
.
props
.
DiscoveryStream
;
if
(
(
billboardEnabled
|
|
leaderboardEnabled
)
&
&
spocs
?
.
data
?
.
newtab_spocs
?
.
items
)
{
const
spocToRender
=
spocs
.
data
.
newtab_spocs
.
items
.
find
(
(
{
format
}
)
=
>
format
=
=
=
"
leaderboard
"
&
&
leaderboardEnabled
)
|
|
spocs
.
data
.
newtab_spocs
.
items
.
find
(
(
{
format
}
)
=
>
format
=
=
=
"
billboard
"
&
&
billboardEnabled
)
;
if
(
spocToRender
&
&
!
spocs
.
blocked
.
includes
(
spocToRender
.
url
)
)
{
const
row
=
spocToRender
.
format
=
=
=
"
leaderboard
"
?
prefs
[
PREF_LEADERBOARD_POSITION
]
:
prefs
[
PREF_BILLBOARD_POSITION
]
;
function
displayCardsPerRow
(
)
{
if
(
window
.
innerWidth
<
=
1122
)
{
return
2
;
}
else
if
(
window
.
innerWidth
>
1122
&
&
window
.
innerWidth
<
1698
)
{
return
3
;
}
return
4
;
}
const
injectAdBanner
=
bannerIndex
=
>
{
cards
.
splice
(
bannerIndex
0
external_React_default
(
)
.
createElement
(
AdBanner
{
spoc
:
spocToRender
key
:
dscard
-
{
spocToRender
.
id
}
dispatch
:
this
.
props
.
dispatch
type
:
this
.
props
.
type
firstVisibleTimestamp
:
this
.
props
.
firstVisibleTimestamp
row
:
row
prefs
:
prefs
}
)
)
;
if
(
promoCardEnabled
)
{
cards
.
splice
(
bannerIndex
+
1
0
external_React_default
(
)
.
createElement
(
PromoCard
null
)
)
;
}
}
;
const
getBannerIndex
=
(
)
=
>
{
const
cardsPerRow
=
displayCardsPerRow
(
)
;
let
bannerIndex
=
(
row
-
1
)
*
cardsPerRow
;
return
bannerIndex
;
}
;
injectAdBanner
(
getBannerIndex
(
)
)
;
}
}
let
moreRecsHeader
=
"
"
;
if
(
showRecentSaves
|
|
essentialReadsHeader
&
&
editorsPicksHeader
)
{
let
spliceAt
=
6
;
if
(
fourCardLayout
)
{
spliceAt
=
8
;
}
moreRecsHeader
=
"
More
Recommendations
"
;
essentialReadsCards
=
[
.
.
.
cards
.
splice
(
0
spliceAt
)
]
;
if
(
essentialReadsHeader
&
&
editorsPicksHeader
)
{
editorsPicksCards
=
[
.
.
.
cards
.
splice
(
0
cards
.
length
)
]
;
}
}
const
gridClassName
=
this
.
renderGridClassName
(
)
;
return
external_React_default
(
)
.
createElement
(
(
external_React_default
(
)
)
.
Fragment
null
!
isOnboardingExperienceDismissed
&
&
onboardingExperience
&
&
external_React_default
(
)
.
createElement
(
OnboardingExperience
{
dispatch
:
this
.
props
.
dispatch
}
)
essentialReadsCards
?
.
length
>
0
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
gridClassName
}
essentialReadsCards
)
showRecentSaves
&
&
external_React_default
(
)
.
createElement
(
RecentSavesContainer
{
gridClassName
:
gridClassName
dispatch
:
this
.
props
.
dispatch
}
)
editorsPicksCards
?
.
length
>
0
&
&
external_React_default
(
)
.
createElement
(
(
external_React_default
(
)
)
.
Fragment
null
external_React_default
(
)
.
createElement
(
DSSubHeader
null
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
section
-
title
"
}
external_React_default
(
)
.
createElement
(
FluentOrText
{
message
:
"
Editor
\
u2019s
Picks
"
}
)
)
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
gridClassName
}
editorsPicksCards
)
)
cards
?
.
length
>
0
&
&
external_React_default
(
)
.
createElement
(
(
external_React_default
(
)
)
.
Fragment
null
moreRecsHeader
&
&
external_React_default
(
)
.
createElement
(
DSSubHeader
null
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
section
-
title
"
}
external_React_default
(
)
.
createElement
(
FluentOrText
{
message
:
moreRecsHeader
}
)
)
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
gridClassName
}
cards
)
)
)
;
}
renderListFeed
(
recommendations
selectedFeed
)
{
const
recs
=
recommendations
.
filter
(
item
=
>
item
.
feedName
=
=
=
selectedFeed
)
;
const
isFakespot
=
selectedFeed
=
=
=
"
fakespot
"
;
const
categories
=
[
.
.
.
new
Set
(
recs
.
map
(
(
{
category
}
)
=
>
category
)
)
]
;
const
listFeed
=
external_React_default
(
)
.
createElement
(
ListFeed
{
recs
:
recs
categories
:
isFakespot
?
categories
:
[
]
firstVisibleTimestamp
:
this
.
props
.
firstVisibleTimestamp
type
:
this
.
props
.
type
dispatch
:
this
.
props
.
dispatch
}
)
;
return
listFeed
;
}
renderGridClassName
(
)
{
const
{
hybridLayout
hideCardBackground
fourCardLayout
compactGrid
hideDescriptions
}
=
this
.
props
;
const
hideCardBackgroundClass
=
hideCardBackground
?
ds
-
card
-
grid
-
hide
-
background
:
;
const
fourCardLayoutClass
=
fourCardLayout
?
ds
-
card
-
grid
-
four
-
card
-
variant
:
;
const
hideDescriptionsClassName
=
!
hideDescriptions
?
ds
-
card
-
grid
-
include
-
descriptions
:
;
const
compactGridClassName
=
compactGrid
?
ds
-
card
-
grid
-
compact
:
;
const
hybridLayoutClassName
=
hybridLayout
?
ds
-
card
-
grid
-
hybrid
-
layout
:
;
const
gridClassName
=
ds
-
card
-
grid
{
hybridLayoutClassName
}
{
hideCardBackgroundClass
}
{
fourCardLayoutClass
}
{
hideDescriptionsClassName
}
{
compactGridClassName
}
;
return
gridClassName
;
}
render
(
)
{
const
{
data
}
=
this
.
props
;
if
(
!
data
)
{
return
null
;
}
const
isEmpty
=
data
.
recommendations
.
length
=
=
=
0
;
return
external_React_default
(
)
.
createElement
(
"
div
"
null
this
.
props
.
title
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
ds
-
header
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
title
"
}
this
.
props
.
title
)
this
.
props
.
context
&
&
external_React_default
(
)
.
createElement
(
FluentOrText
{
message
:
this
.
props
.
context
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
ds
-
context
"
}
)
)
)
isEmpty
?
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
ds
-
card
-
grid
empty
"
}
external_React_default
(
)
.
createElement
(
DSEmptyState
{
status
:
data
.
status
dispatch
:
this
.
props
.
dispatch
feed
:
this
.
props
.
feed
}
)
)
:
this
.
renderCards
(
)
)
;
}
}
_CardGrid
.
defaultProps
=
{
items
:
4
}
;
const
CardGrid
=
(
0
external_ReactRedux_namespaceObject
.
connect
)
(
state
=
>
(
{
Prefs
:
state
.
Prefs
App
:
state
.
App
DiscoveryStream
:
state
.
DiscoveryStream
}
)
)
(
_CardGrid
)
;
;
class
CollectionCardGrid
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
onDismissClick
=
this
.
onDismissClick
.
bind
(
this
)
;
this
.
state
=
{
dismissed
:
false
}
;
}
onDismissClick
(
)
{
const
{
data
}
=
this
.
props
;
if
(
this
.
props
.
dispatch
&
&
data
&
&
data
.
spocs
&
&
data
.
spocs
.
length
)
{
this
.
setState
(
{
dismissed
:
true
}
)
;
const
pos
=
0
;
const
source
=
this
.
props
.
type
.
toUpperCase
(
)
;
const
spocsData
=
data
.
spocs
.
map
(
item
=
>
(
{
url
:
item
.
url
guid
:
item
.
id
shim
:
item
.
shim
flight_id
:
item
.
flightId
}
)
)
;
const
blockUrlOption
=
LinkMenuOptions
.
BlockUrls
(
spocsData
pos
source
)
;
const
{
action
impression
userEvent
}
=
blockUrlOption
;
this
.
props
.
dispatch
(
action
)
;
this
.
props
.
dispatch
(
actionCreators
.
DiscoveryStreamUserEvent
(
{
event
:
userEvent
source
action_position
:
pos
}
)
)
;
if
(
impression
)
{
this
.
props
.
dispatch
(
impression
)
;
}
}
}
render
(
)
{
const
{
data
dismissible
pocket_button_enabled
}
=
this
.
props
;
if
(
this
.
state
.
dismissed
|
|
!
data
|
|
!
data
.
spocs
|
|
!
data
.
spocs
[
0
]
|
|
data
.
spocs
.
length
<
3
)
{
return
null
;
}
const
{
spocs
placement
feed
}
=
this
.
props
;
const
{
title
context
sponsored_by_override
sponsor
}
=
spocs
.
data
[
placement
.
name
]
|
|
{
}
;
if
(
!
title
)
{
return
null
;
}
let
sponsoredByMessage
=
"
"
;
if
(
sponsored_by_override
|
|
sponsored_by_override
=
=
=
"
"
)
{
sponsoredByMessage
=
sponsored_by_override
;
}
else
if
(
sponsor
)
{
sponsoredByMessage
=
{
id
:
newtab
-
label
-
sponsored
-
by
values
:
{
sponsor
}
}
;
}
else
if
(
context
)
{
sponsoredByMessage
=
context
;
}
const
recsData
=
{
recommendations
:
data
.
spocs
}
;
const
type
=
{
this
.
props
.
type
}
_card
;
const
collectionGrid
=
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
ds
-
collection
-
card
-
grid
"
}
external_React_default
(
)
.
createElement
(
CardGrid
{
pocket_button_enabled
:
pocket_button_enabled
title
:
title
context
:
sponsoredByMessage
data
:
recsData
feed
:
feed
type
:
type
is_collection
:
true
dispatch
:
this
.
props
.
dispatch
items
:
this
.
props
.
items
}
)
)
;
if
(
dismissible
)
{
return
external_React_default
(
)
.
createElement
(
DSDismiss
{
onDismissClick
:
this
.
onDismissClick
extraClasses
:
ds
-
dismiss
-
ds
-
collection
}
collectionGrid
)
;
}
return
collectionGrid
;
}
}
;
function
A11yLinkButton_extends
(
)
{
return
A11yLinkButton_extends
=
Object
.
assign
?
Object
.
assign
.
bind
(
)
:
function
(
n
)
{
for
(
var
e
=
1
;
e
<
arguments
.
length
;
e
+
+
)
{
var
t
=
arguments
[
e
]
;
for
(
var
r
in
t
)
(
{
}
)
.
hasOwnProperty
.
call
(
t
r
)
&
&
(
n
[
r
]
=
t
[
r
]
)
;
}
return
n
;
}
A11yLinkButton_extends
.
apply
(
null
arguments
)
;
}
function
A11yLinkButton
(
props
)
{
let
className
=
"
a11y
-
link
-
button
"
;
if
(
props
.
className
)
{
className
+
=
{
props
.
className
}
;
}
return
external_React_default
(
)
.
createElement
(
"
button
"
A11yLinkButton_extends
(
{
type
:
"
button
"
}
props
{
className
:
className
}
)
props
.
children
)
;
}
;
class
ErrorBoundaryFallback
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
windowObj
=
this
.
props
.
windowObj
|
|
window
;
this
.
onClick
=
this
.
onClick
.
bind
(
this
)
;
}
onClick
(
)
{
this
.
windowObj
.
location
.
reload
(
true
)
;
}
render
(
)
{
const
defaultClass
=
"
as
-
error
-
fallback
"
;
let
className
;
if
(
"
className
"
in
this
.
props
)
{
className
=
{
this
.
props
.
className
}
{
defaultClass
}
;
}
else
{
className
=
defaultClass
;
}
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
className
}
external_React_default
(
)
.
createElement
(
"
div
"
{
"
data
-
l10n
-
id
"
:
"
newtab
-
error
-
fallback
-
info
"
}
)
external_React_default
(
)
.
createElement
(
"
span
"
null
external_React_default
(
)
.
createElement
(
A11yLinkButton
{
className
:
"
reload
-
button
"
onClick
:
this
.
onClick
"
data
-
l10n
-
id
"
:
"
newtab
-
error
-
fallback
-
refresh
-
link
"
}
)
)
)
;
}
}
ErrorBoundaryFallback
.
defaultProps
=
{
className
:
"
as
-
error
-
fallback
"
}
;
class
ErrorBoundary
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
state
=
{
hasError
:
false
}
;
}
componentDidCatch
(
)
{
this
.
setState
(
{
hasError
:
true
}
)
;
}
render
(
)
{
if
(
!
this
.
state
.
hasError
)
{
return
this
.
props
.
children
;
}
return
external_React_default
(
)
.
createElement
(
this
.
props
.
FallbackComponent
{
className
:
this
.
props
.
className
}
)
;
}
}
ErrorBoundary
.
defaultProps
=
{
FallbackComponent
:
ErrorBoundaryFallback
}
;
;
class
_CollapsibleSection
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
onBodyMount
=
this
.
onBodyMount
.
bind
(
this
)
;
this
.
onMenuButtonMouseEnter
=
this
.
onMenuButtonMouseEnter
.
bind
(
this
)
;
this
.
onMenuButtonMouseLeave
=
this
.
onMenuButtonMouseLeave
.
bind
(
this
)
;
this
.
onMenuUpdate
=
this
.
onMenuUpdate
.
bind
(
this
)
;
this
.
setContextMenuButtonRef
=
this
.
setContextMenuButtonRef
.
bind
(
this
)
;
this
.
handleTopicSelectionButtonClick
=
this
.
handleTopicSelectionButtonClick
.
bind
(
this
)
;
this
.
state
=
{
menuButtonHover
:
false
showContextMenu
:
false
}
;
}
setContextMenuButtonRef
(
element
)
{
this
.
contextMenuButtonRef
=
element
;
}
onBodyMount
(
node
)
{
this
.
sectionBody
=
node
;
}
onMenuButtonMouseEnter
(
)
{
this
.
setState
(
{
menuButtonHover
:
true
}
)
;
}
onMenuButtonMouseLeave
(
)
{
this
.
setState
(
{
menuButtonHover
:
false
}
)
;
}
onMenuUpdate
(
showContextMenu
)
{
this
.
setState
(
{
showContextMenu
}
)
;
}
handleTopicSelectionButtonClick
(
)
{
const
maybeDisplay
=
this
.
props
.
Prefs
.
values
[
"
discoverystream
.
topicSelection
.
onboarding
.
maybeDisplay
"
]
;
this
.
props
.
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
TOPIC_SELECTION_USER_OPEN
}
)
)
;
if
(
maybeDisplay
)
{
this
.
props
.
dispatch
(
actionCreators
.
SetPref
(
"
discoverystream
.
topicSelection
.
onboarding
.
maybeDisplay
"
false
)
)
;
}
this
.
props
.
dispatch
(
actionCreators
.
BroadcastToContent
(
{
type
:
actionTypes
.
TOPIC_SELECTION_SPOTLIGHT_OPEN
}
)
)
;
}
render
(
)
{
const
{
isAnimating
maxHeight
menuButtonHover
showContextMenu
}
=
this
.
state
;
const
{
id
collapsed
title
subTitle
mayHaveSponsoredStories
mayHaveTopicsSelection
sectionsEnabled
}
=
this
.
props
;
const
active
=
menuButtonHover
|
|
showContextMenu
;
let
bodyStyle
;
if
(
isAnimating
&
&
!
collapsed
)
{
bodyStyle
=
{
maxHeight
}
;
}
else
if
(
!
isAnimating
&
&
collapsed
)
{
bodyStyle
=
{
display
:
"
none
"
}
;
}
let
titleStyle
;
if
(
this
.
props
.
hideTitle
)
{
titleStyle
=
{
visibility
:
"
hidden
"
}
;
}
const
hasSubtitleClassName
=
subTitle
?
has
-
subtitle
:
;
const
hasBeenUpdatedPreviously
=
this
.
props
.
Prefs
.
values
[
"
discoverystream
.
topicSelection
.
hasBeenUpdatedPreviously
"
]
;
const
selectedTopics
=
this
.
props
.
Prefs
.
values
[
"
discoverystream
.
topicSelection
.
selectedTopics
"
]
;
const
topicsHaveBeenPreviouslySet
=
hasBeenUpdatedPreviously
|
|
selectedTopics
;
return
external_React_default
(
)
.
createElement
(
"
section
"
{
className
:
collapsible
-
section
{
this
.
props
.
className
}
{
active
?
"
active
"
:
"
"
}
"
data
-
section
-
id
"
:
id
}
!
sectionsEnabled
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
section
-
top
-
bar
"
}
external_React_default
(
)
.
createElement
(
"
h2
"
{
className
:
section
-
title
-
container
{
hasSubtitleClassName
}
style
:
titleStyle
}
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
section
-
title
"
}
external_React_default
(
)
.
createElement
(
FluentOrText
{
message
:
title
}
)
)
subTitle
&
&
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
section
-
sub
-
title
"
}
external_React_default
(
)
.
createElement
(
FluentOrText
{
message
:
subTitle
}
)
)
mayHaveSponsoredStories
&
&
this
.
props
.
spocMessageVariant
=
=
=
"
variant
-
a
"
&
&
external_React_default
(
)
.
createElement
(
SponsoredContentHighlight
{
position
:
"
inset
-
block
-
start
inset
-
inline
-
start
"
dispatch
:
this
.
props
.
dispatch
}
)
)
mayHaveTopicsSelection
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
button
-
topic
-
selection
"
}
external_React_default
(
)
.
createElement
(
"
moz
-
button
"
{
"
data
-
l10n
-
id
"
:
topicsHaveBeenPreviouslySet
?
"
newtab
-
topic
-
selection
-
button
-
update
-
interests
"
:
"
newtab
-
topic
-
selection
-
button
-
pick
-
interests
"
type
:
topicsHaveBeenPreviouslySet
?
"
default
"
:
"
primary
"
onClick
:
this
.
handleTopicSelectionButtonClick
}
)
)
)
external_React_default
(
)
.
createElement
(
ErrorBoundary
{
className
:
"
section
-
body
-
fallback
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
ref
:
this
.
onBodyMount
style
:
bodyStyle
}
this
.
props
.
children
)
)
)
;
}
}
_CollapsibleSection
.
defaultProps
=
{
document
:
globalThis
.
document
|
|
{
addEventListener
:
(
)
=
>
{
}
removeEventListener
:
(
)
=
>
{
}
visibilityState
:
"
hidden
"
}
}
;
const
CollapsibleSection
=
(
0
external_ReactRedux_namespaceObject
.
connect
)
(
state
=
>
(
{
Prefs
:
state
.
Prefs
}
)
)
(
_CollapsibleSection
)
;
;
class
DSMessage
extends
(
external_React_default
(
)
)
.
PureComponent
{
render
(
)
{
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
ds
-
message
"
}
external_React_default
(
)
.
createElement
(
"
header
"
{
className
:
"
title
"
}
this
.
props
.
icon
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
glyph
"
style
:
{
backgroundImage
:
url
(
{
this
.
props
.
icon
}
)
}
}
)
this
.
props
.
title
&
&
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
title
-
text
"
}
external_React_default
(
)
.
createElement
(
FluentOrText
{
message
:
this
.
props
.
title
}
)
)
this
.
props
.
link_text
&
&
this
.
props
.
link_url
&
&
external_React_default
(
)
.
createElement
(
SafeAnchor
{
className
:
"
link
"
url
:
this
.
props
.
link_url
}
external_React_default
(
)
.
createElement
(
FluentOrText
{
message
:
this
.
props
.
link_text
}
)
)
)
)
;
}
}
;
function
ModalOverlayWrapper
(
{
document
=
globalThis
.
document
unstyled
innerClassName
onClose
children
headerId
id
}
)
{
const
modalRef
=
(
0
external_React_namespaceObject
.
useRef
)
(
null
)
;
let
className
=
unstyled
?
"
"
:
"
modalOverlayInner
active
"
;
if
(
innerClassName
)
{
className
+
=
{
innerClassName
}
;
}
const
onKeyDown
=
(
0
external_React_namespaceObject
.
useCallback
)
(
event
=
>
{
if
(
event
.
key
=
=
=
"
Escape
"
)
{
onClose
(
event
)
;
}
}
[
onClose
]
)
;
(
0
external_React_namespaceObject
.
useEffect
)
(
(
)
=
>
{
document
.
addEventListener
(
"
keydown
"
onKeyDown
)
;
document
.
body
.
classList
.
add
(
"
modal
-
open
"
)
;
return
(
)
=
>
{
document
.
removeEventListener
(
"
keydown
"
onKeyDown
)
;
document
.
body
.
classList
.
remove
(
"
modal
-
open
"
)
;
}
;
}
[
document
onKeyDown
]
)
;
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
modalOverlayOuter
active
"
onKeyDown
:
onKeyDown
role
:
"
presentation
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
className
"
aria
-
labelledby
"
:
headerId
id
:
id
role
:
"
dialog
"
ref
:
modalRef
}
children
)
)
;
}
;
class
DSPrivacyModal
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
closeModal
=
this
.
closeModal
.
bind
(
this
)
;
this
.
onLearnLinkClick
=
this
.
onLearnLinkClick
.
bind
(
this
)
;
this
.
onManageLinkClick
=
this
.
onManageLinkClick
.
bind
(
this
)
;
}
onLearnLinkClick
(
)
{
this
.
props
.
dispatch
(
actionCreators
.
DiscoveryStreamUserEvent
(
{
event
:
"
CLICK_PRIVACY_INFO
"
source
:
"
DS_PRIVACY_MODAL
"
}
)
)
;
}
onManageLinkClick
(
)
{
this
.
props
.
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
SETTINGS_OPEN
}
)
)
;
}
closeModal
(
)
{
this
.
props
.
dispatch
(
{
type
:
HIDE_PRIVACY_INFO
data
:
{
}
}
)
;
}
render
(
)
{
return
external_React_default
(
)
.
createElement
(
ModalOverlayWrapper
{
onClose
:
this
.
closeModal
innerClassName
:
"
ds
-
privacy
-
modal
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
privacy
-
notice
"
}
external_React_default
(
)
.
createElement
(
"
h3
"
{
"
data
-
l10n
-
id
"
:
"
newtab
-
privacy
-
modal
-
header
"
}
)
external_React_default
(
)
.
createElement
(
"
p
"
{
"
data
-
l10n
-
id
"
:
"
newtab
-
privacy
-
modal
-
paragraph
-
2
"
}
)
external_React_default
(
)
.
createElement
(
"
a
"
{
className
:
"
modal
-
link
modal
-
link
-
privacy
"
"
data
-
l10n
-
id
"
:
"
newtab
-
privacy
-
modal
-
link
"
onClick
:
this
.
onLearnLinkClick
href
:
"
https
:
/
/
support
.
mozilla
.
org
/
kb
/
pocket
-
recommendations
-
firefox
-
new
-
tab
"
}
)
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
"
modal
-
link
modal
-
link
-
manage
"
"
data
-
l10n
-
id
"
:
"
newtab
-
privacy
-
modal
-
button
-
manage
"
onClick
:
this
.
onManageLinkClick
}
)
)
external_React_default
(
)
.
createElement
(
"
section
"
{
className
:
"
actions
"
}
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
"
done
"
type
:
"
submit
"
onClick
:
this
.
closeModal
"
data
-
l10n
-
id
"
:
"
newtab
-
privacy
-
modal
-
button
-
done
"
}
)
)
)
;
}
}
;
const
ReportContent
=
spocs
=
>
{
const
dispatch
=
(
0
external_ReactRedux_namespaceObject
.
useDispatch
)
(
)
;
const
modal
=
(
0
external_React_namespaceObject
.
useRef
)
(
null
)
;
const
radioGroupRef
=
(
0
external_React_namespaceObject
.
useRef
)
(
null
)
;
const
submitButtonRef
=
(
0
external_React_namespaceObject
.
useRef
)
(
null
)
;
const
report
=
(
0
external_ReactRedux_namespaceObject
.
useSelector
)
(
state
=
>
state
.
DiscoveryStream
.
report
)
;
const
[
valueSelected
setValueSelected
]
=
(
0
external_React_namespaceObject
.
useState
)
(
false
)
;
const
[
selectedReason
setSelectedReason
]
=
(
0
external_React_namespaceObject
.
useState
)
(
null
)
;
const
spocData
=
spocs
.
spocs
.
data
;
const
handleCancel
=
(
)
=
>
{
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
REPORT_CLOSE
}
)
)
;
}
;
const
handleSubmit
=
(
0
external_React_namespaceObject
.
useCallback
)
(
(
)
=
>
{
const
{
card_type
corpus_item_id
position
reporting_url
scheduled_corpus_item_id
section_position
section
title
topic
url
}
=
report
;
if
(
card_type
=
=
=
"
organic
"
)
{
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
REPORT_CONTENT_SUBMIT
data
:
{
card_type
corpus_item_id
report_reason
:
selectedReason
scheduled_corpus_item_id
section_position
section
title
topic
url
}
}
)
)
;
}
else
if
(
card_type
=
=
=
"
spoc
"
)
{
const
getPlacementId
=
(
)
=
>
{
if
(
!
spocData
|
|
!
report
.
url
)
{
return
null
;
}
for
(
const
[
placementId
spocList
]
of
Object
.
entries
(
spocData
)
)
{
for
(
const
spoc
of
Object
.
values
(
spocList
)
)
{
if
(
spoc
?
.
url
=
=
=
report
.
url
)
{
return
placementId
;
}
}
}
return
null
;
}
;
const
placement_id
=
getPlacementId
(
)
;
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
REPORT_AD_SUBMIT
data
:
{
report_reason
:
selectedReason
placement_id
position
reporting_url
url
}
}
)
)
;
}
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
BLOCK_URL
data
:
[
{
.
.
.
report
}
]
}
)
)
;
dispatch
(
actionCreators
.
OnlyToOneContent
(
{
type
:
actionTypes
.
SHOW_TOAST_MESSAGE
data
:
{
toastId
:
"
reportSuccessToast
"
showNotifications
:
true
}
}
"
ActivityStream
:
Content
"
)
)
;
}
[
dispatch
selectedReason
report
spocData
]
)
;
(
0
external_React_namespaceObject
.
useEffect
)
(
(
)
=
>
{
if
(
report
.
visible
&
&
modal
?
.
current
)
{
modal
.
current
.
showModal
(
)
;
const
radioGroup
=
radioGroupRef
.
current
;
if
(
radioGroup
)
{
const
selectedRadioButton
=
radioGroup
.
querySelector
(
"
moz
-
radio
[
checked
]
"
)
;
if
(
selectedRadioButton
)
{
selectedRadioButton
.
removeAttribute
(
"
checked
"
)
;
}
}
setValueSelected
(
false
)
;
setSelectedReason
(
null
)
;
}
else
if
(
!
report
.
visible
&
&
modal
?
.
current
?
.
open
)
{
modal
.
current
.
close
(
)
;
}
}
[
report
.
visible
]
)
;
(
0
external_React_namespaceObject
.
useEffect
)
(
(
)
=
>
{
const
radioGroup
=
radioGroupRef
.
current
;
const
submitButton
=
submitButtonRef
.
current
;
const
handleRadioChange
=
e
=
>
{
const
reasonValue
=
e
?
.
target
?
.
value
;
if
(
reasonValue
)
{
setValueSelected
(
true
)
;
setSelectedReason
(
reasonValue
)
;
}
}
;
if
(
radioGroup
)
{
radioGroup
.
addEventListener
(
"
change
"
handleRadioChange
)
;
}
const
updateSubmitState
=
(
)
=
>
{
if
(
valueSelected
)
{
submitButton
.
removeAttribute
(
"
disabled
"
)
;
}
else
{
submitButton
.
setAttribute
(
"
disabled
"
"
"
)
;
}
}
;
updateSubmitState
(
)
;
return
(
)
=
>
{
if
(
radioGroup
)
{
radioGroup
.
removeEventListener
(
"
change
"
handleRadioChange
)
;
}
}
;
}
[
valueSelected
selectedReason
]
)
;
return
external_React_default
(
)
.
createElement
(
"
dialog
"
{
className
:
"
report
-
content
-
form
"
id
:
"
dialog
-
report
"
ref
:
modal
onClose
:
(
)
=
>
dispatch
(
{
type
:
actionTypes
.
REPORT_CLOSE
}
)
}
external_React_default
(
)
.
createElement
(
"
form
"
{
action
:
"
"
}
report
.
card_type
=
=
=
"
spoc
"
?
external_React_default
(
)
.
createElement
(
(
external_React_default
(
)
)
.
Fragment
null
external_React_default
(
)
.
createElement
(
"
moz
-
radio
-
group
"
{
name
:
"
report
"
ref
:
radioGroupRef
id
:
"
report
-
group
"
"
data
-
l10n
-
id
"
:
"
newtab
-
report
-
ads
-
why
-
reporting
"
className
:
"
report
-
ads
-
options
"
}
external_React_default
(
)
.
createElement
(
"
moz
-
radio
"
{
"
data
-
l10n
-
id
"
:
"
newtab
-
report
-
ads
-
reason
-
not
-
interested
"
value
:
"
not_interested
"
}
)
external_React_default
(
)
.
createElement
(
"
moz
-
radio
"
{
"
data
-
l10n
-
id
"
:
"
newtab
-
report
-
ads
-
reason
-
inappropriate
"
value
:
"
inappropriate
"
}
)
external_React_default
(
)
.
createElement
(
"
moz
-
radio
"
{
"
data
-
l10n
-
id
"
:
"
newtab
-
report
-
ads
-
reason
-
seen
-
it
-
too
-
many
-
times
"
value
:
"
seen_too_many_times
"
}
)
)
)
:
external_React_default
(
)
.
createElement
(
(
external_React_default
(
)
)
.
Fragment
null
external_React_default
(
)
.
createElement
(
"
moz
-
radio
-
group
"
{
name
:
"
report
"
ref
:
radioGroupRef
id
:
"
report
-
group
"
"
data
-
l10n
-
id
"
:
"
newtab
-
report
-
content
-
why
-
reporting
-
this
"
className
:
"
report
-
content
-
options
"
}
external_React_default
(
)
.
createElement
(
"
moz
-
radio
"
{
"
data
-
l10n
-
id
"
:
"
newtab
-
report
-
content
-
wrong
-
category
"
value
:
"
wrong_category
"
}
)
external_React_default
(
)
.
createElement
(
"
moz
-
radio
"
{
"
data
-
l10n
-
id
"
:
"
newtab
-
report
-
content
-
outdated
"
value
:
"
outdated
"
}
)
external_React_default
(
)
.
createElement
(
"
moz
-
radio
"
{
"
data
-
l10n
-
id
"
:
"
newtab
-
report
-
content
-
inappropriate
-
offensive
"
value
:
"
inappropriate_or_offensive
"
}
)
external_React_default
(
)
.
createElement
(
"
moz
-
radio
"
{
"
data
-
l10n
-
id
"
:
"
newtab
-
report
-
content
-
spam
-
misleading
"
value
:
"
spam_or_misleading
"
}
)
)
)
external_React_default
(
)
.
createElement
(
"
moz
-
button
-
group
"
null
external_React_default
(
)
.
createElement
(
"
moz
-
button
"
{
"
data
-
l10n
-
id
"
:
"
newtab
-
report
-
cancel
"
onClick
:
handleCancel
className
:
"
cancel
-
report
-
btn
"
}
)
external_React_default
(
)
.
createElement
(
"
moz
-
button
"
{
type
:
"
primary
"
"
data
-
l10n
-
id
"
:
"
newtab
-
report
-
submit
"
ref
:
submitButtonRef
onClick
:
handleSubmit
className
:
"
submit
-
report
-
btn
"
}
)
)
)
)
;
}
;
;
class
DSSignup
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
state
=
{
active
:
false
lastItem
:
false
}
;
this
.
onMenuButtonUpdate
=
this
.
onMenuButtonUpdate
.
bind
(
this
)
;
this
.
onLinkClick
=
this
.
onLinkClick
.
bind
(
this
)
;
this
.
onMenuShow
=
this
.
onMenuShow
.
bind
(
this
)
;
}
onMenuButtonUpdate
(
showContextMenu
)
{
if
(
!
showContextMenu
)
{
this
.
setState
(
{
active
:
false
lastItem
:
false
}
)
;
}
}
nextAnimationFrame
(
)
{
return
new
Promise
(
resolve
=
>
this
.
props
.
windowObj
.
requestAnimationFrame
(
resolve
)
)
;
}
async
onMenuShow
(
)
{
let
{
lastItem
}
=
this
.
state
;
await
this
.
nextAnimationFrame
(
)
;
if
(
this
.
props
.
windowObj
.
scrollMaxX
>
0
)
{
lastItem
=
true
;
}
this
.
setState
(
{
active
:
true
lastItem
}
)
;
}
onLinkClick
(
)
{
const
{
data
}
=
this
.
props
;
if
(
this
.
props
.
dispatch
&
&
data
&
&
data
.
spocs
&
&
data
.
spocs
.
length
)
{
const
source
=
this
.
props
.
type
.
toUpperCase
(
)
;
const
[
spoc
]
=
data
.
spocs
;
this
.
props
.
dispatch
(
actionCreators
.
DiscoveryStreamUserEvent
(
{
event
:
"
CLICK
"
source
action_position
:
0
}
)
)
;
this
.
props
.
dispatch
(
actionCreators
.
ImpressionStats
(
{
source
click
:
0
tiles
:
[
{
id
:
spoc
.
id
pos
:
0
.
.
.
(
spoc
.
shim
&
&
spoc
.
shim
.
click
?
{
shim
:
spoc
.
shim
.
click
}
:
{
}
)
}
]
}
)
)
;
}
}
render
(
)
{
const
{
data
dispatch
type
}
=
this
.
props
;
if
(
!
data
|
|
!
data
.
spocs
|
|
!
data
.
spocs
[
0
]
)
{
return
null
;
}
const
[
spoc
]
=
data
.
spocs
;
const
{
title
url
excerpt
flight_id
id
shim
}
=
spoc
;
const
SIGNUP_CONTEXT_MENU_OPTIONS
=
[
"
OpenInNewWindow
"
"
OpenInPrivateWindow
"
"
Separator
"
"
BlockUrl
"
.
.
.
(
flight_id
?
[
"
ShowPrivacyInfo
"
]
:
[
]
)
]
;
const
outerClassName
=
[
"
ds
-
signup
"
this
.
state
.
active
&
&
"
active
"
this
.
state
.
lastItem
&
&
"
last
-
item
"
]
.
filter
(
v
=
>
v
)
.
join
(
"
"
)
;
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
outerClassName
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
ds
-
signup
-
content
"
}
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
icon
icon
-
small
-
spacer
icon
-
mail
"
}
)
external_React_default
(
)
.
createElement
(
"
span
"
null
title
"
"
external_React_default
(
)
.
createElement
(
SafeAnchor
{
className
:
"
ds
-
chevron
-
link
"
dispatch
:
dispatch
onLinkClick
:
this
.
onLinkClick
url
:
url
}
excerpt
)
)
external_React_default
(
)
.
createElement
(
ImpressionStats_ImpressionStats
{
flightId
:
flight_id
rows
:
[
{
id
pos
:
0
shim
:
shim
&
&
shim
.
impression
}
]
dispatch
:
dispatch
source
:
type
}
)
)
external_React_default
(
)
.
createElement
(
ContextMenuButton
{
tooltip
:
"
newtab
-
menu
-
content
-
tooltip
"
tooltipArgs
:
{
title
}
onUpdate
:
this
.
onMenuButtonUpdate
}
external_React_default
(
)
.
createElement
(
LinkMenu
{
dispatch
:
dispatch
index
:
0
source
:
type
.
toUpperCase
(
)
onShow
:
this
.
onMenuShow
options
:
SIGNUP_CONTEXT_MENU_OPTIONS
shouldSendImpressionStats
:
true
userEvent
:
actionCreators
.
DiscoveryStreamUserEvent
site
:
{
referrer
:
"
https
:
/
/
getpocket
.
com
/
recommendations
"
title
type
url
guid
:
id
shim
flight_id
}
}
)
)
)
;
}
}
DSSignup
.
defaultProps
=
{
windowObj
:
window
}
;
;
class
DSTextPromo
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
onLinkClick
=
this
.
onLinkClick
.
bind
(
this
)
;
this
.
onDismissClick
=
this
.
onDismissClick
.
bind
(
this
)
;
}
onLinkClick
(
)
{
const
{
data
}
=
this
.
props
;
if
(
this
.
props
.
dispatch
&
&
data
&
&
data
.
spocs
&
&
data
.
spocs
.
length
)
{
const
source
=
this
.
props
.
type
.
toUpperCase
(
)
;
const
[
spoc
]
=
data
.
spocs
;
this
.
props
.
dispatch
(
actionCreators
.
DiscoveryStreamUserEvent
(
{
event
:
"
CLICK
"
source
action_position
:
0
}
)
)
;
this
.
props
.
dispatch
(
actionCreators
.
ImpressionStats
(
{
source
click
:
0
tiles
:
[
{
id
:
spoc
.
id
pos
:
0
.
.
.
(
spoc
.
shim
&
&
spoc
.
shim
.
click
?
{
shim
:
spoc
.
shim
.
click
}
:
{
}
)
}
]
}
)
)
;
}
}
onDismissClick
(
)
{
const
{
data
}
=
this
.
props
;
if
(
this
.
props
.
dispatch
&
&
data
&
&
data
.
spocs
&
&
data
.
spocs
.
length
)
{
const
index
=
0
;
const
source
=
this
.
props
.
type
.
toUpperCase
(
)
;
const
[
spoc
]
=
data
.
spocs
;
const
spocData
=
{
url
:
spoc
.
url
guid
:
spoc
.
id
shim
:
spoc
.
shim
}
;
const
blockUrlOption
=
LinkMenuOptions
.
BlockUrl
(
spocData
index
source
)
;
const
{
action
impression
userEvent
}
=
blockUrlOption
;
this
.
props
.
dispatch
(
action
)
;
this
.
props
.
dispatch
(
actionCreators
.
DiscoveryStreamUserEvent
(
{
event
:
userEvent
source
action_position
:
index
}
)
)
;
if
(
impression
)
{
this
.
props
.
dispatch
(
impression
)
;
}
}
}
render
(
)
{
const
{
data
}
=
this
.
props
;
if
(
!
data
|
|
!
data
.
spocs
|
|
!
data
.
spocs
[
0
]
)
{
return
null
;
}
const
[
spoc
]
=
data
.
spocs
;
const
{
image_src
raw_image_src
alt_text
title
url
context
cta
flight_id
id
shim
}
=
spoc
;
return
external_React_default
(
)
.
createElement
(
DSDismiss
{
onDismissClick
:
this
.
onDismissClick
extraClasses
:
ds
-
dismiss
-
ds
-
text
-
promo
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
ds
-
text
-
promo
"
}
external_React_default
(
)
.
createElement
(
DSImage
{
alt_text
:
alt_text
source
:
image_src
rawSource
:
raw_image_src
}
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
text
"
}
external_React_default
(
)
.
createElement
(
"
h3
"
null
{
title
}
\
u2003
external_React_default
(
)
.
createElement
(
SafeAnchor
{
className
:
"
ds
-
chevron
-
link
"
dispatch
:
this
.
props
.
dispatch
onLinkClick
:
this
.
onLinkClick
url
:
url
}
cta
)
)
external_React_default
(
)
.
createElement
(
"
p
"
{
className
:
"
subtitle
"
}
context
)
)
external_React_default
(
)
.
createElement
(
ImpressionStats_ImpressionStats
{
flightId
:
flight_id
rows
:
[
{
id
pos
:
0
shim
:
shim
&
&
shim
.
impression
}
]
dispatch
:
this
.
props
.
dispatch
source
:
this
.
props
.
type
}
)
)
)
;
}
}
;
const
ScreenshotUtils
=
{
isBlob
(
isLocal
image
)
{
return
!
!
(
image
&
&
image
.
path
&
&
(
(
!
isLocal
&
&
image
.
data
)
|
|
(
isLocal
&
&
image
.
url
)
)
)
;
}
createLocalImageObject
(
remoteImage
)
{
if
(
!
remoteImage
)
{
return
null
;
}
if
(
this
.
isBlob
(
false
remoteImage
)
)
{
return
{
url
:
globalThis
.
URL
.
createObjectURL
(
remoteImage
.
data
)
path
:
remoteImage
.
path
}
;
}
return
{
url
:
remoteImage
}
;
}
maybeRevokeBlobObjectURL
(
localImage
)
{
if
(
this
.
isBlob
(
true
localImage
)
)
{
globalThis
.
URL
.
revokeObjectURL
(
localImage
.
url
)
;
}
}
isRemoteImageLocal
(
localImage
remoteImage
)
{
if
(
remoteImage
&
&
localImage
)
{
return
this
.
isBlob
(
false
remoteImage
)
?
localImage
.
path
=
=
=
remoteImage
.
path
:
localImage
.
url
=
=
=
remoteImage
;
}
return
!
remoteImage
&
&
!
localImage
;
}
}
;
;
const
gImageLoading
=
new
Map
(
)
;
class
_Card
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
state
=
{
activeCard
:
null
imageLoaded
:
false
cardImage
:
null
}
;
this
.
onMenuButtonUpdate
=
this
.
onMenuButtonUpdate
.
bind
(
this
)
;
this
.
onLinkClick
=
this
.
onLinkClick
.
bind
(
this
)
;
}
async
maybeLoadImage
(
)
{
const
{
cardImage
}
=
this
.
state
;
if
(
!
cardImage
)
{
return
;
}
const
imageUrl
=
cardImage
.
url
;
if
(
!
this
.
state
.
imageLoaded
)
{
if
(
!
gImageLoading
.
has
(
imageUrl
)
)
{
const
loaderPromise
=
new
Promise
(
(
resolve
reject
)
=
>
{
const
loader
=
new
Image
(
)
;
loader
.
addEventListener
(
"
load
"
resolve
)
;
loader
.
addEventListener
(
"
error
"
reject
)
;
loader
.
src
=
imageUrl
;
}
)
;
gImageLoading
.
set
(
imageUrl
loaderPromise
)
;
loaderPromise
.
catch
(
ex
=
>
ex
)
.
then
(
(
)
=
>
gImageLoading
.
delete
(
imageUrl
)
)
;
}
try
{
await
gImageLoading
.
get
(
imageUrl
)
;
}
catch
(
ex
)
{
return
;
}
if
(
ScreenshotUtils
.
isRemoteImageLocal
(
this
.
state
.
cardImage
this
.
props
.
link
.
image
)
&
&
!
this
.
state
.
imageLoaded
)
{
this
.
setState
(
{
imageLoaded
:
true
}
)
;
}
}
}
static
getNextStateFromProps
(
nextProps
prevState
)
{
const
{
image
}
=
nextProps
.
link
;
const
imageInState
=
ScreenshotUtils
.
isRemoteImageLocal
(
prevState
.
cardImage
image
)
;
let
nextState
=
null
;
if
(
!
imageInState
&
&
nextProps
.
link
)
{
nextState
=
{
imageLoaded
:
false
}
;
}
if
(
imageInState
)
{
return
nextState
;
}
ScreenshotUtils
.
maybeRevokeBlobObjectURL
(
prevState
.
cardImage
)
;
nextState
=
nextState
|
|
{
}
;
nextState
.
cardImage
=
ScreenshotUtils
.
createLocalImageObject
(
image
)
;
return
nextState
;
}
onMenuButtonUpdate
(
isOpen
)
{
if
(
isOpen
)
{
this
.
setState
(
{
activeCard
:
this
.
props
.
index
}
)
;
}
else
{
this
.
setState
(
{
activeCard
:
null
}
)
;
}
}
_getTelemetryInfo
(
)
{
if
(
this
.
props
.
link
.
type
!
=
=
"
history
"
)
{
return
{
value
:
{
card_type
:
this
.
props
.
link
.
type
}
}
;
}
return
null
;
}
onLinkClick
(
event
)
{
event
.
preventDefault
(
)
;
const
{
altKey
button
ctrlKey
metaKey
shiftKey
}
=
event
;
if
(
this
.
props
.
link
.
type
=
=
=
"
download
"
)
{
this
.
props
.
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
OPEN_DOWNLOAD_FILE
data
:
Object
.
assign
(
this
.
props
.
link
{
event
:
{
button
ctrlKey
metaKey
shiftKey
}
}
)
}
)
)
;
}
else
{
this
.
props
.
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
OPEN_LINK
data
:
Object
.
assign
(
this
.
props
.
link
{
event
:
{
altKey
button
ctrlKey
metaKey
shiftKey
}
}
)
}
)
)
;
}
if
(
this
.
props
.
isWebExtension
)
{
this
.
props
.
dispatch
(
actionCreators
.
WebExtEvent
(
actionTypes
.
WEBEXT_CLICK
{
source
:
this
.
props
.
eventSource
url
:
this
.
props
.
link
.
url
action_position
:
this
.
props
.
index
}
)
)
;
}
else
{
this
.
props
.
dispatch
(
actionCreators
.
UserEvent
(
Object
.
assign
(
{
event
:
"
CLICK
"
source
:
this
.
props
.
eventSource
action_position
:
this
.
props
.
index
}
this
.
_getTelemetryInfo
(
)
)
)
)
;
if
(
this
.
props
.
shouldSendImpressionStats
)
{
this
.
props
.
dispatch
(
actionCreators
.
ImpressionStats
(
{
source
:
this
.
props
.
eventSource
click
:
0
tiles
:
[
{
id
:
this
.
props
.
link
.
guid
pos
:
this
.
props
.
index
}
]
}
)
)
;
}
}
}
componentDidMount
(
)
{
this
.
maybeLoadImage
(
)
;
}
componentDidUpdate
(
)
{
this
.
maybeLoadImage
(
)
;
}
componentWillMount
(
)
{
const
nextState
=
_Card
.
getNextStateFromProps
(
this
.
props
this
.
state
)
;
if
(
nextState
)
{
this
.
setState
(
nextState
)
;
}
}
componentWillReceiveProps
(
nextProps
)
{
const
nextState
=
_Card
.
getNextStateFromProps
(
nextProps
this
.
state
)
;
if
(
nextState
)
{
this
.
setState
(
nextState
)
;
}
}
componentWillUnmount
(
)
{
ScreenshotUtils
.
maybeRevokeBlobObjectURL
(
this
.
state
.
cardImage
)
;
}
render
(
)
{
const
{
index
className
link
dispatch
contextMenuOptions
eventSource
shouldSendImpressionStats
}
=
this
.
props
;
const
{
props
}
=
this
;
const
title
=
link
.
title
|
|
link
.
hostname
;
const
isContextMenuOpen
=
this
.
state
.
activeCard
=
=
=
index
;
const
{
icon
fluentID
}
=
cardContextTypes
[
link
.
type
=
=
=
"
now
"
?
"
trending
"
:
link
.
type
]
|
|
{
}
;
const
hasImage
=
this
.
state
.
cardImage
|
|
link
.
hasImage
;
const
imageStyle
=
{
backgroundImage
:
this
.
state
.
cardImage
?
url
(
{
this
.
state
.
cardImage
.
url
}
)
:
"
none
"
}
;
const
outerClassName
=
[
"
card
-
outer
"
className
isContextMenuOpen
&
&
"
active
"
props
.
placeholder
&
&
"
placeholder
"
]
.
filter
(
v
=
>
v
)
.
join
(
"
"
)
;
return
external_React_default
(
)
.
createElement
(
"
li
"
{
className
:
outerClassName
}
external_React_default
(
)
.
createElement
(
"
a
"
{
href
:
link
.
type
=
=
=
"
pocket
"
?
link
.
open_url
:
link
.
url
onClick
:
!
props
.
placeholder
?
this
.
onLinkClick
:
undefined
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
card
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
card
-
preview
-
image
-
outer
"
}
hasImage
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
card
-
preview
-
image
{
this
.
state
.
imageLoaded
?
"
loaded
"
:
"
"
}
style
:
imageStyle
}
)
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
card
-
details
"
}
link
.
type
=
=
=
"
download
"
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
card
-
host
-
name
alternate
"
"
data
-
l10n
-
id
"
:
"
newtab
-
menu
-
open
-
file
"
}
)
link
.
hostname
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
card
-
host
-
name
"
}
link
.
hostname
.
slice
(
0
100
)
link
.
type
=
=
=
"
download
"
&
&
\
u2014
{
link
.
description
}
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
[
"
card
-
text
"
icon
?
"
"
:
"
no
-
context
"
link
.
description
?
"
"
:
"
no
-
description
"
link
.
hostname
?
"
"
:
"
no
-
host
-
name
"
]
.
join
(
"
"
)
}
external_React_default
(
)
.
createElement
(
"
h4
"
{
className
:
"
card
-
title
"
dir
:
"
auto
"
}
link
.
title
)
external_React_default
(
)
.
createElement
(
"
p
"
{
className
:
"
card
-
description
"
dir
:
"
auto
"
}
link
.
description
)
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
card
-
context
"
}
icon
&
&
!
link
.
context
&
&
external_React_default
(
)
.
createElement
(
"
span
"
{
"
aria
-
haspopup
"
:
"
true
"
className
:
card
-
context
-
icon
icon
icon
-
{
icon
}
}
)
link
.
icon
&
&
link
.
context
&
&
external_React_default
(
)
.
createElement
(
"
span
"
{
"
aria
-
haspopup
"
:
"
true
"
className
:
"
card
-
context
-
icon
icon
"
style
:
{
backgroundImage
:
url
(
'
{
link
.
icon
}
'
)
}
}
)
fluentID
&
&
!
link
.
context
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
card
-
context
-
label
"
"
data
-
l10n
-
id
"
:
fluentID
}
)
link
.
context
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
card
-
context
-
label
"
}
link
.
context
)
)
)
)
)
!
props
.
placeholder
&
&
external_React_default
(
)
.
createElement
(
ContextMenuButton
{
tooltip
:
"
newtab
-
menu
-
content
-
tooltip
"
tooltipArgs
:
{
title
}
onUpdate
:
this
.
onMenuButtonUpdate
}
external_React_default
(
)
.
createElement
(
LinkMenu
{
dispatch
:
dispatch
index
:
index
source
:
eventSource
options
:
link
.
contextMenuOptions
|
|
contextMenuOptions
site
:
link
siteInfo
:
this
.
_getTelemetryInfo
(
)
shouldSendImpressionStats
:
shouldSendImpressionStats
}
)
)
)
;
}
}
_Card
.
defaultProps
=
{
link
:
{
}
}
;
const
Card
=
(
0
external_ReactRedux_namespaceObject
.
connect
)
(
state
=
>
(
{
platform
:
state
.
Prefs
.
values
.
platform
}
)
)
(
_Card
)
;
const
PlaceholderCard
=
props
=
>
external_React_default
(
)
.
createElement
(
Card
{
placeholder
:
true
className
:
props
.
className
}
)
;
;
let
usablePerfObj
=
window
.
performance
;
function
_PerfService
(
options
)
{
if
(
options
&
&
options
.
performanceObj
)
{
this
.
_perf
=
options
.
performanceObj
;
}
else
{
this
.
_perf
=
usablePerfObj
;
}
}
_PerfService
.
prototype
=
{
mark
:
function
mark
(
str
)
{
this
.
_perf
.
mark
(
str
)
;
}
getEntriesByName
:
function
getEntriesByName
(
entryName
type
)
{
return
this
.
_perf
.
getEntriesByName
(
entryName
type
)
;
}
get
timeOrigin
(
)
{
return
this
.
_perf
.
timeOrigin
;
}
absNow
:
function
absNow
(
)
{
return
this
.
timeOrigin
+
this
.
_perf
.
now
(
)
;
}
getMostRecentAbsMarkStartByName
(
entryName
)
{
let
entries
=
this
.
getEntriesByName
(
entryName
"
mark
"
)
;
if
(
!
entries
.
length
)
{
throw
new
Error
(
No
marks
with
the
name
{
entryName
}
)
;
}
let
mostRecentEntry
=
entries
[
entries
.
length
-
1
]
;
return
this
.
_perf
.
timeOrigin
+
mostRecentEntry
.
startTime
;
}
}
;
const
perfService
=
new
_PerfService
(
)
;
;
const
RECORDED_SECTIONS
=
[
"
highlights
"
"
topsites
"
]
;
class
ComponentPerfTimer
extends
(
external_React_default
(
)
)
.
Component
{
constructor
(
props
)
{
super
(
props
)
;
this
.
perfSvc
=
this
.
props
.
perfSvc
|
|
perfService
;
this
.
_sendBadStateEvent
=
this
.
_sendBadStateEvent
.
bind
(
this
)
;
this
.
_sendPaintedEvent
=
this
.
_sendPaintedEvent
.
bind
(
this
)
;
this
.
_reportMissingData
=
false
;
this
.
_timestampHandled
=
false
;
this
.
_recordedFirstRender
=
false
;
}
componentDidMount
(
)
{
if
(
!
RECORDED_SECTIONS
.
includes
(
this
.
props
.
id
)
)
{
return
;
}
this
.
_maybeSendPaintedEvent
(
)
;
}
componentDidUpdate
(
)
{
if
(
!
RECORDED_SECTIONS
.
includes
(
this
.
props
.
id
)
)
{
return
;
}
this
.
_maybeSendPaintedEvent
(
)
;
}
_afterFramePaint
(
callback
)
{
requestAnimationFrame
(
(
)
=
>
setTimeout
(
callback
0
)
)
;
}
_maybeSendBadStateEvent
(
)
{
if
(
!
this
.
props
.
initialized
)
{
this
.
_reportMissingData
=
true
;
}
else
if
(
this
.
_reportMissingData
)
{
this
.
_reportMissingData
=
false
;
this
.
_sendBadStateEvent
(
)
;
}
}
_maybeSendPaintedEvent
(
)
{
if
(
this
.
_timestampHandled
|
|
!
this
.
props
.
initialized
)
{
return
;
}
this
.
_timestampHandled
=
true
;
this
.
_afterFramePaint
(
this
.
_sendPaintedEvent
)
;
}
_ensureFirstRenderTsRecorded
(
)
{
if
(
!
this
.
_recordedFirstRender
)
{
this
.
_recordedFirstRender
=
true
;
const
key
=
{
this
.
props
.
id
}
_first_render_ts
;
this
.
perfSvc
.
mark
(
key
)
;
}
}
_sendBadStateEvent
(
)
{
const
dataReadyKey
=
{
this
.
props
.
id
}
_data_ready_ts
;
this
.
perfSvc
.
mark
(
dataReadyKey
)
;
try
{
const
firstRenderKey
=
{
this
.
props
.
id
}
_first_render_ts
;
const
value
=
parseInt
(
this
.
perfSvc
.
getMostRecentAbsMarkStartByName
(
dataReadyKey
)
-
this
.
perfSvc
.
getMostRecentAbsMarkStartByName
(
firstRenderKey
)
10
)
;
this
.
props
.
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
SAVE_SESSION_PERF_DATA
data
:
{
[
{
this
.
props
.
id
}
_data_late_by_ms
]
:
value
}
}
)
)
;
}
catch
(
ex
)
{
}
}
_sendPaintedEvent
(
)
{
if
(
this
.
props
.
id
!
=
=
"
topsites
"
)
{
return
;
}
const
key
=
{
this
.
props
.
id
}
_first_painted_ts
;
this
.
perfSvc
.
mark
(
key
)
;
try
{
const
data
=
{
}
;
data
[
key
]
=
this
.
perfSvc
.
getMostRecentAbsMarkStartByName
(
key
)
;
this
.
props
.
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
SAVE_SESSION_PERF_DATA
data
}
)
)
;
}
catch
(
ex
)
{
}
}
render
(
)
{
if
(
RECORDED_SECTIONS
.
includes
(
this
.
props
.
id
)
)
{
this
.
_ensureFirstRenderTsRecorded
(
)
;
this
.
_maybeSendBadStateEvent
(
)
;
}
return
this
.
props
.
children
;
}
}
;
class
MoreRecommendations
extends
(
external_React_default
(
)
)
.
PureComponent
{
render
(
)
{
const
{
read_more_endpoint
}
=
this
.
props
;
if
(
read_more_endpoint
)
{
return
external_React_default
(
)
.
createElement
(
"
a
"
{
className
:
"
more
-
recommendations
"
href
:
read_more_endpoint
"
data
-
l10n
-
id
"
:
"
newtab
-
pocket
-
more
-
recommendations
"
}
)
;
}
return
null
;
}
}
;
class
SelectableSearchShortcut
extends
(
external_React_default
(
)
)
.
PureComponent
{
render
(
)
{
const
{
shortcut
selected
}
=
this
.
props
;
const
imageStyle
=
{
backgroundImage
:
url
(
"
{
shortcut
.
tippyTopIcon
}
"
)
}
;
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
top
-
site
-
outer
search
-
shortcut
"
}
external_React_default
(
)
.
createElement
(
"
input
"
{
type
:
"
checkbox
"
id
:
shortcut
.
keyword
name
:
shortcut
.
keyword
checked
:
selected
onChange
:
this
.
props
.
onChange
}
)
external_React_default
(
)
.
createElement
(
"
label
"
{
htmlFor
:
shortcut
.
keyword
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
top
-
site
-
inner
"
}
external_React_default
(
)
.
createElement
(
"
span
"
null
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
tile
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
top
-
site
-
icon
rich
-
icon
"
style
:
imageStyle
"
data
-
fallback
"
:
"
"
}
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
top
-
site
-
icon
search
-
topsite
"
}
)
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
title
"
}
external_React_default
(
)
.
createElement
(
"
span
"
{
dir
:
"
auto
"
}
shortcut
.
keyword
)
)
)
)
)
)
;
}
}
class
SearchShortcutsForm
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
handleChange
=
this
.
handleChange
.
bind
(
this
)
;
this
.
onCancelButtonClick
=
this
.
onCancelButtonClick
.
bind
(
this
)
;
this
.
onSaveButtonClick
=
this
.
onSaveButtonClick
.
bind
(
this
)
;
const
shortcuts
=
[
]
;
const
{
rows
searchShortcuts
}
=
props
.
TopSites
;
searchShortcuts
.
forEach
(
shortcut
=
>
{
shortcuts
.
push
(
{
.
.
.
shortcut
isSelected
:
!
!
rows
.
find
(
row
=
>
row
&
&
row
.
isPinned
&
&
row
.
searchTopSite
&
&
row
.
label
=
=
=
shortcut
.
keyword
)
}
)
;
}
)
;
this
.
state
=
{
shortcuts
}
;
}
handleChange
(
event
)
{
const
{
target
}
=
event
;
const
{
name
:
targetName
checked
}
=
target
;
this
.
setState
(
prevState
=
>
{
const
shortcuts
=
prevState
.
shortcuts
.
slice
(
)
;
let
shortcut
=
shortcuts
.
find
(
(
{
keyword
}
)
=
>
keyword
=
=
=
targetName
)
;
shortcut
.
isSelected
=
checked
;
return
{
shortcuts
}
;
}
)
;
}
onCancelButtonClick
(
ev
)
{
ev
.
preventDefault
(
)
;
this
.
props
.
onClose
(
)
;
}
onSaveButtonClick
(
ev
)
{
ev
.
preventDefault
(
)
;
const
{
rows
}
=
this
.
props
.
TopSites
;
const
pinQueue
=
[
]
;
const
unpinQueue
=
[
]
;
this
.
state
.
shortcuts
.
forEach
(
shortcut
=
>
{
const
alreadyPinned
=
rows
.
find
(
row
=
>
row
&
&
row
.
isPinned
&
&
row
.
searchTopSite
&
&
row
.
label
=
=
=
shortcut
.
keyword
)
;
if
(
shortcut
.
isSelected
&
&
!
alreadyPinned
)
{
pinQueue
.
push
(
this
.
_searchTopSite
(
shortcut
)
)
;
}
else
if
(
!
shortcut
.
isSelected
&
&
alreadyPinned
)
{
unpinQueue
.
push
(
{
url
:
alreadyPinned
.
url
searchVendor
:
shortcut
.
shortURL
}
)
;
}
}
)
;
this
.
props
.
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
UPDATE_PINNED_SEARCH_SHORTCUTS
data
:
{
addedShortcuts
:
pinQueue
deletedShortcuts
:
unpinQueue
}
}
)
)
;
pinQueue
.
forEach
(
shortcut
=
>
{
this
.
props
.
dispatch
(
actionCreators
.
UserEvent
(
{
source
:
TOP_SITES_SOURCE
event
:
"
SEARCH_EDIT_ADD
"
value
:
{
search_vendor
:
shortcut
.
searchVendor
}
}
)
)
;
}
)
;
unpinQueue
.
forEach
(
shortcut
=
>
{
this
.
props
.
dispatch
(
actionCreators
.
UserEvent
(
{
source
:
TOP_SITES_SOURCE
event
:
"
SEARCH_EDIT_DELETE
"
value
:
{
search_vendor
:
shortcut
.
searchVendor
}
}
)
)
;
}
)
;
this
.
props
.
onClose
(
)
;
}
_searchTopSite
(
shortcut
)
{
return
{
url
:
shortcut
.
url
searchTopSite
:
true
label
:
shortcut
.
keyword
searchVendor
:
shortcut
.
shortURL
}
;
}
render
(
)
{
return
external_React_default
(
)
.
createElement
(
"
form
"
{
className
:
"
topsite
-
form
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
search
-
shortcuts
-
container
"
}
external_React_default
(
)
.
createElement
(
"
h3
"
{
className
:
"
section
-
title
grey
-
title
"
"
data
-
l10n
-
id
"
:
"
newtab
-
topsites
-
add
-
search
-
engine
-
header
"
}
)
external_React_default
(
)
.
createElement
(
"
div
"
null
this
.
state
.
shortcuts
.
map
(
shortcut
=
>
external_React_default
(
)
.
createElement
(
SelectableSearchShortcut
{
key
:
shortcut
.
keyword
shortcut
:
shortcut
selected
:
shortcut
.
isSelected
onChange
:
this
.
handleChange
}
)
)
)
)
external_React_default
(
)
.
createElement
(
"
section
"
{
className
:
"
actions
"
}
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
"
cancel
"
type
:
"
button
"
onClick
:
this
.
onCancelButtonClick
"
data
-
l10n
-
id
"
:
"
newtab
-
topsites
-
cancel
-
button
"
}
)
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
"
done
"
type
:
"
submit
"
onClick
:
this
.
onSaveButtonClick
"
data
-
l10n
-
id
"
:
"
newtab
-
topsites
-
save
-
button
"
}
)
)
)
;
}
}
;
class
Dedupe
{
constructor
(
createKey
)
{
this
.
createKey
=
createKey
|
|
this
.
defaultCreateKey
;
}
defaultCreateKey
(
item
)
{
return
item
;
}
group
(
.
.
.
groups
)
{
const
globalKeys
=
new
Set
(
)
;
const
result
=
[
]
;
for
(
const
values
of
groups
)
{
const
valueMap
=
new
Map
(
)
;
for
(
const
value
of
values
)
{
const
key
=
this
.
createKey
(
value
)
;
if
(
!
globalKeys
.
has
(
key
)
&
&
!
valueMap
.
has
(
key
)
)
{
valueMap
.
set
(
key
value
)
;
}
}
result
.
push
(
valueMap
)
;
valueMap
.
forEach
(
(
value
key
)
=
>
globalKeys
.
add
(
key
)
)
;
}
return
result
.
map
(
m
=
>
Array
.
from
(
m
.
values
(
)
)
)
;
}
}
;
const
TOP_SITES_DEFAULT_ROWS
=
1
;
const
TOP_SITES_MAX_SITES_PER_ROW
=
8
;
;
const
PREF_COLLECTION_DISMISSIBLE
=
"
discoverystream
.
isCollectionDismissible
"
;
const
dedupe
=
new
Dedupe
(
site
=
>
site
&
&
site
.
url
)
;
const
INITIAL_STATE
=
{
App
:
{
initialized
:
false
locale
:
"
"
isForStartupCache
:
{
App
:
false
TopSites
:
false
DiscoveryStream
:
false
Weather
:
false
Wallpaper
:
false
}
customizeMenuVisible
:
false
}
Ads
:
{
initialized
:
false
lastUpdated
:
null
tiles
:
{
}
spocs
:
{
}
spocPlacements
:
{
}
}
TopSites
:
{
initialized
:
false
rows
:
[
]
editForm
:
null
showSearchShortcutsForm
:
false
searchShortcuts
:
[
]
sov
:
{
ready
:
false
positions
:
[
]
}
}
Prefs
:
{
initialized
:
false
values
:
{
featureConfig
:
{
}
}
}
Dialog
:
{
visible
:
false
data
:
{
}
}
Sections
:
[
]
Pocket
:
{
isUserLoggedIn
:
null
pocketCta
:
{
}
waitingForSpoc
:
true
}
DiscoveryStream
:
{
config
:
{
enabled
:
false
}
layout
:
[
]
isPrivacyInfoModalVisible
:
false
isCollectionDismissible
:
false
topicsLoading
:
false
feeds
:
{
data
:
{
}
loaded
:
false
}
impressions
:
{
feed
:
{
}
}
blocks
:
{
}
spocs
:
{
spocs_endpoint
:
"
"
lastUpdated
:
null
data
:
{
}
loaded
:
false
frequency_caps
:
[
]
blocked
:
[
]
placements
:
[
]
}
experimentData
:
{
utmSource
:
"
pocket
-
newtab
"
utmCampaign
:
undefined
utmContent
:
undefined
}
recentSavesData
:
[
]
isUserLoggedIn
:
false
recentSavesEnabled
:
false
showTopicSelection
:
false
report
:
{
visible
:
false
data
:
{
}
}
sectionPersonalization
:
{
}
}
Messages
:
{
isVisible
:
true
portID
:
"
"
messageData
:
{
}
}
Notifications
:
{
showNotifications
:
false
toastCounter
:
0
toastId
:
"
"
toastQueue
:
[
]
}
Personalization
:
{
lastUpdated
:
null
initialized
:
false
}
InferredPersonalization
:
{
initialized
:
false
lastUpdated
:
null
inferredIntrests
:
{
}
coarseInferredInterests
:
{
}
coarsePrivateInferredInterests
:
{
}
}
Search
:
{
fakeFocus
:
false
hide
:
false
}
Wallpapers
:
{
wallpaperList
:
[
]
highlightSeenCounter
:
0
categories
:
[
]
uploadedWallpaper
:
"
"
}
Weather
:
{
initialized
:
false
lastUpdated
:
null
query
:
"
"
suggestions
:
[
]
locationData
:
{
city
:
"
"
adminArea
:
"
"
country
:
"
"
}
searchActive
:
false
locationSearchString
:
"
"
suggestedLocations
:
[
]
}
TrendingSearch
:
{
suggestions
:
[
]
collapsed
:
false
}
ListsWidget
:
{
selected
:
"
taskList
"
lists
:
{
taskList
:
{
label
:
"
Task
List
"
tasks
:
[
]
completed
:
[
]
}
}
}
TimerWidget
:
{
timerType
:
"
focus
"
focus
:
{
duration
:
25
*
60
initialDuration
:
25
*
60
startTime
:
null
isRunning
:
false
}
break
:
{
duration
:
5
*
60
initialDuration
:
5
*
60
startTime
:
null
isRunning
:
false
}
}
}
;
function
App
(
prevState
=
INITIAL_STATE
.
App
action
)
{
switch
(
action
.
type
)
{
case
actionTypes
.
INIT
:
return
Object
.
assign
(
{
}
prevState
action
.
data
|
|
{
}
{
initialized
:
true
}
)
;
case
actionTypes
.
TOP_SITES_UPDATED
:
return
{
.
.
.
prevState
isForStartupCache
:
{
.
.
.
prevState
.
isForStartupCache
TopSites
:
false
}
}
;
case
actionTypes
.
DISCOVERY_STREAM_SPOCS_UPDATE
:
return
{
.
.
.
prevState
isForStartupCache
:
{
.
.
.
prevState
.
isForStartupCache
DiscoveryStream
:
false
}
}
;
case
actionTypes
.
WEATHER_UPDATE
:
return
{
.
.
.
prevState
isForStartupCache
:
{
.
.
.
prevState
.
isForStartupCache
Weather
:
false
}
}
;
case
actionTypes
.
WALLPAPERS_CUSTOM_SET
:
return
{
.
.
.
prevState
isForStartupCache
:
{
.
.
.
prevState
.
isForStartupCache
Wallpaper
:
false
}
}
;
case
actionTypes
.
SHOW_PERSONALIZE
:
return
Object
.
assign
(
{
}
prevState
{
customizeMenuVisible
:
true
}
)
;
case
actionTypes
.
HIDE_PERSONALIZE
:
return
Object
.
assign
(
{
}
prevState
{
customizeMenuVisible
:
false
}
)
;
default
:
return
prevState
;
}
}
function
TopSites
(
prevState
=
INITIAL_STATE
.
TopSites
action
)
{
let
hasMatch
;
let
newRows
;
switch
(
action
.
type
)
{
case
actionTypes
.
TOP_SITES_UPDATED
:
if
(
!
action
.
data
|
|
!
action
.
data
.
links
)
{
return
prevState
;
}
return
Object
.
assign
(
{
}
prevState
{
initialized
:
true
rows
:
action
.
data
.
links
}
action
.
data
.
pref
?
{
pref
:
action
.
data
.
pref
}
:
{
}
)
;
case
actionTypes
.
TOP_SITES_PREFS_UPDATED
:
return
Object
.
assign
(
{
}
prevState
{
pref
:
action
.
data
.
pref
}
)
;
case
actionTypes
.
TOP_SITES_EDIT
:
return
Object
.
assign
(
{
}
prevState
{
editForm
:
{
index
:
action
.
data
.
index
previewResponse
:
null
}
}
)
;
case
actionTypes
.
TOP_SITES_CANCEL_EDIT
:
return
Object
.
assign
(
{
}
prevState
{
editForm
:
null
}
)
;
case
actionTypes
.
TOP_SITES_OPEN_SEARCH_SHORTCUTS_MODAL
:
return
Object
.
assign
(
{
}
prevState
{
showSearchShortcutsForm
:
true
}
)
;
case
actionTypes
.
TOP_SITES_CLOSE_SEARCH_SHORTCUTS_MODAL
:
return
Object
.
assign
(
{
}
prevState
{
showSearchShortcutsForm
:
false
}
)
;
case
actionTypes
.
PREVIEW_RESPONSE
:
if
(
!
prevState
.
editForm
|
|
action
.
data
.
url
!
=
=
prevState
.
editForm
.
previewUrl
)
{
return
prevState
;
}
return
Object
.
assign
(
{
}
prevState
{
editForm
:
{
index
:
prevState
.
editForm
.
index
previewResponse
:
action
.
data
.
preview
previewUrl
:
action
.
data
.
url
}
}
)
;
case
actionTypes
.
PREVIEW_REQUEST
:
if
(
!
prevState
.
editForm
)
{
return
prevState
;
}
return
Object
.
assign
(
{
}
prevState
{
editForm
:
{
index
:
prevState
.
editForm
.
index
previewResponse
:
null
previewUrl
:
action
.
data
.
url
}
}
)
;
case
actionTypes
.
PREVIEW_REQUEST_CANCEL
:
if
(
!
prevState
.
editForm
)
{
return
prevState
;
}
return
Object
.
assign
(
{
}
prevState
{
editForm
:
{
index
:
prevState
.
editForm
.
index
previewResponse
:
null
}
}
)
;
case
actionTypes
.
SCREENSHOT_UPDATED
:
newRows
=
prevState
.
rows
.
map
(
row
=
>
{
if
(
row
&
&
row
.
url
=
=
=
action
.
data
.
url
)
{
hasMatch
=
true
;
return
Object
.
assign
(
{
}
row
{
screenshot
:
action
.
data
.
screenshot
}
)
;
}
return
row
;
}
)
;
return
hasMatch
?
Object
.
assign
(
{
}
prevState
{
rows
:
newRows
}
)
:
prevState
;
case
actionTypes
.
PLACES_BOOKMARK_ADDED
:
if
(
!
action
.
data
)
{
return
prevState
;
}
newRows
=
prevState
.
rows
.
map
(
site
=
>
{
if
(
site
&
&
site
.
url
=
=
=
action
.
data
.
url
)
{
const
{
bookmarkGuid
bookmarkTitle
dateAdded
}
=
action
.
data
;
return
Object
.
assign
(
{
}
site
{
bookmarkGuid
bookmarkTitle
bookmarkDateCreated
:
dateAdded
}
)
;
}
return
site
;
}
)
;
return
Object
.
assign
(
{
}
prevState
{
rows
:
newRows
}
)
;
case
actionTypes
.
PLACES_BOOKMARKS_REMOVED
:
if
(
!
action
.
data
)
{
return
prevState
;
}
newRows
=
prevState
.
rows
.
map
(
site
=
>
{
if
(
site
&
&
action
.
data
.
urls
.
includes
(
site
.
url
)
)
{
const
newSite
=
Object
.
assign
(
{
}
site
)
;
delete
newSite
.
bookmarkGuid
;
delete
newSite
.
bookmarkTitle
;
delete
newSite
.
bookmarkDateCreated
;
return
newSite
;
}
return
site
;
}
)
;
return
Object
.
assign
(
{
}
prevState
{
rows
:
newRows
}
)
;
case
actionTypes
.
PLACES_LINKS_DELETED
:
if
(
!
action
.
data
)
{
return
prevState
;
}
newRows
=
prevState
.
rows
.
filter
(
site
=
>
!
action
.
data
.
urls
.
includes
(
site
.
url
)
)
;
return
Object
.
assign
(
{
}
prevState
{
rows
:
newRows
}
)
;
case
actionTypes
.
UPDATE_SEARCH_SHORTCUTS
:
return
{
.
.
.
prevState
searchShortcuts
:
action
.
data
.
searchShortcuts
}
;
case
actionTypes
.
SOV_UPDATED
:
{
const
sov
=
{
ready
:
action
.
data
.
ready
positions
:
action
.
data
.
positions
}
;
return
{
.
.
.
prevState
sov
}
;
}
default
:
return
prevState
;
}
}
function
Dialog
(
prevState
=
INITIAL_STATE
.
Dialog
action
)
{
switch
(
action
.
type
)
{
case
actionTypes
.
DIALOG_OPEN
:
return
Object
.
assign
(
{
}
prevState
{
visible
:
true
data
:
action
.
data
}
)
;
case
actionTypes
.
DIALOG_CANCEL
:
return
Object
.
assign
(
{
}
prevState
{
visible
:
false
}
)
;
case
actionTypes
.
DIALOG_CLOSE
:
return
Object
.
assign
(
{
}
INITIAL_STATE
.
Dialog
)
;
default
:
return
prevState
;
}
}
function
Prefs
(
prevState
=
INITIAL_STATE
.
Prefs
action
)
{
let
newValues
;
switch
(
action
.
type
)
{
case
actionTypes
.
PREFS_INITIAL_VALUES
:
return
Object
.
assign
(
{
}
prevState
{
initialized
:
true
values
:
action
.
data
}
)
;
case
actionTypes
.
PREF_CHANGED
:
newValues
=
Object
.
assign
(
{
}
prevState
.
values
)
;
newValues
[
action
.
data
.
name
]
=
action
.
data
.
value
;
return
Object
.
assign
(
{
}
prevState
{
values
:
newValues
}
)
;
default
:
return
prevState
;
}
}
function
Sections
(
prevState
=
INITIAL_STATE
.
Sections
action
)
{
let
hasMatch
;
let
newState
;
switch
(
action
.
type
)
{
case
actionTypes
.
SECTION_DEREGISTER
:
return
prevState
.
filter
(
section
=
>
section
.
id
!
=
=
action
.
data
)
;
case
actionTypes
.
SECTION_REGISTER
:
newState
=
prevState
.
map
(
section
=
>
{
if
(
section
&
&
section
.
id
=
=
=
action
.
data
.
id
)
{
hasMatch
=
true
;
return
Object
.
assign
(
{
}
section
action
.
data
)
;
}
return
section
;
}
)
;
if
(
!
hasMatch
)
{
const
initialized
=
!
!
(
action
.
data
.
rows
&
&
!
!
action
.
data
.
rows
.
length
)
;
const
section
=
Object
.
assign
(
{
title
:
"
"
rows
:
[
]
enabled
:
false
}
action
.
data
{
initialized
}
)
;
newState
.
push
(
section
)
;
}
return
newState
;
case
actionTypes
.
SECTION_UPDATE
:
newState
=
prevState
.
map
(
section
=
>
{
if
(
section
&
&
section
.
id
=
=
=
action
.
data
.
id
)
{
const
initialized
=
action
.
data
.
rows
?
{
initialized
:
true
}
:
{
}
;
if
(
action
.
data
.
rows
&
&
!
!
action
.
data
.
rows
.
length
&
&
section
.
rows
.
find
(
card
=
>
card
.
pinned
)
)
{
const
rows
=
Array
.
from
(
action
.
data
.
rows
)
;
section
.
rows
.
forEach
(
(
card
index
)
=
>
{
if
(
card
.
pinned
)
{
if
(
rows
[
index
]
.
guid
!
=
=
card
.
guid
)
{
rows
.
splice
(
index
0
card
)
;
}
}
}
)
;
return
Object
.
assign
(
{
}
section
initialized
Object
.
assign
(
{
}
action
.
data
{
rows
}
)
)
;
}
return
Object
.
assign
(
{
}
section
initialized
action
.
data
)
;
}
return
section
;
}
)
;
if
(
!
action
.
data
.
dedupeConfigurations
)
{
return
newState
;
}
action
.
data
.
dedupeConfigurations
.
forEach
(
dedupeConf
=
>
{
newState
=
newState
.
map
(
section
=
>
{
if
(
section
.
id
=
=
=
dedupeConf
.
id
)
{
const
dedupedRows
=
dedupeConf
.
dedupeFrom
.
reduce
(
(
rows
dedupeSectionId
)
=
>
{
const
dedupeSection
=
newState
.
find
(
s
=
>
s
.
id
=
=
=
dedupeSectionId
)
;
const
[
newRows
]
=
dedupe
.
group
(
dedupeSection
.
rows
rows
)
;
return
newRows
;
}
section
.
rows
)
;
return
Object
.
assign
(
{
}
section
{
rows
:
dedupedRows
}
)
;
}
return
section
;
}
)
;
}
)
;
return
newState
;
case
actionTypes
.
SECTION_UPDATE_CARD
:
return
prevState
.
map
(
section
=
>
{
if
(
section
&
&
section
.
id
=
=
=
action
.
data
.
id
&
&
section
.
rows
)
{
const
newRows
=
section
.
rows
.
map
(
card
=
>
{
if
(
card
.
url
=
=
=
action
.
data
.
url
)
{
return
Object
.
assign
(
{
}
card
action
.
data
.
options
)
;
}
return
card
;
}
)
;
return
Object
.
assign
(
{
}
section
{
rows
:
newRows
}
)
;
}
return
section
;
}
)
;
case
actionTypes
.
PLACES_BOOKMARK_ADDED
:
if
(
!
action
.
data
)
{
return
prevState
;
}
return
prevState
.
map
(
section
=
>
Object
.
assign
(
{
}
section
{
rows
:
section
.
rows
.
map
(
item
=
>
{
if
(
item
.
url
=
=
=
action
.
data
.
url
)
{
const
{
bookmarkGuid
bookmarkTitle
dateAdded
}
=
action
.
data
;
return
Object
.
assign
(
{
}
item
{
bookmarkGuid
bookmarkTitle
bookmarkDateCreated
:
dateAdded
type
:
"
bookmark
"
}
)
;
}
return
item
;
}
)
}
)
)
;
case
actionTypes
.
PLACES_BOOKMARKS_REMOVED
:
if
(
!
action
.
data
)
{
return
prevState
;
}
return
prevState
.
map
(
section
=
>
Object
.
assign
(
{
}
section
{
rows
:
section
.
rows
.
map
(
item
=
>
{
if
(
action
.
data
.
urls
.
includes
(
item
.
url
)
)
{
const
newSite
=
Object
.
assign
(
{
}
item
)
;
delete
newSite
.
bookmarkGuid
;
delete
newSite
.
bookmarkTitle
;
delete
newSite
.
bookmarkDateCreated
;
if
(
!
newSite
.
type
|
|
newSite
.
type
=
=
=
"
bookmark
"
)
{
newSite
.
type
=
"
history
"
;
}
return
newSite
;
}
return
item
;
}
)
}
)
)
;
case
actionTypes
.
PLACES_LINKS_DELETED
:
if
(
!
action
.
data
)
{
return
prevState
;
}
return
prevState
.
map
(
section
=
>
Object
.
assign
(
{
}
section
{
rows
:
section
.
rows
.
filter
(
site
=
>
!
action
.
data
.
urls
.
includes
(
site
.
url
)
)
}
)
)
;
case
actionTypes
.
PLACES_LINK_BLOCKED
:
if
(
!
action
.
data
)
{
return
prevState
;
}
return
prevState
.
map
(
section
=
>
Object
.
assign
(
{
}
section
{
rows
:
section
.
rows
.
filter
(
site
=
>
site
.
url
!
=
=
action
.
data
.
url
)
}
)
)
;
default
:
return
prevState
;
}
}
function
Messages
(
prevState
=
INITIAL_STATE
.
Messages
action
)
{
switch
(
action
.
type
)
{
case
actionTypes
.
MESSAGE_SET
:
if
(
prevState
.
messageData
.
messageType
)
{
return
prevState
;
}
return
{
.
.
.
prevState
messageData
:
action
.
data
.
message
portID
:
action
.
data
.
portID
|
|
"
"
}
;
case
actionTypes
.
MESSAGE_TOGGLE_VISIBILITY
:
return
{
.
.
.
prevState
isVisible
:
action
.
data
}
;
default
:
return
prevState
;
}
}
function
Pocket
(
prevState
=
INITIAL_STATE
.
Pocket
action
)
{
switch
(
action
.
type
)
{
case
actionTypes
.
POCKET_WAITING_FOR_SPOC
:
return
{
.
.
.
prevState
waitingForSpoc
:
action
.
data
}
;
case
actionTypes
.
POCKET_LOGGED_IN
:
return
{
.
.
.
prevState
isUserLoggedIn
:
!
!
action
.
data
}
;
case
actionTypes
.
POCKET_CTA
:
return
{
.
.
.
prevState
pocketCta
:
{
ctaButton
:
action
.
data
.
cta_button
ctaText
:
action
.
data
.
cta_text
ctaUrl
:
action
.
data
.
cta_url
useCta
:
action
.
data
.
use_cta
}
}
;
default
:
return
prevState
;
}
}
function
Reducers_sys_Personalization
(
prevState
=
INITIAL_STATE
.
Personalization
action
)
{
switch
(
action
.
type
)
{
case
actionTypes
.
DISCOVERY_STREAM_PERSONALIZATION_LAST_UPDATED
:
return
{
.
.
.
prevState
lastUpdated
:
action
.
data
.
lastUpdated
}
;
case
actionTypes
.
DISCOVERY_STREAM_PERSONALIZATION_INIT
:
return
{
.
.
.
prevState
initialized
:
true
}
;
case
actionTypes
.
DISCOVERY_STREAM_PERSONALIZATION_RESET
:
return
{
.
.
.
INITIAL_STATE
.
Personalization
}
;
default
:
return
prevState
;
}
}
function
InferredPersonalization
(
prevState
=
INITIAL_STATE
.
InferredPersonalization
action
)
{
switch
(
action
.
type
)
{
case
actionTypes
.
INFERRED_PERSONALIZATION_UPDATE
:
return
{
.
.
.
prevState
initialized
:
true
inferredInterests
:
action
.
data
.
inferredInterests
coarseInferredInterests
:
action
.
data
.
coarseInferredInterests
coarsePrivateInferredInterests
:
action
.
data
.
coarsePrivateInferredInterests
lastUpdated
:
action
.
data
.
lastUpdated
}
;
case
actionTypes
.
INFERRED_PERSONALIZATION_RESET
:
return
{
.
.
.
INITIAL_STATE
.
InferredPersonalization
}
;
default
:
return
prevState
;
}
}
function
DiscoveryStream
(
prevState
=
INITIAL_STATE
.
DiscoveryStream
action
)
{
const
isNotReady
=
(
)
=
>
!
action
.
data
|
|
!
prevState
.
spocs
.
loaded
|
|
!
prevState
.
feeds
.
loaded
;
const
handlePlacements
=
handleSites
=
>
{
const
{
data
placements
}
=
prevState
.
spocs
;
const
result
=
{
}
;
const
forPlacement
=
placement
=
>
{
const
placementSpocs
=
data
[
placement
.
name
]
;
if
(
!
placementSpocs
|
|
!
placementSpocs
.
items
|
|
!
placementSpocs
.
items
.
length
)
{
return
;
}
result
[
placement
.
name
]
=
{
.
.
.
placementSpocs
items
:
handleSites
(
placementSpocs
.
items
)
}
;
}
;
if
(
!
placements
|
|
!
placements
.
length
)
{
[
{
name
:
"
spocs
"
}
]
.
forEach
(
forPlacement
)
;
}
else
{
placements
.
forEach
(
forPlacement
)
;
}
return
result
;
}
;
const
nextState
=
handleSites
=
>
(
{
.
.
.
prevState
spocs
:
{
.
.
.
prevState
.
spocs
data
:
handlePlacements
(
handleSites
)
}
feeds
:
{
.
.
.
prevState
.
feeds
data
:
Object
.
keys
(
prevState
.
feeds
.
data
)
.
reduce
(
(
accumulator
feed_url
)
=
>
{
accumulator
[
feed_url
]
=
{
data
:
{
.
.
.
prevState
.
feeds
.
data
[
feed_url
]
.
data
recommendations
:
handleSites
(
prevState
.
feeds
.
data
[
feed_url
]
.
data
.
recommendations
)
}
}
;
return
accumulator
;
}
{
}
)
}
}
)
;
switch
(
action
.
type
)
{
case
actionTypes
.
DISCOVERY_STREAM_CONFIG_CHANGE
:
case
actionTypes
.
DISCOVERY_STREAM_CONFIG_SETUP
:
return
{
.
.
.
prevState
config
:
action
.
data
|
|
{
}
}
;
case
actionTypes
.
DISCOVERY_STREAM_EXPERIMENT_DATA
:
return
{
.
.
.
prevState
experimentData
:
action
.
data
|
|
{
}
}
;
case
actionTypes
.
DISCOVERY_STREAM_LAYOUT_UPDATE
:
return
{
.
.
.
prevState
layout
:
action
.
data
.
layout
|
|
[
]
}
;
case
actionTypes
.
DISCOVERY_STREAM_COLLECTION_DISMISSIBLE_TOGGLE
:
return
{
.
.
.
prevState
isCollectionDismissible
:
action
.
data
.
value
}
;
case
actionTypes
.
DISCOVERY_STREAM_TOPICS_LOADING
:
return
{
.
.
.
prevState
topicsLoading
:
action
.
data
}
;
case
actionTypes
.
DISCOVERY_STREAM_PREFS_SETUP
:
return
{
.
.
.
prevState
recentSavesEnabled
:
action
.
data
.
recentSavesEnabled
pocketButtonEnabled
:
action
.
data
.
pocketButtonEnabled
hideDescriptions
:
action
.
data
.
hideDescriptions
compactImages
:
action
.
data
.
compactImages
imageGradient
:
action
.
data
.
imageGradient
newSponsoredLabel
:
action
.
data
.
newSponsoredLabel
titleLines
:
action
.
data
.
titleLines
descLines
:
action
.
data
.
descLines
readTime
:
action
.
data
.
readTime
}
;
case
actionTypes
.
DISCOVERY_STREAM_RECENT_SAVES
:
return
{
.
.
.
prevState
recentSavesData
:
action
.
data
.
recentSaves
}
;
case
actionTypes
.
DISCOVERY_STREAM_POCKET_STATE_SET
:
return
{
.
.
.
prevState
isUserLoggedIn
:
action
.
data
.
isUserLoggedIn
}
;
case
actionTypes
.
HIDE_PRIVACY_INFO
:
return
{
.
.
.
prevState
isPrivacyInfoModalVisible
:
false
}
;
case
actionTypes
.
SHOW_PRIVACY_INFO
:
return
{
.
.
.
prevState
isPrivacyInfoModalVisible
:
true
}
;
case
actionTypes
.
DISCOVERY_STREAM_LAYOUT_RESET
:
return
{
.
.
.
INITIAL_STATE
.
DiscoveryStream
config
:
prevState
.
config
}
;
case
actionTypes
.
DISCOVERY_STREAM_FEEDS_UPDATE
:
return
{
.
.
.
prevState
feeds
:
{
.
.
.
prevState
.
feeds
loaded
:
true
}
}
;
case
actionTypes
.
DISCOVERY_STREAM_FEED_UPDATE
:
{
const
newData
=
{
}
;
newData
[
action
.
data
.
url
]
=
action
.
data
.
feed
;
return
{
.
.
.
prevState
feeds
:
{
.
.
.
prevState
.
feeds
data
:
{
.
.
.
prevState
.
feeds
.
data
.
.
.
newData
}
}
}
;
}
case
actionTypes
.
DISCOVERY_STREAM_DEV_IMPRESSIONS
:
return
{
.
.
.
prevState
impressions
:
{
.
.
.
prevState
.
impressions
feed
:
action
.
data
}
}
;
case
actionTypes
.
DISCOVERY_STREAM_DEV_BLOCKS
:
return
{
.
.
.
prevState
blocks
:
action
.
data
}
;
case
actionTypes
.
DISCOVERY_STREAM_SPOCS_CAPS
:
return
{
.
.
.
prevState
spocs
:
{
.
.
.
prevState
.
spocs
frequency_caps
:
[
.
.
.
prevState
.
spocs
.
frequency_caps
.
.
.
action
.
data
]
}
}
;
case
actionTypes
.
DISCOVERY_STREAM_SPOCS_ENDPOINT
:
return
{
.
.
.
prevState
spocs
:
{
.
.
.
INITIAL_STATE
.
DiscoveryStream
.
spocs
spocs_endpoint
:
action
.
data
.
url
|
|
INITIAL_STATE
.
DiscoveryStream
.
spocs
.
spocs_endpoint
}
}
;
case
actionTypes
.
DISCOVERY_STREAM_SPOCS_PLACEMENTS
:
return
{
.
.
.
prevState
spocs
:
{
.
.
.
prevState
.
spocs
placements
:
action
.
data
.
placements
|
|
INITIAL_STATE
.
DiscoveryStream
.
spocs
.
placements
}
}
;
case
actionTypes
.
DISCOVERY_STREAM_SPOCS_UPDATE
:
if
(
action
.
data
)
{
return
{
.
.
.
prevState
spocs
:
{
.
.
.
prevState
.
spocs
lastUpdated
:
action
.
data
.
lastUpdated
data
:
action
.
data
.
spocs
loaded
:
true
}
}
;
}
return
prevState
;
case
actionTypes
.
DISCOVERY_STREAM_SPOC_BLOCKED
:
return
{
.
.
.
prevState
spocs
:
{
.
.
.
prevState
.
spocs
blocked
:
[
.
.
.
prevState
.
spocs
.
blocked
action
.
data
.
url
]
}
}
;
case
actionTypes
.
DISCOVERY_STREAM_LINK_BLOCKED
:
return
isNotReady
(
)
?
prevState
:
nextState
(
items
=
>
items
.
filter
(
item
=
>
item
.
url
!
=
=
action
.
data
.
url
)
)
;
case
actionTypes
.
PLACES_BOOKMARK_ADDED
:
{
const
updateBookmarkInfo
=
item
=
>
{
if
(
item
.
url
=
=
=
action
.
data
.
url
)
{
const
{
bookmarkGuid
bookmarkTitle
dateAdded
}
=
action
.
data
;
return
Object
.
assign
(
{
}
item
{
bookmarkGuid
bookmarkTitle
bookmarkDateCreated
:
dateAdded
context_type
:
"
bookmark
"
}
)
;
}
return
item
;
}
;
return
isNotReady
(
)
?
prevState
:
nextState
(
items
=
>
items
.
map
(
updateBookmarkInfo
)
)
;
}
case
actionTypes
.
PLACES_BOOKMARKS_REMOVED
:
{
const
removeBookmarkInfo
=
item
=
>
{
if
(
action
.
data
.
urls
.
includes
(
item
.
url
)
)
{
const
newSite
=
Object
.
assign
(
{
}
item
)
;
delete
newSite
.
bookmarkGuid
;
delete
newSite
.
bookmarkTitle
;
delete
newSite
.
bookmarkDateCreated
;
if
(
!
newSite
.
context_type
|
|
newSite
.
context_type
=
=
=
"
bookmark
"
)
{
newSite
.
context_type
=
"
removedBookmark
"
;
}
return
newSite
;
}
return
item
;
}
;
return
isNotReady
(
)
?
prevState
:
nextState
(
items
=
>
items
.
map
(
removeBookmarkInfo
)
)
;
}
case
actionTypes
.
PREF_CHANGED
:
if
(
action
.
data
.
name
=
=
=
PREF_COLLECTION_DISMISSIBLE
)
{
return
{
.
.
.
prevState
isCollectionDismissible
:
action
.
data
.
value
}
;
}
return
prevState
;
case
actionTypes
.
TOPIC_SELECTION_SPOTLIGHT_OPEN
:
return
{
.
.
.
prevState
showTopicSelection
:
true
}
;
case
actionTypes
.
TOPIC_SELECTION_SPOTLIGHT_CLOSE
:
return
{
.
.
.
prevState
showTopicSelection
:
false
}
;
case
actionTypes
.
SECTION_BLOCKED
:
return
{
.
.
.
prevState
showBlockSectionConfirmation
:
true
sectionPersonalization
:
action
.
data
}
;
case
actionTypes
.
REPORT_AD_OPEN
:
return
{
.
.
.
prevState
report
:
{
.
.
.
prevState
.
report
card_type
:
action
.
data
?
.
card_type
position
:
action
.
data
?
.
position
placement_id
:
action
.
data
?
.
placement_id
reporting_url
:
action
.
data
?
.
reporting_url
url
:
action
.
data
?
.
url
visible
:
true
}
}
;
case
actionTypes
.
REPORT_CONTENT_OPEN
:
return
{
.
.
.
prevState
report
:
{
.
.
.
prevState
.
report
card_type
:
action
.
data
?
.
card_type
corpus_item_id
:
action
.
data
?
.
corpus_item_id
scheduled_corpus_item_id
:
action
.
data
?
.
scheduled_corpus_item_id
section_position
:
action
.
data
?
.
section_position
section
:
action
.
data
?
.
section
title
:
action
.
data
?
.
title
topic
:
action
.
data
?
.
topic
url
:
action
.
data
?
.
url
visible
:
true
}
}
;
case
actionTypes
.
REPORT_CLOSE
:
case
actionTypes
.
REPORT_AD_SUBMIT
:
case
actionTypes
.
REPORT_CONTENT_SUBMIT
:
return
{
.
.
.
prevState
report
:
{
.
.
.
prevState
.
report
visible
:
false
}
}
;
case
actionTypes
.
SECTION_PERSONALIZATION_UPDATE
:
return
{
.
.
.
prevState
sectionPersonalization
:
action
.
data
}
;
default
:
return
prevState
;
}
}
function
Search
(
prevState
=
INITIAL_STATE
.
Search
action
)
{
switch
(
action
.
type
)
{
case
actionTypes
.
DISABLE_SEARCH
:
return
Object
.
assign
(
{
.
.
.
prevState
disable
:
true
}
)
;
case
actionTypes
.
FAKE_FOCUS_SEARCH
:
return
Object
.
assign
(
{
.
.
.
prevState
fakeFocus
:
true
}
)
;
case
actionTypes
.
SHOW_SEARCH
:
return
Object
.
assign
(
{
.
.
.
prevState
disable
:
false
fakeFocus
:
false
}
)
;
default
:
return
prevState
;
}
}
function
Wallpapers
(
prevState
=
INITIAL_STATE
.
Wallpapers
action
)
{
switch
(
action
.
type
)
{
case
actionTypes
.
WALLPAPERS_SET
:
return
{
.
.
.
prevState
wallpaperList
:
action
.
data
}
;
case
actionTypes
.
WALLPAPERS_FEATURE_HIGHLIGHT_COUNTER_INCREMENT
:
return
{
.
.
.
prevState
highlightSeenCounter
:
action
.
data
}
;
case
actionTypes
.
WALLPAPERS_CATEGORY_SET
:
return
{
.
.
.
prevState
categories
:
action
.
data
}
;
case
actionTypes
.
WALLPAPERS_CUSTOM_SET
:
return
{
.
.
.
prevState
uploadedWallpaper
:
action
.
data
}
;
default
:
return
prevState
;
}
}
function
Notifications
(
prevState
=
INITIAL_STATE
.
Notifications
action
)
{
switch
(
action
.
type
)
{
case
actionTypes
.
SHOW_TOAST_MESSAGE
:
return
{
.
.
.
prevState
showNotifications
:
action
.
data
.
showNotifications
toastCounter
:
prevState
.
toastCounter
+
1
toastId
:
action
.
data
.
toastId
toastQueue
:
[
action
.
data
.
toastId
]
}
;
case
actionTypes
.
HIDE_TOAST_MESSAGE
:
{
const
{
showNotifications
toastId
:
hiddenToastId
}
=
action
.
data
;
const
queuedToasts
=
[
.
.
.
prevState
.
toastQueue
]
.
filter
(
toastId
=
>
toastId
!
=
=
hiddenToastId
)
;
return
{
.
.
.
prevState
toastCounter
:
queuedToasts
.
length
toastQueue
:
queuedToasts
toastId
:
"
"
showNotifications
}
;
}
default
:
return
prevState
;
}
}
function
Weather
(
prevState
=
INITIAL_STATE
.
Weather
action
)
{
switch
(
action
.
type
)
{
case
actionTypes
.
WEATHER_UPDATE
:
return
{
.
.
.
prevState
suggestions
:
action
.
data
.
suggestions
lastUpdated
:
action
.
data
.
date
locationData
:
action
.
data
.
locationData
|
|
prevState
.
locationData
initialized
:
true
}
;
case
actionTypes
.
WEATHER_SEARCH_ACTIVE
:
return
{
.
.
.
prevState
searchActive
:
action
.
data
}
;
case
actionTypes
.
WEATHER_LOCATION_SEARCH_UPDATE
:
return
{
.
.
.
prevState
locationSearchString
:
action
.
data
}
;
case
actionTypes
.
WEATHER_LOCATION_SUGGESTIONS_UPDATE
:
return
{
.
.
.
prevState
suggestedLocations
:
action
.
data
}
;
case
actionTypes
.
WEATHER_LOCATION_DATA_UPDATE
:
return
{
.
.
.
prevState
locationData
:
action
.
data
}
;
default
:
return
prevState
;
}
}
function
Ads
(
prevState
=
INITIAL_STATE
.
Ads
action
)
{
switch
(
action
.
type
)
{
case
actionTypes
.
ADS_INIT
:
return
{
.
.
.
prevState
initialized
:
true
}
;
case
actionTypes
.
ADS_UPDATE_TILES
:
return
{
.
.
.
prevState
tiles
:
action
.
data
.
tiles
}
;
case
actionTypes
.
ADS_UPDATE_SPOCS
:
return
{
.
.
.
prevState
spocs
:
action
.
data
.
spocs
spocPlacements
:
action
.
data
.
spocPlacements
}
;
case
actionTypes
.
ADS_RESET
:
return
{
.
.
.
INITIAL_STATE
.
Ads
}
;
default
:
return
prevState
;
}
}
function
TrendingSearch
(
prevState
=
INITIAL_STATE
.
TrendingSearch
action
)
{
switch
(
action
.
type
)
{
case
actionTypes
.
TRENDING_SEARCH_UPDATE
:
return
{
.
.
.
prevState
suggestions
:
action
.
data
}
;
case
actionTypes
.
TRENDING_SEARCH_TOGGLE_COLLAPSE
:
return
{
.
.
.
prevState
collapsed
:
action
.
data
.
collapsed
}
;
default
:
return
prevState
;
}
}
function
TimerWidget
(
prevState
=
INITIAL_STATE
.
TimerWidget
action
)
{
const
timerType
=
action
.
data
?
.
timerType
|
|
prevState
.
timerType
;
switch
(
action
.
type
)
{
case
actionTypes
.
WIDGETS_TIMER_SET
:
return
{
.
.
.
prevState
.
.
.
action
.
data
}
;
case
actionTypes
.
WIDGETS_TIMER_SET_TYPE
:
return
{
.
.
.
prevState
timerType
:
action
.
data
.
timerType
}
;
case
actionTypes
.
WIDGETS_TIMER_SET_DURATION
:
return
{
.
.
.
prevState
[
timerType
]
:
{
duration
:
action
.
data
.
duration
initialDuration
:
action
.
data
.
duration
startTime
:
null
isRunning
:
false
}
}
;
case
actionTypes
.
WIDGETS_TIMER_PLAY
:
return
{
.
.
.
prevState
[
timerType
]
:
{
.
.
.
prevState
[
timerType
]
startTime
:
Math
.
floor
(
Date
.
now
(
)
/
1000
)
isRunning
:
true
}
}
;
case
actionTypes
.
WIDGETS_TIMER_PAUSE
:
if
(
prevState
[
timerType
]
?
.
isRunning
)
{
return
{
.
.
.
prevState
[
timerType
]
:
{
.
.
.
prevState
[
timerType
]
duration
:
action
.
data
.
duration
startTime
:
null
isRunning
:
false
}
}
;
}
return
prevState
;
case
actionTypes
.
WIDGETS_TIMER_RESET
:
return
{
.
.
.
prevState
[
timerType
]
:
{
.
.
.
prevState
[
timerType
]
duration
:
action
.
data
.
duration
initialDuration
:
action
.
data
.
duration
startTime
:
null
isRunning
:
false
}
}
;
case
actionTypes
.
WIDGETS_TIMER_END
:
return
{
.
.
.
prevState
[
timerType
]
:
{
.
.
.
prevState
[
timerType
]
duration
:
action
.
data
.
duration
initialDuration
:
action
.
data
.
duration
startTime
:
null
isRunning
:
false
}
}
;
default
:
return
prevState
;
}
}
function
ListsWidget
(
prevState
=
INITIAL_STATE
.
ListsWidget
action
)
{
switch
(
action
.
type
)
{
case
actionTypes
.
WIDGETS_LISTS_SET
:
return
{
.
.
.
prevState
lists
:
action
.
data
}
;
case
actionTypes
.
WIDGETS_LISTS_SET_SELECTED
:
return
{
.
.
.
prevState
selected
:
action
.
data
}
;
default
:
return
prevState
;
}
}
const
reducers
=
{
TopSites
App
Ads
Prefs
Dialog
Sections
Messages
Notifications
Pocket
Personalization
:
Reducers_sys_Personalization
InferredPersonalization
DiscoveryStream
Search
TimerWidget
ListsWidget
TrendingSearch
Wallpapers
Weather
}
;
;
class
TopSiteFormInput
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
state
=
{
validationError
:
this
.
props
.
validationError
}
;
this
.
onChange
=
this
.
onChange
.
bind
(
this
)
;
this
.
onMount
=
this
.
onMount
.
bind
(
this
)
;
this
.
onClearIconPress
=
this
.
onClearIconPress
.
bind
(
this
)
;
}
componentWillReceiveProps
(
nextProps
)
{
if
(
nextProps
.
shouldFocus
&
&
!
this
.
props
.
shouldFocus
)
{
this
.
input
.
focus
(
)
;
}
if
(
nextProps
.
validationError
&
&
!
this
.
props
.
validationError
)
{
this
.
setState
(
{
validationError
:
true
}
)
;
}
if
(
this
.
state
.
validationError
&
&
!
nextProps
.
value
)
{
this
.
setState
(
{
validationError
:
false
}
)
;
}
}
onClearIconPress
(
event
)
{
if
(
event
.
key
=
=
=
"
Enter
"
)
{
this
.
props
.
onClear
(
)
;
}
}
onChange
(
ev
)
{
if
(
this
.
state
.
validationError
)
{
this
.
setState
(
{
validationError
:
false
}
)
;
}
this
.
props
.
onChange
(
ev
)
;
}
onMount
(
input
)
{
this
.
input
=
input
;
}
renderLoadingOrCloseButton
(
)
{
const
showClearButton
=
this
.
props
.
value
&
&
this
.
props
.
onClear
;
if
(
this
.
props
.
loading
)
{
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
loading
-
container
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
loading
-
animation
"
}
)
)
;
}
else
if
(
showClearButton
)
{
return
external_React_default
(
)
.
createElement
(
"
button
"
{
type
:
"
button
"
className
:
"
icon
icon
-
clear
-
input
icon
-
button
-
style
"
onClick
:
this
.
props
.
onClear
onKeyPress
:
this
.
onClearIconPress
}
)
;
}
return
null
;
}
render
(
)
{
const
{
typeUrl
}
=
this
.
props
;
const
{
validationError
}
=
this
.
state
;
return
external_React_default
(
)
.
createElement
(
"
label
"
null
external_React_default
(
)
.
createElement
(
"
span
"
{
"
data
-
l10n
-
id
"
:
this
.
props
.
titleId
}
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
field
{
typeUrl
?
"
url
"
:
"
"
}
{
validationError
?
"
invalid
"
:
"
"
}
}
external_React_default
(
)
.
createElement
(
"
input
"
{
type
:
"
text
"
value
:
this
.
props
.
value
ref
:
this
.
onMount
onChange
:
this
.
onChange
"
data
-
l10n
-
id
"
:
this
.
props
.
placeholderId
autoFocus
:
this
.
props
.
autoFocusOnOpen
disabled
:
this
.
props
.
loading
}
)
this
.
renderLoadingOrCloseButton
(
)
validationError
&
&
external_React_default
(
)
.
createElement
(
"
aside
"
{
className
:
"
error
-
tooltip
"
"
data
-
l10n
-
id
"
:
this
.
props
.
errorMessageId
}
)
)
)
;
}
}
TopSiteFormInput
.
defaultProps
=
{
showClearButton
:
false
value
:
"
"
validationError
:
false
}
;
;
const
TopSiteImpressionWrapper_VISIBLE
=
"
visible
"
;
const
TopSiteImpressionWrapper_VISIBILITY_CHANGE_EVENT
=
"
visibilitychange
"
;
const
TopSiteImpressionWrapper_INTERSECTION_RATIO
=
0
.
5
;
class
TopSiteImpressionWrapper
extends
(
external_React_default
(
)
)
.
PureComponent
{
_dispatchImpressionStats
(
)
{
const
{
actionType
tile
}
=
this
.
props
;
if
(
!
actionType
)
{
return
;
}
this
.
props
.
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionType
data
:
{
type
:
"
impression
"
.
.
.
tile
}
}
)
)
;
}
setImpressionObserverOrAddListener
(
)
{
const
{
props
}
=
this
;
if
(
!
props
.
dispatch
)
{
return
;
}
if
(
props
.
document
.
visibilityState
=
=
=
TopSiteImpressionWrapper_VISIBLE
)
{
this
.
setImpressionObserver
(
)
;
}
else
{
if
(
this
.
_onVisibilityChange
)
{
props
.
document
.
removeEventListener
(
TopSiteImpressionWrapper_VISIBILITY_CHANGE_EVENT
this
.
_onVisibilityChange
)
;
}
this
.
_onVisibilityChange
=
(
)
=
>
{
if
(
props
.
document
.
visibilityState
=
=
=
TopSiteImpressionWrapper_VISIBLE
)
{
this
.
setImpressionObserver
(
)
;
props
.
document
.
removeEventListener
(
TopSiteImpressionWrapper_VISIBILITY_CHANGE_EVENT
this
.
_onVisibilityChange
)
;
}
}
;
props
.
document
.
addEventListener
(
TopSiteImpressionWrapper_VISIBILITY_CHANGE_EVENT
this
.
_onVisibilityChange
)
;
}
}
setImpressionObserver
(
)
{
const
{
props
}
=
this
;
if
(
!
props
.
tile
)
{
return
;
}
this
.
_handleIntersect
=
entries
=
>
{
if
(
entries
.
some
(
entry
=
>
entry
.
isIntersecting
&
&
entry
.
intersectionRatio
>
=
TopSiteImpressionWrapper_INTERSECTION_RATIO
)
)
{
this
.
_dispatchImpressionStats
(
)
;
this
.
impressionObserver
.
unobserve
(
this
.
refs
.
topsite_impression_wrapper
)
;
}
}
;
const
options
=
{
threshold
:
TopSiteImpressionWrapper_INTERSECTION_RATIO
}
;
this
.
impressionObserver
=
new
props
.
IntersectionObserver
(
this
.
_handleIntersect
options
)
;
this
.
impressionObserver
.
observe
(
this
.
refs
.
topsite_impression_wrapper
)
;
}
componentDidMount
(
)
{
if
(
this
.
props
.
tile
)
{
this
.
setImpressionObserverOrAddListener
(
)
;
}
}
componentWillUnmount
(
)
{
if
(
this
.
_handleIntersect
&
&
this
.
impressionObserver
)
{
this
.
impressionObserver
.
unobserve
(
this
.
refs
.
topsite_impression_wrapper
)
;
}
if
(
this
.
_onVisibilityChange
)
{
this
.
props
.
document
.
removeEventListener
(
TopSiteImpressionWrapper_VISIBILITY_CHANGE_EVENT
this
.
_onVisibilityChange
)
;
}
}
render
(
)
{
return
external_React_default
(
)
.
createElement
(
"
div
"
{
ref
:
"
topsite_impression_wrapper
"
className
:
"
topsite
-
impression
-
observer
"
}
this
.
props
.
children
)
;
}
}
TopSiteImpressionWrapper
.
defaultProps
=
{
IntersectionObserver
:
globalThis
.
IntersectionObserver
document
:
globalThis
.
document
actionType
:
null
tile
:
null
}
;
;
function
MessageWrapper
(
{
children
dispatch
hiddenOverride
onDismiss
}
)
{
const
message
=
(
0
external_ReactRedux_namespaceObject
.
useSelector
)
(
state
=
>
state
.
Messages
)
;
const
[
isIntersecting
setIsIntersecting
]
=
(
0
external_React_namespaceObject
.
useState
)
(
false
)
;
const
[
tabIsVisible
setTabIsVisible
]
=
(
0
external_React_namespaceObject
.
useState
)
(
(
)
=
>
typeof
document
!
=
=
"
undefined
"
&
&
document
.
visibilityState
=
=
=
"
visible
"
)
;
const
[
hasRun
setHasRun
]
=
(
0
external_React_namespaceObject
.
useState
)
(
)
;
const
handleIntersection
=
(
0
external_React_namespaceObject
.
useCallback
)
(
(
)
=
>
{
setIsIntersecting
(
true
)
;
if
(
tabIsVisible
&
&
message
.
messageData
.
id
&
&
!
hasRun
)
{
setHasRun
(
true
)
;
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
MESSAGE_IMPRESSION
data
:
message
.
messageData
}
)
)
;
}
}
[
dispatch
message
tabIsVisible
hasRun
]
)
;
(
0
external_React_namespaceObject
.
useEffect
)
(
(
)
=
>
{
if
(
message
.
isVisible
&
&
tabIsVisible
)
{
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
MESSAGE_NOTIFY_VISIBILITY
data
:
true
}
)
)
;
}
}
[
message
dispatch
tabIsVisible
]
)
;
(
0
external_React_namespaceObject
.
useEffect
)
(
(
)
=
>
{
const
handleVisibilityChange
=
(
)
=
>
{
setTabIsVisible
(
document
.
visibilityState
=
=
=
"
visible
"
)
;
}
;
document
.
addEventListener
(
"
visibilitychange
"
handleVisibilityChange
)
;
return
(
)
=
>
{
document
.
removeEventListener
(
"
visibilitychange
"
handleVisibilityChange
)
;
}
;
}
[
]
)
;
const
ref
=
useIntersectionObserver
(
handleIntersection
)
;
const
handleClose
=
(
0
external_React_namespaceObject
.
useCallback
)
(
(
)
=
>
{
const
action
=
{
type
:
actionTypes
.
MESSAGE_TOGGLE_VISIBILITY
data
:
false
}
;
if
(
message
.
portID
)
{
dispatch
(
actionCreators
.
OnlyToOneContent
(
action
message
.
portID
)
)
;
}
else
{
dispatch
(
actionCreators
.
AlsoToMain
(
action
)
)
;
}
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
MESSAGE_NOTIFY_VISIBILITY
data
:
false
}
)
)
;
onDismiss
?
.
(
)
;
}
[
dispatch
message
onDismiss
]
)
;
function
handleDismiss
(
)
{
const
{
id
}
=
message
.
messageData
;
if
(
id
)
{
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
MESSAGE_DISMISS
data
:
{
message
:
message
.
messageData
}
}
)
)
;
}
handleClose
(
)
;
}
function
handleBlock
(
)
{
const
{
id
}
=
message
.
messageData
;
if
(
id
)
{
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
MESSAGE_BLOCK
data
:
id
}
)
)
;
}
}
function
handleClick
(
elementId
)
{
const
{
id
}
=
message
.
messageData
;
if
(
id
)
{
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
MESSAGE_CLICK
data
:
{
message
:
message
.
messageData
source
:
elementId
|
|
"
"
}
}
)
)
;
}
}
if
(
!
message
|
|
!
hiddenOverride
&
&
!
message
.
isVisible
)
{
return
null
;
}
return
external_React_default
(
)
.
createElement
(
"
div
"
{
ref
:
el
=
>
{
ref
.
current
=
[
el
]
;
}
className
:
"
message
-
wrapper
"
}
external_React_default
(
)
.
cloneElement
(
children
{
isIntersecting
handleDismiss
handleClick
handleBlock
handleClose
}
)
)
;
}
;
function
ShortcutFeatureHighlight
(
{
position
dispatch
handleDismiss
handleBlock
feature
}
)
{
const
onDismiss
=
(
0
external_React_namespaceObject
.
useCallback
)
(
(
)
=
>
{
handleDismiss
(
)
;
handleBlock
(
)
;
}
[
handleDismiss
handleBlock
]
)
;
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
shortcut
-
feature
-
highlight
"
}
external_React_default
(
)
.
createElement
(
FeatureHighlight
{
position
:
position
feature
:
feature
dispatch
:
dispatch
message
:
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
shortcut
-
feature
-
highlight
-
content
"
}
external_React_default
(
)
.
createElement
(
"
img
"
{
src
:
"
chrome
:
/
/
global
/
skin
/
icons
/
open
-
in
-
new
.
svg
"
width
:
"
24
"
height
:
"
24
"
alt
:
"
"
}
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
shortcut
-
feature
-
highlight
-
copy
"
}
external_React_default
(
)
.
createElement
(
"
p
"
{
className
:
"
title
"
"
data
-
l10n
-
id
"
:
"
newtab
-
shortcuts
-
highlight
-
title
"
}
)
external_React_default
(
)
.
createElement
(
"
p
"
{
className
:
"
subtitle
"
"
data
-
l10n
-
id
"
:
"
newtab
-
shortcuts
-
highlight
-
subtitle
"
}
)
)
)
openedOverride
:
true
showButtonIcon
:
false
dismissCallback
:
onDismiss
outsideClickCallback
:
handleDismiss
}
)
)
;
}
;
function
TopSite_extends
(
)
{
return
TopSite_extends
=
Object
.
assign
?
Object
.
assign
.
bind
(
)
:
function
(
n
)
{
for
(
var
e
=
1
;
e
<
arguments
.
length
;
e
+
+
)
{
var
t
=
arguments
[
e
]
;
for
(
var
r
in
t
)
(
{
}
)
.
hasOwnProperty
.
call
(
t
r
)
&
&
(
n
[
r
]
=
t
[
r
]
)
;
}
return
n
;
}
TopSite_extends
.
apply
(
null
arguments
)
;
}
const
SPOC_TYPE
=
"
SPOC
"
;
const
NEWTAB_SOURCE
=
"
newtab
"
;
function
isSponsored
(
link
)
{
return
link
?
.
sponsored_position
|
|
link
?
.
type
=
=
=
SPOC_TYPE
;
}
class
TopSiteLink
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
state
=
{
screenshotImage
:
null
}
;
this
.
onDragEvent
=
this
.
onDragEvent
.
bind
(
this
)
;
this
.
onKeyPress
=
this
.
onKeyPress
.
bind
(
this
)
;
this
.
shouldShowOMCHighlight
=
this
.
shouldShowOMCHighlight
.
bind
(
this
)
;
}
_allowDrop
(
e
)
{
return
(
this
.
dragged
|
|
!
isSponsored
(
this
.
props
.
link
)
)
&
&
e
.
dataTransfer
.
types
.
includes
(
"
text
/
topsite
-
index
"
)
;
}
onDragEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
click
"
:
if
(
this
.
dragged
)
{
event
.
preventDefault
(
)
;
}
break
;
case
"
dragstart
"
:
event
.
target
.
blur
(
)
;
if
(
isSponsored
(
this
.
props
.
link
)
)
{
event
.
preventDefault
(
)
;
break
;
}
this
.
dragged
=
true
;
event
.
dataTransfer
.
effectAllowed
=
"
move
"
;
event
.
dataTransfer
.
setData
(
"
text
/
topsite
-
index
"
this
.
props
.
index
)
;
this
.
props
.
onDragEvent
(
event
this
.
props
.
index
this
.
props
.
link
this
.
props
.
title
)
;
break
;
case
"
dragend
"
:
this
.
props
.
onDragEvent
(
event
)
;
break
;
case
"
dragenter
"
:
case
"
dragover
"
:
case
"
drop
"
:
if
(
this
.
_allowDrop
(
event
)
)
{
event
.
preventDefault
(
)
;
this
.
props
.
onDragEvent
(
event
this
.
props
.
index
)
;
}
break
;
case
"
mousedown
"
:
if
(
event
.
button
=
=
=
1
&
&
this
.
props
.
link
.
searchTopSite
)
{
event
.
preventDefault
(
)
;
}
this
.
dragged
=
false
;
break
;
}
}
static
getNextStateFromProps
(
nextProps
prevState
)
{
const
{
screenshot
}
=
nextProps
.
link
;
const
imageInState
=
ScreenshotUtils
.
isRemoteImageLocal
(
prevState
.
screenshotImage
screenshot
)
;
if
(
imageInState
)
{
return
null
;
}
ScreenshotUtils
.
maybeRevokeBlobObjectURL
(
prevState
.
screenshotImage
)
;
return
{
screenshotImage
:
ScreenshotUtils
.
createLocalImageObject
(
screenshot
)
}
;
}
componentWillMount
(
)
{
const
nextState
=
TopSiteLink
.
getNextStateFromProps
(
this
.
props
this
.
state
)
;
if
(
nextState
)
{
this
.
setState
(
nextState
)
;
}
}
componentWillReceiveProps
(
nextProps
)
{
const
nextState
=
TopSiteLink
.
getNextStateFromProps
(
nextProps
this
.
state
)
;
if
(
nextState
)
{
this
.
setState
(
nextState
)
;
}
}
componentWillUnmount
(
)
{
ScreenshotUtils
.
maybeRevokeBlobObjectURL
(
this
.
state
.
screenshotImage
)
;
}
onKeyPress
(
event
)
{
if
(
event
.
key
=
=
=
"
Enter
"
&
&
(
this
.
props
.
link
.
searchTopSite
|
|
this
.
props
.
isAddButton
)
)
{
this
.
props
.
onClick
(
event
)
;
}
}
generateColor
(
)
{
let
{
title
colors
}
=
this
.
props
;
if
(
!
colors
)
{
return
"
"
;
}
let
colorArray
=
colors
.
split
(
"
"
)
;
const
hashStr
=
str
=
>
{
let
hash
=
0
;
for
(
let
i
=
0
;
i
<
str
.
length
;
i
+
+
)
{
let
charCode
=
str
.
charCodeAt
(
i
)
;
hash
+
=
charCode
;
}
return
hash
;
}
;
let
hash
=
hashStr
(
title
)
;
let
index
=
hash
%
colorArray
.
length
;
return
colorArray
[
index
]
;
}
calculateStyle
(
)
{
const
{
defaultStyle
link
}
=
this
.
props
;
const
{
tippyTopIcon
faviconSize
}
=
link
;
let
imageClassName
;
let
imageStyle
;
let
showSmallFavicon
=
false
;
let
smallFaviconStyle
;
let
hasScreenshotImage
=
this
.
state
.
screenshotImage
&
&
this
.
state
.
screenshotImage
.
url
;
let
selectedColor
;
if
(
defaultStyle
)
{
selectedColor
=
this
.
generateColor
(
)
;
}
else
if
(
link
.
searchTopSite
)
{
imageClassName
=
"
top
-
site
-
icon
rich
-
icon
"
;
imageStyle
=
{
backgroundColor
:
link
.
backgroundColor
backgroundImage
:
url
(
{
tippyTopIcon
}
)
}
;
smallFaviconStyle
=
{
backgroundImage
:
url
(
{
tippyTopIcon
}
)
}
;
}
else
if
(
link
.
customScreenshotURL
)
{
imageClassName
=
"
top
-
site
-
icon
rich
-
icon
"
;
imageStyle
=
{
backgroundColor
:
link
.
backgroundColor
backgroundImage
:
hasScreenshotImage
?
url
(
{
this
.
state
.
screenshotImage
.
url
}
)
:
"
"
}
;
}
else
if
(
tippyTopIcon
|
|
link
.
type
=
=
=
SPOC_TYPE
|
|
faviconSize
>
=
MIN_RICH_FAVICON_SIZE
)
{
imageClassName
=
"
top
-
site
-
icon
rich
-
icon
"
;
imageStyle
=
{
backgroundColor
:
link
.
backgroundColor
backgroundImage
:
url
(
{
tippyTopIcon
|
|
link
.
favicon
}
)
}
;
}
else
if
(
faviconSize
>
=
MIN_SMALL_FAVICON_SIZE
)
{
showSmallFavicon
=
true
;
smallFaviconStyle
=
{
backgroundImage
:
url
(
{
link
.
favicon
}
)
}
;
}
else
{
selectedColor
=
this
.
generateColor
(
)
;
imageClassName
=
"
"
;
}
return
{
showSmallFavicon
smallFaviconStyle
imageStyle
imageClassName
selectedColor
}
;
}
shouldShowOMCHighlight
(
componentId
)
{
const
messageData
=
this
.
props
.
Messages
?
.
messageData
;
if
(
!
messageData
|
|
Object
.
keys
(
messageData
)
.
length
=
=
=
0
)
{
return
false
;
}
return
messageData
?
.
content
?
.
messageType
=
=
=
componentId
;
}
render
(
)
{
const
{
children
className
isDraggable
link
onClick
title
isAddButton
}
=
this
.
props
;
const
topSiteOuterClassName
=
top
-
site
-
outer
{
className
?
{
className
}
:
"
"
}
{
link
.
isDragged
?
"
dragged
"
:
"
"
}
{
link
.
searchTopSite
?
"
search
-
shortcut
"
:
"
"
}
;
const
[
letterFallback
]
=
title
;
const
{
showSmallFavicon
smallFaviconStyle
imageStyle
imageClassName
selectedColor
}
=
this
.
calculateStyle
(
)
;
const
addButtonLabell10n
=
{
"
data
-
l10n
-
id
"
:
"
newtab
-
topsites
-
add
-
shortcut
-
label
"
}
;
const
addButtonTitlel10n
=
{
"
data
-
l10n
-
id
"
:
"
newtab
-
topsites
-
add
-
shortcut
-
title
"
}
;
const
addPinnedTitlel10n
=
{
"
data
-
l10n
-
id
"
:
"
topsite
-
label
-
pinned
"
"
data
-
l10n
-
args
"
:
JSON
.
stringify
(
{
title
}
)
}
;
let
draggableProps
=
{
}
;
if
(
isDraggable
)
{
draggableProps
=
{
onClick
:
this
.
onDragEvent
onDragEnd
:
this
.
onDragEvent
onDragStart
:
this
.
onDragEvent
onMouseDown
:
this
.
onDragEvent
}
;
}
let
impressionStats
=
null
;
if
(
link
.
type
=
=
=
SPOC_TYPE
)
{
impressionStats
=
external_React_default
(
)
.
createElement
(
ImpressionStats_ImpressionStats
{
flightId
:
link
.
flightId
rows
:
[
{
id
:
link
.
id
pos
:
link
.
pos
shim
:
link
.
shim
&
&
link
.
shim
.
impression
advertiser
:
title
.
toLocaleLowerCase
(
)
}
]
dispatch
:
this
.
props
.
dispatch
source
:
TOP_SITES_SOURCE
}
)
;
}
else
if
(
isSponsored
(
link
)
)
{
impressionStats
=
external_React_default
(
)
.
createElement
(
TopSiteImpressionWrapper
{
actionType
:
actionTypes
.
TOP_SITES_SPONSORED_IMPRESSION_STATS
tile
:
{
position
:
this
.
props
.
index
tile_id
:
link
.
sponsored_tile_id
|
|
-
1
reporting_url
:
link
.
sponsored_impression_url
advertiser
:
title
.
toLocaleLowerCase
(
)
source
:
NEWTAB_SOURCE
}
IntersectionObserver
:
this
.
props
.
IntersectionObserver
document
:
this
.
props
.
document
dispatch
:
this
.
props
.
dispatch
}
)
;
}
else
{
impressionStats
=
external_React_default
(
)
.
createElement
(
TopSiteImpressionWrapper
{
actionType
:
actionTypes
.
TOP_SITES_ORGANIC_IMPRESSION_STATS
tile
:
{
position
:
this
.
props
.
index
source
:
NEWTAB_SOURCE
isPinned
:
this
.
props
.
link
.
isPinned
guid
:
this
.
props
.
link
.
guid
}
IntersectionObserver
:
this
.
props
.
IntersectionObserver
document
:
this
.
props
.
document
dispatch
:
this
.
props
.
dispatch
}
)
;
}
return
external_React_default
(
)
.
createElement
(
"
li
"
TopSite_extends
(
{
className
:
topSiteOuterClassName
onDrop
:
this
.
onDragEvent
onDragOver
:
this
.
onDragEvent
onDragEnter
:
this
.
onDragEvent
onDragLeave
:
this
.
onDragEvent
ref
:
this
.
props
.
setRef
}
draggableProps
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
top
-
site
-
inner
"
}
external_React_default
(
)
.
createElement
(
"
a
"
TopSite_extends
(
{
className
:
"
top
-
site
-
button
"
href
:
link
.
searchTopSite
?
undefined
:
link
.
url
tabIndex
:
this
.
props
.
tabIndex
onKeyPress
:
this
.
onKeyPress
onClick
:
onClick
draggable
:
true
"
data
-
is
-
sponsored
-
link
"
:
!
!
link
.
sponsored_tile_id
onFocus
:
this
.
props
.
onFocus
"
aria
-
label
"
:
link
.
isPinned
?
undefined
:
title
}
isAddButton
&
&
{
.
.
.
addButtonTitlel10n
}
!
isAddButton
&
&
{
title
}
link
.
isPinned
&
&
{
.
.
.
addPinnedTitlel10n
}
{
"
data
-
l10n
-
args
"
:
JSON
.
stringify
(
{
title
}
)
}
)
link
.
isPinned
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
icon
icon
-
pin
-
small
"
}
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
tile
"
"
aria
-
hidden
"
:
true
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
selectedColor
?
"
icon
-
wrapper
letter
-
fallback
"
:
"
icon
-
wrapper
"
"
data
-
fallback
"
:
letterFallback
style
:
selectedColor
?
{
backgroundColor
:
selectedColor
}
:
{
}
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
imageClassName
style
:
imageStyle
}
)
showSmallFavicon
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
top
-
site
-
icon
default
-
icon
"
"
data
-
fallback
"
:
smallFaviconStyle
?
"
"
:
letterFallback
style
:
smallFaviconStyle
}
)
)
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
title
{
link
.
isPinned
?
"
has
-
icon
pinned
"
:
"
"
}
{
link
.
type
=
=
=
SPOC_TYPE
|
|
link
.
show_sponsored_label
?
"
sponsored
"
:
"
"
}
}
external_React_default
(
)
.
createElement
(
"
span
"
TopSite_extends
(
{
className
:
"
title
-
label
"
dir
:
"
auto
"
}
isAddButton
&
&
{
.
.
.
addButtonLabell10n
}
)
link
.
searchTopSite
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
top
-
site
-
icon
search
-
topsite
"
}
)
title
|
|
external_React_default
(
)
.
createElement
(
"
br
"
null
)
)
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
sponsored
-
label
"
"
data
-
l10n
-
id
"
:
"
newtab
-
topsite
-
sponsored
"
}
)
)
)
isAddButton
&
&
this
.
shouldShowOMCHighlight
(
"
ShortcutHighlight
"
)
&
&
external_React_default
(
)
.
createElement
(
MessageWrapper
{
dispatch
:
this
.
props
.
dispatch
onClick
:
e
=
>
e
.
stopPropagation
(
)
}
external_React_default
(
)
.
createElement
(
ShortcutFeatureHighlight
{
dispatch
:
this
.
props
.
dispatch
feature
:
"
FEATURE_SHORTCUT_HIGHLIGHT
"
position
:
"
inset
-
block
-
end
inset
-
inline
-
start
"
}
)
)
children
impressionStats
)
)
;
}
}
TopSiteLink
.
defaultProps
=
{
title
:
"
"
link
:
{
}
isDraggable
:
true
}
;
class
TopSite
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
state
=
{
showContextMenu
:
false
}
;
this
.
onLinkClick
=
this
.
onLinkClick
.
bind
(
this
)
;
this
.
onMenuUpdate
=
this
.
onMenuUpdate
.
bind
(
this
)
;
}
_getTelemetryInfo
(
)
{
const
value
=
{
icon_type
:
this
.
props
.
link
.
iconType
}
;
if
(
this
.
props
.
link
.
isPinned
)
{
value
.
card_type
=
"
pinned
"
;
}
if
(
this
.
props
.
link
.
searchTopSite
)
{
value
.
card_type
=
"
search
"
;
value
.
search_vendor
=
this
.
props
.
link
.
hostname
;
}
if
(
isSponsored
(
this
.
props
.
link
)
)
{
value
.
card_type
=
"
spoc
"
;
}
return
{
value
}
;
}
userEvent
(
event
)
{
this
.
props
.
dispatch
(
actionCreators
.
UserEvent
(
Object
.
assign
(
{
event
source
:
TOP_SITES_SOURCE
action_position
:
this
.
props
.
index
}
this
.
_getTelemetryInfo
(
)
)
)
)
;
}
onLinkClick
(
event
)
{
this
.
userEvent
(
"
CLICK
"
)
;
event
.
preventDefault
(
)
;
const
{
altKey
button
ctrlKey
metaKey
shiftKey
}
=
event
;
if
(
!
this
.
props
.
link
.
searchTopSite
)
{
this
.
props
.
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
OPEN_LINK
data
:
Object
.
assign
(
this
.
props
.
link
{
event
:
{
altKey
button
ctrlKey
metaKey
shiftKey
}
}
)
}
)
)
;
if
(
this
.
props
.
link
.
type
=
=
=
SPOC_TYPE
)
{
this
.
props
.
dispatch
(
actionCreators
.
ImpressionStats
(
{
source
:
TOP_SITES_SOURCE
click
:
0
tiles
:
[
{
id
:
this
.
props
.
link
.
id
pos
:
this
.
props
.
link
.
pos
shim
:
this
.
props
.
link
.
shim
&
&
this
.
props
.
link
.
shim
.
click
}
]
}
)
)
;
this
.
props
.
dispatch
(
actionCreators
.
DiscoveryStreamUserEvent
(
{
event
:
"
CLICK
"
source
:
TOP_SITES_SOURCE
action_position
:
this
.
props
.
link
.
pos
value
:
{
card_type
:
"
spoc
"
tile_id
:
this
.
props
.
link
.
id
shim
:
this
.
props
.
link
.
shim
&
&
this
.
props
.
link
.
shim
.
click
}
}
)
)
;
const
title
=
this
.
props
.
link
.
label
|
|
this
.
props
.
link
.
hostname
;
this
.
props
.
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
TOP_SITES_SPONSORED_IMPRESSION_STATS
data
:
{
type
:
"
click
"
position
:
this
.
props
.
link
.
pos
tile_id
:
this
.
props
.
link
.
id
advertiser
:
title
.
toLocaleLowerCase
(
)
source
:
NEWTAB_SOURCE
}
}
)
)
;
}
else
if
(
isSponsored
(
this
.
props
.
link
)
)
{
const
title
=
this
.
props
.
link
.
label
|
|
this
.
props
.
link
.
hostname
;
this
.
props
.
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
TOP_SITES_SPONSORED_IMPRESSION_STATS
data
:
{
type
:
"
click
"
position
:
this
.
props
.
index
tile_id
:
this
.
props
.
link
.
sponsored_tile_id
|
|
-
1
reporting_url
:
this
.
props
.
link
.
sponsored_click_url
advertiser
:
title
.
toLocaleLowerCase
(
)
source
:
NEWTAB_SOURCE
}
}
)
)
;
}
else
{
this
.
props
.
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
TOP_SITES_ORGANIC_IMPRESSION_STATS
data
:
{
type
:
"
click
"
position
:
this
.
props
.
index
source
:
NEWTAB_SOURCE
isPinned
:
this
.
props
.
link
.
isPinned
guid
:
this
.
props
.
link
.
guid
}
}
)
)
;
}
if
(
this
.
props
.
link
.
sendAttributionRequest
)
{
this
.
props
.
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
PARTNER_LINK_ATTRIBUTION
data
:
{
targetURL
:
this
.
props
.
link
.
url
source
:
"
newtab
"
}
}
)
)
;
}
}
else
{
this
.
props
.
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
FILL_SEARCH_TERM
data
:
{
label
:
this
.
props
.
link
.
label
}
}
)
)
;
}
}
onMenuUpdate
(
isOpen
)
{
if
(
isOpen
)
{
this
.
props
.
onActivate
(
this
.
props
.
index
)
;
}
else
{
this
.
props
.
onActivate
(
)
;
}
}
render
(
)
{
const
{
props
}
=
this
;
const
{
link
}
=
props
;
const
isContextMenuOpen
=
props
.
activeIndex
=
=
=
props
.
index
;
const
title
=
link
.
label
|
|
link
.
title
|
|
link
.
hostname
;
let
menuOptions
;
if
(
link
.
sponsored_position
)
{
menuOptions
=
TOP_SITES_SPONSORED_POSITION_CONTEXT_MENU_OPTIONS
;
}
else
if
(
link
.
searchTopSite
)
{
menuOptions
=
TOP_SITES_SEARCH_SHORTCUTS_CONTEXT_MENU_OPTIONS
;
}
else
if
(
link
.
type
=
=
=
SPOC_TYPE
)
{
menuOptions
=
TOP_SITES_SPOC_CONTEXT_MENU_OPTIONS
;
}
else
{
menuOptions
=
TOP_SITES_CONTEXT_MENU_OPTIONS
;
}
return
external_React_default
(
)
.
createElement
(
TopSiteLink
TopSite_extends
(
{
}
props
{
onClick
:
this
.
onLinkClick
onDragEvent
:
this
.
props
.
onDragEvent
className
:
{
props
.
className
|
|
"
"
}
{
isContextMenuOpen
?
"
active
"
:
"
"
}
title
:
title
setPref
:
this
.
props
.
setPref
tabIndex
:
this
.
props
.
tabIndex
onFocus
:
this
.
props
.
onFocus
}
)
external_React_default
(
)
.
createElement
(
"
div
"
null
external_React_default
(
)
.
createElement
(
ContextMenuButton
{
tooltip
:
"
newtab
-
menu
-
content
-
tooltip
"
tooltipArgs
:
{
title
}
onUpdate
:
this
.
onMenuUpdate
tabIndex
:
this
.
props
.
tabIndex
onFocus
:
this
.
props
.
onFocus
}
external_React_default
(
)
.
createElement
(
LinkMenu
{
dispatch
:
props
.
dispatch
index
:
props
.
index
onUpdate
:
this
.
onMenuUpdate
options
:
menuOptions
site
:
link
shouldSendImpressionStats
:
link
.
type
=
=
=
SPOC_TYPE
siteInfo
:
this
.
_getTelemetryInfo
(
)
source
:
TOP_SITES_SOURCE
}
)
)
)
)
;
}
}
TopSite
.
defaultProps
=
{
link
:
{
}
onActivate
(
)
{
}
}
;
class
TopSiteAddButton
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
onEditButtonClick
=
this
.
onEditButtonClick
.
bind
(
this
)
;
}
onEditButtonClick
(
)
{
this
.
props
.
dispatch
(
{
type
:
actionTypes
.
TOP_SITES_EDIT
data
:
{
index
:
this
.
props
.
index
}
}
)
;
}
render
(
)
{
return
external_React_default
(
)
.
createElement
(
TopSiteLink
TopSite_extends
(
{
}
this
.
props
{
isAddButton
:
true
className
:
add
-
button
{
this
.
props
.
className
|
|
"
"
}
onClick
:
this
.
onEditButtonClick
setPref
:
this
.
props
.
setPref
isDraggable
:
false
tabIndex
:
this
.
props
.
tabIndex
}
)
)
;
}
}
class
TopSitePlaceholder
extends
(
external_React_default
(
)
)
.
PureComponent
{
render
(
)
{
return
external_React_default
(
)
.
createElement
(
TopSiteLink
TopSite_extends
(
{
}
this
.
props
{
className
:
placeholder
{
this
.
props
.
className
|
|
"
"
}
isDraggable
:
false
}
)
)
;
}
}
class
_TopSiteList
extends
(
external_React_default
(
)
)
.
PureComponent
{
static
get
DEFAULT_STATE
(
)
{
return
{
activeIndex
:
null
draggedIndex
:
null
draggedSite
:
null
draggedTitle
:
null
topSitesPreview
:
null
focusedIndex
:
0
}
;
}
constructor
(
props
)
{
super
(
props
)
;
this
.
state
=
_TopSiteList
.
DEFAULT_STATE
;
this
.
onDragEvent
=
this
.
onDragEvent
.
bind
(
this
)
;
this
.
onActivate
=
this
.
onActivate
.
bind
(
this
)
;
this
.
onWrapperFocus
=
this
.
onWrapperFocus
.
bind
(
this
)
;
this
.
onTopsiteFocus
=
this
.
onTopsiteFocus
.
bind
(
this
)
;
this
.
onWrapperBlur
=
this
.
onWrapperBlur
.
bind
(
this
)
;
this
.
onKeyDown
=
this
.
onKeyDown
.
bind
(
this
)
;
}
componentWillReceiveProps
(
nextProps
)
{
if
(
this
.
state
.
draggedSite
)
{
const
prevTopSites
=
this
.
props
.
TopSites
&
&
this
.
props
.
TopSites
.
rows
;
const
newTopSites
=
nextProps
.
TopSites
&
&
nextProps
.
TopSites
.
rows
;
if
(
prevTopSites
&
&
prevTopSites
[
this
.
state
.
draggedIndex
]
&
&
prevTopSites
[
this
.
state
.
draggedIndex
]
.
url
=
=
=
this
.
state
.
draggedSite
.
url
&
&
(
!
newTopSites
[
this
.
state
.
draggedIndex
]
|
|
newTopSites
[
this
.
state
.
draggedIndex
]
.
url
!
=
=
this
.
state
.
draggedSite
.
url
)
)
{
this
.
setState
(
_TopSiteList
.
DEFAULT_STATE
)
;
}
}
}
userEvent
(
event
index
)
{
this
.
props
.
dispatch
(
actionCreators
.
UserEvent
(
{
event
source
:
TOP_SITES_SOURCE
action_position
:
index
}
)
)
;
}
onDragEvent
(
event
index
link
title
)
{
switch
(
event
.
type
)
{
case
"
dragstart
"
:
this
.
dropped
=
false
;
this
.
setState
(
{
draggedIndex
:
index
draggedSite
:
link
draggedTitle
:
title
activeIndex
:
null
}
)
;
this
.
userEvent
(
"
DRAG
"
index
)
;
break
;
case
"
dragend
"
:
if
(
!
this
.
dropped
)
{
this
.
setState
(
_TopSiteList
.
DEFAULT_STATE
)
;
}
break
;
case
"
dragenter
"
:
if
(
index
=
=
=
this
.
state
.
draggedIndex
)
{
this
.
setState
(
{
topSitesPreview
:
null
}
)
;
}
else
{
this
.
setState
(
{
topSitesPreview
:
this
.
_makeTopSitesPreview
(
index
)
}
)
;
}
break
;
case
"
drop
"
:
if
(
index
!
=
=
this
.
state
.
draggedIndex
)
{
this
.
dropped
=
true
;
this
.
props
.
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
TOP_SITES_INSERT
data
:
{
site
:
{
url
:
this
.
state
.
draggedSite
.
url
label
:
this
.
state
.
draggedTitle
customScreenshotURL
:
this
.
state
.
draggedSite
.
customScreenshotURL
.
.
.
(
this
.
state
.
draggedSite
.
searchTopSite
&
&
{
searchTopSite
:
true
}
)
}
index
draggedFromIndex
:
this
.
state
.
draggedIndex
}
}
)
)
;
this
.
userEvent
(
"
DROP
"
index
)
;
}
break
;
}
}
_getTopSites
(
)
{
let
topSites
=
this
.
props
.
TopSites
.
rows
.
slice
(
)
;
topSites
.
length
=
this
.
props
.
TopSitesRows
*
TOP_SITES_MAX_SITES_PER_ROW
;
let
firstPlaceholder
=
topSites
.
findIndex
(
Object
.
is
.
bind
(
null
undefined
)
)
;
if
(
firstPlaceholder
&
&
!
topSites
.
includes
(
site
=
>
site
.
isAddButton
)
)
{
topSites
[
firstPlaceholder
]
=
{
isAddButton
:
true
}
;
}
else
if
(
topSites
.
includes
(
site
=
>
site
.
isAddButton
)
)
{
topSites
.
push
(
topSites
.
splice
(
topSites
.
indexOf
(
{
isAddButton
:
true
}
)
1
)
[
0
]
)
;
}
return
topSites
;
}
_makeTopSitesPreview
(
index
)
{
const
topSites
=
this
.
_getTopSites
(
)
;
topSites
[
this
.
state
.
draggedIndex
]
=
null
;
const
preview
=
topSites
.
map
(
site
=
>
site
&
&
(
site
.
isPinned
|
|
isSponsored
(
site
)
)
?
site
:
null
)
;
const
unpinned
=
topSites
.
filter
(
site
=
>
site
&
&
!
site
.
isPinned
&
&
!
isSponsored
(
site
)
)
;
const
siteToInsert
=
Object
.
assign
(
{
}
this
.
state
.
draggedSite
{
isPinned
:
true
isDragged
:
true
}
)
;
if
(
!
preview
[
index
]
)
{
preview
[
index
]
=
siteToInsert
;
}
else
{
let
holeIndex
=
index
;
const
indexStep
=
index
>
this
.
state
.
draggedIndex
?
-
1
:
1
;
while
(
preview
[
holeIndex
]
)
{
holeIndex
+
=
indexStep
;
}
const
shiftingStep
=
index
>
this
.
state
.
draggedIndex
?
1
:
-
1
;
while
(
index
>
this
.
state
.
draggedIndex
?
holeIndex
<
index
:
holeIndex
>
index
)
{
let
nextIndex
=
holeIndex
+
shiftingStep
;
while
(
isSponsored
(
preview
[
nextIndex
]
)
)
{
nextIndex
+
=
shiftingStep
;
}
preview
[
holeIndex
]
=
preview
[
nextIndex
]
;
holeIndex
=
nextIndex
;
}
preview
[
index
]
=
siteToInsert
;
}
for
(
let
i
=
0
;
i
<
preview
.
length
;
i
+
+
)
{
if
(
!
preview
[
i
]
)
{
preview
[
i
]
=
unpinned
.
shift
(
)
|
|
null
;
}
}
return
preview
;
}
onActivate
(
index
)
{
this
.
setState
(
{
activeIndex
:
index
}
)
;
}
onKeyDown
(
e
)
{
if
(
this
.
state
.
activeIndex
|
|
this
.
state
.
activeIndex
=
=
=
0
)
{
return
;
}
if
(
e
.
key
=
=
=
"
ArrowDown
"
|
|
e
.
key
=
=
=
"
ArrowUp
"
)
{
e
.
preventDefault
(
)
;
}
if
(
this
.
focusedRef
?
.
nextSibling
?
.
querySelector
(
"
a
"
)
&
&
e
.
key
=
=
=
"
ArrowDown
"
)
{
this
.
focusedRef
.
nextSibling
.
querySelector
(
"
a
"
)
.
tabIndex
=
0
;
this
.
focusedRef
.
nextSibling
.
querySelector
(
"
a
"
)
.
focus
(
)
;
}
if
(
this
.
focusedRef
?
.
previousSibling
?
.
querySelector
(
"
a
"
)
&
&
e
.
key
=
=
=
"
ArrowUp
"
)
{
this
.
focusedRef
.
previousSibling
.
querySelector
(
"
a
"
)
.
tabIndex
=
0
;
this
.
focusedRef
.
previousSibling
.
querySelector
(
"
a
"
)
.
focus
(
)
;
}
}
onWrapperFocus
(
)
{
this
.
focusRef
?
.
addEventListener
(
"
keydown
"
this
.
onKeyDown
)
;
}
onWrapperBlur
(
)
{
this
.
focusRef
?
.
removeEventListener
(
"
keydown
"
this
.
onKeyDown
)
;
}
onTopsiteFocus
(
focusIndex
)
{
this
.
setState
(
(
)
=
>
(
{
focusedIndex
:
focusIndex
}
)
)
;
}
render
(
)
{
const
{
props
}
=
this
;
const
topSites
=
this
.
state
.
topSitesPreview
|
|
this
.
_getTopSites
(
)
;
const
topSitesUI
=
[
]
;
const
commonProps
=
{
onDragEvent
:
this
.
onDragEvent
dispatch
:
props
.
dispatch
}
;
let
holeIndex
=
0
;
const
maxNarrowVisibleIndex
=
props
.
TopSitesRows
*
6
;
for
(
let
i
=
0
l
=
topSites
.
length
;
i
<
l
;
i
+
+
)
{
const
link
=
topSites
[
i
]
&
&
Object
.
assign
(
{
}
topSites
[
i
]
{
iconType
:
this
.
props
.
topSiteIconType
(
topSites
[
i
]
)
}
)
;
const
slotProps
=
{
key
:
link
?
link
.
url
:
holeIndex
+
+
index
:
i
}
;
if
(
i
>
=
maxNarrowVisibleIndex
)
{
slotProps
.
className
=
"
hide
-
for
-
narrow
"
;
}
let
topSiteLink
;
if
(
!
link
|
|
props
.
App
.
isForStartupCache
.
TopSites
&
&
isSponsored
(
link
)
)
{
if
(
link
)
{
topSiteLink
=
external_React_default
(
)
.
createElement
(
TopSitePlaceholder
TopSite_extends
(
{
}
slotProps
commonProps
)
)
;
}
}
else
if
(
topSites
[
i
]
?
.
isAddButton
)
{
topSiteLink
=
external_React_default
(
)
.
createElement
(
TopSiteAddButton
TopSite_extends
(
{
}
slotProps
commonProps
{
setRef
:
i
=
=
=
this
.
state
.
focusedIndex
?
el
=
>
{
this
.
focusedRef
=
el
;
}
:
(
)
=
>
{
}
tabIndex
:
i
=
=
=
this
.
state
.
focusedIndex
?
0
:
-
1
onFocus
:
(
)
=
>
{
this
.
onTopsiteFocus
(
i
)
;
}
Messages
:
this
.
props
.
Messages
}
)
)
;
}
else
{
topSiteLink
=
external_React_default
(
)
.
createElement
(
TopSite
TopSite_extends
(
{
link
:
link
activeIndex
:
this
.
state
.
activeIndex
onActivate
:
this
.
onActivate
}
slotProps
commonProps
{
colors
:
props
.
colors
setRef
:
i
=
=
=
this
.
state
.
focusedIndex
?
el
=
>
{
this
.
focusedRef
=
el
;
}
:
(
)
=
>
{
}
tabIndex
:
i
=
=
=
this
.
state
.
focusedIndex
?
0
:
-
1
onFocus
:
(
)
=
>
{
this
.
onTopsiteFocus
(
i
)
;
}
}
)
)
;
}
topSitesUI
.
push
(
topSiteLink
)
;
}
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
top
-
sites
-
list
-
wrapper
"
}
external_React_default
(
)
.
createElement
(
"
ul
"
{
role
:
"
group
"
"
aria
-
label
"
:
"
Shortcuts
"
onFocus
:
this
.
onWrapperFocus
onBlur
:
this
.
onWrapperBlur
ref
:
el
=
>
{
this
.
focusRef
=
el
;
}
className
:
top
-
sites
-
list
{
this
.
state
.
draggedSite
?
"
dnd
-
active
"
:
"
"
}
}
topSitesUI
)
)
;
}
}
const
TopSiteList
=
(
0
external_ReactRedux_namespaceObject
.
connect
)
(
state
=
>
(
{
App
:
state
.
App
Messages
:
state
.
Messages
Prefs
:
state
.
Prefs
}
)
)
(
_TopSiteList
)
;
;
class
TopSiteForm
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
const
{
site
}
=
props
;
this
.
state
=
{
label
:
site
?
site
.
label
|
|
site
.
hostname
:
"
"
url
:
site
?
site
.
url
:
"
"
validationError
:
false
customScreenshotUrl
:
site
?
site
.
customScreenshotURL
:
"
"
showCustomScreenshotForm
:
site
?
site
.
customScreenshotURL
:
false
hasURLChanged
:
false
hasTitleChanged
:
false
}
;
this
.
onClearScreenshotInput
=
this
.
onClearScreenshotInput
.
bind
(
this
)
;
this
.
onLabelChange
=
this
.
onLabelChange
.
bind
(
this
)
;
this
.
onUrlChange
=
this
.
onUrlChange
.
bind
(
this
)
;
this
.
onCancelButtonClick
=
this
.
onCancelButtonClick
.
bind
(
this
)
;
this
.
onClearUrlClick
=
this
.
onClearUrlClick
.
bind
(
this
)
;
this
.
onDoneButtonClick
=
this
.
onDoneButtonClick
.
bind
(
this
)
;
this
.
onCustomScreenshotUrlChange
=
this
.
onCustomScreenshotUrlChange
.
bind
(
this
)
;
this
.
onPreviewButtonClick
=
this
.
onPreviewButtonClick
.
bind
(
this
)
;
this
.
onEnableScreenshotUrlForm
=
this
.
onEnableScreenshotUrlForm
.
bind
(
this
)
;
this
.
validateUrl
=
this
.
validateUrl
.
bind
(
this
)
;
}
onLabelChange
(
event
)
{
this
.
setState
(
{
label
:
event
.
target
.
value
hasTitleChanged
:
true
}
)
;
}
onUrlChange
(
event
)
{
this
.
setState
(
{
url
:
event
.
target
.
value
validationError
:
false
hasURLChanged
:
true
}
)
;
}
onClearUrlClick
(
)
{
this
.
setState
(
{
url
:
"
"
validationError
:
false
}
)
;
}
onEnableScreenshotUrlForm
(
)
{
this
.
setState
(
{
showCustomScreenshotForm
:
true
}
)
;
}
_updateCustomScreenshotInput
(
customScreenshotUrl
)
{
this
.
setState
(
{
customScreenshotUrl
validationError
:
false
}
)
;
this
.
props
.
dispatch
(
{
type
:
actionTypes
.
PREVIEW_REQUEST_CANCEL
}
)
;
}
onCustomScreenshotUrlChange
(
event
)
{
this
.
_updateCustomScreenshotInput
(
event
.
target
.
value
)
;
}
onClearScreenshotInput
(
)
{
this
.
_updateCustomScreenshotInput
(
"
"
)
;
}
onCancelButtonClick
(
ev
)
{
ev
.
preventDefault
(
)
;
this
.
props
.
onClose
(
)
;
}
onDoneButtonClick
(
ev
)
{
ev
.
preventDefault
(
)
;
if
(
this
.
validateForm
(
)
)
{
const
site
=
{
url
:
this
.
cleanUrl
(
this
.
state
.
url
)
}
;
const
{
index
}
=
this
.
props
;
const
isEdit
=
!
!
this
.
props
.
site
;
if
(
this
.
state
.
label
!
=
=
"
"
)
{
site
.
label
=
this
.
state
.
label
;
}
if
(
this
.
state
.
customScreenshotUrl
)
{
site
.
customScreenshotURL
=
this
.
cleanUrl
(
this
.
state
.
customScreenshotUrl
)
;
}
else
if
(
this
.
props
.
site
&
&
this
.
props
.
site
.
customScreenshotURL
)
{
site
.
customScreenshotURL
=
null
;
}
this
.
props
.
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
TOP_SITES_PIN
data
:
{
site
index
}
}
)
)
;
if
(
isEdit
)
{
this
.
props
.
dispatch
(
actionCreators
.
UserEvent
(
{
source
:
TOP_SITES_SOURCE
event
:
"
TOP_SITES_EDIT
"
action_position
:
index
hasTitleChanged
:
this
.
state
.
hasTitleChanged
hasURLChanged
:
this
.
state
.
hasURLChanged
}
)
)
;
}
else
if
(
!
isEdit
)
{
this
.
props
.
dispatch
(
actionCreators
.
UserEvent
(
{
source
:
TOP_SITES_SOURCE
event
:
"
TOP_SITES_ADD
"
action_position
:
index
}
)
)
;
}
this
.
props
.
onClose
(
)
;
}
}
onPreviewButtonClick
(
event
)
{
event
.
preventDefault
(
)
;
if
(
this
.
validateForm
(
)
)
{
this
.
props
.
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
PREVIEW_REQUEST
data
:
{
url
:
this
.
cleanUrl
(
this
.
state
.
customScreenshotUrl
)
}
}
)
)
;
this
.
props
.
dispatch
(
actionCreators
.
UserEvent
(
{
source
:
TOP_SITES_SOURCE
event
:
"
PREVIEW_REQUEST
"
}
)
)
;
}
}
cleanUrl
(
url
)
{
if
(
!
url
.
startsWith
(
"
http
:
"
)
&
&
!
url
.
startsWith
(
"
https
:
"
)
)
{
return
http
:
/
/
{
url
}
;
}
return
url
;
}
_tryParseUrl
(
url
)
{
try
{
return
new
URL
(
url
)
;
}
catch
(
e
)
{
return
null
;
}
}
validateUrl
(
url
)
{
const
validProtocols
=
[
"
http
:
"
"
https
:
"
]
;
const
urlObj
=
this
.
_tryParseUrl
(
url
)
|
|
this
.
_tryParseUrl
(
this
.
cleanUrl
(
url
)
)
;
return
urlObj
&
&
validProtocols
.
includes
(
urlObj
.
protocol
)
;
}
validateCustomScreenshotUrl
(
)
{
const
{
customScreenshotUrl
}
=
this
.
state
;
return
!
customScreenshotUrl
|
|
this
.
validateUrl
(
customScreenshotUrl
)
;
}
validateForm
(
)
{
const
validate
=
this
.
validateUrl
(
this
.
state
.
url
)
&
&
this
.
validateCustomScreenshotUrl
(
)
;
if
(
!
validate
)
{
this
.
setState
(
{
validationError
:
true
}
)
;
}
return
validate
;
}
_renderCustomScreenshotInput
(
)
{
const
{
customScreenshotUrl
}
=
this
.
state
;
const
requestFailed
=
this
.
props
.
previewResponse
=
=
=
"
"
;
const
validationError
=
this
.
state
.
validationError
&
&
!
this
.
validateCustomScreenshotUrl
(
)
|
|
requestFailed
;
const
shouldFocus
=
validationError
&
&
this
.
validateUrl
(
this
.
state
.
url
)
|
|
!
customScreenshotUrl
;
const
isLoading
=
this
.
props
.
previewResponse
=
=
=
null
&
&
customScreenshotUrl
&
&
this
.
props
.
previewUrl
=
=
=
this
.
cleanUrl
(
customScreenshotUrl
)
;
if
(
!
this
.
state
.
showCustomScreenshotForm
)
{
return
external_React_default
(
)
.
createElement
(
A11yLinkButton
{
onClick
:
this
.
onEnableScreenshotUrlForm
className
:
"
enable
-
custom
-
image
-
input
"
"
data
-
l10n
-
id
"
:
"
newtab
-
topsites
-
use
-
image
-
link
"
}
)
;
}
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
custom
-
image
-
input
-
container
"
}
external_React_default
(
)
.
createElement
(
TopSiteFormInput
{
errorMessageId
:
requestFailed
?
"
newtab
-
topsites
-
image
-
validation
"
:
"
newtab
-
topsites
-
url
-
validation
"
loading
:
isLoading
onChange
:
this
.
onCustomScreenshotUrlChange
onClear
:
this
.
onClearScreenshotInput
shouldFocus
:
shouldFocus
typeUrl
:
true
value
:
customScreenshotUrl
validationError
:
validationError
titleId
:
"
newtab
-
topsites
-
image
-
url
-
label
"
placeholderId
:
"
newtab
-
topsites
-
url
-
input
"
}
)
)
;
}
render
(
)
{
const
{
customScreenshotUrl
}
=
this
.
state
;
const
requestFailed
=
this
.
props
.
previewResponse
=
=
=
"
"
;
const
showAsAdd
=
!
this
.
props
.
site
;
const
previous
=
this
.
props
.
site
&
&
this
.
props
.
site
.
customScreenshotURL
|
|
"
"
;
const
changed
=
customScreenshotUrl
&
&
this
.
cleanUrl
(
customScreenshotUrl
)
!
=
=
previous
;
const
previewMode
=
changed
&
&
!
this
.
props
.
previewResponse
;
const
previewLink
=
Object
.
assign
(
{
}
this
.
props
.
site
)
;
if
(
this
.
props
.
previewResponse
)
{
previewLink
.
screenshot
=
this
.
props
.
previewResponse
;
previewLink
.
customScreenshotURL
=
this
.
props
.
previewUrl
;
}
const
onSubmit
=
previewMode
?
this
.
onPreviewButtonClick
:
this
.
onDoneButtonClick
;
const
addTopsitesHeaderL10nId
=
"
newtab
-
topsites
-
add
-
shortcut
-
header
"
;
const
editTopsitesHeaderL10nId
=
"
newtab
-
topsites
-
edit
-
shortcut
-
header
"
;
return
external_React_default
(
)
.
createElement
(
"
form
"
{
className
:
"
topsite
-
form
"
onSubmit
:
onSubmit
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
form
-
input
-
container
"
}
external_React_default
(
)
.
createElement
(
"
h3
"
{
className
:
"
section
-
title
grey
-
title
"
"
data
-
l10n
-
id
"
:
showAsAdd
?
addTopsitesHeaderL10nId
:
editTopsitesHeaderL10nId
}
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
fields
-
and
-
preview
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
form
-
wrapper
"
}
external_React_default
(
)
.
createElement
(
TopSiteFormInput
{
onChange
:
this
.
onLabelChange
value
:
this
.
state
.
label
titleId
:
"
newtab
-
topsites
-
title
-
label
"
placeholderId
:
"
newtab
-
topsites
-
title
-
input
"
autoFocusOnOpen
:
true
}
)
external_React_default
(
)
.
createElement
(
TopSiteFormInput
{
onChange
:
this
.
onUrlChange
shouldFocus
:
this
.
state
.
validationError
&
&
!
this
.
validateUrl
(
this
.
state
.
url
)
value
:
this
.
state
.
url
onClear
:
this
.
onClearUrlClick
validationError
:
this
.
state
.
validationError
&
&
!
this
.
validateUrl
(
this
.
state
.
url
)
titleId
:
"
newtab
-
topsites
-
url
-
label
"
typeUrl
:
true
placeholderId
:
"
newtab
-
topsites
-
url
-
input
"
errorMessageId
:
"
newtab
-
topsites
-
url
-
validation
"
}
)
this
.
_renderCustomScreenshotInput
(
)
)
external_React_default
(
)
.
createElement
(
TopSiteLink
{
link
:
previewLink
defaultStyle
:
requestFailed
title
:
this
.
state
.
label
}
)
)
)
external_React_default
(
)
.
createElement
(
"
section
"
{
className
:
"
actions
"
}
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
"
cancel
"
type
:
"
button
"
onClick
:
this
.
onCancelButtonClick
"
data
-
l10n
-
id
"
:
"
newtab
-
topsites
-
cancel
-
button
"
}
)
previewMode
?
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
"
done
preview
"
type
:
"
submit
"
"
data
-
l10n
-
id
"
:
"
newtab
-
topsites
-
preview
-
button
"
}
)
:
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
"
done
"
type
:
"
submit
"
"
data
-
l10n
-
id
"
:
showAsAdd
?
"
newtab
-
topsites
-
add
-
button
"
:
"
newtab
-
topsites
-
save
-
button
"
}
)
)
)
;
}
}
TopSiteForm
.
defaultProps
=
{
site
:
null
index
:
-
1
}
;
;
function
TopSites_extends
(
)
{
return
TopSites_extends
=
Object
.
assign
?
Object
.
assign
.
bind
(
)
:
function
(
n
)
{
for
(
var
e
=
1
;
e
<
arguments
.
length
;
e
+
+
)
{
var
t
=
arguments
[
e
]
;
for
(
var
r
in
t
)
(
{
}
)
.
hasOwnProperty
.
call
(
t
r
)
&
&
(
n
[
r
]
=
t
[
r
]
)
;
}
return
n
;
}
TopSites_extends
.
apply
(
null
arguments
)
;
}
function
topSiteIconType
(
link
)
{
if
(
link
.
customScreenshotURL
)
{
return
"
custom_screenshot
"
;
}
if
(
link
.
tippyTopIcon
|
|
link
.
faviconRef
=
=
=
"
tippytop
"
)
{
return
"
tippytop
"
;
}
if
(
link
.
faviconSize
>
=
MIN_RICH_FAVICON_SIZE
)
{
return
"
rich_icon
"
;
}
if
(
link
.
screenshot
)
{
return
"
screenshot
"
;
}
return
"
no_image
"
;
}
function
countTopSitesIconsTypes
(
topSites
)
{
const
countTopSitesTypes
=
(
acc
link
)
=
>
{
acc
[
topSiteIconType
(
link
)
]
+
+
;
return
acc
;
}
;
return
topSites
.
reduce
(
countTopSitesTypes
{
custom_screenshot
:
0
screenshot
:
0
tippytop
:
0
rich_icon
:
0
no_image
:
0
}
)
;
}
class
_TopSites
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
onEditFormClose
=
this
.
onEditFormClose
.
bind
(
this
)
;
this
.
onSearchShortcutsFormClose
=
this
.
onSearchShortcutsFormClose
.
bind
(
this
)
;
}
_dispatchTopSitesStats
(
)
{
const
topSites
=
this
.
_getVisibleTopSites
(
)
.
filter
(
topSite
=
>
topSite
!
=
=
null
&
&
topSite
!
=
=
undefined
)
;
const
topSitesIconsStats
=
countTopSitesIconsTypes
(
topSites
)
;
const
topSitesPinned
=
topSites
.
filter
(
site
=
>
!
!
site
.
isPinned
)
.
length
;
const
searchShortcuts
=
topSites
.
filter
(
site
=
>
!
!
site
.
searchTopSite
)
.
length
;
this
.
props
.
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
SAVE_SESSION_PERF_DATA
data
:
{
topsites_icon_stats
:
topSitesIconsStats
topsites_pinned
:
topSitesPinned
topsites_search_shortcuts
:
searchShortcuts
}
}
)
)
;
}
_getVisibleTopSites
(
)
{
let
sitesPerRow
=
TOP_SITES_MAX_SITES_PER_ROW
;
if
(
!
globalThis
.
matchMedia
(
(
min
-
width
:
1072px
)
)
.
matches
)
{
sitesPerRow
-
=
2
;
}
return
this
.
props
.
TopSites
.
rows
.
slice
(
0
this
.
props
.
TopSitesRows
*
sitesPerRow
)
;
}
componentDidUpdate
(
)
{
this
.
_dispatchTopSitesStats
(
)
;
}
componentDidMount
(
)
{
this
.
_dispatchTopSitesStats
(
)
;
}
onEditFormClose
(
)
{
this
.
props
.
dispatch
(
actionCreators
.
UserEvent
(
{
source
:
TOP_SITES_SOURCE
event
:
"
TOP_SITES_EDIT_CLOSE
"
}
)
)
;
this
.
props
.
dispatch
(
{
type
:
actionTypes
.
TOP_SITES_CANCEL_EDIT
}
)
;
}
onSearchShortcutsFormClose
(
)
{
this
.
props
.
dispatch
(
actionCreators
.
UserEvent
(
{
source
:
TOP_SITES_SOURCE
event
:
"
SEARCH_EDIT_CLOSE
"
}
)
)
;
this
.
props
.
dispatch
(
{
type
:
actionTypes
.
TOP_SITES_CLOSE_SEARCH_SHORTCUTS_MODAL
}
)
;
}
render
(
)
{
const
{
props
}
=
this
;
const
{
editForm
showSearchShortcutsForm
}
=
props
.
TopSites
;
const
extraMenuOptions
=
[
"
AddTopSite
"
]
;
const
colors
=
props
.
Prefs
.
values
[
"
newNewtabExperience
.
colors
"
]
;
if
(
props
.
Prefs
.
values
[
"
improvesearch
.
topSiteSearchShortcuts
"
]
)
{
extraMenuOptions
.
push
(
"
AddSearchShortcut
"
)
;
}
return
external_React_default
(
)
.
createElement
(
ComponentPerfTimer
{
id
:
"
topsites
"
initialized
:
props
.
TopSites
.
initialized
dispatch
:
props
.
dispatch
}
external_React_default
(
)
.
createElement
(
CollapsibleSection
{
className
:
"
top
-
sites
"
id
:
"
topsites
"
title
:
props
.
title
|
|
{
id
:
"
newtab
-
section
-
header
-
topsites
"
}
hideTitle
:
true
extraMenuOptions
:
extraMenuOptions
showPrefName
:
"
feeds
.
topsites
"
eventSource
:
TOP_SITES_SOURCE
collapsed
:
false
isFixed
:
props
.
isFixed
isFirst
:
props
.
isFirst
isLast
:
props
.
isLast
dispatch
:
props
.
dispatch
}
external_React_default
(
)
.
createElement
(
TopSiteList
{
TopSites
:
props
.
TopSites
TopSitesRows
:
props
.
TopSitesRows
dispatch
:
props
.
dispatch
topSiteIconType
:
topSiteIconType
colors
:
colors
}
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
edit
-
topsites
-
wrapper
"
}
editForm
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
edit
-
topsites
"
}
external_React_default
(
)
.
createElement
(
ModalOverlayWrapper
{
unstyled
:
true
onClose
:
this
.
onEditFormClose
innerClassName
:
"
modal
"
}
external_React_default
(
)
.
createElement
(
TopSiteForm
TopSites_extends
(
{
site
:
props
.
TopSites
.
rows
[
editForm
.
index
]
onClose
:
this
.
onEditFormClose
dispatch
:
this
.
props
.
dispatch
}
editForm
)
)
)
)
showSearchShortcutsForm
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
edit
-
search
-
shortcuts
"
}
external_React_default
(
)
.
createElement
(
ModalOverlayWrapper
{
unstyled
:
true
onClose
:
this
.
onSearchShortcutsFormClose
innerClassName
:
"
modal
"
}
external_React_default
(
)
.
createElement
(
SearchShortcutsForm
{
TopSites
:
props
.
TopSites
onClose
:
this
.
onSearchShortcutsFormClose
dispatch
:
this
.
props
.
dispatch
}
)
)
)
)
)
)
;
}
}
const
TopSites_TopSites
=
(
0
external_ReactRedux_namespaceObject
.
connect
)
(
state
=
>
(
{
TopSites
:
state
.
TopSites
Prefs
:
state
.
Prefs
TopSitesRows
:
state
.
Prefs
.
values
.
topSitesRows
}
)
)
(
_TopSites
)
;
;
function
Sections_extends
(
)
{
return
Sections_extends
=
Object
.
assign
?
Object
.
assign
.
bind
(
)
:
function
(
n
)
{
for
(
var
e
=
1
;
e
<
arguments
.
length
;
e
+
+
)
{
var
t
=
arguments
[
e
]
;
for
(
var
r
in
t
)
(
{
}
)
.
hasOwnProperty
.
call
(
t
r
)
&
&
(
n
[
r
]
=
t
[
r
]
)
;
}
return
n
;
}
Sections_extends
.
apply
(
null
arguments
)
;
}
const
Sections_VISIBLE
=
"
visible
"
;
const
Sections_VISIBILITY_CHANGE_EVENT
=
"
visibilitychange
"
;
const
CARDS_PER_ROW_DEFAULT
=
3
;
const
CARDS_PER_ROW_COMPACT_WIDE
=
4
;
class
Section
extends
(
external_React_default
(
)
)
.
PureComponent
{
get
numRows
(
)
{
const
{
rowsPref
maxRows
Prefs
}
=
this
.
props
;
return
rowsPref
?
Prefs
.
values
[
rowsPref
]
:
maxRows
;
}
_dispatchImpressionStats
(
)
{
const
{
props
}
=
this
;
let
cardsPerRow
=
CARDS_PER_ROW_DEFAULT
;
if
(
props
.
compactCards
&
&
globalThis
.
matchMedia
(
(
min
-
width
:
1072px
)
)
.
matches
)
{
cardsPerRow
=
CARDS_PER_ROW_COMPACT_WIDE
;
}
const
maxCards
=
cardsPerRow
*
this
.
numRows
;
const
cards
=
props
.
rows
.
slice
(
0
maxCards
)
;
if
(
this
.
needsImpressionStats
(
cards
)
)
{
props
.
dispatch
(
actionCreators
.
ImpressionStats
(
{
source
:
props
.
eventSource
tiles
:
cards
.
map
(
link
=
>
(
{
id
:
link
.
guid
}
)
)
}
)
)
;
this
.
impressionCardGuids
=
cards
.
map
(
link
=
>
link
.
guid
)
;
}
}
sendImpressionStatsOrAddListener
(
)
{
const
{
props
}
=
this
;
if
(
!
props
.
shouldSendImpressionStats
|
|
!
props
.
dispatch
)
{
return
;
}
if
(
props
.
document
.
visibilityState
=
=
=
Sections_VISIBLE
)
{
this
.
_dispatchImpressionStats
(
)
;
}
else
{
if
(
this
.
_onVisibilityChange
)
{
props
.
document
.
removeEventListener
(
Sections_VISIBILITY_CHANGE_EVENT
this
.
_onVisibilityChange
)
;
}
this
.
_onVisibilityChange
=
(
)
=
>
{
if
(
props
.
document
.
visibilityState
=
=
=
Sections_VISIBLE
)
{
if
(
!
this
.
props
.
pref
.
collapsed
)
{
this
.
_dispatchImpressionStats
(
)
;
}
props
.
document
.
removeEventListener
(
Sections_VISIBILITY_CHANGE_EVENT
this
.
_onVisibilityChange
)
;
}
}
;
props
.
document
.
addEventListener
(
Sections_VISIBILITY_CHANGE_EVENT
this
.
_onVisibilityChange
)
;
}
}
componentWillMount
(
)
{
this
.
sendNewTabRehydrated
(
this
.
props
.
initialized
)
;
}
componentDidMount
(
)
{
if
(
this
.
props
.
rows
.
length
&
&
!
this
.
props
.
pref
.
collapsed
)
{
this
.
sendImpressionStatsOrAddListener
(
)
;
}
}
componentDidUpdate
(
prevProps
)
{
const
{
props
}
=
this
;
const
isCollapsed
=
props
.
pref
.
collapsed
;
const
wasCollapsed
=
prevProps
.
pref
.
collapsed
;
if
(
props
.
rows
.
length
&
&
(
props
.
rows
!
=
=
prevProps
.
rows
&
&
!
isCollapsed
|
|
wasCollapsed
&
&
!
isCollapsed
)
)
{
this
.
sendImpressionStatsOrAddListener
(
)
;
}
}
componentWillUpdate
(
nextProps
)
{
this
.
sendNewTabRehydrated
(
nextProps
.
initialized
)
;
}
componentWillUnmount
(
)
{
if
(
this
.
_onVisibilityChange
)
{
this
.
props
.
document
.
removeEventListener
(
Sections_VISIBILITY_CHANGE_EVENT
this
.
_onVisibilityChange
)
;
}
}
needsImpressionStats
(
cards
)
{
if
(
!
this
.
impressionCardGuids
|
|
this
.
impressionCardGuids
.
length
!
=
=
cards
.
length
)
{
return
true
;
}
for
(
let
i
=
0
;
i
<
cards
.
length
;
i
+
+
)
{
if
(
cards
[
i
]
.
guid
!
=
=
this
.
impressionCardGuids
[
i
]
)
{
return
true
;
}
}
return
false
;
}
sendNewTabRehydrated
(
initialized
)
{
if
(
initialized
&
&
!
this
.
renderNotified
)
{
this
.
props
.
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
NEW_TAB_REHYDRATED
data
:
{
}
}
)
)
;
this
.
renderNotified
=
true
;
}
}
render
(
)
{
const
{
id
eventSource
title
rows
emptyState
dispatch
compactCards
read_more_endpoint
contextMenuOptions
initialized
learnMore
pref
privacyNoticeURL
isFirst
isLast
}
=
this
.
props
;
const
waitingForSpoc
=
id
=
=
=
"
topstories
"
&
&
this
.
props
.
Pocket
.
waitingForSpoc
;
const
maxCardsPerRow
=
compactCards
?
CARDS_PER_ROW_COMPACT_WIDE
:
CARDS_PER_ROW_DEFAULT
;
const
{
numRows
}
=
this
;
const
maxCards
=
maxCardsPerRow
*
numRows
;
const
maxCardsOnNarrow
=
CARDS_PER_ROW_DEFAULT
*
numRows
;
const
shouldShowReadMore
=
read_more_endpoint
;
const
realRows
=
rows
.
slice
(
0
maxCards
)
;
const
shouldShowEmptyState
=
initialized
&
&
!
rows
.
length
;
const
cards
=
[
]
;
if
(
!
shouldShowEmptyState
)
{
for
(
let
i
=
0
;
i
<
maxCards
;
i
+
+
)
{
const
link
=
realRows
[
i
]
;
const
className
=
i
>
=
maxCardsOnNarrow
?
"
hide
-
for
-
narrow
"
:
"
"
;
let
usePlaceholder
=
!
link
;
if
(
!
usePlaceholder
&
&
i
=
=
=
2
&
&
waitingForSpoc
)
{
usePlaceholder
=
true
;
}
cards
.
push
(
!
usePlaceholder
?
external_React_default
(
)
.
createElement
(
Card
{
key
:
i
index
:
i
className
:
className
dispatch
:
dispatch
link
:
link
contextMenuOptions
:
contextMenuOptions
eventSource
:
eventSource
shouldSendImpressionStats
:
this
.
props
.
shouldSendImpressionStats
isWebExtension
:
this
.
props
.
isWebExtension
}
)
:
external_React_default
(
)
.
createElement
(
PlaceholderCard
{
key
:
i
className
:
className
}
)
)
;
}
}
const
sectionClassName
=
[
"
section
"
compactCards
?
"
compact
-
cards
"
:
"
normal
-
cards
"
]
.
join
(
"
"
)
;
return
external_React_default
(
)
.
createElement
(
ComponentPerfTimer
this
.
props
external_React_default
(
)
.
createElement
(
CollapsibleSection
{
className
:
sectionClassName
title
:
title
id
:
id
eventSource
:
eventSource
collapsed
:
this
.
props
.
pref
.
collapsed
showPrefName
:
pref
&
&
pref
.
feed
|
|
id
privacyNoticeURL
:
privacyNoticeURL
Prefs
:
this
.
props
.
Prefs
isFixed
:
this
.
props
.
isFixed
isFirst
:
isFirst
isLast
:
isLast
learnMore
:
learnMore
dispatch
:
this
.
props
.
dispatch
isWebExtension
:
this
.
props
.
isWebExtension
}
!
shouldShowEmptyState
&
&
external_React_default
(
)
.
createElement
(
"
ul
"
{
className
:
"
section
-
list
"
style
:
{
padding
:
0
}
}
cards
)
shouldShowEmptyState
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
section
-
empty
-
state
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
empty
-
state
"
}
external_React_default
(
)
.
createElement
(
FluentOrText
{
message
:
emptyState
.
message
}
external_React_default
(
)
.
createElement
(
"
p
"
{
className
:
"
empty
-
state
-
message
"
}
)
)
)
)
id
=
=
=
"
topstories
"
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
top
-
stories
-
bottom
-
container
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
wrapper
-
more
-
recommendations
"
}
shouldShowReadMore
&
&
external_React_default
(
)
.
createElement
(
MoreRecommendations
{
read_more_endpoint
:
read_more_endpoint
}
)
)
)
)
)
;
}
}
Section
.
defaultProps
=
{
document
:
globalThis
.
document
rows
:
[
]
emptyState
:
{
}
pref
:
{
}
title
:
"
"
}
;
const
SectionIntl
=
(
0
external_ReactRedux_namespaceObject
.
connect
)
(
state
=
>
(
{
Prefs
:
state
.
Prefs
Pocket
:
state
.
Pocket
}
)
)
(
Section
)
;
class
_Sections
extends
(
external_React_default
(
)
)
.
PureComponent
{
renderSections
(
)
{
const
sections
=
[
]
;
const
enabledSections
=
this
.
props
.
Sections
.
filter
(
section
=
>
section
.
enabled
)
;
const
{
sectionOrder
"
feeds
.
topsites
"
:
showTopSites
}
=
this
.
props
.
Prefs
.
values
;
const
expectedCount
=
enabledSections
.
length
+
~
~
showTopSites
;
for
(
const
sectionId
of
sectionOrder
.
split
(
"
"
)
)
{
const
commonProps
=
{
key
:
sectionId
isFirst
:
sections
.
length
=
=
=
0
isLast
:
sections
.
length
=
=
=
expectedCount
-
1
}
;
if
(
sectionId
=
=
=
"
topsites
"
&
&
showTopSites
)
{
sections
.
push
(
external_React_default
(
)
.
createElement
(
TopSites_TopSites
commonProps
)
)
;
}
else
{
const
section
=
enabledSections
.
find
(
s
=
>
s
.
id
=
=
=
sectionId
)
;
if
(
section
)
{
sections
.
push
(
external_React_default
(
)
.
createElement
(
SectionIntl
Sections_extends
(
{
}
section
commonProps
)
)
)
;
}
}
}
return
sections
;
}
render
(
)
{
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
sections
-
list
"
}
this
.
renderSections
(
)
)
;
}
}
const
Sections_Sections
=
(
0
external_ReactRedux_namespaceObject
.
connect
)
(
state
=
>
(
{
Sections
:
state
.
Sections
Prefs
:
state
.
Prefs
}
)
)
(
_Sections
)
;
;
function
Highlights_extends
(
)
{
return
Highlights_extends
=
Object
.
assign
?
Object
.
assign
.
bind
(
)
:
function
(
n
)
{
for
(
var
e
=
1
;
e
<
arguments
.
length
;
e
+
+
)
{
var
t
=
arguments
[
e
]
;
for
(
var
r
in
t
)
(
{
}
)
.
hasOwnProperty
.
call
(
t
r
)
&
&
(
n
[
r
]
=
t
[
r
]
)
;
}
return
n
;
}
Highlights_extends
.
apply
(
null
arguments
)
;
}
class
_Highlights
extends
(
external_React_default
(
)
)
.
PureComponent
{
render
(
)
{
const
section
=
this
.
props
.
Sections
.
find
(
s
=
>
s
.
id
=
=
=
"
highlights
"
)
;
if
(
!
section
|
|
!
section
.
enabled
)
{
return
null
;
}
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
ds
-
highlights
sections
-
list
"
}
external_React_default
(
)
.
createElement
(
SectionIntl
Highlights_extends
(
{
}
section
{
isFixed
:
true
}
)
)
)
;
}
}
const
Highlights
=
(
0
external_ReactRedux_namespaceObject
.
connect
)
(
state
=
>
(
{
Sections
:
state
.
Sections
}
)
)
(
_Highlights
)
;
;
class
HorizontalRule
extends
(
external_React_default
(
)
)
.
PureComponent
{
render
(
)
{
return
external_React_default
(
)
.
createElement
(
"
hr
"
{
className
:
"
ds
-
hr
"
}
)
;
}
}
;
class
Topic
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
onLinkClick
=
this
.
onLinkClick
.
bind
(
this
)
;
}
onLinkClick
(
event
)
{
if
(
this
.
props
.
dispatch
)
{
this
.
props
.
dispatch
(
actionCreators
.
DiscoveryStreamUserEvent
(
{
event
:
"
CLICK
"
source
:
"
POPULAR_TOPICS
"
action_position
:
0
value
:
{
topic
:
event
.
target
.
text
.
toLowerCase
(
)
.
replace
(
-
)
}
}
)
)
;
}
}
render
(
)
{
const
{
url
name
:
topicName
}
=
this
.
props
;
return
external_React_default
(
)
.
createElement
(
SafeAnchor
{
onLinkClick
:
this
.
onLinkClick
className
:
this
.
props
.
className
url
:
url
}
topicName
)
;
}
}
class
Navigation
extends
(
external_React_default
(
)
)
.
PureComponent
{
render
(
)
{
let
links
=
this
.
props
.
links
|
|
[
]
;
const
alignment
=
this
.
props
.
alignment
|
|
"
centered
"
;
const
header
=
this
.
props
.
header
|
|
{
}
;
const
english
=
this
.
props
.
locale
.
startsWith
(
"
en
-
"
)
;
const
privacyNotice
=
this
.
props
.
privacyNoticeURL
|
|
{
}
;
const
{
newFooterSection
}
=
this
.
props
;
const
className
=
ds
-
navigation
ds
-
navigation
-
{
alignment
}
{
newFooterSection
?
ds
-
navigation
-
new
-
topics
:
}
;
let
{
title
}
=
header
;
if
(
newFooterSection
)
{
title
=
{
id
:
"
newtab
-
pocket
-
new
-
topics
-
title
"
}
;
if
(
this
.
props
.
extraLinks
)
{
links
=
[
.
.
.
links
.
slice
(
0
links
.
length
-
1
)
.
.
.
this
.
props
.
extraLinks
links
[
links
.
length
-
1
]
]
;
}
}
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
className
}
title
&
&
english
?
external_React_default
(
)
.
createElement
(
FluentOrText
{
message
:
title
}
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
ds
-
navigation
-
header
"
}
)
)
:
null
english
?
external_React_default
(
)
.
createElement
(
"
ul
"
null
links
&
&
links
.
map
(
t
=
>
external_React_default
(
)
.
createElement
(
"
li
"
{
key
:
t
.
name
}
external_React_default
(
)
.
createElement
(
Topic
{
url
:
t
.
url
name
:
t
.
name
dispatch
:
this
.
props
.
dispatch
}
)
)
)
)
:
null
!
newFooterSection
?
external_React_default
(
)
.
createElement
(
SafeAnchor
{
className
:
"
ds
-
navigation
-
privacy
"
url
:
privacyNotice
.
url
}
external_React_default
(
)
.
createElement
(
FluentOrText
{
message
:
privacyNotice
.
title
}
)
)
:
null
newFooterSection
?
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
ds
-
navigation
-
family
"
}
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
icon
firefox
-
logo
"
}
)
external_React_default
(
)
.
createElement
(
"
span
"
null
"
|
"
)
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
icon
pocket
-
logo
"
}
)
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
ds
-
navigation
-
family
-
message
"
"
data
-
l10n
-
id
"
:
"
newtab
-
pocket
-
pocket
-
firefox
-
family
"
}
)
)
:
null
)
;
}
}
;
class
PrivacyLink
extends
(
external_React_default
(
)
)
.
PureComponent
{
render
(
)
{
const
{
properties
}
=
this
.
props
;
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
ds
-
privacy
-
link
"
}
external_React_default
(
)
.
createElement
(
SafeAnchor
{
url
:
properties
.
url
}
external_React_default
(
)
.
createElement
(
FluentOrText
{
message
:
properties
.
title
}
)
)
)
;
}
}
;
class
SectionTitle
extends
(
external_React_default
(
)
)
.
PureComponent
{
render
(
)
{
const
{
header
:
{
title
subtitle
}
}
=
this
.
props
;
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
ds
-
section
-
title
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
title
"
}
title
)
subtitle
?
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
subtitle
"
}
subtitle
)
:
null
)
;
}
}
;
const
selectLayoutRender
=
(
{
state
=
{
}
prefs
=
{
}
}
)
=
>
{
const
{
layout
feeds
spocs
}
=
state
;
let
spocIndexPlacementMap
=
{
}
;
function
fillSpocPositionsForPlacement
(
data
spocsPositions
spocsData
placementName
)
{
if
(
!
spocIndexPlacementMap
[
placementName
]
&
&
spocIndexPlacementMap
[
placementName
]
!
=
=
0
)
{
spocIndexPlacementMap
[
placementName
]
=
0
;
}
const
results
=
[
.
.
.
data
]
;
for
(
let
position
of
spocsPositions
)
{
const
spoc
=
spocsData
[
spocIndexPlacementMap
[
placementName
]
]
;
if
(
!
spoc
)
{
break
;
}
spocIndexPlacementMap
[
placementName
]
+
+
;
if
(
!
spocs
.
blocked
.
includes
(
spoc
.
url
)
)
{
results
.
splice
(
position
.
index
0
spoc
)
;
}
}
return
results
;
}
const
positions
=
{
}
;
const
DS_COMPONENTS
=
[
"
Message
"
"
TextPromo
"
"
SectionTitle
"
"
Signup
"
"
Navigation
"
"
Widgets
"
"
CardGrid
"
"
CollectionCardGrid
"
"
HorizontalRule
"
"
PrivacyLink
"
]
;
const
filterArray
=
[
]
;
if
(
!
prefs
[
"
feeds
.
topsites
"
]
)
{
filterArray
.
push
(
"
TopSites
"
)
;
}
const
nimbusWidgetsEnabled
=
prefs
.
widgetsConfig
?
.
enabled
;
const
widgetsEnabled
=
prefs
[
"
widgets
.
system
.
enabled
"
]
;
if
(
!
nimbusWidgetsEnabled
&
&
!
widgetsEnabled
)
{
filterArray
.
push
(
"
Widgets
"
)
;
}
const
pocketEnabled
=
prefs
[
"
feeds
.
section
.
topstories
"
]
&
&
prefs
[
"
feeds
.
system
.
topstories
"
]
;
if
(
!
pocketEnabled
)
{
filterArray
.
push
(
.
.
.
DS_COMPONENTS
.
filter
(
component
=
>
component
!
=
=
"
Widgets
"
)
)
;
}
function
getMaxTiles
(
responsiveLayouts
)
{
return
responsiveLayouts
.
flatMap
(
responsiveLayout
=
>
responsiveLayout
)
.
reduce
(
(
acc
t
)
=
>
{
acc
[
t
.
columnCount
]
=
t
.
tiles
.
length
;
if
(
!
acc
.
maxTile
|
|
t
.
tiles
.
length
>
acc
.
maxTile
)
{
acc
.
maxTile
=
t
.
tiles
.
length
;
}
return
acc
;
}
{
}
)
;
}
const
placeholderComponent
=
component
=
>
{
if
(
!
component
.
feed
)
{
return
{
.
.
.
component
data
:
{
spocs
:
[
]
}
}
;
}
const
data
=
{
recommendations
:
[
]
sections
:
[
{
layout
:
{
responsiveLayouts
:
[
]
}
data
:
[
]
}
]
}
;
let
items
=
0
;
if
(
component
.
properties
&
&
component
.
properties
.
items
)
{
items
=
component
.
properties
.
items
;
}
for
(
let
i
=
0
;
i
<
items
;
i
+
+
)
{
data
.
recommendations
.
push
(
{
placeholder
:
true
}
)
;
}
const
sectionsEnabled
=
prefs
[
"
discoverystream
.
sections
.
enabled
"
]
;
if
(
sectionsEnabled
)
{
for
(
let
i
=
0
;
i
<
items
;
i
+
+
)
{
data
.
sections
[
0
]
.
data
.
push
(
{
placeholder
:
true
}
)
;
}
}
return
{
.
.
.
component
data
}
;
}
;
const
handleSpocs
=
(
data
=
[
]
spocsPositions
spocsPlacement
)
=
>
{
let
result
=
[
.
.
.
data
]
;
if
(
spocsPositions
?
.
length
)
{
const
placement
=
spocsPlacement
|
|
{
}
;
const
placementName
=
placement
.
name
|
|
"
newtab_spocs
"
;
const
spocsData
=
spocs
.
data
[
placementName
]
;
if
(
spocs
.
loaded
&
&
spocsData
?
.
items
?
.
length
)
{
const
excludedSpocs
=
[
"
billboard
"
"
leaderboard
"
]
;
const
filteredSpocs
=
spocsData
?
.
items
?
.
filter
(
item
=
>
!
excludedSpocs
.
includes
(
item
.
format
)
)
;
result
=
fillSpocPositionsForPlacement
(
result
spocsPositions
filteredSpocs
placementName
)
;
}
}
return
result
;
}
;
const
handleSections
=
(
sections
=
[
]
recommendations
=
[
]
)
=
>
{
let
result
=
sections
.
sort
(
(
a
b
)
=
>
a
.
receivedRank
-
b
.
receivedRank
)
;
const
sectionsMap
=
recommendations
.
reduce
(
(
acc
recommendation
)
=
>
{
const
{
section
}
=
recommendation
;
acc
[
section
]
=
acc
[
section
]
|
|
[
]
;
acc
[
section
]
.
push
(
recommendation
)
;
return
acc
;
}
{
}
)
;
result
.
forEach
(
section
=
>
{
const
{
sectionKey
}
=
section
;
section
.
data
=
sectionsMap
[
sectionKey
]
;
}
)
;
return
result
;
}
;
const
handleComponent
=
component
=
>
{
if
(
component
?
.
spocs
?
.
positions
?
.
length
)
{
const
placement
=
component
.
placement
|
|
{
}
;
const
placementName
=
placement
.
name
|
|
"
newtab_spocs
"
;
const
spocsData
=
spocs
.
data
[
placementName
]
;
if
(
spocs
.
loaded
&
&
spocsData
?
.
items
?
.
length
)
{
return
{
.
.
.
component
data
:
{
spocs
:
spocsData
.
items
.
filter
(
spoc
=
>
spoc
&
&
!
spocs
.
blocked
.
includes
(
spoc
.
url
)
)
.
map
(
(
spoc
index
)
=
>
(
{
.
.
.
spoc
pos
:
index
}
)
)
}
}
;
}
}
return
{
.
.
.
component
data
:
{
spocs
:
[
]
}
}
;
}
;
const
handleComponentWithFeed
=
component
=
>
{
positions
[
component
.
type
]
=
positions
[
component
.
type
]
|
|
0
;
let
data
=
{
recommendations
:
[
]
sections
:
[
]
}
;
const
feed
=
feeds
.
data
[
component
.
feed
.
url
]
;
if
(
feed
?
.
data
)
{
data
=
{
.
.
.
feed
.
data
recommendations
:
[
.
.
.
(
feed
.
data
.
recommendations
|
|
[
]
)
]
sections
:
[
.
.
.
(
feed
.
data
.
sections
|
|
[
]
)
]
}
;
}
if
(
component
&
&
component
.
properties
&
&
component
.
properties
.
offset
)
{
data
=
{
.
.
.
data
recommendations
:
data
.
recommendations
.
slice
(
component
.
properties
.
offset
)
}
;
}
const
spocsPositions
=
component
?
.
spocs
?
.
positions
;
const
spocsPlacement
=
component
?
.
placement
;
const
sectionsEnabled
=
prefs
[
"
discoverystream
.
sections
.
enabled
"
]
;
data
=
{
.
.
.
data
.
.
.
(
sectionsEnabled
?
{
sections
:
handleSections
(
data
.
sections
data
.
recommendations
)
.
map
(
section
=
>
{
const
sectionsSpocsPositions
=
[
]
;
section
.
layout
.
responsiveLayouts
.
find
(
item
=
>
item
.
columnCount
=
=
=
1
)
.
tiles
.
forEach
(
tile
=
>
{
if
(
tile
.
hasAd
)
{
sectionsSpocsPositions
.
push
(
{
index
:
tile
.
position
}
)
;
}
}
)
;
return
{
.
.
.
section
data
:
handleSpocs
(
section
.
data
sectionsSpocsPositions
spocsPlacement
)
}
;
}
)
recommendations
:
data
.
recommendations
}
:
{
recommendations
:
handleSpocs
(
data
.
recommendations
spocsPositions
spocsPlacement
)
}
)
}
;
let
items
=
0
;
if
(
component
.
properties
&
&
component
.
properties
.
items
)
{
items
=
Math
.
min
(
component
.
properties
.
items
data
.
recommendations
.
length
)
;
}
for
(
let
i
=
0
;
i
<
items
;
i
+
+
)
{
data
.
recommendations
[
i
]
=
{
.
.
.
data
.
recommendations
[
i
]
pos
:
positions
[
component
.
type
]
+
+
}
;
}
if
(
sectionsEnabled
)
{
let
currentPosition
=
0
;
data
.
sections
.
forEach
(
section
=
>
{
const
{
maxTile
}
=
getMaxTiles
(
section
?
.
layout
?
.
responsiveLayouts
)
;
for
(
let
i
=
0
;
i
<
maxTile
;
i
+
+
)
{
if
(
section
.
data
[
i
]
)
{
section
.
data
[
i
]
=
{
.
.
.
section
.
data
[
i
]
pos
:
currentPosition
+
+
}
;
}
}
}
)
;
}
return
{
.
.
.
component
data
}
;
}
;
const
renderLayout
=
(
)
=
>
{
const
renderedLayoutArray
=
[
]
;
for
(
const
row
of
layout
.
filter
(
r
=
>
r
.
components
.
filter
(
c
=
>
!
filterArray
.
includes
(
c
.
type
)
)
.
length
)
)
{
let
components
=
[
]
;
renderedLayoutArray
.
push
(
{
.
.
.
row
components
}
)
;
for
(
const
component
of
row
.
components
.
filter
(
c
=
>
!
filterArray
.
includes
(
c
.
type
)
)
)
{
const
spocsConfig
=
component
.
spocs
;
if
(
spocsConfig
|
|
component
.
feed
)
{
if
(
(
component
.
feed
&
&
!
feeds
.
data
[
component
.
feed
.
url
]
)
|
|
(
spocsConfig
&
&
spocsConfig
.
positions
&
&
spocsConfig
.
positions
.
length
&
&
!
spocs
.
loaded
)
)
{
components
.
push
(
placeholderComponent
(
component
)
)
;
}
else
if
(
component
.
feed
)
{
components
.
push
(
handleComponentWithFeed
(
component
)
)
;
}
else
{
components
.
push
(
handleComponent
(
component
)
)
;
}
}
else
{
components
.
push
(
component
)
;
}
}
}
return
renderedLayoutArray
;
}
;
const
layoutRender
=
renderLayout
(
)
;
return
{
layoutRender
}
;
}
;
;
function
SectionContextMenu
(
{
type
=
"
DISCOVERY_STREAM
"
title
source
index
dispatch
sectionKey
following
sectionPersonalization
sectionPosition
}
)
{
const
SECTIONS_CONTEXT_MENU_OPTIONS
=
[
"
SectionBlock
"
]
;
const
[
showContextMenu
setShowContextMenu
]
=
(
0
external_React_namespaceObject
.
useState
)
(
false
)
;
if
(
following
)
{
SECTIONS_CONTEXT_MENU_OPTIONS
.
push
(
"
SectionUnfollow
"
)
;
}
const
onClick
=
e
=
>
{
e
.
preventDefault
(
)
;
setShowContextMenu
(
!
showContextMenu
)
;
}
;
const
onUpdate
=
(
)
=
>
{
setShowContextMenu
(
!
showContextMenu
)
;
}
;
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
section
-
context
-
menu
"
}
external_React_default
(
)
.
createElement
(
"
moz
-
button
"
{
type
:
"
icon
"
size
:
"
default
"
iconsrc
:
"
chrome
:
/
/
global
/
skin
/
icons
/
more
.
svg
"
title
:
title
|
|
source
onClick
:
onClick
}
)
showContextMenu
&
&
external_React_default
(
)
.
createElement
(
LinkMenu
{
onUpdate
:
onUpdate
dispatch
:
dispatch
index
:
index
source
:
type
.
toUpperCase
(
)
options
:
SECTIONS_CONTEXT_MENU_OPTIONS
shouldSendImpressionStats
:
true
site
:
{
sectionPersonalization
sectionKey
sectionPosition
title
}
}
)
)
;
}
;
const
PREF_VISIBLE_SECTIONS
=
"
discoverystream
.
sections
.
interestPicker
.
visibleSections
"
;
function
InterestPicker
(
{
title
subtitle
interests
receivedFeedRank
}
)
{
const
dispatch
=
(
0
external_ReactRedux_namespaceObject
.
useDispatch
)
(
)
;
const
focusedRef
=
(
0
external_React_namespaceObject
.
useRef
)
(
null
)
;
const
focusRef
=
(
0
external_React_namespaceObject
.
useRef
)
(
null
)
;
const
[
focusedIndex
setFocusedIndex
]
=
(
0
external_React_namespaceObject
.
useState
)
(
0
)
;
const
prefs
=
(
0
external_ReactRedux_namespaceObject
.
useSelector
)
(
state
=
>
state
.
Prefs
.
values
)
;
const
{
sectionPersonalization
}
=
(
0
external_ReactRedux_namespaceObject
.
useSelector
)
(
state
=
>
state
.
DiscoveryStream
)
;
const
visibleSections
=
prefs
[
PREF_VISIBLE_SECTIONS
]
?
.
split
(
"
"
)
.
map
(
item
=
>
item
.
trim
(
)
)
.
filter
(
item
=
>
item
)
;
const
handleIntersection
=
(
0
external_React_namespaceObject
.
useCallback
)
(
(
)
=
>
{
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
INLINE_SELECTION_IMPRESSION
data
:
{
section_position
:
receivedFeedRank
}
}
)
)
;
}
[
dispatch
receivedFeedRank
]
)
;
const
ref
=
useIntersectionObserver
(
handleIntersection
)
;
const
onKeyDown
=
(
0
external_React_namespaceObject
.
useCallback
)
(
e
=
>
{
if
(
e
.
key
=
=
=
"
ArrowDown
"
|
|
e
.
key
=
=
=
"
ArrowUp
"
)
{
e
.
preventDefault
(
)
;
}
if
(
focusedRef
.
current
?
.
nextSibling
?
.
querySelector
(
"
input
"
)
&
&
e
.
key
=
=
=
"
ArrowDown
"
)
{
focusedRef
.
current
.
nextSibling
.
querySelector
(
"
input
"
)
.
tabIndex
=
0
;
focusedRef
.
current
.
nextSibling
.
querySelector
(
"
input
"
)
.
focus
(
)
;
}
if
(
focusedRef
.
current
?
.
previousSibling
?
.
querySelector
(
"
input
"
)
&
&
e
.
key
=
=
=
"
ArrowUp
"
)
{
focusedRef
.
current
.
previousSibling
.
querySelector
(
"
input
"
)
.
tabIndex
=
0
;
focusedRef
.
current
.
previousSibling
.
querySelector
(
"
input
"
)
.
focus
(
)
;
}
}
[
]
)
;
function
onWrapperFocus
(
)
{
focusRef
.
current
?
.
addEventListener
(
"
keydown
"
onKeyDown
)
;
}
function
onWrapperBlur
(
)
{
focusRef
.
current
?
.
removeEventListener
(
"
keydown
"
onKeyDown
)
;
}
function
onItemFocus
(
index
)
{
setFocusedIndex
(
index
)
;
}
function
handleChange
(
e
index
)
{
const
{
name
:
topic
checked
}
=
e
.
target
;
let
updatedSections
=
{
.
.
.
sectionPersonalization
}
;
if
(
checked
)
{
updatedSections
[
topic
]
=
{
isFollowed
:
true
isBlocked
:
false
followedAt
:
new
Date
(
)
.
toISOString
(
)
}
;
if
(
!
visibleSections
.
includes
(
topic
)
)
{
visibleSections
.
splice
(
receivedFeedRank
-
1
0
topic
)
;
dispatch
(
actionCreators
.
SetPref
(
PREF_VISIBLE_SECTIONS
visibleSections
.
join
(
"
"
)
)
)
;
}
}
else
{
delete
updatedSections
[
topic
]
;
}
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
INLINE_SELECTION_CLICK
data
:
{
topic
is_followed
:
checked
topic_position
:
index
section_position
:
receivedFeedRank
}
}
)
)
;
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
SECTION_PERSONALIZATION_SET
data
:
updatedSections
}
)
)
;
}
return
external_React_default
(
)
.
createElement
(
"
section
"
{
className
:
"
inline
-
selection
-
wrapper
ds
-
section
"
ref
:
el
=
>
{
ref
.
current
=
[
el
]
;
}
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
section
-
heading
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
section
-
title
-
wrapper
"
}
external_React_default
(
)
.
createElement
(
"
h2
"
{
className
:
"
section
-
title
"
}
title
)
external_React_default
(
)
.
createElement
(
"
p
"
{
className
:
"
section
-
subtitle
"
}
subtitle
)
)
)
external_React_default
(
)
.
createElement
(
"
ul
"
{
className
:
"
topic
-
list
"
onFocus
:
onWrapperFocus
onBlur
:
onWrapperBlur
ref
:
focusRef
}
interests
.
map
(
(
interest
index
)
=
>
{
const
checked
=
sectionPersonalization
[
interest
.
sectionId
]
?
.
isFollowed
;
return
external_React_default
(
)
.
createElement
(
"
li
"
{
key
:
interest
.
sectionId
ref
:
index
=
=
=
focusedIndex
?
focusedRef
:
null
}
external_React_default
(
)
.
createElement
(
"
label
"
null
external_React_default
(
)
.
createElement
(
"
input
"
{
type
:
"
checkbox
"
id
:
interest
.
sectionId
name
:
interest
.
sectionId
checked
:
checked
"
aria
-
checked
"
:
checked
onChange
:
e
=
>
handleChange
(
e
index
)
tabIndex
:
index
=
=
=
focusedIndex
?
0
:
-
1
onFocus
:
(
)
=
>
{
onItemFocus
(
index
)
;
}
}
)
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
topic
-
item
-
label
"
}
interest
.
title
|
|
"
"
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
topic
-
item
-
icon
icon
{
checked
?
"
icon
-
check
-
filled
"
:
"
icon
-
add
-
circle
-
fill
"
}
}
)
)
)
;
}
)
)
external_React_default
(
)
.
createElement
(
"
p
"
{
className
:
"
learn
-
more
-
copy
"
}
external_React_default
(
)
.
createElement
(
"
a
"
{
href
:
prefs
[
"
support
.
url
"
]
"
data
-
l10n
-
id
"
:
"
newtab
-
topic
-
selection
-
privacy
-
link
"
}
)
)
)
;
}
;
const
PersonalizedCard
=
(
{
dispatch
handleDismiss
handleClick
handleBlock
messageData
}
)
=
>
{
const
wavingFox
=
"
chrome
:
/
/
newtab
/
content
/
data
/
content
/
assets
/
waving
-
fox
.
svg
"
;
const
onDismiss
=
(
0
external_React_namespaceObject
.
useCallback
)
(
(
)
=
>
{
handleDismiss
(
)
;
handleBlock
(
)
;
}
[
handleDismiss
handleBlock
]
)
;
const
onToggleClick
=
(
0
external_React_namespaceObject
.
useCallback
)
(
elementId
=
>
{
dispatch
(
{
type
:
actionTypes
.
SHOW_PERSONALIZE
}
)
;
dispatch
(
actionCreators
.
UserEvent
(
{
event
:
"
SHOW_PERSONALIZE
"
}
)
)
;
handleClick
(
elementId
)
;
}
[
dispatch
handleClick
]
)
;
return
external_React_default
(
)
.
createElement
(
"
aside
"
{
className
:
"
personalized
-
card
-
wrapper
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
personalized
-
card
-
dismiss
"
}
external_React_default
(
)
.
createElement
(
"
moz
-
button
"
{
type
:
"
icon
ghost
"
iconSrc
:
"
chrome
:
/
/
global
/
skin
/
icons
/
close
.
svg
"
onClick
:
onDismiss
"
data
-
l10n
-
id
"
:
"
newtab
-
toast
-
dismiss
-
button
"
}
)
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
personalized
-
card
-
inner
"
}
external_React_default
(
)
.
createElement
(
"
img
"
{
src
:
wavingFox
alt
:
"
"
}
)
external_React_default
(
)
.
createElement
(
"
h2
"
null
messageData
.
content
.
cardTitle
)
external_React_default
(
)
.
createElement
(
"
p
"
null
messageData
.
content
.
cardMessage
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
personalized
-
card
-
cta
-
wrapper
"
}
external_React_default
(
)
.
createElement
(
"
moz
-
button
"
{
type
:
"
primary
"
class
:
"
personalized
-
card
-
cta
"
onClick
:
(
)
=
>
onToggleClick
(
"
open
-
personalization
-
panel
"
)
}
messageData
.
content
.
ctaText
)
external_React_default
(
)
.
createElement
(
SafeAnchor
{
className
:
"
personalized
-
card
-
link
"
dispatch
:
dispatch
url
:
"
https
:
/
/
www
.
mozilla
.
org
/
en
-
US
/
privacy
/
firefox
/
#
notice
"
onLinkClick
:
(
)
=
>
{
handleClick
(
"
link
-
click
"
)
;
}
}
messageData
.
content
.
linkText
)
)
)
)
;
}
;
;
function
FollowSectionButtonHighlight
(
{
arrowPosition
position
verticalPosition
dispatch
handleDismiss
handleBlock
feature
}
)
{
const
onDismiss
=
(
0
external_React_namespaceObject
.
useCallback
)
(
(
)
=
>
{
handleDismiss
(
)
;
handleBlock
(
)
;
}
[
handleDismiss
handleBlock
]
)
;
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
follow
-
section
-
button
-
highlight
"
}
external_React_default
(
)
.
createElement
(
FeatureHighlight
{
position
:
position
arrowPosition
:
arrowPosition
verticalPosition
:
verticalPosition
feature
:
feature
dispatch
:
dispatch
message
:
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
follow
-
section
-
button
-
highlight
-
content
"
}
external_React_default
(
)
.
createElement
(
"
img
"
{
src
:
"
chrome
:
/
/
browser
/
content
/
asrouter
/
assets
/
smiling
-
fox
-
icon
.
svg
"
width
:
"
24
"
height
:
"
24
"
alt
:
"
"
}
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
follow
-
section
-
button
-
highlight
-
copy
"
}
external_React_default
(
)
.
createElement
(
"
p
"
{
className
:
"
title
"
"
data
-
l10n
-
id
"
:
"
newtab
-
section
-
follow
-
highlight
-
title
"
}
)
external_React_default
(
)
.
createElement
(
"
p
"
{
className
:
"
subtitle
"
"
data
-
l10n
-
id
"
:
"
newtab
-
section
-
follow
-
highlight
-
subtitle
"
}
)
)
)
openedOverride
:
true
showButtonIcon
:
false
dismissCallback
:
onDismiss
outsideClickCallback
:
handleDismiss
}
)
)
;
}
;
const
CardSections_PREF_SECTIONS_CARDS_ENABLED
=
"
discoverystream
.
sections
.
cards
.
enabled
"
;
const
PREF_SECTIONS_CARDS_THUMBS_UP_DOWN_ENABLED
=
"
discoverystream
.
sections
.
cards
.
thumbsUpDown
.
enabled
"
;
const
PREF_SECTIONS_PERSONALIZATION_ENABLED
=
"
discoverystream
.
sections
.
personalization
.
enabled
"
;
const
CardSections_PREF_TOPICS_ENABLED
=
"
discoverystream
.
topicLabels
.
enabled
"
;
const
CardSections_PREF_TOPICS_SELECTED
=
"
discoverystream
.
topicSelection
.
selectedTopics
"
;
const
CardSections_PREF_TOPICS_AVAILABLE
=
"
discoverystream
.
topicSelection
.
topics
"
;
const
CardSections_PREF_THUMBS_UP_DOWN_ENABLED
=
"
discoverystream
.
thumbsUpDown
.
enabled
"
;
const
PREF_INTEREST_PICKER_ENABLED
=
"
discoverystream
.
sections
.
interestPicker
.
enabled
"
;
const
CardSections_PREF_VISIBLE_SECTIONS
=
"
discoverystream
.
sections
.
interestPicker
.
visibleSections
"
;
const
CardSections_PREF_BILLBOARD_ENABLED
=
"
newtabAdSize
.
billboard
"
;
const
CardSections_PREF_BILLBOARD_POSITION
=
"
newtabAdSize
.
billboard
.
position
"
;
const
CardSections_PREF_PROMOCARD_ENABLED
=
"
discoverystream
.
promoCard
.
enabled
"
;
const
CardSections_PREF_PROMOCARD_VISIBLE
=
"
discoverystream
.
promoCard
.
visible
"
;
const
CardSections_PREF_LEADERBOARD_ENABLED
=
"
newtabAdSize
.
leaderboard
"
;
const
CardSections_PREF_LEADERBOARD_POSITION
=
"
newtabAdSize
.
leaderboard
.
position
"
;
const
PREF_REFINED_CARDS_ENABLED
=
"
discoverystream
.
refinedCardsLayout
.
enabled
"
;
const
CardSections_PREF_INFERRED_PERSONALIZATION_USER
=
"
discoverystream
.
sections
.
personalization
.
inferred
.
user
.
enabled
"
;
const
CardSections_PREF_TRENDING_SEARCH
=
"
trendingSearch
.
enabled
"
;
const
CardSections_PREF_TRENDING_SEARCH_SYSTEM
=
"
system
.
trendingSearch
.
enabled
"
;
const
CardSections_PREF_SEARCH_ENGINE
=
"
trendingSearch
.
defaultSearchEngine
"
;
const
CardSections_PREF_TRENDING_SEARCH_VARIANT
=
"
trendingSearch
.
variant
"
;
function
getLayoutData
(
responsiveLayouts
index
refinedCardsLayout
sectionKey
)
{
let
layoutData
=
{
classNames
:
[
]
imageSizes
:
{
}
}
;
responsiveLayouts
.
forEach
(
layout
=
>
{
layout
.
tiles
.
forEach
(
(
tile
tileIndex
)
=
>
{
if
(
tile
.
position
=
=
=
index
)
{
if
(
sectionKey
=
=
=
"
top_stories_section
"
&
&
tileIndex
=
=
=
0
)
{
layoutData
.
classNames
.
push
(
col
-
{
layout
.
columnCount
}
-
medium
)
;
layoutData
.
classNames
.
push
(
col
-
{
layout
.
columnCount
}
-
position
-
{
tileIndex
}
)
;
layoutData
.
imageSizes
[
layout
.
columnCount
]
=
"
medium
"
;
layoutData
.
classNames
.
push
(
col
-
{
layout
.
columnCount
}
-
hide
-
excerpt
)
;
}
else
{
layoutData
.
classNames
.
push
(
col
-
{
layout
.
columnCount
}
-
{
tile
.
size
}
)
;
layoutData
.
classNames
.
push
(
col
-
{
layout
.
columnCount
}
-
position
-
{
tileIndex
}
)
;
layoutData
.
imageSizes
[
layout
.
columnCount
]
=
tile
.
size
;
}
if
(
tile
.
hasExcerpt
)
{
if
(
tile
.
size
=
=
=
"
medium
"
&
&
refinedCardsLayout
)
{
layoutData
.
classNames
.
push
(
col
-
{
layout
.
columnCount
}
-
hide
-
excerpt
)
;
}
else
{
layoutData
.
classNames
.
push
(
col
-
{
layout
.
columnCount
}
-
show
-
excerpt
)
;
}
}
else
{
layoutData
.
classNames
.
push
(
col
-
{
layout
.
columnCount
}
-
hide
-
excerpt
)
;
}
}
}
)
;
}
)
;
return
layoutData
;
}
function
getMaxTiles
(
responsiveLayouts
)
{
return
responsiveLayouts
.
flatMap
(
responsiveLayout
=
>
responsiveLayout
)
.
reduce
(
(
acc
t
)
=
>
{
acc
[
t
.
columnCount
]
=
t
.
tiles
.
length
;
if
(
!
acc
.
maxTile
|
|
t
.
tiles
.
length
>
acc
.
maxTile
)
{
acc
.
maxTile
=
t
.
tiles
.
length
;
}
return
acc
;
}
{
}
)
;
}
const
prefToArray
=
(
pref
=
"
"
)
=
>
{
return
pref
.
split
(
"
"
)
.
map
(
item
=
>
item
.
trim
(
)
)
.
filter
(
item
=
>
item
)
;
}
;
function
shouldShowOMCHighlight
(
messageData
componentId
)
{
if
(
!
messageData
|
|
Object
.
keys
(
messageData
)
.
length
=
=
=
0
)
{
return
false
;
}
return
messageData
?
.
content
?
.
messageType
=
=
=
componentId
;
}
function
CardSection
(
{
sectionPosition
section
dispatch
type
firstVisibleTimestamp
is_collection
spocMessageVariant
ctaButtonVariant
ctaButtonSponsors
anySectionsFollowed
}
)
{
const
prefs
=
(
0
external_ReactRedux_namespaceObject
.
useSelector
)
(
state
=
>
state
.
Prefs
.
values
)
;
const
{
messageData
}
=
(
0
external_ReactRedux_namespaceObject
.
useSelector
)
(
state
=
>
state
.
Messages
)
;
const
{
sectionPersonalization
}
=
(
0
external_ReactRedux_namespaceObject
.
useSelector
)
(
state
=
>
state
.
DiscoveryStream
)
;
const
showTopics
=
prefs
[
CardSections_PREF_TOPICS_ENABLED
]
;
const
mayHaveSectionsCards
=
prefs
[
CardSections_PREF_SECTIONS_CARDS_ENABLED
]
;
const
mayHaveSectionsCardsThumbsUpDown
=
prefs
[
PREF_SECTIONS_CARDS_THUMBS_UP_DOWN_ENABLED
]
;
const
mayHaveThumbsUpDown
=
prefs
[
CardSections_PREF_THUMBS_UP_DOWN_ENABLED
]
;
const
selectedTopics
=
prefs
[
CardSections_PREF_TOPICS_SELECTED
]
;
const
availableTopics
=
prefs
[
CardSections_PREF_TOPICS_AVAILABLE
]
;
const
refinedCardsLayout
=
prefs
[
PREF_REFINED_CARDS_ENABLED
]
;
const
trendingEnabled
=
prefs
[
CardSections_PREF_TRENDING_SEARCH
]
&
&
prefs
[
CardSections_PREF_TRENDING_SEARCH_SYSTEM
]
&
&
prefs
[
CardSections_PREF_SEARCH_ENGINE
]
?
.
toLowerCase
(
)
=
=
=
"
google
"
;
const
trendingVariant
=
prefs
[
CardSections_PREF_TRENDING_SEARCH_VARIANT
]
;
const
shouldShowTrendingSearch
=
trendingEnabled
&
&
trendingVariant
=
=
=
"
b
"
;
const
mayHaveSectionsPersonalization
=
prefs
[
PREF_SECTIONS_PERSONALIZATION_ENABLED
]
;
const
{
sectionKey
title
subtitle
}
=
section
;
const
{
responsiveLayouts
}
=
section
.
layout
;
const
following
=
sectionPersonalization
[
sectionKey
]
?
.
isFollowed
;
const
handleIntersection
=
(
0
external_React_namespaceObject
.
useCallback
)
(
(
)
=
>
{
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
CARD_SECTION_IMPRESSION
data
:
{
section
:
sectionKey
section_position
:
sectionPosition
is_section_followed
:
following
}
}
)
)
;
}
[
dispatch
sectionKey
sectionPosition
following
]
)
;
const
sectionRefs
=
useIntersectionObserver
(
handleIntersection
)
;
const
mayHaveCombinedThumbsUpDown
=
mayHaveSectionsCardsThumbsUpDown
&
&
mayHaveThumbsUpDown
;
const
onFollowClick
=
(
0
external_React_namespaceObject
.
useCallback
)
(
(
)
=
>
{
const
updatedSectionData
=
{
.
.
.
sectionPersonalization
[
sectionKey
]
:
{
isFollowed
:
true
isBlocked
:
false
followedAt
:
new
Date
(
)
.
toISOString
(
)
}
}
;
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
SECTION_PERSONALIZATION_SET
data
:
updatedSectionData
}
)
)
;
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
"
FOLLOW_SECTION
"
data
:
{
section
:
sectionKey
section_position
:
sectionPosition
event_source
:
"
MOZ_BUTTON
"
}
}
)
)
;
}
[
dispatch
sectionPersonalization
sectionKey
sectionPosition
]
)
;
const
onUnfollowClick
=
(
0
external_React_namespaceObject
.
useCallback
)
(
(
)
=
>
{
const
updatedSectionData
=
{
.
.
.
sectionPersonalization
}
;
delete
updatedSectionData
[
sectionKey
]
;
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
SECTION_PERSONALIZATION_SET
data
:
updatedSectionData
}
)
)
;
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
"
UNFOLLOW_SECTION
"
data
:
{
section
:
sectionKey
section_position
:
sectionPosition
event_source
:
"
MOZ_BUTTON
"
}
}
)
)
;
}
[
dispatch
sectionPersonalization
sectionKey
sectionPosition
]
)
;
const
{
maxTile
}
=
getMaxTiles
(
responsiveLayouts
)
;
const
displaySections
=
section
.
data
.
slice
(
0
maxTile
)
;
const
isSectionEmpty
=
!
displaySections
?
.
length
;
const
shouldShowLabels
=
sectionKey
=
=
=
"
top_stories_section
"
&
&
showTopics
;
if
(
isSectionEmpty
)
{
return
null
;
}
const
sectionContextWrapper
=
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
section
-
context
-
wrapper
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
following
?
"
section
-
follow
following
"
:
"
section
-
follow
"
}
!
anySectionsFollowed
&
&
sectionPosition
=
=
=
1
&
&
shouldShowOMCHighlight
(
messageData
"
FollowSectionButtonHighlight
"
)
&
&
external_React_default
(
)
.
createElement
(
MessageWrapper
{
dispatch
:
dispatch
}
external_React_default
(
)
.
createElement
(
FollowSectionButtonHighlight
{
verticalPosition
:
"
inset
-
block
-
center
"
position
:
"
arrow
-
inline
-
start
"
dispatch
:
dispatch
feature
:
"
FEATURE_FOLLOW_SECTION_BUTTON
"
}
)
)
!
anySectionsFollowed
&
&
sectionPosition
=
=
=
1
&
&
shouldShowOMCHighlight
(
messageData
"
FollowSectionButtonAltHighlight
"
)
&
&
external_React_default
(
)
.
createElement
(
MessageWrapper
{
dispatch
:
dispatch
}
external_React_default
(
)
.
createElement
(
FollowSectionButtonHighlight
{
verticalPosition
:
"
inset
-
block
-
center
"
position
:
"
arrow
-
inline
-
start
"
dispatch
:
dispatch
feature
:
"
FEATURE_ALT_FOLLOW_SECTION_BUTTON
"
}
)
)
external_React_default
(
)
.
createElement
(
"
moz
-
button
"
{
onClick
:
following
?
onUnfollowClick
:
onFollowClick
type
:
"
default
"
index
:
sectionPosition
section
:
sectionKey
}
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
section
-
button
-
follow
-
text
"
"
data
-
l10n
-
id
"
:
"
newtab
-
section
-
follow
-
button
"
}
)
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
section
-
button
-
following
-
text
"
"
data
-
l10n
-
id
"
:
"
newtab
-
section
-
following
-
button
"
}
)
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
section
-
button
-
unfollow
-
text
"
"
data
-
l10n
-
id
"
:
"
newtab
-
section
-
unfollow
-
button
"
}
)
)
)
external_React_default
(
)
.
createElement
(
SectionContextMenu
{
dispatch
:
dispatch
index
:
sectionPosition
following
:
following
sectionPersonalization
:
sectionPersonalization
sectionKey
:
sectionKey
title
:
title
type
:
type
sectionPosition
:
sectionPosition
}
)
)
;
return
external_React_default
(
)
.
createElement
(
"
section
"
{
className
:
"
ds
-
section
"
ref
:
el
=
>
{
sectionRefs
.
current
[
0
]
=
el
;
}
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
section
-
heading
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
section
-
title
-
wrapper
"
}
external_React_default
(
)
.
createElement
(
"
h2
"
{
className
:
"
section
-
title
"
}
title
)
subtitle
&
&
external_React_default
(
)
.
createElement
(
"
p
"
{
className
:
"
section
-
subtitle
"
}
subtitle
)
)
mayHaveSectionsPersonalization
?
sectionContextWrapper
:
null
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
ds
-
section
-
grid
ds
-
card
-
grid
}
section
.
data
.
slice
(
0
maxTile
)
.
map
(
(
rec
index
)
=
>
{
const
layoutData
=
getLayoutData
(
responsiveLayouts
index
refinedCardsLayout
shouldShowTrendingSearch
&
&
sectionKey
)
;
const
{
classNames
imageSizes
}
=
layoutData
;
if
(
!
rec
|
|
rec
.
placeholder
)
{
return
external_React_default
(
)
.
createElement
(
PlaceholderDSCard
{
key
:
dscard
-
{
index
}
}
)
;
}
const
card
=
external_React_default
(
)
.
createElement
(
DSCard
{
key
:
dscard
-
{
rec
.
id
}
pos
:
rec
.
pos
flightId
:
rec
.
flight_id
image_src
:
rec
.
image_src
raw_image_src
:
rec
.
raw_image_src
icon_src
:
rec
.
icon_src
word_count
:
rec
.
word_count
time_to_read
:
rec
.
time_to_read
title
:
rec
.
title
topic
:
rec
.
topic
features
:
rec
.
features
excerpt
:
rec
.
excerpt
url
:
rec
.
url
id
:
rec
.
id
shim
:
rec
.
shim
fetchTimestamp
:
rec
.
fetchTimestamp
type
:
type
context
:
rec
.
context
sponsor
:
rec
.
sponsor
sponsored_by_override
:
rec
.
sponsored_by_override
dispatch
:
dispatch
source
:
rec
.
domain
publisher
:
rec
.
publisher
pocket_id
:
rec
.
pocket_id
context_type
:
rec
.
context_type
bookmarkGuid
:
rec
.
bookmarkGuid
recommendation_id
:
rec
.
recommendation_id
firstVisibleTimestamp
:
firstVisibleTimestamp
corpus_item_id
:
rec
.
corpus_item_id
scheduled_corpus_item_id
:
rec
.
scheduled_corpus_item_id
recommended_at
:
rec
.
recommended_at
received_rank
:
rec
.
received_rank
format
:
rec
.
format
alt_text
:
rec
.
alt_text
mayHaveThumbsUpDown
:
mayHaveCombinedThumbsUpDown
mayHaveSectionsCards
:
mayHaveSectionsCards
showTopics
:
shouldShowLabels
selectedTopics
:
selectedTopics
availableTopics
:
availableTopics
is_collection
:
is_collection
ctaButtonSponsors
:
ctaButtonSponsors
ctaButtonVariant
:
ctaButtonVariant
spocMessageVariant
:
spocMessageVariant
sectionsClassNames
:
classNames
.
join
(
"
"
)
sectionsCardImageSizes
:
imageSizes
section
:
sectionKey
sectionPosition
:
sectionPosition
sectionFollowed
:
following
isTimeSensitive
:
rec
.
isTimeSensitive
}
)
;
return
index
=
=
=
0
&
&
shouldShowTrendingSearch
&
&
sectionKey
=
=
=
"
top_stories_section
"
?
[
card
external_React_default
(
)
.
createElement
(
TrendingSearches
{
key
:
"
trending
"
}
)
]
:
[
card
]
;
}
)
)
)
;
}
function
CardSections
(
{
data
feed
dispatch
type
firstVisibleTimestamp
is_collection
spocMessageVariant
ctaButtonVariant
ctaButtonSponsors
}
)
{
const
prefs
=
(
0
external_ReactRedux_namespaceObject
.
useSelector
)
(
state
=
>
state
.
Prefs
.
values
)
;
const
{
spocs
sectionPersonalization
}
=
(
0
external_ReactRedux_namespaceObject
.
useSelector
)
(
state
=
>
state
.
DiscoveryStream
)
;
const
{
messageData
}
=
(
0
external_ReactRedux_namespaceObject
.
useSelector
)
(
state
=
>
state
.
Messages
)
;
const
personalizationEnabled
=
prefs
[
PREF_SECTIONS_PERSONALIZATION_ENABLED
]
;
const
interestPickerEnabled
=
prefs
[
PREF_INTEREST_PICKER_ENABLED
]
;
if
(
!
data
)
{
return
null
;
}
const
visibleSections
=
prefToArray
(
prefs
[
CardSections_PREF_VISIBLE_SECTIONS
]
)
;
const
{
interestPicker
}
=
data
;
const
anySectionsFollowed
=
sectionPersonalization
&
&
Object
.
values
(
sectionPersonalization
)
.
some
(
section
=
>
section
?
.
isFollowed
)
;
let
filteredSections
=
data
.
sections
.
filter
(
section
=
>
!
sectionPersonalization
[
section
.
sectionKey
]
?
.
isBlocked
)
;
if
(
interestPickerEnabled
&
&
visibleSections
.
length
)
{
filteredSections
=
visibleSections
.
reduce
(
(
acc
visibleSection
)
=
>
{
const
found
=
filteredSections
.
find
(
(
{
sectionKey
}
)
=
>
sectionKey
=
=
=
visibleSection
)
;
if
(
found
)
{
acc
.
push
(
found
)
;
}
return
acc
;
}
[
]
)
;
}
let
sectionsToRender
=
filteredSections
.
map
(
(
section
sectionPosition
)
=
>
external_React_default
(
)
.
createElement
(
CardSection
{
key
:
section
-
{
section
.
sectionKey
}
sectionPosition
:
sectionPosition
section
:
section
dispatch
:
dispatch
type
:
type
firstVisibleTimestamp
:
firstVisibleTimestamp
is_collection
:
is_collection
spocMessageVariant
:
spocMessageVariant
ctaButtonVariant
:
ctaButtonVariant
ctaButtonSponsors
:
ctaButtonSponsors
anySectionsFollowed
:
anySectionsFollowed
}
)
)
;
const
billboardEnabled
=
prefs
[
CardSections_PREF_BILLBOARD_ENABLED
]
;
const
leaderboardEnabled
=
prefs
[
CardSections_PREF_LEADERBOARD_ENABLED
]
;
const
promoCardEnabled
=
prefs
[
CardSections_PREF_PROMOCARD_ENABLED
]
&
&
prefs
[
CardSections_PREF_PROMOCARD_VISIBLE
]
;
if
(
(
billboardEnabled
|
|
leaderboardEnabled
)
&
&
spocs
?
.
data
?
.
newtab_spocs
?
.
items
)
{
const
spocToRender
=
spocs
.
data
.
newtab_spocs
.
items
.
find
(
(
{
format
}
)
=
>
format
=
=
=
"
leaderboard
"
&
&
leaderboardEnabled
)
|
|
spocs
.
data
.
newtab_spocs
.
items
.
find
(
(
{
format
}
)
=
>
format
=
=
=
"
billboard
"
&
&
billboardEnabled
)
;
if
(
spocToRender
&
&
!
spocs
.
blocked
.
includes
(
spocToRender
.
url
)
)
{
const
row
=
spocToRender
.
format
=
=
=
"
leaderboard
"
?
prefs
[
CardSections_PREF_LEADERBOARD_POSITION
]
:
prefs
[
CardSections_PREF_BILLBOARD_POSITION
]
;
sectionsToRender
.
splice
(
Math
.
min
(
sectionsToRender
.
length
-
1
row
)
0
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
ad
-
banner
-
container
"
}
external_React_default
(
)
.
createElement
(
AdBanner
{
spoc
:
spocToRender
key
:
dscard
-
{
spocToRender
.
id
}
dispatch
:
dispatch
type
:
type
firstVisibleTimestamp
:
firstVisibleTimestamp
row
:
row
prefs
:
prefs
}
)
promoCardEnabled
&
&
external_React_default
(
)
.
createElement
(
PromoCard
null
)
)
)
;
}
}
if
(
interestPickerEnabled
&
&
personalizationEnabled
&
&
interestPicker
?
.
sections
)
{
const
index
=
interestPicker
.
receivedFeedRank
-
1
;
sectionsToRender
.
splice
(
Math
.
min
(
sectionsToRender
.
length
-
1
index
)
0
external_React_default
(
)
.
createElement
(
InterestPicker
{
title
:
interestPicker
.
title
subtitle
:
interestPicker
.
subtitle
interests
:
interestPicker
.
sections
|
|
[
]
receivedFeedRank
:
interestPicker
.
receivedFeedRank
}
)
)
;
}
function
displayP13nCard
(
)
{
if
(
messageData
&
&
Object
.
keys
(
messageData
)
.
length
>
=
1
)
{
if
(
shouldShowOMCHighlight
(
messageData
"
PersonalizedCard
"
)
&
&
prefs
[
CardSections_PREF_INFERRED_PERSONALIZATION_USER
]
)
{
const
row
=
messageData
.
content
.
position
;
sectionsToRender
.
splice
(
row
0
external_React_default
(
)
.
createElement
(
MessageWrapper
{
dispatch
:
dispatch
onDismiss
:
(
)
=
>
{
}
}
external_React_default
(
)
.
createElement
(
PersonalizedCard
{
position
:
row
dispatch
:
dispatch
messageData
:
messageData
}
)
)
)
;
}
}
}
displayP13nCard
(
)
;
const
isEmpty
=
sectionsToRender
.
length
=
=
=
0
;
return
isEmpty
?
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
ds
-
card
-
grid
empty
"
}
external_React_default
(
)
.
createElement
(
DSEmptyState
{
status
:
data
.
status
dispatch
:
dispatch
feed
:
feed
}
)
)
:
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
ds
-
section
-
wrapper
"
}
sectionsToRender
)
;
}
;
function
Lists_extends
(
)
{
return
Lists_extends
=
Object
.
assign
?
Object
.
assign
.
bind
(
)
:
function
(
n
)
{
for
(
var
e
=
1
;
e
<
arguments
.
length
;
e
+
+
)
{
var
t
=
arguments
[
e
]
;
for
(
var
r
in
t
)
(
{
}
)
.
hasOwnProperty
.
call
(
t
r
)
&
&
(
n
[
r
]
=
t
[
r
]
)
;
}
return
n
;
}
Lists_extends
.
apply
(
null
arguments
)
;
}
const
TASK_TYPE
=
{
IN_PROGRESS
:
"
tasks
"
COMPLETED
:
"
completed
"
}
;
const
USER_ACTION_TYPES
=
{
LIST_COPY
:
"
list_copy
"
LIST_CREATE
:
"
list_create
"
LIST_EDIT
:
"
list_edit
"
LIST_DELETE
:
"
list_delete
"
TASK_CREATE
:
"
task_create
"
TASK_EDIT
:
"
task_edit
"
TASK_DELETE
:
"
task_delete
"
TASK_COMPLETE
:
"
task_complete
"
}
;
function
Lists
(
{
dispatch
}
)
{
const
{
selected
lists
}
=
(
0
external_ReactRedux_namespaceObject
.
useSelector
)
(
state
=
>
state
.
ListsWidget
)
;
const
[
newTask
setNewTask
]
=
(
0
external_React_namespaceObject
.
useState
)
(
"
"
)
;
const
[
isEditing
setIsEditing
]
=
(
0
external_React_namespaceObject
.
useState
)
(
false
)
;
const
[
pendingNewList
setPendingNewList
]
=
(
0
external_React_namespaceObject
.
useState
)
(
null
)
;
const
inputRef
=
(
0
external_React_namespaceObject
.
useRef
)
(
null
)
;
const
selectRef
=
(
0
external_React_namespaceObject
.
useRef
)
(
null
)
;
const
reorderListRef
=
(
0
external_React_namespaceObject
.
useRef
)
(
null
)
;
const
selectedList
=
(
0
external_React_namespaceObject
.
useMemo
)
(
(
)
=
>
lists
[
selected
]
[
lists
selected
]
)
;
const
isValidUrl
=
(
0
external_React_namespaceObject
.
useCallback
)
(
str
=
>
URL
.
canParse
(
str
)
[
]
)
;
const
handleIntersection
=
(
0
external_React_namespaceObject
.
useCallback
)
(
(
)
=
>
{
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
WIDGETS_LISTS_USER_IMPRESSION
}
)
)
;
}
[
dispatch
]
)
;
const
listsRef
=
useIntersectionObserver
(
handleIntersection
)
;
const
reorderLists
=
(
0
external_React_namespaceObject
.
useCallback
)
(
(
draggedElement
targetElement
before
=
false
)
=
>
{
const
draggedIndex
=
selectedList
.
tasks
.
findIndex
(
(
{
id
}
)
=
>
id
=
=
=
draggedElement
.
id
)
;
const
targetIndex
=
selectedList
.
tasks
.
findIndex
(
(
{
id
}
)
=
>
id
=
=
=
targetElement
.
id
)
;
if
(
draggedIndex
=
=
=
-
1
|
|
targetIndex
=
=
=
-
1
|
|
draggedIndex
=
=
=
targetIndex
)
{
return
;
}
const
reordered
=
[
.
.
.
selectedList
.
tasks
]
;
const
[
removed
]
=
reordered
.
splice
(
draggedIndex
1
)
;
const
insertIndex
=
before
?
targetIndex
:
targetIndex
+
1
;
reordered
.
splice
(
insertIndex
>
draggedIndex
?
insertIndex
-
1
:
insertIndex
0
removed
)
;
const
updatedLists
=
{
.
.
.
lists
[
selected
]
:
{
.
.
.
selectedList
tasks
:
reordered
}
}
;
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
WIDGETS_LISTS_UPDATE
data
:
{
lists
:
updatedLists
}
}
)
)
;
}
[
lists
selected
selectedList
dispatch
]
)
;
const
moveTask
=
(
0
external_React_namespaceObject
.
useCallback
)
(
(
task
direction
)
=
>
{
const
index
=
selectedList
.
tasks
.
findIndex
(
(
{
id
}
)
=
>
id
=
=
=
task
.
id
)
;
if
(
index
=
=
=
-
1
)
{
return
;
}
const
targetIndex
=
direction
=
=
=
"
up
"
?
index
-
1
:
index
+
1
;
const
before
=
direction
=
=
=
"
up
"
;
const
targetTask
=
selectedList
.
tasks
[
targetIndex
]
;
if
(
targetTask
)
{
reorderLists
(
task
targetTask
before
)
;
}
}
[
selectedList
reorderLists
]
)
;
(
0
external_React_namespaceObject
.
useEffect
)
(
(
)
=
>
{
const
selectNode
=
selectRef
.
current
;
const
reorderNode
=
reorderListRef
.
current
;
if
(
!
selectNode
|
|
!
reorderNode
)
{
return
undefined
;
}
function
handleSelectChange
(
e
)
{
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
WIDGETS_LISTS_CHANGE_SELECTED
data
:
e
.
target
.
value
}
)
)
;
}
function
handleReorder
(
e
)
{
const
{
draggedElement
targetElement
position
}
=
e
.
detail
;
reorderLists
(
draggedElement
targetElement
position
=
=
=
-
1
)
;
}
reorderNode
.
addEventListener
(
"
reorder
"
handleReorder
)
;
selectNode
.
addEventListener
(
"
change
"
handleSelectChange
)
;
return
(
)
=
>
{
selectNode
.
removeEventListener
(
"
change
"
handleSelectChange
)
;
reorderNode
.
removeEventListener
(
"
reorder
"
handleReorder
)
;
}
;
}
[
dispatch
isEditing
reorderLists
]
)
;
(
0
external_React_namespaceObject
.
useEffect
)
(
(
)
=
>
{
if
(
selected
=
=
=
pendingNewList
)
{
setIsEditing
(
true
)
;
setPendingNewList
(
null
)
;
}
}
[
selected
pendingNewList
]
)
;
function
saveTask
(
)
{
const
trimmedTask
=
newTask
.
trimEnd
(
)
;
if
(
trimmedTask
)
{
const
formattedTask
=
{
value
:
trimmedTask
completed
:
false
created
:
Date
.
now
(
)
id
:
crypto
.
randomUUID
(
)
isUrl
:
isValidUrl
(
trimmedTask
)
}
;
const
updatedLists
=
{
.
.
.
lists
[
selected
]
:
{
.
.
.
selectedList
tasks
:
[
formattedTask
.
.
.
lists
[
selected
]
.
tasks
]
}
}
;
(
0
external_ReactRedux_namespaceObject
.
batch
)
(
(
)
=
>
{
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
WIDGETS_LISTS_UPDATE
data
:
{
lists
:
updatedLists
}
}
)
)
;
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
WIDGETS_LISTS_USER_EVENT
data
:
{
userAction
:
USER_ACTION_TYPES
.
TASK_CREATE
}
}
)
)
;
}
)
;
setNewTask
(
"
"
)
;
}
}
function
updateTask
(
updatedTask
type
)
{
const
isCompletedType
=
type
=
=
=
TASK_TYPE
.
COMPLETED
;
const
isNowCompleted
=
updatedTask
.
completed
;
let
newTasks
=
selectedList
.
tasks
;
let
newCompleted
=
selectedList
.
completed
;
let
localUpdatedTasks
;
let
userAction
;
const
shouldMoveToTasks
=
isCompletedType
&
&
!
isNowCompleted
;
const
shouldMoveToCompleted
=
!
isCompletedType
&
&
isNowCompleted
;
if
(
shouldMoveToTasks
)
{
newCompleted
=
selectedList
.
completed
.
filter
(
task
=
>
task
.
id
!
=
=
updatedTask
.
id
)
;
newTasks
=
[
.
.
.
selectedList
.
tasks
updatedTask
]
;
}
else
if
(
shouldMoveToCompleted
)
{
newTasks
=
selectedList
.
tasks
.
filter
(
task
=
>
task
.
id
!
=
=
updatedTask
.
id
)
;
newCompleted
=
[
.
.
.
selectedList
.
completed
updatedTask
]
;
localUpdatedTasks
=
selectedList
.
tasks
.
map
(
existingTask
=
>
existingTask
.
id
=
=
=
updatedTask
.
id
?
updatedTask
:
existingTask
)
;
userAction
=
USER_ACTION_TYPES
.
TASK_COMPLETE
;
}
else
{
const
targetKey
=
isCompletedType
?
"
completed
"
:
"
tasks
"
;
const
updatedArray
=
selectedList
[
targetKey
]
.
map
(
task
=
>
task
.
id
=
=
=
updatedTask
.
id
?
updatedTask
:
task
)
;
if
(
targetKey
=
=
=
"
tasks
"
)
{
newTasks
=
updatedArray
;
}
else
{
newCompleted
=
updatedArray
;
}
userAction
=
USER_ACTION_TYPES
.
TASK_EDIT
;
}
const
updatedLists
=
{
.
.
.
lists
[
selected
]
:
{
.
.
.
selectedList
tasks
:
newTasks
completed
:
newCompleted
}
}
;
const
localLists
=
{
.
.
.
lists
[
selected
]
:
{
.
.
.
selectedList
tasks
:
localUpdatedTasks
|
|
newTasks
completed
:
newCompleted
.
filter
(
(
{
id
}
)
=
>
id
!
=
=
updatedTask
.
id
)
}
}
;
(
0
external_ReactRedux_namespaceObject
.
batch
)
(
(
)
=
>
{
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
WIDGETS_LISTS_UPDATE
data
:
{
lists
:
updatedLists
localLists
}
}
)
)
;
if
(
userAction
)
{
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
WIDGETS_LISTS_USER_EVENT
data
:
{
userAction
}
}
)
)
;
}
}
)
;
}
function
deleteTask
(
task
type
)
{
const
selectedTasks
=
lists
[
selected
]
[
type
]
;
const
updatedTasks
=
selectedTasks
.
filter
(
(
{
id
}
)
=
>
id
!
=
=
task
.
id
)
;
const
updatedLists
=
{
.
.
.
lists
[
selected
]
:
{
.
.
.
selectedList
[
type
]
:
updatedTasks
}
}
;
(
0
external_ReactRedux_namespaceObject
.
batch
)
(
(
)
=
>
{
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
WIDGETS_LISTS_UPDATE
data
:
{
lists
:
updatedLists
}
}
)
)
;
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
WIDGETS_LISTS_USER_EVENT
data
:
{
userAction
:
USER_ACTION_TYPES
.
TASK_DELETE
}
}
)
)
;
}
)
;
}
function
handleKeyDown
(
e
)
{
if
(
e
.
key
=
=
=
"
Enter
"
&
&
document
.
activeElement
=
=
=
inputRef
.
current
)
{
saveTask
(
)
;
}
else
if
(
e
.
key
=
=
=
"
Escape
"
&
&
document
.
activeElement
=
=
=
inputRef
.
current
)
{
setNewTask
(
"
"
)
;
}
}
function
handleListNameSave
(
newLabel
)
{
const
trimmedLabel
=
newLabel
.
trimEnd
(
)
;
if
(
trimmedLabel
&
&
trimmedLabel
!
=
=
selectedList
?
.
label
)
{
const
updatedLists
=
{
.
.
.
lists
[
selected
]
:
{
.
.
.
selectedList
label
:
trimmedLabel
}
}
;
(
0
external_ReactRedux_namespaceObject
.
batch
)
(
(
)
=
>
{
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
WIDGETS_LISTS_UPDATE
data
:
{
lists
:
updatedLists
}
}
)
)
;
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
WIDGETS_LISTS_USER_EVENT
data
:
{
userAction
:
USER_ACTION_TYPES
.
LIST_EDIT
}
}
)
)
;
}
)
;
setIsEditing
(
false
)
;
}
}
function
handleCreateNewList
(
)
{
const
id
=
crypto
.
randomUUID
(
)
;
const
newLists
=
{
.
.
.
lists
[
id
]
:
{
label
:
"
New
list
"
tasks
:
[
]
completed
:
[
]
}
}
;
(
0
external_ReactRedux_namespaceObject
.
batch
)
(
(
)
=
>
{
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
WIDGETS_LISTS_UPDATE
data
:
{
lists
:
newLists
}
}
)
)
;
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
WIDGETS_LISTS_CHANGE_SELECTED
data
:
id
}
)
)
;
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
WIDGETS_LISTS_USER_EVENT
data
:
{
userAction
:
USER_ACTION_TYPES
.
LIST_CREATE
}
}
)
)
;
}
)
;
setPendingNewList
(
id
)
;
}
function
handleDeleteList
(
)
{
let
updatedLists
=
{
.
.
.
lists
}
;
if
(
updatedLists
[
selected
]
)
{
delete
updatedLists
[
selected
]
;
if
(
Object
.
keys
(
updatedLists
)
?
.
length
=
=
=
0
)
{
updatedLists
=
{
[
crypto
.
randomUUID
(
)
]
:
{
label
:
"
New
list
"
tasks
:
[
]
completed
:
[
]
}
}
;
}
const
listKeys
=
Object
.
keys
(
updatedLists
)
;
const
key
=
listKeys
[
listKeys
.
length
-
1
]
;
(
0
external_ReactRedux_namespaceObject
.
batch
)
(
(
)
=
>
{
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
WIDGETS_LISTS_UPDATE
data
:
{
lists
:
updatedLists
}
}
)
)
;
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
WIDGETS_LISTS_CHANGE_SELECTED
data
:
key
}
)
)
;
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
WIDGETS_LISTS_USER_EVENT
data
:
{
userAction
:
USER_ACTION_TYPES
.
LIST_DELETE
}
}
)
)
;
}
)
;
}
}
function
handleHideLists
(
)
{
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
SET_PREF
data
:
{
name
:
"
widgets
.
lists
.
enabled
"
value
:
false
}
}
)
)
;
}
function
handleCopyListToClipboard
(
)
{
const
currentList
=
lists
[
selected
]
;
if
(
!
currentList
)
{
return
;
}
const
{
label
tasks
=
[
]
completed
=
[
]
}
=
currentList
;
const
uncompleted
=
tasks
.
filter
(
task
=
>
!
task
.
completed
)
;
const
currentCompleted
=
tasks
.
filter
(
task
=
>
task
.
completed
)
;
const
formatted
=
[
List
:
{
label
}
-
-
-
.
.
.
uncompleted
.
map
(
task
=
>
-
[
]
{
task
.
value
}
)
.
.
.
currentCompleted
.
map
(
task
=
>
-
[
x
]
{
task
.
value
}
)
.
.
.
completed
.
map
(
task
=
>
-
[
x
]
{
task
.
value
}
)
]
.
join
(
"
\
n
"
)
;
try
{
navigator
.
clipboard
.
writeText
(
formatted
)
;
}
catch
(
err
)
{
console
.
error
(
"
Copy
failed
"
err
)
;
}
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
WIDGETS_LISTS_USER_EVENT
data
:
{
userAction
:
USER_ACTION_TYPES
.
LIST_COPY
}
}
)
)
;
}
function
handleLearnMore
(
)
{
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
OPEN_LINK
data
:
{
url
:
"
https
:
/
/
support
.
mozilla
.
org
/
kb
/
firefox
-
new
-
tab
-
widgets
"
}
}
)
)
;
}
if
(
!
lists
)
{
return
null
;
}
return
external_React_default
(
)
.
createElement
(
"
article
"
{
className
:
"
lists
"
ref
:
el
=
>
{
listsRef
.
current
=
[
el
]
;
}
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
select
-
wrapper
"
}
external_React_default
(
)
.
createElement
(
EditableText
{
value
:
lists
[
selected
]
?
.
label
|
|
"
"
onSave
:
handleListNameSave
isEditing
:
isEditing
setIsEditing
:
setIsEditing
type
:
"
list
"
maxLength
:
30
}
external_React_default
(
)
.
createElement
(
"
moz
-
select
"
{
ref
:
selectRef
value
:
selected
}
Object
.
entries
(
lists
)
.
map
(
(
[
key
list
]
)
=
>
external_React_default
(
)
.
createElement
(
"
moz
-
option
"
{
key
:
key
value
:
key
label
:
list
.
label
}
)
)
)
)
external_React_default
(
)
.
createElement
(
"
moz
-
button
"
{
className
:
"
lists
-
panel
-
button
"
iconSrc
:
"
chrome
:
/
/
global
/
skin
/
icons
/
more
.
svg
"
menuId
:
"
lists
-
panel
"
type
:
"
ghost
"
}
)
external_React_default
(
)
.
createElement
(
"
panel
-
list
"
{
id
:
"
lists
-
panel
"
}
external_React_default
(
)
.
createElement
(
"
panel
-
item
"
{
"
data
-
l10n
-
id
"
:
"
newtab
-
widget
-
lists
-
menu
-
edit
"
onClick
:
(
)
=
>
setIsEditing
(
true
)
}
)
external_React_default
(
)
.
createElement
(
"
panel
-
item
"
{
"
data
-
l10n
-
id
"
:
"
newtab
-
widget
-
lists
-
menu
-
create
"
onClick
:
(
)
=
>
handleCreateNewList
(
)
}
)
external_React_default
(
)
.
createElement
(
"
panel
-
item
"
{
"
data
-
l10n
-
id
"
:
"
newtab
-
widget
-
lists
-
menu
-
delete
"
onClick
:
(
)
=
>
handleDeleteList
(
)
}
)
external_React_default
(
)
.
createElement
(
"
hr
"
null
)
external_React_default
(
)
.
createElement
(
"
panel
-
item
"
{
"
data
-
l10n
-
id
"
:
"
newtab
-
widget
-
lists
-
menu
-
copy
"
onClick
:
(
)
=
>
handleCopyListToClipboard
(
)
}
)
external_React_default
(
)
.
createElement
(
"
panel
-
item
"
{
"
data
-
l10n
-
id
"
:
"
newtab
-
widget
-
lists
-
menu
-
hide
"
onClick
:
(
)
=
>
handleHideLists
(
)
}
)
external_React_default
(
)
.
createElement
(
"
panel
-
item
"
{
className
:
"
learn
-
more
"
"
data
-
l10n
-
id
"
:
"
newtab
-
widget
-
lists
-
menu
-
learn
-
more
"
onClick
:
handleLearnMore
}
)
)
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
add
-
task
-
container
"
}
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
icon
icon
-
add
"
}
)
external_React_default
(
)
.
createElement
(
"
input
"
{
ref
:
inputRef
onBlur
:
(
)
=
>
saveTask
(
)
onChange
:
e
=
>
setNewTask
(
e
.
target
.
value
)
value
:
newTask
placeholder
:
"
Add
a
task
"
className
:
"
add
-
task
-
input
"
onKeyDown
:
handleKeyDown
type
:
"
text
"
maxLength
:
100
}
)
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
task
-
list
-
wrapper
"
}
external_React_default
(
)
.
createElement
(
"
moz
-
reorderable
-
list
"
{
ref
:
reorderListRef
itemSelector
:
"
fieldset
.
task
-
type
-
tasks
"
dragSelector
:
"
.
checkbox
-
wrapper
"
}
external_React_default
(
)
.
createElement
(
"
fieldset
"
null
selectedList
?
.
tasks
.
length
>
=
1
?
selectedList
.
tasks
.
map
(
(
task
index
)
=
>
external_React_default
(
)
.
createElement
(
ListItem
{
type
:
TASK_TYPE
.
IN_PROGRESS
task
:
task
key
:
task
.
id
updateTask
:
updateTask
deleteTask
:
deleteTask
moveTask
:
moveTask
isValidUrl
:
isValidUrl
isFirst
:
index
=
=
=
0
isLast
:
index
=
=
=
selectedList
.
tasks
.
length
-
1
}
)
)
:
external_React_default
(
)
.
createElement
(
"
p
"
{
className
:
"
empty
-
list
-
text
"
"
data
-
l10n
-
id
"
:
"
newtab
-
widget
-
lists
-
empty
-
cta
"
}
)
selectedList
?
.
completed
.
length
>
=
1
&
&
external_React_default
(
)
.
createElement
(
"
details
"
{
className
:
"
completed
-
task
-
wrapper
"
}
external_React_default
(
)
.
createElement
(
"
summary
"
null
external_React_default
(
)
.
createElement
(
"
span
"
{
"
data
-
l10n
-
id
"
:
"
newtab
-
widget
-
lists
-
completed
-
list
"
"
data
-
l10n
-
args
"
:
JSON
.
stringify
(
{
number
:
lists
[
selected
]
?
.
completed
.
length
}
)
className
:
"
completed
-
title
"
}
)
)
selectedList
?
.
completed
.
map
(
completedTask
=
>
external_React_default
(
)
.
createElement
(
ListItem
{
key
:
completedTask
.
id
type
:
TASK_TYPE
.
COMPLETED
task
:
completedTask
deleteTask
:
deleteTask
updateTask
:
updateTask
}
)
)
)
)
)
)
)
;
}
function
ListItem
(
{
task
updateTask
deleteTask
moveTask
isValidUrl
type
isFirst
=
false
isLast
=
false
}
)
{
const
[
isEditing
setIsEditing
]
=
(
0
external_React_namespaceObject
.
useState
)
(
false
)
;
const
isCompleted
=
type
=
=
=
TASK_TYPE
.
COMPLETED
;
function
handleCheckboxChange
(
e
)
{
const
updatedTask
=
{
.
.
.
task
completed
:
e
.
target
.
checked
}
;
updateTask
(
updatedTask
type
)
;
}
function
handleSave
(
newValue
)
{
const
trimmedTask
=
newValue
.
trimEnd
(
)
;
if
(
trimmedTask
&
&
trimmedTask
!
=
=
task
.
value
)
{
updateTask
(
{
.
.
.
task
value
:
newValue
isUrl
:
isValidUrl
(
trimmedTask
)
}
type
)
;
setIsEditing
(
false
)
;
}
}
function
handleDelete
(
)
{
deleteTask
(
task
type
)
;
}
const
taskLabel
=
task
.
isUrl
?
external_React_default
(
)
.
createElement
(
"
a
"
{
href
:
task
.
value
rel
:
"
noopener
noreferrer
"
target
:
"
_blank
"
className
:
"
task
-
label
"
title
:
task
.
value
}
task
.
value
)
:
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
task
-
label
"
title
:
task
.
value
onClick
:
(
)
=
>
setIsEditing
(
true
)
}
task
.
value
)
;
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
task
-
item
task
-
type
-
{
type
}
id
:
task
.
id
key
:
task
.
id
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
checkbox
-
wrapper
"
}
external_React_default
(
)
.
createElement
(
"
input
"
{
type
:
"
checkbox
"
onChange
:
handleCheckboxChange
checked
:
task
.
completed
}
)
isCompleted
?
taskLabel
:
external_React_default
(
)
.
createElement
(
EditableText
{
isEditing
:
isEditing
setIsEditing
:
setIsEditing
value
:
task
.
value
onSave
:
handleSave
type
:
"
task
"
}
taskLabel
)
)
external_React_default
(
)
.
createElement
(
"
moz
-
button
"
{
iconSrc
:
"
chrome
:
/
/
global
/
skin
/
icons
/
more
.
svg
"
menuId
:
panel
-
task
-
{
task
.
id
}
type
:
"
ghost
"
}
)
external_React_default
(
)
.
createElement
(
"
panel
-
list
"
{
id
:
panel
-
task
-
{
task
.
id
}
}
!
isCompleted
&
&
external_React_default
(
)
.
createElement
(
(
external_React_default
(
)
)
.
Fragment
null
task
.
isUrl
&
&
external_React_default
(
)
.
createElement
(
"
panel
-
item
"
{
"
data
-
l10n
-
id
"
:
"
newtab
-
widget
-
lists
-
input
-
menu
-
open
-
link
"
onClick
:
(
)
=
>
window
.
open
(
task
.
value
"
_blank
"
"
noopener
"
)
}
)
external_React_default
(
)
.
createElement
(
"
panel
-
item
"
Lists_extends
(
{
}
isFirst
?
{
disabled
:
true
}
:
{
}
{
onClick
:
(
)
=
>
moveTask
(
task
"
up
"
)
"
data
-
l10n
-
id
"
:
"
newtab
-
widget
-
lists
-
input
-
menu
-
move
-
up
"
}
)
)
external_React_default
(
)
.
createElement
(
"
panel
-
item
"
Lists_extends
(
{
}
isLast
?
{
disabled
:
true
}
:
{
}
{
onClick
:
(
)
=
>
moveTask
(
task
"
down
"
)
"
data
-
l10n
-
id
"
:
"
newtab
-
widget
-
lists
-
input
-
menu
-
move
-
down
"
}
)
)
external_React_default
(
)
.
createElement
(
"
panel
-
item
"
{
"
data
-
l10n
-
id
"
:
"
newtab
-
widget
-
lists
-
input
-
menu
-
edit
"
className
:
"
edit
-
item
"
onClick
:
(
)
=
>
setIsEditing
(
true
)
}
)
)
external_React_default
(
)
.
createElement
(
"
panel
-
item
"
{
"
data
-
l10n
-
id
"
:
"
newtab
-
widget
-
lists
-
input
-
menu
-
delete
"
className
:
"
delete
-
item
"
onClick
:
handleDelete
}
)
)
)
;
}
function
EditableText
(
{
value
isEditing
setIsEditing
onSave
children
type
maxLength
=
100
}
)
{
const
[
tempValue
setTempValue
]
=
(
0
external_React_namespaceObject
.
useState
)
(
value
)
;
const
inputRef
=
(
0
external_React_namespaceObject
.
useRef
)
(
null
)
;
(
0
external_React_namespaceObject
.
useEffect
)
(
(
)
=
>
{
if
(
isEditing
)
{
inputRef
.
current
?
.
focus
(
)
;
}
else
{
setTempValue
(
value
)
;
}
}
[
isEditing
value
]
)
;
function
handleKeyDown
(
e
)
{
if
(
e
.
key
=
=
=
"
Enter
"
)
{
onSave
(
tempValue
.
trim
(
)
)
;
setIsEditing
(
false
)
;
}
else
if
(
e
.
key
=
=
=
"
Escape
"
)
{
setIsEditing
(
false
)
;
setTempValue
(
value
)
;
}
}
function
handleOnBlur
(
)
{
onSave
(
tempValue
.
trim
(
)
)
;
setIsEditing
(
false
)
;
}
return
isEditing
?
external_React_default
(
)
.
createElement
(
"
input
"
{
className
:
edit
-
{
type
}
ref
:
inputRef
type
:
"
text
"
value
:
tempValue
maxLength
:
maxLength
onChange
:
event
=
>
setTempValue
(
event
.
target
.
value
)
onBlur
:
handleOnBlur
onKeyDown
:
handleKeyDown
}
)
:
[
children
]
;
}
;
const
FocusTimer_USER_ACTION_TYPES
=
{
TIMER_SET
:
"
timer_set
"
TIMER_PLAY
:
"
timer_play
"
TIMER_PAUSE
:
"
timer_pause
"
TIMER_RESET
:
"
timer_reset
"
TIMER_END
:
"
timer_end
"
TIMER_TOGGLE_FOCUS
:
"
timer_toggle_focus
"
TIMER_TOGGLE_BREAK
:
"
timer_toggle_break
"
}
;
const
calculateTimeRemaining
=
(
duration
start
)
=
>
{
const
currentTime
=
Math
.
floor
(
Date
.
now
(
)
/
1000
)
;
return
Math
.
max
(
duration
-
(
currentTime
-
start
)
0
)
;
}
;
const
formatTime
=
seconds
=
>
{
const
minutes
=
Math
.
floor
(
seconds
/
60
)
.
toString
(
)
.
padStart
(
2
"
0
"
)
;
const
secs
=
(
seconds
%
60
)
.
toString
(
)
.
padStart
(
2
"
0
"
)
;
return
{
minutes
}
:
{
secs
}
;
}
;
const
polarToPercent
=
(
cx
cy
radius
angle
)
=
>
{
const
rad
=
(
angle
-
90
)
*
Math
.
PI
/
180
;
const
x
=
cx
+
radius
*
Math
.
cos
(
rad
)
;
const
y
=
cy
+
radius
*
Math
.
sin
(
rad
)
;
return
{
x
}
%
{
y
}
%
;
}
;
const
getClipPath
=
progress
=
>
{
const
cx
=
50
;
const
cy
=
50
;
const
radius
=
50
;
const
angle
=
progress
>
0
?
Math
.
max
(
progress
*
360
6
)
:
0
;
const
points
=
[
50
%
50
%
]
;
for
(
let
a
=
0
;
a
<
=
angle
;
a
+
=
2
)
{
points
.
push
(
polarToPercent
(
cx
cy
radius
a
)
)
;
}
return
polygon
(
{
points
.
join
(
"
"
)
}
)
;
}
;
const
FocusTimer
=
(
{
dispatch
}
)
=
>
{
const
[
timeLeft
setTimeLeft
]
=
(
0
external_React_namespaceObject
.
useState
)
(
0
)
;
const
[
progress
setProgress
]
=
(
0
external_React_namespaceObject
.
useState
)
(
0
)
;
const
[
progressVisible
setProgressVisible
]
=
(
0
external_React_namespaceObject
.
useState
)
(
false
)
;
const
timerType
=
(
0
external_ReactRedux_namespaceObject
.
useSelector
)
(
state
=
>
state
.
TimerWidget
.
timerType
)
;
const
activeMinutesRef
=
(
0
external_React_namespaceObject
.
useRef
)
(
null
)
;
const
activeSecondsRef
=
(
0
external_React_namespaceObject
.
useRef
)
(
null
)
;
const
idleMinutesRef
=
(
0
external_React_namespaceObject
.
useRef
)
(
null
)
;
const
idleSecondsRef
=
(
0
external_React_namespaceObject
.
useRef
)
(
null
)
;
const
arcRef
=
(
0
external_React_namespaceObject
.
useRef
)
(
null
)
;
const
timerData
=
(
0
external_ReactRedux_namespaceObject
.
useSelector
)
(
state
=
>
state
.
TimerWidget
)
;
const
{
duration
initialDuration
startTime
isRunning
}
=
timerData
[
timerType
]
;
const
initialTimerDuration
=
timerData
[
timerType
]
.
initialDuration
;
const
handleIntersection
=
(
0
external_React_namespaceObject
.
useCallback
)
(
(
)
=
>
{
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
WIDGETS_TIMER_USER_IMPRESSION
}
)
)
;
}
[
dispatch
]
)
;
const
timerRef
=
useIntersectionObserver
(
handleIntersection
)
;
const
resetProgressCircle
=
(
0
external_React_namespaceObject
.
useCallback
)
(
(
)
=
>
{
if
(
arcRef
?
.
current
)
{
arcRef
.
current
.
style
.
clipPath
=
"
polygon
(
50
%
50
%
)
"
;
arcRef
.
current
.
style
.
webkitClipPath
=
"
polygon
(
50
%
50
%
)
"
;
}
setProgress
(
0
)
;
}
[
arcRef
]
)
;
const
prefs
=
(
0
external_ReactRedux_namespaceObject
.
useSelector
)
(
state
=
>
state
.
Prefs
.
values
)
;
const
showSystemNotifications
=
prefs
[
"
widgets
.
focusTimer
.
showSystemNotifications
"
]
;
(
0
external_React_namespaceObject
.
useEffect
)
(
(
)
=
>
{
if
(
isRunning
)
{
setProgressVisible
(
true
)
;
}
}
[
isRunning
]
)
;
(
0
external_React_namespaceObject
.
useEffect
)
(
(
)
=
>
{
let
interval
;
if
(
isRunning
&
&
duration
>
0
)
{
interval
=
setInterval
(
(
)
=
>
{
const
remaining
=
calculateTimeRemaining
(
duration
startTime
)
;
if
(
remaining
<
=
0
)
{
clearInterval
(
interval
)
;
(
0
external_ReactRedux_namespaceObject
.
batch
)
(
(
)
=
>
{
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
WIDGETS_TIMER_END
data
:
{
timerType
duration
:
initialTimerDuration
initialDuration
:
initialTimerDuration
}
}
)
)
;
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
WIDGETS_TIMER_USER_EVENT
data
:
{
userAction
:
FocusTimer_USER_ACTION_TYPES
.
TIMER_END
}
}
)
)
;
}
)
;
setProgress
(
1
)
;
setTimeout
(
(
)
=
>
{
resetProgressCircle
(
)
;
setTimeout
(
(
)
=
>
{
setProgressVisible
(
false
)
;
(
0
external_ReactRedux_namespaceObject
.
batch
)
(
(
)
=
>
{
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
WIDGETS_TIMER_SET_TYPE
data
:
{
timerType
:
timerType
=
=
=
"
focus
"
?
"
break
"
:
"
focus
"
}
}
)
)
;
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
WIDGETS_TIMER_USER_EVENT
data
:
{
userAction
:
timerType
=
=
=
"
focus
"
?
FocusTimer_USER_ACTION_TYPES
.
TIMER_TOGGLE_BREAK
:
FocusTimer_USER_ACTION_TYPES
.
TIMER_TOGGLE_FOCUS
}
}
)
)
;
}
)
;
}
1500
)
;
}
1500
)
;
}
setTimeLeft
(
remaining
)
;
setProgress
(
(
initialDuration
-
remaining
)
/
initialDuration
)
;
}
1000
)
;
}
const
newTime
=
isRunning
?
calculateTimeRemaining
(
duration
startTime
)
:
duration
;
setTimeLeft
(
newTime
)
;
return
(
)
=
>
clearInterval
(
interval
)
;
}
[
isRunning
startTime
duration
initialDuration
dispatch
resetProgressCircle
timerType
initialTimerDuration
]
)
;
(
0
external_React_namespaceObject
.
useEffect
)
(
(
)
=
>
{
if
(
arcRef
?
.
current
)
{
arcRef
.
current
.
style
.
clipPath
=
getClipPath
(
progress
)
;
}
}
[
progress
]
)
;
const
setTimerDuration
=
(
)
=
>
{
const
minutesEl
=
progressVisible
?
activeMinutesRef
.
current
:
idleMinutesRef
.
current
;
const
secondsEl
=
progressVisible
?
activeSecondsRef
.
current
:
idleSecondsRef
.
current
;
const
minutesValue
=
minutesEl
.
innerText
.
trim
(
)
|
|
"
0
"
;
const
secondsValue
=
secondsEl
.
innerText
.
trim
(
)
|
|
"
0
"
;
let
minutes
=
parseInt
(
minutesValue
|
|
"
0
"
10
)
;
let
seconds
=
parseInt
(
secondsValue
|
|
"
0
"
10
)
;
minutes
=
Math
.
min
(
minutes
99
)
;
seconds
=
Math
.
min
(
seconds
59
)
;
const
totalSeconds
=
minutes
*
60
+
seconds
;
if
(
!
Number
.
isNaN
(
totalSeconds
)
&
&
totalSeconds
>
0
&
&
totalSeconds
!
=
=
duration
)
{
(
0
external_ReactRedux_namespaceObject
.
batch
)
(
(
)
=
>
{
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
WIDGETS_TIMER_SET_DURATION
data
:
{
timerType
duration
:
totalSeconds
}
}
)
)
;
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
WIDGETS_TIMER_USER_EVENT
data
:
{
userAction
:
FocusTimer_USER_ACTION_TYPES
.
TIMER_SET
}
}
)
)
;
}
)
;
}
}
;
const
toggleTimer
=
(
)
=
>
{
if
(
!
isRunning
&
&
duration
>
0
)
{
setProgressVisible
(
true
)
;
(
0
external_ReactRedux_namespaceObject
.
batch
)
(
(
)
=
>
{
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
WIDGETS_TIMER_PLAY
data
:
{
timerType
}
}
)
)
;
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
WIDGETS_TIMER_USER_EVENT
data
:
{
userAction
:
FocusTimer_USER_ACTION_TYPES
.
TIMER_PLAY
}
}
)
)
;
}
)
;
}
else
if
(
isRunning
)
{
const
remaining
=
calculateTimeRemaining
(
duration
startTime
)
;
(
0
external_ReactRedux_namespaceObject
.
batch
)
(
(
)
=
>
{
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
WIDGETS_TIMER_PAUSE
data
:
{
timerType
duration
:
remaining
}
}
)
)
;
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
WIDGETS_TIMER_USER_EVENT
data
:
{
userAction
:
FocusTimer_USER_ACTION_TYPES
.
TIMER_PAUSE
}
}
)
)
;
}
)
;
}
}
;
const
resetTimer
=
(
)
=
>
{
(
0
external_ReactRedux_namespaceObject
.
batch
)
(
(
)
=
>
{
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
WIDGETS_TIMER_RESET
data
:
{
timerType
duration
:
initialTimerDuration
initialDuration
:
initialTimerDuration
}
}
)
)
;
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
WIDGETS_TIMER_USER_EVENT
data
:
{
userAction
:
FocusTimer_USER_ACTION_TYPES
.
TIMER_RESET
}
}
)
)
;
}
)
;
resetProgressCircle
(
)
;
if
(
progressVisible
)
{
setProgressVisible
(
false
)
;
}
}
;
const
toggleType
=
type
=
>
{
const
oldTypeRemaining
=
calculateTimeRemaining
(
duration
startTime
)
;
(
0
external_ReactRedux_namespaceObject
.
batch
)
(
(
)
=
>
{
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
WIDGETS_TIMER_PAUSE
data
:
{
timerType
duration
:
oldTypeRemaining
}
}
)
)
;
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
WIDGETS_TIMER_USER_EVENT
data
:
{
userAction
:
FocusTimer_USER_ACTION_TYPES
.
TIMER_PAUSE
}
}
)
)
;
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
WIDGETS_TIMER_SET_TYPE
data
:
{
timerType
:
type
}
}
)
)
;
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
WIDGETS_TIMER_USER_EVENT
data
:
{
userAction
:
type
=
=
=
"
focus
"
?
FocusTimer_USER_ACTION_TYPES
.
TIMER_TOGGLE_FOCUS
:
FocusTimer_USER_ACTION_TYPES
.
TIMER_TOGGLE_BREAK
}
}
)
)
;
}
)
;
}
;
const
handleKeyDown
=
e
=
>
{
if
(
e
.
key
=
=
=
"
Enter
"
)
{
e
.
preventDefault
(
)
;
setTimerDuration
(
e
)
;
}
if
(
e
.
key
=
=
=
"
Tab
"
)
{
setTimerDuration
(
e
)
;
}
}
;
const
handleBeforeInput
=
e
=
>
{
const
input
=
e
.
data
;
const
values
=
e
.
target
.
innerText
.
trim
(
)
;
if
(
!
/
^
\
d
+
/
.
test
(
input
)
)
{
e
.
preventDefault
(
)
;
}
if
(
values
.
length
>
=
2
)
{
e
.
preventDefault
(
)
;
}
const
selection
=
window
.
getSelection
(
)
;
const
selectedText
=
selection
.
toString
(
)
;
if
(
selectedText
=
=
=
values
)
{
e
.
preventDefault
(
)
;
e
.
target
.
innerText
=
input
;
const
range
=
document
.
createRange
(
)
;
range
.
selectNodeContents
(
e
.
target
)
;
range
.
collapse
(
false
)
;
const
sel
=
window
.
getSelection
(
)
;
sel
.
removeAllRanges
(
)
;
sel
.
addRange
(
range
)
;
}
}
;
const
handleFocus
=
e
=
>
{
if
(
isRunning
)
{
const
remaining
=
calculateTimeRemaining
(
duration
startTime
)
;
(
0
external_ReactRedux_namespaceObject
.
batch
)
(
(
)
=
>
{
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
WIDGETS_TIMER_PAUSE
data
:
{
timerType
duration
:
remaining
}
}
)
)
;
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
WIDGETS_TIMER_USER_EVENT
data
:
{
userAction
:
FocusTimer_USER_ACTION_TYPES
.
TIMER_PAUSE
}
}
)
)
;
}
)
;
}
const
el
=
e
.
target
;
if
(
document
.
createRange
&
&
window
.
getSelection
)
{
const
range
=
document
.
createRange
(
)
;
range
.
selectNodeContents
(
el
)
;
const
sel
=
window
.
getSelection
(
)
;
sel
.
removeAllRanges
(
)
;
sel
.
addRange
(
range
)
;
}
}
;
function
handleLearnMore
(
)
{
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
OPEN_LINK
data
:
{
url
:
"
https
:
/
/
support
.
mozilla
.
org
/
kb
/
firefox
-
new
-
tab
-
widgets
"
}
}
)
)
;
}
function
handlePrefUpdate
(
prefName
prefValue
)
{
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
SET_PREF
data
:
{
name
:
prefName
value
:
prefValue
}
}
)
)
;
}
return
timerData
?
external_React_default
(
)
.
createElement
(
"
article
"
{
className
:
"
focus
-
timer
"
ref
:
el
=
>
{
timerRef
.
current
=
[
el
]
;
}
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
focus
-
timer
-
tabs
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
focus
-
timer
-
tabs
-
buttons
"
}
external_React_default
(
)
.
createElement
(
"
moz
-
button
"
{
type
:
timerType
=
=
=
"
focus
"
?
"
primary
"
:
"
ghost
"
"
data
-
l10n
-
id
"
:
"
newtab
-
widget
-
timer
-
mode
-
focus
"
onClick
:
(
)
=
>
toggleType
(
"
focus
"
)
}
)
external_React_default
(
)
.
createElement
(
"
moz
-
button
"
{
type
:
timerType
=
=
=
"
break
"
?
"
primary
"
:
"
ghost
"
"
data
-
l10n
-
id
"
:
"
newtab
-
widget
-
timer
-
mode
-
break
"
onClick
:
(
)
=
>
toggleType
(
"
break
"
)
}
)
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
focus
-
timer
-
context
-
menu
-
wrapper
"
}
external_React_default
(
)
.
createElement
(
"
moz
-
button
"
{
className
:
"
focus
-
timer
-
context
-
menu
-
button
"
iconSrc
:
"
chrome
:
/
/
global
/
skin
/
icons
/
more
.
svg
"
menuId
:
"
focus
-
timer
-
context
-
menu
"
type
:
"
ghost
"
}
)
external_React_default
(
)
.
createElement
(
"
panel
-
list
"
{
id
:
"
focus
-
timer
-
context
-
menu
"
}
external_React_default
(
)
.
createElement
(
"
panel
-
item
"
{
"
data
-
l10n
-
id
"
:
showSystemNotifications
?
"
newtab
-
widget
-
timer
-
menu
-
notifications
"
:
"
newtab
-
widget
-
timer
-
menu
-
notifications
-
on
"
onClick
:
(
)
=
>
{
handlePrefUpdate
(
"
widgets
.
focusTimer
.
showSystemNotifications
"
!
showSystemNotifications
)
;
}
}
)
external_React_default
(
)
.
createElement
(
"
panel
-
item
"
{
"
data
-
l10n
-
id
"
:
"
newtab
-
widget
-
timer
-
menu
-
hide
"
onClick
:
(
)
=
>
{
handlePrefUpdate
(
"
widgets
.
focusTimer
.
enabled
"
false
)
;
}
}
)
external_React_default
(
)
.
createElement
(
"
panel
-
item
"
{
"
data
-
l10n
-
id
"
:
"
newtab
-
widget
-
timer
-
menu
-
learn
-
more
"
onClick
:
handleLearnMore
}
)
)
)
)
external_React_default
(
)
.
createElement
(
"
div
"
{
role
:
"
progress
"
className
:
progress
-
circle
-
wrapper
{
progressVisible
?
"
visible
"
:
"
"
}
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
progress
-
circle
-
background
"
}
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
progress
-
circle
{
timerType
=
=
=
"
focus
"
?
"
focus
-
visible
"
:
"
focus
-
hidden
"
}
ref
:
timerType
=
=
=
"
focus
"
?
arcRef
:
null
}
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
progress
-
circle
{
timerType
=
=
=
"
break
"
?
"
progress
-
circle
-
break
break
-
visible
"
:
"
break
-
hidden
"
}
ref
:
timerType
=
=
=
"
break
"
?
arcRef
:
null
}
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
progress
-
circle
-
complete
{
progress
=
=
=
1
?
"
visible
"
:
"
"
}
}
)
progressVisible
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
role
:
"
timer
"
className
:
"
progress
-
circle
-
label
"
}
external_React_default
(
)
.
createElement
(
EditableTimerFields
{
minutesRef
:
activeMinutesRef
secondsRef
:
activeSecondsRef
onKeyDown
:
handleKeyDown
onBeforeInput
:
handleBeforeInput
onFocus
:
handleFocus
timeLeft
:
timeLeft
onBlur
:
(
)
=
>
setTimerDuration
(
)
}
)
)
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
set
-
timer
-
controls
-
wrapper
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
role
:
"
timer
"
className
:
set
-
timer
-
countdown
progress
-
circle
-
label
{
progressVisible
?
"
hidden
"
:
"
"
}
"
aria
-
hidden
"
:
progressVisible
}
external_React_default
(
)
.
createElement
(
EditableTimerFields
{
minutesRef
:
idleMinutesRef
secondsRef
:
idleSecondsRef
onKeyDown
:
handleKeyDown
onBeforeInput
:
handleBeforeInput
onFocus
:
handleFocus
timeLeft
:
timeLeft
tabIndex
:
progressVisible
?
-
1
:
0
onBlur
:
(
)
=
>
setTimerDuration
(
)
}
)
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
focus
-
timer
-
controls
{
progressVisible
?
"
timer
-
running
"
:
"
"
}
}
external_React_default
(
)
.
createElement
(
"
moz
-
button
"
{
type
:
"
primary
"
iconsrc
:
chrome
:
/
/
global
/
skin
/
media
/
{
isRunning
?
"
pause
"
:
"
play
"
}
-
fill
.
svg
"
data
-
l10n
-
id
"
:
isRunning
?
"
newtab
-
widget
-
timer
-
pause
"
:
"
newtab
-
widget
-
timer
-
play
"
onClick
:
toggleTimer
}
)
external_React_default
(
)
.
createElement
(
"
moz
-
button
"
{
type
:
"
icon
ghost
"
iconsrc
:
"
chrome
:
/
/
newtab
/
content
/
data
/
content
/
assets
/
arrow
-
clockwise
-
16
.
svg
"
"
data
-
l10n
-
id
"
:
"
newtab
-
widget
-
timer
-
reset
"
onClick
:
resetTimer
}
)
)
)
)
:
null
;
}
;
function
EditableTimerFields
(
{
minutesRef
secondsRef
tabIndex
=
0
.
.
.
props
}
)
{
return
external_React_default
(
)
.
createElement
(
(
external_React_default
(
)
)
.
Fragment
null
external_React_default
(
)
.
createElement
(
"
span
"
{
contentEditable
:
"
true
"
ref
:
minutesRef
className
:
"
timer
-
set
-
minutes
"
onKeyDown
:
props
.
onKeyDown
onBeforeInput
:
props
.
onBeforeInput
onFocus
:
props
.
onFocus
onBlur
:
props
.
onBlur
tabIndex
:
tabIndex
}
formatTime
(
props
.
timeLeft
)
.
split
(
"
:
"
)
[
0
]
)
"
:
"
external_React_default
(
)
.
createElement
(
"
span
"
{
contentEditable
:
"
true
"
ref
:
secondsRef
className
:
"
timer
-
set
-
seconds
"
onKeyDown
:
props
.
onKeyDown
onBeforeInput
:
props
.
onBeforeInput
onFocus
:
props
.
onFocus
onBlur
:
props
.
onBlur
tabIndex
:
tabIndex
}
formatTime
(
props
.
timeLeft
)
.
split
(
"
:
"
)
[
1
]
)
)
;
}
;
const
PREF_WIDGETS_LISTS_ENABLED
=
"
widgets
.
lists
.
enabled
"
;
const
PREF_WIDGETS_SYSTEM_LISTS_ENABLED
=
"
widgets
.
system
.
lists
.
enabled
"
;
const
PREF_WIDGETS_TIMER_ENABLED
=
"
widgets
.
focusTimer
.
enabled
"
;
const
PREF_WIDGETS_SYSTEM_TIMER_ENABLED
=
"
widgets
.
system
.
focusTimer
.
enabled
"
;
function
Widgets
(
)
{
const
prefs
=
(
0
external_ReactRedux_namespaceObject
.
useSelector
)
(
state
=
>
state
.
Prefs
.
values
)
;
const
dispatch
=
(
0
external_ReactRedux_namespaceObject
.
useDispatch
)
(
)
;
const
nimbusListsEnabled
=
prefs
.
widgetsConfig
?
.
listsEnabled
;
const
nimbusTimerEnabled
=
prefs
.
widgetsConfig
?
.
timerEnabled
;
const
listsEnabled
=
(
nimbusListsEnabled
|
|
prefs
[
PREF_WIDGETS_SYSTEM_LISTS_ENABLED
]
)
&
&
prefs
[
PREF_WIDGETS_LISTS_ENABLED
]
;
const
timerEnabled
=
(
nimbusTimerEnabled
|
|
prefs
[
PREF_WIDGETS_SYSTEM_TIMER_ENABLED
]
)
&
&
prefs
[
PREF_WIDGETS_TIMER_ENABLED
]
;
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
widgets
-
container
"
}
listsEnabled
&
&
external_React_default
(
)
.
createElement
(
Lists
{
dispatch
:
dispatch
}
)
timerEnabled
&
&
external_React_default
(
)
.
createElement
(
FocusTimer
{
dispatch
:
dispatch
}
)
)
;
}
;
const
ALLOWED_CSS_URL_PREFIXES
=
[
"
chrome
:
/
/
"
"
resource
:
/
/
"
"
https
:
/
/
img
-
getpocket
.
cdn
.
mozilla
.
net
/
"
]
;
const
DUMMY_CSS_SELECTOR
=
"
DUMMY
#
CSS
.
SELECTOR
"
;
function
isAllowedCSS
(
property
value
)
{
if
(
value
=
=
=
undefined
)
{
return
true
;
}
const
urls
=
value
.
match
(
/
url
\
(
"
[
^
"
]
+
"
\
)
/
g
)
;
return
!
urls
|
|
urls
.
every
(
url
=
>
ALLOWED_CSS_URL_PREFIXES
.
some
(
prefix
=
>
url
.
slice
(
5
)
.
startsWith
(
prefix
)
)
)
;
}
class
_DiscoveryStreamBase
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
onStyleMount
=
this
.
onStyleMount
.
bind
(
this
)
;
}
onStyleMount
(
style
)
{
if
(
!
style
)
{
return
;
}
const
{
sheet
}
=
style
;
const
styles
=
JSON
.
parse
(
style
.
dataset
.
styles
)
;
styles
.
forEach
(
(
row
rowIndex
)
=
>
{
row
.
forEach
(
(
component
componentIndex
)
=
>
{
if
(
!
component
)
{
return
;
}
Object
.
entries
(
component
)
.
forEach
(
(
[
selectors
declarations
]
)
=
>
{
sheet
.
insertRule
(
{
DUMMY_CSS_SELECTOR
}
{
}
)
;
const
[
rule
]
=
sheet
.
cssRules
;
rule
.
style
=
declarations
;
[
.
.
.
rule
.
style
]
.
forEach
(
property
=
>
{
const
value
=
rule
.
style
[
property
]
;
if
(
!
isAllowedCSS
(
property
value
)
)
{
console
.
error
(
Bad
CSS
declaration
{
property
}
:
{
value
}
)
;
rule
.
style
.
removeProperty
(
property
)
;
}
}
)
;
const
prefix
=
.
ds
-
layout
>
.
ds
-
column
:
nth
-
child
(
{
rowIndex
+
1
}
)
.
ds
-
column
-
grid
>
:
nth
-
child
(
{
componentIndex
+
1
}
)
;
rule
.
selectorText
=
selectors
.
split
(
"
"
)
.
map
(
selector
=
>
prefix
+
(
selector
[
0
]
=
=
=
"
:
"
?
"
"
:
"
"
)
+
selector
)
.
join
(
"
"
)
;
if
(
rule
.
selectorText
=
=
=
DUMMY_CSS_SELECTOR
)
{
console
.
error
(
Bad
CSS
selector
{
selectors
}
)
;
}
}
)
;
}
)
;
}
)
;
}
renderComponent
(
component
)
{
switch
(
component
.
type
)
{
case
"
Highlights
"
:
return
external_React_default
(
)
.
createElement
(
Highlights
null
)
;
case
"
TopSites
"
:
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
ds
-
top
-
sites
"
}
external_React_default
(
)
.
createElement
(
TopSites_TopSites
{
isFixed
:
true
title
:
component
.
header
?
.
title
}
)
)
;
case
"
TextPromo
"
:
return
external_React_default
(
)
.
createElement
(
DSTextPromo
{
dispatch
:
this
.
props
.
dispatch
type
:
component
.
type
data
:
component
.
data
}
)
;
case
"
Signup
"
:
return
external_React_default
(
)
.
createElement
(
DSSignup
{
dispatch
:
this
.
props
.
dispatch
type
:
component
.
type
data
:
component
.
data
}
)
;
case
"
Message
"
:
return
external_React_default
(
)
.
createElement
(
DSMessage
{
title
:
component
.
header
&
&
component
.
header
.
title
subtitle
:
component
.
header
&
&
component
.
header
.
subtitle
link_text
:
component
.
header
&
&
component
.
header
.
link_text
link_url
:
component
.
header
&
&
component
.
header
.
link_url
icon
:
component
.
header
&
&
component
.
header
.
icon
essentialReadsHeader
:
component
.
essentialReadsHeader
editorsPicksHeader
:
component
.
editorsPicksHeader
}
)
;
case
"
SectionTitle
"
:
return
external_React_default
(
)
.
createElement
(
SectionTitle
{
header
:
component
.
header
}
)
;
case
"
Navigation
"
:
return
external_React_default
(
)
.
createElement
(
Navigation
{
dispatch
:
this
.
props
.
dispatch
links
:
component
.
properties
.
links
extraLinks
:
component
.
properties
.
extraLinks
alignment
:
component
.
properties
.
alignment
explore_topics
:
component
.
properties
.
explore_topics
header
:
component
.
header
locale
:
this
.
props
.
App
.
locale
newFooterSection
:
component
.
newFooterSection
privacyNoticeURL
:
component
.
properties
.
privacyNoticeURL
}
)
;
case
"
CollectionCardGrid
"
:
{
const
{
DiscoveryStream
}
=
this
.
props
;
return
external_React_default
(
)
.
createElement
(
CollectionCardGrid
{
data
:
component
.
data
feed
:
component
.
feed
spocs
:
DiscoveryStream
.
spocs
placement
:
component
.
placement
type
:
component
.
type
items
:
component
.
properties
.
items
dismissible
:
this
.
props
.
DiscoveryStream
.
isCollectionDismissible
dispatch
:
this
.
props
.
dispatch
}
)
;
}
case
"
CardGrid
"
:
{
const
sectionsEnabled
=
this
.
props
.
Prefs
.
values
[
"
discoverystream
.
sections
.
enabled
"
]
;
if
(
sectionsEnabled
)
{
return
external_React_default
(
)
.
createElement
(
CardSections
{
feed
:
component
.
feed
data
:
component
.
data
dispatch
:
this
.
props
.
dispatch
type
:
component
.
type
firstVisibleTimestamp
:
this
.
props
.
firstVisibleTimestamp
is_collection
:
true
ctaButtonSponsors
:
component
.
properties
.
ctaButtonSponsors
ctaButtonVariant
:
component
.
properties
.
ctaButtonVariant
spocMessageVariant
:
component
.
properties
.
spocMessageVariant
}
)
;
}
return
external_React_default
(
)
.
createElement
(
CardGrid
{
title
:
component
.
header
&
&
component
.
header
.
title
data
:
component
.
data
feed
:
component
.
feed
widgets
:
component
.
widgets
type
:
component
.
type
dispatch
:
this
.
props
.
dispatch
items
:
component
.
properties
.
items
hybridLayout
:
component
.
properties
.
hybridLayout
hideCardBackground
:
component
.
properties
.
hideCardBackground
fourCardLayout
:
component
.
properties
.
fourCardLayout
compactGrid
:
component
.
properties
.
compactGrid
essentialReadsHeader
:
component
.
properties
.
essentialReadsHeader
onboardingExperience
:
component
.
properties
.
onboardingExperience
ctaButtonSponsors
:
component
.
properties
.
ctaButtonSponsors
ctaButtonVariant
:
component
.
properties
.
ctaButtonVariant
spocMessageVariant
:
component
.
properties
.
spocMessageVariant
editorsPicksHeader
:
component
.
properties
.
editorsPicksHeader
recentSavesEnabled
:
this
.
props
.
DiscoveryStream
.
recentSavesEnabled
hideDescriptions
:
this
.
props
.
DiscoveryStream
.
hideDescriptions
firstVisibleTimestamp
:
this
.
props
.
firstVisibleTimestamp
spocPositions
:
component
.
spocs
?
.
positions
}
)
;
}
case
"
HorizontalRule
"
:
return
external_React_default
(
)
.
createElement
(
HorizontalRule
null
)
;
case
"
PrivacyLink
"
:
return
external_React_default
(
)
.
createElement
(
PrivacyLink
{
properties
:
component
.
properties
}
)
;
case
"
Widgets
"
:
{
const
nimbusWidgetsEnabled
=
this
.
props
.
Prefs
.
values
.
widgetsConfig
?
.
enabled
;
const
widgetsEnabled
=
this
.
props
.
Prefs
.
values
[
"
widgets
.
system
.
enabled
"
]
;
if
(
widgetsEnabled
|
|
nimbusWidgetsEnabled
)
{
return
external_React_default
(
)
.
createElement
(
Widgets
null
)
;
}
return
null
;
}
default
:
return
external_React_default
(
)
.
createElement
(
"
div
"
null
component
.
type
)
;
}
}
renderStyles
(
styles
)
{
const
json
=
JSON
.
stringify
(
styles
)
;
return
external_React_default
(
)
.
createElement
(
"
style
"
{
key
:
json
"
data
-
styles
"
:
json
ref
:
this
.
onStyleMount
}
)
;
}
render
(
)
{
const
{
locale
mayHaveSponsoredStories
}
=
this
.
props
;
const
{
layoutRender
}
=
selectLayoutRender
(
{
state
:
this
.
props
.
DiscoveryStream
prefs
:
this
.
props
.
Prefs
.
values
locale
}
)
;
const
sectionsEnabled
=
this
.
props
.
Prefs
.
values
[
"
discoverystream
.
sections
.
enabled
"
]
;
const
{
config
}
=
this
.
props
.
DiscoveryStream
;
const
topicSelectionEnabled
=
this
.
props
.
Prefs
.
values
[
"
discoverystream
.
topicSelection
.
enabled
"
]
;
const
reportAdsEnabled
=
this
.
props
.
Prefs
.
values
[
"
discoverystream
.
reportAds
.
enabled
"
]
;
const
spocsEnabled
=
this
.
props
.
Prefs
.
values
[
"
unifiedAds
.
spocs
.
enabled
"
]
;
if
(
!
config
.
collapsible
)
{
return
this
.
renderLayout
(
layoutRender
)
;
}
const
extractComponent
=
type
=
>
{
for
(
const
[
rowIndex
row
]
of
Object
.
entries
(
layoutRender
)
)
{
for
(
const
[
index
component
]
of
Object
.
entries
(
row
.
components
)
)
{
if
(
component
.
type
=
=
=
type
)
{
if
(
row
.
components
.
length
=
=
=
1
)
{
layoutRender
.
splice
(
rowIndex
1
)
;
}
else
{
row
.
components
.
splice
(
index
1
)
;
}
return
component
;
}
}
}
return
null
;
}
;
const
topStories
=
this
.
props
.
Sections
.
find
(
s
=
>
s
.
id
=
=
=
"
topstories
"
)
;
if
(
!
topStories
)
{
return
null
;
}
const
topSites
=
extractComponent
(
"
TopSites
"
)
;
const
widgets
=
extractComponent
(
"
Widgets
"
)
;
const
sponsoredCollection
=
extractComponent
(
"
CollectionCardGrid
"
)
;
const
message
=
extractComponent
(
"
Message
"
)
|
|
{
header
:
{
link_text
:
topStories
.
learnMore
.
link
.
message
link_url
:
topStories
.
learnMore
.
link
.
href
title
:
topStories
.
title
}
}
;
const
privacyLinkComponent
=
extractComponent
(
"
PrivacyLink
"
)
;
let
learnMore
=
{
link
:
{
href
:
message
.
header
.
link_url
message
:
message
.
header
.
link_text
}
}
;
let
sectionTitle
=
message
.
header
.
title
;
let
subTitle
=
"
"
;
if
(
message
.
essentialReadsHeader
|
|
message
.
editorsPicksHeader
)
{
learnMore
=
null
;
subTitle
=
"
Recommended
By
Pocket
"
;
if
(
message
.
essentialReadsHeader
)
{
sectionTitle
=
"
Today
s
Essential
Reads
"
;
}
else
if
(
message
.
editorsPicksHeader
)
{
sectionTitle
=
"
Editor
s
Picks
"
;
}
}
const
{
DiscoveryStream
}
=
this
.
props
;
return
external_React_default
(
)
.
createElement
(
(
external_React_default
(
)
)
.
Fragment
null
this
.
props
.
DiscoveryStream
.
isPrivacyInfoModalVisible
&
&
external_React_default
(
)
.
createElement
(
DSPrivacyModal
{
dispatch
:
this
.
props
.
dispatch
}
)
(
reportAdsEnabled
&
&
spocsEnabled
|
|
sectionsEnabled
)
&
&
external_React_default
(
)
.
createElement
(
ReportContent
{
spocs
:
DiscoveryStream
.
spocs
}
)
topSites
&
&
this
.
renderLayout
(
[
{
width
:
12
components
:
[
topSites
]
sectionType
:
"
topsites
"
}
]
)
widgets
&
&
this
.
renderLayout
(
[
{
width
:
12
components
:
[
widgets
]
sectionType
:
"
widgets
"
}
]
)
sponsoredCollection
&
&
this
.
renderLayout
(
[
{
width
:
12
components
:
[
sponsoredCollection
]
}
]
)
!
!
layoutRender
.
length
&
&
external_React_default
(
)
.
createElement
(
CollapsibleSection
{
className
:
"
ds
-
layout
"
collapsed
:
topStories
.
pref
.
collapsed
dispatch
:
this
.
props
.
dispatch
id
:
topStories
.
id
isFixed
:
true
learnMore
:
learnMore
privacyNoticeURL
:
topStories
.
privacyNoticeURL
showPrefName
:
topStories
.
pref
.
feed
title
:
sectionTitle
subTitle
:
subTitle
mayHaveSponsoredStories
:
mayHaveSponsoredStories
mayHaveTopicsSelection
:
topicSelectionEnabled
sectionsEnabled
:
sectionsEnabled
spocMessageVariant
:
message
?
.
properties
?
.
spocMessageVariant
eventSource
:
"
CARDGRID
"
}
this
.
renderLayout
(
layoutRender
)
)
this
.
renderLayout
(
[
{
width
:
12
components
:
[
{
type
:
"
Highlights
"
}
]
}
]
)
privacyLinkComponent
&
&
this
.
renderLayout
(
[
{
width
:
12
components
:
[
privacyLinkComponent
]
}
]
)
)
;
}
renderLayout
(
layoutRender
)
{
const
styles
=
[
]
;
let
[
data
]
=
layoutRender
;
const
sectionClass
=
data
.
sectionType
?
ds
-
layout
-
{
data
.
sectionType
}
:
"
"
;
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
discovery
-
stream
ds
-
layout
{
sectionClass
}
}
layoutRender
.
map
(
(
row
rowIndex
)
=
>
external_React_default
(
)
.
createElement
(
"
div
"
{
key
:
row
-
{
rowIndex
}
className
:
ds
-
column
ds
-
column
-
{
row
.
width
}
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
ds
-
column
-
grid
"
}
row
.
components
.
map
(
(
component
componentIndex
)
=
>
{
if
(
!
component
)
{
return
null
;
}
styles
[
rowIndex
]
=
[
.
.
.
(
styles
[
rowIndex
]
|
|
[
]
)
component
.
styles
]
;
return
external_React_default
(
)
.
createElement
(
"
div
"
{
key
:
component
-
{
componentIndex
}
}
this
.
renderComponent
(
component
row
.
width
)
)
;
}
)
)
)
)
this
.
renderStyles
(
styles
)
)
;
}
}
const
DiscoveryStreamBase
=
(
0
external_ReactRedux_namespaceObject
.
connect
)
(
state
=
>
(
{
DiscoveryStream
:
state
.
DiscoveryStream
Prefs
:
state
.
Prefs
Sections
:
state
.
Sections
document
:
globalThis
.
document
App
:
state
.
App
}
)
)
(
_DiscoveryStreamBase
)
;
;
function
SectionsMgmtPanel
(
{
exitEventFired
}
)
{
const
[
showPanel
setShowPanel
]
=
(
0
external_React_namespaceObject
.
useState
)
(
false
)
;
const
{
sectionPersonalization
}
=
(
0
external_ReactRedux_namespaceObject
.
useSelector
)
(
state
=
>
state
.
DiscoveryStream
)
;
const
layoutComponents
=
(
0
external_ReactRedux_namespaceObject
.
useSelector
)
(
state
=
>
state
.
DiscoveryStream
.
layout
[
0
]
.
components
)
;
const
sections
=
(
0
external_ReactRedux_namespaceObject
.
useSelector
)
(
state
=
>
state
.
DiscoveryStream
.
feeds
.
data
)
;
const
dispatch
=
(
0
external_ReactRedux_namespaceObject
.
useDispatch
)
(
)
;
let
sectionsFeedName
;
const
cardGridEntry
=
layoutComponents
.
find
(
item
=
>
item
.
type
=
=
=
"
CardGrid
"
)
;
if
(
cardGridEntry
)
{
sectionsFeedName
=
cardGridEntry
.
feed
.
url
;
}
let
sectionsList
;
if
(
sectionsFeedName
)
{
sectionsList
=
sections
[
sectionsFeedName
]
.
data
.
sections
;
}
const
[
sectionsState
setSectionState
]
=
(
0
external_React_namespaceObject
.
useState
)
(
sectionPersonalization
)
;
let
followedSectionsData
=
sectionsList
.
filter
(
item
=
>
sectionsState
[
item
.
sectionKey
]
?
.
isFollowed
)
;
let
blockedSectionsData
=
sectionsList
.
filter
(
item
=
>
sectionsState
[
item
.
sectionKey
]
?
.
isBlocked
)
;
function
updateCachedData
(
)
{
setSectionState
(
sectionPersonalization
)
;
followedSectionsData
=
sectionsList
.
filter
(
item
=
>
sectionsState
[
item
.
sectionKey
]
?
.
isFollowed
)
;
blockedSectionsData
=
sectionsList
.
filter
(
item
=
>
sectionsState
[
item
.
sectionKey
]
?
.
isBlocked
)
;
}
const
onFollowClick
=
(
0
external_React_namespaceObject
.
useCallback
)
(
(
sectionKey
receivedRank
)
=
>
{
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
SECTION_PERSONALIZATION_SET
data
:
{
.
.
.
sectionPersonalization
[
sectionKey
]
:
{
isFollowed
:
true
isBlocked
:
false
followedAt
:
new
Date
(
)
.
toISOString
(
)
}
}
}
)
)
;
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
"
FOLLOW_SECTION
"
data
:
{
section
:
sectionKey
section_position
:
receivedRank
event_source
:
"
CUSTOMIZE_PANEL
"
}
}
)
)
;
}
[
dispatch
sectionPersonalization
]
)
;
const
onBlockClick
=
(
0
external_React_namespaceObject
.
useCallback
)
(
(
sectionKey
receivedRank
)
=
>
{
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
SECTION_PERSONALIZATION_SET
data
:
{
.
.
.
sectionPersonalization
[
sectionKey
]
:
{
isFollowed
:
false
isBlocked
:
true
}
}
}
)
)
;
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
"
BLOCK_SECTION
"
data
:
{
section
:
sectionKey
section_position
:
receivedRank
event_source
:
"
CUSTOMIZE_PANEL
"
}
}
)
)
;
}
[
dispatch
sectionPersonalization
]
)
;
const
onUnblockClick
=
(
0
external_React_namespaceObject
.
useCallback
)
(
(
sectionKey
receivedRank
)
=
>
{
const
updatedSectionData
=
{
.
.
.
sectionPersonalization
}
;
delete
updatedSectionData
[
sectionKey
]
;
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
SECTION_PERSONALIZATION_SET
data
:
updatedSectionData
}
)
)
;
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
"
UNBLOCK_SECTION
"
data
:
{
section
:
sectionKey
section_position
:
receivedRank
event_source
:
"
CUSTOMIZE_PANEL
"
}
}
)
)
;
}
[
dispatch
sectionPersonalization
]
)
;
const
onUnfollowClick
=
(
0
external_React_namespaceObject
.
useCallback
)
(
(
sectionKey
receivedRank
)
=
>
{
const
updatedSectionData
=
{
.
.
.
sectionPersonalization
}
;
delete
updatedSectionData
[
sectionKey
]
;
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
SECTION_PERSONALIZATION_SET
data
:
updatedSectionData
}
)
)
;
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
"
UNFOLLOW_SECTION
"
data
:
{
section
:
sectionKey
section_position
:
receivedRank
event_source
:
"
CUSTOMIZE_PANEL
"
}
}
)
)
;
}
[
dispatch
sectionPersonalization
]
)
;
(
0
external_React_namespaceObject
.
useEffect
)
(
(
)
=
>
{
if
(
exitEventFired
)
{
setShowPanel
(
false
)
;
}
}
[
exitEventFired
]
)
;
const
togglePanel
=
(
)
=
>
{
setShowPanel
(
prevShowPanel
=
>
!
prevShowPanel
)
;
if
(
!
showPanel
)
{
updateCachedData
(
)
;
}
}
;
const
followedSectionsList
=
followedSectionsData
.
map
(
(
{
sectionKey
title
receivedRank
}
)
=
>
{
const
following
=
sectionPersonalization
[
sectionKey
]
?
.
isFollowed
;
return
external_React_default
(
)
.
createElement
(
"
li
"
{
key
:
sectionKey
}
external_React_default
(
)
.
createElement
(
"
label
"
{
htmlFor
:
follow
-
topic
-
{
sectionKey
}
}
title
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
following
?
"
section
-
follow
following
"
:
"
section
-
follow
"
}
external_React_default
(
)
.
createElement
(
"
moz
-
button
"
{
onClick
:
(
)
=
>
following
?
onUnfollowClick
(
sectionKey
receivedRank
)
:
onFollowClick
(
sectionKey
receivedRank
)
type
:
"
default
"
index
:
receivedRank
section
:
sectionKey
id
:
follow
-
topic
-
{
sectionKey
}
}
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
section
-
button
-
follow
-
text
"
"
data
-
l10n
-
id
"
:
"
newtab
-
section
-
follow
-
button
"
}
)
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
section
-
button
-
following
-
text
"
"
data
-
l10n
-
id
"
:
"
newtab
-
section
-
following
-
button
"
}
)
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
section
-
button
-
unfollow
-
text
"
"
data
-
l10n
-
id
"
:
"
newtab
-
section
-
unfollow
-
button
"
}
)
)
)
)
;
}
)
;
const
blockedSectionsList
=
blockedSectionsData
.
map
(
(
{
sectionKey
title
receivedRank
}
)
=
>
{
const
blocked
=
sectionPersonalization
[
sectionKey
]
?
.
isBlocked
;
return
external_React_default
(
)
.
createElement
(
"
li
"
{
key
:
sectionKey
}
external_React_default
(
)
.
createElement
(
"
label
"
{
htmlFor
:
blocked
-
topic
-
{
sectionKey
}
}
title
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
blocked
?
"
section
-
block
blocked
"
:
"
section
-
block
"
}
external_React_default
(
)
.
createElement
(
"
moz
-
button
"
{
onClick
:
(
)
=
>
blocked
?
onUnblockClick
(
sectionKey
receivedRank
)
:
onBlockClick
(
sectionKey
receivedRank
)
type
:
"
default
"
index
:
receivedRank
section
:
sectionKey
id
:
blocked
-
topic
-
{
sectionKey
}
}
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
section
-
button
-
block
-
text
"
"
data
-
l10n
-
id
"
:
"
newtab
-
section
-
block
-
button
"
}
)
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
section
-
button
-
blocked
-
text
"
"
data
-
l10n
-
id
"
:
"
newtab
-
section
-
blocked
-
button
"
}
)
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
section
-
button
-
unblock
-
text
"
"
data
-
l10n
-
id
"
:
"
newtab
-
section
-
unblock
-
button
"
}
)
)
)
)
;
}
)
;
return
external_React_default
(
)
.
createElement
(
"
div
"
null
external_React_default
(
)
.
createElement
(
"
moz
-
box
-
button
"
{
onClick
:
togglePanel
"
data
-
l10n
-
id
"
:
"
newtab
-
section
-
manage
-
topics
-
button
-
v2
"
}
)
external_React_default
(
)
.
createElement
(
external_ReactTransitionGroup_namespaceObject
.
CSSTransition
{
in
:
showPanel
timeout
:
300
classNames
:
"
sections
-
mgmt
-
panel
"
unmountOnExit
:
true
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
sections
-
mgmt
-
panel
"
}
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
"
arrow
-
button
"
onClick
:
togglePanel
}
external_React_default
(
)
.
createElement
(
"
h1
"
{
"
data
-
l10n
-
id
"
:
"
newtab
-
section
-
mangage
-
topics
-
title
"
}
)
)
external_React_default
(
)
.
createElement
(
"
h3
"
{
"
data
-
l10n
-
id
"
:
"
newtab
-
section
-
mangage
-
topics
-
followed
-
topics
"
}
)
followedSectionsData
.
length
?
external_React_default
(
)
.
createElement
(
"
ul
"
{
className
:
"
topic
-
list
"
}
followedSectionsList
)
:
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
topic
-
list
-
empty
-
state
"
"
data
-
l10n
-
id
"
:
"
newtab
-
section
-
mangage
-
topics
-
followed
-
topics
-
empty
-
state
"
}
)
external_React_default
(
)
.
createElement
(
"
h3
"
{
"
data
-
l10n
-
id
"
:
"
newtab
-
section
-
mangage
-
topics
-
blocked
-
topics
"
}
)
blockedSectionsData
.
length
?
external_React_default
(
)
.
createElement
(
"
ul
"
{
className
:
"
topic
-
list
"
}
blockedSectionsList
)
:
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
topic
-
list
-
empty
-
state
"
"
data
-
l10n
-
id
"
:
"
newtab
-
section
-
mangage
-
topics
-
blocked
-
topics
-
empty
-
state
"
}
)
)
)
)
;
}
;
function
WallpaperCategories_extends
(
)
{
return
WallpaperCategories_extends
=
Object
.
assign
?
Object
.
assign
.
bind
(
)
:
function
(
n
)
{
for
(
var
e
=
1
;
e
<
arguments
.
length
;
e
+
+
)
{
var
t
=
arguments
[
e
]
;
for
(
var
r
in
t
)
(
{
}
)
.
hasOwnProperty
.
call
(
t
r
)
&
&
(
n
[
r
]
=
t
[
r
]
)
;
}
return
n
;
}
WallpaperCategories_extends
.
apply
(
null
arguments
)
;
}
const
PREF_WALLPAPER_UPLOADED_PREVIOUSLY
=
"
newtabWallpapers
.
customWallpaper
.
uploadedPreviously
"
;
const
PREF_WALLPAPER_UPLOAD_MAX_FILE_SIZE
=
"
newtabWallpapers
.
customWallpaper
.
fileSize
"
;
const
PREF_WALLPAPER_UPLOAD_MAX_FILE_SIZE_ENABLED
=
"
newtabWallpapers
.
customWallpaper
.
fileSize
.
enabled
"
;
function
debounce
(
func
wait
)
{
let
timer
;
return
(
.
.
.
args
)
=
>
{
if
(
timer
)
{
return
;
}
let
wakeUp
=
(
)
=
>
{
timer
=
null
;
}
;
timer
=
setTimeout
(
wakeUp
wait
)
;
func
.
apply
(
this
args
)
;
}
;
}
class
_WallpaperCategories
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
handleColorInput
=
this
.
handleColorInput
.
bind
(
this
)
;
this
.
debouncedHandleChange
=
debounce
(
this
.
handleChange
.
bind
(
this
)
999
)
;
this
.
handleChange
=
this
.
handleChange
.
bind
(
this
)
;
this
.
handleReset
=
this
.
handleReset
.
bind
(
this
)
;
this
.
handleCategory
=
this
.
handleCategory
.
bind
(
this
)
;
this
.
handleUpload
=
this
.
handleUpload
.
bind
(
this
)
;
this
.
handleBack
=
this
.
handleBack
.
bind
(
this
)
;
this
.
getRGBColors
=
this
.
getRGBColors
.
bind
(
this
)
;
this
.
prefersHighContrastQuery
=
null
;
this
.
prefersDarkQuery
=
null
;
this
.
categoryRef
=
[
]
;
this
.
wallpaperRef
=
[
]
;
this
.
customColorPickerRef
=
external_React_default
(
)
.
createRef
(
)
;
this
.
customColorInput
=
external_React_default
(
)
.
createRef
(
)
;
this
.
state
=
{
activeCategory
:
null
activeCategoryFluentID
:
null
showColorPicker
:
false
inputType
:
"
radio
"
activeId
:
null
isCustomWallpaperError
:
false
}
;
}
componentDidMount
(
)
{
this
.
prefersDarkQuery
=
globalThis
.
matchMedia
(
"
(
prefers
-
color
-
scheme
:
dark
)
"
)
;
}
componentDidUpdate
(
prevProps
)
{
if
(
this
.
props
.
exitEventFired
&
&
this
.
props
.
exitEventFired
!
=
=
prevProps
.
exitEventFired
)
{
this
.
handleBack
(
)
;
}
}
handleColorInput
(
event
)
{
let
{
id
}
=
event
.
target
;
id
=
solid
-
color
-
picker
-
{
event
.
target
.
value
}
;
const
rgbColors
=
this
.
getRGBColors
(
event
.
target
.
value
)
;
event
.
target
.
style
.
backgroundColor
=
rgb
(
{
rgbColors
.
toString
(
)
}
)
;
if
(
this
.
customColorPickerRef
.
current
)
{
const
colorInputBackground
=
this
.
customColorPickerRef
.
current
.
children
[
0
]
.
style
.
backgroundColor
;
this
.
customColorPickerRef
.
current
.
style
.
backgroundColor
=
colorInputBackground
;
}
const
isColorDark
=
this
.
isWallpaperColorDark
(
rgbColors
)
;
if
(
this
.
customColorPickerRef
.
current
)
{
if
(
isColorDark
)
{
this
.
customColorPickerRef
.
current
.
classList
.
add
(
"
is
-
dark
"
)
;
}
else
{
this
.
customColorPickerRef
.
current
.
classList
.
remove
(
"
is
-
dark
"
)
;
}
this
.
customColorPickerRef
.
current
.
classList
.
remove
(
"
custom
-
color
-
set
"
"
custom
-
color
-
dark
"
"
default
-
color
-
set
"
)
;
}
this
.
props
.
setPref
(
"
newtabWallpapers
.
wallpaper
"
id
)
;
}
handleChange
(
event
)
{
let
{
id
}
=
event
.
target
;
if
(
id
=
=
=
"
solid
-
color
-
picker
"
)
{
id
=
solid
-
color
-
picker
-
{
event
.
target
.
value
}
;
}
this
.
props
.
setPref
(
"
newtabWallpapers
.
wallpaper
"
id
)
;
const
uploadedPreviously
=
this
.
props
.
Prefs
.
values
[
PREF_WALLPAPER_UPLOADED_PREVIOUSLY
]
;
this
.
handleUserEvent
(
actionTypes
.
WALLPAPER_CLICK
{
selected_wallpaper
:
id
had_previous_wallpaper
:
!
!
this
.
props
.
activeWallpaper
had_uploaded_previously
:
!
!
uploadedPreviously
}
)
;
}
handleCategoryKeyDown
(
event
category
)
{
const
getIndex
=
this
.
categoryRef
.
findIndex
(
cat
=
>
cat
.
id
=
=
=
category
)
;
if
(
getIndex
=
=
=
-
1
)
{
return
;
}
const
isRTL
=
document
.
dir
=
=
=
"
rtl
"
;
let
eventKey
=
event
.
key
;
if
(
eventKey
=
=
=
"
ArrowRight
"
|
|
eventKey
=
=
=
"
ArrowLeft
"
)
{
if
(
isRTL
)
{
eventKey
=
eventKey
=
=
=
"
ArrowRight
"
?
"
ArrowLeft
"
:
"
ArrowRight
"
;
}
}
let
nextIndex
=
getIndex
;
if
(
eventKey
=
=
=
"
ArrowRight
"
)
{
nextIndex
=
getIndex
+
1
<
this
.
categoryRef
.
length
?
getIndex
+
1
:
getIndex
;
}
else
if
(
eventKey
=
=
=
"
ArrowLeft
"
)
{
nextIndex
=
getIndex
-
1
>
=
0
?
getIndex
-
1
:
getIndex
;
}
this
.
categoryRef
[
nextIndex
]
.
focus
(
)
;
}
handleWallpaperKeyDown
(
event
title
)
{
if
(
event
.
key
=
=
=
"
Tab
"
)
{
if
(
event
.
shiftKey
)
{
event
.
preventDefault
(
)
;
this
.
backToMenuButton
?
.
focus
(
)
;
}
else
{
event
.
preventDefault
(
)
;
}
return
;
}
const
isRTL
=
document
.
dir
=
=
=
"
rtl
"
;
let
eventKey
=
event
.
key
;
if
(
eventKey
=
=
=
"
ArrowRight
"
|
|
eventKey
=
=
=
"
ArrowLeft
"
)
{
if
(
isRTL
)
{
eventKey
=
eventKey
=
=
=
"
ArrowRight
"
?
"
ArrowLeft
"
:
"
ArrowRight
"
;
}
}
const
getIndex
=
this
.
wallpaperRef
.
findIndex
(
wallpaper
=
>
wallpaper
.
id
=
=
=
title
)
;
if
(
getIndex
=
=
=
-
1
)
{
return
;
}
const
columnCount
=
3
;
let
nextIndex
=
getIndex
;
if
(
eventKey
=
=
=
"
ArrowRight
"
)
{
nextIndex
=
getIndex
+
1
<
this
.
wallpaperRef
.
length
?
getIndex
+
1
:
getIndex
;
}
else
if
(
eventKey
=
=
=
"
ArrowLeft
"
)
{
nextIndex
=
getIndex
-
1
>
=
0
?
getIndex
-
1
:
getIndex
;
}
else
if
(
eventKey
=
=
=
"
ArrowDown
"
)
{
nextIndex
=
getIndex
+
columnCount
<
this
.
wallpaperRef
.
length
?
getIndex
+
columnCount
:
getIndex
;
}
else
if
(
eventKey
=
=
=
"
ArrowUp
"
)
{
nextIndex
=
getIndex
-
columnCount
>
=
0
?
getIndex
-
columnCount
:
getIndex
;
}
this
.
wallpaperRef
[
nextIndex
]
.
tabIndex
=
0
;
this
.
wallpaperRef
[
getIndex
]
.
tabIndex
=
-
1
;
this
.
wallpaperRef
[
nextIndex
]
.
focus
(
)
;
this
.
wallpaperRef
[
nextIndex
]
.
click
(
)
;
}
handleReset
(
)
{
const
uploadedPreviously
=
this
.
props
.
Prefs
.
values
[
PREF_WALLPAPER_UPLOADED_PREVIOUSLY
]
;
const
selectedWallpaper
=
this
.
props
.
Prefs
.
values
[
"
newtabWallpapers
.
wallpaper
"
]
;
if
(
selectedWallpaper
=
=
=
"
custom
"
)
{
this
.
props
.
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
WALLPAPER_REMOVE_UPLOAD
}
)
)
;
}
this
.
props
.
setPref
(
"
newtabWallpapers
.
wallpaper
"
"
"
)
;
this
.
handleUserEvent
(
actionTypes
.
WALLPAPER_CLICK
{
selected_wallpaper
:
"
none
"
had_previous_wallpaper
:
!
!
this
.
props
.
activeWallpaper
had_uploaded_previously
:
!
!
uploadedPreviously
}
)
;
}
handleCategory
=
event
=
>
{
this
.
setState
(
{
activeCategory
:
event
.
target
.
id
}
)
;
this
.
handleUserEvent
(
actionTypes
.
WALLPAPER_CATEGORY_CLICK
event
.
target
.
id
)
;
let
fluent_id
;
switch
(
event
.
target
.
id
)
{
case
"
abstracts
"
:
fluent_id
=
"
newtab
-
wallpaper
-
category
-
title
-
abstract
"
;
break
;
case
"
celestial
"
:
fluent_id
=
"
newtab
-
wallpaper
-
category
-
title
-
celestial
"
;
break
;
case
"
photographs
"
:
fluent_id
=
"
newtab
-
wallpaper
-
category
-
title
-
photographs
"
;
break
;
case
"
solid
-
colors
"
:
fluent_id
=
"
newtab
-
wallpaper
-
category
-
title
-
colors
"
;
}
this
.
setState
(
{
activeCategoryFluentID
:
fluent_id
}
)
;
}
;
async
handleUpload
(
)
{
const
wallpaperUploadMaxFileSizeEnabled
=
this
.
props
.
Prefs
.
values
[
PREF_WALLPAPER_UPLOAD_MAX_FILE_SIZE_ENABLED
]
;
const
wallpaperUploadMaxFileSize
=
this
.
props
.
Prefs
.
values
[
PREF_WALLPAPER_UPLOAD_MAX_FILE_SIZE
]
;
const
uploadedPreviously
=
this
.
props
.
Prefs
.
values
[
PREF_WALLPAPER_UPLOADED_PREVIOUSLY
]
;
const
fileInput
=
document
.
createElement
(
"
input
"
)
;
fileInput
.
type
=
"
file
"
;
fileInput
.
accept
=
"
image
/
*
"
;
fileInput
.
oncancel
=
async
(
)
=
>
{
this
.
setState
(
{
isCustomWallpaperError
:
false
}
)
;
}
;
this
.
setState
(
{
isCustomWallpaperError
:
false
}
)
;
fileInput
.
onchange
=
async
event
=
>
{
const
[
file
]
=
event
.
target
.
files
;
const
maxSize
=
wallpaperUploadMaxFileSize
*
1024
*
1024
;
if
(
wallpaperUploadMaxFileSizeEnabled
&
&
file
&
&
file
.
size
>
maxSize
)
{
console
.
error
(
"
File
size
exceeds
limit
"
)
;
this
.
setState
(
{
isCustomWallpaperError
:
true
}
)
;
return
;
}
if
(
file
)
{
this
.
props
.
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
WALLPAPER_UPLOAD
data
:
file
}
)
)
;
this
.
props
.
setPref
(
"
newtabWallpapers
.
wallpaper
"
"
custom
"
)
;
this
.
props
.
setPref
(
PREF_WALLPAPER_UPLOADED_PREVIOUSLY
true
)
;
this
.
handleUserEvent
(
actionTypes
.
WALLPAPER_CLICK
{
selected_wallpaper
:
"
custom
"
had_previous_wallpaper
:
!
!
this
.
props
.
activeWallpaper
had_uploaded_previously
:
!
!
uploadedPreviously
}
)
;
}
}
;
fileInput
.
click
(
)
;
}
handleBack
(
)
{
this
.
setState
(
{
activeCategory
:
null
}
)
;
this
.
categoryRef
[
0
]
?
.
focus
(
)
;
}
handleUserEvent
(
type
data
)
{
this
.
props
.
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
data
}
)
)
;
}
setActiveId
=
id
=
>
{
this
.
setState
(
{
activeId
:
id
}
)
;
}
;
getRGBColors
(
input
)
{
if
(
input
.
length
!
=
=
7
)
{
return
[
]
;
}
const
r
=
parseInt
(
input
.
substr
(
1
2
)
16
)
;
const
g
=
parseInt
(
input
.
substr
(
3
2
)
16
)
;
const
b
=
parseInt
(
input
.
substr
(
5
2
)
16
)
;
return
[
r
g
b
]
;
}
isWallpaperColorDark
(
[
r
g
b
]
)
{
return
0
.
2125
*
r
+
0
.
7154
*
g
+
0
.
0721
*
b
<
=
110
;
}
render
(
)
{
const
prefs
=
this
.
props
.
Prefs
.
values
;
const
{
wallpaperList
categories
}
=
this
.
props
.
Wallpapers
;
const
{
activeWallpaper
}
=
this
.
props
;
const
{
activeCategory
showColorPicker
}
=
this
.
state
;
const
{
activeCategoryFluentID
}
=
this
.
state
;
let
filteredWallpapers
=
wallpaperList
.
filter
(
wallpaper
=
>
wallpaper
.
category
=
=
=
activeCategory
)
;
const
wallpaperUploadMaxFileSize
=
this
.
props
.
Prefs
.
values
[
PREF_WALLPAPER_UPLOAD_MAX_FILE_SIZE
]
;
function
reduceColorsToFitCustomColorInput
(
arr
)
{
while
(
arr
.
length
%
3
!
=
=
2
)
{
arr
.
pop
(
)
;
}
return
arr
;
}
let
wallpaperCustomSolidColorHex
=
null
;
const
selectedWallpaper
=
prefs
[
"
newtabWallpapers
.
wallpaper
"
]
;
if
(
selectedWallpaper
.
includes
(
"
solid
-
color
-
picker
"
)
)
{
this
.
setState
(
{
showColorPicker
:
true
}
)
;
const
regex
=
/
#
(
[
a
-
fA
-
F0
-
9
]
{
6
}
)
/
;
[
wallpaperCustomSolidColorHex
]
=
selectedWallpaper
.
match
(
regex
)
;
}
this
.
setState
(
{
showColorPicker
:
prefs
[
"
newtabWallpapers
.
customColor
.
enabled
"
]
}
)
;
if
(
prefs
[
"
newtabWallpapers
.
customColor
.
enabled
"
]
&
&
activeCategory
=
=
=
"
solid
-
colors
"
)
{
filteredWallpapers
=
reduceColorsToFitCustomColorInput
(
filteredWallpapers
)
;
}
const
starterColorHex
=
this
.
prefersDarkQuery
?
.
matches
?
"
#
054096
"
:
"
#
deeafc
"
;
let
initStateClassname
=
wallpaperCustomSolidColorHex
?
"
custom
-
color
-
set
"
:
"
default
-
color
-
set
"
;
if
(
wallpaperCustomSolidColorHex
)
{
const
rgbColors
=
this
.
getRGBColors
(
wallpaperCustomSolidColorHex
)
;
const
isColorDark
=
this
.
isWallpaperColorDark
(
rgbColors
)
;
if
(
isColorDark
)
{
initStateClassname
+
=
"
custom
-
color
-
dark
"
;
}
}
let
colorPickerInput
=
showColorPicker
&
&
activeCategory
=
=
=
"
solid
-
colors
"
?
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
theme
-
custom
-
color
-
picker
{
initStateClassname
}
ref
:
this
.
customColorPickerRef
}
external_React_default
(
)
.
createElement
(
"
input
"
{
onInput
:
this
.
handleColorInput
onChange
:
this
.
debouncedHandleChange
onClick
:
(
)
=
>
this
.
setActiveId
(
"
solid
-
color
-
picker
"
)
type
:
"
color
"
name
:
wallpaper
-
solid
-
color
-
picker
id
:
"
solid
-
color
-
picker
"
"
aria
-
current
"
:
this
.
state
.
activeId
=
=
=
"
solid
-
color
-
picker
"
value
:
wallpaperCustomSolidColorHex
|
|
starterColorHex
className
:
wallpaper
-
input
{
this
.
state
.
activeId
=
=
=
"
solid
-
color
-
picker
"
?
"
active
"
:
"
"
}
ref
:
this
.
customColorInput
}
)
external_React_default
(
)
.
createElement
(
"
label
"
{
htmlFor
:
"
solid
-
color
-
picker
"
"
data
-
l10n
-
id
"
:
"
newtab
-
wallpaper
-
custom
-
color
"
}
)
)
:
"
"
;
return
external_React_default
(
)
.
createElement
(
"
div
"
null
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
category
-
header
"
}
external_React_default
(
)
.
createElement
(
"
h2
"
{
"
data
-
l10n
-
id
"
:
"
newtab
-
wallpaper
-
title
"
}
)
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
"
wallpapers
-
reset
"
onClick
:
this
.
handleReset
"
data
-
l10n
-
id
"
:
"
newtab
-
wallpaper
-
reset
"
}
)
)
external_React_default
(
)
.
createElement
(
"
div
"
{
role
:
"
grid
"
"
aria
-
label
"
:
"
Wallpaper
category
selection
.
Use
arrow
keys
to
navigate
.
"
}
external_React_default
(
)
.
createElement
(
"
fieldset
"
{
className
:
"
category
-
list
"
}
categories
.
map
(
(
category
index
)
=
>
{
const
filteredList
=
wallpaperList
.
filter
(
wallpaper
=
>
wallpaper
.
category
=
=
=
category
)
;
const
activeWallpaperObj
=
activeWallpaper
&
&
filteredList
.
find
(
wp
=
>
wp
.
title
=
=
=
activeWallpaper
)
;
const
thumbnail
=
activeWallpaperObj
|
|
filteredList
[
0
]
;
let
fluent_id
;
switch
(
category
)
{
case
"
abstracts
"
:
fluent_id
=
"
newtab
-
wallpaper
-
category
-
title
-
abstract
"
;
break
;
case
"
celestial
"
:
fluent_id
=
"
newtab
-
wallpaper
-
category
-
title
-
celestial
"
;
break
;
case
"
custom
-
wallpaper
"
:
fluent_id
=
"
newtab
-
wallpaper
-
upload
-
image
"
;
break
;
case
"
photographs
"
:
fluent_id
=
"
newtab
-
wallpaper
-
category
-
title
-
photographs
"
;
break
;
case
"
solid
-
colors
"
:
fluent_id
=
"
newtab
-
wallpaper
-
category
-
title
-
colors
"
;
}
let
style
=
{
}
;
if
(
thumbnail
?
.
wallpaperUrl
)
{
style
.
backgroundImage
=
url
(
{
thumbnail
.
wallpaperUrl
}
)
;
}
else
{
style
.
backgroundColor
=
thumbnail
?
.
solid_color
|
|
"
"
;
}
return
external_React_default
(
)
.
createElement
(
"
div
"
{
key
:
category
}
external_React_default
(
)
.
createElement
(
"
button
"
WallpaperCategories_extends
(
{
ref
:
el
=
>
{
if
(
el
)
{
this
.
categoryRef
[
index
]
=
el
;
}
}
id
:
category
style
:
style
onKeyDown
:
e
=
>
this
.
handleCategoryKeyDown
(
e
category
)
onClick
:
category
!
=
=
"
custom
-
wallpaper
"
?
this
.
handleCategory
:
this
.
handleUpload
className
:
category
!
=
=
"
custom
-
wallpaper
"
?
wallpaper
-
input
:
wallpaper
-
input
theme
-
custom
-
wallpaper
tabIndex
:
index
=
=
=
0
?
0
:
-
1
}
category
=
=
=
"
custom
-
wallpaper
"
?
{
"
aria
-
errormessage
"
:
"
customWallpaperError
"
}
:
{
}
)
)
external_React_default
(
)
.
createElement
(
"
label
"
{
htmlFor
:
category
"
data
-
l10n
-
id
"
:
fluent_id
}
fluent_id
)
)
;
}
)
)
this
.
state
.
isCustomWallpaperError
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
custom
-
wallpaper
-
error
"
id
:
"
customWallpaperError
"
}
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
icon
icon
-
info
"
}
)
external_React_default
(
)
.
createElement
(
"
span
"
{
"
data
-
l10n
-
id
"
:
"
newtab
-
wallpaper
-
error
-
max
-
file
-
size
"
"
data
-
l10n
-
args
"
:
{
"
file_size
"
:
{
wallpaperUploadMaxFileSize
}
}
}
)
)
)
external_React_default
(
)
.
createElement
(
external_ReactTransitionGroup_namespaceObject
.
CSSTransition
{
in
:
!
!
activeCategory
timeout
:
300
classNames
:
"
wallpaper
-
list
"
unmountOnExit
:
true
}
external_React_default
(
)
.
createElement
(
"
section
"
{
className
:
"
category
wallpaper
-
list
ignore
-
color
-
mode
"
}
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
"
arrow
-
button
"
"
data
-
l10n
-
id
"
:
activeCategoryFluentID
onClick
:
this
.
handleBack
ref
:
el
=
>
{
this
.
backToMenuButton
=
el
;
}
}
)
external_React_default
(
)
.
createElement
(
"
div
"
{
role
:
"
grid
"
"
aria
-
label
"
:
"
Wallpaper
selection
.
Use
arrow
keys
to
navigate
.
"
}
external_React_default
(
)
.
createElement
(
"
fieldset
"
null
filteredWallpapers
.
map
(
(
{
title
theme
fluent_id
solid_color
wallpaperUrl
}
index
)
=
>
{
let
style
=
{
}
;
if
(
wallpaperUrl
)
{
style
.
backgroundImage
=
url
(
{
wallpaperUrl
}
)
;
}
else
{
style
.
backgroundColor
=
solid_color
|
|
"
"
;
}
return
external_React_default
(
)
.
createElement
(
(
external_React_default
(
)
)
.
Fragment
null
external_React_default
(
)
.
createElement
(
"
input
"
{
ref
:
el
=
>
{
if
(
el
)
{
this
.
wallpaperRef
[
index
]
=
el
;
}
}
onChange
:
this
.
handleChange
onKeyDown
:
e
=
>
this
.
handleWallpaperKeyDown
(
e
title
)
style
:
style
type
:
"
radio
"
name
:
wallpaper
-
{
title
}
id
:
title
value
:
title
checked
:
title
=
=
=
activeWallpaper
"
aria
-
checked
"
:
title
=
=
=
activeWallpaper
className
:
wallpaper
-
input
theme
-
{
theme
}
{
this
.
state
.
activeId
=
=
=
title
?
"
active
"
:
"
"
}
onClick
:
(
)
=
>
this
.
setActiveId
(
title
)
tabIndex
:
index
=
=
=
0
?
0
:
-
1
}
)
external_React_default
(
)
.
createElement
(
"
label
"
{
htmlFor
:
title
className
:
"
sr
-
only
"
"
data
-
l10n
-
id
"
:
fluent_id
}
fluent_id
)
)
;
}
)
colorPickerInput
)
)
)
)
)
;
}
}
const
WallpaperCategories
=
(
0
external_ReactRedux_namespaceObject
.
connect
)
(
state
=
>
{
return
{
Wallpapers
:
state
.
Wallpapers
Prefs
:
state
.
Prefs
}
;
}
)
(
_WallpaperCategories
)
;
;
class
ContentSection
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
onPreferenceSelect
=
this
.
onPreferenceSelect
.
bind
(
this
)
;
this
.
topSitesDrawerRef
=
external_React_default
(
)
.
createRef
(
)
;
this
.
pocketDrawerRef
=
external_React_default
(
)
.
createRef
(
)
;
}
inputUserEvent
(
eventSource
eventValue
)
{
this
.
props
.
dispatch
(
actionCreators
.
UserEvent
(
{
event
:
"
PREF_CHANGED
"
source
:
eventSource
value
:
{
status
:
eventValue
menu_source
:
"
CUSTOMIZE_MENU
"
}
}
)
)
;
}
onPreferenceSelect
(
e
)
{
const
{
preference
eventSource
}
=
e
.
target
.
dataset
;
let
value
;
if
(
e
.
target
.
nodeName
=
=
=
"
SELECT
"
)
{
value
=
parseInt
(
e
.
target
.
value
10
)
;
}
else
if
(
e
.
target
.
nodeName
=
=
=
"
INPUT
"
)
{
value
=
e
.
target
.
checked
;
if
(
eventSource
)
{
this
.
inputUserEvent
(
eventSource
value
)
;
}
}
else
if
(
e
.
target
.
nodeName
=
=
=
"
MOZ
-
TOGGLE
"
)
{
value
=
e
.
target
.
pressed
;
if
(
eventSource
)
{
this
.
inputUserEvent
(
eventSource
value
)
;
}
}
this
.
props
.
setPref
(
preference
value
)
;
}
componentDidMount
(
)
{
this
.
setDrawerMargins
(
)
;
}
componentDidUpdate
(
)
{
this
.
setDrawerMargins
(
)
;
}
setDrawerMargins
(
)
{
this
.
setDrawerMargin
(
TOP_SITES
this
.
props
.
enabledSections
.
topSitesEnabled
)
;
this
.
setDrawerMargin
(
TOP_STORIES
this
.
props
.
enabledSections
.
pocketEnabled
)
;
}
setDrawerMargin
(
drawerID
isOpen
)
{
let
drawerRef
;
if
(
drawerID
=
=
=
TOP_SITES
)
{
drawerRef
=
this
.
topSitesDrawerRef
.
current
;
}
else
if
(
drawerID
=
=
=
TOP_STORIES
)
{
drawerRef
=
this
.
pocketDrawerRef
.
current
;
}
else
{
return
;
}
if
(
drawerRef
)
{
let
drawerHeight
=
parseFloat
(
window
.
getComputedStyle
(
drawerRef
)
?
.
height
)
|
|
0
;
if
(
isOpen
)
{
drawerRef
.
style
.
marginTop
=
"
var
(
-
-
space
-
large
)
"
;
}
else
{
drawerRef
.
style
.
marginTop
=
-
{
drawerHeight
+
3
}
px
;
}
}
}
render
(
)
{
const
{
enabledSections
enabledWidgets
pocketRegion
mayHaveInferredPersonalization
mayHaveRecentSaves
mayHaveWeather
mayHaveTrendingSearch
mayHaveWidgets
mayHaveTimerWidget
mayHaveListsWidget
openPreferences
wallpapersEnabled
activeWallpaper
setPref
mayHaveTopicSections
exitEventFired
}
=
this
.
props
;
const
{
topSitesEnabled
pocketEnabled
weatherEnabled
trendingSearchEnabled
showInferredPersonalizationEnabled
showRecentSavesEnabled
topSitesRowsCount
}
=
enabledSections
;
const
{
timerEnabled
listsEnabled
}
=
enabledWidgets
;
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
home
-
section
"
}
wallpapersEnabled
&
&
external_React_default
(
)
.
createElement
(
(
external_React_default
(
)
)
.
Fragment
null
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
wallpapers
-
section
"
}
external_React_default
(
)
.
createElement
(
WallpaperCategories
{
setPref
:
setPref
activeWallpaper
:
activeWallpaper
exitEventFired
:
exitEventFired
}
)
)
!
mayHaveWidgets
&
&
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
divider
"
role
:
"
separator
"
}
)
)
mayHaveWidgets
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
widgets
-
section
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
category
-
header
"
}
external_React_default
(
)
.
createElement
(
"
h2
"
{
"
data
-
l10n
-
id
"
:
"
newtab
-
custom
-
widget
-
section
-
title
"
}
)
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
settings
-
widgets
"
}
mayHaveWeather
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
id
:
"
weather
-
section
"
className
:
"
section
"
}
external_React_default
(
)
.
createElement
(
"
moz
-
toggle
"
{
id
:
"
weather
-
toggle
"
pressed
:
weatherEnabled
|
|
null
onToggle
:
this
.
onPreferenceSelect
"
data
-
preference
"
:
"
showWeather
"
"
data
-
eventSource
"
:
"
WEATHER
"
"
data
-
l10n
-
id
"
:
"
newtab
-
custom
-
widget
-
weather
-
toggle
"
}
)
)
mayHaveListsWidget
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
id
:
"
lists
-
widget
-
section
"
className
:
"
section
"
}
external_React_default
(
)
.
createElement
(
"
moz
-
toggle
"
{
id
:
"
lists
-
toggle
"
pressed
:
listsEnabled
|
|
null
onToggle
:
this
.
onPreferenceSelect
"
data
-
preference
"
:
"
widgets
.
lists
.
enabled
"
"
data
-
eventSource
"
:
"
WIDGET_LISTS
"
"
data
-
l10n
-
id
"
:
"
newtab
-
custom
-
widget
-
lists
-
toggle
"
}
)
)
mayHaveTimerWidget
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
id
:
"
timer
-
widget
-
section
"
className
:
"
section
"
}
external_React_default
(
)
.
createElement
(
"
moz
-
toggle
"
{
id
:
"
timer
-
toggle
"
pressed
:
timerEnabled
|
|
null
onToggle
:
this
.
onPreferenceSelect
"
data
-
preference
"
:
"
widgets
.
focusTimer
.
enabled
"
"
data
-
eventSource
"
:
"
WIDGET_TIMER
"
"
data
-
l10n
-
id
"
:
"
newtab
-
custom
-
widget
-
timer
-
toggle
"
}
)
)
mayHaveTrendingSearch
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
id
:
"
trending
-
search
-
section
"
className
:
"
section
"
}
external_React_default
(
)
.
createElement
(
"
moz
-
toggle
"
{
id
:
"
trending
-
search
-
toggle
"
pressed
:
trendingSearchEnabled
|
|
null
onToggle
:
this
.
onPreferenceSelect
"
data
-
preference
"
:
"
trendingSearch
.
enabled
"
"
data
-
eventSource
"
:
"
TRENDING_SEARCH
"
"
data
-
l10n
-
id
"
:
"
newtab
-
custom
-
widget
-
trending
-
search
-
toggle
"
}
)
)
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
divider
"
role
:
"
separator
"
}
)
)
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
settings
-
toggles
"
}
!
mayHaveWidgets
&
&
mayHaveWeather
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
id
:
"
weather
-
section
"
className
:
"
section
"
}
external_React_default
(
)
.
createElement
(
"
moz
-
toggle
"
{
id
:
"
weather
-
toggle
"
pressed
:
weatherEnabled
|
|
null
onToggle
:
this
.
onPreferenceSelect
"
data
-
preference
"
:
"
showWeather
"
"
data
-
eventSource
"
:
"
WEATHER
"
"
data
-
l10n
-
id
"
:
"
newtab
-
custom
-
weather
-
toggle
"
}
)
)
!
mayHaveWidgets
&
&
mayHaveTrendingSearch
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
id
:
"
trending
-
search
-
section
"
className
:
"
section
"
}
external_React_default
(
)
.
createElement
(
"
moz
-
toggle
"
{
id
:
"
trending
-
search
-
toggle
"
pressed
:
trendingSearchEnabled
|
|
null
onToggle
:
this
.
onPreferenceSelect
"
data
-
preference
"
:
"
trendingSearch
.
enabled
"
"
data
-
eventSource
"
:
"
TRENDING_SEARCH
"
"
data
-
l10n
-
id
"
:
"
newtab
-
custom
-
trending
-
search
-
toggle
"
}
)
)
external_React_default
(
)
.
createElement
(
"
div
"
{
id
:
"
shortcuts
-
section
"
className
:
"
section
"
}
external_React_default
(
)
.
createElement
(
"
moz
-
toggle
"
{
id
:
"
shortcuts
-
toggle
"
pressed
:
topSitesEnabled
|
|
null
onToggle
:
this
.
onPreferenceSelect
"
data
-
preference
"
:
"
feeds
.
topsites
"
"
data
-
eventSource
"
:
"
TOP_SITES
"
"
data
-
l10n
-
id
"
:
"
newtab
-
custom
-
shortcuts
-
toggle
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
slot
:
"
nested
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
more
-
info
-
top
-
wrapper
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
more
-
information
"
ref
:
this
.
topSitesDrawerRef
}
external_React_default
(
)
.
createElement
(
"
select
"
{
id
:
"
row
-
selector
"
className
:
"
selector
"
name
:
"
row
-
count
"
"
data
-
preference
"
:
"
topSitesRows
"
value
:
topSitesRowsCount
onChange
:
this
.
onPreferenceSelect
disabled
:
!
topSitesEnabled
"
aria
-
labelledby
"
:
"
custom
-
shortcuts
-
title
"
}
external_React_default
(
)
.
createElement
(
"
option
"
{
value
:
"
1
"
"
data
-
l10n
-
id
"
:
"
newtab
-
custom
-
row
-
selector
"
"
data
-
l10n
-
args
"
:
"
{
\
"
num
\
"
:
1
}
"
}
)
external_React_default
(
)
.
createElement
(
"
option
"
{
value
:
"
2
"
"
data
-
l10n
-
id
"
:
"
newtab
-
custom
-
row
-
selector
"
"
data
-
l10n
-
args
"
:
"
{
\
"
num
\
"
:
2
}
"
}
)
external_React_default
(
)
.
createElement
(
"
option
"
{
value
:
"
3
"
"
data
-
l10n
-
id
"
:
"
newtab
-
custom
-
row
-
selector
"
"
data
-
l10n
-
args
"
:
"
{
\
"
num
\
"
:
3
}
"
}
)
external_React_default
(
)
.
createElement
(
"
option
"
{
value
:
"
4
"
"
data
-
l10n
-
id
"
:
"
newtab
-
custom
-
row
-
selector
"
"
data
-
l10n
-
args
"
:
"
{
\
"
num
\
"
:
4
}
"
}
)
)
)
)
)
)
)
pocketRegion
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
id
:
"
pocket
-
section
"
className
:
"
section
"
}
external_React_default
(
)
.
createElement
(
"
moz
-
toggle
"
{
id
:
"
pocket
-
toggle
"
pressed
:
pocketEnabled
|
|
null
onToggle
:
this
.
onPreferenceSelect
"
aria
-
describedby
"
:
"
custom
-
pocket
-
subtitle
"
"
data
-
preference
"
:
"
feeds
.
section
.
topstories
"
"
data
-
eventSource
"
:
"
TOP_STORIES
"
"
data
-
l10n
-
id
"
:
"
newtab
-
custom
-
stories
-
toggle
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
slot
:
"
nested
"
}
(
mayHaveRecentSaves
|
|
mayHaveInferredPersonalization
|
|
mayHaveTopicSections
)
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
more
-
info
-
pocket
-
wrapper
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
more
-
information
"
ref
:
this
.
pocketDrawerRef
}
mayHaveInferredPersonalization
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
check
-
wrapper
"
role
:
"
presentation
"
}
external_React_default
(
)
.
createElement
(
"
input
"
{
id
:
"
inferred
-
personalization
"
className
:
"
customize
-
menu
-
checkbox
"
disabled
:
!
pocketEnabled
checked
:
showInferredPersonalizationEnabled
type
:
"
checkbox
"
onChange
:
this
.
onPreferenceSelect
"
data
-
preference
"
:
"
discoverystream
.
sections
.
personalization
.
inferred
.
user
.
enabled
"
"
data
-
eventSource
"
:
"
INFERRED_PERSONALIZATION
"
}
)
external_React_default
(
)
.
createElement
(
"
label
"
{
className
:
"
customize
-
menu
-
checkbox
-
label
"
htmlFor
:
"
inferred
-
personalization
"
}
"
Recommendations
inferred
from
your
activity
with
the
feed
"
)
)
mayHaveTopicSections
&
&
external_React_default
(
)
.
createElement
(
SectionsMgmtPanel
{
exitEventFired
:
exitEventFired
}
)
mayHaveRecentSaves
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
check
-
wrapper
"
role
:
"
presentation
"
}
external_React_default
(
)
.
createElement
(
"
input
"
{
id
:
"
recent
-
saves
-
pocket
"
className
:
"
customize
-
menu
-
checkbox
"
disabled
:
!
pocketEnabled
checked
:
showRecentSavesEnabled
type
:
"
checkbox
"
onChange
:
this
.
onPreferenceSelect
"
data
-
preference
"
:
"
showRecentSaves
"
"
data
-
eventSource
"
:
"
POCKET_RECENT_SAVES
"
}
)
external_React_default
(
)
.
createElement
(
"
label
"
{
className
:
"
customize
-
menu
-
checkbox
-
label
"
htmlFor
:
"
recent
-
saves
-
pocket
"
"
data
-
l10n
-
id
"
:
"
newtab
-
custom
-
pocket
-
show
-
recent
-
saves
"
}
)
)
)
)
)
)
)
)
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
divider
"
role
:
"
separator
"
}
)
external_React_default
(
)
.
createElement
(
"
div
"
null
external_React_default
(
)
.
createElement
(
"
button
"
{
id
:
"
settings
-
link
"
className
:
"
external
-
link
"
onClick
:
openPreferences
"
data
-
l10n
-
id
"
:
"
newtab
-
custom
-
settings
"
}
)
)
)
;
}
}
;
class
_CustomizeMenu
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
onEntered
=
this
.
onEntered
.
bind
(
this
)
;
this
.
onExited
=
this
.
onExited
.
bind
(
this
)
;
this
.
state
=
{
exitEventFired
:
false
}
;
}
onEntered
(
)
{
this
.
setState
(
{
exitEventFired
:
false
}
)
;
if
(
this
.
closeButton
)
{
this
.
closeButton
.
focus
(
)
;
}
}
onExited
(
)
{
this
.
setState
(
{
exitEventFired
:
true
}
)
;
if
(
this
.
openButton
)
{
this
.
openButton
.
focus
(
)
;
}
}
render
(
)
{
return
external_React_default
(
)
.
createElement
(
"
span
"
null
external_React_default
(
)
.
createElement
(
external_ReactTransitionGroup_namespaceObject
.
CSSTransition
{
timeout
:
300
classNames
:
"
personalize
-
animate
"
in
:
!
this
.
props
.
showing
appear
:
true
}
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
"
personalize
-
button
"
"
data
-
l10n
-
id
"
:
"
newtab
-
customize
-
panel
-
icon
-
button
"
onClick
:
(
)
=
>
this
.
props
.
onOpen
(
)
onKeyDown
:
e
=
>
{
if
(
e
.
key
=
=
=
"
Enter
"
)
{
this
.
props
.
onOpen
(
)
;
}
}
ref
:
c
=
>
this
.
openButton
=
c
}
external_React_default
(
)
.
createElement
(
"
div
"
null
external_React_default
(
)
.
createElement
(
"
img
"
{
role
:
"
presentation
"
src
:
"
chrome
:
/
/
global
/
skin
/
icons
/
edit
-
outline
.
svg
"
}
)
)
external_React_default
(
)
.
createElement
(
"
label
"
{
"
data
-
l10n
-
id
"
:
"
newtab
-
customize
-
panel
-
icon
-
button
-
label
"
}
)
)
)
external_React_default
(
)
.
createElement
(
external_ReactTransitionGroup_namespaceObject
.
CSSTransition
{
timeout
:
250
classNames
:
"
customize
-
animate
"
in
:
this
.
props
.
showing
onEntered
:
this
.
onEntered
onExited
:
this
.
onExited
appear
:
true
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
customize
-
menu
"
role
:
"
dialog
"
"
data
-
l10n
-
id
"
:
"
newtab
-
settings
-
dialog
-
label
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
close
-
button
-
wrapper
"
}
external_React_default
(
)
.
createElement
(
"
moz
-
button
"
{
onClick
:
(
)
=
>
this
.
props
.
onClose
(
)
id
:
"
close
-
button
"
type
:
"
icon
ghost
"
"
data
-
l10n
-
id
"
:
"
newtab
-
custom
-
close
-
menu
-
button
"
iconsrc
:
"
chrome
:
/
/
global
/
skin
/
icons
/
close
.
svg
"
ref
:
c
=
>
this
.
closeButton
=
c
}
)
)
external_React_default
(
)
.
createElement
(
ContentSection
{
openPreferences
:
this
.
props
.
openPreferences
setPref
:
this
.
props
.
setPref
enabledSections
:
this
.
props
.
enabledSections
enabledWidgets
:
this
.
props
.
enabledWidgets
wallpapersEnabled
:
this
.
props
.
wallpapersEnabled
activeWallpaper
:
this
.
props
.
activeWallpaper
pocketRegion
:
this
.
props
.
pocketRegion
mayHaveTopicSections
:
this
.
props
.
mayHaveTopicSections
mayHaveInferredPersonalization
:
this
.
props
.
mayHaveInferredPersonalization
mayHaveRecentSaves
:
this
.
props
.
DiscoveryStream
.
recentSavesEnabled
mayHaveWeather
:
this
.
props
.
mayHaveWeather
mayHaveTrendingSearch
:
this
.
props
.
mayHaveTrendingSearch
mayHaveWidgets
:
this
.
props
.
mayHaveWidgets
mayHaveTimerWidget
:
this
.
props
.
mayHaveTimerWidget
mayHaveListsWidget
:
this
.
props
.
mayHaveListsWidget
dispatch
:
this
.
props
.
dispatch
exitEventFired
:
this
.
state
.
exitEventFired
}
)
)
)
)
;
}
}
const
CustomizeMenu
=
(
0
external_ReactRedux_namespaceObject
.
connect
)
(
state
=
>
(
{
DiscoveryStream
:
state
.
DiscoveryStream
}
)
)
(
_CustomizeMenu
)
;
;
const
IS_NEWTAB
=
globalThis
.
document
&
&
globalThis
.
document
.
documentURI
=
=
=
"
about
:
newtab
"
;
const
NEWTAB_DARK_THEME
=
{
ntp_background
:
{
r
:
42
g
:
42
b
:
46
a
:
1
}
ntp_card_background
:
{
r
:
66
g
:
65
b
:
77
a
:
1
}
ntp_text
:
{
r
:
249
g
:
249
b
:
250
a
:
1
}
sidebar
:
{
r
:
56
g
:
56
b
:
61
a
:
1
}
sidebar_text
:
{
r
:
249
g
:
249
b
:
250
a
:
1
}
}
;
;
function
Logo
(
)
{
return
external_React_default
(
)
.
createElement
(
"
h1
"
{
className
:
"
logo
-
and
-
wordmark
-
wrapper
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
logo
-
and
-
wordmark
"
role
:
"
img
"
"
data
-
l10n
-
id
"
:
"
newtab
-
logo
-
and
-
wordmark
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
logo
"
}
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
wordmark
"
}
)
)
)
;
}
;
class
_Search
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
onSearchClick
=
this
.
onSearchClick
.
bind
(
this
)
;
this
.
onSearchHandoffClick
=
this
.
onSearchHandoffClick
.
bind
(
this
)
;
this
.
onSearchHandoffPaste
=
this
.
onSearchHandoffPaste
.
bind
(
this
)
;
this
.
onSearchHandoffDrop
=
this
.
onSearchHandoffDrop
.
bind
(
this
)
;
this
.
onInputMount
=
this
.
onInputMount
.
bind
(
this
)
;
this
.
onInputMountHandoff
=
this
.
onInputMountHandoff
.
bind
(
this
)
;
this
.
onSearchHandoffButtonMount
=
this
.
onSearchHandoffButtonMount
.
bind
(
this
)
;
}
handleEvent
(
event
)
{
if
(
event
.
detail
.
type
=
=
=
"
Search
"
)
{
this
.
props
.
dispatch
(
actionCreators
.
UserEvent
(
{
event
:
"
SEARCH
"
}
)
)
;
}
}
onSearchClick
(
event
)
{
window
.
gContentSearchController
.
search
(
event
)
;
}
doSearchHandoff
(
text
)
{
this
.
props
.
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
HANDOFF_SEARCH_TO_AWESOMEBAR
data
:
{
text
}
}
)
)
;
this
.
props
.
dispatch
(
{
type
:
actionTypes
.
FAKE_FOCUS_SEARCH
}
)
;
this
.
props
.
dispatch
(
actionCreators
.
UserEvent
(
{
event
:
"
SEARCH_HANDOFF
"
}
)
)
;
if
(
text
)
{
this
.
props
.
dispatch
(
{
type
:
actionTypes
.
DISABLE_SEARCH
}
)
;
}
}
onSearchHandoffClick
(
event
)
{
event
.
preventDefault
(
)
;
this
.
doSearchHandoff
(
)
;
}
onSearchHandoffPaste
(
event
)
{
event
.
preventDefault
(
)
;
this
.
doSearchHandoff
(
event
.
clipboardData
.
getData
(
"
Text
"
)
)
;
}
onSearchHandoffDrop
(
event
)
{
event
.
preventDefault
(
)
;
let
text
=
event
.
dataTransfer
.
getData
(
"
text
"
)
;
if
(
text
)
{
this
.
doSearchHandoff
(
text
)
;
}
}
componentDidMount
(
)
{
const
caret
=
this
.
fakeCaret
;
const
{
caretBlinkCount
caretBlinkTime
}
=
this
.
props
.
Prefs
.
values
;
if
(
caret
)
{
caret
.
style
.
setProperty
(
"
-
-
caret
-
blink
-
count
"
caretBlinkCount
>
-
1
?
caretBlinkCount
:
"
infinite
"
)
;
caret
.
style
.
setProperty
(
"
-
-
caret
-
blink
-
time
"
caretBlinkTime
>
0
?
{
caretBlinkTime
*
2
}
ms
:
{
1134
}
ms
)
;
}
}
componentWillUnmount
(
)
{
delete
window
.
gContentSearchController
;
}
onInputMount
(
input
)
{
if
(
input
)
{
const
healthReportKey
=
IS_NEWTAB
?
"
newtab
"
:
"
abouthome
"
;
window
.
gContentSearchController
=
new
ContentSearchUIController
(
input
input
.
parentNode
healthReportKey
)
;
addEventListener
(
"
ContentSearchClient
"
this
)
;
}
else
{
window
.
gContentSearchController
=
null
;
removeEventListener
(
"
ContentSearchClient
"
this
)
;
}
}
onInputMountHandoff
(
input
)
{
if
(
input
)
{
this
.
_handoffSearchController
=
new
ContentSearchHandoffUIController
(
)
;
}
}
onSearchHandoffButtonMount
(
button
)
{
this
.
_searchHandoffButton
=
button
;
}
render
(
)
{
const
wrapperClassName
=
[
"
search
-
wrapper
"
this
.
props
.
disable
&
&
"
search
-
disabled
"
this
.
props
.
fakeFocus
&
&
"
fake
-
focus
"
]
.
filter
(
v
=
>
v
)
.
join
(
"
"
)
;
const
prefs
=
this
.
props
.
Prefs
.
values
;
const
trendingSearchEnabled
=
prefs
[
"
trendingSearch
.
enabled
"
]
&
&
prefs
[
"
system
.
trendingSearch
.
enabled
"
]
&
&
prefs
[
"
trendingSearch
.
defaultSearchEngine
"
]
?
.
toLowerCase
(
)
=
=
=
"
google
"
;
const
trendingSearchVariant
=
this
.
props
.
Prefs
.
values
[
"
trendingSearch
.
variant
"
]
;
return
external_React_default
(
)
.
createElement
(
(
external_React_default
(
)
)
.
Fragment
null
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
wrapperClassName
}
this
.
props
.
showLogo
&
&
external_React_default
(
)
.
createElement
(
Logo
null
)
!
this
.
props
.
handoffEnabled
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
search
-
inner
-
wrapper
no
-
handoff
"
}
external_React_default
(
)
.
createElement
(
"
input
"
{
id
:
"
newtab
-
search
-
text
"
"
data
-
l10n
-
id
"
:
"
newtab
-
search
-
box
-
input
"
maxLength
:
"
256
"
ref
:
this
.
onInputMount
type
:
"
search
"
}
)
external_React_default
(
)
.
createElement
(
"
button
"
{
id
:
"
searchSubmit
"
className
:
"
search
-
button
"
"
data
-
l10n
-
id
"
:
"
newtab
-
search
-
box
-
search
-
button
"
onClick
:
this
.
onSearchClick
}
)
trendingSearchEnabled
&
&
(
trendingSearchVariant
=
=
=
"
a
"
|
|
trendingSearchVariant
=
=
=
"
c
"
)
&
&
external_React_default
(
)
.
createElement
(
TrendingSearches
null
)
)
this
.
props
.
handoffEnabled
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
search
-
inner
-
wrapper
"
}
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
"
search
-
handoff
-
button
"
ref
:
this
.
onSearchHandoffButtonMount
onClick
:
this
.
onSearchHandoffClick
tabIndex
:
"
-
1
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
fake
-
textbox
"
}
)
external_React_default
(
)
.
createElement
(
"
input
"
{
type
:
"
search
"
className
:
"
fake
-
editable
"
tabIndex
:
"
-
1
"
"
aria
-
hidden
"
:
"
true
"
onDrop
:
this
.
onSearchHandoffDrop
onPaste
:
this
.
onSearchHandoffPaste
ref
:
this
.
onInputMountHandoff
}
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
fake
-
caret
"
ref
:
el
=
>
{
this
.
fakeCaret
=
el
;
}
}
)
)
trendingSearchEnabled
&
&
(
trendingSearchVariant
=
=
=
"
a
"
|
|
trendingSearchVariant
=
=
=
"
c
"
)
&
&
external_React_default
(
)
.
createElement
(
TrendingSearches
null
)
)
)
)
;
}
}
const
Search_Search
=
(
0
external_ReactRedux_namespaceObject
.
connect
)
(
state
=
>
(
{
Prefs
:
state
.
Prefs
}
)
)
(
_Search
)
;
;
function
LocationSearch
(
{
outerClassName
}
)
{
const
[
selectedLocation
setSelectedLocation
]
=
(
0
external_React_namespaceObject
.
useState
)
(
"
"
)
;
const
suggestedLocations
=
(
0
external_ReactRedux_namespaceObject
.
useSelector
)
(
state
=
>
state
.
Weather
.
suggestedLocations
)
;
const
locationSearchString
=
(
0
external_ReactRedux_namespaceObject
.
useSelector
)
(
state
=
>
state
.
Weather
.
locationSearchString
)
;
const
[
userInput
setUserInput
]
=
(
0
external_React_namespaceObject
.
useState
)
(
locationSearchString
|
|
"
"
)
;
const
inputRef
=
(
0
external_React_namespaceObject
.
useRef
)
(
null
)
;
const
dispatch
=
(
0
external_ReactRedux_namespaceObject
.
useDispatch
)
(
)
;
(
0
external_React_namespaceObject
.
useEffect
)
(
(
)
=
>
{
if
(
selectedLocation
)
{
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
WEATHER_LOCATION_DATA_UPDATE
data
:
{
city
:
selectedLocation
.
localized_name
adminName
:
selectedLocation
.
administrative_area
country
:
selectedLocation
.
country
}
}
)
)
;
dispatch
(
actionCreators
.
SetPref
(
"
weather
.
query
"
selectedLocation
.
key
)
)
;
dispatch
(
actionCreators
.
BroadcastToContent
(
{
type
:
actionTypes
.
WEATHER_SEARCH_ACTIVE
data
:
false
}
)
)
;
}
}
[
selectedLocation
dispatch
]
)
;
(
0
external_React_namespaceObject
.
useEffect
)
(
(
)
=
>
{
inputRef
?
.
current
?
.
focus
(
)
;
}
[
inputRef
]
)
;
function
handleChange
(
event
)
{
const
{
value
}
=
event
.
target
;
setUserInput
(
value
)
;
if
(
value
.
length
<
3
&
&
suggestedLocations
.
length
)
{
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
WEATHER_LOCATION_SUGGESTIONS_UPDATE
data
:
[
]
}
)
)
;
}
const
match
=
suggestedLocations
?
.
find
(
(
{
key
}
)
=
>
key
=
=
=
value
)
;
if
(
match
)
{
setSelectedLocation
(
match
)
;
setUserInput
(
{
match
.
localized_name
}
{
match
.
administrative_area
.
localized_name
}
)
;
}
else
if
(
value
.
length
>
=
3
&
&
!
match
)
{
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
WEATHER_LOCATION_SEARCH_UPDATE
data
:
value
}
)
)
;
}
}
function
handleCloseSearch
(
)
{
dispatch
(
actionCreators
.
BroadcastToContent
(
{
type
:
actionTypes
.
WEATHER_SEARCH_ACTIVE
data
:
false
}
)
)
;
setUserInput
(
"
"
)
;
}
function
handleKeyDown
(
e
)
{
if
(
e
.
key
=
=
=
"
Escape
"
)
{
handleCloseSearch
(
)
;
}
}
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
{
outerClassName
}
location
-
search
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
location
-
input
-
wrapper
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
search
-
icon
"
}
)
external_React_default
(
)
.
createElement
(
"
input
"
{
ref
:
inputRef
list
:
"
merino
-
location
-
list
"
type
:
"
text
"
"
data
-
l10n
-
id
"
:
"
newtab
-
weather
-
change
-
location
-
search
-
input
-
placeholder
"
onChange
:
handleChange
value
:
userInput
onKeyDown
:
handleKeyDown
}
)
external_React_default
(
)
.
createElement
(
"
moz
-
button
"
{
class
:
"
close
-
icon
"
type
:
"
icon
ghost
"
size
:
"
small
"
iconSrc
:
"
chrome
:
/
/
global
/
skin
/
icons
/
close
.
svg
"
onClick
:
handleCloseSearch
}
)
external_React_default
(
)
.
createElement
(
"
datalist
"
{
id
:
"
merino
-
location
-
list
"
}
(
suggestedLocations
|
|
[
]
)
.
map
(
merinoLcation
=
>
external_React_default
(
)
.
createElement
(
"
option
"
{
value
:
merinoLcation
.
key
key
:
merinoLcation
.
key
}
merinoLcation
.
localized_name
"
"
"
"
merinoLcation
.
administrative_area
.
localized_name
)
)
)
)
)
;
}
;
const
Weather_VISIBLE
=
"
visible
"
;
const
Weather_VISIBILITY_CHANGE_EVENT
=
"
visibilitychange
"
;
function
WeatherPlaceholder
(
)
{
const
[
isSeen
setIsSeen
]
=
(
0
external_React_namespaceObject
.
useState
)
(
false
)
;
const
ref
=
useIntersectionObserver
(
(
)
=
>
setIsSeen
(
true
)
1
)
;
const
isSeenClassName
=
isSeen
?
placeholder
-
seen
:
;
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
weather
weather
-
placeholder
{
isSeenClassName
}
ref
:
el
=
>
{
ref
.
current
=
[
el
]
;
}
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
placeholder
-
image
placeholder
-
fill
"
}
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
placeholder
-
context
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
placeholder
-
header
placeholder
-
fill
"
}
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
placeholder
-
description
placeholder
-
fill
"
}
)
)
)
;
}
class
_Weather
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
state
=
{
contextMenuKeyboard
:
false
showContextMenu
:
false
url
:
"
https
:
/
/
example
.
com
"
impressionSeen
:
false
errorSeen
:
false
}
;
this
.
setImpressionRef
=
element
=
>
{
this
.
impressionElement
=
element
;
}
;
this
.
setErrorRef
=
element
=
>
{
this
.
errorElement
=
element
;
}
;
this
.
onClick
=
this
.
onClick
.
bind
(
this
)
;
this
.
onKeyDown
=
this
.
onKeyDown
.
bind
(
this
)
;
this
.
onUpdate
=
this
.
onUpdate
.
bind
(
this
)
;
this
.
onProviderClick
=
this
.
onProviderClick
.
bind
(
this
)
;
}
componentDidMount
(
)
{
const
{
props
}
=
this
;
if
(
!
props
.
dispatch
)
{
return
;
}
if
(
props
.
document
.
visibilityState
=
=
=
Weather_VISIBLE
)
{
this
.
setImpressionObservers
(
)
;
}
else
{
if
(
this
.
_onVisibilityChange
)
{
props
.
document
.
removeEventListener
(
Weather_VISIBILITY_CHANGE_EVENT
this
.
_onVisibilityChange
)
;
}
this
.
_onVisibilityChange
=
(
)
=
>
{
if
(
props
.
document
.
visibilityState
=
=
=
Weather_VISIBLE
)
{
this
.
setImpressionObservers
(
)
;
props
.
document
.
removeEventListener
(
Weather_VISIBILITY_CHANGE_EVENT
this
.
_onVisibilityChange
)
;
}
}
;
props
.
document
.
addEventListener
(
Weather_VISIBILITY_CHANGE_EVENT
this
.
_onVisibilityChange
)
;
}
}
componentWillUnmount
(
)
{
if
(
this
.
observer
&
&
this
.
impressionElement
)
{
this
.
observer
.
unobserve
(
this
.
impressionElement
)
;
}
if
(
this
.
observer
&
&
this
.
errorElement
)
{
this
.
observer
.
unobserve
(
this
.
errorElement
)
;
}
if
(
this
.
_onVisibilityChange
)
{
this
.
props
.
document
.
removeEventListener
(
Weather_VISIBILITY_CHANGE_EVENT
this
.
_onVisibilityChange
)
;
}
}
setImpressionObservers
(
)
{
if
(
this
.
impressionElement
)
{
this
.
observer
=
new
IntersectionObserver
(
this
.
onImpression
.
bind
(
this
)
)
;
this
.
observer
.
observe
(
this
.
impressionElement
)
;
}
if
(
this
.
errorElement
)
{
this
.
observer
=
new
IntersectionObserver
(
this
.
onError
.
bind
(
this
)
)
;
this
.
observer
.
observe
(
this
.
errorElement
)
;
}
}
onImpression
(
entries
)
{
if
(
this
.
state
)
{
const
entry
=
entries
.
find
(
e
=
>
e
.
isIntersecting
)
;
if
(
entry
)
{
if
(
this
.
impressionElement
)
{
this
.
observer
.
unobserve
(
this
.
impressionElement
)
;
}
this
.
props
.
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
WEATHER_IMPRESSION
}
)
)
;
this
.
setState
(
{
impressionSeen
:
true
}
)
;
}
}
}
onError
(
entries
)
{
if
(
this
.
state
)
{
const
entry
=
entries
.
find
(
e
=
>
e
.
isIntersecting
)
;
if
(
entry
)
{
if
(
this
.
errorElement
)
{
this
.
observer
.
unobserve
(
this
.
errorElement
)
;
}
this
.
props
.
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
WEATHER_LOAD_ERROR
}
)
)
;
this
.
setState
(
{
errorSeen
:
true
}
)
;
}
}
}
openContextMenu
(
isKeyBoard
)
{
if
(
this
.
props
.
onUpdate
)
{
this
.
props
.
onUpdate
(
true
)
;
}
this
.
setState
(
{
showContextMenu
:
true
contextMenuKeyboard
:
isKeyBoard
}
)
;
}
onClick
(
event
)
{
event
.
preventDefault
(
)
;
this
.
openContextMenu
(
false
event
)
;
}
onKeyDown
(
event
)
{
if
(
event
.
key
=
=
=
"
Enter
"
|
|
event
.
key
=
=
=
"
"
)
{
event
.
preventDefault
(
)
;
this
.
openContextMenu
(
true
event
)
;
}
}
onUpdate
(
showContextMenu
)
{
if
(
this
.
props
.
onUpdate
)
{
this
.
props
.
onUpdate
(
showContextMenu
)
;
}
this
.
setState
(
{
showContextMenu
}
)
;
}
onProviderClick
(
)
{
this
.
props
.
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
WEATHER_OPEN_PROVIDER_URL
data
:
{
source
:
"
WEATHER
"
}
}
)
)
;
}
render
(
)
{
const
isWeatherEnabled
=
this
.
props
.
Prefs
.
values
[
"
system
.
showWeather
"
]
;
if
(
!
isWeatherEnabled
)
{
return
false
;
}
if
(
this
.
props
.
App
.
isForStartupCache
.
Weather
|
|
!
this
.
props
.
Weather
.
initialized
)
{
return
external_React_default
(
)
.
createElement
(
WeatherPlaceholder
null
)
;
}
const
{
showContextMenu
}
=
this
.
state
;
const
{
props
}
=
this
;
const
{
dispatch
Prefs
Weather
}
=
props
;
const
WEATHER_SUGGESTION
=
Weather
.
suggestions
?
.
[
0
]
;
const
outerClassName
=
[
"
weather
"
Weather
.
searchActive
&
&
"
search
"
]
.
filter
(
v
=
>
v
)
.
join
(
"
"
)
;
const
showDetailedView
=
Prefs
.
values
[
"
weather
.
display
"
]
=
=
=
"
detailed
"
;
const
WEATHER_SOURCE_CONTEXT_MENU_OPTIONS
=
[
.
.
.
(
Prefs
.
values
[
"
weather
.
locationSearchEnabled
"
]
?
[
"
ChangeWeatherLocation
"
]
:
[
]
)
.
.
.
(
Prefs
.
values
[
"
weather
.
temperatureUnits
"
]
=
=
=
"
f
"
?
[
"
ChangeTempUnitCelsius
"
]
:
[
"
ChangeTempUnitFahrenheit
"
]
)
.
.
.
(
Prefs
.
values
[
"
weather
.
display
"
]
=
=
=
"
simple
"
?
[
"
ChangeWeatherDisplayDetailed
"
]
:
[
"
ChangeWeatherDisplaySimple
"
]
)
"
HideWeather
"
"
OpenLearnMoreURL
"
]
;
const
WEATHER_SOURCE_ERROR_CONTEXT_MENU_OPTIONS
=
[
.
.
.
(
Prefs
.
values
[
"
weather
.
locationSearchEnabled
"
]
?
[
"
ChangeWeatherLocation
"
]
:
[
]
)
"
HideWeather
"
"
OpenLearnMoreURL
"
]
;
const
contextMenu
=
contextOpts
=
>
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
weatherButtonContextMenuWrapper
"
}
external_React_default
(
)
.
createElement
(
"
button
"
{
"
aria
-
haspopup
"
:
"
true
"
onKeyDown
:
this
.
onKeyDown
onClick
:
this
.
onClick
"
data
-
l10n
-
id
"
:
"
newtab
-
menu
-
section
-
tooltip
"
className
:
"
weatherButtonContextMenu
"
}
showContextMenu
?
external_React_default
(
)
.
createElement
(
LinkMenu
{
dispatch
:
dispatch
index
:
0
source
:
"
WEATHER
"
onUpdate
:
this
.
onUpdate
options
:
contextOpts
site
:
{
url
:
"
https
:
/
/
support
.
mozilla
.
org
/
kb
/
customize
-
items
-
on
-
firefox
-
new
-
tab
-
page
"
}
link
:
"
https
:
/
/
support
.
mozilla
.
org
/
kb
/
customize
-
items
-
on
-
firefox
-
new
-
tab
-
page
"
shouldSendImpressionStats
:
false
}
)
:
null
)
)
;
if
(
Weather
.
searchActive
)
{
return
external_React_default
(
)
.
createElement
(
LocationSearch
{
outerClassName
:
outerClassName
}
)
;
}
else
if
(
WEATHER_SUGGESTION
)
{
return
external_React_default
(
)
.
createElement
(
"
div
"
{
ref
:
this
.
setImpressionRef
className
:
outerClassName
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
weatherCard
"
}
external_React_default
(
)
.
createElement
(
"
a
"
{
"
data
-
l10n
-
id
"
:
"
newtab
-
weather
-
see
-
forecast
"
"
data
-
l10n
-
args
"
:
"
{
\
"
provider
\
"
:
\
"
AccuWeather
\
xAE
\
"
}
"
href
:
WEATHER_SUGGESTION
.
forecast
.
url
className
:
"
weatherInfoLink
"
onClick
:
this
.
onProviderClick
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
weatherIconCol
"
}
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
weatherIcon
iconId
{
WEATHER_SUGGESTION
.
current_conditions
.
icon_id
}
}
)
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
weatherText
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
weatherForecastRow
"
}
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
weatherTemperature
"
}
WEATHER_SUGGESTION
.
current_conditions
.
temperature
[
Prefs
.
values
[
"
weather
.
temperatureUnits
"
]
]
"
\
xB0
"
Prefs
.
values
[
"
weather
.
temperatureUnits
"
]
)
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
weatherCityRow
"
}
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
weatherCity
"
}
Weather
.
locationData
.
city
)
)
showDetailedView
?
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
weatherDetailedSummaryRow
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
weatherHighLowTemps
"
}
external_React_default
(
)
.
createElement
(
"
span
"
null
WEATHER_SUGGESTION
.
forecast
.
high
[
Prefs
.
values
[
"
weather
.
temperatureUnits
"
]
]
"
\
xB0
"
Prefs
.
values
[
"
weather
.
temperatureUnits
"
]
)
external_React_default
(
)
.
createElement
(
"
span
"
null
"
\
u2022
"
)
external_React_default
(
)
.
createElement
(
"
span
"
null
WEATHER_SUGGESTION
.
forecast
.
low
[
Prefs
.
values
[
"
weather
.
temperatureUnits
"
]
]
"
\
xB0
"
Prefs
.
values
[
"
weather
.
temperatureUnits
"
]
)
)
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
weatherTextSummary
"
}
WEATHER_SUGGESTION
.
current_conditions
.
summary
)
)
:
null
)
)
contextMenu
(
WEATHER_SOURCE_CONTEXT_MENU_OPTIONS
)
)
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
weatherSponsorText
"
}
external_React_default
(
)
.
createElement
(
"
span
"
{
"
data
-
l10n
-
id
"
:
"
newtab
-
weather
-
sponsored
"
"
data
-
l10n
-
args
"
:
"
{
\
"
provider
\
"
:
\
"
AccuWeather
\
xAE
\
"
}
"
}
)
)
)
;
}
return
external_React_default
(
)
.
createElement
(
"
div
"
{
ref
:
this
.
setErrorRef
className
:
outerClassName
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
weatherNotAvailable
"
}
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
icon
icon
-
info
-
warning
"
}
)
"
"
external_React_default
(
)
.
createElement
(
"
p
"
{
"
data
-
l10n
-
id
"
:
"
newtab
-
weather
-
error
-
not
-
available
"
}
)
contextMenu
(
WEATHER_SOURCE_ERROR_CONTEXT_MENU_OPTIONS
)
)
)
;
}
}
const
Weather_Weather
=
(
0
external_ReactRedux_namespaceObject
.
connect
)
(
state
=
>
(
{
App
:
state
.
App
Weather
:
state
.
Weather
Prefs
:
state
.
Prefs
IntersectionObserver
:
globalThis
.
IntersectionObserver
document
:
globalThis
.
document
}
)
)
(
_Weather
)
;
;
function
DownloadModalToggle
(
{
onClick
isActive
}
)
{
return
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
mobile
-
download
-
promo
{
isActive
?
"
is
-
active
"
:
"
"
}
onClick
:
onClick
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
icon
icon
-
device
-
phone
"
}
)
)
;
}
;
function
ThumbUpThumbDownToast
(
{
onDismissClick
onAnimationEnd
}
)
{
const
mozMessageBarRef
=
(
0
external_React_namespaceObject
.
useRef
)
(
null
)
;
(
0
external_React_namespaceObject
.
useEffect
)
(
(
)
=
>
{
const
{
current
:
mozMessageBarElement
}
=
mozMessageBarRef
;
mozMessageBarElement
.
addEventListener
(
"
message
-
bar
:
user
-
dismissed
"
onDismissClick
{
once
:
true
}
)
;
return
(
)
=
>
{
mozMessageBarElement
.
removeEventListener
(
"
message
-
bar
:
user
-
dismissed
"
onDismissClick
)
;
}
;
}
[
onDismissClick
]
)
;
return
external_React_default
(
)
.
createElement
(
"
moz
-
message
-
bar
"
{
type
:
"
success
"
class
:
"
notification
-
feed
-
item
"
dismissable
:
true
"
data
-
l10n
-
id
"
:
"
newtab
-
toast
-
thumbs
-
up
-
or
-
down2
"
ref
:
mozMessageBarRef
onAnimationEnd
:
onAnimationEnd
}
)
;
}
;
function
ReportContentToast
(
{
onDismissClick
onAnimationEnd
}
)
{
const
mozMessageBarRef
=
(
0
external_React_namespaceObject
.
useRef
)
(
null
)
;
(
0
external_React_namespaceObject
.
useEffect
)
(
(
)
=
>
{
const
{
current
:
mozMessageBarElement
}
=
mozMessageBarRef
;
mozMessageBarElement
.
addEventListener
(
"
message
-
bar
:
user
-
dismissed
"
onDismissClick
{
once
:
true
}
)
;
return
(
)
=
>
{
mozMessageBarElement
.
removeEventListener
(
"
message
-
bar
:
user
-
dismissed
"
onDismissClick
)
;
}
;
}
[
onDismissClick
]
)
;
return
external_React_default
(
)
.
createElement
(
"
moz
-
message
-
bar
"
{
type
:
"
success
"
class
:
"
notification
-
feed
-
item
"
dismissable
:
true
"
data
-
l10n
-
id
"
:
"
newtab
-
toast
-
thanks
-
for
-
reporting
"
ref
:
mozMessageBarRef
onAnimationEnd
:
onAnimationEnd
}
)
;
}
;
function
Notifications_Notifications
(
{
dispatch
}
)
{
const
toastQueue
=
(
0
external_ReactRedux_namespaceObject
.
useSelector
)
(
state
=
>
state
.
Notifications
.
toastQueue
)
;
const
toastCounter
=
(
0
external_ReactRedux_namespaceObject
.
useSelector
)
(
state
=
>
state
.
Notifications
.
toastCounter
)
;
const
syncHiddenToastData
=
(
0
external_React_namespaceObject
.
useCallback
)
(
(
)
=
>
{
const
toastId
=
toastQueue
[
toastQueue
.
length
-
1
]
;
const
queuedToasts
=
[
.
.
.
toastQueue
]
.
slice
(
1
)
;
dispatch
(
actionCreators
.
OnlyToOneContent
(
{
type
:
actionTypes
.
HIDE_TOAST_MESSAGE
data
:
{
toastQueue
:
queuedToasts
toastCounter
:
queuedToasts
.
length
toastId
showNotifications
:
false
}
}
"
ActivityStream
:
Content
"
)
)
;
}
[
dispatch
toastQueue
]
)
;
const
getToast
=
(
0
external_React_namespaceObject
.
useCallback
)
(
(
)
=
>
{
const
latestToastItem
=
toastQueue
[
toastQueue
.
length
-
1
]
;
if
(
!
latestToastItem
)
{
throw
new
Error
(
"
No
toast
found
"
)
;
}
switch
(
latestToastItem
)
{
case
"
reportSuccessToast
"
:
return
external_React_default
(
)
.
createElement
(
ReportContentToast
{
onDismissClick
:
syncHiddenToastData
onAnimationEnd
:
syncHiddenToastData
key
:
toastCounter
}
)
;
case
"
thumbsUpToast
"
:
case
"
thumbsDownToast
"
:
return
external_React_default
(
)
.
createElement
(
ThumbUpThumbDownToast
{
onDismissClick
:
syncHiddenToastData
onAnimationEnd
:
syncHiddenToastData
key
:
toastCounter
}
)
;
default
:
throw
new
Error
(
Unexpected
toast
type
:
{
latestToastItem
}
)
;
}
}
[
syncHiddenToastData
toastCounter
toastQueue
]
)
;
(
0
external_React_namespaceObject
.
useEffect
)
(
(
)
=
>
{
getToast
(
)
;
}
[
toastQueue
getToast
]
)
;
return
toastQueue
.
length
?
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
notification
-
wrapper
"
}
getToast
(
)
)
:
"
"
;
}
;
const
EMOJI_LABELS
=
{
business
:
"
"
arts
:
"
"
food
:
"
"
health
:
"
"
finance
:
"
"
government
:
"
"
sports
:
"
"
tech
:
"
"
travel
:
"
"
"
education
-
science
"
:
"
"
society
:
"
"
}
;
function
TopicSelection
(
{
supportUrl
}
)
{
const
dispatch
=
(
0
external_ReactRedux_namespaceObject
.
useDispatch
)
(
)
;
const
inputRef
=
(
0
external_React_namespaceObject
.
useRef
)
(
null
)
;
const
modalRef
=
(
0
external_React_namespaceObject
.
useRef
)
(
null
)
;
const
checkboxWrapperRef
=
(
0
external_React_namespaceObject
.
useRef
)
(
null
)
;
const
prefs
=
(
0
external_ReactRedux_namespaceObject
.
useSelector
)
(
state
=
>
state
.
Prefs
.
values
)
;
const
topics
=
prefs
[
"
discoverystream
.
topicSelection
.
topics
"
]
.
split
(
"
"
)
;
const
selectedTopics
=
prefs
[
"
discoverystream
.
topicSelection
.
selectedTopics
"
]
;
const
suggestedTopics
=
prefs
[
"
discoverystream
.
topicSelection
.
suggestedTopics
"
]
?
.
split
(
"
"
)
;
const
displayCount
=
prefs
[
"
discoverystream
.
topicSelection
.
onboarding
.
displayCount
"
]
;
const
topicsHaveBeenPreviouslySet
=
prefs
[
"
discoverystream
.
topicSelection
.
hasBeenUpdatedPreviously
"
]
;
const
[
isFirstRun
]
=
(
0
external_React_namespaceObject
.
useState
)
(
displayCount
=
=
=
0
)
;
const
displayCountRef
=
(
0
external_React_namespaceObject
.
useRef
)
(
displayCount
)
;
const
preselectedTopics
=
(
)
=
>
{
if
(
selectedTopics
)
{
return
selectedTopics
.
split
(
"
"
)
;
}
return
isFirstRun
?
suggestedTopics
:
[
]
;
}
;
const
[
topicsToSelect
setTopicsToSelect
]
=
(
0
external_React_namespaceObject
.
useState
)
(
preselectedTopics
)
;
function
isFirstSave
(
)
{
if
(
selectedTopics
=
=
=
"
"
&
&
!
topicsHaveBeenPreviouslySet
)
{
return
true
;
}
return
false
;
}
function
handleModalClose
(
)
{
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
TOPIC_SELECTION_USER_DISMISS
}
)
)
;
dispatch
(
actionCreators
.
BroadcastToContent
(
{
type
:
actionTypes
.
TOPIC_SELECTION_SPOTLIGHT_CLOSE
}
)
)
;
}
function
handleUserClose
(
e
)
{
const
id
=
e
?
.
target
?
.
id
;
if
(
id
=
=
=
"
first
-
run
"
)
{
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
TOPIC_SELECTION_MAYBE_LATER
}
)
)
;
dispatch
(
actionCreators
.
SetPref
(
"
discoverystream
.
topicSelection
.
onboarding
.
maybeDisplay
"
true
)
)
;
}
else
{
dispatch
(
actionCreators
.
SetPref
(
"
discoverystream
.
topicSelection
.
onboarding
.
maybeDisplay
"
false
)
)
;
}
handleModalClose
(
)
;
}
(
0
external_React_namespaceObject
.
useEffect
)
(
(
)
=
>
{
displayCountRef
.
current
=
displayCount
;
}
[
displayCount
]
)
;
(
0
external_React_namespaceObject
.
useEffect
)
(
(
)
=
>
{
const
{
current
}
=
modalRef
;
let
observer
;
if
(
current
)
{
observer
=
new
IntersectionObserver
(
(
[
entry
]
)
=
>
{
if
(
entry
.
isIntersecting
)
{
if
(
displayCountRef
.
current
>
3
)
{
dispatch
(
actionCreators
.
SetPref
(
"
discoverystream
.
topicSelection
.
onboarding
.
maybeDisplay
"
false
)
)
;
}
observer
.
unobserve
(
modalRef
.
current
)
;
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
TOPIC_SELECTION_IMPRESSION
}
)
)
;
}
}
)
;
observer
.
observe
(
current
)
;
}
return
(
)
=
>
{
if
(
current
)
{
observer
.
unobserve
(
current
)
;
}
}
;
}
[
modalRef
dispatch
]
)
;
(
0
external_React_namespaceObject
.
useEffect
)
(
(
)
=
>
{
inputRef
?
.
current
?
.
focus
(
)
;
}
[
inputRef
]
)
;
const
handleFocus
=
(
0
external_React_namespaceObject
.
useCallback
)
(
e
=
>
{
const
tabbableElements
=
modalRef
.
current
.
querySelectorAll
(
'
a
[
href
]
button
moz
-
button
input
[
tabindex
=
"
0
"
]
'
)
;
const
[
firstTabableEl
]
=
tabbableElements
;
const
lastTabbableEl
=
tabbableElements
[
tabbableElements
.
length
-
1
]
;
let
isTabPressed
=
e
.
key
=
=
=
"
Tab
"
|
|
e
.
keyCode
=
=
=
9
;
let
isArrowPressed
=
e
.
key
=
=
=
"
ArrowUp
"
|
|
e
.
key
=
=
=
"
ArrowDown
"
;
if
(
isTabPressed
)
{
if
(
e
.
shiftKey
)
{
if
(
document
.
activeElement
=
=
=
firstTabableEl
)
{
lastTabbableEl
.
focus
(
)
;
e
.
preventDefault
(
)
;
}
}
else
if
(
document
.
activeElement
=
=
=
lastTabbableEl
)
{
firstTabableEl
.
focus
(
)
;
e
.
preventDefault
(
)
;
}
}
else
if
(
isArrowPressed
&
&
checkboxWrapperRef
.
current
.
contains
(
document
.
activeElement
)
)
{
const
checkboxElements
=
checkboxWrapperRef
.
current
.
querySelectorAll
(
"
input
"
)
;
const
[
firstInput
]
=
checkboxElements
;
const
lastInput
=
checkboxElements
[
checkboxElements
.
length
-
1
]
;
const
inputArr
=
Array
.
from
(
checkboxElements
)
;
const
currentIndex
=
inputArr
.
indexOf
(
document
.
activeElement
)
;
let
nextEl
;
if
(
e
.
key
=
=
=
"
ArrowUp
"
)
{
nextEl
=
document
.
activeElement
=
=
=
firstInput
?
lastInput
:
checkboxElements
[
currentIndex
-
1
]
;
}
else
if
(
e
.
key
=
=
=
"
ArrowDown
"
)
{
nextEl
=
document
.
activeElement
=
=
=
lastInput
?
firstInput
:
checkboxElements
[
currentIndex
+
1
]
;
}
nextEl
.
tabIndex
=
0
;
document
.
activeElement
.
tabIndex
=
-
1
;
nextEl
.
focus
(
)
;
}
}
[
]
)
;
(
0
external_React_namespaceObject
.
useEffect
)
(
(
)
=
>
{
const
ref
=
modalRef
.
current
;
ref
.
addEventListener
(
"
keydown
"
handleFocus
)
;
inputRef
.
current
.
tabIndex
=
0
;
return
(
)
=
>
{
ref
.
removeEventListener
(
"
keydown
"
handleFocus
)
;
}
;
}
[
handleFocus
]
)
;
function
handleChange
(
e
)
{
const
topic
=
e
.
target
.
name
;
const
isChecked
=
e
.
target
.
checked
;
if
(
isChecked
)
{
setTopicsToSelect
(
[
.
.
.
topicsToSelect
topic
]
)
;
}
else
{
const
updatedTopics
=
topicsToSelect
.
filter
(
t
=
>
t
!
=
=
topic
)
;
setTopicsToSelect
(
updatedTopics
)
;
}
}
function
handleSubmit
(
)
{
const
topicsString
=
topicsToSelect
.
join
(
"
"
)
;
dispatch
(
actionCreators
.
SetPref
(
"
discoverystream
.
topicSelection
.
selectedTopics
"
topicsString
)
)
;
dispatch
(
actionCreators
.
SetPref
(
"
discoverystream
.
topicSelection
.
onboarding
.
maybeDisplay
"
false
)
)
;
if
(
!
topicsHaveBeenPreviouslySet
)
{
dispatch
(
actionCreators
.
SetPref
(
"
discoverystream
.
topicSelection
.
hasBeenUpdatedPreviously
"
true
)
)
;
}
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
TOPIC_SELECTION_USER_SAVE
data
:
{
topics
:
topicsString
previous_topics
:
selectedTopics
first_save
:
isFirstSave
(
)
}
}
)
)
;
handleModalClose
(
)
;
}
return
external_React_default
(
)
.
createElement
(
ModalOverlayWrapper
{
onClose
:
handleUserClose
innerClassName
:
"
topic
-
selection
-
container
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
topic
-
selection
-
form
"
ref
:
modalRef
}
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
"
dismiss
-
button
"
title
:
"
dismiss
"
onClick
:
handleUserClose
}
)
external_React_default
(
)
.
createElement
(
"
h1
"
{
className
:
"
title
"
"
data
-
l10n
-
id
"
:
"
newtab
-
topic
-
selection
-
title
"
}
)
external_React_default
(
)
.
createElement
(
"
p
"
{
className
:
"
subtitle
"
"
data
-
l10n
-
id
"
:
"
newtab
-
topic
-
selection
-
subtitle
"
}
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
topic
-
list
"
ref
:
checkboxWrapperRef
}
topics
.
map
(
(
topic
i
)
=
>
{
const
checked
=
topicsToSelect
.
includes
(
topic
)
;
return
external_React_default
(
)
.
createElement
(
"
label
"
{
className
:
topic
-
item
key
:
topic
}
external_React_default
(
)
.
createElement
(
"
input
"
{
type
:
"
checkbox
"
id
:
topic
name
:
topic
ref
:
i
=
=
=
0
?
inputRef
:
null
onChange
:
handleChange
checked
:
checked
"
aria
-
checked
"
:
checked
tabIndex
:
-
1
}
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
topic
-
custom
-
checkbox
}
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
topic
-
icon
"
}
EMOJI_LABELS
[
{
topic
}
]
)
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
topic
-
checked
"
}
)
)
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
topic
-
item
-
label
"
"
data
-
l10n
-
id
"
:
newtab
-
topic
-
label
-
{
topic
}
}
)
)
;
}
)
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
modal
-
footer
"
}
external_React_default
(
)
.
createElement
(
"
a
"
{
href
:
supportUrl
"
data
-
l10n
-
id
"
:
"
newtab
-
topic
-
selection
-
privacy
-
link
"
}
)
external_React_default
(
)
.
createElement
(
"
moz
-
button
-
group
"
{
className
:
"
button
-
group
"
}
external_React_default
(
)
.
createElement
(
"
moz
-
button
"
{
id
:
isFirstRun
?
"
first
-
run
"
:
"
"
"
data
-
l10n
-
id
"
:
isFirstRun
?
"
newtab
-
topic
-
selection
-
button
-
maybe
-
later
"
:
"
newtab
-
topic
-
selection
-
cancel
-
button
"
onClick
:
handleUserClose
}
)
external_React_default
(
)
.
createElement
(
"
moz
-
button
"
{
"
data
-
l10n
-
id
"
:
"
newtab
-
topic
-
selection
-
save
-
button
"
type
:
"
primary
"
onClick
:
handleSubmit
}
)
)
)
)
)
;
}
;
const
PREF_MOBILE_DOWNLOAD_HIGHLIGHT_VARIANT_A
=
"
mobileDownloadModal
.
variant
-
a
"
;
const
PREF_MOBILE_DOWNLOAD_HIGHLIGHT_VARIANT_B
=
"
mobileDownloadModal
.
variant
-
b
"
;
const
PREF_MOBILE_DOWNLOAD_HIGHLIGHT_VARIANT_C
=
"
mobileDownloadModal
.
variant
-
c
"
;
const
FEATURE_ID
=
"
FEATURE_DOWNLOAD_MOBILE_PROMO
"
;
function
DownloadMobilePromoHighlight
(
{
position
dispatch
handleDismiss
handleBlock
isIntersecting
}
)
{
const
onDismiss
=
(
0
external_React_namespaceObject
.
useCallback
)
(
(
)
=
>
{
dispatch
(
actionCreators
.
DiscoveryStreamUserEvent
(
{
event
:
"
FEATURE_HIGHLIGHT_DISMISS
"
source
:
"
FEATURE_HIGHLIGHT
"
value
:
{
feature
:
FEATURE_ID
}
}
)
)
;
handleDismiss
(
)
;
handleBlock
(
)
;
}
[
dispatch
handleDismiss
handleBlock
]
)
;
(
0
external_React_namespaceObject
.
useEffect
)
(
(
)
=
>
{
if
(
isIntersecting
)
{
dispatch
(
actionCreators
.
DiscoveryStreamUserEvent
(
{
event
:
"
FEATURE_HIGHLIGHT_IMPRESSION
"
source
:
"
FEATURE_HIGHLIGHT
"
value
:
{
feature
:
FEATURE_ID
}
}
)
)
;
}
}
[
dispatch
isIntersecting
]
)
;
const
prefs
=
(
0
external_ReactRedux_namespaceObject
.
useSelector
)
(
state
=
>
state
.
Prefs
.
values
)
;
const
mobileDownloadPromoVarA
=
prefs
[
PREF_MOBILE_DOWNLOAD_HIGHLIGHT_VARIANT_A
]
;
const
mobileDownloadPromoVarB
=
prefs
[
PREF_MOBILE_DOWNLOAD_HIGHLIGHT_VARIANT_B
]
;
const
mobileDownloadPromoVarC
=
prefs
[
PREF_MOBILE_DOWNLOAD_HIGHLIGHT_VARIANT_C
]
;
function
getActiveVariant
(
)
{
if
(
mobileDownloadPromoVarA
)
{
return
"
A
"
;
}
if
(
mobileDownloadPromoVarB
)
{
return
"
B
"
;
}
if
(
mobileDownloadPromoVarC
)
{
return
"
C
"
;
}
return
null
;
}
function
getVariantQRCodeImg
(
)
{
const
variant
=
getActiveVariant
(
)
;
switch
(
variant
)
{
case
"
A
"
:
return
"
chrome
:
/
/
newtab
/
content
/
data
/
content
/
assets
/
download
-
qr
-
code
-
var
-
a
.
png
"
;
case
"
B
"
:
return
"
chrome
:
/
/
newtab
/
content
/
data
/
content
/
assets
/
download
-
qr
-
code
-
var
-
b
.
png
"
;
case
"
C
"
:
return
"
chrome
:
/
/
newtab
/
content
/
data
/
content
/
assets
/
download
-
qr
-
code
-
var
-
c
.
png
"
;
default
:
return
null
;
}
}
function
getVariantCopy
(
)
{
const
variant
=
getActiveVariant
(
)
;
switch
(
variant
)
{
case
"
A
"
:
return
"
newtab
-
download
-
mobile
-
highlight
-
body
-
variant
-
a
"
;
case
"
B
"
:
return
"
newtab
-
download
-
mobile
-
highlight
-
body
-
variant
-
b
"
;
case
"
C
"
:
return
"
newtab
-
download
-
mobile
-
highlight
-
body
-
variant
-
c
"
;
default
:
return
null
;
}
}
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
download
-
firefox
-
feature
-
highlight
"
}
external_React_default
(
)
.
createElement
(
FeatureHighlight
{
position
:
position
feature
:
FEATURE_ID
dispatch
:
dispatch
message
:
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
download
-
firefox
-
feature
-
highlight
-
content
"
}
external_React_default
(
)
.
createElement
(
"
img
"
{
src
:
getVariantQRCodeImg
(
)
"
data
-
l10n
-
id
"
:
"
newtab
-
download
-
mobile
-
highlight
-
image
"
width
:
"
120
"
height
:
"
191
"
alt
:
"
"
}
)
external_React_default
(
)
.
createElement
(
"
p
"
{
className
:
"
title
"
"
data
-
l10n
-
id
"
:
"
newtab
-
download
-
mobile
-
highlight
-
title
"
}
)
external_React_default
(
)
.
createElement
(
"
p
"
{
className
:
"
subtitle
"
"
data
-
l10n
-
id
"
:
getVariantCopy
(
)
}
)
)
openedOverride
:
true
showButtonIcon
:
false
dismissCallback
:
onDismiss
outsideClickCallback
:
handleDismiss
}
)
)
;
}
;
function
WallpaperFeatureHighlight
(
{
position
dispatch
handleDismiss
handleClick
handleBlock
}
)
{
const
onDismiss
=
(
0
external_React_namespaceObject
.
useCallback
)
(
(
)
=
>
{
handleDismiss
(
)
;
handleBlock
(
)
;
}
[
handleDismiss
handleBlock
]
)
;
const
onToggleClick
=
(
0
external_React_namespaceObject
.
useCallback
)
(
elementId
=
>
{
dispatch
(
{
type
:
actionTypes
.
SHOW_PERSONALIZE
}
)
;
dispatch
(
actionCreators
.
UserEvent
(
{
event
:
"
SHOW_PERSONALIZE
"
}
)
)
;
handleClick
(
elementId
)
;
onDismiss
(
)
;
}
[
dispatch
onDismiss
handleClick
]
)
;
const
{
messageData
}
=
(
0
external_ReactRedux_namespaceObject
.
useSelector
)
(
state
=
>
state
.
Messages
)
;
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
wallpaper
-
feature
-
highlight
"
}
external_React_default
(
)
.
createElement
(
FeatureHighlight
{
position
:
position
"
data
-
l10n
-
id
"
:
"
feature
-
highlight
-
wallpaper
"
feature
:
messageData
.
content
.
feature
dispatch
:
dispatch
message
:
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
wallpaper
-
feature
-
highlight
-
content
"
}
external_React_default
(
)
.
createElement
(
"
img
"
{
src
:
"
chrome
:
/
/
newtab
/
content
/
data
/
content
/
assets
/
custom
-
wp
-
highlight
.
png
"
alt
:
"
"
width
:
"
320
"
height
:
"
195
"
}
)
external_React_default
(
)
.
createElement
(
"
p
"
{
className
:
"
title
"
"
data
-
l10n
-
id
"
:
messageData
.
content
.
title
}
)
external_React_default
(
)
.
createElement
(
"
p
"
{
className
:
"
subtitle
"
"
data
-
l10n
-
id
"
:
messageData
.
content
.
subtitle
}
)
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
button
-
wrapper
"
}
external_React_default
(
)
.
createElement
(
"
moz
-
button
"
{
type
:
"
default
"
onClick
:
(
)
=
>
onToggleClick
(
"
open
-
customize
-
menu
"
)
"
data
-
l10n
-
id
"
:
messageData
.
content
.
cta
}
)
)
)
toggle
:
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
icon
icon
-
help
"
}
)
openedOverride
:
true
showButtonIcon
:
false
dismissCallback
:
onDismiss
outsideClickCallback
:
handleDismiss
}
)
)
;
}
;
function
Base_extends
(
)
{
return
Base_extends
=
Object
.
assign
?
Object
.
assign
.
bind
(
)
:
function
(
n
)
{
for
(
var
e
=
1
;
e
<
arguments
.
length
;
e
+
+
)
{
var
t
=
arguments
[
e
]
;
for
(
var
r
in
t
)
(
{
}
)
.
hasOwnProperty
.
call
(
t
r
)
&
&
(
n
[
r
]
=
t
[
r
]
)
;
}
return
n
;
}
Base_extends
.
apply
(
null
arguments
)
;
}
const
Base_VISIBLE
=
"
visible
"
;
const
Base_VISIBILITY_CHANGE_EVENT
=
"
visibilitychange
"
;
const
Base_PREF_INFERRED_PERSONALIZATION_SYSTEM
=
"
discoverystream
.
sections
.
personalization
.
inferred
.
enabled
"
;
const
Base_PREF_INFERRED_PERSONALIZATION_USER
=
"
discoverystream
.
sections
.
personalization
.
inferred
.
user
.
enabled
"
;
function
Base_debounce
(
func
wait
)
{
let
timer
;
return
(
.
.
.
args
)
=
>
{
if
(
timer
)
{
return
;
}
let
wakeUp
=
(
)
=
>
{
timer
=
null
;
}
;
timer
=
setTimeout
(
wakeUp
wait
)
;
func
.
apply
(
this
args
)
;
}
;
}
class
_Base
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
state
=
{
message
:
{
}
}
;
this
.
notifyContent
=
this
.
notifyContent
.
bind
(
this
)
;
}
notifyContent
(
state
)
{
this
.
setState
(
state
)
;
}
componentWillUnmount
(
)
{
this
.
updateTheme
(
)
;
}
componentWillUpdate
(
)
{
this
.
updateTheme
(
)
;
}
updateTheme
(
)
{
const
bodyClassName
=
[
"
activity
-
stream
"
document
.
body
.
classList
.
contains
(
"
inline
-
onboarding
"
)
?
"
inline
-
onboarding
"
:
"
"
]
.
filter
(
v
=
>
v
)
.
join
(
"
"
)
;
globalThis
.
document
.
body
.
className
=
bodyClassName
;
}
render
(
)
{
const
{
props
}
=
this
;
const
{
App
}
=
props
;
const
isDevtoolsEnabled
=
props
.
Prefs
.
values
[
"
asrouter
.
devtoolsEnabled
"
]
;
if
(
!
App
.
initialized
)
{
return
null
;
}
return
external_React_default
(
)
.
createElement
(
ErrorBoundary
{
className
:
"
base
-
content
-
fallback
"
}
external_React_default
(
)
.
createElement
(
(
external_React_default
(
)
)
.
Fragment
null
external_React_default
(
)
.
createElement
(
BaseContent
Base_extends
(
{
}
this
.
props
{
adminContent
:
this
.
state
}
)
)
isDevtoolsEnabled
?
external_React_default
(
)
.
createElement
(
DiscoveryStreamAdmin
{
notifyContent
:
this
.
notifyContent
}
)
:
null
)
)
;
}
}
class
BaseContent
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
openPreferences
=
this
.
openPreferences
.
bind
(
this
)
;
this
.
openCustomizationMenu
=
this
.
openCustomizationMenu
.
bind
(
this
)
;
this
.
closeCustomizationMenu
=
this
.
closeCustomizationMenu
.
bind
(
this
)
;
this
.
handleOnKeyDown
=
this
.
handleOnKeyDown
.
bind
(
this
)
;
this
.
onWindowScroll
=
Base_debounce
(
this
.
onWindowScroll
.
bind
(
this
)
5
)
;
this
.
setPref
=
this
.
setPref
.
bind
(
this
)
;
this
.
shouldShowOMCHighlight
=
this
.
shouldShowOMCHighlight
.
bind
(
this
)
;
this
.
updateWallpaper
=
this
.
updateWallpaper
.
bind
(
this
)
;
this
.
prefersDarkQuery
=
null
;
this
.
handleColorModeChange
=
this
.
handleColorModeChange
.
bind
(
this
)
;
this
.
shouldDisplayTopicSelectionModal
=
this
.
shouldDisplayTopicSelectionModal
.
bind
(
this
)
;
this
.
toggleDownloadHighlight
=
this
.
toggleDownloadHighlight
.
bind
(
this
)
;
this
.
handleDismissDownloadHighlight
=
this
.
handleDismissDownloadHighlight
.
bind
(
this
)
;
this
.
state
=
{
fixedSearch
:
false
firstVisibleTimestamp
:
null
colorMode
:
"
"
fixedNavStyle
:
{
}
wallpaperTheme
:
"
"
showDownloadHighlightOverride
:
null
}
;
}
setFirstVisibleTimestamp
(
)
{
if
(
!
this
.
state
.
firstVisibleTimestamp
)
{
this
.
setState
(
{
firstVisibleTimestamp
:
Date
.
now
(
)
}
)
;
}
}
componentDidMount
(
)
{
__webpack_require__
.
g
.
addEventListener
(
"
scroll
"
this
.
onWindowScroll
)
;
__webpack_require__
.
g
.
addEventListener
(
"
keydown
"
this
.
handleOnKeyDown
)
;
const
prefs
=
this
.
props
.
Prefs
.
values
;
const
wallpapersEnabled
=
prefs
[
"
newtabWallpapers
.
enabled
"
]
;
if
(
this
.
props
.
document
.
visibilityState
=
=
=
Base_VISIBLE
)
{
this
.
setFirstVisibleTimestamp
(
)
;
this
.
shouldDisplayTopicSelectionModal
(
)
;
}
else
{
this
.
_onVisibilityChange
=
(
)
=
>
{
if
(
this
.
props
.
document
.
visibilityState
=
=
=
Base_VISIBLE
)
{
this
.
setFirstVisibleTimestamp
(
)
;
this
.
shouldDisplayTopicSelectionModal
(
)
;
this
.
props
.
document
.
removeEventListener
(
Base_VISIBILITY_CHANGE_EVENT
this
.
_onVisibilityChange
)
;
this
.
_onVisibilityChange
=
null
;
}
}
;
this
.
props
.
document
.
addEventListener
(
Base_VISIBILITY_CHANGE_EVENT
this
.
_onVisibilityChange
)
;
}
this
.
prefersDarkQuery
=
globalThis
.
matchMedia
(
"
(
prefers
-
color
-
scheme
:
dark
)
"
)
;
this
.
prefersDarkQuery
.
addEventListener
(
"
change
"
this
.
handleColorModeChange
)
;
this
.
handleColorModeChange
(
)
;
if
(
wallpapersEnabled
)
{
this
.
updateWallpaper
(
)
;
}
}
componentDidUpdate
(
prevProps
)
{
const
prefs
=
this
.
props
.
Prefs
.
values
;
const
wallpapersEnabled
=
prefs
[
"
newtabWallpapers
.
enabled
"
]
;
if
(
wallpapersEnabled
)
{
const
{
Wallpapers
:
{
uploadedWallpaper
=
null
wallpaperList
=
null
}
=
{
}
}
=
this
.
props
;
const
{
Wallpapers
:
{
uploadedWallpaper
:
prevUploadedWallpaper
=
null
wallpaperList
:
prevWallpaperList
=
null
}
=
{
}
Prefs
:
{
values
:
prevPrefs
=
{
}
}
=
{
}
}
=
prevProps
;
const
selectedWallpaper
=
prefs
[
"
newtabWallpapers
.
wallpaper
"
]
;
const
prevSelectedWallpaper
=
prevPrefs
[
"
newtabWallpapers
.
wallpaper
"
]
;
if
(
selectedWallpaper
!
=
=
prevSelectedWallpaper
|
|
uploadedWallpaper
!
=
=
prevUploadedWallpaper
|
|
wallpaperList
!
=
=
prevWallpaperList
|
|
this
.
props
.
App
.
isForStartupCache
.
Wallpaper
!
=
=
prevProps
.
App
.
isForStartupCache
.
Wallpaper
)
{
this
.
updateWallpaper
(
)
;
}
}
}
handleColorModeChange
(
)
{
const
colorMode
=
this
.
prefersDarkQuery
?
.
matches
?
"
dark
"
:
"
light
"
;
this
.
setState
(
{
colorMode
}
)
;
}
componentWillUnmount
(
)
{
this
.
prefersDarkQuery
?
.
removeEventListener
(
"
change
"
this
.
handleColorModeChange
)
;
__webpack_require__
.
g
.
removeEventListener
(
"
scroll
"
this
.
onWindowScroll
)
;
__webpack_require__
.
g
.
removeEventListener
(
"
keydown
"
this
.
handleOnKeyDown
)
;
if
(
this
.
_onVisibilityChange
)
{
this
.
props
.
document
.
removeEventListener
(
Base_VISIBILITY_CHANGE_EVENT
this
.
_onVisibilityChange
)
;
}
}
onWindowScroll
(
)
{
if
(
window
.
innerHeight
<
=
700
)
{
return
;
}
const
prefs
=
this
.
props
.
Prefs
.
values
;
const
{
showSearch
}
=
prefs
;
if
(
!
showSearch
)
{
return
;
}
const
logoAlwaysVisible
=
prefs
[
"
logowordmark
.
alwaysVisible
"
]
;
let
SCROLL_THRESHOLD
=
0
;
let
MAIN_OFFSET_PADDING
=
0
;
const
CSS_VAR_SPACE_XXLARGE
=
32
.
04
;
let
layout
=
{
outerWrapperPaddingTop
:
24
searchWrapperPaddingTop
:
16
searchWrapperPaddingBottom
:
CSS_VAR_SPACE_XXLARGE
searchWrapperFixedScrollPaddingTop
:
27
searchWrapperFixedScrollPaddingBottom
:
27
searchInnerWrapperMinHeight
:
52
logoAndWordmarkWrapperHeight
:
0
logoAndWordmarkWrapperMarginBottom
:
0
}
;
if
(
!
logoAlwaysVisible
)
{
layout
.
logoAndWordmarkWrapperHeight
=
0
;
layout
.
logoAndWordmarkWrapperMarginBottom
=
0
;
}
SCROLL_THRESHOLD
=
layout
.
outerWrapperPaddingTop
+
layout
.
searchWrapperPaddingTop
+
layout
.
logoAndWordmarkWrapperHeight
+
layout
.
logoAndWordmarkWrapperMarginBottom
-
layout
.
searchWrapperFixedScrollPaddingTop
;
MAIN_OFFSET_PADDING
=
layout
.
searchWrapperPaddingTop
+
layout
.
searchWrapperPaddingBottom
+
layout
.
searchInnerWrapperMinHeight
+
layout
.
logoAndWordmarkWrapperHeight
+
layout
.
logoAndWordmarkWrapperMarginBottom
;
if
(
SCROLL_THRESHOLD
<
1
)
{
SCROLL_THRESHOLD
=
1
;
}
if
(
__webpack_require__
.
g
.
scrollY
>
SCROLL_THRESHOLD
&
&
!
this
.
state
.
fixedSearch
)
{
this
.
setState
(
{
fixedSearch
:
true
fixedNavStyle
:
{
paddingBlockStart
:
{
MAIN_OFFSET_PADDING
}
px
}
}
)
;
}
else
if
(
__webpack_require__
.
g
.
scrollY
<
=
SCROLL_THRESHOLD
&
&
this
.
state
.
fixedSearch
)
{
this
.
setState
(
{
fixedSearch
:
false
fixedNavStyle
:
{
}
}
)
;
}
}
openPreferences
(
)
{
this
.
props
.
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
SETTINGS_OPEN
}
)
)
;
this
.
props
.
dispatch
(
actionCreators
.
UserEvent
(
{
event
:
"
OPEN_NEWTAB_PREFS
"
}
)
)
;
}
openCustomizationMenu
(
)
{
this
.
props
.
dispatch
(
{
type
:
actionTypes
.
SHOW_PERSONALIZE
}
)
;
this
.
props
.
dispatch
(
actionCreators
.
UserEvent
(
{
event
:
"
SHOW_PERSONALIZE
"
}
)
)
;
}
closeCustomizationMenu
(
)
{
if
(
this
.
props
.
App
.
customizeMenuVisible
)
{
this
.
props
.
dispatch
(
{
type
:
actionTypes
.
HIDE_PERSONALIZE
}
)
;
this
.
props
.
dispatch
(
actionCreators
.
UserEvent
(
{
event
:
"
HIDE_PERSONALIZE
"
}
)
)
;
}
}
handleOnKeyDown
(
e
)
{
if
(
e
.
key
=
=
=
"
Escape
"
)
{
this
.
closeCustomizationMenu
(
)
;
}
}
setPref
(
pref
value
)
{
this
.
props
.
dispatch
(
actionCreators
.
SetPref
(
pref
value
)
)
;
}
renderWallpaperAttribution
(
)
{
const
{
wallpaperList
}
=
this
.
props
.
Wallpapers
;
const
activeWallpaper
=
this
.
props
.
Prefs
.
values
[
newtabWallpapers
.
wallpaper
]
;
const
selected
=
wallpaperList
.
find
(
wp
=
>
wp
.
title
=
=
=
activeWallpaper
)
;
if
(
!
selected
?
.
attribution
)
{
return
null
;
}
const
{
name
:
authorDetails
webpage
}
=
selected
.
attribution
;
if
(
activeWallpaper
&
&
wallpaperList
&
&
authorDetails
.
url
)
{
return
external_React_default
(
)
.
createElement
(
"
p
"
{
className
:
wallpaper
-
attribution
key
:
authorDetails
.
string
"
data
-
l10n
-
id
"
:
"
newtab
-
wallpaper
-
attribution
"
"
data
-
l10n
-
args
"
:
JSON
.
stringify
(
{
author_string
:
authorDetails
.
string
author_url
:
authorDetails
.
url
webpage_string
:
webpage
.
string
webpage_url
:
webpage
.
url
}
)
}
external_React_default
(
)
.
createElement
(
"
a
"
{
"
data
-
l10n
-
name
"
:
"
name
-
link
"
href
:
authorDetails
.
url
}
authorDetails
.
string
)
external_React_default
(
)
.
createElement
(
"
a
"
{
"
data
-
l10n
-
name
"
:
"
webpage
-
link
"
href
:
webpage
.
url
}
webpage
.
string
)
)
;
}
return
null
;
}
async
updateWallpaper
(
)
{
const
prefs
=
this
.
props
.
Prefs
.
values
;
const
selectedWallpaper
=
prefs
[
"
newtabWallpapers
.
wallpaper
"
]
;
const
{
wallpaperList
uploadedWallpaper
:
uploadedWallpaperUrl
}
=
this
.
props
.
Wallpapers
;
let
lightWallpaper
=
{
}
;
let
darkWallpaper
=
{
}
;
if
(
selectedWallpaper
=
=
=
"
custom
"
&
&
uploadedWallpaperUrl
)
{
try
{
__webpack_require__
.
g
.
document
?
.
body
.
style
.
setProperty
(
"
-
-
newtab
-
wallpaper
"
url
(
{
uploadedWallpaperUrl
}
)
)
;
__webpack_require__
.
g
.
document
?
.
body
.
style
.
setProperty
(
"
-
-
newtab
-
wallpaper
-
color
"
"
transparent
"
)
;
if
(
this
.
state
.
colorMode
)
{
this
.
setState
(
prevState
=
>
(
{
wallpaperTheme
:
prevState
.
colorMode
}
)
)
;
}
}
catch
(
e
)
{
}
return
;
}
if
(
wallpaperList
)
{
let
wallpaper
=
wallpaperList
.
find
(
wp
=
>
wp
.
title
=
=
=
selectedWallpaper
)
;
if
(
selectedWallpaper
&
&
wallpaper
)
{
lightWallpaper
=
wallpaper
;
darkWallpaper
=
wallpaper
;
}
const
regexRGB
=
/
#
(
[
a
-
fA
-
F0
-
9
]
{
6
}
)
/
;
if
(
selectedWallpaper
.
includes
(
"
solid
-
color
-
picker
"
)
)
{
wallpaper
=
{
theme
:
wallpaper
?
.
theme
|
|
"
light
"
title
:
"
solid
-
color
-
picker
"
category
:
"
solid
-
colors
"
solid_color
:
selectedWallpaper
.
match
(
regexRGB
)
?
.
[
0
]
}
;
}
const
wallpaperColor
=
wallpaper
?
.
solid_color
|
|
"
"
;
__webpack_require__
.
g
.
document
?
.
body
.
style
.
setProperty
(
"
-
-
newtab
-
wallpaper
"
url
(
{
wallpaper
?
.
wallpaperUrl
|
|
"
"
}
)
)
;
__webpack_require__
.
g
.
document
?
.
body
.
style
.
setProperty
(
"
-
-
newtab
-
wallpaper
-
color
"
wallpaperColor
|
|
"
transparent
"
)
;
let
wallpaperTheme
=
"
"
;
if
(
wallpaperColor
)
{
const
rgbColors
=
this
.
getRGBColors
(
wallpaperColor
)
;
const
isColorDark
=
this
.
isWallpaperColorDark
(
rgbColors
)
;
wallpaperTheme
=
isColorDark
?
"
dark
"
:
"
light
"
;
}
else
{
const
{
theme
}
=
this
.
state
.
colorMode
=
=
=
"
light
"
?
lightWallpaper
:
darkWallpaper
;
if
(
theme
)
{
wallpaperTheme
=
theme
;
}
}
this
.
setState
(
{
wallpaperTheme
}
)
;
}
}
shouldShowOMCHighlight
(
componentId
)
{
const
messageData
=
this
.
props
.
Messages
?
.
messageData
;
if
(
!
messageData
|
|
Object
.
keys
(
messageData
)
.
length
=
=
=
0
)
{
return
false
;
}
return
messageData
?
.
content
?
.
messageType
=
=
=
componentId
;
}
toggleDownloadHighlight
(
)
{
this
.
setState
(
prevState
=
>
{
const
override
=
!
(
prevState
.
showDownloadHighlightOverride
?
?
this
.
shouldShowOMCHighlight
(
"
DownloadMobilePromoHighlight
"
)
)
;
if
(
override
)
{
this
.
props
.
dispatch
(
actionCreators
.
DiscoveryStreamUserEvent
(
{
event
:
"
FEATURE_HIGHLIGHT_OPEN
"
source
:
"
FEATURE_HIGHLIGHT
"
value
:
{
feature
:
"
FEATURE_DOWNLOAD_MOBILE_PROMO
"
}
}
)
)
;
}
return
{
showDownloadHighlightOverride
:
override
}
;
}
)
;
}
handleDismissDownloadHighlight
(
)
{
this
.
setState
(
{
showDownloadHighlightOverride
:
false
}
)
;
}
getRGBColors
(
input
)
{
if
(
input
.
length
!
=
=
7
)
{
return
[
]
;
}
const
r
=
parseInt
(
input
.
substr
(
1
2
)
16
)
;
const
g
=
parseInt
(
input
.
substr
(
3
2
)
16
)
;
const
b
=
parseInt
(
input
.
substr
(
5
2
)
16
)
;
return
[
r
g
b
]
;
}
isWallpaperColorDark
(
[
r
g
b
]
)
{
return
0
.
2125
*
r
+
0
.
7154
*
g
+
0
.
0721
*
b
<
=
110
;
}
shouldDisplayTopicSelectionModal
(
)
{
const
prefs
=
this
.
props
.
Prefs
.
values
;
const
pocketEnabled
=
prefs
[
"
feeds
.
section
.
topstories
"
]
&
&
prefs
[
"
feeds
.
system
.
topstories
"
]
;
const
topicSelectionOnboardingEnabled
=
prefs
[
"
discoverystream
.
topicSelection
.
onboarding
.
enabled
"
]
&
&
pocketEnabled
;
const
maybeShowModal
=
prefs
[
"
discoverystream
.
topicSelection
.
onboarding
.
maybeDisplay
"
]
;
const
displayTimeout
=
prefs
[
"
discoverystream
.
topicSelection
.
onboarding
.
displayTimeout
"
]
;
const
lastDisplayed
=
prefs
[
"
discoverystream
.
topicSelection
.
onboarding
.
lastDisplayed
"
]
;
const
displayCount
=
prefs
[
"
discoverystream
.
topicSelection
.
onboarding
.
displayCount
"
]
;
if
(
!
maybeShowModal
|
|
!
prefs
[
"
discoverystream
.
topicSelection
.
enabled
"
]
|
|
!
topicSelectionOnboardingEnabled
)
{
return
;
}
const
day
=
24
*
60
*
60
*
1000
;
const
now
=
new
Date
(
)
.
getTime
(
)
;
const
timeoutOccured
=
now
-
parseFloat
(
lastDisplayed
)
>
displayTimeout
;
if
(
displayCount
<
3
)
{
if
(
displayCount
=
=
=
0
|
|
timeoutOccured
)
{
this
.
props
.
dispatch
(
actionCreators
.
BroadcastToContent
(
{
type
:
actionTypes
.
TOPIC_SELECTION_SPOTLIGHT_OPEN
}
)
)
;
this
.
setPref
(
"
discoverystream
.
topicSelection
.
onboarding
.
displayTimeout
"
day
)
;
}
}
}
render
(
)
{
const
{
props
}
=
this
;
const
{
App
DiscoveryStream
}
=
props
;
const
{
initialized
customizeMenuVisible
}
=
App
;
const
prefs
=
props
.
Prefs
.
values
;
const
activeWallpaper
=
prefs
[
newtabWallpapers
.
wallpaper
]
;
const
wallpapersEnabled
=
prefs
[
"
newtabWallpapers
.
enabled
"
]
;
const
weatherEnabled
=
prefs
.
showWeather
;
const
{
showTopicSelection
}
=
DiscoveryStream
;
const
mayShowTopicSelection
=
showTopicSelection
&
&
prefs
[
"
discoverystream
.
topicSelection
.
enabled
"
]
;
const
{
pocketConfig
}
=
prefs
;
const
isDiscoveryStream
=
props
.
DiscoveryStream
.
config
&
&
props
.
DiscoveryStream
.
config
.
enabled
;
let
filteredSections
=
props
.
Sections
.
filter
(
section
=
>
section
.
id
!
=
=
"
topstories
"
)
;
let
spocMessageVariant
=
"
"
;
if
(
props
.
App
.
locale
?
.
startsWith
(
"
en
-
"
)
&
&
pocketConfig
?
.
spocMessageVariant
=
=
=
"
variant
-
c
"
)
{
spocMessageVariant
=
pocketConfig
.
spocMessageVariant
;
}
const
pocketEnabled
=
prefs
[
"
feeds
.
section
.
topstories
"
]
&
&
prefs
[
"
feeds
.
system
.
topstories
"
]
;
const
noSectionsEnabled
=
!
prefs
[
"
feeds
.
topsites
"
]
&
&
!
pocketEnabled
&
&
filteredSections
.
filter
(
section
=
>
section
.
enabled
)
.
length
=
=
=
0
;
const
searchHandoffEnabled
=
prefs
[
"
improvesearch
.
handoffToAwesomebar
"
]
;
const
enabledSections
=
{
topSitesEnabled
:
prefs
[
"
feeds
.
topsites
"
]
pocketEnabled
:
prefs
[
"
feeds
.
section
.
topstories
"
]
showInferredPersonalizationEnabled
:
prefs
[
Base_PREF_INFERRED_PERSONALIZATION_USER
]
showRecentSavesEnabled
:
prefs
.
showRecentSaves
topSitesRowsCount
:
prefs
.
topSitesRows
weatherEnabled
:
prefs
.
showWeather
trendingSearchEnabled
:
prefs
[
"
trendingSearch
.
enabled
"
]
}
;
const
pocketRegion
=
prefs
[
"
feeds
.
system
.
topstories
"
]
;
const
mayHaveSponsoredStories
=
prefs
[
"
system
.
showSponsored
"
]
;
const
mayHaveInferredPersonalization
=
prefs
[
Base_PREF_INFERRED_PERSONALIZATION_SYSTEM
]
;
const
mayHaveWeather
=
prefs
[
"
system
.
showWeather
"
]
;
const
{
mayHaveSponsoredTopSites
}
=
prefs
;
const
supportUrl
=
prefs
[
"
support
.
url
"
]
;
const
mayHaveWidgets
=
prefs
[
"
widgets
.
system
.
enabled
"
]
;
const
mayHaveListsWidget
=
prefs
[
"
widgets
.
system
.
lists
.
enabled
"
]
;
const
mayHaveTimerWidget
=
prefs
[
"
widgets
.
system
.
focusTimer
.
enabled
"
]
;
const
enabledWidgets
=
{
listsEnabled
:
prefs
[
"
widgets
.
lists
.
enabled
"
]
timerEnabled
:
prefs
[
"
widgets
.
focusTimer
.
enabled
"
]
trendingSearchEnabled
:
prefs
[
"
trendingSearch
.
enabled
"
]
weatherEnabled
:
prefs
.
showWeather
}
;
const
mayHaveTrendingSearch
=
prefs
[
"
system
.
trendingSearch
.
enabled
"
]
&
&
prefs
[
"
trendingSearch
.
defaultSearchEngine
"
]
.
toLowerCase
(
)
=
=
=
"
google
"
;
const
mobileDownloadPromoEnabled
=
prefs
[
"
mobileDownloadModal
.
enabled
"
]
;
const
mobileDownloadPromoVariantAEnabled
=
prefs
[
"
mobileDownloadModal
.
variant
-
a
"
]
;
const
mobileDownloadPromoVariantBEnabled
=
prefs
[
"
mobileDownloadModal
.
variant
-
b
"
]
;
const
mobileDownloadPromoVariantCEnabled
=
prefs
[
"
mobileDownloadModal
.
variant
-
c
"
]
;
const
mobileDownloadPromoVariantABorC
=
mobileDownloadPromoVariantAEnabled
|
|
mobileDownloadPromoVariantBEnabled
|
|
mobileDownloadPromoVariantCEnabled
;
const
mobileDownloadPromoWrapperHeightModifier
=
prefs
[
"
weather
.
display
"
]
=
=
=
"
detailed
"
&
&
weatherEnabled
&
&
mayHaveWeather
?
"
is
-
tall
"
:
"
"
;
const
hasThumbsUpDownLayout
=
prefs
[
"
discoverystream
.
thumbsUpDown
.
searchTopsitesCompact
"
]
;
const
hasThumbsUpDown
=
prefs
[
"
discoverystream
.
thumbsUpDown
.
enabled
"
]
;
const
sectionsEnabled
=
prefs
[
"
discoverystream
.
sections
.
enabled
"
]
;
const
topicLabelsEnabled
=
prefs
[
"
discoverystream
.
topicLabels
.
enabled
"
]
;
const
sectionsCustomizeMenuPanelEnabled
=
prefs
[
"
discoverystream
.
sections
.
customizeMenuPanel
.
enabled
"
]
;
const
sectionsPersonalizationEnabled
=
prefs
[
"
discoverystream
.
sections
.
personalization
.
enabled
"
]
;
const
mayHavePersonalizedTopicSections
=
sectionsPersonalizationEnabled
&
&
topicLabelsEnabled
&
&
sectionsEnabled
&
&
sectionsCustomizeMenuPanelEnabled
&
&
DiscoveryStream
.
feeds
.
loaded
;
const
featureClassName
=
[
mobileDownloadPromoEnabled
&
&
mobileDownloadPromoVariantABorC
&
&
"
has
-
mobile
-
download
-
promo
"
weatherEnabled
&
&
mayHaveWeather
&
&
"
has
-
weather
"
prefs
.
showSearch
?
"
has
-
search
"
:
"
no
-
search
"
pocketEnabled
?
"
has
-
recommended
-
stories
"
:
"
no
-
recommended
-
stories
"
sectionsEnabled
?
"
has
-
sections
-
grid
"
:
"
"
]
.
filter
(
v
=
>
v
)
.
join
(
"
"
)
;
const
outerClassName
=
[
"
outer
-
wrapper
"
isDiscoveryStream
&
&
pocketEnabled
&
&
"
ds
-
outer
-
wrapper
-
search
-
alignment
"
isDiscoveryStream
&
&
"
ds
-
outer
-
wrapper
-
breakpoint
-
override
"
prefs
.
showSearch
&
&
this
.
state
.
fixedSearch
&
&
!
noSectionsEnabled
&
&
"
fixed
-
search
"
prefs
.
showSearch
&
&
noSectionsEnabled
&
&
"
only
-
search
"
prefs
[
"
feeds
.
topsites
"
]
&
&
!
pocketEnabled
&
&
!
prefs
.
showSearch
&
&
"
only
-
topsites
"
noSectionsEnabled
&
&
"
no
-
sections
"
prefs
[
"
logowordmark
.
alwaysVisible
"
]
&
&
"
visible
-
logo
"
hasThumbsUpDownLayout
&
&
hasThumbsUpDown
&
&
"
thumbs
-
ui
-
compact
"
]
.
filter
(
v
=
>
v
)
.
join
(
"
"
)
;
if
(
wallpapersEnabled
)
{
if
(
this
.
state
.
wallpaperTheme
=
=
=
"
light
"
)
{
__webpack_require__
.
g
.
document
?
.
body
.
classList
.
add
(
"
lightWallpaper
"
)
;
__webpack_require__
.
g
.
document
?
.
body
.
classList
.
remove
(
"
darkWallpaper
"
)
;
}
if
(
this
.
state
.
wallpaperTheme
=
=
=
"
dark
"
)
{
__webpack_require__
.
g
.
document
?
.
body
.
classList
.
add
(
"
darkWallpaper
"
)
;
__webpack_require__
.
g
.
document
?
.
body
.
classList
.
remove
(
"
lightWallpaper
"
)
;
}
}
const
shouldShowDownloadHighlight
=
this
.
state
.
showDownloadHighlightOverride
?
?
this
.
shouldShowOMCHighlight
(
"
DownloadMobilePromoHighlight
"
)
;
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
featureClassName
}
external_React_default
(
)
.
createElement
(
"
menu
"
{
className
:
"
personalizeButtonWrapper
"
}
external_React_default
(
)
.
createElement
(
CustomizeMenu
{
onClose
:
this
.
closeCustomizationMenu
onOpen
:
this
.
openCustomizationMenu
openPreferences
:
this
.
openPreferences
setPref
:
this
.
setPref
enabledSections
:
enabledSections
enabledWidgets
:
enabledWidgets
wallpapersEnabled
:
wallpapersEnabled
activeWallpaper
:
activeWallpaper
pocketRegion
:
pocketRegion
mayHaveTopicSections
:
mayHavePersonalizedTopicSections
mayHaveSponsoredTopSites
:
mayHaveSponsoredTopSites
mayHaveSponsoredStories
:
mayHaveSponsoredStories
mayHaveInferredPersonalization
:
mayHaveInferredPersonalization
mayHaveWeather
:
mayHaveWeather
mayHaveTrendingSearch
:
mayHaveTrendingSearch
mayHaveWidgets
:
mayHaveWidgets
mayHaveTimerWidget
:
mayHaveTimerWidget
mayHaveListsWidget
:
mayHaveListsWidget
spocMessageVariant
:
spocMessageVariant
showing
:
customizeMenuVisible
}
)
this
.
shouldShowOMCHighlight
(
"
CustomWallpaperHighlight
"
)
&
&
external_React_default
(
)
.
createElement
(
MessageWrapper
{
dispatch
:
this
.
props
.
dispatch
}
external_React_default
(
)
.
createElement
(
WallpaperFeatureHighlight
{
position
:
"
inset
-
block
-
start
inset
-
inline
-
start
"
dispatch
:
this
.
props
.
dispatch
}
)
)
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
weatherWrapper
"
}
weatherEnabled
&
&
external_React_default
(
)
.
createElement
(
ErrorBoundary
null
external_React_default
(
)
.
createElement
(
Weather_Weather
null
)
)
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
mobileDownloadPromoWrapper
{
mobileDownloadPromoWrapperHeightModifier
}
}
mobileDownloadPromoEnabled
&
&
mobileDownloadPromoVariantABorC
&
&
external_React_default
(
)
.
createElement
(
ErrorBoundary
null
external_React_default
(
)
.
createElement
(
DownloadModalToggle
{
isActive
:
shouldShowDownloadHighlight
onClick
:
this
.
toggleDownloadHighlight
}
)
shouldShowDownloadHighlight
&
&
external_React_default
(
)
.
createElement
(
MessageWrapper
{
hiddenOverride
:
shouldShowDownloadHighlight
onDismiss
:
this
.
handleDismissDownloadHighlight
dispatch
:
this
.
props
.
dispatch
}
external_React_default
(
)
.
createElement
(
DownloadMobilePromoHighlight
{
position
:
inset
-
inline
-
start
inset
-
block
-
end
dispatch
:
this
.
props
.
dispatch
}
)
)
)
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
outerClassName
onClick
:
this
.
closeCustomizationMenu
}
external_React_default
(
)
.
createElement
(
"
main
"
{
className
:
"
newtab
-
main
"
style
:
this
.
state
.
fixedNavStyle
}
prefs
.
showSearch
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
non
-
collapsible
-
section
"
}
external_React_default
(
)
.
createElement
(
ErrorBoundary
null
external_React_default
(
)
.
createElement
(
Search_Search
Base_extends
(
{
showLogo
:
noSectionsEnabled
|
|
prefs
[
"
logowordmark
.
alwaysVisible
"
]
handoffEnabled
:
searchHandoffEnabled
}
props
.
Search
)
)
)
)
!
prefs
.
showSearch
&
&
!
noSectionsEnabled
&
&
external_React_default
(
)
.
createElement
(
Logo
null
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
body
-
wrapper
{
initialized
?
"
on
"
:
"
"
}
}
isDiscoveryStream
?
external_React_default
(
)
.
createElement
(
ErrorBoundary
{
className
:
"
borderless
-
error
"
}
external_React_default
(
)
.
createElement
(
DiscoveryStreamBase
{
locale
:
props
.
App
.
locale
mayHaveSponsoredStories
:
mayHaveSponsoredStories
firstVisibleTimestamp
:
this
.
state
.
firstVisibleTimestamp
}
)
)
:
external_React_default
(
)
.
createElement
(
Sections_Sections
null
)
)
external_React_default
(
)
.
createElement
(
ConfirmDialog
null
)
wallpapersEnabled
&
&
this
.
renderWallpaperAttribution
(
)
)
external_React_default
(
)
.
createElement
(
"
aside
"
null
this
.
props
.
Notifications
?
.
showNotifications
&
&
external_React_default
(
)
.
createElement
(
ErrorBoundary
null
external_React_default
(
)
.
createElement
(
Notifications_Notifications
{
dispatch
:
this
.
props
.
dispatch
}
)
)
)
mayShowTopicSelection
&
&
pocketEnabled
&
&
external_React_default
(
)
.
createElement
(
TopicSelection
{
supportUrl
:
supportUrl
}
)
)
)
;
}
}
BaseContent
.
defaultProps
=
{
document
:
__webpack_require__
.
g
.
document
}
;
const
Base
=
(
0
external_ReactRedux_namespaceObject
.
connect
)
(
state
=
>
(
{
App
:
state
.
App
Prefs
:
state
.
Prefs
Sections
:
state
.
Sections
DiscoveryStream
:
state
.
DiscoveryStream
Messages
:
state
.
Messages
Notifications
:
state
.
Notifications
Search
:
state
.
Search
Wallpapers
:
state
.
Wallpapers
Weather
:
state
.
Weather
}
)
)
(
_Base
)
;
;
const
detect_user_session_start_VISIBLE
=
"
visible
"
;
const
detect_user_session_start_VISIBILITY_CHANGE_EVENT
=
"
visibilitychange
"
;
class
DetectUserSessionStart
{
constructor
(
store
options
=
{
}
)
{
this
.
_store
=
store
;
this
.
document
=
options
.
document
|
|
globalThis
.
document
;
this
.
_perfService
=
options
.
perfService
|
|
perfService
;
this
.
_onVisibilityChange
=
this
.
_onVisibilityChange
.
bind
(
this
)
;
}
sendEventOrAddListener
(
)
{
if
(
this
.
document
.
visibilityState
=
=
=
detect_user_session_start_VISIBLE
)
{
this
.
_sendEvent
(
)
;
}
else
{
this
.
document
.
addEventListener
(
detect_user_session_start_VISIBILITY_CHANGE_EVENT
this
.
_onVisibilityChange
)
;
}
}
_sendEvent
(
)
{
this
.
_perfService
.
mark
(
"
visibility_event_rcvd_ts
"
)
;
try
{
let
visibility_event_rcvd_ts
=
this
.
_perfService
.
getMostRecentAbsMarkStartByName
(
"
visibility_event_rcvd_ts
"
)
;
this
.
_store
.
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
SAVE_SESSION_PERF_DATA
data
:
{
visibility_event_rcvd_ts
window_inner_width
:
window
.
innerWidth
window_inner_height
:
window
.
innerHeight
}
}
)
)
;
}
catch
(
ex
)
{
}
}
_onVisibilityChange
(
)
{
if
(
this
.
document
.
visibilityState
=
=
=
detect_user_session_start_VISIBLE
)
{
this
.
_sendEvent
(
)
;
this
.
document
.
removeEventListener
(
detect_user_session_start_VISIBILITY_CHANGE_EVENT
this
.
_onVisibilityChange
)
;
}
}
}
;
const
external_Redux_namespaceObject
=
Redux
;
;
const
MERGE_STORE_ACTION
=
"
NEW_TAB_INITIAL_STATE
"
;
const
OUTGOING_MESSAGE_NAME
=
"
ActivityStream
:
ContentToMain
"
;
const
INCOMING_MESSAGE_NAME
=
"
ActivityStream
:
MainToContent
"
;
function
mergeStateReducer
(
mainReducer
)
{
return
(
prevState
action
)
=
>
{
if
(
action
.
type
=
=
=
MERGE_STORE_ACTION
)
{
return
{
.
.
.
prevState
.
.
.
action
.
data
}
;
}
return
mainReducer
(
prevState
action
)
;
}
;
}
const
messageMiddleware
=
(
)
=
>
next
=
>
action
=
>
{
const
skipLocal
=
action
.
meta
&
&
action
.
meta
.
skipLocal
;
if
(
actionUtils
.
isSendToMain
(
action
)
)
{
RPMSendAsyncMessage
(
OUTGOING_MESSAGE_NAME
action
)
;
}
if
(
!
skipLocal
)
{
next
(
action
)
;
}
}
;
const
rehydrationMiddleware
=
(
{
getState
}
)
=
>
{
getState
.
didRehydrate
=
false
;
getState
.
didRequestInitialState
=
false
;
return
next
=
>
action
=
>
{
if
(
getState
.
didRehydrate
|
|
window
.
__FROM_STARTUP_CACHE__
)
{
if
(
window
.
__FROM_STARTUP_CACHE__
&
&
action
.
meta
&
&
action
.
meta
.
isStartup
)
{
return
null
;
}
return
next
(
action
)
;
}
const
isMergeStoreAction
=
action
.
type
=
=
=
MERGE_STORE_ACTION
;
const
isRehydrationRequest
=
action
.
type
=
=
=
actionTypes
.
NEW_TAB_STATE_REQUEST
;
if
(
isRehydrationRequest
)
{
getState
.
didRequestInitialState
=
true
;
return
next
(
action
)
;
}
if
(
isMergeStoreAction
)
{
getState
.
didRehydrate
=
true
;
return
next
(
action
)
;
}
if
(
getState
.
didRequestInitialState
&
&
action
.
type
=
=
=
actionTypes
.
INIT
)
{
return
next
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
NEW_TAB_STATE_REQUEST
}
)
)
;
}
if
(
actionUtils
.
isBroadcastToContent
(
action
)
|
|
actionUtils
.
isSendToOneContent
(
action
)
|
|
actionUtils
.
isSendToPreloaded
(
action
)
)
{
return
null
;
}
return
next
(
action
)
;
}
;
}
;
function
initStore
(
reducers
initialState
)
{
const
store
=
(
0
external_Redux_namespaceObject
.
createStore
)
(
mergeStateReducer
(
(
0
external_Redux_namespaceObject
.
combineReducers
)
(
reducers
)
)
initialState
globalThis
.
RPMAddMessageListener
&
&
(
0
external_Redux_namespaceObject
.
applyMiddleware
)
(
rehydrationMiddleware
messageMiddleware
)
)
;
if
(
globalThis
.
RPMAddMessageListener
)
{
globalThis
.
RPMAddMessageListener
(
INCOMING_MESSAGE_NAME
msg
=
>
{
try
{
store
.
dispatch
(
msg
.
data
)
;
}
catch
(
ex
)
{
console
.
error
(
"
Content
msg
:
"
msg
"
Dispatch
error
:
"
ex
)
;
dump
(
Content
msg
:
{
JSON
.
stringify
(
msg
)
}
\
nDispatch
error
:
{
ex
}
\
n
{
ex
.
stack
}
)
;
}
}
)
;
}
return
store
;
}
;
const
external_ReactDOM_namespaceObject
=
ReactDOM
;
var
external_ReactDOM_default
=
__webpack_require__
.
n
(
external_ReactDOM_namespaceObject
)
;
;
const
NewTab
=
(
{
store
}
)
=
>
external_React_default
(
)
.
createElement
(
external_ReactRedux_namespaceObject
.
Provider
{
store
:
store
}
external_React_default
(
)
.
createElement
(
Base
null
)
)
;
function
doRequestWhenReady
(
)
{
const
doRequestPromise
=
new
Promise
(
resolve
=
>
{
let
didRequest
=
false
;
let
requestIdleCallbackId
=
0
;
function
doRequest
(
)
{
if
(
!
didRequest
)
{
if
(
requestIdleCallbackId
)
{
cancelIdleCallback
(
requestIdleCallbackId
)
;
}
didRequest
=
true
;
resolve
(
)
;
}
}
if
(
document
.
hidden
)
{
requestIdleCallbackId
=
requestIdleCallback
(
doRequest
)
;
addEventListener
(
"
visibilitychange
"
doRequest
{
once
:
true
}
)
;
}
else
{
resolve
(
)
;
}
}
)
;
return
doRequestPromise
;
}
function
renderWithoutState
(
)
{
const
store
=
initStore
(
reducers
)
;
new
DetectUserSessionStart
(
store
)
.
sendEventOrAddListener
(
)
;
doRequestWhenReady
(
)
.
then
(
(
)
=
>
{
store
.
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
NEW_TAB_STATE_REQUEST
}
)
)
;
store
.
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
NEW_TAB_STATE_REQUEST_WITHOUT_STARTUPCACHE
}
)
)
;
}
)
;
external_ReactDOM_default
(
)
.
hydrate
(
external_React_default
(
)
.
createElement
(
NewTab
{
store
:
store
}
)
document
.
getElementById
(
"
root
"
)
)
;
}
function
renderCache
(
initialState
)
{
if
(
initialState
)
{
initialState
.
App
.
isForStartupCache
.
App
=
false
;
}
const
store
=
initStore
(
reducers
initialState
)
;
new
DetectUserSessionStart
(
store
)
.
sendEventOrAddListener
(
)
;
doRequestWhenReady
(
)
.
then
(
(
)
=
>
{
store
.
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
NEW_TAB_STATE_REQUEST_STARTUPCACHE
}
)
)
;
}
)
;
external_ReactDOM_default
(
)
.
hydrate
(
external_React_default
(
)
.
createElement
(
NewTab
{
store
:
store
}
)
document
.
getElementById
(
"
root
"
)
)
;
}
NewtabRenderUtils
=
__webpack_exports__
;
}
)
(
)
;
