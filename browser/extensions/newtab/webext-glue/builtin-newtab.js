"
use
strict
"
;
const
{
AppConstants
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
sys
.
mjs
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
resProto
"
"
mozilla
.
org
/
network
/
protocol
;
1
?
name
=
resource
"
"
nsISubstitutingProtocolHandler
"
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineESModuleGetters
(
lazy
{
AboutHomeStartupCache
:
"
resource
:
/
/
/
modules
/
AboutHomeStartupCache
.
sys
.
mjs
"
}
)
;
const
ResourceSubstitution
=
"
newtab
"
;
this
.
builtin_newtab
=
class
extends
ExtensionAPI
{
#
chromeHandle
=
null
;
onStartup
(
)
{
if
(
!
AppConstants
.
BROWSER_NEWTAB_AS_ADDON
)
{
return
;
}
const
{
rootURI
}
=
this
.
extension
;
resProto
.
setSubstitutionWithFlags
(
ResourceSubstitution
rootURI
Ci
.
nsISubstitutingProtocolHandler
.
ALLOW_CONTENT_ACCESS
)
;
let
aomStartup
=
Cc
[
"
mozilla
.
org
/
addons
/
addon
-
manager
-
startup
;
1
"
]
.
getService
(
Ci
.
amIAddonManagerStartup
)
;
const
manifestURI
=
Services
.
io
.
newURI
(
"
manifest
.
json
"
null
this
.
extension
.
rootURI
)
;
this
.
#
chromeHandle
=
aomStartup
.
registerChrome
(
manifestURI
[
[
"
content
"
"
newtab
"
"
data
/
content
"
"
contentaccessible
=
yes
"
]
]
)
;
let
redirector
=
Cc
[
"
mozilla
.
org
/
network
/
protocol
/
about
;
1
?
what
=
newtab
"
]
.
getService
(
Ci
.
nsIAboutModule
)
.
wrappedJSObject
;
redirector
.
builtInAddonInitialized
(
)
;
}
onShutdown
(
)
{
if
(
!
AppConstants
.
BROWSER_NEWTAB_AS_ADDON
)
{
return
;
}
resProto
.
setSubstitution
(
ResourceSubstitution
null
)
;
this
.
#
chromeHandle
.
destruct
(
)
;
this
.
#
chromeHandle
=
null
;
}
getAPI
(
_context
)
{
return
{
builtin
:
{
newtab
:
{
handleUpdateAvailable
(
)
{
lazy
.
AboutHomeStartupCache
.
clearCacheAndUninit
(
)
;
}
}
}
}
;
}
}
;
