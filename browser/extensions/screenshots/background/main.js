"
use
strict
"
;
this
.
main
=
(
function
(
)
{
const
exports
=
{
}
;
const
pngToJpegCutoff
=
2500000
;
const
{
sendEvent
incrementCount
}
=
analytics
;
const
manifest
=
browser
.
runtime
.
getManifest
(
)
;
let
backend
;
exports
.
setBackend
=
function
(
newBackend
)
{
backend
=
newBackend
;
backend
=
backend
.
replace
(
/
\
/
*
/
"
"
)
;
}
;
exports
.
getBackend
=
function
(
)
{
return
backend
;
}
;
communication
.
register
(
"
getBackend
"
(
)
=
>
{
return
backend
;
}
)
;
for
(
const
permission
of
manifest
.
permissions
)
{
if
(
/
^
https
?
:
\
/
\
/
/
.
test
(
permission
)
)
{
exports
.
setBackend
(
permission
)
;
break
;
}
}
function
setIconActive
(
active
)
{
let
windowIDPromise
=
browser
.
windows
.
getLastFocused
(
)
.
then
(
windowInfo
=
>
{
return
windowInfo
.
id
;
}
)
;
windowIDPromise
.
then
(
id
=
>
{
return
browser
.
experiments
.
screenshots
.
setIcon
(
active
id
)
;
}
)
;
}
function
toggleSelector
(
tab
)
{
return
analytics
.
refreshTelemetryPref
(
)
.
then
(
(
)
=
>
selectorLoader
.
toggle
(
tab
.
id
)
)
.
then
(
active
=
>
{
setIconActive
(
active
)
;
return
active
;
}
)
.
catch
(
error
=
>
{
if
(
error
.
message
&
&
/
Missing
host
permission
for
the
tab
/
.
test
(
error
.
message
)
)
{
error
.
noReport
=
true
;
}
error
.
popupMessage
=
"
UNSHOOTABLE_PAGE
"
;
throw
error
;
}
)
;
}
exports
.
onClicked
=
catcher
.
watchFunction
(
tab
=
>
{
_startShotFlow
(
tab
"
toolbar
-
button
"
)
;
}
)
;
exports
.
onClickedContextMenu
=
catcher
.
watchFunction
(
tab
=
>
{
_startShotFlow
(
tab
"
context
-
menu
"
)
;
}
)
;
exports
.
onCommand
=
catcher
.
watchFunction
(
tab
=
>
{
_startShotFlow
(
tab
"
keyboard
-
shortcut
"
)
;
}
)
;
const
_startShotFlow
=
(
tab
inputType
)
=
>
{
if
(
!
tab
)
{
return
;
}
if
(
!
urlEnabled
(
tab
.
url
)
)
{
senderror
.
showError
(
{
popupMessage
:
"
UNSHOOTABLE_PAGE
"
}
)
;
return
;
}
catcher
.
watchPromise
(
toggleSelector
(
tab
)
.
then
(
active
=
>
{
let
event
=
"
start
-
shot
"
;
if
(
inputType
!
=
=
"
context
-
menu
"
)
{
event
=
active
?
"
start
-
shot
"
:
"
cancel
-
shot
"
;
}
sendEvent
(
event
inputType
{
incognito
:
tab
.
incognito
}
)
;
}
)
.
catch
(
error
=
>
{
throw
error
;
}
)
)
;
}
;
function
urlEnabled
(
url
)
{
if
(
url
&
&
url
.
startsWith
(
"
about
:
reader
?
url
=
"
)
)
{
return
true
;
}
if
(
isShotOrMyShotPage
(
url
)
|
|
/
^
(
?
:
about
|
data
|
moz
-
extension
)
:
/
i
.
test
(
url
)
|
|
isBlacklistedUrl
(
url
)
)
{
return
false
;
}
return
true
;
}
function
isShotOrMyShotPage
(
url
)
{
if
(
!
url
.
startsWith
(
backend
)
)
{
return
false
;
}
const
path
=
url
.
substr
(
backend
.
length
)
.
replace
(
/
^
\
/
*
/
"
"
)
.
replace
(
/
[
?
#
]
.
*
/
"
"
)
;
if
(
path
=
=
=
"
shots
"
)
{
return
true
;
}
if
(
/
^
[
^
/
]
{
1
4000
}
\
/
[
^
/
]
{
1
4000
}
/
.
test
(
path
)
)
{
return
true
;
}
return
false
;
}
function
isBlacklistedUrl
(
url
)
{
const
badDomains
=
[
"
testpilot
.
firefox
.
com
"
]
;
let
domain
=
url
.
replace
(
/
^
https
?
:
\
/
\
/
/
i
"
"
)
;
domain
=
domain
.
replace
(
/
\
/
.
*
/
"
"
)
.
replace
(
/
:
.
*
/
"
"
)
;
domain
=
domain
.
toLowerCase
(
)
;
return
badDomains
.
includes
(
domain
)
;
}
communication
.
register
(
"
getStrings
"
(
sender
ids
)
=
>
{
return
getStrings
(
ids
.
map
(
id
=
>
(
{
id
}
)
)
)
;
}
)
;
communication
.
register
(
"
sendEvent
"
(
sender
.
.
.
args
)
=
>
{
catcher
.
watchPromise
(
sendEvent
(
.
.
.
args
)
)
;
return
null
;
}
)
;
communication
.
register
(
"
captureTelemetry
"
(
sender
.
.
.
args
)
=
>
{
catcher
.
watchPromise
(
incrementCount
(
.
.
.
args
)
)
;
}
)
;
communication
.
register
(
"
openShot
"
async
(
sender
{
url
copied
}
)
=
>
{
if
(
copied
)
{
const
id
=
makeUuid
(
)
;
const
[
title
message
]
=
await
getStrings
(
[
{
id
:
"
screenshots
-
notification
-
link
-
copied
-
title
"
}
{
id
:
"
screenshots
-
notification
-
link
-
copied
-
details
"
}
]
)
;
return
browser
.
notifications
.
create
(
id
{
type
:
"
basic
"
iconUrl
:
"
chrome
:
/
/
browser
/
content
/
screenshots
/
copied
-
notification
.
svg
"
title
message
}
)
;
}
return
null
;
}
)
;
communication
.
register
(
"
canvasToDataURL
"
(
sender
imageData
)
=
>
{
const
canvas
=
document
.
createElement
(
"
canvas
"
)
;
canvas
.
width
=
imageData
.
width
;
canvas
.
height
=
imageData
.
height
;
canvas
.
getContext
(
"
2d
"
)
.
putImageData
(
imageData
0
0
)
;
let
dataUrl
=
canvas
.
toDataURL
(
)
;
if
(
dataUrl
.
length
>
pngToJpegCutoff
)
{
const
jpegDataUrl
=
canvas
.
toDataURL
(
"
image
/
jpeg
"
)
;
if
(
jpegDataUrl
.
length
<
dataUrl
.
length
)
{
dataUrl
=
jpegDataUrl
;
}
}
return
dataUrl
;
}
)
;
communication
.
register
(
"
copyShotToClipboard
"
async
(
sender
blob
)
=
>
{
let
buffer
=
await
blobConverters
.
blobToArray
(
blob
)
;
await
browser
.
clipboard
.
setImageData
(
buffer
blob
.
type
.
split
(
"
/
"
2
)
[
1
]
)
;
const
[
title
message
]
=
await
getStrings
(
[
{
id
:
"
screenshots
-
notification
-
image
-
copied
-
title
"
}
{
id
:
"
screenshots
-
notification
-
image
-
copied
-
details
"
}
]
)
;
catcher
.
watchPromise
(
incrementCount
(
"
copy
"
)
)
;
return
browser
.
notifications
.
create
(
{
type
:
"
basic
"
iconUrl
:
"
chrome
:
/
/
browser
/
content
/
screenshots
/
copied
-
notification
.
svg
"
title
message
}
)
;
}
)
;
communication
.
register
(
"
downloadShot
"
(
sender
info
)
=
>
{
const
blob
=
blobConverters
.
dataUrlToBlob
(
info
.
url
)
;
const
url
=
URL
.
createObjectURL
(
blob
)
;
let
downloadId
;
const
onChangedCallback
=
catcher
.
watchFunction
(
function
(
change
)
{
if
(
!
downloadId
|
|
downloadId
!
=
=
change
.
id
)
{
return
;
}
if
(
change
.
state
&
&
change
.
state
.
current
!
=
=
"
in_progress
"
)
{
URL
.
revokeObjectURL
(
url
)
;
browser
.
downloads
.
onChanged
.
removeListener
(
onChangedCallback
)
;
}
}
)
;
browser
.
downloads
.
onChanged
.
addListener
(
onChangedCallback
)
;
catcher
.
watchPromise
(
incrementCount
(
"
download
"
)
)
;
return
browser
.
windows
.
getLastFocused
(
)
.
then
(
windowInfo
=
>
{
return
browser
.
downloads
.
download
(
{
url
incognito
:
windowInfo
.
incognito
filename
:
info
.
filename
}
)
.
catch
(
error
=
>
{
if
(
error
&
&
error
.
message
&
&
!
error
.
message
.
includes
(
"
canceled
"
)
)
{
log
.
error
(
error
.
message
)
;
}
}
)
.
then
(
id
=
>
{
downloadId
=
id
;
}
)
;
}
)
;
}
)
;
communication
.
register
(
"
closeSelector
"
sender
=
>
{
setIconActive
(
false
)
;
}
)
;
communication
.
register
(
"
abortStartShot
"
(
)
=
>
{
senderror
.
showError
(
{
popupMessage
:
"
UNSHOOTABLE_PAGE
"
}
)
;
}
)
;
communication
.
register
(
"
requestOnboarding
"
sender
=
>
{
return
startSelectionWithOnboarding
(
sender
.
tab
)
;
}
)
;
communication
.
register
(
"
getPlatformOs
"
(
)
=
>
{
return
catcher
.
watchPromise
(
browser
.
runtime
.
getPlatformInfo
(
)
.
then
(
platformInfo
=
>
{
return
platformInfo
.
os
;
}
)
)
;
}
)
;
communication
.
register
(
"
showNotification
"
(
sender
notification
)
=
>
{
return
browser
.
notifications
.
create
(
notification
)
;
}
)
;
return
exports
;
}
)
(
)
;
