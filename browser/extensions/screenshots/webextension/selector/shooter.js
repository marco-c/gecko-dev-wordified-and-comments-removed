"
use
strict
"
;
this
.
shooter
=
(
function
(
)
{
let
exports
=
{
}
;
const
{
AbstractShot
}
=
shot
;
const
RANDOM_STRING_LENGTH
=
16
;
let
backend
;
let
shotObject
;
let
supportsDrawWindow
;
const
callBackground
=
global
.
callBackground
;
const
clipboard
=
global
.
clipboard
;
function
regexpEscape
(
str
)
{
return
str
.
replace
(
/
[
-
[
\
]
{
}
(
)
*
+
?
.
\
\
^
|
#
\
s
]
/
g
"
\
\
&
"
)
;
}
function
sanitizeError
(
data
)
{
const
href
=
new
RegExp
(
regexpEscape
(
window
.
location
.
href
)
'
g
'
)
;
const
origin
=
new
RegExp
(
{
regexpEscape
(
window
.
location
.
origin
)
}
[
^
\
t
\
n
\
r
"
>
]
*
'
g
'
)
;
const
json
=
JSON
.
stringify
(
data
)
.
replace
(
href
'
REDACTED_HREF
'
)
.
replace
(
origin
'
REDACTED_URL
'
)
;
const
result
=
JSON
.
parse
(
json
)
;
return
result
;
}
catcher
.
registerHandler
(
(
errorObj
)
=
>
{
callBackground
(
"
reportError
"
sanitizeError
(
errorObj
)
)
;
}
)
;
catcher
.
watchFunction
(
(
)
=
>
{
let
canvas
=
document
.
createElementNS
(
'
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
'
'
canvas
'
)
;
let
ctx
=
canvas
.
getContext
(
'
2d
'
)
;
supportsDrawWindow
=
!
!
ctx
.
drawWindow
;
}
)
(
)
;
let
screenshotPage
=
exports
.
screenshotPage
=
function
(
selectedPos
captureType
)
{
if
(
!
supportsDrawWindow
)
{
return
null
;
}
let
height
=
selectedPos
.
bottom
-
selectedPos
.
top
;
let
width
=
selectedPos
.
right
-
selectedPos
.
left
;
let
canvas
=
document
.
createElementNS
(
'
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
'
'
canvas
'
)
;
let
ctx
=
canvas
.
getContext
(
'
2d
'
)
;
let
expand
=
window
.
devicePixelRatio
!
=
=
1
;
if
(
captureType
=
=
'
fullPage
'
|
|
captureType
=
=
'
fullPageTruncated
'
)
{
expand
=
false
;
canvas
.
width
=
width
;
canvas
.
height
=
height
;
}
else
{
canvas
.
width
=
width
*
window
.
devicePixelRatio
;
canvas
.
height
=
height
*
window
.
devicePixelRatio
;
}
if
(
expand
)
{
ctx
.
scale
(
window
.
devicePixelRatio
window
.
devicePixelRatio
)
;
}
ui
.
iframe
.
hide
(
)
;
ctx
.
drawWindow
(
window
selectedPos
.
left
selectedPos
.
top
width
height
"
#
fff
"
)
;
let
limit
=
buildSettings
.
pngToJpegCutoff
;
let
dataUrl
=
canvas
.
toDataURL
(
)
;
if
(
limit
&
&
dataUrl
.
length
>
limit
)
{
let
jpegDataUrl
=
canvas
.
toDataURL
(
"
image
/
jpeg
"
)
;
if
(
jpegDataUrl
.
length
<
dataUrl
.
length
)
{
dataUrl
=
jpegDataUrl
;
}
}
return
dataUrl
;
}
;
let
isSaving
=
null
;
exports
.
takeShot
=
function
(
captureType
selectedPos
url
)
{
if
(
Math
.
floor
(
selectedPos
.
left
)
=
=
Math
.
floor
(
selectedPos
.
right
)
|
|
Math
.
floor
(
selectedPos
.
top
)
=
=
Math
.
floor
(
selectedPos
.
bottom
)
)
{
let
exc
=
new
Error
(
"
Empty
selection
"
)
;
exc
.
popupMessage
=
"
EMPTY_SELECTION
"
;
exc
.
noReport
=
true
;
catcher
.
unhandled
(
exc
)
;
return
;
}
let
imageBlob
;
const
uicontrol
=
global
.
uicontrol
;
let
deactivateAfterFinish
=
true
;
if
(
isSaving
)
{
return
;
}
isSaving
=
setTimeout
(
(
)
=
>
{
if
(
typeof
ui
!
=
=
"
undefined
"
)
{
ui
.
Box
.
clearSaveDisabled
(
)
;
}
isSaving
=
null
;
}
1000
)
;
selectedPos
=
selectedPos
.
asJson
(
)
;
let
captureText
=
"
"
;
if
(
buildSettings
.
captureText
)
{
captureText
=
util
.
captureEnclosedText
(
selectedPos
)
;
}
let
dataUrl
=
url
|
|
screenshotPage
(
selectedPos
captureType
)
;
let
type
=
blobConverters
.
getTypeFromDataUrl
(
dataUrl
)
;
type
=
type
?
type
.
split
(
"
/
"
2
)
[
1
]
:
null
;
if
(
dataUrl
)
{
imageBlob
=
blobConverters
.
dataUrlToBlob
(
dataUrl
)
;
shotObject
.
delAllClips
(
)
;
shotObject
.
addClip
(
{
createdDate
:
Date
.
now
(
)
image
:
{
url
:
"
data
:
"
type
captureType
text
:
captureText
location
:
selectedPos
dimensions
:
{
x
:
selectedPos
.
right
-
selectedPos
.
left
y
:
selectedPos
.
bottom
-
selectedPos
.
top
}
}
}
)
;
}
catcher
.
watchPromise
(
callBackground
(
"
takeShot
"
{
captureType
captureText
scroll
:
{
scrollX
:
window
.
scrollX
scrollY
:
window
.
scrollY
innerHeight
:
window
.
innerHeight
innerWidth
:
window
.
innerWidth
}
selectedPos
shotId
:
shotObject
.
id
shot
:
shotObject
.
asJson
(
)
imageBlob
}
)
.
then
(
(
url
)
=
>
{
return
clipboard
.
copy
(
url
)
.
then
(
(
copied
)
=
>
{
return
callBackground
(
"
openShot
"
{
url
copied
}
)
;
}
)
;
}
(
error
)
=
>
{
if
(
'
popupMessage
'
in
error
&
&
(
error
.
popupMessage
=
=
"
REQUEST_ERROR
"
|
|
error
.
popupMessage
=
=
'
CONNECTION_ERROR
'
)
)
{
deactivateAfterFinish
=
false
;
ui
.
iframe
.
unhide
(
)
;
return
;
}
if
(
error
.
name
!
=
"
BackgroundError
"
)
{
throw
error
;
}
}
)
.
then
(
(
)
=
>
{
if
(
deactivateAfterFinish
)
{
uicontrol
.
deactivate
(
)
;
}
}
)
)
;
}
;
exports
.
downloadShot
=
function
(
selectedPos
previewDataUrl
)
{
let
dataUrl
=
previewDataUrl
|
|
screenshotPage
(
selectedPos
)
;
let
promise
=
Promise
.
resolve
(
dataUrl
)
;
if
(
!
dataUrl
)
{
promise
=
callBackground
(
"
screenshotPage
"
selectedPos
.
asJson
(
)
{
scrollX
:
window
.
scrollX
scrollY
:
window
.
scrollY
innerHeight
:
window
.
innerHeight
innerWidth
:
window
.
innerWidth
}
)
;
}
catcher
.
watchPromise
(
promise
.
then
(
(
dataUrl
)
=
>
{
let
type
=
blobConverters
.
getTypeFromDataUrl
(
dataUrl
)
;
type
=
type
?
type
.
split
(
"
/
"
2
)
[
1
]
:
null
;
shotObject
.
delAllClips
(
)
;
shotObject
.
addClip
(
{
createdDate
:
Date
.
now
(
)
image
:
{
url
:
dataUrl
type
location
:
selectedPos
}
}
)
;
ui
.
triggerDownload
(
dataUrl
shotObject
.
filename
)
;
uicontrol
.
deactivate
(
)
;
}
)
)
;
}
;
let
copyInProgress
=
null
;
exports
.
copyShot
=
function
(
selectedPos
previewDataUrl
)
{
if
(
copyInProgress
)
{
return
;
}
copyInProgress
=
setTimeout
(
(
)
=
>
{
copyInProgress
=
null
;
}
5000
)
;
let
unsetCopyInProgress
=
(
)
=
>
{
if
(
copyInProgress
)
{
clearTimeout
(
copyInProgress
)
;
copyInProgress
=
null
;
}
}
let
dataUrl
=
previewDataUrl
|
|
screenshotPage
(
selectedPos
)
;
let
blob
=
blobConverters
.
dataUrlToBlob
(
dataUrl
)
;
catcher
.
watchPromise
(
callBackground
(
"
copyShotToClipboard
"
blob
)
.
then
(
(
)
=
>
{
uicontrol
.
deactivate
(
)
;
unsetCopyInProgress
(
)
;
}
unsetCopyInProgress
)
)
;
}
;
exports
.
sendEvent
=
function
(
.
.
.
args
)
{
let
maybeOptions
=
args
[
args
.
length
-
1
]
;
if
(
typeof
maybeOptions
=
=
=
"
object
"
)
{
maybeOptions
.
incognito
=
browser
.
extension
.
inIncognitoContext
;
}
else
{
args
.
push
(
{
incognito
:
browser
.
extension
.
inIncognitoContext
}
)
;
}
callBackground
(
"
sendEvent
"
.
.
.
args
)
;
}
;
catcher
.
watchFunction
(
(
)
=
>
{
shotObject
=
new
AbstractShot
(
backend
randomString
(
RANDOM_STRING_LENGTH
)
+
"
/
"
+
domainFromUrl
(
location
)
{
origin
:
shot
.
originFromUrl
(
location
.
href
)
}
)
;
shotObject
.
update
(
documentMetadata
(
)
)
;
}
)
(
)
;
return
exports
;
}
)
(
)
;
null
;
