(
function
(
f
)
{
if
(
typeof
exports
=
=
=
"
object
"
&
&
typeof
module
!
=
=
"
undefined
"
)
{
module
.
exports
=
f
(
)
}
else
if
(
typeof
define
=
=
=
"
function
"
&
&
define
.
amd
)
{
define
(
[
]
f
)
}
else
{
var
g
;
if
(
typeof
window
!
=
=
"
undefined
"
)
{
g
=
window
}
else
if
(
typeof
global
!
=
=
"
undefined
"
)
{
g
=
global
}
else
if
(
typeof
self
!
=
=
"
undefined
"
)
{
g
=
self
}
else
{
g
=
this
}
g
.
Raven
=
f
(
)
}
}
)
(
function
(
)
{
var
define
module
exports
;
return
(
function
e
(
t
n
r
)
{
function
s
(
o
u
)
{
if
(
!
n
[
o
]
)
{
if
(
!
t
[
o
]
)
{
var
a
=
typeof
require
=
=
"
function
"
&
&
require
;
if
(
!
u
&
&
a
)
return
a
(
o
!
0
)
;
if
(
i
)
return
i
(
o
!
0
)
;
var
f
=
new
Error
(
"
Cannot
find
module
'
"
+
o
+
"
'
"
)
;
throw
f
.
code
=
"
MODULE_NOT_FOUND
"
f
}
var
l
=
n
[
o
]
=
{
exports
:
{
}
}
;
t
[
o
]
[
0
]
.
call
(
l
.
exports
function
(
e
)
{
var
n
=
t
[
o
]
[
1
]
[
e
]
;
return
s
(
n
?
n
:
e
)
}
l
l
.
exports
e
t
n
r
)
}
return
n
[
o
]
.
exports
}
var
i
=
typeof
require
=
=
"
function
"
&
&
require
;
for
(
var
o
=
0
;
o
<
r
.
length
;
o
+
+
)
s
(
r
[
o
]
)
;
return
s
}
)
(
{
1
:
[
function
(
_dereq_
module
exports
)
{
function
RavenConfigError
(
message
)
{
this
.
name
=
'
RavenConfigError
'
;
this
.
message
=
message
;
}
RavenConfigError
.
prototype
=
new
Error
(
)
;
RavenConfigError
.
prototype
.
constructor
=
RavenConfigError
;
module
.
exports
=
RavenConfigError
;
}
{
}
]
2
:
[
function
(
_dereq_
module
exports
)
{
var
utils
=
_dereq_
(
5
)
;
var
wrapMethod
=
function
(
console
level
callback
)
{
var
originalConsoleLevel
=
console
[
level
]
;
var
originalConsole
=
console
;
if
(
!
(
level
in
console
)
)
{
return
;
}
var
sentryLevel
=
level
=
=
=
'
warn
'
?
'
warning
'
:
level
;
console
[
level
]
=
function
(
)
{
var
args
=
[
]
.
slice
.
call
(
arguments
)
;
var
msg
=
utils
.
safeJoin
(
args
'
'
)
;
var
data
=
{
level
:
sentryLevel
logger
:
'
console
'
extra
:
{
arguments
:
args
}
}
;
if
(
level
=
=
=
'
assert
'
)
{
if
(
args
[
0
]
=
=
=
false
)
{
msg
=
'
Assertion
failed
:
'
+
(
utils
.
safeJoin
(
args
.
slice
(
1
)
'
'
)
|
|
'
console
.
assert
'
)
;
data
.
extra
.
arguments
=
args
.
slice
(
1
)
;
callback
&
&
callback
(
msg
data
)
;
}
}
else
{
callback
&
&
callback
(
msg
data
)
;
}
if
(
originalConsoleLevel
)
{
Function
.
prototype
.
apply
.
call
(
originalConsoleLevel
originalConsole
args
)
;
}
}
;
}
;
module
.
exports
=
{
wrapMethod
:
wrapMethod
}
;
}
{
"
5
"
:
5
}
]
3
:
[
function
(
_dereq_
module
exports
)
{
(
function
(
global
)
{
var
TraceKit
=
_dereq_
(
6
)
;
var
stringify
=
_dereq_
(
7
)
;
var
md5
=
_dereq_
(
8
)
;
var
RavenConfigError
=
_dereq_
(
1
)
;
var
utils
=
_dereq_
(
5
)
;
var
isError
=
utils
.
isError
;
var
isObject
=
utils
.
isObject
;
var
isPlainObject
=
utils
.
isPlainObject
;
var
isErrorEvent
=
utils
.
isErrorEvent
;
var
isUndefined
=
utils
.
isUndefined
;
var
isFunction
=
utils
.
isFunction
;
var
isString
=
utils
.
isString
;
var
isArray
=
utils
.
isArray
;
var
isEmptyObject
=
utils
.
isEmptyObject
;
var
each
=
utils
.
each
;
var
objectMerge
=
utils
.
objectMerge
;
var
truncate
=
utils
.
truncate
;
var
objectFrozen
=
utils
.
objectFrozen
;
var
hasKey
=
utils
.
hasKey
;
var
joinRegExp
=
utils
.
joinRegExp
;
var
urlencode
=
utils
.
urlencode
;
var
uuid4
=
utils
.
uuid4
;
var
htmlTreeAsString
=
utils
.
htmlTreeAsString
;
var
isSameException
=
utils
.
isSameException
;
var
isSameStacktrace
=
utils
.
isSameStacktrace
;
var
parseUrl
=
utils
.
parseUrl
;
var
fill
=
utils
.
fill
;
var
supportsFetch
=
utils
.
supportsFetch
;
var
supportsReferrerPolicy
=
utils
.
supportsReferrerPolicy
;
var
serializeKeysForMessage
=
utils
.
serializeKeysForMessage
;
var
serializeException
=
utils
.
serializeException
;
var
sanitize
=
utils
.
sanitize
;
var
wrapConsoleMethod
=
_dereq_
(
2
)
.
wrapMethod
;
var
dsnKeys
=
'
source
protocol
user
pass
host
port
path
'
.
split
(
'
'
)
dsnPattern
=
/
^
(
?
:
(
\
w
+
)
:
)
?
\
/
\
/
(
?
:
(
\
w
+
)
(
:
\
w
+
)
?
)
?
(
[
\
w
\
.
-
]
+
)
(
?
:
:
(
\
d
+
)
)
?
(
\
/
.
*
)
/
;
function
now
(
)
{
return
+
new
Date
(
)
;
}
var
_window
=
typeof
window
!
=
=
'
undefined
'
?
window
:
typeof
global
!
=
=
'
undefined
'
?
global
:
typeof
self
!
=
=
'
undefined
'
?
self
:
{
}
;
var
_document
=
_window
.
document
;
var
_navigator
=
_window
.
navigator
;
function
keepOriginalCallback
(
original
callback
)
{
return
isFunction
(
callback
)
?
function
(
data
)
{
return
callback
(
data
original
)
;
}
:
callback
;
}
function
Raven
(
)
{
this
.
_hasJSON
=
!
!
(
typeof
JSON
=
=
=
'
object
'
&
&
JSON
.
stringify
)
;
this
.
_hasDocument
=
!
isUndefined
(
_document
)
;
this
.
_hasNavigator
=
!
isUndefined
(
_navigator
)
;
this
.
_lastCapturedException
=
null
;
this
.
_lastData
=
null
;
this
.
_lastEventId
=
null
;
this
.
_globalServer
=
null
;
this
.
_globalKey
=
null
;
this
.
_globalProject
=
null
;
this
.
_globalContext
=
{
}
;
this
.
_globalOptions
=
{
release
:
_window
.
SENTRY_RELEASE
&
&
_window
.
SENTRY_RELEASE
.
id
logger
:
'
javascript
'
ignoreErrors
:
[
]
ignoreUrls
:
[
]
whitelistUrls
:
[
]
includePaths
:
[
]
headers
:
null
collectWindowErrors
:
true
captureUnhandledRejections
:
true
maxMessageLength
:
0
maxUrlLength
:
250
stackTraceLimit
:
50
autoBreadcrumbs
:
true
instrument
:
true
sampleRate
:
1
sanitizeKeys
:
[
]
}
;
this
.
_fetchDefaults
=
{
method
:
'
POST
'
keepalive
:
true
referrerPolicy
:
supportsReferrerPolicy
(
)
?
'
origin
'
:
'
'
}
;
this
.
_ignoreOnError
=
0
;
this
.
_isRavenInstalled
=
false
;
this
.
_originalErrorStackTraceLimit
=
Error
.
stackTraceLimit
;
this
.
_originalConsole
=
_window
.
console
|
|
{
}
;
this
.
_originalConsoleMethods
=
{
}
;
this
.
_plugins
=
[
]
;
this
.
_startTime
=
now
(
)
;
this
.
_wrappedBuiltIns
=
[
]
;
this
.
_breadcrumbs
=
[
]
;
this
.
_lastCapturedEvent
=
null
;
this
.
_keypressTimeout
;
this
.
_location
=
_window
.
location
;
this
.
_lastHref
=
this
.
_location
&
&
this
.
_location
.
href
;
this
.
_resetBackoff
(
)
;
for
(
var
method
in
this
.
_originalConsole
)
{
this
.
_originalConsoleMethods
[
method
]
=
this
.
_originalConsole
[
method
]
;
}
}
Raven
.
prototype
=
{
VERSION
:
'
3
.
24
.
1
'
debug
:
false
TraceKit
:
TraceKit
config
:
function
(
dsn
options
)
{
var
self
=
this
;
if
(
self
.
_globalServer
)
{
this
.
_logDebug
(
'
error
'
'
Error
:
Raven
has
already
been
configured
'
)
;
return
self
;
}
if
(
!
dsn
)
return
self
;
var
globalOptions
=
self
.
_globalOptions
;
if
(
options
)
{
each
(
options
function
(
key
value
)
{
if
(
key
=
=
=
'
tags
'
|
|
key
=
=
=
'
extra
'
|
|
key
=
=
=
'
user
'
)
{
self
.
_globalContext
[
key
]
=
value
;
}
else
{
globalOptions
[
key
]
=
value
;
}
}
)
;
}
self
.
setDSN
(
dsn
)
;
globalOptions
.
ignoreErrors
.
push
(
/
^
Script
error
\
.
?
/
)
;
globalOptions
.
ignoreErrors
.
push
(
/
^
Javascript
error
:
Script
error
\
.
?
on
line
0
/
)
;
globalOptions
.
ignoreErrors
=
joinRegExp
(
globalOptions
.
ignoreErrors
)
;
globalOptions
.
ignoreUrls
=
globalOptions
.
ignoreUrls
.
length
?
joinRegExp
(
globalOptions
.
ignoreUrls
)
:
false
;
globalOptions
.
whitelistUrls
=
globalOptions
.
whitelistUrls
.
length
?
joinRegExp
(
globalOptions
.
whitelistUrls
)
:
false
;
globalOptions
.
includePaths
=
joinRegExp
(
globalOptions
.
includePaths
)
;
globalOptions
.
maxBreadcrumbs
=
Math
.
max
(
0
Math
.
min
(
globalOptions
.
maxBreadcrumbs
|
|
100
100
)
)
;
var
autoBreadcrumbDefaults
=
{
xhr
:
true
console
:
true
dom
:
true
location
:
true
sentry
:
true
}
;
var
autoBreadcrumbs
=
globalOptions
.
autoBreadcrumbs
;
if
(
{
}
.
toString
.
call
(
autoBreadcrumbs
)
=
=
=
'
[
object
Object
]
'
)
{
autoBreadcrumbs
=
objectMerge
(
autoBreadcrumbDefaults
autoBreadcrumbs
)
;
}
else
if
(
autoBreadcrumbs
!
=
=
false
)
{
autoBreadcrumbs
=
autoBreadcrumbDefaults
;
}
globalOptions
.
autoBreadcrumbs
=
autoBreadcrumbs
;
var
instrumentDefaults
=
{
tryCatch
:
true
}
;
var
instrument
=
globalOptions
.
instrument
;
if
(
{
}
.
toString
.
call
(
instrument
)
=
=
=
'
[
object
Object
]
'
)
{
instrument
=
objectMerge
(
instrumentDefaults
instrument
)
;
}
else
if
(
instrument
!
=
=
false
)
{
instrument
=
instrumentDefaults
;
}
globalOptions
.
instrument
=
instrument
;
TraceKit
.
collectWindowErrors
=
!
!
globalOptions
.
collectWindowErrors
;
return
self
;
}
install
:
function
(
)
{
var
self
=
this
;
if
(
self
.
isSetup
(
)
&
&
!
self
.
_isRavenInstalled
)
{
TraceKit
.
report
.
subscribe
(
function
(
)
{
self
.
_handleOnErrorStackInfo
.
apply
(
self
arguments
)
;
}
)
;
if
(
self
.
_globalOptions
.
captureUnhandledRejections
)
{
self
.
_attachPromiseRejectionHandler
(
)
;
}
self
.
_patchFunctionToString
(
)
;
if
(
self
.
_globalOptions
.
instrument
&
&
self
.
_globalOptions
.
instrument
.
tryCatch
)
{
self
.
_instrumentTryCatch
(
)
;
}
if
(
self
.
_globalOptions
.
autoBreadcrumbs
)
self
.
_instrumentBreadcrumbs
(
)
;
self
.
_drainPlugins
(
)
;
self
.
_isRavenInstalled
=
true
;
}
Error
.
stackTraceLimit
=
self
.
_globalOptions
.
stackTraceLimit
;
return
this
;
}
setDSN
:
function
(
dsn
)
{
var
self
=
this
uri
=
self
.
_parseDSN
(
dsn
)
lastSlash
=
uri
.
path
.
lastIndexOf
(
'
/
'
)
path
=
uri
.
path
.
substr
(
1
lastSlash
)
;
self
.
_dsn
=
dsn
;
self
.
_globalKey
=
uri
.
user
;
self
.
_globalSecret
=
uri
.
pass
&
&
uri
.
pass
.
substr
(
1
)
;
self
.
_globalProject
=
uri
.
path
.
substr
(
lastSlash
+
1
)
;
self
.
_globalServer
=
self
.
_getGlobalServer
(
uri
)
;
self
.
_globalEndpoint
=
self
.
_globalServer
+
'
/
'
+
path
+
'
api
/
'
+
self
.
_globalProject
+
'
/
store
/
'
;
this
.
_resetBackoff
(
)
;
}
context
:
function
(
options
func
args
)
{
if
(
isFunction
(
options
)
)
{
args
=
func
|
|
[
]
;
func
=
options
;
options
=
undefined
;
}
return
this
.
wrap
(
options
func
)
.
apply
(
this
args
)
;
}
wrap
:
function
(
options
func
_before
)
{
var
self
=
this
;
if
(
isUndefined
(
func
)
&
&
!
isFunction
(
options
)
)
{
return
options
;
}
if
(
isFunction
(
options
)
)
{
func
=
options
;
options
=
undefined
;
}
if
(
!
isFunction
(
func
)
)
{
return
func
;
}
try
{
if
(
func
.
__raven__
)
{
return
func
;
}
if
(
func
.
__raven_wrapper__
)
{
return
func
.
__raven_wrapper__
;
}
}
catch
(
e
)
{
return
func
;
}
function
wrapped
(
)
{
var
args
=
[
]
i
=
arguments
.
length
deep
=
!
options
|
|
(
options
&
&
options
.
deep
!
=
=
false
)
;
if
(
_before
&
&
isFunction
(
_before
)
)
{
_before
.
apply
(
this
arguments
)
;
}
while
(
i
-
-
)
args
[
i
]
=
deep
?
self
.
wrap
(
options
arguments
[
i
]
)
:
arguments
[
i
]
;
try
{
return
func
.
apply
(
this
args
)
;
}
catch
(
e
)
{
self
.
_ignoreNextOnError
(
)
;
self
.
captureException
(
e
options
)
;
throw
e
;
}
}
for
(
var
property
in
func
)
{
if
(
hasKey
(
func
property
)
)
{
wrapped
[
property
]
=
func
[
property
]
;
}
}
wrapped
.
prototype
=
func
.
prototype
;
func
.
__raven_wrapper__
=
wrapped
;
wrapped
.
__raven__
=
true
;
wrapped
.
__orig__
=
func
;
return
wrapped
;
}
uninstall
:
function
(
)
{
TraceKit
.
report
.
uninstall
(
)
;
this
.
_detachPromiseRejectionHandler
(
)
;
this
.
_unpatchFunctionToString
(
)
;
this
.
_restoreBuiltIns
(
)
;
this
.
_restoreConsole
(
)
;
Error
.
stackTraceLimit
=
this
.
_originalErrorStackTraceLimit
;
this
.
_isRavenInstalled
=
false
;
return
this
;
}
_promiseRejectionHandler
:
function
(
event
)
{
this
.
_logDebug
(
'
debug
'
'
Raven
caught
unhandled
promise
rejection
:
'
event
)
;
this
.
captureException
(
event
.
reason
{
extra
:
{
unhandledPromiseRejection
:
true
}
}
)
;
}
_attachPromiseRejectionHandler
:
function
(
)
{
this
.
_promiseRejectionHandler
=
this
.
_promiseRejectionHandler
.
bind
(
this
)
;
_window
.
addEventListener
&
&
_window
.
addEventListener
(
'
unhandledrejection
'
this
.
_promiseRejectionHandler
)
;
return
this
;
}
_detachPromiseRejectionHandler
:
function
(
)
{
_window
.
removeEventListener
&
&
_window
.
removeEventListener
(
'
unhandledrejection
'
this
.
_promiseRejectionHandler
)
;
return
this
;
}
captureException
:
function
(
ex
options
)
{
options
=
objectMerge
(
{
trimHeadFrames
:
0
}
options
?
options
:
{
}
)
;
if
(
isErrorEvent
(
ex
)
&
&
ex
.
error
)
{
ex
=
ex
.
error
;
}
else
if
(
isError
(
ex
)
)
{
ex
=
ex
;
}
else
if
(
isPlainObject
(
ex
)
)
{
options
=
this
.
_getCaptureExceptionOptionsFromPlainObject
(
options
ex
)
;
ex
=
new
Error
(
options
.
message
)
;
}
else
{
return
this
.
captureMessage
(
ex
objectMerge
(
options
{
stacktrace
:
true
trimHeadFrames
:
options
.
trimHeadFrames
+
1
}
)
)
;
}
this
.
_lastCapturedException
=
ex
;
try
{
var
stack
=
TraceKit
.
computeStackTrace
(
ex
)
;
this
.
_handleStackInfo
(
stack
options
)
;
}
catch
(
ex1
)
{
if
(
ex
!
=
=
ex1
)
{
throw
ex1
;
}
}
return
this
;
}
_getCaptureExceptionOptionsFromPlainObject
:
function
(
currentOptions
ex
)
{
var
exKeys
=
Object
.
keys
(
ex
)
.
sort
(
)
;
var
options
=
objectMerge
(
currentOptions
{
message
:
'
Non
-
Error
exception
captured
with
keys
:
'
+
serializeKeysForMessage
(
exKeys
)
fingerprint
:
[
md5
(
exKeys
)
]
extra
:
currentOptions
.
extra
|
|
{
}
}
)
;
options
.
extra
.
__serialized__
=
serializeException
(
ex
)
;
return
options
;
}
captureMessage
:
function
(
msg
options
)
{
if
(
!
!
this
.
_globalOptions
.
ignoreErrors
.
test
&
&
this
.
_globalOptions
.
ignoreErrors
.
test
(
msg
)
)
{
return
;
}
options
=
options
|
|
{
}
;
msg
=
msg
+
'
'
;
var
data
=
objectMerge
(
{
message
:
msg
}
options
)
;
var
ex
;
try
{
throw
new
Error
(
msg
)
;
}
catch
(
ex1
)
{
ex
=
ex1
;
}
ex
.
name
=
null
;
var
stack
=
TraceKit
.
computeStackTrace
(
ex
)
;
var
initialCall
=
isArray
(
stack
.
stack
)
&
&
stack
.
stack
[
1
]
;
var
fileurl
=
(
initialCall
&
&
initialCall
.
url
)
|
|
'
'
;
if
(
!
!
this
.
_globalOptions
.
ignoreUrls
.
test
&
&
this
.
_globalOptions
.
ignoreUrls
.
test
(
fileurl
)
)
{
return
;
}
if
(
!
!
this
.
_globalOptions
.
whitelistUrls
.
test
&
&
!
this
.
_globalOptions
.
whitelistUrls
.
test
(
fileurl
)
)
{
return
;
}
if
(
this
.
_globalOptions
.
stacktrace
|
|
(
options
&
&
options
.
stacktrace
)
)
{
data
.
fingerprint
=
data
.
fingerprint
=
=
null
?
msg
:
data
.
fingerprint
;
options
=
objectMerge
(
{
trimHeadFrames
:
0
}
options
)
;
options
.
trimHeadFrames
+
=
1
;
var
frames
=
this
.
_prepareFrames
(
stack
options
)
;
data
.
stacktrace
=
{
frames
:
frames
.
reverse
(
)
}
;
}
if
(
data
.
fingerprint
)
{
data
.
fingerprint
=
isArray
(
data
.
fingerprint
)
?
data
.
fingerprint
:
[
data
.
fingerprint
]
;
}
this
.
_send
(
data
)
;
return
this
;
}
captureBreadcrumb
:
function
(
obj
)
{
var
crumb
=
objectMerge
(
{
timestamp
:
now
(
)
/
1000
}
obj
)
;
if
(
isFunction
(
this
.
_globalOptions
.
breadcrumbCallback
)
)
{
var
result
=
this
.
_globalOptions
.
breadcrumbCallback
(
crumb
)
;
if
(
isObject
(
result
)
&
&
!
isEmptyObject
(
result
)
)
{
crumb
=
result
;
}
else
if
(
result
=
=
=
false
)
{
return
this
;
}
}
this
.
_breadcrumbs
.
push
(
crumb
)
;
if
(
this
.
_breadcrumbs
.
length
>
this
.
_globalOptions
.
maxBreadcrumbs
)
{
this
.
_breadcrumbs
.
shift
(
)
;
}
return
this
;
}
addPlugin
:
function
(
plugin
)
{
var
pluginArgs
=
[
]
.
slice
.
call
(
arguments
1
)
;
this
.
_plugins
.
push
(
[
plugin
pluginArgs
]
)
;
if
(
this
.
_isRavenInstalled
)
{
this
.
_drainPlugins
(
)
;
}
return
this
;
}
setUserContext
:
function
(
user
)
{
this
.
_globalContext
.
user
=
user
;
return
this
;
}
setExtraContext
:
function
(
extra
)
{
this
.
_mergeContext
(
'
extra
'
extra
)
;
return
this
;
}
setTagsContext
:
function
(
tags
)
{
this
.
_mergeContext
(
'
tags
'
tags
)
;
return
this
;
}
clearContext
:
function
(
)
{
this
.
_globalContext
=
{
}
;
return
this
;
}
getContext
:
function
(
)
{
return
JSON
.
parse
(
stringify
(
this
.
_globalContext
)
)
;
}
setEnvironment
:
function
(
environment
)
{
this
.
_globalOptions
.
environment
=
environment
;
return
this
;
}
setRelease
:
function
(
release
)
{
this
.
_globalOptions
.
release
=
release
;
return
this
;
}
setDataCallback
:
function
(
callback
)
{
var
original
=
this
.
_globalOptions
.
dataCallback
;
this
.
_globalOptions
.
dataCallback
=
keepOriginalCallback
(
original
callback
)
;
return
this
;
}
setBreadcrumbCallback
:
function
(
callback
)
{
var
original
=
this
.
_globalOptions
.
breadcrumbCallback
;
this
.
_globalOptions
.
breadcrumbCallback
=
keepOriginalCallback
(
original
callback
)
;
return
this
;
}
setShouldSendCallback
:
function
(
callback
)
{
var
original
=
this
.
_globalOptions
.
shouldSendCallback
;
this
.
_globalOptions
.
shouldSendCallback
=
keepOriginalCallback
(
original
callback
)
;
return
this
;
}
setTransport
:
function
(
transport
)
{
this
.
_globalOptions
.
transport
=
transport
;
return
this
;
}
lastException
:
function
(
)
{
return
this
.
_lastCapturedException
;
}
lastEventId
:
function
(
)
{
return
this
.
_lastEventId
;
}
isSetup
:
function
(
)
{
if
(
!
this
.
_hasJSON
)
return
false
;
if
(
!
this
.
_globalServer
)
{
if
(
!
this
.
ravenNotConfiguredError
)
{
this
.
ravenNotConfiguredError
=
true
;
this
.
_logDebug
(
'
error
'
'
Error
:
Raven
has
not
been
configured
.
'
)
;
}
return
false
;
}
return
true
;
}
afterLoad
:
function
(
)
{
var
RavenConfig
=
_window
.
RavenConfig
;
if
(
RavenConfig
)
{
this
.
config
(
RavenConfig
.
dsn
RavenConfig
.
config
)
.
install
(
)
;
}
}
showReportDialog
:
function
(
options
)
{
if
(
!
_document
)
return
;
options
=
options
|
|
{
}
;
var
lastEventId
=
options
.
eventId
|
|
this
.
lastEventId
(
)
;
if
(
!
lastEventId
)
{
throw
new
RavenConfigError
(
'
Missing
eventId
'
)
;
}
var
dsn
=
options
.
dsn
|
|
this
.
_dsn
;
if
(
!
dsn
)
{
throw
new
RavenConfigError
(
'
Missing
DSN
'
)
;
}
var
encode
=
encodeURIComponent
;
var
qs
=
'
'
;
qs
+
=
'
?
eventId
=
'
+
encode
(
lastEventId
)
;
qs
+
=
'
&
dsn
=
'
+
encode
(
dsn
)
;
var
user
=
options
.
user
|
|
this
.
_globalContext
.
user
;
if
(
user
)
{
if
(
user
.
name
)
qs
+
=
'
&
name
=
'
+
encode
(
user
.
name
)
;
if
(
user
.
email
)
qs
+
=
'
&
email
=
'
+
encode
(
user
.
email
)
;
}
var
globalServer
=
this
.
_getGlobalServer
(
this
.
_parseDSN
(
dsn
)
)
;
var
script
=
_document
.
createElement
(
'
script
'
)
;
script
.
async
=
true
;
script
.
src
=
globalServer
+
'
/
api
/
embed
/
error
-
page
/
'
+
qs
;
(
_document
.
head
|
|
_document
.
body
)
.
appendChild
(
script
)
;
}
_ignoreNextOnError
:
function
(
)
{
var
self
=
this
;
this
.
_ignoreOnError
+
=
1
;
setTimeout
(
function
(
)
{
self
.
_ignoreOnError
-
=
1
;
}
)
;
}
_triggerEvent
:
function
(
eventType
options
)
{
var
evt
key
;
if
(
!
this
.
_hasDocument
)
return
;
options
=
options
|
|
{
}
;
eventType
=
'
raven
'
+
eventType
.
substr
(
0
1
)
.
toUpperCase
(
)
+
eventType
.
substr
(
1
)
;
if
(
_document
.
createEvent
)
{
evt
=
_document
.
createEvent
(
'
HTMLEvents
'
)
;
evt
.
initEvent
(
eventType
true
true
)
;
}
else
{
evt
=
_document
.
createEventObject
(
)
;
evt
.
eventType
=
eventType
;
}
for
(
key
in
options
)
if
(
hasKey
(
options
key
)
)
{
evt
[
key
]
=
options
[
key
]
;
}
if
(
_document
.
createEvent
)
{
_document
.
dispatchEvent
(
evt
)
;
}
else
{
try
{
_document
.
fireEvent
(
'
on
'
+
evt
.
eventType
.
toLowerCase
(
)
evt
)
;
}
catch
(
e
)
{
}
}
}
_breadcrumbEventHandler
:
function
(
evtName
)
{
var
self
=
this
;
return
function
(
evt
)
{
self
.
_keypressTimeout
=
null
;
if
(
self
.
_lastCapturedEvent
=
=
=
evt
)
return
;
self
.
_lastCapturedEvent
=
evt
;
var
target
;
try
{
target
=
htmlTreeAsString
(
evt
.
target
)
;
}
catch
(
e
)
{
target
=
'
<
unknown
>
'
;
}
self
.
captureBreadcrumb
(
{
category
:
'
ui
.
'
+
evtName
message
:
target
}
)
;
}
;
}
_keypressEventHandler
:
function
(
)
{
var
self
=
this
debounceDuration
=
1000
;
return
function
(
evt
)
{
var
target
;
try
{
target
=
evt
.
target
;
}
catch
(
e
)
{
return
;
}
var
tagName
=
target
&
&
target
.
tagName
;
if
(
!
tagName
|
|
(
tagName
!
=
=
'
INPUT
'
&
&
tagName
!
=
=
'
TEXTAREA
'
&
&
!
target
.
isContentEditable
)
)
return
;
var
timeout
=
self
.
_keypressTimeout
;
if
(
!
timeout
)
{
self
.
_breadcrumbEventHandler
(
'
input
'
)
(
evt
)
;
}
clearTimeout
(
timeout
)
;
self
.
_keypressTimeout
=
setTimeout
(
function
(
)
{
self
.
_keypressTimeout
=
null
;
}
debounceDuration
)
;
}
;
}
_captureUrlChange
:
function
(
from
to
)
{
var
parsedLoc
=
parseUrl
(
this
.
_location
.
href
)
;
var
parsedTo
=
parseUrl
(
to
)
;
var
parsedFrom
=
parseUrl
(
from
)
;
this
.
_lastHref
=
to
;
if
(
parsedLoc
.
protocol
=
=
=
parsedTo
.
protocol
&
&
parsedLoc
.
host
=
=
=
parsedTo
.
host
)
to
=
parsedTo
.
relative
;
if
(
parsedLoc
.
protocol
=
=
=
parsedFrom
.
protocol
&
&
parsedLoc
.
host
=
=
=
parsedFrom
.
host
)
from
=
parsedFrom
.
relative
;
this
.
captureBreadcrumb
(
{
category
:
'
navigation
'
data
:
{
to
:
to
from
:
from
}
}
)
;
}
_patchFunctionToString
:
function
(
)
{
var
self
=
this
;
self
.
_originalFunctionToString
=
Function
.
prototype
.
toString
;
Function
.
prototype
.
toString
=
function
(
)
{
if
(
typeof
this
=
=
=
'
function
'
&
&
this
.
__raven__
)
{
return
self
.
_originalFunctionToString
.
apply
(
this
.
__orig__
arguments
)
;
}
return
self
.
_originalFunctionToString
.
apply
(
this
arguments
)
;
}
;
}
_unpatchFunctionToString
:
function
(
)
{
if
(
this
.
_originalFunctionToString
)
{
Function
.
prototype
.
toString
=
this
.
_originalFunctionToString
;
}
}
_instrumentTryCatch
:
function
(
)
{
var
self
=
this
;
var
wrappedBuiltIns
=
self
.
_wrappedBuiltIns
;
function
wrapTimeFn
(
orig
)
{
return
function
(
fn
t
)
{
var
args
=
new
Array
(
arguments
.
length
)
;
for
(
var
i
=
0
;
i
<
args
.
length
;
+
+
i
)
{
args
[
i
]
=
arguments
[
i
]
;
}
var
originalCallback
=
args
[
0
]
;
if
(
isFunction
(
originalCallback
)
)
{
args
[
0
]
=
self
.
wrap
(
originalCallback
)
;
}
if
(
orig
.
apply
)
{
return
orig
.
apply
(
this
args
)
;
}
else
{
return
orig
(
args
[
0
]
args
[
1
]
)
;
}
}
;
}
var
autoBreadcrumbs
=
this
.
_globalOptions
.
autoBreadcrumbs
;
function
wrapEventTarget
(
global
)
{
var
proto
=
_window
[
global
]
&
&
_window
[
global
]
.
prototype
;
if
(
proto
&
&
proto
.
hasOwnProperty
&
&
proto
.
hasOwnProperty
(
'
addEventListener
'
)
)
{
fill
(
proto
'
addEventListener
'
function
(
orig
)
{
return
function
(
evtName
fn
capture
secure
)
{
try
{
if
(
fn
&
&
fn
.
handleEvent
)
{
fn
.
handleEvent
=
self
.
wrap
(
fn
.
handleEvent
)
;
}
}
catch
(
err
)
{
}
var
before
clickHandler
keypressHandler
;
if
(
autoBreadcrumbs
&
&
autoBreadcrumbs
.
dom
&
&
(
global
=
=
=
'
EventTarget
'
|
|
global
=
=
=
'
Node
'
)
)
{
clickHandler
=
self
.
_breadcrumbEventHandler
(
'
click
'
)
;
keypressHandler
=
self
.
_keypressEventHandler
(
)
;
before
=
function
(
evt
)
{
if
(
!
evt
)
return
;
var
eventType
;
try
{
eventType
=
evt
.
type
;
}
catch
(
e
)
{
return
;
}
if
(
eventType
=
=
=
'
click
'
)
return
clickHandler
(
evt
)
;
else
if
(
eventType
=
=
=
'
keypress
'
)
return
keypressHandler
(
evt
)
;
}
;
}
return
orig
.
call
(
this
evtName
self
.
wrap
(
fn
undefined
before
)
capture
secure
)
;
}
;
}
wrappedBuiltIns
)
;
fill
(
proto
'
removeEventListener
'
function
(
orig
)
{
return
function
(
evt
fn
capture
secure
)
{
try
{
fn
=
fn
&
&
(
fn
.
__raven_wrapper__
?
fn
.
__raven_wrapper__
:
fn
)
;
}
catch
(
e
)
{
}
return
orig
.
call
(
this
evt
fn
capture
secure
)
;
}
;
}
wrappedBuiltIns
)
;
}
}
fill
(
_window
'
setTimeout
'
wrapTimeFn
wrappedBuiltIns
)
;
fill
(
_window
'
setInterval
'
wrapTimeFn
wrappedBuiltIns
)
;
if
(
_window
.
requestAnimationFrame
)
{
fill
(
_window
'
requestAnimationFrame
'
function
(
orig
)
{
return
function
(
cb
)
{
return
orig
(
self
.
wrap
(
cb
)
)
;
}
;
}
wrappedBuiltIns
)
;
}
var
eventTargets
=
[
'
EventTarget
'
'
Window
'
'
Node
'
'
ApplicationCache
'
'
AudioTrackList
'
'
ChannelMergerNode
'
'
CryptoOperation
'
'
EventSource
'
'
FileReader
'
'
HTMLUnknownElement
'
'
IDBDatabase
'
'
IDBRequest
'
'
IDBTransaction
'
'
KeyOperation
'
'
MediaController
'
'
MessagePort
'
'
ModalWindow
'
'
Notification
'
'
SVGElementInstance
'
'
Screen
'
'
TextTrack
'
'
TextTrackCue
'
'
TextTrackList
'
'
WebSocket
'
'
WebSocketWorker
'
'
Worker
'
'
XMLHttpRequest
'
'
XMLHttpRequestEventTarget
'
'
XMLHttpRequestUpload
'
]
;
for
(
var
i
=
0
;
i
<
eventTargets
.
length
;
i
+
+
)
{
wrapEventTarget
(
eventTargets
[
i
]
)
;
}
}
_instrumentBreadcrumbs
:
function
(
)
{
var
self
=
this
;
var
autoBreadcrumbs
=
this
.
_globalOptions
.
autoBreadcrumbs
;
var
wrappedBuiltIns
=
self
.
_wrappedBuiltIns
;
function
wrapProp
(
prop
xhr
)
{
if
(
prop
in
xhr
&
&
isFunction
(
xhr
[
prop
]
)
)
{
fill
(
xhr
prop
function
(
orig
)
{
return
self
.
wrap
(
orig
)
;
}
)
;
}
}
if
(
autoBreadcrumbs
.
xhr
&
&
'
XMLHttpRequest
'
in
_window
)
{
var
xhrproto
=
_window
.
XMLHttpRequest
&
&
_window
.
XMLHttpRequest
.
prototype
;
fill
(
xhrproto
'
open
'
function
(
origOpen
)
{
return
function
(
method
url
)
{
if
(
isString
(
url
)
&
&
url
.
indexOf
(
self
.
_globalKey
)
=
=
=
-
1
)
{
this
.
__raven_xhr
=
{
method
:
method
url
:
url
status_code
:
null
}
;
}
return
origOpen
.
apply
(
this
arguments
)
;
}
;
}
wrappedBuiltIns
)
;
fill
(
xhrproto
'
send
'
function
(
origSend
)
{
return
function
(
)
{
var
xhr
=
this
;
function
onreadystatechangeHandler
(
)
{
if
(
xhr
.
__raven_xhr
&
&
xhr
.
readyState
=
=
=
4
)
{
try
{
xhr
.
__raven_xhr
.
status_code
=
xhr
.
status
;
}
catch
(
e
)
{
}
self
.
captureBreadcrumb
(
{
type
:
'
http
'
category
:
'
xhr
'
data
:
xhr
.
__raven_xhr
}
)
;
}
}
var
props
=
[
'
onload
'
'
onerror
'
'
onprogress
'
]
;
for
(
var
j
=
0
;
j
<
props
.
length
;
j
+
+
)
{
wrapProp
(
props
[
j
]
xhr
)
;
}
if
(
'
onreadystatechange
'
in
xhr
&
&
isFunction
(
xhr
.
onreadystatechange
)
)
{
fill
(
xhr
'
onreadystatechange
'
function
(
orig
)
{
return
self
.
wrap
(
orig
undefined
onreadystatechangeHandler
)
;
}
)
;
}
else
{
xhr
.
onreadystatechange
=
onreadystatechangeHandler
;
}
return
origSend
.
apply
(
this
arguments
)
;
}
;
}
wrappedBuiltIns
)
;
}
if
(
autoBreadcrumbs
.
xhr
&
&
supportsFetch
(
)
)
{
fill
(
_window
'
fetch
'
function
(
origFetch
)
{
return
function
(
)
{
var
args
=
new
Array
(
arguments
.
length
)
;
for
(
var
i
=
0
;
i
<
args
.
length
;
+
+
i
)
{
args
[
i
]
=
arguments
[
i
]
;
}
var
fetchInput
=
args
[
0
]
;
var
method
=
'
GET
'
;
var
url
;
if
(
typeof
fetchInput
=
=
=
'
string
'
)
{
url
=
fetchInput
;
}
else
if
(
'
Request
'
in
_window
&
&
fetchInput
instanceof
_window
.
Request
)
{
url
=
fetchInput
.
url
;
if
(
fetchInput
.
method
)
{
method
=
fetchInput
.
method
;
}
}
else
{
url
=
'
'
+
fetchInput
;
}
if
(
url
.
indexOf
(
self
.
_globalKey
)
!
=
=
-
1
)
{
return
origFetch
.
apply
(
this
args
)
;
}
if
(
args
[
1
]
&
&
args
[
1
]
.
method
)
{
method
=
args
[
1
]
.
method
;
}
var
fetchData
=
{
method
:
method
url
:
url
status_code
:
null
}
;
return
origFetch
.
apply
(
this
args
)
.
then
(
function
(
response
)
{
fetchData
.
status_code
=
response
.
status
;
self
.
captureBreadcrumb
(
{
type
:
'
http
'
category
:
'
fetch
'
data
:
fetchData
}
)
;
return
response
;
}
)
;
}
;
}
wrappedBuiltIns
)
;
}
if
(
autoBreadcrumbs
.
dom
&
&
this
.
_hasDocument
)
{
if
(
_document
.
addEventListener
)
{
_document
.
addEventListener
(
'
click
'
self
.
_breadcrumbEventHandler
(
'
click
'
)
false
)
;
_document
.
addEventListener
(
'
keypress
'
self
.
_keypressEventHandler
(
)
false
)
;
}
else
if
(
_document
.
attachEvent
)
{
_document
.
attachEvent
(
'
onclick
'
self
.
_breadcrumbEventHandler
(
'
click
'
)
)
;
_document
.
attachEvent
(
'
onkeypress
'
self
.
_keypressEventHandler
(
)
)
;
}
}
var
chrome
=
_window
.
chrome
;
var
isChromePackagedApp
=
chrome
&
&
chrome
.
app
&
&
chrome
.
app
.
runtime
;
var
hasPushAndReplaceState
=
!
isChromePackagedApp
&
&
_window
.
history
&
&
history
.
pushState
&
&
history
.
replaceState
;
if
(
autoBreadcrumbs
.
location
&
&
hasPushAndReplaceState
)
{
var
oldOnPopState
=
_window
.
onpopstate
;
_window
.
onpopstate
=
function
(
)
{
var
currentHref
=
self
.
_location
.
href
;
self
.
_captureUrlChange
(
self
.
_lastHref
currentHref
)
;
if
(
oldOnPopState
)
{
return
oldOnPopState
.
apply
(
this
arguments
)
;
}
}
;
var
historyReplacementFunction
=
function
(
origHistFunction
)
{
return
function
(
)
{
var
url
=
arguments
.
length
>
2
?
arguments
[
2
]
:
undefined
;
if
(
url
)
{
self
.
_captureUrlChange
(
self
.
_lastHref
url
+
'
'
)
;
}
return
origHistFunction
.
apply
(
this
arguments
)
;
}
;
}
;
fill
(
history
'
pushState
'
historyReplacementFunction
wrappedBuiltIns
)
;
fill
(
history
'
replaceState
'
historyReplacementFunction
wrappedBuiltIns
)
;
}
if
(
autoBreadcrumbs
.
console
&
&
'
console
'
in
_window
&
&
console
.
log
)
{
var
consoleMethodCallback
=
function
(
msg
data
)
{
self
.
captureBreadcrumb
(
{
message
:
msg
level
:
data
.
level
category
:
'
console
'
}
)
;
}
;
each
(
[
'
debug
'
'
info
'
'
warn
'
'
error
'
'
log
'
]
function
(
_
level
)
{
wrapConsoleMethod
(
console
level
consoleMethodCallback
)
;
}
)
;
}
}
_restoreBuiltIns
:
function
(
)
{
var
builtin
;
while
(
this
.
_wrappedBuiltIns
.
length
)
{
builtin
=
this
.
_wrappedBuiltIns
.
shift
(
)
;
var
obj
=
builtin
[
0
]
name
=
builtin
[
1
]
orig
=
builtin
[
2
]
;
obj
[
name
]
=
orig
;
}
}
_restoreConsole
:
function
(
)
{
for
(
var
method
in
this
.
_originalConsoleMethods
)
{
this
.
_originalConsole
[
method
]
=
this
.
_originalConsoleMethods
[
method
]
;
}
}
_drainPlugins
:
function
(
)
{
var
self
=
this
;
each
(
this
.
_plugins
function
(
_
plugin
)
{
var
installer
=
plugin
[
0
]
;
var
args
=
plugin
[
1
]
;
installer
.
apply
(
self
[
self
]
.
concat
(
args
)
)
;
}
)
;
}
_parseDSN
:
function
(
str
)
{
var
m
=
dsnPattern
.
exec
(
str
)
dsn
=
{
}
i
=
7
;
try
{
while
(
i
-
-
)
dsn
[
dsnKeys
[
i
]
]
=
m
[
i
]
|
|
'
'
;
}
catch
(
e
)
{
throw
new
RavenConfigError
(
'
Invalid
DSN
:
'
+
str
)
;
}
if
(
dsn
.
pass
&
&
!
this
.
_globalOptions
.
allowSecretKey
)
{
throw
new
RavenConfigError
(
'
Do
not
specify
your
secret
key
in
the
DSN
.
See
:
http
:
/
/
bit
.
ly
/
raven
-
secret
-
key
'
)
;
}
return
dsn
;
}
_getGlobalServer
:
function
(
uri
)
{
var
globalServer
=
'
/
/
'
+
uri
.
host
+
(
uri
.
port
?
'
:
'
+
uri
.
port
:
'
'
)
;
if
(
uri
.
protocol
)
{
globalServer
=
uri
.
protocol
+
'
:
'
+
globalServer
;
}
return
globalServer
;
}
_handleOnErrorStackInfo
:
function
(
)
{
if
(
!
this
.
_ignoreOnError
)
{
this
.
_handleStackInfo
.
apply
(
this
arguments
)
;
}
}
_handleStackInfo
:
function
(
stackInfo
options
)
{
var
frames
=
this
.
_prepareFrames
(
stackInfo
options
)
;
this
.
_triggerEvent
(
'
handle
'
{
stackInfo
:
stackInfo
options
:
options
}
)
;
this
.
_processException
(
stackInfo
.
name
stackInfo
.
message
stackInfo
.
url
stackInfo
.
lineno
frames
options
)
;
}
_prepareFrames
:
function
(
stackInfo
options
)
{
var
self
=
this
;
var
frames
=
[
]
;
if
(
stackInfo
.
stack
&
&
stackInfo
.
stack
.
length
)
{
each
(
stackInfo
.
stack
function
(
i
stack
)
{
var
frame
=
self
.
_normalizeFrame
(
stack
stackInfo
.
url
)
;
if
(
frame
)
{
frames
.
push
(
frame
)
;
}
}
)
;
if
(
options
&
&
options
.
trimHeadFrames
)
{
for
(
var
j
=
0
;
j
<
options
.
trimHeadFrames
&
&
j
<
frames
.
length
;
j
+
+
)
{
frames
[
j
]
.
in_app
=
false
;
}
}
}
frames
=
frames
.
slice
(
0
this
.
_globalOptions
.
stackTraceLimit
)
;
return
frames
;
}
_normalizeFrame
:
function
(
frame
stackInfoUrl
)
{
var
normalized
=
{
filename
:
frame
.
url
lineno
:
frame
.
line
colno
:
frame
.
column
function
:
frame
.
func
|
|
'
?
'
}
;
if
(
!
frame
.
url
)
{
normalized
.
filename
=
stackInfoUrl
;
}
normalized
.
in_app
=
!
(
(
!
!
this
.
_globalOptions
.
includePaths
.
test
&
&
!
this
.
_globalOptions
.
includePaths
.
test
(
normalized
.
filename
)
)
|
|
/
(
Raven
|
TraceKit
)
\
.
/
.
test
(
normalized
[
'
function
'
]
)
|
|
/
raven
\
.
(
min
\
.
)
?
js
/
.
test
(
normalized
.
filename
)
)
;
return
normalized
;
}
_processException
:
function
(
type
message
fileurl
lineno
frames
options
)
{
var
prefixedMessage
=
(
type
?
type
+
'
:
'
:
'
'
)
+
(
message
|
|
'
'
)
;
if
(
!
!
this
.
_globalOptions
.
ignoreErrors
.
test
&
&
(
this
.
_globalOptions
.
ignoreErrors
.
test
(
message
)
|
|
this
.
_globalOptions
.
ignoreErrors
.
test
(
prefixedMessage
)
)
)
{
return
;
}
var
stacktrace
;
if
(
frames
&
&
frames
.
length
)
{
fileurl
=
frames
[
0
]
.
filename
|
|
fileurl
;
frames
.
reverse
(
)
;
stacktrace
=
{
frames
:
frames
}
;
}
else
if
(
fileurl
)
{
stacktrace
=
{
frames
:
[
{
filename
:
fileurl
lineno
:
lineno
in_app
:
true
}
]
}
;
}
if
(
!
!
this
.
_globalOptions
.
ignoreUrls
.
test
&
&
this
.
_globalOptions
.
ignoreUrls
.
test
(
fileurl
)
)
{
return
;
}
if
(
!
!
this
.
_globalOptions
.
whitelistUrls
.
test
&
&
!
this
.
_globalOptions
.
whitelistUrls
.
test
(
fileurl
)
)
{
return
;
}
var
data
=
objectMerge
(
{
exception
:
{
values
:
[
{
type
:
type
value
:
message
stacktrace
:
stacktrace
}
]
}
culprit
:
fileurl
}
options
)
;
this
.
_send
(
data
)
;
}
_trimPacket
:
function
(
data
)
{
var
max
=
this
.
_globalOptions
.
maxMessageLength
;
if
(
data
.
message
)
{
data
.
message
=
truncate
(
data
.
message
max
)
;
}
if
(
data
.
exception
)
{
var
exception
=
data
.
exception
.
values
[
0
]
;
exception
.
value
=
truncate
(
exception
.
value
max
)
;
}
var
request
=
data
.
request
;
if
(
request
)
{
if
(
request
.
url
)
{
request
.
url
=
truncate
(
request
.
url
this
.
_globalOptions
.
maxUrlLength
)
;
}
if
(
request
.
Referer
)
{
request
.
Referer
=
truncate
(
request
.
Referer
this
.
_globalOptions
.
maxUrlLength
)
;
}
}
if
(
data
.
breadcrumbs
&
&
data
.
breadcrumbs
.
values
)
this
.
_trimBreadcrumbs
(
data
.
breadcrumbs
)
;
return
data
;
}
_trimBreadcrumbs
:
function
(
breadcrumbs
)
{
var
urlProps
=
[
'
to
'
'
from
'
'
url
'
]
urlProp
crumb
data
;
for
(
var
i
=
0
;
i
<
breadcrumbs
.
values
.
length
;
+
+
i
)
{
crumb
=
breadcrumbs
.
values
[
i
]
;
if
(
!
crumb
.
hasOwnProperty
(
'
data
'
)
|
|
!
isObject
(
crumb
.
data
)
|
|
objectFrozen
(
crumb
.
data
)
)
continue
;
data
=
objectMerge
(
{
}
crumb
.
data
)
;
for
(
var
j
=
0
;
j
<
urlProps
.
length
;
+
+
j
)
{
urlProp
=
urlProps
[
j
]
;
if
(
data
.
hasOwnProperty
(
urlProp
)
&
&
data
[
urlProp
]
)
{
data
[
urlProp
]
=
truncate
(
data
[
urlProp
]
this
.
_globalOptions
.
maxUrlLength
)
;
}
}
breadcrumbs
.
values
[
i
]
.
data
=
data
;
}
}
_getHttpData
:
function
(
)
{
if
(
!
this
.
_hasNavigator
&
&
!
this
.
_hasDocument
)
return
;
var
httpData
=
{
}
;
if
(
this
.
_hasNavigator
&
&
_navigator
.
userAgent
)
{
httpData
.
headers
=
{
'
User
-
Agent
'
:
navigator
.
userAgent
}
;
}
if
(
_window
.
location
&
&
_window
.
location
.
href
)
{
httpData
.
url
=
_window
.
location
.
href
;
}
if
(
this
.
_hasDocument
&
&
_document
.
referrer
)
{
if
(
!
httpData
.
headers
)
httpData
.
headers
=
{
}
;
httpData
.
headers
.
Referer
=
_document
.
referrer
;
}
return
httpData
;
}
_resetBackoff
:
function
(
)
{
this
.
_backoffDuration
=
0
;
this
.
_backoffStart
=
null
;
}
_shouldBackoff
:
function
(
)
{
return
this
.
_backoffDuration
&
&
now
(
)
-
this
.
_backoffStart
<
this
.
_backoffDuration
;
}
_isRepeatData
:
function
(
current
)
{
var
last
=
this
.
_lastData
;
if
(
!
last
|
|
current
.
message
!
=
=
last
.
message
|
|
current
.
culprit
!
=
=
last
.
culprit
)
return
false
;
if
(
current
.
stacktrace
|
|
last
.
stacktrace
)
{
return
isSameStacktrace
(
current
.
stacktrace
last
.
stacktrace
)
;
}
else
if
(
current
.
exception
|
|
last
.
exception
)
{
return
isSameException
(
current
.
exception
last
.
exception
)
;
}
return
true
;
}
_setBackoffState
:
function
(
request
)
{
if
(
this
.
_shouldBackoff
(
)
)
{
return
;
}
var
status
=
request
.
status
;
if
(
!
(
status
=
=
=
400
|
|
status
=
=
=
401
|
|
status
=
=
=
429
)
)
return
;
var
retry
;
try
{
if
(
supportsFetch
(
)
)
{
retry
=
request
.
headers
.
get
(
'
Retry
-
After
'
)
;
}
else
{
retry
=
request
.
getResponseHeader
(
'
Retry
-
After
'
)
;
}
retry
=
parseInt
(
retry
10
)
*
1000
;
}
catch
(
e
)
{
}
this
.
_backoffDuration
=
retry
?
retry
:
this
.
_backoffDuration
*
2
|
|
1000
;
this
.
_backoffStart
=
now
(
)
;
}
_send
:
function
(
data
)
{
var
globalOptions
=
this
.
_globalOptions
;
var
baseData
=
{
project
:
this
.
_globalProject
logger
:
globalOptions
.
logger
platform
:
'
javascript
'
}
httpData
=
this
.
_getHttpData
(
)
;
if
(
httpData
)
{
baseData
.
request
=
httpData
;
}
if
(
data
.
trimHeadFrames
)
delete
data
.
trimHeadFrames
;
data
=
objectMerge
(
baseData
data
)
;
data
.
tags
=
objectMerge
(
objectMerge
(
{
}
this
.
_globalContext
.
tags
)
data
.
tags
)
;
data
.
extra
=
objectMerge
(
objectMerge
(
{
}
this
.
_globalContext
.
extra
)
data
.
extra
)
;
data
.
extra
[
'
session
:
duration
'
]
=
now
(
)
-
this
.
_startTime
;
if
(
this
.
_breadcrumbs
&
&
this
.
_breadcrumbs
.
length
>
0
)
{
data
.
breadcrumbs
=
{
values
:
[
]
.
slice
.
call
(
this
.
_breadcrumbs
0
)
}
;
}
if
(
this
.
_globalContext
.
user
)
{
data
.
user
=
this
.
_globalContext
.
user
;
}
if
(
globalOptions
.
environment
)
data
.
environment
=
globalOptions
.
environment
;
if
(
globalOptions
.
release
)
data
.
release
=
globalOptions
.
release
;
if
(
globalOptions
.
serverName
)
data
.
server_name
=
globalOptions
.
serverName
;
data
=
this
.
_sanitizeData
(
data
)
;
Object
.
keys
(
data
)
.
forEach
(
function
(
key
)
{
if
(
data
[
key
]
=
=
null
|
|
data
[
key
]
=
=
=
'
'
|
|
isEmptyObject
(
data
[
key
]
)
)
{
delete
data
[
key
]
;
}
}
)
;
if
(
isFunction
(
globalOptions
.
dataCallback
)
)
{
data
=
globalOptions
.
dataCallback
(
data
)
|
|
data
;
}
if
(
!
data
|
|
isEmptyObject
(
data
)
)
{
return
;
}
if
(
isFunction
(
globalOptions
.
shouldSendCallback
)
&
&
!
globalOptions
.
shouldSendCallback
(
data
)
)
{
return
;
}
if
(
this
.
_shouldBackoff
(
)
)
{
this
.
_logDebug
(
'
warn
'
'
Raven
dropped
error
due
to
backoff
:
'
data
)
;
return
;
}
if
(
typeof
globalOptions
.
sampleRate
=
=
=
'
number
'
)
{
if
(
Math
.
random
(
)
<
globalOptions
.
sampleRate
)
{
this
.
_sendProcessedPayload
(
data
)
;
}
}
else
{
this
.
_sendProcessedPayload
(
data
)
;
}
}
_sanitizeData
:
function
(
data
)
{
return
sanitize
(
data
this
.
_globalOptions
.
sanitizeKeys
)
;
}
_getUuid
:
function
(
)
{
return
uuid4
(
)
;
}
_sendProcessedPayload
:
function
(
data
callback
)
{
var
self
=
this
;
var
globalOptions
=
this
.
_globalOptions
;
if
(
!
this
.
isSetup
(
)
)
return
;
data
=
this
.
_trimPacket
(
data
)
;
if
(
!
this
.
_globalOptions
.
allowDuplicates
&
&
this
.
_isRepeatData
(
data
)
)
{
this
.
_logDebug
(
'
warn
'
'
Raven
dropped
repeat
event
:
'
data
)
;
return
;
}
this
.
_lastEventId
=
data
.
event_id
|
|
(
data
.
event_id
=
this
.
_getUuid
(
)
)
;
this
.
_lastData
=
data
;
this
.
_logDebug
(
'
debug
'
'
Raven
about
to
send
:
'
data
)
;
var
auth
=
{
sentry_version
:
'
7
'
sentry_client
:
'
raven
-
js
/
'
+
this
.
VERSION
sentry_key
:
this
.
_globalKey
}
;
if
(
this
.
_globalSecret
)
{
auth
.
sentry_secret
=
this
.
_globalSecret
;
}
var
exception
=
data
.
exception
&
&
data
.
exception
.
values
[
0
]
;
if
(
this
.
_globalOptions
.
autoBreadcrumbs
&
&
this
.
_globalOptions
.
autoBreadcrumbs
.
sentry
)
{
this
.
captureBreadcrumb
(
{
category
:
'
sentry
'
message
:
exception
?
(
exception
.
type
?
exception
.
type
+
'
:
'
:
'
'
)
+
exception
.
value
:
data
.
message
event_id
:
data
.
event_id
level
:
data
.
level
|
|
'
error
'
}
)
;
}
var
url
=
this
.
_globalEndpoint
;
(
globalOptions
.
transport
|
|
this
.
_makeRequest
)
.
call
(
this
{
url
:
url
auth
:
auth
data
:
data
options
:
globalOptions
onSuccess
:
function
success
(
)
{
self
.
_resetBackoff
(
)
;
self
.
_triggerEvent
(
'
success
'
{
data
:
data
src
:
url
}
)
;
callback
&
&
callback
(
)
;
}
onError
:
function
failure
(
error
)
{
self
.
_logDebug
(
'
error
'
'
Raven
transport
failed
to
send
:
'
error
)
;
if
(
error
.
request
)
{
self
.
_setBackoffState
(
error
.
request
)
;
}
self
.
_triggerEvent
(
'
failure
'
{
data
:
data
src
:
url
}
)
;
error
=
error
|
|
new
Error
(
'
Raven
send
failed
(
no
additional
details
provided
)
'
)
;
callback
&
&
callback
(
error
)
;
}
}
)
;
}
_makeRequest
:
function
(
opts
)
{
var
url
=
opts
.
url
+
'
?
'
+
urlencode
(
opts
.
auth
)
;
var
evaluatedHeaders
=
null
;
var
evaluatedFetchParameters
=
{
}
;
if
(
opts
.
options
.
headers
)
{
evaluatedHeaders
=
this
.
_evaluateHash
(
opts
.
options
.
headers
)
;
}
if
(
opts
.
options
.
fetchParameters
)
{
evaluatedFetchParameters
=
this
.
_evaluateHash
(
opts
.
options
.
fetchParameters
)
;
}
if
(
supportsFetch
(
)
)
{
evaluatedFetchParameters
.
body
=
stringify
(
opts
.
data
)
;
var
defaultFetchOptions
=
objectMerge
(
{
}
this
.
_fetchDefaults
)
;
var
fetchOptions
=
objectMerge
(
defaultFetchOptions
evaluatedFetchParameters
)
;
if
(
evaluatedHeaders
)
{
fetchOptions
.
headers
=
evaluatedHeaders
;
}
return
_window
.
fetch
(
url
fetchOptions
)
.
then
(
function
(
response
)
{
if
(
response
.
ok
)
{
opts
.
onSuccess
&
&
opts
.
onSuccess
(
)
;
}
else
{
var
error
=
new
Error
(
'
Sentry
error
code
:
'
+
response
.
status
)
;
error
.
request
=
response
;
opts
.
onError
&
&
opts
.
onError
(
error
)
;
}
}
)
[
'
catch
'
]
(
function
(
)
{
opts
.
onError
&
&
opts
.
onError
(
new
Error
(
'
Sentry
error
code
:
network
unavailable
'
)
)
;
}
)
;
}
var
request
=
_window
.
XMLHttpRequest
&
&
new
_window
.
XMLHttpRequest
(
)
;
if
(
!
request
)
return
;
var
hasCORS
=
'
withCredentials
'
in
request
|
|
typeof
XDomainRequest
!
=
=
'
undefined
'
;
if
(
!
hasCORS
)
return
;
if
(
'
withCredentials
'
in
request
)
{
request
.
onreadystatechange
=
function
(
)
{
if
(
request
.
readyState
!
=
=
4
)
{
return
;
}
else
if
(
request
.
status
=
=
=
200
)
{
opts
.
onSuccess
&
&
opts
.
onSuccess
(
)
;
}
else
if
(
opts
.
onError
)
{
var
err
=
new
Error
(
'
Sentry
error
code
:
'
+
request
.
status
)
;
err
.
request
=
request
;
opts
.
onError
(
err
)
;
}
}
;
}
else
{
request
=
new
XDomainRequest
(
)
;
url
=
url
.
replace
(
/
^
https
?
:
/
'
'
)
;
if
(
opts
.
onSuccess
)
{
request
.
onload
=
opts
.
onSuccess
;
}
if
(
opts
.
onError
)
{
request
.
onerror
=
function
(
)
{
var
err
=
new
Error
(
'
Sentry
error
code
:
XDomainRequest
'
)
;
err
.
request
=
request
;
opts
.
onError
(
err
)
;
}
;
}
}
request
.
open
(
'
POST
'
url
)
;
if
(
evaluatedHeaders
)
{
each
(
evaluatedHeaders
function
(
key
value
)
{
request
.
setRequestHeader
(
key
value
)
;
}
)
;
}
request
.
send
(
stringify
(
opts
.
data
)
)
;
}
_evaluateHash
:
function
(
hash
)
{
var
evaluated
=
{
}
;
for
(
var
key
in
hash
)
{
if
(
hash
.
hasOwnProperty
(
key
)
)
{
var
value
=
hash
[
key
]
;
evaluated
[
key
]
=
typeof
value
=
=
=
'
function
'
?
value
(
)
:
value
;
}
}
return
evaluated
;
}
_logDebug
:
function
(
level
)
{
if
(
this
.
_originalConsoleMethods
[
level
]
&
&
this
.
debug
)
{
Function
.
prototype
.
apply
.
call
(
this
.
_originalConsoleMethods
[
level
]
this
.
_originalConsole
[
]
.
slice
.
call
(
arguments
1
)
)
;
}
}
_mergeContext
:
function
(
key
context
)
{
if
(
isUndefined
(
context
)
)
{
delete
this
.
_globalContext
[
key
]
;
}
else
{
this
.
_globalContext
[
key
]
=
objectMerge
(
this
.
_globalContext
[
key
]
|
|
{
}
context
)
;
}
}
}
;
Raven
.
prototype
.
setUser
=
Raven
.
prototype
.
setUserContext
;
Raven
.
prototype
.
setReleaseContext
=
Raven
.
prototype
.
setRelease
;
module
.
exports
=
Raven
;
}
)
.
call
(
this
typeof
global
!
=
=
"
undefined
"
?
global
:
typeof
self
!
=
=
"
undefined
"
?
self
:
typeof
window
!
=
=
"
undefined
"
?
window
:
{
}
)
}
{
"
1
"
:
1
"
2
"
:
2
"
5
"
:
5
"
6
"
:
6
"
7
"
:
7
"
8
"
:
8
}
]
4
:
[
function
(
_dereq_
module
exports
)
{
(
function
(
global
)
{
var
RavenConstructor
=
_dereq_
(
3
)
;
var
_window
=
typeof
window
!
=
=
'
undefined
'
?
window
:
typeof
global
!
=
=
'
undefined
'
?
global
:
typeof
self
!
=
=
'
undefined
'
?
self
:
{
}
;
var
_Raven
=
_window
.
Raven
;
var
Raven
=
new
RavenConstructor
(
)
;
Raven
.
noConflict
=
function
(
)
{
_window
.
Raven
=
_Raven
;
return
Raven
;
}
;
Raven
.
afterLoad
(
)
;
module
.
exports
=
Raven
;
module
.
exports
.
Client
=
RavenConstructor
;
}
)
.
call
(
this
typeof
global
!
=
=
"
undefined
"
?
global
:
typeof
self
!
=
=
"
undefined
"
?
self
:
typeof
window
!
=
=
"
undefined
"
?
window
:
{
}
)
}
{
"
3
"
:
3
}
]
5
:
[
function
(
_dereq_
module
exports
)
{
(
function
(
global
)
{
var
stringify
=
_dereq_
(
7
)
;
var
_window
=
typeof
window
!
=
=
'
undefined
'
?
window
:
typeof
global
!
=
=
'
undefined
'
?
global
:
typeof
self
!
=
=
'
undefined
'
?
self
:
{
}
;
function
isObject
(
what
)
{
return
typeof
what
=
=
=
'
object
'
&
&
what
!
=
=
null
;
}
function
isError
(
value
)
{
switch
(
{
}
.
toString
.
call
(
value
)
)
{
case
'
[
object
Error
]
'
:
return
true
;
case
'
[
object
Exception
]
'
:
return
true
;
case
'
[
object
DOMException
]
'
:
return
true
;
default
:
return
value
instanceof
Error
;
}
}
function
isErrorEvent
(
value
)
{
return
supportsErrorEvent
(
)
&
&
{
}
.
toString
.
call
(
value
)
=
=
=
'
[
object
ErrorEvent
]
'
;
}
function
isUndefined
(
what
)
{
return
what
=
=
=
void
0
;
}
function
isFunction
(
what
)
{
return
typeof
what
=
=
=
'
function
'
;
}
function
isPlainObject
(
what
)
{
return
Object
.
prototype
.
toString
.
call
(
what
)
=
=
=
'
[
object
Object
]
'
;
}
function
isString
(
what
)
{
return
Object
.
prototype
.
toString
.
call
(
what
)
=
=
=
'
[
object
String
]
'
;
}
function
isArray
(
what
)
{
return
Object
.
prototype
.
toString
.
call
(
what
)
=
=
=
'
[
object
Array
]
'
;
}
function
isEmptyObject
(
what
)
{
if
(
!
isPlainObject
(
what
)
)
return
false
;
for
(
var
_
in
what
)
{
if
(
what
.
hasOwnProperty
(
_
)
)
{
return
false
;
}
}
return
true
;
}
function
supportsErrorEvent
(
)
{
try
{
new
ErrorEvent
(
'
'
)
;
return
true
;
}
catch
(
e
)
{
return
false
;
}
}
function
supportsFetch
(
)
{
if
(
!
(
'
fetch
'
in
_window
)
)
return
false
;
try
{
new
Headers
(
)
;
new
Request
(
'
'
)
;
new
Response
(
)
;
return
true
;
}
catch
(
e
)
{
return
false
;
}
}
function
supportsReferrerPolicy
(
)
{
if
(
!
supportsFetch
(
)
)
return
false
;
try
{
new
Request
(
'
pickleRick
'
{
referrerPolicy
:
'
origin
'
}
)
;
return
true
;
}
catch
(
e
)
{
return
false
;
}
}
function
supportsPromiseRejectionEvent
(
)
{
return
typeof
PromiseRejectionEvent
=
=
=
'
function
'
;
}
function
wrappedCallback
(
callback
)
{
function
dataCallback
(
data
original
)
{
var
normalizedData
=
callback
(
data
)
|
|
data
;
if
(
original
)
{
return
original
(
normalizedData
)
|
|
normalizedData
;
}
return
normalizedData
;
}
return
dataCallback
;
}
function
each
(
obj
callback
)
{
var
i
j
;
if
(
isUndefined
(
obj
.
length
)
)
{
for
(
i
in
obj
)
{
if
(
hasKey
(
obj
i
)
)
{
callback
.
call
(
null
i
obj
[
i
]
)
;
}
}
}
else
{
j
=
obj
.
length
;
if
(
j
)
{
for
(
i
=
0
;
i
<
j
;
i
+
+
)
{
callback
.
call
(
null
i
obj
[
i
]
)
;
}
}
}
}
function
objectMerge
(
obj1
obj2
)
{
if
(
!
obj2
)
{
return
obj1
;
}
each
(
obj2
function
(
key
value
)
{
obj1
[
key
]
=
value
;
}
)
;
return
obj1
;
}
function
objectFrozen
(
obj
)
{
if
(
!
Object
.
isFrozen
)
{
return
false
;
}
return
Object
.
isFrozen
(
obj
)
;
}
function
truncate
(
str
max
)
{
return
!
max
|
|
str
.
length
<
=
max
?
str
:
str
.
substr
(
0
max
)
+
'
\
u2026
'
;
}
function
hasKey
(
object
key
)
{
return
Object
.
prototype
.
hasOwnProperty
.
call
(
object
key
)
;
}
function
joinRegExp
(
patterns
)
{
var
sources
=
[
]
i
=
0
len
=
patterns
.
length
pattern
;
for
(
;
i
<
len
;
i
+
+
)
{
pattern
=
patterns
[
i
]
;
if
(
isString
(
pattern
)
)
{
sources
.
push
(
pattern
.
replace
(
/
(
[
.
*
+
?
^
=
!
:
{
}
(
)
|
\
[
\
]
\
/
\
\
]
)
/
g
'
\
\
1
'
)
)
;
}
else
if
(
pattern
&
&
pattern
.
source
)
{
sources
.
push
(
pattern
.
source
)
;
}
}
return
new
RegExp
(
sources
.
join
(
'
|
'
)
'
i
'
)
;
}
function
urlencode
(
o
)
{
var
pairs
=
[
]
;
each
(
o
function
(
key
value
)
{
pairs
.
push
(
encodeURIComponent
(
key
)
+
'
=
'
+
encodeURIComponent
(
value
)
)
;
}
)
;
return
pairs
.
join
(
'
&
'
)
;
}
function
parseUrl
(
url
)
{
if
(
typeof
url
!
=
=
'
string
'
)
return
{
}
;
var
match
=
url
.
match
(
/
^
(
(
[
^
:
\
/
?
#
]
+
)
:
)
?
(
\
/
\
/
(
[
^
\
/
?
#
]
*
)
)
?
(
[
^
?
#
]
*
)
(
\
?
(
[
^
#
]
*
)
)
?
(
#
(
.
*
)
)
?
/
)
;
var
query
=
match
[
6
]
|
|
'
'
;
var
fragment
=
match
[
8
]
|
|
'
'
;
return
{
protocol
:
match
[
2
]
host
:
match
[
4
]
path
:
match
[
5
]
relative
:
match
[
5
]
+
query
+
fragment
}
;
}
function
uuid4
(
)
{
var
crypto
=
_window
.
crypto
|
|
_window
.
msCrypto
;
if
(
!
isUndefined
(
crypto
)
&
&
crypto
.
getRandomValues
)
{
var
arr
=
new
Uint16Array
(
8
)
;
crypto
.
getRandomValues
(
arr
)
;
arr
[
3
]
=
(
arr
[
3
]
&
0xfff
)
|
0x4000
;
arr
[
4
]
=
(
arr
[
4
]
&
0x3fff
)
|
0x8000
;
var
pad
=
function
(
num
)
{
var
v
=
num
.
toString
(
16
)
;
while
(
v
.
length
<
4
)
{
v
=
'
0
'
+
v
;
}
return
v
;
}
;
return
(
pad
(
arr
[
0
]
)
+
pad
(
arr
[
1
]
)
+
pad
(
arr
[
2
]
)
+
pad
(
arr
[
3
]
)
+
pad
(
arr
[
4
]
)
+
pad
(
arr
[
5
]
)
+
pad
(
arr
[
6
]
)
+
pad
(
arr
[
7
]
)
)
;
}
else
{
return
'
xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx
'
.
replace
(
/
[
xy
]
/
g
function
(
c
)
{
var
r
=
(
Math
.
random
(
)
*
16
)
|
0
v
=
c
=
=
=
'
x
'
?
r
:
(
r
&
0x3
)
|
0x8
;
return
v
.
toString
(
16
)
;
}
)
;
}
}
function
htmlTreeAsString
(
elem
)
{
var
MAX_TRAVERSE_HEIGHT
=
5
MAX_OUTPUT_LEN
=
80
out
=
[
]
height
=
0
len
=
0
separator
=
'
>
'
sepLength
=
separator
.
length
nextStr
;
while
(
elem
&
&
height
+
+
<
MAX_TRAVERSE_HEIGHT
)
{
nextStr
=
htmlElementAsString
(
elem
)
;
if
(
nextStr
=
=
=
'
html
'
|
|
(
height
>
1
&
&
len
+
out
.
length
*
sepLength
+
nextStr
.
length
>
=
MAX_OUTPUT_LEN
)
)
{
break
;
}
out
.
push
(
nextStr
)
;
len
+
=
nextStr
.
length
;
elem
=
elem
.
parentNode
;
}
return
out
.
reverse
(
)
.
join
(
separator
)
;
}
function
htmlElementAsString
(
elem
)
{
var
out
=
[
]
className
classes
key
attr
i
;
if
(
!
elem
|
|
!
elem
.
tagName
)
{
return
'
'
;
}
out
.
push
(
elem
.
tagName
.
toLowerCase
(
)
)
;
if
(
elem
.
id
)
{
out
.
push
(
'
#
'
+
elem
.
id
)
;
}
className
=
elem
.
className
;
if
(
className
&
&
isString
(
className
)
)
{
classes
=
className
.
split
(
/
\
s
+
/
)
;
for
(
i
=
0
;
i
<
classes
.
length
;
i
+
+
)
{
out
.
push
(
'
.
'
+
classes
[
i
]
)
;
}
}
var
attrWhitelist
=
[
'
type
'
'
name
'
'
title
'
'
alt
'
]
;
for
(
i
=
0
;
i
<
attrWhitelist
.
length
;
i
+
+
)
{
key
=
attrWhitelist
[
i
]
;
attr
=
elem
.
getAttribute
(
key
)
;
if
(
attr
)
{
out
.
push
(
'
[
'
+
key
+
'
=
"
'
+
attr
+
'
"
]
'
)
;
}
}
return
out
.
join
(
'
'
)
;
}
function
isOnlyOneTruthy
(
a
b
)
{
return
!
!
(
!
!
a
^
!
!
b
)
;
}
function
isBothUndefined
(
a
b
)
{
return
isUndefined
(
a
)
&
&
isUndefined
(
b
)
;
}
function
isSameException
(
ex1
ex2
)
{
if
(
isOnlyOneTruthy
(
ex1
ex2
)
)
return
false
;
ex1
=
ex1
.
values
[
0
]
;
ex2
=
ex2
.
values
[
0
]
;
if
(
ex1
.
type
!
=
=
ex2
.
type
|
|
ex1
.
value
!
=
=
ex2
.
value
)
return
false
;
if
(
isBothUndefined
(
ex1
.
stacktrace
ex2
.
stacktrace
)
)
return
false
;
return
isSameStacktrace
(
ex1
.
stacktrace
ex2
.
stacktrace
)
;
}
function
isSameStacktrace
(
stack1
stack2
)
{
if
(
isOnlyOneTruthy
(
stack1
stack2
)
)
return
false
;
var
frames1
=
stack1
.
frames
;
var
frames2
=
stack2
.
frames
;
if
(
frames1
.
length
!
=
=
frames2
.
length
)
return
false
;
var
a
b
;
for
(
var
i
=
0
;
i
<
frames1
.
length
;
i
+
+
)
{
a
=
frames1
[
i
]
;
b
=
frames2
[
i
]
;
if
(
a
.
filename
!
=
=
b
.
filename
|
|
a
.
lineno
!
=
=
b
.
lineno
|
|
a
.
colno
!
=
=
b
.
colno
|
|
a
[
'
function
'
]
!
=
=
b
[
'
function
'
]
)
return
false
;
}
return
true
;
}
function
fill
(
obj
name
replacement
track
)
{
if
(
obj
=
=
null
)
return
;
var
orig
=
obj
[
name
]
;
obj
[
name
]
=
replacement
(
orig
)
;
obj
[
name
]
.
__raven__
=
true
;
obj
[
name
]
.
__orig__
=
orig
;
if
(
track
)
{
track
.
push
(
[
obj
name
orig
]
)
;
}
}
function
safeJoin
(
input
delimiter
)
{
if
(
!
isArray
(
input
)
)
return
'
'
;
var
output
=
[
]
;
for
(
var
i
=
0
;
i
<
input
.
length
;
i
+
+
)
{
try
{
output
.
push
(
String
(
input
[
i
]
)
)
;
}
catch
(
e
)
{
output
.
push
(
'
[
value
cannot
be
serialized
]
'
)
;
}
}
return
output
.
join
(
delimiter
)
;
}
var
MAX_SERIALIZE_EXCEPTION_DEPTH
=
3
;
var
MAX_SERIALIZE_EXCEPTION_SIZE
=
50
*
1024
;
var
MAX_SERIALIZE_KEYS_LENGTH
=
40
;
function
utf8Length
(
value
)
{
return
~
-
encodeURI
(
value
)
.
split
(
/
%
.
.
|
.
/
)
.
length
;
}
function
jsonSize
(
value
)
{
return
utf8Length
(
JSON
.
stringify
(
value
)
)
;
}
function
serializeValue
(
value
)
{
var
maxLength
=
40
;
if
(
typeof
value
=
=
=
'
string
'
)
{
return
value
.
length
<
=
maxLength
?
value
:
value
.
substr
(
0
maxLength
-
1
)
+
'
\
u2026
'
;
}
else
if
(
typeof
value
=
=
=
'
number
'
|
|
typeof
value
=
=
=
'
boolean
'
|
|
typeof
value
=
=
=
'
undefined
'
)
{
return
value
;
}
var
type
=
Object
.
prototype
.
toString
.
call
(
value
)
;
if
(
type
=
=
=
'
[
object
Object
]
'
)
return
'
[
Object
]
'
;
if
(
type
=
=
=
'
[
object
Array
]
'
)
return
'
[
Array
]
'
;
if
(
type
=
=
=
'
[
object
Function
]
'
)
return
value
.
name
?
'
[
Function
:
'
+
value
.
name
+
'
]
'
:
'
[
Function
]
'
;
return
value
;
}
function
serializeObject
(
value
depth
)
{
if
(
depth
=
=
=
0
)
return
serializeValue
(
value
)
;
if
(
isPlainObject
(
value
)
)
{
return
Object
.
keys
(
value
)
.
reduce
(
function
(
acc
key
)
{
acc
[
key
]
=
serializeObject
(
value
[
key
]
depth
-
1
)
;
return
acc
;
}
{
}
)
;
}
else
if
(
Array
.
isArray
(
value
)
)
{
return
value
.
map
(
function
(
val
)
{
return
serializeObject
(
val
depth
-
1
)
;
}
)
;
}
return
serializeValue
(
value
)
;
}
function
serializeException
(
ex
depth
maxSize
)
{
if
(
!
isPlainObject
(
ex
)
)
return
ex
;
depth
=
typeof
depth
!
=
=
'
number
'
?
MAX_SERIALIZE_EXCEPTION_DEPTH
:
depth
;
maxSize
=
typeof
depth
!
=
=
'
number
'
?
MAX_SERIALIZE_EXCEPTION_SIZE
:
maxSize
;
var
serialized
=
serializeObject
(
ex
depth
)
;
if
(
jsonSize
(
stringify
(
serialized
)
)
>
maxSize
)
{
return
serializeException
(
ex
depth
-
1
)
;
}
return
serialized
;
}
function
serializeKeysForMessage
(
keys
maxLength
)
{
if
(
typeof
keys
=
=
=
'
number
'
|
|
typeof
keys
=
=
=
'
string
'
)
return
keys
.
toString
(
)
;
if
(
!
Array
.
isArray
(
keys
)
)
return
'
'
;
keys
=
keys
.
filter
(
function
(
key
)
{
return
typeof
key
=
=
=
'
string
'
;
}
)
;
if
(
keys
.
length
=
=
=
0
)
return
'
[
object
has
no
keys
]
'
;
maxLength
=
typeof
maxLength
!
=
=
'
number
'
?
MAX_SERIALIZE_KEYS_LENGTH
:
maxLength
;
if
(
keys
[
0
]
.
length
>
=
maxLength
)
return
keys
[
0
]
;
for
(
var
usedKeys
=
keys
.
length
;
usedKeys
>
0
;
usedKeys
-
-
)
{
var
serialized
=
keys
.
slice
(
0
usedKeys
)
.
join
(
'
'
)
;
if
(
serialized
.
length
>
maxLength
)
continue
;
if
(
usedKeys
=
=
=
keys
.
length
)
return
serialized
;
return
serialized
+
'
\
u2026
'
;
}
return
'
'
;
}
function
sanitize
(
input
sanitizeKeys
)
{
if
(
!
isArray
(
sanitizeKeys
)
|
|
(
isArray
(
sanitizeKeys
)
&
&
sanitizeKeys
.
length
=
=
=
0
)
)
return
input
;
var
sanitizeRegExp
=
joinRegExp
(
sanitizeKeys
)
;
var
sanitizeMask
=
'
*
*
*
*
*
*
*
*
'
;
var
safeInput
;
try
{
safeInput
=
JSON
.
parse
(
stringify
(
input
)
)
;
}
catch
(
o_O
)
{
return
input
;
}
function
sanitizeWorker
(
workerInput
)
{
if
(
isArray
(
workerInput
)
)
{
return
workerInput
.
map
(
function
(
val
)
{
return
sanitizeWorker
(
val
)
;
}
)
;
}
if
(
isPlainObject
(
workerInput
)
)
{
return
Object
.
keys
(
workerInput
)
.
reduce
(
function
(
acc
k
)
{
if
(
sanitizeRegExp
.
test
(
k
)
)
{
acc
[
k
]
=
sanitizeMask
;
}
else
{
acc
[
k
]
=
sanitizeWorker
(
workerInput
[
k
]
)
;
}
return
acc
;
}
{
}
)
;
}
return
workerInput
;
}
return
sanitizeWorker
(
safeInput
)
;
}
module
.
exports
=
{
isObject
:
isObject
isError
:
isError
isErrorEvent
:
isErrorEvent
isUndefined
:
isUndefined
isFunction
:
isFunction
isPlainObject
:
isPlainObject
isString
:
isString
isArray
:
isArray
isEmptyObject
:
isEmptyObject
supportsErrorEvent
:
supportsErrorEvent
supportsFetch
:
supportsFetch
supportsReferrerPolicy
:
supportsReferrerPolicy
supportsPromiseRejectionEvent
:
supportsPromiseRejectionEvent
wrappedCallback
:
wrappedCallback
each
:
each
objectMerge
:
objectMerge
truncate
:
truncate
objectFrozen
:
objectFrozen
hasKey
:
hasKey
joinRegExp
:
joinRegExp
urlencode
:
urlencode
uuid4
:
uuid4
htmlTreeAsString
:
htmlTreeAsString
htmlElementAsString
:
htmlElementAsString
isSameException
:
isSameException
isSameStacktrace
:
isSameStacktrace
parseUrl
:
parseUrl
fill
:
fill
safeJoin
:
safeJoin
serializeException
:
serializeException
serializeKeysForMessage
:
serializeKeysForMessage
sanitize
:
sanitize
}
;
}
)
.
call
(
this
typeof
global
!
=
=
"
undefined
"
?
global
:
typeof
self
!
=
=
"
undefined
"
?
self
:
typeof
window
!
=
=
"
undefined
"
?
window
:
{
}
)
}
{
"
7
"
:
7
}
]
6
:
[
function
(
_dereq_
module
exports
)
{
(
function
(
global
)
{
var
utils
=
_dereq_
(
5
)
;
var
TraceKit
=
{
collectWindowErrors
:
true
debug
:
false
}
;
var
_window
=
typeof
window
!
=
=
'
undefined
'
?
window
:
typeof
global
!
=
=
'
undefined
'
?
global
:
typeof
self
!
=
=
'
undefined
'
?
self
:
{
}
;
var
_slice
=
[
]
.
slice
;
var
UNKNOWN_FUNCTION
=
'
?
'
;
var
ERROR_TYPES_RE
=
/
^
(
?
:
[
Uu
]
ncaught
(
?
:
exception
:
)
?
)
?
(
?
:
(
(
?
:
Eval
|
Internal
|
Range
|
Reference
|
Syntax
|
Type
|
URI
|
)
Error
)
:
)
?
(
.
*
)
/
;
function
getLocationHref
(
)
{
if
(
typeof
document
=
=
=
'
undefined
'
|
|
document
.
location
=
=
null
)
return
'
'
;
return
document
.
location
.
href
;
}
TraceKit
.
report
=
(
function
reportModuleWrapper
(
)
{
var
handlers
=
[
]
lastArgs
=
null
lastException
=
null
lastExceptionStack
=
null
;
function
subscribe
(
handler
)
{
installGlobalHandler
(
)
;
handlers
.
push
(
handler
)
;
}
function
unsubscribe
(
handler
)
{
for
(
var
i
=
handlers
.
length
-
1
;
i
>
=
0
;
-
-
i
)
{
if
(
handlers
[
i
]
=
=
=
handler
)
{
handlers
.
splice
(
i
1
)
;
}
}
}
function
unsubscribeAll
(
)
{
uninstallGlobalHandler
(
)
;
handlers
=
[
]
;
}
function
notifyHandlers
(
stack
isWindowError
)
{
var
exception
=
null
;
if
(
isWindowError
&
&
!
TraceKit
.
collectWindowErrors
)
{
return
;
}
for
(
var
i
in
handlers
)
{
if
(
handlers
.
hasOwnProperty
(
i
)
)
{
try
{
handlers
[
i
]
.
apply
(
null
[
stack
]
.
concat
(
_slice
.
call
(
arguments
2
)
)
)
;
}
catch
(
inner
)
{
exception
=
inner
;
}
}
}
if
(
exception
)
{
throw
exception
;
}
}
var
_oldOnerrorHandler
_onErrorHandlerInstalled
;
function
traceKitWindowOnError
(
msg
url
lineNo
colNo
ex
)
{
var
stack
=
null
;
var
exception
=
utils
.
isErrorEvent
(
ex
)
?
ex
.
error
:
ex
;
var
message
=
utils
.
isErrorEvent
(
msg
)
?
msg
.
message
:
msg
;
if
(
lastExceptionStack
)
{
TraceKit
.
computeStackTrace
.
augmentStackTraceWithInitialElement
(
lastExceptionStack
url
lineNo
message
)
;
processLastException
(
)
;
}
else
if
(
exception
&
&
utils
.
isError
(
exception
)
)
{
stack
=
TraceKit
.
computeStackTrace
(
exception
)
;
notifyHandlers
(
stack
true
)
;
}
else
{
var
location
=
{
url
:
url
line
:
lineNo
column
:
colNo
}
;
var
name
=
undefined
;
var
groups
;
if
(
{
}
.
toString
.
call
(
message
)
=
=
=
'
[
object
String
]
'
)
{
var
groups
=
message
.
match
(
ERROR_TYPES_RE
)
;
if
(
groups
)
{
name
=
groups
[
1
]
;
message
=
groups
[
2
]
;
}
}
location
.
func
=
UNKNOWN_FUNCTION
;
stack
=
{
name
:
name
message
:
message
url
:
getLocationHref
(
)
stack
:
[
location
]
}
;
notifyHandlers
(
stack
true
)
;
}
if
(
_oldOnerrorHandler
)
{
return
_oldOnerrorHandler
.
apply
(
this
arguments
)
;
}
return
false
;
}
function
installGlobalHandler
(
)
{
if
(
_onErrorHandlerInstalled
)
{
return
;
}
_oldOnerrorHandler
=
_window
.
onerror
;
_window
.
onerror
=
traceKitWindowOnError
;
_onErrorHandlerInstalled
=
true
;
}
function
uninstallGlobalHandler
(
)
{
if
(
!
_onErrorHandlerInstalled
)
{
return
;
}
_window
.
onerror
=
_oldOnerrorHandler
;
_onErrorHandlerInstalled
=
false
;
_oldOnerrorHandler
=
undefined
;
}
function
processLastException
(
)
{
var
_lastExceptionStack
=
lastExceptionStack
_lastArgs
=
lastArgs
;
lastArgs
=
null
;
lastExceptionStack
=
null
;
lastException
=
null
;
notifyHandlers
.
apply
(
null
[
_lastExceptionStack
false
]
.
concat
(
_lastArgs
)
)
;
}
function
report
(
ex
rethrow
)
{
var
args
=
_slice
.
call
(
arguments
1
)
;
if
(
lastExceptionStack
)
{
if
(
lastException
=
=
=
ex
)
{
return
;
}
else
{
processLastException
(
)
;
}
}
var
stack
=
TraceKit
.
computeStackTrace
(
ex
)
;
lastExceptionStack
=
stack
;
lastException
=
ex
;
lastArgs
=
args
;
setTimeout
(
function
(
)
{
if
(
lastException
=
=
=
ex
)
{
processLastException
(
)
;
}
}
stack
.
incomplete
?
2000
:
0
)
;
if
(
rethrow
!
=
=
false
)
{
throw
ex
;
}
}
report
.
subscribe
=
subscribe
;
report
.
unsubscribe
=
unsubscribe
;
report
.
uninstall
=
unsubscribeAll
;
return
report
;
}
)
(
)
;
TraceKit
.
computeStackTrace
=
(
function
computeStackTraceWrapper
(
)
{
function
computeStackTraceFromStackProp
(
ex
)
{
if
(
typeof
ex
.
stack
=
=
=
'
undefined
'
|
|
!
ex
.
stack
)
return
;
var
chrome
=
/
^
\
s
*
at
(
?
:
(
.
*
?
)
?
\
(
)
?
(
(
?
:
file
|
https
?
|
blob
|
chrome
-
extension
|
native
|
eval
|
webpack
|
<
anonymous
>
|
[
a
-
z
]
:
|
\
/
)
.
*
?
)
(
?
:
:
(
\
d
+
)
)
?
(
?
:
:
(
\
d
+
)
)
?
\
)
?
\
s
*
/
i
;
var
winjs
=
/
^
\
s
*
at
(
?
:
(
(
?
:
\
[
object
object
\
]
)
?
.
+
)
)
?
\
(
?
(
(
?
:
file
|
ms
-
appx
(
?
:
-
web
)
|
https
?
|
webpack
|
blob
)
:
.
*
?
)
:
(
\
d
+
)
(
?
:
:
(
\
d
+
)
)
?
\
)
?
\
s
*
/
i
;
var
gecko
=
/
^
\
s
*
(
.
*
?
)
(
?
:
\
(
(
.
*
?
)
\
)
)
?
(
?
:
^
|
)
(
(
?
:
file
|
https
?
|
blob
|
chrome
|
webpack
|
resource
|
moz
-
extension
)
.
*
?
:
\
/
.
*
?
|
\
[
native
code
\
]
|
[
^
]
*
bundle
)
(
?
:
:
(
\
d
+
)
)
?
(
?
:
:
(
\
d
+
)
)
?
\
s
*
/
i
;
var
geckoEval
=
/
(
\
S
+
)
line
(
\
d
+
)
(
?
:
>
eval
line
\
d
+
)
*
>
eval
/
i
;
var
chromeEval
=
/
\
(
(
\
S
*
)
(
?
:
:
(
\
d
+
)
)
(
?
:
:
(
\
d
+
)
)
\
)
/
;
var
lines
=
ex
.
stack
.
split
(
'
\
n
'
)
;
var
stack
=
[
]
;
var
submatch
;
var
parts
;
var
element
;
var
reference
=
/
^
(
.
*
)
is
undefined
/
.
exec
(
ex
.
message
)
;
for
(
var
i
=
0
j
=
lines
.
length
;
i
<
j
;
+
+
i
)
{
if
(
(
parts
=
chrome
.
exec
(
lines
[
i
]
)
)
)
{
var
isNative
=
parts
[
2
]
&
&
parts
[
2
]
.
indexOf
(
'
native
'
)
=
=
=
0
;
var
isEval
=
parts
[
2
]
&
&
parts
[
2
]
.
indexOf
(
'
eval
'
)
=
=
=
0
;
if
(
isEval
&
&
(
submatch
=
chromeEval
.
exec
(
parts
[
2
]
)
)
)
{
parts
[
2
]
=
submatch
[
1
]
;
parts
[
3
]
=
submatch
[
2
]
;
parts
[
4
]
=
submatch
[
3
]
;
}
element
=
{
url
:
!
isNative
?
parts
[
2
]
:
null
func
:
parts
[
1
]
|
|
UNKNOWN_FUNCTION
args
:
isNative
?
[
parts
[
2
]
]
:
[
]
line
:
parts
[
3
]
?
+
parts
[
3
]
:
null
column
:
parts
[
4
]
?
+
parts
[
4
]
:
null
}
;
}
else
if
(
(
parts
=
winjs
.
exec
(
lines
[
i
]
)
)
)
{
element
=
{
url
:
parts
[
2
]
func
:
parts
[
1
]
|
|
UNKNOWN_FUNCTION
args
:
[
]
line
:
+
parts
[
3
]
column
:
parts
[
4
]
?
+
parts
[
4
]
:
null
}
;
}
else
if
(
(
parts
=
gecko
.
exec
(
lines
[
i
]
)
)
)
{
var
isEval
=
parts
[
3
]
&
&
parts
[
3
]
.
indexOf
(
'
>
eval
'
)
>
-
1
;
if
(
isEval
&
&
(
submatch
=
geckoEval
.
exec
(
parts
[
3
]
)
)
)
{
parts
[
3
]
=
submatch
[
1
]
;
parts
[
4
]
=
submatch
[
2
]
;
parts
[
5
]
=
null
;
}
else
if
(
i
=
=
=
0
&
&
!
parts
[
5
]
&
&
typeof
ex
.
columnNumber
!
=
=
'
undefined
'
)
{
stack
[
0
]
.
column
=
ex
.
columnNumber
+
1
;
}
element
=
{
url
:
parts
[
3
]
func
:
parts
[
1
]
|
|
UNKNOWN_FUNCTION
args
:
parts
[
2
]
?
parts
[
2
]
.
split
(
'
'
)
:
[
]
line
:
parts
[
4
]
?
+
parts
[
4
]
:
null
column
:
parts
[
5
]
?
+
parts
[
5
]
:
null
}
;
}
else
{
continue
;
}
if
(
!
element
.
func
&
&
element
.
line
)
{
element
.
func
=
UNKNOWN_FUNCTION
;
}
stack
.
push
(
element
)
;
}
if
(
!
stack
.
length
)
{
return
null
;
}
return
{
name
:
ex
.
name
message
:
ex
.
message
url
:
getLocationHref
(
)
stack
:
stack
}
;
}
function
augmentStackTraceWithInitialElement
(
stackInfo
url
lineNo
message
)
{
var
initial
=
{
url
:
url
line
:
lineNo
}
;
if
(
initial
.
url
&
&
initial
.
line
)
{
stackInfo
.
incomplete
=
false
;
if
(
!
initial
.
func
)
{
initial
.
func
=
UNKNOWN_FUNCTION
;
}
if
(
stackInfo
.
stack
.
length
>
0
)
{
if
(
stackInfo
.
stack
[
0
]
.
url
=
=
=
initial
.
url
)
{
if
(
stackInfo
.
stack
[
0
]
.
line
=
=
=
initial
.
line
)
{
return
false
;
}
else
if
(
!
stackInfo
.
stack
[
0
]
.
line
&
&
stackInfo
.
stack
[
0
]
.
func
=
=
=
initial
.
func
)
{
stackInfo
.
stack
[
0
]
.
line
=
initial
.
line
;
return
false
;
}
}
}
stackInfo
.
stack
.
unshift
(
initial
)
;
stackInfo
.
partial
=
true
;
return
true
;
}
else
{
stackInfo
.
incomplete
=
true
;
}
return
false
;
}
function
computeStackTraceByWalkingCallerChain
(
ex
depth
)
{
var
functionName
=
/
function
\
s
+
(
[
_
a
-
zA
-
Z
\
xA0
-
\
uFFFF
]
[
_
a
-
zA
-
Z0
-
9
\
xA0
-
\
uFFFF
]
*
)
?
\
s
*
\
(
/
i
stack
=
[
]
funcs
=
{
}
recursion
=
false
parts
item
source
;
for
(
var
curr
=
computeStackTraceByWalkingCallerChain
.
caller
;
curr
&
&
!
recursion
;
curr
=
curr
.
caller
)
{
if
(
curr
=
=
=
computeStackTrace
|
|
curr
=
=
=
TraceKit
.
report
)
{
continue
;
}
item
=
{
url
:
null
func
:
UNKNOWN_FUNCTION
line
:
null
column
:
null
}
;
if
(
curr
.
name
)
{
item
.
func
=
curr
.
name
;
}
else
if
(
(
parts
=
functionName
.
exec
(
curr
.
toString
(
)
)
)
)
{
item
.
func
=
parts
[
1
]
;
}
if
(
typeof
item
.
func
=
=
=
'
undefined
'
)
{
try
{
item
.
func
=
parts
.
input
.
substring
(
0
parts
.
input
.
indexOf
(
'
{
'
)
)
;
}
catch
(
e
)
{
}
}
if
(
funcs
[
'
'
+
curr
]
)
{
recursion
=
true
;
}
else
{
funcs
[
'
'
+
curr
]
=
true
;
}
stack
.
push
(
item
)
;
}
if
(
depth
)
{
stack
.
splice
(
0
depth
)
;
}
var
result
=
{
name
:
ex
.
name
message
:
ex
.
message
url
:
getLocationHref
(
)
stack
:
stack
}
;
augmentStackTraceWithInitialElement
(
result
ex
.
sourceURL
|
|
ex
.
fileName
ex
.
line
|
|
ex
.
lineNumber
ex
.
message
|
|
ex
.
description
)
;
return
result
;
}
function
computeStackTrace
(
ex
depth
)
{
var
stack
=
null
;
depth
=
depth
=
=
null
?
0
:
+
depth
;
try
{
stack
=
computeStackTraceFromStackProp
(
ex
)
;
if
(
stack
)
{
return
stack
;
}
}
catch
(
e
)
{
if
(
TraceKit
.
debug
)
{
throw
e
;
}
}
try
{
stack
=
computeStackTraceByWalkingCallerChain
(
ex
depth
+
1
)
;
if
(
stack
)
{
return
stack
;
}
}
catch
(
e
)
{
if
(
TraceKit
.
debug
)
{
throw
e
;
}
}
return
{
name
:
ex
.
name
message
:
ex
.
message
url
:
getLocationHref
(
)
}
;
}
computeStackTrace
.
augmentStackTraceWithInitialElement
=
augmentStackTraceWithInitialElement
;
computeStackTrace
.
computeStackTraceFromStackProp
=
computeStackTraceFromStackProp
;
return
computeStackTrace
;
}
)
(
)
;
module
.
exports
=
TraceKit
;
}
)
.
call
(
this
typeof
global
!
=
=
"
undefined
"
?
global
:
typeof
self
!
=
=
"
undefined
"
?
self
:
typeof
window
!
=
=
"
undefined
"
?
window
:
{
}
)
}
{
"
5
"
:
5
}
]
7
:
[
function
(
_dereq_
module
exports
)
{
exports
=
module
.
exports
=
stringify
;
exports
.
getSerialize
=
serializer
;
function
indexOf
(
haystack
needle
)
{
for
(
var
i
=
0
;
i
<
haystack
.
length
;
+
+
i
)
{
if
(
haystack
[
i
]
=
=
=
needle
)
return
i
;
}
return
-
1
;
}
function
stringify
(
obj
replacer
spaces
cycleReplacer
)
{
return
JSON
.
stringify
(
obj
serializer
(
replacer
cycleReplacer
)
spaces
)
;
}
function
stringifyError
(
value
)
{
var
err
=
{
stack
:
value
.
stack
message
:
value
.
message
name
:
value
.
name
}
;
for
(
var
i
in
value
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
value
i
)
)
{
err
[
i
]
=
value
[
i
]
;
}
}
return
err
;
}
function
serializer
(
replacer
cycleReplacer
)
{
var
stack
=
[
]
;
var
keys
=
[
]
;
if
(
cycleReplacer
=
=
null
)
{
cycleReplacer
=
function
(
key
value
)
{
if
(
stack
[
0
]
=
=
=
value
)
{
return
'
[
Circular
~
]
'
;
}
return
'
[
Circular
~
.
'
+
keys
.
slice
(
0
indexOf
(
stack
value
)
)
.
join
(
'
.
'
)
+
'
]
'
;
}
;
}
return
function
(
key
value
)
{
if
(
stack
.
length
>
0
)
{
var
thisPos
=
indexOf
(
stack
this
)
;
~
thisPos
?
stack
.
splice
(
thisPos
+
1
)
:
stack
.
push
(
this
)
;
~
thisPos
?
keys
.
splice
(
thisPos
Infinity
key
)
:
keys
.
push
(
key
)
;
if
(
~
indexOf
(
stack
value
)
)
{
value
=
cycleReplacer
.
call
(
this
key
value
)
;
}
}
else
{
stack
.
push
(
value
)
;
}
return
replacer
=
=
null
?
value
instanceof
Error
?
stringifyError
(
value
)
:
value
:
replacer
.
call
(
this
key
value
)
;
}
;
}
}
{
}
]
8
:
[
function
(
_dereq_
module
exports
)
{
function
safeAdd
(
x
y
)
{
var
lsw
=
(
x
&
0xffff
)
+
(
y
&
0xffff
)
;
var
msw
=
(
x
>
>
16
)
+
(
y
>
>
16
)
+
(
lsw
>
>
16
)
;
return
(
msw
<
<
16
)
|
(
lsw
&
0xffff
)
;
}
function
bitRotateLeft
(
num
cnt
)
{
return
(
num
<
<
cnt
)
|
(
num
>
>
>
(
32
-
cnt
)
)
;
}
function
md5cmn
(
q
a
b
x
s
t
)
{
return
safeAdd
(
bitRotateLeft
(
safeAdd
(
safeAdd
(
a
q
)
safeAdd
(
x
t
)
)
s
)
b
)
;
}
function
md5ff
(
a
b
c
d
x
s
t
)
{
return
md5cmn
(
(
b
&
c
)
|
(
~
b
&
d
)
a
b
x
s
t
)
;
}
function
md5gg
(
a
b
c
d
x
s
t
)
{
return
md5cmn
(
(
b
&
d
)
|
(
c
&
~
d
)
a
b
x
s
t
)
;
}
function
md5hh
(
a
b
c
d
x
s
t
)
{
return
md5cmn
(
b
^
c
^
d
a
b
x
s
t
)
;
}
function
md5ii
(
a
b
c
d
x
s
t
)
{
return
md5cmn
(
c
^
(
b
|
~
d
)
a
b
x
s
t
)
;
}
function
binlMD5
(
x
len
)
{
x
[
len
>
>
5
]
|
=
0x80
<
<
(
len
%
32
)
;
x
[
(
(
(
len
+
64
)
>
>
>
9
)
<
<
4
)
+
14
]
=
len
;
var
i
;
var
olda
;
var
oldb
;
var
oldc
;
var
oldd
;
var
a
=
1732584193
;
var
b
=
-
271733879
;
var
c
=
-
1732584194
;
var
d
=
271733878
;
for
(
i
=
0
;
i
<
x
.
length
;
i
+
=
16
)
{
olda
=
a
;
oldb
=
b
;
oldc
=
c
;
oldd
=
d
;
a
=
md5ff
(
a
b
c
d
x
[
i
]
7
-
680876936
)
;
d
=
md5ff
(
d
a
b
c
x
[
i
+
1
]
12
-
389564586
)
;
c
=
md5ff
(
c
d
a
b
x
[
i
+
2
]
17
606105819
)
;
b
=
md5ff
(
b
c
d
a
x
[
i
+
3
]
22
-
1044525330
)
;
a
=
md5ff
(
a
b
c
d
x
[
i
+
4
]
7
-
176418897
)
;
d
=
md5ff
(
d
a
b
c
x
[
i
+
5
]
12
1200080426
)
;
c
=
md5ff
(
c
d
a
b
x
[
i
+
6
]
17
-
1473231341
)
;
b
=
md5ff
(
b
c
d
a
x
[
i
+
7
]
22
-
45705983
)
;
a
=
md5ff
(
a
b
c
d
x
[
i
+
8
]
7
1770035416
)
;
d
=
md5ff
(
d
a
b
c
x
[
i
+
9
]
12
-
1958414417
)
;
c
=
md5ff
(
c
d
a
b
x
[
i
+
10
]
17
-
42063
)
;
b
=
md5ff
(
b
c
d
a
x
[
i
+
11
]
22
-
1990404162
)
;
a
=
md5ff
(
a
b
c
d
x
[
i
+
12
]
7
1804603682
)
;
d
=
md5ff
(
d
a
b
c
x
[
i
+
13
]
12
-
40341101
)
;
c
=
md5ff
(
c
d
a
b
x
[
i
+
14
]
17
-
1502002290
)
;
b
=
md5ff
(
b
c
d
a
x
[
i
+
15
]
22
1236535329
)
;
a
=
md5gg
(
a
b
c
d
x
[
i
+
1
]
5
-
165796510
)
;
d
=
md5gg
(
d
a
b
c
x
[
i
+
6
]
9
-
1069501632
)
;
c
=
md5gg
(
c
d
a
b
x
[
i
+
11
]
14
643717713
)
;
b
=
md5gg
(
b
c
d
a
x
[
i
]
20
-
373897302
)
;
a
=
md5gg
(
a
b
c
d
x
[
i
+
5
]
5
-
701558691
)
;
d
=
md5gg
(
d
a
b
c
x
[
i
+
10
]
9
38016083
)
;
c
=
md5gg
(
c
d
a
b
x
[
i
+
15
]
14
-
660478335
)
;
b
=
md5gg
(
b
c
d
a
x
[
i
+
4
]
20
-
405537848
)
;
a
=
md5gg
(
a
b
c
d
x
[
i
+
9
]
5
568446438
)
;
d
=
md5gg
(
d
a
b
c
x
[
i
+
14
]
9
-
1019803690
)
;
c
=
md5gg
(
c
d
a
b
x
[
i
+
3
]
14
-
187363961
)
;
b
=
md5gg
(
b
c
d
a
x
[
i
+
8
]
20
1163531501
)
;
a
=
md5gg
(
a
b
c
d
x
[
i
+
13
]
5
-
1444681467
)
;
d
=
md5gg
(
d
a
b
c
x
[
i
+
2
]
9
-
51403784
)
;
c
=
md5gg
(
c
d
a
b
x
[
i
+
7
]
14
1735328473
)
;
b
=
md5gg
(
b
c
d
a
x
[
i
+
12
]
20
-
1926607734
)
;
a
=
md5hh
(
a
b
c
d
x
[
i
+
5
]
4
-
378558
)
;
d
=
md5hh
(
d
a
b
c
x
[
i
+
8
]
11
-
2022574463
)
;
c
=
md5hh
(
c
d
a
b
x
[
i
+
11
]
16
1839030562
)
;
b
=
md5hh
(
b
c
d
a
x
[
i
+
14
]
23
-
35309556
)
;
a
=
md5hh
(
a
b
c
d
x
[
i
+
1
]
4
-
1530992060
)
;
d
=
md5hh
(
d
a
b
c
x
[
i
+
4
]
11
1272893353
)
;
c
=
md5hh
(
c
d
a
b
x
[
i
+
7
]
16
-
155497632
)
;
b
=
md5hh
(
b
c
d
a
x
[
i
+
10
]
23
-
1094730640
)
;
a
=
md5hh
(
a
b
c
d
x
[
i
+
13
]
4
681279174
)
;
d
=
md5hh
(
d
a
b
c
x
[
i
]
11
-
358537222
)
;
c
=
md5hh
(
c
d
a
b
x
[
i
+
3
]
16
-
722521979
)
;
b
=
md5hh
(
b
c
d
a
x
[
i
+
6
]
23
76029189
)
;
a
=
md5hh
(
a
b
c
d
x
[
i
+
9
]
4
-
640364487
)
;
d
=
md5hh
(
d
a
b
c
x
[
i
+
12
]
11
-
421815835
)
;
c
=
md5hh
(
c
d
a
b
x
[
i
+
15
]
16
530742520
)
;
b
=
md5hh
(
b
c
d
a
x
[
i
+
2
]
23
-
995338651
)
;
a
=
md5ii
(
a
b
c
d
x
[
i
]
6
-
198630844
)
;
d
=
md5ii
(
d
a
b
c
x
[
i
+
7
]
10
1126891415
)
;
c
=
md5ii
(
c
d
a
b
x
[
i
+
14
]
15
-
1416354905
)
;
b
=
md5ii
(
b
c
d
a
x
[
i
+
5
]
21
-
57434055
)
;
a
=
md5ii
(
a
b
c
d
x
[
i
+
12
]
6
1700485571
)
;
d
=
md5ii
(
d
a
b
c
x
[
i
+
3
]
10
-
1894986606
)
;
c
=
md5ii
(
c
d
a
b
x
[
i
+
10
]
15
-
1051523
)
;
b
=
md5ii
(
b
c
d
a
x
[
i
+
1
]
21
-
2054922799
)
;
a
=
md5ii
(
a
b
c
d
x
[
i
+
8
]
6
1873313359
)
;
d
=
md5ii
(
d
a
b
c
x
[
i
+
15
]
10
-
30611744
)
;
c
=
md5ii
(
c
d
a
b
x
[
i
+
6
]
15
-
1560198380
)
;
b
=
md5ii
(
b
c
d
a
x
[
i
+
13
]
21
1309151649
)
;
a
=
md5ii
(
a
b
c
d
x
[
i
+
4
]
6
-
145523070
)
;
d
=
md5ii
(
d
a
b
c
x
[
i
+
11
]
10
-
1120210379
)
;
c
=
md5ii
(
c
d
a
b
x
[
i
+
2
]
15
718787259
)
;
b
=
md5ii
(
b
c
d
a
x
[
i
+
9
]
21
-
343485551
)
;
a
=
safeAdd
(
a
olda
)
;
b
=
safeAdd
(
b
oldb
)
;
c
=
safeAdd
(
c
oldc
)
;
d
=
safeAdd
(
d
oldd
)
;
}
return
[
a
b
c
d
]
;
}
function
binl2rstr
(
input
)
{
var
i
;
var
output
=
'
'
;
var
length32
=
input
.
length
*
32
;
for
(
i
=
0
;
i
<
length32
;
i
+
=
8
)
{
output
+
=
String
.
fromCharCode
(
(
input
[
i
>
>
5
]
>
>
>
(
i
%
32
)
)
&
0xff
)
;
}
return
output
;
}
function
rstr2binl
(
input
)
{
var
i
;
var
output
=
[
]
;
output
[
(
input
.
length
>
>
2
)
-
1
]
=
undefined
;
for
(
i
=
0
;
i
<
output
.
length
;
i
+
=
1
)
{
output
[
i
]
=
0
;
}
var
length8
=
input
.
length
*
8
;
for
(
i
=
0
;
i
<
length8
;
i
+
=
8
)
{
output
[
i
>
>
5
]
|
=
(
input
.
charCodeAt
(
i
/
8
)
&
0xff
)
<
<
(
i
%
32
)
;
}
return
output
;
}
function
rstrMD5
(
s
)
{
return
binl2rstr
(
binlMD5
(
rstr2binl
(
s
)
s
.
length
*
8
)
)
;
}
function
rstrHMACMD5
(
key
data
)
{
var
i
;
var
bkey
=
rstr2binl
(
key
)
;
var
ipad
=
[
]
;
var
opad
=
[
]
;
var
hash
;
ipad
[
15
]
=
opad
[
15
]
=
undefined
;
if
(
bkey
.
length
>
16
)
{
bkey
=
binlMD5
(
bkey
key
.
length
*
8
)
;
}
for
(
i
=
0
;
i
<
16
;
i
+
=
1
)
{
ipad
[
i
]
=
bkey
[
i
]
^
0x36363636
;
opad
[
i
]
=
bkey
[
i
]
^
0x5c5c5c5c
;
}
hash
=
binlMD5
(
ipad
.
concat
(
rstr2binl
(
data
)
)
512
+
data
.
length
*
8
)
;
return
binl2rstr
(
binlMD5
(
opad
.
concat
(
hash
)
512
+
128
)
)
;
}
function
rstr2hex
(
input
)
{
var
hexTab
=
'
0123456789abcdef
'
;
var
output
=
'
'
;
var
x
;
var
i
;
for
(
i
=
0
;
i
<
input
.
length
;
i
+
=
1
)
{
x
=
input
.
charCodeAt
(
i
)
;
output
+
=
hexTab
.
charAt
(
(
x
>
>
>
4
)
&
0x0f
)
+
hexTab
.
charAt
(
x
&
0x0f
)
;
}
return
output
;
}
function
str2rstrUTF8
(
input
)
{
return
unescape
(
encodeURIComponent
(
input
)
)
;
}
function
rawMD5
(
s
)
{
return
rstrMD5
(
str2rstrUTF8
(
s
)
)
;
}
function
hexMD5
(
s
)
{
return
rstr2hex
(
rawMD5
(
s
)
)
;
}
function
rawHMACMD5
(
k
d
)
{
return
rstrHMACMD5
(
str2rstrUTF8
(
k
)
str2rstrUTF8
(
d
)
)
;
}
function
hexHMACMD5
(
k
d
)
{
return
rstr2hex
(
rawHMACMD5
(
k
d
)
)
;
}
function
md5
(
string
key
raw
)
{
if
(
!
key
)
{
if
(
!
raw
)
{
return
hexMD5
(
string
)
;
}
return
rawMD5
(
string
)
;
}
if
(
!
raw
)
{
return
hexHMACMD5
(
key
string
)
;
}
return
rawHMACMD5
(
key
string
)
;
}
module
.
exports
=
md5
;
}
{
}
]
}
{
}
[
4
]
)
(
4
)
}
)
;
