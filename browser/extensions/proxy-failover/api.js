"
use
strict
"
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
ChannelWrapper
"
]
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
ProxyService
"
"
mozilla
.
org
/
network
/
protocol
-
proxy
-
service
;
1
"
"
nsIProtocolProxyService
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
NSSErrorsService
"
"
mozilla
.
org
/
nss_errors_service
;
1
"
"
nsINSSErrorsService
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
ExtensionParent
:
"
resource
:
/
/
gre
/
modules
/
ExtensionParent
.
jsm
"
ExtensionPreferencesManager
:
"
resource
:
/
/
gre
/
modules
/
ExtensionPreferencesManager
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
Management
"
(
)
=
>
ExtensionParent
.
apiManager
)
;
const
PROXY_DIRECT
=
"
direct
"
;
const
DISABLE_HOURS
=
48
;
const
MAX_DISABLED_PI
=
2
;
const
PREF_MONITOR_DATA
=
"
extensions
.
proxyMonitor
.
state
"
;
const
PREF_MONITOR_LOGGING
=
"
extensions
.
proxyMonitor
.
logging
.
enabled
"
;
const
PREF_PROXY_FAILOVER
=
"
network
.
proxy
.
failover_direct
"
;
const
CHECK_EXTENSION_ONLY
=
Services
.
vc
.
compare
(
Services
.
appinfo
.
version
"
92
.
0
"
)
>
=
0
;
const
PROXY_CONFIG_TYPES
=
[
"
direct
"
"
manual
"
"
pac
"
"
unused
"
"
wpad
"
"
system
"
]
;
function
hoursSince
(
dt2
dt1
=
Date
.
now
(
)
)
{
var
diff
=
(
dt2
-
dt1
)
/
1000
;
diff
/
=
60
*
60
;
return
Math
.
abs
(
Math
.
round
(
diff
)
)
;
}
const
DEBUG_LOG
=
Services
.
prefs
.
getBoolPref
(
PREF_MONITOR_LOGGING
true
)
;
function
log
(
msg
)
{
if
(
DEBUG_LOG
)
{
console
.
log
(
proxy
-
monitor
:
{
msg
}
)
;
}
}
const
ProxyMonitor
=
{
errors
:
new
Map
(
)
extensions
:
new
Map
(
)
disabledTime
:
0
newDirectProxyInfo
(
failover
=
null
)
{
return
ProxyService
.
newProxyInfo
(
PROXY_DIRECT
"
"
0
"
"
"
"
0
0
failover
)
;
}
async
applyFilter
(
channel
defaultProxyInfo
proxyFilter
)
{
let
proxyInfo
=
defaultProxyInfo
;
try
{
if
(
!
proxyInfo
)
{
return
;
}
if
(
!
channel
.
loadInfo
?
.
loadingPrincipal
?
.
isSystemPrincipal
)
{
return
;
}
let
wrapper
=
ChannelWrapper
.
get
(
channel
)
;
wrapper
.
addEventListener
(
"
start
"
this
)
;
if
(
this
.
tooManyFailures
(
)
)
{
log
(
too
many
proxy
config
failures
prepend
direct
rid
{
wrapper
.
id
}
)
;
proxyInfo
=
this
.
newDirectProxyInfo
(
await
this
.
pruneExtensions
(
defaultProxyInfo
)
)
;
return
;
}
this
.
dumpProxies
(
proxyInfo
starting
proxyInfo
rid
{
wrapper
.
id
}
)
;
proxyInfo
=
this
.
pruneProxyInfo
(
proxyInfo
)
;
if
(
!
proxyInfo
)
{
log
(
all
proxies
disabled
prepend
direct
)
;
proxyInfo
=
this
.
newDirectProxyInfo
(
await
this
.
pruneExtensions
(
defaultProxyInfo
)
)
;
return
;
}
wrapper
.
addEventListener
(
"
error
"
this
)
;
this
.
dumpProxies
(
proxyInfo
pruned
proxyInfo
rid
{
wrapper
.
id
}
)
;
}
finally
{
proxyFilter
.
onProxyFilterResult
(
proxyInfo
)
;
}
}
relinkProxyInfoChain
(
proxies
)
{
if
(
!
proxies
.
length
)
{
return
null
;
}
for
(
let
i
=
0
;
i
<
proxies
.
length
-
2
;
i
+
+
)
{
proxies
[
i
]
.
failoverProxy
=
proxies
[
i
+
1
]
;
}
let
top
=
proxies
[
0
]
;
let
last
=
proxies
.
pop
(
)
;
if
(
last
.
failoverProxy
|
|
last
.
type
!
=
PROXY_DIRECT
)
{
last
.
failoverProxy
=
this
.
newDirectProxyInfo
(
)
;
}
return
top
;
}
async
pruneExtensions
(
proxyInfo
)
{
let
extensionId
=
await
this
.
getControllingExtension
(
)
;
if
(
extensionId
)
{
return
null
;
}
let
enabledProxies
=
[
]
;
let
pi
=
proxyInfo
;
while
(
pi
)
{
if
(
!
pi
.
sourceId
)
{
enabledProxies
.
push
(
pi
)
;
}
pi
=
pi
.
failoverProxy
;
}
return
this
.
relinkProxyInfoChain
(
enabledProxies
)
;
}
pruneProxyInfo
(
proxyInfo
)
{
let
enabledProxies
=
[
]
;
let
pi
=
proxyInfo
;
while
(
pi
)
{
if
(
!
this
.
proxyDisabled
(
pi
)
)
{
enabledProxies
.
push
(
pi
)
;
}
pi
=
pi
.
failoverProxy
;
}
return
this
.
relinkProxyInfoChain
(
enabledProxies
)
;
}
dumpProxies
(
proxyInfo
msg
)
{
if
(
!
DEBUG_LOG
)
{
return
;
}
log
(
msg
)
;
let
pi
=
proxyInfo
;
while
(
pi
)
{
log
(
{
pi
.
type
}
:
{
pi
.
host
}
:
{
pi
.
port
}
)
;
pi
=
pi
.
failoverProxy
;
}
}
tooManyFailures
(
)
{
if
(
this
.
disabledTime
&
&
hoursSince
(
this
.
disabledTime
)
>
=
DISABLE_HOURS
)
{
this
.
recordEvent
(
"
timeout
"
"
proxyBypass
"
"
global
"
)
;
this
.
reset
(
)
;
}
return
!
!
this
.
disabledTime
;
}
proxyDisabled
(
proxyInfo
)
{
let
key
=
this
.
getProxyInfoKey
(
proxyInfo
)
;
if
(
!
key
)
{
return
false
;
}
let
extTime
=
proxyInfo
.
sourceId
&
&
this
.
extensions
.
get
(
proxyInfo
.
sourceId
)
;
if
(
extTime
&
&
hoursSince
(
extTime
)
<
=
DISABLE_HOURS
)
{
return
true
;
}
let
err
=
this
.
errors
.
get
(
key
)
;
if
(
!
err
)
{
return
false
;
}
if
(
hoursSince
(
err
.
time
)
>
=
DISABLE_HOURS
)
{
this
.
errors
.
delete
(
key
)
;
this
.
logProxySource
(
"
timeout
"
proxyInfo
)
;
return
false
;
}
return
true
;
}
getProxyInfoKey
(
proxyInfo
)
{
if
(
!
proxyInfo
|
|
proxyInfo
.
type
=
=
PROXY_DIRECT
)
{
return
;
}
let
{
type
host
port
}
=
proxyInfo
;
return
{
type
}
:
{
host
}
:
{
port
}
;
}
async
getControllingExtension
(
)
{
let
setting
=
await
ExtensionPreferencesManager
.
getSetting
(
"
proxy
.
settings
"
)
;
return
setting
?
.
id
;
}
async
getProxySource
(
proxyInfo
)
{
if
(
proxyInfo
.
sourceId
)
{
return
{
source
:
proxyInfo
.
sourceId
type
:
"
api
"
}
;
}
let
type
=
PROXY_CONFIG_TYPES
[
ProxyService
.
proxyConfigType
]
|
|
"
unknown
"
;
if
(
Services
.
policies
.
status
=
=
=
Services
.
policies
.
ACTIVE
)
{
let
policies
=
Services
.
policies
.
getActivePolicies
(
)
?
.
filter
(
p
=
>
p
.
Proxy
)
;
if
(
policies
?
.
length
)
{
return
{
source
:
"
policy
"
type
}
;
}
}
let
source
=
await
this
.
getControllingExtension
(
)
;
return
{
source
:
source
|
|
"
prefs
"
type
}
;
}
async
logProxySource
(
state
proxyInfo
)
{
let
{
source
type
}
=
await
this
.
getProxySource
(
proxyInfo
)
;
this
.
recordEvent
(
state
"
proxyInfo
"
type
{
source
}
)
;
}
recordEvent
(
method
obj
type
=
null
source
=
{
}
)
{
try
{
Services
.
telemetry
.
recordEvent
(
"
proxyMonitor
"
method
obj
type
source
)
;
log
(
event
:
{
method
}
{
obj
}
{
type
}
{
JSON
.
stringify
(
source
)
}
)
;
}
catch
(
err
)
{
Cu
.
reportError
(
err
)
;
}
}
timeoutEntries
(
)
{
for
(
let
[
k
err
]
of
this
.
errors
)
{
if
(
hoursSince
(
err
.
time
)
>
=
DISABLE_HOURS
)
{
this
.
errors
.
delete
(
k
)
;
this
.
recordEvent
(
"
timeout
"
"
proxyInfo
"
)
;
}
}
for
(
let
[
e
t
]
of
this
.
extensions
)
{
if
(
hoursSince
(
t
)
>
=
DISABLE_HOURS
)
{
this
.
extensions
.
delete
(
e
)
;
this
.
recordEvent
(
"
timeout
"
"
proxyBypass
"
"
extension
"
{
source
:
e
}
)
;
}
}
}
async
disableProxyInfo
(
proxyInfo
)
{
this
.
dumpProxies
(
proxyInfo
"
disableProxyInfo
"
)
;
let
key
=
this
.
getProxyInfoKey
(
proxyInfo
)
;
if
(
!
key
)
{
log
(
direct
request
failure
)
;
return
;
}
let
extensionId
;
if
(
CHECK_EXTENSION_ONLY
)
{
extensionId
=
proxyInfo
.
sourceId
|
|
(
await
this
.
getControllingExtension
(
)
)
;
}
this
.
timeoutEntries
(
)
;
let
err
=
{
time
:
Date
.
now
(
)
extensionId
}
;
this
.
errors
.
set
(
key
err
)
;
if
(
extensionId
)
{
this
.
extensions
.
set
(
extensionId
err
.
time
)
;
log
(
all
proxy
configuration
from
extension
{
extensionId
}
disabled
)
;
this
.
recordEvent
(
"
start
"
"
proxyBypass
"
"
extension
"
{
source
:
extensionId
}
)
;
}
this
.
logProxySource
(
"
disabled
"
proxyInfo
)
;
if
(
!
this
.
disabledTime
&
&
this
.
errors
.
size
>
=
MAX_DISABLED_PI
)
{
this
.
disabledTime
=
Date
.
now
(
)
;
this
.
recordEvent
(
"
start
"
"
proxyBypass
"
"
global
"
)
;
}
}
async
enableProxyInfo
(
proxyInfo
)
{
let
key
=
this
.
getProxyInfoKey
(
proxyInfo
)
;
if
(
!
key
)
{
return
;
}
if
(
this
.
errors
.
delete
(
key
)
)
{
this
.
logProxySource
(
"
enabled
"
proxyInfo
)
;
}
if
(
!
CHECK_EXTENSION_ONLY
)
{
return
;
}
let
extensionId
=
proxyInfo
.
sourceId
|
|
(
await
this
.
getControllingExtension
(
)
)
;
if
(
!
extensionId
)
{
return
;
}
for
(
let
[
k
err
]
of
this
.
errors
)
{
if
(
err
.
extensionId
=
=
extensionId
)
{
return
;
}
}
this
.
extensions
.
delete
(
extensionId
)
;
}
tlsCheck
(
channel
)
{
let
securityInfo
=
channel
.
securityInfo
;
if
(
!
securityInfo
)
{
return
false
;
}
securityInfo
.
QueryInterface
(
Ci
.
nsITransportSecurityInfo
)
;
if
(
NSSErrorsService
.
isNSSErrorCode
(
securityInfo
.
errorCode
)
)
{
return
false
;
}
const
wpl
=
Ci
.
nsIWebProgressListener
;
const
state
=
securityInfo
.
securityState
;
return
!
!
(
state
&
wpl
.
STATE_IS_SECURE
)
;
}
handleEvent
(
event
)
{
let
wrapper
=
event
.
currentTarget
;
let
{
channel
}
=
wrapper
;
if
(
!
(
channel
instanceof
Ci
.
nsIProxiedChannel
)
)
{
log
(
got
{
event
.
type
}
event
but
not
a
proxied
channel
)
;
return
;
}
if
(
wrapper
.
finalURL
.
startsWith
(
"
http
:
"
)
)
{
return
;
}
let
tlsIsSecure
=
this
.
tlsCheck
(
channel
)
;
log
(
request
event
{
event
.
type
}
rid
{
wrapper
.
id
}
status
{
wrapper
.
statusCode
}
tls
{
tlsIsSecure
}
for
{
channel
.
URI
.
spec
}
)
;
let
status
=
wrapper
.
statusCode
;
switch
(
event
.
type
)
{
case
"
error
"
:
if
(
!
tlsIsSecure
|
|
status
=
=
0
)
{
this
.
disableProxyInfo
(
channel
.
proxyInfo
)
;
}
break
;
case
"
start
"
:
if
(
tlsIsSecure
&
&
status
>
=
200
&
&
status
<
400
)
{
this
.
enableProxyInfo
(
channel
.
proxyInfo
)
;
}
break
;
default
:
break
;
}
}
reset
(
)
{
this
.
disabledTime
=
0
;
this
.
errors
=
new
Map
(
)
;
}
store
(
)
{
if
(
!
this
.
disabledTime
&
&
!
this
.
errors
.
size
)
{
Services
.
prefs
.
clearUserPref
(
PREF_MONITOR_DATA
)
;
return
;
}
let
data
=
JSON
.
stringify
(
{
disabledTime
:
this
.
disabledTime
errors
:
Array
.
from
(
this
.
errors
)
}
)
;
Services
.
prefs
.
setStringPref
(
PREF_MONITOR_DATA
data
)
;
}
restore
(
)
{
let
failovers
=
Services
.
prefs
.
getStringPref
(
PREF_MONITOR_DATA
null
)
;
if
(
failovers
)
{
failovers
=
JSON
.
parse
(
failovers
)
;
this
.
disabledTime
=
failovers
.
disabledTime
;
this
.
errors
=
new
Map
(
failovers
.
errors
)
;
this
.
extensions
=
new
Map
(
failovers
.
errors
.
filter
(
e
=
>
e
[
1
]
.
extensionId
)
.
sort
(
(
a
b
)
=
>
a
[
1
]
.
time
-
b
[
1
]
.
time
)
.
map
(
e
=
>
[
e
[
1
]
.
extensionId
e
[
1
]
.
time
]
)
)
;
}
else
{
this
.
disabledTime
=
0
;
this
.
errors
=
new
Map
(
)
;
this
.
extensions
=
new
Map
(
)
;
}
}
startup
(
)
{
ProxyService
.
registerChannelFilter
(
ProxyMonitor
Number
.
MAX_SAFE_INTEGER
)
;
this
.
restore
(
)
;
log
(
"
started
"
)
;
}
shutdown
(
)
{
ProxyService
.
unregisterFilter
(
ProxyMonitor
)
;
this
.
store
(
)
;
log
(
"
stopped
"
)
;
}
}
;
const
monitor
=
{
running
:
false
startup
(
)
{
if
(
!
this
.
failoverEnabled
)
{
return
;
}
Management
.
on
(
"
startup
"
this
.
handleEvent
)
;
Management
.
on
(
"
shutdown
"
this
.
handleEvent
)
;
Management
.
on
(
"
change
-
permissions
"
this
.
handleEvent
)
;
if
(
this
.
hasProxyExtension
(
)
)
{
monitor
.
startMonitors
(
)
;
}
}
shutdown
(
)
{
Management
.
off
(
"
startup
"
this
.
handleEvent
)
;
Management
.
off
(
"
shutdown
"
this
.
handleEvent
)
;
Management
.
off
(
"
change
-
permissions
"
this
.
handleEvent
)
;
monitor
.
stopMonitors
(
)
;
}
get
failoverEnabled
(
)
{
return
Services
.
prefs
.
getBoolPref
(
PREF_PROXY_FAILOVER
true
)
;
}
observe
(
)
{
if
(
monitor
.
failoverEnabled
)
{
monitor
.
startup
(
)
;
}
else
{
monitor
.
shutdown
(
)
;
}
}
startMonitors
(
)
{
if
(
!
monitor
.
running
)
{
ProxyMonitor
.
startup
(
)
;
monitor
.
running
=
true
;
}
}
stopMonitors
(
)
{
if
(
monitor
.
running
)
{
ProxyMonitor
.
shutdown
(
)
;
monitor
.
running
=
false
;
}
}
hasProxyExtension
(
ignore
)
{
for
(
let
policy
of
WebExtensionPolicy
.
getActiveExtensions
(
)
)
{
if
(
policy
.
id
!
=
ignore
&
&
!
policy
.
extension
?
.
isAppProvided
&
&
policy
.
hasPermission
(
"
proxy
"
)
)
{
return
true
;
}
}
return
false
;
}
handleEvent
(
kind
.
.
.
args
)
{
switch
(
kind
)
{
case
"
startup
"
:
{
let
[
extension
]
=
args
;
if
(
!
monitor
.
running
&
&
!
extension
.
isAppProvided
&
&
extension
.
hasPermission
(
"
proxy
"
)
)
{
monitor
.
startMonitors
(
)
;
}
break
;
}
case
"
shutdown
"
:
{
if
(
Services
.
startup
.
shuttingDown
)
{
break
;
}
let
[
extension
]
=
args
;
if
(
monitor
.
running
&
&
!
extension
.
isAppProvided
&
&
!
monitor
.
hasProxyExtension
(
extension
.
id
)
)
{
monitor
.
stopMonitors
(
)
;
}
break
;
}
case
"
change
-
permissions
"
:
{
if
(
monitor
.
running
)
{
break
;
}
let
{
extensionId
added
}
=
args
[
0
]
;
if
(
!
added
?
.
permissions
.
includes
(
"
proxy
"
)
)
{
return
;
}
let
extension
=
WebExtensionPolicy
.
getByID
(
extensionId
)
?
.
extension
;
if
(
extension
&
&
!
extension
.
isAppProvided
)
{
monitor
.
startMonitors
(
)
;
}
break
;
}
}
}
}
;
this
.
failover
=
class
extends
ExtensionAPI
{
onStartup
(
)
{
Services
.
telemetry
.
registerEvents
(
"
proxyMonitor
"
{
proxyMonitor
:
{
methods
:
[
"
enabled
"
"
disabled
"
"
start
"
"
timeout
"
]
objects
:
[
"
proxyInfo
"
"
proxyBypass
"
]
extra_keys
:
[
"
source
"
]
record_on_release
:
true
}
}
)
;
monitor
.
startup
(
)
;
Services
.
prefs
.
addObserver
(
PREF_PROXY_FAILOVER
monitor
)
;
}
onShutdown
(
)
{
monitor
.
shutdown
(
)
;
Services
.
prefs
.
removeObserver
(
PREF_PROXY_FAILOVER
monitor
)
;
}
}
;
