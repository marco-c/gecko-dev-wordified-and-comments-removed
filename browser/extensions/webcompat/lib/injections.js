"
use
strict
"
;
class
Injections
{
constructor
(
availableInjections
customFunctions
)
{
this
.
INJECTION_PREF
=
"
perform_injections
"
;
this
.
_injectionsEnabled
=
true
;
this
.
_availableInjections
=
availableInjections
;
this
.
_activeInjections
=
new
Set
(
)
;
this
.
_activeInjectionHandles
=
new
Map
(
)
;
this
.
_customFunctions
=
customFunctions
;
this
.
shouldUseScriptingAPI
=
browser
.
aboutConfigPrefs
.
getBoolPrefSync
(
"
useScriptingAPI
"
)
;
browser
.
appConstants
.
getReleaseBranch
(
)
.
then
(
releaseBranch
=
>
{
if
(
releaseBranch
!
=
=
"
release_or_beta
"
)
{
console
.
debug
(
WebCompat
Injections
will
be
injected
using
{
this
.
shouldUseScriptingAPI
?
"
scripting
"
:
"
contentScripts
"
}
API
)
;
}
}
)
;
}
bindAboutCompatBroker
(
broker
)
{
this
.
_aboutCompatBroker
=
broker
;
}
bootup
(
)
{
browser
.
aboutConfigPrefs
.
onPrefChange
.
addListener
(
(
)
=
>
{
this
.
checkInjectionPref
(
)
;
}
this
.
INJECTION_PREF
)
;
this
.
checkInjectionPref
(
)
;
}
checkInjectionPref
(
)
{
browser
.
aboutConfigPrefs
.
getPref
(
this
.
INJECTION_PREF
)
.
then
(
value
=
>
{
if
(
value
=
=
=
undefined
)
{
browser
.
aboutConfigPrefs
.
setPref
(
this
.
INJECTION_PREF
true
)
;
}
else
if
(
value
=
=
=
false
)
{
this
.
unregisterContentScripts
(
)
;
}
else
{
this
.
registerContentScripts
(
)
;
}
}
)
;
}
getAvailableInjections
(
)
{
return
this
.
_availableInjections
;
}
isEnabled
(
)
{
return
this
.
_injectionsEnabled
;
}
async
getPromiseRegisteredScriptIds
(
scriptIds
)
{
let
registeredScriptIds
=
[
]
;
try
{
const
registeredScripts
=
await
browser
.
scripting
.
getRegisteredContentScripts
(
{
ids
:
scriptIds
?
?
this
.
_availableInjections
.
map
(
inj
=
>
inj
.
id
)
}
)
;
registeredScriptIds
=
registeredScripts
.
map
(
script
=
>
script
.
id
)
;
}
catch
(
ex
)
{
console
.
error
(
"
Retrieve
WebCompat
GoFaster
registered
content
scripts
failed
:
"
ex
)
;
}
return
registeredScriptIds
;
}
async
registerContentScripts
(
)
{
const
platformInfo
=
await
browser
.
runtime
.
getPlatformInfo
(
)
;
const
platformMatches
=
[
"
all
"
platformInfo
.
os
platformInfo
.
os
=
=
"
android
"
?
"
android
"
:
"
desktop
"
]
;
let
registeredScriptIds
=
this
.
shouldUseScriptingAPI
?
await
this
.
getPromiseRegisteredScriptIds
(
)
:
[
]
;
for
(
const
injection
of
this
.
_availableInjections
)
{
if
(
platformMatches
.
includes
(
injection
.
platform
)
)
{
injection
.
availableOnPlatform
=
true
;
await
this
.
enableInjection
(
injection
registeredScriptIds
)
;
}
}
this
.
_injectionsEnabled
=
true
;
this
.
_aboutCompatBroker
.
portsToAboutCompatTabs
.
broadcast
(
{
interventionsChanged
:
this
.
_aboutCompatBroker
.
filterOverrides
(
this
.
_availableInjections
)
}
)
;
}
buildContentScriptRegistrations
(
contentScripts
)
{
let
finalConfig
=
Object
.
assign
(
{
}
contentScripts
)
;
if
(
!
finalConfig
.
runAt
)
{
finalConfig
.
runAt
=
"
document_start
"
;
}
if
(
this
.
shouldUseScriptingAPI
)
{
finalConfig
.
persistAcrossSessions
=
false
;
if
(
Array
.
isArray
(
finalConfig
.
js
)
)
{
finalConfig
.
js
=
finalConfig
.
js
.
map
(
e
=
>
e
.
file
)
;
}
if
(
Array
.
isArray
(
finalConfig
.
css
)
)
{
finalConfig
.
css
=
finalConfig
.
css
.
map
(
e
=
>
e
.
file
)
;
}
}
return
finalConfig
;
}
async
enableInjection
(
injection
registeredScriptIds
)
{
if
(
injection
.
active
)
{
return
undefined
;
}
if
(
injection
.
customFunc
)
{
return
this
.
enableCustomInjection
(
injection
)
;
}
return
this
.
enableContentScripts
(
injection
registeredScriptIds
)
;
}
enableCustomInjection
(
injection
)
{
if
(
injection
.
customFunc
in
this
.
_customFunctions
)
{
this
.
_customFunctions
[
injection
.
customFunc
]
(
injection
)
;
injection
.
active
=
true
;
}
else
{
console
.
error
(
Provided
function
{
injection
.
customFunc
}
wasn
'
t
found
in
functions
list
)
;
}
}
async
enableContentScripts
(
injection
registeredScriptIds
)
{
let
injectProps
;
try
{
const
{
id
}
=
injection
;
if
(
this
.
shouldUseScriptingAPI
)
{
let
activeScriptIds
=
Array
.
isArray
(
registeredScriptIds
)
?
registeredScriptIds
:
await
this
.
getPromiseRegisteredScriptIds
(
[
id
]
)
;
injectProps
=
this
.
buildContentScriptRegistrations
(
injection
.
contentScripts
)
;
injectProps
.
id
=
id
;
if
(
!
activeScriptIds
.
includes
(
id
)
)
{
await
browser
.
scripting
.
registerContentScripts
(
[
injectProps
]
)
;
}
this
.
_activeInjections
.
add
(
id
)
;
}
else
{
const
handle
=
await
browser
.
contentScripts
.
register
(
this
.
buildContentScriptRegistrations
(
injection
.
contentScripts
)
)
;
this
.
_activeInjections
.
add
(
id
)
;
this
.
_activeInjectionHandles
.
set
(
id
handle
)
;
}
injection
.
active
=
true
;
}
catch
(
ex
)
{
console
.
error
(
"
Registering
WebCompat
GoFaster
content
scripts
failed
:
"
{
injection
injectProps
}
ex
)
;
}
}
unregisterContentScripts
(
)
{
for
(
const
injection
of
this
.
_availableInjections
)
{
this
.
disableInjection
(
injection
)
;
}
this
.
_injectionsEnabled
=
false
;
this
.
_aboutCompatBroker
.
portsToAboutCompatTabs
.
broadcast
(
{
interventionsChanged
:
false
}
)
;
}
async
disableInjection
(
injection
)
{
if
(
!
injection
.
active
)
{
return
undefined
;
}
if
(
injection
.
customFunc
)
{
return
this
.
disableCustomInjections
(
injection
)
;
}
return
this
.
disableContentScripts
(
injection
)
;
}
disableCustomInjections
(
injection
)
{
const
disableFunc
=
injection
.
customFunc
+
"
Disable
"
;
if
(
disableFunc
in
this
.
_customFunctions
)
{
this
.
_customFunctions
[
disableFunc
]
(
injection
)
;
injection
.
active
=
false
;
}
else
{
console
.
error
(
Provided
function
{
disableFunc
}
for
disabling
injection
wasn
'
t
found
in
functions
list
)
;
}
}
async
disableContentScripts
(
injection
)
{
if
(
this
.
_activeInjections
.
has
(
injection
.
id
)
)
{
if
(
this
.
shouldUseScriptingAPI
)
{
await
browser
.
scripting
.
unregisterContentScripts
(
{
ids
:
[
injection
.
id
]
}
)
;
}
else
{
const
handle
=
this
.
_activeInjectionHandles
.
get
(
injection
.
id
)
;
await
handle
.
unregister
(
)
;
this
.
_activeInjectionHandles
.
delete
(
injection
.
id
)
;
}
this
.
_activeInjections
.
delete
(
injection
)
;
}
injection
.
active
=
false
;
}
}
module
.
exports
=
Injections
;
