"
use
strict
"
;
const
{
utils
:
Cu
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
shield
-
recipe
-
client
/
lib
/
LogManager
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
timerManager
"
"
mozilla
.
org
/
updates
/
timer
-
manager
;
1
"
"
nsIUpdateTimerManager
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Preferences
"
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Storage
"
"
resource
:
/
/
shield
-
recipe
-
client
/
lib
/
Storage
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
NormandyDriver
"
"
resource
:
/
/
shield
-
recipe
-
client
/
lib
/
NormandyDriver
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
FilterExpressions
"
"
resource
:
/
/
shield
-
recipe
-
client
/
lib
/
FilterExpressions
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
NormandyApi
"
"
resource
:
/
/
shield
-
recipe
-
client
/
lib
/
NormandyApi
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
SandboxManager
"
"
resource
:
/
/
shield
-
recipe
-
client
/
lib
/
SandboxManager
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
ClientEnvironment
"
"
resource
:
/
/
shield
-
recipe
-
client
/
lib
/
ClientEnvironment
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
CleanupManager
"
"
resource
:
/
/
shield
-
recipe
-
client
/
lib
/
CleanupManager
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
ActionSandboxManager
"
"
resource
:
/
/
shield
-
recipe
-
client
/
lib
/
ActionSandboxManager
.
jsm
"
)
;
Cu
.
importGlobalProperties
(
[
"
fetch
"
]
)
;
this
.
EXPORTED_SYMBOLS
=
[
"
RecipeRunner
"
]
;
const
log
=
LogManager
.
getLogger
(
"
recipe
-
runner
"
)
;
const
prefs
=
Services
.
prefs
.
getBranch
(
"
extensions
.
shield
-
recipe
-
client
.
"
)
;
const
TIMER_NAME
=
"
recipe
-
client
-
addon
-
run
"
;
const
RUN_INTERVAL_PREF
=
"
run_interval_seconds
"
;
const
FIRST_RUN_PREF
=
"
first_run
"
;
const
UI_AVAILABLE_NOTIFICATION
=
"
sessionstore
-
windows
-
restored
"
;
const
SHIELD_INIT_NOTIFICATION
=
"
shield
-
init
-
complete
"
;
this
.
RecipeRunner
=
{
init
(
)
{
if
(
!
this
.
checkPrefs
(
)
)
{
return
;
}
if
(
prefs
.
getBoolPref
(
"
dev_mode
"
)
)
{
this
.
run
(
)
;
}
if
(
prefs
.
getBoolPref
(
FIRST_RUN_PREF
)
)
{
const
observer
=
{
observe
:
async
(
subject
topic
data
)
=
>
{
Services
.
obs
.
removeObserver
(
observer
UI_AVAILABLE_NOTIFICATION
)
;
await
this
.
run
(
)
;
this
.
registerTimer
(
)
;
prefs
.
setBoolPref
(
FIRST_RUN_PREF
false
)
;
Services
.
obs
.
notifyObservers
(
null
SHIELD_INIT_NOTIFICATION
)
;
}
}
;
Services
.
obs
.
addObserver
(
observer
UI_AVAILABLE_NOTIFICATION
)
;
CleanupManager
.
addCleanupHandler
(
(
)
=
>
Services
.
obs
.
removeObserver
(
observer
UI_AVAILABLE_NOTIFICATION
)
)
;
}
else
{
this
.
registerTimer
(
)
;
}
}
registerTimer
(
)
{
this
.
updateRunInterval
(
)
;
CleanupManager
.
addCleanupHandler
(
(
)
=
>
timerManager
.
unregisterTimer
(
TIMER_NAME
)
)
;
prefs
.
addObserver
(
RUN_INTERVAL_PREF
this
)
;
CleanupManager
.
addCleanupHandler
(
(
)
=
>
prefs
.
removeObserver
(
RUN_INTERVAL_PREF
this
)
)
;
}
checkPrefs
(
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
"
toolkit
.
telemetry
.
unified
"
)
)
{
log
.
info
(
"
Disabling
RecipeRunner
because
Unified
Telemetry
is
disabled
.
"
)
;
return
false
;
}
if
(
!
prefs
.
getBoolPref
(
"
enabled
"
)
)
{
log
.
info
(
"
Recipe
Client
is
disabled
.
"
)
;
return
false
;
}
const
apiUrl
=
prefs
.
getCharPref
(
"
api_url
"
)
;
if
(
!
apiUrl
|
|
!
apiUrl
.
startsWith
(
"
https
:
/
/
"
)
)
{
log
.
error
(
Non
HTTPS
URL
provided
for
extensions
.
shield
-
recipe
-
client
.
api_url
:
{
apiUrl
}
)
;
return
false
;
}
return
true
;
}
observe
(
changedPrefBranch
action
changedPref
)
{
if
(
action
=
=
=
"
nsPref
:
changed
"
&
&
changedPref
=
=
=
RUN_INTERVAL_PREF
)
{
this
.
updateRunInterval
(
)
;
}
else
{
log
.
debug
(
Observer
fired
with
unexpected
pref
change
:
{
action
}
{
changedPref
}
)
;
}
}
updateRunInterval
(
)
{
const
runInterval
=
prefs
.
getIntPref
(
RUN_INTERVAL_PREF
)
;
timerManager
.
registerTimer
(
TIMER_NAME
(
)
=
>
this
.
run
(
)
runInterval
)
;
}
async
run
(
)
{
this
.
clearCaches
(
)
;
if
(
!
Preferences
.
get
(
"
extensions
.
shield
-
recipe
-
client
.
experiments
.
lazy_classify
"
false
)
)
{
await
ClientEnvironment
.
getClientClassification
(
)
;
}
const
actionSandboxManagers
=
await
this
.
loadActionSandboxManagers
(
)
;
Object
.
values
(
actionSandboxManagers
)
.
forEach
(
manager
=
>
manager
.
addHold
(
"
recipeRunner
"
)
)
;
for
(
const
[
actionName
manager
]
of
Object
.
entries
(
actionSandboxManagers
)
)
{
try
{
await
manager
.
runAsyncCallback
(
"
preExecution
"
)
;
manager
.
disabled
=
false
;
}
catch
(
err
)
{
log
.
error
(
Could
not
run
pre
-
execution
hook
for
{
actionName
}
:
err
.
message
)
;
manager
.
disabled
=
true
;
}
}
let
recipes
;
try
{
recipes
=
await
NormandyApi
.
fetchRecipes
(
{
enabled
:
true
}
)
;
}
catch
(
e
)
{
const
apiUrl
=
prefs
.
getCharPref
(
"
api_url
"
)
;
log
.
error
(
Could
not
fetch
recipes
from
{
apiUrl
}
:
"
{
e
}
"
)
;
return
;
}
const
recipesToRun
=
[
]
;
for
(
const
recipe
of
recipes
)
{
if
(
await
this
.
checkFilter
(
recipe
)
)
{
recipesToRun
.
push
(
recipe
)
;
}
}
if
(
recipesToRun
.
length
=
=
=
0
)
{
log
.
debug
(
"
No
recipes
to
execute
"
)
;
}
else
{
for
(
const
recipe
of
recipesToRun
)
{
const
manager
=
actionSandboxManagers
[
recipe
.
action
]
;
if
(
!
manager
)
{
log
.
error
(
Could
not
execute
recipe
{
recipe
.
name
}
:
Action
{
recipe
.
action
}
is
either
missing
or
invalid
.
)
;
}
else
if
(
manager
.
disabled
)
{
log
.
warn
(
Skipping
recipe
{
recipe
.
name
}
because
{
recipe
.
action
}
failed
during
pre
-
execution
.
)
;
}
else
{
try
{
log
.
info
(
Executing
recipe
"
{
recipe
.
name
}
"
(
action
=
{
recipe
.
action
}
)
)
;
await
manager
.
runAsyncCallback
(
"
action
"
recipe
)
;
}
catch
(
e
)
{
log
.
error
(
Could
not
execute
recipe
{
recipe
.
name
}
:
e
)
;
}
}
}
}
for
(
const
[
actionName
manager
]
of
Object
.
entries
(
actionSandboxManagers
)
)
{
if
(
manager
.
disabled
)
{
log
.
info
(
Skipping
post
-
execution
hook
for
{
actionName
}
due
to
earlier
failure
.
)
;
continue
;
}
try
{
await
manager
.
runAsyncCallback
(
"
postExecution
"
)
;
}
catch
(
err
)
{
log
.
info
(
Could
not
run
post
-
execution
hook
for
{
actionName
}
:
err
.
message
)
;
}
}
Object
.
values
(
actionSandboxManagers
)
.
forEach
(
manager
=
>
manager
.
removeHold
(
"
recipeRunner
"
)
)
;
}
async
loadActionSandboxManagers
(
)
{
const
actions
=
await
NormandyApi
.
fetchActions
(
)
;
const
actionSandboxManagers
=
{
}
;
for
(
const
action
of
actions
)
{
try
{
const
implementation
=
await
NormandyApi
.
fetchImplementation
(
action
)
;
actionSandboxManagers
[
action
.
name
]
=
new
ActionSandboxManager
(
implementation
)
;
}
catch
(
err
)
{
log
.
warn
(
Could
not
fetch
implementation
for
{
action
.
name
}
:
err
)
;
}
}
return
actionSandboxManagers
;
}
getFilterContext
(
recipe
)
{
return
{
normandy
:
Object
.
assign
(
ClientEnvironment
.
getEnvironment
(
)
{
recipe
:
{
id
:
recipe
.
id
arguments
:
recipe
.
arguments
}
}
)
}
;
}
async
checkFilter
(
recipe
)
{
const
context
=
this
.
getFilterContext
(
recipe
)
;
try
{
const
result
=
await
FilterExpressions
.
eval
(
recipe
.
filter_expression
context
)
;
return
!
!
result
;
}
catch
(
err
)
{
log
.
error
(
Error
checking
filter
for
"
{
recipe
.
name
}
"
)
;
log
.
error
(
Filter
:
"
{
recipe
.
filter_expression
}
"
)
;
log
.
error
(
Error
:
"
{
err
}
"
)
;
return
false
;
}
}
clearCaches
(
)
{
ClientEnvironment
.
clearClassifyCache
(
)
;
NormandyApi
.
clearIndexCache
(
)
;
}
async
testRun
(
baseApiUrl
)
{
const
oldApiUrl
=
prefs
.
getCharPref
(
"
api_url
"
)
;
prefs
.
setCharPref
(
"
api_url
"
baseApiUrl
)
;
try
{
Storage
.
clearAllStorage
(
)
;
this
.
clearCaches
(
)
;
await
this
.
run
(
)
;
}
finally
{
prefs
.
setCharPref
(
"
api_url
"
oldApiUrl
)
;
this
.
clearCaches
(
)
;
}
}
}
;
