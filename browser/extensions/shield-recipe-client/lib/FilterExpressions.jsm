"
use
strict
"
;
const
{
utils
:
Cu
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
shield
-
recipe
-
client
/
lib
/
Sampling
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
shield
-
recipe
-
client
/
lib
/
PreferenceFilters
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
mozjexl
"
"
resource
:
/
/
shield
-
recipe
-
client
-
vendor
/
mozjexl
.
js
"
)
;
this
.
EXPORTED_SYMBOLS
=
[
"
FilterExpressions
"
]
;
XPCOMUtils
.
defineLazyGetter
(
this
"
jexl
"
(
)
=
>
{
const
jexl
=
new
mozjexl
.
Jexl
(
)
;
jexl
.
addTransforms
(
{
date
:
dateString
=
>
new
Date
(
dateString
)
stableSample
:
Sampling
.
stableSample
bucketSample
:
Sampling
.
bucketSample
preferenceValue
:
PreferenceFilters
.
preferenceValue
preferenceIsUserSet
:
PreferenceFilters
.
preferenceIsUserSet
preferenceExists
:
PreferenceFilters
.
preferenceExists
keys
}
)
;
jexl
.
addBinaryOp
(
"
intersect
"
40
operatorIntersect
)
;
return
jexl
;
}
)
;
this
.
FilterExpressions
=
{
eval
(
expr
context
=
{
}
)
{
const
onelineExpr
=
expr
.
replace
(
/
[
\
t
\
n
\
r
]
/
g
"
"
)
;
return
jexl
.
eval
(
onelineExpr
context
)
;
}
}
;
function
keys
(
obj
)
{
if
(
typeof
obj
!
=
=
"
object
"
|
|
obj
=
=
=
null
)
{
return
undefined
;
}
return
Object
.
keys
(
obj
)
;
}
function
operatorIntersect
(
listA
listB
)
{
if
(
!
Array
.
isArray
(
listA
)
|
|
!
Array
.
isArray
(
listB
)
)
{
return
undefined
;
}
return
listA
.
filter
(
item
=
>
listB
.
includes
(
item
)
)
;
}
