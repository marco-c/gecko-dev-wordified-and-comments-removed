"
use
strict
"
;
const
{
utils
:
Cu
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Services
"
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
CleanupManager
"
"
resource
:
/
/
shield
-
recipe
-
client
/
lib
/
CleanupManager
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
JSONFile
"
"
resource
:
/
/
gre
/
modules
/
JSONFile
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
OS
"
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
LogManager
"
"
resource
:
/
/
shield
-
recipe
-
client
/
lib
/
LogManager
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
TelemetryEnvironment
"
"
resource
:
/
/
gre
/
modules
/
TelemetryEnvironment
.
jsm
"
)
;
this
.
EXPORTED_SYMBOLS
=
[
"
PreferenceExperiments
"
]
;
const
EXPERIMENT_FILE
=
"
shield
-
preference
-
experiments
.
json
"
;
const
PREFERENCE_TYPE_MAP
=
{
boolean
:
Services
.
prefs
.
PREF_BOOL
string
:
Services
.
prefs
.
PREF_STRING
integer
:
Services
.
prefs
.
PREF_INT
}
;
const
UserPreferences
=
Services
.
prefs
;
const
DefaultPreferences
=
Services
.
prefs
.
getDefaultBranch
(
"
"
)
;
const
PreferenceBranchType
=
{
user
:
UserPreferences
default
:
DefaultPreferences
}
;
let
storePromise
;
function
ensureStorage
(
)
{
if
(
storePromise
=
=
=
undefined
)
{
const
path
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
EXPERIMENT_FILE
)
;
const
storage
=
new
JSONFile
(
{
path
}
)
;
storePromise
=
storage
.
load
(
)
.
then
(
(
)
=
>
storage
)
;
}
return
storePromise
;
}
const
log
=
LogManager
.
getLogger
(
"
preference
-
experiments
"
)
;
let
experimentObservers
=
new
Map
(
)
;
CleanupManager
.
addCleanupHandler
(
(
)
=
>
PreferenceExperiments
.
stopAllObservers
(
)
)
;
function
getPref
(
prefBranch
prefName
prefType
defaultVal
)
{
switch
(
prefType
)
{
case
"
boolean
"
:
return
prefBranch
.
getBoolPref
(
prefName
defaultVal
)
;
case
"
string
"
:
return
prefBranch
.
getStringPref
(
prefName
defaultVal
)
;
case
"
integer
"
:
return
prefBranch
.
getIntPref
(
prefName
defaultVal
)
;
default
:
throw
new
TypeError
(
Unexpected
preference
type
(
{
prefType
}
)
for
{
prefName
}
.
)
;
}
}
function
setPref
(
prefBranch
prefName
prefType
prefValue
)
{
switch
(
prefType
)
{
case
"
boolean
"
:
prefBranch
.
setBoolPref
(
prefName
prefValue
)
;
break
;
case
"
string
"
:
prefBranch
.
setStringPref
(
prefName
prefValue
)
;
break
;
case
"
integer
"
:
prefBranch
.
setIntPref
(
prefName
prefValue
)
;
break
;
default
:
throw
new
TypeError
(
Unexpected
preference
type
(
{
prefType
}
)
for
{
prefName
}
.
)
;
}
}
this
.
PreferenceExperiments
=
{
async
init
(
)
{
for
(
const
experiment
of
await
this
.
getAllActive
(
)
)
{
if
(
experiment
.
preferenceBranchType
=
=
=
"
default
"
)
{
setPref
(
DefaultPreferences
experiment
.
preferenceName
experiment
.
preferenceType
experiment
.
preferenceValue
)
;
}
if
(
getPref
(
UserPreferences
experiment
.
preferenceName
experiment
.
preferenceType
undefined
)
!
=
=
experiment
.
preferenceValue
)
{
log
.
info
(
Stopping
experiment
"
{
experiment
.
name
}
"
because
its
value
changed
)
;
await
this
.
stop
(
experiment
.
name
false
)
;
continue
;
}
TelemetryEnvironment
.
setExperimentActive
(
experiment
.
name
experiment
.
branch
)
;
this
.
startObserver
(
experiment
.
name
experiment
.
preferenceName
experiment
.
preferenceType
experiment
.
preferenceValue
)
;
}
}
withMockExperiments
(
testFunction
)
{
return
async
function
inner
(
.
.
.
args
)
{
const
oldPromise
=
storePromise
;
const
mockExperiments
=
{
}
;
storePromise
=
Promise
.
resolve
(
{
data
:
mockExperiments
saveSoon
(
)
{
}
}
)
;
const
oldObservers
=
experimentObservers
;
experimentObservers
=
new
Map
(
)
;
try
{
await
testFunction
(
.
.
.
args
mockExperiments
)
;
}
finally
{
storePromise
=
oldPromise
;
PreferenceExperiments
.
stopAllObservers
(
)
;
experimentObservers
=
oldObservers
;
}
}
;
}
async
clearAllExperimentStorage
(
)
{
const
store
=
await
ensureStorage
(
)
;
store
.
data
=
{
}
;
store
.
saveSoon
(
)
;
}
async
start
(
{
name
branch
preferenceName
preferenceValue
preferenceBranchType
preferenceType
}
)
{
log
.
debug
(
PreferenceExperiments
.
start
(
{
name
}
{
branch
}
)
)
;
const
store
=
await
ensureStorage
(
)
;
if
(
name
in
store
.
data
)
{
throw
new
Error
(
A
preference
experiment
named
"
{
name
}
"
already
exists
.
)
;
}
const
activeExperiments
=
Object
.
values
(
store
.
data
)
.
filter
(
e
=
>
!
e
.
expired
)
;
const
hasConflictingExperiment
=
activeExperiments
.
some
(
e
=
>
e
.
preferenceName
=
=
=
preferenceName
)
;
if
(
hasConflictingExperiment
)
{
throw
new
Error
(
Another
preference
experiment
for
the
pref
"
{
preferenceName
}
"
is
currently
active
.
)
;
}
const
preferences
=
PreferenceBranchType
[
preferenceBranchType
]
;
if
(
!
preferences
)
{
throw
new
Error
(
Invalid
value
for
preferenceBranchType
:
{
preferenceBranchType
}
)
;
}
const
experiment
=
{
name
branch
expired
:
false
lastSeen
:
new
Date
(
)
.
toJSON
(
)
preferenceName
preferenceValue
preferenceType
previousPreferenceValue
:
getPref
(
preferences
preferenceName
preferenceType
undefined
)
preferenceBranchType
}
;
const
prevPrefType
=
Services
.
prefs
.
getPrefType
(
preferenceName
)
;
const
givenPrefType
=
PREFERENCE_TYPE_MAP
[
preferenceType
]
;
if
(
!
preferenceType
|
|
!
givenPrefType
)
{
throw
new
Error
(
Invalid
preferenceType
provided
(
given
"
{
preferenceType
}
"
)
)
;
}
if
(
prevPrefType
!
=
=
Services
.
prefs
.
PREF_INVALID
&
&
prevPrefType
!
=
=
givenPrefType
)
{
throw
new
Error
(
Previous
preference
value
is
of
type
"
{
prevPrefType
}
"
but
was
given
+
"
{
givenPrefType
}
"
(
{
preferenceType
}
)
)
;
}
setPref
(
preferences
preferenceName
preferenceType
preferenceValue
)
;
PreferenceExperiments
.
startObserver
(
name
preferenceName
preferenceType
preferenceValue
)
;
store
.
data
[
name
]
=
experiment
;
store
.
saveSoon
(
)
;
TelemetryEnvironment
.
setExperimentActive
(
name
branch
)
;
}
startObserver
(
experimentName
preferenceName
preferenceType
preferenceValue
)
{
log
.
debug
(
PreferenceExperiments
.
startObserver
(
{
experimentName
}
)
)
;
if
(
experimentObservers
.
has
(
experimentName
)
)
{
throw
new
Error
(
An
observer
for
the
preference
experiment
{
experimentName
}
is
already
active
.
)
;
}
const
observerInfo
=
{
preferenceName
observer
(
)
{
let
newValue
=
getPref
(
UserPreferences
preferenceName
preferenceType
undefined
)
;
if
(
newValue
!
=
=
preferenceValue
)
{
PreferenceExperiments
.
stop
(
experimentName
false
)
.
catch
(
Cu
.
reportError
)
;
}
}
}
;
experimentObservers
.
set
(
experimentName
observerInfo
)
;
Services
.
prefs
.
addObserver
(
preferenceName
observerInfo
.
observer
)
;
}
hasObserver
(
experimentName
)
{
log
.
debug
(
PreferenceExperiments
.
hasObserver
(
{
experimentName
}
)
)
;
return
experimentObservers
.
has
(
experimentName
)
;
}
stopObserver
(
experimentName
)
{
log
.
debug
(
PreferenceExperiments
.
stopObserver
(
{
experimentName
}
)
)
;
if
(
!
experimentObservers
.
has
(
experimentName
)
)
{
throw
new
Error
(
No
observer
for
the
preference
experiment
{
experimentName
}
found
.
)
;
}
const
{
preferenceName
observer
}
=
experimentObservers
.
get
(
experimentName
)
;
Services
.
prefs
.
removeObserver
(
preferenceName
observer
)
;
experimentObservers
.
delete
(
experimentName
)
;
}
stopAllObservers
(
)
{
log
.
debug
(
"
PreferenceExperiments
.
stopAllObservers
(
)
"
)
;
for
(
const
{
preferenceName
observer
}
of
experimentObservers
.
values
(
)
)
{
Services
.
prefs
.
removeObserver
(
preferenceName
observer
)
;
}
experimentObservers
.
clear
(
)
;
}
async
markLastSeen
(
experimentName
)
{
log
.
debug
(
PreferenceExperiments
.
markLastSeen
(
{
experimentName
}
)
)
;
const
store
=
await
ensureStorage
(
)
;
if
(
!
(
experimentName
in
store
.
data
)
)
{
throw
new
Error
(
Could
not
find
a
preference
experiment
named
"
{
experimentName
}
"
)
;
}
store
.
data
[
experimentName
]
.
lastSeen
=
new
Date
(
)
.
toJSON
(
)
;
store
.
saveSoon
(
)
;
}
async
stop
(
experimentName
resetValue
=
true
)
{
log
.
debug
(
PreferenceExperiments
.
stop
(
{
experimentName
}
)
)
;
const
store
=
await
ensureStorage
(
)
;
if
(
!
(
experimentName
in
store
.
data
)
)
{
throw
new
Error
(
Could
not
find
a
preference
experiment
named
"
{
experimentName
}
"
)
;
}
const
experiment
=
store
.
data
[
experimentName
]
;
if
(
experiment
.
expired
)
{
throw
new
Error
(
Cannot
stop
preference
experiment
"
{
experimentName
}
"
because
it
is
already
expired
)
;
}
if
(
PreferenceExperiments
.
hasObserver
(
experimentName
)
)
{
PreferenceExperiments
.
stopObserver
(
experimentName
)
;
}
if
(
resetValue
)
{
const
{
preferenceName
preferenceType
previousPreferenceValue
preferenceBranchType
}
=
experiment
;
const
preferences
=
PreferenceBranchType
[
preferenceBranchType
]
;
if
(
previousPreferenceValue
!
=
=
undefined
)
{
setPref
(
preferences
preferenceName
preferenceType
previousPreferenceValue
)
;
}
else
{
preferences
.
clearUserPref
(
preferenceName
)
;
}
}
experiment
.
expired
=
true
;
store
.
saveSoon
(
)
;
TelemetryEnvironment
.
setExperimentInactive
(
experimentName
experiment
.
branch
)
;
}
async
get
(
experimentName
)
{
log
.
debug
(
PreferenceExperiments
.
get
(
{
experimentName
}
)
)
;
const
store
=
await
ensureStorage
(
)
;
if
(
!
(
experimentName
in
store
.
data
)
)
{
throw
new
Error
(
Could
not
find
a
preference
experiment
named
"
{
experimentName
}
"
)
;
}
return
Object
.
assign
(
{
}
store
.
data
[
experimentName
]
)
;
}
async
getAll
(
)
{
const
store
=
await
ensureStorage
(
)
;
return
Object
.
values
(
store
.
data
)
.
map
(
experiment
=
>
Object
.
assign
(
{
}
experiment
)
)
;
}
async
getAllActive
(
)
{
log
.
debug
(
"
PreferenceExperiments
.
getAllActive
(
)
"
)
;
const
store
=
await
ensureStorage
(
)
;
return
Object
.
values
(
store
.
data
)
.
filter
(
e
=
>
!
e
.
expired
)
.
map
(
e
=
>
Object
.
assign
(
{
}
e
)
)
;
}
async
has
(
experimentName
)
{
log
.
debug
(
PreferenceExperiments
.
has
(
{
experimentName
}
)
)
;
const
store
=
await
ensureStorage
(
)
;
return
experimentName
in
store
.
data
;
}
}
;
