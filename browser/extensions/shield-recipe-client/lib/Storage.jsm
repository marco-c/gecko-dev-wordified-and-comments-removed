"
use
strict
"
;
const
{
utils
:
Cu
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
shield
-
recipe
-
client
/
lib
/
LogManager
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
JSONFile
"
"
resource
:
/
/
gre
/
modules
/
JSONFile
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
OS
"
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Task
"
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
this
.
EXPORTED_SYMBOLS
=
[
"
Storage
"
]
;
const
log
=
LogManager
.
getLogger
(
"
storage
"
)
;
let
storePromise
;
function
loadStorage
(
)
{
if
(
storePromise
=
=
=
undefined
)
{
const
path
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
"
shield
-
recipe
-
client
.
json
"
)
;
const
storage
=
new
JSONFile
(
{
path
}
)
;
storePromise
=
Task
.
spawn
(
function
*
(
)
{
yield
storage
.
load
(
)
;
return
storage
;
}
)
;
}
return
storePromise
;
}
this
.
Storage
=
{
makeStorage
(
prefix
sandbox
)
{
if
(
!
sandbox
)
{
throw
new
Error
(
"
No
sandbox
passed
"
)
;
}
const
storageInterface
=
{
getItem
(
keySuffix
)
{
return
new
sandbox
.
Promise
(
(
resolve
reject
)
=
>
{
loadStorage
(
)
.
then
(
store
=
>
{
const
namespace
=
store
.
data
[
prefix
]
|
|
{
}
;
const
value
=
namespace
[
keySuffix
]
|
|
null
;
resolve
(
Cu
.
cloneInto
(
value
sandbox
)
)
;
}
)
.
catch
(
err
=
>
{
log
.
error
(
err
)
;
reject
(
new
sandbox
.
Error
(
)
)
;
}
)
;
}
)
;
}
setItem
(
keySuffix
value
)
{
return
new
sandbox
.
Promise
(
(
resolve
reject
)
=
>
{
loadStorage
(
)
.
then
(
store
=
>
{
if
(
!
(
prefix
in
store
.
data
)
)
{
store
.
data
[
prefix
]
=
{
}
;
}
store
.
data
[
prefix
]
[
keySuffix
]
=
value
;
store
.
saveSoon
(
)
;
resolve
(
)
;
}
)
.
catch
(
err
=
>
{
log
.
error
(
err
)
;
reject
(
new
sandbox
.
Error
(
)
)
;
}
)
;
}
)
;
}
removeItem
(
keySuffix
)
{
return
new
sandbox
.
Promise
(
(
resolve
reject
)
=
>
{
loadStorage
(
)
.
then
(
store
=
>
{
if
(
!
(
prefix
in
store
.
data
)
)
{
return
;
}
delete
store
.
data
[
prefix
]
[
keySuffix
]
;
store
.
saveSoon
(
)
;
resolve
(
)
;
}
)
.
catch
(
err
=
>
{
log
.
error
(
err
)
;
reject
(
new
sandbox
.
Error
(
)
)
;
}
)
;
}
)
;
}
clear
(
)
{
return
new
sandbox
.
Promise
(
(
resolve
reject
)
=
>
{
return
loadStorage
(
)
.
then
(
store
=
>
{
store
.
data
[
prefix
]
=
{
}
;
store
.
saveSoon
(
)
;
resolve
(
)
;
}
)
.
catch
(
err
=
>
{
log
.
error
(
err
)
;
reject
(
new
sandbox
.
Error
(
)
)
;
}
)
;
}
)
;
}
}
;
return
Cu
.
cloneInto
(
storageInterface
sandbox
{
cloneFunctions
:
true
}
)
;
}
clearAllStorage
(
)
{
return
loadStorage
(
)
.
then
(
store
=
>
{
store
.
data
=
{
}
;
store
.
saveSoon
(
)
;
}
)
.
catch
(
err
=
>
{
log
.
error
(
err
)
;
}
)
;
}
}
;
