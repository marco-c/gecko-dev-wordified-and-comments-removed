exports
.
argVal
=
function
(
ast
)
{
this
.
_cursor
.
args
.
push
(
ast
)
;
}
;
exports
.
arrayStart
=
function
(
)
{
this
.
_placeAtCursor
(
{
type
:
'
ArrayLiteral
'
value
:
[
]
}
)
;
}
;
exports
.
arrayVal
=
function
(
ast
)
{
if
(
ast
)
this
.
_cursor
.
value
.
push
(
ast
)
;
}
;
exports
.
binaryOp
=
function
(
token
)
{
var
precedence
=
this
.
_grammar
[
token
.
value
]
.
precedence
|
|
0
parent
=
this
.
_cursor
.
_parent
;
while
(
parent
&
&
parent
.
operator
&
&
this
.
_grammar
[
parent
.
operator
]
.
precedence
>
=
precedence
)
{
this
.
_cursor
=
parent
;
parent
=
parent
.
_parent
;
}
var
node
=
{
type
:
'
BinaryExpression
'
operator
:
token
.
value
left
:
this
.
_cursor
}
;
this
.
_setParent
(
this
.
_cursor
node
)
;
this
.
_cursor
=
parent
;
this
.
_placeAtCursor
(
node
)
;
}
;
exports
.
dot
=
function
(
)
{
this
.
_nextIdentEncapsulate
=
this
.
_cursor
&
&
(
this
.
_cursor
.
type
!
=
'
BinaryExpression
'
|
|
(
this
.
_cursor
.
type
=
=
'
BinaryExpression
'
&
&
this
.
_cursor
.
right
)
)
&
&
this
.
_cursor
.
type
!
=
'
UnaryExpression
'
;
this
.
_nextIdentRelative
=
!
this
.
_cursor
|
|
(
this
.
_cursor
&
&
!
this
.
_nextIdentEncapsulate
)
;
if
(
this
.
_nextIdentRelative
)
this
.
_relative
=
true
;
}
;
exports
.
filter
=
function
(
ast
)
{
this
.
_placeBeforeCursor
(
{
type
:
'
FilterExpression
'
expr
:
ast
relative
:
this
.
_subParser
.
isRelative
(
)
subject
:
this
.
_cursor
}
)
;
}
;
exports
.
identifier
=
function
(
token
)
{
var
node
=
{
type
:
'
Identifier
'
value
:
token
.
value
}
;
if
(
this
.
_nextIdentEncapsulate
)
{
node
.
from
=
this
.
_cursor
;
this
.
_placeBeforeCursor
(
node
)
;
this
.
_nextIdentEncapsulate
=
false
;
}
else
{
if
(
this
.
_nextIdentRelative
)
node
.
relative
=
true
;
this
.
_placeAtCursor
(
node
)
;
}
}
;
exports
.
literal
=
function
(
token
)
{
this
.
_placeAtCursor
(
{
type
:
'
Literal
'
value
:
token
.
value
}
)
;
}
;
exports
.
objKey
=
function
(
token
)
{
this
.
_curObjKey
=
token
.
value
;
}
;
exports
.
objStart
=
function
(
)
{
this
.
_placeAtCursor
(
{
type
:
'
ObjectLiteral
'
value
:
{
}
}
)
;
}
;
exports
.
objVal
=
function
(
ast
)
{
this
.
_cursor
.
value
[
this
.
_curObjKey
]
=
ast
;
}
;
exports
.
subExpression
=
function
(
ast
)
{
this
.
_placeAtCursor
(
ast
)
;
}
;
exports
.
ternaryEnd
=
function
(
ast
)
{
this
.
_cursor
.
alternate
=
ast
;
}
;
exports
.
ternaryMid
=
function
(
ast
)
{
this
.
_cursor
.
consequent
=
ast
;
}
;
exports
.
ternaryStart
=
function
(
)
{
this
.
_tree
=
{
type
:
'
ConditionalExpression
'
test
:
this
.
_tree
}
;
this
.
_cursor
=
this
.
_tree
;
}
;
exports
.
transform
=
function
(
token
)
{
this
.
_placeBeforeCursor
(
{
type
:
'
Transform
'
name
:
token
.
value
args
:
[
]
subject
:
this
.
_cursor
}
)
;
}
;
exports
.
unaryOp
=
function
(
token
)
{
this
.
_placeAtCursor
(
{
type
:
'
UnaryExpression
'
operator
:
token
.
value
}
)
;
}
;
