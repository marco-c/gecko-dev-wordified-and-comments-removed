var
handlers
=
require
(
'
.
/
handlers
'
)
states
=
require
(
'
.
/
states
'
)
.
states
;
function
Parser
(
grammar
prefix
stopMap
)
{
this
.
_grammar
=
grammar
;
this
.
_state
=
'
expectOperand
'
;
this
.
_tree
=
null
;
this
.
_exprStr
=
prefix
|
|
'
'
;
this
.
_relative
=
false
;
this
.
_stopMap
=
stopMap
|
|
{
}
;
}
Parser
.
prototype
.
addToken
=
function
(
token
)
{
if
(
this
.
_state
=
=
'
complete
'
)
throw
new
Error
(
'
Cannot
add
a
new
token
to
a
completed
Parser
'
)
;
var
state
=
states
[
this
.
_state
]
startExpr
=
this
.
_exprStr
;
this
.
_exprStr
+
=
token
.
raw
;
if
(
state
.
subHandler
)
{
if
(
!
this
.
_subParser
)
this
.
_startSubExpression
(
startExpr
)
;
var
stopState
=
this
.
_subParser
.
addToken
(
token
)
;
if
(
stopState
)
{
this
.
_endSubExpression
(
)
;
if
(
this
.
_parentStop
)
return
stopState
;
this
.
_state
=
stopState
;
}
}
else
if
(
state
.
tokenTypes
[
token
.
type
]
)
{
var
typeOpts
=
state
.
tokenTypes
[
token
.
type
]
handleFunc
=
handlers
[
token
.
type
]
;
if
(
typeOpts
.
handler
)
handleFunc
=
typeOpts
.
handler
;
if
(
handleFunc
)
handleFunc
.
call
(
this
token
)
;
if
(
typeOpts
.
toState
)
this
.
_state
=
typeOpts
.
toState
;
}
else
if
(
this
.
_stopMap
[
token
.
type
]
)
return
this
.
_stopMap
[
token
.
type
]
;
else
{
throw
new
Error
(
'
Token
'
+
token
.
raw
+
'
(
'
+
token
.
type
+
'
)
unexpected
in
expression
:
'
+
this
.
_exprStr
)
;
}
return
false
;
}
;
Parser
.
prototype
.
addTokens
=
function
(
tokens
)
{
tokens
.
forEach
(
this
.
addToken
this
)
;
}
;
Parser
.
prototype
.
complete
=
function
(
)
{
if
(
this
.
_cursor
&
&
!
states
[
this
.
_state
]
.
completable
)
throw
new
Error
(
'
Unexpected
end
of
expression
:
'
+
this
.
_exprStr
)
;
if
(
this
.
_subParser
)
this
.
_endSubExpression
(
)
;
this
.
_state
=
'
complete
'
;
return
this
.
_cursor
?
this
.
_tree
:
null
;
}
;
Parser
.
prototype
.
isRelative
=
function
(
)
{
return
this
.
_relative
;
}
;
Parser
.
prototype
.
_endSubExpression
=
function
(
)
{
states
[
this
.
_state
]
.
subHandler
.
call
(
this
this
.
_subParser
.
complete
(
)
)
;
this
.
_subParser
=
null
;
}
;
Parser
.
prototype
.
_placeAtCursor
=
function
(
node
)
{
if
(
!
this
.
_cursor
)
this
.
_tree
=
node
;
else
{
this
.
_cursor
.
right
=
node
;
this
.
_setParent
(
node
this
.
_cursor
)
;
}
this
.
_cursor
=
node
;
}
;
Parser
.
prototype
.
_placeBeforeCursor
=
function
(
node
)
{
this
.
_cursor
=
this
.
_cursor
.
_parent
;
this
.
_placeAtCursor
(
node
)
;
}
;
Parser
.
prototype
.
_setParent
=
function
(
node
parent
)
{
Object
.
defineProperty
(
node
'
_parent
'
{
value
:
parent
writable
:
true
}
)
;
}
;
Parser
.
prototype
.
_startSubExpression
=
function
(
exprStr
)
{
var
endStates
=
states
[
this
.
_state
]
.
endStates
;
if
(
!
endStates
)
{
this
.
_parentStop
=
true
;
endStates
=
this
.
_stopMap
;
}
this
.
_subParser
=
new
Parser
(
this
.
_grammar
exprStr
endStates
)
;
}
;
module
.
exports
=
Parser
;
