var
handlers
=
require
(
'
.
/
handlers
'
)
;
var
Evaluator
=
function
(
grammar
transforms
context
relativeContext
)
{
this
.
_grammar
=
grammar
;
this
.
_transforms
=
transforms
|
|
{
}
;
this
.
_context
=
context
|
|
{
}
;
this
.
_relContext
=
relativeContext
|
|
this
.
_context
;
}
;
Evaluator
.
prototype
.
eval
=
function
(
ast
)
{
var
self
=
this
;
return
Promise
.
resolve
(
)
.
then
(
function
(
)
{
return
handlers
[
ast
.
type
]
.
call
(
self
ast
)
;
}
)
;
}
;
Evaluator
.
prototype
.
evalArray
=
function
(
arr
)
{
return
Promise
.
all
(
arr
.
map
(
function
(
elem
)
{
return
this
.
eval
(
elem
)
;
}
this
)
)
;
}
;
Evaluator
.
prototype
.
evalMap
=
function
(
map
)
{
var
keys
=
Object
.
keys
(
map
)
result
=
{
}
;
var
asts
=
keys
.
map
(
function
(
key
)
{
return
this
.
eval
(
map
[
key
]
)
;
}
this
)
;
return
Promise
.
all
(
asts
)
.
then
(
function
(
vals
)
{
vals
.
forEach
(
function
(
val
idx
)
{
result
[
keys
[
idx
]
]
=
val
;
}
)
;
return
result
;
}
)
;
}
;
Evaluator
.
prototype
.
_filterRelative
=
function
(
subject
expr
)
{
var
promises
=
[
]
;
if
(
!
Array
.
isArray
(
subject
)
)
subject
=
[
subject
]
;
subject
.
forEach
(
function
(
elem
)
{
var
evalInst
=
new
Evaluator
(
this
.
_grammar
this
.
_transforms
this
.
_context
elem
)
;
promises
.
push
(
evalInst
.
eval
(
expr
)
)
;
}
this
)
;
return
Promise
.
all
(
promises
)
.
then
(
function
(
values
)
{
var
results
=
[
]
;
values
.
forEach
(
function
(
value
idx
)
{
if
(
value
)
results
.
push
(
subject
[
idx
]
)
;
}
)
;
return
results
;
}
)
;
}
;
Evaluator
.
prototype
.
_filterStatic
=
function
(
subject
expr
)
{
return
this
.
eval
(
expr
)
.
then
(
function
(
res
)
{
if
(
typeof
res
=
=
=
'
boolean
'
)
return
res
?
subject
:
undefined
;
return
subject
[
res
]
;
}
)
;
}
;
module
.
exports
=
Evaluator
;
