exports
.
ArrayLiteral
=
function
(
ast
)
{
return
this
.
evalArray
(
ast
.
value
)
;
}
;
exports
.
BinaryExpression
=
function
(
ast
)
{
var
self
=
this
;
return
Promise
.
all
(
[
this
.
eval
(
ast
.
left
)
this
.
eval
(
ast
.
right
)
]
)
.
then
(
function
(
arr
)
{
return
self
.
_grammar
[
ast
.
operator
]
.
eval
(
arr
[
0
]
arr
[
1
]
)
;
}
)
;
}
;
exports
.
ConditionalExpression
=
function
(
ast
)
{
var
self
=
this
;
return
this
.
eval
(
ast
.
test
)
.
then
(
function
(
res
)
{
if
(
res
)
{
if
(
ast
.
consequent
)
return
self
.
eval
(
ast
.
consequent
)
;
return
res
;
}
return
self
.
eval
(
ast
.
alternate
)
;
}
)
;
}
;
exports
.
FilterExpression
=
function
(
ast
)
{
var
self
=
this
;
return
this
.
eval
(
ast
.
subject
)
.
then
(
function
(
subject
)
{
if
(
ast
.
relative
)
return
self
.
_filterRelative
(
subject
ast
.
expr
)
;
return
self
.
_filterStatic
(
subject
ast
.
expr
)
;
}
)
;
}
;
exports
.
Identifier
=
function
(
ast
)
{
if
(
ast
.
from
)
{
return
this
.
eval
(
ast
.
from
)
.
then
(
function
(
context
)
{
if
(
context
=
=
=
undefined
)
return
undefined
;
if
(
Array
.
isArray
(
context
)
)
context
=
context
[
0
]
;
return
context
[
ast
.
value
]
;
}
)
;
}
else
{
return
ast
.
relative
?
this
.
_relContext
[
ast
.
value
]
:
this
.
_context
[
ast
.
value
]
;
}
}
;
exports
.
Literal
=
function
(
ast
)
{
return
ast
.
value
;
}
;
exports
.
ObjectLiteral
=
function
(
ast
)
{
return
this
.
evalMap
(
ast
.
value
)
;
}
;
exports
.
Transform
=
function
(
ast
)
{
var
transform
=
this
.
_transforms
[
ast
.
name
]
;
if
(
!
transform
)
throw
new
Error
(
"
Transform
'
"
+
ast
.
name
+
"
'
is
not
defined
.
"
)
;
return
Promise
.
all
(
[
this
.
eval
(
ast
.
subject
)
this
.
evalArray
(
ast
.
args
|
|
[
]
)
]
)
.
then
(
function
(
arr
)
{
return
transform
.
apply
(
null
[
arr
[
0
]
]
.
concat
(
arr
[
1
]
)
)
;
}
)
;
}
;
exports
.
UnaryExpression
=
function
(
ast
)
{
var
self
=
this
;
return
this
.
eval
(
ast
.
right
)
.
then
(
function
(
right
)
{
return
self
.
_grammar
[
ast
.
operator
]
.
eval
(
right
)
;
}
)
;
}
;
