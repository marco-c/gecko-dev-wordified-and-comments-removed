var
Evaluator
=
require
(
'
.
/
evaluator
/
Evaluator
'
)
Lexer
=
require
(
'
.
/
Lexer
'
)
Parser
=
require
(
'
.
/
parser
/
Parser
'
)
defaultGrammar
=
require
(
'
.
/
grammar
'
)
.
elements
;
function
Jexl
(
)
{
this
.
_customGrammar
=
null
;
this
.
_lexer
=
null
;
this
.
_transforms
=
{
}
;
}
Jexl
.
prototype
.
addBinaryOp
=
function
(
operator
precedence
fn
)
{
this
.
_addGrammarElement
(
operator
{
type
:
'
binaryOp
'
precedence
:
precedence
eval
:
fn
}
)
;
}
;
Jexl
.
prototype
.
addUnaryOp
=
function
(
operator
fn
)
{
this
.
_addGrammarElement
(
operator
{
type
:
'
unaryOp
'
weight
:
Infinity
eval
:
fn
}
)
;
}
;
Jexl
.
prototype
.
addTransform
=
function
(
name
fn
)
{
this
.
_transforms
[
name
]
=
fn
;
}
;
Jexl
.
prototype
.
addTransforms
=
function
(
map
)
{
for
(
var
key
in
map
)
{
if
(
map
.
hasOwnProperty
(
key
)
)
this
.
_transforms
[
key
]
=
map
[
key
]
;
}
}
;
Jexl
.
prototype
.
getTransform
=
function
(
name
)
{
return
this
.
_transforms
[
name
]
;
}
;
Jexl
.
prototype
.
eval
=
function
(
expression
context
cb
)
{
if
(
typeof
context
=
=
=
'
function
'
)
{
cb
=
context
;
context
=
{
}
;
}
else
if
(
!
context
)
context
=
{
}
;
var
valPromise
=
this
.
_eval
(
expression
context
)
;
if
(
cb
)
{
var
called
=
false
;
return
valPromise
.
then
(
function
(
val
)
{
called
=
true
;
setTimeout
(
cb
.
bind
(
null
null
val
)
0
)
;
}
)
.
catch
(
function
(
err
)
{
if
(
!
called
)
setTimeout
(
cb
.
bind
(
null
err
)
0
)
;
}
)
;
}
return
valPromise
;
}
;
Jexl
.
prototype
.
removeOp
=
function
(
operator
)
{
var
grammar
=
this
.
_getCustomGrammar
(
)
;
if
(
grammar
[
operator
]
&
&
(
grammar
[
operator
]
.
type
=
=
'
binaryOp
'
|
|
grammar
[
operator
]
.
type
=
=
'
unaryOp
'
)
)
{
delete
grammar
[
operator
]
;
this
.
_lexer
=
null
;
}
}
;
Jexl
.
prototype
.
_addGrammarElement
=
function
(
str
obj
)
{
var
grammar
=
this
.
_getCustomGrammar
(
)
;
grammar
[
str
]
=
obj
;
this
.
_lexer
=
null
;
}
;
Jexl
.
prototype
.
_eval
=
function
(
exp
context
)
{
var
self
=
this
grammar
=
this
.
_getGrammar
(
)
parser
=
new
Parser
(
grammar
)
evaluator
=
new
Evaluator
(
grammar
this
.
_transforms
context
)
;
return
Promise
.
resolve
(
)
.
then
(
function
(
)
{
parser
.
addTokens
(
self
.
_getLexer
(
)
.
tokenize
(
exp
)
)
;
return
evaluator
.
eval
(
parser
.
complete
(
)
)
;
}
)
;
}
;
Jexl
.
prototype
.
_getCustomGrammar
=
function
(
)
{
if
(
!
this
.
_customGrammar
)
{
this
.
_customGrammar
=
{
}
;
for
(
var
key
in
defaultGrammar
)
{
if
(
defaultGrammar
.
hasOwnProperty
(
key
)
)
this
.
_customGrammar
[
key
]
=
defaultGrammar
[
key
]
;
}
}
return
this
.
_customGrammar
;
}
;
Jexl
.
prototype
.
_getGrammar
=
function
(
)
{
return
this
.
_customGrammar
|
|
defaultGrammar
;
}
;
Jexl
.
prototype
.
_getLexer
=
function
(
)
{
if
(
!
this
.
_lexer
)
this
.
_lexer
=
new
Lexer
(
this
.
_getGrammar
(
)
)
;
return
this
.
_lexer
;
}
;
module
.
exports
=
new
Jexl
(
)
;
module
.
exports
.
Jexl
=
Jexl
;
