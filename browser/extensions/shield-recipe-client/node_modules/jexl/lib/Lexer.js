var
numericRegex
=
/
^
-
?
(
?
:
(
?
:
[
0
-
9
]
*
\
.
[
0
-
9
]
+
)
|
[
0
-
9
]
+
)
/
identRegex
=
/
^
[
a
-
zA
-
Z_
\
]
[
a
-
zA
-
Z0
-
9_
\
]
*
/
escEscRegex
=
/
\
\
\
\
/
preOpRegexElems
=
[
"
'
(
?
:
(
?
:
\
\
\
\
'
)
?
[
^
'
]
)
*
'
"
'
"
(
?
:
(
?
:
\
\
\
\
"
)
?
[
^
"
]
)
*
"
'
'
\
\
s
+
'
'
\
\
btrue
\
\
b
'
'
\
\
bfalse
\
\
b
'
]
postOpRegexElems
=
[
'
\
\
b
[
a
-
zA
-
Z_
\
\
]
[
a
-
zA
-
Z0
-
9_
\
\
]
*
\
\
b
'
'
(
?
:
(
?
:
[
0
-
9
]
*
\
\
.
[
0
-
9
]
+
)
|
[
0
-
9
]
+
)
'
]
minusNegatesAfter
=
[
'
binaryOp
'
'
unaryOp
'
'
openParen
'
'
openBracket
'
'
question
'
'
colon
'
]
;
function
Lexer
(
grammar
)
{
this
.
_grammar
=
grammar
;
}
Lexer
.
prototype
.
getElements
=
function
(
str
)
{
var
regex
=
this
.
_getSplitRegex
(
)
;
return
str
.
split
(
regex
)
.
filter
(
function
(
elem
)
{
return
elem
;
}
)
;
}
;
Lexer
.
prototype
.
getTokens
=
function
(
elements
)
{
var
tokens
=
[
]
negate
=
false
;
for
(
var
i
=
0
;
i
<
elements
.
length
;
i
+
+
)
{
if
(
this
.
_isWhitespace
(
elements
[
i
]
)
)
{
if
(
tokens
.
length
)
tokens
[
tokens
.
length
-
1
]
.
raw
+
=
elements
[
i
]
;
}
else
if
(
elements
[
i
]
=
=
=
'
-
'
&
&
this
.
_isNegative
(
tokens
)
)
negate
=
true
;
else
{
if
(
negate
)
{
elements
[
i
]
=
'
-
'
+
elements
[
i
]
;
negate
=
false
;
}
tokens
.
push
(
this
.
_createToken
(
elements
[
i
]
)
)
;
}
}
if
(
negate
)
tokens
.
push
(
this
.
_createToken
(
'
-
'
)
)
;
return
tokens
;
}
;
Lexer
.
prototype
.
tokenize
=
function
(
str
)
{
var
elements
=
this
.
getElements
(
str
)
;
return
this
.
getTokens
(
elements
)
;
}
;
Lexer
.
prototype
.
_createToken
=
function
(
element
)
{
var
token
=
{
type
:
'
literal
'
value
:
element
raw
:
element
}
;
if
(
element
[
0
]
=
=
'
"
'
|
|
element
[
0
]
=
=
"
'
"
)
token
.
value
=
this
.
_unquote
(
element
)
;
else
if
(
element
.
match
(
numericRegex
)
)
token
.
value
=
parseFloat
(
element
)
;
else
if
(
element
=
=
=
'
true
'
|
|
element
=
=
=
'
false
'
)
token
.
value
=
element
=
=
=
'
true
'
;
else
if
(
this
.
_grammar
[
element
]
)
token
.
type
=
this
.
_grammar
[
element
]
.
type
;
else
if
(
element
.
match
(
identRegex
)
)
token
.
type
=
'
identifier
'
;
else
throw
new
Error
(
"
Invalid
expression
token
:
"
+
element
)
;
return
token
;
}
;
Lexer
.
prototype
.
_escapeRegExp
=
function
(
str
)
{
str
=
str
.
replace
(
/
[
.
*
+
?
^
{
}
(
)
|
[
\
]
\
\
]
/
g
"
\
\
&
"
)
;
if
(
str
.
match
(
identRegex
)
)
str
=
'
\
\
b
'
+
str
+
'
\
\
b
'
;
return
str
;
}
;
Lexer
.
prototype
.
_getSplitRegex
=
function
(
)
{
if
(
!
this
.
_splitRegex
)
{
var
elemArray
=
Object
.
keys
(
this
.
_grammar
)
;
elemArray
=
elemArray
.
sort
(
function
(
a
b
)
{
return
b
.
length
-
a
.
length
;
}
)
.
map
(
function
(
elem
)
{
return
this
.
_escapeRegExp
(
elem
)
;
}
this
)
;
this
.
_splitRegex
=
new
RegExp
(
'
(
'
+
[
preOpRegexElems
.
join
(
'
|
'
)
elemArray
.
join
(
'
|
'
)
postOpRegexElems
.
join
(
'
|
'
)
]
.
join
(
'
|
'
)
+
'
)
'
)
;
}
return
this
.
_splitRegex
;
}
;
Lexer
.
prototype
.
_isNegative
=
function
(
tokens
)
{
if
(
!
tokens
.
length
)
return
true
;
return
minusNegatesAfter
.
some
(
function
(
type
)
{
return
type
=
=
=
tokens
[
tokens
.
length
-
1
]
.
type
;
}
)
;
}
;
Lexer
.
prototype
.
_isWhitespace
=
function
(
str
)
{
for
(
var
i
=
0
;
i
<
str
.
length
;
i
+
+
)
{
if
(
str
[
i
]
!
=
'
'
)
return
false
;
}
return
true
;
}
;
Lexer
.
prototype
.
_unquote
=
function
(
str
)
{
var
quote
=
str
[
0
]
escQuoteRegex
=
new
RegExp
(
'
\
\
\
\
'
+
quote
'
g
'
)
;
return
str
.
substr
(
1
str
.
length
-
2
)
.
replace
(
escQuoteRegex
quote
)
.
replace
(
escEscRegex
'
\
\
'
)
;
}
;
module
.
exports
=
Lexer
;
