"
use
strict
"
;
class
PictureInPictureVideoWrapper
{
play
(
video
)
{
video
.
play
(
)
.
catch
(
(
)
=
>
{
video
.
play
(
)
;
}
)
;
}
setCurrentTime
(
video
position
wasPlaying
)
{
if
(
wasPlaying
=
=
=
undefined
)
{
this
.
wasPlaying
=
!
video
.
paused
;
}
video
.
currentTime
=
position
;
if
(
video
.
readyState
<
video
.
HAVE_CURRENT_DATA
)
{
video
.
play
(
)
.
then
(
(
)
=
>
{
if
(
!
wasPlaying
)
{
video
.
pause
(
)
;
}
}
)
.
catch
(
(
)
=
>
{
if
(
wasPlaying
)
{
this
.
play
(
video
)
;
}
}
)
;
}
}
setCaptionContainerObserver
(
video
updateCaptionsFunction
)
{
let
container
=
document
?
.
querySelector
(
"
#
dv
-
web
-
player
"
)
;
if
(
container
)
{
updateCaptionsFunction
(
"
"
)
;
const
callback
=
function
(
mutationsList
)
{
for
(
const
mutation
of
mutationsList
)
{
let
text
;
if
(
container
?
.
querySelector
(
"
.
atvwebplayersdk
-
player
-
container
"
)
)
{
text
=
container
?
.
querySelector
(
"
.
f35bt6a
"
)
?
.
querySelector
(
"
.
atvwebplayersdk
-
captions
-
text
"
)
?
.
innerText
;
}
else
{
text
=
container
?
.
querySelector
(
"
.
persistentPanel
"
)
?
.
querySelector
(
"
span
"
)
?
.
innerText
;
}
if
(
!
text
)
{
updateCaptionsFunction
(
"
"
)
;
return
;
}
updateCaptionsFunction
(
text
)
;
}
}
;
callback
(
[
1
]
null
)
;
this
.
captionsObserver
=
new
MutationObserver
(
callback
)
;
this
.
captionsObserver
.
observe
(
container
{
attributes
:
true
childList
:
true
subtree
:
true
}
)
;
}
}
removeCaptionContainerObserver
(
)
{
this
.
captionsObserver
?
.
disconnect
(
)
;
}
shouldHideToggle
(
video
)
{
return
!
!
video
.
classList
.
contains
(
"
tst
-
video
-
overlay
-
player
-
html5
"
)
;
}
}
this
.
PictureInPictureVideoWrapper
=
PictureInPictureVideoWrapper
;
