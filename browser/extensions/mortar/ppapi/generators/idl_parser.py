"
"
"
Parser
for
PPAPI
IDL
"
"
"
import
getopt
import
glob
import
os
.
path
import
re
import
sys
import
time
from
idl_ast
import
IDLAst
from
idl_log
import
ErrOut
InfoOut
WarnOut
from
idl_lexer
import
IDLLexer
from
idl_node
import
IDLAttribute
IDLFile
IDLNode
from
idl_option
import
GetOption
Option
ParseOptions
from
idl_lint
import
Lint
from
ply
import
lex
from
ply
import
yacc
Option
(
'
build_debug
'
'
Debug
tree
building
.
'
)
Option
(
'
parse_debug
'
'
Debug
parse
reduction
steps
.
'
)
Option
(
'
token_debug
'
'
Debug
token
generation
.
'
)
Option
(
'
dump_tree
'
'
Dump
the
tree
.
'
)
Option
(
'
srcroot
'
'
Working
directory
.
'
default
=
os
.
path
.
join
(
'
.
.
'
'
api
'
)
)
Option
(
'
include_private
'
'
Include
private
IDL
directory
in
default
API
paths
.
'
)
ERROR_REMAP
=
{
  
'
Unexpected
"
)
"
after
"
(
"
.
'
:
'
Empty
argument
list
.
'
  
'
Unexpected
"
)
"
after
"
"
.
'
:
'
Missing
argument
.
'
  
'
Unexpected
"
}
"
after
"
"
.
'
:
'
Trailing
comma
in
block
.
'
  
'
Unexpected
"
}
"
after
"
{
"
.
'
:
'
Unexpected
empty
block
.
'
  
'
Unexpected
comment
after
"
}
"
.
'
:
'
Unexpected
trailing
comment
.
'
  
'
Unexpected
"
{
"
after
keyword
"
enum
"
.
'
:
'
Enum
missing
name
.
'
  
'
Unexpected
"
{
"
after
keyword
"
struct
"
.
'
:
'
Struct
missing
name
.
'
  
'
Unexpected
"
{
"
after
keyword
"
interface
"
.
'
:
'
Interface
missing
name
.
'
}
def
DumpReduction
(
cls
p
)
:
  
if
p
[
0
]
is
None
:
    
InfoOut
.
Log
(
"
OBJ
:
%
s
(
%
d
)
-
None
\
n
"
%
(
cls
len
(
p
)
)
)
    
InfoOut
.
Log
(
"
[
%
s
]
\
n
"
%
[
str
(
x
)
for
x
in
p
[
1
:
]
]
)
  
else
:
    
out
=
"
"
    
for
index
in
range
(
len
(
p
)
-
1
)
:
      
out
+
=
"
>
%
s
<
"
%
str
(
p
[
index
+
1
]
)
    
InfoOut
.
Log
(
"
OBJ
:
%
s
(
%
d
)
-
%
s
:
%
s
\
n
"
%
(
cls
len
(
p
)
str
(
p
[
0
]
)
out
)
)
def
CopyToList
(
item
)
:
  
if
not
item
:
item
=
[
]
  
if
type
(
item
)
is
not
type
(
[
]
)
:
item
=
[
item
]
  
return
list
(
item
)
def
ListFromConcat
(
*
items
)
:
  
itemsout
=
[
]
  
for
item
in
items
:
    
itemlist
=
CopyToList
(
item
)
    
itemsout
.
extend
(
itemlist
)
  
return
itemsout
def
TokenTypeName
(
t
)
:
  
if
t
.
type
=
=
'
SYMBOL
'
:
return
'
symbol
%
s
'
%
t
.
value
  
if
t
.
type
in
[
'
HEX
'
'
INT
'
'
OCT
'
'
FLOAT
'
]
:
    
return
'
value
%
s
'
%
t
.
value
  
if
t
.
type
=
=
'
STRING
'
:
return
'
string
"
%
s
"
'
%
t
.
value
  
if
t
.
type
=
=
'
COMMENT
'
:
return
'
comment
'
  
if
t
.
type
=
=
t
.
value
:
return
'
"
%
s
"
'
%
t
.
value
  
return
'
keyword
"
%
s
"
'
%
t
.
value
class
IDLParser
(
IDLLexer
)
:
  
def
p_top
(
self
p
)
:
    
"
"
"
top
:
COMMENT
COMMENT
ext_attr_block
top_list
"
"
"
    
Copyright
=
self
.
BuildComment
(
'
Copyright
'
p
1
)
    
Filedoc
=
self
.
BuildComment
(
'
Comment
'
p
2
)
    
p
[
0
]
=
ListFromConcat
(
Copyright
Filedoc
p
[
3
]
p
[
4
]
)
    
if
self
.
parse_debug
:
DumpReduction
(
'
top
'
p
)
  
def
p_top_short
(
self
p
)
:
    
"
"
"
top
:
COMMENT
ext_attr_block
top_list
"
"
"
    
Copyright
=
self
.
BuildComment
(
'
Copyright
'
p
1
)
    
Filedoc
=
IDLNode
(
'
Comment
'
self
.
lexobj
.
filename
p
.
lineno
(
2
)
-
1
        
p
.
lexpos
(
2
)
-
1
[
self
.
BuildAttribute
(
'
NAME
'
'
'
)
          
self
.
BuildAttribute
(
'
FORM
'
'
cc
'
)
]
)
    
p
[
0
]
=
ListFromConcat
(
Copyright
Filedoc
p
[
2
]
p
[
3
]
)
    
if
self
.
parse_debug
:
DumpReduction
(
'
top
'
p
)
  
def
p_top_list
(
self
p
)
:
    
"
"
"
top_list
:
callback_decl
top_list
                
|
describe_block
top_list
                
|
dictionary_block
top_list
                
|
enum_block
top_list
                
|
inline
top_list
                
|
interface_block
top_list
                
|
label_block
top_list
                
|
namespace
top_list
                
|
struct_block
top_list
                
|
typedef_decl
top_list
                
|
bad_decl
top_list
                
|
"
"
"
    
if
len
(
p
)
>
2
:
      
p
[
0
]
=
ListFromConcat
(
p
[
1
]
p
[
2
]
)
    
if
self
.
parse_debug
:
DumpReduction
(
'
top_list
'
p
)
  
def
p_top_error
(
self
p
)
:
    
"
"
"
top_list
:
error
top_list
"
"
"
    
p
[
0
]
=
p
[
2
]
  
def
p_bad_decl
(
self
p
)
:
    
"
"
"
bad_decl
:
modifiers
SYMBOL
error
'
}
'
'
;
'
"
"
"
    
p
[
0
]
=
[
]
  
def
p_modifiers
(
self
p
)
:
    
"
"
"
modifiers
:
comments
ext_attr_block
"
"
"
    
p
[
0
]
=
ListFromConcat
(
p
[
1
]
p
[
2
]
)
    
if
self
.
parse_debug
:
DumpReduction
(
'
modifiers
'
p
)
  
def
p_scoped_name
(
self
p
)
:
    
"
"
"
scoped_name
:
SYMBOL
scoped_name_rest
"
"
"
    
p
[
0
]
=
'
'
.
join
(
p
[
1
:
]
)
    
if
self
.
parse_debug
:
DumpReduction
(
'
scoped_name
'
p
)
  
def
p_scoped_name_rest
(
self
p
)
:
    
"
"
"
scoped_name_rest
:
'
.
'
scoped_name
                        
|
"
"
"
    
p
[
0
]
=
'
'
.
join
(
p
[
1
:
]
)
    
if
self
.
parse_debug
:
DumpReduction
(
'
scoped_name_rest
'
p
)
  
def
p_typeref
(
self
p
)
:
    
"
"
"
typeref
:
scoped_name
"
"
"
    
p
[
0
]
=
p
[
1
]
    
if
self
.
parse_debug
:
DumpReduction
(
'
typeref
'
p
)
  
def
p_comments
(
self
p
)
:
    
"
"
"
comments
:
COMMENT
comments
                
|
"
"
"
    
if
len
(
p
)
>
1
:
      
child
=
self
.
BuildComment
(
'
Comment
'
p
1
)
      
p
[
0
]
=
ListFromConcat
(
child
p
[
2
]
)
      
if
self
.
parse_debug
:
DumpReduction
(
'
comments
'
p
)
    
else
:
      
if
self
.
parse_debug
:
DumpReduction
(
'
no
comments
'
p
)
  
def
p_namespace
(
self
p
)
:
    
"
"
"
namespace
:
modifiers
NAMESPACE
namespace_name
'
{
'
top_list
'
}
'
'
;
'
"
"
"
    
children
=
ListFromConcat
(
p
[
1
]
p
[
5
]
)
    
p
[
0
]
=
self
.
BuildNamed
(
'
Namespace
'
p
3
children
)
  
def
p_namespace_name
(
self
p
)
:
    
"
"
"
namespace_name
:
scoped_name
"
"
"
    
p
[
0
]
=
p
[
1
]
  
def
p_dictionary_block
(
self
p
)
:
    
"
"
"
dictionary_block
:
modifiers
DICTIONARY
SYMBOL
'
{
'
struct_list
'
}
'
'
;
'
"
"
"
    
p
[
0
]
=
self
.
BuildNamed
(
'
Dictionary
'
p
3
ListFromConcat
(
p
[
1
]
p
[
5
]
)
)
  
def
p_dictionary_errorA
(
self
p
)
:
    
"
"
"
dictionary_block
:
modifiers
DICTIONARY
error
'
;
'
"
"
"
    
p
[
0
]
=
[
]
  
def
p_dictionary_errorB
(
self
p
)
:
    
"
"
"
dictionary_block
:
modifiers
DICTIONARY
error
'
{
'
struct_list
'
}
'
'
;
'
"
"
"
    
p
[
0
]
=
[
]
  
def
p_callback_decl
(
self
p
)
:
    
"
"
"
callback_decl
:
modifiers
CALLBACK
SYMBOL
'
=
'
SYMBOL
param_list
'
;
'
"
"
"
    
children
=
ListFromConcat
(
p
[
1
]
p
[
6
]
)
    
p
[
0
]
=
self
.
BuildNamed
(
'
Callback
'
p
3
children
)
  
def
p_inline
(
self
p
)
:
    
"
"
"
inline
:
modifiers
INLINE
"
"
"
    
words
=
p
[
2
]
.
split
(
)
    
name
=
self
.
BuildAttribute
(
'
NAME
'
words
[
1
]
)
    
lines
=
p
[
2
]
.
split
(
'
\
n
'
)
    
value
=
self
.
BuildAttribute
(
'
VALUE
'
'
\
n
'
.
join
(
lines
[
1
:
-
1
]
)
+
'
\
n
'
)
    
children
=
ListFromConcat
(
name
value
p
[
1
]
)
    
p
[
0
]
=
self
.
BuildProduction
(
'
Inline
'
p
2
children
)
    
if
self
.
parse_debug
:
DumpReduction
(
'
inline
'
p
)
  
def
p_ext_attr_block
(
self
p
)
:
    
"
"
"
ext_attr_block
:
'
[
'
ext_attr_list
'
]
'
                  
|
"
"
"
    
if
len
(
p
)
>
1
:
      
p
[
0
]
=
p
[
2
]
      
if
self
.
parse_debug
:
DumpReduction
(
'
ext_attr_block
'
p
)
    
else
:
      
if
self
.
parse_debug
:
DumpReduction
(
'
no
ext_attr_block
'
p
)
  
def
p_ext_attr_list
(
self
p
)
:
    
"
"
"
ext_attr_list
:
SYMBOL
'
=
'
SYMBOL
ext_attr_cont
                     
|
SYMBOL
'
=
'
value
ext_attr_cont
                     
|
SYMBOL
'
=
'
SYMBOL
param_list
ext_attr_cont
                     
|
SYMBOL
ext_attr_cont
"
"
"
    
if
len
(
p
)
=
=
5
:
      
p
[
0
]
=
ListFromConcat
(
self
.
BuildAttribute
(
p
[
1
]
p
[
3
]
)
p
[
4
]
)
    
elif
len
(
p
)
=
=
6
:
      
member
=
self
.
BuildNamed
(
'
Member
'
p
3
[
p
[
4
]
]
)
      
p
[
0
]
=
ListFromConcat
(
self
.
BuildAttribute
(
p
[
1
]
member
)
p
[
5
]
)
    
else
:
      
p
[
0
]
=
ListFromConcat
(
self
.
BuildAttribute
(
p
[
1
]
'
True
'
)
p
[
2
]
)
    
if
self
.
parse_debug
:
DumpReduction
(
'
ext_attribute_list
'
p
)
  
def
p_ext_attr_list_values
(
self
p
)
:
    
"
"
"
ext_attr_list
:
SYMBOL
'
=
'
'
(
'
values
'
)
'
ext_attr_cont
                     
|
SYMBOL
'
=
'
'
(
'
symbols
'
)
'
ext_attr_cont
"
"
"
    
p
[
0
]
=
ListFromConcat
(
self
.
BuildAttribute
(
p
[
1
]
p
[
4
]
)
p
[
6
]
)
  
def
p_values
(
self
p
)
:
    
"
"
"
values
:
value
values_cont
"
"
"
    
p
[
0
]
=
ListFromConcat
(
p
[
1
]
p
[
2
]
)
  
def
p_symbols
(
self
p
)
:
    
"
"
"
symbols
:
SYMBOL
symbols_cont
"
"
"
    
p
[
0
]
=
ListFromConcat
(
p
[
1
]
p
[
2
]
)
  
def
p_symbols_cont
(
self
p
)
:
    
"
"
"
symbols_cont
:
'
'
SYMBOL
symbols_cont
                    
|
"
"
"
    
if
len
(
p
)
>
1
:
p
[
0
]
=
ListFromConcat
(
p
[
2
]
p
[
3
]
)
  
def
p_values_cont
(
self
p
)
:
    
"
"
"
values_cont
:
'
'
value
values_cont
                   
|
"
"
"
    
if
len
(
p
)
>
1
:
p
[
0
]
=
ListFromConcat
(
p
[
2
]
p
[
3
]
)
  
def
p_ext_attr_cont
(
self
p
)
:
    
"
"
"
ext_attr_cont
:
'
'
ext_attr_list
                     
|
"
"
"
    
if
len
(
p
)
>
1
:
p
[
0
]
=
p
[
2
]
    
if
self
.
parse_debug
:
DumpReduction
(
'
ext_attribute_cont
'
p
)
  
def
p_ext_attr_func
(
self
p
)
:
    
"
"
"
ext_attr_list
:
SYMBOL
'
(
'
attr_arg_list
'
)
'
ext_attr_cont
"
"
"
    
p
[
0
]
=
ListFromConcat
(
self
.
BuildAttribute
(
p
[
1
]
+
'
(
)
'
p
[
3
]
)
p
[
5
]
)
    
if
self
.
parse_debug
:
DumpReduction
(
'
attr_arg_func
'
p
)
  
def
p_ext_attr_arg_list
(
self
p
)
:
    
"
"
"
attr_arg_list
:
SYMBOL
attr_arg_cont
                     
|
value
attr_arg_cont
"
"
"
    
p
[
0
]
=
ListFromConcat
(
p
[
1
]
p
[
2
]
)
  
def
p_attr_arg_cont
(
self
p
)
:
    
"
"
"
attr_arg_cont
:
'
'
attr_arg_list
                     
|
"
"
"
    
if
self
.
parse_debug
:
DumpReduction
(
'
attr_arg_cont
'
p
)
    
if
len
(
p
)
>
1
:
p
[
0
]
=
p
[
2
]
  
def
p_attr_arg_error
(
self
p
)
:
    
"
"
"
attr_arg_cont
:
error
attr_arg_cont
"
"
"
    
p
[
0
]
=
p
[
2
]
    
if
self
.
parse_debug
:
DumpReduction
(
'
attr_arg_error
'
p
)
  
def
p_describe_block
(
self
p
)
:
    
"
"
"
describe_block
:
modifiers
DESCRIBE
'
{
'
describe_list
'
}
'
'
;
'
"
"
"
    
children
=
ListFromConcat
(
p
[
1
]
p
[
4
]
)
    
p
[
0
]
=
self
.
BuildProduction
(
'
Describe
'
p
2
children
)
    
if
self
.
parse_debug
:
DumpReduction
(
'
describe_block
'
p
)
  
def
p_describe_error
(
self
p
)
:
    
"
"
"
describe_list
:
error
describe_list
"
"
"
    
p
[
0
]
=
[
]
  
def
p_describe_list
(
self
p
)
:
    
"
"
"
describe_list
:
modifiers
SYMBOL
'
;
'
describe_list
                     
|
modifiers
ENUM
'
;
'
describe_list
                     
|
modifiers
STRUCT
'
;
'
describe_list
                     
|
modifiers
TYPEDEF
'
;
'
describe_list
                     
|
"
"
"
    
if
len
(
p
)
>
1
:
      
Type
=
self
.
BuildNamed
(
'
Type
'
p
2
p
[
1
]
)
      
p
[
0
]
=
ListFromConcat
(
Type
p
[
4
]
)
  
def
p_value
(
self
p
)
:
    
"
"
"
value
:
FLOAT
             
|
HEX
             
|
INT
             
|
OCT
             
|
STRING
"
"
"
    
p
[
0
]
=
p
[
1
]
    
if
self
.
parse_debug
:
DumpReduction
(
'
value
'
p
)
  
def
p_value_lshift
(
self
p
)
:
    
"
"
"
value
:
integer
LSHIFT
INT
"
"
"
    
p
[
0
]
=
"
%
s
<
<
%
s
"
%
(
p
[
1
]
p
[
3
]
)
    
if
self
.
parse_debug
:
DumpReduction
(
'
value
'
p
)
  
def
p_integer
(
self
p
)
:
    
"
"
"
integer
:
HEX
               
|
INT
               
|
OCT
"
"
"
    
p
[
0
]
=
p
[
1
]
    
if
self
.
parse_debug
:
DumpReduction
(
'
integer
'
p
)
  
precedence
=
(
    
(
'
left
'
'
|
'
'
&
'
'
^
'
)
    
(
'
left
'
'
LSHIFT
'
'
RSHIFT
'
)
    
(
'
left
'
'
+
'
'
-
'
)
    
(
'
left
'
'
*
'
'
/
'
)
    
(
'
right
'
'
UMINUS
'
'
~
'
)
    
)
  
def
p_expression_binop
(
self
p
)
:
    
"
"
"
expression
:
expression
LSHIFT
expression
                  
|
expression
RSHIFT
expression
                  
|
expression
'
|
'
expression
                  
|
expression
'
&
'
expression
                  
|
expression
'
^
'
expression
                  
|
expression
'
+
'
expression
                  
|
expression
'
-
'
expression
                  
|
expression
'
*
'
expression
                  
|
expression
'
/
'
expression
"
"
"
    
p
[
0
]
=
"
%
s
%
s
%
s
"
%
(
str
(
p
[
1
]
)
str
(
p
[
2
]
)
str
(
p
[
3
]
)
)
    
if
self
.
parse_debug
:
DumpReduction
(
'
expression_binop
'
p
)
  
def
p_expression_unop
(
self
p
)
:
    
"
"
"
expression
:
'
-
'
expression
%
prec
UMINUS
                  
|
'
~
'
expression
%
prec
'
~
'
"
"
"
    
p
[
0
]
=
"
%
s
%
s
"
%
(
str
(
p
[
1
]
)
str
(
p
[
2
]
)
)
    
if
self
.
parse_debug
:
DumpReduction
(
'
expression_unop
'
p
)
  
def
p_expression_term
(
self
p
)
:
    
"
"
"
expression
:
'
(
'
expression
'
)
'
"
"
"
    
p
[
0
]
=
"
%
s
%
s
%
s
"
%
(
str
(
p
[
1
]
)
str
(
p
[
2
]
)
str
(
p
[
3
]
)
)
    
if
self
.
parse_debug
:
DumpReduction
(
'
expression_term
'
p
)
  
def
p_expression_symbol
(
self
p
)
:
    
"
"
"
expression
:
SYMBOL
"
"
"
    
p
[
0
]
=
p
[
1
]
    
if
self
.
parse_debug
:
DumpReduction
(
'
expression_symbol
'
p
)
  
def
p_expression_integer
(
self
p
)
:
    
"
"
"
expression
:
integer
"
"
"
    
p
[
0
]
=
p
[
1
]
    
if
self
.
parse_debug
:
DumpReduction
(
'
expression_integer
'
p
)
  
def
p_arrays
(
self
p
)
:
    
"
"
"
arrays
:
'
[
'
'
]
'
arrays
              
|
'
[
'
integer
'
]
'
arrays
              
|
"
"
"
    
if
len
(
p
)
=
=
4
:
      
array
=
self
.
BuildProduction
(
'
Array
'
p
1
)
      
p
[
0
]
=
ListFromConcat
(
array
p
[
3
]
)
    
elif
len
(
p
)
=
=
5
:
      
count
=
self
.
BuildAttribute
(
'
FIXED
'
p
[
2
]
)
      
array
=
self
.
BuildProduction
(
'
Array
'
p
2
[
count
]
)
      
p
[
0
]
=
ListFromConcat
(
array
p
[
4
]
)
    
elif
len
(
p
)
=
=
1
:
return
    
if
self
.
parse_debug
:
DumpReduction
(
'
arrays
'
p
)
  
def
p_identifier
(
self
p
)
:
    
"
"
"
identifier
:
SYMBOL
                  
|
CALLBACK
"
"
"
    
p
[
0
]
=
p
[
1
]
    
p
.
set_lineno
(
0
p
.
lineno
(
1
)
)
  
def
p_union_option
(
self
p
)
:
    
"
"
"
union_option
:
modifiers
SYMBOL
arrays
"
"
"
    
typeref
=
self
.
BuildAttribute
(
'
TYPEREF
'
p
[
2
]
)
    
children
=
ListFromConcat
(
p
[
1
]
typeref
p
[
3
]
)
    
p
[
0
]
=
self
.
BuildProduction
(
'
Option
'
p
2
children
)
  
def
p_union_list
(
self
p
)
:
    
"
"
"
union_list
:
union_option
OR
union_list
                  
|
union_option
"
"
"
    
if
len
(
p
)
>
2
:
      
p
[
0
]
=
ListFromConcat
(
p
[
1
]
p
[
3
]
)
    
else
:
      
p
[
0
]
=
p
[
1
]
  
def
p_param_list
(
self
p
)
:
    
"
"
"
param_list
:
'
(
'
param_item
param_cont
'
)
'
                  
|
'
(
'
'
)
'
"
"
"
    
if
len
(
p
)
>
3
:
      
args
=
ListFromConcat
(
p
[
2
]
p
[
3
]
)
    
else
:
      
args
=
[
]
    
p
[
0
]
=
self
.
BuildProduction
(
'
Callspec
'
p
1
args
)
    
if
self
.
parse_debug
:
DumpReduction
(
'
param_list
'
p
)
  
def
p_param_item
(
self
p
)
:
    
"
"
"
param_item
:
modifiers
optional
typeref
arrays
identifier
"
"
"
    
typeref
=
self
.
BuildAttribute
(
'
TYPEREF
'
p
[
3
]
)
    
children
=
ListFromConcat
(
p
[
1
]
p
[
2
]
typeref
p
[
4
]
)
    
p
[
0
]
=
self
.
BuildNamed
(
'
Param
'
p
5
children
)
    
if
self
.
parse_debug
:
DumpReduction
(
'
param_item
'
p
)
  
def
p_param_item_union
(
self
p
)
:
    
"
"
"
param_item
:
modifiers
optional
'
(
'
union_list
'
)
'
identifier
"
"
"
    
union
=
self
.
BuildAttribute
(
'
Union
'
True
)
    
children
=
ListFromConcat
(
p
[
1
]
p
[
2
]
p
[
4
]
union
)
    
p
[
0
]
=
self
.
BuildNamed
(
'
Param
'
p
6
children
)
    
if
self
.
parse_debug
:
DumpReduction
(
'
param_item
'
p
)
  
def
p_optional
(
self
p
)
:
    
"
"
"
optional
:
OPTIONAL
                
|
"
"
"
    
if
len
(
p
)
=
=
2
:
      
p
[
0
]
=
self
.
BuildAttribute
(
'
OPTIONAL
'
True
)
  
def
p_param_cont
(
self
p
)
:
    
"
"
"
param_cont
:
'
'
param_item
param_cont
                  
|
"
"
"
    
if
len
(
p
)
>
1
:
      
p
[
0
]
=
ListFromConcat
(
p
[
2
]
p
[
3
]
)
      
if
self
.
parse_debug
:
DumpReduction
(
'
param_cont
'
p
)
  
def
p_param_error
(
self
p
)
:
    
"
"
"
param_cont
:
error
param_cont
"
"
"
    
p
[
0
]
=
p
[
2
]
  
def
p_typedef_data
(
self
p
)
:
    
"
"
"
typedef_decl
:
modifiers
TYPEDEF
SYMBOL
SYMBOL
'
;
'
"
"
"
    
typeref
=
self
.
BuildAttribute
(
'
TYPEREF
'
p
[
3
]
)
    
children
=
ListFromConcat
(
p
[
1
]
typeref
)
    
p
[
0
]
=
self
.
BuildNamed
(
'
Typedef
'
p
4
children
)
    
if
self
.
parse_debug
:
DumpReduction
(
'
typedef_data
'
p
)
  
def
p_typedef_array
(
self
p
)
:
    
"
"
"
typedef_decl
:
modifiers
TYPEDEF
SYMBOL
arrays
SYMBOL
'
;
'
"
"
"
    
typeref
=
self
.
BuildAttribute
(
'
TYPEREF
'
p
[
3
]
)
    
children
=
ListFromConcat
(
p
[
1
]
typeref
p
[
4
]
)
    
p
[
0
]
=
self
.
BuildNamed
(
'
Typedef
'
p
5
children
)
    
if
self
.
parse_debug
:
DumpReduction
(
'
typedef_array
'
p
)
  
def
p_typedef_func
(
self
p
)
:
    
"
"
"
typedef_decl
:
modifiers
TYPEDEF
SYMBOL
SYMBOL
param_list
'
;
'
"
"
"
    
typeref
=
self
.
BuildAttribute
(
'
TYPEREF
'
p
[
3
]
)
    
children
=
ListFromConcat
(
p
[
1
]
typeref
p
[
5
]
)
    
p
[
0
]
=
self
.
BuildNamed
(
'
Typedef
'
p
4
children
)
    
if
self
.
parse_debug
:
DumpReduction
(
'
typedef_func
'
p
)
  
def
p_enum_block
(
self
p
)
:
    
"
"
"
enum_block
:
modifiers
ENUM
SYMBOL
'
{
'
enum_list
'
}
'
'
;
'
"
"
"
    
p
[
0
]
=
self
.
BuildNamed
(
'
Enum
'
p
3
ListFromConcat
(
p
[
1
]
p
[
5
]
)
)
    
if
self
.
parse_debug
:
DumpReduction
(
'
enum_block
'
p
)
  
def
p_enum_errorA
(
self
p
)
:
    
"
"
"
enum_block
:
modifiers
ENUM
error
'
{
'
enum_list
'
}
'
'
;
'
"
"
"
    
p
[
0
]
=
[
]
  
def
p_enum_errorB
(
self
p
)
:
    
"
"
"
enum_block
:
modifiers
ENUM
error
'
;
'
"
"
"
    
p
[
0
]
=
[
]
  
def
p_enum_list
(
self
p
)
:
    
"
"
"
enum_list
:
modifiers
SYMBOL
'
=
'
expression
enum_cont
                 
|
modifiers
SYMBOL
enum_cont
"
"
"
    
if
len
(
p
)
>
4
:
      
val
=
self
.
BuildAttribute
(
'
VALUE
'
p
[
4
]
)
      
enum
=
self
.
BuildNamed
(
'
EnumItem
'
p
2
ListFromConcat
(
val
p
[
1
]
)
)
      
p
[
0
]
=
ListFromConcat
(
enum
p
[
5
]
)
    
else
:
      
enum
=
self
.
BuildNamed
(
'
EnumItem
'
p
2
p
[
1
]
)
      
p
[
0
]
=
ListFromConcat
(
enum
p
[
3
]
)
    
if
self
.
parse_debug
:
DumpReduction
(
'
enum_list
'
p
)
  
def
p_enum_cont
(
self
p
)
:
    
"
"
"
enum_cont
:
'
'
enum_list
                 
|
"
"
"
    
if
len
(
p
)
>
1
:
p
[
0
]
=
p
[
2
]
    
if
self
.
parse_debug
:
DumpReduction
(
'
enum_cont
'
p
)
  
def
p_enum_cont_error
(
self
p
)
:
    
"
"
"
enum_cont
:
error
enum_cont
"
"
"
    
p
[
0
]
=
p
[
2
]
    
if
self
.
parse_debug
:
DumpReduction
(
'
enum_error
'
p
)
  
def
p_label_block
(
self
p
)
:
    
"
"
"
label_block
:
modifiers
LABEL
SYMBOL
'
{
'
label_list
'
}
'
'
;
'
"
"
"
    
p
[
0
]
=
self
.
BuildNamed
(
'
Label
'
p
3
ListFromConcat
(
p
[
1
]
p
[
5
]
)
)
    
if
self
.
parse_debug
:
DumpReduction
(
'
label_block
'
p
)
  
def
p_label_list
(
self
p
)
:
    
"
"
"
label_list
:
modifiers
SYMBOL
'
=
'
FLOAT
label_cont
"
"
"
    
val
=
self
.
BuildAttribute
(
'
VALUE
'
p
[
4
]
)
    
label
=
self
.
BuildNamed
(
'
LabelItem
'
p
2
ListFromConcat
(
val
p
[
1
]
)
)
    
p
[
0
]
=
ListFromConcat
(
label
p
[
5
]
)
    
if
self
.
parse_debug
:
DumpReduction
(
'
label_list
'
p
)
  
def
p_label_cont
(
self
p
)
:
    
"
"
"
label_cont
:
'
'
label_list
                 
|
"
"
"
    
if
len
(
p
)
>
1
:
p
[
0
]
=
p
[
2
]
    
if
self
.
parse_debug
:
DumpReduction
(
'
label_cont
'
p
)
  
def
p_label_cont_error
(
self
p
)
:
    
"
"
"
label_cont
:
error
label_cont
"
"
"
    
p
[
0
]
=
p
[
2
]
    
if
self
.
parse_debug
:
DumpReduction
(
'
label_error
'
p
)
  
def
p_member_attribute
(
self
p
)
:
    
"
"
"
member_attribute
:
modifiers
typeref
arrays
questionmark
identifier
"
"
"
    
typeref
=
self
.
BuildAttribute
(
'
TYPEREF
'
p
[
2
]
)
    
children
=
ListFromConcat
(
p
[
1
]
typeref
p
[
3
]
p
[
4
]
)
    
p
[
0
]
=
self
.
BuildNamed
(
'
Member
'
p
5
children
)
    
if
self
.
parse_debug
:
DumpReduction
(
'
attribute
'
p
)
  
def
p_member_attribute_union
(
self
p
)
:
    
"
"
"
member_attribute
:
modifiers
'
(
'
union_list
'
)
'
questionmark
identifier
"
"
"
    
union
=
self
.
BuildAttribute
(
'
Union
'
True
)
    
children
=
ListFromConcat
(
p
[
1
]
p
[
3
]
p
[
5
]
union
)
    
p
[
0
]
=
self
.
BuildNamed
(
'
Member
'
p
6
children
)
    
if
self
.
parse_debug
:
DumpReduction
(
'
attribute
'
p
)
  
def
p_member_function
(
self
p
)
:
    
"
"
"
member_function
:
modifiers
static
typeref
arrays
SYMBOL
param_list
"
"
"
    
typeref
=
self
.
BuildAttribute
(
'
TYPEREF
'
p
[
3
]
)
    
children
=
ListFromConcat
(
p
[
1
]
p
[
2
]
typeref
p
[
4
]
p
[
6
]
)
    
p
[
0
]
=
self
.
BuildNamed
(
'
Member
'
p
5
children
)
    
if
self
.
parse_debug
:
DumpReduction
(
'
function
'
p
)
  
def
p_static
(
self
p
)
:
    
"
"
"
static
:
STATIC
              
|
"
"
"
    
if
len
(
p
)
=
=
2
:
      
p
[
0
]
=
self
.
BuildAttribute
(
'
STATIC
'
True
)
  
def
p_questionmark
(
self
p
)
:
    
"
"
"
questionmark
:
'
?
'
                    
|
"
"
"
    
if
len
(
p
)
=
=
2
:
      
p
[
0
]
=
self
.
BuildAttribute
(
'
OPTIONAL
'
True
)
  
def
p_interface_block
(
self
p
)
:
    
"
"
"
interface_block
:
modifiers
INTERFACE
SYMBOL
'
{
'
interface_list
'
}
'
'
;
'
"
"
"
    
p
[
0
]
=
self
.
BuildNamed
(
'
Interface
'
p
3
ListFromConcat
(
p
[
1
]
p
[
5
]
)
)
    
if
self
.
parse_debug
:
DumpReduction
(
'
interface_block
'
p
)
  
def
p_interface_error
(
self
p
)
:
    
"
"
"
interface_block
:
modifiers
INTERFACE
error
'
{
'
interface_list
'
}
'
'
;
'
"
"
"
    
p
[
0
]
=
[
]
  
def
p_interface_list
(
self
p
)
:
    
"
"
"
interface_list
:
member_function
'
;
'
interface_list
                      
|
"
"
"
    
if
len
(
p
)
>
1
:
      
p
[
0
]
=
ListFromConcat
(
p
[
1
]
p
[
3
]
)
      
if
self
.
parse_debug
:
DumpReduction
(
'
interface_list
'
p
)
  
def
p_struct_block
(
self
p
)
:
    
"
"
"
struct_block
:
modifiers
STRUCT
SYMBOL
'
{
'
struct_list
'
}
'
'
;
'
"
"
"
    
children
=
ListFromConcat
(
p
[
1
]
p
[
5
]
)
    
p
[
0
]
=
self
.
BuildNamed
(
'
Struct
'
p
3
children
)
    
if
self
.
parse_debug
:
DumpReduction
(
'
struct_block
'
p
)
  
def
p_struct_error
(
self
p
)
:
    
"
"
"
enum_block
:
modifiers
STRUCT
error
'
{
'
struct_list
'
}
'
'
;
'
"
"
"
    
p
[
0
]
=
[
]
  
def
p_struct_list
(
self
p
)
:
    
"
"
"
struct_list
:
member_attribute
'
;
'
struct_list
                   
|
member_function
'
;
'
struct_list
                   
|
"
"
"
    
if
len
(
p
)
>
1
:
p
[
0
]
=
ListFromConcat
(
p
[
1
]
p
[
3
]
)
  
def
p_error
(
self
t
)
:
    
filename
=
self
.
lexobj
.
filename
    
self
.
parse_errors
+
=
1
    
if
t
:
      
lineno
=
t
.
lineno
      
pos
=
t
.
lexpos
      
prev
=
self
.
yaccobj
.
symstack
[
-
1
]
      
if
type
(
prev
)
=
=
lex
.
LexToken
:
        
msg
=
"
Unexpected
%
s
after
%
s
.
"
%
(
            
TokenTypeName
(
t
)
TokenTypeName
(
prev
)
)
      
else
:
        
msg
=
"
Unexpected
%
s
.
"
%
(
t
.
value
)
    
else
:
      
lineno
=
self
.
last
.
lineno
      
pos
=
self
.
last
.
lexpos
      
msg
=
"
Unexpected
end
of
file
after
%
s
.
"
%
TokenTypeName
(
self
.
last
)
      
self
.
yaccobj
.
restart
(
)
    
if
msg
in
ERROR_REMAP
:
      
msg
=
ERROR_REMAP
[
msg
]
    
ErrOut
.
LogLine
(
filename
lineno
pos
msg
)
  
def
Warn
(
self
node
msg
)
:
    
WarnOut
.
LogLine
(
node
.
filename
node
.
lineno
node
.
pos
msg
)
    
self
.
parse_warnings
+
=
1
  
def
__init__
(
self
)
:
    
IDLLexer
.
__init__
(
self
)
    
self
.
yaccobj
=
yacc
.
yacc
(
module
=
self
tabmodule
=
None
debug
=
False
                             
optimize
=
0
write_tables
=
0
)
    
self
.
build_debug
=
GetOption
(
'
build_debug
'
)
    
self
.
parse_debug
=
GetOption
(
'
parse_debug
'
)
    
self
.
token_debug
=
GetOption
(
'
token_debug
'
)
    
self
.
verbose
=
GetOption
(
'
verbose
'
)
    
self
.
parse_errors
=
0
  
def
token
(
self
)
:
    
tok
=
self
.
lexobj
.
token
(
)
    
if
tok
:
      
self
.
last
=
tok
      
if
self
.
token_debug
:
        
InfoOut
.
Log
(
"
TOKEN
%
s
(
%
s
)
"
%
(
tok
.
type
tok
.
value
)
)
    
return
tok
  
def
BuildProduction
(
self
cls
p
index
childlist
=
None
)
:
    
if
not
childlist
:
childlist
=
[
]
    
filename
=
self
.
lexobj
.
filename
    
lineno
=
p
.
lineno
(
index
)
    
pos
=
p
.
lexpos
(
index
)
    
out
=
IDLNode
(
cls
filename
lineno
pos
childlist
)
    
if
self
.
build_debug
:
      
InfoOut
.
Log
(
"
Building
%
s
"
%
out
)
    
return
out
  
def
BuildNamed
(
self
cls
p
index
childlist
=
None
)
:
    
if
not
childlist
:
childlist
=
[
]
    
childlist
.
append
(
self
.
BuildAttribute
(
'
NAME
'
p
[
index
]
)
)
    
return
self
.
BuildProduction
(
cls
p
index
childlist
)
  
def
BuildComment
(
self
cls
p
index
)
:
    
name
=
p
[
index
]
    
lines
=
[
]
    
if
name
[
:
2
]
=
=
'
/
/
'
:
      
form
=
'
cc
'
      
for
line
in
name
.
split
(
'
\
n
'
)
:
        
start
=
line
.
find
(
'
/
/
'
)
        
lines
.
append
(
line
[
start
+
2
:
]
)
    
else
:
      
form
=
'
c
'
      
for
line
in
name
[
:
-
2
]
.
split
(
'
\
n
'
)
:
        
offs
=
line
.
find
(
'
*
'
)
        
if
offs
>
=
0
:
          
line
=
line
[
offs
+
1
:
]
.
rstrip
(
)
        
else
:
          
line
=
'
'
        
lines
.
append
(
line
)
    
name
=
'
\
n
'
.
join
(
lines
)
    
childlist
=
[
self
.
BuildAttribute
(
'
NAME
'
name
)
                 
self
.
BuildAttribute
(
'
FORM
'
form
)
]
    
return
self
.
BuildProduction
(
cls
p
index
childlist
)
  
def
BuildAttribute
(
self
key
val
)
:
    
return
IDLAttribute
(
key
val
)
  
def
ParseData
(
self
data
filename
=
'
<
Internal
>
'
)
:
    
self
.
SetData
(
filename
data
)
    
try
:
      
self
.
parse_errors
=
0
      
self
.
parse_warnings
=
0
      
return
self
.
yaccobj
.
parse
(
lexer
=
self
)
    
except
lex
.
LexError
as
le
:
      
ErrOut
.
Log
(
str
(
le
)
)
      
return
[
]
  
def
ParseFile
(
self
filename
)
:
    
date
=
time
.
ctime
(
os
.
path
.
getmtime
(
filename
)
)
    
data
=
open
(
filename
)
.
read
(
)
    
if
self
.
verbose
:
      
InfoOut
.
Log
(
"
Parsing
%
s
"
%
filename
)
    
try
:
      
out
=
self
.
ParseData
(
data
filename
)
      
srcroot
=
GetOption
(
'
srcroot
'
)
      
if
srcroot
and
filename
.
find
(
srcroot
)
=
=
0
:
        
filename
=
filename
[
len
(
srcroot
)
+
1
:
]
      
filenode
=
IDLFile
(
filename
out
self
.
parse_errors
+
self
.
lex_errors
)
      
filenode
.
SetProperty
(
'
DATETIME
'
date
)
      
return
filenode
    
except
Exception
as
e
:
      
ErrOut
.
LogLine
(
filename
self
.
last
.
lineno
self
.
last
.
lexpos
                     
'
Internal
parsing
error
-
%
s
.
'
%
str
(
e
)
)
      
raise
def
FlattenTree
(
node
)
:
  
add_self
=
False
  
out
=
[
]
  
for
child
in
node
.
GetChildren
(
)
:
    
if
child
.
IsA
(
'
Comment
'
)
:
      
add_self
=
True
    
else
:
      
out
.
extend
(
FlattenTree
(
child
)
)
  
if
add_self
:
    
out
=
[
str
(
node
)
]
+
out
  
return
out
def
TestErrors
(
filename
filenode
)
:
  
nodelist
=
filenode
.
GetChildren
(
)
  
lexer
=
IDLLexer
(
)
  
data
=
open
(
filename
)
.
read
(
)
  
lexer
.
SetData
(
filename
data
)
  
pass_comments
=
[
]
  
fail_comments
=
[
]
  
while
True
:
    
tok
=
lexer
.
lexobj
.
token
(
)
    
if
tok
=
=
None
:
break
    
if
tok
.
type
=
=
'
COMMENT
'
:
      
args
=
tok
.
value
[
3
:
-
3
]
.
split
(
)
      
if
args
[
0
]
=
=
'
OK
'
:
        
pass_comments
.
append
(
(
tok
.
lineno
'
'
.
join
(
args
[
1
:
]
)
)
)
      
else
:
        
if
args
[
0
]
=
=
'
FAIL
'
:
          
fail_comments
.
append
(
(
tok
.
lineno
'
'
.
join
(
args
[
1
:
]
)
)
)
  
obj_list
=
[
]
  
for
node
in
nodelist
:
    
obj_list
.
extend
(
FlattenTree
(
node
)
)
  
errors
=
0
  
obj_cnt
=
len
(
obj_list
)
  
pass_cnt
=
len
(
pass_comments
)
  
if
obj_cnt
!
=
pass_cnt
:
    
InfoOut
.
Log
(
"
Mismatched
pass
(
%
d
)
vs
.
nodes
built
(
%
d
)
.
"
        
%
(
pass_cnt
obj_cnt
)
)
    
InfoOut
.
Log
(
"
PASS
:
%
s
"
%
[
x
[
1
]
for
x
in
pass_comments
]
)
    
InfoOut
.
Log
(
"
OBJS
:
%
s
"
%
obj_list
)
    
errors
+
=
1
    
if
pass_cnt
>
obj_cnt
:
pass_cnt
=
obj_cnt
  
for
i
in
range
(
pass_cnt
)
:
    
line
comment
=
pass_comments
[
i
]
    
if
obj_list
[
i
]
!
=
comment
:
      
ErrOut
.
LogLine
(
filename
line
None
"
OBJ
%
s
:
EXPECTED
%
s
\
n
"
%
                     
(
obj_list
[
i
]
comment
)
)
      
errors
+
=
1
  
err_list
=
ErrOut
.
DrainLog
(
)
  
err_cnt
=
len
(
err_list
)
  
fail_cnt
=
len
(
fail_comments
)
  
if
err_cnt
!
=
fail_cnt
:
    
InfoOut
.
Log
(
"
Mismatched
fail
(
%
d
)
vs
.
errors
seen
(
%
d
)
.
"
        
%
(
fail_cnt
err_cnt
)
)
    
InfoOut
.
Log
(
"
FAIL
:
%
s
"
%
[
x
[
1
]
for
x
in
fail_comments
]
)
    
InfoOut
.
Log
(
"
ERRS
:
%
s
"
%
err_list
)
    
errors
+
=
1
    
if
fail_cnt
>
err_cnt
:
fail_cnt
=
err_cnt
  
for
i
in
range
(
fail_cnt
)
:
    
line
comment
=
fail_comments
[
i
]
    
err
=
err_list
[
i
]
.
strip
(
)
    
if
err_list
[
i
]
!
=
comment
:
      
ErrOut
.
Log
(
"
%
s
(
%
d
)
Error
\
n
\
tERROR
:
%
s
\
n
\
tEXPECT
:
%
s
"
%
(
        
filename
line
err_list
[
i
]
comment
)
)
      
errors
+
=
1
  
err_list
=
[
]
  
return
errors
def
TestFile
(
parser
filename
)
:
  
ErrOut
.
SetConsole
(
False
)
  
ErrOut
.
SetCapture
(
True
)
  
filenode
=
parser
.
ParseFile
(
filename
)
  
ErrOut
.
SetConsole
(
True
)
  
ErrOut
.
SetCapture
(
False
)
  
return
TestErrors
(
filename
filenode
)
def
TestErrorFiles
(
filter
)
:
  
idldir
=
os
.
path
.
split
(
sys
.
argv
[
0
]
)
[
0
]
  
idldir
=
os
.
path
.
join
(
idldir
'
test_parser
'
'
*
.
idl
'
)
  
filenames
=
glob
.
glob
(
idldir
)
  
parser
=
IDLParser
(
)
  
total_errs
=
0
  
for
filename
in
filenames
:
    
if
filter
and
filename
not
in
filter
:
continue
    
errs
=
TestFile
(
parser
filename
)
    
if
errs
:
      
ErrOut
.
Log
(
"
%
s
test
failed
with
%
d
error
(
s
)
.
"
%
(
filename
errs
)
)
      
total_errs
+
=
errs
  
if
total_errs
:
    
ErrOut
.
Log
(
"
Failed
parsing
test
.
"
)
  
else
:
    
InfoOut
.
Log
(
"
Passed
parsing
test
.
"
)
  
return
total_errs
def
TestNamespaceFiles
(
filter
)
:
  
idldir
=
os
.
path
.
split
(
sys
.
argv
[
0
]
)
[
0
]
  
idldir
=
os
.
path
.
join
(
idldir
'
test_namespace
'
'
*
.
idl
'
)
  
filenames
=
glob
.
glob
(
idldir
)
  
testnames
=
[
]
  
for
filename
in
filenames
:
    
if
filter
and
filename
not
in
filter
:
continue
    
testnames
.
append
(
filename
)
  
if
not
testnames
:
    
InfoOut
.
Log
(
'
No
files
to
test
for
namespace
.
'
)
    
return
0
  
InfoOut
.
SetConsole
(
False
)
  
ast
=
ParseFiles
(
testnames
)
  
InfoOut
.
SetConsole
(
True
)
  
errs
=
ast
.
GetProperty
(
'
ERRORS
'
)
  
if
errs
:
    
ErrOut
.
Log
(
"
Failed
namespace
test
.
"
)
  
else
:
    
InfoOut
.
Log
(
"
Passed
namespace
test
.
"
)
  
return
errs
def
FindVersionError
(
releases
node
)
:
  
err_cnt
=
0
  
if
node
.
IsA
(
'
Interface
'
'
Struct
'
)
:
    
comment_list
=
[
]
    
comment
=
node
.
GetOneOf
(
'
Comment
'
)
    
if
comment
and
comment
.
GetName
(
)
[
:
4
]
=
=
'
REL
:
'
:
      
comment_list
=
comment
.
GetName
(
)
[
5
:
]
.
strip
(
)
.
split
(
'
'
)
    
first_list
=
[
node
.
first_release
[
rel
]
for
rel
in
releases
]
    
first_list
=
sorted
(
set
(
first_list
)
)
    
if
first_list
!
=
comment_list
:
      
node
.
Error
(
"
Mismatch
in
releases
:
%
s
vs
%
s
.
"
%
(
          
comment_list
first_list
)
)
      
err_cnt
+
=
1
  
for
child
in
node
.
GetChildren
(
)
:
    
err_cnt
+
=
FindVersionError
(
releases
child
)
  
return
err_cnt
def
TestVersionFiles
(
filter
)
:
  
idldir
=
os
.
path
.
split
(
sys
.
argv
[
0
]
)
[
0
]
  
idldir
=
os
.
path
.
join
(
idldir
'
test_version
'
'
*
.
idl
'
)
  
filenames
=
glob
.
glob
(
idldir
)
  
testnames
=
[
]
  
for
filename
in
filenames
:
    
if
filter
and
filename
not
in
filter
:
continue
    
testnames
.
append
(
filename
)
  
if
not
testnames
:
    
InfoOut
.
Log
(
'
No
files
to
test
for
version
.
'
)
    
return
0
  
ast
=
ParseFiles
(
testnames
)
  
errs
=
FindVersionError
(
ast
.
releases
ast
)
  
errs
+
=
ast
.
errors
  
if
errs
:
    
ErrOut
.
Log
(
"
Failed
version
test
.
"
)
  
else
:
    
InfoOut
.
Log
(
"
Passed
version
test
.
"
)
  
return
errs
default_dirs
=
[
'
.
'
'
trusted
'
'
dev
'
'
private
'
]
def
ParseFiles
(
filenames
)
:
  
parser
=
IDLParser
(
)
  
filenodes
=
[
]
  
if
not
filenames
:
    
filenames
=
[
]
    
srcroot
=
GetOption
(
'
srcroot
'
)
    
dirs
=
default_dirs
    
if
GetOption
(
'
include_private
'
)
:
      
dirs
+
=
[
'
private
'
]
    
for
dirname
in
dirs
:
      
srcdir
=
os
.
path
.
join
(
srcroot
dirname
'
*
.
idl
'
)
      
srcdir
=
os
.
path
.
normpath
(
srcdir
)
      
filenames
+
=
sorted
(
glob
.
glob
(
srcdir
)
)
  
if
not
filenames
:
    
ErrOut
.
Log
(
'
No
sources
provided
.
'
)
  
for
filename
in
filenames
:
    
filenode
=
parser
.
ParseFile
(
filename
)
    
filenodes
.
append
(
filenode
)
  
ast
=
IDLAst
(
filenodes
)
  
if
GetOption
(
'
dump_tree
'
)
:
ast
.
Dump
(
0
)
  
Lint
(
ast
)
  
return
ast
def
Main
(
args
)
:
  
filenames
=
ParseOptions
(
args
)
  
if
GetOption
(
'
test
'
)
:
    
errs
=
TestErrorFiles
(
filenames
)
    
errs
=
TestNamespaceFiles
(
filenames
)
    
errs
=
TestVersionFiles
(
filenames
)
    
if
errs
:
      
ErrOut
.
Log
(
"
Parser
failed
with
%
d
errors
.
"
%
errs
)
      
return
-
1
    
return
0
  
ast
=
ParseFiles
(
filenames
)
  
errs
=
ast
.
GetProperty
(
'
ERRORS
'
)
  
if
errs
:
    
ErrOut
.
Log
(
'
Found
%
d
error
(
s
)
.
'
%
errs
)
;
  
InfoOut
.
Log
(
"
%
d
files
processed
.
"
%
len
(
filenames
)
)
  
return
errs
if
__name__
=
=
'
__main__
'
:
  
sys
.
exit
(
Main
(
sys
.
argv
[
1
:
]
)
)
