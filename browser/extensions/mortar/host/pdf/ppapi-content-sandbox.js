ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
NetUtil
"
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PrivateBrowsingUtils
"
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
let
mm
=
pluginElement
.
frameLoader
.
messageManager
;
let
containerWindow
=
pluginElement
.
ownerGlobal
;
let
printSettings
=
{
}
;
pluginElement
.
addEventListener
(
"
dragstart
"
function
(
event
)
{
event
.
preventDefault
(
)
;
}
)
;
let
isSynthetic
=
pluginElement
.
ownerDocument
.
mozSyntheticDocument
;
if
(
isSynthetic
)
{
pluginElement
.
ownerDocument
.
body
.
addEventListener
(
"
selectstart
"
function
(
event
)
{
event
.
preventDefault
(
)
;
}
)
;
}
function
mapValue
(
v
instance
)
{
return
instance
.
rt
.
toPP_Var
(
v
instance
)
;
}
function
getFileName
(
url
)
{
let
filename
=
"
document
.
pdf
"
;
let
regex
=
/
[
^
\
/
#
\
?
]
+
\
.
pdf
/
i
;
let
result
=
regex
.
exec
(
url
.
hash
)
|
|
regex
.
exec
(
url
.
search
)
|
|
regex
.
exec
(
url
.
pathname
)
;
if
(
result
)
{
filename
=
result
[
0
]
;
}
return
filename
;
}
dump
(
"
<
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
AHA
<
<
<
<
<
<
<
<
<
<
<
<
<
<
<
<
<
<
<
<
<
>
\
n
"
)
;
dump
(
pluginElement
:
{
pluginElement
.
toSource
(
)
}
\
n
)
;
dump
(
pluginElement
.
frameLoader
:
{
pluginElement
.
frameLoader
.
toSource
(
)
}
\
n
)
;
dump
(
pluginElement
.
frameLoader
.
messageManager
:
{
pluginElement
.
frameLoader
.
messageManager
.
toSource
(
)
}
\
n
)
;
dump
(
"
<
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
AHA2
<
<
<
<
<
<
<
<
<
<
<
<
<
<
<
<
<
<
<
<
<
>
\
n
"
)
;
mm
.
addMessageListener
(
"
ppapi
.
js
:
frameLoaded
"
(
{
target
}
)
=
>
{
let
tagName
=
pluginElement
.
nodeName
;
let
url
=
pluginElement
.
srcURI
.
spec
;
let
objectParams
=
new
Map
(
)
;
for
(
let
i
=
0
;
i
<
pluginElement
.
attributes
.
length
;
+
+
i
)
{
let
paramName
=
pluginElement
.
attributes
[
i
]
.
localName
;
objectParams
.
set
(
paramName
pluginElement
.
attributes
[
i
]
.
value
)
;
}
if
(
tagName
=
=
"
OBJECT
"
)
{
let
params
=
pluginElement
.
getElementsByTagName
(
"
param
"
)
;
Array
.
prototype
.
forEach
.
call
(
params
(
p
)
=
>
{
var
paramName
=
p
.
getAttribute
(
"
name
"
)
.
toLowerCase
(
)
;
objectParams
.
set
(
paramName
p
.
getAttribute
(
"
value
"
)
)
;
}
)
;
}
let
documentURL
=
pluginElement
.
ownerDocument
.
location
.
href
;
let
baseUrl
=
documentURL
;
if
(
objectParams
.
base
)
{
try
{
let
parsedDocumentUrl
=
Services
.
io
.
newURI
(
documentURL
)
;
baseUrl
=
Services
.
io
.
newURI
(
objectParams
.
base
null
parsedDocumentUrl
)
.
spec
;
}
catch
(
e
)
{
}
}
let
info
=
{
documentURL
:
"
chrome
-
extension
:
/
/
mhjfbmdgcfjbbpaeojofohoefgiehjai
"
url
setupJSInstanceObject
:
false
isFullFrame
:
false
arguments
:
{
keys
:
[
"
src
"
"
full
-
frame
"
"
top
-
level
-
url
"
]
values
:
[
url
"
"
documentURL
]
}
}
;
mm
.
sendAsyncMessage
(
"
ppapi
.
js
:
createInstance
"
{
type
:
"
pdf
"
info
}
{
pluginWindow
:
containerWindow
}
)
;
containerWindow
.
document
.
addEventListener
(
"
fullscreenchange
"
(
)
=
>
{
let
fullscreen
=
(
containerWindow
.
document
.
fullscreenElement
=
=
pluginElement
)
;
mm
.
sendAsyncMessage
(
"
ppapi
.
js
:
fullscreenchange
"
{
fullscreen
}
)
;
}
)
;
containerWindow
.
addEventListener
(
"
hashchange
"
(
)
=
>
{
let
url
=
containerWindow
.
location
.
href
;
mm
.
sendAsyncMessage
(
"
ppapipdf
.
js
:
hashchange
"
{
url
}
)
;
}
)
}
)
;
mm
.
addMessageListener
(
"
ppapi
.
js
:
setFullscreen
"
(
{
data
}
)
=
>
{
if
(
data
)
{
pluginElement
.
requestFullscreen
(
)
;
}
else
{
containerWindow
.
document
.
exitFullscreen
(
)
;
}
}
)
;
mm
.
addMessageListener
(
"
ppapipdf
.
js
:
setHash
"
(
{
data
}
)
=
>
{
if
(
data
)
{
containerWindow
.
location
.
hash
=
data
;
}
}
)
;
mm
.
addMessageListener
(
"
ppapipdf
.
js
:
getPrintSettings
"
(
{
data
}
)
=
>
{
let
url
=
new
containerWindow
.
URL
(
data
.
url
)
;
containerWindow
.
document
.
title
=
getFileName
(
url
)
;
let
PSSVC
=
Cc
[
"
mozilla
.
org
/
gfx
/
printsettings
-
service
;
1
"
]
.
getService
(
Ci
.
nsIPrintSettingsService
)
;
printSettings
=
PSSVC
.
globalPrintSettings
;
let
webBrowserPrint
=
containerWindow
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebBrowserPrint
)
;
let
PPSVC
=
Cc
[
"
mozilla
.
org
/
embedcomp
/
printingprompt
-
service
;
1
"
]
.
getService
(
Ci
.
nsIPrintingPromptService
)
;
PPSVC
.
showPrintDialog
(
containerWindow
webBrowserPrint
printSettings
)
;
let
trimPrintSettings
=
{
}
;
trimPrintSettings
.
marginTop
=
printSettings
.
marginTop
;
trimPrintSettings
.
marginLeft
=
printSettings
.
marginLeft
;
trimPrintSettings
.
marginBottom
=
printSettings
.
marginBottom
;
trimPrintSettings
.
marginRight
=
printSettings
.
marginRight
;
trimPrintSettings
.
unwriteableMarginLeft
=
printSettings
.
unwriteableMarginLeft
;
trimPrintSettings
.
unwriteableMarginTop
=
printSettings
.
unwriteableMarginTop
;
trimPrintSettings
.
unwriteableMarginRight
=
printSettings
.
unwriteableMarginRight
;
trimPrintSettings
.
unwriteableMarginBottom
=
printSettings
.
unwriteableMarginBottom
;
trimPrintSettings
.
paperWidth
=
printSettings
.
paperWidth
;
trimPrintSettings
.
paperHeight
=
printSettings
.
paperHeight
;
trimPrintSettings
.
paperSizeUnit
=
printSettings
.
paperSizeUnit
;
trimPrintSettings
.
orientation
=
printSettings
.
orientation
;
trimPrintSettings
.
shrinkToFit
=
printSettings
.
shrinkToFit
;
trimPrintSettings
.
printInColor
=
printSettings
.
printInColor
;
trimPrintSettings
.
printRange
=
printSettings
.
printRange
;
trimPrintSettings
.
startPageRange
=
printSettings
.
startPageRange
;
trimPrintSettings
.
endPageRange
=
printSettings
.
endPageRange
;
mm
.
sendAsyncMessage
(
"
ppapipdf
.
js
:
printsettingschanged
"
{
trimPrintSettings
}
)
;
}
)
;
mm
.
addMessageListener
(
"
ppapipdf
.
js
:
printPDF
"
(
{
data
}
)
=
>
{
let
file
=
new
FileUtils
.
File
(
data
.
filePath
)
;
if
(
!
file
.
exists
(
)
)
{
return
;
}
let
webBrowserPrint
=
containerWindow
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebBrowserPrint
)
;
if
(
!
webBrowserPrint
|
|
!
webBrowserPrint
.
printPDF
)
{
file
.
remove
(
false
)
;
return
;
}
webBrowserPrint
.
printPDF
(
file
.
path
printSettings
)
.
then
(
(
)
=
>
{
file
.
remove
(
false
)
;
}
)
.
catch
(
(
)
=
>
{
file
.
remove
(
false
)
;
}
)
;
}
)
;
mm
.
addMessageListener
(
"
ppapipdf
.
js
:
openLink
"
(
{
data
}
)
=
>
{
const
PDFIUM_WINDOW_OPEN_DISPOSITION
=
{
CURRENT_TAB
:
1
NEW_FOREGROUND_TAB
:
3
NEW_BACKGROUND_TAB
:
4
NEW_WINDOW
:
6
}
;
switch
(
data
.
disposition
)
{
case
PDFIUM_WINDOW_OPEN_DISPOSITION
.
CURRENT_TAB
:
containerWindow
.
location
.
href
=
data
.
url
;
break
;
case
PDFIUM_WINDOW_OPEN_DISPOSITION
.
NEW_FOREGROUND_TAB
:
case
PDFIUM_WINDOW_OPEN_DISPOSITION
.
NEW_BACKGROUND_TAB
:
containerWindow
.
open
(
data
.
url
)
;
break
;
case
PDFIUM_WINDOW_OPEN_DISPOSITION
.
NEW_WINDOW
:
containerWindow
.
open
(
data
.
url
"
"
"
noopener
=
1
menubar
=
1
toolbar
=
1
"
+
"
location
=
1
personalbar
=
1
status
=
1
resizable
"
)
;
break
;
}
}
)
;
mm
.
addMessageListener
(
"
ppapipdf
.
js
:
save
"
(
{
data
}
)
=
>
{
let
url
=
new
containerWindow
.
URL
(
data
.
url
)
;
let
filename
=
getFileName
(
url
)
;
let
originalUri
=
NetUtil
.
newURI
(
url
.
href
)
;
let
extHelperAppSvc
=
Cc
[
"
mozilla
.
org
/
uriloader
/
external
-
helper
-
app
-
service
;
1
"
]
.
getService
(
Ci
.
nsIExternalHelperAppService
)
;
let
docIsPrivate
=
PrivateBrowsingUtils
.
isContentWindowPrivate
(
containerWindow
)
;
let
netChannel
=
NetUtil
.
newChannel
(
{
uri
:
originalUri
loadUsingSystemPrincipal
:
true
}
)
;
if
(
"
nsIPrivateBrowsingChannel
"
in
Ci
&
&
netChannel
instanceof
Ci
.
nsIPrivateBrowsingChannel
)
{
netChannel
.
setPrivate
(
docIsPrivate
)
;
}
NetUtil
.
asyncFetch
(
netChannel
function
(
aInputStream
aResult
)
{
if
(
!
Components
.
isSuccessCode
(
aResult
)
)
{
return
;
}
let
channel
=
Cc
[
"
mozilla
.
org
/
network
/
input
-
stream
-
channel
;
1
"
]
.
createInstance
(
Ci
.
nsIInputStreamChannel
)
;
channel
.
QueryInterface
(
Ci
.
nsIChannel
)
;
channel
.
contentDisposition
=
Ci
.
nsIChannel
.
DISPOSITION_ATTACHMENT
;
channel
.
contentDispositionFilename
=
filename
;
channel
.
setURI
(
originalUri
)
;
channel
.
loadInfo
=
netChannel
.
loadInfo
;
channel
.
contentStream
=
aInputStream
;
if
(
"
nsIPrivateBrowsingChannel
"
in
Ci
&
&
channel
instanceof
Ci
.
nsIPrivateBrowsingChannel
)
{
channel
.
setPrivate
(
docIsPrivate
)
;
}
let
listener
=
{
extListener
:
null
onStartRequest
(
aRequest
aContext
)
{
var
loadContext
=
containerWindow
.
docShell
.
QueryInterface
(
Ci
.
nsILoadContext
)
;
this
.
extListener
=
extHelperAppSvc
.
doContent
(
"
application
/
pdf
"
aRequest
loadContext
false
)
;
this
.
extListener
.
onStartRequest
(
aRequest
aContext
)
;
}
onStopRequest
(
aRequest
aContext
aStatusCode
)
{
if
(
this
.
extListener
)
{
this
.
extListener
.
onStopRequest
(
aRequest
aContext
aStatusCode
)
;
}
}
onDataAvailable
(
aRequest
aContext
aInputStream
aOffset
aCount
)
{
this
.
extListener
.
onDataAvailable
(
aRequest
aContext
aInputStream
aOffset
aCount
)
;
}
}
;
channel
.
asyncOpen2
(
listener
)
;
}
)
;
}
)
;
class
CommandController
{
constructor
(
)
{
this
.
SUPPORTED_COMMANDS
=
[
'
cmd_copy
'
'
cmd_selectAll
'
]
;
containerWindow
.
controllers
.
insertControllerAt
(
0
this
)
;
containerWindow
.
addEventListener
(
'
unload
'
this
.
terminate
.
bind
(
this
)
)
;
}
terminate
(
)
{
containerWindow
.
controllers
.
removeController
(
this
)
;
}
supportsCommand
(
cmd
)
{
return
this
.
SUPPORTED_COMMANDS
.
includes
(
cmd
)
;
}
isCommandEnabled
(
cmd
)
{
return
this
.
SUPPORTED_COMMANDS
.
includes
(
cmd
)
;
}
doCommand
(
cmd
)
{
mm
.
sendAsyncMessage
(
"
ppapipdf
.
js
:
oncommand
"
{
name
:
cmd
}
)
;
}
onEvent
(
evt
)
{
}
}
;
var
commandController
=
new
CommandController
(
)
;
mm
.
loadFrameScript
(
"
resource
:
/
/
ppapi
.
js
/
ppapi
-
instance
.
js
"
true
)
;
