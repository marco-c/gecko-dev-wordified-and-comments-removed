"
use
strict
"
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
UpdateUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryArchive
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryController
.
jsm
"
)
;
const
TEST_THRESHOLD
=
{
"
beta
"
:
0
.
5
"
release
"
:
1
.
0
}
;
const
ADDON_ROLLOUT_POLICY
=
{
"
beta
"
:
"
50allmpc
"
"
release
"
:
"
49a
"
}
;
const
PREF_COHORT_SAMPLE
=
"
e10s
.
rollout
.
cohortSample
"
;
const
PREF_COHORT_NAME
=
"
e10s
.
rollout
.
cohort
"
;
const
PREF_E10S_OPTED_IN
=
"
browser
.
tabs
.
remote
.
autostart
"
;
const
PREF_E10S_FORCE_ENABLED
=
"
browser
.
tabs
.
remote
.
force
-
enable
"
;
const
PREF_E10S_FORCE_DISABLED
=
"
browser
.
tabs
.
remote
.
force
-
disable
"
;
const
PREF_TOGGLE_E10S
=
"
browser
.
tabs
.
remote
.
autostart
.
2
"
;
const
PREF_E10S_ADDON_POLICY
=
"
extensions
.
e10s
.
rollout
.
policy
"
;
const
PREF_E10S_ADDON_BLOCKLIST
=
"
extensions
.
e10s
.
rollout
.
blocklist
"
;
const
PREF_E10S_HAS_NONEXEMPT_ADDON
=
"
extensions
.
e10s
.
rollout
.
hasAddon
"
;
const
PREF_DISABLED_FOR_SPINNERS
=
"
e10s
.
rollout
.
disabledByLongSpinners
"
;
const
LONG_SPINNER_HISTOGRAM
=
"
FX_TAB_SWITCH_SPINNER_VISIBLE_LONG_MS
"
;
function
startup
(
)
{
defineCohort
(
)
;
setUpSpinnerCheck
(
)
;
}
function
install
(
)
{
defineCohort
(
)
;
}
let
cohortDefinedOnThisSession
=
false
;
function
defineCohort
(
)
{
if
(
cohortDefinedOnThisSession
)
{
return
;
}
cohortDefinedOnThisSession
=
true
;
let
updateChannel
=
UpdateUtils
.
getUpdateChannel
(
false
)
;
if
(
!
(
updateChannel
in
TEST_THRESHOLD
)
)
{
setCohort
(
"
unsupportedChannel
"
)
;
return
;
}
let
addonPolicy
=
"
unknown
"
;
if
(
updateChannel
in
ADDON_ROLLOUT_POLICY
)
{
addonPolicy
=
ADDON_ROLLOUT_POLICY
[
updateChannel
]
;
Preferences
.
set
(
PREF_E10S_ADDON_POLICY
addonPolicy
)
;
Preferences
.
set
(
PREF_E10S_ADDON_BLOCKLIST
"
{
dc572301
-
7619
-
498c
-
a57d
-
39143191b318
}
"
)
;
}
else
{
Preferences
.
reset
(
PREF_E10S_ADDON_POLICY
)
;
}
let
userOptedOut
=
optedOut
(
)
;
let
userOptedIn
=
optedIn
(
)
;
let
disqualified
=
(
Services
.
appinfo
.
multiprocessBlockPolicy
!
=
0
)
;
let
testGroup
=
(
getUserSample
(
)
<
TEST_THRESHOLD
[
updateChannel
]
)
;
let
hasNonExemptAddon
=
Preferences
.
get
(
PREF_E10S_HAS_NONEXEMPT_ADDON
false
)
;
let
temporaryDisqualification
=
getTemporaryDisqualification
(
)
;
let
cohortPrefix
=
"
"
;
if
(
disqualified
)
{
cohortPrefix
=
"
disqualified
-
"
;
}
else
if
(
hasNonExemptAddon
)
{
cohortPrefix
=
addons
-
set
{
addonPolicy
}
-
;
}
if
(
userOptedOut
)
{
setCohort
(
"
optedOut
"
)
;
}
else
if
(
userOptedIn
)
{
setCohort
(
"
optedIn
"
)
;
}
else
if
(
temporaryDisqualification
!
=
"
"
)
{
setCohort
(
temp
-
disqualified
-
{
temporaryDisqualification
}
)
;
Preferences
.
reset
(
PREF_TOGGLE_E10S
)
;
}
else
if
(
testGroup
)
{
setCohort
(
{
cohortPrefix
}
test
)
;
Preferences
.
set
(
PREF_TOGGLE_E10S
true
)
;
}
else
{
setCohort
(
{
cohortPrefix
}
control
)
;
Preferences
.
reset
(
PREF_TOGGLE_E10S
)
;
}
}
function
shutdown
(
data
reason
)
{
}
function
uninstall
(
)
{
}
function
getUserSample
(
)
{
let
prefValue
=
Preferences
.
get
(
PREF_COHORT_SAMPLE
undefined
)
;
let
value
=
0
.
0
;
if
(
typeof
(
prefValue
)
=
=
"
string
"
)
{
value
=
parseFloat
(
prefValue
10
)
;
return
value
;
}
if
(
typeof
(
prefValue
)
=
=
"
number
"
)
{
value
=
prefValue
/
100
;
}
else
{
value
=
Math
.
random
(
)
;
}
Preferences
.
set
(
PREF_COHORT_SAMPLE
value
.
toString
(
)
.
substr
(
0
8
)
)
;
return
value
;
}
function
setCohort
(
cohortName
)
{
Preferences
.
set
(
PREF_COHORT_NAME
cohortName
)
;
try
{
if
(
Ci
.
nsICrashReporter
)
{
Services
.
appinfo
.
QueryInterface
(
Ci
.
nsICrashReporter
)
.
annotateCrashReport
(
"
E10SCohort
"
cohortName
)
;
}
}
catch
(
e
)
{
}
}
function
optedIn
(
)
{
return
Preferences
.
get
(
PREF_E10S_OPTED_IN
false
)
|
|
Preferences
.
get
(
PREF_E10S_FORCE_ENABLED
false
)
;
}
function
optedOut
(
)
{
return
Preferences
.
get
(
PREF_E10S_FORCE_DISABLED
false
)
|
|
(
Preferences
.
isSet
(
PREF_TOGGLE_E10S
)
&
&
Preferences
.
get
(
PREF_TOGGLE_E10S
)
=
=
false
)
;
}
function
getTemporaryDisqualification
(
)
{
if
(
Preferences
.
isSet
(
PREF_DISABLED_FOR_SPINNERS
)
)
{
return
"
longspinner
"
;
}
let
applicationLanguage
=
Cc
[
"
mozilla
.
org
/
chrome
/
chrome
-
registry
;
1
"
]
.
getService
(
Ci
.
nsIXULChromeRegistry
)
.
getSelectedLocale
(
"
global
"
)
.
split
(
"
-
"
)
[
0
]
;
if
(
applicationLanguage
=
=
"
ru
"
)
{
return
"
ru
"
;
}
return
"
"
;
}
let
performLongSpinnerCheck
=
Task
.
async
(
function
*
(
)
{
if
(
!
Services
.
appinfo
.
browserTabsRemoteAutostart
)
{
return
;
}
const
DAYS_OLD
=
3
;
let
thresholdDate
=
new
Date
(
Date
.
now
(
)
-
(
1000
*
60
*
60
*
24
*
DAYS_OLD
)
)
;
let
allPingsInfo
=
yield
TelemetryArchive
.
promiseArchivedPingList
(
)
;
let
recentPingsInfo
=
allPingsInfo
.
filter
(
ping
=
>
{
let
pingDate
=
new
Date
(
ping
.
timestampCreated
)
;
return
pingDate
>
thresholdDate
;
}
)
;
let
pingList
=
[
]
;
for
(
let
pingInfo
of
recentPingsInfo
)
{
pingList
.
push
(
yield
TelemetryArchive
.
promiseArchivedPingById
(
pingInfo
.
id
)
)
;
}
pingList
.
push
(
TelemetryController
.
getCurrentPingData
(
true
)
)
;
let
totalSessionTime
=
0
;
let
totalSpinnerTime
=
0
;
for
(
let
ping
of
pingList
)
{
try
{
if
(
ping
.
type
!
=
"
main
"
)
{
continue
;
}
if
(
!
ping
.
environment
.
settings
.
e10sEnabled
)
{
continue
;
}
totalSessionTime
=
ping
.
payload
.
info
.
subsessionLength
;
if
(
!
(
LONG_SPINNER_HISTOGRAM
in
ping
.
payload
.
histograms
)
)
{
continue
;
}
let
histogram
=
ping
.
payload
.
histograms
[
LONG_SPINNER_HISTOGRAM
]
;
for
(
let
spinnerTime
of
Object
.
keys
(
histogram
.
values
)
)
{
if
(
spinnerTime
>
=
2000
)
{
totalSpinnerTime
+
=
spinnerTime
*
histogram
.
values
[
spinnerTime
]
;
}
}
}
catch
(
e
)
{
}
}
totalSpinnerTime
/
=
1000
;
const
ACCEPTABLE_THRESHOLD
=
20
/
3600
;
if
(
(
totalSpinnerTime
/
totalSessionTime
)
>
ACCEPTABLE_THRESHOLD
)
{
Preferences
.
set
(
PREF_DISABLED_FOR_SPINNERS
true
)
;
}
else
{
Preferences
.
reset
(
PREF_DISABLED_FOR_SPINNERS
)
;
}
}
)
;
function
setUpSpinnerCheck
(
)
{
let
{
setTimeout
setInterval
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
setTimeout
(
performLongSpinnerCheck
1000
*
60
*
5
)
;
setInterval
(
performLongSpinnerCheck
1000
*
60
*
60
)
;
}
