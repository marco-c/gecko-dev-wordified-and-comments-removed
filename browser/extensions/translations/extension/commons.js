(
self
[
"
webpackChunkbergamot_browser_extension
"
]
=
self
[
"
webpackChunkbergamot_browser_extension
"
]
|
|
[
]
)
.
push
(
[
[
351
]
{
6614
:
(
(
__unused_webpack_module
__webpack_exports__
__webpack_require__
)
=
>
{
"
use
strict
"
;
__webpack_require__
.
r
(
__webpack_exports__
)
;
__webpack_require__
.
d
(
__webpack_exports__
{
"
BrowserClient
"
:
(
)
=
>
(
BrowserClient
)
"
Hub
"
:
(
)
=
>
(
Hub
)
"
Integrations
"
:
(
)
=
>
(
INTEGRATIONS
)
"
SDK_NAME
"
:
(
)
=
>
(
SDK_NAME
)
"
SDK_VERSION
"
:
(
)
=
>
(
SDK_VERSION
)
"
Scope
"
:
(
)
=
>
(
Scope
)
"
Severity
"
:
(
)
=
>
(
Severity
)
"
Status
"
:
(
)
=
>
(
Status
)
"
Transports
"
:
(
)
=
>
(
transports_namespaceObject
)
"
addBreadcrumb
"
:
(
)
=
>
(
addBreadcrumb
)
"
addGlobalEventProcessor
"
:
(
)
=
>
(
addGlobalEventProcessor
)
"
captureEvent
"
:
(
)
=
>
(
captureEvent
)
"
captureException
"
:
(
)
=
>
(
captureException
)
"
captureMessage
"
:
(
)
=
>
(
captureMessage
)
"
close
"
:
(
)
=
>
(
sdk_close
)
"
configureScope
"
:
(
)
=
>
(
configureScope
)
"
defaultIntegrations
"
:
(
)
=
>
(
defaultIntegrations
)
"
eventFromException
"
:
(
)
=
>
(
eventFromException
)
"
eventFromMessage
"
:
(
)
=
>
(
eventFromMessage
)
"
flush
"
:
(
)
=
>
(
flush
)
"
forceLoad
"
:
(
)
=
>
(
forceLoad
)
"
getCurrentHub
"
:
(
)
=
>
(
getCurrentHub
)
"
getHubFromCarrier
"
:
(
)
=
>
(
getHubFromCarrier
)
"
init
"
:
(
)
=
>
(
init
)
"
injectReportDialog
"
:
(
)
=
>
(
injectReportDialog
)
"
lastEventId
"
:
(
)
=
>
(
lastEventId
)
"
makeMain
"
:
(
)
=
>
(
makeMain
)
"
onLoad
"
:
(
)
=
>
(
onLoad
)
"
setContext
"
:
(
)
=
>
(
setContext
)
"
setExtra
"
:
(
)
=
>
(
setExtra
)
"
setExtras
"
:
(
)
=
>
(
setExtras
)
"
setTag
"
:
(
)
=
>
(
setTag
)
"
setTags
"
:
(
)
=
>
(
setTags
)
"
setUser
"
:
(
)
=
>
(
setUser
)
"
showReportDialog
"
:
(
)
=
>
(
showReportDialog
)
"
startTransaction
"
:
(
)
=
>
(
startTransaction
)
"
withScope
"
:
(
)
=
>
(
withScope
)
"
wrap
"
:
(
)
=
>
(
sdk_wrap
)
}
)
;
var
integrations_namespaceObject
=
{
}
;
__webpack_require__
.
r
(
integrations_namespaceObject
)
;
__webpack_require__
.
d
(
integrations_namespaceObject
{
"
FunctionToString
"
:
(
)
=
>
(
FunctionToString
)
"
InboundFilters
"
:
(
)
=
>
(
InboundFilters
)
}
)
;
var
esm_integrations_namespaceObject
=
{
}
;
__webpack_require__
.
r
(
esm_integrations_namespaceObject
)
;
__webpack_require__
.
d
(
esm_integrations_namespaceObject
{
"
Breadcrumbs
"
:
(
)
=
>
(
Breadcrumbs
)
"
GlobalHandlers
"
:
(
)
=
>
(
GlobalHandlers
)
"
LinkedErrors
"
:
(
)
=
>
(
LinkedErrors
)
"
TryCatch
"
:
(
)
=
>
(
TryCatch
)
"
UserAgent
"
:
(
)
=
>
(
UserAgent
)
}
)
;
var
transports_namespaceObject
=
{
}
;
__webpack_require__
.
r
(
transports_namespaceObject
)
;
__webpack_require__
.
d
(
transports_namespaceObject
{
"
BaseTransport
"
:
(
)
=
>
(
BaseTransport
)
"
FetchTransport
"
:
(
)
=
>
(
FetchTransport
)
"
XHRTransport
"
:
(
)
=
>
(
XHRTransport
)
}
)
;
;
var
extendStatics
=
function
(
d
b
)
{
extendStatics
=
Object
.
setPrototypeOf
|
|
(
{
__proto__
:
[
]
}
instanceof
Array
&
&
function
(
d
b
)
{
d
.
__proto__
=
b
;
}
)
|
|
function
(
d
b
)
{
for
(
var
p
in
b
)
if
(
b
.
hasOwnProperty
(
p
)
)
d
[
p
]
=
b
[
p
]
;
}
;
return
extendStatics
(
d
b
)
;
}
;
function
__extends
(
d
b
)
{
extendStatics
(
d
b
)
;
function
__
(
)
{
this
.
constructor
=
d
;
}
d
.
prototype
=
b
=
=
=
null
?
Object
.
create
(
b
)
:
(
__
.
prototype
=
b
.
prototype
new
__
(
)
)
;
}
var
__assign
=
function
(
)
{
__assign
=
Object
.
assign
|
|
function
__assign
(
t
)
{
for
(
var
s
i
=
1
n
=
arguments
.
length
;
i
<
n
;
i
+
+
)
{
s
=
arguments
[
i
]
;
for
(
var
p
in
s
)
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
s
p
)
)
t
[
p
]
=
s
[
p
]
;
}
return
t
;
}
return
__assign
.
apply
(
this
arguments
)
;
}
function
__rest
(
s
e
)
{
var
t
=
{
}
;
for
(
var
p
in
s
)
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
s
p
)
&
&
e
.
indexOf
(
p
)
<
0
)
t
[
p
]
=
s
[
p
]
;
if
(
s
!
=
null
&
&
typeof
Object
.
getOwnPropertySymbols
=
=
=
"
function
"
)
for
(
var
i
=
0
p
=
Object
.
getOwnPropertySymbols
(
s
)
;
i
<
p
.
length
;
i
+
+
)
{
if
(
e
.
indexOf
(
p
[
i
]
)
<
0
&
&
Object
.
prototype
.
propertyIsEnumerable
.
call
(
s
p
[
i
]
)
)
t
[
p
[
i
]
]
=
s
[
p
[
i
]
]
;
}
return
t
;
}
function
__decorate
(
decorators
target
key
desc
)
{
var
c
=
arguments
.
length
r
=
c
<
3
?
target
:
desc
=
=
=
null
?
desc
=
Object
.
getOwnPropertyDescriptor
(
target
key
)
:
desc
d
;
if
(
typeof
Reflect
=
=
=
"
object
"
&
&
typeof
Reflect
.
decorate
=
=
=
"
function
"
)
r
=
Reflect
.
decorate
(
decorators
target
key
desc
)
;
else
for
(
var
i
=
decorators
.
length
-
1
;
i
>
=
0
;
i
-
-
)
if
(
d
=
decorators
[
i
]
)
r
=
(
c
<
3
?
d
(
r
)
:
c
>
3
?
d
(
target
key
r
)
:
d
(
target
key
)
)
|
|
r
;
return
c
>
3
&
&
r
&
&
Object
.
defineProperty
(
target
key
r
)
r
;
}
function
__param
(
paramIndex
decorator
)
{
return
function
(
target
key
)
{
decorator
(
target
key
paramIndex
)
;
}
}
function
__metadata
(
metadataKey
metadataValue
)
{
if
(
typeof
Reflect
=
=
=
"
object
"
&
&
typeof
Reflect
.
metadata
=
=
=
"
function
"
)
return
Reflect
.
metadata
(
metadataKey
metadataValue
)
;
}
function
__awaiter
(
thisArg
_arguments
P
generator
)
{
function
adopt
(
value
)
{
return
value
instanceof
P
?
value
:
new
P
(
function
(
resolve
)
{
resolve
(
value
)
;
}
)
;
}
return
new
(
P
|
|
(
P
=
Promise
)
)
(
function
(
resolve
reject
)
{
function
fulfilled
(
value
)
{
try
{
step
(
generator
.
next
(
value
)
)
;
}
catch
(
e
)
{
reject
(
e
)
;
}
}
function
rejected
(
value
)
{
try
{
step
(
generator
[
"
throw
"
]
(
value
)
)
;
}
catch
(
e
)
{
reject
(
e
)
;
}
}
function
step
(
result
)
{
result
.
done
?
resolve
(
result
.
value
)
:
adopt
(
result
.
value
)
.
then
(
fulfilled
rejected
)
;
}
step
(
(
generator
=
generator
.
apply
(
thisArg
_arguments
|
|
[
]
)
)
.
next
(
)
)
;
}
)
;
}
function
__generator
(
thisArg
body
)
{
var
_
=
{
label
:
0
sent
:
function
(
)
{
if
(
t
[
0
]
&
1
)
throw
t
[
1
]
;
return
t
[
1
]
;
}
trys
:
[
]
ops
:
[
]
}
f
y
t
g
;
return
g
=
{
next
:
verb
(
0
)
"
throw
"
:
verb
(
1
)
"
return
"
:
verb
(
2
)
}
typeof
Symbol
=
=
=
"
function
"
&
&
(
g
[
Symbol
.
iterator
]
=
function
(
)
{
return
this
;
}
)
g
;
function
verb
(
n
)
{
return
function
(
v
)
{
return
step
(
[
n
v
]
)
;
}
;
}
function
step
(
op
)
{
if
(
f
)
throw
new
TypeError
(
"
Generator
is
already
executing
.
"
)
;
while
(
_
)
try
{
if
(
f
=
1
y
&
&
(
t
=
op
[
0
]
&
2
?
y
[
"
return
"
]
:
op
[
0
]
?
y
[
"
throw
"
]
|
|
(
(
t
=
y
[
"
return
"
]
)
&
&
t
.
call
(
y
)
0
)
:
y
.
next
)
&
&
!
(
t
=
t
.
call
(
y
op
[
1
]
)
)
.
done
)
return
t
;
if
(
y
=
0
t
)
op
=
[
op
[
0
]
&
2
t
.
value
]
;
switch
(
op
[
0
]
)
{
case
0
:
case
1
:
t
=
op
;
break
;
case
4
:
_
.
label
+
+
;
return
{
value
:
op
[
1
]
done
:
false
}
;
case
5
:
_
.
label
+
+
;
y
=
op
[
1
]
;
op
=
[
0
]
;
continue
;
case
7
:
op
=
_
.
ops
.
pop
(
)
;
_
.
trys
.
pop
(
)
;
continue
;
default
:
if
(
!
(
t
=
_
.
trys
t
=
t
.
length
>
0
&
&
t
[
t
.
length
-
1
]
)
&
&
(
op
[
0
]
=
=
=
6
|
|
op
[
0
]
=
=
=
2
)
)
{
_
=
0
;
continue
;
}
if
(
op
[
0
]
=
=
=
3
&
&
(
!
t
|
|
(
op
[
1
]
>
t
[
0
]
&
&
op
[
1
]
<
t
[
3
]
)
)
)
{
_
.
label
=
op
[
1
]
;
break
;
}
if
(
op
[
0
]
=
=
=
6
&
&
_
.
label
<
t
[
1
]
)
{
_
.
label
=
t
[
1
]
;
t
=
op
;
break
;
}
if
(
t
&
&
_
.
label
<
t
[
2
]
)
{
_
.
label
=
t
[
2
]
;
_
.
ops
.
push
(
op
)
;
break
;
}
if
(
t
[
2
]
)
_
.
ops
.
pop
(
)
;
_
.
trys
.
pop
(
)
;
continue
;
}
op
=
body
.
call
(
thisArg
_
)
;
}
catch
(
e
)
{
op
=
[
6
e
]
;
y
=
0
;
}
finally
{
f
=
t
=
0
;
}
if
(
op
[
0
]
&
5
)
throw
op
[
1
]
;
return
{
value
:
op
[
0
]
?
op
[
1
]
:
void
0
done
:
true
}
;
}
}
function
__createBinding
(
o
m
k
k2
)
{
if
(
k2
=
=
=
undefined
)
k2
=
k
;
o
[
k2
]
=
m
[
k
]
;
}
function
__exportStar
(
m
exports
)
{
for
(
var
p
in
m
)
if
(
p
!
=
=
"
default
"
&
&
!
exports
.
hasOwnProperty
(
p
)
)
exports
[
p
]
=
m
[
p
]
;
}
function
__values
(
o
)
{
var
s
=
typeof
Symbol
=
=
=
"
function
"
&
&
Symbol
.
iterator
m
=
s
&
&
o
[
s
]
i
=
0
;
if
(
m
)
return
m
.
call
(
o
)
;
if
(
o
&
&
typeof
o
.
length
=
=
=
"
number
"
)
return
{
next
:
function
(
)
{
if
(
o
&
&
i
>
=
o
.
length
)
o
=
void
0
;
return
{
value
:
o
&
&
o
[
i
+
+
]
done
:
!
o
}
;
}
}
;
throw
new
TypeError
(
s
?
"
Object
is
not
iterable
.
"
:
"
Symbol
.
iterator
is
not
defined
.
"
)
;
}
function
__read
(
o
n
)
{
var
m
=
typeof
Symbol
=
=
=
"
function
"
&
&
o
[
Symbol
.
iterator
]
;
if
(
!
m
)
return
o
;
var
i
=
m
.
call
(
o
)
r
ar
=
[
]
e
;
try
{
while
(
(
n
=
=
=
void
0
|
|
n
-
-
>
0
)
&
&
!
(
r
=
i
.
next
(
)
)
.
done
)
ar
.
push
(
r
.
value
)
;
}
catch
(
error
)
{
e
=
{
error
:
error
}
;
}
finally
{
try
{
if
(
r
&
&
!
r
.
done
&
&
(
m
=
i
[
"
return
"
]
)
)
m
.
call
(
i
)
;
}
finally
{
if
(
e
)
throw
e
.
error
;
}
}
return
ar
;
}
function
tslib_es6_spread
(
)
{
for
(
var
ar
=
[
]
i
=
0
;
i
<
arguments
.
length
;
i
+
+
)
ar
=
ar
.
concat
(
__read
(
arguments
[
i
]
)
)
;
return
ar
;
}
function
__spreadArrays
(
)
{
for
(
var
s
=
0
i
=
0
il
=
arguments
.
length
;
i
<
il
;
i
+
+
)
s
+
=
arguments
[
i
]
.
length
;
for
(
var
r
=
Array
(
s
)
k
=
0
i
=
0
;
i
<
il
;
i
+
+
)
for
(
var
a
=
arguments
[
i
]
j
=
0
jl
=
a
.
length
;
j
<
jl
;
j
+
+
k
+
+
)
r
[
k
]
=
a
[
j
]
;
return
r
;
}
;
function
__await
(
v
)
{
return
this
instanceof
__await
?
(
this
.
v
=
v
this
)
:
new
__await
(
v
)
;
}
function
__asyncGenerator
(
thisArg
_arguments
generator
)
{
if
(
!
Symbol
.
asyncIterator
)
throw
new
TypeError
(
"
Symbol
.
asyncIterator
is
not
defined
.
"
)
;
var
g
=
generator
.
apply
(
thisArg
_arguments
|
|
[
]
)
i
q
=
[
]
;
return
i
=
{
}
verb
(
"
next
"
)
verb
(
"
throw
"
)
verb
(
"
return
"
)
i
[
Symbol
.
asyncIterator
]
=
function
(
)
{
return
this
;
}
i
;
function
verb
(
n
)
{
if
(
g
[
n
]
)
i
[
n
]
=
function
(
v
)
{
return
new
Promise
(
function
(
a
b
)
{
q
.
push
(
[
n
v
a
b
]
)
>
1
|
|
resume
(
n
v
)
;
}
)
;
}
;
}
function
resume
(
n
v
)
{
try
{
step
(
g
[
n
]
(
v
)
)
;
}
catch
(
e
)
{
settle
(
q
[
0
]
[
3
]
e
)
;
}
}
function
step
(
r
)
{
r
.
value
instanceof
__await
?
Promise
.
resolve
(
r
.
value
.
v
)
.
then
(
fulfill
reject
)
:
settle
(
q
[
0
]
[
2
]
r
)
;
}
function
fulfill
(
value
)
{
resume
(
"
next
"
value
)
;
}
function
reject
(
value
)
{
resume
(
"
throw
"
value
)
;
}
function
settle
(
f
v
)
{
if
(
f
(
v
)
q
.
shift
(
)
q
.
length
)
resume
(
q
[
0
]
[
0
]
q
[
0
]
[
1
]
)
;
}
}
function
__asyncDelegator
(
o
)
{
var
i
p
;
return
i
=
{
}
verb
(
"
next
"
)
verb
(
"
throw
"
function
(
e
)
{
throw
e
;
}
)
verb
(
"
return
"
)
i
[
Symbol
.
iterator
]
=
function
(
)
{
return
this
;
}
i
;
function
verb
(
n
f
)
{
i
[
n
]
=
o
[
n
]
?
function
(
v
)
{
return
(
p
=
!
p
)
?
{
value
:
__await
(
o
[
n
]
(
v
)
)
done
:
n
=
=
=
"
return
"
}
:
f
?
f
(
v
)
:
v
;
}
:
f
;
}
}
function
__asyncValues
(
o
)
{
if
(
!
Symbol
.
asyncIterator
)
throw
new
TypeError
(
"
Symbol
.
asyncIterator
is
not
defined
.
"
)
;
var
m
=
o
[
Symbol
.
asyncIterator
]
i
;
return
m
?
m
.
call
(
o
)
:
(
o
=
typeof
__values
=
=
=
"
function
"
?
__values
(
o
)
:
o
[
Symbol
.
iterator
]
(
)
i
=
{
}
verb
(
"
next
"
)
verb
(
"
throw
"
)
verb
(
"
return
"
)
i
[
Symbol
.
asyncIterator
]
=
function
(
)
{
return
this
;
}
i
)
;
function
verb
(
n
)
{
i
[
n
]
=
o
[
n
]
&
&
function
(
v
)
{
return
new
Promise
(
function
(
resolve
reject
)
{
v
=
o
[
n
]
(
v
)
settle
(
resolve
reject
v
.
done
v
.
value
)
;
}
)
;
}
;
}
function
settle
(
resolve
reject
d
v
)
{
Promise
.
resolve
(
v
)
.
then
(
function
(
v
)
{
resolve
(
{
value
:
v
done
:
d
}
)
;
}
reject
)
;
}
}
function
__makeTemplateObject
(
cooked
raw
)
{
if
(
Object
.
defineProperty
)
{
Object
.
defineProperty
(
cooked
"
raw
"
{
value
:
raw
}
)
;
}
else
{
cooked
.
raw
=
raw
;
}
return
cooked
;
}
;
function
__importStar
(
mod
)
{
if
(
mod
&
&
mod
.
__esModule
)
return
mod
;
var
result
=
{
}
;
if
(
mod
!
=
null
)
for
(
var
k
in
mod
)
if
(
Object
.
hasOwnProperty
.
call
(
mod
k
)
)
result
[
k
]
=
mod
[
k
]
;
result
.
default
=
mod
;
return
result
;
}
function
__importDefault
(
mod
)
{
return
(
mod
&
&
mod
.
__esModule
)
?
mod
:
{
default
:
mod
}
;
}
function
__classPrivateFieldGet
(
receiver
privateMap
)
{
if
(
!
privateMap
.
has
(
receiver
)
)
{
throw
new
TypeError
(
"
attempted
to
get
private
field
on
non
-
instance
"
)
;
}
return
privateMap
.
get
(
receiver
)
;
}
function
__classPrivateFieldSet
(
receiver
privateMap
value
)
{
if
(
!
privateMap
.
has
(
receiver
)
)
{
throw
new
TypeError
(
"
attempted
to
set
private
field
on
non
-
instance
"
)
;
}
privateMap
.
set
(
receiver
value
)
;
return
value
;
}
;
var
Severity
;
(
function
(
Severity
)
{
Severity
[
"
Fatal
"
]
=
"
fatal
"
;
Severity
[
"
Error
"
]
=
"
error
"
;
Severity
[
"
Warning
"
]
=
"
warning
"
;
Severity
[
"
Log
"
]
=
"
log
"
;
Severity
[
"
Info
"
]
=
"
info
"
;
Severity
[
"
Debug
"
]
=
"
debug
"
;
Severity
[
"
Critical
"
]
=
"
critical
"
;
}
)
(
Severity
|
|
(
Severity
=
{
}
)
)
;
(
function
(
Severity
)
{
function
fromString
(
level
)
{
switch
(
level
)
{
case
'
debug
'
:
return
Severity
.
Debug
;
case
'
info
'
:
return
Severity
.
Info
;
case
'
warn
'
:
case
'
warning
'
:
return
Severity
.
Warning
;
case
'
error
'
:
return
Severity
.
Error
;
case
'
fatal
'
:
return
Severity
.
Fatal
;
case
'
critical
'
:
return
Severity
.
Critical
;
case
'
log
'
:
default
:
return
Severity
.
Log
;
}
}
Severity
.
fromString
=
fromString
;
}
)
(
Severity
|
|
(
Severity
=
{
}
)
)
;
;
var
Status
;
(
function
(
Status
)
{
Status
[
"
Unknown
"
]
=
"
unknown
"
;
Status
[
"
Skipped
"
]
=
"
skipped
"
;
Status
[
"
Success
"
]
=
"
success
"
;
Status
[
"
RateLimit
"
]
=
"
rate_limit
"
;
Status
[
"
Invalid
"
]
=
"
invalid
"
;
Status
[
"
Failed
"
]
=
"
failed
"
;
}
)
(
Status
|
|
(
Status
=
{
}
)
)
;
(
function
(
Status
)
{
function
fromHttpCode
(
code
)
{
if
(
code
>
=
200
&
&
code
<
300
)
{
return
Status
.
Success
;
}
if
(
code
=
=
=
429
)
{
return
Status
.
RateLimit
;
}
if
(
code
>
=
400
&
&
code
<
500
)
{
return
Status
.
Invalid
;
}
if
(
code
>
=
500
)
{
return
Status
.
Failed
;
}
return
Status
.
Unknown
;
}
Status
.
fromHttpCode
=
fromHttpCode
;
}
)
(
Status
|
|
(
Status
=
{
}
)
)
;
;
function
isError
(
wat
)
{
switch
(
Object
.
prototype
.
toString
.
call
(
wat
)
)
{
case
'
[
object
Error
]
'
:
return
true
;
case
'
[
object
Exception
]
'
:
return
true
;
case
'
[
object
DOMException
]
'
:
return
true
;
default
:
return
isInstanceOf
(
wat
Error
)
;
}
}
function
isErrorEvent
(
wat
)
{
return
Object
.
prototype
.
toString
.
call
(
wat
)
=
=
=
'
[
object
ErrorEvent
]
'
;
}
function
isDOMError
(
wat
)
{
return
Object
.
prototype
.
toString
.
call
(
wat
)
=
=
=
'
[
object
DOMError
]
'
;
}
function
isDOMException
(
wat
)
{
return
Object
.
prototype
.
toString
.
call
(
wat
)
=
=
=
'
[
object
DOMException
]
'
;
}
function
isString
(
wat
)
{
return
Object
.
prototype
.
toString
.
call
(
wat
)
=
=
=
'
[
object
String
]
'
;
}
function
isPrimitive
(
wat
)
{
return
wat
=
=
=
null
|
|
(
typeof
wat
!
=
=
'
object
'
&
&
typeof
wat
!
=
=
'
function
'
)
;
}
function
isPlainObject
(
wat
)
{
return
Object
.
prototype
.
toString
.
call
(
wat
)
=
=
=
'
[
object
Object
]
'
;
}
function
isEvent
(
wat
)
{
return
typeof
Event
!
=
=
'
undefined
'
&
&
isInstanceOf
(
wat
Event
)
;
}
function
isElement
(
wat
)
{
return
typeof
Element
!
=
=
'
undefined
'
&
&
isInstanceOf
(
wat
Element
)
;
}
function
isRegExp
(
wat
)
{
return
Object
.
prototype
.
toString
.
call
(
wat
)
=
=
=
'
[
object
RegExp
]
'
;
}
function
isThenable
(
wat
)
{
return
Boolean
(
wat
&
&
wat
.
then
&
&
typeof
wat
.
then
=
=
=
'
function
'
)
;
}
function
isSyntheticEvent
(
wat
)
{
return
isPlainObject
(
wat
)
&
&
'
nativeEvent
'
in
wat
&
&
'
preventDefault
'
in
wat
&
&
'
stopPropagation
'
in
wat
;
}
function
isInstanceOf
(
wat
base
)
{
try
{
return
wat
instanceof
base
;
}
catch
(
_e
)
{
return
false
;
}
}
var
time
=
__webpack_require__
(
7685
)
;
;
var
States
;
(
function
(
States
)
{
States
[
"
PENDING
"
]
=
"
PENDING
"
;
States
[
"
RESOLVED
"
]
=
"
RESOLVED
"
;
States
[
"
REJECTED
"
]
=
"
REJECTED
"
;
}
)
(
States
|
|
(
States
=
{
}
)
)
;
var
SyncPromise
=
(
function
(
)
{
function
SyncPromise
(
executor
)
{
var
_this
=
this
;
this
.
_state
=
States
.
PENDING
;
this
.
_handlers
=
[
]
;
this
.
_resolve
=
function
(
value
)
{
_this
.
_setResult
(
States
.
RESOLVED
value
)
;
}
;
this
.
_reject
=
function
(
reason
)
{
_this
.
_setResult
(
States
.
REJECTED
reason
)
;
}
;
this
.
_setResult
=
function
(
state
value
)
{
if
(
_this
.
_state
!
=
=
States
.
PENDING
)
{
return
;
}
if
(
isThenable
(
value
)
)
{
value
.
then
(
_this
.
_resolve
_this
.
_reject
)
;
return
;
}
_this
.
_state
=
state
;
_this
.
_value
=
value
;
_this
.
_executeHandlers
(
)
;
}
;
this
.
_attachHandler
=
function
(
handler
)
{
_this
.
_handlers
=
_this
.
_handlers
.
concat
(
handler
)
;
_this
.
_executeHandlers
(
)
;
}
;
this
.
_executeHandlers
=
function
(
)
{
if
(
_this
.
_state
=
=
=
States
.
PENDING
)
{
return
;
}
var
cachedHandlers
=
_this
.
_handlers
.
slice
(
)
;
_this
.
_handlers
=
[
]
;
cachedHandlers
.
forEach
(
function
(
handler
)
{
if
(
handler
.
done
)
{
return
;
}
if
(
_this
.
_state
=
=
=
States
.
RESOLVED
)
{
if
(
handler
.
onfulfilled
)
{
handler
.
onfulfilled
(
_this
.
_value
)
;
}
}
if
(
_this
.
_state
=
=
=
States
.
REJECTED
)
{
if
(
handler
.
onrejected
)
{
handler
.
onrejected
(
_this
.
_value
)
;
}
}
handler
.
done
=
true
;
}
)
;
}
;
try
{
executor
(
this
.
_resolve
this
.
_reject
)
;
}
catch
(
e
)
{
this
.
_reject
(
e
)
;
}
}
SyncPromise
.
resolve
=
function
(
value
)
{
return
new
SyncPromise
(
function
(
resolve
)
{
resolve
(
value
)
;
}
)
;
}
;
SyncPromise
.
reject
=
function
(
reason
)
{
return
new
SyncPromise
(
function
(
_
reject
)
{
reject
(
reason
)
;
}
)
;
}
;
SyncPromise
.
all
=
function
(
collection
)
{
return
new
SyncPromise
(
function
(
resolve
reject
)
{
if
(
!
Array
.
isArray
(
collection
)
)
{
reject
(
new
TypeError
(
"
Promise
.
all
requires
an
array
as
input
.
"
)
)
;
return
;
}
if
(
collection
.
length
=
=
=
0
)
{
resolve
(
[
]
)
;
return
;
}
var
counter
=
collection
.
length
;
var
resolvedCollection
=
[
]
;
collection
.
forEach
(
function
(
item
index
)
{
SyncPromise
.
resolve
(
item
)
.
then
(
function
(
value
)
{
resolvedCollection
[
index
]
=
value
;
counter
-
=
1
;
if
(
counter
!
=
=
0
)
{
return
;
}
resolve
(
resolvedCollection
)
;
}
)
.
then
(
null
reject
)
;
}
)
;
}
)
;
}
;
SyncPromise
.
prototype
.
then
=
function
(
onfulfilled
onrejected
)
{
var
_this
=
this
;
return
new
SyncPromise
(
function
(
resolve
reject
)
{
_this
.
_attachHandler
(
{
done
:
false
onfulfilled
:
function
(
result
)
{
if
(
!
onfulfilled
)
{
resolve
(
result
)
;
return
;
}
try
{
resolve
(
onfulfilled
(
result
)
)
;
return
;
}
catch
(
e
)
{
reject
(
e
)
;
return
;
}
}
onrejected
:
function
(
reason
)
{
if
(
!
onrejected
)
{
reject
(
reason
)
;
return
;
}
try
{
resolve
(
onrejected
(
reason
)
)
;
return
;
}
catch
(
e
)
{
reject
(
e
)
;
return
;
}
}
}
)
;
}
)
;
}
;
SyncPromise
.
prototype
.
catch
=
function
(
onrejected
)
{
return
this
.
then
(
function
(
val
)
{
return
val
;
}
onrejected
)
;
}
;
SyncPromise
.
prototype
.
finally
=
function
(
onfinally
)
{
var
_this
=
this
;
return
new
SyncPromise
(
function
(
resolve
reject
)
{
var
val
;
var
isRejected
;
return
_this
.
then
(
function
(
value
)
{
isRejected
=
false
;
val
=
value
;
if
(
onfinally
)
{
onfinally
(
)
;
}
}
function
(
reason
)
{
isRejected
=
true
;
val
=
reason
;
if
(
onfinally
)
{
onfinally
(
)
;
}
}
)
.
then
(
function
(
)
{
if
(
isRejected
)
{
reject
(
val
)
;
return
;
}
resolve
(
val
)
;
}
)
;
}
)
;
}
;
SyncPromise
.
prototype
.
toString
=
function
(
)
{
return
'
[
object
SyncPromise
]
'
;
}
;
return
SyncPromise
;
}
(
)
)
;
var
misc
=
__webpack_require__
(
2681
)
;
;
var
Scope
=
(
function
(
)
{
function
Scope
(
)
{
this
.
_notifyingListeners
=
false
;
this
.
_scopeListeners
=
[
]
;
this
.
_eventProcessors
=
[
]
;
this
.
_breadcrumbs
=
[
]
;
this
.
_user
=
{
}
;
this
.
_tags
=
{
}
;
this
.
_extra
=
{
}
;
this
.
_contexts
=
{
}
;
}
Scope
.
clone
=
function
(
scope
)
{
var
newScope
=
new
Scope
(
)
;
if
(
scope
)
{
newScope
.
_breadcrumbs
=
tslib_es6_spread
(
scope
.
_breadcrumbs
)
;
newScope
.
_tags
=
__assign
(
{
}
scope
.
_tags
)
;
newScope
.
_extra
=
__assign
(
{
}
scope
.
_extra
)
;
newScope
.
_contexts
=
__assign
(
{
}
scope
.
_contexts
)
;
newScope
.
_user
=
scope
.
_user
;
newScope
.
_level
=
scope
.
_level
;
newScope
.
_span
=
scope
.
_span
;
newScope
.
_session
=
scope
.
_session
;
newScope
.
_transactionName
=
scope
.
_transactionName
;
newScope
.
_fingerprint
=
scope
.
_fingerprint
;
newScope
.
_eventProcessors
=
tslib_es6_spread
(
scope
.
_eventProcessors
)
;
}
return
newScope
;
}
;
Scope
.
prototype
.
addScopeListener
=
function
(
callback
)
{
this
.
_scopeListeners
.
push
(
callback
)
;
}
;
Scope
.
prototype
.
addEventProcessor
=
function
(
callback
)
{
this
.
_eventProcessors
.
push
(
callback
)
;
return
this
;
}
;
Scope
.
prototype
.
setUser
=
function
(
user
)
{
this
.
_user
=
user
|
|
{
}
;
if
(
this
.
_session
)
{
this
.
_session
.
update
(
{
user
:
user
}
)
;
}
this
.
_notifyScopeListeners
(
)
;
return
this
;
}
;
Scope
.
prototype
.
getUser
=
function
(
)
{
return
this
.
_user
;
}
;
Scope
.
prototype
.
setTags
=
function
(
tags
)
{
this
.
_tags
=
__assign
(
__assign
(
{
}
this
.
_tags
)
tags
)
;
this
.
_notifyScopeListeners
(
)
;
return
this
;
}
;
Scope
.
prototype
.
setTag
=
function
(
key
value
)
{
var
_a
;
this
.
_tags
=
__assign
(
__assign
(
{
}
this
.
_tags
)
(
_a
=
{
}
_a
[
key
]
=
value
_a
)
)
;
this
.
_notifyScopeListeners
(
)
;
return
this
;
}
;
Scope
.
prototype
.
setExtras
=
function
(
extras
)
{
this
.
_extra
=
__assign
(
__assign
(
{
}
this
.
_extra
)
extras
)
;
this
.
_notifyScopeListeners
(
)
;
return
this
;
}
;
Scope
.
prototype
.
setExtra
=
function
(
key
extra
)
{
var
_a
;
this
.
_extra
=
__assign
(
__assign
(
{
}
this
.
_extra
)
(
_a
=
{
}
_a
[
key
]
=
extra
_a
)
)
;
this
.
_notifyScopeListeners
(
)
;
return
this
;
}
;
Scope
.
prototype
.
setFingerprint
=
function
(
fingerprint
)
{
this
.
_fingerprint
=
fingerprint
;
this
.
_notifyScopeListeners
(
)
;
return
this
;
}
;
Scope
.
prototype
.
setLevel
=
function
(
level
)
{
this
.
_level
=
level
;
this
.
_notifyScopeListeners
(
)
;
return
this
;
}
;
Scope
.
prototype
.
setTransactionName
=
function
(
name
)
{
this
.
_transactionName
=
name
;
this
.
_notifyScopeListeners
(
)
;
return
this
;
}
;
Scope
.
prototype
.
setTransaction
=
function
(
name
)
{
return
this
.
setTransactionName
(
name
)
;
}
;
Scope
.
prototype
.
setContext
=
function
(
key
context
)
{
var
_a
;
if
(
context
=
=
=
null
)
{
delete
this
.
_contexts
[
key
]
;
}
else
{
this
.
_contexts
=
__assign
(
__assign
(
{
}
this
.
_contexts
)
(
_a
=
{
}
_a
[
key
]
=
context
_a
)
)
;
}
this
.
_notifyScopeListeners
(
)
;
return
this
;
}
;
Scope
.
prototype
.
setSpan
=
function
(
span
)
{
this
.
_span
=
span
;
this
.
_notifyScopeListeners
(
)
;
return
this
;
}
;
Scope
.
prototype
.
getSpan
=
function
(
)
{
return
this
.
_span
;
}
;
Scope
.
prototype
.
getTransaction
=
function
(
)
{
var
_a
_b
_c
_d
;
var
span
=
this
.
getSpan
(
)
;
if
(
(
_a
=
span
)
=
=
=
null
|
|
_a
=
=
=
void
0
?
void
0
:
_a
.
transaction
)
{
return
(
_b
=
span
)
=
=
=
null
|
|
_b
=
=
=
void
0
?
void
0
:
_b
.
transaction
;
}
if
(
(
_d
=
(
_c
=
span
)
=
=
=
null
|
|
_c
=
=
=
void
0
?
void
0
:
_c
.
spanRecorder
)
=
=
=
null
|
|
_d
=
=
=
void
0
?
void
0
:
_d
.
spans
[
0
]
)
{
return
span
.
spanRecorder
.
spans
[
0
]
;
}
return
undefined
;
}
;
Scope
.
prototype
.
setSession
=
function
(
session
)
{
if
(
!
session
)
{
delete
this
.
_session
;
}
else
{
this
.
_session
=
session
;
}
this
.
_notifyScopeListeners
(
)
;
return
this
;
}
;
Scope
.
prototype
.
getSession
=
function
(
)
{
return
this
.
_session
;
}
;
Scope
.
prototype
.
update
=
function
(
captureContext
)
{
if
(
!
captureContext
)
{
return
this
;
}
if
(
typeof
captureContext
=
=
=
'
function
'
)
{
var
updatedScope
=
captureContext
(
this
)
;
return
updatedScope
instanceof
Scope
?
updatedScope
:
this
;
}
if
(
captureContext
instanceof
Scope
)
{
this
.
_tags
=
__assign
(
__assign
(
{
}
this
.
_tags
)
captureContext
.
_tags
)
;
this
.
_extra
=
__assign
(
__assign
(
{
}
this
.
_extra
)
captureContext
.
_extra
)
;
this
.
_contexts
=
__assign
(
__assign
(
{
}
this
.
_contexts
)
captureContext
.
_contexts
)
;
if
(
captureContext
.
_user
&
&
Object
.
keys
(
captureContext
.
_user
)
.
length
)
{
this
.
_user
=
captureContext
.
_user
;
}
if
(
captureContext
.
_level
)
{
this
.
_level
=
captureContext
.
_level
;
}
if
(
captureContext
.
_fingerprint
)
{
this
.
_fingerprint
=
captureContext
.
_fingerprint
;
}
}
else
if
(
isPlainObject
(
captureContext
)
)
{
captureContext
=
captureContext
;
this
.
_tags
=
__assign
(
__assign
(
{
}
this
.
_tags
)
captureContext
.
tags
)
;
this
.
_extra
=
__assign
(
__assign
(
{
}
this
.
_extra
)
captureContext
.
extra
)
;
this
.
_contexts
=
__assign
(
__assign
(
{
}
this
.
_contexts
)
captureContext
.
contexts
)
;
if
(
captureContext
.
user
)
{
this
.
_user
=
captureContext
.
user
;
}
if
(
captureContext
.
level
)
{
this
.
_level
=
captureContext
.
level
;
}
if
(
captureContext
.
fingerprint
)
{
this
.
_fingerprint
=
captureContext
.
fingerprint
;
}
}
return
this
;
}
;
Scope
.
prototype
.
clear
=
function
(
)
{
this
.
_breadcrumbs
=
[
]
;
this
.
_tags
=
{
}
;
this
.
_extra
=
{
}
;
this
.
_user
=
{
}
;
this
.
_contexts
=
{
}
;
this
.
_level
=
undefined
;
this
.
_transactionName
=
undefined
;
this
.
_fingerprint
=
undefined
;
this
.
_span
=
undefined
;
this
.
_session
=
undefined
;
this
.
_notifyScopeListeners
(
)
;
return
this
;
}
;
Scope
.
prototype
.
addBreadcrumb
=
function
(
breadcrumb
maxBreadcrumbs
)
{
var
mergedBreadcrumb
=
__assign
(
{
timestamp
:
(
0
time
.
yW
)
(
)
}
breadcrumb
)
;
this
.
_breadcrumbs
=
maxBreadcrumbs
!
=
=
undefined
&
&
maxBreadcrumbs
>
=
0
?
tslib_es6_spread
(
this
.
_breadcrumbs
[
mergedBreadcrumb
]
)
.
slice
(
-
maxBreadcrumbs
)
:
tslib_es6_spread
(
this
.
_breadcrumbs
[
mergedBreadcrumb
]
)
;
this
.
_notifyScopeListeners
(
)
;
return
this
;
}
;
Scope
.
prototype
.
clearBreadcrumbs
=
function
(
)
{
this
.
_breadcrumbs
=
[
]
;
this
.
_notifyScopeListeners
(
)
;
return
this
;
}
;
Scope
.
prototype
.
applyToEvent
=
function
(
event
hint
)
{
if
(
this
.
_extra
&
&
Object
.
keys
(
this
.
_extra
)
.
length
)
{
event
.
extra
=
__assign
(
__assign
(
{
}
this
.
_extra
)
event
.
extra
)
;
}
if
(
this
.
_tags
&
&
Object
.
keys
(
this
.
_tags
)
.
length
)
{
event
.
tags
=
__assign
(
__assign
(
{
}
this
.
_tags
)
event
.
tags
)
;
}
if
(
this
.
_user
&
&
Object
.
keys
(
this
.
_user
)
.
length
)
{
event
.
user
=
__assign
(
__assign
(
{
}
this
.
_user
)
event
.
user
)
;
}
if
(
this
.
_contexts
&
&
Object
.
keys
(
this
.
_contexts
)
.
length
)
{
event
.
contexts
=
__assign
(
__assign
(
{
}
this
.
_contexts
)
event
.
contexts
)
;
}
if
(
this
.
_level
)
{
event
.
level
=
this
.
_level
;
}
if
(
this
.
_transactionName
)
{
event
.
transaction
=
this
.
_transactionName
;
}
if
(
this
.
_span
)
{
event
.
contexts
=
__assign
(
{
trace
:
this
.
_span
.
getTraceContext
(
)
}
event
.
contexts
)
;
}
this
.
_applyFingerprint
(
event
)
;
event
.
breadcrumbs
=
tslib_es6_spread
(
(
event
.
breadcrumbs
|
|
[
]
)
this
.
_breadcrumbs
)
;
event
.
breadcrumbs
=
event
.
breadcrumbs
.
length
>
0
?
event
.
breadcrumbs
:
undefined
;
return
this
.
_notifyEventProcessors
(
tslib_es6_spread
(
getGlobalEventProcessors
(
)
this
.
_eventProcessors
)
event
hint
)
;
}
;
Scope
.
prototype
.
_notifyEventProcessors
=
function
(
processors
event
hint
index
)
{
var
_this
=
this
;
if
(
index
=
=
=
void
0
)
{
index
=
0
;
}
return
new
SyncPromise
(
function
(
resolve
reject
)
{
var
processor
=
processors
[
index
]
;
if
(
event
=
=
=
null
|
|
typeof
processor
!
=
=
'
function
'
)
{
resolve
(
event
)
;
}
else
{
var
result
=
processor
(
__assign
(
{
}
event
)
hint
)
;
if
(
isThenable
(
result
)
)
{
result
.
then
(
function
(
final
)
{
return
_this
.
_notifyEventProcessors
(
processors
final
hint
index
+
1
)
.
then
(
resolve
)
;
}
)
.
then
(
null
reject
)
;
}
else
{
_this
.
_notifyEventProcessors
(
processors
result
hint
index
+
1
)
.
then
(
resolve
)
.
then
(
null
reject
)
;
}
}
}
)
;
}
;
Scope
.
prototype
.
_notifyScopeListeners
=
function
(
)
{
var
_this
=
this
;
if
(
!
this
.
_notifyingListeners
)
{
this
.
_notifyingListeners
=
true
;
setTimeout
(
function
(
)
{
_this
.
_scopeListeners
.
forEach
(
function
(
callback
)
{
callback
(
_this
)
;
}
)
;
_this
.
_notifyingListeners
=
false
;
}
)
;
}
}
;
Scope
.
prototype
.
_applyFingerprint
=
function
(
event
)
{
event
.
fingerprint
=
event
.
fingerprint
?
Array
.
isArray
(
event
.
fingerprint
)
?
event
.
fingerprint
:
[
event
.
fingerprint
]
:
[
]
;
if
(
this
.
_fingerprint
)
{
event
.
fingerprint
=
event
.
fingerprint
.
concat
(
this
.
_fingerprint
)
;
}
if
(
event
.
fingerprint
&
&
!
event
.
fingerprint
.
length
)
{
delete
event
.
fingerprint
;
}
}
;
return
Scope
;
}
(
)
)
;
function
getGlobalEventProcessors
(
)
{
var
global
=
(
0
misc
.
Rf
)
(
)
;
global
.
__SENTRY__
=
global
.
__SENTRY__
|
|
{
}
;
global
.
__SENTRY__
.
globalEventProcessors
=
global
.
__SENTRY__
.
globalEventProcessors
|
|
[
]
;
return
global
.
__SENTRY__
.
globalEventProcessors
;
}
function
addGlobalEventProcessor
(
callback
)
{
getGlobalEventProcessors
(
)
.
push
(
callback
)
;
}
;
var
global
=
(
0
misc
.
Rf
)
(
)
;
var
PREFIX
=
'
Sentry
Logger
'
;
var
Logger
=
(
function
(
)
{
function
Logger
(
)
{
this
.
_enabled
=
false
;
}
Logger
.
prototype
.
disable
=
function
(
)
{
this
.
_enabled
=
false
;
}
;
Logger
.
prototype
.
enable
=
function
(
)
{
this
.
_enabled
=
true
;
}
;
Logger
.
prototype
.
log
=
function
(
)
{
var
args
=
[
]
;
for
(
var
_i
=
0
;
_i
<
arguments
.
length
;
_i
+
+
)
{
args
[
_i
]
=
arguments
[
_i
]
;
}
if
(
!
this
.
_enabled
)
{
return
;
}
(
0
misc
.
Cf
)
(
function
(
)
{
global
.
console
.
log
(
PREFIX
+
"
[
Log
]
:
"
+
args
.
join
(
'
'
)
)
;
}
)
;
}
;
Logger
.
prototype
.
warn
=
function
(
)
{
var
args
=
[
]
;
for
(
var
_i
=
0
;
_i
<
arguments
.
length
;
_i
+
+
)
{
args
[
_i
]
=
arguments
[
_i
]
;
}
if
(
!
this
.
_enabled
)
{
return
;
}
(
0
misc
.
Cf
)
(
function
(
)
{
global
.
console
.
warn
(
PREFIX
+
"
[
Warn
]
:
"
+
args
.
join
(
'
'
)
)
;
}
)
;
}
;
Logger
.
prototype
.
error
=
function
(
)
{
var
args
=
[
]
;
for
(
var
_i
=
0
;
_i
<
arguments
.
length
;
_i
+
+
)
{
args
[
_i
]
=
arguments
[
_i
]
;
}
if
(
!
this
.
_enabled
)
{
return
;
}
(
0
misc
.
Cf
)
(
function
(
)
{
global
.
console
.
error
(
PREFIX
+
"
[
Error
]
:
"
+
args
.
join
(
'
'
)
)
;
}
)
;
}
;
return
Logger
;
}
(
)
)
;
global
.
__SENTRY__
=
global
.
__SENTRY__
|
|
{
}
;
var
logger
=
global
.
__SENTRY__
.
logger
|
|
(
global
.
__SENTRY__
.
logger
=
new
Logger
(
)
)
;
var
node
=
__webpack_require__
(
8612
)
;
;
var
SessionStatus
;
(
function
(
SessionStatus
)
{
SessionStatus
[
"
Ok
"
]
=
"
ok
"
;
SessionStatus
[
"
Exited
"
]
=
"
exited
"
;
SessionStatus
[
"
Crashed
"
]
=
"
crashed
"
;
SessionStatus
[
"
Abnormal
"
]
=
"
abnormal
"
;
}
)
(
SessionStatus
|
|
(
SessionStatus
=
{
}
)
)
;
;
function
htmlTreeAsString
(
elem
)
{
try
{
var
currentElem
=
elem
;
var
MAX_TRAVERSE_HEIGHT
=
5
;
var
MAX_OUTPUT_LEN
=
80
;
var
out
=
[
]
;
var
height
=
0
;
var
len
=
0
;
var
separator
=
'
>
'
;
var
sepLength
=
separator
.
length
;
var
nextStr
=
void
0
;
while
(
currentElem
&
&
height
+
+
<
MAX_TRAVERSE_HEIGHT
)
{
nextStr
=
_htmlElementAsString
(
currentElem
)
;
if
(
nextStr
=
=
=
'
html
'
|
|
(
height
>
1
&
&
len
+
out
.
length
*
sepLength
+
nextStr
.
length
>
=
MAX_OUTPUT_LEN
)
)
{
break
;
}
out
.
push
(
nextStr
)
;
len
+
=
nextStr
.
length
;
currentElem
=
currentElem
.
parentNode
;
}
return
out
.
reverse
(
)
.
join
(
separator
)
;
}
catch
(
_oO
)
{
return
'
<
unknown
>
'
;
}
}
function
_htmlElementAsString
(
el
)
{
var
elem
=
el
;
var
out
=
[
]
;
var
className
;
var
classes
;
var
key
;
var
attr
;
var
i
;
if
(
!
elem
|
|
!
elem
.
tagName
)
{
return
'
'
;
}
out
.
push
(
elem
.
tagName
.
toLowerCase
(
)
)
;
if
(
elem
.
id
)
{
out
.
push
(
"
#
"
+
elem
.
id
)
;
}
className
=
elem
.
className
;
if
(
className
&
&
isString
(
className
)
)
{
classes
=
className
.
split
(
/
\
s
+
/
)
;
for
(
i
=
0
;
i
<
classes
.
length
;
i
+
+
)
{
out
.
push
(
"
.
"
+
classes
[
i
]
)
;
}
}
var
allowedAttrs
=
[
'
type
'
'
name
'
'
title
'
'
alt
'
]
;
for
(
i
=
0
;
i
<
allowedAttrs
.
length
;
i
+
+
)
{
key
=
allowedAttrs
[
i
]
;
attr
=
elem
.
getAttribute
(
key
)
;
if
(
attr
)
{
out
.
push
(
"
[
"
+
key
+
"
=
\
"
"
+
attr
+
"
\
"
]
"
)
;
}
}
return
out
.
join
(
'
'
)
;
}
;
var
Memo
=
(
function
(
)
{
function
Memo
(
)
{
this
.
_hasWeakSet
=
typeof
WeakSet
=
=
=
'
function
'
;
this
.
_inner
=
this
.
_hasWeakSet
?
new
WeakSet
(
)
:
[
]
;
}
Memo
.
prototype
.
memoize
=
function
(
obj
)
{
if
(
this
.
_hasWeakSet
)
{
if
(
this
.
_inner
.
has
(
obj
)
)
{
return
true
;
}
this
.
_inner
.
add
(
obj
)
;
return
false
;
}
for
(
var
i
=
0
;
i
<
this
.
_inner
.
length
;
i
+
+
)
{
var
value
=
this
.
_inner
[
i
]
;
if
(
value
=
=
=
obj
)
{
return
true
;
}
}
this
.
_inner
.
push
(
obj
)
;
return
false
;
}
;
Memo
.
prototype
.
unmemoize
=
function
(
obj
)
{
if
(
this
.
_hasWeakSet
)
{
this
.
_inner
.
delete
(
obj
)
;
}
else
{
for
(
var
i
=
0
;
i
<
this
.
_inner
.
length
;
i
+
+
)
{
if
(
this
.
_inner
[
i
]
=
=
=
obj
)
{
this
.
_inner
.
splice
(
i
1
)
;
break
;
}
}
}
}
;
return
Memo
;
}
(
)
)
;
;
var
defaultFunctionName
=
'
<
anonymous
>
'
;
function
getFunctionName
(
fn
)
{
try
{
if
(
!
fn
|
|
typeof
fn
!
=
=
'
function
'
)
{
return
defaultFunctionName
;
}
return
fn
.
name
|
|
defaultFunctionName
;
}
catch
(
e
)
{
return
defaultFunctionName
;
}
}
;
function
truncate
(
str
max
)
{
if
(
max
=
=
=
void
0
)
{
max
=
0
;
}
if
(
typeof
str
!
=
=
'
string
'
|
|
max
=
=
=
0
)
{
return
str
;
}
return
str
.
length
<
=
max
?
str
:
str
.
substr
(
0
max
)
+
"
.
.
.
"
;
}
function
snipLine
(
line
colno
)
{
var
newLine
=
line
;
var
ll
=
newLine
.
length
;
if
(
ll
<
=
150
)
{
return
newLine
;
}
if
(
colno
>
ll
)
{
colno
=
ll
;
}
var
start
=
Math
.
max
(
colno
-
60
0
)
;
if
(
start
<
5
)
{
start
=
0
;
}
var
end
=
Math
.
min
(
start
+
140
ll
)
;
if
(
end
>
ll
-
5
)
{
end
=
ll
;
}
if
(
end
=
=
=
ll
)
{
start
=
Math
.
max
(
end
-
140
0
)
;
}
newLine
=
newLine
.
slice
(
start
end
)
;
if
(
start
>
0
)
{
newLine
=
"
'
{
snip
}
"
+
newLine
;
}
if
(
end
<
ll
)
{
newLine
+
=
'
{
snip
}
'
;
}
return
newLine
;
}
function
safeJoin
(
input
delimiter
)
{
if
(
!
Array
.
isArray
(
input
)
)
{
return
'
'
;
}
var
output
=
[
]
;
for
(
var
i
=
0
;
i
<
input
.
length
;
i
+
+
)
{
var
value
=
input
[
i
]
;
try
{
output
.
push
(
String
(
value
)
)
;
}
catch
(
e
)
{
output
.
push
(
'
[
value
cannot
be
serialized
]
'
)
;
}
}
return
output
.
join
(
delimiter
)
;
}
function
isMatchingPattern
(
value
pattern
)
{
if
(
!
isString
(
value
)
)
{
return
false
;
}
if
(
isRegExp
(
pattern
)
)
{
return
pattern
.
test
(
value
)
;
}
if
(
typeof
pattern
=
=
=
'
string
'
)
{
return
value
.
indexOf
(
pattern
)
!
=
=
-
1
;
}
return
false
;
}
;
function
fill
(
source
name
replacement
)
{
if
(
!
(
name
in
source
)
)
{
return
;
}
var
original
=
source
[
name
]
;
var
wrapped
=
replacement
(
original
)
;
if
(
typeof
wrapped
=
=
=
'
function
'
)
{
try
{
wrapped
.
prototype
=
wrapped
.
prototype
|
|
{
}
;
Object
.
defineProperties
(
wrapped
{
__sentry_original__
:
{
enumerable
:
false
value
:
original
}
}
)
;
}
catch
(
_Oo
)
{
}
}
source
[
name
]
=
wrapped
;
}
function
urlEncode
(
object
)
{
return
Object
.
keys
(
object
)
.
map
(
function
(
key
)
{
return
encodeURIComponent
(
key
)
+
"
=
"
+
encodeURIComponent
(
object
[
key
]
)
;
}
)
.
join
(
'
&
'
)
;
}
function
getWalkSource
(
value
)
{
if
(
isError
(
value
)
)
{
var
error
=
value
;
var
err
=
{
message
:
error
.
message
name
:
error
.
name
stack
:
error
.
stack
}
;
for
(
var
i
in
error
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
error
i
)
)
{
err
[
i
]
=
error
[
i
]
;
}
}
return
err
;
}
if
(
isEvent
(
value
)
)
{
var
event_1
=
value
;
var
source
=
{
}
;
source
.
type
=
event_1
.
type
;
try
{
source
.
target
=
isElement
(
event_1
.
target
)
?
htmlTreeAsString
(
event_1
.
target
)
:
Object
.
prototype
.
toString
.
call
(
event_1
.
target
)
;
}
catch
(
_oO
)
{
source
.
target
=
'
<
unknown
>
'
;
}
try
{
source
.
currentTarget
=
isElement
(
event_1
.
currentTarget
)
?
htmlTreeAsString
(
event_1
.
currentTarget
)
:
Object
.
prototype
.
toString
.
call
(
event_1
.
currentTarget
)
;
}
catch
(
_oO
)
{
source
.
currentTarget
=
'
<
unknown
>
'
;
}
if
(
typeof
CustomEvent
!
=
=
'
undefined
'
&
&
isInstanceOf
(
value
CustomEvent
)
)
{
source
.
detail
=
event_1
.
detail
;
}
for
(
var
i
in
event_1
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
event_1
i
)
)
{
source
[
i
]
=
event_1
;
}
}
return
source
;
}
return
value
;
}
function
utf8Length
(
value
)
{
return
~
-
encodeURI
(
value
)
.
split
(
/
%
.
.
|
.
/
)
.
length
;
}
function
jsonSize
(
value
)
{
return
utf8Length
(
JSON
.
stringify
(
value
)
)
;
}
function
normalizeToSize
(
object
depth
maxSize
)
{
if
(
depth
=
=
=
void
0
)
{
depth
=
3
;
}
if
(
maxSize
=
=
=
void
0
)
{
maxSize
=
100
*
1024
;
}
var
serialized
=
normalize
(
object
depth
)
;
if
(
jsonSize
(
serialized
)
>
maxSize
)
{
return
normalizeToSize
(
object
depth
-
1
maxSize
)
;
}
return
serialized
;
}
function
serializeValue
(
value
)
{
var
type
=
Object
.
prototype
.
toString
.
call
(
value
)
;
if
(
typeof
value
=
=
=
'
string
'
)
{
return
value
;
}
if
(
type
=
=
=
'
[
object
Object
]
'
)
{
return
'
[
Object
]
'
;
}
if
(
type
=
=
=
'
[
object
Array
]
'
)
{
return
'
[
Array
]
'
;
}
var
normalized
=
normalizeValue
(
value
)
;
return
isPrimitive
(
normalized
)
?
normalized
:
type
;
}
function
normalizeValue
(
value
key
)
{
if
(
key
=
=
=
'
domain
'
&
&
value
&
&
typeof
value
=
=
=
'
object
'
&
&
value
.
_events
)
{
return
'
[
Domain
]
'
;
}
if
(
key
=
=
=
'
domainEmitter
'
)
{
return
'
[
DomainEmitter
]
'
;
}
if
(
typeof
__webpack_require__
.
g
!
=
=
'
undefined
'
&
&
value
=
=
=
__webpack_require__
.
g
)
{
return
'
[
Global
]
'
;
}
if
(
typeof
window
!
=
=
'
undefined
'
&
&
value
=
=
=
window
)
{
return
'
[
Window
]
'
;
}
if
(
typeof
document
!
=
=
'
undefined
'
&
&
value
=
=
=
document
)
{
return
'
[
Document
]
'
;
}
if
(
isSyntheticEvent
(
value
)
)
{
return
'
[
SyntheticEvent
]
'
;
}
if
(
typeof
value
=
=
=
'
number
'
&
&
value
!
=
=
value
)
{
return
'
[
NaN
]
'
;
}
if
(
value
=
=
=
void
0
)
{
return
'
[
undefined
]
'
;
}
if
(
typeof
value
=
=
=
'
function
'
)
{
return
"
[
Function
:
"
+
getFunctionName
(
value
)
+
"
]
"
;
}
return
value
;
}
function
walk
(
key
value
depth
memo
)
{
if
(
depth
=
=
=
void
0
)
{
depth
=
+
Infinity
;
}
if
(
memo
=
=
=
void
0
)
{
memo
=
new
Memo
(
)
;
}
if
(
depth
=
=
=
0
)
{
return
serializeValue
(
value
)
;
}
if
(
value
!
=
=
null
&
&
value
!
=
=
undefined
&
&
typeof
value
.
toJSON
=
=
=
'
function
'
)
{
return
value
.
toJSON
(
)
;
}
var
normalized
=
normalizeValue
(
value
key
)
;
if
(
isPrimitive
(
normalized
)
)
{
return
normalized
;
}
var
source
=
getWalkSource
(
value
)
;
var
acc
=
Array
.
isArray
(
value
)
?
[
]
:
{
}
;
if
(
memo
.
memoize
(
value
)
)
{
return
'
[
Circular
~
]
'
;
}
for
(
var
innerKey
in
source
)
{
if
(
!
Object
.
prototype
.
hasOwnProperty
.
call
(
source
innerKey
)
)
{
continue
;
}
acc
[
innerKey
]
=
walk
(
innerKey
source
[
innerKey
]
depth
-
1
memo
)
;
}
memo
.
unmemoize
(
value
)
;
return
acc
;
}
function
normalize
(
input
depth
)
{
try
{
return
JSON
.
parse
(
JSON
.
stringify
(
input
function
(
key
value
)
{
return
walk
(
key
value
depth
)
;
}
)
)
;
}
catch
(
_oO
)
{
return
'
*
*
non
-
serializable
*
*
'
;
}
}
function
extractExceptionKeysForMessage
(
exception
maxLength
)
{
if
(
maxLength
=
=
=
void
0
)
{
maxLength
=
40
;
}
var
keys
=
Object
.
keys
(
getWalkSource
(
exception
)
)
;
keys
.
sort
(
)
;
if
(
!
keys
.
length
)
{
return
'
[
object
has
no
keys
]
'
;
}
if
(
keys
[
0
]
.
length
>
=
maxLength
)
{
return
truncate
(
keys
[
0
]
maxLength
)
;
}
for
(
var
includedKeys
=
keys
.
length
;
includedKeys
>
0
;
includedKeys
-
-
)
{
var
serialized
=
keys
.
slice
(
0
includedKeys
)
.
join
(
'
'
)
;
if
(
serialized
.
length
>
maxLength
)
{
continue
;
}
if
(
includedKeys
=
=
=
keys
.
length
)
{
return
serialized
;
}
return
truncate
(
serialized
maxLength
)
;
}
return
'
'
;
}
function
dropUndefinedKeys
(
val
)
{
var
e_1
_a
;
if
(
isPlainObject
(
val
)
)
{
var
obj
=
val
;
var
rv
=
{
}
;
try
{
for
(
var
_b
=
__values
(
Object
.
keys
(
obj
)
)
_c
=
_b
.
next
(
)
;
!
_c
.
done
;
_c
=
_b
.
next
(
)
)
{
var
key
=
_c
.
value
;
if
(
typeof
obj
[
key
]
!
=
=
'
undefined
'
)
{
rv
[
key
]
=
dropUndefinedKeys
(
obj
[
key
]
)
;
}
}
}
catch
(
e_1_1
)
{
e_1
=
{
error
:
e_1_1
}
;
}
finally
{
try
{
if
(
_c
&
&
!
_c
.
done
&
&
(
_a
=
_b
.
return
)
)
_a
.
call
(
_b
)
;
}
finally
{
if
(
e_1
)
throw
e_1
.
error
;
}
}
return
rv
;
}
if
(
Array
.
isArray
(
val
)
)
{
return
val
.
map
(
dropUndefinedKeys
)
;
}
return
val
;
}
;
var
Session
=
(
function
(
)
{
function
Session
(
context
)
{
this
.
errors
=
0
;
this
.
sid
=
(
0
misc
.
DM
)
(
)
;
this
.
timestamp
=
Date
.
now
(
)
;
this
.
started
=
Date
.
now
(
)
;
this
.
duration
=
0
;
this
.
status
=
SessionStatus
.
Ok
;
if
(
context
)
{
this
.
update
(
context
)
;
}
}
Session
.
prototype
.
update
=
function
(
context
)
{
if
(
context
=
=
=
void
0
)
{
context
=
{
}
;
}
if
(
context
.
user
)
{
if
(
context
.
user
.
ip_address
)
{
this
.
ipAddress
=
context
.
user
.
ip_address
;
}
if
(
!
context
.
did
)
{
this
.
did
=
context
.
user
.
id
|
|
context
.
user
.
email
|
|
context
.
user
.
username
;
}
}
this
.
timestamp
=
context
.
timestamp
|
|
Date
.
now
(
)
;
if
(
context
.
sid
)
{
this
.
sid
=
context
.
sid
.
length
=
=
=
32
?
context
.
sid
:
(
0
misc
.
DM
)
(
)
;
}
if
(
context
.
did
)
{
this
.
did
=
"
"
+
context
.
did
;
}
if
(
typeof
context
.
started
=
=
=
'
number
'
)
{
this
.
started
=
context
.
started
;
}
if
(
typeof
context
.
duration
=
=
=
'
number
'
)
{
this
.
duration
=
context
.
duration
;
}
else
{
this
.
duration
=
this
.
timestamp
-
this
.
started
;
}
if
(
context
.
release
)
{
this
.
release
=
context
.
release
;
}
if
(
context
.
environment
)
{
this
.
environment
=
context
.
environment
;
}
if
(
context
.
ipAddress
)
{
this
.
ipAddress
=
context
.
ipAddress
;
}
if
(
context
.
userAgent
)
{
this
.
userAgent
=
context
.
userAgent
;
}
if
(
typeof
context
.
errors
=
=
=
'
number
'
)
{
this
.
errors
=
context
.
errors
;
}
if
(
context
.
status
)
{
this
.
status
=
context
.
status
;
}
}
;
Session
.
prototype
.
close
=
function
(
status
)
{
if
(
status
)
{
this
.
update
(
{
status
:
status
}
)
;
}
else
if
(
this
.
status
=
=
=
SessionStatus
.
Ok
)
{
this
.
update
(
{
status
:
SessionStatus
.
Exited
}
)
;
}
else
{
this
.
update
(
)
;
}
}
;
Session
.
prototype
.
toJSON
=
function
(
)
{
return
dropUndefinedKeys
(
{
sid
:
"
"
+
this
.
sid
init
:
true
started
:
new
Date
(
this
.
started
)
.
toISOString
(
)
timestamp
:
new
Date
(
this
.
timestamp
)
.
toISOString
(
)
status
:
this
.
status
errors
:
this
.
errors
did
:
typeof
this
.
did
=
=
=
'
number
'
|
|
typeof
this
.
did
=
=
=
'
string
'
?
"
"
+
this
.
did
:
undefined
duration
:
this
.
duration
attrs
:
dropUndefinedKeys
(
{
release
:
this
.
release
environment
:
this
.
environment
ip_address
:
this
.
ipAddress
user_agent
:
this
.
userAgent
}
)
}
)
;
}
;
return
Session
;
}
(
)
)
;
;
var
API_VERSION
=
3
;
var
DEFAULT_BREADCRUMBS
=
100
;
var
MAX_BREADCRUMBS
=
100
;
var
Hub
=
(
function
(
)
{
function
Hub
(
client
scope
_version
)
{
if
(
scope
=
=
=
void
0
)
{
scope
=
new
Scope
(
)
;
}
if
(
_version
=
=
=
void
0
)
{
_version
=
API_VERSION
;
}
this
.
_version
=
_version
;
this
.
_stack
=
[
{
}
]
;
this
.
getStackTop
(
)
.
scope
=
scope
;
this
.
bindClient
(
client
)
;
}
Hub
.
prototype
.
isOlderThan
=
function
(
version
)
{
return
this
.
_version
<
version
;
}
;
Hub
.
prototype
.
bindClient
=
function
(
client
)
{
var
top
=
this
.
getStackTop
(
)
;
top
.
client
=
client
;
if
(
client
&
&
client
.
setupIntegrations
)
{
client
.
setupIntegrations
(
)
;
}
}
;
Hub
.
prototype
.
pushScope
=
function
(
)
{
var
scope
=
Scope
.
clone
(
this
.
getScope
(
)
)
;
this
.
getStack
(
)
.
push
(
{
client
:
this
.
getClient
(
)
scope
:
scope
}
)
;
return
scope
;
}
;
Hub
.
prototype
.
popScope
=
function
(
)
{
if
(
this
.
getStack
(
)
.
length
<
=
1
)
return
false
;
return
!
!
this
.
getStack
(
)
.
pop
(
)
;
}
;
Hub
.
prototype
.
withScope
=
function
(
callback
)
{
var
scope
=
this
.
pushScope
(
)
;
try
{
callback
(
scope
)
;
}
finally
{
this
.
popScope
(
)
;
}
}
;
Hub
.
prototype
.
getClient
=
function
(
)
{
return
this
.
getStackTop
(
)
.
client
;
}
;
Hub
.
prototype
.
getScope
=
function
(
)
{
return
this
.
getStackTop
(
)
.
scope
;
}
;
Hub
.
prototype
.
getStack
=
function
(
)
{
return
this
.
_stack
;
}
;
Hub
.
prototype
.
getStackTop
=
function
(
)
{
return
this
.
_stack
[
this
.
_stack
.
length
-
1
]
;
}
;
Hub
.
prototype
.
captureException
=
function
(
exception
hint
)
{
var
eventId
=
(
this
.
_lastEventId
=
(
0
misc
.
DM
)
(
)
)
;
var
finalHint
=
hint
;
if
(
!
hint
)
{
var
syntheticException
=
void
0
;
try
{
throw
new
Error
(
'
Sentry
syntheticException
'
)
;
}
catch
(
exception
)
{
syntheticException
=
exception
;
}
finalHint
=
{
originalException
:
exception
syntheticException
:
syntheticException
}
;
}
this
.
_invokeClient
(
'
captureException
'
exception
__assign
(
__assign
(
{
}
finalHint
)
{
event_id
:
eventId
}
)
)
;
return
eventId
;
}
;
Hub
.
prototype
.
captureMessage
=
function
(
message
level
hint
)
{
var
eventId
=
(
this
.
_lastEventId
=
(
0
misc
.
DM
)
(
)
)
;
var
finalHint
=
hint
;
if
(
!
hint
)
{
var
syntheticException
=
void
0
;
try
{
throw
new
Error
(
message
)
;
}
catch
(
exception
)
{
syntheticException
=
exception
;
}
finalHint
=
{
originalException
:
message
syntheticException
:
syntheticException
}
;
}
this
.
_invokeClient
(
'
captureMessage
'
message
level
__assign
(
__assign
(
{
}
finalHint
)
{
event_id
:
eventId
}
)
)
;
return
eventId
;
}
;
Hub
.
prototype
.
captureEvent
=
function
(
event
hint
)
{
var
eventId
=
(
this
.
_lastEventId
=
(
0
misc
.
DM
)
(
)
)
;
this
.
_invokeClient
(
'
captureEvent
'
event
__assign
(
__assign
(
{
}
hint
)
{
event_id
:
eventId
}
)
)
;
return
eventId
;
}
;
Hub
.
prototype
.
lastEventId
=
function
(
)
{
return
this
.
_lastEventId
;
}
;
Hub
.
prototype
.
addBreadcrumb
=
function
(
breadcrumb
hint
)
{
var
_a
=
this
.
getStackTop
(
)
scope
=
_a
.
scope
client
=
_a
.
client
;
if
(
!
scope
|
|
!
client
)
return
;
var
_b
=
(
client
.
getOptions
&
&
client
.
getOptions
(
)
)
|
|
{
}
_c
=
_b
.
beforeBreadcrumb
beforeBreadcrumb
=
_c
=
=
=
void
0
?
null
:
_c
_d
=
_b
.
maxBreadcrumbs
maxBreadcrumbs
=
_d
=
=
=
void
0
?
DEFAULT_BREADCRUMBS
:
_d
;
if
(
maxBreadcrumbs
<
=
0
)
return
;
var
timestamp
=
(
0
time
.
yW
)
(
)
;
var
mergedBreadcrumb
=
__assign
(
{
timestamp
:
timestamp
}
breadcrumb
)
;
var
finalBreadcrumb
=
beforeBreadcrumb
?
(
0
misc
.
Cf
)
(
function
(
)
{
return
beforeBreadcrumb
(
mergedBreadcrumb
hint
)
;
}
)
:
mergedBreadcrumb
;
if
(
finalBreadcrumb
=
=
=
null
)
return
;
scope
.
addBreadcrumb
(
finalBreadcrumb
Math
.
min
(
maxBreadcrumbs
MAX_BREADCRUMBS
)
)
;
}
;
Hub
.
prototype
.
setUser
=
function
(
user
)
{
var
scope
=
this
.
getScope
(
)
;
if
(
scope
)
scope
.
setUser
(
user
)
;
}
;
Hub
.
prototype
.
setTags
=
function
(
tags
)
{
var
scope
=
this
.
getScope
(
)
;
if
(
scope
)
scope
.
setTags
(
tags
)
;
}
;
Hub
.
prototype
.
setExtras
=
function
(
extras
)
{
var
scope
=
this
.
getScope
(
)
;
if
(
scope
)
scope
.
setExtras
(
extras
)
;
}
;
Hub
.
prototype
.
setTag
=
function
(
key
value
)
{
var
scope
=
this
.
getScope
(
)
;
if
(
scope
)
scope
.
setTag
(
key
value
)
;
}
;
Hub
.
prototype
.
setExtra
=
function
(
key
extra
)
{
var
scope
=
this
.
getScope
(
)
;
if
(
scope
)
scope
.
setExtra
(
key
extra
)
;
}
;
Hub
.
prototype
.
setContext
=
function
(
name
context
)
{
var
scope
=
this
.
getScope
(
)
;
if
(
scope
)
scope
.
setContext
(
name
context
)
;
}
;
Hub
.
prototype
.
configureScope
=
function
(
callback
)
{
var
_a
=
this
.
getStackTop
(
)
scope
=
_a
.
scope
client
=
_a
.
client
;
if
(
scope
&
&
client
)
{
callback
(
scope
)
;
}
}
;
Hub
.
prototype
.
run
=
function
(
callback
)
{
var
oldHub
=
makeMain
(
this
)
;
try
{
callback
(
this
)
;
}
finally
{
makeMain
(
oldHub
)
;
}
}
;
Hub
.
prototype
.
getIntegration
=
function
(
integration
)
{
var
client
=
this
.
getClient
(
)
;
if
(
!
client
)
return
null
;
try
{
return
client
.
getIntegration
(
integration
)
;
}
catch
(
_oO
)
{
logger
.
warn
(
"
Cannot
retrieve
integration
"
+
integration
.
id
+
"
from
the
current
Hub
"
)
;
return
null
;
}
}
;
Hub
.
prototype
.
startSpan
=
function
(
context
)
{
return
this
.
_callExtensionMethod
(
'
startSpan
'
context
)
;
}
;
Hub
.
prototype
.
startTransaction
=
function
(
context
customSamplingContext
)
{
return
this
.
_callExtensionMethod
(
'
startTransaction
'
context
customSamplingContext
)
;
}
;
Hub
.
prototype
.
traceHeaders
=
function
(
)
{
return
this
.
_callExtensionMethod
(
'
traceHeaders
'
)
;
}
;
Hub
.
prototype
.
startSession
=
function
(
context
)
{
this
.
endSession
(
)
;
var
_a
=
this
.
getStackTop
(
)
scope
=
_a
.
scope
client
=
_a
.
client
;
var
_b
=
(
client
&
&
client
.
getOptions
(
)
)
|
|
{
}
release
=
_b
.
release
environment
=
_b
.
environment
;
var
session
=
new
Session
(
__assign
(
__assign
(
{
release
:
release
environment
:
environment
}
(
scope
&
&
{
user
:
scope
.
getUser
(
)
}
)
)
context
)
)
;
if
(
scope
)
{
scope
.
setSession
(
session
)
;
}
return
session
;
}
;
Hub
.
prototype
.
endSession
=
function
(
)
{
var
_a
=
this
.
getStackTop
(
)
scope
=
_a
.
scope
client
=
_a
.
client
;
if
(
!
scope
)
return
;
var
session
=
scope
.
getSession
(
)
;
if
(
session
)
{
session
.
close
(
)
;
if
(
client
&
&
client
.
captureSession
)
{
client
.
captureSession
(
session
)
;
}
scope
.
setSession
(
)
;
}
}
;
Hub
.
prototype
.
_invokeClient
=
function
(
method
)
{
var
_a
;
var
args
=
[
]
;
for
(
var
_i
=
1
;
_i
<
arguments
.
length
;
_i
+
+
)
{
args
[
_i
-
1
]
=
arguments
[
_i
]
;
}
var
_b
=
this
.
getStackTop
(
)
scope
=
_b
.
scope
client
=
_b
.
client
;
if
(
client
&
&
client
[
method
]
)
{
(
_a
=
client
)
[
method
]
.
apply
(
_a
tslib_es6_spread
(
args
[
scope
]
)
)
;
}
}
;
Hub
.
prototype
.
_callExtensionMethod
=
function
(
method
)
{
var
args
=
[
]
;
for
(
var
_i
=
1
;
_i
<
arguments
.
length
;
_i
+
+
)
{
args
[
_i
-
1
]
=
arguments
[
_i
]
;
}
var
carrier
=
getMainCarrier
(
)
;
var
sentry
=
carrier
.
__SENTRY__
;
if
(
sentry
&
&
sentry
.
extensions
&
&
typeof
sentry
.
extensions
[
method
]
=
=
=
'
function
'
)
{
return
sentry
.
extensions
[
method
]
.
apply
(
this
args
)
;
}
logger
.
warn
(
"
Extension
method
"
+
method
+
"
couldn
'
t
be
found
doing
nothing
.
"
)
;
}
;
return
Hub
;
}
(
)
)
;
function
getMainCarrier
(
)
{
var
carrier
=
(
0
misc
.
Rf
)
(
)
;
carrier
.
__SENTRY__
=
carrier
.
__SENTRY__
|
|
{
extensions
:
{
}
hub
:
undefined
}
;
return
carrier
;
}
function
makeMain
(
hub
)
{
var
registry
=
getMainCarrier
(
)
;
var
oldHub
=
getHubFromCarrier
(
registry
)
;
setHubOnCarrier
(
registry
hub
)
;
return
oldHub
;
}
function
getCurrentHub
(
)
{
var
registry
=
getMainCarrier
(
)
;
if
(
!
hasHubOnCarrier
(
registry
)
|
|
getHubFromCarrier
(
registry
)
.
isOlderThan
(
API_VERSION
)
)
{
setHubOnCarrier
(
registry
new
Hub
(
)
)
;
}
if
(
(
0
node
.
KV
)
(
)
)
{
return
getHubFromActiveDomain
(
registry
)
;
}
return
getHubFromCarrier
(
registry
)
;
}
function
getActiveDomain
(
)
{
var
sentry
=
getMainCarrier
(
)
.
__SENTRY__
;
return
sentry
&
&
sentry
.
extensions
&
&
sentry
.
extensions
.
domain
&
&
sentry
.
extensions
.
domain
.
active
;
}
function
getHubFromActiveDomain
(
registry
)
{
try
{
var
activeDomain
=
getActiveDomain
(
)
;
if
(
!
activeDomain
)
{
return
getHubFromCarrier
(
registry
)
;
}
if
(
!
hasHubOnCarrier
(
activeDomain
)
|
|
getHubFromCarrier
(
activeDomain
)
.
isOlderThan
(
API_VERSION
)
)
{
var
registryHubTopStack
=
getHubFromCarrier
(
registry
)
.
getStackTop
(
)
;
setHubOnCarrier
(
activeDomain
new
Hub
(
registryHubTopStack
.
client
Scope
.
clone
(
registryHubTopStack
.
scope
)
)
)
;
}
return
getHubFromCarrier
(
activeDomain
)
;
}
catch
(
_Oo
)
{
return
getHubFromCarrier
(
registry
)
;
}
}
function
hasHubOnCarrier
(
carrier
)
{
return
!
!
(
carrier
&
&
carrier
.
__SENTRY__
&
&
carrier
.
__SENTRY__
.
hub
)
;
}
function
getHubFromCarrier
(
carrier
)
{
if
(
carrier
&
&
carrier
.
__SENTRY__
&
&
carrier
.
__SENTRY__
.
hub
)
return
carrier
.
__SENTRY__
.
hub
;
carrier
.
__SENTRY__
=
carrier
.
__SENTRY__
|
|
{
}
;
carrier
.
__SENTRY__
.
hub
=
new
Hub
(
)
;
return
carrier
.
__SENTRY__
.
hub
;
}
function
setHubOnCarrier
(
carrier
hub
)
{
if
(
!
carrier
)
return
false
;
carrier
.
__SENTRY__
=
carrier
.
__SENTRY__
|
|
{
}
;
carrier
.
__SENTRY__
.
hub
=
hub
;
return
true
;
}
;
function
callOnHub
(
method
)
{
var
args
=
[
]
;
for
(
var
_i
=
1
;
_i
<
arguments
.
length
;
_i
+
+
)
{
args
[
_i
-
1
]
=
arguments
[
_i
]
;
}
var
hub
=
getCurrentHub
(
)
;
if
(
hub
&
&
hub
[
method
]
)
{
return
hub
[
method
]
.
apply
(
hub
tslib_es6_spread
(
args
)
)
;
}
throw
new
Error
(
"
No
hub
defined
or
"
+
method
+
"
was
not
found
on
the
hub
please
open
a
bug
report
.
"
)
;
}
function
captureException
(
exception
captureContext
)
{
var
syntheticException
;
try
{
throw
new
Error
(
'
Sentry
syntheticException
'
)
;
}
catch
(
exception
)
{
syntheticException
=
exception
;
}
return
callOnHub
(
'
captureException
'
exception
{
captureContext
:
captureContext
originalException
:
exception
syntheticException
:
syntheticException
}
)
;
}
function
captureMessage
(
message
captureContext
)
{
var
syntheticException
;
try
{
throw
new
Error
(
message
)
;
}
catch
(
exception
)
{
syntheticException
=
exception
;
}
var
level
=
typeof
captureContext
=
=
=
'
string
'
?
captureContext
:
undefined
;
var
context
=
typeof
captureContext
!
=
=
'
string
'
?
{
captureContext
:
captureContext
}
:
undefined
;
return
callOnHub
(
'
captureMessage
'
message
level
__assign
(
{
originalException
:
message
syntheticException
:
syntheticException
}
context
)
)
;
}
function
captureEvent
(
event
)
{
return
callOnHub
(
'
captureEvent
'
event
)
;
}
function
configureScope
(
callback
)
{
callOnHub
(
'
configureScope
'
callback
)
;
}
function
addBreadcrumb
(
breadcrumb
)
{
callOnHub
(
'
addBreadcrumb
'
breadcrumb
)
;
}
function
setContext
(
name
context
)
{
callOnHub
(
'
setContext
'
name
context
)
;
}
function
setExtras
(
extras
)
{
callOnHub
(
'
setExtras
'
extras
)
;
}
function
setTags
(
tags
)
{
callOnHub
(
'
setTags
'
tags
)
;
}
function
setExtra
(
key
extra
)
{
callOnHub
(
'
setExtra
'
key
extra
)
;
}
function
setTag
(
key
value
)
{
callOnHub
(
'
setTag
'
key
value
)
;
}
function
setUser
(
user
)
{
callOnHub
(
'
setUser
'
user
)
;
}
function
withScope
(
callback
)
{
callOnHub
(
'
withScope
'
callback
)
;
}
function
_callOnClient
(
method
)
{
var
args
=
[
]
;
for
(
var
_i
=
1
;
_i
<
arguments
.
length
;
_i
+
+
)
{
args
[
_i
-
1
]
=
arguments
[
_i
]
;
}
callOnHub
.
apply
(
void
0
__spread
(
[
'
_invokeClient
'
method
]
args
)
)
;
}
function
startTransaction
(
context
customSamplingContext
)
{
return
callOnHub
(
'
startTransaction
'
__assign
(
{
}
context
)
customSamplingContext
)
;
}
;
var
setPrototypeOf
=
Object
.
setPrototypeOf
|
|
(
{
__proto__
:
[
]
}
instanceof
Array
?
setProtoOf
:
mixinProperties
)
;
function
setProtoOf
(
obj
proto
)
{
obj
.
__proto__
=
proto
;
return
obj
;
}
function
mixinProperties
(
obj
proto
)
{
for
(
var
prop
in
proto
)
{
if
(
!
obj
.
hasOwnProperty
(
prop
)
)
{
obj
[
prop
]
=
proto
[
prop
]
;
}
}
return
obj
;
}
;
var
SentryError
=
(
function
(
_super
)
{
__extends
(
SentryError
_super
)
;
function
SentryError
(
message
)
{
var
_newTarget
=
this
.
constructor
;
var
_this
=
_super
.
call
(
this
message
)
|
|
this
;
_this
.
message
=
message
;
_this
.
name
=
_newTarget
.
prototype
.
constructor
.
name
;
setPrototypeOf
(
_this
_newTarget
.
prototype
)
;
return
_this
;
}
return
SentryError
;
}
(
Error
)
)
;
;
var
DSN_REGEX
=
/
^
(
?
:
(
\
w
+
)
:
)
\
/
\
/
(
?
:
(
\
w
+
)
(
?
:
:
(
\
w
+
)
)
?
)
(
[
\
w
.
-
]
+
)
(
?
:
:
(
\
d
+
)
)
?
\
/
(
.
+
)
/
;
var
ERROR_MESSAGE
=
'
Invalid
Dsn
'
;
var
Dsn
=
(
function
(
)
{
function
Dsn
(
from
)
{
if
(
typeof
from
=
=
=
'
string
'
)
{
this
.
_fromString
(
from
)
;
}
else
{
this
.
_fromComponents
(
from
)
;
}
this
.
_validate
(
)
;
}
Dsn
.
prototype
.
toString
=
function
(
withPassword
)
{
if
(
withPassword
=
=
=
void
0
)
{
withPassword
=
false
;
}
var
_a
=
this
host
=
_a
.
host
path
=
_a
.
path
pass
=
_a
.
pass
port
=
_a
.
port
projectId
=
_a
.
projectId
protocol
=
_a
.
protocol
user
=
_a
.
user
;
return
(
protocol
+
"
:
/
/
"
+
user
+
(
withPassword
&
&
pass
?
"
:
"
+
pass
:
'
'
)
+
(
"
"
+
host
+
(
port
?
"
:
"
+
port
:
'
'
)
+
"
/
"
+
(
path
?
path
+
"
/
"
:
path
)
+
projectId
)
)
;
}
;
Dsn
.
prototype
.
_fromString
=
function
(
str
)
{
var
match
=
DSN_REGEX
.
exec
(
str
)
;
if
(
!
match
)
{
throw
new
SentryError
(
ERROR_MESSAGE
)
;
}
var
_a
=
__read
(
match
.
slice
(
1
)
6
)
protocol
=
_a
[
0
]
user
=
_a
[
1
]
_b
=
_a
[
2
]
pass
=
_b
=
=
=
void
0
?
'
'
:
_b
host
=
_a
[
3
]
_c
=
_a
[
4
]
port
=
_c
=
=
=
void
0
?
'
'
:
_c
lastPath
=
_a
[
5
]
;
var
path
=
'
'
;
var
projectId
=
lastPath
;
var
split
=
projectId
.
split
(
'
/
'
)
;
if
(
split
.
length
>
1
)
{
path
=
split
.
slice
(
0
-
1
)
.
join
(
'
/
'
)
;
projectId
=
split
.
pop
(
)
;
}
if
(
projectId
)
{
var
projectMatch
=
projectId
.
match
(
/
^
\
d
+
/
)
;
if
(
projectMatch
)
{
projectId
=
projectMatch
[
0
]
;
}
}
this
.
_fromComponents
(
{
host
:
host
pass
:
pass
path
:
path
projectId
:
projectId
port
:
port
protocol
:
protocol
user
:
user
}
)
;
}
;
Dsn
.
prototype
.
_fromComponents
=
function
(
components
)
{
this
.
protocol
=
components
.
protocol
;
this
.
user
=
components
.
user
;
this
.
pass
=
components
.
pass
|
|
'
'
;
this
.
host
=
components
.
host
;
this
.
port
=
components
.
port
|
|
'
'
;
this
.
path
=
components
.
path
|
|
'
'
;
this
.
projectId
=
components
.
projectId
;
}
;
Dsn
.
prototype
.
_validate
=
function
(
)
{
var
_this
=
this
;
[
'
protocol
'
'
user
'
'
host
'
'
projectId
'
]
.
forEach
(
function
(
component
)
{
if
(
!
_this
[
component
]
)
{
throw
new
SentryError
(
ERROR_MESSAGE
+
"
:
"
+
component
+
"
missing
"
)
;
}
}
)
;
if
(
!
this
.
projectId
.
match
(
/
^
\
d
+
/
)
)
{
throw
new
SentryError
(
ERROR_MESSAGE
+
"
:
Invalid
projectId
"
+
this
.
projectId
)
;
}
if
(
this
.
protocol
!
=
=
'
http
'
&
&
this
.
protocol
!
=
=
'
https
'
)
{
throw
new
SentryError
(
ERROR_MESSAGE
+
"
:
Invalid
protocol
"
+
this
.
protocol
)
;
}
if
(
this
.
port
&
&
isNaN
(
parseInt
(
this
.
port
10
)
)
)
{
throw
new
SentryError
(
ERROR_MESSAGE
+
"
:
Invalid
port
"
+
this
.
port
)
;
}
}
;
return
Dsn
;
}
(
)
)
;
;
var
installedIntegrations
=
[
]
;
function
getIntegrationsToSetup
(
options
)
{
var
defaultIntegrations
=
(
options
.
defaultIntegrations
&
&
tslib_es6_spread
(
options
.
defaultIntegrations
)
)
|
|
[
]
;
var
userIntegrations
=
options
.
integrations
;
var
integrations
=
[
]
;
if
(
Array
.
isArray
(
userIntegrations
)
)
{
var
userIntegrationsNames_1
=
userIntegrations
.
map
(
function
(
i
)
{
return
i
.
name
;
}
)
;
var
pickedIntegrationsNames_1
=
[
]
;
defaultIntegrations
.
forEach
(
function
(
defaultIntegration
)
{
if
(
userIntegrationsNames_1
.
indexOf
(
defaultIntegration
.
name
)
=
=
=
-
1
&
&
pickedIntegrationsNames_1
.
indexOf
(
defaultIntegration
.
name
)
=
=
=
-
1
)
{
integrations
.
push
(
defaultIntegration
)
;
pickedIntegrationsNames_1
.
push
(
defaultIntegration
.
name
)
;
}
}
)
;
userIntegrations
.
forEach
(
function
(
userIntegration
)
{
if
(
pickedIntegrationsNames_1
.
indexOf
(
userIntegration
.
name
)
=
=
=
-
1
)
{
integrations
.
push
(
userIntegration
)
;
pickedIntegrationsNames_1
.
push
(
userIntegration
.
name
)
;
}
}
)
;
}
else
if
(
typeof
userIntegrations
=
=
=
'
function
'
)
{
integrations
=
userIntegrations
(
defaultIntegrations
)
;
integrations
=
Array
.
isArray
(
integrations
)
?
integrations
:
[
integrations
]
;
}
else
{
integrations
=
tslib_es6_spread
(
defaultIntegrations
)
;
}
var
integrationsNames
=
integrations
.
map
(
function
(
i
)
{
return
i
.
name
;
}
)
;
var
alwaysLastToRun
=
'
Debug
'
;
if
(
integrationsNames
.
indexOf
(
alwaysLastToRun
)
!
=
=
-
1
)
{
integrations
.
push
.
apply
(
integrations
tslib_es6_spread
(
integrations
.
splice
(
integrationsNames
.
indexOf
(
alwaysLastToRun
)
1
)
)
)
;
}
return
integrations
;
}
function
setupIntegration
(
integration
)
{
if
(
installedIntegrations
.
indexOf
(
integration
.
name
)
!
=
=
-
1
)
{
return
;
}
integration
.
setupOnce
(
addGlobalEventProcessor
getCurrentHub
)
;
installedIntegrations
.
push
(
integration
.
name
)
;
logger
.
log
(
"
Integration
installed
:
"
+
integration
.
name
)
;
}
function
setupIntegrations
(
options
)
{
var
integrations
=
{
}
;
getIntegrationsToSetup
(
options
)
.
forEach
(
function
(
integration
)
{
integrations
[
integration
.
name
]
=
integration
;
setupIntegration
(
integration
)
;
}
)
;
return
integrations
;
}
;
var
BaseClient
=
(
function
(
)
{
function
BaseClient
(
backendClass
options
)
{
this
.
_integrations
=
{
}
;
this
.
_processing
=
0
;
this
.
_backend
=
new
backendClass
(
options
)
;
this
.
_options
=
options
;
if
(
options
.
dsn
)
{
this
.
_dsn
=
new
Dsn
(
options
.
dsn
)
;
}
}
BaseClient
.
prototype
.
captureException
=
function
(
exception
hint
scope
)
{
var
_this
=
this
;
var
eventId
=
hint
&
&
hint
.
event_id
;
this
.
_process
(
this
.
_getBackend
(
)
.
eventFromException
(
exception
hint
)
.
then
(
function
(
event
)
{
return
_this
.
_captureEvent
(
event
hint
scope
)
;
}
)
.
then
(
function
(
result
)
{
eventId
=
result
;
}
)
)
;
return
eventId
;
}
;
BaseClient
.
prototype
.
captureMessage
=
function
(
message
level
hint
scope
)
{
var
_this
=
this
;
var
eventId
=
hint
&
&
hint
.
event_id
;
var
promisedEvent
=
isPrimitive
(
message
)
?
this
.
_getBackend
(
)
.
eventFromMessage
(
"
"
+
message
level
hint
)
:
this
.
_getBackend
(
)
.
eventFromException
(
message
hint
)
;
this
.
_process
(
promisedEvent
.
then
(
function
(
event
)
{
return
_this
.
_captureEvent
(
event
hint
scope
)
;
}
)
.
then
(
function
(
result
)
{
eventId
=
result
;
}
)
)
;
return
eventId
;
}
;
BaseClient
.
prototype
.
captureEvent
=
function
(
event
hint
scope
)
{
var
eventId
=
hint
&
&
hint
.
event_id
;
this
.
_process
(
this
.
_captureEvent
(
event
hint
scope
)
.
then
(
function
(
result
)
{
eventId
=
result
;
}
)
)
;
return
eventId
;
}
;
BaseClient
.
prototype
.
captureSession
=
function
(
session
)
{
if
(
!
session
.
release
)
{
logger
.
warn
(
'
Discarded
session
because
of
missing
release
'
)
;
}
else
{
this
.
_sendSession
(
session
)
;
}
}
;
BaseClient
.
prototype
.
getDsn
=
function
(
)
{
return
this
.
_dsn
;
}
;
BaseClient
.
prototype
.
getOptions
=
function
(
)
{
return
this
.
_options
;
}
;
BaseClient
.
prototype
.
flush
=
function
(
timeout
)
{
var
_this
=
this
;
return
this
.
_isClientProcessing
(
timeout
)
.
then
(
function
(
ready
)
{
return
_this
.
_getBackend
(
)
.
getTransport
(
)
.
close
(
timeout
)
.
then
(
function
(
transportFlushed
)
{
return
ready
&
&
transportFlushed
;
}
)
;
}
)
;
}
;
BaseClient
.
prototype
.
close
=
function
(
timeout
)
{
var
_this
=
this
;
return
this
.
flush
(
timeout
)
.
then
(
function
(
result
)
{
_this
.
getOptions
(
)
.
enabled
=
false
;
return
result
;
}
)
;
}
;
BaseClient
.
prototype
.
setupIntegrations
=
function
(
)
{
if
(
this
.
_isEnabled
(
)
)
{
this
.
_integrations
=
setupIntegrations
(
this
.
_options
)
;
}
}
;
BaseClient
.
prototype
.
getIntegration
=
function
(
integration
)
{
try
{
return
this
.
_integrations
[
integration
.
id
]
|
|
null
;
}
catch
(
_oO
)
{
logger
.
warn
(
"
Cannot
retrieve
integration
"
+
integration
.
id
+
"
from
the
current
Client
"
)
;
return
null
;
}
}
;
BaseClient
.
prototype
.
_updateSessionFromEvent
=
function
(
session
event
)
{
var
e_1
_a
;
var
crashed
=
false
;
var
errored
=
false
;
var
userAgent
;
var
exceptions
=
event
.
exception
&
&
event
.
exception
.
values
;
if
(
exceptions
)
{
errored
=
true
;
try
{
for
(
var
exceptions_1
=
__values
(
exceptions
)
exceptions_1_1
=
exceptions_1
.
next
(
)
;
!
exceptions_1_1
.
done
;
exceptions_1_1
=
exceptions_1
.
next
(
)
)
{
var
ex
=
exceptions_1_1
.
value
;
var
mechanism
=
ex
.
mechanism
;
if
(
mechanism
&
&
mechanism
.
handled
=
=
=
false
)
{
crashed
=
true
;
break
;
}
}
}
catch
(
e_1_1
)
{
e_1
=
{
error
:
e_1_1
}
;
}
finally
{
try
{
if
(
exceptions_1_1
&
&
!
exceptions_1_1
.
done
&
&
(
_a
=
exceptions_1
.
return
)
)
_a
.
call
(
exceptions_1
)
;
}
finally
{
if
(
e_1
)
throw
e_1
.
error
;
}
}
}
var
user
=
event
.
user
;
if
(
!
session
.
userAgent
)
{
var
headers
=
event
.
request
?
event
.
request
.
headers
:
{
}
;
for
(
var
key
in
headers
)
{
if
(
key
.
toLowerCase
(
)
=
=
=
'
user
-
agent
'
)
{
userAgent
=
headers
[
key
]
;
break
;
}
}
}
session
.
update
(
__assign
(
__assign
(
{
}
(
crashed
&
&
{
status
:
SessionStatus
.
Crashed
}
)
)
{
user
:
user
userAgent
:
userAgent
errors
:
session
.
errors
+
Number
(
errored
|
|
crashed
)
}
)
)
;
}
;
BaseClient
.
prototype
.
_sendSession
=
function
(
session
)
{
this
.
_getBackend
(
)
.
sendSession
(
session
)
;
}
;
BaseClient
.
prototype
.
_isClientProcessing
=
function
(
timeout
)
{
var
_this
=
this
;
return
new
SyncPromise
(
function
(
resolve
)
{
var
ticked
=
0
;
var
tick
=
1
;
var
interval
=
setInterval
(
function
(
)
{
if
(
_this
.
_processing
=
=
0
)
{
clearInterval
(
interval
)
;
resolve
(
true
)
;
}
else
{
ticked
+
=
tick
;
if
(
timeout
&
&
ticked
>
=
timeout
)
{
clearInterval
(
interval
)
;
resolve
(
false
)
;
}
}
}
tick
)
;
}
)
;
}
;
BaseClient
.
prototype
.
_getBackend
=
function
(
)
{
return
this
.
_backend
;
}
;
BaseClient
.
prototype
.
_isEnabled
=
function
(
)
{
return
this
.
getOptions
(
)
.
enabled
!
=
=
false
&
&
this
.
_dsn
!
=
=
undefined
;
}
;
BaseClient
.
prototype
.
_prepareEvent
=
function
(
event
scope
hint
)
{
var
_this
=
this
;
var
_a
=
this
.
getOptions
(
)
.
normalizeDepth
normalizeDepth
=
_a
=
=
=
void
0
?
3
:
_a
;
var
prepared
=
__assign
(
__assign
(
{
}
event
)
{
event_id
:
event
.
event_id
|
|
(
hint
&
&
hint
.
event_id
?
hint
.
event_id
:
(
0
misc
.
DM
)
(
)
)
timestamp
:
event
.
timestamp
|
|
(
0
time
.
yW
)
(
)
}
)
;
this
.
_applyClientOptions
(
prepared
)
;
this
.
_applyIntegrationsMetadata
(
prepared
)
;
var
finalScope
=
scope
;
if
(
hint
&
&
hint
.
captureContext
)
{
finalScope
=
Scope
.
clone
(
finalScope
)
.
update
(
hint
.
captureContext
)
;
}
var
result
=
SyncPromise
.
resolve
(
prepared
)
;
if
(
finalScope
)
{
result
=
finalScope
.
applyToEvent
(
prepared
hint
)
;
}
return
result
.
then
(
function
(
evt
)
{
if
(
typeof
normalizeDepth
=
=
=
'
number
'
&
&
normalizeDepth
>
0
)
{
return
_this
.
_normalizeEvent
(
evt
normalizeDepth
)
;
}
return
evt
;
}
)
;
}
;
BaseClient
.
prototype
.
_normalizeEvent
=
function
(
event
depth
)
{
if
(
!
event
)
{
return
null
;
}
var
normalized
=
__assign
(
__assign
(
__assign
(
__assign
(
__assign
(
{
}
event
)
(
event
.
breadcrumbs
&
&
{
breadcrumbs
:
event
.
breadcrumbs
.
map
(
function
(
b
)
{
return
(
__assign
(
__assign
(
{
}
b
)
(
b
.
data
&
&
{
data
:
normalize
(
b
.
data
depth
)
}
)
)
)
;
}
)
}
)
)
(
event
.
user
&
&
{
user
:
normalize
(
event
.
user
depth
)
}
)
)
(
event
.
contexts
&
&
{
contexts
:
normalize
(
event
.
contexts
depth
)
}
)
)
(
event
.
extra
&
&
{
extra
:
normalize
(
event
.
extra
depth
)
}
)
)
;
if
(
event
.
contexts
&
&
event
.
contexts
.
trace
)
{
normalized
.
contexts
.
trace
=
event
.
contexts
.
trace
;
}
return
normalized
;
}
;
BaseClient
.
prototype
.
_applyClientOptions
=
function
(
event
)
{
var
options
=
this
.
getOptions
(
)
;
var
environment
=
options
.
environment
release
=
options
.
release
dist
=
options
.
dist
_a
=
options
.
maxValueLength
maxValueLength
=
_a
=
=
=
void
0
?
250
:
_a
;
if
(
!
(
'
environment
'
in
event
)
)
{
event
.
environment
=
'
environment
'
in
options
?
environment
:
'
production
'
;
}
if
(
event
.
release
=
=
=
undefined
&
&
release
!
=
=
undefined
)
{
event
.
release
=
release
;
}
if
(
event
.
dist
=
=
=
undefined
&
&
dist
!
=
=
undefined
)
{
event
.
dist
=
dist
;
}
if
(
event
.
message
)
{
event
.
message
=
truncate
(
event
.
message
maxValueLength
)
;
}
var
exception
=
event
.
exception
&
&
event
.
exception
.
values
&
&
event
.
exception
.
values
[
0
]
;
if
(
exception
&
&
exception
.
value
)
{
exception
.
value
=
truncate
(
exception
.
value
maxValueLength
)
;
}
var
request
=
event
.
request
;
if
(
request
&
&
request
.
url
)
{
request
.
url
=
truncate
(
request
.
url
maxValueLength
)
;
}
}
;
BaseClient
.
prototype
.
_applyIntegrationsMetadata
=
function
(
event
)
{
var
sdkInfo
=
event
.
sdk
;
var
integrationsArray
=
Object
.
keys
(
this
.
_integrations
)
;
if
(
sdkInfo
&
&
integrationsArray
.
length
>
0
)
{
sdkInfo
.
integrations
=
integrationsArray
;
}
}
;
BaseClient
.
prototype
.
_sendEvent
=
function
(
event
)
{
this
.
_getBackend
(
)
.
sendEvent
(
event
)
;
}
;
BaseClient
.
prototype
.
_captureEvent
=
function
(
event
hint
scope
)
{
return
this
.
_processEvent
(
event
hint
scope
)
.
then
(
function
(
finalEvent
)
{
return
finalEvent
.
event_id
;
}
function
(
reason
)
{
logger
.
error
(
reason
)
;
return
undefined
;
}
)
;
}
;
BaseClient
.
prototype
.
_processEvent
=
function
(
event
hint
scope
)
{
var
_this
=
this
;
var
_a
=
this
.
getOptions
(
)
beforeSend
=
_a
.
beforeSend
sampleRate
=
_a
.
sampleRate
;
if
(
!
this
.
_isEnabled
(
)
)
{
return
SyncPromise
.
reject
(
new
SentryError
(
'
SDK
not
enabled
will
not
send
event
.
'
)
)
;
}
var
isTransaction
=
event
.
type
=
=
=
'
transaction
'
;
if
(
!
isTransaction
&
&
typeof
sampleRate
=
=
=
'
number
'
&
&
Math
.
random
(
)
>
sampleRate
)
{
return
SyncPromise
.
reject
(
new
SentryError
(
'
This
event
has
been
sampled
will
not
send
event
.
'
)
)
;
}
return
this
.
_prepareEvent
(
event
scope
hint
)
.
then
(
function
(
prepared
)
{
if
(
prepared
=
=
=
null
)
{
throw
new
SentryError
(
'
An
event
processor
returned
null
will
not
send
event
.
'
)
;
}
var
isInternalException
=
hint
&
&
hint
.
data
&
&
hint
.
data
.
__sentry__
=
=
=
true
;
if
(
isInternalException
|
|
isTransaction
|
|
!
beforeSend
)
{
return
prepared
;
}
var
beforeSendResult
=
beforeSend
(
prepared
hint
)
;
if
(
typeof
beforeSendResult
=
=
=
'
undefined
'
)
{
throw
new
SentryError
(
'
beforeSend
method
has
to
return
null
or
a
valid
event
.
'
)
;
}
else
if
(
isThenable
(
beforeSendResult
)
)
{
return
beforeSendResult
.
then
(
function
(
event
)
{
return
event
;
}
function
(
e
)
{
throw
new
SentryError
(
"
beforeSend
rejected
with
"
+
e
)
;
}
)
;
}
return
beforeSendResult
;
}
)
.
then
(
function
(
processedEvent
)
{
if
(
processedEvent
=
=
=
null
)
{
throw
new
SentryError
(
'
beforeSend
returned
null
will
not
send
event
.
'
)
;
}
var
session
=
scope
&
&
scope
.
getSession
(
)
;
if
(
!
isTransaction
&
&
session
)
{
_this
.
_updateSessionFromEvent
(
session
processedEvent
)
;
}
_this
.
_sendEvent
(
processedEvent
)
;
return
processedEvent
;
}
)
.
then
(
null
function
(
reason
)
{
if
(
reason
instanceof
SentryError
)
{
throw
reason
;
}
_this
.
captureException
(
reason
{
data
:
{
__sentry__
:
true
}
originalException
:
reason
}
)
;
throw
new
SentryError
(
"
Event
processing
pipeline
threw
an
error
original
event
will
not
be
sent
.
Details
have
been
sent
as
a
new
event
.
\
nReason
:
"
+
reason
)
;
}
)
;
}
;
BaseClient
.
prototype
.
_process
=
function
(
promise
)
{
var
_this
=
this
;
this
.
_processing
+
=
1
;
promise
.
then
(
function
(
value
)
{
_this
.
_processing
-
=
1
;
return
value
;
}
function
(
reason
)
{
_this
.
_processing
-
=
1
;
return
reason
;
}
)
;
}
;
return
BaseClient
;
}
(
)
)
;
;
var
NoopTransport
=
(
function
(
)
{
function
NoopTransport
(
)
{
}
NoopTransport
.
prototype
.
sendEvent
=
function
(
_
)
{
return
SyncPromise
.
resolve
(
{
reason
:
"
NoopTransport
:
Event
has
been
skipped
because
no
Dsn
is
configured
.
"
status
:
Status
.
Skipped
}
)
;
}
;
NoopTransport
.
prototype
.
close
=
function
(
_
)
{
return
SyncPromise
.
resolve
(
true
)
;
}
;
return
NoopTransport
;
}
(
)
)
;
;
var
BaseBackend
=
(
function
(
)
{
function
BaseBackend
(
options
)
{
this
.
_options
=
options
;
if
(
!
this
.
_options
.
dsn
)
{
logger
.
warn
(
'
No
DSN
provided
backend
will
not
do
anything
.
'
)
;
}
this
.
_transport
=
this
.
_setupTransport
(
)
;
}
BaseBackend
.
prototype
.
eventFromException
=
function
(
_exception
_hint
)
{
throw
new
SentryError
(
'
Backend
has
to
implement
eventFromException
method
'
)
;
}
;
BaseBackend
.
prototype
.
eventFromMessage
=
function
(
_message
_level
_hint
)
{
throw
new
SentryError
(
'
Backend
has
to
implement
eventFromMessage
method
'
)
;
}
;
BaseBackend
.
prototype
.
sendEvent
=
function
(
event
)
{
this
.
_transport
.
sendEvent
(
event
)
.
then
(
null
function
(
reason
)
{
logger
.
error
(
"
Error
while
sending
event
:
"
+
reason
)
;
}
)
;
}
;
BaseBackend
.
prototype
.
sendSession
=
function
(
session
)
{
if
(
!
this
.
_transport
.
sendSession
)
{
logger
.
warn
(
"
Dropping
session
because
custom
transport
doesn
'
t
implement
sendSession
"
)
;
return
;
}
this
.
_transport
.
sendSession
(
session
)
.
then
(
null
function
(
reason
)
{
logger
.
error
(
"
Error
while
sending
session
:
"
+
reason
)
;
}
)
;
}
;
BaseBackend
.
prototype
.
getTransport
=
function
(
)
{
return
this
.
_transport
;
}
;
BaseBackend
.
prototype
.
_setupTransport
=
function
(
)
{
return
new
NoopTransport
(
)
;
}
;
return
BaseBackend
;
}
(
)
)
;
;
function
supportsErrorEvent
(
)
{
try
{
new
ErrorEvent
(
'
'
)
;
return
true
;
}
catch
(
e
)
{
return
false
;
}
}
function
supportsDOMError
(
)
{
try
{
new
DOMError
(
'
'
)
;
return
true
;
}
catch
(
e
)
{
return
false
;
}
}
function
supportsDOMException
(
)
{
try
{
new
DOMException
(
'
'
)
;
return
true
;
}
catch
(
e
)
{
return
false
;
}
}
function
supportsFetch
(
)
{
if
(
!
(
'
fetch
'
in
(
0
misc
.
Rf
)
(
)
)
)
{
return
false
;
}
try
{
new
Headers
(
)
;
new
Request
(
'
'
)
;
new
Response
(
)
;
return
true
;
}
catch
(
e
)
{
return
false
;
}
}
function
isNativeFetch
(
func
)
{
return
func
&
&
/
^
function
fetch
\
(
\
)
\
s
+
\
{
\
s
+
\
[
native
code
\
]
\
s
+
\
}
/
.
test
(
func
.
toString
(
)
)
;
}
function
supportsNativeFetch
(
)
{
if
(
!
supportsFetch
(
)
)
{
return
false
;
}
var
global
=
(
0
misc
.
Rf
)
(
)
;
if
(
isNativeFetch
(
global
.
fetch
)
)
{
return
true
;
}
var
result
=
false
;
var
doc
=
global
.
document
;
if
(
doc
&
&
typeof
doc
.
createElement
=
=
=
"
function
"
)
{
try
{
var
sandbox
=
doc
.
createElement
(
'
iframe
'
)
;
sandbox
.
hidden
=
true
;
doc
.
head
.
appendChild
(
sandbox
)
;
if
(
sandbox
.
contentWindow
&
&
sandbox
.
contentWindow
.
fetch
)
{
result
=
isNativeFetch
(
sandbox
.
contentWindow
.
fetch
)
;
}
doc
.
head
.
removeChild
(
sandbox
)
;
}
catch
(
err
)
{
logger
.
warn
(
'
Could
not
create
sandbox
iframe
for
pure
fetch
check
bailing
to
window
.
fetch
:
'
err
)
;
}
}
return
result
;
}
function
supportsReportingObserver
(
)
{
return
'
ReportingObserver
'
in
getGlobalObject
(
)
;
}
function
supportsReferrerPolicy
(
)
{
if
(
!
supportsFetch
(
)
)
{
return
false
;
}
try
{
new
Request
(
'
_
'
{
referrerPolicy
:
'
origin
'
}
)
;
return
true
;
}
catch
(
e
)
{
return
false
;
}
}
function
supportsHistory
(
)
{
var
global
=
(
0
misc
.
Rf
)
(
)
;
var
chrome
=
global
.
chrome
;
var
isChromePackagedApp
=
chrome
&
&
chrome
.
app
&
&
chrome
.
app
.
runtime
;
var
hasHistoryApi
=
'
history
'
in
global
&
&
!
!
global
.
history
.
pushState
&
&
!
!
global
.
history
.
replaceState
;
return
!
isChromePackagedApp
&
&
hasHistoryApi
;
}
;
var
UNKNOWN_FUNCTION
=
'
?
'
;
var
chrome
=
/
^
\
s
*
at
(
?
:
(
.
*
?
)
?
\
(
)
?
(
(
?
:
file
|
https
?
|
blob
|
chrome
-
extension
|
address
|
native
|
eval
|
webpack
|
<
anonymous
>
|
[
-
a
-
z
]
+
:
|
.
*
bundle
|
\
/
)
.
*
?
)
(
?
:
:
(
\
d
+
)
)
?
(
?
:
:
(
\
d
+
)
)
?
\
)
?
\
s
*
/
i
;
var
gecko
=
/
^
\
s
*
(
.
*
?
)
(
?
:
\
(
(
.
*
?
)
\
)
)
?
(
?
:
^
|
)
?
(
(
?
:
file
|
https
?
|
blob
|
chrome
|
webpack
|
resource
|
moz
-
extension
|
capacitor
)
.
*
?
:
\
/
.
*
?
|
\
[
native
code
\
]
|
[
^
]
*
(
?
:
bundle
|
\
d
+
\
.
js
)
)
(
?
:
:
(
\
d
+
)
)
?
(
?
:
:
(
\
d
+
)
)
?
\
s
*
/
i
;
var
winjs
=
/
^
\
s
*
at
(
?
:
(
(
?
:
\
[
object
object
\
]
)
?
.
+
)
)
?
\
(
?
(
(
?
:
file
|
ms
-
appx
|
https
?
|
webpack
|
blob
)
:
.
*
?
)
:
(
\
d
+
)
(
?
:
:
(
\
d
+
)
)
?
\
)
?
\
s
*
/
i
;
var
geckoEval
=
/
(
\
S
+
)
line
(
\
d
+
)
(
?
:
>
eval
line
\
d
+
)
*
>
eval
/
i
;
var
chromeEval
=
/
\
(
(
\
S
*
)
(
?
:
:
(
\
d
+
)
)
(
?
:
:
(
\
d
+
)
)
\
)
/
;
var
reactMinifiedRegexp
=
/
Minified
React
error
#
\
d
+
;
/
i
;
function
computeStackTrace
(
ex
)
{
var
stack
=
null
;
var
popSize
=
0
;
if
(
ex
)
{
if
(
typeof
ex
.
framesToPop
=
=
=
'
number
'
)
{
popSize
=
ex
.
framesToPop
;
}
else
if
(
reactMinifiedRegexp
.
test
(
ex
.
message
)
)
{
popSize
=
1
;
}
}
try
{
stack
=
computeStackTraceFromStacktraceProp
(
ex
)
;
if
(
stack
)
{
return
popFrames
(
stack
popSize
)
;
}
}
catch
(
e
)
{
}
try
{
stack
=
computeStackTraceFromStackProp
(
ex
)
;
if
(
stack
)
{
return
popFrames
(
stack
popSize
)
;
}
}
catch
(
e
)
{
}
return
{
message
:
extractMessage
(
ex
)
name
:
ex
&
&
ex
.
name
stack
:
[
]
failed
:
true
}
;
}
function
computeStackTraceFromStackProp
(
ex
)
{
if
(
!
ex
|
|
!
ex
.
stack
)
{
return
null
;
}
var
stack
=
[
]
;
var
lines
=
ex
.
stack
.
split
(
'
\
n
'
)
;
var
isEval
;
var
submatch
;
var
parts
;
var
element
;
for
(
var
i
=
0
;
i
<
lines
.
length
;
+
+
i
)
{
if
(
(
parts
=
chrome
.
exec
(
lines
[
i
]
)
)
)
{
var
isNative
=
parts
[
2
]
&
&
parts
[
2
]
.
indexOf
(
'
native
'
)
=
=
=
0
;
isEval
=
parts
[
2
]
&
&
parts
[
2
]
.
indexOf
(
'
eval
'
)
=
=
=
0
;
if
(
isEval
&
&
(
submatch
=
chromeEval
.
exec
(
parts
[
2
]
)
)
)
{
parts
[
2
]
=
submatch
[
1
]
;
parts
[
3
]
=
submatch
[
2
]
;
parts
[
4
]
=
submatch
[
3
]
;
}
element
=
{
url
:
parts
[
2
]
&
&
parts
[
2
]
.
indexOf
(
'
address
at
'
)
=
=
=
0
?
parts
[
2
]
.
substr
(
'
address
at
'
.
length
)
:
parts
[
2
]
func
:
parts
[
1
]
|
|
UNKNOWN_FUNCTION
args
:
isNative
?
[
parts
[
2
]
]
:
[
]
line
:
parts
[
3
]
?
+
parts
[
3
]
:
null
column
:
parts
[
4
]
?
+
parts
[
4
]
:
null
}
;
}
else
if
(
(
parts
=
winjs
.
exec
(
lines
[
i
]
)
)
)
{
element
=
{
url
:
parts
[
2
]
func
:
parts
[
1
]
|
|
UNKNOWN_FUNCTION
args
:
[
]
line
:
+
parts
[
3
]
column
:
parts
[
4
]
?
+
parts
[
4
]
:
null
}
;
}
else
if
(
(
parts
=
gecko
.
exec
(
lines
[
i
]
)
)
)
{
isEval
=
parts
[
3
]
&
&
parts
[
3
]
.
indexOf
(
'
>
eval
'
)
>
-
1
;
if
(
isEval
&
&
(
submatch
=
geckoEval
.
exec
(
parts
[
3
]
)
)
)
{
parts
[
1
]
=
parts
[
1
]
|
|
"
eval
"
;
parts
[
3
]
=
submatch
[
1
]
;
parts
[
4
]
=
submatch
[
2
]
;
parts
[
5
]
=
'
'
;
}
else
if
(
i
=
=
=
0
&
&
!
parts
[
5
]
&
&
ex
.
columnNumber
!
=
=
void
0
)
{
stack
[
0
]
.
column
=
ex
.
columnNumber
+
1
;
}
element
=
{
url
:
parts
[
3
]
func
:
parts
[
1
]
|
|
UNKNOWN_FUNCTION
args
:
parts
[
2
]
?
parts
[
2
]
.
split
(
'
'
)
:
[
]
line
:
parts
[
4
]
?
+
parts
[
4
]
:
null
column
:
parts
[
5
]
?
+
parts
[
5
]
:
null
}
;
}
else
{
continue
;
}
if
(
!
element
.
func
&
&
element
.
line
)
{
element
.
func
=
UNKNOWN_FUNCTION
;
}
stack
.
push
(
element
)
;
}
if
(
!
stack
.
length
)
{
return
null
;
}
return
{
message
:
extractMessage
(
ex
)
name
:
ex
.
name
stack
:
stack
}
;
}
function
computeStackTraceFromStacktraceProp
(
ex
)
{
if
(
!
ex
|
|
!
ex
.
stacktrace
)
{
return
null
;
}
var
stacktrace
=
ex
.
stacktrace
;
var
opera10Regex
=
/
line
(
\
d
+
)
.
*
script
(
?
:
in
)
?
(
\
S
+
)
(
?
:
:
in
function
(
\
S
+
)
)
?
/
i
;
var
opera11Regex
=
/
line
(
\
d
+
)
column
(
\
d
+
)
\
s
*
(
?
:
in
(
?
:
<
anonymous
function
:
(
[
^
>
]
+
)
>
|
(
[
^
)
]
+
)
)
\
(
(
.
*
)
\
)
)
?
in
(
.
*
)
:
\
s
*
/
i
;
var
lines
=
stacktrace
.
split
(
'
\
n
'
)
;
var
stack
=
[
]
;
var
parts
;
for
(
var
line
=
0
;
line
<
lines
.
length
;
line
+
=
2
)
{
var
element
=
null
;
if
(
(
parts
=
opera10Regex
.
exec
(
lines
[
line
]
)
)
)
{
element
=
{
url
:
parts
[
2
]
func
:
parts
[
3
]
args
:
[
]
line
:
+
parts
[
1
]
column
:
null
}
;
}
else
if
(
(
parts
=
opera11Regex
.
exec
(
lines
[
line
]
)
)
)
{
element
=
{
url
:
parts
[
6
]
func
:
parts
[
3
]
|
|
parts
[
4
]
args
:
parts
[
5
]
?
parts
[
5
]
.
split
(
'
'
)
:
[
]
line
:
+
parts
[
1
]
column
:
+
parts
[
2
]
}
;
}
if
(
element
)
{
if
(
!
element
.
func
&
&
element
.
line
)
{
element
.
func
=
UNKNOWN_FUNCTION
;
}
stack
.
push
(
element
)
;
}
}
if
(
!
stack
.
length
)
{
return
null
;
}
return
{
message
:
extractMessage
(
ex
)
name
:
ex
.
name
stack
:
stack
}
;
}
function
popFrames
(
stacktrace
popSize
)
{
try
{
return
__assign
(
__assign
(
{
}
stacktrace
)
{
stack
:
stacktrace
.
stack
.
slice
(
popSize
)
}
)
;
}
catch
(
e
)
{
return
stacktrace
;
}
}
function
extractMessage
(
ex
)
{
var
message
=
ex
&
&
ex
.
message
;
if
(
!
message
)
{
return
'
No
error
message
'
;
}
if
(
message
.
error
&
&
typeof
message
.
error
.
message
=
=
=
'
string
'
)
{
return
message
.
error
.
message
;
}
return
message
;
}
;
var
STACKTRACE_LIMIT
=
50
;
function
exceptionFromStacktrace
(
stacktrace
)
{
var
frames
=
prepareFramesForEvent
(
stacktrace
.
stack
)
;
var
exception
=
{
type
:
stacktrace
.
name
value
:
stacktrace
.
message
}
;
if
(
frames
&
&
frames
.
length
)
{
exception
.
stacktrace
=
{
frames
:
frames
}
;
}
if
(
exception
.
type
=
=
=
undefined
&
&
exception
.
value
=
=
=
'
'
)
{
exception
.
value
=
'
Unrecoverable
error
caught
'
;
}
return
exception
;
}
function
eventFromPlainObject
(
exception
syntheticException
rejection
)
{
var
event
=
{
exception
:
{
values
:
[
{
type
:
isEvent
(
exception
)
?
exception
.
constructor
.
name
:
rejection
?
'
UnhandledRejection
'
:
'
Error
'
value
:
"
Non
-
Error
"
+
(
rejection
?
'
promise
rejection
'
:
'
exception
'
)
+
"
captured
with
keys
:
"
+
extractExceptionKeysForMessage
(
exception
)
}
]
}
extra
:
{
__serialized__
:
normalizeToSize
(
exception
)
}
}
;
if
(
syntheticException
)
{
var
stacktrace
=
computeStackTrace
(
syntheticException
)
;
var
frames_1
=
prepareFramesForEvent
(
stacktrace
.
stack
)
;
event
.
stacktrace
=
{
frames
:
frames_1
}
;
}
return
event
;
}
function
eventFromStacktrace
(
stacktrace
)
{
var
exception
=
exceptionFromStacktrace
(
stacktrace
)
;
return
{
exception
:
{
values
:
[
exception
]
}
}
;
}
function
prepareFramesForEvent
(
stack
)
{
if
(
!
stack
|
|
!
stack
.
length
)
{
return
[
]
;
}
var
localStack
=
stack
;
var
firstFrameFunction
=
localStack
[
0
]
.
func
|
|
'
'
;
var
lastFrameFunction
=
localStack
[
localStack
.
length
-
1
]
.
func
|
|
'
'
;
if
(
firstFrameFunction
.
indexOf
(
'
captureMessage
'
)
!
=
=
-
1
|
|
firstFrameFunction
.
indexOf
(
'
captureException
'
)
!
=
=
-
1
)
{
localStack
=
localStack
.
slice
(
1
)
;
}
if
(
lastFrameFunction
.
indexOf
(
'
sentryWrapped
'
)
!
=
=
-
1
)
{
localStack
=
localStack
.
slice
(
0
-
1
)
;
}
return
localStack
.
slice
(
0
STACKTRACE_LIMIT
)
.
map
(
function
(
frame
)
{
return
(
{
colno
:
frame
.
column
=
=
=
null
?
undefined
:
frame
.
column
filename
:
frame
.
url
|
|
localStack
[
0
]
.
url
function
:
frame
.
func
|
|
'
?
'
in_app
:
true
lineno
:
frame
.
line
=
=
=
null
?
undefined
:
frame
.
line
}
)
;
}
)
.
reverse
(
)
;
}
;
function
eventFromException
(
options
exception
hint
)
{
var
syntheticException
=
(
hint
&
&
hint
.
syntheticException
)
|
|
undefined
;
var
event
=
eventFromUnknownInput
(
exception
syntheticException
{
attachStacktrace
:
options
.
attachStacktrace
}
)
;
(
0
misc
.
EG
)
(
event
{
handled
:
true
type
:
'
generic
'
}
)
;
event
.
level
=
Severity
.
Error
;
if
(
hint
&
&
hint
.
event_id
)
{
event
.
event_id
=
hint
.
event_id
;
}
return
SyncPromise
.
resolve
(
event
)
;
}
function
eventFromMessage
(
options
message
level
hint
)
{
if
(
level
=
=
=
void
0
)
{
level
=
Severity
.
Info
;
}
var
syntheticException
=
(
hint
&
&
hint
.
syntheticException
)
|
|
undefined
;
var
event
=
eventFromString
(
message
syntheticException
{
attachStacktrace
:
options
.
attachStacktrace
}
)
;
event
.
level
=
level
;
if
(
hint
&
&
hint
.
event_id
)
{
event
.
event_id
=
hint
.
event_id
;
}
return
SyncPromise
.
resolve
(
event
)
;
}
function
eventFromUnknownInput
(
exception
syntheticException
options
)
{
if
(
options
=
=
=
void
0
)
{
options
=
{
}
;
}
var
event
;
if
(
isErrorEvent
(
exception
)
&
&
exception
.
error
)
{
var
errorEvent
=
exception
;
exception
=
errorEvent
.
error
;
event
=
eventFromStacktrace
(
computeStackTrace
(
exception
)
)
;
return
event
;
}
if
(
isDOMError
(
exception
)
|
|
isDOMException
(
exception
)
)
{
var
domException
=
exception
;
var
name_1
=
domException
.
name
|
|
(
isDOMError
(
domException
)
?
'
DOMError
'
:
'
DOMException
'
)
;
var
message
=
domException
.
message
?
name_1
+
"
:
"
+
domException
.
message
:
name_1
;
event
=
eventFromString
(
message
syntheticException
options
)
;
(
0
misc
.
Db
)
(
event
message
)
;
return
event
;
}
if
(
isError
(
exception
)
)
{
event
=
eventFromStacktrace
(
computeStackTrace
(
exception
)
)
;
return
event
;
}
if
(
isPlainObject
(
exception
)
|
|
isEvent
(
exception
)
)
{
var
objectException
=
exception
;
event
=
eventFromPlainObject
(
objectException
syntheticException
options
.
rejection
)
;
(
0
misc
.
EG
)
(
event
{
synthetic
:
true
}
)
;
return
event
;
}
event
=
eventFromString
(
exception
syntheticException
options
)
;
(
0
misc
.
Db
)
(
event
"
"
+
exception
undefined
)
;
(
0
misc
.
EG
)
(
event
{
synthetic
:
true
}
)
;
return
event
;
}
function
eventFromString
(
input
syntheticException
options
)
{
if
(
options
=
=
=
void
0
)
{
options
=
{
}
;
}
var
event
=
{
message
:
input
}
;
if
(
options
.
attachStacktrace
&
&
syntheticException
)
{
var
stacktrace
=
computeStackTrace
(
syntheticException
)
;
var
frames_1
=
prepareFramesForEvent
(
stacktrace
.
stack
)
;
event
.
stacktrace
=
{
frames
:
frames_1
}
;
}
return
event
;
}
;
function
sessionToSentryRequest
(
session
api
)
{
var
envelopeHeaders
=
JSON
.
stringify
(
{
sent_at
:
new
Date
(
)
.
toISOString
(
)
}
)
;
var
itemHeaders
=
JSON
.
stringify
(
{
type
:
'
session
'
}
)
;
return
{
body
:
envelopeHeaders
+
"
\
n
"
+
itemHeaders
+
"
\
n
"
+
JSON
.
stringify
(
session
)
type
:
'
session
'
url
:
api
.
getEnvelopeEndpointWithUrlEncodedAuth
(
)
}
;
}
function
eventToSentryRequest
(
event
api
)
{
var
useEnvelope
=
event
.
type
=
=
=
'
transaction
'
;
var
req
=
{
body
:
JSON
.
stringify
(
event
)
type
:
event
.
type
|
|
'
event
'
url
:
useEnvelope
?
api
.
getEnvelopeEndpointWithUrlEncodedAuth
(
)
:
api
.
getStoreEndpointWithUrlEncodedAuth
(
)
}
;
if
(
useEnvelope
)
{
var
envelopeHeaders
=
JSON
.
stringify
(
{
event_id
:
event
.
event_id
sent_at
:
new
Date
(
)
.
toISOString
(
)
}
)
;
var
itemHeaders
=
JSON
.
stringify
(
{
type
:
event
.
type
}
)
;
var
envelope
=
envelopeHeaders
+
"
\
n
"
+
itemHeaders
+
"
\
n
"
+
req
.
body
;
req
.
body
=
envelope
;
}
return
req
;
}
;
var
SENTRY_API_VERSION
=
'
7
'
;
var
API
=
(
function
(
)
{
function
API
(
dsn
)
{
this
.
dsn
=
dsn
;
this
.
_dsnObject
=
new
Dsn
(
dsn
)
;
}
API
.
prototype
.
getDsn
=
function
(
)
{
return
this
.
_dsnObject
;
}
;
API
.
prototype
.
getBaseApiEndpoint
=
function
(
)
{
var
dsn
=
this
.
_dsnObject
;
var
protocol
=
dsn
.
protocol
?
dsn
.
protocol
+
"
:
"
:
'
'
;
var
port
=
dsn
.
port
?
"
:
"
+
dsn
.
port
:
'
'
;
return
protocol
+
"
/
/
"
+
dsn
.
host
+
port
+
(
dsn
.
path
?
"
/
"
+
dsn
.
path
:
'
'
)
+
"
/
api
/
"
;
}
;
API
.
prototype
.
getStoreEndpoint
=
function
(
)
{
return
this
.
_getIngestEndpoint
(
'
store
'
)
;
}
;
API
.
prototype
.
getStoreEndpointWithUrlEncodedAuth
=
function
(
)
{
return
this
.
getStoreEndpoint
(
)
+
"
?
"
+
this
.
_encodedAuth
(
)
;
}
;
API
.
prototype
.
getEnvelopeEndpointWithUrlEncodedAuth
=
function
(
)
{
return
this
.
_getEnvelopeEndpoint
(
)
+
"
?
"
+
this
.
_encodedAuth
(
)
;
}
;
API
.
prototype
.
getStoreEndpointPath
=
function
(
)
{
var
dsn
=
this
.
_dsnObject
;
return
(
dsn
.
path
?
"
/
"
+
dsn
.
path
:
'
'
)
+
"
/
api
/
"
+
dsn
.
projectId
+
"
/
store
/
"
;
}
;
API
.
prototype
.
getRequestHeaders
=
function
(
clientName
clientVersion
)
{
var
dsn
=
this
.
_dsnObject
;
var
header
=
[
"
Sentry
sentry_version
=
"
+
SENTRY_API_VERSION
]
;
header
.
push
(
"
sentry_client
=
"
+
clientName
+
"
/
"
+
clientVersion
)
;
header
.
push
(
"
sentry_key
=
"
+
dsn
.
user
)
;
if
(
dsn
.
pass
)
{
header
.
push
(
"
sentry_secret
=
"
+
dsn
.
pass
)
;
}
return
{
'
Content
-
Type
'
:
'
application
/
json
'
'
X
-
Sentry
-
Auth
'
:
header
.
join
(
'
'
)
}
;
}
;
API
.
prototype
.
getReportDialogEndpoint
=
function
(
dialogOptions
)
{
if
(
dialogOptions
=
=
=
void
0
)
{
dialogOptions
=
{
}
;
}
var
dsn
=
this
.
_dsnObject
;
var
endpoint
=
this
.
getBaseApiEndpoint
(
)
+
"
embed
/
error
-
page
/
"
;
var
encodedOptions
=
[
]
;
encodedOptions
.
push
(
"
dsn
=
"
+
dsn
.
toString
(
)
)
;
for
(
var
key
in
dialogOptions
)
{
if
(
key
=
=
=
'
user
'
)
{
if
(
!
dialogOptions
.
user
)
{
continue
;
}
if
(
dialogOptions
.
user
.
name
)
{
encodedOptions
.
push
(
"
name
=
"
+
encodeURIComponent
(
dialogOptions
.
user
.
name
)
)
;
}
if
(
dialogOptions
.
user
.
email
)
{
encodedOptions
.
push
(
"
email
=
"
+
encodeURIComponent
(
dialogOptions
.
user
.
email
)
)
;
}
}
else
{
encodedOptions
.
push
(
encodeURIComponent
(
key
)
+
"
=
"
+
encodeURIComponent
(
dialogOptions
[
key
]
)
)
;
}
}
if
(
encodedOptions
.
length
)
{
return
endpoint
+
"
?
"
+
encodedOptions
.
join
(
'
&
'
)
;
}
return
endpoint
;
}
;
API
.
prototype
.
_getEnvelopeEndpoint
=
function
(
)
{
return
this
.
_getIngestEndpoint
(
'
envelope
'
)
;
}
;
API
.
prototype
.
_getIngestEndpoint
=
function
(
target
)
{
var
base
=
this
.
getBaseApiEndpoint
(
)
;
var
dsn
=
this
.
_dsnObject
;
return
"
"
+
base
+
dsn
.
projectId
+
"
/
"
+
target
+
"
/
"
;
}
;
API
.
prototype
.
_encodedAuth
=
function
(
)
{
var
dsn
=
this
.
_dsnObject
;
var
auth
=
{
sentry_key
:
dsn
.
user
sentry_version
:
SENTRY_API_VERSION
}
;
return
urlEncode
(
auth
)
;
}
;
return
API
;
}
(
)
)
;
;
var
PromiseBuffer
=
(
function
(
)
{
function
PromiseBuffer
(
_limit
)
{
this
.
_limit
=
_limit
;
this
.
_buffer
=
[
]
;
}
PromiseBuffer
.
prototype
.
isReady
=
function
(
)
{
return
this
.
_limit
=
=
=
undefined
|
|
this
.
length
(
)
<
this
.
_limit
;
}
;
PromiseBuffer
.
prototype
.
add
=
function
(
task
)
{
var
_this
=
this
;
if
(
!
this
.
isReady
(
)
)
{
return
SyncPromise
.
reject
(
new
SentryError
(
'
Not
adding
Promise
due
to
buffer
limit
reached
.
'
)
)
;
}
if
(
this
.
_buffer
.
indexOf
(
task
)
=
=
=
-
1
)
{
this
.
_buffer
.
push
(
task
)
;
}
task
.
then
(
function
(
)
{
return
_this
.
remove
(
task
)
;
}
)
.
then
(
null
function
(
)
{
return
_this
.
remove
(
task
)
.
then
(
null
function
(
)
{
}
)
;
}
)
;
return
task
;
}
;
PromiseBuffer
.
prototype
.
remove
=
function
(
task
)
{
var
removedTask
=
this
.
_buffer
.
splice
(
this
.
_buffer
.
indexOf
(
task
)
1
)
[
0
]
;
return
removedTask
;
}
;
PromiseBuffer
.
prototype
.
length
=
function
(
)
{
return
this
.
_buffer
.
length
;
}
;
PromiseBuffer
.
prototype
.
drain
=
function
(
timeout
)
{
var
_this
=
this
;
return
new
SyncPromise
(
function
(
resolve
)
{
var
capturedSetTimeout
=
setTimeout
(
function
(
)
{
if
(
timeout
&
&
timeout
>
0
)
{
resolve
(
false
)
;
}
}
timeout
)
;
SyncPromise
.
all
(
_this
.
_buffer
)
.
then
(
function
(
)
{
clearTimeout
(
capturedSetTimeout
)
;
resolve
(
true
)
;
}
)
.
then
(
null
function
(
)
{
resolve
(
true
)
;
}
)
;
}
)
;
}
;
return
PromiseBuffer
;
}
(
)
)
;
;
var
BaseTransport
=
(
function
(
)
{
function
BaseTransport
(
options
)
{
this
.
options
=
options
;
this
.
_buffer
=
new
PromiseBuffer
(
30
)
;
this
.
_rateLimits
=
{
}
;
this
.
_api
=
new
API
(
this
.
options
.
dsn
)
;
this
.
url
=
this
.
_api
.
getStoreEndpointWithUrlEncodedAuth
(
)
;
}
BaseTransport
.
prototype
.
sendEvent
=
function
(
_
)
{
throw
new
SentryError
(
'
Transport
Class
has
to
implement
sendEvent
method
'
)
;
}
;
BaseTransport
.
prototype
.
close
=
function
(
timeout
)
{
return
this
.
_buffer
.
drain
(
timeout
)
;
}
;
BaseTransport
.
prototype
.
_handleResponse
=
function
(
_a
)
{
var
requestType
=
_a
.
requestType
response
=
_a
.
response
headers
=
_a
.
headers
resolve
=
_a
.
resolve
reject
=
_a
.
reject
;
var
status
=
Status
.
fromHttpCode
(
response
.
status
)
;
var
limited
=
this
.
_handleRateLimit
(
headers
)
;
if
(
limited
)
logger
.
warn
(
"
Too
many
requests
backing
off
till
:
"
+
this
.
_disabledUntil
(
requestType
)
)
;
if
(
status
=
=
=
Status
.
Success
)
{
resolve
(
{
status
:
status
}
)
;
return
;
}
reject
(
response
)
;
}
;
BaseTransport
.
prototype
.
_disabledUntil
=
function
(
category
)
{
return
this
.
_rateLimits
[
category
]
|
|
this
.
_rateLimits
.
all
;
}
;
BaseTransport
.
prototype
.
_isRateLimited
=
function
(
category
)
{
return
this
.
_disabledUntil
(
category
)
>
new
Date
(
Date
.
now
(
)
)
;
}
;
BaseTransport
.
prototype
.
_handleRateLimit
=
function
(
headers
)
{
var
e_1
_a
e_2
_b
;
var
now
=
Date
.
now
(
)
;
var
rlHeader
=
headers
[
'
x
-
sentry
-
rate
-
limits
'
]
;
var
raHeader
=
headers
[
'
retry
-
after
'
]
;
if
(
rlHeader
)
{
try
{
for
(
var
_c
=
__values
(
rlHeader
.
trim
(
)
.
split
(
'
'
)
)
_d
=
_c
.
next
(
)
;
!
_d
.
done
;
_d
=
_c
.
next
(
)
)
{
var
limit
=
_d
.
value
;
var
parameters
=
limit
.
split
(
'
:
'
2
)
;
var
headerDelay
=
parseInt
(
parameters
[
0
]
10
)
;
var
delay
=
(
!
isNaN
(
headerDelay
)
?
headerDelay
:
60
)
*
1000
;
try
{
for
(
var
_e
=
(
e_2
=
void
0
__values
(
parameters
[
1
]
.
split
(
'
;
'
)
)
)
_f
=
_e
.
next
(
)
;
!
_f
.
done
;
_f
=
_e
.
next
(
)
)
{
var
category
=
_f
.
value
;
this
.
_rateLimits
[
category
|
|
'
all
'
]
=
new
Date
(
now
+
delay
)
;
}
}
catch
(
e_2_1
)
{
e_2
=
{
error
:
e_2_1
}
;
}
finally
{
try
{
if
(
_f
&
&
!
_f
.
done
&
&
(
_b
=
_e
.
return
)
)
_b
.
call
(
_e
)
;
}
finally
{
if
(
e_2
)
throw
e_2
.
error
;
}
}
}
}
catch
(
e_1_1
)
{
e_1
=
{
error
:
e_1_1
}
;
}
finally
{
try
{
if
(
_d
&
&
!
_d
.
done
&
&
(
_a
=
_c
.
return
)
)
_a
.
call
(
_c
)
;
}
finally
{
if
(
e_1
)
throw
e_1
.
error
;
}
}
return
true
;
}
else
if
(
raHeader
)
{
this
.
_rateLimits
.
all
=
new
Date
(
now
+
(
0
misc
.
JY
)
(
now
raHeader
)
)
;
return
true
;
}
return
false
;
}
;
return
BaseTransport
;
}
(
)
)
;
;
var
fetch_global
=
(
0
misc
.
Rf
)
(
)
;
var
FetchTransport
=
(
function
(
_super
)
{
__extends
(
FetchTransport
_super
)
;
function
FetchTransport
(
)
{
return
_super
!
=
=
null
&
&
_super
.
apply
(
this
arguments
)
|
|
this
;
}
FetchTransport
.
prototype
.
sendEvent
=
function
(
event
)
{
return
this
.
_sendRequest
(
eventToSentryRequest
(
event
this
.
_api
)
event
)
;
}
;
FetchTransport
.
prototype
.
sendSession
=
function
(
session
)
{
return
this
.
_sendRequest
(
sessionToSentryRequest
(
session
this
.
_api
)
session
)
;
}
;
FetchTransport
.
prototype
.
_sendRequest
=
function
(
sentryRequest
originalPayload
)
{
var
_this
=
this
;
if
(
this
.
_isRateLimited
(
sentryRequest
.
type
)
)
{
return
Promise
.
reject
(
{
event
:
originalPayload
type
:
sentryRequest
.
type
reason
:
"
Transport
locked
till
"
+
this
.
_disabledUntil
(
sentryRequest
.
type
)
+
"
due
to
too
many
requests
.
"
status
:
429
}
)
;
}
var
options
=
{
body
:
sentryRequest
.
body
method
:
'
POST
'
referrerPolicy
:
(
supportsReferrerPolicy
(
)
?
'
origin
'
:
'
'
)
}
;
if
(
this
.
options
.
fetchParameters
!
=
=
undefined
)
{
Object
.
assign
(
options
this
.
options
.
fetchParameters
)
;
}
if
(
this
.
options
.
headers
!
=
=
undefined
)
{
options
.
headers
=
this
.
options
.
headers
;
}
return
this
.
_buffer
.
add
(
new
SyncPromise
(
function
(
resolve
reject
)
{
fetch_global
.
fetch
(
sentryRequest
.
url
options
)
.
then
(
function
(
response
)
{
var
headers
=
{
'
x
-
sentry
-
rate
-
limits
'
:
response
.
headers
.
get
(
'
X
-
Sentry
-
Rate
-
Limits
'
)
'
retry
-
after
'
:
response
.
headers
.
get
(
'
Retry
-
After
'
)
}
;
_this
.
_handleResponse
(
{
requestType
:
sentryRequest
.
type
response
:
response
headers
:
headers
resolve
:
resolve
reject
:
reject
}
)
;
}
)
.
catch
(
reject
)
;
}
)
)
;
}
;
return
FetchTransport
;
}
(
BaseTransport
)
)
;
;
var
XHRTransport
=
(
function
(
_super
)
{
__extends
(
XHRTransport
_super
)
;
function
XHRTransport
(
)
{
return
_super
!
=
=
null
&
&
_super
.
apply
(
this
arguments
)
|
|
this
;
}
XHRTransport
.
prototype
.
sendEvent
=
function
(
event
)
{
return
this
.
_sendRequest
(
eventToSentryRequest
(
event
this
.
_api
)
event
)
;
}
;
XHRTransport
.
prototype
.
sendSession
=
function
(
session
)
{
return
this
.
_sendRequest
(
sessionToSentryRequest
(
session
this
.
_api
)
session
)
;
}
;
XHRTransport
.
prototype
.
_sendRequest
=
function
(
sentryRequest
originalPayload
)
{
var
_this
=
this
;
if
(
this
.
_isRateLimited
(
sentryRequest
.
type
)
)
{
return
Promise
.
reject
(
{
event
:
originalPayload
type
:
sentryRequest
.
type
reason
:
"
Transport
locked
till
"
+
this
.
_disabledUntil
(
sentryRequest
.
type
)
+
"
due
to
too
many
requests
.
"
status
:
429
}
)
;
}
return
this
.
_buffer
.
add
(
new
SyncPromise
(
function
(
resolve
reject
)
{
var
request
=
new
XMLHttpRequest
(
)
;
request
.
onreadystatechange
=
function
(
)
{
if
(
request
.
readyState
=
=
=
4
)
{
var
headers
=
{
'
x
-
sentry
-
rate
-
limits
'
:
request
.
getResponseHeader
(
'
X
-
Sentry
-
Rate
-
Limits
'
)
'
retry
-
after
'
:
request
.
getResponseHeader
(
'
Retry
-
After
'
)
}
;
_this
.
_handleResponse
(
{
requestType
:
sentryRequest
.
type
response
:
request
headers
:
headers
resolve
:
resolve
reject
:
reject
}
)
;
}
}
;
request
.
open
(
'
POST
'
sentryRequest
.
url
)
;
for
(
var
header
in
_this
.
options
.
headers
)
{
if
(
_this
.
options
.
headers
.
hasOwnProperty
(
header
)
)
{
request
.
setRequestHeader
(
header
_this
.
options
.
headers
[
header
]
)
;
}
}
request
.
send
(
sentryRequest
.
body
)
;
}
)
)
;
}
;
return
XHRTransport
;
}
(
BaseTransport
)
)
;
;
var
BrowserBackend
=
(
function
(
_super
)
{
__extends
(
BrowserBackend
_super
)
;
function
BrowserBackend
(
)
{
return
_super
!
=
=
null
&
&
_super
.
apply
(
this
arguments
)
|
|
this
;
}
BrowserBackend
.
prototype
.
eventFromException
=
function
(
exception
hint
)
{
return
eventFromException
(
this
.
_options
exception
hint
)
;
}
;
BrowserBackend
.
prototype
.
eventFromMessage
=
function
(
message
level
hint
)
{
if
(
level
=
=
=
void
0
)
{
level
=
Severity
.
Info
;
}
return
eventFromMessage
(
this
.
_options
message
level
hint
)
;
}
;
BrowserBackend
.
prototype
.
_setupTransport
=
function
(
)
{
if
(
!
this
.
_options
.
dsn
)
{
return
_super
.
prototype
.
_setupTransport
.
call
(
this
)
;
}
var
transportOptions
=
__assign
(
__assign
(
{
}
this
.
_options
.
transportOptions
)
{
dsn
:
this
.
_options
.
dsn
}
)
;
if
(
this
.
_options
.
transport
)
{
return
new
this
.
_options
.
transport
(
transportOptions
)
;
}
if
(
supportsFetch
(
)
)
{
return
new
FetchTransport
(
transportOptions
)
;
}
return
new
XHRTransport
(
transportOptions
)
;
}
;
return
BrowserBackend
;
}
(
BaseBackend
)
)
;
;
var
ignoreOnError
=
0
;
function
shouldIgnoreOnError
(
)
{
return
ignoreOnError
>
0
;
}
function
ignoreNextOnError
(
)
{
ignoreOnError
+
=
1
;
setTimeout
(
function
(
)
{
ignoreOnError
-
=
1
;
}
)
;
}
function
wrap
(
fn
options
before
)
{
if
(
options
=
=
=
void
0
)
{
options
=
{
}
;
}
if
(
typeof
fn
!
=
=
'
function
'
)
{
return
fn
;
}
try
{
if
(
fn
.
__sentry__
)
{
return
fn
;
}
if
(
fn
.
__sentry_wrapped__
)
{
return
fn
.
__sentry_wrapped__
;
}
}
catch
(
e
)
{
return
fn
;
}
var
sentryWrapped
=
function
(
)
{
var
args
=
Array
.
prototype
.
slice
.
call
(
arguments
)
;
try
{
if
(
before
&
&
typeof
before
=
=
=
'
function
'
)
{
before
.
apply
(
this
arguments
)
;
}
var
wrappedArguments
=
args
.
map
(
function
(
arg
)
{
return
wrap
(
arg
options
)
;
}
)
;
if
(
fn
.
handleEvent
)
{
return
fn
.
handleEvent
.
apply
(
this
wrappedArguments
)
;
}
return
fn
.
apply
(
this
wrappedArguments
)
;
}
catch
(
ex
)
{
ignoreNextOnError
(
)
;
withScope
(
function
(
scope
)
{
scope
.
addEventProcessor
(
function
(
event
)
{
var
processedEvent
=
__assign
(
{
}
event
)
;
if
(
options
.
mechanism
)
{
(
0
misc
.
Db
)
(
processedEvent
undefined
undefined
)
;
(
0
misc
.
EG
)
(
processedEvent
options
.
mechanism
)
;
}
processedEvent
.
extra
=
__assign
(
__assign
(
{
}
processedEvent
.
extra
)
{
arguments
:
args
}
)
;
return
processedEvent
;
}
)
;
captureException
(
ex
)
;
}
)
;
throw
ex
;
}
}
;
try
{
for
(
var
property
in
fn
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
fn
property
)
)
{
sentryWrapped
[
property
]
=
fn
[
property
]
;
}
}
}
catch
(
_oO
)
{
}
fn
.
prototype
=
fn
.
prototype
|
|
{
}
;
sentryWrapped
.
prototype
=
fn
.
prototype
;
Object
.
defineProperty
(
fn
'
__sentry_wrapped__
'
{
enumerable
:
false
value
:
sentryWrapped
}
)
;
Object
.
defineProperties
(
sentryWrapped
{
__sentry__
:
{
enumerable
:
false
value
:
true
}
__sentry_original__
:
{
enumerable
:
false
value
:
fn
}
}
)
;
try
{
var
descriptor
=
Object
.
getOwnPropertyDescriptor
(
sentryWrapped
'
name
'
)
;
if
(
descriptor
.
configurable
)
{
Object
.
defineProperty
(
sentryWrapped
'
name
'
{
get
:
function
(
)
{
return
fn
.
name
;
}
}
)
;
}
}
catch
(
_oO
)
{
}
return
sentryWrapped
;
}
function
injectReportDialog
(
options
)
{
if
(
options
=
=
=
void
0
)
{
options
=
{
}
;
}
if
(
!
options
.
eventId
)
{
logger
.
error
(
"
Missing
eventId
option
in
showReportDialog
call
"
)
;
return
;
}
if
(
!
options
.
dsn
)
{
logger
.
error
(
"
Missing
dsn
option
in
showReportDialog
call
"
)
;
return
;
}
var
script
=
document
.
createElement
(
'
script
'
)
;
script
.
async
=
true
;
script
.
src
=
new
API
(
options
.
dsn
)
.
getReportDialogEndpoint
(
options
)
;
if
(
options
.
onLoad
)
{
script
.
onload
=
options
.
onLoad
;
}
(
document
.
head
|
|
document
.
body
)
.
appendChild
(
script
)
;
}
;
var
instrument_global
=
(
0
misc
.
Rf
)
(
)
;
var
handlers
=
{
}
;
var
instrumented
=
{
}
;
function
instrument
(
type
)
{
if
(
instrumented
[
type
]
)
{
return
;
}
instrumented
[
type
]
=
true
;
switch
(
type
)
{
case
'
console
'
:
instrumentConsole
(
)
;
break
;
case
'
dom
'
:
instrumentDOM
(
)
;
break
;
case
'
xhr
'
:
instrumentXHR
(
)
;
break
;
case
'
fetch
'
:
instrumentFetch
(
)
;
break
;
case
'
history
'
:
instrumentHistory
(
)
;
break
;
case
'
error
'
:
instrumentError
(
)
;
break
;
case
'
unhandledrejection
'
:
instrumentUnhandledRejection
(
)
;
break
;
default
:
logger
.
warn
(
'
unknown
instrumentation
type
:
'
type
)
;
}
}
function
addInstrumentationHandler
(
handler
)
{
if
(
!
handler
|
|
typeof
handler
.
type
!
=
=
'
string
'
|
|
typeof
handler
.
callback
!
=
=
'
function
'
)
{
return
;
}
handlers
[
handler
.
type
]
=
handlers
[
handler
.
type
]
|
|
[
]
;
handlers
[
handler
.
type
]
.
push
(
handler
.
callback
)
;
instrument
(
handler
.
type
)
;
}
function
triggerHandlers
(
type
data
)
{
var
e_1
_a
;
if
(
!
type
|
|
!
handlers
[
type
]
)
{
return
;
}
try
{
for
(
var
_b
=
__values
(
handlers
[
type
]
|
|
[
]
)
_c
=
_b
.
next
(
)
;
!
_c
.
done
;
_c
=
_b
.
next
(
)
)
{
var
handler
=
_c
.
value
;
try
{
handler
(
data
)
;
}
catch
(
e
)
{
logger
.
error
(
"
Error
while
triggering
instrumentation
handler
.
\
nType
:
"
+
type
+
"
\
nName
:
"
+
getFunctionName
(
handler
)
+
"
\
nError
:
"
+
e
)
;
}
}
}
catch
(
e_1_1
)
{
e_1
=
{
error
:
e_1_1
}
;
}
finally
{
try
{
if
(
_c
&
&
!
_c
.
done
&
&
(
_a
=
_b
.
return
)
)
_a
.
call
(
_b
)
;
}
finally
{
if
(
e_1
)
throw
e_1
.
error
;
}
}
}
function
instrumentConsole
(
)
{
if
(
!
(
'
console
'
in
instrument_global
)
)
{
return
;
}
[
'
debug
'
'
info
'
'
warn
'
'
error
'
'
log
'
'
assert
'
]
.
forEach
(
function
(
level
)
{
if
(
!
(
level
in
instrument_global
.
console
)
)
{
return
;
}
fill
(
instrument_global
.
console
level
function
(
originalConsoleLevel
)
{
return
function
(
)
{
var
args
=
[
]
;
for
(
var
_i
=
0
;
_i
<
arguments
.
length
;
_i
+
+
)
{
args
[
_i
]
=
arguments
[
_i
]
;
}
triggerHandlers
(
'
console
'
{
args
:
args
level
:
level
}
)
;
if
(
originalConsoleLevel
)
{
Function
.
prototype
.
apply
.
call
(
originalConsoleLevel
instrument_global
.
console
args
)
;
}
}
;
}
)
;
}
)
;
}
function
instrumentFetch
(
)
{
if
(
!
supportsNativeFetch
(
)
)
{
return
;
}
fill
(
instrument_global
'
fetch
'
function
(
originalFetch
)
{
return
function
(
)
{
var
args
=
[
]
;
for
(
var
_i
=
0
;
_i
<
arguments
.
length
;
_i
+
+
)
{
args
[
_i
]
=
arguments
[
_i
]
;
}
var
handlerData
=
{
args
:
args
fetchData
:
{
method
:
getFetchMethod
(
args
)
url
:
getFetchUrl
(
args
)
}
startTimestamp
:
Date
.
now
(
)
}
;
triggerHandlers
(
'
fetch
'
__assign
(
{
}
handlerData
)
)
;
return
originalFetch
.
apply
(
instrument_global
args
)
.
then
(
function
(
response
)
{
triggerHandlers
(
'
fetch
'
__assign
(
__assign
(
{
}
handlerData
)
{
endTimestamp
:
Date
.
now
(
)
response
:
response
}
)
)
;
return
response
;
}
function
(
error
)
{
triggerHandlers
(
'
fetch
'
__assign
(
__assign
(
{
}
handlerData
)
{
endTimestamp
:
Date
.
now
(
)
error
:
error
}
)
)
;
throw
error
;
}
)
;
}
;
}
)
;
}
function
getFetchMethod
(
fetchArgs
)
{
if
(
fetchArgs
=
=
=
void
0
)
{
fetchArgs
=
[
]
;
}
if
(
'
Request
'
in
instrument_global
&
&
isInstanceOf
(
fetchArgs
[
0
]
Request
)
&
&
fetchArgs
[
0
]
.
method
)
{
return
String
(
fetchArgs
[
0
]
.
method
)
.
toUpperCase
(
)
;
}
if
(
fetchArgs
[
1
]
&
&
fetchArgs
[
1
]
.
method
)
{
return
String
(
fetchArgs
[
1
]
.
method
)
.
toUpperCase
(
)
;
}
return
'
GET
'
;
}
function
getFetchUrl
(
fetchArgs
)
{
if
(
fetchArgs
=
=
=
void
0
)
{
fetchArgs
=
[
]
;
}
if
(
typeof
fetchArgs
[
0
]
=
=
=
'
string
'
)
{
return
fetchArgs
[
0
]
;
}
if
(
'
Request
'
in
instrument_global
&
&
isInstanceOf
(
fetchArgs
[
0
]
Request
)
)
{
return
fetchArgs
[
0
]
.
url
;
}
return
String
(
fetchArgs
[
0
]
)
;
}
function
instrumentXHR
(
)
{
if
(
!
(
'
XMLHttpRequest
'
in
instrument_global
)
)
{
return
;
}
var
requestKeys
=
[
]
;
var
requestValues
=
[
]
;
var
xhrproto
=
XMLHttpRequest
.
prototype
;
fill
(
xhrproto
'
open
'
function
(
originalOpen
)
{
return
function
(
)
{
var
args
=
[
]
;
for
(
var
_i
=
0
;
_i
<
arguments
.
length
;
_i
+
+
)
{
args
[
_i
]
=
arguments
[
_i
]
;
}
var
xhr
=
this
;
var
url
=
args
[
1
]
;
xhr
.
__sentry_xhr__
=
{
method
:
isString
(
args
[
0
]
)
?
args
[
0
]
.
toUpperCase
(
)
:
args
[
0
]
url
:
args
[
1
]
}
;
if
(
isString
(
url
)
&
&
xhr
.
__sentry_xhr__
.
method
=
=
=
'
POST
'
&
&
url
.
match
(
/
sentry_key
/
)
)
{
xhr
.
__sentry_own_request__
=
true
;
}
var
onreadystatechangeHandler
=
function
(
)
{
if
(
xhr
.
readyState
=
=
=
4
)
{
try
{
if
(
xhr
.
__sentry_xhr__
)
{
xhr
.
__sentry_xhr__
.
status_code
=
xhr
.
status
;
}
}
catch
(
e
)
{
}
try
{
var
requestPos
=
requestKeys
.
indexOf
(
xhr
)
;
if
(
requestPos
!
=
=
-
1
)
{
requestKeys
.
splice
(
requestPos
)
;
var
args_1
=
requestValues
.
splice
(
requestPos
)
[
0
]
;
if
(
xhr
.
__sentry_xhr__
&
&
args_1
[
0
]
!
=
=
undefined
)
{
xhr
.
__sentry_xhr__
.
body
=
args_1
[
0
]
;
}
}
}
catch
(
e
)
{
}
triggerHandlers
(
'
xhr
'
{
args
:
args
endTimestamp
:
Date
.
now
(
)
startTimestamp
:
Date
.
now
(
)
xhr
:
xhr
}
)
;
}
}
;
if
(
'
onreadystatechange
'
in
xhr
&
&
typeof
xhr
.
onreadystatechange
=
=
=
'
function
'
)
{
fill
(
xhr
'
onreadystatechange
'
function
(
original
)
{
return
function
(
)
{
var
readyStateArgs
=
[
]
;
for
(
var
_i
=
0
;
_i
<
arguments
.
length
;
_i
+
+
)
{
readyStateArgs
[
_i
]
=
arguments
[
_i
]
;
}
onreadystatechangeHandler
(
)
;
return
original
.
apply
(
xhr
readyStateArgs
)
;
}
;
}
)
;
}
else
{
xhr
.
addEventListener
(
'
readystatechange
'
onreadystatechangeHandler
)
;
}
return
originalOpen
.
apply
(
xhr
args
)
;
}
;
}
)
;
fill
(
xhrproto
'
send
'
function
(
originalSend
)
{
return
function
(
)
{
var
args
=
[
]
;
for
(
var
_i
=
0
;
_i
<
arguments
.
length
;
_i
+
+
)
{
args
[
_i
]
=
arguments
[
_i
]
;
}
requestKeys
.
push
(
this
)
;
requestValues
.
push
(
args
)
;
triggerHandlers
(
'
xhr
'
{
args
:
args
startTimestamp
:
Date
.
now
(
)
xhr
:
this
}
)
;
return
originalSend
.
apply
(
this
args
)
;
}
;
}
)
;
}
var
lastHref
;
function
instrumentHistory
(
)
{
if
(
!
supportsHistory
(
)
)
{
return
;
}
var
oldOnPopState
=
instrument_global
.
onpopstate
;
instrument_global
.
onpopstate
=
function
(
)
{
var
args
=
[
]
;
for
(
var
_i
=
0
;
_i
<
arguments
.
length
;
_i
+
+
)
{
args
[
_i
]
=
arguments
[
_i
]
;
}
var
to
=
instrument_global
.
location
.
href
;
var
from
=
lastHref
;
lastHref
=
to
;
triggerHandlers
(
'
history
'
{
from
:
from
to
:
to
}
)
;
if
(
oldOnPopState
)
{
return
oldOnPopState
.
apply
(
this
args
)
;
}
}
;
function
historyReplacementFunction
(
originalHistoryFunction
)
{
return
function
(
)
{
var
args
=
[
]
;
for
(
var
_i
=
0
;
_i
<
arguments
.
length
;
_i
+
+
)
{
args
[
_i
]
=
arguments
[
_i
]
;
}
var
url
=
args
.
length
>
2
?
args
[
2
]
:
undefined
;
if
(
url
)
{
var
from
=
lastHref
;
var
to
=
String
(
url
)
;
lastHref
=
to
;
triggerHandlers
(
'
history
'
{
from
:
from
to
:
to
}
)
;
}
return
originalHistoryFunction
.
apply
(
this
args
)
;
}
;
}
fill
(
instrument_global
.
history
'
pushState
'
historyReplacementFunction
)
;
fill
(
instrument_global
.
history
'
replaceState
'
historyReplacementFunction
)
;
}
function
instrumentDOM
(
)
{
if
(
!
(
'
document
'
in
instrument_global
)
)
{
return
;
}
instrument_global
.
document
.
addEventListener
(
'
click
'
domEventHandler
(
'
click
'
triggerHandlers
.
bind
(
null
'
dom
'
)
)
false
)
;
instrument_global
.
document
.
addEventListener
(
'
keypress
'
keypressEventHandler
(
triggerHandlers
.
bind
(
null
'
dom
'
)
)
false
)
;
[
'
EventTarget
'
'
Node
'
]
.
forEach
(
function
(
target
)
{
var
proto
=
instrument_global
[
target
]
&
&
instrument_global
[
target
]
.
prototype
;
if
(
!
proto
|
|
!
proto
.
hasOwnProperty
|
|
!
proto
.
hasOwnProperty
(
'
addEventListener
'
)
)
{
return
;
}
fill
(
proto
'
addEventListener
'
function
(
original
)
{
return
function
(
eventName
fn
options
)
{
if
(
fn
&
&
fn
.
handleEvent
)
{
if
(
eventName
=
=
=
'
click
'
)
{
fill
(
fn
'
handleEvent
'
function
(
innerOriginal
)
{
return
function
(
event
)
{
domEventHandler
(
'
click
'
triggerHandlers
.
bind
(
null
'
dom
'
)
)
(
event
)
;
return
innerOriginal
.
call
(
this
event
)
;
}
;
}
)
;
}
if
(
eventName
=
=
=
'
keypress
'
)
{
fill
(
fn
'
handleEvent
'
function
(
innerOriginal
)
{
return
function
(
event
)
{
keypressEventHandler
(
triggerHandlers
.
bind
(
null
'
dom
'
)
)
(
event
)
;
return
innerOriginal
.
call
(
this
event
)
;
}
;
}
)
;
}
}
else
{
if
(
eventName
=
=
=
'
click
'
)
{
domEventHandler
(
'
click
'
triggerHandlers
.
bind
(
null
'
dom
'
)
true
)
(
this
)
;
}
if
(
eventName
=
=
=
'
keypress
'
)
{
keypressEventHandler
(
triggerHandlers
.
bind
(
null
'
dom
'
)
)
(
this
)
;
}
}
return
original
.
call
(
this
eventName
fn
options
)
;
}
;
}
)
;
fill
(
proto
'
removeEventListener
'
function
(
original
)
{
return
function
(
eventName
fn
options
)
{
try
{
original
.
call
(
this
eventName
fn
.
__sentry_wrapped__
options
)
;
}
catch
(
e
)
{
}
return
original
.
call
(
this
eventName
fn
options
)
;
}
;
}
)
;
}
)
;
}
var
debounceDuration
=
1000
;
var
debounceTimer
=
0
;
var
keypressTimeout
;
var
lastCapturedEvent
;
function
domEventHandler
(
name
handler
debounce
)
{
if
(
debounce
=
=
=
void
0
)
{
debounce
=
false
;
}
return
function
(
event
)
{
keypressTimeout
=
undefined
;
if
(
!
event
|
|
lastCapturedEvent
=
=
=
event
)
{
return
;
}
lastCapturedEvent
=
event
;
if
(
debounceTimer
)
{
clearTimeout
(
debounceTimer
)
;
}
if
(
debounce
)
{
debounceTimer
=
setTimeout
(
function
(
)
{
handler
(
{
event
:
event
name
:
name
}
)
;
}
)
;
}
else
{
handler
(
{
event
:
event
name
:
name
}
)
;
}
}
;
}
function
keypressEventHandler
(
handler
)
{
return
function
(
event
)
{
var
target
;
try
{
target
=
event
.
target
;
}
catch
(
e
)
{
return
;
}
var
tagName
=
target
&
&
target
.
tagName
;
if
(
!
tagName
|
|
(
tagName
!
=
=
'
INPUT
'
&
&
tagName
!
=
=
'
TEXTAREA
'
&
&
!
target
.
isContentEditable
)
)
{
return
;
}
if
(
!
keypressTimeout
)
{
domEventHandler
(
'
input
'
handler
)
(
event
)
;
}
clearTimeout
(
keypressTimeout
)
;
keypressTimeout
=
setTimeout
(
function
(
)
{
keypressTimeout
=
undefined
;
}
debounceDuration
)
;
}
;
}
var
_oldOnErrorHandler
=
null
;
function
instrumentError
(
)
{
_oldOnErrorHandler
=
instrument_global
.
onerror
;
instrument_global
.
onerror
=
function
(
msg
url
line
column
error
)
{
triggerHandlers
(
'
error
'
{
column
:
column
error
:
error
line
:
line
msg
:
msg
url
:
url
}
)
;
if
(
_oldOnErrorHandler
)
{
return
_oldOnErrorHandler
.
apply
(
this
arguments
)
;
}
return
false
;
}
;
}
var
_oldOnUnhandledRejectionHandler
=
null
;
function
instrumentUnhandledRejection
(
)
{
_oldOnUnhandledRejectionHandler
=
instrument_global
.
onunhandledrejection
;
instrument_global
.
onunhandledrejection
=
function
(
e
)
{
triggerHandlers
(
'
unhandledrejection
'
e
)
;
if
(
_oldOnUnhandledRejectionHandler
)
{
return
_oldOnUnhandledRejectionHandler
.
apply
(
this
arguments
)
;
}
return
true
;
}
;
}
;
var
Breadcrumbs
=
(
function
(
)
{
function
Breadcrumbs
(
options
)
{
this
.
name
=
Breadcrumbs
.
id
;
this
.
_options
=
__assign
(
{
console
:
true
dom
:
true
fetch
:
true
history
:
true
sentry
:
true
xhr
:
true
}
options
)
;
}
Breadcrumbs
.
prototype
.
addSentryBreadcrumb
=
function
(
event
)
{
if
(
!
this
.
_options
.
sentry
)
{
return
;
}
getCurrentHub
(
)
.
addBreadcrumb
(
{
category
:
"
sentry
.
"
+
(
event
.
type
=
=
=
'
transaction
'
?
'
transaction
'
:
'
event
'
)
event_id
:
event
.
event_id
level
:
event
.
level
message
:
(
0
misc
.
jH
)
(
event
)
}
{
event
:
event
}
)
;
}
;
Breadcrumbs
.
prototype
.
setupOnce
=
function
(
)
{
var
_this
=
this
;
if
(
this
.
_options
.
console
)
{
addInstrumentationHandler
(
{
callback
:
function
(
)
{
var
args
=
[
]
;
for
(
var
_i
=
0
;
_i
<
arguments
.
length
;
_i
+
+
)
{
args
[
_i
]
=
arguments
[
_i
]
;
}
_this
.
_consoleBreadcrumb
.
apply
(
_this
tslib_es6_spread
(
args
)
)
;
}
type
:
'
console
'
}
)
;
}
if
(
this
.
_options
.
dom
)
{
addInstrumentationHandler
(
{
callback
:
function
(
)
{
var
args
=
[
]
;
for
(
var
_i
=
0
;
_i
<
arguments
.
length
;
_i
+
+
)
{
args
[
_i
]
=
arguments
[
_i
]
;
}
_this
.
_domBreadcrumb
.
apply
(
_this
tslib_es6_spread
(
args
)
)
;
}
type
:
'
dom
'
}
)
;
}
if
(
this
.
_options
.
xhr
)
{
addInstrumentationHandler
(
{
callback
:
function
(
)
{
var
args
=
[
]
;
for
(
var
_i
=
0
;
_i
<
arguments
.
length
;
_i
+
+
)
{
args
[
_i
]
=
arguments
[
_i
]
;
}
_this
.
_xhrBreadcrumb
.
apply
(
_this
tslib_es6_spread
(
args
)
)
;
}
type
:
'
xhr
'
}
)
;
}
if
(
this
.
_options
.
fetch
)
{
addInstrumentationHandler
(
{
callback
:
function
(
)
{
var
args
=
[
]
;
for
(
var
_i
=
0
;
_i
<
arguments
.
length
;
_i
+
+
)
{
args
[
_i
]
=
arguments
[
_i
]
;
}
_this
.
_fetchBreadcrumb
.
apply
(
_this
tslib_es6_spread
(
args
)
)
;
}
type
:
'
fetch
'
}
)
;
}
if
(
this
.
_options
.
history
)
{
addInstrumentationHandler
(
{
callback
:
function
(
)
{
var
args
=
[
]
;
for
(
var
_i
=
0
;
_i
<
arguments
.
length
;
_i
+
+
)
{
args
[
_i
]
=
arguments
[
_i
]
;
}
_this
.
_historyBreadcrumb
.
apply
(
_this
tslib_es6_spread
(
args
)
)
;
}
type
:
'
history
'
}
)
;
}
}
;
Breadcrumbs
.
prototype
.
_consoleBreadcrumb
=
function
(
handlerData
)
{
var
breadcrumb
=
{
category
:
'
console
'
data
:
{
arguments
:
handlerData
.
args
logger
:
'
console
'
}
level
:
Severity
.
fromString
(
handlerData
.
level
)
message
:
safeJoin
(
handlerData
.
args
'
'
)
}
;
if
(
handlerData
.
level
=
=
=
'
assert
'
)
{
if
(
handlerData
.
args
[
0
]
=
=
=
false
)
{
breadcrumb
.
message
=
"
Assertion
failed
:
"
+
(
safeJoin
(
handlerData
.
args
.
slice
(
1
)
'
'
)
|
|
'
console
.
assert
'
)
;
breadcrumb
.
data
.
arguments
=
handlerData
.
args
.
slice
(
1
)
;
}
else
{
return
;
}
}
getCurrentHub
(
)
.
addBreadcrumb
(
breadcrumb
{
input
:
handlerData
.
args
level
:
handlerData
.
level
}
)
;
}
;
Breadcrumbs
.
prototype
.
_domBreadcrumb
=
function
(
handlerData
)
{
var
target
;
try
{
target
=
handlerData
.
event
.
target
?
htmlTreeAsString
(
handlerData
.
event
.
target
)
:
htmlTreeAsString
(
handlerData
.
event
)
;
}
catch
(
e
)
{
target
=
'
<
unknown
>
'
;
}
if
(
target
.
length
=
=
=
0
)
{
return
;
}
getCurrentHub
(
)
.
addBreadcrumb
(
{
category
:
"
ui
.
"
+
handlerData
.
name
message
:
target
}
{
event
:
handlerData
.
event
name
:
handlerData
.
name
}
)
;
}
;
Breadcrumbs
.
prototype
.
_xhrBreadcrumb
=
function
(
handlerData
)
{
if
(
handlerData
.
endTimestamp
)
{
if
(
handlerData
.
xhr
.
__sentry_own_request__
)
{
return
;
}
var
_a
=
handlerData
.
xhr
.
__sentry_xhr__
|
|
{
}
method
=
_a
.
method
url
=
_a
.
url
status_code
=
_a
.
status_code
body
=
_a
.
body
;
getCurrentHub
(
)
.
addBreadcrumb
(
{
category
:
'
xhr
'
data
:
{
method
:
method
url
:
url
status_code
:
status_code
}
type
:
'
http
'
}
{
xhr
:
handlerData
.
xhr
input
:
body
}
)
;
return
;
}
}
;
Breadcrumbs
.
prototype
.
_fetchBreadcrumb
=
function
(
handlerData
)
{
if
(
!
handlerData
.
endTimestamp
)
{
return
;
}
if
(
handlerData
.
fetchData
.
url
.
match
(
/
sentry_key
/
)
&
&
handlerData
.
fetchData
.
method
=
=
=
'
POST
'
)
{
return
;
}
if
(
handlerData
.
error
)
{
getCurrentHub
(
)
.
addBreadcrumb
(
{
category
:
'
fetch
'
data
:
handlerData
.
fetchData
level
:
Severity
.
Error
type
:
'
http
'
}
{
data
:
handlerData
.
error
input
:
handlerData
.
args
}
)
;
}
else
{
getCurrentHub
(
)
.
addBreadcrumb
(
{
category
:
'
fetch
'
data
:
__assign
(
__assign
(
{
}
handlerData
.
fetchData
)
{
status_code
:
handlerData
.
response
.
status
}
)
type
:
'
http
'
}
{
input
:
handlerData
.
args
response
:
handlerData
.
response
}
)
;
}
}
;
Breadcrumbs
.
prototype
.
_historyBreadcrumb
=
function
(
handlerData
)
{
var
global
=
(
0
misc
.
Rf
)
(
)
;
var
from
=
handlerData
.
from
;
var
to
=
handlerData
.
to
;
var
parsedLoc
=
(
0
misc
.
en
)
(
global
.
location
.
href
)
;
var
parsedFrom
=
(
0
misc
.
en
)
(
from
)
;
var
parsedTo
=
(
0
misc
.
en
)
(
to
)
;
if
(
!
parsedFrom
.
path
)
{
parsedFrom
=
parsedLoc
;
}
if
(
parsedLoc
.
protocol
=
=
=
parsedTo
.
protocol
&
&
parsedLoc
.
host
=
=
=
parsedTo
.
host
)
{
to
=
parsedTo
.
relative
;
}
if
(
parsedLoc
.
protocol
=
=
=
parsedFrom
.
protocol
&
&
parsedLoc
.
host
=
=
=
parsedFrom
.
host
)
{
from
=
parsedFrom
.
relative
;
}
getCurrentHub
(
)
.
addBreadcrumb
(
{
category
:
'
navigation
'
data
:
{
from
:
from
to
:
to
}
}
)
;
}
;
Breadcrumbs
.
id
=
'
Breadcrumbs
'
;
return
Breadcrumbs
;
}
(
)
)
;
;
var
SDK_NAME
=
'
sentry
.
javascript
.
browser
'
;
var
SDK_VERSION
=
'
5
.
27
.
2
'
;
;
var
BrowserClient
=
(
function
(
_super
)
{
__extends
(
BrowserClient
_super
)
;
function
BrowserClient
(
options
)
{
if
(
options
=
=
=
void
0
)
{
options
=
{
}
;
}
return
_super
.
call
(
this
BrowserBackend
options
)
|
|
this
;
}
BrowserClient
.
prototype
.
showReportDialog
=
function
(
options
)
{
if
(
options
=
=
=
void
0
)
{
options
=
{
}
;
}
var
document
=
(
0
misc
.
Rf
)
(
)
.
document
;
if
(
!
document
)
{
return
;
}
if
(
!
this
.
_isEnabled
(
)
)
{
logger
.
error
(
'
Trying
to
call
showReportDialog
with
Sentry
Client
disabled
'
)
;
return
;
}
injectReportDialog
(
__assign
(
__assign
(
{
}
options
)
{
dsn
:
options
.
dsn
|
|
this
.
getDsn
(
)
}
)
)
;
}
;
BrowserClient
.
prototype
.
_prepareEvent
=
function
(
event
scope
hint
)
{
event
.
platform
=
event
.
platform
|
|
'
javascript
'
;
event
.
sdk
=
__assign
(
__assign
(
{
}
event
.
sdk
)
{
name
:
SDK_NAME
packages
:
tslib_es6_spread
(
(
(
event
.
sdk
&
&
event
.
sdk
.
packages
)
|
|
[
]
)
[
{
name
:
'
npm
:
sentry
/
browser
'
version
:
SDK_VERSION
}
]
)
version
:
SDK_VERSION
}
)
;
return
_super
.
prototype
.
_prepareEvent
.
call
(
this
event
scope
hint
)
;
}
;
BrowserClient
.
prototype
.
_sendEvent
=
function
(
event
)
{
var
integration
=
this
.
getIntegration
(
Breadcrumbs
)
;
if
(
integration
)
{
integration
.
addSentryBreadcrumb
(
event
)
;
}
_super
.
prototype
.
_sendEvent
.
call
(
this
event
)
;
}
;
return
BrowserClient
;
}
(
BaseClient
)
)
;
;
function
initAndBind
(
clientClass
options
)
{
if
(
options
.
debug
=
=
=
true
)
{
logger
.
enable
(
)
;
}
var
hub
=
getCurrentHub
(
)
;
var
client
=
new
clientClass
(
options
)
;
hub
.
bindClient
(
client
)
;
}
;
var
DEFAULT_IGNORE_ERRORS
=
[
/
^
Script
error
\
.
?
/
/
^
Javascript
error
:
Script
error
\
.
?
on
line
0
/
]
;
var
InboundFilters
=
(
function
(
)
{
function
InboundFilters
(
_options
)
{
if
(
_options
=
=
=
void
0
)
{
_options
=
{
}
;
}
this
.
_options
=
_options
;
this
.
name
=
InboundFilters
.
id
;
}
InboundFilters
.
prototype
.
setupOnce
=
function
(
)
{
addGlobalEventProcessor
(
function
(
event
)
{
var
hub
=
getCurrentHub
(
)
;
if
(
!
hub
)
{
return
event
;
}
var
self
=
hub
.
getIntegration
(
InboundFilters
)
;
if
(
self
)
{
var
client
=
hub
.
getClient
(
)
;
var
clientOptions
=
client
?
client
.
getOptions
(
)
:
{
}
;
var
options
=
self
.
_mergeOptions
(
clientOptions
)
;
if
(
self
.
_shouldDropEvent
(
event
options
)
)
{
return
null
;
}
}
return
event
;
}
)
;
}
;
InboundFilters
.
prototype
.
_shouldDropEvent
=
function
(
event
options
)
{
if
(
this
.
_isSentryError
(
event
options
)
)
{
logger
.
warn
(
"
Event
dropped
due
to
being
internal
Sentry
Error
.
\
nEvent
:
"
+
(
0
misc
.
jH
)
(
event
)
)
;
return
true
;
}
if
(
this
.
_isIgnoredError
(
event
options
)
)
{
logger
.
warn
(
"
Event
dropped
due
to
being
matched
by
ignoreErrors
option
.
\
nEvent
:
"
+
(
0
misc
.
jH
)
(
event
)
)
;
return
true
;
}
if
(
this
.
_isDeniedUrl
(
event
options
)
)
{
logger
.
warn
(
"
Event
dropped
due
to
being
matched
by
denyUrls
option
.
\
nEvent
:
"
+
(
0
misc
.
jH
)
(
event
)
+
"
.
\
nUrl
:
"
+
this
.
_getEventFilterUrl
(
event
)
)
;
return
true
;
}
if
(
!
this
.
_isAllowedUrl
(
event
options
)
)
{
logger
.
warn
(
"
Event
dropped
due
to
not
being
matched
by
allowUrls
option
.
\
nEvent
:
"
+
(
0
misc
.
jH
)
(
event
)
+
"
.
\
nUrl
:
"
+
this
.
_getEventFilterUrl
(
event
)
)
;
return
true
;
}
return
false
;
}
;
InboundFilters
.
prototype
.
_isSentryError
=
function
(
event
options
)
{
if
(
!
options
.
ignoreInternal
)
{
return
false
;
}
try
{
return
(
(
event
&
&
event
.
exception
&
&
event
.
exception
.
values
&
&
event
.
exception
.
values
[
0
]
&
&
event
.
exception
.
values
[
0
]
.
type
=
=
=
'
SentryError
'
)
|
|
false
)
;
}
catch
(
_oO
)
{
return
false
;
}
}
;
InboundFilters
.
prototype
.
_isIgnoredError
=
function
(
event
options
)
{
if
(
!
options
.
ignoreErrors
|
|
!
options
.
ignoreErrors
.
length
)
{
return
false
;
}
return
this
.
_getPossibleEventMessages
(
event
)
.
some
(
function
(
message
)
{
return
options
.
ignoreErrors
.
some
(
function
(
pattern
)
{
return
isMatchingPattern
(
message
pattern
)
;
}
)
;
}
)
;
}
;
InboundFilters
.
prototype
.
_isDeniedUrl
=
function
(
event
options
)
{
if
(
!
options
.
denyUrls
|
|
!
options
.
denyUrls
.
length
)
{
return
false
;
}
var
url
=
this
.
_getEventFilterUrl
(
event
)
;
return
!
url
?
false
:
options
.
denyUrls
.
some
(
function
(
pattern
)
{
return
isMatchingPattern
(
url
pattern
)
;
}
)
;
}
;
InboundFilters
.
prototype
.
_isAllowedUrl
=
function
(
event
options
)
{
if
(
!
options
.
allowUrls
|
|
!
options
.
allowUrls
.
length
)
{
return
true
;
}
var
url
=
this
.
_getEventFilterUrl
(
event
)
;
return
!
url
?
true
:
options
.
allowUrls
.
some
(
function
(
pattern
)
{
return
isMatchingPattern
(
url
pattern
)
;
}
)
;
}
;
InboundFilters
.
prototype
.
_mergeOptions
=
function
(
clientOptions
)
{
if
(
clientOptions
=
=
=
void
0
)
{
clientOptions
=
{
}
;
}
return
{
allowUrls
:
tslib_es6_spread
(
(
[
]
)
(
this
.
_options
.
allowUrls
|
|
[
]
)
(
[
]
)
(
clientOptions
.
allowUrls
|
|
[
]
)
)
denyUrls
:
tslib_es6_spread
(
(
[
]
)
(
this
.
_options
.
denyUrls
|
|
[
]
)
(
[
]
)
(
clientOptions
.
denyUrls
|
|
[
]
)
)
ignoreErrors
:
tslib_es6_spread
(
(
[
]
)
(
clientOptions
.
ignoreErrors
|
|
[
]
)
DEFAULT_IGNORE_ERRORS
)
ignoreInternal
:
typeof
this
.
_options
.
ignoreInternal
!
=
=
'
undefined
'
?
this
.
_options
.
ignoreInternal
:
true
}
;
}
;
InboundFilters
.
prototype
.
_getPossibleEventMessages
=
function
(
event
)
{
if
(
event
.
message
)
{
return
[
event
.
message
]
;
}
if
(
event
.
exception
)
{
try
{
var
_a
=
(
event
.
exception
.
values
&
&
event
.
exception
.
values
[
0
]
)
|
|
{
}
_b
=
_a
.
type
type
=
_b
=
=
=
void
0
?
'
'
:
_b
_c
=
_a
.
value
value
=
_c
=
=
=
void
0
?
'
'
:
_c
;
return
[
"
"
+
value
type
+
"
:
"
+
value
]
;
}
catch
(
oO
)
{
logger
.
error
(
"
Cannot
extract
message
for
event
"
+
(
0
misc
.
jH
)
(
event
)
)
;
return
[
]
;
}
}
return
[
]
;
}
;
InboundFilters
.
prototype
.
_getEventFilterUrl
=
function
(
event
)
{
try
{
if
(
event
.
stacktrace
)
{
var
frames_1
=
event
.
stacktrace
.
frames
;
return
(
frames_1
&
&
frames_1
[
frames_1
.
length
-
1
]
.
filename
)
|
|
null
;
}
if
(
event
.
exception
)
{
var
frames_2
=
event
.
exception
.
values
&
&
event
.
exception
.
values
[
0
]
.
stacktrace
&
&
event
.
exception
.
values
[
0
]
.
stacktrace
.
frames
;
return
(
frames_2
&
&
frames_2
[
frames_2
.
length
-
1
]
.
filename
)
|
|
null
;
}
return
null
;
}
catch
(
oO
)
{
logger
.
error
(
"
Cannot
extract
url
for
event
"
+
(
0
misc
.
jH
)
(
event
)
)
;
return
null
;
}
}
;
InboundFilters
.
id
=
'
InboundFilters
'
;
return
InboundFilters
;
}
(
)
)
;
;
var
originalFunctionToString
;
var
FunctionToString
=
(
function
(
)
{
function
FunctionToString
(
)
{
this
.
name
=
FunctionToString
.
id
;
}
FunctionToString
.
prototype
.
setupOnce
=
function
(
)
{
originalFunctionToString
=
Function
.
prototype
.
toString
;
Function
.
prototype
.
toString
=
function
(
)
{
var
args
=
[
]
;
for
(
var
_i
=
0
;
_i
<
arguments
.
length
;
_i
+
+
)
{
args
[
_i
]
=
arguments
[
_i
]
;
}
var
context
=
this
.
__sentry_original__
|
|
this
;
return
originalFunctionToString
.
apply
(
context
args
)
;
}
;
}
;
FunctionToString
.
id
=
'
FunctionToString
'
;
return
FunctionToString
;
}
(
)
)
;
;
var
DEFAULT_EVENT_TARGET
=
[
'
EventTarget
'
'
Window
'
'
Node
'
'
ApplicationCache
'
'
AudioTrackList
'
'
ChannelMergerNode
'
'
CryptoOperation
'
'
EventSource
'
'
FileReader
'
'
HTMLUnknownElement
'
'
IDBDatabase
'
'
IDBRequest
'
'
IDBTransaction
'
'
KeyOperation
'
'
MediaController
'
'
MessagePort
'
'
ModalWindow
'
'
Notification
'
'
SVGElementInstance
'
'
Screen
'
'
TextTrack
'
'
TextTrackCue
'
'
TextTrackList
'
'
WebSocket
'
'
WebSocketWorker
'
'
Worker
'
'
XMLHttpRequest
'
'
XMLHttpRequestEventTarget
'
'
XMLHttpRequestUpload
'
]
;
var
TryCatch
=
(
function
(
)
{
function
TryCatch
(
options
)
{
this
.
name
=
TryCatch
.
id
;
this
.
_options
=
__assign
(
{
XMLHttpRequest
:
true
eventTarget
:
true
requestAnimationFrame
:
true
setInterval
:
true
setTimeout
:
true
}
options
)
;
}
TryCatch
.
prototype
.
setupOnce
=
function
(
)
{
var
global
=
(
0
misc
.
Rf
)
(
)
;
if
(
this
.
_options
.
setTimeout
)
{
fill
(
global
'
setTimeout
'
this
.
_wrapTimeFunction
.
bind
(
this
)
)
;
}
if
(
this
.
_options
.
setInterval
)
{
fill
(
global
'
setInterval
'
this
.
_wrapTimeFunction
.
bind
(
this
)
)
;
}
if
(
this
.
_options
.
requestAnimationFrame
)
{
fill
(
global
'
requestAnimationFrame
'
this
.
_wrapRAF
.
bind
(
this
)
)
;
}
if
(
this
.
_options
.
XMLHttpRequest
&
&
'
XMLHttpRequest
'
in
global
)
{
fill
(
XMLHttpRequest
.
prototype
'
send
'
this
.
_wrapXHR
.
bind
(
this
)
)
;
}
if
(
this
.
_options
.
eventTarget
)
{
var
eventTarget
=
Array
.
isArray
(
this
.
_options
.
eventTarget
)
?
this
.
_options
.
eventTarget
:
DEFAULT_EVENT_TARGET
;
eventTarget
.
forEach
(
this
.
_wrapEventTarget
.
bind
(
this
)
)
;
}
}
;
TryCatch
.
prototype
.
_wrapTimeFunction
=
function
(
original
)
{
return
function
(
)
{
var
args
=
[
]
;
for
(
var
_i
=
0
;
_i
<
arguments
.
length
;
_i
+
+
)
{
args
[
_i
]
=
arguments
[
_i
]
;
}
var
originalCallback
=
args
[
0
]
;
args
[
0
]
=
wrap
(
originalCallback
{
mechanism
:
{
data
:
{
function
:
getFunctionName
(
original
)
}
handled
:
true
type
:
'
instrument
'
}
}
)
;
return
original
.
apply
(
this
args
)
;
}
;
}
;
TryCatch
.
prototype
.
_wrapRAF
=
function
(
original
)
{
return
function
(
callback
)
{
return
original
.
call
(
this
wrap
(
callback
{
mechanism
:
{
data
:
{
function
:
'
requestAnimationFrame
'
handler
:
getFunctionName
(
original
)
}
handled
:
true
type
:
'
instrument
'
}
}
)
)
;
}
;
}
;
TryCatch
.
prototype
.
_wrapEventTarget
=
function
(
target
)
{
var
global
=
(
0
misc
.
Rf
)
(
)
;
var
proto
=
global
[
target
]
&
&
global
[
target
]
.
prototype
;
if
(
!
proto
|
|
!
proto
.
hasOwnProperty
|
|
!
proto
.
hasOwnProperty
(
'
addEventListener
'
)
)
{
return
;
}
fill
(
proto
'
addEventListener
'
function
(
original
)
{
return
function
(
eventName
fn
options
)
{
try
{
if
(
typeof
fn
.
handleEvent
=
=
=
'
function
'
)
{
fn
.
handleEvent
=
wrap
(
fn
.
handleEvent
.
bind
(
fn
)
{
mechanism
:
{
data
:
{
function
:
'
handleEvent
'
handler
:
getFunctionName
(
fn
)
target
:
target
}
handled
:
true
type
:
'
instrument
'
}
}
)
;
}
}
catch
(
err
)
{
}
return
original
.
call
(
this
eventName
wrap
(
fn
{
mechanism
:
{
data
:
{
function
:
'
addEventListener
'
handler
:
getFunctionName
(
fn
)
target
:
target
}
handled
:
true
type
:
'
instrument
'
}
}
)
options
)
;
}
;
}
)
;
fill
(
proto
'
removeEventListener
'
function
(
original
)
{
return
function
(
eventName
fn
options
)
{
try
{
original
.
call
(
this
eventName
fn
.
__sentry_wrapped__
options
)
;
}
catch
(
e
)
{
}
return
original
.
call
(
this
eventName
fn
options
)
;
}
;
}
)
;
}
;
TryCatch
.
prototype
.
_wrapXHR
=
function
(
originalSend
)
{
return
function
(
)
{
var
args
=
[
]
;
for
(
var
_i
=
0
;
_i
<
arguments
.
length
;
_i
+
+
)
{
args
[
_i
]
=
arguments
[
_i
]
;
}
var
xhr
=
this
;
var
xmlHttpRequestProps
=
[
'
onload
'
'
onerror
'
'
onprogress
'
'
onreadystatechange
'
]
;
xmlHttpRequestProps
.
forEach
(
function
(
prop
)
{
if
(
prop
in
xhr
&
&
typeof
xhr
[
prop
]
=
=
=
'
function
'
)
{
fill
(
xhr
prop
function
(
original
)
{
var
wrapOptions
=
{
mechanism
:
{
data
:
{
function
:
prop
handler
:
getFunctionName
(
original
)
}
handled
:
true
type
:
'
instrument
'
}
}
;
if
(
original
.
__sentry_original__
)
{
wrapOptions
.
mechanism
.
data
.
handler
=
getFunctionName
(
original
.
__sentry_original__
)
;
}
return
wrap
(
original
wrapOptions
)
;
}
)
;
}
}
)
;
return
originalSend
.
apply
(
this
args
)
;
}
;
}
;
TryCatch
.
id
=
'
TryCatch
'
;
return
TryCatch
;
}
(
)
)
;
;
var
GlobalHandlers
=
(
function
(
)
{
function
GlobalHandlers
(
options
)
{
this
.
name
=
GlobalHandlers
.
id
;
this
.
_onErrorHandlerInstalled
=
false
;
this
.
_onUnhandledRejectionHandlerInstalled
=
false
;
this
.
_options
=
__assign
(
{
onerror
:
true
onunhandledrejection
:
true
}
options
)
;
}
GlobalHandlers
.
prototype
.
setupOnce
=
function
(
)
{
Error
.
stackTraceLimit
=
50
;
if
(
this
.
_options
.
onerror
)
{
logger
.
log
(
'
Global
Handler
attached
:
onerror
'
)
;
this
.
_installGlobalOnErrorHandler
(
)
;
}
if
(
this
.
_options
.
onunhandledrejection
)
{
logger
.
log
(
'
Global
Handler
attached
:
onunhandledrejection
'
)
;
this
.
_installGlobalOnUnhandledRejectionHandler
(
)
;
}
}
;
GlobalHandlers
.
prototype
.
_installGlobalOnErrorHandler
=
function
(
)
{
var
_this
=
this
;
if
(
this
.
_onErrorHandlerInstalled
)
{
return
;
}
addInstrumentationHandler
(
{
callback
:
function
(
data
)
{
var
error
=
data
.
error
;
var
currentHub
=
getCurrentHub
(
)
;
var
hasIntegration
=
currentHub
.
getIntegration
(
GlobalHandlers
)
;
var
isFailedOwnDelivery
=
error
&
&
error
.
__sentry_own_request__
=
=
=
true
;
if
(
!
hasIntegration
|
|
shouldIgnoreOnError
(
)
|
|
isFailedOwnDelivery
)
{
return
;
}
var
client
=
currentHub
.
getClient
(
)
;
var
event
=
isPrimitive
(
error
)
?
_this
.
_eventFromIncompleteOnError
(
data
.
msg
data
.
url
data
.
line
data
.
column
)
:
_this
.
_enhanceEventWithInitialFrame
(
eventFromUnknownInput
(
error
undefined
{
attachStacktrace
:
client
&
&
client
.
getOptions
(
)
.
attachStacktrace
rejection
:
false
}
)
data
.
url
data
.
line
data
.
column
)
;
(
0
misc
.
EG
)
(
event
{
handled
:
false
type
:
'
onerror
'
}
)
;
currentHub
.
captureEvent
(
event
{
originalException
:
error
}
)
;
}
type
:
'
error
'
}
)
;
this
.
_onErrorHandlerInstalled
=
true
;
}
;
GlobalHandlers
.
prototype
.
_installGlobalOnUnhandledRejectionHandler
=
function
(
)
{
var
_this
=
this
;
if
(
this
.
_onUnhandledRejectionHandlerInstalled
)
{
return
;
}
addInstrumentationHandler
(
{
callback
:
function
(
e
)
{
var
error
=
e
;
try
{
if
(
'
reason
'
in
e
)
{
error
=
e
.
reason
;
}
else
if
(
'
detail
'
in
e
&
&
'
reason
'
in
e
.
detail
)
{
error
=
e
.
detail
.
reason
;
}
}
catch
(
_oO
)
{
}
var
currentHub
=
getCurrentHub
(
)
;
var
hasIntegration
=
currentHub
.
getIntegration
(
GlobalHandlers
)
;
var
isFailedOwnDelivery
=
error
&
&
error
.
__sentry_own_request__
=
=
=
true
;
if
(
!
hasIntegration
|
|
shouldIgnoreOnError
(
)
|
|
isFailedOwnDelivery
)
{
return
true
;
}
var
client
=
currentHub
.
getClient
(
)
;
var
event
=
isPrimitive
(
error
)
?
_this
.
_eventFromIncompleteRejection
(
error
)
:
eventFromUnknownInput
(
error
undefined
{
attachStacktrace
:
client
&
&
client
.
getOptions
(
)
.
attachStacktrace
rejection
:
true
}
)
;
event
.
level
=
Severity
.
Error
;
(
0
misc
.
EG
)
(
event
{
handled
:
false
type
:
'
onunhandledrejection
'
}
)
;
currentHub
.
captureEvent
(
event
{
originalException
:
error
}
)
;
return
;
}
type
:
'
unhandledrejection
'
}
)
;
this
.
_onUnhandledRejectionHandlerInstalled
=
true
;
}
;
GlobalHandlers
.
prototype
.
_eventFromIncompleteOnError
=
function
(
msg
url
line
column
)
{
var
ERROR_TYPES_RE
=
/
^
(
?
:
[
Uu
]
ncaught
(
?
:
exception
:
)
?
)
?
(
?
:
(
(
?
:
Eval
|
Internal
|
Range
|
Reference
|
Syntax
|
Type
|
URI
|
)
Error
)
:
)
?
(
.
*
)
/
i
;
var
message
=
isErrorEvent
(
msg
)
?
msg
.
message
:
msg
;
var
name
;
if
(
isString
(
message
)
)
{
var
groups
=
message
.
match
(
ERROR_TYPES_RE
)
;
if
(
groups
)
{
name
=
groups
[
1
]
;
message
=
groups
[
2
]
;
}
}
var
event
=
{
exception
:
{
values
:
[
{
type
:
name
|
|
'
Error
'
value
:
message
}
]
}
}
;
return
this
.
_enhanceEventWithInitialFrame
(
event
url
line
column
)
;
}
;
GlobalHandlers
.
prototype
.
_eventFromIncompleteRejection
=
function
(
error
)
{
return
{
exception
:
{
values
:
[
{
type
:
'
UnhandledRejection
'
value
:
"
Non
-
Error
promise
rejection
captured
with
value
:
"
+
error
}
]
}
}
;
}
;
GlobalHandlers
.
prototype
.
_enhanceEventWithInitialFrame
=
function
(
event
url
line
column
)
{
event
.
exception
=
event
.
exception
|
|
{
}
;
event
.
exception
.
values
=
event
.
exception
.
values
|
|
[
]
;
event
.
exception
.
values
[
0
]
=
event
.
exception
.
values
[
0
]
|
|
{
}
;
event
.
exception
.
values
[
0
]
.
stacktrace
=
event
.
exception
.
values
[
0
]
.
stacktrace
|
|
{
}
;
event
.
exception
.
values
[
0
]
.
stacktrace
.
frames
=
event
.
exception
.
values
[
0
]
.
stacktrace
.
frames
|
|
[
]
;
var
colno
=
isNaN
(
parseInt
(
column
10
)
)
?
undefined
:
column
;
var
lineno
=
isNaN
(
parseInt
(
line
10
)
)
?
undefined
:
line
;
var
filename
=
isString
(
url
)
&
&
url
.
length
>
0
?
url
:
(
0
misc
.
l4
)
(
)
;
if
(
event
.
exception
.
values
[
0
]
.
stacktrace
.
frames
.
length
=
=
=
0
)
{
event
.
exception
.
values
[
0
]
.
stacktrace
.
frames
.
push
(
{
colno
:
colno
filename
:
filename
function
:
'
?
'
in_app
:
true
lineno
:
lineno
}
)
;
}
return
event
;
}
;
GlobalHandlers
.
id
=
'
GlobalHandlers
'
;
return
GlobalHandlers
;
}
(
)
)
;
;
var
DEFAULT_KEY
=
'
cause
'
;
var
DEFAULT_LIMIT
=
5
;
var
LinkedErrors
=
(
function
(
)
{
function
LinkedErrors
(
options
)
{
if
(
options
=
=
=
void
0
)
{
options
=
{
}
;
}
this
.
name
=
LinkedErrors
.
id
;
this
.
_key
=
options
.
key
|
|
DEFAULT_KEY
;
this
.
_limit
=
options
.
limit
|
|
DEFAULT_LIMIT
;
}
LinkedErrors
.
prototype
.
setupOnce
=
function
(
)
{
addGlobalEventProcessor
(
function
(
event
hint
)
{
var
self
=
getCurrentHub
(
)
.
getIntegration
(
LinkedErrors
)
;
if
(
self
)
{
return
self
.
_handler
(
event
hint
)
;
}
return
event
;
}
)
;
}
;
LinkedErrors
.
prototype
.
_handler
=
function
(
event
hint
)
{
if
(
!
event
.
exception
|
|
!
event
.
exception
.
values
|
|
!
hint
|
|
!
isInstanceOf
(
hint
.
originalException
Error
)
)
{
return
event
;
}
var
linkedErrors
=
this
.
_walkErrorTree
(
hint
.
originalException
this
.
_key
)
;
event
.
exception
.
values
=
tslib_es6_spread
(
linkedErrors
event
.
exception
.
values
)
;
return
event
;
}
;
LinkedErrors
.
prototype
.
_walkErrorTree
=
function
(
error
key
stack
)
{
if
(
stack
=
=
=
void
0
)
{
stack
=
[
]
;
}
if
(
!
isInstanceOf
(
error
[
key
]
Error
)
|
|
stack
.
length
+
1
>
=
this
.
_limit
)
{
return
stack
;
}
var
stacktrace
=
computeStackTrace
(
error
[
key
]
)
;
var
exception
=
exceptionFromStacktrace
(
stacktrace
)
;
return
this
.
_walkErrorTree
(
error
[
key
]
key
tslib_es6_spread
(
[
exception
]
stack
)
)
;
}
;
LinkedErrors
.
id
=
'
LinkedErrors
'
;
return
LinkedErrors
;
}
(
)
)
;
;
var
useragent_global
=
(
0
misc
.
Rf
)
(
)
;
var
UserAgent
=
(
function
(
)
{
function
UserAgent
(
)
{
this
.
name
=
UserAgent
.
id
;
}
UserAgent
.
prototype
.
setupOnce
=
function
(
)
{
addGlobalEventProcessor
(
function
(
event
)
{
var
_a
_b
_c
;
if
(
getCurrentHub
(
)
.
getIntegration
(
UserAgent
)
)
{
if
(
!
useragent_global
.
navigator
&
&
!
useragent_global
.
location
&
&
!
useragent_global
.
document
)
{
return
event
;
}
var
url
=
(
(
_a
=
event
.
request
)
=
=
=
null
|
|
_a
=
=
=
void
0
?
void
0
:
_a
.
url
)
|
|
(
(
_b
=
useragent_global
.
location
)
=
=
=
null
|
|
_b
=
=
=
void
0
?
void
0
:
_b
.
href
)
;
var
referrer
=
(
useragent_global
.
document
|
|
{
}
)
.
referrer
;
var
userAgent
=
(
useragent_global
.
navigator
|
|
{
}
)
.
userAgent
;
var
headers
=
__assign
(
__assign
(
__assign
(
{
}
(
_c
=
event
.
request
)
=
=
=
null
|
|
_c
=
=
=
void
0
?
void
0
:
_c
.
headers
)
(
referrer
&
&
{
Referer
:
referrer
}
)
)
(
userAgent
&
&
{
'
User
-
Agent
'
:
userAgent
}
)
)
;
var
request
=
__assign
(
__assign
(
{
}
(
url
&
&
{
url
:
url
}
)
)
{
headers
:
headers
}
)
;
return
__assign
(
__assign
(
{
}
event
)
{
request
:
request
}
)
;
}
return
event
;
}
)
;
}
;
UserAgent
.
id
=
'
UserAgent
'
;
return
UserAgent
;
}
(
)
)
;
;
var
defaultIntegrations
=
[
new
InboundFilters
(
)
new
FunctionToString
(
)
new
TryCatch
(
)
new
Breadcrumbs
(
)
new
GlobalHandlers
(
)
new
LinkedErrors
(
)
new
UserAgent
(
)
]
;
function
init
(
options
)
{
if
(
options
=
=
=
void
0
)
{
options
=
{
}
;
}
if
(
options
.
defaultIntegrations
=
=
=
undefined
)
{
options
.
defaultIntegrations
=
defaultIntegrations
;
}
if
(
options
.
release
=
=
=
undefined
)
{
var
window_1
=
(
0
misc
.
Rf
)
(
)
;
if
(
window_1
.
SENTRY_RELEASE
&
&
window_1
.
SENTRY_RELEASE
.
id
)
{
options
.
release
=
window_1
.
SENTRY_RELEASE
.
id
;
}
}
if
(
options
.
autoSessionTracking
=
=
=
undefined
)
{
options
.
autoSessionTracking
=
false
;
}
initAndBind
(
BrowserClient
options
)
;
if
(
options
.
autoSessionTracking
)
{
startSessionTracking
(
)
;
}
}
function
showReportDialog
(
options
)
{
if
(
options
=
=
=
void
0
)
{
options
=
{
}
;
}
if
(
!
options
.
eventId
)
{
options
.
eventId
=
getCurrentHub
(
)
.
lastEventId
(
)
;
}
var
client
=
getCurrentHub
(
)
.
getClient
(
)
;
if
(
client
)
{
client
.
showReportDialog
(
options
)
;
}
}
function
lastEventId
(
)
{
return
getCurrentHub
(
)
.
lastEventId
(
)
;
}
function
forceLoad
(
)
{
}
function
onLoad
(
callback
)
{
callback
(
)
;
}
function
flush
(
timeout
)
{
var
client
=
getCurrentHub
(
)
.
getClient
(
)
;
if
(
client
)
{
return
client
.
flush
(
timeout
)
;
}
return
SyncPromise
.
reject
(
false
)
;
}
function
sdk_close
(
timeout
)
{
var
client
=
getCurrentHub
(
)
.
getClient
(
)
;
if
(
client
)
{
return
client
.
close
(
timeout
)
;
}
return
SyncPromise
.
reject
(
false
)
;
}
function
sdk_wrap
(
fn
)
{
return
wrap
(
fn
)
(
)
;
}
function
startSessionTracking
(
)
{
var
window
=
(
0
misc
.
Rf
)
(
)
;
var
hub
=
getCurrentHub
(
)
;
var
loadResolved
=
document
.
readyState
=
=
=
'
complete
'
;
var
fcpResolved
=
false
;
var
possiblyEndSession
=
function
(
)
{
if
(
fcpResolved
&
&
loadResolved
)
{
hub
.
endSession
(
)
;
}
}
;
var
resolveWindowLoaded
=
function
(
)
{
loadResolved
=
true
;
possiblyEndSession
(
)
;
window
.
removeEventListener
(
'
load
'
resolveWindowLoaded
)
;
}
;
hub
.
startSession
(
)
;
if
(
!
loadResolved
)
{
window
.
addEventListener
(
'
load
'
resolveWindowLoaded
)
;
}
try
{
var
po
=
new
PerformanceObserver
(
function
(
entryList
po
)
{
entryList
.
getEntries
(
)
.
forEach
(
function
(
entry
)
{
if
(
entry
.
name
=
=
=
'
first
-
contentful
-
paint
'
&
&
entry
.
startTime
<
firstHiddenTime_1
)
{
po
.
disconnect
(
)
;
fcpResolved
=
true
;
possiblyEndSession
(
)
;
}
}
)
;
}
)
;
var
firstHiddenTime_1
=
document
.
visibilityState
=
=
=
'
hidden
'
?
0
:
Infinity
;
document
.
addEventListener
(
'
visibilitychange
'
function
(
event
)
{
firstHiddenTime_1
=
Math
.
min
(
firstHiddenTime_1
event
.
timeStamp
)
;
}
{
once
:
true
}
)
;
po
.
observe
(
{
type
:
'
paint
'
buffered
:
true
}
)
;
}
catch
(
e
)
{
fcpResolved
=
true
;
possiblyEndSession
(
)
;
}
}
;
;
;
;
;
var
windowIntegrations
=
{
}
;
var
_window
=
(
0
misc
.
Rf
)
(
)
;
if
(
_window
.
Sentry
&
&
_window
.
Sentry
.
Integrations
)
{
windowIntegrations
=
_window
.
Sentry
.
Integrations
;
}
var
INTEGRATIONS
=
__assign
(
__assign
(
__assign
(
{
}
windowIntegrations
)
integrations_namespaceObject
)
esm_integrations_namespaceObject
)
;
}
)
2681
:
(
(
__unused_webpack_module
__webpack_exports__
__webpack_require__
)
=
>
{
"
use
strict
"
;
__webpack_require__
.
d
(
__webpack_exports__
{
"
Rf
"
:
(
)
=
>
(
getGlobalObject
)
"
DM
"
:
(
)
=
>
(
uuid4
)
"
en
"
:
(
)
=
>
(
parseUrl
)
"
jH
"
:
(
)
=
>
(
getEventDescription
)
"
Cf
"
:
(
)
=
>
(
consoleSandbox
)
"
Db
"
:
(
)
=
>
(
addExceptionTypeValue
)
"
EG
"
:
(
)
=
>
(
addExceptionMechanism
)
"
l4
"
:
(
)
=
>
(
getLocationHref
)
"
JY
"
:
(
)
=
>
(
parseRetryAfterHeader
)
}
)
;
var
_node__WEBPACK_IMPORTED_MODULE_0__
=
__webpack_require__
(
8612
)
;
var
fallbackGlobalObject
=
{
}
;
function
getGlobalObject
(
)
{
return
(
(
0
_node__WEBPACK_IMPORTED_MODULE_0__
.
KV
)
(
)
?
__webpack_require__
.
g
:
typeof
window
!
=
=
'
undefined
'
?
window
:
typeof
self
!
=
=
'
undefined
'
?
self
:
fallbackGlobalObject
)
;
}
function
uuid4
(
)
{
var
global
=
getGlobalObject
(
)
;
var
crypto
=
global
.
crypto
|
|
global
.
msCrypto
;
if
(
!
(
crypto
=
=
=
void
0
)
&
&
crypto
.
getRandomValues
)
{
var
arr
=
new
Uint16Array
(
8
)
;
crypto
.
getRandomValues
(
arr
)
;
arr
[
3
]
=
(
arr
[
3
]
&
0xfff
)
|
0x4000
;
arr
[
4
]
=
(
arr
[
4
]
&
0x3fff
)
|
0x8000
;
var
pad
=
function
(
num
)
{
var
v
=
num
.
toString
(
16
)
;
while
(
v
.
length
<
4
)
{
v
=
"
0
"
+
v
;
}
return
v
;
}
;
return
(
pad
(
arr
[
0
]
)
+
pad
(
arr
[
1
]
)
+
pad
(
arr
[
2
]
)
+
pad
(
arr
[
3
]
)
+
pad
(
arr
[
4
]
)
+
pad
(
arr
[
5
]
)
+
pad
(
arr
[
6
]
)
+
pad
(
arr
[
7
]
)
)
;
}
return
'
xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx
'
.
replace
(
/
[
xy
]
/
g
function
(
c
)
{
var
r
=
(
Math
.
random
(
)
*
16
)
|
0
;
var
v
=
c
=
=
=
'
x
'
?
r
:
(
r
&
0x3
)
|
0x8
;
return
v
.
toString
(
16
)
;
}
)
;
}
function
parseUrl
(
url
)
{
if
(
!
url
)
{
return
{
}
;
}
var
match
=
url
.
match
(
/
^
(
(
[
^
:
/
?
#
]
+
)
:
)
?
(
\
/
\
/
(
[
^
/
?
#
]
*
)
)
?
(
[
^
?
#
]
*
)
(
\
?
(
[
^
#
]
*
)
)
?
(
#
(
.
*
)
)
?
/
)
;
if
(
!
match
)
{
return
{
}
;
}
var
query
=
match
[
6
]
|
|
'
'
;
var
fragment
=
match
[
8
]
|
|
'
'
;
return
{
host
:
match
[
4
]
path
:
match
[
5
]
protocol
:
match
[
2
]
relative
:
match
[
5
]
+
query
+
fragment
}
;
}
function
getEventDescription
(
event
)
{
if
(
event
.
message
)
{
return
event
.
message
;
}
if
(
event
.
exception
&
&
event
.
exception
.
values
&
&
event
.
exception
.
values
[
0
]
)
{
var
exception
=
event
.
exception
.
values
[
0
]
;
if
(
exception
.
type
&
&
exception
.
value
)
{
return
exception
.
type
+
"
:
"
+
exception
.
value
;
}
return
exception
.
type
|
|
exception
.
value
|
|
event
.
event_id
|
|
'
<
unknown
>
'
;
}
return
event
.
event_id
|
|
'
<
unknown
>
'
;
}
function
consoleSandbox
(
callback
)
{
var
global
=
getGlobalObject
(
)
;
var
levels
=
[
'
debug
'
'
info
'
'
warn
'
'
error
'
'
log
'
'
assert
'
]
;
if
(
!
(
'
console
'
in
global
)
)
{
return
callback
(
)
;
}
var
originalConsole
=
global
.
console
;
var
wrappedLevels
=
{
}
;
levels
.
forEach
(
function
(
level
)
{
if
(
level
in
global
.
console
&
&
originalConsole
[
level
]
.
__sentry_original__
)
{
wrappedLevels
[
level
]
=
originalConsole
[
level
]
;
originalConsole
[
level
]
=
originalConsole
[
level
]
.
__sentry_original__
;
}
}
)
;
var
result
=
callback
(
)
;
Object
.
keys
(
wrappedLevels
)
.
forEach
(
function
(
level
)
{
originalConsole
[
level
]
=
wrappedLevels
[
level
]
;
}
)
;
return
result
;
}
function
addExceptionTypeValue
(
event
value
type
)
{
event
.
exception
=
event
.
exception
|
|
{
}
;
event
.
exception
.
values
=
event
.
exception
.
values
|
|
[
]
;
event
.
exception
.
values
[
0
]
=
event
.
exception
.
values
[
0
]
|
|
{
}
;
event
.
exception
.
values
[
0
]
.
value
=
event
.
exception
.
values
[
0
]
.
value
|
|
value
|
|
'
'
;
event
.
exception
.
values
[
0
]
.
type
=
event
.
exception
.
values
[
0
]
.
type
|
|
type
|
|
'
Error
'
;
}
function
addExceptionMechanism
(
event
mechanism
)
{
if
(
mechanism
=
=
=
void
0
)
{
mechanism
=
{
}
;
}
try
{
event
.
exception
.
values
[
0
]
.
mechanism
=
event
.
exception
.
values
[
0
]
.
mechanism
|
|
{
}
;
Object
.
keys
(
mechanism
)
.
forEach
(
function
(
key
)
{
event
.
exception
.
values
[
0
]
.
mechanism
[
key
]
=
mechanism
[
key
]
;
}
)
;
}
catch
(
_oO
)
{
}
}
function
getLocationHref
(
)
{
try
{
return
document
.
location
.
href
;
}
catch
(
oO
)
{
return
'
'
;
}
}
var
SEMVER_REGEXP
=
/
^
(
0
|
[
1
-
9
]
\
d
*
)
\
.
(
0
|
[
1
-
9
]
\
d
*
)
\
.
(
0
|
[
1
-
9
]
\
d
*
)
(
?
:
-
(
(
?
:
0
|
[
1
-
9
]
\
d
*
|
\
d
*
[
a
-
zA
-
Z
-
]
[
0
-
9a
-
zA
-
Z
-
]
*
)
(
?
:
\
.
(
?
:
0
|
[
1
-
9
]
\
d
*
|
\
d
*
[
a
-
zA
-
Z
-
]
[
0
-
9a
-
zA
-
Z
-
]
*
)
)
*
)
)
?
(
?
:
\
+
(
[
0
-
9a
-
zA
-
Z
-
]
+
(
?
:
\
.
[
0
-
9a
-
zA
-
Z
-
]
+
)
*
)
)
?
/
;
function
parseSemver
(
input
)
{
var
match
=
input
.
match
(
SEMVER_REGEXP
)
|
|
[
]
;
var
major
=
parseInt
(
match
[
1
]
10
)
;
var
minor
=
parseInt
(
match
[
2
]
10
)
;
var
patch
=
parseInt
(
match
[
3
]
10
)
;
return
{
buildmetadata
:
match
[
5
]
major
:
isNaN
(
major
)
?
undefined
:
major
minor
:
isNaN
(
minor
)
?
undefined
:
minor
patch
:
isNaN
(
patch
)
?
undefined
:
patch
prerelease
:
match
[
4
]
}
;
}
var
defaultRetryAfter
=
60
*
1000
;
function
parseRetryAfterHeader
(
now
header
)
{
if
(
!
header
)
{
return
defaultRetryAfter
;
}
var
headerDelay
=
parseInt
(
"
"
+
header
10
)
;
if
(
!
isNaN
(
headerDelay
)
)
{
return
headerDelay
*
1000
;
}
var
headerDate
=
Date
.
parse
(
"
"
+
header
)
;
if
(
!
isNaN
(
headerDate
)
)
{
return
headerDate
-
now
;
}
return
defaultRetryAfter
;
}
function
addContextToFrame
(
lines
frame
linesOfContext
)
{
if
(
linesOfContext
=
=
=
void
0
)
{
linesOfContext
=
5
;
}
var
lineno
=
frame
.
lineno
|
|
0
;
var
maxLines
=
lines
.
length
;
var
sourceLine
=
Math
.
max
(
Math
.
min
(
maxLines
lineno
-
1
)
0
)
;
frame
.
pre_context
=
lines
.
slice
(
Math
.
max
(
0
sourceLine
-
linesOfContext
)
sourceLine
)
.
map
(
function
(
line
)
{
return
snipLine
(
line
0
)
;
}
)
;
frame
.
context_line
=
snipLine
(
lines
[
Math
.
min
(
maxLines
-
1
sourceLine
)
]
frame
.
colno
|
|
0
)
;
frame
.
post_context
=
lines
.
slice
(
Math
.
min
(
sourceLine
+
1
maxLines
)
sourceLine
+
1
+
linesOfContext
)
.
map
(
function
(
line
)
{
return
snipLine
(
line
0
)
;
}
)
;
}
function
stripUrlQueryAndFragment
(
urlPath
)
{
return
urlPath
.
split
(
/
[
\
?
#
]
/
1
)
[
0
]
;
}
}
)
8612
:
(
(
module
__webpack_exports__
__webpack_require__
)
=
>
{
"
use
strict
"
;
__webpack_require__
.
d
(
__webpack_exports__
{
"
KV
"
:
(
)
=
>
(
isNodeEnv
)
"
l
"
:
(
)
=
>
(
dynamicRequire
)
}
)
;
module
=
__webpack_require__
.
hmd
(
module
)
;
function
isNodeEnv
(
)
{
return
Object
.
prototype
.
toString
.
call
(
typeof
process
!
=
=
'
undefined
'
?
process
:
0
)
=
=
=
'
[
object
process
]
'
;
}
function
dynamicRequire
(
mod
request
)
{
return
mod
.
require
(
request
)
;
}
var
DEFAULT_REQUEST_KEYS
=
(
null
&
&
(
[
'
cookies
'
'
data
'
'
headers
'
'
method
'
'
query_string
'
'
url
'
]
)
)
;
function
extractNodeRequestData
(
req
keys
)
{
if
(
keys
=
=
=
void
0
)
{
keys
=
DEFAULT_REQUEST_KEYS
;
}
if
(
!
isNodeEnv
(
)
)
{
throw
new
Error
(
"
Can
'
t
get
node
request
data
outside
of
a
node
environment
"
)
;
}
var
requestData
=
{
}
;
var
headers
=
(
req
.
headers
|
|
req
.
header
|
|
{
}
)
;
var
method
=
req
.
method
;
var
host
=
req
.
hostname
|
|
req
.
host
|
|
headers
.
host
|
|
'
<
no
host
>
'
;
var
protocol
=
req
.
protocol
=
=
=
'
https
'
|
|
req
.
secure
|
|
(
req
.
socket
|
|
{
}
)
.
encrypted
?
'
https
'
:
'
http
'
;
var
originalUrl
=
(
req
.
originalUrl
|
|
req
.
url
|
|
'
'
)
;
var
absoluteUrl
=
protocol
+
"
:
/
/
"
+
host
+
originalUrl
;
keys
.
forEach
(
function
(
key
)
{
switch
(
key
)
{
case
'
headers
'
:
requestData
.
headers
=
headers
;
break
;
case
'
method
'
:
requestData
.
method
=
method
;
break
;
case
'
url
'
:
requestData
.
url
=
absoluteUrl
;
break
;
case
'
cookies
'
:
requestData
.
cookies
=
req
.
cookies
|
|
dynamicRequire
(
module
'
cookie
'
)
.
parse
(
headers
.
cookie
|
|
'
'
)
;
break
;
case
'
query_string
'
:
requestData
.
query_string
=
dynamicRequire
(
module
'
url
'
)
.
parse
(
originalUrl
|
|
'
'
false
)
.
query
;
break
;
case
'
data
'
:
if
(
method
=
=
=
'
GET
'
|
|
method
=
=
=
'
HEAD
'
)
{
break
;
}
if
(
req
.
body
!
=
=
undefined
)
{
requestData
.
data
=
isString
(
req
.
body
)
?
req
.
body
:
JSON
.
stringify
(
normalize
(
req
.
body
)
)
;
}
break
;
default
:
if
(
{
}
.
hasOwnProperty
.
call
(
req
key
)
)
{
requestData
[
key
]
=
req
[
key
]
;
}
}
}
)
;
return
requestData
;
}
}
)
7685
:
(
(
module
__webpack_exports__
__webpack_require__
)
=
>
{
"
use
strict
"
;
__webpack_require__
.
d
(
__webpack_exports__
{
"
yW
"
:
(
)
=
>
(
dateTimestampInSeconds
)
}
)
;
var
_misc__WEBPACK_IMPORTED_MODULE_0__
=
__webpack_require__
(
2681
)
;
var
_node__WEBPACK_IMPORTED_MODULE_1__
=
__webpack_require__
(
8612
)
;
module
=
__webpack_require__
.
hmd
(
module
)
;
var
dateTimestampSource
=
{
nowSeconds
:
function
(
)
{
return
Date
.
now
(
)
/
1000
;
}
}
;
function
getBrowserPerformance
(
)
{
var
performance
=
(
0
_misc__WEBPACK_IMPORTED_MODULE_0__
.
Rf
)
(
)
.
performance
;
if
(
!
performance
|
|
!
performance
.
now
)
{
return
undefined
;
}
var
timeOrigin
=
Date
.
now
(
)
-
performance
.
now
(
)
;
return
{
now
:
function
(
)
{
return
performance
.
now
(
)
;
}
timeOrigin
:
timeOrigin
}
;
}
function
getNodePerformance
(
)
{
try
{
var
perfHooks
=
(
0
_node__WEBPACK_IMPORTED_MODULE_1__
.
l
)
(
module
'
perf_hooks
'
)
;
return
perfHooks
.
performance
;
}
catch
(
_
)
{
return
undefined
;
}
}
var
platformPerformance
=
(
0
_node__WEBPACK_IMPORTED_MODULE_1__
.
KV
)
(
)
?
getNodePerformance
(
)
:
getBrowserPerformance
(
)
;
var
timestampSource
=
platformPerformance
=
=
=
undefined
?
dateTimestampSource
:
{
nowSeconds
:
function
(
)
{
return
(
platformPerformance
.
timeOrigin
+
platformPerformance
.
now
(
)
)
/
1000
;
}
}
;
var
dateTimestampInSeconds
=
dateTimestampSource
.
nowSeconds
.
bind
(
dateTimestampSource
)
;
var
timestampInSeconds
=
timestampSource
.
nowSeconds
.
bind
(
timestampSource
)
;
var
timestampWithMs
=
(
null
&
&
(
timestampInSeconds
)
)
;
var
usingPerformanceAPI
=
platformPerformance
!
=
=
undefined
;
var
browserPerformanceTimeOrigin
=
(
function
(
)
{
var
performance
=
(
0
_misc__WEBPACK_IMPORTED_MODULE_0__
.
Rf
)
(
)
.
performance
;
if
(
!
performance
)
{
return
undefined
;
}
if
(
performance
.
timeOrigin
)
{
return
performance
.
timeOrigin
;
}
return
(
performance
.
timing
&
&
performance
.
timing
.
navigationStart
)
|
|
Date
.
now
(
)
;
}
)
(
)
;
}
)
4050
:
(
(
module
)
=
>
{
"
use
strict
"
;
var
envHasBigInt64Array
=
typeof
BigInt64Array
!
=
=
'
undefined
'
;
module
.
exports
=
function
equal
(
a
b
)
{
if
(
a
=
=
=
b
)
return
true
;
if
(
a
&
&
b
&
&
typeof
a
=
=
'
object
'
&
&
typeof
b
=
=
'
object
'
)
{
if
(
a
.
constructor
!
=
=
b
.
constructor
)
return
false
;
var
length
i
keys
;
if
(
Array
.
isArray
(
a
)
)
{
length
=
a
.
length
;
if
(
length
!
=
b
.
length
)
return
false
;
for
(
i
=
length
;
i
-
-
!
=
=
0
;
)
if
(
!
equal
(
a
[
i
]
b
[
i
]
)
)
return
false
;
return
true
;
}
if
(
(
a
instanceof
Map
)
&
&
(
b
instanceof
Map
)
)
{
if
(
a
.
size
!
=
=
b
.
size
)
return
false
;
for
(
i
of
a
.
entries
(
)
)
if
(
!
b
.
has
(
i
[
0
]
)
)
return
false
;
for
(
i
of
a
.
entries
(
)
)
if
(
!
equal
(
i
[
1
]
b
.
get
(
i
[
0
]
)
)
)
return
false
;
return
true
;
}
if
(
(
a
instanceof
Set
)
&
&
(
b
instanceof
Set
)
)
{
if
(
a
.
size
!
=
=
b
.
size
)
return
false
;
for
(
i
of
a
.
entries
(
)
)
if
(
!
b
.
has
(
i
[
0
]
)
)
return
false
;
return
true
;
}
if
(
ArrayBuffer
.
isView
(
a
)
&
&
ArrayBuffer
.
isView
(
b
)
)
{
length
=
a
.
length
;
if
(
length
!
=
b
.
length
)
return
false
;
for
(
i
=
length
;
i
-
-
!
=
=
0
;
)
if
(
a
[
i
]
!
=
=
b
[
i
]
)
return
false
;
return
true
;
}
if
(
a
.
constructor
=
=
=
RegExp
)
return
a
.
source
=
=
=
b
.
source
&
&
a
.
flags
=
=
=
b
.
flags
;
if
(
a
.
valueOf
!
=
=
Object
.
prototype
.
valueOf
)
return
a
.
valueOf
(
)
=
=
=
b
.
valueOf
(
)
;
if
(
a
.
toString
!
=
=
Object
.
prototype
.
toString
)
return
a
.
toString
(
)
=
=
=
b
.
toString
(
)
;
keys
=
Object
.
keys
(
a
)
;
length
=
keys
.
length
;
if
(
length
!
=
=
Object
.
keys
(
b
)
.
length
)
return
false
;
for
(
i
=
length
;
i
-
-
!
=
=
0
;
)
if
(
!
Object
.
prototype
.
hasOwnProperty
.
call
(
b
keys
[
i
]
)
)
return
false
;
for
(
i
=
length
;
i
-
-
!
=
=
0
;
)
{
var
key
=
keys
[
i
]
;
if
(
!
equal
(
a
[
key
]
b
[
key
]
)
)
return
false
;
}
return
true
;
}
return
a
!
=
=
a
&
&
b
!
=
=
b
;
}
;
}
)
9602
:
(
(
module
)
=
>
{
module
.
exports
=
flatten
flatten
.
flatten
=
flatten
flatten
.
unflatten
=
unflatten
function
isBuffer
(
obj
)
{
return
obj
&
&
obj
.
constructor
&
&
(
typeof
obj
.
constructor
.
isBuffer
=
=
=
'
function
'
)
&
&
obj
.
constructor
.
isBuffer
(
obj
)
}
function
keyIdentity
(
key
)
{
return
key
}
function
flatten
(
target
opts
)
{
opts
=
opts
|
|
{
}
const
delimiter
=
opts
.
delimiter
|
|
'
.
'
const
maxDepth
=
opts
.
maxDepth
const
transformKey
=
opts
.
transformKey
|
|
keyIdentity
const
output
=
{
}
function
step
(
object
prev
currentDepth
)
{
currentDepth
=
currentDepth
|
|
1
Object
.
keys
(
object
)
.
forEach
(
function
(
key
)
{
const
value
=
object
[
key
]
const
isarray
=
opts
.
safe
&
&
Array
.
isArray
(
value
)
const
type
=
Object
.
prototype
.
toString
.
call
(
value
)
const
isbuffer
=
isBuffer
(
value
)
const
isobject
=
(
type
=
=
=
'
[
object
Object
]
'
|
|
type
=
=
=
'
[
object
Array
]
'
)
const
newKey
=
prev
?
prev
+
delimiter
+
transformKey
(
key
)
:
transformKey
(
key
)
if
(
!
isarray
&
&
!
isbuffer
&
&
isobject
&
&
Object
.
keys
(
value
)
.
length
&
&
(
!
opts
.
maxDepth
|
|
currentDepth
<
maxDepth
)
)
{
return
step
(
value
newKey
currentDepth
+
1
)
}
output
[
newKey
]
=
value
}
)
}
step
(
target
)
return
output
}
function
unflatten
(
target
opts
)
{
opts
=
opts
|
|
{
}
const
delimiter
=
opts
.
delimiter
|
|
'
.
'
const
overwrite
=
opts
.
overwrite
|
|
false
const
transformKey
=
opts
.
transformKey
|
|
keyIdentity
const
result
=
{
}
const
isbuffer
=
isBuffer
(
target
)
if
(
isbuffer
|
|
Object
.
prototype
.
toString
.
call
(
target
)
!
=
=
'
[
object
Object
]
'
)
{
return
target
}
function
getkey
(
key
)
{
const
parsedKey
=
Number
(
key
)
return
(
isNaN
(
parsedKey
)
|
|
key
.
indexOf
(
'
.
'
)
!
=
=
-
1
|
|
opts
.
object
)
?
key
:
parsedKey
}
function
addKeys
(
keyPrefix
recipient
target
)
{
return
Object
.
keys
(
target
)
.
reduce
(
function
(
result
key
)
{
result
[
keyPrefix
+
delimiter
+
key
]
=
target
[
key
]
return
result
}
recipient
)
}
function
isEmpty
(
val
)
{
const
type
=
Object
.
prototype
.
toString
.
call
(
val
)
const
isArray
=
type
=
=
=
'
[
object
Array
]
'
const
isObject
=
type
=
=
=
'
[
object
Object
]
'
if
(
!
val
)
{
return
true
}
else
if
(
isArray
)
{
return
!
val
.
length
}
else
if
(
isObject
)
{
return
!
Object
.
keys
(
val
)
.
length
}
}
target
=
Object
.
keys
(
target
)
.
reduce
(
function
(
result
key
)
{
const
type
=
Object
.
prototype
.
toString
.
call
(
target
[
key
]
)
const
isObject
=
(
type
=
=
=
'
[
object
Object
]
'
|
|
type
=
=
=
'
[
object
Array
]
'
)
if
(
!
isObject
|
|
isEmpty
(
target
[
key
]
)
)
{
result
[
key
]
=
target
[
key
]
return
result
}
else
{
return
addKeys
(
key
result
flatten
(
target
[
key
]
opts
)
)
}
}
{
}
)
Object
.
keys
(
target
)
.
forEach
(
function
(
key
)
{
const
split
=
key
.
split
(
delimiter
)
.
map
(
transformKey
)
let
key1
=
getkey
(
split
.
shift
(
)
)
let
key2
=
getkey
(
split
[
0
]
)
let
recipient
=
result
while
(
key2
!
=
=
undefined
)
{
if
(
key1
=
=
=
'
__proto__
'
)
{
return
}
const
type
=
Object
.
prototype
.
toString
.
call
(
recipient
[
key1
]
)
const
isobject
=
(
type
=
=
=
'
[
object
Object
]
'
|
|
type
=
=
=
'
[
object
Array
]
'
)
if
(
!
overwrite
&
&
!
isobject
&
&
typeof
recipient
[
key1
]
!
=
=
'
undefined
'
)
{
return
}
if
(
(
overwrite
&
&
!
isobject
)
|
|
(
!
overwrite
&
&
recipient
[
key1
]
=
=
null
)
)
{
recipient
[
key1
]
=
(
typeof
key2
=
=
=
'
number
'
&
&
!
opts
.
object
?
[
]
:
{
}
)
}
recipient
=
recipient
[
key1
]
if
(
split
.
length
>
0
)
{
key1
=
getkey
(
split
.
shift
(
)
)
key2
=
getkey
(
split
[
0
]
)
}
}
recipient
[
key1
]
=
unflatten
(
target
[
key
]
opts
)
}
)
return
result
}
}
)
7680
:
(
(
__unused_webpack_module
__webpack_exports__
__webpack_require__
)
=
>
{
"
use
strict
"
;
__webpack_require__
.
r
(
__webpack_exports__
)
;
__webpack_require__
.
d
(
__webpack_exports__
{
"
ActionContextActionType
"
:
(
)
=
>
(
ActionContextActionType
)
"
ActionContextAsyncStepType
"
:
(
)
=
>
(
ActionContextAsyncStepType
)
"
ActionTrackingResult
"
:
(
)
=
>
(
ActionTrackingResult
)
"
ArraySet
"
:
(
)
=
>
(
ArraySet
)
"
ArraySetTypeInfo
"
:
(
)
=
>
(
ArraySetTypeInfo
)
"
ArrayTypeInfo
"
:
(
)
=
>
(
ArrayTypeInfo
)
"
BaseModel
"
:
(
)
=
>
(
BaseModel
)
"
BooleanTypeInfo
"
:
(
)
=
>
(
BooleanTypeInfo
)
"
BuiltInAction
"
:
(
)
=
>
(
BuiltInAction
)
"
Draft
"
:
(
)
=
>
(
Draft
)
"
ExtendedModel
"
:
(
)
=
>
(
ExtendedModel
)
"
Frozen
"
:
(
)
=
>
(
Frozen
)
"
FrozenCheckMode
"
:
(
)
=
>
(
FrozenCheckMode
)
"
FrozenTypeInfo
"
:
(
)
=
>
(
FrozenTypeInfo
)
"
HookAction
"
:
(
)
=
>
(
HookAction
)
"
InternalPatchRecorder
"
:
(
)
=
>
(
InternalPatchRecorder
)
"
LiteralTypeInfo
"
:
(
)
=
>
(
LiteralTypeInfo
)
"
MobxKeystoneError
"
:
(
)
=
>
(
MobxKeystoneError
)
"
Model
"
:
(
)
=
>
(
Model
)
"
ModelAutoTypeCheckingMode
"
:
(
)
=
>
(
ModelAutoTypeCheckingMode
)
"
ModelTypeInfo
"
:
(
)
=
>
(
ModelTypeInfo
)
"
NumberTypeInfo
"
:
(
)
=
>
(
NumberTypeInfo
)
"
ObjectMap
"
:
(
)
=
>
(
ObjectMap
)
"
ObjectMapTypeInfo
"
:
(
)
=
>
(
ObjectMapTypeInfo
)
"
ObjectTypeInfo
"
:
(
)
=
>
(
ObjectTypeInfo
)
"
OrTypeInfo
"
:
(
)
=
>
(
OrTypeInfo
)
"
RecordTypeInfo
"
:
(
)
=
>
(
RecordTypeInfo
)
"
Ref
"
:
(
)
=
>
(
Ref
)
"
RefTypeInfo
"
:
(
)
=
>
(
RefTypeInfo
)
"
RefinementTypeInfo
"
:
(
)
=
>
(
RefinementTypeInfo
)
"
SandboxManager
"
:
(
)
=
>
(
SandboxManager
)
"
StringTypeInfo
"
:
(
)
=
>
(
StringTypeInfo
)
"
TupleTypeInfo
"
:
(
)
=
>
(
TupleTypeInfo
)
"
TypeCheckError
"
:
(
)
=
>
(
TypeCheckError
)
"
TypeInfo
"
:
(
)
=
>
(
TypeInfo
)
"
UncheckedTypeInfo
"
:
(
)
=
>
(
UncheckedTypeInfo
)
"
UndoManager
"
:
(
)
=
>
(
UndoManager
)
"
UndoStore
"
:
(
)
=
>
(
UndoStore
)
"
WalkTreeMode
"
:
(
)
=
>
(
WalkTreeMode
)
"
_async
"
:
(
)
=
>
(
_async
)
"
_await
"
:
(
)
=
>
(
_await
)
"
abstractModelClass
"
:
(
)
=
>
(
abstractModelClass
)
"
actionCallToReduxAction
"
:
(
)
=
>
(
actionCallToReduxAction
)
"
actionTrackingMiddleware
"
:
(
)
=
>
(
actionTrackingMiddleware
)
"
addActionMiddleware
"
:
(
)
=
>
(
addActionMiddleware
)
"
addActionToFnModel
"
:
(
)
=
>
(
addActionToFnModel
)
"
addHiddenProp
"
:
(
)
=
>
(
addHiddenProp
)
"
addLateInitializationFunction
"
:
(
)
=
>
(
addLateInitializationFunction
)
"
applyAction
"
:
(
)
=
>
(
applyAction
)
"
applyDelete
"
:
(
)
=
>
(
applyDelete
)
"
applyMethodCall
"
:
(
)
=
>
(
applyMethodCall
)
"
applyPatches
"
:
(
)
=
>
(
applyPatches
)
"
applySerializedActionAndSyncNewModelIds
"
:
(
)
=
>
(
applySerializedActionAndSyncNewModelIds
)
"
applySerializedActionAndTrackNewModelIds
"
:
(
)
=
>
(
applySerializedActionAndTrackNewModelIds
)
"
applySet
"
:
(
)
=
>
(
applySet
)
"
applySnapshot
"
:
(
)
=
>
(
applySnapshot
)
"
arraySet
"
:
(
)
=
>
(
arraySet
)
"
asMap
"
:
(
)
=
>
(
asMap
)
"
asReduxStore
"
:
(
)
=
>
(
asReduxStore
)
"
asSet
"
:
(
)
=
>
(
asSet
)
"
assertCanWrite
"
:
(
)
=
>
(
assertCanWrite
)
"
assertFnModelKeyNotInUse
"
:
(
)
=
>
(
assertFnModelKeyNotInUse
)
"
assertIsFunction
"
:
(
)
=
>
(
assertIsFunction
)
"
assertIsMap
"
:
(
)
=
>
(
assertIsMap
)
"
assertIsModel
"
:
(
)
=
>
(
assertIsModel
)
"
assertIsModelClass
"
:
(
)
=
>
(
assertIsModelClass
)
"
assertIsObject
"
:
(
)
=
>
(
assertIsObject
)
"
assertIsObservableArray
"
:
(
)
=
>
(
assertIsObservableArray
)
"
assertIsObservableObject
"
:
(
)
=
>
(
assertIsObservableObject
)
"
assertIsPlainObject
"
:
(
)
=
>
(
assertIsPlainObject
)
"
assertIsPrimitive
"
:
(
)
=
>
(
assertIsPrimitive
)
"
assertIsSet
"
:
(
)
=
>
(
assertIsSet
)
"
assertIsString
"
:
(
)
=
>
(
assertIsString
)
"
assertIsTreeNode
"
:
(
)
=
>
(
assertIsTreeNode
)
"
assertTweakedObject
"
:
(
)
=
>
(
assertTweakedObject
)
"
baseModelPropNames
"
:
(
)
=
>
(
baseModelPropNames
)
"
canWrite
"
:
(
)
=
>
(
canWrite
)
"
cannotSerialize
"
:
(
)
=
>
(
cannotSerialize
)
"
checkModelDecoratorArgs
"
:
(
)
=
>
(
checkModelDecoratorArgs
)
"
clone
"
:
(
)
=
>
(
clone
)
"
computedWalkTreeAggregate
"
:
(
)
=
>
(
computedWalkTreeAggregate
)
"
connectReduxDevTools
"
:
(
)
=
>
(
connectReduxDevTools
)
"
createContext
"
:
(
)
=
>
(
createContext
)
"
customRef
"
:
(
)
=
>
(
customRef
)
"
debugFreeze
"
:
(
)
=
>
(
debugFreeze
)
"
decorateWrapMethodOrField
"
:
(
)
=
>
(
decorateWrapMethodOrField
)
"
decoratedModel
"
:
(
)
=
>
(
decoratedModel
)
"
deepEquals
"
:
(
)
=
>
(
deepEquals
)
"
deleteFromArray
"
:
(
)
=
>
(
deleteFromArray
)
"
deserializeActionCall
"
:
(
)
=
>
(
deserializeActionCall
)
"
deserializeActionCallArgument
"
:
(
)
=
>
(
deserializeActionCallArgument
)
"
detach
"
:
(
)
=
>
(
detach
)
"
draft
"
:
(
)
=
>
(
draft
)
"
extendFnModelActions
"
:
(
)
=
>
(
extendFnModelActions
)
"
extendFnModelSetterActions
"
:
(
)
=
>
(
extendFnModelSetterActions
)
"
extendFnModelViews
"
:
(
)
=
>
(
extendFnModelViews
)
"
failure
"
:
(
)
=
>
(
failure
)
"
fastGetParent
"
:
(
)
=
>
(
fastGetParent
)
"
fastGetParentIncludingDataObjects
"
:
(
)
=
>
(
fastGetParentIncludingDataObjects
)
"
fastGetParentPath
"
:
(
)
=
>
(
fastGetParentPath
)
"
fastGetParentPathIncludingDataObjects
"
:
(
)
=
>
(
fastGetParentPathIncludingDataObjects
)
"
fastGetRoot
"
:
(
)
=
>
(
fastGetRoot
)
"
fastGetRootPath
"
:
(
)
=
>
(
fastGetRootPath
)
"
fastGetRootStore
"
:
(
)
=
>
(
fastGetRootStore
)
"
fastIsModelDataObject
"
:
(
)
=
>
(
fastIsModelDataObject
)
"
fastIsRootStore
"
:
(
)
=
>
(
fastIsRootStore
)
"
findParent
"
:
(
)
=
>
(
findParent
)
"
findParentPath
"
:
(
)
=
>
(
findParentPath
)
"
flow
"
:
(
)
=
>
(
flow
)
"
fnArray
"
:
(
)
=
>
(
fnArray
)
"
fnModel
"
:
(
)
=
>
(
fnModel
)
"
fnObject
"
:
(
)
=
>
(
fnObject
)
"
fromSnapshot
"
:
(
)
=
>
(
fromSnapshot
)
"
frozen
"
:
(
)
=
>
(
frozen
)
"
frozenKey
"
:
(
)
=
>
(
frozenKey
)
"
getActionMiddlewares
"
:
(
)
=
>
(
getActionMiddlewares
)
"
getActionProtection
"
:
(
)
=
>
(
getActionProtection
)
"
getChildrenObjects
"
:
(
)
=
>
(
getChildrenObjects
)
"
getCurrentActionContext
"
:
(
)
=
>
(
getCurrentActionContext
)
"
getFnModelAction
"
:
(
)
=
>
(
getFnModelAction
)
"
getGlobalConfig
"
:
(
)
=
>
(
getGlobalConfig
)
"
getMobxVersion
"
:
(
)
=
>
(
getMobxVersion
)
"
getModelDataType
"
:
(
)
=
>
(
getModelDataType
)
"
getModelRefId
"
:
(
)
=
>
(
getModelRefId
)
"
getNodeSandboxManager
"
:
(
)
=
>
(
getNodeSandboxManager
)
"
getParent
"
:
(
)
=
>
(
getParent
)
"
getParentPath
"
:
(
)
=
>
(
getParentPath
)
"
getParentToChildPath
"
:
(
)
=
>
(
getParentToChildPath
)
"
getRefsResolvingTo
"
:
(
)
=
>
(
getRefsResolvingTo
)
"
getRoot
"
:
(
)
=
>
(
getRoot
)
"
getRootPath
"
:
(
)
=
>
(
getRootPath
)
"
getRootStore
"
:
(
)
=
>
(
getRootStore
)
"
getSnapshot
"
:
(
)
=
>
(
getSnapshot
)
"
getTypeInfo
"
:
(
)
=
>
(
getTypeInfo
)
"
inDevMode
"
:
(
)
=
>
(
inDevMode
)
"
instanceCreationDataTypeSymbol
"
:
(
)
=
>
(
instanceCreationDataTypeSymbol
)
"
instanceDataTypeSymbol
"
:
(
)
=
>
(
instanceDataTypeSymbol
)
"
internalApplyDelete
"
:
(
)
=
>
(
internalApplyDelete
)
"
internalApplyMethodCall
"
:
(
)
=
>
(
internalApplyMethodCall
)
"
internalApplyPatches
"
:
(
)
=
>
(
internalApplyPatches
)
"
internalCustomRef
"
:
(
)
=
>
(
internalCustomRef
)
"
internalPatchRecorder
"
:
(
)
=
>
(
internalPatchRecorder
)
"
isArray
"
:
(
)
=
>
(
isArray
)
"
isBuiltInAction
"
:
(
)
=
>
(
isBuiltInAction
)
"
isChildOfParent
"
:
(
)
=
>
(
isChildOfParent
)
"
isFrozenSnapshot
"
:
(
)
=
>
(
isFrozenSnapshot
)
"
isHookAction
"
:
(
)
=
>
(
isHookAction
)
"
isMap
"
:
(
)
=
>
(
isMap
)
"
isModel
"
:
(
)
=
>
(
isModel
)
"
isModelAction
"
:
(
)
=
>
(
isModelAction
)
"
isModelAutoTypeCheckingEnabled
"
:
(
)
=
>
(
isModelAutoTypeCheckingEnabled
)
"
isModelClass
"
:
(
)
=
>
(
isModelClass
)
"
isModelDataObject
"
:
(
)
=
>
(
isModelDataObject
)
"
isModelFlow
"
:
(
)
=
>
(
isModelFlow
)
"
isModelSnapshot
"
:
(
)
=
>
(
isModelSnapshot
)
"
isObject
"
:
(
)
=
>
(
isObject
)
"
isParentOfChild
"
:
(
)
=
>
(
isParentOfChild
)
"
isPlainObject
"
:
(
)
=
>
(
isPlainObject
)
"
isPrimitive
"
:
(
)
=
>
(
isPrimitive
)
"
isRefOfType
"
:
(
)
=
>
(
isRefOfType
)
"
isReservedModelKey
"
:
(
)
=
>
(
isReservedModelKey
)
"
isRoot
"
:
(
)
=
>
(
isRoot
)
"
isRootStore
"
:
(
)
=
>
(
isRootStore
)
"
isSandboxedNode
"
:
(
)
=
>
(
isSandboxedNode
)
"
isSet
"
:
(
)
=
>
(
isSet
)
"
isTreeNode
"
:
(
)
=
>
(
isTreeNode
)
"
isTweakedObject
"
:
(
)
=
>
(
isTweakedObject
)
"
jsonPatchToPatch
"
:
(
)
=
>
(
jsonPatchToPatch
)
"
jsonPointerToPath
"
:
(
)
=
>
(
jsonPointerToPath
)
"
lateVal
"
:
(
)
=
>
(
lateVal
)
"
lazy
"
:
(
)
=
>
(
lazy
)
"
logWarning
"
:
(
)
=
>
(
logWarning
)
"
makePropReadonly
"
:
(
)
=
>
(
makePropReadonly
)
"
mapToArray
"
:
(
)
=
>
(
mapToArray
)
"
mapToObject
"
:
(
)
=
>
(
mapToObject
)
"
model
"
:
(
)
=
>
(
model
)
"
modelAction
"
:
(
)
=
>
(
modelAction
)
"
modelClass
"
:
(
)
=
>
(
modelClass
)
"
modelFlow
"
:
(
)
=
>
(
modelFlow
)
"
modelIdKey
"
:
(
)
=
>
(
modelIdKey
)
"
modelInitializedSymbol
"
:
(
)
=
>
(
modelInitializedSymbol
)
"
modelSnapshotInWithMetadata
"
:
(
)
=
>
(
modelSnapshotInWithMetadata
)
"
modelSnapshotOutWithMetadata
"
:
(
)
=
>
(
modelSnapshotOutWithMetadata
)
"
modelTypeKey
"
:
(
)
=
>
(
modelTypeKey
)
"
noDefaultValue
"
:
(
)
=
>
(
noDefaultValue
)
"
objectMap
"
:
(
)
=
>
(
objectMap
)
"
onActionMiddleware
"
:
(
)
=
>
(
onActionMiddleware
)
"
onChildAttachedTo
"
:
(
)
=
>
(
onChildAttachedTo
)
"
onGlobalPatches
"
:
(
)
=
>
(
onGlobalPatches
)
"
onPatches
"
:
(
)
=
>
(
onPatches
)
"
onSnapshot
"
:
(
)
=
>
(
onSnapshot
)
"
patchRecorder
"
:
(
)
=
>
(
patchRecorder
)
"
patchToJsonPatch
"
:
(
)
=
>
(
patchToJsonPatch
)
"
pathToJsonPointer
"
:
(
)
=
>
(
pathToJsonPointer
)
"
prop
"
:
(
)
=
>
(
prop
)
"
propTransform
"
:
(
)
=
>
(
propTransform
)
"
prop_dateString
"
:
(
)
=
>
(
prop_dateString
)
"
prop_dateTimestamp
"
:
(
)
=
>
(
prop_dateTimestamp
)
"
prop_mapArray
"
:
(
)
=
>
(
prop_mapArray
)
"
prop_mapObject
"
:
(
)
=
>
(
prop_mapObject
)
"
prop_setArray
"
:
(
)
=
>
(
prop_setArray
)
"
propsCreationDataTypeSymbol
"
:
(
)
=
>
(
propsCreationDataTypeSymbol
)
"
propsDataTypeSymbol
"
:
(
)
=
>
(
propsDataTypeSymbol
)
"
readonlyMiddleware
"
:
(
)
=
>
(
readonlyMiddleware
)
"
reduxActionType
"
:
(
)
=
>
(
reduxActionType
)
"
registerActionCallArgumentSerializer
"
:
(
)
=
>
(
registerActionCallArgumentSerializer
)
"
registerRootStore
"
:
(
)
=
>
(
registerRootStore
)
"
resolvePath
"
:
(
)
=
>
(
resolvePath
)
"
resolvePathCheckingIds
"
:
(
)
=
>
(
resolvePathCheckingIds
)
"
rootRef
"
:
(
)
=
>
(
rootRef
)
"
runLateInitializationFunctions
"
:
(
)
=
>
(
runLateInitializationFunctions
)
"
runUnprotected
"
:
(
)
=
>
(
runUnprotected
)
"
runWithoutSnapshotOrPatches
"
:
(
)
=
>
(
runWithoutSnapshotOrPatches
)
"
runningWithoutSnapshotOrPatches
"
:
(
)
=
>
(
runningWithoutSnapshotOrPatches
)
"
sandbox
"
:
(
)
=
>
(
sandbox
)
"
serializeActionCall
"
:
(
)
=
>
(
serializeActionCall
)
"
serializeActionCallArgument
"
:
(
)
=
>
(
serializeActionCallArgument
)
"
setCurrentActionContext
"
:
(
)
=
>
(
setCurrentActionContext
)
"
setGlobalConfig
"
:
(
)
=
>
(
setGlobalConfig
)
"
setToArray
"
:
(
)
=
>
(
setToArray
)
"
simplifyActionContext
"
:
(
)
=
>
(
simplifyActionContext
)
"
skipIdChecking
"
:
(
)
=
>
(
skipIdChecking
)
"
stringAsDate
"
:
(
)
=
>
(
stringAsDate
)
"
tProp
"
:
(
)
=
>
(
tProp
)
"
tProp_dateString
"
:
(
)
=
>
(
tProp_dateString
)
"
tProp_dateTimestamp
"
:
(
)
=
>
(
tProp_dateTimestamp
)
"
tProp_mapArray
"
:
(
)
=
>
(
tProp_mapArray
)
"
tProp_mapObject
"
:
(
)
=
>
(
tProp_mapObject
)
"
tProp_setArray
"
:
(
)
=
>
(
tProp_setArray
)
"
tag
"
:
(
)
=
>
(
tag
)
"
timestampAsDate
"
:
(
)
=
>
(
timestampAsDate
)
"
toTreeNode
"
:
(
)
=
>
(
toTreeNode
)
"
transaction
"
:
(
)
=
>
(
transaction
)
"
transactionMiddleware
"
:
(
)
=
>
(
transactionMiddleware
)
"
tryUntweak
"
:
(
)
=
>
(
tryUntweak
)
"
tweak
"
:
(
)
=
>
(
tweak
)
"
tweakedObjects
"
:
(
)
=
>
(
tweakedObjects
)
"
typeCheck
"
:
(
)
=
>
(
typeCheck
)
"
types
"
:
(
)
=
>
(
types
)
"
undoMiddleware
"
:
(
)
=
>
(
undoMiddleware
)
"
unregisterRootStore
"
:
(
)
=
>
(
unregisterRootStore
)
"
walkTree
"
:
(
)
=
>
(
walkTree
)
"
withoutUndo
"
:
(
)
=
>
(
withoutUndo
)
}
)
;
var
mobx_esm
=
__webpack_require__
(
9637
)
;
;
var
getRandomValues
=
typeof
crypto
!
=
=
'
undefined
'
&
&
crypto
.
getRandomValues
&
&
crypto
.
getRandomValues
.
bind
(
crypto
)
|
|
typeof
msCrypto
!
=
=
'
undefined
'
&
&
typeof
msCrypto
.
getRandomValues
=
=
=
'
function
'
&
&
msCrypto
.
getRandomValues
.
bind
(
msCrypto
)
;
var
rnds8
=
new
Uint8Array
(
16
)
;
function
rng
(
)
{
if
(
!
getRandomValues
)
{
throw
new
Error
(
'
crypto
.
getRandomValues
(
)
not
supported
.
See
https
:
/
/
github
.
com
/
uuidjs
/
uuid
#
getrandomvalues
-
not
-
supported
'
)
;
}
return
getRandomValues
(
rnds8
)
;
}
;
const
regex
=
(
/
^
(
?
:
[
0
-
9a
-
f
]
{
8
}
-
[
0
-
9a
-
f
]
{
4
}
-
[
1
-
5
]
[
0
-
9a
-
f
]
{
3
}
-
[
89ab
]
[
0
-
9a
-
f
]
{
3
}
-
[
0
-
9a
-
f
]
{
12
}
|
00000000
-
0000
-
0000
-
0000
-
000000000000
)
/
i
)
;
;
function
validate
(
uuid
)
{
return
typeof
uuid
=
=
=
'
string
'
&
&
regex
.
test
(
uuid
)
;
}
const
esm_browser_validate
=
(
validate
)
;
;
var
byteToHex
=
[
]
;
for
(
var
i
=
0
;
i
<
256
;
+
+
i
)
{
byteToHex
.
push
(
(
i
+
0x100
)
.
toString
(
16
)
.
substr
(
1
)
)
;
}
function
stringify
(
arr
)
{
var
offset
=
arguments
.
length
>
1
&
&
arguments
[
1
]
!
=
=
undefined
?
arguments
[
1
]
:
0
;
var
uuid
=
(
byteToHex
[
arr
[
offset
+
0
]
]
+
byteToHex
[
arr
[
offset
+
1
]
]
+
byteToHex
[
arr
[
offset
+
2
]
]
+
byteToHex
[
arr
[
offset
+
3
]
]
+
'
-
'
+
byteToHex
[
arr
[
offset
+
4
]
]
+
byteToHex
[
arr
[
offset
+
5
]
]
+
'
-
'
+
byteToHex
[
arr
[
offset
+
6
]
]
+
byteToHex
[
arr
[
offset
+
7
]
]
+
'
-
'
+
byteToHex
[
arr
[
offset
+
8
]
]
+
byteToHex
[
arr
[
offset
+
9
]
]
+
'
-
'
+
byteToHex
[
arr
[
offset
+
10
]
]
+
byteToHex
[
arr
[
offset
+
11
]
]
+
byteToHex
[
arr
[
offset
+
12
]
]
+
byteToHex
[
arr
[
offset
+
13
]
]
+
byteToHex
[
arr
[
offset
+
14
]
]
+
byteToHex
[
arr
[
offset
+
15
]
]
)
.
toLowerCase
(
)
;
if
(
!
esm_browser_validate
(
uuid
)
)
{
throw
TypeError
(
'
Stringified
UUID
is
invalid
'
)
;
}
return
uuid
;
}
const
esm_browser_stringify
=
(
stringify
)
;
;
function
v4
(
options
buf
offset
)
{
options
=
options
|
|
{
}
;
var
rnds
=
options
.
random
|
|
(
options
.
rng
|
|
rng
)
(
)
;
rnds
[
6
]
=
rnds
[
6
]
&
0x0f
|
0x40
;
rnds
[
8
]
=
rnds
[
8
]
&
0x3f
|
0x80
;
if
(
buf
)
{
offset
=
offset
|
|
0
;
for
(
var
i
=
0
;
i
<
16
;
+
+
i
)
{
buf
[
offset
+
i
]
=
rnds
[
i
]
;
}
return
buf
;
}
return
esm_browser_stringify
(
rnds
)
;
}
const
esm_browser_v4
=
(
v4
)
;
;
var
extendStatics
=
function
(
d
b
)
{
extendStatics
=
Object
.
setPrototypeOf
|
|
(
{
__proto__
:
[
]
}
instanceof
Array
&
&
function
(
d
b
)
{
d
.
__proto__
=
b
;
}
)
|
|
function
(
d
b
)
{
for
(
var
p
in
b
)
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
b
p
)
)
d
[
p
]
=
b
[
p
]
;
}
;
return
extendStatics
(
d
b
)
;
}
;
function
__extends
(
d
b
)
{
extendStatics
(
d
b
)
;
function
__
(
)
{
this
.
constructor
=
d
;
}
d
.
prototype
=
b
=
=
=
null
?
Object
.
create
(
b
)
:
(
__
.
prototype
=
b
.
prototype
new
__
(
)
)
;
}
var
__assign
=
function
(
)
{
__assign
=
Object
.
assign
|
|
function
__assign
(
t
)
{
for
(
var
s
i
=
1
n
=
arguments
.
length
;
i
<
n
;
i
+
+
)
{
s
=
arguments
[
i
]
;
for
(
var
p
in
s
)
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
s
p
)
)
t
[
p
]
=
s
[
p
]
;
}
return
t
;
}
return
__assign
.
apply
(
this
arguments
)
;
}
function
__rest
(
s
e
)
{
var
t
=
{
}
;
for
(
var
p
in
s
)
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
s
p
)
&
&
e
.
indexOf
(
p
)
<
0
)
t
[
p
]
=
s
[
p
]
;
if
(
s
!
=
null
&
&
typeof
Object
.
getOwnPropertySymbols
=
=
=
"
function
"
)
for
(
var
i
=
0
p
=
Object
.
getOwnPropertySymbols
(
s
)
;
i
<
p
.
length
;
i
+
+
)
{
if
(
e
.
indexOf
(
p
[
i
]
)
<
0
&
&
Object
.
prototype
.
propertyIsEnumerable
.
call
(
s
p
[
i
]
)
)
t
[
p
[
i
]
]
=
s
[
p
[
i
]
]
;
}
return
t
;
}
function
__decorate
(
decorators
target
key
desc
)
{
var
c
=
arguments
.
length
r
=
c
<
3
?
target
:
desc
=
=
=
null
?
desc
=
Object
.
getOwnPropertyDescriptor
(
target
key
)
:
desc
d
;
if
(
typeof
Reflect
=
=
=
"
object
"
&
&
typeof
Reflect
.
decorate
=
=
=
"
function
"
)
r
=
Reflect
.
decorate
(
decorators
target
key
desc
)
;
else
for
(
var
i
=
decorators
.
length
-
1
;
i
>
=
0
;
i
-
-
)
if
(
d
=
decorators
[
i
]
)
r
=
(
c
<
3
?
d
(
r
)
:
c
>
3
?
d
(
target
key
r
)
:
d
(
target
key
)
)
|
|
r
;
return
c
>
3
&
&
r
&
&
Object
.
defineProperty
(
target
key
r
)
r
;
}
function
__param
(
paramIndex
decorator
)
{
return
function
(
target
key
)
{
decorator
(
target
key
paramIndex
)
;
}
}
function
__metadata
(
metadataKey
metadataValue
)
{
if
(
typeof
Reflect
=
=
=
"
object
"
&
&
typeof
Reflect
.
metadata
=
=
=
"
function
"
)
return
Reflect
.
metadata
(
metadataKey
metadataValue
)
;
}
function
__awaiter
(
thisArg
_arguments
P
generator
)
{
function
adopt
(
value
)
{
return
value
instanceof
P
?
value
:
new
P
(
function
(
resolve
)
{
resolve
(
value
)
;
}
)
;
}
return
new
(
P
|
|
(
P
=
Promise
)
)
(
function
(
resolve
reject
)
{
function
fulfilled
(
value
)
{
try
{
step
(
generator
.
next
(
value
)
)
;
}
catch
(
e
)
{
reject
(
e
)
;
}
}
function
rejected
(
value
)
{
try
{
step
(
generator
[
"
throw
"
]
(
value
)
)
;
}
catch
(
e
)
{
reject
(
e
)
;
}
}
function
step
(
result
)
{
result
.
done
?
resolve
(
result
.
value
)
:
adopt
(
result
.
value
)
.
then
(
fulfilled
rejected
)
;
}
step
(
(
generator
=
generator
.
apply
(
thisArg
_arguments
|
|
[
]
)
)
.
next
(
)
)
;
}
)
;
}
function
__generator
(
thisArg
body
)
{
var
_
=
{
label
:
0
sent
:
function
(
)
{
if
(
t
[
0
]
&
1
)
throw
t
[
1
]
;
return
t
[
1
]
;
}
trys
:
[
]
ops
:
[
]
}
f
y
t
g
;
return
g
=
{
next
:
verb
(
0
)
"
throw
"
:
verb
(
1
)
"
return
"
:
verb
(
2
)
}
typeof
Symbol
=
=
=
"
function
"
&
&
(
g
[
Symbol
.
iterator
]
=
function
(
)
{
return
this
;
}
)
g
;
function
verb
(
n
)
{
return
function
(
v
)
{
return
step
(
[
n
v
]
)
;
}
;
}
function
step
(
op
)
{
if
(
f
)
throw
new
TypeError
(
"
Generator
is
already
executing
.
"
)
;
while
(
_
)
try
{
if
(
f
=
1
y
&
&
(
t
=
op
[
0
]
&
2
?
y
[
"
return
"
]
:
op
[
0
]
?
y
[
"
throw
"
]
|
|
(
(
t
=
y
[
"
return
"
]
)
&
&
t
.
call
(
y
)
0
)
:
y
.
next
)
&
&
!
(
t
=
t
.
call
(
y
op
[
1
]
)
)
.
done
)
return
t
;
if
(
y
=
0
t
)
op
=
[
op
[
0
]
&
2
t
.
value
]
;
switch
(
op
[
0
]
)
{
case
0
:
case
1
:
t
=
op
;
break
;
case
4
:
_
.
label
+
+
;
return
{
value
:
op
[
1
]
done
:
false
}
;
case
5
:
_
.
label
+
+
;
y
=
op
[
1
]
;
op
=
[
0
]
;
continue
;
case
7
:
op
=
_
.
ops
.
pop
(
)
;
_
.
trys
.
pop
(
)
;
continue
;
default
:
if
(
!
(
t
=
_
.
trys
t
=
t
.
length
>
0
&
&
t
[
t
.
length
-
1
]
)
&
&
(
op
[
0
]
=
=
=
6
|
|
op
[
0
]
=
=
=
2
)
)
{
_
=
0
;
continue
;
}
if
(
op
[
0
]
=
=
=
3
&
&
(
!
t
|
|
(
op
[
1
]
>
t
[
0
]
&
&
op
[
1
]
<
t
[
3
]
)
)
)
{
_
.
label
=
op
[
1
]
;
break
;
}
if
(
op
[
0
]
=
=
=
6
&
&
_
.
label
<
t
[
1
]
)
{
_
.
label
=
t
[
1
]
;
t
=
op
;
break
;
}
if
(
t
&
&
_
.
label
<
t
[
2
]
)
{
_
.
label
=
t
[
2
]
;
_
.
ops
.
push
(
op
)
;
break
;
}
if
(
t
[
2
]
)
_
.
ops
.
pop
(
)
;
_
.
trys
.
pop
(
)
;
continue
;
}
op
=
body
.
call
(
thisArg
_
)
;
}
catch
(
e
)
{
op
=
[
6
e
]
;
y
=
0
;
}
finally
{
f
=
t
=
0
;
}
if
(
op
[
0
]
&
5
)
throw
op
[
1
]
;
return
{
value
:
op
[
0
]
?
op
[
1
]
:
void
0
done
:
true
}
;
}
}
var
__createBinding
=
Object
.
create
?
(
function
(
o
m
k
k2
)
{
if
(
k2
=
=
=
undefined
)
k2
=
k
;
Object
.
defineProperty
(
o
k2
{
enumerable
:
true
get
:
function
(
)
{
return
m
[
k
]
;
}
}
)
;
}
)
:
(
function
(
o
m
k
k2
)
{
if
(
k2
=
=
=
undefined
)
k2
=
k
;
o
[
k2
]
=
m
[
k
]
;
}
)
;
function
__exportStar
(
m
o
)
{
for
(
var
p
in
m
)
if
(
p
!
=
=
"
default
"
&
&
!
Object
.
prototype
.
hasOwnProperty
.
call
(
o
p
)
)
__createBinding
(
o
m
p
)
;
}
function
__values
(
o
)
{
var
s
=
typeof
Symbol
=
=
=
"
function
"
&
&
Symbol
.
iterator
m
=
s
&
&
o
[
s
]
i
=
0
;
if
(
m
)
return
m
.
call
(
o
)
;
if
(
o
&
&
typeof
o
.
length
=
=
=
"
number
"
)
return
{
next
:
function
(
)
{
if
(
o
&
&
i
>
=
o
.
length
)
o
=
void
0
;
return
{
value
:
o
&
&
o
[
i
+
+
]
done
:
!
o
}
;
}
}
;
throw
new
TypeError
(
s
?
"
Object
is
not
iterable
.
"
:
"
Symbol
.
iterator
is
not
defined
.
"
)
;
}
function
__read
(
o
n
)
{
var
m
=
typeof
Symbol
=
=
=
"
function
"
&
&
o
[
Symbol
.
iterator
]
;
if
(
!
m
)
return
o
;
var
i
=
m
.
call
(
o
)
r
ar
=
[
]
e
;
try
{
while
(
(
n
=
=
=
void
0
|
|
n
-
-
>
0
)
&
&
!
(
r
=
i
.
next
(
)
)
.
done
)
ar
.
push
(
r
.
value
)
;
}
catch
(
error
)
{
e
=
{
error
:
error
}
;
}
finally
{
try
{
if
(
r
&
&
!
r
.
done
&
&
(
m
=
i
[
"
return
"
]
)
)
m
.
call
(
i
)
;
}
finally
{
if
(
e
)
throw
e
.
error
;
}
}
return
ar
;
}
function
__spread
(
)
{
for
(
var
ar
=
[
]
i
=
0
;
i
<
arguments
.
length
;
i
+
+
)
ar
=
ar
.
concat
(
__read
(
arguments
[
i
]
)
)
;
return
ar
;
}
function
__spreadArrays
(
)
{
for
(
var
s
=
0
i
=
0
il
=
arguments
.
length
;
i
<
il
;
i
+
+
)
s
+
=
arguments
[
i
]
.
length
;
for
(
var
r
=
Array
(
s
)
k
=
0
i
=
0
;
i
<
il
;
i
+
+
)
for
(
var
a
=
arguments
[
i
]
j
=
0
jl
=
a
.
length
;
j
<
jl
;
j
+
+
k
+
+
)
r
[
k
]
=
a
[
j
]
;
return
r
;
}
;
function
__await
(
v
)
{
return
this
instanceof
__await
?
(
this
.
v
=
v
this
)
:
new
__await
(
v
)
;
}
function
__asyncGenerator
(
thisArg
_arguments
generator
)
{
if
(
!
Symbol
.
asyncIterator
)
throw
new
TypeError
(
"
Symbol
.
asyncIterator
is
not
defined
.
"
)
;
var
g
=
generator
.
apply
(
thisArg
_arguments
|
|
[
]
)
i
q
=
[
]
;
return
i
=
{
}
verb
(
"
next
"
)
verb
(
"
throw
"
)
verb
(
"
return
"
)
i
[
Symbol
.
asyncIterator
]
=
function
(
)
{
return
this
;
}
i
;
function
verb
(
n
)
{
if
(
g
[
n
]
)
i
[
n
]
=
function
(
v
)
{
return
new
Promise
(
function
(
a
b
)
{
q
.
push
(
[
n
v
a
b
]
)
>
1
|
|
resume
(
n
v
)
;
}
)
;
}
;
}
function
resume
(
n
v
)
{
try
{
step
(
g
[
n
]
(
v
)
)
;
}
catch
(
e
)
{
settle
(
q
[
0
]
[
3
]
e
)
;
}
}
function
step
(
r
)
{
r
.
value
instanceof
__await
?
Promise
.
resolve
(
r
.
value
.
v
)
.
then
(
fulfill
reject
)
:
settle
(
q
[
0
]
[
2
]
r
)
;
}
function
fulfill
(
value
)
{
resume
(
"
next
"
value
)
;
}
function
reject
(
value
)
{
resume
(
"
throw
"
value
)
;
}
function
settle
(
f
v
)
{
if
(
f
(
v
)
q
.
shift
(
)
q
.
length
)
resume
(
q
[
0
]
[
0
]
q
[
0
]
[
1
]
)
;
}
}
function
__asyncDelegator
(
o
)
{
var
i
p
;
return
i
=
{
}
verb
(
"
next
"
)
verb
(
"
throw
"
function
(
e
)
{
throw
e
;
}
)
verb
(
"
return
"
)
i
[
Symbol
.
iterator
]
=
function
(
)
{
return
this
;
}
i
;
function
verb
(
n
f
)
{
i
[
n
]
=
o
[
n
]
?
function
(
v
)
{
return
(
p
=
!
p
)
?
{
value
:
__await
(
o
[
n
]
(
v
)
)
done
:
n
=
=
=
"
return
"
}
:
f
?
f
(
v
)
:
v
;
}
:
f
;
}
}
function
__asyncValues
(
o
)
{
if
(
!
Symbol
.
asyncIterator
)
throw
new
TypeError
(
"
Symbol
.
asyncIterator
is
not
defined
.
"
)
;
var
m
=
o
[
Symbol
.
asyncIterator
]
i
;
return
m
?
m
.
call
(
o
)
:
(
o
=
typeof
__values
=
=
=
"
function
"
?
__values
(
o
)
:
o
[
Symbol
.
iterator
]
(
)
i
=
{
}
verb
(
"
next
"
)
verb
(
"
throw
"
)
verb
(
"
return
"
)
i
[
Symbol
.
asyncIterator
]
=
function
(
)
{
return
this
;
}
i
)
;
function
verb
(
n
)
{
i
[
n
]
=
o
[
n
]
&
&
function
(
v
)
{
return
new
Promise
(
function
(
resolve
reject
)
{
v
=
o
[
n
]
(
v
)
settle
(
resolve
reject
v
.
done
v
.
value
)
;
}
)
;
}
;
}
function
settle
(
resolve
reject
d
v
)
{
Promise
.
resolve
(
v
)
.
then
(
function
(
v
)
{
resolve
(
{
value
:
v
done
:
d
}
)
;
}
reject
)
;
}
}
function
__makeTemplateObject
(
cooked
raw
)
{
if
(
Object
.
defineProperty
)
{
Object
.
defineProperty
(
cooked
"
raw
"
{
value
:
raw
}
)
;
}
else
{
cooked
.
raw
=
raw
;
}
return
cooked
;
}
;
var
__setModuleDefault
=
Object
.
create
?
(
function
(
o
v
)
{
Object
.
defineProperty
(
o
"
default
"
{
enumerable
:
true
value
:
v
}
)
;
}
)
:
function
(
o
v
)
{
o
[
"
default
"
]
=
v
;
}
;
function
__importStar
(
mod
)
{
if
(
mod
&
&
mod
.
__esModule
)
return
mod
;
var
result
=
{
}
;
if
(
mod
!
=
null
)
for
(
var
k
in
mod
)
if
(
k
!
=
=
"
default
"
&
&
Object
.
prototype
.
hasOwnProperty
.
call
(
mod
k
)
)
__createBinding
(
result
mod
k
)
;
__setModuleDefault
(
result
mod
)
;
return
result
;
}
function
__importDefault
(
mod
)
{
return
(
mod
&
&
mod
.
__esModule
)
?
mod
:
{
default
:
mod
}
;
}
function
__classPrivateFieldGet
(
receiver
privateMap
)
{
if
(
!
privateMap
.
has
(
receiver
)
)
{
throw
new
TypeError
(
"
attempted
to
get
private
field
on
non
-
instance
"
)
;
}
return
privateMap
.
get
(
receiver
)
;
}
function
__classPrivateFieldSet
(
receiver
privateMap
value
)
{
if
(
!
privateMap
.
has
(
receiver
)
)
{
throw
new
TypeError
(
"
attempted
to
set
private
field
on
non
-
instance
"
)
;
}
privateMap
.
set
(
receiver
value
)
;
return
value
;
}
var
es6
=
__webpack_require__
(
4050
)
;
var
es6_default
=
__webpack_require__
.
n
(
es6
)
;
;
var
ActionContextActionType
;
(
function
(
ActionContextActionType
)
{
ActionContextActionType
[
"
Sync
"
]
=
"
sync
"
;
ActionContextActionType
[
"
Async
"
]
=
"
async
"
;
}
)
(
ActionContextActionType
|
|
(
ActionContextActionType
=
{
}
)
)
;
var
ActionContextAsyncStepType
;
(
function
(
ActionContextAsyncStepType
)
{
ActionContextAsyncStepType
[
"
Spawn
"
]
=
"
spawn
"
;
ActionContextAsyncStepType
[
"
Return
"
]
=
"
return
"
;
ActionContextAsyncStepType
[
"
Resume
"
]
=
"
resume
"
;
ActionContextAsyncStepType
[
"
ResumeError
"
]
=
"
resumeError
"
;
ActionContextAsyncStepType
[
"
Throw
"
]
=
"
throw
"
;
}
)
(
ActionContextAsyncStepType
|
|
(
ActionContextAsyncStepType
=
{
}
)
)
;
var
currentActionContext
;
function
getCurrentActionContext
(
)
{
return
currentActionContext
;
}
function
setCurrentActionContext
(
ctx
)
{
currentActionContext
=
ctx
;
}
function
_defineProperties
(
target
props
)
{
for
(
var
i
=
0
;
i
<
props
.
length
;
i
+
+
)
{
var
descriptor
=
props
[
i
]
;
descriptor
.
enumerable
=
descriptor
.
enumerable
|
|
false
;
descriptor
.
configurable
=
true
;
if
(
"
value
"
in
descriptor
)
descriptor
.
writable
=
true
;
Object
.
defineProperty
(
target
descriptor
.
key
descriptor
)
;
}
}
function
_createClass
(
Constructor
protoProps
staticProps
)
{
if
(
protoProps
)
_defineProperties
(
Constructor
.
prototype
protoProps
)
;
if
(
staticProps
)
_defineProperties
(
Constructor
staticProps
)
;
return
Constructor
;
}
function
_extends
(
)
{
_extends
=
Object
.
assign
|
|
function
(
target
)
{
for
(
var
i
=
1
;
i
<
arguments
.
length
;
i
+
+
)
{
var
source
=
arguments
[
i
]
;
for
(
var
key
in
source
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
source
key
)
)
{
target
[
key
]
=
source
[
key
]
;
}
}
}
return
target
;
}
;
return
_extends
.
apply
(
this
arguments
)
;
}
function
_inheritsLoose
(
subClass
superClass
)
{
subClass
.
prototype
=
Object
.
create
(
superClass
.
prototype
)
;
subClass
.
prototype
.
constructor
=
subClass
;
subClass
.
__proto__
=
superClass
;
}
function
_getPrototypeOf
(
o
)
{
_getPrototypeOf
=
Object
.
setPrototypeOf
?
Object
.
getPrototypeOf
:
function
_getPrototypeOf
(
o
)
{
return
o
.
__proto__
|
|
Object
.
getPrototypeOf
(
o
)
;
}
;
return
_getPrototypeOf
(
o
)
;
}
function
_setPrototypeOf
(
o
p
)
{
_setPrototypeOf
=
Object
.
setPrototypeOf
|
|
function
_setPrototypeOf
(
o
p
)
{
o
.
__proto__
=
p
;
return
o
;
}
;
return
_setPrototypeOf
(
o
p
)
;
}
function
_isNativeReflectConstruct
(
)
{
if
(
typeof
Reflect
=
=
=
"
undefined
"
|
|
!
Reflect
.
construct
)
return
false
;
if
(
Reflect
.
construct
.
sham
)
return
false
;
if
(
typeof
Proxy
=
=
=
"
function
"
)
return
true
;
try
{
Date
.
prototype
.
toString
.
call
(
Reflect
.
construct
(
Date
[
]
function
(
)
{
}
)
)
;
return
true
;
}
catch
(
e
)
{
return
false
;
}
}
function
_construct
(
Parent
args
Class
)
{
if
(
_isNativeReflectConstruct
(
)
)
{
_construct
=
Reflect
.
construct
;
}
else
{
_construct
=
function
_construct
(
Parent
args
Class
)
{
var
a
=
[
null
]
;
a
.
push
.
apply
(
a
args
)
;
var
Constructor
=
Function
.
bind
.
apply
(
Parent
a
)
;
var
instance
=
new
Constructor
(
)
;
if
(
Class
)
_setPrototypeOf
(
instance
Class
.
prototype
)
;
return
instance
;
}
;
}
return
_construct
.
apply
(
null
arguments
)
;
}
function
_isNativeFunction
(
fn
)
{
return
Function
.
toString
.
call
(
fn
)
.
indexOf
(
"
[
native
code
]
"
)
!
=
=
-
1
;
}
function
_wrapNativeSuper
(
Class
)
{
var
_cache
=
typeof
Map
=
=
=
"
function
"
?
new
Map
(
)
:
undefined
;
_wrapNativeSuper
=
function
_wrapNativeSuper
(
Class
)
{
if
(
Class
=
=
=
null
|
|
!
_isNativeFunction
(
Class
)
)
return
Class
;
if
(
typeof
Class
!
=
=
"
function
"
)
{
throw
new
TypeError
(
"
Super
expression
must
either
be
null
or
a
function
"
)
;
}
if
(
typeof
_cache
!
=
=
"
undefined
"
)
{
if
(
_cache
.
has
(
Class
)
)
return
_cache
.
get
(
Class
)
;
_cache
.
set
(
Class
Wrapper
)
;
}
function
Wrapper
(
)
{
return
_construct
(
Class
arguments
_getPrototypeOf
(
this
)
.
constructor
)
;
}
Wrapper
.
prototype
=
Object
.
create
(
Class
.
prototype
{
constructor
:
{
value
:
Wrapper
enumerable
:
false
writable
:
true
configurable
:
true
}
}
)
;
return
_setPrototypeOf
(
Wrapper
Class
)
;
}
;
return
_wrapNativeSuper
(
Class
)
;
}
function
_assertThisInitialized
(
self
)
{
if
(
self
=
=
=
void
0
)
{
throw
new
ReferenceError
(
"
this
hasn
'
t
been
initialised
-
super
(
)
hasn
'
t
been
called
"
)
;
}
return
self
;
}
function
_unsupportedIterableToArray
(
o
minLen
)
{
if
(
!
o
)
return
;
if
(
typeof
o
=
=
=
"
string
"
)
return
_arrayLikeToArray
(
o
minLen
)
;
var
n
=
Object
.
prototype
.
toString
.
call
(
o
)
.
slice
(
8
-
1
)
;
if
(
n
=
=
=
"
Object
"
&
&
o
.
constructor
)
n
=
o
.
constructor
.
name
;
if
(
n
=
=
=
"
Map
"
|
|
n
=
=
=
"
Set
"
)
return
Array
.
from
(
o
)
;
if
(
n
=
=
=
"
Arguments
"
|
|
/
^
(
?
:
Ui
|
I
)
nt
(
?
:
8
|
16
|
32
)
(
?
:
Clamped
)
?
Array
/
.
test
(
n
)
)
return
_arrayLikeToArray
(
o
minLen
)
;
}
function
_arrayLikeToArray
(
arr
len
)
{
if
(
len
=
=
null
|
|
len
>
arr
.
length
)
len
=
arr
.
length
;
for
(
var
i
=
0
arr2
=
new
Array
(
len
)
;
i
<
len
;
i
+
+
)
arr2
[
i
]
=
arr
[
i
]
;
return
arr2
;
}
function
_createForOfIteratorHelperLoose
(
o
allowArrayLike
)
{
var
it
;
if
(
typeof
Symbol
=
=
=
"
undefined
"
|
|
o
[
Symbol
.
iterator
]
=
=
null
)
{
if
(
Array
.
isArray
(
o
)
|
|
(
it
=
_unsupportedIterableToArray
(
o
)
)
|
|
allowArrayLike
&
&
o
&
&
typeof
o
.
length
=
=
=
"
number
"
)
{
if
(
it
)
o
=
it
;
var
i
=
0
;
return
function
(
)
{
if
(
i
>
=
o
.
length
)
return
{
done
:
true
}
;
return
{
done
:
false
value
:
o
[
i
+
+
]
}
;
}
;
}
throw
new
TypeError
(
"
Invalid
attempt
to
iterate
non
-
iterable
instance
.
\
nIn
order
to
be
iterable
non
-
array
objects
must
have
a
[
Symbol
.
iterator
]
(
)
method
.
"
)
;
}
it
=
o
[
Symbol
.
iterator
]
(
)
;
return
it
.
next
.
bind
(
it
)
;
}
var
MobxKeystoneError
=
function
(
_Error
)
{
_inheritsLoose
(
MobxKeystoneError
_Error
)
;
function
MobxKeystoneError
(
msg
)
{
var
_this
;
_this
=
_Error
.
call
(
this
msg
)
|
|
this
;
Object
.
setPrototypeOf
(
_assertThisInitialized
(
_this
)
MobxKeystoneError
.
prototype
)
;
return
_this
;
}
return
MobxKeystoneError
;
}
(
_wrapNativeSuper
(
Error
)
)
;
function
failure
(
msg
)
{
return
new
MobxKeystoneError
(
msg
)
;
}
var
writableHiddenPropDescriptor
=
{
enumerable
:
false
writable
:
true
configurable
:
false
value
:
undefined
}
;
function
addHiddenProp
(
object
propName
value
writable
)
{
if
(
writable
=
=
=
void
0
)
{
writable
=
true
;
}
if
(
writable
)
{
Object
.
defineProperty
(
object
propName
writableHiddenPropDescriptor
)
;
object
[
propName
]
=
value
;
}
else
{
Object
.
defineProperty
(
object
propName
{
enumerable
:
false
writable
:
writable
configurable
:
true
value
:
value
}
)
;
}
}
function
makePropReadonly
(
object
propName
enumerable
)
{
var
propDesc
=
Object
.
getOwnPropertyDescriptor
(
object
propName
)
;
if
(
propDesc
)
{
propDesc
.
enumerable
=
enumerable
;
if
(
propDesc
.
get
)
{
delete
propDesc
.
set
;
}
else
{
propDesc
.
writable
=
false
;
}
Object
.
defineProperty
(
object
propName
propDesc
)
;
}
}
function
isPlainObject
(
value
)
{
if
(
!
isObject
(
value
)
)
return
false
;
var
proto
=
Object
.
getPrototypeOf
(
value
)
;
return
proto
=
=
=
Object
.
prototype
|
|
proto
=
=
=
null
;
}
function
isObject
(
value
)
{
return
value
!
=
=
null
&
&
typeof
value
=
=
=
"
object
"
;
}
function
isPrimitive
(
value
)
{
switch
(
typeof
value
)
{
case
"
number
"
:
case
"
string
"
:
case
"
boolean
"
:
case
"
undefined
"
:
case
"
bigint
"
:
return
true
;
}
return
value
=
=
=
null
;
}
function
debugFreeze
(
value
)
{
if
(
inDevMode
(
)
)
{
Object
.
freeze
(
value
)
;
}
}
function
deleteFromArray
(
array
value
)
{
var
index
=
array
.
indexOf
(
value
)
;
if
(
index
>
=
0
)
{
array
.
splice
(
index
1
)
;
return
true
;
}
return
false
;
}
function
isMap
(
val
)
{
return
val
instanceof
Map
|
|
(
0
mobx_esm
.
isObservableMap
)
(
val
)
;
}
function
isSet
(
val
)
{
return
val
instanceof
Set
|
|
(
0
mobx_esm
.
isObservableSet
)
(
val
)
;
}
function
isArray
(
val
)
{
return
Array
.
isArray
(
val
)
|
|
(
0
mobx_esm
.
isObservableArray
)
(
val
)
;
}
function
inDevMode
(
)
{
return
"
production
"
!
=
=
"
production
"
;
}
function
assertIsObject
(
value
argName
)
{
if
(
!
isObject
(
value
)
)
{
throw
failure
(
argName
+
"
must
be
an
object
"
)
;
}
}
function
assertIsPlainObject
(
value
argName
)
{
if
(
!
isPlainObject
(
value
)
)
{
throw
failure
(
argName
+
"
must
be
a
plain
object
"
)
;
}
}
function
assertIsObservableObject
(
value
argName
)
{
if
(
!
(
0
mobx_esm
.
isObservableObject
)
(
value
)
)
{
throw
failure
(
argName
+
"
must
be
an
observable
object
"
)
;
}
}
function
assertIsObservableArray
(
value
argName
)
{
if
(
!
(
0
mobx_esm
.
isObservableArray
)
(
value
)
)
{
throw
failure
(
argName
+
"
must
be
an
observable
array
"
)
;
}
}
function
assertIsMap
(
value
argName
)
{
if
(
!
isMap
(
value
)
)
{
throw
failure
(
argName
+
"
must
be
a
map
"
)
;
}
}
function
assertIsSet
(
value
argName
)
{
if
(
!
isSet
(
value
)
)
{
throw
failure
(
argName
+
"
must
be
a
set
"
)
;
}
}
function
assertIsFunction
(
value
argName
)
{
if
(
typeof
value
!
=
=
"
function
"
)
{
throw
failure
(
argName
+
"
must
be
a
function
"
)
;
}
}
function
assertIsPrimitive
(
value
argName
)
{
if
(
!
isPrimitive
(
value
)
)
{
throw
failure
(
argName
+
"
must
be
a
primitive
"
)
;
}
}
function
assertIsString
(
value
argName
)
{
if
(
typeof
value
!
=
=
"
string
"
)
{
throw
failure
(
argName
+
"
must
be
a
string
"
)
;
}
}
var
decoratorsSymbol
=
Symbol
(
"
decorators
"
)
;
function
addLateInitializationFunction
(
target
fn
)
{
var
decoratorsArray
=
target
[
decoratorsSymbol
]
;
if
(
!
decoratorsArray
)
{
decoratorsArray
=
[
]
;
addHiddenProp
(
target
decoratorsSymbol
decoratorsArray
)
;
}
decoratorsArray
.
push
(
fn
)
;
}
function
decorateWrapMethodOrField
(
decoratorName
data
wrap
)
{
var
target
=
data
.
target
propertyKey
=
data
.
propertyKey
baseDescriptor
=
data
.
baseDescriptor
;
var
addFieldDecorator
=
function
addFieldDecorator
(
)
{
addLateInitializationFunction
(
target
function
(
instance
)
{
instance
[
propertyKey
]
=
wrap
(
data
instance
[
propertyKey
]
)
;
}
)
;
}
;
if
(
baseDescriptor
)
{
if
(
baseDescriptor
.
get
!
=
=
undefined
)
{
throw
failure
(
"
"
+
decoratorName
+
"
cannot
be
used
with
getters
"
)
;
}
if
(
baseDescriptor
.
value
)
{
return
{
enumerable
:
false
writable
:
true
configurable
:
true
value
:
wrap
(
data
baseDescriptor
.
value
)
}
;
}
else
{
addFieldDecorator
(
)
;
}
}
else
{
addFieldDecorator
(
)
;
}
}
function
runLateInitializationFunctions
(
instance
)
{
var
fns
=
instance
[
decoratorsSymbol
]
;
if
(
fns
)
{
for
(
var
_iterator
=
_createForOfIteratorHelperLoose
(
fns
)
_step
;
!
(
_step
=
_iterator
(
)
)
.
done
;
)
{
var
fn
=
_step
.
value
;
fn
(
instance
)
;
}
}
}
var
warningsAlreadyDisplayed
=
new
Set
(
)
;
function
logWarning
(
type
msg
uniqueKey
)
{
if
(
uniqueKey
)
{
if
(
warningsAlreadyDisplayed
.
has
(
uniqueKey
)
)
{
return
;
}
warningsAlreadyDisplayed
.
add
(
uniqueKey
)
;
}
msg
=
"
[
mobx
-
keystone
]
"
+
msg
;
switch
(
type
)
{
case
"
warn
"
:
console
.
warn
(
msg
)
;
break
;
case
"
error
"
:
console
.
error
(
msg
)
;
break
;
default
:
throw
failure
(
"
unknown
log
type
-
"
+
type
)
;
}
}
var
notMemoized
=
Symbol
(
"
notMemoized
"
)
;
function
lateVal
(
getter
)
{
var
memoized
=
notMemoized
;
var
fn
=
function
fn
(
)
{
if
(
memoized
=
=
=
notMemoized
)
{
memoized
=
getter
.
apply
(
void
0
arguments
)
;
}
return
memoized
;
}
;
return
fn
;
}
function
lazy
(
valueGen
)
{
var
inited
=
false
;
var
val
;
return
function
(
)
{
if
(
!
inited
)
{
val
=
valueGen
(
)
;
inited
=
true
;
}
return
val
;
}
;
}
function
getMobxVersion
(
)
{
if
(
mobx_esm
.
makeObservable
)
{
return
6
;
}
else
{
return
5
;
}
}
var
chars
=
"
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789
+
/
=
"
;
function
toBase64
(
input
)
{
if
(
typeof
__webpack_require__
.
g
=
=
=
"
object
"
&
&
typeof
__webpack_require__
.
g
.
Buffer
=
=
=
"
function
"
)
{
return
Buffer
.
from
(
input
)
.
toString
(
"
base64
"
)
;
}
if
(
typeof
btoa
=
=
=
"
function
"
)
{
return
btoa
(
input
)
;
}
var
str
=
String
(
input
)
;
var
output
=
"
"
;
for
(
var
block
=
0
charCode
idx
=
0
map
=
chars
;
str
.
charAt
(
idx
|
0
)
|
|
(
map
=
"
=
"
idx
%
1
)
;
output
+
=
map
.
charAt
(
63
&
block
>
>
8
-
idx
%
1
*
8
)
)
{
charCode
=
str
.
charCodeAt
(
idx
+
=
3
/
4
)
;
if
(
charCode
>
0xff
)
{
throw
new
Error
(
"
the
string
to
be
encoded
contains
characters
outside
of
the
Latin1
range
.
"
)
;
}
block
=
block
<
<
8
|
charCode
;
}
return
output
;
}
var
ModelAutoTypeCheckingMode
;
(
function
(
ModelAutoTypeCheckingMode
)
{
ModelAutoTypeCheckingMode
[
"
DevModeOnly
"
]
=
"
devModeOnly
"
;
ModelAutoTypeCheckingMode
[
"
AlwaysOn
"
]
=
"
alwaysOn
"
;
ModelAutoTypeCheckingMode
[
"
AlwaysOff
"
]
=
"
alwaysOff
"
;
}
)
(
ModelAutoTypeCheckingMode
|
|
(
ModelAutoTypeCheckingMode
=
{
}
)
)
;
var
localId
=
0
;
var
localBaseId
=
shortenUuid
(
esm_browser_v4
(
)
)
;
function
defaultModelIdGenerator
(
)
{
var
id
=
localId
.
toString
(
36
)
+
"
-
"
+
localBaseId
;
localId
+
+
;
return
id
;
}
var
globalConfig
=
{
modelAutoTypeChecking
:
ModelAutoTypeCheckingMode
.
DevModeOnly
modelIdGenerator
:
defaultModelIdGenerator
allowUndefinedArrayElements
:
false
}
;
function
setGlobalConfig
(
config
)
{
globalConfig
=
Object
.
freeze
(
_extends
(
{
}
globalConfig
config
)
)
;
}
function
getGlobalConfig
(
)
{
return
globalConfig
;
}
function
isModelAutoTypeCheckingEnabled
(
)
{
switch
(
getGlobalConfig
(
)
.
modelAutoTypeChecking
)
{
case
ModelAutoTypeCheckingMode
.
DevModeOnly
:
return
inDevMode
(
)
;
case
ModelAutoTypeCheckingMode
.
AlwaysOff
:
return
false
;
case
ModelAutoTypeCheckingMode
.
AlwaysOn
:
return
true
;
default
:
throw
failure
(
"
invalid
'
modelAutoTypeChecking
'
config
value
-
"
+
globalConfig
.
modelAutoTypeChecking
)
;
}
}
function
shortenUuid
(
uuid
)
{
var
hex
=
uuid
.
split
(
"
-
"
)
.
join
(
"
"
)
;
var
hexMatch
=
hex
.
match
(
/
\
w
{
2
}
/
g
)
;
var
str
=
String
.
fromCharCode
.
apply
(
null
hexMatch
.
map
(
function
(
a
)
{
return
parseInt
(
a
16
)
;
}
)
)
;
return
toBase64
(
str
)
;
}
var
noDefaultValue
=
Symbol
(
"
noDefaultValue
"
)
;
function
prop
(
arg1
arg2
)
{
var
def
;
var
opts
=
{
}
;
var
hasDefaultValue
=
false
;
if
(
arguments
.
length
>
=
2
)
{
def
=
arg1
;
hasDefaultValue
=
true
;
opts
=
_extends
(
{
}
arg2
)
;
}
else
if
(
arguments
.
length
=
=
=
1
)
{
if
(
isObject
(
arg1
)
)
{
opts
=
_extends
(
{
}
arg1
)
;
}
else
{
def
=
arg1
;
hasDefaultValue
=
true
;
}
}
var
isDefFn
=
typeof
def
=
=
=
"
function
"
;
return
{
propValueType
:
null
propCreationValueType
:
null
isOptional
:
null
instanceValueType
:
null
instanceCreationValueType
:
null
defaultFn
:
hasDefaultValue
&
&
isDefFn
?
def
:
noDefaultValue
defaultValue
:
hasDefaultValue
&
&
!
isDefFn
?
def
:
noDefaultValue
typeChecker
:
undefined
transform
:
undefined
options
:
opts
}
;
}
function
propTransform
(
transform
)
{
var
parametrizedDecorator
=
function
parametrizedDecorator
(
boundPropName
)
{
var
decorator
=
function
decorator
(
target
propertyKey
)
{
addLateInitializationFunction
(
target
function
(
instance
)
{
Object
.
defineProperty
(
instance
propertyKey
{
get
:
function
get
(
)
{
var
memoTransform
=
memoTransformCache
.
getOrCreateMemoTransform
(
this
propertyKey
transform
)
;
return
memoTransform
.
propToData
(
this
.
[
boundPropName
]
)
;
}
set
:
function
set
(
value
)
{
var
memoTransform
=
memoTransformCache
.
getOrCreateMemoTransform
(
this
propertyKey
transform
)
;
this
.
[
boundPropName
]
=
memoTransform
.
dataToProp
(
value
)
;
return
true
;
}
}
)
;
}
)
;
}
;
return
decorator
;
}
;
parametrizedDecorator
.
propToData
=
transform
.
propToData
.
bind
(
transform
)
;
parametrizedDecorator
.
dataToProp
=
transform
.
dataToProp
.
bind
(
transform
)
;
return
parametrizedDecorator
;
}
var
MemoTransformCache
=
function
(
)
{
function
MemoTransformCache
(
)
{
this
.
cache
=
new
WeakMap
(
)
;
}
var
_proto
=
MemoTransformCache
.
prototype
;
_proto
.
getOrCreateMemoTransform
=
function
getOrCreateMemoTransform
(
target
propName
baseTransform
)
{
var
transformsPerProperty
=
this
.
cache
.
get
(
target
)
;
if
(
!
transformsPerProperty
)
{
transformsPerProperty
=
new
Map
(
)
;
this
.
cache
.
set
(
target
transformsPerProperty
)
;
}
var
memoTransform
=
transformsPerProperty
.
get
(
propName
)
;
if
(
!
memoTransform
)
{
memoTransform
=
toMemoPropTransform
(
baseTransform
function
(
newPropValue
)
{
target
.
[
propName
]
=
newPropValue
;
}
)
;
transformsPerProperty
.
set
(
propName
memoTransform
)
;
}
return
memoTransform
;
}
;
return
MemoTransformCache
;
}
(
)
;
var
memoTransformCache
=
new
MemoTransformCache
(
)
;
var
valueNotMemoized
=
Symbol
(
"
valueNotMemoized
"
)
;
function
toMemoPropTransform
(
transform
propSetter
)
{
var
lastPropValue
=
valueNotMemoized
;
var
lastDataValue
=
valueNotMemoized
;
return
{
isMemoPropTransform
:
true
propToData
:
function
propToData
(
propValue
)
{
if
(
lastPropValue
!
=
=
propValue
)
{
lastDataValue
=
transform
.
propToData
(
propValue
propSetter
)
;
lastPropValue
=
propValue
;
}
return
lastDataValue
;
}
dataToProp
:
function
dataToProp
(
newDataValue
)
{
lastPropValue
=
valueNotMemoized
;
lastDataValue
=
valueNotMemoized
;
return
transform
.
dataToProp
(
newDataValue
)
;
}
}
;
}
function
transformedProp
(
prop
transform
transformDefault
)
{
if
(
prop
.
transform
)
{
throw
failure
(
"
a
property
cannot
have
more
than
one
transform
"
)
;
}
var
p
=
_extends
(
{
}
prop
{
transform
:
transform
}
)
;
if
(
transformDefault
)
{
if
(
p
.
defaultValue
!
=
=
noDefaultValue
)
{
var
originalDefaultValue
=
p
.
defaultValue
;
p
.
defaultValue
=
transform
.
dataToProp
(
originalDefaultValue
)
;
}
if
(
p
.
defaultFn
!
=
=
noDefaultValue
)
{
var
originalDefaultFn
=
p
.
defaultFn
;
p
.
defaultFn
=
function
(
)
{
return
transform
.
dataToProp
(
originalDefaultFn
(
)
)
;
}
;
}
}
return
p
;
}
var
objectParents
=
new
WeakMap
(
)
;
var
objectParentsAtoms
=
new
WeakMap
(
)
;
function
parentPathEquals
(
parentPath1
parentPath2
comparePath
)
{
if
(
comparePath
=
=
=
void
0
)
{
comparePath
=
true
;
}
if
(
!
parentPath1
&
&
!
parentPath2
)
return
true
;
if
(
!
parentPath1
|
|
!
parentPath2
)
return
false
;
var
parentEquals
=
parentPath1
.
parent
=
=
=
parentPath2
.
parent
;
if
(
!
parentEquals
)
return
false
;
return
comparePath
?
parentPath1
.
path
=
=
=
parentPath2
.
path
:
true
;
}
function
createParentPathAtom
(
obj
)
{
var
atom
=
objectParentsAtoms
.
get
(
obj
)
;
if
(
!
atom
)
{
atom
=
(
0
mobx_esm
.
createAtom
)
(
"
parentAtom
"
)
;
objectParentsAtoms
.
set
(
obj
atom
)
;
}
return
atom
;
}
function
reportParentPathObserved
(
node
)
{
createParentPathAtom
(
node
)
.
reportObserved
(
)
;
}
function
reportParentPathChanged
(
node
)
{
createParentPathAtom
(
node
)
.
reportChanged
(
)
;
}
var
dataObjectParent
=
new
WeakMap
(
)
;
function
dataToModelNode
(
node
)
{
var
modelNode
=
dataObjectParent
.
get
(
node
)
;
return
modelNode
!
=
null
?
modelNode
:
node
;
}
function
modelToDataNode
(
node
)
{
return
isModel
(
node
)
?
node
.
:
node
;
}
var
tweakedObjects
=
new
WeakMap
(
)
;
function
isTweakedObject
(
value
canBeDataObject
)
{
if
(
!
canBeDataObject
&
&
dataObjectParent
.
has
(
value
)
)
{
return
false
;
}
return
tweakedObjects
.
has
(
value
)
;
}
function
isTreeNode
(
value
)
{
return
!
isPrimitive
(
value
)
&
&
isTweakedObject
(
value
false
)
;
}
function
assertTweakedObject
(
treeNode
argName
canBeDataObject
)
{
if
(
canBeDataObject
=
=
=
void
0
)
{
canBeDataObject
=
false
;
}
if
(
!
canBeDataObject
&
&
dataObjectParent
.
has
(
treeNode
)
)
{
throw
failure
(
argName
+
"
must
be
the
model
object
instance
instead
of
the
'
'
sub
-
object
"
)
;
}
if
(
isPrimitive
(
treeNode
)
|
|
!
isTweakedObject
(
treeNode
true
)
)
{
throw
failure
(
argName
+
"
must
be
a
tree
node
(
usually
a
model
or
a
shallow
/
deep
child
part
of
a
model
'
data
'
object
)
"
)
;
}
}
function
assertIsTreeNode
(
value
argName
)
{
if
(
argName
=
=
=
void
0
)
{
argName
=
"
argument
"
;
}
assertTweakedObject
(
value
argName
false
)
;
}
var
runningWithoutSnapshotOrPatches
=
false
;
function
runWithoutSnapshotOrPatches
(
fn
)
{
var
old
=
runningWithoutSnapshotOrPatches
;
runningWithoutSnapshotOrPatches
=
true
;
try
{
(
0
mobx_esm
.
runInAction
)
(
function
(
)
{
fn
(
)
;
}
)
;
}
finally
{
runningWithoutSnapshotOrPatches
=
old
;
}
}
var
modelTypeKey
=
"
modelType
"
;
var
modelIdKey
=
"
modelId
"
;
function
isReservedModelKey
(
key
)
{
return
key
=
=
=
modelTypeKey
|
|
key
=
=
=
modelIdKey
;
}
var
defaultObservableSetOptions
=
{
deep
:
false
}
;
var
objectChildren
=
new
WeakMap
(
)
;
function
initializeObjectChildren
(
node
)
{
if
(
objectChildren
.
has
(
node
)
)
{
return
;
}
objectChildren
.
set
(
node
{
shallow
:
mobx_esm
.
observable
.
set
(
undefined
defaultObservableSetOptions
)
deep
:
new
Set
(
)
deepByModelTypeAndId
:
new
Map
(
)
deepDirty
:
true
deepAtom
:
(
0
mobx_esm
.
createAtom
)
(
"
deepChildrenAtom
"
)
}
)
;
}
function
getObjectChildren
(
node
)
{
return
objectChildren
.
get
(
node
)
.
shallow
;
}
function
getDeepObjectChildren
(
node
)
{
var
obj
=
objectChildren
.
get
(
node
)
;
if
(
obj
.
deepDirty
)
{
updateDeepObjectChildren
(
node
)
;
}
obj
.
deepAtom
.
reportObserved
(
)
;
return
{
deep
:
obj
.
deep
deepByModelTypeAndId
:
obj
.
deepByModelTypeAndId
}
;
}
function
addNodeToDeepLists
(
node
deep
deepByModelTypeAndId
)
{
deep
.
add
(
node
)
;
if
(
isModel
(
node
)
)
{
deepByModelTypeAndId
.
set
(
byModelTypeAndIdKey
(
node
[
modelTypeKey
]
node
[
modelIdKey
]
)
node
)
;
}
}
var
updateDeepObjectChildren
=
(
0
mobx_esm
.
action
)
(
function
(
node
)
{
var
obj
=
objectChildren
.
get
(
node
)
;
if
(
!
obj
.
deepDirty
)
{
return
{
deep
:
obj
.
deep
deepByModelTypeAndId
:
obj
.
deepByModelTypeAndId
}
;
}
var
deep
=
new
Set
(
)
;
var
deepByModelTypeAndId
=
new
Map
(
)
;
var
childrenIter
=
getObjectChildren
(
node
)
.
values
(
)
;
var
ch
=
childrenIter
.
next
(
)
;
while
(
!
ch
.
done
)
{
addNodeToDeepLists
(
ch
.
value
deep
deepByModelTypeAndId
)
;
var
ret
=
updateDeepObjectChildren
(
ch
.
value
)
.
deep
;
var
retIter
=
ret
.
values
(
)
;
var
retCur
=
retIter
.
next
(
)
;
while
(
!
retCur
.
done
)
{
addNodeToDeepLists
(
retCur
.
value
deep
deepByModelTypeAndId
)
;
retCur
=
retIter
.
next
(
)
;
}
ch
=
childrenIter
.
next
(
)
;
}
obj
.
deep
=
deep
;
obj
.
deepByModelTypeAndId
=
deepByModelTypeAndId
;
obj
.
deepDirty
=
false
;
obj
.
deepAtom
.
reportChanged
(
)
;
return
{
deep
:
deep
deepByModelTypeAndId
:
deepByModelTypeAndId
}
;
}
)
;
var
addObjectChild
=
(
0
mobx_esm
.
action
)
(
function
(
node
child
)
{
var
obj
=
objectChildren
.
get
(
node
)
;
obj
.
shallow
.
add
(
child
)
;
invalidateDeepChildren
(
node
)
;
}
)
;
var
removeObjectChild
=
(
0
mobx_esm
.
action
)
(
function
(
node
child
)
{
var
obj
=
objectChildren
.
get
(
node
)
;
obj
.
shallow
[
"
delete
"
]
(
child
)
;
invalidateDeepChildren
(
node
)
;
}
)
;
function
invalidateDeepChildren
(
node
)
{
var
obj
=
objectChildren
.
get
(
node
)
;
if
(
!
obj
.
deepDirty
)
{
obj
.
deepDirty
=
true
;
obj
.
deepAtom
.
reportChanged
(
)
;
}
var
parent
=
fastGetParent
(
node
)
;
if
(
parent
)
{
invalidateDeepChildren
(
parent
)
;
}
}
function
byModelTypeAndIdKey
(
modelType
modelId
)
{
return
modelType
+
"
"
+
modelId
;
}
function
getParentPath
(
value
)
{
assertTweakedObject
(
value
"
value
"
)
;
return
fastGetParentPath
(
value
)
;
}
function
fastGetParentPath
(
value
)
{
reportParentPathObserved
(
value
)
;
return
objectParents
.
get
(
value
)
;
}
function
fastGetParentPathIncludingDataObjects
(
value
)
{
var
parentModel
=
dataObjectParent
.
get
(
value
)
;
if
(
parentModel
)
{
return
{
parent
:
parentModel
path
:
"
"
}
;
}
var
parentPath
=
fastGetParentPath
(
value
)
;
if
(
parentPath
&
&
isModel
(
parentPath
.
parent
)
)
{
return
{
parent
:
parentPath
.
parent
.
path
:
parentPath
.
path
}
;
}
return
parentPath
;
}
function
getParent
(
value
)
{
assertTweakedObject
(
value
"
value
"
)
;
return
fastGetParent
(
value
)
;
}
function
fastGetParent
(
value
)
{
var
parentPath
=
fastGetParentPath
(
value
)
;
return
parentPath
?
parentPath
.
parent
:
undefined
;
}
function
fastGetParentIncludingDataObjects
(
value
)
{
var
parentPath
=
fastGetParentPathIncludingDataObjects
(
value
)
;
return
parentPath
?
parentPath
.
parent
:
undefined
;
}
function
isModelDataObject
(
value
)
{
assertTweakedObject
(
value
"
value
"
true
)
;
return
fastIsModelDataObject
(
value
)
;
}
function
fastIsModelDataObject
(
value
)
{
return
dataObjectParent
.
has
(
value
)
;
}
function
getRootPath
(
value
)
{
assertTweakedObject
(
value
"
value
"
)
;
return
fastGetRootPath
(
value
)
;
}
var
computedsGetRootPath
=
new
WeakMap
(
)
;
function
internalGetRootPath
(
value
)
{
var
rootPath
=
{
root
:
value
path
:
[
]
pathObjects
:
[
value
]
}
;
var
parentPath
;
while
(
parentPath
=
fastGetParentPath
(
rootPath
.
root
)
)
{
rootPath
.
root
=
parentPath
.
parent
;
rootPath
.
path
.
unshift
(
parentPath
.
path
)
;
rootPath
.
pathObjects
.
unshift
(
parentPath
.
parent
)
;
}
return
rootPath
;
}
function
fastGetRootPath
(
value
)
{
var
computedGetRootPathForNode
=
computedsGetRootPath
.
get
(
value
)
;
if
(
!
computedGetRootPathForNode
)
{
computedGetRootPathForNode
=
(
0
mobx_esm
.
computed
)
(
function
(
)
{
return
internalGetRootPath
(
value
)
;
}
)
;
computedsGetRootPath
.
set
(
value
computedGetRootPathForNode
)
;
}
return
computedGetRootPathForNode
.
get
(
)
;
}
function
getRoot
(
value
)
{
assertTweakedObject
(
value
"
value
"
)
;
return
fastGetRoot
(
value
)
;
}
function
fastGetRoot
(
value
)
{
return
fastGetRootPath
(
value
)
.
root
;
}
function
isRoot
(
value
)
{
assertTweakedObject
(
value
"
value
"
)
;
return
!
fastGetParent
(
value
)
;
}
function
isChildOfParent
(
child
parent
)
{
assertTweakedObject
(
child
"
child
"
)
;
assertTweakedObject
(
parent
"
parent
"
)
;
return
getDeepObjectChildren
(
parent
)
.
deep
.
has
(
child
)
;
}
function
isParentOfChild
(
parent
child
)
{
return
isChildOfParent
(
child
parent
)
;
}
var
unresolved
=
{
resolved
:
false
}
;
function
resolvePath
(
pathRootObject
path
)
{
var
current
=
modelToDataNode
(
pathRootObject
)
;
var
len
=
path
.
length
;
for
(
var
i
=
0
;
i
<
len
;
i
+
+
)
{
if
(
!
isObject
(
current
)
)
{
return
unresolved
;
}
var
p
=
path
[
i
]
;
if
(
isArray
(
current
)
&
&
+
p
>
=
current
.
length
)
{
return
unresolved
;
}
current
=
modelToDataNode
(
current
[
p
]
)
;
}
return
{
resolved
:
true
value
:
dataToModelNode
(
current
)
}
;
}
var
skipIdChecking
=
Symbol
(
"
skipIdChecking
"
)
;
function
resolvePathCheckingIds
(
pathRootObject
path
pathIds
)
{
var
current
=
modelToDataNode
(
pathRootObject
)
;
var
len
=
path
.
length
;
for
(
var
i
=
0
;
i
<
len
;
i
+
+
)
{
if
(
!
isObject
(
current
)
)
{
return
{
resolved
:
false
}
;
}
var
p
=
path
[
i
]
;
if
(
isArray
(
current
)
&
&
+
p
>
=
current
.
length
)
{
return
{
resolved
:
false
}
;
}
var
currentMaybeModel
=
current
[
p
]
;
current
=
modelToDataNode
(
currentMaybeModel
)
;
var
expectedId
=
pathIds
[
i
]
;
if
(
expectedId
!
=
=
skipIdChecking
)
{
var
currentId
=
isModel
(
currentMaybeModel
)
?
currentMaybeModel
[
modelIdKey
]
:
null
;
if
(
expectedId
!
=
=
currentId
)
{
return
{
resolved
:
false
}
;
}
}
}
return
{
resolved
:
true
value
:
dataToModelNode
(
current
)
}
;
}
function
getParentToChildPath
(
fromParent
toChild
)
{
assertTweakedObject
(
fromParent
"
fromParent
"
)
;
assertTweakedObject
(
toChild
"
toChild
"
)
;
if
(
fromParent
=
=
=
toChild
)
{
return
[
]
;
}
var
path
=
[
]
;
var
current
=
toChild
;
var
parentPath
;
while
(
parentPath
=
fastGetParentPath
(
current
)
)
{
path
.
unshift
(
parentPath
.
path
)
;
current
=
parentPath
.
parent
;
if
(
current
=
=
=
fromParent
)
{
return
path
;
}
}
return
undefined
;
}
var
snapshots
=
new
WeakMap
(
)
;
function
getInternalSnapshot
(
value
)
{
return
snapshots
.
get
(
value
)
;
}
function
getInternalSnapshotParent
(
sn
parentPath
)
{
return
(
0
mobx_esm
.
untracked
)
(
function
(
)
{
if
(
!
parentPath
)
{
return
undefined
;
}
var
parentSn
=
getInternalSnapshot
(
parentPath
.
parent
)
;
if
(
!
parentSn
)
{
return
undefined
;
}
return
sn
?
{
parentSnapshot
:
parentSn
parentPath
:
parentPath
}
:
undefined
;
}
)
;
}
var
unsetInternalSnapshot
=
(
0
mobx_esm
.
action
)
(
"
unsetInternalSnapshot
"
function
(
value
)
{
var
oldSn
=
getInternalSnapshot
(
value
)
;
if
(
oldSn
)
{
snapshots
[
"
delete
"
]
(
value
)
;
oldSn
.
atom
.
reportChanged
(
)
;
}
}
)
;
var
setInternalSnapshot
=
(
0
mobx_esm
.
action
)
(
"
setInternalSnapshot
"
function
(
value
standard
)
{
var
oldSn
=
getInternalSnapshot
(
value
)
;
if
(
oldSn
&
&
oldSn
.
standard
=
=
=
standard
)
{
return
;
}
debugFreeze
(
standard
)
;
var
sn
;
if
(
oldSn
)
{
sn
=
oldSn
;
sn
.
standard
=
standard
;
}
else
{
sn
=
{
standard
:
standard
atom
:
(
0
mobx_esm
.
createAtom
)
(
"
snapshot
"
)
}
;
snapshots
.
set
(
value
sn
)
;
}
sn
.
atom
.
reportChanged
(
)
;
var
parent
=
getInternalSnapshotParent
(
oldSn
fastGetParentPath
(
value
)
)
;
if
(
parent
)
{
var
parentSnapshot
=
parent
.
parentSnapshot
parentPath
=
parent
.
parentPath
;
if
(
parentSnapshot
)
{
var
path
=
parentPath
.
path
;
var
parentStandardSn
=
parentSnapshot
.
standard
;
if
(
parentStandardSn
[
path
]
!
=
=
sn
.
standard
)
{
if
(
Array
.
isArray
(
parentStandardSn
)
)
{
parentStandardSn
=
parentStandardSn
.
slice
(
)
;
}
else
{
parentStandardSn
=
Object
.
assign
(
{
}
parentStandardSn
)
;
}
parentStandardSn
[
path
]
=
sn
.
standard
;
setInternalSnapshot
(
parentPath
.
parent
parentStandardSn
)
;
}
}
}
}
)
;
function
reportInternalSnapshotObserved
(
sn
)
{
sn
.
atom
.
reportObserved
(
)
;
}
function
getSnapshot
(
nodeOrPrimitive
)
{
if
(
isPrimitive
(
nodeOrPrimitive
)
)
{
return
nodeOrPrimitive
;
}
assertTweakedObject
(
nodeOrPrimitive
"
nodeOrPrimitive
"
)
;
var
snapshot
=
getInternalSnapshot
(
nodeOrPrimitive
)
;
if
(
!
snapshot
)
{
throw
failure
(
"
getSnapshot
is
not
supported
for
this
kind
of
object
"
)
;
}
reportInternalSnapshotObserved
(
snapshot
)
;
return
snapshot
.
standard
;
}
var
modelDataTypeCheckerSymbol
=
Symbol
(
"
modelDataTypeChecker
"
)
;
var
modelUnwrappedClassSymbol
=
Symbol
(
"
modelUnwrappedClass
"
)
;
function
getModelDataType
(
modelClassOrInstance
)
{
if
(
isModel
(
modelClassOrInstance
)
)
{
return
modelClassOrInstance
.
constructor
[
modelDataTypeCheckerSymbol
]
;
}
else
if
(
isModelClass
(
modelClassOrInstance
)
)
{
return
modelClassOrInstance
[
modelDataTypeCheckerSymbol
]
;
}
else
{
throw
failure
(
"
modelClassOrInstance
must
be
a
model
class
or
instance
"
)
;
}
}
var
modelInfoByName
=
{
}
;
var
modelInfoByClass
=
new
Map
(
)
;
function
getModelInfoForName
(
name
)
{
return
modelInfoByName
[
name
]
;
}
var
modelPropertiesSymbol
=
Symbol
(
"
modelProperties
"
)
;
function
getInternalModelClassPropsInfo
(
modelClass
)
{
return
modelClass
[
modelPropertiesSymbol
]
;
}
function
setInternalModelClassPropsInfo
(
modelClass
props
)
{
modelClass
[
modelPropertiesSymbol
]
=
props
;
}
var
TypeCheckError
=
function
(
)
{
function
TypeCheckError
(
path
expectedTypeName
actualValue
)
{
this
.
path
=
void
0
;
this
.
expectedTypeName
=
void
0
;
this
.
actualValue
=
void
0
;
this
.
path
=
path
;
this
.
expectedTypeName
=
expectedTypeName
;
this
.
actualValue
=
actualValue
;
}
var
_proto
=
TypeCheckError
.
prototype
;
_proto
[
"
throw
"
]
=
function
_throw
(
typeCheckedValue
)
{
var
msg
=
"
TypeCheckError
:
"
;
var
rootPath
=
[
]
;
if
(
isTweakedObject
(
typeCheckedValue
true
)
)
{
rootPath
=
getRootPath
(
typeCheckedValue
)
.
path
;
}
msg
+
=
"
[
/
"
+
[
]
.
concat
(
rootPath
this
.
path
)
.
join
(
"
/
"
)
+
"
]
"
;
msg
+
=
"
Expected
:
"
+
this
.
expectedTypeName
;
throw
failure
(
msg
)
;
}
;
return
TypeCheckError
;
}
(
)
;
var
emptyPath
=
[
]
;
var
typeCheckersWithCachedResultsOfObject
=
new
WeakMap
(
)
;
function
invalidateCachedTypeCheckerResult
(
obj
)
{
var
current
=
obj
;
while
(
current
)
{
var
set
=
typeCheckersWithCachedResultsOfObject
.
get
(
current
)
;
if
(
set
)
{
for
(
var
_iterator
=
_createForOfIteratorHelperLoose
(
set
)
_step
;
!
(
_step
=
_iterator
(
)
)
.
done
;
)
{
var
typeChecker
=
_step
.
value
;
typeChecker
.
invalidateCachedResult
(
current
)
;
}
typeCheckersWithCachedResultsOfObject
[
"
delete
"
]
(
current
)
;
}
current
=
fastGetParentIncludingDataObjects
(
current
)
;
}
}
var
TypeChecker
=
function
(
)
{
var
_proto
=
TypeChecker
.
prototype
;
_proto
.
createCacheIfNeeded
=
function
createCacheIfNeeded
(
)
{
if
(
!
this
.
checkResultCache
)
{
this
.
checkResultCache
=
new
WeakMap
(
)
;
}
return
this
.
checkResultCache
;
}
;
_proto
.
setCachedResult
=
function
setCachedResult
(
obj
newCacheValue
)
{
this
.
createCacheIfNeeded
(
)
.
set
(
obj
newCacheValue
)
;
var
typeCheckerSet
=
typeCheckersWithCachedResultsOfObject
.
get
(
obj
)
;
if
(
!
typeCheckerSet
)
{
typeCheckerSet
=
new
Set
(
)
;
typeCheckersWithCachedResultsOfObject
.
set
(
obj
typeCheckerSet
)
;
}
typeCheckerSet
.
add
(
this
)
;
}
;
_proto
.
invalidateCachedResult
=
function
invalidateCachedResult
(
obj
)
{
if
(
this
.
checkResultCache
)
{
this
.
checkResultCache
[
"
delete
"
]
(
obj
)
;
}
}
;
_proto
.
getCachedResult
=
function
getCachedResult
(
obj
)
{
return
this
.
checkResultCache
?
this
.
checkResultCache
.
get
(
obj
)
:
undefined
;
}
;
_proto
.
check
=
function
check
(
value
path
)
{
if
(
this
.
unchecked
)
{
return
null
;
}
if
(
!
isTweakedObject
(
value
true
)
)
{
return
this
.
_check
(
value
path
)
;
}
var
cachedResult
=
this
.
getCachedResult
(
value
)
;
if
(
cachedResult
=
=
=
undefined
)
{
cachedResult
=
this
.
_check
(
value
emptyPath
)
;
this
.
setCachedResult
(
value
cachedResult
)
;
}
if
(
cachedResult
)
{
return
new
TypeCheckError
(
[
]
.
concat
(
path
cachedResult
.
path
)
cachedResult
.
expectedTypeName
cachedResult
.
actualValue
)
;
}
else
{
return
null
;
}
}
;
_createClass
(
TypeChecker
[
{
key
:
"
typeInfo
"
get
:
function
get
(
)
{
return
this
.
_cachedTypeInfoGen
(
this
)
;
}
}
]
)
;
function
TypeChecker
(
_check
getTypeName
typeInfoGen
)
{
this
.
_check
=
void
0
;
this
.
getTypeName
=
void
0
;
this
.
checkResultCache
=
void
0
;
this
.
unchecked
=
void
0
;
this
.
_cachedTypeInfoGen
=
void
0
;
this
.
_check
=
_check
;
this
.
getTypeName
=
getTypeName
;
this
.
unchecked
=
!
_check
;
this
.
_cachedTypeInfoGen
=
lateVal
(
typeInfoGen
)
;
}
return
TypeChecker
;
}
(
)
;
var
lateTypeCheckerSymbol
=
Symbol
(
"
lateTypeCheker
"
)
;
function
lateTypeChecker
(
fn
typeInfoGen
)
{
var
cached
;
var
ltc
=
function
ltc
(
)
{
if
(
cached
)
{
return
cached
;
}
cached
=
fn
(
)
;
return
cached
;
}
;
ltc
[
lateTypeCheckerSymbol
]
=
true
;
var
cachedTypeInfoGen
=
lateVal
(
typeInfoGen
)
;
Object
.
defineProperty
(
ltc
"
typeInfo
"
{
enumerable
:
true
configurable
:
true
get
:
function
get
(
)
{
return
cachedTypeInfoGen
(
ltc
)
;
}
}
)
;
return
ltc
;
}
function
isLateTypeChecker
(
ltc
)
{
return
typeof
ltc
=
=
=
"
function
"
&
&
ltc
[
lateTypeCheckerSymbol
]
;
}
var
TypeInfo
=
function
TypeInfo
(
thisType
)
{
this
.
thisType
=
void
0
;
this
.
thisType
=
thisType
;
}
;
function
getTypeInfo
(
type
)
{
var
stdType
=
resolveStandardType
(
type
)
;
var
typeInfo
=
stdType
.
typeInfo
;
if
(
!
typeInfo
)
{
throw
failure
(
"
type
info
not
found
for
"
+
type
)
;
}
return
typeInfo
;
}
function
typesRefinement
(
baseType
checkFn
typeName
)
{
var
typeInfoGen
=
function
typeInfoGen
(
t
)
{
return
new
RefinementTypeInfo
(
t
resolveStandardType
(
baseType
)
checkFn
typeName
)
;
}
;
return
lateTypeChecker
(
function
(
)
{
var
baseChecker
=
resolveTypeChecker
(
baseType
)
;
var
getTypeName
=
function
getTypeName
(
)
{
for
(
var
_len
=
arguments
.
length
recursiveTypeCheckers
=
new
Array
(
_len
)
_key
=
0
;
_key
<
_len
;
_key
+
+
)
{
recursiveTypeCheckers
[
_key
]
=
arguments
[
_key
]
;
}
var
baseTypeName
=
baseChecker
.
getTypeName
.
apply
(
baseChecker
recursiveTypeCheckers
.
concat
(
[
baseChecker
]
)
)
;
var
refinementName
=
typeName
|
|
"
refinementOf
"
;
return
refinementName
+
"
<
"
+
baseTypeName
+
"
>
"
;
}
;
var
thisTc
=
new
TypeChecker
(
function
(
data
path
)
{
var
baseErr
=
baseChecker
.
check
(
data
path
)
;
if
(
baseErr
)
{
return
baseErr
;
}
var
refinementErr
=
checkFn
(
data
)
;
if
(
refinementErr
=
=
=
true
)
{
return
null
;
}
else
if
(
refinementErr
=
=
=
false
)
{
return
new
TypeCheckError
(
[
]
getTypeName
(
thisTc
)
data
)
;
}
else
{
return
refinementErr
!
=
null
?
refinementErr
:
null
;
}
}
getTypeName
typeInfoGen
)
;
return
thisTc
;
}
typeInfoGen
)
;
}
var
RefinementTypeInfo
=
function
(
_TypeInfo
)
{
_inheritsLoose
(
RefinementTypeInfo
_TypeInfo
)
;
_createClass
(
RefinementTypeInfo
[
{
key
:
"
baseTypeInfo
"
get
:
function
get
(
)
{
return
getTypeInfo
(
this
.
baseType
)
;
}
}
]
)
;
function
RefinementTypeInfo
(
thisType
baseType
checkFunction
typeName
)
{
var
_this
;
_this
=
_TypeInfo
.
call
(
this
thisType
)
|
|
this
;
_this
.
baseType
=
void
0
;
_this
.
checkFunction
=
void
0
;
_this
.
typeName
=
void
0
;
_this
.
baseType
=
baseType
;
_this
.
checkFunction
=
checkFunction
;
_this
.
typeName
=
typeName
;
return
_this
;
}
return
RefinementTypeInfo
;
}
(
TypeInfo
)
;
function
typesLiteral
(
literal
)
{
assertIsPrimitive
(
literal
"
literal
"
)
;
var
typeName
;
switch
(
literal
)
{
case
undefined
:
typeName
=
"
undefined
"
;
break
;
case
null
:
typeName
=
"
null
"
;
break
;
default
:
typeName
=
JSON
.
stringify
(
literal
)
;
break
;
}
var
typeInfoGen
=
function
typeInfoGen
(
t
)
{
return
new
LiteralTypeInfo
(
t
literal
)
;
}
;
return
new
TypeChecker
(
function
(
value
path
)
{
return
value
=
=
=
literal
?
null
:
new
TypeCheckError
(
path
typeName
value
)
;
}
function
(
)
{
return
typeName
;
}
typeInfoGen
)
;
}
var
LiteralTypeInfo
=
function
(
_TypeInfo
)
{
_inheritsLoose
(
LiteralTypeInfo
_TypeInfo
)
;
function
LiteralTypeInfo
(
thisType
literal
)
{
var
_this
;
_this
=
_TypeInfo
.
call
(
this
thisType
)
|
|
this
;
_this
.
literal
=
void
0
;
_this
.
literal
=
literal
;
return
_this
;
}
return
LiteralTypeInfo
;
}
(
TypeInfo
)
;
var
typesUndefined
=
typesLiteral
(
undefined
)
;
var
typesNull
=
typesLiteral
(
null
)
;
var
typesBoolean
=
new
TypeChecker
(
function
(
value
path
)
{
return
typeof
value
=
=
=
"
boolean
"
?
null
:
new
TypeCheckError
(
path
"
boolean
"
value
)
;
}
function
(
)
{
return
"
boolean
"
;
}
function
(
t
)
{
return
new
BooleanTypeInfo
(
t
)
;
}
)
;
var
BooleanTypeInfo
=
function
(
_TypeInfo2
)
{
_inheritsLoose
(
BooleanTypeInfo
_TypeInfo2
)
;
function
BooleanTypeInfo
(
)
{
return
_TypeInfo2
.
apply
(
this
arguments
)
|
|
this
;
}
return
BooleanTypeInfo
;
}
(
TypeInfo
)
;
var
typesNumber
=
new
TypeChecker
(
function
(
value
path
)
{
return
typeof
value
=
=
=
"
number
"
?
null
:
new
TypeCheckError
(
path
"
number
"
value
)
;
}
function
(
)
{
return
"
number
"
;
}
function
(
t
)
{
return
new
NumberTypeInfo
(
t
)
;
}
)
;
var
NumberTypeInfo
=
function
(
_TypeInfo3
)
{
_inheritsLoose
(
NumberTypeInfo
_TypeInfo3
)
;
function
NumberTypeInfo
(
)
{
return
_TypeInfo3
.
apply
(
this
arguments
)
|
|
this
;
}
return
NumberTypeInfo
;
}
(
TypeInfo
)
;
var
typesString
=
new
TypeChecker
(
function
(
value
path
)
{
return
typeof
value
=
=
=
"
string
"
?
null
:
new
TypeCheckError
(
path
"
string
"
value
)
;
}
function
(
)
{
return
"
string
"
;
}
function
(
t
)
{
return
new
StringTypeInfo
(
t
)
;
}
)
;
var
StringTypeInfo
=
function
(
_TypeInfo4
)
{
_inheritsLoose
(
StringTypeInfo
_TypeInfo4
)
;
function
StringTypeInfo
(
)
{
return
_TypeInfo4
.
apply
(
this
arguments
)
|
|
this
;
}
return
StringTypeInfo
;
}
(
TypeInfo
)
;
var
typesInteger
=
typesRefinement
(
typesNumber
function
(
n
)
{
return
Number
.
isInteger
(
n
)
;
}
"
integer
"
)
;
var
typesNonEmptyString
=
typesRefinement
(
typesString
function
(
s
)
{
return
s
!
=
=
"
"
;
}
"
nonEmpty
"
)
;
function
resolveTypeChecker
(
v
)
{
var
next
=
v
;
while
(
true
)
{
if
(
next
instanceof
TypeChecker
)
{
return
next
;
}
else
if
(
v
=
=
=
String
)
{
return
typesString
;
}
else
if
(
v
=
=
=
Number
)
{
return
typesNumber
;
}
else
if
(
v
=
=
=
Boolean
)
{
return
typesBoolean
;
}
else
if
(
v
=
=
=
null
)
{
return
typesNull
;
}
else
if
(
v
=
=
=
undefined
)
{
return
typesUndefined
;
}
else
if
(
isLateTypeChecker
(
next
)
)
{
next
=
next
(
)
;
}
else
{
throw
failure
(
"
type
checker
could
not
be
resolved
"
)
;
}
}
}
function
resolveStandardType
(
v
)
{
if
(
v
instanceof
TypeChecker
|
|
isLateTypeChecker
(
v
)
)
{
return
v
;
}
else
if
(
v
=
=
=
String
)
{
return
typesString
;
}
else
if
(
v
=
=
=
Number
)
{
return
typesNumber
;
}
else
if
(
v
=
=
=
Boolean
)
{
return
typesBoolean
;
}
else
if
(
v
=
=
=
null
)
{
return
typesNull
;
}
else
if
(
v
=
=
=
undefined
)
{
return
typesUndefined
;
}
else
{
throw
failure
(
"
standard
type
could
not
be
resolved
"
)
;
}
}
var
cachedModelTypeChecker
=
new
WeakMap
(
)
;
function
typesModel
(
modelClass
)
{
if
(
!
isModelClass
(
modelClass
)
&
&
typeof
modelClass
=
=
=
"
function
"
)
{
var
typeInfoGen
=
function
typeInfoGen
(
t
)
{
return
new
ModelTypeInfo
(
t
modelClass
(
)
)
;
}
;
return
lateTypeChecker
(
function
(
)
{
return
typesModel
(
modelClass
(
)
)
;
}
typeInfoGen
)
;
}
else
{
var
modelClazz
=
modelClass
;
assertIsModelClass
(
modelClazz
"
modelClass
"
)
;
var
cachedTypeChecker
=
cachedModelTypeChecker
.
get
(
modelClazz
)
;
if
(
cachedTypeChecker
)
{
return
cachedTypeChecker
;
}
var
_typeInfoGen
=
function
_typeInfoGen
(
t
)
{
return
new
ModelTypeInfo
(
t
modelClazz
)
;
}
;
var
tc
=
lateTypeChecker
(
function
(
)
{
var
modelInfo
=
modelInfoByClass
.
get
(
modelClazz
)
;
var
typeName
=
"
Model
(
"
+
modelInfo
.
name
+
"
)
"
;
return
new
TypeChecker
(
function
(
value
path
)
{
if
(
!
(
value
instanceof
modelClazz
)
)
{
return
new
TypeCheckError
(
path
typeName
value
)
;
}
var
dataTypeChecker
=
getModelDataType
(
value
)
;
if
(
!
dataTypeChecker
)
{
throw
failure
(
"
type
checking
cannot
be
performed
over
model
of
type
'
"
+
modelInfo
.
name
+
"
'
at
path
"
+
path
.
join
(
"
/
"
)
+
"
since
that
model
type
has
no
data
type
declared
consider
adding
a
data
type
or
using
types
.
unchecked
(
)
instead
"
)
;
}
var
resolvedTc
=
resolveTypeChecker
(
dataTypeChecker
)
;
if
(
!
resolvedTc
.
unchecked
)
{
return
resolvedTc
.
check
(
value
.
path
)
;
}
return
null
;
}
function
(
)
{
return
typeName
;
}
_typeInfoGen
)
;
}
_typeInfoGen
)
;
cachedModelTypeChecker
.
set
(
modelClazz
tc
)
;
return
tc
;
}
}
var
ModelTypeInfo
=
function
(
_TypeInfo
)
{
_inheritsLoose
(
ModelTypeInfo
_TypeInfo
)
;
_createClass
(
ModelTypeInfo
[
{
key
:
"
props
"
get
:
function
get
(
)
{
return
this
.
_props
(
)
;
}
}
{
key
:
"
modelType
"
get
:
function
get
(
)
{
var
modelInfo
=
modelInfoByClass
.
get
(
this
.
modelClass
)
;
return
modelInfo
.
name
;
}
}
]
)
;
function
ModelTypeInfo
(
thisType
modelClass
)
{
var
_this
;
_this
=
_TypeInfo
.
call
(
this
thisType
)
|
|
this
;
_this
.
modelClass
=
void
0
;
_this
.
_props
=
lateVal
(
function
(
)
{
var
objSchema
=
getInternalModelClassPropsInfo
(
_this
.
modelClass
)
;
var
propTypes
=
{
}
;
Object
.
keys
(
objSchema
)
.
forEach
(
function
(
propName
)
{
var
propData
=
objSchema
[
propName
]
;
var
type
=
propData
.
typeChecker
;
var
typeInfo
;
if
(
type
)
{
typeInfo
=
getTypeInfo
(
type
)
;
}
var
hasDefault
=
false
;
var
defaultValue
;
if
(
propData
.
defaultFn
!
=
=
noDefaultValue
)
{
defaultValue
=
propData
.
defaultFn
;
hasDefault
=
true
;
}
else
if
(
propData
.
defaultValue
!
=
=
noDefaultValue
)
{
defaultValue
=
propData
.
defaultValue
;
hasDefault
=
true
;
}
propTypes
[
propName
]
=
{
type
:
type
typeInfo
:
typeInfo
hasDefault
:
hasDefault
"
default
"
:
defaultValue
}
;
}
)
;
return
propTypes
;
}
)
;
_this
.
modelClass
=
modelClass
;
return
_this
;
}
return
ModelTypeInfo
;
}
(
TypeInfo
)
;
function
typeCheck
(
type
value
)
{
var
typeChecker
=
resolveTypeChecker
(
type
)
;
if
(
typeChecker
.
unchecked
)
{
return
null
;
}
else
{
return
typeChecker
.
check
(
value
[
]
)
;
}
}
function
canWrite
(
)
{
return
!
getActionProtection
(
)
|
|
!
!
getCurrentActionContext
(
)
;
}
function
assertCanWrite
(
)
{
if
(
!
canWrite
(
)
)
{
throw
failure
(
"
data
changes
must
be
performed
inside
model
actions
"
)
;
}
}
var
actionProtection
=
true
;
function
getActionProtection
(
)
{
return
actionProtection
;
}
function
runUnprotected
(
arg1
arg2
)
{
var
name
=
typeof
arg1
=
=
=
"
string
"
?
arg1
:
undefined
;
var
fn
=
typeof
arg1
=
=
=
"
string
"
?
arg2
:
arg1
;
var
innerAction
=
function
innerAction
(
)
{
var
oldActionProtection
=
actionProtection
;
actionProtection
=
false
;
try
{
return
fn
(
)
;
}
finally
{
actionProtection
=
oldActionProtection
;
tryRunPendingActions
(
)
;
}
}
;
if
(
name
)
{
return
(
0
mobx_esm
.
action
)
(
name
innerAction
)
(
)
;
}
else
{
return
(
0
mobx_esm
.
action
)
(
innerAction
)
(
)
;
}
}
var
pendingActions
=
[
]
;
function
isActionRunning
(
)
{
return
!
getActionProtection
(
)
|
|
getCurrentActionContext
(
)
;
}
function
enqueuePendingAction
(
action
)
{
if
(
isActionRunning
(
)
)
{
pendingActions
.
push
(
action
)
;
}
else
{
action
(
)
;
}
}
function
tryRunPendingActions
(
)
{
if
(
isActionRunning
(
)
)
{
return
false
;
}
while
(
pendingActions
.
length
>
0
)
{
var
nextAction
=
pendingActions
.
shift
(
)
;
nextAction
(
)
;
}
return
true
;
}
var
HookAction
;
(
function
(
HookAction
)
{
HookAction
[
"
OnInit
"
]
=
"
onInit
"
;
HookAction
[
"
OnAttachedToRootStore
"
]
=
"
onAttachedToRootStore
"
;
HookAction
[
"
OnAttachedToRootStoreDisposer
"
]
=
"
onAttachedToRootStoreDisposer
"
;
}
)
(
HookAction
|
|
(
HookAction
=
{
}
)
)
;
var
hookActionValues
=
new
Set
(
Object
.
values
(
HookAction
)
)
;
function
isHookAction
(
actionName
)
{
return
hookActionValues
.
has
(
actionName
)
;
}
var
perObjectActionMiddlewares
=
new
WeakMap
(
)
;
var
perObjectActionMiddlewaresIterator
=
new
WeakMap
(
)
;
function
getActionMiddlewares
(
obj
)
{
var
iterable
=
perObjectActionMiddlewaresIterator
.
get
(
obj
)
;
if
(
!
iterable
)
{
var
_iterable
;
iterable
=
(
_iterable
=
{
}
_iterable
[
Symbol
.
iterator
]
=
function
(
)
{
var
current
=
obj
;
function
getCurrentIterator
(
)
{
var
objMwares
=
current
?
perObjectActionMiddlewares
.
get
(
current
)
:
undefined
;
if
(
!
objMwares
|
|
objMwares
.
length
<
=
0
)
{
return
undefined
;
}
return
objMwares
[
Symbol
.
iterator
]
(
)
;
}
function
findNextIterator
(
)
{
var
nextIter
;
while
(
current
&
&
!
nextIter
)
{
current
=
fastGetParent
(
current
)
;
nextIter
=
getCurrentIterator
(
)
;
}
return
nextIter
;
}
var
iter
=
getCurrentIterator
(
)
;
if
(
!
iter
)
{
iter
=
findNextIterator
(
)
;
}
var
iterator
=
{
next
:
function
next
(
)
{
if
(
!
iter
)
{
return
{
value
:
undefined
done
:
true
}
;
}
var
result
=
iter
.
next
(
)
;
if
(
!
result
.
done
)
{
return
result
;
}
iter
=
findNextIterator
(
)
;
return
this
.
next
(
)
;
}
}
;
return
iterator
;
}
_iterable
)
;
perObjectActionMiddlewaresIterator
.
set
(
obj
iterable
)
;
}
return
iterable
;
}
function
addActionMiddleware
(
mware
)
{
assertIsObject
(
mware
"
middleware
"
)
;
var
middleware
=
mware
.
middleware
filter
=
mware
.
filter
subtreeRoot
=
mware
.
subtreeRoot
;
assertTweakedObject
(
subtreeRoot
"
middleware
.
subtreeRoot
"
)
;
assertIsFunction
(
middleware
"
middleware
.
middleware
"
)
;
if
(
filter
&
&
typeof
filter
!
=
=
"
function
"
)
{
throw
failure
(
"
middleware
.
filter
must
be
a
function
or
undefined
"
)
;
}
if
(
!
(
0
mobx_esm
.
isAction
)
(
middleware
)
)
{
middleware
=
(
0
mobx_esm
.
action
)
(
middleware
.
name
|
|
"
actionMiddleware
"
middleware
)
;
}
if
(
subtreeRoot
)
{
var
targetFilter
=
function
targetFilter
(
ctx
)
{
return
ctx
.
target
=
=
=
subtreeRoot
|
|
isChildOfParent
(
ctx
.
target
subtreeRoot
)
;
}
;
if
(
!
filter
)
{
filter
=
targetFilter
;
}
else
{
var
customFilter
=
filter
;
filter
=
function
filter
(
ctx
)
{
return
targetFilter
(
ctx
)
&
&
customFilter
(
ctx
)
;
}
;
}
}
var
actualMware
=
{
middleware
:
middleware
filter
:
filter
}
;
var
objMwares
=
perObjectActionMiddlewares
.
get
(
subtreeRoot
)
;
if
(
!
objMwares
)
{
objMwares
=
[
actualMware
]
;
perObjectActionMiddlewares
.
set
(
subtreeRoot
objMwares
)
;
}
else
{
objMwares
.
push
(
actualMware
)
;
}
return
function
(
)
{
deleteFromArray
(
objMwares
actualMware
)
;
}
;
}
var
modelActionSymbol
=
Symbol
(
"
modelAction
"
)
;
function
wrapInAction
(
_ref
)
{
var
name
=
_ref
.
name
fn
=
_ref
.
fn
actionType
=
_ref
.
actionType
overrideContext
=
_ref
.
overrideContext
_ref
isFlowFinisher
=
_ref
.
isFlowFinisher
isFlowFinisher
=
_ref
isFlowFinisher
=
=
=
void
0
?
false
:
_ref
isFlowFinisher
;
var
wrappedAction
=
(
0
mobx_esm
.
action
)
(
name
function
(
)
{
var
target
=
this
;
if
(
inDevMode
(
)
)
{
assertTweakedObject
(
target
"
wrappedAction
"
)
;
}
var
parentContext
=
getCurrentActionContext
(
)
;
var
context
=
{
actionName
:
name
type
:
actionType
target
:
target
args
:
Array
.
from
(
arguments
)
parentContext
:
parentContext
data
:
{
}
rootContext
:
undefined
}
;
if
(
overrideContext
)
{
overrideContext
(
context
)
;
}
if
(
!
context
.
rootContext
)
{
if
(
context
.
previousAsyncStepContext
)
{
context
.
rootContext
=
context
.
previousAsyncStepContext
.
rootContext
;
}
else
if
(
context
.
parentContext
)
{
context
.
rootContext
=
context
.
parentContext
.
rootContext
;
}
else
{
context
.
rootContext
=
context
;
}
}
setCurrentActionContext
(
context
)
;
var
mwareFn
=
fn
.
bind
.
apply
(
fn
[
target
]
.
concat
(
Array
.
prototype
.
slice
.
call
(
arguments
)
)
)
;
var
mwareIter
=
getActionMiddlewares
(
target
)
[
Symbol
.
iterator
]
(
)
;
var
mwareCur
=
mwareIter
.
next
(
)
;
while
(
!
mwareCur
.
done
)
{
var
mware
=
mwareCur
.
value
;
var
filterPassed
=
mware
.
filter
?
mware
.
filter
(
context
)
:
true
;
if
(
filterPassed
)
{
mwareFn
=
mware
.
middleware
.
bind
(
undefined
context
mwareFn
)
;
}
mwareCur
=
mwareIter
.
next
(
)
;
}
try
{
var
ret
=
mwareFn
(
)
;
if
(
isFlowFinisher
)
{
var
flowFinisher
=
ret
;
var
value
=
flowFinisher
.
value
;
if
(
flowFinisher
.
resolution
=
=
=
"
accept
"
)
{
flowFinisher
.
accepter
(
value
)
;
}
else
{
flowFinisher
.
rejecter
(
value
)
;
}
return
value
;
}
else
{
return
ret
;
}
}
finally
{
setCurrentActionContext
(
context
.
parentContext
)
;
tryRunPendingActions
(
)
;
}
}
)
;
wrappedAction
[
modelActionSymbol
]
=
true
;
return
wrappedAction
;
}
function
wrapModelMethodInActionIfNeeded
(
model
propertyKey
name
)
{
var
fn
=
model
[
propertyKey
]
;
if
(
isModelAction
(
fn
)
)
{
return
;
}
var
wrappedFn
=
wrapInAction
(
{
name
:
name
fn
:
fn
actionType
:
ActionContextActionType
.
Sync
}
)
;
var
proto
=
Object
.
getPrototypeOf
(
model
)
;
var
protoFn
=
proto
[
propertyKey
]
;
if
(
protoFn
=
=
=
fn
)
{
proto
[
propertyKey
]
=
wrappedFn
;
}
else
{
model
[
propertyKey
]
=
wrappedFn
;
}
}
var
WalkTreeMode
;
(
function
(
WalkTreeMode
)
{
WalkTreeMode
[
"
ParentFirst
"
]
=
"
parentFirst
"
;
WalkTreeMode
[
"
ChildrenFirst
"
]
=
"
childrenFirst
"
;
}
)
(
WalkTreeMode
|
|
(
WalkTreeMode
=
{
}
)
)
;
function
walkTree
(
target
predicate
mode
)
{
assertTweakedObject
(
target
"
target
"
)
;
if
(
mode
=
=
=
WalkTreeMode
.
ParentFirst
)
{
var
recurse
=
function
recurse
(
child
)
{
return
walkTreeParentFirst
(
child
predicate
recurse
)
;
}
;
return
walkTreeParentFirst
(
target
predicate
recurse
)
;
}
else
{
var
_recurse
=
function
_recurse
(
child
)
{
return
walkTreeChildrenFirst
(
child
predicate
_recurse
)
;
}
;
return
walkTreeChildrenFirst
(
target
predicate
_recurse
)
;
}
}
function
walkTreeParentFirst
(
target
rootPredicate
recurse
)
{
var
ret
=
rootPredicate
(
target
)
;
if
(
ret
!
=
=
undefined
)
{
return
ret
;
}
var
childrenIter
=
getObjectChildren
(
target
)
.
values
(
)
;
var
ch
=
childrenIter
.
next
(
)
;
while
(
!
ch
.
done
)
{
var
_ret
=
recurse
(
ch
.
value
)
;
if
(
_ret
!
=
=
undefined
)
{
return
_ret
;
}
ch
=
childrenIter
.
next
(
)
;
}
return
undefined
;
}
function
walkTreeChildrenFirst
(
target
rootPredicate
recurse
)
{
var
childrenIter
=
getObjectChildren
(
target
)
.
values
(
)
;
var
ch
=
childrenIter
.
next
(
)
;
while
(
!
ch
.
done
)
{
var
_ret2
=
recurse
(
ch
.
value
)
;
if
(
_ret2
!
=
=
undefined
)
{
return
_ret2
;
}
ch
=
childrenIter
.
next
(
)
;
}
var
ret
=
rootPredicate
(
target
)
;
if
(
ret
!
=
=
undefined
)
{
return
ret
;
}
return
undefined
;
}
function
computedWalkTreeAggregate
(
predicate
)
{
var
computedFns
=
new
WeakMap
(
)
;
var
getComputedTreeResult
=
function
getComputedTreeResult
(
tree
)
{
var
cmpted
=
computedFns
.
get
(
tree
)
;
if
(
!
cmpted
)
{
cmpted
=
(
0
mobx_esm
.
computed
)
(
function
(
)
{
return
walkTreeAggregate
(
tree
predicate
recurse
)
;
}
)
;
computedFns
.
set
(
tree
cmpted
)
;
}
return
cmpted
.
get
(
)
;
}
;
var
recurse
=
function
recurse
(
ch
)
{
return
getComputedTreeResult
(
ch
)
;
}
;
return
{
walk
:
function
walk
(
target
)
{
return
getComputedTreeResult
(
target
)
;
}
}
;
}
function
walkTreeAggregate
(
target
rootPredicate
recurse
)
{
var
map
;
var
rootVal
=
rootPredicate
(
target
)
;
var
childrenMap
=
getObjectChildren
(
target
)
;
var
childrenIter
=
childrenMap
.
values
(
)
;
var
ch
=
childrenIter
.
next
(
)
;
if
(
rootVal
=
=
=
undefined
&
&
childrenMap
.
size
=
=
=
1
)
{
return
recurse
(
ch
.
value
)
;
}
while
(
!
ch
.
done
)
{
var
childMap
=
recurse
(
ch
.
value
)
;
if
(
childMap
)
{
if
(
!
map
)
{
map
=
new
Map
(
)
;
}
var
mapIter
=
childMap
.
keys
(
)
;
var
mapCur
=
mapIter
.
next
(
)
;
while
(
!
mapCur
.
done
)
{
var
key
=
mapCur
.
value
;
var
val
=
childMap
.
get
(
key
)
;
map
.
set
(
key
val
)
;
mapCur
=
mapIter
.
next
(
)
;
}
}
ch
=
childrenIter
.
next
(
)
;
}
if
(
rootVal
!
=
=
undefined
)
{
if
(
!
map
)
{
map
=
new
Map
(
)
;
}
map
.
set
(
rootVal
target
)
;
}
return
map
;
}
var
onAttachedDisposers
=
new
WeakMap
(
)
;
var
attachToRootStore
=
(
0
mobx_esm
.
action
)
(
"
attachToRootStore
"
function
(
rootStore
child
)
{
var
childrenToCall
=
[
]
;
walkTree
(
child
function
(
ch
)
{
if
(
ch
instanceof
BaseModel
&
&
ch
.
onAttachedToRootStore
)
{
wrapModelMethodInActionIfNeeded
(
ch
"
onAttachedToRootStore
"
HookAction
.
OnAttachedToRootStore
)
;
childrenToCall
.
push
(
ch
)
;
}
}
WalkTreeMode
.
ParentFirst
)
;
var
childrenToCallLen
=
childrenToCall
.
length
;
for
(
var
i
=
0
;
i
<
childrenToCallLen
;
i
+
+
)
{
var
ch
=
childrenToCall
[
i
]
;
var
disposer
=
ch
.
onAttachedToRootStore
(
rootStore
)
;
if
(
disposer
)
{
onAttachedDisposers
.
set
(
ch
disposer
)
;
}
}
}
)
;
var
detachFromRootStore
=
(
0
mobx_esm
.
action
)
(
"
detachFromRootStore
"
function
(
child
)
{
var
disposersToCall
=
[
]
;
walkTree
(
child
function
(
ch
)
{
var
disposer
=
onAttachedDisposers
.
get
(
ch
)
;
if
(
disposer
)
{
var
disposerAction
=
wrapInAction
(
{
name
:
HookAction
.
OnAttachedToRootStoreDisposer
fn
:
disposer
actionType
:
ActionContextActionType
.
Sync
}
)
.
bind
(
ch
)
;
onAttachedDisposers
[
"
delete
"
]
(
ch
)
;
disposersToCall
.
push
(
disposerAction
)
;
}
}
WalkTreeMode
.
ChildrenFirst
)
;
var
disposersToCallLen
=
disposersToCall
.
length
;
for
(
var
i
=
0
;
i
<
disposersToCallLen
;
i
+
+
)
{
disposersToCall
[
i
]
(
)
;
}
}
)
;
var
rootStores
=
new
WeakSet
(
)
;
var
rootStoreAtoms
=
new
WeakMap
(
)
;
var
registerRootStore
=
(
0
mobx_esm
.
action
)
(
"
registerRootStore
"
function
(
node
)
{
assertTweakedObject
(
node
"
node
"
)
;
if
(
rootStores
.
has
(
node
)
)
{
throw
failure
(
"
object
already
registered
as
root
store
"
)
;
}
if
(
!
isRoot
(
node
)
)
{
throw
failure
(
"
a
root
store
must
not
have
a
parent
"
)
;
}
rootStores
.
add
(
node
)
;
attachToRootStore
(
node
node
)
;
getOrCreateRootStoreAtom
(
node
)
.
reportChanged
(
)
;
return
node
;
}
)
;
var
unregisterRootStore
=
(
0
mobx_esm
.
action
)
(
"
unregisterRootStore
"
function
(
node
)
{
if
(
!
isRootStore
(
node
)
)
{
throw
failure
(
"
not
a
root
store
"
)
;
}
rootStores
[
"
delete
"
]
(
node
)
;
detachFromRootStore
(
node
)
;
getOrCreateRootStoreAtom
(
node
)
.
reportChanged
(
)
;
}
)
;
function
isRootStore
(
node
)
{
assertTweakedObject
(
node
"
node
"
)
;
return
fastIsRootStore
(
node
)
;
}
function
fastIsRootStore
(
node
)
{
getOrCreateRootStoreAtom
(
node
)
.
reportObserved
(
)
;
return
rootStores
.
has
(
node
)
;
}
function
getRootStore
(
node
)
{
assertTweakedObject
(
node
"
node
"
)
;
return
fastGetRootStore
(
node
)
;
}
function
fastGetRootStore
(
node
)
{
var
root
=
fastGetRoot
(
node
)
;
return
fastIsRootStore
(
root
)
?
root
:
undefined
;
}
function
getOrCreateRootStoreAtom
(
node
)
{
var
atom
=
rootStoreAtoms
.
get
(
node
)
;
if
(
!
atom
)
{
atom
=
(
0
mobx_esm
.
createAtom
)
(
"
rootStore
"
)
;
rootStoreAtoms
.
set
(
node
atom
)
;
}
return
atom
;
}
var
setParent
=
(
0
mobx_esm
.
action
)
(
"
setParent
"
function
(
value
parentPath
indexChangeAllowed
isDataObject
)
{
if
(
isPrimitive
(
value
)
)
{
return
;
}
if
(
inDevMode
(
)
)
{
if
(
typeof
value
=
=
=
"
function
"
|
|
typeof
value
=
=
=
"
symbol
"
)
{
throw
failure
(
"
assertion
failed
:
value
cannot
be
a
function
or
a
symbol
"
)
;
}
if
(
!
isTweakedObject
(
value
true
)
)
{
throw
failure
(
"
assertion
failed
:
value
is
not
ready
to
take
a
parent
"
)
;
}
if
(
parentPath
)
{
if
(
!
isTweakedObject
(
parentPath
.
parent
true
)
)
{
throw
failure
(
"
assertion
failed
:
parent
is
not
ready
to
take
children
"
)
;
}
}
}
if
(
isDataObject
)
{
dataObjectParent
.
set
(
value
parentPath
.
parent
)
;
return
;
}
initializeObjectChildren
(
value
)
;
if
(
parentPath
)
{
var
actualParent
=
dataToModelNode
(
parentPath
.
parent
)
;
if
(
parentPath
.
parent
!
=
=
actualParent
)
{
parentPath
=
{
parent
:
actualParent
path
:
parentPath
.
path
}
;
}
}
var
oldParentPath
=
fastGetParentPath
(
value
)
;
if
(
parentPathEquals
(
oldParentPath
parentPath
)
)
{
return
;
}
if
(
isRootStore
(
value
)
)
{
throw
failure
(
"
root
stores
cannot
be
attached
to
any
parents
"
)
;
}
if
(
oldParentPath
&
&
parentPath
)
{
if
(
oldParentPath
.
parent
=
=
=
parentPath
.
parent
&
&
indexChangeAllowed
)
{
objectParents
.
set
(
value
parentPath
)
;
reportParentPathChanged
(
value
)
;
return
;
}
else
{
throw
failure
(
"
an
object
cannot
be
assigned
a
new
parent
when
it
already
has
one
"
)
;
}
}
var
removeFromOldParent
=
function
removeFromOldParent
(
)
{
if
(
oldParentPath
=
=
null
?
void
0
:
oldParentPath
.
parent
)
{
removeObjectChild
(
oldParentPath
.
parent
value
)
;
}
}
;
var
attachToNewParent
=
function
attachToNewParent
(
)
{
var
_parentPath
;
objectParents
.
set
(
value
parentPath
)
;
if
(
(
_parentPath
=
parentPath
)
=
=
null
?
void
0
:
_parentPath
.
parent
)
{
addObjectChild
(
parentPath
.
parent
value
)
;
}
reportParentPathChanged
(
value
)
;
}
;
if
(
value
instanceof
BaseModel
)
{
var
oldRoot
=
fastGetRoot
(
value
)
;
var
oldRootStore
=
isRootStore
(
oldRoot
)
?
oldRoot
:
undefined
;
removeFromOldParent
(
)
;
attachToNewParent
(
)
;
var
newRoot
=
fastGetRoot
(
value
)
;
var
newRootStore
=
isRootStore
(
newRoot
)
?
newRoot
:
undefined
;
if
(
oldRootStore
!
=
=
newRootStore
&
&
(
oldRootStore
|
|
newRootStore
)
)
{
enqueuePendingAction
(
function
(
)
{
if
(
oldRootStore
)
{
detachFromRootStore
(
value
)
;
}
if
(
newRootStore
)
{
attachToRootStore
(
newRootStore
value
)
;
}
}
)
;
}
}
else
{
removeFromOldParent
(
)
;
attachToNewParent
(
)
;
}
}
)
;
function
tweakModel
(
value
parentPath
)
{
tweakedObjects
.
set
(
value
undefined
)
;
setParent
(
value
parentPath
false
false
)
;
return
value
;
}
var
InternalPatchRecorder
=
function
(
)
{
function
InternalPatchRecorder
(
)
{
this
.
patches
=
void
0
;
this
.
invPatches
=
void
0
;
}
var
_proto
=
InternalPatchRecorder
.
prototype
;
_proto
.
record
=
function
record
(
patches
invPatches
)
{
this
.
patches
=
patches
;
this
.
invPatches
=
invPatches
;
}
;
_proto
.
emit
=
function
emit
(
obj
)
{
emitPatch
(
obj
this
.
patches
this
.
invPatches
true
)
;
}
;
return
InternalPatchRecorder
;
}
(
)
;
var
patchListeners
=
new
WeakMap
(
)
;
var
globalPatchListeners
=
[
]
;
function
onPatches
(
subtreeRoot
listener
)
{
assertTweakedObject
(
subtreeRoot
"
subtreeRoot
"
)
;
assertIsFunction
(
listener
"
listener
"
)
;
if
(
!
(
0
mobx_esm
.
isAction
)
(
listener
)
)
{
listener
=
(
0
mobx_esm
.
action
)
(
listener
.
name
|
|
"
onPatchesListener
"
listener
)
;
}
var
listenersForObject
=
patchListeners
.
get
(
subtreeRoot
)
;
if
(
!
listenersForObject
)
{
listenersForObject
=
[
]
;
patchListeners
.
set
(
subtreeRoot
listenersForObject
)
;
}
listenersForObject
.
push
(
listener
)
;
return
function
(
)
{
deleteFromArray
(
listenersForObject
listener
)
;
}
;
}
function
onGlobalPatches
(
listener
)
{
assertIsFunction
(
listener
"
listener
"
)
;
if
(
!
(
0
mobx_esm
.
isAction
)
(
listener
)
)
{
listener
=
(
0
mobx_esm
.
action
)
(
listener
.
name
|
|
"
onGlobalPatchesListener
"
listener
)
;
}
globalPatchListeners
.
push
(
listener
)
;
return
function
(
)
{
deleteFromArray
(
globalPatchListeners
listener
)
;
}
;
}
function
emitPatch
(
obj
patches
inversePatches
emitGlobally
)
{
if
(
patches
.
length
<
=
0
&
&
inversePatches
.
length
<
=
0
)
{
return
;
}
if
(
emitGlobally
)
{
for
(
var
i
=
0
;
i
<
globalPatchListeners
.
length
;
i
+
+
)
{
var
listener
=
globalPatchListeners
[
i
]
;
listener
(
obj
patches
inversePatches
)
;
}
}
var
listenersForObject
=
patchListeners
.
get
(
obj
)
;
if
(
listenersForObject
)
{
for
(
var
_i
=
0
;
_i
<
listenersForObject
.
length
;
_i
+
+
)
{
var
_listener
=
listenersForObject
[
_i
]
;
_listener
(
patches
inversePatches
)
;
}
}
var
parentPath
=
fastGetParentPath
(
obj
)
;
if
(
parentPath
)
{
var
childPath
=
parentPath
.
path
;
var
newPatches
=
patches
.
map
(
function
(
p
)
{
return
addPathToPatch
(
p
childPath
)
;
}
)
;
var
newInversePatches
=
inversePatches
.
map
(
function
(
p
)
{
return
addPathToPatch
(
p
childPath
)
;
}
)
;
emitPatch
(
parentPath
.
parent
newPatches
newInversePatches
false
)
;
}
}
function
addPathToPatch
(
patch
path
)
{
return
_extends
(
{
}
patch
{
path
:
[
path
]
.
concat
(
patch
.
path
)
}
)
;
}
var
FrozenCheckMode
;
(
function
(
FrozenCheckMode
)
{
FrozenCheckMode
[
"
DevModeOnly
"
]
=
"
devModeOnly
"
;
FrozenCheckMode
[
"
On
"
]
=
"
on
"
;
FrozenCheckMode
[
"
Off
"
]
=
"
off
"
;
}
)
(
FrozenCheckMode
|
|
(
FrozenCheckMode
=
{
}
)
)
;
var
frozenKey
=
"
frozen
"
;
var
Frozen
=
function
Frozen
(
dataToFreeze
checkMode
)
{
if
(
checkMode
=
=
=
void
0
)
{
checkMode
=
FrozenCheckMode
.
DevModeOnly
;
}
this
.
data
=
void
0
;
var
check
=
checkMode
=
=
=
FrozenCheckMode
.
On
|
|
checkMode
=
=
=
FrozenCheckMode
.
DevModeOnly
&
&
inDevMode
(
)
;
if
(
check
)
{
checkDataIsSerializableAndFreeze
(
dataToFreeze
)
;
}
this
.
data
=
dataToFreeze
;
if
(
check
)
{
Object
.
freeze
(
this
.
data
)
;
}
tweak
(
this
undefined
)
;
}
;
function
frozen
(
data
checkMode
)
{
if
(
checkMode
=
=
=
void
0
)
{
checkMode
=
FrozenCheckMode
.
DevModeOnly
;
}
return
new
Frozen
(
data
checkMode
)
;
}
function
checkDataIsSerializableAndFreeze
(
data
)
{
if
(
isPrimitive
(
data
)
)
{
return
;
}
if
(
Array
.
isArray
(
data
)
)
{
var
arrLen
=
data
.
length
;
for
(
var
i
=
0
;
i
<
arrLen
;
i
+
+
)
{
var
v
=
data
[
i
]
;
if
(
v
=
=
=
undefined
&
&
!
getGlobalConfig
(
)
.
allowUndefinedArrayElements
)
{
throw
failure
(
"
undefined
is
not
supported
inside
arrays
since
it
is
not
serializable
in
JSON
consider
using
null
instead
"
)
;
}
checkDataIsSerializableAndFreeze
(
v
)
;
}
Object
.
freeze
(
data
)
;
return
;
}
if
(
isPlainObject
(
data
)
)
{
var
dataKeys
=
Object
.
keys
(
data
)
;
var
dataKeysLen
=
dataKeys
.
length
;
for
(
var
_i
=
0
;
_i
<
dataKeysLen
;
_i
+
+
)
{
var
k
=
dataKeys
[
_i
]
;
var
_v
=
data
[
k
]
;
checkDataIsSerializableAndFreeze
(
k
)
;
checkDataIsSerializableAndFreeze
(
_v
)
;
}
Object
.
freeze
(
data
)
;
return
;
}
throw
failure
(
"
frozen
data
must
be
plainly
serializable
to
JSON
but
"
+
data
+
"
is
not
"
)
;
}
function
isFrozenSnapshot
(
snapshot
)
{
return
isPlainObject
(
snapshot
)
&
&
!
!
snapshot
[
frozenKey
]
;
}
function
findParent
(
child
predicate
maxDepth
)
{
if
(
maxDepth
=
=
=
void
0
)
{
maxDepth
=
0
;
}
var
foundParentPath
=
findParentPath
(
child
predicate
maxDepth
)
;
return
foundParentPath
?
foundParentPath
.
parent
:
undefined
;
}
function
findParentPath
(
child
predicate
maxDepth
)
{
if
(
maxDepth
=
=
=
void
0
)
{
maxDepth
=
0
;
}
assertTweakedObject
(
child
"
child
"
)
;
var
path
=
[
]
;
var
current
=
child
;
var
depth
=
0
;
var
parentPath
;
while
(
parentPath
=
fastGetParentPath
(
current
)
)
{
path
.
unshift
(
parentPath
.
path
)
;
current
=
parentPath
.
parent
;
if
(
predicate
(
current
)
)
{
return
{
parent
:
current
path
:
path
}
;
}
depth
+
+
;
if
(
maxDepth
>
0
&
&
depth
=
=
=
maxDepth
)
{
break
;
}
}
return
undefined
;
}
var
BuiltInAction
;
(
function
(
BuiltInAction
)
{
BuiltInAction
[
"
ApplyPatches
"
]
=
"
applyPatches
"
;
BuiltInAction
[
"
ApplySnapshot
"
]
=
"
applySnapshot
"
;
BuiltInAction
[
"
Detach
"
]
=
"
detach
"
;
BuiltInAction
[
"
ApplySet
"
]
=
"
applySet
"
;
BuiltInAction
[
"
ApplyDelete
"
]
=
"
applyDelete
"
;
BuiltInAction
[
"
ApplyMethodCall
"
]
=
"
applyMethodCall
"
;
}
)
(
BuiltInAction
|
|
(
BuiltInAction
=
{
}
)
)
;
var
builtInActionValues
=
new
Set
(
Object
.
values
(
BuiltInAction
)
)
;
function
isBuiltInAction
(
actionName
)
{
return
builtInActionValues
.
has
(
actionName
)
;
}
function
detach
(
node
)
{
assertTweakedObject
(
node
"
node
"
)
;
wrappedInternalDetach
(
)
.
call
(
node
)
;
}
var
wrappedInternalDetach
=
lazy
(
function
(
)
{
return
wrapInAction
(
{
name
:
BuiltInAction
.
Detach
fn
:
internalDetach
actionType
:
ActionContextActionType
.
Sync
}
)
;
}
)
;
function
internalDetach
(
)
{
var
node
=
this
;
var
parentPath
=
fastGetParentPathIncludingDataObjects
(
node
)
;
if
(
!
parentPath
)
return
;
var
parent
=
parentPath
.
parent
path
=
parentPath
.
path
;
if
(
(
0
mobx_esm
.
isObservableArray
)
(
parent
)
)
{
parent
.
splice
(
+
path
1
)
;
}
else
if
(
(
0
mobx_esm
.
isObservableObject
)
(
parent
)
)
{
(
0
mobx_esm
.
remove
)
(
parent
"
"
+
path
)
;
}
else
{
throw
failure
(
"
parent
must
be
an
observable
object
or
an
observable
array
"
)
;
}
}
function
getChildrenObjects
(
node
options
)
{
assertTweakedObject
(
node
"
node
"
)
;
if
(
!
options
|
|
!
options
.
deep
)
{
return
getObjectChildren
(
node
)
;
}
else
{
return
getDeepObjectChildren
(
node
)
.
deep
;
}
}
function
onChildAttachedTo
(
target
fn
options
)
{
assertIsFunction
(
target
"
target
"
)
;
assertIsFunction
(
fn
"
fn
"
)
;
var
opts
=
_extends
(
{
deep
:
false
runForCurrentChildren
:
true
}
options
)
;
var
detachDisposers
=
new
WeakMap
(
)
;
var
runDetachDisposer
=
function
runDetachDisposer
(
n
)
{
var
detachDisposer
=
detachDisposers
.
get
(
n
)
;
if
(
detachDisposer
)
{
detachDisposers
[
"
delete
"
]
(
n
)
;
detachDisposer
(
)
;
}
}
;
var
addDetachDisposer
=
function
addDetachDisposer
(
n
disposer
)
{
if
(
disposer
)
{
detachDisposers
.
set
(
n
disposer
)
;
}
}
;
var
getChildrenObjectOpts
=
{
deep
:
opts
.
deep
}
;
var
getCurrentChildren
=
function
getCurrentChildren
(
)
{
var
t
=
target
(
)
;
assertTweakedObject
(
t
"
target
(
)
"
)
;
var
children
=
getChildrenObjects
(
t
getChildrenObjectOpts
)
;
var
set
=
new
Set
(
)
;
var
iter
=
children
.
values
(
)
;
var
cur
=
iter
.
next
(
)
;
while
(
!
cur
.
done
)
{
set
.
add
(
cur
.
value
)
;
cur
=
iter
.
next
(
)
;
}
return
set
;
}
;
var
currentChildren
=
opts
.
runForCurrentChildren
?
new
Set
(
)
:
getCurrentChildren
(
)
;
var
disposer
=
(
0
mobx_esm
.
reaction
)
(
function
(
)
{
return
getCurrentChildren
(
)
;
}
function
(
newChildren
)
{
var
disposersToRun
=
[
]
;
var
currentChildrenIter
=
currentChildren
.
values
(
)
;
var
currentChildrenCur
=
currentChildrenIter
.
next
(
)
;
while
(
!
currentChildrenCur
.
done
)
{
var
n
=
currentChildrenCur
.
value
;
if
(
!
newChildren
.
has
(
n
)
)
{
currentChildren
[
"
delete
"
]
(
n
)
;
disposersToRun
.
push
(
n
)
;
}
currentChildrenCur
=
currentChildrenIter
.
next
(
)
;
}
if
(
disposersToRun
.
length
>
0
)
{
for
(
var
i
=
disposersToRun
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
runDetachDisposer
(
disposersToRun
[
i
]
)
;
}
}
var
newChildrenIter
=
newChildren
.
values
(
)
;
var
newChildrenCur
=
newChildrenIter
.
next
(
)
;
while
(
!
newChildrenCur
.
done
)
{
var
_n
=
newChildrenCur
.
value
;
if
(
!
currentChildren
.
has
(
_n
)
)
{
currentChildren
.
add
(
_n
)
;
addDetachDisposer
(
_n
fn
(
_n
)
)
;
}
newChildrenCur
=
newChildrenIter
.
next
(
)
;
}
}
{
fireImmediately
:
true
}
)
;
return
function
(
runDetachDisposers
)
{
disposer
(
)
;
if
(
runDetachDisposers
)
{
var
currentChildrenIter
=
currentChildren
.
values
(
)
;
var
currentChildrenCur
=
currentChildrenIter
.
next
(
)
;
while
(
!
currentChildrenCur
.
done
)
{
var
n
=
currentChildrenCur
.
value
;
runDetachDisposer
(
n
)
;
currentChildrenCur
=
currentChildrenIter
.
next
(
)
;
}
}
currentChildren
.
clear
(
)
;
}
;
}
var
fromSnapshot
=
function
fromSnapshot
(
snapshot
options
)
{
var
opts
=
_extends
(
{
generateNewIds
:
false
overrideRootModelId
:
undefined
}
options
)
;
var
ctx
=
{
options
:
opts
}
;
ctx
.
snapshotToInitialData
=
snapshotToInitialData
.
bind
(
undefined
ctx
)
;
return
internalFromSnapshot
(
snapshot
ctx
)
;
}
;
fromSnapshot
=
(
0
mobx_esm
.
action
)
(
"
fromSnapshot
"
fromSnapshot
)
;
function
internalFromSnapshot
(
sn
ctx
)
{
if
(
isPrimitive
(
sn
)
)
{
return
sn
;
}
if
(
isMap
(
sn
)
)
{
throw
failure
(
"
a
snapshot
must
not
contain
maps
"
)
;
}
if
(
isSet
(
sn
)
)
{
throw
failure
(
"
a
snapshot
must
not
contain
sets
"
)
;
}
if
(
isArray
(
sn
)
)
{
return
fromArraySnapshot
(
sn
ctx
)
;
}
if
(
isFrozenSnapshot
(
sn
)
)
{
return
frozen
(
sn
.
data
)
;
}
if
(
isModelSnapshot
(
sn
)
)
{
return
fromModelSnapshot
(
sn
ctx
)
;
}
if
(
isPlainObject
(
sn
)
)
{
return
fromPlainObjectSnapshot
(
sn
ctx
)
;
}
throw
failure
(
"
unsupported
snapshot
-
"
+
sn
)
;
}
function
fromArraySnapshot
(
sn
ctx
)
{
var
arr
=
mobx_esm
.
observable
.
array
(
[
]
observableOptions
)
;
var
ln
=
sn
.
length
;
for
(
var
i
=
0
;
i
<
ln
;
i
+
+
)
{
arr
.
push
(
internalFromSnapshot
(
sn
[
i
]
ctx
)
)
;
}
return
tweakArray
(
arr
undefined
true
)
;
}
function
fromModelSnapshot
(
sn
ctx
)
{
var
type
=
sn
[
modelTypeKey
]
;
if
(
!
type
)
{
throw
failure
(
"
a
model
snapshot
must
contain
a
type
key
(
"
+
modelTypeKey
+
"
)
but
none
was
found
"
)
;
}
var
modelInfo
=
getModelInfoForName
(
type
)
;
if
(
!
modelInfo
)
{
throw
failure
(
"
model
with
name
\
"
"
+
type
+
"
\
"
not
found
in
the
registry
"
)
;
}
if
(
!
sn
[
modelIdKey
]
)
{
throw
failure
(
"
a
model
snapshot
must
contain
an
id
key
(
"
+
modelIdKey
+
"
)
but
none
was
found
"
)
;
}
return
new
modelInfo
[
"
class
"
]
(
undefined
{
snapshotInitialData
:
{
unprocessedSnapshot
:
sn
snapshotToInitialData
:
ctx
.
snapshotToInitialData
}
generateNewIds
:
ctx
.
options
.
generateNewIds
}
)
;
}
function
snapshotToInitialData
(
ctx
processedSn
)
{
var
initialData
=
mobx_esm
.
observable
.
object
(
{
}
undefined
observableOptions
)
;
var
processedSnKeys
=
Object
.
keys
(
processedSn
)
;
var
processedSnKeysLen
=
processedSnKeys
.
length
;
for
(
var
i
=
0
;
i
<
processedSnKeysLen
;
i
+
+
)
{
var
k
=
processedSnKeys
[
i
]
;
if
(
!
isReservedModelKey
(
k
)
)
{
var
v
=
processedSn
[
k
]
;
(
0
mobx_esm
.
set
)
(
initialData
k
internalFromSnapshot
(
v
ctx
)
)
;
}
}
return
initialData
;
}
function
fromPlainObjectSnapshot
(
sn
ctx
)
{
var
plainObj
=
mobx_esm
.
observable
.
object
(
{
}
undefined
observableOptions
)
;
var
snKeys
=
Object
.
keys
(
sn
)
;
var
snKeysLen
=
snKeys
.
length
;
for
(
var
i
=
0
;
i
<
snKeysLen
;
i
+
+
)
{
var
k
=
snKeys
[
i
]
;
var
v
=
sn
[
k
]
;
(
0
mobx_esm
.
set
)
(
plainObj
k
internalFromSnapshot
(
v
ctx
)
)
;
}
return
tweakPlainObject
(
plainObj
undefined
undefined
true
false
)
;
}
var
observableOptions
=
{
deep
:
false
}
;
function
reconcileSnapshot
(
value
sn
modelPool
)
{
if
(
isPrimitive
(
sn
)
)
{
return
sn
;
}
if
(
isArray
(
sn
)
)
{
return
reconcileArraySnapshot
(
value
sn
modelPool
)
;
}
if
(
isFrozenSnapshot
(
sn
)
)
{
return
reconcileFrozenSnapshot
(
value
sn
)
;
}
if
(
isModelSnapshot
(
sn
)
)
{
return
reconcileModelSnapshot
(
value
sn
modelPool
)
;
}
if
(
isPlainObject
(
sn
)
)
{
return
reconcilePlainObjectSnapshot
(
value
sn
modelPool
)
;
}
if
(
isMap
(
sn
)
)
{
throw
failure
(
"
a
snapshot
must
not
contain
maps
"
)
;
}
if
(
isSet
(
sn
)
)
{
throw
failure
(
"
a
snapshot
must
not
contain
sets
"
)
;
}
throw
failure
(
"
unsupported
snapshot
-
"
+
sn
)
;
}
function
reconcileArraySnapshot
(
value
sn
modelPool
)
{
if
(
!
isArray
(
value
)
)
{
return
fromSnapshot
(
sn
)
;
}
if
(
value
.
length
>
sn
.
length
)
{
value
.
splice
(
sn
.
length
value
.
length
-
sn
.
length
)
;
}
for
(
var
i
=
0
;
i
<
value
.
length
;
i
+
+
)
{
var
oldValue
=
value
[
i
]
;
var
newValue
=
reconcileSnapshot
(
oldValue
sn
[
i
]
modelPool
)
;
detachIfNeeded
(
newValue
oldValue
modelPool
)
;
(
0
mobx_esm
.
set
)
(
value
i
newValue
)
;
}
for
(
var
_i
=
value
.
length
;
_i
<
sn
.
length
;
_i
+
+
)
{
value
.
push
(
reconcileSnapshot
(
undefined
sn
[
_i
]
modelPool
)
)
;
}
return
value
;
}
function
reconcileFrozenSnapshot
(
value
sn
)
{
if
(
value
instanceof
Frozen
&
&
value
.
data
=
=
=
sn
.
data
)
{
return
value
;
}
return
frozen
(
sn
.
data
)
;
}
function
reconcileModelSnapshot
(
value
sn
modelPool
)
{
var
type
=
sn
[
modelTypeKey
]
;
var
modelInfo
=
getModelInfoForName
(
type
)
;
if
(
!
modelInfo
)
{
throw
failure
(
"
model
with
name
\
"
"
+
type
+
"
\
"
not
found
in
the
registry
"
)
;
}
var
id
=
sn
[
modelIdKey
]
;
var
modelInPool
=
modelPool
.
findModelForSnapshot
(
sn
)
;
if
(
modelInPool
)
{
value
=
modelInPool
;
}
if
(
!
(
value
instanceof
modelInfo
[
"
class
"
]
)
|
|
value
[
modelTypeKey
]
!
=
=
type
|
|
value
[
modelIdKey
]
!
=
=
id
)
{
return
fromSnapshot
(
sn
)
;
}
var
modelObj
=
value
;
var
processedSn
=
sn
;
if
(
modelObj
.
fromSnapshot
)
{
processedSn
=
modelObj
.
fromSnapshot
(
sn
)
;
}
var
data
=
modelObj
.
;
var
dataKeys
=
Object
.
keys
(
data
)
;
var
dataKeysLen
=
dataKeys
.
length
;
for
(
var
i
=
0
;
i
<
dataKeysLen
;
i
+
+
)
{
var
k
=
dataKeys
[
i
]
;
if
(
!
(
k
in
processedSn
)
)
{
(
0
mobx_esm
.
remove
)
(
data
k
)
;
}
}
var
processedSnKeys
=
Object
.
keys
(
processedSn
)
;
var
processedSnKeysLen
=
processedSnKeys
.
length
;
for
(
var
_i2
=
0
;
_i2
<
processedSnKeysLen
;
_i2
+
+
)
{
var
_k
=
processedSnKeys
[
_i2
]
;
if
(
!
isReservedModelKey
(
_k
)
)
{
var
v
=
processedSn
[
_k
]
;
var
oldValue
=
data
[
_k
]
;
var
newValue
=
reconcileSnapshot
(
oldValue
v
modelPool
)
;
detachIfNeeded
(
newValue
oldValue
modelPool
)
;
(
0
mobx_esm
.
set
)
(
data
_k
newValue
)
;
}
}
return
modelObj
;
}
function
reconcilePlainObjectSnapshot
(
value
sn
modelPool
)
{
if
(
!
isPlainObject
(
value
)
&
&
!
(
0
mobx_esm
.
isObservableObject
)
(
value
)
)
{
return
fromSnapshot
(
sn
)
;
}
var
plainObj
=
value
;
var
plainObjKeys
=
Object
.
keys
(
plainObj
)
;
var
plainObjKeysLen
=
plainObjKeys
.
length
;
for
(
var
i
=
0
;
i
<
plainObjKeysLen
;
i
+
+
)
{
var
k
=
plainObjKeys
[
i
]
;
if
(
!
(
k
in
sn
)
)
{
(
0
mobx_esm
.
remove
)
(
plainObj
k
)
;
}
}
var
snKeys
=
Object
.
keys
(
sn
)
;
var
snKeysLen
=
snKeys
.
length
;
for
(
var
_i3
=
0
;
_i3
<
snKeysLen
;
_i3
+
+
)
{
var
_k2
=
snKeys
[
_i3
]
;
var
v
=
sn
[
_k2
]
;
var
oldValue
=
plainObj
[
_k2
]
;
var
newValue
=
reconcileSnapshot
(
oldValue
v
modelPool
)
;
detachIfNeeded
(
newValue
oldValue
modelPool
)
;
(
0
mobx_esm
.
set
)
(
plainObj
_k2
newValue
)
;
}
return
plainObj
;
}
function
detachIfNeeded
(
newValue
oldValue
modelPool
)
{
if
(
newValue
=
=
=
oldValue
)
{
return
;
}
if
(
isModel
(
newValue
)
&
&
modelPool
.
findModelByTypeAndId
(
newValue
[
modelTypeKey
]
newValue
[
modelIdKey
]
)
)
{
var
parentPath
=
fastGetParentPathIncludingDataObjects
(
newValue
)
;
if
(
parentPath
)
{
(
0
mobx_esm
.
set
)
(
parentPath
.
parent
parentPath
.
path
null
)
;
}
}
}
var
ModelPool
=
function
(
)
{
function
ModelPool
(
root
)
{
var
_dataObjectParent
get
;
this
.
pool
=
void
0
;
root
=
(
_dataObjectParent
get
=
dataObjectParent
.
get
(
root
)
)
!
=
null
?
_dataObjectParent
get
:
root
;
this
.
pool
=
getDeepObjectChildren
(
root
)
.
deepByModelTypeAndId
;
}
var
_proto
=
ModelPool
.
prototype
;
_proto
.
findModelByTypeAndId
=
function
findModelByTypeAndId
(
modelType
modelId
)
{
return
this
.
pool
.
get
(
byModelTypeAndIdKey
(
modelType
modelId
)
)
;
}
;
_proto
.
findModelForSnapshot
=
function
findModelForSnapshot
(
sn
)
{
if
(
!
isModelSnapshot
(
sn
)
)
{
return
undefined
;
}
return
this
.
findModelByTypeAndId
(
sn
[
modelTypeKey
]
sn
[
modelIdKey
]
)
;
}
;
return
ModelPool
;
}
(
)
;
function
applyPatches
(
node
patches
reverse
)
{
if
(
reverse
=
=
=
void
0
)
{
reverse
=
false
;
}
assertTweakedObject
(
node
"
node
"
)
;
if
(
patches
.
length
<
=
0
)
{
return
;
}
wrappedInternalApplyPatches
(
)
.
call
(
node
patches
reverse
)
;
}
function
internalApplyPatches
(
patches
reverse
)
{
if
(
reverse
=
=
=
void
0
)
{
reverse
=
false
;
}
var
obj
=
this
;
var
modelPool
=
new
ModelPool
(
obj
)
;
if
(
reverse
)
{
var
i
=
patches
.
length
;
while
(
i
-
-
)
{
var
p
=
patches
[
i
]
;
if
(
!
isArray
(
p
)
)
{
applySinglePatch
(
obj
p
modelPool
)
;
}
else
{
var
j
=
p
.
length
;
while
(
j
-
-
)
{
applySinglePatch
(
obj
p
[
j
]
modelPool
)
;
}
}
}
}
else
{
var
len
=
patches
.
length
;
for
(
var
_i
=
0
;
_i
<
len
;
_i
+
+
)
{
var
_p
=
patches
[
_i
]
;
if
(
!
isArray
(
_p
)
)
{
applySinglePatch
(
obj
_p
modelPool
)
;
}
else
{
var
len2
=
_p
.
length
;
for
(
var
_j
=
0
;
_j
<
len2
;
_j
+
+
)
{
applySinglePatch
(
obj
_p
[
_j
]
modelPool
)
;
}
}
}
}
}
var
wrappedInternalApplyPatches
=
lazy
(
function
(
)
{
return
wrapInAction
(
{
name
:
BuiltInAction
.
ApplyPatches
fn
:
internalApplyPatches
actionType
:
ActionContextActionType
.
Sync
}
)
;
}
)
;
function
applySinglePatch
(
obj
patch
modelPool
)
{
var
_pathArrayToObjectAnd
=
pathArrayToObjectAndProp
(
obj
patch
.
path
)
target
=
_pathArrayToObjectAnd
.
target
prop
=
_pathArrayToObjectAnd
.
prop
;
if
(
isArray
(
target
)
)
{
switch
(
patch
.
op
)
{
case
"
add
"
:
{
var
index
=
+
prop
;
var
newValue
=
reconcileSnapshot
(
undefined
patch
.
value
modelPool
)
;
target
.
splice
(
index
0
newValue
)
;
break
;
}
case
"
remove
"
:
{
var
_index
=
+
prop
;
target
.
splice
(
_index
1
)
;
break
;
}
case
"
replace
"
:
{
if
(
prop
=
=
=
"
length
"
)
{
target
.
length
=
patch
.
value
;
}
else
{
var
_index2
=
+
prop
;
var
_newValue
=
reconcileSnapshot
(
target
[
_index2
]
patch
.
value
modelPool
)
;
(
0
mobx_esm
.
set
)
(
target
_index2
_newValue
)
;
}
break
;
}
default
:
throw
failure
(
"
unsupported
patch
operation
:
"
+
patch
.
op
)
;
}
}
else
{
switch
(
patch
.
op
)
{
case
"
add
"
:
{
var
_newValue2
=
reconcileSnapshot
(
undefined
patch
.
value
modelPool
)
;
(
0
mobx_esm
.
set
)
(
target
prop
_newValue2
)
;
break
;
}
case
"
remove
"
:
{
(
0
mobx_esm
.
remove
)
(
target
prop
)
;
break
;
}
case
"
replace
"
:
{
var
_newValue3
=
reconcileSnapshot
(
target
[
prop
]
patch
.
value
modelPool
)
;
(
0
mobx_esm
.
set
)
(
target
prop
_newValue3
)
;
break
;
}
default
:
throw
failure
(
"
unsupported
patch
operation
:
"
+
patch
.
op
)
;
}
}
}
function
pathArrayToObjectAndProp
(
obj
path
)
{
if
(
inDevMode
(
)
)
{
if
(
!
isArray
(
path
)
)
{
throw
failure
(
"
invalid
path
:
"
+
path
)
;
}
}
var
target
=
modelToDataNode
(
obj
)
;
if
(
path
.
length
=
=
=
0
)
{
return
{
target
:
target
}
;
}
for
(
var
i
=
0
;
i
<
=
path
.
length
-
2
;
i
+
+
)
{
target
=
modelToDataNode
(
target
[
path
[
i
]
]
)
;
}
return
{
target
:
target
prop
:
path
[
path
.
length
-
1
]
}
;
}
function
runTypeCheckingAfterChange
(
obj
patchRecorder
)
{
invalidateCachedTypeCheckerResult
(
obj
)
;
if
(
isModelAutoTypeCheckingEnabled
(
)
)
{
var
parentModelWithTypeChecker
=
findNearestParentModelWithTypeChecker
(
obj
)
;
if
(
parentModelWithTypeChecker
)
{
var
err
=
parentModelWithTypeChecker
.
typeCheck
(
)
;
if
(
err
)
{
runWithoutSnapshotOrPatches
(
function
(
)
{
internalApplyPatches
.
call
(
obj
patchRecorder
.
invPatches
true
)
;
}
)
;
err
[
"
throw
"
]
(
parentModelWithTypeChecker
)
;
}
}
}
}
function
findNearestParentModelWithTypeChecker
(
child
)
{
var
actualChild
=
dataToModelNode
(
child
)
;
if
(
child
!
=
=
actualChild
)
{
child
=
actualChild
;
if
(
isModel
(
child
)
&
&
!
!
getModelDataType
(
child
)
)
{
return
child
;
}
}
return
findParent
(
child
function
(
parent
)
{
return
isModel
(
parent
)
&
&
!
!
getModelDataType
(
parent
)
;
}
)
;
}
function
tweakArray
(
value
parentPath
doNotTweakChildren
)
{
var
originalArr
=
value
;
var
arrLn
=
originalArr
.
length
;
var
tweakedArr
=
(
0
mobx_esm
.
isObservableArray
)
(
originalArr
)
?
originalArr
:
mobx_esm
.
observable
.
array
(
[
]
observableOptions
1
)
;
if
(
tweakedArr
!
=
=
originalArr
)
{
tweakedArr
.
length
=
originalArr
.
length
;
}
var
interceptDisposer
;
var
observeDisposer
;
var
untweak
=
function
untweak
(
)
{
interceptDisposer
(
)
;
observeDisposer
(
)
;
}
;
tweakedObjects
.
set
(
tweakedArr
untweak
)
;
setParent
(
tweakedArr
parentPath
false
false
)
;
var
standardSn
=
[
]
;
standardSn
.
length
=
arrLn
;
for
(
var
i
=
0
;
i
<
arrLn
;
i
+
+
)
{
var
v
=
originalArr
[
i
]
;
if
(
isPrimitive
(
v
)
)
{
if
(
!
doNotTweakChildren
)
{
(
0
mobx_esm
.
set
)
(
tweakedArr
i
v
)
;
}
standardSn
[
i
]
=
v
;
}
else
{
var
path
=
{
parent
:
tweakedArr
path
:
i
}
;
var
tweakedValue
=
void
0
;
if
(
doNotTweakChildren
)
{
tweakedValue
=
v
;
setParent
(
tweakedValue
path
false
false
)
;
}
else
{
tweakedValue
=
tweak
(
v
path
)
;
(
0
mobx_esm
.
set
)
(
tweakedArr
i
tweakedValue
)
;
}
var
valueSn
=
getInternalSnapshot
(
tweakedValue
)
;
standardSn
[
i
]
=
valueSn
.
standard
;
}
}
setInternalSnapshot
(
tweakedArr
standardSn
)
;
interceptDisposer
=
(
0
mobx_esm
.
intercept
)
(
tweakedArr
interceptArrayMutation
.
bind
(
undefined
tweakedArr
)
)
;
observeDisposer
=
(
0
mobx_esm
.
observe
)
(
tweakedArr
arrayDidChange
)
;
return
tweakedArr
;
}
function
arrayDidChange
(
change
)
{
var
arr
=
change
.
object
;
var
_getInternalSnapshot
=
getInternalSnapshot
(
arr
)
oldSnapshot
=
_getInternalSnapshot
.
standard
;
var
patchRecorder
=
new
InternalPatchRecorder
(
)
;
var
newSnapshot
=
oldSnapshot
.
slice
(
)
;
switch
(
change
.
type
)
{
case
"
splice
"
:
{
var
index
=
change
.
index
;
var
addedCount
=
change
.
addedCount
;
var
removedCount
=
change
.
removedCount
;
var
addedItems
=
[
]
;
addedItems
.
length
=
addedCount
;
for
(
var
i
=
0
;
i
<
addedCount
;
i
+
+
)
{
var
v
=
change
.
added
[
i
]
;
if
(
isPrimitive
(
v
)
)
{
addedItems
[
i
]
=
v
;
}
else
{
addedItems
[
i
]
=
getInternalSnapshot
(
v
)
.
standard
;
}
}
var
oldLen
=
oldSnapshot
.
length
;
newSnapshot
.
splice
.
apply
(
newSnapshot
[
index
removedCount
]
.
concat
(
addedItems
)
)
;
var
patches
=
[
]
;
var
invPatches
=
[
]
;
if
(
addedCount
=
=
=
removedCount
)
{
for
(
var
_i
=
0
;
_i
<
addedCount
;
_i
+
+
)
{
var
realIndex
=
index
+
_i
;
var
newVal
=
newSnapshot
[
realIndex
]
;
var
oldVal
=
oldSnapshot
[
realIndex
]
;
if
(
newVal
!
=
=
oldVal
)
{
var
path
=
[
realIndex
]
;
patches
.
push
(
{
op
:
"
replace
"
path
:
path
value
:
newVal
}
)
;
invPatches
.
push
(
{
op
:
"
replace
"
path
:
path
value
:
oldVal
}
)
;
}
}
}
else
{
var
interimLen
=
oldLen
-
removedCount
;
if
(
removedCount
>
0
)
{
var
removeUsingSetLength
=
index
>
=
interimLen
;
if
(
removeUsingSetLength
)
{
patches
.
push
(
{
op
:
"
replace
"
path
:
[
"
length
"
]
value
:
interimLen
}
)
;
}
for
(
var
_i2
=
removedCount
-
1
;
_i2
>
=
0
;
_i2
-
-
)
{
var
_realIndex
=
index
+
_i2
;
var
_path
=
[
_realIndex
]
;
if
(
!
removeUsingSetLength
)
{
patches
.
push
(
{
op
:
"
remove
"
path
:
_path
}
)
;
}
invPatches
.
push
(
{
op
:
"
add
"
path
:
_path
value
:
oldSnapshot
[
_realIndex
]
}
)
;
}
}
if
(
addedCount
>
0
)
{
var
restoreUsingSetLength
=
index
>
=
interimLen
;
if
(
restoreUsingSetLength
)
{
invPatches
.
push
(
{
op
:
"
replace
"
path
:
[
"
length
"
]
value
:
interimLen
}
)
;
}
for
(
var
_i3
=
0
;
_i3
<
addedCount
;
_i3
+
+
)
{
var
_realIndex2
=
index
+
_i3
;
var
_path2
=
[
_realIndex2
]
;
patches
.
push
(
{
op
:
"
add
"
path
:
_path2
value
:
newSnapshot
[
_realIndex2
]
}
)
;
if
(
!
restoreUsingSetLength
)
{
invPatches
.
push
(
{
op
:
"
remove
"
path
:
_path2
}
)
;
}
}
}
}
patchRecorder
.
record
(
patches
invPatches
)
;
}
break
;
case
"
update
"
:
{
var
k
=
change
.
index
;
var
val
=
change
.
newValue
;
var
_oldVal
=
newSnapshot
[
k
]
;
if
(
isPrimitive
(
val
)
)
{
newSnapshot
[
k
]
=
val
;
}
else
{
var
valueSn
=
getInternalSnapshot
(
val
)
;
newSnapshot
[
k
]
=
valueSn
.
standard
;
}
var
_path3
=
[
k
]
;
patchRecorder
.
record
(
[
{
op
:
"
replace
"
path
:
_path3
value
:
newSnapshot
[
k
]
}
]
[
{
op
:
"
replace
"
path
:
_path3
value
:
_oldVal
}
]
)
;
}
break
;
}
runTypeCheckingAfterChange
(
arr
patchRecorder
)
;
if
(
!
runningWithoutSnapshotOrPatches
)
{
setInternalSnapshot
(
arr
newSnapshot
)
;
patchRecorder
.
emit
(
arr
)
;
}
}
var
undefinedInsideArrayErrorMsg
=
"
undefined
is
not
supported
inside
arrays
since
it
is
not
serializable
in
JSON
consider
using
null
instead
"
;
function
interceptArrayMutation
(
array
change
)
{
assertCanWrite
(
)
;
switch
(
change
.
type
)
{
case
"
splice
"
:
{
if
(
inDevMode
(
)
&
&
!
getGlobalConfig
(
)
.
allowUndefinedArrayElements
)
{
var
len
=
change
.
added
.
length
;
for
(
var
i
=
0
;
i
<
len
;
i
+
+
)
{
var
v
=
change
.
added
[
i
]
;
if
(
v
=
=
=
undefined
)
{
throw
failure
(
undefinedInsideArrayErrorMsg
)
;
}
}
}
for
(
var
_i4
=
0
;
_i4
<
change
.
removedCount
;
_i4
+
+
)
{
var
removedValue
=
change
.
object
[
change
.
index
+
_i4
]
;
tweak
(
removedValue
undefined
)
;
tryUntweak
(
removedValue
)
;
}
for
(
var
_i5
=
0
;
_i5
<
change
.
added
.
length
;
_i5
+
+
)
{
change
.
added
[
_i5
]
=
tweak
(
change
.
added
[
_i5
]
{
parent
:
change
.
object
path
:
change
.
index
+
_i5
}
)
;
}
var
oldNextIndex
=
change
.
index
+
change
.
removedCount
;
var
newNextIndex
=
change
.
index
+
change
.
added
.
length
;
if
(
oldNextIndex
!
=
=
newNextIndex
)
{
for
(
var
_i6
=
oldNextIndex
j
=
newNextIndex
;
_i6
<
change
.
object
.
length
;
_i6
+
+
j
+
+
)
{
setParent
(
change
.
object
[
_i6
]
{
parent
:
change
.
object
path
:
j
}
true
false
)
;
}
}
}
break
;
case
"
update
"
:
if
(
inDevMode
(
)
&
&
!
getGlobalConfig
(
)
.
allowUndefinedArrayElements
&
&
change
.
newValue
=
=
=
undefined
)
{
throw
failure
(
undefinedInsideArrayErrorMsg
)
;
}
var
oldVal
=
array
[
change
.
index
]
;
tweak
(
oldVal
undefined
)
;
tryUntweak
(
oldVal
)
;
change
.
newValue
=
tweak
(
change
.
newValue
{
parent
:
array
path
:
change
.
index
}
)
;
break
;
}
return
change
;
}
var
observableOptions
1
=
{
deep
:
false
}
;
function
tweakFrozen
(
frozenObj
parentPath
)
{
var
_setInternalSnapshot
;
tweakedObjects
.
set
(
frozenObj
undefined
)
;
setParent
(
frozenObj
parentPath
false
false
)
;
setInternalSnapshot
(
frozenObj
(
_setInternalSnapshot
=
{
}
_setInternalSnapshot
[
frozenKey
]
=
true
_setInternalSnapshot
.
data
=
frozenObj
.
data
_setInternalSnapshot
)
)
;
return
frozenObj
;
}
function
toTreeNode
(
value
)
{
if
(
!
isObject
(
value
)
)
{
throw
failure
(
"
only
objects
can
be
turned
into
tree
nodes
"
)
;
}
if
(
!
isTweakedObject
(
value
true
)
)
{
return
tweak
(
value
undefined
)
;
}
return
value
;
}
function
internalTweak
(
value
parentPath
)
{
if
(
isPrimitive
(
value
)
)
{
return
value
;
}
if
(
isTweakedObject
(
value
true
)
)
{
setParent
(
value
parentPath
false
false
)
;
return
value
;
}
if
(
isModel
(
value
)
)
{
return
tweakModel
(
value
parentPath
)
;
}
if
(
isArray
(
value
)
)
{
return
tweakArray
(
value
parentPath
false
)
;
}
if
(
(
0
mobx_esm
.
isObservableObject
)
(
value
)
|
|
isPlainObject
(
value
)
)
{
return
tweakPlainObject
(
value
parentPath
undefined
false
false
)
;
}
if
(
value
instanceof
Frozen
)
{
return
tweakFrozen
(
value
parentPath
)
;
}
if
(
isMap
(
value
)
)
{
throw
failure
(
"
maps
are
not
directly
supported
.
consider
applying
'
transformObjectAsMap
'
over
a
'
{
[
k
:
string
]
:
V
}
'
property
or
'
transformArrayAsMap
'
over
a
'
[
string
V
]
[
]
'
property
instead
.
"
)
;
}
if
(
isSet
(
value
)
)
{
throw
failure
(
"
sets
are
not
directly
supported
.
consider
applying
'
transformArrayAsSet
'
over
a
'
V
[
]
'
property
instead
.
"
)
;
}
throw
failure
(
"
tweak
can
only
work
over
models
observable
objects
/
arrays
or
primitives
but
got
"
+
value
+
"
instead
"
)
;
}
var
tweak
=
(
0
mobx_esm
.
action
)
(
"
tweak
"
internalTweak
)
;
function
tryUntweak
(
value
)
{
if
(
isPrimitive
(
value
)
)
{
return
true
;
}
if
(
inDevMode
(
)
)
{
if
(
fastGetParent
(
value
)
)
{
throw
failure
(
"
assertion
error
:
object
cannot
be
untweaked
while
it
has
a
parent
"
)
;
}
}
var
untweaker
=
tweakedObjects
.
get
(
value
)
;
if
(
!
untweaker
)
{
return
false
;
}
var
children
=
[
]
;
var
childrenIter
=
getObjectChildren
(
value
)
.
values
(
)
;
var
childrenCur
=
childrenIter
.
next
(
)
;
while
(
!
childrenCur
.
done
)
{
children
.
push
(
childrenCur
.
value
)
;
childrenCur
=
childrenIter
.
next
(
)
;
}
for
(
var
i
=
0
;
i
<
children
.
length
;
i
+
+
)
{
var
v
=
children
[
i
]
;
setParent
(
v
undefined
false
false
)
;
}
untweaker
(
)
;
tweakedObjects
[
"
delete
"
]
(
value
)
;
unsetInternalSnapshot
(
value
)
;
return
true
;
}
function
tweakPlainObject
(
value
parentPath
snapshotModelType
doNotTweakChildren
isDataObject
)
{
var
originalObj
=
value
;
var
tweakedObj
=
(
0
mobx_esm
.
isObservableObject
)
(
originalObj
)
?
originalObj
:
mobx_esm
.
observable
.
object
(
{
}
undefined
observableOptions
2
)
;
var
interceptDisposer
;
var
observeDisposer
;
var
untweak
=
function
untweak
(
)
{
interceptDisposer
(
)
;
observeDisposer
(
)
;
}
;
tweakedObjects
.
set
(
tweakedObj
untweak
)
;
setParent
(
tweakedObj
parentPath
false
isDataObject
)
;
var
standardSn
=
{
}
;
var
originalObjKeys
=
Object
.
keys
(
originalObj
)
;
var
originalObjKeysLen
=
originalObjKeys
.
length
;
for
(
var
i
=
0
;
i
<
originalObjKeysLen
;
i
+
+
)
{
var
k
=
originalObjKeys
[
i
]
;
var
v
=
originalObj
[
k
]
;
if
(
isPrimitive
(
v
)
)
{
if
(
!
doNotTweakChildren
)
{
(
0
mobx_esm
.
set
)
(
tweakedObj
k
v
)
;
}
standardSn
[
k
]
=
v
;
}
else
{
var
path
=
{
parent
:
tweakedObj
path
:
k
}
;
var
tweakedValue
=
void
0
;
if
(
doNotTweakChildren
)
{
tweakedValue
=
v
;
setParent
(
tweakedValue
path
false
false
)
;
}
else
{
tweakedValue
=
tweak
(
v
path
)
;
(
0
mobx_esm
.
set
)
(
tweakedObj
k
tweakedValue
)
;
}
var
valueSn
=
getInternalSnapshot
(
tweakedValue
)
;
standardSn
[
k
]
=
valueSn
.
standard
;
}
}
if
(
snapshotModelType
)
{
standardSn
[
modelTypeKey
]
=
snapshotModelType
;
}
setInternalSnapshot
(
isDataObject
?
dataToModelNode
(
tweakedObj
)
:
tweakedObj
standardSn
)
;
interceptDisposer
=
(
0
mobx_esm
.
intercept
)
(
tweakedObj
interceptObjectMutation
)
;
observeDisposer
=
(
0
mobx_esm
.
observe
)
(
tweakedObj
objectDidChange
)
;
return
tweakedObj
;
}
var
observableOptions
2
=
{
deep
:
false
}
;
function
objectDidChange
(
change
)
{
var
obj
=
change
.
object
;
var
actualNode
=
dataToModelNode
(
obj
)
;
var
_getInternalSnapshot
=
getInternalSnapshot
(
actualNode
)
standardSn
=
_getInternalSnapshot
.
standard
;
var
patchRecorder
=
new
InternalPatchRecorder
(
)
;
standardSn
=
Object
.
assign
(
{
}
standardSn
)
;
switch
(
change
.
type
)
{
case
"
add
"
:
case
"
update
"
:
{
var
k
=
change
.
name
;
var
val
=
change
.
newValue
;
var
oldVal
=
standardSn
[
k
]
;
if
(
isPrimitive
(
val
)
)
{
standardSn
[
k
]
=
val
;
}
else
{
var
valueSn
=
getInternalSnapshot
(
val
)
;
standardSn
[
k
]
=
valueSn
.
standard
;
}
var
path
=
[
k
]
;
if
(
change
.
type
=
=
=
"
add
"
)
{
patchRecorder
.
record
(
[
{
op
:
"
add
"
path
:
path
value
:
standardSn
[
k
]
}
]
[
{
op
:
"
remove
"
path
:
path
}
]
)
;
}
else
{
patchRecorder
.
record
(
[
{
op
:
"
replace
"
path
:
path
value
:
standardSn
[
k
]
}
]
[
{
op
:
"
replace
"
path
:
path
value
:
oldVal
}
]
)
;
}
}
break
;
case
"
remove
"
:
{
var
_k
=
change
.
name
;
var
_oldVal
=
standardSn
[
_k
]
;
delete
standardSn
[
_k
]
;
var
_path
=
[
_k
]
;
patchRecorder
.
record
(
[
{
op
:
"
remove
"
path
:
_path
}
]
[
{
op
:
"
add
"
path
:
_path
value
:
_oldVal
}
]
)
;
}
break
;
}
runTypeCheckingAfterChange
(
obj
patchRecorder
)
;
if
(
!
runningWithoutSnapshotOrPatches
)
{
setInternalSnapshot
(
actualNode
standardSn
)
;
patchRecorder
.
emit
(
actualNode
)
;
}
}
function
interceptObjectMutation
(
change
)
{
assertCanWrite
(
)
;
if
(
typeof
change
.
name
=
=
=
"
symbol
"
)
{
throw
failure
(
"
symbol
properties
are
not
supported
"
)
;
}
switch
(
change
.
type
)
{
case
"
add
"
:
change
.
newValue
=
tweak
(
change
.
newValue
{
parent
:
change
.
object
path
:
"
"
+
change
.
name
}
)
;
break
;
case
"
remove
"
:
{
var
oldVal
=
change
.
object
[
change
.
name
]
;
tweak
(
oldVal
undefined
)
;
tryUntweak
(
oldVal
)
;
break
;
}
case
"
update
"
:
{
var
_oldVal2
=
change
.
object
[
change
.
name
]
;
tweak
(
_oldVal2
undefined
)
;
tryUntweak
(
_oldVal2
)
;
change
.
newValue
=
tweak
(
change
.
newValue
{
parent
:
change
.
object
path
:
"
"
+
change
.
name
}
)
;
break
;
}
}
return
change
;
}
var
modelInitializersSymbol
=
Symbol
(
"
modelInitializers
"
)
;
function
addModelClassInitializer
(
modelClass
init
)
{
var
initializers
=
modelClass
[
modelInitializersSymbol
]
;
if
(
!
initializers
)
{
initializers
=
[
]
;
modelClass
[
modelInitializersSymbol
]
=
initializers
;
}
initializers
.
push
(
init
)
;
}
function
getModelClassInitializers
(
modelClass
)
{
return
modelClass
[
modelInitializersSymbol
]
;
}
var
internalNewModel
=
(
0
mobx_esm
.
action
)
(
"
newModel
"
function
(
origModelObj
initialData
options
)
{
var
_modelClass
=
options
.
modelClass
snapshotInitialData
=
options
.
snapshotInitialData
generateNewIds
=
options
.
generateNewIds
;
var
modelClass
=
_modelClass
;
if
(
inDevMode
(
)
)
{
assertIsModelClass
(
modelClass
"
modelClass
"
)
;
}
var
modelObj
=
origModelObj
;
var
modelInfo
=
modelInfoByClass
.
get
(
modelClass
)
;
if
(
!
modelInfo
)
{
throw
failure
(
"
no
model
info
for
class
"
+
modelClass
.
name
+
"
could
be
found
-
did
you
forget
to
add
the
model
decorator
?
"
)
;
}
var
id
;
if
(
snapshotInitialData
)
{
var
sn
=
snapshotInitialData
.
unprocessedSnapshot
;
if
(
generateNewIds
)
{
id
=
getGlobalConfig
(
)
.
modelIdGenerator
(
)
;
}
else
{
id
=
sn
[
modelIdKey
]
;
}
if
(
modelObj
.
fromSnapshot
)
{
sn
=
modelObj
.
fromSnapshot
(
sn
)
;
}
initialData
=
snapshotInitialData
.
snapshotToInitialData
(
sn
)
;
}
else
{
if
(
initialData
[
modelIdKey
]
)
{
id
=
initialData
[
modelIdKey
]
;
}
else
{
id
=
getGlobalConfig
(
)
.
modelIdGenerator
(
)
;
}
}
modelObj
[
modelTypeKey
]
=
modelInfo
.
name
;
var
modelProps
=
getInternalModelClassPropsInfo
(
modelClass
)
;
var
modelPropsKeys
=
Object
.
keys
(
modelProps
)
;
for
(
var
i
=
0
;
i
<
modelPropsKeys
.
length
;
i
+
+
)
{
var
k
=
modelPropsKeys
[
i
]
;
var
v
=
initialData
[
k
]
;
if
(
v
=
=
=
undefined
|
|
v
=
=
=
null
)
{
var
newValue
=
v
;
var
propData
=
modelProps
[
k
]
;
if
(
propData
.
defaultFn
!
=
=
noDefaultValue
)
{
newValue
=
propData
.
defaultFn
(
)
;
}
else
if
(
propData
.
defaultValue
!
=
=
noDefaultValue
)
{
newValue
=
propData
.
defaultValue
;
}
(
0
mobx_esm
.
set
)
(
initialData
k
newValue
)
;
}
}
(
0
mobx_esm
.
set
)
(
initialData
modelIdKey
id
)
;
tweakModel
(
modelObj
undefined
)
;
var
obsData
=
tweakPlainObject
(
initialData
{
parent
:
modelObj
path
:
"
"
}
modelObj
[
modelTypeKey
]
false
true
)
;
Object
.
defineProperty
(
obsData
modelIdKey
_extends
(
{
}
Object
.
getOwnPropertyDescriptor
(
obsData
modelIdKey
)
{
enumerable
:
false
}
)
)
;
modelObj
.
=
obsData
;
if
(
inDevMode
(
)
)
{
makePropReadonly
(
modelObj
"
"
true
)
;
}
if
(
isModelAutoTypeCheckingEnabled
(
)
&
&
getModelDataType
(
modelClass
)
)
{
var
err
=
modelObj
.
typeCheck
(
)
;
if
(
err
)
{
err
[
"
throw
"
]
(
modelObj
)
;
}
}
var
initializers
=
getModelClassInitializers
(
modelClass
)
;
if
(
initializers
)
{
var
len
=
initializers
.
length
;
for
(
var
_i
=
0
;
_i
<
len
;
_i
+
+
)
{
var
init
=
initializers
[
_i
]
;
init
(
modelObj
)
;
}
}
return
modelObj
;
}
)
;
var
propsDataTypeSymbol
=
Symbol
(
)
;
var
propsCreationDataTypeSymbol
=
Symbol
(
)
;
var
instanceDataTypeSymbol
=
Symbol
(
)
;
var
instanceCreationDataTypeSymbol
=
Symbol
(
)
;
var
modelInitializedSymbol
=
Symbol
(
"
modelInitialized
"
)
;
var
BaseModel
=
function
(
)
{
var
_proto
=
BaseModel
.
prototype
;
_proto
.
getRefId
=
function
getRefId
(
)
{
return
this
[
modelIdKey
]
;
}
;
_proto
.
typeCheck
=
function
typeCheck
1
(
)
{
var
type
=
typesModel
(
this
.
constructor
)
;
return
typeCheck
(
type
this
)
;
}
;
function
BaseModel
(
data
)
{
this
[
propsDataTypeSymbol
]
=
void
0
;
this
[
propsCreationDataTypeSymbol
]
=
void
0
;
this
[
instanceDataTypeSymbol
]
=
void
0
;
this
[
instanceCreationDataTypeSymbol
]
=
void
0
;
this
[
modelTypeKey
]
=
void
0
;
this
[
modelIdKey
]
=
void
0
;
this
.
=
void
0
;
var
initialData
=
data
;
var
_arguments
=
arguments
[
1
]
snapshotInitialData
=
_arguments
.
snapshotInitialData
modelClass
=
_arguments
.
modelClass
propsWithTransforms
=
_arguments
.
propsWithTransforms
generateNewIds
=
_arguments
.
generateNewIds
;
Object
.
setPrototypeOf
(
this
modelClass
.
prototype
)
;
var
self
=
this
;
delete
self
[
modelIdKey
]
;
delete
self
[
propsDataTypeSymbol
]
;
delete
self
[
propsCreationDataTypeSymbol
]
;
delete
self
[
instanceDataTypeSymbol
]
;
delete
self
[
instanceCreationDataTypeSymbol
]
;
if
(
!
snapshotInitialData
)
{
assertIsObject
(
initialData
"
initialData
"
)
;
var
propsWithTransformsLen
=
propsWithTransforms
.
length
;
if
(
propsWithTransformsLen
>
0
)
{
initialData
=
Object
.
assign
(
initialData
)
;
for
(
var
i
=
0
;
i
<
propsWithTransformsLen
;
i
+
+
)
{
var
propWithTransform
=
propsWithTransforms
[
i
]
;
var
propName
=
propWithTransform
[
0
]
;
var
propTransform
=
propWithTransform
[
1
]
;
var
memoTransform
=
memoTransformCache
.
getOrCreateMemoTransform
(
this
propName
propTransform
)
;
initialData
[
propName
]
=
memoTransform
.
dataToProp
(
initialData
[
propName
]
)
;
}
}
internalNewModel
(
this
mobx_esm
.
observable
.
object
(
initialData
undefined
{
deep
:
false
}
)
{
modelClass
:
modelClass
generateNewIds
:
true
}
)
;
}
else
{
internalNewModel
(
this
undefined
{
modelClass
:
modelClass
snapshotInitialData
:
snapshotInitialData
generateNewIds
:
generateNewIds
}
)
;
}
}
_proto
.
toString
=
function
toString
(
options
)
{
var
finalOptions
=
_extends
(
{
withData
:
true
}
options
)
;
var
firstPart
=
this
.
constructor
.
name
+
"
#
"
+
this
[
modelTypeKey
]
;
return
finalOptions
.
withData
?
"
[
"
+
firstPart
+
"
"
+
JSON
.
stringify
(
getSnapshot
(
this
)
)
+
"
]
"
:
"
[
"
+
firstPart
+
"
]
"
;
}
;
return
BaseModel
;
}
(
)
;
var
baseModelPropNames
=
new
Set
(
[
modelTypeKey
modelIdKey
"
onInit
"
"
"
"
getRefId
"
"
onAttachedToRootStore
"
"
fromSnapshot
"
"
typeCheck
"
]
)
;
function
abstractModelClass
(
type
)
{
return
type
;
}
function
modelClass
(
type
)
{
return
type
;
}
function
modelSnapshotInWithMetadata
(
modelClass
snapshot
internalId
)
{
var
_extends2
;
if
(
internalId
=
=
=
void
0
)
{
internalId
=
getGlobalConfig
(
)
.
modelIdGenerator
(
)
;
}
assertIsModelClass
(
modelClass
"
modelClass
"
)
;
assertIsObject
(
snapshot
"
initialData
"
)
;
var
modelInfo
=
modelInfoByClass
.
get
(
modelClass
)
;
return
_extends
(
{
}
snapshot
(
_extends2
=
{
}
_extends2
[
modelTypeKey
]
=
modelInfo
.
name
_extends2
[
modelIdKey
]
=
internalId
_extends2
)
)
;
}
function
modelSnapshotOutWithMetadata
(
modelClass
snapshot
internalId
)
{
var
_extends3
;
if
(
internalId
=
=
=
void
0
)
{
internalId
=
getGlobalConfig
(
)
.
modelIdGenerator
(
)
;
}
assertIsModelClass
(
modelClass
"
modelClass
"
)
;
assertIsObject
(
snapshot
"
initialData
"
)
;
var
modelInfo
=
modelInfoByClass
.
get
(
modelClass
)
;
return
_extends
(
{
}
snapshot
(
_extends3
=
{
}
_extends3
[
modelTypeKey
]
=
modelInfo
.
name
_extends3
[
modelIdKey
]
=
internalId
_extends3
)
)
;
}
function
isModel
(
model
)
{
return
model
instanceof
BaseModel
;
}
function
assertIsModel
(
model
argName
customErrMsg
)
{
if
(
customErrMsg
=
=
=
void
0
)
{
customErrMsg
=
"
must
be
a
model
instance
"
;
}
if
(
!
isModel
(
model
)
)
{
throw
failure
(
argName
+
"
"
+
customErrMsg
)
;
}
}
function
isModelClass
(
modelClass
)
{
if
(
typeof
modelClass
!
=
=
"
function
"
)
{
return
false
;
}
if
(
modelClass
!
=
=
BaseModel
&
&
!
(
modelClass
.
prototype
instanceof
BaseModel
)
)
{
return
false
;
}
return
true
;
}
function
assertIsModelClass
(
modelClass
argName
)
{
if
(
typeof
modelClass
!
=
=
"
function
"
)
{
throw
failure
(
argName
+
"
must
be
a
class
"
)
;
}
if
(
modelClass
!
=
=
BaseModel
&
&
!
(
modelClass
.
prototype
instanceof
BaseModel
)
)
{
throw
failure
(
argName
+
"
must
extend
Model
"
)
;
}
}
function
isModelSnapshot
(
sn
)
{
return
isPlainObject
(
sn
)
&
&
!
!
sn
[
modelTypeKey
]
;
}
function
checkModelDecoratorArgs
(
fnName
target
propertyKey
)
{
if
(
typeof
propertyKey
!
=
=
"
string
"
)
{
throw
failure
(
fnName
+
"
cannot
be
used
over
symbol
properties
"
)
;
}
var
errMessage
=
fnName
+
"
must
be
used
over
model
classes
or
instances
"
;
if
(
!
target
)
{
throw
failure
(
errMessage
)
;
}
if
(
!
(
target
instanceof
BaseModel
)
&
&
target
!
=
=
BaseModel
&
&
!
(
target
.
prototype
instanceof
BaseModel
)
)
{
throw
failure
(
errMessage
)
;
}
}
function
isModelAction
(
fn
)
{
return
typeof
fn
=
=
=
"
function
"
&
&
!
!
fn
[
modelActionSymbol
]
;
}
function
checkModelActionArgs
(
target
propertyKey
value
)
{
if
(
typeof
value
!
=
=
"
function
"
)
{
throw
failure
(
"
modelAction
has
to
be
used
over
functions
"
)
;
}
checkModelDecoratorArgs
(
"
modelAction
"
target
propertyKey
)
;
}
function
modelAction
(
target
propertyKey
baseDescriptor
)
{
return
decorateWrapMethodOrField
(
"
modelAction
"
{
target
:
target
propertyKey
:
propertyKey
baseDescriptor
:
baseDescriptor
}
function
(
data
fn
)
{
if
(
isModelAction
(
fn
)
)
{
return
fn
;
}
else
{
checkModelActionArgs
(
data
.
target
data
.
propertyKey
fn
)
;
return
wrapInAction
(
{
name
:
data
.
propertyKey
fn
:
fn
actionType
:
ActionContextActionType
.
Sync
}
)
;
}
}
)
;
}
var
modelFlowSymbol
=
Symbol
(
"
modelFlow
"
)
;
function
flow
(
name
generator
)
{
var
flowFn
=
function
flowFn
(
)
{
for
(
var
_len
=
arguments
.
length
args
=
new
Array
(
_len
)
_key
=
0
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
]
=
arguments
[
_key
]
;
}
var
target
=
this
;
if
(
inDevMode
(
)
)
{
assertTweakedObject
(
target
"
flow
"
)
;
}
var
previousAsyncStepContext
;
var
ctxOverride
=
function
ctxOverride
(
stepType
)
{
return
function
(
ctx
)
{
ctx
.
previousAsyncStepContext
=
previousAsyncStepContext
;
ctx
.
spawnAsyncStepContext
=
previousAsyncStepContext
?
previousAsyncStepContext
.
spawnAsyncStepContext
:
ctx
;
ctx
.
asyncStepType
=
stepType
;
ctx
.
args
=
args
;
previousAsyncStepContext
=
ctx
;
}
;
}
;
var
generatorRun
=
false
;
var
gen
=
wrapInAction
(
{
name
:
name
fn
:
function
fn
(
)
{
generatorRun
=
true
;
return
generator
.
apply
(
target
args
)
;
}
actionType
:
ActionContextActionType
.
Async
overrideContext
:
ctxOverride
(
ActionContextAsyncStepType
.
Spawn
)
}
)
.
apply
(
target
)
;
if
(
!
generatorRun
)
{
return
gen
instanceof
Promise
?
gen
:
Promise
.
resolve
(
gen
)
;
}
var
genNext
=
gen
.
next
.
bind
(
gen
)
;
var
genThrow
=
gen
[
"
throw
"
]
.
bind
(
gen
)
;
var
promise
=
new
Promise
(
function
(
resolve
reject
)
{
function
onFulfilled
(
res
)
{
var
ret
;
try
{
ret
=
wrapInAction
(
{
name
:
name
fn
:
genNext
actionType
:
ActionContextActionType
.
Async
overrideContext
:
ctxOverride
(
ActionContextAsyncStepType
.
Resume
)
}
)
.
call
(
target
res
)
;
}
catch
(
e
)
{
wrapInAction
(
{
name
:
name
fn
:
function
fn
(
err
)
{
return
{
value
:
err
resolution
:
"
reject
"
accepter
:
resolve
rejecter
:
reject
}
;
}
actionType
:
ActionContextActionType
.
Async
overrideContext
:
ctxOverride
(
ActionContextAsyncStepType
.
Throw
)
isFlowFinisher
:
true
}
)
.
call
(
target
e
)
;
return
;
}
next
(
ret
)
;
}
function
onRejected
(
err
)
{
var
ret
;
try
{
ret
=
wrapInAction
(
{
name
:
name
fn
:
genThrow
actionType
:
ActionContextActionType
.
Async
overrideContext
:
ctxOverride
(
ActionContextAsyncStepType
.
ResumeError
)
}
)
.
call
(
target
err
)
;
}
catch
(
e
)
{
wrapInAction
(
{
name
:
name
fn
:
function
fn
(
err
)
{
return
{
value
:
err
resolution
:
"
reject
"
accepter
:
resolve
rejecter
:
reject
}
;
}
actionType
:
ActionContextActionType
.
Async
overrideContext
:
ctxOverride
(
ActionContextAsyncStepType
.
Throw
)
isFlowFinisher
:
true
}
)
.
call
(
target
e
)
;
return
;
}
next
(
ret
)
;
}
function
next
(
ret
)
{
if
(
ret
&
&
typeof
ret
.
then
=
=
=
"
function
"
)
{
ret
.
then
(
next
reject
)
;
}
else
if
(
ret
.
done
)
{
wrapInAction
(
{
name
:
name
fn
:
function
fn
(
val
)
{
return
{
value
:
val
resolution
:
"
accept
"
accepter
:
resolve
rejecter
:
reject
}
;
}
actionType
:
ActionContextActionType
.
Async
overrideContext
:
ctxOverride
(
ActionContextAsyncStepType
.
Return
)
isFlowFinisher
:
true
}
)
.
call
(
target
ret
.
value
)
;
}
else
{
Promise
.
resolve
(
ret
.
value
)
.
then
(
onFulfilled
onRejected
)
;
}
}
onFulfilled
(
undefined
)
;
}
)
;
return
promise
;
}
;
flowFn
[
modelFlowSymbol
]
=
true
;
return
flowFn
;
}
function
isModelFlow
(
fn
)
{
return
typeof
fn
=
=
=
"
function
"
&
&
fn
[
modelFlowSymbol
]
;
}
function
modelFlow
(
target
propertyKey
baseDescriptor
)
{
return
decorateWrapMethodOrField
(
"
modelFlow
"
{
target
:
target
propertyKey
:
propertyKey
baseDescriptor
:
baseDescriptor
}
function
(
data
fn
)
{
if
(
isModelFlow
(
fn
)
)
{
return
fn
;
}
else
{
checkModelFlowArgs
(
data
.
target
data
.
propertyKey
fn
)
;
return
flow
(
data
.
propertyKey
fn
)
;
}
}
)
;
}
function
checkModelFlowArgs
(
target
propertyKey
value
)
{
if
(
typeof
value
!
=
=
"
function
"
)
{
throw
failure
(
"
modelFlow
has
to
be
used
over
functions
"
)
;
}
checkModelDecoratorArgs
(
"
modelFlow
"
target
propertyKey
)
;
}
function
_async
(
fn
)
{
return
fn
;
}
function
_await
(
promise
)
{
return
promiseGenerator
.
call
(
promise
)
;
}
var
mobxkeystone_esm_generator
=
function
__generator
(
thisArg
body
)
{
var
_
=
{
label
:
0
sent
:
function
sent
(
)
{
if
(
t
[
0
]
&
1
)
throw
t
[
1
]
;
return
t
[
1
]
;
}
trys
:
[
]
ops
:
[
]
}
f
y
t
g
;
return
g
=
{
next
:
verb
(
0
)
"
throw
"
:
verb
(
1
)
"
return
"
:
verb
(
2
)
}
typeof
Symbol
=
=
=
"
function
"
&
&
(
g
[
Symbol
.
iterator
]
=
function
(
)
{
return
this
;
}
)
g
;
function
verb
(
n
)
{
return
function
(
v
)
{
return
step
(
[
n
v
]
)
;
}
;
}
function
step
(
op
)
{
if
(
f
)
throw
new
TypeError
(
"
Generator
is
already
executing
.
"
)
;
while
(
_
)
{
try
{
if
(
f
=
1
y
&
&
(
t
=
op
[
0
]
&
2
?
y
[
"
return
"
]
:
op
[
0
]
?
y
[
"
throw
"
]
|
|
(
(
t
=
y
[
"
return
"
]
)
&
&
t
.
call
(
y
)
0
)
:
y
.
next
)
&
&
!
(
t
=
t
.
call
(
y
op
[
1
]
)
)
.
done
)
return
t
;
if
(
y
=
0
t
)
op
=
[
op
[
0
]
&
2
t
.
value
]
;
switch
(
op
[
0
]
)
{
case
0
:
case
1
:
t
=
op
;
break
;
case
4
:
_
.
label
+
+
;
return
{
value
:
op
[
1
]
done
:
false
}
;
case
5
:
_
.
label
+
+
;
y
=
op
[
1
]
;
op
=
[
0
]
;
continue
;
case
7
:
op
=
_
.
ops
.
pop
(
)
;
_
.
trys
.
pop
(
)
;
continue
;
default
:
if
(
!
(
t
=
_
.
trys
t
=
t
.
length
>
0
&
&
t
[
t
.
length
-
1
]
)
&
&
(
op
[
0
]
=
=
=
6
|
|
op
[
0
]
=
=
=
2
)
)
{
_
=
0
;
continue
;
}
if
(
op
[
0
]
=
=
=
3
&
&
(
!
t
|
|
op
[
1
]
>
t
[
0
]
&
&
op
[
1
]
<
t
[
3
]
)
)
{
_
.
label
=
op
[
1
]
;
break
;
}
if
(
op
[
0
]
=
=
=
6
&
&
_
.
label
<
t
[
1
]
)
{
_
.
label
=
t
[
1
]
;
t
=
op
;
break
;
}
if
(
t
&
&
_
.
label
<
t
[
2
]
)
{
_
.
label
=
t
[
2
]
;
_
.
ops
.
push
(
op
)
;
break
;
}
if
(
t
[
2
]
)
_
.
ops
.
pop
(
)
;
_
.
trys
.
pop
(
)
;
continue
;
}
op
=
body
.
call
(
thisArg
_
)
;
}
catch
(
e
)
{
op
=
[
6
e
]
;
y
=
0
;
}
finally
{
f
=
t
=
0
;
}
}
if
(
op
[
0
]
&
5
)
throw
op
[
1
]
;
return
{
value
:
op
[
0
]
?
op
[
1
]
:
void
0
done
:
true
}
;
}
}
;
function
promiseGenerator
(
)
{
var
ret
;
return
mobxkeystone_esm_generator
(
this
function
(
_a
)
{
switch
(
_a
.
label
)
{
case
0
:
return
[
4
this
]
;
case
1
:
ret
=
_a
.
sent
(
)
;
return
[
2
ret
]
;
default
:
return
;
}
}
)
;
}
function
assertFnModelKeyNotInUse
(
fnModelObj
key
)
{
if
(
fnModelObj
[
key
]
!
=
=
undefined
)
{
throw
failure
(
"
key
'
"
+
key
+
"
'
cannot
be
redeclared
"
)
;
}
}
var
fnModelActionRegistry
=
new
Map
(
)
;
function
getFnModelAction
(
actionName
)
{
return
fnModelActionRegistry
.
get
(
actionName
)
;
}
function
extendFnModelActions
(
fnModelObj
namespace
actions
)
{
for
(
var
_i
=
0
_Object
entries
=
Object
.
entries
(
actions
)
;
_i
<
_Object
entries
.
length
;
_i
+
+
)
{
var
_Object
entries
_i
=
_Object
entries
[
_i
]
name
=
_Object
entries
_i
[
0
]
fn
=
_Object
entries
_i
[
1
]
;
addActionToFnModel
(
fnModelObj
namespace
name
fn
false
)
;
}
return
fnModelObj
;
}
function
addActionToFnModel
(
fnModelObj
namespace
name
fn
isFlow
)
{
assertFnModelKeyNotInUse
(
fnModelObj
name
)
;
var
fullActionName
=
namespace
+
"
:
:
"
+
name
;
assertIsFunction
(
fn
fullActionName
)
;
if
(
fnModelActionRegistry
.
has
(
fullActionName
)
)
{
logWarning
(
"
warn
"
"
an
standalone
action
with
name
\
"
"
+
fullActionName
+
"
\
"
already
exists
(
if
you
are
using
hot
-
reloading
you
may
safely
ignore
this
warning
)
"
"
duplicateActionName
-
"
+
name
)
;
}
if
(
isModelAction
(
fn
)
)
{
throw
failure
(
"
the
standalone
action
must
not
be
previously
marked
as
an
action
"
)
;
}
if
(
isModelFlow
(
fn
)
)
{
throw
failure
(
"
the
standalone
action
must
not
be
previously
marked
as
a
flow
action
"
)
;
}
var
wrappedAction
=
isFlow
?
flow
(
fullActionName
fn
)
:
wrapInAction
(
{
name
:
fullActionName
fn
:
fn
actionType
:
ActionContextActionType
.
Sync
}
)
;
fnModelObj
[
name
]
=
function
(
target
)
{
for
(
var
_len
=
arguments
.
length
args
=
new
Array
(
_len
>
1
?
_len
-
1
:
0
)
_key
=
1
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
-
1
]
=
arguments
[
_key
]
;
}
return
wrappedAction
.
apply
(
target
args
)
;
}
;
fnModelActionRegistry
.
set
(
fullActionName
fnModelObj
[
name
]
)
;
}
function
applySnapshot
(
node
snapshot
)
{
assertTweakedObject
(
node
"
node
"
)
;
assertIsObject
(
snapshot
"
snapshot
"
)
;
wrappedInternalApplySnapshot
(
)
.
call
(
node
snapshot
)
;
}
function
internalApplySnapshot
(
sn
)
{
var
obj
=
this
;
var
reconcile
=
function
reconcile
(
)
{
var
modelPool
=
new
ModelPool
(
obj
)
;
var
ret
=
reconcileSnapshot
(
obj
sn
modelPool
)
;
if
(
inDevMode
(
)
)
{
if
(
ret
!
=
=
obj
)
{
throw
failure
(
"
assertion
error
:
reconciled
object
has
to
be
the
same
"
)
;
}
}
}
;
if
(
isArray
(
sn
)
)
{
if
(
!
isArray
(
obj
)
)
{
throw
failure
(
"
if
the
snapshot
is
an
array
the
target
must
be
an
array
too
"
)
;
}
return
reconcile
(
)
;
}
if
(
isFrozenSnapshot
(
sn
)
)
{
throw
failure
(
"
applySnapshot
cannot
be
used
over
frozen
objects
"
)
;
}
if
(
isModelSnapshot
(
sn
)
)
{
var
type
=
sn
[
modelTypeKey
]
;
var
modelInfo
=
getModelInfoForName
(
type
)
;
if
(
!
modelInfo
)
{
throw
failure
(
"
model
with
name
\
"
"
+
type
+
"
\
"
not
found
in
the
registry
"
)
;
}
if
(
!
isModel
(
obj
)
)
{
throw
failure
(
"
the
target
for
a
model
snapshot
must
be
a
model
instance
"
)
;
}
if
(
obj
[
modelTypeKey
]
!
=
=
type
)
{
throw
failure
(
"
snapshot
model
type
'
"
+
type
+
"
'
does
not
match
target
model
type
'
"
+
obj
[
modelTypeKey
]
+
"
'
"
)
;
}
var
id
=
sn
[
modelIdKey
]
;
if
(
obj
[
modelIdKey
]
!
=
=
id
)
{
throw
failure
(
"
snapshot
model
id
'
"
+
id
+
"
'
does
not
match
target
model
id
'
"
+
obj
[
modelIdKey
]
+
"
'
"
)
;
}
return
reconcile
(
)
;
}
if
(
isPlainObject
(
sn
)
)
{
if
(
!
isPlainObject
(
obj
)
&
&
!
(
0
mobx_esm
.
isObservableObject
)
(
obj
)
)
{
throw
failure
(
"
if
the
snapshot
is
an
object
the
target
must
be
an
object
too
"
)
;
}
return
reconcile
(
)
;
}
throw
failure
(
"
unsupported
snapshot
-
"
+
sn
)
;
}
var
wrappedInternalApplySnapshot
=
lazy
(
function
(
)
{
return
wrapInAction
(
{
name
:
BuiltInAction
.
ApplySnapshot
fn
:
internalApplySnapshot
actionType
:
ActionContextActionType
.
Sync
}
)
;
}
)
;
function
applyDelete
(
node
fieldName
)
{
assertTweakedObject
(
node
"
node
"
)
;
wrappedInternalApplyDelete
(
)
.
call
(
node
fieldName
)
;
}
function
internalApplyDelete
(
fieldName
)
{
(
0
mobx_esm
.
remove
)
(
this
"
"
+
fieldName
)
;
}
var
wrappedInternalApplyDelete
=
lazy
(
function
(
)
{
return
wrapInAction
(
{
name
:
BuiltInAction
.
ApplyDelete
fn
:
internalApplyDelete
actionType
:
ActionContextActionType
.
Sync
}
)
;
}
)
;
function
applyMethodCall
(
node
methodName
)
{
assertTweakedObject
(
node
"
node
"
)
;
for
(
var
_len
=
arguments
.
length
args
=
new
Array
(
_len
>
2
?
_len
-
2
:
0
)
_key
=
2
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
-
2
]
=
arguments
[
_key
]
;
}
return
wrappedInternalApplyMethodCall
(
)
.
call
(
node
methodName
args
)
;
}
function
internalApplyMethodCall
(
methodName
args
)
{
return
this
[
methodName
]
.
apply
(
this
args
)
;
}
var
wrappedInternalApplyMethodCall
=
lazy
(
function
(
)
{
return
wrapInAction
(
{
name
:
BuiltInAction
.
ApplyMethodCall
fn
:
internalApplyMethodCall
actionType
:
ActionContextActionType
.
Sync
}
)
;
}
)
;
function
applySet
(
node
fieldName
value
)
{
assertTweakedObject
(
node
"
node
"
)
;
wrappedInternalApplySet
(
)
.
call
(
node
fieldName
value
)
;
}
function
internalApplySet
(
fieldName
value
)
{
if
(
!
isModel
(
this
)
&
&
(
0
mobx_esm
.
isObservable
)
(
this
)
)
{
(
0
mobx_esm
.
set
)
(
this
fieldName
value
)
;
}
else
{
this
[
fieldName
]
=
value
;
}
}
var
wrappedInternalApplySet
=
lazy
(
function
(
)
{
return
wrapInAction
(
{
name
:
BuiltInAction
.
ApplySet
fn
:
internalApplySet
actionType
:
ActionContextActionType
.
Sync
}
)
;
}
)
;
var
_builtInActionToFunct
;
var
builtInActionToFunction
=
(
_builtInActionToFunct
=
{
}
_builtInActionToFunct
[
BuiltInAction
.
ApplySnapshot
]
=
applySnapshot
_builtInActionToFunct
[
BuiltInAction
.
ApplyPatches
]
=
applyPatches
_builtInActionToFunct
[
BuiltInAction
.
Detach
]
=
detach
_builtInActionToFunct
[
BuiltInAction
.
ApplySet
]
=
applySet
_builtInActionToFunct
[
BuiltInAction
.
ApplyDelete
]
=
applyDelete
_builtInActionToFunct
[
BuiltInAction
.
ApplyMethodCall
]
=
applyMethodCall
_builtInActionToFunct
)
;
function
applyAction
(
subtreeRoot
call
)
{
if
(
call
.
serialized
)
{
throw
failure
(
"
cannot
apply
a
serialized
action
call
use
one
of
the
'
applySerializedAction
'
methods
instead
"
)
;
}
assertTweakedObject
(
subtreeRoot
"
subtreeRoot
"
)
;
var
_resolvePathCheckingI
=
resolvePathCheckingIds
(
subtreeRoot
call
.
targetPath
call
.
targetPathIds
)
current
=
_resolvePathCheckingI
.
value
resolved
=
_resolvePathCheckingI
.
resolved
;
if
(
!
resolved
)
{
throw
failure
(
"
object
at
path
"
+
JSON
.
stringify
(
call
.
targetPath
)
+
"
with
ids
"
+
JSON
.
stringify
(
call
.
targetPathIds
)
+
"
could
not
be
resolved
"
)
;
}
assertTweakedObject
(
current
"
resolved
"
+
current
true
)
;
if
(
isBuiltInAction
(
call
.
actionName
)
)
{
var
fnToCall
=
builtInActionToFunction
[
call
.
actionName
]
;
if
(
!
fnToCall
)
{
throw
failure
(
"
assertion
error
:
unknown
built
-
in
action
-
"
+
call
.
actionName
)
;
}
return
fnToCall
.
apply
(
current
[
current
]
.
concat
(
call
.
args
)
)
;
}
else
if
(
isHookAction
(
call
.
actionName
)
)
{
throw
failure
(
"
calls
to
hooks
(
"
+
call
.
actionName
+
"
)
cannot
be
applied
"
)
;
}
else
{
var
standaloneAction
=
getFnModelAction
(
call
.
actionName
)
;
if
(
standaloneAction
)
{
return
standaloneAction
.
apply
(
current
call
.
args
)
;
}
else
{
return
current
[
call
.
actionName
]
.
apply
(
current
call
.
args
)
;
}
}
}
var
cannotSerialize
=
Symbol
(
"
cannotSerialize
"
)
;
var
arraySerializer
=
{
id
:
"
mobx
-
keystone
/
array
"
serialize
:
function
serialize
(
value
_serialize
)
{
if
(
!
isArray
(
value
)
)
return
cannotSerialize
;
return
value
.
map
(
_serialize
)
;
}
deserialize
:
function
deserialize
(
arr
_deserialize
)
{
return
arr
.
map
(
_deserialize
)
;
}
}
;
var
dateSerializer
=
{
id
:
"
mobx
-
keystone
/
dateAsTimestamp
"
serialize
:
function
serialize
(
date
)
{
if
(
!
(
date
instanceof
Date
)
)
return
cannotSerialize
;
return
+
date
;
}
deserialize
:
function
deserialize
(
timestamp
)
{
return
new
Date
(
timestamp
)
;
}
}
;
var
mapSerializer
=
{
id
:
"
mobx
-
keystone
/
mapAsArray
"
serialize
:
function
serialize
(
map
_serialize
)
{
if
(
!
(
map
instanceof
Map
)
&
&
!
(
0
mobx_esm
.
isObservableMap
)
(
map
)
)
return
cannotSerialize
;
var
arr
=
[
]
;
var
iter
=
map
.
keys
(
)
;
var
cur
=
iter
.
next
(
)
;
while
(
!
cur
.
done
)
{
var
k
=
cur
.
value
;
var
v
=
map
.
get
(
k
)
;
arr
.
push
(
[
_serialize
(
k
)
_serialize
(
v
)
]
)
;
cur
=
iter
.
next
(
)
;
}
return
arr
;
}
deserialize
:
function
deserialize
(
arr
_deserialize
)
{
var
map
=
new
Map
(
)
;
var
len
=
arr
.
length
;
for
(
var
i
=
0
;
i
<
len
;
i
+
+
)
{
var
k
=
arr
[
i
]
[
0
]
;
var
v
=
arr
[
i
]
[
1
]
;
map
.
set
(
_deserialize
(
k
)
_deserialize
(
v
)
)
;
}
return
map
;
}
}
;
function
rootPathToTargetPathIds
(
rootPath
)
{
var
targetPathIds
=
[
]
;
for
(
var
i
=
0
;
i
<
rootPath
.
path
.
length
;
i
+
+
)
{
var
targetObj
=
rootPath
.
pathObjects
[
i
+
1
]
;
var
targetObjId
=
isModel
(
targetObj
)
?
targetObj
[
modelIdKey
]
:
null
;
targetPathIds
.
push
(
targetObjId
)
;
}
return
targetPathIds
;
}
function
pathToTargetPathIds
(
root
path
)
{
var
targetPathIds
=
[
]
;
var
current
=
root
;
for
(
var
i
=
0
;
i
<
path
.
length
;
i
+
+
)
{
current
=
current
[
path
[
i
]
]
;
var
targetObjId
=
isModel
(
current
)
?
current
[
modelIdKey
]
:
null
;
targetPathIds
.
push
(
targetObjId
)
;
}
return
targetPathIds
;
}
var
objectPathSerializer
=
{
id
:
"
mobx
-
keystone
/
objectPath
"
serialize
:
function
serialize
(
value
_
targetRoot
)
{
if
(
typeof
value
!
=
=
"
object
"
|
|
value
=
=
=
null
|
|
!
isTweakedObject
(
value
false
)
)
return
cannotSerialize
;
if
(
targetRoot
)
{
var
rootPath
=
fastGetRootPath
(
value
)
;
if
(
rootPath
.
root
=
=
=
targetRoot
)
{
return
{
targetPath
:
rootPath
.
path
targetPathIds
:
rootPathToTargetPathIds
(
rootPath
)
}
;
}
}
return
cannotSerialize
;
}
deserialize
:
function
deserialize
(
ref
_
targetRoot
)
{
if
(
targetRoot
)
{
var
result
=
resolvePathCheckingIds
(
targetRoot
ref
.
targetPath
ref
.
targetPathIds
)
;
if
(
result
.
resolved
)
{
return
result
.
value
;
}
}
throw
failure
(
"
object
at
path
"
+
JSON
.
stringify
(
ref
.
targetPath
)
+
"
with
ids
"
+
JSON
.
stringify
(
ref
.
targetPathIds
)
+
"
could
not
be
resolved
"
)
;
}
}
;
var
objectSnapshotSerializer
=
{
id
:
"
mobx
-
keystone
/
objectSnapshot
"
serialize
:
function
serialize
(
value
)
{
if
(
typeof
value
!
=
=
"
object
"
|
|
value
=
=
=
null
|
|
!
isTweakedObject
(
value
false
)
)
return
cannotSerialize
;
return
getSnapshot
(
value
)
;
}
deserialize
:
function
deserialize
(
snapshot
)
{
return
fromSnapshot
(
snapshot
)
;
}
}
;
var
plainObjectSerializer
=
{
id
:
"
mobx
-
keystone
/
plainObject
"
serialize
:
function
serialize
(
value
_serialize
)
{
if
(
!
isPlainObject
(
value
)
&
&
!
(
0
mobx_esm
.
isObservableObject
)
(
value
)
)
return
cannotSerialize
;
return
mapObjectFields
(
value
_serialize
)
;
}
deserialize
:
function
deserialize
(
obj
serialize
)
{
return
mapObjectFields
(
obj
serialize
)
;
}
}
;
function
mapObjectFields
(
originalObj
mapFn
)
{
var
obj
=
{
}
;
var
keys
=
Object
.
keys
(
originalObj
)
;
var
len
=
keys
.
length
;
for
(
var
i
=
0
;
i
<
len
;
i
+
+
)
{
var
k
=
keys
[
i
]
;
var
v
=
originalObj
[
k
]
;
obj
[
k
]
=
mapFn
(
v
)
;
}
return
obj
;
}
var
setSerializer
=
{
id
:
"
mobx
-
keystone
/
setAsArray
"
serialize
:
function
serialize
(
set
_serialize
)
{
if
(
!
(
set
instanceof
Set
)
)
return
cannotSerialize
;
var
arr
=
[
]
;
var
iter
=
set
.
keys
(
)
;
var
cur
=
iter
.
next
(
)
;
while
(
!
cur
.
done
)
{
var
k
=
cur
.
value
;
arr
.
push
(
_serialize
(
k
)
)
;
cur
=
iter
.
next
(
)
;
}
return
arr
;
}
deserialize
:
function
deserialize
(
arr
_deserialize
)
{
var
set
=
new
Set
(
)
;
var
len
=
arr
.
length
;
for
(
var
i
=
0
;
i
<
len
;
i
+
+
)
{
var
k
=
arr
[
i
]
;
set
.
add
(
_deserialize
(
k
)
)
;
}
return
set
;
}
}
;
var
serializersArray
=
[
]
;
var
serializersMap
=
new
Map
(
)
;
function
registerActionCallArgumentSerializer
(
serializer
)
{
if
(
serializersArray
.
includes
(
serializer
)
)
{
throw
failure
(
"
action
call
argument
serializer
already
registered
"
)
;
}
if
(
serializersMap
.
has
(
serializer
.
id
)
)
{
throw
failure
(
"
action
call
argument
serializer
with
id
'
"
+
serializer
.
id
+
"
'
already
registered
"
)
;
}
serializersArray
.
unshift
(
serializer
)
;
serializersMap
.
set
(
serializer
.
id
serializer
)
;
return
function
(
)
{
var
index
=
serializersArray
.
indexOf
(
serializer
)
;
if
(
index
>
=
0
)
{
serializersArray
.
splice
(
index
1
)
;
}
serializersMap
[
"
delete
"
]
(
serializer
.
id
)
;
}
;
}
function
serializeActionCallArgument
(
argValue
targetRoot
)
{
if
(
isPrimitive
(
argValue
)
)
{
return
argValue
;
}
var
origValue
=
argValue
;
var
serialize
=
function
serialize
(
v
)
{
return
serializeActionCallArgument
(
v
targetRoot
)
;
}
;
for
(
var
i
=
0
;
i
<
serializersArray
.
length
;
i
+
+
)
{
var
serializer
=
serializersArray
[
i
]
;
var
serializedValue
=
serializer
.
serialize
(
argValue
serialize
targetRoot
)
;
if
(
serializedValue
!
=
=
cannotSerialize
)
{
return
{
mobxKeystoneSerializer
:
serializer
.
id
value
:
serializedValue
}
;
}
}
throw
failure
(
"
serializeActionCallArgument
could
not
serialize
the
given
value
:
"
+
origValue
)
;
}
function
serializeActionCall
(
actionCall
targetRoot
)
{
if
(
actionCall
.
serialized
)
{
throw
failure
(
"
cannot
serialize
an
already
serialized
action
call
"
)
;
}
if
(
targetRoot
!
=
=
undefined
)
{
assertTweakedObject
(
targetRoot
"
targetRoot
"
)
;
}
var
serialize
=
function
serialize
(
v
)
{
return
serializeActionCallArgument
(
v
targetRoot
)
;
}
;
return
_extends
(
{
}
actionCall
{
serialized
:
true
args
:
actionCall
.
args
.
map
(
serialize
)
}
)
;
}
function
deserializeActionCallArgument
(
argValue
targetRoot
)
{
if
(
isPrimitive
(
argValue
)
)
{
return
argValue
;
}
if
(
!
isPlainObject
(
argValue
)
|
|
typeof
argValue
.
mobxKeystoneSerializer
!
=
=
"
string
"
)
{
throw
failure
(
"
invalid
serialized
action
call
argument
"
)
;
}
var
serializerId
=
argValue
.
mobxKeystoneSerializer
;
var
serializer
=
serializersMap
.
get
(
serializerId
)
;
if
(
!
serializer
)
{
throw
failure
(
"
a
serializer
with
id
'
"
+
serializerId
+
"
'
could
not
be
found
"
)
;
}
var
serializedValue
=
argValue
;
var
deserialize
=
function
deserialize
(
v
)
{
return
deserializeActionCallArgument
(
v
targetRoot
)
;
}
;
return
serializer
.
deserialize
(
serializedValue
.
value
deserialize
targetRoot
)
;
}
function
deserializeActionCall
(
actionCall
targetRoot
)
{
if
(
!
actionCall
.
serialized
)
{
throw
failure
(
"
cannot
deserialize
a
non
-
serialized
action
call
"
)
;
}
if
(
targetRoot
!
=
=
undefined
)
{
assertTweakedObject
(
targetRoot
"
targetRoot
"
)
;
}
var
deserialize
=
function
deserialize
(
v
)
{
return
deserializeActionCallArgument
(
v
targetRoot
)
;
}
;
var
deserializedActionCall
=
_extends
(
{
}
actionCall
{
serialized
:
undefined
args
:
actionCall
.
args
.
map
(
deserialize
)
}
)
;
delete
deserializedActionCall
.
serialized
;
return
deserializedActionCall
;
}
registerActionCallArgumentSerializer
(
plainObjectSerializer
)
;
registerActionCallArgumentSerializer
(
setSerializer
)
;
registerActionCallArgumentSerializer
(
mapSerializer
)
;
registerActionCallArgumentSerializer
(
dateSerializer
)
;
registerActionCallArgumentSerializer
(
arraySerializer
)
;
registerActionCallArgumentSerializer
(
objectSnapshotSerializer
)
;
registerActionCallArgumentSerializer
(
objectPathSerializer
)
;
function
typesObjectHelper
(
objFn
frozen
typeInfoGen
)
{
assertIsFunction
(
objFn
"
objFn
"
)
;
return
lateTypeChecker
(
function
(
)
{
var
objectSchema
=
objFn
(
)
;
assertIsObject
(
objectSchema
"
objectSchema
"
)
;
var
schemaEntries
=
Object
.
entries
(
objectSchema
)
;
var
getTypeName
=
function
getTypeName
(
)
{
var
propsMsg
=
[
]
;
for
(
var
_len
=
arguments
.
length
recursiveTypeCheckers
=
new
Array
(
_len
)
_key
=
0
;
_key
<
_len
;
_key
+
+
)
{
recursiveTypeCheckers
[
_key
]
=
arguments
[
_key
]
;
}
for
(
var
_iterator
=
_createForOfIteratorHelperLoose
(
schemaEntries
)
_step
;
!
(
_step
=
_iterator
(
)
)
.
done
;
)
{
var
_step
value
=
_step
.
value
k
=
_step
value
[
0
]
unresolvedTc
=
_step
value
[
1
]
;
var
tc
=
resolveTypeChecker
(
unresolvedTc
)
;
var
propTypename
=
"
.
.
.
"
;
if
(
!
recursiveTypeCheckers
.
includes
(
tc
)
)
{
propTypename
=
tc
.
getTypeName
.
apply
(
tc
recursiveTypeCheckers
.
concat
(
[
tc
]
)
)
;
}
propsMsg
.
push
(
k
+
"
:
"
+
propTypename
+
"
;
"
)
;
}
return
"
{
"
+
propsMsg
.
join
(
"
"
)
+
"
}
"
;
}
;
var
thisTc
=
new
TypeChecker
(
function
(
obj
path
)
{
if
(
!
isObject
(
obj
)
|
|
frozen
&
&
!
(
obj
instanceof
Frozen
)
)
return
new
TypeCheckError
(
path
getTypeName
(
thisTc
)
obj
)
;
for
(
var
_iterator2
=
_createForOfIteratorHelperLoose
(
schemaEntries
)
_step2
;
!
(
_step2
=
_iterator2
(
)
)
.
done
;
)
{
var
_step2
value
=
_step2
.
value
k
=
_step2
value
[
0
]
unresolvedTc
=
_step2
value
[
1
]
;
var
tc
=
resolveTypeChecker
(
unresolvedTc
)
;
var
objVal
=
obj
[
k
]
;
var
valueError
=
!
tc
.
unchecked
?
tc
.
check
(
objVal
[
]
.
concat
(
path
[
k
]
)
)
:
null
;
if
(
valueError
)
{
return
valueError
;
}
}
return
null
;
}
getTypeName
typeInfoGen
)
;
return
thisTc
;
}
typeInfoGen
)
;
}
function
typesObject
(
objectFunction
)
{
var
typeInfoGen
=
function
typeInfoGen
(
t
)
{
return
new
ObjectTypeInfo
(
t
objectFunction
)
;
}
;
return
typesObjectHelper
(
objectFunction
false
typeInfoGen
)
;
}
var
ObjectTypeInfo
=
function
(
_TypeInfo
)
{
_inheritsLoose
(
ObjectTypeInfo
_TypeInfo
)
;
_createClass
(
ObjectTypeInfo
[
{
key
:
"
props
"
get
:
function
get
(
)
{
return
this
.
_props
(
)
;
}
}
]
)
;
function
ObjectTypeInfo
(
thisType
_objTypeFn
)
{
var
_this
;
_this
=
_TypeInfo
.
call
(
this
thisType
)
|
|
this
;
_this
.
_objTypeFn
=
void
0
;
_this
.
_props
=
lateVal
(
function
(
)
{
var
objSchema
=
_this
.
_objTypeFn
(
)
;
var
propTypes
=
{
}
;
Object
.
keys
(
objSchema
)
.
forEach
(
function
(
propName
)
{
var
type
=
resolveStandardType
(
objSchema
[
propName
]
)
;
propTypes
[
propName
]
=
{
type
:
type
typeInfo
:
getTypeInfo
(
type
)
}
;
}
)
;
return
propTypes
;
}
)
;
_this
.
_objTypeFn
=
_objTypeFn
;
return
_this
;
}
return
ObjectTypeInfo
;
}
(
TypeInfo
)
;
function
typesFrozen
(
dataType
)
{
return
typesObjectHelper
(
function
(
)
{
return
{
data
:
dataType
}
;
}
true
function
(
t
)
{
return
new
FrozenTypeInfo
(
t
resolveStandardType
(
dataType
)
)
;
}
)
;
}
var
FrozenTypeInfo
=
function
(
_TypeInfo2
)
{
_inheritsLoose
(
FrozenTypeInfo
_TypeInfo2
)
;
_createClass
(
FrozenTypeInfo
[
{
key
:
"
dataTypeInfo
"
get
:
function
get
(
)
{
return
getTypeInfo
(
this
.
dataType
)
;
}
}
]
)
;
function
FrozenTypeInfo
(
thisType
dataType
)
{
var
_this2
;
_this2
=
_TypeInfo2
.
call
(
this
thisType
)
|
|
this
;
_this2
.
dataType
=
void
0
;
_this2
.
dataType
=
dataType
;
return
_this2
;
}
return
FrozenTypeInfo
;
}
(
TypeInfo
)
;
var
unchecked
=
new
TypeChecker
(
null
function
(
)
{
return
"
any
"
;
}
function
(
t
)
{
return
new
UncheckedTypeInfo
(
t
)
;
}
)
;
function
typesUnchecked
(
)
{
return
unchecked
;
}
var
UncheckedTypeInfo
=
function
(
_TypeInfo
)
{
_inheritsLoose
(
UncheckedTypeInfo
_TypeInfo
)
;
function
UncheckedTypeInfo
(
)
{
return
_TypeInfo
.
apply
(
this
arguments
)
|
|
this
;
}
return
UncheckedTypeInfo
;
}
(
TypeInfo
)
;
function
ExtendedModel
(
baseModel
modelProps
)
{
return
internalModel
(
modelProps
baseModel
)
;
}
function
Model
(
modelProps
)
{
return
internalModel
(
modelProps
)
;
}
function
internalModel
(
modelProps
baseModel
)
{
var
_baseModel
;
assertIsObject
(
modelProps
"
modelProps
"
)
;
if
(
baseModel
)
{
assertIsModelClass
(
baseModel
"
baseModel
"
)
;
var
unwrappedClass
=
baseModel
[
modelUnwrappedClassSymbol
]
;
if
(
unwrappedClass
)
{
baseModel
=
unwrappedClass
;
assertIsModelClass
(
baseModel
"
baseModel
"
)
;
}
}
var
extraDescriptors
=
{
}
;
var
composedModelProps
=
modelProps
;
if
(
baseModel
)
{
var
oldModelProps
=
getInternalModelClassPropsInfo
(
baseModel
)
;
for
(
var
_i
=
0
_Object
keys
=
Object
.
keys
(
oldModelProps
)
;
_i
<
_Object
keys
.
length
;
_i
+
+
)
{
var
oldModelPropKey
=
_Object
keys
[
_i
]
;
if
(
modelProps
[
oldModelPropKey
]
)
{
throw
failure
(
"
extended
model
cannot
redeclare
base
model
property
named
'
"
+
oldModelPropKey
+
"
'
"
)
;
}
composedModelProps
[
oldModelPropKey
]
=
oldModelProps
[
oldModelPropKey
]
;
}
}
else
{
extraDescriptors
[
modelIdKey
]
=
createModelPropDescriptor
(
modelIdKey
undefined
true
)
;
}
var
dataTypeChecker
;
if
(
Object
.
values
(
composedModelProps
)
.
some
(
function
(
mp
)
{
return
!
!
mp
.
typeChecker
;
}
)
)
{
var
typeCheckerObj
=
{
}
;
for
(
var
_i2
=
0
_Object
entries
=
Object
.
entries
(
composedModelProps
)
;
_i2
<
_Object
entries
.
length
;
_i2
+
+
)
{
var
_Object
entries
_i
=
_Object
entries
[
_i2
]
k
=
_Object
entries
_i
[
0
]
mp
=
_Object
entries
_i
[
1
]
;
typeCheckerObj
[
k
]
=
!
mp
.
typeChecker
?
typesUnchecked
(
)
:
mp
.
typeChecker
;
}
dataTypeChecker
=
typesObject
(
function
(
)
{
return
typeCheckerObj
;
}
)
;
}
for
(
var
_iterator
=
_createForOfIteratorHelperLoose
(
Object
.
keys
(
modelProps
)
.
filter
(
function
(
mp
)
{
return
!
baseModelPropNames
.
has
(
mp
)
;
}
)
)
_step
;
!
(
_step
=
_iterator
(
)
)
.
done
;
)
{
var
modelPropName
=
_step
.
value
;
extraDescriptors
[
modelPropName
]
=
createModelPropDescriptor
(
modelPropName
modelProps
[
modelPropName
]
false
)
;
}
var
extraPropNames
=
Object
.
keys
(
extraDescriptors
)
;
var
extraPropNamesLen
=
extraPropNames
.
length
;
var
base
=
(
_baseModel
=
baseModel
)
!
=
null
?
_baseModel
:
BaseModel
;
var
propsWithTransforms
=
Object
.
entries
(
modelProps
)
.
filter
(
function
(
_ref
)
{
var
_propName
=
_ref
[
0
]
prop
=
_ref
[
1
]
;
return
!
!
prop
.
transform
;
}
)
.
map
(
function
(
_ref2
)
{
var
propName
=
_ref2
[
0
]
prop
=
_ref2
[
1
]
;
return
[
propName
prop
.
transform
]
;
}
)
;
var
CustomBaseModel
=
function
(
_base
)
{
_inheritsLoose
1
(
CustomBaseModel
_base
)
;
function
CustomBaseModel
(
initialData
constructorOptions
)
{
var
_constructorOptions
m
;
var
baseModel
=
new
base
(
initialData
_extends
(
{
}
constructorOptions
{
modelClass
:
(
_constructorOptions
m
=
constructorOptions
=
=
null
?
void
0
:
constructorOptions
.
modelClass
)
!
=
null
?
_constructorOptions
m
:
this
.
constructor
propsWithTransforms
:
propsWithTransforms
}
)
)
;
for
(
var
i
=
0
;
i
<
extraPropNamesLen
;
i
+
+
)
{
var
extraPropName
=
extraPropNames
[
i
]
;
if
(
Object
.
getOwnPropertyDescriptor
(
baseModel
extraPropName
)
)
{
delete
baseModel
[
extraPropName
]
;
}
}
return
baseModel
;
}
return
CustomBaseModel
;
}
(
base
)
;
var
initializers
=
base
[
modelInitializersSymbol
]
;
if
(
initializers
)
{
CustomBaseModel
[
modelInitializersSymbol
]
=
initializers
.
slice
(
)
;
}
setInternalModelClassPropsInfo
(
CustomBaseModel
composedModelProps
)
;
CustomBaseModel
[
modelDataTypeCheckerSymbol
]
=
dataTypeChecker
;
Object
.
defineProperties
(
CustomBaseModel
.
prototype
extraDescriptors
)
;
return
CustomBaseModel
;
}
function
_inheritsLoose
1
(
subClass
superClass
)
{
subClass
.
prototype
=
Object
.
create
(
superClass
.
prototype
)
;
subClass
.
prototype
.
constructor
=
subClass
;
subClass
.
__proto__
=
superClass
;
}
function
createModelPropDescriptor
(
modelPropName
modelProp
enumerable
)
{
return
{
enumerable
:
enumerable
configurable
:
true
get
:
function
get
(
)
{
return
getModelInstanceDataField
(
this
modelProp
modelPropName
)
;
}
set
:
function
set
(
v
)
{
if
(
!
this
[
modelInitializedSymbol
]
)
{
return
;
}
setModelInstanceDataField
(
this
modelProp
modelPropName
v
)
;
}
}
;
}
function
getModelInstanceDataField
(
model
modelProp
modelPropName
)
{
var
transform
=
modelProp
?
modelProp
.
transform
:
undefined
;
if
(
transform
)
{
var
memoTransform
=
memoTransformCache
.
getOrCreateMemoTransform
(
model
modelPropName
transform
)
;
return
memoTransform
.
propToData
(
model
.
[
modelPropName
]
)
;
}
else
{
return
model
.
[
modelPropName
]
;
}
}
function
setModelInstanceDataField
(
model
modelProp
modelPropName
value
)
{
if
(
(
modelProp
=
=
null
?
void
0
:
modelProp
.
options
.
setterAction
)
&
&
!
getCurrentActionContext
(
)
)
{
applySet
(
model
modelPropName
value
)
;
return
;
}
var
transform
=
modelProp
=
=
null
?
void
0
:
modelProp
.
transform
;
if
(
transform
)
{
var
memoTransform
=
memoTransformCache
.
getOrCreateMemoTransform
(
model
modelPropName
transform
)
;
model
.
[
modelPropName
]
=
memoTransform
.
dataToProp
(
value
)
;
}
else
{
model
.
[
modelPropName
]
=
value
;
}
}
var
model
=
function
model
(
name
)
{
return
function
(
clazz
)
{
return
internalModel
1
(
name
)
(
clazz
)
;
}
;
}
;
var
internalModel
1
=
function
internalModel
(
name
)
{
return
function
(
clazz
)
{
assertIsModelClass
(
clazz
"
a
model
class
"
)
;
if
(
modelInfoByName
[
name
]
)
{
logWarning
(
"
warn
"
"
a
model
with
name
\
"
"
+
name
+
"
\
"
already
exists
(
if
you
are
using
hot
-
reloading
you
may
safely
ignore
this
warning
)
"
"
duplicateModelName
-
"
+
name
)
;
}
if
(
clazz
[
modelUnwrappedClassSymbol
]
)
{
throw
failure
(
"
a
class
already
decorated
with
model
cannot
be
re
-
decorated
"
)
;
}
var
newClazz
=
function
newClazz
(
initialData
snapshotInitialData
generateNewIds
)
{
var
instance
=
new
clazz
(
initialData
snapshotInitialData
this
.
constructor
generateNewIds
)
;
runLateInitializationFunctions
(
instance
)
;
if
(
getMobxVersion
(
)
>
=
6
)
{
try
{
;
(
0
mobx_esm
.
makeObservable
)
(
instance
)
;
}
catch
(
err
)
{
if
(
err
.
message
!
=
=
"
[
MobX
]
No
annotations
were
passed
to
makeObservable
but
no
decorator
members
have
been
found
either
"
)
{
throw
err
;
}
}
}
addHiddenProp
(
instance
modelInitializedSymbol
true
false
)
;
if
(
instance
.
onInit
)
{
wrapModelMethodInActionIfNeeded
(
instance
"
onInit
"
HookAction
.
OnInit
)
;
instance
.
onInit
(
)
;
}
return
instance
;
}
;
clazz
.
toString
=
function
(
)
{
return
"
class
"
+
clazz
.
name
+
"
#
"
+
name
;
}
;
clazz
[
modelTypeKey
]
=
name
;
Object
.
setPrototypeOf
(
newClazz
clazz
)
;
newClazz
.
prototype
=
clazz
.
prototype
;
Object
.
defineProperty
(
newClazz
"
name
"
_extends
(
{
}
Object
.
getOwnPropertyDescriptor
(
newClazz
"
name
"
)
{
value
:
clazz
.
name
}
)
)
;
newClazz
[
modelUnwrappedClassSymbol
]
=
clazz
;
var
modelInfo
=
{
name
:
name
"
class
"
:
newClazz
}
;
modelInfoByName
[
name
]
=
modelInfo
;
modelInfoByClass
.
set
(
newClazz
modelInfo
)
;
modelInfoByClass
.
set
(
clazz
modelInfo
)
;
return
newClazz
;
}
;
}
;
function
tsDecorate
(
decorators
target
key
desc
)
{
var
c
=
arguments
.
length
r
=
c
<
3
?
target
:
desc
=
=
=
null
?
desc
=
Object
.
getOwnPropertyDescriptor
(
target
key
)
:
desc
d
;
if
(
typeof
Reflect
=
=
=
"
object
"
&
&
typeof
Reflect
.
decorate
=
=
=
"
function
"
)
r
=
Reflect
.
decorate
(
decorators
target
key
desc
)
;
else
for
(
var
i
=
decorators
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
if
(
d
=
decorators
[
i
]
)
r
=
(
c
<
3
?
d
(
r
)
:
c
>
3
?
d
(
target
key
r
)
:
d
(
target
key
)
)
|
|
r
;
}
return
c
>
3
&
&
r
&
&
Object
.
defineProperty
(
target
key
r
)
r
;
}
function
decoratedModel
(
name
clazz
decorators
)
{
for
(
var
_i
=
0
_Object
entries
=
Object
.
entries
(
decorators
)
;
_i
<
_Object
entries
.
length
;
_i
+
+
)
{
var
_Object
entries
_i
=
_Object
entries
[
_i
]
k
=
_Object
entries
_i
[
0
]
decorator
=
_Object
entries
_i
[
1
]
;
var
prototypeValueDesc
=
Object
.
getOwnPropertyDescriptor
(
clazz
.
prototype
k
)
;
tsDecorate
(
Array
.
isArray
(
decorator
)
?
decorator
:
[
decorator
]
clazz
.
prototype
k
prototypeValueDesc
?
prototypeValueDesc
:
void
0
)
;
}
return
name
?
model
(
name
)
(
clazz
)
:
clazz
;
}
function
applySerializedActionAndTrackNewModelIds
(
subtreeRoot
call
)
{
if
(
!
call
.
serialized
)
{
throw
failure
(
"
cannot
apply
a
non
-
serialized
action
call
use
'
applyAction
'
instead
"
)
;
}
assertTweakedObject
(
subtreeRoot
"
subtreeRoot
"
)
;
var
deserializedCall
=
deserializeActionCall
(
call
subtreeRoot
)
;
var
modelIdOverrides
=
[
]
;
var
patchDisposer
=
onPatches
(
subtreeRoot
function
(
patches
)
{
scanPatchesForModelIdChanges
(
subtreeRoot
modelIdOverrides
patches
)
;
}
)
;
try
{
var
returnValue
=
applyAction
(
subtreeRoot
deserializedCall
)
;
return
{
returnValue
:
returnValue
serializedActionCall
:
_extends
(
{
}
call
{
modelIdOverrides
:
modelIdOverrides
}
)
}
;
}
finally
{
patchDisposer
(
)
;
}
}
function
scanPatchesForModelIdChanges
(
root
modelIdOverrides
patches
)
{
var
len
=
patches
.
length
;
for
(
var
i
=
0
;
i
<
len
;
i
+
+
)
{
var
patch
=
patches
[
i
]
;
if
(
patch
.
op
=
=
=
"
replace
"
|
|
patch
.
op
=
=
=
"
add
"
)
{
deepScanValueForModelIdChanges
(
root
modelIdOverrides
patch
.
value
patch
.
path
)
;
}
}
}
function
deepScanValueForModelIdChanges
(
root
modelIdOverrides
value
path
)
{
if
(
path
.
length
>
=
1
&
&
path
[
path
.
length
-
1
]
=
=
=
modelIdKey
&
&
typeof
value
=
=
=
"
string
"
)
{
var
parent
=
resolvePath
(
root
path
.
slice
(
0
path
.
length
-
1
)
)
.
value
;
if
(
isModel
(
parent
)
)
{
modelIdOverrides
.
push
(
{
op
:
"
replace
"
path
:
path
.
slice
(
)
value
:
value
}
)
;
}
}
else
if
(
Array
.
isArray
(
value
)
)
{
var
len
=
value
.
length
;
for
(
var
i
=
0
;
i
<
len
;
i
+
+
)
{
path
.
push
(
i
)
;
deepScanValueForModelIdChanges
(
root
modelIdOverrides
value
[
i
]
path
)
;
path
.
pop
(
)
;
}
}
else
if
(
isObject
(
value
)
)
{
if
(
!
value
[
frozenKey
]
)
{
var
keys
=
Object
.
keys
(
value
)
;
var
_len
=
keys
.
length
;
for
(
var
_i
=
0
;
_i
<
_len
;
_i
+
+
)
{
var
propName
=
keys
[
_i
]
;
var
propValue
=
value
[
propName
]
;
path
.
push
(
propName
)
;
deepScanValueForModelIdChanges
(
root
modelIdOverrides
propValue
path
)
;
path
.
pop
(
)
;
}
}
}
}
function
applySerializedActionAndSyncNewModelIds
(
subtreeRoot
call
)
{
if
(
!
call
.
serialized
)
{
throw
failure
(
"
cannot
apply
a
non
-
serialized
action
call
use
'
applyAction
'
instead
"
)
;
}
assertTweakedObject
(
subtreeRoot
"
subtreeRoot
"
)
;
var
deserializedCall
=
deserializeActionCall
(
call
subtreeRoot
)
;
var
returnValue
;
(
0
mobx_esm
.
runInAction
)
(
function
(
)
{
returnValue
=
applyAction
(
subtreeRoot
deserializedCall
)
;
applyPatches
(
subtreeRoot
call
.
modelIdOverrides
)
;
}
)
;
return
returnValue
;
}
var
ActionTrackingResult
;
(
function
(
ActionTrackingResult
)
{
ActionTrackingResult
[
"
Return
"
]
=
"
return
"
;
ActionTrackingResult
[
"
Throw
"
]
=
"
throw
"
;
}
)
(
ActionTrackingResult
|
|
(
ActionTrackingResult
=
{
}
)
)
;
function
actionTrackingMiddleware
(
subtreeRoot
hooks
)
{
assertTweakedObject
(
subtreeRoot
"
subtreeRoot
"
)
;
var
dataSymbol
=
Symbol
(
"
actionTrackingMiddlewareData
"
)
;
function
getCtxData
(
ctx
)
{
return
ctx
.
data
[
dataSymbol
]
;
}
function
setCtxData
(
ctx
partialData
)
{
var
currentData
=
ctx
.
data
[
dataSymbol
]
;
if
(
!
currentData
)
{
ctx
.
data
[
dataSymbol
]
=
partialData
;
}
else
{
Object
.
assign
(
currentData
partialData
)
;
}
}
var
userFilter
=
function
userFilter
(
ctx
)
{
if
(
hooks
.
filter
)
{
return
hooks
.
filter
(
simplifyActionContext
(
ctx
)
)
;
}
return
true
;
}
;
var
resumeSuspendSupport
=
!
!
hooks
.
onResume
|
|
!
!
hooks
.
onSuspend
;
var
filter
=
function
filter
(
ctx
)
{
if
(
ctx
.
type
=
=
=
ActionContextActionType
.
Sync
)
{
var
accepted
=
userFilter
(
ctx
)
;
if
(
accepted
)
{
setCtxData
(
ctx
{
startAccepted
:
true
state
:
"
idle
"
}
)
;
}
return
accepted
;
}
else
{
switch
(
ctx
.
asyncStepType
)
{
case
ActionContextAsyncStepType
.
Spawn
:
var
_accepted
=
userFilter
(
ctx
)
;
if
(
_accepted
)
{
setCtxData
(
ctx
{
startAccepted
:
true
state
:
"
idle
"
}
)
;
}
return
_accepted
;
case
ActionContextAsyncStepType
.
Return
:
case
ActionContextAsyncStepType
.
Throw
:
var
data
=
getCtxData
(
ctx
.
spawnAsyncStepContext
)
;
return
data
?
data
.
startAccepted
:
false
;
case
ActionContextAsyncStepType
.
Resume
:
case
ActionContextAsyncStepType
.
ResumeError
:
if
(
!
resumeSuspendSupport
)
{
return
false
;
}
else
{
var
_data
=
getCtxData
(
ctx
.
spawnAsyncStepContext
)
;
return
_data
?
_data
.
startAccepted
:
false
;
}
default
:
return
false
;
}
}
}
;
var
start
=
function
start
(
simpleCtx
)
{
setCtxData
(
simpleCtx
{
state
:
"
started
"
}
)
;
if
(
hooks
.
onStart
)
{
return
hooks
.
onStart
(
simpleCtx
)
|
|
undefined
;
}
return
undefined
;
}
;
var
finish
=
function
finish
(
simpleCtx
ret
)
{
var
parentCtx
=
simpleCtx
.
parentContext
;
var
parentResumed
=
false
;
if
(
parentCtx
)
{
var
parentData
=
getCtxData
(
parentCtx
)
;
if
(
parentData
&
&
parentData
.
startAccepted
&
&
parentData
.
state
=
=
=
"
suspended
"
)
{
parentResumed
=
true
;
resume
(
parentCtx
false
)
;
}
}
setCtxData
(
simpleCtx
{
state
:
"
finished
"
}
)
;
if
(
hooks
.
onFinish
)
{
ret
=
hooks
.
onFinish
(
simpleCtx
ret
)
|
|
ret
;
}
if
(
parentResumed
)
{
suspend
(
parentCtx
)
;
}
return
ret
;
}
;
var
resume
=
function
resume
(
simpleCtx
real
)
{
var
parentCtx
=
simpleCtx
.
parentContext
;
if
(
parentCtx
)
{
var
parentData
=
getCtxData
(
parentCtx
)
;
if
(
parentData
&
&
parentData
.
startAccepted
&
&
parentData
.
state
=
=
=
"
suspended
"
)
{
resume
(
parentCtx
false
)
;
}
}
setCtxData
(
simpleCtx
{
state
:
real
?
"
realResumed
"
:
"
fakeResumed
"
}
)
;
if
(
hooks
.
onResume
)
{
hooks
.
onResume
(
simpleCtx
)
;
}
}
;
var
suspend
=
function
suspend
(
simpleCtx
)
{
setCtxData
(
simpleCtx
{
state
:
"
suspended
"
}
)
;
if
(
hooks
.
onSuspend
)
{
hooks
.
onSuspend
(
simpleCtx
)
;
}
var
parentCtx
=
simpleCtx
.
parentContext
;
if
(
parentCtx
)
{
var
parentData
=
getCtxData
(
parentCtx
)
;
if
(
parentData
&
&
parentData
.
startAccepted
&
&
parentData
.
state
=
=
=
"
fakeResumed
"
)
{
suspend
(
parentCtx
)
;
}
}
}
;
var
mware
=
function
mware
(
ctx
next
)
{
var
simpleCtx
=
simplifyActionContext
(
ctx
)
;
var
origNext
=
next
;
next
=
function
next
(
)
{
resume
(
simpleCtx
true
)
;
try
{
return
origNext
(
)
;
}
finally
{
suspend
(
simpleCtx
)
;
}
}
;
if
(
ctx
.
type
=
=
=
ActionContextActionType
.
Sync
)
{
var
retObj
=
start
(
simpleCtx
)
;
if
(
retObj
)
{
resume
(
simpleCtx
true
)
;
suspend
(
simpleCtx
)
;
retObj
=
finish
(
simpleCtx
retObj
)
;
}
else
{
try
{
retObj
=
finish
(
simpleCtx
{
result
:
ActionTrackingResult
.
Return
value
:
next
(
)
}
)
;
}
catch
(
err
)
{
retObj
=
finish
(
simpleCtx
{
result
:
ActionTrackingResult
.
Throw
value
:
err
}
)
;
}
}
return
returnOrThrowActionTrackingReturn
(
retObj
)
;
}
else
{
switch
(
ctx
.
asyncStepType
)
{
case
ActionContextAsyncStepType
.
Spawn
:
{
var
_retObj
=
start
(
simpleCtx
)
;
if
(
_retObj
)
{
resume
(
simpleCtx
true
)
;
suspend
(
simpleCtx
)
;
_retObj
=
finish
(
simpleCtx
_retObj
)
;
return
returnOrThrowActionTrackingReturn
(
_retObj
)
;
}
else
{
return
next
(
)
;
}
}
case
ActionContextAsyncStepType
.
Return
:
{
var
flowFinisher
=
next
(
)
;
var
_retObj2
=
finish
(
simpleCtx
{
result
:
ActionTrackingResult
.
Return
value
:
flowFinisher
.
value
}
)
;
flowFinisher
.
resolution
=
_retObj2
.
result
=
=
=
ActionTrackingResult
.
Return
?
"
accept
"
:
"
reject
"
;
flowFinisher
.
value
=
_retObj2
.
value
;
return
flowFinisher
;
}
case
ActionContextAsyncStepType
.
Throw
:
{
var
_flowFinisher
=
next
(
)
;
var
_retObj3
=
finish
(
simpleCtx
{
result
:
ActionTrackingResult
.
Throw
value
:
_flowFinisher
.
value
}
)
;
_flowFinisher
.
resolution
=
_retObj3
.
result
=
=
=
ActionTrackingResult
.
Return
?
"
accept
"
:
"
reject
"
;
_flowFinisher
.
value
=
_retObj3
.
value
;
return
_flowFinisher
;
}
case
ActionContextAsyncStepType
.
Resume
:
case
ActionContextAsyncStepType
.
ResumeError
:
if
(
resumeSuspendSupport
)
{
return
next
(
)
;
}
else
{
throw
failure
(
"
asssertion
error
:
async
step
should
have
been
filtered
out
-
"
+
ctx
.
asyncStepType
)
;
}
default
:
throw
failure
(
"
asssertion
error
:
async
step
should
have
been
filtered
out
-
"
+
ctx
.
asyncStepType
)
;
}
}
}
;
return
addActionMiddleware
(
{
middleware
:
mware
filter
:
filter
subtreeRoot
:
subtreeRoot
}
)
;
}
function
returnOrThrowActionTrackingReturn
(
retObj
)
{
if
(
retObj
.
result
=
=
=
ActionTrackingResult
.
Return
)
{
return
retObj
.
value
;
}
else
{
throw
retObj
.
value
;
}
}
var
simpleDataContextSymbol
=
Symbol
(
"
simpleDataContext
"
)
;
function
simplifyActionContext
(
ctx
)
{
while
(
ctx
.
previousAsyncStepContext
)
{
ctx
=
ctx
.
previousAsyncStepContext
;
}
var
simpleCtx
=
ctx
.
data
[
simpleDataContextSymbol
]
;
if
(
!
simpleCtx
)
{
var
parentContext
=
ctx
.
parentContext
?
simplifyActionContext
(
ctx
.
parentContext
)
:
undefined
;
simpleCtx
=
{
actionName
:
ctx
.
actionName
type
:
ctx
.
type
target
:
ctx
.
target
args
:
ctx
.
args
data
:
ctx
.
data
parentContext
:
parentContext
}
;
simpleCtx
.
rootContext
=
parentContext
?
parentContext
.
rootContext
:
simpleCtx
;
ctx
.
data
[
simpleDataContextSymbol
]
=
simpleCtx
;
}
return
simpleCtx
;
}
function
onActionMiddleware
(
subtreeRoot
listeners
)
{
assertTweakedObject
(
subtreeRoot
"
subtreeRoot
"
)
;
assertIsObject
(
listeners
"
listeners
"
)
;
return
actionTrackingMiddleware
(
subtreeRoot
{
filter
:
function
filter
(
ctx
)
{
if
(
ctx
.
parentContext
)
{
return
false
;
}
if
(
isHookAction
(
ctx
.
actionName
)
)
{
return
false
;
}
return
true
;
}
onStart
:
function
onStart
(
ctx
)
{
if
(
listeners
.
onStart
)
{
var
actionCall
=
actionContextToActionCall
(
ctx
)
;
return
listeners
.
onStart
(
actionCall
ctx
)
;
}
}
onFinish
:
function
onFinish
(
ctx
ret
)
{
if
(
listeners
.
onFinish
)
{
var
actionCall
=
actionContextToActionCall
(
ctx
)
;
return
listeners
.
onFinish
(
actionCall
ctx
ret
)
;
}
}
}
)
;
}
function
actionContextToActionCall
(
ctx
)
{
var
rootPath
=
fastGetRootPath
(
ctx
.
target
)
;
return
{
actionName
:
ctx
.
actionName
args
:
ctx
.
args
targetPath
:
rootPath
.
path
targetPathIds
:
rootPathToTargetPathIds
(
rootPath
)
}
;
}
function
readonlyMiddleware
(
subtreeRoot
)
{
assertTweakedObject
(
subtreeRoot
"
subtreeRoot
"
)
;
var
writable
=
false
;
var
writableSymbol
=
Symbol
(
"
writable
"
)
;
var
disposer
=
actionTrackingMiddleware
(
subtreeRoot
{
filter
:
function
filter
(
ctx
)
{
if
(
isHookAction
(
ctx
.
actionName
)
)
{
return
false
;
}
var
currentlyWritable
=
writable
;
if
(
!
currentlyWritable
)
{
var
currentCtx
=
ctx
;
while
(
currentCtx
&
&
!
currentlyWritable
)
{
currentlyWritable
=
!
!
currentCtx
.
data
[
writableSymbol
]
;
currentCtx
=
currentCtx
.
parentContext
;
}
}
if
(
currentlyWritable
)
{
ctx
.
data
[
writableSymbol
]
=
true
;
return
false
;
}
return
true
;
}
onStart
:
function
onStart
(
ctx
)
{
return
{
result
:
ActionTrackingResult
.
Throw
value
:
failure
(
"
tried
to
invoke
action
'
"
+
ctx
.
actionName
+
"
'
over
a
readonly
node
"
)
}
;
}
}
)
;
return
{
dispose
:
disposer
allowWrite
:
function
allowWrite
(
fn
)
{
var
oldWritable
=
writable
;
writable
=
true
;
try
{
return
fn
(
)
;
}
finally
{
writable
=
oldWritable
;
}
}
}
;
}
function
escapePathComponent
(
path
)
{
if
(
typeof
path
=
=
=
"
number
"
)
{
return
"
"
+
path
;
}
if
(
path
.
indexOf
(
"
/
"
)
=
=
=
-
1
&
&
path
.
indexOf
(
"
~
"
)
=
=
=
-
1
)
{
return
path
;
}
return
path
.
replace
(
/
~
/
g
"
~
0
"
)
.
replace
(
/
\
/
/
g
"
~
1
"
)
;
}
function
unescapePathComponent
(
path
)
{
return
path
.
replace
(
/
~
1
/
g
"
/
"
)
.
replace
(
/
~
0
/
g
"
~
"
)
;
}
function
pathToJsonPointer
(
path
)
{
if
(
path
.
length
<
=
0
)
{
return
"
"
;
}
return
"
/
"
+
path
.
map
(
escapePathComponent
)
.
join
(
"
/
"
)
;
}
function
jsonPointerToPath
(
jsonPointer
)
{
if
(
jsonPointer
=
=
=
"
"
)
{
return
[
]
;
}
if
(
!
jsonPointer
.
startsWith
(
"
/
"
)
)
{
throw
failure
(
"
a
JSON
pointer
must
start
with
'
/
'
or
be
empty
"
)
;
}
jsonPointer
=
jsonPointer
.
slice
(
1
)
;
return
jsonPointer
.
split
(
"
/
"
)
.
map
(
unescapePathComponent
)
;
}
function
patchToJsonPatch
(
patch
)
{
return
_extends
(
{
}
patch
{
path
:
pathToJsonPointer
(
patch
.
path
)
}
)
;
}
function
jsonPatchToPatch
(
jsonPatch
)
{
return
_extends
(
{
}
jsonPatch
{
path
:
jsonPointerToPath
(
jsonPatch
.
path
)
}
)
;
}
function
patchRecorder
(
subtreeRoot
opts
)
{
assertTweakedObject
(
subtreeRoot
"
subtreeRoot
"
)
;
return
internalPatchRecorder
(
subtreeRoot
opts
)
;
}
function
internalPatchRecorder
(
subtreeRoot
opts
)
{
var
_recording
filter
opt
=
_extends
(
{
recording
:
true
filter
:
alwaysAcceptFilter
}
opts
)
recording
=
_recording
filter
opt
.
recording
filter
=
_recording
filter
opt
.
filter
;
var
events
=
mobx_esm
.
observable
.
array
(
[
]
{
deep
:
false
}
)
;
var
onPatchesDisposer
;
if
(
subtreeRoot
)
{
onPatchesDisposer
=
onPatches
(
subtreeRoot
function
(
p
invP
)
{
if
(
recording
&
&
filter
(
p
invP
)
)
{
events
.
push
(
{
target
:
subtreeRoot
patches
:
p
inversePatches
:
invP
}
)
;
opts
=
=
null
?
void
0
:
opts
.
onPatches
=
=
null
?
void
0
:
opts
.
onPatches
(
p
invP
)
;
}
}
)
;
}
else
{
onPatchesDisposer
=
onGlobalPatches
(
function
(
target
p
invP
)
{
if
(
recording
&
&
filter
(
p
invP
)
)
{
events
.
push
(
{
target
:
target
patches
:
p
inversePatches
:
invP
}
)
;
opts
=
=
null
?
void
0
:
opts
.
onPatches
=
=
null
?
void
0
:
opts
.
onPatches
(
p
invP
)
;
}
}
)
;
}
return
{
get
recording
(
)
{
return
recording
;
}
set
recording
(
enabled
)
{
recording
=
enabled
;
}
get
events
(
)
{
return
events
;
}
dispose
:
function
dispose
(
)
{
onPatchesDisposer
(
)
;
}
}
;
}
var
alwaysAcceptFilter
=
function
alwaysAcceptFilter
(
)
{
return
true
;
}
;
function
transactionMiddleware
(
target
)
{
assertIsObject
(
target
"
target
"
)
;
var
model
=
target
.
model
actionName
=
target
.
actionName
;
assertIsModel
(
model
"
target
.
model
"
)
;
if
(
typeof
actionName
!
=
=
"
string
"
)
{
throw
failure
(
"
target
.
actionName
must
be
a
string
"
)
;
}
var
patchRecorderSymbol
=
Symbol
(
"
patchRecorder
"
)
;
function
initPatchRecorder
(
ctx
)
{
ctx
.
rootContext
.
data
[
patchRecorderSymbol
]
=
internalPatchRecorder
(
undefined
{
recording
:
false
}
)
;
}
function
getPatchRecorder
(
ctx
)
{
return
ctx
.
rootContext
.
data
[
patchRecorderSymbol
]
;
}
return
actionTrackingMiddleware
(
model
{
filter
:
function
filter
(
ctx
)
{
var
rootContext
=
ctx
.
rootContext
;
return
rootContext
.
target
=
=
=
model
&
&
rootContext
.
actionName
=
=
=
actionName
;
}
onStart
:
function
onStart
(
ctx
)
{
if
(
ctx
=
=
=
ctx
.
rootContext
)
{
initPatchRecorder
(
ctx
)
;
}
}
onResume
:
function
onResume
(
ctx
)
{
getPatchRecorder
(
ctx
)
.
recording
=
true
;
}
onSuspend
:
function
onSuspend
(
ctx
)
{
getPatchRecorder
(
ctx
)
.
recording
=
false
;
}
onFinish
:
function
onFinish
(
ctx
ret
)
{
if
(
ctx
=
=
=
ctx
.
rootContext
)
{
var
patchRecorder
=
getPatchRecorder
(
ctx
)
;
try
{
if
(
ret
.
result
=
=
=
ActionTrackingResult
.
Throw
)
{
var
events
=
patchRecorder
.
events
;
for
(
var
i
=
events
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
var
event
=
events
[
i
]
;
applyPatches
(
event
.
target
event
.
inversePatches
true
)
;
}
}
}
finally
{
patchRecorder
.
dispose
(
)
;
}
}
}
}
)
;
}
function
transaction
(
target
propertyKey
)
{
checkModelDecoratorArgs
(
"
transaction
"
target
propertyKey
)
;
addModelClassInitializer
(
target
.
constructor
function
(
modelInstance
)
{
transactionMiddleware
(
{
model
:
modelInstance
actionName
:
propertyKey
}
)
;
}
)
;
}
function
typesArray
(
itemType
)
{
var
typeInfoGen
=
function
typeInfoGen
(
t
)
{
return
new
ArrayTypeInfo
(
t
resolveStandardType
(
itemType
)
)
;
}
;
return
lateTypeChecker
(
function
(
)
{
var
itemChecker
=
resolveTypeChecker
(
itemType
)
;
var
getTypeName
=
function
getTypeName
(
)
{
for
(
var
_len
=
arguments
.
length
recursiveTypeCheckers
=
new
Array
(
_len
)
_key
=
0
;
_key
<
_len
;
_key
+
+
)
{
recursiveTypeCheckers
[
_key
]
=
arguments
[
_key
]
;
}
return
"
Array
<
"
+
itemChecker
.
getTypeName
.
apply
(
itemChecker
recursiveTypeCheckers
.
concat
(
[
itemChecker
]
)
)
+
"
>
"
;
}
;
var
thisTc
=
new
TypeChecker
(
function
(
array
path
)
{
if
(
!
isArray
(
array
)
)
{
return
new
TypeCheckError
(
path
getTypeName
(
thisTc
)
array
)
;
}
if
(
!
itemChecker
.
unchecked
)
{
for
(
var
i
=
0
;
i
<
array
.
length
;
i
+
+
)
{
var
itemError
=
itemChecker
.
check
(
array
[
i
]
[
]
.
concat
(
path
[
i
]
)
)
;
if
(
itemError
)
{
return
itemError
;
}
}
}
return
null
;
}
getTypeName
typeInfoGen
)
;
return
thisTc
;
}
typeInfoGen
)
;
}
var
ArrayTypeInfo
=
function
(
_TypeInfo
)
{
_inheritsLoose
(
ArrayTypeInfo
_TypeInfo
)
;
_createClass
(
ArrayTypeInfo
[
{
key
:
"
itemTypeInfo
"
get
:
function
get
(
)
{
return
getTypeInfo
(
this
.
itemType
)
;
}
}
]
)
;
function
ArrayTypeInfo
(
thisType
itemType
)
{
var
_this
;
_this
=
_TypeInfo
.
call
(
this
thisType
)
|
|
this
;
_this
.
itemType
=
void
0
;
_this
.
itemType
=
itemType
;
return
_this
;
}
return
ArrayTypeInfo
;
}
(
TypeInfo
)
;
function
tProp
(
typeOrDefaultValue
arg1
arg2
)
{
var
def
;
var
opts
=
{
}
;
var
hasDefaultValue
=
false
;
switch
(
typeof
typeOrDefaultValue
)
{
case
"
string
"
:
return
tProp
(
typesString
typeOrDefaultValue
arg1
)
;
case
"
number
"
:
return
tProp
(
typesNumber
typeOrDefaultValue
arg1
)
;
case
"
boolean
"
:
return
tProp
(
typesBoolean
typeOrDefaultValue
arg1
)
;
}
if
(
arguments
.
length
>
=
3
)
{
def
=
arg1
;
hasDefaultValue
=
true
;
opts
=
_extends
(
{
}
arg2
)
;
}
else
if
(
arguments
.
length
=
=
=
2
)
{
if
(
isObject
(
arg1
)
)
{
opts
=
_extends
(
{
}
arg1
)
;
}
else
{
def
=
arg1
;
hasDefaultValue
=
true
;
}
}
var
isDefFn
=
typeof
def
=
=
=
"
function
"
;
return
{
propValueType
:
null
propCreationValueType
:
null
isOptional
:
null
instanceValueType
:
null
instanceCreationValueType
:
null
defaultFn
:
hasDefaultValue
&
&
isDefFn
?
def
:
noDefaultValue
defaultValue
:
hasDefaultValue
&
&
!
isDefFn
?
def
:
noDefaultValue
typeChecker
:
resolveStandardType
(
typeOrDefaultValue
)
transform
:
undefined
options
:
opts
}
;
}
var
UndoStore
=
function
(
_Model
)
{
_inheritsLoose
(
UndoStore
_Model
)
;
function
UndoStore
(
)
{
return
_Model
.
apply
(
this
arguments
)
|
|
this
;
}
var
_proto
=
UndoStore
.
prototype
;
_proto
.
_clearUndo
=
function
_clearUndo
(
)
{
var
_this
=
this
;
withoutUndo
(
function
(
)
{
_this
.
undoEvents
.
length
=
0
;
}
)
;
}
;
_proto
.
_clearRedo
=
function
_clearRedo
(
)
{
var
_this2
=
this
;
withoutUndo
(
function
(
)
{
_this2
.
redoEvents
.
length
=
0
;
}
)
;
}
;
_proto
.
_undo
=
function
_undo
(
)
{
var
_this3
=
this
;
withoutUndo
(
function
(
)
{
var
event
=
_this3
.
undoEvents
.
pop
(
)
;
_this3
.
redoEvents
.
push
(
event
)
;
}
)
;
}
;
_proto
.
_redo
=
function
_redo
(
)
{
var
_this4
=
this
;
withoutUndo
(
function
(
)
{
var
event
=
_this4
.
redoEvents
.
pop
(
)
;
_this4
.
undoEvents
.
push
(
event
)
;
}
)
;
}
;
_proto
.
_addUndo
=
function
_addUndo
(
event
)
{
var
_this5
=
this
;
withoutUndo
(
function
(
)
{
_this5
.
undoEvents
.
push
(
event
)
;
_this5
.
redoEvents
.
length
=
0
;
}
)
;
}
;
return
UndoStore
;
}
(
Model
(
{
undoEvents
:
tProp
(
typesArray
(
typesUnchecked
(
)
)
function
(
)
{
return
[
]
;
}
)
redoEvents
:
tProp
(
typesArray
(
typesUnchecked
(
)
)
function
(
)
{
return
[
]
;
}
)
}
)
)
;
__decorate
(
[
modelAction
]
UndoStore
.
prototype
"
_clearUndo
"
null
)
;
__decorate
(
[
modelAction
]
UndoStore
.
prototype
"
_clearRedo
"
null
)
;
__decorate
(
[
modelAction
]
UndoStore
.
prototype
"
_undo
"
null
)
;
__decorate
(
[
modelAction
]
UndoStore
.
prototype
"
_redo
"
null
)
;
__decorate
(
[
modelAction
]
UndoStore
.
prototype
"
_addUndo
"
null
)
;
UndoStore
=
__decorate
(
[
model
(
"
mobx
-
keystone
/
UndoStore
"
)
]
UndoStore
)
;
var
UndoManager
=
function
(
)
{
var
_proto2
=
UndoManager
.
prototype
;
_proto2
.
clearUndo
=
function
clearUndo
(
)
{
this
.
store
.
_clearUndo
(
)
;
}
;
_proto2
.
clearRedo
=
function
clearRedo
(
)
{
this
.
store
.
_clearRedo
(
)
;
}
;
_proto2
.
undo
=
function
undo
(
)
{
var
_this6
=
this
;
if
(
!
this
.
canUndo
)
{
throw
failure
(
"
nothing
to
undo
"
)
;
}
var
event
=
this
.
undoQueue
[
this
.
undoQueue
.
length
-
1
]
;
withoutUndo
(
function
(
)
{
applyPatches
(
_this6
.
subtreeRoot
event
.
inversePatches
true
)
;
}
)
;
this
.
store
.
_undo
(
)
;
}
;
_proto2
.
redo
=
function
redo
(
)
{
var
_this7
=
this
;
if
(
!
this
.
canRedo
)
{
throw
failure
(
"
nothing
to
redo
"
)
;
}
var
event
=
this
.
redoQueue
[
this
.
redoQueue
.
length
-
1
]
;
withoutUndo
(
function
(
)
{
applyPatches
(
_this7
.
subtreeRoot
event
.
patches
)
;
}
)
;
this
.
store
.
_redo
(
)
;
}
;
_proto2
.
dispose
=
function
dispose
(
)
{
this
.
disposer
(
)
;
}
;
_createClass
(
UndoManager
[
{
key
:
"
undoQueue
"
get
:
function
get
(
)
{
return
this
.
store
.
undoEvents
;
}
}
{
key
:
"
redoQueue
"
get
:
function
get
(
)
{
return
this
.
store
.
redoEvents
;
}
}
{
key
:
"
undoLevels
"
get
:
function
get
(
)
{
return
this
.
undoQueue
.
length
;
}
}
{
key
:
"
canUndo
"
get
:
function
get
(
)
{
return
this
.
undoLevels
>
0
;
}
}
{
key
:
"
redoLevels
"
get
:
function
get
(
)
{
return
this
.
redoQueue
.
length
;
}
}
{
key
:
"
canRedo
"
get
:
function
get
(
)
{
return
this
.
redoLevels
>
0
;
}
}
]
)
;
function
UndoManager
(
disposer
subtreeRoot
store
)
{
this
.
disposer
=
void
0
;
this
.
subtreeRoot
=
void
0
;
this
.
store
=
void
0
;
this
.
disposer
=
disposer
;
this
.
subtreeRoot
=
subtreeRoot
;
this
.
store
=
store
!
=
null
?
store
:
new
UndoStore
(
{
}
)
;
}
return
UndoManager
;
}
(
)
;
__decorate
(
[
mobx_esm
.
computed
]
UndoManager
.
prototype
"
undoQueue
"
null
)
;
__decorate
(
[
mobx_esm
.
computed
]
UndoManager
.
prototype
"
redoQueue
"
null
)
;
__decorate
(
[
mobx_esm
.
computed
]
UndoManager
.
prototype
"
undoLevels
"
null
)
;
__decorate
(
[
mobx_esm
.
computed
]
UndoManager
.
prototype
"
canUndo
"
null
)
;
__decorate
(
[
mobx_esm
.
action
]
UndoManager
.
prototype
"
clearUndo
"
null
)
;
__decorate
(
[
mobx_esm
.
computed
]
UndoManager
.
prototype
"
redoLevels
"
null
)
;
__decorate
(
[
mobx_esm
.
computed
]
UndoManager
.
prototype
"
canRedo
"
null
)
;
__decorate
(
[
mobx_esm
.
action
]
UndoManager
.
prototype
"
clearRedo
"
null
)
;
__decorate
(
[
mobx_esm
.
action
]
UndoManager
.
prototype
"
undo
"
null
)
;
__decorate
(
[
mobx_esm
.
action
]
UndoManager
.
prototype
"
redo
"
null
)
;
function
undoMiddleware
(
subtreeRoot
store
)
{
assertTweakedObject
(
subtreeRoot
"
subtreeRoot
"
)
;
var
patchRecorderSymbol
=
Symbol
(
"
patchRecorder
"
)
;
function
initPatchRecorder
(
ctx
)
{
ctx
.
rootContext
.
data
[
patchRecorderSymbol
]
=
{
recorder
:
patchRecorder
(
subtreeRoot
{
recording
:
false
filter
:
undoDisabledFilter
}
)
recorderStack
:
0
undoRootContext
:
ctx
}
;
}
function
getPatchRecorderData
(
ctx
)
{
return
ctx
.
rootContext
.
data
[
patchRecorderSymbol
]
;
}
var
manager
;
var
middlewareDisposer
=
actionTrackingMiddleware
(
subtreeRoot
{
onStart
:
function
onStart
(
ctx
)
{
if
(
!
getPatchRecorderData
(
ctx
)
)
{
initPatchRecorder
(
ctx
)
;
}
}
onResume
:
function
onResume
(
ctx
)
{
var
patchRecorderData
=
getPatchRecorderData
(
ctx
)
;
patchRecorderData
.
recorderStack
+
+
;
patchRecorderData
.
recorder
.
recording
=
patchRecorderData
.
recorderStack
>
0
;
}
onSuspend
:
function
onSuspend
(
ctx
)
{
var
patchRecorderData
=
getPatchRecorderData
(
ctx
)
;
patchRecorderData
.
recorderStack
-
-
;
patchRecorderData
.
recorder
.
recording
=
patchRecorderData
.
recorderStack
>
0
;
}
onFinish
:
function
onFinish
(
ctx
)
{
var
patchRecorderData
=
getPatchRecorderData
(
ctx
)
;
if
(
patchRecorderData
&
&
patchRecorderData
.
undoRootContext
=
=
=
ctx
)
{
var
_patchRecorder
=
patchRecorderData
.
recorder
;
if
(
_patchRecorder
.
events
.
length
>
0
)
{
var
patches
=
[
]
;
var
inversePatches
=
[
]
;
for
(
var
_iterator
=
_createForOfIteratorHelperLoose
(
_patchRecorder
.
events
)
_step
;
!
(
_step
=
_iterator
(
)
)
.
done
;
)
{
var
event
=
_step
.
value
;
patches
.
push
.
apply
(
patches
event
.
patches
)
;
inversePatches
.
push
.
apply
(
inversePatches
event
.
inversePatches
)
;
}
manager
.
store
.
_addUndo
(
{
targetPath
:
fastGetRootPath
(
ctx
.
target
)
.
path
actionName
:
ctx
.
actionName
patches
:
patches
inversePatches
:
inversePatches
}
)
;
}
_patchRecorder
.
dispose
(
)
;
}
}
}
)
;
manager
=
new
UndoManager
(
middlewareDisposer
subtreeRoot
store
)
;
return
manager
;
}
var
undoDisabled
=
false
;
var
undoDisabledFilter
=
function
undoDisabledFilter
(
)
{
return
!
undoDisabled
;
}
;
function
withoutUndo
(
fn
)
{
var
savedUndoDisabled
=
undoDisabled
;
undoDisabled
=
true
;
try
{
return
fn
(
)
;
}
finally
{
undoDisabled
=
savedUndoDisabled
;
}
}
function
getContextValue
(
contextValue
)
{
if
(
contextValue
.
type
=
=
=
"
value
"
)
{
return
contextValue
.
value
;
}
else
{
return
contextValue
.
value
.
get
(
)
;
}
}
var
ContextClass
=
function
(
)
{
var
_proto
=
ContextClass
.
prototype
;
_proto
.
getNodeAtom
=
function
getNodeAtom
(
node
)
{
var
atomPerNode
=
this
.
nodeAtom
.
get
(
node
)
;
if
(
!
atomPerNode
)
{
atomPerNode
=
(
0
mobx_esm
.
createAtom
)
(
"
contextValue
"
)
;
this
.
nodeAtom
.
set
(
node
atomPerNode
)
;
}
return
atomPerNode
;
}
;
_proto
.
fastGet
=
function
fastGet
(
node
)
{
this
.
getNodeAtom
(
node
)
.
reportObserved
(
)
;
var
obsForNode
=
this
.
nodeContextValue
.
get
(
node
)
;
if
(
obsForNode
)
{
return
getContextValue
(
obsForNode
)
;
}
var
parent
=
fastGetParent
(
node
)
;
if
(
!
parent
)
{
return
this
.
getDefault
(
)
;
}
return
this
.
fastGet
(
parent
)
;
}
;
_proto
.
get
=
function
get
(
node
)
{
assertTweakedObject
(
node
"
node
"
)
;
return
this
.
fastGet
(
node
)
;
}
;
_proto
.
fastGetProviderNode
=
function
fastGetProviderNode
(
node
)
{
this
.
getNodeAtom
(
node
)
.
reportObserved
(
)
;
var
obsForNode
=
this
.
nodeContextValue
.
get
(
node
)
;
if
(
obsForNode
)
{
return
node
;
}
var
parent
=
fastGetParent
(
node
)
;
if
(
!
parent
)
{
return
undefined
;
}
return
this
.
fastGetProviderNode
(
parent
)
;
}
;
_proto
.
getProviderNode
=
function
getProviderNode
(
node
)
{
assertTweakedObject
(
node
"
node
"
)
;
return
this
.
fastGetProviderNode
(
node
)
;
}
;
_proto
.
getDefault
=
function
getDefault
(
)
{
return
getContextValue
(
this
.
defaultContextValue
)
;
}
;
_proto
.
setDefault
=
function
setDefault
(
value
)
{
this
.
defaultContextValue
=
{
type
:
"
value
"
value
:
value
}
;
}
;
_proto
.
setDefaultComputed
=
function
setDefaultComputed
(
valueFn
)
{
this
.
defaultContextValue
=
{
type
:
"
computed
"
value
:
(
0
mobx_esm
.
computed
)
(
valueFn
)
}
;
}
;
_proto
.
set
=
function
set
(
node
value
)
{
assertTweakedObject
(
node
"
node
"
)
;
this
.
nodeContextValue
.
set
(
node
{
type
:
"
value
"
value
:
value
}
)
;
this
.
getNodeAtom
(
node
)
.
reportChanged
(
)
;
}
;
_proto
.
setComputed
=
function
setComputed
(
node
valueFn
)
{
assertTweakedObject
(
node
"
node
"
)
;
this
.
nodeContextValue
.
set
(
node
{
type
:
"
computed
"
value
:
(
0
mobx_esm
.
computed
)
(
valueFn
)
}
)
;
this
.
getNodeAtom
(
node
)
.
reportChanged
(
)
;
}
;
_proto
.
unset
=
function
unset
(
node
)
{
assertTweakedObject
(
node
"
node
"
)
;
this
.
nodeContextValue
[
"
delete
"
]
(
node
)
;
this
.
getNodeAtom
(
node
)
.
reportChanged
(
)
;
}
;
function
ContextClass
(
defaultValue
)
{
this
.
defaultContextValue
=
void
0
;
this
.
nodeContextValue
=
new
WeakMap
(
)
;
this
.
nodeAtom
=
new
WeakMap
(
)
;
if
(
getMobxVersion
(
)
>
=
6
)
{
(
0
mobx_esm
.
makeObservable
)
(
this
)
;
}
this
.
setDefault
(
defaultValue
)
;
}
return
ContextClass
;
}
(
)
;
__decorate
(
[
mobx_esm
.
observable
.
ref
]
ContextClass
.
prototype
"
defaultContextValue
"
void
0
)
;
__decorate
(
[
mobx_esm
.
action
]
ContextClass
.
prototype
"
setDefault
"
null
)
;
__decorate
(
[
mobx_esm
.
action
]
ContextClass
.
prototype
"
setDefaultComputed
"
null
)
;
__decorate
(
[
mobx_esm
.
action
]
ContextClass
.
prototype
"
set
"
null
)
;
__decorate
(
[
mobx_esm
.
action
]
ContextClass
.
prototype
"
setComputed
"
null
)
;
__decorate
(
[
mobx_esm
.
action
]
ContextClass
.
prototype
"
unset
"
null
)
;
function
createContext
(
defaultValue
)
{
return
new
ContextClass
(
defaultValue
)
;
}
function
extendFnModelFlowActions
(
fnModelObj
namespace
flowActions
)
{
for
(
var
_i
=
0
_Object
entries
=
Object
.
entries
(
flowActions
)
;
_i
<
_Object
entries
.
length
;
_i
+
+
)
{
var
_Object
entries
_i
=
_Object
entries
[
_i
]
name
=
_Object
entries
_i
[
0
]
fn
=
_Object
entries
_i
[
1
]
;
addActionToFnModel
(
fnModelObj
namespace
name
fn
true
)
;
}
return
fnModelObj
;
}
function
extendFnModelSetterActions
(
fnModelObj
namespace
setterActions
)
{
var
_loop
=
function
_loop
(
)
{
var
_Object
entries
_i
=
_Object
entries
[
_i
]
name
=
_Object
entries
_i
[
0
]
fieldName
=
_Object
entries
_i
[
1
]
;
var
fn
=
function
fn
(
value
)
{
this
[
fieldName
]
=
value
;
}
;
addActionToFnModel
(
fnModelObj
namespace
name
fn
false
)
;
}
;
for
(
var
_i
=
0
_Object
entries
=
Object
.
entries
(
setterActions
)
;
_i
<
_Object
entries
.
length
;
_i
+
+
)
{
_loop
(
)
;
}
return
fnModelObj
;
}
function
extendFnModelViews
(
fnModelObj
views
)
{
var
_loop
=
function
_loop
(
)
{
var
_Object
entries
_i
=
_Object
entries
[
_i
]
name
=
_Object
entries
_i
[
0
]
fnOrFnWithOptions
=
_Object
entries
_i
[
1
]
;
assertFnModelKeyNotInUse
(
fnModelObj
name
)
;
var
computedsPerObject
=
new
WeakMap
(
)
;
var
fn
=
void
0
;
var
equals
=
void
0
;
if
(
typeof
fnOrFnWithOptions
=
=
=
"
function
"
)
{
fn
=
fnOrFnWithOptions
;
}
else
{
fn
=
fnOrFnWithOptions
.
get
;
equals
=
fnOrFnWithOptions
.
equals
;
}
fnModelObj
[
name
]
=
function
(
target
)
{
var
computedFn
=
computedsPerObject
.
get
(
target
)
;
if
(
!
computedFn
)
{
computedFn
=
(
0
mobx_esm
.
computed
)
(
fn
{
name
:
name
context
:
target
equals
:
equals
}
)
;
computedsPerObject
.
set
(
target
computedFn
)
;
}
return
computedFn
.
get
(
)
;
}
;
}
;
for
(
var
_i
=
0
_Object
entries
=
Object
.
entries
(
views
)
;
_i
<
_Object
entries
.
length
;
_i
+
+
)
{
_loop
(
)
;
}
return
fnModelObj
;
}
function
fnModel
(
arg1
arg2
)
{
var
actualType
=
arguments
.
length
>
=
2
?
arg1
:
null
;
var
namespace
=
arguments
.
length
>
=
2
?
arg2
:
arg1
;
assertIsString
(
namespace
"
namespace
"
)
;
var
fnModelObj
=
{
create
:
actualType
?
fnModelCreateWithType
.
bind
(
undefined
actualType
)
:
fnModelCreateWithoutType
type
:
actualType
}
;
fnModelObj
.
views
=
extendFnModelViews
.
bind
(
undefined
fnModelObj
)
;
fnModelObj
.
actions
=
extendFnModelActions
.
bind
(
undefined
fnModelObj
namespace
)
;
fnModelObj
.
flowActions
=
extendFnModelFlowActions
.
bind
(
undefined
fnModelObj
namespace
)
;
fnModelObj
.
setterActions
=
extendFnModelSetterActions
.
bind
(
undefined
fnModelObj
namespace
)
;
return
fnModelObj
;
}
function
fnModelCreateWithoutType
(
data
)
{
return
toTreeNode
(
data
)
;
}
function
fnModelCreateWithType
(
actualType
data
)
{
if
(
isModelAutoTypeCheckingEnabled
(
)
)
{
var
errors
=
typeCheck
(
actualType
data
)
;
if
(
errors
)
{
errors
[
"
throw
"
]
(
data
)
;
}
}
return
toTreeNode
(
data
)
;
}
function
_splice
(
)
{
return
this
.
splice
.
apply
(
this
arguments
)
;
}
var
_fnArray
=
fnModel
(
"
mobx
-
keystone
/
fnArray
"
)
.
actions
(
{
set
:
function
set
1
(
index
value
)
{
(
0
mobx_esm
.
set
)
(
this
index
value
)
;
}
"
delete
"
:
function
_delete
(
index
)
{
return
(
0
mobx_esm
.
remove
)
(
this
"
"
+
index
)
;
}
setLength
:
function
setLength
(
length
)
{
this
.
length
=
length
;
}
concat
:
function
concat
(
)
{
return
this
.
concat
.
apply
(
this
arguments
)
;
}
copyWithin
:
function
copyWithin
(
target
start
end
)
{
return
this
.
copyWithin
(
target
start
end
)
;
}
fill
:
function
fill
(
value
start
end
)
{
return
this
.
fill
(
value
start
end
)
;
}
pop
:
function
pop
(
)
{
return
this
.
pop
(
)
;
}
push
:
function
push
(
)
{
return
this
.
push
.
apply
(
this
arguments
)
;
}
reverse
:
function
reverse
(
)
{
return
this
.
reverse
(
)
;
}
shift
:
function
shift
(
)
{
return
this
.
shift
(
)
;
}
slice
:
function
slice
(
start
end
)
{
return
this
.
slice
(
start
end
)
;
}
sort
:
function
sort
(
compareFn
)
{
return
this
.
sort
(
compareFn
)
;
}
splice
:
_splice
unshift
:
function
unshift
(
)
{
return
this
.
unshift
.
apply
(
this
arguments
)
;
}
}
)
;
var
fnArray
=
{
set
:
_fnArray
.
set
"
delete
"
:
_fnArray
[
"
delete
"
]
setLength
:
_fnArray
.
setLength
concat
:
_fnArray
.
concat
copyWithin
:
_fnArray
.
copyWithin
fill
:
_fnArray
.
fill
pop
:
_fnArray
.
pop
push
:
_fnArray
.
push
reverse
:
_fnArray
.
reverse
shift
:
_fnArray
.
shift
slice
:
_fnArray
.
slice
sort
:
_fnArray
.
sort
splice
:
_fnArray
.
splice
unshift
:
_fnArray
.
unshift
create
:
_fnArray
.
create
}
;
var
_fnObject
=
fnModel
(
"
mobx
-
keystone
/
fnObject
"
)
.
actions
(
{
set
:
function
set
1
(
key
value
)
{
(
0
mobx_esm
.
set
)
(
this
key
value
)
;
}
"
delete
"
:
function
_delete
(
key
)
{
return
(
0
mobx_esm
.
remove
)
(
this
key
)
;
}
call
:
function
call
(
methodName
)
{
for
(
var
_len
=
arguments
.
length
args
=
new
Array
(
_len
>
1
?
_len
-
1
:
0
)
_key
=
1
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
-
1
]
=
arguments
[
_key
]
;
}
return
this
[
methodName
]
.
apply
(
this
args
)
;
}
}
)
;
var
fnObject
=
{
set
:
_fnObject
.
set
"
delete
"
:
_fnObject
[
"
delete
"
]
call
:
_fnObject
.
call
create
:
_fnObject
.
create
}
;
var
Lock
=
function
(
)
{
function
Lock
(
)
{
this
.
_locked
=
true
;
}
var
_proto
=
Lock
.
prototype
;
_proto
.
unlockedFn
=
function
unlockedFn
(
fn
)
{
var
_this
=
this
;
var
innerFn
=
function
innerFn
(
)
{
var
oldLocked
=
_this
.
_locked
;
_this
.
_locked
=
false
;
try
{
return
fn
.
apply
(
void
0
arguments
)
;
}
finally
{
_this
.
_locked
=
oldLocked
;
}
}
;
return
innerFn
;
}
;
_proto
.
withUnlock
=
function
withUnlock
(
fn
)
{
var
oldLocked
=
this
.
_locked
;
this
.
_locked
=
false
;
try
{
return
fn
(
)
;
}
finally
{
this
.
_locked
=
oldLocked
;
}
}
;
_createClass
(
Lock
[
{
key
:
"
isLocked
"
get
:
function
get
(
)
{
return
this
.
_locked
;
}
}
]
)
;
return
Lock
;
}
(
)
;
function
tag
(
tagDataConstructor
)
{
var
map
=
new
WeakMap
(
)
;
return
{
"
for
"
:
function
_for
(
target
)
{
if
(
!
map
.
has
(
target
)
)
{
var
data
=
tagDataConstructor
(
target
)
;
map
.
set
(
target
data
)
;
return
data
;
}
else
{
return
map
.
get
(
target
)
;
}
}
}
;
}
var
observableMapBackedByObservableObject
=
(
0
mobx_esm
.
action
)
(
function
(
obj
)
{
if
(
inDevMode
(
)
)
{
if
(
!
(
0
mobx_esm
.
isObservableObject
)
(
obj
)
)
{
throw
failure
(
"
assertion
failed
:
expected
an
observable
object
"
)
;
}
}
var
map
=
mobx_esm
.
observable
.
map
(
)
;
map
.
dataObject
=
obj
;
var
keys
=
Object
.
keys
(
obj
)
;
for
(
var
i
=
0
;
i
<
keys
.
length
;
i
+
+
)
{
var
k
=
keys
[
i
]
;
map
.
set
(
k
obj
[
k
]
)
;
}
var
mutationLock
=
new
Lock
(
)
;
(
0
mobx_esm
.
observe
)
(
obj
(
0
mobx_esm
.
action
)
(
mutationLock
.
unlockedFn
(
function
(
change
)
{
switch
(
change
.
type
)
{
case
"
add
"
:
case
"
update
"
:
{
map
.
set
(
change
.
name
change
.
newValue
)
;
break
;
}
case
"
remove
"
:
{
map
[
"
delete
"
]
(
change
.
name
)
;
break
;
}
}
}
)
)
)
;
(
0
mobx_esm
.
intercept
)
(
map
(
0
mobx_esm
.
action
)
(
function
(
change
)
{
if
(
!
mutationLock
.
isLocked
)
{
return
null
;
}
switch
(
change
.
type
)
{
case
"
add
"
:
case
"
update
"
:
{
(
0
mobx_esm
.
set
)
(
obj
change
.
name
change
.
newValue
)
;
break
;
}
case
"
delete
"
:
{
(
0
mobx_esm
.
remove
)
(
obj
change
.
name
)
;
break
;
}
}
return
change
;
}
)
)
;
return
map
;
}
)
;
var
observableMapBackedByObservableArray
=
(
0
mobx_esm
.
action
)
(
function
(
array
)
{
if
(
inDevMode
(
)
)
{
if
(
!
(
0
mobx_esm
.
isObservableArray
)
(
array
)
)
{
throw
failure
(
"
assertion
failed
:
expected
an
observable
array
"
)
;
}
}
var
map
=
mobx_esm
.
observable
.
map
(
array
)
;
map
.
dataObject
=
array
;
if
(
map
.
size
!
=
=
array
.
length
)
{
throw
failure
(
"
arrays
backing
a
map
cannot
contain
duplicate
keys
"
)
;
}
var
mutationLock
=
new
Lock
(
)
;
(
0
mobx_esm
.
observe
)
(
array
(
0
mobx_esm
.
action
)
(
mutationLock
.
unlockedFn
(
function
(
change
)
{
switch
(
change
.
type
)
{
case
"
splice
"
:
{
{
var
removed
=
change
.
removed
;
for
(
var
i
=
0
;
i
<
removed
.
length
;
i
+
+
)
{
map
[
"
delete
"
]
(
removed
[
i
]
[
0
]
)
;
}
}
{
var
added
=
change
.
added
;
for
(
var
_i
=
0
;
_i
<
added
.
length
;
_i
+
+
)
{
map
.
set
(
added
[
_i
]
[
0
]
added
[
_i
]
[
1
]
)
;
}
}
break
;
}
case
"
update
"
:
{
map
[
"
delete
"
]
(
change
.
oldValue
[
0
]
)
;
map
.
set
(
change
.
newValue
[
0
]
change
.
newValue
[
1
]
)
;
break
;
}
}
}
)
)
)
;
(
0
mobx_esm
.
intercept
)
(
map
(
0
mobx_esm
.
action
)
(
function
(
change
)
{
if
(
!
mutationLock
.
isLocked
)
{
return
null
;
}
switch
(
change
.
type
)
{
case
"
update
"
:
{
var
i
=
array
.
findIndex
(
function
(
i
)
{
return
i
[
0
]
=
=
=
change
.
name
;
}
)
;
array
[
i
]
=
[
change
.
name
change
.
newValue
]
;
break
;
}
case
"
add
"
:
{
array
.
push
(
[
change
.
name
change
.
newValue
]
)
;
break
;
}
case
"
delete
"
:
{
var
_i2
=
array
.
findIndex
(
function
(
i
)
{
return
i
[
0
]
=
=
=
change
.
name
;
}
)
;
if
(
_i2
>
=
0
)
{
array
.
splice
(
_i2
1
)
;
}
break
;
}
}
return
change
;
}
)
)
;
return
map
;
}
)
;
var
asMapTag
=
tag
(
function
(
objOrArray
)
{
if
(
isArray
(
objOrArray
)
)
{
assertIsObservableArray
(
objOrArray
"
objOrArray
"
)
;
return
observableMapBackedByObservableArray
(
objOrArray
)
;
}
else
{
assertIsObservableObject
(
objOrArray
"
objOrArray
"
)
;
return
observableMapBackedByObservableObject
(
objOrArray
)
;
}
}
)
;
function
asMap
(
objOrArray
)
{
return
asMapTag
[
"
for
"
]
(
objOrArray
)
;
}
function
mapToObject
(
map
)
{
assertIsMap
(
map
"
map
"
)
;
var
dataObject
=
map
.
dataObject
;
if
(
dataObject
&
&
!
isArray
(
dataObject
)
)
{
return
dataObject
;
}
var
obj
=
{
}
;
for
(
var
_iterator
=
_createForOfIteratorHelperLoose
(
map
.
keys
(
)
)
_step
;
!
(
_step
=
_iterator
(
)
)
.
done
;
)
{
var
k
=
_step
.
value
;
obj
[
k
]
=
map
.
get
(
k
)
;
}
return
obj
;
}
function
mapToArray
(
map
)
{
assertIsMap
(
map
"
map
"
)
;
var
dataObject
=
map
.
dataObject
;
if
(
dataObject
&
&
isArray
(
dataObject
)
)
{
return
dataObject
;
}
var
arr
=
[
]
;
for
(
var
_iterator2
=
_createForOfIteratorHelperLoose
(
map
.
keys
(
)
)
_step2
;
!
(
_step2
=
_iterator2
(
)
)
.
done
;
)
{
var
k
=
_step2
.
value
;
arr
.
push
(
[
k
map
.
get
(
k
)
]
)
;
}
return
arr
;
}
var
arrayAsMapInnerTransform
=
{
propToData
:
function
propToData
(
arr
)
{
return
isArray
(
arr
)
?
asMap
(
arr
)
:
arr
;
}
dataToProp
:
function
dataToProp
(
newMap
)
{
if
(
!
isMap
(
newMap
)
)
{
return
newMap
;
}
return
mapToArray
(
newMap
)
;
}
}
;
function
prop_mapArray
(
def
)
{
return
transformedProp
(
prop
(
def
)
arrayAsMapInnerTransform
true
)
;
}
function
tProp_mapArray
(
typeOrDefaultValue
def
)
{
return
transformedProp
(
tProp
(
typeOrDefaultValue
def
)
arrayAsMapInnerTransform
true
)
;
}
var
observableSetBackedByObservableArray
=
(
0
mobx_esm
.
action
)
(
function
(
array
)
{
if
(
inDevMode
(
)
)
{
if
(
!
(
0
mobx_esm
.
isObservableArray
)
(
array
)
)
{
throw
failure
(
"
assertion
failed
:
expected
an
observable
array
"
)
;
}
}
var
set
=
mobx_esm
.
observable
.
set
(
array
)
;
set
.
dataObject
=
array
;
if
(
set
.
size
!
=
=
array
.
length
)
{
throw
failure
(
"
arrays
backing
a
set
cannot
contain
duplicate
values
"
)
;
}
var
mutationLock
=
new
Lock
(
)
;
(
0
mobx_esm
.
observe
)
(
array
(
0
mobx_esm
.
action
)
(
mutationLock
.
unlockedFn
(
function
(
change
)
{
switch
(
change
.
type
)
{
case
"
splice
"
:
{
{
var
removed
=
change
.
removed
;
for
(
var
i
=
0
;
i
<
removed
.
length
;
i
+
+
)
{
set
[
"
delete
"
]
(
removed
[
i
]
)
;
}
}
{
var
added
=
change
.
added
;
for
(
var
_i
=
0
;
_i
<
added
.
length
;
_i
+
+
)
{
set
.
add
(
added
[
_i
]
)
;
}
}
break
;
}
case
"
update
"
:
{
set
[
"
delete
"
]
(
change
.
oldValue
)
;
set
.
add
(
change
.
newValue
)
;
break
;
}
}
}
)
)
)
;
(
0
mobx_esm
.
intercept
)
(
set
(
0
mobx_esm
.
action
)
(
function
(
change
)
{
if
(
!
mutationLock
.
isLocked
)
{
return
null
;
}
switch
(
change
.
type
)
{
case
"
add
"
:
{
array
.
push
(
change
.
newValue
)
;
break
;
}
case
"
delete
"
:
{
var
i
=
array
.
indexOf
(
change
.
oldValue
)
;
if
(
i
>
=
0
)
{
array
.
splice
(
i
1
)
;
}
break
;
}
}
return
change
;
}
)
)
;
return
set
;
}
)
;
var
asSetTag
=
tag
(
function
(
array
)
{
assertIsObservableArray
(
array
"
array
"
)
;
return
observableSetBackedByObservableArray
(
array
)
;
}
)
;
function
asSet
(
array
)
{
return
asSetTag
[
"
for
"
]
(
array
)
;
}
function
setToArray
(
set
)
{
assertIsSet
(
set
"
set
"
)
;
var
dataObject
=
set
.
dataObject
;
if
(
dataObject
)
{
return
dataObject
;
}
return
Array
.
from
(
set
.
values
(
)
)
;
}
var
arrayAsSetInnerTransform
=
{
propToData
:
function
propToData
(
arr
)
{
return
isArray
(
arr
)
?
asSet
(
arr
)
:
arr
;
}
dataToProp
:
function
dataToProp
(
newSet
)
{
return
isSet
(
newSet
)
?
setToArray
(
newSet
)
:
newSet
;
}
}
;
function
prop_setArray
(
def
)
{
return
transformedProp
(
prop
(
def
)
arrayAsSetInnerTransform
true
)
;
}
function
tProp_setArray
(
typeOrDefaultValue
def
)
{
return
transformedProp
(
tProp
(
typeOrDefaultValue
def
)
arrayAsSetInnerTransform
true
)
;
}
var
objectAsMapInnerTransform
=
{
propToData
:
function
propToData
(
obj
)
{
return
isObject
(
obj
)
?
asMap
(
obj
)
:
obj
;
}
dataToProp
:
function
dataToProp
(
newMap
)
{
if
(
!
isMap
(
newMap
)
)
{
return
newMap
;
}
return
mapToObject
(
newMap
)
;
}
}
;
function
prop_mapObject
(
def
)
{
return
transformedProp
(
prop
(
def
)
objectAsMapInnerTransform
true
)
;
}
function
tProp_mapObject
(
typeOrDefaultValue
def
)
{
return
transformedProp
(
tProp
(
typeOrDefaultValue
def
)
objectAsMapInnerTransform
true
)
;
}
function
immutableDate
(
value
)
{
return
new
InternalImmutableDate
(
value
)
;
}
var
errMessage
=
"
this
Date
object
is
immutable
"
;
var
InternalImmutableDate
=
function
(
_Date
)
{
_inheritsLoose
(
InternalImmutableDate
_Date
)
;
function
InternalImmutableDate
(
)
{
return
_Date
.
apply
(
this
arguments
)
|
|
this
;
}
var
_proto
=
InternalImmutableDate
.
prototype
;
_proto
.
setTime
=
function
setTime
(
)
{
throw
failure
(
errMessage
)
;
}
;
_proto
.
setMilliseconds
=
function
setMilliseconds
(
)
{
throw
failure
(
errMessage
)
;
}
;
_proto
.
setUTCMilliseconds
=
function
setUTCMilliseconds
(
)
{
throw
failure
(
errMessage
)
;
}
;
_proto
.
setSeconds
=
function
setSeconds
(
)
{
throw
failure
(
errMessage
)
;
}
;
_proto
.
setUTCSeconds
=
function
setUTCSeconds
(
)
{
throw
failure
(
errMessage
)
;
}
;
_proto
.
setMinutes
=
function
setMinutes
(
)
{
throw
failure
(
errMessage
)
;
}
;
_proto
.
setUTCMinutes
=
function
setUTCMinutes
(
)
{
throw
failure
(
errMessage
)
;
}
;
_proto
.
setHours
=
function
setHours
(
)
{
throw
failure
(
errMessage
)
;
}
;
_proto
.
setUTCHours
=
function
setUTCHours
(
)
{
throw
failure
(
errMessage
)
;
}
;
_proto
.
setDate
=
function
setDate
(
)
{
throw
failure
(
errMessage
)
;
}
;
_proto
.
setUTCDate
=
function
setUTCDate
(
)
{
throw
failure
(
errMessage
)
;
}
;
_proto
.
setMonth
=
function
setMonth
(
)
{
throw
failure
(
errMessage
)
;
}
;
_proto
.
setUTCMonth
=
function
setUTCMonth
(
)
{
throw
failure
(
errMessage
)
;
}
;
_proto
.
setFullYear
=
function
setFullYear
(
)
{
throw
failure
(
errMessage
)
;
}
;
_proto
.
setUTCFullYear
=
function
setUTCFullYear
(
)
{
throw
failure
(
errMessage
)
;
}
;
return
InternalImmutableDate
;
}
(
_wrapNativeSuper
(
Date
)
)
;
var
stringAsDate
=
propTransform
(
{
propToData
:
function
propToData
(
prop
)
{
if
(
typeof
prop
!
=
=
"
string
"
)
{
return
prop
;
}
return
immutableDate
(
prop
)
;
}
dataToProp
:
function
dataToProp
(
date
)
{
return
date
instanceof
Date
?
date
.
toJSON
(
)
:
date
;
}
}
)
;
function
prop_dateString
(
def
)
{
return
transformedProp
(
prop
(
def
)
stringAsDate
true
)
;
}
function
tProp_dateString
(
typeOrDefaultValue
def
)
{
return
transformedProp
(
tProp
(
typeOrDefaultValue
def
)
stringAsDate
true
)
;
}
var
timestampAsDate
=
propTransform
(
{
propToData
:
function
propToData
(
prop
)
{
if
(
typeof
prop
!
=
=
"
number
"
)
{
return
prop
;
}
return
immutableDate
(
prop
)
;
}
dataToProp
:
function
dataToProp
(
date
)
{
return
date
instanceof
Date
?
date
.
getTime
(
)
:
date
;
}
}
)
;
function
prop_dateTimestamp
(
def
)
{
return
transformedProp
(
prop
(
def
)
timestampAsDate
true
)
;
}
function
tProp_dateTimestamp
(
typeOrDefaultValue
def
)
{
return
transformedProp
(
tProp
(
typeOrDefaultValue
def
)
timestampAsDate
true
)
;
}
function
connectReduxDevTools
(
remotedevPackage
remotedevConnection
target
options
)
{
assertTweakedObject
(
target
"
target
"
)
;
var
opts
=
_extends
(
{
logArgsNearName
:
true
}
options
)
;
var
handlingMonitorAction
=
0
;
remotedevConnection
.
subscribe
(
function
(
message
)
{
if
(
message
.
type
=
=
=
"
DISPATCH
"
)
{
handleMonitorActions
(
remotedevConnection
target
message
)
;
}
}
)
;
var
initialState
=
getSnapshot
(
target
)
;
remotedevConnection
.
init
(
initialState
)
;
var
currentActionId
=
0
;
var
actionIdSymbol
=
Symbol
(
"
actionId
"
)
;
actionTrackingMiddleware
(
target
{
onStart
:
function
onStart
(
ctx
)
{
ctx
.
data
[
actionIdSymbol
]
=
currentActionId
+
+
;
}
onResume
:
function
onResume
(
ctx
)
{
if
(
ctx
.
parentContext
)
{
log
(
ctx
.
parentContext
undefined
)
;
}
log
(
ctx
undefined
)
;
}
onSuspend
:
function
onSuspend
(
ctx
)
{
log
(
ctx
undefined
)
;
}
onFinish
:
function
onFinish
(
ctx
ret
)
{
log
(
ctx
ret
.
result
)
;
}
}
)
;
function
handleMonitorActions
(
remotedev2
target2
message
)
{
try
{
handlingMonitorAction
+
+
;
switch
(
message
.
payload
.
type
)
{
case
"
RESET
"
:
applySnapshot
(
target2
initialState
)
;
return
remotedev2
.
init
(
initialState
)
;
case
"
COMMIT
"
:
return
remotedev2
.
init
(
getSnapshot
(
target2
)
)
;
case
"
ROLLBACK
"
:
return
remotedev2
.
init
(
remotedevPackage
.
extractState
(
message
)
)
;
case
"
JUMP_TO_STATE
"
:
case
"
JUMP_TO_ACTION
"
:
applySnapshot
(
target2
remotedevPackage
.
extractState
(
message
)
)
;
return
;
case
"
IMPORT_STATE
"
:
var
nextLiftedState
=
message
.
payload
.
nextLiftedState
;
var
computedStates
=
nextLiftedState
.
computedStates
;
applySnapshot
(
target2
computedStates
[
computedStates
.
length
-
1
]
.
state
)
;
remotedev2
.
send
(
null
nextLiftedState
)
;
return
;
default
:
}
}
finally
{
handlingMonitorAction
-
-
;
}
}
var
lastLoggedSnapshot
=
initialState
;
function
log
(
ctx
result
)
{
if
(
handlingMonitorAction
)
{
return
;
}
var
sn
=
getSnapshot
(
target
)
;
if
(
sn
=
=
=
lastLoggedSnapshot
&
&
result
!
=
=
ActionTrackingResult
.
Throw
)
{
return
;
}
lastLoggedSnapshot
=
sn
;
var
rootPath
=
fastGetRootPath
(
ctx
.
target
)
;
var
name
=
getActionContextNameAndTypePath
(
ctx
rootPath
result
)
;
var
copy
=
{
type
:
name
path
:
rootPath
.
path
args
:
ctx
.
args
}
;
remotedevConnection
.
send
(
copy
sn
)
;
}
function
getActionContextNameAndTypePath
(
ctx
rootPath
result
)
{
var
pathStr
=
"
[
/
"
+
rootPath
.
path
.
join
(
"
/
"
)
+
"
]
"
;
var
name
=
pathStr
+
ctx
.
actionName
;
if
(
opts
.
logArgsNearName
)
{
var
args
=
ctx
.
args
.
map
(
function
(
a
)
{
try
{
return
JSON
.
stringify
(
a
)
;
}
catch
(
_unused
)
{
return
"
*
*
unserializable
*
*
"
;
}
}
)
.
join
(
"
"
)
;
if
(
args
.
length
>
64
)
{
args
=
args
.
slice
(
0
64
)
+
"
.
.
.
"
;
}
name
+
=
"
(
"
+
args
+
"
)
"
;
}
var
actionId
=
ctx
.
data
[
actionIdSymbol
]
;
name
+
=
"
(
id
"
+
(
actionId
!
=
=
undefined
?
actionId
:
"
?
"
)
;
if
(
ctx
.
type
=
=
=
ActionContextActionType
.
Async
)
{
name
+
=
"
async
"
;
}
name
+
=
"
)
"
;
if
(
result
=
=
=
ActionTrackingResult
.
Throw
)
{
name
+
=
"
-
error
thrown
-
"
;
}
if
(
ctx
.
parentContext
)
{
var
parentName
=
getActionContextNameAndTypePath
(
ctx
.
parentContext
fastGetRootPath
(
ctx
.
parentContext
.
target
)
undefined
)
;
if
(
parentName
)
{
name
=
parentName
+
"
>
>
>
"
+
name
;
}
}
return
name
;
}
}
function
onSnapshot
(
node
listener
)
{
assertTweakedObject
(
node
"
node
"
)
;
var
currentSnapshot
=
getSnapshot
(
node
)
;
return
(
0
mobx_esm
.
reaction
)
(
function
(
)
{
return
getSnapshot
(
node
)
;
}
function
(
newSnapshot
)
{
var
prevSn
=
currentSnapshot
;
currentSnapshot
=
newSnapshot
;
listener
(
newSnapshot
prevSn
)
;
}
)
;
}
var
reduxActionType
=
"
applyAction
"
;
function
actionCallToReduxAction
(
actionCall
)
{
return
{
type
:
reduxActionType
payload
:
actionCall
}
;
}
function
asReduxStore
(
target
)
{
assertTweakedObject
(
target
"
target
"
)
;
var
defaultDispatch
=
function
defaultDispatch
(
action
)
{
if
(
action
.
type
!
=
=
reduxActionType
)
{
throw
failure
(
"
action
type
was
expected
to
be
'
"
+
reduxActionType
+
"
'
but
it
was
'
"
+
action
.
type
+
"
'
"
)
;
}
applyAction
(
target
action
.
payload
)
;
return
action
;
}
;
var
store
=
{
getState
:
function
getState
(
)
{
return
getSnapshot
(
target
)
;
}
dispatch
:
function
dispatch
(
action
)
{
return
runMiddlewares
(
action
runners
defaultDispatch
)
;
}
subscribe
:
function
subscribe
(
listener
)
{
return
onSnapshot
(
target
listener
)
;
}
}
;
for
(
var
_len
=
arguments
.
length
middlewares
=
new
Array
(
_len
>
1
?
_len
-
1
:
0
)
_key
=
1
;
_key
<
_len
;
_key
+
+
)
{
middlewares
[
_key
-
1
]
=
arguments
[
_key
]
;
}
var
runners
=
middlewares
.
map
(
function
(
mw
)
{
return
mw
(
store
)
;
}
)
;
return
store
;
}
function
runMiddlewares
(
initialAction
runners
next
)
{
var
i
=
0
;
function
runNextMiddleware
(
action
)
{
var
runner
=
runners
[
i
]
;
i
+
+
;
if
(
runner
)
{
return
runner
(
runNextMiddleware
)
(
action
)
;
}
else
{
return
next
(
action
)
;
}
}
return
runNextMiddleware
(
initialAction
)
;
}
var
Ref
=
function
(
_Model
)
{
_inheritsLoose
(
Ref
_Model
)
;
function
Ref
(
)
{
return
_Model
.
apply
(
this
arguments
)
|
|
this
;
}
_createClass
(
Ref
[
{
key
:
"
maybeCurrent
"
get
:
function
get
(
)
{
return
this
.
resolve
(
)
;
}
}
{
key
:
"
isValid
"
get
:
function
get
(
)
{
return
!
!
this
.
maybeCurrent
;
}
}
{
key
:
"
current
"
get
:
function
get
(
)
{
var
current
=
this
.
maybeCurrent
;
if
(
!
current
)
{
throw
failure
(
"
a
reference
of
type
'
"
+
this
[
modelTypeKey
]
+
"
'
could
not
resolve
an
object
with
id
'
"
+
this
.
id
+
"
'
"
)
;
}
return
current
;
}
}
]
)
;
return
Ref
;
}
(
Model
(
{
id
:
tProp
(
typesString
)
}
)
)
;
__decorate
(
[
mobx_esm
.
computed
]
Ref
.
prototype
"
maybeCurrent
"
null
)
;
__decorate
(
[
mobx_esm
.
computed
]
Ref
.
prototype
"
isValid
"
null
)
;
__decorate
(
[
mobx_esm
.
computed
]
Ref
.
prototype
"
current
"
null
)
;
function
isRefOfType
(
ref
refType
)
{
return
ref
instanceof
refType
.
refClass
;
}
var
objectBackRefs
=
new
WeakMap
(
)
;
function
internalCustomRef
(
modelTypeId
resolverGen
getId
onResolvedValueChange
)
{
var
_temp
;
var
CustomRef
=
(
_temp
=
function
(
_Ref
)
{
_inheritsLoose
(
CustomRef
_Ref
)
;
function
CustomRef
(
)
{
var
_this
;
for
(
var
_len
=
arguments
.
length
args
=
new
Array
(
_len
)
_key
=
0
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
]
=
arguments
[
_key
]
;
}
_this
=
_Ref
.
call
.
apply
(
_Ref
[
this
]
.
concat
(
args
)
)
|
|
this
;
_this
.
resolver
=
void
0
;
return
_this
;
}
var
_proto
=
CustomRef
.
prototype
;
_proto
.
resolve
=
function
resolve
(
)
{
if
(
!
this
.
resolver
)
{
this
.
resolver
=
resolverGen
(
this
)
;
}
return
this
.
resolver
(
this
)
;
}
;
_proto
.
onInit
=
function
onInit
(
)
{
var
_this2
=
this
;
var
savedOldTarget
;
var
savedFirstTime
=
true
;
(
0
mobx_esm
.
reaction
)
(
function
(
)
{
return
_this2
.
maybeCurrent
;
}
function
(
newTarget
)
{
var
oldTarget
=
savedOldTarget
;
var
firstTime
=
savedFirstTime
;
savedOldTarget
=
newTarget
;
savedFirstTime
=
false
;
updateBackRefs
(
_this2
fn
newTarget
oldTarget
)
;
if
(
!
firstTime
&
&
onResolvedValueChange
&
&
newTarget
!
=
=
oldTarget
)
{
onResolvedValueChange
(
_this2
newTarget
oldTarget
)
;
}
}
{
fireImmediately
:
true
}
)
;
}
;
return
CustomRef
;
}
(
Ref
)
_temp
)
;
CustomRef
=
__decorate
(
[
model
(
modelTypeId
)
]
CustomRef
)
;
var
fn
=
function
fn
(
target
)
{
var
id
;
if
(
typeof
target
=
=
=
"
string
"
)
{
id
=
target
;
}
else
{
assertIsObject
(
target
"
target
"
)
;
id
=
getId
(
target
)
;
}
if
(
typeof
id
!
=
=
"
string
"
)
{
throw
failure
(
"
ref
target
object
must
have
an
id
of
string
type
"
)
;
}
var
ref
=
new
CustomRef
(
{
id
:
id
}
)
;
return
ref
;
}
;
fn
.
refClass
=
CustomRef
;
return
fn
;
}
function
getModelRefId
(
target
)
{
if
(
isModel
(
target
)
&
&
target
.
getRefId
)
{
var
id
=
target
.
getRefId
(
)
;
if
(
typeof
id
!
=
=
"
string
"
)
{
throw
failure
(
"
'
getRefId
(
)
'
must
return
a
string
when
present
"
)
;
}
return
id
;
}
return
undefined
;
}
function
getBackRefs
(
target
refType
)
{
var
backRefs
=
objectBackRefs
.
get
(
target
)
;
if
(
!
backRefs
)
{
backRefs
=
{
all
:
mobx_esm
.
observable
.
set
(
undefined
{
deep
:
false
}
)
byType
:
new
WeakMap
(
)
}
;
objectBackRefs
.
set
(
target
backRefs
)
;
}
if
(
!
refType
)
{
return
backRefs
.
all
;
}
else
{
var
byType
=
backRefs
.
byType
.
get
(
refType
)
;
if
(
!
byType
)
{
byType
=
mobx_esm
.
observable
.
set
(
undefined
{
deep
:
false
}
)
;
backRefs
.
byType
.
set
(
refType
byType
)
;
}
return
byType
;
}
}
function
getRefsResolvingTo
(
target
refType
)
{
assertTweakedObject
(
target
"
target
"
)
;
var
refTypeObject
=
refType
;
return
getBackRefs
(
target
refTypeObject
)
;
}
function
updateBackRefs
(
ref
refClass
newTarget
oldTarget
)
{
if
(
newTarget
=
=
=
oldTarget
)
{
return
;
}
if
(
oldTarget
)
{
getBackRefs
(
oldTarget
)
[
"
delete
"
]
(
ref
)
;
getBackRefs
(
oldTarget
refClass
)
[
"
delete
"
]
(
ref
)
;
}
if
(
newTarget
)
{
getBackRefs
(
newTarget
)
.
add
(
ref
)
;
getBackRefs
(
newTarget
refClass
)
.
add
(
ref
)
;
}
}
var
customRef
=
(
0
mobx_esm
.
action
)
(
"
customRef
"
function
(
modelTypeId
options
)
{
var
_options
getId
;
var
getId
=
(
_options
getId
=
options
.
getId
)
!
=
null
?
_options
getId
:
getModelRefId
;
return
internalCustomRef
(
modelTypeId
function
(
)
{
return
options
.
resolve
;
}
getId
options
.
onResolvedValueChange
)
;
}
)
;
var
computedIdTrees
=
new
WeakMap
(
)
;
var
rootRef
=
(
0
mobx_esm
.
action
)
(
"
rootRef
"
function
(
modelTypeId
options
)
{
var
_options
getId
;
var
getId
=
(
_options
getId
=
options
=
=
null
?
void
0
:
options
.
getId
)
!
=
null
?
_options
getId
:
getModelRefId
;
var
onResolvedValueChange
=
options
=
=
null
?
void
0
:
options
.
onResolvedValueChange
;
var
computedIdTree
=
computedIdTrees
.
get
(
getId
)
;
if
(
!
computedIdTree
)
{
computedIdTree
=
computedWalkTreeAggregate
(
getId
)
;
computedIdTrees
.
set
(
getId
computedIdTree
)
;
}
var
resolverGen
=
function
resolverGen
(
ref
)
{
var
cachedTarget
;
return
function
(
)
{
var
refRoot
=
fastGetRoot
(
ref
)
;
if
(
isRefRootCachedTargetOk
(
ref
refRoot
cachedTarget
getId
)
)
{
return
cachedTarget
;
}
var
idMap
=
computedIdTree
.
walk
(
refRoot
)
;
var
newTarget
=
idMap
?
idMap
.
get
(
ref
.
id
)
:
undefined
;
if
(
newTarget
)
{
cachedTarget
=
newTarget
;
}
return
newTarget
;
}
;
}
;
return
internalCustomRef
(
modelTypeId
resolverGen
getId
onResolvedValueChange
)
;
}
)
;
function
isRefRootCachedTargetOk
(
ref
refRoot
cachedTarget
getId
)
{
if
(
!
cachedTarget
)
return
false
;
if
(
ref
.
id
!
=
=
getId
(
cachedTarget
)
)
return
false
;
if
(
refRoot
!
=
=
fastGetRoot
(
cachedTarget
)
)
return
false
;
return
true
;
}
function
clone
(
node
options
)
{
assertTweakedObject
(
node
"
node
"
)
;
var
opts
=
_extends
(
{
generateNewIds
:
true
}
options
)
;
var
sn
=
getSnapshot
(
node
)
;
return
fromSnapshot
(
sn
opts
)
;
}
function
deepEquals
(
a
b
)
{
if
(
a
=
=
=
b
)
{
return
true
;
}
if
(
isTreeNode
(
a
)
)
{
a
=
getSnapshot
(
a
)
;
}
else
if
(
(
0
mobx_esm
.
isObservable
)
(
a
)
)
{
a
=
(
0
mobx_esm
.
toJS
)
(
a
toJSOptions
)
;
}
if
(
isTreeNode
(
b
)
)
{
b
=
getSnapshot
(
b
)
;
}
else
if
(
(
0
mobx_esm
.
isObservable
)
(
b
)
)
{
b
=
(
0
mobx_esm
.
toJS
)
(
b
toJSOptions
)
;
}
return
es6_default
(
)
(
a
b
)
;
}
var
toJSOptions
=
getMobxVersion
(
)
>
=
6
?
undefined
:
{
exportMapsAsObjects
:
false
recurseEverything
:
false
}
;
var
Draft
=
function
(
)
{
var
_proto
=
Draft
.
prototype
;
_proto
.
commit
=
function
commit
(
)
{
applySnapshot
(
this
.
originalData
getSnapshot
(
this
.
data
)
)
;
}
;
_proto
.
commitByPath
=
function
commitByPath
(
path
)
{
var
draftTarget
=
resolvePath
(
this
.
data
path
)
;
if
(
!
draftTarget
.
resolved
)
{
throw
failure
(
"
path
"
+
JSON
.
stringify
(
path
)
+
"
could
not
be
resolved
in
draft
object
"
)
;
}
var
draftPathIds
=
pathToTargetPathIdsIgnoringLast
(
this
.
data
path
)
;
var
originalTarget
=
resolvePathCheckingIds
(
this
.
originalData
path
draftPathIds
)
;
if
(
!
originalTarget
.
resolved
)
{
throw
failure
(
"
path
"
+
JSON
.
stringify
(
path
)
+
"
could
not
be
resolved
in
original
object
"
)
;
}
applyPatches
(
this
.
originalData
[
{
path
:
path
op
:
"
replace
"
value
:
getSnapshot
(
draftTarget
.
value
)
}
]
)
;
}
;
_proto
.
reset
=
function
reset
(
)
{
applySnapshot
(
this
.
data
this
.
originalSnapshot
)
;
}
;
_proto
.
resetByPath
=
function
resetByPath
(
path
)
{
var
originalTarget
=
resolvePath
(
this
.
originalData
path
)
;
if
(
!
originalTarget
.
resolved
)
{
throw
failure
(
"
path
"
+
JSON
.
stringify
(
path
)
+
"
could
not
be
resolved
in
original
object
"
)
;
}
var
originalPathIds
=
pathToTargetPathIdsIgnoringLast
(
this
.
originalData
path
)
;
var
draftTarget
=
resolvePathCheckingIds
(
this
.
data
path
originalPathIds
)
;
if
(
!
draftTarget
.
resolved
)
{
throw
failure
(
"
path
"
+
JSON
.
stringify
(
path
)
+
"
could
not
be
resolved
in
draft
object
"
)
;
}
applyPatches
(
this
.
data
[
{
path
:
path
op
:
"
replace
"
value
:
getSnapshot
(
originalTarget
.
value
)
}
]
)
;
}
;
_proto
.
isDirtyByPath
=
function
isDirtyByPath
(
path
)
{
var
draftTarget
=
resolvePath
(
this
.
data
path
)
;
if
(
!
draftTarget
.
resolved
)
{
throw
failure
(
"
path
"
+
JSON
.
stringify
(
path
)
+
"
could
not
be
resolved
in
draft
object
"
)
;
}
var
draftPathIds
=
pathToTargetPathIdsIgnoringLast
(
this
.
data
path
)
;
var
originalTarget
=
resolvePathCheckingIds
(
this
.
originalData
path
draftPathIds
)
;
if
(
!
originalTarget
.
resolved
)
{
return
true
;
}
return
!
deepEquals
(
draftTarget
.
value
originalTarget
.
value
)
;
}
;
_createClass
(
Draft
[
{
key
:
"
isDirty
"
get
:
function
get
(
)
{
return
!
deepEquals
(
getSnapshot
(
this
.
data
)
this
.
originalSnapshot
)
;
}
}
{
key
:
"
originalSnapshot
"
get
:
function
get
(
)
{
return
getSnapshot
(
this
.
originalData
)
;
}
}
]
)
;
function
Draft
(
original
)
{
this
.
data
=
void
0
;
this
.
originalData
=
void
0
;
assertTweakedObject
(
original
"
original
"
)
;
this
.
originalData
=
original
;
this
.
data
=
fromSnapshot
(
this
.
originalSnapshot
{
generateNewIds
:
false
}
)
;
}
return
Draft
;
}
(
)
;
__decorate
(
[
mobx_esm
.
action
]
Draft
.
prototype
"
commit
"
null
)
;
__decorate
(
[
mobx_esm
.
action
]
Draft
.
prototype
"
commitByPath
"
null
)
;
__decorate
(
[
mobx_esm
.
action
]
Draft
.
prototype
"
reset
"
null
)
;
__decorate
(
[
mobx_esm
.
action
]
Draft
.
prototype
"
resetByPath
"
null
)
;
__decorate
(
[
mobx_esm
.
computed
]
Draft
.
prototype
"
isDirty
"
null
)
;
__decorate
(
[
mobx_esm
.
computed
]
Draft
.
prototype
"
originalSnapshot
"
null
)
;
function
draft
(
original
)
{
return
new
Draft
(
original
)
;
}
function
pathToTargetPathIdsIgnoringLast
(
root
path
)
{
var
pathIds
=
pathToTargetPathIds
(
root
path
)
;
if
(
pathIds
.
length
>
=
1
)
{
pathIds
[
pathIds
.
length
-
1
]
=
skipIdChecking
;
}
return
pathIds
;
}
var
sandboxManagerContext
=
createContext
(
)
;
function
getNodeSandboxManager
(
node
)
{
return
sandboxManagerContext
.
get
(
node
)
;
}
function
isSandboxedNode
(
node
)
{
return
!
!
getNodeSandboxManager
(
node
)
;
}
var
SandboxManager
=
function
(
)
{
function
SandboxManager
(
subtreeRoot
)
{
var
_this
=
this
;
this
.
subtreeRoot
=
void
0
;
this
.
subtreeRootClone
=
void
0
;
this
.
disposer
=
void
0
;
this
.
withSandboxPatchRecorder
=
void
0
;
this
.
allowWrite
=
void
0
;
this
.
subtreeRoot
=
subtreeRoot
;
assertTweakedObject
(
subtreeRoot
"
subtreeRoot
"
)
;
var
previousContextDefault
=
sandboxManagerContext
.
getDefault
(
)
;
sandboxManagerContext
.
setDefault
(
this
)
;
try
{
this
.
subtreeRootClone
=
clone
(
subtreeRoot
{
generateNewIds
:
false
}
)
;
sandboxManagerContext
.
set
(
this
.
subtreeRootClone
this
)
;
}
catch
(
err
)
{
throw
err
;
}
finally
{
sandboxManagerContext
.
setDefault
(
previousContextDefault
)
;
}
var
wasRS
=
false
;
var
disposeReactionRS
=
(
0
mobx_esm
.
reaction
)
(
function
(
)
{
return
isRootStore
(
subtreeRoot
)
;
}
function
(
isRS
)
{
if
(
isRS
!
=
=
wasRS
)
{
wasRS
=
isRS
;
if
(
isRS
)
{
registerRootStore
(
_this
.
subtreeRootClone
)
;
}
else
{
unregisterRootStore
(
_this
.
subtreeRootClone
)
;
}
}
}
{
fireImmediately
:
true
}
)
;
var
disposeOnPatches
=
onPatches
(
subtreeRoot
function
(
patches
)
{
if
(
_this
.
withSandboxPatchRecorder
)
{
throw
failure
(
"
original
subtree
must
not
change
while
'
withSandbox
'
executes
"
)
;
}
_this
.
allowWrite
(
function
(
)
{
applyPatches
(
_this
.
subtreeRootClone
patches
)
;
}
)
;
}
)
;
var
_readonlyMiddleware
=
readonlyMiddleware
(
this
.
subtreeRootClone
)
allowWrite
=
_readonlyMiddleware
.
allowWrite
disposeReadonlyMW
=
_readonlyMiddleware
.
dispose
;
this
.
allowWrite
=
allowWrite
;
this
.
disposer
=
function
(
)
{
disposeReactionRS
(
)
;
disposeOnPatches
(
)
;
disposeReadonlyMW
(
)
;
if
(
isRootStore
(
_this
.
subtreeRootClone
)
)
{
unregisterRootStore
(
_this
.
subtreeRootClone
)
;
}
_this
.
disposer
=
function
(
)
{
}
;
}
;
}
var
_proto
=
SandboxManager
.
prototype
;
_proto
.
withSandbox
=
function
withSandbox
(
node
fn
)
{
assertIsFunction
(
fn
"
fn
"
)
;
var
isNodesArray
=
Array
.
isArray
(
node
)
&
&
!
isTweakedObject
(
node
false
)
;
var
nodes
=
isNodesArray
?
node
:
[
node
]
;
var
_this
prepareSandboxC
=
this
.
prepareSandboxChanges
(
nodes
)
sandboxNodes
=
_this
prepareSandboxC
.
sandboxNodes
applyRecorderChanges
=
_this
prepareSandboxC
.
applyRecorderChanges
;
var
commit
=
false
;
try
{
var
returnValue
=
this
.
allowWrite
(
function
(
)
{
return
fn
(
isNodesArray
?
sandboxNodes
:
sandboxNodes
[
0
]
)
;
}
)
;
if
(
typeof
returnValue
=
=
=
"
boolean
"
)
{
commit
=
returnValue
;
return
undefined
;
}
else
{
commit
=
returnValue
.
commit
;
return
returnValue
[
"
return
"
]
;
}
}
finally
{
applyRecorderChanges
(
commit
)
;
}
}
;
_proto
.
dispose
=
function
dispose
(
)
{
this
.
disposer
(
)
;
}
;
_proto
.
prepareSandboxChanges
=
function
prepareSandboxChanges
(
nodes
)
{
var
_this2
=
this
;
var
isNestedWithSandboxCall
=
!
!
this
.
withSandboxPatchRecorder
;
var
sandboxNodes
=
nodes
.
map
(
function
(
node
)
{
assertTweakedObject
(
node
"
node
"
)
;
var
path
=
getParentToChildPath
(
isNestedWithSandboxCall
?
_this2
.
subtreeRootClone
:
_this2
.
subtreeRoot
node
)
;
if
(
!
path
)
{
throw
failure
(
"
node
is
not
a
child
of
subtreeRoot
"
+
(
isNestedWithSandboxCall
?
"
Clone
"
:
"
"
)
)
;
}
var
sandboxNode
=
resolvePath
(
_this2
.
subtreeRootClone
path
)
.
value
;
if
(
!
sandboxNode
)
{
throw
failure
(
"
path
could
not
be
resolved
-
sandbox
may
be
out
of
sync
with
original
tree
"
)
;
}
return
sandboxNode
;
}
)
;
if
(
!
this
.
withSandboxPatchRecorder
)
{
this
.
withSandboxPatchRecorder
=
patchRecorder
(
this
.
subtreeRootClone
)
;
}
var
recorder
=
this
.
withSandboxPatchRecorder
;
var
numRecorderEvents
=
recorder
.
events
.
length
;
var
applyRecorderChanges
=
function
applyRecorderChanges
(
commit
)
{
if
(
!
isNestedWithSandboxCall
)
{
recorder
.
dispose
(
)
;
_this2
.
withSandboxPatchRecorder
=
undefined
;
}
(
0
mobx_esm
.
runInAction
)
(
function
(
)
{
if
(
commit
)
{
if
(
!
isNestedWithSandboxCall
)
{
var
len
=
recorder
.
events
.
length
;
for
(
var
i
=
0
;
i
<
len
;
i
+
+
)
{
applyPatches
(
_this2
.
subtreeRoot
recorder
.
events
[
i
]
.
patches
)
;
}
}
}
else
{
_this2
.
allowWrite
(
function
(
)
{
var
i
=
recorder
.
events
.
length
;
while
(
i
-
-
>
numRecorderEvents
)
{
applyPatches
(
_this2
.
subtreeRootClone
recorder
.
events
[
i
]
.
inversePatches
true
)
;
}
}
)
;
}
}
)
;
}
;
return
{
sandboxNodes
:
sandboxNodes
applyRecorderChanges
:
applyRecorderChanges
}
;
}
;
return
SandboxManager
;
}
(
)
;
function
sandbox
(
subtreeRoot
)
{
return
new
SandboxManager
(
subtreeRoot
)
;
}
var
ArraySet
=
function
(
_Model
)
{
_inheritsLoose
(
ArraySet
_Model
)
;
function
ArraySet
(
)
{
return
_Model
.
apply
(
this
arguments
)
|
|
this
;
}
var
_proto
=
ArraySet
.
prototype
;
_proto
.
add
=
function
add
(
value
)
{
var
items
=
this
.
items
;
if
(
!
items
.
includes
(
value
)
)
{
items
.
push
(
value
)
;
}
return
this
;
}
;
_proto
.
clear
=
function
clear
(
)
{
this
.
items
.
length
=
0
;
}
;
_proto
[
"
delete
"
]
=
function
_delete
(
value
)
{
var
items
=
this
.
items
;
var
index
=
items
.
findIndex
(
function
(
t
)
{
return
t
=
=
=
value
;
}
)
;
if
(
index
>
=
0
)
{
items
.
splice
(
index
1
)
;
return
true
;
}
else
{
return
false
;
}
}
;
_proto
.
forEach
=
function
forEach
(
callbackfn
thisArg
)
{
var
items
=
this
.
items
;
var
len
=
items
.
length
;
for
(
var
i
=
0
;
i
<
len
;
i
+
+
)
{
var
k
=
items
[
i
]
;
callbackfn
.
call
(
thisArg
k
k
this
)
;
}
}
;
_proto
.
has
=
function
has
(
value
)
{
return
this
.
items
.
includes
(
value
)
;
}
;
_proto
.
keys
=
function
keys
(
)
{
return
this
.
values
(
)
;
}
;
_proto
.
values
=
function
values
1
(
)
{
var
items
=
this
.
items
;
return
(
0
mobx_esm
.
values
)
(
items
)
[
Symbol
.
iterator
]
(
)
;
}
;
_proto
.
entries
=
function
entries
(
)
{
var
items
=
this
.
items
;
return
items
.
map
(
function
(
v
)
{
return
[
v
v
]
;
}
)
.
values
(
)
;
}
;
_proto
[
Symbol
.
iterator
]
=
function
(
)
{
return
this
.
values
(
)
;
}
;
_createClass
(
ArraySet
[
{
key
:
"
size
"
get
:
function
get
(
)
{
return
this
.
items
.
length
;
}
}
{
key
:
Symbol
.
toStringTag
get
:
function
get
(
)
{
return
"
ArraySet
"
;
}
}
]
)
;
return
ArraySet
;
}
(
Model
(
{
items
:
tProp
(
typesArray
(
typesUnchecked
(
)
)
function
(
)
{
return
[
]
;
}
)
}
)
)
;
__decorate
(
[
modelAction
]
ArraySet
.
prototype
"
add
"
null
)
;
__decorate
(
[
modelAction
]
ArraySet
.
prototype
"
clear
"
null
)
;
__decorate
(
[
modelAction
]
ArraySet
.
prototype
"
delete
"
null
)
;
ArraySet
=
__decorate
(
[
model
(
"
mobx
-
keystone
/
ArraySet
"
)
]
ArraySet
)
;
function
arraySet
(
values
)
{
var
initialArr
=
values
?
values
.
slice
(
)
:
[
]
;
return
new
ArraySet
(
{
items
:
initialArr
}
)
;
}
function
typesArraySet
(
valueType
)
{
var
typeInfoGen
=
function
typeInfoGen
(
t
)
{
return
new
ArraySetTypeInfo
(
t
resolveStandardType
(
valueType
)
)
;
}
;
return
lateTypeChecker
(
function
(
)
{
var
valueChecker
=
resolveTypeChecker
(
valueType
)
;
var
getTypeName
=
function
getTypeName
(
)
{
for
(
var
_len
=
arguments
.
length
recursiveTypeCheckers
=
new
Array
(
_len
)
_key
=
0
;
_key
<
_len
;
_key
+
+
)
{
recursiveTypeCheckers
[
_key
]
=
arguments
[
_key
]
;
}
return
"
ArraySet
<
"
+
valueChecker
.
getTypeName
.
apply
(
valueChecker
recursiveTypeCheckers
.
concat
(
[
valueChecker
]
)
)
+
"
>
"
;
}
;
var
thisTc
=
new
TypeChecker
(
function
(
obj
path
)
{
if
(
!
(
obj
instanceof
ArraySet
)
)
{
return
new
TypeCheckError
(
path
getTypeName
(
thisTc
)
obj
)
;
}
var
dataTypeChecker
=
typesObject
(
function
(
)
{
return
{
items
:
typesArray
(
valueChecker
)
}
;
}
)
;
var
resolvedTc
=
resolveTypeChecker
(
dataTypeChecker
)
;
return
resolvedTc
.
check
(
obj
.
path
)
;
}
getTypeName
typeInfoGen
)
;
return
thisTc
;
}
typeInfoGen
)
;
}
var
ArraySetTypeInfo
=
function
(
_TypeInfo
)
{
_inheritsLoose
(
ArraySetTypeInfo
_TypeInfo
)
;
_createClass
(
ArraySetTypeInfo
[
{
key
:
"
valueTypeInfo
"
get
:
function
get
(
)
{
return
getTypeInfo
(
this
.
valueType
)
;
}
}
]
)
;
function
ArraySetTypeInfo
(
originalType
valueType
)
{
var
_this
;
_this
=
_TypeInfo
.
call
(
this
originalType
)
|
|
this
;
_this
.
valueType
=
void
0
;
_this
.
valueType
=
valueType
;
return
_this
;
}
return
ArraySetTypeInfo
;
}
(
TypeInfo
)
;
function
typesOr
(
)
{
for
(
var
_len
=
arguments
.
length
orTypes
=
new
Array
(
_len
)
_key
=
0
;
_key
<
_len
;
_key
+
+
)
{
orTypes
[
_key
]
=
arguments
[
_key
]
;
}
var
typeInfoGen
=
function
typeInfoGen
(
t
)
{
return
new
OrTypeInfo
(
t
orTypes
.
map
(
resolveStandardType
)
)
;
}
;
return
lateTypeChecker
(
function
(
)
{
var
checkers
=
orTypes
.
map
(
resolveTypeChecker
)
;
if
(
checkers
.
some
(
function
(
tc
)
{
return
tc
.
unchecked
;
}
)
)
{
return
typesUnchecked
(
)
;
}
var
getTypeName
=
function
getTypeName
(
)
{
for
(
var
_len2
=
arguments
.
length
recursiveTypeCheckers
=
new
Array
(
_len2
)
_key2
=
0
;
_key2
<
_len2
;
_key2
+
+
)
{
recursiveTypeCheckers
[
_key2
]
=
arguments
[
_key2
]
;
}
var
typeNames
=
checkers
.
map
(
function
(
tc
)
{
if
(
recursiveTypeCheckers
.
includes
(
tc
)
)
{
return
"
.
.
.
"
;
}
return
tc
.
getTypeName
.
apply
(
tc
recursiveTypeCheckers
.
concat
(
[
tc
]
)
)
;
}
)
;
return
typeNames
.
join
(
"
|
"
)
;
}
;
var
thisTc
=
new
TypeChecker
(
function
(
value
path
)
{
var
noMatchingType
=
checkers
.
every
(
function
(
tc
)
{
return
!
!
tc
.
check
(
value
path
)
;
}
)
;
if
(
noMatchingType
)
{
return
new
TypeCheckError
(
path
getTypeName
(
thisTc
)
value
)
;
}
else
{
return
null
;
}
}
getTypeName
typeInfoGen
)
;
return
thisTc
;
}
typeInfoGen
)
;
}
var
OrTypeInfo
=
function
(
_TypeInfo
)
{
_inheritsLoose
(
OrTypeInfo
_TypeInfo
)
;
_createClass
(
OrTypeInfo
[
{
key
:
"
orTypeInfos
"
get
:
function
get
(
)
{
return
this
.
_orTypeInfos
(
)
;
}
}
]
)
;
function
OrTypeInfo
(
thisType
orTypes
)
{
var
_this
;
_this
=
_TypeInfo
.
call
(
this
thisType
)
|
|
this
;
_this
.
orTypes
=
void
0
;
_this
.
_orTypeInfos
=
lateVal
(
function
(
)
{
return
_this
.
orTypes
.
map
(
getTypeInfo
)
;
}
)
;
_this
.
orTypes
=
orTypes
;
return
_this
;
}
return
OrTypeInfo
;
}
(
TypeInfo
)
;
function
enumValues
(
e
)
{
var
vals
=
[
]
;
for
(
var
_i
=
0
_Object
keys
=
Object
.
keys
(
e
)
;
_i
<
_Object
keys
.
length
;
_i
+
+
)
{
var
k
=
_Object
keys
[
_i
]
;
var
v
=
e
[
k
]
;
if
(
typeof
v
!
=
=
"
string
"
|
|
e
[
v
]
!
=
=
+
k
)
{
vals
.
push
(
v
)
;
}
}
return
vals
;
}
function
typesEnum
(
enumObject
)
{
assertIsObject
(
enumObject
"
enumObject
"
)
;
var
literals
=
enumValues
(
enumObject
)
.
map
(
function
(
e
)
{
return
typesLiteral
(
e
)
;
}
)
;
return
typesOr
.
apply
(
void
0
literals
)
;
}
function
typesMaybe
(
baseType
)
{
return
typesOr
(
baseType
typesUndefined
)
;
}
function
typesMaybeNull
(
type
)
{
return
typesOr
(
type
typesNull
)
;
}
function
typesRecord
(
valueType
)
{
var
typeInfoGen
=
function
typeInfoGen
(
tc
)
{
return
new
RecordTypeInfo
(
tc
resolveStandardType
(
valueType
)
)
;
}
;
return
lateTypeChecker
(
function
(
)
{
var
valueChecker
=
resolveTypeChecker
(
valueType
)
;
var
getTypeName
=
function
getTypeName
(
)
{
for
(
var
_len
=
arguments
.
length
recursiveTypeCheckers
=
new
Array
(
_len
)
_key
=
0
;
_key
<
_len
;
_key
+
+
)
{
recursiveTypeCheckers
[
_key
]
=
arguments
[
_key
]
;
}
return
"
Record
<
"
+
valueChecker
.
getTypeName
.
apply
(
valueChecker
recursiveTypeCheckers
.
concat
(
[
valueChecker
]
)
)
+
"
>
"
;
}
;
var
thisTc
=
new
TypeChecker
(
function
(
obj
path
)
{
if
(
!
isObject
(
obj
)
)
return
new
TypeCheckError
(
path
getTypeName
(
thisTc
)
obj
)
;
if
(
!
valueChecker
.
unchecked
)
{
var
keys
=
Object
.
keys
(
obj
)
;
for
(
var
i
=
0
;
i
<
keys
.
length
;
i
+
+
)
{
var
k
=
keys
[
i
]
;
var
v
=
obj
[
k
]
;
var
valueError
=
valueChecker
.
check
(
v
[
]
.
concat
(
path
[
k
]
)
)
;
if
(
valueError
)
{
return
valueError
;
}
}
}
return
null
;
}
getTypeName
typeInfoGen
)
;
return
thisTc
;
}
typeInfoGen
)
;
}
var
RecordTypeInfo
=
function
(
_TypeInfo
)
{
_inheritsLoose
(
RecordTypeInfo
_TypeInfo
)
;
_createClass
(
RecordTypeInfo
[
{
key
:
"
valueTypeInfo
"
get
:
function
get
(
)
{
return
getTypeInfo
(
this
.
valueType
)
;
}
}
]
)
;
function
RecordTypeInfo
(
thisType
valueType
)
{
var
_this
;
_this
=
_TypeInfo
.
call
(
this
thisType
)
|
|
this
;
_this
.
valueType
=
void
0
;
_this
.
valueType
=
valueType
;
return
_this
;
}
return
RecordTypeInfo
;
}
(
TypeInfo
)
;
var
ObjectMap
=
function
(
_Model
)
{
_inheritsLoose
(
ObjectMap
_Model
)
;
function
ObjectMap
(
)
{
return
_Model
.
apply
(
this
arguments
)
|
|
this
;
}
var
_proto
=
ObjectMap
.
prototype
;
_proto
.
clear
=
function
clear
(
)
{
var
items
=
this
.
items
;
var
keys
=
Object
.
keys
(
items
)
;
var
len
=
keys
.
length
;
for
(
var
i
=
0
;
i
<
len
;
i
+
+
)
{
var
k
=
keys
[
i
]
;
(
0
mobx_esm
.
remove
)
(
items
k
)
;
}
}
;
_proto
[
"
delete
"
]
=
function
_delete
(
key
)
{
var
hasKey
=
this
.
has
(
key
)
;
if
(
hasKey
)
{
(
0
mobx_esm
.
remove
)
(
this
.
items
key
)
;
return
true
;
}
else
{
return
false
;
}
}
;
_proto
.
forEach
=
function
forEach
(
callbackfn
thisArg
)
{
var
items
=
this
.
items
;
var
keys
=
Object
.
keys
(
items
)
;
var
len
=
keys
.
length
;
for
(
var
i
=
0
;
i
<
len
;
i
+
+
)
{
var
k
=
keys
[
i
]
;
callbackfn
.
call
(
thisArg
items
[
k
]
k
this
)
;
}
}
;
_proto
.
get
=
function
get
1
(
key
)
{
return
(
0
mobx_esm
.
get
)
(
this
.
items
key
)
;
}
;
_proto
.
has
=
function
has
1
(
key
)
{
return
(
0
mobx_esm
.
has
)
(
this
.
items
key
)
;
}
;
_proto
.
set
=
function
set
1
(
key
value
)
{
(
0
mobx_esm
.
set
)
(
this
.
items
key
value
)
;
return
this
;
}
;
_proto
.
keys
=
function
keys
1
(
)
{
return
(
0
mobx_esm
.
keys
)
(
this
.
items
)
[
Symbol
.
iterator
]
(
)
;
}
;
_proto
.
values
=
function
values
1
(
)
{
return
(
0
mobx_esm
.
values
)
(
this
.
items
)
[
Symbol
.
iterator
]
(
)
;
}
;
_proto
.
entries
=
function
entries
1
(
)
{
return
(
0
mobx_esm
.
entries
)
(
this
.
items
)
[
Symbol
.
iterator
]
(
)
;
}
;
_proto
[
Symbol
.
iterator
]
=
function
(
)
{
return
this
.
entries
(
)
;
}
;
_createClass
(
ObjectMap
[
{
key
:
"
size
"
get
:
function
get
(
)
{
return
(
0
mobx_esm
.
keys
)
(
this
.
items
)
.
length
;
}
}
{
key
:
Symbol
.
toStringTag
get
:
function
get
(
)
{
return
"
ObjectMap
"
;
}
}
]
)
;
return
ObjectMap
;
}
(
Model
(
{
items
:
tProp
(
typesRecord
(
typesUnchecked
(
)
)
function
(
)
{
return
{
}
;
}
)
}
)
)
;
__decorate
(
[
modelAction
]
ObjectMap
.
prototype
"
clear
"
null
)
;
__decorate
(
[
modelAction
]
ObjectMap
.
prototype
"
delete
"
null
)
;
__decorate
(
[
modelAction
]
ObjectMap
.
prototype
"
set
"
null
)
;
ObjectMap
=
__decorate
(
[
model
(
"
mobx
-
keystone
/
ObjectMap
"
)
]
ObjectMap
)
;
function
objectMap
(
entries
)
{
var
initialObj
=
{
}
;
if
(
entries
)
{
var
len
=
entries
.
length
;
for
(
var
i
=
0
;
i
<
len
;
i
+
+
)
{
var
entry
=
entries
[
i
]
;
initialObj
[
entry
[
0
]
]
=
entry
[
1
]
;
}
}
return
new
ObjectMap
(
{
items
:
initialObj
}
)
;
}
function
typesObjectMap
(
valueType
)
{
var
typeInfoGen
=
function
typeInfoGen
(
t
)
{
return
new
ObjectMapTypeInfo
(
t
resolveStandardType
(
valueType
)
)
;
}
;
return
lateTypeChecker
(
function
(
)
{
var
valueChecker
=
resolveTypeChecker
(
valueType
)
;
var
getTypeName
=
function
getTypeName
(
)
{
for
(
var
_len
=
arguments
.
length
recursiveTypeCheckers
=
new
Array
(
_len
)
_key
=
0
;
_key
<
_len
;
_key
+
+
)
{
recursiveTypeCheckers
[
_key
]
=
arguments
[
_key
]
;
}
return
"
ObjectMap
<
"
+
valueChecker
.
getTypeName
.
apply
(
valueChecker
recursiveTypeCheckers
.
concat
(
[
valueChecker
]
)
)
+
"
>
"
;
}
;
var
thisTc
=
new
TypeChecker
(
function
(
obj
path
)
{
if
(
!
(
obj
instanceof
ObjectMap
)
)
{
return
new
TypeCheckError
(
path
getTypeName
(
thisTc
)
obj
)
;
}
var
dataTypeChecker
=
typesObject
(
function
(
)
{
return
{
items
:
typesRecord
(
valueChecker
)
}
;
}
)
;
var
resolvedTc
=
resolveTypeChecker
(
dataTypeChecker
)
;
return
resolvedTc
.
check
(
obj
.
path
)
;
}
getTypeName
typeInfoGen
)
;
return
thisTc
;
}
typeInfoGen
)
;
}
var
ObjectMapTypeInfo
=
function
(
_TypeInfo
)
{
_inheritsLoose
(
ObjectMapTypeInfo
_TypeInfo
)
;
_createClass
(
ObjectMapTypeInfo
[
{
key
:
"
valueTypeInfo
"
get
:
function
get
(
)
{
return
getTypeInfo
(
this
.
valueType
)
;
}
}
]
)
;
function
ObjectMapTypeInfo
(
thisType
valueType
)
{
var
_this
;
_this
=
_TypeInfo
.
call
(
this
thisType
)
|
|
this
;
_this
.
valueType
=
void
0
;
_this
.
valueType
=
valueType
;
return
_this
;
}
return
ObjectMapTypeInfo
;
}
(
TypeInfo
)
;
function
typesRef
(
)
{
return
refTypeChecker
;
}
var
typeName
=
"
Ref
"
;
var
refDataTypeChecker
=
typesObject
(
function
(
)
{
return
{
id
:
typesString
}
;
}
)
;
var
refTypeChecker
=
new
TypeChecker
(
function
(
value
path
)
{
if
(
!
(
value
instanceof
Ref
)
)
{
return
new
TypeCheckError
(
path
typeName
value
)
;
}
var
resolvedTc
=
resolveTypeChecker
(
refDataTypeChecker
)
;
return
resolvedTc
.
check
(
value
.
path
)
;
}
function
(
)
{
return
typeName
;
}
function
(
t
)
{
return
new
RefTypeInfo
(
t
)
;
}
)
;
var
RefTypeInfo
=
function
(
_TypeInfo
)
{
_inheritsLoose
(
RefTypeInfo
_TypeInfo
)
;
function
RefTypeInfo
(
)
{
return
_TypeInfo
.
apply
(
this
arguments
)
|
|
this
;
}
return
RefTypeInfo
;
}
(
TypeInfo
)
;
function
typesTuple
(
)
{
for
(
var
_len
=
arguments
.
length
itemTypes
=
new
Array
(
_len
)
_key
=
0
;
_key
<
_len
;
_key
+
+
)
{
itemTypes
[
_key
]
=
arguments
[
_key
]
;
}
var
typeInfoGen
=
function
typeInfoGen
(
t
)
{
return
new
TupleTypeInfo
(
t
itemTypes
.
map
(
resolveStandardType
)
)
;
}
;
return
lateTypeChecker
(
function
(
)
{
var
checkers
=
itemTypes
.
map
(
resolveTypeChecker
)
;
var
getTypeName
=
function
getTypeName
(
)
{
for
(
var
_len2
=
arguments
.
length
recursiveTypeCheckers
=
new
Array
(
_len2
)
_key2
=
0
;
_key2
<
_len2
;
_key2
+
+
)
{
recursiveTypeCheckers
[
_key2
]
=
arguments
[
_key2
]
;
}
var
typeNames
=
checkers
.
map
(
function
(
tc
)
{
if
(
recursiveTypeCheckers
.
includes
(
tc
)
)
{
return
"
.
.
.
"
;
}
return
tc
.
getTypeName
.
apply
(
tc
recursiveTypeCheckers
.
concat
(
[
tc
]
)
)
;
}
)
;
return
"
[
"
+
typeNames
.
join
(
"
"
)
+
"
]
"
;
}
;
var
thisTc
=
new
TypeChecker
(
function
(
array
path
)
{
if
(
!
isArray
(
array
)
|
|
array
.
length
!
=
=
itemTypes
.
length
)
{
return
new
TypeCheckError
(
path
getTypeName
(
thisTc
)
array
)
;
}
for
(
var
i
=
0
;
i
<
array
.
length
;
i
+
+
)
{
var
itemChecker
=
checkers
[
i
]
;
if
(
!
itemChecker
.
unchecked
)
{
var
itemError
=
itemChecker
.
check
(
array
[
i
]
[
]
.
concat
(
path
[
i
]
)
)
;
if
(
itemError
)
{
return
itemError
;
}
}
}
return
null
;
}
getTypeName
typeInfoGen
)
;
return
thisTc
;
}
typeInfoGen
)
;
}
var
TupleTypeInfo
=
function
(
_TypeInfo
)
{
_inheritsLoose
(
TupleTypeInfo
_TypeInfo
)
;
_createClass
(
TupleTypeInfo
[
{
key
:
"
itemTypeInfos
"
get
:
function
get
(
)
{
return
this
.
_itemTypeInfos
(
)
;
}
}
]
)
;
function
TupleTypeInfo
(
thisType
itemTypes
)
{
var
_this
;
_this
=
_TypeInfo
.
call
(
this
thisType
)
|
|
this
;
_this
.
itemTypes
=
void
0
;
_this
.
_itemTypeInfos
=
lateVal
(
function
(
)
{
return
_this
.
itemTypes
.
map
(
getTypeInfo
)
;
}
)
;
_this
.
itemTypes
=
itemTypes
;
return
_this
;
}
return
TupleTypeInfo
;
}
(
TypeInfo
)
;
var
types
=
{
literal
:
typesLiteral
undefined
:
typesUndefined
"
null
"
:
typesNull
"
boolean
"
:
typesBoolean
number
:
typesNumber
string
:
typesString
or
:
typesOr
maybe
:
typesMaybe
maybeNull
:
typesMaybeNull
array
:
typesArray
record
:
typesRecord
unchecked
:
typesUnchecked
model
:
typesModel
object
:
typesObject
ref
:
typesRef
frozen
:
typesFrozen
"
enum
"
:
typesEnum
refinement
:
typesRefinement
integer
:
typesInteger
nonEmptyString
:
typesNonEmptyString
objectMap
:
typesObjectMap
arraySet
:
typesArraySet
tuple
:
typesTuple
mapArray
:
function
mapArray
(
valueType
)
{
return
typesArray
(
typesTuple
(
typesString
valueType
)
)
;
}
setArray
:
function
setArray
(
valueType
)
{
return
typesArray
(
valueType
)
;
}
mapObject
:
function
mapObject
(
valueType
)
{
return
typesRecord
(
valueType
)
;
}
dateString
:
typesNonEmptyString
dateTimestamp
:
typesInteger
}
;
}
)
9637
:
(
(
__unused_webpack_module
__webpack_exports__
__webpack_require__
)
=
>
{
"
use
strict
"
;
__webpack_require__
.
r
(
__webpack_exports__
)
;
__webpack_require__
.
d
(
__webpack_exports__
{
"
mobx
"
:
(
)
=
>
(
mobx
)
"
FlowCancellationError
"
:
(
)
=
>
(
FlowCancellationError
)
"
ObservableMap
"
:
(
)
=
>
(
ObservableMap
)
"
ObservableSet
"
:
(
)
=
>
(
ObservableSet
)
"
Reaction
"
:
(
)
=
>
(
Reaction
)
"
_allowStateChanges
"
:
(
)
=
>
(
allowStateChanges
)
"
_allowStateChangesInsideComputed
"
:
(
)
=
>
(
runInAction
)
"
_allowStateReadsEnd
"
:
(
)
=
>
(
allowStateReadsEnd
)
"
_allowStateReadsStart
"
:
(
)
=
>
(
allowStateReadsStart
)
"
_autoAction
"
:
(
)
=
>
(
autoAction
)
"
_endAction
"
:
(
)
=
>
(
_endAction
)
"
_getAdministration
"
:
(
)
=
>
(
getAdministration
)
"
_getGlobalState
"
:
(
)
=
>
(
getGlobalState
)
"
_interceptReads
"
:
(
)
=
>
(
interceptReads
)
"
_isComputingDerivation
"
:
(
)
=
>
(
isComputingDerivation
)
"
_resetGlobalState
"
:
(
)
=
>
(
resetGlobalState
)
"
_startAction
"
:
(
)
=
>
(
_startAction
)
"
action
"
:
(
)
=
>
(
action
)
"
autorun
"
:
(
)
=
>
(
autorun
)
"
comparer
"
:
(
)
=
>
(
comparer
)
"
computed
"
:
(
)
=
>
(
computed
)
"
configure
"
:
(
)
=
>
(
configure
)
"
createAtom
"
:
(
)
=
>
(
createAtom
)
"
entries
"
:
(
)
=
>
(
entries
)
"
extendObservable
"
:
(
)
=
>
(
extendObservable
)
"
flow
"
:
(
)
=
>
(
flow
)
"
flowResult
"
:
(
)
=
>
(
flowResult
)
"
get
"
:
(
)
=
>
(
get
)
"
getAtom
"
:
(
)
=
>
(
getAtom
)
"
getDebugName
"
:
(
)
=
>
(
getDebugName
)
"
getDependencyTree
"
:
(
)
=
>
(
getDependencyTree
)
"
getObserverTree
"
:
(
)
=
>
(
getObserverTree
)
"
has
"
:
(
)
=
>
(
has
)
"
intercept
"
:
(
)
=
>
(
intercept
)
"
isAction
"
:
(
)
=
>
(
isAction
)
"
isBoxedObservable
"
:
(
)
=
>
(
isObservableValue
)
"
isComputed
"
:
(
)
=
>
(
isComputed
)
"
isComputedProp
"
:
(
)
=
>
(
isComputedProp
)
"
isFlowCancellationError
"
:
(
)
=
>
(
isFlowCancellationError
)
"
isObservable
"
:
(
)
=
>
(
isObservable
)
"
isObservableArray
"
:
(
)
=
>
(
isObservableArray
)
"
isObservableMap
"
:
(
)
=
>
(
isObservableMap
)
"
isObservableObject
"
:
(
)
=
>
(
isObservableObject
)
"
isObservableProp
"
:
(
)
=
>
(
isObservableProp
)
"
isObservableSet
"
:
(
)
=
>
(
isObservableSet
)
"
keys
"
:
(
)
=
>
(
keys
)
"
makeAutoObservable
"
:
(
)
=
>
(
makeAutoObservable
)
"
makeObservable
"
:
(
)
=
>
(
makeObservable
)
"
observable
"
:
(
)
=
>
(
observable
)
"
observe
"
:
(
)
=
>
(
observe
)
"
onBecomeObserved
"
:
(
)
=
>
(
onBecomeObserved
)
"
onBecomeUnobserved
"
:
(
)
=
>
(
onBecomeUnobserved
)
"
onReactionError
"
:
(
)
=
>
(
onReactionError
)
"
reaction
"
:
(
)
=
>
(
reaction
)
"
remove
"
:
(
)
=
>
(
remove
)
"
runInAction
"
:
(
)
=
>
(
runInAction
)
"
set
"
:
(
)
=
>
(
set
)
"
spy
"
:
(
)
=
>
(
spy
)
"
toJS
"
:
(
)
=
>
(
toJS
)
"
trace
"
:
(
)
=
>
(
trace
)
"
transaction
"
:
(
)
=
>
(
transaction
)
"
untracked
"
:
(
)
=
>
(
untracked
)
"
values
"
:
(
)
=
>
(
values
)
"
when
"
:
(
)
=
>
(
when
)
}
)
;
var
niceErrors
=
{
0
:
"
Invalid
value
for
configuration
'
enforceActions
'
expected
'
never
'
'
always
'
or
'
observed
'
"
1
:
function
_
(
prop
)
{
return
"
Cannot
decorate
undefined
property
:
'
"
+
prop
.
toString
(
)
+
"
'
"
;
}
2
:
function
_
(
prop
)
{
return
"
invalid
decorator
for
'
"
+
prop
.
toString
(
)
+
"
'
"
;
}
3
:
function
_
(
prop
)
{
return
"
Cannot
decorate
'
"
+
prop
.
toString
(
)
+
"
'
:
action
can
only
be
used
on
properties
with
a
function
value
.
"
;
}
4
:
function
_
(
prop
)
{
return
"
Cannot
decorate
'
"
+
prop
.
toString
(
)
+
"
'
:
computed
can
only
be
used
on
getter
properties
.
"
;
}
5
:
"
'
keys
(
)
'
can
only
be
used
on
observable
objects
arrays
sets
and
maps
"
6
:
"
'
values
(
)
'
can
only
be
used
on
observable
objects
arrays
sets
and
maps
"
7
:
"
'
entries
(
)
'
can
only
be
used
on
observable
objects
arrays
and
maps
"
8
:
"
'
set
(
)
'
can
only
be
used
on
observable
objects
arrays
and
maps
"
9
:
"
'
remove
(
)
'
can
only
be
used
on
observable
objects
arrays
and
maps
"
10
:
"
'
has
(
)
'
can
only
be
used
on
observable
objects
arrays
and
maps
"
11
:
"
'
get
(
)
'
can
only
be
used
on
observable
objects
arrays
and
maps
"
12
:
"
Invalid
annotation
"
13
:
"
Dynamic
observable
objects
cannot
be
frozen
"
14
:
"
Intercept
handlers
should
return
nothing
or
a
change
object
"
15
:
"
Observable
arrays
cannot
be
frozen
"
16
:
"
Modification
exception
:
the
internal
structure
of
an
observable
array
was
changed
.
"
17
:
function
_
(
index
length
)
{
return
"
[
mobx
.
array
]
Index
out
of
bounds
"
+
index
+
"
is
larger
than
"
+
length
;
}
18
:
"
mobx
.
map
requires
Map
polyfill
for
the
current
browser
.
Check
babel
-
polyfill
or
core
-
js
/
es6
/
map
.
js
"
19
:
function
_
(
other
)
{
return
"
Cannot
initialize
from
classes
that
inherit
from
Map
:
"
+
other
.
constructor
.
name
;
}
20
:
function
_
(
other
)
{
return
"
Cannot
initialize
map
from
"
+
other
;
}
21
:
function
_
(
dataStructure
)
{
return
"
Cannot
convert
to
map
from
'
"
+
dataStructure
+
"
'
"
;
}
22
:
"
mobx
.
set
requires
Set
polyfill
for
the
current
browser
.
Check
babel
-
polyfill
or
core
-
js
/
es6
/
set
.
js
"
23
:
"
It
is
not
possible
to
get
index
atoms
from
arrays
"
24
:
function
_
(
thing
)
{
return
"
Cannot
obtain
administration
from
"
+
thing
;
}
25
:
function
_
(
property
name
)
{
return
"
the
entry
'
"
+
property
+
"
'
does
not
exist
in
the
observable
map
'
"
+
name
+
"
'
"
;
}
26
:
"
please
specify
a
property
"
27
:
function
_
(
property
name
)
{
return
"
no
observable
property
'
"
+
property
.
toString
(
)
+
"
'
found
on
the
observable
object
'
"
+
name
+
"
'
"
;
}
28
:
function
_
(
thing
)
{
return
"
Cannot
obtain
atom
from
"
+
thing
;
}
29
:
"
Expecting
some
object
"
30
:
"
invalid
action
stack
.
did
you
forget
to
finish
an
action
?
"
31
:
"
missing
option
for
computed
:
get
"
32
:
function
_
(
name
derivation
)
{
return
"
Cycle
detected
in
computation
"
+
name
+
"
:
"
+
derivation
;
}
33
:
function
_
(
name
)
{
return
"
The
setter
of
computed
value
'
"
+
name
+
"
'
is
trying
to
update
itself
.
Did
you
intend
to
update
an
_observable_
value
instead
of
the
computed
property
?
"
;
}
34
:
function
_
(
name
)
{
return
"
[
ComputedValue
'
"
+
name
+
"
'
]
It
is
not
possible
to
assign
a
new
value
to
a
computed
value
.
"
;
}
35
:
"
There
are
multiple
different
versions
of
MobX
active
.
Make
sure
MobX
is
loaded
only
once
or
use
configure
(
{
isolateGlobalState
:
true
}
)
"
36
:
"
isolateGlobalState
should
be
called
before
MobX
is
running
any
reactions
"
37
:
function
_
(
method
)
{
return
"
[
mobx
]
observableArray
.
"
+
method
+
"
(
)
mutates
the
array
in
-
place
which
is
not
allowed
inside
a
derivation
.
Use
array
.
slice
(
)
.
"
+
method
+
"
(
)
instead
"
;
}
}
;
var
errors
=
false
?
0
:
{
}
;
function
die
(
error
)
{
for
(
var
_len
=
arguments
.
length
args
=
new
Array
(
_len
>
1
?
_len
-
1
:
0
)
_key
=
1
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
-
1
]
=
arguments
[
_key
]
;
}
if
(
false
)
{
var
e
;
}
throw
new
Error
(
typeof
error
=
=
=
"
number
"
?
"
[
MobX
]
minified
error
nr
:
"
+
error
+
(
args
.
length
?
"
"
+
args
.
join
(
"
"
)
:
"
"
)
+
"
.
Find
the
full
error
at
:
https
:
/
/
github
.
com
/
mobxjs
/
mobx
/
blob
/
mobx6
/
src
/
errors
.
ts
"
:
"
[
MobX
]
"
+
error
)
;
}
var
mockGlobal
=
{
}
;
function
getGlobal
(
)
{
if
(
typeof
window
!
=
=
"
undefined
"
)
{
return
window
;
}
if
(
typeof
__webpack_require__
.
g
!
=
=
"
undefined
"
)
{
return
__webpack_require__
.
g
;
}
if
(
typeof
self
!
=
=
"
undefined
"
)
{
return
self
;
}
return
mockGlobal
;
}
var
assign
=
Object
.
assign
;
var
getDescriptor
=
Object
.
getOwnPropertyDescriptor
;
var
defineProperty
=
Object
.
defineProperty
;
var
objectPrototype
=
Object
.
prototype
;
var
EMPTY_ARRAY
=
[
]
;
Object
.
freeze
(
EMPTY_ARRAY
)
;
var
EMPTY_OBJECT
=
{
}
;
Object
.
freeze
(
EMPTY_OBJECT
)
;
var
hasProxy
=
typeof
Proxy
!
=
=
"
undefined
"
;
var
plainObjectString
=
Object
.
toString
(
)
;
function
assertProxies
(
)
{
if
(
!
hasProxy
)
{
die
(
false
?
0
:
"
Proxy
not
available
"
)
;
}
}
function
warnAboutProxyRequirement
(
msg
)
{
if
(
false
)
{
}
}
function
getNextId
(
)
{
return
+
+
globalState
.
mobxGuid
;
}
function
once
(
func
)
{
var
invoked
=
false
;
return
function
(
)
{
if
(
invoked
)
return
;
invoked
=
true
;
return
func
.
apply
(
this
arguments
)
;
}
;
}
var
noop
=
function
noop
(
)
{
}
;
function
isFunction
(
fn
)
{
return
typeof
fn
=
=
=
"
function
"
;
}
function
isStringish
(
value
)
{
var
t
=
typeof
value
;
switch
(
t
)
{
case
"
string
"
:
case
"
symbol
"
:
case
"
number
"
:
return
true
;
}
return
false
;
}
function
isObject
(
value
)
{
return
value
!
=
=
null
&
&
typeof
value
=
=
=
"
object
"
;
}
function
isPlainObject
(
value
)
{
var
_proto
constructor
;
if
(
!
isObject
(
value
)
)
return
false
;
var
proto
=
Object
.
getPrototypeOf
(
value
)
;
if
(
proto
=
=
null
)
return
true
;
return
(
(
_proto
constructor
=
proto
.
constructor
)
=
=
null
?
void
0
:
_proto
constructor
.
toString
(
)
)
=
=
=
plainObjectString
;
}
function
isGenerator
(
obj
)
{
var
constructor
=
obj
=
=
null
?
void
0
:
obj
.
constructor
;
if
(
!
constructor
)
return
false
;
if
(
"
GeneratorFunction
"
=
=
=
constructor
.
name
|
|
"
GeneratorFunction
"
=
=
=
constructor
.
displayName
)
return
true
;
return
false
;
}
function
addHiddenProp
(
object
propName
value
)
{
defineProperty
(
object
propName
{
enumerable
:
false
writable
:
true
configurable
:
true
value
:
value
}
)
;
}
function
addHiddenFinalProp
(
object
propName
value
)
{
defineProperty
(
object
propName
{
enumerable
:
false
writable
:
false
configurable
:
true
value
:
value
}
)
;
}
function
assertPropertyConfigurable
(
object
prop
)
{
if
(
false
)
{
var
descriptor
;
}
}
function
createInstanceofPredicate
(
name
theClass
)
{
var
propName
=
"
isMobX
"
+
name
;
theClass
.
prototype
[
propName
]
=
true
;
return
function
(
x
)
{
return
isObject
(
x
)
&
&
x
[
propName
]
=
=
=
true
;
}
;
}
function
isES6Map
(
thing
)
{
return
thing
instanceof
Map
;
}
function
isES6Set
(
thing
)
{
return
thing
instanceof
Set
;
}
var
hasGetOwnPropertySymbols
=
typeof
Object
.
getOwnPropertySymbols
!
=
=
"
undefined
"
;
function
getPlainObjectKeys
(
object
)
{
var
keys
=
Object
.
keys
(
object
)
;
if
(
!
hasGetOwnPropertySymbols
)
return
keys
;
var
symbols
=
Object
.
getOwnPropertySymbols
(
object
)
;
if
(
!
symbols
.
length
)
return
keys
;
return
[
]
.
concat
(
keys
symbols
.
filter
(
function
(
s
)
{
return
objectPrototype
.
propertyIsEnumerable
.
call
(
object
s
)
;
}
)
)
;
}
var
ownKeys
=
typeof
Reflect
!
=
=
"
undefined
"
&
&
Reflect
.
ownKeys
?
Reflect
.
ownKeys
:
hasGetOwnPropertySymbols
?
function
(
obj
)
{
return
Object
.
getOwnPropertyNames
(
obj
)
.
concat
(
Object
.
getOwnPropertySymbols
(
obj
)
)
;
}
:
Object
.
getOwnPropertyNames
;
function
stringifyKey
(
key
)
{
if
(
typeof
key
=
=
=
"
string
"
)
return
key
;
if
(
typeof
key
=
=
=
"
symbol
"
)
return
key
.
toString
(
)
;
return
new
String
(
key
)
.
toString
(
)
;
}
function
toPrimitive
(
value
)
{
return
value
=
=
=
null
?
null
:
typeof
value
=
=
=
"
object
"
?
"
"
+
value
:
value
;
}
function
hasProp
(
target
prop
)
{
return
objectPrototype
.
hasOwnProperty
.
call
(
target
prop
)
;
}
var
getOwnPropertyDescriptors
=
Object
.
getOwnPropertyDescriptors
|
|
function
getOwnPropertyDescriptors
(
target
)
{
var
res
=
{
}
;
ownKeys
(
target
)
.
forEach
(
function
(
key
)
{
res
[
key
]
=
getDescriptor
(
target
key
)
;
}
)
;
return
res
;
}
;
var
mobxDecoratorsSymbol
=
Symbol
(
"
mobx
-
decorators
"
)
;
var
mobxAppliedDecoratorsSymbol
=
Symbol
(
"
mobx
-
applied
-
decorators
"
)
;
function
createDecorator
(
type
)
{
return
assign
(
function
(
target
property
)
{
if
(
property
=
=
=
undefined
)
{
createDecoratorAndAnnotation
(
type
target
)
;
}
else
{
storeDecorator
(
target
property
type
)
;
}
}
{
annotationType_
:
type
}
)
;
}
function
createDecoratorAndAnnotation
(
type
arg_
)
{
return
assign
(
function
(
target
property
)
{
storeDecorator
(
target
property
type
arg_
)
;
}
{
annotationType_
:
type
arg_
:
arg_
}
)
;
}
function
storeDecorator
(
target
property
type
arg_
)
{
var
desc
=
getDescriptor
(
target
mobxDecoratorsSymbol
)
;
var
map
;
if
(
desc
)
{
map
=
desc
.
value
;
}
else
{
map
=
{
}
;
addHiddenProp
(
target
mobxDecoratorsSymbol
map
)
;
}
map
[
property
]
=
{
annotationType_
:
type
arg_
:
arg_
}
;
}
function
applyDecorators
(
target
)
{
if
(
target
[
mobxAppliedDecoratorsSymbol
]
)
return
true
;
var
current
=
target
;
var
annotations
=
[
]
;
while
(
current
&
&
current
!
=
=
objectPrototype
)
{
var
desc
=
getDescriptor
(
current
mobxDecoratorsSymbol
)
;
if
(
desc
)
{
if
(
!
annotations
.
length
)
{
for
(
var
key
in
desc
.
value
)
{
if
(
!
hasProp
(
target
key
)
&
&
!
hasProp
(
current
key
)
)
{
return
true
;
}
}
}
annotations
.
unshift
(
desc
.
value
)
;
}
current
=
Object
.
getPrototypeOf
(
current
)
;
}
annotations
.
forEach
(
function
(
a
)
{
makeObservable
(
target
a
)
;
}
)
;
addHiddenProp
(
target
mobxAppliedDecoratorsSymbol
true
)
;
return
annotations
.
length
>
0
;
}
var
mobx
=
Symbol
(
"
mobx
administration
"
)
;
var
Atom
=
function
(
)
{
function
Atom
(
name_
)
{
if
(
name_
=
=
=
void
0
)
{
name_
=
"
Atom
"
+
getNextId
(
)
;
}
this
.
name_
=
void
0
;
this
.
isPendingUnobservation_
=
false
;
this
.
isBeingObserved_
=
false
;
this
.
observers_
=
new
Set
(
)
;
this
.
diffValue_
=
0
;
this
.
lastAccessedBy_
=
0
;
this
.
lowestObserverState_
=
IDerivationState_
.
NOT_TRACKING_
;
this
.
onBOL
=
void
0
;
this
.
onBUOL
=
void
0
;
this
.
name_
=
name_
;
}
var
_proto
=
Atom
.
prototype
;
_proto
.
onBO
=
function
onBO
(
)
{
if
(
this
.
onBOL
)
{
this
.
onBOL
.
forEach
(
function
(
listener
)
{
return
listener
(
)
;
}
)
;
}
}
;
_proto
.
onBUO
=
function
onBUO
(
)
{
if
(
this
.
onBUOL
)
{
this
.
onBUOL
.
forEach
(
function
(
listener
)
{
return
listener
(
)
;
}
)
;
}
}
;
_proto
.
reportObserved
=
function
reportObserved
1
(
)
{
return
reportObserved
(
this
)
;
}
;
_proto
.
reportChanged
=
function
reportChanged
(
)
{
startBatch
(
)
;
propagateChanged
(
this
)
;
endBatch
(
)
;
}
;
_proto
.
toString
=
function
toString
(
)
{
return
this
.
name_
;
}
;
return
Atom
;
}
(
)
;
var
isAtom
=
createInstanceofPredicate
(
"
Atom
"
Atom
)
;
function
createAtom
(
name
onBecomeObservedHandler
onBecomeUnobservedHandler
)
{
if
(
onBecomeObservedHandler
=
=
=
void
0
)
{
onBecomeObservedHandler
=
noop
;
}
if
(
onBecomeUnobservedHandler
=
=
=
void
0
)
{
onBecomeUnobservedHandler
=
noop
;
}
var
atom
=
new
Atom
(
name
)
;
if
(
onBecomeObservedHandler
!
=
=
noop
)
{
onBecomeObserved
(
atom
onBecomeObservedHandler
)
;
}
if
(
onBecomeUnobservedHandler
!
=
=
noop
)
{
onBecomeUnobserved
(
atom
onBecomeUnobservedHandler
)
;
}
return
atom
;
}
function
identityComparer
(
a
b
)
{
return
a
=
=
=
b
;
}
function
structuralComparer
(
a
b
)
{
return
deepEqual
(
a
b
)
;
}
function
shallowComparer
(
a
b
)
{
return
deepEqual
(
a
b
1
)
;
}
function
defaultComparer
(
a
b
)
{
return
Object
.
is
(
a
b
)
;
}
var
comparer
=
{
identity
:
identityComparer
structural
:
structuralComparer
"
default
"
:
defaultComparer
shallow
:
shallowComparer
}
;
function
deepEnhancer
(
v
_
name
)
{
if
(
isObservable
(
v
)
)
return
v
;
if
(
Array
.
isArray
(
v
)
)
return
observable
.
array
(
v
{
name
:
name
}
)
;
if
(
isPlainObject
(
v
)
)
return
observable
.
object
(
v
undefined
{
name
:
name
}
)
;
if
(
isES6Map
(
v
)
)
return
observable
.
map
(
v
{
name
:
name
}
)
;
if
(
isES6Set
(
v
)
)
return
observable
.
set
(
v
{
name
:
name
}
)
;
return
v
;
}
function
shallowEnhancer
(
v
_
name
)
{
if
(
v
=
=
=
undefined
|
|
v
=
=
=
null
)
return
v
;
if
(
isObservableObject
(
v
)
|
|
isObservableArray
(
v
)
|
|
isObservableMap
(
v
)
|
|
isObservableSet
(
v
)
)
return
v
;
if
(
Array
.
isArray
(
v
)
)
return
observable
.
array
(
v
{
name
:
name
deep
:
false
}
)
;
if
(
isPlainObject
(
v
)
)
return
observable
.
object
(
v
undefined
{
name
:
name
deep
:
false
}
)
;
if
(
isES6Map
(
v
)
)
return
observable
.
map
(
v
{
name
:
name
deep
:
false
}
)
;
if
(
isES6Set
(
v
)
)
return
observable
.
set
(
v
{
name
:
name
deep
:
false
}
)
;
if
(
false
)
{
}
}
function
referenceEnhancer
(
newValue
)
{
return
newValue
;
}
function
refStructEnhancer
(
v
oldValue
)
{
if
(
false
)
{
}
if
(
deepEqual
(
v
oldValue
)
)
return
oldValue
;
return
v
;
}
var
_annotationToEnhancer
;
var
OBSERVABLE
=
"
observable
"
;
var
OBSERVABLE_REF
=
"
observable
.
ref
"
;
var
OBSERVABLE_SHALLOW
=
"
observable
.
shallow
"
;
var
OBSERVABLE_STRUCT
=
"
observable
.
struct
"
;
var
defaultCreateObservableOptions
=
{
deep
:
true
name
:
undefined
defaultDecorator
:
undefined
proxy
:
true
}
;
Object
.
freeze
(
defaultCreateObservableOptions
)
;
function
asCreateObservableOptions
(
thing
)
{
return
thing
|
|
defaultCreateObservableOptions
;
}
function
getEnhancerFromOption
(
options
)
{
return
options
.
deep
=
=
=
true
?
deepEnhancer
:
options
.
deep
=
=
=
false
?
referenceEnhancer
:
getEnhancerFromAnnotation
(
options
.
defaultDecorator
)
;
}
var
annotationToEnhancer
=
(
_annotationToEnhancer
=
{
}
_annotationToEnhancer
[
OBSERVABLE
]
=
deepEnhancer
_annotationToEnhancer
[
OBSERVABLE_REF
]
=
referenceEnhancer
_annotationToEnhancer
[
OBSERVABLE_SHALLOW
]
=
shallowEnhancer
_annotationToEnhancer
[
OBSERVABLE_STRUCT
]
=
refStructEnhancer
_annotationToEnhancer
)
;
function
getEnhancerFromAnnotation
(
annotation
)
{
var
_annotationToEnhancer2
;
return
!
annotation
?
deepEnhancer
:
(
_annotationToEnhancer2
=
annotationToEnhancer
[
annotation
.
annotationType_
]
)
!
=
null
?
_annotationToEnhancer2
:
die
(
12
)
;
}
function
createObservable
(
v
arg2
arg3
)
{
if
(
isStringish
(
arg2
)
)
{
storeDecorator
(
v
arg2
OBSERVABLE
)
;
return
;
}
if
(
isObservable
(
v
)
)
return
v
;
var
res
=
isPlainObject
(
v
)
?
observable
.
object
(
v
arg2
arg3
)
:
Array
.
isArray
(
v
)
?
observable
.
array
(
v
arg2
)
:
isES6Map
(
v
)
?
observable
.
map
(
v
arg2
)
:
isES6Set
(
v
)
?
observable
.
set
(
v
arg2
)
:
v
;
if
(
res
!
=
=
v
)
return
res
;
return
observable
.
box
(
v
)
;
}
createObservable
.
annotationType_
=
OBSERVABLE
;
var
observableFactories
=
{
box
:
function
box
(
value
options
)
{
var
o
=
asCreateObservableOptions
(
options
)
;
return
new
ObservableValue
(
value
getEnhancerFromOption
(
o
)
o
.
name
true
o
.
equals
)
;
}
array
:
function
array
(
initialValues
options
)
{
var
o
=
asCreateObservableOptions
(
options
)
;
return
(
globalState
.
useProxies
=
=
=
false
|
|
o
.
proxy
=
=
=
false
?
createLegacyArray
:
createObservableArray
)
(
initialValues
getEnhancerFromOption
(
o
)
o
.
name
)
;
}
map
:
function
map
(
initialValues
options
)
{
var
o
=
asCreateObservableOptions
(
options
)
;
return
new
ObservableMap
(
initialValues
getEnhancerFromOption
(
o
)
o
.
name
)
;
}
set
:
function
set
(
initialValues
options
)
{
var
o
=
asCreateObservableOptions
(
options
)
;
return
new
ObservableSet
(
initialValues
getEnhancerFromOption
(
o
)
o
.
name
)
;
}
object
:
function
object
(
props
decorators
options
)
{
var
o
=
asCreateObservableOptions
(
options
)
;
var
base
=
{
}
;
asObservableObject
(
base
options
=
=
null
?
void
0
:
options
.
name
getEnhancerFromOption
(
o
)
)
;
return
extendObservable
(
globalState
.
useProxies
=
=
=
false
|
|
o
.
proxy
=
=
=
false
?
base
:
createDynamicObservableObject
(
base
)
props
decorators
options
)
;
}
ref
:
createDecorator
(
OBSERVABLE_REF
)
shallow
:
createDecorator
(
OBSERVABLE_SHALLOW
)
deep
:
createDecorator
(
OBSERVABLE
)
struct
:
createDecorator
(
OBSERVABLE_STRUCT
)
}
;
var
observable
=
assign
(
createObservable
observableFactories
)
;
var
COMPUTED
=
"
computed
"
;
var
COMPUTED_STRUCT
=
"
computed
.
struct
"
;
var
computed
=
function
computed
(
arg1
arg2
arg3
)
{
if
(
isStringish
(
arg2
)
)
{
return
storeDecorator
(
arg1
arg2
COMPUTED
)
;
}
if
(
isPlainObject
(
arg1
)
)
{
return
createDecoratorAndAnnotation
(
COMPUTED
arg1
)
;
}
if
(
false
)
{
}
var
opts
=
isPlainObject
(
arg2
)
?
arg2
:
{
}
;
opts
.
get
=
arg1
;
opts
.
name
=
opts
.
name
|
|
arg1
.
name
|
|
"
"
;
return
new
ComputedValue
(
opts
)
;
}
;
computed
.
annotationType_
=
COMPUTED
;
computed
.
struct
=
assign
(
function
(
target
property
)
{
storeDecorator
(
target
property
COMPUTED_STRUCT
)
;
}
{
annotationType_
:
COMPUTED_STRUCT
}
)
;
var
_getDescriptor
config
_getDescriptor
;
var
currentActionId
=
0
;
var
nextActionId
=
1
;
var
isFunctionNameConfigurable
=
(
_getDescriptor
config
=
(
_getDescriptor
=
getDescriptor
(
function
(
)
{
}
"
name
"
)
)
=
=
null
?
void
0
:
_getDescriptor
.
configurable
)
!
=
null
?
_getDescriptor
config
:
false
;
var
tmpNameDescriptor
=
{
value
:
"
action
"
configurable
:
true
writable
:
false
enumerable
:
false
}
;
function
createAction
(
actionName
fn
autoAction
ref
)
{
if
(
autoAction
=
=
=
void
0
)
{
autoAction
=
false
;
}
if
(
false
)
{
}
function
res
(
)
{
return
executeAction
(
actionName
autoAction
fn
ref
|
|
this
arguments
)
;
}
res
.
isMobxAction
=
true
;
if
(
isFunctionNameConfigurable
)
{
tmpNameDescriptor
.
value
=
actionName
;
Object
.
defineProperty
(
res
"
name
"
tmpNameDescriptor
)
;
}
return
res
;
}
function
executeAction
(
actionName
canRunAsDerivation
fn
scope
args
)
{
var
runInfo
=
_startAction
(
actionName
canRunAsDerivation
scope
args
)
;
try
{
return
fn
.
apply
(
scope
args
)
;
}
catch
(
err
)
{
runInfo
.
error_
=
err
;
throw
err
;
}
finally
{
_endAction
(
runInfo
)
;
}
}
function
_startAction
(
actionName
canRunAsDerivation
scope
args
)
{
var
notifySpy_
=
false
&
&
0
;
var
startTime_
=
0
;
if
(
false
)
{
var
flattenedArgs
;
}
var
prevDerivation_
=
globalState
.
trackingDerivation
;
var
runAsAction
=
!
canRunAsDerivation
|
|
!
prevDerivation_
;
startBatch
(
)
;
var
prevAllowStateChanges_
=
globalState
.
allowStateChanges
;
if
(
runAsAction
)
{
untrackedStart
(
)
;
prevAllowStateChanges_
=
allowStateChangesStart
(
true
)
;
}
var
prevAllowStateReads_
=
allowStateReadsStart
(
true
)
;
var
runInfo
=
{
runAsAction_
:
runAsAction
prevDerivation_
:
prevDerivation_
prevAllowStateChanges_
:
prevAllowStateChanges_
prevAllowStateReads_
:
prevAllowStateReads_
notifySpy_
:
notifySpy_
startTime_
:
startTime_
actionId_
:
nextActionId
+
+
parentActionId_
:
currentActionId
}
;
currentActionId
=
runInfo
.
actionId_
;
return
runInfo
;
}
function
_endAction
(
runInfo
)
{
if
(
currentActionId
!
=
=
runInfo
.
actionId_
)
{
die
(
30
)
;
}
currentActionId
=
runInfo
.
parentActionId_
;
if
(
runInfo
.
error_
!
=
=
undefined
)
{
globalState
.
suppressReactionErrors
=
true
;
}
allowStateChangesEnd
(
runInfo
.
prevAllowStateChanges_
)
;
allowStateReadsEnd
(
runInfo
.
prevAllowStateReads_
)
;
endBatch
(
)
;
if
(
runInfo
.
runAsAction_
)
untrackedEnd
(
runInfo
.
prevDerivation_
)
;
if
(
false
)
{
}
globalState
.
suppressReactionErrors
=
false
;
}
function
allowStateChanges
(
allowStateChanges
func
)
{
var
prev
=
allowStateChangesStart
(
allowStateChanges
)
;
try
{
return
func
(
)
;
}
finally
{
allowStateChangesEnd
(
prev
)
;
}
}
function
allowStateChangesStart
(
allowStateChanges
)
{
var
prev
=
globalState
.
allowStateChanges
;
globalState
.
allowStateChanges
=
allowStateChanges
;
return
prev
;
}
function
allowStateChangesEnd
(
prev
)
{
globalState
.
allowStateChanges
=
prev
;
}
function
_defineProperties
(
target
props
)
{
for
(
var
i
=
0
;
i
<
props
.
length
;
i
+
+
)
{
var
descriptor
=
props
[
i
]
;
descriptor
.
enumerable
=
descriptor
.
enumerable
|
|
false
;
descriptor
.
configurable
=
true
;
if
(
"
value
"
in
descriptor
)
descriptor
.
writable
=
true
;
Object
.
defineProperty
(
target
descriptor
.
key
descriptor
)
;
}
}
function
_createClass
(
Constructor
protoProps
staticProps
)
{
if
(
protoProps
)
_defineProperties
(
Constructor
.
prototype
protoProps
)
;
if
(
staticProps
)
_defineProperties
(
Constructor
staticProps
)
;
return
Constructor
;
}
function
_extends
(
)
{
_extends
=
Object
.
assign
|
|
function
(
target
)
{
for
(
var
i
=
1
;
i
<
arguments
.
length
;
i
+
+
)
{
var
source
=
arguments
[
i
]
;
for
(
var
key
in
source
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
source
key
)
)
{
target
[
key
]
=
source
[
key
]
;
}
}
}
return
target
;
}
;
return
_extends
.
apply
(
this
arguments
)
;
}
function
_inheritsLoose
(
subClass
superClass
)
{
subClass
.
prototype
=
Object
.
create
(
superClass
.
prototype
)
;
subClass
.
prototype
.
constructor
=
subClass
;
subClass
.
__proto__
=
superClass
;
}
function
_assertThisInitialized
(
self
)
{
if
(
self
=
=
=
void
0
)
{
throw
new
ReferenceError
(
"
this
hasn
'
t
been
initialised
-
super
(
)
hasn
'
t
been
called
"
)
;
}
return
self
;
}
function
_unsupportedIterableToArray
(
o
minLen
)
{
if
(
!
o
)
return
;
if
(
typeof
o
=
=
=
"
string
"
)
return
_arrayLikeToArray
(
o
minLen
)
;
var
n
=
Object
.
prototype
.
toString
.
call
(
o
)
.
slice
(
8
-
1
)
;
if
(
n
=
=
=
"
Object
"
&
&
o
.
constructor
)
n
=
o
.
constructor
.
name
;
if
(
n
=
=
=
"
Map
"
|
|
n
=
=
=
"
Set
"
)
return
Array
.
from
(
o
)
;
if
(
n
=
=
=
"
Arguments
"
|
|
/
^
(
?
:
Ui
|
I
)
nt
(
?
:
8
|
16
|
32
)
(
?
:
Clamped
)
?
Array
/
.
test
(
n
)
)
return
_arrayLikeToArray
(
o
minLen
)
;
}
function
_arrayLikeToArray
(
arr
len
)
{
if
(
len
=
=
null
|
|
len
>
arr
.
length
)
len
=
arr
.
length
;
for
(
var
i
=
0
arr2
=
new
Array
(
len
)
;
i
<
len
;
i
+
+
)
arr2
[
i
]
=
arr
[
i
]
;
return
arr2
;
}
function
_createForOfIteratorHelperLoose
(
o
allowArrayLike
)
{
var
it
;
if
(
typeof
Symbol
=
=
=
"
undefined
"
|
|
o
[
Symbol
.
iterator
]
=
=
null
)
{
if
(
Array
.
isArray
(
o
)
|
|
(
it
=
_unsupportedIterableToArray
(
o
)
)
|
|
allowArrayLike
&
&
o
&
&
typeof
o
.
length
=
=
=
"
number
"
)
{
if
(
it
)
o
=
it
;
var
i
=
0
;
return
function
(
)
{
if
(
i
>
=
o
.
length
)
return
{
done
:
true
}
;
return
{
done
:
false
value
:
o
[
i
+
+
]
}
;
}
;
}
throw
new
TypeError
(
"
Invalid
attempt
to
iterate
non
-
iterable
instance
.
\
nIn
order
to
be
iterable
non
-
array
objects
must
have
a
[
Symbol
.
iterator
]
(
)
method
.
"
)
;
}
it
=
o
[
Symbol
.
iterator
]
(
)
;
return
it
.
next
.
bind
(
it
)
;
}
var
_Symbol
toPrimitive
;
var
CREATE
=
"
create
"
;
_Symbol
toPrimitive
=
Symbol
.
toPrimitive
;
var
ObservableValue
=
function
(
_Atom
)
{
_inheritsLoose
(
ObservableValue
_Atom
)
;
function
ObservableValue
(
value
enhancer
name_
notifySpy
equals
)
{
var
_this
;
if
(
name_
=
=
=
void
0
)
{
name_
=
"
ObservableValue
"
+
getNextId
(
)
;
}
if
(
notifySpy
=
=
=
void
0
)
{
notifySpy
=
true
;
}
if
(
equals
=
=
=
void
0
)
{
equals
=
comparer
[
"
default
"
]
;
}
_this
=
_Atom
.
call
(
this
name_
)
|
|
this
;
_this
.
enhancer
=
void
0
;
_this
.
name_
=
void
0
;
_this
.
equals
=
void
0
;
_this
.
hasUnreportedChange_
=
false
;
_this
.
interceptors_
=
void
0
;
_this
.
changeListeners_
=
void
0
;
_this
.
value_
=
void
0
;
_this
.
dehancer
=
void
0
;
_this
.
enhancer
=
enhancer
;
_this
.
name_
=
name_
;
_this
.
equals
=
equals
;
_this
.
value_
=
enhancer
(
value
undefined
name_
)
;
if
(
false
)
{
}
return
_this
;
}
var
_proto
=
ObservableValue
.
prototype
;
_proto
.
dehanceValue
=
function
dehanceValue
(
value
)
{
if
(
this
.
dehancer
!
=
=
undefined
)
return
this
.
dehancer
(
value
)
;
return
value
;
}
;
_proto
.
set
=
function
set
(
newValue
)
{
var
oldValue
=
this
.
value_
;
newValue
=
this
.
prepareNewValue_
(
newValue
)
;
if
(
newValue
!
=
=
globalState
.
UNCHANGED
)
{
var
notifySpy
=
isSpyEnabled
(
)
;
if
(
false
)
{
}
this
.
setNewValue_
(
newValue
)
;
if
(
false
)
{
}
}
}
;
_proto
.
prepareNewValue_
=
function
prepareNewValue_
(
newValue
)
{
checkIfStateModificationsAreAllowed
(
this
)
;
if
(
hasInterceptors
(
this
)
)
{
var
change
=
interceptChange
(
this
{
object
:
this
type
:
UPDATE
newValue
:
newValue
}
)
;
if
(
!
change
)
return
globalState
.
UNCHANGED
;
newValue
=
change
.
newValue
;
}
newValue
=
this
.
enhancer
(
newValue
this
.
value_
this
.
name_
)
;
return
this
.
equals
(
this
.
value_
newValue
)
?
globalState
.
UNCHANGED
:
newValue
;
}
;
_proto
.
setNewValue_
=
function
setNewValue_
(
newValue
)
{
var
oldValue
=
this
.
value_
;
this
.
value_
=
newValue
;
this
.
reportChanged
(
)
;
if
(
hasListeners
(
this
)
)
{
notifyListeners
(
this
{
type
:
UPDATE
object
:
this
newValue
:
newValue
oldValue
:
oldValue
}
)
;
}
}
;
_proto
.
get
=
function
get
(
)
{
this
.
reportObserved
(
)
;
return
this
.
dehanceValue
(
this
.
value_
)
;
}
;
_proto
.
intercept_
=
function
intercept_
(
handler
)
{
return
registerInterceptor
(
this
handler
)
;
}
;
_proto
.
observe_
=
function
observe_
(
listener
fireImmediately
)
{
if
(
fireImmediately
)
listener
(
{
observableKind
:
"
value
"
debugObjectName
:
this
.
name_
object
:
this
type
:
UPDATE
newValue
:
this
.
value_
oldValue
:
undefined
}
)
;
return
registerListener
(
this
listener
)
;
}
;
_proto
.
raw
=
function
raw
(
)
{
return
this
.
value_
;
}
;
_proto
.
toJSON
=
function
toJSON
(
)
{
return
this
.
get
(
)
;
}
;
_proto
.
toString
=
function
toString
(
)
{
return
this
.
name_
+
"
[
"
+
this
.
value_
+
"
]
"
;
}
;
_proto
.
valueOf
=
function
valueOf
(
)
{
return
toPrimitive
(
this
.
get
(
)
)
;
}
;
_proto
[
_Symbol
toPrimitive
]
=
function
(
)
{
return
this
.
valueOf
(
)
;
}
;
return
ObservableValue
;
}
(
Atom
)
;
var
isObservableValue
=
createInstanceofPredicate
(
"
ObservableValue
"
ObservableValue
)
;
var
_Symbol
toPrimitive
1
;
_Symbol
toPrimitive
1
=
Symbol
.
toPrimitive
;
var
ComputedValue
=
function
(
)
{
function
ComputedValue
(
options
)
{
this
.
dependenciesState_
=
IDerivationState_
.
NOT_TRACKING_
;
this
.
observing_
=
[
]
;
this
.
newObserving_
=
null
;
this
.
isBeingObserved_
=
false
;
this
.
isPendingUnobservation_
=
false
;
this
.
observers_
=
new
Set
(
)
;
this
.
diffValue_
=
0
;
this
.
runId_
=
0
;
this
.
lastAccessedBy_
=
0
;
this
.
lowestObserverState_
=
IDerivationState_
.
UP_TO_DATE_
;
this
.
unboundDepsCount_
=
0
;
this
.
mapid_
=
"
#
"
+
getNextId
(
)
;
this
.
value_
=
new
CaughtException
(
null
)
;
this
.
name_
=
void
0
;
this
.
triggeredBy_
=
void
0
;
this
.
isComputing_
=
false
;
this
.
isRunningSetter_
=
false
;
this
.
derivation
=
void
0
;
this
.
setter_
=
void
0
;
this
.
isTracing_
=
TraceMode
.
NONE
;
this
.
scope_
=
void
0
;
this
.
equals_
=
void
0
;
this
.
requiresReaction_
=
void
0
;
this
.
keepAlive_
=
void
0
;
this
.
onBOL
=
void
0
;
this
.
onBUOL
=
void
0
;
if
(
!
options
.
get
)
die
(
31
)
;
this
.
derivation
=
options
.
get
;
this
.
name_
=
options
.
name
|
|
"
ComputedValue
"
+
getNextId
(
)
;
if
(
options
.
set
)
this
.
setter_
=
createAction
(
this
.
name_
+
"
-
setter
"
options
.
set
)
;
this
.
equals_
=
options
.
equals
|
|
(
options
.
compareStructural
|
|
options
.
struct
?
comparer
.
structural
:
comparer
[
"
default
"
]
)
;
this
.
scope_
=
options
.
context
;
this
.
requiresReaction_
=
!
!
options
.
requiresReaction
;
this
.
keepAlive_
=
!
!
options
.
keepAlive
;
}
var
_proto
=
ComputedValue
.
prototype
;
_proto
.
onBecomeStale_
=
function
onBecomeStale_
(
)
{
propagateMaybeChanged
(
this
)
;
}
;
_proto
.
onBO
=
function
onBO
(
)
{
if
(
this
.
onBOL
)
{
this
.
onBOL
.
forEach
(
function
(
listener
)
{
return
listener
(
)
;
}
)
;
}
}
;
_proto
.
onBUO
=
function
onBUO
(
)
{
if
(
this
.
onBUOL
)
{
this
.
onBUOL
.
forEach
(
function
(
listener
)
{
return
listener
(
)
;
}
)
;
}
}
;
_proto
.
get
=
function
get
(
)
{
if
(
this
.
isComputing_
)
die
(
32
this
.
name_
this
.
derivation
)
;
if
(
globalState
.
inBatch
=
=
=
0
&
&
this
.
observers_
.
size
=
=
=
0
&
&
!
this
.
keepAlive_
)
{
if
(
shouldCompute
(
this
)
)
{
this
.
warnAboutUntrackedRead_
(
)
;
startBatch
(
)
;
this
.
value_
=
this
.
computeValue_
(
false
)
;
endBatch
(
)
;
}
}
else
{
reportObserved
(
this
)
;
if
(
shouldCompute
(
this
)
)
{
var
prevTrackingContext
=
globalState
.
trackingContext
;
if
(
this
.
keepAlive_
&
&
!
prevTrackingContext
)
globalState
.
trackingContext
=
this
;
if
(
this
.
trackAndCompute
(
)
)
propagateChangeConfirmed
(
this
)
;
globalState
.
trackingContext
=
prevTrackingContext
;
}
}
var
result
=
this
.
value_
;
if
(
isCaughtException
(
result
)
)
throw
result
.
cause
;
return
result
;
}
;
_proto
.
set
=
function
set
(
value
)
{
if
(
this
.
setter_
)
{
if
(
this
.
isRunningSetter_
)
die
(
33
this
.
name_
)
;
this
.
isRunningSetter_
=
true
;
try
{
this
.
setter_
.
call
(
this
.
scope_
value
)
;
}
finally
{
this
.
isRunningSetter_
=
false
;
}
}
else
die
(
34
this
.
name_
)
;
}
;
_proto
.
trackAndCompute
=
function
trackAndCompute
(
)
{
var
oldValue
=
this
.
value_
;
var
wasSuspended
=
this
.
dependenciesState_
=
=
=
IDerivationState_
.
NOT_TRACKING_
;
var
newValue
=
this
.
computeValue_
(
true
)
;
if
(
false
)
{
}
var
changed
=
wasSuspended
|
|
isCaughtException
(
oldValue
)
|
|
isCaughtException
(
newValue
)
|
|
!
this
.
equals_
(
oldValue
newValue
)
;
if
(
changed
)
{
this
.
value_
=
newValue
;
}
return
changed
;
}
;
_proto
.
computeValue_
=
function
computeValue_
(
track
)
{
this
.
isComputing_
=
true
;
var
prev
=
allowStateChangesStart
(
false
)
;
var
res
;
if
(
track
)
{
res
=
trackDerivedFunction
(
this
this
.
derivation
this
.
scope_
)
;
}
else
{
if
(
globalState
.
disableErrorBoundaries
=
=
=
true
)
{
res
=
this
.
derivation
.
call
(
this
.
scope_
)
;
}
else
{
try
{
res
=
this
.
derivation
.
call
(
this
.
scope_
)
;
}
catch
(
e
)
{
res
=
new
CaughtException
(
e
)
;
}
}
}
allowStateChangesEnd
(
prev
)
;
this
.
isComputing_
=
false
;
return
res
;
}
;
_proto
.
suspend_
=
function
suspend_
(
)
{
if
(
!
this
.
keepAlive_
)
{
clearObserving
(
this
)
;
this
.
value_
=
undefined
;
}
}
;
_proto
.
observe_
=
function
observe_
(
listener
fireImmediately
)
{
var
_this
=
this
;
var
firstTime
=
true
;
var
prevValue
=
undefined
;
return
autorun
(
function
(
)
{
var
newValue
=
_this
.
get
(
)
;
if
(
!
firstTime
|
|
fireImmediately
)
{
var
prevU
=
untrackedStart
(
)
;
listener
(
{
observableKind
:
"
computed
"
debugObjectName
:
_this
.
name_
type
:
UPDATE
object
:
_this
newValue
:
newValue
oldValue
:
prevValue
}
)
;
untrackedEnd
(
prevU
)
;
}
firstTime
=
false
;
prevValue
=
newValue
;
}
)
;
}
;
_proto
.
warnAboutUntrackedRead_
=
function
warnAboutUntrackedRead_
(
)
{
if
(
true
)
return
;
if
(
this
.
requiresReaction_
=
=
=
true
)
{
die
(
"
[
mobx
]
Computed
value
"
+
this
.
name_
+
"
is
read
outside
a
reactive
context
"
)
;
}
if
(
this
.
isTracing_
!
=
=
TraceMode
.
NONE
)
{
console
.
log
(
"
[
mobx
.
trace
]
'
"
+
this
.
name_
+
"
'
is
being
read
outside
a
reactive
context
.
Doing
a
full
recompute
"
)
;
}
if
(
globalState
.
computedRequiresReaction
)
{
console
.
warn
(
"
[
mobx
]
Computed
value
"
+
this
.
name_
+
"
is
being
read
outside
a
reactive
context
.
Doing
a
full
recompute
"
)
;
}
}
;
_proto
.
toString
=
function
toString
(
)
{
return
this
.
name_
+
"
[
"
+
this
.
derivation
.
toString
(
)
+
"
]
"
;
}
;
_proto
.
valueOf
=
function
valueOf
(
)
{
return
toPrimitive
(
this
.
get
(
)
)
;
}
;
_proto
[
_Symbol
toPrimitive
1
]
=
function
(
)
{
return
this
.
valueOf
(
)
;
}
;
return
ComputedValue
;
}
(
)
;
var
isComputedValue
=
createInstanceofPredicate
(
"
ComputedValue
"
ComputedValue
)
;
var
IDerivationState_
;
(
function
(
IDerivationState_
)
{
IDerivationState_
[
IDerivationState_
[
"
NOT_TRACKING_
"
]
=
-
1
]
=
"
NOT_TRACKING_
"
;
IDerivationState_
[
IDerivationState_
[
"
UP_TO_DATE_
"
]
=
0
]
=
"
UP_TO_DATE_
"
;
IDerivationState_
[
IDerivationState_
[
"
POSSIBLY_STALE_
"
]
=
1
]
=
"
POSSIBLY_STALE_
"
;
IDerivationState_
[
IDerivationState_
[
"
STALE_
"
]
=
2
]
=
"
STALE_
"
;
}
)
(
IDerivationState_
|
|
(
IDerivationState_
=
{
}
)
)
;
var
TraceMode
;
(
function
(
TraceMode
)
{
TraceMode
[
TraceMode
[
"
NONE
"
]
=
0
]
=
"
NONE
"
;
TraceMode
[
TraceMode
[
"
LOG
"
]
=
1
]
=
"
LOG
"
;
TraceMode
[
TraceMode
[
"
BREAK
"
]
=
2
]
=
"
BREAK
"
;
}
)
(
TraceMode
|
|
(
TraceMode
=
{
}
)
)
;
var
CaughtException
=
function
CaughtException
(
cause
)
{
this
.
cause
=
void
0
;
this
.
cause
=
cause
;
}
;
function
isCaughtException
(
e
)
{
return
e
instanceof
CaughtException
;
}
function
shouldCompute
(
derivation
)
{
switch
(
derivation
.
dependenciesState_
)
{
case
IDerivationState_
.
UP_TO_DATE_
:
return
false
;
case
IDerivationState_
.
NOT_TRACKING_
:
case
IDerivationState_
.
STALE_
:
return
true
;
case
IDerivationState_
.
POSSIBLY_STALE_
:
{
var
prevAllowStateReads
=
allowStateReadsStart
(
true
)
;
var
prevUntracked
=
untrackedStart
(
)
;
var
obs
=
derivation
.
observing_
l
=
obs
.
length
;
for
(
var
i
=
0
;
i
<
l
;
i
+
+
)
{
var
obj
=
obs
[
i
]
;
if
(
isComputedValue
(
obj
)
)
{
if
(
globalState
.
disableErrorBoundaries
)
{
obj
.
get
(
)
;
}
else
{
try
{
obj
.
get
(
)
;
}
catch
(
e
)
{
untrackedEnd
(
prevUntracked
)
;
allowStateReadsEnd
(
prevAllowStateReads
)
;
return
true
;
}
}
if
(
derivation
.
dependenciesState_
=
=
=
IDerivationState_
.
STALE_
)
{
untrackedEnd
(
prevUntracked
)
;
allowStateReadsEnd
(
prevAllowStateReads
)
;
return
true
;
}
}
}
changeDependenciesStateTo0
(
derivation
)
;
untrackedEnd
(
prevUntracked
)
;
allowStateReadsEnd
(
prevAllowStateReads
)
;
return
false
;
}
}
}
function
isComputingDerivation
(
)
{
return
globalState
.
trackingDerivation
!
=
=
null
;
}
function
checkIfStateModificationsAreAllowed
(
atom
)
{
if
(
true
)
{
return
;
}
var
hasObservers
=
atom
.
observers_
.
size
>
0
;
if
(
!
globalState
.
allowStateChanges
&
&
(
hasObservers
|
|
globalState
.
enforceActions
=
=
=
"
always
"
)
)
console
.
warn
(
"
[
MobX
]
"
+
(
globalState
.
enforceActions
?
"
Since
strict
-
mode
is
enabled
changing
(
observed
)
observable
values
without
using
an
action
is
not
allowed
.
Tried
to
modify
:
"
:
"
Side
effects
like
changing
state
are
not
allowed
at
this
point
.
Are
you
trying
to
modify
state
from
for
example
a
computed
value
or
the
render
function
of
a
React
component
?
You
can
wrap
side
effects
in
'
runInAction
'
(
or
decorate
functions
with
'
action
'
)
if
needed
.
Tried
to
modify
:
"
)
+
atom
.
name_
)
;
}
function
checkIfStateReadsAreAllowed
(
observable
)
{
if
(
false
)
{
}
}
function
trackDerivedFunction
(
derivation
f
context
)
{
var
prevAllowStateReads
=
allowStateReadsStart
(
true
)
;
changeDependenciesStateTo0
(
derivation
)
;
derivation
.
newObserving_
=
new
Array
(
derivation
.
observing_
.
length
+
100
)
;
derivation
.
unboundDepsCount_
=
0
;
derivation
.
runId_
=
+
+
globalState
.
runId
;
var
prevTracking
=
globalState
.
trackingDerivation
;
globalState
.
trackingDerivation
=
derivation
;
globalState
.
inBatch
+
+
;
var
result
;
if
(
globalState
.
disableErrorBoundaries
=
=
=
true
)
{
result
=
f
.
call
(
context
)
;
}
else
{
try
{
result
=
f
.
call
(
context
)
;
}
catch
(
e
)
{
result
=
new
CaughtException
(
e
)
;
}
}
globalState
.
inBatch
-
-
;
globalState
.
trackingDerivation
=
prevTracking
;
bindDependencies
(
derivation
)
;
warnAboutDerivationWithoutDependencies
(
derivation
)
;
allowStateReadsEnd
(
prevAllowStateReads
)
;
return
result
;
}
function
warnAboutDerivationWithoutDependencies
(
derivation
)
{
if
(
true
)
return
;
if
(
derivation
.
observing_
.
length
!
=
=
0
)
return
;
if
(
globalState
.
reactionRequiresObservable
|
|
derivation
.
requiresObservable_
)
{
console
.
warn
(
"
[
mobx
]
Derivation
"
+
derivation
.
name_
+
"
is
created
/
updated
without
reading
any
observable
value
"
)
;
}
}
function
bindDependencies
(
derivation
)
{
var
prevObserving
=
derivation
.
observing_
;
var
observing
=
derivation
.
observing_
=
derivation
.
newObserving_
;
var
lowestNewObservingDerivationState
=
IDerivationState_
.
UP_TO_DATE_
;
var
i0
=
0
l
=
derivation
.
unboundDepsCount_
;
for
(
var
i
=
0
;
i
<
l
;
i
+
+
)
{
var
dep
=
observing
[
i
]
;
if
(
dep
.
diffValue_
=
=
=
0
)
{
dep
.
diffValue_
=
1
;
if
(
i0
!
=
=
i
)
observing
[
i0
]
=
dep
;
i0
+
+
;
}
if
(
dep
.
dependenciesState_
>
lowestNewObservingDerivationState
)
{
lowestNewObservingDerivationState
=
dep
.
dependenciesState_
;
}
}
observing
.
length
=
i0
;
derivation
.
newObserving_
=
null
;
l
=
prevObserving
.
length
;
while
(
l
-
-
)
{
var
_dep
=
prevObserving
[
l
]
;
if
(
_dep
.
diffValue_
=
=
=
0
)
{
removeObserver
(
_dep
derivation
)
;
}
_dep
.
diffValue_
=
0
;
}
while
(
i0
-
-
)
{
var
_dep2
=
observing
[
i0
]
;
if
(
_dep2
.
diffValue_
=
=
=
1
)
{
_dep2
.
diffValue_
=
0
;
addObserver
(
_dep2
derivation
)
;
}
}
if
(
lowestNewObservingDerivationState
!
=
=
IDerivationState_
.
UP_TO_DATE_
)
{
derivation
.
dependenciesState_
=
lowestNewObservingDerivationState
;
derivation
.
onBecomeStale_
(
)
;
}
}
function
clearObserving
(
derivation
)
{
var
obs
=
derivation
.
observing_
;
derivation
.
observing_
=
[
]
;
var
i
=
obs
.
length
;
while
(
i
-
-
)
{
removeObserver
(
obs
[
i
]
derivation
)
;
}
derivation
.
dependenciesState_
=
IDerivationState_
.
NOT_TRACKING_
;
}
function
untracked
(
action
)
{
var
prev
=
untrackedStart
(
)
;
try
{
return
action
(
)
;
}
finally
{
untrackedEnd
(
prev
)
;
}
}
function
untrackedStart
(
)
{
var
prev
=
globalState
.
trackingDerivation
;
globalState
.
trackingDerivation
=
null
;
return
prev
;
}
function
untrackedEnd
(
prev
)
{
globalState
.
trackingDerivation
=
prev
;
}
function
allowStateReadsStart
(
allowStateReads
)
{
var
prev
=
globalState
.
allowStateReads
;
globalState
.
allowStateReads
=
allowStateReads
;
return
prev
;
}
function
allowStateReadsEnd
(
prev
)
{
globalState
.
allowStateReads
=
prev
;
}
function
changeDependenciesStateTo0
(
derivation
)
{
if
(
derivation
.
dependenciesState_
=
=
=
IDerivationState_
.
UP_TO_DATE_
)
return
;
derivation
.
dependenciesState_
=
IDerivationState_
.
UP_TO_DATE_
;
var
obs
=
derivation
.
observing_
;
var
i
=
obs
.
length
;
while
(
i
-
-
)
{
obs
[
i
]
.
lowestObserverState_
=
IDerivationState_
.
UP_TO_DATE_
;
}
}
var
persistentKeys
=
[
"
mobxGuid
"
"
spyListeners
"
"
enforceActions
"
"
computedRequiresReaction
"
"
reactionRequiresObservable
"
"
observableRequiresReaction
"
"
allowStateReads
"
"
disableErrorBoundaries
"
"
runId
"
"
UNCHANGED
"
"
useProxies
"
]
;
var
MobXGlobals
=
function
MobXGlobals
(
)
{
this
.
version
=
6
;
this
.
UNCHANGED
=
{
}
;
this
.
trackingDerivation
=
null
;
this
.
trackingContext
=
null
;
this
.
runId
=
0
;
this
.
mobxGuid
=
0
;
this
.
inBatch
=
0
;
this
.
pendingUnobservations
=
[
]
;
this
.
pendingReactions
=
[
]
;
this
.
isRunningReactions
=
false
;
this
.
allowStateChanges
=
false
;
this
.
allowStateReads
=
true
;
this
.
enforceActions
=
true
;
this
.
spyListeners
=
[
]
;
this
.
globalReactionErrorHandlers
=
[
]
;
this
.
computedRequiresReaction
=
false
;
this
.
reactionRequiresObservable
=
false
;
this
.
observableRequiresReaction
=
false
;
this
.
disableErrorBoundaries
=
false
;
this
.
suppressReactionErrors
=
false
;
this
.
useProxies
=
true
;
this
.
verifyProxies
=
false
;
}
;
var
canMergeGlobalState
=
true
;
var
isolateCalled
=
false
;
var
globalState
=
function
(
)
{
var
global
=
getGlobal
(
)
;
if
(
global
.
__mobxInstanceCount
>
0
&
&
!
global
.
__mobxGlobals
)
canMergeGlobalState
=
false
;
if
(
global
.
__mobxGlobals
&
&
global
.
__mobxGlobals
.
version
!
=
=
new
MobXGlobals
(
)
.
version
)
canMergeGlobalState
=
false
;
if
(
!
canMergeGlobalState
)
{
setTimeout
(
function
(
)
{
if
(
!
isolateCalled
)
{
die
(
35
)
;
}
}
1
)
;
return
new
MobXGlobals
(
)
;
}
else
if
(
global
.
__mobxGlobals
)
{
global
.
__mobxInstanceCount
+
=
1
;
if
(
!
global
.
__mobxGlobals
.
UNCHANGED
)
global
.
__mobxGlobals
.
UNCHANGED
=
{
}
;
return
global
.
__mobxGlobals
;
}
else
{
global
.
__mobxInstanceCount
=
1
;
return
global
.
__mobxGlobals
=
new
MobXGlobals
(
)
;
}
}
(
)
;
function
isolateGlobalState
(
)
{
if
(
globalState
.
pendingReactions
.
length
|
|
globalState
.
inBatch
|
|
globalState
.
isRunningReactions
)
die
(
36
)
;
isolateCalled
=
true
;
if
(
canMergeGlobalState
)
{
var
global
=
getGlobal
(
)
;
if
(
-
-
global
.
__mobxInstanceCount
=
=
=
0
)
global
.
__mobxGlobals
=
undefined
;
globalState
=
new
MobXGlobals
(
)
;
}
}
function
getGlobalState
(
)
{
return
globalState
;
}
function
resetGlobalState
(
)
{
var
defaultGlobals
=
new
MobXGlobals
(
)
;
for
(
var
key
in
defaultGlobals
)
{
if
(
persistentKeys
.
indexOf
(
key
)
=
=
=
-
1
)
globalState
[
key
]
=
defaultGlobals
[
key
]
;
}
globalState
.
allowStateChanges
=
!
globalState
.
enforceActions
;
}
function
hasObservers
(
observable
)
{
return
observable
.
observers_
&
&
observable
.
observers_
.
size
>
0
;
}
function
getObservers
(
observable
)
{
return
observable
.
observers_
;
}
function
addObserver
(
observable
node
)
{
observable
.
observers_
.
add
(
node
)
;
if
(
observable
.
lowestObserverState_
>
node
.
dependenciesState_
)
observable
.
lowestObserverState_
=
node
.
dependenciesState_
;
}
function
removeObserver
(
observable
node
)
{
observable
.
observers_
[
"
delete
"
]
(
node
)
;
if
(
observable
.
observers_
.
size
=
=
=
0
)
{
queueForUnobservation
(
observable
)
;
}
}
function
queueForUnobservation
(
observable
)
{
if
(
observable
.
isPendingUnobservation_
=
=
=
false
)
{
observable
.
isPendingUnobservation_
=
true
;
globalState
.
pendingUnobservations
.
push
(
observable
)
;
}
}
function
startBatch
(
)
{
globalState
.
inBatch
+
+
;
}
function
endBatch
(
)
{
if
(
-
-
globalState
.
inBatch
=
=
=
0
)
{
runReactions
(
)
;
var
list
=
globalState
.
pendingUnobservations
;
for
(
var
i
=
0
;
i
<
list
.
length
;
i
+
+
)
{
var
observable
=
list
[
i
]
;
observable
.
isPendingUnobservation_
=
false
;
if
(
observable
.
observers_
.
size
=
=
=
0
)
{
if
(
observable
.
isBeingObserved_
)
{
observable
.
isBeingObserved_
=
false
;
observable
.
onBUO
(
)
;
}
if
(
observable
instanceof
ComputedValue
)
{
observable
.
suspend_
(
)
;
}
}
}
globalState
.
pendingUnobservations
=
[
]
;
}
}
function
reportObserved
(
observable
)
{
checkIfStateReadsAreAllowed
(
observable
)
;
var
derivation
=
globalState
.
trackingDerivation
;
if
(
derivation
!
=
=
null
)
{
if
(
derivation
.
runId_
!
=
=
observable
.
lastAccessedBy_
)
{
observable
.
lastAccessedBy_
=
derivation
.
runId_
;
derivation
.
newObserving_
[
derivation
.
unboundDepsCount_
+
+
]
=
observable
;
if
(
!
observable
.
isBeingObserved_
&
&
globalState
.
trackingContext
)
{
observable
.
isBeingObserved_
=
true
;
observable
.
onBO
(
)
;
}
}
return
true
;
}
else
if
(
observable
.
observers_
.
size
=
=
=
0
&
&
globalState
.
inBatch
>
0
)
{
queueForUnobservation
(
observable
)
;
}
return
false
;
}
function
propagateChanged
(
observable
)
{
if
(
observable
.
lowestObserverState_
=
=
=
IDerivationState_
.
STALE_
)
return
;
observable
.
lowestObserverState_
=
IDerivationState_
.
STALE_
;
observable
.
observers_
.
forEach
(
function
(
d
)
{
if
(
d
.
dependenciesState_
=
=
=
IDerivationState_
.
UP_TO_DATE_
)
{
if
(
false
)
{
}
d
.
onBecomeStale_
(
)
;
}
d
.
dependenciesState_
=
IDerivationState_
.
STALE_
;
}
)
;
}
function
propagateChangeConfirmed
(
observable
)
{
if
(
observable
.
lowestObserverState_
=
=
=
IDerivationState_
.
STALE_
)
return
;
observable
.
lowestObserverState_
=
IDerivationState_
.
STALE_
;
observable
.
observers_
.
forEach
(
function
(
d
)
{
if
(
d
.
dependenciesState_
=
=
=
IDerivationState_
.
POSSIBLY_STALE_
)
d
.
dependenciesState_
=
IDerivationState_
.
STALE_
;
else
if
(
d
.
dependenciesState_
=
=
=
IDerivationState_
.
UP_TO_DATE_
)
observable
.
lowestObserverState_
=
IDerivationState_
.
UP_TO_DATE_
;
}
)
;
}
function
propagateMaybeChanged
(
observable
)
{
if
(
observable
.
lowestObserverState_
!
=
=
IDerivationState_
.
UP_TO_DATE_
)
return
;
observable
.
lowestObserverState_
=
IDerivationState_
.
POSSIBLY_STALE_
;
observable
.
observers_
.
forEach
(
function
(
d
)
{
if
(
d
.
dependenciesState_
=
=
=
IDerivationState_
.
UP_TO_DATE_
)
{
d
.
dependenciesState_
=
IDerivationState_
.
POSSIBLY_STALE_
;
if
(
false
)
{
}
d
.
onBecomeStale_
(
)
;
}
}
)
;
}
function
logTraceInfo
(
derivation
observable
)
{
console
.
log
(
"
[
mobx
.
trace
]
'
"
+
derivation
.
name_
+
"
'
is
invalidated
due
to
a
change
in
:
'
"
+
observable
.
name_
+
"
'
"
)
;
if
(
derivation
.
isTracing_
=
=
=
TraceMode
.
BREAK
)
{
var
lines
=
[
]
;
printDepTree
(
getDependencyTree
(
derivation
)
lines
1
)
;
new
Function
(
"
debugger
;
\
n
/
*
\
nTracing
'
"
+
derivation
.
name_
+
"
'
\
n
\
nYou
are
entering
this
break
point
because
derivation
'
"
+
derivation
.
name_
+
"
'
is
being
traced
and
'
"
+
observable
.
name_
+
"
'
is
now
forcing
it
to
update
.
\
nJust
follow
the
stacktrace
you
should
now
see
in
the
devtools
to
see
precisely
what
piece
of
your
code
is
causing
this
update
\
nThe
stackframe
you
are
looking
for
is
at
least
~
6
-
8
stack
-
frames
up
.
\
n
\
n
"
+
(
derivation
instanceof
ComputedValue
?
derivation
.
derivation
.
toString
(
)
.
replace
(
/
[
*
]
\
/
/
g
"
/
"
)
:
"
"
)
+
"
\
n
\
nThe
dependencies
for
this
derivation
are
:
\
n
\
n
"
+
lines
.
join
(
"
\
n
"
)
+
"
\
n
*
/
\
n
"
)
(
)
;
}
}
function
printDepTree
(
tree
lines
depth
)
{
if
(
lines
.
length
>
=
1000
)
{
lines
.
push
(
"
(
and
many
more
)
"
)
;
return
;
}
lines
.
push
(
"
"
+
new
Array
(
depth
)
.
join
(
"
\
t
"
)
+
tree
.
name
)
;
if
(
tree
.
dependencies
)
tree
.
dependencies
.
forEach
(
function
(
child
)
{
return
printDepTree
(
child
lines
depth
+
1
)
;
}
)
;
}
var
Reaction
=
function
(
)
{
function
Reaction
(
name_
onInvalidate_
errorHandler_
requiresObservable_
)
{
if
(
name_
=
=
=
void
0
)
{
name_
=
"
Reaction
"
+
getNextId
(
)
;
}
if
(
requiresObservable_
=
=
=
void
0
)
{
requiresObservable_
=
false
;
}
this
.
name_
=
void
0
;
this
.
onInvalidate_
=
void
0
;
this
.
errorHandler_
=
void
0
;
this
.
requiresObservable_
=
void
0
;
this
.
observing_
=
[
]
;
this
.
newObserving_
=
[
]
;
this
.
dependenciesState_
=
IDerivationState_
.
NOT_TRACKING_
;
this
.
diffValue_
=
0
;
this
.
runId_
=
0
;
this
.
unboundDepsCount_
=
0
;
this
.
mapid_
=
"
#
"
+
getNextId
(
)
;
this
.
isDisposed_
=
false
;
this
.
isScheduled_
=
false
;
this
.
isTrackPending_
=
false
;
this
.
isRunning_
=
false
;
this
.
isTracing_
=
TraceMode
.
NONE
;
this
.
name_
=
name_
;
this
.
onInvalidate_
=
onInvalidate_
;
this
.
errorHandler_
=
errorHandler_
;
this
.
requiresObservable_
=
requiresObservable_
;
}
var
_proto
=
Reaction
.
prototype
;
_proto
.
onBecomeStale_
=
function
onBecomeStale_
(
)
{
this
.
schedule_
(
)
;
}
;
_proto
.
schedule_
=
function
schedule_
(
)
{
if
(
!
this
.
isScheduled_
)
{
this
.
isScheduled_
=
true
;
globalState
.
pendingReactions
.
push
(
this
)
;
runReactions
(
)
;
}
}
;
_proto
.
isScheduled
=
function
isScheduled
(
)
{
return
this
.
isScheduled_
;
}
;
_proto
.
runReaction_
=
function
runReaction_
(
)
{
if
(
!
this
.
isDisposed_
)
{
startBatch
(
)
;
this
.
isScheduled_
=
false
;
if
(
shouldCompute
(
this
)
)
{
this
.
isTrackPending_
=
true
;
try
{
this
.
onInvalidate_
(
)
;
if
(
false
)
{
}
}
catch
(
e
)
{
this
.
reportExceptionInDerivation_
(
e
)
;
}
}
endBatch
(
)
;
}
}
;
_proto
.
track
=
function
track
(
fn
)
{
if
(
this
.
isDisposed_
)
{
return
;
}
startBatch
(
)
;
var
notify
=
isSpyEnabled
(
)
;
var
startTime
;
if
(
false
)
{
}
this
.
isRunning_
=
true
;
var
prevReaction
=
globalState
.
trackingContext
;
globalState
.
trackingContext
=
this
;
var
result
=
trackDerivedFunction
(
this
fn
undefined
)
;
globalState
.
trackingContext
=
prevReaction
;
this
.
isRunning_
=
false
;
this
.
isTrackPending_
=
false
;
if
(
this
.
isDisposed_
)
{
clearObserving
(
this
)
;
}
if
(
isCaughtException
(
result
)
)
this
.
reportExceptionInDerivation_
(
result
.
cause
)
;
if
(
false
)
{
}
endBatch
(
)
;
}
;
_proto
.
reportExceptionInDerivation_
=
function
reportExceptionInDerivation_
(
error
)
{
var
_this
=
this
;
if
(
this
.
errorHandler_
)
{
this
.
errorHandler_
(
error
this
)
;
return
;
}
if
(
globalState
.
disableErrorBoundaries
)
throw
error
;
var
message
=
false
?
0
:
"
[
mobx
]
uncaught
error
in
'
"
+
this
+
"
'
"
;
if
(
!
globalState
.
suppressReactionErrors
)
{
console
.
error
(
message
error
)
;
}
else
if
(
false
)
{
}
if
(
false
)
{
}
globalState
.
globalReactionErrorHandlers
.
forEach
(
function
(
f
)
{
return
f
(
error
_this
)
;
}
)
;
}
;
_proto
.
dispose
=
function
dispose
(
)
{
if
(
!
this
.
isDisposed_
)
{
this
.
isDisposed_
=
true
;
if
(
!
this
.
isRunning_
)
{
startBatch
(
)
;
clearObserving
(
this
)
;
endBatch
(
)
;
}
}
}
;
_proto
.
getDisposer_
=
function
getDisposer_
(
)
{
var
r
=
this
.
dispose
.
bind
(
this
)
;
r
[
mobx
]
=
this
;
return
r
;
}
;
_proto
.
toString
=
function
toString
(
)
{
return
"
Reaction
[
"
+
this
.
name_
+
"
]
"
;
}
;
_proto
.
trace
=
function
trace
1
(
enterBreakPoint
)
{
if
(
enterBreakPoint
=
=
=
void
0
)
{
enterBreakPoint
=
false
;
}
trace
(
this
enterBreakPoint
)
;
}
;
return
Reaction
;
}
(
)
;
function
onReactionError
(
handler
)
{
globalState
.
globalReactionErrorHandlers
.
push
(
handler
)
;
return
function
(
)
{
var
idx
=
globalState
.
globalReactionErrorHandlers
.
indexOf
(
handler
)
;
if
(
idx
>
=
0
)
globalState
.
globalReactionErrorHandlers
.
splice
(
idx
1
)
;
}
;
}
var
MAX_REACTION_ITERATIONS
=
100
;
var
reactionScheduler
=
function
reactionScheduler
(
f
)
{
return
f
(
)
;
}
;
function
runReactions
(
)
{
if
(
globalState
.
inBatch
>
0
|
|
globalState
.
isRunningReactions
)
return
;
reactionScheduler
(
runReactionsHelper
)
;
}
function
runReactionsHelper
(
)
{
globalState
.
isRunningReactions
=
true
;
var
allReactions
=
globalState
.
pendingReactions
;
var
iterations
=
0
;
while
(
allReactions
.
length
>
0
)
{
if
(
+
+
iterations
=
=
=
MAX_REACTION_ITERATIONS
)
{
console
.
error
(
false
?
0
:
"
[
mobx
]
cycle
in
reaction
:
"
+
allReactions
[
0
]
)
;
allReactions
.
splice
(
0
)
;
}
var
remainingReactions
=
allReactions
.
splice
(
0
)
;
for
(
var
i
=
0
l
=
remainingReactions
.
length
;
i
<
l
;
i
+
+
)
{
remainingReactions
[
i
]
.
runReaction_
(
)
;
}
}
globalState
.
isRunningReactions
=
false
;
}
var
isReaction
=
createInstanceofPredicate
(
"
Reaction
"
Reaction
)
;
function
setReactionScheduler
(
fn
)
{
var
baseScheduler
=
reactionScheduler
;
reactionScheduler
=
function
reactionScheduler
(
f
)
{
return
fn
(
function
(
)
{
return
baseScheduler
(
f
)
;
}
)
;
}
;
}
function
isSpyEnabled
(
)
{
return
false
&
&
0
;
}
function
spyReport
(
event
)
{
if
(
true
)
return
;
if
(
!
globalState
.
spyListeners
.
length
)
return
;
var
listeners
=
globalState
.
spyListeners
;
for
(
var
i
=
0
l
=
listeners
.
length
;
i
<
l
;
i
+
+
)
{
listeners
[
i
]
(
event
)
;
}
}
function
spyReportStart
(
event
)
{
if
(
true
)
return
;
var
change
=
_extends
(
{
}
event
{
spyReportStart
:
true
}
)
;
spyReport
(
change
)
;
}
var
END_EVENT
=
{
type
:
"
report
-
end
"
spyReportEnd
:
true
}
;
function
spyReportEnd
(
change
)
{
if
(
true
)
return
;
if
(
change
)
spyReport
(
_extends
(
{
}
change
{
type
:
"
report
-
end
"
spyReportEnd
:
true
}
)
)
;
else
spyReport
(
END_EVENT
)
;
}
function
spy
(
listener
)
{
if
(
true
)
{
console
.
warn
(
"
[
mobx
.
spy
]
Is
a
no
-
op
in
production
builds
"
)
;
return
function
(
)
{
}
;
}
else
{
}
}
var
ACTION
=
"
action
"
;
var
ACTION_BOUND
=
"
action
.
bound
"
;
var
AUTOACTION
=
"
autoAction
"
;
var
AUTOACTION_BOUND
=
"
autoAction
.
bound
"
;
var
ACTION_UNNAMED
=
"
<
unnamed
action
>
"
;
function
createActionFactory
(
autoAction
annotation
)
{
var
res
=
function
action
(
arg1
arg2
)
{
if
(
isFunction
(
arg1
)
)
return
createAction
(
arg1
.
name
|
|
ACTION_UNNAMED
arg1
autoAction
)
;
if
(
isFunction
(
arg2
)
)
return
createAction
(
arg1
arg2
autoAction
)
;
if
(
isStringish
(
arg2
)
)
{
return
storeDecorator
(
arg1
arg2
annotation
)
;
}
if
(
isStringish
(
arg1
)
)
{
return
createDecoratorAndAnnotation
(
annotation
arg1
)
;
}
if
(
false
)
{
}
}
;
res
.
annotationType_
=
annotation
;
return
res
;
}
var
action
=
createActionFactory
(
false
ACTION
)
;
var
autoAction
=
createActionFactory
(
true
AUTOACTION
)
;
action
.
bound
=
createDecorator
(
ACTION_BOUND
)
;
autoAction
.
bound
=
createDecorator
(
AUTOACTION_BOUND
)
;
function
runInAction
(
fn
)
{
return
executeAction
(
fn
.
name
|
|
ACTION_UNNAMED
false
fn
this
undefined
)
;
}
function
isAction
(
thing
)
{
return
isFunction
(
thing
)
&
&
thing
.
isMobxAction
=
=
=
true
;
}
function
autorun
(
view
opts
)
{
if
(
opts
=
=
=
void
0
)
{
opts
=
EMPTY_OBJECT
;
}
if
(
false
)
{
}
var
name
=
opts
&
&
opts
.
name
|
|
view
.
name
|
|
"
Autorun
"
+
getNextId
(
)
;
var
runSync
=
!
opts
.
scheduler
&
&
!
opts
.
delay
;
var
reaction
;
if
(
runSync
)
{
reaction
=
new
Reaction
(
name
function
(
)
{
this
.
track
(
reactionRunner
)
;
}
opts
.
onError
opts
.
requiresObservable
)
;
}
else
{
var
scheduler
=
createSchedulerFromOptions
(
opts
)
;
var
isScheduled
=
false
;
reaction
=
new
Reaction
(
name
function
(
)
{
if
(
!
isScheduled
)
{
isScheduled
=
true
;
scheduler
(
function
(
)
{
isScheduled
=
false
;
if
(
!
reaction
.
isDisposed_
)
reaction
.
track
(
reactionRunner
)
;
}
)
;
}
}
opts
.
onError
opts
.
requiresObservable
)
;
}
function
reactionRunner
(
)
{
view
(
reaction
)
;
}
reaction
.
schedule_
(
)
;
return
reaction
.
getDisposer_
(
)
;
}
var
run
=
function
run
(
f
)
{
return
f
(
)
;
}
;
function
createSchedulerFromOptions
(
opts
)
{
return
opts
.
scheduler
?
opts
.
scheduler
:
opts
.
delay
?
function
(
f
)
{
return
setTimeout
(
f
opts
.
delay
)
;
}
:
run
;
}
function
reaction
(
expression
effect
opts
)
{
if
(
opts
=
=
=
void
0
)
{
opts
=
EMPTY_OBJECT
;
}
if
(
false
)
{
}
var
name
=
opts
.
name
|
|
"
Reaction
"
+
getNextId
(
)
;
var
effectAction
=
action
(
name
opts
.
onError
?
wrapErrorHandler
(
opts
.
onError
effect
)
:
effect
)
;
var
runSync
=
!
opts
.
scheduler
&
&
!
opts
.
delay
;
var
scheduler
=
createSchedulerFromOptions
(
opts
)
;
var
firstTime
=
true
;
var
isScheduled
=
false
;
var
value
;
var
oldValue
=
undefined
;
var
equals
=
opts
.
compareStructural
?
comparer
.
structural
:
opts
.
equals
|
|
comparer
[
"
default
"
]
;
var
r
=
new
Reaction
(
name
function
(
)
{
if
(
firstTime
|
|
runSync
)
{
reactionRunner
(
)
;
}
else
if
(
!
isScheduled
)
{
isScheduled
=
true
;
scheduler
(
reactionRunner
)
;
}
}
opts
.
onError
opts
.
requiresObservable
)
;
function
reactionRunner
(
)
{
isScheduled
=
false
;
if
(
r
.
isDisposed_
)
return
;
var
changed
=
false
;
r
.
track
(
function
(
)
{
var
nextValue
=
allowStateChanges
(
false
function
(
)
{
return
expression
(
r
)
;
}
)
;
changed
=
firstTime
|
|
!
equals
(
value
nextValue
)
;
oldValue
=
value
;
value
=
nextValue
;
}
)
;
if
(
firstTime
&
&
opts
.
fireImmediately
)
effectAction
(
value
oldValue
r
)
;
else
if
(
!
firstTime
&
&
changed
)
effectAction
(
value
oldValue
r
)
;
firstTime
=
false
;
}
r
.
schedule_
(
)
;
return
r
.
getDisposer_
(
)
;
}
function
wrapErrorHandler
(
errorHandler
baseFn
)
{
return
function
(
)
{
try
{
return
baseFn
.
apply
(
this
arguments
)
;
}
catch
(
e
)
{
errorHandler
.
call
(
this
e
)
;
}
}
;
}
var
ON_BECOME_OBSERVED
=
"
onBO
"
;
var
ON_BECOME_UNOBSERVED
=
"
onBUO
"
;
function
onBecomeObserved
(
thing
arg2
arg3
)
{
return
interceptHook
(
ON_BECOME_OBSERVED
thing
arg2
arg3
)
;
}
function
onBecomeUnobserved
(
thing
arg2
arg3
)
{
return
interceptHook
(
ON_BECOME_UNOBSERVED
thing
arg2
arg3
)
;
}
function
interceptHook
(
hook
thing
arg2
arg3
)
{
var
atom
=
typeof
arg3
=
=
=
"
function
"
?
getAtom
(
thing
arg2
)
:
getAtom
(
thing
)
;
var
cb
=
isFunction
(
arg3
)
?
arg3
:
arg2
;
var
listenersKey
=
hook
+
"
L
"
;
if
(
atom
[
listenersKey
]
)
{
atom
[
listenersKey
]
.
add
(
cb
)
;
}
else
{
atom
[
listenersKey
]
=
new
Set
(
[
cb
]
)
;
}
return
function
(
)
{
var
hookListeners
=
atom
[
listenersKey
]
;
if
(
hookListeners
)
{
hookListeners
[
"
delete
"
]
(
cb
)
;
if
(
hookListeners
.
size
=
=
=
0
)
{
delete
atom
[
listenersKey
]
;
}
}
}
;
}
var
NEVER
=
"
never
"
;
var
ALWAYS
=
"
always
"
;
var
OBSERVED
=
"
observed
"
;
function
configure
(
options
)
{
if
(
options
.
isolateGlobalState
=
=
=
true
)
{
isolateGlobalState
(
)
;
}
var
useProxies
=
options
.
useProxies
enforceActions
=
options
.
enforceActions
;
if
(
useProxies
!
=
=
undefined
)
{
globalState
.
useProxies
=
useProxies
=
=
=
ALWAYS
?
true
:
useProxies
=
=
=
NEVER
?
false
:
typeof
Proxy
!
=
=
"
undefined
"
;
}
if
(
useProxies
=
=
=
"
ifavailable
"
)
globalState
.
verifyProxies
=
true
;
if
(
enforceActions
!
=
=
undefined
)
{
var
ea
=
enforceActions
=
=
=
ALWAYS
?
ALWAYS
:
enforceActions
=
=
=
OBSERVED
;
globalState
.
enforceActions
=
ea
;
globalState
.
allowStateChanges
=
ea
=
=
=
true
|
|
ea
=
=
=
ALWAYS
?
false
:
true
;
}
[
"
computedRequiresReaction
"
"
reactionRequiresObservable
"
"
observableRequiresReaction
"
"
disableErrorBoundaries
"
]
.
forEach
(
function
(
key
)
{
if
(
key
in
options
)
globalState
[
key
]
=
!
!
options
[
key
]
;
}
)
;
globalState
.
allowStateReads
=
!
globalState
.
observableRequiresReaction
;
if
(
false
)
{
}
if
(
options
.
reactionScheduler
)
{
setReactionScheduler
(
options
.
reactionScheduler
)
;
}
}
function
extendObservable
(
target
properties
annotations
options
)
{
if
(
false
)
{
}
var
o
=
asCreateObservableOptions
(
options
)
;
var
adm
=
asObservableObject
(
target
o
.
name
getEnhancerFromOption
(
o
)
)
;
startBatch
(
)
;
try
{
var
descs
=
getOwnPropertyDescriptors
(
properties
)
;
getPlainObjectKeys
(
descs
)
.
forEach
(
function
(
key
)
{
makeProperty
(
adm
target
key
descs
[
key
]
!
annotations
?
true
:
key
in
annotations
?
annotations
[
key
]
:
true
true
!
!
(
options
=
=
null
?
void
0
:
options
.
autoBind
)
)
;
}
)
;
}
finally
{
endBatch
(
)
;
}
return
target
;
}
function
getDependencyTree
(
thing
property
)
{
return
nodeToDependencyTree
(
getAtom
(
thing
property
)
)
;
}
function
nodeToDependencyTree
(
node
)
{
var
result
=
{
name
:
node
.
name_
}
;
if
(
node
.
observing_
&
&
node
.
observing_
.
length
>
0
)
result
.
dependencies
=
unique
(
node
.
observing_
)
.
map
(
nodeToDependencyTree
)
;
return
result
;
}
function
getObserverTree
(
thing
property
)
{
return
nodeToObserverTree
(
getAtom
(
thing
property
)
)
;
}
function
nodeToObserverTree
(
node
)
{
var
result
=
{
name
:
node
.
name_
}
;
if
(
hasObservers
(
node
)
)
result
.
observers
=
Array
.
from
(
getObservers
(
node
)
)
.
map
(
nodeToObserverTree
)
;
return
result
;
}
function
unique
(
list
)
{
return
Array
.
from
(
new
Set
(
list
)
)
;
}
var
FLOW
=
"
flow
"
;
var
generatorId
=
0
;
function
FlowCancellationError
(
)
{
this
.
message
=
"
FLOW_CANCELLED
"
;
}
FlowCancellationError
.
prototype
=
Object
.
create
(
Error
.
prototype
)
;
function
isFlowCancellationError
(
error
)
{
return
error
instanceof
FlowCancellationError
;
}
var
flow
=
Object
.
assign
(
function
flow
(
arg1
arg2
)
{
if
(
isStringish
(
arg2
)
)
{
return
storeDecorator
(
arg1
arg2
"
flow
"
)
;
}
if
(
false
)
{
}
var
generator
=
arg1
;
var
name
=
generator
.
name
|
|
"
<
unnamed
flow
>
"
;
var
res
=
function
res
(
)
{
var
ctx
=
this
;
var
args
=
arguments
;
var
runId
=
+
+
generatorId
;
var
gen
=
action
(
name
+
"
-
runid
:
"
+
runId
+
"
-
init
"
generator
)
.
apply
(
ctx
args
)
;
var
rejector
;
var
pendingPromise
=
undefined
;
var
promise
=
new
Promise
(
function
(
resolve
reject
)
{
var
stepId
=
0
;
rejector
=
reject
;
function
onFulfilled
(
res
)
{
pendingPromise
=
undefined
;
var
ret
;
try
{
ret
=
action
(
name
+
"
-
runid
:
"
+
runId
+
"
-
yield
"
+
stepId
+
+
gen
.
next
)
.
call
(
gen
res
)
;
}
catch
(
e
)
{
return
reject
(
e
)
;
}
next
(
ret
)
;
}
function
onRejected
(
err
)
{
pendingPromise
=
undefined
;
var
ret
;
try
{
ret
=
action
(
name
+
"
-
runid
:
"
+
runId
+
"
-
yield
"
+
stepId
+
+
gen
[
"
throw
"
]
)
.
call
(
gen
err
)
;
}
catch
(
e
)
{
return
reject
(
e
)
;
}
next
(
ret
)
;
}
function
next
(
ret
)
{
if
(
isFunction
(
ret
=
=
null
?
void
0
:
ret
.
then
)
)
{
ret
.
then
(
next
reject
)
;
return
;
}
if
(
ret
.
done
)
return
resolve
(
ret
.
value
)
;
pendingPromise
=
Promise
.
resolve
(
ret
.
value
)
;
return
pendingPromise
.
then
(
onFulfilled
onRejected
)
;
}
onFulfilled
(
undefined
)
;
}
)
;
promise
.
cancel
=
action
(
name
+
"
-
runid
:
"
+
runId
+
"
-
cancel
"
function
(
)
{
try
{
if
(
pendingPromise
)
cancelPromise
(
pendingPromise
)
;
var
_res
=
gen
[
"
return
"
]
(
undefined
)
;
var
yieldedPromise
=
Promise
.
resolve
(
_res
.
value
)
;
yieldedPromise
.
then
(
noop
noop
)
;
cancelPromise
(
yieldedPromise
)
;
rejector
(
new
FlowCancellationError
(
)
)
;
}
catch
(
e
)
{
rejector
(
e
)
;
}
}
)
;
return
promise
;
}
;
res
.
isMobXFlow
=
true
;
return
res
;
}
{
annotationType_
:
"
flow
"
}
)
;
function
cancelPromise
(
promise
)
{
if
(
isFunction
(
promise
.
cancel
)
)
promise
.
cancel
(
)
;
}
function
flowResult
(
result
)
{
return
result
;
}
function
isFlow
(
fn
)
{
return
(
fn
=
=
null
?
void
0
:
fn
.
isMobXFlow
)
=
=
=
true
;
}
function
interceptReads
(
thing
propOrHandler
handler
)
{
var
target
;
if
(
isObservableMap
(
thing
)
|
|
isObservableArray
(
thing
)
|
|
isObservableValue
(
thing
)
)
{
target
=
getAdministration
(
thing
)
;
}
else
if
(
isObservableObject
(
thing
)
)
{
if
(
false
)
{
}
target
=
getAdministration
(
thing
propOrHandler
)
;
}
else
if
(
false
)
{
}
if
(
false
)
{
}
target
.
dehancer
=
typeof
propOrHandler
=
=
=
"
function
"
?
propOrHandler
:
handler
;
return
function
(
)
{
target
.
dehancer
=
undefined
;
}
;
}
function
intercept
(
thing
propOrHandler
handler
)
{
if
(
isFunction
(
handler
)
)
return
interceptProperty
(
thing
propOrHandler
handler
)
;
else
return
interceptInterceptable
(
thing
propOrHandler
)
;
}
function
interceptInterceptable
(
thing
handler
)
{
return
getAdministration
(
thing
)
.
intercept_
(
handler
)
;
}
function
interceptProperty
(
thing
property
handler
)
{
return
getAdministration
(
thing
property
)
.
intercept_
(
handler
)
;
}
function
_isComputed
(
value
property
)
{
if
(
property
!
=
=
undefined
)
{
if
(
isObservableObject
(
value
)
=
=
=
false
)
return
false
;
if
(
!
value
[
mobx
]
.
values_
.
has
(
property
)
)
return
false
;
var
atom
=
getAtom
(
value
property
)
;
return
isComputedValue
(
atom
)
;
}
return
isComputedValue
(
value
)
;
}
function
isComputed
(
value
)
{
if
(
false
)
{
}
return
_isComputed
(
value
)
;
}
function
isComputedProp
(
value
propName
)
{
if
(
false
)
{
}
return
_isComputed
(
value
propName
)
;
}
function
_isObservable
(
value
property
)
{
if
(
!
value
)
return
false
;
if
(
property
!
=
=
undefined
)
{
if
(
false
)
{
}
if
(
isObservableObject
(
value
)
)
{
return
value
[
mobx
]
.
values_
.
has
(
property
)
;
}
return
false
;
}
return
isObservableObject
(
value
)
|
|
!
!
value
[
mobx
]
|
|
isAtom
(
value
)
|
|
isReaction
(
value
)
|
|
isComputedValue
(
value
)
;
}
function
isObservable
(
value
)
{
if
(
false
)
{
}
return
_isObservable
(
value
)
;
}
function
isObservableProp
(
value
propName
)
{
if
(
false
)
{
}
return
_isObservable
(
value
propName
)
;
}
function
keys
(
obj
)
{
if
(
isObservableObject
(
obj
)
)
{
return
obj
[
mobx
]
.
getKeys_
(
)
;
}
if
(
isObservableMap
(
obj
)
|
|
isObservableSet
(
obj
)
)
{
return
Array
.
from
(
obj
.
keys
(
)
)
;
}
if
(
isObservableArray
(
obj
)
)
{
return
obj
.
map
(
function
(
_
index
)
{
return
index
;
}
)
;
}
die
(
5
)
;
}
function
values
(
obj
)
{
if
(
isObservableObject
(
obj
)
)
{
return
keys
(
obj
)
.
map
(
function
(
key
)
{
return
obj
[
key
]
;
}
)
;
}
if
(
isObservableMap
(
obj
)
)
{
return
keys
(
obj
)
.
map
(
function
(
key
)
{
return
obj
.
get
(
key
)
;
}
)
;
}
if
(
isObservableSet
(
obj
)
)
{
return
Array
.
from
(
obj
.
values
(
)
)
;
}
if
(
isObservableArray
(
obj
)
)
{
return
obj
.
slice
(
)
;
}
die
(
6
)
;
}
function
entries
(
obj
)
{
if
(
isObservableObject
(
obj
)
)
{
return
keys
(
obj
)
.
map
(
function
(
key
)
{
return
[
key
obj
[
key
]
]
;
}
)
;
}
if
(
isObservableMap
(
obj
)
)
{
return
keys
(
obj
)
.
map
(
function
(
key
)
{
return
[
key
obj
.
get
(
key
)
]
;
}
)
;
}
if
(
isObservableSet
(
obj
)
)
{
return
Array
.
from
(
obj
.
entries
(
)
)
;
}
if
(
isObservableArray
(
obj
)
)
{
return
obj
.
map
(
function
(
key
index
)
{
return
[
index
key
]
;
}
)
;
}
die
(
7
)
;
}
function
set
(
obj
key
value
)
{
if
(
arguments
.
length
=
=
=
2
&
&
!
isObservableSet
(
obj
)
)
{
startBatch
(
)
;
var
_values
=
key
;
try
{
for
(
var
_key
in
_values
)
{
set
(
obj
_key
_values
[
_key
]
)
;
}
}
finally
{
endBatch
(
)
;
}
return
;
}
if
(
isObservableObject
(
obj
)
)
{
var
adm
=
obj
[
mobx
]
;
var
existingObservable
=
adm
.
values_
.
get
(
key
)
;
if
(
existingObservable
)
{
adm
.
write_
(
key
value
)
;
}
else
{
adm
.
addObservableProp_
(
key
value
adm
.
defaultEnhancer_
)
;
}
}
else
if
(
isObservableMap
(
obj
)
)
{
obj
.
set
(
key
value
)
;
}
else
if
(
isObservableSet
(
obj
)
)
{
obj
.
add
(
key
)
;
}
else
if
(
isObservableArray
(
obj
)
)
{
if
(
typeof
key
!
=
=
"
number
"
)
key
=
parseInt
(
key
10
)
;
if
(
key
<
0
)
die
(
"
Invalid
index
:
'
"
+
key
+
"
'
"
)
;
startBatch
(
)
;
if
(
key
>
=
obj
.
length
)
obj
.
length
=
key
+
1
;
obj
[
key
]
=
value
;
endBatch
(
)
;
}
else
die
(
8
)
;
}
function
remove
(
obj
key
)
{
if
(
isObservableObject
(
obj
)
)
{
obj
[
mobx
]
.
remove_
(
key
)
;
}
else
if
(
isObservableMap
(
obj
)
)
{
obj
[
"
delete
"
]
(
key
)
;
}
else
if
(
isObservableSet
(
obj
)
)
{
obj
[
"
delete
"
]
(
key
)
;
}
else
if
(
isObservableArray
(
obj
)
)
{
if
(
typeof
key
!
=
=
"
number
"
)
key
=
parseInt
(
key
10
)
;
obj
.
splice
(
key
1
)
;
}
else
{
die
(
9
)
;
}
}
function
has
(
obj
key
)
{
if
(
isObservableObject
(
obj
)
)
{
return
getAdministration
(
obj
)
.
has_
(
key
)
;
}
else
if
(
isObservableMap
(
obj
)
)
{
return
obj
.
has
(
key
)
;
}
else
if
(
isObservableSet
(
obj
)
)
{
return
obj
.
has
(
key
)
;
}
else
if
(
isObservableArray
(
obj
)
)
{
return
key
>
=
0
&
&
key
<
obj
.
length
;
}
die
(
10
)
;
}
function
get
(
obj
key
)
{
if
(
!
has
(
obj
key
)
)
return
undefined
;
if
(
isObservableObject
(
obj
)
)
{
return
obj
[
key
]
;
}
else
if
(
isObservableMap
(
obj
)
)
{
return
obj
.
get
(
key
)
;
}
else
if
(
isObservableArray
(
obj
)
)
{
return
obj
[
key
]
;
}
die
(
11
)
;
}
function
observe
(
thing
propOrCb
cbOrFire
fireImmediately
)
{
if
(
isFunction
(
cbOrFire
)
)
return
observeObservableProperty
(
thing
propOrCb
cbOrFire
fireImmediately
)
;
else
return
observeObservable
(
thing
propOrCb
cbOrFire
)
;
}
function
observeObservable
(
thing
listener
fireImmediately
)
{
return
getAdministration
(
thing
)
.
observe_
(
listener
fireImmediately
)
;
}
function
observeObservableProperty
(
thing
property
listener
fireImmediately
)
{
return
getAdministration
(
thing
property
)
.
observe_
(
listener
fireImmediately
)
;
}
function
cache
(
map
key
value
)
{
map
.
set
(
key
value
)
;
return
value
;
}
function
toJSHelper
(
source
__alreadySeen
)
{
if
(
source
=
=
null
|
|
typeof
source
!
=
=
"
object
"
|
|
source
instanceof
Date
|
|
!
isObservable
(
source
)
)
return
source
;
if
(
isObservableValue
(
source
)
)
return
toJSHelper
(
source
.
get
(
)
__alreadySeen
)
;
if
(
__alreadySeen
.
has
(
source
)
)
{
return
__alreadySeen
.
get
(
source
)
;
}
if
(
isObservableArray
(
source
)
)
{
var
res
=
cache
(
__alreadySeen
source
new
Array
(
source
.
length
)
)
;
source
.
forEach
(
function
(
value
idx
)
{
res
[
idx
]
=
toJSHelper
(
value
__alreadySeen
)
;
}
)
;
return
res
;
}
if
(
isObservableSet
(
source
)
)
{
var
_res
=
cache
(
__alreadySeen
source
new
Set
(
)
)
;
source
.
forEach
(
function
(
value
)
{
_res
.
add
(
toJSHelper
(
value
__alreadySeen
)
)
;
}
)
;
return
_res
;
}
if
(
isObservableMap
(
source
)
)
{
var
_res2
=
cache
(
__alreadySeen
source
new
Map
(
)
)
;
source
.
forEach
(
function
(
value
key
)
{
_res2
.
set
(
key
toJSHelper
(
value
__alreadySeen
)
)
;
}
)
;
return
_res2
;
}
else
{
keys
(
source
)
;
var
_res3
=
cache
(
__alreadySeen
source
{
}
)
;
getPlainObjectKeys
(
source
)
.
forEach
(
function
(
key
)
{
_res3
[
key
]
=
toJSHelper
(
source
[
key
]
__alreadySeen
)
;
}
)
;
return
_res3
;
}
}
function
toJS
(
source
options
)
{
if
(
false
)
{
}
return
toJSHelper
(
source
new
Map
(
)
)
;
}
function
trace
(
)
{
if
(
true
)
die
(
"
trace
(
)
is
not
available
in
production
builds
"
)
;
var
enterBreakPoint
=
false
;
for
(
var
_len
=
arguments
.
length
args
=
new
Array
(
_len
)
_key
=
0
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
]
=
arguments
[
_key
]
;
}
if
(
typeof
args
[
args
.
length
-
1
]
=
=
=
"
boolean
"
)
enterBreakPoint
=
args
.
pop
(
)
;
var
derivation
=
getAtomFromArgs
(
args
)
;
if
(
!
derivation
)
{
return
die
(
"
'
trace
(
break
?
)
'
can
only
be
used
inside
a
tracked
computed
value
or
a
Reaction
.
Consider
passing
in
the
computed
value
or
reaction
explicitly
"
)
;
}
if
(
derivation
.
isTracing_
=
=
=
TraceMode
.
NONE
)
{
console
.
log
(
"
[
mobx
.
trace
]
'
"
+
derivation
.
name_
+
"
'
tracing
enabled
"
)
;
}
derivation
.
isTracing_
=
enterBreakPoint
?
TraceMode
.
BREAK
:
TraceMode
.
LOG
;
}
function
getAtomFromArgs
(
args
)
{
switch
(
args
.
length
)
{
case
0
:
return
globalState
.
trackingDerivation
;
case
1
:
return
getAtom
(
args
[
0
]
)
;
case
2
:
return
getAtom
(
args
[
0
]
args
[
1
]
)
;
}
}
function
transaction
(
action
thisArg
)
{
if
(
thisArg
=
=
=
void
0
)
{
thisArg
=
undefined
;
}
startBatch
(
)
;
try
{
return
action
.
apply
(
thisArg
)
;
}
finally
{
endBatch
(
)
;
}
}
function
when
(
predicate
arg1
arg2
)
{
if
(
arguments
.
length
=
=
=
1
|
|
arg1
&
&
typeof
arg1
=
=
=
"
object
"
)
return
whenPromise
(
predicate
arg1
)
;
return
_when
(
predicate
arg1
arg2
|
|
{
}
)
;
}
function
_when
(
predicate
effect
opts
)
{
var
timeoutHandle
;
if
(
typeof
opts
.
timeout
=
=
=
"
number
"
)
{
timeoutHandle
=
setTimeout
(
function
(
)
{
if
(
!
disposer
[
mobx
]
.
isDisposed_
)
{
disposer
(
)
;
var
error
=
new
Error
(
"
WHEN_TIMEOUT
"
)
;
if
(
opts
.
onError
)
opts
.
onError
(
error
)
;
else
throw
error
;
}
}
opts
.
timeout
)
;
}
opts
.
name
=
opts
.
name
|
|
"
When
"
+
getNextId
(
)
;
var
effectAction
=
createAction
(
opts
.
name
+
"
-
effect
"
effect
)
;
var
disposer
=
autorun
(
function
(
r
)
{
var
cond
=
allowStateChanges
(
false
predicate
)
;
if
(
cond
)
{
r
.
dispose
(
)
;
if
(
timeoutHandle
)
clearTimeout
(
timeoutHandle
)
;
effectAction
(
)
;
}
}
opts
)
;
return
disposer
;
}
function
whenPromise
(
predicate
opts
)
{
if
(
false
)
{
}
var
cancel
;
var
res
=
new
Promise
(
function
(
resolve
reject
)
{
var
disposer
=
_when
(
predicate
resolve
_extends
(
{
}
opts
{
onError
:
reject
}
)
)
;
cancel
=
function
cancel
(
)
{
disposer
(
)
;
reject
(
"
WHEN_CANCELLED
"
)
;
}
;
}
)
;
res
.
cancel
=
cancel
;
return
res
;
}
function
getAdm
(
target
)
{
return
target
[
mobx
]
;
}
var
objectProxyTraps
=
{
has
:
function
has
(
target
name
)
{
if
(
name
=
=
=
mobx
|
|
name
=
=
=
"
constructor
"
)
return
true
;
if
(
false
)
{
}
var
adm
=
getAdm
(
target
)
;
if
(
isStringish
(
name
)
)
return
adm
.
has_
(
name
)
;
return
name
in
target
;
}
get
:
function
get
(
target
name
)
{
if
(
name
=
=
=
mobx
|
|
name
=
=
=
"
constructor
"
)
return
target
[
name
]
;
var
adm
=
getAdm
(
target
)
;
var
observable
=
adm
.
values_
.
get
(
name
)
;
if
(
observable
instanceof
Atom
)
{
var
result
=
observable
.
get
(
)
;
if
(
result
=
=
=
undefined
)
{
adm
.
has_
(
name
)
;
}
return
result
;
}
if
(
isStringish
(
name
)
)
adm
.
has_
(
name
)
;
return
target
[
name
]
;
}
set
:
function
set
1
(
target
name
value
)
{
if
(
!
isStringish
(
name
)
)
return
false
;
if
(
false
)
{
}
set
(
target
name
value
)
;
return
true
;
}
deleteProperty
:
function
deleteProperty
(
target
name
)
{
if
(
false
)
{
}
if
(
!
isStringish
(
name
)
)
return
false
;
var
adm
=
getAdm
(
target
)
;
adm
.
remove_
(
name
)
;
return
true
;
}
ownKeys
:
function
ownKeys
(
target
)
{
if
(
false
)
{
}
var
adm
=
getAdm
(
target
)
;
adm
.
keysAtom_
.
reportObserved
(
)
;
return
Reflect
.
ownKeys
(
target
)
;
}
preventExtensions
:
function
preventExtensions
(
target
)
{
die
(
13
)
;
}
}
;
function
createDynamicObservableObject
(
base
)
{
assertProxies
(
)
;
var
proxy
=
new
Proxy
(
base
objectProxyTraps
)
;
base
[
mobx
]
.
proxy_
=
proxy
;
return
proxy
;
}
function
hasInterceptors
(
interceptable
)
{
return
interceptable
.
interceptors_
!
=
=
undefined
&
&
interceptable
.
interceptors_
.
length
>
0
;
}
function
registerInterceptor
(
interceptable
handler
)
{
var
interceptors
=
interceptable
.
interceptors_
|
|
(
interceptable
.
interceptors_
=
[
]
)
;
interceptors
.
push
(
handler
)
;
return
once
(
function
(
)
{
var
idx
=
interceptors
.
indexOf
(
handler
)
;
if
(
idx
!
=
=
-
1
)
interceptors
.
splice
(
idx
1
)
;
}
)
;
}
function
interceptChange
(
interceptable
change
)
{
var
prevU
=
untrackedStart
(
)
;
try
{
var
interceptors
=
[
]
.
concat
(
interceptable
.
interceptors_
|
|
[
]
)
;
for
(
var
i
=
0
l
=
interceptors
.
length
;
i
<
l
;
i
+
+
)
{
change
=
interceptors
[
i
]
(
change
)
;
if
(
change
&
&
!
change
.
type
)
die
(
14
)
;
if
(
!
change
)
break
;
}
return
change
;
}
finally
{
untrackedEnd
(
prevU
)
;
}
}
function
hasListeners
(
listenable
)
{
return
listenable
.
changeListeners_
!
=
=
undefined
&
&
listenable
.
changeListeners_
.
length
>
0
;
}
function
registerListener
(
listenable
handler
)
{
var
listeners
=
listenable
.
changeListeners_
|
|
(
listenable
.
changeListeners_
=
[
]
)
;
listeners
.
push
(
handler
)
;
return
once
(
function
(
)
{
var
idx
=
listeners
.
indexOf
(
handler
)
;
if
(
idx
!
=
=
-
1
)
listeners
.
splice
(
idx
1
)
;
}
)
;
}
function
notifyListeners
(
listenable
change
)
{
var
prevU
=
untrackedStart
(
)
;
var
listeners
=
listenable
.
changeListeners_
;
if
(
!
listeners
)
return
;
listeners
=
listeners
.
slice
(
)
;
for
(
var
i
=
0
l
=
listeners
.
length
;
i
<
l
;
i
+
+
)
{
listeners
[
i
]
(
change
)
;
}
untrackedEnd
(
prevU
)
;
}
var
CACHED_ANNOTATIONS
=
Symbol
(
"
mobx
-
cached
-
annotations
"
)
;
function
makeAction
(
target
key
name
fn
asAutoAction
)
{
addHiddenProp
(
target
key
asAutoAction
?
autoAction
(
name
|
|
key
fn
)
:
action
(
name
|
|
key
fn
)
)
;
}
function
getInferredAnnotation
(
desc
defaultAnnotation
autoBind
)
{
if
(
desc
.
get
)
return
computed
;
if
(
desc
.
set
)
return
false
;
if
(
isFunction
(
desc
.
value
)
)
return
isGenerator
(
desc
.
value
)
?
flow
:
isAction
(
desc
.
value
)
?
false
:
autoBind
?
autoAction
.
bound
:
autoAction
;
return
defaultAnnotation
!
=
null
?
defaultAnnotation
:
observable
.
deep
;
}
function
getDescriptorInChain
(
target
prop
)
{
var
current
=
target
;
while
(
current
&
&
current
!
=
=
objectPrototype
)
{
var
desc
=
getDescriptor
(
current
prop
)
;
if
(
desc
)
{
return
[
desc
current
]
;
}
current
=
Object
.
getPrototypeOf
(
current
)
;
}
die
(
1
prop
)
;
}
function
makeProperty
(
adm
owner
key
descriptor
annotation
forceCopy
autoBind
)
{
var
_annotation
annotatio
;
var
target
=
adm
.
target_
;
var
defaultAnnotation
=
observable
;
var
originAnnotation
=
annotation
;
if
(
annotation
=
=
=
true
)
{
annotation
=
getInferredAnnotation
(
descriptor
defaultAnnotation
autoBind
)
;
}
if
(
annotation
=
=
=
false
)
{
if
(
forceCopy
)
{
defineProperty
(
target
key
descriptor
)
;
}
return
;
}
if
(
!
annotation
|
|
annotation
=
=
=
true
|
|
!
annotation
.
annotationType_
)
{
return
die
(
2
key
)
;
}
var
type
=
annotation
.
annotationType_
;
switch
(
type
)
{
case
AUTOACTION
:
case
ACTION
:
{
var
fn
=
descriptor
.
value
;
if
(
!
isFunction
(
fn
)
)
die
(
3
key
)
;
if
(
owner
!
=
=
target
&
&
!
forceCopy
)
{
if
(
!
isAction
(
owner
[
key
]
)
)
makeAction
(
owner
key
annotation
.
arg_
fn
type
=
=
=
AUTOACTION
)
;
}
else
{
makeAction
(
target
key
annotation
.
arg_
fn
type
=
=
=
AUTOACTION
)
;
}
break
;
}
case
AUTOACTION_BOUND
:
case
ACTION_BOUND
:
{
var
_fn
=
descriptor
.
value
;
if
(
!
isFunction
(
_fn
)
)
die
(
3
key
)
;
makeAction
(
target
key
annotation
.
arg_
_fn
.
bind
(
adm
.
proxy_
|
|
target
)
type
=
=
=
AUTOACTION_BOUND
)
;
break
;
}
case
FLOW
:
{
if
(
owner
!
=
=
target
&
&
!
forceCopy
)
{
if
(
!
isFlow
(
owner
[
key
]
)
)
addHiddenProp
(
owner
key
flow
(
descriptor
.
value
)
)
;
}
else
{
addHiddenProp
(
target
key
flow
(
descriptor
.
value
)
)
;
}
break
;
}
case
COMPUTED
:
case
COMPUTED_STRUCT
:
{
if
(
!
descriptor
.
get
)
die
(
4
key
)
;
adm
.
addComputedProp_
(
target
key
_extends
(
{
get
:
descriptor
.
get
set
:
descriptor
.
set
compareStructural
:
annotation
.
annotationType_
=
=
=
COMPUTED_STRUCT
}
annotation
.
arg_
)
)
;
break
;
}
case
OBSERVABLE
:
case
OBSERVABLE_REF
:
case
OBSERVABLE_SHALLOW
:
case
OBSERVABLE_STRUCT
:
{
if
(
false
)
{
}
if
(
false
)
{
}
var
enhancer
=
originAnnotation
=
=
=
true
?
adm
.
defaultEnhancer_
:
getEnhancerFromAnnotation
(
annotation
)
;
adm
.
addObservableProp_
(
key
descriptor
.
value
enhancer
)
;
break
;
}
default
:
if
(
false
)
{
}
}
}
function
makeObservable
(
target
annotations
options
)
{
var
autoBind
=
!
!
(
options
=
=
null
?
void
0
:
options
.
autoBind
)
;
var
adm
=
asObservableObject
(
target
options
=
=
null
?
void
0
:
options
.
name
getEnhancerFromAnnotation
(
options
=
=
null
?
void
0
:
options
.
defaultDecorator
)
)
;
startBatch
(
)
;
try
{
if
(
!
annotations
)
{
var
didDecorate
=
applyDecorators
(
target
)
;
if
(
false
)
{
}
return
target
;
}
var
make
=
function
make
(
key
)
{
var
annotation
=
annotations
[
key
]
;
var
_getDescriptorInChain
=
getDescriptorInChain
(
target
key
)
desc
=
_getDescriptorInChain
[
0
]
owner
=
_getDescriptorInChain
[
1
]
;
makeProperty
(
adm
owner
key
desc
annotation
false
autoBind
)
;
}
;
ownKeys
(
annotations
)
.
forEach
(
make
)
;
}
finally
{
endBatch
(
)
;
}
return
target
;
}
function
makeAutoObservable
(
target
overrides
options
)
{
var
proto
=
Object
.
getPrototypeOf
(
target
)
;
var
isPlain
=
proto
=
=
null
|
|
proto
=
=
=
objectPrototype
;
if
(
false
)
{
}
var
annotations
;
if
(
!
isPlain
&
&
hasProp
(
proto
CACHED_ANNOTATIONS
)
)
{
annotations
=
proto
[
CACHED_ANNOTATIONS
]
;
}
else
{
annotations
=
_extends
(
{
}
overrides
)
;
extractAnnotationsFromObject
(
target
annotations
options
)
;
if
(
!
isPlain
)
{
extractAnnotationsFromProto
(
proto
annotations
options
)
;
addHiddenProp
(
proto
CACHED_ANNOTATIONS
annotations
)
;
}
}
makeObservable
(
target
annotations
options
)
;
return
target
;
}
function
extractAnnotationsFromObject
(
target
collector
options
)
{
var
_options
defaultDecor
;
var
autoBind
=
!
!
(
options
=
=
null
?
void
0
:
options
.
autoBind
)
;
var
defaultAnnotation
=
(
options
=
=
null
?
void
0
:
options
.
deep
)
=
=
=
undefined
?
(
_options
defaultDecor
=
options
=
=
null
?
void
0
:
options
.
defaultDecorator
)
!
=
null
?
_options
defaultDecor
:
observable
.
deep
:
(
options
=
=
null
?
void
0
:
options
.
deep
)
?
observable
.
deep
:
observable
.
ref
;
Object
.
entries
(
getOwnPropertyDescriptors
(
target
)
)
.
forEach
(
function
(
_ref
)
{
var
key
=
_ref
[
0
]
descriptor
=
_ref
[
1
]
;
if
(
key
in
collector
|
|
key
=
=
=
"
constructor
"
)
return
;
collector
[
key
]
=
getInferredAnnotation
(
descriptor
defaultAnnotation
autoBind
)
;
}
)
;
}
function
extractAnnotationsFromProto
(
proto
collector
options
)
{
Object
.
entries
(
getOwnPropertyDescriptors
(
proto
)
)
.
forEach
(
function
(
_ref2
)
{
var
key
=
_ref2
[
0
]
prop
=
_ref2
[
1
]
;
if
(
key
in
collector
|
|
key
=
=
=
"
constructor
"
)
return
;
if
(
prop
.
get
)
{
collector
[
key
]
=
computed
;
}
else
if
(
isFunction
(
prop
.
value
)
)
{
collector
[
key
]
=
isGenerator
(
prop
.
value
)
?
flow
:
(
options
=
=
null
?
void
0
:
options
.
autoBind
)
?
autoAction
.
bound
:
autoAction
;
}
}
)
;
}
var
SPLICE
=
"
splice
"
;
var
UPDATE
=
"
update
"
;
var
MAX_SPLICE_SIZE
=
10000
;
var
arrayTraps
=
{
get
:
function
get
(
target
name
)
{
var
adm
=
target
[
mobx
]
;
if
(
name
=
=
=
mobx
)
return
adm
;
if
(
name
=
=
=
"
length
"
)
return
adm
.
getArrayLength_
(
)
;
if
(
typeof
name
=
=
=
"
string
"
&
&
!
isNaN
(
name
)
)
{
return
adm
.
get_
(
parseInt
(
name
)
)
;
}
if
(
hasProp
(
arrayExtensions
name
)
)
{
return
arrayExtensions
[
name
]
;
}
return
target
[
name
]
;
}
set
:
function
set
(
target
name
value
)
{
var
adm
=
target
[
mobx
]
;
if
(
name
=
=
=
"
length
"
)
{
adm
.
setArrayLength_
(
value
)
;
}
if
(
typeof
name
=
=
=
"
symbol
"
|
|
isNaN
(
name
)
)
{
target
[
name
]
=
value
;
}
else
{
adm
.
set_
(
parseInt
(
name
)
value
)
;
}
return
true
;
}
preventExtensions
:
function
preventExtensions
(
)
{
die
(
15
)
;
}
}
;
var
ObservableArrayAdministration
=
function
(
)
{
function
ObservableArrayAdministration
(
name
enhancer
owned_
legacyMode_
)
{
this
.
owned_
=
void
0
;
this
.
legacyMode_
=
void
0
;
this
.
atom_
=
void
0
;
this
.
values_
=
[
]
;
this
.
interceptors_
=
void
0
;
this
.
changeListeners_
=
void
0
;
this
.
enhancer_
=
void
0
;
this
.
dehancer
=
void
0
;
this
.
proxy_
=
void
0
;
this
.
lastKnownLength_
=
0
;
this
.
owned_
=
owned_
;
this
.
legacyMode_
=
legacyMode_
;
this
.
atom_
=
new
Atom
(
name
|
|
"
ObservableArray
"
+
getNextId
(
)
)
;
this
.
enhancer_
=
function
(
newV
oldV
)
{
return
enhancer
(
newV
oldV
name
+
"
[
.
.
]
"
)
;
}
;
}
var
_proto
=
ObservableArrayAdministration
.
prototype
;
_proto
.
dehanceValue_
=
function
dehanceValue_
(
value
)
{
if
(
this
.
dehancer
!
=
=
undefined
)
return
this
.
dehancer
(
value
)
;
return
value
;
}
;
_proto
.
dehanceValues_
=
function
dehanceValues_
(
values
)
{
if
(
this
.
dehancer
!
=
=
undefined
&
&
values
.
length
>
0
)
return
values
.
map
(
this
.
dehancer
)
;
return
values
;
}
;
_proto
.
intercept_
=
function
intercept_
(
handler
)
{
return
registerInterceptor
(
this
handler
)
;
}
;
_proto
.
observe_
=
function
observe_
(
listener
fireImmediately
)
{
if
(
fireImmediately
=
=
=
void
0
)
{
fireImmediately
=
false
;
}
if
(
fireImmediately
)
{
listener
(
{
observableKind
:
"
array
"
object
:
this
.
proxy_
debugObjectName
:
this
.
atom_
.
name_
type
:
"
splice
"
index
:
0
added
:
this
.
values_
.
slice
(
)
addedCount
:
this
.
values_
.
length
removed
:
[
]
removedCount
:
0
}
)
;
}
return
registerListener
(
this
listener
)
;
}
;
_proto
.
getArrayLength_
=
function
getArrayLength_
(
)
{
this
.
atom_
.
reportObserved
(
)
;
return
this
.
values_
.
length
;
}
;
_proto
.
setArrayLength_
=
function
setArrayLength_
(
newLength
)
{
if
(
typeof
newLength
!
=
=
"
number
"
|
|
newLength
<
0
)
die
(
"
Out
of
range
:
"
+
newLength
)
;
var
currentLength
=
this
.
values_
.
length
;
if
(
newLength
=
=
=
currentLength
)
return
;
else
if
(
newLength
>
currentLength
)
{
var
newItems
=
new
Array
(
newLength
-
currentLength
)
;
for
(
var
i
=
0
;
i
<
newLength
-
currentLength
;
i
+
+
)
{
newItems
[
i
]
=
undefined
;
}
this
.
spliceWithArray_
(
currentLength
0
newItems
)
;
}
else
this
.
spliceWithArray_
(
newLength
currentLength
-
newLength
)
;
}
;
_proto
.
updateArrayLength_
=
function
updateArrayLength_
(
oldLength
delta
)
{
if
(
oldLength
!
=
=
this
.
lastKnownLength_
)
die
(
16
)
;
this
.
lastKnownLength_
+
=
delta
;
if
(
this
.
legacyMode_
&
&
delta
>
0
)
reserveArrayBuffer
(
oldLength
+
delta
+
1
)
;
}
;
_proto
.
spliceWithArray_
=
function
spliceWithArray_
(
index
deleteCount
newItems
)
{
var
_this
=
this
;
checkIfStateModificationsAreAllowed
(
this
.
atom_
)
;
var
length
=
this
.
values_
.
length
;
if
(
index
=
=
=
undefined
)
index
=
0
;
else
if
(
index
>
length
)
index
=
length
;
else
if
(
index
<
0
)
index
=
Math
.
max
(
0
length
+
index
)
;
if
(
arguments
.
length
=
=
=
1
)
deleteCount
=
length
-
index
;
else
if
(
deleteCount
=
=
=
undefined
|
|
deleteCount
=
=
=
null
)
deleteCount
=
0
;
else
deleteCount
=
Math
.
max
(
0
Math
.
min
(
deleteCount
length
-
index
)
)
;
if
(
newItems
=
=
=
undefined
)
newItems
=
EMPTY_ARRAY
;
if
(
hasInterceptors
(
this
)
)
{
var
change
=
interceptChange
(
this
{
object
:
this
.
proxy_
type
:
SPLICE
index
:
index
removedCount
:
deleteCount
added
:
newItems
}
)
;
if
(
!
change
)
return
EMPTY_ARRAY
;
deleteCount
=
change
.
removedCount
;
newItems
=
change
.
added
;
}
newItems
=
newItems
.
length
=
=
=
0
?
newItems
:
newItems
.
map
(
function
(
v
)
{
return
_this
.
enhancer_
(
v
undefined
)
;
}
)
;
if
(
this
.
legacyMode_
|
|
"
production
"
!
=
=
"
production
"
)
{
var
lengthDelta
=
newItems
.
length
-
deleteCount
;
this
.
updateArrayLength_
(
length
lengthDelta
)
;
}
var
res
=
this
.
spliceItemsIntoValues_
(
index
deleteCount
newItems
)
;
if
(
deleteCount
!
=
=
0
|
|
newItems
.
length
!
=
=
0
)
this
.
notifyArraySplice_
(
index
newItems
res
)
;
return
this
.
dehanceValues_
(
res
)
;
}
;
_proto
.
spliceItemsIntoValues_
=
function
spliceItemsIntoValues_
(
index
deleteCount
newItems
)
{
if
(
newItems
.
length
<
MAX_SPLICE_SIZE
)
{
var
_this
values_
;
return
(
_this
values_
=
this
.
values_
)
.
splice
.
apply
(
_this
values_
[
index
deleteCount
]
.
concat
(
newItems
)
)
;
}
else
{
var
res
=
this
.
values_
.
slice
(
index
index
+
deleteCount
)
;
var
oldItems
=
this
.
values_
.
slice
(
index
+
deleteCount
)
;
this
.
values_
.
length
=
index
+
newItems
.
length
-
deleteCount
;
for
(
var
i
=
0
;
i
<
newItems
.
length
;
i
+
+
)
{
this
.
values_
[
index
+
i
]
=
newItems
[
i
]
;
}
for
(
var
_i
=
0
;
_i
<
oldItems
.
length
;
_i
+
+
)
{
this
.
values_
[
index
+
newItems
.
length
+
_i
]
=
oldItems
[
_i
]
;
}
return
res
;
}
}
;
_proto
.
notifyArrayChildUpdate_
=
function
notifyArrayChildUpdate_
(
index
newValue
oldValue
)
{
var
notifySpy
=
!
this
.
owned_
&
&
isSpyEnabled
(
)
;
var
notify
=
hasListeners
(
this
)
;
var
change
=
notify
|
|
notifySpy
?
{
observableKind
:
"
array
"
object
:
this
.
proxy_
type
:
UPDATE
debugObjectName
:
this
.
atom_
.
name_
index
:
index
newValue
:
newValue
oldValue
:
oldValue
}
:
null
;
if
(
false
)
{
}
this
.
atom_
.
reportChanged
(
)
;
if
(
notify
)
notifyListeners
(
this
change
)
;
if
(
false
)
{
}
}
;
_proto
.
notifyArraySplice_
=
function
notifyArraySplice_
(
index
added
removed
)
{
var
notifySpy
=
!
this
.
owned_
&
&
isSpyEnabled
(
)
;
var
notify
=
hasListeners
(
this
)
;
var
change
=
notify
|
|
notifySpy
?
{
observableKind
:
"
array
"
object
:
this
.
proxy_
debugObjectName
:
this
.
atom_
.
name_
type
:
SPLICE
index
:
index
removed
:
removed
added
:
added
removedCount
:
removed
.
length
addedCount
:
added
.
length
}
:
null
;
if
(
false
)
{
}
this
.
atom_
.
reportChanged
(
)
;
if
(
notify
)
notifyListeners
(
this
change
)
;
if
(
false
)
{
}
}
;
_proto
.
get_
=
function
get_
(
index
)
{
if
(
index
<
this
.
values_
.
length
)
{
this
.
atom_
.
reportObserved
(
)
;
return
this
.
dehanceValue_
(
this
.
values_
[
index
]
)
;
}
console
.
warn
(
false
?
0
:
"
[
mobx
.
array
]
Attempt
to
read
an
array
index
(
"
+
index
+
"
)
that
is
out
of
bounds
(
"
+
this
.
values_
.
length
+
"
)
.
Please
check
length
first
.
Out
of
bound
indices
will
not
be
tracked
by
MobX
"
)
;
}
;
_proto
.
set_
=
function
set_
(
index
newValue
)
{
var
values
=
this
.
values_
;
if
(
index
<
values
.
length
)
{
checkIfStateModificationsAreAllowed
(
this
.
atom_
)
;
var
oldValue
=
values
[
index
]
;
if
(
hasInterceptors
(
this
)
)
{
var
change
=
interceptChange
(
this
{
type
:
UPDATE
object
:
this
.
proxy_
index
:
index
newValue
:
newValue
}
)
;
if
(
!
change
)
return
;
newValue
=
change
.
newValue
;
}
newValue
=
this
.
enhancer_
(
newValue
oldValue
)
;
var
changed
=
newValue
!
=
=
oldValue
;
if
(
changed
)
{
values
[
index
]
=
newValue
;
this
.
notifyArrayChildUpdate_
(
index
newValue
oldValue
)
;
}
}
else
if
(
index
=
=
=
values
.
length
)
{
this
.
spliceWithArray_
(
index
0
[
newValue
]
)
;
}
else
{
die
(
17
index
values
.
length
)
;
}
}
;
return
ObservableArrayAdministration
;
}
(
)
;
function
createObservableArray
(
initialValues
enhancer
name
owned
)
{
if
(
name
=
=
=
void
0
)
{
name
=
"
ObservableArray
"
+
getNextId
(
)
;
}
if
(
owned
=
=
=
void
0
)
{
owned
=
false
;
}
assertProxies
(
)
;
var
adm
=
new
ObservableArrayAdministration
(
name
enhancer
owned
false
)
;
addHiddenFinalProp
(
adm
.
values_
mobx
adm
)
;
var
proxy
=
new
Proxy
(
adm
.
values_
arrayTraps
)
;
adm
.
proxy_
=
proxy
;
if
(
initialValues
&
&
initialValues
.
length
)
{
var
prev
=
allowStateChangesStart
(
true
)
;
adm
.
spliceWithArray_
(
0
0
initialValues
)
;
allowStateChangesEnd
(
prev
)
;
}
return
proxy
;
}
var
arrayExtensions
=
{
clear
:
function
clear
(
)
{
return
this
.
splice
(
0
)
;
}
replace
:
function
replace
(
newItems
)
{
var
adm
=
this
[
mobx
]
;
return
adm
.
spliceWithArray_
(
0
adm
.
values_
.
length
newItems
)
;
}
toJSON
:
function
toJSON
(
)
{
return
this
.
slice
(
)
;
}
splice
:
function
splice
(
index
deleteCount
)
{
for
(
var
_len
=
arguments
.
length
newItems
=
new
Array
(
_len
>
2
?
_len
-
2
:
0
)
_key
=
2
;
_key
<
_len
;
_key
+
+
)
{
newItems
[
_key
-
2
]
=
arguments
[
_key
]
;
}
var
adm
=
this
[
mobx
]
;
switch
(
arguments
.
length
)
{
case
0
:
return
[
]
;
case
1
:
return
adm
.
spliceWithArray_
(
index
)
;
case
2
:
return
adm
.
spliceWithArray_
(
index
deleteCount
)
;
}
return
adm
.
spliceWithArray_
(
index
deleteCount
newItems
)
;
}
spliceWithArray
:
function
spliceWithArray
(
index
deleteCount
newItems
)
{
return
this
[
mobx
]
.
spliceWithArray_
(
index
deleteCount
newItems
)
;
}
push
:
function
push
(
)
{
var
adm
=
this
[
mobx
]
;
for
(
var
_len2
=
arguments
.
length
items
=
new
Array
(
_len2
)
_key2
=
0
;
_key2
<
_len2
;
_key2
+
+
)
{
items
[
_key2
]
=
arguments
[
_key2
]
;
}
adm
.
spliceWithArray_
(
adm
.
values_
.
length
0
items
)
;
return
adm
.
values_
.
length
;
}
pop
:
function
pop
(
)
{
return
this
.
splice
(
Math
.
max
(
this
[
mobx
]
.
values_
.
length
-
1
0
)
1
)
[
0
]
;
}
shift
:
function
shift
(
)
{
return
this
.
splice
(
0
1
)
[
0
]
;
}
unshift
:
function
unshift
(
)
{
var
adm
=
this
[
mobx
]
;
for
(
var
_len3
=
arguments
.
length
items
=
new
Array
(
_len3
)
_key3
=
0
;
_key3
<
_len3
;
_key3
+
+
)
{
items
[
_key3
]
=
arguments
[
_key3
]
;
}
adm
.
spliceWithArray_
(
0
0
items
)
;
return
adm
.
values_
.
length
;
}
reverse
:
function
reverse
(
)
{
if
(
globalState
.
trackingDerivation
)
{
die
(
37
"
reverse
"
)
;
}
this
.
replace
(
this
.
slice
(
)
.
reverse
(
)
)
;
return
this
;
}
sort
:
function
sort
(
)
{
if
(
globalState
.
trackingDerivation
)
{
die
(
37
"
sort
"
)
;
}
var
copy
=
this
.
slice
(
)
;
copy
.
sort
.
apply
(
copy
arguments
)
;
this
.
replace
(
copy
)
;
return
this
;
}
remove
:
function
remove
(
value
)
{
var
adm
=
this
[
mobx
]
;
var
idx
=
adm
.
dehanceValues_
(
adm
.
values_
)
.
indexOf
(
value
)
;
if
(
idx
>
-
1
)
{
this
.
splice
(
idx
1
)
;
return
true
;
}
return
false
;
}
}
;
addArrayExtension
(
"
concat
"
simpleFunc
)
;
addArrayExtension
(
"
flat
"
simpleFunc
)
;
addArrayExtension
(
"
includes
"
simpleFunc
)
;
addArrayExtension
(
"
indexOf
"
simpleFunc
)
;
addArrayExtension
(
"
join
"
simpleFunc
)
;
addArrayExtension
(
"
lastIndexOf
"
simpleFunc
)
;
addArrayExtension
(
"
slice
"
simpleFunc
)
;
addArrayExtension
(
"
toString
"
simpleFunc
)
;
addArrayExtension
(
"
toLocaleString
"
simpleFunc
)
;
addArrayExtension
(
"
every
"
mapLikeFunc
)
;
addArrayExtension
(
"
filter
"
mapLikeFunc
)
;
addArrayExtension
(
"
find
"
mapLikeFunc
)
;
addArrayExtension
(
"
findIndex
"
mapLikeFunc
)
;
addArrayExtension
(
"
flatMap
"
mapLikeFunc
)
;
addArrayExtension
(
"
forEach
"
mapLikeFunc
)
;
addArrayExtension
(
"
map
"
mapLikeFunc
)
;
addArrayExtension
(
"
some
"
mapLikeFunc
)
;
addArrayExtension
(
"
reduce
"
reduceLikeFunc
)
;
addArrayExtension
(
"
reduceRight
"
reduceLikeFunc
)
;
function
addArrayExtension
(
funcName
funcFactory
)
{
if
(
typeof
Array
.
prototype
[
funcName
]
=
=
=
"
function
"
)
{
arrayExtensions
[
funcName
]
=
funcFactory
(
funcName
)
;
}
}
function
simpleFunc
(
funcName
)
{
return
function
(
)
{
var
adm
=
this
[
mobx
]
;
adm
.
atom_
.
reportObserved
(
)
;
var
dehancedValues
=
adm
.
dehanceValues_
(
adm
.
values_
)
;
return
dehancedValues
[
funcName
]
.
apply
(
dehancedValues
arguments
)
;
}
;
}
function
mapLikeFunc
(
funcName
)
{
return
function
(
callback
thisArg
)
{
var
_this2
=
this
;
var
adm
=
this
[
mobx
]
;
adm
.
atom_
.
reportObserved
(
)
;
var
dehancedValues
=
adm
.
dehanceValues_
(
adm
.
values_
)
;
return
dehancedValues
[
funcName
]
(
function
(
element
index
)
{
return
callback
.
call
(
thisArg
element
index
_this2
)
;
}
)
;
}
;
}
function
reduceLikeFunc
(
funcName
)
{
return
function
(
)
{
var
_this3
=
this
;
var
adm
=
this
[
mobx
]
;
adm
.
atom_
.
reportObserved
(
)
;
var
dehancedValues
=
adm
.
dehanceValues_
(
adm
.
values_
)
;
var
callback
=
arguments
[
0
]
;
arguments
[
0
]
=
function
(
accumulator
currentValue
index
)
{
return
callback
(
accumulator
currentValue
index
_this3
)
;
}
;
return
dehancedValues
[
funcName
]
.
apply
(
dehancedValues
arguments
)
;
}
;
}
var
isObservableArrayAdministration
=
createInstanceofPredicate
(
"
ObservableArrayAdministration
"
ObservableArrayAdministration
)
;
function
isObservableArray
(
thing
)
{
return
isObject
(
thing
)
&
&
isObservableArrayAdministration
(
thing
[
mobx
]
)
;
}
var
_Symbol
iterator
_Symbol
toStringTag
;
var
ObservableMapMarker
=
{
}
;
var
ADD
=
"
add
"
;
var
DELETE
=
"
delete
"
;
_Symbol
iterator
=
Symbol
.
iterator
;
_Symbol
toStringTag
=
Symbol
.
toStringTag
;
var
ObservableMap
=
function
(
)
{
function
ObservableMap
(
initialData
enhancer_
name_
)
{
if
(
enhancer_
=
=
=
void
0
)
{
enhancer_
=
deepEnhancer
;
}
if
(
name_
=
=
=
void
0
)
{
name_
=
"
ObservableMap
"
+
getNextId
(
)
;
}
this
.
enhancer_
=
void
0
;
this
.
name_
=
void
0
;
this
[
mobx
]
=
ObservableMapMarker
;
this
.
data_
=
void
0
;
this
.
hasMap_
=
void
0
;
this
.
keysAtom_
=
void
0
;
this
.
interceptors_
=
void
0
;
this
.
changeListeners_
=
void
0
;
this
.
dehancer
=
void
0
;
this
.
enhancer_
=
enhancer_
;
this
.
name_
=
name_
;
if
(
!
isFunction
(
Map
)
)
{
die
(
18
)
;
}
this
.
keysAtom_
=
createAtom
(
this
.
name_
+
"
.
keys
(
)
"
)
;
this
.
data_
=
new
Map
(
)
;
this
.
hasMap_
=
new
Map
(
)
;
this
.
merge
(
initialData
)
;
}
var
_proto
=
ObservableMap
.
prototype
;
_proto
.
has_
=
function
has_
(
key
)
{
return
this
.
data_
.
has
(
key
)
;
}
;
_proto
.
has
=
function
has
(
key
)
{
var
_this
=
this
;
if
(
!
globalState
.
trackingDerivation
)
return
this
.
has_
(
key
)
;
var
entry
=
this
.
hasMap_
.
get
(
key
)
;
if
(
!
entry
)
{
var
newEntry
=
entry
=
new
ObservableValue
(
this
.
has_
(
key
)
referenceEnhancer
this
.
name_
+
"
.
"
+
stringifyKey
(
key
)
+
"
?
"
false
)
;
this
.
hasMap_
.
set
(
key
newEntry
)
;
onBecomeUnobserved
(
newEntry
function
(
)
{
return
_this
.
hasMap_
[
"
delete
"
]
(
key
)
;
}
)
;
}
return
entry
.
get
(
)
;
}
;
_proto
.
set
=
function
set
(
key
value
)
{
var
hasKey
=
this
.
has_
(
key
)
;
if
(
hasInterceptors
(
this
)
)
{
var
change
=
interceptChange
(
this
{
type
:
hasKey
?
UPDATE
:
ADD
object
:
this
newValue
:
value
name
:
key
}
)
;
if
(
!
change
)
return
this
;
value
=
change
.
newValue
;
}
if
(
hasKey
)
{
this
.
updateValue_
(
key
value
)
;
}
else
{
this
.
addValue_
(
key
value
)
;
}
return
this
;
}
;
_proto
[
"
delete
"
]
=
function
_delete
(
key
)
{
var
_this2
=
this
;
checkIfStateModificationsAreAllowed
(
this
.
keysAtom_
)
;
if
(
hasInterceptors
(
this
)
)
{
var
change
=
interceptChange
(
this
{
type
:
DELETE
object
:
this
name
:
key
}
)
;
if
(
!
change
)
return
false
;
}
if
(
this
.
has_
(
key
)
)
{
var
notifySpy
=
isSpyEnabled
(
)
;
var
notify
=
hasListeners
(
this
)
;
var
_change
=
notify
|
|
notifySpy
?
{
observableKind
:
"
map
"
debugObjectName
:
this
.
name_
type
:
DELETE
object
:
this
oldValue
:
this
.
data_
.
get
(
key
)
.
value_
name
:
key
}
:
null
;
if
(
false
)
{
}
transaction
(
function
(
)
{
_this2
.
keysAtom_
.
reportChanged
(
)
;
_this2
.
updateHasMapEntry_
(
key
false
)
;
var
observable
=
_this2
.
data_
.
get
(
key
)
;
observable
.
setNewValue_
(
undefined
)
;
_this2
.
data_
[
"
delete
"
]
(
key
)
;
}
)
;
if
(
notify
)
notifyListeners
(
this
_change
)
;
if
(
false
)
{
}
return
true
;
}
return
false
;
}
;
_proto
.
updateHasMapEntry_
=
function
updateHasMapEntry_
(
key
value
)
{
var
entry
=
this
.
hasMap_
.
get
(
key
)
;
if
(
entry
)
{
entry
.
setNewValue_
(
value
)
;
}
}
;
_proto
.
updateValue_
=
function
updateValue_
(
key
newValue
)
{
var
observable
=
this
.
data_
.
get
(
key
)
;
newValue
=
observable
.
prepareNewValue_
(
newValue
)
;
if
(
newValue
!
=
=
globalState
.
UNCHANGED
)
{
var
notifySpy
=
isSpyEnabled
(
)
;
var
notify
=
hasListeners
(
this
)
;
var
change
=
notify
|
|
notifySpy
?
{
observableKind
:
"
map
"
debugObjectName
:
this
.
name_
type
:
UPDATE
object
:
this
oldValue
:
observable
.
value_
name
:
key
newValue
:
newValue
}
:
null
;
if
(
false
)
{
}
observable
.
setNewValue_
(
newValue
)
;
if
(
notify
)
notifyListeners
(
this
change
)
;
if
(
false
)
{
}
}
}
;
_proto
.
addValue_
=
function
addValue_
(
key
newValue
)
{
var
_this3
=
this
;
checkIfStateModificationsAreAllowed
(
this
.
keysAtom_
)
;
transaction
(
function
(
)
{
var
observable
=
new
ObservableValue
(
newValue
_this3
.
enhancer_
_this3
.
name_
+
"
.
"
+
stringifyKey
(
key
)
false
)
;
_this3
.
data_
.
set
(
key
observable
)
;
newValue
=
observable
.
value_
;
_this3
.
updateHasMapEntry_
(
key
true
)
;
_this3
.
keysAtom_
.
reportChanged
(
)
;
}
)
;
var
notifySpy
=
isSpyEnabled
(
)
;
var
notify
=
hasListeners
(
this
)
;
var
change
=
notify
|
|
notifySpy
?
{
observableKind
:
"
map
"
debugObjectName
:
this
.
name_
type
:
ADD
object
:
this
name
:
key
newValue
:
newValue
}
:
null
;
if
(
false
)
{
}
if
(
notify
)
notifyListeners
(
this
change
)
;
if
(
false
)
{
}
}
;
_proto
.
get
=
function
get
(
key
)
{
if
(
this
.
has
(
key
)
)
return
this
.
dehanceValue_
(
this
.
data_
.
get
(
key
)
.
get
(
)
)
;
return
this
.
dehanceValue_
(
undefined
)
;
}
;
_proto
.
dehanceValue_
=
function
dehanceValue_
(
value
)
{
if
(
this
.
dehancer
!
=
=
undefined
)
{
return
this
.
dehancer
(
value
)
;
}
return
value
;
}
;
_proto
.
keys
=
function
keys
(
)
{
this
.
keysAtom_
.
reportObserved
(
)
;
return
this
.
data_
.
keys
(
)
;
}
;
_proto
.
values
=
function
values
(
)
{
var
self
=
this
;
var
keys
=
this
.
keys
(
)
;
return
makeIterable
(
{
next
:
function
next
(
)
{
var
_keys
next
=
keys
.
next
(
)
done
=
_keys
next
.
done
value
=
_keys
next
.
value
;
return
{
done
:
done
value
:
done
?
undefined
:
self
.
get
(
value
)
}
;
}
}
)
;
}
;
_proto
.
entries
=
function
entries
(
)
{
var
self
=
this
;
var
keys
=
this
.
keys
(
)
;
return
makeIterable
(
{
next
:
function
next
(
)
{
var
_keys
next2
=
keys
.
next
(
)
done
=
_keys
next2
.
done
value
=
_keys
next2
.
value
;
return
{
done
:
done
value
:
done
?
undefined
:
[
value
self
.
get
(
value
)
]
}
;
}
}
)
;
}
;
_proto
[
_Symbol
iterator
]
=
function
(
)
{
return
this
.
entries
(
)
;
}
;
_proto
.
forEach
=
function
forEach
(
callback
thisArg
)
{
for
(
var
_iterator
=
_createForOfIteratorHelperLoose
(
this
)
_step
;
!
(
_step
=
_iterator
(
)
)
.
done
;
)
{
var
_step
value
=
_step
.
value
key
=
_step
value
[
0
]
value
=
_step
value
[
1
]
;
callback
.
call
(
thisArg
value
key
this
)
;
}
}
;
_proto
.
merge
=
function
merge
(
other
)
{
var
_this4
=
this
;
if
(
isObservableMap
(
other
)
)
{
other
=
new
Map
(
other
)
;
}
transaction
(
function
(
)
{
if
(
isPlainObject
(
other
)
)
getPlainObjectKeys
(
other
)
.
forEach
(
function
(
key
)
{
return
_this4
.
set
(
key
other
[
key
]
)
;
}
)
;
else
if
(
Array
.
isArray
(
other
)
)
other
.
forEach
(
function
(
_ref
)
{
var
key
=
_ref
[
0
]
value
=
_ref
[
1
]
;
return
_this4
.
set
(
key
value
)
;
}
)
;
else
if
(
isES6Map
(
other
)
)
{
if
(
other
.
constructor
!
=
=
Map
)
die
(
19
other
)
;
other
.
forEach
(
function
(
value
key
)
{
return
_this4
.
set
(
key
value
)
;
}
)
;
}
else
if
(
other
!
=
=
null
&
&
other
!
=
=
undefined
)
die
(
20
other
)
;
}
)
;
return
this
;
}
;
_proto
.
clear
=
function
clear
(
)
{
var
_this5
=
this
;
transaction
(
function
(
)
{
untracked
(
function
(
)
{
for
(
var
_iterator2
=
_createForOfIteratorHelperLoose
(
_this5
.
keys
(
)
)
_step2
;
!
(
_step2
=
_iterator2
(
)
)
.
done
;
)
{
var
key
=
_step2
.
value
;
_this5
[
"
delete
"
]
(
key
)
;
}
}
)
;
}
)
;
}
;
_proto
.
replace
=
function
replace
(
values
)
{
var
_this6
=
this
;
transaction
(
function
(
)
{
var
replacementMap
=
convertToMap
(
values
)
;
var
orderedData
=
new
Map
(
)
;
var
keysReportChangedCalled
=
false
;
for
(
var
_iterator3
=
_createForOfIteratorHelperLoose
(
_this6
.
data_
.
keys
(
)
)
_step3
;
!
(
_step3
=
_iterator3
(
)
)
.
done
;
)
{
var
key
=
_step3
.
value
;
if
(
!
replacementMap
.
has
(
key
)
)
{
var
deleted
=
_this6
[
"
delete
"
]
(
key
)
;
if
(
deleted
)
{
keysReportChangedCalled
=
true
;
}
else
{
var
value
=
_this6
.
data_
.
get
(
key
)
;
orderedData
.
set
(
key
value
)
;
}
}
}
for
(
var
_iterator4
=
_createForOfIteratorHelperLoose
(
replacementMap
.
entries
(
)
)
_step4
;
!
(
_step4
=
_iterator4
(
)
)
.
done
;
)
{
var
_step4
value
=
_step4
.
value
_key
=
_step4
value
[
0
]
_value
=
_step4
value
[
1
]
;
var
keyExisted
=
_this6
.
data_
.
has
(
_key
)
;
_this6
.
set
(
_key
_value
)
;
if
(
_this6
.
data_
.
has
(
_key
)
)
{
var
_value2
=
_this6
.
data_
.
get
(
_key
)
;
orderedData
.
set
(
_key
_value2
)
;
if
(
!
keyExisted
)
{
keysReportChangedCalled
=
true
;
}
}
}
if
(
!
keysReportChangedCalled
)
{
if
(
_this6
.
data_
.
size
!
=
=
orderedData
.
size
)
{
_this6
.
keysAtom_
.
reportChanged
(
)
;
}
else
{
var
iter1
=
_this6
.
data_
.
keys
(
)
;
var
iter2
=
orderedData
.
keys
(
)
;
var
next1
=
iter1
.
next
(
)
;
var
next2
=
iter2
.
next
(
)
;
while
(
!
next1
.
done
)
{
if
(
next1
.
value
!
=
=
next2
.
value
)
{
_this6
.
keysAtom_
.
reportChanged
(
)
;
break
;
}
next1
=
iter1
.
next
(
)
;
next2
=
iter2
.
next
(
)
;
}
}
}
_this6
.
data_
=
orderedData
;
}
)
;
return
this
;
}
;
_proto
.
toString
=
function
toString
(
)
{
return
"
[
object
ObservableMap
]
"
;
}
;
_proto
.
toJSON
=
function
toJSON
(
)
{
return
Array
.
from
(
this
)
;
}
;
_proto
.
observe_
=
function
observe_
(
listener
fireImmediately
)
{
if
(
false
)
{
}
return
registerListener
(
this
listener
)
;
}
;
_proto
.
intercept_
=
function
intercept_
(
handler
)
{
return
registerInterceptor
(
this
handler
)
;
}
;
_createClass
(
ObservableMap
[
{
key
:
"
size
"
get
:
function
get
(
)
{
this
.
keysAtom_
.
reportObserved
(
)
;
return
this
.
data_
.
size
;
}
}
{
key
:
_Symbol
toStringTag
get
:
function
get
(
)
{
return
"
Map
"
;
}
}
]
)
;
return
ObservableMap
;
}
(
)
;
var
isObservableMap
=
createInstanceofPredicate
(
"
ObservableMap
"
ObservableMap
)
;
function
convertToMap
(
dataStructure
)
{
if
(
isES6Map
(
dataStructure
)
|
|
isObservableMap
(
dataStructure
)
)
{
return
dataStructure
;
}
else
if
(
Array
.
isArray
(
dataStructure
)
)
{
return
new
Map
(
dataStructure
)
;
}
else
if
(
isPlainObject
(
dataStructure
)
)
{
var
map
=
new
Map
(
)
;
for
(
var
key
in
dataStructure
)
{
map
.
set
(
key
dataStructure
[
key
]
)
;
}
return
map
;
}
else
{
return
die
(
21
dataStructure
)
;
}
}
var
_Symbol
iterator
1
_Symbol
toStringTag
1
;
var
ObservableSetMarker
=
{
}
;
_Symbol
iterator
1
=
Symbol
.
iterator
;
_Symbol
toStringTag
1
=
Symbol
.
toStringTag
;
var
ObservableSet
=
function
(
)
{
function
ObservableSet
(
initialData
enhancer
name_
)
{
if
(
enhancer
=
=
=
void
0
)
{
enhancer
=
deepEnhancer
;
}
if
(
name_
=
=
=
void
0
)
{
name_
=
"
ObservableSet
"
+
getNextId
(
)
;
}
this
.
name_
=
void
0
;
this
[
mobx
]
=
ObservableSetMarker
;
this
.
data_
=
new
Set
(
)
;
this
.
atom_
=
void
0
;
this
.
changeListeners_
=
void
0
;
this
.
interceptors_
=
void
0
;
this
.
dehancer
=
void
0
;
this
.
enhancer_
=
void
0
;
this
.
name_
=
name_
;
if
(
!
isFunction
(
Set
)
)
{
die
(
22
)
;
}
this
.
atom_
=
createAtom
(
this
.
name_
)
;
this
.
enhancer_
=
function
(
newV
oldV
)
{
return
enhancer
(
newV
oldV
name_
)
;
}
;
if
(
initialData
)
{
this
.
replace
(
initialData
)
;
}
}
var
_proto
=
ObservableSet
.
prototype
;
_proto
.
dehanceValue_
=
function
dehanceValue_
(
value
)
{
if
(
this
.
dehancer
!
=
=
undefined
)
{
return
this
.
dehancer
(
value
)
;
}
return
value
;
}
;
_proto
.
clear
=
function
clear
(
)
{
var
_this
=
this
;
transaction
(
function
(
)
{
untracked
(
function
(
)
{
for
(
var
_iterator
=
_createForOfIteratorHelperLoose
(
_this
.
data_
.
values
(
)
)
_step
;
!
(
_step
=
_iterator
(
)
)
.
done
;
)
{
var
value
=
_step
.
value
;
_this
[
"
delete
"
]
(
value
)
;
}
}
)
;
}
)
;
}
;
_proto
.
forEach
=
function
forEach
(
callbackFn
thisArg
)
{
for
(
var
_iterator2
=
_createForOfIteratorHelperLoose
(
this
)
_step2
;
!
(
_step2
=
_iterator2
(
)
)
.
done
;
)
{
var
value
=
_step2
.
value
;
callbackFn
.
call
(
thisArg
value
value
this
)
;
}
}
;
_proto
.
add
=
function
add
(
value
)
{
var
_this2
=
this
;
checkIfStateModificationsAreAllowed
(
this
.
atom_
)
;
if
(
hasInterceptors
(
this
)
)
{
var
change
=
interceptChange
(
this
{
type
:
ADD
object
:
this
newValue
:
value
}
)
;
if
(
!
change
)
return
this
;
}
if
(
!
this
.
has
(
value
)
)
{
transaction
(
function
(
)
{
_this2
.
data_
.
add
(
_this2
.
enhancer_
(
value
undefined
)
)
;
_this2
.
atom_
.
reportChanged
(
)
;
}
)
;
var
notifySpy
=
false
&
&
0
;
var
notify
=
hasListeners
(
this
)
;
var
_change
=
notify
|
|
notifySpy
?
{
observableKind
:
"
set
"
debugObjectName
:
this
.
name_
type
:
ADD
object
:
this
newValue
:
value
}
:
null
;
if
(
notifySpy
&
&
"
production
"
!
=
=
"
production
"
)
spyReportStart
(
_change
)
;
if
(
notify
)
notifyListeners
(
this
_change
)
;
if
(
notifySpy
&
&
"
production
"
!
=
=
"
production
"
)
spyReportEnd
(
)
;
}
return
this
;
}
;
_proto
[
"
delete
"
]
=
function
_delete
(
value
)
{
var
_this3
=
this
;
if
(
hasInterceptors
(
this
)
)
{
var
change
=
interceptChange
(
this
{
type
:
DELETE
object
:
this
oldValue
:
value
}
)
;
if
(
!
change
)
return
false
;
}
if
(
this
.
has
(
value
)
)
{
var
notifySpy
=
false
&
&
0
;
var
notify
=
hasListeners
(
this
)
;
var
_change2
=
notify
|
|
notifySpy
?
{
observableKind
:
"
set
"
debugObjectName
:
this
.
name_
type
:
DELETE
object
:
this
oldValue
:
value
}
:
null
;
if
(
notifySpy
&
&
"
production
"
!
=
=
"
production
"
)
spyReportStart
(
_change2
)
;
transaction
(
function
(
)
{
_this3
.
atom_
.
reportChanged
(
)
;
_this3
.
data_
[
"
delete
"
]
(
value
)
;
}
)
;
if
(
notify
)
notifyListeners
(
this
_change2
)
;
if
(
notifySpy
&
&
"
production
"
!
=
=
"
production
"
)
spyReportEnd
(
)
;
return
true
;
}
return
false
;
}
;
_proto
.
has
=
function
has
(
value
)
{
this
.
atom_
.
reportObserved
(
)
;
return
this
.
data_
.
has
(
this
.
dehanceValue_
(
value
)
)
;
}
;
_proto
.
entries
=
function
entries
(
)
{
var
nextIndex
=
0
;
var
keys
=
Array
.
from
(
this
.
keys
(
)
)
;
var
values
=
Array
.
from
(
this
.
values
(
)
)
;
return
makeIterable
(
{
next
:
function
next
(
)
{
var
index
=
nextIndex
;
nextIndex
+
=
1
;
return
index
<
values
.
length
?
{
value
:
[
keys
[
index
]
values
[
index
]
]
done
:
false
}
:
{
done
:
true
}
;
}
}
)
;
}
;
_proto
.
keys
=
function
keys
(
)
{
return
this
.
values
(
)
;
}
;
_proto
.
values
=
function
values
(
)
{
this
.
atom_
.
reportObserved
(
)
;
var
self
=
this
;
var
nextIndex
=
0
;
var
observableValues
=
Array
.
from
(
this
.
data_
.
values
(
)
)
;
return
makeIterable
(
{
next
:
function
next
(
)
{
return
nextIndex
<
observableValues
.
length
?
{
value
:
self
.
dehanceValue_
(
observableValues
[
nextIndex
+
+
]
)
done
:
false
}
:
{
done
:
true
}
;
}
}
)
;
}
;
_proto
.
replace
=
function
replace
(
other
)
{
var
_this4
=
this
;
if
(
isObservableSet
(
other
)
)
{
other
=
new
Set
(
other
)
;
}
transaction
(
function
(
)
{
if
(
Array
.
isArray
(
other
)
)
{
_this4
.
clear
(
)
;
other
.
forEach
(
function
(
value
)
{
return
_this4
.
add
(
value
)
;
}
)
;
}
else
if
(
isES6Set
(
other
)
)
{
_this4
.
clear
(
)
;
other
.
forEach
(
function
(
value
)
{
return
_this4
.
add
(
value
)
;
}
)
;
}
else
if
(
other
!
=
=
null
&
&
other
!
=
=
undefined
)
{
die
(
"
Cannot
initialize
set
from
"
+
other
)
;
}
}
)
;
return
this
;
}
;
_proto
.
observe_
=
function
observe_
(
listener
fireImmediately
)
{
if
(
false
)
{
}
return
registerListener
(
this
listener
)
;
}
;
_proto
.
intercept_
=
function
intercept_
(
handler
)
{
return
registerInterceptor
(
this
handler
)
;
}
;
_proto
.
toJSON
=
function
toJSON
(
)
{
return
Array
.
from
(
this
)
;
}
;
_proto
.
toString
=
function
toString
(
)
{
return
"
[
object
ObservableSet
]
"
;
}
;
_proto
[
_Symbol
iterator
1
]
=
function
(
)
{
return
this
.
values
(
)
;
}
;
_createClass
(
ObservableSet
[
{
key
:
"
size
"
get
:
function
get
(
)
{
this
.
atom_
.
reportObserved
(
)
;
return
this
.
data_
.
size
;
}
}
{
key
:
_Symbol
toStringTag
1
get
:
function
get
(
)
{
return
"
Set
"
;
}
}
]
)
;
return
ObservableSet
;
}
(
)
;
var
isObservableSet
=
createInstanceofPredicate
(
"
ObservableSet
"
ObservableSet
)
;
var
REMOVE
=
"
remove
"
;
var
ObservableObjectAdministration
=
function
(
)
{
function
ObservableObjectAdministration
(
target_
values_
name_
defaultEnhancer_
)
{
if
(
values_
=
=
=
void
0
)
{
values_
=
new
Map
(
)
;
}
this
.
target_
=
void
0
;
this
.
values_
=
void
0
;
this
.
name_
=
void
0
;
this
.
defaultEnhancer_
=
void
0
;
this
.
keysAtom_
=
void
0
;
this
.
changeListeners_
=
void
0
;
this
.
interceptors_
=
void
0
;
this
.
proxy_
=
void
0
;
this
.
pendingKeys_
=
void
0
;
this
.
keysValue_
=
[
]
;
this
.
isStaledKeysValue_
=
true
;
this
.
target_
=
target_
;
this
.
values_
=
values_
;
this
.
name_
=
name_
;
this
.
defaultEnhancer_
=
defaultEnhancer_
;
this
.
keysAtom_
=
new
Atom
(
name_
+
"
.
keys
"
)
;
}
var
_proto
=
ObservableObjectAdministration
.
prototype
;
_proto
.
read_
=
function
read_
(
key
)
{
return
this
.
values_
.
get
(
key
)
.
get
(
)
;
}
;
_proto
.
write_
=
function
write_
(
key
newValue
)
{
var
instance
=
this
.
target_
;
var
observable
=
this
.
values_
.
get
(
key
)
;
if
(
observable
instanceof
ComputedValue
)
{
observable
.
set
(
newValue
)
;
return
;
}
if
(
hasInterceptors
(
this
)
)
{
var
change
=
interceptChange
(
this
{
type
:
UPDATE
object
:
this
.
proxy_
|
|
instance
name
:
key
newValue
:
newValue
}
)
;
if
(
!
change
)
return
;
newValue
=
change
.
newValue
;
}
newValue
=
observable
.
prepareNewValue_
(
newValue
)
;
if
(
newValue
!
=
=
globalState
.
UNCHANGED
)
{
var
notify
=
hasListeners
(
this
)
;
var
notifySpy
=
false
&
&
0
;
var
_change
=
notify
|
|
notifySpy
?
{
type
:
UPDATE
observableKind
:
"
object
"
debugObjectName
:
this
.
name_
object
:
this
.
proxy_
|
|
instance
oldValue
:
observable
.
value_
name
:
key
newValue
:
newValue
}
:
null
;
if
(
false
)
{
}
observable
.
setNewValue_
(
newValue
)
;
if
(
notify
)
notifyListeners
(
this
_change
)
;
if
(
false
)
{
}
}
}
;
_proto
.
has_
=
function
has_
(
key
)
{
var
map
=
this
.
pendingKeys_
|
|
(
this
.
pendingKeys_
=
new
Map
(
)
)
;
var
entry
=
map
.
get
(
key
)
;
if
(
entry
)
return
entry
.
get
(
)
;
else
{
var
exists
=
!
!
this
.
values_
.
get
(
key
)
;
entry
=
new
ObservableValue
(
exists
referenceEnhancer
this
.
name_
+
"
.
"
+
stringifyKey
(
key
)
+
"
?
"
false
)
;
map
.
set
(
key
entry
)
;
return
entry
.
get
(
)
;
}
}
;
_proto
.
addObservableProp_
=
function
addObservableProp_
(
propName
newValue
enhancer
)
{
if
(
enhancer
=
=
=
void
0
)
{
enhancer
=
this
.
defaultEnhancer_
;
}
var
target
=
this
.
target_
;
if
(
false
)
{
}
if
(
hasInterceptors
(
this
)
)
{
var
change
=
interceptChange
(
this
{
object
:
this
.
proxy_
|
|
target
name
:
propName
type
:
ADD
newValue
:
newValue
}
)
;
if
(
!
change
)
return
;
newValue
=
change
.
newValue
;
}
var
observable
=
new
ObservableValue
(
newValue
enhancer
this
.
name_
+
"
.
"
+
stringifyKey
(
propName
)
false
)
;
this
.
values_
.
set
(
propName
observable
)
;
newValue
=
observable
.
value_
;
defineProperty
(
target
propName
generateObservablePropConfig
(
propName
)
)
;
this
.
notifyPropertyAddition_
(
propName
newValue
)
;
}
;
_proto
.
addComputedProp_
=
function
addComputedProp_
(
propertyOwner
propName
options
)
{
var
target
=
this
.
target_
;
options
.
name
=
options
.
name
|
|
this
.
name_
+
"
.
"
+
stringifyKey
(
propName
)
;
options
.
context
=
this
.
proxy_
|
|
target
;
this
.
values_
.
set
(
propName
new
ComputedValue
(
options
)
)
;
defineProperty
(
propertyOwner
propName
generateComputedPropConfig
(
propName
)
)
;
}
;
_proto
.
remove_
=
function
remove_
(
key
)
{
if
(
!
this
.
values_
.
has
(
key
)
)
return
;
var
target
=
this
.
target_
;
if
(
hasInterceptors
(
this
)
)
{
var
change
=
interceptChange
(
this
{
object
:
this
.
proxy_
|
|
target
name
:
key
type
:
REMOVE
}
)
;
if
(
!
change
)
return
;
}
try
{
startBatch
(
)
;
var
notify
=
hasListeners
(
this
)
;
var
notifySpy
=
false
&
&
0
;
var
oldObservable
=
this
.
values_
.
get
(
key
)
;
var
oldValue
=
oldObservable
&
&
oldObservable
.
get
(
)
;
oldObservable
&
&
oldObservable
.
set
(
undefined
)
;
this
.
reportKeysChanged
(
)
;
this
.
values_
[
"
delete
"
]
(
key
)
;
if
(
this
.
pendingKeys_
)
{
var
entry
=
this
.
pendingKeys_
.
get
(
key
)
;
if
(
entry
)
entry
.
set
(
false
)
;
}
delete
this
.
target_
[
key
]
;
var
_change2
=
notify
|
|
notifySpy
?
{
type
:
REMOVE
observableKind
:
"
object
"
object
:
this
.
proxy_
|
|
target
debugObjectName
:
this
.
name_
oldValue
:
oldValue
name
:
key
}
:
null
;
if
(
false
)
{
}
if
(
notify
)
notifyListeners
(
this
_change2
)
;
if
(
false
)
{
}
}
finally
{
endBatch
(
)
;
}
}
;
_proto
.
observe_
=
function
observe_
(
callback
fireImmediately
)
{
if
(
false
)
{
}
return
registerListener
(
this
callback
)
;
}
;
_proto
.
intercept_
=
function
intercept_
(
handler
)
{
return
registerInterceptor
(
this
handler
)
;
}
;
_proto
.
notifyPropertyAddition_
=
function
notifyPropertyAddition_
(
key
newValue
)
{
var
notify
=
hasListeners
(
this
)
;
var
notifySpy
=
false
&
&
0
;
var
change
=
notify
|
|
notifySpy
?
{
type
:
ADD
observableKind
:
"
object
"
debugObjectName
:
this
.
name_
object
:
this
.
proxy_
|
|
this
.
target_
name
:
key
newValue
:
newValue
}
:
null
;
if
(
false
)
{
}
if
(
notify
)
notifyListeners
(
this
change
)
;
if
(
false
)
{
}
if
(
this
.
pendingKeys_
)
{
var
entry
=
this
.
pendingKeys_
.
get
(
key
)
;
if
(
entry
)
entry
.
set
(
true
)
;
}
this
.
reportKeysChanged
(
)
;
}
;
_proto
.
getKeys_
=
function
getKeys_
(
)
{
this
.
keysAtom_
.
reportObserved
(
)
;
if
(
!
this
.
isStaledKeysValue_
)
{
return
this
.
keysValue_
;
}
this
.
keysValue_
=
[
]
;
for
(
var
_iterator
=
_createForOfIteratorHelperLoose
(
this
.
values_
)
_step
;
!
(
_step
=
_iterator
(
)
)
.
done
;
)
{
var
_step
value
=
_step
.
value
key
=
_step
value
[
0
]
value
=
_step
value
[
1
]
;
if
(
value
instanceof
ObservableValue
)
this
.
keysValue_
.
push
(
key
)
;
}
if
(
false
)
{
}
this
.
isStaledKeysValue_
=
false
;
return
this
.
keysValue_
;
}
;
_proto
.
reportKeysChanged
=
function
reportKeysChanged
(
)
{
this
.
isStaledKeysValue_
=
true
;
this
.
keysAtom_
.
reportChanged
(
)
;
}
;
return
ObservableObjectAdministration
;
}
(
)
;
function
asObservableObject
(
target
name
defaultEnhancer
)
{
if
(
name
=
=
=
void
0
)
{
name
=
"
"
;
}
if
(
defaultEnhancer
=
=
=
void
0
)
{
defaultEnhancer
=
deepEnhancer
;
}
if
(
hasProp
(
target
mobx
)
)
return
target
[
mobx
]
;
if
(
false
)
{
}
if
(
!
isPlainObject
(
target
)
)
name
=
(
target
.
constructor
.
name
|
|
"
ObservableObject
"
)
+
"
"
+
getNextId
(
)
;
if
(
!
name
)
name
=
"
ObservableObject
"
+
getNextId
(
)
;
var
adm
=
new
ObservableObjectAdministration
(
target
new
Map
(
)
stringifyKey
(
name
)
defaultEnhancer
)
;
addHiddenProp
(
target
mobx
adm
)
;
return
adm
;
}
var
observablePropertyConfigs
=
Object
.
create
(
null
)
;
var
computedPropertyConfigs
=
Object
.
create
(
null
)
;
function
generateObservablePropConfig
(
propName
)
{
return
observablePropertyConfigs
[
propName
]
|
|
(
observablePropertyConfigs
[
propName
]
=
{
configurable
:
true
enumerable
:
true
get
:
function
get
(
)
{
return
this
[
mobx
]
.
read_
(
propName
)
;
}
set
:
function
set
(
v
)
{
this
[
mobx
]
.
write_
(
propName
v
)
;
}
}
)
;
}
function
generateComputedPropConfig
(
propName
)
{
return
computedPropertyConfigs
[
propName
]
|
|
(
computedPropertyConfigs
[
propName
]
=
{
configurable
:
true
enumerable
:
false
get
:
function
get
(
)
{
return
this
[
mobx
]
.
read_
(
propName
)
;
}
set
:
function
set
(
v
)
{
this
[
mobx
]
.
write_
(
propName
v
)
;
}
}
)
;
}
var
isObservableObjectAdministration
=
createInstanceofPredicate
(
"
ObservableObjectAdministration
"
ObservableObjectAdministration
)
;
function
isObservableObject
(
thing
)
{
if
(
isObject
(
thing
)
)
{
return
isObservableObjectAdministration
(
thing
[
mobx
]
)
;
}
return
false
;
}
var
OBSERVABLE_ARRAY_BUFFER_SIZE
=
0
;
var
StubArray
=
function
StubArray
(
)
{
}
;
function
inherit
(
ctor
proto
)
{
if
(
Object
.
setPrototypeOf
)
{
Object
.
setPrototypeOf
(
ctor
.
prototype
proto
)
;
}
else
if
(
ctor
.
prototype
.
__proto__
!
=
=
undefined
)
{
ctor
.
prototype
.
__proto__
=
proto
;
}
else
{
ctor
.
prototype
=
proto
;
}
}
inherit
(
StubArray
Array
.
prototype
)
;
var
LegacyObservableArray
=
function
(
_StubArray
)
{
_inheritsLoose
(
LegacyObservableArray
_StubArray
)
;
function
LegacyObservableArray
(
initialValues
enhancer
name
owned
)
{
var
_this
;
if
(
name
=
=
=
void
0
)
{
name
=
"
ObservableArray
"
+
getNextId
(
)
;
}
if
(
owned
=
=
=
void
0
)
{
owned
=
false
;
}
_this
=
_StubArray
.
call
(
this
)
|
|
this
;
var
adm
=
new
ObservableArrayAdministration
(
name
enhancer
owned
true
)
;
adm
.
proxy_
=
_assertThisInitialized
(
_this
)
;
addHiddenFinalProp
(
_assertThisInitialized
(
_this
)
mobx
adm
)
;
if
(
initialValues
&
&
initialValues
.
length
)
{
var
prev
=
allowStateChangesStart
(
true
)
;
_this
.
spliceWithArray
(
0
0
initialValues
)
;
allowStateChangesEnd
(
prev
)
;
}
return
_this
;
}
var
_proto
=
LegacyObservableArray
.
prototype
;
_proto
.
concat
=
function
concat
(
)
{
this
[
mobx
]
.
atom_
.
reportObserved
(
)
;
for
(
var
_len
=
arguments
.
length
arrays
=
new
Array
(
_len
)
_key
=
0
;
_key
<
_len
;
_key
+
+
)
{
arrays
[
_key
]
=
arguments
[
_key
]
;
}
return
Array
.
prototype
.
concat
.
apply
(
this
.
slice
(
)
arrays
.
map
(
function
(
a
)
{
return
isObservableArray
(
a
)
?
a
.
slice
(
)
:
a
;
}
)
)
;
}
;
_proto
[
Symbol
.
iterator
]
=
function
(
)
{
var
self
=
this
;
var
nextIndex
=
0
;
return
makeIterable
(
{
next
:
function
next
(
)
{
return
nextIndex
<
self
.
length
?
{
value
:
self
[
nextIndex
+
+
]
done
:
false
}
:
{
done
:
true
value
:
undefined
}
;
}
}
)
;
}
;
_createClass
(
LegacyObservableArray
[
{
key
:
"
length
"
get
:
function
get
(
)
{
return
this
[
mobx
]
.
getArrayLength_
(
)
;
}
set
:
function
set
(
newLength
)
{
this
[
mobx
]
.
setArrayLength_
(
newLength
)
;
}
}
{
key
:
Symbol
.
toStringTag
get
:
function
get
(
)
{
return
"
Array
"
;
}
}
]
)
;
return
LegacyObservableArray
;
}
(
StubArray
)
;
Object
.
entries
(
arrayExtensions
)
.
forEach
(
function
(
_ref
)
{
var
prop
=
_ref
[
0
]
fn
=
_ref
[
1
]
;
if
(
prop
!
=
=
"
concat
"
)
addHiddenProp
(
LegacyObservableArray
.
prototype
prop
fn
)
;
}
)
;
function
createArrayEntryDescriptor
(
index
)
{
return
{
enumerable
:
false
configurable
:
true
get
:
function
get
(
)
{
return
this
[
mobx
]
.
get_
(
index
)
;
}
set
:
function
set
(
value
)
{
this
[
mobx
]
.
set_
(
index
value
)
;
}
}
;
}
function
createArrayBufferItem
(
index
)
{
defineProperty
(
LegacyObservableArray
.
prototype
"
"
+
index
createArrayEntryDescriptor
(
index
)
)
;
}
function
reserveArrayBuffer
(
max
)
{
if
(
max
>
OBSERVABLE_ARRAY_BUFFER_SIZE
)
{
for
(
var
index
=
OBSERVABLE_ARRAY_BUFFER_SIZE
;
index
<
max
+
100
;
index
+
+
)
{
createArrayBufferItem
(
index
)
;
}
OBSERVABLE_ARRAY_BUFFER_SIZE
=
max
;
}
}
reserveArrayBuffer
(
1000
)
;
function
createLegacyArray
(
initialValues
enhancer
name
)
{
return
new
LegacyObservableArray
(
initialValues
enhancer
name
)
;
}
function
getAtom
(
thing
property
)
{
if
(
typeof
thing
=
=
=
"
object
"
&
&
thing
!
=
=
null
)
{
if
(
isObservableArray
(
thing
)
)
{
if
(
property
!
=
=
undefined
)
die
(
23
)
;
return
thing
[
mobx
]
.
atom_
;
}
if
(
isObservableSet
(
thing
)
)
{
return
thing
[
mobx
]
;
}
if
(
isObservableMap
(
thing
)
)
{
if
(
property
=
=
=
undefined
)
return
thing
.
keysAtom_
;
var
observable
=
thing
.
data_
.
get
(
property
)
|
|
thing
.
hasMap_
.
get
(
property
)
;
if
(
!
observable
)
die
(
25
property
getDebugName
(
thing
)
)
;
return
observable
;
}
if
(
isObservableObject
(
thing
)
)
{
if
(
!
property
)
return
die
(
26
)
;
var
_observable
=
thing
[
mobx
]
.
values_
.
get
(
property
)
;
if
(
!
_observable
)
die
(
27
property
getDebugName
(
thing
)
)
;
return
_observable
;
}
if
(
isAtom
(
thing
)
|
|
isComputedValue
(
thing
)
|
|
isReaction
(
thing
)
)
{
return
thing
;
}
}
else
if
(
isFunction
(
thing
)
)
{
if
(
isReaction
(
thing
[
mobx
]
)
)
{
return
thing
[
mobx
]
;
}
}
die
(
28
)
;
}
function
getAdministration
(
thing
property
)
{
if
(
!
thing
)
die
(
29
)
;
if
(
property
!
=
=
undefined
)
return
getAdministration
(
getAtom
(
thing
property
)
)
;
if
(
isAtom
(
thing
)
|
|
isComputedValue
(
thing
)
|
|
isReaction
(
thing
)
)
return
thing
;
if
(
isObservableMap
(
thing
)
|
|
isObservableSet
(
thing
)
)
return
thing
;
if
(
thing
[
mobx
]
)
return
thing
[
mobx
]
;
die
(
24
thing
)
;
}
function
getDebugName
(
thing
property
)
{
var
named
;
if
(
property
!
=
=
undefined
)
named
=
getAtom
(
thing
property
)
;
else
if
(
isObservableObject
(
thing
)
|
|
isObservableMap
(
thing
)
|
|
isObservableSet
(
thing
)
)
named
=
getAdministration
(
thing
)
;
else
named
=
getAtom
(
thing
)
;
return
named
.
name_
;
}
var
toString
=
objectPrototype
.
toString
;
function
deepEqual
(
a
b
depth
)
{
if
(
depth
=
=
=
void
0
)
{
depth
=
-
1
;
}
return
eq
(
a
b
depth
)
;
}
function
eq
(
a
b
depth
aStack
bStack
)
{
if
(
a
=
=
=
b
)
return
a
!
=
=
0
|
|
1
/
a
=
=
=
1
/
b
;
if
(
a
=
=
null
|
|
b
=
=
null
)
return
false
;
if
(
a
!
=
=
a
)
return
b
!
=
=
b
;
var
type
=
typeof
a
;
if
(
!
isFunction
(
type
)
&
&
type
!
=
=
"
object
"
&
&
typeof
b
!
=
"
object
"
)
return
false
;
var
className
=
toString
.
call
(
a
)
;
if
(
className
!
=
=
toString
.
call
(
b
)
)
return
false
;
switch
(
className
)
{
case
"
[
object
RegExp
]
"
:
case
"
[
object
String
]
"
:
return
"
"
+
a
=
=
=
"
"
+
b
;
case
"
[
object
Number
]
"
:
if
(
+
a
!
=
=
+
a
)
return
+
b
!
=
=
+
b
;
return
+
a
=
=
=
0
?
1
/
+
a
=
=
=
1
/
b
:
+
a
=
=
=
+
b
;
case
"
[
object
Date
]
"
:
case
"
[
object
Boolean
]
"
:
return
+
a
=
=
=
+
b
;
case
"
[
object
Symbol
]
"
:
return
typeof
Symbol
!
=
=
"
undefined
"
&
&
Symbol
.
valueOf
.
call
(
a
)
=
=
=
Symbol
.
valueOf
.
call
(
b
)
;
case
"
[
object
Map
]
"
:
case
"
[
object
Set
]
"
:
if
(
depth
>
=
0
)
{
depth
+
+
;
}
break
;
}
a
=
unwrap
(
a
)
;
b
=
unwrap
(
b
)
;
var
areArrays
=
className
=
=
=
"
[
object
Array
]
"
;
if
(
!
areArrays
)
{
if
(
typeof
a
!
=
"
object
"
|
|
typeof
b
!
=
"
object
"
)
return
false
;
var
aCtor
=
a
.
constructor
bCtor
=
b
.
constructor
;
if
(
aCtor
!
=
=
bCtor
&
&
!
(
isFunction
(
aCtor
)
&
&
aCtor
instanceof
aCtor
&
&
isFunction
(
bCtor
)
&
&
bCtor
instanceof
bCtor
)
&
&
"
constructor
"
in
a
&
&
"
constructor
"
in
b
)
{
return
false
;
}
}
if
(
depth
=
=
=
0
)
{
return
false
;
}
else
if
(
depth
<
0
)
{
depth
=
-
1
;
}
aStack
=
aStack
|
|
[
]
;
bStack
=
bStack
|
|
[
]
;
var
length
=
aStack
.
length
;
while
(
length
-
-
)
{
if
(
aStack
[
length
]
=
=
=
a
)
return
bStack
[
length
]
=
=
=
b
;
}
aStack
.
push
(
a
)
;
bStack
.
push
(
b
)
;
if
(
areArrays
)
{
length
=
a
.
length
;
if
(
length
!
=
=
b
.
length
)
return
false
;
while
(
length
-
-
)
{
if
(
!
eq
(
a
[
length
]
b
[
length
]
depth
-
1
aStack
bStack
)
)
return
false
;
}
}
else
{
var
keys
=
Object
.
keys
(
a
)
;
var
key
;
length
=
keys
.
length
;
if
(
Object
.
keys
(
b
)
.
length
!
=
=
length
)
return
false
;
while
(
length
-
-
)
{
key
=
keys
[
length
]
;
if
(
!
(
hasProp
(
b
key
)
&
&
eq
(
a
[
key
]
b
[
key
]
depth
-
1
aStack
bStack
)
)
)
return
false
;
}
}
aStack
.
pop
(
)
;
bStack
.
pop
(
)
;
return
true
;
}
function
unwrap
(
a
)
{
if
(
isObservableArray
(
a
)
)
return
a
.
slice
(
)
;
if
(
isES6Map
(
a
)
|
|
isObservableMap
(
a
)
)
return
Array
.
from
(
a
.
entries
(
)
)
;
if
(
isES6Set
(
a
)
|
|
isObservableSet
(
a
)
)
return
Array
.
from
(
a
.
entries
(
)
)
;
return
a
;
}
function
makeIterable
(
iterator
)
{
iterator
[
Symbol
.
iterator
]
=
getSelf
;
return
iterator
;
}
function
getSelf
(
)
{
return
this
;
}
[
"
Symbol
"
"
Map
"
"
Set
"
"
Symbol
"
]
.
forEach
(
function
(
m
)
{
var
g
=
getGlobal
(
)
;
if
(
typeof
g
[
m
]
=
=
=
"
undefined
"
)
{
die
(
"
MobX
requires
global
'
"
+
m
+
"
'
to
be
available
or
polyfilled
"
)
;
}
}
)
;
if
(
typeof
__MOBX_DEVTOOLS_GLOBAL_HOOK__
=
=
=
"
object
"
)
{
__MOBX_DEVTOOLS_GLOBAL_HOOK__
.
injectMobx
(
{
spy
:
spy
extras
:
{
getDebugName
:
getDebugName
}
mobx
:
mobx
}
)
;
}
}
)
350
:
(
(
__unused_webpack___webpack_module__
__webpack_exports__
__webpack_require__
)
=
>
{
"
use
strict
"
;
__webpack_require__
.
r
(
__webpack_exports__
)
;
__webpack_require__
.
d
(
__webpack_exports__
{
"
customAlphabet
"
:
(
)
=
>
(
customAlphabet
)
"
customRandom
"
:
(
)
=
>
(
customRandom
)
"
nanoid
"
:
(
)
=
>
(
nanoid
)
"
random
"
:
(
)
=
>
(
random
)
"
urlAlphabet
"
:
(
)
=
>
(
urlAlphabet
)
}
)
;
;
let
urlAlphabet
=
'
ModuleSymbhasOwnPr
-
0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW
'
;
if
(
false
)
{
}
let
random
=
bytes
=
>
crypto
.
getRandomValues
(
new
Uint8Array
(
bytes
)
)
let
customRandom
=
(
alphabet
size
getRandom
)
=
>
{
let
mask
=
(
2
<
<
(
Math
.
log
(
alphabet
.
length
-
1
)
/
Math
.
LN2
)
)
-
1
let
step
=
-
~
(
(
1
.
6
*
mask
*
size
)
/
alphabet
.
length
)
return
(
)
=
>
{
let
id
=
'
'
while
(
true
)
{
let
bytes
=
getRandom
(
step
)
let
j
=
step
while
(
j
-
-
)
{
id
+
=
alphabet
[
bytes
[
j
]
&
mask
]
|
|
'
'
if
(
id
.
length
=
=
=
+
size
)
return
id
}
}
}
}
let
customAlphabet
=
(
alphabet
size
)
=
>
customRandom
(
alphabet
size
random
)
let
nanoid
=
(
size
=
21
)
=
>
{
let
id
=
'
'
let
bytes
=
crypto
.
getRandomValues
(
new
Uint8Array
(
size
)
)
while
(
size
-
-
)
{
let
byte
=
bytes
[
size
]
&
63
if
(
byte
<
36
)
{
id
+
=
byte
.
toString
(
36
)
}
else
if
(
byte
<
62
)
{
id
+
=
(
byte
-
26
)
.
toString
(
36
)
.
toUpperCase
(
)
}
else
if
(
byte
<
63
)
{
id
+
=
'
_
'
}
else
{
id
+
=
'
-
'
}
}
return
id
}
}
)
3624
:
(
(
__unused_webpack_module
exports
__webpack_require__
)
=
>
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
(
{
value
:
true
}
)
)
;
if
(
typeof
window
=
=
=
"
undefined
"
)
exports
.
browser
=
{
}
;
else
exports
.
browser
=
__webpack_require__
(
4390
)
;
}
)
4390
:
(
function
(
module
exports
)
{
var
__WEBPACK_AMD_DEFINE_FACTORY__
__WEBPACK_AMD_DEFINE_ARRAY__
__WEBPACK_AMD_DEFINE_RESULT__
;
(
function
(
global
factory
)
{
if
(
true
)
{
!
(
__WEBPACK_AMD_DEFINE_ARRAY__
=
[
module
]
__WEBPACK_AMD_DEFINE_FACTORY__
=
(
factory
)
__WEBPACK_AMD_DEFINE_RESULT__
=
(
typeof
__WEBPACK_AMD_DEFINE_FACTORY__
=
=
=
'
function
'
?
(
__WEBPACK_AMD_DEFINE_FACTORY__
.
apply
(
exports
__WEBPACK_AMD_DEFINE_ARRAY__
)
)
:
__WEBPACK_AMD_DEFINE_FACTORY__
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
else
{
var
mod
;
}
}
)
(
typeof
globalThis
!
=
=
"
undefined
"
?
globalThis
:
typeof
self
!
=
=
"
undefined
"
?
self
:
this
function
(
module
)
{
"
use
strict
"
;
if
(
typeof
browser
=
=
=
"
undefined
"
|
|
Object
.
getPrototypeOf
(
browser
)
!
=
=
Object
.
prototype
)
{
const
CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE
=
"
The
message
port
closed
before
a
response
was
received
.
"
;
const
SEND_RESPONSE_DEPRECATION_WARNING
=
"
Returning
a
Promise
is
the
preferred
way
to
send
a
reply
from
an
onMessage
/
onMessageExternal
listener
as
the
sendResponse
will
be
removed
from
the
specs
(
See
https
:
/
/
developer
.
mozilla
.
org
/
docs
/
Mozilla
/
Add
-
ons
/
WebExtensions
/
API
/
runtime
/
onMessage
)
"
;
const
wrapAPIs
=
extensionAPIs
=
>
{
const
apiMetadata
=
{
"
alarms
"
:
{
"
clear
"
:
{
"
minArgs
"
:
0
"
maxArgs
"
:
1
}
"
clearAll
"
:
{
"
minArgs
"
:
0
"
maxArgs
"
:
0
}
"
get
"
:
{
"
minArgs
"
:
0
"
maxArgs
"
:
1
}
"
getAll
"
:
{
"
minArgs
"
:
0
"
maxArgs
"
:
0
}
}
"
bookmarks
"
:
{
"
create
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
"
get
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
"
getChildren
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
"
getRecent
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
"
getSubTree
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
"
getTree
"
:
{
"
minArgs
"
:
0
"
maxArgs
"
:
0
}
"
move
"
:
{
"
minArgs
"
:
2
"
maxArgs
"
:
2
}
"
remove
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
"
removeTree
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
"
search
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
"
update
"
:
{
"
minArgs
"
:
2
"
maxArgs
"
:
2
}
}
"
browserAction
"
:
{
"
disable
"
:
{
"
minArgs
"
:
0
"
maxArgs
"
:
1
"
fallbackToNoCallback
"
:
true
}
"
enable
"
:
{
"
minArgs
"
:
0
"
maxArgs
"
:
1
"
fallbackToNoCallback
"
:
true
}
"
getBadgeBackgroundColor
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
"
getBadgeText
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
"
getPopup
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
"
getTitle
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
"
openPopup
"
:
{
"
minArgs
"
:
0
"
maxArgs
"
:
0
}
"
setBadgeBackgroundColor
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
"
fallbackToNoCallback
"
:
true
}
"
setBadgeText
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
"
fallbackToNoCallback
"
:
true
}
"
setIcon
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
"
setPopup
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
"
fallbackToNoCallback
"
:
true
}
"
setTitle
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
"
fallbackToNoCallback
"
:
true
}
}
"
browsingData
"
:
{
"
remove
"
:
{
"
minArgs
"
:
2
"
maxArgs
"
:
2
}
"
removeCache
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
"
removeCookies
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
"
removeDownloads
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
"
removeFormData
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
"
removeHistory
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
"
removeLocalStorage
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
"
removePasswords
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
"
removePluginData
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
"
settings
"
:
{
"
minArgs
"
:
0
"
maxArgs
"
:
0
}
}
"
commands
"
:
{
"
getAll
"
:
{
"
minArgs
"
:
0
"
maxArgs
"
:
0
}
}
"
contextMenus
"
:
{
"
remove
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
"
removeAll
"
:
{
"
minArgs
"
:
0
"
maxArgs
"
:
0
}
"
update
"
:
{
"
minArgs
"
:
2
"
maxArgs
"
:
2
}
}
"
cookies
"
:
{
"
get
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
"
getAll
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
"
getAllCookieStores
"
:
{
"
minArgs
"
:
0
"
maxArgs
"
:
0
}
"
remove
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
"
set
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
}
"
devtools
"
:
{
"
inspectedWindow
"
:
{
"
eval
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
2
"
singleCallbackArg
"
:
false
}
}
"
panels
"
:
{
"
create
"
:
{
"
minArgs
"
:
3
"
maxArgs
"
:
3
"
singleCallbackArg
"
:
true
}
}
}
"
downloads
"
:
{
"
cancel
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
"
download
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
"
erase
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
"
getFileIcon
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
2
}
"
open
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
"
fallbackToNoCallback
"
:
true
}
"
pause
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
"
removeFile
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
"
resume
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
"
search
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
"
show
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
"
fallbackToNoCallback
"
:
true
}
}
"
extension
"
:
{
"
isAllowedFileSchemeAccess
"
:
{
"
minArgs
"
:
0
"
maxArgs
"
:
0
}
"
isAllowedIncognitoAccess
"
:
{
"
minArgs
"
:
0
"
maxArgs
"
:
0
}
}
"
history
"
:
{
"
addUrl
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
"
deleteAll
"
:
{
"
minArgs
"
:
0
"
maxArgs
"
:
0
}
"
deleteRange
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
"
deleteUrl
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
"
getVisits
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
"
search
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
}
"
i18n
"
:
{
"
detectLanguage
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
"
getAcceptLanguages
"
:
{
"
minArgs
"
:
0
"
maxArgs
"
:
0
}
}
"
identity
"
:
{
"
launchWebAuthFlow
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
}
"
idle
"
:
{
"
queryState
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
}
"
management
"
:
{
"
get
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
"
getAll
"
:
{
"
minArgs
"
:
0
"
maxArgs
"
:
0
}
"
getSelf
"
:
{
"
minArgs
"
:
0
"
maxArgs
"
:
0
}
"
setEnabled
"
:
{
"
minArgs
"
:
2
"
maxArgs
"
:
2
}
"
uninstallSelf
"
:
{
"
minArgs
"
:
0
"
maxArgs
"
:
1
}
}
"
notifications
"
:
{
"
clear
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
"
create
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
2
}
"
getAll
"
:
{
"
minArgs
"
:
0
"
maxArgs
"
:
0
}
"
getPermissionLevel
"
:
{
"
minArgs
"
:
0
"
maxArgs
"
:
0
}
"
update
"
:
{
"
minArgs
"
:
2
"
maxArgs
"
:
2
}
}
"
pageAction
"
:
{
"
getPopup
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
"
getTitle
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
"
hide
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
"
fallbackToNoCallback
"
:
true
}
"
setIcon
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
"
setPopup
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
"
fallbackToNoCallback
"
:
true
}
"
setTitle
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
"
fallbackToNoCallback
"
:
true
}
"
show
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
"
fallbackToNoCallback
"
:
true
}
}
"
permissions
"
:
{
"
contains
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
"
getAll
"
:
{
"
minArgs
"
:
0
"
maxArgs
"
:
0
}
"
remove
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
"
request
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
}
"
runtime
"
:
{
"
getBackgroundPage
"
:
{
"
minArgs
"
:
0
"
maxArgs
"
:
0
}
"
getPlatformInfo
"
:
{
"
minArgs
"
:
0
"
maxArgs
"
:
0
}
"
openOptionsPage
"
:
{
"
minArgs
"
:
0
"
maxArgs
"
:
0
}
"
requestUpdateCheck
"
:
{
"
minArgs
"
:
0
"
maxArgs
"
:
0
}
"
sendMessage
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
3
}
"
sendNativeMessage
"
:
{
"
minArgs
"
:
2
"
maxArgs
"
:
2
}
"
setUninstallURL
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
}
"
sessions
"
:
{
"
getDevices
"
:
{
"
minArgs
"
:
0
"
maxArgs
"
:
1
}
"
getRecentlyClosed
"
:
{
"
minArgs
"
:
0
"
maxArgs
"
:
1
}
"
restore
"
:
{
"
minArgs
"
:
0
"
maxArgs
"
:
1
}
}
"
storage
"
:
{
"
local
"
:
{
"
clear
"
:
{
"
minArgs
"
:
0
"
maxArgs
"
:
0
}
"
get
"
:
{
"
minArgs
"
:
0
"
maxArgs
"
:
1
}
"
getBytesInUse
"
:
{
"
minArgs
"
:
0
"
maxArgs
"
:
1
}
"
remove
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
"
set
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
}
"
managed
"
:
{
"
get
"
:
{
"
minArgs
"
:
0
"
maxArgs
"
:
1
}
"
getBytesInUse
"
:
{
"
minArgs
"
:
0
"
maxArgs
"
:
1
}
}
"
sync
"
:
{
"
clear
"
:
{
"
minArgs
"
:
0
"
maxArgs
"
:
0
}
"
get
"
:
{
"
minArgs
"
:
0
"
maxArgs
"
:
1
}
"
getBytesInUse
"
:
{
"
minArgs
"
:
0
"
maxArgs
"
:
1
}
"
remove
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
"
set
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
}
}
"
tabs
"
:
{
"
captureVisibleTab
"
:
{
"
minArgs
"
:
0
"
maxArgs
"
:
2
}
"
create
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
"
detectLanguage
"
:
{
"
minArgs
"
:
0
"
maxArgs
"
:
1
}
"
discard
"
:
{
"
minArgs
"
:
0
"
maxArgs
"
:
1
}
"
duplicate
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
"
executeScript
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
2
}
"
get
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
"
getCurrent
"
:
{
"
minArgs
"
:
0
"
maxArgs
"
:
0
}
"
getZoom
"
:
{
"
minArgs
"
:
0
"
maxArgs
"
:
1
}
"
getZoomSettings
"
:
{
"
minArgs
"
:
0
"
maxArgs
"
:
1
}
"
highlight
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
"
insertCSS
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
2
}
"
move
"
:
{
"
minArgs
"
:
2
"
maxArgs
"
:
2
}
"
query
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
"
reload
"
:
{
"
minArgs
"
:
0
"
maxArgs
"
:
2
}
"
remove
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
"
removeCSS
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
2
}
"
sendMessage
"
:
{
"
minArgs
"
:
2
"
maxArgs
"
:
3
}
"
setZoom
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
2
}
"
setZoomSettings
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
2
}
"
update
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
2
}
}
"
topSites
"
:
{
"
get
"
:
{
"
minArgs
"
:
0
"
maxArgs
"
:
0
}
}
"
webNavigation
"
:
{
"
getAllFrames
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
"
getFrame
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
}
"
webRequest
"
:
{
"
handlerBehaviorChanged
"
:
{
"
minArgs
"
:
0
"
maxArgs
"
:
0
}
}
"
windows
"
:
{
"
create
"
:
{
"
minArgs
"
:
0
"
maxArgs
"
:
1
}
"
get
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
2
}
"
getAll
"
:
{
"
minArgs
"
:
0
"
maxArgs
"
:
1
}
"
getCurrent
"
:
{
"
minArgs
"
:
0
"
maxArgs
"
:
1
}
"
getLastFocused
"
:
{
"
minArgs
"
:
0
"
maxArgs
"
:
1
}
"
remove
"
:
{
"
minArgs
"
:
1
"
maxArgs
"
:
1
}
"
update
"
:
{
"
minArgs
"
:
2
"
maxArgs
"
:
2
}
}
}
;
if
(
Object
.
keys
(
apiMetadata
)
.
length
=
=
=
0
)
{
throw
new
Error
(
"
api
-
metadata
.
json
has
not
been
included
in
browser
-
polyfill
"
)
;
}
class
DefaultWeakMap
extends
WeakMap
{
constructor
(
createItem
items
=
undefined
)
{
super
(
items
)
;
this
.
createItem
=
createItem
;
}
get
(
key
)
{
if
(
!
this
.
has
(
key
)
)
{
this
.
set
(
key
this
.
createItem
(
key
)
)
;
}
return
super
.
get
(
key
)
;
}
}
const
isThenable
=
value
=
>
{
return
value
&
&
typeof
value
=
=
=
"
object
"
&
&
typeof
value
.
then
=
=
=
"
function
"
;
}
;
const
makeCallback
=
(
promise
metadata
)
=
>
{
return
(
.
.
.
callbackArgs
)
=
>
{
if
(
extensionAPIs
.
runtime
.
lastError
)
{
promise
.
reject
(
extensionAPIs
.
runtime
.
lastError
)
;
}
else
if
(
metadata
.
singleCallbackArg
|
|
callbackArgs
.
length
<
=
1
&
&
metadata
.
singleCallbackArg
!
=
=
false
)
{
promise
.
resolve
(
callbackArgs
[
0
]
)
;
}
else
{
promise
.
resolve
(
callbackArgs
)
;
}
}
;
}
;
const
pluralizeArguments
=
numArgs
=
>
numArgs
=
=
1
?
"
argument
"
:
"
arguments
"
;
const
wrapAsyncFunction
=
(
name
metadata
)
=
>
{
return
function
asyncFunctionWrapper
(
target
.
.
.
args
)
{
if
(
args
.
length
<
metadata
.
minArgs
)
{
throw
new
Error
(
Expected
at
least
{
metadata
.
minArgs
}
{
pluralizeArguments
(
metadata
.
minArgs
)
}
for
{
name
}
(
)
got
{
args
.
length
}
)
;
}
if
(
args
.
length
>
metadata
.
maxArgs
)
{
throw
new
Error
(
Expected
at
most
{
metadata
.
maxArgs
}
{
pluralizeArguments
(
metadata
.
maxArgs
)
}
for
{
name
}
(
)
got
{
args
.
length
}
)
;
}
return
new
Promise
(
(
resolve
reject
)
=
>
{
if
(
metadata
.
fallbackToNoCallback
)
{
try
{
target
[
name
]
(
.
.
.
args
makeCallback
(
{
resolve
reject
}
metadata
)
)
;
}
catch
(
cbError
)
{
console
.
warn
(
{
name
}
API
method
doesn
'
t
seem
to
support
the
callback
parameter
+
"
falling
back
to
call
it
without
a
callback
:
"
cbError
)
;
target
[
name
]
(
.
.
.
args
)
;
metadata
.
fallbackToNoCallback
=
false
;
metadata
.
noCallback
=
true
;
resolve
(
)
;
}
}
else
if
(
metadata
.
noCallback
)
{
target
[
name
]
(
.
.
.
args
)
;
resolve
(
)
;
}
else
{
target
[
name
]
(
.
.
.
args
makeCallback
(
{
resolve
reject
}
metadata
)
)
;
}
}
)
;
}
;
}
;
const
wrapMethod
=
(
target
method
wrapper
)
=
>
{
return
new
Proxy
(
method
{
apply
(
targetMethod
thisObj
args
)
{
return
wrapper
.
call
(
thisObj
target
.
.
.
args
)
;
}
}
)
;
}
;
let
hasOwnProperty
=
Function
.
call
.
bind
(
Object
.
prototype
.
hasOwnProperty
)
;
const
wrapObject
=
(
target
wrappers
=
{
}
metadata
=
{
}
)
=
>
{
let
cache
=
Object
.
create
(
null
)
;
let
handlers
=
{
has
(
proxyTarget
prop
)
{
return
prop
in
target
|
|
prop
in
cache
;
}
get
(
proxyTarget
prop
receiver
)
{
if
(
prop
in
cache
)
{
return
cache
[
prop
]
;
}
if
(
!
(
prop
in
target
)
)
{
return
undefined
;
}
let
value
=
target
[
prop
]
;
if
(
typeof
value
=
=
=
"
function
"
)
{
if
(
typeof
wrappers
[
prop
]
=
=
=
"
function
"
)
{
value
=
wrapMethod
(
target
target
[
prop
]
wrappers
[
prop
]
)
;
}
else
if
(
hasOwnProperty
(
metadata
prop
)
)
{
let
wrapper
=
wrapAsyncFunction
(
prop
metadata
[
prop
]
)
;
value
=
wrapMethod
(
target
target
[
prop
]
wrapper
)
;
}
else
{
value
=
value
.
bind
(
target
)
;
}
}
else
if
(
typeof
value
=
=
=
"
object
"
&
&
value
!
=
=
null
&
&
(
hasOwnProperty
(
wrappers
prop
)
|
|
hasOwnProperty
(
metadata
prop
)
)
)
{
value
=
wrapObject
(
value
wrappers
[
prop
]
metadata
[
prop
]
)
;
}
else
if
(
hasOwnProperty
(
metadata
"
*
"
)
)
{
value
=
wrapObject
(
value
wrappers
[
prop
]
metadata
[
"
*
"
]
)
;
}
else
{
Object
.
defineProperty
(
cache
prop
{
configurable
:
true
enumerable
:
true
get
(
)
{
return
target
[
prop
]
;
}
set
(
value
)
{
target
[
prop
]
=
value
;
}
}
)
;
return
value
;
}
cache
[
prop
]
=
value
;
return
value
;
}
set
(
proxyTarget
prop
value
receiver
)
{
if
(
prop
in
cache
)
{
cache
[
prop
]
=
value
;
}
else
{
target
[
prop
]
=
value
;
}
return
true
;
}
defineProperty
(
proxyTarget
prop
desc
)
{
return
Reflect
.
defineProperty
(
cache
prop
desc
)
;
}
deleteProperty
(
proxyTarget
prop
)
{
return
Reflect
.
deleteProperty
(
cache
prop
)
;
}
}
;
let
proxyTarget
=
Object
.
create
(
target
)
;
return
new
Proxy
(
proxyTarget
handlers
)
;
}
;
const
wrapEvent
=
wrapperMap
=
>
(
{
addListener
(
target
listener
.
.
.
args
)
{
target
.
addListener
(
wrapperMap
.
get
(
listener
)
.
.
.
args
)
;
}
hasListener
(
target
listener
)
{
return
target
.
hasListener
(
wrapperMap
.
get
(
listener
)
)
;
}
removeListener
(
target
listener
)
{
target
.
removeListener
(
wrapperMap
.
get
(
listener
)
)
;
}
}
)
;
let
loggedSendResponseDeprecationWarning
=
false
;
const
onMessageWrappers
=
new
DefaultWeakMap
(
listener
=
>
{
if
(
typeof
listener
!
=
=
"
function
"
)
{
return
listener
;
}
return
function
onMessage
(
message
sender
sendResponse
)
{
let
didCallSendResponse
=
false
;
let
wrappedSendResponse
;
let
sendResponsePromise
=
new
Promise
(
resolve
=
>
{
wrappedSendResponse
=
function
(
response
)
{
if
(
!
loggedSendResponseDeprecationWarning
)
{
console
.
warn
(
SEND_RESPONSE_DEPRECATION_WARNING
new
Error
(
)
.
stack
)
;
loggedSendResponseDeprecationWarning
=
true
;
}
didCallSendResponse
=
true
;
resolve
(
response
)
;
}
;
}
)
;
let
result
;
try
{
result
=
listener
(
message
sender
wrappedSendResponse
)
;
}
catch
(
err
)
{
result
=
Promise
.
reject
(
err
)
;
}
const
isResultThenable
=
result
!
=
=
true
&
&
isThenable
(
result
)
;
if
(
result
!
=
=
true
&
&
!
isResultThenable
&
&
!
didCallSendResponse
)
{
return
false
;
}
const
sendPromisedResult
=
promise
=
>
{
promise
.
then
(
msg
=
>
{
sendResponse
(
msg
)
;
}
error
=
>
{
let
message
;
if
(
error
&
&
(
error
instanceof
Error
|
|
typeof
error
.
message
=
=
=
"
string
"
)
)
{
message
=
error
.
message
;
}
else
{
message
=
"
An
unexpected
error
occurred
"
;
}
sendResponse
(
{
__mozWebExtensionPolyfillReject__
:
true
message
}
)
;
}
)
.
catch
(
err
=
>
{
console
.
error
(
"
Failed
to
send
onMessage
rejected
reply
"
err
)
;
}
)
;
}
;
if
(
isResultThenable
)
{
sendPromisedResult
(
result
)
;
}
else
{
sendPromisedResult
(
sendResponsePromise
)
;
}
return
true
;
}
;
}
)
;
const
wrappedSendMessageCallback
=
(
{
reject
resolve
}
reply
)
=
>
{
if
(
extensionAPIs
.
runtime
.
lastError
)
{
if
(
extensionAPIs
.
runtime
.
lastError
.
message
=
=
=
CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE
)
{
resolve
(
)
;
}
else
{
reject
(
extensionAPIs
.
runtime
.
lastError
)
;
}
}
else
if
(
reply
&
&
reply
.
__mozWebExtensionPolyfillReject__
)
{
reject
(
new
Error
(
reply
.
message
)
)
;
}
else
{
resolve
(
reply
)
;
}
}
;
const
wrappedSendMessage
=
(
name
metadata
apiNamespaceObj
.
.
.
args
)
=
>
{
if
(
args
.
length
<
metadata
.
minArgs
)
{
throw
new
Error
(
Expected
at
least
{
metadata
.
minArgs
}
{
pluralizeArguments
(
metadata
.
minArgs
)
}
for
{
name
}
(
)
got
{
args
.
length
}
)
;
}
if
(
args
.
length
>
metadata
.
maxArgs
)
{
throw
new
Error
(
Expected
at
most
{
metadata
.
maxArgs
}
{
pluralizeArguments
(
metadata
.
maxArgs
)
}
for
{
name
}
(
)
got
{
args
.
length
}
)
;
}
return
new
Promise
(
(
resolve
reject
)
=
>
{
const
wrappedCb
=
wrappedSendMessageCallback
.
bind
(
null
{
resolve
reject
}
)
;
args
.
push
(
wrappedCb
)
;
apiNamespaceObj
.
sendMessage
(
.
.
.
args
)
;
}
)
;
}
;
const
staticWrappers
=
{
runtime
:
{
onMessage
:
wrapEvent
(
onMessageWrappers
)
onMessageExternal
:
wrapEvent
(
onMessageWrappers
)
sendMessage
:
wrappedSendMessage
.
bind
(
null
"
sendMessage
"
{
minArgs
:
1
maxArgs
:
3
}
)
}
tabs
:
{
sendMessage
:
wrappedSendMessage
.
bind
(
null
"
sendMessage
"
{
minArgs
:
2
maxArgs
:
3
}
)
}
}
;
const
settingMetadata
=
{
clear
:
{
minArgs
:
1
maxArgs
:
1
}
get
:
{
minArgs
:
1
maxArgs
:
1
}
set
:
{
minArgs
:
1
maxArgs
:
1
}
}
;
apiMetadata
.
privacy
=
{
network
:
{
"
*
"
:
settingMetadata
}
services
:
{
"
*
"
:
settingMetadata
}
websites
:
{
"
*
"
:
settingMetadata
}
}
;
return
wrapObject
(
extensionAPIs
staticWrappers
apiMetadata
)
;
}
;
if
(
typeof
chrome
!
=
"
object
"
|
|
!
chrome
|
|
!
chrome
.
runtime
|
|
!
chrome
.
runtime
.
id
)
{
throw
new
Error
(
"
This
script
should
only
be
loaded
in
a
browser
extension
.
"
)
;
}
module
.
exports
=
wrapAPIs
(
chrome
)
;
}
else
{
module
.
exports
=
browser
;
}
}
)
;
}
)
964
:
(
(
__unused_webpack_module
exports
)
=
>
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
(
{
value
:
true
}
)
)
;
exports
.
modelRegistry
=
exports
.
config
=
void
0
;
const
developmentBuild
=
"
production
"
!
=
=
"
production
"
;
exports
.
config
=
{
bergamotRestApiUrl
:
"
http
:
/
/
127
.
0
.
0
.
1
:
8787
"
useBergamotRestApi
:
"
0
"
=
=
=
"
1
"
sentryDsn
:
"
https
:
/
/
<
key
>
<
organization
>
.
ingest
.
sentry
.
io
/
<
project
>
"
bergamotModelsBaseUrl
:
developmentBuild
?
"
http
:
/
/
0
.
0
.
0
.
0
:
4000
/
models
"
:
"
https
:
/
/
storage
.
googleapis
.
com
/
bergamot
-
models
-
sandbox
/
0
.
2
.
0
"
telemetryAppId
:
"
org
-
mozilla
-
bergamot
"
telemetryDebugMode
:
developmentBuild
extensionBuildId
:
{
"
v0
.
4
.
0
"
}
-
{
"
local
"
}
#
{
"
HEAD
"
}
supportedLanguagePairs
:
[
[
"
es
"
"
en
"
]
[
"
et
"
"
en
"
]
[
"
en
"
"
de
"
]
[
"
en
"
"
es
"
]
[
"
en
"
"
et
"
]
]
privacyNoticeUrl
:
"
https
:
/
/
example
.
com
/
privacy
-
notice
"
feedbackSurveyUrl
:
"
https
:
/
/
qsurvey
.
mozilla
.
com
/
s3
/
bergamot
-
translate
-
product
-
feedback
"
}
;
exports
.
modelRegistry
=
{
esen
:
{
lex
:
{
name
:
"
lex
.
50
.
50
.
esen
.
s2t
.
bin
"
size
:
3860888
estimatedCompressedSize
:
1978538
expectedSha256Hash
:
"
f11a2c23ef85ab1fee1c412b908d69bc20d66fd59faa8f7da5a5f0347eddf969
"
}
model
:
{
name
:
"
model
.
esen
.
intgemm
.
alphas
.
bin
"
size
:
17140755
estimatedCompressedSize
:
13215960
expectedSha256Hash
:
"
4b6b7f451094aaa447d012658af158ffc708fc8842dde2f871a58404f5457fe0
"
}
vocab
:
{
name
:
"
vocab
.
esen
.
spm
"
size
:
825463
estimatedCompressedSize
:
414566
expectedSha256Hash
:
"
909b1eea1face0d7f90a474fe29a8c0fef8d104b6e41e65616f864c964ba8845
"
}
}
eten
:
{
lex
:
{
name
:
"
lex
.
50
.
50
.
eten
.
s2t
.
bin
"
size
:
3974944
estimatedCompressedSize
:
1920655
expectedSha256Hash
:
"
6992bedc590e60e610a28129c80746fe5f33144a4520e2c5508d87db14ca54f8
"
}
model
:
{
name
:
"
model
.
eten
.
intgemm
.
alphas
.
bin
"
size
:
17140754
estimatedCompressedSize
:
12222624
expectedSha256Hash
:
"
aac98a2371e216ee2d4843cbe896c617f6687501e17225ac83482eba52fd0028
"
}
vocab
:
{
name
:
"
vocab
.
eten
.
spm
"
size
:
828426
estimatedCompressedSize
:
416995
expectedSha256Hash
:
"
e3b66bc141f6123cd40746e2fb9b8ee4f89cbf324ab27d6bbf3782e52f15fa2d
"
}
}
ende
:
{
lex
:
{
name
:
"
lex
.
50
.
50
.
ende
.
s2t
.
bin
"
size
:
3062492
estimatedCompressedSize
:
1575385
expectedSha256Hash
:
"
764797d075f0642c0b079cce6547348d65fe4e92ac69fa6a8605cd8b53dacb3f
"
}
model
:
{
name
:
"
model
.
ende
.
intgemm
.
alphas
.
bin
"
size
:
17140498
estimatedCompressedSize
:
13207068
expectedSha256Hash
:
"
f0946515c6645304f0706fa66a051c3b7b7c507f12d0c850f276c18165a10c14
"
}
vocab
:
{
name
:
"
vocab
.
deen
.
spm
"
size
:
797501
estimatedCompressedSize
:
412505
expectedSha256Hash
:
"
bc8f8229933d8294c727f3eab12f6f064e7082b929f2d29494c8a1e619ba174c
"
}
}
enes
:
{
lex
:
{
name
:
"
lex
.
50
.
50
.
enes
.
s2t
.
bin
"
size
:
3347104
estimatedCompressedSize
:
1720700
expectedSha256Hash
:
"
3a113d713dec3cf1d12bba5b138ae616e28bba4bbc7fe7fd39ba145e26b86d7f
"
}
model
:
{
name
:
"
model
.
enes
.
intgemm
.
alphas
.
bin
"
size
:
17140755
estimatedCompressedSize
:
12602853
expectedSha256Hash
:
"
fa7460037a3163e03fe1d23602f964bff2331da6ee813637e092ddf37156ef53
"
}
vocab
:
{
name
:
"
vocab
.
esen
.
spm
"
size
:
825463
estimatedCompressedSize
:
414566
expectedSha256Hash
:
"
909b1eea1face0d7f90a474fe29a8c0fef8d104b6e41e65616f864c964ba8845
"
}
}
enet
:
{
lex
:
{
name
:
"
lex
.
50
.
50
.
enet
.
s2t
.
bin
"
size
:
2700780
estimatedCompressedSize
:
1336443
expectedSha256Hash
:
"
3d1b40ff43ebef82cf98d416a88a1ea19eb325a85785eef102f59878a63a829d
"
}
model
:
{
name
:
"
model
.
enet
.
intgemm
.
alphas
.
bin
"
size
:
17140754
estimatedCompressedSize
:
12543318
expectedSha256Hash
:
"
a28874a8b702a519a14dc71bcee726a5cb4b539eeaada2d06492f751469a1fd6
"
}
vocab
:
{
name
:
"
vocab
.
eten
.
spm
"
size
:
828426
estimatedCompressedSize
:
416995
expectedSha256Hash
:
"
e3b66bc141f6123cd40746e2fb9b8ee4f89cbf324ab27d6bbf3782e52f15fa2d
"
}
}
}
;
}
)
3345
:
(
function
(
__unused_webpack_module
exports
__webpack_require__
)
{
"
use
strict
"
;
var
__createBinding
=
(
this
&
&
this
.
__createBinding
)
|
|
(
Object
.
create
?
(
function
(
o
m
k
k2
)
{
if
(
k2
=
=
=
undefined
)
k2
=
k
;
Object
.
defineProperty
(
o
k2
{
enumerable
:
true
get
:
function
(
)
{
return
m
[
k
]
;
}
}
)
;
}
)
:
(
function
(
o
m
k
k2
)
{
if
(
k2
=
=
=
undefined
)
k2
=
k
;
o
[
k2
]
=
m
[
k
]
;
}
)
)
;
var
__setModuleDefault
=
(
this
&
&
this
.
__setModuleDefault
)
|
|
(
Object
.
create
?
(
function
(
o
v
)
{
Object
.
defineProperty
(
o
"
default
"
{
enumerable
:
true
value
:
v
}
)
;
}
)
:
function
(
o
v
)
{
o
[
"
default
"
]
=
v
;
}
)
;
var
__importStar
=
(
this
&
&
this
.
__importStar
)
|
|
function
(
mod
)
{
if
(
mod
&
&
mod
.
__esModule
)
return
mod
;
var
result
=
{
}
;
if
(
mod
!
=
null
)
for
(
var
k
in
mod
)
if
(
k
!
=
=
"
default
"
&
&
Object
.
prototype
.
hasOwnProperty
.
call
(
mod
k
)
)
__createBinding
(
result
mod
k
)
;
__setModuleDefault
(
result
mod
)
;
return
result
;
}
;
var
__awaiter
=
(
this
&
&
this
.
__awaiter
)
|
|
function
(
thisArg
_arguments
P
generator
)
{
function
adopt
(
value
)
{
return
value
instanceof
P
?
value
:
new
P
(
function
(
resolve
)
{
resolve
(
value
)
;
}
)
;
}
return
new
(
P
|
|
(
P
=
Promise
)
)
(
function
(
resolve
reject
)
{
function
fulfilled
(
value
)
{
try
{
step
(
generator
.
next
(
value
)
)
;
}
catch
(
e
)
{
reject
(
e
)
;
}
}
function
rejected
(
value
)
{
try
{
step
(
generator
[
"
throw
"
]
(
value
)
)
;
}
catch
(
e
)
{
reject
(
e
)
;
}
}
function
step
(
result
)
{
result
.
done
?
resolve
(
result
.
value
)
:
adopt
(
result
.
value
)
.
then
(
fulfilled
rejected
)
;
}
step
(
(
generator
=
generator
.
apply
(
thisArg
_arguments
|
|
[
]
)
)
.
next
(
)
)
;
}
)
;
}
;
Object
.
defineProperty
(
exports
"
__esModule
"
(
{
value
:
true
}
)
)
;
exports
.
Sentry
=
exports
.
captureExceptionWithExtras
=
exports
.
initErrorReportingInContentScript
=
exports
.
initErrorReportingInBackgroundScript
=
exports
.
toggleErrorReportingBasedAsPerExtensionPreferences
=
void
0
;
const
Sentry
=
__importStar
(
__webpack_require__
(
6614
)
)
;
exports
.
Sentry
=
Sentry
;
const
config_1
=
__webpack_require__
(
964
)
;
const
subscribeToExtensionPreferenceChanges_1
=
__webpack_require__
(
4971
)
;
const
flat_1
=
__webpack_require__
(
9602
)
;
let
sentryIntialized
=
false
;
if
(
!
config_1
.
config
.
sentryDsn
.
includes
(
"
<
project
>
"
)
)
{
Sentry
.
init
(
{
dsn
:
config_1
.
config
.
sentryDsn
}
)
;
sentryIntialized
=
true
;
}
const
enableErrorReporting
=
(
)
=
>
sentryIntialized
&
&
(
Sentry
.
getCurrentHub
(
)
.
getClient
(
)
.
getOptions
(
)
.
enabled
=
true
)
;
const
disableErrorReporting
=
(
)
=
>
sentryIntialized
&
&
(
Sentry
.
getCurrentHub
(
)
.
getClient
(
)
.
getOptions
(
)
.
enabled
=
false
)
;
disableErrorReporting
(
)
;
const
toggleErrorReportingBasedAsPerExtensionPreferences
=
(
extensionPreferences
)
=
>
{
if
(
extensionPreferences
.
enableErrorReporting
)
{
enableErrorReporting
(
)
;
Sentry
.
configureScope
(
function
(
scope
)
{
scope
.
setTag
(
"
extension
.
version
"
extensionPreferences
.
extensionVersion
)
;
scope
.
setUser
(
{
id
:
extensionPreferences
.
extensionInstallationErrorReportingId
}
)
;
}
)
;
console
.
info
(
"
Enabled
error
reporting
"
)
;
}
else
{
disableErrorReporting
(
)
;
console
.
info
(
"
Disabled
error
reporting
"
)
;
}
}
;
exports
.
toggleErrorReportingBasedAsPerExtensionPreferences
=
toggleErrorReportingBasedAsPerExtensionPreferences
;
const
initErrorReportingInBackgroundScript
=
(
store
portNames
)
=
>
__awaiter
(
void
0
void
0
void
0
function
*
(
)
{
console
.
info
(
Inquiring
about
error
reporting
preference
in
background
script
)
;
yield
subscribeToExtensionPreferenceChanges_1
.
subscribeToExtensionPreferenceChangesInBackgroundScript
(
store
exports
.
toggleErrorReportingBasedAsPerExtensionPreferences
)
;
return
subscribeToExtensionPreferenceChanges_1
.
communicateExtensionPreferenceChangesToContentScripts
(
store
portNames
)
;
}
)
;
exports
.
initErrorReportingInBackgroundScript
=
initErrorReportingInBackgroundScript
;
const
initErrorReportingInContentScript
=
(
portName
)
=
>
__awaiter
(
void
0
void
0
void
0
function
*
(
)
{
console
.
info
(
Inquiring
about
error
reporting
preference
in
"
{
portName
}
"
)
;
yield
subscribeToExtensionPreferenceChanges_1
.
subscribeToExtensionPreferenceChangesInContentScript
(
portName
exports
.
toggleErrorReportingBasedAsPerExtensionPreferences
)
;
}
)
;
exports
.
initErrorReportingInContentScript
=
initErrorReportingInContentScript
;
const
captureExceptionWithExtras
=
(
exception
extras
=
null
level
=
null
)
=
>
{
Sentry
.
withScope
(
scope
=
>
{
if
(
extras
!
=
=
null
)
{
scope
.
setExtras
(
flat_1
.
flatten
(
extras
)
)
;
}
if
(
level
!
=
=
null
)
{
scope
.
setLevel
(
level
)
;
}
Sentry
.
captureException
(
exception
)
;
}
)
;
}
;
exports
.
captureExceptionWithExtras
=
captureExceptionWithExtras
;
Sentry
.
configureScope
(
scope
=
>
{
scope
.
addEventProcessor
(
(
event
)
=
>
__awaiter
(
void
0
void
0
void
0
function
*
(
)
{
const
normalizeUrl
=
url
=
>
{
return
url
.
replace
(
/
(
webpack_require__
)
?
(
moz
|
chrome
)
-
extension
:
\
/
\
/
[
^
\
/
]
+
\
/
/
"
~
/
"
)
;
}
;
if
(
event
.
exception
&
&
event
.
exception
.
values
&
&
event
.
exception
.
values
[
0
]
)
{
if
(
event
.
culprit
)
{
event
.
culprit
=
normalizeUrl
(
event
.
culprit
)
;
}
if
(
event
.
exception
.
values
[
0
]
.
stacktrace
&
&
event
.
exception
.
values
[
0
]
.
stacktrace
.
frames
)
{
event
.
exception
.
values
[
0
]
.
stacktrace
.
frames
=
event
.
exception
.
values
[
0
]
.
stacktrace
.
frames
.
map
(
frame
=
>
{
frame
.
filename
=
normalizeUrl
(
frame
.
filename
)
;
return
frame
;
}
)
;
}
return
event
;
}
return
null
;
}
)
)
;
}
)
;
}
)
5602
:
(
function
(
__unused_webpack_module
exports
__webpack_require__
)
{
"
use
strict
"
;
var
__awaiter
=
(
this
&
&
this
.
__awaiter
)
|
|
function
(
thisArg
_arguments
P
generator
)
{
function
adopt
(
value
)
{
return
value
instanceof
P
?
value
:
new
P
(
function
(
resolve
)
{
resolve
(
value
)
;
}
)
;
}
return
new
(
P
|
|
(
P
=
Promise
)
)
(
function
(
resolve
reject
)
{
function
fulfilled
(
value
)
{
try
{
step
(
generator
.
next
(
value
)
)
;
}
catch
(
e
)
{
reject
(
e
)
;
}
}
function
rejected
(
value
)
{
try
{
step
(
generator
[
"
throw
"
]
(
value
)
)
;
}
catch
(
e
)
{
reject
(
e
)
;
}
}
function
step
(
result
)
{
result
.
done
?
resolve
(
result
.
value
)
:
adopt
(
result
.
value
)
.
then
(
fulfilled
rejected
)
;
}
step
(
(
generator
=
generator
.
apply
(
thisArg
_arguments
|
|
[
]
)
)
.
next
(
)
)
;
}
)
;
}
;
Object
.
defineProperty
(
exports
"
__esModule
"
(
{
value
:
true
}
)
)
;
exports
.
LanguageSupport
=
void
0
;
const
webextension_polyfill_ts_1
=
__webpack_require__
(
3624
)
;
const
config_1
=
__webpack_require__
(
964
)
;
class
LanguageSupport
{
constructor
(
)
{
this
.
getAcceptedTargetLanguages
=
(
)
=
>
__awaiter
(
this
void
0
void
0
function
*
(
)
{
return
[
.
.
.
new
Set
(
[
webextension_polyfill_ts_1
.
browser
.
i18n
.
getUILanguage
(
)
.
.
.
(
yield
webextension_polyfill_ts_1
.
browser
.
i18n
.
getAcceptLanguages
(
)
)
]
.
map
(
localeCode
=
>
localeCode
.
split
(
"
-
"
)
[
0
]
)
)
]
;
}
)
;
this
.
getSupportedSourceLanguages
=
(
)
=
>
{
return
[
.
.
.
new
Set
(
config_1
.
config
.
supportedLanguagePairs
.
map
(
lp
=
>
lp
[
0
]
)
)
]
;
}
;
this
.
getSupportedTargetLanguagesGivenASourceLanguage
=
(
translateFrom
)
=
>
{
return
[
.
.
.
new
Set
(
config_1
.
config
.
supportedLanguagePairs
.
filter
(
lp
=
>
lp
[
0
]
=
=
=
translateFrom
)
.
map
(
lp
=
>
lp
[
1
]
)
)
]
;
}
;
this
.
getAllPossiblySupportedTargetLanguages
=
(
)
=
>
{
return
[
.
.
.
new
Set
(
config_1
.
config
.
supportedLanguagePairs
.
map
(
lp
=
>
lp
[
1
]
)
)
]
;
}
;
this
.
getDefaultSourceLanguage
=
(
translateFrom
detectedLanguage
)
=
>
{
return
translateFrom
|
|
detectedLanguage
;
}
;
this
.
getDefaultTargetLanguage
=
(
translateFrom
acceptedTargetLanguages
)
=
>
{
const
supportedTargetLanguages
=
translateFrom
?
this
.
getSupportedTargetLanguagesGivenASourceLanguage
(
translateFrom
)
:
this
.
getAllPossiblySupportedTargetLanguages
(
)
;
const
possibleDefaultTargetLanguages
=
acceptedTargetLanguages
.
filter
(
languageCode
=
>
supportedTargetLanguages
.
includes
(
languageCode
)
)
;
if
(
possibleDefaultTargetLanguages
.
length
)
{
return
possibleDefaultTargetLanguages
[
0
]
;
}
return
null
;
}
;
this
.
summarizeLanguageSupport
=
(
detectedLanguageResults
)
=
>
__awaiter
(
this
void
0
void
0
function
*
(
)
{
const
acceptedTargetLanguages
=
yield
this
.
getAcceptedTargetLanguages
(
)
;
const
defaultSourceLanguage
=
this
.
getDefaultSourceLanguage
(
null
detectedLanguageResults
=
=
=
null
|
|
detectedLanguageResults
=
=
=
void
0
?
void
0
:
detectedLanguageResults
.
language
)
;
const
defaultTargetLanguage
=
this
.
getDefaultTargetLanguage
(
defaultSourceLanguage
acceptedTargetLanguages
)
;
const
supportedSourceLanguages
=
this
.
getSupportedSourceLanguages
(
)
;
const
supportedTargetLanguagesGivenDefaultSourceLanguage
=
this
.
getSupportedTargetLanguagesGivenASourceLanguage
(
defaultSourceLanguage
)
;
const
allPossiblySupportedTargetLanguages
=
this
.
getAllPossiblySupportedTargetLanguages
(
)
;
return
{
acceptedTargetLanguages
defaultSourceLanguage
defaultTargetLanguage
supportedSourceLanguages
supportedTargetLanguagesGivenDefaultSourceLanguage
allPossiblySupportedTargetLanguages
}
;
}
)
;
}
}
exports
.
LanguageSupport
=
LanguageSupport
;
}
)
4779
:
(
function
(
__unused_webpack_module
exports
__webpack_require__
)
{
"
use
strict
"
;
var
__decorate
=
(
this
&
&
this
.
__decorate
)
|
|
function
(
decorators
target
key
desc
)
{
var
c
=
arguments
.
length
r
=
c
<
3
?
target
:
desc
=
=
=
null
?
desc
=
Object
.
getOwnPropertyDescriptor
(
target
key
)
:
desc
d
;
if
(
typeof
Reflect
=
=
=
"
object
"
&
&
typeof
Reflect
.
decorate
=
=
=
"
function
"
)
r
=
Reflect
.
decorate
(
decorators
target
key
desc
)
;
else
for
(
var
i
=
decorators
.
length
-
1
;
i
>
=
0
;
i
-
-
)
if
(
d
=
decorators
[
i
]
)
r
=
(
c
<
3
?
d
(
r
)
:
c
>
3
?
d
(
target
key
r
)
:
d
(
target
key
)
)
|
|
r
;
return
c
>
3
&
&
r
&
&
Object
.
defineProperty
(
target
key
r
)
r
;
}
;
Object
.
defineProperty
(
exports
"
__esModule
"
(
{
value
:
true
}
)
)
;
exports
.
BaseTranslationState
=
exports
.
TranslationStatus
=
void
0
;
const
mobx_keystone_1
=
__webpack_require__
(
7680
)
;
const
mobx_1
=
__webpack_require__
(
9637
)
;
const
webextension_polyfill_ts_1
=
__webpack_require__
(
3624
)
;
var
TranslationStatus
;
(
function
(
TranslationStatus
)
{
TranslationStatus
[
"
UNKNOWN
"
]
=
"
UNKNOWN
"
;
TranslationStatus
[
"
UNAVAILABLE
"
]
=
"
UNAVAILABLE
"
;
TranslationStatus
[
"
DETECTING_LANGUAGE
"
]
=
"
DETECTING_LANGUAGE
"
;
TranslationStatus
[
"
LANGUAGE_NOT_DETECTED
"
]
=
"
LANGUAGE_NOT_DETECTED
"
;
TranslationStatus
[
"
SOURCE_LANGUAGE_UNDERSTOOD
"
]
=
"
SOURCE_LANGUAGE_UNDERSTOOD
"
;
TranslationStatus
[
"
TRANSLATION_UNSUPPORTED
"
]
=
"
TRANSLATION_UNSUPPORTED
"
;
TranslationStatus
[
"
OFFER
"
]
=
"
OFFER
"
;
TranslationStatus
[
"
DOWNLOADING_TRANSLATION_MODEL
"
]
=
"
DOWNLOADING_TRANSLATION_MODEL
"
;
TranslationStatus
[
"
TRANSLATING
"
]
=
"
TRANSLATING
"
;
TranslationStatus
[
"
TRANSLATED
"
]
=
"
TRANSLATED
"
;
TranslationStatus
[
"
ERROR
"
]
=
"
ERROR
"
;
}
)
(
TranslationStatus
=
exports
.
TranslationStatus
|
|
(
exports
.
TranslationStatus
=
{
}
)
)
;
let
BaseTranslationState
=
class
BaseTranslationState
extends
mobx_keystone_1
.
Model
(
{
isVisible
:
mobx_keystone_1
.
prop
(
{
setterAction
:
true
}
)
displayQualityEstimation
:
mobx_keystone_1
.
prop
(
{
setterAction
:
true
}
)
translationRequested
:
mobx_keystone_1
.
prop
(
{
setterAction
:
true
}
)
cancellationRequested
:
mobx_keystone_1
.
prop
(
{
setterAction
:
true
}
)
detectedLanguageResults
:
mobx_keystone_1
.
prop
(
(
)
=
>
null
{
setterAction
:
true
}
)
translateFrom
:
mobx_keystone_1
.
prop
(
{
setterAction
:
true
}
)
translateTo
:
mobx_keystone_1
.
prop
(
{
setterAction
:
true
}
)
translationStatus
:
mobx_keystone_1
.
prop
(
TranslationStatus
.
UNKNOWN
{
setterAction
:
true
}
)
tabId
:
mobx_keystone_1
.
prop
(
)
wordCount
:
mobx_keystone_1
.
prop
(
)
wordCountVisible
:
mobx_keystone_1
.
prop
(
)
wordCountVisibleInViewport
:
mobx_keystone_1
.
prop
(
)
translationInitiationTimestamp
:
mobx_keystone_1
.
prop
(
)
totalModelLoadWallTimeMs
:
mobx_keystone_1
.
prop
(
)
totalTranslationWallTimeMs
:
mobx_keystone_1
.
prop
(
)
totalTranslationEngineRequestCount
:
mobx_keystone_1
.
prop
(
)
queuedTranslationEngineRequestCount
:
mobx_keystone_1
.
prop
(
)
modelLoadNecessary
:
mobx_keystone_1
.
prop
(
)
modelDownloadNecessary
:
mobx_keystone_1
.
prop
(
)
modelDownloading
:
mobx_keystone_1
.
prop
(
)
modelDownloadProgress
:
mobx_keystone_1
.
prop
(
)
modelLoading
:
mobx_keystone_1
.
prop
(
)
modelLoaded
:
mobx_keystone_1
.
prop
(
)
translationFinished
:
mobx_keystone_1
.
prop
(
)
modelLoadErrorOccurred
:
mobx_keystone_1
.
prop
(
)
modelDownloadErrorOccurred
:
mobx_keystone_1
.
prop
(
)
translationErrorOccurred
:
mobx_keystone_1
.
prop
(
)
otherErrorOccurred
:
mobx_keystone_1
.
prop
(
)
}
)
{
get
effectiveTranslateFrom
(
)
{
var
_a
;
return
this
.
translateFrom
|
|
(
(
_a
=
this
.
detectedLanguageResults
)
=
=
=
null
|
|
_a
=
=
=
void
0
?
void
0
:
_a
.
language
)
;
}
get
effectiveTranslateTo
(
)
{
const
browserUiLanguageCode
=
webextension_polyfill_ts_1
.
browser
.
i18n
.
getUILanguage
(
)
.
split
(
"
-
"
)
[
0
]
;
return
this
.
translateTo
|
|
browserUiLanguageCode
;
}
}
;
__decorate
(
[
mobx_1
.
computed
]
BaseTranslationState
.
prototype
"
effectiveTranslateFrom
"
null
)
;
__decorate
(
[
mobx_1
.
computed
]
BaseTranslationState
.
prototype
"
effectiveTranslateTo
"
null
)
;
BaseTranslationState
=
__decorate
(
[
mobx_keystone_1
.
model
(
"
bergamotTranslate
/
BaseTranslationState
"
)
]
BaseTranslationState
)
;
exports
.
BaseTranslationState
=
BaseTranslationState
;
}
)
5482
:
(
function
(
__unused_webpack_module
exports
__webpack_require__
)
{
"
use
strict
"
;
var
__decorate
=
(
this
&
&
this
.
__decorate
)
|
|
function
(
decorators
target
key
desc
)
{
var
c
=
arguments
.
length
r
=
c
<
3
?
target
:
desc
=
=
=
null
?
desc
=
Object
.
getOwnPropertyDescriptor
(
target
key
)
:
desc
d
;
if
(
typeof
Reflect
=
=
=
"
object
"
&
&
typeof
Reflect
.
decorate
=
=
=
"
function
"
)
r
=
Reflect
.
decorate
(
decorators
target
key
desc
)
;
else
for
(
var
i
=
decorators
.
length
-
1
;
i
>
=
0
;
i
-
-
)
if
(
d
=
decorators
[
i
]
)
r
=
(
c
<
3
?
d
(
r
)
:
c
>
3
?
d
(
target
key
r
)
:
d
(
target
key
)
)
|
|
r
;
return
c
>
3
&
&
r
&
&
Object
.
defineProperty
(
target
key
r
)
r
;
}
;
Object
.
defineProperty
(
exports
"
__esModule
"
(
{
value
:
true
}
)
)
;
exports
.
DocumentTranslationState
=
void
0
;
const
mobx_keystone_1
=
__webpack_require__
(
7680
)
;
const
TabTranslationState_1
=
__webpack_require__
(
6556
)
;
let
DocumentTranslationState
=
class
DocumentTranslationState
extends
mobx_keystone_1
.
ExtendedModel
(
TabTranslationState_1
.
TabTranslationState
{
frameId
:
mobx_keystone_1
.
prop
(
)
}
)
{
}
;
DocumentTranslationState
=
__decorate
(
[
mobx_keystone_1
.
model
(
"
bergamotTranslate
/
DocumentTranslationState
"
)
]
DocumentTranslationState
)
;
exports
.
DocumentTranslationState
=
DocumentTranslationState
;
}
)
65
:
(
function
(
__unused_webpack_module
exports
__webpack_require__
)
{
"
use
strict
"
;
var
__decorate
=
(
this
&
&
this
.
__decorate
)
|
|
function
(
decorators
target
key
desc
)
{
var
c
=
arguments
.
length
r
=
c
<
3
?
target
:
desc
=
=
=
null
?
desc
=
Object
.
getOwnPropertyDescriptor
(
target
key
)
:
desc
d
;
if
(
typeof
Reflect
=
=
=
"
object
"
&
&
typeof
Reflect
.
decorate
=
=
=
"
function
"
)
r
=
Reflect
.
decorate
(
decorators
target
key
desc
)
;
else
for
(
var
i
=
decorators
.
length
-
1
;
i
>
=
0
;
i
-
-
)
if
(
d
=
decorators
[
i
]
)
r
=
(
c
<
3
?
d
(
r
)
:
c
>
3
?
d
(
target
key
r
)
:
d
(
target
key
)
)
|
|
r
;
return
c
>
3
&
&
r
&
&
Object
.
defineProperty
(
target
key
r
)
r
;
}
;
Object
.
defineProperty
(
exports
"
__esModule
"
(
{
value
:
true
}
)
)
;
exports
.
ExtensionState
=
exports
.
translateOwnTextTranslationStateMapKey
=
exports
.
documentTranslationStateMapKey
=
void
0
;
const
mobx_keystone_1
=
__webpack_require__
(
7680
)
;
const
mobx_1
=
__webpack_require__
(
9637
)
;
const
TabTranslationState_1
=
__webpack_require__
(
6556
)
;
const
BaseTranslationState_1
=
__webpack_require__
(
4779
)
;
const
documentTranslationStateMapKey
=
(
frameInfo
)
=
>
{
frameInfo
.
tabId
}
-
{
frameInfo
.
frameId
}
;
exports
.
documentTranslationStateMapKey
=
documentTranslationStateMapKey
;
const
translateOwnTextTranslationStateMapKey
=
(
totts
)
=
>
{
totts
.
tabId
}
;
exports
.
translateOwnTextTranslationStateMapKey
=
translateOwnTextTranslationStateMapKey
;
let
ExtensionState
=
class
ExtensionState
extends
mobx_keystone_1
.
Model
(
{
documentTranslationStates
:
mobx_keystone_1
.
prop_mapObject
(
(
)
=
>
new
Map
(
)
)
fragmentTranslationStates
:
mobx_keystone_1
.
prop_mapObject
(
(
)
=
>
new
Map
(
)
)
translateOwnTextTranslationStates
:
mobx_keystone_1
.
prop_mapObject
(
(
)
=
>
new
Map
(
)
)
}
)
{
setDocumentTranslationState
(
documentTranslationState
)
{
this
.
documentTranslationStates
.
set
(
exports
.
documentTranslationStateMapKey
(
documentTranslationState
)
documentTranslationState
)
;
}
patchDocumentTranslationStateByFrameInfo
(
frameInfo
patches
)
{
const
key
=
exports
.
documentTranslationStateMapKey
(
frameInfo
)
;
const
dts
=
this
.
documentTranslationStates
.
get
(
key
)
;
mobx_keystone_1
.
applyPatches
(
dts
patches
)
;
this
.
documentTranslationStates
.
set
(
key
dts
)
;
}
deleteDocumentTranslationStateByFrameInfo
(
frameInfo
)
{
this
.
documentTranslationStates
.
delete
(
exports
.
documentTranslationStateMapKey
(
frameInfo
)
)
;
}
setTranslateOwnTextTranslationState
(
translateOwnTextTranslationState
)
{
this
.
translateOwnTextTranslationStates
.
set
(
exports
.
translateOwnTextTranslationStateMapKey
(
translateOwnTextTranslationState
)
translateOwnTextTranslationState
)
;
}
deleteTranslateOwnTextTranslationState
(
translateOwnTextTranslationState
)
{
this
.
translateOwnTextTranslationStates
.
delete
(
exports
.
translateOwnTextTranslationStateMapKey
(
translateOwnTextTranslationState
)
)
;
}
get
documentTranslationStatesByTabId
(
)
{
const
map
=
new
Map
(
)
;
this
.
documentTranslationStates
.
forEach
(
(
documentTranslationState
)
=
>
{
if
(
map
.
has
(
documentTranslationState
.
tabId
)
)
{
map
.
set
(
documentTranslationState
.
tabId
[
.
.
.
map
.
get
(
documentTranslationState
.
tabId
)
documentTranslationState
]
)
;
}
else
{
map
.
set
(
documentTranslationState
.
tabId
[
documentTranslationState
]
)
;
}
}
)
;
return
map
;
}
get
tabTranslationStates
(
)
{
const
map
=
new
Map
(
)
;
this
.
documentTranslationStatesByTabId
.
forEach
(
(
documentTranslationStates
tabId
)
=
>
{
const
tabTopFrameState
=
documentTranslationStates
.
find
(
(
dts
)
=
>
dts
.
frameId
=
=
=
0
)
;
if
(
!
tabTopFrameState
)
{
const
tabTranslationState
=
new
TabTranslationState_1
.
TabTranslationState
(
Object
.
assign
(
{
tabId
}
mobx_keystone_1
.
getSnapshot
(
documentTranslationStates
[
0
]
)
)
)
;
map
.
set
(
tabId
tabTranslationState
)
;
return
;
}
const
{
isVisible
displayQualityEstimation
translationRequested
cancellationRequested
detectedLanguageResults
translateFrom
translateTo
windowId
showOriginal
url
}
=
mobx_keystone_1
.
getSnapshot
(
tabTopFrameState
)
;
const
wordCount
=
documentTranslationStates
.
map
(
dts
=
>
dts
.
wordCount
)
.
reduce
(
(
a
b
)
=
>
a
+
b
0
)
;
const
wordCountVisible
=
documentTranslationStates
.
map
(
dts
=
>
dts
.
wordCountVisible
)
.
reduce
(
(
a
b
)
=
>
a
+
b
0
)
;
const
wordCountVisibleInViewport
=
documentTranslationStates
.
map
(
dts
=
>
dts
.
wordCountVisibleInViewport
)
.
reduce
(
(
a
b
)
=
>
a
+
b
0
)
;
const
totalModelLoadWallTimeMs
=
documentTranslationStates
.
map
(
dts
=
>
dts
.
totalModelLoadWallTimeMs
)
.
reduce
(
(
a
b
)
=
>
a
+
b
0
)
;
const
totalTranslationWallTimeMs
=
documentTranslationStates
.
map
(
dts
=
>
dts
.
totalTranslationWallTimeMs
)
.
reduce
(
(
a
b
)
=
>
a
+
b
0
)
;
const
totalTranslationEngineRequestCount
=
documentTranslationStates
.
map
(
dts
=
>
dts
.
totalTranslationEngineRequestCount
)
.
reduce
(
(
a
b
)
=
>
a
+
b
0
)
;
const
queuedTranslationEngineRequestCount
=
documentTranslationStates
.
map
(
dts
=
>
dts
.
queuedTranslationEngineRequestCount
)
.
reduce
(
(
a
b
)
=
>
a
+
b
0
)
;
const
translationInitiationTimestamps
=
documentTranslationStates
.
map
(
(
dts
)
=
>
dts
.
translationInitiationTimestamp
)
;
const
translationInitiationTimestamp
=
Math
.
min
(
.
.
.
translationInitiationTimestamps
)
;
const
modelLoadNecessary
=
!
!
documentTranslationStates
.
filter
(
(
dts
)
=
>
dts
.
modelLoadNecessary
)
.
length
;
const
modelDownloadNecessary
=
!
!
documentTranslationStates
.
filter
(
(
dts
)
=
>
dts
.
modelDownloadNecessary
)
.
length
;
const
modelDownloading
=
!
!
documentTranslationStates
.
filter
(
(
dts
)
=
>
dts
.
modelDownloading
)
.
length
;
const
modelLoading
=
modelLoadNecessary
?
!
!
documentTranslationStates
.
find
(
(
dts
)
=
>
dts
.
modelLoading
)
:
undefined
;
const
modelLoaded
=
modelLoadNecessary
?
!
!
documentTranslationStates
.
find
(
(
dts
)
=
>
!
dts
.
modelLoaded
)
:
undefined
;
const
translationFinished
=
documentTranslationStates
.
filter
(
(
dts
)
=
>
!
dts
.
translationFinished
)
.
length
=
=
=
0
;
const
emptyDownloadProgress
=
{
bytesDownloaded
:
0
bytesToDownload
:
0
startTs
:
undefined
durationMs
:
0
endTs
:
undefined
}
;
const
modelDownloadProgress
=
documentTranslationStates
.
map
(
(
dts
)
=
>
mobx_keystone_1
.
getSnapshot
(
dts
.
modelDownloadProgress
)
)
.
filter
(
(
mdp
)
=
>
mdp
)
.
reduce
(
(
a
b
)
=
>
{
const
startTs
=
a
.
startTs
&
&
a
.
startTs
<
=
b
.
startTs
?
a
.
startTs
:
b
.
startTs
;
const
endTs
=
a
.
endTs
&
&
a
.
endTs
>
=
b
.
endTs
?
a
.
endTs
:
b
.
endTs
;
return
{
bytesDownloaded
:
a
.
bytesDownloaded
+
b
.
bytesDownloaded
bytesToDownload
:
a
.
bytesToDownload
+
b
.
bytesToDownload
startTs
durationMs
:
endTs
?
endTs
-
startTs
:
Date
.
now
(
)
-
startTs
endTs
}
;
}
emptyDownloadProgress
)
;
const
modelLoadErrorOccurred
=
!
!
documentTranslationStates
.
filter
(
(
dts
)
=
>
dts
.
modelLoadErrorOccurred
)
.
length
;
const
modelDownloadErrorOccurred
=
!
!
documentTranslationStates
.
filter
(
(
dts
)
=
>
dts
.
modelDownloadErrorOccurred
)
.
length
;
const
translationErrorOccurred
=
!
!
documentTranslationStates
.
filter
(
(
dts
)
=
>
dts
.
translationErrorOccurred
)
.
length
;
const
otherErrorOccurred
=
!
!
documentTranslationStates
.
filter
(
(
dts
)
=
>
dts
.
otherErrorOccurred
)
.
length
;
const
anyTabHasTranslationStatus
=
(
translationStatus
)
=
>
documentTranslationStates
.
find
(
dts
=
>
dts
.
translationStatus
=
=
=
translationStatus
)
;
const
tabTranslationStatus
=
(
)
=
>
{
if
(
anyTabHasTranslationStatus
(
BaseTranslationState_1
.
TranslationStatus
.
DETECTING_LANGUAGE
)
)
{
return
BaseTranslationState_1
.
TranslationStatus
.
DETECTING_LANGUAGE
;
}
if
(
anyTabHasTranslationStatus
(
BaseTranslationState_1
.
TranslationStatus
.
DOWNLOADING_TRANSLATION_MODEL
)
)
{
return
BaseTranslationState_1
.
TranslationStatus
.
DOWNLOADING_TRANSLATION_MODEL
;
}
if
(
anyTabHasTranslationStatus
(
BaseTranslationState_1
.
TranslationStatus
.
TRANSLATING
)
)
{
return
BaseTranslationState_1
.
TranslationStatus
.
TRANSLATING
;
}
if
(
anyTabHasTranslationStatus
(
BaseTranslationState_1
.
TranslationStatus
.
ERROR
)
)
{
return
BaseTranslationState_1
.
TranslationStatus
.
ERROR
;
}
return
tabTopFrameState
.
translationStatus
;
}
;
const
translationStatus
=
tabTranslationStatus
(
)
;
const
tabTranslationStateData
=
{
isVisible
displayQualityEstimation
translationRequested
cancellationRequested
detectedLanguageResults
translateFrom
translateTo
translationStatus
tabId
windowId
showOriginal
url
wordCount
wordCountVisible
wordCountVisibleInViewport
translationInitiationTimestamp
totalModelLoadWallTimeMs
totalTranslationWallTimeMs
totalTranslationEngineRequestCount
queuedTranslationEngineRequestCount
modelLoadNecessary
modelDownloadNecessary
modelDownloading
modelDownloadProgress
modelLoading
modelLoaded
translationFinished
modelLoadErrorOccurred
modelDownloadErrorOccurred
translationErrorOccurred
otherErrorOccurred
}
;
const
tabTranslationState
=
new
TabTranslationState_1
.
TabTranslationState
(
tabTranslationStateData
)
;
map
.
set
(
tabId
tabTranslationState
)
;
}
)
;
return
map
;
}
tabSpecificDocumentTranslationStates
(
tabId
)
{
const
result
=
[
]
;
this
.
documentTranslationStates
.
forEach
(
(
documentTranslationState
)
=
>
{
if
(
documentTranslationState
.
tabId
=
=
=
tabId
)
{
result
.
push
(
documentTranslationState
)
;
}
}
)
;
return
result
;
}
requestTranslationOfAllFramesInTab
(
tabId
from
to
)
{
this
.
tabSpecificDocumentTranslationStates
(
tabId
)
.
forEach
(
(
dts
)
=
>
{
this
.
patchDocumentTranslationStateByFrameInfo
(
dts
[
{
op
:
"
replace
"
path
:
[
"
translateFrom
"
]
value
:
from
}
{
op
:
"
replace
"
path
:
[
"
translateTo
"
]
value
:
to
}
{
op
:
"
replace
"
path
:
[
"
translationRequested
"
]
value
:
true
}
]
)
;
}
)
;
}
showOriginalInTab
(
tabId
)
{
this
.
tabSpecificDocumentTranslationStates
(
tabId
)
.
forEach
(
(
dts
)
=
>
{
this
.
patchDocumentTranslationStateByFrameInfo
(
dts
[
{
op
:
"
replace
"
path
:
[
"
showOriginal
"
]
value
:
true
}
]
)
;
}
)
;
}
hideOriginalInTab
(
tabId
)
{
this
.
tabSpecificDocumentTranslationStates
(
tabId
)
.
forEach
(
(
dts
)
=
>
{
this
.
patchDocumentTranslationStateByFrameInfo
(
dts
[
{
op
:
"
replace
"
path
:
[
"
showOriginal
"
]
value
:
false
}
]
)
;
}
)
;
}
}
;
__decorate
(
[
mobx_keystone_1
.
modelAction
]
ExtensionState
.
prototype
"
setDocumentTranslationState
"
null
)
;
__decorate
(
[
mobx_keystone_1
.
modelAction
]
ExtensionState
.
prototype
"
patchDocumentTranslationStateByFrameInfo
"
null
)
;
__decorate
(
[
mobx_keystone_1
.
modelAction
]
ExtensionState
.
prototype
"
deleteDocumentTranslationStateByFrameInfo
"
null
)
;
__decorate
(
[
mobx_keystone_1
.
modelAction
]
ExtensionState
.
prototype
"
setTranslateOwnTextTranslationState
"
null
)
;
__decorate
(
[
mobx_keystone_1
.
modelAction
]
ExtensionState
.
prototype
"
deleteTranslateOwnTextTranslationState
"
null
)
;
__decorate
(
[
mobx_1
.
computed
]
ExtensionState
.
prototype
"
documentTranslationStatesByTabId
"
null
)
;
__decorate
(
[
mobx_1
.
computed
]
ExtensionState
.
prototype
"
tabTranslationStates
"
null
)
;
ExtensionState
=
__decorate
(
[
mobx_keystone_1
.
model
(
"
bergamotTranslate
/
ExtensionState
"
)
]
ExtensionState
)
;
exports
.
ExtensionState
=
ExtensionState
;
}
)
6556
:
(
function
(
__unused_webpack_module
exports
__webpack_require__
)
{
"
use
strict
"
;
var
__decorate
=
(
this
&
&
this
.
__decorate
)
|
|
function
(
decorators
target
key
desc
)
{
var
c
=
arguments
.
length
r
=
c
<
3
?
target
:
desc
=
=
=
null
?
desc
=
Object
.
getOwnPropertyDescriptor
(
target
key
)
:
desc
d
;
if
(
typeof
Reflect
=
=
=
"
object
"
&
&
typeof
Reflect
.
decorate
=
=
=
"
function
"
)
r
=
Reflect
.
decorate
(
decorators
target
key
desc
)
;
else
for
(
var
i
=
decorators
.
length
-
1
;
i
>
=
0
;
i
-
-
)
if
(
d
=
decorators
[
i
]
)
r
=
(
c
<
3
?
d
(
r
)
:
c
>
3
?
d
(
target
key
r
)
:
d
(
target
key
)
)
|
|
r
;
return
c
>
3
&
&
r
&
&
Object
.
defineProperty
(
target
key
r
)
r
;
}
;
Object
.
defineProperty
(
exports
"
__esModule
"
(
{
value
:
true
}
)
)
;
exports
.
TabTranslationState
=
void
0
;
const
mobx_keystone_1
=
__webpack_require__
(
7680
)
;
const
BaseTranslationState_1
=
__webpack_require__
(
4779
)
;
let
TabTranslationState
=
class
TabTranslationState
extends
mobx_keystone_1
.
ExtendedModel
(
BaseTranslationState_1
.
BaseTranslationState
{
windowId
:
mobx_keystone_1
.
prop
(
)
showOriginal
:
mobx_keystone_1
.
prop
(
{
setterAction
:
true
}
)
url
:
mobx_keystone_1
.
prop
(
)
}
)
{
}
;
TabTranslationState
=
__decorate
(
[
mobx_keystone_1
.
model
(
"
bergamotTranslate
/
TabTranslationState
"
)
]
TabTranslationState
)
;
exports
.
TabTranslationState
=
TabTranslationState
;
}
)
8238
:
(
function
(
__unused_webpack_module
exports
__webpack_require__
)
{
"
use
strict
"
;
var
__decorate
=
(
this
&
&
this
.
__decorate
)
|
|
function
(
decorators
target
key
desc
)
{
var
c
=
arguments
.
length
r
=
c
<
3
?
target
:
desc
=
=
=
null
?
desc
=
Object
.
getOwnPropertyDescriptor
(
target
key
)
:
desc
d
;
if
(
typeof
Reflect
=
=
=
"
object
"
&
&
typeof
Reflect
.
decorate
=
=
=
"
function
"
)
r
=
Reflect
.
decorate
(
decorators
target
key
desc
)
;
else
for
(
var
i
=
decorators
.
length
-
1
;
i
>
=
0
;
i
-
-
)
if
(
d
=
decorators
[
i
]
)
r
=
(
c
<
3
?
d
(
r
)
:
c
>
3
?
d
(
target
key
r
)
:
d
(
target
key
)
)
|
|
r
;
return
c
>
3
&
&
r
&
&
Object
.
defineProperty
(
target
key
r
)
r
;
}
;
Object
.
defineProperty
(
exports
"
__esModule
"
(
{
value
:
true
}
)
)
;
exports
.
TranslateOwnTextTranslationState
=
void
0
;
const
mobx_keystone_1
=
__webpack_require__
(
7680
)
;
const
BaseTranslationState_1
=
__webpack_require__
(
4779
)
;
let
TranslateOwnTextTranslationState
=
class
TranslateOwnTextTranslationState
extends
mobx_keystone_1
.
ExtendedModel
(
BaseTranslationState_1
.
BaseTranslationState
{
translateAutomatically
:
mobx_keystone_1
.
prop
(
true
)
}
)
{
}
;
TranslateOwnTextTranslationState
=
__decorate
(
[
mobx_keystone_1
.
model
(
"
bergamotTranslate
/
TranslateOwnTextTranslationState
"
)
]
TranslateOwnTextTranslationState
)
;
exports
.
TranslateOwnTextTranslationState
=
TranslateOwnTextTranslationState
;
}
)
4971
:
(
function
(
__unused_webpack_module
exports
__webpack_require__
)
{
"
use
strict
"
;
var
__awaiter
=
(
this
&
&
this
.
__awaiter
)
|
|
function
(
thisArg
_arguments
P
generator
)
{
function
adopt
(
value
)
{
return
value
instanceof
P
?
value
:
new
P
(
function
(
resolve
)
{
resolve
(
value
)
;
}
)
;
}
return
new
(
P
|
|
(
P
=
Promise
)
)
(
function
(
resolve
reject
)
{
function
fulfilled
(
value
)
{
try
{
step
(
generator
.
next
(
value
)
)
;
}
catch
(
e
)
{
reject
(
e
)
;
}
}
function
rejected
(
value
)
{
try
{
step
(
generator
[
"
throw
"
]
(
value
)
)
;
}
catch
(
e
)
{
reject
(
e
)
;
}
}
function
step
(
result
)
{
result
.
done
?
resolve
(
result
.
value
)
:
adopt
(
result
.
value
)
.
then
(
fulfilled
rejected
)
;
}
step
(
(
generator
=
generator
.
apply
(
thisArg
_arguments
|
|
[
]
)
)
.
next
(
)
)
;
}
)
;
}
;
Object
.
defineProperty
(
exports
"
__esModule
"
(
{
value
:
true
}
)
)
;
exports
.
communicateExtensionPreferenceChangesToContentScripts
=
exports
.
subscribeToExtensionPreferenceChangesInContentScript
=
exports
.
subscribeToExtensionPreferenceChangesInBackgroundScript
=
void
0
;
const
webextension_polyfill_ts_1
=
__webpack_require__
(
3624
)
;
const
subscribeToExtensionPreferenceChangesInBackgroundScript
=
(
store
callback
)
=
>
__awaiter
(
void
0
void
0
void
0
function
*
(
)
{
const
extensionPreferences
=
yield
store
.
getExtensionPreferences
(
)
;
callback
(
extensionPreferences
)
;
const
originalSetExtensionPreferences
=
store
.
setExtensionPreferences
.
bind
(
store
)
;
store
.
setExtensionPreferences
=
(
extensionPreferences
)
=
>
__awaiter
(
void
0
void
0
void
0
function
*
(
)
{
yield
originalSetExtensionPreferences
(
extensionPreferences
)
;
callback
(
yield
store
.
getExtensionPreferences
(
)
)
;
}
)
;
}
)
;
exports
.
subscribeToExtensionPreferenceChangesInBackgroundScript
=
subscribeToExtensionPreferenceChangesInBackgroundScript
;
const
subscribeToExtensionPreferenceChangesInContentScript
=
(
portName
callback
)
=
>
__awaiter
(
void
0
void
0
void
0
function
*
(
)
{
const
port
=
webextension_polyfill_ts_1
.
browser
.
runtime
.
connect
(
webextension_polyfill_ts_1
.
browser
.
runtime
.
id
{
name
:
portName
}
)
;
return
new
Promise
(
(
resolve
reject
)
=
>
{
port
.
postMessage
(
{
requestExtensionPreferences
:
true
}
)
;
port
.
onMessage
.
addListener
(
(
m
)
=
>
__awaiter
(
void
0
void
0
void
0
function
*
(
)
{
if
(
m
.
extensionPreferences
)
{
const
{
extensionPreferences
}
=
m
;
callback
(
extensionPreferences
)
;
resolve
(
)
;
}
reject
(
"
Unexpected
message
"
)
;
}
)
)
;
}
)
;
}
)
;
exports
.
subscribeToExtensionPreferenceChangesInContentScript
=
subscribeToExtensionPreferenceChangesInContentScript
;
const
communicateExtensionPreferenceChangesToContentScripts
=
(
store
portNames
)
=
>
__awaiter
(
void
0
void
0
void
0
function
*
(
)
{
const
connectedPorts
=
{
}
;
const
originalSetExtensionPreferences
=
store
.
setExtensionPreferences
.
bind
(
store
)
;
store
.
setExtensionPreferences
=
(
extensionPreferences
)
=
>
__awaiter
(
void
0
void
0
void
0
function
*
(
)
{
yield
originalSetExtensionPreferences
(
extensionPreferences
)
;
Object
.
keys
(
connectedPorts
)
.
forEach
(
(
portName
)
=
>
__awaiter
(
void
0
void
0
void
0
function
*
(
)
{
const
port
=
connectedPorts
[
portName
]
;
port
.
postMessage
(
{
extensionPreferences
:
yield
store
.
getExtensionPreferences
(
)
}
)
;
}
)
)
;
}
)
;
const
extensionPreferencesContentScriptPortListener
=
(
port
)
=
>
{
if
(
!
portNames
.
includes
(
port
.
name
)
)
{
return
;
}
port
.
onMessage
.
addListener
(
function
(
m
)
{
return
__awaiter
(
this
void
0
void
0
function
*
(
)
{
connectedPorts
[
port
.
name
]
=
port
;
if
(
m
.
requestExtensionPreferences
)
{
port
.
postMessage
(
{
extensionPreferences
:
yield
store
.
getExtensionPreferences
(
)
}
)
;
}
if
(
m
.
saveExtensionPreferences
)
{
const
{
updatedExtensionPreferences
}
=
m
.
saveExtensionPreferences
;
yield
store
.
setExtensionPreferences
(
updatedExtensionPreferences
)
;
port
.
postMessage
(
{
extensionPreferences
:
yield
store
.
getExtensionPreferences
(
)
}
)
;
}
}
)
;
}
)
;
port
.
onDisconnect
.
addListener
(
(
port
)
=
>
{
delete
connectedPorts
[
port
.
name
]
;
}
)
;
}
;
webextension_polyfill_ts_1
.
browser
.
runtime
.
onConnect
.
addListener
(
extensionPreferencesContentScriptPortListener
)
;
return
extensionPreferencesContentScriptPortListener
;
}
)
;
exports
.
communicateExtensionPreferenceChangesToContentScripts
=
communicateExtensionPreferenceChangesToContentScripts
;
}
)
}
]
)
;
