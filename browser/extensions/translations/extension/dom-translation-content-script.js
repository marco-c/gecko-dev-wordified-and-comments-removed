(
(
)
=
>
{
"
use
strict
"
;
var
__webpack_modules__
=
(
{
3550
:
(
function
(
__unused_webpack_module
exports
__webpack_require__
)
{
var
__awaiter
=
(
this
&
&
this
.
__awaiter
)
|
|
function
(
thisArg
_arguments
P
generator
)
{
function
adopt
(
value
)
{
return
value
instanceof
P
?
value
:
new
P
(
function
(
resolve
)
{
resolve
(
value
)
;
}
)
;
}
return
new
(
P
|
|
(
P
=
Promise
)
)
(
function
(
resolve
reject
)
{
function
fulfilled
(
value
)
{
try
{
step
(
generator
.
next
(
value
)
)
;
}
catch
(
e
)
{
reject
(
e
)
;
}
}
function
rejected
(
value
)
{
try
{
step
(
generator
[
"
throw
"
]
(
value
)
)
;
}
catch
(
e
)
{
reject
(
e
)
;
}
}
function
step
(
result
)
{
result
.
done
?
resolve
(
result
.
value
)
:
adopt
(
result
.
value
)
.
then
(
fulfilled
rejected
)
;
}
step
(
(
generator
=
generator
.
apply
(
thisArg
_arguments
|
|
[
]
)
)
.
next
(
)
)
;
}
)
;
}
;
Object
.
defineProperty
(
exports
"
__esModule
"
(
{
value
:
true
}
)
)
;
exports
.
DomTranslationManager
=
void
0
;
const
TranslationDocument_1
=
__webpack_require__
(
3451
)
;
const
BergamotDomTranslator_1
=
__webpack_require__
(
7668
)
;
const
ContentScriptLanguageDetectorProxy_1
=
__webpack_require__
(
8341
)
;
const
BaseTranslationState_1
=
__webpack_require__
(
9359
)
;
const
LanguageSupport_1
=
__webpack_require__
(
3872
)
;
class
DomTranslationManager
{
constructor
(
documentTranslationStateCommunicator
document
contentWindow
)
{
this
.
documentTranslationStateCommunicator
=
documentTranslationStateCommunicator
;
this
.
document
=
document
;
this
.
contentWindow
=
contentWindow
;
this
.
languageDetector
=
new
ContentScriptLanguageDetectorProxy_1
.
ContentScriptLanguageDetectorProxy
(
)
;
}
getTranslationDocument
(
)
{
return
(
this
.
contentWindow
.
translationDocument
|
|
new
TranslationDocument_1
.
TranslationDocument
(
this
.
document
)
)
;
}
attemptToDetectLanguage
(
)
{
return
__awaiter
(
this
void
0
void
0
function
*
(
)
{
console
.
debug
(
"
Attempting
to
detect
language
"
)
;
const
url
=
String
(
this
.
document
.
location
)
;
if
(
!
url
.
startsWith
(
"
http
:
/
/
"
)
&
&
!
url
.
startsWith
(
"
https
:
/
/
"
)
)
{
console
.
debug
(
"
Not
a
HTTP
(
S
)
url
translation
unavailable
"
{
url
}
)
;
this
.
documentTranslationStateCommunicator
.
broadcastUpdatedTranslationStatus
(
BaseTranslationState_1
.
TranslationStatus
.
UNAVAILABLE
)
;
return
;
}
console
.
debug
(
"
Setting
status
to
reflect
detection
of
language
ongoing
"
)
;
this
.
documentTranslationStateCommunicator
.
broadcastUpdatedTranslationStatus
(
BaseTranslationState_1
.
TranslationStatus
.
DETECTING_LANGUAGE
)
;
const
startGetTranslationNodes
=
performance
.
now
(
)
;
const
translationRoots
=
this
.
getTranslationDocument
(
)
.
translationRoots
;
const
endGetTranslationNodes
=
performance
.
now
(
)
;
console
.
info
(
Extracting
translation
nodes
from
the
document
took
{
(
endGetTranslationNodes
-
startGetTranslationNodes
)
/
1000
}
seconds
)
;
const
startGrabSample
=
performance
.
now
(
)
;
const
grabTranslationNodesSample
=
(
translationRoots
maxLength
)
=
>
{
let
totalLength
=
0
;
const
textContents
=
[
]
;
translationRoots
.
some
(
translationItem
=
>
{
const
textContent
=
translationItem
.
nodeRef
.
textContent
;
textContents
.
push
(
textContent
)
;
totalLength
+
=
textContent
.
length
;
return
totalLength
>
=
maxLength
;
}
)
;
return
textContents
.
join
(
"
\
n
"
)
.
substr
(
0
maxLength
)
;
}
;
const
string
=
grabTranslationNodesSample
(
translationRoots
60
*
1024
)
;
const
endGrabSample
=
performance
.
now
(
)
;
console
.
info
(
Grabbing
a
DOM
sample
for
language
detection
took
{
(
endGrabSample
-
startGrabSample
)
/
1000
}
seconds
)
;
if
(
string
.
length
<
100
)
{
console
.
debug
(
"
Language
detection
isn
'
t
reliable
on
very
short
strings
.
Skipping
language
detection
"
{
string
}
)
;
this
.
documentTranslationStateCommunicator
.
broadcastUpdatedTranslationStatus
(
BaseTranslationState_1
.
TranslationStatus
.
LANGUAGE_NOT_DETECTED
)
;
return
;
}
const
detectedLanguageResults
=
yield
this
.
languageDetector
.
detectLanguage
(
string
)
;
console
.
debug
(
"
Language
detection
results
are
in
"
{
detectedLanguageResults
}
)
;
if
(
!
this
.
contentWindow
)
{
console
.
info
(
"
Content
window
reference
invalid
deleting
document
translation
state
"
)
;
this
.
documentTranslationStateCommunicator
.
clear
(
)
;
return
;
}
this
.
documentTranslationStateCommunicator
.
updatedDetectedLanguageResults
(
detectedLanguageResults
)
;
if
(
!
detectedLanguageResults
.
confident
)
{
console
.
debug
(
"
Language
detection
results
not
confident
enough
bailing
.
"
{
string
}
)
;
this
.
documentTranslationStateCommunicator
.
broadcastUpdatedTranslationStatus
(
BaseTranslationState_1
.
TranslationStatus
.
LANGUAGE_NOT_DETECTED
)
;
return
;
}
console
.
debug
(
"
Updating
state
to
reflect
that
language
has
been
detected
"
)
;
yield
this
.
checkLanguageSupport
(
detectedLanguageResults
)
;
}
)
;
}
checkLanguageSupport
(
detectedLanguageResults
)
{
return
__awaiter
(
this
void
0
void
0
function
*
(
)
{
const
{
summarizeLanguageSupport
}
=
new
LanguageSupport_1
.
LanguageSupport
(
)
;
const
detectedLanguage
=
detectedLanguageResults
.
language
;
const
{
acceptedTargetLanguages
defaultTargetLanguage
supportedSourceLanguages
supportedTargetLanguagesGivenDefaultSourceLanguage
allPossiblySupportedTargetLanguages
}
=
yield
summarizeLanguageSupport
(
detectedLanguageResults
)
;
if
(
acceptedTargetLanguages
.
includes
(
detectedLanguage
)
)
{
console
.
info
(
"
Detected
language
is
in
one
of
the
user
'
s
accepted
target
languages
.
"
{
acceptedTargetLanguages
}
)
;
this
.
documentTranslationStateCommunicator
.
broadcastUpdatedTranslationStatus
(
BaseTranslationState_1
.
TranslationStatus
.
SOURCE_LANGUAGE_UNDERSTOOD
)
;
return
;
}
if
(
!
supportedSourceLanguages
.
includes
(
detectedLanguage
)
)
{
console
.
info
(
"
Detected
language
is
not
part
of
the
supported
source
languages
.
"
{
detectedLanguage
supportedSourceLanguages
}
)
;
this
.
documentTranslationStateCommunicator
.
broadcastUpdatedTranslationStatus
(
BaseTranslationState_1
.
TranslationStatus
.
TRANSLATION_UNSUPPORTED
)
;
return
;
}
if
(
!
allPossiblySupportedTargetLanguages
.
includes
(
defaultTargetLanguage
)
)
{
console
.
info
(
"
Default
target
language
is
not
part
of
the
supported
target
languages
.
"
{
acceptedTargetLanguages
defaultTargetLanguage
allPossiblySupportedTargetLanguages
}
)
;
this
.
documentTranslationStateCommunicator
.
broadcastUpdatedTranslationStatus
(
BaseTranslationState_1
.
TranslationStatus
.
TRANSLATION_UNSUPPORTED
)
;
return
;
}
if
(
!
defaultTargetLanguage
|
|
!
supportedTargetLanguagesGivenDefaultSourceLanguage
.
includes
(
defaultTargetLanguage
)
)
{
console
.
info
(
"
Combination
of
source
and
target
languages
unsupported
.
"
{
acceptedTargetLanguages
defaultTargetLanguage
supportedTargetLanguagesGivenDefaultSourceLanguage
}
)
;
this
.
documentTranslationStateCommunicator
.
broadcastUpdatedTranslationStatus
(
BaseTranslationState_1
.
TranslationStatus
.
TRANSLATION_UNSUPPORTED
)
;
return
;
}
this
.
documentTranslationStateCommunicator
.
broadcastUpdatedTranslationStatus
(
BaseTranslationState_1
.
TranslationStatus
.
OFFER
)
;
}
)
;
}
doTranslation
(
from
to
)
{
return
__awaiter
(
this
void
0
void
0
function
*
(
)
{
const
translationDocument
=
this
.
getTranslationDocument
(
)
;
console
.
info
(
"
Translating
web
page
"
)
;
const
domTranslator
=
new
BergamotDomTranslator_1
.
BergamotDomTranslator
(
translationDocument
from
to
)
;
this
.
contentWindow
.
translationDocument
=
translationDocument
;
translationDocument
.
translatedFrom
=
from
;
translationDocument
.
translatedTo
=
to
;
translationDocument
.
translationError
=
false
;
try
{
console
.
info
(
About
to
translate
web
page
document
(
{
translationDocument
.
translationRoots
.
length
}
translation
items
)
{
from
to
}
)
;
yield
domTranslator
.
translate
(
(
frameTranslationProgress
)
=
>
{
this
.
documentTranslationStateCommunicator
.
broadcastUpdatedFrameTranslationProgress
(
frameTranslationProgress
)
;
}
)
;
console
.
info
(
Translation
of
web
page
document
completed
(
translated
{
translationDocument
.
translationRoots
.
filter
(
translationRoot
=
>
translationRoot
.
currentDisplayMode
=
=
=
"
translation
"
)
.
length
}
out
of
{
translationDocument
.
translationRoots
.
length
}
translation
items
)
{
from
to
}
)
;
console
.
info
(
"
Translated
web
page
"
)
;
}
catch
(
err
)
{
console
.
warn
(
"
Translation
error
occurred
:
"
err
)
;
translationDocument
.
translationError
=
true
;
}
finally
{
this
.
documentTranslationStateCommunicator
.
broadcastTranslationAttemptConcluded
(
translationDocument
.
translationError
domTranslator
.
derivedTranslationDocumentData
)
;
domTranslator
.
errorsEncountered
.
forEach
(
(
error
)
=
>
{
if
(
error
.
name
=
=
=
"
BergamotTranslatorAPIModelLoadError
"
)
{
this
.
documentTranslationStateCommunicator
.
broadcastUpdatedAttributeValue
(
"
modelLoadErrorOccurred
"
true
)
;
}
else
if
(
error
.
name
=
=
=
"
BergamotTranslatorAPIModelDownloadError
"
)
{
this
.
documentTranslationStateCommunicator
.
broadcastUpdatedAttributeValue
(
"
modelDownloadErrorOccurred
"
true
)
;
}
else
if
(
error
.
name
=
=
=
"
BergamotTranslatorAPITranslationError
"
)
{
this
.
documentTranslationStateCommunicator
.
broadcastUpdatedAttributeValue
(
"
translationErrorOccurred
"
true
)
;
}
else
{
this
.
documentTranslationStateCommunicator
.
broadcastUpdatedAttributeValue
(
"
otherErrorOccurred
"
true
)
;
}
}
)
;
}
}
)
;
}
}
exports
.
DomTranslationManager
=
DomTranslationManager
;
}
)
3451
:
(
function
(
__unused_webpack_module
exports
__webpack_require__
)
{
var
__awaiter
=
(
this
&
&
this
.
__awaiter
)
|
|
function
(
thisArg
_arguments
P
generator
)
{
function
adopt
(
value
)
{
return
value
instanceof
P
?
value
:
new
P
(
function
(
resolve
)
{
resolve
(
value
)
;
}
)
;
}
return
new
(
P
|
|
(
P
=
Promise
)
)
(
function
(
resolve
reject
)
{
function
fulfilled
(
value
)
{
try
{
step
(
generator
.
next
(
value
)
)
;
}
catch
(
e
)
{
reject
(
e
)
;
}
}
function
rejected
(
value
)
{
try
{
step
(
generator
[
"
throw
"
]
(
value
)
)
;
}
catch
(
e
)
{
reject
(
e
)
;
}
}
function
step
(
result
)
{
result
.
done
?
resolve
(
result
.
value
)
:
adopt
(
result
.
value
)
.
then
(
fulfilled
rejected
)
;
}
step
(
(
generator
=
generator
.
apply
(
thisArg
_arguments
|
|
[
]
)
)
.
next
(
)
)
;
}
)
;
}
;
Object
.
defineProperty
(
exports
"
__esModule
"
(
{
value
:
true
}
)
)
;
exports
.
generateMarkupToTranslateForItem
=
exports
.
TranslationDocument
=
void
0
;
const
getTranslationNodes_1
=
__webpack_require__
(
2542
)
;
const
TranslationItem_1
=
__webpack_require__
(
664
)
;
class
TranslationDocument
{
constructor
(
document
)
{
this
.
translatedFrom
=
"
"
;
this
.
translatedTo
=
"
"
;
this
.
translationError
=
false
;
this
.
originalShown
=
true
;
this
.
qualityEstimationShown
=
true
;
this
.
paintProcessedNodes
=
false
;
this
.
nodeTranslationItemsMap
=
new
Map
(
)
;
this
.
translationRoots
=
[
]
;
this
.
_init
(
document
)
;
}
_init
(
document
)
{
const
translationNodes
=
getTranslationNodes_1
.
getTranslationNodes
(
document
.
body
)
;
console
.
info
(
The
document
has
a
total
of
{
translationNodes
.
length
}
translation
nodes
of
which
{
translationNodes
.
filter
(
tn
=
>
tn
.
isTranslationRoot
)
.
length
}
are
translation
roots
)
;
translationNodes
.
forEach
(
(
translationNode
index
)
=
>
{
const
{
content
isTranslationRoot
}
=
translationNode
;
if
(
this
.
paintProcessedNodes
)
{
content
.
style
.
backgroundColor
=
"
darkorange
"
;
}
this
.
_createItemForNode
(
content
index
isTranslationRoot
)
;
}
)
;
for
(
const
translationRoot
of
this
.
translationRoots
)
{
if
(
!
translationRoot
.
children
.
length
&
&
translationRoot
.
nodeRef
instanceof
Element
&
&
translationRoot
.
nodeRef
.
childElementCount
=
=
=
0
)
{
translationRoot
.
isSimleTranslationRoot
=
true
;
if
(
this
.
paintProcessedNodes
)
{
translationRoot
.
nodeRef
.
style
.
backgroundColor
=
"
orange
"
;
}
}
}
}
_createItemForNode
(
node
id
isTranslationRoot
)
{
if
(
this
.
nodeTranslationItemsMap
.
has
(
node
)
)
{
return
this
.
nodeTranslationItemsMap
.
get
(
node
)
;
}
const
item
=
new
TranslationItem_1
.
TranslationItem
(
node
id
isTranslationRoot
)
;
if
(
isTranslationRoot
)
{
this
.
translationRoots
.
push
(
item
)
;
}
else
{
let
ancestorTranslationItem
;
for
(
let
ancestor
=
node
.
parentNode
;
ancestor
;
ancestor
=
ancestor
.
parentNode
)
{
ancestorTranslationItem
=
this
.
nodeTranslationItemsMap
.
get
(
ancestor
)
;
if
(
ancestorTranslationItem
)
{
ancestorTranslationItem
.
children
.
push
(
item
)
;
break
;
}
else
{
this
.
nodeTranslationItemsMap
.
set
(
ancestor
item
)
;
}
}
}
this
.
nodeTranslationItemsMap
.
set
(
node
item
)
;
return
item
;
}
generateMarkupToTranslate
(
item
)
{
if
(
!
item
.
original
)
{
item
.
original
=
this
.
generateOriginalStructureElements
(
item
)
;
}
return
regenerateMarkupToTranslateFromOriginal
(
item
)
;
}
generateOriginalStructureElements
(
item
)
{
const
original
=
[
]
;
if
(
item
.
isSimleTranslationRoot
)
{
const
text
=
item
.
nodeRef
.
firstChild
.
nodeValue
.
trim
(
)
;
original
.
push
(
text
)
;
return
original
;
}
let
wasLastItemPlaceholder
=
false
;
for
(
const
child
of
Array
.
from
(
item
.
nodeRef
.
childNodes
)
)
{
if
(
child
.
nodeType
=
=
=
child
.
TEXT_NODE
)
{
const
x
=
child
.
nodeValue
;
const
hasLeadingWhitespace
=
x
.
length
!
=
=
x
.
trimStart
(
)
.
length
;
const
hasTrailingWhitespace
=
x
.
length
!
=
=
x
.
trimEnd
(
)
.
length
;
if
(
x
.
trim
(
)
!
=
=
"
"
)
{
const
xWithNormalizedWhitespace
=
{
hasLeadingWhitespace
?
"
"
:
"
"
}
{
x
.
trim
(
)
}
{
hasTrailingWhitespace
?
"
"
:
"
"
}
;
original
.
push
(
xWithNormalizedWhitespace
)
;
wasLastItemPlaceholder
=
false
;
}
continue
;
}
const
objInMap
=
this
.
nodeTranslationItemsMap
.
get
(
child
)
;
if
(
objInMap
&
&
!
objInMap
.
isTranslationRoot
)
{
original
.
push
(
objInMap
)
;
objInMap
.
original
=
this
.
generateOriginalStructureElements
(
objInMap
)
;
wasLastItemPlaceholder
=
false
;
}
else
if
(
!
wasLastItemPlaceholder
)
{
original
.
push
(
new
TranslationItem_1
.
TranslationItem_NodePlaceholder
(
)
)
;
wasLastItemPlaceholder
=
true
;
}
}
return
original
;
}
showTranslation
(
)
{
this
.
originalShown
=
false
;
this
.
qualityEstimationShown
=
false
;
this
.
_swapDocumentContent
(
"
translation
"
)
;
}
showOriginal
(
)
{
this
.
originalShown
=
true
;
this
.
qualityEstimationShown
=
false
;
this
.
_swapDocumentContent
(
"
original
"
)
;
}
showQualityEstimation
(
)
{
this
.
originalShown
=
false
;
this
.
qualityEstimationShown
=
true
;
this
.
_swapDocumentContent
(
"
qeAnnotatedTranslation
"
)
;
}
_swapDocumentContent
(
target
)
{
(
(
)
=
>
__awaiter
(
this
void
0
void
0
function
*
(
)
{
this
.
translationRoots
.
filter
(
translationRoot
=
>
translationRoot
.
currentDisplayMode
!
=
=
target
)
.
forEach
(
translationRoot
=
>
translationRoot
.
swapText
(
target
this
.
paintProcessedNodes
)
)
;
}
)
)
(
)
;
}
determineVisibilityOfTranslationRoots
(
)
{
return
__awaiter
(
this
void
0
void
0
function
*
(
)
{
const
{
translationRoots
}
=
this
;
if
(
translationRoots
.
length
=
=
=
0
)
{
return
{
translationRoots
:
[
]
translationRootsVisible
:
[
]
translationRootsVisibleInViewport
:
[
]
}
;
}
const
elements
=
translationRoots
.
map
(
translationRoot
=
>
translationRoot
.
nodeRef
)
;
const
elementsVisibleInViewport
=
yield
getElementsVisibleInViewport
(
elements
)
;
const
translationRootsVisible
=
[
]
;
const
translationRootsVisibleInViewport
=
[
]
;
for
(
let
i
=
0
;
i
<
translationRoots
.
length
;
i
+
+
)
{
const
translationRoot
=
translationRoots
[
i
]
;
const
visible
=
isElementVisible
(
translationRoot
.
nodeRef
)
;
if
(
visible
)
{
translationRootsVisible
.
push
(
translationRoot
)
;
}
const
visibleInViewport
=
isElementVisibleInViewport
(
elementsVisibleInViewport
translationRoot
.
nodeRef
)
;
if
(
visibleInViewport
)
{
translationRootsVisibleInViewport
.
push
(
translationRoot
)
;
}
}
if
(
this
.
paintProcessedNodes
)
{
translationRootsVisible
.
forEach
(
translationRoot
=
>
{
translationRoot
.
nodeRef
.
style
.
color
=
"
purple
"
;
}
)
;
translationRootsVisibleInViewport
.
forEach
(
translationRoot
=
>
{
translationRoot
.
nodeRef
.
style
.
color
=
"
maroon
"
;
}
)
;
}
return
{
translationRoots
translationRootsVisible
translationRootsVisibleInViewport
}
;
}
)
;
}
}
exports
.
TranslationDocument
=
TranslationDocument
;
function
generateMarkupToTranslateForItem
(
item
content
)
{
const
localName
=
item
.
isTranslationRoot
?
"
div
"
:
"
b
"
;
return
(
"
<
"
+
localName
+
"
id
=
n
"
+
item
.
id
+
"
>
"
+
content
+
"
<
/
"
+
localName
+
"
>
"
)
;
}
exports
.
generateMarkupToTranslateForItem
=
generateMarkupToTranslateForItem
;
function
regenerateMarkupToTranslateFromOriginal
(
item
)
{
if
(
item
.
isSimleTranslationRoot
)
{
return
item
.
original
[
0
]
;
}
let
str
=
"
"
;
for
(
const
child
of
item
.
original
)
{
if
(
child
instanceof
TranslationItem_1
.
TranslationItem
)
{
str
+
=
regenerateMarkupToTranslateFromOriginal
(
child
)
;
}
else
if
(
child
instanceof
TranslationItem_1
.
TranslationItem_NodePlaceholder
)
{
str
+
=
"
<
br
>
"
;
}
else
{
str
+
=
child
;
}
}
return
generateMarkupToTranslateForItem
(
item
str
)
;
}
const
isElementVisible
=
(
el
)
=
>
{
const
rect
=
el
.
getBoundingClientRect
(
)
;
return
rect
.
width
>
0
&
&
rect
.
height
>
0
;
}
;
const
isElementVisibleInViewport
=
(
elementsVisibleInViewport
el
)
=
>
{
return
!
!
elementsVisibleInViewport
.
filter
(
el
=
>
el
=
=
=
el
)
.
length
;
}
;
const
getElementsVisibleInViewport
=
(
elements
)
=
>
__awaiter
(
void
0
void
0
void
0
function
*
(
)
{
return
new
Promise
(
resolve
=
>
{
const
options
=
{
threshold
:
0
.
0
}
;
const
callback
=
(
entries
observer
)
=
>
{
const
elementsInViewport
=
entries
.
filter
(
entry
=
>
entry
.
isIntersecting
)
.
map
(
entry
=
>
entry
.
target
)
;
observer
.
disconnect
(
)
;
resolve
(
elementsInViewport
)
;
}
;
const
observer
=
new
IntersectionObserver
(
callback
options
)
;
elements
.
forEach
(
el
=
>
observer
.
observe
(
el
)
)
;
}
)
;
}
)
;
}
)
664
:
(
(
__unused_webpack_module
exports
)
=
>
{
Object
.
defineProperty
(
exports
"
__esModule
"
(
{
value
:
true
}
)
)
;
exports
.
TranslationItem_NodePlaceholder
=
exports
.
TranslationItem
=
void
0
;
class
TranslationItem
{
constructor
(
node
id
isTranslationRoot
)
{
this
.
isTranslationRoot
=
false
;
this
.
isSimleTranslationRoot
=
false
;
this
.
children
=
[
]
;
this
.
nodeRef
=
node
;
this
.
id
=
id
;
this
.
isTranslationRoot
=
isTranslationRoot
;
}
toString
(
)
{
let
rootType
=
"
"
;
if
(
this
.
isTranslationRoot
)
{
if
(
this
.
isSimleTranslationRoot
)
{
rootType
=
"
(
simple
root
)
"
;
}
else
{
rootType
=
"
(
non
simple
root
)
"
;
}
}
return
(
"
[
object
TranslationItem
:
<
"
+
this
.
nodeRef
.
toString
(
)
+
"
>
"
+
rootType
+
"
]
"
)
;
}
parseTranslationResult
(
translatedMarkup
)
{
this
.
translatedMarkup
=
translatedMarkup
;
if
(
this
.
isSimleTranslationRoot
)
{
if
(
this
.
isSimleTranslationRoot
&
&
translatedMarkup
.
match
(
/
&
(
[
a
-
z0
-
9
]
+
|
#
[
0
-
9
]
{
1
6
}
|
#
x
[
0
-
9a
-
f
]
{
1
6
}
)
;
/
gi
)
)
{
const
doc
=
new
DOMParser
(
)
.
parseFromString
(
translatedMarkup
"
text
/
html
"
)
;
translatedMarkup
=
doc
.
body
.
firstChild
.
nodeValue
;
}
this
.
translation
=
[
translatedMarkup
]
;
return
;
}
const
domParser
=
new
DOMParser
(
)
;
const
doc
=
domParser
.
parseFromString
(
translatedMarkup
"
text
/
html
"
)
;
this
.
translation
=
[
]
;
parseResultNode
(
this
doc
.
body
.
firstChild
"
translation
"
)
;
}
parseQeAnnotatedTranslationResult
(
qeAnnotatedTranslatedMarkup
)
{
const
domParser
=
new
DOMParser
(
)
;
const
doc
=
domParser
.
parseFromString
(
qeAnnotatedTranslatedMarkup
"
text
/
html
"
)
;
this
.
qeAnnotatedTranslation
=
[
]
;
parseResultNode
(
this
doc
.
body
.
firstChild
"
qeAnnotatedTranslation
"
)
;
}
getChildById
(
id
)
{
for
(
const
child
of
this
.
children
)
{
const
childId
=
"
n
"
+
child
.
id
;
if
(
childId
=
=
=
id
)
{
return
child
;
}
}
return
null
;
}
swapText
(
target
paintProcessedNodes
)
{
swapTextForItem
(
this
target
paintProcessedNodes
)
;
}
}
exports
.
TranslationItem
=
TranslationItem
;
class
TranslationItem_NodePlaceholder
{
static
toString
(
)
{
return
"
[
object
TranslationItem_NodePlaceholder
]
"
;
}
}
exports
.
TranslationItem_NodePlaceholder
=
TranslationItem_NodePlaceholder
;
function
parseResultNode
(
item
node
target
)
{
try
{
const
into
=
item
[
target
]
;
for
(
const
child
of
node
.
childNodes
)
{
if
(
child
.
nodeType
=
=
=
Node
.
TEXT_NODE
)
{
into
.
push
(
child
.
nodeValue
)
;
}
else
if
(
child
.
localName
=
=
=
"
br
"
)
{
into
.
push
(
new
TranslationItem_NodePlaceholder
(
)
)
;
}
else
if
(
child
.
dataset
&
&
typeof
child
.
dataset
.
translationQeScore
!
=
=
"
undefined
"
)
{
into
.
push
(
child
)
;
}
else
{
const
translationRootChild
=
item
.
getChildById
(
child
.
id
)
;
if
(
translationRootChild
)
{
into
.
push
(
translationRootChild
)
;
translationRootChild
[
target
]
=
[
]
;
parseResultNode
(
translationRootChild
child
target
)
;
}
else
{
console
.
warn
(
Result
node
'
s
(
belonging
to
translation
item
with
id
{
item
.
id
}
)
child
node
(
child
.
id
:
{
child
.
id
}
)
lacks
an
associated
translation
root
child
{
item
node
child
}
)
;
}
}
}
}
catch
(
err
)
{
console
.
error
(
err
)
;
throw
err
;
}
}
function
swapTextForItem
(
item
target
paintProcessedNodes
)
{
const
visitStack
=
[
item
]
;
if
(
paintProcessedNodes
)
{
item
.
nodeRef
.
style
.
border
=
"
1px
solid
maroon
"
;
}
while
(
visitStack
.
length
)
{
const
curItem
=
visitStack
.
shift
(
)
;
if
(
paintProcessedNodes
)
{
item
.
nodeRef
.
style
.
border
=
"
1px
solid
yellow
"
;
}
const
domNode
=
curItem
.
nodeRef
;
if
(
!
domNode
)
{
continue
;
}
if
(
!
curItem
[
target
]
)
{
if
(
paintProcessedNodes
)
{
curItem
.
nodeRef
.
style
.
border
=
"
1px
solid
red
"
;
}
continue
;
}
domNode
.
normalize
(
)
;
if
(
paintProcessedNodes
)
{
curItem
.
nodeRef
.
style
.
border
=
"
1px
solid
green
"
;
}
let
curNode
=
domNode
.
firstChild
;
if
(
paintProcessedNodes
&
&
curNode
instanceof
HTMLElement
)
{
curNode
.
style
.
border
=
"
1px
solid
blue
"
;
}
while
(
curNode
&
&
curNode
.
nodeType
=
=
=
Node
.
TEXT_NODE
&
&
curNode
.
nodeValue
.
trim
(
)
=
=
=
"
"
)
{
curNode
=
curNode
.
nextSibling
;
}
for
(
const
targetItem
of
curItem
[
target
]
)
{
if
(
targetItem
instanceof
TranslationItem
)
{
visitStack
.
push
(
targetItem
)
;
const
targetNode
=
targetItem
.
nodeRef
;
if
(
curNode
!
=
=
targetNode
&
&
targetNode
.
parentNode
=
=
=
domNode
)
{
domNode
.
insertBefore
(
targetNode
curNode
)
;
curNode
=
targetNode
;
}
if
(
curNode
)
{
curNode
=
getNextSiblingSkippingEmptyTextNodes
(
curNode
)
;
}
}
else
if
(
targetItem
instanceof
TranslationItem_NodePlaceholder
)
{
while
(
curNode
&
&
(
curNode
.
nodeType
!
=
=
Node
.
TEXT_NODE
|
|
curNode
.
nodeValue
.
trim
(
)
=
=
=
"
"
)
)
{
curNode
=
curNode
.
nextSibling
;
}
}
else
{
while
(
curNode
&
&
curNode
.
nodeType
!
=
=
Node
.
TEXT_NODE
)
{
curNode
=
curNode
.
nextSibling
;
}
if
(
!
curNode
)
{
curNode
=
domNode
.
appendChild
(
domNode
.
ownerDocument
.
createTextNode
(
"
"
)
)
;
}
if
(
target
=
=
=
"
translation
"
)
{
const
preSpace
=
/
^
\
s
/
.
test
(
curNode
.
nodeValue
)
?
"
"
:
"
"
;
const
endSpace
=
/
\
s
/
.
test
(
curNode
.
nodeValue
)
?
"
"
:
"
"
;
curNode
.
nodeValue
=
preSpace
+
targetItem
+
endSpace
;
}
else
{
curNode
.
nodeValue
=
targetItem
;
}
if
(
[
"
original
"
"
translation
"
]
.
includes
(
target
)
)
{
for
(
const
child
of
curNode
.
parentNode
.
childNodes
)
{
if
(
child
.
dataset
&
&
typeof
child
.
dataset
.
translationQeScore
!
=
=
"
undefined
"
)
{
curNode
.
remove
(
)
;
child
.
parentNode
.
replaceChild
(
curNode
child
)
;
}
}
curNode
=
getNextSiblingSkippingEmptyTextNodes
(
curNode
)
;
}
else
if
(
target
=
=
=
"
qeAnnotatedTranslation
"
)
{
const
nextSibling
=
getNextSiblingSkippingEmptyTextNodes
(
curNode
)
;
curNode
.
parentNode
.
replaceChild
(
targetItem
curNode
)
;
curNode
=
nextSibling
;
}
}
}
if
(
curNode
)
{
clearRemainingNonEmptyTextNodesFromElement
(
curNode
)
;
}
domNode
.
normalize
(
)
;
curItem
.
currentDisplayMode
=
target
;
if
(
paintProcessedNodes
)
{
curItem
.
nodeRef
.
style
.
border
=
"
2px
solid
green
"
;
}
}
}
function
getNextSiblingSkippingEmptyTextNodes
(
startSibling
)
{
let
item
=
startSibling
.
nextSibling
;
while
(
item
&
&
item
.
nodeType
=
=
=
Node
.
TEXT_NODE
&
&
item
.
nodeValue
.
trim
(
)
=
=
=
"
"
)
{
item
=
item
.
nextSibling
;
}
return
item
;
}
function
clearRemainingNonEmptyTextNodesFromElement
(
startSibling
)
{
let
item
=
startSibling
;
while
(
item
)
{
if
(
item
.
nodeType
=
=
=
Node
.
TEXT_NODE
&
&
item
.
nodeValue
!
=
=
"
"
)
{
item
.
nodeValue
=
"
"
;
}
item
=
item
.
nextSibling
;
}
}
}
)
1896
:
(
function
(
__unused_webpack_module
exports
__webpack_require__
)
{
var
__awaiter
=
(
this
&
&
this
.
__awaiter
)
|
|
function
(
thisArg
_arguments
P
generator
)
{
function
adopt
(
value
)
{
return
value
instanceof
P
?
value
:
new
P
(
function
(
resolve
)
{
resolve
(
value
)
;
}
)
;
}
return
new
(
P
|
|
(
P
=
Promise
)
)
(
function
(
resolve
reject
)
{
function
fulfilled
(
value
)
{
try
{
step
(
generator
.
next
(
value
)
)
;
}
catch
(
e
)
{
reject
(
e
)
;
}
}
function
rejected
(
value
)
{
try
{
step
(
generator
[
"
throw
"
]
(
value
)
)
;
}
catch
(
e
)
{
reject
(
e
)
;
}
}
function
step
(
result
)
{
result
.
done
?
resolve
(
result
.
value
)
:
adopt
(
result
.
value
)
.
then
(
fulfilled
rejected
)
;
}
step
(
(
generator
=
generator
.
apply
(
thisArg
_arguments
|
|
[
]
)
)
.
next
(
)
)
;
}
)
;
}
;
Object
.
defineProperty
(
exports
"
__esModule
"
(
{
value
:
true
}
)
)
;
exports
.
BaseDomTranslator
=
exports
.
DomTranslatorError
=
void
0
;
const
MinimalDomTranslator_1
=
__webpack_require__
(
3301
)
;
const
detagAndProject_1
=
__webpack_require__
(
3770
)
;
class
DomTranslatorError
extends
Error
{
constructor
(
)
{
super
(
.
.
.
arguments
)
;
this
.
name
=
"
DomTranslatorError
"
;
}
}
exports
.
DomTranslatorError
=
DomTranslatorError
;
class
BaseDomTranslator
extends
MinimalDomTranslator_1
.
MinimalDomTranslator
{
constructor
(
translationDocument
sourceLanguage
targetLanguage
translationApiClient
parseChunkResult
translationApiLimits
domTranslatorRequestFactory
)
{
super
(
translationDocument
sourceLanguage
targetLanguage
)
;
this
.
translatedCharacterCount
=
0
;
this
.
errorsEncountered
=
[
]
;
this
.
partialSuccess
=
false
;
this
.
translationApiClient
=
translationApiClient
;
this
.
parseChunkResult
=
parseChunkResult
;
this
.
translationApiLimits
=
translationApiLimits
;
this
.
domTranslatorRequestFactory
=
domTranslatorRequestFactory
;
}
translate
(
frameTranslationProgressCallback
)
{
return
__awaiter
(
this
void
0
void
0
function
*
(
)
{
const
chunksBeingProcessed
=
[
]
;
const
{
MAX_REQUESTS
}
=
this
.
translationApiLimits
;
const
startDeriveDocumentTranslationData
=
performance
.
now
(
)
;
this
.
derivedTranslationDocumentData
=
yield
this
.
deriveDocumentTranslationData
(
)
;
console
.
log
(
{
derivedTranslationDocumentData
:
this
.
derivedTranslationDocumentData
}
)
;
const
endDeriveDocumentTranslationData
=
performance
.
now
(
)
;
console
.
info
(
Deriving
document
translation
data
took
{
(
endDeriveDocumentTranslationData
-
startDeriveDocumentTranslationData
)
/
1000
}
seconds
)
;
const
{
translationRoots
translationRootsVisible
translationRootsVisibleInViewport
}
=
this
.
derivedTranslationDocumentData
;
this
.
translationRootsPickedUpForTranslation
=
[
]
;
const
progressOfIndividualTranslationRequests
=
new
Map
(
)
;
for
(
let
currentRequestOrdinal
=
0
;
currentRequestOrdinal
<
MAX_REQUESTS
;
currentRequestOrdinal
+
+
)
{
const
domTranslationChunk
=
this
.
generateNextDomTranslationChunk
(
translationRoots
translationRootsVisible
translationRootsVisibleInViewport
)
;
if
(
domTranslationChunk
.
translationRoots
.
length
=
=
=
0
)
{
break
;
}
const
translationRequestData
=
domTranslationChunk
.
translationRequestData
;
const
domTranslatorRequest
=
this
.
domTranslatorRequestFactory
(
translationRequestData
this
.
sourceLanguage
this
.
targetLanguage
)
;
const
chunkBeingProcessed
=
domTranslatorRequest
.
fireRequest
(
this
.
translationApiClient
(
translationRequestProgress
)
=
>
{
progressOfIndividualTranslationRequests
.
set
(
translationRequestProgress
.
requestId
translationRequestProgress
)
;
frameTranslationProgressCallback
(
{
progressOfIndividualTranslationRequests
}
)
;
}
)
;
chunksBeingProcessed
.
push
(
chunkBeingProcessed
)
;
chunkBeingProcessed
.
then
(
(
translationResponseData
)
=
>
{
if
(
translationResponseData
)
{
this
.
chunkCompleted
(
translationResponseData
domTranslationChunk
domTranslatorRequest
)
;
}
else
{
throw
new
Error
(
"
The
returned
translationResponseData
was
false
/
empty
"
)
;
}
}
)
.
catch
(
err
=
>
{
this
.
errorsEncountered
.
push
(
err
)
;
}
)
;
console
.
info
(
Fired
off
request
with
{
domTranslationChunk
.
translationRoots
.
length
}
translation
roots
to
the
translation
backend
{
domTranslationChunk
}
)
;
if
(
domTranslationChunk
.
isLastChunk
)
{
break
;
}
if
(
!
domTranslationChunk
.
isLastChunk
&
&
currentRequestOrdinal
=
=
=
MAX_REQUESTS
-
1
)
{
console
.
warn
(
We
have
reached
the
MAX_REQUESTS
limit
of
{
MAX_REQUESTS
}
requests
.
Remaining
parts
of
the
page
will
be
left
untranslated
)
;
}
}
if
(
chunksBeingProcessed
.
length
=
=
=
0
)
{
console
.
info
(
"
Found
nothing
to
translate
"
)
;
return
{
characterCount
:
0
}
;
}
console
.
info
(
Fired
off
{
chunksBeingProcessed
.
length
}
requests
to
the
translation
backend
)
;
yield
Promise
.
allSettled
(
chunksBeingProcessed
)
;
if
(
this
.
errorsEncountered
.
length
)
{
console
.
warn
(
"
Errors
were
encountered
during
translation
"
this
.
errorsEncountered
)
;
}
if
(
!
this
.
partialSuccess
)
{
throw
new
DomTranslatorError
(
"
No
content
was
translated
"
)
;
}
return
{
characterCount
:
this
.
translatedCharacterCount
}
;
}
)
;
}
deriveDocumentTranslationData
(
)
{
return
__awaiter
(
this
void
0
void
0
function
*
(
)
{
const
{
translationRoots
translationRootsVisible
translationRootsVisibleInViewport
}
=
yield
this
.
translationDocument
.
determineVisibilityOfTranslationRoots
(
)
;
const
generateOriginalMarkupToTranslate
=
translationRoot
=
>
this
.
translationDocument
.
generateMarkupToTranslate
(
translationRoot
)
;
const
removeTags
=
originalString
=
>
{
const
detaggedString
=
detagAndProject_1
.
detag
(
originalString
)
;
return
detaggedString
.
plainString
;
}
;
const
texts
=
translationRoots
.
map
(
generateOriginalMarkupToTranslate
)
.
map
(
removeTags
)
;
const
textsVisible
=
translationRootsVisible
.
map
(
generateOriginalMarkupToTranslate
)
.
map
(
removeTags
)
;
const
textsVisibleInViewport
=
translationRootsVisibleInViewport
.
map
(
generateOriginalMarkupToTranslate
)
.
map
(
removeTags
)
;
const
wordCount
=
texts
.
join
(
"
"
)
.
split
(
"
"
)
.
length
;
const
wordCountVisible
=
textsVisible
.
join
(
"
"
)
.
split
(
"
"
)
.
length
;
const
wordCountVisibleInViewport
=
textsVisibleInViewport
.
join
(
"
"
)
.
split
(
"
"
)
.
length
;
const
translationRootsCount
=
translationRoots
.
length
;
const
simpleTranslationRootsCount
=
translationRoots
.
filter
(
translationRoot
=
>
translationRoot
.
isSimleTranslationRoot
)
.
length
;
return
{
translationRoots
translationRootsVisible
translationRootsVisibleInViewport
translationRootsCount
simpleTranslationRootsCount
texts
textsVisible
textsVisibleInViewport
wordCount
wordCountVisible
wordCountVisibleInViewport
}
;
}
)
;
}
chunkCompleted
(
translationResponseData
domTranslationChunk
domTranslatorRequest
)
{
if
(
this
.
parseChunkResult
(
translationResponseData
domTranslationChunk
)
)
{
this
.
partialSuccess
=
true
;
this
.
translatedCharacterCount
+
=
domTranslatorRequest
.
characterCount
;
console
.
info
(
"
Part
of
the
web
page
document
translated
.
Showing
translations
that
have
completed
so
far
.
.
.
"
)
;
this
.
translationDocument
.
showTranslation
(
)
;
}
}
generateNextDomTranslationChunk
(
translationRoots
translationRootsVisible
translationRootsVisibleInViewport
)
{
let
currentDataSize
=
0
;
let
currentChunks
=
0
;
const
translationRequestData
=
{
markupsToTranslate
:
[
]
}
;
const
chunkTranslationRoots
=
[
]
;
const
{
MAX_REQUEST_DATA
MAX_REQUEST_TEXTS
}
=
this
.
translationApiLimits
;
let
translationRootsToConsider
;
const
notYetPickedUp
=
(
translationRoots
)
=
>
translationRoots
.
filter
(
value
=
>
!
this
.
translationRootsPickedUpForTranslation
.
includes
(
value
)
)
;
translationRootsToConsider
=
notYetPickedUp
(
translationRootsVisibleInViewport
)
;
if
(
translationRootsToConsider
.
length
=
=
=
0
)
{
translationRootsToConsider
=
notYetPickedUp
(
translationRootsVisible
)
;
}
if
(
translationRootsToConsider
.
length
=
=
=
0
)
{
translationRootsToConsider
=
notYetPickedUp
(
translationRoots
)
;
}
for
(
let
i
=
0
;
i
<
translationRootsToConsider
.
length
;
i
+
+
)
{
const
translationRoot
=
translationRootsToConsider
[
i
]
;
const
markupToTranslate
=
this
.
translationDocument
.
generateMarkupToTranslate
(
translationRoot
)
;
const
newCurSize
=
currentDataSize
+
markupToTranslate
.
length
;
const
newChunks
=
currentChunks
+
1
;
if
(
newCurSize
>
MAX_REQUEST_DATA
|
|
newChunks
>
MAX_REQUEST_TEXTS
)
{
console
.
info
(
"
We
have
reached
the
specified
translation
API
limits
and
will
process
remaining
translation
roots
in
a
separate
request
"
{
newCurSize
newChunks
translationApiLimits
:
this
.
translationApiLimits
}
)
;
return
{
translationRequestData
translationRoots
:
chunkTranslationRoots
isLastChunk
:
false
}
;
}
currentDataSize
=
newCurSize
;
currentChunks
=
newChunks
;
chunkTranslationRoots
.
push
(
translationRoot
)
;
this
.
translationRootsPickedUpForTranslation
.
push
(
translationRoot
)
;
translationRequestData
.
markupsToTranslate
.
push
(
markupToTranslate
)
;
}
const
remainingTranslationRoots
=
notYetPickedUp
(
translationRoots
)
;
const
isLastChunk
=
remainingTranslationRoots
.
length
=
=
=
0
;
return
{
translationRequestData
translationRoots
:
chunkTranslationRoots
isLastChunk
}
;
}
}
exports
.
BaseDomTranslator
=
BaseDomTranslator
;
}
)
7668
:
(
(
__unused_webpack_module
exports
__webpack_require__
)
=
>
{
Object
.
defineProperty
(
exports
"
__esModule
"
(
{
value
:
true
}
)
)
;
exports
.
BergamotDomTranslator
=
exports
.
MAX_REQUESTS
=
exports
.
MAX_REQUEST_TEXTS
=
exports
.
MAX_REQUEST_DATA
=
void
0
;
const
ContentScriptBergamotApiClient_1
=
__webpack_require__
(
5971
)
;
const
TranslationDocument_1
=
__webpack_require__
(
3451
)
;
const
BaseDomTranslator_1
=
__webpack_require__
(
1896
)
;
const
BergamotDomTranslatorRequest_1
=
__webpack_require__
(
3535
)
;
exports
.
MAX_REQUEST_DATA
=
10
*
500
;
exports
.
MAX_REQUEST_TEXTS
=
5000
;
exports
.
MAX_REQUESTS
=
1000
;
class
BergamotDomTranslator
extends
BaseDomTranslator_1
.
BaseDomTranslator
{
constructor
(
translationDocument
sourceLanguage
targetLanguage
)
{
super
(
translationDocument
sourceLanguage
targetLanguage
new
ContentScriptBergamotApiClient_1
.
ContentScriptBergamotApiClient
(
)
parseChunkResult
{
MAX_REQUEST_DATA
:
exports
.
MAX_REQUEST_DATA
MAX_REQUEST_TEXTS
:
exports
.
MAX_REQUEST_TEXTS
MAX_REQUESTS
:
exports
.
MAX_REQUESTS
}
(
translationRequestData
sourceLanguage
targetLanguage
)
=
>
new
BergamotDomTranslatorRequest_1
.
BergamotDomTranslatorRequest
(
translationRequestData
sourceLanguage
targetLanguage
)
)
;
}
}
exports
.
BergamotDomTranslator
=
BergamotDomTranslator
;
function
parseChunkResult
(
translationResponseData
domTranslationChunk
)
{
const
len
=
translationResponseData
.
translatedMarkups
.
length
;
if
(
len
=
=
=
0
)
{
throw
new
Error
(
"
Translation
response
data
has
no
translated
strings
"
)
;
}
if
(
len
!
=
=
domTranslationChunk
.
translationRoots
.
length
)
{
throw
new
Error
(
"
Translation
response
data
has
a
different
number
of
items
(
from
the
number
of
items
submitted
)
"
)
;
}
console
.
info
(
Parsing
translation
chunk
result
with
{
len
}
translation
entries
)
;
let
errorOccurred
=
false
;
domTranslationChunk
.
translationRoots
.
forEach
(
(
translationRoot
index
)
=
>
{
try
{
const
translatedMarkup
=
translationResponseData
.
translatedMarkups
[
index
]
;
translationRoot
.
parseTranslationResult
(
translatedMarkup
)
;
if
(
translationResponseData
.
qeAnnotatedTranslatedMarkups
)
{
let
qeAnnotatedTranslatedMarkup
=
translationResponseData
.
qeAnnotatedTranslatedMarkups
[
index
]
;
qeAnnotatedTranslatedMarkup
=
TranslationDocument_1
.
generateMarkupToTranslateForItem
(
translationRoot
qeAnnotatedTranslatedMarkup
)
;
translationRoot
.
parseQeAnnotatedTranslationResult
(
qeAnnotatedTranslatedMarkup
)
;
}
}
catch
(
e
)
{
errorOccurred
=
true
;
console
.
error
(
"
Translation
error
:
"
e
)
;
}
}
)
;
console
.
info
(
Parsed
translation
chunk
result
with
{
len
}
translation
entries
{
errorOccurred
}
)
;
return
!
errorOccurred
;
}
}
)
3535
:
(
function
(
__unused_webpack_module
exports
__webpack_require__
)
{
var
__awaiter
=
(
this
&
&
this
.
__awaiter
)
|
|
function
(
thisArg
_arguments
P
generator
)
{
function
adopt
(
value
)
{
return
value
instanceof
P
?
value
:
new
P
(
function
(
resolve
)
{
resolve
(
value
)
;
}
)
;
}
return
new
(
P
|
|
(
P
=
Promise
)
)
(
function
(
resolve
reject
)
{
function
fulfilled
(
value
)
{
try
{
step
(
generator
.
next
(
value
)
)
;
}
catch
(
e
)
{
reject
(
e
)
;
}
}
function
rejected
(
value
)
{
try
{
step
(
generator
[
"
throw
"
]
(
value
)
)
;
}
catch
(
e
)
{
reject
(
e
)
;
}
}
function
step
(
result
)
{
result
.
done
?
resolve
(
result
.
value
)
:
adopt
(
result
.
value
)
.
then
(
fulfilled
rejected
)
;
}
step
(
(
generator
=
generator
.
apply
(
thisArg
_arguments
|
|
[
]
)
)
.
next
(
)
)
;
}
)
;
}
;
Object
.
defineProperty
(
exports
"
__esModule
"
(
{
value
:
true
}
)
)
;
exports
.
BergamotDomTranslatorRequest
=
void
0
;
const
detagAndProject_1
=
__webpack_require__
(
3770
)
;
class
BergamotDomTranslatorRequest
{
constructor
(
translationRequestData
sourceLanguage
targetLanguage
)
{
this
.
translationRequestData
=
translationRequestData
;
this
.
sourceLanguage
=
sourceLanguage
;
this
.
targetLanguage
=
targetLanguage
;
this
.
translationRequestData
.
markupsToTranslate
.
forEach
(
text
=
>
{
this
.
characterCount
+
=
text
.
length
;
}
)
;
}
fireRequest
(
bergamotApiClient
translationRequestProgressCallback
)
{
return
__awaiter
(
this
void
0
void
0
function
*
(
)
{
const
detaggedStrings
=
this
.
translationRequestData
.
markupsToTranslate
.
map
(
detagAndProject_1
.
detag
)
;
const
plainStringsToTranslate
=
detaggedStrings
.
map
(
detaggedString
=
>
detaggedString
.
plainString
)
;
const
results
=
yield
bergamotApiClient
.
sendTranslationRequest
(
plainStringsToTranslate
this
.
sourceLanguage
this
.
targetLanguage
translationRequestProgressCallback
)
;
return
Object
.
assign
(
Object
.
assign
(
{
}
this
.
parseResults
(
results
detaggedStrings
)
)
{
plainStringsToTranslate
}
)
;
}
)
;
}
parseResults
(
results
detaggedStrings
)
{
const
len
=
results
.
translatedTexts
.
length
;
if
(
len
!
=
=
this
.
translationRequestData
.
markupsToTranslate
.
length
)
{
throw
new
Error
(
"
Translation
backend
returned
a
different
number
of
results
(
from
the
number
of
strings
to
translate
)
"
)
;
}
const
translatedMarkups
=
[
]
;
const
translatedPlainTextStrings
=
[
]
;
const
qeAnnotatedTranslatedMarkups
=
results
.
qeAnnotatedTranslatedTexts
;
results
.
translatedTexts
.
forEach
(
(
translatedPlainTextString
index
)
=
>
{
const
detaggedString
=
detaggedStrings
[
index
]
;
const
originalEndedWithASinglePeriod
=
/
(
[
^
\
.
]
)
\
.
(
\
s
+
)
?
/
gm
.
exec
(
detaggedString
.
plainString
)
;
const
translationEndsWithTwoPeriods
=
/
(
[
^
\
.
]
)
\
.
\
.
(
\
s
+
)
?
/
gm
.
exec
(
translatedPlainTextString
)
;
if
(
originalEndedWithASinglePeriod
&
&
translationEndsWithTwoPeriods
)
{
translatedPlainTextString
=
translatedPlainTextString
.
replace
(
/
(
[
^
\
.
]
)
\
.
\
.
(
\
s
+
)
?
/
gm
"
1
.
2
"
)
;
}
let
translatedMarkup
;
if
(
[
"
"
"
*
"
"
*
(
)
"
]
.
includes
(
translatedPlainTextString
)
)
{
translatedMarkup
=
this
.
translationRequestData
.
markupsToTranslate
[
index
]
;
}
else
{
translatedMarkup
=
detagAndProject_1
.
project
(
detaggedString
translatedPlainTextString
)
;
}
translatedMarkups
.
push
(
translatedMarkup
)
;
translatedPlainTextStrings
.
push
(
translatedPlainTextString
)
;
}
)
;
return
{
translatedMarkups
translatedPlainTextStrings
qeAnnotatedTranslatedMarkups
}
;
}
}
exports
.
BergamotDomTranslatorRequest
=
BergamotDomTranslatorRequest
;
}
)
3301
:
(
function
(
__unused_webpack_module
exports
)
{
var
__awaiter
=
(
this
&
&
this
.
__awaiter
)
|
|
function
(
thisArg
_arguments
P
generator
)
{
function
adopt
(
value
)
{
return
value
instanceof
P
?
value
:
new
P
(
function
(
resolve
)
{
resolve
(
value
)
;
}
)
;
}
return
new
(
P
|
|
(
P
=
Promise
)
)
(
function
(
resolve
reject
)
{
function
fulfilled
(
value
)
{
try
{
step
(
generator
.
next
(
value
)
)
;
}
catch
(
e
)
{
reject
(
e
)
;
}
}
function
rejected
(
value
)
{
try
{
step
(
generator
[
"
throw
"
]
(
value
)
)
;
}
catch
(
e
)
{
reject
(
e
)
;
}
}
function
step
(
result
)
{
result
.
done
?
resolve
(
result
.
value
)
:
adopt
(
result
.
value
)
.
then
(
fulfilled
rejected
)
;
}
step
(
(
generator
=
generator
.
apply
(
thisArg
_arguments
|
|
[
]
)
)
.
next
(
)
)
;
}
)
;
}
;
Object
.
defineProperty
(
exports
"
__esModule
"
(
{
value
:
true
}
)
)
;
exports
.
MinimalDomTranslator
=
void
0
;
class
MinimalDomTranslator
{
constructor
(
translationDocument
sourceLanguage
targetLanguage
)
{
this
.
translationDocument
=
translationDocument
;
this
.
sourceLanguage
=
sourceLanguage
;
this
.
targetLanguage
=
targetLanguage
;
}
translate
(
_translationProgressCallback
)
{
return
__awaiter
(
this
void
0
void
0
function
*
(
)
{
return
{
characterCount
:
-
1
}
;
}
)
;
}
}
exports
.
MinimalDomTranslator
=
MinimalDomTranslator
;
}
)
3770
:
(
(
__unused_webpack_module
exports
)
=
>
{
Object
.
defineProperty
(
exports
"
__esModule
"
(
{
value
:
true
}
)
)
;
exports
.
project
=
exports
.
detag
=
void
0
;
const
isTagTokenWithImpliedWhitespace
=
(
token
)
=
>
{
return
token
.
type
=
=
=
"
tag
"
&
&
token
.
tagName
=
=
=
"
br
"
;
}
;
const
detag
=
(
originalString
)
=
>
{
const
originalStringDoc
=
new
DOMParser
(
)
.
parseFromString
(
originalString
"
text
/
html
"
)
;
const
tokens
=
serializeNodeIntoTokens
(
originalStringDoc
.
body
)
;
const
plainString
=
tokens
.
map
(
token
=
>
{
if
(
token
.
type
=
=
=
"
tag
"
)
{
return
isTagTokenWithImpliedWhitespace
(
token
)
?
"
"
:
"
"
;
}
return
token
.
textRepresentation
;
}
)
.
join
(
"
"
)
;
return
{
originalString
tokens
plainString
}
;
}
;
exports
.
detag
=
detag
;
function
serializeNodeIntoTokens
(
node
)
{
const
tokens
=
[
]
;
try
{
for
(
const
child
of
node
.
childNodes
)
{
if
(
child
.
nodeType
=
=
=
Node
.
TEXT_NODE
)
{
const
textChunk
=
child
.
nodeValue
.
trim
(
)
;
if
(
textChunk
=
=
=
"
"
)
{
tokens
.
push
(
{
type
:
"
whitespace
"
textRepresentation
:
"
"
}
)
;
continue
;
}
const
leadingSpace
=
/
^
\
s
+
/
.
exec
(
child
.
nodeValue
)
;
const
trailingSpace
=
/
\
s
+
/
.
exec
(
child
.
nodeValue
)
;
if
(
leadingSpace
!
=
=
null
)
{
tokens
.
push
(
{
type
:
"
whitespace
"
textRepresentation
:
leadingSpace
[
0
]
}
)
;
}
const
words
=
textChunk
.
split
(
"
"
)
;
words
.
forEach
(
(
word
wordIndex
)
=
>
{
if
(
word
!
=
=
"
"
)
{
tokens
.
push
(
{
type
:
"
word
"
textRepresentation
:
word
}
)
;
}
if
(
wordIndex
!
=
=
words
.
length
-
1
)
{
tokens
.
push
(
{
type
:
"
whitespace
"
textRepresentation
:
"
"
}
)
;
}
}
)
;
if
(
trailingSpace
!
=
=
null
)
{
tokens
.
push
(
{
type
:
"
whitespace
"
textRepresentation
:
trailingSpace
[
0
]
}
)
;
}
}
else
{
const
startTagMatch
=
/
^
<
[
^
>
]
*
>
/
gm
.
exec
(
child
.
outerHTML
)
;
const
endTagMatch
=
/
<
\
/
[
^
>
]
*
>
/
gm
.
exec
(
child
.
outerHTML
)
;
const
tagName
=
child
.
tagName
.
toLowerCase
(
)
;
tokens
.
push
(
{
type
:
"
tag
"
tagName
textRepresentation
:
startTagMatch
[
0
]
}
)
;
const
childTokens
=
serializeNodeIntoTokens
(
child
)
;
tokens
.
push
(
.
.
.
childTokens
)
;
if
(
endTagMatch
)
{
tokens
.
push
(
{
type
:
"
tag
"
tagName
textRepresentation
:
endTagMatch
[
0
]
}
)
;
}
}
}
}
catch
(
err
)
{
console
.
error
(
err
)
;
throw
err
;
}
return
tokens
;
}
const
project
=
(
detaggedString
translatedString
)
=
>
{
if
(
detaggedString
.
tokens
.
filter
(
token
=
>
token
.
type
=
=
=
"
tag
"
)
.
length
=
=
=
0
)
{
return
translatedString
;
}
const
lastToken
=
detaggedString
.
tokens
.
slice
(
-
1
)
[
0
]
;
if
(
lastToken
.
type
=
=
=
"
tag
"
)
{
detaggedString
.
tokens
.
pop
(
)
;
}
const
translatedStringWords
=
translatedString
.
split
(
"
"
)
;
const
remainingTranslatedStringWords
=
[
.
.
.
translatedStringWords
]
;
let
whitespaceHaveBeenInjectedSinceTheLastWordWasInjected
=
true
;
const
projectedStringParts
=
detaggedString
.
tokens
.
map
(
(
token
)
=
>
{
const
determineProjectedStringPart
=
(
)
=
>
{
if
(
token
.
type
=
=
=
"
word
"
)
{
const
correspondingTranslatedWord
=
remainingTranslatedStringWords
.
shift
(
)
;
if
(
correspondingTranslatedWord
=
=
=
undefined
)
{
return
"
"
;
}
const
projectedStringPart
=
{
whitespaceHaveBeenInjectedSinceTheLastWordWasInjected
?
"
"
:
"
"
}
{
correspondingTranslatedWord
}
;
whitespaceHaveBeenInjectedSinceTheLastWordWasInjected
=
false
;
return
projectedStringPart
;
}
else
if
(
token
.
type
=
=
=
"
whitespace
"
)
{
if
(
remainingTranslatedStringWords
.
length
=
=
=
0
)
{
return
"
"
;
}
whitespaceHaveBeenInjectedSinceTheLastWordWasInjected
=
true
;
return
token
.
textRepresentation
;
}
else
if
(
token
.
type
=
=
=
"
tag
"
)
{
if
(
isTagTokenWithImpliedWhitespace
(
token
)
)
{
whitespaceHaveBeenInjectedSinceTheLastWordWasInjected
=
true
;
}
return
token
.
textRepresentation
;
}
throw
new
Error
(
Unexpected
token
type
:
{
token
.
type
}
)
;
}
;
const
projectedStringPart
=
determineProjectedStringPart
(
)
;
return
projectedStringPart
;
}
)
;
let
projectedString
=
projectedStringParts
.
join
(
"
"
)
;
if
(
remainingTranslatedStringWords
.
length
)
{
if
(
lastToken
.
type
!
=
=
"
whitespace
"
)
{
projectedString
+
=
"
"
;
}
projectedString
+
=
remainingTranslatedStringWords
.
join
(
"
"
)
;
}
if
(
lastToken
.
type
=
=
=
"
tag
"
)
{
projectedString
+
=
lastToken
.
textRepresentation
;
}
return
projectedString
;
}
;
exports
.
project
=
project
;
}
)
2542
:
(
(
__unused_webpack_module
exports
__webpack_require__
)
=
>
{
Object
.
defineProperty
(
exports
"
__esModule
"
(
{
value
:
true
}
)
)
;
exports
.
getTranslationNodes
=
void
0
;
const
hasTextForTranslation_1
=
__webpack_require__
(
895
)
;
const
isBlockFrameOrSubclass
=
(
element
)
=
>
{
const
nodeTagName
=
element
.
tagName
.
toLowerCase
(
)
;
const
blockLevelElementTagNames
=
[
"
address
"
"
article
"
"
aside
"
"
blockquote
"
"
canvas
"
"
dd
"
"
div
"
"
dl
"
"
dt
"
"
fieldset
"
"
figcaption
"
"
figure
"
"
footer
"
"
form
"
"
h1
"
"
h2
"
"
h3
"
"
h4
"
"
h5
"
"
h6
"
"
header
"
"
hr
"
"
li
"
"
main
"
"
nav
"
"
noscript
"
"
ol
"
"
p
"
"
pre
"
"
section
"
"
table
"
"
tfoot
"
"
ul
"
"
video
"
]
;
const
result
=
(
blockLevelElementTagNames
.
includes
(
nodeTagName
)
|
|
element
.
style
.
display
=
=
=
"
block
"
)
&
&
element
.
style
.
display
!
=
=
"
inline
"
;
return
result
;
}
;
const
getTranslationNodes
=
(
rootElement
seenTranslationNodes
=
[
]
limit
=
15000
)
=
>
{
const
translationNodes
=
[
]
;
const
childElements
=
rootElement
.
children
;
for
(
let
i
=
0
;
i
<
limit
&
&
i
<
childElements
.
length
;
i
+
+
)
{
const
childElement
=
childElements
[
i
]
;
const
tagName
=
childElement
.
tagName
.
toLowerCase
(
)
;
const
isTextNode
=
childElement
.
nodeType
=
=
=
Node
.
TEXT_NODE
;
if
(
isTextNode
)
{
console
.
warn
(
We
are
not
supposed
to
run
into
text
nodes
here
.
childElement
.
textContent
:
"
{
childElement
.
textContent
}
"
)
;
continue
;
}
if
(
[
"
script
"
"
iframe
"
"
frameset
"
"
frame
"
"
code
"
"
noscript
"
"
style
"
"
svg
"
"
math
"
]
.
includes
(
tagName
)
)
{
continue
;
}
const
nodeHasTextForTranslation
=
hasTextForTranslation_1
.
hasTextForTranslation
(
childElement
.
textContent
)
;
if
(
!
nodeHasTextForTranslation
)
{
continue
;
}
const
childChildTextNodes
=
Array
.
from
(
childElement
.
childNodes
)
.
filter
(
(
childChildNode
)
=
>
childChildNode
.
nodeType
=
=
=
Node
.
TEXT_NODE
)
;
const
childChildTextNodesWithTextForTranslation
=
childChildTextNodes
.
map
(
textNode
=
>
textNode
.
textContent
)
.
filter
(
hasTextForTranslation_1
.
hasTextForTranslation
)
;
const
isTranslationNode
=
!
!
childChildTextNodesWithTextForTranslation
.
length
;
if
(
isTranslationNode
)
{
let
isTranslationRoot
;
isTranslationRoot
=
isBlockFrameOrSubclass
(
childElement
)
;
seenTranslationNodes
.
push
(
childElement
)
;
if
(
!
isTranslationRoot
)
{
let
ancestorWasATranslationNode
=
false
;
for
(
let
ancestor
=
childElement
.
parentNode
;
ancestor
;
ancestor
=
ancestor
.
parentNode
)
{
if
(
seenTranslationNodes
.
includes
(
ancestor
)
)
{
ancestorWasATranslationNode
=
true
;
break
;
}
}
isTranslationRoot
=
!
ancestorWasATranslationNode
;
}
const
translationNode
=
{
content
:
childElement
isTranslationRoot
}
;
translationNodes
.
push
(
translationNode
)
;
}
if
(
childElement
.
firstElementChild
)
{
const
childTranslationNodes
=
exports
.
getTranslationNodes
(
childElement
seenTranslationNodes
limit
-
translationNodes
.
length
)
;
translationNodes
.
push
(
.
.
.
childTranslationNodes
)
;
}
}
return
translationNodes
;
}
;
exports
.
getTranslationNodes
=
getTranslationNodes
;
}
)
895
:
(
(
__unused_webpack_module
exports
)
=
>
{
Object
.
defineProperty
(
exports
"
__esModule
"
(
{
value
:
true
}
)
)
;
exports
.
hasTextForTranslation
=
void
0
;
const
hasTextForTranslation
=
text
=
>
{
const
trimmed
=
text
.
trim
(
)
;
if
(
trimmed
=
=
=
"
"
)
{
return
false
;
}
return
/
\
p
{
L
}
/
gu
.
test
(
trimmed
)
;
}
;
exports
.
hasTextForTranslation
=
hasTextForTranslation
;
}
)
2380
:
(
function
(
__unused_webpack_module
exports
__webpack_require__
)
{
var
__awaiter
=
(
this
&
&
this
.
__awaiter
)
|
|
function
(
thisArg
_arguments
P
generator
)
{
function
adopt
(
value
)
{
return
value
instanceof
P
?
value
:
new
P
(
function
(
resolve
)
{
resolve
(
value
)
;
}
)
;
}
return
new
(
P
|
|
(
P
=
Promise
)
)
(
function
(
resolve
reject
)
{
function
fulfilled
(
value
)
{
try
{
step
(
generator
.
next
(
value
)
)
;
}
catch
(
e
)
{
reject
(
e
)
;
}
}
function
rejected
(
value
)
{
try
{
step
(
generator
[
"
throw
"
]
(
value
)
)
;
}
catch
(
e
)
{
reject
(
e
)
;
}
}
function
step
(
result
)
{
result
.
done
?
resolve
(
result
.
value
)
:
adopt
(
result
.
value
)
.
then
(
fulfilled
rejected
)
;
}
step
(
(
generator
=
generator
.
apply
(
thisArg
_arguments
|
|
[
]
)
)
.
next
(
)
)
;
}
)
;
}
;
Object
.
defineProperty
(
exports
"
__esModule
"
(
{
value
:
true
}
)
)
;
const
mobx_keystone_1
=
__webpack_require__
(
4380
)
;
const
DomTranslationManager_1
=
__webpack_require__
(
3550
)
;
const
subscribeToExtensionState_1
=
__webpack_require__
(
1429
)
;
const
DocumentTranslationStateCommunicator_1
=
__webpack_require__
(
7994
)
;
const
ContentScriptFrameInfo_1
=
__webpack_require__
(
6528
)
;
const
ExtensionState_1
=
__webpack_require__
(
7516
)
;
const
BaseTranslationState_1
=
__webpack_require__
(
9359
)
;
const
TranslateOwnTextTranslationState_1
=
__webpack_require__
(
6745
)
;
const
DocumentTranslationState_1
=
__webpack_require__
(
1120
)
;
new
ExtensionState_1
.
ExtensionState
(
{
}
)
;
new
TranslateOwnTextTranslationState_1
.
TranslateOwnTextTranslationState
(
{
}
)
;
const
init
=
(
)
=
>
__awaiter
(
void
0
void
0
void
0
function
*
(
)
{
const
contentScriptFrameInfo
=
new
ContentScriptFrameInfo_1
.
ContentScriptFrameInfo
(
)
;
const
frameInfo
=
yield
contentScriptFrameInfo
.
getCurrentFrameInfo
(
)
;
const
tabFrameReference
=
{
frameInfo
.
tabId
}
-
{
frameInfo
.
frameId
}
;
const
extensionState
=
yield
subscribeToExtensionState_1
.
subscribeToExtensionState
(
)
;
const
documentTranslationStateCommunicator
=
new
DocumentTranslationStateCommunicator_1
.
DocumentTranslationStateCommunicator
(
frameInfo
extensionState
)
;
const
domTranslationManager
=
new
DomTranslationManager_1
.
DomTranslationManager
(
documentTranslationStateCommunicator
document
window
)
;
mobx_keystone_1
.
onSnapshot
(
extensionState
.
.
documentTranslationStates
(
documentTranslationStates
previousDocumentTranslationStates
)
=
>
__awaiter
(
void
0
void
0
void
0
function
*
(
)
{
var
_a
_b
;
const
currentTabFrameDocumentTranslationState
=
documentTranslationStates
[
tabFrameReference
]
;
const
previousTabFrameDocumentTranslationState
=
previousDocumentTranslationStates
[
tabFrameReference
]
;
if
(
!
currentTabFrameDocumentTranslationState
)
{
return
;
}
const
hasChanged
=
property
=
>
{
return
(
!
previousTabFrameDocumentTranslationState
|
|
currentTabFrameDocumentTranslationState
[
property
]
!
=
=
previousTabFrameDocumentTranslationState
[
property
]
)
;
}
;
if
(
hasChanged
(
"
translationRequested
"
)
)
{
if
(
currentTabFrameDocumentTranslationState
.
translationRequested
)
{
const
translationPromise
=
domTranslationManager
.
doTranslation
(
currentTabFrameDocumentTranslationState
.
translateFrom
currentTabFrameDocumentTranslationState
.
translateTo
)
;
extensionState
.
patchDocumentTranslationStateByFrameInfo
(
frameInfo
[
{
op
:
"
replace
"
path
:
[
"
translationRequested
"
]
value
:
false
}
]
)
;
yield
translationPromise
;
}
}
if
(
hasChanged
(
"
translationStatus
"
)
)
{
if
(
currentTabFrameDocumentTranslationState
.
translationStatus
=
=
=
BaseTranslationState_1
.
TranslationStatus
.
UNKNOWN
&
&
frameInfo
.
frameId
=
=
=
0
)
{
yield
domTranslationManager
.
attemptToDetectLanguage
(
)
;
}
if
(
currentTabFrameDocumentTranslationState
.
translationStatus
=
=
=
BaseTranslationState_1
.
TranslationStatus
.
TRANSLATING
)
{
if
(
currentTabFrameDocumentTranslationState
.
cancellationRequested
)
{
console
.
debug
(
"
Cancellation
requested
"
)
;
console
.
debug
(
"
TODO
:
Implement
"
)
;
}
}
}
if
(
(
_a
=
domTranslationManager
=
=
=
null
|
|
domTranslationManager
=
=
=
void
0
?
void
0
:
domTranslationManager
.
contentWindow
)
=
=
=
null
|
|
_a
=
=
=
void
0
?
void
0
:
_a
.
translationDocument
)
{
const
translationDocument
=
(
_b
=
domTranslationManager
=
=
=
null
|
|
domTranslationManager
=
=
=
void
0
?
void
0
:
domTranslationManager
.
contentWindow
)
=
=
=
null
|
|
_b
=
=
=
void
0
?
void
0
:
_b
.
translationDocument
;
if
(
hasChanged
(
"
showOriginal
"
)
)
{
if
(
currentTabFrameDocumentTranslationState
.
showOriginal
!
=
=
translationDocument
.
originalShown
)
{
if
(
translationDocument
.
originalShown
)
{
translationDocument
.
showTranslation
(
)
;
}
else
{
translationDocument
.
showOriginal
(
)
;
}
}
}
if
(
hasChanged
(
"
displayQualityEstimation
"
)
)
{
if
(
currentTabFrameDocumentTranslationState
.
displayQualityEstimation
!
=
=
translationDocument
.
qualityEstimationShown
)
{
if
(
translationDocument
.
qualityEstimationShown
)
{
translationDocument
.
showTranslation
(
)
;
}
else
{
translationDocument
.
showQualityEstimation
(
)
;
}
}
}
}
}
)
)
;
try
{
extensionState
.
setDocumentTranslationState
(
new
DocumentTranslationState_1
.
DocumentTranslationState
(
Object
.
assign
(
Object
.
assign
(
{
}
frameInfo
)
{
translationStatus
:
BaseTranslationState_1
.
TranslationStatus
.
UNKNOWN
url
:
window
.
location
.
href
}
)
)
)
;
const
onBeforeunloadEventListener
=
function
(
e
)
{
extensionState
.
deleteDocumentTranslationStateByFrameInfo
(
frameInfo
)
;
delete
e
.
returnValue
;
window
.
removeEventListener
(
"
beforeunload
"
onBeforeunloadEventListener
)
;
}
;
window
.
addEventListener
(
"
beforeunload
"
onBeforeunloadEventListener
)
;
}
catch
(
err
)
{
console
.
error
(
"
Instantiate
DocumentTranslationState
error
"
err
)
;
}
}
)
;
init
(
)
;
}
)
5971
:
(
function
(
__unused_webpack_module
exports
__webpack_require__
)
{
var
__awaiter
=
(
this
&
&
this
.
__awaiter
)
|
|
function
(
thisArg
_arguments
P
generator
)
{
function
adopt
(
value
)
{
return
value
instanceof
P
?
value
:
new
P
(
function
(
resolve
)
{
resolve
(
value
)
;
}
)
;
}
return
new
(
P
|
|
(
P
=
Promise
)
)
(
function
(
resolve
reject
)
{
function
fulfilled
(
value
)
{
try
{
step
(
generator
.
next
(
value
)
)
;
}
catch
(
e
)
{
reject
(
e
)
;
}
}
function
rejected
(
value
)
{
try
{
step
(
generator
[
"
throw
"
]
(
value
)
)
;
}
catch
(
e
)
{
reject
(
e
)
;
}
}
function
step
(
result
)
{
result
.
done
?
resolve
(
result
.
value
)
:
adopt
(
result
.
value
)
.
then
(
fulfilled
rejected
)
;
}
step
(
(
generator
=
generator
.
apply
(
thisArg
_arguments
|
|
[
]
)
)
.
next
(
)
)
;
}
)
;
}
;
Object
.
defineProperty
(
exports
"
__esModule
"
(
{
value
:
true
}
)
)
;
exports
.
ContentScriptBergamotApiClient
=
void
0
;
const
webextension_polyfill_ts_1
=
__webpack_require__
(
5006
)
;
const
nanoid_1
=
__webpack_require__
(
3608
)
;
const
ErrorReporting_1
=
__webpack_require__
(
9009
)
;
class
ContentScriptBergamotApiClient
{
constructor
(
)
{
this
.
backgroundContextPort
=
webextension_polyfill_ts_1
.
browser
.
runtime
.
connect
(
webextension_polyfill_ts_1
.
browser
.
runtime
.
id
{
name
:
"
port
-
from
-
content
-
script
-
bergamot
-
api
-
client
"
}
)
;
}
sendTranslationRequest
(
texts
from
to
translationRequestProgressCallback
)
{
return
__awaiter
(
this
void
0
void
0
function
*
(
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
const
requestId
=
nanoid_1
.
nanoid
(
)
;
const
resultsMessageListener
=
(
m
)
=
>
__awaiter
(
this
void
0
void
0
function
*
(
)
{
if
(
m
.
translationRequestUpdate
)
{
const
{
translationRequestUpdate
}
=
m
;
if
(
translationRequestUpdate
.
requestId
!
=
=
requestId
)
{
return
;
}
const
{
results
translationRequestProgress
error
}
=
translationRequestUpdate
;
if
(
translationRequestProgress
)
{
translationRequestProgressCallback
(
translationRequestProgress
)
;
return
;
}
if
(
results
)
{
this
.
backgroundContextPort
.
onMessage
.
removeListener
(
resultsMessageListener
)
;
resolve
(
translationRequestUpdate
.
results
)
;
return
;
}
if
(
error
)
{
this
.
backgroundContextPort
.
onMessage
.
removeListener
(
resultsMessageListener
)
;
reject
(
error
)
;
return
;
}
}
ErrorReporting_1
.
captureExceptionWithExtras
(
new
Error
(
"
Unexpected
message
structure
"
)
{
m
}
)
;
console
.
error
(
"
Unexpected
message
structure
"
{
m
}
)
;
reject
(
{
m
}
)
;
}
)
;
this
.
backgroundContextPort
.
onMessage
.
addListener
(
resultsMessageListener
)
;
this
.
backgroundContextPort
.
postMessage
(
{
texts
from
to
requestId
}
)
;
}
)
;
}
)
;
}
}
exports
.
ContentScriptBergamotApiClient
=
ContentScriptBergamotApiClient
;
}
)
6528
:
(
function
(
__unused_webpack_module
exports
__webpack_require__
)
{
var
__awaiter
=
(
this
&
&
this
.
__awaiter
)
|
|
function
(
thisArg
_arguments
P
generator
)
{
function
adopt
(
value
)
{
return
value
instanceof
P
?
value
:
new
P
(
function
(
resolve
)
{
resolve
(
value
)
;
}
)
;
}
return
new
(
P
|
|
(
P
=
Promise
)
)
(
function
(
resolve
reject
)
{
function
fulfilled
(
value
)
{
try
{
step
(
generator
.
next
(
value
)
)
;
}
catch
(
e
)
{
reject
(
e
)
;
}
}
function
rejected
(
value
)
{
try
{
step
(
generator
[
"
throw
"
]
(
value
)
)
;
}
catch
(
e
)
{
reject
(
e
)
;
}
}
function
step
(
result
)
{
result
.
done
?
resolve
(
result
.
value
)
:
adopt
(
result
.
value
)
.
then
(
fulfilled
rejected
)
;
}
step
(
(
generator
=
generator
.
apply
(
thisArg
_arguments
|
|
[
]
)
)
.
next
(
)
)
;
}
)
;
}
;
Object
.
defineProperty
(
exports
"
__esModule
"
(
{
value
:
true
}
)
)
;
exports
.
ContentScriptFrameInfo
=
void
0
;
const
webextension_polyfill_ts_1
=
__webpack_require__
(
5006
)
;
const
ErrorReporting_1
=
__webpack_require__
(
9009
)
;
const
nanoid_1
=
__webpack_require__
(
3608
)
;
class
ContentScriptFrameInfo
{
constructor
(
)
{
this
.
backgroundContextPort
=
webextension_polyfill_ts_1
.
browser
.
runtime
.
connect
(
webextension_polyfill_ts_1
.
browser
.
runtime
.
id
{
name
:
"
port
-
from
-
content
-
script
-
frame
-
info
"
}
)
;
}
getCurrentFrameInfo
(
)
{
return
__awaiter
(
this
void
0
void
0
function
*
(
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
const
requestId
=
nanoid_1
.
nanoid
(
)
;
const
resultsMessageListener
=
(
m
)
=
>
__awaiter
(
this
void
0
void
0
function
*
(
)
{
if
(
m
.
frameInfo
)
{
const
{
frameInfo
}
=
m
;
if
(
m
.
requestId
!
=
=
requestId
)
{
return
;
}
this
.
backgroundContextPort
.
onMessage
.
removeListener
(
resultsMessageListener
)
;
resolve
(
frameInfo
)
;
return
;
}
ErrorReporting_1
.
captureExceptionWithExtras
(
new
Error
(
"
Unexpected
message
"
)
{
m
}
)
;
console
.
error
(
"
Unexpected
message
"
{
m
}
)
;
reject
(
{
m
}
)
;
}
)
;
this
.
backgroundContextPort
.
onMessage
.
addListener
(
resultsMessageListener
)
;
this
.
backgroundContextPort
.
postMessage
(
{
requestId
}
)
;
}
)
;
}
)
;
}
}
exports
.
ContentScriptFrameInfo
=
ContentScriptFrameInfo
;
}
)
8341
:
(
function
(
__unused_webpack_module
exports
__webpack_require__
)
{
var
__awaiter
=
(
this
&
&
this
.
__awaiter
)
|
|
function
(
thisArg
_arguments
P
generator
)
{
function
adopt
(
value
)
{
return
value
instanceof
P
?
value
:
new
P
(
function
(
resolve
)
{
resolve
(
value
)
;
}
)
;
}
return
new
(
P
|
|
(
P
=
Promise
)
)
(
function
(
resolve
reject
)
{
function
fulfilled
(
value
)
{
try
{
step
(
generator
.
next
(
value
)
)
;
}
catch
(
e
)
{
reject
(
e
)
;
}
}
function
rejected
(
value
)
{
try
{
step
(
generator
[
"
throw
"
]
(
value
)
)
;
}
catch
(
e
)
{
reject
(
e
)
;
}
}
function
step
(
result
)
{
result
.
done
?
resolve
(
result
.
value
)
:
adopt
(
result
.
value
)
.
then
(
fulfilled
rejected
)
;
}
step
(
(
generator
=
generator
.
apply
(
thisArg
_arguments
|
|
[
]
)
)
.
next
(
)
)
;
}
)
;
}
;
Object
.
defineProperty
(
exports
"
__esModule
"
(
{
value
:
true
}
)
)
;
exports
.
ContentScriptLanguageDetectorProxy
=
void
0
;
const
webextension_polyfill_ts_1
=
__webpack_require__
(
5006
)
;
const
ErrorReporting_1
=
__webpack_require__
(
9009
)
;
const
nanoid_1
=
__webpack_require__
(
3608
)
;
class
ContentScriptLanguageDetectorProxy
{
constructor
(
)
{
this
.
backgroundContextPort
=
webextension_polyfill_ts_1
.
browser
.
runtime
.
connect
(
webextension_polyfill_ts_1
.
browser
.
runtime
.
id
{
name
:
"
port
-
from
-
content
-
script
-
language
-
detector
-
proxy
"
}
)
;
}
detectLanguage
(
str
)
{
return
__awaiter
(
this
void
0
void
0
function
*
(
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
const
requestId
=
nanoid_1
.
nanoid
(
)
;
const
resultsMessageListener
=
(
m
)
=
>
__awaiter
(
this
void
0
void
0
function
*
(
)
{
if
(
m
.
languageDetectorResults
)
{
const
{
languageDetectorResults
}
=
m
;
if
(
languageDetectorResults
.
requestId
!
=
=
requestId
)
{
return
;
}
this
.
backgroundContextPort
.
onMessage
.
removeListener
(
resultsMessageListener
)
;
resolve
(
languageDetectorResults
.
results
)
;
return
;
}
ErrorReporting_1
.
captureExceptionWithExtras
(
new
Error
(
"
Unexpected
message
"
)
{
m
}
)
;
console
.
error
(
"
Unexpected
message
"
{
m
}
)
;
reject
(
{
m
}
)
;
}
)
;
this
.
backgroundContextPort
.
onMessage
.
addListener
(
resultsMessageListener
)
;
this
.
backgroundContextPort
.
postMessage
(
{
str
requestId
}
)
;
}
)
;
}
)
;
}
}
exports
.
ContentScriptLanguageDetectorProxy
=
ContentScriptLanguageDetectorProxy
;
}
)
7994
:
(
(
__unused_webpack_module
exports
__webpack_require__
)
=
>
{
Object
.
defineProperty
(
exports
"
__esModule
"
(
{
value
:
true
}
)
)
;
exports
.
DocumentTranslationStateCommunicator
=
void
0
;
const
BaseTranslationState_1
=
__webpack_require__
(
9359
)
;
class
DocumentTranslationStateCommunicator
{
constructor
(
frameInfo
extensionState
)
{
this
.
frameInfo
=
frameInfo
;
this
.
extensionState
=
extensionState
;
}
patchDocumentTranslationState
(
patches
)
{
setTimeout
(
(
)
=
>
{
this
.
extensionState
.
patchDocumentTranslationStateByFrameInfo
(
this
.
frameInfo
patches
)
;
}
0
)
;
}
broadcastUpdatedAttributeValue
(
attribute
value
)
{
this
.
patchDocumentTranslationState
(
[
{
op
:
"
replace
"
path
:
[
attribute
]
value
}
]
)
;
}
broadcastUpdatedTranslationStatus
(
translationStatus
)
{
this
.
broadcastUpdatedAttributeValue
(
"
translationStatus
"
translationStatus
)
;
}
broadcastTranslationAttemptConcluded
(
translationError
derivedTranslationDocumentData
)
{
const
{
wordCount
wordCountVisible
wordCountVisibleInViewport
}
=
derivedTranslationDocumentData
;
this
.
patchDocumentTranslationState
(
[
{
op
:
"
replace
"
path
:
[
"
translationStatus
"
]
value
:
translationError
?
BaseTranslationState_1
.
TranslationStatus
.
ERROR
:
BaseTranslationState_1
.
TranslationStatus
.
TRANSLATED
}
{
op
:
"
replace
"
path
:
[
"
wordCount
"
]
value
:
wordCount
}
{
op
:
"
replace
"
path
:
[
"
wordCountVisible
"
]
value
:
wordCountVisible
}
{
op
:
"
replace
"
path
:
[
"
wordCountVisibleInViewport
"
]
value
:
wordCountVisibleInViewport
}
]
)
;
}
broadcastUpdatedFrameTranslationProgress
(
frameTranslationProgress
)
{
const
{
progressOfIndividualTranslationRequests
}
=
frameTranslationProgress
;
const
translationRequestProgressEntries
=
Array
.
from
(
progressOfIndividualTranslationRequests
)
.
map
(
(
[
translationRequestProgress
]
)
=
>
translationRequestProgress
)
;
const
translationInitiationTimestamps
=
translationRequestProgressEntries
.
map
(
(
trp
)
=
>
trp
.
initiationTimestamp
)
;
const
translationInitiationTimestamp
=
Math
.
min
(
.
.
.
translationInitiationTimestamps
)
;
const
totalModelLoadWallTimeMs
=
translationRequestProgressEntries
.
map
(
(
trp
)
=
>
trp
.
modelLoadWallTimeMs
|
|
0
)
.
reduce
(
(
a
b
)
=
>
a
+
b
0
)
;
const
totalTranslationWallTimeMs
=
translationRequestProgressEntries
.
map
(
(
trp
)
=
>
trp
.
translationWallTimeMs
|
|
0
)
.
reduce
(
(
a
b
)
=
>
a
+
b
0
)
;
const
totalTranslationEngineRequestCount
=
translationRequestProgressEntries
.
length
;
const
queuedTranslationEngineRequestCount
=
translationRequestProgressEntries
.
filter
(
(
trp
)
=
>
trp
.
queued
)
.
length
;
const
modelLoadNecessary
=
!
!
translationRequestProgressEntries
.
filter
(
(
trp
)
=
>
trp
.
modelLoadNecessary
)
.
length
;
const
modelDownloadNecessary
=
!
!
translationRequestProgressEntries
.
filter
(
(
trp
)
=
>
trp
.
modelDownloadNecessary
)
.
length
;
const
modelDownloading
=
!
!
translationRequestProgressEntries
.
filter
(
(
trp
)
=
>
trp
.
modelDownloading
)
.
length
;
const
modelLoading
=
modelLoadNecessary
?
!
!
translationRequestProgressEntries
.
find
(
(
trp
)
=
>
trp
.
modelLoading
)
:
undefined
;
const
modelLoaded
=
modelLoadNecessary
?
!
!
translationRequestProgressEntries
.
filter
(
(
trp
)
=
>
trp
.
modelLoadNecessary
)
.
find
(
(
trp
)
=
>
trp
.
modelLoaded
)
:
undefined
;
const
translationFinished
=
translationRequestProgressEntries
.
filter
(
(
trp
)
=
>
!
trp
.
translationFinished
)
.
length
=
=
=
0
;
const
emptyDownloadProgress
=
{
bytesDownloaded
:
0
bytesToDownload
:
0
startTs
:
undefined
durationMs
:
0
endTs
:
undefined
}
;
const
modelDownloadProgress
=
translationRequestProgressEntries
.
map
(
(
trp
)
=
>
trp
.
modelDownloadProgress
)
.
filter
(
(
mdp
)
=
>
mdp
)
.
reduce
(
(
a
b
)
=
>
{
const
startTs
=
a
.
startTs
&
&
a
.
startTs
<
=
b
.
startTs
?
a
.
startTs
:
b
.
startTs
;
const
endTs
=
a
.
endTs
&
&
a
.
endTs
>
=
b
.
endTs
?
a
.
endTs
:
b
.
endTs
;
return
{
bytesDownloaded
:
a
.
bytesDownloaded
+
b
.
bytesDownloaded
bytesToDownload
:
a
.
bytesToDownload
+
b
.
bytesToDownload
startTs
durationMs
:
endTs
?
endTs
-
startTs
:
Date
.
now
(
)
-
startTs
endTs
}
;
}
emptyDownloadProgress
)
;
this
.
patchDocumentTranslationState
(
[
{
op
:
"
replace
"
path
:
[
"
translationInitiationTimestamp
"
]
value
:
translationInitiationTimestamp
}
{
op
:
"
replace
"
path
:
[
"
totalModelLoadWallTimeMs
"
]
value
:
totalModelLoadWallTimeMs
}
{
op
:
"
replace
"
path
:
[
"
modelDownloadNecessary
"
]
value
:
modelDownloadNecessary
}
{
op
:
"
replace
"
path
:
[
"
modelDownloading
"
]
value
:
modelDownloading
}
{
op
:
"
replace
"
path
:
[
"
modelDownloadProgress
"
]
value
:
modelDownloadProgress
}
{
op
:
"
replace
"
path
:
[
"
totalTranslationWallTimeMs
"
]
value
:
totalTranslationWallTimeMs
}
{
op
:
"
replace
"
path
:
[
"
totalTranslationEngineRequestCount
"
]
value
:
totalTranslationEngineRequestCount
}
{
op
:
"
replace
"
path
:
[
"
queuedTranslationEngineRequestCount
"
]
value
:
queuedTranslationEngineRequestCount
}
{
op
:
"
replace
"
path
:
[
"
modelLoadNecessary
"
]
value
:
modelLoadNecessary
}
{
op
:
"
replace
"
path
:
[
"
modelLoading
"
]
value
:
modelLoading
}
{
op
:
"
replace
"
path
:
[
"
modelLoaded
"
]
value
:
modelLoaded
}
{
op
:
"
replace
"
path
:
[
"
translationFinished
"
]
value
:
translationFinished
}
]
)
;
}
clear
(
)
{
setTimeout
(
(
)
=
>
{
this
.
extensionState
.
deleteDocumentTranslationStateByFrameInfo
(
this
.
frameInfo
)
;
}
0
)
;
}
updatedDetectedLanguageResults
(
detectedLanguageResults
)
{
this
.
broadcastUpdatedAttributeValue
(
"
detectedLanguageResults
"
detectedLanguageResults
)
;
}
}
exports
.
DocumentTranslationStateCommunicator
=
DocumentTranslationStateCommunicator
;
}
)
1429
:
(
function
(
__unused_webpack_module
exports
__webpack_require__
)
{
var
__awaiter
=
(
this
&
&
this
.
__awaiter
)
|
|
function
(
thisArg
_arguments
P
generator
)
{
function
adopt
(
value
)
{
return
value
instanceof
P
?
value
:
new
P
(
function
(
resolve
)
{
resolve
(
value
)
;
}
)
;
}
return
new
(
P
|
|
(
P
=
Promise
)
)
(
function
(
resolve
reject
)
{
function
fulfilled
(
value
)
{
try
{
step
(
generator
.
next
(
value
)
)
;
}
catch
(
e
)
{
reject
(
e
)
;
}
}
function
rejected
(
value
)
{
try
{
step
(
generator
[
"
throw
"
]
(
value
)
)
;
}
catch
(
e
)
{
reject
(
e
)
;
}
}
function
step
(
result
)
{
result
.
done
?
resolve
(
result
.
value
)
:
adopt
(
result
.
value
)
.
then
(
fulfilled
rejected
)
;
}
step
(
(
generator
=
generator
.
apply
(
thisArg
_arguments
|
|
[
]
)
)
.
next
(
)
)
;
}
)
;
}
;
Object
.
defineProperty
(
exports
"
__esModule
"
(
{
value
:
true
}
)
)
;
exports
.
subscribeToExtensionState
=
void
0
;
const
mobx_keystone_1
=
__webpack_require__
(
4380
)
;
const
webextension_polyfill_ts_1
=
__webpack_require__
(
5006
)
;
const
ErrorReporting_1
=
__webpack_require__
(
9009
)
;
const
nanoid_1
=
__webpack_require__
(
3608
)
;
mobx_keystone_1
.
setGlobalConfig
(
{
modelAutoTypeChecking
:
mobx_keystone_1
.
ModelAutoTypeCheckingMode
.
AlwaysOff
}
)
;
class
MobxKeystoneProxy
{
constructor
(
msgListeners
)
{
this
.
msgListeners
=
[
]
;
this
.
msgListeners
=
msgListeners
;
this
.
backgroundContextPort
=
webextension_polyfill_ts_1
.
browser
.
runtime
.
connect
(
webextension_polyfill_ts_1
.
browser
.
runtime
.
id
{
name
:
"
port
-
from
-
mobx
-
keystone
-
proxy
"
}
)
;
const
actionCallResultsMessageListener
=
(
m
)
=
>
__awaiter
(
this
void
0
void
0
function
*
(
)
{
if
(
m
.
serializedActionCallToReplicate
)
{
const
{
serializedActionCallToReplicate
}
=
m
;
this
.
msgListeners
.
forEach
(
listener
=
>
listener
(
serializedActionCallToReplicate
)
)
;
return
;
}
if
(
m
.
initialState
)
{
return
;
}
ErrorReporting_1
.
captureExceptionWithExtras
(
new
Error
(
"
Unexpected
message
"
)
{
m
}
)
;
console
.
error
(
"
Unexpected
message
"
{
m
}
)
;
}
)
;
this
.
backgroundContextPort
.
onMessage
.
addListener
(
actionCallResultsMessageListener
)
;
}
requestInitialState
(
)
{
return
__awaiter
(
this
void
0
void
0
function
*
(
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
const
requestId
=
nanoid_1
.
nanoid
(
)
;
const
resultsMessageListener
=
(
m
)
=
>
__awaiter
(
this
void
0
void
0
function
*
(
)
{
if
(
m
.
initialState
)
{
const
{
initialState
}
=
m
;
if
(
m
.
requestId
!
=
=
requestId
)
{
return
;
}
this
.
backgroundContextPort
.
onMessage
.
removeListener
(
resultsMessageListener
)
;
resolve
(
initialState
)
;
return
;
}
if
(
m
.
serializedActionCallToReplicate
)
{
return
;
}
ErrorReporting_1
.
captureExceptionWithExtras
(
new
Error
(
"
Unexpected
message
"
)
{
m
}
)
;
console
.
error
(
"
Unexpected
message
"
{
m
}
)
;
reject
(
{
m
}
)
;
}
)
;
this
.
backgroundContextPort
.
onMessage
.
addListener
(
resultsMessageListener
)
;
this
.
backgroundContextPort
.
postMessage
(
{
requestInitialState
:
true
requestId
}
)
;
}
)
;
}
)
;
}
actionCall
(
actionCall
)
{
return
__awaiter
(
this
void
0
void
0
function
*
(
)
{
return
new
Promise
(
(
resolve
_reject
)
=
>
{
const
requestId
=
nanoid_1
.
nanoid
(
)
;
this
.
backgroundContextPort
.
postMessage
(
{
actionCall
requestId
}
)
;
resolve
(
)
;
}
)
;
}
)
;
}
}
class
BackgroundContextCommunicator
{
constructor
(
)
{
this
.
msgListeners
=
[
]
;
this
.
mobxKeystoneProxy
=
new
MobxKeystoneProxy
(
this
.
msgListeners
)
;
}
requestInitialState
(
)
{
return
__awaiter
(
this
void
0
void
0
function
*
(
)
{
return
this
.
mobxKeystoneProxy
.
requestInitialState
(
)
;
}
)
;
}
onMessage
(
listener
)
{
this
.
msgListeners
.
push
(
listener
)
;
}
sendMessage
(
actionCall
)
{
this
.
mobxKeystoneProxy
.
actionCall
(
actionCall
)
;
}
}
const
server
=
new
BackgroundContextCommunicator
(
)
;
function
subscribeToExtensionState
(
)
{
return
__awaiter
(
this
void
0
void
0
function
*
(
)
{
const
rootStoreSnapshot
=
yield
server
.
requestInitialState
(
)
;
const
rootStore
=
mobx_keystone_1
.
fromSnapshot
(
rootStoreSnapshot
)
;
let
serverAction
=
false
;
const
runServerActionLocally
=
(
actionCall
)
=
>
{
const
wasServerAction
=
serverAction
;
serverAction
=
true
;
try
{
mobx_keystone_1
.
applySerializedActionAndSyncNewModelIds
(
rootStore
actionCall
)
;
}
finally
{
serverAction
=
wasServerAction
;
}
}
;
server
.
onMessage
(
actionCall
=
>
{
runServerActionLocally
(
actionCall
)
;
}
)
;
mobx_keystone_1
.
onActionMiddleware
(
rootStore
{
onStart
(
actionCall
ctx
)
{
if
(
!
serverAction
)
{
server
.
sendMessage
(
mobx_keystone_1
.
serializeActionCall
(
actionCall
rootStore
)
)
;
ctx
.
data
.
cancelled
=
true
;
return
{
result
:
mobx_keystone_1
.
ActionTrackingResult
.
Return
value
:
undefined
}
;
}
return
undefined
;
}
}
)
;
mobx_keystone_1
.
registerRootStore
(
rootStore
)
;
return
rootStore
;
}
)
;
}
exports
.
subscribeToExtensionState
=
subscribeToExtensionState
;
}
)
}
)
;
var
__webpack_module_cache__
=
{
}
;
function
__webpack_require__
(
moduleId
)
{
if
(
__webpack_module_cache__
[
moduleId
]
)
{
return
__webpack_module_cache__
[
moduleId
]
.
exports
;
}
var
module
=
__webpack_module_cache__
[
moduleId
]
=
{
id
:
moduleId
loaded
:
false
exports
:
{
}
}
;
__webpack_modules__
[
moduleId
]
.
call
(
module
.
exports
module
module
.
exports
__webpack_require__
)
;
module
.
loaded
=
true
;
return
module
.
exports
;
}
__webpack_require__
.
m
=
__webpack_modules__
;
__webpack_require__
.
x
=
x
=
>
{
}
;
(
(
)
=
>
{
__webpack_require__
.
n
=
(
module
)
=
>
{
var
getter
=
module
&
&
module
.
__esModule
?
(
)
=
>
(
module
[
'
default
'
]
)
:
(
)
=
>
(
module
)
;
__webpack_require__
.
d
(
getter
{
a
:
getter
}
)
;
return
getter
;
}
;
}
)
(
)
;
(
(
)
=
>
{
__webpack_require__
.
d
=
(
exports
definition
)
=
>
{
for
(
var
key
in
definition
)
{
if
(
__webpack_require__
.
o
(
definition
key
)
&
&
!
__webpack_require__
.
o
(
exports
key
)
)
{
Object
.
defineProperty
(
exports
key
{
enumerable
:
true
get
:
definition
[
key
]
}
)
;
}
}
}
;
}
)
(
)
;
(
(
)
=
>
{
__webpack_require__
.
g
=
(
function
(
)
{
if
(
typeof
globalThis
=
=
=
'
object
'
)
return
globalThis
;
try
{
return
this
|
|
new
Function
(
'
return
this
'
)
(
)
;
}
catch
(
e
)
{
if
(
typeof
window
=
=
=
'
object
'
)
return
window
;
}
}
)
(
)
;
}
)
(
)
;
(
(
)
=
>
{
__webpack_require__
.
hmd
=
(
module
)
=
>
{
module
=
Object
.
create
(
module
)
;
if
(
!
module
.
children
)
module
.
children
=
[
]
;
Object
.
defineProperty
(
module
'
exports
'
{
enumerable
:
true
set
:
(
)
=
>
{
throw
new
Error
(
'
ES
Modules
may
not
assign
module
.
exports
or
exports
.
*
Use
ESM
export
syntax
instead
:
'
+
module
.
id
)
;
}
}
)
;
return
module
;
}
;
}
)
(
)
;
(
(
)
=
>
{
__webpack_require__
.
o
=
(
obj
prop
)
=
>
(
Object
.
prototype
.
hasOwnProperty
.
call
(
obj
prop
)
)
}
)
(
)
;
(
(
)
=
>
{
__webpack_require__
.
r
=
(
exports
)
=
>
{
if
(
typeof
Symbol
!
=
=
'
undefined
'
&
&
Symbol
.
toStringTag
)
{
Object
.
defineProperty
(
exports
Symbol
.
toStringTag
{
value
:
'
Module
'
}
)
;
}
Object
.
defineProperty
(
exports
'
__esModule
'
{
value
:
true
}
)
;
}
;
}
)
(
)
;
(
(
)
=
>
{
var
installedChunks
=
{
840
:
0
}
;
var
deferredModules
=
[
[
2380
351
]
]
;
var
checkDeferredModules
=
x
=
>
{
}
;
var
webpackJsonpCallback
=
(
parentChunkLoadingFunction
data
)
=
>
{
var
[
chunkIds
moreModules
runtime
executeModules
]
=
data
;
var
moduleId
chunkId
i
=
0
resolves
=
[
]
;
for
(
;
i
<
chunkIds
.
length
;
i
+
+
)
{
chunkId
=
chunkIds
[
i
]
;
if
(
__webpack_require__
.
o
(
installedChunks
chunkId
)
&
&
installedChunks
[
chunkId
]
)
{
resolves
.
push
(
installedChunks
[
chunkId
]
[
0
]
)
;
}
installedChunks
[
chunkId
]
=
0
;
}
for
(
moduleId
in
moreModules
)
{
if
(
__webpack_require__
.
o
(
moreModules
moduleId
)
)
{
__webpack_require__
.
m
[
moduleId
]
=
moreModules
[
moduleId
]
;
}
}
if
(
runtime
)
runtime
(
__webpack_require__
)
;
if
(
parentChunkLoadingFunction
)
parentChunkLoadingFunction
(
data
)
;
while
(
resolves
.
length
)
{
resolves
.
shift
(
)
(
)
;
}
if
(
executeModules
)
deferredModules
.
push
.
apply
(
deferredModules
executeModules
)
;
return
checkDeferredModules
(
)
;
}
var
chunkLoadingGlobal
=
self
[
"
webpackChunkfirefox_infobar_ui
"
]
=
self
[
"
webpackChunkfirefox_infobar_ui
"
]
|
|
[
]
;
chunkLoadingGlobal
.
forEach
(
webpackJsonpCallback
.
bind
(
null
0
)
)
;
chunkLoadingGlobal
.
push
=
webpackJsonpCallback
.
bind
(
null
chunkLoadingGlobal
.
push
.
bind
(
chunkLoadingGlobal
)
)
;
function
checkDeferredModulesImpl
(
)
{
var
result
;
for
(
var
i
=
0
;
i
<
deferredModules
.
length
;
i
+
+
)
{
var
deferredModule
=
deferredModules
[
i
]
;
var
fulfilled
=
true
;
for
(
var
j
=
1
;
j
<
deferredModule
.
length
;
j
+
+
)
{
var
depId
=
deferredModule
[
j
]
;
if
(
installedChunks
[
depId
]
!
=
=
0
)
fulfilled
=
false
;
}
if
(
fulfilled
)
{
deferredModules
.
splice
(
i
-
-
1
)
;
result
=
__webpack_require__
(
__webpack_require__
.
s
=
deferredModule
[
0
]
)
;
}
}
if
(
deferredModules
.
length
=
=
=
0
)
{
__webpack_require__
.
x
(
)
;
__webpack_require__
.
x
=
x
=
>
{
}
;
}
return
result
;
}
var
startup
=
__webpack_require__
.
x
;
__webpack_require__
.
x
=
(
)
=
>
{
__webpack_require__
.
x
=
startup
|
|
(
x
=
>
{
}
)
;
return
(
checkDeferredModules
=
checkDeferredModulesImpl
)
(
)
;
}
;
}
)
(
)
;
var
__webpack_exports__
=
__webpack_require__
.
x
(
)
;
}
)
(
)
;
