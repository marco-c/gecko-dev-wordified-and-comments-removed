"
use
strict
"
;
let
showConsoleLogs
;
async
function
log
(
)
{
if
(
showConsoleLogs
)
{
console
.
log
(
.
.
.
arguments
)
;
}
}
const
DOH_ENABLED_PREF
=
"
doh
-
rollout
.
enabled
"
;
const
TRR_MODE_PREF
=
"
network
.
trr
.
mode
"
;
const
DOH_SELF_ENABLED_PREF
=
"
doh
-
rollout
.
self
-
enabled
"
;
const
DOH_PREVIOUS_TRR_MODE_PREF
=
"
doh
-
rollout
.
previous
.
trr
.
mode
"
;
const
DOH_DOORHANGER_SHOWN_PREF
=
"
doh
-
rollout
.
doorhanger
-
shown
"
;
const
DOH_DOORHANGER_USER_DECISION_PREF
=
"
doh
-
rollout
.
doorhanger
-
decision
"
;
const
DOH_DISABLED_PREF
=
"
doh
-
rollout
.
disable
-
heuristics
"
;
const
DOH_SKIP_HEURISTICS_PREF
=
"
doh
-
rollout
.
skipHeuristicsCheck
"
;
const
DOH_DONE_FIRST_RUN_PREF
=
"
doh
-
rollout
.
doneFirstRun
"
;
const
DOH_BALROG_MIGRATION_PREF
=
"
doh
-
rollout
.
balrog
-
migration
-
done
"
;
const
DOH_DEBUG_PREF
=
"
doh
-
rollout
.
debug
"
;
const
stateManager
=
{
async
setState
(
state
)
{
log
(
"
setState
:
"
state
)
;
browser
.
experiments
.
preferences
.
state
.
set
(
{
value
:
state
}
)
;
switch
(
state
)
{
case
"
uninstalled
"
:
break
;
case
"
disabled
"
:
rollout
.
setSetting
(
TRR_MODE_PREF
0
)
;
break
;
case
"
manuallyDisabled
"
:
browser
.
experiments
.
preferences
.
clearUserPref
(
DOH_SELF_ENABLED_PREF
)
;
break
;
case
"
UIOk
"
:
rollout
.
setSetting
(
DOH_SELF_ENABLED_PREF
true
)
;
break
;
case
"
enabled
"
:
rollout
.
setSetting
(
TRR_MODE_PREF
2
)
;
rollout
.
setSetting
(
DOH_SELF_ENABLED_PREF
true
)
;
break
;
case
"
UIDisabled
"
:
rollout
.
setSetting
(
TRR_MODE_PREF
5
)
;
browser
.
experiments
.
preferences
.
clearUserPref
(
DOH_SELF_ENABLED_PREF
)
;
break
;
}
await
browser
.
experiments
.
heuristics
.
sendStatePing
(
state
)
;
await
stateManager
.
rememberTRRMode
(
)
;
}
async
rememberTRRMode
(
)
{
let
curMode
=
await
browser
.
experiments
.
preferences
.
getIntPref
(
TRR_MODE_PREF
0
)
;
log
(
"
Saving
current
trr
mode
:
"
curMode
)
;
await
rollout
.
setSetting
(
DOH_PREVIOUS_TRR_MODE_PREF
curMode
true
)
;
}
async
rememberDoorhangerShown
(
)
{
log
(
"
Remembering
that
doorhanger
has
been
shown
"
)
;
await
rollout
.
setSetting
(
DOH_DOORHANGER_SHOWN_PREF
true
)
;
}
async
rememberDoorhangerDecision
(
decision
)
{
log
(
"
Remember
doorhanger
decision
:
"
decision
)
;
await
rollout
.
setSetting
(
DOH_DOORHANGER_USER_DECISION_PREF
decision
true
)
;
}
async
rememberDisableHeuristics
(
)
{
log
(
"
Remembering
to
never
run
heuristics
again
"
)
;
await
rollout
.
setSetting
(
DOH_DISABLED_PREF
true
)
;
}
async
shouldRunHeuristics
(
)
{
let
disableHeuristics
=
await
rollout
.
getSetting
(
DOH_DISABLED_PREF
false
)
;
if
(
disableHeuristics
)
{
log
(
"
disableHeuristics
has
been
enabled
.
"
)
;
return
false
;
}
let
prevMode
=
await
rollout
.
getSetting
(
DOH_PREVIOUS_TRR_MODE_PREF
0
)
;
let
curMode
=
await
browser
.
experiments
.
preferences
.
getIntPref
(
TRR_MODE_PREF
0
)
;
log
(
"
Comparing
previous
trr
mode
to
current
mode
:
"
prevMode
curMode
)
;
if
(
prevMode
!
=
=
curMode
)
{
log
(
"
Mismatched
curMode
:
"
curMode
)
;
let
results
=
await
runHeuristics
(
)
;
results
.
evaluateReason
=
"
userModified
"
;
if
(
curMode
=
=
=
0
|
|
curMode
=
=
=
5
)
{
browser
.
experiments
.
heuristics
.
sendHeuristicsPing
(
"
disable_doh
"
results
)
;
browser
.
experiments
.
preferences
.
clearUserPref
(
DOH_SELF_ENABLED_PREF
)
;
await
stateManager
.
rememberDisableHeuristics
(
)
;
}
else
{
await
rollout
.
trrModePrefHasUserValue
(
"
shouldRunHeuristics_mismatch
"
results
)
;
}
return
false
;
}
return
true
;
}
async
shouldShowDoorhanger
(
)
{
let
doorhangerShown
=
await
rollout
.
getSetting
(
DOH_DOORHANGER_SHOWN_PREF
false
)
;
log
(
"
Should
show
doorhanger
:
"
!
doorhangerShown
)
;
return
!
doorhangerShown
;
}
async
showDoorHangerAndEnableDoH
(
)
{
browser
.
experiments
.
doorhanger
.
onDoorhangerAccept
.
addListener
(
rollout
.
doorhangerAcceptListener
)
;
browser
.
experiments
.
doorhanger
.
onDoorhangerDecline
.
addListener
(
rollout
.
doorhangerDeclineListener
)
;
await
browser
.
experiments
.
doorhanger
.
show
(
{
name
:
browser
.
i18n
.
getMessage
(
"
doorhangerName
"
)
text
:
"
<
>
"
+
browser
.
i18n
.
getMessage
(
"
doorhangerBody
"
)
okLabel
:
browser
.
i18n
.
getMessage
(
"
doorhangerButtonOk
"
)
okAccessKey
:
browser
.
i18n
.
getMessage
(
"
doorhangerButtonOkAccessKey
"
)
cancelLabel
:
browser
.
i18n
.
getMessage
(
"
doorhangerButtonCancel2
"
)
cancelAccessKey
:
browser
.
i18n
.
getMessage
(
"
doorhangerButtonCancelAccessKey
"
)
}
)
;
await
stateManager
.
setState
(
"
enabled
"
)
;
}
}
;
let
notificationTime
=
new
Date
(
)
.
getTime
(
)
/
1000
;
const
rollout
=
{
async
doorhangerAcceptListener
(
tabId
)
{
log
(
"
Doorhanger
accepted
on
tab
"
tabId
)
;
await
stateManager
.
setState
(
"
UIOk
"
)
;
await
stateManager
.
rememberDoorhangerDecision
(
"
UIOk
"
)
;
await
stateManager
.
rememberDoorhangerShown
(
)
;
}
async
doorhangerDeclineListener
(
tabId
)
{
log
(
"
Doorhanger
declined
on
tab
"
tabId
)
;
await
stateManager
.
setState
(
"
UIDisabled
"
)
;
await
stateManager
.
rememberDoorhangerDecision
(
"
UIDisabled
"
)
;
let
results
=
await
runHeuristics
(
)
;
results
.
evaluateReason
=
"
doorhangerDecline
"
;
browser
.
experiments
.
heuristics
.
sendHeuristicsPing
(
"
disable_doh
"
results
)
;
await
stateManager
.
rememberDisableHeuristics
(
)
;
await
stateManager
.
rememberDoorhangerShown
(
)
;
}
async
netChangeListener
(
)
{
let
curTime
=
new
Date
(
)
.
getTime
(
)
/
1000
;
let
timePassed
=
curTime
-
notificationTime
;
log
(
"
Time
passed
since
last
network
change
:
"
timePassed
)
;
if
(
timePassed
<
30
)
{
return
;
}
notificationTime
=
curTime
;
let
decision
=
await
rollout
.
heuristics
(
"
netChange
"
)
;
if
(
decision
=
=
=
"
disable_doh
"
)
{
await
stateManager
.
setState
(
"
disabled
"
)
;
}
else
{
await
stateManager
.
setState
(
"
enabled
"
)
;
}
}
async
heuristics
(
evaluateReason
)
{
let
results
=
await
runHeuristics
(
)
;
let
disablingDoh
=
Object
.
values
(
results
)
.
some
(
item
=
>
item
=
=
=
"
disable_doh
"
)
;
let
decision
;
if
(
disablingDoh
)
{
decision
=
"
disable_doh
"
;
}
else
{
decision
=
"
enable_doh
"
;
}
log
(
"
Heuristics
decision
on
"
+
evaluateReason
+
"
:
"
+
decision
)
;
results
.
evaluateReason
=
evaluateReason
;
browser
.
experiments
.
heuristics
.
sendHeuristicsPing
(
decision
results
)
;
return
decision
;
}
async
getSetting
(
name
defaultValue
)
{
switch
(
typeof
defaultValue
)
{
case
"
boolean
"
:
log
(
{
context
:
"
getSetting
"
type
:
"
boolean
"
name
value
:
await
browser
.
experiments
.
preferences
.
getBoolPref
(
name
defaultValue
)
}
)
;
return
browser
.
experiments
.
preferences
.
getBoolPref
(
name
defaultValue
)
;
case
"
number
"
:
log
(
{
context
:
"
getSetting
"
type
:
"
number
"
name
value
:
await
browser
.
experiments
.
preferences
.
getIntPref
(
name
defaultValue
)
}
)
;
return
browser
.
experiments
.
preferences
.
getIntPref
(
name
defaultValue
)
;
case
"
string
"
:
log
(
{
context
:
"
getSetting
"
type
:
"
string
"
name
value
:
await
browser
.
experiments
.
preferences
.
getCharPref
(
name
defaultValue
)
}
)
;
return
browser
.
experiments
.
preferences
.
getCharPref
(
name
defaultValue
)
;
default
:
throw
new
Error
(
Invalid
defaultValue
argument
when
trying
to
fetch
pref
:
{
JSON
.
stringify
(
name
)
}
)
;
}
}
async
setSetting
(
name
value
)
{
switch
(
typeof
value
)
{
case
"
boolean
"
:
await
browser
.
experiments
.
preferences
.
setBoolPref
(
name
value
)
;
break
;
case
"
number
"
:
await
browser
.
experiments
.
preferences
.
setIntPref
(
name
value
)
;
break
;
case
"
string
"
:
await
browser
.
experiments
.
preferences
.
setCharPref
(
name
value
)
;
break
;
default
:
throw
new
Error
(
"
setSetting
typeof
value
unknown
!
"
)
;
}
}
async
trrModePrefHasUserValue
(
event
results
)
{
results
.
evaluateReason
=
event
;
await
rollout
.
setSetting
(
DOH_SKIP_HEURISTICS_PREF
false
)
;
if
(
await
browser
.
experiments
.
preferences
.
prefHasUserValue
(
TRR_MODE_PREF
)
)
{
browser
.
experiments
.
heuristics
.
sendHeuristicsPing
(
"
prefHasUserValue
"
results
)
;
browser
.
experiments
.
preferences
.
clearUserPref
(
DOH_SELF_ENABLED_PREF
)
;
await
stateManager
.
rememberDisableHeuristics
(
)
;
}
}
async
enterprisePolicyCheck
(
event
results
)
{
results
.
evaluateReason
=
event
;
await
rollout
.
setSetting
(
DOH_SKIP_HEURISTICS_PREF
false
)
;
let
policyEnableDoH
=
await
browser
.
experiments
.
heuristics
.
checkEnterprisePolicies
(
)
;
switch
(
policyEnableDoH
)
{
case
"
enable_doh
"
:
log
(
"
Policy
requires
DoH
enabled
.
"
)
;
browser
.
experiments
.
heuristics
.
sendHeuristicsPing
(
policyEnableDoH
results
)
;
break
;
case
"
policy_without_doh
"
:
log
(
"
Policy
does
not
mention
DoH
.
"
)
;
await
stateManager
.
setState
(
"
disabled
"
)
;
browser
.
experiments
.
heuristics
.
sendHeuristicsPing
(
policyEnableDoH
results
)
;
break
;
case
"
disable_doh
"
:
log
(
"
Policy
requires
DoH
to
be
disabled
.
"
)
;
browser
.
experiments
.
heuristics
.
sendHeuristicsPing
(
policyEnableDoH
results
)
;
break
;
case
"
no_policy_set
"
:
}
if
(
policyEnableDoH
=
=
=
"
no_policy_set
"
)
{
await
rollout
.
setSetting
(
DOH_SKIP_HEURISTICS_PREF
false
)
;
}
else
{
await
rollout
.
setSetting
(
DOH_SKIP_HEURISTICS_PREF
true
)
;
}
}
async
migrateLocalStoragePrefs
(
)
{
const
isMigrated
=
await
browser
.
experiments
.
preferences
.
getBoolPref
(
DOH_BALROG_MIGRATION_PREF
false
)
;
if
(
isMigrated
)
{
log
(
"
User
has
been
migrated
.
"
)
;
return
;
}
const
legacyLocalStorageKeys
=
[
"
doneFirstRun
"
"
skipHeuristicsCheck
"
DOH_ENABLED_PREF
DOH_PREVIOUS_TRR_MODE_PREF
DOH_DOORHANGER_SHOWN_PREF
DOH_DOORHANGER_USER_DECISION_PREF
DOH_DISABLED_PREF
]
;
for
(
let
item
of
legacyLocalStorageKeys
)
{
let
data
=
await
browser
.
storage
.
local
.
get
(
item
)
;
let
value
=
data
[
item
]
;
log
(
{
context
:
"
migration
"
item
value
}
)
;
if
(
data
.
hasOwnProperty
(
item
)
)
{
let
migratedName
=
item
;
if
(
!
item
.
startsWith
(
"
doh
-
rollout
.
"
)
)
{
migratedName
=
"
doh
-
rollout
.
"
+
item
;
}
await
this
.
setSetting
(
migratedName
value
)
;
}
}
browser
.
experiments
.
preferences
.
setBoolPref
(
DOH_BALROG_MIGRATION_PREF
true
)
;
log
(
"
Remembering
that
this
user
has
been
migrated
.
"
)
;
}
async
init
(
)
{
log
(
"
calling
init
"
)
;
let
doneFirstRun
=
await
rollout
.
getSetting
(
DOH_DONE_FIRST_RUN_PREF
false
)
;
browser
.
experiments
.
heuristics
.
setupTelemetry
(
)
;
let
results
=
await
runHeuristics
(
)
;
if
(
!
doneFirstRun
)
{
log
(
"
first
run
!
"
)
;
await
rollout
.
setSetting
(
DOH_DONE_FIRST_RUN_PREF
true
)
;
await
this
.
trrModePrefHasUserValue
(
"
first_run
"
results
)
;
await
this
.
enterprisePolicyCheck
(
"
first_run
"
results
)
;
}
else
{
log
(
"
not
first
run
!
"
)
;
await
this
.
enterprisePolicyCheck
(
"
startup
"
results
)
;
}
let
skipHeuristicsCheck
=
await
rollout
.
getSetting
(
DOH_SKIP_HEURISTICS_PREF
false
)
;
log
(
"
skipHeuristicsCheck
:
"
skipHeuristicsCheck
)
;
if
(
!
skipHeuristicsCheck
)
{
let
shouldRunHeuristics
=
await
stateManager
.
shouldRunHeuristics
(
)
;
if
(
shouldRunHeuristics
)
{
await
rollout
.
main
(
)
;
}
}
browser
.
experiments
.
netChange
.
onConnectionChanged
.
addListener
(
async
(
)
=
>
{
log
(
"
onConnectionChanged
"
)
;
let
shouldRunHeuristics
=
await
stateManager
.
shouldRunHeuristics
(
)
;
let
shouldShowDoorhanger
=
await
stateManager
.
shouldShowDoorhanger
(
)
;
if
(
shouldRunHeuristics
)
{
const
netChangeDecision
=
await
rollout
.
heuristics
(
"
netChange
"
)
;
if
(
netChangeDecision
=
=
=
"
disable_doh
"
)
{
await
stateManager
.
setState
(
"
disabled
"
)
;
}
else
if
(
shouldShowDoorhanger
)
{
await
stateManager
.
showDoorHangerAndEnableDoH
(
)
;
}
else
{
await
stateManager
.
setState
(
"
enabled
"
)
;
}
}
}
)
;
}
async
main
(
)
{
browser
.
captivePortal
.
onStateChanged
.
addListener
(
rollout
.
onReady
)
;
let
captiveState
=
await
browser
.
captivePortal
.
getState
(
)
;
log
(
"
Captive
state
:
"
captiveState
)
;
if
(
captiveState
=
=
=
"
unlocked_portal
"
|
|
captiveState
=
=
=
"
not_captive
"
)
{
await
rollout
.
onReady
(
{
state
:
captiveState
}
)
;
}
}
async
onReady
(
details
)
{
browser
.
captivePortal
.
onStateChanged
.
removeListener
(
rollout
.
onReady
)
;
if
(
details
.
state
!
=
=
"
unlocked_portal
"
&
&
details
.
state
!
=
=
"
not_captive
"
)
{
return
;
}
let
decision
=
await
rollout
.
heuristics
(
"
startup
"
)
;
let
shouldShowDoorhanger
=
await
stateManager
.
shouldShowDoorhanger
(
)
;
if
(
decision
=
=
=
"
disable_doh
"
)
{
await
stateManager
.
setState
(
"
disabled
"
)
;
}
else
if
(
shouldShowDoorhanger
)
{
await
stateManager
.
showDoorHangerAndEnableDoH
(
)
;
}
else
{
await
stateManager
.
setState
(
"
enabled
"
)
;
}
}
}
;
async
function
checkNormandyAddonStudy
(
)
{
const
study
=
await
browser
.
normandyAddonStudy
.
getStudy
(
)
;
if
(
typeof
study
=
=
=
"
undefined
"
|
|
study
=
=
=
undefined
)
{
log
(
"
No
Normandy
study
detected
!
"
)
;
return
false
;
}
const
branch
=
study
.
branch
;
switch
(
branch
)
{
case
"
doh
-
rollout
-
heuristics
"
:
return
true
;
case
"
doh
-
rollout
-
disabled
"
:
return
false
;
default
:
throw
new
Error
(
Unexpected
study
branch
:
{
JSON
.
stringify
(
branch
)
}
)
;
}
}
const
setup
=
{
async
start
(
)
{
showConsoleLogs
=
await
browser
.
experiments
.
preferences
.
getBoolPref
(
DOH_DEBUG_PREF
false
)
;
await
rollout
.
migrateLocalStoragePrefs
(
)
;
const
isNormandyStudy
=
await
checkNormandyAddonStudy
(
)
;
const
isAddonDisabled
=
await
rollout
.
getSetting
(
DOH_DISABLED_PREF
false
)
;
const
runAddonPref
=
await
rollout
.
getSetting
(
DOH_ENABLED_PREF
false
)
;
const
runAddonBypassPref
=
await
rollout
.
getSetting
(
DOH_SELF_ENABLED_PREF
false
)
;
const
runAddonDoorhangerDecision
=
await
rollout
.
getSetting
(
DOH_DOORHANGER_USER_DECISION_PREF
"
"
)
;
const
runAddonPreviousTRRMode
=
await
rollout
.
getSetting
(
DOH_PREVIOUS_TRR_MODE_PREF
0
)
;
if
(
isAddonDisabled
)
{
log
(
"
Addon
has
been
disabled
.
DoH
status
will
not
be
modified
from
current
setting
"
)
;
await
stateManager
.
rememberDisableHeuristics
(
)
;
return
;
}
if
(
runAddonPref
|
|
runAddonBypassPref
|
|
runAddonDoorhangerDecision
=
=
=
"
UIOk
"
|
|
runAddonDoorhangerDecision
=
=
=
"
enabled
"
|
|
runAddonPreviousTRRMode
=
=
=
2
|
|
runAddonPreviousTRRMode
=
=
=
0
|
|
isNormandyStudy
)
{
rollout
.
init
(
)
;
}
else
{
log
(
"
Init
not
ran
on
startup
.
Watching
doh
-
rollout
.
enabled
pref
for
change
event
"
)
;
}
browser
.
experiments
.
preferences
.
onPrefChanged
.
addListener
(
(
)
=
>
this
.
start
(
)
)
;
}
}
;
setup
.
start
(
)
;
