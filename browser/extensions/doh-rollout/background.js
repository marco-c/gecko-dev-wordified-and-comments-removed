"
use
strict
"
;
let
DEBUG
;
async
function
log
(
)
{
if
(
DEBUG
)
{
console
.
log
(
.
.
.
arguments
)
;
}
}
const
DOH_ENABLED_PREF
=
"
doh
-
rollout
.
enabled
"
;
const
MOCK_HEURISTICS_PREF
=
"
doh
-
rollout
.
heuristics
.
mockValues
"
;
const
TRR_MODE_PREF
=
"
network
.
trr
.
mode
"
;
const
DOH_SELF_ENABLED_PREF
=
"
doh
-
rollout
.
self
-
enabled
"
;
const
DOH_PREVIOUS_TRR_MODE_PREF
=
"
doh
-
rollout
.
previous
.
trr
.
mode
"
;
const
DOH_DOORHANGER_SHOWN_PREF
=
"
doh
-
rollout
.
doorhanger
-
shown
"
;
const
DOH_DOORHANGER_USER_DECISION_PREF
=
"
doh
-
rollout
.
doorhanger
-
decision
"
;
const
DOH_DISABLED_PREF
=
"
doh
-
rollout
.
disable
-
heuristics
"
;
const
DOH_SKIP_HEURISTICS_PREF
=
"
doh
-
rollout
.
skipHeuristicsCheck
"
;
const
DOH_DONE_FIRST_RUN_PREF
=
"
doh
-
rollout
.
doneFirstRun
"
;
const
DOH_BALROG_MIGRATION_PREF
=
"
doh
-
rollout
.
balrog
-
migration
-
done
"
;
const
DOH_DEBUG_PREF
=
"
doh
-
rollout
.
debug
"
;
const
stateManager
=
{
async
setState
(
state
)
{
log
(
"
setState
:
"
state
)
;
switch
(
state
)
{
case
"
uninstalled
"
:
break
;
case
"
disabled
"
:
rollout
.
setSetting
(
TRR_MODE_PREF
0
)
;
break
;
case
"
manuallyDisabled
"
:
browser
.
experiments
.
preferences
.
clearUserPref
(
DOH_SELF_ENABLED_PREF
)
;
break
;
case
"
UIOk
"
:
rollout
.
setSetting
(
DOH_SELF_ENABLED_PREF
true
)
;
break
;
case
"
enabled
"
:
rollout
.
setSetting
(
TRR_MODE_PREF
2
)
;
rollout
.
setSetting
(
DOH_SELF_ENABLED_PREF
true
)
;
break
;
case
"
UIDisabled
"
:
rollout
.
setSetting
(
TRR_MODE_PREF
5
)
;
browser
.
experiments
.
preferences
.
clearUserPref
(
DOH_SELF_ENABLED_PREF
)
;
break
;
}
await
browser
.
experiments
.
heuristics
.
sendStatePing
(
state
)
;
await
stateManager
.
rememberTRRMode
(
)
;
}
async
rememberTRRMode
(
)
{
let
curMode
=
await
browser
.
experiments
.
preferences
.
getIntPref
(
TRR_MODE_PREF
0
)
;
log
(
"
Saving
current
trr
mode
:
"
curMode
)
;
await
rollout
.
setSetting
(
DOH_PREVIOUS_TRR_MODE_PREF
curMode
true
)
;
}
async
rememberDoorhangerShown
(
)
{
log
(
"
Remembering
that
doorhanger
has
been
shown
"
)
;
await
rollout
.
setSetting
(
DOH_DOORHANGER_SHOWN_PREF
true
)
;
}
async
rememberDoorhangerDecision
(
decision
)
{
log
(
"
Remember
doorhanger
decision
:
"
decision
)
;
await
rollout
.
setSetting
(
DOH_DOORHANGER_USER_DECISION_PREF
decision
true
)
;
}
async
rememberDisableHeuristics
(
)
{
log
(
"
Remembering
to
never
run
heuristics
again
"
)
;
await
rollout
.
setSetting
(
DOH_DISABLED_PREF
true
)
;
}
async
shouldRunHeuristics
(
)
{
let
disableHeuristics
=
await
rollout
.
getSetting
(
DOH_DISABLED_PREF
false
)
;
let
skipHeuristicsCheck
=
await
rollout
.
getSetting
(
DOH_SKIP_HEURISTICS_PREF
false
)
;
if
(
disableHeuristics
|
|
skipHeuristicsCheck
)
{
log
(
"
shouldRunHeuristics
:
Will
not
run
heuristics
"
)
;
return
false
;
}
let
prevMode
=
await
rollout
.
getSetting
(
DOH_PREVIOUS_TRR_MODE_PREF
0
)
;
let
curMode
=
await
browser
.
experiments
.
preferences
.
getIntPref
(
TRR_MODE_PREF
0
)
;
log
(
"
Comparing
previous
trr
mode
to
current
mode
:
"
prevMode
curMode
)
;
if
(
prevMode
=
=
=
curMode
)
{
return
true
;
}
log
(
"
Mismatched
curMode
:
"
curMode
)
;
let
results
=
await
runHeuristics
(
)
;
results
.
evaluateReason
=
"
userModified
"
;
if
(
curMode
=
=
=
0
|
|
curMode
=
=
=
5
)
{
browser
.
experiments
.
heuristics
.
sendHeuristicsPing
(
"
disable_doh
"
results
)
;
browser
.
experiments
.
preferences
.
clearUserPref
(
DOH_SELF_ENABLED_PREF
)
;
await
stateManager
.
rememberDisableHeuristics
(
)
;
}
else
{
await
rollout
.
trrModePrefHasUserValue
(
"
shouldRunHeuristics_mismatch
"
results
)
;
}
return
false
;
}
async
shouldShowDoorhanger
(
)
{
let
doorhangerShown
=
await
rollout
.
getSetting
(
DOH_DOORHANGER_SHOWN_PREF
false
)
;
log
(
"
Should
show
doorhanger
:
"
!
doorhangerShown
)
;
return
!
doorhangerShown
;
}
async
showDoorHangerAndEnableDoH
(
)
{
browser
.
experiments
.
doorhanger
.
onDoorhangerAccept
.
addListener
(
rollout
.
doorhangerAcceptListener
)
;
browser
.
experiments
.
doorhanger
.
onDoorhangerDecline
.
addListener
(
rollout
.
doorhangerDeclineListener
)
;
await
browser
.
experiments
.
doorhanger
.
show
(
{
name
:
browser
.
i18n
.
getMessage
(
"
doorhangerName
"
)
text
:
"
<
>
"
+
browser
.
i18n
.
getMessage
(
"
doorhangerBody
"
)
okLabel
:
browser
.
i18n
.
getMessage
(
"
doorhangerButtonOk
"
)
okAccessKey
:
browser
.
i18n
.
getMessage
(
"
doorhangerButtonOkAccessKey
"
)
cancelLabel
:
browser
.
i18n
.
getMessage
(
"
doorhangerButtonCancel2
"
)
cancelAccessKey
:
browser
.
i18n
.
getMessage
(
"
doorhangerButtonCancelAccessKey
"
)
}
)
;
await
stateManager
.
setState
(
"
enabled
"
)
;
}
}
;
const
rollout
=
{
lastNetworkChangeTime
:
0
async
isTesting
(
)
{
if
(
this
.
_isTesting
=
=
=
undefined
)
{
this
.
_isTesting
=
await
browser
.
experiments
.
heuristics
.
isTesting
(
)
;
}
return
this
.
_isTesting
;
}
async
doorhangerAcceptListener
(
tabId
)
{
log
(
"
Doorhanger
accepted
on
tab
"
tabId
)
;
await
stateManager
.
setState
(
"
UIOk
"
)
;
await
stateManager
.
rememberDoorhangerDecision
(
"
UIOk
"
)
;
await
stateManager
.
rememberDoorhangerShown
(
)
;
}
async
doorhangerDeclineListener
(
tabId
)
{
log
(
"
Doorhanger
declined
on
tab
"
tabId
)
;
await
stateManager
.
setState
(
"
UIDisabled
"
)
;
await
stateManager
.
rememberDoorhangerDecision
(
"
UIDisabled
"
)
;
let
results
=
await
runHeuristics
(
)
;
results
.
evaluateReason
=
"
doorhangerDecline
"
;
browser
.
experiments
.
heuristics
.
sendHeuristicsPing
(
"
disable_doh
"
results
)
;
await
stateManager
.
rememberDisableHeuristics
(
)
;
await
stateManager
.
rememberDoorhangerShown
(
)
;
}
async
heuristics
(
evaluateReason
)
{
let
results
;
if
(
await
rollout
.
isTesting
(
)
)
{
results
=
await
browser
.
experiments
.
preferences
.
getCharPref
(
MOCK_HEURISTICS_PREF
"
disable_doh
"
)
;
results
=
JSON
.
parse
(
results
)
;
}
else
{
results
=
await
runHeuristics
(
)
;
}
let
decision
=
Object
.
values
(
results
)
.
includes
(
"
disable_doh
"
)
?
"
disable_doh
"
:
"
enable_doh
"
;
log
(
"
Heuristics
decision
on
"
+
evaluateReason
+
"
:
"
+
decision
)
;
results
.
evaluateReason
=
evaluateReason
;
browser
.
experiments
.
heuristics
.
sendHeuristicsPing
(
decision
results
)
;
return
decision
;
}
async
getSetting
(
name
defaultValue
)
{
let
value
;
switch
(
typeof
defaultValue
)
{
case
"
boolean
"
:
value
=
await
browser
.
experiments
.
preferences
.
getBoolPref
(
name
defaultValue
)
;
break
;
case
"
number
"
:
value
=
await
browser
.
experiments
.
preferences
.
getIntPref
(
name
defaultValue
)
;
break
;
case
"
string
"
:
value
=
await
browser
.
experiments
.
preferences
.
getCharPref
(
name
defaultValue
)
;
break
;
default
:
throw
new
Error
(
Invalid
defaultValue
argument
when
trying
to
fetch
pref
:
{
JSON
.
stringify
(
name
)
}
)
;
}
log
(
{
context
:
"
getSetting
"
type
:
typeof
defaultValue
name
value
}
)
;
return
value
;
}
async
setSetting
(
name
value
)
{
switch
(
typeof
value
)
{
case
"
boolean
"
:
await
browser
.
experiments
.
preferences
.
setBoolPref
(
name
value
)
;
break
;
case
"
number
"
:
await
browser
.
experiments
.
preferences
.
setIntPref
(
name
value
)
;
break
;
case
"
string
"
:
await
browser
.
experiments
.
preferences
.
setCharPref
(
name
value
)
;
break
;
default
:
throw
new
Error
(
"
setSetting
typeof
value
unknown
!
"
)
;
}
log
(
{
context
:
"
setSetting
"
type
:
typeof
value
name
value
}
)
;
}
async
trrModePrefHasUserValue
(
event
results
)
{
results
.
evaluateReason
=
event
;
if
(
await
browser
.
experiments
.
preferences
.
prefHasUserValue
(
TRR_MODE_PREF
)
)
{
browser
.
experiments
.
heuristics
.
sendHeuristicsPing
(
"
prefHasUserValue
"
results
)
;
browser
.
experiments
.
preferences
.
clearUserPref
(
DOH_SELF_ENABLED_PREF
)
;
await
this
.
setSetting
(
DOH_SKIP_HEURISTICS_PREF
true
)
;
await
stateManager
.
rememberDisableHeuristics
(
)
;
}
}
async
enterprisePolicyCheck
(
event
results
)
{
results
.
evaluateReason
=
event
;
let
skipHeuristicsCheck
=
await
rollout
.
getSetting
(
DOH_SKIP_HEURISTICS_PREF
false
)
;
if
(
skipHeuristicsCheck
)
{
return
;
}
let
policyEnableDoH
=
await
browser
.
experiments
.
heuristics
.
checkEnterprisePolicies
(
)
;
log
(
"
Enterprise
Policy
Check
:
"
policyEnableDoH
)
;
if
(
policyEnableDoH
=
=
=
"
no_policy_set
"
)
{
await
this
.
setSetting
(
DOH_SKIP_HEURISTICS_PREF
false
)
;
return
;
}
if
(
policyEnableDoH
=
=
=
"
policy_without_doh
"
)
{
await
stateManager
.
setState
(
"
disabled
"
)
;
}
await
this
.
setSetting
(
DOH_SKIP_HEURISTICS_PREF
true
)
;
browser
.
experiments
.
heuristics
.
sendHeuristicsPing
(
policyEnableDoH
results
)
;
}
async
migrateLocalStoragePrefs
(
)
{
const
isMigrated
=
await
browser
.
experiments
.
preferences
.
getBoolPref
(
DOH_BALROG_MIGRATION_PREF
false
)
;
if
(
isMigrated
)
{
log
(
"
User
has
already
been
migrated
.
"
)
;
return
;
}
const
legacyLocalStorageKeys
=
[
"
doneFirstRun
"
"
skipHeuristicsCheck
"
DOH_PREVIOUS_TRR_MODE_PREF
DOH_DOORHANGER_SHOWN_PREF
DOH_DOORHANGER_USER_DECISION_PREF
DOH_DISABLED_PREF
]
;
for
(
let
item
of
legacyLocalStorageKeys
)
{
let
data
=
await
browser
.
storage
.
local
.
get
(
item
)
;
let
value
=
data
[
item
]
;
log
(
{
context
:
"
migration
"
item
value
}
)
;
if
(
data
.
hasOwnProperty
(
item
)
)
{
let
migratedName
=
item
;
if
(
!
item
.
startsWith
(
"
doh
-
rollout
.
"
)
)
{
migratedName
=
"
doh
-
rollout
.
"
+
item
;
}
await
this
.
setSetting
(
migratedName
value
)
;
}
}
browser
.
experiments
.
preferences
.
setBoolPref
(
DOH_BALROG_MIGRATION_PREF
true
)
;
log
(
"
User
successfully
migrated
.
"
)
;
}
async
init
(
)
{
log
(
"
calling
init
"
)
;
let
doneFirstRun
=
await
this
.
getSetting
(
DOH_DONE_FIRST_RUN_PREF
false
)
;
browser
.
experiments
.
heuristics
.
setupTelemetry
(
)
;
let
results
=
await
runHeuristics
(
)
;
if
(
!
doneFirstRun
)
{
log
(
"
first
run
!
"
)
;
await
this
.
setSetting
(
DOH_DONE_FIRST_RUN_PREF
true
)
;
await
this
.
trrModePrefHasUserValue
(
"
first_run
"
results
)
;
await
this
.
enterprisePolicyCheck
(
"
first_run
"
results
)
;
}
else
{
log
(
"
not
first
run
!
"
)
;
await
this
.
enterprisePolicyCheck
(
"
startup
"
results
)
;
}
if
(
await
stateManager
.
shouldRunHeuristics
(
)
)
{
await
this
.
runStartupHeuristics
(
)
;
}
browser
.
networkStatus
.
onConnectionChanged
.
addListener
(
async
(
)
=
>
{
log
(
"
onConnectionChanged
"
)
;
let
linkInfo
=
await
browser
.
networkStatus
.
getLinkInfo
(
)
;
if
(
linkInfo
.
status
!
=
=
"
up
"
)
{
log
(
"
Link
down
.
"
)
;
if
(
rollout
.
networkSettledTimeout
)
{
log
(
"
Canceling
queued
heuristics
run
.
"
)
;
clearTimeout
(
rollout
.
networkSettledTimeout
)
;
rollout
.
networkSettledTimeout
=
null
;
}
return
;
}
log
(
"
Queing
a
heuristics
run
in
60s
will
cancel
if
network
fluctuates
.
"
)
;
let
gracePeriod
=
(
await
rollout
.
isTesting
(
)
)
?
0
:
60000
;
rollout
.
networkSettledTimeout
=
setTimeout
(
async
(
)
=
>
{
log
(
"
No
network
fluctuation
for
60
seconds
running
heuristics
.
"
)
;
let
shouldRunHeuristics
=
await
stateManager
.
shouldRunHeuristics
(
)
;
let
shouldShowDoorhanger
=
await
stateManager
.
shouldShowDoorhanger
(
)
;
if
(
!
shouldRunHeuristics
)
{
return
;
}
const
netChangeDecision
=
await
rollout
.
heuristics
(
"
netChange
"
)
;
if
(
netChangeDecision
=
=
=
"
disable_doh
"
)
{
await
stateManager
.
setState
(
"
disabled
"
)
;
}
else
if
(
shouldShowDoorhanger
)
{
await
stateManager
.
showDoorHangerAndEnableDoH
(
)
;
}
else
{
await
stateManager
.
setState
(
"
enabled
"
)
;
}
}
gracePeriod
)
;
}
)
;
browser
.
captivePortal
.
onConnectivityAvailable
.
addListener
(
async
(
)
=
>
{
log
(
"
Captive
portal
onConnectivityAvailable
running
heuristics
.
"
)
;
if
(
rollout
.
networkSettledTimeout
)
{
log
(
"
Canceling
queued
heuristics
run
.
"
)
;
clearTimeout
(
rollout
.
networkSettledTimeout
)
;
rollout
.
networkSettledTimeout
=
null
;
}
let
shouldRunHeuristics
=
await
stateManager
.
shouldRunHeuristics
(
)
;
if
(
!
shouldRunHeuristics
)
{
return
;
}
await
this
.
runStartupHeuristics
(
)
;
}
)
;
}
async
runStartupHeuristics
(
)
{
let
decision
=
await
this
.
heuristics
(
"
startup
"
)
;
let
shouldShowDoorhanger
=
await
stateManager
.
shouldShowDoorhanger
(
)
;
if
(
decision
=
=
=
"
disable_doh
"
)
{
await
stateManager
.
setState
(
"
disabled
"
)
;
}
else
if
(
shouldShowDoorhanger
)
{
await
stateManager
.
showDoorHangerAndEnableDoH
(
)
;
}
else
{
await
stateManager
.
setState
(
"
enabled
"
)
;
}
}
}
;
const
setup
=
{
async
start
(
)
{
DEBUG
=
await
browser
.
experiments
.
preferences
.
getBoolPref
(
DOH_DEBUG_PREF
false
)
;
await
rollout
.
migrateLocalStoragePrefs
(
)
;
const
isAddonDisabled
=
await
rollout
.
getSetting
(
DOH_DISABLED_PREF
false
)
;
const
runAddonPref
=
await
rollout
.
getSetting
(
DOH_ENABLED_PREF
false
)
;
const
runAddonBypassPref
=
await
rollout
.
getSetting
(
DOH_SELF_ENABLED_PREF
false
)
;
const
runAddonDoorhangerDecision
=
await
rollout
.
getSetting
(
DOH_DOORHANGER_USER_DECISION_PREF
"
"
)
;
const
runAddonPreviousTRRMode
=
await
rollout
.
getSetting
(
DOH_PREVIOUS_TRR_MODE_PREF
-
1
)
;
if
(
isAddonDisabled
)
{
log
(
"
Addon
has
been
disabled
.
DoH
status
will
not
be
modified
from
current
setting
"
)
;
await
stateManager
.
rememberDisableHeuristics
(
)
;
return
;
}
if
(
runAddonPref
|
|
runAddonBypassPref
|
|
runAddonDoorhangerDecision
=
=
=
"
UIOk
"
|
|
runAddonDoorhangerDecision
=
=
=
"
enabled
"
|
|
runAddonPreviousTRRMode
=
=
=
2
|
|
runAddonPreviousTRRMode
=
=
=
0
)
{
rollout
.
init
(
)
;
}
else
{
log
(
"
Disabled
aborting
!
Watching
doh
-
rollout
.
enabled
pref
for
change
event
"
)
;
browser
.
experiments
.
preferences
.
onPrefChanged
.
addListener
(
function
listener
(
)
{
browser
.
experiments
.
preferences
.
onPrefChanged
.
removeListener
(
listener
)
;
setup
.
start
(
)
;
}
)
;
}
}
}
;
setup
.
start
(
)
;
