"
use
strict
"
;
let
DEBUG
;
async
function
log
(
)
{
if
(
DEBUG
)
{
console
.
log
(
.
.
.
arguments
)
;
}
}
const
DOH_ENABLED_PREF
=
"
doh
-
rollout
.
enabled
"
;
const
NETWORK_TRR_MODE_PREF
=
"
network
.
trr
.
mode
"
;
const
NETWORK_TRR_URI_PREF
=
"
network
.
trr
.
uri
"
;
const
ROLLOUT_TRR_MODE_PREF
=
"
doh
-
rollout
.
mode
"
;
const
DOH_SELF_ENABLED_PREF
=
"
doh
-
rollout
.
self
-
enabled
"
;
const
DOH_DOORHANGER_USER_DECISION_PREF
=
"
doh
-
rollout
.
doorhanger
-
decision
"
;
const
DOH_DISABLED_PREF
=
"
doh
-
rollout
.
disable
-
heuristics
"
;
const
DOH_SKIP_HEURISTICS_PREF
=
"
doh
-
rollout
.
skipHeuristicsCheck
"
;
const
DOH_DONE_FIRST_RUN_PREF
=
"
doh
-
rollout
.
doneFirstRun
"
;
const
DOH_BALROG_MIGRATION_PREF
=
"
doh
-
rollout
.
balrog
-
migration
-
done
"
;
const
DOH_PREVIOUS_TRR_MODE_PREF
=
"
doh
-
rollout
.
previous
.
trr
.
mode
"
;
const
DOH_DEBUG_PREF
=
"
doh
-
rollout
.
debug
"
;
const
stateManager
=
{
async
setState
(
state
)
{
log
(
"
setState
:
"
state
)
;
switch
(
state
)
{
case
"
uninstalled
"
:
break
;
case
"
disabled
"
:
await
rollout
.
setSetting
(
ROLLOUT_TRR_MODE_PREF
0
)
;
break
;
case
"
UIOk
"
:
await
rollout
.
setSetting
(
DOH_SELF_ENABLED_PREF
true
)
;
break
;
case
"
enabled
"
:
await
rollout
.
setSetting
(
ROLLOUT_TRR_MODE_PREF
2
)
;
await
rollout
.
setSetting
(
DOH_SELF_ENABLED_PREF
true
)
;
break
;
case
"
manuallyDisabled
"
:
case
"
UIDisabled
"
:
await
browser
.
experiments
.
preferences
.
clearUserPref
(
DOH_SELF_ENABLED_PREF
)
;
case
"
rollback
"
:
await
browser
.
experiments
.
preferences
.
clearUserPref
(
ROLLOUT_TRR_MODE_PREF
)
;
break
;
}
await
browser
.
experiments
.
heuristics
.
sendStatePing
(
state
)
;
}
async
rememberDisableHeuristics
(
)
{
log
(
"
Remembering
to
never
run
heuristics
again
"
)
;
await
rollout
.
setSetting
(
DOH_DISABLED_PREF
true
)
;
}
async
shouldRunHeuristics
(
)
{
let
disableHeuristics
=
await
rollout
.
getSetting
(
DOH_DISABLED_PREF
false
)
;
let
skipHeuristicsCheck
=
await
rollout
.
getSetting
(
DOH_SKIP_HEURISTICS_PREF
false
)
;
if
(
disableHeuristics
|
|
skipHeuristicsCheck
)
{
log
(
"
shouldRunHeuristics
:
Will
not
run
heuristics
"
)
;
return
false
;
}
return
true
;
}
}
;
const
rollout
=
{
lastNetworkChangeTime
:
0
async
heuristics
(
evaluateReason
)
{
let
shouldRunHeuristics
=
await
stateManager
.
shouldRunHeuristics
(
)
;
if
(
!
shouldRunHeuristics
)
{
return
;
}
let
results
=
await
runHeuristics
(
)
;
let
decision
=
Object
.
values
(
results
)
.
includes
(
"
disable_doh
"
)
?
"
disable_doh
"
:
"
enable_doh
"
;
log
(
"
Heuristics
decision
on
"
+
evaluateReason
+
"
:
"
+
decision
)
;
results
.
evaluateReason
=
evaluateReason
;
browser
.
experiments
.
heuristics
.
sendHeuristicsPing
(
decision
results
)
;
if
(
decision
=
=
=
"
disable_doh
"
)
{
await
stateManager
.
setState
(
"
disabled
"
)
;
}
else
{
await
stateManager
.
setState
(
"
enabled
"
)
;
}
}
async
getSetting
(
name
defaultValue
)
{
let
value
;
switch
(
typeof
defaultValue
)
{
case
"
boolean
"
:
value
=
await
browser
.
experiments
.
preferences
.
getBoolPref
(
name
defaultValue
)
;
break
;
case
"
number
"
:
value
=
await
browser
.
experiments
.
preferences
.
getIntPref
(
name
defaultValue
)
;
break
;
case
"
string
"
:
value
=
await
browser
.
experiments
.
preferences
.
getCharPref
(
name
defaultValue
)
;
break
;
default
:
throw
new
Error
(
Invalid
defaultValue
argument
when
trying
to
fetch
pref
:
{
JSON
.
stringify
(
name
)
}
)
;
}
log
(
{
context
:
"
getSetting
"
type
:
typeof
defaultValue
name
value
}
)
;
return
value
;
}
async
setSetting
(
name
value
)
{
switch
(
typeof
value
)
{
case
"
boolean
"
:
await
browser
.
experiments
.
preferences
.
setBoolPref
(
name
value
)
;
break
;
case
"
number
"
:
await
browser
.
experiments
.
preferences
.
setIntPref
(
name
value
)
;
break
;
case
"
string
"
:
await
browser
.
experiments
.
preferences
.
setCharPref
(
name
value
)
;
break
;
default
:
throw
new
Error
(
"
setSetting
typeof
value
unknown
!
"
)
;
}
log
(
{
context
:
"
setSetting
"
type
:
typeof
value
name
value
}
)
;
}
async
trrPrefUserModifiedCheck
(
)
{
let
modeHasUserValue
=
await
browser
.
experiments
.
preferences
.
prefHasUserValue
(
NETWORK_TRR_MODE_PREF
)
;
let
uriHasUserValue
=
await
browser
.
experiments
.
preferences
.
prefHasUserValue
(
NETWORK_TRR_URI_PREF
)
;
if
(
modeHasUserValue
|
|
uriHasUserValue
)
{
await
stateManager
.
setState
(
"
manuallyDisabled
"
)
;
await
stateManager
.
rememberDisableHeuristics
(
)
;
}
}
async
enterprisePolicyCheck
(
)
{
let
policyEnableDoH
=
await
browser
.
experiments
.
heuristics
.
checkEnterprisePolicies
(
)
;
log
(
"
Enterprise
Policy
Check
:
"
policyEnableDoH
)
;
if
(
policyEnableDoH
=
=
=
"
no_policy_set
"
)
{
await
this
.
setSetting
(
DOH_SKIP_HEURISTICS_PREF
false
)
;
return
;
}
if
(
policyEnableDoH
=
=
=
"
policy_without_doh
"
)
{
await
stateManager
.
setState
(
"
disabled
"
)
;
}
await
this
.
setSetting
(
DOH_SKIP_HEURISTICS_PREF
true
)
;
}
async
migrateLocalStoragePrefs
(
)
{
const
isMigrated
=
await
browser
.
experiments
.
preferences
.
getBoolPref
(
DOH_BALROG_MIGRATION_PREF
false
)
;
if
(
isMigrated
)
{
log
(
"
User
has
already
been
migrated
.
"
)
;
return
;
}
const
legacyLocalStorageKeys
=
[
"
doneFirstRun
"
"
skipHeuristicsCheck
"
DOH_DOORHANGER_USER_DECISION_PREF
DOH_DISABLED_PREF
]
;
for
(
let
item
of
legacyLocalStorageKeys
)
{
let
data
=
await
browser
.
storage
.
local
.
get
(
item
)
;
let
value
=
data
[
item
]
;
log
(
{
context
:
"
migration
"
item
value
}
)
;
if
(
data
.
hasOwnProperty
(
item
)
)
{
let
migratedName
=
item
;
if
(
!
item
.
startsWith
(
"
doh
-
rollout
.
"
)
)
{
migratedName
=
"
doh
-
rollout
.
"
+
item
;
}
await
this
.
setSetting
(
migratedName
value
)
;
}
}
browser
.
experiments
.
preferences
.
setBoolPref
(
DOH_BALROG_MIGRATION_PREF
true
)
;
log
(
"
User
successfully
migrated
.
"
)
;
}
async
migrateOldTrrMode
(
)
{
const
needsMigration
=
await
browser
.
experiments
.
preferences
.
getIntPref
(
DOH_PREVIOUS_TRR_MODE_PREF
-
1
)
;
if
(
needsMigration
=
=
=
-
1
)
{
log
(
"
User
'
s
TRR
mode
prefs
already
migrated
"
)
;
return
;
}
await
browser
.
experiments
.
preferences
.
clearUserPref
(
NETWORK_TRR_MODE_PREF
)
;
await
browser
.
experiments
.
preferences
.
clearUserPref
(
DOH_PREVIOUS_TRR_MODE_PREF
)
;
log
(
"
TRR
mode
prefs
migrated
"
)
;
}
async
init
(
)
{
log
(
"
calling
init
"
)
;
await
this
.
setSetting
(
DOH_DONE_FIRST_RUN_PREF
true
)
;
browser
.
experiments
.
heuristics
.
setupTelemetry
(
)
;
await
this
.
enterprisePolicyCheck
(
)
;
await
this
.
trrPrefUserModifiedCheck
(
)
;
if
(
!
(
await
stateManager
.
shouldRunHeuristics
(
)
)
)
{
return
;
}
await
browser
.
experiments
.
trrselect
.
run
(
)
;
log
(
"
TRR
selection
complete
!
"
)
;
let
networkStatus
=
(
await
browser
.
networkStatus
.
getLinkInfo
(
)
)
.
status
;
let
captiveState
=
"
unknown
"
;
try
{
captiveState
=
await
browser
.
captivePortal
.
getState
(
)
;
}
catch
(
e
)
{
}
if
(
networkStatus
=
=
"
up
"
&
&
captiveState
!
=
"
locked_portal
"
)
{
await
rollout
.
heuristics
(
"
startup
"
)
;
}
browser
.
networkStatus
.
onConnectionChanged
.
addListener
(
rollout
.
onConnectionChanged
)
;
try
{
browser
.
captivePortal
.
onStateChange
.
addListener
(
rollout
.
onCaptiveStateChanged
)
;
}
catch
(
e
)
{
}
browser
.
experiments
.
preferences
.
onTRRPrefChanged
.
addListener
(
async
function
listener
(
)
{
await
stateManager
.
setState
(
"
manuallyDisabled
"
)
;
await
stateManager
.
rememberDisableHeuristics
(
)
;
await
setup
.
stop
(
)
;
browser
.
experiments
.
preferences
.
onTRRPrefChanged
.
removeListener
(
listener
)
;
}
)
;
}
async
onConnectionChanged
(
{
status
}
)
{
log
(
"
onConnectionChanged
"
status
)
;
if
(
status
!
=
"
up
"
)
{
return
;
}
let
captiveState
=
"
unknown
"
;
try
{
captiveState
=
await
browser
.
captivePortal
.
getState
(
)
;
}
catch
(
e
)
{
await
rollout
.
heuristics
(
"
netchange
"
)
;
return
;
}
if
(
captiveState
=
=
"
locked_portal
"
)
{
return
;
}
await
rollout
.
heuristics
(
"
netchange
"
)
;
}
async
onCaptiveStateChanged
(
{
state
}
)
{
log
(
"
onCaptiveStateChanged
"
state
)
;
if
(
state
=
=
"
unlocked_portal
"
|
|
state
=
=
"
not_captive
"
)
{
await
rollout
.
heuristics
(
"
captivechanged
"
)
;
}
}
}
;
const
setup
=
{
async
start
(
)
{
const
isAddonDisabled
=
await
rollout
.
getSetting
(
DOH_DISABLED_PREF
false
)
;
const
runAddonPref
=
await
rollout
.
getSetting
(
DOH_ENABLED_PREF
false
)
;
const
runAddonBypassPref
=
await
rollout
.
getSetting
(
DOH_SELF_ENABLED_PREF
false
)
;
const
runAddonDoorhangerDecision
=
await
rollout
.
getSetting
(
DOH_DOORHANGER_USER_DECISION_PREF
"
"
)
;
if
(
isAddonDisabled
)
{
log
(
"
Addon
has
been
disabled
.
DoH
status
will
not
be
modified
from
current
setting
"
)
;
await
stateManager
.
rememberDisableHeuristics
(
)
;
return
;
}
if
(
runAddonBypassPref
)
{
rollout
.
migrateOldTrrMode
(
)
;
}
if
(
runAddonPref
|
|
runAddonBypassPref
|
|
runAddonDoorhangerDecision
=
=
=
"
UIOk
"
|
|
runAddonDoorhangerDecision
=
=
=
"
enabled
"
)
{
rollout
.
init
(
)
;
}
else
{
log
(
"
Disabled
aborting
!
"
)
;
}
}
async
stop
(
)
{
browser
.
networkStatus
.
onConnectionChanged
.
removeListener
(
rollout
.
onConnectionChanged
)
;
try
{
browser
.
captivePortal
.
onStateChange
.
removeListener
(
rollout
.
onCaptiveStateChanged
)
;
}
catch
(
e
)
{
}
}
}
;
(
async
(
)
=
>
{
DEBUG
=
await
browser
.
experiments
.
preferences
.
getBoolPref
(
DOH_DEBUG_PREF
false
)
;
await
rollout
.
migrateLocalStoragePrefs
(
)
;
await
browser
.
experiments
.
preferences
.
migrateNextDNSEndpoint
(
)
;
log
(
"
Watching
doh
-
rollout
.
enabled
pref
"
)
;
browser
.
experiments
.
preferences
.
onEnabledChanged
.
addListener
(
async
(
)
=
>
{
let
enabled
=
await
rollout
.
getSetting
(
DOH_ENABLED_PREF
false
)
;
if
(
enabled
)
{
setup
.
start
(
)
;
}
else
{
if
(
await
stateManager
.
shouldRunHeuristics
(
)
)
{
await
stateManager
.
setState
(
"
rollback
"
)
;
}
setup
.
stop
(
)
;
}
}
)
;
if
(
await
rollout
.
getSetting
(
DOH_ENABLED_PREF
false
)
)
{
await
setup
.
start
(
)
;
}
else
if
(
(
await
rollout
.
getSetting
(
DOH_DONE_FIRST_RUN_PREF
false
)
)
&
&
(
await
stateManager
.
shouldRunHeuristics
(
)
)
)
{
await
stateManager
.
setState
(
"
rollback
"
)
;
}
}
)
(
)
;
