var
EXPORTED_SYMBOLS
=
[
'
LocalConnectionService
'
]
;
Components
.
utils
.
import
(
'
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
'
)
;
Components
.
utils
.
import
(
'
resource
:
/
/
gre
/
modules
/
Services
.
jsm
'
)
;
const
localConnectionsRegistry
=
Object
.
create
(
null
)
;
function
isConnectionNameValid
(
connectionName
)
{
return
typeof
connectionName
=
=
=
'
string
'
&
&
(
connectionName
[
0
]
=
=
=
'
_
'
|
|
connectionName
.
split
(
'
:
'
)
.
length
=
=
=
2
)
;
}
function
_getQualifiedConnectionName
(
connectionName
swfUrl
)
{
if
(
!
isConnectionNameValid
(
connectionName
)
)
{
throw
new
Error
(
'
Syntactically
invalid
local
-
connection
name
encountered
'
connectionName
swfUrl
)
;
}
var
[
domain
name
]
=
connectionName
.
split
(
'
:
'
)
;
var
parsedURL
=
NetUtil
.
newURI
(
swfUrl
)
;
if
(
domain
!
=
=
parsedURL
.
host
)
{
log
(
'
Warning
:
invalid
local
-
connection
name
qualification
found
:
'
+
connectionName
)
;
return
parsedURL
.
host
+
'
:
'
+
swfUrl
;
}
return
connectionName
;
}
function
_getLocalConnection
(
connectionName
)
{
if
(
!
isConnectionNameValid
(
connectionName
)
)
{
return
null
;
}
var
connection
=
localConnectionsRegistry
[
connectionName
]
;
if
(
connection
&
&
Components
.
utils
.
isDeadWrapper
(
connection
.
callback
)
)
{
delete
localConnectionsRegistry
[
connectionName
]
;
return
null
;
}
return
localConnectionsRegistry
[
connectionName
]
;
}
function
LocalConnectionService
(
content
environment
)
{
var
traceLocalConnection
=
getBoolPref
(
'
shumway
.
localConnection
.
trace
'
false
)
;
var
api
=
{
createLocalConnection
:
function
(
connectionName
callback
)
{
connectionName
=
connectionName
+
'
'
;
traceLocalConnection
&
&
content
.
console
.
log
(
Creating
local
connection
"
{
connectionName
}
"
+
for
SWF
with
URL
{
environment
.
swfUrl
}
)
;
if
(
!
isConnectionNameValid
(
connectionName
)
)
{
traceLocalConnection
&
&
content
.
console
.
warn
(
Invalid
localConnection
name
)
;
return
-
1
;
}
if
(
typeof
callback
!
=
=
'
function
'
)
{
traceLocalConnection
&
&
content
.
console
.
warn
(
Invalid
callback
for
localConnection
)
;
return
-
3
;
}
connectionName
=
_getQualifiedConnectionName
(
connectionName
environment
.
swfUrl
)
;
if
(
_getLocalConnection
(
connectionName
)
)
{
traceLocalConnection
&
&
content
.
console
.
log
(
localConnection
+
name
"
{
connectionName
}
"
already
taken
)
;
return
-
2
;
}
var
parsedURL
=
NetUtil
.
newURI
(
environment
.
swfUrl
)
;
var
connection
=
{
callback
domain
:
parsedURL
.
host
environment
:
environment
secure
:
parsedURL
.
protocol
=
=
=
'
https
:
'
allowedSecureDomains
:
Object
.
create
(
null
)
allowedInsecureDomains
:
Object
.
create
(
null
)
}
;
localConnectionsRegistry
[
connectionName
]
=
connection
;
return
0
;
}
hasLocalConnection
:
function
(
connectionName
)
{
connectionName
=
_getQualifiedConnectionName
(
connectionName
+
'
'
environment
.
swfUrl
)
;
var
result
=
!
!
_getLocalConnection
(
connectionName
)
;
traceLocalConnection
&
&
content
.
console
.
log
(
hasLocalConnection
"
{
connectionName
}
"
?
+
result
)
;
return
result
;
}
closeLocalConnection
:
function
(
connectionName
)
{
connectionName
=
_getQualifiedConnectionName
(
connectionName
+
'
'
environment
.
swfUrl
)
;
traceLocalConnection
&
&
content
.
console
.
log
(
Closing
local
connection
"
{
connectionName
}
"
+
for
SWF
with
URL
{
environment
.
swfUrl
}
)
;
var
connection
=
_getLocalConnection
(
connectionName
)
;
if
(
!
connection
)
{
traceLocalConnection
&
&
content
.
console
.
log
(
localConnection
"
{
connectionName
}
"
not
+
connected
)
;
return
-
1
;
}
else
if
(
connection
.
environment
!
=
=
environment
)
{
traceLocalConnection
&
&
content
.
console
.
warn
(
Ignored
attempt
to
close
localConnection
+
"
{
connectionName
}
"
from
SWF
instance
that
+
didn
'
t
create
it
)
;
return
-
1
;
}
delete
localConnectionsRegistry
[
connectionName
]
;
return
0
;
}
sendLocalConnectionMessage
:
function
(
connectionName
methodName
argsBuffer
sender
senderDomain
senderIsSecure
)
{
connectionName
=
connectionName
+
'
'
;
methodName
=
methodName
+
'
'
;
senderDomain
=
senderDomain
+
'
'
;
senderIsSecure
=
!
!
senderIsSecure
;
traceLocalConnection
&
&
content
.
console
.
log
(
sending
localConnection
message
+
"
{
methodName
}
"
to
"
{
connectionName
}
"
)
;
var
parsedURL
=
NetUtil
.
newURI
(
environment
.
swfUrl
)
;
var
parsedURLIsSecure
=
parsedURL
.
protocol
=
=
=
'
https
:
'
;
if
(
parsedURL
.
host
!
=
=
senderDomain
|
|
parsedURLIsSecure
!
=
=
senderIsSecure
)
{
traceLocalConnection
&
&
content
.
console
.
warn
(
sending
localConnection
message
+
"
{
methodName
}
"
to
"
{
connectionName
}
"
)
;
}
senderDomain
=
parsedURL
.
host
;
senderIsSecure
=
parsedURLIsSecure
;
var
connection
=
_getLocalConnection
(
connectionName
)
;
if
(
!
connection
)
{
traceLocalConnection
&
&
content
.
console
.
log
(
localConnection
"
{
connectionName
}
"
not
+
connected
)
;
return
;
}
try
{
var
allowed
=
false
;
if
(
connection
.
secure
)
{
if
(
senderIsSecure
)
{
if
(
senderDomain
=
=
=
connection
.
domain
|
|
senderDomain
in
connection
.
allowedSecureDomains
|
|
'
*
'
in
connection
.
allowedSecureDomains
)
{
allowed
=
true
;
}
}
else
{
if
(
senderDomain
in
connection
.
allowedInsecureDomains
|
|
'
*
'
in
connection
.
allowedInsecureDomains
)
{
allowed
=
true
;
}
}
}
else
{
if
(
senderDomain
=
=
=
connection
.
domain
|
|
senderDomain
in
connection
.
allowedSecureDomains
|
|
'
*
'
in
connection
.
allowedSecureDomains
)
{
allowed
=
true
;
}
}
if
(
!
allowed
)
{
traceLocalConnection
&
&
content
.
console
.
warn
(
LocalConnection
message
rejected
:
domain
+
{
senderDomain
}
not
allowed
.
)
;
return
{
name
:
'
SecurityError
'
Bgmessage
:
"
The
current
security
context
does
not
allow
this
operation
.
"
_errorID
:
3315
}
;
}
var
callback
=
connection
.
callback
;
var
clonedArgs
=
Components
.
utils
.
cloneInto
(
argsBuffer
callback
)
;
callback
(
methodName
clonedArgs
)
;
}
catch
(
e
)
{
content
.
console
.
warn
(
'
Unexpected
error
encountered
while
sending
LocalConnection
message
.
'
)
;
}
}
allowDomainsForLocalConnection
:
function
(
connectionName
domains
secure
)
{
connectionName
=
_getQualifiedConnectionName
(
connectionName
+
'
'
environment
.
swfUrl
)
;
secure
=
!
!
secure
;
var
connection
=
_getLocalConnection
(
connectionName
)
;
if
(
!
connection
)
{
return
;
}
try
{
domains
=
Components
.
utils
.
cloneInto
(
domains
connection
)
;
}
catch
(
e
)
{
log
(
'
error
in
allowDomainsForLocalConnection
:
'
+
e
)
;
return
;
}
traceLocalConnection
&
&
content
.
console
.
log
(
allowing
{
secure
?
'
'
:
'
in
'
}
secure
domains
+
[
{
domains
}
]
for
localConnection
+
"
{
connectionName
}
"
)
;
function
validateDomain
(
domain
)
{
if
(
typeof
domain
!
=
=
'
string
'
)
{
return
false
;
}
if
(
domain
=
=
=
'
*
'
)
{
return
true
;
}
try
{
var
uri
=
NetUtil
.
newURI
(
'
http
:
/
/
'
+
domain
)
;
return
uri
.
host
=
=
=
domain
;
}
catch
(
e
)
{
return
false
;
}
}
if
(
!
Array
.
isArray
(
domains
)
|
|
!
domains
.
every
(
validateDomain
)
)
{
traceLocalConnection
&
&
content
.
console
.
warn
(
Invalid
domains
rejected
)
;
return
;
}
var
allowedDomains
=
secure
?
connection
.
allowedSecureDomains
:
connection
.
allowedInsecureDomains
;
domains
.
forEach
(
domain
=
>
allowedDomains
[
domain
]
=
true
)
;
}
}
;
return
Components
.
utils
.
cloneInto
(
api
content
{
cloneFunctions
:
true
}
)
;
}
function
getBoolPref
(
pref
def
)
{
try
{
return
Services
.
prefs
.
getBoolPref
(
pref
)
;
}
catch
(
ex
)
{
return
def
;
}
}
