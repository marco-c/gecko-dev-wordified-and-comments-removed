"
use
strict
"
;
const
{
AddonManager
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
sys
.
mjs
"
)
;
const
{
WebRequest
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
WebRequest
.
sys
.
mjs
"
)
;
var
{
ExtensionParent
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
ExtensionParent
.
sys
.
mjs
"
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineESModuleGetters
(
lazy
{
AddonSearchEngine
:
"
moz
-
src
:
/
/
/
toolkit
/
components
/
search
/
AddonSearchEngine
.
sys
.
mjs
"
AppProvidedSearchEngine
:
"
moz
-
src
:
/
/
/
toolkit
/
components
/
search
/
AppProvidedSearchEngine
.
sys
.
mjs
"
}
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
ChannelWrapper
"
"
URLSearchParams
"
]
)
;
const
SEARCH_TOPIC_ENGINE_MODIFIED
=
"
browser
-
search
-
engine
-
modified
"
;
this
.
addonsSearchDetection
=
class
extends
ExtensionAPI
{
getAPI
(
context
)
{
const
{
extension
}
=
context
;
this
.
firstMatchedUrls
=
{
}
;
return
{
addonsSearchDetection
:
{
async
getEngines
(
)
{
const
results
=
[
]
;
try
{
if
(
!
Cu
.
isESModuleLoaded
(
"
resource
:
/
/
gre
/
modules
/
SearchService
.
sys
.
mjs
"
)
)
{
await
ExtensionParent
.
browserPaintedPromise
;
}
if
(
extension
.
hasShutdown
|
|
Services
.
startup
.
shuttingDown
)
{
return
results
;
}
await
Services
.
search
.
promiseInitialized
;
const
engines
=
await
Services
.
search
.
getEngines
(
)
;
for
(
let
engine
of
engines
)
{
if
(
!
(
engine
instanceof
lazy
.
AddonSearchEngine
)
&
&
!
(
engine
instanceof
lazy
.
AppProvidedSearchEngine
)
)
{
continue
;
}
let
submission
=
engine
.
getSubmission
(
"
searchTerm
"
)
;
if
(
submission
)
{
const
uri
=
submission
.
uri
;
const
baseUrl
=
uri
.
prePath
+
uri
.
filePath
;
const
addonId
=
engine
.
wrappedJSObject
.
_extensionID
;
let
paramName
;
for
(
let
[
key
value
]
of
new
URLSearchParams
(
uri
.
query
)
)
{
if
(
value
&
&
value
=
=
=
engine
.
partnerCode
)
{
paramName
=
key
;
}
}
results
.
push
(
{
baseUrl
addonId
paramName
}
)
;
}
}
}
catch
(
err
)
{
console
.
error
(
err
)
;
}
return
results
;
}
async
getAddonVersion
(
addonId
)
{
const
addon
=
await
AddonManager
.
getAddonByID
(
addonId
)
;
return
addon
&
&
addon
.
version
;
}
async
getPublicSuffix
(
url
)
{
try
{
return
Services
.
eTLD
.
getBaseDomain
(
Services
.
io
.
newURI
(
url
)
)
;
}
catch
(
err
)
{
console
.
error
(
err
)
;
return
null
;
}
}
reportSameSiteRedirect
(
extra
)
{
Glean
.
addonsSearchDetection
.
sameSiteRedirect
.
record
(
extra
)
;
}
reportETLDChangeOther
(
extra
)
{
Glean
.
addonsSearchDetection
.
etldChangeOther
.
record
(
extra
)
;
}
reportETLDChangeWebrequest
(
extra
)
{
Glean
.
addonsSearchDetection
.
etldChangeWebrequest
.
record
(
extra
)
;
}
onSearchEngineModified
:
new
ExtensionCommon
.
EventManager
(
{
context
name
:
"
addonsSearchDetection
.
onSearchEngineModified
"
register
:
fire
=
>
{
const
onSearchEngineModifiedObserver
=
(
aSubject
aTopic
aData
)
=
>
{
if
(
aTopic
!
=
=
SEARCH_TOPIC_ENGINE_MODIFIED
|
|
!
[
"
engine
-
added
"
"
engine
-
removed
"
"
engine
-
changed
"
]
.
includes
(
aData
)
)
{
return
;
}
fire
.
async
(
)
;
}
;
Services
.
obs
.
addObserver
(
onSearchEngineModifiedObserver
SEARCH_TOPIC_ENGINE_MODIFIED
)
;
return
(
)
=
>
{
Services
.
obs
.
removeObserver
(
onSearchEngineModifiedObserver
SEARCH_TOPIC_ENGINE_MODIFIED
)
;
}
;
}
}
)
.
api
(
)
onRedirected
:
new
ExtensionCommon
.
EventManager
(
{
context
name
:
"
addonsSearchDetection
.
onRedirected
"
register
:
(
fire
filter
)
=
>
{
const
stopListener
=
event
=
>
{
if
(
event
.
type
!
=
"
stop
"
)
{
return
;
}
const
wrapper
=
event
.
currentTarget
;
const
{
channel
id
:
requestId
}
=
wrapper
;
let
addonId
;
try
{
addonId
=
channel
?
.
QueryInterface
(
Ci
.
nsIPropertyBag
)
?
.
getProperty
(
"
redirectedByExtension
"
)
;
}
catch
(
err
)
{
console
.
error
(
err
)
;
}
const
firstUrl
=
this
.
firstMatchedUrls
[
requestId
]
;
delete
this
.
firstMatchedUrls
[
requestId
]
;
const
lastUrl
=
wrapper
.
finalURL
;
if
(
!
firstUrl
|
|
!
lastUrl
)
{
return
;
}
fire
.
sync
(
{
addonId
firstUrl
lastUrl
}
)
;
}
;
const
remoteTab
=
context
.
xulBrowser
.
frameLoader
.
remoteTab
;
const
listener
=
(
{
requestId
url
originUrl
}
)
=
>
{
if
(
originUrl
!
=
=
undefined
)
{
return
;
}
if
(
!
this
.
firstMatchedUrls
[
requestId
]
)
{
this
.
firstMatchedUrls
[
requestId
]
=
url
;
const
wrapper
=
ChannelWrapper
.
getRegisteredChannel
(
requestId
context
.
extension
.
policy
remoteTab
)
;
wrapper
.
addEventListener
(
"
stop
"
stopListener
)
;
}
}
;
const
ensureRegisterChannel
=
data
=
>
{
data
.
registerTraceableChannel
(
extension
.
policy
remoteTab
)
;
}
;
const
parsedFilter
=
{
types
:
[
"
main_frame
"
]
urls
:
ExtensionUtils
.
parseMatchPatterns
(
filter
.
urls
)
}
;
WebRequest
.
onBeforeRequest
.
addListener
(
ensureRegisterChannel
parsedFilter
[
"
blocking
"
]
{
addonId
:
extension
.
id
policy
:
extension
.
policy
blockingAllowed
:
true
}
)
;
WebRequest
.
onBeforeRedirect
.
addListener
(
listener
parsedFilter
[
]
{
addonId
:
extension
.
id
policy
:
extension
.
policy
blockingAllowed
:
false
}
)
;
return
(
)
=
>
{
WebRequest
.
onBeforeRequest
.
removeListener
(
ensureRegisterChannel
)
;
WebRequest
.
onBeforeRedirect
.
removeListener
(
listener
)
;
}
;
}
}
)
.
api
(
)
}
}
;
}
}
;
