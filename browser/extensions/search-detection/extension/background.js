"
use
strict
"
;
const
TELEMETRY_CATEGORY
=
"
addonsSearchDetection
"
;
const
TELEMETRY_METHOD_ETLD_CHANGE
=
"
etld_change
"
;
const
TELEMETRY_OBJECT_WEBREQUEST
=
"
webrequest
"
;
const
TELEMETRY_OBJECT_OTHER
=
"
other
"
;
const
TELEMETRY_VALUE_EXTENSION
=
"
extension
"
;
const
TELEMETRY_VALUE_SERVER
=
"
server
"
;
class
AddonsSearchDetection
{
constructor
(
)
{
this
.
matchPatterns
=
{
}
;
browser
.
telemetry
.
registerEvents
(
TELEMETRY_CATEGORY
{
[
TELEMETRY_METHOD_ETLD_CHANGE
]
:
{
methods
:
[
TELEMETRY_METHOD_ETLD_CHANGE
]
objects
:
[
TELEMETRY_OBJECT_WEBREQUEST
TELEMETRY_OBJECT_OTHER
]
extra_keys
:
[
"
addonId
"
"
addonVersion
"
"
from
"
"
to
"
]
record_on_release
:
true
}
}
)
;
this
.
onRedirectedListener
=
this
.
onRedirectedListener
.
bind
(
this
)
;
}
async
getMatchPatterns
(
)
{
try
{
this
.
matchPatterns
=
await
browser
.
addonsSearchDetection
.
getMatchPatterns
(
)
;
}
catch
(
err
)
{
console
.
error
(
failed
to
retrieve
the
list
of
URL
patterns
:
{
err
}
)
;
this
.
matchPatterns
=
{
}
;
}
return
this
.
matchPatterns
;
}
async
monitor
(
)
{
if
(
browser
.
addonsSearchDetection
.
onRedirected
.
hasListener
(
this
.
onRedirectedListener
)
)
{
browser
.
addonsSearchDetection
.
onRedirected
.
removeListener
(
this
.
onRedirectedListener
)
;
}
if
(
browser
.
webRequest
.
onBeforeRequest
.
hasListener
(
this
.
noOpListener
)
)
{
browser
.
webRequest
.
onBeforeRequest
.
removeListener
(
this
.
noOpListener
)
;
}
const
matchPatterns
=
await
this
.
getMatchPatterns
(
)
;
const
patterns
=
Object
.
keys
(
matchPatterns
)
;
if
(
patterns
.
length
=
=
=
0
)
{
return
;
}
browser
.
webRequest
.
onBeforeRequest
.
addListener
(
this
.
noOpListener
{
types
:
[
"
main_frame
"
]
urls
:
patterns
}
[
"
blocking
"
]
)
;
browser
.
addonsSearchDetection
.
onRedirected
.
addListener
(
this
.
onRedirectedListener
{
urls
:
patterns
}
)
;
}
noOpListener
(
)
{
}
async
onRedirectedListener
(
{
addonId
firstUrl
lastUrl
}
)
{
const
maybeServerSideRedirect
=
!
addonId
;
let
addonIds
=
[
]
;
if
(
maybeServerSideRedirect
)
{
addonIds
=
this
.
getAddonIdsForUrl
(
firstUrl
)
;
}
else
if
(
addonId
)
{
addonIds
=
[
addonId
]
;
}
if
(
addonIds
.
length
=
=
=
0
)
{
return
;
}
const
from
=
await
browser
.
addonsSearchDetection
.
getPublicSuffix
(
firstUrl
)
;
const
to
=
await
browser
.
addonsSearchDetection
.
getPublicSuffix
(
lastUrl
)
;
if
(
from
=
=
=
to
)
{
return
;
}
const
telemetryObject
=
maybeServerSideRedirect
?
TELEMETRY_OBJECT_OTHER
:
TELEMETRY_OBJECT_WEBREQUEST
;
const
telemetryValue
=
maybeServerSideRedirect
?
TELEMETRY_VALUE_SERVER
:
TELEMETRY_VALUE_EXTENSION
;
for
(
const
id
of
addonIds
)
{
const
addonVersion
=
await
browser
.
addonsSearchDetection
.
getAddonVersion
(
id
)
;
const
extra
=
{
addonId
:
id
addonVersion
from
to
}
;
browser
.
telemetry
.
recordEvent
(
TELEMETRY_CATEGORY
TELEMETRY_METHOD_ETLD_CHANGE
telemetryObject
telemetryValue
extra
)
;
}
}
getAddonIdsForUrl
(
url
)
{
for
(
const
pattern
of
Object
.
keys
(
this
.
matchPatterns
)
)
{
const
urlPrefix
=
pattern
.
slice
(
0
-
1
)
;
if
(
url
.
startsWith
(
urlPrefix
)
)
{
return
this
.
matchPatterns
[
pattern
]
;
}
}
return
[
]
;
}
}
const
exp
=
new
AddonsSearchDetection
(
)
;
exp
.
monitor
(
)
;
browser
.
addonsSearchDetection
.
onSearchEngineModified
.
addListener
(
async
(
)
=
>
{
await
exp
.
monitor
(
)
;
}
)
;
