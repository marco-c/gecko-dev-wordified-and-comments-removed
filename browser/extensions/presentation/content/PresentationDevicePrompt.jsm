"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
PresentationDevicePrompt
"
]
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
Strings
"
function
(
)
{
return
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
presentation
/
locale
/
presentation
.
properties
"
)
;
}
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PermissionUI
"
"
resource
:
/
/
/
modules
/
PermissionUI
.
jsm
"
)
;
function
log
(
aMsg
)
{
}
function
GetString
(
aName
)
{
return
Strings
.
GetStringFromName
(
aName
)
;
}
const
kNotificationId
=
"
presentation
-
device
-
selection
"
;
const
kNotificationPopupIcon
=
"
chrome
:
/
/
presentation
-
shared
/
skin
/
link
.
svg
"
;
const
kNotificationAnchorId
=
"
presentation
-
device
-
notification
-
icon
"
;
const
kNotificationAnchorIcon
=
"
chrome
:
/
/
presentation
-
shared
/
skin
/
link
.
svg
"
;
const
kPopupNotificationId
=
kNotificationId
+
"
-
notification
"
;
function
PresentationPermissionPrompt
(
aRequest
aDevices
)
{
this
.
request
=
aRequest
;
this
.
_isResponded
=
false
;
this
.
_devices
=
aDevices
;
}
PresentationPermissionPrompt
.
prototype
=
{
__proto__
:
PermissionUI
.
PermissionPromptForRequestPrototype
get
browser
(
)
{
return
this
.
request
.
chromeEventHandler
;
}
get
principal
(
)
{
return
this
.
request
.
principal
;
}
get
popupOptions
(
)
{
return
{
removeOnDismissal
:
true
popupIconURL
:
kNotificationPopupIcon
eventCallback
:
(
aTopic
aNewBrowser
)
=
>
{
log
(
"
eventCallback
:
"
+
aTopic
)
;
let
handler
=
{
removed
:
(
)
=
>
{
log
(
"
Prompt
is
removed
.
"
)
;
if
(
!
this
.
_isResponded
)
{
log
(
"
Dismissed
by
user
.
Cancel
the
request
.
"
)
;
this
.
request
.
cancel
(
Cr
.
NS_ERROR_NOT_AVAILABLE
)
;
}
}
showing
:
(
)
=
>
{
log
(
"
Prompt
is
showing
.
"
)
;
}
shown
:
(
)
=
>
{
log
(
"
Prompt
is
shown
.
"
)
;
this
.
_createPopupContent
(
)
;
}
}
;
handler
[
aTopic
]
(
)
;
}
}
;
}
get
notificationID
(
)
{
return
kNotificationId
;
}
get
anchorID
(
)
{
let
chromeDoc
=
this
.
browser
.
ownerDocument
;
let
anchor
=
chromeDoc
.
getElementById
(
kNotificationAnchorId
)
;
if
(
!
anchor
)
{
let
notificationPopupBox
=
chromeDoc
.
getElementById
(
"
notification
-
popup
-
box
"
)
;
let
notificationIcon
=
chromeDoc
.
createElement
(
"
image
"
)
;
notificationIcon
.
id
=
kNotificationAnchorId
;
notificationIcon
.
setAttribute
(
"
src
"
kNotificationAnchorIcon
)
;
notificationIcon
.
classList
.
add
(
"
notification
-
anchor
-
icon
"
)
;
notificationIcon
.
setAttribute
(
"
role
"
"
button
"
)
;
notificationIcon
.
setAttribute
(
"
tooltiptext
"
GetString
(
"
presentation
.
urlbar
.
tooltiptext
"
)
)
;
notificationIcon
.
style
.
setProperty
(
"
-
moz
-
context
-
properties
"
"
fill
"
)
;
notificationIcon
.
style
.
fill
=
"
currentcolor
"
;
notificationIcon
.
style
.
opacity
=
"
0
.
4
"
;
notificationPopupBox
.
appendChild
(
notificationIcon
)
;
}
return
kNotificationAnchorId
;
}
get
message
(
)
{
return
GetString
(
"
presentation
.
message
"
this
.
_domainName
)
;
}
get
promptActions
(
)
{
return
[
{
label
:
GetString
(
"
presentation
.
deviceprompt
.
select
.
label
"
)
accessKey
:
GetString
(
"
presentation
.
deviceprompt
.
select
.
accessKey
"
)
callback
:
(
)
=
>
{
log
(
"
Select
"
)
;
this
.
_isResponded
=
true
;
if
(
!
this
.
_listbox
|
|
!
this
.
_devices
.
length
)
{
log
(
"
No
device
can
be
selected
!
"
)
;
this
.
request
.
cancel
(
Cr
.
NS_ERROR_NOT_AVAILABLE
)
;
return
;
}
let
device
=
this
.
_devices
[
this
.
_listbox
.
selectedIndex
]
;
this
.
request
.
select
(
device
)
;
log
(
"
device
:
"
+
device
.
name
+
"
(
"
+
device
.
id
+
"
)
is
selected
!
"
)
;
}
}
{
label
:
GetString
(
"
presentation
.
deviceprompt
.
cancel
.
label
"
)
accessKey
:
GetString
(
"
presentation
.
deviceprompt
.
cancel
.
accessKey
"
)
callback
:
(
)
=
>
{
log
(
"
Cancel
selection
.
"
)
;
this
.
_isResponded
=
true
;
this
.
request
.
cancel
(
Cr
.
NS_ERROR_NOT_AVAILABLE
)
;
}
dismiss
:
true
}
]
;
}
get
_domainName
(
)
{
if
(
this
.
principal
.
URI
instanceof
Ci
.
nsIFileURL
)
{
return
this
.
principal
.
URI
.
pathQueryRef
.
split
(
"
/
"
)
[
1
]
;
}
return
this
.
principal
.
URI
.
hostPort
;
}
_createPopupContent
(
)
{
log
(
"
_createPopupContent
"
)
;
if
(
!
this
.
_devices
.
length
)
{
log
(
"
No
available
devices
can
be
listed
!
"
)
;
return
;
}
let
chromeDoc
=
this
.
browser
.
ownerDocument
;
let
popupnotification
=
chromeDoc
.
getElementById
(
kPopupNotificationId
)
;
if
(
!
popupnotification
)
{
log
(
"
No
available
popupnotification
element
to
be
inserted
!
"
)
;
return
;
}
let
popupnotificationcontent
=
chromeDoc
.
createElement
(
"
popupnotificationcontent
"
)
;
this
.
_listbox
=
chromeDoc
.
createElement
(
"
richlistbox
"
)
;
this
.
_listbox
.
setAttribute
(
"
flex
"
"
1
"
)
;
this
.
_devices
.
forEach
(
(
device
)
=
>
{
let
listitem
=
chromeDoc
.
createElement
(
"
richlistitem
"
)
;
let
label
=
chromeDoc
.
createElement
(
"
label
"
)
;
label
.
setAttribute
(
"
value
"
device
.
name
)
;
listitem
.
appendChild
(
label
)
;
this
.
_listbox
.
appendChild
(
listitem
)
;
}
)
;
popupnotificationcontent
.
appendChild
(
this
.
_listbox
)
;
popupnotification
.
appendChild
(
popupnotificationcontent
)
;
}
}
;
const
PRESENTATIONDEVICEPROMPT_CONTRACTID
=
"
mozilla
.
org
/
presentation
-
device
/
prompt
;
1
"
;
const
PRESENTATIONDEVICEPROMPT_CID
=
Components
.
ID
(
"
{
388bd149
-
c919
-
4a43
-
b646
-
d7ec57877689
}
"
)
;
function
PresentationDevicePrompt
(
)
{
}
PresentationDevicePrompt
.
prototype
=
{
classID
:
PRESENTATIONDEVICEPROMPT_CID
classDescription
:
"
Presentation
API
Device
Prompt
"
contractID
:
PRESENTATIONDEVICEPROMPT_CONTRACTID
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIPresentationDevicePrompt
]
)
promptDeviceSelection
(
aRequest
)
{
log
(
"
promptDeviceSelection
"
)
;
let
devices
=
this
.
_loadDevices
(
)
;
if
(
!
devices
.
length
)
{
log
(
"
No
available
device
.
"
)
;
aRequest
.
cancel
(
Cr
.
NS_ERROR_NOT_AVAILABLE
)
;
return
;
}
let
promptUI
=
new
PresentationPermissionPrompt
(
aRequest
devices
)
;
promptUI
.
prompt
(
)
;
}
_loadDevices
(
)
{
let
deviceManager
=
Cc
[
"
mozilla
.
org
/
presentation
-
device
/
manager
;
1
"
]
.
getService
(
Ci
.
nsIPresentationDeviceManager
)
;
let
devices
=
deviceManager
.
getAvailableDevices
(
)
.
QueryInterface
(
Ci
.
nsIArray
)
;
let
list
=
[
]
;
for
(
let
i
=
0
;
i
<
devices
.
length
;
i
+
+
)
{
let
device
=
devices
.
queryElementAt
(
i
Ci
.
nsIPresentationDevice
)
;
list
.
push
(
device
)
;
}
return
list
;
}
}
;
