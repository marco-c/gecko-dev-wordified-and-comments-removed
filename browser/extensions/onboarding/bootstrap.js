"
use
strict
"
;
const
{
utils
:
Cu
interfaces
:
Ci
}
=
Components
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
OnboardingTourType
:
"
resource
:
/
/
onboarding
/
modules
/
OnboardingTourType
.
jsm
"
OnboardingTelemetry
:
"
resource
:
/
/
onboarding
/
modules
/
OnboardingTelemetry
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
fxAccounts
:
"
resource
:
/
/
gre
/
modules
/
FxAccounts
.
jsm
"
}
)
;
const
{
PREF_STRING
PREF_BOOL
PREF_INT
}
=
Ci
.
nsIPrefBranch
;
const
BROWSER_READY_NOTIFICATION
=
"
browser
-
delayed
-
startup
-
finished
"
;
const
BROWSER_SESSION_STORE_NOTIFICATION
=
"
sessionstore
-
windows
-
restored
"
;
const
PREF_WHITELIST
=
[
[
"
browser
.
onboarding
.
enabled
"
PREF_BOOL
]
[
"
browser
.
onboarding
.
state
"
PREF_STRING
]
[
"
browser
.
onboarding
.
notification
.
finished
"
PREF_BOOL
]
[
"
browser
.
onboarding
.
notification
.
prompt
-
count
"
PREF_INT
]
[
"
browser
.
onboarding
.
notification
.
last
-
time
-
of
-
changing
-
tour
-
sec
"
PREF_INT
]
[
"
browser
.
onboarding
.
notification
.
tour
-
ids
-
queue
"
PREF_STRING
]
]
;
[
"
onboarding
-
tour
-
addons
"
"
onboarding
-
tour
-
customize
"
"
onboarding
-
tour
-
default
-
browser
"
"
onboarding
-
tour
-
library
"
"
onboarding
-
tour
-
performance
"
"
onboarding
-
tour
-
private
-
browsing
"
"
onboarding
-
tour
-
screenshots
"
"
onboarding
-
tour
-
singlesearch
"
"
onboarding
-
tour
-
sync
"
]
.
forEach
(
tourId
=
>
PREF_WHITELIST
.
push
(
[
browser
.
onboarding
.
tour
.
{
tourId
}
.
completed
PREF_BOOL
]
)
)
;
let
waitingForBrowserReady
=
true
;
let
startupData
;
function
setPrefs
(
prefs
)
{
prefs
.
forEach
(
pref
=
>
{
let
prefObj
=
PREF_WHITELIST
.
find
(
(
[
name
]
)
=
>
name
=
=
pref
.
name
)
;
if
(
!
prefObj
)
{
return
;
}
let
[
name
type
]
=
prefObj
;
switch
(
type
)
{
case
PREF_BOOL
:
Services
.
prefs
.
setBoolPref
(
name
pref
.
value
)
;
break
;
case
PREF_INT
:
Services
.
prefs
.
setIntPref
(
name
pref
.
value
)
;
break
;
case
PREF_STRING
:
Services
.
prefs
.
setStringPref
(
name
pref
.
value
)
;
break
;
default
:
throw
new
TypeError
(
Unexpected
type
(
{
type
}
)
for
preference
{
name
}
.
)
;
}
}
)
;
}
let
syncTourChecker
=
{
_registered
:
false
_loggedIn
:
false
isLoggedIn
(
)
{
return
this
.
_loggedIn
;
}
observe
(
subject
topic
)
{
switch
(
topic
)
{
case
"
fxaccounts
:
onlogin
"
:
this
.
setComplete
(
)
;
break
;
case
"
fxaccounts
:
onlogout
"
:
this
.
_loggedIn
=
false
;
break
;
}
}
init
(
)
{
fxAccounts
.
getSignedInUser
(
)
.
then
(
user
=
>
{
if
(
user
)
{
this
.
setComplete
(
)
;
}
this
.
register
(
)
;
}
)
;
}
register
(
)
{
if
(
this
.
_registered
)
{
return
;
}
Services
.
obs
.
addObserver
(
this
"
fxaccounts
:
onlogin
"
)
;
Services
.
obs
.
addObserver
(
this
"
fxaccounts
:
onlogout
"
)
;
this
.
_registered
=
true
;
}
setComplete
(
)
{
this
.
_loggedIn
=
true
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
onboarding
.
tour
.
onboarding
-
tour
-
sync
.
completed
"
true
)
;
}
unregister
(
)
{
if
(
!
this
.
_registered
)
{
return
;
}
Services
.
obs
.
removeObserver
(
this
"
fxaccounts
:
onlogin
"
)
;
Services
.
obs
.
removeObserver
(
this
"
fxaccounts
:
onlogout
"
)
;
this
.
_registered
=
false
;
}
uninit
(
)
{
this
.
unregister
(
)
;
}
}
;
function
initContentMessageListener
(
)
{
Services
.
mm
.
addMessageListener
(
"
Onboarding
:
OnContentMessage
"
msg
=
>
{
switch
(
msg
.
data
.
action
)
{
case
"
set
-
prefs
"
:
setPrefs
(
msg
.
data
.
params
)
;
break
;
case
"
get
-
login
-
status
"
:
msg
.
target
.
messageManager
.
sendAsyncMessage
(
"
Onboarding
:
ResponseLoginStatus
"
{
isLoggedIn
:
syncTourChecker
.
isLoggedIn
(
)
}
)
;
break
;
case
"
ping
-
centre
"
:
try
{
OnboardingTelemetry
.
process
(
msg
.
data
.
params
.
data
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
break
;
}
}
)
;
}
function
onBrowserReady
(
)
{
waitingForBrowserReady
=
false
;
OnboardingTourType
.
check
(
)
;
OnboardingTelemetry
.
init
(
startupData
)
;
Services
.
mm
.
loadFrameScript
(
"
resource
:
/
/
onboarding
/
onboarding
.
js
"
true
)
;
initContentMessageListener
(
)
;
}
function
observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
BROWSER_READY_NOTIFICATION
:
Services
.
obs
.
removeObserver
(
observe
BROWSER_READY_NOTIFICATION
)
;
onBrowserReady
(
)
;
break
;
case
BROWSER_SESSION_STORE_NOTIFICATION
:
Services
.
obs
.
removeObserver
(
observe
BROWSER_SESSION_STORE_NOTIFICATION
)
;
Services
.
tm
.
idleDispatchToMainThread
(
(
)
=
>
syncTourChecker
.
init
(
)
)
;
break
;
}
}
function
install
(
aData
aReason
)
{
}
function
uninstall
(
aData
aReason
)
{
}
function
startup
(
aData
aReason
)
{
startupData
=
aData
;
if
(
Services
.
startup
.
startingUp
)
{
Services
.
obs
.
addObserver
(
observe
BROWSER_READY_NOTIFICATION
)
;
Services
.
obs
.
addObserver
(
observe
BROWSER_SESSION_STORE_NOTIFICATION
)
;
}
else
{
onBrowserReady
(
)
;
syncTourChecker
.
init
(
)
;
}
}
function
shutdown
(
aData
aReason
)
{
startupData
=
null
;
if
(
waitingForBrowserReady
)
{
Services
.
obs
.
removeObserver
(
observe
BROWSER_READY_NOTIFICATION
)
;
}
syncTourChecker
.
uninit
(
)
;
}
