#
include
"
download_firefox
.
h
"
#
include
<
iostream
>
#
include
<
memory
>
#
include
<
optional
>
#
include
<
string
>
#
include
<
wchar
.
h
>
#
include
<
windows
.
h
>
#
include
<
winhttp
.
h
>
#
include
"
data_sink
.
h
"
static
const
wchar_t
*
user_agent
=
L
"
FirefoxDesktopLauncher
/
0
.
1
.
0
"
;
static
const
DWORD
timeout_ms
=
5000
;
static
const
int
BUFFER_SIZE
=
1
<
<
16
;
static
char
buffer
[
BUFFER_SIZE
]
;
struct
DownloadContext
{
HINTERNET
hsession
;
HINTERNET
hconnection
;
HINTERNET
hrequest
;
DataSink
*
dataSink
;
std
:
:
wstring
contentType
;
HANDLE
eventHandle
;
ErrCode
asyncStatus
;
}
;
std
:
:
optional
<
std
:
:
wstring
>
get_architecture
(
)
{
SYSTEM_INFO
sysinfo
;
GetSystemInfo
(
&
sysinfo
)
;
switch
(
sysinfo
.
wProcessorArchitecture
)
{
case
PROCESSOR_ARCHITECTURE_AMD64
:
return
L
"
win64
"
;
case
PROCESSOR_ARCHITECTURE_INTEL
:
return
L
"
win
"
;
case
PROCESSOR_ARCHITECTURE_ARM64
:
return
L
"
win64
-
aarch64
"
;
default
:
return
std
:
:
nullopt
;
}
}
std
:
:
optional
<
std
:
:
wstring
>
get_object_name
(
)
{
wchar_t
locale_name
[
LOCALE_NAME_MAX_LENGTH
]
{
}
;
int
ct
=
GetUserDefaultLocaleName
(
locale_name
sizeof
locale_name
)
;
if
(
ct
=
=
0
)
{
return
std
:
:
nullopt
;
}
std
:
:
wstring
lang
=
locale_name
;
std
:
:
optional
<
std
:
:
wstring
>
arch
=
get_architecture
(
)
;
if
(
!
arch
.
has_value
(
)
)
{
return
std
:
:
nullopt
;
}
#
if
defined
(
MOZ_BRANDING_IS_OFFICIAL
)
std
:
:
wstring
product
=
L
"
firefox
-
stub
"
;
#
elif
defined
(
MOZ_BRANDING_IS_NIGHTLY
)
std
:
:
wstring
product
=
L
"
firefox
-
nightly
-
latest
-
ssl
"
;
#
elif
defined
(
MOZ_BRANDING_IS_BETA
)
std
:
:
wstring
product
=
L
"
firefox
-
beta
-
latest
-
ssl
"
;
#
elif
defined
(
MOZ_BRANDING_IS_DEVEDITION
)
std
:
:
wstring
product
=
L
"
firefox
-
devedition
-
latest
-
ssl
"
;
#
elif
defined
(
MOZ_BRANDING_IS_UNOFFICIAL
)
std
:
:
wstring
product
=
L
"
firefox
-
nightly
-
latest
-
ssl
"
;
#
else
static_assert
(
false
)
;
#
endif
return
L
"
https
:
/
/
download
.
mozilla
.
org
/
?
os
=
"
+
arch
.
value
(
)
+
L
"
&
lang
=
"
+
lang
+
L
"
&
product
=
"
+
product
;
}
static
void
exitCallback
(
DownloadContext
*
context
ErrCode
exitStatus
)
{
context
-
>
asyncStatus
=
exitStatus
;
WinHttpSetStatusCallback
(
context
-
>
hrequest
nullptr
WINHTTP_CALLBACK_FLAG_ALL_NOTIFICATIONS
NULL
)
;
SetEvent
(
context
-
>
eventHandle
)
;
}
static
void
CALLBACK
AsyncHttpStatusCallback
(
HINTERNET
hInternet
DWORD_PTR
dwContext
DWORD
dwInternetStatus
void
*
lpvStatusInformation
DWORD
dwStatusInformationLength
)
{
DownloadContext
*
context
=
(
DownloadContext
*
)
dwContext
;
DWORD
dwCount
=
0
;
DWORD
dwResponseStatus
;
wchar_t
contentTypeBuf
[
256
]
{
}
;
switch
(
dwInternetStatus
)
{
case
WINHTTP_CALLBACK_STATUS_SENDREQUEST_COMPLETE
:
if
(
!
WinHttpReceiveResponse
(
context
-
>
hrequest
nullptr
)
)
{
exitCallback
(
context
ErrCode
:
:
ERR_RECEIVE
)
;
}
break
;
case
WINHTTP_CALLBACK_STATUS_HEADERS_AVAILABLE
:
{
dwCount
=
sizeof
(
DWORD
)
;
if
(
!
WinHttpQueryHeaders
(
context
-
>
hrequest
WINHTTP_QUERY_STATUS_CODE
|
WINHTTP_QUERY_FLAG_NUMBER
WINHTTP_HEADER_NAME_BY_INDEX
&
dwResponseStatus
&
dwCount
WINHTTP_NO_HEADER_INDEX
)
)
{
exitCallback
(
context
ErrCode
:
:
ERR_HEADER
)
;
return
;
}
if
(
dwResponseStatus
!
=
200
)
{
if
(
dwResponseStatus
=
=
404
)
{
exitCallback
(
context
ErrCode
:
:
ERR_FILE_NOT_FOUND
)
;
}
else
if
(
dwResponseStatus
>
=
400
&
&
dwResponseStatus
<
500
)
{
exitCallback
(
context
ErrCode
:
:
ERR_CLIENT_REQUEST
)
;
}
else
{
exitCallback
(
context
ErrCode
:
:
ERR_SERVER
)
;
}
return
;
}
dwCount
=
sizeof
contentTypeBuf
;
if
(
!
WinHttpQueryHeaders
(
context
-
>
hrequest
WINHTTP_QUERY_CONTENT_TYPE
WINHTTP_HEADER_NAME_BY_INDEX
contentTypeBuf
&
dwCount
WINHTTP_NO_HEADER_INDEX
)
)
{
exitCallback
(
context
ErrCode
:
:
ERR_HEADER
)
;
return
;
}
if
(
!
WinHttpQueryDataAvailable
(
context
-
>
hrequest
nullptr
)
)
{
exitCallback
(
context
ErrCode
:
:
ERR_QUERY_DATA
)
;
}
}
break
;
case
WINHTTP_CALLBACK_STATUS_DATA_AVAILABLE
:
dwCount
=
*
(
(
DWORD
*
)
lpvStatusInformation
)
;
if
(
dwCount
=
=
0
)
{
exitCallback
(
context
ErrCode
:
:
OK
)
;
return
;
}
if
(
dwCount
>
sizeof
buffer
)
{
dwCount
=
sizeof
buffer
;
}
ZeroMemory
(
buffer
sizeof
buffer
)
;
if
(
!
WinHttpReadData
(
context
-
>
hrequest
buffer
dwCount
nullptr
)
)
{
exitCallback
(
context
ErrCode
:
:
ERR_READ_DATA
)
;
}
break
;
case
WINHTTP_CALLBACK_STATUS_READ_COMPLETE
:
dwCount
=
dwStatusInformationLength
;
if
(
!
context
-
>
dataSink
-
>
accept
(
(
char
*
)
lpvStatusInformation
dwCount
)
)
{
exitCallback
(
context
ErrCode
:
:
ERR_FILE
)
;
}
else
if
(
!
WinHttpQueryDataAvailable
(
context
-
>
hrequest
nullptr
)
)
{
exitCallback
(
context
ErrCode
:
:
ERR_QUERY_DATA
)
;
}
break
;
case
WINHTTP_CALLBACK_STATUS_REQUEST_ERROR
:
exitCallback
(
context
ErrCode
:
:
ERR_REQUEST_INVALID
)
;
break
;
}
}
ErrCode
download_file
(
DataSink
*
dataSink
std
:
:
wstring
server_name
int
server_port
bool
is_https
std
:
:
wstring
object_name
std
:
:
wstring
contentType
)
{
DownloadContext
context
{
}
;
context
.
asyncStatus
=
ErrCode
:
:
UNKNOWN
;
context
.
dataSink
=
dataSink
;
context
.
contentType
=
contentType
;
const
wchar_t
*
accept_types
[
]
=
{
contentType
.
c_str
(
)
nullptr
}
;
context
.
eventHandle
=
CreateEventW
(
nullptr
false
false
nullptr
)
;
if
(
!
context
.
eventHandle
)
{
return
ErrCode
:
:
ERR_EVENT
;
}
context
.
hsession
=
WinHttpOpen
(
user_agent
WINHTTP_ACCESS_TYPE_AUTOMATIC_PROXY
WINHTTP_NO_PROXY_NAME
WINHTTP_NO_PROXY_BYPASS
is_https
?
WINHTTP_FLAG_SECURE_DEFAULTS
:
WINHTTP_FLAG_ASYNC
)
;
if
(
context
.
hsession
=
=
nullptr
)
{
return
ErrCode
:
:
ERR_OPEN
;
}
context
.
hconnection
=
WinHttpConnect
(
context
.
hsession
server_name
.
c_str
(
)
server_port
0
)
;
if
(
!
context
.
hconnection
)
{
return
ErrCode
:
:
ERR_CONNECT
;
}
context
.
hrequest
=
WinHttpOpenRequest
(
context
.
hconnection
L
"
GET
"
object_name
.
c_str
(
)
nullptr
WINHTTP_NO_REFERER
accept_types
is_https
?
WINHTTP_FLAG_SECURE
:
0
)
;
if
(
!
context
.
hrequest
)
{
return
ErrCode
:
:
ERR_OPEN_REQ
;
}
WINHTTP_STATUS_CALLBACK
statusCallback
=
AsyncHttpStatusCallback
;
if
(
WinHttpSetStatusCallback
(
context
.
hrequest
statusCallback
WINHTTP_CALLBACK_FLAG_ALL_NOTIFICATIONS
NULL
)
=
=
WINHTTP_INVALID_STATUS_CALLBACK
)
{
return
ErrCode
:
:
ERR_SET_CALLBACK
;
}
if
(
!
WinHttpSendRequest
(
context
.
hrequest
WINHTTP_NO_ADDITIONAL_HEADERS
0
WINHTTP_NO_REQUEST_DATA
0
0
(
DWORD_PTR
)
&
context
)
)
{
return
ErrCode
:
:
ERR_SEND
;
}
ErrCode
result
;
if
(
WaitForSingleObject
(
context
.
eventHandle
timeout_ms
)
=
=
WAIT_OBJECT_0
)
{
result
=
context
.
asyncStatus
;
}
else
{
result
=
ErrCode
:
:
ERR_TIMEOUT
;
}
return
result
;
}
static
const
wchar_t
*
server_name
=
L
"
download
.
mozilla
.
org
"
;
static
const
wchar_t
*
installer_content_type
=
L
"
application
/
x
-
msdos
-
program
"
;
static
const
int
standard_server_port
=
INTERNET_DEFAULT_HTTPS_PORT
;
static
const
bool
standard_is_https
=
true
;
ErrCode
download_firefox
(
DataSink
*
dataSink
)
{
std
:
:
optional
<
std
:
:
wstring
>
object_name_opt
=
get_object_name
(
)
;
std
:
:
wstring
object_name
;
if
(
object_name_opt
.
has_value
(
)
)
{
object_name
=
object_name_opt
.
value
(
)
;
}
else
{
return
ErrCode
:
:
ERR_ENVIRON
;
}
return
download_file
(
dataSink
server_name
standard_server_port
standard_is_https
object_name
installer_content_type
)
;
}
