#
include
"
nsWindowsDllInterceptor
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
BinarySearch
.
h
"
#
include
"
mozilla
/
ImportDir
.
h
"
#
include
"
mozilla
/
NativeNt
.
h
"
#
include
"
mozilla
/
Types
.
h
"
#
include
"
mozilla
/
WindowsDllBlocklist
.
h
"
#
include
"
mozilla
/
WinHeaderOnlyUtils
.
h
"
#
include
"
DllBlocklistInit
.
h
"
#
include
"
freestanding
/
DllBlocklist
.
h
"
#
if
defined
(
_MSC_VER
)
extern
"
C
"
IMAGE_DOS_HEADER
__ImageBase
;
#
endif
namespace
mozilla
{
#
if
defined
(
MOZ_ASAN
)
|
|
defined
(
_M_ARM64
)
LauncherVoidResultWithLineInfo
InitializeDllBlocklistOOP
(
const
wchar_t
*
aFullImagePath
HANDLE
aChildProcess
)
{
return
mozilla
:
:
Ok
(
)
;
}
LauncherVoidResultWithLineInfo
InitializeDllBlocklistOOPFromLauncher
(
const
wchar_t
*
aFullImagePath
HANDLE
aChildProcess
)
{
return
mozilla
:
:
Ok
(
)
;
}
#
else
static
LauncherVoidResultWithLineInfo
InitializeDllBlocklistOOPInternal
(
const
wchar_t
*
aFullImagePath
HANDLE
aChildProcess
)
{
CrossProcessDllInterceptor
intcpt
(
aChildProcess
)
;
intcpt
.
Init
(
L
"
ntdll
.
dll
"
)
;
bool
ok
=
freestanding
:
:
stub_NtMapViewOfSection
.
SetDetour
(
aChildProcess
intcpt
"
NtMapViewOfSection
"
&
freestanding
:
:
patched_NtMapViewOfSection
)
;
if
(
!
ok
)
{
return
LAUNCHER_ERROR_GENERIC
(
)
;
}
ok
=
freestanding
:
:
stub_LdrLoadDll
.
SetDetour
(
aChildProcess
intcpt
"
LdrLoadDll
"
&
freestanding
:
:
patched_LdrLoadDll
)
;
if
(
!
ok
)
{
return
LAUNCHER_ERROR_GENERIC
(
)
;
}
HMODULE
ourModule
;
#
if
defined
(
_MSC_VER
)
ourModule
=
reinterpret_cast
<
HMODULE
>
(
&
__ImageBase
)
;
#
else
ourModule
=
:
:
GetModuleHandleW
(
nullptr
)
;
#
endif
mozilla
:
:
nt
:
:
PEHeaders
ourExeImage
(
ourModule
)
;
if
(
!
ourExeImage
)
{
return
LAUNCHER_ERROR_FROM_WIN32
(
ERROR_BAD_EXE_FORMAT
)
;
}
LauncherVoidResult
importDirRestored
=
RestoreImportDirectory
(
aFullImagePath
ourExeImage
aChildProcess
ourModule
)
;
if
(
importDirRestored
.
isErr
(
)
)
{
return
importDirRestored
;
}
Maybe
<
Span
<
IMAGE_THUNK_DATA
>
>
ntdllThunks
=
ourExeImage
.
GetIATThunksForModule
(
"
ntdll
.
dll
"
)
;
if
(
!
ntdllThunks
)
{
return
LAUNCHER_ERROR_FROM_WIN32
(
ERROR_INVALID_DATA
)
;
}
SIZE_T
bytesWritten
;
{
PIMAGE_THUNK_DATA
firstIatThunk
=
ntdllThunks
.
value
(
)
.
data
(
)
;
SIZE_T
iatLength
=
ntdllThunks
.
value
(
)
.
LengthBytes
(
)
;
AutoVirtualProtect
prot
(
firstIatThunk
iatLength
PAGE_READWRITE
aChildProcess
)
;
if
(
!
prot
)
{
return
LAUNCHER_ERROR_FROM_MOZ_WINDOWS_ERROR
(
prot
.
GetError
(
)
)
;
}
ok
=
!
!
:
:
WriteProcessMemory
(
aChildProcess
firstIatThunk
firstIatThunk
iatLength
&
bytesWritten
)
;
if
(
!
ok
|
|
bytesWritten
!
=
iatLength
)
{
return
LAUNCHER_ERROR_FROM_LAST
(
)
;
}
}
uint32_t
newFlags
=
eDllBlocklistInitFlagWasBootstrapped
;
if
(
gBlocklistInitFlags
&
eDllBlocklistInitFlagWasBootstrapped
)
{
newFlags
|
=
eDllBlocklistInitFlagIsChildProcess
;
}
ok
=
!
!
:
:
WriteProcessMemory
(
aChildProcess
&
gBlocklistInitFlags
&
newFlags
sizeof
(
newFlags
)
&
bytesWritten
)
;
if
(
!
ok
|
|
bytesWritten
!
=
sizeof
(
newFlags
)
)
{
return
LAUNCHER_ERROR_FROM_LAST
(
)
;
}
return
Ok
(
)
;
}
LauncherVoidResultWithLineInfo
InitializeDllBlocklistOOP
(
const
wchar_t
*
aFullImagePath
HANDLE
aChildProcess
)
{
if
(
!
(
gBlocklistInitFlags
&
eDllBlocklistInitFlagWasBootstrapped
)
)
{
return
Ok
(
)
;
}
return
InitializeDllBlocklistOOPInternal
(
aFullImagePath
aChildProcess
)
;
}
LauncherVoidResultWithLineInfo
InitializeDllBlocklistOOPFromLauncher
(
const
wchar_t
*
aFullImagePath
HANDLE
aChildProcess
)
{
return
InitializeDllBlocklistOOPInternal
(
aFullImagePath
aChildProcess
)
;
}
#
endif
}
