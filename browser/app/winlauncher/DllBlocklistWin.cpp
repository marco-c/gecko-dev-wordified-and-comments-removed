#
include
"
nsWindowsDllInterceptor
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
BinarySearch
.
h
"
#
include
"
mozilla
/
ImportDir
.
h
"
#
include
"
mozilla
/
NativeNt
.
h
"
#
include
"
mozilla
/
Types
.
h
"
#
include
"
mozilla
/
WindowsDllBlocklist
.
h
"
#
include
"
mozilla
/
WinHeaderOnlyUtils
.
h
"
#
define
MOZ_LITERAL_UNICODE_STRING
(
s
)
\
{
\
/
*
Length
of
the
string
in
bytes
less
the
null
terminator
*
/
\
sizeof
(
s
)
-
sizeof
(
wchar_t
)
\
/
*
Length
of
the
string
in
bytes
including
the
null
terminator
*
/
\
sizeof
(
s
)
\
/
*
Pointer
to
the
buffer
*
/
\
const_cast
<
wchar_t
*
>
(
s
)
\
}
#
define
DLL_BLOCKLIST_ENTRY
(
name
.
.
.
)
\
{
MOZ_LITERAL_UNICODE_STRING
(
L
#
#
name
)
__VA_ARGS__
}
#
define
DLL_BLOCKLIST_STRING_TYPE
UNICODE_STRING
#
if
defined
(
MOZ_LAUNCHER_PROCESS
)
|
|
defined
(
NIGHTLY_BUILD
)
#
include
"
mozilla
/
WindowsDllBlocklistLauncherDefs
.
h
"
#
else
#
include
"
mozilla
/
WindowsDllBlocklistCommon
.
h
"
DLL_BLOCKLIST_DEFINITIONS_BEGIN
DLL_BLOCKLIST_DEFINITIONS_END
#
endif
extern
uint32_t
gBlocklistInitFlags
;
static
const
HANDLE
kCurrentProcess
=
reinterpret_cast
<
HANDLE
>
(
-
1
)
;
class
MOZ_STATIC_CLASS
MOZ_TRIVIAL_CTOR_DTOR
NativeNtBlockSet
final
{
struct
NativeNtBlockSetEntry
{
NativeNtBlockSetEntry
(
)
=
default
;
~
NativeNtBlockSetEntry
(
)
=
default
;
NativeNtBlockSetEntry
(
const
UNICODE_STRING
&
aName
uint64_t
aVersion
NativeNtBlockSetEntry
*
aNext
)
:
mName
(
aName
)
mVersion
(
aVersion
)
mNext
(
aNext
)
{
}
UNICODE_STRING
mName
;
uint64_t
mVersion
;
NativeNtBlockSetEntry
*
mNext
;
}
;
public
:
NativeNtBlockSet
(
)
=
default
;
~
NativeNtBlockSet
(
)
=
default
;
void
Add
(
const
UNICODE_STRING
&
aName
uint64_t
aVersion
)
;
void
Write
(
HANDLE
aFile
)
;
private
:
static
NativeNtBlockSetEntry
*
NewEntry
(
const
UNICODE_STRING
&
aName
uint64_t
aVersion
NativeNtBlockSetEntry
*
aNextEntry
)
;
private
:
NativeNtBlockSetEntry
*
mFirstEntry
;
SRWLOCK
mLock
;
}
;
NativeNtBlockSet
:
:
NativeNtBlockSetEntry
*
NativeNtBlockSet
:
:
NewEntry
(
const
UNICODE_STRING
&
aName
uint64_t
aVersion
NativeNtBlockSet
:
:
NativeNtBlockSetEntry
*
aNextEntry
)
{
HANDLE
processHeap
=
mozilla
:
:
nt
:
:
RtlGetProcessHeap
(
)
;
if
(
!
processHeap
)
{
return
nullptr
;
}
PVOID
memory
=
:
:
RtlAllocateHeap
(
processHeap
0
sizeof
(
NativeNtBlockSetEntry
)
)
;
if
(
!
memory
)
{
return
nullptr
;
}
return
new
(
memory
)
NativeNtBlockSetEntry
(
aName
aVersion
aNextEntry
)
;
}
void
NativeNtBlockSet
:
:
Add
(
const
UNICODE_STRING
&
aName
uint64_t
aVersion
)
{
:
:
RtlAcquireSRWLockExclusive
(
&
mLock
)
;
for
(
NativeNtBlockSetEntry
*
entry
=
mFirstEntry
;
entry
;
entry
=
entry
-
>
mNext
)
{
if
(
:
:
RtlEqualUnicodeString
(
&
entry
-
>
mName
&
aName
TRUE
)
&
&
aVersion
=
=
entry
-
>
mVersion
)
{
:
:
RtlReleaseSRWLockExclusive
(
&
mLock
)
;
return
;
}
}
NativeNtBlockSetEntry
*
newEntry
=
NewEntry
(
aName
aVersion
mFirstEntry
)
;
mFirstEntry
=
newEntry
;
:
:
RtlReleaseSRWLockExclusive
(
&
mLock
)
;
}
void
NativeNtBlockSet
:
:
Write
(
HANDLE
aFile
)
{
DWORD
nBytes
;
char
buf
[
MAX_PATH
]
;
:
:
AcquireSRWLockExclusive
(
&
mLock
)
;
MOZ_SEH_TRY
{
for
(
auto
entry
=
mFirstEntry
;
entry
;
entry
=
entry
-
>
mNext
)
{
int
convOk
=
:
:
WideCharToMultiByte
(
CP_UTF8
0
entry
-
>
mName
.
Buffer
entry
-
>
mName
.
Length
/
sizeof
(
wchar_t
)
buf
sizeof
(
buf
)
nullptr
nullptr
)
;
if
(
!
convOk
)
{
continue
;
}
if
(
!
WriteFile
(
aFile
buf
convOk
&
nBytes
nullptr
)
)
{
continue
;
}
if
(
entry
-
>
mVersion
!
=
DllBlockInfo
:
:
ALL_VERSIONS
)
{
WriteFile
(
aFile
"
"
1
&
nBytes
nullptr
)
;
uint16_t
parts
[
4
]
;
parts
[
0
]
=
entry
-
>
mVersion
>
>
48
;
parts
[
1
]
=
(
entry
-
>
mVersion
>
>
32
)
&
0xFFFF
;
parts
[
2
]
=
(
entry
-
>
mVersion
>
>
16
)
&
0xFFFF
;
parts
[
3
]
=
entry
-
>
mVersion
&
0xFFFF
;
for
(
size_t
p
=
0
;
p
<
mozilla
:
:
ArrayLength
(
parts
)
;
+
+
p
)
{
ltoa
(
parts
[
p
]
buf
10
)
;
WriteFile
(
aFile
buf
strlen
(
buf
)
&
nBytes
nullptr
)
;
if
(
p
!
=
mozilla
:
:
ArrayLength
(
parts
)
-
1
)
{
WriteFile
(
aFile
"
.
"
1
&
nBytes
nullptr
)
;
}
}
}
WriteFile
(
aFile
"
;
"
1
&
nBytes
nullptr
)
;
}
}
MOZ_SEH_EXCEPT
(
EXCEPTION_EXECUTE_HANDLER
)
{
}
:
:
ReleaseSRWLockExclusive
(
&
mLock
)
;
}
static
NativeNtBlockSet
gBlockSet
;
extern
"
C
"
void
MOZ_EXPORT
NativeNtBlockSet_Write
(
HANDLE
aHandle
)
{
gBlockSet
.
Write
(
aHandle
)
;
}
static
bool
CheckBlockInfo
(
const
DllBlockInfo
*
aInfo
void
*
aBaseAddress
uint64_t
&
aVersion
)
{
aVersion
=
DllBlockInfo
:
:
ALL_VERSIONS
;
if
(
aInfo
-
>
mFlags
&
(
DllBlockInfo
:
:
BLOCK_WIN8PLUS_ONLY
|
DllBlockInfo
:
:
BLOCK_WIN8_ONLY
)
)
{
RTL_OSVERSIONINFOW
osv
=
{
sizeof
(
osv
)
}
;
NTSTATUS
ntStatus
=
:
:
RtlGetVersion
(
&
osv
)
;
if
(
!
NT_SUCCESS
(
ntStatus
)
)
{
return
false
;
}
if
(
osv
.
dwMajorVersion
<
8
)
{
return
true
;
}
if
(
(
aInfo
-
>
mFlags
&
DllBlockInfo
:
:
BLOCK_WIN8_ONLY
)
&
&
(
osv
.
dwMajorVersion
>
8
|
|
(
osv
.
dwMajorVersion
=
=
8
&
&
osv
.
dwMinorVersion
>
0
)
)
)
{
return
true
;
}
}
if
(
aInfo
-
>
mFlags
&
DllBlockInfo
:
:
CHILD_PROCESSES_ONLY
)
{
return
true
;
}
if
(
aInfo
-
>
mMaxVersion
=
=
DllBlockInfo
:
:
ALL_VERSIONS
)
{
return
false
;
}
mozilla
:
:
nt
:
:
PEHeaders
headers
(
aBaseAddress
)
;
if
(
!
headers
)
{
return
false
;
}
if
(
aInfo
-
>
mFlags
&
DllBlockInfo
:
:
USE_TIMESTAMP
)
{
DWORD
timestamp
;
if
(
!
headers
.
GetTimeStamp
(
timestamp
)
)
{
return
false
;
}
return
timestamp
>
aInfo
-
>
mMaxVersion
;
}
if
(
!
headers
.
GetVersionInfo
(
aVersion
)
)
{
return
false
;
}
return
!
aInfo
-
>
IsVersionBlocked
(
aVersion
)
;
}
struct
DllBlockInfoComparator
{
explicit
DllBlockInfoComparator
(
const
UNICODE_STRING
&
aTarget
)
:
mTarget
(
&
aTarget
)
{
}
int
operator
(
)
(
const
DllBlockInfo
&
aVal
)
const
{
return
static_cast
<
int
>
(
:
:
RtlCompareUnicodeString
(
mTarget
&
aVal
.
mName
TRUE
)
)
;
}
PCUNICODE_STRING
mTarget
;
}
;
static
bool
IsDllAllowed
(
const
UNICODE_STRING
&
aLeafName
void
*
aBaseAddress
)
{
if
(
mozilla
:
:
nt
:
:
Contains12DigitHexString
(
aLeafName
)
|
|
mozilla
:
:
nt
:
:
IsFileNameAtLeast16HexDigits
(
aLeafName
)
)
{
return
false
;
}
DECLARE_POINTER_TO_FIRST_DLL_BLOCKLIST_ENTRY
(
info
)
;
DECLARE_DLL_BLOCKLIST_NUM_ENTRIES
(
infoNumEntries
)
;
DllBlockInfoComparator
comp
(
aLeafName
)
;
size_t
match
;
if
(
!
BinarySearchIf
(
info
0
infoNumEntries
comp
&
match
)
)
{
return
true
;
}
const
DllBlockInfo
&
entry
=
info
[
match
]
;
uint64_t
version
;
if
(
!
CheckBlockInfo
(
&
entry
aBaseAddress
version
)
)
{
gBlockSet
.
Add
(
entry
.
mName
version
)
;
return
false
;
}
return
true
;
}
typedef
decltype
(
&
NtMapViewOfSection
)
NtMapViewOfSection_func
;
static
mozilla
:
:
CrossProcessDllInterceptor
:
:
FuncHookType
<
NtMapViewOfSection_func
>
stub_NtMapViewOfSection
;
static
NTSTATUS
NTAPI
patched_NtMapViewOfSection
(
HANDLE
aSection
HANDLE
aProcess
PVOID
*
aBaseAddress
ULONG_PTR
aZeroBits
SIZE_T
aCommitSize
PLARGE_INTEGER
aSectionOffset
PSIZE_T
aViewSize
SECTION_INHERIT
aInheritDisposition
ULONG
aAllocationType
ULONG
aProtectionFlags
)
{
NTSTATUS
stubStatus
=
stub_NtMapViewOfSection
(
aSection
aProcess
aBaseAddress
aZeroBits
aCommitSize
aSectionOffset
aViewSize
aInheritDisposition
aAllocationType
aProtectionFlags
)
;
if
(
!
NT_SUCCESS
(
stubStatus
)
)
{
return
stubStatus
;
}
if
(
aProcess
!
=
kCurrentProcess
)
{
return
stubStatus
;
}
MEMORY_BASIC_INFORMATION
mbi
;
NTSTATUS
ntStatus
=
:
:
NtQueryVirtualMemory
(
aProcess
*
aBaseAddress
MemoryBasicInformation
&
mbi
sizeof
(
mbi
)
nullptr
)
;
if
(
!
NT_SUCCESS
(
ntStatus
)
)
{
:
:
NtUnmapViewOfSection
(
aProcess
*
aBaseAddress
)
;
return
STATUS_ACCESS_DENIED
;
}
if
(
!
(
mbi
.
Type
&
MEM_IMAGE
)
)
{
return
stubStatus
;
}
mozilla
:
:
nt
:
:
MemorySectionNameBuf
buf
;
ntStatus
=
:
:
NtQueryVirtualMemory
(
aProcess
*
aBaseAddress
MemorySectionName
&
buf
sizeof
(
buf
)
nullptr
)
;
if
(
!
NT_SUCCESS
(
ntStatus
)
)
{
:
:
NtUnmapViewOfSection
(
aProcess
*
aBaseAddress
)
;
return
STATUS_ACCESS_DENIED
;
}
UNICODE_STRING
leaf
;
mozilla
:
:
nt
:
:
GetLeafName
(
&
leaf
&
buf
.
mSectionFileName
)
;
if
(
IsDllAllowed
(
leaf
*
aBaseAddress
)
)
{
return
stubStatus
;
}
:
:
NtUnmapViewOfSection
(
aProcess
*
aBaseAddress
)
;
return
STATUS_ACCESS_DENIED
;
}
#
if
defined
(
_MSC_VER
)
extern
"
C
"
IMAGE_DOS_HEADER
__ImageBase
;
#
endif
namespace
mozilla
{
LauncherVoidResult
InitializeDllBlocklistOOP
(
const
wchar_t
*
aFullImagePath
HANDLE
aChildProcess
)
{
mozilla
:
:
CrossProcessDllInterceptor
intcpt
(
aChildProcess
)
;
intcpt
.
Init
(
L
"
ntdll
.
dll
"
)
;
bool
ok
=
stub_NtMapViewOfSection
.
SetDetour
(
aChildProcess
intcpt
"
NtMapViewOfSection
"
&
patched_NtMapViewOfSection
)
;
if
(
!
ok
)
{
return
LAUNCHER_ERROR_GENERIC
(
)
;
}
HMODULE
ourModule
;
#
if
defined
(
_MSC_VER
)
ourModule
=
reinterpret_cast
<
HMODULE
>
(
&
__ImageBase
)
;
#
else
ourModule
=
:
:
GetModuleHandleW
(
nullptr
)
;
#
endif
mozilla
:
:
nt
:
:
PEHeaders
ourExeImage
(
ourModule
)
;
if
(
!
ourExeImage
)
{
return
LAUNCHER_ERROR_FROM_WIN32
(
ERROR_BAD_EXE_FORMAT
)
;
}
LauncherVoidResult
importDirRestored
=
RestoreImportDirectory
(
aFullImagePath
ourExeImage
aChildProcess
ourModule
)
;
if
(
importDirRestored
.
isErr
(
)
)
{
return
importDirRestored
;
}
Maybe
<
nt
:
:
PEHeaders
:
:
IATThunks
>
ntdllThunks
=
ourExeImage
.
GetIATThunksForModule
(
"
ntdll
.
dll
"
)
;
if
(
!
ntdllThunks
)
{
return
LAUNCHER_ERROR_FROM_WIN32
(
ERROR_INVALID_DATA
)
;
}
PIMAGE_THUNK_DATA
firstIatThunk
=
ntdllThunks
.
value
(
)
.
mFirstThunk
;
SIZE_T
iatLength
=
ntdllThunks
.
value
(
)
.
Length
(
)
;
SIZE_T
bytesWritten
;
{
AutoVirtualProtect
prot
(
firstIatThunk
iatLength
PAGE_READWRITE
aChildProcess
)
;
if
(
!
prot
)
{
return
LAUNCHER_ERROR_FROM_MOZ_WINDOWS_ERROR
(
prot
.
GetError
(
)
)
;
}
ok
=
!
!
:
:
WriteProcessMemory
(
aChildProcess
firstIatThunk
firstIatThunk
iatLength
&
bytesWritten
)
;
if
(
!
ok
|
|
bytesWritten
!
=
iatLength
)
{
return
LAUNCHER_ERROR_FROM_LAST
(
)
;
}
}
uint32_t
newFlags
=
eDllBlocklistInitFlagWasBootstrapped
;
ok
=
!
!
:
:
WriteProcessMemory
(
aChildProcess
&
gBlocklistInitFlags
&
newFlags
sizeof
(
newFlags
)
&
bytesWritten
)
;
if
(
!
ok
|
|
bytesWritten
!
=
sizeof
(
newFlags
)
)
{
return
LAUNCHER_ERROR_FROM_LAST
(
)
;
}
return
Ok
(
)
;
}
}
