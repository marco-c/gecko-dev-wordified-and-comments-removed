#
include
"
NativeNt
.
h
"
#
include
"
nsWindowsDllInterceptor
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Types
.
h
"
#
include
"
mozilla
/
WindowsDllBlocklist
.
h
"
#
define
DLL_BLOCKLIST_ENTRY
(
name
.
.
.
)
\
{
L
#
#
name
__VA_ARGS__
}
#
define
DLL_BLOCKLIST_CHAR_TYPE
wchar_t
#
if
defined
(
NIGHTLY_BUILD
)
#
include
"
mozilla
/
WindowsDllBlocklistDefs
.
h
"
#
else
#
include
"
mozilla
/
WindowsDllBlocklistCommon
.
h
"
DLL_BLOCKLIST_DEFINITIONS_BEGIN
DLL_BLOCKLIST_DEFINITIONS_END
#
endif
extern
uint32_t
gBlocklistInitFlags
;
static
const
HANDLE
kCurrentProcess
=
reinterpret_cast
<
HANDLE
>
(
-
1
)
;
class
MOZ_STATIC_CLASS
MOZ_TRIVIAL_CTOR_DTOR
NativeNtBlockSet
final
{
struct
NativeNtBlockSetEntry
{
NativeNtBlockSetEntry
(
)
=
default
;
~
NativeNtBlockSetEntry
(
)
=
default
;
NativeNtBlockSetEntry
(
const
wchar_t
*
aName
uint64_t
aVersion
NativeNtBlockSetEntry
*
aNext
)
:
mName
(
aName
)
mVersion
(
aVersion
)
mNext
(
aNext
)
{
}
const
wchar_t
*
mName
;
uint64_t
mVersion
;
NativeNtBlockSetEntry
*
mNext
;
}
;
public
:
NativeNtBlockSet
(
)
=
default
;
~
NativeNtBlockSet
(
)
=
default
;
void
Add
(
const
wchar_t
*
aName
uint64_t
aVersion
)
;
void
Write
(
HANDLE
aFile
)
;
private
:
static
NativeNtBlockSetEntry
*
NewEntry
(
const
wchar_t
*
aName
uint64_t
aVersion
NativeNtBlockSetEntry
*
aNextEntry
)
;
private
:
NativeNtBlockSetEntry
*
mFirstEntry
;
SRWLOCK
mLock
;
}
;
NativeNtBlockSet
:
:
NativeNtBlockSetEntry
*
NativeNtBlockSet
:
:
NewEntry
(
const
wchar_t
*
aName
uint64_t
aVersion
NativeNtBlockSet
:
:
NativeNtBlockSetEntry
*
aNextEntry
)
{
HANDLE
processHeap
=
mozilla
:
:
nt
:
:
RtlGetProcessHeap
(
)
;
if
(
!
processHeap
)
{
return
nullptr
;
}
PVOID
memory
=
:
:
RtlAllocateHeap
(
processHeap
0
sizeof
(
NativeNtBlockSetEntry
)
)
;
if
(
!
memory
)
{
return
nullptr
;
}
return
new
(
memory
)
NativeNtBlockSetEntry
(
aName
aVersion
aNextEntry
)
;
}
void
NativeNtBlockSet
:
:
Add
(
const
wchar_t
*
aName
uint64_t
aVersion
)
{
:
:
RtlAcquireSRWLockExclusive
(
&
mLock
)
;
for
(
NativeNtBlockSetEntry
*
entry
=
mFirstEntry
;
entry
;
entry
=
entry
-
>
mNext
)
{
if
(
aName
=
=
entry
-
>
mName
&
&
aVersion
=
=
entry
-
>
mVersion
)
{
:
:
RtlReleaseSRWLockExclusive
(
&
mLock
)
;
return
;
}
}
NativeNtBlockSetEntry
*
newEntry
=
NewEntry
(
aName
aVersion
mFirstEntry
)
;
mFirstEntry
=
newEntry
;
:
:
RtlReleaseSRWLockExclusive
(
&
mLock
)
;
}
void
NativeNtBlockSet
:
:
Write
(
HANDLE
aFile
)
{
DWORD
nBytes
;
char
buf
[
MAX_PATH
]
;
:
:
AcquireSRWLockExclusive
(
&
mLock
)
;
MOZ_SEH_TRY
{
for
(
auto
entry
=
mFirstEntry
;
entry
;
entry
=
entry
-
>
mNext
)
{
int
convOk
=
:
:
WideCharToMultiByte
(
CP_UTF8
0
entry
-
>
mName
-
1
buf
sizeof
(
buf
)
nullptr
nullptr
)
;
if
(
!
convOk
)
{
continue
;
}
if
(
!
WriteFile
(
aFile
buf
convOk
&
nBytes
nullptr
)
)
{
continue
;
}
if
(
entry
-
>
mVersion
!
=
ALL_VERSIONS
)
{
WriteFile
(
aFile
"
"
1
&
nBytes
nullptr
)
;
uint16_t
parts
[
4
]
;
parts
[
0
]
=
entry
-
>
mVersion
>
>
48
;
parts
[
1
]
=
(
entry
-
>
mVersion
>
>
32
)
&
0xFFFF
;
parts
[
2
]
=
(
entry
-
>
mVersion
>
>
16
)
&
0xFFFF
;
parts
[
3
]
=
entry
-
>
mVersion
&
0xFFFF
;
for
(
size_t
p
=
0
;
p
<
mozilla
:
:
ArrayLength
(
parts
)
;
+
+
p
)
{
ltoa
(
parts
[
p
]
buf
10
)
;
WriteFile
(
aFile
buf
strlen
(
buf
)
&
nBytes
nullptr
)
;
if
(
p
!
=
mozilla
:
:
ArrayLength
(
parts
)
-
1
)
{
WriteFile
(
aFile
"
.
"
1
&
nBytes
nullptr
)
;
}
}
}
WriteFile
(
aFile
"
;
"
1
&
nBytes
nullptr
)
;
}
}
MOZ_SEH_EXCEPT
(
EXCEPTION_EXECUTE_HANDLER
)
{
}
:
:
ReleaseSRWLockExclusive
(
&
mLock
)
;
}
static
NativeNtBlockSet
gBlockSet
;
extern
"
C
"
void
MOZ_EXPORT
NativeNtBlockSet_Write
(
HANDLE
aHandle
)
{
gBlockSet
.
Write
(
aHandle
)
;
}
static
bool
CheckBlockInfo
(
const
DllBlockInfo
*
aInfo
void
*
aBaseAddress
uint64_t
&
aVersion
)
{
aVersion
=
ALL_VERSIONS
;
if
(
aInfo
-
>
flags
&
(
DllBlockInfo
:
:
BLOCK_WIN8PLUS_ONLY
|
DllBlockInfo
:
:
BLOCK_WIN8_ONLY
)
)
{
RTL_OSVERSIONINFOW
osv
;
NTSTATUS
ntStatus
=
:
:
RtlGetVersion
(
&
osv
)
;
if
(
!
NT_SUCCESS
(
ntStatus
)
)
{
return
false
;
}
if
(
osv
.
dwMajorVersion
<
8
)
{
return
true
;
}
if
(
(
aInfo
-
>
flags
&
DllBlockInfo
:
:
BLOCK_WIN8_ONLY
)
&
&
(
osv
.
dwMajorVersion
>
8
|
|
(
osv
.
dwMajorVersion
=
=
8
&
&
osv
.
dwMinorVersion
>
0
)
)
)
{
return
true
;
}
}
if
(
aInfo
-
>
flags
&
DllBlockInfo
:
:
CHILD_PROCESSES_ONLY
)
{
return
true
;
}
if
(
aInfo
-
>
maxVersion
=
=
ALL_VERSIONS
)
{
return
false
;
}
mozilla
:
:
nt
:
:
PEHeaders
headers
(
aBaseAddress
)
;
if
(
!
headers
)
{
return
false
;
}
if
(
aInfo
-
>
flags
&
DllBlockInfo
:
:
USE_TIMESTAMP
)
{
DWORD
timestamp
;
if
(
!
headers
.
GetTimeStamp
(
timestamp
)
)
{
return
false
;
}
return
timestamp
>
aInfo
-
>
maxVersion
;
}
if
(
!
headers
.
GetVersionInfo
(
aVersion
)
)
{
return
false
;
}
return
aVersion
>
aInfo
-
>
maxVersion
;
}
static
bool
IsDllAllowed
(
const
UNICODE_STRING
&
aLeafName
void
*
aBaseAddress
)
{
if
(
mozilla
:
:
nt
:
:
Contains12DigitHexString
(
aLeafName
)
|
|
mozilla
:
:
nt
:
:
IsFileNameAtLeast16HexDigits
(
aLeafName
)
)
{
return
false
;
}
UNICODE_STRING
testStr
;
DECLARE_POINTER_TO_FIRST_DLL_BLOCKLIST_ENTRY
(
info
)
;
while
(
info
-
>
name
)
{
:
:
RtlInitUnicodeString
(
&
testStr
info
-
>
name
)
;
if
(
:
:
RtlEqualUnicodeString
(
&
aLeafName
&
testStr
TRUE
)
)
{
break
;
}
+
+
info
;
}
uint64_t
version
;
if
(
info
-
>
name
&
&
!
CheckBlockInfo
(
info
aBaseAddress
version
)
)
{
gBlockSet
.
Add
(
info
-
>
name
version
)
;
return
false
;
}
return
true
;
}
typedef
decltype
(
&
NtMapViewOfSection
)
NtMapViewOfSection_func
;
static
NtMapViewOfSection_func
stub_NtMapViewOfSection
;
static
NTSTATUS
NTAPI
patched_NtMapViewOfSection
(
HANDLE
aSection
HANDLE
aProcess
PVOID
*
aBaseAddress
ULONG_PTR
aZeroBits
SIZE_T
aCommitSize
PLARGE_INTEGER
aSectionOffset
PSIZE_T
aViewSize
SECTION_INHERIT
aInheritDisposition
ULONG
aAllocationType
ULONG
aProtectionFlags
)
{
NTSTATUS
stubStatus
=
stub_NtMapViewOfSection
(
aSection
aProcess
aBaseAddress
aZeroBits
aCommitSize
aSectionOffset
aViewSize
aInheritDisposition
aAllocationType
aProtectionFlags
)
;
if
(
!
NT_SUCCESS
(
stubStatus
)
)
{
return
stubStatus
;
}
if
(
aProcess
!
=
kCurrentProcess
)
{
return
stubStatus
;
}
MEMORY_BASIC_INFORMATION
mbi
;
NTSTATUS
ntStatus
=
:
:
NtQueryVirtualMemory
(
aProcess
*
aBaseAddress
MemoryBasicInformation
&
mbi
sizeof
(
mbi
)
nullptr
)
;
if
(
!
NT_SUCCESS
(
ntStatus
)
)
{
:
:
NtUnmapViewOfSection
(
aProcess
*
aBaseAddress
)
;
return
STATUS_ACCESS_DENIED
;
}
if
(
!
(
mbi
.
Type
&
MEM_IMAGE
)
)
{
return
stubStatus
;
}
mozilla
:
:
nt
:
:
MemorySectionNameBuf
buf
;
ntStatus
=
:
:
NtQueryVirtualMemory
(
aProcess
*
aBaseAddress
MemorySectionName
&
buf
sizeof
(
buf
)
nullptr
)
;
if
(
!
NT_SUCCESS
(
ntStatus
)
)
{
:
:
NtUnmapViewOfSection
(
aProcess
*
aBaseAddress
)
;
return
STATUS_ACCESS_DENIED
;
}
UNICODE_STRING
leaf
;
mozilla
:
:
nt
:
:
GetLeafName
(
&
leaf
&
buf
.
mSectionFileName
)
;
if
(
IsDllAllowed
(
leaf
*
aBaseAddress
)
)
{
return
stubStatus
;
}
:
:
NtUnmapViewOfSection
(
aProcess
*
aBaseAddress
)
;
return
STATUS_ACCESS_DENIED
;
}
namespace
mozilla
{
class
MOZ_RAII
AutoVirtualProtect
final
{
public
:
AutoVirtualProtect
(
void
*
aAddress
size_t
aLength
DWORD
aProtFlags
HANDLE
aTargetProcess
=
nullptr
)
:
mAddress
(
aAddress
)
mLength
(
aLength
)
mTargetProcess
(
aTargetProcess
)
mPrevProt
(
0
)
{
:
:
VirtualProtectEx
(
aTargetProcess
aAddress
aLength
aProtFlags
&
mPrevProt
)
;
}
~
AutoVirtualProtect
(
)
{
if
(
!
mPrevProt
)
{
return
;
}
:
:
VirtualProtectEx
(
mTargetProcess
mAddress
mLength
mPrevProt
&
mPrevProt
)
;
}
explicit
operator
bool
(
)
const
{
return
!
!
mPrevProt
;
}
AutoVirtualProtect
(
const
AutoVirtualProtect
&
)
=
delete
;
AutoVirtualProtect
(
AutoVirtualProtect
&
&
)
=
delete
;
AutoVirtualProtect
&
operator
=
(
const
AutoVirtualProtect
&
)
=
delete
;
AutoVirtualProtect
&
operator
=
(
AutoVirtualProtect
&
&
)
=
delete
;
private
:
void
*
mAddress
;
size_t
mLength
;
HANDLE
mTargetProcess
;
DWORD
mPrevProt
;
}
;
bool
InitializeDllBlocklistOOP
(
HANDLE
aChildProcess
)
{
mozilla
:
:
CrossProcessDllInterceptor
intcpt
(
aChildProcess
)
;
intcpt
.
Init
(
L
"
ntdll
.
dll
"
)
;
bool
ok
=
intcpt
.
AddDetour
(
"
NtMapViewOfSection
"
reinterpret_cast
<
intptr_t
>
(
&
patched_NtMapViewOfSection
)
(
void
*
*
)
&
stub_NtMapViewOfSection
)
;
if
(
!
ok
)
{
return
false
;
}
SIZE_T
bytesWritten
;
ok
=
!
!
:
:
WriteProcessMemory
(
aChildProcess
&
stub_NtMapViewOfSection
&
stub_NtMapViewOfSection
sizeof
(
stub_NtMapViewOfSection
)
&
bytesWritten
)
;
if
(
!
ok
)
{
return
false
;
}
mozilla
:
:
nt
:
:
PEHeaders
ourExeImage
(
:
:
GetModuleHandleW
(
nullptr
)
)
;
if
(
!
ourExeImage
)
{
return
false
;
}
PIMAGE_IMPORT_DESCRIPTOR
impDesc
=
ourExeImage
.
GetIATForModule
(
"
ntdll
.
dll
"
)
;
if
(
!
impDesc
)
{
return
false
;
}
auto
firstIatThunk
=
ourExeImage
.
template
RVAToPtr
<
PIMAGE_THUNK_DATA
>
(
impDesc
-
>
FirstThunk
)
;
if
(
!
firstIatThunk
)
{
return
false
;
}
PIMAGE_THUNK_DATA
curIatThunk
=
firstIatThunk
;
while
(
mozilla
:
:
nt
:
:
PEHeaders
:
:
IsValid
(
curIatThunk
)
)
{
+
+
curIatThunk
;
}
ptrdiff_t
iatLength
=
(
curIatThunk
-
firstIatThunk
)
*
sizeof
(
IMAGE_THUNK_DATA
)
;
{
AutoVirtualProtect
prot
(
firstIatThunk
iatLength
PAGE_READWRITE
aChildProcess
)
;
if
(
!
prot
)
{
return
false
;
}
ok
=
!
!
:
:
WriteProcessMemory
(
aChildProcess
firstIatThunk
firstIatThunk
iatLength
&
bytesWritten
)
;
if
(
!
ok
)
{
return
false
;
}
}
uint32_t
newFlags
=
eDllBlocklistInitFlagWasBootstrapped
;
ok
=
!
!
:
:
WriteProcessMemory
(
aChildProcess
&
gBlocklistInitFlags
&
newFlags
sizeof
(
newFlags
)
&
bytesWritten
)
;
return
ok
;
}
}
