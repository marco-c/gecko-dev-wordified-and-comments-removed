#
include
"
LoaderPrivateAPI
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Types
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
.
.
/
DllBlocklistInit
.
h
"
#
include
"
.
.
/
ErrorHandler
.
h
"
#
include
"
SharedSection
.
h
"
using
GlobalInitializerFn
=
void
(
__cdecl
*
)
(
void
)
;
#
pragma
section
(
"
.
freestd
a
"
read
)
__declspec
(
allocate
(
"
.
freestd
a
"
)
)
static
const
GlobalInitializerFn
FreeStdStart
=
reinterpret_cast
<
GlobalInitializerFn
>
(
0
)
;
#
pragma
section
(
"
.
freestd
z
"
read
)
__declspec
(
allocate
(
"
.
freestd
z
"
)
)
static
const
GlobalInitializerFn
FreeStdEnd
=
reinterpret_cast
<
GlobalInitializerFn
>
(
0
)
;
namespace
mozilla
{
namespace
freestanding
{
static
RTL_RUN_ONCE
gRunOnce
=
RTL_RUN_ONCE_INIT
;
static
ULONG
NTAPI
DoOneTimeInit
(
PRTL_RUN_ONCE
aRunOnce
PVOID
aParameter
PVOID
*
aContext
)
{
const
GlobalInitializerFn
*
cur
=
&
FreeStdStart
+
1
;
while
(
cur
<
&
FreeStdEnd
)
{
if
(
*
cur
)
{
(
*
cur
)
(
)
;
}
+
+
cur
;
}
return
TRUE
;
}
class
MOZ_ONLY_USED_TO_AVOID_STATIC_CONSTRUCTORS
DefaultLoaderObserver
final
:
public
nt
:
:
LoaderObserver
{
public
:
constexpr
DefaultLoaderObserver
(
)
:
mModuleLoads
(
nullptr
)
{
}
void
OnBeginDllLoad
(
void
*
*
aContext
PCUNICODE_STRING
aRequestedDllName
)
final
{
}
bool
SubstituteForLSP
(
PCUNICODE_STRING
aLSPLeafName
PHANDLE
aOutHandle
)
final
{
return
false
;
}
void
OnEndDllLoad
(
void
*
aContext
NTSTATUS
aNtStatus
ModuleLoadInfo
&
&
aModuleLoadInfo
)
final
;
void
Forward
(
nt
:
:
LoaderObserver
*
aNext
)
final
;
void
OnForward
(
ModuleLoadInfoVec
&
&
aInfo
)
final
{
MOZ_ASSERT_UNREACHABLE
(
"
Not
valid
in
freestanding
:
:
DefaultLoaderObserver
"
)
;
}
private
:
mozilla
:
:
nt
:
:
SRWLock
mLock
;
ModuleLoadInfoVec
*
mModuleLoads
;
}
;
class
MOZ_ONLY_USED_TO_AVOID_STATIC_CONSTRUCTORS
LoaderPrivateAPIImp
final
:
public
LoaderPrivateAPI
{
public
:
ModuleLoadInfo
ConstructAndNotifyBeginDllLoad
(
void
*
*
aContext
PCUNICODE_STRING
aRequestedDllName
)
final
;
bool
SubstituteForLSP
(
PCUNICODE_STRING
aLSPLeafName
PHANDLE
aOutHandle
)
final
;
void
NotifyEndDllLoad
(
void
*
aContext
NTSTATUS
aLoadNtStatus
ModuleLoadInfo
&
&
aModuleLoadInfo
)
final
;
nt
:
:
AllocatedUnicodeString
GetSectionName
(
void
*
aSectionAddr
)
final
;
nt
:
:
LoaderAPI
:
:
InitDllBlocklistOOPFnPtr
GetDllBlocklistInitFn
(
)
final
;
nt
:
:
LoaderAPI
:
:
HandleLauncherErrorFnPtr
GetHandleLauncherErrorFn
(
)
final
;
nt
:
:
SharedSection
*
GetSharedSection
(
)
final
;
void
NotifyBeginDllLoad
(
void
*
*
aContext
PCUNICODE_STRING
aRequestedDllName
)
final
;
void
NotifyBeginDllLoad
(
ModuleLoadInfo
&
aModuleLoadInfo
void
*
*
aContext
PCUNICODE_STRING
aRequestedDllName
)
final
;
void
SetObserver
(
nt
:
:
LoaderObserver
*
aNewObserver
)
final
;
bool
IsDefaultObserver
(
)
const
final
;
nt
:
:
MemorySectionNameBuf
GetSectionNameBuffer
(
void
*
aSectionAddr
)
final
;
}
;
static
void
Init
(
)
{
DebugOnly
<
NTSTATUS
>
ntStatus
=
:
:
RtlRunOnceExecuteOnce
(
&
gRunOnce
&
DoOneTimeInit
nullptr
nullptr
)
;
MOZ_ASSERT
(
NT_SUCCESS
(
ntStatus
)
)
;
}
}
}
static
mozilla
:
:
freestanding
:
:
DefaultLoaderObserver
gDefaultObserver
;
static
mozilla
:
:
freestanding
:
:
LoaderPrivateAPIImp
gPrivateAPI
;
static
mozilla
:
:
nt
:
:
SRWLock
gLoaderObserverLock
;
static
mozilla
:
:
nt
:
:
LoaderObserver
*
gLoaderObserver
=
&
gDefaultObserver
;
namespace
mozilla
{
namespace
freestanding
{
LoaderPrivateAPI
&
gLoaderPrivateAPI
=
gPrivateAPI
;
void
DefaultLoaderObserver
:
:
OnEndDllLoad
(
void
*
aContext
NTSTATUS
aNtStatus
ModuleLoadInfo
&
&
aModuleLoadInfo
)
{
if
(
!
NT_SUCCESS
(
aNtStatus
)
|
|
!
aModuleLoadInfo
.
WasMapped
(
)
)
{
return
;
}
nt
:
:
AutoExclusiveLock
lock
(
mLock
)
;
if
(
!
mModuleLoads
)
{
mModuleLoads
=
RtlNew
<
ModuleLoadInfoVec
>
(
)
;
if
(
!
mModuleLoads
)
{
return
;
}
}
Unused
<
<
mModuleLoads
-
>
emplaceBack
(
std
:
:
forward
<
ModuleLoadInfo
>
(
aModuleLoadInfo
)
)
;
}
void
DefaultLoaderObserver
:
:
Forward
(
nt
:
:
LoaderObserver
*
aNext
)
{
MOZ_ASSERT
(
aNext
)
;
if
(
!
aNext
)
{
return
;
}
ModuleLoadInfoVec
*
moduleLoads
=
nullptr
;
{
nt
:
:
AutoExclusiveLock
lock
(
mLock
)
;
moduleLoads
=
mModuleLoads
;
mModuleLoads
=
nullptr
;
}
if
(
!
moduleLoads
)
{
return
;
}
aNext
-
>
OnForward
(
std
:
:
move
(
*
moduleLoads
)
)
;
RtlDelete
(
moduleLoads
)
;
}
ModuleLoadInfo
LoaderPrivateAPIImp
:
:
ConstructAndNotifyBeginDllLoad
(
void
*
*
aContext
PCUNICODE_STRING
aRequestedDllName
)
{
ModuleLoadInfo
loadInfo
(
aRequestedDllName
)
;
NotifyBeginDllLoad
(
loadInfo
aContext
aRequestedDllName
)
;
return
loadInfo
;
}
bool
LoaderPrivateAPIImp
:
:
SubstituteForLSP
(
PCUNICODE_STRING
aLSPLeafName
PHANDLE
aOutHandle
)
{
nt
:
:
AutoSharedLock
lock
(
gLoaderObserverLock
)
;
return
gLoaderObserver
-
>
SubstituteForLSP
(
aLSPLeafName
aOutHandle
)
;
}
void
LoaderPrivateAPIImp
:
:
NotifyEndDllLoad
(
void
*
aContext
NTSTATUS
aLoadNtStatus
ModuleLoadInfo
&
&
aModuleLoadInfo
)
{
aModuleLoadInfo
.
SetEndLoadTimeStamp
(
)
;
if
(
NT_SUCCESS
(
aLoadNtStatus
)
)
{
aModuleLoadInfo
.
CaptureBacktrace
(
)
;
}
nt
:
:
AutoSharedLock
lock
(
gLoaderObserverLock
)
;
gLoaderObserver
-
>
OnEndDllLoad
(
aContext
aLoadNtStatus
std
:
:
move
(
aModuleLoadInfo
)
)
;
}
nt
:
:
AllocatedUnicodeString
LoaderPrivateAPIImp
:
:
GetSectionName
(
void
*
aSectionAddr
)
{
const
HANDLE
kCurrentProcess
=
reinterpret_cast
<
HANDLE
>
(
-
1
)
;
nt
:
:
MemorySectionNameBuf
buf
;
NTSTATUS
ntStatus
=
:
:
NtQueryVirtualMemory
(
kCurrentProcess
aSectionAddr
MemorySectionName
&
buf
sizeof
(
buf
)
nullptr
)
;
if
(
!
NT_SUCCESS
(
ntStatus
)
)
{
return
nt
:
:
AllocatedUnicodeString
(
)
;
}
return
nt
:
:
AllocatedUnicodeString
(
&
buf
.
mSectionFileName
)
;
}
nt
:
:
LoaderAPI
:
:
InitDllBlocklistOOPFnPtr
LoaderPrivateAPIImp
:
:
GetDllBlocklistInitFn
(
)
{
return
&
InitializeDllBlocklistOOP
;
}
nt
:
:
LoaderAPI
:
:
HandleLauncherErrorFnPtr
LoaderPrivateAPIImp
:
:
GetHandleLauncherErrorFn
(
)
{
return
&
HandleLauncherError
;
}
nt
:
:
SharedSection
*
LoaderPrivateAPIImp
:
:
GetSharedSection
(
)
{
return
&
gSharedSection
;
}
nt
:
:
MemorySectionNameBuf
LoaderPrivateAPIImp
:
:
GetSectionNameBuffer
(
void
*
aSectionAddr
)
{
const
HANDLE
kCurrentProcess
=
reinterpret_cast
<
HANDLE
>
(
-
1
)
;
nt
:
:
MemorySectionNameBuf
buf
;
NTSTATUS
ntStatus
=
:
:
NtQueryVirtualMemory
(
kCurrentProcess
aSectionAddr
MemorySectionName
&
buf
sizeof
(
buf
)
nullptr
)
;
if
(
!
NT_SUCCESS
(
ntStatus
)
)
{
return
nt
:
:
MemorySectionNameBuf
(
)
;
}
return
buf
;
}
void
LoaderPrivateAPIImp
:
:
NotifyBeginDllLoad
(
void
*
*
aContext
PCUNICODE_STRING
aRequestedDllName
)
{
nt
:
:
AutoSharedLock
lock
(
gLoaderObserverLock
)
;
gLoaderObserver
-
>
OnBeginDllLoad
(
aContext
aRequestedDllName
)
;
}
void
LoaderPrivateAPIImp
:
:
NotifyBeginDllLoad
(
ModuleLoadInfo
&
aModuleLoadInfo
void
*
*
aContext
PCUNICODE_STRING
aRequestedDllName
)
{
NotifyBeginDllLoad
(
aContext
aRequestedDllName
)
;
aModuleLoadInfo
.
SetBeginLoadTimeStamp
(
)
;
}
void
LoaderPrivateAPIImp
:
:
SetObserver
(
nt
:
:
LoaderObserver
*
aNewObserver
)
{
nt
:
:
LoaderObserver
*
prevLoaderObserver
=
nullptr
;
nt
:
:
AutoExclusiveLock
lock
(
gLoaderObserverLock
)
;
MOZ_ASSERT
(
aNewObserver
)
;
if
(
!
aNewObserver
)
{
gLoaderObserver
=
&
gDefaultObserver
;
return
;
}
prevLoaderObserver
=
gLoaderObserver
;
gLoaderObserver
=
aNewObserver
;
MOZ_ASSERT
(
prevLoaderObserver
)
;
if
(
!
prevLoaderObserver
)
{
return
;
}
prevLoaderObserver
-
>
Forward
(
aNewObserver
)
;
}
bool
LoaderPrivateAPIImp
:
:
IsDefaultObserver
(
)
const
{
nt
:
:
AutoSharedLock
lock
(
gLoaderObserverLock
)
;
return
gLoaderObserver
=
=
&
gDefaultObserver
;
}
void
EnsureInitialized
(
)
{
Init
(
)
;
}
}
}
