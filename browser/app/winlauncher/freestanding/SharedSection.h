#
ifndef
mozilla_freestanding_SharedSection_h
#
define
mozilla_freestanding_SharedSection_h
#
include
"
mozilla
/
DynamicBlocklist
.
h
"
#
include
"
mozilla
/
glue
/
SharedSection
.
h
"
#
include
"
mozilla
/
NativeNt
.
h
"
#
include
"
mozilla
/
interceptor
/
MMPolicies
.
h
"
#
define
MOZ_LITERAL_UNICODE_STRING
(
s
)
\
{
\
/
*
Length
of
the
string
in
bytes
less
the
null
terminator
*
/
\
sizeof
(
s
)
-
sizeof
(
wchar_t
)
\
/
*
Length
of
the
string
in
bytes
including
the
null
terminator
*
/
\
sizeof
(
s
)
\
/
*
Pointer
to
the
buffer
*
/
\
const_cast
<
wchar_t
*
>
(
s
)
\
}
namespace
mozilla
{
namespace
freestanding
{
class
SharedSectionTestHelper
;
struct
DllBlockInfoComparator
{
explicit
DllBlockInfoComparator
(
const
UNICODE_STRING
&
aTarget
)
:
mTarget
(
&
aTarget
)
{
}
int
operator
(
)
(
const
DllBlockInfo
&
aVal
)
const
{
return
static_cast
<
int
>
(
:
:
RtlCompareUnicodeString
(
mTarget
&
aVal
.
mName
TRUE
)
)
;
}
PCUNICODE_STRING
mTarget
;
}
;
struct
MOZ_TRIVIAL_CTOR_DTOR
Kernel32ExportsSolver
final
:
interceptor
:
:
MMPolicyInProcessEarlyStage
:
:
Kernel32Exports
{
void
Init
(
)
;
bool
Resolve
(
)
;
}
;
class
MOZ_TRIVIAL_CTOR_DTOR
SharedSection
final
:
public
nt
:
:
SharedSection
{
struct
Layout
final
{
enum
class
State
{
kUninitialized
kInitialized
kLoadedDynamicBlocklistEntries
kResolved
}
mState
;
Kernel32ExportsSolver
mK32Exports
;
uint32_t
mBlocklistIsDisabled
;
uint32_t
mDependentModulePathArrayStart
;
uint32_t
mNumBlockEntries
;
DllBlockInfo
mFirstBlockEntry
[
1
]
;
Span
<
DllBlockInfo
>
GetModulePathArray
(
)
{
return
Span
<
DllBlockInfo
>
(
mFirstBlockEntry
(
kSharedViewSize
-
(
reinterpret_cast
<
uintptr_t
>
(
mFirstBlockEntry
)
-
reinterpret_cast
<
uintptr_t
>
(
this
)
)
)
/
sizeof
(
DllBlockInfo
)
)
;
}
static
constexpr
uint32_t
GetMaxNumBlockEntries
(
)
{
return
(
kSharedViewSize
-
(
offsetof
(
Layout
mFirstBlockEntry
)
)
)
/
sizeof
(
DllBlockInfo
)
;
}
Layout
(
)
=
delete
;
bool
Resolve
(
)
;
bool
IsDisabled
(
)
const
;
const
DllBlockInfo
*
SearchBlocklist
(
const
UNICODE_STRING
&
aLeafName
)
const
;
Span
<
wchar_t
>
GetDependentModules
(
)
;
}
;
static
HANDLE
sSectionHandle
;
static
Layout
*
sWriteCopyView
;
static
RTL_RUN_ONCE
sEnsureOnce
;
static
nt
:
:
SRWLock
sLock
;
static
ULONG
NTAPI
EnsureWriteCopyViewOnce
(
PRTL_RUN_ONCE
PVOID
PVOID
*
)
;
static
Layout
*
EnsureWriteCopyView
(
bool
requireKernel32Exports
=
false
)
;
static
constexpr
size_t
kSharedViewSize
=
0x1000
;
friend
class
SharedSectionTestHelper
;
public
:
static
void
Reset
(
HANDLE
aNewSectionObject
=
sSectionHandle
)
;
static
inline
nt
:
:
AutoSharedLock
AutoNoReset
(
)
{
return
nt
:
:
AutoSharedLock
{
sLock
}
;
}
static
void
ConvertToReadOnly
(
)
;
static
LauncherVoidResult
Init
(
)
;
static
LauncherVoidResult
AddDependentModule
(
PCUNICODE_STRING
aNtPath
)
;
static
LauncherVoidResult
SetBlocklist
(
const
DynamicBlockList
&
aBlocklist
bool
isDisabled
)
;
Kernel32ExportsSolver
*
GetKernel32Exports
(
)
;
Maybe
<
Vector
<
const
wchar_t
*
>
>
GetDependentModules
(
)
final
override
;
Span
<
const
DllBlockInfo
>
GetDynamicBlocklist
(
)
final
override
;
static
bool
IsDisabled
(
)
;
static
const
DllBlockInfo
*
SearchBlocklist
(
const
UNICODE_STRING
&
aLeafName
)
;
static
LauncherVoidResult
TransferHandle
(
nt
:
:
CrossExecTransferManager
&
aTransferMgr
DWORD
aDesiredAccess
HANDLE
*
aDestinationAddress
=
&
sSectionHandle
)
;
}
;
extern
SharedSection
gSharedSection
;
}
}
#
endif
