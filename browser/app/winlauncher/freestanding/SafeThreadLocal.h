#
ifndef
mozilla_freestanding_SafeThreadLocal_h
#
define
mozilla_freestanding_SafeThreadLocal_h
#
include
<
type_traits
>
#
include
"
mozilla
/
NativeNt
.
h
"
#
include
"
mozilla
/
ThreadLocal
.
h
"
namespace
mozilla
{
namespace
freestanding
{
#
if
defined
(
__MINGW32__
)
&
&
!
defined
(
HAVE_THREAD_TLS_KEYWORD
)
#
error
"
This
code
requires
the
compiler
to
have
native
TLS
support
"
#
endif
template
<
typename
T
>
class
SafeThreadLocal
final
{
static
MOZ_THREAD_LOCAL
(
T
)
sThreadLocal
;
static
T
sGlobal
;
static
bool
sIsTlsUsed
;
static
DWORD
sMainThreadId
;
MOZ_NEVER_INLINE
static
void
SetGlobalValue
(
T
aValue
)
{
sGlobal
=
aValue
;
}
MOZ_NEVER_INLINE
static
T
GetGlobalValue
(
)
{
return
sGlobal
;
}
public
:
static
void
set
(
T
aValue
)
{
static_assert
(
std
:
:
is_pointer_v
<
T
>
"
SafeThreadLocal
must
be
used
with
a
pointer
"
)
;
if
(
sMainThreadId
=
=
mozilla
:
:
nt
:
:
RtlGetCurrentThreadId
(
)
)
{
SetGlobalValue
(
aValue
)
;
}
else
if
(
sIsTlsUsed
)
{
MOZ_ASSERT
(
mozilla
:
:
nt
:
:
RtlGetThreadLocalStoragePointer
(
)
"
Once
TLS
is
used
TLS
should
be
available
till
the
end
.
"
)
;
sThreadLocal
.
set
(
aValue
)
;
}
else
if
(
mozilla
:
:
nt
:
:
RtlGetThreadLocalStoragePointer
(
)
)
{
sIsTlsUsed
=
true
;
sThreadLocal
.
set
(
aValue
)
;
}
else
{
MOZ_ASSERT
(
sMainThreadId
=
=
0
"
A
second
thread
cannot
be
created
before
TLS
is
available
.
"
)
;
sMainThreadId
=
mozilla
:
:
nt
:
:
RtlGetCurrentThreadId
(
)
;
SetGlobalValue
(
aValue
)
;
}
}
static
T
get
(
)
{
if
(
sMainThreadId
=
=
mozilla
:
:
nt
:
:
RtlGetCurrentThreadId
(
)
)
{
return
GetGlobalValue
(
)
;
}
else
if
(
sIsTlsUsed
)
{
return
sThreadLocal
.
get
(
)
;
}
return
GetGlobalValue
(
)
;
}
}
;
template
<
typename
T
>
MOZ_GLOBINIT
MOZ_THREAD_LOCAL
(
T
)
SafeThreadLocal
<
T
>
:
:
sThreadLocal
;
template
<
typename
T
>
T
SafeThreadLocal
<
T
>
:
:
sGlobal
=
nullptr
;
template
<
typename
T
>
bool
SafeThreadLocal
<
T
>
:
:
sIsTlsUsed
=
false
;
template
<
typename
T
>
DWORD
SafeThreadLocal
<
T
>
:
:
sMainThreadId
=
0
;
}
}
#
endif
