#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
BinarySearch
.
h
"
#
include
"
mozilla
/
NativeNt
.
h
"
#
include
"
mozilla
/
Types
.
h
"
#
include
"
mozilla
/
WindowsDllBlocklist
.
h
"
#
include
"
CrashAnnotations
.
h
"
#
include
"
DllBlocklist
.
h
"
#
include
"
LoaderPrivateAPI
.
h
"
#
include
"
ModuleLoadFrame
.
h
"
#
include
"
SharedSection
.
h
"
#
define
DLL_BLOCKLIST_ENTRY
(
name
.
.
.
)
\
{
MOZ_LITERAL_UNICODE_STRING
(
L
#
#
name
)
__VA_ARGS__
}
#
define
DLL_BLOCKLIST_STRING_TYPE
UNICODE_STRING
#
if
defined
(
MOZ_LAUNCHER_PROCESS
)
|
|
defined
(
NIGHTLY_BUILD
)
#
include
"
mozilla
/
WindowsDllBlocklistLauncherDefs
.
h
"
#
else
#
include
"
mozilla
/
WindowsDllBlocklistCommon
.
h
"
DLL_BLOCKLIST_DEFINITIONS_BEGIN
DLL_BLOCKLIST_DEFINITIONS_END
#
endif
using
WritableBuffer
=
mozilla
:
:
glue
:
:
detail
:
:
WritableBuffer
<
1024
>
;
class
MOZ_STATIC_CLASS
MOZ_TRIVIAL_CTOR_DTOR
NativeNtBlockSet
final
{
struct
NativeNtBlockSetEntry
{
NativeNtBlockSetEntry
(
)
=
default
;
~
NativeNtBlockSetEntry
(
)
=
default
;
NativeNtBlockSetEntry
(
const
UNICODE_STRING
&
aName
uint64_t
aVersion
NativeNtBlockSetEntry
*
aNext
)
:
mName
(
aName
)
mVersion
(
aVersion
)
mNext
(
aNext
)
{
}
UNICODE_STRING
mName
;
uint64_t
mVersion
;
NativeNtBlockSetEntry
*
mNext
;
}
;
public
:
constexpr
NativeNtBlockSet
(
)
:
mFirstEntry
(
nullptr
)
{
}
~
NativeNtBlockSet
(
)
=
default
;
void
Add
(
const
UNICODE_STRING
&
aName
uint64_t
aVersion
)
;
void
Write
(
WritableBuffer
&
buffer
)
;
private
:
static
NativeNtBlockSetEntry
*
NewEntry
(
const
UNICODE_STRING
&
aName
uint64_t
aVersion
NativeNtBlockSetEntry
*
aNextEntry
)
;
private
:
NativeNtBlockSetEntry
*
mFirstEntry
;
mozilla
:
:
nt
:
:
SRWLock
mLock
;
}
;
NativeNtBlockSet
:
:
NativeNtBlockSetEntry
*
NativeNtBlockSet
:
:
NewEntry
(
const
UNICODE_STRING
&
aName
uint64_t
aVersion
NativeNtBlockSet
:
:
NativeNtBlockSetEntry
*
aNextEntry
)
{
return
mozilla
:
:
freestanding
:
:
RtlNew
<
NativeNtBlockSetEntry
>
(
aName
aVersion
aNextEntry
)
;
}
void
NativeNtBlockSet
:
:
Add
(
const
UNICODE_STRING
&
aName
uint64_t
aVersion
)
{
mozilla
:
:
nt
:
:
AutoExclusiveLock
lock
(
mLock
)
;
for
(
NativeNtBlockSetEntry
*
entry
=
mFirstEntry
;
entry
;
entry
=
entry
-
>
mNext
)
{
if
(
:
:
RtlEqualUnicodeString
(
&
entry
-
>
mName
&
aName
TRUE
)
&
&
aVersion
=
=
entry
-
>
mVersion
)
{
return
;
}
}
NativeNtBlockSetEntry
*
newEntry
=
NewEntry
(
aName
aVersion
mFirstEntry
)
;
if
(
newEntry
)
{
mFirstEntry
=
newEntry
;
}
}
void
NativeNtBlockSet
:
:
Write
(
WritableBuffer
&
aBuffer
)
{
char
buf
[
MAX_PATH
]
;
:
:
AcquireSRWLockExclusive
(
&
mLock
)
;
MOZ_SEH_TRY
{
for
(
auto
entry
=
mFirstEntry
;
entry
;
entry
=
entry
-
>
mNext
)
{
int
convOk
=
:
:
WideCharToMultiByte
(
CP_UTF8
0
entry
-
>
mName
.
Buffer
entry
-
>
mName
.
Length
/
sizeof
(
wchar_t
)
buf
sizeof
(
buf
)
nullptr
nullptr
)
;
if
(
!
convOk
)
{
continue
;
}
aBuffer
.
Write
(
buf
convOk
)
;
if
(
entry
-
>
mVersion
!
=
DllBlockInfo
:
:
ALL_VERSIONS
)
{
aBuffer
.
Write
(
"
"
1
)
;
uint16_t
parts
[
4
]
;
parts
[
0
]
=
entry
-
>
mVersion
>
>
48
;
parts
[
1
]
=
(
entry
-
>
mVersion
>
>
32
)
&
0xFFFF
;
parts
[
2
]
=
(
entry
-
>
mVersion
>
>
16
)
&
0xFFFF
;
parts
[
3
]
=
entry
-
>
mVersion
&
0xFFFF
;
for
(
size_t
p
=
0
;
p
<
mozilla
:
:
ArrayLength
(
parts
)
;
+
+
p
)
{
_ltoa_s
(
parts
[
p
]
buf
sizeof
(
buf
)
10
)
;
aBuffer
.
Write
(
buf
strlen
(
buf
)
)
;
if
(
p
!
=
mozilla
:
:
ArrayLength
(
parts
)
-
1
)
{
aBuffer
.
Write
(
"
.
"
1
)
;
}
}
}
aBuffer
.
Write
(
"
;
"
1
)
;
}
}
MOZ_SEH_EXCEPT
(
EXCEPTION_EXECUTE_HANDLER
)
{
}
:
:
ReleaseSRWLockExclusive
(
&
mLock
)
;
}
static
NativeNtBlockSet
gBlockSet
;
extern
"
C
"
void
MOZ_EXPORT
NativeNtBlockSet_Write
(
CrashReporter
:
:
AnnotationWriter
&
aWriter
)
{
WritableBuffer
buffer
;
gBlockSet
.
Write
(
buffer
)
;
aWriter
.
Write
(
CrashReporter
:
:
Annotation
:
:
BlockedDllList
buffer
.
Data
(
)
buffer
.
Length
(
)
)
;
}
enum
class
BlockAction
{
Allow
SubstituteLSP
Error
Deny
NoOpEntryPoint
}
;
static
BlockAction
CheckBlockInfo
(
const
DllBlockInfo
*
aInfo
const
mozilla
:
:
nt
:
:
PEHeaders
&
aHeaders
uint64_t
&
aVersion
)
{
aVersion
=
DllBlockInfo
:
:
ALL_VERSIONS
;
if
(
aInfo
-
>
mFlags
&
(
DllBlockInfo
:
:
BLOCK_WIN8_AND_OLDER
|
DllBlockInfo
:
:
BLOCK_WIN7_AND_OLDER
)
)
{
RTL_OSVERSIONINFOW
osv
=
{
sizeof
(
osv
)
}
;
NTSTATUS
ntStatus
=
:
:
RtlGetVersion
(
&
osv
)
;
if
(
!
NT_SUCCESS
(
ntStatus
)
)
{
return
BlockAction
:
:
Error
;
}
if
(
(
aInfo
-
>
mFlags
&
DllBlockInfo
:
:
BLOCK_WIN8_AND_OLDER
)
&
&
(
osv
.
dwMajorVersion
>
6
|
|
(
osv
.
dwMajorVersion
=
=
6
&
&
osv
.
dwMinorVersion
>
2
)
)
)
{
return
BlockAction
:
:
Allow
;
}
if
(
(
aInfo
-
>
mFlags
&
DllBlockInfo
:
:
BLOCK_WIN7_AND_OLDER
)
&
&
(
osv
.
dwMajorVersion
>
6
|
|
(
osv
.
dwMajorVersion
=
=
6
&
&
osv
.
dwMinorVersion
>
1
)
)
)
{
return
BlockAction
:
:
Allow
;
}
}
if
(
(
aInfo
-
>
mFlags
&
DllBlockInfo
:
:
CHILD_PROCESSES_ONLY
)
&
&
!
(
gBlocklistInitFlags
&
eDllBlocklistInitFlagIsChildProcess
)
)
{
return
BlockAction
:
:
Allow
;
}
if
(
(
aInfo
-
>
mFlags
&
DllBlockInfo
:
:
UTILITY_PROCESSES_ONLY
)
&
&
!
(
gBlocklistInitFlags
&
eDllBlocklistInitFlagIsUtilityProcess
)
)
{
return
BlockAction
:
:
Allow
;
}
if
(
(
aInfo
-
>
mFlags
&
DllBlockInfo
:
:
SOCKET_PROCESSES_ONLY
)
&
&
!
(
gBlocklistInitFlags
&
eDllBlocklistInitFlagIsSocketProcess
)
)
{
return
BlockAction
:
:
Allow
;
}
if
(
(
aInfo
-
>
mFlags
&
DllBlockInfo
:
:
GPU_PROCESSES_ONLY
)
&
&
!
(
gBlocklistInitFlags
&
eDllBlocklistInitFlagIsGPUProcess
)
)
{
return
BlockAction
:
:
Allow
;
}
if
(
(
aInfo
-
>
mFlags
&
DllBlockInfo
:
:
BROWSER_PROCESS_ONLY
)
&
&
(
gBlocklistInitFlags
&
eDllBlocklistInitFlagIsChildProcess
)
)
{
return
BlockAction
:
:
Allow
;
}
if
(
(
aInfo
-
>
mFlags
&
DllBlockInfo
:
:
GMPLUGIN_PROCESSES_ONLY
)
&
&
!
(
gBlocklistInitFlags
&
eDllBlocklistInitFlagIsGMPluginProcess
)
)
{
return
BlockAction
:
:
Allow
;
}
if
(
aInfo
-
>
mMaxVersion
=
=
DllBlockInfo
:
:
ALL_VERSIONS
)
{
return
BlockAction
:
:
Deny
;
}
if
(
!
aHeaders
)
{
return
BlockAction
:
:
Error
;
}
if
(
aInfo
-
>
mFlags
&
DllBlockInfo
:
:
USE_TIMESTAMP
)
{
DWORD
timestamp
;
if
(
!
aHeaders
.
GetTimeStamp
(
timestamp
)
)
{
return
BlockAction
:
:
Error
;
}
if
(
timestamp
>
aInfo
-
>
mMaxVersion
)
{
return
BlockAction
:
:
Allow
;
}
return
BlockAction
:
:
Deny
;
}
if
(
!
aHeaders
.
GetVersionInfo
(
aVersion
)
)
{
return
BlockAction
:
:
Error
;
}
if
(
aInfo
-
>
IsVersionBlocked
(
aVersion
)
)
{
return
BlockAction
:
:
Deny
;
}
return
BlockAction
:
:
Allow
;
}
static
BOOL
WINAPI
NoOp_DllMain
(
HINSTANCE
DWORD
LPVOID
)
{
return
TRUE
;
}
static
bool
IsInjectedDependentModule
(
const
UNICODE_STRING
&
aModuleLeafName
mozilla
:
:
freestanding
:
:
Kernel32ExportsSolver
&
aK32Exports
)
{
mozilla
:
:
nt
:
:
PEHeaders
exeHeaders
(
aK32Exports
.
mGetModuleHandleW
(
nullptr
)
)
;
if
(
!
exeHeaders
|
|
!
exeHeaders
.
IsImportDirectoryTampered
(
)
)
{
return
false
;
}
bool
isDependent
=
false
;
exeHeaders
.
EnumImportChunks
(
[
&
isDependent
&
aModuleLeafName
&
exeHeaders
]
(
const
char
*
aDepModule
)
{
if
(
isDependent
|
|
exeHeaders
.
IsWithinImage
(
aDepModule
)
)
{
return
;
}
UNICODE_STRING
depModuleLeafName
;
mozilla
:
:
nt
:
:
AllocatedUnicodeString
depModuleName
(
aDepModule
)
;
mozilla
:
:
nt
:
:
GetLeafName
(
&
depModuleLeafName
depModuleName
)
;
isDependent
=
(
:
:
RtlCompareUnicodeString
(
&
aModuleLeafName
&
depModuleLeafName
TRUE
)
=
=
0
)
;
}
)
;
return
isDependent
;
}
static
bool
RedirectToNoOpEntryPoint
(
const
mozilla
:
:
nt
:
:
PEHeaders
&
aModule
mozilla
:
:
freestanding
:
:
Kernel32ExportsSolver
&
aK32Exports
)
{
mozilla
:
:
interceptor
:
:
WindowsDllEntryPointInterceptor
interceptor
(
aK32Exports
)
;
if
(
!
interceptor
.
Set
(
aModule
NoOp_DllMain
)
)
{
return
false
;
}
return
true
;
}
static
BlockAction
DetermineBlockAction
(
const
UNICODE_STRING
&
aLeafName
void
*
aBaseAddress
mozilla
:
:
freestanding
:
:
Kernel32ExportsSolver
*
aK32Exports
)
{
if
(
mozilla
:
:
nt
:
:
Contains12DigitHexString
(
aLeafName
)
|
|
mozilla
:
:
nt
:
:
IsFileNameAtLeast16HexDigits
(
aLeafName
)
)
{
return
BlockAction
:
:
Deny
;
}
DECLARE_POINTER_TO_FIRST_DLL_BLOCKLIST_ENTRY
(
info
)
;
DECLARE_DLL_BLOCKLIST_NUM_ENTRIES
(
infoNumEntries
)
;
mozilla
:
:
freestanding
:
:
DllBlockInfoComparator
comp
(
aLeafName
)
;
size_t
match
=
LowerBound
(
info
0
infoNumEntries
comp
)
;
bool
builtinListHasLowerBound
=
match
!
=
infoNumEntries
;
const
DllBlockInfo
*
entry
=
nullptr
;
mozilla
:
:
nt
:
:
PEHeaders
headers
(
aBaseAddress
)
;
uint64_t
version
;
BlockAction
checkResult
=
BlockAction
:
:
Allow
;
if
(
builtinListHasLowerBound
)
{
while
(
match
<
infoNumEntries
&
&
(
comp
(
info
[
match
]
)
=
=
0
)
)
{
entry
=
&
info
[
match
]
;
checkResult
=
CheckBlockInfo
(
entry
headers
version
)
;
if
(
checkResult
!
=
BlockAction
:
:
Allow
)
{
break
;
}
+
+
match
;
}
}
mozilla
:
:
DebugOnly
<
bool
>
blockedByDynamicBlocklist
=
false
;
if
(
checkResult
=
=
BlockAction
:
:
Allow
)
{
if
(
!
mozilla
:
:
freestanding
:
:
gSharedSection
.
IsDisabled
(
)
)
{
entry
=
mozilla
:
:
freestanding
:
:
gSharedSection
.
SearchBlocklist
(
aLeafName
)
;
if
(
entry
)
{
checkResult
=
CheckBlockInfo
(
entry
headers
version
)
;
blockedByDynamicBlocklist
=
checkResult
!
=
BlockAction
:
:
Allow
;
}
}
}
if
(
checkResult
=
=
BlockAction
:
:
Allow
)
{
return
BlockAction
:
:
Allow
;
}
gBlockSet
.
Add
(
entry
-
>
mName
version
)
;
if
(
(
entry
-
>
mFlags
&
DllBlockInfo
:
:
REDIRECT_TO_NOOP_ENTRYPOINT
)
&
&
aK32Exports
&
&
RedirectToNoOpEntryPoint
(
headers
*
aK32Exports
)
)
{
MOZ_ASSERT
(
!
blockedByDynamicBlocklist
"
dynamic
blocklist
has
redirect
?
"
)
;
return
BlockAction
:
:
NoOpEntryPoint
;
}
return
checkResult
;
}
namespace
mozilla
{
namespace
freestanding
{
CrossProcessDllInterceptor
:
:
FuncHookType
<
LdrLoadDllPtr
>
stub_LdrLoadDll
;
NTSTATUS
NTAPI
patched_LdrLoadDll
(
PWCHAR
aDllPath
PULONG
aFlags
PUNICODE_STRING
aDllName
PHANDLE
aOutHandle
)
{
ModuleLoadFrame
frame
(
aDllName
)
;
NTSTATUS
ntStatus
=
stub_LdrLoadDll
(
aDllPath
aFlags
aDllName
aOutHandle
)
;
return
frame
.
SetLoadStatus
(
ntStatus
aOutHandle
)
;
}
CrossProcessDllInterceptor
:
:
FuncHookType
<
NtMapViewOfSectionPtr
>
stub_NtMapViewOfSection
;
constexpr
DWORD
kPageExecutable
=
PAGE_EXECUTE
|
PAGE_EXECUTE_READ
|
PAGE_EXECUTE_READWRITE
|
PAGE_EXECUTE_WRITECOPY
;
MOZ_NEVER_INLINE
NTSTATUS
AfterMapExecutableViewOfSection
(
HANDLE
aProcess
PVOID
*
aBaseAddress
NTSTATUS
aStubStatus
)
{
MEMORY_BASIC_INFORMATION
mbi
;
NTSTATUS
ntStatus
=
:
:
NtQueryVirtualMemory
(
aProcess
*
aBaseAddress
MemoryBasicInformation
&
mbi
sizeof
(
mbi
)
nullptr
)
;
if
(
!
NT_SUCCESS
(
ntStatus
)
)
{
:
:
NtUnmapViewOfSection
(
aProcess
*
aBaseAddress
)
;
return
STATUS_ACCESS_DENIED
;
}
if
(
!
(
mbi
.
Type
&
MEM_IMAGE
)
|
|
!
(
mbi
.
AllocationProtect
&
kPageExecutable
)
)
{
return
aStubStatus
;
}
nt
:
:
MemorySectionNameBuf
sectionFileName
(
gLoaderPrivateAPI
.
GetSectionNameBuffer
(
*
aBaseAddress
)
)
;
if
(
sectionFileName
.
IsEmpty
(
)
)
{
:
:
NtUnmapViewOfSection
(
aProcess
*
aBaseAddress
)
;
return
STATUS_ACCESS_DENIED
;
}
UNICODE_STRING
leafOnStack
;
nt
:
:
GetLeafName
(
&
leafOnStack
sectionFileName
)
;
bool
isInjectedDependent
=
false
;
const
UNICODE_STRING
k32Name
=
MOZ_LITERAL_UNICODE_STRING
(
L
"
kernel32
.
dll
"
)
;
Kernel32ExportsSolver
*
k32Exports
=
nullptr
;
BlockAction
blockAction
;
if
(
:
:
RtlCompareUnicodeString
(
&
k32Name
&
leafOnStack
TRUE
)
=
=
0
)
{
blockAction
=
BlockAction
:
:
Allow
;
}
else
{
k32Exports
=
gSharedSection
.
GetKernel32Exports
(
)
;
if
(
k32Exports
&
&
!
ModuleLoadFrame
:
:
ExistsTopFrame
(
)
)
{
isInjectedDependent
=
IsInjectedDependentModule
(
leafOnStack
*
k32Exports
)
;
}
if
(
isInjectedDependent
)
{
Unused
<
<
SharedSection
:
:
AddDependentModule
(
sectionFileName
)
;
bool
attemptToBlockViaRedirect
;
#
if
defined
(
NIGHTLY_BUILD
)
attemptToBlockViaRedirect
=
true
;
blockAction
=
BlockAction
:
:
NoOpEntryPoint
;
#
else
blockAction
=
DetermineBlockAction
(
leafOnStack
*
aBaseAddress
k32Exports
)
;
attemptToBlockViaRedirect
=
blockAction
=
=
BlockAction
:
:
Deny
|
|
blockAction
=
=
BlockAction
:
:
Error
;
#
endif
if
(
attemptToBlockViaRedirect
)
{
mozilla
:
:
nt
:
:
PEHeaders
headers
(
*
aBaseAddress
)
;
blockAction
=
RedirectToNoOpEntryPoint
(
headers
*
k32Exports
)
?
BlockAction
:
:
NoOpEntryPoint
:
BlockAction
:
:
Allow
;
}
}
else
{
blockAction
=
DetermineBlockAction
(
leafOnStack
*
aBaseAddress
k32Exports
)
;
}
}
ModuleLoadInfo
:
:
Status
loadStatus
=
ModuleLoadInfo
:
:
Status
:
:
Blocked
;
switch
(
blockAction
)
{
case
BlockAction
:
:
Allow
:
loadStatus
=
ModuleLoadInfo
:
:
Status
:
:
Loaded
;
break
;
case
BlockAction
:
:
NoOpEntryPoint
:
loadStatus
=
ModuleLoadInfo
:
:
Status
:
:
Redirected
;
break
;
case
BlockAction
:
:
SubstituteLSP
:
MOZ_ASSERT
(
nt
:
:
RtlGetProcessHeap
(
)
)
;
ModuleLoadFrame
:
:
NotifyLSPSubstitutionRequired
(
&
leafOnStack
)
;
break
;
default
:
break
;
}
if
(
nt
:
:
RtlGetProcessHeap
(
)
)
{
ModuleLoadFrame
:
:
NotifySectionMap
(
nt
:
:
AllocatedUnicodeString
(
sectionFileName
)
*
aBaseAddress
aStubStatus
loadStatus
isInjectedDependent
)
;
}
if
(
loadStatus
=
=
ModuleLoadInfo
:
:
Status
:
:
Loaded
|
|
loadStatus
=
=
ModuleLoadInfo
:
:
Status
:
:
Redirected
)
{
return
aStubStatus
;
}
:
:
NtUnmapViewOfSection
(
aProcess
*
aBaseAddress
)
;
return
STATUS_ACCESS_DENIED
;
}
NTSTATUS
NTAPI
patched_NtMapViewOfSection
(
HANDLE
aSection
HANDLE
aProcess
PVOID
*
aBaseAddress
ULONG_PTR
aZeroBits
SIZE_T
aCommitSize
PLARGE_INTEGER
aSectionOffset
PSIZE_T
aViewSize
SECTION_INHERIT
aInheritDisposition
ULONG
aAllocationType
ULONG
aProtectionFlags
)
{
NTSTATUS
stubStatus
=
stub_NtMapViewOfSection
(
aSection
aProcess
aBaseAddress
aZeroBits
aCommitSize
aSectionOffset
aViewSize
aInheritDisposition
aAllocationType
aProtectionFlags
)
;
if
(
!
NT_SUCCESS
(
stubStatus
)
)
{
return
stubStatus
;
}
if
(
aProcess
!
=
nt
:
:
kCurrentProcess
)
{
return
stubStatus
;
}
if
(
!
(
aProtectionFlags
&
kPageExecutable
)
)
{
return
stubStatus
;
}
return
AfterMapExecutableViewOfSection
(
aProcess
aBaseAddress
stubStatus
)
;
}
}
}
