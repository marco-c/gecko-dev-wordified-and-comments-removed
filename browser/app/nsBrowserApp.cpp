#
include
"
nsXULAppAPI
.
h
"
#
include
"
mozilla
/
XREAppData
.
h
"
#
include
"
XREChildData
.
h
"
#
include
"
XREShellData
.
h
"
#
include
"
application
.
ini
.
h
"
#
include
"
mozilla
/
Bootstrap
.
h
"
#
include
"
mozilla
/
ProcessType
.
h
"
#
include
"
mozilla
/
RuntimeExceptionModule
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
BrowserDefines
.
h
"
#
if
defined
(
XP_WIN
)
#
include
<
windows
.
h
>
#
include
<
stdlib
.
h
>
#
elif
defined
(
XP_UNIX
)
#
include
<
sys
/
resource
.
h
>
#
include
<
unistd
.
h
>
#
include
<
fcntl
.
h
>
#
endif
#
include
<
stdio
.
h
>
#
include
<
stdarg
.
h
>
#
include
<
time
.
h
>
#
include
"
nsCOMPtr
.
h
"
#
ifdef
XP_WIN
#
include
"
mozilla
/
PreXULSkeletonUI
.
h
"
#
include
"
freestanding
/
SharedSection
.
h
"
#
include
"
LauncherProcessWin
.
h
"
#
include
"
mozilla
/
GeckoArgs
.
h
"
#
include
"
mozilla
/
mscom
/
ProcessRuntime
.
h
"
#
include
"
mozilla
/
WindowsDllBlocklist
.
h
"
#
include
"
mozilla
/
WindowsDpiInitialization
.
h
"
#
include
"
mozilla
/
WindowsProcessMitigations
.
h
"
#
define
XRE_WANT_ENVIRON
#
include
"
nsWindowsWMain
.
cpp
"
#
define
strcasecmp
_stricmp
#
ifdef
MOZ_SANDBOX
#
include
"
mozilla
/
sandboxing
/
SandboxInitialization
.
h
"
#
include
"
mozilla
/
sandboxing
/
sandboxLogging
.
h
"
#
endif
#
endif
#
include
"
BinaryPath
.
h
"
#
include
"
nsXPCOMPrivate
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
mozilla
/
StartupTimeline
.
h
"
#
include
"
BaseProfiler
.
h
"
#
ifdef
LIBFUZZER
#
include
"
FuzzerDefs
.
h
"
#
endif
#
ifdef
MOZ_LINUX_32_SSE2_STARTUP_ERROR
#
include
<
cpuid
.
h
>
static
bool
IsSSE2Available
(
)
{
unsigned
int
level
=
1u
;
unsigned
int
eax
ebx
ecx
edx
;
unsigned
int
bits
=
(
1u
<
<
26
)
;
unsigned
int
max
=
__get_cpuid_max
(
0
nullptr
)
;
if
(
level
>
max
)
{
return
false
;
}
__cpuid_count
(
level
0
eax
ebx
ecx
edx
)
;
return
(
edx
&
bits
)
=
=
bits
;
}
static
const
char
sSSE2Message
[
]
=
"
This
browser
version
requires
a
processor
with
the
SSE2
instruction
"
"
set
extension
.
\
nYou
may
be
able
to
obtain
a
version
that
does
not
"
"
require
SSE2
from
your
Linux
distribution
.
\
n
"
;
__attribute__
(
(
constructor
)
)
static
void
SSE2Check
(
)
{
if
(
IsSSE2Available
(
)
)
{
return
;
}
(
void
)
write
(
STDERR_FILENO
sSSE2Message
std
:
:
size
(
sSSE2Message
)
-
1
)
;
_exit
(
255
)
;
}
#
endif
#
if
!
defined
(
MOZ_WIDGET_COCOA
)
&
&
!
defined
(
MOZ_WIDGET_ANDROID
)
#
define
MOZ_BROWSER_CAN_BE_CONTENTPROC
#
endif
using
namespace
mozilla
;
#
define
kDesktopFolder
"
browser
"
#
ifdef
MOZ_BACKGROUNDTASKS
static
bool
gIsBackgroundTask
=
false
;
#
endif
static
MOZ_FORMAT_PRINTF
(
1
2
)
void
Output
(
const
char
*
fmt
.
.
.
)
{
va_list
ap
;
va_start
(
ap
fmt
)
;
#
ifndef
XP_WIN
vfprintf
(
stderr
fmt
ap
)
;
#
else
bool
showMessageBox
=
true
;
char
msg
[
2048
]
;
vsnprintf_s
(
msg
_countof
(
msg
)
_TRUNCATE
fmt
ap
)
;
wchar_t
wide_msg
[
2048
]
;
MultiByteToWideChar
(
CP_UTF8
0
msg
-
1
wide_msg
_countof
(
wide_msg
)
)
;
#
if
MOZ_WINCONSOLE
showMessageBox
=
false
;
#
elif
defined
(
MOZ_BACKGROUNDTASKS
)
showMessageBox
=
!
gIsBackgroundTask
;
#
endif
if
(
showMessageBox
)
{
HMODULE
user32
=
LoadLibraryW
(
L
"
user32
.
dll
"
)
;
if
(
user32
)
{
decltype
(
MessageBoxW
)
*
messageBoxW
=
(
decltype
(
MessageBoxW
)
*
)
GetProcAddress
(
user32
"
MessageBoxW
"
)
;
if
(
messageBoxW
)
{
messageBoxW
(
nullptr
wide_msg
L
"
Firefox
"
MB_OK
|
MB_ICONERROR
|
MB_SETFOREGROUND
)
;
}
else
{
showMessageBox
=
false
;
}
FreeLibrary
(
user32
)
;
}
else
{
showMessageBox
=
false
;
}
}
if
(
!
showMessageBox
)
{
fwprintf_s
(
stderr
wide_msg
)
;
}
#
endif
va_end
(
ap
)
;
}
static
bool
IsFlag
(
const
char
*
arg
const
char
*
s
)
{
if
(
*
arg
=
=
'
-
'
)
{
if
(
*
+
+
arg
=
=
'
-
'
)
+
+
arg
;
return
!
strcasecmp
(
arg
s
)
;
}
#
if
defined
(
XP_WIN
)
if
(
*
arg
=
=
'
/
'
)
return
!
strcasecmp
(
+
+
arg
s
)
;
#
endif
return
false
;
}
static
bool
HasFlag
(
int
argc
char
*
argv
[
]
const
char
*
s
)
{
for
(
int
i
=
1
;
i
<
argc
;
i
+
+
)
{
if
(
IsFlag
(
argv
[
i
]
s
)
)
{
return
true
;
}
}
return
false
;
}
constinit
Bootstrap
:
:
UniquePtr
gBootstrap
;
static
int
do_main
(
int
argc
char
*
argv
[
]
char
*
envp
[
]
)
{
const
char
*
appDataFile
=
getenv
(
"
XUL_APP_FILE
"
)
;
if
(
(
!
appDataFile
|
|
!
*
appDataFile
)
&
&
(
argc
>
1
&
&
IsFlag
(
argv
[
1
]
"
app
"
)
)
)
{
if
(
argc
=
=
2
)
{
Output
(
"
Incorrect
number
of
arguments
passed
to
-
app
"
)
;
return
255
;
}
appDataFile
=
argv
[
2
]
;
char
appEnv
[
MAXPATHLEN
]
;
SprintfLiteral
(
appEnv
"
XUL_APP_FILE
=
%
s
"
argv
[
2
]
)
;
if
(
putenv
(
strdup
(
appEnv
)
)
)
{
Output
(
"
Couldn
'
t
set
%
s
.
\
n
"
appEnv
)
;
return
255
;
}
argv
[
2
]
=
argv
[
0
]
;
argv
+
=
2
;
argc
-
=
2
;
}
else
if
(
argc
>
1
&
&
IsFlag
(
argv
[
1
]
"
xpcshell
"
)
)
{
for
(
int
i
=
1
;
i
<
argc
;
i
+
+
)
{
argv
[
i
]
=
argv
[
i
+
1
]
;
}
XREShellData
shellData
;
#
if
defined
(
XP_WIN
)
&
&
defined
(
MOZ_SANDBOX
)
shellData
.
sandboxBrokerServices
=
sandboxing
:
:
GetInitializedBrokerServices
(
)
;
#
endif
#
ifdef
LIBFUZZER
shellData
.
fuzzerDriver
=
fuzzer
:
:
FuzzerDriver
;
#
endif
#
ifdef
AFLFUZZ
shellData
.
fuzzerDriver
=
afl_interface_raw
;
#
endif
return
gBootstrap
-
>
XRE_XPCShellMain
(
-
-
argc
argv
envp
&
shellData
)
;
}
BootstrapConfig
config
;
if
(
appDataFile
&
&
*
appDataFile
)
{
config
.
appData
=
nullptr
;
config
.
appDataPath
=
appDataFile
;
}
else
{
config
.
appData
=
&
sAppData
;
config
.
appDataPath
=
kDesktopFolder
;
}
#
if
defined
(
XP_WIN
)
&
&
defined
(
MOZ_SANDBOX
)
sandbox
:
:
BrokerServices
*
brokerServices
=
sandboxing
:
:
GetInitializedBrokerServices
(
)
;
if
(
!
brokerServices
)
{
Output
(
"
Couldn
'
t
initialize
the
broker
services
.
\
n
"
)
;
return
255
;
}
config
.
sandboxBrokerServices
=
brokerServices
;
#
endif
#
ifdef
LIBFUZZER
if
(
getenv
(
"
FUZZER
"
)
)
gBootstrap
-
>
XRE_LibFuzzerSetDriver
(
fuzzer
:
:
FuzzerDriver
)
;
#
endif
EnsureBrowserCommandlineSafe
(
argc
argv
)
;
return
gBootstrap
-
>
XRE_main
(
argc
argv
config
)
;
}
static
nsresult
InitXPCOMGlue
(
LibLoadingStrategy
aLibLoadingStrategy
)
{
if
(
gBootstrap
)
{
return
NS_OK
;
}
UniqueFreePtr
<
char
>
exePath
=
BinaryPath
:
:
Get
(
)
;
if
(
!
exePath
)
{
Output
(
"
Couldn
'
t
find
the
application
directory
.
\
n
"
)
;
return
NS_ERROR_FAILURE
;
}
auto
bootstrapResult
=
mozilla
:
:
GetBootstrap
(
exePath
.
get
(
)
aLibLoadingStrategy
)
;
if
(
bootstrapResult
.
isErr
(
)
)
{
Output
(
"
Couldn
'
t
load
XPCOM
.
\
n
"
)
;
return
NS_ERROR_FAILURE
;
}
gBootstrap
=
bootstrapResult
.
unwrap
(
)
;
gBootstrap
-
>
NS_LogInit
(
)
;
return
NS_OK
;
}
#
ifdef
HAS_DLL_BLOCKLIST
uint32_t
gBlocklistInitFlags
=
eDllBlocklistInitFlagDefault
;
#
endif
#
if
defined
(
XP_UNIX
)
static
void
ReserveDefaultFileDescriptors
(
)
{
int
fd
=
open
(
"
/
dev
/
null
"
O_RDONLY
)
;
for
(
int
i
=
0
;
i
<
2
;
i
+
+
)
{
[
[
maybe_unused
]
]
int
r
=
dup
(
fd
)
;
}
}
#
endif
#
ifdef
XP_LINUX
static
void
ExpandFileDescriptorTable
(
)
{
mozilla
:
:
UniqueFileHandle
fdTableExpander
(
fcntl
(
0
F_DUPFD
256
)
)
;
}
#
endif
int
main
(
int
argc
char
*
argv
[
]
char
*
envp
[
]
)
{
#
if
defined
(
XP_UNIX
)
ReserveDefaultFileDescriptors
(
)
;
#
endif
#
ifdef
MOZ_BACKGROUNDTASKS
gIsBackgroundTask
=
HasFlag
(
argc
argv
"
backgroundtask
"
)
;
#
endif
#
ifdef
MOZ_BROWSER_CAN_BE_CONTENTPROC
if
(
argc
>
1
&
&
IsFlag
(
argv
[
1
]
"
contentproc
"
)
)
{
SetGeckoProcessType
(
argv
[
-
-
argc
]
)
;
SetGeckoChildID
(
argv
[
-
-
argc
]
)
;
#
if
defined
(
MOZ_ENABLE_FORKSERVER
)
if
(
GetGeckoProcessType
(
)
=
=
GeckoProcessType_ForkServer
)
{
nsresult
rv
=
InitXPCOMGlue
(
LibLoadingStrategy
:
:
NoReadAhead
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
255
;
}
if
(
gBootstrap
-
>
XRE_ForkServer
(
&
argc
&
argv
)
)
{
gBootstrap
-
>
NS_LogTerm
(
)
;
return
0
;
}
}
#
endif
}
#
endif
#
ifdef
XP_LINUX
ExpandFileDescriptorTable
(
)
;
#
endif
mozilla
:
:
TimeStamp
start
=
mozilla
:
:
TimeStamp
:
:
Now
(
)
;
AUTO_BASE_PROFILER_INIT
;
AUTO_BASE_PROFILER_LABEL
(
"
nsBrowserApp
main
"
OTHER
)
;
CrashReporter
:
:
RegisterRuntimeExceptionModule
(
)
;
auto
unregisterRuntimeExceptionModule
=
MakeScopeExit
(
[
]
{
CrashReporter
:
:
UnregisterRuntimeExceptionModule
(
)
;
}
)
;
#
ifdef
MOZ_BROWSER_CAN_BE_CONTENTPROC
if
(
GetGeckoProcessType
(
)
!
=
GeckoProcessType_Default
)
{
#
if
defined
(
XP_WIN
)
&
&
defined
(
MOZ_SANDBOX
)
Maybe
<
bool
>
win32kLockedDown
=
mozilla
:
:
geckoargs
:
:
sWin32kLockedDown
.
Get
(
argc
argv
)
;
if
(
win32kLockedDown
.
isSome
(
)
&
&
*
win32kLockedDown
)
{
mozilla
:
:
SetWin32kLockedDownInPolicy
(
)
;
}
#
endif
#
ifdef
HAS_DLL_BLOCKLIST
uint32_t
initFlags
=
gBlocklistInitFlags
|
eDllBlocklistInitFlagIsChildProcess
;
SetDllBlocklistProcessTypeFlags
(
initFlags
GetGeckoProcessType
(
)
)
;
DllBlocklist_Initialize
(
initFlags
)
;
#
endif
#
if
defined
(
XP_WIN
)
&
&
defined
(
MOZ_SANDBOX
)
if
(
IsSandboxedProcess
(
)
&
&
!
sandboxing
:
:
GetInitializedTargetServices
(
)
)
{
Output
(
"
Failed
to
initialize
the
sandbox
target
services
.
"
)
;
return
255
;
}
#
endif
#
if
defined
(
XP_WIN
)
{
auto
result
=
mozilla
:
:
WindowsDpiInitialization
(
)
;
(
void
)
result
;
}
#
endif
nsresult
rv
=
InitXPCOMGlue
(
LibLoadingStrategy
:
:
NoReadAhead
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
255
;
}
XREChildData
childData
;
#
if
defined
(
XP_WIN
)
&
&
defined
(
MOZ_SANDBOX
)
if
(
IsSandboxedProcess
(
)
)
{
childData
.
sandboxTargetServices
=
mozilla
:
:
sandboxing
:
:
GetInitializedTargetServices
(
)
;
if
(
!
childData
.
sandboxTargetServices
)
{
return
1
;
}
childData
.
ProvideLogFunction
=
mozilla
:
:
sandboxing
:
:
ProvideLogFunction
;
}
#
endif
rv
=
gBootstrap
-
>
XRE_InitChildProcess
(
argc
argv
&
childData
)
;
#
if
defined
(
DEBUG
)
&
&
defined
(
HAS_DLL_BLOCKLIST
)
DllBlocklist_Shutdown
(
)
;
#
endif
gBootstrap
-
>
NS_LogTerm
(
)
;
return
NS_FAILED
(
rv
)
?
1
:
0
;
}
#
endif
#
ifdef
HAS_DLL_BLOCKLIST
DllBlocklist_Initialize
(
gBlocklistInitFlags
)
;
#
endif
#
if
defined
(
XP_WIN
)
|
|
defined
(
XP_MACOSX
)
if
(
argc
>
1
&
&
IsFlag
(
argv
[
1
]
"
silentmode
"
)
)
{
:
:
putenv
(
const_cast
<
char
*
>
(
"
MOZ_APP_SILENT_START
=
1
"
)
)
;
#
if
defined
(
XP_WIN
)
:
:
putenv
(
const_cast
<
char
*
>
(
"
MOZ_APP_ALLOW_WINDOWLESS
=
1
"
)
)
;
#
endif
#
if
defined
(
XP_MACOSX
)
:
:
putenv
(
const_cast
<
char
*
>
(
"
MOZ_APP_NO_DOCK
=
1
"
)
)
;
#
endif
}
#
endif
#
if
defined
(
XP_WIN
)
{
auto
result
=
mozilla
:
:
WindowsDpiInitialization
(
)
;
(
void
)
result
;
}
mozilla
:
:
freestanding
:
:
gSharedSection
.
ConvertToReadOnly
(
)
;
mozilla
:
:
CreateAndStorePreXULSkeletonUI
(
GetModuleHandle
(
nullptr
)
argc
argv
)
;
#
endif
nsresult
rv
=
InitXPCOMGlue
(
LibLoadingStrategy
:
:
ReadAhead
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
255
;
}
gBootstrap
-
>
XRE_StartupTimelineRecord
(
mozilla
:
:
StartupTimeline
:
:
START
start
)
;
#
ifdef
MOZ_BROWSER_CAN_BE_CONTENTPROC
gBootstrap
-
>
XRE_EnableSameExecutableForContentProc
(
)
;
#
endif
int
result
=
do_main
(
argc
argv
envp
)
;
#
if
defined
(
XP_WIN
)
CleanupProcessRuntime
(
)
;
#
endif
gBootstrap
-
>
NS_LogTerm
(
)
;
#
if
defined
(
DEBUG
)
&
&
defined
(
HAS_DLL_BLOCKLIST
)
DllBlocklist_Shutdown
(
)
;
#
endif
#
ifdef
XP_MACOSX
gBootstrap
-
>
XRE_StopLateWriteChecks
(
)
;
#
endif
gBootstrap
.
reset
(
)
;
return
result
;
}
