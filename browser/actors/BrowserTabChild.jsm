"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
BrowserTabChild
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ActorChild
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
E10SUtils
"
"
resource
:
/
/
gre
/
modules
/
E10SUtils
.
jsm
"
)
;
class
BrowserTabChild
extends
ActorChild
{
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
DOMWindowCreated
"
:
let
loadContext
=
this
.
mm
.
docShell
.
QueryInterface
(
Ci
.
nsILoadContext
)
;
let
userContextId
=
loadContext
.
originAttributes
.
userContextId
;
this
.
mm
.
sendAsyncMessage
(
"
Browser
:
WindowCreated
"
{
userContextId
}
)
;
break
;
case
"
MozAfterPaint
"
:
this
.
mm
.
sendAsyncMessage
(
"
Browser
:
FirstPaint
"
)
;
break
;
case
"
MozDOMPointerLock
:
Entered
"
:
this
.
mm
.
sendAsyncMessage
(
"
PointerLock
:
Entered
"
{
originNoSuffix
:
event
.
target
.
nodePrincipal
.
originNoSuffix
}
)
;
break
;
case
"
MozDOMPointerLock
:
Exited
"
:
this
.
mm
.
sendAsyncMessage
(
"
PointerLock
:
Exited
"
)
;
break
;
}
}
switchDocumentDirection
(
window
=
this
.
content
)
{
if
(
window
.
document
.
dir
=
=
"
ltr
"
|
|
window
.
document
.
dir
=
=
"
"
)
{
window
.
document
.
dir
=
"
rtl
"
;
}
else
if
(
window
.
document
.
dir
=
=
"
rtl
"
)
{
window
.
document
.
dir
=
"
ltr
"
;
}
for
(
let
i
=
0
;
i
<
window
.
frames
.
length
;
i
+
+
)
{
this
.
switchDocumentDirection
(
window
.
frames
[
i
]
)
;
}
}
receiveMessage
(
message
)
{
switch
(
message
.
name
)
{
case
"
AllowScriptsToClose
"
:
this
.
content
.
windowUtils
.
allowScriptsToClose
(
)
;
break
;
case
"
Browser
:
AppTab
"
:
if
(
this
.
docShell
)
{
this
.
docShell
.
isAppTab
=
message
.
data
.
isAppTab
;
}
break
;
case
"
Browser
:
HasSiblings
"
:
try
{
let
tabChild
=
this
.
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsITabChild
)
;
let
hasSiblings
=
message
.
data
;
tabChild
.
hasSiblings
=
hasSiblings
;
}
catch
(
e
)
{
}
break
;
case
"
Browser
:
Reload
"
:
let
webNav
=
this
.
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
;
try
{
if
(
webNav
.
sessionHistory
)
{
webNav
=
webNav
.
sessionHistory
;
}
}
catch
(
e
)
{
}
let
reloadFlags
=
message
.
data
.
flags
;
try
{
E10SUtils
.
wrapHandlingUserInput
(
this
.
content
message
.
data
.
handlingUserInput
(
)
=
>
webNav
.
reload
(
reloadFlags
)
)
;
}
catch
(
e
)
{
}
break
;
case
"
MixedContent
:
ReenableProtection
"
:
this
.
docShell
.
mixedContentChannel
=
null
;
break
;
case
"
SwitchDocumentDirection
"
:
this
.
switchDocumentDirection
(
)
;
break
;
case
"
UpdateCharacterSet
"
:
this
.
docShell
.
charset
=
message
.
data
.
value
;
this
.
docShell
.
gatherCharsetMenuTelemetry
(
)
;
break
;
}
}
}
