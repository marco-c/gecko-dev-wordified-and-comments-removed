"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
BrowserTabChild
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
E10SUtils
"
"
resource
:
/
/
gre
/
modules
/
E10SUtils
.
jsm
"
)
;
class
BrowserTabChild
extends
JSWindowActorChild
{
constructor
(
)
{
super
(
)
;
this
.
handledWindowCreated
=
false
;
this
.
handledFirstPaint
=
false
;
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
DOMWindowCreated
"
:
{
if
(
this
.
handledWindowCreated
)
{
return
;
}
this
.
handledWindowCreated
=
true
;
let
context
=
this
.
manager
.
browsingContext
;
let
loadContext
=
context
.
docShell
.
QueryInterface
(
Ci
.
nsILoadContext
)
;
let
userContextId
=
loadContext
.
originAttributes
.
userContextId
;
this
.
initializeRPM
(
)
;
this
.
sendAsyncMessage
(
"
Browser
:
WindowCreated
"
{
userContextId
}
)
;
break
;
}
case
"
MozAfterPaint
"
:
if
(
this
.
handledFirstPaint
)
{
return
;
}
this
.
handledFirstPaint
=
true
;
this
.
sendAsyncMessage
(
"
Browser
:
FirstPaint
"
{
}
)
;
break
;
}
}
receiveMessage
(
message
)
{
let
context
=
this
.
manager
.
browsingContext
;
let
docShell
=
context
.
docShell
;
switch
(
message
.
name
)
{
case
"
Browser
:
AppTab
"
:
if
(
docShell
)
{
docShell
.
isAppTab
=
message
.
data
.
isAppTab
;
}
break
;
case
"
Browser
:
HasSiblings
"
:
try
{
let
browserChild
=
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIBrowserChild
)
;
let
hasSiblings
=
message
.
data
;
browserChild
.
hasSiblings
=
hasSiblings
;
}
catch
(
e
)
{
}
break
;
case
"
Browser
:
Reload
"
:
let
webNav
=
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
;
try
{
if
(
webNav
.
sessionHistory
)
{
webNav
=
webNav
.
sessionHistory
;
}
}
catch
(
e
)
{
}
let
reloadFlags
=
message
.
data
.
flags
;
try
{
E10SUtils
.
wrapHandlingUserInput
(
this
.
document
.
defaultView
message
.
data
.
handlingUserInput
(
)
=
>
webNav
.
reload
(
reloadFlags
)
)
;
}
catch
(
e
)
{
}
break
;
case
"
MixedContent
:
ReenableProtection
"
:
docShell
.
mixedContentChannel
=
null
;
break
;
case
"
UpdateCharacterSet
"
:
docShell
.
charset
=
message
.
data
.
value
;
docShell
.
gatherCharsetMenuTelemetry
(
)
;
break
;
}
}
initializeRPM
(
)
{
let
url
=
this
.
document
.
documentURI
.
replace
(
/
[
\
#
?
]
.
*
/
"
"
)
;
let
registeredURLs
=
Services
.
cpmm
.
sharedData
.
get
(
"
RemotePageManager
:
urls
"
)
;
if
(
registeredURLs
&
&
registeredURLs
.
has
(
url
)
)
{
let
{
ChildMessagePort
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
remotepagemanager
/
RemotePageManagerChild
.
jsm
"
)
;
new
ChildMessagePort
(
this
.
contentWindow
)
;
}
}
}
