"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
DOMFullscreenChild
"
]
;
const
{
ActorChild
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ActorChild
.
jsm
"
)
;
class
DOMFullscreenChild
extends
ActorChild
{
receiveMessage
(
aMessage
)
{
let
windowUtils
=
this
.
content
&
&
this
.
content
.
windowUtils
;
switch
(
aMessage
.
name
)
{
case
"
DOMFullscreen
:
Entered
"
:
{
this
.
_lastTransactionId
=
windowUtils
.
lastTransactionId
;
if
(
!
windowUtils
.
handleFullscreenRequests
(
)
&
&
!
this
.
content
.
document
.
fullscreenElement
)
{
this
.
mm
.
sendAsyncMessage
(
"
DOMFullscreen
:
Exit
"
)
;
}
break
;
}
case
"
DOMFullscreen
:
CleanUp
"
:
{
if
(
this
.
content
.
document
.
fullscreenElement
&
&
windowUtils
)
{
this
.
_lastTransactionId
=
windowUtils
.
lastTransactionId
;
windowUtils
.
exitFullscreen
(
)
;
}
break
;
}
}
}
handleEvent
(
aEvent
)
{
switch
(
aEvent
.
type
)
{
case
"
MozDOMFullscreen
:
Request
"
:
{
this
.
mm
.
sendAsyncMessage
(
"
DOMFullscreen
:
Request
"
)
;
break
;
}
case
"
MozDOMFullscreen
:
NewOrigin
"
:
{
this
.
mm
.
sendAsyncMessage
(
"
DOMFullscreen
:
NewOrigin
"
{
originNoSuffix
:
aEvent
.
target
.
nodePrincipal
.
originNoSuffix
}
)
;
break
;
}
case
"
MozDOMFullscreen
:
Exit
"
:
{
this
.
mm
.
sendAsyncMessage
(
"
DOMFullscreen
:
Exit
"
)
;
break
;
}
case
"
MozDOMFullscreen
:
Entered
"
:
case
"
MozDOMFullscreen
:
Exited
"
:
{
this
.
mm
.
addEventListener
(
"
MozAfterPaint
"
this
)
;
if
(
!
this
.
content
|
|
!
this
.
content
.
document
.
fullscreenElement
)
{
this
.
mm
.
sendAsyncMessage
(
"
DOMFullscreen
:
Exit
"
)
;
}
break
;
}
case
"
MozAfterPaint
"
:
{
if
(
!
this
.
_lastTransactionId
|
|
aEvent
.
transactionId
>
this
.
_lastTransactionId
)
{
this
.
mm
.
removeEventListener
(
"
MozAfterPaint
"
this
)
;
this
.
mm
.
sendAsyncMessage
(
"
DOMFullscreen
:
Painted
"
)
;
}
break
;
}
}
}
}
