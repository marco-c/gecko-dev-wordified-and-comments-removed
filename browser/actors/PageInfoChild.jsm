var
EXPORTED_SYMBOLS
=
[
"
PageInfoChild
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
E10SUtils
:
"
resource
:
/
/
gre
/
modules
/
E10SUtils
.
jsm
"
PrivateBrowsingUtils
:
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
setTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
}
)
;
class
PageInfoChild
extends
JSWindowActorChild
{
async
receiveMessage
(
message
)
{
let
window
=
this
.
contentWindow
;
let
document
=
window
.
document
;
switch
(
message
.
name
)
{
case
"
PageInfo
:
getData
"
:
{
return
Promise
.
resolve
(
{
metaViewRows
:
this
.
getMetaInfo
(
document
)
docInfo
:
this
.
getDocumentInfo
(
document
)
windowInfo
:
this
.
getWindowInfo
(
window
)
}
)
;
}
case
"
PageInfo
:
getMediaData
"
:
{
return
Promise
.
resolve
(
{
mediaItems
:
await
this
.
getDocumentMedia
(
document
)
}
)
;
}
}
return
undefined
;
}
getMetaInfo
(
document
)
{
let
metaViewRows
=
[
]
;
let
metaNodes
=
document
.
getElementsByTagName
(
"
meta
"
)
;
for
(
let
metaNode
of
metaNodes
)
{
metaViewRows
.
push
(
[
metaNode
.
name
|
|
metaNode
.
httpEquiv
|
|
metaNode
.
getAttribute
(
"
property
"
)
metaNode
.
content
]
)
;
}
return
metaViewRows
;
}
getWindowInfo
(
window
)
{
let
windowInfo
=
{
}
;
windowInfo
.
isTopWindow
=
window
=
=
window
.
top
;
let
hostName
=
null
;
try
{
hostName
=
Services
.
io
.
newURI
(
window
.
location
.
href
)
.
displayHost
;
}
catch
(
exception
)
{
}
windowInfo
.
hostName
=
hostName
;
return
windowInfo
;
}
getDocumentInfo
(
document
)
{
let
docInfo
=
{
}
;
docInfo
.
title
=
document
.
title
;
docInfo
.
location
=
document
.
location
.
toString
(
)
;
try
{
docInfo
.
location
=
Services
.
io
.
newURI
(
document
.
location
.
toString
(
)
)
.
displaySpec
;
}
catch
(
exception
)
{
}
docInfo
.
referrer
=
document
.
referrer
;
try
{
if
(
document
.
referrer
)
{
docInfo
.
referrer
=
Services
.
io
.
newURI
(
document
.
referrer
)
.
displaySpec
;
}
}
catch
(
exception
)
{
}
docInfo
.
compatMode
=
document
.
compatMode
;
docInfo
.
contentType
=
document
.
contentType
;
docInfo
.
characterSet
=
document
.
characterSet
;
docInfo
.
lastModified
=
document
.
lastModified
;
docInfo
.
principal
=
document
.
nodePrincipal
;
docInfo
.
cookieJarSettings
=
E10SUtils
.
serializeCookieJarSettings
(
document
.
cookieJarSettings
)
;
let
documentURIObject
=
{
}
;
documentURIObject
.
spec
=
document
.
documentURIObject
.
spec
;
docInfo
.
documentURIObject
=
documentURIObject
;
docInfo
.
isContentWindowPrivate
=
PrivateBrowsingUtils
.
isContentWindowPrivate
(
document
.
ownerGlobal
)
;
return
docInfo
;
}
async
getDocumentMedia
(
document
)
{
let
nodeCount
=
0
;
let
content
=
document
.
ownerGlobal
;
let
iterator
=
document
.
createTreeWalker
(
document
content
.
NodeFilter
.
SHOW_ELEMENT
)
;
let
totalMediaItems
=
[
]
;
while
(
iterator
.
nextNode
(
)
)
{
let
mediaItems
=
this
.
getMediaItems
(
document
iterator
.
currentNode
)
;
if
(
+
+
nodeCount
%
500
=
=
0
)
{
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
10
)
)
;
}
totalMediaItems
.
push
(
.
.
.
mediaItems
)
;
}
return
totalMediaItems
;
}
getMediaItems
(
document
elem
)
{
let
computedStyle
=
elem
.
ownerGlobal
.
getComputedStyle
(
elem
)
;
let
mediaItems
=
[
]
;
let
content
=
document
.
ownerGlobal
;
let
addMedia
=
(
url
type
alt
el
isBg
altNotProvided
=
false
)
=
>
{
let
element
=
this
.
serializeElementInfo
(
document
url
el
isBg
)
;
mediaItems
.
push
(
{
url
type
alt
altNotProvided
element
isBg
}
)
;
}
;
if
(
computedStyle
)
{
let
addImgFunc
=
(
type
urls
)
=
>
{
for
(
let
url
of
urls
)
{
addMedia
(
url
type
"
"
elem
true
true
)
;
}
}
;
addImgFunc
(
"
bg
-
img
"
computedStyle
.
getCSSImageURLs
(
"
background
-
image
"
)
)
;
addImgFunc
(
"
border
-
img
"
computedStyle
.
getCSSImageURLs
(
"
border
-
image
-
source
"
)
)
;
addImgFunc
(
"
list
-
img
"
computedStyle
.
getCSSImageURLs
(
"
list
-
style
-
image
"
)
)
;
addImgFunc
(
"
cursor
"
computedStyle
.
getCSSImageURLs
(
"
cursor
"
)
)
;
}
if
(
elem
instanceof
content
.
HTMLImageElement
)
{
addMedia
(
elem
.
src
"
img
"
elem
.
getAttribute
(
"
alt
"
)
elem
false
!
elem
.
hasAttribute
(
"
alt
"
)
)
;
}
else
if
(
elem
instanceof
content
.
SVGImageElement
)
{
try
{
if
(
elem
.
href
.
baseVal
)
{
let
href
=
Services
.
io
.
newURI
(
elem
.
href
.
baseVal
null
Services
.
io
.
newURI
(
elem
.
baseURI
)
)
.
spec
;
addMedia
(
href
"
img
"
"
"
elem
false
)
;
}
}
catch
(
e
)
{
}
}
else
if
(
elem
instanceof
content
.
HTMLVideoElement
)
{
addMedia
(
elem
.
currentSrc
"
video
"
"
"
elem
false
)
;
}
else
if
(
elem
instanceof
content
.
HTMLAudioElement
)
{
addMedia
(
elem
.
currentSrc
"
audio
"
"
"
elem
false
)
;
}
else
if
(
elem
instanceof
content
.
HTMLLinkElement
)
{
if
(
elem
.
rel
&
&
/
\
bicon
\
b
/
i
.
test
(
elem
.
rel
)
)
{
addMedia
(
elem
.
href
"
link
"
"
"
elem
false
)
;
}
}
else
if
(
elem
instanceof
content
.
HTMLInputElement
|
|
elem
instanceof
content
.
HTMLButtonElement
)
{
if
(
elem
.
type
.
toLowerCase
(
)
=
=
"
image
"
)
{
addMedia
(
elem
.
src
"
input
"
elem
.
getAttribute
(
"
alt
"
)
elem
false
!
elem
.
hasAttribute
(
"
alt
"
)
)
;
}
}
else
if
(
elem
instanceof
content
.
HTMLObjectElement
)
{
addMedia
(
elem
.
data
"
object
"
this
.
getValueText
(
elem
)
elem
false
)
;
}
else
if
(
elem
instanceof
content
.
HTMLEmbedElement
)
{
addMedia
(
elem
.
src
"
embed
"
"
"
elem
false
)
;
}
return
mediaItems
;
}
serializeElementInfo
(
document
url
item
isBG
)
{
let
result
=
{
}
;
let
content
=
document
.
ownerGlobal
;
let
imageText
;
if
(
!
isBG
&
&
!
(
item
instanceof
content
.
SVGImageElement
)
&
&
!
(
document
instanceof
content
.
ImageDocument
)
)
{
imageText
=
item
.
title
|
|
item
.
alt
;
if
(
!
imageText
&
&
!
(
item
instanceof
content
.
HTMLImageElement
)
)
{
imageText
=
this
.
getValueText
(
item
)
;
}
}
result
.
imageText
=
imageText
;
result
.
longDesc
=
item
.
longDesc
;
result
.
numFrames
=
1
;
if
(
item
instanceof
content
.
HTMLObjectElement
|
|
item
instanceof
content
.
HTMLEmbedElement
|
|
item
instanceof
content
.
HTMLLinkElement
)
{
result
.
mimeType
=
item
.
type
;
}
if
(
!
result
.
mimeType
&
&
!
isBG
&
&
item
instanceof
Ci
.
nsIImageLoadingContent
)
{
let
imageRequest
=
item
.
getRequest
(
Ci
.
nsIImageLoadingContent
.
CURRENT_REQUEST
)
;
if
(
imageRequest
)
{
result
.
mimeType
=
imageRequest
.
mimeType
;
let
image
=
!
(
imageRequest
.
imageStatus
&
imageRequest
.
STATUS_ERROR
)
&
&
imageRequest
.
image
;
if
(
image
)
{
result
.
numFrames
=
image
.
numFrames
;
}
}
}
if
(
!
result
.
mimeType
&
&
url
.
startsWith
(
"
data
:
"
)
)
{
let
dataMimeType
=
/
^
data
:
(
image
\
/
[
^
;
]
+
)
/
i
.
exec
(
url
)
;
if
(
dataMimeType
)
{
result
.
mimeType
=
dataMimeType
[
1
]
.
toLowerCase
(
)
;
}
}
result
.
HTMLLinkElement
=
item
instanceof
content
.
HTMLLinkElement
;
result
.
HTMLInputElement
=
item
instanceof
content
.
HTMLInputElement
;
result
.
HTMLImageElement
=
item
instanceof
content
.
HTMLImageElement
;
result
.
HTMLObjectElement
=
item
instanceof
content
.
HTMLObjectElement
;
result
.
SVGImageElement
=
item
instanceof
content
.
SVGImageElement
;
result
.
HTMLVideoElement
=
item
instanceof
content
.
HTMLVideoElement
;
result
.
HTMLAudioElement
=
item
instanceof
content
.
HTMLAudioElement
;
if
(
isBG
)
{
let
img
=
content
.
document
.
createElement
(
"
img
"
)
;
img
.
src
=
url
;
result
.
naturalWidth
=
img
.
naturalWidth
;
result
.
naturalHeight
=
img
.
naturalHeight
;
}
else
if
(
!
(
item
instanceof
content
.
SVGImageElement
)
)
{
result
.
width
=
item
.
width
;
result
.
height
=
item
.
height
;
}
if
(
item
instanceof
content
.
SVGImageElement
)
{
result
.
SVGImageElementWidth
=
item
.
width
.
baseVal
.
value
;
result
.
SVGImageElementHeight
=
item
.
height
.
baseVal
.
value
;
}
result
.
baseURI
=
item
.
baseURI
;
return
result
;
}
getValueText
(
node
)
{
let
valueText
=
"
"
;
let
content
=
node
.
ownerGlobal
;
if
(
node
instanceof
content
.
HTMLInputElement
|
|
node
instanceof
content
.
HTMLSelectElement
|
|
node
instanceof
content
.
HTMLTextAreaElement
)
{
return
valueText
;
}
let
length
=
node
.
childNodes
.
length
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
let
childNode
=
node
.
childNodes
[
i
]
;
let
nodeType
=
childNode
.
nodeType
;
if
(
nodeType
=
=
content
.
Node
.
TEXT_NODE
)
{
valueText
+
=
"
"
+
childNode
.
nodeValue
;
}
else
if
(
nodeType
=
=
content
.
Node
.
ELEMENT_NODE
)
{
if
(
childNode
instanceof
content
.
HTMLImageElement
)
{
valueText
+
=
"
"
+
this
.
getAltText
(
childNode
)
;
}
else
{
valueText
+
=
"
"
+
this
.
getValueText
(
childNode
)
;
}
}
}
return
this
.
stripWS
(
valueText
)
;
}
getAltText
(
node
)
{
let
altText
=
"
"
;
if
(
node
.
alt
)
{
return
node
.
alt
;
}
let
length
=
node
.
childNodes
.
length
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
if
(
(
altText
=
this
.
getAltText
(
node
.
childNodes
[
i
]
)
!
=
undefined
)
)
{
return
altText
;
}
}
return
"
"
;
}
stripWS
(
text
)
{
let
middleRE
=
/
\
s
+
/
g
;
let
endRE
=
/
(
^
\
s
+
)
|
(
\
s
+
)
/
g
;
text
=
text
.
replace
(
middleRE
"
"
)
;
return
text
.
replace
(
endRE
"
"
)
;
}
}
