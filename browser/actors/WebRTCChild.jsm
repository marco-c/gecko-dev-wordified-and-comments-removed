"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
WebRTCChild
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
MediaManagerService
"
"
mozilla
.
org
/
mediaManagerService
;
1
"
"
nsIMediaManagerService
"
)
;
const
kBrowserURL
=
AppConstants
.
BROWSER_CHROME_URL
;
const
GlobalMuteListener
=
{
_initted
:
false
init
(
)
{
if
(
!
this
.
_initted
)
{
Services
.
cpmm
.
sharedData
.
addEventListener
(
"
change
"
this
)
;
this
.
_updateCameraMuteState
(
)
;
this
.
_updateMicrophoneMuteState
(
)
;
this
.
_initted
=
true
;
}
}
handleEvent
(
event
)
{
if
(
event
.
changedKeys
.
includes
(
"
WebRTC
:
GlobalCameraMute
"
)
)
{
this
.
_updateCameraMuteState
(
)
;
}
if
(
event
.
changedKeys
.
includes
(
"
WebRTC
:
GlobalMicrophoneMute
"
)
)
{
this
.
_updateMicrophoneMuteState
(
)
;
}
}
_updateCameraMuteState
(
)
{
let
shouldMute
=
Services
.
cpmm
.
sharedData
.
get
(
"
WebRTC
:
GlobalCameraMute
"
)
;
let
topic
=
shouldMute
?
"
getUserMedia
:
muteVideo
"
:
"
getUserMedia
:
unmuteVideo
"
;
Services
.
obs
.
notifyObservers
(
null
topic
)
;
}
_updateMicrophoneMuteState
(
)
{
let
shouldMute
=
Services
.
cpmm
.
sharedData
.
get
(
"
WebRTC
:
GlobalMicrophoneMute
"
)
;
let
topic
=
shouldMute
?
"
getUserMedia
:
muteAudio
"
:
"
getUserMedia
:
unmuteAudio
"
;
Services
.
obs
.
notifyObservers
(
null
topic
)
;
}
}
;
class
WebRTCChild
extends
JSWindowActorChild
{
actorCreated
(
)
{
this
.
suppressNotifications
=
false
;
}
static
handleEvent
(
aEvent
)
{
let
contentWindow
=
aEvent
.
target
.
defaultView
;
let
actor
=
getActorForWindow
(
contentWindow
)
;
if
(
actor
)
{
for
(
let
key
of
contentWindow
.
pendingGetUserMediaRequests
.
keys
(
)
)
{
actor
.
sendAsyncMessage
(
"
webrtc
:
CancelRequest
"
key
)
;
}
for
(
let
key
of
contentWindow
.
pendingPeerConnectionRequests
.
keys
(
)
)
{
actor
.
sendAsyncMessage
(
"
rtcpeer
:
CancelRequest
"
key
)
;
}
}
}
static
observe
(
aSubject
aTopic
aData
)
{
switch
(
aTopic
)
{
case
"
getUserMedia
:
request
"
:
handleGUMRequest
(
aSubject
aTopic
aData
)
;
break
;
case
"
recording
-
device
-
stopped
"
:
handleGUMStop
(
aSubject
aTopic
aData
)
;
break
;
case
"
PeerConnection
:
request
"
:
handlePCRequest
(
aSubject
aTopic
aData
)
;
break
;
case
"
recording
-
device
-
events
"
:
updateIndicators
(
aSubject
aTopic
aData
)
;
break
;
case
"
recording
-
window
-
ended
"
:
removeBrowserSpecificIndicator
(
aSubject
aTopic
aData
)
;
break
;
}
}
receiveMessage
(
aMessage
)
{
switch
(
aMessage
.
name
)
{
case
"
rtcpeer
:
Allow
"
:
case
"
rtcpeer
:
Deny
"
:
{
let
callID
=
aMessage
.
data
.
callID
;
let
contentWindow
=
Services
.
wm
.
getOuterWindowWithId
(
aMessage
.
data
.
windowID
)
;
forgetPCRequest
(
contentWindow
callID
)
;
let
topic
=
aMessage
.
name
=
=
"
rtcpeer
:
Allow
"
?
"
PeerConnection
:
response
:
allow
"
:
"
PeerConnection
:
response
:
deny
"
;
Services
.
obs
.
notifyObservers
(
null
topic
callID
)
;
break
;
}
case
"
webrtc
:
Allow
"
:
{
let
callID
=
aMessage
.
data
.
callID
;
let
contentWindow
=
Services
.
wm
.
getOuterWindowWithId
(
aMessage
.
data
.
windowID
)
;
let
devices
=
contentWindow
.
pendingGetUserMediaRequests
.
get
(
callID
)
;
forgetGUMRequest
(
contentWindow
callID
)
;
let
allowedDevices
=
Cc
[
"
mozilla
.
org
/
array
;
1
"
]
.
createInstance
(
Ci
.
nsIMutableArray
)
;
for
(
let
deviceIndex
of
aMessage
.
data
.
devices
)
{
allowedDevices
.
appendElement
(
devices
[
deviceIndex
]
)
;
}
Services
.
obs
.
notifyObservers
(
allowedDevices
"
getUserMedia
:
response
:
allow
"
callID
)
;
this
.
suppressNotifications
=
!
!
aMessage
.
data
.
suppressNotifications
;
break
;
}
case
"
webrtc
:
Deny
"
:
denyGUMRequest
(
aMessage
.
data
)
;
break
;
case
"
webrtc
:
StopSharing
"
:
Services
.
obs
.
notifyObservers
(
null
"
getUserMedia
:
revoke
"
aMessage
.
data
)
;
break
;
case
"
webrtc
:
MuteCamera
"
:
Services
.
obs
.
notifyObservers
(
null
"
getUserMedia
:
muteVideo
"
aMessage
.
data
)
;
break
;
case
"
webrtc
:
UnmuteCamera
"
:
Services
.
obs
.
notifyObservers
(
null
"
getUserMedia
:
unmuteVideo
"
aMessage
.
data
)
;
break
;
case
"
webrtc
:
MuteMicrophone
"
:
Services
.
obs
.
notifyObservers
(
null
"
getUserMedia
:
muteAudio
"
aMessage
.
data
)
;
break
;
case
"
webrtc
:
UnmuteMicrophone
"
:
Services
.
obs
.
notifyObservers
(
null
"
getUserMedia
:
unmuteAudio
"
aMessage
.
data
)
;
break
;
}
}
}
function
getActorForWindow
(
window
)
{
try
{
let
windowGlobal
=
window
.
windowGlobalChild
;
if
(
windowGlobal
)
{
return
windowGlobal
.
getActor
(
"
WebRTC
"
)
;
}
}
catch
(
ex
)
{
}
return
null
;
}
function
handlePCRequest
(
aSubject
aTopic
aData
)
{
let
{
windowID
innerWindowID
callID
isSecure
}
=
aSubject
;
let
contentWindow
=
Services
.
wm
.
getOuterWindowWithId
(
windowID
)
;
if
(
!
contentWindow
.
pendingPeerConnectionRequests
)
{
setupPendingListsInitially
(
contentWindow
)
;
}
contentWindow
.
pendingPeerConnectionRequests
.
add
(
callID
)
;
let
request
=
{
windowID
innerWindowID
callID
documentURI
:
contentWindow
.
document
.
documentURI
secure
:
isSecure
}
;
let
actor
=
getActorForWindow
(
contentWindow
)
;
if
(
actor
)
{
actor
.
sendAsyncMessage
(
"
rtcpeer
:
Request
"
request
)
;
}
}
function
handleGUMStop
(
aSubject
aTopic
aData
)
{
let
contentWindow
=
Services
.
wm
.
getOuterWindowWithId
(
aSubject
.
windowID
)
;
let
request
=
{
windowID
:
aSubject
.
windowID
rawID
:
aSubject
.
rawID
mediaSource
:
aSubject
.
mediaSource
}
;
let
actor
=
getActorForWindow
(
contentWindow
)
;
if
(
actor
)
{
actor
.
sendAsyncMessage
(
"
webrtc
:
StopRecording
"
request
)
;
}
}
function
handleGUMRequest
(
aSubject
aTopic
aData
)
{
GlobalMuteListener
.
init
(
)
;
let
constraints
=
aSubject
.
getConstraints
(
)
;
let
contentWindow
=
Services
.
wm
.
getOuterWindowWithId
(
aSubject
.
windowID
)
;
prompt
(
aSubject
.
type
contentWindow
aSubject
.
windowID
aSubject
.
callID
constraints
aSubject
.
devices
aSubject
.
isSecure
aSubject
.
isHandlingUserInput
)
;
}
function
prompt
(
aRequestType
aContentWindow
aWindowID
aCallID
aConstraints
aDevices
aSecure
aIsHandlingUserInput
)
{
let
audioInputDevices
=
[
]
;
let
videoInputDevices
=
[
]
;
let
audioOutputDevices
=
[
]
;
let
devices
=
[
]
;
let
video
=
aConstraints
.
video
|
|
aConstraints
.
picture
;
let
audio
=
aConstraints
.
audio
;
let
sharingScreen
=
video
&
&
typeof
video
!
=
"
boolean
"
&
&
video
.
mediaSource
!
=
"
camera
"
;
let
sharingAudio
=
audio
&
&
typeof
audio
!
=
"
boolean
"
&
&
audio
.
mediaSource
!
=
"
microphone
"
;
const
hasInherentConstraints
=
(
{
facingMode
groupId
deviceId
}
)
=
>
{
const
id
=
[
deviceId
]
.
flat
(
)
[
0
]
;
return
facingMode
|
|
groupId
|
|
(
id
&
&
id
!
=
"
default
"
)
;
}
;
let
hasInherentAudioConstraints
=
audio
&
&
!
sharingAudio
&
&
[
audio
.
.
.
(
audio
.
advanced
|
|
[
]
)
]
.
some
(
hasInherentConstraints
)
;
let
hasInherentVideoConstraints
=
video
&
&
!
sharingScreen
&
&
[
video
.
.
.
(
video
.
advanced
|
|
[
]
)
]
.
some
(
hasInherentConstraints
)
;
for
(
let
device
of
aDevices
)
{
device
=
device
.
QueryInterface
(
Ci
.
nsIMediaDevice
)
;
let
deviceObject
=
{
name
:
device
.
rawName
deviceIndex
:
devices
.
length
id
:
device
.
rawId
mediaSource
:
device
.
mediaSource
}
;
switch
(
device
.
type
)
{
case
"
audioinput
"
:
if
(
audio
&
&
(
device
.
mediaSource
=
=
"
microphone
"
)
!
=
sharingAudio
)
{
audioInputDevices
.
push
(
deviceObject
)
;
devices
.
push
(
device
)
;
}
break
;
case
"
videoinput
"
:
if
(
video
&
&
(
device
.
mediaSource
=
=
"
camera
"
)
!
=
sharingScreen
)
{
if
(
device
.
scary
)
{
deviceObject
.
scary
=
true
;
}
videoInputDevices
.
push
(
deviceObject
)
;
devices
.
push
(
device
)
;
}
break
;
case
"
audiooutput
"
:
if
(
aRequestType
=
=
"
selectaudiooutput
"
)
{
audioOutputDevices
.
push
(
deviceObject
)
;
devices
.
push
(
device
)
;
}
break
;
}
}
let
requestTypes
=
[
]
;
if
(
videoInputDevices
.
length
)
{
requestTypes
.
push
(
sharingScreen
?
"
Screen
"
:
"
Camera
"
)
;
}
if
(
audioInputDevices
.
length
)
{
requestTypes
.
push
(
sharingAudio
?
"
AudioCapture
"
:
"
Microphone
"
)
;
}
if
(
audioOutputDevices
.
length
)
{
requestTypes
.
push
(
"
Speaker
"
)
;
}
if
(
!
requestTypes
.
length
)
{
denyGUMRequest
(
{
callID
:
aCallID
}
)
;
return
;
}
if
(
!
aContentWindow
.
pendingGetUserMediaRequests
)
{
setupPendingListsInitially
(
aContentWindow
)
;
}
aContentWindow
.
pendingGetUserMediaRequests
.
set
(
aCallID
devices
)
;
const
permDelegateHandler
=
aContentWindow
.
document
.
permDelegateHandler
.
QueryInterface
(
Ci
.
nsIPermissionDelegateHandler
)
;
const
shouldDelegatePermission
=
permDelegateHandler
.
permissionDelegateFPEnabled
;
let
secondOrigin
=
undefined
;
if
(
shouldDelegatePermission
&
&
permDelegateHandler
.
maybeUnsafePermissionDelegate
(
requestTypes
)
)
{
secondOrigin
=
aContentWindow
.
document
.
nodePrincipal
.
origin
;
}
let
request
=
{
callID
:
aCallID
windowID
:
aWindowID
secondOrigin
documentURI
:
aContentWindow
.
document
.
documentURI
secure
:
aSecure
isHandlingUserInput
:
aIsHandlingUserInput
shouldDelegatePermission
requestTypes
sharingScreen
sharingAudio
audioInputDevices
videoInputDevices
audioOutputDevices
hasInherentAudioConstraints
hasInherentVideoConstraints
}
;
let
actor
=
getActorForWindow
(
aContentWindow
)
;
if
(
actor
)
{
actor
.
sendAsyncMessage
(
"
webrtc
:
Request
"
request
)
;
}
}
function
denyGUMRequest
(
aData
)
{
let
subject
;
if
(
aData
.
noOSPermission
)
{
subject
=
"
getUserMedia
:
response
:
noOSPermission
"
;
}
else
{
subject
=
"
getUserMedia
:
response
:
deny
"
;
}
Services
.
obs
.
notifyObservers
(
null
subject
aData
.
callID
)
;
if
(
!
aData
.
windowID
)
{
return
;
}
let
contentWindow
=
Services
.
wm
.
getOuterWindowWithId
(
aData
.
windowID
)
;
if
(
contentWindow
.
pendingGetUserMediaRequests
)
{
forgetGUMRequest
(
contentWindow
aData
.
callID
)
;
}
}
function
forgetGUMRequest
(
aContentWindow
aCallID
)
{
aContentWindow
.
pendingGetUserMediaRequests
.
delete
(
aCallID
)
;
forgetPendingListsEventually
(
aContentWindow
)
;
}
function
forgetPCRequest
(
aContentWindow
aCallID
)
{
aContentWindow
.
pendingPeerConnectionRequests
.
delete
(
aCallID
)
;
forgetPendingListsEventually
(
aContentWindow
)
;
}
function
setupPendingListsInitially
(
aContentWindow
)
{
if
(
aContentWindow
.
pendingGetUserMediaRequests
)
{
return
;
}
aContentWindow
.
pendingGetUserMediaRequests
=
new
Map
(
)
;
aContentWindow
.
pendingPeerConnectionRequests
=
new
Set
(
)
;
aContentWindow
.
addEventListener
(
"
unload
"
WebRTCChild
.
handleEvent
)
;
}
function
forgetPendingListsEventually
(
aContentWindow
)
{
if
(
aContentWindow
.
pendingGetUserMediaRequests
.
size
|
|
aContentWindow
.
pendingPeerConnectionRequests
.
size
)
{
return
;
}
aContentWindow
.
pendingGetUserMediaRequests
=
null
;
aContentWindow
.
pendingPeerConnectionRequests
=
null
;
aContentWindow
.
removeEventListener
(
"
unload
"
WebRTCChild
.
handleEvent
)
;
}
function
updateIndicators
(
aSubject
aTopic
aData
)
{
if
(
aSubject
instanceof
Ci
.
nsIPropertyBag
&
&
aSubject
.
getProperty
(
"
requestURL
"
)
=
=
kBrowserURL
)
{
return
;
}
let
contentWindow
=
aSubject
.
getProperty
(
"
window
"
)
;
let
actor
=
contentWindow
?
getActorForWindow
(
contentWindow
)
:
null
;
if
(
actor
)
{
let
tabState
=
getTabStateForContentWindow
(
contentWindow
false
)
;
tabState
.
windowId
=
getInnerWindowIDForWindow
(
contentWindow
)
;
if
(
actor
.
suppressNotifications
)
{
if
(
!
tabState
.
screen
&
&
!
tabState
.
window
&
&
!
tabState
.
browser
)
{
actor
.
suppressNotifications
=
false
;
}
}
tabState
.
suppressNotifications
=
actor
.
suppressNotifications
;
actor
.
sendAsyncMessage
(
"
webrtc
:
UpdateIndicators
"
tabState
)
;
}
}
function
removeBrowserSpecificIndicator
(
aSubject
aTopic
aData
)
{
let
contentWindow
=
Services
.
wm
.
getOuterWindowWithId
(
aData
)
;
if
(
contentWindow
.
document
.
documentURI
=
=
kBrowserURL
)
{
return
;
}
let
tabState
=
getTabStateForContentWindow
(
contentWindow
true
)
;
tabState
.
windowId
=
aData
;
let
actor
=
getActorForWindow
(
contentWindow
)
;
if
(
actor
)
{
actor
.
sendAsyncMessage
(
"
webrtc
:
UpdateIndicators
"
tabState
)
;
}
}
function
getTabStateForContentWindow
(
aContentWindow
aForRemove
=
false
)
{
let
camera
=
{
}
microphone
=
{
}
screen
=
{
}
window
=
{
}
browser
=
{
}
devices
=
{
}
;
MediaManagerService
.
mediaCaptureWindowState
(
aContentWindow
camera
microphone
screen
window
browser
devices
)
;
if
(
camera
.
value
=
=
MediaManagerService
.
STATE_NOCAPTURE
&
&
microphone
.
value
=
=
MediaManagerService
.
STATE_NOCAPTURE
&
&
screen
.
value
=
=
MediaManagerService
.
STATE_NOCAPTURE
&
&
window
.
value
=
=
MediaManagerService
.
STATE_NOCAPTURE
&
&
browser
.
value
=
=
MediaManagerService
.
STATE_NOCAPTURE
)
{
return
{
remove
:
true
}
;
}
if
(
aForRemove
)
{
return
{
remove
:
true
}
;
}
let
serializedDevices
=
[
]
;
if
(
Array
.
isArray
(
devices
.
value
)
)
{
serializedDevices
=
devices
.
value
.
map
(
device
=
>
{
return
{
type
:
device
.
type
mediaSource
:
device
.
mediaSource
rawId
:
device
.
rawId
scary
:
device
.
scary
}
;
}
)
;
}
return
{
camera
:
camera
.
value
microphone
:
microphone
.
value
screen
:
screen
.
value
window
:
window
.
value
browser
:
browser
.
value
devices
:
serializedDevices
}
;
}
function
getInnerWindowIDForWindow
(
aContentWindow
)
{
return
aContentWindow
.
windowGlobalChild
.
innerWindowId
;
}
