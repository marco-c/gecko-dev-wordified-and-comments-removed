var
EXPORTED_SYMBOLS
=
[
"
ClickHandlerChild
"
"
MiddleMousePasteHandlerChild
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PrivateBrowsingUtils
"
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
WebNavigationFrames
"
"
resource
:
/
/
gre
/
modules
/
WebNavigationFrames
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
E10SUtils
"
"
resource
:
/
/
gre
/
modules
/
E10SUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
BrowserUtils
"
"
resource
:
/
/
gre
/
modules
/
BrowserUtils
.
jsm
"
)
;
class
MiddleMousePasteHandlerChild
extends
JSWindowActorChild
{
handleEvent
(
clickEvent
)
{
if
(
clickEvent
.
defaultPrevented
|
|
clickEvent
.
button
!
=
1
|
|
MiddleMousePasteHandlerChild
.
autoscrollEnabled
)
{
return
;
}
this
.
manager
.
getActor
(
"
ClickHandler
"
)
.
handleClickEvent
(
clickEvent
true
)
;
}
onProcessedClick
(
data
)
{
this
.
sendAsyncMessage
(
"
MiddleClickPaste
"
data
)
;
}
}
XPCOMUtils
.
defineLazyPreferenceGetter
(
MiddleMousePasteHandlerChild
"
autoscrollEnabled
"
"
general
.
autoScroll
"
true
)
;
class
ClickHandlerChild
extends
JSWindowActorChild
{
handleEvent
(
wrapperEvent
)
{
this
.
handleClickEvent
(
wrapperEvent
.
sourceEvent
)
;
}
handleClickEvent
(
event
isFromMiddleMousePasteHandler
=
false
)
{
if
(
event
.
defaultPrevented
|
|
event
.
button
=
=
2
)
{
return
;
}
let
composedTarget
=
event
.
composedTarget
;
if
(
composedTarget
.
isContentEditable
|
|
(
composedTarget
.
ownerDocument
&
&
composedTarget
.
ownerDocument
.
designMode
=
=
"
on
"
)
|
|
ChromeUtils
.
getClassName
(
composedTarget
)
=
=
"
HTMLInputElement
"
|
|
ChromeUtils
.
getClassName
(
composedTarget
)
=
=
"
HTMLTextAreaElement
"
)
{
return
;
}
let
originalTarget
=
event
.
originalTarget
;
let
ownerDoc
=
originalTarget
.
ownerDocument
;
if
(
!
ownerDoc
)
{
return
;
}
if
(
event
.
button
=
=
0
)
{
if
(
ownerDoc
.
documentURI
.
startsWith
(
"
about
:
blocked
"
)
)
{
return
;
}
}
if
(
!
event
.
isTrusted
&
&
!
ownerDoc
.
hasValidTransientUserGestureActivation
)
{
return
;
}
let
[
href
node
principal
]
=
BrowserUtils
.
hrefAndLinkNodeForClickEvent
(
event
)
;
let
csp
=
ownerDoc
.
csp
;
if
(
csp
)
{
csp
=
E10SUtils
.
serializeCSP
(
csp
)
;
}
let
referrerInfo
=
Cc
[
"
mozilla
.
org
/
referrer
-
info
;
1
"
]
.
createInstance
(
Ci
.
nsIReferrerInfo
)
;
if
(
node
)
{
referrerInfo
.
initWithElement
(
node
)
;
}
else
{
referrerInfo
.
initWithDocument
(
ownerDoc
)
;
}
referrerInfo
=
E10SUtils
.
serializeReferrerInfo
(
referrerInfo
)
;
let
frameID
=
WebNavigationFrames
.
getFrameId
(
ownerDoc
.
defaultView
)
;
let
json
=
{
button
:
event
.
button
shiftKey
:
event
.
shiftKey
ctrlKey
:
event
.
ctrlKey
metaKey
:
event
.
metaKey
altKey
:
event
.
altKey
href
:
null
title
:
null
frameID
triggeringPrincipal
:
principal
csp
referrerInfo
originAttributes
:
principal
?
principal
.
originAttributes
:
{
}
isContentWindowPrivate
:
PrivateBrowsingUtils
.
isContentWindowPrivate
(
ownerDoc
.
defaultView
)
}
;
if
(
href
&
&
!
isFromMiddleMousePasteHandler
)
{
try
{
Services
.
scriptSecurityManager
.
checkLoadURIStrWithPrincipal
(
principal
href
)
;
}
catch
(
e
)
{
return
;
}
if
(
!
event
.
isTrusted
&
&
BrowserUtils
.
whereToOpenLink
(
event
)
!
=
"
current
"
)
{
ownerDoc
.
consumeTransientUserGestureActivation
(
)
;
}
json
.
href
=
href
;
if
(
node
)
{
json
.
title
=
node
.
getAttribute
(
"
title
"
)
;
}
json
.
originPrincipal
=
ownerDoc
.
nodePrincipal
;
json
.
originStoragePrincipal
=
ownerDoc
.
effectiveStoragePrincipal
;
json
.
triggeringPrincipal
=
ownerDoc
.
nodePrincipal
;
event
.
preventMultipleActions
(
)
;
this
.
sendAsyncMessage
(
"
Content
:
Click
"
json
)
;
}
if
(
!
href
&
&
event
.
button
=
=
1
&
&
isFromMiddleMousePasteHandler
)
{
this
.
manager
.
getActor
(
"
MiddleMousePasteHandler
"
)
.
onProcessedClick
(
json
)
;
}
}
}
