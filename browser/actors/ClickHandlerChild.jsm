var
EXPORTED_SYMBOLS
=
[
"
ClickHandlerChild
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PrivateBrowsingUtils
"
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
WebNavigationFrames
"
"
resource
:
/
/
gre
/
modules
/
WebNavigationFrames
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
E10SUtils
"
"
resource
:
/
/
gre
/
modules
/
E10SUtils
.
jsm
"
)
;
class
ClickHandlerChild
extends
JSWindowActorChild
{
handleEvent
(
event
)
{
if
(
!
event
.
isTrusted
|
|
event
.
defaultPrevented
|
|
event
.
button
=
=
2
|
|
(
event
.
type
=
=
"
click
"
&
&
event
.
button
=
=
1
)
)
{
return
;
}
let
composedTarget
=
event
.
composedTarget
;
if
(
composedTarget
.
isContentEditable
|
|
(
composedTarget
.
ownerDocument
&
&
composedTarget
.
ownerDocument
.
designMode
=
=
"
on
"
)
|
|
ChromeUtils
.
getClassName
(
composedTarget
)
=
=
"
HTMLInputElement
"
|
|
ChromeUtils
.
getClassName
(
composedTarget
)
=
=
"
HTMLTextAreaElement
"
)
{
return
;
}
let
originalTarget
=
event
.
originalTarget
;
let
ownerDoc
=
originalTarget
.
ownerDocument
;
if
(
!
ownerDoc
)
{
return
;
}
if
(
event
.
button
=
=
0
)
{
if
(
ownerDoc
.
documentURI
.
startsWith
(
"
about
:
blocked
"
)
)
{
return
;
}
}
let
[
href
node
principal
]
=
this
.
_hrefAndLinkNodeForClickEvent
(
event
)
;
let
csp
=
ownerDoc
.
csp
;
if
(
csp
)
{
csp
=
E10SUtils
.
serializeCSP
(
csp
)
;
}
let
referrerInfo
=
Cc
[
"
mozilla
.
org
/
referrer
-
info
;
1
"
]
.
createInstance
(
Ci
.
nsIReferrerInfo
)
;
if
(
node
)
{
referrerInfo
.
initWithElement
(
node
)
;
}
else
{
referrerInfo
.
initWithDocument
(
ownerDoc
)
;
}
referrerInfo
=
E10SUtils
.
serializeReferrerInfo
(
referrerInfo
)
;
let
frameID
=
WebNavigationFrames
.
getFrameId
(
ownerDoc
.
defaultView
)
;
let
json
=
{
button
:
event
.
button
shiftKey
:
event
.
shiftKey
ctrlKey
:
event
.
ctrlKey
metaKey
:
event
.
metaKey
altKey
:
event
.
altKey
href
:
null
title
:
null
frameID
triggeringPrincipal
:
principal
csp
referrerInfo
originAttributes
:
principal
?
principal
.
originAttributes
:
{
}
isContentWindowPrivate
:
PrivateBrowsingUtils
.
isContentWindowPrivate
(
ownerDoc
.
defaultView
)
}
;
if
(
href
)
{
try
{
Services
.
scriptSecurityManager
.
checkLoadURIStrWithPrincipal
(
principal
href
)
;
}
catch
(
e
)
{
return
;
}
json
.
href
=
href
;
if
(
node
)
{
json
.
title
=
node
.
getAttribute
(
"
title
"
)
;
}
json
.
originPrincipal
=
ownerDoc
.
nodePrincipal
;
json
.
originStoragePrincipal
=
ownerDoc
.
effectiveStoragePrincipal
;
json
.
triggeringPrincipal
=
ownerDoc
.
nodePrincipal
;
if
(
event
.
button
=
=
=
1
)
{
event
.
preventMultipleActions
(
)
;
}
this
.
sendAsyncMessage
(
"
Content
:
Click
"
json
)
;
return
;
}
if
(
event
.
button
=
=
1
)
{
this
.
sendAsyncMessage
(
"
Content
:
Click
"
json
)
;
}
}
_hrefAndLinkNodeForClickEvent
(
event
)
{
let
content
=
this
.
contentWindow
;
function
isHTMLLink
(
aNode
)
{
return
(
(
aNode
instanceof
content
.
HTMLAnchorElement
&
&
aNode
.
href
)
|
|
(
aNode
instanceof
content
.
HTMLAreaElement
&
&
aNode
.
href
)
|
|
aNode
instanceof
content
.
HTMLLinkElement
)
;
}
let
node
=
event
.
composedTarget
;
while
(
node
&
&
!
isHTMLLink
(
node
)
)
{
node
=
node
.
flattenedTreeParentNode
;
}
if
(
node
)
{
return
[
node
.
href
node
node
.
ownerDocument
.
nodePrincipal
]
;
}
let
href
baseURI
;
node
=
event
.
composedTarget
;
while
(
node
&
&
!
href
)
{
if
(
node
.
nodeType
=
=
content
.
Node
.
ELEMENT_NODE
&
&
(
node
.
localName
=
=
"
a
"
|
|
node
.
namespaceURI
=
=
"
http
:
/
/
www
.
w3
.
org
/
1998
/
Math
/
MathML
"
)
)
{
href
=
node
.
getAttribute
(
"
href
"
)
|
|
node
.
getAttributeNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xlink
"
"
href
"
)
;
if
(
href
)
{
baseURI
=
node
.
ownerDocument
.
baseURIObject
;
break
;
}
}
node
=
node
.
flattenedTreeParentNode
;
}
return
[
href
?
Services
.
io
.
newURI
(
href
null
baseURI
)
.
spec
:
null
null
node
&
&
node
.
ownerDocument
.
nodePrincipal
]
;
}
}
