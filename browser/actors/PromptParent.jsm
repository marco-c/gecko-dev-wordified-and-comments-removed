"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
PromptParent
"
]
;
ChromeUtils
.
defineModuleGetter
(
this
"
PromptUtils
"
"
resource
:
/
/
gre
/
modules
/
SharedPromptUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Services
"
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
tabChromePromptSubDialog
"
"
prompts
.
tabChromePromptSubDialog
"
false
)
;
let
gBrowserPrompts
=
new
WeakMap
(
)
;
class
PromptParent
extends
JSWindowActorParent
{
didDestroy
(
)
{
this
.
forceClosePrompts
(
)
;
}
registerPrompt
(
tabModalPrompt
id
)
{
let
prompts
=
gBrowserPrompts
.
get
(
this
.
browsingContext
)
;
if
(
!
prompts
)
{
prompts
=
new
Map
(
)
;
gBrowserPrompts
.
set
(
this
.
browsingContext
prompts
)
;
}
let
promise
=
new
Promise
(
resolve
=
>
{
prompts
.
set
(
id
{
tabModalPrompt
resolver
:
resolve
}
)
;
}
)
;
return
promise
;
}
unregisterPrompt
(
id
)
{
let
prompts
=
gBrowserPrompts
.
get
(
this
.
browsingContext
)
;
if
(
prompts
)
{
prompts
.
delete
(
id
)
;
}
}
forceClosePrompts
(
)
{
let
prompts
=
gBrowserPrompts
.
get
(
this
.
browsingContext
)
|
|
[
]
;
for
(
let
[
prompt
]
of
prompts
)
{
prompt
.
tabModalPrompt
&
&
prompt
.
tabModalPrompt
.
abortPrompt
(
)
;
}
}
receiveMessage
(
message
)
{
let
args
=
message
.
data
;
let
id
=
args
.
_remoteId
;
switch
(
message
.
name
)
{
case
"
Prompt
:
Open
"
:
{
if
(
args
.
modalType
=
=
=
Ci
.
nsIPrompt
.
MODAL_TYPE_CONTENT
|
|
(
args
.
modalType
=
=
=
Ci
.
nsIPrompt
.
MODAL_TYPE_TAB
&
&
!
tabChromePromptSubDialog
)
)
{
return
this
.
openContentPrompt
(
args
id
)
;
}
return
this
.
openChromePrompt
(
args
)
;
}
}
return
undefined
;
}
openContentPrompt
(
args
id
)
{
let
browser
=
this
.
browsingContext
.
top
.
embedderElement
;
if
(
!
browser
)
{
throw
new
Error
(
"
Cannot
tab
-
prompt
without
a
browser
!
"
)
;
}
let
window
=
browser
.
ownerGlobal
;
let
tabPrompt
=
window
.
gBrowser
.
getTabModalPromptBox
(
browser
)
;
let
newPrompt
;
let
needRemove
=
false
;
args
.
showCallerOrigin
=
args
.
promptPrincipal
&
&
!
browser
.
contentPrincipal
.
equals
(
args
.
promptPrincipal
)
;
let
onPromptClose
=
(
)
=
>
{
let
promptData
=
gBrowserPrompts
.
get
(
this
.
browsingContext
)
;
if
(
!
promptData
|
|
!
promptData
.
has
(
id
)
)
{
throw
new
Error
(
"
Failed
to
close
a
prompt
since
it
wasn
'
t
registered
for
some
reason
.
"
)
;
}
let
{
resolver
tabModalPrompt
}
=
promptData
.
get
(
id
)
;
if
(
tabModalPrompt
)
{
tabPrompt
.
removePrompt
(
tabModalPrompt
)
;
}
else
{
needRemove
=
true
;
}
this
.
unregisterPrompt
(
id
)
;
PromptUtils
.
fireDialogEvent
(
window
"
DOMModalDialogClosed
"
browser
{
wasPermitUnload
:
args
.
inPermitUnload
areLeaving
:
args
.
ok
}
)
;
resolver
(
args
)
;
browser
.
maybeLeaveModalState
(
)
;
}
;
try
{
browser
.
enterModalState
(
)
;
let
eventDetail
=
{
tabPrompt
:
true
promptPrincipal
:
args
.
promptPrincipal
inPermitUnload
:
args
.
inPermitUnload
}
;
PromptUtils
.
fireDialogEvent
(
window
"
DOMWillOpenModalDialog
"
browser
eventDetail
)
;
args
.
promptActive
=
true
;
newPrompt
=
tabPrompt
.
appendPrompt
(
args
onPromptClose
)
;
let
promise
=
this
.
registerPrompt
(
newPrompt
id
)
;
if
(
needRemove
)
{
tabPrompt
.
removePrompt
(
newPrompt
)
;
}
return
promise
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
onPromptClose
(
true
)
;
}
return
null
;
}
async
openChromePrompt
(
args
)
{
const
COMMON_DIALOG
=
"
chrome
:
/
/
global
/
content
/
commonDialog
.
xhtml
"
;
const
SELECT_DIALOG
=
"
chrome
:
/
/
global
/
content
/
selectDialog
.
xhtml
"
;
let
uri
=
args
.
promptType
=
=
"
select
"
?
SELECT_DIALOG
:
COMMON_DIALOG
;
let
browsingContext
=
this
.
browsingContext
.
top
;
let
browser
=
browsingContext
.
embedderElement
;
let
win
;
if
(
!
browsingContext
.
isContent
&
&
browsingContext
.
window
)
{
win
=
browsingContext
.
window
;
}
else
{
win
=
browser
?
.
ownerGlobal
;
}
if
(
win
?
.
winUtils
&
&
!
win
.
winUtils
.
isParentWindowMainWidgetVisible
)
{
throw
new
Error
(
"
Cannot
call
openModalWindow
on
a
hidden
window
"
)
;
}
try
{
if
(
browser
)
{
browser
.
enterModalState
(
)
;
PromptUtils
.
fireDialogEvent
(
win
"
DOMWillOpenModalDialog
"
browser
)
;
}
args
.
promptAborted
=
false
;
let
bag
=
PromptUtils
.
objectToPropBag
(
args
)
;
if
(
args
.
modalType
=
=
=
Services
.
prompt
.
MODAL_TYPE_TAB
)
{
if
(
!
browser
)
{
throw
new
Error
(
"
Cannot
tab
-
prompt
without
a
browser
!
"
)
;
}
let
dialogBox
=
win
.
gBrowser
.
getTabDialogBox
(
browser
)
;
await
dialogBox
.
open
(
uri
{
features
:
"
resizable
=
no
"
}
bag
)
;
}
else
{
Services
.
ww
.
openWindow
(
win
uri
"
_blank
"
"
centerscreen
chrome
modal
titlebar
"
bag
)
;
}
PromptUtils
.
propBagToObject
(
bag
args
)
;
}
finally
{
if
(
browser
)
{
browser
.
leaveModalState
(
)
;
PromptUtils
.
fireDialogEvent
(
win
"
DOMModalDialogClosed
"
browser
)
;
}
}
return
args
;
}
}
