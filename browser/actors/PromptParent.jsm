"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
PromptParent
"
]
;
ChromeUtils
.
defineModuleGetter
(
this
"
PromptUtils
"
"
resource
:
/
/
gre
/
modules
/
SharedPromptUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Services
"
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
let
gBrowserPrompts
=
new
WeakMap
(
)
;
class
PromptParent
extends
JSWindowActorParent
{
didDestroy
(
)
{
this
.
forceClosePrompts
(
this
.
browsingContext
)
;
}
registerPrompt
(
browsingContext
tabModalPrompt
id
)
{
let
prompts
=
gBrowserPrompts
.
get
(
browsingContext
)
;
if
(
!
prompts
)
{
prompts
=
new
Map
(
)
;
gBrowserPrompts
.
set
(
browsingContext
prompts
)
;
}
let
promise
=
new
Promise
(
resolve
=
>
{
prompts
.
set
(
id
{
tabModalPrompt
resolver
:
resolve
}
)
;
}
)
;
return
promise
;
}
unregisterPrompt
(
browsingContext
id
)
{
let
prompts
=
gBrowserPrompts
.
get
(
browsingContext
)
;
if
(
prompts
)
{
prompts
.
delete
(
id
)
;
}
}
forceClosePrompt
(
browsingContext
id
)
{
let
prompts
=
gBrowserPrompts
.
get
(
browsingContext
)
;
let
prompt
=
prompts
.
get
(
id
)
;
if
(
prompt
&
&
prompt
.
tabModalPrompt
)
{
prompt
.
tabModalPrompt
.
abortPrompt
(
)
;
}
}
forceClosePrompts
(
browsingContext
)
{
let
prompts
=
gBrowserPrompts
.
get
(
browsingContext
)
|
|
[
]
;
for
(
let
[
prompt
]
of
prompts
)
{
prompt
.
tabModalPrompt
&
&
prompt
.
tabModalPrompt
.
abortPrompt
(
)
;
}
}
receiveMessage
(
message
)
{
let
args
=
message
.
data
;
let
browsingContext
=
args
.
browsingContext
|
|
this
.
browsingContext
;
let
id
=
args
.
_remoteId
;
switch
(
message
.
name
)
{
case
"
Prompt
:
Open
"
:
{
let
topPrincipal
=
browsingContext
.
top
.
currentWindowGlobal
.
documentPrincipal
;
args
.
showAlertOrigin
=
topPrincipal
.
equals
(
args
.
promptPrincipal
)
;
if
(
args
.
modalType
=
=
=
Ci
.
nsIPrompt
.
MODAL_TYPE_WINDOW
)
{
return
this
.
openWindowPrompt
(
args
browsingContext
)
;
}
return
this
.
openTabPrompt
(
args
browsingContext
id
)
;
}
case
"
Prompt
:
ForceClose
"
:
{
this
.
forceClosePrompt
(
browsingContext
id
)
;
break
;
}
case
"
Prompt
:
OnPageHide
"
:
{
this
.
forceClosePrompts
(
browsingContext
)
;
break
;
}
}
return
undefined
;
}
openTabPrompt
(
args
browsingContext
=
this
.
browsingContext
id
)
{
let
browser
=
browsingContext
.
top
.
embedderElement
;
if
(
!
browser
)
{
throw
new
Error
(
"
Cannot
tab
-
prompt
without
a
browser
!
"
)
;
}
let
window
=
browser
.
ownerGlobal
;
let
tabPrompt
=
window
.
gBrowser
.
getTabModalPromptBox
(
browser
)
;
let
newPrompt
;
let
needRemove
=
false
;
let
onPromptClose
=
forceCleanup
=
>
{
let
promptData
=
gBrowserPrompts
.
get
(
browsingContext
)
;
if
(
!
promptData
|
|
!
promptData
.
has
(
id
)
)
{
throw
new
Error
(
"
Failed
to
close
a
prompt
since
it
wasn
'
t
registered
for
some
reason
.
"
)
;
}
let
{
resolver
tabModalPrompt
}
=
promptData
.
get
(
id
)
;
if
(
tabModalPrompt
)
{
tabPrompt
.
removePrompt
(
tabModalPrompt
)
;
}
else
{
needRemove
=
true
;
}
this
.
unregisterPrompt
(
browsingContext
id
)
;
PromptUtils
.
fireDialogEvent
(
window
"
DOMModalDialogClosed
"
browser
)
;
resolver
(
args
)
;
browser
.
maybeLeaveModalState
(
)
;
}
;
try
{
browser
.
enterModalState
(
)
;
let
eventDetail
=
{
tabPrompt
:
true
promptPrincipal
:
args
.
promptPrincipal
inPermitUnload
:
args
.
inPermitUnload
}
;
PromptUtils
.
fireDialogEvent
(
window
"
DOMWillOpenModalDialog
"
browser
eventDetail
)
;
args
.
promptActive
=
true
;
newPrompt
=
tabPrompt
.
appendPrompt
(
args
onPromptClose
)
;
let
promise
=
this
.
registerPrompt
(
browsingContext
newPrompt
id
)
;
if
(
needRemove
)
{
tabPrompt
.
removePrompt
(
newPrompt
)
;
}
return
promise
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
onPromptClose
(
true
)
;
}
return
null
;
}
openWindowPrompt
(
args
browsingContext
=
this
.
browsingContext
)
{
const
COMMON_DIALOG
=
"
chrome
:
/
/
global
/
content
/
commonDialog
.
xhtml
"
;
const
SELECT_DIALOG
=
"
chrome
:
/
/
global
/
content
/
selectDialog
.
xhtml
"
;
let
uri
=
args
.
promptType
=
=
"
select
"
?
SELECT_DIALOG
:
COMMON_DIALOG
;
let
browser
=
browsingContext
.
top
.
embedderElement
;
let
win
=
(
browser
&
&
browser
.
ownerGlobal
)
|
|
browsingContext
.
top
.
window
;
if
(
win
&
&
win
.
winUtils
&
&
!
win
.
winUtils
.
isParentWindowMainWidgetVisible
)
{
throw
new
Error
(
"
Cannot
call
openModalWindow
on
a
hidden
window
"
)
;
}
try
{
if
(
browser
)
{
browser
.
enterModalState
(
)
;
PromptUtils
.
fireDialogEvent
(
win
"
DOMWillOpenModalDialog
"
browser
)
;
}
let
bag
=
PromptUtils
.
objectToPropBag
(
args
)
;
Services
.
ww
.
openWindow
(
win
uri
"
_blank
"
"
centerscreen
chrome
modal
titlebar
"
bag
)
;
PromptUtils
.
propBagToObject
(
bag
args
)
;
}
finally
{
if
(
browser
)
{
browser
.
leaveModalState
(
)
;
PromptUtils
.
fireDialogEvent
(
win
"
DOMModalDialogClosed
"
browser
)
;
}
}
return
Promise
.
resolve
(
args
)
;
}
}
