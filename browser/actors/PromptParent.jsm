"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
PromptParent
"
]
;
const
lazy
=
{
}
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
PromptUtils
"
"
resource
:
/
/
gre
/
modules
/
SharedPromptUtils
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
lazy
"
tabChromePromptSubDialog
"
"
prompts
.
tabChromePromptSubDialog
"
false
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
lazy
"
contentPromptSubDialog
"
"
prompts
.
contentPromptSubDialog
"
false
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
gTabBrowserLocalization
"
(
)
=
>
{
return
new
Localization
(
[
"
browser
/
tabbrowser
.
ftl
"
]
true
)
;
}
)
;
let
gBrowserPrompts
=
new
WeakMap
(
)
;
class
PromptParent
extends
JSWindowActorParent
{
didDestroy
(
)
{
this
.
forceClosePrompts
(
)
;
}
registerPrompt
(
tabModalPrompt
id
)
{
let
prompts
=
gBrowserPrompts
.
get
(
this
.
browsingContext
)
;
if
(
!
prompts
)
{
prompts
=
new
Map
(
)
;
gBrowserPrompts
.
set
(
this
.
browsingContext
prompts
)
;
}
let
promise
=
new
Promise
(
resolve
=
>
{
prompts
.
set
(
id
{
tabModalPrompt
resolver
:
resolve
}
)
;
}
)
;
return
promise
;
}
unregisterPrompt
(
id
)
{
let
prompts
=
gBrowserPrompts
.
get
(
this
.
browsingContext
)
;
if
(
prompts
)
{
prompts
.
delete
(
id
)
;
}
}
forceClosePrompts
(
)
{
let
prompts
=
gBrowserPrompts
.
get
(
this
.
browsingContext
)
|
|
[
]
;
for
(
let
[
prompt
]
of
prompts
)
{
prompt
.
tabModalPrompt
&
&
prompt
.
tabModalPrompt
.
abortPrompt
(
)
;
}
}
isAboutAddonsOptionsPage
(
browsingContext
)
{
const
{
embedderWindowGlobal
name
}
=
browsingContext
;
if
(
!
embedderWindowGlobal
)
{
return
false
;
}
return
(
embedderWindowGlobal
.
documentPrincipal
.
isSystemPrincipal
&
&
embedderWindowGlobal
.
documentURI
.
spec
=
=
=
"
about
:
addons
"
&
&
name
=
=
=
"
addon
-
inline
-
options
"
)
;
}
receiveMessage
(
message
)
{
let
args
=
message
.
data
;
let
id
=
args
.
_remoteId
;
switch
(
message
.
name
)
{
case
"
Prompt
:
Open
"
:
{
if
(
(
args
.
modalType
=
=
=
Ci
.
nsIPrompt
.
MODAL_TYPE_CONTENT
&
&
!
lazy
.
contentPromptSubDialog
)
|
|
(
args
.
modalType
=
=
=
Ci
.
nsIPrompt
.
MODAL_TYPE_TAB
&
&
!
lazy
.
tabChromePromptSubDialog
)
|
|
this
.
isAboutAddonsOptionsPage
(
this
.
browsingContext
)
)
{
return
this
.
openContentPrompt
(
args
id
)
;
}
return
this
.
openPromptWithTabDialogBox
(
args
)
;
}
}
return
undefined
;
}
openContentPrompt
(
args
id
)
{
let
browser
=
this
.
browsingContext
.
top
.
embedderElement
;
if
(
!
browser
)
{
throw
new
Error
(
"
Cannot
tab
-
prompt
without
a
browser
!
"
)
;
}
let
window
=
browser
.
ownerGlobal
;
let
tabPrompt
=
window
.
gBrowser
.
getTabModalPromptBox
(
browser
)
;
let
newPrompt
;
let
needRemove
=
false
;
args
.
showCallerOrigin
=
args
.
promptPrincipal
&
&
!
browser
.
contentPrincipal
.
equals
(
args
.
promptPrincipal
)
;
let
onPromptClose
=
(
)
=
>
{
let
promptData
=
gBrowserPrompts
.
get
(
this
.
browsingContext
)
;
if
(
!
promptData
|
|
!
promptData
.
has
(
id
)
)
{
throw
new
Error
(
"
Failed
to
close
a
prompt
since
it
wasn
'
t
registered
for
some
reason
.
"
)
;
}
let
{
resolver
tabModalPrompt
}
=
promptData
.
get
(
id
)
;
if
(
tabModalPrompt
)
{
tabPrompt
.
removePrompt
(
tabModalPrompt
)
;
}
else
{
needRemove
=
true
;
}
this
.
unregisterPrompt
(
id
)
;
lazy
.
PromptUtils
.
fireDialogEvent
(
window
"
DOMModalDialogClosed
"
browser
this
.
getClosingEventDetail
(
args
)
)
;
resolver
(
args
)
;
browser
.
maybeLeaveModalState
(
)
;
}
;
try
{
browser
.
enterModalState
(
)
;
lazy
.
PromptUtils
.
fireDialogEvent
(
window
"
DOMWillOpenModalDialog
"
browser
this
.
getOpenEventDetail
(
args
)
)
;
args
.
promptActive
=
true
;
newPrompt
=
tabPrompt
.
appendPrompt
(
args
onPromptClose
)
;
let
promise
=
this
.
registerPrompt
(
newPrompt
id
)
;
if
(
needRemove
)
{
tabPrompt
.
removePrompt
(
newPrompt
)
;
}
return
promise
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
onPromptClose
(
true
)
;
}
return
null
;
}
async
openPromptWithTabDialogBox
(
args
)
{
const
COMMON_DIALOG
=
"
chrome
:
/
/
global
/
content
/
commonDialog
.
xhtml
"
;
const
SELECT_DIALOG
=
"
chrome
:
/
/
global
/
content
/
selectDialog
.
xhtml
"
;
let
uri
=
args
.
promptType
=
=
"
select
"
?
SELECT_DIALOG
:
COMMON_DIALOG
;
let
browsingContext
=
this
.
browsingContext
.
top
;
let
browser
=
browsingContext
.
embedderElement
;
let
promptRequiresBrowser
=
args
.
modalType
=
=
=
Services
.
prompt
.
MODAL_TYPE_TAB
|
|
args
.
modalType
=
=
=
Services
.
prompt
.
MODAL_TYPE_CONTENT
;
if
(
promptRequiresBrowser
&
&
!
browser
)
{
let
modal_type
=
args
.
modalType
=
=
=
Services
.
prompt
.
MODAL_TYPE_TAB
?
"
tab
"
:
"
content
"
;
throw
new
Error
(
Cannot
{
modal_type
}
-
prompt
without
a
browser
!
)
;
}
let
win
;
if
(
!
browsingContext
.
isContent
&
&
browsingContext
.
window
)
{
win
=
browsingContext
.
window
;
}
else
{
win
=
browser
?
.
ownerGlobal
;
}
if
(
win
?
.
winUtils
&
&
!
win
.
winUtils
.
isParentWindowMainWidgetVisible
)
{
throw
new
Error
(
"
Cannot
open
a
prompt
in
a
hidden
window
"
)
;
}
try
{
if
(
browser
)
{
browser
.
enterModalState
(
)
;
lazy
.
PromptUtils
.
fireDialogEvent
(
win
"
DOMWillOpenModalDialog
"
browser
this
.
getOpenEventDetail
(
args
)
)
;
}
args
.
promptAborted
=
false
;
args
.
openedWithTabDialog
=
true
;
let
bag
;
if
(
promptRequiresBrowser
&
&
win
?
.
gBrowser
?
.
getTabDialogBox
)
{
let
dialogBox
=
win
.
gBrowser
.
getTabDialogBox
(
browser
)
;
if
(
dialogBox
.
_allowTabFocusByPromptPrincipal
)
{
this
.
addTabSwitchCheckboxToArgs
(
dialogBox
args
)
;
}
bag
=
lazy
.
PromptUtils
.
objectToPropBag
(
args
)
;
await
dialogBox
.
open
(
uri
{
features
:
"
resizable
=
no
"
modalType
:
args
.
modalType
allowFocusCheckbox
:
args
.
allowFocusCheckbox
}
bag
)
.
closedPromise
;
}
else
{
args
.
modalType
=
Services
.
prompt
.
MODAL_TYPE_WINDOW
;
bag
=
lazy
.
PromptUtils
.
objectToPropBag
(
args
)
;
Services
.
ww
.
openWindow
(
win
uri
"
_blank
"
"
centerscreen
chrome
modal
titlebar
"
bag
)
;
}
lazy
.
PromptUtils
.
propBagToObject
(
bag
args
)
;
}
finally
{
if
(
browser
)
{
browser
.
maybeLeaveModalState
(
)
;
lazy
.
PromptUtils
.
fireDialogEvent
(
win
"
DOMModalDialogClosed
"
browser
this
.
getClosingEventDetail
(
args
)
)
;
}
}
return
args
;
}
getClosingEventDetail
(
args
)
{
let
details
=
args
.
modalType
=
=
=
Services
.
prompt
.
MODAL_TYPE_CONTENT
?
{
wasPermitUnload
:
args
.
inPermitUnload
areLeaving
:
args
.
ok
}
:
null
;
return
details
;
}
getOpenEventDetail
(
args
)
{
let
details
=
args
.
modalType
=
=
=
Services
.
prompt
.
MODAL_TYPE_CONTENT
?
{
inPermitUnload
:
args
.
inPermitUnload
promptPrincipal
:
args
.
promptPrincipal
tabPrompt
:
true
}
:
null
;
return
details
;
}
addTabSwitchCheckboxToArgs
(
dialogBox
args
)
{
let
allowTabFocusByPromptPrincipal
=
dialogBox
.
_allowTabFocusByPromptPrincipal
;
if
(
allowTabFocusByPromptPrincipal
&
&
args
.
modalType
=
=
=
Services
.
prompt
.
MODAL_TYPE_CONTENT
)
{
let
domain
=
allowTabFocusByPromptPrincipal
.
addonPolicy
?
.
name
;
try
{
domain
|
|
=
allowTabFocusByPromptPrincipal
.
URI
.
displayHostPort
;
}
catch
(
ex
)
{
}
domain
|
|
=
allowTabFocusByPromptPrincipal
.
URI
.
prePath
;
let
[
allowFocusMsg
]
=
lazy
.
gTabBrowserLocalization
.
formatMessagesSync
(
[
{
id
:
"
tabbrowser
-
allow
-
dialogs
-
to
-
get
-
focus
"
args
:
{
domain
}
}
]
)
;
let
labelAttr
=
allowFocusMsg
.
attributes
.
find
(
a
=
>
a
.
name
=
=
"
label
"
)
;
if
(
labelAttr
)
{
args
.
allowFocusCheckbox
=
true
;
args
.
checkLabel
=
labelAttr
.
value
;
}
}
}
}
