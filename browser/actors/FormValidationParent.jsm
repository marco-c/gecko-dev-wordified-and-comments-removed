"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
FormValidationParent
"
]
;
const
lazy
=
{
}
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
BrowserWindowTracker
"
"
resource
:
/
/
/
modules
/
BrowserWindowTracker
.
jsm
"
)
;
class
PopupShownObserver
{
_weakContext
=
null
;
constructor
(
browsingContext
)
{
this
.
_weakContext
=
Cu
.
getWeakReference
(
browsingContext
)
;
}
observe
(
subject
topic
data
)
{
let
ctxt
=
this
.
_weakContext
.
get
(
)
;
let
actor
=
ctxt
.
currentWindowGlobal
?
.
getExistingActor
(
"
FormValidation
"
)
;
if
(
!
actor
)
{
Services
.
obs
.
removeObserver
(
this
"
popup
-
shown
"
)
;
return
;
}
if
(
topic
=
=
"
popup
-
shown
"
&
&
subject
!
=
actor
.
_panel
)
{
actor
.
_hidePopup
(
)
;
}
}
QueryInterface
=
ChromeUtils
.
generateQI
(
[
Ci
.
nsIObserver
Ci
.
nsISupportsWeakReference
]
)
;
}
class
FormValidationParent
extends
JSWindowActorParent
{
constructor
(
)
{
super
(
)
;
this
.
_panel
=
null
;
this
.
_obs
=
null
;
}
static
hasOpenPopups
(
)
{
for
(
let
win
of
lazy
.
BrowserWindowTracker
.
orderedWindows
)
{
let
popups
=
win
.
document
.
querySelectorAll
(
"
panel
menupopup
"
)
;
for
(
let
popup
of
popups
)
{
let
{
state
}
=
popup
;
if
(
state
=
=
"
open
"
|
|
state
=
=
"
showing
"
)
{
return
true
;
}
}
}
return
false
;
}
uninit
(
)
{
this
.
_panel
=
null
;
this
.
_obs
=
null
;
}
hidePopup
(
)
{
this
.
_hidePopup
(
)
;
}
receiveMessage
(
aMessage
)
{
switch
(
aMessage
.
name
)
{
case
"
FormValidation
:
ShowPopup
"
:
let
browser
=
this
.
browsingContext
.
top
.
embedderElement
;
let
window
=
browser
.
ownerGlobal
;
let
data
=
aMessage
.
data
;
let
tabBrowser
=
window
.
gBrowser
;
if
(
tabBrowser
&
&
browser
!
=
tabBrowser
.
selectedBrowser
)
{
return
;
}
if
(
FormValidationParent
.
hasOpenPopups
(
)
)
{
return
;
}
this
.
_showPopup
(
data
)
;
break
;
case
"
FormValidation
:
HidePopup
"
:
this
.
_hidePopup
(
)
;
break
;
}
}
handleEvent
(
aEvent
)
{
switch
(
aEvent
.
type
)
{
case
"
FullZoomChange
"
:
case
"
TextZoomChange
"
:
case
"
scroll
"
:
this
.
_hidePopup
(
)
;
break
;
case
"
popuphiding
"
:
this
.
_onPopupHiding
(
aEvent
)
;
break
;
}
}
_onPopupHiding
(
aEvent
)
{
aEvent
.
originalTarget
.
removeEventListener
(
"
popuphiding
"
this
true
)
;
Services
.
obs
.
removeObserver
(
this
.
_obs
"
popup
-
shown
"
)
;
let
tabBrowser
=
aEvent
.
originalTarget
.
ownerGlobal
.
gBrowser
;
tabBrowser
.
selectedBrowser
.
removeEventListener
(
"
scroll
"
this
true
)
;
tabBrowser
.
selectedBrowser
.
removeEventListener
(
"
FullZoomChange
"
this
)
;
tabBrowser
.
selectedBrowser
.
removeEventListener
(
"
TextZoomChange
"
this
)
;
this
.
_obs
=
null
;
this
.
_panel
=
null
;
}
_showPopup
(
aPanelData
)
{
let
previouslyShown
=
!
!
this
.
_panel
;
this
.
_panel
=
this
.
_getAndMaybeCreatePanel
(
)
;
this
.
_panel
.
firstChild
.
textContent
=
aPanelData
.
message
;
let
browser
=
this
.
browsingContext
.
top
.
embedderElement
;
let
window
=
browser
.
ownerGlobal
;
let
tabBrowser
=
window
.
gBrowser
;
if
(
!
previouslyShown
)
{
this
.
_panel
.
addEventListener
(
"
popuphiding
"
this
true
)
;
this
.
_obs
=
new
PopupShownObserver
(
this
.
browsingContext
)
;
Services
.
obs
.
addObserver
(
this
.
_obs
"
popup
-
shown
"
true
)
;
tabBrowser
.
selectedBrowser
.
addEventListener
(
"
scroll
"
this
true
)
;
tabBrowser
.
selectedBrowser
.
addEventListener
(
"
FullZoomChange
"
this
)
;
tabBrowser
.
selectedBrowser
.
addEventListener
(
"
TextZoomChange
"
this
)
;
let
rect
=
aPanelData
.
screenRect
;
this
.
_panel
.
openPopupAtScreenRect
(
aPanelData
.
position
rect
.
left
rect
.
top
rect
.
width
rect
.
height
false
false
)
;
}
}
_hidePopup
(
)
{
this
.
_panel
?
.
hidePopup
(
)
;
}
_getAndMaybeCreatePanel
(
)
{
if
(
!
this
.
_panel
)
{
let
browser
=
this
.
browsingContext
.
top
.
embedderElement
;
let
window
=
browser
.
ownerGlobal
;
let
template
=
window
.
document
.
getElementById
(
"
invalidFormTemplate
"
)
;
if
(
template
)
{
template
.
replaceWith
(
template
.
content
)
;
}
this
.
_panel
=
window
.
document
.
getElementById
(
"
invalid
-
form
-
popup
"
)
;
}
return
this
.
_panel
;
}
}
