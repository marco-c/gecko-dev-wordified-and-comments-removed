"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
DecoderDoctorParent
"
]
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gNavigatorBundle
"
function
(
)
{
return
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
browser
/
locale
/
browser
.
properties
"
)
;
}
)
;
class
DecoderDoctorParent
extends
JSWindowActorParent
{
getLabelForNotificationBox
(
type
)
{
if
(
type
=
=
"
platform
-
decoder
-
not
-
found
"
)
{
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
return
gNavigatorBundle
.
GetStringFromName
(
"
decoder
.
noHWAcceleration
.
message
"
)
;
}
if
(
AppConstants
.
platform
=
=
"
linux
"
)
{
return
gNavigatorBundle
.
GetStringFromName
(
"
decoder
.
noCodecsLinux
.
message
"
)
;
}
}
if
(
type
=
=
"
cannot
-
initialize
-
pulseaudio
"
)
{
return
gNavigatorBundle
.
GetStringFromName
(
"
decoder
.
noPulseAudio
.
message
"
)
;
}
if
(
type
=
=
"
unsupported
-
libavcodec
"
&
&
AppConstants
.
platform
=
=
"
linux
"
)
{
return
gNavigatorBundle
.
GetStringFromName
(
"
decoder
.
unsupportedLibavcodec
.
message
"
)
;
}
if
(
type
=
=
"
decode
-
error
"
)
{
return
gNavigatorBundle
.
GetStringFromName
(
"
decoder
.
decodeError
.
message
"
)
;
}
if
(
type
=
=
"
decode
-
warning
"
)
{
return
gNavigatorBundle
.
GetStringFromName
(
"
decoder
.
decodeWarning
.
message
"
)
;
}
return
"
"
;
}
getSumoForLearnHowButton
(
type
)
{
if
(
type
=
=
"
platform
-
decoder
-
not
-
found
"
&
&
AppConstants
.
platform
=
=
"
win
"
)
{
return
"
fix
-
video
-
audio
-
problems
-
firefox
-
windows
"
;
}
if
(
type
=
=
"
cannot
-
initialize
-
pulseaudio
"
)
{
return
"
fix
-
common
-
audio
-
and
-
video
-
issues
"
;
}
return
"
"
;
}
getEndpointForReportIssueButton
(
type
)
{
if
(
type
=
=
"
decode
-
error
"
|
|
type
=
=
"
decode
-
warning
"
)
{
return
Services
.
prefs
.
getStringPref
(
"
media
.
decoder
-
doctor
.
new
-
issue
-
endpoint
"
"
"
)
;
}
return
"
"
;
}
receiveMessage
(
aMessage
)
{
let
browser
=
this
.
browsingContext
.
top
.
embedderElement
;
let
window
=
browser
?
.
ownerGlobal
;
if
(
!
browser
|
|
!
window
)
{
return
;
}
let
box
=
browser
.
getTabBrowser
(
)
.
getNotificationBox
(
browser
)
;
let
notificationId
=
"
decoder
-
doctor
-
notification
"
;
if
(
box
.
getNotificationWithValue
(
notificationId
)
)
{
return
;
}
let
parsedData
;
try
{
parsedData
=
JSON
.
parse
(
aMessage
.
data
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
"
Malformed
Decoder
Doctor
message
with
data
:
"
+
aMessage
.
data
)
;
return
;
}
let
{
type
isSolved
decoderDoctorReportId
formats
decodeIssue
docURL
resourceURL
}
=
parsedData
;
type
=
type
.
toLowerCase
(
)
;
if
(
!
/
^
\
w
+
/
im
.
test
(
decoderDoctorReportId
)
)
{
return
;
}
let
title
=
this
.
getLabelForNotificationBox
(
type
)
;
if
(
!
title
)
{
return
;
}
let
formatsPref
=
formats
&
&
"
media
.
decoder
-
doctor
.
"
+
decoderDoctorReportId
+
"
.
formats
"
;
let
buttonClickedPref
=
"
media
.
decoder
-
doctor
.
"
+
decoderDoctorReportId
+
"
.
button
-
clicked
"
;
let
formatsInPref
=
formats
&
&
Services
.
prefs
.
getCharPref
(
formatsPref
"
"
)
;
if
(
!
isSolved
)
{
if
(
formats
)
{
if
(
!
formatsInPref
)
{
Services
.
prefs
.
setCharPref
(
formatsPref
formats
)
;
}
else
{
let
existing
=
formatsInPref
.
split
(
"
"
)
.
map
(
x
=
>
x
.
trim
(
)
)
;
let
newbies
=
formats
.
split
(
"
"
)
.
map
(
x
=
>
x
.
trim
(
)
)
.
filter
(
x
=
>
!
existing
.
includes
(
x
)
)
;
if
(
newbies
.
length
)
{
Services
.
prefs
.
setCharPref
(
formatsPref
existing
.
concat
(
newbies
)
.
join
(
"
"
)
)
;
}
}
}
else
if
(
!
decodeIssue
)
{
Cu
.
reportError
(
"
Malformed
Decoder
Doctor
unsolved
message
with
no
formats
nor
decode
issue
"
)
;
return
;
}
let
buttons
=
[
]
;
let
sumo
=
this
.
getSumoForLearnHowButton
(
type
)
;
if
(
sumo
)
{
buttons
.
push
(
{
label
:
gNavigatorBundle
.
GetStringFromName
(
"
decoder
.
noCodecs
.
button
"
)
accessKey
:
gNavigatorBundle
.
GetStringFromName
(
"
decoder
.
noCodecs
.
accesskey
"
)
callback
(
)
{
let
clickedInPref
=
Services
.
prefs
.
getBoolPref
(
buttonClickedPref
false
)
;
if
(
!
clickedInPref
)
{
Services
.
prefs
.
setBoolPref
(
buttonClickedPref
true
)
;
}
let
baseURL
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
;
window
.
openTrustedLinkIn
(
baseURL
+
sumo
"
tab
"
)
;
}
}
)
;
}
let
endpoint
=
this
.
getEndpointForReportIssueButton
(
type
)
;
if
(
endpoint
)
{
buttons
.
push
(
{
label
:
gNavigatorBundle
.
GetStringFromName
(
"
decoder
.
decodeError
.
button
"
)
accessKey
:
gNavigatorBundle
.
GetStringFromName
(
"
decoder
.
decodeError
.
accesskey
"
)
callback
(
)
{
let
clickedInPref
=
Services
.
prefs
.
getBoolPref
(
buttonClickedPref
false
)
;
if
(
!
clickedInPref
)
{
Services
.
prefs
.
setBoolPref
(
buttonClickedPref
true
)
;
}
let
params
=
new
URLSearchParams
(
)
;
params
.
append
(
"
url
"
docURL
)
;
params
.
append
(
"
label
"
"
type
-
media
"
)
;
params
.
append
(
"
problem_type
"
"
video_bug
"
)
;
params
.
append
(
"
src
"
"
media
-
decode
-
error
"
)
;
let
details
=
{
"
Technical
Information
:
"
:
decodeIssue
}
;
if
(
resourceURL
)
{
details
[
"
Resource
:
"
]
=
resourceURL
;
}
params
.
append
(
"
details
"
JSON
.
stringify
(
details
)
)
;
window
.
openTrustedLinkIn
(
endpoint
+
"
?
"
+
params
.
toString
(
)
"
tab
"
)
;
}
}
)
;
}
box
.
appendNotification
(
title
notificationId
"
"
box
.
PRIORITY_INFO_LOW
buttons
)
;
}
else
if
(
formatsInPref
)
{
Services
.
prefs
.
clearUserPref
(
formatsPref
)
;
Services
.
prefs
.
clearUserPref
(
buttonClickedPref
)
;
}
}
}
