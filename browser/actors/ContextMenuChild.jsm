"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
ContextMenuChild
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
URL
"
]
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
E10SUtils
:
"
resource
:
/
/
gre
/
modules
/
E10SUtils
.
jsm
"
BrowserUtils
:
"
resource
:
/
/
gre
/
modules
/
BrowserUtils
.
jsm
"
findAllCssSelectors
:
"
resource
:
/
/
gre
/
modules
/
css
-
selector
.
js
"
SpellCheckHelper
:
"
resource
:
/
/
gre
/
modules
/
InlineSpellChecker
.
jsm
"
LoginManagerContent
:
"
resource
:
/
/
gre
/
modules
/
LoginManagerContent
.
jsm
"
WebNavigationFrames
:
"
resource
:
/
/
gre
/
modules
/
WebNavigationFrames
.
jsm
"
PrivateBrowsingUtils
:
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
InlineSpellCheckerContent
:
"
resource
:
/
/
gre
/
modules
/
InlineSpellCheckerContent
.
jsm
"
ContentDOMReference
:
"
resource
:
/
/
gre
/
modules
/
ContentDOMReference
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
PageMenuChild
"
(
)
=
>
{
let
tmp
=
{
}
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PageMenu
.
jsm
"
tmp
)
;
return
new
tmp
.
PageMenuChild
(
)
;
}
)
;
let
contextMenus
=
new
WeakMap
(
)
;
class
ContextMenuChild
extends
JSWindowActorChild
{
constructor
(
)
{
super
(
)
;
this
.
target
=
null
;
this
.
context
=
null
;
this
.
lastMenuTarget
=
null
;
}
static
getTarget
(
browsingContext
message
key
)
{
let
actor
=
contextMenus
.
get
(
browsingContext
)
;
if
(
!
actor
)
{
throw
new
Error
(
"
Can
'
t
find
ContextMenu
actor
for
browsing
context
with
"
+
"
ID
:
"
+
browsingContext
.
id
)
;
}
return
actor
.
getTarget
(
message
key
)
;
}
static
getLastTarget
(
browsingContext
)
{
let
contextMenu
=
contextMenus
.
get
(
browsingContext
)
;
return
contextMenu
&
&
contextMenu
.
lastMenuTarget
;
}
receiveMessage
(
message
)
{
switch
(
message
.
name
)
{
case
"
ContextMenu
:
GetFrameTitle
"
:
{
let
target
=
ContentDOMReference
.
resolve
(
message
.
data
.
targetIdentifier
)
;
return
Promise
.
resolve
(
target
.
ownerDocument
.
title
)
;
}
case
"
ContextMenu
:
Canvas
:
ToBlobURL
"
:
{
let
target
=
ContentDOMReference
.
resolve
(
message
.
data
.
targetIdentifier
)
;
return
new
Promise
(
resolve
=
>
{
target
.
toBlob
(
blob
=
>
{
let
blobURL
=
URL
.
createObjectURL
(
blob
)
;
resolve
(
blobURL
)
;
}
)
;
}
)
;
}
case
"
ContextMenu
:
DoCustomCommand
"
:
{
E10SUtils
.
wrapHandlingUserInput
(
this
.
contentWindow
message
.
data
.
handlingUserInput
(
)
=
>
PageMenuChild
.
executeMenu
(
message
.
data
.
generatedItemId
)
)
;
break
;
}
case
"
ContextMenu
:
Hiding
"
:
{
this
.
context
=
null
;
this
.
target
=
null
;
break
;
}
case
"
ContextMenu
:
MediaCommand
"
:
{
E10SUtils
.
wrapHandlingUserInput
(
this
.
contentWindow
message
.
data
.
handlingUserInput
(
)
=
>
{
let
media
=
ContentDOMReference
.
resolve
(
message
.
data
.
targetIdentifier
)
;
switch
(
message
.
data
.
command
)
{
case
"
play
"
:
media
.
play
(
)
;
break
;
case
"
pause
"
:
media
.
pause
(
)
;
break
;
case
"
loop
"
:
media
.
loop
=
!
media
.
loop
;
break
;
case
"
mute
"
:
media
.
muted
=
true
;
break
;
case
"
unmute
"
:
media
.
muted
=
false
;
break
;
case
"
playbackRate
"
:
media
.
playbackRate
=
message
.
data
.
data
;
break
;
case
"
hidecontrols
"
:
media
.
removeAttribute
(
"
controls
"
)
;
break
;
case
"
showcontrols
"
:
media
.
setAttribute
(
"
controls
"
"
true
"
)
;
break
;
case
"
fullscreen
"
:
if
(
this
.
document
.
fullscreenEnabled
)
{
media
.
requestFullscreen
(
)
;
}
break
;
case
"
pictureinpicture
"
:
let
event
=
new
this
.
contentWindow
.
CustomEvent
(
"
MozTogglePictureInPicture
"
{
bubbles
:
true
}
this
.
contentWindow
)
;
media
.
dispatchEvent
(
event
)
;
break
;
}
}
)
;
break
;
}
case
"
ContextMenu
:
ReloadFrame
"
:
{
let
target
=
ContentDOMReference
.
resolve
(
message
.
data
.
targetIdentifier
)
;
target
.
ownerDocument
.
location
.
reload
(
message
.
data
.
forceReload
)
;
break
;
}
case
"
ContextMenu
:
ReloadImage
"
:
{
let
image
=
ContentDOMReference
.
resolve
(
message
.
data
.
targetIdentifier
)
;
if
(
image
instanceof
Ci
.
nsIImageLoadingContent
)
{
image
.
forceReload
(
)
;
}
break
;
}
case
"
ContextMenu
:
SearchFieldBookmarkData
"
:
{
let
node
=
ContentDOMReference
.
resolve
(
message
.
data
.
targetIdentifier
)
;
let
charset
=
node
.
ownerDocument
.
characterSet
;
let
formBaseURI
=
Services
.
io
.
newURI
(
node
.
form
.
baseURI
charset
)
;
let
formURI
=
Services
.
io
.
newURI
(
node
.
form
.
getAttribute
(
"
action
"
)
charset
formBaseURI
)
;
let
spec
=
formURI
.
spec
;
let
isURLEncoded
=
(
node
.
form
.
method
.
toUpperCase
(
)
=
=
"
POST
"
&
&
(
node
.
form
.
enctype
=
=
"
application
/
x
-
www
-
form
-
urlencoded
"
|
|
node
.
form
.
enctype
=
=
"
"
)
)
;
let
title
=
node
.
ownerDocument
.
title
;
function
escapeNameValuePair
(
[
aName
aValue
]
)
{
if
(
isURLEncoded
)
{
return
escape
(
aName
+
"
=
"
+
aValue
)
;
}
return
escape
(
aName
)
+
"
=
"
+
escape
(
aValue
)
;
}
let
formData
=
new
this
.
contentWindow
.
FormData
(
node
.
form
)
;
formData
.
delete
(
node
.
name
)
;
formData
=
Array
.
from
(
formData
)
.
map
(
escapeNameValuePair
)
;
formData
.
push
(
escape
(
node
.
name
)
+
(
isURLEncoded
?
escape
(
"
=
%
s
"
)
:
"
=
%
s
"
)
)
;
let
postData
;
if
(
isURLEncoded
)
{
postData
=
formData
.
join
(
"
&
"
)
;
}
else
{
let
separator
=
spec
.
includes
(
"
?
"
)
?
"
&
"
:
"
?
"
;
spec
+
=
separator
+
formData
.
join
(
"
&
"
)
;
}
return
Promise
.
resolve
(
{
spec
title
postData
charset
}
)
;
}
case
"
ContextMenu
:
SaveVideoFrameAsImage
"
:
{
let
video
=
ContentDOMReference
.
resolve
(
message
.
data
.
targetIdentifier
)
;
let
canvas
=
this
.
document
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
"
canvas
"
)
;
canvas
.
width
=
video
.
videoWidth
;
canvas
.
height
=
video
.
videoHeight
;
let
ctxDraw
=
canvas
.
getContext
(
"
2d
"
)
;
ctxDraw
.
drawImage
(
video
0
0
)
;
return
Promise
.
resolve
(
canvas
.
toDataURL
(
"
image
/
jpeg
"
"
"
)
)
;
}
case
"
ContextMenu
:
SetAsDesktopBackground
"
:
{
let
target
=
ContentDOMReference
.
resolve
(
message
.
data
.
targetIdentifier
)
;
let
disable
=
this
.
_disableSetDesktopBackground
(
target
)
;
if
(
!
disable
)
{
try
{
BrowserUtils
.
urlSecurityCheck
(
target
.
currentURI
.
spec
target
.
ownerDocument
.
nodePrincipal
)
;
let
canvas
=
this
.
document
.
createElement
(
"
canvas
"
)
;
canvas
.
width
=
target
.
naturalWidth
;
canvas
.
height
=
target
.
naturalHeight
;
let
ctx
=
canvas
.
getContext
(
"
2d
"
)
;
ctx
.
drawImage
(
target
0
0
)
;
let
dataURL
=
canvas
.
toDataURL
(
)
;
let
url
=
(
new
URL
(
target
.
ownerDocument
.
location
.
href
)
)
.
pathname
;
let
imageName
=
url
.
substr
(
url
.
lastIndexOf
(
"
/
"
)
+
1
)
;
return
Promise
.
resolve
(
{
failed
:
false
dataURL
imageName
}
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
return
Promise
.
resolve
(
{
failed
:
true
dataURL
:
null
imageName
:
null
}
)
;
}
}
return
undefined
;
}
getTarget
(
aMessage
aKey
=
"
target
"
)
{
return
this
.
target
|
|
(
aMessage
.
objects
&
&
aMessage
.
objects
[
aKey
]
)
;
}
_isXULTextLinkLabel
(
aNode
)
{
const
XUL_NS
=
"
http
:
/
/
www
.
mozilla
.
org
/
keymaster
/
gatekeeper
/
there
.
is
.
only
.
xul
"
;
return
aNode
.
namespaceURI
=
=
XUL_NS
&
&
aNode
.
tagName
=
=
"
label
"
&
&
aNode
.
classList
.
contains
(
"
text
-
link
"
)
&
&
aNode
.
href
;
}
_getLinkURL
(
)
{
let
href
=
this
.
context
.
link
.
href
;
if
(
href
)
{
if
(
typeof
href
=
=
"
object
"
&
&
href
.
animVal
)
{
return
this
.
_makeURLAbsolute
(
this
.
context
.
link
.
baseURI
href
.
animVal
)
;
}
return
href
;
}
href
=
this
.
context
.
link
.
getAttribute
(
"
href
"
)
|
|
this
.
context
.
link
.
getAttributeNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xlink
"
"
href
"
)
;
if
(
!
href
|
|
!
href
.
match
(
/
\
S
/
)
)
{
throw
new
Error
(
"
Empty
href
"
)
;
}
return
this
.
_makeURLAbsolute
(
this
.
context
.
link
.
baseURI
href
)
;
}
_getLinkURI
(
)
{
try
{
return
Services
.
io
.
newURI
(
this
.
context
.
linkURL
)
;
}
catch
(
ex
)
{
}
return
null
;
}
_getLinkText
(
)
{
let
text
=
this
.
_gatherTextUnder
(
this
.
context
.
link
)
;
if
(
!
text
|
|
!
text
.
match
(
/
\
S
/
)
)
{
text
=
this
.
context
.
link
.
getAttribute
(
"
title
"
)
;
if
(
!
text
|
|
!
text
.
match
(
/
\
S
/
)
)
{
text
=
this
.
context
.
link
.
getAttribute
(
"
alt
"
)
;
if
(
!
text
|
|
!
text
.
match
(
/
\
S
/
)
)
{
text
=
this
.
context
.
linkURL
;
}
}
}
return
text
;
}
_getLinkProtocol
(
)
{
if
(
this
.
context
.
linkURI
)
{
return
this
.
context
.
linkURI
.
scheme
;
}
return
null
;
}
_isLinkSaveable
(
aLink
)
{
return
this
.
context
.
linkProtocol
&
&
!
(
this
.
context
.
linkProtocol
=
=
"
mailto
"
|
|
this
.
context
.
linkProtocol
=
=
"
javascript
"
|
|
this
.
context
.
linkProtocol
=
=
"
news
"
|
|
this
.
context
.
linkProtocol
=
=
"
snews
"
)
;
}
_gatherTextUnder
(
root
)
{
let
text
=
"
"
;
let
node
=
root
.
firstChild
;
let
depth
=
1
;
while
(
node
&
&
depth
>
0
)
{
if
(
node
.
nodeType
=
=
node
.
TEXT_NODE
)
{
text
+
=
"
"
+
node
.
data
;
}
else
if
(
node
instanceof
this
.
contentWindow
.
HTMLImageElement
)
{
let
altText
=
node
.
getAttribute
(
"
alt
"
)
;
if
(
altText
&
&
altText
!
=
"
"
)
{
text
+
=
"
"
+
altText
;
}
}
if
(
node
.
hasChildNodes
(
)
)
{
node
=
node
.
firstChild
;
depth
+
+
;
}
else
{
while
(
depth
>
0
&
&
!
node
.
nextSibling
)
{
node
=
node
.
parentNode
;
depth
-
-
;
}
if
(
node
.
nextSibling
)
{
node
=
node
.
nextSibling
;
}
}
}
text
=
text
.
trim
(
)
;
text
=
text
.
replace
(
/
\
s
+
/
g
"
"
)
;
return
text
;
}
_getComputedURL
(
aElem
aProp
)
{
let
urls
=
aElem
.
ownerGlobal
.
getComputedStyle
(
aElem
)
.
getCSSImageURLs
(
aProp
)
;
if
(
!
urls
.
length
)
{
return
null
;
}
if
(
urls
.
length
!
=
1
)
{
throw
new
Error
(
"
found
multiple
URLs
"
)
;
}
return
urls
[
0
]
;
}
_makeURLAbsolute
(
aBase
aUrl
)
{
return
Services
.
io
.
newURI
(
aUrl
null
Services
.
io
.
newURI
(
aBase
)
)
.
spec
;
}
_isProprietaryDRM
(
)
{
return
this
.
context
.
target
.
isEncrypted
&
&
this
.
context
.
target
.
mediaKeys
&
&
this
.
context
.
target
.
mediaKeys
.
keySystem
!
=
"
org
.
w3
.
clearkey
"
;
}
_isMediaURLReusable
(
aURL
)
{
if
(
aURL
.
startsWith
(
"
blob
:
"
)
)
{
return
URL
.
isValidURL
(
aURL
)
;
}
return
true
;
}
_isTargetATextBox
(
node
)
{
if
(
node
instanceof
this
.
contentWindow
.
HTMLInputElement
)
{
return
node
.
mozIsTextField
(
false
)
;
}
return
(
node
instanceof
this
.
contentWindow
.
HTMLTextAreaElement
)
;
}
_isSpellCheckEnabled
(
aNode
)
{
if
(
this
.
_isTargetATextBox
(
aNode
)
)
{
return
true
;
}
let
editable
=
aNode
.
isContentEditable
;
if
(
!
editable
&
&
aNode
.
ownerDocument
)
{
editable
=
aNode
.
ownerDocument
.
designMode
=
=
"
on
"
;
}
if
(
!
editable
)
{
return
false
;
}
return
aNode
.
spellcheck
;
}
_disableSetDesktopBackground
(
aTarget
)
{
if
(
!
(
aTarget
instanceof
Ci
.
nsIImageLoadingContent
)
)
{
return
true
;
}
if
(
(
"
complete
"
in
aTarget
)
&
&
!
aTarget
.
complete
)
{
return
true
;
}
if
(
aTarget
.
currentURI
.
schemeIs
(
"
javascript
"
)
)
{
return
true
;
}
let
request
=
aTarget
.
getRequest
(
Ci
.
nsIImageLoadingContent
.
CURRENT_REQUEST
)
;
if
(
!
request
)
{
return
true
;
}
return
false
;
}
handleEvent
(
aEvent
)
{
contextMenus
.
set
(
this
.
browsingContext
this
)
;
let
defaultPrevented
=
aEvent
.
defaultPrevented
;
if
(
!
Services
.
prefs
.
getBoolPref
(
"
dom
.
event
.
contextmenu
.
enabled
"
)
)
{
let
plugin
=
null
;
try
{
plugin
=
aEvent
.
composedTarget
.
QueryInterface
(
Ci
.
nsIObjectLoadingContent
)
;
}
catch
(
e
)
{
}
if
(
plugin
&
&
plugin
.
displayedType
=
=
Ci
.
nsIObjectLoadingContent
.
TYPE_PLUGIN
)
{
return
;
}
defaultPrevented
=
false
;
}
if
(
defaultPrevented
)
{
return
;
}
let
doc
=
aEvent
.
composedTarget
.
ownerDocument
;
let
{
mozDocumentURIIfNotForErrorPages
:
docLocation
characterSet
:
charSet
baseURI
}
=
doc
;
docLocation
=
docLocation
&
&
docLocation
.
spec
;
let
frameOuterWindowID
=
WebNavigationFrames
.
getFrameId
(
doc
.
defaultView
)
;
let
loginFillInfo
=
LoginManagerContent
.
getFieldContext
(
aEvent
.
composedTarget
)
;
let
parentAllowsMixedContent
=
!
!
this
.
docShell
.
mixedContentChannel
;
let
disableSetDesktopBackground
=
null
;
let
contentType
=
null
;
let
contentDisposition
=
null
;
if
(
aEvent
.
composedTarget
.
nodeType
=
=
aEvent
.
composedTarget
.
ELEMENT_NODE
&
&
aEvent
.
composedTarget
instanceof
Ci
.
nsIImageLoadingContent
&
&
aEvent
.
composedTarget
.
currentURI
)
{
disableSetDesktopBackground
=
this
.
_disableSetDesktopBackground
(
aEvent
.
composedTarget
)
;
try
{
let
imageCache
=
Cc
[
"
mozilla
.
org
/
image
/
tools
;
1
"
]
.
getService
(
Ci
.
imgITools
)
.
getImgCacheForDocument
(
doc
)
;
let
props
=
imageCache
.
findEntryProperties
(
aEvent
.
composedTarget
.
currentURI
doc
)
;
try
{
contentType
=
props
.
get
(
"
type
"
Ci
.
nsISupportsCString
)
.
data
;
}
catch
(
e
)
{
}
try
{
contentDisposition
=
props
.
get
(
"
content
-
disposition
"
Ci
.
nsISupportsCString
)
.
data
;
}
catch
(
e
)
{
}
}
catch
(
e
)
{
}
}
let
selectionInfo
=
BrowserUtils
.
getSelectionDetails
(
this
.
contentWindow
)
;
let
loadContext
=
this
.
docShell
.
QueryInterface
(
Ci
.
nsILoadContext
)
;
let
userContextId
=
loadContext
.
originAttributes
.
userContextId
;
let
popupNodeSelectors
=
findAllCssSelectors
(
aEvent
.
composedTarget
)
;
this
.
_setContext
(
aEvent
)
;
let
context
=
this
.
context
;
this
.
target
=
context
.
target
;
let
spellInfo
=
null
;
let
editFlags
=
null
;
let
principal
=
null
;
let
customMenuItems
=
null
;
let
referrerInfo
=
Cc
[
"
mozilla
.
org
/
referrer
-
info
;
1
"
]
.
createInstance
(
Ci
.
nsIReferrerInfo
)
;
referrerInfo
.
initWithNode
(
context
.
onLink
?
context
.
link
:
aEvent
.
composedTarget
)
;
referrerInfo
=
E10SUtils
.
serializeReferrerInfo
(
referrerInfo
)
;
let
target
=
context
.
target
;
if
(
target
)
{
this
.
_cleanContext
(
)
;
}
editFlags
=
SpellCheckHelper
.
isEditable
(
aEvent
.
composedTarget
this
.
contentWindow
)
;
if
(
editFlags
&
SpellCheckHelper
.
SPELLCHECKABLE
)
{
spellInfo
=
InlineSpellCheckerContent
.
initContextMenu
(
aEvent
editFlags
this
)
;
}
this
.
docShell
.
contentViewer
.
QueryInterface
(
Ci
.
nsIContentViewerEdit
)
.
setCommandNode
(
aEvent
.
composedTarget
)
;
aEvent
.
composedTarget
.
ownerGlobal
.
updateCommands
(
"
contentcontextmenu
"
)
;
let
data
=
{
context
charSet
baseURI
referrerInfo
editFlags
principal
spellInfo
contentType
docLocation
loginFillInfo
selectionInfo
userContextId
customMenuItems
contentDisposition
frameOuterWindowID
popupNodeSelectors
disableSetDesktopBackground
parentAllowsMixedContent
}
;
if
(
context
.
inFrame
&
&
!
context
.
inSrcdocFrame
)
{
data
.
frameReferrerInfo
=
doc
.
referrerInfo
;
}
if
(
Services
.
appinfo
.
processType
=
=
Services
.
appinfo
.
PROCESS_TYPE_CONTENT
)
{
data
.
customMenuItems
=
PageMenuChild
.
build
(
aEvent
.
composedTarget
)
;
}
Services
.
obs
.
notifyObservers
(
{
wrappedJSObject
:
data
}
"
on
-
prepare
-
contextmenu
"
)
;
data
.
principal
=
E10SUtils
.
serializePrincipal
(
doc
.
nodePrincipal
)
;
data
.
context
.
principal
=
E10SUtils
.
serializePrincipal
(
context
.
principal
)
;
data
.
storagePrincipal
=
E10SUtils
.
serializePrincipal
(
doc
.
effectiveStoragePrincipal
)
;
data
.
context
.
storagePrincipal
=
E10SUtils
.
serializePrincipal
(
context
.
storagePrincipal
)
;
aEvent
.
preventDefault
(
)
;
aEvent
.
stopPropagation
(
)
;
this
.
sendAsyncMessage
(
"
contextmenu
"
data
)
;
}
_cleanContext
(
aEvent
)
{
const
context
=
this
.
context
;
const
cleanTarget
=
Object
.
create
(
null
)
;
cleanTarget
.
ownerDocument
=
{
fullscreen
:
context
.
target
.
ownerDocument
.
fullscreen
contentType
:
context
.
target
.
ownerDocument
.
contentType
isPrivate
:
PrivateBrowsingUtils
.
isContentWindowPrivate
(
context
.
target
.
ownerGlobal
)
}
;
Object
.
assign
(
cleanTarget
{
ended
:
context
.
target
.
ended
muted
:
context
.
target
.
muted
paused
:
context
.
target
.
paused
controls
:
context
.
target
.
controls
duration
:
context
.
target
.
duration
}
)
;
const
onMedia
=
context
.
onVideo
|
|
context
.
onAudio
;
if
(
onMedia
)
{
Object
.
assign
(
cleanTarget
{
loop
:
context
.
target
.
loop
error
:
context
.
target
.
error
networkState
:
context
.
target
.
networkState
playbackRate
:
context
.
target
.
playbackRate
NETWORK_NO_SOURCE
:
context
.
target
.
NETWORK_NO_SOURCE
}
)
;
if
(
context
.
onVideo
)
{
Object
.
assign
(
cleanTarget
{
readyState
:
context
.
target
.
readyState
HAVE_CURRENT_DATA
:
context
.
target
.
HAVE_CURRENT_DATA
}
)
;
}
}
context
.
target
=
cleanTarget
;
if
(
context
.
link
)
{
context
.
link
=
{
href
:
context
.
linkURL
}
;
}
delete
context
.
linkURI
;
}
_setContext
(
aEvent
)
{
this
.
context
=
Object
.
create
(
null
)
;
const
context
=
this
.
context
;
context
.
timeStamp
=
aEvent
.
timeStamp
;
context
.
screenX
=
aEvent
.
screenX
;
context
.
screenY
=
aEvent
.
screenY
;
context
.
mozInputSource
=
aEvent
.
mozInputSource
;
let
node
=
aEvent
.
composedTarget
;
if
(
this
.
contentWindow
.
ShadowRoot
)
{
let
n
=
node
;
while
(
n
)
{
if
(
n
instanceof
this
.
contentWindow
.
ShadowRoot
)
{
if
(
n
.
host
instanceof
this
.
contentWindow
.
HTMLMediaElement
|
|
n
.
host
instanceof
this
.
contentWindow
.
HTMLEmbedElement
|
|
n
.
host
instanceof
this
.
contentWindow
.
HTMLObjectElement
)
{
node
=
n
.
host
;
break
;
}
break
;
}
n
=
n
.
parentNode
;
}
}
const
XUL_NS
=
"
http
:
/
/
www
.
mozilla
.
org
/
keymaster
/
gatekeeper
/
there
.
is
.
only
.
xul
"
;
context
.
shouldDisplay
=
true
;
if
(
node
.
nodeType
=
=
node
.
DOCUMENT_NODE
|
|
(
node
.
namespaceURI
=
=
XUL_NS
&
&
!
this
.
_isXULTextLinkLabel
(
node
)
)
)
{
context
.
shouldDisplay
=
false
;
return
;
}
const
isAboutDevtoolsToolbox
=
this
.
document
.
documentURI
.
startsWith
(
"
about
:
devtools
-
toolbox
"
)
;
const
editFlags
=
SpellCheckHelper
.
isEditable
(
node
this
.
contentWindow
)
;
if
(
isAboutDevtoolsToolbox
&
&
(
editFlags
&
SpellCheckHelper
.
TEXTINPUT
)
=
=
=
0
)
{
context
.
shouldDisplay
=
false
;
return
;
}
context
.
bgImageURL
=
"
"
;
context
.
imageDescURL
=
"
"
;
context
.
imageInfo
=
null
;
context
.
mediaURL
=
"
"
;
context
.
webExtBrowserType
=
"
"
;
context
.
canSpellCheck
=
false
;
context
.
hasBGImage
=
false
;
context
.
hasMultipleBGImages
=
false
;
context
.
isDesignMode
=
false
;
context
.
inFrame
=
false
;
context
.
inSrcdocFrame
=
false
;
context
.
inSyntheticDoc
=
false
;
context
.
inTabBrowser
=
true
;
context
.
inWebExtBrowser
=
false
;
context
.
link
=
null
;
context
.
linkDownload
=
"
"
;
context
.
linkProtocol
=
"
"
;
context
.
linkTextStr
=
"
"
;
context
.
linkURL
=
"
"
;
context
.
linkURI
=
null
;
context
.
onAudio
=
false
;
context
.
onCanvas
=
false
;
context
.
onCompletedImage
=
false
;
context
.
onCTPPlugin
=
false
;
context
.
onDRMMedia
=
false
;
context
.
onPiPVideo
=
false
;
context
.
onEditable
=
false
;
context
.
onImage
=
false
;
context
.
onKeywordField
=
false
;
context
.
onLink
=
false
;
context
.
onLoadedImage
=
false
;
context
.
onMailtoLink
=
false
;
context
.
onMozExtLink
=
false
;
context
.
onNumeric
=
false
;
context
.
onPassword
=
false
;
context
.
onSaveableLink
=
false
;
context
.
onSpellcheckable
=
false
;
context
.
onTextInput
=
false
;
context
.
onVideo
=
false
;
context
.
target
=
node
;
context
.
targetIdentifier
=
ContentDOMReference
.
get
(
node
)
;
context
.
principal
=
context
.
target
.
ownerDocument
.
nodePrincipal
;
context
.
storagePrincipal
=
context
.
target
.
ownerDocument
.
effectiveStoragePrincipal
;
context
.
csp
=
E10SUtils
.
serializeCSP
(
context
.
target
.
ownerDocument
.
csp
)
;
context
.
frameOuterWindowID
=
WebNavigationFrames
.
getFrameId
(
context
.
target
.
ownerGlobal
)
;
context
.
inSyntheticDoc
=
context
.
target
.
ownerDocument
.
mozSyntheticDocument
;
context
.
shouldInitInlineSpellCheckerUINoChildren
=
false
;
context
.
shouldInitInlineSpellCheckerUIWithChildren
=
false
;
this
.
_setContextForNodesNoChildren
(
editFlags
)
;
this
.
_setContextForNodesWithChildren
(
editFlags
)
;
this
.
lastMenuTarget
=
{
targetRef
:
Cu
.
getWeakReference
(
node
)
timeStamp
:
context
.
timeStamp
}
;
if
(
isAboutDevtoolsToolbox
)
{
context
.
inAboutDevtoolsToolbox
=
true
;
context
.
canSpellCheck
=
false
;
context
.
inTabBrowser
=
false
;
context
.
inFrame
=
false
;
context
.
inSrcdocFrame
=
false
;
context
.
onSpellcheckable
=
false
;
}
}
_setContextForNodesNoChildren
(
editFlags
)
{
const
context
=
this
.
context
;
if
(
context
.
target
.
nodeType
=
=
context
.
target
.
TEXT_NODE
)
{
context
.
canSpellCheck
=
context
.
target
.
parentNode
&
&
this
.
_isSpellCheckEnabled
(
context
.
target
)
;
return
;
}
if
(
context
.
target
.
nodeType
!
=
context
.
target
.
ELEMENT_NODE
)
{
return
;
}
if
(
context
.
target
instanceof
Ci
.
nsIImageLoadingContent
&
&
(
context
.
target
.
currentRequestFinalURI
|
|
context
.
target
.
currentURI
)
)
{
context
.
onImage
=
true
;
context
.
imageInfo
=
{
currentSrc
:
context
.
target
.
currentSrc
width
:
context
.
target
.
width
height
:
context
.
target
.
height
imageText
:
context
.
target
.
title
|
|
context
.
target
.
alt
}
;
const
request
=
context
.
target
.
getRequest
(
Ci
.
nsIImageLoadingContent
.
CURRENT_REQUEST
)
;
if
(
request
&
&
(
request
.
imageStatus
&
request
.
STATUS_SIZE_AVAILABLE
)
)
{
context
.
onLoadedImage
=
true
;
}
if
(
request
&
&
(
request
.
imageStatus
&
request
.
STATUS_LOAD_COMPLETE
)
&
&
!
(
request
.
imageStatus
&
request
.
STATUS_ERROR
)
)
{
context
.
onCompletedImage
=
true
;
}
context
.
mediaURL
=
(
context
.
target
.
currentRequestFinalURI
|
|
context
.
target
.
currentURI
)
.
spec
;
const
descURL
=
context
.
target
.
getAttribute
(
"
longdesc
"
)
;
if
(
descURL
)
{
context
.
imageDescURL
=
this
.
_makeURLAbsolute
(
context
.
target
.
ownerDocument
.
body
.
baseURI
descURL
)
;
}
}
else
if
(
context
.
target
instanceof
this
.
contentWindow
.
HTMLCanvasElement
)
{
context
.
onCanvas
=
true
;
}
else
if
(
context
.
target
instanceof
this
.
contentWindow
.
HTMLVideoElement
)
{
const
mediaURL
=
context
.
target
.
currentSrc
|
|
context
.
target
.
src
;
if
(
this
.
_isMediaURLReusable
(
mediaURL
)
)
{
context
.
mediaURL
=
mediaURL
;
}
if
(
this
.
_isProprietaryDRM
(
)
)
{
context
.
onDRMMedia
=
true
;
}
if
(
context
.
target
.
isCloningElementVisually
)
{
context
.
onPiPVideo
=
true
;
}
if
(
context
.
target
.
readyState
>
=
context
.
target
.
HAVE_METADATA
&
&
(
context
.
target
.
videoWidth
=
=
0
|
|
context
.
target
.
videoHeight
=
=
0
)
)
{
context
.
onAudio
=
true
;
}
else
{
context
.
onVideo
=
true
;
}
}
else
if
(
context
.
target
instanceof
this
.
contentWindow
.
HTMLAudioElement
)
{
context
.
onAudio
=
true
;
const
mediaURL
=
context
.
target
.
currentSrc
|
|
context
.
target
.
src
;
if
(
this
.
_isMediaURLReusable
(
mediaURL
)
)
{
context
.
mediaURL
=
mediaURL
;
}
if
(
this
.
_isProprietaryDRM
(
)
)
{
context
.
onDRMMedia
=
true
;
}
}
else
if
(
editFlags
&
(
SpellCheckHelper
.
INPUT
|
SpellCheckHelper
.
TEXTAREA
)
)
{
context
.
onTextInput
=
(
editFlags
&
SpellCheckHelper
.
TEXTINPUT
)
!
=
=
0
;
context
.
onNumeric
=
(
editFlags
&
SpellCheckHelper
.
NUMERIC
)
!
=
=
0
;
context
.
onEditable
=
(
editFlags
&
SpellCheckHelper
.
EDITABLE
)
!
=
=
0
;
context
.
onPassword
=
(
editFlags
&
SpellCheckHelper
.
PASSWORD
)
!
=
=
0
;
context
.
onSpellcheckable
=
(
editFlags
&
SpellCheckHelper
.
SPELLCHECKABLE
)
!
=
=
0
;
if
(
context
.
onSpellcheckable
)
{
context
.
shouldInitInlineSpellCheckerUINoChildren
=
true
;
}
context
.
onKeywordField
=
(
editFlags
&
SpellCheckHelper
.
KEYWORD
)
;
}
else
if
(
context
.
target
instanceof
this
.
contentWindow
.
HTMLHtmlElement
)
{
const
bodyElt
=
context
.
target
.
ownerDocument
.
body
;
if
(
bodyElt
)
{
let
computedURL
;
try
{
computedURL
=
this
.
_getComputedURL
(
bodyElt
"
background
-
image
"
)
;
context
.
hasMultipleBGImages
=
false
;
}
catch
(
e
)
{
context
.
hasMultipleBGImages
=
true
;
}
if
(
computedURL
)
{
context
.
hasBGImage
=
true
;
context
.
bgImageURL
=
this
.
_makeURLAbsolute
(
bodyElt
.
baseURI
computedURL
)
;
}
}
}
else
if
(
(
context
.
target
instanceof
this
.
contentWindow
.
HTMLEmbedElement
|
|
context
.
target
instanceof
this
.
contentWindow
.
HTMLObjectElement
)
&
&
context
.
target
.
displayedType
=
=
this
.
contentWindow
.
HTMLObjectElement
.
TYPE_NULL
&
&
context
.
target
.
pluginFallbackType
=
=
this
.
contentWindow
.
HTMLObjectElement
.
PLUGIN_CLICK_TO_PLAY
)
{
context
.
onCTPPlugin
=
true
;
}
context
.
canSpellCheck
=
this
.
_isSpellCheckEnabled
(
context
.
target
)
;
}
_setContextForNodesWithChildren
(
editFlags
)
{
const
context
=
this
.
context
;
let
elem
=
context
.
target
;
while
(
elem
)
{
if
(
elem
.
nodeType
=
=
elem
.
ELEMENT_NODE
)
{
const
XLINK_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xlink
"
;
if
(
!
context
.
onLink
&
&
(
this
.
_isXULTextLinkLabel
(
elem
)
|
|
(
elem
instanceof
this
.
contentWindow
.
HTMLAnchorElement
&
&
elem
.
href
)
|
|
(
elem
instanceof
this
.
contentWindow
.
SVGAElement
&
&
(
elem
.
href
|
|
elem
.
hasAttributeNS
(
XLINK_NS
"
href
"
)
)
)
|
|
(
elem
instanceof
this
.
contentWindow
.
HTMLAreaElement
&
&
elem
.
href
)
|
|
elem
instanceof
this
.
contentWindow
.
HTMLLinkElement
|
|
elem
.
getAttributeNS
(
XLINK_NS
"
type
"
)
=
=
"
simple
"
)
)
{
context
.
onLink
=
true
;
context
.
link
=
elem
;
context
.
linkURL
=
this
.
_getLinkURL
(
)
;
context
.
linkURI
=
this
.
_getLinkURI
(
)
;
context
.
linkTextStr
=
this
.
_getLinkText
(
)
;
context
.
linkProtocol
=
this
.
_getLinkProtocol
(
)
;
context
.
onMailtoLink
=
(
context
.
linkProtocol
=
=
"
mailto
"
)
;
context
.
onMozExtLink
=
(
context
.
linkProtocol
=
=
"
moz
-
extension
"
)
;
context
.
onSaveableLink
=
this
.
_isLinkSaveable
(
context
.
link
)
;
try
{
if
(
elem
.
download
)
{
context
.
principal
.
checkMayLoad
(
context
.
linkURI
false
true
)
;
context
.
linkDownload
=
elem
.
download
;
}
}
catch
(
ex
)
{
}
}
if
(
!
context
.
hasBGImage
&
&
!
context
.
hasMultipleBGImages
)
{
let
bgImgUrl
=
null
;
try
{
bgImgUrl
=
this
.
_getComputedURL
(
elem
"
background
-
image
"
)
;
context
.
hasMultipleBGImages
=
false
;
}
catch
(
e
)
{
context
.
hasMultipleBGImages
=
true
;
}
if
(
bgImgUrl
)
{
context
.
hasBGImage
=
true
;
context
.
bgImageURL
=
this
.
_makeURLAbsolute
(
elem
.
baseURI
bgImgUrl
)
;
}
}
}
elem
=
elem
.
parentNode
;
}
const
docDefaultView
=
context
.
target
.
ownerGlobal
;
if
(
docDefaultView
!
=
docDefaultView
.
top
)
{
context
.
inFrame
=
true
;
if
(
context
.
target
.
ownerDocument
.
isSrcdocDocument
)
{
context
.
inSrcdocFrame
=
true
;
}
}
if
(
!
context
.
onEditable
)
{
if
(
editFlags
&
SpellCheckHelper
.
CONTENTEDITABLE
)
{
context
.
onTextInput
=
true
;
context
.
onKeywordField
=
false
;
context
.
onImage
=
false
;
context
.
onLoadedImage
=
false
;
context
.
onCompletedImage
=
false
;
context
.
inFrame
=
false
;
context
.
inSrcdocFrame
=
false
;
context
.
hasBGImage
=
false
;
context
.
isDesignMode
=
true
;
context
.
onEditable
=
true
;
context
.
onSpellcheckable
=
true
;
context
.
shouldInitInlineSpellCheckerUIWithChildren
=
true
;
}
}
}
}
