"
use
strict
"
;
Cu
.
importGlobalProperties
(
[
"
fetch
"
]
)
;
var
EXPORTED_SYMBOLS
=
[
"
AboutProtectionsParent
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
fxAccounts
:
"
resource
:
/
/
gre
/
modules
/
FxAccounts
.
jsm
"
FXA_PWDMGR_HOST
:
"
resource
:
/
/
gre
/
modules
/
FxAccountsCommon
.
js
"
FXA_PWDMGR_REALM
:
"
resource
:
/
/
gre
/
modules
/
FxAccountsCommon
.
js
"
AddonManager
:
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
LoginBreaches
:
"
resource
:
/
/
/
modules
/
LoginBreaches
.
jsm
"
LoginHelper
:
"
resource
:
/
/
gre
/
modules
/
LoginHelper
.
jsm
"
PrivateBrowsingUtils
:
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
Region
:
"
resource
:
/
/
gre
/
modules
/
Region
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
TrackingDBService
"
"
mozilla
.
org
/
tracking
-
db
-
service
;
1
"
"
nsITrackingDBService
"
)
;
let
idToTextMap
=
new
Map
(
[
[
Ci
.
nsITrackingDBService
.
TRACKERS_ID
"
tracker
"
]
[
Ci
.
nsITrackingDBService
.
TRACKING_COOKIES_ID
"
cookie
"
]
[
Ci
.
nsITrackingDBService
.
CRYPTOMINERS_ID
"
cryptominer
"
]
[
Ci
.
nsITrackingDBService
.
FINGERPRINTERS_ID
"
fingerprinter
"
]
[
Ci
.
nsITrackingDBService
.
SOCIAL_ID
"
social
"
]
]
)
;
const
MONITOR_API_ENDPOINT
=
Services
.
urlFormatter
.
formatURLPref
(
"
browser
.
contentblocking
.
report
.
endpoint_url
"
)
;
const
SECURE_PROXY_ADDON_ID
=
"
secure
-
proxy
mozilla
.
com
"
;
const
SCOPE_MONITOR
=
[
"
profile
:
uid
"
"
https
:
/
/
identity
.
mozilla
.
com
/
apps
/
monitor
"
]
;
const
INVALID_OAUTH_TOKEN
=
"
Invalid
OAuth
token
"
;
const
USER_UNSUBSCRIBED_TO_MONITOR
=
"
User
is
not
subscribed
to
Monitor
"
;
const
SERVICE_UNAVAILABLE
=
"
Service
unavailable
"
;
const
UNEXPECTED_RESPONSE
=
"
Unexpected
response
"
;
const
UNKNOWN_ERROR
=
"
Unknown
error
"
;
const
MONITOR_RESPONSE_PROPS
=
[
"
monitoredEmails
"
"
numBreaches
"
"
passwords
"
"
numBreachesResolved
"
"
passwordsResolved
"
]
;
let
gTestOverride
=
null
;
let
monitorResponse
=
null
;
let
entrypoint
=
"
direct
"
;
class
AboutProtectionsParent
extends
JSWindowActorParent
{
constructor
(
)
{
super
(
)
;
}
static
setTestOverride
(
callback
)
{
gTestOverride
=
callback
;
}
async
fetchUserBreachStats
(
token
)
{
if
(
monitorResponse
&
&
monitorResponse
.
timestamp
)
{
var
timeDiff
=
Date
.
now
(
)
-
monitorResponse
.
timestamp
;
let
oneDayInMS
=
24
*
60
*
60
*
1000
;
if
(
timeDiff
>
=
oneDayInMS
)
{
monitorResponse
=
null
;
}
else
{
return
monitorResponse
;
}
}
const
headers
=
new
Headers
(
)
;
headers
.
append
(
"
Authorization
"
Bearer
{
token
}
)
;
const
request
=
new
Request
(
MONITOR_API_ENDPOINT
{
headers
}
)
;
const
response
=
await
fetch
(
request
)
;
if
(
response
.
ok
)
{
const
json
=
await
response
.
json
(
)
;
let
isValid
=
null
;
for
(
let
prop
in
json
)
{
isValid
=
MONITOR_RESPONSE_PROPS
.
includes
(
prop
)
;
if
(
!
isValid
)
{
break
;
}
}
monitorResponse
=
isValid
?
json
:
new
Error
(
UNEXPECTED_RESPONSE
)
;
if
(
isValid
)
{
monitorResponse
.
timestamp
=
Date
.
now
(
)
;
}
}
else
{
switch
(
response
.
status
)
{
case
400
:
case
401
:
monitorResponse
=
new
Error
(
INVALID_OAUTH_TOKEN
)
;
break
;
case
404
:
monitorResponse
=
new
Error
(
USER_UNSUBSCRIBED_TO_MONITOR
)
;
break
;
case
503
:
monitorResponse
=
new
Error
(
SERVICE_UNAVAILABLE
)
;
break
;
default
:
monitorResponse
=
new
Error
(
UNKNOWN_ERROR
)
;
break
;
}
}
if
(
monitorResponse
instanceof
Error
)
{
throw
monitorResponse
;
}
return
monitorResponse
;
}
async
getLoginData
(
)
{
if
(
gTestOverride
&
&
"
getLoginData
"
in
gTestOverride
)
{
return
gTestOverride
.
getLoginData
(
)
;
}
try
{
if
(
await
fxAccounts
.
getSignedInUser
(
)
)
{
await
fxAccounts
.
device
.
refreshDeviceList
(
)
;
}
}
catch
(
e
)
{
Cu
.
reportError
(
"
There
was
an
error
fetching
login
data
:
"
e
.
message
)
;
}
const
userFacingLogins
=
Services
.
logins
.
countLogins
(
"
"
"
"
"
"
)
-
Services
.
logins
.
countLogins
(
FXA_PWDMGR_HOST
null
FXA_PWDMGR_REALM
)
;
let
potentiallyBreachedLogins
=
null
;
if
(
userFacingLogins
&
&
Services
.
logins
.
isLoggedIn
)
{
const
logins
=
await
LoginHelper
.
getAllUserFacingLogins
(
)
;
potentiallyBreachedLogins
=
await
LoginBreaches
.
getPotentialBreachesByLoginGUID
(
logins
)
;
}
let
mobileDeviceConnected
=
fxAccounts
.
device
.
recentDeviceList
&
&
fxAccounts
.
device
.
recentDeviceList
.
filter
(
device
=
>
device
.
type
=
=
"
mobile
"
)
.
length
;
return
{
numLogins
:
userFacingLogins
potentiallyBreachedLogins
:
potentiallyBreachedLogins
?
potentiallyBreachedLogins
.
size
:
0
mobileDeviceConnected
}
;
}
async
getMonitorData
(
)
{
if
(
gTestOverride
&
&
"
getMonitorData
"
in
gTestOverride
)
{
monitorResponse
=
gTestOverride
.
getMonitorData
(
)
;
monitorResponse
.
timestamp
=
Date
.
now
(
)
;
monitorResponse
=
await
this
.
fetchUserBreachStats
(
)
;
return
monitorResponse
;
}
let
monitorData
=
{
}
;
let
userEmail
=
null
;
let
token
=
await
this
.
getMonitorScopedOAuthToken
(
)
;
try
{
if
(
token
)
{
monitorData
=
await
this
.
fetchUserBreachStats
(
token
)
;
const
{
email
}
=
await
fxAccounts
.
getSignedInUser
(
)
;
userEmail
=
email
;
}
else
{
monitorData
=
{
errorMessage
:
"
No
account
"
}
;
}
}
catch
(
e
)
{
Cu
.
reportError
(
e
.
message
)
;
monitorData
.
errorMessage
=
e
.
message
;
if
(
e
.
message
=
=
=
INVALID_OAUTH_TOKEN
)
{
await
fxAccounts
.
removeCachedOAuthToken
(
{
token
}
)
;
token
=
await
this
.
getMonitorScopedOAuthToken
(
)
;
try
{
monitorData
=
await
this
.
fetchUserBreachStats
(
token
)
;
}
catch
(
_
)
{
Cu
.
reportError
(
e
.
message
)
;
}
}
else
if
(
e
.
message
=
=
=
USER_UNSUBSCRIBED_TO_MONITOR
)
{
const
{
email
}
=
await
fxAccounts
.
getSignedInUser
(
)
;
userEmail
=
email
;
}
else
{
monitorData
.
errorMessage
=
e
.
message
|
|
"
An
error
ocurred
.
"
;
}
}
return
{
.
.
.
monitorData
userEmail
error
:
!
!
monitorData
.
errorMessage
}
;
}
async
getMonitorScopedOAuthToken
(
)
{
let
token
=
null
;
try
{
token
=
await
fxAccounts
.
getOAuthToken
(
{
scope
:
SCOPE_MONITOR
}
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
"
There
was
an
error
fetching
the
user
'
s
token
:
"
e
.
message
)
;
}
return
token
;
}
async
shouldShowProxyCard
(
)
{
const
region
=
Region
.
home
|
|
"
"
;
const
languages
=
Services
.
prefs
.
getComplexValue
(
"
intl
.
accept_languages
"
Ci
.
nsIPrefLocalizedString
)
;
const
alreadyInstalled
=
await
AddonManager
.
getAddonByID
(
SECURE_PROXY_ADDON_ID
)
;
return
(
region
.
toLowerCase
(
)
=
=
=
"
us
"
&
&
!
alreadyInstalled
&
&
languages
.
data
.
toLowerCase
(
)
.
includes
(
"
en
-
us
"
)
)
;
}
async
receiveMessage
(
aMessage
)
{
let
win
=
this
.
browsingContext
.
top
.
embedderElement
.
ownerGlobal
;
switch
(
aMessage
.
name
)
{
case
"
OpenAboutLogins
"
:
LoginHelper
.
openPasswordManager
(
win
{
entryPoint
:
"
aboutprotections
"
}
)
;
break
;
case
"
OpenContentBlockingPreferences
"
:
win
.
openPreferences
(
"
privacy
-
trackingprotection
"
{
origin
:
"
about
-
protections
"
}
)
;
break
;
case
"
OpenSyncPreferences
"
:
win
.
openTrustedLinkIn
(
"
about
:
preferences
#
sync
"
"
tab
"
)
;
break
;
case
"
FetchContentBlockingEvents
"
:
let
dataToSend
=
{
}
;
let
weekdays
=
Services
.
intl
.
getDisplayNames
(
undefined
{
style
:
"
short
"
keys
:
[
"
dates
/
gregorian
/
weekdays
/
sunday
"
"
dates
/
gregorian
/
weekdays
/
monday
"
"
dates
/
gregorian
/
weekdays
/
tuesday
"
"
dates
/
gregorian
/
weekdays
/
wednesday
"
"
dates
/
gregorian
/
weekdays
/
thursday
"
"
dates
/
gregorian
/
weekdays
/
friday
"
"
dates
/
gregorian
/
weekdays
/
saturday
"
"
dates
/
gregorian
/
weekdays
/
sunday
"
]
}
)
;
weekdays
=
Object
.
values
(
weekdays
.
values
)
;
dataToSend
.
weekdays
=
weekdays
;
if
(
PrivateBrowsingUtils
.
isWindowPrivate
(
win
)
)
{
dataToSend
.
isPrivate
=
true
;
return
dataToSend
;
}
let
sumEvents
=
await
TrackingDBService
.
sumAllEvents
(
)
;
let
earliestDate
=
await
TrackingDBService
.
getEarliestRecordedDate
(
)
;
let
eventsByDate
=
await
TrackingDBService
.
getEventsByDateRange
(
aMessage
.
data
.
from
aMessage
.
data
.
to
)
;
let
largest
=
0
;
for
(
let
result
of
eventsByDate
)
{
let
count
=
result
.
getResultByName
(
"
count
"
)
;
let
type
=
result
.
getResultByName
(
"
type
"
)
;
let
timestamp
=
result
.
getResultByName
(
"
timestamp
"
)
;
dataToSend
[
timestamp
]
=
dataToSend
[
timestamp
]
|
|
{
total
:
0
}
;
dataToSend
[
timestamp
]
[
idToTextMap
.
get
(
type
)
]
=
count
;
dataToSend
[
timestamp
]
.
total
+
=
count
;
if
(
largest
<
dataToSend
[
timestamp
]
.
total
)
{
largest
=
dataToSend
[
timestamp
]
.
total
;
}
}
dataToSend
.
largest
=
largest
;
dataToSend
.
earliestDate
=
earliestDate
;
dataToSend
.
sumEvents
=
sumEvents
;
return
dataToSend
;
case
"
FetchMonitorData
"
:
return
this
.
getMonitorData
(
)
;
case
"
FetchUserLoginsData
"
:
return
this
.
getLoginData
(
)
;
case
"
ClearMonitorCache
"
:
monitorResponse
=
null
;
break
;
case
"
GetShowProxyCard
"
:
let
card
=
await
this
.
shouldShowProxyCard
(
)
;
return
card
;
case
"
RecordEntryPoint
"
:
entrypoint
=
aMessage
.
data
.
entrypoint
;
break
;
case
"
FetchEntryPoint
"
:
return
entrypoint
;
}
return
undefined
;
}
}
