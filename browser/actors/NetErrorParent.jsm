var
EXPORTED_SYMBOLS
=
[
"
NetErrorParent
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
PrivateBrowsingUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
const
{
HomePage
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
/
modules
/
HomePage
.
jsm
"
)
;
const
{
TelemetryController
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryController
.
jsm
"
)
;
const
PREF_SSL_IMPACT_ROOTS
=
[
"
security
.
tls
.
version
.
"
"
security
.
ssl3
.
"
"
security
.
tls13
.
"
]
;
const
lazy
=
{
}
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
BrowserUtils
"
"
resource
:
/
/
gre
/
modules
/
BrowserUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
lazy
"
gSerializationHelper
"
"
mozilla
.
org
/
network
/
serialization
-
helper
;
1
"
"
nsISerializationHelper
"
)
;
class
CaptivePortalObserver
{
constructor
(
actor
)
{
this
.
actor
=
actor
;
Services
.
obs
.
addObserver
(
this
"
captive
-
portal
-
login
-
abort
"
)
;
Services
.
obs
.
addObserver
(
this
"
captive
-
portal
-
login
-
success
"
)
;
}
stop
(
)
{
Services
.
obs
.
removeObserver
(
this
"
captive
-
portal
-
login
-
abort
"
)
;
Services
.
obs
.
removeObserver
(
this
"
captive
-
portal
-
login
-
success
"
)
;
}
observe
(
aSubject
aTopic
aData
)
{
switch
(
aTopic
)
{
case
"
captive
-
portal
-
login
-
abort
"
:
case
"
captive
-
portal
-
login
-
success
"
:
this
.
actor
.
sendAsyncMessage
(
"
AboutNetErrorCaptivePortalFreed
"
)
;
break
;
}
}
}
class
NetErrorParent
extends
JSWindowActorParent
{
constructor
(
)
{
super
(
)
;
this
.
captivePortalObserver
=
new
CaptivePortalObserver
(
this
)
;
}
didDestroy
(
)
{
if
(
this
.
captivePortalObserver
)
{
this
.
captivePortalObserver
.
stop
(
)
;
}
}
get
browser
(
)
{
return
this
.
browsingContext
.
top
.
embedderElement
;
}
getSecurityInfo
(
securityInfoAsString
)
{
if
(
!
securityInfoAsString
)
{
return
null
;
}
let
securityInfo
=
lazy
.
gSerializationHelper
.
deserializeObject
(
securityInfoAsString
)
;
securityInfo
.
QueryInterface
(
Ci
.
nsITransportSecurityInfo
)
;
return
securityInfo
;
}
hasChangedCertPrefs
(
)
{
let
prefSSLImpact
=
PREF_SSL_IMPACT_ROOTS
.
reduce
(
(
prefs
root
)
=
>
{
return
prefs
.
concat
(
Services
.
prefs
.
getChildList
(
root
)
)
;
}
[
]
)
;
for
(
let
prefName
of
prefSSLImpact
)
{
if
(
Services
.
prefs
.
prefHasUserValue
(
prefName
)
)
{
return
true
;
}
}
return
false
;
}
async
ReportBlockingError
(
bcID
scheme
host
port
path
xfoAndCspInfo
)
{
let
topBC
=
BrowsingContext
.
get
(
bcID
)
.
top
;
let
topURI
=
topBC
.
currentWindowGlobal
.
documentURI
;
let
frame_uri
=
{
scheme
}
:
/
/
{
host
}
{
port
=
=
-
1
?
"
"
:
"
:
"
+
port
}
{
path
}
;
let
top_uri
=
{
topURI
.
scheme
}
:
/
/
{
topURI
.
hostPort
}
{
topURI
.
filePath
}
;
TelemetryController
.
submitExternalPing
(
"
xfocsp
-
error
-
report
"
{
.
.
.
xfoAndCspInfo
frame_hostname
:
host
top_hostname
:
topURI
.
host
frame_uri
top_uri
}
{
addClientId
:
false
addEnvironment
:
false
}
)
;
}
getDefaultHomePage
(
win
)
{
if
(
PrivateBrowsingUtils
.
isWindowPrivate
(
win
)
)
{
return
win
.
BROWSER_NEW_TAB_URL
;
}
let
url
=
HomePage
.
getDefault
(
)
;
if
(
url
.
includes
(
"
|
"
)
)
{
url
=
url
.
split
(
"
|
"
)
[
0
]
;
}
return
url
;
}
goBackFromErrorPage
(
browser
)
{
if
(
!
browser
.
canGoBack
)
{
browser
.
loadURI
(
this
.
getDefaultHomePage
(
browser
.
ownerGlobal
)
{
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
}
)
;
}
else
{
browser
.
goBack
(
)
;
}
}
primeMitm
(
browser
)
{
if
(
Services
.
prefs
.
getStringPref
(
"
security
.
pki
.
mitm_canary_issuer
"
null
)
)
{
return
;
}
let
url
=
Services
.
prefs
.
getStringPref
(
"
security
.
certerrors
.
mitm
.
priming
.
endpoint
"
)
;
let
request
=
new
XMLHttpRequest
(
{
mozAnon
:
true
}
)
;
request
.
open
(
"
HEAD
"
url
)
;
request
.
channel
.
loadFlags
|
=
Ci
.
nsIRequest
.
LOAD_BYPASS_CACHE
;
request
.
channel
.
loadFlags
|
=
Ci
.
nsIRequest
.
INHIBIT_CACHING
;
request
.
addEventListener
(
"
error
"
event
=
>
{
if
(
!
browser
.
documentURI
.
spec
.
startsWith
(
"
about
:
certerror
"
)
)
{
return
;
}
let
secInfo
=
request
.
channel
.
securityInfo
.
QueryInterface
(
Ci
.
nsITransportSecurityInfo
)
;
if
(
secInfo
.
errorCodeString
!
=
"
SEC_ERROR_UNKNOWN_ISSUER
"
)
{
return
;
}
if
(
secInfo
.
serverCert
&
&
secInfo
.
serverCert
.
issuerName
)
{
Services
.
prefs
.
setStringPref
(
"
security
.
pki
.
mitm_canary_issuer
"
secInfo
.
serverCert
.
issuerName
)
;
if
(
Services
.
prefs
.
getBoolPref
(
"
security
.
certerrors
.
mitm
.
auto_enable_enterprise_roots
"
)
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
"
security
.
enterprise_roots
.
enabled
"
)
)
{
lazy
.
BrowserUtils
.
promiseObserved
(
"
psm
:
enterprise
-
certs
-
imported
"
)
.
then
(
(
)
=
>
{
if
(
browser
.
documentURI
.
spec
.
startsWith
(
"
about
:
certerror
"
)
)
{
browser
.
reload
(
)
;
}
}
)
;
Services
.
prefs
.
setBoolPref
(
"
security
.
enterprise_roots
.
enabled
"
true
)
;
Services
.
prefs
.
setBoolPref
(
"
security
.
enterprise_roots
.
auto
-
enabled
"
true
)
;
}
}
else
{
browser
.
reload
(
)
;
}
}
}
)
;
request
.
send
(
null
)
;
}
displayOfflineSupportPage
(
supportPageSlug
)
{
const
AVAILABLE_PAGES
=
[
"
connection
-
not
-
secure
"
"
time
-
errors
"
]
;
if
(
!
AVAILABLE_PAGES
.
includes
(
supportPageSlug
)
)
{
console
.
log
(
[
Not
supported
]
Offline
support
is
not
yet
available
for
{
supportPageSlug
}
errors
.
)
;
return
;
}
let
offlinePagePath
=
chrome
:
/
/
browser
/
content
/
certerror
/
supportpages
/
{
supportPageSlug
}
.
html
;
let
triggeringPrincipal
=
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
;
this
.
browser
.
loadURI
(
offlinePagePath
{
triggeringPrincipal
}
)
;
}
receiveMessage
(
message
)
{
switch
(
message
.
name
)
{
case
"
Browser
:
EnableOnlineMode
"
:
Services
.
io
.
offline
=
false
;
this
.
browser
.
reload
(
)
;
break
;
case
"
Browser
:
OpenCaptivePortalPage
"
:
this
.
browser
.
ownerGlobal
.
CaptivePortalWatcher
.
ensureCaptivePortalTab
(
)
;
break
;
case
"
Browser
:
PrimeMitm
"
:
this
.
primeMitm
(
this
.
browser
)
;
break
;
case
"
Browser
:
ResetEnterpriseRootsPref
"
:
Services
.
prefs
.
clearUserPref
(
"
security
.
enterprise_roots
.
enabled
"
)
;
Services
.
prefs
.
clearUserPref
(
"
security
.
enterprise_roots
.
auto
-
enabled
"
)
;
break
;
case
"
Browser
:
ResetSSLPreferences
"
:
let
prefSSLImpact
=
PREF_SSL_IMPACT_ROOTS
.
reduce
(
(
prefs
root
)
=
>
{
return
prefs
.
concat
(
Services
.
prefs
.
getChildList
(
root
)
)
;
}
[
]
)
;
for
(
let
prefName
of
prefSSLImpact
)
{
Services
.
prefs
.
clearUserPref
(
prefName
)
;
}
this
.
browser
.
reload
(
)
;
break
;
case
"
Browser
:
SSLErrorGoBack
"
:
this
.
goBackFromErrorPage
(
this
.
browser
)
;
break
;
case
"
Browser
:
SSLErrorReportTelemetry
"
:
let
reportStatus
=
message
.
data
.
reportStatus
;
Services
.
telemetry
.
getHistogramById
(
"
TLS_ERROR_REPORT_UI
"
)
.
add
(
reportStatus
)
;
break
;
case
"
GetChangedCertPrefs
"
:
let
hasChangedCertPrefs
=
this
.
hasChangedCertPrefs
(
)
;
this
.
sendAsyncMessage
(
"
HasChangedCertPrefs
"
{
hasChangedCertPrefs
}
)
;
break
;
case
"
ReportBlockingError
"
:
this
.
ReportBlockingError
(
this
.
browsingContext
.
id
message
.
data
.
scheme
message
.
data
.
host
message
.
data
.
port
message
.
data
.
path
message
.
data
.
xfoAndCspInfo
)
;
break
;
case
"
DisplayOfflineSupportPage
"
:
this
.
displayOfflineSupportPage
(
message
.
data
.
supportPageSlug
)
;
break
;
case
"
Browser
:
CertExceptionError
"
:
switch
(
message
.
data
.
elementId
)
{
case
"
viewCertificate
"
:
{
let
window
=
this
.
browser
.
ownerGlobal
;
let
securityInfo
=
this
.
getSecurityInfo
(
message
.
data
.
securityInfoAsString
)
;
let
certChain
=
securityInfo
.
failedCertChain
;
let
certs
=
certChain
.
map
(
elem
=
>
encodeURIComponent
(
elem
.
getBase64DERString
(
)
)
)
;
let
certsStringURL
=
certs
.
map
(
elem
=
>
cert
=
{
elem
}
)
;
certsStringURL
=
certsStringURL
.
join
(
"
&
"
)
;
let
url
=
about
:
certificate
?
{
certsStringURL
}
;
window
.
switchToTabHavingURI
(
url
true
{
}
)
;
break
;
}
}
}
}
}
