"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
WebRTCParent
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
PluralForm
"
"
resource
:
/
/
gre
/
modules
/
PluralForm
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
PrivateBrowsingUtils
"
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
SitePermissions
"
"
resource
:
/
/
/
modules
/
SitePermissions
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
webrtcUI
"
"
resource
:
/
/
/
modules
/
webrtcUI
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
gBrandBundle
"
function
(
)
{
return
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
branding
/
locale
/
brand
.
properties
"
)
;
}
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
lazy
"
OSPermissions
"
"
mozilla
.
org
/
ospermissionrequest
;
1
"
"
nsIOSPermissionRequest
"
)
;
const
PIPEWIRE_PORTAL_NAME
=
"
#
#
#
#
_PIPEWIRE_PORTAL_
#
#
#
#
"
;
const
PIPEWIRE_ID
=
0xaffffff
;
class
WebRTCParent
extends
JSWindowActorParent
{
didDestroy
(
)
{
this
.
stopRecording
(
this
.
manager
.
outerWindowId
)
;
lazy
.
webrtcUI
.
forgetStreamsFromBrowserContext
(
this
.
browsingContext
)
;
lazy
.
webrtcUI
.
activePerms
.
delete
(
this
.
manager
.
outerWindowId
)
;
}
getBrowser
(
)
{
return
this
.
browsingContext
.
top
.
embedderElement
;
}
receiveMessage
(
aMessage
)
{
switch
(
aMessage
.
name
)
{
case
"
rtcpeer
:
Request
"
:
{
let
params
=
Object
.
freeze
(
Object
.
assign
(
{
origin
:
this
.
manager
.
documentPrincipal
.
origin
}
aMessage
.
data
)
)
;
let
blockers
=
Array
.
from
(
lazy
.
webrtcUI
.
peerConnectionBlockers
)
;
(
async
function
(
)
{
for
(
let
blocker
of
blockers
)
{
try
{
let
result
=
await
blocker
(
params
)
;
if
(
result
=
=
"
deny
"
)
{
return
false
;
}
}
catch
(
err
)
{
Cu
.
reportError
(
error
in
PeerConnection
blocker
:
{
err
.
message
}
)
;
}
}
return
true
;
}
)
(
)
.
then
(
decision
=
>
{
let
message
;
if
(
decision
)
{
lazy
.
webrtcUI
.
emitter
.
emit
(
"
peer
-
request
-
allowed
"
params
)
;
message
=
"
rtcpeer
:
Allow
"
;
}
else
{
lazy
.
webrtcUI
.
emitter
.
emit
(
"
peer
-
request
-
blocked
"
params
)
;
message
=
"
rtcpeer
:
Deny
"
;
}
this
.
sendAsyncMessage
(
message
{
callID
:
params
.
callID
windowID
:
params
.
windowID
}
)
;
}
)
;
break
;
}
case
"
rtcpeer
:
CancelRequest
"
:
{
let
params
=
Object
.
freeze
(
{
origin
:
this
.
manager
.
documentPrincipal
.
origin
callID
:
aMessage
.
data
}
)
;
lazy
.
webrtcUI
.
emitter
.
emit
(
"
peer
-
request
-
cancel
"
params
)
;
break
;
}
case
"
webrtc
:
Request
"
:
{
let
data
=
aMessage
.
data
;
let
isThirdPartyOrigin
=
this
.
manager
.
documentPrincipal
.
origin
!
=
this
.
manager
.
topWindowContext
.
documentPrincipal
.
origin
;
data
.
isThirdPartyOrigin
=
isThirdPartyOrigin
;
data
.
origin
=
data
.
shouldDelegatePermission
?
this
.
manager
.
topWindowContext
.
documentPrincipal
.
origin
:
this
.
manager
.
documentPrincipal
.
origin
;
let
browser
=
this
.
getBrowser
(
)
;
if
(
browser
.
fxrPermissionPrompt
)
{
browser
.
fxrPermissionPrompt
(
data
)
;
}
else
{
prompt
(
this
this
.
getBrowser
(
)
data
)
;
}
break
;
}
case
"
webrtc
:
StopRecording
"
:
this
.
stopRecording
(
aMessage
.
data
.
windowID
aMessage
.
data
.
mediaSource
aMessage
.
data
.
rawID
)
;
break
;
case
"
webrtc
:
CancelRequest
"
:
{
let
browser
=
this
.
getBrowser
(
)
;
if
(
browser
)
{
removePrompt
(
browser
aMessage
.
data
)
;
}
break
;
}
case
"
webrtc
:
UpdateIndicators
"
:
{
let
{
data
}
=
aMessage
;
data
.
documentURI
=
this
.
manager
.
documentURI
?
.
spec
;
if
(
data
.
windowId
)
{
if
(
!
data
.
remove
)
{
data
.
principal
=
this
.
manager
.
topWindowContext
.
documentPrincipal
;
}
lazy
.
webrtcUI
.
streamAddedOrRemoved
(
this
.
browsingContext
data
)
;
}
this
.
updateIndicators
(
data
)
;
break
;
}
}
}
updateIndicators
(
aData
)
{
let
browsingContext
=
this
.
browsingContext
;
let
state
=
lazy
.
webrtcUI
.
updateIndicators
(
browsingContext
.
top
)
;
let
browser
=
this
.
getBrowser
(
)
;
if
(
!
browser
)
{
return
;
}
state
.
browsingContext
=
browsingContext
;
state
.
windowId
=
aData
.
windowId
;
let
tabbrowser
=
browser
.
ownerGlobal
.
gBrowser
;
if
(
tabbrowser
)
{
tabbrowser
.
updateBrowserSharing
(
browser
{
webRTC
:
state
}
)
;
}
}
denyRequest
(
aRequest
)
{
this
.
sendAsyncMessage
(
"
webrtc
:
Deny
"
{
callID
:
aRequest
.
callID
windowID
:
aRequest
.
windowID
}
)
;
}
denyRequestNoPermission
(
aRequest
)
{
this
.
sendAsyncMessage
(
"
webrtc
:
Deny
"
{
callID
:
aRequest
.
callID
windowID
:
aRequest
.
windowID
noOSPermission
:
true
}
)
;
}
async
checkOSPermission
(
camNeeded
micNeeded
scrNeeded
)
{
if
(
!
scrNeeded
&
&
Services
.
prefs
.
getBoolPref
(
"
media
.
navigator
.
streams
.
fake
"
false
)
)
{
return
true
;
}
let
camStatus
=
{
}
micStatus
=
{
}
;
if
(
camNeeded
|
|
micNeeded
)
{
lazy
.
OSPermissions
.
getMediaCapturePermissionState
(
camStatus
micStatus
)
;
}
if
(
camNeeded
)
{
let
camPermission
=
camStatus
.
value
;
let
camAccessible
=
await
this
.
checkAndGetOSPermission
(
camPermission
lazy
.
OSPermissions
.
requestVideoCapturePermission
)
;
if
(
!
camAccessible
)
{
return
false
;
}
}
if
(
micNeeded
)
{
let
micPermission
=
micStatus
.
value
;
let
micAccessible
=
await
this
.
checkAndGetOSPermission
(
micPermission
lazy
.
OSPermissions
.
requestAudioCapturePermission
)
;
if
(
!
micAccessible
)
{
return
false
;
}
}
let
scrStatus
=
{
}
;
if
(
scrNeeded
)
{
lazy
.
OSPermissions
.
getScreenCapturePermissionState
(
scrStatus
)
;
if
(
scrStatus
.
value
=
=
lazy
.
OSPermissions
.
PERMISSION_STATE_DENIED
)
{
lazy
.
OSPermissions
.
maybeRequestScreenCapturePermission
(
)
;
return
false
;
}
}
return
true
;
}
async
checkAndGetOSPermission
(
devicePermission
requestPermissionFunc
)
{
if
(
devicePermission
=
=
lazy
.
OSPermissions
.
PERMISSION_STATE_DENIED
|
|
devicePermission
=
=
lazy
.
OSPermissions
.
PERMISSION_STATE_RESTRICTED
)
{
return
false
;
}
if
(
devicePermission
=
=
lazy
.
OSPermissions
.
PERMISSION_STATE_NOTDETERMINED
)
{
let
deviceAllowed
=
await
requestPermissionFunc
(
)
;
if
(
!
deviceAllowed
)
{
return
false
;
}
}
return
true
;
}
stopRecording
(
aOuterWindowId
aMediaSource
aRawId
)
{
for
(
let
{
browsingContext
state
}
of
lazy
.
webrtcUI
.
_streams
)
{
if
(
browsingContext
=
=
this
.
browsingContext
)
{
let
{
principal
}
=
state
;
for
(
let
{
mediaSource
rawId
}
of
state
.
devices
)
{
if
(
aRawId
&
&
(
aRawId
!
=
rawId
|
|
aMediaSource
!
=
mediaSource
)
)
{
continue
;
}
this
.
deactivateDevicePerm
(
aOuterWindowId
mediaSource
rawId
principal
)
;
}
}
}
}
activateDevicePerm
(
aOuterWindowId
aMediaSource
aId
)
{
if
(
!
lazy
.
webrtcUI
.
activePerms
.
has
(
this
.
manager
.
outerWindowId
)
)
{
lazy
.
webrtcUI
.
activePerms
.
set
(
this
.
manager
.
outerWindowId
new
Set
(
)
)
;
}
lazy
.
webrtcUI
.
activePerms
.
get
(
this
.
manager
.
outerWindowId
)
.
add
(
aOuterWindowId
+
aMediaSource
+
aId
)
;
}
deactivateDevicePerm
(
aOuterWindowId
aMediaSource
aId
aPermissionPrincipal
)
{
if
(
!
lazy
.
webrtcUI
.
activePerms
.
has
(
this
.
manager
.
outerWindowId
)
)
{
return
;
}
let
set
=
lazy
.
webrtcUI
.
activePerms
.
get
(
this
.
manager
.
outerWindowId
)
;
set
.
delete
(
aOuterWindowId
+
aMediaSource
+
aId
)
;
if
(
(
aMediaSource
!
=
"
camera
"
&
&
aMediaSource
!
=
"
microphone
"
)
|
|
!
this
.
browsingContext
.
top
.
embedderElement
)
{
return
;
}
let
gracePeriodMs
=
lazy
.
webrtcUI
.
deviceGracePeriodTimeoutMs
;
if
(
gracePeriodMs
>
0
)
{
let
permissionName
=
[
aMediaSource
aId
]
.
join
(
"
^
"
)
;
lazy
.
SitePermissions
.
setForPrincipal
(
aPermissionPrincipal
permissionName
lazy
.
SitePermissions
.
ALLOW
lazy
.
SitePermissions
.
SCOPE_TEMPORARY
this
.
browsingContext
.
top
.
embedderElement
gracePeriodMs
aPermissionPrincipal
.
URI
)
;
}
}
checkRequestAllowed
(
aRequest
aPrincipal
)
{
if
(
!
aRequest
.
secure
)
{
return
false
;
}
if
(
aRequest
.
sharingScreen
)
{
return
false
;
}
if
(
aRequest
.
audioOutputDevices
?
.
length
)
{
return
false
;
}
let
{
perms
}
=
Services
;
if
(
perms
.
testExactPermissionFromPrincipal
(
aPrincipal
"
MediaManagerVideo
"
)
)
{
perms
.
removeFromPrincipal
(
aPrincipal
"
MediaManagerVideo
"
)
;
}
let
limited
=
(
aRequest
.
isThirdPartyOrigin
&
&
!
aRequest
.
shouldDelegatePermission
)
|
|
aRequest
.
secondOrigin
;
let
set
=
lazy
.
webrtcUI
.
activePerms
.
get
(
this
.
manager
.
outerWindowId
)
;
let
{
callID
windowID
audioInputDevices
videoInputDevices
hasInherentAudioConstraints
hasInherentVideoConstraints
}
=
aRequest
;
const
isAllowed
=
(
{
mediaSource
id
}
permissionID
)
=
>
set
?
.
has
(
windowID
+
mediaSource
+
id
)
|
|
(
!
limited
&
&
(
lazy
.
SitePermissions
.
getForPrincipal
(
aPrincipal
permissionID
)
.
state
=
=
lazy
.
SitePermissions
.
ALLOW
|
|
lazy
.
SitePermissions
.
getForPrincipal
(
aPrincipal
[
mediaSource
id
]
.
join
(
"
^
"
)
this
.
getBrowser
(
)
)
.
state
=
=
lazy
.
SitePermissions
.
ALLOW
)
)
;
let
microphone
;
if
(
audioInputDevices
.
length
)
{
for
(
let
device
of
audioInputDevices
)
{
if
(
isAllowed
(
device
"
microphone
"
)
)
{
microphone
=
device
;
break
;
}
if
(
hasInherentAudioConstraints
)
{
break
;
}
}
if
(
!
microphone
)
{
return
false
;
}
}
let
camera
;
if
(
videoInputDevices
.
length
)
{
for
(
let
device
of
videoInputDevices
)
{
if
(
isAllowed
(
device
"
camera
"
)
)
{
camera
=
device
;
break
;
}
if
(
hasInherentVideoConstraints
)
{
break
;
}
}
if
(
!
camera
)
{
return
false
;
}
}
let
devices
=
[
]
;
if
(
camera
)
{
perms
.
addFromPrincipal
(
aPrincipal
"
MediaManagerVideo
"
perms
.
ALLOW_ACTION
perms
.
EXPIRE_SESSION
)
;
devices
.
push
(
camera
.
deviceIndex
)
;
this
.
activateDevicePerm
(
windowID
camera
.
mediaSource
camera
.
id
)
;
}
if
(
microphone
)
{
devices
.
push
(
microphone
.
deviceIndex
)
;
this
.
activateDevicePerm
(
windowID
microphone
.
mediaSource
microphone
.
id
)
;
}
this
.
checkOSPermission
(
!
!
camera
!
!
microphone
false
)
.
then
(
havePermission
=
>
{
if
(
havePermission
)
{
this
.
sendAsyncMessage
(
"
webrtc
:
Allow
"
{
callID
windowID
devices
}
)
;
}
else
{
this
.
denyRequestNoPermission
(
aRequest
)
;
}
}
)
;
return
true
;
}
}
function
prompt
(
aActor
aBrowser
aRequest
)
{
let
{
audioInputDevices
videoInputDevices
audioOutputDevices
sharingScreen
sharingAudio
requestTypes
}
=
aRequest
;
let
principal
=
Services
.
scriptSecurityManager
.
createContentPrincipalFromOrigin
(
aRequest
.
origin
)
;
if
(
principal
.
addonPolicy
)
{
let
isPopup
=
false
;
let
isBackground
=
false
;
for
(
let
view
of
principal
.
addonPolicy
.
extension
.
views
)
{
if
(
view
.
viewType
=
=
"
popup
"
&
&
view
.
xulBrowser
=
=
aBrowser
)
{
isPopup
=
true
;
}
if
(
view
.
viewType
=
=
"
background
"
&
&
view
.
xulBrowser
=
=
aBrowser
)
{
isBackground
=
true
;
}
}
if
(
isBackground
)
{
aActor
.
denyRequest
(
aRequest
)
;
return
;
}
if
(
isPopup
)
{
if
(
!
aActor
.
checkRequestAllowed
(
aRequest
principal
aBrowser
)
)
{
aActor
.
denyRequest
(
aRequest
)
;
}
return
;
}
}
for
(
const
type
of
requestTypes
)
{
const
permissionID
=
type
=
=
"
AudioCapture
"
?
"
microphone
"
:
type
.
toLowerCase
(
)
;
if
(
lazy
.
SitePermissions
.
getForPrincipal
(
principal
permissionID
aBrowser
)
.
state
=
=
lazy
.
SitePermissions
.
BLOCK
)
{
aActor
.
denyRequest
(
aRequest
)
;
return
;
}
}
let
chromeDoc
=
aBrowser
.
ownerDocument
;
let
stringBundle
=
chromeDoc
.
defaultView
.
gNavigatorBundle
;
let
localization
=
new
Localization
(
[
"
branding
/
brand
.
ftl
"
"
browser
/
browser
.
ftl
"
]
true
)
;
let
joinedRequestTypes
=
requestTypes
.
join
(
"
And
"
)
;
let
requestMessages
;
if
(
aRequest
.
secondOrigin
)
{
requestMessages
=
[
"
getUserMedia
.
shareCameraUnsafeDelegation2
.
message
"
"
getUserMedia
.
shareMicrophoneUnsafeDelegations2
.
message
"
"
getUserMedia
.
shareScreenUnsafeDelegation2
.
message
"
"
getUserMedia
.
shareAudioCaptureUnsafeDelegation2
.
message
"
"
selectAudioOutput
.
shareSpeakerUnsafeDelegation
.
message
"
"
getUserMedia
.
shareCameraAndMicrophoneUnsafeDelegation2
.
message
"
"
getUserMedia
.
shareCameraAndAudioCaptureUnsafeDelegation2
.
message
"
"
getUserMedia
.
shareScreenAndMicrophoneUnsafeDelegation2
.
message
"
"
getUserMedia
.
shareScreenAndAudioCaptureUnsafeDelegation2
.
message
"
]
;
}
else
{
requestMessages
=
[
"
getUserMedia
.
shareCamera3
.
message
"
"
getUserMedia
.
shareMicrophone3
.
message
"
"
getUserMedia
.
shareScreen4
.
message
"
"
getUserMedia
.
shareAudioCapture3
.
message
"
"
selectAudioOutput
.
shareSpeaker
.
message
"
"
getUserMedia
.
shareCameraAndMicrophone3
.
message
"
"
getUserMedia
.
shareCameraAndAudioCapture3
.
message
"
"
getUserMedia
.
shareScreenAndMicrophone4
.
message
"
"
getUserMedia
.
shareScreenAndAudioCapture4
.
message
"
]
;
}
let
stringId
=
requestMessages
.
find
(
id
=
>
id
.
includes
(
joinedRequestTypes
)
)
;
let
message
=
aRequest
.
secondOrigin
?
stringBundle
.
getFormattedString
(
stringId
[
"
<
>
"
"
{
}
"
]
)
:
stringBundle
.
getFormattedString
(
stringId
[
"
<
>
"
]
)
;
let
notification
;
let
mainAction
=
{
label
:
stringBundle
.
getString
(
"
getUserMedia
.
allow
.
label
"
)
accessKey
:
stringBundle
.
getString
(
"
getUserMedia
.
allow
.
accesskey
"
)
callback
(
)
{
}
}
;
let
notificationSilencingEnabled
=
Services
.
prefs
.
getBoolPref
(
"
privacy
.
webrtc
.
allowSilencingNotifications
"
)
;
let
secondaryActions
=
[
]
;
if
(
notificationSilencingEnabled
&
&
sharingScreen
)
{
let
convertAttributesToObjects
=
messages
=
>
{
return
messages
.
map
(
msg
=
>
{
return
msg
.
attributes
.
reduce
(
(
acc
attribute
)
=
>
{
acc
[
attribute
.
name
]
=
attribute
.
value
;
return
acc
;
}
{
}
)
;
}
)
;
}
;
let
[
block
alwaysBlock
]
=
convertAttributesToObjects
(
localization
.
formatMessagesSync
(
[
{
id
:
"
popup
-
screen
-
sharing
-
block
"
}
{
id
:
"
popup
-
screen
-
sharing
-
always
-
block
"
}
]
)
)
;
secondaryActions
=
[
{
label
:
block
.
label
accessKey
:
block
.
accesskey
callback
(
aState
)
{
aActor
.
denyRequest
(
aRequest
)
;
lazy
.
SitePermissions
.
setForPrincipal
(
principal
"
screen
"
lazy
.
SitePermissions
.
BLOCK
lazy
.
SitePermissions
.
SCOPE_TEMPORARY
notification
.
browser
)
;
}
}
{
label
:
alwaysBlock
.
label
accessKey
:
alwaysBlock
.
accesskey
callback
(
aState
)
{
aActor
.
denyRequest
(
aRequest
)
;
lazy
.
SitePermissions
.
setForPrincipal
(
principal
"
screen
"
lazy
.
SitePermissions
.
BLOCK
lazy
.
SitePermissions
.
SCOPE_PERSISTENT
notification
.
browser
)
;
}
}
]
;
}
else
{
secondaryActions
=
[
{
label
:
stringBundle
.
getString
(
"
getUserMedia
.
block
.
label
"
)
accessKey
:
stringBundle
.
getString
(
"
getUserMedia
.
block
.
accesskey
"
)
callback
(
aState
)
{
aActor
.
denyRequest
(
aRequest
)
;
clearTemporaryGrants
(
notification
.
browser
videoInputDevices
.
length
&
&
!
sharingScreen
audioInputDevices
.
length
)
;
let
scope
=
lazy
.
SitePermissions
.
SCOPE_TEMPORARY
;
if
(
aState
&
&
aState
.
checkboxChecked
)
{
scope
=
lazy
.
SitePermissions
.
SCOPE_PERSISTENT
;
}
if
(
audioInputDevices
.
length
)
{
lazy
.
SitePermissions
.
setForPrincipal
(
principal
"
microphone
"
lazy
.
SitePermissions
.
BLOCK
scope
notification
.
browser
)
;
}
if
(
videoInputDevices
.
length
)
{
lazy
.
SitePermissions
.
setForPrincipal
(
principal
sharingScreen
?
"
screen
"
:
"
camera
"
lazy
.
SitePermissions
.
BLOCK
scope
notification
.
browser
)
;
}
}
}
]
;
}
let
productName
=
lazy
.
gBrandBundle
.
GetStringFromName
(
"
brandShortName
"
)
;
let
options
=
{
name
:
lazy
.
webrtcUI
.
getHostOrExtensionName
(
principal
.
URI
)
persistent
:
true
hideClose
:
true
eventCallback
(
aTopic
aNewBrowser
isCancel
)
{
if
(
aTopic
=
=
"
swapping
"
)
{
return
true
;
}
let
doc
=
this
.
browser
.
ownerDocument
;
if
(
(
(
aTopic
=
=
"
dismissed
"
|
|
aTopic
=
=
"
removed
"
)
&
&
requestTypes
.
includes
(
"
Screen
"
)
)
|
|
!
requestTypes
.
includes
(
"
Screen
"
)
)
{
let
video
=
doc
.
getElementById
(
"
webRTC
-
previewVideo
"
)
;
if
(
video
.
stream
)
{
video
.
stream
.
getTracks
(
)
.
forEach
(
t
=
>
t
.
stop
(
)
)
;
video
.
stream
=
null
;
video
.
src
=
null
;
doc
.
getElementById
(
"
webRTC
-
preview
"
)
.
hidden
=
true
;
}
let
menupopup
=
doc
.
getElementById
(
"
webRTC
-
selectWindow
-
menupopup
"
)
;
if
(
menupopup
.
_commandEventListener
)
{
menupopup
.
removeEventListener
(
"
command
"
menupopup
.
_commandEventListener
)
;
menupopup
.
_commandEventListener
=
null
;
}
}
if
(
aTopic
=
=
"
removed
"
&
&
notification
&
&
isCancel
)
{
aActor
.
denyRequest
(
aRequest
)
;
}
if
(
aTopic
!
=
"
showing
"
)
{
return
false
;
}
if
(
aActor
.
checkRequestAllowed
(
aRequest
principal
aBrowser
)
)
{
this
.
remove
(
)
;
return
true
;
}
function
listDevices
(
menupopup
devices
labelID
)
{
while
(
menupopup
.
lastChild
)
{
menupopup
.
removeChild
(
menupopup
.
lastChild
)
;
}
let
menulist
=
menupopup
.
parentNode
;
menulist
.
removeAttribute
(
"
value
"
)
;
menulist
.
selectedItem
=
null
;
for
(
let
device
of
devices
)
{
addDeviceToList
(
menupopup
device
.
name
device
.
deviceIndex
)
;
}
let
label
=
doc
.
getElementById
(
labelID
)
;
if
(
devices
.
length
=
=
1
)
{
label
.
value
=
devices
[
0
]
.
name
;
label
.
hidden
=
false
;
menulist
.
hidden
=
true
;
}
else
{
label
.
hidden
=
true
;
menulist
.
hidden
=
false
;
}
}
let
notificationElement
=
doc
.
getElementById
(
"
webRTC
-
shareDevices
-
notification
"
)
;
function
checkDisabledWindowMenuItem
(
)
{
let
list
=
doc
.
getElementById
(
"
webRTC
-
selectWindow
-
menulist
"
)
;
let
item
=
list
.
selectedItem
;
if
(
!
item
|
|
item
.
hasAttribute
(
"
disabled
"
)
)
{
notificationElement
.
setAttribute
(
"
invalidselection
"
"
true
"
)
;
}
else
{
notificationElement
.
removeAttribute
(
"
invalidselection
"
)
;
}
}
function
listScreenShareDevices
(
menupopup
devices
)
{
while
(
menupopup
.
lastChild
)
{
menupopup
.
removeChild
(
menupopup
.
lastChild
)
;
}
menupopup
.
parentNode
.
removeAttribute
(
"
value
"
)
;
menupopup
.
parentNode
.
selectedItem
=
null
;
let
label
=
doc
.
getElementById
(
"
webRTC
-
selectWindow
-
label
"
)
;
const
gumStringId
=
"
getUserMedia
.
selectWindowOrScreen2
"
;
label
.
setAttribute
(
"
value
"
stringBundle
.
getString
(
gumStringId
+
"
.
label
"
)
)
;
label
.
setAttribute
(
"
accesskey
"
stringBundle
.
getString
(
gumStringId
+
"
.
accesskey
"
)
)
;
addDeviceToList
(
menupopup
stringBundle
.
getString
(
"
getUserMedia
.
pickWindowOrScreen
.
label
"
)
"
-
1
"
)
;
menupopup
.
appendChild
(
doc
.
createXULElement
(
"
menuseparator
"
)
)
;
let
isPipeWire
=
false
;
let
monitorIndex
=
1
;
for
(
let
i
=
0
;
i
<
devices
.
length
;
+
+
i
)
{
let
device
=
devices
[
i
]
;
let
type
=
device
.
mediaSource
;
let
name
;
if
(
type
=
=
"
screen
"
)
{
if
(
device
.
name
=
=
"
Primary
Monitor
"
)
{
name
=
stringBundle
.
getString
(
"
getUserMedia
.
shareEntireScreen
.
label
"
)
;
}
else
{
name
=
stringBundle
.
getFormattedString
(
"
getUserMedia
.
shareMonitor
.
label
"
[
monitorIndex
]
)
;
+
+
monitorIndex
;
}
}
else
{
name
=
device
.
name
;
if
(
name
=
=
PIPEWIRE_PORTAL_NAME
&
&
device
.
id
=
=
PIPEWIRE_ID
)
{
isPipeWire
=
true
;
let
sawcStringId
=
"
getUserMedia
.
sharePipeWirePortal
.
label
"
;
let
item
=
addDeviceToList
(
menupopup
stringBundle
.
getString
(
sawcStringId
)
i
type
)
;
item
.
deviceId
=
device
.
id
;
item
.
mediaSource
=
type
;
menupopup
.
parentNode
.
selectedItem
=
item
;
menupopup
.
parentNode
.
disabled
=
true
;
break
;
}
if
(
type
=
=
"
application
"
)
{
let
sepIndex
=
name
.
indexOf
(
"
\
x1e
"
)
;
let
count
=
name
.
slice
(
0
sepIndex
)
;
let
sawcStringId
=
"
getUserMedia
.
shareApplicationWindowCount
.
label
"
;
name
=
lazy
.
PluralForm
.
get
(
parseInt
(
count
)
stringBundle
.
getString
(
sawcStringId
)
)
.
replace
(
"
#
1
"
name
.
slice
(
sepIndex
+
1
)
)
.
replace
(
"
#
2
"
count
)
;
}
}
let
item
=
addDeviceToList
(
menupopup
name
i
type
)
;
item
.
deviceId
=
device
.
id
;
item
.
mediaSource
=
type
;
if
(
device
.
scary
)
{
item
.
scary
=
true
;
}
}
doc
.
getElementById
(
"
webRTC
-
selectWindow
-
menulist
"
)
.
removeAttribute
(
"
value
"
)
;
doc
.
getElementById
(
"
webRTC
-
all
-
windows
-
shared
"
)
.
hidden
=
true
;
menupopup
.
_commandEventListener
=
event
=
>
{
checkDisabledWindowMenuItem
(
)
;
let
video
=
doc
.
getElementById
(
"
webRTC
-
previewVideo
"
)
;
if
(
video
.
stream
)
{
video
.
stream
.
getTracks
(
)
.
forEach
(
t
=
>
t
.
stop
(
)
)
;
video
.
stream
=
null
;
}
let
type
=
event
.
target
.
mediaSource
;
let
deviceId
=
event
.
target
.
deviceId
;
if
(
deviceId
=
=
undefined
)
{
doc
.
getElementById
(
"
webRTC
-
preview
"
)
.
hidden
=
true
;
video
.
src
=
null
;
return
;
}
let
scary
=
event
.
target
.
scary
;
let
warning
=
doc
.
getElementById
(
"
webRTC
-
previewWarning
"
)
;
let
warningBox
=
doc
.
getElementById
(
"
webRTC
-
previewWarningBox
"
)
;
warningBox
.
hidden
=
!
scary
;
let
chromeWin
=
doc
.
defaultView
;
if
(
scary
)
{
warningBox
.
hidden
=
false
;
let
string
;
let
bundle
=
chromeWin
.
gNavigatorBundle
;
let
learnMoreText
=
bundle
.
getString
(
"
getUserMedia
.
shareScreen
.
learnMoreLabel
"
)
;
let
baseURL
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
;
if
(
type
=
=
"
screen
"
)
{
string
=
bundle
.
getString
(
"
getUserMedia
.
shareScreenWarning2
.
message
"
)
;
}
else
{
let
brand
=
doc
.
getElementById
(
"
bundle_brand
"
)
.
getString
(
"
brandShortName
"
)
;
string
=
bundle
.
getFormattedString
(
"
getUserMedia
.
shareFirefoxWarning2
.
message
"
[
brand
]
)
;
}
warning
.
textContent
=
string
;
let
learnMore
=
doc
.
getElementById
(
"
webRTC
-
previewWarning
-
learnMore
"
)
;
learnMore
.
setAttribute
(
"
href
"
baseURL
+
"
screenshare
-
safety
"
)
;
learnMore
.
textContent
=
learnMoreText
;
let
scrStatus
=
{
}
;
lazy
.
OSPermissions
.
getScreenCapturePermissionState
(
scrStatus
)
;
if
(
scrStatus
.
value
=
=
lazy
.
OSPermissions
.
PERMISSION_STATE_DENIED
)
{
lazy
.
OSPermissions
.
maybeRequestScreenCapturePermission
(
)
;
}
}
let
perms
=
Services
.
perms
;
let
chromePrincipal
=
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
;
perms
.
addFromPrincipal
(
chromePrincipal
"
MediaManagerVideo
"
perms
.
ALLOW_ACTION
perms
.
EXPIRE_SESSION
)
;
if
(
!
isPipeWire
)
{
video
.
deviceId
=
deviceId
;
let
constraints
=
{
video
:
{
mediaSource
:
type
deviceId
:
{
exact
:
deviceId
}
}
}
;
chromeWin
.
navigator
.
mediaDevices
.
getUserMedia
(
constraints
)
.
then
(
stream
=
>
{
if
(
video
.
deviceId
!
=
deviceId
)
{
stream
.
getTracks
(
)
.
forEach
(
t
=
>
t
.
stop
(
)
)
;
return
;
}
video
.
srcObject
=
stream
;
video
.
stream
=
stream
;
doc
.
getElementById
(
"
webRTC
-
preview
"
)
.
hidden
=
false
;
video
.
onloadedmetadata
=
function
(
e
)
{
video
.
play
(
)
;
}
;
}
err
=
>
{
if
(
err
.
name
=
=
"
OverconstrainedError
"
&
&
err
.
constraint
=
=
"
deviceId
"
)
{
return
;
}
Cu
.
reportError
(
error
in
preview
:
{
err
.
message
}
{
err
.
constraint
}
)
;
}
)
;
}
}
;
menupopup
.
addEventListener
(
"
command
"
menupopup
.
_commandEventListener
)
;
}
function
addDeviceToList
(
menupopup
deviceName
deviceIndex
type
)
{
let
menuitem
=
doc
.
createXULElement
(
"
menuitem
"
)
;
menuitem
.
setAttribute
(
"
value
"
deviceIndex
)
;
menuitem
.
setAttribute
(
"
label
"
deviceName
)
;
menuitem
.
setAttribute
(
"
tooltiptext
"
deviceName
)
;
if
(
type
)
{
menuitem
.
setAttribute
(
"
devicetype
"
type
)
;
}
if
(
deviceIndex
=
=
"
-
1
"
)
{
menuitem
.
setAttribute
(
"
disabled
"
true
)
;
}
menupopup
.
appendChild
(
menuitem
)
;
return
menuitem
;
}
doc
.
getElementById
(
"
webRTC
-
selectCamera
"
)
.
hidden
=
!
videoInputDevices
.
length
|
|
sharingScreen
;
doc
.
getElementById
(
"
webRTC
-
selectWindowOrScreen
"
)
.
hidden
=
!
sharingScreen
|
|
!
videoInputDevices
.
length
;
doc
.
getElementById
(
"
webRTC
-
selectMicrophone
"
)
.
hidden
=
!
audioInputDevices
.
length
|
|
sharingAudio
;
doc
.
getElementById
(
"
webRTC
-
selectSpeaker
"
)
.
hidden
=
!
audioOutputDevices
.
length
;
let
camMenupopup
=
doc
.
getElementById
(
"
webRTC
-
selectCamera
-
menupopup
"
)
;
let
windowMenupopup
=
doc
.
getElementById
(
"
webRTC
-
selectWindow
-
menupopup
"
)
;
let
micMenupopup
=
doc
.
getElementById
(
"
webRTC
-
selectMicrophone
-
menupopup
"
)
;
let
speakerMenupopup
=
doc
.
getElementById
(
"
webRTC
-
selectSpeaker
-
menupopup
"
)
;
let
describedByIDs
=
[
"
webRTC
-
shareDevices
-
notification
-
description
"
]
;
let
describedBySuffix
=
"
icon
"
;
if
(
sharingScreen
)
{
listScreenShareDevices
(
windowMenupopup
videoInputDevices
)
;
checkDisabledWindowMenuItem
(
)
;
}
else
{
let
labelID
=
"
webRTC
-
selectCamera
-
single
-
device
-
label
"
;
listDevices
(
camMenupopup
videoInputDevices
labelID
)
;
notificationElement
.
removeAttribute
(
"
invalidselection
"
)
;
if
(
videoInputDevices
.
length
=
=
1
)
{
describedByIDs
.
push
(
"
webRTC
-
selectCamera
-
"
+
describedBySuffix
)
;
describedByIDs
.
push
(
labelID
)
;
}
}
if
(
!
sharingAudio
)
{
let
labelID
=
"
webRTC
-
selectMicrophone
-
single
-
device
-
label
"
;
listDevices
(
micMenupopup
audioInputDevices
labelID
)
;
if
(
audioInputDevices
.
length
=
=
1
)
{
describedByIDs
.
push
(
"
webRTC
-
selectMicrophone
-
"
+
describedBySuffix
)
;
describedByIDs
.
push
(
labelID
)
;
}
}
let
labelID
=
"
webRTC
-
selectSpeaker
-
single
-
device
-
label
"
;
listDevices
(
speakerMenupopup
audioOutputDevices
labelID
)
;
if
(
audioInputDevices
.
length
=
=
1
)
{
describedByIDs
.
push
(
"
webRTC
-
selectSpeaker
-
icon
"
)
;
describedByIDs
.
push
(
labelID
)
;
}
chromeDoc
.
defaultView
.
PopupNotifications
.
panel
.
setAttribute
(
"
aria
-
describedby
"
describedByIDs
.
join
(
"
"
)
)
;
this
.
mainAction
.
callback
=
async
function
(
aState
)
{
let
remember
=
false
;
let
silenceNotifications
=
false
;
if
(
notificationSilencingEnabled
&
&
sharingScreen
)
{
silenceNotifications
=
aState
&
&
aState
.
checkboxChecked
;
}
else
{
remember
=
aState
&
&
aState
.
checkboxChecked
;
}
let
allowedDevices
=
[
]
;
let
perms
=
Services
.
perms
;
if
(
videoInputDevices
.
length
)
{
let
listId
=
"
webRTC
-
select
"
+
(
sharingScreen
?
"
Window
"
:
"
Camera
"
)
+
"
-
menulist
"
;
let
videoDeviceIndex
=
doc
.
getElementById
(
listId
)
.
value
;
let
allowVideoDevice
=
videoDeviceIndex
!
=
"
-
1
"
;
if
(
allowVideoDevice
)
{
allowedDevices
.
push
(
videoDeviceIndex
)
;
perms
.
addFromPrincipal
(
principal
"
MediaManagerVideo
"
perms
.
ALLOW_ACTION
perms
.
EXPIRE_SESSION
)
;
let
{
mediaSource
id
}
=
videoInputDevices
.
find
(
(
{
deviceIndex
}
)
=
>
deviceIndex
=
=
videoDeviceIndex
)
;
aActor
.
activateDevicePerm
(
aRequest
.
windowID
mediaSource
id
)
;
if
(
remember
)
{
lazy
.
SitePermissions
.
setForPrincipal
(
principal
"
camera
"
lazy
.
SitePermissions
.
ALLOW
)
;
}
}
}
if
(
audioInputDevices
.
length
)
{
if
(
!
sharingAudio
)
{
let
audioDeviceIndex
=
doc
.
getElementById
(
"
webRTC
-
selectMicrophone
-
menulist
"
)
.
value
;
let
allowMic
=
audioDeviceIndex
!
=
"
-
1
"
;
if
(
allowMic
)
{
allowedDevices
.
push
(
audioDeviceIndex
)
;
let
{
mediaSource
id
}
=
audioInputDevices
.
find
(
(
{
deviceIndex
}
)
=
>
deviceIndex
=
=
audioDeviceIndex
)
;
aActor
.
activateDevicePerm
(
aRequest
.
windowID
mediaSource
id
)
;
if
(
remember
)
{
lazy
.
SitePermissions
.
setForPrincipal
(
principal
"
microphone
"
lazy
.
SitePermissions
.
ALLOW
)
;
}
}
}
else
{
allowedDevices
.
push
(
0
)
;
}
}
if
(
audioOutputDevices
.
length
)
{
let
audioDeviceIndex
=
doc
.
getElementById
(
"
webRTC
-
selectSpeaker
-
menulist
"
)
.
value
;
let
allowSpeaker
=
audioDeviceIndex
!
=
"
-
1
"
;
if
(
allowSpeaker
)
{
allowedDevices
.
push
(
audioDeviceIndex
)
;
}
}
if
(
!
allowedDevices
.
length
)
{
aActor
.
denyRequest
(
aRequest
)
;
return
;
}
let
camNeeded
=
!
!
videoInputDevices
.
length
&
&
!
sharingScreen
;
let
scrNeeded
=
!
!
videoInputDevices
.
length
&
&
sharingScreen
;
let
micNeeded
=
!
!
audioInputDevices
.
length
;
let
havePermission
=
await
aActor
.
checkOSPermission
(
camNeeded
micNeeded
scrNeeded
)
;
if
(
!
havePermission
)
{
aActor
.
denyRequestNoPermission
(
aRequest
)
;
return
;
}
aActor
.
sendAsyncMessage
(
"
webrtc
:
Allow
"
{
callID
:
aRequest
.
callID
windowID
:
aRequest
.
windowID
devices
:
allowedDevices
suppressNotifications
:
silenceNotifications
}
)
;
}
;
return
false
;
}
}
;
function
shouldShowAlwaysRemember
(
)
{
if
(
lazy
.
PrivateBrowsingUtils
.
isBrowserPrivate
(
aBrowser
)
)
{
return
false
;
}
if
(
aRequest
.
isThirdPartyOrigin
&
&
!
aRequest
.
shouldDelegatePermission
)
{
return
false
;
}
if
(
aRequest
.
shouldDelegatePermission
&
&
aRequest
.
secondOrigin
)
{
return
false
;
}
if
(
audioOutputDevices
.
length
)
{
return
false
;
}
return
true
;
}
if
(
shouldShowAlwaysRemember
(
)
)
{
let
reasonForNoPermanentAllow
=
"
"
;
if
(
sharingScreen
)
{
reasonForNoPermanentAllow
=
"
getUserMedia
.
reasonForNoPermanentAllow
.
screen3
"
;
}
else
if
(
sharingAudio
)
{
reasonForNoPermanentAllow
=
"
getUserMedia
.
reasonForNoPermanentAllow
.
audio
"
;
}
else
if
(
!
aRequest
.
secure
)
{
reasonForNoPermanentAllow
=
"
getUserMedia
.
reasonForNoPermanentAllow
.
insecure
"
;
}
options
.
checkbox
=
{
label
:
stringBundle
.
getString
(
"
getUserMedia
.
remember
"
)
checked
:
principal
.
isAddonOrExpandedAddonPrincipal
checkedState
:
reasonForNoPermanentAllow
?
{
disableMainAction
:
true
warningLabel
:
stringBundle
.
getFormattedString
(
reasonForNoPermanentAllow
[
productName
]
)
}
:
undefined
}
;
}
if
(
notificationSilencingEnabled
&
&
sharingScreen
)
{
let
[
silenceNotifications
]
=
localization
.
formatMessagesSync
(
[
{
id
:
"
popup
-
mute
-
notifications
-
checkbox
"
}
]
)
;
options
.
checkbox
=
{
label
:
silenceNotifications
.
value
checked
:
false
checkedState
:
{
disableMainAction
:
false
}
}
;
}
let
iconType
=
"
Devices
"
;
if
(
requestTypes
.
length
=
=
1
)
{
switch
(
requestTypes
[
0
]
)
{
case
"
AudioCapture
"
:
iconType
=
"
Microphone
"
;
break
;
case
"
Microphone
"
:
case
"
Speaker
"
:
iconType
=
requestTypes
[
0
]
;
break
;
}
}
if
(
requestTypes
.
includes
(
"
Screen
"
)
)
{
iconType
=
"
Screen
"
;
}
let
anchorId
=
"
webRTC
-
share
"
+
iconType
+
"
-
notification
-
icon
"
;
if
(
aRequest
.
secondOrigin
)
{
options
.
secondName
=
lazy
.
webrtcUI
.
getHostOrExtensionName
(
null
aRequest
.
secondOrigin
)
;
}
notification
=
chromeDoc
.
defaultView
.
PopupNotifications
.
show
(
aBrowser
"
webRTC
-
shareDevices
"
message
anchorId
mainAction
secondaryActions
options
)
;
notification
.
callID
=
aRequest
.
callID
;
let
schemeHistogram
=
Services
.
telemetry
.
getKeyedHistogramById
(
"
PERMISSION_REQUEST_ORIGIN_SCHEME
"
)
;
let
userInputHistogram
=
Services
.
telemetry
.
getKeyedHistogramById
(
"
PERMISSION_REQUEST_HANDLING_USER_INPUT
"
)
;
let
docURI
=
aRequest
.
documentURI
;
let
scheme
=
0
;
if
(
docURI
.
startsWith
(
"
https
"
)
)
{
scheme
=
2
;
}
else
if
(
docURI
.
startsWith
(
"
http
"
)
)
{
scheme
=
1
;
}
for
(
let
requestType
of
requestTypes
)
{
if
(
requestType
=
=
"
AudioCapture
"
)
{
requestType
=
"
Microphone
"
;
}
requestType
=
requestType
.
toLowerCase
(
)
;
schemeHistogram
.
add
(
requestType
scheme
)
;
userInputHistogram
.
add
(
requestType
aRequest
.
isHandlingUserInput
)
;
}
}
function
removePrompt
(
aBrowser
aCallId
)
{
let
chromeWin
=
aBrowser
.
ownerGlobal
;
let
notification
=
chromeWin
.
PopupNotifications
.
getNotification
(
"
webRTC
-
shareDevices
"
aBrowser
)
;
if
(
notification
&
&
notification
.
callID
=
=
aCallId
)
{
notification
.
remove
(
)
;
}
}
function
clearTemporaryGrants
(
browser
clearCamera
clearMicrophone
)
{
if
(
!
clearCamera
&
&
!
clearMicrophone
)
{
return
;
}
let
perms
=
lazy
.
SitePermissions
.
getAllForBrowser
(
browser
)
;
perms
.
filter
(
perm
=
>
{
let
[
id
key
]
=
perm
.
id
.
split
(
lazy
.
SitePermissions
.
PERM_KEY_DELIMITER
)
;
return
(
key
&
&
perm
.
state
=
=
lazy
.
SitePermissions
.
ALLOW
&
&
perm
.
scope
=
=
lazy
.
SitePermissions
.
SCOPE_TEMPORARY
&
&
(
(
clearCamera
&
&
id
=
=
"
camera
"
)
|
|
(
clearMicrophone
&
&
id
=
=
"
microphone
"
)
)
)
;
}
)
.
forEach
(
perm
=
>
lazy
.
SitePermissions
.
removeFromPrincipal
(
null
perm
.
id
browser
)
)
;
}
