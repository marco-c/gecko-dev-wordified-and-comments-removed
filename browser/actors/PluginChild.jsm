"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
PluginChild
"
]
;
const
{
ActorChild
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ActorChild
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
BrowserUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
BrowserUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ContextMenuChild
"
"
resource
:
/
/
/
actors
/
ContextMenuChild
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gNavigatorBundle
"
function
(
)
{
const
url
=
"
chrome
:
/
/
browser
/
locale
/
browser
.
properties
"
;
return
Services
.
strings
.
createBundle
(
url
)
;
}
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
AppConstants
"
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
const
OVERLAY_DISPLAY
=
{
HIDDEN
:
0
BLANK
:
1
TINY
:
2
REDUCED
:
3
NOTEXT
:
4
FULL
:
5
}
;
class
PluginChild
extends
ActorChild
{
constructor
(
dispatcher
)
{
super
(
dispatcher
)
;
this
.
pluginData
=
new
Map
(
)
;
this
.
pluginCrashData
=
new
Map
(
)
;
this
.
mm
.
addEventListener
(
"
pagehide
"
this
{
capture
:
true
mozSystemGroup
:
true
}
)
;
this
.
mm
.
addEventListener
(
"
pageshow
"
this
{
capture
:
true
mozSystemGroup
:
true
}
)
;
}
receiveMessage
(
msg
)
{
switch
(
msg
.
name
)
{
case
"
BrowserPlugins
:
ActivatePlugins
"
:
this
.
activatePlugins
(
msg
.
data
.
pluginInfo
msg
.
data
.
newState
)
;
break
;
case
"
BrowserPlugins
:
ContextMenuCommand
"
:
switch
(
msg
.
data
.
command
)
{
case
"
play
"
:
this
.
_showClickToPlayNotification
(
ContextMenuChild
.
getTarget
(
this
.
mm
msg
"
plugin
"
)
true
)
;
break
;
case
"
hide
"
:
this
.
hideClickToPlayOverlay
(
ContextMenuChild
.
getTarget
(
this
.
mm
msg
"
plugin
"
)
)
;
break
;
}
break
;
case
"
BrowserPlugins
:
NPAPIPluginProcessCrashed
"
:
this
.
NPAPIPluginProcessCrashed
(
{
pluginName
:
msg
.
data
.
pluginName
runID
:
msg
.
data
.
runID
state
:
msg
.
data
.
state
}
)
;
break
;
case
"
BrowserPlugins
:
CrashReportSubmitted
"
:
this
.
NPAPIPluginCrashReportSubmitted
(
{
runID
:
msg
.
data
.
runID
state
:
msg
.
data
.
state
}
)
;
break
;
case
"
BrowserPlugins
:
Test
:
ClearCrashData
"
:
if
(
Services
.
prefs
.
getBoolPref
(
"
plugins
.
testmode
"
)
)
{
this
.
pluginCrashData
.
clear
(
)
;
}
}
}
observe
(
aSubject
aTopic
aData
)
{
switch
(
aTopic
)
{
case
"
decoder
-
doctor
-
notification
"
:
let
data
=
JSON
.
parse
(
aData
)
;
let
type
=
data
.
type
.
toLowerCase
(
)
;
if
(
type
=
=
"
cannot
-
play
"
&
&
this
.
haveShownNotification
&
&
aSubject
.
top
.
document
=
=
this
.
content
.
document
&
&
data
.
formats
.
toLowerCase
(
)
.
includes
(
"
application
/
x
-
mpegurl
"
0
)
)
{
this
.
content
.
pluginRequiresReload
=
true
;
}
}
}
onPageShow
(
event
)
{
if
(
!
this
.
content
|
|
event
.
target
!
=
this
.
content
.
document
)
{
return
;
}
if
(
event
.
persisted
)
{
this
.
reshowClickToPlayNotification
(
)
;
}
}
onPageHide
(
event
)
{
if
(
!
this
.
content
|
|
event
.
target
!
=
this
.
content
.
document
)
{
return
;
}
this
.
clearPluginCaches
(
)
;
this
.
haveShownNotification
=
false
;
}
getPluginUI
(
plugin
anonid
)
{
if
(
plugin
.
openOrClosedShadowRoot
&
&
plugin
.
openOrClosedShadowRoot
.
isUAWidget
(
)
)
{
return
plugin
.
openOrClosedShadowRoot
.
getElementById
(
anonid
)
;
}
return
plugin
.
ownerDocument
.
getAnonymousElementByAttribute
(
plugin
"
anonid
"
anonid
)
;
}
_getPluginInfo
(
pluginElement
)
{
let
pluginHost
=
Cc
[
"
mozilla
.
org
/
plugin
/
host
;
1
"
]
.
getService
(
Ci
.
nsIPluginHost
)
;
pluginElement
.
QueryInterface
(
Ci
.
nsIObjectLoadingContent
)
;
let
tagMimetype
;
let
pluginName
=
gNavigatorBundle
.
GetStringFromName
(
"
pluginInfo
.
unknownPlugin
"
)
;
let
pluginTag
=
null
;
let
permissionString
=
null
;
let
fallbackType
=
null
;
let
blocklistState
=
null
;
tagMimetype
=
pluginElement
.
actualType
;
if
(
tagMimetype
=
=
"
"
)
{
tagMimetype
=
pluginElement
.
type
;
}
if
(
this
.
isKnownPlugin
(
pluginElement
)
)
{
pluginTag
=
pluginHost
.
getPluginTagForType
(
pluginElement
.
actualType
)
;
pluginName
=
BrowserUtils
.
makeNicePluginName
(
pluginTag
.
name
)
;
let
properties
=
[
"
name
"
"
description
"
"
filename
"
"
version
"
"
enabledState
"
"
niceName
"
]
;
let
pluginTagCopy
=
{
}
;
for
(
let
prop
of
properties
)
{
pluginTagCopy
[
prop
]
=
pluginTag
[
prop
]
;
}
pluginTag
=
pluginTagCopy
;
permissionString
=
pluginHost
.
getPermissionStringForType
(
pluginElement
.
actualType
)
;
fallbackType
=
pluginElement
.
defaultFallbackType
;
blocklistState
=
pluginHost
.
getBlocklistStateForType
(
pluginElement
.
actualType
)
;
if
(
blocklistState
=
=
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
|
|
blocklistState
=
=
Ci
.
nsIBlocklistService
.
STATE_OUTDATED
)
{
blocklistState
=
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
;
}
}
return
{
mimetype
:
tagMimetype
pluginName
pluginTag
permissionString
fallbackType
blocklistState
}
;
}
_getPluginInfoForTag
(
pluginTag
tagMimetype
)
{
let
pluginHost
=
Cc
[
"
mozilla
.
org
/
plugin
/
host
;
1
"
]
.
getService
(
Ci
.
nsIPluginHost
)
;
let
pluginName
=
gNavigatorBundle
.
GetStringFromName
(
"
pluginInfo
.
unknownPlugin
"
)
;
let
permissionString
=
null
;
let
blocklistState
=
null
;
if
(
pluginTag
)
{
pluginName
=
BrowserUtils
.
makeNicePluginName
(
pluginTag
.
name
)
;
permissionString
=
pluginHost
.
getPermissionStringForTag
(
pluginTag
)
;
blocklistState
=
pluginTag
.
blocklistState
;
let
properties
=
[
"
name
"
"
description
"
"
filename
"
"
version
"
"
enabledState
"
"
niceName
"
]
;
let
pluginTagCopy
=
{
}
;
for
(
let
prop
of
properties
)
{
pluginTagCopy
[
prop
]
=
pluginTag
[
prop
]
;
}
pluginTag
=
pluginTagCopy
;
if
(
blocklistState
=
=
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
|
|
blocklistState
=
=
Ci
.
nsIBlocklistService
.
STATE_OUTDATED
)
{
blocklistState
=
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
;
}
}
return
{
mimetype
:
tagMimetype
pluginName
pluginTag
permissionString
fallbackType
:
Ci
.
nsIObjectLoadingContent
.
PLUGIN_CLICK_TO_PLAY
blocklistState
}
;
}
setVisibility
(
plugin
overlay
overlayDisplayState
)
{
overlay
.
classList
.
toggle
(
"
visible
"
overlayDisplayState
!
=
OVERLAY_DISPLAY
.
HIDDEN
)
;
if
(
overlayDisplayState
!
=
OVERLAY_DISPLAY
.
HIDDEN
)
{
overlay
.
removeAttribute
(
"
dismissed
"
)
;
}
}
computeAndAdjustOverlayDisplay
(
plugin
overlay
)
{
let
fallbackType
=
plugin
.
pluginFallbackType
;
if
(
plugin
.
pluginFallbackTypeOverride
!
=
=
undefined
)
{
fallbackType
=
plugin
.
pluginFallbackTypeOverride
;
}
if
(
fallbackType
=
=
Ci
.
nsIObjectLoadingContent
.
PLUGIN_CLICK_TO_PLAY_QUIET
)
{
return
OVERLAY_DISPLAY
.
HIDDEN
;
}
if
(
overlay
.
scrollWidth
=
=
0
)
{
return
OVERLAY_DISPLAY
.
FULL
;
}
let
overlayDisplay
=
OVERLAY_DISPLAY
.
FULL
;
let
pluginRect
=
plugin
.
getBoundingClientRect
(
)
;
let
pluginWidth
=
Math
.
ceil
(
pluginRect
.
width
)
;
let
pluginHeight
=
Math
.
ceil
(
pluginRect
.
height
)
;
if
(
pluginWidth
<
=
32
|
|
pluginHeight
<
=
32
)
{
overlay
.
setAttribute
(
"
sizing
"
"
blank
"
)
;
overlayDisplay
=
OVERLAY_DISPLAY
.
BLANK
;
}
else
if
(
pluginWidth
<
=
80
|
|
pluginHeight
<
=
60
)
{
overlayDisplay
=
OVERLAY_DISPLAY
.
TINY
;
overlay
.
setAttribute
(
"
sizing
"
"
tiny
"
)
;
overlay
.
setAttribute
(
"
notext
"
"
notext
"
)
;
}
else
if
(
pluginWidth
<
=
120
|
|
pluginHeight
<
=
80
)
{
overlayDisplay
=
OVERLAY_DISPLAY
.
REDUCED
;
overlay
.
setAttribute
(
"
sizing
"
"
reduced
"
)
;
overlay
.
setAttribute
(
"
notext
"
"
notext
"
)
;
}
else
if
(
pluginWidth
<
=
240
|
|
pluginHeight
<
=
160
)
{
overlayDisplay
=
OVERLAY_DISPLAY
.
NOTEXT
;
overlay
.
removeAttribute
(
"
sizing
"
)
;
overlay
.
setAttribute
(
"
notext
"
"
notext
"
)
;
}
else
{
overlayDisplay
=
OVERLAY_DISPLAY
.
FULL
;
overlay
.
removeAttribute
(
"
sizing
"
)
;
overlay
.
removeAttribute
(
"
notext
"
)
;
}
let
overflows
=
(
overlay
.
scrollWidth
>
pluginWidth
)
|
|
(
overlay
.
scrollHeight
-
5
>
pluginHeight
)
;
if
(
overflows
)
{
overlay
.
setAttribute
(
"
sizing
"
"
blank
"
)
;
return
OVERLAY_DISPLAY
.
BLANK
;
}
let
left
=
pluginRect
.
left
+
2
;
let
right
=
pluginRect
.
right
-
2
;
let
top
=
pluginRect
.
top
+
2
;
let
bottom
=
pluginRect
.
bottom
-
2
;
let
centerX
=
left
+
(
right
-
left
)
/
2
;
let
centerY
=
top
+
(
bottom
-
top
)
/
2
;
let
points
=
[
[
left
top
]
[
left
bottom
]
[
right
top
]
[
right
bottom
]
[
centerX
centerY
]
]
;
let
contentWindow
=
plugin
.
ownerGlobal
;
let
cwu
=
contentWindow
.
windowUtils
;
for
(
let
[
x
y
]
of
points
)
{
if
(
x
<
0
|
|
y
<
0
)
{
continue
;
}
let
el
=
cwu
.
elementFromPoint
(
x
y
true
true
)
;
if
(
el
=
=
=
plugin
)
{
return
overlayDisplay
;
}
}
overlay
.
setAttribute
(
"
sizing
"
"
blank
"
)
;
return
OVERLAY_DISPLAY
.
BLANK
;
}
addLinkClickCallback
(
linkNode
callbackName
)
{
let
self
=
this
;
let
callbackArgs
=
Array
.
prototype
.
slice
.
call
(
arguments
)
.
slice
(
2
)
;
linkNode
.
addEventListener
(
"
click
"
function
(
evt
)
{
if
(
!
evt
.
isTrusted
)
return
;
evt
.
preventDefault
(
)
;
if
(
callbackArgs
.
length
=
=
0
)
callbackArgs
=
[
evt
]
;
(
self
[
callbackName
]
)
.
apply
(
self
callbackArgs
)
;
}
true
)
;
linkNode
.
addEventListener
(
"
keydown
"
function
(
evt
)
{
if
(
!
evt
.
isTrusted
)
return
;
if
(
evt
.
keyCode
=
=
evt
.
DOM_VK_RETURN
)
{
evt
.
preventDefault
(
)
;
if
(
callbackArgs
.
length
=
=
0
)
callbackArgs
=
[
evt
]
;
evt
.
preventDefault
(
)
;
(
self
[
callbackName
]
)
.
apply
(
self
callbackArgs
)
;
}
}
true
)
;
}
_getBindingType
(
plugin
)
{
if
(
!
(
plugin
instanceof
Ci
.
nsIObjectLoadingContent
)
)
return
null
;
switch
(
plugin
.
pluginFallbackType
)
{
case
Ci
.
nsIObjectLoadingContent
.
PLUGIN_UNSUPPORTED
:
return
"
PluginNotFound
"
;
case
Ci
.
nsIObjectLoadingContent
.
PLUGIN_DISABLED
:
return
"
PluginDisabled
"
;
case
Ci
.
nsIObjectLoadingContent
.
PLUGIN_BLOCKLISTED
:
return
"
PluginBlocklisted
"
;
case
Ci
.
nsIObjectLoadingContent
.
PLUGIN_OUTDATED
:
return
"
PluginOutdated
"
;
case
Ci
.
nsIObjectLoadingContent
.
PLUGIN_CLICK_TO_PLAY
:
case
Ci
.
nsIObjectLoadingContent
.
PLUGIN_CLICK_TO_PLAY_QUIET
:
return
"
PluginClickToPlay
"
;
case
Ci
.
nsIObjectLoadingContent
.
PLUGIN_VULNERABLE_UPDATABLE
:
return
"
PluginVulnerableUpdatable
"
;
case
Ci
.
nsIObjectLoadingContent
.
PLUGIN_VULNERABLE_NO_UPDATE
:
return
"
PluginVulnerableNoUpdate
"
;
default
:
return
null
;
}
}
handleEvent
(
event
)
{
let
eventType
=
event
.
type
;
if
(
eventType
=
=
"
pagehide
"
)
{
this
.
onPageHide
(
event
)
;
return
;
}
if
(
eventType
=
=
"
pageshow
"
)
{
this
.
onPageShow
(
event
)
;
return
;
}
if
(
eventType
=
=
"
click
"
)
{
this
.
onOverlayClick
(
event
)
;
return
;
}
if
(
eventType
=
=
"
PluginCrashed
"
&
&
!
(
event
.
target
instanceof
Ci
.
nsIObjectLoadingContent
)
)
{
this
.
onPluginCrashed
(
event
.
target
event
)
;
return
;
}
if
(
eventType
=
=
"
HiddenPlugin
"
)
{
let
pluginTag
=
event
.
tag
.
QueryInterface
(
Ci
.
nsIPluginTag
)
;
if
(
event
.
target
.
defaultView
.
top
.
document
!
=
this
.
content
.
document
)
{
return
;
}
this
.
_showClickToPlayNotification
(
pluginTag
false
)
;
}
let
plugin
=
event
.
target
;
if
(
!
(
plugin
instanceof
Ci
.
nsIObjectLoadingContent
)
)
return
;
if
(
eventType
=
=
"
PluginBindingAttached
"
)
{
let
overlay
=
this
.
getPluginUI
(
plugin
"
main
"
)
;
if
(
!
overlay
|
|
overlay
.
_bindingHandled
)
{
return
;
}
overlay
.
_bindingHandled
=
true
;
eventType
=
this
.
_getBindingType
(
plugin
)
;
if
(
!
eventType
)
{
return
;
}
}
let
shouldShowNotification
=
false
;
switch
(
eventType
)
{
case
"
PluginCrashed
"
:
this
.
onPluginCrashed
(
plugin
event
)
;
break
;
case
"
PluginNotFound
"
:
{
break
;
}
case
"
PluginBlocklisted
"
:
case
"
PluginOutdated
"
:
shouldShowNotification
=
true
;
break
;
case
"
PluginVulnerableUpdatable
"
:
let
updateLink
=
this
.
getPluginUI
(
plugin
"
checkForUpdatesLink
"
)
;
let
{
pluginTag
}
=
this
.
_getPluginInfo
(
plugin
)
;
this
.
addLinkClickCallback
(
updateLink
"
forwardCallback
"
"
openPluginUpdatePage
"
pluginTag
)
;
case
"
PluginVulnerableNoUpdate
"
:
case
"
PluginClickToPlay
"
:
this
.
_handleClickToPlayEvent
(
plugin
)
;
let
pluginName
=
this
.
_getPluginInfo
(
plugin
)
.
pluginName
;
let
messageString
=
gNavigatorBundle
.
formatStringFromName
(
"
PluginClickToActivate2
"
[
pluginName
]
1
)
;
let
overlayText
=
this
.
getPluginUI
(
plugin
"
clickToPlay
"
)
;
overlayText
.
textContent
=
messageString
;
if
(
eventType
=
=
"
PluginVulnerableUpdatable
"
|
|
eventType
=
=
"
PluginVulnerableNoUpdate
"
)
{
let
vulnerabilityString
=
gNavigatorBundle
.
GetStringFromName
(
eventType
)
;
let
vulnerabilityText
=
this
.
getPluginUI
(
plugin
"
vulnerabilityStatus
"
)
;
vulnerabilityText
.
textContent
=
vulnerabilityString
;
}
shouldShowNotification
=
true
;
break
;
case
"
PluginDisabled
"
:
let
manageLink
=
this
.
getPluginUI
(
plugin
"
managePluginsLink
"
)
;
this
.
addLinkClickCallback
(
manageLink
"
forwardCallback
"
"
managePlugins
"
)
;
shouldShowNotification
=
true
;
break
;
case
"
PluginInstantiated
"
:
shouldShowNotification
=
true
;
break
;
}
let
overlay
=
this
.
getPluginUI
(
plugin
"
main
"
)
;
if
(
eventType
!
=
"
PluginCrashed
"
)
{
if
(
overlay
!
=
null
)
{
this
.
setVisibility
(
plugin
overlay
this
.
computeAndAdjustOverlayDisplay
(
plugin
overlay
)
)
;
let
resizeListener
=
(
)
=
>
{
this
.
setVisibility
(
plugin
overlay
this
.
computeAndAdjustOverlayDisplay
(
plugin
overlay
)
)
;
}
;
plugin
.
addEventListener
(
"
overflow
"
resizeListener
)
;
plugin
.
addEventListener
(
"
underflow
"
resizeListener
)
;
}
}
let
closeIcon
=
this
.
getPluginUI
(
plugin
"
closeIcon
"
)
;
if
(
closeIcon
)
{
closeIcon
.
addEventListener
(
"
click
"
clickEvent
=
>
{
if
(
clickEvent
.
button
=
=
0
&
&
clickEvent
.
isTrusted
)
{
this
.
hideClickToPlayOverlay
(
plugin
)
;
overlay
.
setAttribute
(
"
dismissed
"
"
true
"
)
;
}
}
true
)
;
}
if
(
shouldShowNotification
)
{
this
.
_showClickToPlayNotification
(
plugin
false
)
;
}
}
isKnownPlugin
(
objLoadingContent
)
{
return
(
objLoadingContent
.
getContentTypeForMIMEType
(
objLoadingContent
.
actualType
)
=
=
Ci
.
nsIObjectLoadingContent
.
TYPE_PLUGIN
)
;
}
canActivatePlugin
(
objLoadingContent
)
{
if
(
!
this
.
isKnownPlugin
(
objLoadingContent
)
)
return
false
;
let
pluginHost
=
Cc
[
"
mozilla
.
org
/
plugin
/
host
;
1
"
]
.
getService
(
Ci
.
nsIPluginHost
)
;
let
permissionString
=
pluginHost
.
getPermissionStringForType
(
objLoadingContent
.
actualType
)
;
let
principal
=
objLoadingContent
.
ownerGlobal
.
top
.
document
.
nodePrincipal
;
let
pluginPermission
=
Services
.
perms
.
testPermissionFromPrincipal
(
principal
permissionString
)
;
let
isFallbackTypeValid
=
objLoadingContent
.
pluginFallbackType
>
=
Ci
.
nsIObjectLoadingContent
.
PLUGIN_CLICK_TO_PLAY
&
&
objLoadingContent
.
pluginFallbackType
<
=
Ci
.
nsIObjectLoadingContent
.
PLUGIN_CLICK_TO_PLAY_QUIET
;
return
!
objLoadingContent
.
activated
&
&
pluginPermission
!
=
Ci
.
nsIPermissionManager
.
DENY_ACTION
&
&
isFallbackTypeValid
;
}
hideClickToPlayOverlay
(
plugin
)
{
let
overlay
=
this
.
getPluginUI
(
plugin
"
main
"
)
;
if
(
overlay
)
{
overlay
.
classList
.
remove
(
"
visible
"
)
;
}
}
forwardCallback
(
name
pluginTag
)
{
this
.
mm
.
sendAsyncMessage
(
"
PluginContent
:
LinkClickCallback
"
{
name
pluginTag
}
)
;
}
submitReport
(
plugin
)
{
if
(
!
AppConstants
.
MOZ_CRASHREPORTER
)
{
return
;
}
if
(
!
plugin
)
{
Cu
.
reportError
(
"
Attempted
to
submit
crash
report
without
an
associated
plugin
.
"
)
;
return
;
}
if
(
!
(
plugin
instanceof
Ci
.
nsIObjectLoadingContent
)
)
{
Cu
.
reportError
(
"
Attempted
to
submit
crash
report
on
plugin
that
does
not
"
+
"
implement
nsIObjectLoadingContent
.
"
)
;
return
;
}
let
runID
=
plugin
.
runID
;
let
submitURLOptIn
=
this
.
getPluginUI
(
plugin
"
submitURLOptIn
"
)
.
checked
;
let
keyVals
=
{
}
;
let
userComment
=
this
.
getPluginUI
(
plugin
"
submitComment
"
)
.
value
.
trim
(
)
;
if
(
userComment
)
keyVals
.
PluginUserComment
=
userComment
;
if
(
submitURLOptIn
)
keyVals
.
PluginContentURL
=
plugin
.
ownerDocument
.
URL
;
this
.
mm
.
sendAsyncMessage
(
"
PluginContent
:
SubmitReport
"
{
runID
keyVals
submitURLOptIn
}
)
;
}
reloadPage
(
)
{
this
.
content
.
location
.
reload
(
)
;
}
_handleClickToPlayEvent
(
plugin
)
{
let
doc
=
plugin
.
ownerDocument
;
let
pluginHost
=
Cc
[
"
mozilla
.
org
/
plugin
/
host
;
1
"
]
.
getService
(
Ci
.
nsIPluginHost
)
;
let
objLoadingContent
=
plugin
.
QueryInterface
(
Ci
.
nsIObjectLoadingContent
)
;
if
(
!
this
.
isKnownPlugin
(
objLoadingContent
)
)
return
;
let
permissionString
=
pluginHost
.
getPermissionStringForType
(
objLoadingContent
.
actualType
)
;
let
principal
=
doc
.
defaultView
.
top
.
document
.
nodePrincipal
;
let
pluginPermission
=
Services
.
perms
.
testPermissionFromPrincipal
(
principal
permissionString
)
;
let
overlay
=
this
.
getPluginUI
(
plugin
"
main
"
)
;
if
(
pluginPermission
=
=
Ci
.
nsIPermissionManager
.
DENY_ACTION
|
|
pluginPermission
=
=
Ci
.
nsIObjectLoadingContent
.
PLUGIN_PERMISSION_PROMPT_ACTION_QUIET
)
{
if
(
overlay
)
{
overlay
.
classList
.
remove
(
"
visible
"
)
;
}
return
;
}
if
(
overlay
)
{
overlay
.
addEventListener
(
"
click
"
this
true
)
;
}
}
onOverlayClick
(
event
)
{
let
document
=
event
.
target
.
ownerDocument
;
let
plugin
=
document
.
getBindingParent
(
event
.
target
)
;
let
overlay
=
this
.
getPluginUI
(
plugin
"
main
"
)
;
if
(
!
(
ChromeUtils
.
getClassName
(
event
.
originalTarget
)
=
=
=
"
HTMLAnchorElement
"
)
&
&
event
.
originalTarget
.
getAttribute
(
"
anonid
"
)
!
=
"
closeIcon
"
&
&
event
.
originalTarget
.
id
!
=
"
closeIcon
"
&
&
!
overlay
.
hasAttribute
(
"
dismissed
"
)
&
&
event
.
button
=
=
0
&
&
event
.
isTrusted
)
{
this
.
_showClickToPlayNotification
(
plugin
true
)
;
event
.
stopPropagation
(
)
;
event
.
preventDefault
(
)
;
}
}
reshowClickToPlayNotification
(
)
{
let
contentWindow
=
this
.
content
;
let
cwu
=
contentWindow
.
windowUtils
;
let
plugins
=
cwu
.
plugins
;
for
(
let
plugin
of
plugins
)
{
let
overlay
=
this
.
getPluginUI
(
plugin
"
main
"
)
;
if
(
overlay
)
overlay
.
removeEventListener
(
"
click
"
this
true
)
;
let
objLoadingContent
=
plugin
.
QueryInterface
(
Ci
.
nsIObjectLoadingContent
)
;
if
(
this
.
canActivatePlugin
(
objLoadingContent
)
)
this
.
_handleClickToPlayEvent
(
plugin
)
;
}
this
.
_showClickToPlayNotification
(
null
false
)
;
}
activatePlugins
(
pluginInfo
newState
)
{
let
contentWindow
=
this
.
content
;
let
cwu
=
contentWindow
.
windowUtils
;
let
plugins
=
cwu
.
plugins
;
let
pluginHost
=
Cc
[
"
mozilla
.
org
/
plugin
/
host
;
1
"
]
.
getService
(
Ci
.
nsIPluginHost
)
;
let
pluginFound
=
false
;
for
(
let
plugin
of
plugins
)
{
plugin
.
QueryInterface
(
Ci
.
nsIObjectLoadingContent
)
;
if
(
!
this
.
isKnownPlugin
(
plugin
)
)
{
continue
;
}
if
(
pluginInfo
.
permissionString
=
=
pluginHost
.
getPermissionStringForType
(
plugin
.
actualType
)
)
{
let
overlay
=
this
.
getPluginUI
(
plugin
"
main
"
)
;
pluginFound
=
true
;
if
(
newState
=
=
"
block
"
|
|
newState
=
=
"
blockalways
"
|
|
newState
=
=
"
continueblocking
"
)
{
if
(
overlay
)
{
overlay
.
addEventListener
(
"
click
"
this
true
)
;
}
plugin
.
pluginFallbackTypeOverride
=
pluginInfo
.
fallbackType
;
plugin
.
reload
(
true
)
;
}
else
if
(
this
.
canActivatePlugin
(
plugin
)
)
{
if
(
overlay
)
{
overlay
.
removeEventListener
(
"
click
"
this
true
)
;
}
plugin
.
playPlugin
(
)
;
}
}
}
if
(
newState
!
=
"
block
"
&
&
newState
!
=
"
blockalways
"
&
&
newState
!
=
"
continueblocking
"
&
&
(
!
pluginFound
|
|
contentWindow
.
pluginRequiresReload
)
)
{
this
.
reloadPage
(
)
;
}
}
_showClickToPlayNotification
(
plugin
showNow
)
{
let
plugins
=
[
]
;
if
(
plugin
=
=
=
null
)
{
let
contentWindow
=
this
.
content
;
let
cwu
=
contentWindow
.
windowUtils
;
plugins
=
cwu
.
plugins
.
filter
(
(
p
)
=
>
p
.
getContentTypeForMIMEType
(
p
.
actualType
)
=
=
Ci
.
nsIObjectLoadingContent
.
TYPE_PLUGIN
)
;
if
(
plugins
.
length
=
=
0
)
{
this
.
removeNotification
(
"
click
-
to
-
play
-
plugins
"
)
;
return
;
}
}
else
{
plugins
=
[
plugin
]
;
}
let
pluginData
=
this
.
pluginData
;
let
principal
=
this
.
content
.
document
.
nodePrincipal
;
let
location
=
this
.
content
.
document
.
location
.
href
;
for
(
let
p
of
plugins
)
{
let
pluginInfo
;
if
(
p
instanceof
Ci
.
nsIPluginTag
)
{
let
mimeType
=
p
.
getMimeTypes
(
)
>
0
?
p
.
getMimeTypes
(
)
[
0
]
:
null
;
pluginInfo
=
this
.
_getPluginInfoForTag
(
p
mimeType
)
;
}
else
{
pluginInfo
=
this
.
_getPluginInfo
(
p
)
;
}
if
(
pluginInfo
.
permissionString
=
=
=
null
)
{
Cu
.
reportError
(
"
No
permission
string
for
active
plugin
.
"
)
;
continue
;
}
if
(
pluginData
.
has
(
pluginInfo
.
permissionString
)
)
{
continue
;
}
let
permissionObj
=
Services
.
perms
.
getPermissionObject
(
principal
pluginInfo
.
permissionString
false
)
;
if
(
permissionObj
)
{
pluginInfo
.
pluginPermissionPrePath
=
permissionObj
.
principal
.
originNoSuffix
;
pluginInfo
.
pluginPermissionType
=
permissionObj
.
expireType
;
}
else
{
pluginInfo
.
pluginPermissionPrePath
=
principal
.
originNoSuffix
;
pluginInfo
.
pluginPermissionType
=
undefined
;
}
this
.
pluginData
.
set
(
pluginInfo
.
permissionString
pluginInfo
)
;
}
this
.
haveShownNotification
=
true
;
this
.
mm
.
sendAsyncMessage
(
"
PluginContent
:
ShowClickToPlayNotification
"
{
plugins
:
[
.
.
.
this
.
pluginData
.
values
(
)
]
showNow
location
}
null
principal
)
;
}
removeNotification
(
name
)
{
this
.
mm
.
sendAsyncMessage
(
"
PluginContent
:
RemoveNotification
"
{
name
}
)
;
}
clearPluginCaches
(
)
{
this
.
pluginData
.
clear
(
)
;
this
.
pluginCrashData
.
clear
(
)
;
}
isWithinFullScreenElement
(
fullScreenElement
domElement
)
{
let
getTrueFullScreenElement
=
fullScreenIframe
=
>
{
if
(
typeof
fullScreenIframe
.
contentDocument
!
=
=
"
undefined
"
&
&
fullScreenIframe
.
contentDocument
.
mozFullScreenElement
)
{
return
getTrueFullScreenElement
(
fullScreenIframe
.
contentDocument
.
mozFullScreenElement
)
;
}
return
fullScreenIframe
;
}
;
if
(
fullScreenElement
.
tagName
=
=
=
"
IFRAME
"
)
{
fullScreenElement
=
getTrueFullScreenElement
(
fullScreenElement
)
;
}
if
(
fullScreenElement
.
contains
(
domElement
)
)
{
return
true
;
}
let
parentIframe
=
domElement
.
ownerGlobal
.
frameElement
;
if
(
parentIframe
)
{
return
this
.
isWithinFullScreenElement
(
fullScreenElement
parentIframe
)
;
}
return
false
;
}
onPluginCrashed
(
target
aEvent
)
{
if
(
!
(
aEvent
instanceof
this
.
content
.
PluginCrashedEvent
)
)
return
;
let
fullScreenElement
=
this
.
content
.
document
.
mozFullScreenElement
;
if
(
fullScreenElement
)
{
if
(
this
.
isWithinFullScreenElement
(
fullScreenElement
target
)
)
{
this
.
content
.
document
.
mozCancelFullScreen
(
)
;
}
}
if
(
aEvent
.
gmpPlugin
)
{
this
.
GMPCrashed
(
aEvent
)
;
return
;
}
if
(
!
(
target
instanceof
Ci
.
nsIObjectLoadingContent
)
)
return
;
let
crashData
=
this
.
pluginCrashData
.
get
(
target
.
runID
)
;
if
(
!
crashData
)
{
return
;
}
crashData
.
instances
.
delete
(
target
)
;
if
(
crashData
.
instances
.
length
=
=
0
)
{
this
.
pluginCrashData
.
delete
(
target
.
runID
)
;
}
this
.
setCrashedNPAPIPluginState
(
{
plugin
:
target
state
:
crashData
.
state
message
:
crashData
.
message
}
)
;
}
NPAPIPluginProcessCrashed
(
{
pluginName
runID
state
}
)
{
let
message
=
gNavigatorBundle
.
formatStringFromName
(
"
crashedpluginsMessage
.
title
"
[
pluginName
]
1
)
;
let
contentWindow
=
this
.
content
;
let
cwu
=
contentWindow
.
windowUtils
;
let
plugins
=
cwu
.
plugins
;
for
(
let
plugin
of
plugins
)
{
if
(
plugin
instanceof
Ci
.
nsIObjectLoadingContent
&
&
plugin
.
runID
=
=
runID
)
{
if
(
plugin
.
pluginFallbackType
=
=
Ci
.
nsIObjectLoadingContent
.
PLUGIN_CRASHED
)
{
this
.
setCrashedNPAPIPluginState
(
{
plugin
state
message
}
)
;
}
else
{
if
(
!
this
.
pluginCrashData
.
has
(
runID
)
)
{
this
.
pluginCrashData
.
set
(
runID
{
state
message
instances
:
new
WeakSet
(
)
}
)
;
}
let
crashData
=
this
.
pluginCrashData
.
get
(
runID
)
;
crashData
.
instances
.
add
(
plugin
)
;
}
}
}
}
setCrashedNPAPIPluginState
(
{
plugin
state
message
}
)
{
plugin
.
clientTop
;
let
overlay
=
this
.
getPluginUI
(
plugin
"
main
"
)
;
let
statusDiv
=
this
.
getPluginUI
(
plugin
"
submitStatus
"
)
;
let
optInCB
=
this
.
getPluginUI
(
plugin
"
submitURLOptIn
"
)
;
this
.
getPluginUI
(
plugin
"
submitButton
"
)
.
addEventListener
(
"
click
"
(
event
)
=
>
{
if
(
event
.
button
!
=
0
|
|
!
event
.
isTrusted
)
return
;
this
.
submitReport
(
plugin
)
;
}
)
;
let
pref
=
Services
.
prefs
.
getBranch
(
"
dom
.
ipc
.
plugins
.
reportCrashURL
"
)
;
optInCB
.
checked
=
pref
.
getBoolPref
(
"
"
)
;
statusDiv
.
setAttribute
(
"
status
"
state
)
;
let
helpIcon
=
this
.
getPluginUI
(
plugin
"
helpIcon
"
)
;
this
.
addLinkClickCallback
(
helpIcon
"
openHelpPage
"
)
;
let
crashText
=
this
.
getPluginUI
(
plugin
"
crashedText
"
)
;
crashText
.
textContent
=
message
;
let
link
=
this
.
getPluginUI
(
plugin
"
reloadLink
"
)
;
this
.
addLinkClickCallback
(
link
"
reloadPage
"
)
;
let
overlayDisplayState
=
this
.
computeAndAdjustOverlayDisplay
(
plugin
overlay
)
;
if
(
overlayDisplayState
!
=
OVERLAY_DISPLAY
.
FULL
)
{
statusDiv
.
removeAttribute
(
"
status
"
)
;
overlayDisplayState
=
this
.
computeAndAdjustOverlayDisplay
(
plugin
overlay
)
;
}
this
.
setVisibility
(
plugin
overlay
overlayDisplayState
)
;
let
doc
=
plugin
.
ownerDocument
;
let
runID
=
plugin
.
runID
;
if
(
overlayDisplayState
=
=
OVERLAY_DISPLAY
.
FULL
)
{
doc
.
mozNoPluginCrashedNotification
=
true
;
let
winUtils
=
this
.
content
.
windowUtils
;
let
event
=
new
this
.
content
.
CustomEvent
(
"
PluginCrashReporterDisplayed
"
{
bubbles
:
true
}
)
;
winUtils
.
dispatchEventToChromeOnly
(
plugin
event
)
;
}
else
if
(
!
doc
.
mozNoPluginCrashedNotification
)
{
this
.
mm
.
sendAsyncMessage
(
"
PluginContent
:
ShowPluginCrashedNotification
"
{
messageString
:
message
pluginID
:
runID
}
)
;
}
}
NPAPIPluginCrashReportSubmitted
(
{
runID
state
}
)
{
this
.
pluginCrashData
.
delete
(
runID
)
;
let
contentWindow
=
this
.
content
;
let
cwu
=
contentWindow
.
windowUtils
;
let
plugins
=
cwu
.
plugins
;
for
(
let
plugin
of
plugins
)
{
if
(
plugin
instanceof
Ci
.
nsIObjectLoadingContent
&
&
plugin
.
runID
=
=
runID
)
{
let
statusDiv
=
this
.
getPluginUI
(
plugin
"
submitStatus
"
)
;
statusDiv
.
setAttribute
(
"
status
"
state
)
;
}
}
}
GMPCrashed
(
aEvent
)
{
let
target
=
aEvent
.
target
;
let
pluginName
=
aEvent
.
pluginName
;
let
gmpPlugin
=
aEvent
.
gmpPlugin
;
let
pluginID
=
aEvent
.
pluginID
;
let
doc
=
target
.
document
;
if
(
!
gmpPlugin
|
|
!
doc
)
{
return
;
}
let
messageString
=
gNavigatorBundle
.
formatStringFromName
(
"
crashedpluginsMessage
.
title
"
[
pluginName
]
1
)
;
this
.
mm
.
sendAsyncMessage
(
"
PluginContent
:
ShowPluginCrashedNotification
"
{
messageString
pluginID
}
)
;
doc
.
defaultView
.
top
.
addEventListener
(
"
unload
"
event
=
>
{
this
.
hideNotificationBar
(
"
plugin
-
crashed
"
)
;
}
)
;
}
}
