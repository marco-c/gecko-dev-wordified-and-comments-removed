"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
PluginChild
"
]
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
const
{
BrowserUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
BrowserUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gNavigatorBundle
"
function
(
)
{
const
url
=
"
chrome
:
/
/
browser
/
locale
/
browser
.
properties
"
;
return
Services
.
strings
.
createBundle
(
url
)
;
}
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
gPluginHost
"
"
mozilla
.
org
/
plugin
/
host
;
1
"
"
nsIPluginHost
"
)
;
const
OVERLAY_DISPLAY
=
{
HIDDEN
:
0
BLANK
:
1
TINY
:
2
REDUCED
:
3
NOTEXT
:
4
FULL
:
5
}
;
const
kSubmitMsg
=
"
PluginParent
:
NPAPIPluginCrashReportSubmitted
"
;
class
PluginChild
extends
JSWindowActorChild
{
constructor
(
)
{
super
(
)
;
this
.
pluginCrashData
=
new
Map
(
)
;
Services
.
cpmm
.
addMessageListener
(
kSubmitMsg
this
)
;
}
didDestroy
(
)
{
Services
.
cpmm
.
removeMessageListener
(
kSubmitMsg
this
)
;
if
(
this
.
_addedListeners
)
{
this
.
contentWindow
.
removeEventListener
(
"
pagehide
"
this
{
capture
:
true
mozSystemGroup
:
true
}
)
;
this
.
contentWindow
.
removeEventListener
(
"
pageshow
"
this
{
capture
:
true
mozSystemGroup
:
true
}
)
;
}
}
receiveMessage
(
msg
)
{
switch
(
msg
.
name
)
{
case
"
PluginParent
:
ActivatePlugins
"
:
this
.
activatePlugins
(
msg
.
data
.
activationInfo
msg
.
data
.
newState
)
;
break
;
case
"
PluginParent
:
NPAPIPluginCrashReportSubmitted
"
:
this
.
NPAPIPluginCrashReportSubmitted
(
{
runID
:
msg
.
data
.
runID
state
:
msg
.
data
.
state
}
)
;
break
;
case
"
PluginParent
:
Test
:
ClearCrashData
"
:
if
(
Services
.
prefs
.
getBoolPref
(
"
plugins
.
testmode
"
)
)
{
this
.
pluginCrashData
.
clear
(
)
;
}
}
}
observe
(
aSubject
aTopic
aData
)
{
switch
(
aTopic
)
{
case
"
decoder
-
doctor
-
notification
"
:
let
data
=
JSON
.
parse
(
aData
)
;
let
type
=
data
.
type
.
toLowerCase
(
)
;
if
(
type
=
=
"
cannot
-
play
"
&
&
this
.
haveShownNotification
&
&
aSubject
.
top
.
document
=
=
this
.
document
&
&
data
.
formats
.
toLowerCase
(
)
.
includes
(
"
application
/
x
-
mpegurl
"
0
)
)
{
this
.
contentWindow
.
pluginRequiresReload
=
true
;
}
}
}
onPageShow
(
event
)
{
if
(
!
this
.
contentWindow
|
|
event
.
target
!
=
this
.
document
)
{
return
;
}
if
(
event
.
persisted
)
{
this
.
reshowClickToPlayNotification
(
)
;
}
}
onPageHide
(
event
)
{
if
(
!
this
.
contentWindow
|
|
event
.
target
!
=
this
.
document
)
{
return
;
}
this
.
clearPluginCaches
(
)
;
this
.
haveShownNotification
=
false
;
}
getPluginUI
(
pluginElement
anonid
)
{
if
(
pluginElement
.
openOrClosedShadowRoot
&
&
pluginElement
.
openOrClosedShadowRoot
.
isUAWidget
(
)
)
{
return
pluginElement
.
openOrClosedShadowRoot
.
getElementById
(
anonid
)
;
}
return
null
;
}
_getPluginInfo
(
pluginElement
)
{
if
(
this
.
isKnownPlugin
(
pluginElement
)
)
{
let
pluginTag
=
gPluginHost
.
getPluginTagForType
(
pluginElement
.
actualType
)
;
let
pluginName
=
BrowserUtils
.
makeNicePluginName
(
pluginTag
.
name
)
;
let
fallbackType
=
pluginElement
.
defaultFallbackType
;
let
permissionString
=
gPluginHost
.
getPermissionStringForType
(
pluginElement
.
actualType
)
;
return
{
pluginTag
pluginName
fallbackType
permissionString
}
;
}
return
{
fallbackType
:
null
permissionString
:
null
pluginName
:
gNavigatorBundle
.
GetStringFromName
(
"
pluginInfo
.
unknownPlugin
"
)
pluginTag
:
null
}
;
}
_getPluginInfoForTag
(
pluginTag
)
{
let
fallbackType
=
Ci
.
nsIObjectLoadingContent
.
PLUGIN_CLICK_TO_PLAY
;
if
(
pluginTag
)
{
let
pluginName
=
BrowserUtils
.
makeNicePluginName
(
pluginTag
.
name
)
;
let
permissionString
=
gPluginHost
.
getPermissionStringForTag
(
pluginTag
)
;
return
{
pluginTag
pluginName
permissionString
fallbackType
}
;
}
return
{
fallbackType
permissionString
:
null
pluginName
:
gNavigatorBundle
.
GetStringFromName
(
"
pluginInfo
.
unknownPlugin
"
)
pluginTag
:
null
}
;
}
setVisibility
(
plugin
overlay
overlayDisplayState
)
{
overlay
.
classList
.
toggle
(
"
visible
"
overlayDisplayState
!
=
OVERLAY_DISPLAY
.
HIDDEN
)
;
if
(
overlayDisplayState
!
=
OVERLAY_DISPLAY
.
HIDDEN
)
{
overlay
.
removeAttribute
(
"
dismissed
"
)
;
}
}
computeAndAdjustOverlayDisplay
(
plugin
overlay
flushLayout
)
{
let
fallbackType
=
plugin
.
pluginFallbackType
;
if
(
plugin
.
pluginFallbackTypeOverride
!
=
=
undefined
)
{
fallbackType
=
plugin
.
pluginFallbackTypeOverride
;
}
if
(
fallbackType
=
=
Ci
.
nsIObjectLoadingContent
.
PLUGIN_CLICK_TO_PLAY_QUIET
)
{
return
OVERLAY_DISPLAY
.
HIDDEN
;
}
if
(
flushLayout
&
&
overlay
.
scrollWidth
=
=
0
)
{
return
OVERLAY_DISPLAY
.
FULL
;
}
let
overlayDisplay
=
OVERLAY_DISPLAY
.
FULL
;
let
cwu
=
plugin
.
ownerGlobal
.
windowUtils
;
let
pluginRect
=
flushLayout
?
plugin
.
getBoundingClientRect
(
)
:
cwu
.
getBoundsWithoutFlushing
(
plugin
)
;
let
pluginWidth
=
Math
.
ceil
(
pluginRect
.
width
)
;
let
pluginHeight
=
Math
.
ceil
(
pluginRect
.
height
)
;
let
layoutNeedsFlush
=
!
flushLayout
&
&
cwu
.
needsFlush
(
cwu
.
FLUSH_STYLE
)
&
&
cwu
.
needsFlush
(
cwu
.
FLUSH_LAYOUT
)
;
if
(
layoutNeedsFlush
)
{
overlayDisplay
=
OVERLAY_DISPLAY
.
FULL
;
overlay
.
setAttribute
(
"
sizing
"
"
oversized
"
)
;
overlay
.
removeAttribute
(
"
notext
"
)
;
}
else
if
(
pluginWidth
<
=
32
|
|
pluginHeight
<
=
32
)
{
overlay
.
setAttribute
(
"
sizing
"
"
blank
"
)
;
overlayDisplay
=
OVERLAY_DISPLAY
.
BLANK
;
}
else
if
(
pluginWidth
<
=
80
|
|
pluginHeight
<
=
60
)
{
overlayDisplay
=
OVERLAY_DISPLAY
.
TINY
;
overlay
.
setAttribute
(
"
sizing
"
"
tiny
"
)
;
overlay
.
setAttribute
(
"
notext
"
"
notext
"
)
;
}
else
if
(
pluginWidth
<
=
120
|
|
pluginHeight
<
=
80
)
{
overlayDisplay
=
OVERLAY_DISPLAY
.
REDUCED
;
overlay
.
setAttribute
(
"
sizing
"
"
reduced
"
)
;
overlay
.
setAttribute
(
"
notext
"
"
notext
"
)
;
}
else
if
(
pluginWidth
<
=
240
|
|
pluginHeight
<
=
160
)
{
overlayDisplay
=
OVERLAY_DISPLAY
.
NOTEXT
;
overlay
.
removeAttribute
(
"
sizing
"
)
;
overlay
.
setAttribute
(
"
notext
"
"
notext
"
)
;
}
else
{
overlayDisplay
=
OVERLAY_DISPLAY
.
FULL
;
overlay
.
removeAttribute
(
"
sizing
"
)
;
overlay
.
removeAttribute
(
"
notext
"
)
;
}
if
(
fallbackType
=
=
Ci
.
nsIObjectLoadingContent
.
PLUGIN_BLOCK_ALL
)
{
overlay
.
setAttribute
(
"
blockall
"
"
blockall
"
)
;
return
OVERLAY_DISPLAY
.
HIDDEN
;
}
if
(
layoutNeedsFlush
)
{
return
overlayDisplay
;
}
let
overflows
=
overlay
.
scrollWidth
>
pluginWidth
|
|
overlay
.
scrollHeight
-
5
>
pluginHeight
;
if
(
overflows
)
{
overlay
.
setAttribute
(
"
sizing
"
"
blank
"
)
;
return
OVERLAY_DISPLAY
.
BLANK
;
}
let
left
=
pluginRect
.
left
+
2
;
let
right
=
pluginRect
.
right
-
2
;
let
top
=
pluginRect
.
top
+
2
;
let
bottom
=
pluginRect
.
bottom
-
2
;
let
centerX
=
left
+
(
right
-
left
)
/
2
;
let
centerY
=
top
+
(
bottom
-
top
)
/
2
;
let
points
=
[
[
left
top
]
[
left
bottom
]
[
right
top
]
[
right
bottom
]
[
centerX
centerY
]
]
;
for
(
let
[
x
y
]
of
points
)
{
if
(
x
<
0
|
|
y
<
0
)
{
continue
;
}
let
el
=
cwu
.
elementFromPoint
(
x
y
true
true
)
;
if
(
el
=
=
=
plugin
)
{
return
overlayDisplay
;
}
}
overlay
.
setAttribute
(
"
sizing
"
"
blank
"
)
;
return
OVERLAY_DISPLAY
.
BLANK
;
}
addLinkClickCallback
(
linkNode
callbackName
)
{
let
self
=
this
;
let
callbackArgs
=
Array
.
prototype
.
slice
.
call
(
arguments
)
.
slice
(
2
)
;
linkNode
.
addEventListener
(
"
click
"
function
(
evt
)
{
if
(
!
evt
.
isTrusted
)
{
return
;
}
evt
.
preventDefault
(
)
;
if
(
!
callbackArgs
.
length
)
{
callbackArgs
=
[
evt
]
;
}
self
[
callbackName
]
.
apply
(
self
callbackArgs
)
;
}
true
)
;
linkNode
.
addEventListener
(
"
keydown
"
function
(
evt
)
{
if
(
!
evt
.
isTrusted
)
{
return
;
}
if
(
evt
.
keyCode
=
=
evt
.
DOM_VK_RETURN
)
{
evt
.
preventDefault
(
)
;
if
(
!
callbackArgs
.
length
)
{
callbackArgs
=
[
evt
]
;
}
evt
.
preventDefault
(
)
;
self
[
callbackName
]
.
apply
(
self
callbackArgs
)
;
}
}
true
)
;
}
_getBindingType
(
plugin
)
{
if
(
!
(
plugin
instanceof
Ci
.
nsIObjectLoadingContent
)
)
{
return
null
;
}
switch
(
plugin
.
pluginFallbackType
)
{
case
Ci
.
nsIObjectLoadingContent
.
PLUGIN_UNSUPPORTED
:
return
"
PluginNotFound
"
;
case
Ci
.
nsIObjectLoadingContent
.
PLUGIN_DISABLED
:
return
"
PluginDisabled
"
;
case
Ci
.
nsIObjectLoadingContent
.
PLUGIN_BLOCKLISTED
:
return
"
PluginBlocklisted
"
;
case
Ci
.
nsIObjectLoadingContent
.
PLUGIN_OUTDATED
:
return
"
PluginOutdated
"
;
case
Ci
.
nsIObjectLoadingContent
.
PLUGIN_CLICK_TO_PLAY
:
case
Ci
.
nsIObjectLoadingContent
.
PLUGIN_CLICK_TO_PLAY_QUIET
:
return
"
PluginClickToPlay
"
;
case
Ci
.
nsIObjectLoadingContent
.
PLUGIN_VULNERABLE_UPDATABLE
:
return
"
PluginVulnerableUpdatable
"
;
case
Ci
.
nsIObjectLoadingContent
.
PLUGIN_VULNERABLE_NO_UPDATE
:
return
"
PluginVulnerableNoUpdate
"
;
case
Ci
.
nsIObjectLoadingContent
.
PLUGIN_BLOCK_ALL
:
return
"
PluginBlockAll
"
;
default
:
return
null
;
}
}
handleEvent
(
event
)
{
let
eventDoc
=
event
.
target
.
ownerDocument
|
|
event
.
target
.
document
;
if
(
eventDoc
&
&
eventDoc
!
=
this
.
document
)
{
return
;
}
if
(
!
this
.
_addedListeners
)
{
this
.
contentWindow
.
addEventListener
(
"
pagehide
"
this
{
capture
:
true
mozSystemGroup
:
true
}
)
;
this
.
contentWindow
.
addEventListener
(
"
pageshow
"
this
{
capture
:
true
mozSystemGroup
:
true
}
)
;
this
.
_addedListeners
=
true
;
}
let
eventType
=
event
.
type
;
if
(
eventType
=
=
"
pagehide
"
)
{
this
.
onPageHide
(
event
)
;
return
;
}
if
(
eventType
=
=
"
pageshow
"
)
{
this
.
onPageShow
(
event
)
;
return
;
}
if
(
eventType
=
=
"
click
"
)
{
this
.
onOverlayClick
(
event
)
;
return
;
}
if
(
eventType
=
=
"
PluginCrashed
"
&
&
!
(
event
.
target
instanceof
Ci
.
nsIObjectLoadingContent
)
)
{
this
.
onPluginCrashed
(
event
.
target
event
)
;
return
;
}
if
(
eventType
=
=
"
HiddenPlugin
"
)
{
let
pluginTag
=
event
.
tag
.
QueryInterface
(
Ci
.
nsIPluginTag
)
;
this
.
showClickToPlayNotification
(
pluginTag
false
)
;
}
let
pluginElement
=
event
.
target
;
if
(
!
(
pluginElement
instanceof
Ci
.
nsIObjectLoadingContent
)
)
{
return
;
}
if
(
eventType
=
=
"
PluginBindingAttached
"
)
{
let
overlay
=
this
.
getPluginUI
(
pluginElement
"
main
"
)
;
if
(
!
overlay
|
|
overlay
.
_bindingHandled
)
{
return
;
}
overlay
.
_bindingHandled
=
true
;
eventType
=
this
.
_getBindingType
(
pluginElement
)
;
if
(
!
eventType
)
{
return
;
}
}
let
shouldShowNotification
=
false
;
switch
(
eventType
)
{
case
"
PluginCrashed
"
:
this
.
onPluginCrashed
(
pluginElement
event
)
;
break
;
case
"
PluginBlockAll
"
:
case
"
PluginNotFound
"
:
{
break
;
}
case
"
PluginBlocklisted
"
:
case
"
PluginOutdated
"
:
shouldShowNotification
=
true
;
break
;
case
"
PluginVulnerableUpdatable
"
:
let
updateLink
=
this
.
getPluginUI
(
pluginElement
"
checkForUpdatesLink
"
)
;
let
{
pluginTag
}
=
this
.
_getPluginInfo
(
pluginElement
)
;
this
.
addLinkClickCallback
(
updateLink
"
forwardCallback
"
"
openPluginUpdatePage
"
pluginTag
.
id
)
;
case
"
PluginVulnerableNoUpdate
"
:
case
"
PluginClickToPlay
"
:
this
.
_handleClickToPlayEvent
(
pluginElement
)
;
let
{
pluginName
}
=
this
.
_getPluginInfo
(
pluginElement
)
;
let
messageString
=
gNavigatorBundle
.
formatStringFromName
(
"
PluginClickToActivate2
"
[
pluginName
]
)
;
let
overlayText
=
this
.
getPluginUI
(
pluginElement
"
clickToPlay
"
)
;
overlayText
.
textContent
=
messageString
;
if
(
eventType
=
=
"
PluginVulnerableUpdatable
"
|
|
eventType
=
=
"
PluginVulnerableNoUpdate
"
)
{
let
vulnerabilityString
=
gNavigatorBundle
.
GetStringFromName
(
eventType
)
;
let
vulnerabilityText
=
this
.
getPluginUI
(
pluginElement
"
vulnerabilityStatus
"
)
;
vulnerabilityText
.
textContent
=
vulnerabilityString
;
}
shouldShowNotification
=
true
;
break
;
case
"
PluginDisabled
"
:
let
manageLink
=
this
.
getPluginUI
(
pluginElement
"
managePluginsLink
"
)
;
this
.
addLinkClickCallback
(
manageLink
"
forwardCallback
"
"
managePlugins
"
)
;
shouldShowNotification
=
true
;
break
;
case
"
PluginInstantiated
"
:
shouldShowNotification
=
true
;
break
;
}
let
overlay
=
this
.
getPluginUI
(
pluginElement
"
main
"
)
;
if
(
eventType
!
=
"
PluginCrashed
"
)
{
if
(
overlay
!
=
null
)
{
this
.
setVisibility
(
pluginElement
overlay
this
.
computeAndAdjustOverlayDisplay
(
pluginElement
overlay
false
)
)
;
let
resizeListener
=
(
)
=
>
{
this
.
setVisibility
(
pluginElement
overlay
this
.
computeAndAdjustOverlayDisplay
(
pluginElement
overlay
true
)
)
;
}
;
pluginElement
.
addEventListener
(
"
overflow
"
resizeListener
)
;
pluginElement
.
addEventListener
(
"
underflow
"
resizeListener
)
;
}
}
let
closeIcon
=
this
.
getPluginUI
(
pluginElement
"
closeIcon
"
)
;
if
(
closeIcon
)
{
closeIcon
.
addEventListener
(
"
click
"
clickEvent
=
>
{
if
(
clickEvent
.
button
=
=
0
&
&
clickEvent
.
isTrusted
)
{
this
.
hideClickToPlayOverlay
(
pluginElement
)
;
overlay
.
setAttribute
(
"
dismissed
"
"
true
"
)
;
}
}
true
)
;
}
if
(
shouldShowNotification
)
{
this
.
showClickToPlayNotification
(
pluginElement
false
)
;
}
}
isKnownPlugin
(
objLoadingContent
)
{
return
(
objLoadingContent
.
getContentTypeForMIMEType
(
objLoadingContent
.
actualType
)
=
=
Ci
.
nsIObjectLoadingContent
.
TYPE_PLUGIN
)
;
}
canActivatePlugin
(
objLoadingContent
)
{
if
(
!
this
.
isKnownPlugin
(
objLoadingContent
)
)
{
return
false
;
}
let
permissionString
=
gPluginHost
.
getPermissionStringForType
(
objLoadingContent
.
actualType
)
;
let
principal
=
objLoadingContent
.
ownerGlobal
.
top
.
document
.
nodePrincipal
;
let
pluginPermission
=
Services
.
perms
.
testPermissionFromPrincipal
(
principal
permissionString
)
;
let
isFallbackTypeValid
=
objLoadingContent
.
pluginFallbackType
>
=
Ci
.
nsIObjectLoadingContent
.
PLUGIN_CLICK_TO_PLAY
&
&
objLoadingContent
.
pluginFallbackType
<
=
Ci
.
nsIObjectLoadingContent
.
PLUGIN_CLICK_TO_PLAY_QUIET
;
return
(
!
objLoadingContent
.
activated
&
&
pluginPermission
!
=
Ci
.
nsIPermissionManager
.
DENY_ACTION
&
&
isFallbackTypeValid
)
;
}
hideClickToPlayOverlay
(
pluginElement
)
{
let
overlay
=
this
.
getPluginUI
(
pluginElement
"
main
"
)
;
if
(
overlay
)
{
overlay
.
classList
.
remove
(
"
visible
"
)
;
}
}
forwardCallback
(
name
pluginId
)
{
this
.
sendAsyncMessage
(
"
PluginContent
:
LinkClickCallback
"
{
name
pluginId
}
)
;
}
submitReport
(
plugin
)
{
if
(
!
AppConstants
.
MOZ_CRASHREPORTER
)
{
return
;
}
if
(
!
plugin
)
{
Cu
.
reportError
(
"
Attempted
to
submit
crash
report
without
an
associated
plugin
.
"
)
;
return
;
}
if
(
!
(
plugin
instanceof
Ci
.
nsIObjectLoadingContent
)
)
{
Cu
.
reportError
(
"
Attempted
to
submit
crash
report
on
plugin
that
does
not
"
+
"
implement
nsIObjectLoadingContent
.
"
)
;
return
;
}
let
runID
=
plugin
.
runID
;
let
submitURLOptIn
=
this
.
getPluginUI
(
plugin
"
submitURLOptIn
"
)
.
checked
;
let
keyVals
=
{
}
;
let
userComment
=
this
.
getPluginUI
(
plugin
"
submitComment
"
)
.
value
.
trim
(
)
;
if
(
userComment
)
{
keyVals
.
PluginUserComment
=
userComment
;
}
if
(
submitURLOptIn
)
{
keyVals
.
PluginContentURL
=
plugin
.
ownerDocument
.
URL
;
}
this
.
sendAsyncMessage
(
"
PluginContent
:
SubmitReport
"
{
runID
keyVals
submitURLOptIn
}
)
;
}
reloadPage
(
)
{
this
.
contentWindow
.
location
.
reload
(
)
;
}
_handleClickToPlayEvent
(
plugin
)
{
let
doc
=
plugin
.
ownerDocument
;
if
(
!
this
.
isKnownPlugin
(
plugin
)
)
{
return
;
}
let
permissionString
=
gPluginHost
.
getPermissionStringForType
(
plugin
.
actualType
)
;
let
principal
=
doc
.
defaultView
.
top
.
document
.
nodePrincipal
;
let
pluginPermission
=
Services
.
perms
.
testPermissionFromPrincipal
(
principal
permissionString
)
;
let
overlay
=
this
.
getPluginUI
(
plugin
"
main
"
)
;
if
(
pluginPermission
=
=
Ci
.
nsIPermissionManager
.
DENY_ACTION
|
|
pluginPermission
=
=
Ci
.
nsIObjectLoadingContent
.
PLUGIN_PERMISSION_PROMPT_ACTION_QUIET
)
{
if
(
overlay
)
{
overlay
.
classList
.
remove
(
"
visible
"
)
;
}
return
;
}
if
(
overlay
)
{
overlay
.
addEventListener
(
"
click
"
this
true
)
;
}
}
onOverlayClick
(
event
)
{
let
plugin
=
event
.
target
.
containingShadowRoot
.
host
;
let
overlay
=
this
.
getPluginUI
(
plugin
"
main
"
)
;
if
(
!
(
ChromeUtils
.
getClassName
(
event
.
originalTarget
)
=
=
=
"
HTMLAnchorElement
"
)
&
&
event
.
originalTarget
.
getAttribute
(
"
anonid
"
)
!
=
"
closeIcon
"
&
&
event
.
originalTarget
.
id
!
=
"
closeIcon
"
&
&
!
overlay
.
hasAttribute
(
"
dismissed
"
)
&
&
!
overlay
.
hasAttribute
(
"
blockall
"
)
&
&
event
.
button
=
=
0
&
&
event
.
isTrusted
)
{
this
.
showClickToPlayNotification
(
plugin
true
)
;
event
.
stopPropagation
(
)
;
event
.
preventDefault
(
)
;
}
}
reshowClickToPlayNotification
(
)
{
let
{
plugins
}
=
this
.
contentWindow
.
windowUtils
;
for
(
let
plugin
of
plugins
)
{
let
overlay
=
this
.
getPluginUI
(
plugin
"
main
"
)
;
if
(
overlay
)
{
overlay
.
removeEventListener
(
"
click
"
this
true
)
;
}
if
(
this
.
canActivatePlugin
(
plugin
)
)
{
this
.
_handleClickToPlayEvent
(
plugin
)
;
}
}
this
.
showClickToPlayNotification
(
null
false
)
;
}
activatePlugins
(
activationInfo
newState
)
{
let
{
plugins
}
=
this
.
contentWindow
.
windowUtils
;
let
pluginFound
=
false
;
for
(
let
plugin
of
plugins
)
{
if
(
!
this
.
isKnownPlugin
(
plugin
)
)
{
continue
;
}
if
(
activationInfo
.
permissionString
=
=
gPluginHost
.
getPermissionStringForType
(
plugin
.
actualType
)
)
{
let
overlay
=
this
.
getPluginUI
(
plugin
"
main
"
)
;
pluginFound
=
true
;
if
(
newState
=
=
"
block
"
|
|
newState
=
=
"
blockalways
"
|
|
newState
=
=
"
continueblocking
"
)
{
if
(
overlay
)
{
overlay
.
addEventListener
(
"
click
"
this
true
)
;
}
plugin
.
pluginFallbackTypeOverride
=
activationInfo
.
fallbackType
;
plugin
.
reload
(
true
)
;
}
else
if
(
this
.
canActivatePlugin
(
plugin
)
)
{
if
(
overlay
)
{
overlay
.
removeEventListener
(
"
click
"
this
true
)
;
}
plugin
.
playPlugin
(
)
;
}
}
}
if
(
newState
!
=
"
block
"
&
&
newState
!
=
"
blockalways
"
&
&
newState
!
=
"
continueblocking
"
&
&
(
!
pluginFound
|
|
this
.
contentWindow
.
pluginRequiresReload
)
)
{
this
.
reloadPage
(
)
;
}
}
showClickToPlayNotification
(
pluginElOrTag
showNow
)
{
let
plugins
=
[
]
;
if
(
pluginElOrTag
=
=
=
null
)
{
plugins
=
this
.
contentWindow
.
windowUtils
.
plugins
.
filter
(
p
=
>
p
.
getContentTypeForMIMEType
(
p
.
actualType
)
=
=
Ci
.
nsIObjectLoadingContent
.
TYPE_PLUGIN
)
;
if
(
!
plugins
.
length
)
{
this
.
removeNotification
(
)
;
return
;
}
}
else
{
plugins
=
[
pluginElOrTag
]
;
}
let
permissionMap
=
new
Map
(
)
;
for
(
let
p
of
plugins
)
{
let
pluginInfo
;
if
(
p
instanceof
Ci
.
nsIPluginTag
)
{
pluginInfo
=
this
.
_getPluginInfoForTag
(
p
)
;
}
else
{
pluginInfo
=
this
.
_getPluginInfo
(
p
)
;
}
if
(
pluginInfo
.
permissionString
=
=
=
null
)
{
Cu
.
reportError
(
"
No
permission
string
for
active
plugin
.
"
)
;
continue
;
}
if
(
!
permissionMap
.
has
(
pluginInfo
.
permissionString
)
)
{
permissionMap
.
set
(
pluginInfo
.
permissionString
pluginInfo
)
;
continue
;
}
}
if
(
permissionMap
.
size
>
1
)
{
Cu
.
reportError
(
"
Err
we
'
re
not
meant
to
have
more
than
1
plugin
anymore
!
"
)
;
}
if
(
!
permissionMap
.
size
)
{
return
;
}
this
.
haveShownNotification
=
true
;
let
permissionItem
=
permissionMap
.
values
(
)
.
next
(
)
.
value
;
let
plugin
=
{
id
:
permissionItem
.
pluginTag
.
id
fallbackType
:
permissionItem
.
fallbackType
}
;
let
msg
=
"
PluginContent
:
ShowClickToPlayNotification
"
;
this
.
sendAsyncMessage
(
msg
{
plugin
showNow
}
)
;
}
removeNotification
(
)
{
this
.
sendAsyncMessage
(
"
PluginContent
:
RemoveNotification
"
)
;
}
clearPluginCaches
(
)
{
this
.
pluginCrashData
.
clear
(
)
;
}
isWithinFullScreenElement
(
fullScreenElement
domElement
)
{
let
getTrueFullScreenElement
=
fullScreenIframe
=
>
{
if
(
typeof
fullScreenIframe
.
contentDocument
!
=
=
"
undefined
"
&
&
fullScreenIframe
.
contentDocument
.
mozFullScreenElement
)
{
return
getTrueFullScreenElement
(
fullScreenIframe
.
contentDocument
.
mozFullScreenElement
)
;
}
return
fullScreenIframe
;
}
;
if
(
fullScreenElement
.
tagName
=
=
=
"
IFRAME
"
)
{
fullScreenElement
=
getTrueFullScreenElement
(
fullScreenElement
)
;
}
if
(
fullScreenElement
.
contains
(
domElement
)
)
{
return
true
;
}
let
parentIframe
=
domElement
.
ownerGlobal
.
frameElement
;
if
(
parentIframe
)
{
return
this
.
isWithinFullScreenElement
(
fullScreenElement
parentIframe
)
;
}
return
false
;
}
async
onPluginCrashed
(
target
aEvent
)
{
if
(
!
(
aEvent
instanceof
this
.
contentWindow
.
PluginCrashedEvent
)
)
{
return
;
}
let
fullScreenElement
=
this
.
contentWindow
.
top
.
document
.
mozFullScreenElement
;
if
(
fullScreenElement
)
{
if
(
this
.
isWithinFullScreenElement
(
fullScreenElement
target
)
)
{
this
.
contentWindow
.
top
.
document
.
mozCancelFullScreen
(
)
;
}
}
if
(
aEvent
.
gmpPlugin
)
{
this
.
GMPCrashed
(
aEvent
)
;
return
;
}
if
(
!
(
target
instanceof
Ci
.
nsIObjectLoadingContent
)
)
{
return
;
}
let
crashData
=
this
.
pluginCrashData
.
get
(
target
.
runID
)
;
if
(
!
crashData
)
{
crashData
=
await
this
.
sendQuery
(
"
PluginContent
:
GetCrashData
"
{
runID
:
target
.
runID
}
)
;
this
.
pluginCrashData
.
set
(
target
.
runID
crashData
)
;
}
this
.
setCrashedNPAPIPluginState
(
{
pluginElement
:
target
state
:
crashData
.
state
pluginName
:
crashData
.
pluginName
}
)
;
}
setCrashedNPAPIPluginState
(
{
pluginElement
state
pluginName
}
)
{
let
overlay
=
this
.
getPluginUI
(
pluginElement
"
main
"
)
;
let
statusDiv
=
this
.
getPluginUI
(
pluginElement
"
submitStatus
"
)
;
let
optInCB
=
this
.
getPluginUI
(
pluginElement
"
submitURLOptIn
"
)
;
this
.
getPluginUI
(
pluginElement
"
submitButton
"
)
.
addEventListener
(
"
click
"
event
=
>
{
if
(
event
.
button
!
=
0
|
|
!
event
.
isTrusted
)
{
return
;
}
this
.
submitReport
(
pluginElement
)
;
}
)
;
optInCB
.
checked
=
Services
.
prefs
.
getBoolPref
(
"
dom
.
ipc
.
plugins
.
reportCrashURL
"
true
)
;
statusDiv
.
setAttribute
(
"
status
"
state
)
;
let
helpIcon
=
this
.
getPluginUI
(
pluginElement
"
helpIcon
"
)
;
this
.
addLinkClickCallback
(
helpIcon
"
openHelpPage
"
)
;
let
crashText
=
this
.
getPluginUI
(
pluginElement
"
crashedText
"
)
;
let
message
=
gNavigatorBundle
.
formatStringFromName
(
"
crashedpluginsMessage
.
title
"
[
pluginName
]
)
;
crashText
.
textContent
=
message
;
let
link
=
this
.
getPluginUI
(
pluginElement
"
reloadLink
"
)
;
this
.
addLinkClickCallback
(
link
"
reloadPage
"
)
;
let
overlayDisplayState
=
this
.
computeAndAdjustOverlayDisplay
(
pluginElement
overlay
true
)
;
if
(
overlayDisplayState
!
=
OVERLAY_DISPLAY
.
FULL
)
{
statusDiv
.
removeAttribute
(
"
status
"
)
;
overlayDisplayState
=
this
.
computeAndAdjustOverlayDisplay
(
pluginElement
overlay
true
)
;
}
this
.
setVisibility
(
pluginElement
overlay
overlayDisplayState
)
;
let
doc
=
pluginElement
.
ownerDocument
;
let
runID
=
pluginElement
.
runID
;
if
(
overlayDisplayState
=
=
OVERLAY_DISPLAY
.
FULL
)
{
doc
.
mozNoPluginCrashedNotification
=
true
;
let
winUtils
=
this
.
contentWindow
.
windowUtils
;
let
event
=
new
this
.
contentWindow
.
CustomEvent
(
"
PluginCrashReporterDisplayed
"
{
bubbles
:
true
}
)
;
winUtils
.
dispatchEventToChromeOnly
(
pluginElement
event
)
;
}
else
if
(
!
doc
.
mozNoPluginCrashedNotification
)
{
this
.
sendAsyncMessage
(
"
PluginContent
:
ShowPluginCrashedNotification
"
{
pluginCrashID
:
{
runID
}
}
)
;
}
}
NPAPIPluginCrashReportSubmitted
(
{
runID
state
}
)
{
this
.
pluginCrashData
.
delete
(
runID
)
;
let
{
plugins
}
=
this
.
contentWindow
.
windowUtils
;
for
(
let
pluginElement
of
plugins
)
{
if
(
pluginElement
instanceof
Ci
.
nsIObjectLoadingContent
&
&
pluginElement
.
runID
=
=
runID
)
{
let
statusDiv
=
this
.
getPluginUI
(
pluginElement
"
submitStatus
"
)
;
statusDiv
.
setAttribute
(
"
status
"
state
)
;
}
}
}
GMPCrashed
(
aEvent
)
{
let
{
target
gmpPlugin
pluginID
}
=
aEvent
;
if
(
!
gmpPlugin
|
|
!
target
.
document
)
{
return
;
}
this
.
sendAsyncMessage
(
"
PluginContent
:
ShowPluginCrashedNotification
"
{
pluginCrashID
:
{
pluginID
}
}
)
;
}
}
