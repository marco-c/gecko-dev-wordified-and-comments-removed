"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
FormValidationChild
"
]
;
const
{
LayoutUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
LayoutUtils
.
jsm
"
)
;
class
FormValidationChild
extends
JSWindowActorChild
{
constructor
(
)
{
super
(
)
;
this
.
_validationMessage
=
"
"
;
this
.
_element
=
null
;
}
handleEvent
(
aEvent
)
{
switch
(
aEvent
.
type
)
{
case
"
MozInvalidForm
"
:
aEvent
.
preventDefault
(
)
;
this
.
notifyInvalidSubmit
(
aEvent
.
detail
)
;
break
;
case
"
pageshow
"
:
if
(
this
.
_isRootDocumentEvent
(
aEvent
)
)
{
this
.
_hidePopup
(
)
;
}
break
;
case
"
pagehide
"
:
this
.
_onBlur
(
)
;
break
;
case
"
input
"
:
this
.
_onInput
(
aEvent
)
;
break
;
case
"
blur
"
:
this
.
_onBlur
(
aEvent
)
;
break
;
}
}
notifyInvalidSubmit
(
aInvalidElements
)
{
for
(
let
element
of
aInvalidElements
)
{
if
(
this
.
contentWindow
!
=
element
.
ownerGlobal
.
document
.
defaultView
)
{
return
;
}
if
(
!
(
ChromeUtils
.
getClassName
(
element
)
=
=
=
"
HTMLInputElement
"
|
|
ChromeUtils
.
getClassName
(
element
)
=
=
=
"
HTMLTextAreaElement
"
|
|
ChromeUtils
.
getClassName
(
element
)
=
=
=
"
HTMLSelectElement
"
|
|
ChromeUtils
.
getClassName
(
element
)
=
=
=
"
HTMLButtonElement
"
|
|
element
.
isFormAssociatedCustomElements
)
)
{
continue
;
}
let
validationMessage
=
element
.
isFormAssociatedCustomElements
?
element
.
internals
.
validationMessage
:
element
.
validationMessage
;
if
(
element
.
isFormAssociatedCustomElements
)
{
element
=
element
.
internals
.
validationAnchor
;
}
if
(
!
element
|
|
!
Services
.
focus
.
elementIsFocusable
(
element
0
)
)
{
continue
;
}
this
.
_validationMessage
=
validationMessage
;
if
(
this
.
_element
=
=
element
)
{
this
.
_showPopup
(
element
)
;
break
;
}
this
.
_element
=
element
;
element
.
focus
(
)
;
element
.
addEventListener
(
"
input
"
this
)
;
element
.
addEventListener
(
"
blur
"
this
)
;
this
.
_showPopup
(
element
)
;
break
;
}
}
_onInput
(
aEvent
)
{
let
element
=
aEvent
.
originalTarget
;
if
(
element
.
validity
.
valid
)
{
this
.
_hidePopup
(
)
;
return
;
}
if
(
this
.
_validationMessage
!
=
element
.
validationMessage
)
{
this
.
_validationMessage
=
element
.
validationMessage
;
this
.
_showPopup
(
element
)
;
}
}
_onBlur
(
aEvent
)
{
if
(
this
.
_element
)
{
this
.
_element
.
removeEventListener
(
"
input
"
this
)
;
this
.
_element
.
removeEventListener
(
"
blur
"
this
)
;
}
this
.
_hidePopup
(
)
;
this
.
_element
=
null
;
}
_showPopup
(
aElement
)
{
let
panelData
=
{
}
;
panelData
.
message
=
this
.
_validationMessage
;
panelData
.
screenRect
=
LayoutUtils
.
getElementBoundingScreenRect
(
aElement
)
;
if
(
aElement
.
tagName
=
=
"
INPUT
"
&
&
(
aElement
.
type
=
=
"
radio
"
|
|
aElement
.
type
=
=
"
checkbox
"
)
)
{
panelData
.
position
=
"
bottomcenter
topleft
"
;
}
else
{
panelData
.
position
=
"
after_start
"
;
}
this
.
sendAsyncMessage
(
"
FormValidation
:
ShowPopup
"
panelData
)
;
aElement
.
ownerGlobal
.
addEventListener
(
"
pagehide
"
this
{
mozSystemGroup
:
true
}
)
;
}
_hidePopup
(
)
{
this
.
sendAsyncMessage
(
"
FormValidation
:
HidePopup
"
{
}
)
;
this
.
_element
.
ownerGlobal
.
removeEventListener
(
"
pagehide
"
this
{
mozSystemGroup
:
true
}
)
;
}
_isRootDocumentEvent
(
aEvent
)
{
if
(
this
.
contentWindow
=
=
null
)
{
return
true
;
}
let
target
=
aEvent
.
originalTarget
;
return
(
target
=
=
this
.
document
|
|
(
target
.
ownerDocument
&
&
target
.
ownerDocument
=
=
this
.
document
)
)
;
}
}
