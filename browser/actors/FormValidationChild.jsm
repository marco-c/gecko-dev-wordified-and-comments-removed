"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
FormValidationChild
"
]
;
const
{
BrowserUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
BrowserUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
class
FormValidationChild
extends
JSWindowActorChild
{
constructor
(
)
{
super
(
)
;
this
.
_validationMessage
=
"
"
;
this
.
_element
=
null
;
this
.
_addedPageShowListener
=
false
;
}
handleEvent
(
aEvent
)
{
if
(
!
this
.
_addedPageShowListener
)
{
this
.
contentWindow
.
addEventListener
(
"
pageshow
"
this
)
;
this
.
_addedPageShowListener
=
true
;
}
switch
(
aEvent
.
type
)
{
case
"
MozInvalidForm
"
:
aEvent
.
preventDefault
(
)
;
this
.
notifyInvalidSubmit
(
aEvent
.
target
aEvent
.
detail
)
;
break
;
case
"
pageshow
"
:
if
(
this
.
_isRootDocumentEvent
(
aEvent
)
)
{
this
.
_hidePopup
(
)
;
}
break
;
case
"
input
"
:
this
.
_onInput
(
aEvent
)
;
break
;
case
"
blur
"
:
this
.
_onBlur
(
aEvent
)
;
break
;
}
}
notifyInvalidSubmit
(
aFormElement
aInvalidElements
)
{
for
(
let
element
of
aInvalidElements
)
{
if
(
this
.
contentWindow
!
=
element
.
ownerGlobal
.
document
.
defaultView
)
{
return
;
}
if
(
!
(
ChromeUtils
.
getClassName
(
element
)
=
=
=
"
HTMLInputElement
"
|
|
ChromeUtils
.
getClassName
(
element
)
=
=
=
"
HTMLTextAreaElement
"
|
|
ChromeUtils
.
getClassName
(
element
)
=
=
=
"
HTMLSelectElement
"
|
|
ChromeUtils
.
getClassName
(
element
)
=
=
=
"
HTMLButtonElement
"
)
)
{
continue
;
}
if
(
!
Services
.
focus
.
elementIsFocusable
(
element
0
)
)
{
continue
;
}
this
.
_validationMessage
=
element
.
validationMessage
;
if
(
this
.
_element
=
=
element
)
{
this
.
_showPopup
(
element
)
;
break
;
}
this
.
_element
=
element
;
element
.
focus
(
)
;
element
.
addEventListener
(
"
input
"
this
)
;
element
.
addEventListener
(
"
blur
"
this
)
;
this
.
_showPopup
(
element
)
;
break
;
}
}
_onInput
(
aEvent
)
{
let
element
=
aEvent
.
originalTarget
;
if
(
element
.
validity
.
valid
)
{
this
.
_hidePopup
(
)
;
return
;
}
if
(
this
.
_validationMessage
!
=
element
.
validationMessage
)
{
this
.
_validationMessage
=
element
.
validationMessage
;
this
.
_showPopup
(
element
)
;
}
}
_onBlur
(
aEvent
)
{
aEvent
.
originalTarget
.
removeEventListener
(
"
input
"
this
)
;
aEvent
.
originalTarget
.
removeEventListener
(
"
blur
"
this
)
;
this
.
_element
=
null
;
this
.
_hidePopup
(
)
;
}
_showPopup
(
aElement
)
{
let
panelData
=
{
}
;
panelData
.
message
=
this
.
_validationMessage
;
panelData
.
contentRect
=
BrowserUtils
.
getElementBoundingRect
(
aElement
)
;
let
offset
=
0
;
if
(
aElement
.
tagName
=
=
"
INPUT
"
&
&
(
aElement
.
type
=
=
"
radio
"
|
|
aElement
.
type
=
=
"
checkbox
"
)
)
{
panelData
.
position
=
"
bottomcenter
topleft
"
;
}
else
{
let
win
=
aElement
.
ownerGlobal
;
let
style
=
win
.
getComputedStyle
(
aElement
)
;
if
(
style
.
direction
=
=
"
rtl
"
)
{
offset
=
parseInt
(
style
.
paddingRight
)
+
parseInt
(
style
.
borderRightWidth
)
;
}
else
{
offset
=
parseInt
(
style
.
paddingLeft
)
+
parseInt
(
style
.
borderLeftWidth
)
;
}
let
zoomFactor
=
this
.
contentWindow
.
windowUtils
.
fullZoom
;
panelData
.
offset
=
Math
.
round
(
offset
*
zoomFactor
)
;
panelData
.
position
=
"
after_start
"
;
}
this
.
sendAsyncMessage
(
"
FormValidation
:
ShowPopup
"
panelData
)
;
}
_hidePopup
(
)
{
this
.
sendAsyncMessage
(
"
FormValidation
:
HidePopup
"
{
}
)
;
}
_isRootDocumentEvent
(
aEvent
)
{
if
(
this
.
contentWindow
=
=
null
)
{
return
true
;
}
let
target
=
aEvent
.
originalTarget
;
return
(
target
=
=
this
.
document
|
|
(
target
.
ownerDocument
&
&
target
.
ownerDocument
=
=
this
.
document
)
)
;
}
}
