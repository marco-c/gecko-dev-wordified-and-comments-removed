"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
ContentSearchParent
"
"
ContentSearch
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
BrowserSearchTelemetry
:
"
resource
:
/
/
/
modules
/
BrowserSearchTelemetry
.
jsm
"
FormHistory
:
"
resource
:
/
/
gre
/
modules
/
FormHistory
.
jsm
"
PrivateBrowsingUtils
:
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
SearchSuggestionController
:
"
resource
:
/
/
gre
/
modules
/
SearchSuggestionController
.
jsm
"
UrlbarPrefs
:
"
resource
:
/
/
/
modules
/
UrlbarPrefs
.
jsm
"
}
)
;
const
MAX_LOCAL_SUGGESTIONS
=
3
;
const
MAX_SUGGESTIONS
=
6
;
const
SEARCH_ENGINE_PLACEHOLDER_ICON
=
"
chrome
:
/
/
browser
/
skin
/
search
-
engine
-
placeholder
.
png
"
;
let
gContentSearchActors
=
new
Set
(
)
;
let
ContentSearch
=
{
initialized
:
false
_eventQueue
:
[
]
_currentEventPromise
:
null
_suggestionMap
:
new
WeakMap
(
)
_destroyedPromise
:
null
_currentSuggestion
:
null
init
(
)
{
if
(
!
this
.
initialized
)
{
Services
.
obs
.
addObserver
(
this
"
browser
-
search
-
engine
-
modified
"
)
;
Services
.
obs
.
addObserver
(
this
"
browser
-
search
-
service
"
)
;
Services
.
obs
.
addObserver
(
this
"
shutdown
-
leaks
-
before
-
check
"
)
;
Services
.
prefs
.
addObserver
(
"
browser
.
search
.
hiddenOneOffs
"
this
)
;
lazy
.
UrlbarPrefs
.
addObserver
(
this
)
;
this
.
initialized
=
true
;
}
}
get
searchSuggestionUIStrings
(
)
{
if
(
this
.
_searchSuggestionUIStrings
)
{
return
this
.
_searchSuggestionUIStrings
;
}
this
.
_searchSuggestionUIStrings
=
{
}
;
let
searchBundle
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
browser
/
locale
/
search
.
properties
"
)
;
let
stringNames
=
[
"
searchHeader
"
"
searchForSomethingWith2
"
"
searchWithHeader
"
"
searchSettings
"
]
;
for
(
let
name
of
stringNames
)
{
this
.
_searchSuggestionUIStrings
[
name
]
=
searchBundle
.
GetStringFromName
(
name
)
;
}
return
this
.
_searchSuggestionUIStrings
;
}
destroy
(
)
{
if
(
!
this
.
initialized
)
{
return
new
Promise
(
)
;
}
if
(
this
.
_destroyedPromise
)
{
return
this
.
_destroyedPromise
;
}
Services
.
prefs
.
removeObserver
(
"
browser
.
search
.
hiddenOneOffs
"
this
)
;
Services
.
obs
.
removeObserver
(
this
"
browser
-
search
-
engine
-
modified
"
)
;
Services
.
obs
.
removeObserver
(
this
"
browser
-
search
-
service
"
)
;
Services
.
obs
.
removeObserver
(
this
"
shutdown
-
leaks
-
before
-
check
"
)
;
this
.
_eventQueue
.
length
=
0
;
this
.
_destroyedPromise
=
Promise
.
resolve
(
this
.
_currentEventPromise
)
;
return
this
.
_destroyedPromise
;
}
observe
(
subj
topic
data
)
{
switch
(
topic
)
{
case
"
browser
-
search
-
service
"
:
if
(
data
!
=
"
init
-
complete
"
)
{
break
;
}
case
"
nsPref
:
changed
"
:
case
"
browser
-
search
-
engine
-
modified
"
:
this
.
_eventQueue
.
push
(
{
type
:
"
Observe
"
data
}
)
;
this
.
_processEventQueue
(
)
;
break
;
case
"
shutdown
-
leaks
-
before
-
check
"
:
subj
.
wrappedJSObject
.
client
.
addBlocker
(
"
ContentSearch
:
Wait
until
the
service
is
destroyed
"
(
)
=
>
this
.
destroy
(
)
)
;
break
;
}
}
onPrefChanged
(
pref
)
{
if
(
lazy
.
UrlbarPrefs
.
shouldHandOffToSearchModePrefs
.
includes
(
pref
)
)
{
this
.
_eventQueue
.
push
(
{
type
:
"
Observe
"
data
:
"
shouldHandOffToSearchMode
"
}
)
;
this
.
_processEventQueue
(
)
;
}
}
removeFormHistoryEntry
(
browser
entry
)
{
let
browserData
=
this
.
_suggestionDataForBrowser
(
browser
)
;
if
(
browserData
&
&
browserData
.
previousFormHistoryResult
)
{
let
{
previousFormHistoryResult
}
=
browserData
;
for
(
let
i
=
0
;
i
<
previousFormHistoryResult
.
matchCount
;
i
+
+
)
{
if
(
previousFormHistoryResult
.
getValueAt
(
i
)
=
=
=
entry
)
{
previousFormHistoryResult
.
removeValueAt
(
i
)
;
break
;
}
}
}
}
performSearch
(
actor
browser
data
)
{
this
.
_ensureDataHasProperties
(
data
[
"
engineName
"
"
searchString
"
"
healthReportKey
"
"
searchPurpose
"
]
)
;
let
engine
=
Services
.
search
.
getEngineByName
(
data
.
engineName
)
;
let
submission
=
engine
.
getSubmission
(
data
.
searchString
"
"
data
.
searchPurpose
)
;
let
win
=
browser
.
ownerGlobal
;
if
(
!
win
)
{
return
;
}
let
where
=
win
.
whereToOpenLink
(
data
.
originalEvent
)
;
if
(
where
=
=
=
"
current
"
)
{
this
.
_reply
(
actor
"
Blur
"
)
;
browser
.
loadURI
(
submission
.
uri
.
spec
{
postData
:
submission
.
postData
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
createNullPrincipal
(
{
userContextId
:
win
.
gBrowser
.
selectedBrowser
.
getAttribute
(
"
userContextId
"
)
}
)
}
)
;
}
else
{
let
params
=
{
postData
:
submission
.
postData
inBackground
:
Services
.
prefs
.
getBoolPref
(
"
browser
.
tabs
.
loadInBackground
"
)
}
;
win
.
openTrustedLinkIn
(
submission
.
uri
.
spec
where
params
)
;
}
lazy
.
BrowserSearchTelemetry
.
recordSearch
(
browser
engine
data
.
healthReportKey
{
selection
:
data
.
selection
url
:
submission
.
uri
}
)
;
}
async
getSuggestions
(
engineName
searchString
browser
)
{
let
engine
=
Services
.
search
.
getEngineByName
(
engineName
)
;
if
(
!
engine
)
{
throw
new
Error
(
"
Unknown
engine
name
:
"
+
engineName
)
;
}
let
browserData
=
this
.
_suggestionDataForBrowser
(
browser
true
)
;
let
{
controller
}
=
browserData
;
let
ok
=
lazy
.
SearchSuggestionController
.
engineOffersSuggestions
(
engine
)
;
controller
.
maxLocalResults
=
ok
?
MAX_LOCAL_SUGGESTIONS
:
MAX_SUGGESTIONS
;
controller
.
maxRemoteResults
=
ok
?
MAX_SUGGESTIONS
:
0
;
let
priv
=
lazy
.
PrivateBrowsingUtils
.
isBrowserPrivate
(
browser
)
;
this
.
_currentSuggestion
=
{
controller
browser
}
;
let
suggestions
=
await
controller
.
fetch
(
searchString
priv
engine
)
;
suggestions
.
local
=
suggestions
.
local
.
map
(
e
=
>
e
.
value
)
;
let
nonTailEntries
=
suggestions
.
remote
.
filter
(
e
=
>
!
e
.
matchPrefix
&
&
!
e
.
tail
)
;
suggestions
.
remote
=
nonTailEntries
.
map
(
e
=
>
e
.
value
)
;
this
.
_currentSuggestion
=
null
;
let
result
=
{
}
;
if
(
!
suggestions
)
{
return
result
;
}
browserData
.
previousFormHistoryResult
=
suggestions
.
formHistoryResult
;
result
=
{
engineName
term
:
suggestions
.
term
local
:
suggestions
.
local
remote
:
suggestions
.
remote
}
;
return
result
;
}
async
addFormHistoryEntry
(
browser
entry
=
null
)
{
let
isPrivate
=
false
;
try
{
isPrivate
=
lazy
.
PrivateBrowsingUtils
.
isBrowserPrivate
(
browser
)
;
}
catch
(
err
)
{
return
false
;
}
if
(
isPrivate
|
|
!
entry
|
|
entry
.
value
.
length
>
lazy
.
SearchSuggestionController
.
SEARCH_HISTORY_MAX_VALUE_LENGTH
)
{
return
false
;
}
let
browserData
=
this
.
_suggestionDataForBrowser
(
browser
true
)
;
lazy
.
FormHistory
.
update
(
{
op
:
"
bump
"
fieldname
:
browserData
.
controller
.
formHistoryParam
value
:
entry
.
value
source
:
entry
.
engineName
}
{
handleCompletion
:
(
)
=
>
{
}
handleError
:
err
=
>
{
Cu
.
reportError
(
"
Error
adding
form
history
entry
:
"
+
err
)
;
}
}
)
;
return
true
;
}
async
currentStateObj
(
window
)
{
let
state
=
{
engines
:
[
]
currentEngine
:
await
this
.
_currentEngineObj
(
false
)
currentPrivateEngine
:
await
this
.
_currentEngineObj
(
true
)
}
;
let
pref
=
Services
.
prefs
.
getStringPref
(
"
browser
.
search
.
hiddenOneOffs
"
)
;
let
hiddenList
=
pref
?
pref
.
split
(
"
"
)
:
[
]
;
for
(
let
engine
of
await
Services
.
search
.
getVisibleEngines
(
)
)
{
state
.
engines
.
push
(
{
name
:
engine
.
name
iconData
:
await
this
.
_getEngineIconURL
(
engine
)
hidden
:
hiddenList
.
includes
(
engine
.
name
)
isAppProvided
:
engine
.
isAppProvided
}
)
;
}
if
(
window
)
{
state
.
isInPrivateBrowsingMode
=
lazy
.
PrivateBrowsingUtils
.
isContentWindowPrivate
(
window
)
;
state
.
isAboutPrivateBrowsing
=
window
.
gBrowser
.
currentURI
.
spec
=
=
"
about
:
privatebrowsing
"
;
}
return
state
;
}
_processEventQueue
(
)
{
if
(
this
.
_currentEventPromise
|
|
!
this
.
_eventQueue
.
length
)
{
return
;
}
let
event
=
this
.
_eventQueue
.
shift
(
)
;
this
.
_currentEventPromise
=
(
async
(
)
=
>
{
try
{
await
this
[
"
_on
"
+
event
.
type
]
(
event
)
;
}
catch
(
err
)
{
Cu
.
reportError
(
err
)
;
}
finally
{
this
.
_currentEventPromise
=
null
;
this
.
_processEventQueue
(
)
;
}
}
)
(
)
;
}
_cancelSuggestions
(
{
actor
browser
}
)
{
let
cancelled
=
false
;
if
(
this
.
_currentSuggestion
&
&
this
.
_currentSuggestion
.
browser
=
=
=
browser
)
{
this
.
_currentSuggestion
.
controller
.
stop
(
)
;
cancelled
=
true
;
}
for
(
let
i
=
0
;
i
<
this
.
_eventQueue
.
length
;
i
+
+
)
{
let
m
=
this
.
_eventQueue
[
i
]
;
if
(
actor
=
=
=
m
.
actor
&
&
m
.
name
=
=
=
"
GetSuggestions
"
)
{
this
.
_eventQueue
.
splice
(
i
1
)
;
cancelled
=
true
;
i
-
-
;
}
}
if
(
cancelled
)
{
this
.
_reply
(
actor
"
SuggestionsCancelled
"
)
;
}
}
async
_onMessage
(
eventItem
)
{
let
methodName
=
"
_onMessage
"
+
eventItem
.
name
;
if
(
methodName
in
this
)
{
await
this
.
_initService
(
)
;
await
this
[
methodName
]
(
eventItem
)
;
eventItem
.
browser
.
removeEventListener
(
"
SwapDocShells
"
eventItem
true
)
;
}
}
_onMessageGetState
(
{
actor
browser
}
)
{
return
this
.
currentStateObj
(
browser
.
ownerGlobal
)
.
then
(
state
=
>
{
this
.
_reply
(
actor
"
State
"
state
)
;
}
)
;
}
_onMessageGetEngine
(
{
actor
browser
}
)
{
return
this
.
currentStateObj
(
browser
.
ownerGlobal
)
.
then
(
state
=
>
{
this
.
_reply
(
actor
"
Engine
"
{
isPrivateEngine
:
state
.
isInPrivateBrowsingMode
isAboutPrivateBrowsing
:
state
.
isAboutPrivateBrowsing
engine
:
state
.
isInPrivateBrowsingMode
?
state
.
currentPrivateEngine
:
state
.
currentEngine
}
)
;
}
)
;
}
_onMessageGetHandoffSearchModePrefs
(
{
actor
}
)
{
this
.
_reply
(
actor
"
HandoffSearchModePrefs
"
lazy
.
UrlbarPrefs
.
get
(
"
shouldHandOffToSearchMode
"
)
)
;
}
_onMessageGetStrings
(
{
actor
}
)
{
this
.
_reply
(
actor
"
Strings
"
this
.
searchSuggestionUIStrings
)
;
}
_onMessageSearch
(
{
actor
browser
data
}
)
{
this
.
performSearch
(
actor
browser
data
)
;
}
_onMessageSetCurrentEngine
(
{
data
}
)
{
Services
.
search
.
defaultEngine
=
Services
.
search
.
getEngineByName
(
data
)
;
}
_onMessageManageEngines
(
{
browser
}
)
{
browser
.
ownerGlobal
.
openPreferences
(
"
paneSearch
"
)
;
}
async
_onMessageGetSuggestions
(
{
actor
browser
data
}
)
{
this
.
_ensureDataHasProperties
(
data
[
"
engineName
"
"
searchString
"
]
)
;
let
{
engineName
searchString
}
=
data
;
let
suggestions
=
await
this
.
getSuggestions
(
engineName
searchString
browser
)
;
this
.
_reply
(
actor
"
Suggestions
"
{
engineName
:
data
.
engineName
searchString
:
suggestions
.
term
formHistory
:
suggestions
.
local
remote
:
suggestions
.
remote
}
)
;
}
async
_onMessageAddFormHistoryEntry
(
{
browser
data
:
entry
}
)
{
await
this
.
addFormHistoryEntry
(
browser
entry
)
;
}
_onMessageRemoveFormHistoryEntry
(
{
browser
data
:
entry
}
)
{
this
.
removeFormHistoryEntry
(
browser
entry
)
;
}
_onMessageSpeculativeConnect
(
{
browser
data
:
engineName
}
)
{
let
engine
=
Services
.
search
.
getEngineByName
(
engineName
)
;
if
(
!
engine
)
{
throw
new
Error
(
"
Unknown
engine
name
:
"
+
engineName
)
;
}
if
(
browser
.
contentWindow
)
{
engine
.
speculativeConnect
(
{
window
:
browser
.
contentWindow
originAttributes
:
browser
.
contentPrincipal
.
originAttributes
}
)
;
}
}
async
_onObserve
(
eventItem
)
{
let
engine
;
switch
(
eventItem
.
data
)
{
case
"
engine
-
default
"
:
engine
=
await
this
.
_currentEngineObj
(
false
)
;
this
.
_broadcast
(
"
CurrentEngine
"
engine
)
;
break
;
case
"
engine
-
default
-
private
"
:
engine
=
await
this
.
_currentEngineObj
(
true
)
;
this
.
_broadcast
(
"
CurrentPrivateEngine
"
engine
)
;
break
;
case
"
shouldHandOffToSearchMode
"
:
this
.
_broadcast
(
"
HandoffSearchModePrefs
"
lazy
.
UrlbarPrefs
.
get
(
"
shouldHandOffToSearchMode
"
)
)
;
break
;
default
:
let
state
=
await
this
.
currentStateObj
(
)
;
this
.
_broadcast
(
"
CurrentState
"
state
)
;
break
;
}
}
_suggestionDataForBrowser
(
browser
create
=
false
)
{
let
data
=
this
.
_suggestionMap
.
get
(
browser
)
;
if
(
!
data
&
&
create
)
{
data
=
{
controller
:
new
lazy
.
SearchSuggestionController
(
)
}
;
this
.
_suggestionMap
.
set
(
browser
data
)
;
}
return
data
;
}
_reply
(
actor
type
data
)
{
actor
.
sendAsyncMessage
(
type
data
)
;
}
_broadcast
(
type
data
)
{
for
(
let
actor
of
gContentSearchActors
)
{
actor
.
sendAsyncMessage
(
type
data
)
;
}
}
async
_currentEngineObj
(
usePrivate
)
{
let
engine
=
Services
.
search
[
usePrivate
?
"
defaultPrivateEngine
"
:
"
defaultEngine
"
]
;
let
obj
=
{
name
:
engine
.
name
iconData
:
await
this
.
_getEngineIconURL
(
engine
)
isAppProvided
:
engine
.
isAppProvided
}
;
return
obj
;
}
async
_getEngineIconURL
(
engine
)
{
let
url
=
engine
.
getIconURLBySize
(
16
16
)
;
if
(
!
url
)
{
return
SEARCH_ENGINE_PLACEHOLDER_ICON
;
}
if
(
!
url
.
startsWith
(
"
data
:
"
)
)
{
return
url
;
}
return
new
Promise
(
resolve
=
>
{
let
xhr
=
new
XMLHttpRequest
(
)
;
xhr
.
open
(
"
GET
"
url
true
)
;
xhr
.
responseType
=
"
arraybuffer
"
;
xhr
.
onload
=
(
)
=
>
{
resolve
(
xhr
.
response
)
;
}
;
xhr
.
onerror
=
xhr
.
onabort
=
xhr
.
ontimeout
=
(
)
=
>
{
resolve
(
SEARCH_ENGINE_PLACEHOLDER_ICON
)
;
}
;
try
{
xhr
.
send
(
)
;
}
catch
(
err
)
{
resolve
(
SEARCH_ENGINE_PLACEHOLDER_ICON
)
;
}
}
)
;
}
_ensureDataHasProperties
(
data
requiredProperties
)
{
for
(
let
prop
of
requiredProperties
)
{
if
(
!
(
prop
in
data
)
)
{
throw
new
Error
(
"
Message
data
missing
required
property
:
"
+
prop
)
;
}
}
}
_initService
(
)
{
if
(
!
this
.
_initServicePromise
)
{
this
.
_initServicePromise
=
Services
.
search
.
init
(
)
;
}
return
this
.
_initServicePromise
;
}
}
;
class
ContentSearchParent
extends
JSWindowActorParent
{
constructor
(
)
{
super
(
)
;
ContentSearch
.
init
(
)
;
gContentSearchActors
.
add
(
this
)
;
}
didDestroy
(
)
{
gContentSearchActors
.
delete
(
this
)
;
}
receiveMessage
(
msg
)
{
let
browser
=
this
.
browsingContext
.
top
.
embedderElement
;
let
eventItem
=
{
type
:
"
Message
"
name
:
msg
.
name
data
:
msg
.
data
browser
actor
:
this
handleEvent
:
event
=
>
{
let
browserData
=
ContentSearch
.
_suggestionMap
.
get
(
eventItem
.
browser
)
;
if
(
browserData
)
{
ContentSearch
.
_suggestionMap
.
delete
(
eventItem
.
browser
)
;
ContentSearch
.
_suggestionMap
.
set
(
event
.
detail
browserData
)
;
}
browser
.
removeEventListener
(
"
SwapDocShells
"
eventItem
true
)
;
eventItem
.
browser
=
event
.
detail
;
eventItem
.
browser
.
addEventListener
(
"
SwapDocShells
"
eventItem
true
)
;
}
}
;
browser
.
addEventListener
(
"
SwapDocShells
"
eventItem
true
)
;
if
(
msg
.
name
=
=
=
"
Search
"
)
{
ContentSearch
.
_cancelSuggestions
(
eventItem
)
;
}
ContentSearch
.
_eventQueue
.
push
(
eventItem
)
;
ContentSearch
.
_processEventQueue
(
)
;
}
}
