"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
DOMFullscreenParent
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
class
DOMFullscreenParent
extends
JSWindowActorParent
{
waitingForChildEnterFullscreen
=
false
;
waitingForChildExitFullscreen
=
false
;
nextMsgRecipient
=
null
;
updateFullscreenWindowReference
(
aWindow
)
{
if
(
aWindow
.
document
.
documentElement
.
hasAttribute
(
"
inDOMFullscreen
"
)
)
{
this
.
_fullscreenWindow
=
aWindow
;
}
else
{
delete
this
.
_fullscreenWindow
;
}
}
cleanupDomFullscreen
(
aWindow
)
{
if
(
!
aWindow
.
FullScreen
)
{
return
;
}
if
(
!
aWindow
.
FullScreen
.
cleanupDomFullscreen
(
this
)
&
&
!
aWindow
.
document
.
fullscreen
)
{
Services
.
obs
.
notifyObservers
(
aWindow
"
fullscreen
-
painted
"
)
;
}
}
didDestroy
(
)
{
this
.
_didDestroy
=
true
;
let
window
=
this
.
_fullscreenWindow
;
if
(
!
window
)
{
if
(
this
.
waitingForChildExitFullscreen
)
{
this
.
waitingForChildExitFullscreen
=
false
;
let
topBrowsingContext
=
this
.
browsingContext
.
top
;
let
browser
=
topBrowsingContext
.
embedderElement
;
if
(
browser
)
{
this
.
cleanupDomFullscreen
(
browser
.
ownerGlobal
)
;
}
}
return
;
}
if
(
this
.
waitingForChildEnterFullscreen
)
{
this
.
waitingForChildEnterFullscreen
=
false
;
if
(
window
.
document
.
fullscreen
)
{
window
.
document
.
exitFullscreen
(
)
.
catch
(
(
)
=
>
{
}
)
;
return
;
}
this
.
cleanupDomFullscreen
(
window
)
;
}
if
(
window
.
document
.
documentElement
.
hasAttribute
(
"
inDOMFullscreen
"
)
)
{
this
.
cleanupDomFullscreen
(
window
)
;
if
(
window
.
windowUtils
)
{
window
.
windowUtils
.
remoteFrameFullscreenReverted
(
)
;
}
}
else
if
(
this
.
waitingForChildExitFullscreen
)
{
this
.
waitingForChildExitFullscreen
=
false
;
this
.
cleanupDomFullscreen
(
window
)
;
}
this
.
updateFullscreenWindowReference
(
window
)
;
}
receiveMessage
(
aMessage
)
{
let
topBrowsingContext
=
this
.
browsingContext
.
top
;
let
browser
=
topBrowsingContext
.
embedderElement
;
if
(
!
browser
)
{
return
;
}
let
window
=
browser
.
ownerGlobal
;
switch
(
aMessage
.
name
)
{
case
"
DOMFullscreen
:
Request
"
:
{
this
.
waitingForChildExitFullscreen
=
false
;
this
.
nextMsgRecipient
=
null
;
this
.
requestOrigin
=
this
;
this
.
addListeners
(
window
)
;
window
.
windowUtils
.
remoteFrameFullscreenChanged
(
browser
)
;
break
;
}
case
"
DOMFullscreen
:
NewOrigin
"
:
{
if
(
window
.
document
.
fullscreen
)
{
window
.
PointerlockFsWarning
.
showFullScreen
(
aMessage
.
data
.
originNoSuffix
)
;
}
this
.
updateFullscreenWindowReference
(
window
)
;
break
;
}
case
"
DOMFullscreen
:
Entered
"
:
{
this
.
nextMsgRecipient
=
null
;
this
.
waitingForChildEnterFullscreen
=
false
;
window
.
FullScreen
.
enterDomFullscreen
(
browser
this
)
;
this
.
updateFullscreenWindowReference
(
window
)
;
break
;
}
case
"
DOMFullscreen
:
Exit
"
:
{
this
.
waitingForChildEnterFullscreen
=
false
;
window
.
windowUtils
.
remoteFrameFullscreenReverted
(
)
;
break
;
}
case
"
DOMFullscreen
:
Exited
"
:
{
this
.
waitingForChildExitFullscreen
=
false
;
this
.
cleanupDomFullscreen
(
window
)
;
this
.
updateFullscreenWindowReference
(
window
)
;
break
;
}
case
"
DOMFullscreen
:
Painted
"
:
{
this
.
waitingForChildExitFullscreen
=
false
;
Services
.
obs
.
notifyObservers
(
window
"
fullscreen
-
painted
"
)
;
this
.
sendAsyncMessage
(
"
DOMFullscreen
:
Painted
"
{
}
)
;
TelemetryStopwatch
.
finish
(
"
FULLSCREEN_CHANGE_MS
"
)
;
break
;
}
}
}
handleEvent
(
aEvent
)
{
let
window
=
aEvent
.
currentTarget
.
ownerGlobal
;
switch
(
aEvent
.
type
)
{
case
"
MozDOMFullscreen
:
Entered
"
:
{
let
browser
;
if
(
aEvent
.
target
.
ownerGlobal
=
=
window
)
{
browser
=
aEvent
.
target
;
}
else
{
browser
=
aEvent
.
target
.
ownerGlobal
.
docShell
.
chromeEventHandler
;
}
if
(
window
.
gXPInstallObserver
)
{
window
.
gXPInstallObserver
.
removeAllNotifications
(
browser
)
;
}
TelemetryStopwatch
.
start
(
"
FULLSCREEN_CHANGE_MS
"
)
;
window
.
FullScreen
.
enterDomFullscreen
(
browser
this
)
;
this
.
updateFullscreenWindowReference
(
window
)
;
break
;
}
case
"
MozDOMFullscreen
:
Exited
"
:
{
TelemetryStopwatch
.
start
(
"
FULLSCREEN_CHANGE_MS
"
)
;
if
(
!
this
.
hasBeenDestroyed
(
)
&
&
!
this
.
requestOrigin
)
{
this
.
requestOrigin
=
this
;
}
this
.
cleanupDomFullscreen
(
window
)
;
this
.
updateFullscreenWindowReference
(
window
)
;
this
.
removeListeners
(
window
)
;
break
;
}
}
}
addListeners
(
aWindow
)
{
aWindow
.
addEventListener
(
"
MozDOMFullscreen
:
Entered
"
this
true
false
)
;
aWindow
.
addEventListener
(
"
MozDOMFullscreen
:
Exited
"
this
true
false
)
;
}
removeListeners
(
aWindow
)
{
aWindow
.
removeEventListener
(
"
MozDOMFullscreen
:
Entered
"
this
true
)
;
aWindow
.
removeEventListener
(
"
MozDOMFullscreen
:
Exited
"
this
true
)
;
}
get
requestOrigin
(
)
{
let
requestOrigin
=
this
.
browsingContext
.
top
.
fullscreenRequestOrigin
;
return
requestOrigin
&
&
requestOrigin
.
get
(
)
;
}
set
requestOrigin
(
aActor
)
{
if
(
aActor
)
{
this
.
browsingContext
.
top
.
fullscreenRequestOrigin
=
Cu
.
getWeakReference
(
aActor
)
;
}
else
{
delete
this
.
browsingContext
.
top
.
fullscreenRequestOrigin
;
}
}
hasBeenDestroyed
(
)
{
if
(
this
.
_didDestroy
)
{
return
true
;
}
try
{
return
!
this
.
browsingContext
;
}
catch
{
return
true
;
}
}
}
