"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
AboutTabCrashedParent
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
SessionStore
:
"
resource
:
/
/
/
modules
/
sessionstore
/
SessionStore
.
jsm
"
TabCrashHandler
:
"
resource
:
/
/
/
modules
/
ContentCrashHandlers
.
jsm
"
}
)
;
let
gAboutTabCrashedPages
=
new
Map
(
)
;
class
AboutTabCrashedParent
extends
JSWindowActorParent
{
didDestroy
(
)
{
this
.
removeCrashedPage
(
)
;
}
async
receiveMessage
(
message
)
{
let
browser
=
this
.
browsingContext
.
top
.
embedderElement
;
if
(
!
browser
)
{
this
.
removeCrashedPage
(
)
;
return
;
}
let
gBrowser
=
browser
.
getTabBrowser
(
)
;
let
tab
=
gBrowser
.
getTabForBrowser
(
browser
)
;
switch
(
message
.
name
)
{
case
"
Load
"
:
{
gAboutTabCrashedPages
.
set
(
this
browser
)
;
this
.
updateTabCrashedCount
(
)
;
let
report
=
TabCrashHandler
.
onAboutTabCrashedLoad
(
browser
)
;
this
.
sendAsyncMessage
(
"
SetCrashReportAvailable
"
report
)
;
break
;
}
case
"
closeTab
"
:
{
TabCrashHandler
.
maybeSendCrashReport
(
browser
message
)
;
gBrowser
.
removeTab
(
tab
{
animate
:
true
}
)
;
break
;
}
case
"
restoreTab
"
:
{
TabCrashHandler
.
maybeSendCrashReport
(
browser
message
)
;
SessionStore
.
reviveCrashedTab
(
tab
)
;
break
;
}
case
"
restoreAll
"
:
{
TabCrashHandler
.
maybeSendCrashReport
(
browser
message
)
;
SessionStore
.
reviveAllCrashedTabs
(
)
;
break
;
}
}
}
removeCrashedPage
(
)
{
let
browser
=
this
.
browsingContext
.
top
.
embedderElement
|
|
gAboutTabCrashedPages
.
get
(
this
)
;
gAboutTabCrashedPages
.
delete
(
this
)
;
this
.
updateTabCrashedCount
(
)
;
TabCrashHandler
.
onAboutTabCrashedUnload
(
browser
)
;
}
updateTabCrashedCount
(
)
{
let
count
=
gAboutTabCrashedPages
.
size
;
for
(
let
actor
of
gAboutTabCrashedPages
.
keys
(
)
)
{
let
browser
=
actor
.
browsingContext
.
top
.
embedderElement
;
if
(
browser
)
{
browser
.
sendMessageToActor
(
"
UpdateCount
"
{
count
}
"
AboutTabCrashed
"
)
;
}
}
}
}
