"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
AboutReaderChild
"
]
;
const
{
ActorChild
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ActorChild
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
AboutReader
"
"
resource
:
/
/
gre
/
modules
/
AboutReader
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ReaderMode
"
"
resource
:
/
/
gre
/
modules
/
ReaderMode
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Readerable
"
"
resource
:
/
/
gre
/
modules
/
Readerable
.
jsm
"
)
;
class
AboutReaderChild
extends
ActorChild
{
constructor
(
dispatcher
)
{
super
(
dispatcher
)
;
this
.
_articlePromise
=
null
;
this
.
_isLeavingReaderableReaderMode
=
false
;
}
receiveMessage
(
message
)
{
switch
(
message
.
name
)
{
case
"
Reader
:
ToggleReaderMode
"
:
if
(
!
this
.
isAboutReader
)
{
this
.
_articlePromise
=
ReaderMode
.
parseDocument
(
this
.
content
.
document
)
.
catch
(
Cu
.
reportError
)
;
ReaderMode
.
enterReaderMode
(
this
.
mm
.
docShell
this
.
content
)
;
}
else
{
this
.
_isLeavingReaderableReaderMode
=
this
.
isReaderableAboutReader
;
ReaderMode
.
leaveReaderMode
(
this
.
mm
.
docShell
this
.
content
)
;
}
break
;
case
"
Reader
:
PushState
"
:
this
.
updateReaderButton
(
!
!
(
message
.
data
&
&
message
.
data
.
isArticle
)
)
;
break
;
}
}
get
isAboutReader
(
)
{
if
(
!
this
.
content
)
{
return
false
;
}
return
this
.
content
.
document
.
documentURI
.
startsWith
(
"
about
:
reader
"
)
;
}
get
isReaderableAboutReader
(
)
{
return
this
.
isAboutReader
&
&
!
this
.
content
.
document
.
documentElement
.
dataset
.
isError
;
}
handleEvent
(
aEvent
)
{
if
(
aEvent
.
originalTarget
.
defaultView
!
=
this
.
content
)
{
return
;
}
switch
(
aEvent
.
type
)
{
case
"
AboutReaderContentLoaded
"
:
if
(
!
this
.
isAboutReader
)
{
return
;
}
if
(
this
.
content
.
document
.
body
)
{
this
.
mm
.
sendAsyncMessage
(
"
Reader
:
UpdateReaderButton
"
)
;
new
AboutReader
(
this
.
mm
this
.
content
this
.
_articlePromise
)
;
this
.
_articlePromise
=
null
;
}
break
;
case
"
pagehide
"
:
this
.
cancelPotentialPendingReadabilityCheck
(
)
;
this
.
mm
.
sendAsyncMessage
(
"
Reader
:
UpdateReaderButton
"
{
isArticle
:
this
.
_isLeavingReaderableReaderMode
}
)
;
if
(
this
.
_isLeavingReaderableReaderMode
)
{
this
.
_isLeavingReaderableReaderMode
=
false
;
}
break
;
case
"
pageshow
"
:
if
(
aEvent
.
persisted
)
{
this
.
updateReaderButton
(
)
;
}
break
;
case
"
DOMContentLoaded
"
:
this
.
updateReaderButton
(
)
;
break
;
}
}
updateReaderButton
(
forceNonArticle
)
{
if
(
!
Readerable
.
isEnabledForParseOnLoad
|
|
this
.
isAboutReader
|
|
!
this
.
content
|
|
!
(
this
.
content
.
document
instanceof
this
.
content
.
HTMLDocument
)
|
|
this
.
content
.
document
.
mozSyntheticDocument
)
{
return
;
}
this
.
scheduleReadabilityCheckPostPaint
(
forceNonArticle
)
;
}
cancelPotentialPendingReadabilityCheck
(
)
{
if
(
this
.
_pendingReadabilityCheck
)
{
this
.
mm
.
removeEventListener
(
"
MozAfterPaint
"
this
.
_pendingReadabilityCheck
)
;
delete
this
.
_pendingReadabilityCheck
;
}
}
scheduleReadabilityCheckPostPaint
(
forceNonArticle
)
{
if
(
this
.
_pendingReadabilityCheck
)
{
this
.
cancelPotentialPendingReadabilityCheck
(
)
;
}
this
.
_pendingReadabilityCheck
=
this
.
onPaintWhenWaitedFor
.
bind
(
this
forceNonArticle
)
;
this
.
mm
.
addEventListener
(
"
MozAfterPaint
"
this
.
_pendingReadabilityCheck
)
;
}
onPaintWhenWaitedFor
(
forceNonArticle
event
)
{
if
(
!
event
.
clientRects
.
length
)
{
return
;
}
this
.
cancelPotentialPendingReadabilityCheck
(
)
;
if
(
Readerable
.
isProbablyReaderable
(
this
.
content
.
document
)
)
{
this
.
mm
.
sendAsyncMessage
(
"
Reader
:
UpdateReaderButton
"
{
isArticle
:
true
}
)
;
}
else
if
(
forceNonArticle
)
{
this
.
mm
.
sendAsyncMessage
(
"
Reader
:
UpdateReaderButton
"
{
isArticle
:
false
}
)
;
}
}
}
