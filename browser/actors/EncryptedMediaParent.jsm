"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
EncryptedMediaParent
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
BrowserUIUtils
"
"
resource
:
/
/
/
modules
/
BrowserUIUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gBrandBundle
"
function
(
)
{
return
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
branding
/
locale
/
brand
.
properties
"
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gNavigatorBundle
"
function
(
)
{
return
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
browser
/
locale
/
browser
.
properties
"
)
;
}
)
;
class
EncryptedMediaParent
extends
JSWindowActorParent
{
isUiEnabled
(
)
{
return
Services
.
prefs
.
getBoolPref
(
"
browser
.
eme
.
ui
.
enabled
"
)
;
}
ensureEMEEnabled
(
aBrowser
aKeySystem
)
{
Services
.
prefs
.
setBoolPref
(
"
media
.
eme
.
enabled
"
true
)
;
if
(
aKeySystem
&
&
aKeySystem
=
=
"
com
.
widevine
.
alpha
"
&
&
Services
.
prefs
.
getPrefType
(
"
media
.
gmp
-
widevinecdm
.
enabled
"
)
&
&
!
Services
.
prefs
.
getBoolPref
(
"
media
.
gmp
-
widevinecdm
.
enabled
"
)
)
{
Services
.
prefs
.
setBoolPref
(
"
media
.
gmp
-
widevinecdm
.
enabled
"
true
)
;
}
aBrowser
.
reload
(
)
;
}
isKeySystemVisible
(
aKeySystem
)
{
if
(
!
aKeySystem
)
{
return
false
;
}
if
(
aKeySystem
=
=
"
com
.
widevine
.
alpha
"
&
&
Services
.
prefs
.
getPrefType
(
"
media
.
gmp
-
widevinecdm
.
visible
"
)
)
{
return
Services
.
prefs
.
getBoolPref
(
"
media
.
gmp
-
widevinecdm
.
visible
"
)
;
}
return
true
;
}
getEMEDisabledFragment
(
aBrowser
)
{
let
mainMessage
=
gNavigatorBundle
.
GetStringFromName
(
"
emeNotifications
.
drmContentDisabled
.
message
"
)
;
let
text
=
gNavigatorBundle
.
GetStringFromName
(
"
emeNotifications
.
drmContentDisabled
.
learnMoreLabel
"
)
;
let
document
=
aBrowser
.
ownerDocument
;
let
baseURL
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
;
let
link
=
document
.
createXULElement
(
"
label
"
{
is
:
"
text
-
link
"
}
)
;
link
.
setAttribute
(
"
href
"
baseURL
+
"
drm
-
content
"
)
;
link
.
textContent
=
text
;
return
BrowserUIUtils
.
getLocalizedFragment
(
document
mainMessage
link
)
;
}
getMessageWithBrandName
(
aNotificationId
)
{
let
msgId
=
"
emeNotifications
.
"
+
aNotificationId
+
"
.
message
"
;
return
gNavigatorBundle
.
formatStringFromName
(
msgId
[
gBrandBundle
.
GetStringFromName
(
"
brandShortName
"
)
]
)
;
}
receiveMessage
(
aMessage
)
{
let
browser
=
this
.
browsingContext
.
top
.
embedderElement
;
if
(
!
browser
)
{
return
;
}
let
parsedData
;
try
{
parsedData
=
JSON
.
parse
(
aMessage
.
data
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
"
Malformed
EME
video
message
with
data
:
"
+
aMessage
.
data
)
;
return
;
}
let
{
status
keySystem
}
=
parsedData
;
if
(
!
this
.
isKeySystemVisible
(
keySystem
)
)
{
return
;
}
if
(
status
=
=
"
cdm
-
not
-
installed
"
)
{
Services
.
obs
.
notifyObservers
(
browser
"
EMEVideo
:
CDMMissing
"
)
;
}
if
(
!
this
.
isUiEnabled
(
)
)
{
return
;
}
let
notificationId
;
let
buttonCallback
;
let
notificationMessage
;
switch
(
status
)
{
case
"
available
"
:
case
"
cdm
-
created
"
:
if
(
keySystem
!
=
"
org
.
w3
.
clearkey
"
)
{
this
.
showPopupNotificationForSuccess
(
browser
keySystem
)
;
}
return
;
case
"
api
-
disabled
"
:
case
"
cdm
-
disabled
"
:
notificationId
=
"
drmContentDisabled
"
;
buttonCallback
=
(
)
=
>
{
this
.
ensureEMEEnabled
(
browser
keySystem
)
;
}
;
notificationMessage
=
this
.
getEMEDisabledFragment
(
browser
)
;
break
;
case
"
cdm
-
not
-
installed
"
:
notificationId
=
"
drmContentCDMInstalling
"
;
notificationMessage
=
this
.
getMessageWithBrandName
(
notificationId
)
;
break
;
case
"
cdm
-
not
-
supported
"
:
return
;
default
:
Cu
.
reportError
(
new
Error
(
"
Unknown
message
(
'
"
+
status
+
"
'
)
dealing
with
EME
key
request
:
"
+
aMessage
.
data
)
)
;
return
;
}
let
notificationBox
=
browser
.
getTabBrowser
(
)
.
getNotificationBox
(
browser
)
;
if
(
notificationBox
.
getNotificationWithValue
(
notificationId
)
)
{
return
;
}
let
buttons
=
[
]
;
if
(
buttonCallback
)
{
let
msgPrefix
=
"
emeNotifications
.
"
+
notificationId
+
"
.
"
;
let
btnLabelId
=
msgPrefix
+
"
button
.
label
"
;
let
btnAccessKeyId
=
msgPrefix
+
"
button
.
accesskey
"
;
buttons
.
push
(
{
label
:
gNavigatorBundle
.
GetStringFromName
(
btnLabelId
)
accessKey
:
gNavigatorBundle
.
GetStringFromName
(
btnAccessKeyId
)
callback
:
buttonCallback
}
)
;
}
let
iconURL
=
"
chrome
:
/
/
browser
/
skin
/
drm
-
icon
.
svg
"
;
notificationBox
.
appendNotification
(
notificationMessage
notificationId
iconURL
notificationBox
.
PRIORITY_INFO_HIGH
buttons
)
;
}
showPopupNotificationForSuccess
(
aBrowser
)
{
let
notificationBox
=
aBrowser
.
getTabBrowser
(
)
.
getNotificationBox
(
aBrowser
)
;
[
"
drmContentDisabled
"
"
drmContentCDMInstalling
"
]
.
forEach
(
function
(
value
)
{
let
notification
=
notificationBox
.
getNotificationWithValue
(
value
)
;
if
(
notification
)
{
notificationBox
.
removeNotification
(
notification
)
;
}
}
)
;
if
(
aBrowser
.
ownerGlobal
.
PopupNotifications
.
getNotification
(
"
drmContentPlaying
"
aBrowser
)
)
{
return
;
}
let
msgPrefix
=
"
emeNotifications
.
drmContentPlaying
.
"
;
let
msgId
=
msgPrefix
+
"
message2
"
;
let
btnLabelId
=
msgPrefix
+
"
button
.
label
"
;
let
btnAccessKeyId
=
msgPrefix
+
"
button
.
accesskey
"
;
let
message
=
gNavigatorBundle
.
formatStringFromName
(
msgId
[
gBrandBundle
.
GetStringFromName
(
"
brandShortName
"
)
]
)
;
let
anchorId
=
"
eme
-
notification
-
icon
"
;
let
firstPlayPref
=
"
browser
.
eme
.
ui
.
firstContentShown
"
;
let
document
=
aBrowser
.
ownerDocument
;
if
(
!
Services
.
prefs
.
getPrefType
(
firstPlayPref
)
|
|
!
Services
.
prefs
.
getBoolPref
(
firstPlayPref
)
)
{
document
.
getElementById
(
anchorId
)
.
setAttribute
(
"
firstplay
"
"
true
"
)
;
Services
.
prefs
.
setBoolPref
(
firstPlayPref
true
)
;
}
else
{
document
.
getElementById
(
anchorId
)
.
removeAttribute
(
"
firstplay
"
)
;
}
let
mainAction
=
{
label
:
gNavigatorBundle
.
GetStringFromName
(
btnLabelId
)
accessKey
:
gNavigatorBundle
.
GetStringFromName
(
btnAccessKeyId
)
callback
(
)
{
aBrowser
.
ownerGlobal
.
openPreferences
(
"
general
-
drm
"
)
;
}
dismiss
:
true
}
;
let
options
=
{
dismissed
:
true
eventCallback
:
aTopic
=
>
aTopic
=
=
"
swapping
"
learnMoreURL
:
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
+
"
drm
-
content
"
}
;
aBrowser
.
ownerGlobal
.
PopupNotifications
.
show
(
aBrowser
"
drmContentPlaying
"
message
anchorId
mainAction
null
options
)
;
}
}
