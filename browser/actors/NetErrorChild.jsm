var
EXPORTED_SYMBOLS
=
[
"
NetErrorChild
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
ActorChild
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ActorChild
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
BrowserUtils
"
"
resource
:
/
/
gre
/
modules
/
BrowserUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
WebNavigationFrames
"
"
resource
:
/
/
gre
/
modules
/
WebNavigationFrames
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
URL
"
]
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
URL
"
]
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gPipNSSBundle
"
function
(
)
{
return
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
pipnss
/
locale
/
pipnss
.
properties
"
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gBrandBundle
"
function
(
)
{
return
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
branding
/
locale
/
brand
.
properties
"
)
;
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
newErrorPagesEnabled
"
"
browser
.
security
.
newcerterrorpage
.
enabled
"
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
mitmErrorPageEnabled
"
"
browser
.
security
.
newcerterrorpage
.
mitm
.
enabled
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gNSSErrorsBundle
"
function
(
)
{
return
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
pipnss
/
locale
/
nsserrors
.
properties
"
)
;
}
)
;
const
SEC_ERROR_BASE
=
Ci
.
nsINSSErrorsService
.
NSS_SEC_ERROR_BASE
;
const
MOZILLA_PKIX_ERROR_BASE
=
Ci
.
nsINSSErrorsService
.
MOZILLA_PKIX_ERROR_BASE
;
const
SEC_ERROR_EXPIRED_CERTIFICATE
=
SEC_ERROR_BASE
+
11
;
const
SEC_ERROR_UNKNOWN_ISSUER
=
SEC_ERROR_BASE
+
13
;
const
SEC_ERROR_UNTRUSTED_ISSUER
=
SEC_ERROR_BASE
+
20
;
const
SEC_ERROR_EXPIRED_ISSUER_CERTIFICATE
=
SEC_ERROR_BASE
+
30
;
const
SEC_ERROR_CA_CERT_INVALID
=
SEC_ERROR_BASE
+
36
;
const
SEC_ERROR_REUSED_ISSUER_AND_SERIAL
=
SEC_ERROR_BASE
+
138
;
const
SEC_ERROR_OCSP_INVALID_SIGNING_CERT
=
SEC_ERROR_BASE
+
144
;
const
SEC_ERROR_CERT_SIGNATURE_ALGORITHM_DISABLED
=
SEC_ERROR_BASE
+
176
;
const
MOZILLA_PKIX_ERROR_NOT_YET_VALID_CERTIFICATE
=
MOZILLA_PKIX_ERROR_BASE
+
5
;
const
MOZILLA_PKIX_ERROR_NOT_YET_VALID_ISSUER_CERTIFICATE
=
MOZILLA_PKIX_ERROR_BASE
+
6
;
const
MOZILLA_PKIX_ERROR_ADDITIONAL_POLICY_CONSTRAINT_FAILED
=
MOZILLA_PKIX_ERROR_BASE
+
13
;
const
MOZILLA_PKIX_ERROR_SELF_SIGNED_CERT
=
MOZILLA_PKIX_ERROR_BASE
+
14
;
const
MOZILLA_PKIX_ERROR_MITM_DETECTED
=
MOZILLA_PKIX_ERROR_BASE
+
15
;
const
SSL_ERROR_BASE
=
Ci
.
nsINSSErrorsService
.
NSS_SSL_ERROR_BASE
;
const
SSL_ERROR_BAD_CERT_DOMAIN
=
SSL_ERROR_BASE
+
12
;
const
SSL_ERROR_SSL_DISABLED
=
SSL_ERROR_BASE
+
20
;
const
SSL_ERROR_SSL2_DISABLED
=
SSL_ERROR_BASE
+
14
;
const
PREF_SERVICES_SETTINGS_CLOCK_SKEW_SECONDS
=
"
services
.
settings
.
clock_skew_seconds
"
;
const
PREF_SERVICES_SETTINGS_LAST_FETCHED
=
"
services
.
settings
.
last_update_seconds
"
;
const
PREF_SSL_IMPACT_ROOTS
=
[
"
security
.
tls
.
version
.
"
"
security
.
ssl3
.
"
]
;
function
getSerializedSecurityInfo
(
docShell
)
{
let
serhelper
=
Cc
[
"
mozilla
.
org
/
network
/
serialization
-
helper
;
1
"
]
.
getService
(
Ci
.
nsISerializationHelper
)
;
let
securityInfo
=
docShell
.
failedChannel
&
&
docShell
.
failedChannel
.
securityInfo
;
if
(
!
securityInfo
)
{
return
"
"
;
}
securityInfo
.
QueryInterface
(
Ci
.
nsITransportSecurityInfo
)
.
QueryInterface
(
Ci
.
nsISerializable
)
;
return
serhelper
.
serializeToString
(
securityInfo
)
;
}
class
NetErrorChild
extends
ActorChild
{
isAboutNetError
(
doc
)
{
return
doc
.
documentURI
.
startsWith
(
"
about
:
neterror
"
)
;
}
isAboutCertError
(
doc
)
{
return
doc
.
documentURI
.
startsWith
(
"
about
:
certerror
"
)
;
}
getParams
(
doc
)
{
let
searchParams
=
new
URL
(
doc
.
documentURI
)
.
searchParams
;
return
{
cssClass
:
searchParams
.
get
(
"
s
"
)
error
:
searchParams
.
get
(
"
e
"
)
}
;
}
_getCertValidityRange
(
docShell
)
{
let
{
securityInfo
}
=
docShell
.
failedChannel
;
securityInfo
.
QueryInterface
(
Ci
.
nsITransportSecurityInfo
)
;
let
notBefore
=
0
;
let
notAfter
=
Number
.
MAX_SAFE_INTEGER
;
for
(
let
cert
of
securityInfo
.
failedCertChain
.
getEnumerator
(
)
)
{
notBefore
=
Math
.
max
(
notBefore
cert
.
validity
.
notBefore
)
;
notAfter
=
Math
.
min
(
notAfter
cert
.
validity
.
notAfter
)
;
}
notBefore
/
=
1000
;
notAfter
/
=
1000
;
return
{
notBefore
notAfter
}
;
}
_setTechDetails
(
input
doc
)
{
let
{
cssClass
error
}
=
this
.
getParams
(
doc
)
;
let
technicalInfo
=
doc
.
getElementById
(
"
badCertTechnicalInfo
"
)
;
technicalInfo
.
textContent
=
"
"
;
let
uri
=
Services
.
io
.
newURI
(
input
.
data
.
url
)
;
let
hostString
=
uri
.
host
;
if
(
uri
.
port
!
=
443
&
&
uri
.
port
!
=
-
1
)
{
hostString
=
uri
.
hostPort
;
}
let
msg1
=
gPipNSSBundle
.
formatStringFromName
(
"
certErrorIntro
"
[
hostString
]
1
)
;
msg1
+
=
"
\
n
\
n
"
;
if
(
input
.
data
.
certIsUntrusted
)
{
switch
(
input
.
data
.
code
)
{
case
MOZILLA_PKIX_ERROR_MITM_DETECTED
:
if
(
newErrorPagesEnabled
&
&
mitmErrorPageEnabled
)
{
let
brandName
=
gBrandBundle
.
GetStringFromName
(
"
brandShortName
"
)
;
msg1
=
gPipNSSBundle
.
GetStringFromName
(
"
certErrorMitM
"
)
;
msg1
+
=
"
\
n
\
n
"
;
msg1
+
=
gPipNSSBundle
.
formatStringFromName
(
"
certErrorMitM2
"
[
brandName
]
1
)
;
msg1
+
=
"
\
n
\
n
"
;
msg1
+
=
gPipNSSBundle
.
formatStringFromName
(
"
certErrorMitM3
"
[
brandName
]
1
)
;
msg1
+
=
"
\
n
"
;
break
;
}
case
SEC_ERROR_UNKNOWN_ISSUER
:
let
brandName
=
gBrandBundle
.
GetStringFromName
(
"
brandShortName
"
)
;
if
(
newErrorPagesEnabled
)
{
msg1
=
"
"
;
msg1
+
=
gPipNSSBundle
.
formatStringFromName
(
"
certErrorTrust_UnknownIssuer4
"
[
hostString
]
1
)
;
msg1
+
=
"
\
n
\
n
"
;
msg1
+
=
gPipNSSBundle
.
formatStringFromName
(
"
certErrorTrust_UnknownIssuer6
"
[
brandName
hostString
]
2
)
;
msg1
+
=
"
\
n
\
n
"
;
}
else
{
msg1
+
=
gPipNSSBundle
.
GetStringFromName
(
"
certErrorTrust_UnknownIssuer
"
)
+
"
\
n
"
;
msg1
+
=
gPipNSSBundle
.
GetStringFromName
(
"
certErrorTrust_UnknownIssuer2
"
)
+
"
\
n
"
;
msg1
+
=
gPipNSSBundle
.
GetStringFromName
(
"
certErrorTrust_UnknownIssuer3
"
)
+
"
\
n
"
;
}
break
;
case
SEC_ERROR_CA_CERT_INVALID
:
msg1
+
=
gPipNSSBundle
.
GetStringFromName
(
"
certErrorTrust_CaInvalid
"
)
+
"
\
n
"
;
break
;
case
SEC_ERROR_UNTRUSTED_ISSUER
:
msg1
+
=
gPipNSSBundle
.
GetStringFromName
(
"
certErrorTrust_Issuer
"
)
+
"
\
n
"
;
break
;
case
SEC_ERROR_CERT_SIGNATURE_ALGORITHM_DISABLED
:
msg1
+
=
gPipNSSBundle
.
GetStringFromName
(
"
certErrorTrust_SignatureAlgorithmDisabled
"
)
+
"
\
n
"
;
break
;
case
SEC_ERROR_EXPIRED_ISSUER_CERTIFICATE
:
msg1
+
=
gPipNSSBundle
.
GetStringFromName
(
"
certErrorTrust_ExpiredIssuer
"
)
+
"
\
n
"
;
break
;
case
MOZILLA_PKIX_ERROR_SELF_SIGNED_CERT
:
msg1
+
=
gPipNSSBundle
.
GetStringFromName
(
"
certErrorTrust_SelfSigned
"
)
+
"
\
n
"
;
break
;
case
MOZILLA_PKIX_ERROR_ADDITIONAL_POLICY_CONSTRAINT_FAILED
:
msg1
+
=
gPipNSSBundle
.
GetStringFromName
(
"
certErrorTrust_Symantec1
"
)
+
"
\
n
"
;
break
;
default
:
msg1
+
=
gPipNSSBundle
.
GetStringFromName
(
"
certErrorTrust_Untrusted
"
)
+
"
\
n
"
;
}
}
technicalInfo
.
appendChild
(
doc
.
createTextNode
(
msg1
)
)
;
if
(
input
.
data
.
isDomainMismatch
)
{
let
subjectAltNames
=
input
.
data
.
certSubjectAltNames
.
split
(
"
"
)
;
let
numSubjectAltNames
=
subjectAltNames
.
length
;
let
msgPrefix
=
"
"
;
if
(
numSubjectAltNames
!
=
0
)
{
if
(
numSubjectAltNames
=
=
1
)
{
if
(
newErrorPagesEnabled
)
{
technicalInfo
.
textContent
=
"
"
;
let
brandName
=
gBrandBundle
.
GetStringFromName
(
"
brandShortName
"
)
;
msgPrefix
=
gPipNSSBundle
.
formatStringFromName
(
"
certErrorMismatchSinglePrefix3
"
[
brandName
hostString
]
2
)
+
"
"
;
msgPrefix
+
=
gPipNSSBundle
.
GetStringFromName
(
"
certErrorMismatchSinglePrefix
"
)
;
}
else
{
msgPrefix
=
gPipNSSBundle
.
GetStringFromName
(
"
certErrorMismatchSinglePrefix
"
)
;
}
let
okHost
=
input
.
data
.
certSubjectAltNames
;
let
href
=
"
"
;
let
thisHost
=
doc
.
location
.
hostname
;
let
proto
=
doc
.
location
.
protocol
+
"
/
/
"
;
okHost
=
okHost
.
replace
(
/
^
\
*
\
.
/
"
www
.
"
)
;
if
(
okHost
.
endsWith
(
"
.
"
+
thisHost
)
)
{
href
=
proto
+
okHost
;
}
if
(
thisHost
.
endsWith
(
"
.
"
+
okHost
)
)
{
href
=
proto
+
okHost
;
}
if
(
href
&
&
cssClass
!
=
"
expertBadCert
"
)
{
doc
.
getElementById
(
"
badCertAdvancedPanel
"
)
.
style
.
display
=
"
block
"
;
if
(
error
=
=
"
nssBadCert
"
)
{
var
div
=
doc
.
getElementById
(
"
certificateErrorDebugInformation
"
)
;
div
.
style
.
display
=
"
none
"
;
}
}
if
(
href
)
{
let
referrerlink
=
doc
.
createElement
(
"
a
"
)
;
referrerlink
.
append
(
input
.
data
.
certSubjectAltNames
)
;
referrerlink
.
title
=
input
.
data
.
certSubjectAltNames
;
referrerlink
.
id
=
"
cert_domain_link
"
;
referrerlink
.
href
=
href
;
let
fragment
=
BrowserUtils
.
getLocalizedFragment
(
doc
msgPrefix
referrerlink
)
;
technicalInfo
.
appendChild
(
fragment
)
;
}
else
{
let
fragment
=
BrowserUtils
.
getLocalizedFragment
(
doc
msgPrefix
input
.
data
.
certSubjectAltNames
)
;
technicalInfo
.
appendChild
(
fragment
)
;
}
technicalInfo
.
append
(
"
\
n
"
)
;
}
else
{
let
msg
=
"
"
;
if
(
newErrorPagesEnabled
)
{
technicalInfo
.
textContent
=
"
"
;
let
brandName
=
gBrandBundle
.
GetStringFromName
(
"
brandShortName
"
)
;
msg
=
gPipNSSBundle
.
formatStringFromName
(
"
certErrorMismatchMultiple3
"
[
brandName
hostString
]
2
)
+
"
"
;
}
else
{
msg
=
gPipNSSBundle
.
GetStringFromName
(
"
certErrorMismatchMultiple
"
)
+
"
\
n
"
;
}
for
(
let
i
=
0
;
i
<
numSubjectAltNames
;
i
+
+
)
{
msg
+
=
subjectAltNames
[
i
]
;
if
(
i
!
=
(
numSubjectAltNames
-
1
)
)
{
msg
+
=
"
"
;
}
}
technicalInfo
.
append
(
msg
+
"
\
n
"
)
;
}
}
else
{
let
msg
=
"
"
;
if
(
newErrorPagesEnabled
)
{
technicalInfo
.
textContent
=
"
"
;
let
brandName
=
gBrandBundle
.
GetStringFromName
(
"
brandShortName
"
)
;
msg
=
gPipNSSBundle
.
formatStringFromName
(
"
certErrorMismatch3
"
[
brandName
hostString
]
2
)
+
"
"
;
}
else
{
msg
=
gPipNSSBundle
.
formatStringFromName
(
"
certErrorMismatch
"
[
hostString
]
1
)
;
}
technicalInfo
.
append
(
msg
+
"
\
n
"
)
;
}
}
if
(
input
.
data
.
isNotValidAtThisTime
)
{
let
nowTime
=
new
Date
(
)
.
getTime
(
)
*
1000
;
let
dateOptions
=
{
year
:
"
numeric
"
month
:
"
long
"
day
:
"
numeric
"
hour
:
"
numeric
"
minute
:
"
numeric
"
}
;
let
now
=
new
Services
.
intl
.
DateTimeFormat
(
undefined
dateOptions
)
.
format
(
new
Date
(
)
)
;
let
msg
=
"
"
;
if
(
input
.
data
.
validity
.
notBefore
)
{
if
(
nowTime
>
input
.
data
.
validity
.
notAfter
)
{
if
(
newErrorPagesEnabled
)
{
technicalInfo
.
textContent
=
"
"
;
msg
+
=
gPipNSSBundle
.
formatStringFromName
(
"
certErrorExpiredNow2
"
[
hostString
]
1
)
;
msg
+
=
"
\
n
"
;
}
else
{
msg
+
=
gPipNSSBundle
.
formatStringFromName
(
"
certErrorExpiredNow
"
[
input
.
data
.
validity
.
notAfterLocalTime
now
]
2
)
;
msg
+
=
"
\
n
"
;
}
}
else
{
if
(
newErrorPagesEnabled
)
{
technicalInfo
.
textContent
=
"
"
;
msg
+
=
gPipNSSBundle
.
formatStringFromName
(
"
certErrorNotYetValidNow2
"
[
hostString
]
1
)
;
msg
+
=
"
\
n
"
;
}
else
{
msg
+
=
gPipNSSBundle
.
formatStringFromName
(
"
certErrorNotYetValidNow
"
[
input
.
data
.
validity
.
notBeforeLocalTime
now
]
2
)
;
msg
+
=
"
\
n
"
;
}
}
}
else
{
if
(
newErrorPagesEnabled
)
{
technicalInfo
.
textContent
=
"
"
;
msg
+
=
gPipNSSBundle
.
formatStringFromName
(
"
certErrorExpiredNow2
"
[
hostString
]
1
)
;
msg
+
=
"
\
n
"
;
}
else
{
msg
+
=
gPipNSSBundle
.
formatStringFromName
(
"
certErrorExpiredNow
"
[
"
"
now
]
2
)
;
msg
+
=
"
\
n
"
;
}
}
technicalInfo
.
append
(
msg
)
;
}
technicalInfo
.
append
(
"
\
n
"
)
;
let
linkPrefix
=
gPipNSSBundle
.
GetStringFromName
(
"
certErrorCodePrefix3
"
)
;
let
detailLink
=
doc
.
createElement
(
"
a
"
)
;
detailLink
.
append
(
input
.
data
.
codeString
)
;
detailLink
.
title
=
input
.
data
.
codeString
;
detailLink
.
id
=
"
errorCode
"
;
detailLink
.
dataset
.
telemetryId
=
"
error_code_link
"
;
let
fragment
=
BrowserUtils
.
getLocalizedFragment
(
doc
linkPrefix
detailLink
)
;
technicalInfo
.
appendChild
(
fragment
)
;
var
errorCode
=
doc
.
getElementById
(
"
errorCode
"
)
;
if
(
errorCode
)
{
errorCode
.
href
=
"
javascript
:
void
(
0
)
"
;
errorCode
.
addEventListener
(
"
click
"
(
)
=
>
{
let
debugInfo
=
doc
.
getElementById
(
"
certificateErrorDebugInformation
"
)
;
debugInfo
.
style
.
display
=
"
block
"
;
debugInfo
.
scrollIntoView
(
{
block
:
"
start
"
behavior
:
"
smooth
"
}
)
;
}
)
;
}
}
onCertErrorDetails
(
msg
docShell
)
{
let
doc
=
docShell
.
document
;
function
updateContainerPosition
(
)
{
let
textContainer
=
doc
.
getElementById
(
"
text
-
container
"
)
;
textContainer
.
style
.
marginTop
=
calc
(
50vh
-
{
textContainer
.
clientHeight
/
2
}
px
)
;
}
let
div
=
doc
.
getElementById
(
"
certificateErrorText
"
)
;
div
.
textContent
=
msg
.
data
.
info
;
this
.
_setTechDetails
(
msg
doc
)
;
let
learnMoreLink
=
doc
.
getElementById
(
"
learnMoreLink
"
)
;
let
baseURL
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
;
let
errWhatToDo
=
doc
.
getElementById
(
"
es_nssBadCert_
"
+
msg
.
data
.
codeString
)
;
let
es
=
doc
.
getElementById
(
"
errorWhatToDoText
"
)
;
let
errWhatToDoTitle
=
doc
.
getElementById
(
"
edd_nssBadCert
"
)
;
let
est
=
doc
.
getElementById
(
"
errorWhatToDoTitleText
"
)
;
let
clockSkew
=
false
;
doc
.
body
.
setAttribute
(
"
code
"
msg
.
data
.
codeString
)
;
this
.
recordLoadEvent
(
doc
)
;
switch
(
msg
.
data
.
code
)
{
case
SSL_ERROR_BAD_CERT_DOMAIN
:
case
SEC_ERROR_OCSP_INVALID_SIGNING_CERT
:
case
SEC_ERROR_UNKNOWN_ISSUER
:
if
(
!
newErrorPagesEnabled
)
{
break
;
}
if
(
es
)
{
es
.
innerHTML
=
errWhatToDo
.
innerHTML
;
}
if
(
est
)
{
est
.
innerHTML
=
errWhatToDoTitle
.
innerHTML
;
}
updateContainerPosition
(
)
;
break
;
case
MOZILLA_PKIX_ERROR_ADDITIONAL_POLICY_CONSTRAINT_FAILED
:
let
description
=
gPipNSSBundle
.
formatStringFromName
(
"
certErrorSymantecDistrustDescription1
"
[
doc
.
location
.
hostname
]
1
)
;
let
descriptionContainer
=
doc
.
getElementById
(
"
errorShortDescText2
"
)
;
descriptionContainer
.
textContent
=
description
;
let
adminDescription
=
doc
.
createElement
(
"
p
"
)
;
adminDescription
.
textContent
=
gPipNSSBundle
.
GetStringFromName
(
"
certErrorSymantecDistrustAdministrator
"
)
;
descriptionContainer
.
append
(
adminDescription
)
;
learnMoreLink
.
href
=
baseURL
+
"
symantec
-
warning
"
;
updateContainerPosition
(
)
;
break
;
case
MOZILLA_PKIX_ERROR_MITM_DETECTED
:
if
(
newErrorPagesEnabled
&
&
mitmErrorPageEnabled
)
{
let
{
securityInfo
}
=
docShell
.
failedChannel
;
securityInfo
.
QueryInterface
(
Ci
.
nsITransportSecurityInfo
)
;
let
mitmName
=
null
;
for
(
let
cert
of
securityInfo
.
failedCertChain
.
getEnumerator
(
)
)
{
mitmName
=
cert
.
issuerCommonName
;
}
for
(
let
span
of
doc
.
querySelectorAll
(
"
.
mitm
-
name
"
)
)
{
span
.
textContent
=
mitmName
;
}
learnMoreLink
.
href
=
baseURL
+
"
security
-
error
"
;
let
title
=
doc
.
getElementById
(
"
et_mitm
"
)
;
let
desc
=
doc
.
getElementById
(
"
ed_mitm
"
)
;
doc
.
querySelector
(
"
.
title
-
text
"
)
.
textContent
=
title
.
textContent
;
doc
.
getElementById
(
"
errorShortDescText
"
)
.
innerHTML
=
desc
.
innerHTML
;
es
.
innerHTML
=
errWhatToDo
.
innerHTML
;
est
.
innerHTML
=
errWhatToDoTitle
.
innerHTML
;
updateContainerPosition
(
)
;
break
;
}
case
MOZILLA_PKIX_ERROR_SELF_SIGNED_CERT
:
learnMoreLink
.
href
=
baseURL
+
"
security
-
error
"
;
break
;
case
SEC_ERROR_EXPIRED_CERTIFICATE
:
case
SEC_ERROR_EXPIRED_ISSUER_CERTIFICATE
:
case
MOZILLA_PKIX_ERROR_NOT_YET_VALID_CERTIFICATE
:
case
MOZILLA_PKIX_ERROR_NOT_YET_VALID_ISSUER_CERTIFICATE
:
learnMoreLink
.
href
=
baseURL
+
"
time
-
errors
"
;
let
difference
=
Services
.
prefs
.
getIntPref
(
PREF_SERVICES_SETTINGS_CLOCK_SKEW_SECONDS
0
)
;
let
lastFetched
=
Services
.
prefs
.
getIntPref
(
PREF_SERVICES_SETTINGS_LAST_FETCHED
0
)
*
1000
;
let
now
=
Date
.
now
(
)
;
let
certRange
=
this
.
_getCertValidityRange
(
docShell
)
;
let
formatter
=
new
Services
.
intl
.
DateTimeFormat
(
undefined
{
dateStyle
:
"
short
"
}
)
;
let
approximateDate
=
now
-
difference
*
1000
;
if
(
Math
.
abs
(
difference
)
>
60
*
60
*
24
&
&
(
now
-
lastFetched
)
<
=
60
*
60
*
24
*
5
&
&
certRange
.
notBefore
<
approximateDate
&
&
certRange
.
notAfter
>
approximateDate
)
{
clockSkew
=
true
;
let
systemDate
=
formatter
.
format
(
new
Date
(
)
)
;
approximateDate
=
formatter
.
format
(
new
Date
(
approximateDate
)
)
;
doc
.
getElementById
(
"
wrongSystemTime_URL
"
)
.
textContent
=
doc
.
location
.
hostname
;
doc
.
getElementById
(
"
wrongSystemTime_systemDate
"
)
.
textContent
=
systemDate
;
doc
.
getElementById
(
"
wrongSystemTime_actualDate
"
)
.
textContent
=
approximateDate
;
doc
.
getElementById
(
"
errorShortDesc
"
)
.
style
.
display
=
"
none
"
;
doc
.
getElementById
(
"
wrongSystemTimePanel
"
)
.
style
.
display
=
"
block
"
;
}
else
{
let
appBuildID
=
Services
.
appinfo
.
appBuildID
;
let
year
=
parseInt
(
appBuildID
.
substr
(
0
4
)
10
)
;
let
month
=
parseInt
(
appBuildID
.
substr
(
4
2
)
10
)
-
1
;
let
day
=
parseInt
(
appBuildID
.
substr
(
6
2
)
10
)
;
let
buildDate
=
new
Date
(
year
month
day
)
;
let
systemDate
=
new
Date
(
)
;
if
(
buildDate
>
systemDate
&
&
new
Date
(
certRange
.
notAfter
)
>
buildDate
)
{
clockSkew
=
true
;
doc
.
getElementById
(
"
wrongSystemTimeWithoutReference_URL
"
)
.
textContent
=
doc
.
location
.
hostname
;
doc
.
getElementById
(
"
wrongSystemTimeWithoutReference_systemDate
"
)
.
textContent
=
formatter
.
format
(
systemDate
)
;
}
}
if
(
!
newErrorPagesEnabled
)
{
break
;
}
let
systemDate
=
formatter
.
format
(
new
Date
(
)
)
;
doc
.
getElementById
(
"
wrongSystemTime_systemDate1
"
)
.
textContent
=
systemDate
;
if
(
clockSkew
)
{
doc
.
body
.
classList
.
add
(
"
illustrated
"
"
clockSkewError
"
)
;
let
clockErrTitle
=
doc
.
getElementById
(
"
et_clockSkewError
"
)
;
let
clockErrDesc
=
doc
.
getElementById
(
"
ed_clockSkewError
"
)
;
doc
.
querySelector
(
"
.
title
-
text
"
)
.
textContent
=
clockErrTitle
.
textContent
;
let
desc
=
doc
.
getElementById
(
"
errorShortDescText
"
)
;
doc
.
getElementById
(
"
errorShortDesc
"
)
.
style
.
display
=
"
block
"
;
doc
.
getElementById
(
"
wrongSystemTimePanel
"
)
.
style
.
display
=
"
none
"
;
doc
.
getElementById
(
"
certificateErrorReporting
"
)
.
style
.
display
=
"
none
"
;
if
(
desc
)
{
desc
.
innerHTML
=
clockErrDesc
.
innerHTML
;
}
let
errorPageContainer
=
doc
.
getElementById
(
"
errorPageContainer
"
)
;
let
textContainer
=
doc
.
getElementById
(
"
text
-
container
"
)
;
errorPageContainer
.
style
.
backgroundPosition
=
left
top
calc
(
50vh
-
{
textContainer
.
clientHeight
/
2
}
px
)
;
}
else
{
doc
.
getElementById
(
"
wrongSystemTime_systemDate2
"
)
.
textContent
=
systemDate
;
let
errDesc
=
doc
.
getElementById
(
"
ed_nssBadCert_SEC_ERROR_EXPIRED_CERTIFICATE
"
)
;
let
sd
=
doc
.
getElementById
(
"
errorShortDescText
"
)
;
sd
.
innerHTML
=
errDesc
.
innerHTML
;
let
span
=
sd
.
querySelector
(
"
.
hostname
"
)
;
span
.
textContent
=
doc
.
location
.
hostname
;
if
(
msg
.
data
.
code
=
=
SEC_ERROR_EXPIRED_CERTIFICATE
)
{
let
{
cssClass
}
=
this
.
getParams
(
doc
)
;
let
stsSuffix
=
cssClass
=
=
"
badStsCert
"
?
"
_sts
"
:
"
"
;
let
errDesc2
=
doc
.
getElementById
(
ed2_nssBadCert_SEC_ERROR_EXPIRED_CERTIFICATE
{
stsSuffix
}
)
;
let
sd2
=
doc
.
getElementById
(
"
errorShortDescText2
"
)
;
sd2
.
innerHTML
=
errDesc2
.
innerHTML
;
}
if
(
es
)
{
es
.
innerHTML
=
errWhatToDo
.
innerHTML
;
}
if
(
est
)
{
est
.
textContent
=
errWhatToDoTitle
.
textContent
;
est
.
style
.
fontWeight
=
"
bold
"
;
}
updateContainerPosition
(
)
;
}
break
;
}
if
(
newErrorPagesEnabled
)
{
let
{
cssClass
}
=
this
.
getParams
(
doc
)
;
if
(
cssClass
!
=
"
badStsCert
"
&
&
doc
.
ownerGlobal
.
parent
=
=
doc
.
ownerGlobal
&
&
!
clockSkew
&
&
msg
.
data
.
code
!
=
MOZILLA_PKIX_ERROR_ADDITIONAL_POLICY_CONSTRAINT_FAILED
)
{
doc
.
body
.
classList
.
add
(
"
caution
"
)
;
}
}
}
handleEvent
(
aEvent
)
{
let
doc
=
aEvent
.
originalTarget
.
ownerDocument
|
|
aEvent
.
originalTarget
;
switch
(
aEvent
.
type
)
{
case
"
AboutNetErrorLoad
"
:
this
.
onPageLoad
(
aEvent
.
originalTarget
doc
.
defaultView
)
;
break
;
case
"
AboutNetErrorOpenCaptivePortal
"
:
this
.
openCaptivePortalPage
(
aEvent
)
;
break
;
case
"
AboutNetErrorSetAutomatic
"
:
this
.
onSetAutomatic
(
aEvent
)
;
break
;
case
"
AboutNetErrorResetPreferences
"
:
this
.
onResetPreferences
(
aEvent
)
;
break
;
case
"
click
"
:
if
(
aEvent
.
button
=
=
0
)
{
if
(
this
.
isAboutCertError
(
doc
)
)
{
this
.
recordClick
(
aEvent
.
originalTarget
)
;
this
.
onCertError
(
aEvent
.
originalTarget
doc
.
defaultView
)
;
}
else
{
this
.
onClick
(
aEvent
)
;
}
}
break
;
}
}
receiveMessage
(
msg
)
{
if
(
msg
.
name
=
=
"
CertErrorDetails
"
)
{
let
frameDocShell
=
WebNavigationFrames
.
findDocShell
(
msg
.
data
.
frameId
this
.
docShell
)
;
frameDocShell
&
&
frameDocShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
;
if
(
!
frameDocShell
|
|
!
this
.
isAboutCertError
(
frameDocShell
.
document
)
)
{
return
;
}
this
.
onCertErrorDetails
(
msg
frameDocShell
)
;
}
else
if
(
msg
.
name
=
=
"
Browser
:
CaptivePortalFreed
"
)
{
if
(
!
this
.
isAboutCertError
(
this
.
content
.
document
)
)
{
return
;
}
this
.
onCaptivePortalFreed
(
msg
)
;
}
}
onCaptivePortalFreed
(
msg
)
{
this
.
content
.
dispatchEvent
(
new
this
.
content
.
CustomEvent
(
"
AboutNetErrorCaptivePortalFreed
"
)
)
;
}
changedCertPrefs
(
)
{
let
prefSSLImpact
=
PREF_SSL_IMPACT_ROOTS
.
reduce
(
(
prefs
root
)
=
>
{
return
prefs
.
concat
(
Services
.
prefs
.
getChildList
(
root
)
)
;
}
[
]
)
;
for
(
let
prefName
of
prefSSLImpact
)
{
if
(
Services
.
prefs
.
prefHasUserValue
(
prefName
)
)
{
return
true
;
}
}
return
false
;
}
_getErrorMessageFromCode
(
securityInfo
doc
)
{
let
uri
=
Services
.
io
.
newURI
(
doc
.
location
)
;
let
hostString
=
uri
.
host
;
if
(
uri
.
port
!
=
443
&
&
uri
.
port
!
=
-
1
)
{
hostString
=
uri
.
hostPort
;
}
let
id_str
=
"
"
;
switch
(
securityInfo
.
errorCode
)
{
case
SSL_ERROR_SSL_DISABLED
:
id_str
=
"
PSMERR_SSL_Disabled
"
;
break
;
case
SSL_ERROR_SSL2_DISABLED
:
id_str
=
"
PSMERR_SSL2_Disabled
"
;
break
;
case
SEC_ERROR_REUSED_ISSUER_AND_SERIAL
:
id_str
=
"
PSMERR_HostReusedIssuerSerial
"
;
break
;
}
let
nss_error_id_str
=
securityInfo
.
errorCodeString
;
let
msg2
=
"
"
;
if
(
id_str
)
{
msg2
=
gPipNSSBundle
.
GetStringFromName
(
id_str
)
+
"
\
n
"
;
}
else
if
(
nss_error_id_str
)
{
msg2
=
gNSSErrorsBundle
.
GetStringFromName
(
nss_error_id_str
)
+
"
\
n
"
;
}
if
(
!
msg2
)
{
msg2
=
nss_error_id_str
;
}
let
msg
=
gPipNSSBundle
.
formatStringFromName
(
"
SSLConnectionErrorPrefix2
"
[
hostString
msg2
]
2
)
;
if
(
nss_error_id_str
)
{
msg
+
=
gPipNSSBundle
.
formatStringFromName
(
"
certErrorCodePrefix3
"
[
nss_error_id_str
]
1
)
+
"
\
n
"
;
}
return
msg
;
}
onPageLoad
(
originalTarget
win
)
{
const
TLS_ERROR_REPORT_TELEMETRY_UI_SHOWN
=
0
;
let
hideAddExceptionButton
=
false
;
if
(
this
.
isAboutCertError
(
win
.
document
)
)
{
this
.
onCertError
(
originalTarget
win
)
;
hideAddExceptionButton
=
Services
.
prefs
.
getBoolPref
(
"
security
.
certerror
.
hideAddException
"
false
)
;
}
if
(
this
.
isAboutNetError
(
win
.
document
)
)
{
let
docShell
=
win
.
docShell
;
if
(
docShell
)
{
let
{
securityInfo
}
=
docShell
.
failedChannel
;
if
(
securityInfo
)
{
securityInfo
.
QueryInterface
(
Ci
.
nsITransportSecurityInfo
)
;
let
msg
=
this
.
_getErrorMessageFromCode
(
securityInfo
win
.
document
)
;
let
id
=
win
.
document
.
getElementById
(
"
errorShortDescText
"
)
;
id
.
textContent
=
msg
;
}
}
}
let
automatic
=
Services
.
prefs
.
getBoolPref
(
"
security
.
ssl
.
errorReporting
.
automatic
"
)
;
win
.
dispatchEvent
(
new
win
.
CustomEvent
(
"
AboutNetErrorOptions
"
{
detail
:
JSON
.
stringify
(
{
enabled
:
Services
.
prefs
.
getBoolPref
(
"
security
.
ssl
.
errorReporting
.
enabled
"
)
changedCertPrefs
:
this
.
changedCertPrefs
(
)
automatic
hideAddExceptionButton
}
)
}
)
)
;
this
.
mm
.
sendAsyncMessage
(
"
Browser
:
SSLErrorReportTelemetry
"
{
reportStatus
:
TLS_ERROR_REPORT_TELEMETRY_UI_SHOWN
}
)
;
}
openCaptivePortalPage
(
evt
)
{
this
.
mm
.
sendAsyncMessage
(
"
Browser
:
OpenCaptivePortalPage
"
)
;
}
onResetPreferences
(
evt
)
{
this
.
mm
.
sendAsyncMessage
(
"
Browser
:
ResetSSLPreferences
"
)
;
}
onSetAutomatic
(
evt
)
{
this
.
mm
.
sendAsyncMessage
(
"
Browser
:
SetSSLErrorReportAuto
"
{
automatic
:
evt
.
detail
}
)
;
if
(
evt
.
detail
)
{
let
win
=
evt
.
originalTarget
.
ownerGlobal
;
let
docShell
=
win
.
docShell
;
let
{
securityInfo
}
=
docShell
.
failedChannel
;
securityInfo
.
QueryInterface
(
Ci
.
nsITransportSecurityInfo
)
;
let
{
host
port
}
=
win
.
document
.
mozDocumentURIIfNotForErrorPages
;
let
errorReporter
=
Cc
[
"
mozilla
.
org
/
securityreporter
;
1
"
]
.
getService
(
Ci
.
nsISecurityReporter
)
;
errorReporter
.
reportTLSError
(
securityInfo
host
port
)
;
}
}
onCertError
(
target
win
)
{
this
.
mm
.
sendAsyncMessage
(
"
Browser
:
CertExceptionError
"
{
frameId
:
WebNavigationFrames
.
getFrameId
(
win
)
location
:
win
.
document
.
location
.
href
elementId
:
target
.
getAttribute
(
"
id
"
)
isTopFrame
:
(
win
.
parent
=
=
=
win
)
securityInfoAsString
:
getSerializedSecurityInfo
(
win
.
docShell
)
}
)
;
}
getCSSClass
(
doc
)
{
let
searchParams
=
new
URL
(
doc
.
documentURI
)
.
searchParams
;
return
searchParams
.
get
(
"
s
"
)
;
}
recordLoadEvent
(
doc
)
{
let
cssClass
=
this
.
getCSSClass
(
doc
)
;
let
errorCode
=
doc
.
body
.
getAttribute
(
"
code
"
)
.
substring
(
0
40
)
;
Services
.
telemetry
.
recordEvent
(
"
security
.
ui
.
certerror
"
"
load
"
"
aboutcerterror
"
errorCode
{
"
has_sts
"
:
(
cssClass
=
=
"
badStsCert
"
)
.
toString
(
)
"
is_frame
"
:
(
doc
.
ownerGlobal
.
parent
!
=
doc
.
ownerGlobal
)
.
toString
(
)
}
)
;
}
recordClick
(
element
)
{
let
telemetryId
=
element
.
dataset
.
telemetryId
;
if
(
!
telemetryId
)
{
return
;
}
let
doc
=
element
.
ownerDocument
;
let
cssClass
=
this
.
getCSSClass
(
doc
)
;
let
errorCode
=
doc
.
body
.
getAttribute
(
"
code
"
)
.
substring
(
0
40
)
;
let
panel
=
doc
.
getElementById
(
"
badCertAdvancedPanel
"
)
;
Services
.
telemetry
.
recordEvent
(
"
security
.
ui
.
certerror
"
"
click
"
telemetryId
errorCode
{
"
panel_open
"
:
(
panel
.
style
.
display
=
=
"
none
"
)
.
toString
(
)
"
has_sts
"
:
(
cssClass
=
=
"
badStsCert
"
)
.
toString
(
)
"
is_frame
"
:
(
doc
.
ownerGlobal
.
parent
!
=
doc
.
ownerGlobal
)
.
toString
(
)
}
)
;
}
onClick
(
event
)
{
let
{
documentURI
}
=
event
.
target
.
ownerDocument
;
let
elmId
=
event
.
originalTarget
.
getAttribute
(
"
id
"
)
;
if
(
elmId
=
=
"
returnButton
"
)
{
this
.
mm
.
sendAsyncMessage
(
"
Browser
:
SSLErrorGoBack
"
{
}
)
;
return
;
}
if
(
elmId
!
=
"
errorTryAgain
"
|
|
!
/
e
=
netOffline
/
.
test
(
documentURI
)
)
{
return
;
}
if
(
Services
.
io
.
offline
)
{
event
.
preventDefault
(
)
;
this
.
mm
.
sendAsyncMessage
(
"
Browser
:
EnableOnlineMode
"
{
}
)
;
}
}
}
