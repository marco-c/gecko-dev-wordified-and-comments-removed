var
EXPORTED_SYMBOLS
=
[
"
RefreshBlockerChild
"
"
RefreshBlockerObserverChild
"
]
;
const
{
setTimeout
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
sys
.
mjs
"
)
;
const
REFRESHBLOCKING_PREF
=
"
accessibility
.
blockautorefresh
"
;
var
progressListener
=
{
blockedWindows
:
new
WeakMap
(
)
onStateChange
(
aWebProgress
aRequest
aStateFlags
aStatus
)
{
if
(
aStateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_IS_WINDOW
&
&
aStateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_STOP
)
{
this
.
blockedWindows
.
delete
(
aWebProgress
.
DOMWindow
)
;
}
}
onLocationChange
(
aWebProgress
aRequest
aLocation
aFlags
)
{
let
win
=
aWebProgress
.
DOMWindow
;
if
(
this
.
blockedWindows
.
has
(
win
)
)
{
let
data
=
this
.
blockedWindows
.
get
(
win
)
;
if
(
data
)
{
this
.
send
(
win
data
)
;
}
}
else
{
this
.
blockedWindows
.
set
(
win
null
)
;
}
}
onRefreshAttempted
(
aWebProgress
aURI
aDelay
aSameURI
)
{
let
win
=
aWebProgress
.
DOMWindow
;
let
data
=
{
browsingContext
:
win
.
browsingContext
URI
:
aURI
.
spec
delay
:
aDelay
sameURI
:
aSameURI
}
;
if
(
this
.
blockedWindows
.
has
(
win
)
)
{
this
.
send
(
win
data
)
;
}
else
{
this
.
blockedWindows
.
set
(
win
data
)
;
}
return
false
;
}
send
(
win
data
)
{
setTimeout
(
(
)
=
>
{
try
{
let
actor
=
win
.
windowGlobalChild
.
getActor
(
"
RefreshBlocker
"
)
;
if
(
actor
)
{
actor
.
sendAsyncMessage
(
"
RefreshBlocker
:
Blocked
"
data
)
;
}
}
catch
(
ex
)
{
}
}
0
)
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIWebProgressListener2
"
"
nsIWebProgressListener
"
"
nsISupportsWeakReference
"
]
)
}
;
class
RefreshBlockerChild
extends
JSWindowActorChild
{
didDestroy
(
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
REFRESHBLOCKING_PREF
)
)
{
this
.
disable
(
this
.
docShell
)
;
}
}
enable
(
)
{
ChromeUtils
.
domProcessChild
.
getActor
(
"
RefreshBlockerObserver
"
)
.
enable
(
this
.
docShell
)
;
}
disable
(
)
{
ChromeUtils
.
domProcessChild
.
getActor
(
"
RefreshBlockerObserver
"
)
.
disable
(
this
.
docShell
)
;
}
receiveMessage
(
message
)
{
let
data
=
message
.
data
;
switch
(
message
.
name
)
{
case
"
RefreshBlocker
:
Refresh
"
:
let
docShell
=
data
.
browsingContext
.
docShell
;
let
refreshURI
=
docShell
.
QueryInterface
(
Ci
.
nsIRefreshURI
)
;
let
URI
=
Services
.
io
.
newURI
(
data
.
URI
)
;
refreshURI
.
forceRefreshURI
(
URI
null
data
.
delay
)
;
break
;
case
"
PreferenceChanged
"
:
if
(
data
.
isEnabled
)
{
this
.
enable
(
this
.
docShell
)
;
}
else
{
this
.
disable
(
this
.
docShell
)
;
}
}
}
}
class
RefreshBlockerObserverChild
extends
JSProcessActorChild
{
constructor
(
)
{
super
(
)
;
this
.
filtersMap
=
new
Map
(
)
;
}
observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
"
webnavigation
-
create
"
:
case
"
chrome
-
webnavigation
-
create
"
:
if
(
Services
.
prefs
.
getBoolPref
(
REFRESHBLOCKING_PREF
)
)
{
this
.
enable
(
subject
.
QueryInterface
(
Ci
.
nsIDocShell
)
)
;
}
break
;
case
"
webnavigation
-
destroy
"
:
case
"
chrome
-
webnavigation
-
destroy
"
:
if
(
Services
.
prefs
.
getBoolPref
(
REFRESHBLOCKING_PREF
)
)
{
this
.
disable
(
subject
.
QueryInterface
(
Ci
.
nsIDocShell
)
)
;
}
break
;
}
}
enable
(
docShell
)
{
if
(
this
.
filtersMap
.
has
(
docShell
)
)
{
return
;
}
let
filter
=
Cc
[
"
mozilla
.
org
/
appshell
/
component
/
browser
-
status
-
filter
;
1
"
]
.
createInstance
(
Ci
.
nsIWebProgress
)
;
filter
.
addProgressListener
(
progressListener
Ci
.
nsIWebProgress
.
NOTIFY_ALL
)
;
this
.
filtersMap
.
set
(
docShell
filter
)
;
let
webProgress
=
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebProgress
)
;
webProgress
.
addProgressListener
(
filter
Ci
.
nsIWebProgress
.
NOTIFY_ALL
)
;
}
disable
(
docShell
)
{
let
filter
=
this
.
filtersMap
.
get
(
docShell
)
;
if
(
!
filter
)
{
return
;
}
let
webProgress
=
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebProgress
)
;
webProgress
.
removeProgressListener
(
filter
)
;
filter
.
removeProgressListener
(
progressListener
)
;
this
.
filtersMap
.
delete
(
docShell
)
;
}
}
