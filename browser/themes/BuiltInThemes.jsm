var
EXPORTED_SYMBOLS
=
[
"
BuiltInThemes
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AddonManager
:
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
BuiltInThemeConfig
:
"
resource
:
/
/
/
modules
/
BuiltInThemeConfig
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
}
)
;
const
kActiveThemePref
=
"
extensions
.
activeThemeID
"
;
const
kRetainedThemesPref
=
"
browser
.
theme
.
retainedExpiredThemes
"
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
retainedThemes
"
kRetainedThemesPref
null
null
val
=
>
{
if
(
!
val
)
{
return
[
]
;
}
let
parsedVal
;
try
{
parsedVal
=
JSON
.
parse
(
val
)
;
}
catch
(
ex
)
{
console
.
log
(
{
kRetainedThemesPref
}
has
invalid
value
.
)
;
return
[
]
;
}
return
parsedVal
;
}
)
;
class
_BuiltInThemes
{
builtInThemeMap
=
BuiltInThemeConfig
;
previewForBuiltInThemeId
(
id
)
{
let
theme
=
this
.
builtInThemeMap
.
get
(
id
)
;
if
(
theme
)
{
return
{
theme
.
path
}
preview
.
svg
;
}
return
null
;
}
isMonochromaticTheme
(
id
)
{
return
id
.
endsWith
(
"
-
colorway
mozilla
.
org
"
)
;
}
maybeInstallActiveBuiltInTheme
(
)
{
const
activeThemeID
=
Services
.
prefs
.
getStringPref
(
kActiveThemePref
"
default
-
theme
mozilla
.
org
"
)
;
let
activeBuiltInTheme
=
this
.
builtInThemeMap
.
get
(
activeThemeID
)
;
if
(
activeBuiltInTheme
)
{
AddonManager
.
maybeInstallBuiltinAddon
(
activeThemeID
activeBuiltInTheme
.
version
resource
:
/
/
builtin
-
themes
/
{
activeBuiltInTheme
.
path
}
)
;
}
}
async
ensureBuiltInThemes
(
)
{
let
installPromises
=
[
]
;
installPromises
.
push
(
this
.
_uninstallExpiredThemes
(
)
)
;
const
now
=
new
Date
(
)
;
this
.
monochromaticSortIndices
=
new
Map
(
)
;
let
monochromaticSortIndex
=
0
;
for
(
let
[
id
themeInfo
]
of
this
.
builtInThemeMap
.
entries
(
)
)
{
if
(
!
themeInfo
.
expiry
|
|
retainedThemes
.
includes
(
id
)
|
|
new
Date
(
themeInfo
.
expiry
)
>
now
)
{
installPromises
.
push
(
AddonManager
.
maybeInstallBuiltinAddon
(
id
themeInfo
.
version
themeInfo
.
path
)
)
;
if
(
this
.
isMonochromaticTheme
(
id
)
)
{
this
.
monochromaticSortIndices
.
set
(
id
monochromaticSortIndex
+
+
)
;
}
}
}
await
Promise
.
all
(
installPromises
)
;
}
themeIsExpired
(
id
)
{
let
themeInfo
=
this
.
builtInThemeMap
.
get
(
id
)
;
return
themeInfo
?
.
expiry
&
&
new
Date
(
themeInfo
.
expiry
)
<
new
Date
(
)
;
}
isRetainedExpiredTheme
(
id
)
{
return
retainedThemes
.
includes
(
id
)
&
&
this
.
themeIsExpired
(
id
)
;
}
async
_uninstallExpiredThemes
(
)
{
const
activeThemeID
=
Services
.
prefs
.
getStringPref
(
kActiveThemePref
"
default
-
theme
mozilla
.
org
"
)
;
const
now
=
new
Date
(
)
;
const
expiredThemes
=
Array
.
from
(
this
.
builtInThemeMap
.
entries
(
)
)
.
filter
(
(
[
id
themeInfo
]
)
=
>
!
!
themeInfo
.
expiry
&
&
!
retainedThemes
.
includes
(
id
)
&
&
new
Date
(
themeInfo
.
expiry
)
<
=
now
)
;
for
(
let
[
id
]
of
expiredThemes
)
{
if
(
id
=
=
activeThemeID
)
{
this
.
_retainLimitedTimeTheme
(
id
)
;
}
else
{
try
{
let
addon
=
await
AddonManager
.
getAddonByID
(
id
)
;
if
(
addon
)
{
await
addon
.
uninstall
(
)
;
}
}
catch
(
e
)
{
Cu
.
reportError
(
Failed
to
uninstall
expired
theme
{
id
}
)
;
}
}
}
}
_retainLimitedTimeTheme
(
id
)
{
if
(
!
retainedThemes
.
includes
(
id
)
)
{
retainedThemes
.
push
(
id
)
;
Services
.
prefs
.
setStringPref
(
kRetainedThemesPref
JSON
.
stringify
(
retainedThemes
)
)
;
}
}
}
var
BuiltInThemes
=
new
_BuiltInThemes
(
)
;
