"
use
strict
"
;
var
Cc
=
Components
.
classes
;
var
Ci
=
Components
.
interfaces
;
var
Cu
=
Components
.
utils
;
var
Cr
=
Components
.
results
;
this
.
EXPORTED_SYMBOLS
=
[
"
TabCrashHandler
"
"
PluginCrashReporter
"
"
UnsubmittedCrashHandler
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
CrashSubmit
"
"
resource
:
/
/
gre
/
modules
/
CrashSubmit
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
AppConstants
"
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
RemotePages
"
"
resource
:
/
/
gre
/
modules
/
RemotePageManager
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
SessionStore
"
"
resource
:
/
/
/
modules
/
sessionstore
/
SessionStore
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
RecentWindow
"
"
resource
:
/
/
/
modules
/
RecentWindow
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PluralForm
"
"
resource
:
/
/
gre
/
modules
/
PluralForm
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
setTimeout
"
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
clearTimeout
"
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gNavigatorBundle
"
function
(
)
{
const
url
=
"
chrome
:
/
/
browser
/
locale
/
browser
.
properties
"
;
return
Services
.
strings
.
createBundle
(
url
)
;
}
)
;
const
PENDING_CRASH_REPORT_DAYS
=
28
;
const
DAY
=
24
*
60
*
60
*
1000
;
const
DAYS_TO_SUPPRESS
=
30
;
const
MAX_UNSEEN_CRASHED_CHILD_IDS
=
20
;
const
CHECK_FOR_UNSUBMITTED_CRASH_REPORTS_DELAY_MS
=
60
*
10000
;
class
BrowserWeakMap
extends
WeakMap
{
get
(
browser
)
{
if
(
browser
.
permanentKey
)
{
return
super
.
get
(
browser
.
permanentKey
)
;
}
return
super
.
get
(
browser
)
;
}
set
(
browser
value
)
{
if
(
browser
.
permanentKey
)
{
return
super
.
set
(
browser
.
permanentKey
value
)
;
}
return
super
.
set
(
browser
value
)
;
}
delete
(
browser
)
{
if
(
browser
.
permanentKey
)
{
return
super
.
delete
(
browser
.
permanentKey
)
;
}
return
super
.
delete
(
browser
)
;
}
}
this
.
TabCrashHandler
=
{
_crashedTabCount
:
0
childMap
:
new
Map
(
)
browserMap
:
new
BrowserWeakMap
(
)
unseenCrashedChildIDs
:
[
]
crashedBrowserQueues
:
new
Map
(
)
get
prefs
(
)
{
delete
this
.
prefs
;
return
this
.
prefs
=
Services
.
prefs
.
getBranch
(
"
browser
.
tabs
.
crashReporting
.
"
)
;
}
init
(
)
{
if
(
this
.
initialized
)
return
;
this
.
initialized
=
true
;
Services
.
obs
.
addObserver
(
this
"
ipc
:
content
-
shutdown
"
)
;
Services
.
obs
.
addObserver
(
this
"
oop
-
frameloader
-
crashed
"
)
;
this
.
pageListener
=
new
RemotePages
(
"
about
:
tabcrashed
"
)
;
this
.
pageListener
.
addMessageListener
(
"
Load
"
this
.
receiveMessage
.
bind
(
this
)
)
;
this
.
pageListener
.
addMessageListener
(
"
RemotePage
:
Unload
"
this
.
receiveMessage
.
bind
(
this
)
)
;
this
.
pageListener
.
addMessageListener
(
"
closeTab
"
this
.
receiveMessage
.
bind
(
this
)
)
;
this
.
pageListener
.
addMessageListener
(
"
restoreTab
"
this
.
receiveMessage
.
bind
(
this
)
)
;
this
.
pageListener
.
addMessageListener
(
"
restoreAll
"
this
.
receiveMessage
.
bind
(
this
)
)
;
}
observe
(
aSubject
aTopic
aData
)
{
switch
(
aTopic
)
{
case
"
ipc
:
content
-
shutdown
"
:
{
aSubject
.
QueryInterface
(
Ci
.
nsIPropertyBag2
)
;
if
(
!
aSubject
.
get
(
"
abnormal
"
)
)
{
return
;
}
let
childID
=
aSubject
.
get
(
"
childID
"
)
;
let
dumpID
=
aSubject
.
get
(
"
dumpID
"
)
;
if
(
!
dumpID
)
{
Services
.
telemetry
.
getHistogramById
(
"
FX_CONTENT_CRASH_DUMP_UNAVAILABLE
"
)
.
add
(
1
)
;
}
else
if
(
AppConstants
.
MOZ_CRASHREPORTER
)
{
this
.
childMap
.
set
(
childID
dumpID
)
;
}
if
(
!
this
.
flushCrashedBrowserQueue
(
childID
)
)
{
this
.
unseenCrashedChildIDs
.
push
(
childID
)
;
if
(
this
.
unseenCrashedChildIDs
.
length
>
MAX_UNSEEN_CRASHED_CHILD_IDS
)
{
this
.
unseenCrashedChildIDs
.
shift
(
)
;
}
}
let
env
=
Cc
[
"
mozilla
.
org
/
process
/
environment
;
1
"
]
.
getService
(
Ci
.
nsIEnvironment
)
;
let
shutdown
=
env
.
exists
(
"
MOZ_CRASHREPORTER_SHUTDOWN
"
)
;
if
(
shutdown
)
{
dump
(
"
A
content
process
crashed
and
MOZ_CRASHREPORTER_SHUTDOWN
is
"
+
"
set
shutting
down
\
n
"
)
;
Services
.
startup
.
quit
(
Ci
.
nsIAppStartup
.
eForceQuit
)
;
}
break
;
}
case
"
oop
-
frameloader
-
crashed
"
:
{
aSubject
.
QueryInterface
(
Ci
.
nsIFrameLoader
)
;
let
browser
=
aSubject
.
ownerElement
;
if
(
!
browser
)
{
return
;
}
this
.
browserMap
.
set
(
browser
aSubject
.
childID
)
;
break
;
}
}
}
receiveMessage
(
message
)
{
let
browser
=
message
.
target
.
browser
;
let
gBrowser
=
browser
.
ownerGlobal
.
gBrowser
;
let
tab
=
gBrowser
.
getTabForBrowser
(
browser
)
;
switch
(
message
.
name
)
{
case
"
Load
"
:
{
this
.
onAboutTabCrashedLoad
(
message
)
;
break
;
}
case
"
RemotePage
:
Unload
"
:
{
this
.
onAboutTabCrashedUnload
(
message
)
;
break
;
}
case
"
closeTab
"
:
{
this
.
maybeSendCrashReport
(
message
)
;
gBrowser
.
removeTab
(
tab
{
animate
:
true
}
)
;
break
;
}
case
"
restoreTab
"
:
{
this
.
maybeSendCrashReport
(
message
)
;
SessionStore
.
reviveCrashedTab
(
tab
)
;
break
;
}
case
"
restoreAll
"
:
{
this
.
maybeSendCrashReport
(
message
)
;
SessionStore
.
reviveAllCrashedTabs
(
)
;
break
;
}
}
}
flushCrashedBrowserQueue
(
childID
)
{
let
browserQueue
=
this
.
crashedBrowserQueues
.
get
(
childID
)
;
if
(
!
browserQueue
)
{
return
false
;
}
this
.
crashedBrowserQueues
.
delete
(
childID
)
;
let
sentBrowser
=
false
;
for
(
let
weakBrowser
of
browserQueue
)
{
let
browser
=
weakBrowser
.
get
(
)
;
if
(
browser
)
{
this
.
sendToTabCrashedPage
(
browser
)
;
sentBrowser
=
true
;
}
}
return
sentBrowser
;
}
onSelectedBrowserCrash
(
browser
)
{
if
(
!
browser
.
isRemoteBrowser
)
{
Cu
.
reportError
(
"
Selected
crashed
browser
is
not
remote
.
"
)
;
return
;
}
if
(
!
browser
.
frameLoader
)
{
Cu
.
reportError
(
"
Selected
crashed
browser
has
no
frameloader
.
"
)
;
return
;
}
let
childID
=
browser
.
frameLoader
.
childID
;
let
browserQueue
=
this
.
crashedBrowserQueues
.
get
(
childID
)
;
if
(
!
browserQueue
)
{
browserQueue
=
[
]
;
this
.
crashedBrowserQueues
.
set
(
childID
browserQueue
)
;
}
browserQueue
.
push
(
Cu
.
getWeakReference
(
browser
)
)
;
}
willShowCrashedTab
(
browser
)
{
let
childID
=
this
.
browserMap
.
get
(
browser
)
;
if
(
childID
&
&
this
.
unseenCrashedChildIDs
.
includes
(
childID
)
)
{
if
(
UnsubmittedCrashHandler
.
autoSubmit
)
{
let
dumpID
=
this
.
childMap
.
get
(
childID
)
;
if
(
dumpID
)
{
UnsubmittedCrashHandler
.
submitReports
(
[
dumpID
]
)
;
}
}
else
{
this
.
sendToTabCrashedPage
(
browser
)
;
return
true
;
}
}
return
false
;
}
sendToTabCrashedPage
(
browser
)
{
let
title
=
browser
.
contentTitle
;
let
uri
=
browser
.
currentURI
;
let
gBrowser
=
browser
.
ownerGlobal
.
gBrowser
;
let
tab
=
gBrowser
.
getTabForBrowser
(
browser
)
;
gBrowser
.
updateBrowserRemoteness
(
browser
false
)
;
browser
.
setAttribute
(
"
crashedPageTitle
"
title
)
;
browser
.
docShell
.
displayLoadError
(
Cr
.
NS_ERROR_CONTENT_CRASHED
uri
null
)
;
browser
.
removeAttribute
(
"
crashedPageTitle
"
)
;
tab
.
setAttribute
(
"
crashed
"
true
)
;
}
maybeSendCrashReport
(
message
)
{
if
(
!
AppConstants
.
MOZ_CRASHREPORTER
)
{
return
;
}
if
(
!
message
.
data
.
hasReport
)
{
return
;
}
let
browser
=
message
.
target
.
browser
;
if
(
message
.
data
.
autoSubmit
)
{
UnsubmittedCrashHandler
.
autoSubmit
=
true
;
}
let
childID
=
this
.
browserMap
.
get
(
browser
)
;
let
dumpID
=
this
.
childMap
.
get
(
childID
)
;
if
(
!
dumpID
)
{
return
;
}
if
(
!
message
.
data
.
sendReport
)
{
Services
.
telemetry
.
getHistogramById
(
"
FX_CONTENT_CRASH_NOT_SUBMITTED
"
)
.
add
(
1
)
;
this
.
prefs
.
setBoolPref
(
"
sendReport
"
false
)
;
return
;
}
let
{
includeURL
comments
email
emailMe
URL
}
=
message
.
data
;
let
extraExtraKeyVals
=
{
"
Comments
"
:
comments
"
Email
"
:
email
"
URL
"
:
URL
}
;
for
(
let
key
in
extraExtraKeyVals
)
{
let
val
=
extraExtraKeyVals
[
key
]
.
trim
(
)
;
if
(
!
val
)
{
delete
extraExtraKeyVals
[
key
]
;
}
}
if
(
!
includeURL
)
{
extraExtraKeyVals
.
URL
=
"
"
;
}
CrashSubmit
.
submit
(
dumpID
{
recordSubmission
:
true
extraExtraKeyVals
}
)
.
catch
(
Cu
.
reportError
)
;
this
.
prefs
.
setBoolPref
(
"
sendReport
"
true
)
;
this
.
prefs
.
setBoolPref
(
"
includeURL
"
includeURL
)
;
this
.
prefs
.
setBoolPref
(
"
emailMe
"
emailMe
)
;
if
(
emailMe
)
{
this
.
prefs
.
setCharPref
(
"
email
"
email
)
;
}
else
{
this
.
prefs
.
setCharPref
(
"
email
"
"
"
)
;
}
this
.
childMap
.
set
(
childID
null
)
;
this
.
removeSubmitCheckboxesForSameCrash
(
childID
)
;
}
removeSubmitCheckboxesForSameCrash
(
childID
)
{
let
enumerator
=
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
;
while
(
enumerator
.
hasMoreElements
(
)
)
{
let
window
=
enumerator
.
getNext
(
)
;
if
(
!
window
.
gMultiProcessBrowser
)
continue
;
for
(
let
browser
of
window
.
gBrowser
.
browsers
)
{
if
(
browser
.
isRemoteBrowser
)
continue
;
let
doc
=
browser
.
contentDocument
;
if
(
!
doc
.
documentURI
.
startsWith
(
"
about
:
tabcrashed
"
)
)
continue
;
if
(
this
.
browserMap
.
get
(
browser
)
=
=
childID
)
{
this
.
browserMap
.
delete
(
browser
)
;
let
ports
=
this
.
pageListener
.
portsForBrowser
(
browser
)
;
if
(
ports
.
length
)
{
ports
[
0
]
.
sendAsyncMessage
(
"
CrashReportSent
"
)
;
}
}
}
}
}
onAboutTabCrashedLoad
(
message
)
{
this
.
_crashedTabCount
+
+
;
this
.
pageListener
.
sendAsyncMessage
(
"
UpdateCount
"
{
count
:
this
.
_crashedTabCount
}
)
;
let
browser
=
message
.
target
.
browser
;
let
childID
=
this
.
browserMap
.
get
(
browser
)
;
let
index
=
this
.
unseenCrashedChildIDs
.
indexOf
(
childID
)
;
if
(
index
!
=
-
1
)
{
this
.
unseenCrashedChildIDs
.
splice
(
index
1
)
;
}
let
dumpID
=
this
.
getDumpID
(
browser
)
;
if
(
!
dumpID
)
{
message
.
target
.
sendAsyncMessage
(
"
SetCrashReportAvailable
"
{
hasReport
:
false
}
)
;
return
;
}
let
requestAutoSubmit
=
!
UnsubmittedCrashHandler
.
autoSubmit
;
let
requestEmail
=
this
.
prefs
.
getBoolPref
(
"
requestEmail
"
)
;
let
sendReport
=
this
.
prefs
.
getBoolPref
(
"
sendReport
"
)
;
let
includeURL
=
this
.
prefs
.
getBoolPref
(
"
includeURL
"
)
;
let
emailMe
=
this
.
prefs
.
getBoolPref
(
"
emailMe
"
)
;
let
data
=
{
hasReport
:
true
sendReport
includeURL
emailMe
requestAutoSubmit
requestEmail
}
;
if
(
emailMe
)
{
data
.
email
=
this
.
prefs
.
getCharPref
(
"
email
"
)
;
}
if
(
this
.
_crashedTabCount
=
=
1
)
{
Services
.
telemetry
.
getHistogramById
(
"
FX_CONTENT_CRASH_PRESENTED
"
)
.
add
(
1
)
;
}
message
.
target
.
sendAsyncMessage
(
"
SetCrashReportAvailable
"
data
)
;
}
onAboutTabCrashedUnload
(
message
)
{
if
(
!
this
.
_crashedTabCount
)
{
Cu
.
reportError
(
"
Can
not
decrement
crashed
tab
count
to
below
0
"
)
;
return
;
}
this
.
_crashedTabCount
-
-
;
this
.
pageListener
.
sendAsyncMessage
(
"
UpdateCount
"
{
count
:
this
.
_crashedTabCount
}
)
;
let
browser
=
message
.
target
.
browser
;
let
childID
=
this
.
browserMap
.
get
(
browser
)
;
if
(
this
.
_crashedTabCount
=
=
0
&
&
childID
)
{
Services
.
telemetry
.
getHistogramById
(
"
FX_CONTENT_CRASH_NOT_SUBMITTED
"
)
.
add
(
1
)
;
}
}
getDumpID
(
browser
)
{
if
(
!
AppConstants
.
MOZ_CRASHREPORTER
)
{
return
null
;
}
return
this
.
childMap
.
get
(
this
.
browserMap
.
get
(
browser
)
)
;
}
}
;
this
.
UnsubmittedCrashHandler
=
{
get
prefs
(
)
{
delete
this
.
prefs
;
return
this
.
prefs
=
Services
.
prefs
.
getBranch
(
"
browser
.
crashReports
.
unsubmittedCheck
.
"
)
;
}
get
enabled
(
)
{
return
this
.
prefs
.
getBoolPref
(
"
enabled
"
)
;
}
showingNotification
:
false
suppressed
:
false
_checkTimeout
:
null
init
(
)
{
if
(
this
.
initialized
)
{
return
;
}
this
.
initialized
=
true
;
if
(
this
.
enabled
)
{
if
(
this
.
prefs
.
prefHasUserValue
(
"
suppressUntilDate
"
)
)
{
if
(
this
.
prefs
.
getCharPref
(
"
suppressUntilDate
"
)
>
this
.
dateString
(
)
)
{
this
.
suppressed
=
true
;
return
;
}
this
.
prefs
.
clearUserPref
(
"
suppressUntilDate
"
)
;
}
Services
.
obs
.
addObserver
(
this
"
profile
-
before
-
change
"
)
;
}
}
uninit
(
)
{
if
(
!
this
.
initialized
)
{
return
;
}
this
.
initialized
=
false
;
if
(
this
.
_checkTimeout
)
{
clearTimeout
(
this
.
_checkTimeout
)
;
this
.
_checkTimeout
=
null
;
}
if
(
!
this
.
enabled
)
{
return
;
}
if
(
this
.
suppressed
)
{
this
.
suppressed
=
false
;
return
;
}
if
(
this
.
showingNotification
)
{
this
.
prefs
.
setBoolPref
(
"
shutdownWhileShowing
"
true
)
;
this
.
showingNotification
=
false
;
}
Services
.
obs
.
removeObserver
(
this
"
profile
-
before
-
change
"
)
;
}
observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
"
profile
-
before
-
change
"
:
{
this
.
uninit
(
)
;
break
;
}
}
}
scheduleCheckForUnsubmittedCrashReports
(
)
{
this
.
_checkTimeout
=
setTimeout
(
(
)
=
>
{
Services
.
tm
.
idleDispatchToMainThread
(
(
)
=
>
{
this
.
checkForUnsubmittedCrashReports
(
)
;
}
)
;
}
CHECK_FOR_UNSUBMITTED_CRASH_REPORTS_DELAY_MS
)
;
}
async
checkForUnsubmittedCrashReports
(
)
{
if
(
!
this
.
enabled
|
|
this
.
suppressed
)
{
return
null
;
}
let
dateLimit
=
new
Date
(
)
;
dateLimit
.
setDate
(
dateLimit
.
getDate
(
)
-
PENDING_CRASH_REPORT_DAYS
)
;
let
reportIDs
=
[
]
;
try
{
reportIDs
=
await
CrashSubmit
.
pendingIDs
(
dateLimit
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
return
null
;
}
if
(
reportIDs
.
length
)
{
if
(
this
.
autoSubmit
)
{
this
.
submitReports
(
reportIDs
)
;
}
else
if
(
this
.
shouldShowPendingSubmissionsNotification
(
)
)
{
return
this
.
showPendingSubmissionsNotification
(
reportIDs
)
;
}
}
return
null
;
}
shouldShowPendingSubmissionsNotification
(
)
{
if
(
!
this
.
prefs
.
prefHasUserValue
(
"
shutdownWhileShowing
"
)
)
{
return
true
;
}
let
shutdownWhileShowing
=
this
.
prefs
.
getBoolPref
(
"
shutdownWhileShowing
"
)
;
this
.
prefs
.
clearUserPref
(
"
shutdownWhileShowing
"
)
;
if
(
!
this
.
prefs
.
prefHasUserValue
(
"
lastShownDate
"
)
)
{
return
true
;
}
let
lastShownDate
=
this
.
prefs
.
getCharPref
(
"
lastShownDate
"
)
;
if
(
this
.
dateString
(
)
>
lastShownDate
&
&
shutdownWhileShowing
)
{
let
chances
=
this
.
prefs
.
getIntPref
(
"
chancesUntilSuppress
"
)
;
if
(
-
-
chances
<
0
)
{
this
.
prefs
.
clearUserPref
(
"
chancesUntilSuppress
"
)
;
let
suppressUntil
=
this
.
dateString
(
new
Date
(
Date
.
now
(
)
+
(
DAY
*
DAYS_TO_SUPPRESS
)
)
)
;
this
.
prefs
.
setCharPref
(
"
suppressUntilDate
"
suppressUntil
)
;
return
false
;
}
this
.
prefs
.
setIntPref
(
"
chancesUntilSuppress
"
chances
)
;
}
return
true
;
}
showPendingSubmissionsNotification
(
reportIDs
)
{
let
count
=
reportIDs
.
length
;
if
(
!
count
)
{
return
null
;
}
let
messageTemplate
=
gNavigatorBundle
.
GetStringFromName
(
"
pendingCrashReports2
.
label
"
)
;
let
message
=
PluralForm
.
get
(
count
messageTemplate
)
.
replace
(
"
#
1
"
count
)
;
let
notification
=
this
.
show
(
{
notificationID
:
"
pending
-
crash
-
reports
"
message
reportIDs
onAction
:
(
)
=
>
{
this
.
showingNotification
=
false
;
}
}
)
;
if
(
notification
)
{
this
.
showingNotification
=
true
;
this
.
prefs
.
setCharPref
(
"
lastShownDate
"
this
.
dateString
(
)
)
;
}
return
notification
;
}
dateString
(
someDate
=
new
Date
(
)
)
{
let
year
=
String
(
someDate
.
getFullYear
(
)
)
.
padStart
(
4
"
0
"
)
;
let
month
=
String
(
someDate
.
getMonth
(
)
+
1
)
.
padStart
(
2
"
0
"
)
;
let
day
=
String
(
someDate
.
getDate
(
)
)
.
padStart
(
2
"
0
"
)
;
return
year
+
month
+
day
;
}
show
(
{
notificationID
message
reportIDs
onAction
}
)
{
let
chromeWin
=
RecentWindow
.
getMostRecentBrowserWindow
(
)
;
if
(
!
chromeWin
)
{
return
null
;
}
let
nb
=
chromeWin
.
document
.
getElementById
(
"
global
-
notificationbox
"
)
;
let
notification
=
nb
.
getNotificationWithValue
(
notificationID
)
;
if
(
notification
)
{
return
null
;
}
let
buttons
=
[
{
label
:
gNavigatorBundle
.
GetStringFromName
(
"
pendingCrashReports
.
send
"
)
callback
:
(
)
=
>
{
this
.
submitReports
(
reportIDs
)
;
if
(
onAction
)
{
onAction
(
)
;
}
}
}
{
label
:
gNavigatorBundle
.
GetStringFromName
(
"
pendingCrashReports
.
alwaysSend
"
)
callback
:
(
)
=
>
{
this
.
autoSubmit
=
true
;
this
.
submitReports
(
reportIDs
)
;
if
(
onAction
)
{
onAction
(
)
;
}
}
}
{
label
:
gNavigatorBundle
.
GetStringFromName
(
"
pendingCrashReports
.
viewAll
"
)
callback
(
)
{
chromeWin
.
openUILinkIn
(
"
about
:
crashes
"
"
tab
"
)
;
return
true
;
}
}
]
;
let
eventCallback
=
(
eventType
)
=
>
{
if
(
eventType
=
=
"
dismissed
"
)
{
reportIDs
.
forEach
(
function
(
reportID
)
{
CrashSubmit
.
ignore
(
reportID
)
;
}
)
;
if
(
onAction
)
{
onAction
(
)
;
}
}
}
;
return
nb
.
appendNotification
(
message
notificationID
"
chrome
:
/
/
browser
/
skin
/
tab
-
crashed
.
svg
"
nb
.
PRIORITY_INFO_HIGH
buttons
eventCallback
)
;
}
get
autoSubmit
(
)
{
return
Services
.
prefs
.
getBoolPref
(
"
browser
.
crashReports
.
unsubmittedCheck
.
autoSubmit2
"
)
;
}
set
autoSubmit
(
val
)
{
Services
.
prefs
.
setBoolPref
(
"
browser
.
crashReports
.
unsubmittedCheck
.
autoSubmit2
"
val
)
;
}
submitReports
(
reportIDs
)
{
for
(
let
reportID
of
reportIDs
)
{
CrashSubmit
.
submit
(
reportID
{
extraExtraKeyVals
:
{
"
SubmittedFromInfobar
"
:
true
}
}
)
.
catch
(
Cu
.
reportError
)
;
}
}
}
;
this
.
PluginCrashReporter
=
{
init
(
)
{
if
(
this
.
initialized
)
{
return
;
}
this
.
initialized
=
true
;
this
.
crashReports
=
new
Map
(
)
;
Services
.
obs
.
addObserver
(
this
"
plugin
-
crashed
"
)
;
Services
.
obs
.
addObserver
(
this
"
gmp
-
plugin
-
crash
"
)
;
Services
.
obs
.
addObserver
(
this
"
profile
-
after
-
change
"
)
;
}
uninit
(
)
{
Services
.
obs
.
removeObserver
(
this
"
plugin
-
crashed
"
)
;
Services
.
obs
.
removeObserver
(
this
"
gmp
-
plugin
-
crash
"
)
;
Services
.
obs
.
removeObserver
(
this
"
profile
-
after
-
change
"
)
;
this
.
initialized
=
false
;
}
observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
"
plugin
-
crashed
"
:
{
let
propertyBag
=
subject
;
if
(
!
(
propertyBag
instanceof
Ci
.
nsIPropertyBag2
)
|
|
!
(
propertyBag
instanceof
Ci
.
nsIWritablePropertyBag2
)
|
|
!
propertyBag
.
hasKey
(
"
runID
"
)
|
|
!
propertyBag
.
hasKey
(
"
pluginDumpID
"
)
)
{
Cu
.
reportError
(
"
PluginCrashReporter
can
not
read
plugin
information
.
"
)
;
return
;
}
let
runID
=
propertyBag
.
getPropertyAsUint32
(
"
runID
"
)
;
let
pluginDumpID
=
propertyBag
.
getPropertyAsAString
(
"
pluginDumpID
"
)
;
let
browserDumpID
=
propertyBag
.
getPropertyAsAString
(
"
browserDumpID
"
)
;
if
(
pluginDumpID
)
{
this
.
crashReports
.
set
(
runID
{
pluginDumpID
browserDumpID
}
)
;
}
break
;
}
case
"
gmp
-
plugin
-
crash
"
:
{
let
propertyBag
=
subject
;
if
(
!
(
propertyBag
instanceof
Ci
.
nsIWritablePropertyBag2
)
|
|
!
propertyBag
.
hasKey
(
"
pluginID
"
)
|
|
!
propertyBag
.
hasKey
(
"
pluginDumpID
"
)
|
|
!
propertyBag
.
hasKey
(
"
pluginName
"
)
)
{
Cu
.
reportError
(
"
PluginCrashReporter
can
not
read
plugin
information
.
"
)
;
return
;
}
let
pluginID
=
propertyBag
.
getPropertyAsUint32
(
"
pluginID
"
)
;
let
pluginDumpID
=
propertyBag
.
getPropertyAsAString
(
"
pluginDumpID
"
)
;
if
(
pluginDumpID
)
{
this
.
crashReports
.
set
(
pluginID
{
pluginDumpID
}
)
;
}
if
(
Cc
[
"
mozilla
.
org
/
parentprocessmessagemanager
;
1
"
]
)
{
let
pluginName
=
propertyBag
.
getPropertyAsAString
(
"
pluginName
"
)
;
let
mm
=
Cc
[
"
mozilla
.
org
/
parentprocessmessagemanager
;
1
"
]
.
getService
(
Ci
.
nsIMessageListenerManager
)
;
mm
.
broadcastAsyncMessage
(
"
gmp
-
plugin
-
crash
"
{
pluginName
pluginID
}
)
;
}
break
;
}
case
"
profile
-
after
-
change
"
:
this
.
uninit
(
)
;
break
;
}
}
submitCrashReport
(
runID
keyVals
)
{
if
(
!
this
.
crashReports
.
has
(
runID
)
)
{
Cu
.
reportError
(
Could
not
find
plugin
dump
IDs
for
run
ID
{
runID
}
.
+
It
is
possible
that
a
report
was
already
submitted
.
)
;
return
;
}
keyVals
=
keyVals
|
|
{
}
;
let
{
pluginDumpID
browserDumpID
}
=
this
.
crashReports
.
get
(
runID
)
;
let
submissionPromise
=
CrashSubmit
.
submit
(
pluginDumpID
{
recordSubmission
:
true
extraExtraKeyVals
:
keyVals
}
)
;
if
(
browserDumpID
)
CrashSubmit
.
submit
(
browserDumpID
)
.
catch
(
Cu
.
reportError
)
;
this
.
broadcastState
(
runID
"
submitting
"
)
;
submissionPromise
.
then
(
(
)
=
>
{
this
.
broadcastState
(
runID
"
success
"
)
;
}
(
)
=
>
{
this
.
broadcastState
(
runID
"
failed
"
)
;
}
)
;
this
.
crashReports
.
delete
(
runID
)
;
}
broadcastState
(
runID
state
)
{
let
enumerator
=
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
;
while
(
enumerator
.
hasMoreElements
(
)
)
{
let
window
=
enumerator
.
getNext
(
)
;
let
mm
=
window
.
messageManager
;
mm
.
broadcastAsyncMessage
(
"
BrowserPlugins
:
CrashReportSubmitted
"
{
runID
state
}
)
;
}
}
hasCrashReport
(
runID
)
{
return
this
.
crashReports
.
has
(
runID
)
;
}
}
;
