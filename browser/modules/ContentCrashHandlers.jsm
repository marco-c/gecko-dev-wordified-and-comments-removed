"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
TabCrashHandler
"
"
UnsubmittedCrashHandler
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AppConstants
:
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
BrowserWindowTracker
:
"
resource
:
/
/
/
modules
/
BrowserWindowTracker
.
jsm
"
clearTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
CrashSubmit
:
"
resource
:
/
/
gre
/
modules
/
CrashSubmit
.
jsm
"
E10SUtils
:
"
resource
:
/
/
gre
/
modules
/
E10SUtils
.
jsm
"
PluralForm
:
"
resource
:
/
/
gre
/
modules
/
PluralForm
.
jsm
"
SessionStore
:
"
resource
:
/
/
/
modules
/
sessionstore
/
SessionStore
.
jsm
"
setTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gNavigatorBundle
"
function
(
)
{
const
url
=
"
chrome
:
/
/
browser
/
locale
/
browser
.
properties
"
;
return
Services
.
strings
.
createBundle
(
url
)
;
}
)
;
const
PENDING_CRASH_REPORT_DAYS
=
28
;
const
DAY
=
24
*
60
*
60
*
1000
;
const
DAYS_TO_SUPPRESS
=
30
;
const
MAX_UNSEEN_CRASHED_CHILD_IDS
=
20
;
const
MAX_UNSEEN_CRASHED_SUBFRAME_IDS
=
10
;
const
CHECK_FOR_UNSUBMITTED_CRASH_REPORTS_DELAY_MS
=
60
*
10000
;
const
TABCRASHED_ICON_URI
=
"
chrome
:
/
/
browser
/
skin
/
tab
-
crashed
.
svg
"
;
const
SUBFRAMECRASH_LEARNMORE_URI
=
"
https
:
/
/
support
.
mozilla
.
org
/
kb
/
firefox
-
crashes
-
troubleshoot
-
prevent
-
and
-
get
-
help
"
;
class
BrowserWeakMap
extends
WeakMap
{
get
(
browser
)
{
if
(
browser
.
permanentKey
)
{
return
super
.
get
(
browser
.
permanentKey
)
;
}
return
super
.
get
(
browser
)
;
}
set
(
browser
value
)
{
if
(
browser
.
permanentKey
)
{
return
super
.
set
(
browser
.
permanentKey
value
)
;
}
return
super
.
set
(
browser
value
)
;
}
delete
(
browser
)
{
if
(
browser
.
permanentKey
)
{
return
super
.
delete
(
browser
.
permanentKey
)
;
}
return
super
.
delete
(
browser
)
;
}
}
var
TabCrashHandler
=
{
_crashedTabCount
:
0
childMap
:
new
Map
(
)
browserMap
:
new
BrowserWeakMap
(
)
notificationsMap
:
new
Map
(
)
unseenCrashedChildIDs
:
[
]
pendingSubFrameCrashes
:
new
Map
(
)
pendingSubFrameCrashesIDs
:
[
]
crashedBrowserQueues
:
new
Map
(
)
restartRequiredBrowsers
:
new
WeakSet
(
)
testBuildIDMismatch
:
false
get
prefs
(
)
{
delete
this
.
prefs
;
return
(
this
.
prefs
=
Services
.
prefs
.
getBranch
(
"
browser
.
tabs
.
crashReporting
.
"
)
)
;
}
init
(
)
{
if
(
this
.
initialized
)
{
return
;
}
this
.
initialized
=
true
;
Services
.
obs
.
addObserver
(
this
"
ipc
:
content
-
shutdown
"
)
;
Services
.
obs
.
addObserver
(
this
"
oop
-
frameloader
-
crashed
"
)
;
}
observe
(
aSubject
aTopic
aData
)
{
switch
(
aTopic
)
{
case
"
ipc
:
content
-
shutdown
"
:
{
aSubject
.
QueryInterface
(
Ci
.
nsIPropertyBag2
)
;
if
(
!
aSubject
.
get
(
"
abnormal
"
)
)
{
return
;
}
let
childID
=
aSubject
.
get
(
"
childID
"
)
;
let
dumpID
=
aSubject
.
get
(
"
dumpID
"
)
;
let
subframeCrashItem
=
this
.
getAndRemoveSubframeCrash
(
childID
)
;
if
(
!
dumpID
)
{
Services
.
telemetry
.
getHistogramById
(
"
FX_CONTENT_CRASH_DUMP_UNAVAILABLE
"
)
.
add
(
1
)
;
}
else
if
(
AppConstants
.
MOZ_CRASHREPORTER
)
{
this
.
childMap
.
set
(
childID
dumpID
)
;
if
(
subframeCrashItem
)
{
let
browsers
=
ChromeUtils
.
nondeterministicGetWeakMapKeys
(
subframeCrashItem
)
|
|
[
]
;
for
(
let
browserItem
of
browsers
)
{
let
browser
=
subframeCrashItem
.
get
(
browserItem
)
;
if
(
browser
.
isConnected
&
&
!
browser
.
ownerGlobal
.
closed
)
{
this
.
showSubFrameNotification
(
browser
childID
dumpID
)
;
}
}
}
}
if
(
!
this
.
flushCrashedBrowserQueue
(
childID
)
)
{
this
.
unseenCrashedChildIDs
.
push
(
childID
)
;
if
(
this
.
unseenCrashedChildIDs
.
length
>
MAX_UNSEEN_CRASHED_CHILD_IDS
)
{
this
.
unseenCrashedChildIDs
.
shift
(
)
;
}
}
let
env
=
Cc
[
"
mozilla
.
org
/
process
/
environment
;
1
"
]
.
getService
(
Ci
.
nsIEnvironment
)
;
let
shutdown
=
env
.
exists
(
"
MOZ_CRASHREPORTER_SHUTDOWN
"
)
;
if
(
shutdown
)
{
dump
(
"
A
content
process
crashed
and
MOZ_CRASHREPORTER_SHUTDOWN
is
"
+
"
set
shutting
down
\
n
"
)
;
Services
.
startup
.
quit
(
Ci
.
nsIAppStartup
.
eForceQuit
)
;
}
break
;
}
case
"
oop
-
frameloader
-
crashed
"
:
{
let
browser
=
aSubject
.
ownerElement
;
if
(
!
browser
)
{
return
;
}
this
.
browserMap
.
set
(
browser
aSubject
.
childID
)
;
break
;
}
}
}
flushCrashedBrowserQueue
(
childID
)
{
let
browserQueue
=
this
.
crashedBrowserQueues
.
get
(
childID
)
;
if
(
!
browserQueue
)
{
return
false
;
}
this
.
crashedBrowserQueues
.
delete
(
childID
)
;
let
sentBrowser
=
false
;
for
(
let
weakBrowser
of
browserQueue
)
{
let
browser
=
weakBrowser
.
get
(
)
;
if
(
browser
)
{
if
(
this
.
restartRequiredBrowsers
.
has
(
browser
)
|
|
this
.
testBuildIDMismatch
)
{
this
.
sendToRestartRequiredPage
(
browser
)
;
}
else
{
this
.
sendToTabCrashedPage
(
browser
)
;
}
sentBrowser
=
true
;
}
}
return
sentBrowser
;
}
onSelectedBrowserCrash
(
browser
restartRequired
)
{
if
(
!
browser
.
isRemoteBrowser
)
{
Cu
.
reportError
(
"
Selected
crashed
browser
is
not
remote
.
"
)
;
return
;
}
if
(
!
browser
.
frameLoader
)
{
Cu
.
reportError
(
"
Selected
crashed
browser
has
no
frameloader
.
"
)
;
return
;
}
let
childID
=
browser
.
frameLoader
.
childID
;
let
browserQueue
=
this
.
crashedBrowserQueues
.
get
(
childID
)
;
if
(
!
browserQueue
)
{
browserQueue
=
[
]
;
this
.
crashedBrowserQueues
.
set
(
childID
browserQueue
)
;
}
browserQueue
.
push
(
Cu
.
getWeakReference
(
browser
)
)
;
if
(
restartRequired
)
{
this
.
restartRequiredBrowsers
.
add
(
browser
)
;
}
if
(
childID
=
=
0
)
{
this
.
flushCrashedBrowserQueue
(
0
)
;
}
}
onBackgroundBrowserCrash
(
browser
restartRequired
)
{
if
(
restartRequired
)
{
this
.
restartRequiredBrowsers
.
add
(
browser
)
;
}
let
gBrowser
=
browser
.
getTabBrowser
(
)
;
let
tab
=
gBrowser
.
getTabForBrowser
(
browser
)
;
gBrowser
.
updateBrowserRemoteness
(
browser
{
remoteType
:
E10SUtils
.
NOT_REMOTE
}
)
;
SessionStore
.
reviveCrashedTab
(
tab
)
;
}
async
onSubFrameCrash
(
browser
childID
)
{
if
(
!
AppConstants
.
MOZ_CRASHREPORTER
)
{
return
;
}
let
dumpID
=
this
.
childMap
.
get
(
childID
)
;
if
(
dumpID
)
{
this
.
showSubFrameNotification
(
browser
childID
dumpID
)
;
}
else
{
let
item
=
this
.
pendingSubFrameCrashes
.
get
(
childID
)
;
if
(
!
item
)
{
item
=
new
BrowserWeakMap
(
)
;
this
.
pendingSubFrameCrashes
.
set
(
childID
item
)
;
if
(
this
.
pendingSubFrameCrashesIDs
.
length
>
=
MAX_UNSEEN_CRASHED_SUBFRAME_IDS
)
{
let
idToDelete
=
this
.
pendingSubFrameCrashesIDs
.
shift
(
)
;
this
.
pendingSubFrameCrashes
.
delete
(
idToDelete
)
;
}
this
.
pendingSubFrameCrashesIDs
.
push
(
childID
)
;
}
item
.
set
(
browser
browser
)
;
}
}
getAndRemoveSubframeCrash
(
childID
)
{
let
item
=
this
.
pendingSubFrameCrashes
.
get
(
childID
)
;
if
(
item
)
{
this
.
pendingSubFrameCrashes
.
delete
(
childID
)
;
let
idx
=
this
.
pendingSubFrameCrashesIDs
.
indexOf
(
childID
)
;
if
(
idx
>
=
0
)
{
this
.
pendingSubFrameCrashesIDs
.
splice
(
idx
1
)
;
}
}
return
item
;
}
showSubFrameNotification
(
browser
childID
dumpID
)
{
let
gBrowser
=
browser
.
getTabBrowser
(
)
;
let
notificationBox
=
gBrowser
.
getNotificationBox
(
browser
)
;
const
value
=
"
subframe
-
crashed
"
;
let
notification
=
notificationBox
.
getNotificationWithValue
(
value
)
;
if
(
notification
)
{
return
;
}
let
closeAllNotifications
=
(
)
=
>
{
let
existingItem
=
this
.
notificationsMap
.
get
(
childID
)
;
if
(
existingItem
)
{
for
(
let
notif
of
existingItem
.
slice
(
)
)
{
notif
.
close
(
)
;
}
}
}
;
let
doc
=
browser
.
ownerDocument
;
let
messageFragment
=
doc
.
createDocumentFragment
(
)
;
let
message
=
doc
.
createElement
(
"
span
"
)
;
message
.
setAttribute
(
"
data
-
l10n
-
id
"
"
crashed
-
subframe
-
message
"
)
;
messageFragment
.
appendChild
(
message
)
;
let
buttons
=
[
{
"
l10n
-
id
"
:
"
crashed
-
subframe
-
learnmore
-
link
"
popup
:
null
link
:
SUBFRAMECRASH_LEARNMORE_URI
}
{
"
l10n
-
id
"
:
"
crashed
-
subframe
-
submit
"
popup
:
null
callback
:
async
(
)
=
>
{
if
(
dumpID
)
{
UnsubmittedCrashHandler
.
submitReports
(
[
dumpID
]
)
;
}
closeAllNotifications
(
)
;
}
}
]
;
notification
=
notificationBox
.
appendNotification
(
value
{
label
:
messageFragment
image
:
TABCRASHED_ICON_URI
priority
:
notificationBox
.
PRIORITY_INFO_MEDIUM
telemetry
:
"
notificationbar
.
crash_subframe_ui
"
eventCallback
:
eventName
=
>
{
if
(
eventName
=
=
"
disconnected
"
)
{
let
existingItem
=
this
.
notificationsMap
.
get
(
childID
)
;
if
(
existingItem
)
{
let
idx
=
existingItem
.
indexOf
(
notification
)
;
if
(
idx
>
=
0
)
{
existingItem
.
splice
(
idx
1
)
;
}
if
(
!
existingItem
.
length
)
{
this
.
notificationsMap
.
delete
(
childID
)
;
}
}
}
else
if
(
eventName
=
=
"
dismissed
"
)
{
if
(
dumpID
)
{
CrashSubmit
.
ignore
(
dumpID
)
;
this
.
childMap
.
delete
(
childID
)
;
}
closeAllNotifications
(
)
;
}
}
}
buttons
)
;
let
existingItem
=
this
.
notificationsMap
.
get
(
childID
)
;
if
(
existingItem
)
{
existingItem
.
push
(
notification
)
;
}
else
{
this
.
notificationsMap
.
set
(
childID
[
notification
]
)
;
}
}
willShowCrashedTab
(
browser
)
{
let
childID
=
this
.
browserMap
.
get
(
browser
)
;
if
(
childID
&
&
this
.
unseenCrashedChildIDs
.
includes
(
childID
)
)
{
if
(
UnsubmittedCrashHandler
.
autoSubmit
)
{
let
dumpID
=
this
.
childMap
.
get
(
childID
)
;
if
(
dumpID
)
{
UnsubmittedCrashHandler
.
submitReports
(
[
dumpID
]
)
;
}
}
else
{
this
.
sendToTabCrashedPage
(
browser
)
;
return
true
;
}
}
else
if
(
childID
=
=
=
0
)
{
if
(
this
.
restartRequiredBrowsers
.
has
(
browser
)
)
{
this
.
sendToRestartRequiredPage
(
browser
)
;
}
else
{
this
.
sendToTabCrashedPage
(
browser
)
;
}
return
true
;
}
return
false
;
}
sendToRestartRequiredPage
(
browser
)
{
let
uri
=
browser
.
currentURI
;
let
gBrowser
=
browser
.
getTabBrowser
(
)
;
let
tab
=
gBrowser
.
getTabForBrowser
(
browser
)
;
gBrowser
.
updateBrowserRemoteness
(
browser
{
remoteType
:
E10SUtils
.
NOT_REMOTE
}
)
;
browser
.
docShell
.
displayLoadError
(
Cr
.
NS_ERROR_BUILDID_MISMATCH
uri
null
)
;
tab
.
setAttribute
(
"
crashed
"
true
)
;
if
(
this
.
_crashedTabCount
=
=
1
)
{
Services
.
telemetry
.
scalarAdd
(
"
dom
.
contentprocess
.
buildID_mismatch
"
1
)
;
}
}
sendToTabCrashedPage
(
browser
)
{
let
title
=
browser
.
contentTitle
;
let
uri
=
browser
.
currentURI
;
let
gBrowser
=
browser
.
getTabBrowser
(
)
;
let
tab
=
gBrowser
.
getTabForBrowser
(
browser
)
;
gBrowser
.
updateBrowserRemoteness
(
browser
{
remoteType
:
E10SUtils
.
NOT_REMOTE
}
)
;
browser
.
setAttribute
(
"
crashedPageTitle
"
title
)
;
browser
.
docShell
.
displayLoadError
(
Cr
.
NS_ERROR_CONTENT_CRASHED
uri
null
)
;
browser
.
removeAttribute
(
"
crashedPageTitle
"
)
;
tab
.
setAttribute
(
"
crashed
"
true
)
;
}
maybeSendCrashReport
(
browser
message
)
{
if
(
!
AppConstants
.
MOZ_CRASHREPORTER
)
{
return
;
}
if
(
!
message
.
data
.
hasReport
)
{
return
;
}
if
(
message
.
data
.
autoSubmit
)
{
UnsubmittedCrashHandler
.
autoSubmit
=
true
;
}
let
childID
=
this
.
browserMap
.
get
(
browser
)
;
let
dumpID
=
this
.
childMap
.
get
(
childID
)
;
if
(
!
dumpID
)
{
return
;
}
if
(
!
message
.
data
.
sendReport
)
{
Services
.
telemetry
.
getHistogramById
(
"
FX_CONTENT_CRASH_NOT_SUBMITTED
"
)
.
add
(
1
)
;
this
.
prefs
.
setBoolPref
(
"
sendReport
"
false
)
;
return
;
}
let
{
includeURL
comments
URL
}
=
message
.
data
;
let
extraExtraKeyVals
=
{
Comments
:
comments
URL
}
;
for
(
let
key
in
extraExtraKeyVals
)
{
let
val
=
extraExtraKeyVals
[
key
]
.
trim
(
)
;
if
(
!
val
)
{
delete
extraExtraKeyVals
[
key
]
;
}
}
if
(
!
includeURL
)
{
extraExtraKeyVals
.
URL
=
"
"
;
}
CrashSubmit
.
submit
(
dumpID
{
recordSubmission
:
true
extraExtraKeyVals
}
)
.
catch
(
Cu
.
reportError
)
;
this
.
prefs
.
setBoolPref
(
"
sendReport
"
true
)
;
this
.
prefs
.
setBoolPref
(
"
includeURL
"
includeURL
)
;
this
.
childMap
.
set
(
childID
null
)
;
this
.
removeSubmitCheckboxesForSameCrash
(
childID
)
;
}
removeSubmitCheckboxesForSameCrash
(
childID
)
{
for
(
let
window
of
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
)
{
if
(
!
window
.
gMultiProcessBrowser
)
{
continue
;
}
for
(
let
browser
of
window
.
gBrowser
.
browsers
)
{
if
(
browser
.
isRemoteBrowser
)
{
continue
;
}
let
doc
=
browser
.
contentDocument
;
if
(
!
doc
.
documentURI
.
startsWith
(
"
about
:
tabcrashed
"
)
)
{
continue
;
}
if
(
this
.
browserMap
.
get
(
browser
)
=
=
childID
)
{
this
.
browserMap
.
delete
(
browser
)
;
browser
.
sendMessageToActor
(
"
CrashReportSent
"
{
}
"
AboutTabCrashed
"
)
;
}
}
}
}
onAboutTabCrashedLoad
(
browser
)
{
this
.
_crashedTabCount
+
+
;
let
window
=
browser
.
ownerGlobal
;
window
.
ZoomManager
.
setZoomForBrowser
(
browser
1
)
;
let
childID
=
this
.
browserMap
.
get
(
browser
)
;
let
index
=
this
.
unseenCrashedChildIDs
.
indexOf
(
childID
)
;
if
(
index
!
=
-
1
)
{
this
.
unseenCrashedChildIDs
.
splice
(
index
1
)
;
}
if
(
browser
.
getTabBrowser
(
)
.
selectedBrowser
=
=
browser
)
{
Services
.
telemetry
.
scalarAdd
(
"
dom
.
contentprocess
.
crash_tab_ui_presented
"
1
)
;
}
let
dumpID
=
this
.
getDumpID
(
browser
)
;
if
(
!
dumpID
)
{
return
{
hasReport
:
false
}
;
}
let
requestAutoSubmit
=
!
UnsubmittedCrashHandler
.
autoSubmit
;
let
sendReport
=
this
.
prefs
.
getBoolPref
(
"
sendReport
"
)
;
let
includeURL
=
this
.
prefs
.
getBoolPref
(
"
includeURL
"
)
;
let
data
=
{
hasReport
:
true
sendReport
includeURL
requestAutoSubmit
}
;
return
data
;
}
onAboutTabCrashedUnload
(
browser
)
{
if
(
!
this
.
_crashedTabCount
)
{
Cu
.
reportError
(
"
Can
not
decrement
crashed
tab
count
to
below
0
"
)
;
return
;
}
this
.
_crashedTabCount
-
-
;
let
childID
=
this
.
browserMap
.
get
(
browser
)
;
if
(
this
.
_crashedTabCount
=
=
0
&
&
childID
)
{
Services
.
telemetry
.
getHistogramById
(
"
FX_CONTENT_CRASH_NOT_SUBMITTED
"
)
.
add
(
1
)
;
}
}
getDumpID
(
browser
)
{
if
(
!
AppConstants
.
MOZ_CRASHREPORTER
)
{
return
null
;
}
return
this
.
childMap
.
get
(
this
.
browserMap
.
get
(
browser
)
)
;
}
get
queuedCrashedBrowsers
(
)
{
return
this
.
crashedBrowserQueues
.
size
;
}
}
;
var
UnsubmittedCrashHandler
=
{
get
prefs
(
)
{
delete
this
.
prefs
;
return
(
this
.
prefs
=
Services
.
prefs
.
getBranch
(
"
browser
.
crashReports
.
unsubmittedCheck
.
"
)
)
;
}
get
enabled
(
)
{
return
this
.
prefs
.
getBoolPref
(
"
enabled
"
)
;
}
showingNotification
:
false
suppressed
:
false
_checkTimeout
:
null
init
(
)
{
if
(
this
.
initialized
)
{
return
;
}
this
.
initialized
=
true
;
if
(
this
.
enabled
)
{
if
(
this
.
prefs
.
prefHasUserValue
(
"
suppressUntilDate
"
)
)
{
if
(
this
.
prefs
.
getCharPref
(
"
suppressUntilDate
"
)
>
this
.
dateString
(
)
)
{
this
.
suppressed
=
true
;
return
;
}
this
.
prefs
.
clearUserPref
(
"
suppressUntilDate
"
)
;
}
Services
.
obs
.
addObserver
(
this
"
profile
-
before
-
change
"
)
;
}
}
uninit
(
)
{
if
(
!
this
.
initialized
)
{
return
;
}
this
.
initialized
=
false
;
if
(
this
.
_checkTimeout
)
{
clearTimeout
(
this
.
_checkTimeout
)
;
this
.
_checkTimeout
=
null
;
}
if
(
!
this
.
enabled
)
{
return
;
}
if
(
this
.
suppressed
)
{
this
.
suppressed
=
false
;
return
;
}
if
(
this
.
showingNotification
)
{
this
.
prefs
.
setBoolPref
(
"
shutdownWhileShowing
"
true
)
;
this
.
showingNotification
=
false
;
}
Services
.
obs
.
removeObserver
(
this
"
profile
-
before
-
change
"
)
;
}
observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
"
profile
-
before
-
change
"
:
{
this
.
uninit
(
)
;
break
;
}
}
}
scheduleCheckForUnsubmittedCrashReports
(
)
{
this
.
_checkTimeout
=
setTimeout
(
(
)
=
>
{
Services
.
tm
.
idleDispatchToMainThread
(
(
)
=
>
{
this
.
checkForUnsubmittedCrashReports
(
)
;
}
)
;
}
CHECK_FOR_UNSUBMITTED_CRASH_REPORTS_DELAY_MS
)
;
}
async
checkForUnsubmittedCrashReports
(
)
{
if
(
!
this
.
enabled
|
|
this
.
suppressed
)
{
return
null
;
}
let
dateLimit
=
new
Date
(
)
;
dateLimit
.
setDate
(
dateLimit
.
getDate
(
)
-
PENDING_CRASH_REPORT_DAYS
)
;
let
reportIDs
=
[
]
;
try
{
reportIDs
=
await
CrashSubmit
.
pendingIDs
(
dateLimit
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
return
null
;
}
if
(
reportIDs
.
length
)
{
if
(
this
.
autoSubmit
)
{
this
.
submitReports
(
reportIDs
)
;
}
else
if
(
this
.
shouldShowPendingSubmissionsNotification
(
)
)
{
return
this
.
showPendingSubmissionsNotification
(
reportIDs
)
;
}
}
return
null
;
}
shouldShowPendingSubmissionsNotification
(
)
{
if
(
!
this
.
prefs
.
prefHasUserValue
(
"
shutdownWhileShowing
"
)
)
{
return
true
;
}
let
shutdownWhileShowing
=
this
.
prefs
.
getBoolPref
(
"
shutdownWhileShowing
"
)
;
this
.
prefs
.
clearUserPref
(
"
shutdownWhileShowing
"
)
;
if
(
!
this
.
prefs
.
prefHasUserValue
(
"
lastShownDate
"
)
)
{
return
true
;
}
let
lastShownDate
=
this
.
prefs
.
getCharPref
(
"
lastShownDate
"
)
;
if
(
this
.
dateString
(
)
>
lastShownDate
&
&
shutdownWhileShowing
)
{
let
chances
=
this
.
prefs
.
getIntPref
(
"
chancesUntilSuppress
"
)
;
if
(
-
-
chances
<
0
)
{
this
.
prefs
.
clearUserPref
(
"
chancesUntilSuppress
"
)
;
let
suppressUntil
=
this
.
dateString
(
new
Date
(
Date
.
now
(
)
+
DAY
*
DAYS_TO_SUPPRESS
)
)
;
this
.
prefs
.
setCharPref
(
"
suppressUntilDate
"
suppressUntil
)
;
return
false
;
}
this
.
prefs
.
setIntPref
(
"
chancesUntilSuppress
"
chances
)
;
}
return
true
;
}
showPendingSubmissionsNotification
(
reportIDs
)
{
let
count
=
reportIDs
.
length
;
if
(
!
count
)
{
return
null
;
}
let
messageTemplate
=
gNavigatorBundle
.
GetStringFromName
(
"
pendingCrashReports2
.
label
"
)
;
let
message
=
PluralForm
.
get
(
count
messageTemplate
)
.
replace
(
"
#
1
"
count
)
;
let
notification
=
this
.
show
(
{
notificationID
:
"
pending
-
crash
-
reports
"
message
reportIDs
onAction
:
(
)
=
>
{
this
.
showingNotification
=
false
;
}
}
)
;
if
(
notification
)
{
this
.
showingNotification
=
true
;
this
.
prefs
.
setCharPref
(
"
lastShownDate
"
this
.
dateString
(
)
)
;
}
return
notification
;
}
dateString
(
someDate
=
new
Date
(
)
)
{
let
year
=
String
(
someDate
.
getFullYear
(
)
)
.
padStart
(
4
"
0
"
)
;
let
month
=
String
(
someDate
.
getMonth
(
)
+
1
)
.
padStart
(
2
"
0
"
)
;
let
day
=
String
(
someDate
.
getDate
(
)
)
.
padStart
(
2
"
0
"
)
;
return
year
+
month
+
day
;
}
show
(
{
notificationID
message
reportIDs
onAction
}
)
{
let
chromeWin
=
BrowserWindowTracker
.
getTopWindow
(
)
;
if
(
!
chromeWin
)
{
return
null
;
}
let
notification
=
chromeWin
.
gNotificationBox
.
getNotificationWithValue
(
notificationID
)
;
if
(
notification
)
{
return
null
;
}
let
buttons
=
[
{
label
:
gNavigatorBundle
.
GetStringFromName
(
"
pendingCrashReports
.
send
"
)
callback
:
(
)
=
>
{
this
.
submitReports
(
reportIDs
)
;
if
(
onAction
)
{
onAction
(
)
;
}
}
}
{
label
:
gNavigatorBundle
.
GetStringFromName
(
"
pendingCrashReports
.
alwaysSend
"
)
callback
:
(
)
=
>
{
this
.
autoSubmit
=
true
;
this
.
submitReports
(
reportIDs
)
;
if
(
onAction
)
{
onAction
(
)
;
}
}
}
{
label
:
gNavigatorBundle
.
GetStringFromName
(
"
pendingCrashReports
.
viewAll
"
)
callback
(
)
{
chromeWin
.
openTrustedLinkIn
(
"
about
:
crashes
"
"
tab
"
)
;
return
true
;
}
}
]
;
let
eventCallback
=
eventType
=
>
{
if
(
eventType
=
=
"
dismissed
"
)
{
reportIDs
.
forEach
(
function
(
reportID
)
{
CrashSubmit
.
ignore
(
reportID
)
;
}
)
;
if
(
onAction
)
{
onAction
(
)
;
}
}
}
;
Services
.
telemetry
.
scalarAdd
(
"
dom
.
contentprocess
.
unsubmitted_ui_presented
"
1
)
;
return
chromeWin
.
gNotificationBox
.
appendNotification
(
notificationID
{
label
:
message
image
:
TABCRASHED_ICON_URI
priority
:
chromeWin
.
gNotificationBox
.
PRIORITY_INFO_HIGH
eventCallback
}
buttons
)
;
}
get
autoSubmit
(
)
{
return
Services
.
prefs
.
getBoolPref
(
"
browser
.
crashReports
.
unsubmittedCheck
.
autoSubmit2
"
)
;
}
set
autoSubmit
(
val
)
{
Services
.
prefs
.
setBoolPref
(
"
browser
.
crashReports
.
unsubmittedCheck
.
autoSubmit2
"
val
)
;
}
submitReports
(
reportIDs
)
{
for
(
let
reportID
of
reportIDs
)
{
CrashSubmit
.
submit
(
reportID
{
extraExtraKeyVals
:
{
SubmittedFromInfobar
:
"
1
"
}
}
)
.
catch
(
Cu
.
reportError
)
;
}
}
}
;
