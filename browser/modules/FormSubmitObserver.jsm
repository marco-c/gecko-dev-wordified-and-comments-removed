"
use
strict
"
;
var
Cc
=
Components
.
classes
;
var
Ci
=
Components
.
interfaces
;
var
Cu
=
Components
.
utils
;
var
HTMLInputElement
=
Ci
.
nsIDOMHTMLInputElement
;
var
HTMLTextAreaElement
=
Ci
.
nsIDOMHTMLTextAreaElement
;
var
HTMLSelectElement
=
Ci
.
nsIDOMHTMLSelectElement
;
var
HTMLButtonElement
=
Ci
.
nsIDOMHTMLButtonElement
;
this
.
EXPORTED_SYMBOLS
=
[
"
FormSubmitObserver
"
]
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
BrowserUtils
.
jsm
"
)
;
function
FormSubmitObserver
(
aWindow
aTabChildGlobal
)
{
this
.
init
(
aWindow
aTabChildGlobal
)
;
}
FormSubmitObserver
.
prototype
=
{
_validationMessage
:
"
"
_content
:
null
_element
:
null
init
(
aWindow
aTabChildGlobal
)
{
this
.
_content
=
aWindow
;
this
.
_tab
=
aTabChildGlobal
;
this
.
_mm
=
this
.
_content
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDocShell
)
.
sameTypeRootTreeItem
.
QueryInterface
(
Ci
.
nsIDocShell
)
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIContentFrameMessageManager
)
;
Services
.
obs
.
addObserver
(
this
"
invalidformsubmit
"
false
)
;
this
.
_tab
.
addEventListener
(
"
pageshow
"
this
)
;
this
.
_tab
.
addEventListener
(
"
unload
"
this
)
;
}
uninit
(
)
{
Services
.
obs
.
removeObserver
(
this
"
invalidformsubmit
"
)
;
this
.
_content
.
removeEventListener
(
"
pageshow
"
this
)
;
this
.
_content
.
removeEventListener
(
"
unload
"
this
)
;
this
.
_mm
=
null
;
this
.
_element
=
null
;
this
.
_content
=
null
;
this
.
_tab
=
null
;
}
handleEvent
(
aEvent
)
{
switch
(
aEvent
.
type
)
{
case
"
pageshow
"
:
if
(
this
.
_isRootDocumentEvent
(
aEvent
)
)
{
this
.
_hidePopup
(
)
;
}
break
;
case
"
unload
"
:
this
.
uninit
(
)
;
break
;
case
"
input
"
:
this
.
_onInput
(
aEvent
)
;
break
;
case
"
blur
"
:
this
.
_onBlur
(
aEvent
)
;
break
;
}
}
notifyInvalidSubmit
(
aFormElement
aInvalidElements
)
{
if
(
!
aInvalidElements
.
length
)
{
return
;
}
for
(
let
i
=
0
;
i
<
aInvalidElements
.
length
;
i
+
+
)
{
let
element
=
aInvalidElements
.
queryElementAt
(
i
Ci
.
nsISupports
)
;
if
(
this
.
_content
!
=
element
.
ownerGlobal
.
top
.
document
.
defaultView
)
{
return
;
}
if
(
!
(
element
instanceof
HTMLInputElement
|
|
element
instanceof
HTMLTextAreaElement
|
|
element
instanceof
HTMLSelectElement
|
|
element
instanceof
HTMLButtonElement
)
)
{
continue
;
}
if
(
!
Services
.
focus
.
elementIsFocusable
(
element
0
)
)
{
continue
;
}
this
.
_validationMessage
=
element
.
validationMessage
;
if
(
this
.
_element
=
=
element
)
{
this
.
_showPopup
(
element
)
;
break
;
}
this
.
_element
=
element
;
element
.
focus
(
)
;
element
.
addEventListener
(
"
input
"
this
)
;
element
.
addEventListener
(
"
blur
"
this
)
;
this
.
_showPopup
(
element
)
;
break
;
}
}
_onInput
(
aEvent
)
{
let
element
=
aEvent
.
originalTarget
;
if
(
element
.
validity
.
valid
)
{
this
.
_hidePopup
(
)
;
return
;
}
if
(
this
.
_validationMessage
!
=
element
.
validationMessage
)
{
this
.
_validationMessage
=
element
.
validationMessage
;
this
.
_showPopup
(
element
)
;
}
}
_onBlur
(
aEvent
)
{
aEvent
.
originalTarget
.
removeEventListener
(
"
input
"
this
)
;
aEvent
.
originalTarget
.
removeEventListener
(
"
blur
"
this
)
;
this
.
_element
=
null
;
this
.
_hidePopup
(
)
;
}
_showPopup
(
aElement
)
{
let
panelData
=
{
}
;
panelData
.
message
=
this
.
_validationMessage
;
panelData
.
contentRect
=
BrowserUtils
.
getElementBoundingRect
(
aElement
)
;
let
offset
=
0
;
if
(
aElement
.
tagName
=
=
'
INPUT
'
&
&
(
aElement
.
type
=
=
'
radio
'
|
|
aElement
.
type
=
=
'
checkbox
'
)
)
{
panelData
.
position
=
"
bottomcenter
topleft
"
;
}
else
{
let
win
=
aElement
.
ownerGlobal
;
let
style
=
win
.
getComputedStyle
(
aElement
null
)
;
if
(
style
.
direction
=
=
'
rtl
'
)
{
offset
=
parseInt
(
style
.
paddingRight
)
+
parseInt
(
style
.
borderRightWidth
)
;
}
else
{
offset
=
parseInt
(
style
.
paddingLeft
)
+
parseInt
(
style
.
borderLeftWidth
)
;
}
let
zoomFactor
=
this
.
_getWindowUtils
(
)
.
fullZoom
;
panelData
.
offset
=
Math
.
round
(
offset
*
zoomFactor
)
;
panelData
.
position
=
"
after_start
"
;
}
this
.
_mm
.
sendAsyncMessage
(
"
FormValidation
:
ShowPopup
"
panelData
)
;
}
_hidePopup
(
)
{
this
.
_mm
.
sendAsyncMessage
(
"
FormValidation
:
HidePopup
"
{
}
)
;
}
_getWindowUtils
(
)
{
return
this
.
_content
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
}
_isRootDocumentEvent
(
aEvent
)
{
if
(
this
.
_content
=
=
null
)
{
return
true
;
}
let
target
=
aEvent
.
originalTarget
;
return
(
target
=
=
this
.
_content
.
document
|
|
(
target
.
ownerDocument
&
&
target
.
ownerDocument
=
=
this
.
_content
.
document
)
)
;
}
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIFormSubmitObserver
]
)
}
;
