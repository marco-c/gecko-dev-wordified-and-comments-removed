"
use
strict
"
;
var
Cc
=
Components
.
classes
;
var
Ci
=
Components
.
interfaces
;
var
Cu
=
Components
.
utils
;
this
.
EXPORTED_SYMBOLS
=
[
"
ProcessHangMonitor
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
var
ProcessHangMonitor
=
{
get
WAIT_EXPIRATION_TIME
(
)
{
try
{
return
Services
.
prefs
.
getIntPref
(
"
browser
.
hangNotification
.
waitPeriod
"
)
;
}
catch
(
ex
)
{
return
10000
;
}
}
_shuttingDown
:
false
_activeReports
:
new
Set
(
)
_pausedReports
:
new
Map
(
)
init
(
)
{
Services
.
obs
.
addObserver
(
this
"
process
-
hang
-
report
"
)
;
Services
.
obs
.
addObserver
(
this
"
clear
-
hang
-
report
"
)
;
Services
.
obs
.
addObserver
(
this
"
quit
-
application
-
granted
"
)
;
Services
.
obs
.
addObserver
(
this
"
xpcom
-
shutdown
"
)
;
Services
.
ww
.
registerNotification
(
this
)
;
}
terminateScript
(
win
)
{
this
.
handleUserInput
(
win
report
=
>
report
.
terminateScript
(
)
)
;
}
terminateGlobal
(
win
)
{
this
.
handleUserInput
(
win
report
=
>
report
.
terminateGlobal
(
)
)
;
}
debugScript
(
win
)
{
this
.
handleUserInput
(
win
report
=
>
{
function
callback
(
)
{
report
.
endStartingDebugger
(
)
;
}
report
.
beginStartingDebugger
(
)
;
let
svc
=
Cc
[
"
mozilla
.
org
/
dom
/
slow
-
script
-
debug
;
1
"
]
.
getService
(
Ci
.
nsISlowScriptDebug
)
;
let
handler
=
svc
.
remoteActivationHandler
;
handler
.
handleSlowScriptDebug
(
report
.
scriptBrowser
callback
)
;
}
)
;
}
terminatePlugin
(
win
)
{
this
.
handleUserInput
(
win
report
=
>
report
.
terminatePlugin
(
)
)
;
}
stopIt
(
win
)
{
let
report
=
this
.
findActiveReport
(
win
.
gBrowser
.
selectedBrowser
)
;
if
(
!
report
)
{
return
;
}
switch
(
report
.
hangType
)
{
case
report
.
SLOW_SCRIPT
:
this
.
terminateScript
(
win
)
;
break
;
case
report
.
PLUGIN_HANG
:
this
.
terminatePlugin
(
win
)
;
break
;
}
}
stopGlobal
(
win
)
{
let
report
=
this
.
findActiveReport
(
win
.
gBrowser
.
selectedBrowser
)
;
if
(
!
report
)
{
return
;
}
switch
(
report
.
hangType
)
{
case
report
.
SLOW_SCRIPT
:
this
.
terminateGlobal
(
win
)
;
break
;
}
}
stopHang
(
report
)
{
switch
(
report
.
hangType
)
{
case
report
.
SLOW_SCRIPT
:
{
if
(
report
.
addonId
)
{
report
.
terminateGlobal
(
)
;
}
else
{
report
.
terminateScript
(
)
;
}
break
;
}
case
report
.
PLUGIN_HANG
:
{
report
.
terminatePlugin
(
)
;
break
;
}
}
}
waitLonger
(
win
)
{
let
report
=
this
.
findActiveReport
(
win
.
gBrowser
.
selectedBrowser
)
;
if
(
!
report
)
{
return
;
}
this
.
removeActiveReport
(
report
)
;
let
timer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
timer
.
initWithCallback
(
(
)
=
>
{
for
(
let
[
stashedReport
otherTimer
]
of
this
.
_pausedReports
)
{
if
(
otherTimer
=
=
=
timer
)
{
this
.
removePausedReport
(
stashedReport
)
;
this
.
_activeReports
.
add
(
report
)
;
this
.
updateWindows
(
)
;
break
;
}
}
}
this
.
WAIT_EXPIRATION_TIME
timer
.
TYPE_ONE_SHOT
)
;
this
.
_pausedReports
.
set
(
report
timer
)
;
this
.
updateWindows
(
)
;
}
handleUserInput
(
win
func
)
{
let
report
=
this
.
findActiveReport
(
win
.
gBrowser
.
selectedBrowser
)
;
if
(
!
report
)
{
return
null
;
}
this
.
removeActiveReport
(
report
)
;
return
func
(
report
)
;
}
observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
"
xpcom
-
shutdown
"
:
{
Services
.
obs
.
removeObserver
(
this
"
xpcom
-
shutdown
"
)
;
Services
.
obs
.
removeObserver
(
this
"
process
-
hang
-
report
"
)
;
Services
.
obs
.
removeObserver
(
this
"
clear
-
hang
-
report
"
)
;
Services
.
obs
.
removeObserver
(
this
"
quit
-
application
-
granted
"
)
;
Services
.
ww
.
unregisterNotification
(
this
)
;
break
;
}
case
"
quit
-
application
-
granted
"
:
{
this
.
onQuitApplicationGranted
(
)
;
break
;
}
case
"
process
-
hang
-
report
"
:
{
this
.
reportHang
(
subject
.
QueryInterface
(
Ci
.
nsIHangReport
)
)
;
break
;
}
case
"
clear
-
hang
-
report
"
:
{
this
.
clearHang
(
subject
.
QueryInterface
(
Ci
.
nsIHangReport
)
)
;
break
;
}
case
"
domwindowopened
"
:
{
let
win
=
subject
.
QueryInterface
(
Ci
.
nsIDOMWindow
)
;
let
listener
=
(
ev
)
=
>
{
win
.
removeEventListener
(
"
load
"
listener
true
)
;
this
.
updateWindows
(
)
;
}
;
win
.
addEventListener
(
"
load
"
listener
true
)
;
break
;
}
case
"
domwindowclosed
"
:
{
let
win
=
subject
.
QueryInterface
(
Ci
.
nsIDOMWindow
)
;
this
.
onWindowClosed
(
win
)
;
break
;
}
}
}
onQuitApplicationGranted
(
)
{
this
.
_shuttingDown
=
true
;
this
.
stopAllHangs
(
)
;
this
.
updateWindows
(
)
;
}
onWindowClosed
(
win
)
{
let
maybeStopHang
=
(
report
)
=
>
{
if
(
report
.
hangType
=
=
report
.
SLOW_SCRIPT
)
{
let
hungBrowserWindow
=
null
;
try
{
hungBrowserWindow
=
report
.
scriptBrowser
.
ownerGlobal
;
}
catch
(
e
)
{
}
if
(
!
hungBrowserWindow
|
|
hungBrowserWindow
=
=
win
)
{
this
.
stopHang
(
report
)
;
return
true
;
}
}
else
if
(
report
.
hangType
=
=
report
.
PLUGIN_HANG
)
{
this
.
stopHang
(
report
)
;
return
true
;
}
return
false
;
}
;
for
(
let
report
of
this
.
_activeReports
)
{
if
(
maybeStopHang
(
report
)
)
{
this
.
_activeReports
.
delete
(
report
)
;
}
}
for
(
let
[
pausedReport
]
of
this
.
_pausedReports
)
{
if
(
maybeStopHang
(
pausedReport
)
)
{
this
.
removePausedReport
(
pausedReport
)
;
}
}
this
.
updateWindows
(
)
;
}
stopAllHangs
(
)
{
for
(
let
report
of
this
.
_activeReports
)
{
this
.
stopHang
(
report
)
;
}
this
.
_activeReports
=
new
Set
(
)
;
for
(
let
[
pausedReport
]
of
this
.
_pausedReports
)
{
this
.
stopHang
(
pausedReport
)
;
this
.
removePausedReport
(
pausedReport
)
;
}
}
findActiveReport
(
browser
)
{
let
frameLoader
=
browser
.
frameLoader
;
for
(
let
report
of
this
.
_activeReports
)
{
if
(
report
.
isReportForBrowser
(
frameLoader
)
)
{
return
report
;
}
}
return
null
;
}
findPausedReport
(
browser
)
{
let
frameLoader
=
browser
.
frameLoader
;
for
(
let
[
report
]
of
this
.
_pausedReports
)
{
if
(
report
.
isReportForBrowser
(
frameLoader
)
)
{
return
report
;
}
}
return
null
;
}
removeActiveReport
(
report
)
{
this
.
_activeReports
.
delete
(
report
)
;
this
.
updateWindows
(
)
;
}
removePausedReport
(
report
)
{
let
timer
=
this
.
_pausedReports
.
get
(
report
)
;
if
(
timer
)
{
timer
.
cancel
(
)
;
}
this
.
_pausedReports
.
delete
(
report
)
;
}
updateWindows
(
)
{
let
e
=
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
;
if
(
!
e
.
hasMoreElements
(
)
)
{
this
.
stopAllHangs
(
)
;
return
;
}
while
(
e
.
hasMoreElements
(
)
)
{
let
win
=
e
.
getNext
(
)
;
this
.
updateWindow
(
win
)
;
if
(
this
.
_activeReports
.
size
)
{
this
.
trackWindow
(
win
)
;
}
else
{
this
.
untrackWindow
(
win
)
;
}
}
}
updateWindow
(
win
)
{
let
report
=
this
.
findActiveReport
(
win
.
gBrowser
.
selectedBrowser
)
;
if
(
report
)
{
this
.
showNotification
(
win
report
)
;
}
else
{
this
.
hideNotification
(
win
)
;
}
}
showNotification
(
win
report
)
{
let
nb
=
win
.
document
.
getElementById
(
"
high
-
priority
-
global
-
notificationbox
"
)
;
let
notification
=
nb
.
getNotificationWithValue
(
"
process
-
hang
"
)
;
if
(
notification
)
{
return
;
}
let
bundle
=
win
.
gNavigatorBundle
;
let
buttons
=
[
{
label
:
bundle
.
getString
(
"
processHang
.
button_stop
.
label
"
)
accessKey
:
bundle
.
getString
(
"
processHang
.
button_stop
.
accessKey
"
)
callback
(
)
{
ProcessHangMonitor
.
stopIt
(
win
)
;
}
}
{
label
:
bundle
.
getString
(
"
processHang
.
button_wait
.
label
"
)
accessKey
:
bundle
.
getString
(
"
processHang
.
button_wait
.
accessKey
"
)
callback
(
)
{
ProcessHangMonitor
.
waitLonger
(
win
)
;
}
}
]
;
let
message
=
bundle
.
getString
(
"
processHang
.
label
"
)
;
if
(
report
.
addonId
)
{
let
aps
=
Cc
[
"
mozilla
.
org
/
addons
/
policy
-
service
;
1
"
]
.
getService
(
Ci
.
nsIAddonPolicyService
)
;
let
doc
=
win
.
document
;
let
brandBundle
=
doc
.
getElementById
(
"
bundle_brand
"
)
;
let
addonName
=
aps
.
getExtensionName
(
report
.
addonId
)
;
let
label
=
bundle
.
getFormattedString
(
"
processHang
.
add
-
on
.
label
"
[
addonName
brandBundle
.
getString
(
"
brandShortName
"
)
]
)
;
let
linkText
=
bundle
.
getString
(
"
processHang
.
add
-
on
.
learn
-
more
.
text
"
)
;
let
linkURL
=
"
https
:
/
/
support
.
mozilla
.
org
/
kb
/
warning
-
unresponsive
-
script
#
w_other
-
causes
"
;
let
link
=
doc
.
createElement
(
"
label
"
)
;
link
.
setAttribute
(
"
class
"
"
text
-
link
"
)
;
link
.
setAttribute
(
"
role
"
"
link
"
)
;
link
.
setAttribute
(
"
onclick
"
openUILinkIn
(
{
JSON
.
stringify
(
linkURL
)
}
"
tab
"
)
)
;
link
.
setAttribute
(
"
value
"
linkText
)
;
message
=
doc
.
createDocumentFragment
(
)
;
message
.
appendChild
(
doc
.
createTextNode
(
label
+
"
"
)
)
;
message
.
appendChild
(
link
)
;
buttons
.
unshift
(
{
label
:
bundle
.
getString
(
"
processHang
.
button_stop_sandbox
.
label
"
)
accessKey
:
bundle
.
getString
(
"
processHang
.
button_stop_sandbox
.
accessKey
"
)
callback
(
)
{
ProcessHangMonitor
.
stopGlobal
(
win
)
;
}
}
)
;
}
if
(
AppConstants
.
MOZ_DEV_EDITION
&
&
report
.
hangType
=
=
report
.
SLOW_SCRIPT
)
{
buttons
.
push
(
{
label
:
bundle
.
getString
(
"
processHang
.
button_debug
.
label
"
)
accessKey
:
bundle
.
getString
(
"
processHang
.
button_debug
.
accessKey
"
)
callback
(
)
{
ProcessHangMonitor
.
debugScript
(
win
)
;
}
}
)
;
}
nb
.
appendNotification
(
message
"
process
-
hang
"
"
chrome
:
/
/
browser
/
content
/
aboutRobots
-
icon
.
png
"
nb
.
PRIORITY_WARNING_HIGH
buttons
)
;
}
hideNotification
(
win
)
{
let
nb
=
win
.
document
.
getElementById
(
"
high
-
priority
-
global
-
notificationbox
"
)
;
let
notification
=
nb
.
getNotificationWithValue
(
"
process
-
hang
"
)
;
if
(
notification
)
{
nb
.
removeNotification
(
notification
)
;
}
}
trackWindow
(
win
)
{
win
.
gBrowser
.
tabContainer
.
addEventListener
(
"
TabSelect
"
this
true
)
;
win
.
gBrowser
.
tabContainer
.
addEventListener
(
"
TabRemotenessChange
"
this
true
)
;
}
untrackWindow
(
win
)
{
win
.
gBrowser
.
tabContainer
.
removeEventListener
(
"
TabSelect
"
this
true
)
;
win
.
gBrowser
.
tabContainer
.
removeEventListener
(
"
TabRemotenessChange
"
this
true
)
;
}
handleEvent
(
event
)
{
let
win
=
event
.
target
.
ownerGlobal
;
if
(
event
.
type
=
=
"
TabSelect
"
|
|
event
.
type
=
=
"
TabRemotenessChange
"
)
{
this
.
updateWindow
(
win
)
;
}
}
reportHang
(
report
)
{
if
(
this
.
_shuttingDown
)
{
this
.
stopHang
(
report
)
;
return
;
}
if
(
this
.
_activeReports
.
has
(
report
)
)
{
this
.
updateWindows
(
)
;
return
;
}
if
(
this
.
_pausedReports
.
has
(
report
)
)
{
return
;
}
if
(
report
.
hangType
=
=
report
.
SLOW_SCRIPT
)
{
Services
.
telemetry
.
getHistogramById
(
"
SLOW_SCRIPT_NOTICE_COUNT
"
)
.
add
(
)
;
}
else
if
(
report
.
hangType
=
=
report
.
PLUGIN_HANG
)
{
Services
.
telemetry
.
getHistogramById
(
"
PLUGIN_HANG_NOTICE_COUNT
"
)
.
add
(
)
;
}
this
.
_activeReports
.
add
(
report
)
;
this
.
updateWindows
(
)
;
}
clearHang
(
report
)
{
this
.
removeActiveReport
(
report
)
;
this
.
removePausedReport
(
report
)
;
report
.
userCanceled
(
)
;
}
}
;
