"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
ProcessHangMonitor
"
]
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
var
ProcessHangMonitor
=
{
get
WAIT_EXPIRATION_TIME
(
)
{
try
{
return
Services
.
prefs
.
getIntPref
(
"
browser
.
hangNotification
.
waitPeriod
"
)
;
}
catch
(
ex
)
{
return
10000
;
}
}
_shuttingDown
:
false
_activeReports
:
new
Map
(
)
_pausedReports
:
new
Map
(
)
init
(
)
{
Services
.
obs
.
addObserver
(
this
"
process
-
hang
-
report
"
)
;
Services
.
obs
.
addObserver
(
this
"
clear
-
hang
-
report
"
)
;
Services
.
obs
.
addObserver
(
this
"
quit
-
application
-
granted
"
)
;
Services
.
obs
.
addObserver
(
this
"
xpcom
-
shutdown
"
)
;
Services
.
ww
.
registerNotification
(
this
)
;
Services
.
telemetry
.
setEventRecordingEnabled
(
"
slow_script_warning
"
true
)
;
}
terminateScript
(
win
)
{
this
.
handleUserInput
(
win
report
=
>
report
.
terminateScript
(
)
)
;
}
terminateGlobal
(
win
)
{
this
.
handleUserInput
(
win
report
=
>
report
.
terminateGlobal
(
)
)
;
}
debugScript
(
win
)
{
this
.
handleUserInput
(
win
report
=
>
{
function
callback
(
)
{
report
.
endStartingDebugger
(
)
;
}
this
.
_recordTelemetryForReport
(
report
"
debugging
"
)
;
report
.
beginStartingDebugger
(
)
;
let
svc
=
Cc
[
"
mozilla
.
org
/
dom
/
slow
-
script
-
debug
;
1
"
]
.
getService
(
Ci
.
nsISlowScriptDebug
)
;
let
handler
=
svc
.
remoteActivationHandler
;
handler
.
handleSlowScriptDebug
(
report
.
scriptBrowser
callback
)
;
}
)
;
}
terminatePlugin
(
win
)
{
this
.
handleUserInput
(
win
report
=
>
report
.
terminatePlugin
(
)
)
;
}
stopIt
(
win
)
{
let
report
=
this
.
findActiveReport
(
win
.
gBrowser
.
selectedBrowser
)
;
if
(
!
report
)
{
return
;
}
switch
(
report
.
hangType
)
{
case
report
.
SLOW_SCRIPT
:
this
.
_recordTelemetryForReport
(
report
"
user
-
aborted
"
)
;
this
.
terminateScript
(
win
)
;
break
;
case
report
.
PLUGIN_HANG
:
this
.
terminatePlugin
(
win
)
;
break
;
}
}
stopGlobal
(
win
)
{
let
report
=
this
.
findActiveReport
(
win
.
gBrowser
.
selectedBrowser
)
;
if
(
!
report
)
{
return
;
}
switch
(
report
.
hangType
)
{
case
report
.
SLOW_SCRIPT
:
this
.
_recordTelemetryForReport
(
report
"
user
-
aborted
"
)
;
this
.
terminateGlobal
(
win
)
;
break
;
}
}
stopHang
(
report
endReason
backupInfo
)
{
switch
(
report
.
hangType
)
{
case
report
.
SLOW_SCRIPT
:
{
this
.
_recordTelemetryForReport
(
report
endReason
backupInfo
)
;
if
(
report
.
addonId
)
{
report
.
terminateGlobal
(
)
;
}
else
{
report
.
terminateScript
(
)
;
}
break
;
}
case
report
.
PLUGIN_HANG
:
{
report
.
terminatePlugin
(
)
;
break
;
}
}
}
waitLonger
(
win
)
{
let
report
=
this
.
findActiveReport
(
win
.
gBrowser
.
selectedBrowser
)
;
if
(
!
report
)
{
return
;
}
let
reportInfo
=
this
.
_activeReports
.
get
(
report
)
;
reportInfo
.
waitCount
+
+
;
this
.
removeActiveReport
(
report
)
;
let
timer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
timer
.
initWithCallback
(
(
)
=
>
{
for
(
let
[
stashedReport
pausedInfo
]
of
this
.
_pausedReports
)
{
if
(
pausedInfo
.
timer
=
=
=
timer
)
{
this
.
removePausedReport
(
stashedReport
)
;
this
.
_activeReports
.
set
(
report
pausedInfo
)
;
this
.
updateWindows
(
)
;
break
;
}
}
}
this
.
WAIT_EXPIRATION_TIME
timer
.
TYPE_ONE_SHOT
)
;
reportInfo
.
timer
=
timer
;
this
.
_pausedReports
.
set
(
report
reportInfo
)
;
this
.
updateWindows
(
)
;
}
handleUserInput
(
win
func
)
{
let
report
=
this
.
findActiveReport
(
win
.
gBrowser
.
selectedBrowser
)
;
if
(
!
report
)
{
return
null
;
}
this
.
removeActiveReport
(
report
)
;
return
func
(
report
)
;
}
observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
"
xpcom
-
shutdown
"
:
{
Services
.
obs
.
removeObserver
(
this
"
xpcom
-
shutdown
"
)
;
Services
.
obs
.
removeObserver
(
this
"
process
-
hang
-
report
"
)
;
Services
.
obs
.
removeObserver
(
this
"
clear
-
hang
-
report
"
)
;
Services
.
obs
.
removeObserver
(
this
"
quit
-
application
-
granted
"
)
;
Services
.
ww
.
unregisterNotification
(
this
)
;
break
;
}
case
"
quit
-
application
-
granted
"
:
{
this
.
onQuitApplicationGranted
(
)
;
break
;
}
case
"
process
-
hang
-
report
"
:
{
this
.
reportHang
(
subject
.
QueryInterface
(
Ci
.
nsIHangReport
)
)
;
break
;
}
case
"
clear
-
hang
-
report
"
:
{
this
.
clearHang
(
subject
.
QueryInterface
(
Ci
.
nsIHangReport
)
)
;
break
;
}
case
"
domwindowopened
"
:
{
let
win
=
subject
;
let
listener
=
ev
=
>
{
win
.
removeEventListener
(
"
load
"
listener
true
)
;
this
.
updateWindows
(
)
;
}
;
win
.
addEventListener
(
"
load
"
listener
true
)
;
break
;
}
case
"
domwindowclosed
"
:
{
let
win
=
subject
;
this
.
onWindowClosed
(
win
)
;
break
;
}
}
}
onQuitApplicationGranted
(
)
{
this
.
_shuttingDown
=
true
;
this
.
stopAllHangs
(
"
quit
-
application
-
granted
"
)
;
this
.
updateWindows
(
)
;
}
onWindowClosed
(
win
)
{
let
maybeStopHang
=
report
=
>
{
if
(
report
.
hangType
=
=
report
.
SLOW_SCRIPT
)
{
let
hungBrowserWindow
=
null
;
try
{
hungBrowserWindow
=
report
.
scriptBrowser
.
ownerGlobal
;
}
catch
(
e
)
{
}
if
(
!
hungBrowserWindow
|
|
hungBrowserWindow
=
=
win
)
{
this
.
stopHang
(
report
"
window
-
closed
"
)
;
return
true
;
}
}
else
if
(
report
.
hangType
=
=
report
.
PLUGIN_HANG
)
{
this
.
stopHang
(
report
)
;
return
true
;
}
return
false
;
}
;
for
(
let
[
report
]
of
this
.
_activeReports
)
{
if
(
maybeStopHang
(
report
)
)
{
this
.
_activeReports
.
delete
(
report
)
;
}
}
for
(
let
[
pausedReport
]
of
this
.
_pausedReports
)
{
if
(
maybeStopHang
(
pausedReport
)
)
{
this
.
removePausedReport
(
pausedReport
)
;
}
}
this
.
updateWindows
(
)
;
}
stopAllHangs
(
endReason
)
{
for
(
let
[
report
]
of
this
.
_activeReports
)
{
this
.
stopHang
(
report
endReason
)
;
}
this
.
_activeReports
=
new
Map
(
)
;
for
(
let
[
pausedReport
]
of
this
.
_pausedReports
)
{
this
.
stopHang
(
pausedReport
endReason
)
;
this
.
removePausedReport
(
pausedReport
)
;
}
}
findActiveReport
(
browser
)
{
let
frameLoader
=
browser
.
frameLoader
;
for
(
let
report
of
this
.
_activeReports
.
keys
(
)
)
{
if
(
report
.
isReportForBrowser
(
frameLoader
)
)
{
return
report
;
}
}
return
null
;
}
findPausedReport
(
browser
)
{
let
frameLoader
=
browser
.
frameLoader
;
for
(
let
[
report
]
of
this
.
_pausedReports
)
{
if
(
report
.
isReportForBrowser
(
frameLoader
)
)
{
return
report
;
}
}
return
null
;
}
_recordTelemetryForReport
(
report
endReason
backupInfo
)
{
let
info
=
this
.
_activeReports
.
get
(
report
)
|
|
this
.
_pausedReports
.
get
(
report
)
|
|
backupInfo
;
if
(
!
info
)
{
return
;
}
try
{
if
(
report
.
hangType
!
=
report
.
SLOW_SCRIPT
)
{
return
;
}
let
uri_type
;
if
(
report
.
addonId
)
{
uri_type
=
"
extension
"
;
}
else
if
(
report
.
scriptFileName
?
.
startsWith
(
"
debugger
"
)
)
{
uri_type
=
"
devtools
"
;
}
else
{
try
{
let
url
=
new
URL
(
report
.
scriptFileName
)
;
if
(
url
.
protocol
=
=
"
chrome
:
"
|
|
url
.
protocol
=
=
"
resource
:
"
)
{
uri_type
=
"
browser
"
;
}
else
{
uri_type
=
"
content
"
;
}
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
uri_type
=
"
unknown
"
;
}
}
let
uptime
=
0
;
if
(
info
.
notificationTime
)
{
uptime
=
Cu
.
now
(
)
-
info
.
notificationTime
;
}
uptime
=
"
"
+
uptime
;
let
hangDuration
=
report
.
hangDuration
+
Cu
.
now
(
)
-
info
.
lastReportFromChild
;
Services
.
telemetry
.
recordEvent
(
"
slow_script_warning
"
"
shown
"
"
content
"
null
{
end_reason
:
endReason
hang_duration
:
"
"
+
hangDuration
uri_type
uptime
wait_count
:
"
"
+
info
.
waitCount
}
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
}
removeActiveReport
(
report
)
{
this
.
_activeReports
.
delete
(
report
)
;
this
.
updateWindows
(
)
;
}
removePausedReport
(
report
)
{
let
info
=
this
.
_pausedReports
.
get
(
report
)
;
info
?
.
timer
?
.
cancel
(
)
;
this
.
_pausedReports
.
delete
(
report
)
;
}
updateWindows
(
)
{
let
e
=
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
;
if
(
!
e
.
hasMoreElements
(
)
)
{
this
.
stopAllHangs
(
"
no
-
windows
-
left
"
)
;
return
;
}
for
(
let
win
of
e
)
{
this
.
updateWindow
(
win
)
;
if
(
this
.
_activeReports
.
size
)
{
this
.
trackWindow
(
win
)
;
}
else
{
this
.
untrackWindow
(
win
)
;
}
}
}
updateWindow
(
win
)
{
let
report
=
this
.
findActiveReport
(
win
.
gBrowser
.
selectedBrowser
)
;
if
(
report
)
{
let
info
=
this
.
_activeReports
.
get
(
report
)
;
if
(
info
&
&
!
info
.
notificationTime
)
{
info
.
notificationTime
=
Cu
.
now
(
)
;
}
this
.
showNotification
(
win
report
)
;
}
else
{
this
.
hideNotification
(
win
)
;
}
}
showNotification
(
win
report
)
{
let
notification
=
win
.
gHighPriorityNotificationBox
.
getNotificationWithValue
(
"
process
-
hang
"
)
;
if
(
notification
)
{
return
;
}
let
bundle
=
win
.
gNavigatorBundle
;
let
buttons
=
[
{
label
:
bundle
.
getString
(
"
processHang
.
button_stop
.
label
"
)
accessKey
:
bundle
.
getString
(
"
processHang
.
button_stop
.
accessKey
"
)
callback
(
)
{
ProcessHangMonitor
.
stopIt
(
win
)
;
}
}
{
label
:
bundle
.
getString
(
"
processHang
.
button_wait
.
label
"
)
accessKey
:
bundle
.
getString
(
"
processHang
.
button_wait
.
accessKey
"
)
callback
(
)
{
ProcessHangMonitor
.
waitLonger
(
win
)
;
}
}
]
;
let
message
=
bundle
.
getString
(
"
processHang
.
label
"
)
;
if
(
report
.
addonId
)
{
let
aps
=
Cc
[
"
mozilla
.
org
/
addons
/
policy
-
service
;
1
"
]
.
getService
(
Ci
.
nsIAddonPolicyService
)
;
let
doc
=
win
.
document
;
let
brandBundle
=
doc
.
getElementById
(
"
bundle_brand
"
)
;
let
addonName
=
aps
.
getExtensionName
(
report
.
addonId
)
;
let
label
=
bundle
.
getFormattedString
(
"
processHang
.
add
-
on
.
label
"
[
addonName
brandBundle
.
getString
(
"
brandShortName
"
)
]
)
;
let
linkText
=
bundle
.
getString
(
"
processHang
.
add
-
on
.
learn
-
more
.
text
"
)
;
let
linkURL
=
"
https
:
/
/
support
.
mozilla
.
org
/
kb
/
warning
-
unresponsive
-
script
#
w_other
-
causes
"
;
let
link
=
doc
.
createXULElement
(
"
label
"
{
is
:
"
text
-
link
"
}
)
;
link
.
setAttribute
(
"
role
"
"
link
"
)
;
link
.
setAttribute
(
"
onclick
"
openTrustedLinkIn
(
{
JSON
.
stringify
(
linkURL
)
}
"
tab
"
)
)
;
link
.
setAttribute
(
"
value
"
linkText
)
;
message
=
doc
.
createDocumentFragment
(
)
;
message
.
appendChild
(
doc
.
createTextNode
(
label
+
"
"
)
)
;
message
.
appendChild
(
link
)
;
buttons
.
unshift
(
{
label
:
bundle
.
getString
(
"
processHang
.
button_stop_sandbox
.
label
"
)
accessKey
:
bundle
.
getString
(
"
processHang
.
button_stop_sandbox
.
accessKey
"
)
callback
(
)
{
ProcessHangMonitor
.
stopGlobal
(
win
)
;
}
}
)
;
}
if
(
AppConstants
.
MOZ_DEV_EDITION
&
&
report
.
hangType
=
=
report
.
SLOW_SCRIPT
)
{
buttons
.
push
(
{
label
:
bundle
.
getString
(
"
processHang
.
button_debug
.
label
"
)
accessKey
:
bundle
.
getString
(
"
processHang
.
button_debug
.
accessKey
"
)
callback
(
)
{
ProcessHangMonitor
.
debugScript
(
win
)
;
}
}
)
;
}
win
.
gHighPriorityNotificationBox
.
appendNotification
(
message
"
process
-
hang
"
"
chrome
:
/
/
browser
/
content
/
aboutRobots
-
icon
.
png
"
win
.
gHighPriorityNotificationBox
.
PRIORITY_WARNING_HIGH
buttons
)
;
}
hideNotification
(
win
)
{
let
notification
=
win
.
gHighPriorityNotificationBox
.
getNotificationWithValue
(
"
process
-
hang
"
)
;
if
(
notification
)
{
win
.
gHighPriorityNotificationBox
.
removeNotification
(
notification
)
;
}
}
trackWindow
(
win
)
{
win
.
gBrowser
.
tabContainer
.
addEventListener
(
"
TabSelect
"
this
true
)
;
win
.
gBrowser
.
tabContainer
.
addEventListener
(
"
TabRemotenessChange
"
this
true
)
;
}
untrackWindow
(
win
)
{
win
.
gBrowser
.
tabContainer
.
removeEventListener
(
"
TabSelect
"
this
true
)
;
win
.
gBrowser
.
tabContainer
.
removeEventListener
(
"
TabRemotenessChange
"
this
true
)
;
}
handleEvent
(
event
)
{
let
win
=
event
.
target
.
ownerGlobal
;
if
(
event
.
type
=
=
"
TabSelect
"
|
|
event
.
type
=
=
"
TabRemotenessChange
"
)
{
this
.
updateWindow
(
win
)
;
}
}
reportHang
(
report
)
{
let
now
=
Cu
.
now
(
)
;
if
(
this
.
_shuttingDown
)
{
this
.
stopHang
(
report
"
shutdown
-
in
-
progress
"
{
lastReportFromChild
:
now
}
)
;
return
;
}
if
(
this
.
_activeReports
.
has
(
report
)
)
{
this
.
_activeReports
.
get
(
report
)
.
lastReportFromChild
=
now
;
this
.
updateWindows
(
)
;
return
;
}
if
(
this
.
_pausedReports
.
has
(
report
)
)
{
this
.
_pausedReports
.
get
(
report
)
.
lastReportFromChild
=
now
;
return
;
}
if
(
report
.
hangType
=
=
report
.
SLOW_SCRIPT
)
{
Services
.
telemetry
.
getHistogramById
(
"
SLOW_SCRIPT_NOTICE_COUNT
"
)
.
add
(
)
;
}
else
if
(
report
.
hangType
=
=
report
.
PLUGIN_HANG
)
{
Services
.
telemetry
.
getHistogramById
(
"
PLUGIN_HANG_NOTICE_COUNT
"
)
.
add
(
)
;
}
this
.
_activeReports
.
set
(
report
{
lastReportFromChild
:
now
waitCount
:
0
}
)
;
this
.
updateWindows
(
)
;
}
clearHang
(
report
)
{
this
.
_recordTelemetryForReport
(
report
"
cleared
"
)
;
this
.
removeActiveReport
(
report
)
;
this
.
removePausedReport
(
report
)
;
report
.
userCanceled
(
)
;
}
}
;
