"
use
strict
"
;
var
Cc
=
Components
.
classes
;
var
Ci
=
Components
.
interfaces
;
var
Cu
=
Components
.
utils
;
this
.
EXPORTED_SYMBOLS
=
[
"
ProcessHangMonitor
"
]
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
var
ProcessHangMonitor
=
{
get
HANG_EXPIRATION_TIME
(
)
{
try
{
return
Services
.
prefs
.
getIntPref
(
"
browser
.
hangNotification
.
expiration
"
)
;
}
catch
(
ex
)
{
return
10000
;
}
}
get
WAIT_EXPIRATION_TIME
(
)
{
try
{
return
Services
.
prefs
.
getIntPref
(
"
browser
.
hangNotification
.
waitPeriod
"
)
;
}
catch
(
ex
)
{
return
10000
;
}
}
_activeReports
:
new
Map
(
)
_pausedReports
:
new
Map
(
)
init
:
function
(
)
{
Services
.
obs
.
addObserver
(
this
"
process
-
hang
-
report
"
false
)
;
Services
.
obs
.
addObserver
(
this
"
xpcom
-
shutdown
"
false
)
;
Services
.
ww
.
registerNotification
(
this
)
;
}
terminateScript
:
function
(
win
)
{
this
.
handleUserInput
(
win
report
=
>
report
.
terminateScript
(
)
)
;
}
debugScript
:
function
(
win
)
{
this
.
handleUserInput
(
win
report
=
>
{
function
callback
(
)
{
report
.
endStartingDebugger
(
)
;
}
report
.
beginStartingDebugger
(
)
;
let
svc
=
Cc
[
"
mozilla
.
org
/
dom
/
slow
-
script
-
debug
;
1
"
]
.
getService
(
Ci
.
nsISlowScriptDebug
)
;
let
handler
=
svc
.
remoteActivationHandler
;
handler
.
handleSlowScriptDebug
(
report
.
scriptBrowser
callback
)
;
}
)
;
}
terminatePlugin
:
function
(
win
)
{
this
.
handleUserInput
(
win
report
=
>
report
.
terminatePlugin
(
)
)
;
}
stopIt
:
function
(
win
)
{
let
report
=
this
.
findActiveReport
(
win
.
gBrowser
.
selectedBrowser
)
;
if
(
!
report
)
{
return
;
}
switch
(
report
.
hangType
)
{
case
report
.
SLOW_SCRIPT
:
this
.
terminateScript
(
win
)
;
break
;
case
report
.
PLUGIN_HANG
:
this
.
terminatePlugin
(
win
)
;
break
;
}
}
waitLonger
:
function
(
win
)
{
let
report
=
this
.
findActiveReport
(
win
.
gBrowser
.
selectedBrowser
)
;
if
(
!
report
)
{
return
;
}
this
.
removeActiveReport
(
report
)
;
let
timer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
timer
.
initWithCallback
(
(
)
=
>
{
for
(
let
[
stashedReport
otherTimer
]
of
this
.
_pausedReports
)
{
if
(
otherTimer
=
=
=
timer
)
{
this
.
removePausedReport
(
stashedReport
)
;
let
timer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
timer
.
initWithCallback
(
this
this
.
HANG_EXPIRATION_TIME
timer
.
TYPE_ONE_SHOT
)
;
this
.
_activeReports
.
set
(
report
timer
)
;
break
;
}
}
}
this
.
WAIT_EXPIRATION_TIME
timer
.
TYPE_ONE_SHOT
)
;
this
.
_pausedReports
.
set
(
report
timer
)
;
this
.
updateWindows
(
)
;
}
handleUserInput
:
function
(
win
func
)
{
let
report
=
this
.
findActiveReport
(
win
.
gBrowser
.
selectedBrowser
)
;
if
(
!
report
)
{
return
null
;
}
this
.
removeActiveReport
(
report
)
;
return
func
(
report
)
;
}
observe
:
function
(
subject
topic
data
)
{
switch
(
topic
)
{
case
"
xpcom
-
shutdown
"
:
Services
.
obs
.
removeObserver
(
this
"
xpcom
-
shutdown
"
)
;
Services
.
obs
.
removeObserver
(
this
"
process
-
hang
-
report
"
)
;
Services
.
ww
.
unregisterNotification
(
this
)
;
break
;
case
"
process
-
hang
-
report
"
:
this
.
reportHang
(
subject
.
QueryInterface
(
Ci
.
nsIHangReport
)
)
;
break
;
case
"
domwindowopened
"
:
let
win
=
subject
.
QueryInterface
(
Ci
.
nsIDOMWindow
)
;
let
listener
=
(
ev
)
=
>
{
win
.
removeEventListener
(
"
load
"
listener
true
)
;
this
.
updateWindows
(
)
;
}
;
win
.
addEventListener
(
"
load
"
listener
true
)
;
break
;
}
}
findActiveReport
:
function
(
browser
)
{
let
frameLoader
=
browser
.
QueryInterface
(
Ci
.
nsIFrameLoaderOwner
)
.
frameLoader
;
for
(
let
[
report
timer
]
of
this
.
_activeReports
)
{
if
(
report
.
isReportForBrowser
(
frameLoader
)
)
{
return
report
;
}
}
return
null
;
}
findPausedReport
:
function
(
browser
)
{
let
frameLoader
=
browser
.
QueryInterface
(
Ci
.
nsIFrameLoaderOwner
)
.
frameLoader
;
for
(
let
[
report
timer
]
of
this
.
_pausedReports
)
{
if
(
report
.
isReportForBrowser
(
frameLoader
)
)
{
return
report
;
}
}
return
null
;
}
removeActiveReport
:
function
(
report
)
{
let
timer
=
this
.
_activeReports
.
get
(
report
)
;
if
(
timer
)
{
timer
.
cancel
(
)
;
}
this
.
_activeReports
.
delete
(
report
)
;
this
.
updateWindows
(
)
;
}
removePausedReport
:
function
(
report
)
{
let
timer
=
this
.
_pausedReports
.
get
(
report
)
;
if
(
timer
)
{
timer
.
cancel
(
)
;
}
this
.
_pausedReports
.
delete
(
report
)
;
}
updateWindows
:
function
(
)
{
let
e
=
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
;
while
(
e
.
hasMoreElements
(
)
)
{
let
win
=
e
.
getNext
(
)
;
this
.
updateWindow
(
win
)
;
if
(
this
.
_activeReports
.
size
)
{
this
.
trackWindow
(
win
)
;
}
else
{
this
.
untrackWindow
(
win
)
;
}
}
}
updateWindow
:
function
(
win
)
{
let
report
=
this
.
findActiveReport
(
win
.
gBrowser
.
selectedBrowser
)
;
if
(
report
)
{
this
.
showNotification
(
win
report
)
;
}
else
{
this
.
hideNotification
(
win
)
;
}
}
showNotification
:
function
(
win
report
)
{
let
nb
=
win
.
document
.
getElementById
(
"
high
-
priority
-
global
-
notificationbox
"
)
;
let
notification
=
nb
.
getNotificationWithValue
(
"
process
-
hang
"
)
;
if
(
notification
)
{
return
;
}
let
bundle
=
win
.
gNavigatorBundle
;
let
brandBundle
=
win
.
document
.
getElementById
(
"
bundle_brand
"
)
;
let
buttons
=
[
{
label
:
bundle
.
getString
(
"
processHang
.
button_stop
.
label
"
)
accessKey
:
bundle
.
getString
(
"
processHang
.
button_stop
.
accessKey
"
)
callback
:
function
(
)
{
ProcessHangMonitor
.
stopIt
(
win
)
;
}
}
{
label
:
bundle
.
getString
(
"
processHang
.
button_wait
.
label
"
)
accessKey
:
bundle
.
getString
(
"
processHang
.
button_wait
.
accessKey
"
)
callback
:
function
(
)
{
ProcessHangMonitor
.
waitLonger
(
win
)
;
}
}
]
;
if
(
AppConstants
.
MOZ_DEV_EDITION
&
&
report
.
hangType
=
=
report
.
SLOW_SCRIPT
)
{
buttons
.
push
(
{
label
:
bundle
.
getString
(
"
processHang
.
button_debug
.
label
"
)
accessKey
:
bundle
.
getString
(
"
processHang
.
button_debug
.
accessKey
"
)
callback
:
function
(
)
{
ProcessHangMonitor
.
debugScript
(
win
)
;
}
}
)
;
}
nb
.
appendNotification
(
bundle
.
getString
(
"
processHang
.
label
"
)
"
process
-
hang
"
"
chrome
:
/
/
browser
/
content
/
aboutRobots
-
icon
.
png
"
nb
.
PRIORITY_WARNING_HIGH
buttons
)
;
}
hideNotification
:
function
(
win
)
{
let
nb
=
win
.
document
.
getElementById
(
"
high
-
priority
-
global
-
notificationbox
"
)
;
let
notification
=
nb
.
getNotificationWithValue
(
"
process
-
hang
"
)
;
if
(
notification
)
{
nb
.
removeNotification
(
notification
)
;
}
}
trackWindow
:
function
(
win
)
{
win
.
gBrowser
.
tabContainer
.
addEventListener
(
"
TabSelect
"
this
true
)
;
win
.
gBrowser
.
tabContainer
.
addEventListener
(
"
TabRemotenessChange
"
this
true
)
;
}
untrackWindow
:
function
(
win
)
{
win
.
gBrowser
.
tabContainer
.
removeEventListener
(
"
TabSelect
"
this
true
)
;
win
.
gBrowser
.
tabContainer
.
removeEventListener
(
"
TabRemotenessChange
"
this
true
)
;
}
handleEvent
:
function
(
event
)
{
let
win
=
event
.
target
.
ownerDocument
.
defaultView
;
if
(
event
.
type
=
=
"
TabSelect
"
|
|
event
.
type
=
=
"
TabRemotenessChange
"
)
{
this
.
updateWindow
(
win
)
;
}
}
reportHang
:
function
(
report
)
{
if
(
this
.
_activeReports
.
has
(
report
)
)
{
let
timer
=
this
.
_activeReports
.
get
(
report
)
;
timer
.
cancel
(
)
;
timer
.
initWithCallback
(
this
this
.
HANG_EXPIRATION_TIME
timer
.
TYPE_ONE_SHOT
)
;
this
.
updateWindows
(
)
;
return
;
}
if
(
this
.
_pausedReports
.
has
(
report
)
)
{
return
;
}
if
(
report
.
hangType
=
=
report
.
SLOW_SCRIPT
)
{
Services
.
telemetry
.
getHistogramById
(
"
SLOW_SCRIPT_NOTICE_COUNT
"
)
.
add
(
)
;
}
else
if
(
report
.
hangType
=
=
report
.
PLUGIN_HANG
)
{
Services
.
telemetry
.
getHistogramById
(
"
PLUGIN_HANG_NOTICE_COUNT
"
)
.
add
(
)
;
}
let
timer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
timer
.
initWithCallback
(
this
this
.
HANG_EXPIRATION_TIME
timer
.
TYPE_ONE_SHOT
)
;
this
.
_activeReports
.
set
(
report
timer
)
;
this
.
updateWindows
(
)
;
}
notify
:
function
(
timer
)
{
for
(
let
[
otherReport
otherTimer
]
of
this
.
_activeReports
)
{
if
(
otherTimer
=
=
=
timer
)
{
this
.
removeActiveReport
(
otherReport
)
;
otherReport
.
userCanceled
(
)
;
break
;
}
}
}
}
;
