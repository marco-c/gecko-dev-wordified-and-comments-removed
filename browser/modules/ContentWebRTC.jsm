"
use
strict
"
;
const
{
classes
:
Cc
interfaces
:
Ci
results
:
Cr
utils
:
Cu
}
=
Components
;
this
.
EXPORTED_SYMBOLS
=
[
"
ContentWebRTC
"
]
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
MediaManagerService
"
"
mozilla
.
org
/
mediaManagerService
;
1
"
"
nsIMediaManagerService
"
)
;
const
kBrowserURL
=
"
chrome
:
/
/
browser
/
content
/
browser
.
xul
"
;
this
.
ContentWebRTC
=
{
_initialized
:
false
init
(
)
{
if
(
this
.
_initialized
)
return
;
this
.
_initialized
=
true
;
Services
.
obs
.
addObserver
(
handleGUMRequest
"
getUserMedia
:
request
"
false
)
;
Services
.
obs
.
addObserver
(
handleGUMStop
"
recording
-
device
-
stopped
"
false
)
;
Services
.
obs
.
addObserver
(
handlePCRequest
"
PeerConnection
:
request
"
false
)
;
Services
.
obs
.
addObserver
(
updateIndicators
"
recording
-
device
-
events
"
false
)
;
Services
.
obs
.
addObserver
(
removeBrowserSpecificIndicator
"
recording
-
window
-
ended
"
false
)
;
if
(
Services
.
appinfo
.
processType
=
=
Services
.
appinfo
.
PROCESS_TYPE_CONTENT
)
Services
.
obs
.
addObserver
(
processShutdown
"
content
-
child
-
shutdown
"
false
)
;
}
uninit
(
)
{
Services
.
obs
.
removeObserver
(
handleGUMRequest
"
getUserMedia
:
request
"
)
;
Services
.
obs
.
removeObserver
(
handleGUMStop
"
recording
-
device
-
stopped
"
)
;
Services
.
obs
.
removeObserver
(
handlePCRequest
"
PeerConnection
:
request
"
)
;
Services
.
obs
.
removeObserver
(
updateIndicators
"
recording
-
device
-
events
"
)
;
Services
.
obs
.
removeObserver
(
removeBrowserSpecificIndicator
"
recording
-
window
-
ended
"
)
;
if
(
Services
.
appinfo
.
processType
=
=
Services
.
appinfo
.
PROCESS_TYPE_CONTENT
)
Services
.
obs
.
removeObserver
(
processShutdown
"
content
-
child
-
shutdown
"
)
;
this
.
_initialized
=
false
;
}
handleEvent
(
aEvent
)
{
let
contentWindow
=
aEvent
.
target
.
defaultView
;
let
mm
=
getMessageManagerForWindow
(
contentWindow
)
;
for
(
let
key
of
contentWindow
.
pendingGetUserMediaRequests
.
keys
(
)
)
{
mm
.
sendAsyncMessage
(
"
webrtc
:
CancelRequest
"
key
)
;
}
for
(
let
key
of
contentWindow
.
pendingPeerConnectionRequests
.
keys
(
)
)
{
mm
.
sendAsyncMessage
(
"
rtcpeer
:
CancelRequest
"
key
)
;
}
}
receiveMessage
(
aMessage
)
{
switch
(
aMessage
.
name
)
{
case
"
rtcpeer
:
Allow
"
:
case
"
rtcpeer
:
Deny
"
:
{
let
callID
=
aMessage
.
data
.
callID
;
let
contentWindow
=
Services
.
wm
.
getOuterWindowWithId
(
aMessage
.
data
.
windowID
)
;
forgetPCRequest
(
contentWindow
callID
)
;
let
topic
=
(
aMessage
.
name
=
=
"
rtcpeer
:
Allow
"
)
?
"
PeerConnection
:
response
:
allow
"
:
"
PeerConnection
:
response
:
deny
"
;
Services
.
obs
.
notifyObservers
(
null
topic
callID
)
;
break
;
}
case
"
webrtc
:
Allow
"
:
{
let
callID
=
aMessage
.
data
.
callID
;
let
contentWindow
=
Services
.
wm
.
getOuterWindowWithId
(
aMessage
.
data
.
windowID
)
;
let
devices
=
contentWindow
.
pendingGetUserMediaRequests
.
get
(
callID
)
;
forgetGUMRequest
(
contentWindow
callID
)
;
let
allowedDevices
=
Cc
[
"
mozilla
.
org
/
array
;
1
"
]
.
createInstance
(
Ci
.
nsIMutableArray
)
;
for
(
let
deviceIndex
of
aMessage
.
data
.
devices
)
allowedDevices
.
appendElement
(
devices
[
deviceIndex
]
false
)
;
Services
.
obs
.
notifyObservers
(
allowedDevices
"
getUserMedia
:
response
:
allow
"
callID
)
;
break
;
}
case
"
webrtc
:
Deny
"
:
denyGUMRequest
(
aMessage
.
data
)
;
break
;
case
"
webrtc
:
StopSharing
"
:
Services
.
obs
.
notifyObservers
(
null
"
getUserMedia
:
revoke
"
aMessage
.
data
)
;
break
;
}
}
}
;
function
handlePCRequest
(
aSubject
aTopic
aData
)
{
let
{
windowID
innerWindowID
callID
isSecure
}
=
aSubject
;
let
contentWindow
=
Services
.
wm
.
getOuterWindowWithId
(
windowID
)
;
let
mm
=
getMessageManagerForWindow
(
contentWindow
)
;
if
(
!
mm
)
{
Services
.
obs
.
notifyObservers
(
null
"
PeerConnection
:
response
:
allow
"
callID
)
;
return
;
}
if
(
!
contentWindow
.
pendingPeerConnectionRequests
)
{
setupPendingListsInitially
(
contentWindow
)
;
}
contentWindow
.
pendingPeerConnectionRequests
.
add
(
callID
)
;
let
request
=
{
windowID
innerWindowID
callID
documentURI
:
contentWindow
.
document
.
documentURI
secure
:
isSecure
}
;
mm
.
sendAsyncMessage
(
"
rtcpeer
:
Request
"
request
)
;
}
function
handleGUMStop
(
aSubject
aTopic
aData
)
{
let
contentWindow
=
Services
.
wm
.
getOuterWindowWithId
(
aSubject
.
windowID
)
;
let
request
=
{
windowID
:
aSubject
.
windowID
rawID
:
aSubject
.
rawID
mediaSource
:
aSubject
.
mediaSource
}
;
let
mm
=
getMessageManagerForWindow
(
contentWindow
)
;
if
(
mm
)
mm
.
sendAsyncMessage
(
"
webrtc
:
StopRecording
"
request
)
;
}
function
handleGUMRequest
(
aSubject
aTopic
aData
)
{
let
constraints
=
aSubject
.
getConstraints
(
)
;
let
secure
=
aSubject
.
isSecure
;
let
contentWindow
=
Services
.
wm
.
getOuterWindowWithId
(
aSubject
.
windowID
)
;
contentWindow
.
navigator
.
mozGetUserMediaDevices
(
constraints
function
(
devices
)
{
if
(
contentWindow
.
closed
)
return
;
prompt
(
contentWindow
aSubject
.
windowID
aSubject
.
callID
constraints
devices
secure
)
;
}
function
(
error
)
{
denyGUMRequest
(
{
callID
:
aSubject
.
callID
}
error
)
;
}
aSubject
.
innerWindowID
aSubject
.
callID
)
;
}
function
prompt
(
aContentWindow
aWindowID
aCallID
aConstraints
aDevices
aSecure
)
{
let
audioDevices
=
[
]
;
let
videoDevices
=
[
]
;
let
devices
=
[
]
;
let
video
=
aConstraints
.
video
|
|
aConstraints
.
picture
;
let
audio
=
aConstraints
.
audio
;
let
sharingScreen
=
video
&
&
typeof
(
video
)
!
=
"
boolean
"
&
&
video
.
mediaSource
!
=
"
camera
"
;
let
sharingAudio
=
audio
&
&
typeof
(
audio
)
!
=
"
boolean
"
&
&
audio
.
mediaSource
!
=
"
microphone
"
;
for
(
let
device
of
aDevices
)
{
device
=
device
.
QueryInterface
(
Ci
.
nsIMediaDevice
)
;
switch
(
device
.
type
)
{
case
"
audio
"
:
if
(
audio
&
&
(
device
.
mediaSource
=
=
"
microphone
"
)
!
=
sharingAudio
)
{
audioDevices
.
push
(
{
name
:
device
.
name
deviceIndex
:
devices
.
length
id
:
device
.
rawId
mediaSource
:
device
.
mediaSource
}
)
;
devices
.
push
(
device
)
;
}
break
;
case
"
video
"
:
if
(
video
&
&
(
device
.
mediaSource
=
=
"
camera
"
)
!
=
sharingScreen
)
{
let
deviceObject
=
{
name
:
device
.
name
deviceIndex
:
devices
.
length
id
:
device
.
rawId
mediaSource
:
device
.
mediaSource
}
;
if
(
device
.
scary
)
deviceObject
.
scary
=
true
;
videoDevices
.
push
(
deviceObject
)
;
devices
.
push
(
device
)
;
}
break
;
}
}
let
requestTypes
=
[
]
;
if
(
videoDevices
.
length
)
requestTypes
.
push
(
sharingScreen
?
"
Screen
"
:
"
Camera
"
)
;
if
(
audioDevices
.
length
)
requestTypes
.
push
(
sharingAudio
?
"
AudioCapture
"
:
"
Microphone
"
)
;
if
(
!
requestTypes
.
length
)
{
denyGUMRequest
(
{
callID
:
aCallID
}
"
NotFoundError
"
)
;
return
;
}
if
(
!
aContentWindow
.
pendingGetUserMediaRequests
)
{
setupPendingListsInitially
(
aContentWindow
)
;
}
aContentWindow
.
pendingGetUserMediaRequests
.
set
(
aCallID
devices
)
;
let
request
=
{
callID
:
aCallID
windowID
:
aWindowID
documentURI
:
aContentWindow
.
document
.
documentURI
secure
:
aSecure
requestTypes
sharingScreen
sharingAudio
audioDevices
videoDevices
}
;
let
mm
=
getMessageManagerForWindow
(
aContentWindow
)
;
mm
.
sendAsyncMessage
(
"
webrtc
:
Request
"
request
)
;
}
function
denyGUMRequest
(
aData
aError
)
{
let
msg
=
null
;
if
(
aError
)
{
msg
=
Cc
[
"
mozilla
.
org
/
supports
-
string
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsString
)
;
msg
.
data
=
aError
;
}
Services
.
obs
.
notifyObservers
(
msg
"
getUserMedia
:
response
:
deny
"
aData
.
callID
)
;
if
(
!
aData
.
windowID
)
return
;
let
contentWindow
=
Services
.
wm
.
getOuterWindowWithId
(
aData
.
windowID
)
;
if
(
contentWindow
.
pendingGetUserMediaRequests
)
forgetGUMRequest
(
contentWindow
aData
.
callID
)
;
}
function
forgetGUMRequest
(
aContentWindow
aCallID
)
{
aContentWindow
.
pendingGetUserMediaRequests
.
delete
(
aCallID
)
;
forgetPendingListsEventually
(
aContentWindow
)
;
}
function
forgetPCRequest
(
aContentWindow
aCallID
)
{
aContentWindow
.
pendingPeerConnectionRequests
.
delete
(
aCallID
)
;
forgetPendingListsEventually
(
aContentWindow
)
;
}
function
setupPendingListsInitially
(
aContentWindow
)
{
if
(
aContentWindow
.
pendingGetUserMediaRequests
)
{
return
;
}
aContentWindow
.
pendingGetUserMediaRequests
=
new
Map
(
)
;
aContentWindow
.
pendingPeerConnectionRequests
=
new
Set
(
)
;
aContentWindow
.
addEventListener
(
"
unload
"
ContentWebRTC
)
;
}
function
forgetPendingListsEventually
(
aContentWindow
)
{
if
(
aContentWindow
.
pendingGetUserMediaRequests
.
size
|
|
aContentWindow
.
pendingPeerConnectionRequests
.
size
)
{
return
;
}
aContentWindow
.
pendingGetUserMediaRequests
=
null
;
aContentWindow
.
pendingPeerConnectionRequests
=
null
;
aContentWindow
.
removeEventListener
(
"
unload
"
ContentWebRTC
)
;
}
function
updateIndicators
(
aSubject
aTopic
aData
)
{
if
(
aSubject
instanceof
Ci
.
nsIPropertyBag
&
&
aSubject
.
getProperty
(
"
requestURL
"
)
=
=
kBrowserURL
)
{
return
;
}
let
contentWindowArray
=
MediaManagerService
.
activeMediaCaptureWindows
;
let
count
=
contentWindowArray
.
length
;
let
state
=
{
showGlobalIndicator
:
count
>
0
showCameraIndicator
:
false
showMicrophoneIndicator
:
false
showScreenSharingIndicator
:
"
"
}
;
let
cpmm
=
Cc
[
"
mozilla
.
org
/
childprocessmessagemanager
;
1
"
]
.
getService
(
Ci
.
nsIMessageSender
)
;
cpmm
.
sendAsyncMessage
(
"
webrtc
:
UpdatingIndicators
"
)
;
let
contentWindows
=
new
Set
(
)
;
for
(
let
i
=
0
;
i
<
count
;
+
+
i
)
{
contentWindows
.
add
(
contentWindowArray
.
queryElementAt
(
i
Ci
.
nsISupports
)
.
top
)
;
}
for
(
let
contentWindow
of
contentWindows
)
{
if
(
contentWindow
.
document
.
documentURI
=
=
kBrowserURL
)
{
continue
;
}
let
tabState
=
getTabStateForContentWindow
(
contentWindow
)
;
if
(
tabState
.
camera
)
state
.
showCameraIndicator
=
true
;
if
(
tabState
.
microphone
)
state
.
showMicrophoneIndicator
=
true
;
if
(
tabState
.
screen
)
{
if
(
tabState
.
screen
=
=
"
Screen
"
)
{
state
.
showScreenSharingIndicator
=
"
Screen
"
;
}
else
if
(
tabState
.
screen
=
=
"
Window
"
)
{
if
(
state
.
showScreenSharingIndicator
!
=
"
Screen
"
)
state
.
showScreenSharingIndicator
=
"
Window
"
;
}
else
if
(
tabState
.
screen
=
=
"
Application
"
)
{
if
(
!
state
.
showScreenSharingIndicator
)
state
.
showScreenSharingIndicator
=
"
Application
"
;
}
else
if
(
tabState
.
screen
=
=
"
Browser
"
)
{
if
(
!
state
.
showScreenSharingIndicator
)
state
.
showScreenSharingIndicator
=
"
Browser
"
;
}
}
let
mm
=
getMessageManagerForWindow
(
contentWindow
)
;
mm
.
sendAsyncMessage
(
"
webrtc
:
UpdateBrowserIndicators
"
tabState
)
;
}
cpmm
.
sendAsyncMessage
(
"
webrtc
:
UpdateGlobalIndicators
"
state
)
;
}
function
removeBrowserSpecificIndicator
(
aSubject
aTopic
aData
)
{
let
contentWindow
=
Services
.
wm
.
getOuterWindowWithId
(
aData
)
.
top
;
if
(
contentWindow
.
document
.
documentURI
=
=
kBrowserURL
)
{
return
;
}
let
tabState
=
getTabStateForContentWindow
(
contentWindow
)
;
if
(
!
tabState
.
camera
&
&
!
tabState
.
microphone
&
&
!
tabState
.
screen
)
tabState
=
{
windowId
:
tabState
.
windowId
}
;
let
mm
=
getMessageManagerForWindow
(
contentWindow
)
;
if
(
mm
)
mm
.
sendAsyncMessage
(
"
webrtc
:
UpdateBrowserIndicators
"
tabState
)
;
}
function
getTabStateForContentWindow
(
aContentWindow
)
{
let
camera
=
{
}
microphone
=
{
}
screen
=
{
}
window
=
{
}
app
=
{
}
browser
=
{
}
;
MediaManagerService
.
mediaCaptureWindowState
(
aContentWindow
camera
microphone
screen
window
app
browser
)
;
let
tabState
=
{
camera
:
camera
.
value
microphone
:
microphone
.
value
}
;
if
(
screen
.
value
)
tabState
.
screen
=
"
Screen
"
;
else
if
(
window
.
value
)
tabState
.
screen
=
"
Window
"
;
else
if
(
app
.
value
)
tabState
.
screen
=
"
Application
"
;
else
if
(
browser
.
value
)
tabState
.
screen
=
"
Browser
"
;
tabState
.
windowId
=
getInnerWindowIDForWindow
(
aContentWindow
)
;
tabState
.
documentURI
=
aContentWindow
.
document
.
documentURI
;
return
tabState
;
}
function
getInnerWindowIDForWindow
(
aContentWindow
)
{
return
aContentWindow
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
.
currentInnerWindowID
;
}
function
getMessageManagerForWindow
(
aContentWindow
)
{
aContentWindow
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
;
let
docShell
;
try
{
docShell
=
aContentWindow
.
getInterface
(
Ci
.
nsIDocShell
)
;
}
catch
(
e
)
{
if
(
e
.
result
=
=
Cr
.
NS_NOINTERFACE
)
{
return
null
;
}
throw
e
;
}
let
ir
=
docShell
.
sameTypeRootTreeItem
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
;
try
{
return
ir
.
getInterface
(
Ci
.
nsIContentFrameMessageManager
)
;
}
catch
(
e
)
{
if
(
e
.
result
=
=
Cr
.
NS_NOINTERFACE
)
{
return
null
;
}
throw
e
;
}
}
function
processShutdown
(
)
{
ContentWebRTC
.
uninit
(
)
;
}
