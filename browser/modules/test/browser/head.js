ChromeUtils
.
defineModuleGetter
(
this
"
PlacesTestUtils
"
"
resource
:
/
/
testing
-
common
/
PlacesTestUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
TelemetryTestUtils
"
"
resource
:
/
/
testing
-
common
/
TelemetryTestUtils
.
jsm
"
)
;
const
SINGLE_TRY_TIMEOUT
=
100
;
const
NUMBER_OF_TRIES
=
30
;
const
PROTON_URLBAR_PREF
=
"
browser
.
proton
.
urlbar
.
enabled
"
;
let
gProtonUrlbar
=
Services
.
prefs
.
getBoolPref
(
PROTON_URLBAR_PREF
false
)
;
function
waitForConditionPromise
(
condition
timeoutMsg
tryCount
=
NUMBER_OF_TRIES
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
tries
=
0
;
function
checkCondition
(
)
{
if
(
tries
>
=
tryCount
)
{
reject
(
timeoutMsg
)
;
}
var
conditionPassed
;
try
{
conditionPassed
=
condition
(
)
;
}
catch
(
e
)
{
return
reject
(
e
)
;
}
if
(
conditionPassed
)
{
return
resolve
(
)
;
}
tries
+
+
;
setTimeout
(
checkCondition
SINGLE_TRY_TIMEOUT
)
;
return
undefined
;
}
setTimeout
(
checkCondition
SINGLE_TRY_TIMEOUT
)
;
}
)
;
}
function
waitForCondition
(
condition
nextTest
errorMsg
)
{
waitForConditionPromise
(
condition
errorMsg
)
.
then
(
nextTest
reason
=
>
{
ok
(
false
reason
+
(
reason
.
stack
?
"
\
n
"
+
reason
.
stack
:
"
"
)
)
;
}
)
;
}
let
typeInSearchField
=
async
function
(
browser
text
fieldName
)
{
await
SpecialPowers
.
spawn
(
browser
[
[
fieldName
text
]
]
async
function
(
[
contentFieldName
contentText
]
)
{
let
searchInput
=
content
.
document
.
getElementById
(
contentFieldName
)
;
searchInput
.
focus
(
)
;
searchInput
.
value
=
contentText
;
}
)
;
}
;
function
makeMockPermissionRequest
(
browser
)
{
let
type
=
{
options
:
Cc
[
"
mozilla
.
org
/
array
;
1
"
]
.
createInstance
(
Ci
.
nsIArray
)
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIContentPermissionType
"
]
)
}
;
let
types
=
Cc
[
"
mozilla
.
org
/
array
;
1
"
]
.
createInstance
(
Ci
.
nsIMutableArray
)
;
types
.
appendElement
(
type
)
;
let
principal
=
browser
.
contentPrincipal
;
let
result
=
{
types
isHandlingUserInput
:
false
principal
topLevelPrincipal
:
principal
requester
:
null
_cancelled
:
false
cancel
(
)
{
this
.
_cancelled
=
true
;
}
_allowed
:
false
allow
(
)
{
this
.
_allowed
=
true
;
}
getDelegatePrincipal
(
aType
)
{
return
principal
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIContentPermissionRequest
"
]
)
}
;
if
(
browser
.
isRemoteBrowser
)
{
result
.
element
=
browser
;
}
else
{
result
.
window
=
browser
.
contentWindow
;
}
return
result
;
}
function
clickMainAction
(
)
{
let
removePromise
=
BrowserTestUtils
.
waitForEvent
(
PopupNotifications
.
panel
"
popuphidden
"
)
;
let
popupNotification
=
getPopupNotificationNode
(
)
;
popupNotification
.
button
.
click
(
)
;
return
removePromise
;
}
function
clickSecondaryAction
(
actionIndex
)
{
let
removePromise
=
BrowserTestUtils
.
waitForEvent
(
PopupNotifications
.
panel
"
popuphidden
"
)
;
let
popupNotification
=
getPopupNotificationNode
(
)
;
if
(
!
actionIndex
)
{
popupNotification
.
secondaryButton
.
click
(
)
;
return
removePromise
;
}
return
(
async
function
(
)
{
let
dropdownPromise
=
BrowserTestUtils
.
waitForEvent
(
popupNotification
.
menupopup
"
popupshown
"
)
;
await
EventUtils
.
synthesizeMouseAtCenter
(
popupNotification
.
menubutton
{
}
)
;
await
dropdownPromise
;
let
actionMenuItem
=
popupNotification
.
querySelectorAll
(
"
menuitem
"
)
[
actionIndex
-
1
]
;
await
EventUtils
.
synthesizeMouseAtCenter
(
actionMenuItem
{
}
)
;
await
removePromise
;
}
)
(
)
;
}
function
getPopupNotificationNode
(
)
{
let
popupNotifications
=
PopupNotifications
.
panel
.
childNodes
;
Assert
.
equal
(
popupNotifications
.
length
1
"
Should
be
showing
a
<
xul
:
popupnotification
>
"
)
;
return
popupNotifications
[
0
]
;
}
async
function
disableNonReleaseActions
(
)
{
if
(
!
[
"
release
"
"
esr
"
]
.
includes
(
AppConstants
.
MOZ_UPDATE_CHANNEL
)
)
{
SpecialPowers
.
Services
.
prefs
.
setBoolPref
(
"
extensions
.
webcompat
-
reporter
.
enabled
"
false
)
;
}
}
function
assertActivatedPageActionPanelHidden
(
)
{
Assert
.
ok
(
!
document
.
getElementById
(
BrowserPageActions
.
_activatedActionPanelID
)
)
;
}
function
promiseOpenPageActionPanel
(
)
{
let
dwu
=
window
.
windowUtils
;
return
TestUtils
.
waitForCondition
(
(
)
=
>
{
info
(
"
Waiting
for
main
page
action
button
to
have
non
-
0
size
"
)
;
let
bounds
=
dwu
.
getBoundsWithoutFlushing
(
BrowserPageActions
.
mainButtonNode
)
;
return
bounds
.
width
>
0
&
&
bounds
.
height
>
0
;
}
)
.
then
(
(
)
=
>
{
info
(
"
Waiting
for
main
page
action
panel
to
be
open
"
)
;
if
(
BrowserPageActions
.
panelNode
.
state
=
=
"
open
"
)
{
return
Promise
.
resolve
(
)
;
}
let
shownPromise
=
promisePageActionPanelShown
(
)
;
EventUtils
.
synthesizeMouseAtCenter
(
BrowserPageActions
.
mainButtonNode
{
}
)
;
return
shownPromise
;
}
)
.
then
(
(
)
=
>
{
return
promisePageActionViewChildrenVisible
(
BrowserPageActions
.
mainViewNode
)
;
}
)
;
}
function
promisePageActionPanelShown
(
)
{
return
promisePanelShown
(
BrowserPageActions
.
panelNode
)
;
}
function
promisePageActionPanelHidden
(
)
{
return
promisePanelHidden
(
BrowserPageActions
.
panelNode
)
;
}
function
promisePanelShown
(
panelIDOrNode
)
{
return
promisePanelEvent
(
panelIDOrNode
"
popupshown
"
)
;
}
function
promisePanelHidden
(
panelIDOrNode
)
{
return
promisePanelEvent
(
panelIDOrNode
"
popuphidden
"
)
;
}
function
promisePanelEvent
(
panelIDOrNode
eventType
)
{
return
new
Promise
(
resolve
=
>
{
let
panel
=
panelIDOrNode
;
if
(
typeof
panel
=
=
"
string
"
)
{
panel
=
document
.
getElementById
(
panelIDOrNode
)
;
if
(
!
panel
)
{
throw
new
Error
(
Panel
with
ID
"
{
panelIDOrNode
}
"
does
not
exist
.
)
;
}
}
if
(
(
eventType
=
=
"
popupshown
"
&
&
panel
.
state
=
=
"
open
"
)
|
|
(
eventType
=
=
"
popuphidden
"
&
&
panel
.
state
=
=
"
closed
"
)
)
{
executeSoon
(
resolve
)
;
return
;
}
panel
.
addEventListener
(
eventType
(
)
=
>
{
executeSoon
(
resolve
)
;
}
{
once
:
true
}
)
;
}
)
;
}
function
promisePageActionViewShown
(
)
{
info
(
"
promisePageActionViewShown
waiting
for
ViewShown
"
)
;
return
BrowserTestUtils
.
waitForEvent
(
BrowserPageActions
.
panelNode
"
ViewShown
"
)
.
then
(
async
event
=
>
{
let
panelViewNode
=
event
.
originalTarget
;
await
promisePageActionViewChildrenVisible
(
panelViewNode
)
;
return
panelViewNode
;
}
)
;
}
async
function
promisePageActionViewChildrenVisible
(
panelViewNode
)
{
info
(
"
promisePageActionViewChildrenVisible
waiting
for
a
child
node
to
be
visible
"
)
;
await
new
Promise
(
requestAnimationFrame
)
;
let
dwu
=
window
.
windowUtils
;
return
TestUtils
.
waitForCondition
(
(
)
=
>
{
let
bodyNode
=
panelViewNode
.
firstElementChild
;
for
(
let
childNode
of
bodyNode
.
children
)
{
let
bounds
=
dwu
.
getBoundsWithoutFlushing
(
childNode
)
;
if
(
bounds
.
width
>
0
&
&
bounds
.
height
>
0
)
{
return
true
;
}
}
return
false
;
}
)
;
}
async
function
initPageActionsTest
(
)
{
await
disableNonReleaseActions
(
)
;
const
addon
=
await
AddonManager
.
getAddonByID
(
"
screenshots
mozilla
.
org
"
)
;
await
addon
.
disable
(
{
allowSystemAddons
:
true
}
)
;
gProtonUrlbar
=
Services
.
prefs
.
getBoolPref
(
PROTON_URLBAR_PREF
false
)
;
if
(
gProtonUrlbar
)
{
BrowserPageActions
.
mainButtonNode
.
style
.
visibility
=
"
visible
"
;
registerCleanupFunction
(
(
)
=
>
{
BrowserPageActions
.
mainButtonNode
.
style
.
removeProperty
(
"
visibility
"
)
;
}
)
;
}
}
