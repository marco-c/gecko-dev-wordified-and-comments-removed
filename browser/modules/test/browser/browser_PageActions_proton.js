"
use
strict
"
;
const
PROTON_PREF
=
"
browser
.
proton
.
enabled
"
;
const
PERSISTED_ACTIONS_PREF
=
"
browser
.
pageActions
.
persistedActions
"
;
const
TEST_ACTION_ID
=
"
browser_PageActions_proton
"
;
const
IGNORED_ACTION_IDS
=
new
Set
(
[
"
addSearchEngine
"
"
screenshots_mozilla_org
"
]
)
;
requestLongerTimeout
(
10
)
;
add_task
(
async
function
init
(
)
{
await
disableNonReleaseActions
(
)
;
let
initialActions
=
PageActions
.
actions
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
PERSISTED_ACTIONS_PREF
)
;
PageActions
.
init
(
false
)
;
for
(
let
action
of
initialActions
)
{
if
(
!
PageActions
.
actionForID
(
action
.
id
)
)
{
PageActions
.
addAction
(
action
)
;
}
}
}
)
;
}
)
;
add_task
(
async
function
newProfile_noProton_proton_noProton
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
PROTON_PREF
false
]
]
}
)
;
simulateRestart
(
{
newProfile
:
true
}
)
;
Assert
.
deepEqual
(
ids
(
PageActions
.
_persistedActions
.
ids
)
ids
(
PageActions
.
actions
)
"
Initial
PageActions
.
_persistedActions
.
ids
"
)
;
Assert
.
deepEqual
(
ids
(
PageActions
.
_persistedActions
.
idsInUrlbar
false
)
ids
(
[
PageActions
.
ACTION_ID_BOOKMARK
]
false
)
"
Inital
PageActions
.
_persistedActions
.
idsInUrlbar
"
)
;
Assert
.
ok
(
!
PageActions
.
_persistedActions
.
idsInUrlbarPreProton
"
Initial
PageActions
.
_persistedActions
.
idsInUrlbarPreProton
"
)
;
let
copyURLAction
=
PageActions
.
actionForID
(
"
copyURL
"
)
;
Assert
.
ok
(
copyURLAction
"
copyURL
action
exists
when
Proton
is
disabled
"
)
;
copyURLAction
.
pinnedToUrlbar
=
true
;
let
testAction
=
new
PageActions
.
Action
(
{
id
:
TEST_ACTION_ID
pinnedToUrlbar
:
true
}
)
;
PageActions
.
addAction
(
testAction
)
;
simulateRestart
(
{
restoringActions
:
[
testAction
]
}
)
;
let
idsInUrlbar
=
[
copyURLAction
.
id
testAction
.
id
PageActions
.
ACTION_ID_BOOKMARK
]
;
await
assertProtonNotApplied
(
{
idsInUrlbar
}
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
PROTON_PREF
true
]
]
}
)
;
await
assertProtonNotApplied
(
{
idsInUrlbar
}
)
;
simulateRestart
(
{
restoringActions
:
[
testAction
]
}
)
;
await
assertProtonApplied
(
{
idsInUrlbarPreProton
:
idsInUrlbar
idsInUrlbarExtra
:
[
copyURLAction
.
id
]
}
)
;
simulateRestart
(
{
restoringActions
:
[
testAction
]
}
)
;
await
assertProtonApplied
(
{
idsInUrlbarPreProton
:
idsInUrlbar
}
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
await
assertProtonApplied
(
{
idsInUrlbarPreProton
:
idsInUrlbar
}
)
;
simulateRestart
(
{
restoringActions
:
[
testAction
]
}
)
;
await
assertProtonNotApplied
(
{
idsInUrlbar
}
)
;
testAction
.
remove
(
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
)
;
add_task
(
async
function
newProfile_proton_noProton_proton
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
PROTON_PREF
true
]
]
}
)
;
simulateRestart
(
{
newProfile
:
true
}
)
;
Assert
.
deepEqual
(
ids
(
PageActions
.
_persistedActions
.
ids
)
ids
(
PageActions
.
actions
)
"
Initial
PageActions
.
_persistedActions
.
ids
"
)
;
Assert
.
deepEqual
(
ids
(
PageActions
.
_persistedActions
.
idsInUrlbar
)
ids
(
PageActions
.
actions
.
filter
(
a
=
>
!
a
.
__isSeparator
)
)
"
Inital
PageActions
.
_persistedActions
.
idsInUrlbar
"
)
;
Assert
.
equal
(
PageActions
.
_persistedActions
.
idsInUrlbar
[
PageActions
.
_persistedActions
.
idsInUrlbar
.
length
-
1
]
PageActions
.
ACTION_ID_BOOKMARK
"
Inital
PageActions
.
_persistedActions
.
idsInUrlbar
has
bookmark
action
last
"
)
;
Assert
.
deepEqual
(
PageActions
.
_persistedActions
.
idsInUrlbarPreProton
[
]
"
Initial
PageActions
.
_persistedActions
.
idsInUrlbarPreProton
"
)
;
let
testAction
=
new
PageActions
.
Action
(
{
id
:
TEST_ACTION_ID
pinnedToUrlbar
:
true
}
)
;
PageActions
.
addAction
(
testAction
)
;
simulateRestart
(
{
restoringActions
:
[
testAction
]
}
)
;
await
assertProtonApplied
(
{
idsInUrlbarPreProton
:
[
]
}
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
PROTON_PREF
false
]
]
}
)
;
await
assertProtonApplied
(
{
idsInUrlbarPreProton
:
[
]
}
)
;
simulateRestart
(
{
restoringActions
:
[
testAction
]
}
)
;
let
idsInUrlbar
=
[
PageActions
.
ACTION_ID_BOOKMARK
]
;
await
assertProtonNotApplied
(
{
idsInUrlbar
}
)
;
testAction
.
pinnedToUrlbar
=
true
;
simulateRestart
(
{
restoringActions
:
[
testAction
]
}
)
;
idsInUrlbar
.
splice
(
idsInUrlbar
.
length
-
1
0
testAction
.
id
)
;
await
assertProtonNotApplied
(
{
idsInUrlbar
}
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
await
assertProtonNotApplied
(
{
idsInUrlbar
}
)
;
simulateRestart
(
{
restoringActions
:
[
testAction
]
}
)
;
await
assertProtonApplied
(
{
idsInUrlbarPreProton
:
idsInUrlbar
}
)
;
testAction
.
remove
(
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
)
;
function
simulateRestart
(
{
newProfile
=
false
restoringActions
=
[
]
}
=
{
}
)
{
info
(
"
Simulating
restart
.
.
.
"
)
;
PageActions
.
_purgeUnregisteredPersistedActions
(
)
;
for
(
let
action
of
PageActions
.
actions
)
{
action
.
remove
(
)
;
}
if
(
newProfile
)
{
Services
.
prefs
.
clearUserPref
(
PERSISTED_ACTIONS_PREF
)
;
}
PageActions
.
init
(
false
)
;
for
(
let
action
of
restoringActions
)
{
if
(
!
PageActions
.
actionForID
(
action
.
id
)
)
{
PageActions
.
addAction
(
action
)
;
}
}
info
(
"
Simulating
restart
done
PageActions
.
_persistedActions
=
"
+
JSON
.
stringify
(
PageActions
.
_persistedActions
)
)
;
}
async
function
assertProtonApplied
(
{
idsInUrlbarPreProton
idsInUrlbarExtra
=
[
]
}
)
{
info
(
"
Asserting
Proton
is
applied
.
.
.
"
)
;
Assert
.
deepEqual
(
ids
(
PageActions
.
_persistedActions
.
idsInUrlbar
)
ids
(
PageActions
.
actions
.
filter
(
a
=
>
!
a
.
__isSeparator
)
.
concat
(
idsInUrlbarExtra
)
)
"
idsInUrlbar
when
Proton
applied
"
)
;
if
(
!
idsInUrlbarPreProton
)
{
Assert
.
ok
(
!
PageActions
.
_persistedActions
.
idsInUrlbarPreProton
"
idsInUrlbarPreProton
does
not
exist
when
Proton
applied
"
)
;
}
else
{
Assert
.
deepEqual
(
ids
(
PageActions
.
_persistedActions
.
idsInUrlbarPreProton
)
ids
(
idsInUrlbarPreProton
)
"
idsInUrlbarPreProton
when
Proton
applied
"
)
;
}
assertCommonState
(
{
idsInUrlbarExtra
}
)
;
await
checkNewWindow
(
{
idsInUrlbarExtra
}
)
;
}
async
function
assertProtonNotApplied
(
{
idsInUrlbar
}
)
{
info
(
"
Asserting
Proton
is
not
applied
.
.
.
"
)
;
Assert
.
deepEqual
(
ids
(
PageActions
.
_persistedActions
.
idsInUrlbar
false
)
ids
(
idsInUrlbar
false
)
"
idsInUrlbar
when
Proton
not
applied
"
)
;
Assert
.
ok
(
!
PageActions
.
_persistedActions
.
idsInUrlbarPreProton
"
idsInUrlbarPreProton
does
not
exist
when
Proton
not
applied
"
)
;
assertCommonState
(
)
;
await
checkNewWindow
(
)
;
}
function
assertCommonState
(
{
idsInUrlbarExtra
=
[
]
}
=
{
}
)
{
Assert
.
equal
(
PageActions
.
_persistedActions
.
idsInUrlbar
[
PageActions
.
_persistedActions
.
idsInUrlbar
.
length
-
1
]
PageActions
.
ACTION_ID_BOOKMARK
"
Bookmark
action
is
last
in
idsInUrlbar
"
)
;
Assert
.
deepEqual
(
ids
(
PageActions
.
actionsInUrlbar
(
window
)
false
)
ids
(
PageActions
.
_persistedActions
.
idsInUrlbar
.
filter
(
id
=
>
!
idsInUrlbarExtra
.
includes
(
id
)
)
false
)
"
actionsInUrlbar
matches
idsInUrlbar
"
)
;
}
async
function
checkNewWindow
(
{
idsInUrlbarExtra
=
[
]
}
=
{
}
)
{
if
(
AppConstants
.
platform
=
=
"
macosx
"
&
&
AppConstants
.
DEBUG
)
{
info
(
"
Skipping
checkNewWindow
on
Mac
debug
due
to
TV
failures
"
)
;
return
;
}
info
(
"
Checking
a
new
window
.
.
.
"
)
;
let
win
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
await
BrowserTestUtils
.
openNewForegroundTab
(
{
gBrowser
:
win
.
gBrowser
url
:
"
http
:
/
/
example
.
com
/
"
}
)
;
let
ignoredElementIDs
=
Array
.
from
(
IGNORED_ACTION_IDS
)
.
map
(
id
=
>
win
.
BrowserPageActions
.
urlbarButtonNodeIDForActionID
(
id
)
)
;
let
elementIDs
=
[
]
;
for
(
let
element
=
win
.
BrowserPageActions
.
mainButtonNode
.
nextElementSibling
;
element
;
element
=
element
.
nextElementSibling
)
{
if
(
!
ignoredElementIDs
.
includes
(
element
.
id
)
)
{
elementIDs
.
push
(
element
.
id
)
;
}
}
Assert
.
deepEqual
(
elementIDs
ids
(
PageActions
.
_persistedActions
.
idsInUrlbar
.
filter
(
id
=
>
!
idsInUrlbarExtra
.
includes
(
id
)
)
false
)
.
map
(
id
=
>
win
.
BrowserPageActions
.
urlbarButtonNodeIDForActionID
(
id
)
)
"
Actions
in
new
window
'
s
urlbar
"
)
;
await
BrowserTestUtils
.
closeWindow
(
win
)
;
}
function
ids
(
idsOrActions
sort
=
true
)
{
let
array
=
idsOrActions
.
map
(
obj
=
>
(
typeof
obj
=
=
"
string
"
?
obj
:
obj
.
id
)
)
.
filter
(
id
=
>
!
IGNORED_ACTION_IDS
.
has
(
id
)
)
;
if
(
sort
)
{
array
=
array
.
sort
(
)
;
}
return
array
;
}
