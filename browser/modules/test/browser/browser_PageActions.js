"
use
strict
"
;
add_task
(
async
function
init
(
)
{
let
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
{
gBrowser
url
:
"
http
:
/
/
example
.
com
/
"
}
)
;
await
disableNonReleaseActions
(
)
;
registerCleanupFunction
(
async
(
)
=
>
{
BrowserTestUtils
.
removeTab
(
tab
)
;
}
)
;
const
addon
=
await
AddonManager
.
getAddonByID
(
"
screenshots
mozilla
.
org
"
)
;
await
addon
.
disable
(
{
allowSystemAddons
:
true
}
)
;
}
)
;
add_task
(
async
function
simple
(
)
{
let
iconURL
=
"
chrome
:
/
/
browser
/
skin
/
mail
.
svg
"
;
let
id
=
"
test
-
simple
"
;
let
title
=
"
Test
simple
"
;
let
tooltip
=
"
Test
simple
tooltip
"
;
let
onCommandCallCount
=
0
;
let
onPlacedInPanelCallCount
=
0
;
let
onPlacedInUrlbarCallCount
=
0
;
let
onShowingInPanelCallCount
=
0
;
let
onCommandExpectedButtonID
;
let
panelButtonID
=
BrowserPageActions
.
panelButtonNodeIDForActionID
(
id
)
;
let
urlbarButtonID
=
BrowserPageActions
.
urlbarButtonNodeIDForActionID
(
id
)
;
await
promiseOpenPageActionPanel
(
)
;
EventUtils
.
synthesizeMouseAtCenter
(
BrowserPageActions
.
mainButtonNode
{
}
)
;
await
promisePageActionPanelHidden
(
)
;
let
initialActions
=
PageActions
.
actions
;
let
initialActionsInPanel
=
PageActions
.
actionsInPanel
(
window
)
;
let
initialActionsInUrlbar
=
PageActions
.
actionsInUrlbar
(
window
)
;
let
action
=
PageActions
.
addAction
(
new
PageActions
.
Action
(
{
iconURL
id
title
tooltip
onCommand
(
event
buttonNode
)
{
onCommandCallCount
+
+
;
Assert
.
ok
(
event
"
event
should
be
non
-
null
:
"
+
event
)
;
Assert
.
ok
(
buttonNode
"
buttonNode
should
be
non
-
null
:
"
+
buttonNode
)
;
Assert
.
equal
(
buttonNode
.
id
onCommandExpectedButtonID
"
buttonNode
.
id
"
)
;
}
onPlacedInPanel
(
buttonNode
)
{
onPlacedInPanelCallCount
+
+
;
Assert
.
ok
(
buttonNode
"
buttonNode
should
be
non
-
null
:
"
+
buttonNode
)
;
Assert
.
equal
(
buttonNode
.
id
panelButtonID
"
buttonNode
.
id
"
)
;
}
onPlacedInUrlbar
(
buttonNode
)
{
onPlacedInUrlbarCallCount
+
+
;
Assert
.
ok
(
buttonNode
"
buttonNode
should
be
non
-
null
:
"
+
buttonNode
)
;
Assert
.
equal
(
buttonNode
.
id
urlbarButtonID
"
buttonNode
.
id
"
)
;
}
onShowingInPanel
(
buttonNode
)
{
onShowingInPanelCallCount
+
+
;
Assert
.
ok
(
buttonNode
"
buttonNode
should
be
non
-
null
:
"
+
buttonNode
)
;
Assert
.
equal
(
buttonNode
.
id
panelButtonID
"
buttonNode
.
id
"
)
;
}
}
)
)
;
Assert
.
equal
(
action
.
getIconURL
(
)
iconURL
"
iconURL
"
)
;
Assert
.
equal
(
action
.
id
id
"
id
"
)
;
Assert
.
equal
(
action
.
pinnedToUrlbar
false
"
pinnedToUrlbar
"
)
;
Assert
.
equal
(
action
.
getDisabled
(
)
false
"
disabled
"
)
;
Assert
.
equal
(
action
.
getDisabled
(
window
)
false
"
disabled
in
window
"
)
;
Assert
.
equal
(
action
.
getTitle
(
)
title
"
title
"
)
;
Assert
.
equal
(
action
.
getTitle
(
window
)
title
"
title
in
window
"
)
;
Assert
.
equal
(
action
.
getTooltip
(
)
tooltip
"
tooltip
"
)
;
Assert
.
equal
(
action
.
getTooltip
(
window
)
tooltip
"
tooltip
in
window
"
)
;
Assert
.
equal
(
action
.
getWantsSubview
(
)
false
"
subview
"
)
;
Assert
.
equal
(
action
.
getWantsSubview
(
window
)
false
"
subview
in
window
"
)
;
Assert
.
equal
(
action
.
urlbarIDOverride
null
"
urlbarIDOverride
"
)
;
Assert
.
equal
(
action
.
wantsIframe
false
"
wantsIframe
"
)
;
Assert
.
ok
(
!
(
"
__insertBeforeActionID
"
in
action
)
"
__insertBeforeActionID
"
)
;
Assert
.
ok
(
!
(
"
__isSeparator
"
in
action
)
"
__isSeparator
"
)
;
Assert
.
ok
(
!
(
"
__urlbarNodeInMarkup
"
in
action
)
"
__urlbarNodeInMarkup
"
)
;
Assert
.
ok
(
!
(
"
__transient
"
in
action
)
"
__transient
"
)
;
Assert
.
equal
(
onPlacedInPanelCallCount
0
"
onPlacedInPanelCallCount
should
remain
0
"
)
;
Assert
.
equal
(
onPlacedInUrlbarCallCount
0
"
onPlacedInUrlbarCallCount
should
remain
0
"
)
;
Assert
.
equal
(
onShowingInPanelCallCount
0
"
onShowingInPanelCallCount
should
remain
0
"
)
;
await
promiseOpenPageActionPanel
(
)
;
EventUtils
.
synthesizeMouseAtCenter
(
BrowserPageActions
.
mainButtonNode
{
}
)
;
await
promisePageActionPanelHidden
(
)
;
Assert
.
equal
(
onPlacedInPanelCallCount
1
"
onPlacedInPanelCallCount
should
be
inc
'
ed
"
)
;
Assert
.
equal
(
onShowingInPanelCallCount
1
"
onShowingInPanelCallCount
should
be
inc
'
ed
"
)
;
let
sepIndex
=
initialActionsInPanel
.
findIndex
(
a
=
>
a
.
id
=
=
PageActions
.
ACTION_ID_BUILT_IN_SEPARATOR
)
;
let
initialSepIndex
=
sepIndex
;
let
indexInPanel
;
if
(
sepIndex
<
0
)
{
indexInPanel
=
initialActionsInPanel
.
length
;
}
else
{
for
(
indexInPanel
=
sepIndex
+
1
;
indexInPanel
<
initialActionsInPanel
.
length
;
indexInPanel
+
+
)
{
let
a
=
initialActionsInPanel
[
indexInPanel
]
;
if
(
a
.
getTitle
(
)
.
localeCompare
(
action
.
getTitle
(
)
)
<
1
)
{
break
;
}
}
}
let
expectedActionsInPanel
=
initialActionsInPanel
.
slice
(
)
;
expectedActionsInPanel
.
splice
(
indexInPanel
0
action
)
;
if
(
sepIndex
<
0
)
{
expectedActionsInPanel
.
splice
(
indexInPanel
0
new
PageActions
.
Action
(
{
id
:
PageActions
.
ACTION_ID_BUILT_IN_SEPARATOR
_isSeparator
:
true
}
)
)
;
sepIndex
=
indexInPanel
;
indexInPanel
+
+
;
}
Assert
.
deepEqual
(
PageActions
.
actionsInPanel
(
window
)
expectedActionsInPanel
"
Actions
in
panel
after
adding
the
action
"
)
;
Assert
.
deepEqual
(
PageActions
.
actionsInUrlbar
(
window
)
initialActionsInUrlbar
"
Actions
in
urlbar
after
adding
the
action
"
)
;
Assert
.
deepEqual
(
new
Set
(
PageActions
.
actions
)
new
Set
(
initialActions
.
concat
(
[
action
]
)
)
"
All
actions
after
adding
the
action
"
)
;
Assert
.
deepEqual
(
PageActions
.
actionForID
(
action
.
id
)
action
"
actionForID
should
be
action
"
)
;
Assert
.
ok
(
PageActions
.
_persistedActions
.
ids
.
includes
(
action
.
id
)
"
PageActions
should
record
action
in
its
list
of
seen
actions
"
)
;
let
panelButtonNode
=
BrowserPageActions
.
mainViewBodyNode
.
children
[
indexInPanel
]
;
Assert
.
notEqual
(
panelButtonNode
null
"
panelButtonNode
"
)
;
Assert
.
equal
(
panelButtonNode
.
id
panelButtonID
"
panelButtonID
"
)
;
Assert
.
equal
(
panelButtonNode
.
getAttribute
(
"
label
"
)
action
.
getTitle
(
)
"
label
"
)
;
let
sepNode
=
BrowserPageActions
.
mainViewBodyNode
.
children
[
sepIndex
]
;
Assert
.
notEqual
(
sepNode
null
"
sepNode
"
)
;
Assert
.
equal
(
sepNode
.
id
BrowserPageActions
.
panelButtonNodeIDForActionID
(
PageActions
.
ACTION_ID_BUILT_IN_SEPARATOR
)
"
sepNode
.
id
"
)
;
let
urlbarButtonNode
=
document
.
getElementById
(
urlbarButtonID
)
;
Assert
.
equal
(
urlbarButtonNode
null
"
urlbarButtonNode
"
)
;
await
promiseOpenPageActionPanel
(
)
;
Assert
.
equal
(
onShowingInPanelCallCount
2
"
onShowingInPanelCallCount
should
be
inc
'
ed
"
)
;
onCommandExpectedButtonID
=
panelButtonID
;
EventUtils
.
synthesizeMouseAtCenter
(
panelButtonNode
{
}
)
;
await
promisePageActionPanelHidden
(
)
;
Assert
.
equal
(
onCommandCallCount
1
"
onCommandCallCount
should
be
inc
'
ed
"
)
;
action
.
pinnedToUrlbar
=
true
;
Assert
.
equal
(
onPlacedInUrlbarCallCount
1
"
onPlacedInUrlbarCallCount
should
be
inc
'
ed
"
)
;
urlbarButtonNode
=
document
.
getElementById
(
urlbarButtonID
)
;
Assert
.
notEqual
(
urlbarButtonNode
null
"
urlbarButtonNode
"
)
;
Assert
.
notEqual
(
urlbarButtonNode
.
nextElementSibling
null
"
Should
be
a
next
node
"
)
;
Assert
.
equal
(
urlbarButtonNode
.
nextElementSibling
.
id
PageActions
.
actionForID
(
PageActions
.
ACTION_ID_BOOKMARK
)
.
urlbarIDOverride
"
Next
node
should
be
the
bookmark
star
"
)
;
action
.
setDisabled
(
true
)
;
urlbarButtonNode
=
document
.
getElementById
(
urlbarButtonID
)
;
Assert
.
equal
(
urlbarButtonNode
null
"
urlbar
button
should
be
removed
"
)
;
Assert
.
equal
(
panelButtonNode
.
disabled
true
"
panel
button
should
be
disabled
"
)
;
action
.
setDisabled
(
false
)
;
urlbarButtonNode
=
document
.
getElementById
(
urlbarButtonID
)
;
Assert
.
notEqual
(
urlbarButtonNode
null
"
urlbar
button
should
be
added
back
"
)
;
Assert
.
equal
(
panelButtonNode
.
disabled
false
"
panel
button
should
not
be
disabled
"
)
;
onCommandExpectedButtonID
=
urlbarButtonID
;
EventUtils
.
synthesizeMouseAtCenter
(
urlbarButtonNode
{
}
)
;
Assert
.
equal
(
onCommandCallCount
2
"
onCommandCallCount
should
be
inc
'
ed
"
)
;
let
newTitle
=
title
+
"
new
title
"
;
action
.
setTitle
(
newTitle
)
;
Assert
.
equal
(
action
.
getTitle
(
)
newTitle
"
New
title
"
)
;
Assert
.
equal
(
panelButtonNode
.
getAttribute
(
"
label
"
)
action
.
getTitle
(
)
"
New
label
"
)
;
PageActions
.
_actionsByID
.
delete
(
action
.
id
)
;
let
index
=
PageActions
.
_nonBuiltInActions
.
findIndex
(
a
=
>
a
.
id
=
=
action
.
id
)
;
Assert
.
ok
(
index
>
=
0
"
Action
should
be
in
_nonBuiltInActions
to
begin
with
"
)
;
PageActions
.
_nonBuiltInActions
.
splice
(
index
1
)
;
PageActions
.
_registerAction
(
action
)
;
Assert
.
ok
(
PageActions
.
_persistedActions
.
ids
.
includes
(
action
.
id
)
"
PageActions
should
have
'
seen
'
the
action
"
)
;
Assert
.
ok
(
PageActions
.
_persistedActions
.
idsInUrlbar
.
includes
(
action
.
id
)
"
idsInUrlbar
should
still
include
the
action
"
)
;
Assert
.
ok
(
action
.
pinnedToUrlbar
"
pinnedToUrlbar
should
still
be
true
"
)
;
Assert
.
ok
(
action
.
_pinnedToUrlbar
"
_pinnedToUrlbar
should
still
be
true
for
good
measure
"
)
;
action
.
remove
(
)
;
panelButtonNode
=
document
.
getElementById
(
panelButtonID
)
;
Assert
.
equal
(
panelButtonNode
null
"
panelButtonNode
"
)
;
urlbarButtonNode
=
document
.
getElementById
(
urlbarButtonID
)
;
Assert
.
equal
(
urlbarButtonNode
null
"
urlbarButtonNode
"
)
;
let
separatorNode
=
document
.
getElementById
(
BrowserPageActions
.
panelButtonNodeIDForActionID
(
PageActions
.
ACTION_ID_BUILT_IN_SEPARATOR
)
)
;
if
(
initialSepIndex
<
0
)
{
Assert
.
equal
(
separatorNode
null
"
No
separator
"
)
;
Assert
.
ok
(
!
BrowserPageActions
.
mainViewBodyNode
.
lastElementChild
.
localName
.
includes
(
"
separator
"
)
"
Last
child
should
not
be
separator
"
)
;
}
else
{
Assert
.
notEqual
(
separatorNode
null
"
Separator
should
still
exist
"
)
;
}
Assert
.
deepEqual
(
PageActions
.
actionsInPanel
(
window
)
initialActionsInPanel
"
Actions
in
panel
should
go
back
to
initial
"
)
;
Assert
.
deepEqual
(
PageActions
.
actionsInUrlbar
(
window
)
initialActionsInUrlbar
"
Actions
in
urlbar
should
go
back
to
initial
"
)
;
Assert
.
deepEqual
(
PageActions
.
actions
initialActions
"
Actions
should
go
back
to
initial
"
)
;
Assert
.
equal
(
PageActions
.
actionForID
(
action
.
id
)
null
"
actionForID
should
be
null
"
)
;
Assert
.
ok
(
PageActions
.
_persistedActions
.
ids
.
includes
(
action
.
id
)
"
Action
ID
should
remain
in
cache
until
purged
"
)
;
PageActions
.
_purgeUnregisteredPersistedActions
(
)
;
Assert
.
ok
(
!
PageActions
.
_persistedActions
.
ids
.
includes
(
action
.
id
)
"
Action
ID
should
be
removed
from
cache
after
being
purged
"
)
;
}
)
;
add_task
(
async
function
withSubview
(
)
{
let
id
=
"
test
-
subview
"
;
let
onActionPlacedInPanelCallCount
=
0
;
let
onActionPlacedInUrlbarCallCount
=
0
;
let
onSubviewPlacedCount
=
0
;
let
onSubviewShowingCount
=
0
;
let
panelButtonID
=
BrowserPageActions
.
panelButtonNodeIDForActionID
(
id
)
;
let
urlbarButtonID
=
BrowserPageActions
.
urlbarButtonNodeIDForActionID
(
id
)
;
let
panelViewIDPanel
=
BrowserPageActions
.
_panelViewNodeIDForActionID
(
id
false
)
;
let
panelViewIDUrlbar
=
BrowserPageActions
.
_panelViewNodeIDForActionID
(
id
true
)
;
let
onSubviewPlacedExpectedPanelViewID
=
panelViewIDPanel
;
let
onSubviewShowingExpectedPanelViewID
;
let
action
=
PageActions
.
addAction
(
new
PageActions
.
Action
(
{
iconURL
:
"
chrome
:
/
/
browser
/
skin
/
mail
.
svg
"
id
pinnedToUrlbar
:
true
title
:
"
Test
subview
"
wantsSubview
:
true
onPlacedInPanel
(
buttonNode
)
{
onActionPlacedInPanelCallCount
+
+
;
Assert
.
ok
(
buttonNode
"
buttonNode
should
be
non
-
null
:
"
+
buttonNode
)
;
Assert
.
equal
(
buttonNode
.
id
panelButtonID
"
buttonNode
.
id
"
)
;
}
onPlacedInUrlbar
(
buttonNode
)
{
onActionPlacedInUrlbarCallCount
+
+
;
Assert
.
ok
(
buttonNode
"
buttonNode
should
be
non
-
null
:
"
+
buttonNode
)
;
Assert
.
equal
(
buttonNode
.
id
urlbarButtonID
"
buttonNode
.
id
"
)
;
}
onSubviewPlaced
(
panelViewNode
)
{
onSubviewPlacedCount
+
+
;
Assert
.
ok
(
panelViewNode
"
panelViewNode
should
be
non
-
null
:
"
+
panelViewNode
)
;
Assert
.
equal
(
panelViewNode
.
id
onSubviewPlacedExpectedPanelViewID
"
panelViewNode
.
id
"
)
;
}
onSubviewShowing
(
panelViewNode
)
{
onSubviewShowingCount
+
+
;
Assert
.
ok
(
panelViewNode
"
panelViewNode
should
be
non
-
null
:
"
+
panelViewNode
)
;
Assert
.
equal
(
panelViewNode
.
id
onSubviewShowingExpectedPanelViewID
"
panelViewNode
.
id
"
)
;
}
}
)
)
;
Assert
.
equal
(
action
.
id
id
"
id
"
)
;
Assert
.
equal
(
action
.
getWantsSubview
(
)
true
"
subview
"
)
;
Assert
.
equal
(
action
.
getWantsSubview
(
window
)
true
"
subview
in
window
"
)
;
Assert
.
equal
(
onActionPlacedInPanelCallCount
0
"
onActionPlacedInPanelCallCount
should
be
0
"
)
;
Assert
.
equal
(
onSubviewPlacedCount
0
"
onSubviewPlacedCount
should
be
0
"
)
;
Assert
.
equal
(
onActionPlacedInUrlbarCallCount
1
"
onActionPlacedInUrlbarCallCount
should
be
0
"
)
;
await
promiseOpenPageActionPanel
(
)
;
Assert
.
equal
(
onActionPlacedInPanelCallCount
1
"
onActionPlacedInPanelCallCount
should
be
inc
'
ed
"
)
;
Assert
.
equal
(
onSubviewPlacedCount
1
"
onSubviewPlacedCount
should
be
inc
'
ed
"
)
;
Assert
.
equal
(
onSubviewShowingCount
0
"
onSubviewShowingCount
should
remain
0
"
)
;
let
panelButtonNode
=
document
.
getElementById
(
panelButtonID
)
;
Assert
.
notEqual
(
panelButtonNode
null
"
panelButtonNode
"
)
;
let
urlbarButtonNode
=
document
.
getElementById
(
urlbarButtonID
)
;
Assert
.
notEqual
(
urlbarButtonNode
null
"
urlbarButtonNode
"
)
;
Assert
.
notEqual
(
urlbarButtonNode
.
nextElementSibling
null
"
Should
be
a
next
node
"
)
;
Assert
.
equal
(
urlbarButtonNode
.
nextElementSibling
.
id
PageActions
.
actionForID
(
PageActions
.
ACTION_ID_BOOKMARK
)
.
urlbarIDOverride
"
Next
node
should
be
the
bookmark
star
"
)
;
Assert
.
equal
(
onSubviewShowingCount
0
"
onSubviewShowingCount
should
remain
0
"
)
;
let
subviewShownPromise
=
promisePageActionViewShown
(
)
;
onSubviewShowingExpectedPanelViewID
=
panelViewIDPanel
;
panelButtonNode
.
click
(
)
;
await
subviewShownPromise
;
EventUtils
.
synthesizeMouseAtCenter
(
BrowserPageActions
.
mainButtonNode
{
}
)
;
await
promisePageActionPanelHidden
(
)
;
onSubviewPlacedExpectedPanelViewID
=
panelViewIDUrlbar
;
onSubviewShowingExpectedPanelViewID
=
panelViewIDUrlbar
;
EventUtils
.
synthesizeMouseAtCenter
(
urlbarButtonNode
{
}
)
;
await
promisePanelShown
(
BrowserPageActions
.
_activatedActionPanelID
)
;
Assert
.
equal
(
onSubviewPlacedCount
2
"
onSubviewPlacedCount
should
be
inc
'
ed
"
)
;
Assert
.
equal
(
onSubviewShowingCount
2
"
onSubviewShowingCount
should
be
inc
'
ed
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
urlbarButtonNode
{
}
)
;
assertActivatedPageActionPanelHidden
(
)
;
action
.
remove
(
)
;
panelButtonNode
=
document
.
getElementById
(
panelButtonID
)
;
Assert
.
equal
(
panelButtonNode
null
"
panelButtonNode
"
)
;
urlbarButtonNode
=
document
.
getElementById
(
urlbarButtonID
)
;
Assert
.
equal
(
urlbarButtonNode
null
"
urlbarButtonNode
"
)
;
let
panelViewNodePanel
=
document
.
getElementById
(
panelViewIDPanel
)
;
Assert
.
equal
(
panelViewNodePanel
null
"
panelViewNodePanel
"
)
;
let
panelViewNodeUrlbar
=
document
.
getElementById
(
panelViewIDUrlbar
)
;
Assert
.
equal
(
panelViewNodeUrlbar
null
"
panelViewNodeUrlbar
"
)
;
}
)
;
add_task
(
async
function
withIframe
(
)
{
let
id
=
"
test
-
iframe
"
;
let
onCommandCallCount
=
0
;
let
onPlacedInPanelCallCount
=
0
;
let
onPlacedInUrlbarCallCount
=
0
;
let
onIframeShowingCount
=
0
;
let
panelButtonID
=
BrowserPageActions
.
panelButtonNodeIDForActionID
(
id
)
;
let
urlbarButtonID
=
BrowserPageActions
.
urlbarButtonNodeIDForActionID
(
id
)
;
let
action
=
PageActions
.
addAction
(
new
PageActions
.
Action
(
{
iconURL
:
"
chrome
:
/
/
browser
/
skin
/
mail
.
svg
"
id
pinnedToUrlbar
:
true
title
:
"
Test
iframe
"
wantsIframe
:
true
onCommand
(
event
buttonNode
)
{
onCommandCallCount
+
+
;
}
onIframeShowing
(
iframeNode
panelNode
)
{
onIframeShowingCount
+
+
;
Assert
.
ok
(
iframeNode
"
iframeNode
should
be
non
-
null
:
"
+
iframeNode
)
;
Assert
.
equal
(
iframeNode
.
localName
"
iframe
"
"
iframe
localName
"
)
;
Assert
.
ok
(
panelNode
"
panelNode
should
be
non
-
null
:
"
+
panelNode
)
;
Assert
.
equal
(
panelNode
.
id
BrowserPageActions
.
_activatedActionPanelID
"
panelNode
.
id
"
)
;
}
onPlacedInPanel
(
buttonNode
)
{
onPlacedInPanelCallCount
+
+
;
Assert
.
ok
(
buttonNode
"
buttonNode
should
be
non
-
null
:
"
+
buttonNode
)
;
Assert
.
equal
(
buttonNode
.
id
panelButtonID
"
buttonNode
.
id
"
)
;
}
onPlacedInUrlbar
(
buttonNode
)
{
onPlacedInUrlbarCallCount
+
+
;
Assert
.
ok
(
buttonNode
"
buttonNode
should
be
non
-
null
:
"
+
buttonNode
)
;
Assert
.
equal
(
buttonNode
.
id
urlbarButtonID
"
buttonNode
.
id
"
)
;
}
}
)
)
;
Assert
.
equal
(
action
.
id
id
"
id
"
)
;
Assert
.
equal
(
action
.
wantsIframe
true
"
wantsIframe
"
)
;
await
promiseOpenPageActionPanel
(
)
;
EventUtils
.
synthesizeMouseAtCenter
(
BrowserPageActions
.
mainButtonNode
{
}
)
;
await
promisePageActionPanelHidden
(
)
;
Assert
.
equal
(
onPlacedInPanelCallCount
1
"
onPlacedInPanelCallCount
should
be
inc
'
ed
"
)
;
Assert
.
equal
(
onPlacedInUrlbarCallCount
1
"
onPlacedInUrlbarCallCount
should
be
inc
'
ed
"
)
;
Assert
.
equal
(
onIframeShowingCount
0
"
onIframeShowingCount
should
remain
0
"
)
;
Assert
.
equal
(
onCommandCallCount
0
"
onCommandCallCount
should
remain
0
"
)
;
let
panelButtonNode
=
document
.
getElementById
(
panelButtonID
)
;
Assert
.
notEqual
(
panelButtonNode
null
"
panelButtonNode
"
)
;
let
urlbarButtonNode
=
document
.
getElementById
(
urlbarButtonID
)
;
Assert
.
notEqual
(
urlbarButtonNode
null
"
urlbarButtonNode
"
)
;
Assert
.
notEqual
(
urlbarButtonNode
.
nextElementSibling
null
"
Should
be
a
next
node
"
)
;
Assert
.
equal
(
urlbarButtonNode
.
nextElementSibling
.
id
PageActions
.
actionForID
(
PageActions
.
ACTION_ID_BOOKMARK
)
.
urlbarIDOverride
"
Next
node
should
be
the
bookmark
star
"
)
;
await
promiseOpenPageActionPanel
(
)
;
Assert
.
equal
(
onIframeShowingCount
0
"
onIframeShowingCount
should
remain
0
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
panelButtonNode
{
}
)
;
await
promisePanelShown
(
BrowserPageActions
.
_activatedActionPanelID
)
;
Assert
.
equal
(
onCommandCallCount
1
"
onCommandCallCount
should
be
inc
'
ed
"
)
;
Assert
.
equal
(
onIframeShowingCount
1
"
onIframeShowingCount
should
be
inc
'
ed
"
)
;
let
aaPanel
=
document
.
getElementById
(
BrowserPageActions
.
_activatedActionPanelID
)
;
Assert
.
notEqual
(
aaPanel
null
"
activated
-
action
panel
"
)
;
Assert
.
equal
(
aaPanel
.
anchorNode
.
id
urlbarButtonID
"
aaPanel
.
anchorNode
.
id
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
urlbarButtonNode
{
}
)
;
assertActivatedPageActionPanelHidden
(
)
;
EventUtils
.
synthesizeMouseAtCenter
(
urlbarButtonNode
{
}
)
;
await
promisePanelShown
(
BrowserPageActions
.
_activatedActionPanelID
)
;
Assert
.
equal
(
onCommandCallCount
2
"
onCommandCallCount
should
be
inc
'
ed
"
)
;
Assert
.
equal
(
onIframeShowingCount
2
"
onIframeShowingCount
should
be
inc
'
ed
"
)
;
aaPanel
=
document
.
getElementById
(
BrowserPageActions
.
_activatedActionPanelID
)
;
Assert
.
notEqual
(
aaPanel
null
"
aaPanel
"
)
;
Assert
.
equal
(
aaPanel
.
anchorNode
.
id
urlbarButtonID
"
aaPanel
.
anchorNode
.
id
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
urlbarButtonNode
{
}
)
;
assertActivatedPageActionPanelHidden
(
)
;
action
.
pinnedToUrlbar
=
false
;
urlbarButtonNode
=
document
.
getElementById
(
urlbarButtonID
)
;
Assert
.
equal
(
urlbarButtonNode
null
"
urlbarButtonNode
"
)
;
await
promiseOpenPageActionPanel
(
)
;
EventUtils
.
synthesizeMouseAtCenter
(
panelButtonNode
{
}
)
;
await
promisePanelShown
(
BrowserPageActions
.
_activatedActionPanelID
)
;
Assert
.
equal
(
onCommandCallCount
3
"
onCommandCallCount
should
be
inc
'
ed
"
)
;
Assert
.
equal
(
onIframeShowingCount
3
"
onIframeShowingCount
should
be
inc
'
ed
"
)
;
aaPanel
=
document
.
getElementById
(
BrowserPageActions
.
_activatedActionPanelID
)
;
Assert
.
notEqual
(
aaPanel
null
"
aaPanel
"
)
;
Assert
.
equal
(
aaPanel
.
anchorNode
.
id
BrowserPageActions
.
mainButtonNode
.
id
"
aaPanel
.
anchorNode
.
id
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
BrowserPageActions
.
mainButtonNode
{
}
)
;
assertActivatedPageActionPanelHidden
(
)
;
action
.
remove
(
)
;
panelButtonNode
=
document
.
getElementById
(
panelButtonID
)
;
Assert
.
equal
(
panelButtonNode
null
"
panelButtonNode
"
)
;
urlbarButtonNode
=
document
.
getElementById
(
urlbarButtonID
)
;
Assert
.
equal
(
urlbarButtonNode
null
"
urlbarButtonNode
"
)
;
}
)
;
add_task
(
async
function
insertBeforeActionID
(
)
{
let
id
=
"
test
-
insertBeforeActionID
"
;
let
panelButtonID
=
BrowserPageActions
.
panelButtonNodeIDForActionID
(
id
)
;
let
initialActions
=
PageActions
.
actionsInPanel
(
window
)
;
let
initialBuiltInActions
=
PageActions
.
_builtInActions
.
slice
(
)
;
let
initialNonBuiltInActions
=
PageActions
.
_nonBuiltInActions
.
slice
(
)
;
let
initialBookmarkSeparatorIndex
=
initialActions
.
findIndex
(
a
=
>
{
return
a
.
id
=
=
PageActions
.
ACTION_ID_BOOKMARK_SEPARATOR
;
}
)
;
let
action
=
PageActions
.
addAction
(
new
PageActions
.
Action
(
{
id
title
:
"
Test
insertBeforeActionID
"
_insertBeforeActionID
:
PageActions
.
ACTION_ID_BOOKMARK_SEPARATOR
}
)
)
;
Assert
.
equal
(
action
.
id
id
"
id
"
)
;
Assert
.
ok
(
"
__insertBeforeActionID
"
in
action
"
__insertBeforeActionID
"
)
;
Assert
.
equal
(
action
.
__insertBeforeActionID
PageActions
.
ACTION_ID_BOOKMARK_SEPARATOR
"
action
.
__insertBeforeActionID
"
)
;
await
promiseOpenPageActionPanel
(
)
;
EventUtils
.
synthesizeMouseAtCenter
(
BrowserPageActions
.
mainButtonNode
{
}
)
;
await
promisePageActionPanelHidden
(
)
;
let
newActions
=
PageActions
.
actionsInPanel
(
window
)
;
Assert
.
equal
(
newActions
.
length
initialActions
.
length
+
1
"
PageActions
.
actions
.
length
should
be
updated
"
)
;
Assert
.
equal
(
PageActions
.
_builtInActions
.
length
initialBuiltInActions
.
length
+
1
"
PageActions
.
_builtInActions
.
length
should
be
updated
"
)
;
Assert
.
equal
(
PageActions
.
_nonBuiltInActions
.
length
initialNonBuiltInActions
.
length
"
PageActions
.
_nonBuiltInActions
.
length
should
remain
the
same
"
)
;
let
actionIndex
=
newActions
.
findIndex
(
a
=
>
a
.
id
=
=
id
)
;
Assert
.
equal
(
initialBookmarkSeparatorIndex
actionIndex
"
initialBookmarkSeparatorIndex
"
)
;
let
newBookmarkSeparatorIndex
=
newActions
.
findIndex
(
a
=
>
{
return
a
.
id
=
=
PageActions
.
ACTION_ID_BOOKMARK_SEPARATOR
;
}
)
;
Assert
.
equal
(
newBookmarkSeparatorIndex
initialBookmarkSeparatorIndex
+
1
"
newBookmarkSeparatorIndex
"
)
;
let
panelButtonNode
=
document
.
getElementById
(
panelButtonID
)
;
Assert
.
notEqual
(
panelButtonNode
null
"
panelButtonNode
"
)
;
Assert
.
notEqual
(
panelButtonNode
.
nextElementSibling
null
"
panelButtonNode
.
nextElementSibling
"
)
;
Assert
.
equal
(
panelButtonNode
.
nextElementSibling
.
id
BrowserPageActions
.
panelButtonNodeIDForActionID
(
PageActions
.
ACTION_ID_BOOKMARK_SEPARATOR
)
"
panelButtonNode
.
nextElementSibling
.
id
"
)
;
Assert
.
equal
(
document
.
getElementById
(
BrowserPageActions
.
panelButtonNodeIDForActionID
(
PageActions
.
ACTION_ID_BUILT_IN_SEPARATOR
)
)
null
"
Separator
should
be
gone
"
)
;
action
.
remove
(
)
;
}
)
;
add_task
(
async
function
multipleNonBuiltInOrdering
(
)
{
let
idPrefix
=
"
test
-
multipleNonBuiltInOrdering
-
"
;
let
titlePrefix
=
"
Test
multipleNonBuiltInOrdering
"
;
let
initialActions
=
PageActions
.
actionsInPanel
(
window
)
;
let
initialBuiltInActions
=
PageActions
.
_builtInActions
.
slice
(
)
;
let
initialNonBuiltInActions
=
PageActions
.
_nonBuiltInActions
.
slice
(
)
;
let
actions
=
[
2
1
4
3
]
.
map
(
index
=
>
{
return
PageActions
.
addAction
(
new
PageActions
.
Action
(
{
id
:
idPrefix
+
index
title
:
titlePrefix
+
index
}
)
)
;
}
)
;
Assert
.
equal
(
PageActions
.
actionsInPanel
(
window
)
.
length
initialActions
.
length
+
actions
.
length
+
1
"
PageActions
.
actionsInPanel
(
)
.
length
should
be
updated
"
)
;
Assert
.
equal
(
PageActions
.
_builtInActions
.
length
initialBuiltInActions
.
length
"
PageActions
.
_builtInActions
.
length
should
be
same
"
)
;
Assert
.
equal
(
PageActions
.
_nonBuiltInActions
.
length
initialNonBuiltInActions
.
length
+
actions
.
length
"
PageActions
.
_nonBuiltInActions
.
length
should
be
updated
"
)
;
for
(
let
i
=
0
;
i
<
actions
.
length
;
i
+
+
)
{
let
expectedIndex
=
i
+
1
;
let
actualAction
=
PageActions
.
_nonBuiltInActions
[
i
]
;
Assert
.
equal
(
actualAction
.
id
idPrefix
+
expectedIndex
"
actualAction
.
id
for
index
:
"
+
i
)
;
}
await
promiseOpenPageActionPanel
(
)
;
EventUtils
.
synthesizeMouseAtCenter
(
BrowserPageActions
.
mainButtonNode
{
}
)
;
await
promisePageActionPanelHidden
(
)
;
let
expectedIndex
=
1
;
let
buttonNode
=
document
.
getElementById
(
BrowserPageActions
.
panelButtonNodeIDForActionID
(
idPrefix
+
expectedIndex
)
)
;
Assert
.
notEqual
(
buttonNode
null
"
buttonNode
"
)
;
Assert
.
notEqual
(
buttonNode
.
previousElementSibling
null
"
buttonNode
.
previousElementSibling
"
)
;
Assert
.
equal
(
buttonNode
.
previousElementSibling
.
id
BrowserPageActions
.
panelButtonNodeIDForActionID
(
PageActions
.
ACTION_ID_BUILT_IN_SEPARATOR
)
"
buttonNode
.
previousElementSibling
.
id
"
)
;
for
(
let
i
=
0
;
i
<
actions
.
length
;
i
+
+
)
{
Assert
.
notEqual
(
buttonNode
null
"
buttonNode
at
index
:
"
+
i
)
;
Assert
.
equal
(
buttonNode
.
id
BrowserPageActions
.
panelButtonNodeIDForActionID
(
idPrefix
+
expectedIndex
)
"
buttonNode
.
id
at
index
:
"
+
i
)
;
buttonNode
=
buttonNode
.
nextElementSibling
;
expectedIndex
+
+
;
}
Assert
.
equal
(
buttonNode
null
"
Nothing
should
come
after
the
last
button
"
)
;
for
(
let
action
of
actions
)
{
action
.
remove
(
)
;
}
Assert
.
equal
(
document
.
getElementById
(
BrowserPageActions
.
panelButtonNodeIDForActionID
(
PageActions
.
ACTION_ID_BUILT_IN_SEPARATOR
)
)
null
"
Separator
should
be
gone
"
)
;
}
)
;
add_task
(
async
function
nonBuiltFirst
(
)
{
let
initialActions
=
PageActions
.
actions
;
let
initialActionsInPanel
=
PageActions
.
actionsInPanel
(
window
)
;
for
(
let
action
of
initialActions
)
{
action
.
remove
(
)
;
}
Assert
.
deepEqual
(
PageActions
.
actions
.
map
(
a
=
>
a
.
id
)
[
]
"
PageActions
.
actions
should
be
empty
"
)
;
Assert
.
deepEqual
(
PageActions
.
_builtInActions
.
map
(
a
=
>
a
.
id
)
[
]
"
PageActions
.
_builtInActions
should
be
empty
"
)
;
Assert
.
deepEqual
(
PageActions
.
_nonBuiltInActions
.
map
(
a
=
>
a
.
id
)
[
]
"
PageActions
.
_nonBuiltInActions
should
be
empty
"
)
;
Assert
.
equal
(
BrowserPageActions
.
mainViewBodyNode
.
children
.
length
0
"
All
nodes
should
be
gone
"
)
;
let
action
=
PageActions
.
addAction
(
new
PageActions
.
Action
(
{
id
:
"
test
-
nonBuiltFirst
"
title
:
"
Test
nonBuiltFirst
"
}
)
)
;
Assert
.
deepEqual
(
PageActions
.
actions
.
map
(
a
=
>
a
.
id
)
[
action
.
id
]
"
Action
should
be
in
PageActions
.
actions
"
)
;
Assert
.
deepEqual
(
PageActions
.
_builtInActions
.
map
(
a
=
>
a
.
id
)
[
]
"
PageActions
.
_builtInActions
should
be
empty
"
)
;
Assert
.
deepEqual
(
PageActions
.
_nonBuiltInActions
.
map
(
a
=
>
a
.
id
)
[
action
.
id
]
"
Action
should
be
in
PageActions
.
_nonBuiltInActions
"
)
;
await
promiseOpenPageActionPanel
(
)
;
EventUtils
.
synthesizeMouseAtCenter
(
BrowserPageActions
.
mainButtonNode
{
}
)
;
await
promisePageActionPanelHidden
(
)
;
Assert
.
deepEqual
(
Array
.
map
(
BrowserPageActions
.
mainViewBodyNode
.
children
n
=
>
n
.
id
)
[
BrowserPageActions
.
panelButtonNodeIDForActionID
(
action
.
id
)
]
"
Action
should
be
in
panel
"
)
;
for
(
let
a
of
initialActions
)
{
PageActions
.
addAction
(
a
)
;
}
Assert
.
deepEqual
(
new
Set
(
PageActions
.
actions
.
map
(
a
=
>
a
.
id
)
)
new
Set
(
initialActions
.
map
(
a
=
>
a
.
id
)
.
concat
(
[
action
.
id
]
)
)
"
All
actions
should
be
in
PageActions
.
actions
"
)
;
Assert
.
deepEqual
(
PageActions
.
_builtInActions
.
map
(
a
=
>
a
.
id
)
initialActions
.
filter
(
a
=
>
!
a
.
__transient
)
.
map
(
a
=
>
a
.
id
)
"
PageActions
.
_builtInActions
should
be
initial
actions
"
)
;
Assert
.
deepEqual
(
PageActions
.
_nonBuiltInActions
.
map
(
a
=
>
a
.
id
)
[
action
.
id
]
"
PageActions
.
_nonBuiltInActions
should
contain
action
"
)
;
await
promiseOpenPageActionPanel
(
)
;
EventUtils
.
synthesizeMouseAtCenter
(
BrowserPageActions
.
mainButtonNode
{
}
)
;
await
promisePageActionPanelHidden
(
)
;
Assert
.
deepEqual
(
PageActions
.
actionsInPanel
(
window
)
.
map
(
a
=
>
a
.
id
)
initialActionsInPanel
.
map
(
a
=
>
a
.
id
)
.
concat
(
[
PageActions
.
ACTION_ID_BUILT_IN_SEPARATOR
]
[
action
.
id
]
)
"
All
actions
should
be
in
PageActions
.
actionsInPanel
(
)
"
)
;
Assert
.
deepEqual
(
Array
.
map
(
BrowserPageActions
.
mainViewBodyNode
.
children
n
=
>
n
.
id
)
initialActionsInPanel
.
map
(
a
=
>
a
.
id
)
.
concat
(
[
PageActions
.
ACTION_ID_BUILT_IN_SEPARATOR
]
[
action
.
id
]
)
.
map
(
id
=
>
BrowserPageActions
.
panelButtonNodeIDForActionID
(
id
)
)
"
Panel
should
contain
all
actions
"
)
;
action
.
remove
(
)
;
Assert
.
deepEqual
(
PageActions
.
actions
.
map
(
a
=
>
a
.
id
)
initialActions
.
map
(
a
=
>
a
.
id
)
"
Action
should
no
longer
be
in
PageActions
.
actions
"
)
;
Assert
.
deepEqual
(
PageActions
.
_builtInActions
.
map
(
a
=
>
a
.
id
)
initialActions
.
filter
(
a
=
>
!
a
.
__transient
)
.
map
(
a
=
>
a
.
id
)
"
PageActions
.
_builtInActions
should
be
initial
actions
"
)
;
Assert
.
deepEqual
(
PageActions
.
_nonBuiltInActions
.
map
(
a
=
>
a
.
id
)
[
]
"
Action
should
no
longer
be
in
PageActions
.
_nonBuiltInActions
"
)
;
await
promiseOpenPageActionPanel
(
)
;
EventUtils
.
synthesizeMouseAtCenter
(
BrowserPageActions
.
mainButtonNode
{
}
)
;
await
promisePageActionPanelHidden
(
)
;
Assert
.
deepEqual
(
PageActions
.
actionsInPanel
(
window
)
.
map
(
a
=
>
a
.
id
)
initialActionsInPanel
.
map
(
a
=
>
a
.
id
)
"
Action
should
no
longer
be
in
PageActions
.
actionsInPanel
(
)
"
)
;
Assert
.
deepEqual
(
Array
.
map
(
BrowserPageActions
.
mainViewBodyNode
.
children
n
=
>
n
.
id
)
initialActionsInPanel
.
map
(
a
=
>
BrowserPageActions
.
panelButtonNodeIDForActionID
(
a
.
id
)
)
"
Action
should
no
longer
be
in
panel
"
)
;
}
)
;
add_task
(
async
function
urlbarOrderNewWindow
(
)
{
let
actions
=
[
0
1
2
]
.
map
(
i
=
>
{
return
PageActions
.
addAction
(
new
PageActions
.
Action
(
{
id
:
test
-
urlbarOrderNewWindow
-
{
i
}
title
:
Test
urlbarOrderNewWindow
{
i
}
pinnedToUrlbar
:
true
}
)
)
;
}
)
;
Assert
.
deepEqual
(
PageActions
.
_persistedActions
.
idsInUrlbar
.
slice
(
PageActions
.
_persistedActions
.
idsInUrlbar
.
length
-
(
actions
.
length
+
1
)
)
actions
.
map
(
a
=
>
a
.
id
)
.
concat
(
[
PageActions
.
ACTION_ID_BOOKMARK
]
)
"
PageActions
.
_persistedActions
.
idsInUrlbar
has
new
actions
inserted
"
)
;
Assert
.
deepEqual
(
PageActions
.
actionsInUrlbar
(
window
)
.
slice
(
PageActions
.
actionsInUrlbar
(
window
)
.
length
-
(
actions
.
length
+
1
)
)
.
map
(
a
=
>
a
.
id
)
actions
.
map
(
a
=
>
a
.
id
)
.
concat
(
[
PageActions
.
ACTION_ID_BOOKMARK
]
)
"
PageActions
.
actionsInUrlbar
has
new
actions
inserted
"
)
;
PageActions
.
_persistedActions
.
idsInUrlbar
.
splice
(
PageActions
.
_persistedActions
.
idsInUrlbar
.
length
-
(
actions
.
length
+
1
)
actions
.
length
)
;
for
(
let
i
=
0
;
i
<
actions
.
length
;
i
+
+
)
{
PageActions
.
_persistedActions
.
idsInUrlbar
.
splice
(
i
0
actions
[
i
]
.
id
)
;
}
let
ids
=
PageActions
.
_persistedActions
.
idsInUrlbar
.
slice
(
)
;
Assert
.
deepEqual
(
ids
.
slice
(
0
actions
.
length
)
actions
.
map
(
a
=
>
a
.
id
)
"
PageActions
.
_persistedActions
.
idsInUrlbar
now
has
new
actions
at
front
"
)
;
ids
=
ids
.
filter
(
id
=
>
PageActions
.
actionForID
(
id
)
)
;
let
win
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
let
actualUrlbarNodeIDs
=
[
]
;
for
(
let
node
=
win
.
BrowserPageActions
.
mainButtonNode
.
nextElementSibling
;
node
;
node
=
node
.
nextElementSibling
)
{
actualUrlbarNodeIDs
.
push
(
node
.
id
)
;
}
Assert
.
deepEqual
(
actualUrlbarNodeIDs
ids
.
map
(
id
=
>
win
.
BrowserPageActions
.
urlbarButtonNodeIDForActionID
(
id
)
)
"
Expected
actions
in
new
window
'
s
urlbar
"
)
;
await
BrowserTestUtils
.
closeWindow
(
win
)
;
for
(
let
action
of
actions
)
{
action
.
remove
(
)
;
}
}
)
;
add_task
(
async
function
migrate1
(
)
{
let
ids
=
[
PageActions
.
ACTION_ID_BOOKMARK
"
pocket
"
"
copyURL
"
]
;
let
persisted
=
ids
.
reduce
(
(
memo
id
)
=
>
{
memo
.
ids
[
id
]
=
true
;
memo
.
idsInUrlbar
.
push
(
id
)
;
return
memo
;
}
{
ids
:
{
}
idsInUrlbar
:
[
]
}
)
;
Services
.
prefs
.
setStringPref
(
PageActions
.
PREF_PERSISTED_ACTIONS
JSON
.
stringify
(
persisted
)
)
;
PageActions
.
_loadPersistedActions
(
)
;
Assert
.
equal
(
PageActions
.
_persistedActions
.
version
1
"
Correct
version
"
)
;
PageActions
.
actionForID
(
"
copyURL
"
)
.
_pinnedToUrlbar
=
true
;
let
orderedIDs
=
[
"
pocket
"
"
copyURL
"
PageActions
.
ACTION_ID_BOOKMARK
]
;
Assert
.
deepEqual
(
PageActions
.
_persistedActions
.
idsInUrlbar
orderedIDs
"
PageActions
.
_persistedActions
.
idsInUrlbar
has
right
order
"
)
;
Assert
.
deepEqual
(
PageActions
.
actionsInUrlbar
(
window
)
.
map
(
a
=
>
a
.
id
)
orderedIDs
"
PageActions
.
actionsInUrlbar
has
right
order
"
)
;
let
win
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
await
BrowserTestUtils
.
openNewForegroundTab
(
{
gBrowser
:
win
.
gBrowser
url
:
"
http
:
/
/
example
.
com
/
"
}
)
;
let
actualUrlbarNodeIDs
=
[
]
;
for
(
let
node
=
win
.
BrowserPageActions
.
mainButtonNode
.
nextElementSibling
;
node
;
node
=
node
.
nextElementSibling
)
{
actualUrlbarNodeIDs
.
push
(
node
.
id
)
;
}
Assert
.
deepEqual
(
actualUrlbarNodeIDs
orderedIDs
.
map
(
id
=
>
win
.
BrowserPageActions
.
urlbarButtonNodeIDForActionID
(
id
)
)
"
Expected
actions
in
new
window
'
s
urlbar
"
)
;
await
BrowserTestUtils
.
closeWindow
(
win
)
;
Services
.
prefs
.
clearUserPref
(
PageActions
.
PREF_PERSISTED_ACTIONS
)
;
PageActions
.
actionForID
(
"
copyURL
"
)
.
pinnedToUrlbar
=
false
;
}
)
;
add_task
(
async
function
perWindowState
(
)
{
let
title
=
"
Test
perWindowState
"
;
let
action
=
PageActions
.
addAction
(
new
PageActions
.
Action
(
{
iconURL
:
"
chrome
:
/
/
browser
/
skin
/
mail
.
svg
"
id
:
"
test
-
perWindowState
"
pinnedToUrlbar
:
true
title
}
)
)
;
let
actionsInUrlbar
=
PageActions
.
actionsInUrlbar
(
window
)
;
let
newWindow
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
await
BrowserTestUtils
.
openNewForegroundTab
(
{
gBrowser
:
newWindow
.
gBrowser
url
:
"
http
:
/
/
example
.
com
/
"
}
)
;
let
newGlobalTitle
=
title
+
"
new
title
"
;
action
.
setTitle
(
newGlobalTitle
)
;
Assert
.
equal
(
action
.
getTitle
(
)
newGlobalTitle
"
Title
:
global
"
)
;
Assert
.
equal
(
action
.
getTitle
(
window
)
newGlobalTitle
"
Title
:
old
window
"
)
;
Assert
.
equal
(
action
.
getTitle
(
newWindow
)
newGlobalTitle
"
Title
:
new
window
"
)
;
let
panelButtonID
=
BrowserPageActions
.
panelButtonNodeIDForActionID
(
action
.
id
)
;
for
(
let
win
of
[
window
newWindow
]
)
{
win
.
BrowserPageActions
.
placeLazyActionsInPanel
(
)
;
let
panelButtonNode
=
win
.
document
.
getElementById
(
panelButtonID
)
;
Assert
.
equal
(
panelButtonNode
.
getAttribute
(
"
label
"
)
newGlobalTitle
"
Panel
button
label
should
be
global
title
"
)
;
}
let
newPerWinTitle
=
title
+
"
new
title
in
new
window
"
;
action
.
setTitle
(
newPerWinTitle
newWindow
)
;
Assert
.
equal
(
action
.
getTitle
(
)
newGlobalTitle
"
Title
:
global
should
remain
same
"
)
;
Assert
.
equal
(
action
.
getTitle
(
window
)
newGlobalTitle
"
Title
:
old
window
should
remain
same
"
)
;
Assert
.
equal
(
action
.
getTitle
(
newWindow
)
newPerWinTitle
"
Title
:
new
window
should
be
new
"
)
;
let
panelButtonNode1
=
document
.
getElementById
(
panelButtonID
)
;
Assert
.
equal
(
panelButtonNode1
.
getAttribute
(
"
label
"
)
newGlobalTitle
"
Panel
button
label
in
old
window
"
)
;
let
panelButtonNode2
=
newWindow
.
document
.
getElementById
(
panelButtonID
)
;
Assert
.
equal
(
panelButtonNode2
.
getAttribute
(
"
label
"
)
newPerWinTitle
"
Panel
button
label
in
new
window
"
)
;
action
.
setDisabled
(
true
newWindow
)
;
Assert
.
equal
(
action
.
getDisabled
(
)
false
"
Disabled
:
global
should
remain
false
"
)
;
Assert
.
equal
(
action
.
getDisabled
(
window
)
false
"
Disabled
:
old
window
should
remain
false
"
)
;
Assert
.
equal
(
action
.
getDisabled
(
newWindow
)
true
"
Disabled
:
new
window
should
be
true
"
)
;
Assert
.
deepEqual
(
PageActions
.
actionsInUrlbar
(
window
)
.
map
(
a
=
>
a
.
id
)
actionsInUrlbar
.
map
(
a
=
>
a
.
id
)
"
PageActions
.
actionsInUrlbar
:
old
window
should
have
all
actions
in
urlbar
"
)
;
Assert
.
deepEqual
(
PageActions
.
actionsInUrlbar
(
newWindow
)
.
map
(
a
=
>
a
.
id
)
actionsInUrlbar
.
map
(
a
=
>
a
.
id
)
.
filter
(
id
=
>
id
!
=
action
.
id
)
"
PageActions
.
actionsInUrlbar
:
new
window
should
have
all
actions
in
urlbar
except
the
test
action
"
)
;
let
actualUrlbarNodeIDs
=
[
]
;
for
(
let
node
=
BrowserPageActions
.
mainButtonNode
.
nextElementSibling
;
node
;
node
=
node
.
nextElementSibling
)
{
actualUrlbarNodeIDs
.
push
(
node
.
id
)
;
}
Assert
.
deepEqual
(
actualUrlbarNodeIDs
actionsInUrlbar
.
map
(
a
=
>
BrowserPageActions
.
urlbarButtonNodeIDForActionID
(
a
.
id
)
)
"
Old
window
should
have
all
nodes
in
urlbar
"
)
;
actualUrlbarNodeIDs
=
[
]
;
for
(
let
node
=
newWindow
.
BrowserPageActions
.
mainButtonNode
.
nextElementSibling
;
node
;
node
=
node
.
nextElementSibling
)
{
actualUrlbarNodeIDs
.
push
(
node
.
id
)
;
}
Assert
.
deepEqual
(
actualUrlbarNodeIDs
actionsInUrlbar
.
filter
(
a
=
>
a
.
id
!
=
action
.
id
)
.
map
(
a
=
>
BrowserPageActions
.
urlbarButtonNodeIDForActionID
(
a
.
id
)
)
"
New
window
should
have
all
nodes
in
urlbar
except
for
the
test
action
'
s
"
)
;
await
BrowserTestUtils
.
closeWindow
(
newWindow
)
;
action
.
remove
(
)
;
}
)
;
add_task
(
async
function
removeRetainState
(
)
{
let
initialActionsInUrlbar
=
PageActions
.
actionsInUrlbar
(
window
)
;
Assert
.
ok
(
initialActionsInUrlbar
.
length
>
0
"
This
test
expects
there
to
be
at
least
one
action
in
the
urlbar
initially
(
like
the
bookmark
star
)
"
)
;
let
id
=
"
test
-
removeRetainState
"
;
let
testAction
=
PageActions
.
addAction
(
new
PageActions
.
Action
(
{
id
title
:
"
Test
removeRetainState
"
}
)
)
;
testAction
.
pinnedToUrlbar
=
true
;
for
(
let
action
of
initialActionsInUrlbar
)
{
action
.
pinnedToUrlbar
=
false
;
action
.
pinnedToUrlbar
=
true
;
}
Assert
.
deepEqual
(
PageActions
.
actionsInUrlbar
(
window
)
.
map
(
a
=
>
a
.
id
)
[
testAction
]
.
concat
(
initialActionsInUrlbar
)
.
map
(
a
=
>
a
.
id
)
"
PageActions
.
actionsInUrlbar
should
be
in
expected
order
:
testAction
followed
by
all
initial
actions
"
)
;
let
actualUrlbarNodeIDs
=
[
]
;
for
(
let
node
=
BrowserPageActions
.
mainButtonNode
.
nextElementSibling
;
node
;
node
=
node
.
nextElementSibling
)
{
actualUrlbarNodeIDs
.
push
(
node
.
id
)
;
}
Assert
.
deepEqual
(
actualUrlbarNodeIDs
[
testAction
]
.
concat
(
initialActionsInUrlbar
)
.
map
(
a
=
>
BrowserPageActions
.
urlbarButtonNodeIDForActionID
(
a
.
id
)
)
"
urlbar
nodes
should
be
in
expected
order
:
testAction
followed
by
all
initial
actions
"
)
;
testAction
.
remove
(
)
;
Assert
.
deepEqual
(
PageActions
.
actionsInUrlbar
(
window
)
.
map
(
a
=
>
a
.
id
)
initialActionsInUrlbar
.
map
(
a
=
>
a
.
id
)
"
PageActions
.
actionsInUrlbar
should
be
in
expected
order
after
removing
test
action
:
all
initial
actions
"
)
;
actualUrlbarNodeIDs
=
[
]
;
for
(
let
node
=
BrowserPageActions
.
mainButtonNode
.
nextElementSibling
;
node
;
node
=
node
.
nextElementSibling
)
{
actualUrlbarNodeIDs
.
push
(
node
.
id
)
;
}
Assert
.
deepEqual
(
actualUrlbarNodeIDs
initialActionsInUrlbar
.
map
(
a
=
>
BrowserPageActions
.
urlbarButtonNodeIDForActionID
(
a
.
id
)
)
"
urlbar
nodes
should
be
in
expected
order
after
removing
test
action
:
all
initial
actions
"
)
;
testAction
=
PageActions
.
addAction
(
new
PageActions
.
Action
(
{
id
title
:
"
Test
removeRetainState
"
}
)
)
;
testAction
.
pinnedToUrlbar
=
true
;
Assert
.
deepEqual
(
PageActions
.
actionsInUrlbar
(
window
)
.
map
(
a
=
>
a
.
id
)
[
testAction
]
.
concat
(
initialActionsInUrlbar
)
.
map
(
a
=
>
a
.
id
)
"
PageActions
.
actionsInUrlbar
should
be
in
expected
order
after
re
-
adding
test
action
:
testAction
followed
by
all
initial
actions
"
)
;
actualUrlbarNodeIDs
=
[
]
;
for
(
let
node
=
BrowserPageActions
.
mainButtonNode
.
nextElementSibling
;
node
;
node
=
node
.
nextElementSibling
)
{
actualUrlbarNodeIDs
.
push
(
node
.
id
)
;
}
Assert
.
deepEqual
(
actualUrlbarNodeIDs
[
testAction
]
.
concat
(
initialActionsInUrlbar
)
.
map
(
a
=
>
BrowserPageActions
.
urlbarButtonNodeIDForActionID
(
a
.
id
)
)
"
urlbar
nodes
should
be
in
expected
order
after
re
-
adding
test
action
:
testAction
followed
by
all
initial
actions
"
)
;
testAction
.
remove
(
)
;
}
)
;
add_task
(
async
function
contextMenu
(
)
{
Services
.
telemetry
.
clearEvents
(
)
;
let
action
=
PageActions
.
addAction
(
new
PageActions
.
Action
(
{
id
:
"
test
-
contextMenu
"
title
:
"
Test
contextMenu
"
pinnedToUrlbar
:
true
}
)
)
;
await
promiseOpenPageActionPanel
(
)
;
let
panelButton
=
BrowserPageActions
.
panelButtonNodeForActionID
(
action
.
id
)
;
let
contextMenuPromise
=
promisePanelShown
(
"
pageActionContextMenu
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
panelButton
{
type
:
"
contextmenu
"
button
:
2
}
)
;
await
contextMenuPromise
;
let
menuItems
=
collectContextMenuItems
(
)
;
Assert
.
equal
(
menuItems
.
length
3
"
Context
menu
has
3
children
"
)
;
Assert
.
equal
(
menuItems
[
0
]
.
label
"
Remove
from
Address
Bar
"
"
Context
menu
is
in
the
'
remove
'
state
"
)
;
Assert
.
equal
(
menuItems
[
1
]
.
localName
"
menuseparator
"
"
menuseparator
is
present
"
)
;
Assert
.
equal
(
menuItems
[
2
]
.
label
"
Manage
Extension
\
u2026
"
"
'
Manage
'
item
is
present
"
)
;
contextMenuPromise
=
promisePanelHidden
(
"
pageActionContextMenu
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
menuItems
[
0
]
{
}
)
;
await
contextMenuPromise
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
{
return
!
BrowserPageActions
.
urlbarButtonNodeForActionID
(
action
.
id
)
;
}
"
Waiting
for
urlbar
button
to
be
removed
"
)
;
contextMenuPromise
=
promisePanelShown
(
"
pageActionContextMenu
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
panelButton
{
type
:
"
contextmenu
"
button
:
2
}
)
;
await
contextMenuPromise
;
menuItems
=
collectContextMenuItems
(
)
;
Assert
.
equal
(
menuItems
.
length
3
"
Context
menu
has
3
children
"
)
;
Assert
.
equal
(
menuItems
[
0
]
.
label
"
Add
to
Address
Bar
"
"
Context
menu
is
in
the
'
add
'
state
"
)
;
Assert
.
equal
(
menuItems
[
1
]
.
localName
"
menuseparator
"
"
menuseparator
is
present
"
)
;
Assert
.
equal
(
menuItems
[
2
]
.
label
"
Manage
Extension
\
u2026
"
"
'
Manage
'
item
is
present
"
)
;
contextMenuPromise
=
promisePanelHidden
(
"
pageActionContextMenu
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
menuItems
[
0
]
{
}
)
;
await
contextMenuPromise
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
{
return
BrowserPageActions
.
urlbarButtonNodeForActionID
(
action
.
id
)
;
}
"
Waiting
for
urlbar
button
to
be
added
back
"
)
;
contextMenuPromise
=
promisePanelShown
(
"
pageActionContextMenu
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
panelButton
{
type
:
"
contextmenu
"
button
:
2
}
)
;
await
contextMenuPromise
;
menuItems
=
collectContextMenuItems
(
)
;
Assert
.
equal
(
menuItems
.
length
3
"
Context
menu
has
3
children
"
)
;
Assert
.
equal
(
menuItems
[
0
]
.
label
"
Remove
from
Address
Bar
"
"
Context
menu
is
in
the
'
remove
'
state
"
)
;
Assert
.
equal
(
menuItems
[
1
]
.
localName
"
menuseparator
"
"
menuseparator
is
present
"
)
;
Assert
.
equal
(
menuItems
[
2
]
.
label
"
Manage
Extension
\
u2026
"
"
'
Manage
'
item
is
present
"
)
;
contextMenuPromise
=
promisePanelHidden
(
"
pageActionContextMenu
"
)
;
let
aboutAddonsPromise
=
BrowserTestUtils
.
waitForNewTab
(
gBrowser
"
about
:
addons
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
menuItems
[
2
]
{
}
)
;
let
values
=
await
Promise
.
all
(
[
aboutAddonsPromise
contextMenuPromise
]
)
;
let
aboutAddonsTab
=
values
[
0
]
;
BrowserTestUtils
.
removeTab
(
aboutAddonsTab
)
;
let
urlbarButton
=
BrowserPageActions
.
urlbarButtonNodeForActionID
(
action
.
id
)
;
contextMenuPromise
=
promisePanelShown
(
"
pageActionContextMenu
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
urlbarButton
{
type
:
"
contextmenu
"
button
:
2
}
)
;
await
contextMenuPromise
;
menuItems
=
collectContextMenuItems
(
)
;
Assert
.
equal
(
menuItems
.
length
3
"
Context
menu
has
3
children
"
)
;
Assert
.
equal
(
menuItems
[
0
]
.
label
"
Remove
from
Address
Bar
"
"
Context
menu
is
in
the
'
remove
'
state
"
)
;
Assert
.
equal
(
menuItems
[
1
]
.
localName
"
menuseparator
"
"
menuseparator
is
present
"
)
;
Assert
.
equal
(
menuItems
[
2
]
.
label
"
Manage
Extension
\
u2026
"
"
'
Manage
'
item
is
present
"
)
;
contextMenuPromise
=
promisePanelHidden
(
"
pageActionContextMenu
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
menuItems
[
0
]
{
}
)
;
await
contextMenuPromise
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
{
return
!
BrowserPageActions
.
urlbarButtonNodeForActionID
(
action
.
id
)
;
}
"
Waiting
for
urlbar
button
to
be
removed
"
)
;
await
promiseOpenPageActionPanel
(
)
;
contextMenuPromise
=
promisePanelShown
(
"
pageActionContextMenu
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
panelButton
{
type
:
"
contextmenu
"
button
:
2
}
)
;
await
contextMenuPromise
;
menuItems
=
collectContextMenuItems
(
)
;
Assert
.
equal
(
menuItems
.
length
3
"
Context
menu
has
3
children
"
)
;
Assert
.
equal
(
menuItems
[
0
]
.
label
"
Add
to
Address
Bar
"
"
Context
menu
is
in
the
'
add
'
state
"
)
;
Assert
.
equal
(
menuItems
[
1
]
.
localName
"
menuseparator
"
"
menuseparator
is
present
"
)
;
Assert
.
equal
(
menuItems
[
2
]
.
label
"
Manage
Extension
\
u2026
"
"
'
Manage
'
item
is
present
"
)
;
contextMenuPromise
=
promisePanelHidden
(
"
pageActionContextMenu
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
menuItems
[
0
]
{
}
)
;
await
contextMenuPromise
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
{
return
BrowserPageActions
.
urlbarButtonNodeForActionID
(
action
.
id
)
;
}
"
Waiting
for
urlbar
button
to
be
added
back
"
)
;
urlbarButton
=
BrowserPageActions
.
urlbarButtonNodeForActionID
(
action
.
id
)
;
contextMenuPromise
=
promisePanelShown
(
"
pageActionContextMenu
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
urlbarButton
{
type
:
"
contextmenu
"
button
:
2
}
)
;
await
contextMenuPromise
;
menuItems
=
collectContextMenuItems
(
)
;
Assert
.
equal
(
menuItems
.
length
3
"
Context
menu
has
3
children
"
)
;
Assert
.
equal
(
menuItems
[
0
]
.
label
"
Remove
from
Address
Bar
"
"
Context
menu
is
in
the
'
remove
'
state
"
)
;
Assert
.
equal
(
menuItems
[
1
]
.
localName
"
menuseparator
"
"
menuseparator
is
present
"
)
;
Assert
.
equal
(
menuItems
[
2
]
.
label
"
Manage
Extension
\
u2026
"
"
'
Manage
'
item
is
present
"
)
;
contextMenuPromise
=
promisePanelHidden
(
"
pageActionContextMenu
"
)
;
aboutAddonsPromise
=
BrowserTestUtils
.
waitForNewTab
(
gBrowser
"
about
:
addons
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
menuItems
[
2
]
{
}
)
;
values
=
await
Promise
.
all
(
[
aboutAddonsPromise
contextMenuPromise
]
)
;
aboutAddonsTab
=
values
[
0
]
;
BrowserTestUtils
.
removeTab
(
aboutAddonsTab
)
;
action
.
remove
(
)
;
let
snapshot
=
Services
.
telemetry
.
snapshotEvents
(
Ci
.
nsITelemetry
.
DATASET_RELEASE_CHANNEL_OPTIN
true
)
;
ok
(
snapshot
.
parent
&
&
snapshot
.
parent
.
length
>
0
"
Got
parent
telemetry
events
in
the
snapshot
"
)
;
let
relatedEvents
=
snapshot
.
parent
.
filter
(
(
[
timestamp
category
method
]
)
=
>
category
=
=
"
addonsManager
"
&
&
method
=
=
"
action
"
)
.
map
(
relatedEvent
=
>
relatedEvent
.
slice
(
3
6
)
)
;
Assert
.
deepEqual
(
relatedEvents
[
[
"
pageAction
"
null
{
action
:
"
manage
"
}
]
[
"
pageAction
"
null
{
action
:
"
manage
"
}
]
]
)
;
EventUtils
.
synthesizeMouseAtCenter
(
gURLBar
.
inputField
{
type
:
"
mousemove
"
}
)
;
gURLBar
.
focus
(
)
;
}
)
;
add_task
(
async
function
transient
(
)
{
let
initialActionsInPanel
=
PageActions
.
actionsInPanel
(
window
)
;
let
onPlacedInPanelCount
=
0
;
let
onBeforePlacedInWindowCount
=
0
;
let
action
=
PageActions
.
addAction
(
new
PageActions
.
Action
(
{
id
:
"
test
-
transient
"
title
:
"
Test
transient
"
_transient
:
true
onPlacedInPanel
(
buttonNode
)
{
onPlacedInPanelCount
+
+
;
}
onBeforePlacedInWindow
(
win
)
{
onBeforePlacedInWindowCount
+
+
;
}
}
)
)
;
Assert
.
equal
(
action
.
__transient
true
"
__transient
"
)
;
Assert
.
equal
(
onPlacedInPanelCount
0
"
onPlacedInPanelCount
should
remain
0
"
)
;
Assert
.
equal
(
onBeforePlacedInWindowCount
0
"
onBeforePlacedInWindowCount
should
remain
0
"
)
;
Assert
.
deepEqual
(
PageActions
.
actionsInPanel
(
window
)
.
map
(
a
=
>
a
.
id
)
initialActionsInPanel
.
map
(
a
=
>
a
.
id
)
.
concat
(
[
PageActions
.
ACTION_ID_TRANSIENT_SEPARATOR
action
.
id
]
)
"
PageActions
.
actionsInPanel
(
)
should
be
updated
"
)
;
await
promiseOpenPageActionPanel
(
)
;
EventUtils
.
synthesizeMouseAtCenter
(
BrowserPageActions
.
mainButtonNode
{
}
)
;
await
promisePageActionPanelHidden
(
)
;
Assert
.
deepEqual
(
Array
.
map
(
BrowserPageActions
.
mainViewBodyNode
.
children
n
=
>
n
.
id
)
initialActionsInPanel
.
map
(
a
=
>
a
.
id
)
.
concat
(
[
PageActions
.
ACTION_ID_TRANSIENT_SEPARATOR
action
.
id
]
)
.
map
(
id
=
>
BrowserPageActions
.
panelButtonNodeIDForActionID
(
id
)
)
"
Actions
in
panel
should
be
correct
"
)
;
Assert
.
equal
(
onPlacedInPanelCount
1
"
onPlacedInPanelCount
should
be
inc
'
ed
"
)
;
Assert
.
equal
(
onBeforePlacedInWindowCount
1
"
onBeforePlacedInWindowCount
should
be
inc
'
ed
"
)
;
action
.
setDisabled
(
true
window
)
;
Assert
.
deepEqual
(
PageActions
.
actionsInPanel
(
window
)
.
map
(
a
=
>
a
.
id
)
initialActionsInPanel
.
map
(
a
=
>
a
.
id
)
"
PageActions
.
actionsInPanel
(
)
should
revert
to
initial
"
)
;
await
promiseOpenPageActionPanel
(
)
;
EventUtils
.
synthesizeMouseAtCenter
(
BrowserPageActions
.
mainButtonNode
{
}
)
;
await
promisePageActionPanelHidden
(
)
;
Assert
.
deepEqual
(
Array
.
map
(
BrowserPageActions
.
mainViewBodyNode
.
children
n
=
>
n
.
id
)
initialActionsInPanel
.
map
(
a
=
>
BrowserPageActions
.
panelButtonNodeIDForActionID
(
a
.
id
)
)
"
Actions
in
panel
should
be
correct
"
)
;
action
.
setDisabled
(
false
window
)
;
Assert
.
deepEqual
(
PageActions
.
actionsInPanel
(
window
)
.
map
(
a
=
>
a
.
id
)
initialActionsInPanel
.
map
(
a
=
>
a
.
id
)
.
concat
(
[
PageActions
.
ACTION_ID_TRANSIENT_SEPARATOR
action
.
id
]
)
"
PageActions
.
actionsInPanel
(
)
should
be
updated
"
)
;
await
promiseOpenPageActionPanel
(
)
;
EventUtils
.
synthesizeMouseAtCenter
(
BrowserPageActions
.
mainButtonNode
{
}
)
;
await
promisePageActionPanelHidden
(
)
;
Assert
.
deepEqual
(
Array
.
map
(
BrowserPageActions
.
mainViewBodyNode
.
children
n
=
>
n
.
id
)
initialActionsInPanel
.
map
(
a
=
>
a
.
id
)
.
concat
(
[
PageActions
.
ACTION_ID_TRANSIENT_SEPARATOR
action
.
id
]
)
.
map
(
id
=
>
BrowserPageActions
.
panelButtonNodeIDForActionID
(
id
)
)
"
Actions
in
panel
should
be
correct
"
)
;
Assert
.
equal
(
onPlacedInPanelCount
2
"
onPlacedInPanelCount
should
be
inc
'
ed
"
)
;
Assert
.
equal
(
onBeforePlacedInWindowCount
2
"
onBeforePlacedInWindowCount
should
be
inc
'
ed
"
)
;
let
otherAction
=
PageActions
.
addAction
(
new
PageActions
.
Action
(
{
id
:
"
test
-
transient2
"
title
:
"
Test
transient
2
"
}
)
)
;
Assert
.
deepEqual
(
PageActions
.
actionsInPanel
(
window
)
.
map
(
a
=
>
a
.
id
)
initialActionsInPanel
.
map
(
a
=
>
a
.
id
)
.
concat
(
[
PageActions
.
ACTION_ID_BUILT_IN_SEPARATOR
otherAction
.
id
PageActions
.
ACTION_ID_TRANSIENT_SEPARATOR
action
.
id
]
)
"
PageActions
.
actionsInPanel
(
)
should
be
updated
"
)
;
await
promiseOpenPageActionPanel
(
)
;
EventUtils
.
synthesizeMouseAtCenter
(
BrowserPageActions
.
mainButtonNode
{
}
)
;
await
promisePageActionPanelHidden
(
)
;
Assert
.
deepEqual
(
Array
.
map
(
BrowserPageActions
.
mainViewBodyNode
.
children
n
=
>
n
.
id
)
initialActionsInPanel
.
map
(
a
=
>
a
.
id
)
.
concat
(
[
PageActions
.
ACTION_ID_BUILT_IN_SEPARATOR
otherAction
.
id
PageActions
.
ACTION_ID_TRANSIENT_SEPARATOR
action
.
id
]
)
.
map
(
id
=
>
BrowserPageActions
.
panelButtonNodeIDForActionID
(
id
)
)
"
Actions
in
panel
should
be
correct
"
)
;
Assert
.
equal
(
onPlacedInPanelCount
2
"
onPlacedInPanelCount
should
remain
the
same
"
)
;
Assert
.
equal
(
onBeforePlacedInWindowCount
2
"
onBeforePlacedInWindowCount
should
remain
the
same
"
)
;
action
.
setDisabled
(
true
window
)
;
Assert
.
deepEqual
(
PageActions
.
actionsInPanel
(
window
)
.
map
(
a
=
>
a
.
id
)
initialActionsInPanel
.
map
(
a
=
>
a
.
id
)
.
concat
(
[
PageActions
.
ACTION_ID_BUILT_IN_SEPARATOR
otherAction
.
id
]
)
"
PageActions
.
actionsInPanel
(
)
should
be
updated
"
)
;
await
promiseOpenPageActionPanel
(
)
;
EventUtils
.
synthesizeMouseAtCenter
(
BrowserPageActions
.
mainButtonNode
{
}
)
;
await
promisePageActionPanelHidden
(
)
;
Assert
.
deepEqual
(
Array
.
map
(
BrowserPageActions
.
mainViewBodyNode
.
children
n
=
>
n
.
id
)
initialActionsInPanel
.
map
(
a
=
>
a
.
id
)
.
concat
(
[
PageActions
.
ACTION_ID_BUILT_IN_SEPARATOR
otherAction
.
id
]
)
.
map
(
id
=
>
BrowserPageActions
.
panelButtonNodeIDForActionID
(
id
)
)
"
Actions
in
panel
should
be
correct
"
)
;
action
.
setDisabled
(
false
window
)
;
Assert
.
deepEqual
(
PageActions
.
actionsInPanel
(
window
)
.
map
(
a
=
>
a
.
id
)
initialActionsInPanel
.
map
(
a
=
>
a
.
id
)
.
concat
(
[
PageActions
.
ACTION_ID_BUILT_IN_SEPARATOR
otherAction
.
id
PageActions
.
ACTION_ID_TRANSIENT_SEPARATOR
action
.
id
]
)
"
PageActions
.
actionsInPanel
(
)
should
be
updated
"
)
;
await
promiseOpenPageActionPanel
(
)
;
EventUtils
.
synthesizeMouseAtCenter
(
BrowserPageActions
.
mainButtonNode
{
}
)
;
await
promisePageActionPanelHidden
(
)
;
Assert
.
deepEqual
(
Array
.
map
(
BrowserPageActions
.
mainViewBodyNode
.
children
n
=
>
n
.
id
)
initialActionsInPanel
.
map
(
a
=
>
a
.
id
)
.
concat
(
[
PageActions
.
ACTION_ID_BUILT_IN_SEPARATOR
otherAction
.
id
PageActions
.
ACTION_ID_TRANSIENT_SEPARATOR
action
.
id
]
)
.
map
(
id
=
>
BrowserPageActions
.
panelButtonNodeIDForActionID
(
id
)
)
"
Actions
in
panel
should
be
correct
"
)
;
Assert
.
equal
(
onPlacedInPanelCount
3
"
onPlacedInPanelCount
should
be
inc
'
ed
"
)
;
Assert
.
equal
(
onBeforePlacedInWindowCount
3
"
onBeforePlacedInWindowCount
should
be
inc
'
ed
"
)
;
action
.
remove
(
)
;
otherAction
.
remove
(
)
;
}
)
;
add_task
(
async
function
action_disablePrivateBrowsing
(
)
{
let
id
=
"
testWidget
"
;
let
action
=
PageActions
.
addAction
(
new
PageActions
.
Action
(
{
id
disablePrivateBrowsing
:
true
title
:
"
title
"
disabled
:
false
pinnedToUrlbar
:
true
}
)
)
;
let
url
=
"
http
:
/
/
example
.
com
/
"
;
let
privateWindow
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
{
private
:
true
}
)
;
await
BrowserTestUtils
.
openNewForegroundTab
(
privateWindow
.
gBrowser
url
true
true
)
;
Assert
.
ok
(
action
.
canShowInWindow
(
window
)
"
should
show
in
default
window
"
)
;
Assert
.
ok
(
!
action
.
canShowInWindow
(
privateWindow
)
"
should
not
show
in
private
browser
"
)
;
Assert
.
ok
(
action
.
shouldShowInUrlbar
(
window
)
"
should
show
in
default
urlbar
"
)
;
Assert
.
ok
(
!
action
.
shouldShowInUrlbar
(
privateWindow
)
"
should
not
show
in
default
urlbar
"
)
;
Assert
.
ok
(
action
.
shouldShowInPanel
(
window
)
"
should
show
in
default
urlbar
"
)
;
Assert
.
ok
(
!
action
.
shouldShowInPanel
(
privateWindow
)
"
should
not
show
in
default
urlbar
"
)
;
action
.
remove
(
)
;
privateWindow
.
close
(
)
;
}
)
;
function
assertActivatedPageActionPanelHidden
(
)
{
Assert
.
ok
(
!
document
.
getElementById
(
BrowserPageActions
.
_activatedActionPanelID
)
)
;
}
function
promiseOpenPageActionPanel
(
)
{
let
dwu
=
window
.
windowUtils
;
return
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
{
info
(
"
Waiting
for
main
page
action
button
to
have
non
-
0
size
"
)
;
let
bounds
=
dwu
.
getBoundsWithoutFlushing
(
BrowserPageActions
.
mainButtonNode
)
;
return
bounds
.
width
>
0
&
&
bounds
.
height
>
0
;
}
)
.
then
(
(
)
=
>
{
info
(
"
Waiting
for
main
page
action
panel
to
be
open
"
)
;
if
(
BrowserPageActions
.
panelNode
.
state
=
=
"
open
"
)
{
return
Promise
.
resolve
(
)
;
}
let
shownPromise
=
promisePageActionPanelShown
(
)
;
EventUtils
.
synthesizeMouseAtCenter
(
BrowserPageActions
.
mainButtonNode
{
}
)
;
return
shownPromise
;
}
)
.
then
(
(
)
=
>
{
return
promisePageActionViewChildrenVisible
(
BrowserPageActions
.
mainViewNode
)
;
}
)
;
}
function
promisePageActionPanelShown
(
)
{
return
promisePanelShown
(
BrowserPageActions
.
panelNode
)
;
}
function
promisePageActionPanelHidden
(
)
{
return
promisePanelHidden
(
BrowserPageActions
.
panelNode
)
;
}
function
promisePanelShown
(
panelIDOrNode
)
{
return
promisePanelEvent
(
panelIDOrNode
"
popupshown
"
)
;
}
function
promisePanelHidden
(
panelIDOrNode
)
{
return
promisePanelEvent
(
panelIDOrNode
"
popuphidden
"
)
;
}
function
promisePanelEvent
(
panelIDOrNode
eventType
)
{
return
new
Promise
(
resolve
=
>
{
let
panel
=
panelIDOrNode
;
if
(
typeof
panel
=
=
"
string
"
)
{
panel
=
document
.
getElementById
(
panelIDOrNode
)
;
if
(
!
panel
)
{
throw
new
Error
(
Panel
with
ID
"
{
panelIDOrNode
}
"
does
not
exist
.
)
;
}
}
if
(
(
eventType
=
=
"
popupshown
"
&
&
panel
.
state
=
=
"
open
"
)
|
|
(
eventType
=
=
"
popuphidden
"
&
&
panel
.
state
=
=
"
closed
"
)
)
{
executeSoon
(
resolve
)
;
return
;
}
panel
.
addEventListener
(
eventType
(
)
=
>
{
executeSoon
(
resolve
)
;
}
{
once
:
true
}
)
;
}
)
;
}
function
promisePageActionViewShown
(
)
{
info
(
"
promisePageActionViewShown
waiting
for
ViewShown
"
)
;
return
BrowserTestUtils
.
waitForEvent
(
BrowserPageActions
.
panelNode
"
ViewShown
"
)
.
then
(
async
event
=
>
{
let
panelViewNode
=
event
.
originalTarget
;
await
promisePageActionViewChildrenVisible
(
panelViewNode
)
;
return
panelViewNode
;
}
)
;
}
function
promisePageActionViewChildrenVisible
(
panelViewNode
)
{
info
(
"
promisePageActionViewChildrenVisible
waiting
for
a
child
node
to
be
visible
"
)
;
let
dwu
=
window
.
windowUtils
;
return
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
{
let
bodyNode
=
panelViewNode
.
firstElementChild
;
for
(
let
childNode
of
bodyNode
.
children
)
{
let
bounds
=
dwu
.
getBoundsWithoutFlushing
(
childNode
)
;
if
(
bounds
.
width
>
0
&
&
bounds
.
height
>
0
)
{
return
true
;
}
}
return
false
;
}
)
;
}
function
collectContextMenuItems
(
)
{
let
contextMenu
=
document
.
getElementById
(
"
pageActionContextMenu
"
)
;
return
Array
.
filter
(
contextMenu
.
children
node
=
>
{
return
window
.
getComputedStyle
(
node
)
.
visibility
=
=
"
visible
"
;
}
)
;
}
