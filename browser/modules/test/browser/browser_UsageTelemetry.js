"
use
strict
"
;
const
MAX_CONCURRENT_TABS
=
"
browser
.
engagement
.
max_concurrent_tab_count
"
;
const
TAB_EVENT_COUNT
=
"
browser
.
engagement
.
tab_open_event_count
"
;
const
MAX_CONCURRENT_WINDOWS
=
"
browser
.
engagement
.
max_concurrent_window_count
"
;
const
MAX_TAB_PINNED
=
"
browser
.
engagement
.
max_concurrent_tab_pinned_count
"
;
const
TAB_PINNED_EVENT
=
"
browser
.
engagement
.
tab_pinned_event_count
"
;
const
WINDOW_OPEN_COUNT
=
"
browser
.
engagement
.
window_open_event_count
"
;
const
TOTAL_URI_COUNT
=
"
browser
.
engagement
.
total_uri_count
"
;
const
UNIQUE_DOMAINS_COUNT
=
"
browser
.
engagement
.
unique_domains_count
"
;
const
UNFILTERED_URI_COUNT
=
"
browser
.
engagement
.
unfiltered_uri_count
"
;
const
TELEMETRY_SUBSESSION_TOPIC
=
"
internal
-
telemetry
-
after
-
subsession
-
split
"
;
ChromeUtils
.
defineModuleGetter
(
this
"
MINIMUM_TAB_COUNT_INTERVAL_MS
"
"
resource
:
/
/
/
modules
/
BrowserUsageTelemetry
.
jsm
"
)
;
Services
.
obs
.
notifyObservers
(
null
TELEMETRY_SUBSESSION_TOPIC
)
;
let
checkScalars
=
(
countsObject
)
=
>
{
const
scalars
=
TelemetryTestUtils
.
getProcessScalars
(
"
parent
"
)
;
TelemetryTestUtils
.
assertScalar
(
scalars
MAX_CONCURRENT_TABS
countsObject
.
maxTabs
"
The
maximum
tab
count
must
match
the
expected
value
.
"
)
;
TelemetryTestUtils
.
assertScalar
(
scalars
TAB_EVENT_COUNT
countsObject
.
tabOpenCount
"
The
number
of
open
tab
event
count
must
match
the
expected
value
.
"
)
;
TelemetryTestUtils
.
assertScalar
(
scalars
MAX_TAB_PINNED
countsObject
.
maxTabsPinned
"
The
maximum
tabs
pinned
count
must
match
the
expected
value
.
"
)
;
TelemetryTestUtils
.
assertScalar
(
scalars
TAB_PINNED_EVENT
countsObject
.
tabPinnedCount
"
The
number
of
tab
pinned
event
count
must
match
the
expected
value
.
"
)
;
TelemetryTestUtils
.
assertScalar
(
scalars
MAX_CONCURRENT_WINDOWS
countsObject
.
maxWindows
"
The
maximum
window
count
must
match
the
expected
value
.
"
)
;
TelemetryTestUtils
.
assertScalar
(
scalars
WINDOW_OPEN_COUNT
countsObject
.
windowsOpenCount
"
The
number
of
window
open
event
count
must
match
the
expected
value
.
"
)
;
TelemetryTestUtils
.
assertScalar
(
scalars
TOTAL_URI_COUNT
countsObject
.
totalURIs
"
The
total
URI
count
must
match
the
expected
value
.
"
)
;
TelemetryTestUtils
.
assertScalar
(
scalars
UNIQUE_DOMAINS_COUNT
countsObject
.
domainCount
"
The
unique
domains
count
must
match
the
expected
value
.
"
)
;
TelemetryTestUtils
.
assertScalar
(
scalars
UNFILTERED_URI_COUNT
countsObject
.
totalUnfilteredURIs
"
The
unfiltered
URI
count
must
match
the
expected
value
.
"
)
;
}
;
add_task
(
async
function
test_tabsAndWindows
(
)
{
Services
.
telemetry
.
clearScalars
(
)
;
let
openedTabs
=
[
]
;
let
expectedTabOpenCount
=
0
;
let
expectedWinOpenCount
=
0
;
let
expectedMaxTabs
=
0
;
let
expectedMaxWins
=
0
;
let
expectedMaxTabsPinned
=
0
;
let
expectedTabPinned
=
0
;
openedTabs
.
push
(
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
"
about
:
blank
"
)
)
;
gBrowser
.
pinTab
(
openedTabs
[
0
]
)
;
gBrowser
.
unpinTab
(
openedTabs
[
0
]
)
;
expectedTabOpenCount
=
1
;
expectedMaxTabs
=
2
;
expectedMaxTabsPinned
=
1
;
expectedTabPinned
+
=
1
;
checkScalars
(
{
maxTabs
:
expectedMaxTabs
tabOpenCount
:
expectedTabOpenCount
maxWindows
:
expectedMaxWins
windowsOpenCount
:
expectedWinOpenCount
totalURIs
:
0
domainCount
:
0
totalUnfilteredURIs
:
0
maxTabsPinned
:
expectedMaxTabsPinned
tabPinnedCount
:
expectedTabPinned
}
)
;
openedTabs
.
push
(
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
"
about
:
blank
"
)
)
;
openedTabs
.
push
(
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
"
about
:
blank
"
)
)
;
gBrowser
.
pinTab
(
openedTabs
[
1
]
)
;
gBrowser
.
pinTab
(
openedTabs
[
2
]
)
;
gBrowser
.
unpinTab
(
openedTabs
[
2
]
)
;
gBrowser
.
unpinTab
(
openedTabs
[
1
]
)
;
expectedTabOpenCount
+
=
2
;
expectedMaxTabs
+
=
2
;
expectedMaxTabsPinned
=
2
;
expectedTabPinned
+
=
2
;
checkScalars
(
{
maxTabs
:
expectedMaxTabs
tabOpenCount
:
expectedTabOpenCount
maxWindows
:
expectedMaxWins
windowsOpenCount
:
expectedWinOpenCount
totalURIs
:
0
domainCount
:
0
totalUnfilteredURIs
:
0
maxTabsPinned
:
expectedMaxTabsPinned
tabPinnedCount
:
expectedTabPinned
}
)
;
let
win
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
openedTabs
.
push
(
await
BrowserTestUtils
.
openNewForegroundTab
(
win
.
gBrowser
"
about
:
blank
"
)
)
;
openedTabs
.
push
(
await
BrowserTestUtils
.
openNewForegroundTab
(
win
.
gBrowser
"
about
:
blank
"
)
)
;
openedTabs
.
push
(
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
"
about
:
blank
"
)
)
;
expectedTabOpenCount
+
=
4
;
expectedWinOpenCount
+
=
1
;
expectedMaxWins
=
2
;
expectedMaxTabs
+
=
4
;
BrowserTestUtils
.
removeTab
(
openedTabs
.
pop
(
)
)
;
checkScalars
(
{
maxTabs
:
expectedMaxTabs
tabOpenCount
:
expectedTabOpenCount
maxWindows
:
expectedMaxWins
windowsOpenCount
:
expectedWinOpenCount
totalURIs
:
0
domainCount
:
0
totalUnfilteredURIs
:
0
maxTabsPinned
:
expectedMaxTabsPinned
tabPinnedCount
:
expectedTabPinned
}
)
;
for
(
let
tab
of
openedTabs
)
{
BrowserTestUtils
.
removeTab
(
tab
)
;
}
await
BrowserTestUtils
.
closeWindow
(
win
)
;
checkScalars
(
{
maxTabs
:
expectedMaxTabs
tabOpenCount
:
expectedTabOpenCount
maxWindows
:
expectedMaxWins
windowsOpenCount
:
expectedWinOpenCount
totalURIs
:
0
domainCount
:
0
totalUnfilteredURIs
:
0
maxTabsPinned
:
expectedMaxTabsPinned
tabPinnedCount
:
expectedTabPinned
}
)
;
}
)
;
add_task
(
async
function
test_subsessionSplit
(
)
{
Services
.
telemetry
.
clearScalars
(
)
;
let
win
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
let
openedTabs
=
[
]
;
openedTabs
.
push
(
await
BrowserTestUtils
.
openNewForegroundTab
(
win
.
gBrowser
"
about
:
blank
"
)
)
;
openedTabs
.
push
(
await
BrowserTestUtils
.
openNewForegroundTab
(
win
.
gBrowser
"
about
:
mozilla
"
)
)
;
openedTabs
.
push
(
await
BrowserTestUtils
.
openNewForegroundTab
(
win
.
gBrowser
"
http
:
/
/
www
.
example
.
com
"
)
)
;
checkScalars
(
{
maxTabs
:
5
tabOpenCount
:
4
maxWindows
:
2
windowsOpenCount
:
1
totalURIs
:
1
domainCount
:
1
totalUnfilteredURIs
:
2
maxTabsPinned
:
0
tabPinnedCount
:
0
}
)
;
BrowserTestUtils
.
removeTab
(
openedTabs
.
pop
(
)
)
;
Services
.
telemetry
.
getSnapshotForScalars
(
"
main
"
true
)
;
Services
.
obs
.
notifyObservers
(
null
TELEMETRY_SUBSESSION_TOPIC
)
;
checkScalars
(
{
maxTabs
:
4
tabOpenCount
:
0
maxWindows
:
2
windowsOpenCount
:
0
totalURIs
:
0
domainCount
:
0
totalUnfilteredURIs
:
0
maxTabsPinned
:
0
tabPinnedCount
:
0
}
)
;
for
(
let
tab
of
openedTabs
)
{
BrowserTestUtils
.
removeTab
(
tab
)
;
}
await
BrowserTestUtils
.
closeWindow
(
win
)
;
}
)
;
function
checkTabCountHistogram
(
result
expected
message
)
{
Assert
.
deepEqual
(
result
.
values
expected
message
)
;
}
add_task
(
async
function
test_tabsHistogram
(
)
{
let
openedTabs
=
[
]
;
let
tabCountHist
=
TelemetryTestUtils
.
getAndClearHistogram
(
"
TAB_COUNT
"
)
;
checkTabCountHistogram
(
tabCountHist
.
snapshot
(
)
{
}
"
TAB_COUNT
telemetry
-
initial
tab
counts
"
)
;
BrowserUsageTelemetry
.
_lastRecordTabCount
=
0
;
openedTabs
.
push
(
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
"
about
:
blank
"
)
)
;
checkTabCountHistogram
(
tabCountHist
.
snapshot
(
)
{
1
:
0
2
:
1
3
:
0
}
"
TAB_COUNT
telemetry
-
opening
tabs
"
)
;
BrowserUsageTelemetry
.
_lastRecordTabCount
=
0
;
let
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
"
about
:
blank
"
)
;
openedTabs
.
push
(
tab
)
;
BrowserUsageTelemetry
.
_lastRecordTabCount
=
0
;
await
BrowserTestUtils
.
loadURI
(
tab
.
linkedBrowser
"
http
:
/
/
example
.
com
/
"
)
;
await
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
)
;
checkTabCountHistogram
(
tabCountHist
.
snapshot
(
)
{
1
:
0
2
:
1
3
:
2
4
:
0
}
"
TAB_COUNT
telemetry
-
loading
page
"
)
;
BrowserUsageTelemetry
.
_lastRecordTabCount
=
0
;
openedTabs
.
push
(
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
"
about
:
blank
"
)
)
;
checkTabCountHistogram
(
tabCountHist
.
snapshot
(
)
{
1
:
0
2
:
1
3
:
2
4
:
1
5
:
0
}
"
TAB_COUNT
telemetry
-
opening
more
tabs
"
)
;
BrowserUsageTelemetry
.
_lastRecordTabCount
=
0
;
let
win
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
checkTabCountHistogram
(
tabCountHist
.
snapshot
(
)
{
1
:
0
2
:
1
3
:
2
4
:
1
5
:
1
6
:
0
}
"
TAB_COUNT
telemetry
-
opening
window
"
)
;
BrowserUsageTelemetry
.
_lastRecordTabCount
=
Date
.
now
(
)
-
(
MINIMUM_TAB_COUNT_INTERVAL_MS
/
2
)
;
{
let
oldLastRecordTabCount
=
BrowserUsageTelemetry
.
_lastRecordTabCount
;
openedTabs
.
push
(
await
BrowserTestUtils
.
openNewForegroundTab
(
win
.
gBrowser
"
about
:
blank
"
)
)
;
checkTabCountHistogram
(
tabCountHist
.
snapshot
(
)
{
1
:
0
2
:
1
3
:
2
4
:
1
5
:
1
6
:
0
}
"
TAB_COUNT
telemetry
-
new
tab
recount
event
ignored
"
)
;
ok
(
BrowserUsageTelemetry
.
_lastRecordTabCount
=
=
oldLastRecordTabCount
"
TAB_COUNT
telemetry
-
_lastRecordTabCount
unchanged
"
)
;
}
BrowserUsageTelemetry
.
_lastRecordTabCount
=
Date
.
now
(
)
-
(
MINIMUM_TAB_COUNT_INTERVAL_MS
+
1000
)
;
{
let
oldLastRecordTabCount
=
BrowserUsageTelemetry
.
_lastRecordTabCount
;
openedTabs
.
push
(
await
BrowserTestUtils
.
openNewForegroundTab
(
win
.
gBrowser
"
about
:
blank
"
)
)
;
checkTabCountHistogram
(
tabCountHist
.
snapshot
(
)
{
1
:
0
2
:
1
3
:
2
4
:
1
5
:
1
7
:
1
8
:
0
}
"
TAB_COUNT
telemetry
-
new
tab
recount
event
included
"
)
;
ok
(
BrowserUsageTelemetry
.
_lastRecordTabCount
!
=
oldLastRecordTabCount
"
TAB_COUNT
telemetry
-
_lastRecordTabCount
updated
"
)
;
ok
(
BrowserUsageTelemetry
.
_lastRecordTabCount
>
Date
.
now
(
)
-
MINIMUM_TAB_COUNT_INTERVAL_MS
"
TAB_COUNT
telemetry
-
_lastRecordTabCount
invariant
"
)
;
}
BrowserUsageTelemetry
.
_lastRecordTabCount
=
Date
.
now
(
)
-
(
MINIMUM_TAB_COUNT_INTERVAL_MS
/
2
)
;
{
let
oldLastRecordTabCount
=
BrowserUsageTelemetry
.
_lastRecordTabCount
;
await
BrowserTestUtils
.
loadURI
(
tab
.
linkedBrowser
"
http
:
/
/
example
.
com
/
"
)
;
await
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
)
;
checkTabCountHistogram
(
tabCountHist
.
snapshot
(
)
{
1
:
0
2
:
1
3
:
2
4
:
1
5
:
1
7
:
1
8
:
0
}
"
TAB_COUNT
telemetry
-
page
load
recount
event
ignored
"
)
;
ok
(
BrowserUsageTelemetry
.
_lastRecordTabCount
=
=
oldLastRecordTabCount
"
TAB_COUNT
telemetry
-
_lastRecordTabCount
unchanged
"
)
;
}
BrowserUsageTelemetry
.
_lastRecordTabCount
=
Date
.
now
(
)
-
(
MINIMUM_TAB_COUNT_INTERVAL_MS
+
1000
)
;
{
let
oldLastRecordTabCount
=
BrowserUsageTelemetry
.
_lastRecordTabCount
;
await
BrowserTestUtils
.
loadURI
(
tab
.
linkedBrowser
"
http
:
/
/
example
.
com
/
"
)
;
await
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
)
;
checkTabCountHistogram
(
tabCountHist
.
snapshot
(
)
{
1
:
0
2
:
1
3
:
2
4
:
1
5
:
1
7
:
2
8
:
0
}
"
TAB_COUNT
telemetry
-
page
load
recount
event
included
"
)
;
ok
(
BrowserUsageTelemetry
.
_lastRecordTabCount
!
=
oldLastRecordTabCount
"
TAB_COUNT
telemetry
-
_lastRecordTabCount
updated
"
)
;
ok
(
BrowserUsageTelemetry
.
_lastRecordTabCount
>
Date
.
now
(
)
-
MINIMUM_TAB_COUNT_INTERVAL_MS
"
TAB_COUNT
telemetry
-
_lastRecordTabCount
invariant
"
)
;
}
for
(
let
openTab
of
openedTabs
)
{
BrowserTestUtils
.
removeTab
(
openTab
)
;
}
await
BrowserTestUtils
.
closeWindow
(
win
)
;
}
)
;
