"
use
strict
"
;
ChromeUtils
.
defineESModuleGetters
(
this
{
ExtensionCommon
:
"
resource
:
/
/
gre
/
modules
/
ExtensionCommon
.
sys
.
mjs
"
}
)
;
add_setup
(
async
function
(
)
{
let
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
{
gBrowser
url
:
"
http
:
/
/
example
.
com
/
"
}
)
;
registerCleanupFunction
(
async
(
)
=
>
{
BrowserTestUtils
.
removeTab
(
tab
)
;
}
)
;
await
initPageActionsTest
(
)
;
}
)
;
add_task
(
async
function
contextMenu
(
)
{
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
manifest
:
{
name
:
"
Page
action
test
"
page_action
:
{
show_matches
:
[
"
<
all_urls
>
"
]
}
}
useAddonManager
:
"
temporary
"
}
)
;
await
extension
.
startup
(
)
;
let
actionId
=
ExtensionCommon
.
makeWidgetId
(
extension
.
id
)
;
await
promiseOpenPageActionPanel
(
)
;
let
panelButton
=
BrowserPageActions
.
panelButtonNodeForActionID
(
actionId
)
;
let
cxmenu
=
document
.
getElementById
(
"
pageActionContextMenu
"
)
;
let
contextMenuPromise
;
let
menuItems
;
contextMenuPromise
=
promisePanelShown
(
"
pageActionContextMenu
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
panelButton
{
type
:
"
contextmenu
"
button
:
2
}
)
;
await
contextMenuPromise
;
menuItems
=
collectContextMenuItems
(
)
;
Assert
.
deepEqual
(
makeMenuItemSpecs
(
menuItems
)
makeContextMenuItemSpecs
(
)
)
;
let
manageItemIndex
=
0
;
contextMenuPromise
=
promisePanelHidden
(
"
pageActionContextMenu
"
)
;
let
aboutAddonsPromise
=
BrowserTestUtils
.
waitForNewTab
(
gBrowser
"
about
:
addons
"
)
;
cxmenu
.
activateItem
(
menuItems
[
manageItemIndex
]
)
;
let
values
=
await
Promise
.
all
(
[
aboutAddonsPromise
contextMenuPromise
]
)
;
let
aboutAddonsTab
=
values
[
0
]
;
BrowserTestUtils
.
removeTab
(
aboutAddonsTab
)
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
{
return
BrowserPageActions
.
urlbarButtonNodeForActionID
(
actionId
)
;
}
"
Waiting
for
urlbar
button
to
be
added
back
"
)
;
let
urlbarButton
=
BrowserPageActions
.
urlbarButtonNodeForActionID
(
actionId
)
;
contextMenuPromise
=
promisePanelShown
(
"
pageActionContextMenu
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
urlbarButton
{
type
:
"
contextmenu
"
button
:
2
}
)
;
await
contextMenuPromise
;
menuItems
=
collectContextMenuItems
(
)
;
Assert
.
deepEqual
(
makeMenuItemSpecs
(
menuItems
)
makeContextMenuItemSpecs
(
)
)
;
contextMenuPromise
=
promisePanelHidden
(
"
pageActionContextMenu
"
)
;
aboutAddonsPromise
=
BrowserTestUtils
.
waitForNewTab
(
gBrowser
"
about
:
addons
"
)
;
cxmenu
.
activateItem
(
menuItems
[
manageItemIndex
]
)
;
values
=
await
Promise
.
all
(
[
aboutAddonsPromise
contextMenuPromise
]
)
;
aboutAddonsTab
=
values
[
0
]
;
BrowserTestUtils
.
removeTab
(
aboutAddonsTab
)
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
{
return
BrowserPageActions
.
urlbarButtonNodeForActionID
(
actionId
)
;
}
"
Waiting
for
urlbar
button
to
be
added
back
"
)
;
urlbarButton
=
BrowserPageActions
.
urlbarButtonNodeForActionID
(
actionId
)
;
contextMenuPromise
=
promisePanelShown
(
"
pageActionContextMenu
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
urlbarButton
{
type
:
"
contextmenu
"
button
:
2
}
)
;
await
contextMenuPromise
;
menuItems
=
collectContextMenuItems
(
)
;
Assert
.
deepEqual
(
makeMenuItemSpecs
(
menuItems
)
makeContextMenuItemSpecs
(
)
)
;
let
{
prompt
}
=
Services
;
let
promptService
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIPromptService
"
]
)
confirmEx
(
)
{
return
0
;
}
}
;
Services
.
prompt
=
promptService
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
prompt
=
prompt
;
}
)
;
let
removeItemIndex
=
manageItemIndex
+
1
;
contextMenuPromise
=
promisePanelHidden
(
"
pageActionContextMenu
"
)
;
let
promiseUninstalled
=
promiseAddonUninstalled
(
extension
.
id
)
;
cxmenu
.
activateItem
(
menuItems
[
removeItemIndex
]
)
;
await
contextMenuPromise
;
await
promiseUninstalled
;
await
extension
.
unload
(
)
;
Services
.
prompt
=
prompt
;
EventUtils
.
synthesizeMouseAtCenter
(
gURLBar
.
inputField
{
type
:
"
mousemove
"
}
)
;
gURLBar
.
focus
(
)
;
}
)
;
add_task
(
async
function
contextMenuOnSeparator
(
)
{
let
action
=
PageActions
.
addAction
(
new
PageActions
.
Action
(
{
id
:
"
contextMenuOnSeparator
"
title
:
"
contextMenuOnSeparator
"
pinnedToUrlbar
:
true
}
)
)
;
await
promiseOpenPageActionPanel
(
)
;
let
separator
=
BrowserPageActions
.
panelButtonNodeForActionID
(
PageActions
.
ACTION_ID_BUILT_IN_SEPARATOR
)
;
Assert
.
ok
(
separator
"
The
built
-
in
separator
should
be
in
the
panel
"
)
;
let
showingPromise
=
BrowserTestUtils
.
waitForEvent
(
document
.
getElementById
(
"
pageActionContextMenu
"
)
"
popupshowing
"
false
)
;
EventUtils
.
synthesizeMouseAtCenter
(
separator
{
type
:
"
contextmenu
"
button
:
2
}
)
;
let
event
=
await
showingPromise
;
Assert
.
ok
(
event
.
defaultPrevented
"
defaultPrevented
should
be
true
on
popupshowing
event
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
BrowserPageActions
.
mainButtonNode
{
}
)
;
await
promisePageActionPanelHidden
(
)
;
action
.
remove
(
)
;
EventUtils
.
synthesizeMouseAtCenter
(
gURLBar
.
inputField
{
type
:
"
mousemove
"
}
)
;
gURLBar
.
focus
(
)
;
}
)
;
function
collectContextMenuItems
(
)
{
let
contextMenu
=
document
.
getElementById
(
"
pageActionContextMenu
"
)
;
return
Array
.
prototype
.
filter
.
call
(
contextMenu
.
children
node
=
>
{
return
window
.
getComputedStyle
(
node
)
.
visibility
=
=
"
visible
"
;
}
)
;
}
function
makeMenuItemSpecs
(
elements
)
{
return
elements
.
map
(
e
=
>
e
.
localName
=
=
"
menuseparator
"
?
{
}
:
{
label
:
e
.
label
}
)
;
}
function
makeContextMenuItemSpecs
(
)
{
let
items
=
[
{
label
:
"
Manage
Extension
\
u2026
"
}
{
label
:
"
Remove
Extension
"
}
]
;
return
items
;
}
function
promiseAddonUninstalled
(
addonId
)
{
return
new
Promise
(
resolve
=
>
{
let
listener
=
{
}
;
listener
.
onUninstalled
=
addon
=
>
{
if
(
addon
.
id
=
=
addonId
)
{
AddonManager
.
removeAddonListener
(
listener
)
;
resolve
(
)
;
}
}
;
AddonManager
.
addAddonListener
(
listener
)
;
}
)
;
}
