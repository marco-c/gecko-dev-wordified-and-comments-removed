"
use
strict
"
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
ExtensionCommon
:
"
resource
:
/
/
gre
/
modules
/
ExtensionCommon
.
jsm
"
}
)
;
add_task
(
async
function
init
(
)
{
let
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
{
gBrowser
url
:
"
http
:
/
/
example
.
com
/
"
}
)
;
registerCleanupFunction
(
async
(
)
=
>
{
BrowserTestUtils
.
removeTab
(
tab
)
;
}
)
;
await
initPageActionsTest
(
)
;
}
)
;
add_task
(
async
function
contextMenu
(
)
{
Services
.
telemetry
.
clearEvents
(
)
;
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
manifest
:
{
name
:
"
Page
action
test
"
page_action
:
{
show_matches
:
[
"
<
all_urls
>
"
]
}
}
useAddonManager
:
"
temporary
"
}
)
;
await
extension
.
startup
(
)
;
let
actionId
=
ExtensionCommon
.
makeWidgetId
(
extension
.
id
)
;
await
promiseOpenPageActionPanel
(
)
;
let
panelButton
=
BrowserPageActions
.
panelButtonNodeForActionID
(
actionId
)
;
let
contextMenuPromise
;
let
menuItems
;
if
(
!
gProton
)
{
contextMenuPromise
=
promisePanelShown
(
"
pageActionContextMenu
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
panelButton
{
type
:
"
contextmenu
"
button
:
2
}
)
;
await
contextMenuPromise
;
menuItems
=
collectContextMenuItems
(
)
;
Assert
.
deepEqual
(
makeMenuItemSpecs
(
menuItems
)
makeContextMenuItemSpecs
(
true
)
)
;
contextMenuPromise
=
promisePanelHidden
(
"
pageActionContextMenu
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
menuItems
[
0
]
{
}
)
;
await
contextMenuPromise
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
{
return
!
BrowserPageActions
.
urlbarButtonNodeForActionID
(
actionId
)
;
}
"
Waiting
for
urlbar
button
to
be
removed
"
)
;
contextMenuPromise
=
promisePanelShown
(
"
pageActionContextMenu
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
panelButton
{
type
:
"
contextmenu
"
button
:
2
}
)
;
await
contextMenuPromise
;
menuItems
=
collectContextMenuItems
(
)
;
Assert
.
deepEqual
(
makeMenuItemSpecs
(
menuItems
)
makeContextMenuItemSpecs
(
false
)
)
;
contextMenuPromise
=
promisePanelHidden
(
"
pageActionContextMenu
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
menuItems
[
0
]
{
}
)
;
await
contextMenuPromise
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
{
return
BrowserPageActions
.
urlbarButtonNodeForActionID
(
actionId
)
;
}
"
Waiting
for
urlbar
button
to
be
added
back
"
)
;
}
contextMenuPromise
=
promisePanelShown
(
"
pageActionContextMenu
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
panelButton
{
type
:
"
contextmenu
"
button
:
2
}
)
;
await
contextMenuPromise
;
menuItems
=
collectContextMenuItems
(
)
;
Assert
.
deepEqual
(
makeMenuItemSpecs
(
menuItems
)
makeContextMenuItemSpecs
(
true
)
)
;
let
manageItemIndex
=
gProton
?
0
:
2
;
contextMenuPromise
=
promisePanelHidden
(
"
pageActionContextMenu
"
)
;
let
aboutAddonsPromise
=
BrowserTestUtils
.
waitForNewTab
(
gBrowser
"
about
:
addons
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
menuItems
[
manageItemIndex
]
{
}
)
;
let
values
=
await
Promise
.
all
(
[
aboutAddonsPromise
contextMenuPromise
]
)
;
let
aboutAddonsTab
=
values
[
0
]
;
BrowserTestUtils
.
removeTab
(
aboutAddonsTab
)
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
{
return
BrowserPageActions
.
urlbarButtonNodeForActionID
(
actionId
)
;
}
"
Waiting
for
urlbar
button
to
be
added
back
"
)
;
let
urlbarButton
;
if
(
!
gProton
)
{
urlbarButton
=
BrowserPageActions
.
urlbarButtonNodeForActionID
(
actionId
)
;
contextMenuPromise
=
promisePanelShown
(
"
pageActionContextMenu
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
urlbarButton
{
type
:
"
contextmenu
"
button
:
2
}
)
;
await
contextMenuPromise
;
menuItems
=
collectContextMenuItems
(
)
;
Assert
.
deepEqual
(
makeMenuItemSpecs
(
menuItems
)
makeContextMenuItemSpecs
(
true
)
)
;
contextMenuPromise
=
promisePanelHidden
(
"
pageActionContextMenu
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
menuItems
[
0
]
{
}
)
;
await
contextMenuPromise
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
{
return
!
BrowserPageActions
.
urlbarButtonNodeForActionID
(
actionId
)
;
}
"
Waiting
for
urlbar
button
to
be
removed
"
)
;
await
promiseOpenPageActionPanel
(
)
;
contextMenuPromise
=
promisePanelShown
(
"
pageActionContextMenu
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
panelButton
{
type
:
"
contextmenu
"
button
:
2
}
)
;
await
contextMenuPromise
;
menuItems
=
collectContextMenuItems
(
)
;
Assert
.
deepEqual
(
makeMenuItemSpecs
(
menuItems
)
makeContextMenuItemSpecs
(
false
)
)
;
contextMenuPromise
=
promisePanelHidden
(
"
pageActionContextMenu
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
menuItems
[
0
]
{
}
)
;
await
contextMenuPromise
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
{
return
BrowserPageActions
.
urlbarButtonNodeForActionID
(
actionId
)
;
}
"
Waiting
for
urlbar
button
to
be
added
back
"
)
;
}
urlbarButton
=
BrowserPageActions
.
urlbarButtonNodeForActionID
(
actionId
)
;
contextMenuPromise
=
promisePanelShown
(
"
pageActionContextMenu
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
urlbarButton
{
type
:
"
contextmenu
"
button
:
2
}
)
;
await
contextMenuPromise
;
menuItems
=
collectContextMenuItems
(
)
;
Assert
.
deepEqual
(
makeMenuItemSpecs
(
menuItems
)
makeContextMenuItemSpecs
(
true
)
)
;
contextMenuPromise
=
promisePanelHidden
(
"
pageActionContextMenu
"
)
;
aboutAddonsPromise
=
BrowserTestUtils
.
waitForNewTab
(
gBrowser
"
about
:
addons
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
menuItems
[
manageItemIndex
]
{
}
)
;
values
=
await
Promise
.
all
(
[
aboutAddonsPromise
contextMenuPromise
]
)
;
aboutAddonsTab
=
values
[
0
]
;
BrowserTestUtils
.
removeTab
(
aboutAddonsTab
)
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
{
return
BrowserPageActions
.
urlbarButtonNodeForActionID
(
actionId
)
;
}
"
Waiting
for
urlbar
button
to
be
added
back
"
)
;
urlbarButton
=
BrowserPageActions
.
urlbarButtonNodeForActionID
(
actionId
)
;
contextMenuPromise
=
promisePanelShown
(
"
pageActionContextMenu
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
urlbarButton
{
type
:
"
contextmenu
"
button
:
2
}
)
;
await
contextMenuPromise
;
menuItems
=
collectContextMenuItems
(
)
;
Assert
.
deepEqual
(
makeMenuItemSpecs
(
menuItems
)
makeContextMenuItemSpecs
(
true
)
)
;
let
{
prompt
}
=
Services
;
let
promptService
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIPromptService
"
]
)
confirmEx
(
)
{
return
0
;
}
}
;
Services
.
prompt
=
promptService
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
prompt
=
prompt
;
}
)
;
let
removeItemIndex
=
manageItemIndex
+
1
;
contextMenuPromise
=
promisePanelHidden
(
"
pageActionContextMenu
"
)
;
let
promiseUninstalled
=
promiseAddonUninstalled
(
extension
.
id
)
;
EventUtils
.
synthesizeMouseAtCenter
(
menuItems
[
removeItemIndex
]
{
}
)
;
await
contextMenuPromise
;
await
promiseUninstalled
;
let
addonId
=
extension
.
id
;
await
extension
.
unload
(
)
;
Services
.
prompt
=
prompt
;
let
snapshot
=
Services
.
telemetry
.
snapshotEvents
(
Ci
.
nsITelemetry
.
DATASET_PRERELEASE_CHANNELS
true
)
;
ok
(
snapshot
.
parent
&
&
!
!
snapshot
.
parent
.
length
"
Got
parent
telemetry
events
in
the
snapshot
"
)
;
let
relatedEvents
=
snapshot
.
parent
.
filter
(
(
[
timestamp
category
method
]
)
=
>
category
=
=
"
addonsManager
"
&
&
method
=
=
"
action
"
)
.
map
(
relatedEvent
=
>
relatedEvent
.
slice
(
3
6
)
)
;
Assert
.
deepEqual
(
relatedEvents
[
[
"
pageAction
"
null
{
addonId
action
:
"
manage
"
}
]
[
"
pageAction
"
null
{
addonId
action
:
"
manage
"
}
]
[
"
pageAction
"
"
accepted
"
{
addonId
action
:
"
uninstall
"
}
]
]
)
;
EventUtils
.
synthesizeMouseAtCenter
(
gURLBar
.
inputField
{
type
:
"
mousemove
"
}
)
;
gURLBar
.
focus
(
)
;
}
)
;
add_task
(
async
function
contextMenuOnSeparator
(
)
{
let
action
=
PageActions
.
addAction
(
new
PageActions
.
Action
(
{
id
:
"
contextMenuOnSeparator
"
title
:
"
contextMenuOnSeparator
"
pinnedToUrlbar
:
true
}
)
)
;
await
promiseOpenPageActionPanel
(
)
;
let
separator
=
BrowserPageActions
.
panelButtonNodeForActionID
(
PageActions
.
ACTION_ID_BUILT_IN_SEPARATOR
)
;
Assert
.
ok
(
separator
"
The
built
-
in
separator
should
be
in
the
panel
"
)
;
let
showingPromise
=
BrowserTestUtils
.
waitForEvent
(
document
.
getElementById
(
"
pageActionContextMenu
"
)
"
popupshowing
"
false
)
;
EventUtils
.
synthesizeMouseAtCenter
(
separator
{
type
:
"
contextmenu
"
button
:
2
}
)
;
let
event
=
await
showingPromise
;
Assert
.
ok
(
event
.
defaultPrevented
"
defaultPrevented
should
be
true
on
popupshowing
event
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
BrowserPageActions
.
mainButtonNode
{
}
)
;
await
promisePageActionPanelHidden
(
)
;
action
.
remove
(
)
;
EventUtils
.
synthesizeMouseAtCenter
(
gURLBar
.
inputField
{
type
:
"
mousemove
"
}
)
;
gURLBar
.
focus
(
)
;
}
)
;
function
collectContextMenuItems
(
)
{
let
contextMenu
=
document
.
getElementById
(
"
pageActionContextMenu
"
)
;
return
Array
.
prototype
.
filter
.
call
(
contextMenu
.
children
node
=
>
{
return
window
.
getComputedStyle
(
node
)
.
visibility
=
=
"
visible
"
;
}
)
;
}
function
makeMenuItemSpecs
(
elements
)
{
return
elements
.
map
(
e
=
>
e
.
localName
=
=
"
menuseparator
"
?
{
}
:
{
label
:
e
.
label
}
)
;
}
function
makeContextMenuItemSpecs
(
actionInUrlbar
=
false
)
{
let
items
=
[
{
label
:
"
Manage
Extension
\
u2026
"
}
{
label
:
"
Remove
Extension
"
}
]
;
if
(
!
gProton
)
{
items
.
unshift
(
{
label
:
actionInUrlbar
?
"
Remove
from
Address
Bar
"
:
"
Add
to
Address
Bar
"
}
{
}
)
;
}
return
items
;
}
function
promiseAddonUninstalled
(
addonId
)
{
return
new
Promise
(
resolve
=
>
{
let
listener
=
{
}
;
listener
.
onUninstalled
=
addon
=
>
{
if
(
addon
.
id
=
=
addonId
)
{
AddonManager
.
removeAddonListener
(
listener
)
;
resolve
(
)
;
}
}
;
AddonManager
.
addAddonListener
(
listener
)
;
}
)
;
}
