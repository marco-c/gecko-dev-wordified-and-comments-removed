"
use
strict
"
;
const
SCALAR_SEARCHBAR
=
"
browser
.
engagement
.
navigation
.
searchbar
"
;
let
searchInSearchbar
=
Task
.
async
(
function
*
(
inputText
)
{
let
win
=
window
;
yield
new
Promise
(
r
=
>
waitForFocus
(
r
win
)
)
;
let
sb
=
BrowserSearch
.
searchBar
;
sb
.
focus
(
)
;
sb
.
value
=
inputText
;
sb
.
textbox
.
controller
.
startSearch
(
inputText
)
;
yield
BrowserTestUtils
.
waitForEvent
(
sb
.
textbox
.
popup
"
popupshown
"
)
;
yield
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
sb
.
textbox
.
controller
.
searchStatus
>
=
Ci
.
nsIAutoCompleteController
.
STATUS_COMPLETE_NO_MATCH
"
The
search
in
the
searchbar
must
complete
.
"
)
;
}
)
;
function
clickSearchbarSuggestion
(
entryName
)
{
let
popup
=
BrowserSearch
.
searchBar
.
textbox
.
popup
;
let
column
=
popup
.
tree
.
columns
[
0
]
;
for
(
let
rowID
=
0
;
rowID
<
popup
.
tree
.
view
.
rowCount
;
rowID
+
+
)
{
const
suggestion
=
popup
.
tree
.
view
.
getValueAt
(
rowID
column
)
;
if
(
suggestion
!
=
=
entryName
)
{
continue
;
}
let
tbo
=
popup
.
tree
.
treeBoxObject
;
tbo
.
ensureRowIsVisible
(
rowID
)
;
let
rect
=
tbo
.
getCoordsForCellItem
(
rowID
column
"
text
"
)
;
let
x
=
rect
.
x
+
rect
.
width
/
2
;
let
y
=
rect
.
y
+
rect
.
height
/
2
;
EventUtils
.
synthesizeMouse
(
popup
.
tree
.
body
x
y
{
}
popup
.
tree
.
ownerGlobal
)
;
break
;
}
}
add_task
(
function
*
setup
(
)
{
Services
.
search
.
addEngineWithDetails
(
"
MozSearch
"
"
"
"
mozalias
"
"
"
"
GET
"
"
http
:
/
/
example
.
com
/
?
q
=
{
searchTerms
}
"
)
;
Services
.
search
.
addEngineWithDetails
(
"
MozSearch2
"
"
"
"
mozalias2
"
"
"
"
GET
"
"
http
:
/
/
example
.
com
/
?
q
=
{
searchTerms
}
"
)
;
let
engineDefault
=
Services
.
search
.
getEngineByName
(
"
MozSearch
"
)
;
let
originalEngine
=
Services
.
search
.
currentEngine
;
Services
.
search
.
currentEngine
=
engineDefault
;
let
engineOneOff
=
Services
.
search
.
getEngineByName
(
"
MozSearch2
"
)
;
Services
.
search
.
moveEngine
(
engineOneOff
0
)
;
registerCleanupFunction
(
function
*
(
)
{
Services
.
search
.
currentEngine
=
originalEngine
;
Services
.
search
.
removeEngine
(
engineDefault
)
;
Services
.
search
.
removeEngine
(
engineOneOff
)
;
}
)
;
}
)
;
add_task
(
function
*
test_plainQuery
(
)
{
Services
.
telemetry
.
clearScalars
(
)
;
let
tab
=
yield
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
"
about
:
blank
"
)
;
info
(
"
Simulate
entering
a
simple
search
.
"
)
;
let
p
=
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
)
;
yield
searchInSearchbar
(
"
simple
query
"
)
;
EventUtils
.
sendKey
(
"
return
"
)
;
yield
p
;
const
scalars
=
Services
.
telemetry
.
snapshotKeyedScalars
(
Ci
.
nsITelemetry
.
DATASET_RELEASE_CHANNEL_OPTIN
false
)
;
checkKeyedScalar
(
scalars
SCALAR_SEARCHBAR
"
search_enter
"
1
)
;
Assert
.
equal
(
Object
.
keys
(
scalars
[
SCALAR_SEARCHBAR
]
)
.
length
1
"
This
search
must
only
increment
one
entry
in
the
scalar
.
"
)
;
yield
BrowserTestUtils
.
removeTab
(
tab
)
;
}
)
;
add_task
(
function
*
test_oneOff
(
)
{
Services
.
telemetry
.
clearScalars
(
)
;
let
tab
=
yield
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
"
about
:
blank
"
)
;
info
(
"
Perform
a
one
-
off
search
using
the
first
engine
.
"
)
;
let
p
=
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
)
;
yield
searchInSearchbar
(
"
query
"
)
;
info
(
"
Pressing
Alt
+
Down
to
highlight
the
first
one
off
engine
.
"
)
;
EventUtils
.
synthesizeKey
(
"
VK_DOWN
"
{
altKey
:
true
}
)
;
EventUtils
.
sendKey
(
"
return
"
)
;
yield
p
;
const
scalars
=
Services
.
telemetry
.
snapshotKeyedScalars
(
Ci
.
nsITelemetry
.
DATASET_RELEASE_CHANNEL_OPTIN
false
)
;
checkKeyedScalar
(
scalars
SCALAR_SEARCHBAR
"
search_oneoff
"
1
)
;
Assert
.
equal
(
Object
.
keys
(
scalars
[
SCALAR_SEARCHBAR
]
)
.
length
1
"
This
search
must
only
increment
one
entry
in
the
scalar
.
"
)
;
yield
BrowserTestUtils
.
removeTab
(
tab
)
;
}
)
;
add_task
(
function
*
test_suggestion
(
)
{
Services
.
telemetry
.
clearScalars
(
)
;
const
url
=
getRootDirectory
(
gTestPath
)
+
"
usageTelemetrySearchSuggestions
.
xml
"
;
let
suggestionEngine
=
yield
new
Promise
(
(
resolve
reject
)
=
>
{
Services
.
search
.
addEngine
(
url
null
"
"
false
{
onSuccess
(
engine
)
{
resolve
(
engine
)
}
onError
(
)
{
reject
(
)
}
}
)
;
}
)
;
let
previousEngine
=
Services
.
search
.
currentEngine
;
Services
.
search
.
currentEngine
=
suggestionEngine
;
let
tab
=
yield
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
"
about
:
blank
"
)
;
info
(
"
Perform
a
one
-
off
search
using
the
first
engine
.
"
)
;
let
p
=
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
)
;
yield
searchInSearchbar
(
"
query
"
)
;
info
(
"
Clicking
the
searchbar
suggestion
.
"
)
;
clickSearchbarSuggestion
(
"
queryfoo
"
)
;
yield
p
;
const
scalars
=
Services
.
telemetry
.
snapshotKeyedScalars
(
Ci
.
nsITelemetry
.
DATASET_RELEASE_CHANNEL_OPTIN
false
)
;
checkKeyedScalar
(
scalars
SCALAR_SEARCHBAR
"
search_suggestion
"
1
)
;
Assert
.
equal
(
Object
.
keys
(
scalars
[
SCALAR_SEARCHBAR
]
)
.
length
1
"
This
search
must
only
increment
one
entry
in
the
scalar
.
"
)
;
Services
.
search
.
currentEngine
=
previousEngine
;
Services
.
search
.
removeEngine
(
suggestionEngine
)
;
yield
BrowserTestUtils
.
removeTab
(
tab
)
;
}
)
;
