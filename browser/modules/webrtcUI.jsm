"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
webrtcUI
"
]
;
const
{
EventEmitter
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
/
modules
/
syncedtabs
/
EventEmitter
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
AppConstants
"
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PluralForm
"
"
resource
:
/
/
gre
/
modules
/
PluralForm
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PrivateBrowsingUtils
"
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
SitePermissions
"
"
resource
:
/
/
/
modules
/
SitePermissions
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gBrandBundle
"
function
(
)
{
return
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
branding
/
locale
/
brand
.
properties
"
)
;
}
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
OSPermissions
"
"
mozilla
.
org
/
ospermissionrequest
;
1
"
"
nsIOSPermissionRequest
"
)
;
var
webrtcUI
=
{
peerConnectionBlockers
:
new
Set
(
)
emitter
:
new
EventEmitter
(
)
init
(
)
{
Services
.
obs
.
addObserver
(
maybeAddMenuIndicator
"
browser
-
delayed
-
startup
-
finished
"
)
;
Services
.
ppmm
.
addMessageListener
(
"
child
-
process
-
shutdown
"
this
)
;
}
uninit
(
)
{
Services
.
obs
.
removeObserver
(
maybeAddMenuIndicator
"
browser
-
delayed
-
startup
-
finished
"
)
;
if
(
gIndicatorWindow
)
{
gIndicatorWindow
.
close
(
)
;
gIndicatorWindow
=
null
;
}
}
processIndicators
:
new
Map
(
)
activePerms
:
new
Map
(
)
get
showGlobalIndicator
(
)
{
for
(
let
[
indicators
]
of
this
.
processIndicators
)
{
if
(
indicators
.
showGlobalIndicator
)
{
return
true
;
}
}
return
false
;
}
get
showCameraIndicator
(
)
{
for
(
let
[
indicators
]
of
this
.
processIndicators
)
{
if
(
indicators
.
showCameraIndicator
)
{
return
true
;
}
}
return
false
;
}
get
showMicrophoneIndicator
(
)
{
for
(
let
[
indicators
]
of
this
.
processIndicators
)
{
if
(
indicators
.
showMicrophoneIndicator
)
{
return
true
;
}
}
return
false
;
}
get
showScreenSharingIndicator
(
)
{
let
list
=
[
"
"
]
;
for
(
let
[
indicators
]
of
this
.
processIndicators
)
{
if
(
indicators
.
showScreenSharingIndicator
)
{
list
.
push
(
indicators
.
showScreenSharingIndicator
)
;
}
}
let
precedence
=
[
"
Screen
"
"
Window
"
"
Application
"
"
Browser
"
"
"
]
;
list
.
sort
(
(
a
b
)
=
>
{
return
precedence
.
indexOf
(
a
)
-
precedence
.
indexOf
(
b
)
;
}
)
;
return
list
[
0
]
;
}
_streams
:
[
]
getActiveStreams
(
aCamera
aMicrophone
aScreen
)
{
return
webrtcUI
.
_streams
.
filter
(
aStream
=
>
{
let
state
=
aStream
.
state
;
return
(
(
aCamera
&
&
state
.
camera
)
|
|
(
aMicrophone
&
&
state
.
microphone
)
|
|
(
aScreen
&
&
state
.
screen
)
)
;
}
)
.
map
(
aStream
=
>
{
let
state
=
aStream
.
state
;
let
types
=
{
camera
:
state
.
camera
microphone
:
state
.
microphone
screen
:
state
.
screen
}
;
let
browser
=
aStream
.
browser
;
let
browserWindow
=
browser
.
ownerGlobal
;
let
tab
=
browserWindow
.
gBrowser
&
&
browserWindow
.
gBrowser
.
getTabForBrowser
(
browser
)
;
return
{
uri
:
state
.
documentURI
tab
browser
types
}
;
}
)
;
}
swapBrowserForNotification
(
aOldBrowser
aNewBrowser
)
{
for
(
let
stream
of
this
.
_streams
)
{
if
(
stream
.
browser
=
=
aOldBrowser
)
{
stream
.
browser
=
aNewBrowser
;
}
}
}
forgetActivePermissionsFromBrowser
(
aBrowser
)
{
webrtcUI
.
activePerms
.
delete
(
aBrowser
.
outerWindowID
)
;
}
forgetStreamsFromBrowser
(
aBrowser
)
{
this
.
_streams
=
this
.
_streams
.
filter
(
stream
=
>
stream
.
browser
!
=
aBrowser
)
;
webrtcUI
.
forgetActivePermissionsFromBrowser
(
aBrowser
)
;
}
forgetStreamsFromProcess
(
aProcessMM
)
{
this
.
_streams
=
this
.
_streams
.
filter
(
stream
=
>
stream
.
processMM
&
&
stream
.
processMM
!
=
aProcessMM
)
;
}
showSharingDoorhanger
(
aActiveStream
)
{
let
browserWindow
=
aActiveStream
.
browser
.
ownerGlobal
;
if
(
aActiveStream
.
tab
)
{
browserWindow
.
gBrowser
.
selectedTab
=
aActiveStream
.
tab
;
}
else
{
aActiveStream
.
browser
.
focus
(
)
;
}
browserWindow
.
focus
(
)
;
let
identityBox
=
browserWindow
.
document
.
getElementById
(
"
identity
-
box
"
)
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
&
&
!
Services
.
focus
.
activeWindow
)
{
browserWindow
.
addEventListener
(
"
activate
"
function
(
)
{
Services
.
tm
.
dispatchToMainThread
(
function
(
)
{
identityBox
.
click
(
)
;
}
)
;
}
{
once
:
true
}
)
;
Cc
[
"
mozilla
.
org
/
widget
/
macdocksupport
;
1
"
]
.
getService
(
Ci
.
nsIMacDockSupport
)
.
activateApplication
(
true
)
;
return
;
}
identityBox
.
click
(
)
;
}
updateWarningLabel
(
aMenuList
)
{
let
type
=
aMenuList
.
selectedItem
.
getAttribute
(
"
devicetype
"
)
;
let
document
=
aMenuList
.
ownerDocument
;
document
.
getElementById
(
"
webRTC
-
all
-
windows
-
shared
"
)
.
hidden
=
type
!
=
"
screen
"
;
}
addPeerConnectionBlocker
(
aCallback
)
{
this
.
peerConnectionBlockers
.
add
(
aCallback
)
;
}
removePeerConnectionBlocker
(
aCallback
)
{
this
.
peerConnectionBlockers
.
delete
(
aCallback
)
;
}
on
(
.
.
.
args
)
{
return
this
.
emitter
.
on
(
.
.
.
args
)
;
}
off
(
.
.
.
args
)
{
return
this
.
emitter
.
off
(
.
.
.
args
)
;
}
receiveMessage
(
aMessage
)
{
switch
(
aMessage
.
name
)
{
case
"
rtcpeer
:
Request
"
:
{
let
params
=
Object
.
freeze
(
Object
.
assign
(
{
origin
:
aMessage
.
target
.
contentPrincipal
.
origin
}
aMessage
.
data
)
)
;
let
blockers
=
Array
.
from
(
this
.
peerConnectionBlockers
)
;
(
async
function
(
)
{
for
(
let
blocker
of
blockers
)
{
try
{
let
result
=
await
blocker
(
params
)
;
if
(
result
=
=
"
deny
"
)
{
return
false
;
}
}
catch
(
err
)
{
Cu
.
reportError
(
error
in
PeerConnection
blocker
:
{
err
.
message
}
)
;
}
}
return
true
;
}
)
(
)
.
then
(
decision
=
>
{
let
message
;
if
(
decision
)
{
this
.
emitter
.
emit
(
"
peer
-
request
-
allowed
"
params
)
;
message
=
"
rtcpeer
:
Allow
"
;
}
else
{
this
.
emitter
.
emit
(
"
peer
-
request
-
blocked
"
params
)
;
message
=
"
rtcpeer
:
Deny
"
;
}
aMessage
.
target
.
messageManager
.
sendAsyncMessage
(
message
{
callID
:
params
.
callID
windowID
:
params
.
windowID
}
)
;
}
)
;
break
;
}
case
"
rtcpeer
:
CancelRequest
"
:
{
let
params
=
Object
.
freeze
(
{
origin
:
aMessage
.
target
.
contentPrincipal
.
origin
callID
:
aMessage
.
data
}
)
;
this
.
emitter
.
emit
(
"
peer
-
request
-
cancel
"
params
)
;
break
;
}
case
"
webrtc
:
Request
"
:
if
(
aMessage
.
target
.
fxrPermissionPrompt
)
{
aMessage
.
target
.
fxrPermissionPrompt
(
aMessage
.
data
)
;
}
else
{
prompt
(
aMessage
.
target
aMessage
.
data
)
;
}
break
;
case
"
webrtc
:
StopRecording
"
:
stopRecording
(
aMessage
.
target
aMessage
.
data
)
;
break
;
case
"
webrtc
:
CancelRequest
"
:
removePrompt
(
aMessage
.
target
aMessage
.
data
)
;
break
;
case
"
webrtc
:
UpdatingIndicators
"
:
webrtcUI
.
forgetStreamsFromProcess
(
aMessage
.
target
)
;
break
;
case
"
webrtc
:
UpdateGlobalIndicators
"
:
updateIndicators
(
aMessage
.
data
aMessage
.
target
)
;
break
;
case
"
webrtc
:
UpdateBrowserIndicators
"
:
let
id
=
aMessage
.
data
.
windowId
;
let
processMM
=
aMessage
.
targetFrameLoader
.
messageManager
.
processMessageManager
;
let
index
;
for
(
index
=
0
;
index
<
webrtcUI
.
_streams
.
length
;
+
+
index
)
{
let
stream
=
webrtcUI
.
_streams
[
index
]
;
if
(
stream
.
state
.
windowId
=
=
id
&
&
stream
.
processMM
=
=
processMM
)
{
break
;
}
}
if
(
!
aMessage
.
data
.
documentURI
&
&
index
<
webrtcUI
.
_streams
.
length
)
{
webrtcUI
.
_streams
.
splice
(
index
1
)
;
}
else
{
webrtcUI
.
_streams
[
index
]
=
{
browser
:
aMessage
.
target
processMM
state
:
aMessage
.
data
}
;
}
let
tabbrowser
=
aMessage
.
target
.
ownerGlobal
.
gBrowser
;
if
(
tabbrowser
)
{
tabbrowser
.
updateBrowserSharing
(
aMessage
.
target
{
webRTC
:
aMessage
.
data
}
)
;
}
break
;
case
"
child
-
process
-
shutdown
"
:
webrtcUI
.
processIndicators
.
delete
(
aMessage
.
target
)
;
webrtcUI
.
forgetStreamsFromProcess
(
aMessage
.
target
)
;
updateIndicators
(
null
null
)
;
break
;
}
}
}
;
function
denyRequest
(
aBrowser
aRequest
)
{
aBrowser
.
messageManager
.
sendAsyncMessage
(
"
webrtc
:
Deny
"
{
callID
:
aRequest
.
callID
windowID
:
aRequest
.
windowID
}
)
;
}
function
denyRequestNoPermission
(
aBrowser
aRequest
)
{
aBrowser
.
messageManager
.
sendAsyncMessage
(
"
webrtc
:
Deny
"
{
callID
:
aRequest
.
callID
windowID
:
aRequest
.
windowID
noOSPermission
:
true
}
)
;
}
async
function
checkOSPermission
(
camNeeded
micNeeded
scrNeeded
)
{
if
(
!
scrNeeded
&
&
Services
.
prefs
.
getBoolPref
(
"
media
.
navigator
.
streams
.
fake
"
false
)
)
{
return
true
;
}
let
camStatus
=
{
}
micStatus
=
{
}
;
if
(
camNeeded
|
|
micNeeded
)
{
OSPermissions
.
getMediaCapturePermissionState
(
camStatus
micStatus
)
;
}
if
(
camNeeded
)
{
let
camPermission
=
camStatus
.
value
;
let
camAccessible
=
await
checkAndGetOSPermission
(
camPermission
OSPermissions
.
requestVideoCapturePermission
)
;
if
(
!
camAccessible
)
{
return
false
;
}
}
if
(
micNeeded
)
{
let
micPermission
=
micStatus
.
value
;
let
micAccessible
=
await
checkAndGetOSPermission
(
micPermission
OSPermissions
.
requestAudioCapturePermission
)
;
if
(
!
micAccessible
)
{
return
false
;
}
}
let
scrStatus
=
{
}
;
if
(
scrNeeded
)
{
OSPermissions
.
getScreenCapturePermissionState
(
scrStatus
)
;
if
(
scrStatus
.
value
=
=
OSPermissions
.
PERMISSION_STATE_DENIED
)
{
OSPermissions
.
maybeRequestScreenCapturePermission
(
)
;
return
false
;
}
}
return
true
;
}
async
function
checkAndGetOSPermission
(
devicePermission
requestPermissionFunc
)
{
if
(
devicePermission
=
=
OSPermissions
.
PERMISSION_STATE_DENIED
|
|
devicePermission
=
=
OSPermissions
.
PERMISSION_STATE_RESTRICTED
)
{
return
false
;
}
if
(
devicePermission
=
=
OSPermissions
.
PERMISSION_STATE_NOTDETERMINED
)
{
let
deviceAllowed
=
await
requestPermissionFunc
(
)
;
if
(
!
deviceAllowed
)
{
return
false
;
}
}
return
true
;
}
function
getHostOrExtensionName
(
uri
href
)
{
let
host
;
try
{
if
(
!
uri
)
{
uri
=
Services
.
io
.
newURI
(
href
)
;
}
let
addonPolicy
=
WebExtensionPolicy
.
getByURI
(
uri
)
;
host
=
addonPolicy
?
addonPolicy
.
name
:
uri
.
host
;
}
catch
(
ex
)
{
}
if
(
!
host
)
{
if
(
uri
&
&
uri
.
scheme
.
toLowerCase
(
)
=
=
"
about
"
)
{
host
=
uri
.
specIgnoringRef
;
}
else
{
const
kBundleURI
=
"
chrome
:
/
/
browser
/
locale
/
browser
.
properties
"
;
let
bundle
=
Services
.
strings
.
createBundle
(
kBundleURI
)
;
host
=
bundle
.
GetStringFromName
(
"
getUserMedia
.
sharingMenuUnknownHost
"
)
;
}
}
return
host
;
}
function
stopRecording
(
aBrowser
aRequest
)
{
let
outerWindowID
=
aBrowser
.
outerWindowID
;
if
(
!
webrtcUI
.
activePerms
.
has
(
outerWindowID
)
)
{
return
;
}
if
(
!
aRequest
.
rawID
)
{
webrtcUI
.
activePerms
.
delete
(
outerWindowID
)
;
}
else
{
let
set
=
webrtcUI
.
activePerms
.
get
(
outerWindowID
)
;
set
.
delete
(
aRequest
.
windowID
+
aRequest
.
mediaSource
+
aRequest
.
rawID
)
;
}
}
function
checkRequestAllowed
(
aRequest
aPrincipal
aBrowser
)
{
if
(
!
aRequest
.
secure
)
{
return
false
;
}
let
{
audioDevices
videoDevices
sharingScreen
}
=
aRequest
;
let
micAllowed
=
SitePermissions
.
getForPrincipal
(
aPrincipal
"
microphone
"
)
.
state
=
=
SitePermissions
.
ALLOW
;
let
camAllowed
=
SitePermissions
.
getForPrincipal
(
aPrincipal
"
camera
"
)
.
state
=
=
SitePermissions
.
ALLOW
;
let
perms
=
Services
.
perms
;
let
mediaManagerPerm
=
perms
.
testExactPermissionFromPrincipal
(
aPrincipal
"
MediaManagerVideo
"
)
;
if
(
mediaManagerPerm
)
{
perms
.
removeFromPrincipal
(
aPrincipal
"
MediaManagerVideo
"
)
;
}
if
(
videoDevices
.
length
&
&
sharingScreen
)
{
camAllowed
=
false
;
}
if
(
aRequest
.
isThirdPartyOrigin
&
&
!
aRequest
.
shouldDelegatePermission
)
{
camAllowed
=
false
;
micAllowed
=
false
;
}
let
activeCamera
;
let
activeMic
;
if
(
!
sharingScreen
)
{
for
(
let
device
of
videoDevices
)
{
let
set
=
webrtcUI
.
activePerms
.
get
(
aBrowser
.
outerWindowID
)
;
if
(
set
&
&
set
.
has
(
aRequest
.
windowID
+
device
.
mediaSource
+
device
.
id
)
)
{
activeCamera
=
device
;
break
;
}
}
for
(
let
device
of
audioDevices
)
{
let
set
=
webrtcUI
.
activePerms
.
get
(
aBrowser
.
outerWindowID
)
;
if
(
set
&
&
set
.
has
(
aRequest
.
windowID
+
device
.
mediaSource
+
device
.
id
)
)
{
activeMic
=
device
;
break
;
}
}
}
if
(
(
!
audioDevices
.
length
|
|
micAllowed
|
|
activeMic
)
&
&
(
!
videoDevices
.
length
|
|
camAllowed
|
|
activeCamera
)
)
{
let
allowedDevices
=
[
]
;
if
(
videoDevices
.
length
)
{
allowedDevices
.
push
(
(
activeCamera
|
|
videoDevices
[
0
]
)
.
deviceIndex
)
;
Services
.
perms
.
addFromPrincipal
(
aPrincipal
"
MediaManagerVideo
"
Services
.
perms
.
ALLOW_ACTION
Services
.
perms
.
EXPIRE_SESSION
)
;
}
if
(
audioDevices
.
length
)
{
allowedDevices
.
push
(
(
activeMic
|
|
audioDevices
[
0
]
)
.
deviceIndex
)
;
}
let
browser
=
aBrowser
;
browser
.
getDevicePermissionOrigins
(
"
webrtc
"
)
.
add
(
aPrincipal
.
origin
)
;
let
camNeeded
=
!
!
videoDevices
.
length
&
&
!
sharingScreen
;
let
scrNeeded
=
!
!
videoDevices
.
length
&
&
sharingScreen
;
let
micNeeded
=
!
!
audioDevices
.
length
;
checkOSPermission
(
camNeeded
micNeeded
scrNeeded
)
.
then
(
havePermission
=
>
{
if
(
havePermission
)
{
let
mm
=
browser
.
messageManager
;
mm
.
sendAsyncMessage
(
"
webrtc
:
Allow
"
{
callID
:
aRequest
.
callID
windowID
:
aRequest
.
windowID
devices
:
allowedDevices
}
)
;
}
else
{
denyRequestNoPermission
(
browser
aRequest
)
;
}
}
)
;
return
true
;
}
return
false
;
}
function
prompt
(
aBrowser
aRequest
)
{
let
{
audioDevices
videoDevices
sharingScreen
sharingAudio
requestTypes
}
=
aRequest
;
let
principal
=
Services
.
scriptSecurityManager
.
createContentPrincipalFromOrigin
(
aRequest
.
origin
)
;
if
(
principal
.
addonPolicy
)
{
let
isPopup
=
false
;
let
isBackground
=
false
;
for
(
let
view
of
principal
.
addonPolicy
.
extension
.
views
)
{
if
(
view
.
viewType
=
=
"
popup
"
&
&
view
.
xulBrowser
=
=
aBrowser
)
{
isPopup
=
true
;
}
if
(
view
.
viewType
=
=
"
background
"
&
&
view
.
xulBrowser
=
=
aBrowser
)
{
isBackground
=
true
;
}
}
if
(
isBackground
)
{
denyRequest
(
aBrowser
aRequest
)
;
return
;
}
if
(
isPopup
)
{
if
(
aRequest
.
secondOrigin
|
|
!
checkRequestAllowed
(
aRequest
principal
aBrowser
)
)
{
denyRequest
(
aBrowser
aRequest
)
;
}
return
;
}
}
if
(
(
audioDevices
.
length
&
&
SitePermissions
.
getForPrincipal
(
principal
"
microphone
"
aBrowser
)
.
state
=
=
SitePermissions
.
BLOCK
)
|
|
(
videoDevices
.
length
&
&
SitePermissions
.
getForPrincipal
(
principal
sharingScreen
?
"
screen
"
:
"
camera
"
aBrowser
)
.
state
=
=
SitePermissions
.
BLOCK
)
)
{
denyRequest
(
aBrowser
aRequest
)
;
return
;
}
aBrowser
.
dispatchEvent
(
new
aBrowser
.
ownerGlobal
.
CustomEvent
(
"
PermissionStateChange
"
)
)
;
let
chromeDoc
=
aBrowser
.
ownerDocument
;
let
stringBundle
=
chromeDoc
.
defaultView
.
gNavigatorBundle
;
let
joinedRequestTypes
=
requestTypes
.
join
(
"
And
"
)
;
let
requestMessages
;
if
(
aRequest
.
secondOrigin
)
{
requestMessages
=
[
"
getUserMedia
.
shareCameraUnsafeDelegation
.
message
"
"
getUserMedia
.
shareMicrophoneUnsafeDelegation
.
message
"
"
getUserMedia
.
shareScreenUnsafeDelegation
.
message
"
"
getUserMedia
.
shareAudioCaptureUnsafeDelegation
.
message
"
"
getUserMedia
.
shareCameraAndMicrophoneUnsafeDelegation
.
message
"
"
getUserMedia
.
shareCameraAndAudioCaptureUnsafeDelegation
.
message
"
"
getUserMedia
.
shareScreenAndMicrophoneUnsafeDelegation
.
message
"
"
getUserMedia
.
shareScreenAndAudioCaptureUnsafeDelegation
.
message
"
]
;
}
else
{
requestMessages
=
[
"
getUserMedia
.
shareCamera2
.
message
"
"
getUserMedia
.
shareMicrophone2
.
message
"
"
getUserMedia
.
shareScreen3
.
message
"
"
getUserMedia
.
shareAudioCapture2
.
message
"
"
getUserMedia
.
shareCameraAndMicrophone2
.
message
"
"
getUserMedia
.
shareCameraAndAudioCapture2
.
me
ssage
"
"
getUserMedia
.
shareScreenAndMicrophone3
.
message
"
"
getUserMedia
.
shareScreenAndAudioCapture3
.
message
"
]
;
}
let
stringId
=
requestMessages
.
find
(
id
=
>
id
.
includes
(
joinedRequestTypes
)
)
;
let
message
=
aRequest
.
secondOrigin
?
stringBundle
.
getFormattedString
(
stringId
[
"
<
>
"
"
{
}
"
]
)
:
stringBundle
.
getFormattedString
(
stringId
[
"
<
>
"
]
)
;
let
notification
;
let
mainAction
=
{
label
:
stringBundle
.
getString
(
"
getUserMedia
.
allow
.
label
"
)
accessKey
:
stringBundle
.
getString
(
"
getUserMedia
.
allow
.
accesskey
"
)
callback
(
)
{
}
}
;
let
secondaryActions
=
[
{
label
:
stringBundle
.
getString
(
"
getUserMedia
.
dontAllow
.
label
"
)
accessKey
:
stringBundle
.
getString
(
"
getUserMedia
.
dontAllow
.
accesskey
"
)
callback
(
aState
)
{
denyRequest
(
notification
.
browser
aRequest
)
;
let
scope
=
SitePermissions
.
SCOPE_TEMPORARY
;
if
(
aState
&
&
aState
.
checkboxChecked
)
{
scope
=
SitePermissions
.
SCOPE_PERSISTENT
;
}
if
(
audioDevices
.
length
)
{
SitePermissions
.
setForPrincipal
(
principal
"
microphone
"
SitePermissions
.
BLOCK
scope
notification
.
browser
)
;
}
if
(
videoDevices
.
length
)
{
SitePermissions
.
setForPrincipal
(
principal
sharingScreen
?
"
screen
"
:
"
camera
"
SitePermissions
.
BLOCK
scope
notification
.
browser
)
;
}
}
}
]
;
let
productName
=
gBrandBundle
.
GetStringFromName
(
"
brandShortName
"
)
;
let
options
=
{
name
:
getHostOrExtensionName
(
principal
.
URI
)
persistent
:
true
hideClose
:
true
eventCallback
(
aTopic
aNewBrowser
isCancel
)
{
if
(
aTopic
=
=
"
swapping
"
)
{
return
true
;
}
let
doc
=
this
.
browser
.
ownerDocument
;
if
(
(
(
aTopic
=
=
"
dismissed
"
|
|
aTopic
=
=
"
removed
"
)
&
&
requestTypes
.
includes
(
"
Screen
"
)
)
|
|
!
requestTypes
.
includes
(
"
Screen
"
)
)
{
let
video
=
doc
.
getElementById
(
"
webRTC
-
previewVideo
"
)
;
if
(
video
.
stream
)
{
video
.
stream
.
getTracks
(
)
.
forEach
(
t
=
>
t
.
stop
(
)
)
;
video
.
stream
=
null
;
video
.
src
=
null
;
doc
.
getElementById
(
"
webRTC
-
preview
"
)
.
hidden
=
true
;
}
let
menupopup
=
doc
.
getElementById
(
"
webRTC
-
selectWindow
-
menupopup
"
)
;
if
(
menupopup
.
_commandEventListener
)
{
menupopup
.
removeEventListener
(
"
command
"
menupopup
.
_commandEventListener
)
;
menupopup
.
_commandEventListener
=
null
;
}
}
if
(
aTopic
=
=
"
removed
"
&
&
notification
&
&
isCancel
)
{
denyRequest
(
notification
.
browser
aRequest
)
;
}
if
(
aTopic
!
=
"
showing
"
)
{
return
false
;
}
if
(
!
aRequest
.
secondOrigin
&
&
checkRequestAllowed
(
aRequest
principal
aBrowser
)
)
{
this
.
remove
(
)
;
return
true
;
}
function
listDevices
(
menupopup
devices
)
{
while
(
menupopup
.
lastChild
)
{
menupopup
.
removeChild
(
menupopup
.
lastChild
)
;
}
menupopup
.
parentNode
.
removeAttribute
(
"
value
"
)
;
menupopup
.
parentNode
.
selectedItem
=
null
;
for
(
let
device
of
devices
)
{
addDeviceToList
(
menupopup
device
.
name
device
.
deviceIndex
)
;
}
}
function
checkDisabledWindowMenuItem
(
)
{
let
list
=
doc
.
getElementById
(
"
webRTC
-
selectWindow
-
menulist
"
)
;
let
item
=
list
.
selectedItem
;
let
notificationElement
=
doc
.
getElementById
(
"
webRTC
-
shareDevices
-
notification
"
)
;
if
(
!
item
|
|
item
.
hasAttribute
(
"
disabled
"
)
)
{
notificationElement
.
setAttribute
(
"
invalidselection
"
"
true
"
)
;
}
else
{
notificationElement
.
removeAttribute
(
"
invalidselection
"
)
;
}
}
function
listScreenShareDevices
(
menupopup
devices
)
{
while
(
menupopup
.
lastChild
)
{
menupopup
.
removeChild
(
menupopup
.
lastChild
)
;
}
menupopup
.
parentNode
.
removeAttribute
(
"
value
"
)
;
menupopup
.
parentNode
.
selectedItem
=
null
;
let
label
=
doc
.
getElementById
(
"
webRTC
-
selectWindow
-
label
"
)
;
const
gumStringId
=
"
getUserMedia
.
selectWindowOrScreen
"
;
label
.
setAttribute
(
"
value
"
stringBundle
.
getString
(
gumStringId
+
"
.
label
"
)
)
;
label
.
setAttribute
(
"
accesskey
"
stringBundle
.
getString
(
gumStringId
+
"
.
accesskey
"
)
)
;
addDeviceToList
(
menupopup
stringBundle
.
getString
(
"
getUserMedia
.
pickWindowOrScreen
.
label
"
)
"
-
1
"
)
;
menupopup
.
appendChild
(
doc
.
createXULElement
(
"
menuseparator
"
)
)
;
let
monitorIndex
=
1
;
for
(
let
i
=
0
;
i
<
devices
.
length
;
+
+
i
)
{
let
device
=
devices
[
i
]
;
let
type
=
device
.
mediaSource
;
let
name
;
if
(
type
=
=
"
screen
"
)
{
if
(
device
.
name
=
=
"
Primary
Monitor
"
)
{
name
=
stringBundle
.
getString
(
"
getUserMedia
.
shareEntireScreen
.
label
"
)
;
}
else
{
name
=
stringBundle
.
getFormattedString
(
"
getUserMedia
.
shareMonitor
.
label
"
[
monitorIndex
]
)
;
+
+
monitorIndex
;
}
}
else
{
name
=
device
.
name
;
if
(
type
=
=
"
application
"
)
{
let
sepIndex
=
name
.
indexOf
(
"
\
x1e
"
)
;
let
count
=
name
.
slice
(
0
sepIndex
)
;
let
sawcStringId
=
"
getUserMedia
.
shareApplicationWindowCount
.
label
"
;
name
=
PluralForm
.
get
(
parseInt
(
count
)
stringBundle
.
getString
(
sawcStringId
)
)
.
replace
(
"
#
1
"
name
.
slice
(
sepIndex
+
1
)
)
.
replace
(
"
#
2
"
count
)
;
}
}
let
item
=
addDeviceToList
(
menupopup
name
i
type
)
;
item
.
deviceId
=
device
.
id
;
item
.
mediaSource
=
type
;
if
(
device
.
scary
)
{
item
.
scary
=
true
;
}
}
doc
.
getElementById
(
"
webRTC
-
selectWindow
-
menulist
"
)
.
removeAttribute
(
"
value
"
)
;
doc
.
getElementById
(
"
webRTC
-
all
-
windows
-
shared
"
)
.
hidden
=
true
;
menupopup
.
_commandEventListener
=
event
=
>
{
checkDisabledWindowMenuItem
(
)
;
let
video
=
doc
.
getElementById
(
"
webRTC
-
previewVideo
"
)
;
if
(
video
.
stream
)
{
video
.
stream
.
getTracks
(
)
.
forEach
(
t
=
>
t
.
stop
(
)
)
;
video
.
stream
=
null
;
}
let
type
=
event
.
target
.
mediaSource
;
let
deviceId
=
event
.
target
.
deviceId
;
if
(
deviceId
=
=
undefined
)
{
doc
.
getElementById
(
"
webRTC
-
preview
"
)
.
hidden
=
true
;
video
.
src
=
null
;
return
;
}
let
scary
=
event
.
target
.
scary
;
let
warning
=
doc
.
getElementById
(
"
webRTC
-
previewWarning
"
)
;
warning
.
hidden
=
!
scary
;
let
chromeWin
=
doc
.
defaultView
;
if
(
scary
)
{
warning
.
hidden
=
false
;
let
string
;
let
bundle
=
chromeWin
.
gNavigatorBundle
;
let
learnMoreText
=
bundle
.
getString
(
"
getUserMedia
.
shareScreen
.
learnMoreLabel
"
)
;
let
baseURL
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
;
let
learnMore
=
chromeWin
.
document
.
createXULElement
(
"
label
"
{
is
:
"
text
-
link
"
}
)
;
learnMore
.
setAttribute
(
"
href
"
baseURL
+
"
screenshare
-
safety
"
)
;
learnMore
.
textContent
=
learnMoreText
;
if
(
type
=
=
"
screen
"
)
{
string
=
bundle
.
getFormattedString
(
"
getUserMedia
.
shareScreenWarning
.
message
"
[
"
<
>
"
]
)
;
}
else
{
let
brand
=
doc
.
getElementById
(
"
bundle_brand
"
)
.
getString
(
"
brandShortName
"
)
;
string
=
bundle
.
getFormattedString
(
"
getUserMedia
.
shareFirefoxWarning
.
message
"
[
brand
"
<
>
"
]
)
;
}
let
[
pre
post
]
=
string
.
split
(
"
<
>
"
)
;
warning
.
textContent
=
pre
;
warning
.
appendChild
(
learnMore
)
;
warning
.
appendChild
(
chromeWin
.
document
.
createTextNode
(
post
)
)
;
let
scrStatus
=
{
}
;
OSPermissions
.
getScreenCapturePermissionState
(
scrStatus
)
;
if
(
scrStatus
.
value
=
=
OSPermissions
.
PERMISSION_STATE_DENIED
)
{
OSPermissions
.
maybeRequestScreenCapturePermission
(
)
;
}
}
let
perms
=
Services
.
perms
;
let
chromePrincipal
=
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
;
perms
.
addFromPrincipal
(
chromePrincipal
"
MediaManagerVideo
"
perms
.
ALLOW_ACTION
perms
.
EXPIRE_SESSION
)
;
video
.
deviceId
=
deviceId
;
let
constraints
=
{
video
:
{
mediaSource
:
type
deviceId
:
{
exact
:
deviceId
}
}
}
;
chromeWin
.
navigator
.
mediaDevices
.
getUserMedia
(
constraints
)
.
then
(
stream
=
>
{
if
(
video
.
deviceId
!
=
deviceId
)
{
stream
.
getTracks
(
)
.
forEach
(
t
=
>
t
.
stop
(
)
)
;
return
;
}
video
.
srcObject
=
stream
;
video
.
stream
=
stream
;
doc
.
getElementById
(
"
webRTC
-
preview
"
)
.
hidden
=
false
;
video
.
onloadedmetadata
=
function
(
e
)
{
video
.
play
(
)
;
}
;
}
err
=
>
{
if
(
err
.
name
=
=
"
OverconstrainedError
"
&
&
err
.
constraint
=
=
"
deviceId
"
)
{
return
;
}
Cu
.
reportError
(
error
in
preview
:
{
err
.
message
}
{
err
.
constraint
}
)
;
}
)
;
}
;
menupopup
.
addEventListener
(
"
command
"
menupopup
.
_commandEventListener
)
;
}
function
addDeviceToList
(
menupopup
deviceName
deviceIndex
type
)
{
let
menuitem
=
doc
.
createXULElement
(
"
menuitem
"
)
;
menuitem
.
setAttribute
(
"
value
"
deviceIndex
)
;
menuitem
.
setAttribute
(
"
label
"
deviceName
)
;
menuitem
.
setAttribute
(
"
tooltiptext
"
deviceName
)
;
if
(
type
)
{
menuitem
.
setAttribute
(
"
devicetype
"
type
)
;
}
if
(
deviceIndex
=
=
"
-
1
"
)
{
menuitem
.
setAttribute
(
"
disabled
"
true
)
;
}
menupopup
.
appendChild
(
menuitem
)
;
return
menuitem
;
}
doc
.
getElementById
(
"
webRTC
-
selectCamera
"
)
.
hidden
=
!
videoDevices
.
length
|
|
sharingScreen
;
doc
.
getElementById
(
"
webRTC
-
selectWindowOrScreen
"
)
.
hidden
=
!
sharingScreen
|
|
!
videoDevices
.
length
;
doc
.
getElementById
(
"
webRTC
-
selectMicrophone
"
)
.
hidden
=
!
audioDevices
.
length
|
|
sharingAudio
;
let
camMenupopup
=
doc
.
getElementById
(
"
webRTC
-
selectCamera
-
menupopup
"
)
;
let
windowMenupopup
=
doc
.
getElementById
(
"
webRTC
-
selectWindow
-
menupopup
"
)
;
let
micMenupopup
=
doc
.
getElementById
(
"
webRTC
-
selectMicrophone
-
menupopup
"
)
;
if
(
sharingScreen
)
{
listScreenShareDevices
(
windowMenupopup
videoDevices
)
;
checkDisabledWindowMenuItem
(
)
;
}
else
{
listDevices
(
camMenupopup
videoDevices
)
;
doc
.
getElementById
(
"
webRTC
-
shareDevices
-
notification
"
)
.
removeAttribute
(
"
invalidselection
"
)
;
}
if
(
!
sharingAudio
)
{
listDevices
(
micMenupopup
audioDevices
)
;
}
this
.
mainAction
.
callback
=
async
function
(
aState
)
{
let
remember
=
aState
&
&
aState
.
checkboxChecked
;
let
allowedDevices
=
[
]
;
let
perms
=
Services
.
perms
;
if
(
videoDevices
.
length
)
{
let
listId
=
"
webRTC
-
select
"
+
(
sharingScreen
?
"
Window
"
:
"
Camera
"
)
+
"
-
menulist
"
;
let
videoDeviceIndex
=
doc
.
getElementById
(
listId
)
.
value
;
let
allowVideoDevice
=
videoDeviceIndex
!
=
"
-
1
"
;
if
(
allowVideoDevice
)
{
allowedDevices
.
push
(
videoDeviceIndex
)
;
perms
.
addFromPrincipal
(
principal
"
MediaManagerVideo
"
perms
.
ALLOW_ACTION
perms
.
EXPIRE_SESSION
)
;
if
(
!
webrtcUI
.
activePerms
.
has
(
aBrowser
.
outerWindowID
)
)
{
webrtcUI
.
activePerms
.
set
(
aBrowser
.
outerWindowID
new
Set
(
)
)
;
}
for
(
let
device
of
videoDevices
)
{
if
(
device
.
deviceIndex
=
=
videoDeviceIndex
)
{
webrtcUI
.
activePerms
.
get
(
aBrowser
.
outerWindowID
)
.
add
(
aRequest
.
windowID
+
device
.
mediaSource
+
device
.
id
)
;
break
;
}
}
if
(
remember
)
{
SitePermissions
.
setForPrincipal
(
principal
"
camera
"
SitePermissions
.
ALLOW
)
;
}
}
}
if
(
audioDevices
.
length
)
{
if
(
!
sharingAudio
)
{
let
audioDeviceIndex
=
doc
.
getElementById
(
"
webRTC
-
selectMicrophone
-
menulist
"
)
.
value
;
let
allowMic
=
audioDeviceIndex
!
=
"
-
1
"
;
if
(
allowMic
)
{
allowedDevices
.
push
(
audioDeviceIndex
)
;
if
(
!
webrtcUI
.
activePerms
.
has
(
aBrowser
.
outerWindowID
)
)
{
webrtcUI
.
activePerms
.
set
(
aBrowser
.
outerWindowID
new
Set
(
)
)
;
}
for
(
let
device
of
audioDevices
)
{
if
(
device
.
deviceIndex
=
=
audioDeviceIndex
)
{
webrtcUI
.
activePerms
.
get
(
aBrowser
.
outerWindowID
)
.
add
(
aRequest
.
windowID
+
device
.
mediaSource
+
device
.
id
)
;
break
;
}
}
if
(
remember
)
{
SitePermissions
.
setForPrincipal
(
principal
"
microphone
"
SitePermissions
.
ALLOW
)
;
}
}
}
else
{
allowedDevices
.
push
(
0
)
;
}
}
if
(
!
allowedDevices
.
length
)
{
denyRequest
(
notification
.
browser
aRequest
)
;
return
;
}
if
(
remember
)
{
aBrowser
.
getDevicePermissionOrigins
(
"
webrtc
"
)
.
add
(
principal
.
origin
)
;
}
let
camNeeded
=
!
!
videoDevices
.
length
&
&
!
sharingScreen
;
let
scrNeeded
=
!
!
videoDevices
.
length
&
&
sharingScreen
;
let
micNeeded
=
!
!
audioDevices
.
length
;
let
havePermission
=
await
checkOSPermission
(
camNeeded
micNeeded
scrNeeded
)
;
if
(
!
havePermission
)
{
denyRequestNoPermission
(
notification
.
browser
aRequest
)
;
return
;
}
let
mm
=
notification
.
browser
.
messageManager
;
mm
.
sendAsyncMessage
(
"
webrtc
:
Allow
"
{
callID
:
aRequest
.
callID
windowID
:
aRequest
.
windowID
devices
:
allowedDevices
}
)
;
}
;
return
false
;
}
}
;
function
shouldShowAlwaysRemember
(
)
{
if
(
PrivateBrowsingUtils
.
isBrowserPrivate
(
aBrowser
)
)
{
return
false
;
}
if
(
aRequest
.
isThirdPartyOrigin
&
&
!
aRequest
.
shouldDelegatePermission
)
{
return
false
;
}
if
(
aRequest
.
shouldDelegatePermission
&
&
aRequest
.
secondOrigin
)
{
return
false
;
}
return
true
;
}
if
(
shouldShowAlwaysRemember
(
)
)
{
let
reasonForNoPermanentAllow
=
"
"
;
if
(
sharingScreen
)
{
reasonForNoPermanentAllow
=
"
getUserMedia
.
reasonForNoPermanentAllow
.
screen3
"
;
}
else
if
(
sharingAudio
)
{
reasonForNoPermanentAllow
=
"
getUserMedia
.
reasonForNoPermanentAllow
.
audio
"
;
}
else
if
(
!
aRequest
.
secure
)
{
reasonForNoPermanentAllow
=
"
getUserMedia
.
reasonForNoPermanentAllow
.
insecure
"
;
}
options
.
checkbox
=
{
label
:
stringBundle
.
getString
(
"
getUserMedia
.
remember
"
)
checked
:
principal
.
isAddonOrExpandedAddonPrincipal
checkedState
:
reasonForNoPermanentAllow
?
{
disableMainAction
:
true
warningLabel
:
stringBundle
.
getFormattedString
(
reasonForNoPermanentAllow
[
productName
]
)
}
:
undefined
}
;
}
let
iconType
=
"
Devices
"
;
if
(
requestTypes
.
length
=
=
1
&
&
(
requestTypes
[
0
]
=
=
"
Microphone
"
|
|
requestTypes
[
0
]
=
=
"
AudioCapture
"
)
)
{
iconType
=
"
Microphone
"
;
}
if
(
requestTypes
.
includes
(
"
Screen
"
)
)
{
iconType
=
"
Screen
"
;
}
let
anchorId
=
"
webRTC
-
share
"
+
iconType
+
"
-
notification
-
icon
"
;
let
iconClass
=
iconType
.
toLowerCase
(
)
;
if
(
iconClass
=
=
"
devices
"
)
{
iconClass
=
"
camera
"
;
}
options
.
popupIconClass
=
iconClass
+
"
-
icon
"
;
if
(
aRequest
.
secondOrigin
)
{
options
.
secondName
=
getHostOrExtensionName
(
null
aRequest
.
secondOrigin
)
;
}
notification
=
chromeDoc
.
defaultView
.
PopupNotifications
.
show
(
aBrowser
"
webRTC
-
shareDevices
"
message
anchorId
mainAction
secondaryActions
options
)
;
notification
.
callID
=
aRequest
.
callID
;
let
schemeHistogram
=
Services
.
telemetry
.
getKeyedHistogramById
(
"
PERMISSION_REQUEST_ORIGIN_SCHEME
"
)
;
let
userInputHistogram
=
Services
.
telemetry
.
getKeyedHistogramById
(
"
PERMISSION_REQUEST_HANDLING_USER_INPUT
"
)
;
let
docURI
=
aRequest
.
documentURI
;
let
scheme
=
0
;
if
(
docURI
.
startsWith
(
"
https
"
)
)
{
scheme
=
2
;
}
else
if
(
docURI
.
startsWith
(
"
http
"
)
)
{
scheme
=
1
;
}
for
(
let
requestType
of
requestTypes
)
{
if
(
requestType
=
=
"
AudioCapture
"
)
{
requestType
=
"
Microphone
"
;
}
requestType
=
requestType
.
toLowerCase
(
)
;
schemeHistogram
.
add
(
requestType
scheme
)
;
userInputHistogram
.
add
(
requestType
aRequest
.
isHandlingUserInput
)
;
}
}
function
removePrompt
(
aBrowser
aCallId
)
{
let
chromeWin
=
aBrowser
.
ownerGlobal
;
let
notification
=
chromeWin
.
PopupNotifications
.
getNotification
(
"
webRTC
-
shareDevices
"
aBrowser
)
;
if
(
notification
&
&
notification
.
callID
=
=
aCallId
)
{
notification
.
remove
(
)
;
}
}
function
getGlobalIndicator
(
)
{
if
(
AppConstants
.
platform
!
=
"
macosx
"
)
{
const
INDICATOR_CHROME_URI
=
"
chrome
:
/
/
browser
/
content
/
webrtcIndicator
.
xhtml
"
;
const
features
=
"
chrome
dialog
=
yes
titlebar
=
no
popup
=
yes
"
;
return
Services
.
ww
.
openWindow
(
null
INDICATOR_CHROME_URI
"
_blank
"
features
[
]
)
;
}
let
indicator
=
{
_camera
:
null
_microphone
:
null
_screen
:
null
_hiddenDoc
:
Services
.
appShell
.
hiddenDOMWindow
.
document
_statusBar
:
Cc
[
"
mozilla
.
org
/
widget
/
macsystemstatusbar
;
1
"
]
.
getService
(
Ci
.
nsISystemStatusBar
)
_command
(
aEvent
)
{
webrtcUI
.
showSharingDoorhanger
(
aEvent
.
target
.
stream
)
;
}
_popupShowing
(
aEvent
)
{
let
type
=
this
.
getAttribute
(
"
type
"
)
;
let
activeStreams
;
if
(
type
=
=
"
Camera
"
)
{
activeStreams
=
webrtcUI
.
getActiveStreams
(
true
false
false
)
;
}
else
if
(
type
=
=
"
Microphone
"
)
{
activeStreams
=
webrtcUI
.
getActiveStreams
(
false
true
false
)
;
}
else
if
(
type
=
=
"
Screen
"
)
{
activeStreams
=
webrtcUI
.
getActiveStreams
(
false
false
true
)
;
type
=
webrtcUI
.
showScreenSharingIndicator
;
}
let
bundle
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
browser
/
locale
/
webrtcIndicator
.
properties
"
)
;
if
(
activeStreams
.
length
=
=
1
)
{
let
stream
=
activeStreams
[
0
]
;
let
menuitem
=
this
.
ownerDocument
.
createXULElement
(
"
menuitem
"
)
;
let
labelId
=
"
webrtcIndicator
.
sharing
"
+
type
+
"
With
.
menuitem
"
;
let
label
=
stream
.
browser
.
contentTitle
|
|
stream
.
uri
;
menuitem
.
setAttribute
(
"
label
"
bundle
.
formatStringFromName
(
labelId
[
label
]
)
)
;
menuitem
.
setAttribute
(
"
disabled
"
"
true
"
)
;
this
.
appendChild
(
menuitem
)
;
menuitem
=
this
.
ownerDocument
.
createXULElement
(
"
menuitem
"
)
;
menuitem
.
setAttribute
(
"
label
"
bundle
.
GetStringFromName
(
"
webrtcIndicator
.
controlSharing
.
menuitem
"
)
)
;
menuitem
.
stream
=
stream
;
menuitem
.
addEventListener
(
"
command
"
indicator
.
_command
)
;
this
.
appendChild
(
menuitem
)
;
return
true
;
}
let
menuitem
=
this
.
ownerDocument
.
createXULElement
(
"
menuitem
"
)
;
let
labelId
=
"
webrtcIndicator
.
sharing
"
+
type
+
"
WithNTabs
.
menuitem
"
;
let
count
=
activeStreams
.
length
;
let
label
=
PluralForm
.
get
(
count
bundle
.
GetStringFromName
(
labelId
)
)
.
replace
(
"
#
1
"
count
)
;
menuitem
.
setAttribute
(
"
label
"
label
)
;
menuitem
.
setAttribute
(
"
disabled
"
"
true
"
)
;
this
.
appendChild
(
menuitem
)
;
for
(
let
stream
of
activeStreams
)
{
let
item
=
this
.
ownerDocument
.
createXULElement
(
"
menuitem
"
)
;
labelId
=
"
webrtcIndicator
.
controlSharingOn
.
menuitem
"
;
label
=
stream
.
browser
.
contentTitle
|
|
stream
.
uri
;
item
.
setAttribute
(
"
label
"
bundle
.
formatStringFromName
(
labelId
[
label
]
)
)
;
item
.
stream
=
stream
;
item
.
addEventListener
(
"
command
"
indicator
.
_command
)
;
this
.
appendChild
(
item
)
;
}
return
true
;
}
_popupHiding
(
aEvent
)
{
while
(
this
.
firstChild
)
{
this
.
firstChild
.
remove
(
)
;
}
}
_setIndicatorState
(
aName
aState
)
{
let
field
=
"
_
"
+
aName
.
toLowerCase
(
)
;
if
(
aState
&
&
!
this
[
field
]
)
{
let
menu
=
this
.
_hiddenDoc
.
createXULElement
(
"
menu
"
)
;
menu
.
setAttribute
(
"
id
"
"
webRTC
-
sharing
"
+
aName
+
"
-
menu
"
)
;
this
.
_hiddenDoc
.
documentElement
.
appendChild
(
menu
)
;
this
.
_statusBar
.
addItem
(
menu
)
;
let
menupopup
=
this
.
_hiddenDoc
.
createXULElement
(
"
menupopup
"
)
;
menupopup
.
setAttribute
(
"
type
"
aName
)
;
menupopup
.
addEventListener
(
"
popupshowing
"
this
.
_popupShowing
)
;
menupopup
.
addEventListener
(
"
popuphiding
"
this
.
_popupHiding
)
;
menupopup
.
addEventListener
(
"
command
"
this
.
_command
)
;
menu
.
appendChild
(
menupopup
)
;
this
[
field
]
=
menu
;
}
else
if
(
this
[
field
]
&
&
!
aState
)
{
this
.
_statusBar
.
removeItem
(
this
[
field
]
)
;
this
[
field
]
.
remove
(
)
;
this
[
field
]
=
null
;
}
}
updateIndicatorState
(
)
{
this
.
_setIndicatorState
(
"
Camera
"
webrtcUI
.
showCameraIndicator
)
;
this
.
_setIndicatorState
(
"
Microphone
"
webrtcUI
.
showMicrophoneIndicator
)
;
this
.
_setIndicatorState
(
"
Screen
"
webrtcUI
.
showScreenSharingIndicator
)
;
}
close
(
)
{
this
.
_setIndicatorState
(
"
Camera
"
false
)
;
this
.
_setIndicatorState
(
"
Microphone
"
false
)
;
this
.
_setIndicatorState
(
"
Screen
"
false
)
;
}
}
;
indicator
.
updateIndicatorState
(
)
;
return
indicator
;
}
function
onTabSharingMenuPopupShowing
(
e
)
{
let
streams
=
webrtcUI
.
getActiveStreams
(
true
true
true
)
;
for
(
let
streamInfo
of
streams
)
{
let
stringName
=
"
getUserMedia
.
sharingMenu
"
;
let
types
=
streamInfo
.
types
;
if
(
types
.
camera
)
{
stringName
+
=
"
Camera
"
;
}
if
(
types
.
microphone
)
{
stringName
+
=
"
Microphone
"
;
}
if
(
types
.
screen
)
{
stringName
+
=
types
.
screen
;
}
let
doc
=
e
.
target
.
ownerDocument
;
let
bundle
=
doc
.
defaultView
.
gNavigatorBundle
;
let
origin
=
getHostOrExtensionName
(
null
streamInfo
.
uri
)
;
let
menuitem
=
doc
.
createXULElement
(
"
menuitem
"
)
;
menuitem
.
setAttribute
(
"
label
"
bundle
.
getFormattedString
(
stringName
[
origin
]
)
)
;
menuitem
.
stream
=
streamInfo
;
menuitem
.
addEventListener
(
"
command
"
onTabSharingMenuPopupCommand
)
;
e
.
target
.
appendChild
(
menuitem
)
;
}
}
function
onTabSharingMenuPopupHiding
(
e
)
{
while
(
this
.
lastChild
)
{
this
.
lastChild
.
remove
(
)
;
}
}
function
onTabSharingMenuPopupCommand
(
e
)
{
webrtcUI
.
showSharingDoorhanger
(
e
.
target
.
stream
)
;
}
function
showOrCreateMenuForWindow
(
aWindow
)
{
let
document
=
aWindow
.
document
;
let
menu
=
document
.
getElementById
(
"
tabSharingMenu
"
)
;
if
(
!
menu
)
{
let
stringBundle
=
aWindow
.
gNavigatorBundle
;
menu
=
document
.
createXULElement
(
"
menu
"
)
;
menu
.
id
=
"
tabSharingMenu
"
;
let
labelStringId
=
"
getUserMedia
.
sharingMenu
.
label
"
;
menu
.
setAttribute
(
"
label
"
stringBundle
.
getString
(
labelStringId
)
)
;
let
container
insertionPoint
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
container
=
document
.
getElementById
(
"
windowPopup
"
)
;
insertionPoint
=
document
.
getElementById
(
"
sep
-
window
-
list
"
)
;
let
separator
=
document
.
createXULElement
(
"
menuseparator
"
)
;
separator
.
id
=
"
tabSharingSeparator
"
;
container
.
insertBefore
(
separator
insertionPoint
)
;
}
else
{
let
accesskeyStringId
=
"
getUserMedia
.
sharingMenu
.
accesskey
"
;
menu
.
setAttribute
(
"
accesskey
"
stringBundle
.
getString
(
accesskeyStringId
)
)
;
container
=
document
.
getElementById
(
"
main
-
menubar
"
)
;
insertionPoint
=
document
.
getElementById
(
"
helpMenu
"
)
;
}
let
popup
=
document
.
createXULElement
(
"
menupopup
"
)
;
popup
.
id
=
"
tabSharingMenuPopup
"
;
popup
.
addEventListener
(
"
popupshowing
"
onTabSharingMenuPopupShowing
)
;
popup
.
addEventListener
(
"
popuphiding
"
onTabSharingMenuPopupHiding
)
;
menu
.
appendChild
(
popup
)
;
container
.
insertBefore
(
menu
insertionPoint
)
;
}
else
{
menu
.
hidden
=
false
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
document
.
getElementById
(
"
tabSharingSeparator
"
)
.
hidden
=
false
;
}
}
}
function
maybeAddMenuIndicator
(
window
)
{
if
(
webrtcUI
.
showGlobalIndicator
)
{
showOrCreateMenuForWindow
(
window
)
;
}
}
var
gIndicatorWindow
=
null
;
function
updateIndicators
(
data
target
)
{
if
(
data
)
{
let
indicators
;
if
(
webrtcUI
.
processIndicators
.
has
(
target
)
)
{
indicators
=
webrtcUI
.
processIndicators
.
get
(
target
)
;
}
else
{
indicators
=
{
}
;
webrtcUI
.
processIndicators
.
set
(
target
indicators
)
;
}
indicators
.
showGlobalIndicator
=
data
.
showGlobalIndicator
;
indicators
.
showCameraIndicator
=
data
.
showCameraIndicator
;
indicators
.
showMicrophoneIndicator
=
data
.
showMicrophoneIndicator
;
indicators
.
showScreenSharingIndicator
=
data
.
showScreenSharingIndicator
;
}
for
(
let
chromeWin
of
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
)
{
if
(
webrtcUI
.
showGlobalIndicator
)
{
showOrCreateMenuForWindow
(
chromeWin
)
;
}
else
{
let
doc
=
chromeWin
.
document
;
let
existingMenu
=
doc
.
getElementById
(
"
tabSharingMenu
"
)
;
if
(
existingMenu
)
{
existingMenu
.
hidden
=
true
;
}
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
let
separator
=
doc
.
getElementById
(
"
tabSharingSeparator
"
)
;
if
(
separator
)
{
separator
.
hidden
=
true
;
}
}
}
}
if
(
webrtcUI
.
showGlobalIndicator
)
{
if
(
!
gIndicatorWindow
)
{
gIndicatorWindow
=
getGlobalIndicator
(
)
;
}
else
{
try
{
gIndicatorWindow
.
updateIndicatorState
(
)
;
}
catch
(
err
)
{
Cu
.
reportError
(
error
in
gIndicatorWindow
.
updateIndicatorState
(
)
:
{
err
.
message
}
)
;
}
}
}
else
if
(
gIndicatorWindow
)
{
gIndicatorWindow
.
close
(
)
;
gIndicatorWindow
=
null
;
}
}
