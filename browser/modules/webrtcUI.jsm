"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
webrtcUI
"
"
showStreamSharingMenu
"
"
MacOSWebRTCStatusbarIndicator
"
]
;
const
{
EventEmitter
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
/
modules
/
syncedtabs
/
EventEmitter
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
{
AppConstants
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
sys
.
mjs
"
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
BrowserWindowTracker
"
"
resource
:
/
/
/
modules
/
BrowserWindowTracker
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
SitePermissions
"
"
resource
:
/
/
/
modules
/
SitePermissions
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
syncL10n
"
(
)
=
>
new
Localization
(
[
"
browser
/
webrtcIndicator
.
ftl
"
]
true
)
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
listFormat
"
(
)
=
>
new
Services
.
intl
.
ListFormat
(
undefined
)
)
;
const
SHARING_L10NID_BY_TYPE
=
new
Map
(
[
[
"
Camera
"
[
"
webrtc
-
indicator
-
menuitem
-
sharing
-
camera
-
with
"
"
webrtc
-
indicator
-
menuitem
-
sharing
-
camera
-
with
-
n
-
tabs
"
]
]
[
"
Microphone
"
[
"
webrtc
-
indicator
-
menuitem
-
sharing
-
microphone
-
with
"
"
webrtc
-
indicator
-
menuitem
-
sharing
-
microphone
-
with
-
n
-
tabs
"
]
]
[
"
Application
"
[
"
webrtc
-
indicator
-
menuitem
-
sharing
-
application
-
with
"
"
webrtc
-
indicator
-
menuitem
-
sharing
-
application
-
with
-
n
-
tabs
"
]
]
[
"
Screen
"
[
"
webrtc
-
indicator
-
menuitem
-
sharing
-
screen
-
with
"
"
webrtc
-
indicator
-
menuitem
-
sharing
-
screen
-
with
-
n
-
tabs
"
]
]
[
"
Window
"
[
"
webrtc
-
indicator
-
menuitem
-
sharing
-
window
-
with
"
"
webrtc
-
indicator
-
menuitem
-
sharing
-
window
-
with
-
n
-
tabs
"
]
]
[
"
Browser
"
[
"
webrtc
-
indicator
-
menuitem
-
sharing
-
browser
-
with
"
"
webrtc
-
indicator
-
menuitem
-
sharing
-
browser
-
with
-
n
-
tabs
"
]
]
]
)
;
const
MEDIA_SOURCE_L10NID_BY_TYPE
=
new
Map
(
[
[
"
camera
"
"
webrtc
-
item
-
camera
"
]
[
"
screen
"
"
webrtc
-
item
-
screen
"
]
[
"
application
"
"
webrtc
-
item
-
application
"
]
[
"
window
"
"
webrtc
-
item
-
window
"
]
[
"
browser
"
"
webrtc
-
item
-
browser
"
]
[
"
microphone
"
"
webrtc
-
item
-
microphone
"
]
[
"
audioCapture
"
"
webrtc
-
item
-
audio
-
capture
"
]
]
)
;
var
webrtcUI
=
{
initialized
:
false
peerConnectionBlockers
:
new
Set
(
)
emitter
:
new
EventEmitter
(
)
init
(
)
{
if
(
!
this
.
initialized
)
{
Services
.
obs
.
addObserver
(
this
"
browser
-
delayed
-
startup
-
finished
"
)
;
this
.
initialized
=
true
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
useLegacyGlobalIndicator
"
"
privacy
.
webrtc
.
legacyGlobalIndicator
"
true
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
deviceGracePeriodTimeoutMs
"
"
privacy
.
webrtc
.
deviceGracePeriodTimeoutMs
"
)
;
Services
.
telemetry
.
setEventRecordingEnabled
(
"
webrtc
.
ui
"
true
)
;
}
}
uninit
(
)
{
if
(
this
.
initialized
)
{
Services
.
obs
.
removeObserver
(
this
"
browser
-
delayed
-
startup
-
finished
"
)
;
this
.
initialized
=
false
;
}
}
observe
(
subject
topic
data
)
{
if
(
topic
=
=
"
browser
-
delayed
-
startup
-
finished
"
)
{
if
(
webrtcUI
.
showGlobalIndicator
)
{
showOrCreateMenuForWindow
(
subject
)
;
}
}
}
SHARING_NONE
:
0
SHARING_WINDOW
:
1
SHARING_SCREEN
:
2
sharedBrowserWindows
:
new
WeakSet
(
)
sharingScreen
:
false
allowedSharedBrowsers
:
new
WeakSet
(
)
allowTabSwitchesForSession
:
false
tabSwitchCountForSession
:
0
sharingDisplay
:
false
sharingDisplaySessionId
:
0
perTabIndicators
:
new
Map
(
)
activePerms
:
new
Map
(
)
get
showGlobalIndicator
(
)
{
for
(
let
[
indicators
]
of
this
.
perTabIndicators
)
{
if
(
indicators
.
showCameraIndicator
|
|
indicators
.
showMicrophoneIndicator
|
|
indicators
.
showScreenSharingIndicator
)
{
return
true
;
}
}
return
false
;
}
get
showCameraIndicator
(
)
{
for
(
let
[
indicators
]
of
this
.
perTabIndicators
)
{
if
(
indicators
.
showCameraIndicator
)
{
return
true
;
}
}
return
false
;
}
get
showMicrophoneIndicator
(
)
{
for
(
let
[
indicators
]
of
this
.
perTabIndicators
)
{
if
(
indicators
.
showMicrophoneIndicator
)
{
return
true
;
}
}
return
false
;
}
get
showScreenSharingIndicator
(
)
{
let
list
=
[
"
"
]
;
for
(
let
[
indicators
]
of
this
.
perTabIndicators
)
{
if
(
indicators
.
showScreenSharingIndicator
)
{
list
.
push
(
indicators
.
showScreenSharingIndicator
)
;
}
}
let
precedence
=
[
"
Screen
"
"
Window
"
"
Application
"
"
Browser
"
"
"
]
;
list
.
sort
(
(
a
b
)
=
>
{
return
precedence
.
indexOf
(
a
)
-
precedence
.
indexOf
(
b
)
;
}
)
;
return
list
[
0
]
;
}
_streams
:
[
]
getActiveStreams
(
aCamera
aMicrophone
aScreen
aWindow
=
false
)
{
return
webrtcUI
.
_streams
.
filter
(
aStream
=
>
{
let
state
=
aStream
.
state
;
return
(
(
aCamera
&
&
state
.
camera
)
|
|
(
aMicrophone
&
&
state
.
microphone
)
|
|
(
aScreen
&
&
state
.
screen
)
|
|
(
aWindow
&
&
state
.
window
)
)
;
}
)
.
map
(
aStream
=
>
{
let
state
=
aStream
.
state
;
let
types
=
{
camera
:
state
.
camera
microphone
:
state
.
microphone
screen
:
state
.
screen
window
:
state
.
window
}
;
let
browser
=
aStream
.
topBrowsingContext
.
embedderElement
;
let
tab
=
browser
?
.
ownerGlobal
.
gBrowser
?
.
getTabForBrowser
(
browser
)
;
return
{
uri
:
state
.
documentURI
tab
browser
types
devices
:
state
.
devices
}
;
}
)
;
}
browserHasStreams
(
aBrowser
)
{
for
(
let
stream
of
this
.
_streams
)
{
if
(
stream
.
topBrowsingContext
.
embedderElement
=
=
aBrowser
)
{
return
true
;
}
}
return
false
;
}
getCombinedStateForBrowser
(
aTopBrowsingContext
)
{
function
combine
(
x
y
)
{
if
(
x
=
=
Ci
.
nsIMediaManagerService
.
STATE_CAPTURE_ENABLED
|
|
y
=
=
Ci
.
nsIMediaManagerService
.
STATE_CAPTURE_ENABLED
)
{
return
Ci
.
nsIMediaManagerService
.
STATE_CAPTURE_ENABLED
;
}
if
(
x
=
=
Ci
.
nsIMediaManagerService
.
STATE_CAPTURE_DISABLED
|
|
y
=
=
Ci
.
nsIMediaManagerService
.
STATE_CAPTURE_DISABLED
)
{
return
Ci
.
nsIMediaManagerService
.
STATE_CAPTURE_DISABLED
;
}
return
Ci
.
nsIMediaManagerService
.
STATE_NOCAPTURE
;
}
let
camera
microphone
screen
window
browser
;
for
(
let
stream
of
this
.
_streams
)
{
if
(
stream
.
topBrowsingContext
=
=
aTopBrowsingContext
)
{
camera
=
combine
(
stream
.
state
.
camera
camera
)
;
microphone
=
combine
(
stream
.
state
.
microphone
microphone
)
;
screen
=
combine
(
stream
.
state
.
screen
screen
)
;
window
=
combine
(
stream
.
state
.
window
window
)
;
browser
=
combine
(
stream
.
state
.
browser
browser
)
;
}
}
let
tabState
=
{
camera
microphone
}
;
if
(
screen
=
=
Ci
.
nsIMediaManagerService
.
STATE_CAPTURE_ENABLED
)
{
tabState
.
screen
=
"
Screen
"
;
}
else
if
(
window
=
=
Ci
.
nsIMediaManagerService
.
STATE_CAPTURE_ENABLED
)
{
tabState
.
screen
=
"
Window
"
;
}
else
if
(
browser
=
=
Ci
.
nsIMediaManagerService
.
STATE_CAPTURE_ENABLED
)
{
tabState
.
screen
=
"
Browser
"
;
}
else
if
(
screen
=
=
Ci
.
nsIMediaManagerService
.
STATE_CAPTURE_DISABLED
)
{
tabState
.
screen
=
"
ScreenPaused
"
;
}
else
if
(
window
=
=
Ci
.
nsIMediaManagerService
.
STATE_CAPTURE_DISABLED
)
{
tabState
.
screen
=
"
WindowPaused
"
;
}
else
if
(
browser
=
=
Ci
.
nsIMediaManagerService
.
STATE_CAPTURE_DISABLED
)
{
tabState
.
screen
=
"
BrowserPaused
"
;
}
let
screenEnabled
=
tabState
.
screen
&
&
!
tabState
.
screen
.
includes
(
"
Paused
"
)
;
let
cameraEnabled
=
tabState
.
camera
=
=
Ci
.
nsIMediaManagerService
.
STATE_CAPTURE_ENABLED
;
let
microphoneEnabled
=
tabState
.
microphone
=
=
Ci
.
nsIMediaManagerService
.
STATE_CAPTURE_ENABLED
;
if
(
screenEnabled
)
{
tabState
.
sharing
=
"
screen
"
;
}
else
if
(
cameraEnabled
)
{
tabState
.
sharing
=
"
camera
"
;
}
else
if
(
microphoneEnabled
)
{
tabState
.
sharing
=
"
microphone
"
;
}
else
if
(
tabState
.
screen
)
{
tabState
.
sharing
=
"
screen
"
;
}
else
if
(
tabState
.
camera
)
{
tabState
.
sharing
=
"
camera
"
;
}
else
if
(
tabState
.
microphone
)
{
tabState
.
sharing
=
"
microphone
"
;
}
tabState
.
paused
=
tabState
.
sharing
&
&
!
screenEnabled
&
&
!
cameraEnabled
&
&
!
microphoneEnabled
;
if
(
tabState
.
camera
=
=
Ci
.
nsIMediaManagerService
.
STATE_CAPTURE_ENABLED
|
|
tabState
.
camera
=
=
Ci
.
nsIMediaManagerService
.
STATE_CAPTURE_DISABLED
)
{
tabState
.
showCameraIndicator
=
true
;
}
if
(
tabState
.
microphone
=
=
Ci
.
nsIMediaManagerService
.
STATE_CAPTURE_ENABLED
|
|
tabState
.
microphone
=
=
Ci
.
nsIMediaManagerService
.
STATE_CAPTURE_DISABLED
)
{
tabState
.
showMicrophoneIndicator
=
true
;
}
tabState
.
showScreenSharingIndicator
=
"
"
;
if
(
tabState
.
screen
)
{
if
(
tabState
.
screen
.
startsWith
(
"
Screen
"
)
)
{
tabState
.
showScreenSharingIndicator
=
"
Screen
"
;
}
else
if
(
tabState
.
screen
.
startsWith
(
"
Window
"
)
)
{
if
(
tabState
.
showScreenSharingIndicator
!
=
"
Screen
"
)
{
tabState
.
showScreenSharingIndicator
=
"
Window
"
;
}
}
else
if
(
tabState
.
screen
.
startsWith
(
"
Browser
"
)
)
{
if
(
!
tabState
.
showScreenSharingIndicator
)
{
tabState
.
showScreenSharingIndicator
=
"
Browser
"
;
}
}
}
return
tabState
;
}
streamAddedOrRemoved
(
aBrowsingContext
aData
)
{
this
.
init
(
)
;
let
index
;
for
(
index
=
0
;
index
<
webrtcUI
.
_streams
.
length
;
+
+
index
)
{
let
stream
=
this
.
_streams
[
index
]
;
if
(
stream
.
browsingContext
=
=
aBrowsingContext
)
{
break
;
}
}
if
(
aData
.
remove
)
{
if
(
index
<
this
.
_streams
.
length
)
{
this
.
_streams
.
splice
(
index
1
)
;
}
}
else
{
this
.
_streams
[
index
]
=
{
browsingContext
:
aBrowsingContext
topBrowsingContext
:
aBrowsingContext
.
top
state
:
aData
}
;
}
let
wasSharingDisplay
=
this
.
sharingDisplay
;
let
sharingBrowserWindow
=
false
;
let
sharedWindowRawDeviceIds
=
new
Set
(
)
;
this
.
sharingDisplay
=
false
;
this
.
sharingScreen
=
false
;
let
suppressNotifications
=
false
;
for
(
let
stream
of
this
.
_streams
)
{
let
{
state
}
=
stream
;
suppressNotifications
|
=
state
.
suppressNotifications
;
for
(
let
device
of
state
.
devices
)
{
let
mediaSource
=
device
.
mediaSource
;
if
(
mediaSource
=
=
"
window
"
|
|
mediaSource
=
=
"
screen
"
)
{
this
.
sharingDisplay
=
true
;
}
if
(
!
device
.
scary
)
{
continue
;
}
if
(
mediaSource
=
=
"
window
"
)
{
sharedWindowRawDeviceIds
.
add
(
device
.
rawId
)
;
}
else
if
(
mediaSource
=
=
"
screen
"
)
{
this
.
sharingScreen
=
true
;
}
let
browser
=
stream
.
topBrowsingContext
.
embedderElement
;
if
(
browser
.
permanentKey
)
{
this
.
allowedSharedBrowsers
.
add
(
browser
.
permanentKey
)
;
}
}
}
this
.
sharedBrowserWindows
=
new
WeakSet
(
)
;
for
(
let
win
of
lazy
.
BrowserWindowTracker
.
orderedWindows
)
{
let
rawDeviceId
;
try
{
rawDeviceId
=
win
.
windowUtils
.
webrtcRawDeviceId
;
}
catch
(
e
)
{
continue
;
}
if
(
sharedWindowRawDeviceIds
.
has
(
rawDeviceId
)
)
{
this
.
sharedBrowserWindows
.
add
(
win
)
;
let
selectedBrowser
=
win
.
gBrowser
.
selectedBrowser
;
this
.
allowedSharedBrowsers
.
add
(
selectedBrowser
.
permanentKey
)
;
sharingBrowserWindow
=
true
;
}
}
if
(
!
wasSharingDisplay
&
&
this
.
sharingDisplay
)
{
this
.
sharingDisplaySessionId
+
+
;
}
if
(
aData
.
devices
)
{
let
silence_notifs
=
suppressNotifications
?
"
true
"
:
"
false
"
;
for
(
let
device
of
aData
.
devices
)
{
if
(
device
.
mediaSource
=
=
"
screen
"
)
{
this
.
recordEvent
(
"
share_display
"
"
screen
"
{
silence_notifs
}
)
;
}
else
if
(
device
.
mediaSource
=
=
"
window
"
)
{
if
(
device
.
scary
)
{
this
.
recordEvent
(
"
share_display
"
"
browser_window
"
{
silence_notifs
}
)
;
}
else
{
this
.
recordEvent
(
"
share_display
"
"
window
"
{
silence_notifs
}
)
;
}
}
}
}
if
(
!
this
.
sharingScreen
&
&
!
sharingBrowserWindow
)
{
this
.
allowedSharedBrowsers
=
new
WeakSet
(
)
;
this
.
allowTabSwitchesForSession
=
false
;
this
.
tabSwitchCountForSession
=
0
;
}
this
.
_setSharedData
(
)
;
if
(
Services
.
prefs
.
getBoolPref
(
"
privacy
.
webrtc
.
allowSilencingNotifications
"
false
)
)
{
let
alertsService
=
Cc
[
"
mozilla
.
org
/
alerts
-
service
;
1
"
]
.
getService
(
Ci
.
nsIAlertsService
)
.
QueryInterface
(
Ci
.
nsIAlertsDoNotDisturb
)
;
alertsService
.
suppressForScreenSharing
=
suppressNotifications
;
}
}
forgetStreamsFromBrowserContext
(
aBrowsingContext
)
{
for
(
let
index
=
0
;
index
<
webrtcUI
.
_streams
.
length
;
)
{
let
stream
=
this
.
_streams
[
index
]
;
if
(
stream
.
browsingContext
=
=
aBrowsingContext
)
{
this
.
_streams
.
splice
(
index
1
)
;
}
else
{
index
+
+
;
}
}
let
topBC
=
aBrowsingContext
.
top
;
if
(
this
.
perTabIndicators
.
has
(
topBC
)
)
{
let
tabState
=
this
.
getCombinedStateForBrowser
(
topBC
)
;
if
(
!
tabState
.
showCameraIndicator
&
&
!
tabState
.
showMicrophoneIndicator
&
&
!
tabState
.
showScreenSharingIndicator
)
{
this
.
perTabIndicators
.
delete
(
topBC
)
;
}
}
this
.
updateGlobalIndicator
(
)
;
this
.
_setSharedData
(
)
;
}
stopSharingStreams
(
activeStreams
stopCameras
=
true
stopMics
=
true
stopScreens
=
true
stopWindows
=
true
)
{
if
(
!
activeStreams
.
length
)
{
return
;
}
let
ids
=
[
]
;
if
(
stopCameras
)
{
ids
.
push
(
"
camera
"
)
;
}
if
(
stopMics
)
{
ids
.
push
(
"
microphone
"
)
;
}
if
(
stopScreens
|
|
stopWindows
)
{
ids
.
push
(
"
screen
"
)
;
}
for
(
let
stream
of
activeStreams
)
{
let
{
browser
}
=
stream
;
let
gBrowser
=
browser
.
getTabBrowser
(
)
;
if
(
!
gBrowser
)
{
console
.
error
(
"
Can
'
t
stop
sharing
stream
-
cannot
find
gBrowser
.
"
)
;
continue
;
}
let
tab
=
gBrowser
.
getTabForBrowser
(
browser
)
;
if
(
!
tab
)
{
console
.
error
(
"
Can
'
t
stop
sharing
stream
-
cannot
find
tab
.
"
)
;
continue
;
}
this
.
clearPermissionsAndStopSharing
(
ids
tab
)
;
}
let
mostRecentStream
=
activeStreams
[
activeStreams
.
length
-
1
]
;
let
{
browser
:
browserToSelect
}
=
mostRecentStream
;
let
window
=
browserToSelect
.
ownerGlobal
;
let
gBrowser
=
browserToSelect
.
getTabBrowser
(
)
;
let
tab
=
gBrowser
.
getTabForBrowser
(
browserToSelect
)
;
window
.
focus
(
)
;
gBrowser
.
selectedTab
=
tab
;
}
clearPermissionsAndStopSharing
(
types
tab
)
{
let
invalidTypes
=
types
.
filter
(
type
=
>
!
[
"
camera
"
"
screen
"
"
microphone
"
"
speaker
"
]
.
includes
(
type
)
)
;
if
(
invalidTypes
.
length
)
{
throw
new
Error
(
Invalid
device
types
{
invalidTypes
.
join
(
"
"
)
}
)
;
}
let
browser
=
tab
.
linkedBrowser
;
let
sharingState
=
tab
.
_sharingState
?
.
webRTC
;
let
perms
=
lazy
.
SitePermissions
.
getAllForBrowser
(
browser
)
;
let
sharingCameraOrMic
=
(
sharingState
?
.
camera
|
|
sharingState
?
.
microphone
)
&
&
(
types
.
includes
(
"
camera
"
)
|
|
types
.
includes
(
"
microphone
"
)
)
;
perms
.
filter
(
perm
=
>
{
let
[
id
]
=
perm
.
id
.
split
(
lazy
.
SitePermissions
.
PERM_KEY_DELIMITER
)
;
if
(
sharingCameraOrMic
&
&
(
id
=
=
"
camera
"
|
|
id
=
=
"
microphone
"
)
)
{
return
true
;
}
return
types
.
includes
(
id
)
;
}
)
.
forEach
(
perm
=
>
{
lazy
.
SitePermissions
.
removeFromPrincipal
(
browser
.
contentPrincipal
perm
.
id
browser
)
;
}
)
;
if
(
!
sharingState
?
.
windowId
)
{
return
;
}
let
{
windowId
}
=
sharingState
;
let
windowIds
=
[
]
;
if
(
types
.
includes
(
"
screen
"
)
&
&
sharingState
.
screen
)
{
windowIds
.
push
(
screen
:
{
windowId
}
)
;
}
if
(
sharingCameraOrMic
)
{
windowIds
.
push
(
windowId
)
;
}
if
(
!
windowIds
.
length
)
{
return
;
}
let
actor
=
sharingState
.
browsingContext
.
currentWindowGlobal
.
getActor
(
"
WebRTC
"
)
;
webrtcUI
.
forgetActivePermissionsFromBrowser
(
browser
)
;
windowIds
.
forEach
(
id
=
>
actor
.
sendAsyncMessage
(
"
webrtc
:
StopSharing
"
id
)
)
;
}
updateIndicators
(
aTopBrowsingContext
)
{
let
tabState
=
this
.
getCombinedStateForBrowser
(
aTopBrowsingContext
)
;
let
indicators
;
if
(
this
.
perTabIndicators
.
has
(
aTopBrowsingContext
)
)
{
indicators
=
this
.
perTabIndicators
.
get
(
aTopBrowsingContext
)
;
}
else
{
indicators
=
{
}
;
this
.
perTabIndicators
.
set
(
aTopBrowsingContext
indicators
)
;
}
indicators
.
showCameraIndicator
=
tabState
.
showCameraIndicator
;
indicators
.
showMicrophoneIndicator
=
tabState
.
showMicrophoneIndicator
;
indicators
.
showScreenSharingIndicator
=
tabState
.
showScreenSharingIndicator
;
this
.
updateGlobalIndicator
(
)
;
return
tabState
;
}
swapBrowserForNotification
(
aOldBrowser
aNewBrowser
)
{
for
(
let
stream
of
this
.
_streams
)
{
if
(
stream
.
browser
=
=
aOldBrowser
)
{
stream
.
browser
=
aNewBrowser
;
}
}
}
forgetActivePermissionsFromBrowser
(
aBrowser
)
{
let
browserWindowIds
=
aBrowser
.
browsingContext
.
getAllBrowsingContextsInSubtree
(
)
.
map
(
bc
=
>
bc
.
currentWindowGlobal
?
.
outerWindowId
)
.
filter
(
id
=
>
id
!
=
null
)
;
browserWindowIds
.
push
(
aBrowser
.
outerWindowId
)
;
browserWindowIds
.
forEach
(
id
=
>
this
.
activePerms
.
delete
(
id
)
)
;
}
showSharingDoorhanger
(
aActiveStream
aEvent
)
{
let
browserWindow
=
aActiveStream
.
browser
.
ownerGlobal
;
if
(
aActiveStream
.
tab
)
{
browserWindow
.
gBrowser
.
selectedTab
=
aActiveStream
.
tab
;
}
else
{
aActiveStream
.
browser
.
focus
(
)
;
}
browserWindow
.
focus
(
)
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
&
&
!
Services
.
focus
.
activeWindow
)
{
browserWindow
.
addEventListener
(
"
activate
"
function
(
)
{
Services
.
tm
.
dispatchToMainThread
(
function
(
)
{
browserWindow
.
gPermissionPanel
.
openPopup
(
aEvent
)
;
}
)
;
}
{
once
:
true
}
)
;
Cc
[
"
mozilla
.
org
/
widget
/
macdocksupport
;
1
"
]
.
getService
(
Ci
.
nsIMacDockSupport
)
.
activateApplication
(
true
)
;
return
;
}
browserWindow
.
gPermissionPanel
.
openPopup
(
aEvent
)
;
}
updateWarningLabel
(
aMenuList
)
{
let
type
=
aMenuList
.
selectedItem
.
getAttribute
(
"
devicetype
"
)
;
let
document
=
aMenuList
.
ownerDocument
;
document
.
getElementById
(
"
webRTC
-
all
-
windows
-
shared
"
)
.
hidden
=
type
!
=
"
screen
"
;
}
addPeerConnectionBlocker
(
aCallback
)
{
this
.
peerConnectionBlockers
.
add
(
aCallback
)
;
}
removePeerConnectionBlocker
(
aCallback
)
{
this
.
peerConnectionBlockers
.
delete
(
aCallback
)
;
}
on
(
.
.
.
args
)
{
return
this
.
emitter
.
on
(
.
.
.
args
)
;
}
off
(
.
.
.
args
)
{
return
this
.
emitter
.
off
(
.
.
.
args
)
;
}
getHostOrExtensionName
(
uri
href
)
{
let
host
;
try
{
if
(
!
uri
)
{
uri
=
Services
.
io
.
newURI
(
href
)
;
}
let
addonPolicy
=
WebExtensionPolicy
.
getByURI
(
uri
)
;
host
=
addonPolicy
?
.
name
?
?
uri
.
hostPort
;
}
catch
(
ex
)
{
}
if
(
!
host
)
{
if
(
uri
&
&
uri
.
scheme
.
toLowerCase
(
)
=
=
"
about
"
)
{
host
=
uri
.
specIgnoringRef
;
}
else
{
host
=
lazy
.
syncL10n
.
formatValueSync
(
"
webrtc
-
sharing
-
menuitem
-
unknown
-
host
"
)
;
}
}
return
host
;
}
updateGlobalIndicator
(
)
{
for
(
let
chromeWin
of
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
)
{
if
(
this
.
showGlobalIndicator
)
{
showOrCreateMenuForWindow
(
chromeWin
)
;
}
else
{
let
doc
=
chromeWin
.
document
;
let
existingMenu
=
doc
.
getElementById
(
"
tabSharingMenu
"
)
;
if
(
existingMenu
)
{
existingMenu
.
hidden
=
true
;
}
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
let
separator
=
doc
.
getElementById
(
"
tabSharingSeparator
"
)
;
if
(
separator
)
{
separator
.
hidden
=
true
;
}
}
}
}
if
(
this
.
showGlobalIndicator
)
{
if
(
!
gIndicatorWindow
)
{
gIndicatorWindow
=
getGlobalIndicator
(
)
;
}
else
{
try
{
gIndicatorWindow
.
updateIndicatorState
(
)
;
}
catch
(
err
)
{
console
.
error
(
error
in
gIndicatorWindow
.
updateIndicatorState
(
)
:
{
err
.
message
}
)
;
}
}
}
else
if
(
gIndicatorWindow
)
{
if
(
!
webrtcUI
.
useLegacyGlobalIndicator
&
&
gIndicatorWindow
.
closingInternally
)
{
gIndicatorWindow
.
closingInternally
(
)
;
}
gIndicatorWindow
.
close
(
)
;
gIndicatorWindow
=
null
;
}
}
getWindowShareState
(
window
)
{
if
(
this
.
sharingScreen
)
{
return
this
.
SHARING_SCREEN
;
}
else
if
(
this
.
sharedBrowserWindows
.
has
(
window
)
)
{
return
this
.
SHARING_WINDOW
;
}
return
this
.
SHARING_NONE
;
}
tabAddedWhileSharing
(
tab
)
{
this
.
allowedSharedBrowsers
.
add
(
tab
.
linkedBrowser
.
permanentKey
)
;
}
shouldShowSharedTabWarning
(
tab
)
{
if
(
!
tab
|
|
!
tab
.
linkedBrowser
)
{
return
false
;
}
let
browser
=
tab
.
linkedBrowser
;
if
(
!
this
.
tabSwitchCountForSession
)
{
this
.
allowedSharedBrowsers
.
add
(
browser
.
permanentKey
)
;
}
this
.
tabSwitchCountForSession
+
+
;
let
shouldShow
=
!
this
.
allowTabSwitchesForSession
&
&
!
this
.
allowedSharedBrowsers
.
has
(
browser
.
permanentKey
)
;
return
shouldShow
;
}
allowSharedTabSwitch
(
tab
allowForSession
)
{
let
browser
=
tab
.
linkedBrowser
;
let
gBrowser
=
browser
.
getTabBrowser
(
)
;
this
.
allowedSharedBrowsers
.
add
(
browser
.
permanentKey
)
;
gBrowser
.
selectedTab
=
tab
;
this
.
allowTabSwitchesForSession
=
allowForSession
;
}
recordEvent
(
type
object
args
=
{
}
)
{
Services
.
telemetry
.
recordEvent
(
"
webrtc
.
ui
"
type
object
this
.
sharingDisplaySessionId
.
toString
(
)
args
)
;
}
_setSharedData
(
)
{
let
sharedTopInnerWindowIds
=
new
Set
(
)
;
for
(
let
win
of
lazy
.
BrowserWindowTracker
.
orderedWindows
)
{
if
(
this
.
sharedBrowserWindows
.
has
(
win
)
)
{
sharedTopInnerWindowIds
.
add
(
win
.
browsingContext
.
currentWindowGlobal
.
innerWindowId
)
;
}
}
Services
.
ppmm
.
sharedData
.
set
(
"
webrtcUI
:
isSharingScreen
"
this
.
sharingScreen
)
;
Services
.
ppmm
.
sharedData
.
set
(
"
webrtcUI
:
sharedTopInnerWindowIds
"
sharedTopInnerWindowIds
)
;
}
}
;
function
getGlobalIndicator
(
)
{
if
(
!
webrtcUI
.
useLegacyGlobalIndicator
)
{
const
INDICATOR_CHROME_URI
=
"
chrome
:
/
/
browser
/
content
/
webrtcIndicator
.
xhtml
"
;
let
features
=
"
chrome
titlebar
=
no
alwaysontop
minimizable
dialog
"
;
return
Services
.
ww
.
openWindow
(
null
INDICATOR_CHROME_URI
"
_blank
"
features
null
)
;
}
if
(
AppConstants
.
platform
!
=
"
macosx
"
)
{
const
LEGACY_INDICATOR_CHROME_URI
=
"
chrome
:
/
/
browser
/
content
/
webrtcLegacyIndicator
.
xhtml
"
;
const
features
=
"
chrome
dialog
=
yes
titlebar
=
no
popup
=
yes
"
;
return
Services
.
ww
.
openWindow
(
null
LEGACY_INDICATOR_CHROME_URI
"
_blank
"
features
null
)
;
}
return
new
MacOSWebRTCStatusbarIndicator
(
)
;
}
function
showStreamSharingMenu
(
win
event
inclWindow
=
false
)
{
win
.
MozXULElement
.
insertFTLIfNeeded
(
"
browser
/
webrtcIndicator
.
ftl
"
)
;
const
doc
=
win
.
document
;
const
menu
=
event
.
target
;
let
type
=
menu
.
getAttribute
(
"
type
"
)
;
let
activeStreams
;
if
(
type
=
=
"
Camera
"
)
{
activeStreams
=
webrtcUI
.
getActiveStreams
(
true
false
false
)
;
}
else
if
(
type
=
=
"
Microphone
"
)
{
activeStreams
=
webrtcUI
.
getActiveStreams
(
false
true
false
)
;
}
else
if
(
type
=
=
"
Screen
"
)
{
activeStreams
=
webrtcUI
.
getActiveStreams
(
false
false
true
inclWindow
)
;
type
=
webrtcUI
.
showScreenSharingIndicator
;
}
if
(
!
activeStreams
.
length
)
{
event
.
preventDefault
(
)
;
return
;
}
const
l10nIds
=
SHARING_L10NID_BY_TYPE
.
get
(
type
)
?
?
[
]
;
if
(
activeStreams
.
length
=
=
1
)
{
let
stream
=
activeStreams
[
0
]
;
const
sharingItem
=
doc
.
createXULElement
(
"
menuitem
"
)
;
const
streamTitle
=
stream
.
browser
.
contentTitle
|
|
stream
.
uri
;
doc
.
l10n
.
setAttributes
(
sharingItem
l10nIds
[
0
]
{
streamTitle
}
)
;
sharingItem
.
setAttribute
(
"
disabled
"
"
true
"
)
;
menu
.
appendChild
(
sharingItem
)
;
const
controlItem
=
doc
.
createXULElement
(
"
menuitem
"
)
;
doc
.
l10n
.
setAttributes
(
controlItem
"
webrtc
-
indicator
-
menuitem
-
control
-
sharing
"
)
;
controlItem
.
stream
=
stream
;
controlItem
.
addEventListener
(
"
command
"
this
)
;
menu
.
appendChild
(
controlItem
)
;
}
else
{
const
sharingItem
=
doc
.
createXULElement
(
"
menuitem
"
)
;
doc
.
l10n
.
setAttributes
(
sharingItem
l10nIds
[
1
]
{
tabCount
:
activeStreams
.
length
}
)
;
sharingItem
.
setAttribute
(
"
disabled
"
"
true
"
)
;
menu
.
appendChild
(
sharingItem
)
;
for
(
let
stream
of
activeStreams
)
{
const
controlItem
=
doc
.
createXULElement
(
"
menuitem
"
)
;
const
streamTitle
=
stream
.
browser
.
contentTitle
|
|
stream
.
uri
;
doc
.
l10n
.
setAttributes
(
controlItem
"
webrtc
-
indicator
-
menuitem
-
control
-
sharing
-
on
"
{
streamTitle
}
)
;
controlItem
.
stream
=
stream
;
controlItem
.
addEventListener
(
"
command
"
this
)
;
menu
.
appendChild
(
controlItem
)
;
}
}
}
class
MacOSWebRTCStatusbarIndicator
{
constructor
(
)
{
this
.
_camera
=
null
;
this
.
_microphone
=
null
;
this
.
_screen
=
null
;
this
.
_hiddenDoc
=
Services
.
appShell
.
hiddenDOMWindow
.
document
;
this
.
_statusBar
=
Cc
[
"
mozilla
.
org
/
widget
/
systemstatusbar
;
1
"
]
.
getService
(
Ci
.
nsISystemStatusBar
)
;
this
.
updateIndicatorState
(
)
;
}
updateIndicatorState
(
)
{
this
.
_setIndicatorState
(
"
Camera
"
webrtcUI
.
showCameraIndicator
)
;
this
.
_setIndicatorState
(
"
Microphone
"
webrtcUI
.
showMicrophoneIndicator
)
;
this
.
_setIndicatorState
(
"
Screen
"
webrtcUI
.
showScreenSharingIndicator
)
;
}
close
(
)
{
this
.
_setIndicatorState
(
"
Camera
"
false
)
;
this
.
_setIndicatorState
(
"
Microphone
"
false
)
;
this
.
_setIndicatorState
(
"
Screen
"
false
)
;
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
popupshowing
"
:
{
this
.
_popupShowing
(
event
)
;
break
;
}
case
"
popuphiding
"
:
{
this
.
_popupHiding
(
event
)
;
break
;
}
case
"
command
"
:
{
this
.
_command
(
event
)
;
break
;
}
}
}
_command
(
aEvent
)
{
webrtcUI
.
showSharingDoorhanger
(
aEvent
.
target
.
stream
aEvent
)
;
}
_popupShowing
(
aEvent
)
{
const
menu
=
aEvent
.
target
;
showStreamSharingMenu
(
menu
.
ownerGlobal
aEvent
)
;
return
true
;
}
_popupHiding
(
aEvent
)
{
let
menu
=
aEvent
.
target
;
while
(
menu
.
firstChild
)
{
menu
.
firstChild
.
remove
(
)
;
}
}
_setIndicatorState
(
aName
aState
)
{
let
field
=
"
_
"
+
aName
.
toLowerCase
(
)
;
if
(
aState
&
&
!
this
[
field
]
)
{
let
menu
=
this
.
_hiddenDoc
.
createXULElement
(
"
menu
"
)
;
menu
.
setAttribute
(
"
id
"
"
webRTC
-
sharing
"
+
aName
+
"
-
menu
"
)
;
this
.
_hiddenDoc
.
documentElement
.
appendChild
(
menu
)
;
this
.
_statusBar
.
addItem
(
menu
)
;
let
menupopup
=
this
.
_hiddenDoc
.
createXULElement
(
"
menupopup
"
)
;
menupopup
.
setAttribute
(
"
type
"
aName
)
;
menupopup
.
addEventListener
(
"
popupshowing
"
this
)
;
menupopup
.
addEventListener
(
"
popuphiding
"
this
)
;
menupopup
.
addEventListener
(
"
command
"
this
)
;
menu
.
appendChild
(
menupopup
)
;
this
[
field
]
=
menu
;
}
else
if
(
this
[
field
]
&
&
!
aState
)
{
this
.
_statusBar
.
removeItem
(
this
[
field
]
)
;
this
[
field
]
.
remove
(
)
;
this
[
field
]
=
null
;
}
}
}
function
onTabSharingMenuPopupShowing
(
e
)
{
const
streams
=
webrtcUI
.
getActiveStreams
(
true
true
true
true
)
;
for
(
let
streamInfo
of
streams
)
{
const
names
=
streamInfo
.
devices
.
map
(
(
{
mediaSource
}
)
=
>
{
const
l10nId
=
MEDIA_SOURCE_L10NID_BY_TYPE
.
get
(
mediaSource
)
;
return
l10nId
?
lazy
.
syncL10n
.
formatValueSync
(
l10nId
)
:
mediaSource
;
}
)
;
const
doc
=
e
.
target
.
ownerDocument
;
const
menuitem
=
doc
.
createXULElement
(
"
menuitem
"
)
;
doc
.
l10n
.
setAttributes
(
menuitem
"
webrtc
-
sharing
-
menuitem
"
{
origin
:
webrtcUI
.
getHostOrExtensionName
(
null
streamInfo
.
uri
)
itemList
:
lazy
.
listFormat
.
format
(
names
)
}
)
;
menuitem
.
stream
=
streamInfo
;
menuitem
.
addEventListener
(
"
command
"
onTabSharingMenuPopupCommand
)
;
e
.
target
.
appendChild
(
menuitem
)
;
}
}
function
onTabSharingMenuPopupHiding
(
e
)
{
while
(
this
.
lastChild
)
{
this
.
lastChild
.
remove
(
)
;
}
}
function
onTabSharingMenuPopupCommand
(
e
)
{
webrtcUI
.
showSharingDoorhanger
(
e
.
target
.
stream
e
)
;
}
function
showOrCreateMenuForWindow
(
aWindow
)
{
let
document
=
aWindow
.
document
;
let
menu
=
document
.
getElementById
(
"
tabSharingMenu
"
)
;
if
(
!
menu
)
{
menu
=
document
.
createXULElement
(
"
menu
"
)
;
menu
.
id
=
"
tabSharingMenu
"
;
document
.
l10n
.
setAttributes
(
menu
"
webrtc
-
sharing
-
menu
"
)
;
let
container
insertionPoint
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
container
=
document
.
getElementById
(
"
menu_ToolsPopup
"
)
;
insertionPoint
=
document
.
getElementById
(
"
devToolsSeparator
"
)
;
let
separator
=
document
.
createXULElement
(
"
menuseparator
"
)
;
separator
.
id
=
"
tabSharingSeparator
"
;
container
.
insertBefore
(
separator
insertionPoint
)
;
}
else
{
container
=
document
.
getElementById
(
"
main
-
menubar
"
)
;
insertionPoint
=
document
.
getElementById
(
"
helpMenu
"
)
;
}
let
popup
=
document
.
createXULElement
(
"
menupopup
"
)
;
popup
.
id
=
"
tabSharingMenuPopup
"
;
popup
.
addEventListener
(
"
popupshowing
"
onTabSharingMenuPopupShowing
)
;
popup
.
addEventListener
(
"
popuphiding
"
onTabSharingMenuPopupHiding
)
;
menu
.
appendChild
(
popup
)
;
container
.
insertBefore
(
menu
insertionPoint
)
;
}
else
{
menu
.
hidden
=
false
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
document
.
getElementById
(
"
tabSharingSeparator
"
)
.
hidden
=
false
;
}
}
}
var
gIndicatorWindow
=
null
;
