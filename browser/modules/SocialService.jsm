this
.
EXPORTED_SYMBOLS
=
[
"
SocialService
"
]
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
const
URI_EXTENSION_STRINGS
=
"
chrome
:
/
/
mozapps
/
locale
/
extensions
/
extensions
.
properties
"
;
const
ADDON_TYPE_SERVICE
=
"
service
"
;
const
ID_SUFFIX
=
"
services
.
mozilla
.
org
"
;
const
STRING_TYPE_NAME
=
"
type
.
%
ID
%
.
name
"
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
DeferredTask
"
"
resource
:
/
/
gre
/
modules
/
DeferredTask
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
etld
"
"
mozilla
.
org
/
network
/
effective
-
tld
-
service
;
1
"
"
nsIEffectiveTLDService
"
)
;
var
SocialServiceInternal
=
{
get
enabled
(
)
{
return
this
.
providerArray
.
length
>
0
;
}
get
providerArray
(
)
{
return
Object
.
keys
(
this
.
providers
)
.
map
(
origin
=
>
this
.
providers
[
origin
]
)
;
}
*
manifestsGenerator
(
)
{
let
MANIFEST_PREFS
=
Services
.
prefs
.
getBranch
(
"
social
.
manifest
.
"
)
;
let
prefs
=
MANIFEST_PREFS
.
getChildList
(
"
"
[
]
)
;
for
(
let
pref
of
prefs
)
{
if
(
!
MANIFEST_PREFS
.
prefHasUserValue
(
pref
)
)
continue
;
try
{
var
manifest
=
JSON
.
parse
(
MANIFEST_PREFS
.
getStringPref
(
pref
)
)
;
if
(
manifest
&
&
typeof
(
manifest
)
=
=
"
object
"
&
&
manifest
.
origin
)
yield
manifest
;
}
catch
(
err
)
{
Cu
.
reportError
(
"
SocialService
:
failed
to
load
manifest
:
"
+
pref
+
"
exception
:
"
+
err
)
;
}
}
}
get
manifests
(
)
{
return
this
.
manifestsGenerator
(
)
;
}
getManifestPrefname
(
origin
)
{
let
MANIFEST_PREFS
=
Services
.
prefs
.
getBranch
(
"
social
.
manifest
.
"
)
;
let
prefs
=
MANIFEST_PREFS
.
getChildList
(
"
"
[
]
)
;
for
(
let
pref
of
prefs
)
{
try
{
var
manifest
=
JSON
.
parse
(
MANIFEST_PREFS
.
getStringPref
(
pref
)
)
;
if
(
manifest
.
origin
=
=
origin
)
{
return
pref
;
}
}
catch
(
err
)
{
Cu
.
reportError
(
"
SocialService
:
failed
to
load
manifest
:
"
+
pref
+
"
exception
:
"
+
err
)
;
}
}
let
originUri
=
Services
.
io
.
newURI
(
origin
)
;
return
originUri
.
hostPort
.
replace
(
"
.
"
"
-
"
)
;
}
orderedProviders
(
aCallback
)
{
if
(
SocialServiceInternal
.
providerArray
.
length
<
2
)
{
schedule
(
function
(
)
{
aCallback
(
SocialServiceInternal
.
providerArray
)
;
}
)
;
return
;
}
let
hosts
=
[
]
;
let
providers
=
{
}
;
for
(
let
p
of
SocialServiceInternal
.
providerArray
)
{
p
.
frecency
=
0
;
providers
[
p
.
domain
]
=
p
;
hosts
.
push
(
p
.
domain
)
;
}
let
stmt
=
PlacesUtils
.
history
.
QueryInterface
(
Ci
.
nsPIPlacesDatabase
)
.
DBConnection
.
createAsyncStatement
(
"
SELECT
host
frecency
FROM
moz_hosts
WHERE
host
IN
(
"
+
hosts
.
map
(
host
=
>
'
"
'
+
host
+
'
"
'
)
.
join
(
"
"
)
+
"
)
"
)
;
try
{
stmt
.
executeAsync
(
{
handleResult
(
aResultSet
)
{
let
row
;
while
(
(
row
=
aResultSet
.
getNextRow
(
)
)
)
{
let
rh
=
row
.
getResultByName
(
"
host
"
)
;
let
frecency
=
row
.
getResultByName
(
"
frecency
"
)
;
providers
[
rh
]
.
frecency
=
parseInt
(
frecency
)
|
|
0
;
}
}
handleError
(
aError
)
{
Cu
.
reportError
(
aError
.
message
+
"
(
Result
=
"
+
aError
.
result
+
"
)
"
)
;
}
handleCompletion
(
aReason
)
{
let
providerList
=
SocialServiceInternal
.
providerArray
;
aCallback
(
providerList
.
sort
(
(
a
b
)
=
>
b
.
frecency
-
a
.
frecency
)
)
;
}
}
)
;
}
finally
{
stmt
.
finalize
(
)
;
}
}
}
;
XPCOMUtils
.
defineLazyGetter
(
SocialServiceInternal
"
providers
"
function
(
)
{
initService
(
)
;
let
providers
=
{
}
;
for
(
let
manifest
of
this
.
manifests
)
{
try
{
if
(
ActiveProviders
.
has
(
manifest
.
origin
)
)
{
let
provider
=
new
SocialProvider
(
manifest
)
;
providers
[
provider
.
origin
]
=
provider
;
}
}
catch
(
err
)
{
Cu
.
reportError
(
"
SocialService
:
failed
to
load
provider
:
"
+
manifest
.
origin
+
"
exception
:
"
+
err
)
;
}
}
return
providers
;
}
)
;
function
getOriginActivationType
(
origin
)
{
let
URI
=
Services
.
io
.
newURI
(
origin
)
;
let
principal
=
Services
.
scriptSecurityManager
.
createCodebasePrincipal
(
URI
{
}
)
;
if
(
Services
.
scriptSecurityManager
.
isSystemPrincipal
(
principal
)
|
|
origin
=
=
"
moz
-
safe
-
about
:
home
"
)
{
return
"
internal
"
;
}
let
directories
=
Services
.
prefs
.
getCharPref
(
"
social
.
directories
"
)
.
split
(
"
"
)
;
if
(
directories
.
indexOf
(
origin
)
>
=
0
)
return
"
directory
"
;
return
"
foreign
"
;
}
var
ActiveProviders
=
{
get
_providers
(
)
{
delete
this
.
_providers
;
this
.
_providers
=
{
}
;
try
{
let
pref
=
Services
.
prefs
.
getStringPref
(
"
social
.
activeProviders
"
)
;
this
.
_providers
=
JSON
.
parse
(
pref
)
;
}
catch
(
ex
)
{
}
return
this
.
_providers
;
}
has
(
origin
)
{
return
(
origin
in
this
.
_providers
)
;
}
add
(
origin
)
{
this
.
_providers
[
origin
]
=
1
;
this
.
_deferredTask
.
arm
(
)
;
}
delete
(
origin
)
{
delete
this
.
_providers
[
origin
]
;
this
.
_deferredTask
.
arm
(
)
;
}
flush
(
)
{
this
.
_deferredTask
.
disarm
(
)
;
this
.
_persist
(
)
;
}
get
_deferredTask
(
)
{
delete
this
.
_deferredTask
;
return
this
.
_deferredTask
=
new
DeferredTask
(
this
.
_persist
.
bind
(
this
)
0
)
;
}
_persist
(
)
{
Services
.
prefs
.
setStringPref
(
"
social
.
activeProviders
"
JSON
.
stringify
(
this
.
_providers
)
)
;
}
}
;
function
migrateSettings
(
)
{
let
enabled
;
if
(
Services
.
prefs
.
prefHasUserValue
(
"
social
.
enabled
"
)
)
{
enabled
=
Services
.
prefs
.
getBoolPref
(
"
social
.
enabled
"
)
;
}
if
(
Services
.
prefs
.
getCharPref
(
"
social
.
activeProviders
"
"
"
)
)
{
for
(
let
origin
in
ActiveProviders
.
_providers
)
{
let
prefname
;
let
manifest
;
let
defaultManifest
;
try
{
prefname
=
getPrefnameFromOrigin
(
origin
)
;
manifest
=
JSON
.
parse
(
Services
.
prefs
.
getStringPref
(
prefname
)
)
;
}
catch
(
e
)
{
ActiveProviders
.
delete
(
origin
)
;
ActiveProviders
.
flush
(
)
;
continue
;
}
let
needsUpdate
=
!
manifest
.
updateDate
;
try
{
defaultManifest
=
Services
.
prefs
.
getDefaultBranch
(
null
)
.
getStringPref
(
prefname
)
;
defaultManifest
=
JSON
.
parse
(
defaultManifest
)
;
}
catch
(
e
)
{
}
if
(
defaultManifest
)
{
if
(
defaultManifest
.
shareURL
&
&
!
manifest
.
shareURL
)
{
manifest
.
shareURL
=
defaultManifest
.
shareURL
;
needsUpdate
=
true
;
}
if
(
defaultManifest
.
version
&
&
(
!
manifest
.
version
|
|
defaultManifest
.
version
>
manifest
.
version
)
)
{
manifest
=
defaultManifest
;
needsUpdate
=
true
;
}
}
if
(
needsUpdate
)
{
delete
manifest
.
builtin
;
manifest
.
updateDate
=
Date
.
now
(
)
;
if
(
!
manifest
.
installDate
)
manifest
.
installDate
=
0
;
Services
.
prefs
.
setStringPref
(
prefname
JSON
.
stringify
(
manifest
)
)
;
}
if
(
enabled
=
=
=
false
)
{
ActiveProviders
.
delete
(
origin
)
;
}
}
ActiveProviders
.
flush
(
)
;
Services
.
prefs
.
clearUserPref
(
"
social
.
enabled
"
)
;
return
;
}
let
active
=
Services
.
prefs
.
getBoolPref
(
"
social
.
active
"
false
)
;
if
(
!
active
)
return
;
let
manifestPrefs
=
Services
.
prefs
.
getDefaultBranch
(
"
social
.
manifest
.
"
)
;
let
prefs
=
manifestPrefs
.
getChildList
(
"
"
[
]
)
;
for
(
let
pref
of
prefs
)
{
try
{
let
manifest
;
try
{
manifest
=
JSON
.
parse
(
manifestPrefs
.
getStringPref
(
pref
)
)
;
}
catch
(
e
)
{
continue
;
}
if
(
manifest
&
&
typeof
(
manifest
)
=
=
"
object
"
&
&
manifest
.
origin
)
{
delete
manifest
.
builtin
;
if
(
!
manifest
.
updateDate
)
{
manifest
.
updateDate
=
Date
.
now
(
)
;
manifest
.
installDate
=
0
;
}
Services
.
prefs
.
setStringPref
(
"
social
.
manifest
.
"
+
pref
JSON
.
stringify
(
manifest
)
)
;
ActiveProviders
.
add
(
manifest
.
origin
)
;
ActiveProviders
.
flush
(
)
;
return
;
}
}
catch
(
err
)
{
Cu
.
reportError
(
"
SocialService
:
failed
to
load
manifest
:
"
+
pref
+
"
exception
:
"
+
err
)
;
}
}
}
function
initService
(
)
{
Services
.
obs
.
addObserver
(
function
xpcomShutdown
(
)
{
ActiveProviders
.
flush
(
)
;
SocialService
.
_providerListeners
=
null
;
Services
.
obs
.
removeObserver
(
xpcomShutdown
"
xpcom
-
shutdown
"
)
;
}
"
xpcom
-
shutdown
"
)
;
try
{
migrateSettings
(
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
"
Error
migrating
social
settings
:
"
+
e
)
;
}
}
function
schedule
(
callback
)
{
Services
.
tm
.
dispatchToMainThread
(
callback
)
;
}
this
.
SocialService
=
{
get
hasEnabledProviders
(
)
{
for
(
let
p
in
ActiveProviders
.
_providers
)
{
return
true
;
}
return
false
;
}
get
enabled
(
)
{
return
SocialServiceInternal
.
enabled
;
}
set
enabled
(
val
)
{
throw
new
Error
(
"
not
allowed
to
set
SocialService
.
enabled
"
)
;
}
enableProvider
:
function
enableProvider
(
origin
onDone
)
{
if
(
SocialServiceInternal
.
providers
[
origin
]
)
{
schedule
(
function
(
)
{
onDone
(
SocialServiceInternal
.
providers
[
origin
]
)
;
}
)
;
return
;
}
let
manifest
=
SocialService
.
getManifestByOrigin
(
origin
)
;
if
(
manifest
)
{
let
addon
=
new
AddonWrapper
(
manifest
)
;
AddonManagerPrivate
.
callAddonListeners
(
"
onEnabling
"
addon
false
)
;
addon
.
pendingOperations
|
=
AddonManager
.
PENDING_ENABLE
;
this
.
addProvider
(
manifest
onDone
)
;
addon
.
pendingOperations
-
=
AddonManager
.
PENDING_ENABLE
;
AddonManagerPrivate
.
callAddonListeners
(
"
onEnabled
"
addon
)
;
return
;
}
schedule
(
function
(
)
{
onDone
(
null
)
;
}
)
;
}
addProvider
:
function
addProvider
(
manifest
onDone
)
{
if
(
SocialServiceInternal
.
providers
[
manifest
.
origin
]
)
throw
new
Error
(
"
SocialService
.
addProvider
:
provider
with
this
origin
already
exists
"
)
;
let
provider
=
new
SocialProvider
(
manifest
)
;
SocialServiceInternal
.
providers
[
provider
.
origin
]
=
provider
;
ActiveProviders
.
add
(
provider
.
origin
)
;
this
.
getOrderedProviderList
(
providers
=
>
{
this
.
_notifyProviderListeners
(
"
provider
-
enabled
"
provider
.
origin
providers
)
;
if
(
onDone
)
onDone
(
provider
)
;
}
)
;
}
disableProvider
:
function
disableProvider
(
origin
onDone
)
{
if
(
!
(
origin
in
SocialServiceInternal
.
providers
)
)
throw
new
Error
(
"
SocialService
.
disableProvider
:
no
provider
with
origin
"
+
origin
+
"
exists
!
"
)
;
let
provider
=
SocialServiceInternal
.
providers
[
origin
]
;
let
manifest
=
SocialService
.
getManifestByOrigin
(
origin
)
;
let
addon
=
manifest
&
&
new
AddonWrapper
(
manifest
)
;
if
(
addon
)
{
AddonManagerPrivate
.
callAddonListeners
(
"
onDisabling
"
addon
false
)
;
addon
.
pendingOperations
|
=
AddonManager
.
PENDING_DISABLE
;
}
provider
.
enabled
=
false
;
ActiveProviders
.
delete
(
provider
.
origin
)
;
delete
SocialServiceInternal
.
providers
[
origin
]
;
if
(
addon
)
{
addon
.
pendingOperations
-
=
AddonManager
.
PENDING_DISABLE
;
AddonManagerPrivate
.
callAddonListeners
(
"
onDisabled
"
addon
)
;
}
this
.
getOrderedProviderList
(
providers
=
>
{
this
.
_notifyProviderListeners
(
"
provider
-
disabled
"
origin
providers
)
;
if
(
onDone
)
onDone
(
)
;
}
)
;
}
getProvider
:
function
getProvider
(
origin
onDone
)
{
schedule
(
(
function
(
)
{
onDone
(
SocialServiceInternal
.
providers
[
origin
]
|
|
null
)
;
}
)
)
;
}
getProviderList
(
onDone
)
{
schedule
(
function
(
)
{
onDone
(
SocialServiceInternal
.
providerArray
)
;
}
)
;
}
getManifestByOrigin
(
origin
)
{
for
(
let
manifest
of
SocialServiceInternal
.
manifests
)
{
if
(
origin
=
=
manifest
.
origin
)
{
return
manifest
;
}
}
return
null
;
}
getOrderedProviderList
(
onDone
)
{
SocialServiceInternal
.
orderedProviders
(
onDone
)
;
}
getOriginActivationType
(
origin
)
{
return
getOriginActivationType
(
origin
)
;
}
_providerListeners
:
new
Map
(
)
registerProviderListener
:
function
registerProviderListener
(
listener
)
{
this
.
_providerListeners
.
set
(
listener
1
)
;
}
unregisterProviderListener
:
function
unregisterProviderListener
(
listener
)
{
this
.
_providerListeners
.
delete
(
listener
)
;
}
_notifyProviderListeners
(
topic
origin
providers
)
{
for
(
let
[
listener
]
of
this
.
_providerListeners
)
{
try
{
listener
(
topic
origin
providers
)
;
}
catch
(
ex
)
{
Components
.
utils
.
reportError
(
"
SocialService
:
provider
listener
threw
an
exception
:
"
+
ex
)
;
}
}
}
_manifestFromData
(
type
data
installOrigin
)
{
let
featureURLs
=
[
"
shareURL
"
]
;
let
resolveURLs
=
featureURLs
.
concat
(
[
"
postActivationURL
"
]
)
;
if
(
type
=
=
"
directory
"
|
|
type
=
=
"
internal
"
)
{
if
(
!
data
[
"
origin
"
]
)
{
Cu
.
reportError
(
"
SocialService
.
manifestFromData
directory
service
provided
manifest
without
origin
.
"
)
;
return
null
;
}
installOrigin
=
data
.
origin
;
}
let
URI
=
Services
.
io
.
newURI
(
installOrigin
)
;
let
principal
=
Services
.
scriptSecurityManager
.
createCodebasePrincipal
(
URI
{
}
)
;
data
.
origin
=
principal
.
origin
;
let
providerHasFeatures
=
featureURLs
.
some
(
url
=
>
data
[
url
]
)
;
if
(
!
providerHasFeatures
)
{
Cu
.
reportError
(
"
SocialService
.
manifestFromData
manifest
missing
required
urls
.
"
)
;
return
null
;
}
if
(
!
data
[
"
name
"
]
|
|
!
data
[
"
iconURL
"
]
)
{
Cu
.
reportError
(
"
SocialService
.
manifestFromData
manifest
missing
name
or
iconURL
.
"
)
;
return
null
;
}
for
(
let
url
of
resolveURLs
)
{
if
(
data
[
url
]
)
{
try
{
let
resolved
=
Services
.
io
.
newURI
(
principal
.
URI
.
resolve
(
data
[
url
]
)
)
;
if
(
!
(
resolved
.
schemeIs
(
"
http
"
)
|
|
resolved
.
schemeIs
(
"
https
"
)
)
)
{
Cu
.
reportError
(
"
SocialService
.
manifestFromData
unsupported
scheme
'
"
+
resolved
.
scheme
+
"
'
for
"
+
principal
.
origin
)
;
return
null
;
}
data
[
url
]
=
resolved
.
spec
;
}
catch
(
e
)
{
Cu
.
reportError
(
"
SocialService
.
manifestFromData
unable
to
resolve
'
"
+
url
+
"
'
for
"
+
principal
.
origin
)
;
return
null
;
}
}
}
return
data
;
}
_showInstallNotification
(
data
aAddonInstaller
)
{
let
brandBundle
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
branding
/
locale
/
brand
.
properties
"
)
;
let
browserBundle
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
browser
/
locale
/
browser
.
properties
"
)
;
let
url
=
data
.
url
;
if
(
data
.
installType
=
=
"
internal
"
|
|
data
.
installType
=
=
"
directory
"
)
{
url
=
data
.
manifest
.
origin
;
}
let
requestingURI
=
Services
.
io
.
newURI
(
url
)
;
let
productName
=
brandBundle
.
GetStringFromName
(
"
brandShortName
"
)
;
let
message
=
browserBundle
.
formatStringFromName
(
"
service
.
install
.
description
"
[
requestingURI
.
host
productName
]
2
)
;
let
action
=
{
label
:
browserBundle
.
GetStringFromName
(
"
service
.
install
.
ok
.
label
"
)
accessKey
:
browserBundle
.
GetStringFromName
(
"
service
.
install
.
ok
.
accesskey
"
)
callback
(
)
{
aAddonInstaller
.
install
(
)
;
}
}
;
let
options
=
{
learnMoreURL
:
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
+
"
social
-
api
"
persistent
:
true
}
;
let
anchor
=
"
servicesInstall
-
notification
-
icon
"
;
let
notificationid
=
"
servicesInstall
"
;
data
.
window
.
PopupNotifications
.
show
(
data
.
window
.
gBrowser
.
selectedBrowser
notificationid
message
anchor
action
[
]
options
)
;
}
installProvider
(
data
installCallback
options
=
{
}
)
{
data
.
installType
=
getOriginActivationType
(
data
.
origin
)
;
let
manifest
=
this
.
_manifestFromData
(
data
.
installType
data
.
manifest
data
.
origin
)
;
if
(
!
manifest
)
throw
new
Error
(
"
SocialService
.
installProvider
:
service
configuration
is
invalid
from
"
+
data
.
url
)
;
let
addon
=
new
AddonWrapper
(
manifest
)
;
if
(
addon
&
&
addon
.
blocklistState
=
=
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
)
throw
new
Error
(
"
installProvider
:
provider
with
origin
[
"
+
data
.
origin
+
"
]
is
blocklisted
"
)
;
data
.
manifest
=
manifest
;
let
id
=
getAddonIDFromOrigin
(
manifest
.
origin
)
;
AddonManager
.
getAddonByID
(
id
aAddon
=
>
{
if
(
aAddon
&
&
aAddon
.
userDisabled
)
{
aAddon
.
cancelUninstall
(
)
;
aAddon
.
userDisabled
=
false
;
}
schedule
(
(
)
=
>
{
try
{
this
.
_installProvider
(
data
options
aManifest
=
>
{
this
.
_notifyProviderListeners
(
"
provider
-
installed
"
aManifest
.
origin
)
;
installCallback
(
aManifest
)
;
}
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
"
Activation
failed
:
"
+
e
)
;
installCallback
(
null
)
;
}
}
)
;
}
)
;
}
_installProvider
(
data
options
installCallback
)
{
if
(
!
data
.
manifest
)
throw
new
Error
(
"
Cannot
install
provider
without
manifest
data
"
)
;
if
(
data
.
installType
=
=
"
foreign
"
&
&
!
Services
.
prefs
.
getBoolPref
(
"
social
.
remote
-
install
.
enabled
"
)
)
throw
new
Error
(
"
Remote
install
of
services
is
disabled
"
)
;
if
(
data
.
installType
!
=
"
internal
"
&
&
!
Services
.
io
.
newURI
(
data
.
origin
)
.
schemeIs
(
"
https
"
)
)
{
throw
new
Error
(
"
attempt
to
activate
provider
over
unsecured
channel
:
"
+
data
.
origin
)
;
}
let
installer
=
new
AddonInstaller
(
data
.
url
data
.
manifest
installCallback
)
;
let
bypassPanel
=
options
.
bypassInstallPanel
|
|
(
data
.
installType
=
=
"
internal
"
&
&
data
.
manifest
.
oneclick
)
;
if
(
bypassPanel
)
installer
.
install
(
)
;
else
this
.
_showInstallNotification
(
data
installer
)
;
}
createWrapper
(
manifest
)
{
return
new
AddonWrapper
(
manifest
)
;
}
updateProvider
(
aUpdateOrigin
aManifest
)
{
let
installType
=
this
.
getOriginActivationType
(
aUpdateOrigin
)
;
let
manifest
=
this
.
_manifestFromData
(
installType
aManifest
aUpdateOrigin
)
;
if
(
!
manifest
)
throw
new
Error
(
"
SocialService
.
installProvider
:
service
configuration
is
invalid
from
"
+
aUpdateOrigin
)
;
Services
.
prefs
.
setStringPref
(
getPrefnameFromOrigin
(
manifest
.
origin
)
JSON
.
stringify
(
manifest
)
)
;
if
(
ActiveProviders
.
has
(
manifest
.
origin
)
)
{
let
provider
=
SocialServiceInternal
.
providers
[
manifest
.
origin
]
;
provider
.
enabled
=
false
;
provider
=
new
SocialProvider
(
manifest
)
;
SocialServiceInternal
.
providers
[
provider
.
origin
]
=
provider
;
this
.
getOrderedProviderList
(
providers
=
>
{
this
.
_notifyProviderListeners
(
"
provider
-
update
"
provider
.
origin
providers
)
;
}
)
;
}
}
uninstallProvider
(
origin
aCallback
)
{
let
manifest
=
SocialService
.
getManifestByOrigin
(
origin
)
;
let
addon
=
new
AddonWrapper
(
manifest
)
;
addon
.
uninstall
(
aCallback
)
;
}
}
;
function
SocialProvider
(
input
)
{
if
(
!
input
.
name
)
throw
new
Error
(
"
SocialProvider
must
be
passed
a
name
"
)
;
if
(
!
input
.
origin
)
throw
new
Error
(
"
SocialProvider
must
be
passed
an
origin
"
)
;
let
addon
=
new
AddonWrapper
(
input
)
;
if
(
addon
.
blocklistState
=
=
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
)
throw
new
Error
(
"
SocialProvider
:
provider
with
origin
[
"
+
input
.
origin
+
"
]
is
blocklisted
"
)
;
this
.
name
=
input
.
name
;
this
.
iconURL
=
input
.
iconURL
;
this
.
icon32URL
=
input
.
icon32URL
;
this
.
icon64URL
=
input
.
icon64URL
;
this
.
shareURL
=
input
.
shareURL
;
this
.
postActivationURL
=
input
.
postActivationURL
;
this
.
origin
=
input
.
origin
;
let
originUri
=
Services
.
io
.
newURI
(
input
.
origin
)
;
this
.
principal
=
Services
.
scriptSecurityManager
.
createCodebasePrincipal
(
originUri
{
}
)
;
this
.
ambientNotificationIcons
=
{
}
;
this
.
errorState
=
null
;
this
.
frecency
=
0
;
try
{
this
.
domain
=
etld
.
getBaseDomainFromHost
(
originUri
.
host
)
;
}
catch
(
e
)
{
this
.
domain
=
originUri
.
host
;
}
}
SocialProvider
.
prototype
=
{
reload
(
)
{
this
.
enabled
=
false
;
this
.
enabled
=
true
;
Services
.
obs
.
notifyObservers
(
null
"
social
:
provider
-
reload
"
this
.
origin
)
;
}
_enabled
:
false
get
enabled
(
)
{
return
this
.
_enabled
;
}
set
enabled
(
val
)
{
let
enable
=
!
!
val
;
if
(
enable
=
=
this
.
_enabled
)
return
;
this
.
_enabled
=
enable
;
if
(
enable
)
{
this
.
_activate
(
)
;
}
else
{
this
.
_terminate
(
)
;
}
}
get
manifest
(
)
{
return
SocialService
.
getManifestByOrigin
(
this
.
origin
)
;
}
getPageSize
(
name
)
{
let
manifest
=
this
.
manifest
;
if
(
manifest
&
&
manifest
.
pageSize
)
return
manifest
.
pageSize
[
name
]
;
return
undefined
;
}
_activate
:
function
_activate
(
)
{
}
_terminate
:
function
_terminate
(
)
{
this
.
errorState
=
null
;
}
isSameOrigin
:
function
isSameOrigin
(
uri
allowIfInheritsPrincipal
)
{
if
(
!
uri
)
return
false
;
if
(
typeof
uri
=
=
"
string
"
)
{
try
{
uri
=
Services
.
io
.
newURI
(
uri
)
;
}
catch
(
ex
)
{
return
false
;
}
}
try
{
this
.
principal
.
checkMayLoad
(
uri
false
allowIfInheritsPrincipal
)
;
return
true
;
}
catch
(
ex
)
{
return
false
;
}
}
resolveUri
:
function
resolveUri
(
url
)
{
try
{
let
fullURL
=
this
.
principal
.
URI
.
resolve
(
url
)
;
return
Services
.
io
.
newURI
(
fullURL
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
"
mozSocial
:
failed
to
resolve
window
URL
:
"
+
url
+
"
;
"
+
ex
)
;
return
null
;
}
}
}
;
function
getAddonIDFromOrigin
(
origin
)
{
let
originUri
=
Services
.
io
.
newURI
(
origin
)
;
return
originUri
.
host
+
ID_SUFFIX
;
}
function
getPrefnameFromOrigin
(
origin
)
{
return
"
social
.
manifest
.
"
+
SocialServiceInternal
.
getManifestPrefname
(
origin
)
;
}
function
AddonInstaller
(
sourceURI
aManifest
installCallback
)
{
aManifest
.
updateDate
=
Date
.
now
(
)
;
let
manifest
=
SocialService
.
getManifestByOrigin
(
aManifest
.
origin
)
;
let
isNewInstall
=
!
manifest
;
if
(
manifest
&
&
manifest
.
installDate
)
aManifest
.
installDate
=
manifest
.
installDate
;
else
aManifest
.
installDate
=
aManifest
.
updateDate
;
this
.
sourceURI
=
sourceURI
;
this
.
install
=
function
(
)
{
let
addon
=
this
.
addon
;
if
(
isNewInstall
)
{
AddonManagerPrivate
.
callInstallListeners
(
"
onExternalInstall
"
null
addon
null
false
)
;
AddonManagerPrivate
.
callAddonListeners
(
"
onInstalling
"
addon
false
)
;
}
Services
.
prefs
.
setStringPref
(
getPrefnameFromOrigin
(
aManifest
.
origin
)
JSON
.
stringify
(
aManifest
)
)
;
if
(
isNewInstall
)
{
AddonManagerPrivate
.
callAddonListeners
(
"
onInstalled
"
addon
)
;
}
installCallback
(
aManifest
)
;
}
;
this
.
cancel
=
function
(
)
{
Services
.
prefs
.
clearUserPref
(
getPrefnameFromOrigin
(
aManifest
.
origin
)
)
;
}
;
this
.
addon
=
new
AddonWrapper
(
aManifest
)
;
}
var
SocialAddonProvider
=
{
startup
(
)
{
}
shutdown
(
)
{
}
updateAddonAppDisabledStates
(
)
{
for
(
let
manifest
of
SocialServiceInternal
.
manifests
)
{
try
{
if
(
ActiveProviders
.
has
(
manifest
.
origin
)
)
{
let
addon
=
new
AddonWrapper
(
manifest
)
;
if
(
addon
.
blocklistState
!
=
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
{
SocialService
.
disableProvider
(
manifest
.
origin
)
;
}
}
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
}
getAddonByID
(
aId
aCallback
)
{
for
(
let
manifest
of
SocialServiceInternal
.
manifests
)
{
if
(
aId
=
=
getAddonIDFromOrigin
(
manifest
.
origin
)
)
{
aCallback
(
new
AddonWrapper
(
manifest
)
)
;
return
;
}
}
aCallback
(
null
)
;
}
getAddonsByTypes
(
aTypes
aCallback
)
{
if
(
aTypes
&
&
aTypes
.
indexOf
(
ADDON_TYPE_SERVICE
)
=
=
-
1
)
{
aCallback
(
[
]
)
;
return
;
}
aCallback
(
[
.
.
.
SocialServiceInternal
.
manifests
]
.
map
(
a
=
>
new
AddonWrapper
(
a
)
)
)
;
}
removeAddon
(
aAddon
aCallback
)
{
AddonManagerPrivate
.
callAddonListeners
(
"
onUninstalling
"
aAddon
false
)
;
aAddon
.
pendingOperations
|
=
AddonManager
.
PENDING_UNINSTALL
;
Services
.
prefs
.
clearUserPref
(
getPrefnameFromOrigin
(
aAddon
.
manifest
.
origin
)
)
;
aAddon
.
pendingOperations
-
=
AddonManager
.
PENDING_UNINSTALL
;
AddonManagerPrivate
.
callAddonListeners
(
"
onUninstalled
"
aAddon
)
;
SocialService
.
_notifyProviderListeners
(
"
provider
-
uninstalled
"
aAddon
.
manifest
.
origin
)
;
if
(
aCallback
)
schedule
(
aCallback
)
;
}
}
;
function
AddonWrapper
(
aManifest
)
{
this
.
manifest
=
aManifest
;
this
.
id
=
getAddonIDFromOrigin
(
this
.
manifest
.
origin
)
;
this
.
_pending
=
AddonManager
.
PENDING_NONE
;
}
AddonWrapper
.
prototype
=
{
get
type
(
)
{
return
ADDON_TYPE_SERVICE
;
}
get
appDisabled
(
)
{
return
this
.
blocklistState
=
=
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
;
}
set
softDisabled
(
val
)
{
this
.
userDisabled
=
val
;
}
get
softDisabled
(
)
{
return
this
.
userDisabled
;
}
get
isCompatible
(
)
{
return
true
;
}
get
isPlatformCompatible
(
)
{
return
true
;
}
get
scope
(
)
{
return
AddonManager
.
SCOPE_PROFILE
;
}
get
foreignInstall
(
)
{
return
false
;
}
isCompatibleWith
(
appVersion
platformVersion
)
{
return
true
;
}
get
providesUpdatesSecurely
(
)
{
return
true
;
}
get
blocklistState
(
)
{
return
Services
.
blocklist
.
getAddonBlocklistState
(
this
)
;
}
get
blocklistURL
(
)
{
return
Services
.
blocklist
.
getAddonBlocklistURL
(
this
)
;
}
get
screenshots
(
)
{
return
[
]
;
}
get
pendingOperations
(
)
{
return
this
.
_pending
|
|
AddonManager
.
PENDING_NONE
;
}
set
pendingOperations
(
val
)
{
this
.
_pending
=
val
;
}
get
operationsRequiringRestart
(
)
{
return
AddonManager
.
OP_NEEDS_RESTART_NONE
;
}
get
size
(
)
{
return
null
;
}
get
permissions
(
)
{
let
permissions
=
0
;
if
(
Services
.
prefs
.
prefHasUserValue
(
getPrefnameFromOrigin
(
this
.
manifest
.
origin
)
)
)
permissions
=
AddonManager
.
PERM_CAN_UNINSTALL
;
if
(
!
this
.
appDisabled
)
{
if
(
this
.
userDisabled
)
{
permissions
|
=
AddonManager
.
PERM_CAN_ENABLE
;
}
else
{
permissions
|
=
AddonManager
.
PERM_CAN_DISABLE
;
}
}
return
permissions
;
}
findUpdates
(
listener
reason
appVersion
platformVersion
)
{
if
(
"
onNoCompatibilityUpdateAvailable
"
in
listener
)
listener
.
onNoCompatibilityUpdateAvailable
(
this
)
;
if
(
"
onNoUpdateAvailable
"
in
listener
)
listener
.
onNoUpdateAvailable
(
this
)
;
if
(
"
onUpdateFinished
"
in
listener
)
listener
.
onUpdateFinished
(
this
)
;
}
get
isActive
(
)
{
return
ActiveProviders
.
has
(
this
.
manifest
.
origin
)
;
}
get
name
(
)
{
return
this
.
manifest
.
name
;
}
get
version
(
)
{
return
this
.
manifest
.
version
?
this
.
manifest
.
version
.
toString
(
)
:
"
"
;
}
get
iconURL
(
)
{
return
this
.
manifest
.
icon32URL
?
this
.
manifest
.
icon32URL
:
this
.
manifest
.
iconURL
;
}
get
icon64URL
(
)
{
return
this
.
manifest
.
icon64URL
;
}
get
icons
(
)
{
let
icons
=
{
16
:
this
.
manifest
.
iconURL
}
;
if
(
this
.
manifest
.
icon32URL
)
icons
[
32
]
=
this
.
manifest
.
icon32URL
;
if
(
this
.
manifest
.
icon64URL
)
icons
[
64
]
=
this
.
manifest
.
icon64URL
;
return
icons
;
}
get
description
(
)
{
return
this
.
manifest
.
description
;
}
get
homepageURL
(
)
{
return
this
.
manifest
.
homepageURL
;
}
get
defaultLocale
(
)
{
return
this
.
manifest
.
defaultLocale
;
}
get
selectedLocale
(
)
{
return
this
.
manifest
.
selectedLocale
;
}
get
installDate
(
)
{
return
this
.
manifest
.
installDate
?
new
Date
(
this
.
manifest
.
installDate
)
:
null
;
}
get
updateDate
(
)
{
return
this
.
manifest
.
updateDate
?
new
Date
(
this
.
manifest
.
updateDate
)
:
null
;
}
get
creator
(
)
{
return
new
AddonManagerPrivate
.
AddonAuthor
(
this
.
manifest
.
author
)
;
}
get
userDisabled
(
)
{
return
this
.
appDisabled
|
|
!
ActiveProviders
.
has
(
this
.
manifest
.
origin
)
;
}
set
userDisabled
(
val
)
{
if
(
val
=
=
this
.
userDisabled
)
return
val
;
if
(
val
)
{
SocialService
.
disableProvider
(
this
.
manifest
.
origin
)
;
}
else
if
(
!
this
.
appDisabled
)
{
SocialService
.
enableProvider
(
this
.
manifest
.
origin
)
;
}
return
val
;
}
uninstall
(
aCallback
)
{
let
prefName
=
getPrefnameFromOrigin
(
this
.
manifest
.
origin
)
;
if
(
Services
.
prefs
.
prefHasUserValue
(
prefName
)
)
{
if
(
ActiveProviders
.
has
(
this
.
manifest
.
origin
)
)
{
SocialService
.
disableProvider
(
this
.
manifest
.
origin
(
)
=
>
{
SocialAddonProvider
.
removeAddon
(
this
aCallback
)
;
}
)
;
}
else
{
SocialAddonProvider
.
removeAddon
(
this
aCallback
)
;
}
}
else
{
schedule
(
aCallback
)
;
}
}
cancelUninstall
(
)
{
this
.
_pending
-
=
AddonManager
.
PENDING_UNINSTALL
;
AddonManagerPrivate
.
callAddonListeners
(
"
onOperationCancelled
"
this
)
;
}
}
;
AddonManagerPrivate
.
registerProvider
(
SocialAddonProvider
[
new
AddonManagerPrivate
.
AddonType
(
ADDON_TYPE_SERVICE
URI_EXTENSION_STRINGS
STRING_TYPE_NAME
AddonManager
.
VIEW_TYPE_LIST
10000
)
]
)
;
