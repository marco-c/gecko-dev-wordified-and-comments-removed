var
EXPORTED_SYMBOLS
=
[
"
AeroPeek
"
]
;
const
{
NetUtil
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
const
{
PlacesUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
const
{
PrivateBrowsingUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
TOGGLE_PREF_NAME
=
"
browser
.
taskbar
.
previews
.
enable
"
;
const
DISABLE_THRESHOLD_PREF_NAME
=
"
browser
.
taskbar
.
previews
.
max
"
;
const
CACHE_EXPIRATION_TIME_PREF_NAME
=
"
browser
.
taskbar
.
previews
.
cachetime
"
;
const
WINTASKBAR_CONTRACTID
=
"
mozilla
.
org
/
windows
-
taskbar
;
1
"
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyServiceGetter
(
lazy
"
imgTools
"
"
mozilla
.
org
/
image
/
tools
;
1
"
"
imgITools
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
PageThumbs
"
"
resource
:
/
/
gre
/
modules
/
PageThumbs
.
jsm
"
)
;
function
_imageFromURI
(
uri
privateMode
callback
)
{
let
channel
=
NetUtil
.
newChannel
(
{
uri
loadUsingSystemPrincipal
:
true
contentPolicyType
:
Ci
.
nsIContentPolicy
.
TYPE_INTERNAL_IMAGE
}
)
;
try
{
channel
.
QueryInterface
(
Ci
.
nsIPrivateBrowsingChannel
)
;
channel
.
setPrivate
(
privateMode
)
;
}
catch
(
e
)
{
}
NetUtil
.
asyncFetch
(
channel
function
(
inputStream
resultCode
)
{
if
(
!
Components
.
isSuccessCode
(
resultCode
)
)
{
return
;
}
const
decodeCallback
=
{
onImageReady
(
image
status
)
{
if
(
!
image
)
{
let
defaultURI
=
PlacesUtils
.
favicons
.
defaultFavicon
;
if
(
!
defaultURI
.
equals
(
uri
)
)
{
_imageFromURI
(
defaultURI
privateMode
callback
)
;
return
;
}
}
callback
(
image
)
;
}
}
;
try
{
let
threadManager
=
Cc
[
"
mozilla
.
org
/
thread
-
manager
;
1
"
]
.
getService
(
)
;
lazy
.
imgTools
.
decodeImageAsync
(
inputStream
channel
.
contentType
decodeCallback
threadManager
.
currentThread
)
;
}
catch
(
e
)
{
let
defaultURI
=
PlacesUtils
.
favicons
.
defaultFavicon
;
if
(
!
defaultURI
.
equals
(
uri
)
)
{
_imageFromURI
(
defaultURI
privateMode
callback
)
;
}
}
}
)
;
}
function
getFaviconAsImage
(
iconurl
privateMode
callback
)
{
if
(
iconurl
)
{
_imageFromURI
(
NetUtil
.
newURI
(
iconurl
)
privateMode
callback
)
;
}
else
{
_imageFromURI
(
PlacesUtils
.
favicons
.
defaultFavicon
privateMode
callback
)
;
}
}
function
PreviewController
(
win
tab
)
{
this
.
win
=
win
;
this
.
tab
=
tab
;
this
.
linkedBrowser
=
tab
.
linkedBrowser
;
this
.
preview
=
this
.
win
.
createTabPreview
(
this
)
;
this
.
tab
.
addEventListener
(
"
TabAttrModified
"
this
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
canvasPreview
"
function
(
)
{
let
canvas
=
lazy
.
PageThumbs
.
createCanvas
(
this
.
win
.
win
)
;
canvas
.
mozOpaque
=
true
;
return
canvas
;
}
)
;
}
PreviewController
.
prototype
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsITaskbarPreviewController
"
]
)
destroy
(
)
{
this
.
tab
.
removeEventListener
(
"
TabAttrModified
"
this
)
;
delete
this
.
win
;
delete
this
.
preview
;
}
get
wrappedJSObject
(
)
{
return
this
;
}
resetCanvasPreview
(
)
{
this
.
canvasPreview
.
width
=
0
;
this
.
canvasPreview
.
height
=
0
;
}
resizeCanvasPreview
(
aRequestedWidth
aRequestedHeight
)
{
this
.
canvasPreview
.
width
=
aRequestedWidth
;
this
.
canvasPreview
.
height
=
aRequestedHeight
;
}
get
browserDims
(
)
{
return
this
.
tab
.
linkedBrowser
.
getBoundingClientRect
(
)
;
}
cacheBrowserDims
(
)
{
let
dims
=
this
.
browserDims
;
this
.
_cachedWidth
=
dims
.
width
;
this
.
_cachedHeight
=
dims
.
height
;
}
testCacheBrowserDims
(
)
{
let
dims
=
this
.
browserDims
;
return
this
.
_cachedWidth
=
=
dims
.
width
&
&
this
.
_cachedHeight
=
=
dims
.
height
;
}
updateCanvasPreview
(
aFullScale
)
{
this
.
cacheBrowserDims
(
)
;
AeroPeek
.
resetCacheTimer
(
)
;
return
lazy
.
PageThumbs
.
captureToCanvas
(
this
.
linkedBrowser
this
.
canvasPreview
{
fullScale
:
aFullScale
}
)
.
catch
(
e
=
>
Cu
.
reportError
(
e
)
)
;
}
updateTitleAndTooltip
(
)
{
let
title
=
this
.
win
.
tabbrowser
.
getWindowTitleForBrowser
(
this
.
linkedBrowser
)
;
this
.
preview
.
title
=
title
;
this
.
preview
.
tooltip
=
title
;
}
get
width
(
)
{
return
this
.
win
.
width
;
}
get
height
(
)
{
return
this
.
win
.
height
;
}
get
thumbnailAspectRatio
(
)
{
let
browserDims
=
this
.
browserDims
;
let
tabWidth
=
browserDims
.
width
|
|
1
;
let
tabHeight
=
browserDims
.
height
|
|
1
;
return
tabWidth
/
tabHeight
;
}
requestPreview
(
aTaskbarCallback
)
{
this
.
resetCanvasPreview
(
)
;
this
.
updateCanvasPreview
(
true
)
.
then
(
aPreviewCanvas
=
>
{
let
winWidth
=
this
.
win
.
width
;
let
winHeight
=
this
.
win
.
height
;
let
composite
=
lazy
.
PageThumbs
.
createCanvas
(
this
.
win
.
win
)
;
composite
.
mozOpaque
=
false
;
let
ctx
=
composite
.
getContext
(
"
2d
"
)
;
let
scale
=
this
.
win
.
devicePixelRatio
;
composite
.
width
=
winWidth
*
scale
;
composite
.
height
=
winHeight
*
scale
;
ctx
.
save
(
)
;
ctx
.
scale
(
scale
scale
)
;
ctx
.
drawWindow
(
this
.
win
.
win
0
0
winWidth
winHeight
"
rgba
(
0
0
0
0
)
"
)
;
ctx
.
drawImage
(
aPreviewCanvas
this
.
browserDims
.
x
this
.
browserDims
.
y
aPreviewCanvas
.
width
aPreviewCanvas
.
height
)
;
ctx
.
restore
(
)
;
this
.
win
.
tabbrowser
.
previewTab
(
this
.
tab
function
(
)
{
aTaskbarCallback
.
done
(
composite
false
)
;
}
)
;
}
)
;
}
requestThumbnail
(
aTaskbarCallback
aRequestedWidth
aRequestedHeight
)
{
this
.
resizeCanvasPreview
(
aRequestedWidth
aRequestedHeight
)
;
this
.
updateCanvasPreview
(
false
)
.
then
(
aThumbnailCanvas
=
>
{
aTaskbarCallback
.
done
(
aThumbnailCanvas
false
)
;
}
)
;
}
onClose
(
)
{
this
.
win
.
tabbrowser
.
removeTab
(
this
.
tab
)
;
}
onActivate
(
)
{
this
.
win
.
tabbrowser
.
selectedTab
=
this
.
tab
;
return
true
;
}
handleEvent
(
evt
)
{
switch
(
evt
.
type
)
{
case
"
TabAttrModified
"
:
this
.
updateTitleAndTooltip
(
)
;
break
;
}
}
}
;
function
TabWindow
(
win
)
{
this
.
win
=
win
;
this
.
tabbrowser
=
win
.
gBrowser
;
this
.
previews
=
new
Map
(
)
;
for
(
let
i
=
0
;
i
<
this
.
tabEvents
.
length
;
i
+
+
)
{
this
.
tabbrowser
.
tabContainer
.
addEventListener
(
this
.
tabEvents
[
i
]
this
)
;
}
for
(
let
i
=
0
;
i
<
this
.
winEvents
.
length
;
i
+
+
)
{
this
.
win
.
addEventListener
(
this
.
winEvents
[
i
]
this
)
;
}
this
.
tabbrowser
.
addTabsProgressListener
(
this
)
;
AeroPeek
.
windows
.
push
(
this
)
;
let
tabs
=
this
.
tabbrowser
.
tabs
;
for
(
let
i
=
0
;
i
<
tabs
.
length
;
i
+
+
)
{
this
.
newTab
(
tabs
[
i
]
)
;
}
this
.
updateTabOrdering
(
)
;
AeroPeek
.
checkPreviewCount
(
)
;
}
TabWindow
.
prototype
=
{
_enabled
:
false
_cachedWidth
:
0
_cachedHeight
:
0
tabEvents
:
[
"
TabOpen
"
"
TabClose
"
"
TabSelect
"
"
TabMove
"
]
winEvents
:
[
"
resize
"
]
destroy
(
)
{
this
.
_destroying
=
true
;
let
tabs
=
this
.
tabbrowser
.
tabs
;
this
.
tabbrowser
.
removeTabsProgressListener
(
this
)
;
for
(
let
i
=
0
;
i
<
this
.
winEvents
.
length
;
i
+
+
)
{
this
.
win
.
removeEventListener
(
this
.
winEvents
[
i
]
this
)
;
}
for
(
let
i
=
0
;
i
<
this
.
tabEvents
.
length
;
i
+
+
)
{
this
.
tabbrowser
.
tabContainer
.
removeEventListener
(
this
.
tabEvents
[
i
]
this
)
;
}
for
(
let
i
=
0
;
i
<
tabs
.
length
;
i
+
+
)
{
this
.
removeTab
(
tabs
[
i
]
)
;
}
let
idx
=
AeroPeek
.
windows
.
indexOf
(
this
.
win
.
gTaskbarTabGroup
)
;
AeroPeek
.
windows
.
splice
(
idx
1
)
;
AeroPeek
.
checkPreviewCount
(
)
;
}
get
width
(
)
{
return
this
.
win
.
innerWidth
;
}
get
height
(
)
{
return
this
.
win
.
innerHeight
;
}
cacheDims
(
)
{
this
.
_cachedWidth
=
this
.
width
;
this
.
_cachedHeight
=
this
.
height
;
}
testCacheDims
(
)
{
return
this
.
_cachedWidth
=
=
this
.
width
&
&
this
.
_cachedHeight
=
=
this
.
height
;
}
newTab
(
tab
)
{
let
controller
=
new
PreviewController
(
this
tab
)
;
this
.
previews
.
set
(
tab
controller
.
preview
)
;
AeroPeek
.
addPreview
(
controller
.
preview
)
;
controller
.
updateTitleAndTooltip
(
)
;
}
createTabPreview
(
controller
)
{
let
docShell
=
this
.
win
.
docShell
;
let
preview
=
AeroPeek
.
taskbar
.
createTaskbarTabPreview
(
docShell
controller
)
;
preview
.
visible
=
AeroPeek
.
enabled
;
let
{
tab
}
=
controller
;
preview
.
active
=
this
.
tabbrowser
.
selectedTab
=
=
tab
;
this
.
updateFavicon
(
tab
tab
.
getAttribute
(
"
image
"
)
)
;
return
preview
;
}
removeTab
(
tab
)
{
let
preview
=
this
.
previewFromTab
(
tab
)
;
preview
.
active
=
false
;
preview
.
visible
=
false
;
preview
.
move
(
null
)
;
preview
.
controller
.
wrappedJSObject
.
destroy
(
)
;
this
.
previews
.
delete
(
tab
)
;
AeroPeek
.
removePreview
(
preview
)
;
}
get
enabled
(
)
{
return
this
.
_enabled
;
}
set
enabled
(
enable
)
{
this
.
_enabled
=
enable
;
for
(
let
[
preview
]
of
this
.
previews
)
{
preview
.
move
(
null
)
;
preview
.
visible
=
enable
;
}
this
.
updateTabOrdering
(
)
;
}
previewFromTab
(
tab
)
{
return
this
.
previews
.
get
(
tab
)
;
}
updateTabOrdering
(
)
{
let
previews
=
this
.
previews
;
let
tabs
=
this
.
tabbrowser
.
tabs
;
let
inorder
=
[
]
;
for
(
let
t
of
tabs
)
{
if
(
previews
.
has
(
t
)
)
{
inorder
.
push
(
previews
.
get
(
t
)
)
;
}
}
for
(
let
i
=
inorder
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
inorder
[
i
]
.
move
(
inorder
[
i
+
1
]
|
|
null
)
;
}
}
handleEvent
(
evt
)
{
let
tab
=
evt
.
originalTarget
;
switch
(
evt
.
type
)
{
case
"
TabOpen
"
:
this
.
newTab
(
tab
)
;
this
.
updateTabOrdering
(
)
;
break
;
case
"
TabClose
"
:
this
.
removeTab
(
tab
)
;
this
.
updateTabOrdering
(
)
;
break
;
case
"
TabSelect
"
:
this
.
previewFromTab
(
tab
)
.
active
=
true
;
break
;
case
"
TabMove
"
:
this
.
updateTabOrdering
(
)
;
break
;
case
"
resize
"
:
if
(
!
AeroPeek
.
_prefenabled
)
{
return
;
}
this
.
onResize
(
)
;
break
;
}
}
setInvalidationTimer
(
)
{
if
(
!
this
.
invalidateTimer
)
{
this
.
invalidateTimer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
}
this
.
invalidateTimer
.
cancel
(
)
;
this
.
invalidateTimer
.
initWithCallback
(
(
)
=
>
{
this
.
previews
.
forEach
(
function
(
aPreview
)
{
let
controller
=
aPreview
.
controller
.
wrappedJSObject
;
if
(
!
controller
.
testCacheBrowserDims
(
)
)
{
controller
.
cacheBrowserDims
(
)
;
aPreview
.
invalidate
(
)
;
}
}
)
;
}
1000
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
onResize
(
)
{
if
(
this
.
testCacheDims
(
)
)
{
return
;
}
this
.
cacheDims
(
)
;
this
.
setInvalidationTimer
(
)
;
}
invalidateTabPreview
(
aBrowser
)
{
for
(
let
[
tab
preview
]
of
this
.
previews
)
{
if
(
aBrowser
=
=
tab
.
linkedBrowser
)
{
preview
.
invalidate
(
)
;
break
;
}
}
}
onLocationChange
(
aBrowser
)
{
}
onStateChange
(
aBrowser
aWebProgress
aRequest
aStateFlags
aStatus
)
{
if
(
aStateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_STOP
&
&
aStateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_IS_NETWORK
)
{
this
.
invalidateTabPreview
(
aBrowser
)
;
}
}
directRequestProtocols
:
new
Set
(
[
"
file
"
"
chrome
"
"
resource
"
"
about
"
"
data
"
]
)
onLinkIconAvailable
(
aBrowser
aIconURL
)
{
let
tab
=
this
.
win
.
gBrowser
.
getTabForBrowser
(
aBrowser
)
;
this
.
updateFavicon
(
tab
aIconURL
)
;
}
updateFavicon
(
aTab
aIconURL
)
{
let
requestURL
=
null
;
if
(
aIconURL
)
{
let
shouldRequestFaviconURL
=
true
;
try
{
let
urlObject
=
NetUtil
.
newURI
(
aIconURL
)
;
shouldRequestFaviconURL
=
!
this
.
directRequestProtocols
.
has
(
urlObject
.
scheme
)
;
}
catch
(
ex
)
{
}
requestURL
=
shouldRequestFaviconURL
?
"
moz
-
anno
:
favicon
:
"
+
aIconURL
:
aIconURL
;
}
let
isDefaultFavicon
=
!
requestURL
;
getFaviconAsImage
(
requestURL
PrivateBrowsingUtils
.
isWindowPrivate
(
this
.
win
)
img
=
>
{
if
(
this
.
win
.
closed
|
|
aTab
.
closing
|
|
!
aTab
.
linkedBrowser
)
{
return
;
}
let
preview
=
this
.
previews
.
get
(
aTab
)
;
if
(
aTab
.
getAttribute
(
"
image
"
)
=
=
aIconURL
|
|
(
!
preview
.
icon
&
&
isDefaultFavicon
)
)
{
preview
.
icon
=
img
;
}
}
)
;
}
}
;
var
AeroPeek
=
{
available
:
false
__prefenabled
:
false
_enabled
:
true
initialized
:
false
previews
:
[
]
windows
:
[
]
taskbar
:
null
maxpreviews
:
20
cacheLifespan
:
20
initialize
(
)
{
if
(
!
(
WINTASKBAR_CONTRACTID
in
Cc
)
)
{
return
;
}
this
.
taskbar
=
Cc
[
WINTASKBAR_CONTRACTID
]
.
getService
(
Ci
.
nsIWinTaskbar
)
;
this
.
available
=
this
.
taskbar
.
available
;
if
(
!
this
.
available
)
{
return
;
}
Services
.
prefs
.
addObserver
(
TOGGLE_PREF_NAME
this
true
)
;
this
.
enabled
=
this
.
_prefenabled
=
Services
.
prefs
.
getBoolPref
(
TOGGLE_PREF_NAME
)
;
this
.
initialized
=
true
;
}
destroy
:
function
destroy
(
)
{
this
.
_enabled
=
false
;
if
(
this
.
cacheTimer
)
{
this
.
cacheTimer
.
cancel
(
)
;
}
}
get
enabled
(
)
{
return
this
.
_enabled
;
}
set
enabled
(
enable
)
{
if
(
this
.
_enabled
=
=
enable
)
{
return
;
}
this
.
_enabled
=
enable
;
this
.
windows
.
forEach
(
function
(
win
)
{
win
.
enabled
=
enable
;
}
)
;
}
get
_prefenabled
(
)
{
return
this
.
__prefenabled
;
}
set
_prefenabled
(
enable
)
{
if
(
enable
=
=
this
.
__prefenabled
)
{
return
;
}
this
.
__prefenabled
=
enable
;
if
(
enable
)
{
this
.
enable
(
)
;
}
else
{
this
.
disable
(
)
;
}
}
_observersAdded
:
false
enable
(
)
{
if
(
!
this
.
_observersAdded
)
{
Services
.
prefs
.
addObserver
(
DISABLE_THRESHOLD_PREF_NAME
this
true
)
;
Services
.
prefs
.
addObserver
(
CACHE_EXPIRATION_TIME_PREF_NAME
this
true
)
;
this
.
_placesListener
=
this
.
handlePlacesEvents
.
bind
(
this
)
;
PlacesUtils
.
observers
.
addListener
(
[
"
favicon
-
changed
"
]
this
.
_placesListener
)
;
this
.
_observersAdded
=
true
;
}
this
.
cacheLifespan
=
Services
.
prefs
.
getIntPref
(
CACHE_EXPIRATION_TIME_PREF_NAME
)
;
this
.
maxpreviews
=
Services
.
prefs
.
getIntPref
(
DISABLE_THRESHOLD_PREF_NAME
)
;
if
(
this
.
initialized
)
{
for
(
let
win
of
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
)
{
if
(
!
win
.
closed
)
{
this
.
onOpenWindow
(
win
)
;
}
}
}
}
disable
(
)
{
while
(
this
.
windows
.
length
)
{
let
tabWinObject
=
this
.
windows
[
0
]
;
tabWinObject
.
destroy
(
)
;
delete
tabWinObject
.
win
.
gTaskbarTabGroup
;
}
PlacesUtils
.
observers
.
removeListener
(
[
"
favicon
-
changed
"
]
this
.
_placesListener
)
;
}
addPreview
(
preview
)
{
this
.
previews
.
push
(
preview
)
;
this
.
checkPreviewCount
(
)
;
}
removePreview
(
preview
)
{
let
idx
=
this
.
previews
.
indexOf
(
preview
)
;
this
.
previews
.
splice
(
idx
1
)
;
this
.
checkPreviewCount
(
)
;
}
checkPreviewCount
(
)
{
if
(
!
this
.
_prefenabled
)
{
return
;
}
this
.
enabled
=
this
.
previews
.
length
<
=
this
.
maxpreviews
;
}
onOpenWindow
(
win
)
{
if
(
!
this
.
available
|
|
!
this
.
_prefenabled
)
{
return
;
}
win
.
gTaskbarTabGroup
=
new
TabWindow
(
win
)
;
}
onCloseWindow
(
win
)
{
if
(
!
this
.
available
|
|
!
this
.
_prefenabled
)
{
return
;
}
win
.
gTaskbarTabGroup
.
destroy
(
)
;
delete
win
.
gTaskbarTabGroup
;
if
(
!
this
.
windows
.
length
)
{
this
.
destroy
(
)
;
}
}
resetCacheTimer
(
)
{
this
.
cacheTimer
.
cancel
(
)
;
this
.
cacheTimer
.
init
(
this
1000
*
this
.
cacheLifespan
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
observe
(
aSubject
aTopic
aData
)
{
if
(
aTopic
=
=
"
nsPref
:
changed
"
&
&
aData
=
=
TOGGLE_PREF_NAME
)
{
this
.
_prefenabled
=
Services
.
prefs
.
getBoolPref
(
TOGGLE_PREF_NAME
)
;
}
if
(
!
this
.
_prefenabled
)
{
return
;
}
switch
(
aTopic
)
{
case
"
nsPref
:
changed
"
:
if
(
aData
=
=
CACHE_EXPIRATION_TIME_PREF_NAME
)
{
break
;
}
if
(
aData
=
=
DISABLE_THRESHOLD_PREF_NAME
)
{
this
.
maxpreviews
=
Services
.
prefs
.
getIntPref
(
DISABLE_THRESHOLD_PREF_NAME
)
;
}
this
.
checkPreviewCount
(
)
;
break
;
case
"
timer
-
callback
"
:
this
.
previews
.
forEach
(
function
(
preview
)
{
let
controller
=
preview
.
controller
.
wrappedJSObject
;
controller
.
resetCanvasPreview
(
)
;
}
)
;
break
;
}
}
handlePlacesEvents
(
events
)
{
for
(
let
event
of
events
)
{
switch
(
event
.
type
)
{
case
"
favicon
-
changed
"
:
{
for
(
let
win
of
this
.
windows
)
{
for
(
let
[
tab
]
of
win
.
previews
)
{
if
(
tab
.
getAttribute
(
"
image
"
)
=
=
event
.
faviconUrl
)
{
win
.
updateFavicon
(
tab
event
.
faviconUrl
)
;
}
}
}
}
}
}
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsISupportsWeakReference
"
"
nsIObserver
"
]
)
}
;
XPCOMUtils
.
defineLazyGetter
(
AeroPeek
"
cacheTimer
"
(
)
=
>
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
)
;
AeroPeek
.
initialize
(
)
;
