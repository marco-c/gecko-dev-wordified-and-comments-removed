this
.
EXPORTED_SYMBOLS
=
[
"
AeroPeek
"
]
;
const
Cc
=
Components
.
classes
;
const
Ci
=
Components
.
interfaces
;
const
Cu
=
Components
.
utils
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
TOGGLE_PREF_NAME
=
"
browser
.
taskbar
.
previews
.
enable
"
;
const
DISABLE_THRESHOLD_PREF_NAME
=
"
browser
.
taskbar
.
previews
.
max
"
;
const
CACHE_EXPIRATION_TIME_PREF_NAME
=
"
browser
.
taskbar
.
previews
.
cachetime
"
;
const
WINTASKBAR_CONTRACTID
=
"
mozilla
.
org
/
windows
-
taskbar
;
1
"
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
imgTools
"
"
mozilla
.
org
/
image
/
tools
;
1
"
"
imgITools
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PageThumbs
"
"
resource
:
/
/
gre
/
modules
/
PageThumbs
.
jsm
"
)
;
function
_imageFromURI
(
uri
privateMode
callback
)
{
let
channel
=
NetUtil
.
newChannel
(
{
uri
:
uri
loadUsingSystemPrincipal
:
true
contentPolicyType
:
Ci
.
nsIContentPolicy
.
TYPE_INTERNAL_IMAGE
}
)
;
try
{
channel
.
QueryInterface
(
Ci
.
nsIPrivateBrowsingChannel
)
;
channel
.
setPrivate
(
privateMode
)
;
}
catch
(
e
)
{
}
NetUtil
.
asyncFetch
(
channel
function
(
inputStream
resultCode
)
{
if
(
!
Components
.
isSuccessCode
(
resultCode
)
)
return
;
try
{
let
out_img
=
{
value
:
null
}
;
imgTools
.
decodeImageData
(
inputStream
channel
.
contentType
out_img
)
;
callback
(
out_img
.
value
)
;
}
catch
(
e
)
{
let
defaultURI
=
PlacesUtils
.
favicons
.
defaultFavicon
;
if
(
!
defaultURI
.
equals
(
uri
)
)
_imageFromURI
(
defaultURI
privateMode
callback
)
;
}
}
)
;
}
function
getFaviconAsImage
(
iconurl
privateMode
callback
)
{
if
(
iconurl
)
{
_imageFromURI
(
NetUtil
.
newURI
(
iconurl
)
privateMode
callback
)
;
}
else
{
_imageFromURI
(
PlacesUtils
.
favicons
.
defaultFavicon
privateMode
callback
)
;
}
}
function
snapRectAtScale
(
r
scale
)
{
let
x
=
Math
.
floor
(
r
.
x
*
scale
)
;
let
y
=
Math
.
floor
(
r
.
y
*
scale
)
;
let
width
=
Math
.
ceil
(
(
r
.
x
+
r
.
width
)
*
scale
)
-
x
;
let
height
=
Math
.
ceil
(
(
r
.
y
+
r
.
height
)
*
scale
)
-
y
;
r
.
x
=
x
/
scale
;
r
.
y
=
y
/
scale
;
r
.
width
=
width
/
scale
;
r
.
height
=
height
/
scale
;
}
function
PreviewController
(
win
tab
)
{
this
.
win
=
win
;
this
.
tab
=
tab
;
this
.
linkedBrowser
=
tab
.
linkedBrowser
;
this
.
preview
=
this
.
win
.
createTabPreview
(
this
)
;
this
.
tab
.
addEventListener
(
"
TabAttrModified
"
this
false
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
canvasPreview
"
function
(
)
{
let
canvas
=
PageThumbs
.
createCanvas
(
)
;
canvas
.
mozOpaque
=
true
;
return
canvas
;
}
)
;
}
PreviewController
.
prototype
=
{
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsITaskbarPreviewController
Ci
.
nsIDOMEventListener
]
)
destroy
:
function
(
)
{
this
.
tab
.
removeEventListener
(
"
TabAttrModified
"
this
false
)
;
delete
this
.
win
;
delete
this
.
preview
;
}
get
wrappedJSObject
(
)
{
return
this
;
}
resetCanvasPreview
:
function
(
)
{
this
.
canvasPreview
.
width
=
0
;
this
.
canvasPreview
.
height
=
0
;
}
resizeCanvasPreview
:
function
(
aRequestedWidth
aRequestedHeight
)
{
this
.
canvasPreview
.
width
=
aRequestedWidth
;
this
.
canvasPreview
.
height
=
aRequestedHeight
;
}
get
zoom
(
)
{
return
this
.
tab
.
linkedBrowser
.
fullZoom
;
}
get
screenPixelsPerCSSPixel
(
)
{
let
chromeWin
=
this
.
tab
.
ownerGlobal
;
let
windowUtils
=
chromeWin
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
return
windowUtils
.
screenPixelsPerCSSPixel
;
}
get
browserDims
(
)
{
return
this
.
tab
.
linkedBrowser
.
getBoundingClientRect
(
)
;
}
cacheBrowserDims
:
function
(
)
{
let
dims
=
this
.
browserDims
;
this
.
_cachedWidth
=
dims
.
width
;
this
.
_cachedHeight
=
dims
.
height
;
}
testCacheBrowserDims
:
function
(
)
{
let
dims
=
this
.
browserDims
;
return
this
.
_cachedWidth
=
=
dims
.
width
&
&
this
.
_cachedHeight
=
=
dims
.
height
;
}
updateCanvasPreview
:
function
(
aFullScale
aCallback
)
{
this
.
cacheBrowserDims
(
)
;
PageThumbs
.
captureToCanvas
(
this
.
linkedBrowser
this
.
canvasPreview
aCallback
{
fullScale
:
aFullScale
}
)
;
AeroPeek
.
resetCacheTimer
(
)
;
}
updateTitleAndTooltip
:
function
(
)
{
let
title
=
this
.
win
.
tabbrowser
.
getWindowTitleForBrowser
(
this
.
linkedBrowser
)
;
this
.
preview
.
title
=
title
;
this
.
preview
.
tooltip
=
title
;
}
get
width
(
)
{
return
this
.
win
.
width
;
}
get
height
(
)
{
return
this
.
win
.
height
;
}
get
thumbnailAspectRatio
(
)
{
let
browserDims
=
this
.
browserDims
;
let
tabWidth
=
browserDims
.
width
|
|
1
;
let
tabHeight
=
browserDims
.
height
|
|
1
;
return
tabWidth
/
tabHeight
;
}
requestPreview
:
function
(
aTaskbarCallback
)
{
this
.
resetCanvasPreview
(
)
;
this
.
updateCanvasPreview
(
true
(
aPreviewCanvas
)
=
>
{
let
winWidth
=
this
.
win
.
width
;
let
winHeight
=
this
.
win
.
height
;
let
composite
=
PageThumbs
.
createCanvas
(
)
;
composite
.
mozOpaque
=
false
;
let
ctx
=
composite
.
getContext
(
'
2d
'
)
;
let
scale
=
this
.
screenPixelsPerCSSPixel
/
this
.
zoom
;
composite
.
width
=
winWidth
*
scale
;
composite
.
height
=
winHeight
*
scale
;
ctx
.
save
(
)
;
ctx
.
scale
(
scale
scale
)
;
ctx
.
drawWindow
(
this
.
win
.
win
0
0
winWidth
winHeight
"
rgba
(
0
0
0
0
)
"
)
;
ctx
.
drawImage
(
aPreviewCanvas
this
.
browserDims
.
x
this
.
browserDims
.
y
aPreviewCanvas
.
width
aPreviewCanvas
.
height
)
;
ctx
.
restore
(
)
;
this
.
win
.
tabbrowser
.
previewTab
(
this
.
tab
function
(
)
{
aTaskbarCallback
.
done
(
composite
false
)
;
}
)
;
}
)
;
}
requestThumbnail
:
function
(
aTaskbarCallback
aRequestedWidth
aRequestedHeight
)
{
this
.
resizeCanvasPreview
(
aRequestedWidth
aRequestedHeight
)
;
this
.
updateCanvasPreview
(
false
(
aThumbnailCanvas
)
=
>
{
aTaskbarCallback
.
done
(
aThumbnailCanvas
false
)
;
}
)
;
}
onClose
:
function
(
)
{
this
.
win
.
tabbrowser
.
removeTab
(
this
.
tab
)
;
}
onActivate
:
function
(
)
{
this
.
win
.
tabbrowser
.
selectedTab
=
this
.
tab
;
return
true
;
}
handleEvent
:
function
(
evt
)
{
switch
(
evt
.
type
)
{
case
"
TabAttrModified
"
:
this
.
updateTitleAndTooltip
(
)
;
break
;
}
}
}
;
XPCOMUtils
.
defineLazyGetter
(
PreviewController
.
prototype
"
canvasPreviewFlags
"
function
(
)
{
let
canvasInterface
=
Ci
.
nsIDOMCanvasRenderingContext2D
;
return
canvasInterface
.
DRAWWINDOW_DRAW_VIEW
|
canvasInterface
.
DRAWWINDOW_DRAW_CARET
|
canvasInterface
.
DRAWWINDOW_ASYNC_DECODE_IMAGES
|
canvasInterface
.
DRAWWINDOW_DO_NOT_FLUSH
;
}
)
;
function
TabWindow
(
win
)
{
this
.
win
=
win
;
this
.
tabbrowser
=
win
.
gBrowser
;
this
.
previews
=
new
Map
(
)
;
for
(
let
i
=
0
;
i
<
this
.
tabEvents
.
length
;
i
+
+
)
this
.
tabbrowser
.
tabContainer
.
addEventListener
(
this
.
tabEvents
[
i
]
this
false
)
;
for
(
let
i
=
0
;
i
<
this
.
winEvents
.
length
;
i
+
+
)
this
.
win
.
addEventListener
(
this
.
winEvents
[
i
]
this
false
)
;
this
.
tabbrowser
.
addTabsProgressListener
(
this
)
;
AeroPeek
.
windows
.
push
(
this
)
;
let
tabs
=
this
.
tabbrowser
.
tabs
;
for
(
let
i
=
0
;
i
<
tabs
.
length
;
i
+
+
)
this
.
newTab
(
tabs
[
i
]
)
;
this
.
updateTabOrdering
(
)
;
AeroPeek
.
checkPreviewCount
(
)
;
}
TabWindow
.
prototype
=
{
_enabled
:
false
_cachedWidth
:
0
_cachedHeight
:
0
tabEvents
:
[
"
TabOpen
"
"
TabClose
"
"
TabSelect
"
"
TabMove
"
]
winEvents
:
[
"
resize
"
]
destroy
:
function
(
)
{
this
.
_destroying
=
true
;
let
tabs
=
this
.
tabbrowser
.
tabs
;
this
.
tabbrowser
.
removeTabsProgressListener
(
this
)
;
for
(
let
i
=
0
;
i
<
this
.
winEvents
.
length
;
i
+
+
)
this
.
win
.
removeEventListener
(
this
.
winEvents
[
i
]
this
false
)
;
for
(
let
i
=
0
;
i
<
this
.
tabEvents
.
length
;
i
+
+
)
this
.
tabbrowser
.
tabContainer
.
removeEventListener
(
this
.
tabEvents
[
i
]
this
false
)
;
for
(
let
i
=
0
;
i
<
tabs
.
length
;
i
+
+
)
this
.
removeTab
(
tabs
[
i
]
)
;
let
idx
=
AeroPeek
.
windows
.
indexOf
(
this
.
win
.
gTaskbarTabGroup
)
;
AeroPeek
.
windows
.
splice
(
idx
1
)
;
AeroPeek
.
checkPreviewCount
(
)
;
}
get
width
(
)
{
return
this
.
win
.
innerWidth
;
}
get
height
(
)
{
return
this
.
win
.
innerHeight
;
}
cacheDims
:
function
(
)
{
this
.
_cachedWidth
=
this
.
width
;
this
.
_cachedHeight
=
this
.
height
;
}
testCacheDims
:
function
(
)
{
return
this
.
_cachedWidth
=
=
this
.
width
&
&
this
.
_cachedHeight
=
=
this
.
height
;
}
newTab
:
function
(
tab
)
{
let
controller
=
new
PreviewController
(
this
tab
)
;
this
.
previews
.
set
(
tab
controller
.
preview
)
;
AeroPeek
.
addPreview
(
controller
.
preview
)
;
controller
.
updateTitleAndTooltip
(
)
;
}
createTabPreview
:
function
(
controller
)
{
let
docShell
=
this
.
win
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebNavigation
)
.
QueryInterface
(
Ci
.
nsIDocShell
)
;
let
preview
=
AeroPeek
.
taskbar
.
createTaskbarTabPreview
(
docShell
controller
)
;
preview
.
visible
=
AeroPeek
.
enabled
;
preview
.
active
=
this
.
tabbrowser
.
selectedTab
=
=
controller
.
tab
;
this
.
onLinkIconAvailable
(
controller
.
tab
.
linkedBrowser
controller
.
tab
.
getAttribute
(
"
image
"
)
)
;
return
preview
;
}
removeTab
:
function
(
tab
)
{
let
preview
=
this
.
previewFromTab
(
tab
)
;
preview
.
active
=
false
;
preview
.
visible
=
false
;
preview
.
move
(
null
)
;
preview
.
controller
.
wrappedJSObject
.
destroy
(
)
;
this
.
previews
.
delete
(
tab
)
;
AeroPeek
.
removePreview
(
preview
)
;
}
get
enabled
(
)
{
return
this
.
_enabled
;
}
set
enabled
(
enable
)
{
this
.
_enabled
=
enable
;
for
(
let
[
tab
preview
]
of
this
.
previews
)
{
preview
.
move
(
null
)
;
preview
.
visible
=
enable
;
}
this
.
updateTabOrdering
(
)
;
}
previewFromTab
:
function
(
tab
)
{
return
this
.
previews
.
get
(
tab
)
;
}
updateTabOrdering
:
function
(
)
{
let
previews
=
this
.
previews
;
let
tabs
=
this
.
tabbrowser
.
tabs
;
let
inorder
=
[
]
;
for
(
let
t
of
tabs
)
{
if
(
previews
.
has
(
t
)
)
{
inorder
.
push
(
previews
.
get
(
t
)
)
;
}
}
for
(
let
i
=
inorder
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
inorder
[
i
]
.
move
(
inorder
[
i
+
1
]
|
|
null
)
;
}
}
handleEvent
:
function
(
evt
)
{
let
tab
=
evt
.
originalTarget
;
switch
(
evt
.
type
)
{
case
"
TabOpen
"
:
this
.
newTab
(
tab
)
;
this
.
updateTabOrdering
(
)
;
break
;
case
"
TabClose
"
:
this
.
removeTab
(
tab
)
;
this
.
updateTabOrdering
(
)
;
break
;
case
"
TabSelect
"
:
this
.
previewFromTab
(
tab
)
.
active
=
true
;
break
;
case
"
TabMove
"
:
this
.
updateTabOrdering
(
)
;
break
;
case
"
resize
"
:
if
(
!
AeroPeek
.
_prefenabled
)
return
;
this
.
onResize
(
)
;
break
;
}
}
setInvalidationTimer
:
function
(
)
{
if
(
!
this
.
invalidateTimer
)
{
this
.
invalidateTimer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
}
this
.
invalidateTimer
.
cancel
(
)
;
this
.
invalidateTimer
.
initWithCallback
(
(
)
=
>
{
this
.
previews
.
forEach
(
function
(
aPreview
)
{
let
controller
=
aPreview
.
controller
.
wrappedJSObject
;
if
(
!
controller
.
testCacheBrowserDims
(
)
)
{
controller
.
cacheBrowserDims
(
)
;
aPreview
.
invalidate
(
)
;
}
}
)
;
}
1000
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
onResize
:
function
(
)
{
if
(
this
.
testCacheDims
(
)
)
{
return
;
}
this
.
cacheDims
(
)
;
this
.
setInvalidationTimer
(
)
;
}
invalidateTabPreview
:
function
(
aBrowser
)
{
for
(
let
[
tab
preview
]
of
this
.
previews
)
{
if
(
aBrowser
=
=
tab
.
linkedBrowser
)
{
preview
.
invalidate
(
)
;
break
;
}
}
}
onLocationChange
:
function
(
aBrowser
)
{
}
onStateChange
:
function
(
aBrowser
aWebProgress
aRequest
aStateFlags
aStatus
)
{
if
(
aStateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_STOP
&
&
aStateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_IS_NETWORK
)
{
this
.
invalidateTabPreview
(
aBrowser
)
;
}
}
directRequestProtocols
:
new
Set
(
[
"
file
"
"
chrome
"
"
resource
"
"
about
"
]
)
onLinkIconAvailable
:
function
(
aBrowser
aIconURL
)
{
let
requestURL
=
null
;
if
(
aIconURL
)
{
let
shouldRequestFaviconURL
=
true
;
try
{
let
urlObject
=
NetUtil
.
newURI
(
aIconURL
)
;
shouldRequestFaviconURL
=
!
this
.
directRequestProtocols
.
has
(
urlObject
.
scheme
)
;
}
catch
(
ex
)
{
}
requestURL
=
shouldRequestFaviconURL
?
"
moz
-
anno
:
favicon
:
"
+
aIconURL
:
aIconURL
;
}
let
isDefaultFavicon
=
!
requestURL
;
getFaviconAsImage
(
requestURL
PrivateBrowsingUtils
.
isWindowPrivate
(
this
.
win
)
img
=
>
{
let
index
=
this
.
tabbrowser
.
browsers
.
indexOf
(
aBrowser
)
;
if
(
index
!
=
-
1
)
{
let
tab
=
this
.
tabbrowser
.
tabs
[
index
]
;
let
preview
=
this
.
previews
.
get
(
tab
)
;
if
(
tab
.
getAttribute
(
"
image
"
)
=
=
aIconURL
|
|
(
!
preview
.
icon
&
&
isDefaultFavicon
)
)
{
preview
.
icon
=
img
;
}
}
}
)
;
}
}
this
.
AeroPeek
=
{
available
:
false
__prefenabled
:
false
_enabled
:
true
initialized
:
false
previews
:
[
]
windows
:
[
]
taskbar
:
null
maxpreviews
:
20
cacheLifespan
:
20
initialize
:
function
(
)
{
if
(
!
(
WINTASKBAR_CONTRACTID
in
Cc
)
)
return
;
this
.
taskbar
=
Cc
[
WINTASKBAR_CONTRACTID
]
.
getService
(
Ci
.
nsIWinTaskbar
)
;
this
.
available
=
this
.
taskbar
.
available
;
if
(
!
this
.
available
)
return
;
this
.
prefs
.
addObserver
(
TOGGLE_PREF_NAME
this
true
)
;
this
.
enabled
=
this
.
_prefenabled
=
this
.
prefs
.
getBoolPref
(
TOGGLE_PREF_NAME
)
;
this
.
initialized
=
true
;
}
destroy
:
function
destroy
(
)
{
this
.
_enabled
=
false
;
if
(
this
.
cacheTimer
)
this
.
cacheTimer
.
cancel
(
)
;
}
get
enabled
(
)
{
return
this
.
_enabled
;
}
set
enabled
(
enable
)
{
if
(
this
.
_enabled
=
=
enable
)
return
;
this
.
_enabled
=
enable
;
this
.
windows
.
forEach
(
function
(
win
)
{
win
.
enabled
=
enable
;
}
)
;
}
get
_prefenabled
(
)
{
return
this
.
__prefenabled
;
}
set
_prefenabled
(
enable
)
{
if
(
enable
=
=
this
.
__prefenabled
)
{
return
;
}
this
.
__prefenabled
=
enable
;
if
(
enable
)
{
this
.
enable
(
)
;
}
else
{
this
.
disable
(
)
;
}
}
_observersAdded
:
false
enable
(
)
{
if
(
!
this
.
_observersAdded
)
{
this
.
prefs
.
addObserver
(
DISABLE_THRESHOLD_PREF_NAME
this
true
)
;
this
.
prefs
.
addObserver
(
CACHE_EXPIRATION_TIME_PREF_NAME
this
true
)
;
PlacesUtils
.
history
.
addObserver
(
this
true
)
;
this
.
_observersAdded
=
true
;
}
this
.
cacheLifespan
=
this
.
prefs
.
getIntPref
(
CACHE_EXPIRATION_TIME_PREF_NAME
)
;
this
.
maxpreviews
=
this
.
prefs
.
getIntPref
(
DISABLE_THRESHOLD_PREF_NAME
)
;
if
(
this
.
initialized
)
{
let
browserWindows
=
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
;
while
(
browserWindows
.
hasMoreElements
(
)
)
{
let
win
=
browserWindows
.
getNext
(
)
;
if
(
!
win
.
closed
)
{
this
.
onOpenWindow
(
win
)
;
}
}
}
}
disable
(
)
{
while
(
this
.
windows
.
length
)
{
let
tabWinObject
=
this
.
windows
[
0
]
;
tabWinObject
.
destroy
(
)
;
delete
tabWinObject
.
win
.
gTaskbarTabGroup
;
}
}
addPreview
:
function
(
preview
)
{
this
.
previews
.
push
(
preview
)
;
this
.
checkPreviewCount
(
)
;
}
removePreview
:
function
(
preview
)
{
let
idx
=
this
.
previews
.
indexOf
(
preview
)
;
this
.
previews
.
splice
(
idx
1
)
;
this
.
checkPreviewCount
(
)
;
}
checkPreviewCount
:
function
(
)
{
if
(
!
this
.
_prefenabled
)
{
return
;
}
this
.
enabled
=
this
.
previews
.
length
<
=
this
.
maxpreviews
;
}
onOpenWindow
:
function
(
win
)
{
if
(
!
this
.
available
|
|
!
this
.
_prefenabled
)
return
;
win
.
gTaskbarTabGroup
=
new
TabWindow
(
win
)
;
}
onCloseWindow
:
function
(
win
)
{
if
(
!
this
.
available
|
|
!
this
.
_prefenabled
)
return
;
win
.
gTaskbarTabGroup
.
destroy
(
)
;
delete
win
.
gTaskbarTabGroup
;
if
(
this
.
windows
.
length
=
=
0
)
this
.
destroy
(
)
;
}
resetCacheTimer
:
function
(
)
{
this
.
cacheTimer
.
cancel
(
)
;
this
.
cacheTimer
.
init
(
this
1000
*
this
.
cacheLifespan
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
observe
:
function
(
aSubject
aTopic
aData
)
{
if
(
aTopic
=
=
"
nsPref
:
changed
"
&
&
aData
=
=
TOGGLE_PREF_NAME
)
{
this
.
_prefenabled
=
this
.
prefs
.
getBoolPref
(
TOGGLE_PREF_NAME
)
;
}
if
(
!
this
.
_prefenabled
)
{
return
;
}
switch
(
aTopic
)
{
case
"
nsPref
:
changed
"
:
if
(
aData
=
=
CACHE_EXPIRATION_TIME_PREF_NAME
)
break
;
if
(
aData
=
=
DISABLE_THRESHOLD_PREF_NAME
)
this
.
maxpreviews
=
this
.
prefs
.
getIntPref
(
DISABLE_THRESHOLD_PREF_NAME
)
;
this
.
checkPreviewCount
(
)
;
break
;
case
"
timer
-
callback
"
:
this
.
previews
.
forEach
(
function
(
preview
)
{
let
controller
=
preview
.
controller
.
wrappedJSObject
;
controller
.
resetCanvasPreview
(
)
;
}
)
;
break
;
}
}
onBeginUpdateBatch
(
)
{
}
onEndUpdateBatch
(
)
{
}
onVisit
(
)
{
}
onTitleChanged
(
)
{
}
onFrecencyChanged
(
)
{
}
onManyFrecenciesChanged
(
)
{
}
onDeleteURI
(
)
{
}
onClearHistory
(
)
{
}
onDeleteVisits
(
)
{
}
onPageChanged
(
uri
changedConst
newValue
)
{
if
(
this
.
enabled
&
&
changedConst
=
=
Ci
.
nsINavHistoryObserver
.
ATTRIBUTE_FAVICON
)
{
for
(
let
win
of
this
.
windows
)
{
for
(
let
[
tab
preview
]
of
win
.
previews
)
{
if
(
tab
.
getAttribute
(
"
image
"
)
=
=
newValue
)
{
win
.
onLinkIconAvailable
(
tab
.
linkedBrowser
newValue
)
;
}
}
}
}
}
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsISupportsWeakReference
Ci
.
nsINavHistoryObserver
Ci
.
nsIObserver
]
)
}
;
XPCOMUtils
.
defineLazyGetter
(
AeroPeek
"
cacheTimer
"
(
)
=
>
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
AeroPeek
"
prefs
"
"
mozilla
.
org
/
preferences
-
service
;
1
"
"
nsIPrefBranch
"
)
;
AeroPeek
.
initialize
(
)
;
