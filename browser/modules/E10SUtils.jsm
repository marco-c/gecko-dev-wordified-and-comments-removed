"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
E10SUtils
"
]
;
const
{
interfaces
:
Ci
utils
:
Cu
classes
:
Cc
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
useRemoteWebExtensions
"
"
extensions
.
webextensions
.
remote
"
false
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
useSeparateFileUriProcess
"
"
browser
.
tabs
.
remote
.
separateFileUriProcess
"
false
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Utils
"
"
resource
:
/
/
gre
/
modules
/
sessionstore
/
Utils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
console
"
"
resource
:
/
/
gre
/
modules
/
Console
.
jsm
"
)
;
function
getAboutModule
(
aURL
)
{
let
moduleName
=
aURL
.
path
.
replace
(
/
[
#
?
]
.
*
/
"
"
)
.
toLowerCase
(
)
;
let
contract
=
"
mozilla
.
org
/
network
/
protocol
/
about
;
1
?
what
=
"
+
moduleName
;
try
{
return
Cc
[
contract
]
.
getService
(
Ci
.
nsIAboutModule
)
;
}
catch
(
e
)
{
return
null
;
}
}
const
NOT_REMOTE
=
null
;
const
WEB_REMOTE_TYPE
=
"
web
"
;
const
FILE_REMOTE_TYPE
=
"
file
"
;
const
EXTENSION_REMOTE_TYPE
=
"
extension
"
;
const
DEFAULT_REMOTE_TYPE
=
WEB_REMOTE_TYPE
;
function
validatedWebRemoteType
(
aPreferredRemoteType
)
{
return
aPreferredRemoteType
&
&
aPreferredRemoteType
.
startsWith
(
WEB_REMOTE_TYPE
)
?
aPreferredRemoteType
:
WEB_REMOTE_TYPE
;
}
this
.
E10SUtils
=
{
DEFAULT_REMOTE_TYPE
NOT_REMOTE
WEB_REMOTE_TYPE
FILE_REMOTE_TYPE
EXTENSION_REMOTE_TYPE
canLoadURIInProcess
(
aURL
aProcess
)
{
let
remoteType
=
aProcess
=
=
Ci
.
nsIXULRuntime
.
PROCESS_TYPE_CONTENT
?
DEFAULT_REMOTE_TYPE
:
NOT_REMOTE
;
return
remoteType
=
=
this
.
getRemoteTypeForURI
(
aURL
true
remoteType
)
;
}
getRemoteTypeForURI
(
aURL
aMultiProcess
aPreferredRemoteType
=
DEFAULT_REMOTE_TYPE
)
{
if
(
!
aMultiProcess
)
{
return
NOT_REMOTE
;
}
if
(
!
aURL
)
{
aURL
=
"
about
:
blank
"
;
}
let
uri
;
try
{
uri
=
Services
.
io
.
newURI
(
aURL
)
;
}
catch
(
e
)
{
return
DEFAULT_REMOTE_TYPE
;
}
return
this
.
getRemoteTypeForURIObject
(
uri
aMultiProcess
aPreferredRemoteType
)
;
}
getRemoteTypeForURIObject
(
aURI
aMultiProcess
aPreferredRemoteType
=
DEFAULT_REMOTE_TYPE
)
{
if
(
!
aMultiProcess
)
{
return
NOT_REMOTE
;
}
switch
(
aURI
.
scheme
)
{
case
"
javascript
"
:
return
aPreferredRemoteType
;
case
"
data
"
:
case
"
blob
"
:
return
aPreferredRemoteType
=
=
NOT_REMOTE
?
DEFAULT_REMOTE_TYPE
:
aPreferredRemoteType
;
case
"
file
"
:
return
useSeparateFileUriProcess
?
FILE_REMOTE_TYPE
:
DEFAULT_REMOTE_TYPE
;
case
"
about
"
:
let
module
=
getAboutModule
(
aURI
)
;
if
(
!
module
)
{
return
aPreferredRemoteType
;
}
let
flags
=
module
.
getURIFlags
(
aURI
)
;
if
(
flags
&
Ci
.
nsIAboutModule
.
URI_MUST_LOAD_IN_CHILD
)
{
return
DEFAULT_REMOTE_TYPE
;
}
if
(
flags
&
Ci
.
nsIAboutModule
.
URI_CAN_LOAD_IN_CHILD
)
{
return
aPreferredRemoteType
;
}
return
NOT_REMOTE
;
case
"
chrome
"
:
let
chromeReg
=
Cc
[
"
mozilla
.
org
/
chrome
/
chrome
-
registry
;
1
"
]
.
getService
(
Ci
.
nsIXULChromeRegistry
)
;
if
(
chromeReg
.
mustLoadURLRemotely
(
aURI
)
)
{
return
DEFAULT_REMOTE_TYPE
;
}
if
(
chromeReg
.
canLoadURLRemotely
(
aURI
)
&
&
aPreferredRemoteType
!
=
NOT_REMOTE
)
{
return
DEFAULT_REMOTE_TYPE
;
}
return
NOT_REMOTE
;
case
"
moz
-
extension
"
:
return
useRemoteWebExtensions
?
EXTENSION_REMOTE_TYPE
:
NOT_REMOTE
;
default
:
if
(
aURI
instanceof
Ci
.
nsINestedURI
)
{
let
innerURI
=
aURI
.
QueryInterface
(
Ci
.
nsINestedURI
)
.
innerURI
;
return
this
.
getRemoteTypeForURIObject
(
innerURI
aMultiProcess
aPreferredRemoteType
)
;
}
return
validatedWebRemoteType
(
aPreferredRemoteType
)
;
}
}
shouldLoadURIInThisProcess
(
aURI
)
{
let
remoteType
=
Services
.
appinfo
.
remoteType
;
return
remoteType
=
=
this
.
getRemoteTypeForURIObject
(
aURI
true
remoteType
)
;
}
shouldLoadURI
(
aDocShell
aURI
aReferrer
)
{
if
(
aDocShell
.
QueryInterface
(
Ci
.
nsIDocShellTreeItem
)
.
sameTypeParent
)
return
true
;
if
(
aDocShell
.
inLargeAllocProcess
&
&
!
aDocShell
.
awaitingLargeAlloc
&
&
aDocShell
.
isOnlyToplevelInTabGroup
)
{
return
false
;
}
return
this
.
shouldLoadURIInThisProcess
(
aURI
)
;
}
redirectLoad
(
aDocShell
aURI
aReferrer
aTriggeringPrincipal
aFreshProcess
aFlags
)
{
let
messageManager
=
aDocShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIContentFrameMessageManager
)
;
let
sessionHistory
=
aDocShell
.
getInterface
(
Ci
.
nsIWebNavigation
)
.
sessionHistory
;
messageManager
.
sendAsyncMessage
(
"
Browser
:
LoadURI
"
{
loadOptions
:
{
uri
:
aURI
.
spec
flags
:
aFlags
|
|
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_NONE
referrer
:
aReferrer
?
aReferrer
.
spec
:
null
triggeringPrincipal
:
aTriggeringPrincipal
?
Utils
.
serializePrincipal
(
aTriggeringPrincipal
)
:
null
reloadInFreshProcess
:
!
!
aFreshProcess
}
historyIndex
:
sessionHistory
.
requestedIndex
}
)
;
return
false
;
}
wrapHandlingUserInput
(
aWindow
aIsHandling
aCallback
)
{
var
handlingUserInput
;
try
{
handlingUserInput
=
aWindow
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
.
setHandlingUserInput
(
aIsHandling
)
;
aCallback
(
)
;
}
finally
{
handlingUserInput
.
destruct
(
)
;
}
}
}
;
