"
use
strict
"
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
URL
"
]
)
;
const
TIMEOUT_DELAY
=
1000
;
const
ACCEPTED_PROTOCOLS
=
[
"
http
:
"
"
https
:
"
]
;
const
DESCRIPTION_RULES
=
[
"
twitter
:
description
"
"
description
"
"
og
:
description
"
]
;
const
PREVIEW_IMAGE_RULES
=
[
"
thumbnail
"
"
twitter
:
image
"
"
og
:
image
"
"
og
:
image
:
url
"
"
og
:
image
:
secure_url
"
]
;
function
shouldExtractMetadata
(
aRules
aTag
aEntry
)
{
return
aRules
.
indexOf
(
aTag
)
>
aEntry
.
currMaxScore
;
}
function
checkLoadURIStr
(
aURL
)
{
if
(
!
ACCEPTED_PROTOCOLS
.
includes
(
aURL
.
protocol
)
)
{
return
false
;
}
try
{
let
ssm
=
Services
.
scriptSecurityManager
;
let
principal
=
ssm
.
createNullPrincipal
(
{
}
)
;
ssm
.
checkLoadURIStrWithPrincipal
(
principal
aURL
.
href
ssm
.
DISALLOW_INHERIT_PRINCIPAL
)
;
}
catch
(
e
)
{
return
false
;
}
return
true
;
}
var
EXPORTED_SYMBOLS
=
[
"
ContentMetaHandler
"
]
;
var
ContentMetaHandler
=
{
init
(
chromeGlobal
)
{
const
metaTags
=
new
Map
(
)
;
chromeGlobal
.
addEventListener
(
"
DOMMetaAdded
"
event
=
>
{
const
metaTag
=
event
.
originalTarget
;
const
window
=
metaTag
.
ownerGlobal
;
if
(
!
metaTag
|
|
!
metaTag
.
ownerDocument
|
|
window
!
=
window
.
top
)
{
return
;
}
this
.
handleMetaTag
(
metaTag
chromeGlobal
metaTags
)
;
}
)
;
}
handleMetaTag
(
metaTag
chromeGlobal
metaTags
)
{
const
url
=
metaTag
.
ownerDocument
.
documentURI
;
let
name
=
metaTag
.
name
;
let
prop
=
metaTag
.
getAttributeNS
(
null
"
property
"
)
;
if
(
!
name
&
&
!
prop
)
{
return
;
}
let
tag
=
name
|
|
prop
;
const
entry
=
metaTags
.
get
(
url
)
|
|
{
description
:
{
value
:
null
currMaxScore
:
-
1
}
image
:
{
value
:
null
currMaxScore
:
-
1
}
timeout
:
null
}
;
const
content
=
metaTag
.
getAttributeNS
(
null
"
content
"
)
;
if
(
!
content
)
{
return
;
}
if
(
shouldExtractMetadata
(
DESCRIPTION_RULES
tag
entry
.
description
)
)
{
entry
.
description
.
value
=
content
;
entry
.
description
.
currMaxScore
=
DESCRIPTION_RULES
.
indexOf
(
tag
)
;
}
else
if
(
shouldExtractMetadata
(
PREVIEW_IMAGE_RULES
tag
entry
.
image
)
)
{
let
value
;
try
{
value
=
new
URL
(
content
url
)
;
}
catch
(
e
)
{
return
;
}
if
(
value
&
&
checkLoadURIStr
(
value
)
)
{
entry
.
image
.
value
=
value
.
href
;
entry
.
image
.
currMaxScore
=
PREVIEW_IMAGE_RULES
.
indexOf
(
tag
)
;
}
}
else
{
return
;
}
if
(
!
metaTags
.
has
(
url
)
)
{
metaTags
.
set
(
url
entry
)
;
}
if
(
entry
.
timeout
)
{
entry
.
timeout
.
delay
=
TIMEOUT_DELAY
;
}
else
{
entry
.
timeout
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
entry
.
timeout
.
initWithCallback
(
(
)
=
>
{
entry
.
timeout
=
null
;
chromeGlobal
.
sendAsyncMessage
(
"
Meta
:
SetPageInfo
"
{
url
description
:
entry
.
description
.
value
previewImageURL
:
entry
.
image
.
value
}
)
;
let
metadataSize
=
entry
.
description
.
value
?
entry
.
description
.
value
.
length
:
0
;
metadataSize
+
=
entry
.
image
.
value
?
entry
.
image
.
value
.
length
:
0
;
Services
.
telemetry
.
getHistogramById
(
"
PAGE_METADATA_SIZE
"
)
.
add
(
metadataSize
)
;
metaTags
.
delete
(
url
)
;
}
TIMEOUT_DELAY
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
}
}
;
