import
{
XPCOMUtils
}
from
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyServiceGetters
(
lazy
{
BrowserHandler
:
[
"
mozilla
.
org
/
browser
/
clh
;
1
"
"
nsIBrowserHandler
"
]
}
)
;
ChromeUtils
.
defineESModuleGetters
(
lazy
{
BrowserWindowTracker
:
"
resource
:
/
/
/
modules
/
BrowserWindowTracker
.
sys
.
mjs
"
}
)
;
export
var
BrowserUIUtils
=
{
checkEmptyPageOrigin
(
browser
uri
=
browser
.
currentURI
)
{
if
(
browser
.
hasContentOpener
)
{
return
false
;
}
let
contentPrincipal
=
browser
.
contentPrincipal
;
let
uriToCheck
=
browser
.
documentURI
|
|
uri
;
if
(
(
uriToCheck
.
spec
=
=
"
about
:
blank
"
&
&
contentPrincipal
.
isNullPrincipal
)
|
|
contentPrincipal
.
spec
=
=
"
about
:
blank
"
)
{
return
true
;
}
if
(
contentPrincipal
.
isContentPrincipal
)
{
return
contentPrincipal
.
equalsURI
(
uri
)
;
}
return
contentPrincipal
.
isSystemPrincipal
;
}
getLocalizedFragment
(
doc
msg
.
.
.
nodesOrStrings
)
{
for
(
let
i
=
1
;
i
<
=
nodesOrStrings
.
length
;
i
+
+
)
{
if
(
!
msg
.
includes
(
"
%
"
+
i
+
"
S
"
)
)
{
msg
=
msg
.
replace
(
/
%
S
/
"
%
"
+
i
+
"
S
"
)
;
}
}
let
numberOfInsertionPoints
=
msg
.
match
(
/
%
\
d
+
\
S
/
g
)
.
length
;
if
(
numberOfInsertionPoints
!
=
nodesOrStrings
.
length
)
{
console
.
error
(
Message
has
{
numberOfInsertionPoints
}
insertion
points
+
but
got
{
nodesOrStrings
.
length
}
replacement
parameters
!
)
;
}
let
fragment
=
doc
.
createDocumentFragment
(
)
;
let
parts
=
[
msg
]
;
let
insertionPoint
=
1
;
for
(
let
replacement
of
nodesOrStrings
)
{
let
insertionString
=
"
%
"
+
insertionPoint
+
+
+
"
S
"
;
let
partIndex
=
parts
.
findIndex
(
part
=
>
typeof
part
=
=
"
string
"
&
&
part
.
includes
(
insertionString
)
)
;
if
(
partIndex
=
=
-
1
)
{
fragment
.
appendChild
(
doc
.
createTextNode
(
msg
)
)
;
return
fragment
;
}
if
(
typeof
replacement
=
=
"
string
"
)
{
parts
[
partIndex
]
=
parts
[
partIndex
]
.
replace
(
insertionString
replacement
)
;
}
else
{
let
[
firstBit
lastBit
]
=
parts
[
partIndex
]
.
split
(
insertionString
)
;
parts
.
splice
(
partIndex
1
firstBit
replacement
lastBit
)
;
}
}
for
(
let
part
of
parts
)
{
if
(
typeof
part
=
=
"
string
"
)
{
if
(
part
)
{
fragment
.
appendChild
(
doc
.
createTextNode
(
part
)
)
;
}
}
else
{
fragment
.
appendChild
(
part
)
;
}
}
return
fragment
;
}
removeSingleTrailingSlashFromURL
(
aURL
)
{
return
aURL
.
replace
(
/
^
(
(
?
:
http
|
https
|
ftp
)
:
\
/
\
/
[
^
/
]
+
)
\
/
/
"
1
"
)
;
}
get
trimURLProtocol
(
)
{
return
"
http
:
/
/
"
;
}
trimURL
(
aURL
)
{
let
url
=
this
.
removeSingleTrailingSlashFromURL
(
aURL
)
;
return
url
.
startsWith
(
this
.
trimURLProtocol
)
?
url
.
substring
(
this
.
trimURLProtocol
.
length
)
:
url
;
}
async
openNewBrowserWindow
(
)
{
var
telemetryObj
=
{
}
;
TelemetryStopwatch
.
start
(
"
FX_NEW_WINDOW_MS
"
telemetryObj
)
;
let
defaultArgs
=
Cc
[
"
mozilla
.
org
/
supports
-
string
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsString
)
;
defaultArgs
.
data
=
lazy
.
BrowserHandler
.
defaultArgs
;
let
extraFeatures
=
"
suppressanimation
"
;
let
win
=
lazy
.
BrowserWindowTracker
.
openWindow
(
{
args
:
defaultArgs
features
:
extraFeatures
}
)
;
win
.
addEventListener
(
"
MozAfterPaint
"
(
)
=
>
{
TelemetryStopwatch
.
finish
(
"
FX_NEW_WINDOW_MS
"
telemetryObj
)
;
}
{
once
:
true
}
)
;
await
this
.
_topicObserved
(
"
browser
-
delayed
-
startup
-
finished
"
subject
=
>
subject
=
=
win
)
;
win
.
focus
(
)
;
return
win
;
}
_topicObserved
(
observeTopic
checkFn
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
function
observer
(
subject
topic
data
)
{
try
{
if
(
checkFn
&
&
!
checkFn
(
subject
data
)
)
{
return
;
}
Services
.
obs
.
removeObserver
(
observer
topic
)
;
checkFn
=
null
;
resolve
(
[
subject
data
]
)
;
}
catch
(
ex
)
{
Services
.
obs
.
removeObserver
(
observer
topic
)
;
checkFn
=
null
;
reject
(
ex
)
;
}
}
Services
.
obs
.
addObserver
(
observer
observeTopic
)
;
}
)
;
}
}
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
BrowserUIUtils
"
quitShortcutDisabled
"
"
browser
.
quitShortcut
.
disabled
"
false
)
;
