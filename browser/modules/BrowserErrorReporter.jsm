ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Log
"
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
UpdateUtils
"
"
resource
:
/
/
gre
/
modules
/
UpdateUtils
.
jsm
"
)
;
Cu
.
importGlobalProperties
(
[
"
fetch
"
"
URL
"
]
)
;
this
.
EXPORTED_SYMBOLS
=
[
"
BrowserErrorReporter
"
]
;
const
ERROR_PREFIX_RE
=
/
^
[
^
\
W
]
+
:
/
m
;
const
PREF_ENABLED
=
"
browser
.
chrome
.
errorReporter
.
enabled
"
;
const
PREF_LOG_LEVEL
=
"
browser
.
chrome
.
errorReporter
.
logLevel
"
;
const
PREF_PROJECT_ID
=
"
browser
.
chrome
.
errorReporter
.
projectId
"
;
const
PREF_PUBLIC_KEY
=
"
browser
.
chrome
.
errorReporter
.
publicKey
"
;
const
PREF_SAMPLE_RATE
=
"
browser
.
chrome
.
errorReporter
.
sampleRate
"
;
const
PREF_SUBMIT_URL
=
"
browser
.
chrome
.
errorReporter
.
submitUrl
"
;
const
REPORTED_CATEGORIES
=
new
Set
(
[
"
XPConnect
JavaScript
"
"
component
javascript
"
"
chrome
javascript
"
"
chrome
registration
"
"
XBL
"
"
XBL
Prototype
Handler
"
"
XBL
Content
Sink
"
"
xbl
javascript
"
"
FrameConstructor
"
]
)
;
class
BrowserErrorReporter
{
constructor
(
fetchMethod
=
this
.
_defaultFetch
)
{
this
.
fetch
=
fetchMethod
;
this
.
requestBodyTemplate
=
{
request
:
{
headers
:
{
"
User
-
Agent
"
:
Services
.
appShell
.
hiddenDOMWindow
.
navigator
.
userAgent
}
}
logger
:
"
javascript
"
platform
:
"
javascript
"
release
:
Services
.
appinfo
.
version
environment
:
UpdateUtils
.
getUpdateChannel
(
false
)
tags
:
{
appBuildID
:
Services
.
appinfo
.
appBuildID
changeset
:
AppConstants
.
SOURCE_REVISION_URL
}
}
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
collectionEnabled
"
PREF_ENABLED
false
this
.
handleEnabledPrefChanged
.
bind
(
this
)
)
;
}
get
logger
(
)
{
const
logger
=
Log
.
repository
.
getLogger
(
"
BrowserErrorReporter
"
)
;
logger
.
addAppender
(
new
Log
.
ConsoleAppender
(
new
Log
.
BasicFormatter
(
)
)
)
;
logger
.
manageLevelFromPref
(
PREF_LOG_LEVEL
)
;
Object
.
defineProperty
(
this
"
logger
"
{
value
:
logger
}
)
;
return
this
.
logger
;
}
init
(
)
{
if
(
this
.
collectionEnabled
)
{
Services
.
console
.
registerListener
(
this
)
;
for
(
const
message
of
Services
.
console
.
getMessageArray
(
)
)
{
this
.
observe
(
message
)
;
}
}
}
uninit
(
)
{
try
{
Services
.
console
.
unregisterListener
(
this
)
;
}
catch
(
err
)
{
}
}
handleEnabledPrefChanged
(
prefName
previousValue
newValue
)
{
if
(
newValue
)
{
Services
.
console
.
registerListener
(
this
)
;
}
else
{
try
{
Services
.
console
.
unregisterListener
(
this
)
;
}
catch
(
err
)
{
}
}
}
async
observe
(
message
)
{
try
{
message
.
QueryInterface
(
Ci
.
nsIScriptError
)
;
}
catch
(
err
)
{
return
;
}
const
isWarning
=
message
.
flags
&
message
.
warningFlag
;
const
isFromChrome
=
REPORTED_CATEGORIES
.
has
(
message
.
category
)
;
if
(
!
isFromChrome
|
|
isWarning
)
{
return
;
}
const
sampleRate
=
Number
.
parseFloat
(
Services
.
prefs
.
getCharPref
(
PREF_SAMPLE_RATE
)
)
;
if
(
!
Number
.
isFinite
(
sampleRate
)
|
|
(
Math
.
random
(
)
>
=
sampleRate
)
)
{
return
;
}
let
errorMessage
=
message
.
errorMessage
;
let
errorName
=
"
Error
"
;
if
(
message
.
errorMessage
.
match
(
ERROR_PREFIX_RE
)
)
{
const
parts
=
message
.
errorMessage
.
split
(
"
:
"
)
;
errorName
=
parts
[
0
]
;
errorMessage
=
parts
.
slice
(
1
)
.
join
(
"
:
"
)
.
trim
(
)
;
}
const
frames
=
[
]
;
let
frame
=
message
.
stack
;
while
(
frame
&
&
frames
.
length
<
100
)
{
frames
.
push
(
{
function
:
frame
.
functionDisplayName
filename
:
frame
.
source
lineno
:
frame
.
line
colno
:
frame
.
column
in_app
:
true
}
)
;
frame
=
frame
.
parent
;
}
const
requestBody
=
Object
.
assign
(
{
}
this
.
requestBodyTemplate
{
project
:
Services
.
prefs
.
getCharPref
(
PREF_PROJECT_ID
)
exception
:
{
values
:
[
{
type
:
errorName
value
:
errorMessage
stacktrace
:
{
frames
}
}
]
}
culprit
:
message
.
sourceName
}
)
;
requestBody
.
request
.
url
=
message
.
sourceName
;
const
url
=
new
URL
(
Services
.
prefs
.
getCharPref
(
PREF_SUBMIT_URL
)
)
;
url
.
searchParams
.
set
(
"
sentry_client
"
"
firefox
-
error
-
reporter
/
1
.
0
.
0
"
)
;
url
.
searchParams
.
set
(
"
sentry_version
"
"
7
"
)
;
url
.
searchParams
.
set
(
"
sentry_key
"
Services
.
prefs
.
getCharPref
(
PREF_PUBLIC_KEY
)
)
;
try
{
await
this
.
fetch
(
url
{
method
:
"
POST
"
headers
:
{
"
Content
-
Type
"
:
"
application
/
json
"
"
Accept
"
:
"
application
/
json
"
}
referrer
:
"
https
:
/
/
fake
.
mozilla
.
org
"
body
:
JSON
.
stringify
(
requestBody
)
}
)
;
this
.
logger
.
debug
(
"
Sent
error
successfully
.
"
)
;
}
catch
(
error
)
{
this
.
logger
.
warn
(
Failed
to
send
error
:
{
error
}
)
;
}
}
async
_defaultFetch
(
.
.
.
args
)
{
if
(
Cu
.
isInAutomation
)
{
return
null
;
}
return
fetch
(
.
.
.
args
)
;
}
}
