ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Log
"
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
UpdateUtils
"
"
resource
:
/
/
gre
/
modules
/
UpdateUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
fetch
"
"
URL
"
]
)
;
var
EXPORTED_SYMBOLS
=
[
"
BrowserErrorReporter
"
]
;
const
CONTEXT_LINES
=
5
;
const
ERROR_PREFIX_RE
=
/
^
[
^
\
W
]
+
:
/
m
;
const
PREF_ENABLED
=
"
browser
.
chrome
.
errorReporter
.
enabled
"
;
const
PREF_LOG_LEVEL
=
"
browser
.
chrome
.
errorReporter
.
logLevel
"
;
const
PREF_PROJECT_ID
=
"
browser
.
chrome
.
errorReporter
.
projectId
"
;
const
PREF_PUBLIC_KEY
=
"
browser
.
chrome
.
errorReporter
.
publicKey
"
;
const
PREF_SAMPLE_RATE
=
"
browser
.
chrome
.
errorReporter
.
sampleRate
"
;
const
PREF_SUBMIT_URL
=
"
browser
.
chrome
.
errorReporter
.
submitUrl
"
;
const
RECENT_BUILD_AGE
=
1000
*
60
*
60
*
24
*
7
;
const
SDK_NAME
=
"
firefox
-
error
-
reporter
"
;
const
SDK_VERSION
=
"
1
.
0
.
0
"
;
const
TELEMETRY_ERROR_COLLECTED
=
"
browser
.
errors
.
collected_count
"
;
const
TELEMETRY_ERROR_COLLECTED_FILENAME
=
"
browser
.
errors
.
collected_count_by_filename
"
;
const
TELEMETRY_ERROR_COLLECTED_STACK
=
"
browser
.
errors
.
collected_with_stack_count
"
;
const
TELEMETRY_ERROR_REPORTED
=
"
browser
.
errors
.
reported_success_count
"
;
const
TELEMETRY_ERROR_REPORTED_FAIL
=
"
browser
.
errors
.
reported_failure_count
"
;
const
TELEMETRY_ERROR_SAMPLE_RATE
=
"
browser
.
errors
.
sample_rate
"
;
const
REPORTED_CATEGORIES
=
new
Set
(
[
"
XPConnect
JavaScript
"
"
component
javascript
"
"
chrome
javascript
"
"
chrome
registration
"
"
XBL
"
"
XBL
Prototype
Handler
"
"
XBL
Content
Sink
"
"
xbl
javascript
"
"
FrameConstructor
"
]
)
;
const
PLATFORM_NAMES
=
{
linux
:
"
Linux
"
win
:
"
Windows
"
macosx
:
"
macOS
"
android
:
"
Android
"
}
;
const
TELEMETRY_REPORTED_PATTERNS
=
new
Set
(
[
/
^
resource
:
\
/
\
/
(
?
:
\
/
|
gre
|
devtools
)
/
/
^
chrome
:
\
/
\
/
(
?
:
global
|
browser
|
devtools
)
/
]
)
;
const
MODULE_SAMPLE_RATES
=
new
Map
(
[
[
/
^
(
?
:
chrome
|
resource
)
:
\
/
\
/
devtools
/
1
]
[
/
^
moz
-
extension
:
\
/
\
/
/
0
]
]
)
;
class
BrowserErrorReporter
{
static
getAppBuildIdDate
(
)
{
const
appBuildId
=
Services
.
appinfo
.
appBuildID
;
const
buildYear
=
Number
.
parseInt
(
appBuildId
.
slice
(
0
4
)
)
;
const
buildMonth
=
Number
.
parseInt
(
appBuildId
.
slice
(
4
6
)
)
-
1
;
const
buildDay
=
Number
.
parseInt
(
appBuildId
.
slice
(
6
8
)
)
;
return
new
Date
(
buildYear
buildMonth
buildDay
)
;
}
constructor
(
options
=
{
}
)
{
const
defaultOptions
=
{
fetch
:
defaultFetch
now
:
null
chromeOnly
:
true
sampleRates
:
MODULE_SAMPLE_RATES
registerListener
:
(
)
=
>
Services
.
console
.
registerListener
(
this
)
unregisterListener
:
(
)
=
>
Services
.
console
.
unregisterListener
(
this
)
}
;
for
(
const
[
key
defaultValue
]
of
Object
.
entries
(
defaultOptions
)
)
{
this
[
key
]
=
key
in
options
?
options
[
key
]
:
defaultValue
;
}
XPCOMUtils
.
defineLazyGetter
(
this
"
appBuildIdDate
"
BrowserErrorReporter
.
getAppBuildIdDate
)
;
this
.
requestBodyTemplate
=
{
logger
:
"
javascript
"
platform
:
"
javascript
"
release
:
Services
.
appinfo
.
appBuildID
environment
:
UpdateUtils
.
getUpdateChannel
(
false
)
contexts
:
{
os
:
{
name
:
PLATFORM_NAMES
[
AppConstants
.
platform
]
version
:
(
Cc
[
"
mozilla
.
org
/
network
/
protocol
;
1
?
name
=
http
"
]
.
getService
(
Ci
.
nsIHttpProtocolHandler
)
.
oscpu
)
}
browser
:
{
name
:
"
Firefox
"
version
:
Services
.
appinfo
.
version
}
}
tags
:
{
changeset
:
AppConstants
.
SOURCE_REVISION_URL
}
sdk
:
{
name
:
SDK_NAME
version
:
SDK_VERSION
}
}
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
collectionEnabled
"
PREF_ENABLED
false
this
.
handleEnabledPrefChanged
.
bind
(
this
)
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
sampleRatePref
"
PREF_SAMPLE_RATE
"
0
.
0
"
this
.
handleSampleRatePrefChanged
.
bind
(
this
)
)
;
this
.
manglePrefixes
=
options
.
manglePrefixes
|
|
{
greDir
:
Services
.
dirsvc
.
get
(
"
GreD
"
Ci
.
nsIFile
)
profileDir
:
Services
.
dirsvc
.
get
(
"
ProfD
"
Ci
.
nsIFile
)
}
;
for
(
const
[
name
prefixFile
]
of
Object
.
entries
(
this
.
manglePrefixes
)
)
{
let
filePath
=
Services
.
io
.
newFileURI
(
prefixFile
)
.
filePath
;
if
(
!
filePath
.
endsWith
(
"
/
"
)
)
{
filePath
+
=
"
/
"
;
}
this
.
manglePrefixes
[
name
]
=
filePath
;
}
}
get
logger
(
)
{
const
logger
=
Log
.
repository
.
getLogger
(
"
BrowserErrorReporter
"
)
;
logger
.
addAppender
(
new
Log
.
ConsoleAppender
(
new
Log
.
BasicFormatter
(
)
)
)
;
logger
.
manageLevelFromPref
(
PREF_LOG_LEVEL
)
;
Object
.
defineProperty
(
this
"
logger
"
{
value
:
logger
}
)
;
return
this
.
logger
;
}
init
(
)
{
if
(
this
.
collectionEnabled
)
{
this
.
registerListener
(
)
;
for
(
const
message
of
Services
.
console
.
getMessageArray
(
)
)
{
this
.
observe
(
message
)
;
}
}
}
uninit
(
)
{
try
{
this
.
unregisterListener
(
)
;
}
catch
(
err
)
{
}
}
handleEnabledPrefChanged
(
prefName
previousValue
newValue
)
{
if
(
newValue
)
{
this
.
registerListener
(
)
;
}
else
{
try
{
this
.
unregisterListener
(
)
;
}
catch
(
err
)
{
}
}
}
handleSampleRatePrefChanged
(
prefName
previousValue
newValue
)
{
Services
.
telemetry
.
scalarSet
(
TELEMETRY_ERROR_SAMPLE_RATE
newValue
)
;
}
errorCollectedFilenameKey
(
filename
)
{
for
(
const
pattern
of
TELEMETRY_REPORTED_PATTERNS
)
{
if
(
filename
.
match
(
pattern
)
)
{
return
filename
;
}
}
if
(
filename
.
startsWith
(
"
moz
-
extension
:
/
/
"
)
)
{
return
"
MOZEXTENSION
"
;
}
return
"
FILTERED
"
;
}
isRecentBuild
(
)
{
const
now
=
this
.
now
|
|
new
Date
(
)
;
return
(
now
-
this
.
appBuildIdDate
)
<
=
RECENT_BUILD_AGE
;
}
observe
(
message
)
{
if
(
message
instanceof
Ci
.
nsIScriptError
)
{
ChromeUtils
.
idleDispatch
(
(
)
=
>
this
.
handleMessage
(
message
)
)
;
}
}
async
handleMessage
(
message
)
{
const
isWarning
=
message
.
flags
&
message
.
warningFlag
;
const
isFromChrome
=
REPORTED_CATEGORIES
.
has
(
message
.
category
)
;
if
(
(
this
.
chromeOnly
&
&
!
isFromChrome
)
|
|
isWarning
)
{
return
;
}
Services
.
telemetry
.
scalarAdd
(
TELEMETRY_ERROR_COLLECTED
1
)
;
if
(
message
.
stack
)
{
Services
.
telemetry
.
scalarAdd
(
TELEMETRY_ERROR_COLLECTED_STACK
1
)
;
}
if
(
message
.
sourceName
)
{
const
key
=
this
.
errorCollectedFilenameKey
(
message
.
sourceName
)
;
Services
.
telemetry
.
keyedScalarAdd
(
TELEMETRY_ERROR_COLLECTED_FILENAME
key
.
slice
(
0
69
)
1
)
;
}
if
(
!
AppConstants
.
NIGHTLY_BUILD
|
|
!
this
.
isRecentBuild
(
)
)
{
return
;
}
let
sampleRate
=
Number
.
parseFloat
(
this
.
sampleRatePref
)
;
for
(
const
[
regex
rate
]
of
this
.
sampleRates
)
{
if
(
message
.
sourceName
.
match
(
regex
)
)
{
sampleRate
=
rate
;
break
;
}
}
if
(
!
Number
.
isFinite
(
sampleRate
)
|
|
(
Math
.
random
(
)
>
=
sampleRate
)
)
{
return
;
}
const
exceptionValue
=
{
}
;
const
requestBody
=
{
.
.
.
this
.
requestBodyTemplate
timestamp
:
new
Date
(
)
.
toISOString
(
)
.
slice
(
0
-
1
)
project
:
Services
.
prefs
.
getCharPref
(
PREF_PROJECT_ID
)
exception
:
{
values
:
[
exceptionValue
]
}
}
;
const
transforms
=
[
addErrorMessage
addStacktrace
addModule
mangleExtensionUrls
this
.
mangleFilePaths
.
bind
(
this
)
tagExtensionErrors
]
;
for
(
const
transform
of
transforms
)
{
await
transform
(
message
exceptionValue
requestBody
)
;
}
const
url
=
new
URL
(
Services
.
prefs
.
getCharPref
(
PREF_SUBMIT_URL
)
)
;
url
.
searchParams
.
set
(
"
sentry_client
"
{
SDK_NAME
}
/
{
SDK_VERSION
}
)
;
url
.
searchParams
.
set
(
"
sentry_version
"
"
7
"
)
;
url
.
searchParams
.
set
(
"
sentry_key
"
Services
.
prefs
.
getCharPref
(
PREF_PUBLIC_KEY
)
)
;
try
{
await
this
.
fetch
(
url
{
method
:
"
POST
"
headers
:
{
"
Content
-
Type
"
:
"
application
/
json
"
"
Accept
"
:
"
application
/
json
"
}
referrer
:
"
https
:
/
/
fake
.
mozilla
.
org
"
body
:
JSON
.
stringify
(
requestBody
)
}
)
;
Services
.
telemetry
.
scalarAdd
(
TELEMETRY_ERROR_REPORTED
1
)
;
this
.
logger
.
debug
(
Sent
error
"
{
message
.
errorMessage
}
"
successfully
.
)
;
}
catch
(
error
)
{
Services
.
telemetry
.
scalarAdd
(
TELEMETRY_ERROR_REPORTED_FAIL
1
)
;
this
.
logger
.
warn
(
Failed
to
send
error
"
{
message
.
errorMessage
}
"
:
{
error
}
)
;
}
}
mangleFilePaths
(
message
exceptionValue
)
{
exceptionValue
.
module
=
this
.
_transformFilePath
(
exceptionValue
.
module
)
;
for
(
const
frame
of
exceptionValue
.
stacktrace
.
frames
)
{
frame
.
module
=
this
.
_transformFilePath
(
frame
.
module
)
;
}
}
_transformFilePath
(
path
)
{
try
{
const
uri
=
Services
.
io
.
newURI
(
path
)
;
if
(
uri
.
schemeIs
(
"
jar
"
)
)
{
return
uri
.
filePath
;
}
if
(
uri
.
schemeIs
(
"
file
"
)
)
{
for
(
const
[
name
prefix
]
of
Object
.
entries
(
this
.
manglePrefixes
)
)
{
if
(
uri
.
filePath
.
startsWith
(
prefix
)
)
{
return
uri
.
filePath
.
replace
(
prefix
[
{
name
}
]
/
)
;
}
}
return
"
[
UNKNOWN_LOCAL_FILEPATH
]
"
;
}
}
catch
(
err
)
{
}
return
path
;
}
}
function
defaultFetch
(
.
.
.
args
)
{
if
(
Cu
.
isInAutomation
)
{
return
null
;
}
return
fetch
(
.
.
.
args
)
;
}
function
addErrorMessage
(
message
exceptionValue
)
{
let
errorMessage
=
message
.
errorMessage
;
let
errorName
=
"
Error
"
;
if
(
message
.
errorMessage
.
match
(
ERROR_PREFIX_RE
)
)
{
const
parts
=
message
.
errorMessage
.
split
(
"
:
"
)
;
errorName
=
parts
[
0
]
;
errorMessage
=
parts
.
slice
(
1
)
.
join
(
"
:
"
)
.
trim
(
)
;
}
exceptionValue
.
type
=
errorName
;
exceptionValue
.
value
=
errorMessage
;
}
async
function
addStacktrace
(
message
exceptionValue
)
{
const
frames
=
[
]
;
let
frame
=
message
.
stack
;
while
(
frame
&
&
frames
.
length
<
100
)
{
const
normalizedFrame
=
{
function
:
frame
.
functionDisplayName
module
:
frame
.
source
lineno
:
frame
.
line
colno
:
frame
.
column
}
;
try
{
const
response
=
await
fetch
(
frame
.
source
)
;
const
sourceCode
=
await
response
.
text
(
)
;
const
sourceLines
=
sourceCode
.
split
(
/
\
r
?
\
n
/
)
;
let
lineIndex
=
Math
.
max
(
frame
.
line
-
1
0
)
;
if
(
frame
.
source
.
endsWith
(
"
.
xml
"
)
&
&
lineIndex
>
0
)
{
lineIndex
-
-
;
}
normalizedFrame
.
context_line
=
sourceLines
[
lineIndex
]
;
normalizedFrame
.
pre_context
=
sourceLines
.
slice
(
Math
.
max
(
lineIndex
-
CONTEXT_LINES
0
)
lineIndex
)
;
normalizedFrame
.
post_context
=
sourceLines
.
slice
(
lineIndex
+
1
Math
.
min
(
lineIndex
+
1
+
CONTEXT_LINES
sourceLines
.
length
)
)
;
}
catch
(
err
)
{
}
frames
.
push
(
normalizedFrame
)
;
frame
=
frame
.
parent
;
}
frames
.
reverse
(
)
;
exceptionValue
.
stacktrace
=
{
frames
}
;
}
function
addModule
(
message
exceptionValue
)
{
exceptionValue
.
module
=
message
.
sourceName
;
}
function
mangleExtensionUrls
(
message
exceptionValue
)
{
const
extensions
=
new
Map
(
)
;
for
(
let
extension
of
WebExtensionPolicy
.
getActiveExtensions
(
)
)
{
extensions
.
set
(
extension
.
mozExtensionHostname
extension
)
;
}
function
mangleExtURL
(
string
anchored
=
true
)
{
if
(
!
string
)
{
return
string
;
}
const
re
=
new
RegExp
(
{
anchored
?
"
^
"
:
"
"
}
moz
-
extension
:
/
/
(
[
^
/
]
+
)
/
"
g
"
)
;
return
string
.
replace
(
re
(
m0
m1
)
=
>
{
const
id
=
extensions
.
has
(
m1
)
?
extensions
.
get
(
m1
)
.
id
:
m1
;
return
moz
-
extension
:
/
/
{
id
}
/
;
}
)
;
}
exceptionValue
.
value
=
mangleExtURL
(
exceptionValue
.
value
false
)
;
exceptionValue
.
module
=
mangleExtURL
(
exceptionValue
.
module
)
;
for
(
const
frame
of
exceptionValue
.
stacktrace
.
frames
)
{
frame
.
module
=
mangleExtURL
(
frame
.
module
)
;
}
}
function
tagExtensionErrors
(
message
exceptionValue
requestBody
)
{
requestBody
.
tags
.
isExtensionError
=
!
!
(
exceptionValue
.
module
&
&
exceptionValue
.
module
.
startsWith
(
"
moz
-
extension
:
/
/
"
)
)
;
}
