ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Log
"
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
UpdateUtils
"
"
resource
:
/
/
gre
/
modules
/
UpdateUtils
.
jsm
"
)
;
Cu
.
importGlobalProperties
(
[
"
fetch
"
"
URL
"
]
)
;
var
EXPORTED_SYMBOLS
=
[
"
BrowserErrorReporter
"
]
;
const
CONTEXT_LINES
=
5
;
const
ERROR_PREFIX_RE
=
/
^
[
^
\
W
]
+
:
/
m
;
const
PREF_ENABLED
=
"
browser
.
chrome
.
errorReporter
.
enabled
"
;
const
PREF_LOG_LEVEL
=
"
browser
.
chrome
.
errorReporter
.
logLevel
"
;
const
PREF_PROJECT_ID
=
"
browser
.
chrome
.
errorReporter
.
projectId
"
;
const
PREF_PUBLIC_KEY
=
"
browser
.
chrome
.
errorReporter
.
publicKey
"
;
const
PREF_SAMPLE_RATE
=
"
browser
.
chrome
.
errorReporter
.
sampleRate
"
;
const
PREF_SUBMIT_URL
=
"
browser
.
chrome
.
errorReporter
.
submitUrl
"
;
const
SDK_NAME
=
"
firefox
-
error
-
reporter
"
;
const
SDK_VERSION
=
"
1
.
0
.
0
"
;
const
REPORTED_CATEGORIES
=
new
Set
(
[
"
XPConnect
JavaScript
"
"
component
javascript
"
"
chrome
javascript
"
"
chrome
registration
"
"
XBL
"
"
XBL
Prototype
Handler
"
"
XBL
Content
Sink
"
"
xbl
javascript
"
"
FrameConstructor
"
]
)
;
class
BrowserErrorReporter
{
constructor
(
fetchMethod
=
this
.
_defaultFetch
chromeOnly
=
true
)
{
this
.
fetch
=
fetchMethod
;
this
.
chromeOnly
=
chromeOnly
;
this
.
requestBodyTemplate
=
{
logger
:
"
javascript
"
platform
:
"
javascript
"
release
:
Services
.
appinfo
.
version
environment
:
UpdateUtils
.
getUpdateChannel
(
false
)
tags
:
{
appBuildID
:
Services
.
appinfo
.
appBuildID
changeset
:
AppConstants
.
SOURCE_REVISION_URL
}
sdk
:
{
name
:
SDK_NAME
version
:
SDK_VERSION
}
}
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
collectionEnabled
"
PREF_ENABLED
false
this
.
handleEnabledPrefChanged
.
bind
(
this
)
)
;
}
get
logger
(
)
{
const
logger
=
Log
.
repository
.
getLogger
(
"
BrowserErrorReporter
"
)
;
logger
.
addAppender
(
new
Log
.
ConsoleAppender
(
new
Log
.
BasicFormatter
(
)
)
)
;
logger
.
manageLevelFromPref
(
PREF_LOG_LEVEL
)
;
Object
.
defineProperty
(
this
"
logger
"
{
value
:
logger
}
)
;
return
this
.
logger
;
}
init
(
)
{
if
(
this
.
collectionEnabled
)
{
Services
.
console
.
registerListener
(
this
)
;
for
(
const
message
of
Services
.
console
.
getMessageArray
(
)
)
{
this
.
observe
(
message
)
;
}
}
}
uninit
(
)
{
try
{
Services
.
console
.
unregisterListener
(
this
)
;
}
catch
(
err
)
{
}
}
handleEnabledPrefChanged
(
prefName
previousValue
newValue
)
{
if
(
newValue
)
{
Services
.
console
.
registerListener
(
this
)
;
}
else
{
try
{
Services
.
console
.
unregisterListener
(
this
)
;
}
catch
(
err
)
{
}
}
}
async
observe
(
message
)
{
try
{
message
.
QueryInterface
(
Ci
.
nsIScriptError
)
;
}
catch
(
err
)
{
return
;
}
const
isWarning
=
message
.
flags
&
message
.
warningFlag
;
const
isFromChrome
=
REPORTED_CATEGORIES
.
has
(
message
.
category
)
;
if
(
(
this
.
chromeOnly
&
&
!
isFromChrome
)
|
|
isWarning
)
{
return
;
}
const
sampleRate
=
Number
.
parseFloat
(
Services
.
prefs
.
getCharPref
(
PREF_SAMPLE_RATE
)
)
;
if
(
!
Number
.
isFinite
(
sampleRate
)
|
|
(
Math
.
random
(
)
>
=
sampleRate
)
)
{
return
;
}
const
extensions
=
new
Map
(
)
;
for
(
let
extension
of
WebExtensionPolicy
.
getActiveExtensions
(
)
)
{
extensions
.
set
(
extension
.
mozExtensionHostname
extension
)
;
}
function
mangleExtURL
(
string
anchored
=
true
)
{
let
re
=
new
RegExp
(
{
anchored
?
"
^
"
:
"
"
}
moz
-
extension
:
/
/
(
[
^
/
]
+
)
/
"
g
"
)
;
return
string
.
replace
(
re
(
m0
m1
)
=
>
{
let
id
=
extensions
.
has
(
m1
)
?
extensions
.
get
(
m1
)
.
id
:
m1
;
return
moz
-
extension
:
/
/
{
id
}
/
;
}
)
;
}
let
errorMessage
=
message
.
errorMessage
;
let
errorName
=
"
Error
"
;
if
(
message
.
errorMessage
.
match
(
ERROR_PREFIX_RE
)
)
{
const
parts
=
message
.
errorMessage
.
split
(
"
:
"
)
;
errorName
=
parts
[
0
]
;
errorMessage
=
parts
.
slice
(
1
)
.
join
(
"
:
"
)
.
trim
(
)
;
}
const
frames
=
[
]
;
let
frame
=
message
.
stack
;
while
(
frame
&
&
frames
.
length
<
100
)
{
const
normalizedFrame
=
await
this
.
normalizeStackFrame
(
frame
)
;
normalizedFrame
.
module
=
mangleExtURL
(
normalizedFrame
.
module
false
)
;
frames
.
push
(
normalizedFrame
)
;
frame
=
frame
.
parent
;
}
frames
.
reverse
(
)
;
const
requestBody
=
Object
.
assign
(
{
}
this
.
requestBodyTemplate
{
timestamp
:
new
Date
(
)
.
toISOString
(
)
.
slice
(
0
-
1
)
project
:
Services
.
prefs
.
getCharPref
(
PREF_PROJECT_ID
)
exception
:
{
values
:
[
{
type
:
errorName
value
:
mangleExtURL
(
errorMessage
)
module
:
message
.
sourceName
stacktrace
:
{
frames
}
}
]
}
culprit
:
message
.
sourceName
}
)
;
const
url
=
new
URL
(
Services
.
prefs
.
getCharPref
(
PREF_SUBMIT_URL
)
)
;
url
.
searchParams
.
set
(
"
sentry_client
"
{
SDK_NAME
}
/
{
SDK_VERSION
}
)
;
url
.
searchParams
.
set
(
"
sentry_version
"
"
7
"
)
;
url
.
searchParams
.
set
(
"
sentry_key
"
Services
.
prefs
.
getCharPref
(
PREF_PUBLIC_KEY
)
)
;
try
{
await
this
.
fetch
(
url
{
method
:
"
POST
"
headers
:
{
"
Content
-
Type
"
:
"
application
/
json
"
"
Accept
"
:
"
application
/
json
"
}
referrer
:
"
https
:
/
/
fake
.
mozilla
.
org
"
body
:
JSON
.
stringify
(
requestBody
)
}
)
;
this
.
logger
.
debug
(
"
Sent
error
successfully
.
"
)
;
}
catch
(
error
)
{
this
.
logger
.
warn
(
Failed
to
send
error
:
{
error
}
)
;
}
}
async
normalizeStackFrame
(
frame
)
{
const
normalizedFrame
=
{
function
:
frame
.
functionDisplayName
module
:
frame
.
source
lineno
:
frame
.
line
colno
:
frame
.
column
}
;
try
{
const
response
=
await
fetch
(
frame
.
source
)
;
const
sourceCode
=
await
response
.
text
(
)
;
const
sourceLines
=
sourceCode
.
split
(
/
\
r
?
\
n
/
)
;
let
lineIndex
=
Math
.
max
(
frame
.
line
-
1
0
)
;
if
(
frame
.
source
.
endsWith
(
"
.
xml
"
)
&
&
lineIndex
>
0
)
{
lineIndex
-
-
;
}
normalizedFrame
.
context_line
=
sourceLines
[
lineIndex
]
;
normalizedFrame
.
pre_context
=
sourceLines
.
slice
(
Math
.
max
(
lineIndex
-
CONTEXT_LINES
0
)
lineIndex
)
;
normalizedFrame
.
post_context
=
sourceLines
.
slice
(
lineIndex
+
1
Math
.
min
(
lineIndex
+
1
+
CONTEXT_LINES
sourceLines
.
length
)
)
;
}
catch
(
err
)
{
}
return
normalizedFrame
;
}
async
_defaultFetch
(
.
.
.
args
)
{
if
(
Cu
.
isInAutomation
)
{
return
null
;
}
return
fetch
(
.
.
.
args
)
;
}
}
