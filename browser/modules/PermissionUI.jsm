"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
PermissionUI
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Services
"
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
SitePermissions
"
"
resource
:
/
/
/
modules
/
SitePermissions
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PrivateBrowsingUtils
"
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
URICountListener
"
"
resource
:
/
/
/
modules
/
BrowserUsageTelemetry
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PermissionUITelemetry
"
"
resource
:
/
/
/
modules
/
PermissionUITelemetry
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
IDNService
"
"
mozilla
.
org
/
network
/
idn
-
service
;
1
"
"
nsIIDNService
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gBrowserBundle
"
function
(
)
{
return
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
browser
/
locale
/
browser
.
properties
"
)
;
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
animationsEnabled
"
"
toolkit
.
cosmeticAnimations
.
enabled
"
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
postPromptAnimationEnabled
"
"
permissions
.
postPrompt
.
animate
"
)
;
var
PermissionUI
=
{
}
;
var
PermissionPromptPrototype
=
{
get
browser
(
)
{
throw
new
Error
(
"
Not
implemented
.
"
)
;
}
get
principal
(
)
{
throw
new
Error
(
"
Not
implemented
.
"
)
;
}
get
principalName
(
)
{
if
(
this
.
principal
.
addonPolicy
)
{
return
this
.
principal
.
addonPolicy
.
name
;
}
return
this
.
principal
.
URI
.
hostPort
;
}
get
permissionKey
(
)
{
return
undefined
;
}
get
permissionTelemetryKey
(
)
{
return
undefined
;
}
get
usePermissionManager
(
)
{
return
true
;
}
get
popupOptions
(
)
{
return
{
}
;
}
get
postPromptEnabled
(
)
{
return
false
;
}
get
requiresUserInput
(
)
{
return
false
;
}
get
notificationID
(
)
{
throw
new
Error
(
"
Not
implemented
.
"
)
;
}
get
anchorID
(
)
{
return
"
default
-
notification
-
icon
"
;
}
get
message
(
)
{
throw
new
Error
(
"
Not
implemented
.
"
)
;
}
cancel
(
)
{
throw
new
Error
(
"
Not
implemented
.
"
)
;
}
allow
(
)
{
throw
new
Error
(
"
Not
implemented
.
"
)
;
}
get
promptActions
(
)
{
return
[
]
;
}
get
postPromptActions
(
)
{
return
null
;
}
onBeforeShow
(
)
{
return
true
;
}
onShown
(
)
{
}
onAfterShow
(
)
{
}
prompt
(
)
{
let
requestingURI
=
this
.
principal
.
URI
;
if
(
!
(
requestingURI
instanceof
Ci
.
nsIStandardURL
)
)
{
return
;
}
if
(
this
.
usePermissionManager
&
&
this
.
permissionKey
)
{
let
{
state
}
=
SitePermissions
.
getForPrincipal
(
this
.
principal
this
.
permissionKey
this
.
browser
)
;
if
(
state
=
=
SitePermissions
.
BLOCK
)
{
if
(
this
.
postPromptEnabled
&
&
SitePermissions
.
getDefault
(
this
.
permissionKey
)
=
=
SitePermissions
.
BLOCK
)
{
this
.
postPrompt
(
)
;
}
this
.
cancel
(
)
;
return
;
}
if
(
state
=
=
SitePermissions
.
ALLOW
)
{
this
.
allow
(
)
;
return
;
}
this
.
browser
.
dispatchEvent
(
new
this
.
browser
.
ownerGlobal
.
CustomEvent
(
"
PermissionStateChange
"
)
)
;
}
else
if
(
this
.
permissionKey
)
{
let
{
state
}
=
SitePermissions
.
get
(
null
this
.
permissionKey
this
.
browser
)
;
if
(
state
=
=
SitePermissions
.
BLOCK
)
{
this
.
cancel
(
)
;
return
;
}
}
if
(
this
.
requiresUserInput
&
&
!
this
.
request
.
isHandlingUserInput
)
{
if
(
this
.
postPromptEnabled
)
{
this
.
postPrompt
(
)
;
}
this
.
cancel
(
)
;
return
;
}
let
chromeWin
=
this
.
browser
.
ownerGlobal
;
if
(
!
chromeWin
.
PopupNotifications
)
{
this
.
cancel
(
)
;
return
;
}
this
.
_buttonAction
=
null
;
let
popupNotificationActions
=
[
]
;
for
(
let
promptAction
of
this
.
promptActions
)
{
let
action
=
{
label
:
promptAction
.
label
accessKey
:
promptAction
.
accessKey
callback
:
state
=
>
{
if
(
promptAction
.
callback
)
{
promptAction
.
callback
(
)
;
}
if
(
this
.
usePermissionManager
&
&
this
.
permissionKey
)
{
if
(
(
state
&
&
state
.
checkboxChecked
&
&
state
.
source
!
=
"
esc
-
press
"
)
|
|
promptAction
.
scope
=
=
SitePermissions
.
SCOPE_PERSISTENT
)
{
let
scope
=
SitePermissions
.
SCOPE_PERSISTENT
;
if
(
PrivateBrowsingUtils
.
isBrowserPrivate
(
this
.
browser
)
)
{
scope
=
SitePermissions
.
SCOPE_SESSION
;
}
SitePermissions
.
setForPrincipal
(
this
.
principal
this
.
permissionKey
promptAction
.
action
scope
)
;
}
else
if
(
promptAction
.
action
=
=
SitePermissions
.
BLOCK
)
{
SitePermissions
.
setForPrincipal
(
this
.
principal
this
.
permissionKey
promptAction
.
action
SitePermissions
.
SCOPE_TEMPORARY
this
.
browser
)
;
}
if
(
promptAction
.
action
=
=
SitePermissions
.
ALLOW
)
{
this
.
_buttonAction
=
"
accept
"
;
this
.
allow
(
)
;
}
else
{
if
(
promptAction
.
scope
=
=
SitePermissions
.
SCOPE_PERSISTENT
)
{
this
.
_buttonAction
=
"
never
"
;
}
else
{
this
.
_buttonAction
=
"
deny
"
;
}
this
.
cancel
(
)
;
}
}
else
if
(
this
.
permissionKey
)
{
if
(
promptAction
.
action
=
=
SitePermissions
.
BLOCK
)
{
SitePermissions
.
set
(
null
this
.
permissionKey
promptAction
.
action
SitePermissions
.
SCOPE_TEMPORARY
this
.
browser
)
;
}
}
}
}
;
if
(
promptAction
.
dismiss
)
{
action
.
dismiss
=
promptAction
.
dismiss
;
}
popupNotificationActions
.
push
(
action
)
;
}
this
.
_showNotification
(
popupNotificationActions
)
;
}
postPrompt
(
)
{
let
browser
=
this
.
browser
;
let
principal
=
this
.
principal
;
let
chromeWin
=
browser
.
ownerGlobal
;
if
(
!
chromeWin
.
PopupNotifications
)
{
return
;
}
if
(
!
this
.
permissionKey
)
{
throw
new
Error
(
"
permissionKey
is
required
to
show
a
post
-
prompt
"
)
;
}
if
(
!
this
.
postPromptActions
)
{
throw
new
Error
(
"
postPromptActions
are
required
to
show
a
post
-
prompt
"
)
;
}
let
popupNotificationActions
=
[
]
;
for
(
let
promptAction
of
this
.
postPromptActions
)
{
let
action
=
{
label
:
promptAction
.
label
accessKey
:
promptAction
.
accessKey
callback
:
state
=
>
{
if
(
promptAction
.
callback
)
{
promptAction
.
callback
(
)
;
}
let
scope
=
SitePermissions
.
SCOPE_PERSISTENT
;
if
(
PrivateBrowsingUtils
.
isBrowserPrivate
(
browser
)
)
{
scope
=
SitePermissions
.
SCOPE_SESSION
;
}
SitePermissions
.
setForPrincipal
(
principal
this
.
permissionKey
promptAction
.
action
scope
)
;
}
}
;
popupNotificationActions
.
push
(
action
)
;
}
if
(
animationsEnabled
&
&
postPromptAnimationEnabled
)
{
let
anchor
=
chromeWin
.
document
.
getElementById
(
this
.
anchorID
)
;
anchor
.
addEventListener
(
"
animationend
"
(
)
=
>
anchor
.
removeAttribute
(
"
animate
"
)
{
once
:
true
}
)
;
anchor
.
setAttribute
(
"
animate
"
"
true
"
)
;
}
this
.
_showNotification
(
popupNotificationActions
true
)
;
}
_showNotification
(
actions
postPrompt
=
false
)
{
let
chromeWin
=
this
.
browser
.
ownerGlobal
;
let
mainAction
=
actions
.
length
?
actions
[
0
]
:
null
;
let
secondaryActions
=
actions
.
splice
(
1
)
;
let
options
=
this
.
popupOptions
;
let
telemetryData
=
null
;
if
(
this
.
request
&
&
this
.
permissionTelemetryKey
)
{
telemetryData
=
{
permissionTelemetryKey
:
this
.
permissionTelemetryKey
permissionKey
:
this
.
permissionKey
principal
:
this
.
principal
documentDOMContentLoadedTimestamp
:
this
.
request
.
documentDOMContentLoadedTimestamp
isHandlingUserInput
:
this
.
request
.
isHandlingUserInput
userHadInteractedWithDocument
:
this
.
request
.
userHadInteractedWithDocument
}
;
}
if
(
!
options
.
hasOwnProperty
(
"
displayURI
"
)
|
|
options
.
displayURI
)
{
options
.
displayURI
=
this
.
principal
.
URI
;
}
if
(
!
postPrompt
)
{
options
.
persistent
=
true
;
options
.
hideClose
=
true
;
}
options
.
eventCallback
=
(
topic
nextRemovalReason
)
=
>
{
if
(
topic
=
=
"
swapping
"
)
{
return
true
;
}
if
(
topic
=
=
"
shown
"
&
&
!
postPrompt
)
{
this
.
onShown
(
)
;
}
if
(
topic
=
=
"
removed
"
&
&
!
postPrompt
)
{
if
(
telemetryData
)
{
PermissionUITelemetry
.
onRemoved
(
telemetryData
this
.
_buttonAction
nextRemovalReason
)
;
}
this
.
onAfterShow
(
)
;
}
return
false
;
}
;
options
.
dismissed
=
postPrompt
;
if
(
postPrompt
|
|
this
.
onBeforeShow
(
)
!
=
=
false
)
{
chromeWin
.
PopupNotifications
.
show
(
this
.
browser
this
.
notificationID
this
.
message
this
.
anchorID
mainAction
secondaryActions
options
)
;
if
(
telemetryData
)
{
PermissionUITelemetry
.
onShow
(
telemetryData
)
;
}
}
}
}
;
PermissionUI
.
PermissionPromptPrototype
=
PermissionPromptPrototype
;
var
PermissionPromptForRequestPrototype
=
{
__proto__
:
PermissionPromptPrototype
get
browser
(
)
{
if
(
this
.
request
.
element
)
{
return
this
.
request
.
element
;
}
return
this
.
request
.
window
.
docShell
.
chromeEventHandler
;
}
get
principal
(
)
{
return
this
.
request
.
principal
;
}
cancel
(
)
{
this
.
request
.
cancel
(
)
;
}
allow
(
choices
)
{
this
.
request
.
allow
(
choices
)
;
}
}
;
PermissionUI
.
PermissionPromptForRequestPrototype
=
PermissionPromptForRequestPrototype
;
function
GeolocationPermissionPrompt
(
request
)
{
this
.
request
=
request
;
}
GeolocationPermissionPrompt
.
prototype
=
{
__proto__
:
PermissionPromptForRequestPrototype
get
permissionKey
(
)
{
return
"
geo
"
;
}
get
permissionTelemetryKey
(
)
{
return
"
geo
"
;
}
get
popupOptions
(
)
{
let
pref
=
"
browser
.
geolocation
.
warning
.
infoURL
"
;
let
options
=
{
learnMoreURL
:
Services
.
urlFormatter
.
formatURLPref
(
pref
)
displayURI
:
false
name
:
this
.
principalName
}
;
if
(
this
.
principal
.
URI
.
schemeIs
(
"
file
"
)
)
{
options
.
checkbox
=
{
show
:
false
}
;
}
else
{
options
.
checkbox
=
{
show
:
!
PrivateBrowsingUtils
.
isWindowPrivate
(
this
.
browser
.
ownerGlobal
)
}
;
}
if
(
options
.
checkbox
.
show
)
{
options
.
checkbox
.
label
=
gBrowserBundle
.
GetStringFromName
(
"
geolocation
.
remember
"
)
;
}
return
options
;
}
get
notificationID
(
)
{
return
"
geolocation
"
;
}
get
anchorID
(
)
{
return
"
geo
-
notification
-
icon
"
;
}
get
message
(
)
{
if
(
this
.
principal
.
URI
.
schemeIs
(
"
file
"
)
)
{
return
gBrowserBundle
.
GetStringFromName
(
"
geolocation
.
shareWithFile3
"
)
;
}
return
gBrowserBundle
.
formatStringFromName
(
"
geolocation
.
shareWithSite3
"
[
"
<
>
"
]
)
;
}
get
promptActions
(
)
{
return
[
{
label
:
gBrowserBundle
.
GetStringFromName
(
"
geolocation
.
allowLocation
"
)
accessKey
:
gBrowserBundle
.
GetStringFromName
(
"
geolocation
.
allowLocation
.
accesskey
"
)
action
:
SitePermissions
.
ALLOW
}
{
label
:
gBrowserBundle
.
GetStringFromName
(
"
geolocation
.
dontAllowLocation
"
)
accessKey
:
gBrowserBundle
.
GetStringFromName
(
"
geolocation
.
dontAllowLocation
.
accesskey
"
)
action
:
SitePermissions
.
BLOCK
}
]
;
}
}
;
PermissionUI
.
GeolocationPermissionPrompt
=
GeolocationPermissionPrompt
;
function
DesktopNotificationPermissionPrompt
(
request
)
{
this
.
request
=
request
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
requiresUserInput
"
"
dom
.
webnotifications
.
requireuserinteraction
"
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
postPromptEnabled
"
"
permissions
.
desktop
-
notification
.
postPrompt
.
enabled
"
)
;
}
DesktopNotificationPermissionPrompt
.
prototype
=
{
__proto__
:
PermissionPromptForRequestPrototype
get
permissionKey
(
)
{
return
"
desktop
-
notification
"
;
}
get
permissionTelemetryKey
(
)
{
return
"
notifications
"
;
}
get
popupOptions
(
)
{
let
learnMoreURL
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
+
"
push
"
;
return
{
learnMoreURL
displayURI
:
false
name
:
this
.
principalName
}
;
}
get
notificationID
(
)
{
return
"
web
-
notifications
"
;
}
get
anchorID
(
)
{
return
"
web
-
notifications
-
notification
-
icon
"
;
}
get
message
(
)
{
return
gBrowserBundle
.
formatStringFromName
(
"
webNotifications
.
receiveFromSite2
"
[
"
<
>
"
]
)
;
}
get
promptActions
(
)
{
let
actions
=
[
{
label
:
gBrowserBundle
.
GetStringFromName
(
"
webNotifications
.
allow
"
)
accessKey
:
gBrowserBundle
.
GetStringFromName
(
"
webNotifications
.
allow
.
accesskey
"
)
action
:
SitePermissions
.
ALLOW
scope
:
SitePermissions
.
SCOPE_PERSISTENT
}
{
label
:
gBrowserBundle
.
GetStringFromName
(
"
webNotifications
.
notNow
"
)
accessKey
:
gBrowserBundle
.
GetStringFromName
(
"
webNotifications
.
notNow
.
accesskey
"
)
action
:
SitePermissions
.
BLOCK
}
]
;
if
(
!
PrivateBrowsingUtils
.
isBrowserPrivate
(
this
.
browser
)
)
{
actions
.
push
(
{
label
:
gBrowserBundle
.
GetStringFromName
(
"
webNotifications
.
never
"
)
accessKey
:
gBrowserBundle
.
GetStringFromName
(
"
webNotifications
.
never
.
accesskey
"
)
action
:
SitePermissions
.
BLOCK
scope
:
SitePermissions
.
SCOPE_PERSISTENT
}
)
;
}
return
actions
;
}
get
postPromptActions
(
)
{
return
[
{
label
:
gBrowserBundle
.
GetStringFromName
(
"
webNotifications
.
allow
"
)
accessKey
:
gBrowserBundle
.
GetStringFromName
(
"
webNotifications
.
allow
.
accesskey
"
)
action
:
SitePermissions
.
ALLOW
}
{
label
:
gBrowserBundle
.
GetStringFromName
(
"
webNotifications
.
never
"
)
accessKey
:
gBrowserBundle
.
GetStringFromName
(
"
webNotifications
.
never
.
accesskey
"
)
action
:
SitePermissions
.
BLOCK
}
]
;
}
}
;
PermissionUI
.
DesktopNotificationPermissionPrompt
=
DesktopNotificationPermissionPrompt
;
function
PersistentStoragePermissionPrompt
(
request
)
{
this
.
request
=
request
;
}
PersistentStoragePermissionPrompt
.
prototype
=
{
__proto__
:
PermissionPromptForRequestPrototype
get
permissionKey
(
)
{
return
"
persistent
-
storage
"
;
}
get
popupOptions
(
)
{
let
learnMoreURL
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
+
"
storage
-
permissions
"
;
return
{
learnMoreURL
displayURI
:
false
name
:
this
.
principalName
}
;
}
get
notificationID
(
)
{
return
"
persistent
-
storage
"
;
}
get
anchorID
(
)
{
return
"
persistent
-
storage
-
notification
-
icon
"
;
}
get
message
(
)
{
return
gBrowserBundle
.
formatStringFromName
(
"
persistentStorage
.
allowWithSite
"
[
"
<
>
"
]
)
;
}
get
promptActions
(
)
{
return
[
{
label
:
gBrowserBundle
.
GetStringFromName
(
"
persistentStorage
.
allow
"
)
accessKey
:
gBrowserBundle
.
GetStringFromName
(
"
persistentStorage
.
allow
.
accesskey
"
)
action
:
Ci
.
nsIPermissionManager
.
ALLOW_ACTION
scope
:
SitePermissions
.
SCOPE_PERSISTENT
}
{
label
:
gBrowserBundle
.
GetStringFromName
(
"
persistentStorage
.
notNow
.
label
"
)
accessKey
:
gBrowserBundle
.
GetStringFromName
(
"
persistentStorage
.
notNow
.
accesskey
"
)
action
:
Ci
.
nsIPermissionManager
.
DENY_ACTION
}
{
label
:
gBrowserBundle
.
GetStringFromName
(
"
persistentStorage
.
neverAllow
.
label
"
)
accessKey
:
gBrowserBundle
.
GetStringFromName
(
"
persistentStorage
.
neverAllow
.
accesskey
"
)
action
:
SitePermissions
.
BLOCK
scope
:
SitePermissions
.
SCOPE_PERSISTENT
}
]
;
}
}
;
PermissionUI
.
PersistentStoragePermissionPrompt
=
PersistentStoragePermissionPrompt
;
function
MIDIPermissionPrompt
(
request
)
{
this
.
request
=
request
;
let
types
=
request
.
types
.
QueryInterface
(
Ci
.
nsIArray
)
;
let
perm
=
types
.
queryElementAt
(
0
Ci
.
nsIContentPermissionType
)
;
this
.
isSysexPerm
=
(
perm
.
options
.
length
>
0
&
&
perm
.
options
.
queryElementAt
(
0
Ci
.
nsISupportsString
)
=
=
"
sysex
"
)
;
this
.
permName
=
"
midi
"
;
if
(
this
.
isSysexPerm
)
{
this
.
permName
=
"
midi
-
sysex
"
;
}
}
MIDIPermissionPrompt
.
prototype
=
{
__proto__
:
PermissionPromptForRequestPrototype
get
permissionKey
(
)
{
return
this
.
permName
;
}
get
popupOptions
(
)
{
let
options
=
{
displayURI
:
false
name
:
this
.
principalName
}
;
if
(
this
.
principal
.
URI
.
schemeIs
(
"
file
"
)
)
{
options
.
checkbox
=
{
show
:
false
}
;
}
else
{
options
.
checkbox
=
{
show
:
!
PrivateBrowsingUtils
.
isWindowPrivate
(
this
.
browser
.
ownerGlobal
)
}
;
}
if
(
options
.
checkbox
.
show
)
{
options
.
checkbox
.
label
=
gBrowserBundle
.
GetStringFromName
(
"
midi
.
remember
"
)
;
}
return
options
;
}
get
notificationID
(
)
{
return
"
midi
"
;
}
get
anchorID
(
)
{
return
"
midi
-
notification
-
icon
"
;
}
get
message
(
)
{
let
message
;
if
(
this
.
principal
.
URI
.
schemeIs
(
"
file
"
)
)
{
if
(
this
.
isSysexPerm
)
{
message
=
gBrowserBundle
.
formatStringFromName
(
"
midi
.
shareSysexWithFile
.
message
"
)
;
}
else
{
message
=
gBrowserBundle
.
formatStringFromName
(
"
midi
.
shareWithFile
.
message
"
)
;
}
}
else
if
(
this
.
isSysexPerm
)
{
message
=
gBrowserBundle
.
formatStringFromName
(
"
midi
.
shareSysexWithSite
.
message
"
[
"
<
>
"
]
)
;
}
else
{
message
=
gBrowserBundle
.
formatStringFromName
(
"
midi
.
shareWithSite
.
message
"
[
"
<
>
"
]
)
;
}
return
message
;
}
get
promptActions
(
)
{
return
[
{
label
:
gBrowserBundle
.
GetStringFromName
(
"
midi
.
Allow
.
label
"
)
accessKey
:
gBrowserBundle
.
GetStringFromName
(
"
midi
.
Allow
.
accesskey
"
)
action
:
Ci
.
nsIPermissionManager
.
ALLOW_ACTION
}
{
label
:
gBrowserBundle
.
GetStringFromName
(
"
midi
.
DontAllow
.
label
"
)
accessKey
:
gBrowserBundle
.
GetStringFromName
(
"
midi
.
DontAllow
.
accesskey
"
)
action
:
Ci
.
nsIPermissionManager
.
DENY_ACTION
}
]
;
}
}
;
PermissionUI
.
MIDIPermissionPrompt
=
MIDIPermissionPrompt
;
function
StorageAccessPermissionPrompt
(
request
)
{
this
.
request
=
request
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
_autoGrants
"
"
dom
.
storage_access
.
auto_grants
"
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
_maxConcurrentAutoGrants
"
"
dom
.
storage_access
.
max_concurrent_auto_grants
"
)
;
}
StorageAccessPermissionPrompt
.
prototype
=
{
__proto__
:
PermissionPromptForRequestPrototype
get
usePermissionManager
(
)
{
return
false
;
}
get
permissionKey
(
)
{
return
"
storage
-
access
-
"
+
this
.
principal
.
origin
;
}
prettifyHostPort
(
uri
)
{
try
{
uri
=
Services
.
uriFixup
.
createExposableURI
(
uri
)
;
}
catch
(
e
)
{
}
let
host
=
IDNService
.
convertToDisplayIDN
(
uri
.
host
{
}
)
;
if
(
uri
.
port
!
=
-
1
)
{
host
+
=
:
{
uri
.
port
}
;
}
return
host
;
}
get
popupOptions
(
)
{
return
{
displayURI
:
false
name
:
this
.
prettifyHostPort
(
this
.
principal
.
URI
)
secondName
:
this
.
prettifyHostPort
(
this
.
topLevelPrincipal
.
URI
)
escAction
:
"
buttoncommand
"
}
;
}
onShown
(
)
{
let
document
=
this
.
browser
.
ownerDocument
;
let
label
=
gBrowserBundle
.
formatStringFromName
(
"
storageAccess
.
description
.
label
"
[
this
.
prettifyHostPort
(
this
.
request
.
principal
.
URI
)
"
<
>
"
]
)
;
let
parts
=
label
.
split
(
"
<
>
"
)
;
if
(
parts
.
length
=
=
1
)
{
parts
.
push
(
"
"
)
;
}
let
map
=
{
"
storage
-
access
-
perm
-
label
"
:
parts
[
0
]
"
storage
-
access
-
perm
-
learnmore
"
:
gBrowserBundle
.
GetStringFromName
(
"
storageAccess
.
description
.
learnmore
"
)
"
storage
-
access
-
perm
-
endlabel
"
:
parts
[
1
]
}
;
for
(
let
id
in
map
)
{
let
str
=
map
[
id
]
;
document
.
getElementById
(
id
)
.
textContent
=
str
;
}
let
learnMoreURL
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
+
"
third
-
party
-
cookies
"
;
document
.
getElementById
(
"
storage
-
access
-
perm
-
learnmore
"
)
.
href
=
learnMoreURL
;
}
get
notificationID
(
)
{
return
"
storage
-
access
"
;
}
get
anchorID
(
)
{
return
"
storage
-
access
-
notification
-
icon
"
;
}
get
message
(
)
{
return
gBrowserBundle
.
formatStringFromName
(
"
storageAccess
.
message
"
[
"
<
>
"
"
<
>
"
]
)
;
}
get
promptActions
(
)
{
let
self
=
this
;
let
storageAccessHistogram
=
Services
.
telemetry
.
getHistogramById
(
"
STORAGE_ACCESS_API_UI
"
)
;
return
[
{
label
:
gBrowserBundle
.
GetStringFromName
(
"
storageAccess
.
DontAllow
.
label
"
)
accessKey
:
gBrowserBundle
.
GetStringFromName
(
"
storageAccess
.
DontAllow
.
accesskey
"
)
action
:
Ci
.
nsIPermissionManager
.
DENY_ACTION
callback
(
state
)
{
storageAccessHistogram
.
add
(
"
Deny
"
)
;
self
.
cancel
(
)
;
}
}
{
label
:
gBrowserBundle
.
GetStringFromName
(
"
storageAccess
.
Allow
.
label
"
)
accessKey
:
gBrowserBundle
.
GetStringFromName
(
"
storageAccess
.
Allow
.
accesskey
"
)
action
:
Ci
.
nsIPermissionManager
.
ALLOW_ACTION
callback
(
state
)
{
storageAccessHistogram
.
add
(
"
Allow
"
)
;
self
.
allow
(
{
"
storage
-
access
"
:
"
allow
"
}
)
;
}
}
{
label
:
gBrowserBundle
.
GetStringFromName
(
"
storageAccess
.
AllowOnAnySite
.
label
"
)
accessKey
:
gBrowserBundle
.
GetStringFromName
(
"
storageAccess
.
AllowOnAnySite
.
accesskey
"
)
action
:
Ci
.
nsIPermissionManager
.
ALLOW_ACTION
callback
(
state
)
{
storageAccessHistogram
.
add
(
"
AllowOnAnySite
"
)
;
self
.
allow
(
{
"
storage
-
access
"
:
"
allow
-
on
-
any
-
site
"
}
)
;
}
}
]
;
}
get
topLevelPrincipal
(
)
{
return
this
.
request
.
topLevelPrincipal
;
}
get
maxConcurrentAutomaticGrants
(
)
{
return
Math
.
max
(
Math
.
max
(
Math
.
floor
(
URICountListener
.
uniqueDomainsVisitedInPast24Hours
/
100
)
this
.
_maxConcurrentAutoGrants
)
0
)
;
}
getOriginsThirdPartyHasAccessTo
(
thirdPartyOrigin
)
{
let
prefix
=
3rdPartyStorage
^
{
thirdPartyOrigin
}
;
let
perms
=
Services
.
perms
.
getAllWithTypePrefix
(
prefix
)
;
let
origins
=
new
Set
(
)
;
while
(
perms
.
length
)
{
let
perm
=
perms
.
shift
(
)
;
if
(
perm
.
type
!
=
prefix
&
&
!
perm
.
type
.
startsWith
(
{
prefix
}
^
)
)
{
continue
;
}
origins
.
add
(
perm
.
principal
.
origin
)
;
}
return
origins
.
size
;
}
onBeforeShow
(
)
{
let
storageAccessHistogram
=
Services
.
telemetry
.
getHistogramById
(
"
STORAGE_ACCESS_API_UI
"
)
;
storageAccessHistogram
.
add
(
"
Request
"
)
;
let
thirdPartyOrigin
=
this
.
request
.
principal
.
origin
;
if
(
this
.
_autoGrants
&
&
this
.
getOriginsThirdPartyHasAccessTo
(
thirdPartyOrigin
)
<
this
.
maxConcurrentAutomaticGrants
)
{
this
.
allow
(
{
"
storage
-
access
"
:
"
allow
-
auto
-
grant
"
}
)
;
storageAccessHistogram
.
add
(
"
AllowAutomatically
"
)
;
return
false
;
}
return
true
;
}
}
;
PermissionUI
.
StorageAccessPermissionPrompt
=
StorageAccessPermissionPrompt
;
