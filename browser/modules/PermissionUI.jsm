"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
PermissionUI
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
SitePermissions
"
"
resource
:
/
/
/
modules
/
SitePermissions
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
PrivateBrowsingUtils
"
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
lazy
"
IDNService
"
"
mozilla
.
org
/
network
/
idn
-
service
;
1
"
"
nsIIDNService
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
lazy
"
ContentPrefService2
"
"
mozilla
.
org
/
content
-
pref
/
service
;
1
"
"
nsIContentPrefService2
"
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
gBrowserBundle
"
function
(
)
{
return
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
browser
/
locale
/
browser
.
properties
"
)
;
}
)
;
var
PermissionUI
=
{
}
;
var
PermissionPromptPrototype
=
{
get
browser
(
)
{
throw
new
Error
(
"
Not
implemented
.
"
)
;
}
get
principal
(
)
{
throw
new
Error
(
"
Not
implemented
.
"
)
;
}
get
type
(
)
{
return
undefined
;
}
get
permissionKey
(
)
{
return
undefined
;
}
get
usePermissionManager
(
)
{
return
true
;
}
get
popupOptions
(
)
{
return
{
}
;
}
get
postPromptEnabled
(
)
{
return
false
;
}
get
requiresUserInput
(
)
{
return
false
;
}
get
notificationID
(
)
{
throw
new
Error
(
"
Not
implemented
.
"
)
;
}
get
anchorID
(
)
{
return
"
default
-
notification
-
icon
"
;
}
get
message
(
)
{
throw
new
Error
(
"
Not
implemented
.
"
)
;
}
getPrincipalName
(
principal
=
this
.
principal
)
{
if
(
principal
.
addonPolicy
)
{
return
principal
.
addonPolicy
.
name
;
}
return
principal
.
hostPort
;
}
cancel
(
)
{
throw
new
Error
(
"
Not
implemented
.
"
)
;
}
allow
(
)
{
throw
new
Error
(
"
Not
implemented
.
"
)
;
}
get
promptActions
(
)
{
return
[
]
;
}
get
postPromptActions
(
)
{
return
null
;
}
onBeforeShow
(
)
{
return
true
;
}
onShown
(
)
{
}
onAfterShow
(
)
{
}
prompt
(
)
{
let
requestingURI
=
this
.
principal
.
URI
;
if
(
!
(
requestingURI
instanceof
Ci
.
nsIStandardURL
)
)
{
return
;
}
if
(
this
.
usePermissionManager
&
&
this
.
permissionKey
)
{
let
{
state
}
=
lazy
.
SitePermissions
.
getForPrincipal
(
this
.
principal
this
.
permissionKey
this
.
browser
)
;
if
(
state
=
=
lazy
.
SitePermissions
.
BLOCK
)
{
if
(
this
.
postPromptEnabled
&
&
lazy
.
SitePermissions
.
getDefault
(
this
.
permissionKey
)
=
=
lazy
.
SitePermissions
.
BLOCK
)
{
this
.
postPrompt
(
)
;
}
this
.
cancel
(
)
;
return
;
}
if
(
state
=
=
lazy
.
SitePermissions
.
ALLOW
&
&
!
this
.
request
.
isRequestDelegatedToUnsafeThirdParty
)
{
this
.
allow
(
)
;
return
;
}
}
else
if
(
this
.
permissionKey
)
{
let
{
state
}
=
lazy
.
SitePermissions
.
getForPrincipal
(
null
this
.
permissionKey
this
.
browser
)
;
if
(
state
=
=
lazy
.
SitePermissions
.
BLOCK
)
{
this
.
cancel
(
)
;
return
;
}
}
if
(
this
.
requiresUserInput
&
&
!
this
.
request
.
hasValidTransientUserGestureActivation
)
{
if
(
this
.
postPromptEnabled
)
{
this
.
postPrompt
(
)
;
}
this
.
cancel
(
)
;
return
;
}
let
chromeWin
=
this
.
browser
.
ownerGlobal
;
if
(
!
chromeWin
.
PopupNotifications
)
{
this
.
cancel
(
)
;
return
;
}
let
popupNotificationActions
=
[
]
;
for
(
let
promptAction
of
this
.
promptActions
)
{
let
action
=
{
label
:
promptAction
.
label
accessKey
:
promptAction
.
accessKey
callback
:
state
=
>
{
if
(
promptAction
.
callback
)
{
promptAction
.
callback
(
)
;
}
if
(
this
.
usePermissionManager
&
&
this
.
permissionKey
)
{
if
(
(
state
&
&
state
.
checkboxChecked
&
&
state
.
source
!
=
"
esc
-
press
"
)
|
|
promptAction
.
scope
=
=
lazy
.
SitePermissions
.
SCOPE_PERSISTENT
)
{
let
scope
=
lazy
.
SitePermissions
.
SCOPE_PERSISTENT
;
if
(
lazy
.
PrivateBrowsingUtils
.
isBrowserPrivate
(
this
.
browser
)
)
{
scope
=
lazy
.
SitePermissions
.
SCOPE_SESSION
;
}
lazy
.
SitePermissions
.
setForPrincipal
(
this
.
principal
this
.
permissionKey
promptAction
.
action
scope
)
;
}
else
if
(
promptAction
.
action
=
=
lazy
.
SitePermissions
.
BLOCK
)
{
lazy
.
SitePermissions
.
setForPrincipal
(
this
.
principal
this
.
permissionKey
promptAction
.
action
lazy
.
SitePermissions
.
SCOPE_TEMPORARY
this
.
browser
)
;
}
if
(
promptAction
.
action
=
=
lazy
.
SitePermissions
.
ALLOW
)
{
this
.
allow
(
)
;
}
else
{
this
.
cancel
(
)
;
}
}
else
if
(
this
.
permissionKey
)
{
if
(
promptAction
.
action
=
=
lazy
.
SitePermissions
.
BLOCK
)
{
lazy
.
SitePermissions
.
setForPrincipal
(
null
this
.
permissionKey
promptAction
.
action
lazy
.
SitePermissions
.
SCOPE_TEMPORARY
this
.
browser
)
;
}
}
}
}
;
if
(
promptAction
.
dismiss
)
{
action
.
dismiss
=
promptAction
.
dismiss
;
}
popupNotificationActions
.
push
(
action
)
;
}
this
.
_showNotification
(
popupNotificationActions
)
;
}
postPrompt
(
)
{
let
browser
=
this
.
browser
;
let
principal
=
this
.
principal
;
let
chromeWin
=
browser
.
ownerGlobal
;
if
(
!
chromeWin
.
PopupNotifications
)
{
return
;
}
if
(
!
this
.
permissionKey
)
{
throw
new
Error
(
"
permissionKey
is
required
to
show
a
post
-
prompt
"
)
;
}
if
(
!
this
.
postPromptActions
)
{
throw
new
Error
(
"
postPromptActions
are
required
to
show
a
post
-
prompt
"
)
;
}
let
popupNotificationActions
=
[
]
;
for
(
let
promptAction
of
this
.
postPromptActions
)
{
let
action
=
{
label
:
promptAction
.
label
accessKey
:
promptAction
.
accessKey
callback
:
state
=
>
{
if
(
promptAction
.
callback
)
{
promptAction
.
callback
(
)
;
}
let
scope
=
lazy
.
SitePermissions
.
SCOPE_PERSISTENT
;
if
(
lazy
.
PrivateBrowsingUtils
.
isBrowserPrivate
(
browser
)
)
{
scope
=
lazy
.
SitePermissions
.
SCOPE_SESSION
;
}
lazy
.
SitePermissions
.
setForPrincipal
(
principal
this
.
permissionKey
promptAction
.
action
scope
)
;
}
}
;
popupNotificationActions
.
push
(
action
)
;
}
if
(
!
chromeWin
.
gReduceMotion
)
{
let
anchor
=
chromeWin
.
document
.
getElementById
(
this
.
anchorID
)
;
anchor
.
addEventListener
(
"
animationend
"
(
)
=
>
anchor
.
removeAttribute
(
"
animate
"
)
{
once
:
true
}
)
;
anchor
.
setAttribute
(
"
animate
"
"
true
"
)
;
}
this
.
_showNotification
(
popupNotificationActions
true
)
;
}
_showNotification
(
actions
postPrompt
=
false
)
{
let
chromeWin
=
this
.
browser
.
ownerGlobal
;
let
mainAction
=
actions
.
length
?
actions
[
0
]
:
null
;
let
secondaryActions
=
actions
.
splice
(
1
)
;
let
options
=
this
.
popupOptions
;
if
(
!
options
.
hasOwnProperty
(
"
displayURI
"
)
|
|
options
.
displayURI
)
{
options
.
displayURI
=
this
.
principal
.
URI
;
}
if
(
!
postPrompt
)
{
options
.
persistent
=
true
;
options
.
hideClose
=
true
;
}
options
.
eventCallback
=
(
topic
nextRemovalReason
isCancel
)
=
>
{
if
(
topic
=
=
"
swapping
"
)
{
return
true
;
}
if
(
topic
=
=
"
shown
"
&
&
!
postPrompt
)
{
this
.
onShown
(
)
;
}
if
(
topic
=
=
"
removed
"
&
&
!
postPrompt
)
{
if
(
isCancel
)
{
this
.
cancel
(
)
;
}
this
.
onAfterShow
(
)
;
}
return
false
;
}
;
options
.
dismissed
=
postPrompt
;
if
(
postPrompt
|
|
this
.
onBeforeShow
(
)
!
=
=
false
)
{
chromeWin
.
PopupNotifications
.
show
(
this
.
browser
this
.
notificationID
this
.
message
this
.
anchorID
mainAction
secondaryActions
options
)
;
}
}
}
;
PermissionUI
.
PermissionPromptPrototype
=
PermissionPromptPrototype
;
var
PermissionPromptForRequestPrototype
=
{
__proto__
:
PermissionPromptPrototype
get
browser
(
)
{
if
(
this
.
request
.
element
)
{
return
this
.
request
.
element
;
}
return
this
.
request
.
window
.
docShell
.
chromeEventHandler
;
}
get
principal
(
)
{
let
request
=
this
.
request
.
QueryInterface
(
Ci
.
nsIContentPermissionRequest
)
;
return
request
.
getDelegatePrincipal
(
this
.
type
)
;
}
cancel
(
)
{
this
.
request
.
cancel
(
)
;
}
allow
(
choices
)
{
this
.
request
.
allow
(
choices
)
;
}
}
;
PermissionUI
.
PermissionPromptForRequestPrototype
=
PermissionPromptForRequestPrototype
;
function
GeolocationPermissionPrompt
(
request
)
{
this
.
request
=
request
;
}
GeolocationPermissionPrompt
.
prototype
=
{
__proto__
:
PermissionPromptForRequestPrototype
get
type
(
)
{
return
"
geo
"
;
}
get
permissionKey
(
)
{
return
"
geo
"
;
}
get
popupOptions
(
)
{
let
pref
=
"
browser
.
geolocation
.
warning
.
infoURL
"
;
let
options
=
{
learnMoreURL
:
Services
.
urlFormatter
.
formatURLPref
(
pref
)
displayURI
:
false
name
:
this
.
getPrincipalName
(
)
}
;
if
(
this
.
principal
.
schemeIs
(
"
file
"
)
)
{
options
.
checkbox
=
{
show
:
false
}
;
}
else
{
options
.
checkbox
=
{
show
:
!
lazy
.
PrivateBrowsingUtils
.
isWindowPrivate
(
this
.
browser
.
ownerGlobal
)
}
;
}
if
(
this
.
request
.
isRequestDelegatedToUnsafeThirdParty
)
{
options
.
secondName
=
this
.
getPrincipalName
(
this
.
request
.
principal
)
;
options
.
checkbox
=
{
show
:
false
}
;
}
if
(
options
.
checkbox
.
show
)
{
options
.
checkbox
.
label
=
lazy
.
gBrowserBundle
.
GetStringFromName
(
"
geolocation
.
remember
"
)
;
}
return
options
;
}
get
notificationID
(
)
{
return
"
geolocation
"
;
}
get
anchorID
(
)
{
return
"
geo
-
notification
-
icon
"
;
}
get
message
(
)
{
if
(
this
.
principal
.
schemeIs
(
"
file
"
)
)
{
return
lazy
.
gBrowserBundle
.
GetStringFromName
(
"
geolocation
.
shareWithFile4
"
)
;
}
if
(
this
.
request
.
isRequestDelegatedToUnsafeThirdParty
)
{
return
lazy
.
gBrowserBundle
.
formatStringFromName
(
"
geolocation
.
shareWithSiteUnsafeDelegation2
"
[
"
<
>
"
"
{
}
"
]
)
;
}
return
lazy
.
gBrowserBundle
.
formatStringFromName
(
"
geolocation
.
shareWithSite4
"
[
"
<
>
"
]
)
;
}
get
promptActions
(
)
{
return
[
{
label
:
lazy
.
gBrowserBundle
.
GetStringFromName
(
"
geolocation
.
allow
"
)
accessKey
:
lazy
.
gBrowserBundle
.
GetStringFromName
(
"
geolocation
.
allow
.
accesskey
"
)
action
:
lazy
.
SitePermissions
.
ALLOW
}
{
label
:
lazy
.
gBrowserBundle
.
GetStringFromName
(
"
geolocation
.
block
"
)
accessKey
:
lazy
.
gBrowserBundle
.
GetStringFromName
(
"
geolocation
.
block
.
accesskey
"
)
action
:
lazy
.
SitePermissions
.
BLOCK
}
]
;
}
_updateGeoSharing
(
state
)
{
let
gBrowser
=
this
.
browser
.
ownerGlobal
.
gBrowser
;
if
(
gBrowser
=
=
null
)
{
return
;
}
gBrowser
.
updateBrowserSharing
(
this
.
browser
{
geo
:
state
}
)
;
let
host
;
try
{
host
=
this
.
browser
.
currentURI
.
host
;
}
catch
(
e
)
{
return
;
}
if
(
host
=
=
null
|
|
host
=
=
"
"
)
{
return
;
}
lazy
.
ContentPrefService2
.
set
(
this
.
browser
.
currentURI
.
host
"
permissions
.
geoLocation
.
lastAccess
"
new
Date
(
)
.
toString
(
)
this
.
browser
.
loadContext
)
;
}
allow
(
.
.
.
args
)
{
this
.
_updateGeoSharing
(
true
)
;
PermissionPromptForRequestPrototype
.
allow
.
apply
(
this
args
)
;
}
cancel
(
.
.
.
args
)
{
this
.
_updateGeoSharing
(
false
)
;
PermissionPromptForRequestPrototype
.
cancel
.
apply
(
this
args
)
;
}
}
;
PermissionUI
.
GeolocationPermissionPrompt
=
GeolocationPermissionPrompt
;
function
XRPermissionPrompt
(
request
)
{
this
.
request
=
request
;
}
XRPermissionPrompt
.
prototype
=
{
__proto__
:
PermissionPromptForRequestPrototype
get
type
(
)
{
return
"
xr
"
;
}
get
permissionKey
(
)
{
return
"
xr
"
;
}
get
popupOptions
(
)
{
let
pref
=
"
browser
.
xr
.
warning
.
infoURL
"
;
let
options
=
{
learnMoreURL
:
Services
.
urlFormatter
.
formatURLPref
(
pref
)
displayURI
:
false
name
:
this
.
getPrincipalName
(
)
}
;
if
(
this
.
principal
.
schemeIs
(
"
file
"
)
)
{
options
.
checkbox
=
{
show
:
false
}
;
}
else
{
options
.
checkbox
=
{
show
:
!
lazy
.
PrivateBrowsingUtils
.
isWindowPrivate
(
this
.
browser
.
ownerGlobal
)
}
;
}
if
(
options
.
checkbox
.
show
)
{
options
.
checkbox
.
label
=
lazy
.
gBrowserBundle
.
GetStringFromName
(
"
xr
.
remember
"
)
;
}
return
options
;
}
get
notificationID
(
)
{
return
"
xr
"
;
}
get
anchorID
(
)
{
return
"
xr
-
notification
-
icon
"
;
}
get
message
(
)
{
if
(
this
.
principal
.
schemeIs
(
"
file
"
)
)
{
return
lazy
.
gBrowserBundle
.
GetStringFromName
(
"
xr
.
shareWithFile4
"
)
;
}
return
lazy
.
gBrowserBundle
.
formatStringFromName
(
"
xr
.
shareWithSite4
"
[
"
<
>
"
]
)
;
}
get
promptActions
(
)
{
return
[
{
label
:
lazy
.
gBrowserBundle
.
GetStringFromName
(
"
xr
.
allow2
"
)
accessKey
:
lazy
.
gBrowserBundle
.
GetStringFromName
(
"
xr
.
allow2
.
accesskey
"
)
action
:
lazy
.
SitePermissions
.
ALLOW
}
{
label
:
lazy
.
gBrowserBundle
.
GetStringFromName
(
"
xr
.
block
"
)
accessKey
:
lazy
.
gBrowserBundle
.
GetStringFromName
(
"
xr
.
block
.
accesskey
"
)
action
:
lazy
.
SitePermissions
.
BLOCK
}
]
;
}
_updateXRSharing
(
state
)
{
let
gBrowser
=
this
.
browser
.
ownerGlobal
.
gBrowser
;
if
(
gBrowser
=
=
null
)
{
return
;
}
gBrowser
.
updateBrowserSharing
(
this
.
browser
{
xr
:
state
}
)
;
let
devicePermOrigins
=
this
.
browser
.
getDevicePermissionOrigins
(
"
xr
"
)
;
if
(
!
state
)
{
devicePermOrigins
.
delete
(
this
.
principal
.
origin
)
;
return
;
}
devicePermOrigins
.
add
(
this
.
principal
.
origin
)
;
}
allow
(
.
.
.
args
)
{
this
.
_updateXRSharing
(
true
)
;
PermissionPromptForRequestPrototype
.
allow
.
apply
(
this
args
)
;
}
cancel
(
.
.
.
args
)
{
this
.
_updateXRSharing
(
false
)
;
PermissionPromptForRequestPrototype
.
cancel
.
apply
(
this
args
)
;
}
}
;
PermissionUI
.
XRPermissionPrompt
=
XRPermissionPrompt
;
function
DesktopNotificationPermissionPrompt
(
request
)
{
this
.
request
=
request
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
requiresUserInput
"
"
dom
.
webnotifications
.
requireuserinteraction
"
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
postPromptEnabled
"
"
permissions
.
desktop
-
notification
.
postPrompt
.
enabled
"
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
notNowEnabled
"
"
permissions
.
desktop
-
notification
.
notNow
.
enabled
"
)
;
}
DesktopNotificationPermissionPrompt
.
prototype
=
{
__proto__
:
PermissionPromptForRequestPrototype
get
type
(
)
{
return
"
desktop
-
notification
"
;
}
get
permissionKey
(
)
{
return
"
desktop
-
notification
"
;
}
get
popupOptions
(
)
{
let
learnMoreURL
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
+
"
push
"
;
return
{
learnMoreURL
displayURI
:
false
name
:
this
.
getPrincipalName
(
)
}
;
}
get
notificationID
(
)
{
return
"
web
-
notifications
"
;
}
get
anchorID
(
)
{
return
"
web
-
notifications
-
notification
-
icon
"
;
}
get
message
(
)
{
return
lazy
.
gBrowserBundle
.
formatStringFromName
(
"
webNotifications
.
receiveFromSite3
"
[
"
<
>
"
]
)
;
}
get
promptActions
(
)
{
let
actions
=
[
{
label
:
lazy
.
gBrowserBundle
.
GetStringFromName
(
"
webNotifications
.
allow2
"
)
accessKey
:
lazy
.
gBrowserBundle
.
GetStringFromName
(
"
webNotifications
.
allow2
.
accesskey
"
)
action
:
lazy
.
SitePermissions
.
ALLOW
scope
:
lazy
.
SitePermissions
.
SCOPE_PERSISTENT
}
]
;
if
(
this
.
notNowEnabled
)
{
actions
.
push
(
{
label
:
lazy
.
gBrowserBundle
.
GetStringFromName
(
"
webNotifications
.
notNow
"
)
accessKey
:
lazy
.
gBrowserBundle
.
GetStringFromName
(
"
webNotifications
.
notNow
.
accesskey
"
)
action
:
lazy
.
SitePermissions
.
BLOCK
}
)
;
}
let
isBrowserPrivate
=
lazy
.
PrivateBrowsingUtils
.
isBrowserPrivate
(
this
.
browser
)
;
actions
.
push
(
{
label
:
isBrowserPrivate
?
lazy
.
gBrowserBundle
.
GetStringFromName
(
"
webNotifications
.
block
"
)
:
lazy
.
gBrowserBundle
.
GetStringFromName
(
"
webNotifications
.
alwaysBlock
"
)
accessKey
:
isBrowserPrivate
?
lazy
.
gBrowserBundle
.
GetStringFromName
(
"
webNotifications
.
block
.
accesskey
"
)
:
lazy
.
gBrowserBundle
.
GetStringFromName
(
"
webNotifications
.
alwaysBlock
.
accesskey
"
)
action
:
lazy
.
SitePermissions
.
BLOCK
scope
:
isBrowserPrivate
?
lazy
.
SitePermissions
.
SCOPE_SESSION
:
lazy
.
SitePermissions
.
SCOPE_PERSISTENT
}
)
;
return
actions
;
}
get
postPromptActions
(
)
{
let
actions
=
[
{
label
:
lazy
.
gBrowserBundle
.
GetStringFromName
(
"
webNotifications
.
allow2
"
)
accessKey
:
lazy
.
gBrowserBundle
.
GetStringFromName
(
"
webNotifications
.
allow2
.
accesskey
"
)
action
:
lazy
.
SitePermissions
.
ALLOW
}
]
;
let
isBrowserPrivate
=
lazy
.
PrivateBrowsingUtils
.
isBrowserPrivate
(
this
.
browser
)
;
actions
.
push
(
{
label
:
isBrowserPrivate
?
lazy
.
gBrowserBundle
.
GetStringFromName
(
"
webNotifications
.
block
"
)
:
lazy
.
gBrowserBundle
.
GetStringFromName
(
"
webNotifications
.
alwaysBlock
"
)
accessKey
:
isBrowserPrivate
?
lazy
.
gBrowserBundle
.
GetStringFromName
(
"
webNotifications
.
block
.
accesskey
"
)
:
lazy
.
gBrowserBundle
.
GetStringFromName
(
"
webNotifications
.
alwaysBlock
.
accesskey
"
)
action
:
lazy
.
SitePermissions
.
BLOCK
}
)
;
return
actions
;
}
}
;
PermissionUI
.
DesktopNotificationPermissionPrompt
=
DesktopNotificationPermissionPrompt
;
function
PersistentStoragePermissionPrompt
(
request
)
{
this
.
request
=
request
;
}
PersistentStoragePermissionPrompt
.
prototype
=
{
__proto__
:
PermissionPromptForRequestPrototype
get
type
(
)
{
return
"
persistent
-
storage
"
;
}
get
permissionKey
(
)
{
return
"
persistent
-
storage
"
;
}
get
popupOptions
(
)
{
let
learnMoreURL
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
+
"
storage
-
permissions
"
;
return
{
learnMoreURL
displayURI
:
false
name
:
this
.
getPrincipalName
(
)
}
;
}
get
notificationID
(
)
{
return
"
persistent
-
storage
"
;
}
get
anchorID
(
)
{
return
"
persistent
-
storage
-
notification
-
icon
"
;
}
get
message
(
)
{
return
lazy
.
gBrowserBundle
.
formatStringFromName
(
"
persistentStorage
.
allowWithSite2
"
[
"
<
>
"
]
)
;
}
get
promptActions
(
)
{
return
[
{
label
:
lazy
.
gBrowserBundle
.
GetStringFromName
(
"
persistentStorage
.
allow
"
)
accessKey
:
lazy
.
gBrowserBundle
.
GetStringFromName
(
"
persistentStorage
.
allow
.
accesskey
"
)
action
:
Ci
.
nsIPermissionManager
.
ALLOW_ACTION
scope
:
lazy
.
SitePermissions
.
SCOPE_PERSISTENT
}
{
label
:
lazy
.
gBrowserBundle
.
GetStringFromName
(
"
persistentStorage
.
block
.
label
"
)
accessKey
:
lazy
.
gBrowserBundle
.
GetStringFromName
(
"
persistentStorage
.
block
.
accesskey
"
)
action
:
lazy
.
SitePermissions
.
BLOCK
}
]
;
}
}
;
PermissionUI
.
PersistentStoragePermissionPrompt
=
PersistentStoragePermissionPrompt
;
function
MIDIPermissionPrompt
(
request
)
{
this
.
request
=
request
;
let
types
=
request
.
types
.
QueryInterface
(
Ci
.
nsIArray
)
;
let
perm
=
types
.
queryElementAt
(
0
Ci
.
nsIContentPermissionType
)
;
this
.
isSysexPerm
=
!
!
perm
.
options
.
length
&
&
perm
.
options
.
queryElementAt
(
0
Ci
.
nsISupportsString
)
=
=
"
sysex
"
;
this
.
permName
=
"
midi
"
;
if
(
this
.
isSysexPerm
)
{
this
.
permName
=
"
midi
-
sysex
"
;
}
}
MIDIPermissionPrompt
.
prototype
=
{
__proto__
:
PermissionPromptForRequestPrototype
get
type
(
)
{
return
"
midi
"
;
}
get
permissionKey
(
)
{
return
this
.
permName
;
}
get
popupOptions
(
)
{
let
options
=
{
displayURI
:
false
name
:
this
.
getPrincipalName
(
)
}
;
if
(
this
.
principal
.
schemeIs
(
"
file
"
)
)
{
options
.
checkbox
=
{
show
:
false
}
;
}
else
{
options
.
checkbox
=
{
show
:
!
lazy
.
PrivateBrowsingUtils
.
isWindowPrivate
(
this
.
browser
.
ownerGlobal
)
}
;
}
if
(
options
.
checkbox
.
show
)
{
options
.
checkbox
.
label
=
lazy
.
gBrowserBundle
.
GetStringFromName
(
"
midi
.
remember
"
)
;
}
return
options
;
}
get
notificationID
(
)
{
return
"
midi
"
;
}
get
anchorID
(
)
{
return
"
midi
-
notification
-
icon
"
;
}
get
message
(
)
{
let
message
;
if
(
this
.
principal
.
schemeIs
(
"
file
"
)
)
{
if
(
this
.
isSysexPerm
)
{
message
=
lazy
.
gBrowserBundle
.
GetStringFromName
(
"
midi
.
shareSysexWithFile
"
)
;
}
else
{
message
=
lazy
.
gBrowserBundle
.
GetStringFromName
(
"
midi
.
shareWithFile
"
)
;
}
}
else
if
(
this
.
isSysexPerm
)
{
message
=
lazy
.
gBrowserBundle
.
formatStringFromName
(
"
midi
.
shareSysexWithSite
"
[
"
<
>
"
]
)
;
}
else
{
message
=
lazy
.
gBrowserBundle
.
formatStringFromName
(
"
midi
.
shareWithSite
"
[
"
<
>
"
]
)
;
}
return
message
;
}
get
promptActions
(
)
{
return
[
{
label
:
lazy
.
gBrowserBundle
.
GetStringFromName
(
"
midi
.
allow
.
label
"
)
accessKey
:
lazy
.
gBrowserBundle
.
GetStringFromName
(
"
midi
.
allow
.
accesskey
"
)
action
:
Ci
.
nsIPermissionManager
.
ALLOW_ACTION
}
{
label
:
lazy
.
gBrowserBundle
.
GetStringFromName
(
"
midi
.
block
.
label
"
)
accessKey
:
lazy
.
gBrowserBundle
.
GetStringFromName
(
"
midi
.
block
.
accesskey
"
)
action
:
Ci
.
nsIPermissionManager
.
DENY_ACTION
}
]
;
}
}
;
PermissionUI
.
MIDIPermissionPrompt
=
MIDIPermissionPrompt
;
function
StorageAccessPermissionPrompt
(
request
)
{
this
.
request
=
request
;
}
StorageAccessPermissionPrompt
.
prototype
=
{
__proto__
:
PermissionPromptForRequestPrototype
get
usePermissionManager
(
)
{
return
false
;
}
get
type
(
)
{
return
"
storage
-
access
"
;
}
get
permissionKey
(
)
{
return
3rdPartyStorage
{
lazy
.
SitePermissions
.
PERM_KEY_DELIMITER
}
{
this
.
principal
.
origin
}
;
}
prettifyHostPort
(
hostport
)
{
let
[
host
port
]
=
hostport
.
split
(
"
:
"
)
;
host
=
lazy
.
IDNService
.
convertToDisplayIDN
(
host
{
}
)
;
if
(
port
)
{
return
{
host
}
:
{
port
}
;
}
return
host
;
}
get
popupOptions
(
)
{
let
learnMoreURL
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
+
"
third
-
party
-
cookies
"
;
let
hostPort
=
this
.
prettifyHostPort
(
this
.
principal
.
hostPort
)
;
let
hintText
=
lazy
.
gBrowserBundle
.
formatStringFromName
(
"
storageAccess1
.
hintText
"
[
hostPort
]
)
;
return
{
learnMoreURL
displayURI
:
false
hintText
escAction
:
"
secondarybuttoncommand
"
}
;
}
get
notificationID
(
)
{
return
"
storage
-
access
"
;
}
get
anchorID
(
)
{
return
"
storage
-
access
-
notification
-
icon
"
;
}
get
message
(
)
{
return
lazy
.
gBrowserBundle
.
formatStringFromName
(
"
storageAccess4
.
message
"
[
this
.
prettifyHostPort
(
this
.
principal
.
hostPort
)
this
.
prettifyHostPort
(
this
.
topLevelPrincipal
.
hostPort
)
]
)
;
}
get
promptActions
(
)
{
let
self
=
this
;
return
[
{
label
:
lazy
.
gBrowserBundle
.
GetStringFromName
(
"
storageAccess1
.
Allow
.
label
"
)
accessKey
:
lazy
.
gBrowserBundle
.
GetStringFromName
(
"
storageAccess1
.
Allow
.
accesskey
"
)
action
:
Ci
.
nsIPermissionManager
.
ALLOW_ACTION
callback
(
state
)
{
self
.
allow
(
{
"
storage
-
access
"
:
"
allow
"
}
)
;
}
}
{
label
:
lazy
.
gBrowserBundle
.
GetStringFromName
(
"
storageAccess1
.
DontAllow
.
label
"
)
accessKey
:
lazy
.
gBrowserBundle
.
GetStringFromName
(
"
storageAccess1
.
DontAllow
.
accesskey
"
)
action
:
Ci
.
nsIPermissionManager
.
DENY_ACTION
callback
(
state
)
{
self
.
cancel
(
)
;
}
}
]
;
}
get
topLevelPrincipal
(
)
{
return
this
.
request
.
topLevelPrincipal
;
}
}
;
PermissionUI
.
StorageAccessPermissionPrompt
=
StorageAccessPermissionPrompt
;
