"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
PermissionUI
"
]
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Services
"
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
SitePermissions
"
"
resource
:
/
/
/
modules
/
SitePermissions
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PrivateBrowsingUtils
"
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gBrandBundle
"
function
(
)
{
return
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
branding
/
locale
/
brand
.
properties
"
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gBrowserBundle
"
function
(
)
{
return
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
browser
/
locale
/
browser
.
properties
"
)
;
}
)
;
this
.
PermissionUI
=
{
}
;
this
.
PermissionPromptPrototype
=
{
get
browser
(
)
{
throw
new
Error
(
"
Not
implemented
.
"
)
;
}
get
principal
(
)
{
throw
new
Error
(
"
Not
implemented
.
"
)
;
}
get
permissionKey
(
)
{
return
undefined
;
}
get
popupOptions
(
)
{
return
{
}
;
}
get
notificationID
(
)
{
throw
new
Error
(
"
Not
implemented
.
"
)
;
}
get
anchorID
(
)
{
return
"
default
-
notification
-
icon
"
;
}
get
message
(
)
{
throw
new
Error
(
"
Not
implemented
.
"
)
;
}
cancel
(
)
{
throw
new
Error
(
"
Not
implemented
.
"
)
}
allow
(
)
{
throw
new
Error
(
"
Not
implemented
.
"
)
;
}
get
promptActions
(
)
{
return
[
]
;
}
onBeforeShow
(
)
{
}
prompt
(
)
{
let
requestingURI
=
this
.
principal
.
URI
;
if
(
!
(
requestingURI
instanceof
Ci
.
nsIStandardURL
)
)
{
return
;
}
if
(
this
.
permissionKey
)
{
let
{
state
}
=
SitePermissions
.
get
(
requestingURI
this
.
permissionKey
this
.
browser
)
;
if
(
state
=
=
SitePermissions
.
BLOCK
)
{
this
.
cancel
(
)
;
return
;
}
if
(
state
=
=
SitePermissions
.
ALLOW
)
{
this
.
allow
(
)
;
return
;
}
this
.
browser
.
dispatchEvent
(
new
this
.
browser
.
ownerGlobal
.
CustomEvent
(
"
PermissionStateChange
"
)
)
;
}
let
chromeWin
=
this
.
browser
.
ownerGlobal
;
if
(
!
chromeWin
.
PopupNotifications
)
{
this
.
cancel
(
)
;
return
;
}
let
popupNotificationActions
=
[
]
;
for
(
let
promptAction
of
this
.
promptActions
)
{
let
action
=
{
label
:
promptAction
.
label
accessKey
:
promptAction
.
accessKey
callback
:
state
=
>
{
if
(
promptAction
.
callback
)
{
promptAction
.
callback
(
)
;
}
if
(
this
.
permissionKey
)
{
if
(
state
&
&
state
.
checkboxChecked
)
{
let
scope
=
SitePermissions
.
SCOPE_PERSISTENT
;
if
(
PrivateBrowsingUtils
.
isBrowserPrivate
(
this
.
browser
)
)
{
scope
=
SitePermissions
.
SCOPE_SESSION
;
}
SitePermissions
.
set
(
this
.
principal
.
URI
this
.
permissionKey
promptAction
.
action
scope
)
;
}
else
if
(
promptAction
.
action
=
=
SitePermissions
.
BLOCK
)
{
SitePermissions
.
set
(
this
.
principal
.
URI
this
.
permissionKey
promptAction
.
action
SitePermissions
.
SCOPE_TEMPORARY
this
.
browser
)
;
}
if
(
promptAction
.
action
=
=
SitePermissions
.
ALLOW
)
{
this
.
allow
(
)
;
}
else
{
this
.
cancel
(
)
;
}
}
}
}
;
if
(
promptAction
.
dismiss
)
{
action
.
dismiss
=
promptAction
.
dismiss
}
popupNotificationActions
.
push
(
action
)
;
}
let
mainAction
=
popupNotificationActions
.
length
?
popupNotificationActions
[
0
]
:
null
;
let
secondaryActions
=
popupNotificationActions
.
splice
(
1
)
;
let
options
=
this
.
popupOptions
;
if
(
!
options
.
hasOwnProperty
(
"
displayURI
"
)
|
|
options
.
displayURI
)
{
options
.
displayURI
=
this
.
principal
.
URI
;
}
options
.
persistent
=
true
;
options
.
hideClose
=
!
Services
.
prefs
.
getBoolPref
(
"
privacy
.
permissionPrompts
.
showCloseButton
"
)
;
this
.
onBeforeShow
(
)
;
chromeWin
.
PopupNotifications
.
show
(
this
.
browser
this
.
notificationID
this
.
message
this
.
anchorID
mainAction
secondaryActions
options
)
;
}
}
;
PermissionUI
.
PermissionPromptPrototype
=
PermissionPromptPrototype
;
this
.
PermissionPromptForRequestPrototype
=
{
__proto__
:
PermissionPromptPrototype
get
browser
(
)
{
if
(
this
.
request
.
element
)
{
return
this
.
request
.
element
;
}
return
this
.
request
.
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebNavigation
)
.
QueryInterface
(
Ci
.
nsIDocShell
)
.
chromeEventHandler
;
}
get
principal
(
)
{
return
this
.
request
.
principal
;
}
cancel
(
)
{
this
.
request
.
cancel
(
)
;
}
allow
(
)
{
this
.
request
.
allow
(
)
;
}
}
;
PermissionUI
.
PermissionPromptForRequestPrototype
=
PermissionPromptForRequestPrototype
;
function
GeolocationPermissionPrompt
(
request
)
{
this
.
request
=
request
;
}
GeolocationPermissionPrompt
.
prototype
=
{
__proto__
:
PermissionPromptForRequestPrototype
get
permissionKey
(
)
{
return
"
geo
"
;
}
get
popupOptions
(
)
{
let
pref
=
"
browser
.
geolocation
.
warning
.
infoURL
"
;
let
options
=
{
learnMoreURL
:
Services
.
urlFormatter
.
formatURLPref
(
pref
)
displayURI
:
false
}
;
if
(
this
.
principal
.
URI
.
schemeIs
(
"
file
"
)
)
{
options
.
checkbox
=
{
show
:
false
}
;
}
else
{
options
.
checkbox
=
{
show
:
!
PrivateBrowsingUtils
.
isWindowPrivate
(
this
.
browser
.
ownerGlobal
)
}
;
}
if
(
options
.
checkbox
.
show
)
{
options
.
checkbox
.
label
=
gBrowserBundle
.
GetStringFromName
(
"
geolocation
.
remember
"
)
;
}
return
options
;
}
get
notificationID
(
)
{
return
"
geolocation
"
;
}
get
anchorID
(
)
{
return
"
geo
-
notification
-
icon
"
;
}
get
message
(
)
{
let
message
;
if
(
this
.
principal
.
URI
.
schemeIs
(
"
file
"
)
)
{
message
=
gBrowserBundle
.
GetStringFromName
(
"
geolocation
.
shareWithFile3
"
)
;
}
else
{
let
hostPort
=
"
<
>
"
;
try
{
hostPort
=
this
.
principal
.
URI
.
hostPort
;
}
catch
(
ex
)
{
}
message
=
gBrowserBundle
.
formatStringFromName
(
"
geolocation
.
shareWithSite3
"
[
hostPort
]
1
)
;
}
return
message
;
}
get
promptActions
(
)
{
const
SHARE_LOCATION
=
Ci
.
nsISecurityUITelemetry
.
WARNING_GEOLOCATION_REQUEST_SHARE_LOCATION
;
const
ALWAYS_SHARE
=
Ci
.
nsISecurityUITelemetry
.
WARNING_GEOLOCATION_REQUEST_ALWAYS_SHARE
;
const
NEVER_SHARE
=
Ci
.
nsISecurityUITelemetry
.
WARNING_GEOLOCATION_REQUEST_NEVER_SHARE
;
let
secHistogram
=
Services
.
telemetry
.
getHistogramById
(
"
SECURITY_UI
"
)
;
return
[
{
label
:
gBrowserBundle
.
GetStringFromName
(
"
geolocation
.
allowLocation
"
)
accessKey
:
gBrowserBundle
.
GetStringFromName
(
"
geolocation
.
allowLocation
.
accesskey
"
)
action
:
SitePermissions
.
ALLOW
callback
(
state
)
{
if
(
state
&
&
state
.
checkboxChecked
)
{
secHistogram
.
add
(
ALWAYS_SHARE
)
;
}
else
{
secHistogram
.
add
(
SHARE_LOCATION
)
;
}
}
}
{
label
:
gBrowserBundle
.
GetStringFromName
(
"
geolocation
.
dontAllowLocation
"
)
accessKey
:
gBrowserBundle
.
GetStringFromName
(
"
geolocation
.
dontAllowLocation
.
accesskey
"
)
action
:
SitePermissions
.
BLOCK
callback
(
state
)
{
if
(
state
&
&
state
.
checkboxChecked
)
{
secHistogram
.
add
(
NEVER_SHARE
)
;
}
}
}
]
;
}
onBeforeShow
(
)
{
let
secHistogram
=
Services
.
telemetry
.
getHistogramById
(
"
SECURITY_UI
"
)
;
const
SHOW_REQUEST
=
Ci
.
nsISecurityUITelemetry
.
WARNING_GEOLOCATION_REQUEST
;
secHistogram
.
add
(
SHOW_REQUEST
)
;
}
}
;
PermissionUI
.
GeolocationPermissionPrompt
=
GeolocationPermissionPrompt
;
function
DesktopNotificationPermissionPrompt
(
request
)
{
this
.
request
=
request
;
}
DesktopNotificationPermissionPrompt
.
prototype
=
{
__proto__
:
PermissionPromptForRequestPrototype
get
permissionKey
(
)
{
return
"
desktop
-
notification
"
;
}
get
popupOptions
(
)
{
let
learnMoreURL
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
+
"
push
"
;
let
checkbox
=
{
show
:
true
checked
:
true
label
:
gBrowserBundle
.
GetStringFromName
(
"
webNotifications
.
remember
"
)
}
;
if
(
PrivateBrowsingUtils
.
isWindowPrivate
(
this
.
browser
.
ownerGlobal
)
)
{
checkbox
.
label
=
gBrowserBundle
.
GetStringFromName
(
"
webNotifications
.
rememberForSession
"
)
;
}
return
{
learnMoreURL
checkbox
displayURI
:
false
}
;
}
get
notificationID
(
)
{
return
"
web
-
notifications
"
;
}
get
anchorID
(
)
{
return
"
web
-
notifications
-
notification
-
icon
"
;
}
get
message
(
)
{
let
hostPort
=
"
<
>
"
;
try
{
hostPort
=
this
.
principal
.
URI
.
hostPort
;
}
catch
(
ex
)
{
}
return
gBrowserBundle
.
formatStringFromName
(
"
webNotifications
.
receiveFromSite2
"
[
hostPort
]
1
)
;
}
get
promptActions
(
)
{
return
[
{
label
:
gBrowserBundle
.
GetStringFromName
(
"
webNotifications
.
allow
"
)
accessKey
:
gBrowserBundle
.
GetStringFromName
(
"
webNotifications
.
allow
.
accesskey
"
)
action
:
SitePermissions
.
ALLOW
}
{
label
:
gBrowserBundle
.
GetStringFromName
(
"
webNotifications
.
dontAllow
"
)
accessKey
:
gBrowserBundle
.
GetStringFromName
(
"
webNotifications
.
dontAllow
.
accesskey
"
)
action
:
SitePermissions
.
BLOCK
}
]
;
}
}
;
PermissionUI
.
DesktopNotificationPermissionPrompt
=
DesktopNotificationPermissionPrompt
;
