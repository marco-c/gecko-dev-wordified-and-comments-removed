"
use
strict
"
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
this
.
EXPORTED_SYMBOLS
=
[
"
LaterRun
"
]
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
setInterval
"
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
clearInterval
"
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
RecentWindow
"
"
resource
:
/
/
gre
/
modules
/
RecentWindow
.
jsm
"
)
;
const
kEnabledPref
=
"
browser
.
laterrun
.
enabled
"
;
const
kPagePrefRoot
=
"
browser
.
laterrun
.
pages
.
"
;
const
kSessionCountPref
=
"
browser
.
laterrun
.
bookkeeping
.
sessionCount
"
;
const
kProfileCreationTime
=
"
browser
.
laterrun
.
bookkeeping
.
profileCreationTime
"
;
const
kSelfDestructSessionLimit
=
50
;
const
kSelfDestructHoursLimit
=
31
*
24
;
class
Page
{
constructor
(
{
pref
minimumHoursSinceInstall
minimumSessionCount
requireBoth
url
}
)
{
this
.
pref
=
pref
;
this
.
minimumHoursSinceInstall
=
minimumHoursSinceInstall
|
|
0
;
this
.
minimumSessionCount
=
minimumSessionCount
|
|
1
;
this
.
requireBoth
=
requireBoth
|
|
false
;
this
.
url
=
url
;
}
get
hasRun
(
)
{
return
Preferences
.
get
(
this
.
pref
+
"
hasRun
"
false
)
;
}
applies
(
sessionInfo
)
{
if
(
this
.
hasRun
)
{
return
false
;
}
if
(
this
.
requireBoth
)
{
return
sessionInfo
.
sessionCount
>
=
this
.
minimumSessionCount
&
&
sessionInfo
.
hoursSinceInstall
>
=
this
.
minimumHoursSinceInstall
;
}
return
sessionInfo
.
sessionCount
>
=
this
.
minimumSessionCount
|
|
sessionInfo
.
hoursSinceInstall
>
=
this
.
minimumHoursSinceInstall
;
}
}
let
LaterRun
=
{
init
(
)
{
if
(
!
this
.
enabled
)
{
return
;
}
if
(
!
Preferences
.
has
(
kProfileCreationTime
)
)
{
Preferences
.
set
(
kProfileCreationTime
Math
.
floor
(
Date
.
now
(
)
/
1000
)
)
;
}
this
.
sessionCount
+
+
;
if
(
this
.
hoursSinceInstall
>
kSelfDestructHoursLimit
|
|
this
.
sessionCount
>
kSelfDestructSessionLimit
)
{
this
.
selfDestruct
(
)
;
return
;
}
}
get
enabled
(
)
{
return
Preferences
.
get
(
kEnabledPref
false
)
;
}
set
enabled
(
val
)
{
let
wasEnabled
=
this
.
enabled
;
Preferences
.
set
(
kEnabledPref
val
)
;
if
(
val
&
&
!
wasEnabled
)
{
this
.
init
(
)
;
}
}
get
hoursSinceInstall
(
)
{
let
installStamp
=
Preferences
.
get
(
kProfileCreationTime
Date
.
now
(
)
/
1000
)
;
return
Math
.
floor
(
(
Date
.
now
(
)
/
1000
-
installStamp
)
/
3600
)
;
}
get
sessionCount
(
)
{
if
(
this
.
_sessionCount
)
{
return
this
.
_sessionCount
;
}
return
this
.
_sessionCount
=
Preferences
.
get
(
kSessionCountPref
0
)
;
}
set
sessionCount
(
val
)
{
this
.
_sessionCount
=
val
;
Preferences
.
set
(
kSessionCountPref
val
)
;
}
selfDestruct
(
)
{
Preferences
.
set
(
kEnabledPref
false
)
;
}
readPages
(
)
{
let
allPrefsForPages
=
Services
.
prefs
.
getChildList
(
kPagePrefRoot
)
;
let
pageDataStore
=
new
Map
(
)
;
for
(
let
pref
of
allPrefsForPages
)
{
let
[
slug
prop
]
=
pref
.
substring
(
kPagePrefRoot
.
length
)
.
split
(
"
.
"
)
;
if
(
!
pageDataStore
.
has
(
slug
)
)
{
pageDataStore
.
set
(
slug
{
pref
:
pref
.
substring
(
0
pref
.
length
-
prop
.
length
)
}
)
;
}
let
defaultPrefValue
=
0
;
if
(
prop
=
=
"
requireBoth
"
|
|
prop
=
=
"
hasRun
"
)
{
defaultPrefValue
=
false
;
}
else
if
(
prop
=
=
"
url
"
)
{
defaultPrefValue
=
"
"
;
}
pageDataStore
.
get
(
slug
)
[
prop
]
=
Preferences
.
get
(
pref
defaultPrefValue
)
;
}
let
rv
=
[
]
;
for
(
let
[
pageData
]
of
pageDataStore
)
{
if
(
pageData
.
url
)
{
let
uri
=
null
;
try
{
uri
=
Services
.
io
.
newURI
(
pageData
.
url
.
trim
(
)
null
null
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
"
Invalid
LaterRun
page
URL
"
+
pageData
.
url
+
"
ignored
.
"
)
;
}
if
(
!
uri
.
schemeIs
(
"
https
"
)
)
{
Cu
.
reportError
(
"
Insecure
LaterRun
page
URL
"
+
uri
.
spec
+
"
ignored
.
"
)
;
}
else
{
pageData
.
url
=
uri
.
spec
;
rv
.
push
(
new
Page
(
pageData
)
)
;
}
}
}
return
rv
;
}
getURL
(
)
{
if
(
!
this
.
enabled
)
{
return
null
;
}
let
pages
=
this
.
readPages
(
)
;
let
page
=
pages
.
find
(
page
=
>
page
.
applies
(
this
)
)
;
if
(
page
)
{
Services
.
prefs
.
setBoolPref
(
page
.
pref
+
"
hasRun
"
true
)
;
return
page
.
url
;
}
return
null
;
}
}
;
LaterRun
.
init
(
)
;
