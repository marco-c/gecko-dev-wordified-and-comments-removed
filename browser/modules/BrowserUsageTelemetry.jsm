"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
BrowserUsageTelemetry
"
]
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
WINDOWS_RESTORED_TOPIC
=
"
sessionstore
-
windows
-
restored
"
;
const
TELEMETRY_SUBSESSIONSPLIT_TOPIC
=
"
internal
-
telemetry
-
after
-
subsession
-
split
"
;
const
DOMWINDOW_OPENED_TOPIC
=
"
domwindowopened
"
;
const
DOMWINDOW_CLOSED_TOPIC
=
"
domwindowclosed
"
;
const
MAX_TAB_COUNT_SCALAR_NAME
=
"
browser
.
engagement
.
max_concurrent_tab_count
"
;
const
MAX_WINDOW_COUNT_SCALAR_NAME
=
"
browser
.
engagement
.
max_concurrent_window_count
"
;
const
TAB_OPEN_EVENT_COUNT_SCALAR_NAME
=
"
browser
.
engagement
.
tab_open_event_count
"
;
const
WINDOW_OPEN_EVENT_COUNT_SCALAR_NAME
=
"
browser
.
engagement
.
window_open_event_count
"
;
function
getOpenTabsAndWinsCounts
(
)
{
let
tabCount
=
0
;
let
winCount
=
0
;
let
browserEnum
=
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
;
while
(
browserEnum
.
hasMoreElements
(
)
)
{
let
win
=
browserEnum
.
getNext
(
)
;
winCount
+
+
;
tabCount
+
=
win
.
gBrowser
.
tabs
.
length
;
}
return
{
tabCount
winCount
}
;
}
let
BrowserUsageTelemetry
=
{
init
(
)
{
Services
.
obs
.
addObserver
(
this
WINDOWS_RESTORED_TOPIC
false
)
;
}
afterSubsessionSplit
(
)
{
const
counts
=
getOpenTabsAndWinsCounts
(
)
;
Services
.
telemetry
.
scalarSetMaximum
(
MAX_TAB_COUNT_SCALAR_NAME
counts
.
tabCount
)
;
Services
.
telemetry
.
scalarSetMaximum
(
MAX_WINDOW_COUNT_SCALAR_NAME
counts
.
winCount
)
;
}
uninit
(
)
{
Services
.
obs
.
removeObserver
(
this
DOMWINDOW_OPENED_TOPIC
false
)
;
Services
.
obs
.
removeObserver
(
this
DOMWINDOW_CLOSED_TOPIC
false
)
;
Services
.
obs
.
removeObserver
(
this
TELEMETRY_SUBSESSIONSPLIT_TOPIC
false
)
;
Services
.
obs
.
removeObserver
(
this
WINDOWS_RESTORED_TOPIC
false
)
;
}
observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
WINDOWS_RESTORED_TOPIC
:
this
.
_setupAfterRestore
(
)
;
break
;
case
DOMWINDOW_OPENED_TOPIC
:
this
.
_onWindowOpen
(
subject
)
;
break
;
case
DOMWINDOW_CLOSED_TOPIC
:
this
.
_unregisterWindow
(
subject
)
;
break
;
case
TELEMETRY_SUBSESSIONSPLIT_TOPIC
:
this
.
afterSubsessionSplit
(
)
;
break
;
}
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
TabOpen
"
:
this
.
_onTabOpen
(
)
;
break
;
}
}
_setupAfterRestore
(
)
{
Services
.
obs
.
addObserver
(
this
DOMWINDOW_OPENED_TOPIC
false
)
;
Services
.
obs
.
addObserver
(
this
DOMWINDOW_CLOSED_TOPIC
false
)
;
Services
.
obs
.
addObserver
(
this
TELEMETRY_SUBSESSIONSPLIT_TOPIC
false
)
;
let
browserEnum
=
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
;
while
(
browserEnum
.
hasMoreElements
(
)
)
{
this
.
_registerWindow
(
browserEnum
.
getNext
(
)
)
;
}
const
counts
=
getOpenTabsAndWinsCounts
(
)
;
Services
.
telemetry
.
scalarSetMaximum
(
MAX_TAB_COUNT_SCALAR_NAME
counts
.
tabCount
)
;
Services
.
telemetry
.
scalarSetMaximum
(
MAX_WINDOW_COUNT_SCALAR_NAME
counts
.
winCount
)
;
}
_registerWindow
(
win
)
{
win
.
addEventListener
(
"
TabOpen
"
this
true
)
;
}
_unregisterWindow
(
win
)
{
if
(
!
(
win
instanceof
Ci
.
nsIDOMWindow
)
|
|
win
.
document
.
documentElement
.
getAttribute
(
"
windowtype
"
)
!
=
"
navigator
:
browser
"
)
{
return
;
}
win
.
removeEventListener
(
"
TabOpen
"
this
true
)
;
}
_onTabOpen
(
tabCount
=
0
)
{
tabCount
=
tabCount
|
|
getOpenTabsAndWinsCounts
(
)
.
tabCount
;
Services
.
telemetry
.
scalarAdd
(
TAB_OPEN_EVENT_COUNT_SCALAR_NAME
1
)
;
Services
.
telemetry
.
scalarSetMaximum
(
MAX_TAB_COUNT_SCALAR_NAME
tabCount
)
;
}
_onWindowOpen
(
win
)
{
if
(
!
(
win
instanceof
Ci
.
nsIDOMWindow
)
)
{
return
;
}
let
onLoad
=
(
)
=
>
{
win
.
removeEventListener
(
"
load
"
onLoad
false
)
;
if
(
win
.
document
.
documentElement
.
getAttribute
(
"
windowtype
"
)
!
=
"
navigator
:
browser
"
)
{
return
;
}
this
.
_registerWindow
(
win
)
;
const
counts
=
getOpenTabsAndWinsCounts
(
)
;
Services
.
telemetry
.
scalarAdd
(
WINDOW_OPEN_EVENT_COUNT_SCALAR_NAME
1
)
;
Services
.
telemetry
.
scalarSetMaximum
(
MAX_WINDOW_COUNT_SCALAR_NAME
counts
.
winCount
)
;
this
.
_onTabOpen
(
counts
.
tabCount
)
;
}
;
win
.
addEventListener
(
"
load
"
onLoad
false
)
;
}
}
;
