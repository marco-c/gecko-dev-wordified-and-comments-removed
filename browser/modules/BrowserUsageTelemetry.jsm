"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
BrowserUsageTelemetry
"
"
getUniqueDomainsVisitedInPast24Hours
"
"
URICountListener
"
"
MINIMUM_TAB_COUNT_INTERVAL_MS
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AppConstants
:
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
ClientID
:
"
resource
:
/
/
gre
/
modules
/
ClientID
.
jsm
"
BrowserUtils
:
"
resource
:
/
/
gre
/
modules
/
BrowserUtils
.
jsm
"
CustomizableUI
:
"
resource
:
/
/
/
modules
/
CustomizableUI
.
jsm
"
OS
:
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
PageActions
:
"
resource
:
/
/
/
modules
/
PageActions
.
jsm
"
PartnerLinkAttribution
:
"
resource
:
/
/
/
modules
/
PartnerLinkAttribution
.
jsm
"
PrivateBrowsingUtils
:
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
SearchTelemetry
:
"
resource
:
/
/
/
modules
/
SearchTelemetry
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
setTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
clearTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
UrlbarUtils
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
gRecentVisitedOriginsExpiry
"
"
browser
.
engagement
.
recent_visited_origins
.
expiry
"
)
;
const
MAX_UNIQUE_VISITED_DOMAINS
=
100
;
const
TAB_RESTORING_TOPIC
=
"
SSTabRestoring
"
;
const
TELEMETRY_SUBSESSIONSPLIT_TOPIC
=
"
internal
-
telemetry
-
after
-
subsession
-
split
"
;
const
DOMWINDOW_OPENED_TOPIC
=
"
domwindowopened
"
;
const
MAX_TAB_COUNT_SCALAR_NAME
=
"
browser
.
engagement
.
max_concurrent_tab_count
"
;
const
MAX_WINDOW_COUNT_SCALAR_NAME
=
"
browser
.
engagement
.
max_concurrent_window_count
"
;
const
TAB_OPEN_EVENT_COUNT_SCALAR_NAME
=
"
browser
.
engagement
.
tab_open_event_count
"
;
const
MAX_TAB_PINNED_COUNT_SCALAR_NAME
=
"
browser
.
engagement
.
max_concurrent_tab_pinned_count
"
;
const
TAB_PINNED_EVENT_COUNT_SCALAR_NAME
=
"
browser
.
engagement
.
tab_pinned_event_count
"
;
const
WINDOW_OPEN_EVENT_COUNT_SCALAR_NAME
=
"
browser
.
engagement
.
window_open_event_count
"
;
const
UNIQUE_DOMAINS_COUNT_SCALAR_NAME
=
"
browser
.
engagement
.
unique_domains_count
"
;
const
TOTAL_URI_COUNT_SCALAR_NAME
=
"
browser
.
engagement
.
total_uri_count
"
;
const
UNFILTERED_URI_COUNT_SCALAR_NAME
=
"
browser
.
engagement
.
unfiltered_uri_count
"
;
const
KNOWN_SEARCH_SOURCES
=
[
"
abouthome
"
"
contextmenu
"
"
newtab
"
"
searchbar
"
"
system
"
"
urlbar
"
"
urlbar
-
searchmode
"
"
webextension
"
]
;
const
KNOWN_ONEOFF_SOURCES
=
[
"
oneoff
-
urlbar
"
"
oneoff
-
searchbar
"
"
unknown
"
]
;
const
MINIMUM_TAB_COUNT_INTERVAL_MS
=
5
*
60
*
1000
;
const
UI_TARGET_ELEMENTS
=
[
"
menuitem
"
"
toolbarbutton
"
"
key
"
"
command
"
"
checkbox
"
"
input
"
"
button
"
"
image
"
"
radio
"
"
richlistitem
"
]
;
const
BROWSER_UI_CONTAINER_IDS
=
{
"
toolbar
-
menubar
"
:
"
menu
-
bar
"
TabsToolbar
:
"
tabs
-
bar
"
PersonalToolbar
:
"
bookmarks
-
bar
"
"
appMenu
-
popup
"
:
"
app
-
menu
"
tabContextMenu
:
"
tabs
-
context
"
contentAreaContextMenu
:
"
content
-
context
"
"
widget
-
overflow
-
list
"
:
"
overflow
-
menu
"
"
widget
-
overflow
-
fixed
-
list
"
:
"
pinned
-
overflow
-
menu
"
"
page
-
action
-
buttons
"
:
"
pageaction
-
urlbar
"
pageActionPanel
:
"
pageaction
-
panel
"
"
nav
-
bar
"
:
"
nav
-
bar
"
}
;
const
PREFERENCES_PANES
=
[
"
paneHome
"
"
paneGeneral
"
"
panePrivacy
"
"
paneSearch
"
"
paneSearchResults
"
"
paneSync
"
"
paneContainers
"
"
paneExperimental
"
]
;
const
IGNORABLE_EVENTS
=
new
WeakMap
(
)
;
const
KNOWN_ADDONS
=
[
]
;
function
telemetryId
(
widgetId
obscureAddons
=
true
)
{
function
addonId
(
id
)
{
if
(
!
obscureAddons
)
{
return
id
;
}
let
pos
=
KNOWN_ADDONS
.
indexOf
(
id
)
;
if
(
pos
<
0
)
{
pos
=
KNOWN_ADDONS
.
length
;
KNOWN_ADDONS
.
push
(
id
)
;
}
return
addon
{
pos
}
;
}
if
(
widgetId
.
endsWith
(
"
-
browser
-
action
"
)
)
{
widgetId
=
addonId
(
widgetId
.
substring
(
0
widgetId
.
length
-
"
-
browser
-
action
"
.
length
)
)
;
}
else
if
(
widgetId
.
startsWith
(
"
pageAction
-
"
)
)
{
let
actionId
;
if
(
widgetId
.
startsWith
(
"
pageAction
-
urlbar
-
"
)
)
{
actionId
=
widgetId
.
substring
(
"
pageAction
-
urlbar
-
"
.
length
)
;
}
else
if
(
widgetId
.
startsWith
(
"
pageAction
-
panel
-
"
)
)
{
actionId
=
widgetId
.
substring
(
"
pageAction
-
panel
-
"
.
length
)
;
}
if
(
actionId
)
{
let
action
=
PageActions
.
actionForID
(
actionId
)
;
widgetId
=
action
?
.
_isMozillaAction
?
actionId
:
addonId
(
actionId
)
;
}
}
else
if
(
widgetId
.
startsWith
(
"
ext
-
keyset
-
id
-
"
)
)
{
widgetId
=
addonId
(
widgetId
.
substring
(
"
ext
-
keyset
-
id
-
"
.
length
)
)
;
}
else
if
(
widgetId
.
startsWith
(
"
ext
-
key
-
id
-
"
)
)
{
widgetId
=
widgetId
.
substring
(
"
ext
-
key
-
id
-
"
.
length
)
;
if
(
widgetId
.
endsWith
(
"
-
sidebar
-
action
"
)
)
{
widgetId
=
addonId
(
widgetId
.
substring
(
0
widgetId
.
length
-
"
-
sidebar
-
action
"
.
length
)
)
;
}
}
return
widgetId
.
replace
(
/
_
/
g
"
-
"
)
;
}
function
getOpenTabsAndWinsCounts
(
)
{
let
loadedTabCount
=
0
;
let
tabCount
=
0
;
let
winCount
=
0
;
for
(
let
win
of
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
)
{
winCount
+
+
;
tabCount
+
=
win
.
gBrowser
.
tabs
.
length
;
for
(
const
tab
of
win
.
gBrowser
.
tabs
)
{
if
(
tab
.
getAttribute
(
"
pending
"
)
!
=
=
"
true
"
)
{
loadedTabCount
+
=
1
;
}
}
}
return
{
loadedTabCount
tabCount
winCount
}
;
}
function
getPinnedTabsCount
(
)
{
let
pinnedTabs
=
0
;
for
(
let
win
of
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
)
{
pinnedTabs
+
=
[
.
.
.
win
.
ownerGlobal
.
gBrowser
.
tabs
]
.
filter
(
t
=
>
t
.
pinned
)
.
length
;
}
return
pinnedTabs
;
}
function
shouldRecordSearchCount
(
tabbrowser
)
{
return
(
!
PrivateBrowsingUtils
.
isWindowPrivate
(
tabbrowser
.
ownerGlobal
)
|
|
!
Services
.
prefs
.
getBoolPref
(
"
browser
.
engagement
.
search_counts
.
pbm
"
false
)
)
;
}
let
URICountListener
=
{
_domainSet
:
new
Set
(
)
_domain24hrSet
:
new
Set
(
)
_restoredURIsMap
:
new
WeakMap
(
)
_timeouts
:
new
Set
(
)
isHttpURI
(
uri
)
{
return
uri
.
schemeIs
(
"
http
"
)
|
|
uri
.
schemeIs
(
"
https
"
)
;
}
addRestoredURI
(
browser
uri
)
{
if
(
!
this
.
isHttpURI
(
uri
)
)
{
return
;
}
this
.
_restoredURIsMap
.
set
(
browser
uri
.
spec
)
;
}
onStateChange
(
browser
webProgress
request
stateFlags
status
)
{
if
(
!
webProgress
.
isTopLevel
|
|
!
(
stateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_STOP
)
|
|
!
(
stateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_IS_WINDOW
)
)
{
return
;
}
if
(
!
(
request
instanceof
Ci
.
nsIChannel
)
|
|
!
this
.
isHttpURI
(
request
.
URI
)
)
{
return
;
}
BrowserUsageTelemetry
.
_recordSiteOriginsPerLoadedTabs
(
)
;
}
onLocationChange
(
browser
webProgress
request
uri
flags
)
{
if
(
!
(
flags
&
Ci
.
nsIWebProgressListener
.
LOCATION_CHANGE_SAME_DOCUMENT
)
)
{
SearchTelemetry
.
stopTrackingBrowser
(
browser
)
;
}
if
(
flags
&
Ci
.
nsIWebProgressListener
.
LOCATION_CHANGE_ERROR_PAGE
)
{
return
;
}
if
(
!
webProgress
.
isTopLevel
)
{
return
;
}
if
(
!
request
&
&
!
(
flags
&
Ci
.
nsIWebProgressListener
.
LOCATION_CHANGE_SAME_DOCUMENT
)
)
{
return
;
}
let
shouldCountURI
=
!
PrivateBrowsingUtils
.
isWindowPrivate
(
browser
.
ownerGlobal
)
|
|
Services
.
prefs
.
getBoolPref
(
"
browser
.
engagement
.
total_uri_count
.
pbm
"
false
)
;
let
uriSpec
=
null
;
try
{
uriSpec
=
uri
.
spec
;
}
catch
(
e
)
{
if
(
shouldCountURI
)
{
Services
.
telemetry
.
scalarAdd
(
UNFILTERED_URI_COUNT_SCALAR_NAME
1
)
;
}
return
;
}
if
(
browser
.
ownerGlobal
.
gInitialPages
.
includes
(
uriSpec
)
)
{
return
;
}
if
(
this
.
_restoredURIsMap
.
get
(
browser
)
=
=
=
uriSpec
)
{
this
.
_restoredURIsMap
.
delete
(
browser
)
;
return
;
}
if
(
shouldCountURI
)
{
Services
.
telemetry
.
scalarAdd
(
UNFILTERED_URI_COUNT_SCALAR_NAME
1
)
;
}
if
(
!
this
.
isHttpURI
(
uri
)
)
{
return
;
}
if
(
shouldRecordSearchCount
(
browser
.
getTabBrowser
(
)
)
&
&
!
(
flags
&
Ci
.
nsIWebProgressListener
.
LOCATION_CHANGE_SAME_DOCUMENT
)
)
{
SearchTelemetry
.
updateTrackingStatus
(
browser
uriSpec
)
;
}
if
(
!
shouldCountURI
)
{
return
;
}
Services
.
telemetry
.
scalarAdd
(
TOTAL_URI_COUNT_SCALAR_NAME
1
)
;
BrowserUsageTelemetry
.
_recordTabCounts
(
getOpenTabsAndWinsCounts
(
)
)
;
let
baseDomain
;
try
{
baseDomain
=
Services
.
eTLD
.
getBaseDomain
(
uri
)
;
}
catch
(
e
)
{
return
;
}
if
(
this
.
_domainSet
.
size
<
MAX_UNIQUE_VISITED_DOMAINS
)
{
this
.
_domainSet
.
add
(
baseDomain
)
;
Services
.
telemetry
.
scalarSet
(
UNIQUE_DOMAINS_COUNT_SCALAR_NAME
this
.
_domainSet
.
size
)
;
}
this
.
_domain24hrSet
.
add
(
baseDomain
)
;
if
(
gRecentVisitedOriginsExpiry
)
{
let
timeoutId
=
setTimeout
(
(
)
=
>
{
this
.
_domain24hrSet
.
delete
(
baseDomain
)
;
this
.
_timeouts
.
delete
(
timeoutId
)
;
}
gRecentVisitedOriginsExpiry
*
1000
)
;
this
.
_timeouts
.
add
(
timeoutId
)
;
}
}
reset
(
)
{
this
.
_domainSet
.
clear
(
)
;
}
get
uniqueDomainsVisitedInPast24Hours
(
)
{
return
this
.
_domain24hrSet
.
size
;
}
resetUniqueDomainsVisitedInPast24Hours
(
)
{
this
.
_timeouts
.
forEach
(
timeoutId
=
>
clearTimeout
(
timeoutId
)
)
;
this
.
_timeouts
.
clear
(
)
;
this
.
_domain24hrSet
.
clear
(
)
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIWebProgressListener
"
"
nsISupportsWeakReference
"
]
)
}
;
let
BrowserUsageTelemetry
=
{
Policy
:
{
getTelemetryClientId
:
async
(
)
=
>
ClientID
.
getClientID
(
)
getUpdateDirectory
:
(
)
=
>
Services
.
dirsvc
.
get
(
"
UpdRootD
"
Ci
.
nsIFile
)
readProfileCountFile
:
async
path
=
>
OS
.
File
.
read
(
path
{
encoding
:
"
UTF
-
8
"
}
)
writeProfileCountFile
:
async
(
path
data
)
=
>
OS
.
File
.
writeAtomic
(
path
data
)
}
_inited
:
false
init
(
)
{
this
.
_lastRecordTabCount
=
0
;
this
.
_lastRecordLoadedTabCount
=
0
;
this
.
_lastRecordSiteOriginsPerLoadedTabs
=
0
;
this
.
_setupAfterRestore
(
)
;
this
.
_inited
=
true
;
Services
.
prefs
.
addObserver
(
"
browser
.
tabs
.
extraDragSpace
"
this
)
;
Services
.
prefs
.
addObserver
(
"
browser
.
tabs
.
drawInTitlebar
"
this
)
;
this
.
_recordUITelemetry
(
)
;
}
_resetAddonIds
(
)
{
KNOWN_ADDONS
.
length
=
0
;
}
afterSubsessionSplit
(
)
{
const
counts
=
getOpenTabsAndWinsCounts
(
)
;
Services
.
telemetry
.
scalarSetMaximum
(
MAX_TAB_COUNT_SCALAR_NAME
counts
.
tabCount
)
;
Services
.
telemetry
.
scalarSetMaximum
(
MAX_WINDOW_COUNT_SCALAR_NAME
counts
.
winCount
)
;
URICountListener
.
reset
(
)
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIObserver
"
"
nsISupportsWeakReference
"
]
)
uninit
(
)
{
if
(
!
this
.
_inited
)
{
return
;
}
Services
.
obs
.
removeObserver
(
this
DOMWINDOW_OPENED_TOPIC
)
;
Services
.
obs
.
removeObserver
(
this
TELEMETRY_SUBSESSIONSPLIT_TOPIC
)
;
}
observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
DOMWINDOW_OPENED_TOPIC
:
this
.
_onWindowOpen
(
subject
)
;
break
;
case
TELEMETRY_SUBSESSIONSPLIT_TOPIC
:
this
.
afterSubsessionSplit
(
)
;
break
;
case
"
nsPref
:
changed
"
:
switch
(
data
)
{
case
"
browser
.
tabs
.
extraDragSpace
"
:
this
.
_recordWidgetChange
(
"
drag
-
space
"
Services
.
prefs
.
getBoolPref
(
"
browser
.
tabs
.
extraDragSpace
"
)
?
"
on
"
:
"
off
"
"
pref
"
)
;
break
;
case
"
browser
.
tabs
.
drawInTitlebar
"
:
this
.
_recordWidgetChange
(
"
titlebar
"
Services
.
prefs
.
getBoolPref
(
"
browser
.
tabs
.
drawInTitlebar
"
)
?
"
off
"
:
"
on
"
"
pref
"
)
;
break
;
}
break
;
}
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
TabOpen
"
:
this
.
_onTabOpen
(
getOpenTabsAndWinsCounts
(
)
)
;
break
;
case
"
TabPinned
"
:
this
.
_onTabPinned
(
)
;
break
;
case
"
unload
"
:
this
.
_unregisterWindow
(
event
.
target
)
;
break
;
case
TAB_RESTORING_TOPIC
:
let
browser
=
event
.
target
.
linkedBrowser
;
URICountListener
.
addRestoredURI
(
browser
browser
.
currentURI
)
;
const
{
loadedTabCount
}
=
getOpenTabsAndWinsCounts
(
)
;
this
.
_recordTabCounts
(
{
loadedTabCount
}
)
;
break
;
}
}
recordSearch
(
tabbrowser
engine
source
details
=
{
}
)
{
if
(
!
shouldRecordSearchCount
(
tabbrowser
)
)
{
return
;
}
const
countIdPrefix
=
{
engine
.
telemetryId
}
.
;
const
countIdSource
=
countIdPrefix
+
source
;
let
histogram
=
Services
.
telemetry
.
getKeyedHistogramById
(
"
SEARCH_COUNTS
"
)
;
if
(
details
.
isOneOff
)
{
if
(
!
KNOWN_ONEOFF_SOURCES
.
includes
(
source
)
)
{
if
(
[
"
urlbar
"
"
searchbar
"
]
.
includes
(
source
)
)
{
histogram
.
add
(
countIdSource
)
;
PartnerLinkAttribution
.
makeSearchEngineRequest
(
engine
details
.
url
)
.
catch
(
Cu
.
reportError
)
;
return
;
}
throw
new
Error
(
"
Unknown
source
for
one
-
off
search
:
"
+
source
)
;
}
}
else
{
if
(
!
KNOWN_SEARCH_SOURCES
.
includes
(
source
)
)
{
throw
new
Error
(
"
Unknown
source
for
search
:
"
+
source
)
;
}
if
(
details
.
alias
&
&
engine
.
isAppProvided
&
&
engine
.
aliases
.
includes
(
details
.
alias
)
)
{
histogram
.
add
(
countIdPrefix
+
"
alias
"
)
;
}
else
{
histogram
.
add
(
countIdSource
)
;
}
}
this
.
_handleSearchAction
(
engine
source
details
)
;
}
_recordSearch
(
engine
url
source
action
=
null
)
{
if
(
!
(
action
=
=
"
oneoff
"
&
&
!
url
)
)
{
PartnerLinkAttribution
.
makeSearchEngineRequest
(
engine
url
)
.
catch
(
Cu
.
reportError
)
;
}
let
scalarKey
=
action
?
"
search_
"
+
action
:
"
search
"
;
Services
.
telemetry
.
keyedScalarAdd
(
"
browser
.
engagement
.
navigation
.
"
+
source
scalarKey
1
)
;
Services
.
telemetry
.
recordEvent
(
"
navigation
"
"
search
"
source
action
{
engine
:
engine
.
telemetryId
}
)
;
}
recordSearchMode
(
searchMode
)
{
let
scalarKey
;
if
(
searchMode
.
engineName
)
{
let
engine
=
Services
.
search
.
getEngineByName
(
searchMode
.
engineName
)
;
let
resultDomain
=
engine
.
getResultDomain
(
)
;
if
(
!
engine
.
isAppProvided
)
{
scalarKey
=
"
other
"
;
}
else
if
(
resultDomain
.
includes
(
"
amazon
.
"
)
)
{
scalarKey
=
"
Amazon
"
;
}
else
if
(
resultDomain
.
endsWith
(
"
wikipedia
.
org
"
)
)
{
scalarKey
=
"
Wikipedia
"
;
}
else
{
scalarKey
=
searchMode
.
engineName
;
}
}
else
if
(
searchMode
.
source
)
{
scalarKey
=
UrlbarUtils
.
getResultSourceName
(
searchMode
.
source
)
|
|
"
other
"
;
}
Services
.
telemetry
.
keyedScalarAdd
(
"
urlbar
.
searchmode
.
"
+
searchMode
.
entry
scalarKey
1
)
;
}
_handleSearchAction
(
engine
source
details
)
{
switch
(
source
)
{
case
"
urlbar
"
:
case
"
oneoff
-
urlbar
"
:
case
"
searchbar
"
:
case
"
oneoff
-
searchbar
"
:
case
"
unknown
"
:
this
.
_handleSearchAndUrlbar
(
engine
source
details
)
;
break
;
case
"
urlbar
-
searchmode
"
:
this
.
_handleSearchAndUrlbar
(
engine
"
urlbar_searchmode
"
details
)
;
break
;
case
"
abouthome
"
:
this
.
_recordSearch
(
engine
details
.
url
"
about_home
"
"
enter
"
)
;
break
;
case
"
newtab
"
:
this
.
_recordSearch
(
engine
details
.
url
"
about_newtab
"
"
enter
"
)
;
break
;
case
"
contextmenu
"
:
case
"
system
"
:
case
"
webextension
"
:
this
.
_recordSearch
(
engine
details
.
url
source
)
;
break
;
}
}
_handleSearchAndUrlbar
(
engine
source
details
)
{
const
sourceName
=
source
=
=
=
"
unknown
"
?
"
searchbar
"
:
source
.
replace
(
"
oneoff
-
"
"
"
)
;
const
isOneOff
=
!
!
details
.
isOneOff
;
if
(
isOneOff
)
{
if
(
[
"
urlbar
"
"
searchbar
"
"
unknown
"
]
.
includes
(
source
)
)
{
return
;
}
this
.
_recordSearch
(
engine
details
.
url
sourceName
"
oneoff
"
)
;
return
;
}
if
(
details
.
isFormHistory
)
{
this
.
_recordSearch
(
engine
details
.
url
sourceName
"
formhistory
"
)
;
return
;
}
else
if
(
details
.
isSuggestion
)
{
this
.
_recordSearch
(
engine
details
.
url
sourceName
"
suggestion
"
)
;
return
;
}
else
if
(
details
.
alias
)
{
this
.
_recordSearch
(
engine
details
.
url
sourceName
"
alias
"
)
;
return
;
}
this
.
_recordSearch
(
engine
details
.
url
sourceName
"
enter
"
)
;
}
recordUrlbarSelectedResultMethod
(
event
index
userSelectionBehavior
=
"
none
"
)
{
this
.
_recordUrlOrSearchbarSelectedResultMethod
(
event
index
"
FX_URLBAR_SELECTED_RESULT_METHOD
"
userSelectionBehavior
)
;
}
recordSearchbarSelectedResultMethod
(
event
highlightedIndex
)
{
this
.
_recordUrlOrSearchbarSelectedResultMethod
(
event
highlightedIndex
"
FX_SEARCHBAR_SELECTED_RESULT_METHOD
"
"
none
"
)
;
}
_recordUrlOrSearchbarSelectedResultMethod
(
event
highlightedIndex
histogramID
userSelectionBehavior
)
{
let
histogram
=
Services
.
telemetry
.
getHistogramById
(
histogramID
)
;
let
isClick
=
event
&
&
(
ChromeUtils
.
getClassName
(
event
)
=
=
"
MouseEvent
"
|
|
event
.
type
=
=
"
command
"
)
;
let
category
;
if
(
isClick
)
{
category
=
"
click
"
;
}
else
if
(
highlightedIndex
>
=
0
)
{
switch
(
userSelectionBehavior
)
{
case
"
tab
"
:
category
=
"
tabEnterSelection
"
;
break
;
case
"
arrow
"
:
category
=
"
arrowEnterSelection
"
;
break
;
case
"
rightClick
"
:
category
=
"
rightClickEnter
"
;
break
;
default
:
category
=
"
enterSelection
"
;
}
}
else
{
category
=
"
enter
"
;
}
histogram
.
add
(
category
)
;
}
_setupAfterRestore
(
)
{
Services
.
obs
.
addObserver
(
this
DOMWINDOW_OPENED_TOPIC
true
)
;
Services
.
obs
.
addObserver
(
this
TELEMETRY_SUBSESSIONSPLIT_TOPIC
true
)
;
for
(
let
win
of
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
)
{
this
.
_registerWindow
(
win
)
;
}
const
counts
=
getOpenTabsAndWinsCounts
(
)
;
Services
.
telemetry
.
scalarSetMaximum
(
MAX_TAB_COUNT_SCALAR_NAME
counts
.
tabCount
)
;
Services
.
telemetry
.
scalarSetMaximum
(
MAX_WINDOW_COUNT_SCALAR_NAME
counts
.
winCount
)
;
}
_buildWidgetPositions
(
)
{
let
widgetMap
=
new
Map
(
)
;
const
toolbarState
=
nodeId
=
>
{
let
value
=
Services
.
xulStore
.
getValue
(
AppConstants
.
BROWSER_CHROME_URL
nodeId
"
collapsed
"
)
;
if
(
value
)
{
return
value
=
=
"
true
"
?
"
off
"
:
"
on
"
;
}
return
"
off
"
;
}
;
widgetMap
.
set
(
BROWSER_UI_CONTAINER_IDS
.
PersonalToolbar
toolbarState
(
"
PersonalToolbar
"
)
)
;
let
menuBarHidden
=
Services
.
xulStore
.
getValue
(
AppConstants
.
BROWSER_CHROME_URL
"
toolbar
-
menubar
"
"
autohide
"
)
!
=
"
false
"
;
widgetMap
.
set
(
"
menu
-
toolbar
"
menuBarHidden
?
"
off
"
:
"
on
"
)
;
widgetMap
.
set
(
"
drag
-
space
"
Services
.
prefs
.
getBoolPref
(
"
browser
.
tabs
.
extraDragSpace
"
)
?
"
on
"
:
"
off
"
)
;
widgetMap
.
set
(
"
titlebar
"
Services
.
prefs
.
getBoolPref
(
"
browser
.
tabs
.
drawInTitlebar
"
true
)
?
"
off
"
:
"
on
"
)
;
for
(
let
area
of
CustomizableUI
.
areas
)
{
if
(
!
(
area
in
BROWSER_UI_CONTAINER_IDS
)
)
{
continue
;
}
let
position
=
BROWSER_UI_CONTAINER_IDS
[
area
]
;
if
(
area
=
=
"
nav
-
bar
"
)
{
position
=
{
BROWSER_UI_CONTAINER_IDS
[
area
]
}
-
start
;
}
let
widgets
=
CustomizableUI
.
getWidgetsInArea
(
area
)
;
for
(
let
widget
of
widgets
)
{
if
(
!
widget
)
{
continue
;
}
if
(
widget
.
id
.
startsWith
(
"
customizableui
-
special
-
"
)
)
{
continue
;
}
if
(
area
=
=
"
nav
-
bar
"
&
&
widget
.
id
=
=
"
urlbar
-
container
"
)
{
position
=
{
BROWSER_UI_CONTAINER_IDS
[
area
]
}
-
end
;
continue
;
}
widgetMap
.
set
(
widget
.
id
position
)
;
}
}
let
actions
=
PageActions
.
actions
;
for
(
let
action
of
actions
)
{
if
(
action
.
pinnedToUrlbar
)
{
widgetMap
.
set
(
action
.
id
"
pageaction
-
urlbar
"
)
;
}
}
return
widgetMap
;
}
_getWidgetID
(
node
)
{
if
(
!
node
)
{
return
null
;
}
if
(
node
.
ownerDocument
.
URL
=
=
AppConstants
.
BROWSER_CHROME_URL
)
{
for
(
let
area
of
CustomizableUI
.
areas
)
{
if
(
node
.
closest
(
#
{
CSS
.
escape
(
area
)
}
)
)
{
for
(
let
widget
of
CustomizableUI
.
getWidgetIdsInArea
(
area
)
)
{
if
(
widget
=
=
"
tabbrowser
-
tabs
"
|
|
widget
=
=
"
urlbar
-
container
"
|
|
widget
=
=
"
menubar
-
items
"
|
|
widget
=
=
"
personal
-
bookmarks
"
)
{
continue
;
}
if
(
node
.
closest
(
#
{
CSS
.
escape
(
widget
)
}
)
)
{
return
widget
;
}
}
break
;
}
}
}
if
(
node
.
id
)
{
return
node
.
id
;
}
for
(
let
cls
of
[
"
bookmark
-
item
"
"
tab
-
icon
-
sound
"
"
tab
-
close
-
button
"
]
)
{
if
(
node
.
classList
.
contains
(
cls
)
)
{
return
cls
;
}
}
let
possibleAttributes
=
[
"
preference
"
"
command
"
"
observes
"
"
data
-
l10n
-
id
"
]
;
if
(
node
.
localName
!
=
"
key
"
)
{
possibleAttributes
.
unshift
(
"
key
"
)
;
}
for
(
let
idAttribute
of
possibleAttributes
)
{
if
(
node
.
hasAttribute
(
idAttribute
)
)
{
return
node
.
getAttribute
(
idAttribute
)
;
}
}
return
this
.
_getWidgetID
(
node
.
parentElement
)
;
}
_getWidgetContainer
(
node
)
{
if
(
node
.
localName
=
=
"
key
"
)
{
return
"
keyboard
"
;
}
if
(
node
.
ownerDocument
.
URL
=
=
AppConstants
.
BROWSER_CHROME_URL
)
{
for
(
let
containerId
of
Object
.
keys
(
BROWSER_UI_CONTAINER_IDS
)
)
{
let
container
=
node
.
ownerDocument
.
getElementById
(
containerId
)
;
if
(
container
&
&
container
.
contains
(
node
)
)
{
return
BROWSER_UI_CONTAINER_IDS
[
containerId
]
;
}
}
}
else
if
(
node
.
ownerDocument
.
URL
.
startsWith
(
"
about
:
preferences
"
)
)
{
let
container
=
node
.
closest
(
"
[
data
-
category
]
"
)
;
if
(
!
container
)
{
return
null
;
}
let
pane
=
container
.
getAttribute
(
"
data
-
category
"
)
;
if
(
!
PREFERENCES_PANES
.
includes
(
pane
)
)
{
pane
=
"
paneUnknown
"
;
}
return
preferences_
{
pane
}
;
}
return
null
;
}
lastClickTarget
:
null
ignoreEvent
(
event
)
{
IGNORABLE_EVENTS
.
set
(
event
true
)
;
}
_recordCommand
(
event
)
{
if
(
IGNORABLE_EVENTS
.
get
(
event
)
)
{
return
;
}
let
types
=
[
event
.
type
]
;
let
sourceEvent
=
event
;
while
(
sourceEvent
.
sourceEvent
)
{
sourceEvent
=
sourceEvent
.
sourceEvent
;
types
.
push
(
sourceEvent
.
type
)
;
}
let
lastTarget
=
this
.
lastClickTarget
?
.
get
(
)
;
if
(
lastTarget
&
&
sourceEvent
.
type
=
=
"
command
"
&
&
sourceEvent
.
target
.
contains
(
lastTarget
)
)
{
this
.
lastClickTarget
=
null
;
return
;
}
this
.
lastClickTarget
=
null
;
if
(
sourceEvent
.
type
=
=
"
click
"
)
{
if
(
sourceEvent
.
button
!
=
0
)
{
return
;
}
this
.
lastClickTarget
=
Cu
.
getWeakReference
(
sourceEvent
.
target
)
;
}
let
url
=
sourceEvent
.
target
.
ownerDocument
.
documentURIObject
;
if
(
!
url
.
schemeIs
(
"
chrome
"
)
&
&
!
url
.
schemeIs
(
"
about
"
)
)
{
return
;
}
if
(
sourceEvent
.
target
.
localName
=
=
"
browser
"
)
{
return
;
}
let
node
=
sourceEvent
.
target
;
while
(
!
UI_TARGET_ELEMENTS
.
includes
(
node
.
localName
)
)
{
node
=
node
.
parentNode
;
if
(
!
node
)
{
return
;
}
}
let
item
=
this
.
_getWidgetID
(
node
)
;
let
source
=
this
.
_getWidgetContainer
(
node
)
;
if
(
item
&
&
source
)
{
let
scalar
=
browser
.
ui
.
interaction
.
{
source
.
replace
(
"
-
"
"
_
"
)
}
;
Services
.
telemetry
.
keyedScalarAdd
(
scalar
telemetryId
(
item
)
1
)
;
}
}
_addUsageListeners
(
win
)
{
win
.
addEventListener
(
"
command
"
event
=
>
this
.
_recordCommand
(
event
)
true
)
;
win
.
addEventListener
(
"
click
"
event
=
>
this
.
_recordCommand
(
event
)
true
)
;
}
recordWidgetChange
(
widgetId
newPos
reason
)
{
try
{
if
(
newPos
)
{
newPos
=
BROWSER_UI_CONTAINER_IDS
[
newPos
]
;
}
if
(
newPos
=
=
"
nav
-
bar
"
)
{
let
{
position
}
=
CustomizableUI
.
getPlacementOfWidget
(
widgetId
)
;
let
{
position
:
urlPosition
}
=
CustomizableUI
.
getPlacementOfWidget
(
"
urlbar
-
container
"
)
;
newPos
=
newPos
+
(
urlPosition
>
position
?
"
-
start
"
:
"
-
end
"
)
;
}
this
.
_recordWidgetChange
(
widgetId
newPos
reason
)
;
}
catch
(
e
)
{
console
.
error
(
e
)
;
}
}
recordToolbarVisibility
(
toolbarId
newState
reason
)
{
this
.
_recordWidgetChange
(
BROWSER_UI_CONTAINER_IDS
[
toolbarId
]
newState
?
"
on
"
:
"
off
"
reason
)
;
}
_recordWidgetChange
(
widgetId
newPos
reason
)
{
if
(
!
this
.
widgetMap
)
{
return
;
}
if
(
widgetId
=
=
"
urlbar
-
container
"
)
{
let
position
=
"
nav
-
bar
-
start
"
;
let
widgets
=
CustomizableUI
.
getWidgetsInArea
(
"
nav
-
bar
"
)
;
for
(
let
widget
of
widgets
)
{
if
(
!
widget
)
{
continue
;
}
if
(
widget
.
id
.
startsWith
(
"
customizableui
-
special
-
"
)
)
{
continue
;
}
if
(
widget
.
id
=
=
"
urlbar
-
container
"
)
{
position
=
"
nav
-
bar
-
end
"
;
continue
;
}
this
.
_recordWidgetChange
(
widget
.
id
position
reason
)
;
}
return
;
}
let
oldPos
=
this
.
widgetMap
.
get
(
widgetId
)
;
if
(
oldPos
=
=
newPos
)
{
return
;
}
let
action
=
"
move
"
;
if
(
!
oldPos
)
{
action
=
"
add
"
;
}
else
if
(
!
newPos
)
{
action
=
"
remove
"
;
}
let
key
=
{
telemetryId
(
widgetId
false
)
}
_
{
action
}
_
{
oldPos
?
?
"
na
"
}
_
{
newPos
?
?
"
na
"
}
_
{
reason
}
;
Services
.
telemetry
.
keyedScalarAdd
(
"
browser
.
ui
.
customized_widgets
"
key
1
)
;
if
(
newPos
)
{
this
.
widgetMap
.
set
(
widgetId
newPos
)
;
}
else
{
this
.
widgetMap
.
delete
(
widgetId
)
;
}
}
_recordUITelemetry
(
)
{
this
.
widgetMap
=
this
.
_buildWidgetPositions
(
)
;
for
(
let
[
widgetId
position
]
of
this
.
widgetMap
.
entries
(
)
)
{
let
key
=
{
telemetryId
(
widgetId
false
)
}
_pinned_
{
position
}
;
Services
.
telemetry
.
keyedScalarSet
(
"
browser
.
ui
.
toolbar_widgets
"
key
true
)
;
}
}
_registerWindow
(
win
)
{
this
.
_addUsageListeners
(
win
)
;
win
.
addEventListener
(
"
unload
"
this
)
;
win
.
addEventListener
(
"
TabOpen
"
this
true
)
;
win
.
addEventListener
(
"
TabPinned
"
this
true
)
;
win
.
gBrowser
.
tabContainer
.
addEventListener
(
TAB_RESTORING_TOPIC
this
)
;
win
.
gBrowser
.
addTabsProgressListener
(
URICountListener
)
;
}
_unregisterWindow
(
win
)
{
win
.
removeEventListener
(
"
unload
"
this
)
;
win
.
removeEventListener
(
"
TabOpen
"
this
true
)
;
win
.
removeEventListener
(
"
TabPinned
"
this
true
)
;
win
.
defaultView
.
gBrowser
.
tabContainer
.
removeEventListener
(
TAB_RESTORING_TOPIC
this
)
;
win
.
defaultView
.
gBrowser
.
removeTabsProgressListener
(
URICountListener
)
;
}
_onTabOpen
(
{
tabCount
loadedTabCount
}
)
{
Services
.
telemetry
.
scalarAdd
(
TAB_OPEN_EVENT_COUNT_SCALAR_NAME
1
)
;
Services
.
telemetry
.
scalarSetMaximum
(
MAX_TAB_COUNT_SCALAR_NAME
tabCount
)
;
this
.
_recordTabCounts
(
{
tabCount
loadedTabCount
}
)
;
}
_onTabPinned
(
target
)
{
const
pinnedTabs
=
getPinnedTabsCount
(
)
;
Services
.
telemetry
.
scalarAdd
(
TAB_PINNED_EVENT_COUNT_SCALAR_NAME
1
)
;
Services
.
telemetry
.
scalarSetMaximum
(
MAX_TAB_PINNED_COUNT_SCALAR_NAME
pinnedTabs
)
;
}
_onWindowOpen
(
win
)
{
if
(
!
(
win
instanceof
Ci
.
nsIDOMWindow
)
)
{
return
;
}
let
onLoad
=
(
)
=
>
{
win
.
removeEventListener
(
"
load
"
onLoad
)
;
if
(
win
.
document
.
documentElement
.
getAttribute
(
"
windowtype
"
)
!
=
"
navigator
:
browser
"
)
{
return
;
}
this
.
_registerWindow
(
win
)
;
const
counts
=
getOpenTabsAndWinsCounts
(
)
;
Services
.
telemetry
.
scalarAdd
(
WINDOW_OPEN_EVENT_COUNT_SCALAR_NAME
1
)
;
Services
.
telemetry
.
scalarSetMaximum
(
MAX_WINDOW_COUNT_SCALAR_NAME
counts
.
winCount
)
;
this
.
_onTabOpen
(
counts
)
;
}
;
win
.
addEventListener
(
"
load
"
onLoad
)
;
}
_recordTabCounts
(
{
tabCount
loadedTabCount
}
)
{
let
currentTime
=
Date
.
now
(
)
;
if
(
tabCount
!
=
=
undefined
&
&
currentTime
>
this
.
_lastRecordTabCount
+
MINIMUM_TAB_COUNT_INTERVAL_MS
)
{
Services
.
telemetry
.
getHistogramById
(
"
TAB_COUNT
"
)
.
add
(
tabCount
)
;
this
.
_lastRecordTabCount
=
currentTime
;
}
if
(
loadedTabCount
!
=
=
undefined
&
&
currentTime
>
this
.
_lastRecordLoadedTabCount
+
MINIMUM_TAB_COUNT_INTERVAL_MS
)
{
Services
.
telemetry
.
getHistogramById
(
"
LOADED_TAB_COUNT
"
)
.
add
(
loadedTabCount
)
;
this
.
_lastRecordLoadedTabCount
=
currentTime
;
}
}
_checkProfileCountFileSchema
(
fileData
)
{
if
(
typeof
fileData
.
version
!
=
"
string
"
)
{
throw
new
Error
(
"
Schema
Mismatch
Error
:
Bad
type
for
'
version
'
field
"
)
;
}
if
(
!
Array
.
isArray
(
fileData
.
profileTelemetryIds
)
)
{
throw
new
Error
(
"
Schema
Mismatch
Error
:
Bad
type
for
'
profileTelemetryIds
'
field
"
)
;
}
for
(
let
profileTelemetryId
of
fileData
.
profileTelemetryIds
)
{
if
(
typeof
profileTelemetryId
!
=
"
string
"
)
{
throw
new
Error
(
"
Schema
Mismatch
Error
:
Bad
type
for
an
element
of
'
profileTelemetryIds
'
"
)
;
}
}
}
async
reportProfileCount
(
)
{
if
(
AppConstants
.
platform
!
=
"
win
"
)
{
return
;
}
const
buckets
=
[
1
2
3
4
5
6
7
8
9
10
100
1000
10000
]
;
const
updateDirectory
=
BrowserUsageTelemetry
.
Policy
.
getUpdateDirectory
(
)
;
const
hash
=
updateDirectory
.
leafName
;
const
profileCountFilename
=
"
profile_count_
"
+
hash
+
"
.
json
"
;
let
profileCountFile
=
updateDirectory
.
parent
.
parent
;
profileCountFile
.
append
(
profileCountFilename
)
;
let
readError
=
false
;
let
fileData
;
try
{
let
json
=
await
BrowserUsageTelemetry
.
Policy
.
readProfileCountFile
(
profileCountFile
.
path
)
;
fileData
=
JSON
.
parse
(
json
)
;
BrowserUsageTelemetry
.
_checkProfileCountFileSchema
(
fileData
)
;
}
catch
(
ex
)
{
fileData
=
{
version
:
"
1
"
profileTelemetryIds
:
[
]
}
;
if
(
!
(
ex
instanceof
OS
.
File
.
Error
&
&
ex
.
becauseNoSuchFile
)
)
{
Cu
.
reportError
(
ex
)
;
readError
=
true
;
}
}
let
writeError
=
false
;
let
currentTelemetryId
=
await
BrowserUsageTelemetry
.
Policy
.
getTelemetryClientId
(
)
;
if
(
!
fileData
.
profileTelemetryIds
.
includes
(
currentTelemetryId
)
&
&
fileData
.
profileTelemetryIds
.
length
<
Math
.
max
(
.
.
.
buckets
)
)
{
fileData
.
profileTelemetryIds
.
push
(
currentTelemetryId
)
;
try
{
await
BrowserUsageTelemetry
.
Policy
.
writeProfileCountFile
(
profileCountFile
.
path
JSON
.
stringify
(
fileData
)
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
writeError
=
true
;
}
}
let
rawProfileCount
=
fileData
.
profileTelemetryIds
.
length
;
let
valueToReport
=
0
;
for
(
let
bucket
of
buckets
)
{
if
(
bucket
<
=
rawProfileCount
&
&
bucket
>
valueToReport
)
{
valueToReport
=
bucket
;
}
}
if
(
readError
|
|
writeError
)
{
valueToReport
=
0
;
}
Services
.
telemetry
.
scalarSet
(
"
browser
.
engagement
.
profile_count
"
valueToReport
)
;
}
_recordSiteOriginsPerLoadedTabs
(
)
{
const
currentTime
=
Date
.
now
(
)
;
if
(
currentTime
>
this
.
_lastRecordSiteOriginsPerLoadedTabs
+
MINIMUM_TAB_COUNT_INTERVAL_MS
)
{
this
.
_lastRecordSiteOriginsPerLoadedTabs
=
currentTime
;
if
(
this
.
_lastRecordSiteOriginsPerLoadedTabs
=
=
=
0
)
{
return
;
}
const
{
loadedTabCount
}
=
getOpenTabsAndWinsCounts
(
)
;
const
siteOrigins
=
BrowserUtils
.
computeSiteOriginCount
(
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
false
)
;
const
histogramId
=
this
.
_getSiteOriginHistogram
(
loadedTabCount
)
;
Services
.
telemetry
.
getHistogramById
(
histogramId
)
.
add
(
Math
.
trunc
(
(
100
*
siteOrigins
)
/
loadedTabCount
)
)
;
}
}
_siteOriginHistogramIds
:
[
[
1
1
"
FX_NUMBER_OF_UNIQUE_SITE_ORIGINS_PER_LOADED_TABS_1
"
]
[
2
4
"
FX_NUMBER_OF_UNIQUE_SITE_ORIGINS_PER_LOADED_TABS_2_4
"
]
[
5
9
"
FX_NUMBER_OF_UNIQUE_SITE_ORIGINS_PER_LOADED_TABS_5_9
"
]
[
10
14
"
FX_NUMBER_OF_UNIQUE_SITE_ORIGINS_PER_LOADED_TABS_10_14
"
]
[
15
19
"
FX_NUMBER_OF_UNIQUE_SITE_ORIGINS_PER_LOADED_TABS_15_19
"
]
[
20
24
"
FX_NUMBER_OF_UNIQUE_SITE_ORIGINS_PER_LOADED_TABS_20_24
"
]
[
25
29
"
FX_NUMBER_OF_UNIQUE_SITE_ORIGINS_PER_LOADED_TABS_25_29
"
]
[
31
34
"
FX_NUMBER_OF_UNIQUE_SITE_ORIGINS_PER_LOADED_TABS_30_34
"
]
[
35
39
"
FX_NUMBER_OF_UNIQUE_SITE_ORIGINS_PER_LOADED_TABS_35_39
"
]
[
40
44
"
FX_NUMBER_OF_UNIQUE_SITE_ORIGINS_PER_LOADED_TABS_40_44
"
]
[
45
49
"
FX_NUMBER_OF_UNIQUE_SITE_ORIGINS_PER_LOADED_TABS_45_49
"
]
]
_getSiteOriginHistogram
(
loadedTabCount
)
{
for
(
const
[
min
max
histogramId
]
of
this
.
_siteOriginHistogramIds
)
{
if
(
min
<
=
loadedTabCount
&
&
loadedTabCount
<
=
max
)
{
return
histogramId
;
}
}
return
"
FX_NUMBER_OF_UNIQUE_SITE_ORIGINS_PER_LOADED_TABS_50_PLUS
"
;
}
}
;
function
getUniqueDomainsVisitedInPast24Hours
(
)
{
return
URICountListener
.
uniqueDomainsVisitedInPast24Hours
;
}
