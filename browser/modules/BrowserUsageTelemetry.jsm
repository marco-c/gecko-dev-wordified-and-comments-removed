"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
BrowserUsageTelemetry
"
"
URLBAR_SELECTED_RESULT_TYPES
"
"
URLBAR_SELECTED_RESULT_METHODS
"
"
MINIMUM_TAB_COUNT_INTERVAL_MS
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PrivateBrowsingUtils
"
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
const
MAX_UNIQUE_VISITED_DOMAINS
=
100
;
const
TAB_RESTORING_TOPIC
=
"
SSTabRestoring
"
;
const
TELEMETRY_SUBSESSIONSPLIT_TOPIC
=
"
internal
-
telemetry
-
after
-
subsession
-
split
"
;
const
DOMWINDOW_OPENED_TOPIC
=
"
domwindowopened
"
;
const
AUTOCOMPLETE_ENTER_TEXT_TOPIC
=
"
autocomplete
-
did
-
enter
-
text
"
;
const
MAX_TAB_COUNT_SCALAR_NAME
=
"
browser
.
engagement
.
max_concurrent_tab_count
"
;
const
MAX_WINDOW_COUNT_SCALAR_NAME
=
"
browser
.
engagement
.
max_concurrent_window_count
"
;
const
TAB_OPEN_EVENT_COUNT_SCALAR_NAME
=
"
browser
.
engagement
.
tab_open_event_count
"
;
const
WINDOW_OPEN_EVENT_COUNT_SCALAR_NAME
=
"
browser
.
engagement
.
window_open_event_count
"
;
const
UNIQUE_DOMAINS_COUNT_SCALAR_NAME
=
"
browser
.
engagement
.
unique_domains_count
"
;
const
TOTAL_URI_COUNT_SCALAR_NAME
=
"
browser
.
engagement
.
total_uri_count
"
;
const
UNFILTERED_URI_COUNT_SCALAR_NAME
=
"
browser
.
engagement
.
unfiltered_uri_count
"
;
const
KNOWN_SEARCH_SOURCES
=
[
"
abouthome
"
"
contextmenu
"
"
newtab
"
"
searchbar
"
"
urlbar
"
]
;
const
KNOWN_ONEOFF_SOURCES
=
[
"
oneoff
-
urlbar
"
"
oneoff
-
searchbar
"
"
unknown
"
]
;
const
URLBAR_SELECTED_RESULT_TYPES
=
{
autofill
:
0
bookmark
:
1
history
:
2
keyword
:
3
searchengine
:
4
searchsuggestion
:
5
switchtab
:
6
tag
:
7
visiturl
:
8
remotetab
:
9
extension
:
10
"
preloaded
-
top
-
site
"
:
11
}
;
const
URLBAR_SELECTED_RESULT_METHODS
=
{
enter
:
0
enterSelection
:
1
click
:
2
arrowEnterSelection
:
3
tabEnterSelection
:
4
rightClickEnter
:
5
}
;
const
MINIMUM_TAB_COUNT_INTERVAL_MS
=
5
*
60
*
1000
;
function
getOpenTabsAndWinsCounts
(
)
{
let
tabCount
=
0
;
let
winCount
=
0
;
let
browserEnum
=
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
;
while
(
browserEnum
.
hasMoreElements
(
)
)
{
let
win
=
browserEnum
.
getNext
(
)
;
winCount
+
+
;
tabCount
+
=
win
.
gBrowser
.
tabs
.
length
;
}
return
{
tabCount
winCount
}
;
}
function
getTabCount
(
)
{
return
getOpenTabsAndWinsCounts
(
)
.
tabCount
;
}
function
getSearchEngineId
(
engine
)
{
if
(
engine
)
{
if
(
engine
.
identifier
)
{
return
engine
.
identifier
;
}
if
(
engine
.
name
)
{
return
"
other
-
"
+
engine
.
name
;
}
}
return
"
other
"
;
}
let
URICountListener
=
{
_domainSet
:
new
Set
(
)
_restoredURIsMap
:
new
WeakMap
(
)
isHttpURI
(
uri
)
{
return
uri
.
schemeIs
(
"
http
"
)
|
|
uri
.
schemeIs
(
"
https
"
)
;
}
addRestoredURI
(
browser
uri
)
{
if
(
!
this
.
isHttpURI
(
uri
)
)
{
return
;
}
this
.
_restoredURIsMap
.
set
(
browser
uri
.
spec
)
;
}
onLocationChange
(
browser
webProgress
request
uri
flags
)
{
if
(
flags
&
Ci
.
nsIWebProgressListener
.
LOCATION_CHANGE_ERROR_PAGE
)
{
return
;
}
if
(
!
webProgress
.
isTopLevel
)
{
return
;
}
if
(
!
request
&
&
!
(
flags
&
Ci
.
nsIWebProgressListener
.
LOCATION_CHANGE_SAME_DOCUMENT
)
)
{
return
;
}
let
uriSpec
=
null
;
try
{
uriSpec
=
uri
.
spec
;
}
catch
(
e
)
{
Services
.
telemetry
.
scalarAdd
(
UNFILTERED_URI_COUNT_SCALAR_NAME
1
)
;
return
;
}
if
(
browser
.
ownerGlobal
.
gInitialPages
.
includes
(
uriSpec
)
)
{
return
;
}
if
(
this
.
_restoredURIsMap
.
get
(
browser
)
=
=
=
uriSpec
)
{
this
.
_restoredURIsMap
.
delete
(
browser
)
;
return
;
}
Services
.
telemetry
.
scalarAdd
(
UNFILTERED_URI_COUNT_SCALAR_NAME
1
)
;
if
(
!
this
.
isHttpURI
(
uri
)
)
{
return
;
}
Services
.
telemetry
.
scalarAdd
(
TOTAL_URI_COUNT_SCALAR_NAME
1
)
;
BrowserUsageTelemetry
.
_recordTabCount
(
)
;
if
(
this
.
_domainSet
.
size
=
=
MAX_UNIQUE_VISITED_DOMAINS
)
{
return
;
}
try
{
this
.
_domainSet
.
add
(
Services
.
eTLD
.
getBaseDomain
(
uri
)
)
;
}
catch
(
e
)
{
return
;
}
Services
.
telemetry
.
scalarSet
(
UNIQUE_DOMAINS_COUNT_SCALAR_NAME
this
.
_domainSet
.
size
)
;
}
reset
(
)
{
this
.
_domainSet
.
clear
(
)
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIWebProgressListener
Ci
.
nsISupportsWeakReference
]
)
}
;
let
urlbarListener
=
{
selectedIndex
:
-
1
init
(
)
{
Services
.
obs
.
addObserver
(
this
AUTOCOMPLETE_ENTER_TEXT_TOPIC
true
)
;
}
uninit
(
)
{
Services
.
obs
.
removeObserver
(
this
AUTOCOMPLETE_ENTER_TEXT_TOPIC
)
;
}
observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
AUTOCOMPLETE_ENTER_TEXT_TOPIC
:
this
.
_handleURLBarTelemetry
(
subject
.
QueryInterface
(
Ci
.
nsIAutoCompleteInput
)
)
;
break
;
}
}
_handleURLBarTelemetry
(
input
)
{
if
(
!
input
|
|
input
.
id
!
=
"
urlbar
"
)
{
return
;
}
if
(
input
.
inPrivateContext
|
|
input
.
popup
.
selectedIndex
<
0
)
{
this
.
selectedIndex
=
-
1
;
return
;
}
this
.
selectedIndex
=
input
.
popup
.
selectedIndex
>
0
|
|
!
input
.
popup
.
_isFirstResultHeuristic
?
input
.
popup
.
selectedIndex
:
-
1
;
let
controller
=
input
.
popup
.
view
.
QueryInterface
(
Ci
.
nsIAutoCompleteController
)
;
let
idx
=
input
.
popup
.
selectedIndex
;
let
value
=
controller
.
getValueAt
(
idx
)
;
let
action
=
input
.
_parseActionUrl
(
value
)
;
let
actionType
;
if
(
action
)
{
actionType
=
action
.
type
=
=
"
searchengine
"
&
&
action
.
params
.
searchSuggestion
?
"
searchsuggestion
"
:
action
.
type
;
}
if
(
!
actionType
)
{
let
styles
=
new
Set
(
controller
.
getStyleAt
(
idx
)
.
split
(
/
\
s
+
/
)
)
;
let
style
=
[
"
preloaded
-
top
-
site
"
"
autofill
"
"
tag
"
"
bookmark
"
]
.
find
(
s
=
>
styles
.
has
(
s
)
)
;
actionType
=
style
|
|
"
history
"
;
}
Services
.
telemetry
.
getHistogramById
(
"
FX_URLBAR_SELECTED_RESULT_INDEX
"
)
.
add
(
idx
)
;
if
(
actionType
in
URLBAR_SELECTED_RESULT_TYPES
)
{
Services
.
telemetry
.
getHistogramById
(
"
FX_URLBAR_SELECTED_RESULT_TYPE
"
)
.
add
(
URLBAR_SELECTED_RESULT_TYPES
[
actionType
]
)
;
Services
.
telemetry
.
getKeyedHistogramById
(
"
FX_URLBAR_SELECTED_RESULT_INDEX_BY_TYPE
"
)
.
add
(
actionType
idx
)
;
if
(
actionType
=
=
=
"
bookmark
"
|
|
actionType
=
=
=
"
history
"
)
{
Services
.
telemetry
.
recordEvent
(
"
savant
"
"
follow_urlbar_link
"
actionType
null
{
subcategory
:
"
navigation
"
}
)
;
}
}
else
{
Cu
.
reportError
(
"
Unknown
FX_URLBAR_SELECTED_RESULT_TYPE
type
:
"
+
actionType
)
;
}
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIObserver
Ci
.
nsISupportsWeakReference
]
)
}
;
let
BrowserUsageTelemetry
=
{
_inited
:
false
init
(
)
{
this
.
_lastRecordTabCount
=
0
;
urlbarListener
.
init
(
)
;
this
.
_setupAfterRestore
(
)
;
this
.
_inited
=
true
;
}
afterSubsessionSplit
(
)
{
const
counts
=
getOpenTabsAndWinsCounts
(
)
;
Services
.
telemetry
.
scalarSetMaximum
(
MAX_TAB_COUNT_SCALAR_NAME
counts
.
tabCount
)
;
Services
.
telemetry
.
scalarSetMaximum
(
MAX_WINDOW_COUNT_SCALAR_NAME
counts
.
winCount
)
;
URICountListener
.
reset
(
)
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIObserver
Ci
.
nsISupportsWeakReference
]
)
uninit
(
)
{
if
(
!
this
.
_inited
)
{
return
;
}
Services
.
obs
.
removeObserver
(
this
DOMWINDOW_OPENED_TOPIC
)
;
Services
.
obs
.
removeObserver
(
this
TELEMETRY_SUBSESSIONSPLIT_TOPIC
)
;
urlbarListener
.
uninit
(
)
;
}
observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
DOMWINDOW_OPENED_TOPIC
:
this
.
_onWindowOpen
(
subject
)
;
break
;
case
TELEMETRY_SUBSESSIONSPLIT_TOPIC
:
this
.
afterSubsessionSplit
(
)
;
break
;
}
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
TabOpen
"
:
this
.
_onTabOpen
(
)
;
break
;
case
"
unload
"
:
this
.
_unregisterWindow
(
event
.
target
)
;
break
;
case
TAB_RESTORING_TOPIC
:
let
browser
=
event
.
target
.
linkedBrowser
;
URICountListener
.
addRestoredURI
(
browser
browser
.
currentURI
)
;
break
;
}
}
recordSearch
(
engine
source
details
=
{
}
)
{
const
isOneOff
=
!
!
details
.
isOneOff
;
const
countId
=
getSearchEngineId
(
engine
)
+
"
.
"
+
source
;
if
(
isOneOff
)
{
if
(
!
KNOWN_ONEOFF_SOURCES
.
includes
(
source
)
)
{
if
(
[
"
urlbar
"
"
searchbar
"
]
.
includes
(
source
)
)
{
Services
.
telemetry
.
getKeyedHistogramById
(
"
SEARCH_COUNTS
"
)
.
add
(
countId
)
;
return
;
}
throw
new
Error
(
"
Unknown
source
for
one
-
off
search
:
"
+
source
)
;
}
}
else
{
if
(
!
KNOWN_SEARCH_SOURCES
.
includes
(
source
)
)
{
throw
new
Error
(
"
Unknown
source
for
search
:
"
+
source
)
;
}
Services
.
telemetry
.
getKeyedHistogramById
(
"
SEARCH_COUNTS
"
)
.
add
(
countId
)
;
}
this
.
_handleSearchAction
(
engine
source
details
)
;
}
_recordSearch
(
engine
source
action
=
null
)
{
let
scalarKey
=
action
?
"
search_
"
+
action
:
"
search
"
;
Services
.
telemetry
.
keyedScalarAdd
(
"
browser
.
engagement
.
navigation
.
"
+
source
scalarKey
1
)
;
Services
.
telemetry
.
recordEvent
(
"
navigation
"
"
search
"
source
action
{
engine
:
getSearchEngineId
(
engine
)
}
)
;
Services
.
telemetry
.
recordEvent
(
"
savant
"
"
search
"
source
action
{
subcategory
:
"
navigation
"
engine
:
getSearchEngineId
(
engine
)
}
)
;
}
_handleSearchAction
(
engine
source
details
)
{
switch
(
source
)
{
case
"
urlbar
"
:
case
"
oneoff
-
urlbar
"
:
case
"
searchbar
"
:
case
"
oneoff
-
searchbar
"
:
case
"
unknown
"
:
this
.
_handleSearchAndUrlbar
(
engine
source
details
)
;
break
;
case
"
abouthome
"
:
this
.
_recordSearch
(
engine
"
about_home
"
"
enter
"
)
;
break
;
case
"
newtab
"
:
this
.
_recordSearch
(
engine
"
about_newtab
"
"
enter
"
)
;
break
;
case
"
contextmenu
"
:
this
.
_recordSearch
(
engine
"
contextmenu
"
)
;
break
;
}
}
_handleSearchAndUrlbar
(
engine
source
details
)
{
const
sourceName
=
(
source
=
=
=
"
unknown
"
)
?
"
searchbar
"
:
source
.
replace
(
"
oneoff
-
"
"
"
)
;
const
isOneOff
=
!
!
details
.
isOneOff
;
if
(
isOneOff
)
{
if
(
[
"
urlbar
"
"
searchbar
"
"
unknown
"
]
.
includes
(
source
)
)
{
return
;
}
this
.
_recordSearch
(
engine
sourceName
"
oneoff
"
)
;
return
;
}
if
(
details
.
isSuggestion
)
{
this
.
_recordSearch
(
engine
sourceName
"
suggestion
"
)
;
return
;
}
else
if
(
details
.
isAlias
)
{
this
.
_recordSearch
(
engine
sourceName
"
alias
"
)
;
return
;
}
this
.
_recordSearch
(
engine
sourceName
"
enter
"
)
;
}
recordUrlbarSelectedResultMethod
(
event
userSelectionBehavior
=
"
none
"
)
{
this
.
_recordUrlOrSearchbarSelectedResultMethod
(
event
urlbarListener
.
selectedIndex
"
FX_URLBAR_SELECTED_RESULT_METHOD
"
userSelectionBehavior
)
;
}
recordSearchbarSelectedResultMethod
(
event
highlightedIndex
)
{
this
.
_recordUrlOrSearchbarSelectedResultMethod
(
event
highlightedIndex
"
FX_SEARCHBAR_SELECTED_RESULT_METHOD
"
"
none
"
)
;
}
_recordUrlOrSearchbarSelectedResultMethod
(
event
highlightedIndex
histogramID
userSelectionBehavior
)
{
let
histogram
=
Services
.
telemetry
.
getHistogramById
(
histogramID
)
;
let
isClick
=
event
&
&
(
ChromeUtils
.
getClassName
(
event
)
=
=
"
MouseEvent
"
|
|
event
.
type
=
=
"
command
"
)
;
let
category
;
if
(
isClick
)
{
category
=
"
click
"
;
}
else
if
(
highlightedIndex
>
=
0
)
{
switch
(
userSelectionBehavior
)
{
case
"
tab
"
:
category
=
"
tabEnterSelection
"
;
break
;
case
"
arrow
"
:
category
=
"
arrowEnterSelection
"
;
break
;
case
"
rightClick
"
:
category
=
"
rightClickEnter
"
;
break
;
default
:
category
=
"
enterSelection
"
;
}
}
else
{
category
=
"
enter
"
;
}
histogram
.
add
(
category
)
;
}
_setupAfterRestore
(
)
{
Services
.
obs
.
addObserver
(
this
DOMWINDOW_OPENED_TOPIC
true
)
;
Services
.
obs
.
addObserver
(
this
TELEMETRY_SUBSESSIONSPLIT_TOPIC
true
)
;
let
browserEnum
=
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
;
while
(
browserEnum
.
hasMoreElements
(
)
)
{
this
.
_registerWindow
(
browserEnum
.
getNext
(
)
)
;
}
const
counts
=
getOpenTabsAndWinsCounts
(
)
;
Services
.
telemetry
.
scalarSetMaximum
(
MAX_TAB_COUNT_SCALAR_NAME
counts
.
tabCount
)
;
Services
.
telemetry
.
scalarSetMaximum
(
MAX_WINDOW_COUNT_SCALAR_NAME
counts
.
winCount
)
;
}
_registerWindow
(
win
)
{
win
.
addEventListener
(
"
unload
"
this
)
;
win
.
addEventListener
(
"
TabOpen
"
this
true
)
;
if
(
PrivateBrowsingUtils
.
isWindowPrivate
(
win
)
)
{
return
;
}
win
.
gBrowser
.
tabContainer
.
addEventListener
(
TAB_RESTORING_TOPIC
this
)
;
win
.
gBrowser
.
addTabsProgressListener
(
URICountListener
)
;
}
_unregisterWindow
(
win
)
{
win
.
removeEventListener
(
"
unload
"
this
)
;
win
.
removeEventListener
(
"
TabOpen
"
this
true
)
;
if
(
PrivateBrowsingUtils
.
isWindowPrivate
(
win
.
defaultView
)
)
{
return
;
}
win
.
defaultView
.
gBrowser
.
tabContainer
.
removeEventListener
(
TAB_RESTORING_TOPIC
this
)
;
win
.
defaultView
.
gBrowser
.
removeTabsProgressListener
(
URICountListener
)
;
}
_onTabOpen
(
tabCount
=
0
)
{
tabCount
=
tabCount
|
|
getOpenTabsAndWinsCounts
(
)
.
tabCount
;
Services
.
telemetry
.
scalarAdd
(
TAB_OPEN_EVENT_COUNT_SCALAR_NAME
1
)
;
Services
.
telemetry
.
scalarSetMaximum
(
MAX_TAB_COUNT_SCALAR_NAME
tabCount
)
;
this
.
_recordTabCount
(
tabCount
)
;
}
_onWindowOpen
(
win
)
{
if
(
!
(
win
instanceof
Ci
.
nsIDOMWindow
)
)
{
return
;
}
let
onLoad
=
(
)
=
>
{
win
.
removeEventListener
(
"
load
"
onLoad
)
;
if
(
win
.
document
.
documentElement
.
getAttribute
(
"
windowtype
"
)
!
=
"
navigator
:
browser
"
)
{
return
;
}
this
.
_registerWindow
(
win
)
;
const
counts
=
getOpenTabsAndWinsCounts
(
)
;
Services
.
telemetry
.
scalarAdd
(
WINDOW_OPEN_EVENT_COUNT_SCALAR_NAME
1
)
;
Services
.
telemetry
.
scalarSetMaximum
(
MAX_WINDOW_COUNT_SCALAR_NAME
counts
.
winCount
)
;
this
.
_onTabOpen
(
counts
.
tabCount
)
;
}
;
win
.
addEventListener
(
"
load
"
onLoad
)
;
}
_recordTabCount
(
tabCount
)
{
let
currentTime
=
Date
.
now
(
)
;
if
(
currentTime
>
this
.
_lastRecordTabCount
+
MINIMUM_TAB_COUNT_INTERVAL_MS
)
{
if
(
tabCount
=
=
=
undefined
)
{
tabCount
=
getTabCount
(
)
;
}
Services
.
telemetry
.
getHistogramById
(
"
TAB_COUNT
"
)
.
add
(
tabCount
)
;
this
.
_lastRecordTabCount
=
currentTime
;
}
}
}
;
