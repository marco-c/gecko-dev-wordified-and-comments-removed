"
use
strict
"
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
var
EXPORTED_SYMBOLS
=
[
"
SiteDataManager
"
]
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gStringBundle
"
function
(
)
{
return
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
browser
/
locale
/
siteData
.
properties
"
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gBrandBundle
"
function
(
)
{
return
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
branding
/
locale
/
brand
.
properties
"
)
;
}
)
;
var
SiteDataManager
=
{
_appCache
:
Cc
[
"
mozilla
.
org
/
network
/
application
-
cache
-
service
;
1
"
]
.
getService
(
Ci
.
nsIApplicationCacheService
)
_sites
:
new
Map
(
)
_getCacheSizeObserver
:
null
_getCacheSizePromise
:
null
_getQuotaUsagePromise
:
null
_quotaUsageRequest
:
null
async
updateSites
(
)
{
Services
.
obs
.
notifyObservers
(
null
"
sitedatamanager
:
updating
-
sites
"
)
;
this
.
_sites
.
clear
(
)
;
this
.
_getAllCookies
(
)
;
await
this
.
_getQuotaUsage
(
)
;
this
.
_updateAppCache
(
)
;
Services
.
obs
.
notifyObservers
(
null
"
sitedatamanager
:
sites
-
updated
"
)
;
}
getBaseDomainFromHost
(
host
)
{
let
result
=
host
;
try
{
result
=
Services
.
eTLD
.
getBaseDomainFromHost
(
host
)
;
}
catch
(
e
)
{
if
(
e
.
result
=
=
Cr
.
NS_ERROR_HOST_IS_IP_ADDRESS
|
|
e
.
result
=
=
Cr
.
NS_ERROR_INSUFFICIENT_DOMAIN_LEVELS
)
{
result
=
host
;
}
else
{
throw
e
;
}
}
return
result
;
}
_getOrInsertSite
(
host
)
{
let
site
=
this
.
_sites
.
get
(
host
)
;
if
(
!
site
)
{
site
=
{
baseDomain
:
this
.
getBaseDomainFromHost
(
host
)
cookies
:
[
]
persisted
:
false
quotaUsage
:
0
lastAccessed
:
0
principals
:
[
]
appCacheList
:
[
]
}
;
this
.
_sites
.
set
(
host
site
)
;
}
return
site
;
}
getCacheSize
(
)
{
if
(
this
.
_getCacheSizePromise
)
{
return
this
.
_getCacheSizePromise
;
}
this
.
_getCacheSizePromise
=
new
Promise
(
(
resolve
reject
)
=
>
{
this
.
_getCacheSizeObserver
=
{
onNetworkCacheDiskConsumption
:
consumption
=
>
{
resolve
(
consumption
)
;
this
.
_getCacheSizePromise
=
null
;
this
.
_getCacheSizeObserver
=
null
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsICacheStorageConsumptionObserver
Ci
.
nsISupportsWeakReference
]
)
}
;
try
{
Services
.
cache2
.
asyncGetDiskConsumption
(
this
.
_getCacheSizeObserver
)
;
}
catch
(
e
)
{
reject
(
e
)
;
this
.
_getCacheSizePromise
=
null
;
this
.
_getCacheSizeObserver
=
null
;
}
}
)
;
return
this
.
_getCacheSizePromise
;
}
_getQuotaUsage
(
)
{
this
.
_cancelGetQuotaUsage
(
)
;
this
.
_getQuotaUsagePromise
=
new
Promise
(
resolve
=
>
{
let
onUsageResult
=
request
=
>
{
if
(
request
.
resultCode
=
=
Cr
.
NS_OK
)
{
let
items
=
request
.
result
;
for
(
let
item
of
items
)
{
if
(
!
item
.
persisted
&
&
item
.
usage
<
=
0
)
{
continue
;
}
let
principal
=
Services
.
scriptSecurityManager
.
createContentPrincipalFromOrigin
(
item
.
origin
)
;
let
uri
=
principal
.
URI
;
if
(
uri
.
scheme
=
=
"
http
"
|
|
uri
.
scheme
=
=
"
https
"
)
{
let
site
=
this
.
_getOrInsertSite
(
uri
.
host
)
;
if
(
item
.
persisted
)
{
site
.
persisted
=
true
;
}
if
(
site
.
lastAccessed
<
item
.
lastAccessed
)
{
site
.
lastAccessed
=
item
.
lastAccessed
;
}
site
.
principals
.
push
(
principal
)
;
site
.
quotaUsage
+
=
item
.
usage
;
}
}
}
resolve
(
)
;
}
;
this
.
_quotaUsageRequest
=
Services
.
qms
.
getUsage
(
onUsageResult
)
;
}
)
;
return
this
.
_getQuotaUsagePromise
;
}
_getAllCookies
(
)
{
for
(
let
cookie
of
Services
.
cookies
.
enumerator
)
{
let
site
=
this
.
_getOrInsertSite
(
cookie
.
rawHost
)
;
site
.
cookies
.
push
(
cookie
)
;
if
(
site
.
lastAccessed
<
cookie
.
lastAccessed
)
{
site
.
lastAccessed
=
cookie
.
lastAccessed
;
}
}
}
_cancelGetQuotaUsage
(
)
{
if
(
this
.
_quotaUsageRequest
)
{
this
.
_quotaUsageRequest
.
cancel
(
)
;
this
.
_quotaUsageRequest
=
null
;
}
}
_updateAppCache
(
)
{
let
groups
;
try
{
groups
=
this
.
_appCache
.
getGroups
(
)
;
}
catch
(
e
)
{
if
(
e
.
result
!
=
Cr
.
NS_ERROR_NOT_AVAILABLE
)
{
Cu
.
reportError
(
e
)
;
}
return
;
}
for
(
let
group
of
groups
)
{
let
cache
=
this
.
_appCache
.
getActiveCache
(
group
)
;
if
(
cache
.
usage
<
=
0
)
{
continue
;
}
let
principal
=
Services
.
scriptSecurityManager
.
createContentPrincipalFromOrigin
(
group
)
;
let
uri
=
principal
.
URI
;
let
site
=
this
.
_getOrInsertSite
(
uri
.
host
)
;
if
(
!
site
.
principals
.
some
(
p
=
>
p
.
origin
=
=
principal
.
origin
)
)
{
site
.
principals
.
push
(
principal
)
;
}
site
.
appCacheList
.
push
(
cache
)
;
}
}
getAppCacheUsageByHost
(
host
)
{
let
usage
=
0
;
let
groups
;
try
{
groups
=
this
.
_appCache
.
getGroups
(
)
;
}
catch
(
e
)
{
if
(
e
.
result
!
=
Cr
.
NS_ERROR_NOT_AVAILABLE
)
{
Cu
.
reportError
(
e
)
;
}
return
usage
;
}
for
(
let
group
of
groups
)
{
let
uri
=
Services
.
io
.
newURI
(
group
)
;
if
(
uri
.
asciiHost
=
=
host
)
{
let
cache
=
this
.
_appCache
.
getActiveCache
(
group
)
;
usage
+
=
cache
.
usage
;
}
}
return
usage
;
}
async
hasSiteData
(
asciiHost
)
{
if
(
Services
.
cookies
.
countCookiesFromHost
(
asciiHost
)
)
{
return
true
;
}
let
appCacheUsage
=
this
.
getAppCacheUsageByHost
(
asciiHost
)
;
if
(
appCacheUsage
>
0
)
{
return
true
;
}
let
hasQuota
=
await
new
Promise
(
resolve
=
>
{
Services
.
qms
.
getUsage
(
request
=
>
{
if
(
request
.
resultCode
!
=
Cr
.
NS_OK
)
{
resolve
(
false
)
;
return
;
}
for
(
let
item
of
request
.
result
)
{
if
(
!
item
.
persisted
&
&
item
.
usage
<
=
0
)
{
continue
;
}
let
principal
=
Services
.
scriptSecurityManager
.
createContentPrincipalFromOrigin
(
item
.
origin
)
;
if
(
principal
.
URI
.
asciiHost
=
=
asciiHost
)
{
resolve
(
true
)
;
return
;
}
}
resolve
(
false
)
;
}
)
;
}
)
;
if
(
hasQuota
)
{
return
true
;
}
return
false
;
}
getTotalUsage
(
)
{
return
this
.
_getQuotaUsagePromise
.
then
(
(
)
=
>
{
let
usage
=
0
;
for
(
let
site
of
this
.
_sites
.
values
(
)
)
{
for
(
let
cache
of
site
.
appCacheList
)
{
usage
+
=
cache
.
usage
;
}
usage
+
=
site
.
quotaUsage
;
}
return
usage
;
}
)
;
}
getSites
(
baseDomain
)
{
return
this
.
_getQuotaUsagePromise
.
then
(
(
)
=
>
{
let
list
=
[
]
;
for
(
let
[
host
site
]
of
this
.
_sites
)
{
if
(
baseDomain
&
&
site
.
baseDomain
!
=
baseDomain
)
{
continue
;
}
let
usage
=
site
.
quotaUsage
;
for
(
let
cache
of
site
.
appCacheList
)
{
usage
+
=
cache
.
usage
;
}
list
.
push
(
{
baseDomain
:
site
.
baseDomain
cookies
:
site
.
cookies
host
usage
persisted
:
site
.
persisted
lastAccessed
:
new
Date
(
site
.
lastAccessed
/
1000
)
}
)
;
}
return
list
;
}
)
;
}
_removePermission
(
site
)
{
let
removals
=
new
Set
(
)
;
for
(
let
principal
of
site
.
principals
)
{
let
{
originNoSuffix
}
=
principal
;
if
(
removals
.
has
(
originNoSuffix
)
)
{
continue
;
}
removals
.
add
(
originNoSuffix
)
;
Services
.
perms
.
removeFromPrincipal
(
principal
"
persistent
-
storage
"
)
;
}
}
_removeQuotaUsage
(
site
)
{
let
promises
=
[
]
;
let
removals
=
new
Set
(
)
;
for
(
let
principal
of
site
.
principals
)
{
let
{
originNoSuffix
}
=
principal
;
if
(
removals
.
has
(
originNoSuffix
)
)
{
continue
;
}
removals
.
add
(
originNoSuffix
)
;
promises
.
push
(
new
Promise
(
resolve
=
>
{
principal
=
Services
.
scriptSecurityManager
.
createContentPrincipalFromOrigin
(
originNoSuffix
)
;
let
request
=
this
.
_qms
.
clearStoragesForPrincipal
(
principal
null
null
true
)
;
request
.
callback
=
resolve
;
}
)
)
;
}
return
Promise
.
all
(
promises
)
;
}
_removeAppCache
(
site
)
{
for
(
let
cache
of
site
.
appCacheList
)
{
cache
.
discard
(
)
;
}
}
_removeCookies
(
site
)
{
for
(
let
cookie
of
site
.
cookies
)
{
Services
.
cookies
.
remove
(
cookie
.
host
cookie
.
name
cookie
.
path
cookie
.
originAttributes
)
;
}
site
.
cookies
=
[
]
;
}
_getDeletablePermissions
(
)
{
let
perms
=
[
]
;
for
(
let
permission
of
Services
.
perms
.
all
)
{
if
(
permission
.
type
=
=
"
persistent
-
storage
"
|
|
permission
.
type
=
=
"
storage
-
access
"
)
{
perms
.
push
(
permission
)
;
}
}
return
perms
;
}
async
remove
(
hosts
)
{
let
perms
=
this
.
_getDeletablePermissions
(
)
;
let
promises
=
[
]
;
for
(
let
host
of
hosts
)
{
const
kFlags
=
Ci
.
nsIClearDataService
.
CLEAR_COOKIES
|
Ci
.
nsIClearDataService
.
CLEAR_DOM_STORAGES
|
Ci
.
nsIClearDataService
.
CLEAR_SECURITY_SETTINGS
|
Ci
.
nsIClearDataService
.
CLEAR_PLUGIN_DATA
|
Ci
.
nsIClearDataService
.
CLEAR_EME
|
Ci
.
nsIClearDataService
.
CLEAR_ALL_CACHES
;
promises
.
push
(
new
Promise
(
function
(
resolve
)
{
const
{
clearData
}
=
Services
;
if
(
host
)
{
clearData
.
deleteDataFromHost
(
host
true
kFlags
resolve
)
;
}
else
{
clearData
.
deleteDataFromLocalFiles
(
true
kFlags
resolve
)
;
}
}
)
)
;
for
(
let
perm
of
perms
)
{
if
(
!
host
)
{
if
(
perm
.
principal
.
URI
.
schemeIs
(
"
file
"
)
)
{
Services
.
perms
.
removePermission
(
perm
)
;
}
}
else
if
(
Services
.
eTLD
.
hasRootDomain
(
perm
.
principal
.
URI
.
host
host
)
)
{
Services
.
perms
.
removePermission
(
perm
)
;
}
}
}
await
Promise
.
all
(
promises
)
;
return
this
.
updateSites
(
)
;
}
promptSiteDataRemoval
(
win
removals
)
{
if
(
removals
)
{
let
args
=
{
hosts
:
removals
allowed
:
false
}
;
let
features
=
"
centerscreen
chrome
modal
resizable
=
no
"
;
win
.
docShell
.
rootTreeItem
.
domWindow
.
openDialog
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
siteDataRemoveSelected
.
xul
"
"
"
features
args
)
;
return
args
.
allowed
;
}
let
brandName
=
gBrandBundle
.
GetStringFromName
(
"
brandShortName
"
)
;
let
flags
=
Services
.
prompt
.
BUTTON_TITLE_IS_STRING
*
Services
.
prompt
.
BUTTON_POS_0
+
Services
.
prompt
.
BUTTON_TITLE_CANCEL
*
Services
.
prompt
.
BUTTON_POS_1
+
Services
.
prompt
.
BUTTON_POS_0_DEFAULT
;
let
title
=
gStringBundle
.
GetStringFromName
(
"
clearSiteDataPromptTitle
"
)
;
let
text
=
gStringBundle
.
formatStringFromName
(
"
clearSiteDataPromptText
"
[
brandName
]
)
;
let
btn0Label
=
gStringBundle
.
GetStringFromName
(
"
clearSiteDataNow
"
)
;
let
result
=
Services
.
prompt
.
confirmEx
(
win
title
text
flags
btn0Label
null
null
null
{
}
)
;
return
result
=
=
0
;
}
async
removeAll
(
)
{
await
this
.
removeCache
(
)
;
return
this
.
removeSiteData
(
)
;
}
removeCache
(
)
{
return
new
Promise
(
function
(
resolve
)
{
Services
.
clearData
.
deleteData
(
Ci
.
nsIClearDataService
.
CLEAR_ALL_CACHES
resolve
)
;
}
)
;
}
async
removeSiteData
(
)
{
await
new
Promise
(
function
(
resolve
)
{
Services
.
clearData
.
deleteData
(
Ci
.
nsIClearDataService
.
CLEAR_COOKIES
|
Ci
.
nsIClearDataService
.
CLEAR_DOM_STORAGES
|
Ci
.
nsIClearDataService
.
CLEAR_SECURITY_SETTINGS
|
Ci
.
nsIClearDataService
.
CLEAR_EME
|
Ci
.
nsIClearDataService
.
CLEAR_PLUGIN_DATA
resolve
)
;
}
)
;
for
(
let
permission
of
this
.
_getDeletablePermissions
(
)
)
{
Services
.
perms
.
removePermission
(
permission
)
;
}
return
this
.
updateSites
(
)
;
}
}
;
