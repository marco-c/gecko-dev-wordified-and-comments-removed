"
use
strict
"
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
var
EXPORTED_SYMBOLS
=
[
"
SiteDataManager
"
]
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gStringBundle
"
function
(
)
{
return
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
browser
/
locale
/
siteData
.
properties
"
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gBrandBundle
"
function
(
)
{
return
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
branding
/
locale
/
brand
.
properties
"
)
;
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
gFirstPartyIsolateUseSite
"
"
privacy
.
firstparty
.
isolate
.
use_site
"
false
)
;
var
SiteDataManager
=
{
_sites
:
new
Map
(
)
_getCacheSizeObserver
:
null
_getCacheSizePromise
:
null
_getQuotaUsagePromise
:
null
_quotaUsageRequest
:
null
async
updateSites
(
entryUpdatedCallback
)
{
Services
.
obs
.
notifyObservers
(
null
"
sitedatamanager
:
updating
-
sites
"
)
;
this
.
_sites
.
clear
(
)
;
this
.
_getAllCookies
(
entryUpdatedCallback
)
;
await
this
.
_getQuotaUsage
(
entryUpdatedCallback
)
;
Services
.
obs
.
notifyObservers
(
null
"
sitedatamanager
:
sites
-
updated
"
)
;
}
getBaseDomainFromHost
(
host
)
{
let
result
=
host
;
try
{
result
=
Services
.
eTLD
.
getBaseDomainFromHost
(
host
)
;
}
catch
(
e
)
{
if
(
e
.
result
=
=
Cr
.
NS_ERROR_HOST_IS_IP_ADDRESS
|
|
e
.
result
=
=
Cr
.
NS_ERROR_INSUFFICIENT_DOMAIN_LEVELS
)
{
result
=
host
;
}
else
{
throw
e
;
}
}
return
result
;
}
_getOrInsertSite
(
baseDomainOrHost
)
{
let
site
=
this
.
_sites
.
get
(
baseDomainOrHost
)
;
if
(
!
site
)
{
site
=
{
baseDomainOrHost
cookies
:
[
]
persisted
:
false
quotaUsage
:
0
lastAccessed
:
0
principals
:
[
]
}
;
this
.
_sites
.
set
(
baseDomainOrHost
site
)
;
}
return
site
;
}
getCacheSize
(
)
{
if
(
this
.
_getCacheSizePromise
)
{
return
this
.
_getCacheSizePromise
;
}
this
.
_getCacheSizePromise
=
new
Promise
(
(
resolve
reject
)
=
>
{
this
.
_getCacheSizeObserver
=
{
onNetworkCacheDiskConsumption
:
consumption
=
>
{
resolve
(
consumption
)
;
this
.
_getCacheSizePromise
=
null
;
this
.
_getCacheSizeObserver
=
null
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsICacheStorageConsumptionObserver
"
"
nsISupportsWeakReference
"
]
)
}
;
try
{
Services
.
cache2
.
asyncGetDiskConsumption
(
this
.
_getCacheSizeObserver
)
;
}
catch
(
e
)
{
reject
(
e
)
;
this
.
_getCacheSizePromise
=
null
;
this
.
_getCacheSizeObserver
=
null
;
}
}
)
;
return
this
.
_getCacheSizePromise
;
}
_getBaseDomainFromPartitionKey
(
partitionKey
)
{
if
(
!
partitionKey
?
.
length
)
{
return
undefined
;
}
if
(
gFirstPartyIsolateUseSite
)
{
return
partitionKey
;
}
let
entries
=
partitionKey
.
substr
(
1
partitionKey
.
length
-
2
)
.
split
(
"
"
)
;
if
(
entries
.
length
<
2
)
{
return
undefined
;
}
return
entries
[
1
]
;
}
_getQuotaUsage
(
entryUpdatedCallback
)
{
this
.
_cancelGetQuotaUsage
(
)
;
this
.
_getQuotaUsagePromise
=
new
Promise
(
resolve
=
>
{
let
onUsageResult
=
request
=
>
{
if
(
request
.
resultCode
=
=
Cr
.
NS_OK
)
{
let
items
=
request
.
result
;
for
(
let
item
of
items
)
{
if
(
!
item
.
persisted
&
&
item
.
usage
<
=
0
)
{
continue
;
}
let
principal
=
Services
.
scriptSecurityManager
.
createContentPrincipalFromOrigin
(
item
.
origin
)
;
if
(
principal
.
schemeIs
(
"
http
"
)
|
|
principal
.
schemeIs
(
"
https
"
)
)
{
let
pkBaseDomain
=
this
.
_getBaseDomainFromPartitionKey
(
principal
.
originAttributes
.
partitionKey
)
;
let
site
=
this
.
_getOrInsertSite
(
pkBaseDomain
|
|
principal
.
baseDomain
)
;
if
(
item
.
persisted
)
{
site
.
persisted
=
true
;
}
if
(
site
.
lastAccessed
<
item
.
lastAccessed
)
{
site
.
lastAccessed
=
item
.
lastAccessed
;
}
site
.
principals
.
push
(
principal
)
;
site
.
quotaUsage
+
=
item
.
usage
;
if
(
entryUpdatedCallback
)
{
entryUpdatedCallback
(
principal
.
baseDomain
site
)
;
}
}
}
}
resolve
(
)
;
}
;
this
.
_quotaUsageRequest
=
Services
.
qms
.
getUsage
(
onUsageResult
)
;
}
)
;
return
this
.
_getQuotaUsagePromise
;
}
_getAllCookies
(
entryUpdatedCallback
)
{
for
(
let
cookie
of
Services
.
cookies
.
cookies
)
{
let
pkBaseDomain
=
this
.
_getBaseDomainFromPartitionKey
(
cookie
.
originAttributes
.
partitionKey
)
;
let
baseDomainOrHost
=
pkBaseDomain
|
|
this
.
getBaseDomainFromHost
(
cookie
.
rawHost
)
;
let
site
=
this
.
_getOrInsertSite
(
baseDomainOrHost
)
;
if
(
entryUpdatedCallback
)
{
entryUpdatedCallback
(
baseDomainOrHost
site
)
;
}
site
.
cookies
.
push
(
cookie
)
;
if
(
site
.
lastAccessed
<
cookie
.
lastAccessed
)
{
site
.
lastAccessed
=
cookie
.
lastAccessed
;
}
}
}
_cancelGetQuotaUsage
(
)
{
if
(
this
.
_quotaUsageRequest
)
{
this
.
_quotaUsageRequest
.
cancel
(
)
;
this
.
_quotaUsageRequest
=
null
;
}
}
async
hasSiteData
(
asciiHost
)
{
if
(
Services
.
cookies
.
countCookiesFromHost
(
asciiHost
)
)
{
return
true
;
}
let
hasQuota
=
await
new
Promise
(
resolve
=
>
{
Services
.
qms
.
getUsage
(
request
=
>
{
if
(
request
.
resultCode
!
=
Cr
.
NS_OK
)
{
resolve
(
false
)
;
return
;
}
for
(
let
item
of
request
.
result
)
{
if
(
!
item
.
persisted
&
&
item
.
usage
<
=
0
)
{
continue
;
}
let
principal
=
Services
.
scriptSecurityManager
.
createContentPrincipalFromOrigin
(
item
.
origin
)
;
if
(
principal
.
asciiHost
=
=
asciiHost
)
{
resolve
(
true
)
;
return
;
}
}
resolve
(
false
)
;
}
)
;
}
)
;
if
(
hasQuota
)
{
return
true
;
}
return
false
;
}
getTotalUsage
(
)
{
return
this
.
_getQuotaUsagePromise
.
then
(
(
)
=
>
{
let
usage
=
0
;
for
(
let
site
of
this
.
_sites
.
values
(
)
)
{
usage
+
=
site
.
quotaUsage
;
}
return
usage
;
}
)
;
}
async
getSites
(
)
{
await
this
.
_getQuotaUsagePromise
;
return
Array
.
from
(
this
.
_sites
.
values
(
)
)
.
map
(
site
=
>
(
{
baseDomain
:
site
.
baseDomainOrHost
cookies
:
site
.
cookies
usage
:
site
.
quotaUsage
persisted
:
site
.
persisted
lastAccessed
:
new
Date
(
site
.
lastAccessed
/
1000
)
}
)
)
;
}
async
getSite
(
baseDomainOrHost
)
{
let
baseDomain
=
this
.
getBaseDomainFromHost
(
baseDomainOrHost
)
;
let
site
=
this
.
_sites
.
get
(
baseDomain
)
;
if
(
!
site
)
{
return
null
;
}
return
{
baseDomain
:
site
.
baseDomainOrHost
cookies
:
site
.
cookies
usage
:
site
.
quotaUsage
persisted
:
site
.
persisted
lastAccessed
:
new
Date
(
site
.
lastAccessed
/
1000
)
}
;
}
_removePermission
(
site
)
{
let
removals
=
new
Set
(
)
;
for
(
let
principal
of
site
.
principals
)
{
let
{
originNoSuffix
}
=
principal
;
if
(
removals
.
has
(
originNoSuffix
)
)
{
continue
;
}
removals
.
add
(
originNoSuffix
)
;
Services
.
perms
.
removeFromPrincipal
(
principal
"
persistent
-
storage
"
)
;
}
}
_removeQuotaUsage
(
site
)
{
let
promises
=
[
]
;
let
removals
=
new
Set
(
)
;
for
(
let
principal
of
site
.
principals
)
{
let
{
originNoSuffix
}
=
principal
;
if
(
removals
.
has
(
originNoSuffix
)
)
{
continue
;
}
removals
.
add
(
originNoSuffix
)
;
promises
.
push
(
new
Promise
(
resolve
=
>
{
principal
=
Services
.
scriptSecurityManager
.
createContentPrincipalFromOrigin
(
originNoSuffix
)
;
let
request
=
this
.
_qms
.
clearStoragesForPrincipal
(
principal
null
null
true
)
;
request
.
callback
=
resolve
;
}
)
)
;
}
return
Promise
.
all
(
promises
)
;
}
_removeCookies
(
site
)
{
for
(
let
cookie
of
site
.
cookies
)
{
Services
.
cookies
.
remove
(
cookie
.
host
cookie
.
name
cookie
.
path
cookie
.
originAttributes
)
;
}
site
.
cookies
=
[
]
;
}
_getDeletablePermissions
(
)
{
let
perms
=
[
]
;
for
(
let
permission
of
Services
.
perms
.
all
)
{
if
(
permission
.
type
=
=
"
persistent
-
storage
"
|
|
permission
.
type
=
=
"
storage
-
access
"
)
{
perms
.
push
(
permission
)
;
}
}
return
perms
;
}
async
remove
(
domainsOrHosts
)
{
if
(
domainsOrHosts
=
=
null
)
{
throw
new
Error
(
"
domainsOrHosts
is
required
.
"
)
;
}
if
(
!
Array
.
isArray
(
domainsOrHosts
)
)
{
domainsOrHosts
=
[
domainsOrHosts
]
;
}
let
perms
=
this
.
_getDeletablePermissions
(
)
;
let
promises
=
[
]
;
for
(
let
domainOrHost
of
domainsOrHosts
)
{
const
kFlags
=
Ci
.
nsIClearDataService
.
CLEAR_COOKIES
|
Ci
.
nsIClearDataService
.
CLEAR_DOM_STORAGES
|
Ci
.
nsIClearDataService
.
CLEAR_SECURITY_SETTINGS
|
Ci
.
nsIClearDataService
.
CLEAR_EME
|
Ci
.
nsIClearDataService
.
CLEAR_ALL_CACHES
;
promises
.
push
(
new
Promise
(
function
(
resolve
)
{
const
{
clearData
}
=
Services
;
if
(
domainOrHost
)
{
try
{
clearData
.
deleteDataFromBaseDomain
(
domainOrHost
true
kFlags
resolve
)
;
}
catch
(
e
)
{
if
(
e
.
result
!
=
Cr
.
NS_ERROR_HOST_IS_IP_ADDRESS
&
&
e
.
result
!
=
Cr
.
NS_ERROR_INSUFFICIENT_DOMAIN_LEVELS
)
{
throw
e
;
}
clearData
.
deleteDataFromHost
(
domainOrHost
true
kFlags
resolve
)
;
}
}
else
{
clearData
.
deleteDataFromLocalFiles
(
true
kFlags
resolve
)
;
}
}
)
)
;
for
(
let
perm
of
perms
)
{
if
(
!
domainOrHost
)
{
if
(
perm
.
principal
.
schemeIs
(
"
file
"
)
)
{
Services
.
perms
.
removePermission
(
perm
)
;
}
}
else
if
(
Services
.
eTLD
.
hasRootDomain
(
perm
.
principal
.
host
domainOrHost
)
)
{
Services
.
perms
.
removePermission
(
perm
)
;
}
}
}
await
Promise
.
all
(
promises
)
;
return
this
.
updateSites
(
)
;
}
promptSiteDataRemoval
(
win
removals
)
{
if
(
removals
)
{
let
args
=
{
hosts
:
removals
allowed
:
false
}
;
let
features
=
"
centerscreen
chrome
modal
resizable
=
no
"
;
win
.
browsingContext
.
topChromeWindow
.
openDialog
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
dialogs
/
siteDataRemoveSelected
.
xhtml
"
"
"
features
args
)
;
return
args
.
allowed
;
}
let
brandName
=
gBrandBundle
.
GetStringFromName
(
"
brandShortName
"
)
;
let
flags
=
Services
.
prompt
.
BUTTON_TITLE_IS_STRING
*
Services
.
prompt
.
BUTTON_POS_0
+
Services
.
prompt
.
BUTTON_TITLE_CANCEL
*
Services
.
prompt
.
BUTTON_POS_1
+
Services
.
prompt
.
BUTTON_POS_0_DEFAULT
;
let
title
=
gStringBundle
.
GetStringFromName
(
"
clearSiteDataPromptTitle
"
)
;
let
text
=
gStringBundle
.
formatStringFromName
(
"
clearSiteDataPromptText
"
[
brandName
]
)
;
let
btn0Label
=
gStringBundle
.
GetStringFromName
(
"
clearSiteDataNow
"
)
;
let
result
=
Services
.
prompt
.
confirmEx
(
win
title
text
flags
btn0Label
null
null
null
{
}
)
;
return
result
=
=
0
;
}
async
removeAll
(
)
{
await
this
.
removeCache
(
)
;
return
this
.
removeSiteData
(
)
;
}
removeCache
(
)
{
return
new
Promise
(
function
(
resolve
)
{
Services
.
clearData
.
deleteData
(
Ci
.
nsIClearDataService
.
CLEAR_ALL_CACHES
resolve
)
;
}
)
;
}
async
removeSiteData
(
)
{
await
new
Promise
(
function
(
resolve
)
{
Services
.
clearData
.
deleteData
(
Ci
.
nsIClearDataService
.
CLEAR_COOKIES
|
Ci
.
nsIClearDataService
.
CLEAR_DOM_STORAGES
|
Ci
.
nsIClearDataService
.
CLEAR_SECURITY_SETTINGS
|
Ci
.
nsIClearDataService
.
CLEAR_EME
resolve
)
;
}
)
;
for
(
let
permission
of
this
.
_getDeletablePermissions
(
)
)
{
Services
.
perms
.
removePermission
(
permission
)
;
}
return
this
.
updateSites
(
)
;
}
}
;
