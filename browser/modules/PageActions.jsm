"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
PageActions
"
]
;
const
{
utils
:
Cu
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
AppConstants
"
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
BinarySearch
"
"
resource
:
/
/
gre
/
modules
/
BinarySearch
.
jsm
"
)
;
const
ACTION_ID_BOOKMARK
=
"
bookmark
"
;
const
ACTION_ID_BOOKMARK_SEPARATOR
=
"
bookmarkSeparator
"
;
const
ACTION_ID_BUILT_IN_SEPARATOR
=
"
builtInSeparator
"
;
const
PREF_PERSISTED_ACTIONS
=
"
browser
.
pageActions
.
persistedActions
"
;
const
PERSISTED_ACTIONS_CURRENT_VERSION
=
1
this
.
PageActions
=
{
init
(
)
{
let
callbacks
=
this
.
_deferredAddActionCalls
;
delete
this
.
_deferredAddActionCalls
;
this
.
_loadPersistedActions
(
)
;
for
(
let
options
of
gBuiltInActions
)
{
if
(
!
this
.
actionForID
(
options
.
id
)
)
{
this
.
_registerAction
(
new
Action
(
options
)
)
;
}
}
for
(
let
bpa
of
allBrowserPageActions
(
)
)
{
bpa
.
placeAllActions
(
)
;
}
while
(
callbacks
&
&
callbacks
.
length
)
{
callbacks
.
shift
(
)
(
)
;
}
}
_deferredAddActionCalls
:
[
]
get
actions
(
)
{
let
actions
=
this
.
builtInActions
;
if
(
this
.
nonBuiltInActions
.
length
)
{
if
(
actions
.
length
)
{
actions
.
push
(
new
Action
(
{
id
:
ACTION_ID_BUILT_IN_SEPARATOR
_isSeparator
:
true
}
)
)
;
}
actions
.
push
(
.
.
.
this
.
nonBuiltInActions
)
;
}
return
actions
;
}
get
builtInActions
(
)
{
return
this
.
_builtInActions
.
slice
(
)
;
}
get
nonBuiltInActions
(
)
{
return
this
.
_nonBuiltInActions
.
slice
(
)
;
}
get
actionsInUrlbar
(
)
{
return
this
.
_persistedActions
.
idsInUrlbar
.
reduce
(
(
actions
id
)
=
>
{
let
action
=
this
.
actionForID
(
id
)
;
if
(
action
)
{
actions
.
push
(
action
)
;
}
return
actions
;
}
[
]
)
;
}
actionForID
(
id
)
{
return
this
.
_actionsByID
.
get
(
id
)
;
}
addAction
(
action
)
{
if
(
this
.
_deferredAddActionCalls
)
{
this
.
_deferredAddActionCalls
.
push
(
(
)
=
>
this
.
addAction
(
action
)
)
;
return
action
;
}
let
hadSep
=
this
.
actions
.
some
(
a
=
>
a
.
id
=
=
ACTION_ID_BUILT_IN_SEPARATOR
)
;
this
.
_registerAction
(
action
)
;
let
sep
=
null
;
if
(
!
hadSep
)
{
sep
=
this
.
actions
.
find
(
a
=
>
a
.
id
=
=
ACTION_ID_BUILT_IN_SEPARATOR
)
;
}
for
(
let
bpa
of
allBrowserPageActions
(
)
)
{
if
(
sep
)
{
bpa
.
placeAction
(
sep
)
;
}
bpa
.
placeAction
(
action
)
;
}
return
action
;
}
_registerAction
(
action
)
{
if
(
this
.
actionForID
(
action
.
id
)
)
{
throw
new
Error
(
Action
with
ID
'
{
action
.
id
}
'
already
added
)
;
}
this
.
_actionsByID
.
set
(
action
.
id
action
)
;
if
(
"
__insertBeforeActionID
"
in
action
)
{
let
index
=
!
action
.
__insertBeforeActionID
?
-
1
:
this
.
_builtInActions
.
findIndex
(
a
=
>
{
return
a
.
id
=
=
action
.
__insertBeforeActionID
;
}
)
;
if
(
index
<
0
)
{
index
=
this
.
_builtInActions
.
length
;
}
this
.
_builtInActions
.
splice
(
index
0
action
)
;
}
else
if
(
gBuiltInActions
.
find
(
a
=
>
a
.
id
=
=
action
.
id
)
)
{
this
.
_builtInActions
.
push
(
action
)
;
}
else
{
let
index
=
BinarySearch
.
insertionIndexOf
(
(
a1
a2
)
=
>
{
return
a1
.
title
.
localeCompare
(
a2
.
title
)
;
}
this
.
_nonBuiltInActions
action
)
;
this
.
_nonBuiltInActions
.
splice
(
index
0
action
)
;
}
if
(
this
.
_persistedActions
.
ids
.
includes
(
action
.
id
)
)
{
action
.
_shownInUrlbar
=
this
.
_persistedActions
.
idsInUrlbar
.
includes
(
action
.
id
)
;
}
else
{
this
.
_persistedActions
.
ids
.
push
(
action
.
id
)
;
this
.
_updateIDsInUrlbarForAction
(
action
)
;
}
}
_updateIDsInUrlbarForAction
(
action
)
{
let
index
=
this
.
_persistedActions
.
idsInUrlbar
.
indexOf
(
action
.
id
)
;
if
(
action
.
shownInUrlbar
)
{
if
(
index
<
0
)
{
let
nextID
=
this
.
nextActionIDInUrlbar
(
action
.
id
)
;
let
nextIndex
=
nextID
?
this
.
_persistedActions
.
idsInUrlbar
.
indexOf
(
nextID
)
:
-
1
;
if
(
nextIndex
<
0
)
{
nextIndex
=
this
.
_persistedActions
.
idsInUrlbar
.
length
;
}
this
.
_persistedActions
.
idsInUrlbar
.
splice
(
nextIndex
0
action
.
id
)
;
}
}
else
if
(
index
>
=
0
)
{
this
.
_persistedActions
.
idsInUrlbar
.
splice
(
index
1
)
;
}
this
.
_storePersistedActions
(
)
;
}
_builtInActions
:
[
]
_nonBuiltInActions
:
[
]
_actionsByID
:
new
Map
(
)
nextActionIDInUrlbar
(
action
)
{
if
(
action
.
id
=
=
ACTION_ID_BOOKMARK
)
{
return
null
;
}
let
id
=
this
.
_nextActionID
(
action
this
.
actionsInUrlbar
)
;
return
id
|
|
ACTION_ID_BOOKMARK
;
}
nextActionIDInPanel
(
action
)
{
return
this
.
_nextActionID
(
action
this
.
actions
)
;
}
_nextActionID
(
action
actionArray
)
{
let
index
=
actionArray
.
findIndex
(
a
=
>
a
.
id
=
=
action
.
id
)
;
if
(
index
<
0
)
{
return
null
;
}
let
nextAction
=
actionArray
[
index
+
1
]
;
if
(
!
nextAction
)
{
return
null
;
}
return
nextAction
.
id
;
}
onActionRemoved
(
action
)
{
if
(
!
this
.
actionForID
(
action
.
id
)
)
{
return
;
}
this
.
_actionsByID
.
delete
(
action
.
id
)
;
for
(
let
list
of
[
this
.
_nonBuiltInActions
this
.
_builtInActions
]
)
{
let
index
=
list
.
findIndex
(
a
=
>
a
.
id
=
=
action
.
id
)
;
if
(
index
>
=
0
)
{
list
.
splice
(
index
1
)
;
break
;
}
}
for
(
let
name
of
[
"
ids
"
"
idsInUrlbar
"
]
)
{
let
array
=
this
.
_persistedActions
[
name
]
;
let
index
=
array
.
indexOf
(
action
.
id
)
;
if
(
index
>
=
0
)
{
array
.
splice
(
index
1
)
;
}
}
this
.
_storePersistedActions
(
)
;
for
(
let
bpa
of
allBrowserPageActions
(
)
)
{
bpa
.
removeAction
(
action
)
;
}
}
onActionSetIconURL
(
action
)
{
if
(
!
this
.
actionForID
(
action
.
id
)
)
{
return
;
}
for
(
let
bpa
of
allBrowserPageActions
(
)
)
{
bpa
.
updateActionIconURL
(
action
)
;
}
}
onActionSetTitle
(
action
)
{
if
(
!
this
.
actionForID
(
action
.
id
)
)
{
return
;
}
for
(
let
bpa
of
allBrowserPageActions
(
)
)
{
bpa
.
updateActionTitle
(
action
)
;
}
}
onActionToggledShownInUrlbar
(
action
)
{
if
(
!
this
.
actionForID
(
action
.
id
)
)
{
return
;
}
this
.
_updateIDsInUrlbarForAction
(
action
)
;
for
(
let
bpa
of
allBrowserPageActions
(
)
)
{
bpa
.
placeActionInUrlbar
(
action
)
;
}
}
logTelemetry
(
type
action
node
=
null
)
{
const
kAllowedLabels
=
[
"
pocket
"
"
screenshots
"
"
webcompat
"
]
.
concat
(
gBuiltInActions
.
filter
(
a
=
>
!
a
.
__isSeparator
)
.
map
(
a
=
>
a
.
id
)
)
;
if
(
type
=
=
"
used
"
)
{
type
=
(
node
&
&
node
.
closest
(
"
#
urlbar
-
container
"
)
)
?
"
urlbar_used
"
:
"
panel_used
"
;
}
let
histogramID
=
"
FX_PAGE_ACTION_
"
+
type
.
toUpperCase
(
)
;
try
{
let
histogram
=
Services
.
telemetry
.
getHistogramById
(
histogramID
)
;
if
(
kAllowedLabels
.
includes
(
action
.
labelForHistogram
)
)
{
histogram
.
add
(
action
.
labelForHistogram
)
;
}
else
{
histogram
.
add
(
"
other
"
)
;
}
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
}
_storePersistedActions
(
)
{
let
json
=
JSON
.
stringify
(
this
.
_persistedActions
)
;
Services
.
prefs
.
setStringPref
(
PREF_PERSISTED_ACTIONS
json
)
;
}
_loadPersistedActions
(
)
{
try
{
let
json
=
Services
.
prefs
.
getStringPref
(
PREF_PERSISTED_ACTIONS
)
;
this
.
_persistedActions
=
this
.
_migratePersistedActions
(
JSON
.
parse
(
json
)
)
;
}
catch
(
ex
)
{
}
}
_migratePersistedActions
(
actions
)
{
for
(
let
version
=
actions
.
version
|
|
0
;
version
<
PERSISTED_ACTIONS_CURRENT_VERSION
;
version
+
+
)
{
let
methodName
=
_migratePersistedActionsTo
{
version
+
1
}
;
actions
=
this
[
methodName
]
(
actions
)
;
actions
.
version
=
version
+
1
;
}
return
actions
;
}
_migratePersistedActionsTo1
(
actions
)
{
let
ids
=
[
]
;
for
(
let
id
in
actions
.
ids
)
{
ids
.
push
(
id
)
;
}
let
bookmarkIndex
=
actions
.
idsInUrlbar
.
indexOf
(
ACTION_ID_BOOKMARK
)
;
if
(
bookmarkIndex
>
=
0
)
{
actions
.
idsInUrlbar
.
splice
(
bookmarkIndex
1
)
;
actions
.
idsInUrlbar
.
push
(
ACTION_ID_BOOKMARK
)
;
}
return
{
ids
idsInUrlbar
:
actions
.
idsInUrlbar
}
;
}
_persistedActions
:
{
version
:
PERSISTED_ACTIONS_CURRENT_VERSION
ids
:
[
]
idsInUrlbar
:
[
]
}
}
;
function
Action
(
options
)
{
setProperties
(
this
options
{
id
:
true
title
:
!
options
.
_isSeparator
anchorIDOverride
:
false
iconURL
:
false
labelForHistogram
:
false
nodeAttributes
:
false
onBeforePlacedInWindow
:
false
onCommand
:
false
onIframeHiding
:
false
onIframeHidden
:
false
onIframeShown
:
false
onPlacedInPanel
:
false
onPlacedInUrlbar
:
false
onShowingInPanel
:
false
shownInUrlbar
:
false
subview
:
false
tooltip
:
false
urlbarIDOverride
:
false
wantsIframe
:
false
_insertBeforeActionID
:
false
_isSeparator
:
false
_urlbarNodeInMarkup
:
false
}
)
;
if
(
this
.
_subview
)
{
this
.
_subview
=
new
Subview
(
options
.
subview
)
;
}
}
Action
.
prototype
=
{
get
iconURL
(
)
{
return
this
.
_iconURL
;
}
set
iconURL
(
url
)
{
this
.
_iconURL
=
url
;
PageActions
.
onActionSetIconURL
(
this
)
;
return
this
.
_iconURL
;
}
get
id
(
)
{
return
this
.
_id
;
}
get
nodeAttributes
(
)
{
return
this
.
_nodeAttributes
;
}
get
shownInUrlbar
(
)
{
return
this
.
_shownInUrlbar
|
|
false
;
}
set
shownInUrlbar
(
shown
)
{
if
(
this
.
shownInUrlbar
!
=
shown
)
{
this
.
_shownInUrlbar
=
shown
;
PageActions
.
onActionToggledShownInUrlbar
(
this
)
;
}
return
this
.
shownInUrlbar
;
}
get
title
(
)
{
return
this
.
_title
;
}
set
title
(
title
)
{
this
.
_title
=
title
|
|
"
"
;
PageActions
.
onActionSetTitle
(
this
)
;
return
this
.
_title
;
}
get
tooltip
(
)
{
return
this
.
_tooltip
;
}
get
anchorIDOverride
(
)
{
return
this
.
_anchorIDOverride
;
}
get
urlbarIDOverride
(
)
{
return
this
.
_urlbarIDOverride
;
}
get
wantsIframe
(
)
{
return
this
.
_wantsIframe
|
|
false
;
}
get
subview
(
)
{
return
this
.
_subview
;
}
get
labelForHistogram
(
)
{
return
this
.
_labelForHistogram
|
|
this
.
_id
;
}
doCommand
(
browserWindow
)
{
browserPageActions
(
browserWindow
)
.
doCommandForAction
(
this
)
;
}
onBeforePlacedInWindow
(
browserWindow
)
{
if
(
this
.
_onBeforePlacedInWindow
)
{
this
.
_onBeforePlacedInWindow
(
browserWindow
)
;
}
}
onCommand
(
event
buttonNode
)
{
if
(
this
.
_onCommand
)
{
this
.
_onCommand
(
event
buttonNode
)
;
}
}
onIframeHiding
(
iframeNode
parentPanelNode
)
{
if
(
this
.
_onIframeHiding
)
{
this
.
_onIframeHiding
(
iframeNode
parentPanelNode
)
;
}
}
onIframeHidden
(
iframeNode
parentPanelNode
)
{
if
(
this
.
_onIframeHidden
)
{
this
.
_onIframeHidden
(
iframeNode
parentPanelNode
)
;
}
}
onIframeShown
(
iframeNode
parentPanelNode
)
{
if
(
this
.
_onIframeShown
)
{
this
.
_onIframeShown
(
iframeNode
parentPanelNode
)
;
}
}
onPlacedInPanel
(
buttonNode
)
{
if
(
this
.
_onPlacedInPanel
)
{
this
.
_onPlacedInPanel
(
buttonNode
)
;
}
}
onPlacedInUrlbar
(
buttonNode
)
{
if
(
this
.
_onPlacedInUrlbar
)
{
this
.
_onPlacedInUrlbar
(
buttonNode
)
;
}
}
onShowingInPanel
(
buttonNode
)
{
if
(
this
.
_onShowingInPanel
)
{
this
.
_onShowingInPanel
(
buttonNode
)
;
}
}
remove
(
)
{
PageActions
.
onActionRemoved
(
this
)
;
}
}
;
this
.
PageActions
.
Action
=
Action
;
function
Subview
(
options
)
{
setProperties
(
this
options
{
buttons
:
false
onPlaced
:
false
onShowing
:
false
}
)
;
this
.
_buttons
=
(
this
.
_buttons
|
|
[
]
)
.
map
(
buttonOptions
=
>
{
return
new
Button
(
buttonOptions
)
;
}
)
;
}
Subview
.
prototype
=
{
get
buttons
(
)
{
return
this
.
_buttons
;
}
onPlaced
(
panelViewNode
)
{
if
(
this
.
_onPlaced
)
{
this
.
_onPlaced
(
panelViewNode
)
;
}
}
onShowing
(
panelViewNode
)
{
if
(
this
.
_onShowing
)
{
this
.
_onShowing
(
panelViewNode
)
;
}
}
}
;
this
.
PageActions
.
Subview
=
Subview
;
function
Button
(
options
)
{
setProperties
(
this
options
{
id
:
true
title
:
true
disabled
:
false
onCommand
:
false
shortcut
:
false
}
)
;
}
Button
.
prototype
=
{
get
disabled
(
)
{
return
this
.
_disabled
|
|
false
;
}
get
id
(
)
{
return
this
.
_id
;
}
get
shortcut
(
)
{
return
this
.
_shortcut
;
}
get
title
(
)
{
return
this
.
_title
;
}
onCommand
(
event
buttonNode
)
{
if
(
this
.
_onCommand
)
{
this
.
_onCommand
(
event
buttonNode
)
;
}
}
}
;
this
.
PageActions
.
Button
=
Button
;
this
.
PageActions
.
ACTION_ID_BOOKMARK
=
ACTION_ID_BOOKMARK
;
this
.
PageActions
.
ACTION_ID_BOOKMARK_SEPARATOR
=
ACTION_ID_BOOKMARK_SEPARATOR
;
this
.
PageActions
.
PREF_PERSISTED_ACTIONS
=
PREF_PERSISTED_ACTIONS
;
this
.
PageActions
.
ACTION_ID_BUILT_IN_SEPARATOR
=
ACTION_ID_BUILT_IN_SEPARATOR
;
var
gBuiltInActions
=
[
{
id
:
ACTION_ID_BOOKMARK
urlbarIDOverride
:
"
star
-
button
-
box
"
_urlbarNodeInMarkup
:
true
title
:
"
"
shownInUrlbar
:
true
nodeAttributes
:
{
observes
:
"
bookmarkThisPageBroadcaster
"
}
onShowingInPanel
(
buttonNode
)
{
browserPageActions
(
buttonNode
)
.
bookmark
.
onShowingInPanel
(
buttonNode
)
;
}
onCommand
(
event
buttonNode
)
{
browserPageActions
(
buttonNode
)
.
bookmark
.
onCommand
(
event
buttonNode
)
;
}
}
{
id
:
ACTION_ID_BOOKMARK_SEPARATOR
_isSeparator
:
true
}
{
id
:
"
copyURL
"
title
:
"
copyURL
-
title
"
onPlacedInPanel
(
buttonNode
)
{
browserPageActions
(
buttonNode
)
.
copyURL
.
onPlacedInPanel
(
buttonNode
)
;
}
onCommand
(
event
buttonNode
)
{
browserPageActions
(
buttonNode
)
.
copyURL
.
onCommand
(
event
buttonNode
)
;
}
}
{
id
:
"
emailLink
"
title
:
"
emailLink
-
title
"
onPlacedInPanel
(
buttonNode
)
{
browserPageActions
(
buttonNode
)
.
emailLink
.
onPlacedInPanel
(
buttonNode
)
;
}
onCommand
(
event
buttonNode
)
{
browserPageActions
(
buttonNode
)
.
emailLink
.
onCommand
(
event
buttonNode
)
;
}
}
{
id
:
"
sendToDevice
"
title
:
"
sendToDevice
-
title
"
onPlacedInPanel
(
buttonNode
)
{
browserPageActions
(
buttonNode
)
.
sendToDevice
.
onPlacedInPanel
(
buttonNode
)
;
}
onShowingInPanel
(
buttonNode
)
{
browserPageActions
(
buttonNode
)
.
sendToDevice
.
onShowingInPanel
(
buttonNode
)
;
}
subview
:
{
buttons
:
[
{
id
:
"
notReady
"
title
:
"
sendToDevice
-
notReadyTitle
"
disabled
:
true
}
]
onPlaced
(
panelViewNode
)
{
browserPageActions
(
panelViewNode
)
.
sendToDevice
.
onSubviewPlaced
(
panelViewNode
)
;
}
onShowing
(
panelViewNode
)
{
browserPageActions
(
panelViewNode
)
.
sendToDevice
.
onShowingSubview
(
panelViewNode
)
;
}
}
}
]
;
function
browserPageActions
(
obj
)
{
if
(
obj
.
BrowserPageActions
)
{
return
obj
.
BrowserPageActions
;
}
return
obj
.
ownerGlobal
.
BrowserPageActions
;
}
function
*
allBrowserWindows
(
)
{
let
windows
=
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
;
while
(
windows
.
hasMoreElements
(
)
)
{
yield
windows
.
getNext
(
)
;
}
}
function
*
allBrowserPageActions
(
)
{
for
(
let
win
of
allBrowserWindows
(
)
)
{
yield
browserPageActions
(
win
)
;
}
}
function
setProperties
(
obj
options
schema
)
{
for
(
let
name
in
schema
)
{
let
required
=
schema
[
name
]
;
if
(
required
&
&
!
(
name
in
options
)
)
{
throw
new
Error
(
'
{
name
}
'
must
be
specified
)
;
}
let
nameInObj
=
"
_
"
+
name
;
if
(
name
[
0
]
=
=
"
_
"
)
{
if
(
name
in
options
)
{
obj
[
nameInObj
]
=
options
[
name
]
;
}
}
else
{
obj
[
nameInObj
]
=
options
[
name
]
|
|
null
;
}
}
for
(
let
name
in
options
)
{
if
(
!
(
name
in
schema
)
)
{
throw
new
Error
(
Unrecognized
option
'
{
name
}
'
)
;
}
}
}
