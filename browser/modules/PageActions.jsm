"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
PageActions
"
]
;
const
{
utils
:
Cu
}
=
Components
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
AppConstants
"
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
AsyncShutdown
"
"
resource
:
/
/
gre
/
modules
/
AsyncShutdown
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
BinarySearch
"
"
resource
:
/
/
gre
/
modules
/
BinarySearch
.
jsm
"
)
;
const
ACTION_ID_BOOKMARK
=
"
bookmark
"
;
const
ACTION_ID_BOOKMARK_SEPARATOR
=
"
bookmarkSeparator
"
;
const
ACTION_ID_BUILT_IN_SEPARATOR
=
"
builtInSeparator
"
;
const
PREF_PERSISTED_ACTIONS
=
"
browser
.
pageActions
.
persistedActions
"
;
const
PERSISTED_ACTIONS_CURRENT_VERSION
=
1
;
this
.
PageActions
=
{
init
(
)
{
let
callbacks
=
this
.
_deferredAddActionCalls
;
delete
this
.
_deferredAddActionCalls
;
this
.
_loadPersistedActions
(
)
;
for
(
let
options
of
gBuiltInActions
)
{
if
(
!
this
.
actionForID
(
options
.
id
)
)
{
this
.
_registerAction
(
new
Action
(
options
)
)
;
}
}
for
(
let
bpa
of
allBrowserPageActions
(
)
)
{
bpa
.
placeAllActions
(
)
;
}
while
(
callbacks
&
&
callbacks
.
length
)
{
callbacks
.
shift
(
)
(
)
;
}
AsyncShutdown
.
profileBeforeChange
.
addBlocker
(
"
PageActions
:
purging
unregistered
actions
from
cache
"
(
)
=
>
this
.
_purgeUnregisteredPersistedActions
(
)
)
;
}
_deferredAddActionCalls
:
[
]
get
actions
(
)
{
let
actions
=
this
.
builtInActions
;
if
(
this
.
nonBuiltInActions
.
length
)
{
if
(
actions
.
length
)
{
actions
.
push
(
new
Action
(
{
id
:
ACTION_ID_BUILT_IN_SEPARATOR
_isSeparator
:
true
}
)
)
;
}
actions
.
push
(
.
.
.
this
.
nonBuiltInActions
)
;
}
return
actions
;
}
get
builtInActions
(
)
{
return
this
.
_builtInActions
.
slice
(
)
;
}
get
nonBuiltInActions
(
)
{
return
this
.
_nonBuiltInActions
.
slice
(
)
;
}
actionsInUrlbar
(
browserWindow
)
{
return
this
.
_persistedActions
.
idsInUrlbar
.
reduce
(
(
actions
id
)
=
>
{
let
action
=
this
.
actionForID
(
id
)
;
if
(
action
&
&
action
.
shouldShowInUrlbar
(
browserWindow
)
)
{
actions
.
push
(
action
)
;
}
return
actions
;
}
[
]
)
;
}
actionForID
(
id
)
{
return
this
.
_actionsByID
.
get
(
id
)
;
}
addAction
(
action
)
{
if
(
this
.
_deferredAddActionCalls
)
{
this
.
_deferredAddActionCalls
.
push
(
(
)
=
>
this
.
addAction
(
action
)
)
;
return
action
;
}
let
hadSep
=
this
.
actions
.
some
(
a
=
>
a
.
id
=
=
ACTION_ID_BUILT_IN_SEPARATOR
)
;
this
.
_registerAction
(
action
)
;
let
sep
=
null
;
if
(
!
hadSep
)
{
sep
=
this
.
actions
.
find
(
a
=
>
a
.
id
=
=
ACTION_ID_BUILT_IN_SEPARATOR
)
;
}
for
(
let
bpa
of
allBrowserPageActions
(
)
)
{
if
(
sep
)
{
bpa
.
placeAction
(
sep
)
;
}
bpa
.
placeAction
(
action
)
;
}
return
action
;
}
_registerAction
(
action
)
{
if
(
this
.
actionForID
(
action
.
id
)
)
{
throw
new
Error
(
Action
with
ID
'
{
action
.
id
}
'
already
added
)
;
}
this
.
_actionsByID
.
set
(
action
.
id
action
)
;
if
(
"
__insertBeforeActionID
"
in
action
)
{
let
index
=
!
action
.
__insertBeforeActionID
?
-
1
:
this
.
_builtInActions
.
findIndex
(
a
=
>
{
return
a
.
id
=
=
action
.
__insertBeforeActionID
;
}
)
;
if
(
index
<
0
)
{
index
=
this
.
_builtInActions
.
length
;
}
this
.
_builtInActions
.
splice
(
index
0
action
)
;
}
else
if
(
gBuiltInActions
.
find
(
a
=
>
a
.
id
=
=
action
.
id
)
)
{
this
.
_builtInActions
.
push
(
action
)
;
}
else
{
let
index
=
BinarySearch
.
insertionIndexOf
(
(
a1
a2
)
=
>
{
return
a1
.
getTitle
(
)
.
localeCompare
(
a2
.
getTitle
(
)
)
;
}
this
.
_nonBuiltInActions
action
)
;
this
.
_nonBuiltInActions
.
splice
(
index
0
action
)
;
}
if
(
this
.
_persistedActions
.
ids
.
includes
(
action
.
id
)
)
{
action
.
_pinnedToUrlbar
=
this
.
_persistedActions
.
idsInUrlbar
.
includes
(
action
.
id
)
;
}
else
{
this
.
_persistedActions
.
ids
.
push
(
action
.
id
)
;
this
.
_updateIDsPinnedToUrlbarForAction
(
action
)
;
}
}
_updateIDsPinnedToUrlbarForAction
(
action
)
{
let
index
=
this
.
_persistedActions
.
idsInUrlbar
.
indexOf
(
action
.
id
)
;
if
(
action
.
pinnedToUrlbar
)
{
if
(
index
<
0
)
{
index
=
action
.
id
=
=
ACTION_ID_BOOKMARK
?
-
1
:
this
.
_persistedActions
.
idsInUrlbar
.
indexOf
(
ACTION_ID_BOOKMARK
)
;
if
(
index
<
0
)
{
index
=
this
.
_persistedActions
.
idsInUrlbar
.
length
;
}
this
.
_persistedActions
.
idsInUrlbar
.
splice
(
index
0
action
.
id
)
;
}
}
else
if
(
index
>
=
0
)
{
this
.
_persistedActions
.
idsInUrlbar
.
splice
(
index
1
)
;
}
this
.
_storePersistedActions
(
)
;
}
_builtInActions
:
[
]
_nonBuiltInActions
:
[
]
_actionsByID
:
new
Map
(
)
nextActionIDInUrlbar
(
browserWindow
action
)
{
if
(
action
.
id
=
=
ACTION_ID_BOOKMARK
)
{
return
null
;
}
let
id
=
this
.
_nextActionID
(
action
this
.
actionsInUrlbar
(
browserWindow
)
)
;
return
id
|
|
ACTION_ID_BOOKMARK
;
}
nextActionIDInPanel
(
action
)
{
return
this
.
_nextActionID
(
action
this
.
actions
)
;
}
_nextActionID
(
action
actionArray
)
{
let
index
=
actionArray
.
findIndex
(
a
=
>
a
.
id
=
=
action
.
id
)
;
if
(
index
<
0
)
{
return
null
;
}
let
nextAction
=
actionArray
[
index
+
1
]
;
if
(
!
nextAction
)
{
return
null
;
}
return
nextAction
.
id
;
}
onActionRemoved
(
action
)
{
if
(
!
this
.
actionForID
(
action
.
id
)
)
{
return
;
}
this
.
_actionsByID
.
delete
(
action
.
id
)
;
for
(
let
list
of
[
this
.
_nonBuiltInActions
this
.
_builtInActions
]
)
{
let
index
=
list
.
findIndex
(
a
=
>
a
.
id
=
=
action
.
id
)
;
if
(
index
>
=
0
)
{
list
.
splice
(
index
1
)
;
break
;
}
}
for
(
let
bpa
of
allBrowserPageActions
(
)
)
{
bpa
.
removeAction
(
action
)
;
}
}
onActionToggledPinnedToUrlbar
(
action
)
{
if
(
!
this
.
actionForID
(
action
.
id
)
)
{
return
;
}
this
.
_updateIDsPinnedToUrlbarForAction
(
action
)
;
for
(
let
bpa
of
allBrowserPageActions
(
)
)
{
bpa
.
placeActionInUrlbar
(
action
)
;
}
}
logTelemetry
(
type
action
node
=
null
)
{
if
(
type
=
=
"
used
"
)
{
type
=
node
&
&
node
.
closest
(
"
#
urlbar
-
container
"
)
?
"
urlbar_used
"
:
"
panel_used
"
;
}
let
histogramID
=
"
FX_PAGE_ACTION_
"
+
type
.
toUpperCase
(
)
;
try
{
let
histogram
=
Services
.
telemetry
.
getHistogramById
(
histogramID
)
;
if
(
action
.
_isBuiltIn
)
{
histogram
.
add
(
action
.
labelForHistogram
)
;
}
else
{
histogram
.
add
(
"
other
"
)
;
}
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
}
_reset
(
)
{
PageActions
.
_purgeUnregisteredPersistedActions
(
)
;
PageActions
.
_builtInActions
=
[
]
;
PageActions
.
_nonBuiltInActions
=
[
]
;
PageActions
.
_actionsByID
=
new
Map
(
)
;
}
_storePersistedActions
(
)
{
let
json
=
JSON
.
stringify
(
this
.
_persistedActions
)
;
Services
.
prefs
.
setStringPref
(
PREF_PERSISTED_ACTIONS
json
)
;
}
_loadPersistedActions
(
)
{
try
{
let
json
=
Services
.
prefs
.
getStringPref
(
PREF_PERSISTED_ACTIONS
)
;
this
.
_persistedActions
=
this
.
_migratePersistedActions
(
JSON
.
parse
(
json
)
)
;
}
catch
(
ex
)
{
}
}
_purgeUnregisteredPersistedActions
(
)
{
for
(
let
name
of
[
"
ids
"
"
idsInUrlbar
"
]
)
{
this
.
_persistedActions
[
name
]
=
this
.
_persistedActions
[
name
]
.
filter
(
id
=
>
{
return
this
.
actionForID
(
id
)
;
}
)
;
}
this
.
_storePersistedActions
(
)
;
}
_migratePersistedActions
(
actions
)
{
for
(
let
version
=
actions
.
version
|
|
0
;
version
<
PERSISTED_ACTIONS_CURRENT_VERSION
;
version
+
+
)
{
let
methodName
=
_migratePersistedActionsTo
{
version
+
1
}
;
actions
=
this
[
methodName
]
(
actions
)
;
actions
.
version
=
version
+
1
;
}
return
actions
;
}
_migratePersistedActionsTo1
(
actions
)
{
let
ids
=
[
]
;
for
(
let
id
in
actions
.
ids
)
{
ids
.
push
(
id
)
;
}
let
bookmarkIndex
=
actions
.
idsInUrlbar
.
indexOf
(
ACTION_ID_BOOKMARK
)
;
if
(
bookmarkIndex
>
=
0
)
{
actions
.
idsInUrlbar
.
splice
(
bookmarkIndex
1
)
;
actions
.
idsInUrlbar
.
push
(
ACTION_ID_BOOKMARK
)
;
}
return
{
ids
idsInUrlbar
:
actions
.
idsInUrlbar
}
;
}
_persistedActions
:
{
version
:
PERSISTED_ACTIONS_CURRENT_VERSION
ids
:
[
]
idsInUrlbar
:
[
]
}
}
;
function
Action
(
options
)
{
setProperties
(
this
options
{
id
:
true
title
:
!
options
.
_isSeparator
anchorIDOverride
:
false
disabled
:
false
extensionID
:
false
iconURL
:
false
labelForHistogram
:
false
nodeAttributes
:
false
onBeforePlacedInWindow
:
false
onCommand
:
false
onIframeHiding
:
false
onIframeHidden
:
false
onIframeShowing
:
false
onLocationChange
:
false
onPlacedInPanel
:
false
onPlacedInUrlbar
:
false
onRemovedFromWindow
:
false
onShowingInPanel
:
false
pinnedToUrlbar
:
false
subview
:
false
tooltip
:
false
urlbarIDOverride
:
false
wantsIframe
:
false
_insertBeforeActionID
:
false
_isSeparator
:
false
_urlbarNodeInMarkup
:
false
}
)
;
if
(
this
.
_subview
)
{
this
.
_subview
=
new
Subview
(
options
.
subview
)
;
}
}
Action
.
prototype
=
{
get
extensionID
(
)
{
return
this
.
_extensionID
;
}
get
id
(
)
{
return
this
.
_id
;
}
get
nodeAttributes
(
)
{
return
this
.
_nodeAttributes
;
}
get
pinnedToUrlbar
(
)
{
return
this
.
_pinnedToUrlbar
|
|
false
;
}
set
pinnedToUrlbar
(
shown
)
{
if
(
this
.
pinnedToUrlbar
!
=
shown
)
{
this
.
_pinnedToUrlbar
=
shown
;
PageActions
.
onActionToggledPinnedToUrlbar
(
this
)
;
}
return
this
.
pinnedToUrlbar
;
}
getDisabled
(
browserWindow
=
null
)
{
return
!
!
this
.
_getProperty
(
"
disabled
"
browserWindow
)
;
}
setDisabled
(
value
browserWindow
=
null
)
{
return
this
.
_setProperty
(
"
disabled
"
!
!
value
browserWindow
)
;
}
getIconURL
(
browserWindow
=
null
)
{
return
this
.
_getProperty
(
"
iconURL
"
browserWindow
)
;
}
setIconURL
(
value
browserWindow
=
null
)
{
return
this
.
_setProperty
(
"
iconURL
"
value
browserWindow
)
;
}
getTitle
(
browserWindow
=
null
)
{
return
this
.
_getProperty
(
"
title
"
browserWindow
)
;
}
setTitle
(
value
browserWindow
=
null
)
{
return
this
.
_setProperty
(
"
title
"
value
browserWindow
)
;
}
getTooltip
(
browserWindow
=
null
)
{
return
this
.
_getProperty
(
"
tooltip
"
browserWindow
)
;
}
setTooltip
(
value
browserWindow
=
null
)
{
return
this
.
_setProperty
(
"
tooltip
"
value
browserWindow
)
;
}
_setProperty
(
name
value
browserWindow
)
{
if
(
!
browserWindow
)
{
this
[
_
{
name
}
]
=
value
;
}
else
{
let
props
=
this
.
_propertiesByBrowserWindow
.
get
(
browserWindow
)
;
if
(
!
props
)
{
props
=
{
}
;
this
.
_propertiesByBrowserWindow
.
set
(
browserWindow
props
)
;
}
props
[
name
]
=
value
;
}
if
(
PageActions
.
actionForID
(
this
.
id
)
)
{
for
(
let
bpa
of
allBrowserPageActions
(
browserWindow
)
)
{
bpa
.
updateAction
(
this
name
)
;
}
}
return
value
;
}
_getProperty
(
name
browserWindow
)
{
if
(
browserWindow
)
{
let
props
=
this
.
_propertiesByBrowserWindow
.
get
(
browserWindow
)
;
if
(
props
&
&
name
in
props
)
{
return
props
[
name
]
;
}
}
return
this
[
_
{
name
}
]
;
}
get
_propertiesByBrowserWindow
(
)
{
if
(
!
this
.
__propertiesByBrowserWindow
)
{
this
.
__propertiesByBrowserWindow
=
new
WeakMap
(
)
;
}
return
this
.
__propertiesByBrowserWindow
;
}
get
anchorIDOverride
(
)
{
return
this
.
_anchorIDOverride
;
}
get
urlbarIDOverride
(
)
{
return
this
.
_urlbarIDOverride
;
}
get
wantsIframe
(
)
{
return
this
.
_wantsIframe
|
|
false
;
}
get
subview
(
)
{
return
this
.
_subview
;
}
get
labelForHistogram
(
)
{
return
this
.
_labelForHistogram
|
|
this
.
_id
;
}
iconURLForSize
(
preferredSize
browserWindow
)
{
let
iconURL
=
this
.
getIconURL
(
browserWindow
)
;
if
(
!
iconURL
)
{
return
null
;
}
if
(
typeof
(
iconURL
)
=
=
"
string
"
)
{
return
iconURL
;
}
if
(
typeof
(
iconURL
)
=
=
"
object
"
)
{
let
bestSize
=
null
;
if
(
iconURL
[
preferredSize
]
)
{
bestSize
=
preferredSize
;
}
else
if
(
iconURL
[
2
*
preferredSize
]
)
{
bestSize
=
2
*
preferredSize
;
}
else
{
let
sizes
=
Object
.
keys
(
iconURL
)
.
map
(
key
=
>
parseInt
(
key
10
)
)
.
sort
(
(
a
b
)
=
>
a
-
b
)
;
bestSize
=
sizes
.
find
(
candidate
=
>
candidate
>
preferredSize
)
|
|
sizes
.
pop
(
)
;
}
return
iconURL
[
bestSize
]
;
}
return
null
;
}
doCommand
(
browserWindow
)
{
browserPageActions
(
browserWindow
)
.
doCommandForAction
(
this
)
;
}
onBeforePlacedInWindow
(
browserWindow
)
{
if
(
this
.
_onBeforePlacedInWindow
)
{
this
.
_onBeforePlacedInWindow
(
browserWindow
)
;
}
}
onCommand
(
event
buttonNode
)
{
if
(
this
.
_onCommand
)
{
this
.
_onCommand
(
event
buttonNode
)
;
}
}
onIframeHiding
(
iframeNode
parentPanelNode
)
{
if
(
this
.
_onIframeHiding
)
{
this
.
_onIframeHiding
(
iframeNode
parentPanelNode
)
;
}
}
onIframeHidden
(
iframeNode
parentPanelNode
)
{
if
(
this
.
_onIframeHidden
)
{
this
.
_onIframeHidden
(
iframeNode
parentPanelNode
)
;
}
}
onIframeShowing
(
iframeNode
parentPanelNode
)
{
if
(
this
.
_onIframeShowing
)
{
this
.
_onIframeShowing
(
iframeNode
parentPanelNode
)
;
}
}
onLocationChange
(
browserWindow
)
{
if
(
this
.
_onLocationChange
)
{
this
.
_onLocationChange
(
browserWindow
)
;
}
}
onPlacedInPanel
(
buttonNode
)
{
if
(
this
.
_onPlacedInPanel
)
{
this
.
_onPlacedInPanel
(
buttonNode
)
;
}
}
onPlacedInUrlbar
(
buttonNode
)
{
if
(
this
.
_onPlacedInUrlbar
)
{
this
.
_onPlacedInUrlbar
(
buttonNode
)
;
}
}
onRemovedFromWindow
(
browserWindow
)
{
if
(
this
.
_onRemovedFromWindow
)
{
this
.
_onRemovedFromWindow
(
browserWindow
)
;
}
}
onShowingInPanel
(
buttonNode
)
{
if
(
this
.
_onShowingInPanel
)
{
this
.
_onShowingInPanel
(
buttonNode
)
;
}
}
remove
(
)
{
PageActions
.
onActionRemoved
(
this
)
;
}
shouldShowInUrlbar
(
browserWindow
)
{
return
this
.
pinnedToUrlbar
&
&
!
this
.
getDisabled
(
browserWindow
)
;
}
get
_isBuiltIn
(
)
{
let
builtInIDs
=
[
"
pocket
"
"
screenshots
"
"
webcompat
-
reporter
-
button
"
]
.
concat
(
gBuiltInActions
.
filter
(
a
=
>
!
a
.
__isSeparator
)
.
map
(
a
=
>
a
.
id
)
)
;
return
builtInIDs
.
includes
(
this
.
id
)
;
}
}
;
this
.
PageActions
.
Action
=
Action
;
function
Subview
(
options
)
{
setProperties
(
this
options
{
buttons
:
false
onPlaced
:
false
onShowing
:
false
}
)
;
this
.
_buttons
=
(
this
.
_buttons
|
|
[
]
)
.
map
(
buttonOptions
=
>
{
return
new
Button
(
buttonOptions
)
;
}
)
;
}
Subview
.
prototype
=
{
get
buttons
(
)
{
return
this
.
_buttons
;
}
onPlaced
(
panelViewNode
)
{
if
(
this
.
_onPlaced
)
{
this
.
_onPlaced
(
panelViewNode
)
;
}
}
onShowing
(
panelViewNode
)
{
if
(
this
.
_onShowing
)
{
this
.
_onShowing
(
panelViewNode
)
;
}
}
}
;
this
.
PageActions
.
Subview
=
Subview
;
function
Button
(
options
)
{
setProperties
(
this
options
{
id
:
true
title
:
true
disabled
:
false
onCommand
:
false
shortcut
:
false
}
)
;
}
Button
.
prototype
=
{
get
disabled
(
)
{
return
this
.
_disabled
|
|
false
;
}
get
id
(
)
{
return
this
.
_id
;
}
get
shortcut
(
)
{
return
this
.
_shortcut
;
}
get
title
(
)
{
return
this
.
_title
;
}
onCommand
(
event
buttonNode
)
{
if
(
this
.
_onCommand
)
{
this
.
_onCommand
(
event
buttonNode
)
;
}
}
}
;
this
.
PageActions
.
Button
=
Button
;
this
.
PageActions
.
ACTION_ID_BOOKMARK
=
ACTION_ID_BOOKMARK
;
this
.
PageActions
.
ACTION_ID_BOOKMARK_SEPARATOR
=
ACTION_ID_BOOKMARK_SEPARATOR
;
this
.
PageActions
.
PREF_PERSISTED_ACTIONS
=
PREF_PERSISTED_ACTIONS
;
this
.
PageActions
.
ACTION_ID_BUILT_IN_SEPARATOR
=
ACTION_ID_BUILT_IN_SEPARATOR
;
var
gBuiltInActions
=
[
{
id
:
ACTION_ID_BOOKMARK
urlbarIDOverride
:
"
star
-
button
-
box
"
_urlbarNodeInMarkup
:
true
title
:
"
"
pinnedToUrlbar
:
true
nodeAttributes
:
{
observes
:
"
bookmarkThisPageBroadcaster
"
}
onShowingInPanel
(
buttonNode
)
{
browserPageActions
(
buttonNode
)
.
bookmark
.
onShowingInPanel
(
buttonNode
)
;
}
onCommand
(
event
buttonNode
)
{
browserPageActions
(
buttonNode
)
.
bookmark
.
onCommand
(
event
buttonNode
)
;
}
}
{
id
:
ACTION_ID_BOOKMARK_SEPARATOR
_isSeparator
:
true
}
{
id
:
"
copyURL
"
title
:
"
copyURL
-
title
"
onPlacedInPanel
(
buttonNode
)
{
browserPageActions
(
buttonNode
)
.
copyURL
.
onPlacedInPanel
(
buttonNode
)
;
}
onCommand
(
event
buttonNode
)
{
browserPageActions
(
buttonNode
)
.
copyURL
.
onCommand
(
event
buttonNode
)
;
}
}
{
id
:
"
emailLink
"
title
:
"
emailLink
-
title
"
onPlacedInPanel
(
buttonNode
)
{
browserPageActions
(
buttonNode
)
.
emailLink
.
onPlacedInPanel
(
buttonNode
)
;
}
onCommand
(
event
buttonNode
)
{
browserPageActions
(
buttonNode
)
.
emailLink
.
onCommand
(
event
buttonNode
)
;
}
}
{
id
:
"
sendToDevice
"
title
:
"
sendToDevice
-
title
"
onPlacedInPanel
(
buttonNode
)
{
browserPageActions
(
buttonNode
)
.
sendToDevice
.
onPlacedInPanel
(
buttonNode
)
;
}
onLocationChange
(
browserWindow
)
{
browserPageActions
(
browserWindow
)
.
sendToDevice
.
onLocationChange
(
)
;
}
subview
:
{
buttons
:
[
{
id
:
"
notReady
"
title
:
"
sendToDevice
-
notReadyTitle
"
disabled
:
true
}
]
onPlaced
(
panelViewNode
)
{
browserPageActions
(
panelViewNode
)
.
sendToDevice
.
onSubviewPlaced
(
panelViewNode
)
;
}
onShowing
(
panelViewNode
)
{
browserPageActions
(
panelViewNode
)
.
sendToDevice
.
onShowingSubview
(
panelViewNode
)
;
}
}
}
]
;
function
browserPageActions
(
obj
)
{
if
(
obj
.
BrowserPageActions
)
{
return
obj
.
BrowserPageActions
;
}
return
obj
.
ownerGlobal
.
BrowserPageActions
;
}
function
*
allBrowserWindows
(
browserWindow
=
null
)
{
if
(
browserWindow
)
{
yield
browserWindow
;
return
;
}
let
windows
=
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
;
while
(
windows
.
hasMoreElements
(
)
)
{
yield
windows
.
getNext
(
)
;
}
}
function
*
allBrowserPageActions
(
browserWindow
=
null
)
{
for
(
let
win
of
allBrowserWindows
(
browserWindow
)
)
{
yield
browserPageActions
(
win
)
;
}
}
function
setProperties
(
obj
options
schema
)
{
for
(
let
name
in
schema
)
{
let
required
=
schema
[
name
]
;
if
(
required
&
&
!
(
name
in
options
)
)
{
throw
new
Error
(
'
{
name
}
'
must
be
specified
)
;
}
let
nameInObj
=
"
_
"
+
name
;
if
(
name
[
0
]
=
=
"
_
"
)
{
if
(
name
in
options
)
{
obj
[
nameInObj
]
=
options
[
name
]
;
}
}
else
{
obj
[
nameInObj
]
=
options
[
name
]
|
|
null
;
}
}
for
(
let
name
in
options
)
{
if
(
!
(
name
in
schema
)
)
{
throw
new
Error
(
Unrecognized
option
'
{
name
}
'
)
;
}
}
}
