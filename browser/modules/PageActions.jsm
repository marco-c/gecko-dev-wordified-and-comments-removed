"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
PageActions
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
AppConstants
"
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
AsyncShutdown
"
"
resource
:
/
/
gre
/
modules
/
AsyncShutdown
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
BinarySearch
"
"
resource
:
/
/
gre
/
modules
/
BinarySearch
.
jsm
"
)
;
const
ACTION_ID_BOOKMARK
=
"
bookmark
"
;
const
ACTION_ID_BOOKMARK_SEPARATOR
=
"
bookmarkSeparator
"
;
const
ACTION_ID_BUILT_IN_SEPARATOR
=
"
builtInSeparator
"
;
const
ACTION_ID_TRANSIENT_SEPARATOR
=
"
transientSeparator
"
;
const
PREF_PERSISTED_ACTIONS
=
"
browser
.
pageActions
.
persistedActions
"
;
const
PERSISTED_ACTIONS_CURRENT_VERSION
=
1
;
function
escapeCSSURL
(
url
)
{
return
url
(
"
{
url
.
replace
(
/
[
\
\
\
s
"
]
/
g
encodeURIComponent
)
}
"
)
;
}
var
PageActions
=
{
init
(
)
{
let
callbacks
=
this
.
_deferredAddActionCalls
;
delete
this
.
_deferredAddActionCalls
;
this
.
_loadPersistedActions
(
)
;
for
(
let
options
of
gBuiltInActions
)
{
if
(
!
this
.
actionForID
(
options
.
id
)
)
{
this
.
_registerAction
(
new
Action
(
options
)
)
;
}
}
for
(
let
bpa
of
allBrowserPageActions
(
)
)
{
bpa
.
placeAllActions
(
)
;
}
while
(
callbacks
&
&
callbacks
.
length
)
{
callbacks
.
shift
(
)
(
)
;
}
AsyncShutdown
.
profileBeforeChange
.
addBlocker
(
"
PageActions
:
purging
unregistered
actions
from
cache
"
(
)
=
>
this
.
_purgeUnregisteredPersistedActions
(
)
)
;
}
_deferredAddActionCalls
:
[
]
get
actions
(
)
{
let
lists
=
[
this
.
_builtInActions
this
.
_nonBuiltInActions
this
.
_transientActions
]
;
return
lists
.
reduce
(
(
memo
list
)
=
>
memo
.
concat
(
list
)
[
]
)
;
}
actionsInPanel
(
browserWindow
)
{
function
filter
(
action
)
{
return
action
.
shouldShowInPanel
(
browserWindow
)
;
}
let
actions
=
this
.
_builtInActions
.
filter
(
filter
)
;
let
nonBuiltInActions
=
this
.
_nonBuiltInActions
.
filter
(
filter
)
;
if
(
nonBuiltInActions
.
length
)
{
if
(
actions
.
length
)
{
actions
.
push
(
new
Action
(
{
id
:
ACTION_ID_BUILT_IN_SEPARATOR
_isSeparator
:
true
}
)
)
;
}
actions
.
push
(
.
.
.
nonBuiltInActions
)
;
}
let
transientActions
=
this
.
_transientActions
.
filter
(
filter
)
;
if
(
transientActions
.
length
)
{
if
(
actions
.
length
)
{
actions
.
push
(
new
Action
(
{
id
:
ACTION_ID_TRANSIENT_SEPARATOR
_isSeparator
:
true
}
)
)
;
}
actions
.
push
(
.
.
.
transientActions
)
;
}
return
actions
;
}
actionsInUrlbar
(
browserWindow
)
{
return
this
.
_persistedActions
.
idsInUrlbar
.
reduce
(
(
actions
id
)
=
>
{
let
action
=
this
.
actionForID
(
id
)
;
if
(
action
&
&
action
.
shouldShowInUrlbar
(
browserWindow
)
)
{
actions
.
push
(
action
)
;
}
return
actions
;
}
[
]
)
;
}
actionForID
(
id
)
{
return
this
.
_actionsByID
.
get
(
id
)
;
}
addAction
(
action
)
{
if
(
this
.
_deferredAddActionCalls
)
{
this
.
_deferredAddActionCalls
.
push
(
(
)
=
>
this
.
addAction
(
action
)
)
;
return
action
;
}
this
.
_registerAction
(
action
)
;
for
(
let
bpa
of
allBrowserPageActions
(
)
)
{
bpa
.
placeAction
(
action
)
;
}
return
action
;
}
_registerAction
(
action
)
{
if
(
this
.
actionForID
(
action
.
id
)
)
{
throw
new
Error
(
Action
with
ID
'
{
action
.
id
}
'
already
added
)
;
}
this
.
_actionsByID
.
set
(
action
.
id
action
)
;
if
(
"
__insertBeforeActionID
"
in
action
)
{
let
index
=
!
action
.
__insertBeforeActionID
?
-
1
:
this
.
_builtInActions
.
findIndex
(
a
=
>
{
return
a
.
id
=
=
action
.
__insertBeforeActionID
;
}
)
;
if
(
index
<
0
)
{
index
=
this
.
_builtInActions
.
filter
(
a
=
>
!
a
.
__transient
)
.
length
;
}
this
.
_builtInActions
.
splice
(
index
0
action
)
;
}
else
if
(
action
.
__transient
)
{
this
.
_transientActions
.
push
(
action
)
;
}
else
if
(
gBuiltInActions
.
find
(
a
=
>
a
.
id
=
=
action
.
id
)
)
{
this
.
_builtInActions
.
push
(
action
)
;
}
else
{
let
index
=
BinarySearch
.
insertionIndexOf
(
(
a1
a2
)
=
>
{
return
a1
.
getTitle
(
)
.
localeCompare
(
a2
.
getTitle
(
)
)
;
}
this
.
_nonBuiltInActions
action
)
;
this
.
_nonBuiltInActions
.
splice
(
index
0
action
)
;
}
if
(
this
.
_persistedActions
.
ids
.
includes
(
action
.
id
)
)
{
action
.
_pinnedToUrlbar
=
this
.
_persistedActions
.
idsInUrlbar
.
includes
(
action
.
id
)
;
}
else
{
this
.
_persistedActions
.
ids
.
push
(
action
.
id
)
;
this
.
_updateIDsPinnedToUrlbarForAction
(
action
)
;
}
}
_updateIDsPinnedToUrlbarForAction
(
action
)
{
let
index
=
this
.
_persistedActions
.
idsInUrlbar
.
indexOf
(
action
.
id
)
;
if
(
action
.
pinnedToUrlbar
)
{
if
(
index
<
0
)
{
index
=
action
.
id
=
=
ACTION_ID_BOOKMARK
?
-
1
:
this
.
_persistedActions
.
idsInUrlbar
.
indexOf
(
ACTION_ID_BOOKMARK
)
;
if
(
index
<
0
)
{
index
=
this
.
_persistedActions
.
idsInUrlbar
.
length
;
}
this
.
_persistedActions
.
idsInUrlbar
.
splice
(
index
0
action
.
id
)
;
}
}
else
if
(
index
>
=
0
)
{
this
.
_persistedActions
.
idsInUrlbar
.
splice
(
index
1
)
;
}
this
.
_storePersistedActions
(
)
;
}
_builtInActions
:
[
]
_nonBuiltInActions
:
[
]
_transientActions
:
[
]
_actionsByID
:
new
Map
(
)
onActionRemoved
(
action
)
{
if
(
!
this
.
actionForID
(
action
.
id
)
)
{
return
;
}
this
.
_actionsByID
.
delete
(
action
.
id
)
;
let
lists
=
[
this
.
_builtInActions
this
.
_nonBuiltInActions
this
.
_transientActions
]
;
for
(
let
list
of
lists
)
{
let
index
=
list
.
findIndex
(
a
=
>
a
.
id
=
=
action
.
id
)
;
if
(
index
>
=
0
)
{
list
.
splice
(
index
1
)
;
break
;
}
}
for
(
let
bpa
of
allBrowserPageActions
(
)
)
{
bpa
.
removeAction
(
action
)
;
}
}
onActionToggledPinnedToUrlbar
(
action
)
{
if
(
!
this
.
actionForID
(
action
.
id
)
)
{
return
;
}
this
.
_updateIDsPinnedToUrlbarForAction
(
action
)
;
for
(
let
bpa
of
allBrowserPageActions
(
)
)
{
bpa
.
placeActionInUrlbar
(
action
)
;
}
}
logTelemetry
(
type
action
node
=
null
)
{
if
(
type
=
=
"
used
"
)
{
type
=
node
&
&
node
.
closest
(
"
#
urlbar
-
container
"
)
?
"
urlbar_used
"
:
"
panel_used
"
;
}
let
histogramID
=
"
FX_PAGE_ACTION_
"
+
type
.
toUpperCase
(
)
;
try
{
let
histogram
=
Services
.
telemetry
.
getHistogramById
(
histogramID
)
;
if
(
action
.
_isBuiltIn
)
{
histogram
.
add
(
action
.
labelForHistogram
)
;
}
else
{
histogram
.
add
(
"
other
"
)
;
}
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
}
_reset
(
)
{
PageActions
.
_purgeUnregisteredPersistedActions
(
)
;
PageActions
.
_builtInActions
=
[
]
;
PageActions
.
_nonBuiltInActions
=
[
]
;
PageActions
.
_transientActions
=
[
]
;
PageActions
.
_actionsByID
=
new
Map
(
)
;
}
_storePersistedActions
(
)
{
let
json
=
JSON
.
stringify
(
this
.
_persistedActions
)
;
Services
.
prefs
.
setStringPref
(
PREF_PERSISTED_ACTIONS
json
)
;
}
_loadPersistedActions
(
)
{
try
{
let
json
=
Services
.
prefs
.
getStringPref
(
PREF_PERSISTED_ACTIONS
)
;
this
.
_persistedActions
=
this
.
_migratePersistedActions
(
JSON
.
parse
(
json
)
)
;
}
catch
(
ex
)
{
}
}
_purgeUnregisteredPersistedActions
(
)
{
for
(
let
name
of
[
"
ids
"
"
idsInUrlbar
"
]
)
{
this
.
_persistedActions
[
name
]
=
this
.
_persistedActions
[
name
]
.
filter
(
id
=
>
{
return
this
.
actionForID
(
id
)
;
}
)
;
}
this
.
_storePersistedActions
(
)
;
}
_migratePersistedActions
(
actions
)
{
for
(
let
version
=
actions
.
version
|
|
0
;
version
<
PERSISTED_ACTIONS_CURRENT_VERSION
;
version
+
+
)
{
let
methodName
=
_migratePersistedActionsTo
{
version
+
1
}
;
actions
=
this
[
methodName
]
(
actions
)
;
actions
.
version
=
version
+
1
;
}
return
actions
;
}
_migratePersistedActionsTo1
(
actions
)
{
let
ids
=
[
]
;
for
(
let
id
in
actions
.
ids
)
{
ids
.
push
(
id
)
;
}
let
bookmarkIndex
=
actions
.
idsInUrlbar
.
indexOf
(
ACTION_ID_BOOKMARK
)
;
if
(
bookmarkIndex
>
=
0
)
{
actions
.
idsInUrlbar
.
splice
(
bookmarkIndex
1
)
;
actions
.
idsInUrlbar
.
push
(
ACTION_ID_BOOKMARK
)
;
}
return
{
ids
idsInUrlbar
:
actions
.
idsInUrlbar
}
;
}
_persistedActions
:
{
version
:
PERSISTED_ACTIONS_CURRENT_VERSION
ids
:
[
]
idsInUrlbar
:
[
]
}
}
;
function
Action
(
options
)
{
setProperties
(
this
options
{
id
:
true
title
:
!
options
.
_isSeparator
anchorIDOverride
:
false
disabled
:
false
extensionID
:
false
iconURL
:
false
labelForHistogram
:
false
nodeAttributes
:
false
onBeforePlacedInWindow
:
false
onCommand
:
false
onIframeHiding
:
false
onIframeHidden
:
false
onIframeShowing
:
false
onLocationChange
:
false
onPlacedInPanel
:
false
onPlacedInUrlbar
:
false
onRemovedFromWindow
:
false
onShowingInPanel
:
false
onSubviewPlaced
:
false
onSubviewShowing
:
false
pinnedToUrlbar
:
false
tooltip
:
false
urlbarIDOverride
:
false
wantsIframe
:
false
wantsSubview
:
false
_insertBeforeActionID
:
false
_isSeparator
:
false
_transient
:
false
_urlbarNodeInMarkup
:
false
}
)
;
this
.
_iconProperties
=
new
WeakMap
(
)
;
this
.
_globalProps
=
{
disabled
:
this
.
_disabled
iconURL
:
this
.
_iconURL
iconProps
:
this
.
_createIconProperties
(
this
.
_iconURL
)
title
:
this
.
_title
tooltip
:
this
.
_tooltip
wantsSubview
:
this
.
_wantsSubview
}
;
this
.
_windowProps
=
new
WeakMap
(
)
;
}
Action
.
prototype
=
{
get
extensionID
(
)
{
return
this
.
_extensionID
;
}
get
id
(
)
{
return
this
.
_id
;
}
get
nodeAttributes
(
)
{
return
this
.
_nodeAttributes
;
}
get
pinnedToUrlbar
(
)
{
return
this
.
_pinnedToUrlbar
|
|
false
;
}
set
pinnedToUrlbar
(
shown
)
{
if
(
this
.
pinnedToUrlbar
!
=
shown
)
{
this
.
_pinnedToUrlbar
=
shown
;
PageActions
.
onActionToggledPinnedToUrlbar
(
this
)
;
}
return
this
.
pinnedToUrlbar
;
}
getDisabled
(
browserWindow
=
null
)
{
return
!
!
this
.
_getProperties
(
browserWindow
)
.
disabled
;
}
setDisabled
(
value
browserWindow
=
null
)
{
return
this
.
_setProperty
(
"
disabled
"
!
!
value
browserWindow
)
;
}
getIconURL
(
browserWindow
=
null
)
{
return
this
.
_getProperties
(
browserWindow
)
.
iconURL
;
}
setIconURL
(
value
browserWindow
=
null
)
{
let
props
=
this
.
_getProperties
(
browserWindow
!
!
browserWindow
)
;
props
.
iconURL
=
value
;
props
.
iconProps
=
this
.
_createIconProperties
(
value
)
;
this
.
_updateProperty
(
"
iconURL
"
props
.
iconProps
browserWindow
)
;
return
value
;
}
getIconProperties
(
browserWindow
=
null
)
{
return
this
.
_getProperties
(
browserWindow
)
.
iconProps
;
}
_createIconProperties
(
urls
)
{
if
(
urls
&
&
typeof
urls
=
=
"
object
"
)
{
let
props
=
this
.
_iconProperties
.
get
(
urls
)
;
if
(
!
props
)
{
props
=
Object
.
freeze
(
{
"
-
-
pageAction
-
image
-
16px
"
:
escapeCSSURL
(
this
.
_iconURLForSize
(
urls
16
)
)
"
-
-
pageAction
-
image
-
32px
"
:
escapeCSSURL
(
this
.
_iconURLForSize
(
urls
32
)
)
}
)
;
this
.
_iconProperties
.
set
(
urls
props
)
;
}
return
props
;
}
let
cssURL
=
urls
?
escapeCSSURL
(
urls
)
:
null
;
return
Object
.
freeze
(
{
"
-
-
pageAction
-
image
-
16px
"
:
cssURL
"
-
-
pageAction
-
image
-
32px
"
:
cssURL
}
)
;
}
getTitle
(
browserWindow
=
null
)
{
return
this
.
_getProperties
(
browserWindow
)
.
title
;
}
setTitle
(
value
browserWindow
=
null
)
{
return
this
.
_setProperty
(
"
title
"
value
browserWindow
)
;
}
getTooltip
(
browserWindow
=
null
)
{
return
this
.
_getProperties
(
browserWindow
)
.
tooltip
;
}
setTooltip
(
value
browserWindow
=
null
)
{
return
this
.
_setProperty
(
"
tooltip
"
value
browserWindow
)
;
}
getWantsSubview
(
browserWindow
=
null
)
{
return
!
!
this
.
_getProperties
(
browserWindow
)
.
wantsSubview
;
}
setWantsSubview
(
value
browserWindow
=
null
)
{
return
this
.
_setProperty
(
"
wantsSubview
"
!
!
value
browserWindow
)
;
}
_setProperty
(
name
value
browserWindow
)
{
let
props
=
this
.
_getProperties
(
browserWindow
!
!
browserWindow
)
;
props
[
name
]
=
value
;
this
.
_updateProperty
(
name
value
browserWindow
)
;
return
value
;
}
_updateProperty
(
name
value
browserWindow
)
{
if
(
PageActions
.
actionForID
(
this
.
id
)
)
{
for
(
let
bpa
of
allBrowserPageActions
(
browserWindow
)
)
{
bpa
.
updateAction
(
this
name
{
value
}
)
;
}
}
}
_getProperties
(
window
forceWindowSpecific
=
false
)
{
let
props
=
window
&
&
this
.
_windowProps
.
get
(
window
)
;
if
(
!
props
&
&
forceWindowSpecific
)
{
props
=
Object
.
create
(
this
.
_globalProps
)
;
this
.
_windowProps
.
set
(
window
props
)
;
}
return
props
|
|
this
.
_globalProps
;
}
get
anchorIDOverride
(
)
{
return
this
.
_anchorIDOverride
;
}
get
urlbarIDOverride
(
)
{
return
this
.
_urlbarIDOverride
;
}
get
wantsIframe
(
)
{
return
this
.
_wantsIframe
|
|
false
;
}
get
labelForHistogram
(
)
{
return
this
.
_labelForHistogram
|
|
this
.
_id
;
}
_iconURLForSize
(
urls
preferredSize
)
{
let
bestSize
=
null
;
if
(
urls
[
preferredSize
]
)
{
bestSize
=
preferredSize
;
}
else
if
(
urls
[
2
*
preferredSize
]
)
{
bestSize
=
2
*
preferredSize
;
}
else
{
let
sizes
=
Object
.
keys
(
urls
)
.
map
(
key
=
>
parseInt
(
key
10
)
)
.
sort
(
(
a
b
)
=
>
a
-
b
)
;
bestSize
=
sizes
.
find
(
candidate
=
>
candidate
>
preferredSize
)
|
|
sizes
.
pop
(
)
;
}
return
urls
[
bestSize
]
;
}
doCommand
(
browserWindow
)
{
browserPageActions
(
browserWindow
)
.
doCommandForAction
(
this
)
;
}
onBeforePlacedInWindow
(
browserWindow
)
{
if
(
this
.
_onBeforePlacedInWindow
)
{
this
.
_onBeforePlacedInWindow
(
browserWindow
)
;
}
}
onCommand
(
event
buttonNode
)
{
if
(
this
.
_onCommand
)
{
this
.
_onCommand
(
event
buttonNode
)
;
}
}
onIframeHiding
(
iframeNode
parentPanelNode
)
{
if
(
this
.
_onIframeHiding
)
{
this
.
_onIframeHiding
(
iframeNode
parentPanelNode
)
;
}
}
onIframeHidden
(
iframeNode
parentPanelNode
)
{
if
(
this
.
_onIframeHidden
)
{
this
.
_onIframeHidden
(
iframeNode
parentPanelNode
)
;
}
}
onIframeShowing
(
iframeNode
parentPanelNode
)
{
if
(
this
.
_onIframeShowing
)
{
this
.
_onIframeShowing
(
iframeNode
parentPanelNode
)
;
}
}
onLocationChange
(
browserWindow
)
{
if
(
this
.
_onLocationChange
)
{
this
.
_onLocationChange
(
browserWindow
)
;
}
}
onPlacedInPanel
(
buttonNode
)
{
if
(
this
.
_onPlacedInPanel
)
{
this
.
_onPlacedInPanel
(
buttonNode
)
;
}
}
onPlacedInUrlbar
(
buttonNode
)
{
if
(
this
.
_onPlacedInUrlbar
)
{
this
.
_onPlacedInUrlbar
(
buttonNode
)
;
}
}
onRemovedFromWindow
(
browserWindow
)
{
if
(
this
.
_onRemovedFromWindow
)
{
this
.
_onRemovedFromWindow
(
browserWindow
)
;
}
}
onShowingInPanel
(
buttonNode
)
{
if
(
this
.
_onShowingInPanel
)
{
this
.
_onShowingInPanel
(
buttonNode
)
;
}
}
onSubviewPlaced
(
panelViewNode
)
{
if
(
this
.
_onSubviewPlaced
)
{
this
.
_onSubviewPlaced
(
panelViewNode
)
;
}
}
onSubviewShowing
(
panelViewNode
)
{
if
(
this
.
_onSubviewShowing
)
{
this
.
_onSubviewShowing
(
panelViewNode
)
;
}
}
remove
(
)
{
PageActions
.
onActionRemoved
(
this
)
;
}
shouldShowInPanel
(
browserWindow
)
{
return
!
this
.
__transient
|
|
!
this
.
getDisabled
(
browserWindow
)
;
}
shouldShowInUrlbar
(
browserWindow
)
{
return
this
.
pinnedToUrlbar
&
&
!
this
.
getDisabled
(
browserWindow
)
;
}
get
_isBuiltIn
(
)
{
let
builtInIDs
=
[
"
pocket
"
"
screenshots
"
"
webcompat
-
reporter
-
button
"
]
.
concat
(
gBuiltInActions
.
filter
(
a
=
>
!
a
.
__isSeparator
)
.
map
(
a
=
>
a
.
id
)
)
;
return
builtInIDs
.
includes
(
this
.
id
)
;
}
}
;
this
.
PageActions
.
Action
=
Action
;
this
.
PageActions
.
ACTION_ID_BUILT_IN_SEPARATOR
=
ACTION_ID_BUILT_IN_SEPARATOR
;
this
.
PageActions
.
ACTION_ID_TRANSIENT_SEPARATOR
=
ACTION_ID_TRANSIENT_SEPARATOR
;
this
.
PageActions
.
ACTION_ID_BOOKMARK
=
ACTION_ID_BOOKMARK
;
this
.
PageActions
.
ACTION_ID_BOOKMARK_SEPARATOR
=
ACTION_ID_BOOKMARK_SEPARATOR
;
this
.
PageActions
.
PREF_PERSISTED_ACTIONS
=
PREF_PERSISTED_ACTIONS
;
var
gBuiltInActions
=
[
{
id
:
ACTION_ID_BOOKMARK
urlbarIDOverride
:
"
star
-
button
-
box
"
_urlbarNodeInMarkup
:
true
title
:
"
"
pinnedToUrlbar
:
true
nodeAttributes
:
{
observes
:
"
bookmarkThisPageBroadcaster
"
}
onShowingInPanel
(
buttonNode
)
{
browserPageActions
(
buttonNode
)
.
bookmark
.
onShowingInPanel
(
buttonNode
)
;
}
onCommand
(
event
buttonNode
)
{
browserPageActions
(
buttonNode
)
.
bookmark
.
onCommand
(
event
buttonNode
)
;
}
}
{
id
:
ACTION_ID_BOOKMARK_SEPARATOR
_isSeparator
:
true
}
{
id
:
"
copyURL
"
title
:
"
copyURL
-
title
"
onPlacedInPanel
(
buttonNode
)
{
browserPageActions
(
buttonNode
)
.
copyURL
.
onPlacedInPanel
(
buttonNode
)
;
}
onCommand
(
event
buttonNode
)
{
browserPageActions
(
buttonNode
)
.
copyURL
.
onCommand
(
event
buttonNode
)
;
}
}
{
id
:
"
emailLink
"
title
:
"
emailLink
-
title
"
onPlacedInPanel
(
buttonNode
)
{
browserPageActions
(
buttonNode
)
.
emailLink
.
onPlacedInPanel
(
buttonNode
)
;
}
onCommand
(
event
buttonNode
)
{
browserPageActions
(
buttonNode
)
.
emailLink
.
onCommand
(
event
buttonNode
)
;
}
}
{
id
:
"
addSearchEngine
"
title
:
"
"
_transient
:
true
onShowingInPanel
(
buttonNode
)
{
browserPageActions
(
buttonNode
)
.
addSearchEngine
.
onShowingInPanel
(
)
;
}
onCommand
(
event
buttonNode
)
{
browserPageActions
(
buttonNode
)
.
addSearchEngine
.
onCommand
(
event
buttonNode
)
;
}
onSubviewShowing
(
panelViewNode
)
{
browserPageActions
(
panelViewNode
)
.
addSearchEngine
.
onSubviewShowing
(
panelViewNode
)
;
}
}
]
;
if
(
Services
.
prefs
.
getBoolPref
(
"
identity
.
fxaccounts
.
enabled
"
)
)
{
gBuiltInActions
.
push
(
{
id
:
"
sendToDevice
"
title
:
"
sendToDevice
-
title
"
onPlacedInPanel
(
buttonNode
)
{
browserPageActions
(
buttonNode
)
.
sendToDevice
.
onPlacedInPanel
(
buttonNode
)
;
}
onLocationChange
(
browserWindow
)
{
browserPageActions
(
browserWindow
)
.
sendToDevice
.
onLocationChange
(
)
;
}
wantsSubview
:
true
onSubviewPlaced
(
panelViewNode
)
{
browserPageActions
(
panelViewNode
)
.
sendToDevice
.
onSubviewPlaced
(
panelViewNode
)
;
}
onSubviewShowing
(
panelViewNode
)
{
browserPageActions
(
panelViewNode
)
.
sendToDevice
.
onShowingSubview
(
panelViewNode
)
;
}
}
)
;
}
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
gBuiltInActions
.
push
(
{
id
:
"
shareURL
"
title
:
"
shareURL
-
title
"
onShowingInPanel
(
buttonNode
)
{
browserPageActions
(
buttonNode
)
.
shareURL
.
onShowingInPanel
(
buttonNode
)
;
}
onPlacedInPanel
(
buttonNode
)
{
browserPageActions
(
buttonNode
)
.
shareURL
.
onPlacedInPanel
(
buttonNode
)
;
}
wantsSubview
:
true
onSubviewShowing
(
panelViewNode
)
{
browserPageActions
(
panelViewNode
)
.
shareURL
.
onShowingSubview
(
panelViewNode
)
;
}
}
)
;
}
function
browserPageActions
(
obj
)
{
if
(
obj
.
BrowserPageActions
)
{
return
obj
.
BrowserPageActions
;
}
return
obj
.
ownerGlobal
.
BrowserPageActions
;
}
function
*
allBrowserWindows
(
browserWindow
=
null
)
{
if
(
browserWindow
)
{
yield
browserWindow
;
return
;
}
let
windows
=
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
;
while
(
windows
.
hasMoreElements
(
)
)
{
yield
windows
.
getNext
(
)
;
}
}
function
*
allBrowserPageActions
(
browserWindow
=
null
)
{
for
(
let
win
of
allBrowserWindows
(
browserWindow
)
)
{
yield
browserPageActions
(
win
)
;
}
}
function
setProperties
(
obj
options
schema
)
{
for
(
let
name
in
schema
)
{
let
required
=
schema
[
name
]
;
if
(
required
&
&
!
(
name
in
options
)
)
{
throw
new
Error
(
'
{
name
}
'
must
be
specified
)
;
}
let
nameInObj
=
"
_
"
+
name
;
if
(
name
[
0
]
=
=
"
_
"
)
{
if
(
name
in
options
)
{
obj
[
nameInObj
]
=
options
[
name
]
;
}
}
else
{
obj
[
nameInObj
]
=
options
[
name
]
|
|
null
;
}
}
for
(
let
name
in
options
)
{
if
(
!
(
name
in
schema
)
)
{
throw
new
Error
(
Unrecognized
option
'
{
name
}
'
)
;
}
}
}
