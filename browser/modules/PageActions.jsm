"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
PageActions
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
AppConstants
"
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
AsyncShutdown
"
"
resource
:
/
/
gre
/
modules
/
AsyncShutdown
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
BinarySearch
"
"
resource
:
/
/
gre
/
modules
/
BinarySearch
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PrivateBrowsingUtils
"
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
const
ACTION_ID_BOOKMARK
=
"
bookmark
"
;
const
ACTION_ID_PIN_TAB
=
"
pinTab
"
;
const
ACTION_ID_BOOKMARK_SEPARATOR
=
"
bookmarkSeparator
"
;
const
ACTION_ID_BUILT_IN_SEPARATOR
=
"
builtInSeparator
"
;
const
ACTION_ID_TRANSIENT_SEPARATOR
=
"
transientSeparator
"
;
const
PREF_PERSISTED_ACTIONS
=
"
browser
.
pageActions
.
persistedActions
"
;
const
PERSISTED_ACTIONS_CURRENT_VERSION
=
1
;
function
escapeCSSURL
(
url
)
{
return
url
(
"
{
url
.
replace
(
/
[
\
\
\
s
"
]
/
g
encodeURIComponent
)
}
"
)
;
}
var
PageActions
=
{
init
(
)
{
let
callbacks
=
this
.
_deferredAddActionCalls
;
delete
this
.
_deferredAddActionCalls
;
this
.
_loadPersistedActions
(
)
;
for
(
let
options
of
gBuiltInActions
)
{
if
(
!
this
.
actionForID
(
options
.
id
)
)
{
this
.
_registerAction
(
new
Action
(
options
)
)
;
}
}
for
(
let
bpa
of
allBrowserPageActions
(
)
)
{
bpa
.
placeAllActionsInUrlbar
(
)
;
}
while
(
callbacks
&
&
callbacks
.
length
)
{
callbacks
.
shift
(
)
(
)
;
}
AsyncShutdown
.
profileBeforeChange
.
addBlocker
(
"
PageActions
:
purging
unregistered
actions
from
cache
"
(
)
=
>
this
.
_purgeUnregisteredPersistedActions
(
)
)
;
}
_deferredAddActionCalls
:
[
]
get
actions
(
)
{
let
lists
=
[
this
.
_builtInActions
this
.
_nonBuiltInActions
this
.
_transientActions
]
;
return
lists
.
reduce
(
(
memo
list
)
=
>
memo
.
concat
(
list
)
[
]
)
;
}
actionsInPanel
(
browserWindow
)
{
function
filter
(
action
)
{
return
action
.
shouldShowInPanel
(
browserWindow
)
;
}
let
actions
=
this
.
_builtInActions
.
filter
(
filter
)
;
let
nonBuiltInActions
=
this
.
_nonBuiltInActions
.
filter
(
filter
)
;
if
(
nonBuiltInActions
.
length
)
{
if
(
actions
.
length
)
{
actions
.
push
(
new
Action
(
{
id
:
ACTION_ID_BUILT_IN_SEPARATOR
_isSeparator
:
true
}
)
)
;
}
actions
.
push
(
.
.
.
nonBuiltInActions
)
;
}
let
transientActions
=
this
.
_transientActions
.
filter
(
filter
)
;
if
(
transientActions
.
length
)
{
if
(
actions
.
length
)
{
actions
.
push
(
new
Action
(
{
id
:
ACTION_ID_TRANSIENT_SEPARATOR
_isSeparator
:
true
}
)
)
;
}
actions
.
push
(
.
.
.
transientActions
)
;
}
return
actions
;
}
actionsInUrlbar
(
browserWindow
)
{
return
this
.
_persistedActions
.
idsInUrlbar
.
reduce
(
(
actions
id
)
=
>
{
let
action
=
this
.
actionForID
(
id
)
;
if
(
action
&
&
action
.
shouldShowInUrlbar
(
browserWindow
)
)
{
actions
.
push
(
action
)
;
}
return
actions
;
}
[
]
)
;
}
actionForID
(
id
)
{
return
this
.
_actionsByID
.
get
(
id
)
;
}
addAction
(
action
)
{
if
(
this
.
_deferredAddActionCalls
)
{
this
.
_deferredAddActionCalls
.
push
(
(
)
=
>
this
.
addAction
(
action
)
)
;
return
action
;
}
this
.
_registerAction
(
action
)
;
for
(
let
bpa
of
allBrowserPageActions
(
)
)
{
bpa
.
placeAction
(
action
)
;
}
return
action
;
}
_registerAction
(
action
)
{
if
(
this
.
actionForID
(
action
.
id
)
)
{
throw
new
Error
(
Action
with
ID
'
{
action
.
id
}
'
already
added
)
;
}
this
.
_actionsByID
.
set
(
action
.
id
action
)
;
if
(
"
__insertBeforeActionID
"
in
action
)
{
let
index
=
!
action
.
__insertBeforeActionID
?
-
1
:
this
.
_builtInActions
.
findIndex
(
a
=
>
{
return
a
.
id
=
=
action
.
__insertBeforeActionID
;
}
)
;
if
(
index
<
0
)
{
index
=
this
.
_builtInActions
.
filter
(
a
=
>
!
a
.
__transient
)
.
length
;
}
this
.
_builtInActions
.
splice
(
index
0
action
)
;
}
else
if
(
action
.
__transient
)
{
this
.
_transientActions
.
push
(
action
)
;
}
else
if
(
action
.
_isBuiltIn
)
{
this
.
_builtInActions
.
push
(
action
)
;
}
else
{
let
index
=
BinarySearch
.
insertionIndexOf
(
(
a1
a2
)
=
>
{
return
a1
.
getTitle
(
)
.
localeCompare
(
a2
.
getTitle
(
)
)
;
}
this
.
_nonBuiltInActions
action
)
;
this
.
_nonBuiltInActions
.
splice
(
index
0
action
)
;
}
if
(
this
.
_persistedActions
.
ids
.
includes
(
action
.
id
)
)
{
action
.
_pinnedToUrlbar
=
this
.
_persistedActions
.
idsInUrlbar
.
includes
(
action
.
id
)
;
}
else
{
this
.
_persistedActions
.
ids
.
push
(
action
.
id
)
;
this
.
_updateIDsPinnedToUrlbarForAction
(
action
)
;
}
}
_updateIDsPinnedToUrlbarForAction
(
action
)
{
let
index
=
this
.
_persistedActions
.
idsInUrlbar
.
indexOf
(
action
.
id
)
;
if
(
action
.
pinnedToUrlbar
)
{
if
(
index
<
0
)
{
index
=
action
.
id
=
=
ACTION_ID_BOOKMARK
?
-
1
:
this
.
_persistedActions
.
idsInUrlbar
.
indexOf
(
ACTION_ID_BOOKMARK
)
;
if
(
index
<
0
)
{
index
=
this
.
_persistedActions
.
idsInUrlbar
.
length
;
}
this
.
_persistedActions
.
idsInUrlbar
.
splice
(
index
0
action
.
id
)
;
}
}
else
if
(
index
>
=
0
)
{
this
.
_persistedActions
.
idsInUrlbar
.
splice
(
index
1
)
;
}
this
.
_storePersistedActions
(
)
;
}
_builtInActions
:
[
]
_nonBuiltInActions
:
[
]
_transientActions
:
[
]
_actionsByID
:
new
Map
(
)
onActionRemoved
(
action
)
{
if
(
!
this
.
actionForID
(
action
.
id
)
)
{
return
;
}
this
.
_actionsByID
.
delete
(
action
.
id
)
;
let
lists
=
[
this
.
_builtInActions
this
.
_nonBuiltInActions
this
.
_transientActions
]
;
for
(
let
list
of
lists
)
{
let
index
=
list
.
findIndex
(
a
=
>
a
.
id
=
=
action
.
id
)
;
if
(
index
>
=
0
)
{
list
.
splice
(
index
1
)
;
break
;
}
}
for
(
let
bpa
of
allBrowserPageActions
(
)
)
{
bpa
.
removeAction
(
action
)
;
}
}
onActionToggledPinnedToUrlbar
(
action
)
{
if
(
!
this
.
actionForID
(
action
.
id
)
)
{
return
;
}
this
.
_updateIDsPinnedToUrlbarForAction
(
action
)
;
for
(
let
bpa
of
allBrowserPageActions
(
)
)
{
bpa
.
placeActionInUrlbar
(
action
)
;
}
}
_reset
(
)
{
PageActions
.
_purgeUnregisteredPersistedActions
(
)
;
PageActions
.
_builtInActions
=
[
]
;
PageActions
.
_nonBuiltInActions
=
[
]
;
PageActions
.
_transientActions
=
[
]
;
PageActions
.
_actionsByID
=
new
Map
(
)
;
}
_storePersistedActions
(
)
{
let
json
=
JSON
.
stringify
(
this
.
_persistedActions
)
;
Services
.
prefs
.
setStringPref
(
PREF_PERSISTED_ACTIONS
json
)
;
}
_loadPersistedActions
(
)
{
try
{
let
json
=
Services
.
prefs
.
getStringPref
(
PREF_PERSISTED_ACTIONS
)
;
this
.
_persistedActions
=
this
.
_migratePersistedActions
(
JSON
.
parse
(
json
)
)
;
}
catch
(
ex
)
{
}
}
_purgeUnregisteredPersistedActions
(
)
{
for
(
let
name
of
[
"
ids
"
"
idsInUrlbar
"
]
)
{
this
.
_persistedActions
[
name
]
=
this
.
_persistedActions
[
name
]
.
filter
(
id
=
>
{
return
this
.
actionForID
(
id
)
;
}
)
;
}
this
.
_storePersistedActions
(
)
;
}
_migratePersistedActions
(
actions
)
{
for
(
let
version
=
actions
.
version
|
|
0
;
version
<
PERSISTED_ACTIONS_CURRENT_VERSION
;
version
+
+
)
{
let
methodName
=
_migratePersistedActionsTo
{
version
+
1
}
;
actions
=
this
[
methodName
]
(
actions
)
;
actions
.
version
=
version
+
1
;
}
return
actions
;
}
_migratePersistedActionsTo1
(
actions
)
{
let
ids
=
[
]
;
for
(
let
id
in
actions
.
ids
)
{
ids
.
push
(
id
)
;
}
let
bookmarkIndex
=
actions
.
idsInUrlbar
.
indexOf
(
ACTION_ID_BOOKMARK
)
;
if
(
bookmarkIndex
>
=
0
)
{
actions
.
idsInUrlbar
.
splice
(
bookmarkIndex
1
)
;
actions
.
idsInUrlbar
.
push
(
ACTION_ID_BOOKMARK
)
;
}
return
{
ids
idsInUrlbar
:
actions
.
idsInUrlbar
}
;
}
_persistedActions
:
{
version
:
PERSISTED_ACTIONS_CURRENT_VERSION
ids
:
[
]
idsInUrlbar
:
[
]
}
}
;
function
Action
(
options
)
{
setProperties
(
this
options
{
id
:
true
title
:
false
anchorIDOverride
:
false
disabled
:
false
extensionID
:
false
iconURL
:
false
isBadged
:
false
labelForHistogram
:
false
onBeforePlacedInWindow
:
false
onCommand
:
false
onIframeHiding
:
false
onIframeHidden
:
false
onIframeShowing
:
false
onLocationChange
:
false
onPlacedInPanel
:
false
onPlacedInUrlbar
:
false
onRemovedFromWindow
:
false
onShowingInPanel
:
false
onSubviewPlaced
:
false
onSubviewShowing
:
false
onPinToUrlbarToggled
:
false
panelFluentID
:
false
pinnedToUrlbar
:
false
tooltip
:
false
urlbarIDOverride
:
false
urlbarFluentID
:
false
wantsIframe
:
false
wantsSubview
:
false
disablePrivateBrowsing
:
false
_insertBeforeActionID
:
false
_isSeparator
:
false
_transient
:
false
_urlbarNodeInMarkup
:
false
}
)
;
this
.
_iconProperties
=
new
WeakMap
(
)
;
this
.
_globalProps
=
{
disabled
:
this
.
_disabled
iconURL
:
this
.
_iconURL
iconProps
:
this
.
_createIconProperties
(
this
.
_iconURL
)
title
:
this
.
_title
tooltip
:
this
.
_tooltip
wantsSubview
:
this
.
_wantsSubview
}
;
this
.
_windowProps
=
new
WeakMap
(
)
;
}
Action
.
prototype
=
{
get
extensionID
(
)
{
return
this
.
_extensionID
;
}
get
id
(
)
{
return
this
.
_id
;
}
get
panelFluentID
(
)
{
return
this
.
_panelFluentID
;
}
set
panelFluentID
(
id
)
{
this
.
_panelFluentID
=
id
;
}
get
urlbarFluentID
(
)
{
return
this
.
_urlbarFluentID
;
}
set
urlbarFluentID
(
id
)
{
this
.
_urlbarFluentID
=
id
;
}
get
disablePrivateBrowsing
(
)
{
return
!
!
this
.
_disablePrivateBrowsing
;
}
canShowInWindow
(
browserWindow
)
{
if
(
this
.
_extensionID
)
{
let
policy
=
WebExtensionPolicy
.
getByID
(
this
.
_extensionID
)
;
if
(
!
policy
.
canAccessWindow
(
browserWindow
)
)
{
return
false
;
}
}
return
!
(
this
.
disablePrivateBrowsing
&
&
PrivateBrowsingUtils
.
isWindowPrivate
(
browserWindow
)
)
;
}
get
pinnedToUrlbar
(
)
{
return
this
.
_pinnedToUrlbar
|
|
false
;
}
set
pinnedToUrlbar
(
shown
)
{
if
(
this
.
pinnedToUrlbar
!
=
shown
)
{
this
.
_pinnedToUrlbar
=
shown
;
PageActions
.
onActionToggledPinnedToUrlbar
(
this
)
;
this
.
onPinToUrlbarToggled
(
)
;
}
}
getDisabled
(
browserWindow
=
null
)
{
return
!
!
this
.
_getProperties
(
browserWindow
)
.
disabled
;
}
setDisabled
(
value
browserWindow
=
null
)
{
return
this
.
_setProperty
(
"
disabled
"
!
!
value
browserWindow
)
;
}
getIconURL
(
browserWindow
=
null
)
{
return
this
.
_getProperties
(
browserWindow
)
.
iconURL
;
}
setIconURL
(
value
browserWindow
=
null
)
{
let
props
=
this
.
_getProperties
(
browserWindow
!
!
browserWindow
)
;
props
.
iconURL
=
value
;
props
.
iconProps
=
this
.
_createIconProperties
(
value
)
;
this
.
_updateProperty
(
"
iconURL
"
props
.
iconProps
browserWindow
)
;
return
value
;
}
getIconProperties
(
browserWindow
=
null
)
{
return
this
.
_getProperties
(
browserWindow
)
.
iconProps
;
}
_createIconProperties
(
urls
)
{
if
(
urls
&
&
typeof
urls
=
=
"
object
"
)
{
let
props
=
this
.
_iconProperties
.
get
(
urls
)
;
if
(
!
props
)
{
props
=
Object
.
freeze
(
{
"
-
-
pageAction
-
image
-
16px
"
:
escapeCSSURL
(
this
.
_iconURLForSize
(
urls
16
)
)
"
-
-
pageAction
-
image
-
32px
"
:
escapeCSSURL
(
this
.
_iconURLForSize
(
urls
32
)
)
}
)
;
this
.
_iconProperties
.
set
(
urls
props
)
;
}
return
props
;
}
let
cssURL
=
urls
?
escapeCSSURL
(
urls
)
:
null
;
return
Object
.
freeze
(
{
"
-
-
pageAction
-
image
-
16px
"
:
cssURL
"
-
-
pageAction
-
image
-
32px
"
:
cssURL
}
)
;
}
getTitle
(
browserWindow
=
null
)
{
return
this
.
_getProperties
(
browserWindow
)
.
title
;
}
setTitle
(
value
browserWindow
=
null
)
{
return
this
.
_setProperty
(
"
title
"
value
browserWindow
)
;
}
getTooltip
(
browserWindow
=
null
)
{
return
this
.
_getProperties
(
browserWindow
)
.
tooltip
;
}
setTooltip
(
value
browserWindow
=
null
)
{
return
this
.
_setProperty
(
"
tooltip
"
value
browserWindow
)
;
}
getWantsSubview
(
browserWindow
=
null
)
{
return
!
!
this
.
_getProperties
(
browserWindow
)
.
wantsSubview
;
}
setWantsSubview
(
value
browserWindow
=
null
)
{
return
this
.
_setProperty
(
"
wantsSubview
"
!
!
value
browserWindow
)
;
}
_setProperty
(
name
value
browserWindow
)
{
let
props
=
this
.
_getProperties
(
browserWindow
!
!
browserWindow
)
;
props
[
name
]
=
value
;
this
.
_updateProperty
(
name
value
browserWindow
)
;
return
value
;
}
_updateProperty
(
name
value
browserWindow
)
{
if
(
PageActions
.
actionForID
(
this
.
id
)
)
{
for
(
let
bpa
of
allBrowserPageActions
(
browserWindow
)
)
{
bpa
.
updateAction
(
this
name
{
value
}
)
;
}
}
}
_getProperties
(
window
forceWindowSpecific
=
false
)
{
let
props
=
window
&
&
this
.
_windowProps
.
get
(
window
)
;
if
(
!
props
&
&
forceWindowSpecific
)
{
props
=
Object
.
create
(
this
.
_globalProps
)
;
this
.
_windowProps
.
set
(
window
props
)
;
}
return
props
|
|
this
.
_globalProps
;
}
get
anchorIDOverride
(
)
{
return
this
.
_anchorIDOverride
;
}
get
urlbarIDOverride
(
)
{
return
this
.
_urlbarIDOverride
;
}
get
wantsIframe
(
)
{
return
this
.
_wantsIframe
|
|
false
;
}
get
isBadged
(
)
{
return
this
.
_isBadged
|
|
false
;
}
get
labelForHistogram
(
)
{
return
(
this
.
_labelForHistogram
|
|
this
.
_id
.
replace
(
/
_
\
w
{
1
}
/
g
match
=
>
match
[
1
]
.
toUpperCase
(
)
)
.
substr
(
0
20
)
)
;
}
_iconURLForSize
(
urls
preferredSize
)
{
let
bestSize
=
null
;
if
(
urls
[
preferredSize
]
)
{
bestSize
=
preferredSize
;
}
else
if
(
urls
[
2
*
preferredSize
]
)
{
bestSize
=
2
*
preferredSize
;
}
else
{
let
sizes
=
Object
.
keys
(
urls
)
.
map
(
key
=
>
parseInt
(
key
10
)
)
.
sort
(
(
a
b
)
=
>
a
-
b
)
;
bestSize
=
sizes
.
find
(
candidate
=
>
candidate
>
preferredSize
)
|
|
sizes
.
pop
(
)
;
}
return
urls
[
bestSize
]
;
}
doCommand
(
browserWindow
)
{
browserPageActions
(
browserWindow
)
.
doCommandForAction
(
this
)
;
}
onBeforePlacedInWindow
(
browserWindow
)
{
if
(
this
.
_onBeforePlacedInWindow
)
{
this
.
_onBeforePlacedInWindow
(
browserWindow
)
;
}
}
onCommand
(
event
buttonNode
)
{
if
(
this
.
_onCommand
)
{
this
.
_onCommand
(
event
buttonNode
)
;
}
}
onIframeHiding
(
iframeNode
parentPanelNode
)
{
if
(
this
.
_onIframeHiding
)
{
this
.
_onIframeHiding
(
iframeNode
parentPanelNode
)
;
}
}
onIframeHidden
(
iframeNode
parentPanelNode
)
{
if
(
this
.
_onIframeHidden
)
{
this
.
_onIframeHidden
(
iframeNode
parentPanelNode
)
;
}
}
onIframeShowing
(
iframeNode
parentPanelNode
)
{
if
(
this
.
_onIframeShowing
)
{
this
.
_onIframeShowing
(
iframeNode
parentPanelNode
)
;
}
}
onLocationChange
(
browserWindow
)
{
if
(
this
.
_onLocationChange
)
{
this
.
_onLocationChange
(
browserWindow
)
;
}
}
onPlacedInPanel
(
buttonNode
)
{
if
(
this
.
_onPlacedInPanel
)
{
this
.
_onPlacedInPanel
(
buttonNode
)
;
}
}
onPlacedInUrlbar
(
buttonNode
)
{
if
(
this
.
_onPlacedInUrlbar
)
{
this
.
_onPlacedInUrlbar
(
buttonNode
)
;
}
}
onRemovedFromWindow
(
browserWindow
)
{
if
(
this
.
_onRemovedFromWindow
)
{
this
.
_onRemovedFromWindow
(
browserWindow
)
;
}
}
onShowingInPanel
(
buttonNode
)
{
if
(
this
.
_onShowingInPanel
)
{
this
.
_onShowingInPanel
(
buttonNode
)
;
}
}
onSubviewPlaced
(
panelViewNode
)
{
if
(
this
.
_onSubviewPlaced
)
{
this
.
_onSubviewPlaced
(
panelViewNode
)
;
}
}
onSubviewShowing
(
panelViewNode
)
{
if
(
this
.
_onSubviewShowing
)
{
this
.
_onSubviewShowing
(
panelViewNode
)
;
}
}
onPinToUrlbarToggled
(
)
{
if
(
this
.
_onPinToUrlbarToggled
)
{
this
.
_onPinToUrlbarToggled
(
)
;
}
}
remove
(
)
{
PageActions
.
onActionRemoved
(
this
)
;
}
shouldShowInPanel
(
browserWindow
)
{
return
(
(
!
this
.
__transient
|
|
!
this
.
getDisabled
(
browserWindow
)
)
&
&
this
.
canShowInWindow
(
browserWindow
)
)
;
}
shouldShowInUrlbar
(
browserWindow
)
{
return
(
this
.
pinnedToUrlbar
&
&
!
this
.
getDisabled
(
browserWindow
)
&
&
this
.
canShowInWindow
(
browserWindow
)
)
;
}
get
_isBuiltIn
(
)
{
let
builtInIDs
=
[
"
pocket
"
"
screenshots_mozilla_org
"
]
.
concat
(
gBuiltInActions
.
filter
(
a
=
>
!
a
.
__isSeparator
)
.
map
(
a
=
>
a
.
id
)
)
;
return
builtInIDs
.
includes
(
this
.
id
)
;
}
get
_isMozillaAction
(
)
{
return
this
.
_isBuiltIn
|
|
this
.
id
=
=
"
webcompat
-
reporter_mozilla_org
"
;
}
}
;
PageActions
.
Action
=
Action
;
PageActions
.
ACTION_ID_BUILT_IN_SEPARATOR
=
ACTION_ID_BUILT_IN_SEPARATOR
;
PageActions
.
ACTION_ID_TRANSIENT_SEPARATOR
=
ACTION_ID_TRANSIENT_SEPARATOR
;
PageActions
.
ACTION_ID_BOOKMARK
=
ACTION_ID_BOOKMARK
;
PageActions
.
ACTION_ID_PIN_TAB
=
ACTION_ID_PIN_TAB
;
PageActions
.
ACTION_ID_BOOKMARK_SEPARATOR
=
ACTION_ID_BOOKMARK_SEPARATOR
;
PageActions
.
PREF_PERSISTED_ACTIONS
=
PREF_PERSISTED_ACTIONS
;
var
gBuiltInActions
=
[
{
id
:
ACTION_ID_BOOKMARK
urlbarIDOverride
:
"
star
-
button
-
box
"
_urlbarNodeInMarkup
:
true
pinnedToUrlbar
:
true
onShowingInPanel
(
buttonNode
)
{
browserPageActions
(
buttonNode
)
.
bookmark
.
onShowingInPanel
(
buttonNode
)
;
}
onCommand
(
event
buttonNode
)
{
browserPageActions
(
buttonNode
)
.
bookmark
.
onCommand
(
event
buttonNode
)
;
}
}
{
id
:
ACTION_ID_PIN_TAB
onBeforePlacedInWindow
(
browserWindow
)
{
function
handlePinEvent
(
)
{
browserPageActions
(
browserWindow
)
.
pinTab
.
updateState
(
)
;
}
function
handleWindowUnload
(
)
{
for
(
let
event
of
[
"
TabPinned
"
"
TabUnpinned
"
]
)
{
browserWindow
.
removeEventListener
(
event
handlePinEvent
)
;
}
}
for
(
let
event
of
[
"
TabPinned
"
"
TabUnpinned
"
]
)
{
browserWindow
.
addEventListener
(
event
handlePinEvent
)
;
}
browserWindow
.
addEventListener
(
"
unload
"
handleWindowUnload
{
once
:
true
}
)
;
}
onPlacedInPanel
(
buttonNode
)
{
browserPageActions
(
buttonNode
)
.
pinTab
.
updateState
(
)
;
}
onPlacedInUrlbar
(
buttonNode
)
{
browserPageActions
(
buttonNode
)
.
pinTab
.
updateState
(
)
;
}
onLocationChange
(
browserWindow
)
{
browserPageActions
(
browserWindow
)
.
pinTab
.
updateState
(
)
;
}
onCommand
(
event
buttonNode
)
{
browserPageActions
(
buttonNode
)
.
pinTab
.
onCommand
(
event
buttonNode
)
;
}
}
{
id
:
ACTION_ID_BOOKMARK_SEPARATOR
_isSeparator
:
true
}
{
id
:
"
copyURL
"
panelFluentID
:
"
page
-
action
-
copy
-
url
-
panel
"
urlbarFluentID
:
"
page
-
action
-
copy
-
url
-
urlbar
"
onCommand
(
event
buttonNode
)
{
browserPageActions
(
buttonNode
)
.
copyURL
.
onCommand
(
event
buttonNode
)
;
}
}
{
id
:
"
emailLink
"
panelFluentID
:
"
page
-
action
-
email
-
link
-
panel
"
urlbarFluentID
:
"
page
-
action
-
email
-
link
-
urlbar
"
onCommand
(
event
buttonNode
)
{
browserPageActions
(
buttonNode
)
.
emailLink
.
onCommand
(
event
buttonNode
)
;
}
}
{
id
:
"
addSearchEngine
"
isBadged
:
true
_transient
:
true
onShowingInPanel
(
buttonNode
)
{
browserPageActions
(
buttonNode
)
.
addSearchEngine
.
onShowingInPanel
(
)
;
}
onCommand
(
event
buttonNode
)
{
browserPageActions
(
buttonNode
)
.
addSearchEngine
.
onCommand
(
event
buttonNode
)
;
}
onSubviewShowing
(
panelViewNode
)
{
browserPageActions
(
panelViewNode
)
.
addSearchEngine
.
onSubviewShowing
(
panelViewNode
)
;
}
}
]
;
if
(
Services
.
prefs
.
getBoolPref
(
"
identity
.
fxaccounts
.
enabled
"
)
)
{
gBuiltInActions
.
push
(
{
id
:
"
sendToDevice
"
panelFluentID
:
"
page
-
action
-
send
-
tabs
-
panel
"
urlbarFluentID
:
"
page
-
action
-
send
-
tabs
-
urlbar
"
onBeforePlacedInWindow
(
browserWindow
)
{
browserPageActions
(
browserWindow
)
.
sendToDevice
.
onBeforePlacedInWindow
(
browserWindow
)
;
}
onLocationChange
(
browserWindow
)
{
browserPageActions
(
browserWindow
)
.
sendToDevice
.
onLocationChange
(
)
;
}
wantsSubview
:
true
onSubviewPlaced
(
panelViewNode
)
{
browserPageActions
(
panelViewNode
)
.
sendToDevice
.
onSubviewPlaced
(
panelViewNode
)
;
}
onSubviewShowing
(
panelViewNode
)
{
browserPageActions
(
panelViewNode
)
.
sendToDevice
.
onShowingSubview
(
panelViewNode
)
;
}
}
)
;
}
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
gBuiltInActions
.
push
(
{
id
:
"
shareURL
"
panelFluentID
:
"
page
-
action
-
share
-
url
-
panel
"
urlbarFluentID
:
"
page
-
action
-
share
-
url
-
urlbar
"
onShowingInPanel
(
buttonNode
)
{
browserPageActions
(
buttonNode
)
.
shareURL
.
onShowingInPanel
(
buttonNode
)
;
}
wantsSubview
:
true
onSubviewShowing
(
panelViewNode
)
{
browserPageActions
(
panelViewNode
)
.
shareURL
.
onShowingSubview
(
panelViewNode
)
;
}
}
)
;
}
if
(
AppConstants
.
isPlatformAndVersionAtLeast
(
"
win
"
"
6
.
4
"
)
)
{
gBuiltInActions
.
push
(
{
id
:
"
shareURL
"
panelFluentID
:
"
page
-
action
-
share
-
url
-
panel
"
urlbarFluentID
:
"
page
-
action
-
share
-
url
-
urlbar
"
onCommand
(
event
buttonNode
)
{
browserPageActions
(
buttonNode
)
.
shareURL
.
onCommand
(
event
buttonNode
)
;
}
}
)
;
}
function
browserPageActions
(
obj
)
{
if
(
obj
.
BrowserPageActions
)
{
return
obj
.
BrowserPageActions
;
}
return
obj
.
ownerGlobal
.
BrowserPageActions
;
}
function
*
allBrowserWindows
(
browserWindow
=
null
)
{
if
(
browserWindow
)
{
yield
browserWindow
;
return
;
}
yield
*
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
;
}
function
*
allBrowserPageActions
(
browserWindow
=
null
)
{
for
(
let
win
of
allBrowserWindows
(
browserWindow
)
)
{
yield
browserPageActions
(
win
)
;
}
}
function
setProperties
(
obj
options
schema
)
{
for
(
let
name
in
schema
)
{
let
required
=
schema
[
name
]
;
if
(
required
&
&
!
(
name
in
options
)
)
{
throw
new
Error
(
'
{
name
}
'
must
be
specified
)
;
}
let
nameInObj
=
"
_
"
+
name
;
if
(
name
[
0
]
=
=
"
_
"
)
{
if
(
name
in
options
)
{
obj
[
nameInObj
]
=
options
[
name
]
;
}
}
else
{
obj
[
nameInObj
]
=
options
[
name
]
|
|
null
;
}
}
for
(
let
name
in
options
)
{
if
(
!
(
name
in
schema
)
)
{
throw
new
Error
(
Unrecognized
option
'
{
name
}
'
)
;
}
}
}
