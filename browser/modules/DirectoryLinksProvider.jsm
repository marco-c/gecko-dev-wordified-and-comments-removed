"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
DirectoryLinksProvider
"
]
;
const
Cu
=
Components
.
utils
;
Cu
.
importGlobalProperties
(
[
"
XMLHttpRequest
"
]
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
OS
"
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PromiseUtils
"
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
UpdateUtils
"
"
resource
:
/
/
gre
/
modules
/
UpdateUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gTextDecoder
"
(
)
=
>
{
return
new
TextDecoder
(
)
;
}
)
;
const
DIRECTORY_LINKS_FILE
=
"
directoryLinks
.
json
"
;
const
DIRECTORY_LINKS_TYPE
=
"
application
/
json
"
;
const
PREF_DIRECTORY_SOURCE
=
"
browser
.
newtabpage
.
directory
.
source
"
;
const
PREF_NEWTAB_ENHANCED
=
"
browser
.
newtabpage
.
enhanced
"
;
const
ALLOWED_LINK_SCHEMES
=
new
Set
(
[
"
http
"
"
https
"
]
)
;
const
ALLOWED_IMAGE_SCHEMES
=
new
Set
(
[
"
https
"
"
data
"
]
)
;
const
ALLOWED_URL_BASE
=
new
Set
(
[
"
mozilla
.
net
"
"
"
]
)
;
const
DIRECTORY_FRECENCY
=
1000
;
var
DirectoryLinksProvider
=
{
__linksURL
:
null
_observers
:
new
Set
(
)
_downloadDeferred
:
null
_downloadIntervalMS
:
86400000
get
_observedPrefs
(
)
{
return
Object
.
freeze
(
{
enhanced
:
PREF_NEWTAB_ENHANCED
linksURL
:
PREF_DIRECTORY_SOURCE
}
)
;
}
get
_linksURL
(
)
{
if
(
!
this
.
__linksURL
)
{
try
{
this
.
__linksURL
=
Services
.
prefs
.
getCharPref
(
this
.
_observedPrefs
.
linksURL
)
;
this
.
__linksURLModified
=
Services
.
prefs
.
prefHasUserValue
(
this
.
_observedPrefs
.
linksURL
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
"
Error
fetching
directory
links
url
from
prefs
:
"
+
e
)
;
}
}
return
this
.
__linksURL
;
}
get
locale
(
)
{
return
Services
.
locale
.
getRequestedLocale
(
)
|
|
"
en
-
US
"
;
}
_setDefaultEnhanced
:
function
DirectoryLinksProvider_setDefaultEnhanced
(
)
{
if
(
!
Services
.
prefs
.
prefHasUserValue
(
PREF_NEWTAB_ENHANCED
)
)
{
let
enhanced
=
Services
.
prefs
.
getBoolPref
(
PREF_NEWTAB_ENHANCED
)
;
try
{
if
(
Services
.
prefs
.
getBoolPref
(
"
privacy
.
donottrackheader
.
enabled
"
)
)
{
enhanced
=
false
;
}
}
catch
(
ex
)
{
}
Services
.
prefs
.
setBoolPref
(
PREF_NEWTAB_ENHANCED
enhanced
)
;
}
}
observe
:
function
DirectoryLinksProvider_observe
(
aSubject
aTopic
aData
)
{
if
(
aTopic
=
=
"
nsPref
:
changed
"
)
{
switch
(
aData
)
{
case
this
.
_observedPrefs
.
enhanced
:
this
.
_setDefaultEnhanced
(
)
;
break
;
case
this
.
_observedPrefs
.
linksURL
:
delete
this
.
__linksURL
;
this
.
_fetchAndCacheLinksIfNecessary
(
true
)
;
break
;
}
}
else
if
(
aTopic
=
=
=
"
intl
:
requested
-
locales
-
changed
"
)
{
this
.
_fetchAndCacheLinksIfNecessary
(
true
)
;
}
}
_addPrefsObserver
:
function
DirectoryLinksProvider_addObserver
(
)
{
for
(
let
pref
in
this
.
_observedPrefs
)
{
let
prefName
=
this
.
_observedPrefs
[
pref
]
;
Services
.
prefs
.
addObserver
(
prefName
this
)
;
}
}
_removePrefsObserver
:
function
DirectoryLinksProvider_removeObserver
(
)
{
for
(
let
pref
in
this
.
_observedPrefs
)
{
let
prefName
=
this
.
_observedPrefs
[
pref
]
;
Services
.
prefs
.
removeObserver
(
prefName
this
)
;
}
}
_fetchAndCacheLinks
:
function
DirectoryLinksProvider_fetchAndCacheLinks
(
uri
)
{
uri
=
uri
.
replace
(
"
%
LOCALE
%
"
this
.
locale
)
;
uri
=
uri
.
replace
(
"
%
CHANNEL
%
"
UpdateUtils
.
UpdateChannel
)
;
return
this
.
_downloadJsonData
(
uri
)
.
then
(
json
=
>
{
return
OS
.
File
.
writeAtomic
(
this
.
_directoryFilePath
json
{
tmpPath
:
this
.
_directoryFilePath
+
"
.
tmp
"
}
)
;
}
)
;
}
_downloadJsonData
:
function
DirectoryLinksProvider__downloadJsonData
(
uri
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
xmlHttp
=
this
.
_newXHR
(
)
;
xmlHttp
.
onload
=
function
(
aResponse
)
{
let
json
=
this
.
responseText
;
if
(
this
.
status
&
&
this
.
status
!
=
200
)
{
json
=
"
{
}
"
;
}
resolve
(
json
)
;
}
;
xmlHttp
.
onerror
=
function
(
e
)
{
reject
(
"
Fetching
"
+
uri
+
"
results
in
error
code
:
"
+
e
.
target
.
status
)
;
}
;
try
{
xmlHttp
.
open
(
"
GET
"
uri
)
;
xmlHttp
.
overrideMimeType
(
DIRECTORY_LINKS_TYPE
)
;
xmlHttp
.
setRequestHeader
(
"
Content
-
Type
"
DIRECTORY_LINKS_TYPE
)
;
xmlHttp
.
send
(
)
;
}
catch
(
e
)
{
reject
(
"
Error
fetching
"
+
uri
)
;
Cu
.
reportError
(
e
)
;
}
}
)
;
}
_fetchAndCacheLinksIfNecessary
:
function
DirectoryLinksProvider_fetchAndCacheLinksIfNecessary
(
forceDownload
=
false
)
{
if
(
this
.
_downloadDeferred
)
{
return
this
.
_downloadDeferred
.
promise
;
}
if
(
forceDownload
|
|
this
.
_needsDownload
)
{
this
.
_downloadDeferred
=
PromiseUtils
.
defer
(
)
;
this
.
_fetchAndCacheLinks
(
this
.
_linksURL
)
.
then
(
(
)
=
>
{
this
.
_lastDownloadMS
=
Date
.
now
(
)
;
this
.
_downloadDeferred
.
resolve
(
)
;
this
.
_downloadDeferred
=
null
;
this
.
_callObservers
(
"
onManyLinksChanged
"
)
;
}
error
=
>
{
this
.
_downloadDeferred
.
resolve
(
)
;
this
.
_downloadDeferred
=
null
;
this
.
_callObservers
(
"
onDownloadFail
"
)
;
}
)
;
return
this
.
_downloadDeferred
.
promise
;
}
return
Promise
.
resolve
(
)
;
}
get
_needsDownload
(
)
{
if
(
(
Date
.
now
(
)
-
this
.
_lastDownloadMS
)
>
this
.
_downloadIntervalMS
)
{
return
true
;
}
return
false
;
}
_newXHR
(
)
{
return
new
XMLHttpRequest
(
{
mozAnon
:
true
}
)
;
}
_readDirectoryLinksFile
:
function
DirectoryLinksProvider_readDirectoryLinksFile
(
)
{
let
emptyOutput
=
{
directory
:
[
]
}
;
return
OS
.
File
.
read
(
this
.
_directoryFilePath
)
.
then
(
binaryData
=
>
{
let
output
;
try
{
let
json
=
gTextDecoder
.
decode
(
binaryData
)
;
let
linksObj
=
JSON
.
parse
(
json
)
;
output
=
{
directory
:
linksObj
.
directory
|
|
[
]
}
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
return
output
|
|
emptyOutput
;
}
error
=
>
{
Cu
.
reportError
(
error
)
;
return
emptyOutput
;
}
)
;
}
getEnhancedLink
:
function
DirectoryLinksProvider_getEnhancedLink
(
link
)
{
return
link
.
enhancedImageURI
&
&
link
;
}
isURLAllowed
(
url
allowed
checkBase
)
{
if
(
!
url
)
{
return
true
;
}
let
scheme
=
"
"
base
=
"
"
;
try
{
let
uri
=
Services
.
io
.
newURI
(
url
)
;
scheme
=
uri
.
scheme
;
base
=
Services
.
eTLD
.
getBaseDomain
(
uri
)
;
}
catch
(
ex
)
{
}
return
allowed
.
has
(
scheme
)
&
&
(
!
checkBase
|
|
ALLOWED_URL_BASE
.
has
(
base
)
)
;
}
getLinks
:
function
DirectoryLinksProvider_getLinks
(
aCallback
)
{
this
.
_readDirectoryLinksFile
(
)
.
then
(
rawLinks
=
>
{
let
checkBase
=
!
this
.
__linksURLModified
;
let
validityFilter
=
link
=
>
{
return
this
.
isURLAllowed
(
link
.
url
ALLOWED_LINK_SCHEMES
false
)
&
&
(
!
link
.
imageURI
|
|
this
.
isURLAllowed
(
link
.
imageURI
ALLOWED_IMAGE_SCHEMES
checkBase
)
)
&
&
(
!
link
.
enhancedImageURI
|
|
this
.
isURLAllowed
(
link
.
enhancedImageURI
ALLOWED_IMAGE_SCHEMES
checkBase
)
)
;
}
;
let
links
=
rawLinks
.
directory
.
filter
(
validityFilter
)
.
map
(
(
link
position
)
=
>
{
link
.
lastVisitDate
=
rawLinks
.
directory
.
length
-
position
;
link
.
frecency
=
DIRECTORY_FRECENCY
;
return
link
;
}
)
;
return
links
;
}
)
.
catch
(
ex
=
>
{
Cu
.
reportError
(
ex
)
;
return
[
]
;
}
)
.
then
(
links
=
>
{
aCallback
(
links
)
;
}
)
;
}
init
:
function
DirectoryLinksProvider_init
(
)
{
this
.
_setDefaultEnhanced
(
)
;
this
.
_addPrefsObserver
(
)
;
Services
.
obs
.
addObserver
(
this
"
intl
:
requested
-
locales
-
changed
"
)
;
this
.
_directoryFilePath
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
localProfileDir
DIRECTORY_LINKS_FILE
)
;
this
.
_lastDownloadMS
=
0
;
return
(
async
(
)
=
>
{
let
doesFileExists
=
await
OS
.
File
.
exists
(
this
.
_directoryFilePath
)
;
if
(
doesFileExists
)
{
let
fileInfo
=
await
OS
.
File
.
stat
(
this
.
_directoryFilePath
)
;
this
.
_lastDownloadMS
=
Date
.
parse
(
fileInfo
.
lastModificationDate
)
;
}
await
this
.
_fetchAndCacheLinksIfNecessary
(
)
;
}
)
(
)
;
}
reset
:
function
DirectoryLinksProvider_reset
(
)
{
delete
this
.
__linksURL
;
this
.
_removePrefsObserver
(
)
;
this
.
_removeObservers
(
)
;
Services
.
obs
.
removeObserver
(
this
"
intl
:
requested
-
locales
-
changed
"
)
;
}
addObserver
:
function
DirectoryLinksProvider_addObserver
(
aObserver
)
{
this
.
_observers
.
add
(
aObserver
)
;
}
removeObserver
:
function
DirectoryLinksProvider_removeObserver
(
aObserver
)
{
this
.
_observers
.
delete
(
aObserver
)
;
}
_callObservers
(
methodName
.
.
.
args
)
{
for
(
let
obs
of
this
.
_observers
)
{
if
(
typeof
(
obs
[
methodName
]
)
=
=
"
function
"
)
{
try
{
obs
[
methodName
]
(
this
.
.
.
args
)
;
}
catch
(
err
)
{
Cu
.
reportError
(
err
)
;
}
}
}
}
_removeObservers
(
)
{
this
.
_observers
.
clear
(
)
;
}
}
;
