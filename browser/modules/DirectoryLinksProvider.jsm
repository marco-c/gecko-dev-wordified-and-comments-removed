"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
DirectoryLinksProvider
"
]
;
const
Ci
=
Components
.
interfaces
;
const
Cc
=
Components
.
classes
;
const
Cu
=
Components
.
utils
;
const
ParserUtils
=
Cc
[
"
mozilla
.
org
/
parserutils
;
1
"
]
.
getService
(
Ci
.
nsIParserUtils
)
;
Cu
.
importGlobalProperties
(
[
"
XMLHttpRequest
"
]
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
NetUtil
"
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
NewTabUtils
"
"
resource
:
/
/
gre
/
modules
/
NewTabUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
OS
"
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Promise
"
"
resource
:
/
/
gre
/
modules
/
Promise
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
UpdateUtils
"
"
resource
:
/
/
gre
/
modules
/
UpdateUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
eTLD
"
"
mozilla
.
org
/
network
/
effective
-
tld
-
service
;
1
"
"
nsIEffectiveTLDService
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
RemoteNewTabUtils
"
"
resource
:
/
/
/
modules
/
RemoteNewTabUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gTextDecoder
"
(
)
=
>
{
return
new
TextDecoder
(
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gCryptoHash
"
function
(
)
{
return
Cc
[
"
mozilla
.
org
/
security
/
hash
;
1
"
]
.
createInstance
(
Ci
.
nsICryptoHash
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gUnicodeConverter
"
function
(
)
{
let
converter
=
Cc
[
"
mozilla
.
org
/
intl
/
scriptableunicodeconverter
"
]
.
createInstance
(
Ci
.
nsIScriptableUnicodeConverter
)
;
converter
.
charset
=
'
utf8
'
;
return
converter
;
}
)
;
const
DIRECTORY_LINKS_FILE
=
"
directoryLinks
.
json
"
;
const
DIRECTORY_LINKS_TYPE
=
"
application
/
json
"
;
const
PREF_MATCH_OS_LOCALE
=
"
intl
.
locale
.
matchOS
"
;
const
PREF_SELECTED_LOCALE
=
"
general
.
useragent
.
locale
"
;
const
PREF_DIRECTORY_SOURCE
=
"
browser
.
newtabpage
.
directory
.
source
"
;
const
PREF_DIRECTORY_PING
=
"
browser
.
newtabpage
.
directory
.
ping
"
;
const
PREF_NEWTAB_ENHANCED
=
"
browser
.
newtabpage
.
enhanced
"
;
const
ALLOWED_LINK_SCHEMES
=
new
Set
(
[
"
http
"
"
https
"
]
)
;
const
ALLOWED_IMAGE_SCHEMES
=
new
Set
(
[
"
https
"
"
data
"
]
)
;
const
ALLOWED_URL_BASE
=
new
Set
(
[
"
mozilla
.
net
"
"
"
]
)
;
const
DIRECTORY_FRECENCY
=
1000
;
const
SUGGESTED_FRECENCY
=
Infinity
;
const
FREQUENCY_CAP_FILE
=
"
frequencyCap
.
json
"
;
const
DEFAULT_DAILY_FREQUENCY_CAP
=
3
;
const
DEFAULT_TOTAL_FREQUENCY_CAP
=
10
;
const
DEFAULT_PRUNE_TIME_DELTA
=
10
*
24
*
60
*
60
*
1000
;
const
MIN_VISIBLE_HISTORY_TILES
=
8
;
const
MAX_VISIBLE_HISTORY_TILES
=
15
;
const
PING_SCORE_DIVISOR
=
10000
;
const
PING_ACTIONS
=
[
"
block
"
"
click
"
"
pin
"
"
sponsored
"
"
sponsored_link
"
"
unpin
"
"
view
"
]
;
const
INADJACENCY_SOURCE
=
"
chrome
:
/
/
browser
/
content
/
newtab
/
newTab
.
inadjacent
.
json
"
;
const
FAKE_SUGGESTED_BLOCK_URL
=
"
ignore
:
/
/
suggested_block
"
;
const
AFTER_SUGGESTED_BLOCK_DECAY_TIME
=
24
*
60
*
60
*
1000
;
var
DirectoryLinksProvider
=
{
__linksURL
:
null
_observers
:
new
Set
(
)
_downloadDeferred
:
null
_downloadIntervalMS
:
86400000
_enhancedLinks
:
new
Map
(
)
_suggestedLinks
:
new
Map
(
)
_frequencyCaps
:
{
}
_topSitesWithSuggestedLinks
:
new
Set
(
)
_inadjacentSites
:
new
Set
(
)
_avoidInadjacentSites
:
false
_newTabHasInadjacentSite
:
false
get
_observedPrefs
(
)
{
return
Object
.
freeze
(
{
enhanced
:
PREF_NEWTAB_ENHANCED
linksURL
:
PREF_DIRECTORY_SOURCE
matchOSLocale
:
PREF_MATCH_OS_LOCALE
prefSelectedLocale
:
PREF_SELECTED_LOCALE
}
)
;
}
get
_linksURL
(
)
{
if
(
!
this
.
__linksURL
)
{
try
{
this
.
__linksURL
=
Services
.
prefs
.
getCharPref
(
this
.
_observedPrefs
[
"
linksURL
"
]
)
;
this
.
__linksURLModified
=
Services
.
prefs
.
prefHasUserValue
(
this
.
_observedPrefs
[
"
linksURL
"
]
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
"
Error
fetching
directory
links
url
from
prefs
:
"
+
e
)
;
}
}
return
this
.
__linksURL
;
}
get
locale
(
)
{
let
matchOS
;
try
{
matchOS
=
Services
.
prefs
.
getBoolPref
(
PREF_MATCH_OS_LOCALE
)
;
}
catch
(
e
)
{
}
if
(
matchOS
)
{
return
Services
.
locale
.
getLocaleComponentForUserAgent
(
)
;
}
try
{
let
locale
=
Services
.
prefs
.
getComplexValue
(
PREF_SELECTED_LOCALE
Ci
.
nsIPrefLocalizedString
)
;
if
(
locale
)
{
return
locale
.
data
;
}
}
catch
(
e
)
{
}
try
{
return
Services
.
prefs
.
getCharPref
(
PREF_SELECTED_LOCALE
)
;
}
catch
(
e
)
{
}
return
"
en
-
US
"
;
}
_setDefaultEnhanced
:
function
DirectoryLinksProvider_setDefaultEnhanced
(
)
{
if
(
!
Services
.
prefs
.
prefHasUserValue
(
PREF_NEWTAB_ENHANCED
)
)
{
let
enhanced
=
Services
.
prefs
.
getBoolPref
(
PREF_NEWTAB_ENHANCED
)
;
try
{
if
(
Services
.
prefs
.
getBoolPref
(
"
privacy
.
donottrackheader
.
enabled
"
)
)
{
enhanced
=
false
;
}
}
catch
(
ex
)
{
}
Services
.
prefs
.
setBoolPref
(
PREF_NEWTAB_ENHANCED
enhanced
)
;
}
}
observe
:
function
DirectoryLinksProvider_observe
(
aSubject
aTopic
aData
)
{
if
(
aTopic
=
=
"
nsPref
:
changed
"
)
{
switch
(
aData
)
{
case
this
.
_observedPrefs
.
enhanced
:
this
.
_setDefaultEnhanced
(
)
;
break
;
case
this
.
_observedPrefs
.
linksURL
:
delete
this
.
__linksURL
;
case
this
.
_observedPrefs
.
matchOSLocale
:
case
this
.
_observedPrefs
.
prefSelectedLocale
:
this
.
_fetchAndCacheLinksIfNecessary
(
true
)
;
break
;
}
}
}
_addPrefsObserver
:
function
DirectoryLinksProvider_addObserver
(
)
{
for
(
let
pref
in
this
.
_observedPrefs
)
{
let
prefName
=
this
.
_observedPrefs
[
pref
]
;
Services
.
prefs
.
addObserver
(
prefName
this
false
)
;
}
}
_removePrefsObserver
:
function
DirectoryLinksProvider_removeObserver
(
)
{
for
(
let
pref
in
this
.
_observedPrefs
)
{
let
prefName
=
this
.
_observedPrefs
[
pref
]
;
Services
.
prefs
.
removeObserver
(
prefName
this
)
;
}
}
_cacheSuggestedLinks
:
function
(
link
)
{
if
(
!
link
.
frecent_sites
)
{
return
;
}
for
(
let
suggestedSite
of
link
.
frecent_sites
)
{
let
suggestedMap
=
this
.
_suggestedLinks
.
get
(
suggestedSite
)
|
|
new
Map
(
)
;
suggestedMap
.
set
(
link
.
url
link
)
;
this
.
_setupStartEndTime
(
link
)
;
this
.
_suggestedLinks
.
set
(
suggestedSite
suggestedMap
)
;
}
}
_fetchAndCacheLinks
:
function
DirectoryLinksProvider_fetchAndCacheLinks
(
uri
)
{
uri
=
uri
.
replace
(
"
%
LOCALE
%
"
this
.
locale
)
;
uri
=
uri
.
replace
(
"
%
CHANNEL
%
"
UpdateUtils
.
UpdateChannel
)
;
return
this
.
_downloadJsonData
(
uri
)
.
then
(
json
=
>
{
return
OS
.
File
.
writeAtomic
(
this
.
_directoryFilePath
json
{
tmpPath
:
this
.
_directoryFilePath
+
"
.
tmp
"
}
)
;
}
)
;
}
_downloadJsonData
:
function
DirectoryLinksProvider__downloadJsonData
(
uri
)
{
let
deferred
=
Promise
.
defer
(
)
;
let
xmlHttp
=
this
.
_newXHR
(
)
;
xmlHttp
.
onload
=
function
(
aResponse
)
{
let
json
=
this
.
responseText
;
if
(
this
.
status
&
&
this
.
status
!
=
200
)
{
json
=
"
{
}
"
;
}
deferred
.
resolve
(
json
)
;
}
;
xmlHttp
.
onerror
=
function
(
e
)
{
deferred
.
reject
(
"
Fetching
"
+
uri
+
"
results
in
error
code
:
"
+
e
.
target
.
status
)
;
}
;
try
{
xmlHttp
.
open
(
"
GET
"
uri
)
;
xmlHttp
.
overrideMimeType
(
DIRECTORY_LINKS_TYPE
)
;
xmlHttp
.
setRequestHeader
(
"
Content
-
Type
"
DIRECTORY_LINKS_TYPE
)
;
xmlHttp
.
send
(
)
;
}
catch
(
e
)
{
deferred
.
reject
(
"
Error
fetching
"
+
uri
)
;
Cu
.
reportError
(
e
)
;
}
return
deferred
.
promise
;
}
_fetchAndCacheLinksIfNecessary
:
function
DirectoryLinksProvider_fetchAndCacheLinksIfNecessary
(
forceDownload
=
false
)
{
if
(
this
.
_downloadDeferred
)
{
return
this
.
_downloadDeferred
.
promise
;
}
if
(
forceDownload
|
|
this
.
_needsDownload
)
{
this
.
_downloadDeferred
=
Promise
.
defer
(
)
;
this
.
_fetchAndCacheLinks
(
this
.
_linksURL
)
.
then
(
(
)
=
>
{
this
.
_lastDownloadMS
=
Date
.
now
(
)
;
this
.
_downloadDeferred
.
resolve
(
)
;
this
.
_downloadDeferred
=
null
;
this
.
_callObservers
(
"
onManyLinksChanged
"
)
}
error
=
>
{
this
.
_downloadDeferred
.
resolve
(
)
;
this
.
_downloadDeferred
=
null
;
this
.
_callObservers
(
"
onDownloadFail
"
)
;
}
)
;
return
this
.
_downloadDeferred
.
promise
;
}
return
Promise
.
resolve
(
)
;
}
get
_needsDownload
(
)
{
if
(
(
Date
.
now
(
)
-
this
.
_lastDownloadMS
)
>
this
.
_downloadIntervalMS
)
{
return
true
;
}
return
false
;
}
_newXHR
(
)
{
return
new
XMLHttpRequest
(
{
mozAnon
:
true
}
)
;
}
_readDirectoryLinksFile
:
function
DirectoryLinksProvider_readDirectoryLinksFile
(
)
{
let
emptyOutput
=
{
directory
:
[
]
suggested
:
[
]
enhanced
:
[
]
}
;
return
OS
.
File
.
read
(
this
.
_directoryFilePath
)
.
then
(
binaryData
=
>
{
let
output
;
try
{
let
json
=
gTextDecoder
.
decode
(
binaryData
)
;
let
linksObj
=
JSON
.
parse
(
json
)
;
output
=
{
directory
:
linksObj
.
directory
|
|
[
]
suggested
:
linksObj
.
suggested
|
|
[
]
enhanced
:
linksObj
.
enhanced
|
|
[
]
}
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
return
output
|
|
emptyOutput
;
}
error
=
>
{
Cu
.
reportError
(
error
)
;
return
emptyOutput
;
}
)
;
}
_setupStartEndTime
:
function
DirectoryLinksProvider_setupStartEndTime
(
link
)
{
if
(
!
link
.
time_limits
)
{
return
;
}
let
parsedTime
;
if
(
link
.
time_limits
.
start
)
{
parsedTime
=
Date
.
parse
(
link
.
time_limits
.
start
)
;
if
(
parsedTime
&
&
!
isNaN
(
parsedTime
)
)
{
link
.
startTime
=
parsedTime
;
}
}
if
(
link
.
time_limits
.
end
)
{
parsedTime
=
Date
.
parse
(
link
.
time_limits
.
end
)
;
if
(
parsedTime
&
&
!
isNaN
(
parsedTime
)
)
{
link
.
endTime
=
parsedTime
;
}
}
}
_onCampaignTimeout
:
function
DirectoryLinksProvider_onCampaignTimeout
(
)
{
this
.
_campaignTimeoutID
=
null
;
this
.
_updateSuggestedTile
(
)
;
}
_clearCampaignTimeout
:
function
DirectoryLinksProvider_clearCampaignTimeout
(
)
{
if
(
this
.
_campaignTimeoutID
)
{
clearTimeout
(
this
.
_campaignTimeoutID
)
;
this
.
_campaignTimeoutID
=
null
;
}
}
_setupCampaignTimeCheck
:
function
DirectoryLinksProvider_setupCampaignTimeCheck
(
timeout
)
{
if
(
!
timeout
|
|
timeout
<
=
0
)
{
return
;
}
this
.
_clearCampaignTimeout
(
)
;
this
.
_campaignTimeoutID
=
setTimeout
(
this
.
_onCampaignTimeout
.
bind
(
this
)
timeout
)
;
}
_testLinkForCampaignTimeLimits
:
function
DirectoryLinksProvider_testLinkForCampaignTimeLimits
(
link
)
{
let
currentTime
=
Date
.
now
(
)
;
if
(
link
.
startTime
&
&
link
.
startTime
>
currentTime
)
{
return
{
use
:
false
timeoutDate
:
link
.
startTime
}
;
}
if
(
link
.
endTime
)
{
if
(
link
.
endTime
<
=
currentTime
)
{
return
{
use
:
false
}
;
}
return
{
use
:
true
timeoutDate
:
link
.
endTime
}
;
}
return
{
use
:
true
}
;
}
handleSuggestedTileBlock
:
function
DirectoryLinksProvider_handleSuggestedTileBlock
(
)
{
this
.
_updateFrequencyCapSettings
(
{
url
:
FAKE_SUGGESTED_BLOCK_URL
}
)
;
this
.
_writeFrequencyCapFile
(
)
;
}
_isSuggestedTileBlocked
:
function
DirectoryLinksProvider__isSuggestedTileBlocked
(
)
{
let
capObject
=
this
.
_frequencyCaps
[
FAKE_SUGGESTED_BLOCK_URL
]
;
if
(
!
capObject
|
|
!
capObject
.
lastUpdated
)
{
return
false
;
}
return
(
capObject
.
lastUpdated
+
AFTER_SUGGESTED_BLOCK_DECAY_TIME
)
>
Date
.
now
(
)
;
}
reportSitesAction
:
function
DirectoryLinksProvider_reportSitesAction
(
sites
action
triggeringSiteIndex
)
{
let
pastImpressions
;
if
(
action
=
=
"
view
"
)
{
sites
.
slice
(
0
triggeringSiteIndex
+
1
)
.
filter
(
s
=
>
s
)
.
forEach
(
site
=
>
{
let
{
targetedSite
url
}
=
site
.
link
;
if
(
targetedSite
)
{
this
.
_addFrequencyCapView
(
url
)
;
}
}
)
;
}
else
{
let
{
frecent_sites
targetedSite
url
}
=
sites
[
triggeringSiteIndex
]
.
link
;
if
(
frecent_sites
|
|
targetedSite
)
{
if
(
this
.
_frequencyCaps
[
url
]
&
&
action
!
=
"
unpin
"
)
{
pastImpressions
=
{
total
:
this
.
_frequencyCaps
[
url
]
.
totalViews
daily
:
this
.
_frequencyCaps
[
url
]
.
dailyViews
}
;
}
this
.
_setFrequencyCapClick
(
url
)
;
}
}
let
newtabEnhanced
=
false
;
let
pingEndPoint
=
"
"
;
try
{
newtabEnhanced
=
Services
.
prefs
.
getBoolPref
(
PREF_NEWTAB_ENHANCED
)
;
pingEndPoint
=
Services
.
prefs
.
getCharPref
(
PREF_DIRECTORY_PING
)
;
}
catch
(
ex
)
{
}
let
invalidAction
=
PING_ACTIONS
.
indexOf
(
action
)
=
=
-
1
;
if
(
!
newtabEnhanced
|
|
pingEndPoint
=
=
"
"
|
|
invalidAction
)
{
return
Promise
.
resolve
(
)
;
}
let
actionIndex
;
let
data
=
{
locale
:
this
.
locale
tiles
:
sites
.
reduce
(
(
tiles
site
pos
)
=
>
{
if
(
site
)
{
let
{
link
}
=
site
;
let
tilesIndex
=
tiles
.
length
;
if
(
triggeringSiteIndex
=
=
pos
)
{
actionIndex
=
tilesIndex
;
}
let
id
=
link
.
directoryId
;
tiles
.
push
(
{
id
:
id
|
|
site
.
enhancedId
pin
:
site
.
isPinned
(
)
?
1
:
undefined
pos
:
pos
!
=
tilesIndex
?
pos
:
undefined
past_impressions
:
pos
=
=
triggeringSiteIndex
?
pastImpressions
:
undefined
score
:
Math
.
round
(
link
.
frecency
/
PING_SCORE_DIVISOR
)
|
|
undefined
url
:
site
.
enhancedId
&
&
"
"
}
)
;
}
return
tiles
;
}
[
]
)
}
;
if
(
actionIndex
!
=
=
undefined
)
{
data
[
action
]
=
actionIndex
;
}
let
ping
=
this
.
_newXHR
(
)
;
ping
.
open
(
"
POST
"
pingEndPoint
+
(
action
=
=
"
view
"
?
"
view
"
:
"
click
"
)
)
;
ping
.
send
(
JSON
.
stringify
(
data
)
)
;
return
Task
.
spawn
(
function
*
(
)
{
yield
this
.
_writeFrequencyCapFile
(
)
;
yield
this
.
_fetchAndCacheLinksIfNecessary
(
)
;
}
.
bind
(
this
)
)
;
}
getEnhancedLink
:
function
DirectoryLinksProvider_getEnhancedLink
(
link
)
{
return
link
.
enhancedImageURI
&
&
link
?
link
:
this
.
_enhancedLinks
.
get
(
NewTabUtils
.
extractSite
(
link
.
url
)
)
;
}
isURLAllowed
(
url
allowed
checkBase
)
{
if
(
!
url
)
{
return
true
;
}
let
scheme
=
"
"
base
=
"
"
;
try
{
let
uri
=
Services
.
io
.
newURI
(
url
null
null
)
;
scheme
=
uri
.
scheme
;
base
=
Services
.
eTLD
.
getBaseDomain
(
uri
)
;
}
catch
(
ex
)
{
}
return
allowed
.
has
(
scheme
)
&
&
(
!
checkBase
|
|
ALLOWED_URL_BASE
.
has
(
base
)
)
;
}
_escapeChars
(
text
)
{
let
charMap
=
{
'
&
'
:
'
&
amp
;
'
'
<
'
:
'
&
lt
;
'
'
>
'
:
'
&
gt
;
'
'
"
'
:
'
&
quot
;
'
"
'
"
:
'
&
#
039
;
'
}
;
return
text
.
replace
(
/
[
&
<
>
"
'
]
/
g
(
character
)
=
>
charMap
[
character
]
)
;
}
getLinks
:
function
DirectoryLinksProvider_getLinks
(
aCallback
)
{
this
.
_readDirectoryLinksFile
(
)
.
then
(
rawLinks
=
>
{
this
.
_enhancedLinks
.
clear
(
)
;
this
.
_suggestedLinks
.
clear
(
)
;
this
.
_clearCampaignTimeout
(
)
;
this
.
_avoidInadjacentSites
=
false
;
let
checkBase
=
!
this
.
__linksURLModified
;
let
validityFilter
=
function
(
link
)
{
return
this
.
isURLAllowed
(
link
.
url
ALLOWED_LINK_SCHEMES
false
)
&
&
this
.
isURLAllowed
(
link
.
imageURI
ALLOWED_IMAGE_SCHEMES
checkBase
)
&
&
this
.
isURLAllowed
(
link
.
enhancedImageURI
ALLOWED_IMAGE_SCHEMES
checkBase
)
;
}
.
bind
(
this
)
;
rawLinks
.
suggested
.
filter
(
validityFilter
)
.
forEach
(
(
link
position
)
=
>
{
if
(
!
link
.
adgroup_name
)
{
return
;
}
let
sanitizeFlags
=
ParserUtils
.
SanitizerCidEmbedsOnly
|
ParserUtils
.
SanitizerDropForms
|
ParserUtils
.
SanitizerDropNonCSSPresentation
;
link
.
explanation
=
this
.
_escapeChars
(
link
.
explanation
?
ParserUtils
.
convertToPlainText
(
link
.
explanation
sanitizeFlags
0
)
:
"
"
)
;
link
.
targetedName
=
this
.
_escapeChars
(
ParserUtils
.
convertToPlainText
(
link
.
adgroup_name
sanitizeFlags
0
)
)
;
link
.
lastVisitDate
=
rawLinks
.
suggested
.
length
-
position
;
if
(
link
.
check_inadjacency
)
{
this
.
_avoidInadjacentSites
=
true
;
}
this
.
_cacheSuggestedLinks
(
link
)
;
this
.
_updateFrequencyCapSettings
(
link
)
;
}
)
;
rawLinks
.
enhanced
.
filter
(
validityFilter
)
.
forEach
(
(
link
position
)
=
>
{
link
.
lastVisitDate
=
rawLinks
.
enhanced
.
length
-
position
;
if
(
link
.
enhancedImageURI
)
{
this
.
_enhancedLinks
.
set
(
NewTabUtils
.
extractSite
(
link
.
url
)
link
)
;
}
}
)
;
let
links
=
rawLinks
.
directory
.
filter
(
validityFilter
)
.
map
(
(
link
position
)
=
>
{
link
.
lastVisitDate
=
rawLinks
.
directory
.
length
-
position
;
link
.
frecency
=
DIRECTORY_FRECENCY
;
return
link
;
}
)
;
this
.
maxNumLinks
=
links
.
length
+
1
;
this
.
_pruneFrequencyCapUrls
(
)
;
this
.
_writeFrequencyCapFile
(
)
;
return
links
;
}
)
.
catch
(
ex
=
>
{
Cu
.
reportError
(
ex
)
;
return
[
]
;
}
)
.
then
(
links
=
>
{
aCallback
(
links
)
;
this
.
_populatePlacesLinks
(
)
;
}
)
;
}
init
:
function
DirectoryLinksProvider_init
(
)
{
this
.
_setDefaultEnhanced
(
)
;
this
.
_addPrefsObserver
(
)
;
this
.
_directoryFilePath
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
localProfileDir
DIRECTORY_LINKS_FILE
)
;
this
.
_lastDownloadMS
=
0
;
this
.
_frequencyCapFilePath
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
localProfileDir
FREQUENCY_CAP_FILE
)
;
this
.
_inadjacentSitesUrl
=
INADJACENCY_SOURCE
;
NewTabUtils
.
placesProvider
.
addObserver
(
this
)
;
NewTabUtils
.
links
.
addObserver
(
this
)
;
RemoteNewTabUtils
.
placesProvider
.
addObserver
(
this
)
;
RemoteNewTabUtils
.
links
.
addObserver
(
this
)
;
return
Task
.
spawn
(
function
(
)
{
let
doesFileExists
=
yield
OS
.
File
.
exists
(
this
.
_directoryFilePath
)
;
if
(
doesFileExists
)
{
let
fileInfo
=
yield
OS
.
File
.
stat
(
this
.
_directoryFilePath
)
;
this
.
_lastDownloadMS
=
Date
.
parse
(
fileInfo
.
lastModificationDate
)
;
}
yield
this
.
_readFrequencyCapFile
(
)
;
yield
this
.
_fetchAndCacheLinksIfNecessary
(
)
;
yield
this
.
_loadInadjacentSites
(
)
;
}
.
bind
(
this
)
)
;
}
_handleManyLinksChanged
:
function
(
)
{
this
.
_topSitesWithSuggestedLinks
.
clear
(
)
;
this
.
_suggestedLinks
.
forEach
(
(
suggestedLinks
site
)
=
>
{
if
(
NewTabUtils
.
isTopPlacesSite
(
site
)
)
{
this
.
_topSitesWithSuggestedLinks
.
add
(
site
)
;
}
}
)
;
this
.
_updateSuggestedTile
(
)
;
}
_handleLinkChanged
:
function
(
aLink
)
{
let
changedLinkSite
=
NewTabUtils
.
extractSite
(
aLink
.
url
)
;
let
linkStored
=
this
.
_topSitesWithSuggestedLinks
.
has
(
changedLinkSite
)
;
if
(
!
NewTabUtils
.
isTopPlacesSite
(
changedLinkSite
)
&
&
linkStored
)
{
this
.
_topSitesWithSuggestedLinks
.
delete
(
changedLinkSite
)
;
return
true
;
}
if
(
this
.
_suggestedLinks
.
has
(
changedLinkSite
)
&
&
NewTabUtils
.
isTopPlacesSite
(
changedLinkSite
)
&
&
!
linkStored
)
{
this
.
_topSitesWithSuggestedLinks
.
add
(
changedLinkSite
)
;
return
true
;
}
if
(
this
.
_avoidInadjacentSites
&
&
this
.
_isInadjacentLink
(
aLink
)
)
{
return
true
;
}
return
false
;
}
_populatePlacesLinks
:
function
(
)
{
NewTabUtils
.
links
.
populateProviderCache
(
NewTabUtils
.
placesProvider
(
)
=
>
{
this
.
_handleManyLinksChanged
(
)
;
}
)
;
}
onDeleteURI
:
function
(
aProvider
aLink
)
{
let
{
url
}
=
aLink
;
this
.
_removeTileClick
(
url
)
.
then
(
(
)
=
>
{
this
.
_callObservers
(
"
onDeleteURI
"
url
)
;
}
)
;
}
onClearHistory
:
function
(
)
{
this
.
_removeAllTileClicks
(
)
.
then
(
(
)
=
>
{
this
.
_callObservers
(
"
onClearHistory
"
)
;
}
)
;
}
onLinkChanged
:
function
(
aProvider
aLink
)
{
setTimeout
(
(
)
=
>
{
if
(
this
.
_handleLinkChanged
(
aLink
)
|
|
this
.
_shouldUpdateSuggestedTile
(
)
)
{
this
.
_updateSuggestedTile
(
)
;
}
}
0
)
;
}
onManyLinksChanged
:
function
(
)
{
setTimeout
(
(
)
=
>
{
this
.
_handleManyLinksChanged
(
)
;
}
0
)
;
}
_getCurrentTopSiteCount
:
function
(
)
{
let
visibleTopSiteCount
=
0
;
let
newTabLinks
=
NewTabUtils
.
links
.
getLinks
(
)
;
for
(
let
link
of
newTabLinks
.
slice
(
0
MIN_VISIBLE_HISTORY_TILES
)
)
{
if
(
link
&
&
(
link
.
type
=
=
"
history
"
|
|
link
.
type
=
=
"
enhanced
"
)
)
{
visibleTopSiteCount
+
+
;
}
}
this
.
_newTabHasInadjacentSite
=
this
.
_avoidInadjacentSites
&
&
this
.
_checkForInadjacentSites
(
newTabLinks
)
;
return
visibleTopSiteCount
;
}
_shouldUpdateSuggestedTile
:
function
(
)
{
let
sortedLinks
=
NewTabUtils
.
getProviderLinks
(
this
)
;
let
mostFrecentLink
=
{
}
;
if
(
sortedLinks
&
&
sortedLinks
.
length
)
{
mostFrecentLink
=
sortedLinks
[
0
]
}
let
currTopSiteCount
=
this
.
_getCurrentTopSiteCount
(
)
;
if
(
(
!
mostFrecentLink
.
targetedSite
&
&
currTopSiteCount
>
=
MIN_VISIBLE_HISTORY_TILES
)
|
|
(
mostFrecentLink
.
targetedSite
&
&
currTopSiteCount
<
MIN_VISIBLE_HISTORY_TILES
)
)
{
return
true
;
}
return
false
;
}
_updateSuggestedTile
:
function
(
)
{
let
sortedLinks
=
NewTabUtils
.
getProviderLinks
(
this
)
;
if
(
!
sortedLinks
)
{
return
;
}
let
initialLength
=
sortedLinks
.
length
;
if
(
initialLength
)
{
let
mostFrecentLink
=
sortedLinks
[
0
]
;
if
(
mostFrecentLink
.
targetedSite
)
{
this
.
_callObservers
(
"
onLinkChanged
"
{
url
:
mostFrecentLink
.
url
frecency
:
SUGGESTED_FRECENCY
lastVisitDate
:
mostFrecentLink
.
lastVisitDate
type
:
mostFrecentLink
.
type
}
0
true
)
;
}
}
if
(
this
.
_topSitesWithSuggestedLinks
.
size
=
=
0
|
|
!
this
.
_shouldUpdateSuggestedTile
(
)
|
|
this
.
_isSuggestedTileBlocked
(
)
)
{
return
;
}
let
nextTimeout
;
let
possibleLinks
=
new
Map
(
)
;
let
targetedSites
=
new
Map
(
)
;
this
.
_topSitesWithSuggestedLinks
.
forEach
(
topSiteWithSuggestedLink
=
>
{
let
suggestedLinksMap
=
this
.
_suggestedLinks
.
get
(
topSiteWithSuggestedLink
)
;
suggestedLinksMap
.
forEach
(
(
suggestedLink
url
)
=
>
{
if
(
!
this
.
_testFrequencyCapLimits
(
url
)
)
{
return
;
}
let
{
use
timeoutDate
}
=
this
.
_testLinkForCampaignTimeLimits
(
suggestedLink
)
;
if
(
timeoutDate
&
&
(
!
nextTimeout
|
|
nextTimeout
>
timeoutDate
)
)
{
nextTimeout
=
timeoutDate
;
}
if
(
!
use
)
{
return
;
}
if
(
suggestedLink
.
check_inadjacency
&
&
this
.
_newTabHasInadjacentSite
)
{
return
;
}
possibleLinks
.
set
(
url
suggestedLink
)
;
if
(
!
targetedSites
.
get
(
url
)
)
{
targetedSites
.
set
(
url
[
]
)
;
}
targetedSites
.
get
(
url
)
.
push
(
topSiteWithSuggestedLink
)
;
}
)
}
)
;
if
(
nextTimeout
)
{
this
.
_setupCampaignTimeCheck
(
nextTimeout
-
Date
.
now
(
)
)
;
}
let
numLinks
=
possibleLinks
.
size
;
if
(
numLinks
=
=
0
)
{
return
;
}
let
flattenedLinks
=
[
.
.
.
possibleLinks
.
values
(
)
]
;
let
suggestedIndex
=
Math
.
floor
(
Math
.
random
(
)
*
numLinks
)
;
let
chosenSuggestedLink
=
flattenedLinks
[
suggestedIndex
]
;
this
.
_callObservers
(
"
onLinkChanged
"
Object
.
assign
(
{
frecency
:
SUGGESTED_FRECENCY
targetedSite
:
targetedSites
.
get
(
chosenSuggestedLink
.
url
)
.
length
?
targetedSites
.
get
(
chosenSuggestedLink
.
url
)
[
0
]
:
null
}
chosenSuggestedLink
)
)
;
return
chosenSuggestedLink
;
}
_loadInadjacentSites
:
function
DirectoryLinksProvider_loadInadjacentSites
(
)
{
return
this
.
_downloadJsonData
(
this
.
_inadjacentSitesUrl
)
.
then
(
jsonString
=
>
{
let
jsonObject
=
{
}
;
try
{
jsonObject
=
JSON
.
parse
(
jsonString
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
this
.
_inadjacentSites
=
new
Set
(
jsonObject
.
domains
)
;
}
)
;
}
_generateHash
:
function
DirectoryLinksProvider_generateHash
(
value
)
{
let
byteArr
=
gUnicodeConverter
.
convertToByteArray
(
value
)
;
gCryptoHash
.
init
(
gCryptoHash
.
MD5
)
;
gCryptoHash
.
update
(
byteArr
byteArr
.
length
)
;
return
gCryptoHash
.
finish
(
true
)
;
}
_isInadjacentLink
:
function
DirectoryLinksProvider_isInadjacentLink
(
link
)
{
let
baseDomain
=
link
.
baseDomain
|
|
NewTabUtils
.
extractSite
(
link
.
url
|
|
"
"
)
;
if
(
!
baseDomain
)
{
return
false
;
}
return
this
.
_inadjacentSites
.
has
(
this
.
_generateHash
(
baseDomain
)
)
;
}
_checkForInadjacentSites
:
function
DirectoryLinksProvider_checkForInadjacentSites
(
newTabLink
)
{
let
links
=
newTabLink
|
|
NewTabUtils
.
links
.
getLinks
(
)
;
for
(
let
link
of
links
.
slice
(
0
MAX_VISIBLE_HISTORY_TILES
)
)
{
if
(
this
.
_isInadjacentLink
(
link
)
)
{
return
true
;
}
}
return
false
;
}
_readJsonFile
:
Task
.
async
(
function
*
(
filePath
nullObject
)
{
let
jsonObj
;
try
{
let
binaryData
=
yield
OS
.
File
.
read
(
filePath
)
;
let
json
=
gTextDecoder
.
decode
(
binaryData
)
;
jsonObj
=
JSON
.
parse
(
json
)
;
}
catch
(
e
)
{
}
return
jsonObj
|
|
nullObject
;
}
)
_readFrequencyCapFile
:
Task
.
async
(
function
*
(
)
{
this
.
_frequencyCaps
=
yield
this
.
_readJsonFile
(
this
.
_frequencyCapFilePath
{
}
)
;
}
)
_writeFrequencyCapFile
:
function
DirectoryLinksProvider_writeFrequencyCapFile
(
)
{
let
json
=
JSON
.
stringify
(
this
.
_frequencyCaps
|
|
{
}
)
;
return
OS
.
File
.
writeAtomic
(
this
.
_frequencyCapFilePath
json
{
tmpPath
:
this
.
_frequencyCapFilePath
+
"
.
tmp
"
}
)
;
}
_clearFrequencyCap
:
function
DirectoryLinksProvider_clearFrequencyCap
(
)
{
this
.
_frequencyCaps
=
{
}
;
return
this
.
_writeFrequencyCapFile
(
)
;
}
_updateFrequencyCapSettings
:
function
DirectoryLinksProvider_updateFrequencyCapSettings
(
link
)
{
let
capsObject
=
this
.
_frequencyCaps
[
link
.
url
]
;
if
(
!
capsObject
)
{
capsObject
=
{
dailyViews
:
0
totalViews
:
0
lastShownDate
:
0
}
;
this
.
_frequencyCaps
[
link
.
url
]
=
capsObject
;
}
capsObject
.
lastUpdated
=
Date
.
now
(
)
;
if
(
link
.
frequency_caps
)
{
capsObject
.
dailyCap
=
link
.
frequency_caps
.
daily
|
|
DEFAULT_DAILY_FREQUENCY_CAP
;
capsObject
.
totalCap
=
link
.
frequency_caps
.
total
|
|
DEFAULT_TOTAL_FREQUENCY_CAP
;
}
else
{
capsObject
.
dailyCap
=
DEFAULT_DAILY_FREQUENCY_CAP
;
capsObject
.
totalCap
=
DEFAULT_TOTAL_FREQUENCY_CAP
;
}
}
_pruneFrequencyCapUrls
:
function
DirectoryLinksProvider_pruneFrequencyCapUrls
(
timeDelta
=
DEFAULT_PRUNE_TIME_DELTA
)
{
let
timeThreshold
=
Date
.
now
(
)
-
timeDelta
;
Object
.
keys
(
this
.
_frequencyCaps
)
.
forEach
(
url
=
>
{
if
(
!
url
.
startsWith
(
"
ignore
"
)
&
&
this
.
_frequencyCaps
[
url
]
.
lastUpdated
<
=
timeThreshold
)
{
delete
this
.
_frequencyCaps
[
url
]
;
}
}
)
;
}
_wasToday
:
function
DirectoryLinksProvider_wasToday
(
timestamp
)
{
let
showOn
=
new
Date
(
timestamp
)
;
let
today
=
new
Date
(
)
;
return
showOn
.
getDate
(
)
=
=
today
.
getDate
(
)
&
&
showOn
.
getMonth
(
)
=
=
today
.
getMonth
(
)
&
&
showOn
.
getYear
(
)
=
=
today
.
getYear
(
)
;
}
_addFrequencyCapView
:
function
DirectoryLinksProvider_addFrequencyCapView
(
url
)
{
let
capObject
=
this
.
_frequencyCaps
[
url
]
;
if
(
!
capObject
)
{
return
;
}
if
(
!
this
.
_wasToday
(
capObject
.
lastShownDate
)
)
{
capObject
.
dailyViews
=
0
;
capObject
.
lastShownDate
=
Date
.
now
(
)
;
}
capObject
.
totalViews
+
+
;
capObject
.
dailyViews
+
+
;
if
(
capObject
.
totalViews
>
=
capObject
.
totalCap
|
|
capObject
.
dailyViews
>
=
capObject
.
dailyCap
)
{
this
.
_updateSuggestedTile
(
)
;
}
}
_setFrequencyCapClick
(
url
)
{
let
capObject
=
this
.
_frequencyCaps
[
url
]
;
if
(
!
capObject
)
{
return
;
}
capObject
.
clicked
=
true
;
this
.
_updateSuggestedTile
(
)
;
}
_testFrequencyCapLimits
:
function
DirectoryLinksProvider_testFrequencyCapLimits
(
url
)
{
let
capObject
=
this
.
_frequencyCaps
[
url
]
;
if
(
!
capObject
)
{
return
false
;
}
if
(
capObject
.
clicked
|
|
capObject
.
totalViews
>
=
capObject
.
totalCap
)
{
return
false
;
}
if
(
this
.
_wasToday
(
capObject
.
lastShownDate
)
&
&
capObject
.
dailyViews
>
=
capObject
.
dailyCap
)
{
return
false
;
}
return
true
;
}
_removeTileClick
:
function
DirectoryLinksProvider_removeTileClick
(
url
=
"
"
)
{
let
noTrailingSlashUrl
=
url
.
replace
(
/
\
/
/
"
"
)
;
let
capObject
=
this
.
_frequencyCaps
[
url
]
|
|
this
.
_frequencyCaps
[
noTrailingSlashUrl
]
;
if
(
!
capObject
)
{
return
Promise
.
resolve
(
)
;
}
delete
capObject
.
clicked
;
return
this
.
_writeFrequencyCapFile
(
)
;
}
_removeAllTileClicks
:
function
DirectoryLinksProvider_removeAllTileClicks
(
)
{
Object
.
keys
(
this
.
_frequencyCaps
)
.
forEach
(
url
=
>
{
delete
this
.
_frequencyCaps
[
url
]
.
clicked
;
}
)
;
return
this
.
_writeFrequencyCapFile
(
)
;
}
reset
:
function
DirectoryLinksProvider_reset
(
)
{
delete
this
.
__linksURL
;
this
.
_removePrefsObserver
(
)
;
this
.
_removeObservers
(
)
;
}
addObserver
:
function
DirectoryLinksProvider_addObserver
(
aObserver
)
{
this
.
_observers
.
add
(
aObserver
)
;
}
removeObserver
:
function
DirectoryLinksProvider_removeObserver
(
aObserver
)
{
this
.
_observers
.
delete
(
aObserver
)
;
}
_callObservers
(
methodName
.
.
.
args
)
{
for
(
let
obs
of
this
.
_observers
)
{
if
(
typeof
(
obs
[
methodName
]
)
=
=
"
function
"
)
{
try
{
obs
[
methodName
]
(
this
.
.
.
args
)
;
}
catch
(
err
)
{
Cu
.
reportError
(
err
)
;
}
}
}
}
_removeObservers
:
function
(
)
{
this
.
_observers
.
clear
(
)
;
}
}
;
