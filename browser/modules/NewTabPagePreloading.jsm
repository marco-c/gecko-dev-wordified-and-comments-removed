var
EXPORTED_SYMBOLS
=
[
"
NewTabPagePreloading
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AboutNewTab
:
"
resource
:
/
/
/
modules
/
AboutNewTab
.
jsm
"
BrowserWindowTracker
:
"
resource
:
/
/
/
modules
/
BrowserWindowTracker
.
jsm
"
E10SUtils
:
"
resource
:
/
/
gre
/
modules
/
E10SUtils
.
jsm
"
PrivateBrowsingUtils
:
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
}
)
;
let
NewTabPagePreloading
=
{
MAX_COUNT
:
3
browserCounts
:
{
normal
:
0
private
:
0
}
get
enabled
(
)
{
return
(
this
.
prefEnabled
&
&
this
.
newTabEnabled
&
&
!
AboutNewTab
.
newTabURLOverridden
)
;
}
_createBrowser
(
win
)
{
const
{
gBrowser
gMultiProcessBrowser
gFissionBrowser
BROWSER_NEW_TAB_URL
}
=
win
;
let
remoteType
=
E10SUtils
.
getRemoteTypeForURI
(
BROWSER_NEW_TAB_URL
gMultiProcessBrowser
gFissionBrowser
)
;
let
browser
=
gBrowser
.
createBrowser
(
{
isPreloadBrowser
:
true
remoteType
}
)
;
gBrowser
.
preloadedBrowser
=
browser
;
let
panel
=
gBrowser
.
getPanel
(
browser
)
;
gBrowser
.
tabpanels
.
appendChild
(
panel
)
;
return
browser
;
}
_adoptBrowserFromOtherWindow
(
window
)
{
let
winPrivate
=
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
;
let
oldWin
=
BrowserWindowTracker
.
orderedWindows
.
filter
(
w
=
>
{
return
(
winPrivate
=
=
PrivateBrowsingUtils
.
isWindowPrivate
(
w
)
&
&
w
.
gBrowser
&
&
w
.
gBrowser
.
preloadedBrowser
)
;
}
)
.
pop
(
)
;
if
(
!
oldWin
)
{
return
null
;
}
let
oldBrowser
=
oldWin
.
gBrowser
.
preloadedBrowser
;
oldWin
.
gBrowser
.
preloadedBrowser
=
null
;
let
newBrowser
=
this
.
_createBrowser
(
window
)
;
oldBrowser
.
swapBrowsers
(
newBrowser
)
;
newBrowser
.
permanentKey
=
oldBrowser
.
permanentKey
;
oldWin
.
gBrowser
.
getPanel
(
oldBrowser
)
.
remove
(
)
;
return
newBrowser
;
}
maybeCreatePreloadedBrowser
(
window
)
{
if
(
!
this
.
enabled
|
|
window
.
gBrowser
.
preloadedBrowser
|
|
!
window
.
toolbar
.
visible
)
{
return
;
}
let
windowPrivate
=
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
;
let
countKey
=
windowPrivate
?
"
private
"
:
"
normal
"
;
let
topWindows
=
BrowserWindowTracker
.
orderedWindows
.
filter
(
w
=
>
PrivateBrowsingUtils
.
isWindowPrivate
(
w
)
=
=
windowPrivate
)
;
if
(
topWindows
.
indexOf
(
window
)
>
=
this
.
MAX_COUNT
)
{
return
;
}
if
(
this
.
browserCounts
[
countKey
]
>
=
this
.
MAX_COUNT
)
{
let
browser
=
this
.
_adoptBrowserFromOtherWindow
(
window
)
;
if
(
browser
)
{
return
;
}
}
let
browser
=
this
.
_createBrowser
(
window
)
;
browser
.
loadURI
(
window
.
BROWSER_NEW_TAB_URL
{
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
}
)
;
browser
.
docShellIsActive
=
false
;
browser
.
_urlbarFocused
=
true
;
let
tabURI
=
Services
.
io
.
newURI
(
window
.
BROWSER_NEW_TAB_URL
)
;
window
.
FullZoom
.
onLocationChange
(
tabURI
false
browser
)
;
this
.
browserCounts
[
countKey
]
+
+
;
}
getPreloadedBrowser
(
window
)
{
if
(
!
this
.
enabled
)
{
return
null
;
}
let
browser
=
window
.
gBrowser
.
preloadedBrowser
;
window
.
gBrowser
.
preloadedBrowser
=
null
;
if
(
browser
)
{
let
countKey
=
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
?
"
private
"
:
"
normal
"
;
this
.
browserCounts
[
countKey
]
-
-
;
browser
.
setAttribute
(
"
preloadedState
"
"
consumed
"
)
;
browser
.
setAttribute
(
"
autocompletepopup
"
"
PopupAutoComplete
"
)
;
}
return
browser
;
}
removePreloadedBrowser
(
window
)
{
let
browser
=
this
.
getPreloadedBrowser
(
window
)
;
if
(
browser
)
{
window
.
gBrowser
.
getPanel
(
browser
)
.
remove
(
)
;
}
}
}
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
NewTabPagePreloading
"
prefEnabled
"
"
browser
.
newtab
.
preload
"
true
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
NewTabPagePreloading
"
newTabEnabled
"
"
browser
.
newtabpage
.
enabled
"
true
)
;
