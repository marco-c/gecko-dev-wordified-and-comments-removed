"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
AppUpdater
"
]
;
var
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
var
gLogfileOutputStream
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
const
{
FileUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
)
;
const
PREF_APP_UPDATE_LOG
=
"
app
.
update
.
log
"
;
const
PREF_APP_UPDATE_LOG_FILE
=
"
app
.
update
.
log
.
file
"
;
const
KEY_PROFILE_DIR
=
"
ProfD
"
;
const
FILE_UPDATE_MESSAGES
=
"
update_messages
.
log
"
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
UpdateUtils
:
"
resource
:
/
/
gre
/
modules
/
UpdateUtils
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
gLogEnabled
"
function
aus_gLogEnabled
(
)
{
return
(
Services
.
prefs
.
getBoolPref
(
PREF_APP_UPDATE_LOG
false
)
|
|
Services
.
prefs
.
getBoolPref
(
PREF_APP_UPDATE_LOG_FILE
false
)
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
gLogfileEnabled
"
function
aus_gLogfileEnabled
(
)
{
return
Services
.
prefs
.
getBoolPref
(
PREF_APP_UPDATE_LOG_FILE
false
)
;
}
)
;
const
PREF_APP_UPDATE_CANCELATIONS_OSX
=
"
app
.
update
.
cancelations
.
osx
"
;
const
PREF_APP_UPDATE_ELEVATE_NEVER
=
"
app
.
update
.
elevate
.
never
"
;
class
AppUpdater
{
constructor
(
)
{
this
.
_listeners
=
new
Set
(
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
aus
"
"
mozilla
.
org
/
updates
/
update
-
service
;
1
"
"
nsIApplicationUpdateService
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
checker
"
"
mozilla
.
org
/
updates
/
update
-
checker
;
1
"
"
nsIUpdateChecker
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
um
"
"
mozilla
.
org
/
updates
/
update
-
manager
;
1
"
"
nsIUpdateManager
"
)
;
this
.
QueryInterface
=
ChromeUtils
.
generateQI
(
[
"
nsIObserver
"
"
nsIProgressEventSink
"
"
nsIRequestObserver
"
"
nsISupportsWeakReference
"
]
)
;
Services
.
obs
.
addObserver
(
this
"
update
-
swap
"
true
)
;
Services
.
prefs
.
addObserver
(
PREF_APP_UPDATE_LOG
this
)
;
}
check
(
)
{
if
(
!
AppConstants
.
MOZ_UPDATER
|
|
this
.
updateDisabledByPackage
)
{
LOG
(
"
AppUpdater
:
check
-
"
+
"
AppConstants
.
MOZ_UPDATER
=
"
+
AppConstants
.
MOZ_UPDATER
+
"
this
.
updateDisabledByPackage
:
"
+
this
.
updateDisabledByPackage
)
;
this
.
_setStatus
(
AppUpdater
.
STATUS
.
NO_UPDATER
)
;
return
;
}
if
(
this
.
updateDisabledByPolicy
)
{
LOG
(
"
AppUpdater
:
check
-
this
.
updateDisabledByPolicy
"
)
;
this
.
_setStatus
(
AppUpdater
.
STATUS
.
UPDATE_DISABLED_BY_POLICY
)
;
return
;
}
if
(
this
.
isReadyForRestart
)
{
LOG
(
"
AppUpdater
:
check
-
this
.
isReadyForRestart
"
)
;
this
.
_setStatus
(
AppUpdater
.
STATUS
.
READY_FOR_RESTART
)
;
return
;
}
if
(
this
.
aus
.
isOtherInstanceHandlingUpdates
)
{
LOG
(
"
AppUpdater
:
check
-
this
.
aus
.
isOtherInstanceHandlingUpdates
"
)
;
this
.
_setStatus
(
AppUpdater
.
STATUS
.
OTHER_INSTANCE_HANDLING_UPDATES
)
;
return
;
}
if
(
this
.
isDownloading
)
{
LOG
(
"
AppUpdater
:
check
-
this
.
isDownloading
"
)
;
this
.
startDownload
(
)
;
return
;
}
if
(
this
.
isStaging
)
{
LOG
(
"
AppUpdater
:
check
-
this
.
isStaging
"
)
;
this
.
_waitForUpdateToStage
(
)
;
return
;
}
this
.
promiseAutoUpdateSetting
=
lazy
.
UpdateUtils
.
getAppUpdateAutoEnabled
(
)
;
this
.
checkForUpdates
(
)
;
}
get
isPending
(
)
{
if
(
this
.
update
)
{
return
(
this
.
update
.
state
=
=
"
pending
"
|
|
this
.
update
.
state
=
=
"
pending
-
service
"
|
|
this
.
update
.
state
=
=
"
pending
-
elevate
"
)
;
}
return
(
this
.
um
.
readyUpdate
&
&
(
this
.
um
.
readyUpdate
.
state
=
=
"
pending
"
|
|
this
.
um
.
readyUpdate
.
state
=
=
"
pending
-
service
"
|
|
this
.
um
.
readyUpdate
.
state
=
=
"
pending
-
elevate
"
)
)
;
}
get
isApplied
(
)
{
if
(
this
.
update
)
{
return
(
this
.
update
.
state
=
=
"
applied
"
|
|
this
.
update
.
state
=
=
"
applied
-
service
"
)
;
}
return
(
this
.
um
.
readyUpdate
&
&
(
this
.
um
.
readyUpdate
.
state
=
=
"
applied
"
|
|
this
.
um
.
readyUpdate
.
state
=
=
"
applied
-
service
"
)
)
;
}
get
isStaging
(
)
{
if
(
!
this
.
updateStagingEnabled
)
{
return
false
;
}
let
errorCode
;
if
(
this
.
update
)
{
errorCode
=
this
.
update
.
errorCode
;
}
else
if
(
this
.
um
.
readyUpdate
)
{
errorCode
=
this
.
um
.
readyUpdate
.
errorCode
;
}
return
this
.
isPending
&
&
errorCode
=
=
0
;
}
get
isReadyForRestart
(
)
{
if
(
this
.
updateStagingEnabled
)
{
let
errorCode
;
if
(
this
.
update
)
{
errorCode
=
this
.
update
.
errorCode
;
}
else
if
(
this
.
um
.
readyUpdate
)
{
errorCode
=
this
.
um
.
readyUpdate
.
errorCode
;
}
return
this
.
isApplied
|
|
(
this
.
isPending
&
&
errorCode
!
=
0
)
;
}
return
this
.
isPending
;
}
get
isDownloading
(
)
{
if
(
this
.
update
)
{
return
this
.
update
.
state
=
=
"
downloading
"
;
}
return
(
this
.
um
.
downloadingUpdate
&
&
this
.
um
.
downloadingUpdate
.
state
=
=
"
downloading
"
)
;
}
get
updateDisabledByPolicy
(
)
{
return
Services
.
policies
&
&
!
Services
.
policies
.
isAllowed
(
"
appUpdate
"
)
;
}
get
updateDisabledByPackage
(
)
{
try
{
return
Services
.
sysinfo
.
getProperty
(
"
hasWinPackageId
"
)
;
}
catch
(
_ex
)
{
}
return
false
;
}
get
updateStagingEnabled
(
)
{
LOG
(
"
AppUpdater
:
updateStagingEnabled
"
+
"
canStageUpdates
:
"
+
this
.
aus
.
canStageUpdates
)
;
return
(
!
this
.
updateDisabledByPolicy
&
&
!
this
.
updateDisabledByPackage
&
&
this
.
aus
.
canStageUpdates
)
;
}
checkForUpdates
(
)
{
if
(
Services
.
prefs
.
prefHasUserValue
(
PREF_APP_UPDATE_CANCELATIONS_OSX
)
)
{
Services
.
prefs
.
clearUserPref
(
PREF_APP_UPDATE_CANCELATIONS_OSX
)
;
}
if
(
Services
.
prefs
.
prefHasUserValue
(
PREF_APP_UPDATE_ELEVATE_NEVER
)
)
{
Services
.
prefs
.
clearUserPref
(
PREF_APP_UPDATE_ELEVATE_NEVER
)
;
}
this
.
_setStatus
(
AppUpdater
.
STATUS
.
CHECKING
)
;
this
.
checker
.
checkForUpdates
(
this
.
_updateCheckListener
true
)
;
LOG
(
"
AppUpdater
:
checkForUpdates
-
waiting
for
onCheckComplete
(
)
"
)
;
}
get
_updateCheckListener
(
)
{
if
(
!
this
.
__updateCheckListener
)
{
this
.
__updateCheckListener
=
{
onCheckComplete
:
async
(
aRequest
aUpdates
)
=
>
{
LOG
(
"
AppUpdater
:
_updateCheckListener
:
onCheckComplete
-
reached
.
"
)
;
this
.
update
=
this
.
aus
.
selectUpdate
(
aUpdates
)
;
if
(
!
this
.
update
)
{
LOG
(
"
AppUpdater
:
_updateCheckListener
:
onCheckComplete
-
result
:
"
+
"
NO_UPDATES_FOUND
"
)
;
this
.
_setStatus
(
AppUpdater
.
STATUS
.
NO_UPDATES_FOUND
)
;
return
;
}
if
(
this
.
update
.
unsupported
)
{
LOG
(
"
AppUpdater
:
_updateCheckListener
:
onCheckComplete
-
result
:
"
+
"
UNSUPPORTED
SYSTEM
"
)
;
this
.
_setStatus
(
AppUpdater
.
STATUS
.
UNSUPPORTED_SYSTEM
)
;
return
;
}
if
(
!
this
.
aus
.
canApplyUpdates
)
{
LOG
(
"
AppUpdater
:
_updateCheckListener
:
onCheckComplete
-
result
:
"
+
"
MANUAL_UPDATE
"
)
;
this
.
_setStatus
(
AppUpdater
.
STATUS
.
MANUAL_UPDATE
)
;
return
;
}
if
(
!
this
.
promiseAutoUpdateSetting
)
{
this
.
promiseAutoUpdateSetting
=
lazy
.
UpdateUtils
.
getAppUpdateAutoEnabled
(
)
;
}
this
.
promiseAutoUpdateSetting
.
then
(
updateAuto
=
>
{
if
(
updateAuto
&
&
!
this
.
aus
.
manualUpdateOnly
)
{
LOG
(
"
AppUpdater
:
_updateCheckListener
:
onCheckComplete
-
"
+
"
updateAuto
is
active
and
"
+
"
manualUpdateOnlydateOnly
is
inactive
.
"
+
"
start
the
download
.
"
)
;
this
.
startDownload
(
)
;
}
else
{
this
.
_setStatus
(
AppUpdater
.
STATUS
.
DOWNLOAD_AND_INSTALL
)
;
}
}
)
;
}
onError
:
async
(
aRequest
aUpdate
)
=
>
{
LOG
(
"
AppUpdater
:
_updateCheckListener
:
onError
:
NO_UPDATES_FOUND
"
)
;
this
.
_setStatus
(
AppUpdater
.
STATUS
.
NO_UPDATES_FOUND
)
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIUpdateCheckListener
"
]
)
}
;
}
return
this
.
__updateCheckListener
;
}
_waitForUpdateToStage
(
)
{
if
(
!
this
.
update
)
{
this
.
update
=
this
.
um
.
readyUpdate
;
}
this
.
update
.
QueryInterface
(
Ci
.
nsIWritablePropertyBag
)
;
this
.
update
.
setProperty
(
"
foregroundDownload
"
"
true
"
)
;
this
.
_setStatus
(
AppUpdater
.
STATUS
.
STAGING
)
;
this
.
_awaitStagingComplete
(
)
;
}
startDownload
(
)
{
if
(
!
this
.
update
)
{
this
.
update
=
this
.
um
.
downloadingUpdate
;
}
this
.
update
.
QueryInterface
(
Ci
.
nsIWritablePropertyBag
)
;
this
.
update
.
setProperty
(
"
foregroundDownload
"
"
true
"
)
;
let
success
=
this
.
aus
.
downloadUpdate
(
this
.
update
false
)
;
if
(
!
success
)
{
LOG
(
"
AppUpdater
:
startDownload
-
downloadUpdate
failed
.
"
)
;
this
.
_setStatus
(
AppUpdater
.
STATUS
.
DOWNLOAD_FAILED
)
;
return
;
}
this
.
_setupDownloadListener
(
)
;
}
_setupDownloadListener
(
)
{
this
.
_setStatus
(
AppUpdater
.
STATUS
.
DOWNLOADING
)
;
this
.
aus
.
addDownloadListener
(
this
)
;
LOG
(
"
AppUpdater
:
_setupDownloadListener
-
registered
a
download
listener
"
)
;
}
onStartRequest
(
aRequest
)
{
LOG
(
"
AppUpdater
:
onStartRequest
-
aRequest
:
"
+
aRequest
)
;
}
onStopRequest
(
aRequest
aStatusCode
)
{
LOG
(
"
AppUpdater
:
onStopRequest
"
+
"
-
aRequest
:
"
+
aRequest
+
"
aStatusCode
:
"
+
aStatusCode
)
;
switch
(
aStatusCode
)
{
case
Cr
.
NS_ERROR_UNEXPECTED
:
if
(
this
.
update
.
selectedPatch
.
state
=
=
"
download
-
failed
"
&
&
(
this
.
update
.
isCompleteUpdate
|
|
this
.
update
.
patchCount
!
=
2
)
)
{
this
.
aus
.
removeDownloadListener
(
this
)
;
LOG
(
"
AppUpdater
:
onStopRequest
"
+
"
-
download
failed
with
unexpected
error
"
+
"
removed
download
listener
"
)
;
this
.
_setStatus
(
AppUpdater
.
STATUS
.
DOWNLOAD_FAILED
)
;
break
;
}
break
;
case
Cr
.
NS_BINDING_ABORTED
:
break
;
case
Cr
.
NS_OK
:
this
.
aus
.
removeDownloadListener
(
this
)
;
LOG
(
"
AppUpdater
:
onStopRequest
"
+
"
-
download
ok
"
+
"
removed
download
listener
"
)
;
if
(
this
.
updateStagingEnabled
)
{
if
(
this
.
aus
.
isOtherInstanceHandlingUpdates
)
{
LOG
(
"
AppUpdater
:
onStopRequest
"
+
"
-
aStatusCode
=
Cr
.
NS_OK
"
+
"
another
instance
is
handling
updates
"
)
;
this
.
_setStatus
(
AppUpdater
.
OTHER_INSTANCE_HANDLING_UPDATES
)
;
}
else
{
LOG
(
"
AppUpdater
:
onStopRequest
"
+
"
-
aStatusCode
=
Cr
.
NS_OK
"
+
"
no
competitive
instance
found
.
"
)
;
this
.
_setStatus
(
AppUpdater
.
STATUS
.
STAGING
)
;
}
this
.
_awaitStagingComplete
(
)
;
}
else
{
this
.
_awaitDownloadComplete
(
)
;
}
break
;
default
:
this
.
aus
.
removeDownloadListener
(
this
)
;
LOG
(
"
AppUpdater
:
onStopRequest
"
+
"
-
case
default
"
+
"
removing
download
listener
"
+
"
because
the
download
failed
.
"
)
;
this
.
_setStatus
(
AppUpdater
.
STATUS
.
DOWNLOAD_FAILED
)
;
break
;
}
}
onStatus
(
aRequest
aStatus
aStatusArg
)
{
LOG
(
"
AppUpdater
:
onStatus
"
+
"
-
aRequest
:
"
+
aRequest
+
"
aStatus
:
"
+
aStatus
+
"
aStatusArg
:
"
+
aStatusArg
)
;
}
onProgress
(
aRequest
aProgress
aProgressMax
)
{
LOG
(
"
AppUpdater
:
onProgress
"
+
"
-
aRequest
:
"
+
aRequest
+
"
aProgress
:
"
+
aProgress
+
"
aProgressMax
:
"
+
aProgressMax
)
;
this
.
_setStatus
(
AppUpdater
.
STATUS
.
DOWNLOADING
aProgress
aProgressMax
)
;
}
_awaitDownloadComplete
(
)
{
let
observer
=
(
aSubject
aTopic
aData
)
=
>
{
LOG
(
"
AppUpdater
:
_awaitStagingComplete
-
observer
reached
"
+
"
status
changes
to
READY_FOR_RESTART
"
)
;
this
.
_setStatus
(
AppUpdater
.
STATUS
.
READY_FOR_RESTART
)
;
Services
.
obs
.
removeObserver
(
observer
"
update
-
downloaded
"
)
;
}
;
Services
.
obs
.
addObserver
(
observer
"
update
-
downloaded
"
)
;
}
_awaitStagingComplete
(
)
{
let
observer
=
(
aSubject
aTopic
aData
)
=
>
{
LOG
(
"
AppUpdater
:
_awaitStagingComplete
:
observer
"
+
"
-
aSubject
:
"
+
aSubject
+
"
-
aTopic
:
"
+
aTopic
+
"
-
aData
(
=
status
)
:
"
+
aData
)
;
switch
(
aTopic
)
{
case
"
update
-
staged
"
:
let
status
=
aData
;
if
(
status
=
=
"
applied
"
|
|
status
=
=
"
applied
-
service
"
|
|
status
=
=
"
pending
"
|
|
status
=
=
"
pending
-
service
"
|
|
status
=
=
"
pending
-
elevate
"
)
{
this
.
_setStatus
(
AppUpdater
.
STATUS
.
READY_FOR_RESTART
)
;
}
else
if
(
status
=
=
"
failed
"
)
{
this
.
_setStatus
(
AppUpdater
.
STATUS
.
DOWNLOAD_FAILED
)
;
}
else
if
(
status
=
=
"
downloading
"
)
{
this
.
_setupDownloadListener
(
)
;
return
;
}
break
;
case
"
update
-
error
"
:
this
.
_setStatus
(
AppUpdater
.
STATUS
.
DOWNLOAD_FAILED
)
;
break
;
}
Services
.
obs
.
removeObserver
(
observer
"
update
-
staged
"
)
;
Services
.
obs
.
removeObserver
(
observer
"
update
-
error
"
)
;
}
;
Services
.
obs
.
addObserver
(
observer
"
update
-
staged
"
)
;
Services
.
obs
.
addObserver
(
observer
"
update
-
error
"
)
;
}
stop
(
)
{
LOG
(
"
AppUpdater
:
stop
called
remove
download
listener
"
)
;
this
.
checker
.
stopCurrentCheck
(
)
;
this
.
aus
.
removeDownloadListener
(
this
)
;
}
get
status
(
)
{
if
(
!
this
.
_status
)
{
if
(
!
AppConstants
.
MOZ_UPDATER
|
|
this
.
updateDisabledByPackage
)
{
LOG
(
"
AppUpdater
:
status
-
no
updater
or
updates
disabled
by
package
.
"
)
;
this
.
_status
=
AppUpdater
.
STATUS
.
NO_UPDATER
;
}
else
if
(
this
.
updateDisabledByPolicy
)
{
LOG
(
"
AppUpdater
:
status
-
updateDisabledByPolicy
"
)
;
this
.
_status
=
AppUpdater
.
STATUS
.
UPDATE_DISABLED_BY_POLICY
;
}
else
if
(
this
.
isReadyForRestart
)
{
LOG
(
"
AppUpdater
:
status
-
isReadyForRestart
"
)
;
this
.
_status
=
AppUpdater
.
STATUS
.
READY_FOR_RESTART
;
}
else
if
(
this
.
aus
.
isOtherInstanceHandlingUpdates
)
{
LOG
(
"
AppUpdater
:
status
-
another
instance
is
handling
updates
"
)
;
this
.
_status
=
AppUpdater
.
STATUS
.
OTHER_INSTANCE_HANDLING_UPDATES
;
}
else
if
(
this
.
isDownloading
)
{
LOG
(
"
AppUpdater
:
status
-
isDownloading
"
)
;
this
.
_status
=
AppUpdater
.
STATUS
.
DOWNLOADING
;
}
else
if
(
this
.
isStaging
)
{
LOG
(
"
AppUpdater
:
status
-
isStaging
"
)
;
this
.
_status
=
AppUpdater
.
STATUS
.
STAGING
;
}
else
{
LOG
(
"
AppUpdater
:
status
-
NEVER_CHECKED
"
)
;
this
.
_status
=
AppUpdater
.
STATUS
.
NEVER_CHECKED
;
}
}
return
this
.
_status
;
}
addListener
(
listener
)
{
this
.
_listeners
.
add
(
listener
)
;
}
removeListener
(
listener
)
{
this
.
_listeners
.
delete
(
listener
)
;
}
_setStatus
(
status
.
.
.
listenerArgs
)
{
this
.
_status
=
status
;
for
(
let
listener
of
this
.
_listeners
)
{
listener
(
status
.
.
.
listenerArgs
)
;
}
return
status
;
}
observe
(
subject
topic
status
)
{
LOG
(
"
AppUpdater
:
observe
"
+
"
-
subject
:
"
+
subject
+
"
topic
:
"
+
topic
+
"
status
:
"
+
status
)
;
switch
(
topic
)
{
case
"
update
-
swap
"
:
this
.
_handleUpdateSwap
(
)
;
break
;
case
"
nsPref
:
changed
"
:
if
(
status
=
=
PREF_APP_UPDATE_LOG
|
|
status
=
=
PREF_APP_UPDATE_LOG_FILE
)
{
lazy
.
gLogEnabled
;
lazy
.
gLogEnabled
=
Services
.
prefs
.
getBoolPref
(
PREF_APP_UPDATE_LOG
false
)
|
|
Services
.
prefs
.
getBoolPref
(
PREF_APP_UPDATE_LOG_FILE
false
)
;
}
break
;
case
"
quit
-
application
"
:
Services
.
prefs
.
removeObserver
(
PREF_APP_UPDATE_LOG
this
)
;
Services
.
obs
.
removeObserver
(
this
topic
)
;
}
}
_handleUpdateSwap
(
)
{
if
(
this
.
_status
=
=
AppUpdater
.
STATUS
.
DOWNLOADING
|
|
this
.
_status
=
=
AppUpdater
.
STATUS
.
STAGING
)
{
return
;
}
if
(
this
.
updateStagingEnabled
)
{
LOG
(
"
AppUpdater
:
_handleUpdateSwap
-
updateStagingEnabled
"
)
;
this
.
_setStatus
(
AppUpdater
.
STATUS
.
STAGING
)
;
this
.
_awaitStagingComplete
(
)
;
}
else
{
LOG
(
"
AppUpdater
:
_handleUpdateSwap
-
updateStagingDisabled
"
)
;
this
.
_setStatus
(
AppUpdater
.
STATUS
.
DOWNLOADING
)
;
this
.
_awaitDownloadComplete
(
)
;
}
}
}
AppUpdater
.
STATUS
=
{
NEVER_CHECKED
:
0
NO_UPDATER
:
1
UPDATE_DISABLED_BY_POLICY
:
2
OTHER_INSTANCE_HANDLING_UPDATES
:
3
UNSUPPORTED_SYSTEM
:
4
MANUAL_UPDATE
:
5
CHECKING
:
6
NO_UPDATES_FOUND
:
7
DOWNLOADING
:
8
DOWNLOAD_FAILED
:
9
DOWNLOAD_AND_INSTALL
:
10
STAGING
:
11
READY_FOR_RESTART
:
12
isTerminalStatus
(
status
)
{
return
!
[
AppUpdater
.
STATUS
.
CHECKING
AppUpdater
.
STATUS
.
DOWNLOAD_AND_INSTALL
AppUpdater
.
STATUS
.
DOWNLOADING
AppUpdater
.
STATUS
.
NEVER_CHECKED
AppUpdater
.
STATUS
.
STAGING
]
.
includes
(
status
)
;
}
debugStringFor
(
status
)
{
for
(
let
[
k
v
]
of
Object
.
entries
(
AppUpdater
.
STATUS
)
)
{
if
(
v
=
=
status
)
{
return
k
;
}
}
return
null
;
}
}
;
function
LOG
(
string
)
{
if
(
lazy
.
gLogEnabled
)
{
dump
(
"
*
*
*
AUS
:
AUM
"
+
string
+
"
\
n
"
)
;
if
(
!
Cu
.
isInAutomation
)
{
Services
.
console
.
logStringMessage
(
"
AUS
:
AUM
"
+
string
)
;
}
if
(
lazy
.
gLogfileEnabled
)
{
if
(
!
gLogfileOutputStream
)
{
let
logfile
=
Services
.
dirsvc
.
get
(
KEY_PROFILE_DIR
Ci
.
nsIFile
)
;
logfile
.
append
(
FILE_UPDATE_MESSAGES
)
;
gLogfileOutputStream
=
FileUtils
.
openAtomicFileOutputStream
(
logfile
)
;
}
try
{
let
encoded
=
new
TextEncoder
(
)
.
encode
(
string
+
"
\
n
"
)
;
gLogfileOutputStream
.
write
(
encoded
encoded
.
length
)
;
gLogfileOutputStream
.
flush
(
)
;
}
catch
(
e
)
{
dump
(
"
*
*
*
AUS
:
AUM
Unable
to
write
to
messages
file
:
"
+
e
+
"
\
n
"
)
;
Services
.
console
.
logStringMessage
(
"
AUS
:
AUM
Unable
to
write
to
messages
file
:
"
+
e
)
;
}
}
}
}
