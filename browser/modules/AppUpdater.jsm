"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
AppUpdater
"
]
;
var
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
var
gLogfileOutputStream
;
const
{
AppConstants
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
sys
.
mjs
"
)
;
const
{
FileUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
sys
.
mjs
"
)
;
const
PREF_APP_UPDATE_LOG
=
"
app
.
update
.
log
"
;
const
PREF_APP_UPDATE_LOG_FILE
=
"
app
.
update
.
log
.
file
"
;
const
KEY_PROFILE_DIR
=
"
ProfD
"
;
const
FILE_UPDATE_MESSAGES
=
"
update_messages
.
log
"
;
const
lazy
=
{
}
;
ChromeUtils
.
defineESModuleGetters
(
lazy
{
UpdateUtils
:
"
resource
:
/
/
gre
/
modules
/
UpdateUtils
.
sys
.
mjs
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
gLogEnabled
"
function
aus_gLogEnabled
(
)
{
return
(
Services
.
prefs
.
getBoolPref
(
PREF_APP_UPDATE_LOG
false
)
|
|
Services
.
prefs
.
getBoolPref
(
PREF_APP_UPDATE_LOG_FILE
false
)
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
gLogfileEnabled
"
function
aus_gLogfileEnabled
(
)
{
return
Services
.
prefs
.
getBoolPref
(
PREF_APP_UPDATE_LOG_FILE
false
)
;
}
)
;
const
PREF_APP_UPDATE_CANCELATIONS_OSX
=
"
app
.
update
.
cancelations
.
osx
"
;
const
PREF_APP_UPDATE_ELEVATE_NEVER
=
"
app
.
update
.
elevate
.
never
"
;
class
AbortError
extends
Error
{
constructor
(
.
.
.
params
)
{
super
(
.
.
.
params
)
;
this
.
name
=
this
.
constructor
.
name
;
}
}
var
gPendingAbortablePromises
=
new
Set
(
)
;
class
AbortablePromise
{
#
abortFn
;
#
promise
;
#
hasCompleted
=
false
;
constructor
(
promise
)
{
let
abortPromise
=
new
Promise
(
(
resolve
reject
)
=
>
{
this
.
#
abortFn
=
(
)
=
>
reject
(
new
AbortError
(
)
)
;
}
)
;
this
.
#
promise
=
Promise
.
race
(
[
promise
abortPromise
]
)
;
this
.
#
promise
=
this
.
#
promise
.
finally
(
(
)
=
>
{
this
.
#
hasCompleted
=
true
;
gPendingAbortablePromises
.
delete
(
this
)
;
}
)
;
gPendingAbortablePromises
.
add
(
this
)
;
}
abort
(
)
{
if
(
this
.
#
hasCompleted
)
{
return
;
}
this
.
#
abortFn
(
)
;
}
get
promise
(
)
{
return
this
.
#
promise
;
}
get
hasCompleted
(
)
{
return
this
.
#
hasCompleted
;
}
}
function
makeAbortable
(
promise
)
{
let
abortable
=
new
AbortablePromise
(
promise
)
;
return
abortable
.
promise
;
}
function
abortAllPromises
(
)
{
for
(
const
promise
of
gPendingAbortablePromises
)
{
promise
.
abort
(
)
;
}
}
class
AppUpdater
{
#
listeners
=
new
Set
(
)
;
#
status
=
AppUpdater
.
STATUS
.
NEVER_CHECKED
;
#
updateBusy
=
false
;
#
permissionToDownloadGivenFn
=
null
;
#
_update
=
null
;
#
swapListenerConnected
=
false
;
constructor
(
)
{
try
{
this
.
QueryInterface
=
ChromeUtils
.
generateQI
(
[
"
nsIObserver
"
"
nsISupportsWeakReference
"
]
)
;
Services
.
prefs
.
addObserver
(
PREF_APP_UPDATE_LOG
this
true
)
;
}
catch
(
e
)
{
this
.
#
onException
(
e
)
;
}
}
#
onException
(
exception
)
{
try
{
this
.
#
update
=
null
;
if
(
this
.
#
swapListenerConnected
)
{
LOG
(
"
AppUpdater
:
#
onException
-
Removing
update
-
swap
listener
"
)
;
Services
.
obs
.
removeObserver
(
this
"
update
-
swap
"
)
;
this
.
#
swapListenerConnected
=
false
;
}
if
(
exception
instanceof
AbortError
)
{
LOG
(
"
AppUpdater
:
#
onException
-
Caught
AbortError
.
Setting
status
"
+
"
NEVER_CHECKED
"
)
;
this
.
#
setStatus
(
AppUpdater
.
STATUS
.
NEVER_CHECKED
)
;
}
else
{
LOG
(
"
AppUpdater
:
#
onException
-
Exception
caught
.
Setting
status
"
+
"
INTERNAL_ERROR
"
)
;
console
.
error
(
exception
)
;
this
.
#
setStatus
(
AppUpdater
.
STATUS
.
INTERNAL_ERROR
)
;
}
}
catch
(
e
)
{
LOG
(
"
AppUpdater
:
#
onException
-
Caught
additional
exception
while
"
+
"
handling
previous
exception
"
)
;
console
.
error
(
e
)
;
}
}
get
update
(
)
{
return
this
.
#
update
;
}
get
#
update
(
)
{
return
this
.
#
_update
;
}
set
#
update
(
update
)
{
this
.
#
_update
=
update
;
if
(
this
.
#
_update
)
{
this
.
#
_update
.
QueryInterface
(
Ci
.
nsIWritablePropertyBag
)
;
this
.
#
_update
.
setProperty
(
"
foregroundDownload
"
"
true
"
)
;
}
}
async
check
(
)
{
try
{
if
(
this
.
#
updateBusy
)
{
return
;
}
}
catch
(
e
)
{
this
.
#
onException
(
e
)
;
}
try
{
this
.
#
updateBusy
=
true
;
this
.
#
update
=
null
;
if
(
this
.
#
swapListenerConnected
)
{
LOG
(
"
AppUpdater
:
check
-
Removing
update
-
swap
listener
"
)
;
Services
.
obs
.
removeObserver
(
this
"
update
-
swap
"
)
;
this
.
#
swapListenerConnected
=
false
;
}
if
(
!
AppConstants
.
MOZ_UPDATER
|
|
this
.
#
updateDisabledByPackage
)
{
LOG
(
"
AppUpdater
:
check
-
"
+
"
AppConstants
.
MOZ_UPDATER
=
"
+
AppConstants
.
MOZ_UPDATER
+
"
this
.
#
updateDisabledByPackage
:
"
+
this
.
#
updateDisabledByPackage
)
;
this
.
#
setStatus
(
AppUpdater
.
STATUS
.
NO_UPDATER
)
;
return
;
}
if
(
this
.
aus
.
disabled
)
{
LOG
(
"
AppUpdater
:
check
-
AUS
disabled
"
)
;
this
.
#
setStatus
(
AppUpdater
.
STATUS
.
UPDATE_DISABLED_BY_POLICY
)
;
return
;
}
let
updateState
=
this
.
aus
.
currentState
;
let
stateName
=
this
.
aus
.
getStateName
(
updateState
)
;
LOG
(
AppUpdater
:
check
-
currentState
=
{
stateName
}
)
;
if
(
updateState
=
=
Ci
.
nsIApplicationUpdateService
.
STATE_PENDING
)
{
LOG
(
"
AppUpdater
:
check
-
ready
for
restart
"
)
;
this
.
#
onReadyToRestart
(
)
;
return
;
}
if
(
this
.
aus
.
isOtherInstanceHandlingUpdates
)
{
LOG
(
"
AppUpdater
:
check
-
this
.
aus
.
isOtherInstanceHandlingUpdates
"
)
;
this
.
#
setStatus
(
AppUpdater
.
STATUS
.
OTHER_INSTANCE_HANDLING_UPDATES
)
;
return
;
}
if
(
updateState
=
=
Ci
.
nsIApplicationUpdateService
.
STATE_DOWNLOADING
)
{
LOG
(
"
AppUpdater
:
check
-
downloading
"
)
;
this
.
#
update
=
this
.
um
.
downloadingUpdate
;
await
this
.
#
downloadUpdate
(
)
;
return
;
}
if
(
updateState
=
=
Ci
.
nsIApplicationUpdateService
.
STATE_STAGING
)
{
LOG
(
"
AppUpdater
:
check
-
staging
"
)
;
this
.
#
update
=
this
.
um
.
readyUpdate
;
await
this
.
#
awaitStagingComplete
(
)
;
return
;
}
if
(
Services
.
prefs
.
prefHasUserValue
(
PREF_APP_UPDATE_CANCELATIONS_OSX
)
)
{
Services
.
prefs
.
clearUserPref
(
PREF_APP_UPDATE_CANCELATIONS_OSX
)
;
}
if
(
Services
.
prefs
.
prefHasUserValue
(
PREF_APP_UPDATE_ELEVATE_NEVER
)
)
{
Services
.
prefs
.
clearUserPref
(
PREF_APP_UPDATE_ELEVATE_NEVER
)
;
}
this
.
#
setStatus
(
AppUpdater
.
STATUS
.
CHECKING
)
;
LOG
(
"
AppUpdater
:
check
-
starting
update
check
"
)
;
let
check
=
this
.
checker
.
checkForUpdates
(
this
.
checker
.
FOREGROUND_CHECK
)
;
let
result
;
try
{
result
=
await
makeAbortable
(
check
.
result
)
;
}
catch
(
e
)
{
if
(
e
instanceof
AbortError
)
{
this
.
checker
.
stopCheck
(
check
.
id
)
;
}
throw
e
;
}
if
(
!
result
.
checksAllowed
)
{
LOG
(
"
AppUpdater
:
check
-
!
checksAllowed
;
INTERNAL_ERROR
"
)
;
this
.
#
setStatus
(
AppUpdater
.
STATUS
.
INTERNAL_ERROR
)
;
return
;
}
if
(
!
result
.
succeeded
)
{
LOG
(
"
AppUpdater
:
check
-
Update
check
failed
;
NO_UPDATES_FOUND
"
)
;
this
.
#
setStatus
(
AppUpdater
.
STATUS
.
NO_UPDATES_FOUND
)
;
return
;
}
LOG
(
"
AppUpdater
:
check
-
Update
check
succeeded
"
)
;
this
.
#
update
=
this
.
aus
.
selectUpdate
(
result
.
updates
)
;
if
(
!
this
.
#
update
)
{
LOG
(
"
AppUpdater
:
check
-
result
:
NO_UPDATES_FOUND
"
)
;
this
.
#
setStatus
(
AppUpdater
.
STATUS
.
NO_UPDATES_FOUND
)
;
return
;
}
if
(
this
.
#
update
.
unsupported
)
{
LOG
(
"
AppUpdater
:
check
-
result
:
UNSUPPORTED
SYSTEM
"
)
;
this
.
#
setStatus
(
AppUpdater
.
STATUS
.
UNSUPPORTED_SYSTEM
)
;
return
;
}
if
(
!
this
.
aus
.
canApplyUpdates
)
{
LOG
(
"
AppUpdater
:
check
-
result
:
MANUAL_UPDATE
"
)
;
this
.
#
setStatus
(
AppUpdater
.
STATUS
.
MANUAL_UPDATE
)
;
return
;
}
let
updateAuto
=
await
makeAbortable
(
lazy
.
UpdateUtils
.
getAppUpdateAutoEnabled
(
)
)
;
if
(
!
updateAuto
|
|
this
.
aus
.
manualUpdateOnly
)
{
LOG
(
"
AppUpdater
:
check
-
Need
to
wait
for
user
approval
to
start
the
"
+
"
download
.
"
)
;
let
downloadPermissionPromise
=
new
Promise
(
resolve
=
>
{
this
.
#
permissionToDownloadGivenFn
=
resolve
;
}
)
;
let
downloadStartPromise
=
Promise
.
race
(
[
downloadPermissionPromise
this
.
aus
.
stateTransition
]
)
;
this
.
#
setStatus
(
AppUpdater
.
STATUS
.
DOWNLOAD_AND_INSTALL
)
;
await
makeAbortable
(
downloadStartPromise
)
;
LOG
(
"
AppUpdater
:
check
-
Got
user
approval
.
Proceeding
with
download
"
)
;
if
(
this
.
um
.
downloadingUpdate
)
{
this
.
#
update
=
this
.
um
.
downloadingUpdate
;
}
}
else
{
LOG
(
"
AppUpdater
:
check
-
updateAuto
is
active
and
"
+
"
manualUpdateOnlydateOnly
is
inactive
.
Start
the
download
.
"
)
;
}
await
this
.
#
downloadUpdate
(
)
;
}
catch
(
e
)
{
this
.
#
onException
(
e
)
;
}
finally
{
this
.
#
updateBusy
=
false
;
}
}
allowUpdateDownload
(
)
{
if
(
this
.
#
permissionToDownloadGivenFn
)
{
this
.
#
permissionToDownloadGivenFn
(
)
;
}
}
get
#
updateDisabledByPackage
(
)
{
return
Services
.
sysinfo
.
getProperty
(
"
isPackagedApp
"
)
;
}
get
#
updateStagingEnabled
(
)
{
LOG
(
"
AppUpdater
:
#
updateStagingEnabled
"
+
"
canStageUpdates
:
"
+
this
.
aus
.
canStageUpdates
)
;
return
(
!
this
.
aus
.
disabled
&
&
!
this
.
#
updateDisabledByPackage
&
&
this
.
aus
.
canStageUpdates
)
;
}
async
#
downloadUpdate
(
)
{
this
.
#
setStatus
(
AppUpdater
.
STATUS
.
DOWNLOADING
)
;
let
success
=
await
this
.
aus
.
downloadUpdate
(
this
.
#
update
false
)
;
if
(
!
success
)
{
LOG
(
"
AppUpdater
:
#
downloadUpdate
-
downloadUpdate
failed
.
"
)
;
this
.
#
setStatus
(
AppUpdater
.
STATUS
.
DOWNLOAD_FAILED
)
;
return
;
}
await
this
.
#
awaitDownloadComplete
(
)
;
}
async
#
awaitDownloadComplete
(
)
{
let
updateState
=
this
.
aus
.
currentState
;
if
(
updateState
!
=
Ci
.
nsIApplicationUpdateService
.
STATE_DOWNLOADING
&
&
updateState
!
=
Ci
.
nsIApplicationUpdateService
.
STATE_SWAP
)
{
throw
new
Error
(
"
AppUpdater
:
#
awaitDownloadComplete
invoked
in
unexpected
state
:
"
+
this
.
aus
.
getStateName
(
updateState
)
)
;
}
this
.
#
setStatus
(
AppUpdater
.
STATUS
.
DOWNLOADING
)
;
const
updateDownloadProgress
=
(
progress
progressMax
)
=
>
{
this
.
#
setStatus
(
AppUpdater
.
STATUS
.
DOWNLOADING
progress
progressMax
)
;
}
;
const
progressObserver
=
{
onStartRequest
(
aRequest
)
{
LOG
(
AppUpdater
:
#
awaitDownloadComplete
.
observer
.
onStartRequest
-
+
aRequest
:
{
aRequest
}
)
;
}
onStatus
(
aRequest
aStatus
aStatusArg
)
{
LOG
(
AppUpdater
:
#
awaitDownloadComplete
.
observer
.
onStatus
+
-
aRequest
:
{
aRequest
}
aStatus
:
{
aStatus
}
+
aStatusArg
:
{
aStatusArg
}
)
;
}
onProgress
(
aRequest
aProgress
aProgressMax
)
{
LOG
(
AppUpdater
:
#
awaitDownloadComplete
.
observer
.
onProgress
+
-
aRequest
:
{
aRequest
}
aProgress
:
{
aProgress
}
+
aProgressMax
:
{
aProgressMax
}
)
;
updateDownloadProgress
(
aProgress
aProgressMax
)
;
}
onStopRequest
(
aRequest
aStatusCode
)
{
LOG
(
AppUpdater
:
#
awaitDownloadComplete
.
observer
.
onStopRequest
+
-
aRequest
:
{
aRequest
}
aStatusCode
:
{
aStatusCode
}
)
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIProgressEventSink
"
"
nsIRequestObserver
"
]
)
}
;
let
listenForProgress
=
updateState
=
=
Ci
.
nsIApplicationUpdateService
.
STATE_DOWNLOADING
;
if
(
listenForProgress
)
{
this
.
aus
.
addDownloadListener
(
progressObserver
)
;
LOG
(
"
AppUpdater
:
#
awaitDownloadComplete
-
Registered
download
listener
"
)
;
}
LOG
(
"
AppUpdater
:
#
awaitDownloadComplete
-
Waiting
for
state
transition
.
"
)
;
try
{
await
makeAbortable
(
this
.
aus
.
stateTransition
)
;
}
finally
{
if
(
listenForProgress
)
{
this
.
aus
.
removeDownloadListener
(
progressObserver
)
;
LOG
(
"
AppUpdater
:
#
awaitDownloadComplete
-
Download
listener
removed
"
)
;
}
}
updateState
=
this
.
aus
.
currentState
;
LOG
(
"
AppUpdater
:
#
awaitDownloadComplete
-
State
transition
seen
.
New
state
:
"
+
this
.
aus
.
getStateName
(
updateState
)
)
;
switch
(
updateState
)
{
case
Ci
.
nsIApplicationUpdateService
.
STATE_IDLE
:
LOG
(
"
AppUpdater
:
#
awaitDownloadComplete
-
Setting
status
DOWNLOAD_FAILED
.
"
)
;
this
.
#
setStatus
(
AppUpdater
.
STATUS
.
DOWNLOAD_FAILED
)
;
break
;
case
Ci
.
nsIApplicationUpdateService
.
STATE_STAGING
:
LOG
(
"
AppUpdater
:
#
awaitDownloadComplete
-
awaiting
staging
completion
.
"
)
;
await
this
.
#
awaitStagingComplete
(
)
;
break
;
case
Ci
.
nsIApplicationUpdateService
.
STATE_PENDING
:
LOG
(
"
AppUpdater
:
#
awaitDownloadComplete
-
ready
to
restart
.
"
)
;
this
.
#
onReadyToRestart
(
)
;
break
;
default
:
LOG
(
"
AppUpdater
:
#
awaitDownloadComplete
-
Setting
status
INTERNAL_ERROR
.
"
)
;
this
.
#
setStatus
(
AppUpdater
.
STATUS
.
INTERNAL_ERROR
)
;
break
;
}
}
async
#
awaitStagingComplete
(
)
{
let
updateState
=
this
.
aus
.
currentState
;
if
(
updateState
!
=
Ci
.
nsIApplicationUpdateService
.
STATE_STAGING
)
{
throw
new
Error
(
"
AppUpdater
:
#
awaitStagingComplete
invoked
in
unexpected
state
:
"
+
this
.
aus
.
getStateName
(
updateState
)
)
;
}
LOG
(
"
AppUpdater
:
#
awaitStagingComplete
-
Setting
status
STAGING
.
"
)
;
this
.
#
setStatus
(
AppUpdater
.
STATUS
.
STAGING
)
;
LOG
(
"
AppUpdater
:
#
awaitStagingComplete
-
Waiting
for
state
transition
.
"
)
;
await
makeAbortable
(
this
.
aus
.
stateTransition
)
;
updateState
=
this
.
aus
.
currentState
;
LOG
(
"
AppUpdater
:
#
awaitStagingComplete
-
State
transition
seen
.
New
state
:
"
+
this
.
aus
.
getStateName
(
updateState
)
)
;
switch
(
updateState
)
{
case
Ci
.
nsIApplicationUpdateService
.
STATE_PENDING
:
LOG
(
"
AppUpdater
:
#
awaitStagingComplete
-
ready
for
restart
"
)
;
this
.
#
onReadyToRestart
(
)
;
break
;
case
Ci
.
nsIApplicationUpdateService
.
STATE_IDLE
:
LOG
(
"
AppUpdater
:
#
awaitStagingComplete
-
DOWNLOAD_FAILED
"
)
;
this
.
#
setStatus
(
AppUpdater
.
STATUS
.
DOWNLOAD_FAILED
)
;
break
;
case
Ci
.
nsIApplicationUpdateService
.
STATE_DOWNLOADING
:
LOG
(
"
AppUpdater
:
#
awaitStagingComplete
-
Partial
update
must
have
"
+
"
failed
to
stage
.
Downloading
complete
update
.
"
)
;
await
this
.
#
awaitDownloadComplete
(
)
;
break
;
default
:
LOG
(
"
AppUpdater
:
#
awaitStagingComplete
-
Setting
status
INTERNAL_ERROR
.
"
)
;
this
.
#
setStatus
(
AppUpdater
.
STATUS
.
INTERNAL_ERROR
)
;
break
;
}
}
#
onReadyToRestart
(
)
{
let
updateState
=
this
.
aus
.
currentState
;
if
(
updateState
!
=
Ci
.
nsIApplicationUpdateService
.
STATE_PENDING
)
{
throw
new
Error
(
"
AppUpdater
:
#
onReadyToRestart
invoked
in
unexpected
state
:
"
+
this
.
aus
.
getStateName
(
updateState
)
)
;
}
LOG
(
"
AppUpdater
:
#
onReadyToRestart
-
Setting
status
READY_FOR_RESTART
.
"
)
;
if
(
this
.
#
swapListenerConnected
)
{
LOG
(
"
AppUpdater
:
#
onReadyToRestart
-
update
-
swap
listener
already
attached
"
)
;
}
else
{
this
.
#
swapListenerConnected
=
true
;
LOG
(
"
AppUpdater
:
#
onReadyToRestart
-
Attaching
update
-
swap
listener
"
)
;
Services
.
obs
.
addObserver
(
this
"
update
-
swap
"
true
)
;
}
this
.
#
setStatus
(
AppUpdater
.
STATUS
.
READY_FOR_RESTART
)
;
}
stop
(
)
{
LOG
(
"
AppUpdater
:
stop
called
"
)
;
if
(
this
.
#
swapListenerConnected
)
{
LOG
(
"
AppUpdater
:
stop
-
Removing
update
-
swap
listener
"
)
;
Services
.
obs
.
removeObserver
(
this
"
update
-
swap
"
)
;
this
.
#
swapListenerConnected
=
false
;
}
abortAllPromises
(
)
;
}
get
status
(
)
{
return
this
.
#
status
;
}
addListener
(
listener
)
{
this
.
#
listeners
.
add
(
listener
)
;
}
removeListener
(
listener
)
{
this
.
#
listeners
.
delete
(
listener
)
;
}
#
setStatus
(
status
.
.
.
listenerArgs
)
{
this
.
#
status
=
status
;
for
(
let
listener
of
this
.
#
listeners
)
{
listener
(
status
.
.
.
listenerArgs
)
;
}
return
status
;
}
observe
(
subject
topic
status
)
{
LOG
(
"
AppUpdater
:
observe
"
+
"
-
subject
:
"
+
subject
+
"
topic
:
"
+
topic
+
"
status
:
"
+
status
)
;
switch
(
topic
)
{
case
"
update
-
swap
"
:
this
.
#
handleUpdateSwap
(
)
;
break
;
case
"
nsPref
:
changed
"
:
if
(
status
=
=
PREF_APP_UPDATE_LOG
|
|
status
=
=
PREF_APP_UPDATE_LOG_FILE
)
{
lazy
.
gLogEnabled
;
lazy
.
gLogEnabled
=
Services
.
prefs
.
getBoolPref
(
PREF_APP_UPDATE_LOG
false
)
|
|
Services
.
prefs
.
getBoolPref
(
PREF_APP_UPDATE_LOG_FILE
false
)
;
}
break
;
}
}
async
#
handleUpdateSwap
(
)
{
try
{
if
(
this
.
#
updateBusy
)
{
return
;
}
}
catch
(
e
)
{
this
.
#
onException
(
e
)
;
}
try
{
this
.
#
updateBusy
=
true
;
this
.
#
update
=
this
.
um
.
downloadingUpdate
;
if
(
!
this
.
#
update
)
{
this
.
#
update
=
this
.
um
.
readyUpdate
;
}
await
this
.
#
awaitDownloadComplete
(
)
;
}
catch
(
e
)
{
this
.
#
onException
(
e
)
;
}
finally
{
this
.
#
updateBusy
=
false
;
}
}
}
XPCOMUtils
.
defineLazyServiceGetter
(
AppUpdater
.
prototype
"
aus
"
"
mozilla
.
org
/
updates
/
update
-
service
;
1
"
"
nsIApplicationUpdateService
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
AppUpdater
.
prototype
"
checker
"
"
mozilla
.
org
/
updates
/
update
-
checker
;
1
"
"
nsIUpdateChecker
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
AppUpdater
.
prototype
"
um
"
"
mozilla
.
org
/
updates
/
update
-
manager
;
1
"
"
nsIUpdateManager
"
)
;
AppUpdater
.
STATUS
=
{
NEVER_CHECKED
:
0
NO_UPDATER
:
1
UPDATE_DISABLED_BY_POLICY
:
2
OTHER_INSTANCE_HANDLING_UPDATES
:
3
UNSUPPORTED_SYSTEM
:
4
MANUAL_UPDATE
:
5
CHECKING
:
6
NO_UPDATES_FOUND
:
7
DOWNLOADING
:
8
DOWNLOAD_FAILED
:
9
DOWNLOAD_AND_INSTALL
:
10
STAGING
:
11
READY_FOR_RESTART
:
12
INTERNAL_ERROR
:
13
isTerminalStatus
(
status
)
{
return
!
[
AppUpdater
.
STATUS
.
CHECKING
AppUpdater
.
STATUS
.
DOWNLOAD_AND_INSTALL
AppUpdater
.
STATUS
.
DOWNLOADING
AppUpdater
.
STATUS
.
NEVER_CHECKED
AppUpdater
.
STATUS
.
STAGING
]
.
includes
(
status
)
;
}
debugStringFor
(
status
)
{
for
(
let
[
k
v
]
of
Object
.
entries
(
AppUpdater
.
STATUS
)
)
{
if
(
v
=
=
status
)
{
return
k
;
}
}
return
null
;
}
}
;
function
LOG
(
string
)
{
if
(
lazy
.
gLogEnabled
)
{
dump
(
"
*
*
*
AUS
:
AUM
"
+
string
+
"
\
n
"
)
;
if
(
!
Cu
.
isInAutomation
)
{
Services
.
console
.
logStringMessage
(
"
AUS
:
AUM
"
+
string
)
;
}
if
(
lazy
.
gLogfileEnabled
)
{
if
(
!
gLogfileOutputStream
)
{
let
logfile
=
Services
.
dirsvc
.
get
(
KEY_PROFILE_DIR
Ci
.
nsIFile
)
;
logfile
.
append
(
FILE_UPDATE_MESSAGES
)
;
gLogfileOutputStream
=
FileUtils
.
openAtomicFileOutputStream
(
logfile
)
;
}
try
{
let
encoded
=
new
TextEncoder
(
)
.
encode
(
string
+
"
\
n
"
)
;
gLogfileOutputStream
.
write
(
encoded
encoded
.
length
)
;
gLogfileOutputStream
.
flush
(
)
;
}
catch
(
e
)
{
dump
(
"
*
*
*
AUS
:
AUM
Unable
to
write
to
messages
file
:
"
+
e
+
"
\
n
"
)
;
Services
.
console
.
logStringMessage
(
"
AUS
:
AUM
Unable
to
write
to
messages
file
:
"
+
e
)
;
}
}
}
}
