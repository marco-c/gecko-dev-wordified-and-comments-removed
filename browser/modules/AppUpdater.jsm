"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
AppUpdater
"
]
;
var
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AppConstants
:
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
UpdateUtils
:
"
resource
:
/
/
gre
/
modules
/
UpdateUtils
.
jsm
"
}
)
;
const
PREF_APP_UPDATE_CANCELATIONS_OSX
=
"
app
.
update
.
cancelations
.
osx
"
;
const
PREF_APP_UPDATE_ELEVATE_NEVER
=
"
app
.
update
.
elevate
.
never
"
;
class
AppUpdater
{
constructor
(
)
{
this
.
_listeners
=
new
Set
(
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
aus
"
"
mozilla
.
org
/
updates
/
update
-
service
;
1
"
"
nsIApplicationUpdateService
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
checker
"
"
mozilla
.
org
/
updates
/
update
-
checker
;
1
"
"
nsIUpdateChecker
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
um
"
"
mozilla
.
org
/
updates
/
update
-
manager
;
1
"
"
nsIUpdateManager
"
)
;
}
check
(
)
{
if
(
!
AppConstants
.
MOZ_UPDATER
)
{
this
.
_setStatus
(
AppUpdater
.
STATUS
.
NO_UPDATER
)
;
return
;
}
if
(
this
.
updateDisabledByPolicy
)
{
this
.
_setStatus
(
AppUpdater
.
STATUS
.
UPDATE_DISABLED_BY_POLICY
)
;
return
;
}
if
(
this
.
isReadyForRestart
)
{
this
.
_setStatus
(
AppUpdater
.
STATUS
.
READY_FOR_RESTART
)
;
return
;
}
if
(
this
.
aus
.
isOtherInstanceHandlingUpdates
)
{
this
.
_setStatus
(
AppUpdater
.
STATUS
.
OTHER_INSTANCE_HANDLING_UPDATES
)
;
return
;
}
if
(
this
.
isDownloading
)
{
this
.
startDownload
(
)
;
return
;
}
if
(
this
.
isStaging
)
{
this
.
_waitForUpdateToStage
(
)
;
return
;
}
this
.
promiseAutoUpdateSetting
=
UpdateUtils
.
getAppUpdateAutoEnabled
(
)
;
this
.
checkForUpdates
(
)
;
}
get
isPending
(
)
{
if
(
this
.
update
)
{
return
(
this
.
update
.
state
=
=
"
pending
"
|
|
this
.
update
.
state
=
=
"
pending
-
service
"
|
|
this
.
update
.
state
=
=
"
pending
-
elevate
"
)
;
}
return
(
this
.
um
.
activeUpdate
&
&
(
this
.
um
.
activeUpdate
.
state
=
=
"
pending
"
|
|
this
.
um
.
activeUpdate
.
state
=
=
"
pending
-
service
"
|
|
this
.
um
.
activeUpdate
.
state
=
=
"
pending
-
elevate
"
)
)
;
}
get
isApplied
(
)
{
if
(
this
.
update
)
{
return
(
this
.
update
.
state
=
=
"
applied
"
|
|
this
.
update
.
state
=
=
"
applied
-
service
"
)
;
}
return
(
this
.
um
.
activeUpdate
&
&
(
this
.
um
.
activeUpdate
.
state
=
=
"
applied
"
|
|
this
.
um
.
activeUpdate
.
state
=
=
"
applied
-
service
"
)
)
;
}
get
isStaging
(
)
{
if
(
!
this
.
updateStagingEnabled
)
{
return
false
;
}
let
errorCode
;
if
(
this
.
update
)
{
errorCode
=
this
.
update
.
errorCode
;
}
else
if
(
this
.
um
.
activeUpdate
)
{
errorCode
=
this
.
um
.
activeUpdate
.
errorCode
;
}
return
this
.
isPending
&
&
errorCode
=
=
0
;
}
get
isReadyForRestart
(
)
{
if
(
this
.
updateStagingEnabled
)
{
let
errorCode
;
if
(
this
.
update
)
{
errorCode
=
this
.
update
.
errorCode
;
}
else
if
(
this
.
um
.
activeUpdate
)
{
errorCode
=
this
.
um
.
activeUpdate
.
errorCode
;
}
return
this
.
isApplied
|
|
(
this
.
isPending
&
&
errorCode
!
=
0
)
;
}
return
this
.
isPending
;
}
get
isDownloading
(
)
{
if
(
this
.
update
)
{
return
this
.
update
.
state
=
=
"
downloading
"
;
}
return
this
.
um
.
activeUpdate
&
&
this
.
um
.
activeUpdate
.
state
=
=
"
downloading
"
;
}
get
updateDisabledByPolicy
(
)
{
return
Services
.
policies
&
&
!
Services
.
policies
.
isAllowed
(
"
appUpdate
"
)
;
}
get
updateStagingEnabled
(
)
{
return
!
this
.
updateDisabledByPolicy
&
&
this
.
aus
.
canStageUpdates
;
}
checkForUpdates
(
)
{
if
(
Services
.
prefs
.
prefHasUserValue
(
PREF_APP_UPDATE_CANCELATIONS_OSX
)
)
{
Services
.
prefs
.
clearUserPref
(
PREF_APP_UPDATE_CANCELATIONS_OSX
)
;
}
if
(
Services
.
prefs
.
prefHasUserValue
(
PREF_APP_UPDATE_ELEVATE_NEVER
)
)
{
Services
.
prefs
.
clearUserPref
(
PREF_APP_UPDATE_ELEVATE_NEVER
)
;
}
this
.
_setStatus
(
AppUpdater
.
STATUS
.
CHECKING
)
;
this
.
checker
.
checkForUpdates
(
this
.
_updateCheckListener
true
)
;
}
get
_updateCheckListener
(
)
{
if
(
!
this
.
__updateCheckListener
)
{
this
.
__updateCheckListener
=
{
onCheckComplete
:
(
aRequest
aUpdates
)
=
>
{
this
.
update
=
this
.
aus
.
selectUpdate
(
aUpdates
)
;
if
(
!
this
.
update
)
{
this
.
_setStatus
(
AppUpdater
.
STATUS
.
NO_UPDATES_FOUND
)
;
return
;
}
if
(
this
.
update
.
unsupported
)
{
this
.
_setStatus
(
AppUpdater
.
STATUS
.
UNSUPPORTED_SYSTEM
)
;
return
;
}
if
(
!
this
.
aus
.
canApplyUpdates
)
{
this
.
_setStatus
(
AppUpdater
.
STATUS
.
MANUAL_UPDATE
)
;
return
;
}
if
(
!
this
.
promiseAutoUpdateSetting
)
{
this
.
promiseAutoUpdateSetting
=
UpdateUtils
.
getAppUpdateAutoEnabled
(
)
;
}
this
.
promiseAutoUpdateSetting
.
then
(
updateAuto
=
>
{
if
(
updateAuto
)
{
this
.
startDownload
(
)
;
}
else
{
this
.
_setStatus
(
AppUpdater
.
STATUS
.
DOWNLOAD_AND_INSTALL
)
;
}
}
)
;
}
onError
:
(
aRequest
aUpdate
)
=
>
{
this
.
_setStatus
(
AppUpdater
.
STATUS
.
NO_UPDATES_FOUND
)
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIUpdateCheckListener
"
]
)
}
;
}
return
this
.
__updateCheckListener
;
}
_waitForUpdateToStage
(
)
{
if
(
!
this
.
update
)
{
this
.
update
=
this
.
um
.
activeUpdate
;
}
this
.
update
.
QueryInterface
(
Ci
.
nsIWritablePropertyBag
)
;
this
.
update
.
setProperty
(
"
foregroundDownload
"
"
true
"
)
;
this
.
_setStatus
(
AppUpdater
.
STATUS
.
STAGING
)
;
this
.
_awaitStagingComplete
(
)
;
}
startDownload
(
)
{
if
(
!
this
.
update
)
{
this
.
update
=
this
.
um
.
activeUpdate
;
}
this
.
update
.
QueryInterface
(
Ci
.
nsIWritablePropertyBag
)
;
this
.
update
.
setProperty
(
"
foregroundDownload
"
"
true
"
)
;
let
state
=
this
.
aus
.
downloadUpdate
(
this
.
update
false
)
;
if
(
state
=
=
"
failed
"
)
{
this
.
_setStatus
(
AppUpdater
.
STATUS
.
DOWNLOAD_FAILED
)
;
return
;
}
this
.
_setupDownloadListener
(
)
;
}
_setupDownloadListener
(
)
{
this
.
_setStatus
(
AppUpdater
.
STATUS
.
DOWNLOADING
)
;
this
.
aus
.
addDownloadListener
(
this
)
;
}
onStartRequest
(
aRequest
)
{
}
onStopRequest
(
aRequest
aStatusCode
)
{
switch
(
aStatusCode
)
{
case
Cr
.
NS_ERROR_UNEXPECTED
:
if
(
this
.
update
.
selectedPatch
.
state
=
=
"
download
-
failed
"
&
&
(
this
.
update
.
isCompleteUpdate
|
|
this
.
update
.
patchCount
!
=
2
)
)
{
this
.
aus
.
removeDownloadListener
(
this
)
;
this
.
_setStatus
(
AppUpdater
.
STATUS
.
DOWNLOAD_FAILED
)
;
break
;
}
break
;
case
Cr
.
NS_BINDING_ABORTED
:
break
;
case
Cr
.
NS_OK
:
this
.
aus
.
removeDownloadListener
(
this
)
;
if
(
this
.
updateStagingEnabled
)
{
this
.
_setStatus
(
AppUpdater
.
STATUS
.
STAGING
)
;
this
.
_awaitStagingComplete
(
)
;
}
else
{
this
.
_setStatus
(
AppUpdater
.
STATUS
.
READY_FOR_RESTART
)
;
}
break
;
default
:
this
.
aus
.
removeDownloadListener
(
this
)
;
this
.
_setStatus
(
AppUpdater
.
STATUS
.
DOWNLOAD_FAILED
)
;
break
;
}
}
onStatus
(
aRequest
aContext
aStatus
aStatusArg
)
{
}
onProgress
(
aRequest
aContext
aProgress
aProgressMax
)
{
this
.
_setStatus
(
AppUpdater
.
STATUS
.
DOWNLOADING
aProgress
aProgressMax
)
;
}
_awaitStagingComplete
(
)
{
let
observer
=
(
aSubject
aTopic
aData
)
=
>
{
let
status
=
aData
;
if
(
status
=
=
"
applied
"
|
|
status
=
=
"
applied
-
service
"
|
|
status
=
=
"
pending
"
|
|
status
=
=
"
pending
-
service
"
|
|
status
=
=
"
pending
-
elevate
"
)
{
this
.
_setStatus
(
AppUpdater
.
STATUS
.
READY_FOR_RESTART
)
;
}
else
if
(
status
=
=
"
failed
"
)
{
this
.
_setStatus
(
AppUpdater
.
STATUS
.
DOWNLOAD_FAILED
)
;
}
else
if
(
status
=
=
"
downloading
"
)
{
this
.
_setupDownloadListener
(
)
;
return
;
}
Services
.
obs
.
removeObserver
(
observer
"
update
-
staged
"
)
;
}
;
Services
.
obs
.
addObserver
(
observer
"
update
-
staged
"
)
;
}
stop
(
)
{
this
.
checker
.
stopCurrentCheck
(
)
;
this
.
aus
.
removeDownloadListener
(
this
)
;
}
get
status
(
)
{
if
(
!
this
.
_status
)
{
if
(
!
AppConstants
.
MOZ_UPDATER
)
{
this
.
_status
=
AppUpdater
.
STATUS
.
NO_UPDATER
;
}
else
if
(
this
.
updateDisabledByPolicy
)
{
this
.
_status
=
AppUpdater
.
STATUS
.
UPDATE_DISABLED_BY_POLICY
;
}
else
if
(
this
.
isReadyForRestart
)
{
this
.
_status
=
AppUpdater
.
STATUS
.
READY_FOR_RESTART
;
}
else
if
(
this
.
aus
.
isOtherInstanceHandlingUpdates
)
{
this
.
_status
=
AppUpdater
.
STATUS
.
OTHER_INSTANCE_HANDLING_UPDATES
;
}
else
if
(
this
.
isDownloading
)
{
this
.
_status
=
AppUpdater
.
STATUS
.
DOWNLOADING
;
}
else
if
(
this
.
isStaging
)
{
this
.
_status
=
AppUpdater
.
STATUS
.
STAGING
;
}
else
{
this
.
_status
=
AppUpdater
.
STATUS
.
NEVER_CHECKED
;
}
}
return
this
.
_status
;
}
addListener
(
listener
)
{
this
.
_listeners
.
add
(
listener
)
;
}
removeListener
(
listener
)
{
this
.
_listeners
.
delete
(
listener
)
;
}
_setStatus
(
status
.
.
.
listenerArgs
)
{
this
.
_status
=
status
;
for
(
let
listener
of
this
.
_listeners
)
{
listener
(
status
.
.
.
listenerArgs
)
;
}
return
status
;
}
}
AppUpdater
.
STATUS
=
{
NEVER_CHECKED
:
0
NO_UPDATER
:
1
UPDATE_DISABLED_BY_POLICY
:
2
OTHER_INSTANCE_HANDLING_UPDATES
:
3
UNSUPPORTED_SYSTEM
:
4
MANUAL_UPDATE
:
5
CHECKING
:
6
NO_UPDATES_FOUND
:
7
DOWNLOADING
:
8
DOWNLOAD_FAILED
:
9
DOWNLOAD_AND_INSTALL
:
10
STAGING
:
11
READY_FOR_RESTART
:
12
}
;
