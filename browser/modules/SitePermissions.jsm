var
EXPORTED_SYMBOLS
=
[
"
SitePermissions
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
var
gStringBundle
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
browser
/
locale
/
sitePermissions
.
properties
"
)
;
const
TemporaryPermissions
=
{
_stateByBrowser
:
new
WeakMap
(
)
_get
(
entry
baseDomain
id
permission
)
{
if
(
permission
=
=
null
|
|
permission
.
timeStamp
=
=
null
)
{
delete
entry
[
baseDomain
]
[
id
]
;
return
null
;
}
if
(
permission
.
timeStamp
+
SitePermissions
.
temporaryPermissionExpireTime
<
Date
.
now
(
)
)
{
delete
entry
[
baseDomain
]
[
id
]
;
return
null
;
}
return
{
id
state
:
permission
.
state
scope
:
SitePermissions
.
SCOPE_TEMPORARY
}
;
}
_uriToBaseDomain
(
uri
)
{
try
{
return
Services
.
eTLD
.
getBaseDomain
(
uri
)
;
}
catch
(
error
)
{
if
(
error
.
result
!
=
=
Cr
.
NS_ERROR_HOST_IS_IP_ADDRESS
&
&
error
.
result
!
=
=
Cr
.
NS_ERROR_INSUFFICIENT_DOMAIN_LEVELS
)
{
throw
error
;
}
return
uri
.
host
;
}
}
set
(
browser
id
state
)
{
if
(
!
browser
)
{
return
;
}
if
(
!
this
.
_stateByBrowser
.
has
(
browser
)
)
{
this
.
_stateByBrowser
.
set
(
browser
{
}
)
;
}
let
entry
=
this
.
_stateByBrowser
.
get
(
browser
)
;
let
baseDomain
=
this
.
_uriToBaseDomain
(
browser
.
currentURI
)
;
if
(
!
entry
[
baseDomain
]
)
{
entry
[
baseDomain
]
=
{
}
;
}
entry
[
baseDomain
]
[
id
]
=
{
timeStamp
:
Date
.
now
(
)
state
}
;
}
remove
(
browser
id
)
{
if
(
!
browser
|
|
!
this
.
_stateByBrowser
.
has
(
browser
)
)
{
return
;
}
let
entry
=
this
.
_stateByBrowser
.
get
(
browser
)
;
let
baseDomain
=
this
.
_uriToBaseDomain
(
browser
.
currentURI
)
;
if
(
entry
[
baseDomain
]
)
{
delete
entry
[
baseDomain
]
[
id
]
;
}
}
get
(
browser
id
)
{
if
(
!
browser
|
|
!
browser
.
currentURI
|
|
!
this
.
_stateByBrowser
.
has
(
browser
)
)
{
return
null
;
}
let
entry
=
this
.
_stateByBrowser
.
get
(
browser
)
;
let
baseDomain
=
this
.
_uriToBaseDomain
(
browser
.
currentURI
)
;
if
(
entry
[
baseDomain
]
)
{
let
permission
=
entry
[
baseDomain
]
[
id
]
;
return
this
.
_get
(
entry
baseDomain
id
permission
)
;
}
return
null
;
}
getAll
(
browser
)
{
let
permissions
=
[
]
;
if
(
!
this
.
_stateByBrowser
.
has
(
browser
)
)
{
return
permissions
;
}
let
entry
=
this
.
_stateByBrowser
.
get
(
browser
)
;
let
baseDomain
=
this
.
_uriToBaseDomain
(
browser
.
currentURI
)
;
if
(
entry
[
baseDomain
]
)
{
let
timeStamps
=
entry
[
baseDomain
]
;
for
(
let
id
of
Object
.
keys
(
timeStamps
)
)
{
let
permission
=
this
.
_get
(
entry
baseDomain
id
timeStamps
[
id
]
)
;
if
(
permission
)
{
permissions
.
push
(
permission
)
;
}
}
}
return
permissions
;
}
clear
(
browser
)
{
this
.
_stateByBrowser
.
delete
(
browser
)
;
}
copy
(
browser
newBrowser
)
{
let
entry
=
this
.
_stateByBrowser
.
get
(
browser
)
;
if
(
entry
)
{
this
.
_stateByBrowser
.
set
(
newBrowser
entry
)
;
}
}
}
;
const
GloballyBlockedPermissions
=
{
_stateByBrowser
:
new
WeakMap
(
)
set
(
browser
id
)
{
if
(
!
this
.
_stateByBrowser
.
has
(
browser
)
)
{
this
.
_stateByBrowser
.
set
(
browser
{
}
)
;
}
let
entry
=
this
.
_stateByBrowser
.
get
(
browser
)
;
let
prePath
=
browser
.
currentURI
.
prePath
;
if
(
!
entry
[
prePath
]
)
{
entry
[
prePath
]
=
{
}
;
}
if
(
entry
[
prePath
]
[
id
]
)
{
return
;
}
entry
[
prePath
]
[
id
]
=
true
;
browser
.
addProgressListener
(
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIWebProgressListener
"
"
nsISupportsWeakReference
"
]
)
onLocationChange
(
aWebProgress
aRequest
aLocation
aFlags
)
{
let
hasLeftPage
=
aLocation
.
prePath
!
=
prePath
|
|
!
(
aFlags
&
Ci
.
nsIWebProgressListener
.
LOCATION_CHANGE_SAME_DOCUMENT
)
;
let
isReload
=
!
!
(
aFlags
&
Ci
.
nsIWebProgressListener
.
LOCATION_CHANGE_RELOAD
)
;
if
(
aWebProgress
.
isTopLevel
&
&
(
hasLeftPage
|
|
isReload
)
)
{
GloballyBlockedPermissions
.
remove
(
browser
id
prePath
)
;
browser
.
removeProgressListener
(
this
)
;
}
}
}
Ci
.
nsIWebProgress
.
NOTIFY_LOCATION
)
;
}
remove
(
browser
id
prePath
=
null
)
{
let
entry
=
this
.
_stateByBrowser
.
get
(
browser
)
;
if
(
!
prePath
)
{
prePath
=
browser
.
currentURI
.
prePath
;
}
if
(
entry
&
&
entry
[
prePath
]
)
{
delete
entry
[
prePath
]
[
id
]
;
}
}
getAll
(
browser
)
{
let
permissions
=
[
]
;
let
entry
=
this
.
_stateByBrowser
.
get
(
browser
)
;
let
prePath
=
browser
.
currentURI
.
prePath
;
if
(
entry
&
&
entry
[
prePath
]
)
{
let
timeStamps
=
entry
[
prePath
]
;
for
(
let
id
of
Object
.
keys
(
timeStamps
)
)
{
permissions
.
push
(
{
id
state
:
gPermissions
.
get
(
id
)
.
getDefault
(
)
scope
:
SitePermissions
.
SCOPE_GLOBAL
}
)
;
}
}
return
permissions
;
}
copy
(
browser
newBrowser
)
{
let
entry
=
this
.
_stateByBrowser
.
get
(
browser
)
;
if
(
entry
)
{
this
.
_stateByBrowser
.
set
(
newBrowser
entry
)
;
}
}
}
;
var
SitePermissions
=
{
UNKNOWN
:
Services
.
perms
.
UNKNOWN_ACTION
ALLOW
:
Services
.
perms
.
ALLOW_ACTION
BLOCK
:
Services
.
perms
.
DENY_ACTION
PROMPT
:
Services
.
perms
.
PROMPT_ACTION
ALLOW_COOKIES_FOR_SESSION
:
Ci
.
nsICookiePermission
.
ACCESS_SESSION
AUTOPLAY_BLOCKED_ALL
:
Ci
.
nsIAutoplay
.
BLOCKED_ALL
SCOPE_REQUEST
:
"
{
SitePermissions
.
SCOPE_REQUEST
}
"
SCOPE_TEMPORARY
:
"
{
SitePermissions
.
SCOPE_TEMPORARY
}
"
SCOPE_SESSION
:
"
{
SitePermissions
.
SCOPE_SESSION
}
"
SCOPE_PERSISTENT
:
"
{
SitePermissions
.
SCOPE_PERSISTENT
}
"
SCOPE_POLICY
:
"
{
SitePermissions
.
SCOPE_POLICY
}
"
SCOPE_GLOBAL
:
"
{
SitePermissions
.
SCOPE_GLOBAL
}
"
PERM_KEY_DELIMITER
:
"
^
"
_permissionsArray
:
null
_defaultPrefBranch
:
Services
.
prefs
.
getBranch
(
"
permissions
.
default
.
"
)
getAllByPrincipal
(
principal
)
{
if
(
!
principal
)
{
throw
new
Error
(
"
principal
argument
cannot
be
null
.
"
)
;
}
if
(
!
this
.
isSupportedPrincipal
(
principal
)
)
{
return
[
]
;
}
let
permissions
=
Services
.
perms
.
getAllForPrincipal
(
principal
)
.
filter
(
permission
=
>
{
let
entry
=
gPermissions
.
get
(
permission
.
type
)
;
if
(
!
entry
|
|
entry
.
disabled
)
{
return
false
;
}
let
type
=
entry
.
id
;
if
(
type
=
=
"
persistent
-
storage
"
&
&
SitePermissions
.
getForPrincipal
(
principal
"
WebExtensions
-
unlimitedStorage
"
)
.
state
=
=
SitePermissions
.
ALLOW
)
{
return
false
;
}
return
true
;
}
)
;
return
permissions
.
map
(
permission
=
>
{
let
scope
=
this
.
SCOPE_PERSISTENT
;
if
(
permission
.
expireType
=
=
Services
.
perms
.
EXPIRE_SESSION
)
{
scope
=
this
.
SCOPE_SESSION
;
}
else
if
(
permission
.
expireType
=
=
Services
.
perms
.
EXPIRE_POLICY
)
{
scope
=
this
.
SCOPE_POLICY
;
}
return
{
id
:
permission
.
type
scope
state
:
permission
.
capability
}
;
}
)
;
}
getAllForBrowser
(
browser
)
{
let
permissions
=
{
}
;
for
(
let
permission
of
TemporaryPermissions
.
getAll
(
browser
)
)
{
permission
.
scope
=
this
.
SCOPE_TEMPORARY
;
permissions
[
permission
.
id
]
=
permission
;
}
for
(
let
permission
of
GloballyBlockedPermissions
.
getAll
(
browser
)
)
{
permissions
[
permission
.
id
]
=
permission
;
}
for
(
let
permission
of
this
.
getAllByPrincipal
(
browser
.
contentPrincipal
)
)
{
permissions
[
permission
.
id
]
=
permission
;
}
return
Object
.
values
(
permissions
)
;
}
getAllPermissionDetailsForBrowser
(
browser
)
{
return
this
.
getAllForBrowser
(
browser
)
.
map
(
(
{
id
scope
state
}
)
=
>
(
{
id
scope
state
label
:
this
.
getPermissionLabel
(
id
)
}
)
)
;
}
isSupportedPrincipal
(
principal
)
{
if
(
!
principal
)
{
return
false
;
}
if
(
!
(
principal
instanceof
Ci
.
nsIPrincipal
)
)
{
throw
new
Error
(
"
Argument
passed
as
principal
is
not
an
instance
of
Ci
.
nsIPrincipal
"
)
;
}
return
[
"
http
"
"
https
"
"
moz
-
extension
"
"
file
"
]
.
some
(
scheme
=
>
principal
.
schemeIs
(
scheme
)
)
;
}
listPermissions
(
)
{
if
(
this
.
_permissionsArray
=
=
=
null
)
{
this
.
_permissionsArray
=
gPermissions
.
getEnabledPermissions
(
)
;
}
return
this
.
_permissionsArray
;
}
isSitePermission
(
type
)
{
return
gPermissions
.
has
(
type
)
;
}
invalidatePermissionList
(
data
previous
latest
)
{
this
.
_permissionsArray
=
null
;
}
getAvailableStates
(
permissionID
)
{
if
(
gPermissions
.
has
(
permissionID
)
&
&
gPermissions
.
get
(
permissionID
)
.
states
)
{
return
gPermissions
.
get
(
permissionID
)
.
states
;
}
if
(
this
.
getDefault
(
permissionID
)
=
=
this
.
UNKNOWN
)
{
return
[
SitePermissions
.
UNKNOWN
SitePermissions
.
ALLOW
SitePermissions
.
BLOCK
]
;
}
return
[
SitePermissions
.
PROMPT
SitePermissions
.
ALLOW
SitePermissions
.
BLOCK
]
;
}
getDefault
(
permissionID
)
{
if
(
gPermissions
.
has
(
permissionID
)
&
&
gPermissions
.
get
(
permissionID
)
.
getDefault
)
{
return
gPermissions
.
get
(
permissionID
)
.
getDefault
(
)
;
}
return
this
.
_defaultPrefBranch
.
getIntPref
(
permissionID
this
.
UNKNOWN
)
;
}
setDefault
(
permissionID
state
)
{
if
(
gPermissions
.
has
(
permissionID
)
&
&
gPermissions
.
get
(
permissionID
)
.
setDefault
)
{
return
gPermissions
.
get
(
permissionID
)
.
setDefault
(
state
)
;
}
let
key
=
"
permissions
.
default
.
"
+
permissionID
;
return
Services
.
prefs
.
setIntPref
(
key
state
)
;
}
getForPrincipal
(
principal
permissionID
browser
)
{
if
(
!
principal
&
&
!
browser
)
{
throw
new
Error
(
"
Atleast
one
of
the
arguments
either
principal
or
browser
should
not
be
null
.
"
)
;
}
let
defaultState
=
this
.
getDefault
(
permissionID
)
;
let
result
=
{
state
:
defaultState
scope
:
this
.
SCOPE_PERSISTENT
}
;
if
(
this
.
isSupportedPrincipal
(
principal
)
)
{
let
permission
=
null
;
if
(
gPermissions
.
has
(
permissionID
)
&
&
gPermissions
.
get
(
permissionID
)
.
exactHostMatch
)
{
permission
=
Services
.
perms
.
getPermissionObject
(
principal
permissionID
true
)
;
}
else
{
permission
=
Services
.
perms
.
getPermissionObject
(
principal
permissionID
false
)
;
}
if
(
permission
)
{
result
.
state
=
permission
.
capability
;
if
(
permission
.
expireType
=
=
Services
.
perms
.
EXPIRE_SESSION
)
{
result
.
scope
=
this
.
SCOPE_SESSION
;
}
else
if
(
permission
.
expireType
=
=
Services
.
perms
.
EXPIRE_POLICY
)
{
result
.
scope
=
this
.
SCOPE_POLICY
;
}
}
}
if
(
result
.
state
=
=
defaultState
)
{
let
value
=
TemporaryPermissions
.
get
(
browser
permissionID
)
;
if
(
value
)
{
result
.
state
=
value
.
state
;
result
.
scope
=
this
.
SCOPE_TEMPORARY
;
}
}
return
result
;
}
setForPrincipal
(
principal
permissionID
state
scope
=
this
.
SCOPE_PERSISTENT
browser
=
null
)
{
if
(
!
principal
&
&
!
browser
)
{
throw
new
Error
(
"
Atleast
one
of
the
arguments
either
principal
or
browser
should
not
be
null
.
"
)
;
}
if
(
scope
=
=
this
.
SCOPE_GLOBAL
&
&
state
=
=
this
.
BLOCK
)
{
GloballyBlockedPermissions
.
set
(
browser
permissionID
)
;
browser
.
dispatchEvent
(
new
browser
.
ownerGlobal
.
CustomEvent
(
"
PermissionStateChange
"
)
)
;
return
;
}
if
(
state
=
=
this
.
UNKNOWN
|
|
state
=
=
this
.
getDefault
(
permissionID
)
)
{
if
(
permissionID
!
=
"
cookie
"
)
{
this
.
removeFromPrincipal
(
principal
permissionID
browser
)
;
return
;
}
}
if
(
state
=
=
this
.
ALLOW_COOKIES_FOR_SESSION
&
&
permissionID
!
=
"
cookie
"
)
{
throw
new
Error
(
"
ALLOW_COOKIES_FOR_SESSION
can
only
be
set
on
the
cookie
permission
"
)
;
}
if
(
scope
=
=
this
.
SCOPE_TEMPORARY
)
{
if
(
state
!
=
this
.
BLOCK
)
{
throw
new
Error
(
"
'
Block
'
is
the
only
permission
we
can
save
temporarily
on
a
browser
"
)
;
}
if
(
!
browser
)
{
throw
new
Error
(
"
TEMPORARY
scoped
permissions
require
a
browser
object
"
)
;
}
TemporaryPermissions
.
set
(
browser
permissionID
state
)
;
browser
.
dispatchEvent
(
new
browser
.
ownerGlobal
.
CustomEvent
(
"
PermissionStateChange
"
)
)
;
}
else
if
(
this
.
isSupportedPrincipal
(
principal
)
)
{
let
perms_scope
=
Services
.
perms
.
EXPIRE_NEVER
;
if
(
scope
=
=
this
.
SCOPE_SESSION
)
{
perms_scope
=
Services
.
perms
.
EXPIRE_SESSION
;
}
else
if
(
scope
=
=
this
.
SCOPE_POLICY
)
{
perms_scope
=
Services
.
perms
.
EXPIRE_POLICY
;
}
Services
.
perms
.
addFromPrincipal
(
principal
permissionID
state
perms_scope
)
;
}
}
removeFromPrincipal
(
principal
permissionID
browser
)
{
if
(
!
principal
&
&
!
browser
)
{
throw
new
Error
(
"
Atleast
one
of
the
arguments
either
principal
or
browser
should
not
be
null
.
"
)
;
}
if
(
this
.
isSupportedPrincipal
(
principal
)
)
{
Services
.
perms
.
removeFromPrincipal
(
principal
permissionID
)
;
}
if
(
TemporaryPermissions
.
get
(
browser
permissionID
)
)
{
TemporaryPermissions
.
remove
(
browser
permissionID
)
;
browser
.
dispatchEvent
(
new
browser
.
ownerGlobal
.
CustomEvent
(
"
PermissionStateChange
"
)
)
;
}
}
clearTemporaryPermissions
(
browser
)
{
TemporaryPermissions
.
clear
(
browser
)
;
}
copyTemporaryPermissions
(
browser
newBrowser
)
{
TemporaryPermissions
.
copy
(
browser
newBrowser
)
;
GloballyBlockedPermissions
.
copy
(
browser
newBrowser
)
;
}
getPermissionLabel
(
permissionID
)
{
let
[
id
key
]
=
permissionID
.
split
(
this
.
PERM_KEY_DELIMITER
)
;
if
(
!
gPermissions
.
has
(
id
)
)
{
return
null
;
}
if
(
"
labelID
"
in
gPermissions
.
get
(
id
)
&
&
gPermissions
.
get
(
id
)
.
labelID
=
=
=
null
)
{
return
null
;
}
if
(
id
=
=
"
3rdPartyStorage
"
)
{
return
key
;
}
let
labelID
=
gPermissions
.
get
(
id
)
.
labelID
|
|
id
;
return
gStringBundle
.
formatStringFromName
(
permission
.
{
labelID
}
.
label
[
key
]
)
;
}
getMultichoiceStateLabel
(
permissionID
state
)
{
if
(
gPermissions
.
has
(
permissionID
)
&
&
gPermissions
.
get
(
permissionID
)
.
getMultichoiceStateLabel
)
{
return
gPermissions
.
get
(
permissionID
)
.
getMultichoiceStateLabel
(
state
)
;
}
switch
(
state
)
{
case
this
.
UNKNOWN
:
case
this
.
PROMPT
:
return
gStringBundle
.
GetStringFromName
(
"
state
.
multichoice
.
alwaysAsk
"
)
;
case
this
.
ALLOW
:
return
gStringBundle
.
GetStringFromName
(
"
state
.
multichoice
.
allow
"
)
;
case
this
.
ALLOW_COOKIES_FOR_SESSION
:
return
gStringBundle
.
GetStringFromName
(
"
state
.
multichoice
.
allowForSession
"
)
;
case
this
.
BLOCK
:
return
gStringBundle
.
GetStringFromName
(
"
state
.
multichoice
.
block
"
)
;
default
:
return
null
;
}
}
getCurrentStateLabel
(
state
id
scope
=
null
)
{
switch
(
state
)
{
case
this
.
PROMPT
:
return
gStringBundle
.
GetStringFromName
(
"
state
.
current
.
prompt
"
)
;
case
this
.
ALLOW
:
if
(
scope
&
&
scope
!
=
this
.
SCOPE_PERSISTENT
&
&
scope
!
=
this
.
SCOPE_POLICY
)
{
return
gStringBundle
.
GetStringFromName
(
"
state
.
current
.
allowedTemporarily
"
)
;
}
return
gStringBundle
.
GetStringFromName
(
"
state
.
current
.
allowed
"
)
;
case
this
.
ALLOW_COOKIES_FOR_SESSION
:
return
gStringBundle
.
GetStringFromName
(
"
state
.
current
.
allowedForSession
"
)
;
case
this
.
BLOCK
:
if
(
scope
&
&
scope
!
=
this
.
SCOPE_PERSISTENT
&
&
scope
!
=
this
.
SCOPE_POLICY
&
&
scope
!
=
this
.
SCOPE_GLOBAL
)
{
return
gStringBundle
.
GetStringFromName
(
"
state
.
current
.
blockedTemporarily
"
)
;
}
return
gStringBundle
.
GetStringFromName
(
"
state
.
current
.
blocked
"
)
;
default
:
return
null
;
}
}
}
;
let
gPermissions
=
{
_getId
(
type
)
{
let
[
id
]
=
type
.
split
(
SitePermissions
.
PERM_KEY_DELIMITER
)
;
return
id
;
}
has
(
type
)
{
return
this
.
_getId
(
type
)
in
this
.
_permissions
;
}
get
(
type
)
{
let
id
=
this
.
_getId
(
type
)
;
let
perm
=
this
.
_permissions
[
id
]
;
if
(
perm
)
{
perm
.
id
=
id
;
}
return
perm
;
}
getEnabledPermissions
(
)
{
return
Object
.
keys
(
this
.
_permissions
)
.
filter
(
id
=
>
!
this
.
_permissions
[
id
]
.
disabled
)
;
}
_permissions
:
{
"
autoplay
-
media
"
:
{
exactHostMatch
:
true
getDefault
(
)
{
let
pref
=
Services
.
prefs
.
getIntPref
(
"
media
.
autoplay
.
default
"
Ci
.
nsIAutoplay
.
BLOCKED
)
;
if
(
pref
=
=
Ci
.
nsIAutoplay
.
ALLOWED
)
{
return
SitePermissions
.
ALLOW
;
}
if
(
pref
=
=
Ci
.
nsIAutoplay
.
BLOCKED_ALL
)
{
return
SitePermissions
.
AUTOPLAY_BLOCKED_ALL
;
}
return
SitePermissions
.
BLOCK
;
}
setDefault
(
value
)
{
let
prefValue
=
Ci
.
nsIAutoplay
.
BLOCKED
;
if
(
value
=
=
SitePermissions
.
ALLOW
)
{
prefValue
=
Ci
.
nsIAutoplay
.
ALLOWED
;
}
else
if
(
value
=
=
SitePermissions
.
AUTOPLAY_BLOCKED_ALL
)
{
prefValue
=
Ci
.
nsIAutoplay
.
BLOCKED_ALL
;
}
Services
.
prefs
.
setIntPref
(
"
media
.
autoplay
.
default
"
prefValue
)
;
}
labelID
:
"
autoplay
"
states
:
[
SitePermissions
.
ALLOW
SitePermissions
.
BLOCK
SitePermissions
.
AUTOPLAY_BLOCKED_ALL
]
getMultichoiceStateLabel
(
state
)
{
switch
(
state
)
{
case
SitePermissions
.
AUTOPLAY_BLOCKED_ALL
:
return
gStringBundle
.
GetStringFromName
(
"
state
.
multichoice
.
autoplayblockall
"
)
;
case
SitePermissions
.
BLOCK
:
return
gStringBundle
.
GetStringFromName
(
"
state
.
multichoice
.
autoplayblock
"
)
;
case
SitePermissions
.
ALLOW
:
return
gStringBundle
.
GetStringFromName
(
"
state
.
multichoice
.
autoplayallow
"
)
;
}
throw
new
Error
(
Unknown
state
:
{
state
}
)
;
}
}
cookie
:
{
states
:
[
SitePermissions
.
ALLOW
SitePermissions
.
ALLOW_COOKIES_FOR_SESSION
SitePermissions
.
BLOCK
]
getDefault
(
)
{
if
(
Services
.
cookies
.
cookieBehavior
=
=
Ci
.
nsICookieService
.
BEHAVIOR_REJECT
)
{
return
SitePermissions
.
BLOCK
;
}
if
(
Services
.
prefs
.
getIntPref
(
"
network
.
cookie
.
lifetimePolicy
"
)
=
=
Ci
.
nsICookieService
.
ACCEPT_SESSION
)
{
return
SitePermissions
.
ALLOW_COOKIES_FOR_SESSION
;
}
return
SitePermissions
.
ALLOW
;
}
}
"
desktop
-
notification
"
:
{
exactHostMatch
:
true
labelID
:
"
desktop
-
notification3
"
}
camera
:
{
exactHostMatch
:
true
}
microphone
:
{
exactHostMatch
:
true
}
screen
:
{
exactHostMatch
:
true
states
:
[
SitePermissions
.
UNKNOWN
SitePermissions
.
BLOCK
]
}
popup
:
{
getDefault
(
)
{
return
Services
.
prefs
.
getBoolPref
(
"
dom
.
disable_open_during_load
"
)
?
SitePermissions
.
BLOCK
:
SitePermissions
.
ALLOW
;
}
states
:
[
SitePermissions
.
ALLOW
SitePermissions
.
BLOCK
]
}
install
:
{
getDefault
(
)
{
return
Services
.
prefs
.
getBoolPref
(
"
xpinstall
.
whitelist
.
required
"
)
?
SitePermissions
.
UNKNOWN
:
SitePermissions
.
ALLOW
;
}
}
geo
:
{
exactHostMatch
:
true
}
"
open
-
protocol
-
handler
"
:
{
labelID
:
"
open
-
protocol
-
handler
"
exactHostMatch
:
true
states
:
[
SitePermissions
.
UNKNOWN
SitePermissions
.
ALLOW
]
get
disabled
(
)
{
return
!
SitePermissions
.
openProtoPermissionEnabled
;
}
}
xr
:
{
exactHostMatch
:
true
}
"
focus
-
tab
-
by
-
prompt
"
:
{
exactHostMatch
:
true
states
:
[
SitePermissions
.
UNKNOWN
SitePermissions
.
ALLOW
]
}
"
persistent
-
storage
"
:
{
exactHostMatch
:
true
}
shortcuts
:
{
states
:
[
SitePermissions
.
ALLOW
SitePermissions
.
BLOCK
]
}
canvas
:
{
get
disabled
(
)
{
return
!
SitePermissions
.
resistFingerprinting
;
}
}
midi
:
{
exactHostMatch
:
true
get
disabled
(
)
{
return
!
SitePermissions
.
midiPermissionEnabled
;
}
}
"
midi
-
sysex
"
:
{
exactHostMatch
:
true
get
disabled
(
)
{
return
!
SitePermissions
.
midiPermissionEnabled
;
}
}
"
storage
-
access
"
:
{
labelID
:
null
getDefault
(
)
{
return
SitePermissions
.
UNKNOWN
;
}
}
"
3rdPartyStorage
"
:
{
get
disabled
(
)
{
return
!
SitePermissions
.
statePartitioningPermissionsEnabled
;
}
}
}
}
;
SitePermissions
.
midiPermissionEnabled
=
Services
.
prefs
.
getBoolPref
(
"
dom
.
webmidi
.
enabled
"
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
SitePermissions
"
temporaryPermissionExpireTime
"
"
privacy
.
temporary_permission_expire_time_ms
"
3600
*
1000
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
SitePermissions
"
resistFingerprinting
"
"
privacy
.
resistFingerprinting
"
false
SitePermissions
.
invalidatePermissionList
.
bind
(
SitePermissions
)
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
SitePermissions
"
openProtoPermissionEnabled
"
"
security
.
external_protocol_requires_permission
"
true
SitePermissions
.
invalidatePermissionList
.
bind
(
SitePermissions
)
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
SitePermissions
"
statePartitioningPermissionsEnabled
"
"
browser
.
contentblocking
.
state
-
partitioning
.
mvp
.
ui
.
enabled
"
false
SitePermissions
.
invalidatePermissionList
.
bind
(
SitePermissions
)
)
;
