var
EXPORTED_SYMBOLS
=
[
"
SitePermissions
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
clearTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
setTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
}
)
;
var
gStringBundle
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
browser
/
locale
/
sitePermissions
.
properties
"
)
;
const
TemporaryPermissions
=
{
_stateByBrowser
:
new
WeakMap
(
)
_uriToBaseDomain
(
uri
)
{
try
{
return
Services
.
eTLD
.
getBaseDomain
(
uri
)
;
}
catch
(
error
)
{
if
(
error
.
result
!
=
=
Cr
.
NS_ERROR_HOST_IS_IP_ADDRESS
&
&
error
.
result
!
=
=
Cr
.
NS_ERROR_INSUFFICIENT_DOMAIN_LEVELS
)
{
throw
error
;
}
return
uri
.
host
;
}
}
_getKeysFromURI
(
uri
)
{
return
{
strict
:
uri
.
prePath
nonStrict
:
this
.
_uriToBaseDomain
(
uri
)
}
;
}
set
(
browser
id
state
expireTimeMS
browserURI
expireCallback
)
{
if
(
!
browser
|
|
!
browserURI
|
|
!
SitePermissions
.
isSupportedScheme
(
browserURI
.
scheme
)
)
{
return
;
}
let
entry
=
this
.
_stateByBrowser
.
get
(
browser
)
;
if
(
!
entry
)
{
entry
=
{
browser
:
Cu
.
getWeakReference
(
browser
)
uriToPerm
:
{
}
}
;
this
.
_stateByBrowser
.
set
(
browser
entry
)
;
}
let
{
uriToPerm
}
=
entry
;
let
{
strict
nonStrict
}
=
this
.
_getKeysFromURI
(
browserURI
)
;
let
setKey
;
let
deleteKey
;
if
(
state
=
=
SitePermissions
.
BLOCK
)
{
setKey
=
nonStrict
;
deleteKey
=
strict
;
}
else
{
setKey
=
strict
;
deleteKey
=
nonStrict
;
}
if
(
!
uriToPerm
[
setKey
]
)
{
uriToPerm
[
setKey
]
=
{
}
;
}
let
expireTimeout
=
uriToPerm
[
setKey
]
[
id
]
?
.
expireTimeout
;
if
(
expireTimeout
)
{
lazy
.
clearTimeout
(
expireTimeout
)
;
}
expireTimeout
=
lazy
.
setTimeout
(
(
)
=
>
{
let
entryBrowser
=
entry
.
browser
.
get
(
)
;
if
(
!
entryBrowser
|
|
!
uriToPerm
[
setKey
]
)
{
return
;
}
delete
uriToPerm
[
setKey
]
[
id
]
;
expireCallback
(
entryBrowser
)
;
}
expireTimeMS
)
;
uriToPerm
[
setKey
]
[
id
]
=
{
expireTimeout
state
}
;
let
permissions
=
uriToPerm
[
deleteKey
]
;
if
(
!
permissions
)
{
return
;
}
expireTimeout
=
permissions
[
id
]
?
.
expireTimeout
;
if
(
expireTimeout
)
{
lazy
.
clearTimeout
(
expireTimeout
)
;
}
delete
permissions
[
id
]
;
}
remove
(
browser
id
)
{
if
(
!
browser
|
|
!
SitePermissions
.
isSupportedScheme
(
browser
.
currentURI
.
scheme
)
|
|
!
this
.
_stateByBrowser
.
has
(
browser
)
)
{
return
;
}
let
{
strict
nonStrict
}
=
this
.
_getKeysFromURI
(
browser
.
currentURI
)
;
let
{
uriToPerm
}
=
this
.
_stateByBrowser
.
get
(
browser
)
;
for
(
let
key
of
[
nonStrict
strict
]
)
{
if
(
uriToPerm
[
key
]
?
.
[
id
]
!
=
null
)
{
let
{
expireTimeout
}
=
uriToPerm
[
key
]
[
id
]
;
if
(
expireTimeout
)
{
lazy
.
clearTimeout
(
expireTimeout
)
;
}
delete
uriToPerm
[
key
]
[
id
]
;
return
;
}
}
}
get
(
browser
id
browserURI
=
browser
?
.
currentURI
)
{
if
(
!
browser
|
|
!
browser
.
currentURI
|
|
!
SitePermissions
.
isSupportedScheme
(
browserURI
.
scheme
)
|
|
!
this
.
_stateByBrowser
.
has
(
browser
)
)
{
return
null
;
}
let
{
uriToPerm
}
=
this
.
_stateByBrowser
.
get
(
browser
)
;
let
{
strict
nonStrict
}
=
this
.
_getKeysFromURI
(
browserURI
)
;
for
(
let
key
of
[
nonStrict
strict
]
)
{
if
(
uriToPerm
[
key
]
)
{
let
permission
=
uriToPerm
[
key
]
[
id
]
;
if
(
permission
)
{
return
{
id
state
:
permission
.
state
scope
:
SitePermissions
.
SCOPE_TEMPORARY
}
;
}
}
}
return
null
;
}
getAll
(
browser
browserURI
=
browser
?
.
currentURI
)
{
let
permissions
=
[
]
;
if
(
!
SitePermissions
.
isSupportedScheme
(
browserURI
.
scheme
)
|
|
!
this
.
_stateByBrowser
.
has
(
browser
)
)
{
return
permissions
;
}
let
{
uriToPerm
}
=
this
.
_stateByBrowser
.
get
(
browser
)
;
let
{
strict
nonStrict
}
=
this
.
_getKeysFromURI
(
browserURI
)
;
for
(
let
key
of
[
nonStrict
strict
]
)
{
if
(
uriToPerm
[
key
]
)
{
let
perms
=
uriToPerm
[
key
]
;
for
(
let
id
of
Object
.
keys
(
perms
)
)
{
let
permission
=
perms
[
id
]
;
if
(
permission
)
{
permissions
.
push
(
{
id
state
:
permission
.
state
scope
:
SitePermissions
.
SCOPE_TEMPORARY
}
)
;
}
}
}
}
return
permissions
;
}
clear
(
browser
filterState
=
null
)
{
let
entry
=
this
.
_stateByBrowser
.
get
(
browser
)
;
if
(
!
entry
?
.
uriToPerm
)
{
return
;
}
let
{
uriToPerm
}
=
entry
;
Object
.
entries
(
uriToPerm
)
.
forEach
(
(
[
uriKey
permissions
]
)
=
>
{
Object
.
entries
(
permissions
)
.
forEach
(
(
[
permId
{
state
expireTimeout
}
]
)
=
>
{
if
(
filterState
!
=
null
)
{
if
(
state
!
=
filterState
)
{
return
;
}
delete
permissions
[
permId
]
;
}
if
(
!
expireTimeout
)
{
return
;
}
lazy
.
clearTimeout
(
expireTimeout
)
;
}
)
;
if
(
filterState
!
=
null
&
&
!
Object
.
keys
(
permissions
)
.
length
)
{
delete
uriToPerm
[
uriKey
]
;
}
}
)
;
if
(
filterState
=
=
null
|
|
!
Object
.
keys
(
uriToPerm
)
.
length
)
{
this
.
_stateByBrowser
.
delete
(
browser
)
;
}
}
copy
(
browser
newBrowser
)
{
let
entry
=
this
.
_stateByBrowser
.
get
(
browser
)
;
if
(
entry
)
{
entry
.
browser
=
Cu
.
getWeakReference
(
newBrowser
)
;
this
.
_stateByBrowser
.
set
(
newBrowser
entry
)
;
}
}
}
;
const
GloballyBlockedPermissions
=
{
_stateByBrowser
:
new
WeakMap
(
)
set
(
browser
id
)
{
if
(
!
this
.
_stateByBrowser
.
has
(
browser
)
)
{
this
.
_stateByBrowser
.
set
(
browser
{
}
)
;
}
let
entry
=
this
.
_stateByBrowser
.
get
(
browser
)
;
let
prePath
=
browser
.
currentURI
.
prePath
;
if
(
!
entry
[
prePath
]
)
{
entry
[
prePath
]
=
{
}
;
}
if
(
entry
[
prePath
]
[
id
]
)
{
return
;
}
entry
[
prePath
]
[
id
]
=
true
;
browser
.
addProgressListener
(
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIWebProgressListener
"
"
nsISupportsWeakReference
"
]
)
onLocationChange
(
aWebProgress
aRequest
aLocation
aFlags
)
{
let
hasLeftPage
=
aLocation
.
prePath
!
=
prePath
|
|
!
(
aFlags
&
Ci
.
nsIWebProgressListener
.
LOCATION_CHANGE_SAME_DOCUMENT
)
;
let
isReload
=
!
!
(
aFlags
&
Ci
.
nsIWebProgressListener
.
LOCATION_CHANGE_RELOAD
)
;
if
(
aWebProgress
.
isTopLevel
&
&
(
hasLeftPage
|
|
isReload
)
)
{
GloballyBlockedPermissions
.
remove
(
browser
id
prePath
)
;
browser
.
removeProgressListener
(
this
)
;
}
}
}
Ci
.
nsIWebProgress
.
NOTIFY_LOCATION
)
;
}
remove
(
browser
id
prePath
=
null
)
{
let
entry
=
this
.
_stateByBrowser
.
get
(
browser
)
;
if
(
!
prePath
)
{
prePath
=
browser
.
currentURI
.
prePath
;
}
if
(
entry
&
&
entry
[
prePath
]
)
{
delete
entry
[
prePath
]
[
id
]
;
}
}
getAll
(
browser
)
{
let
permissions
=
[
]
;
let
entry
=
this
.
_stateByBrowser
.
get
(
browser
)
;
let
prePath
=
browser
.
currentURI
.
prePath
;
if
(
entry
&
&
entry
[
prePath
]
)
{
let
timeStamps
=
entry
[
prePath
]
;
for
(
let
id
of
Object
.
keys
(
timeStamps
)
)
{
permissions
.
push
(
{
id
state
:
gPermissions
.
get
(
id
)
.
getDefault
(
)
scope
:
SitePermissions
.
SCOPE_GLOBAL
}
)
;
}
}
return
permissions
;
}
copy
(
browser
newBrowser
)
{
let
entry
=
this
.
_stateByBrowser
.
get
(
browser
)
;
if
(
entry
)
{
this
.
_stateByBrowser
.
set
(
newBrowser
entry
)
;
}
}
}
;
var
SitePermissions
=
{
UNKNOWN
:
Services
.
perms
.
UNKNOWN_ACTION
ALLOW
:
Services
.
perms
.
ALLOW_ACTION
BLOCK
:
Services
.
perms
.
DENY_ACTION
PROMPT
:
Services
.
perms
.
PROMPT_ACTION
ALLOW_COOKIES_FOR_SESSION
:
Ci
.
nsICookiePermission
.
ACCESS_SESSION
AUTOPLAY_BLOCKED_ALL
:
Ci
.
nsIAutoplay
.
BLOCKED_ALL
SCOPE_REQUEST
:
"
{
SitePermissions
.
SCOPE_REQUEST
}
"
SCOPE_TEMPORARY
:
"
{
SitePermissions
.
SCOPE_TEMPORARY
}
"
SCOPE_SESSION
:
"
{
SitePermissions
.
SCOPE_SESSION
}
"
SCOPE_PERSISTENT
:
"
{
SitePermissions
.
SCOPE_PERSISTENT
}
"
SCOPE_POLICY
:
"
{
SitePermissions
.
SCOPE_POLICY
}
"
SCOPE_GLOBAL
:
"
{
SitePermissions
.
SCOPE_GLOBAL
}
"
PERM_KEY_DELIMITER
:
"
^
"
_permissionsArray
:
null
_defaultPrefBranch
:
Services
.
prefs
.
getBranch
(
"
permissions
.
default
.
"
)
_temporaryPermissions
:
TemporaryPermissions
getAllByPrincipal
(
principal
)
{
if
(
!
principal
)
{
throw
new
Error
(
"
principal
argument
cannot
be
null
.
"
)
;
}
if
(
!
this
.
isSupportedPrincipal
(
principal
)
)
{
return
[
]
;
}
let
permissions
=
Services
.
perms
.
getAllForPrincipal
(
principal
)
.
filter
(
permission
=
>
{
let
entry
=
gPermissions
.
get
(
permission
.
type
)
;
if
(
!
entry
|
|
entry
.
disabled
)
{
return
false
;
}
let
type
=
entry
.
id
;
if
(
type
=
=
"
persistent
-
storage
"
&
&
SitePermissions
.
getForPrincipal
(
principal
"
WebExtensions
-
unlimitedStorage
"
)
.
state
=
=
SitePermissions
.
ALLOW
)
{
return
false
;
}
return
true
;
}
)
;
return
permissions
.
map
(
permission
=
>
{
let
scope
=
this
.
SCOPE_PERSISTENT
;
if
(
permission
.
expireType
=
=
Services
.
perms
.
EXPIRE_SESSION
)
{
scope
=
this
.
SCOPE_SESSION
;
}
else
if
(
permission
.
expireType
=
=
Services
.
perms
.
EXPIRE_POLICY
)
{
scope
=
this
.
SCOPE_POLICY
;
}
return
{
id
:
permission
.
type
scope
state
:
permission
.
capability
}
;
}
)
;
}
getAllForBrowser
(
browser
)
{
let
permissions
=
{
}
;
for
(
let
permission
of
TemporaryPermissions
.
getAll
(
browser
)
)
{
permission
.
scope
=
this
.
SCOPE_TEMPORARY
;
permissions
[
permission
.
id
]
=
permission
;
}
for
(
let
permission
of
GloballyBlockedPermissions
.
getAll
(
browser
)
)
{
permissions
[
permission
.
id
]
=
permission
;
}
for
(
let
permission
of
this
.
getAllByPrincipal
(
browser
.
contentPrincipal
)
)
{
permissions
[
permission
.
id
]
=
permission
;
}
return
Object
.
values
(
permissions
)
;
}
getAllPermissionDetailsForBrowser
(
browser
)
{
return
this
.
getAllForBrowser
(
browser
)
.
map
(
(
{
id
scope
state
}
)
=
>
(
{
id
scope
state
label
:
this
.
getPermissionLabel
(
id
)
}
)
)
;
}
isSupportedPrincipal
(
principal
)
{
if
(
!
principal
)
{
return
false
;
}
if
(
!
(
principal
instanceof
Ci
.
nsIPrincipal
)
)
{
throw
new
Error
(
"
Argument
passed
as
principal
is
not
an
instance
of
Ci
.
nsIPrincipal
"
)
;
}
return
this
.
isSupportedScheme
(
principal
.
scheme
)
;
}
isSupportedScheme
(
scheme
)
{
return
[
"
http
"
"
https
"
"
moz
-
extension
"
"
file
"
]
.
includes
(
scheme
)
;
}
listPermissions
(
)
{
if
(
this
.
_permissionsArray
=
=
=
null
)
{
this
.
_permissionsArray
=
gPermissions
.
getEnabledPermissions
(
)
;
}
return
this
.
_permissionsArray
;
}
isSitePermission
(
type
)
{
return
gPermissions
.
has
(
type
)
;
}
invalidatePermissionList
(
data
previous
latest
)
{
this
.
_permissionsArray
=
null
;
}
getAvailableStates
(
permissionID
)
{
if
(
gPermissions
.
has
(
permissionID
)
&
&
gPermissions
.
get
(
permissionID
)
.
states
)
{
return
gPermissions
.
get
(
permissionID
)
.
states
;
}
if
(
this
.
getDefault
(
permissionID
)
=
=
this
.
UNKNOWN
)
{
return
[
SitePermissions
.
UNKNOWN
SitePermissions
.
ALLOW
SitePermissions
.
BLOCK
]
;
}
return
[
SitePermissions
.
PROMPT
SitePermissions
.
ALLOW
SitePermissions
.
BLOCK
]
;
}
getDefault
(
permissionID
)
{
if
(
gPermissions
.
has
(
permissionID
)
&
&
gPermissions
.
get
(
permissionID
)
.
getDefault
)
{
return
gPermissions
.
get
(
permissionID
)
.
getDefault
(
)
;
}
return
this
.
_defaultPrefBranch
.
getIntPref
(
permissionID
this
.
UNKNOWN
)
;
}
setDefault
(
permissionID
state
)
{
if
(
gPermissions
.
has
(
permissionID
)
&
&
gPermissions
.
get
(
permissionID
)
.
setDefault
)
{
return
gPermissions
.
get
(
permissionID
)
.
setDefault
(
state
)
;
}
let
key
=
"
permissions
.
default
.
"
+
permissionID
;
return
Services
.
prefs
.
setIntPref
(
key
state
)
;
}
getForPrincipal
(
principal
permissionID
browser
browserURI
=
browser
?
.
currentURI
)
{
if
(
!
principal
&
&
!
browser
)
{
throw
new
Error
(
"
Atleast
one
of
the
arguments
either
principal
or
browser
should
not
be
null
.
"
)
;
}
let
defaultState
=
this
.
getDefault
(
permissionID
)
;
let
result
=
{
state
:
defaultState
scope
:
this
.
SCOPE_PERSISTENT
}
;
if
(
this
.
isSupportedPrincipal
(
principal
)
)
{
let
permission
=
null
;
if
(
gPermissions
.
has
(
permissionID
)
&
&
gPermissions
.
get
(
permissionID
)
.
exactHostMatch
)
{
permission
=
Services
.
perms
.
getPermissionObject
(
principal
permissionID
true
)
;
}
else
{
permission
=
Services
.
perms
.
getPermissionObject
(
principal
permissionID
false
)
;
}
if
(
permission
)
{
result
.
state
=
permission
.
capability
;
if
(
permission
.
expireType
=
=
Services
.
perms
.
EXPIRE_SESSION
)
{
result
.
scope
=
this
.
SCOPE_SESSION
;
}
else
if
(
permission
.
expireType
=
=
Services
.
perms
.
EXPIRE_POLICY
)
{
result
.
scope
=
this
.
SCOPE_POLICY
;
}
}
}
if
(
result
.
state
=
=
defaultState
)
{
let
value
=
TemporaryPermissions
.
get
(
browser
permissionID
browserURI
)
;
if
(
value
)
{
result
.
state
=
value
.
state
;
result
.
scope
=
this
.
SCOPE_TEMPORARY
;
}
}
return
result
;
}
setForPrincipal
(
principal
permissionID
state
scope
=
this
.
SCOPE_PERSISTENT
browser
=
null
expireTimeMS
=
SitePermissions
.
temporaryPermissionExpireTime
browserURI
=
browser
?
.
currentURI
)
{
if
(
!
principal
&
&
!
browser
)
{
throw
new
Error
(
"
Atleast
one
of
the
arguments
either
principal
or
browser
should
not
be
null
.
"
)
;
}
if
(
scope
=
=
this
.
SCOPE_GLOBAL
&
&
state
=
=
this
.
BLOCK
)
{
GloballyBlockedPermissions
.
set
(
browser
permissionID
)
;
browser
.
dispatchEvent
(
new
browser
.
ownerGlobal
.
CustomEvent
(
"
PermissionStateChange
"
)
)
;
return
;
}
if
(
state
=
=
this
.
UNKNOWN
|
|
state
=
=
this
.
getDefault
(
permissionID
)
)
{
if
(
permissionID
!
=
"
cookie
"
)
{
this
.
removeFromPrincipal
(
principal
permissionID
browser
)
;
return
;
}
}
if
(
state
=
=
this
.
ALLOW_COOKIES_FOR_SESSION
&
&
permissionID
!
=
"
cookie
"
)
{
throw
new
Error
(
"
ALLOW_COOKIES_FOR_SESSION
can
only
be
set
on
the
cookie
permission
"
)
;
}
if
(
scope
=
=
this
.
SCOPE_TEMPORARY
)
{
if
(
!
browser
)
{
throw
new
Error
(
"
TEMPORARY
scoped
permissions
require
a
browser
object
"
)
;
}
if
(
!
Number
.
isInteger
(
expireTimeMS
)
|
|
expireTimeMS
<
=
0
)
{
throw
new
Error
(
"
expireTime
must
be
a
positive
integer
"
)
;
}
TemporaryPermissions
.
set
(
browser
permissionID
state
expireTimeMS
browserURI
origBrowser
=
>
{
if
(
!
origBrowser
.
ownerGlobal
)
{
return
;
}
origBrowser
.
dispatchEvent
(
new
origBrowser
.
ownerGlobal
.
CustomEvent
(
"
PermissionStateChange
"
)
)
;
}
)
;
browser
.
dispatchEvent
(
new
browser
.
ownerGlobal
.
CustomEvent
(
"
PermissionStateChange
"
)
)
;
}
else
if
(
this
.
isSupportedPrincipal
(
principal
)
)
{
let
perms_scope
=
Services
.
perms
.
EXPIRE_NEVER
;
if
(
scope
=
=
this
.
SCOPE_SESSION
)
{
perms_scope
=
Services
.
perms
.
EXPIRE_SESSION
;
}
else
if
(
scope
=
=
this
.
SCOPE_POLICY
)
{
perms_scope
=
Services
.
perms
.
EXPIRE_POLICY
;
}
Services
.
perms
.
addFromPrincipal
(
principal
permissionID
state
perms_scope
)
;
}
}
removeFromPrincipal
(
principal
permissionID
browser
)
{
if
(
!
principal
&
&
!
browser
)
{
throw
new
Error
(
"
Atleast
one
of
the
arguments
either
principal
or
browser
should
not
be
null
.
"
)
;
}
if
(
this
.
isSupportedPrincipal
(
principal
)
)
{
Services
.
perms
.
removeFromPrincipal
(
principal
permissionID
)
;
}
if
(
TemporaryPermissions
.
get
(
browser
permissionID
)
)
{
TemporaryPermissions
.
remove
(
browser
permissionID
)
;
browser
.
dispatchEvent
(
new
browser
.
ownerGlobal
.
CustomEvent
(
"
PermissionStateChange
"
)
)
;
}
}
clearTemporaryBlockPermissions
(
browser
)
{
TemporaryPermissions
.
clear
(
browser
SitePermissions
.
BLOCK
)
;
}
copyTemporaryPermissions
(
browser
newBrowser
)
{
TemporaryPermissions
.
copy
(
browser
newBrowser
)
;
GloballyBlockedPermissions
.
copy
(
browser
newBrowser
)
;
}
getPermissionLabel
(
permissionID
)
{
let
[
id
key
]
=
permissionID
.
split
(
this
.
PERM_KEY_DELIMITER
)
;
if
(
!
gPermissions
.
has
(
id
)
)
{
return
null
;
}
if
(
"
labelID
"
in
gPermissions
.
get
(
id
)
&
&
gPermissions
.
get
(
id
)
.
labelID
=
=
=
null
)
{
return
null
;
}
if
(
id
=
=
"
3rdPartyStorage
"
)
{
return
key
;
}
let
labelID
=
gPermissions
.
get
(
id
)
.
labelID
|
|
id
;
return
gStringBundle
.
formatStringFromName
(
permission
.
{
labelID
}
.
label
[
key
]
)
;
}
getMultichoiceStateLabel
(
permissionID
state
)
{
if
(
gPermissions
.
has
(
permissionID
)
&
&
gPermissions
.
get
(
permissionID
)
.
getMultichoiceStateLabel
)
{
return
gPermissions
.
get
(
permissionID
)
.
getMultichoiceStateLabel
(
state
)
;
}
switch
(
state
)
{
case
this
.
UNKNOWN
:
case
this
.
PROMPT
:
return
gStringBundle
.
GetStringFromName
(
"
state
.
multichoice
.
alwaysAsk
"
)
;
case
this
.
ALLOW
:
return
gStringBundle
.
GetStringFromName
(
"
state
.
multichoice
.
allow
"
)
;
case
this
.
ALLOW_COOKIES_FOR_SESSION
:
return
gStringBundle
.
GetStringFromName
(
"
state
.
multichoice
.
allowForSession
"
)
;
case
this
.
BLOCK
:
return
gStringBundle
.
GetStringFromName
(
"
state
.
multichoice
.
block
"
)
;
default
:
return
null
;
}
}
getCurrentStateLabel
(
state
id
scope
=
null
)
{
switch
(
state
)
{
case
this
.
PROMPT
:
return
gStringBundle
.
GetStringFromName
(
"
state
.
current
.
prompt
"
)
;
case
this
.
ALLOW
:
if
(
scope
&
&
scope
!
=
this
.
SCOPE_PERSISTENT
&
&
scope
!
=
this
.
SCOPE_POLICY
)
{
return
gStringBundle
.
GetStringFromName
(
"
state
.
current
.
allowedTemporarily
"
)
;
}
return
gStringBundle
.
GetStringFromName
(
"
state
.
current
.
allowed
"
)
;
case
this
.
ALLOW_COOKIES_FOR_SESSION
:
return
gStringBundle
.
GetStringFromName
(
"
state
.
current
.
allowedForSession
"
)
;
case
this
.
BLOCK
:
if
(
scope
&
&
scope
!
=
this
.
SCOPE_PERSISTENT
&
&
scope
!
=
this
.
SCOPE_POLICY
&
&
scope
!
=
this
.
SCOPE_GLOBAL
)
{
return
gStringBundle
.
GetStringFromName
(
"
state
.
current
.
blockedTemporarily
"
)
;
}
return
gStringBundle
.
GetStringFromName
(
"
state
.
current
.
blocked
"
)
;
default
:
return
null
;
}
}
}
;
let
gPermissions
=
{
_getId
(
type
)
{
let
[
id
]
=
type
.
split
(
SitePermissions
.
PERM_KEY_DELIMITER
)
;
return
id
;
}
has
(
type
)
{
return
this
.
_getId
(
type
)
in
this
.
_permissions
;
}
get
(
type
)
{
let
id
=
this
.
_getId
(
type
)
;
let
perm
=
this
.
_permissions
[
id
]
;
if
(
perm
)
{
perm
.
id
=
id
;
}
return
perm
;
}
getEnabledPermissions
(
)
{
return
Object
.
keys
(
this
.
_permissions
)
.
filter
(
id
=
>
!
this
.
_permissions
[
id
]
.
disabled
)
;
}
_permissions
:
{
"
autoplay
-
media
"
:
{
exactHostMatch
:
true
getDefault
(
)
{
let
pref
=
Services
.
prefs
.
getIntPref
(
"
media
.
autoplay
.
default
"
Ci
.
nsIAutoplay
.
BLOCKED
)
;
if
(
pref
=
=
Ci
.
nsIAutoplay
.
ALLOWED
)
{
return
SitePermissions
.
ALLOW
;
}
if
(
pref
=
=
Ci
.
nsIAutoplay
.
BLOCKED_ALL
)
{
return
SitePermissions
.
AUTOPLAY_BLOCKED_ALL
;
}
return
SitePermissions
.
BLOCK
;
}
setDefault
(
value
)
{
let
prefValue
=
Ci
.
nsIAutoplay
.
BLOCKED
;
if
(
value
=
=
SitePermissions
.
ALLOW
)
{
prefValue
=
Ci
.
nsIAutoplay
.
ALLOWED
;
}
else
if
(
value
=
=
SitePermissions
.
AUTOPLAY_BLOCKED_ALL
)
{
prefValue
=
Ci
.
nsIAutoplay
.
BLOCKED_ALL
;
}
Services
.
prefs
.
setIntPref
(
"
media
.
autoplay
.
default
"
prefValue
)
;
}
labelID
:
"
autoplay
"
states
:
[
SitePermissions
.
ALLOW
SitePermissions
.
BLOCK
SitePermissions
.
AUTOPLAY_BLOCKED_ALL
]
getMultichoiceStateLabel
(
state
)
{
switch
(
state
)
{
case
SitePermissions
.
AUTOPLAY_BLOCKED_ALL
:
return
gStringBundle
.
GetStringFromName
(
"
state
.
multichoice
.
autoplayblockall
"
)
;
case
SitePermissions
.
BLOCK
:
return
gStringBundle
.
GetStringFromName
(
"
state
.
multichoice
.
autoplayblock
"
)
;
case
SitePermissions
.
ALLOW
:
return
gStringBundle
.
GetStringFromName
(
"
state
.
multichoice
.
autoplayallow
"
)
;
}
throw
new
Error
(
Unknown
state
:
{
state
}
)
;
}
}
cookie
:
{
states
:
[
SitePermissions
.
ALLOW
SitePermissions
.
ALLOW_COOKIES_FOR_SESSION
SitePermissions
.
BLOCK
]
getDefault
(
)
{
if
(
Services
.
cookies
.
getCookieBehavior
(
false
)
=
=
Ci
.
nsICookieService
.
BEHAVIOR_REJECT
)
{
return
SitePermissions
.
BLOCK
;
}
return
SitePermissions
.
ALLOW
;
}
}
"
desktop
-
notification
"
:
{
exactHostMatch
:
true
labelID
:
"
desktop
-
notification3
"
}
camera
:
{
exactHostMatch
:
true
}
microphone
:
{
exactHostMatch
:
true
}
screen
:
{
exactHostMatch
:
true
states
:
[
SitePermissions
.
UNKNOWN
SitePermissions
.
BLOCK
]
}
popup
:
{
getDefault
(
)
{
return
Services
.
prefs
.
getBoolPref
(
"
dom
.
disable_open_during_load
"
)
?
SitePermissions
.
BLOCK
:
SitePermissions
.
ALLOW
;
}
states
:
[
SitePermissions
.
ALLOW
SitePermissions
.
BLOCK
]
}
install
:
{
getDefault
(
)
{
return
Services
.
prefs
.
getBoolPref
(
"
xpinstall
.
whitelist
.
required
"
)
?
SitePermissions
.
UNKNOWN
:
SitePermissions
.
ALLOW
;
}
}
geo
:
{
exactHostMatch
:
true
}
"
open
-
protocol
-
handler
"
:
{
labelID
:
"
open
-
protocol
-
handler
"
exactHostMatch
:
true
states
:
[
SitePermissions
.
UNKNOWN
SitePermissions
.
ALLOW
]
get
disabled
(
)
{
return
!
SitePermissions
.
openProtoPermissionEnabled
;
}
}
xr
:
{
exactHostMatch
:
true
}
"
focus
-
tab
-
by
-
prompt
"
:
{
exactHostMatch
:
true
states
:
[
SitePermissions
.
UNKNOWN
SitePermissions
.
ALLOW
]
}
"
persistent
-
storage
"
:
{
exactHostMatch
:
true
}
shortcuts
:
{
states
:
[
SitePermissions
.
ALLOW
SitePermissions
.
BLOCK
]
}
canvas
:
{
get
disabled
(
)
{
return
!
SitePermissions
.
resistFingerprinting
;
}
}
midi
:
{
exactHostMatch
:
true
get
disabled
(
)
{
return
!
SitePermissions
.
midiPermissionEnabled
;
}
}
"
midi
-
sysex
"
:
{
exactHostMatch
:
true
get
disabled
(
)
{
return
!
SitePermissions
.
midiPermissionEnabled
;
}
}
"
storage
-
access
"
:
{
labelID
:
null
getDefault
(
)
{
return
SitePermissions
.
UNKNOWN
;
}
}
"
3rdPartyStorage
"
:
{
}
}
}
;
SitePermissions
.
midiPermissionEnabled
=
Services
.
prefs
.
getBoolPref
(
"
dom
.
webmidi
.
enabled
"
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
SitePermissions
"
temporaryPermissionExpireTime
"
"
privacy
.
temporary_permission_expire_time_ms
"
3600
*
1000
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
SitePermissions
"
resistFingerprinting
"
"
privacy
.
resistFingerprinting
"
false
SitePermissions
.
invalidatePermissionList
.
bind
(
SitePermissions
)
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
SitePermissions
"
openProtoPermissionEnabled
"
"
security
.
external_protocol_requires_permission
"
true
SitePermissions
.
invalidatePermissionList
.
bind
(
SitePermissions
)
)
;
