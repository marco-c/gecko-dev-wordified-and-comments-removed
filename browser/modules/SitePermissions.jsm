var
EXPORTED_SYMBOLS
=
[
"
SitePermissions
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
var
gStringBundle
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
browser
/
locale
/
sitePermissions
.
properties
"
)
;
const
TemporaryPermissions
=
{
_stateByBrowser
:
new
WeakMap
(
)
_get
(
entry
prePath
id
permission
)
{
if
(
permission
=
=
null
|
|
permission
.
timeStamp
=
=
null
)
{
delete
entry
[
prePath
]
[
id
]
;
return
null
;
}
if
(
permission
.
timeStamp
+
SitePermissions
.
temporaryPermissionExpireTime
<
Date
.
now
(
)
)
{
delete
entry
[
prePath
]
[
id
]
;
return
null
;
}
return
{
id
state
:
permission
.
state
scope
:
SitePermissions
.
SCOPE_TEMPORARY
}
;
}
set
(
browser
id
state
)
{
if
(
!
browser
)
{
return
;
}
if
(
!
this
.
_stateByBrowser
.
has
(
browser
)
)
{
this
.
_stateByBrowser
.
set
(
browser
{
}
)
;
}
let
entry
=
this
.
_stateByBrowser
.
get
(
browser
)
;
let
prePath
=
browser
.
currentURI
.
prePath
;
if
(
!
entry
[
prePath
]
)
{
entry
[
prePath
]
=
{
}
;
}
entry
[
prePath
]
[
id
]
=
{
timeStamp
:
Date
.
now
(
)
state
}
;
}
remove
(
browser
id
)
{
if
(
!
browser
)
{
return
;
}
let
entry
=
this
.
_stateByBrowser
.
get
(
browser
)
;
let
prePath
=
browser
.
currentURI
.
prePath
;
if
(
entry
&
&
entry
[
prePath
]
)
{
delete
entry
[
prePath
]
[
id
]
;
}
}
get
(
browser
id
)
{
if
(
!
browser
|
|
!
browser
.
currentURI
)
{
return
null
;
}
let
entry
=
this
.
_stateByBrowser
.
get
(
browser
)
;
let
prePath
=
browser
.
currentURI
.
prePath
;
if
(
entry
&
&
entry
[
prePath
]
)
{
let
permission
=
entry
[
prePath
]
[
id
]
;
return
this
.
_get
(
entry
prePath
id
permission
)
;
}
return
null
;
}
getAll
(
browser
)
{
let
permissions
=
[
]
;
let
entry
=
this
.
_stateByBrowser
.
get
(
browser
)
;
let
prePath
=
browser
.
currentURI
.
prePath
;
if
(
entry
&
&
entry
[
prePath
]
)
{
let
timeStamps
=
entry
[
prePath
]
;
for
(
let
id
of
Object
.
keys
(
timeStamps
)
)
{
let
permission
=
this
.
_get
(
entry
prePath
id
timeStamps
[
id
]
)
;
if
(
permission
)
{
permissions
.
push
(
permission
)
;
}
}
}
return
permissions
;
}
clear
(
browser
)
{
this
.
_stateByBrowser
.
delete
(
browser
)
;
}
copy
(
browser
newBrowser
)
{
let
entry
=
this
.
_stateByBrowser
.
get
(
browser
)
;
if
(
entry
)
{
this
.
_stateByBrowser
.
set
(
newBrowser
entry
)
;
}
}
}
;
const
GloballyBlockedPermissions
=
{
_stateByBrowser
:
new
WeakMap
(
)
set
(
browser
id
)
{
if
(
!
this
.
_stateByBrowser
.
has
(
browser
)
)
{
this
.
_stateByBrowser
.
set
(
browser
{
}
)
;
}
let
entry
=
this
.
_stateByBrowser
.
get
(
browser
)
;
let
prePath
=
browser
.
currentURI
.
prePath
;
if
(
!
entry
[
prePath
]
)
{
entry
[
prePath
]
=
{
}
;
}
entry
[
prePath
]
[
id
]
=
true
;
browser
.
addProgressListener
(
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIWebProgressListener
Ci
.
nsISupportsWeakReference
]
)
onLocationChange
(
aWebProgress
aRequest
aLocation
aFlags
)
{
if
(
aWebProgress
.
isTopLevel
)
{
GloballyBlockedPermissions
.
remove
(
browser
id
)
;
browser
.
removeProgressListener
(
this
)
;
}
}
}
)
;
}
remove
(
browser
id
)
{
let
entry
=
this
.
_stateByBrowser
.
get
(
browser
)
;
let
prePath
=
browser
.
currentURI
.
prePath
;
if
(
entry
&
&
entry
[
prePath
]
)
{
delete
entry
[
prePath
]
[
id
]
;
}
}
getAll
(
browser
)
{
let
permissions
=
[
]
;
let
entry
=
this
.
_stateByBrowser
.
get
(
browser
)
;
let
prePath
=
browser
.
currentURI
.
prePath
;
if
(
entry
&
&
entry
[
prePath
]
)
{
let
timeStamps
=
entry
[
prePath
]
;
for
(
let
id
of
Object
.
keys
(
timeStamps
)
)
{
permissions
.
push
(
{
id
state
:
SitePermissions
.
BLOCK
scope
:
SitePermissions
.
SCOPE_GLOBAL
}
)
;
}
}
return
permissions
;
}
}
;
var
SitePermissions
=
{
UNKNOWN
:
Services
.
perms
.
UNKNOWN_ACTION
ALLOW
:
Services
.
perms
.
ALLOW_ACTION
BLOCK
:
Services
.
perms
.
DENY_ACTION
PROMPT
:
Services
.
perms
.
PROMPT_ACTION
ALLOW_COOKIES_FOR_SESSION
:
Ci
.
nsICookiePermission
.
ACCESS_SESSION
PROMPT_HIDE
:
Ci
.
nsIObjectLoadingContent
.
PLUGIN_PERMISSION_PROMPT_ACTION_QUIET
SCOPE_REQUEST
:
"
{
SitePermissions
.
SCOPE_REQUEST
}
"
SCOPE_TEMPORARY
:
"
{
SitePermissions
.
SCOPE_TEMPORARY
}
"
SCOPE_SESSION
:
"
{
SitePermissions
.
SCOPE_SESSION
}
"
SCOPE_PERSISTENT
:
"
{
SitePermissions
.
SCOPE_PERSISTENT
}
"
SCOPE_POLICY
:
"
{
SitePermissions
.
SCOPE_POLICY
}
"
SCOPE_GLOBAL
:
"
{
SitePermissions
.
SCOPE_GLOBAL
}
"
_permissionsArray
:
null
_defaultPrefBranch
:
Services
.
prefs
.
getBranch
(
"
permissions
.
default
.
"
)
getAllByURI
(
uri
)
{
let
result
=
[
]
;
if
(
!
this
.
isSupportedURI
(
uri
)
)
{
return
result
;
}
let
permissions
=
Services
.
perms
.
getAllForURI
(
uri
)
;
while
(
permissions
.
hasMoreElements
(
)
)
{
let
permission
=
permissions
.
getNext
(
)
;
if
(
gPermissionObject
[
permission
.
type
]
)
{
if
(
permission
.
type
=
=
"
install
"
)
{
continue
;
}
if
(
(
permission
.
type
=
=
"
canvas
"
)
&
&
!
this
.
resistFingerprinting
)
{
continue
;
}
let
scope
=
this
.
SCOPE_PERSISTENT
;
if
(
permission
.
expireType
=
=
Services
.
perms
.
EXPIRE_SESSION
)
{
scope
=
this
.
SCOPE_SESSION
;
}
else
if
(
permission
.
expireType
=
=
Services
.
perms
.
EXPIRE_POLICY
)
{
scope
=
this
.
SCOPE_POLICY
;
}
result
.
push
(
{
id
:
permission
.
type
scope
state
:
permission
.
capability
}
)
;
}
}
return
result
;
}
getAllForBrowser
(
browser
)
{
let
permissions
=
{
}
;
for
(
let
permission
of
TemporaryPermissions
.
getAll
(
browser
)
)
{
permission
.
scope
=
this
.
SCOPE_TEMPORARY
;
permissions
[
permission
.
id
]
=
permission
;
}
for
(
let
permission
of
GloballyBlockedPermissions
.
getAll
(
browser
)
)
{
permissions
[
permission
.
id
]
=
permission
;
}
for
(
let
permission
of
this
.
getAllByURI
(
browser
.
currentURI
)
)
{
permissions
[
permission
.
id
]
=
permission
;
}
return
Object
.
values
(
permissions
)
;
}
getAllPermissionDetailsForBrowser
(
browser
)
{
return
this
.
getAllForBrowser
(
browser
)
.
map
(
(
{
id
scope
state
}
)
=
>
(
{
id
scope
state
label
:
this
.
getPermissionLabel
(
id
)
}
)
)
;
}
isSupportedURI
(
uri
)
{
return
uri
&
&
[
"
http
"
"
https
"
"
moz
-
extension
"
]
.
includes
(
uri
.
scheme
)
;
}
listPermissions
(
)
{
if
(
this
.
_permissionsArray
=
=
=
null
)
{
let
permissions
=
Object
.
keys
(
gPermissionObject
)
;
if
(
!
this
.
resistFingerprinting
)
{
permissions
=
permissions
.
filter
(
permission
=
>
permission
!
=
=
"
canvas
"
)
;
}
this
.
_permissionsArray
=
permissions
;
}
return
this
.
_permissionsArray
;
}
onResistFingerprintingChanged
(
data
previous
latest
)
{
this
.
_permissionsArray
=
null
;
}
getAvailableStates
(
permissionID
)
{
if
(
permissionID
in
gPermissionObject
&
&
gPermissionObject
[
permissionID
]
.
states
)
return
gPermissionObject
[
permissionID
]
.
states
;
if
(
this
.
getDefault
(
permissionID
)
=
=
this
.
UNKNOWN
)
return
[
SitePermissions
.
UNKNOWN
SitePermissions
.
ALLOW
SitePermissions
.
BLOCK
]
;
return
[
SitePermissions
.
PROMPT
SitePermissions
.
ALLOW
SitePermissions
.
BLOCK
]
;
}
getDefault
(
permissionID
)
{
if
(
permissionID
in
gPermissionObject
&
&
gPermissionObject
[
permissionID
]
.
getDefault
)
return
gPermissionObject
[
permissionID
]
.
getDefault
(
)
;
return
this
.
_defaultPrefBranch
.
getIntPref
(
permissionID
this
.
UNKNOWN
)
;
}
get
(
uri
permissionID
browser
)
{
let
defaultState
=
this
.
getDefault
(
permissionID
)
;
let
result
=
{
state
:
defaultState
scope
:
this
.
SCOPE_PERSISTENT
}
;
if
(
this
.
isSupportedURI
(
uri
)
)
{
let
permission
=
null
;
if
(
permissionID
in
gPermissionObject
&
&
gPermissionObject
[
permissionID
]
.
exactHostMatch
)
{
permission
=
Services
.
perms
.
getPermissionObjectForURI
(
uri
permissionID
true
)
;
}
else
{
permission
=
Services
.
perms
.
getPermissionObjectForURI
(
uri
permissionID
false
)
;
}
if
(
permission
)
{
result
.
state
=
permission
.
capability
;
if
(
permission
.
expireType
=
=
Services
.
perms
.
EXPIRE_SESSION
)
{
result
.
scope
=
this
.
SCOPE_SESSION
;
}
else
if
(
permission
.
expireType
=
=
Services
.
perms
.
EXPIRE_POLICY
)
{
result
.
scope
=
this
.
SCOPE_POLICY
;
}
}
}
if
(
result
.
state
=
=
defaultState
)
{
let
value
=
TemporaryPermissions
.
get
(
browser
permissionID
)
;
if
(
value
)
{
result
.
state
=
value
.
state
;
result
.
scope
=
this
.
SCOPE_TEMPORARY
;
}
}
return
result
;
}
set
(
uri
permissionID
state
scope
=
this
.
SCOPE_PERSISTENT
browser
=
null
)
{
if
(
scope
=
=
this
.
SCOPE_GLOBAL
&
&
state
=
=
this
.
BLOCK
)
{
GloballyBlockedPermissions
.
set
(
browser
permissionID
)
;
browser
.
dispatchEvent
(
new
browser
.
ownerGlobal
.
CustomEvent
(
"
PermissionStateChange
"
)
)
;
return
;
}
if
(
state
=
=
this
.
UNKNOWN
|
|
state
=
=
this
.
getDefault
(
permissionID
)
)
{
if
(
permissionID
!
=
"
cookie
"
)
{
this
.
remove
(
uri
permissionID
browser
)
;
return
;
}
}
if
(
state
=
=
this
.
ALLOW_COOKIES_FOR_SESSION
&
&
permissionID
!
=
"
cookie
"
)
{
throw
"
ALLOW_COOKIES_FOR_SESSION
can
only
be
set
on
the
cookie
permission
"
;
}
if
(
scope
=
=
this
.
SCOPE_TEMPORARY
)
{
if
(
state
!
=
this
.
BLOCK
)
{
throw
"
'
Block
'
is
the
only
permission
we
can
save
temporarily
on
a
browser
"
;
}
if
(
!
browser
)
{
throw
"
TEMPORARY
scoped
permissions
require
a
browser
object
"
;
}
TemporaryPermissions
.
set
(
browser
permissionID
state
)
;
browser
.
dispatchEvent
(
new
browser
.
ownerGlobal
.
CustomEvent
(
"
PermissionStateChange
"
)
)
;
}
else
if
(
this
.
isSupportedURI
(
uri
)
)
{
let
perms_scope
=
Services
.
perms
.
EXPIRE_NEVER
;
if
(
scope
=
=
this
.
SCOPE_SESSION
)
{
perms_scope
=
Services
.
perms
.
EXPIRE_SESSION
;
}
else
if
(
scope
=
=
this
.
SCOPE_POLICY
)
{
perms_scope
=
Services
.
perms
.
EXPIRE_POLICY
;
}
Services
.
perms
.
add
(
uri
permissionID
state
perms_scope
)
;
}
}
remove
(
uri
permissionID
browser
)
{
if
(
this
.
isSupportedURI
(
uri
)
)
Services
.
perms
.
remove
(
uri
permissionID
)
;
if
(
TemporaryPermissions
.
get
(
browser
permissionID
)
)
{
TemporaryPermissions
.
remove
(
browser
permissionID
)
;
browser
.
dispatchEvent
(
new
browser
.
ownerGlobal
.
CustomEvent
(
"
PermissionStateChange
"
)
)
;
}
}
clearTemporaryPermissions
(
browser
)
{
TemporaryPermissions
.
clear
(
browser
)
;
}
copyTemporaryPermissions
(
browser
newBrowser
)
{
TemporaryPermissions
.
copy
(
browser
newBrowser
)
;
}
getPermissionLabel
(
permissionID
)
{
if
(
!
(
permissionID
in
gPermissionObject
)
)
{
return
null
;
}
if
(
"
labelID
"
in
gPermissionObject
[
permissionID
]
&
&
gPermissionObject
[
permissionID
]
.
labelID
=
=
=
null
)
{
return
null
;
}
let
labelID
=
gPermissionObject
[
permissionID
]
.
labelID
|
|
permissionID
;
return
gStringBundle
.
GetStringFromName
(
"
permission
.
"
+
labelID
+
"
.
label
"
)
;
}
getMultichoiceStateLabel
(
state
)
{
switch
(
state
)
{
case
this
.
UNKNOWN
:
case
this
.
PROMPT
:
return
gStringBundle
.
GetStringFromName
(
"
state
.
multichoice
.
alwaysAsk
"
)
;
case
this
.
ALLOW
:
return
gStringBundle
.
GetStringFromName
(
"
state
.
multichoice
.
allow
"
)
;
case
this
.
ALLOW_COOKIES_FOR_SESSION
:
return
gStringBundle
.
GetStringFromName
(
"
state
.
multichoice
.
allowForSession
"
)
;
case
this
.
BLOCK
:
return
gStringBundle
.
GetStringFromName
(
"
state
.
multichoice
.
block
"
)
;
default
:
return
null
;
}
}
getCurrentStateLabel
(
state
id
scope
=
null
)
{
if
(
id
.
startsWith
(
"
plugin
"
)
&
&
state
=
=
SitePermissions
.
PROMPT_HIDE
)
{
return
gStringBundle
.
GetStringFromName
(
"
state
.
current
.
hide
"
)
;
}
switch
(
state
)
{
case
this
.
PROMPT
:
return
gStringBundle
.
GetStringFromName
(
"
state
.
current
.
prompt
"
)
;
case
this
.
ALLOW
:
if
(
scope
&
&
scope
!
=
this
.
SCOPE_PERSISTENT
&
&
scope
!
=
this
.
SCOPE_POLICY
)
return
gStringBundle
.
GetStringFromName
(
"
state
.
current
.
allowedTemporarily
"
)
;
return
gStringBundle
.
GetStringFromName
(
"
state
.
current
.
allowed
"
)
;
case
this
.
ALLOW_COOKIES_FOR_SESSION
:
return
gStringBundle
.
GetStringFromName
(
"
state
.
current
.
allowedForSession
"
)
;
case
this
.
BLOCK
:
if
(
scope
&
&
scope
!
=
this
.
SCOPE_PERSISTENT
&
&
scope
!
=
this
.
SCOPE_POLICY
&
&
scope
!
=
this
.
SCOPE_GLOBAL
)
{
return
gStringBundle
.
GetStringFromName
(
"
state
.
current
.
blockedTemporarily
"
)
;
}
return
gStringBundle
.
GetStringFromName
(
"
state
.
current
.
blocked
"
)
;
default
:
return
null
;
}
}
}
;
var
gPermissionObject
=
{
"
autoplay
-
media
"
:
{
exactHostMatch
:
true
getDefault
(
)
{
let
state
=
Services
.
prefs
.
getIntPref
(
"
media
.
autoplay
.
default
"
Ci
.
nsIAutoplay
.
BLOCKED
)
;
if
(
state
=
=
Ci
.
nsIAutoplay
.
ALLOWED
)
{
return
SitePermissions
.
ALLOW
;
}
else
if
(
state
=
=
Ci
.
nsIAutoplay
.
BLOCKED
)
{
return
SitePermissions
.
BLOCK
;
}
return
SitePermissions
.
UNKNOWN
;
}
labelID
:
"
autoplay
-
media
"
states
:
[
SitePermissions
.
ALLOW
SitePermissions
.
BLOCK
]
}
"
image
"
:
{
states
:
[
SitePermissions
.
ALLOW
SitePermissions
.
BLOCK
]
}
"
cookie
"
:
{
states
:
[
SitePermissions
.
ALLOW
SitePermissions
.
ALLOW_COOKIES_FOR_SESSION
SitePermissions
.
BLOCK
]
getDefault
(
)
{
if
(
Services
.
prefs
.
getIntPref
(
"
network
.
cookie
.
cookieBehavior
"
)
=
=
Ci
.
nsICookieService
.
BEHAVIOR_REJECT
)
return
SitePermissions
.
BLOCK
;
if
(
Services
.
prefs
.
getIntPref
(
"
network
.
cookie
.
lifetimePolicy
"
)
=
=
Ci
.
nsICookieService
.
ACCEPT_SESSION
)
return
SitePermissions
.
ALLOW_COOKIES_FOR_SESSION
;
return
SitePermissions
.
ALLOW
;
}
}
"
desktop
-
notification
"
:
{
exactHostMatch
:
true
labelID
:
"
desktop
-
notification3
"
}
"
camera
"
:
{
exactHostMatch
:
true
}
"
microphone
"
:
{
exactHostMatch
:
true
}
"
screen
"
:
{
exactHostMatch
:
true
states
:
[
SitePermissions
.
UNKNOWN
SitePermissions
.
BLOCK
]
}
"
popup
"
:
{
getDefault
(
)
{
return
Services
.
prefs
.
getBoolPref
(
"
dom
.
disable_open_during_load
"
)
?
SitePermissions
.
BLOCK
:
SitePermissions
.
ALLOW
;
}
states
:
[
SitePermissions
.
ALLOW
SitePermissions
.
BLOCK
]
}
"
install
"
:
{
getDefault
(
)
{
return
Services
.
prefs
.
getBoolPref
(
"
xpinstall
.
whitelist
.
required
"
)
?
SitePermissions
.
BLOCK
:
SitePermissions
.
ALLOW
;
}
states
:
[
SitePermissions
.
ALLOW
SitePermissions
.
BLOCK
]
}
"
geo
"
:
{
exactHostMatch
:
true
}
"
focus
-
tab
-
by
-
prompt
"
:
{
exactHostMatch
:
true
states
:
[
SitePermissions
.
UNKNOWN
SitePermissions
.
ALLOW
]
}
"
persistent
-
storage
"
:
{
exactHostMatch
:
true
}
"
shortcuts
"
:
{
states
:
[
SitePermissions
.
ALLOW
SitePermissions
.
BLOCK
]
}
"
canvas
"
:
{
}
"
plugin
:
flash
"
:
{
labelID
:
"
flash
-
plugin
"
states
:
[
SitePermissions
.
UNKNOWN
SitePermissions
.
ALLOW
SitePermissions
.
BLOCK
]
}
"
midi
"
:
{
exactHostMatch
:
true
}
"
midi
-
sysex
"
:
{
exactHostMatch
:
true
}
"
storage
-
access
"
:
{
labelID
:
null
getDefault
(
)
{
return
SitePermissions
.
UNKNOWN
;
}
}
}
;
if
(
!
Services
.
prefs
.
getBoolPref
(
"
dom
.
webmidi
.
enabled
"
)
)
{
delete
gPermissionObject
[
"
midi
"
]
;
delete
gPermissionObject
[
"
midi
-
sysex
"
]
;
}
XPCOMUtils
.
defineLazyPreferenceGetter
(
SitePermissions
"
temporaryPermissionExpireTime
"
"
privacy
.
temporary_permission_expire_time_ms
"
3600
*
1000
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
SitePermissions
"
resistFingerprinting
"
"
privacy
.
resistFingerprinting
"
false
SitePermissions
.
onResistFingerprintingChanged
.
bind
(
SitePermissions
)
)
;
