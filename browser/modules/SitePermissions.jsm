this
.
EXPORTED_SYMBOLS
=
[
"
SitePermissions
"
]
;
Components
.
utils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
var
gStringBundle
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
browser
/
locale
/
sitePermissions
.
properties
"
)
;
this
.
SitePermissions
=
{
UNKNOWN
:
Services
.
perms
.
UNKNOWN_ACTION
ALLOW
:
Services
.
perms
.
ALLOW_ACTION
BLOCK
:
Services
.
perms
.
DENY_ACTION
SESSION
:
Components
.
interfaces
.
nsICookiePermission
.
ACCESS_SESSION
getAllByURI
(
aURI
)
{
let
result
=
[
]
;
if
(
!
this
.
isSupportedURI
(
aURI
)
)
{
return
result
;
}
let
permissions
=
Services
.
perms
.
getAllForURI
(
aURI
)
;
while
(
permissions
.
hasMoreElements
(
)
)
{
let
permission
=
permissions
.
getNext
(
)
;
if
(
gPermissionObject
[
permission
.
type
]
)
{
if
(
permission
.
type
=
=
"
install
"
)
{
continue
;
}
result
.
push
(
{
id
:
permission
.
type
state
:
permission
.
capability
}
)
;
}
}
return
result
;
}
getPermissionItem
(
aId
aState
)
{
let
availableStates
=
this
.
getAvailableStates
(
aId
)
.
map
(
state
=
>
{
return
{
id
:
state
label
:
this
.
getStateLabel
(
aId
state
)
}
;
}
)
;
if
(
aState
=
=
undefined
)
aState
=
this
.
getDefault
(
aId
)
;
return
{
id
:
aId
label
:
this
.
getPermissionLabel
(
aId
)
state
:
aState
availableStates
}
;
}
getPermissionDetailsByURI
(
aURI
)
{
let
permissions
=
[
]
;
for
(
let
{
state
id
}
of
this
.
getAllByURI
(
aURI
)
)
{
permissions
.
push
(
this
.
getPermissionItem
(
id
state
)
)
;
}
return
permissions
;
}
isSupportedURI
(
aURI
)
{
return
aURI
.
schemeIs
(
"
http
"
)
|
|
aURI
.
schemeIs
(
"
https
"
)
;
}
listPermissions
(
)
{
return
Object
.
keys
(
gPermissionObject
)
;
}
getAvailableStates
(
aPermissionID
)
{
if
(
aPermissionID
in
gPermissionObject
&
&
gPermissionObject
[
aPermissionID
]
.
states
)
return
gPermissionObject
[
aPermissionID
]
.
states
;
if
(
this
.
getDefault
(
aPermissionID
)
=
=
this
.
UNKNOWN
)
return
[
SitePermissions
.
UNKNOWN
SitePermissions
.
ALLOW
SitePermissions
.
BLOCK
]
;
return
[
SitePermissions
.
ALLOW
SitePermissions
.
BLOCK
]
;
}
getDefault
(
aPermissionID
)
{
if
(
aPermissionID
in
gPermissionObject
&
&
gPermissionObject
[
aPermissionID
]
.
getDefault
)
return
gPermissionObject
[
aPermissionID
]
.
getDefault
(
)
;
return
this
.
UNKNOWN
;
}
get
(
aURI
aPermissionID
)
{
if
(
!
this
.
isSupportedURI
(
aURI
)
)
return
this
.
UNKNOWN
;
let
state
;
if
(
aPermissionID
in
gPermissionObject
&
&
gPermissionObject
[
aPermissionID
]
.
exactHostMatch
)
state
=
Services
.
perms
.
testExactPermission
(
aURI
aPermissionID
)
;
else
state
=
Services
.
perms
.
testPermission
(
aURI
aPermissionID
)
;
return
state
;
}
set
(
aURI
aPermissionID
aState
)
{
if
(
!
this
.
isSupportedURI
(
aURI
)
)
return
;
if
(
aState
=
=
this
.
UNKNOWN
)
{
this
.
remove
(
aURI
aPermissionID
)
;
return
;
}
Services
.
perms
.
add
(
aURI
aPermissionID
aState
)
;
}
remove
(
aURI
aPermissionID
)
{
if
(
!
this
.
isSupportedURI
(
aURI
)
)
return
;
Services
.
perms
.
remove
(
aURI
aPermissionID
)
;
}
getPermissionLabel
(
aPermissionID
)
{
let
labelID
=
gPermissionObject
[
aPermissionID
]
.
labelID
|
|
aPermissionID
;
return
gStringBundle
.
GetStringFromName
(
"
permission
.
"
+
labelID
+
"
.
label
"
)
;
}
getStateLabel
(
aPermissionID
aState
aInUse
=
false
)
{
switch
(
aState
)
{
case
this
.
UNKNOWN
:
if
(
aInUse
)
return
gStringBundle
.
GetStringFromName
(
"
allowTemporarily
"
)
;
return
gStringBundle
.
GetStringFromName
(
"
alwaysAsk
"
)
;
case
this
.
ALLOW
:
return
gStringBundle
.
GetStringFromName
(
"
allow
"
)
;
case
this
.
SESSION
:
return
gStringBundle
.
GetStringFromName
(
"
allowForSession
"
)
;
case
this
.
BLOCK
:
return
gStringBundle
.
GetStringFromName
(
"
block
"
)
;
default
:
throw
new
Error
(
"
unknown
permission
state
"
)
;
}
}
}
;
var
gPermissionObject
=
{
"
image
"
:
{
getDefault
(
)
{
return
Services
.
prefs
.
getIntPref
(
"
permissions
.
default
.
image
"
)
=
=
2
?
SitePermissions
.
BLOCK
:
SitePermissions
.
ALLOW
;
}
}
"
cookie
"
:
{
states
:
[
SitePermissions
.
ALLOW
SitePermissions
.
SESSION
SitePermissions
.
BLOCK
]
getDefault
(
)
{
if
(
Services
.
prefs
.
getIntPref
(
"
network
.
cookie
.
cookieBehavior
"
)
=
=
2
)
return
SitePermissions
.
BLOCK
;
if
(
Services
.
prefs
.
getIntPref
(
"
network
.
cookie
.
lifetimePolicy
"
)
=
=
2
)
return
SitePermissions
.
SESSION
;
return
SitePermissions
.
ALLOW
;
}
}
"
desktop
-
notification
"
:
{
exactHostMatch
:
true
labelID
:
"
desktop
-
notification2
"
}
"
camera
"
:
{
}
"
microphone
"
:
{
}
"
screen
"
:
{
states
:
[
SitePermissions
.
UNKNOWN
SitePermissions
.
BLOCK
]
}
"
popup
"
:
{
getDefault
(
)
{
return
Services
.
prefs
.
getBoolPref
(
"
dom
.
disable_open_during_load
"
)
?
SitePermissions
.
BLOCK
:
SitePermissions
.
ALLOW
;
}
}
"
install
"
:
{
getDefault
(
)
{
return
Services
.
prefs
.
getBoolPref
(
"
xpinstall
.
whitelist
.
required
"
)
?
SitePermissions
.
BLOCK
:
SitePermissions
.
ALLOW
;
}
}
"
geo
"
:
{
exactHostMatch
:
true
}
"
indexedDB
"
:
{
}
}
;
const
kPermissionIDs
=
Object
.
keys
(
gPermissionObject
)
;
