var
EXPORTED_SYMBOLS
=
[
"
BrowserWindowTracker
"
]
;
const
{
AppConstants
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
sys
.
mjs
"
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineESModuleGetters
(
lazy
{
PrivateBrowsingUtils
:
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
sys
.
mjs
"
PromiseUtils
:
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
sys
.
mjs
"
}
)
;
const
TAB_EVENTS
=
[
"
TabBrowserInserted
"
"
TabSelect
"
]
;
const
WINDOW_EVENTS
=
[
"
activate
"
"
unload
"
]
;
const
DEBUG
=
false
;
let
_lastCurrentBrowserId
=
0
;
let
_trackedWindows
=
[
]
;
function
debug
(
s
)
{
if
(
DEBUG
)
{
dump
(
"
-
*
-
UpdateBrowserIDHelper
:
"
+
s
+
"
\
n
"
)
;
}
}
function
_updateCurrentBrowserId
(
browser
)
{
if
(
!
browser
.
browserId
|
|
browser
.
browserId
=
=
=
_lastCurrentBrowserId
|
|
browser
.
ownerGlobal
!
=
_trackedWindows
[
0
]
)
{
return
;
}
if
(
DEBUG
)
{
debug
(
Current
window
uri
=
{
browser
.
currentURI
?
.
spec
}
browser
id
=
{
browser
.
browserId
}
)
;
}
_lastCurrentBrowserId
=
browser
.
browserId
;
let
idWrapper
=
Cc
[
"
mozilla
.
org
/
supports
-
PRUint64
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsPRUint64
)
;
idWrapper
.
data
=
_lastCurrentBrowserId
;
Services
.
obs
.
notifyObservers
(
idWrapper
"
net
:
current
-
browser
-
id
"
)
;
}
function
_handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
TabBrowserInserted
"
:
if
(
event
.
target
.
ownerGlobal
.
gBrowser
.
selectedBrowser
=
=
=
event
.
target
.
linkedBrowser
)
{
_updateCurrentBrowserId
(
event
.
target
.
linkedBrowser
)
;
}
break
;
case
"
TabSelect
"
:
_updateCurrentBrowserId
(
event
.
target
.
linkedBrowser
)
;
break
;
case
"
activate
"
:
WindowHelper
.
onActivate
(
event
.
target
)
;
break
;
case
"
unload
"
:
WindowHelper
.
removeWindow
(
event
.
currentTarget
)
;
break
;
}
}
function
_trackWindowOrder
(
window
)
{
if
(
window
.
windowState
=
=
window
.
STATE_MINIMIZED
)
{
let
firstMinimizedWindow
=
_trackedWindows
.
findIndex
(
w
=
>
w
.
windowState
=
=
w
.
STATE_MINIMIZED
)
;
if
(
firstMinimizedWindow
=
=
-
1
)
{
firstMinimizedWindow
=
_trackedWindows
.
length
;
}
_trackedWindows
.
splice
(
firstMinimizedWindow
0
window
)
;
}
else
{
_trackedWindows
.
unshift
(
window
)
;
}
}
function
_untrackWindowOrder
(
window
)
{
let
idx
=
_trackedWindows
.
indexOf
(
window
)
;
if
(
idx
>
=
0
)
{
_trackedWindows
.
splice
(
idx
1
)
;
}
}
var
WindowHelper
=
{
addWindow
(
window
)
{
TAB_EVENTS
.
forEach
(
function
(
event
)
{
window
.
gBrowser
.
tabContainer
.
addEventListener
(
event
_handleEvent
)
;
}
)
;
WINDOW_EVENTS
.
forEach
(
function
(
event
)
{
window
.
addEventListener
(
event
_handleEvent
)
;
}
)
;
_trackWindowOrder
(
window
)
;
_updateCurrentBrowserId
(
window
.
gBrowser
.
selectedBrowser
)
;
}
removeWindow
(
window
)
{
_untrackWindowOrder
(
window
)
;
TAB_EVENTS
.
forEach
(
function
(
event
)
{
window
.
gBrowser
.
tabContainer
.
removeEventListener
(
event
_handleEvent
)
;
}
)
;
WINDOW_EVENTS
.
forEach
(
function
(
event
)
{
window
.
removeEventListener
(
event
_handleEvent
)
;
}
)
;
}
onActivate
(
window
)
{
if
(
window
=
=
_trackedWindows
[
0
]
)
{
return
;
}
_untrackWindowOrder
(
window
)
;
_trackWindowOrder
(
window
)
;
_updateCurrentBrowserId
(
window
.
gBrowser
.
selectedBrowser
)
;
}
}
;
const
BrowserWindowTracker
=
{
pendingWindows
:
new
Map
(
)
getTopWindow
(
options
=
{
}
)
{
for
(
let
win
of
_trackedWindows
)
{
if
(
!
win
.
closed
&
&
(
options
.
allowPopups
|
|
win
.
toolbar
.
visible
)
&
&
(
!
(
"
private
"
in
options
)
|
|
lazy
.
PrivateBrowsingUtils
.
permanentPrivateBrowsing
|
|
lazy
.
PrivateBrowsingUtils
.
isWindowPrivate
(
win
)
=
=
options
.
private
)
)
{
return
win
;
}
}
return
null
;
}
getPendingWindow
(
options
=
{
}
)
{
for
(
let
pending
of
this
.
pendingWindows
.
values
(
)
)
{
if
(
!
(
"
private
"
in
options
)
|
|
lazy
.
PrivateBrowsingUtils
.
permanentPrivateBrowsing
|
|
pending
.
isPrivate
=
=
options
.
private
)
{
return
pending
.
deferred
.
promise
;
}
}
return
null
;
}
registerOpeningWindow
(
window
isPrivate
)
{
let
deferred
=
lazy
.
PromiseUtils
.
defer
(
)
;
this
.
pendingWindows
.
set
(
window
{
isPrivate
deferred
}
)
;
}
openWindow
(
{
private
:
isPrivate
=
false
features
=
undefined
args
=
null
}
=
{
}
)
{
let
windowFeatures
=
"
chrome
dialog
=
no
all
"
;
if
(
features
)
{
windowFeatures
+
=
{
features
}
;
}
if
(
isPrivate
)
{
windowFeatures
+
=
"
private
"
;
}
let
win
=
Services
.
ww
.
openWindow
(
null
AppConstants
.
BROWSER_CHROME_URL
"
_blank
"
windowFeatures
args
)
;
this
.
registerOpeningWindow
(
win
isPrivate
)
;
return
win
;
}
get
windowCount
(
)
{
return
_trackedWindows
.
length
;
}
get
orderedWindows
(
)
{
return
[
.
.
.
_trackedWindows
]
;
}
getAllVisibleTabs
(
)
{
let
tabs
=
[
]
;
for
(
let
win
of
BrowserWindowTracker
.
orderedWindows
)
{
for
(
let
tab
of
win
.
gBrowser
.
visibleTabs
)
{
if
(
tab
.
linkedPanel
)
{
let
{
contentTitle
browserId
}
=
tab
.
linkedBrowser
;
tabs
.
push
(
{
contentTitle
browserId
}
)
;
}
}
}
return
tabs
;
}
track
(
window
)
{
let
pending
=
this
.
pendingWindows
.
get
(
window
)
;
if
(
pending
)
{
this
.
pendingWindows
.
delete
(
window
)
;
window
.
delayedStartupPromise
.
then
(
(
)
=
>
pending
.
deferred
.
resolve
(
window
)
)
;
}
return
WindowHelper
.
addWindow
(
window
)
;
}
getBrowserById
(
browserId
)
{
for
(
let
win
of
BrowserWindowTracker
.
orderedWindows
)
{
for
(
let
tab
of
win
.
gBrowser
.
visibleTabs
)
{
if
(
tab
.
linkedPanel
&
&
tab
.
linkedBrowser
.
browserId
=
=
=
browserId
)
{
return
tab
.
linkedBrowser
;
}
}
}
return
null
;
}
untrackForTestsOnly
(
window
)
{
return
WindowHelper
.
removeWindow
(
window
)
;
}
}
;
