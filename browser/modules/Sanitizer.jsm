var
EXPORTED_SYMBOLS
=
[
"
Sanitizer
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AppConstants
:
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
PlacesUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
FormHistory
:
"
resource
:
/
/
gre
/
modules
/
FormHistory
.
jsm
"
ContextualIdentityService
:
"
resource
:
/
/
gre
/
modules
/
ContextualIdentityService
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
quotaManagerService
"
"
mozilla
.
org
/
dom
/
quota
-
manager
-
service
;
1
"
"
nsIQuotaManagerService
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
serviceWorkerManager
"
"
mozilla
.
org
/
serviceworkers
/
manager
;
1
"
"
nsIServiceWorkerManager
"
)
;
var
logConsole
;
function
log
(
msg
)
{
if
(
!
logConsole
)
{
logConsole
=
console
.
createInstance
(
{
prefix
:
"
*
*
Sanitizer
.
jsm
"
maxLogLevelPref
:
"
browser
.
sanitizer
.
loglevel
"
}
)
;
}
logConsole
.
log
(
msg
)
;
}
var
gPendingSanitizationSerial
=
0
;
const
PREF_COOKIE_LIFETIME
=
"
network
.
cookie
.
lifetimePolicy
"
;
var
Sanitizer
=
{
PREF_SANITIZE_ON_SHUTDOWN
:
"
privacy
.
sanitize
.
sanitizeOnShutdown
"
PREF_PENDING_SANITIZATIONS
:
"
privacy
.
sanitize
.
pending
"
PREF_CPD_BRANCH
:
"
privacy
.
cpd
.
"
PREF_SHUTDOWN_BRANCH
:
"
privacy
.
clearOnShutdown
.
"
PREF_TIMESPAN
:
"
privacy
.
sanitize
.
timeSpan
"
PREF_NEWTAB_SEGREGATION
:
"
privacy
.
usercontext
.
about_newtab_segregation
.
enabled
"
TIMESPAN_EVERYTHING
:
0
TIMESPAN_HOUR
:
1
TIMESPAN_2HOURS
:
2
TIMESPAN_4HOURS
:
3
TIMESPAN_TODAY
:
4
TIMESPAN_5MIN
:
5
TIMESPAN_24HOURS
:
6
shouldSanitizeOnShutdown
:
false
shouldSanitizeNewTabContainer
:
false
showUI
(
parentWindow
)
{
let
win
=
AppConstants
.
platform
=
=
"
macosx
"
?
null
:
parentWindow
;
Services
.
ww
.
openWindow
(
win
"
chrome
:
/
/
browser
/
content
/
sanitize
.
xul
"
"
Sanitize
"
"
chrome
titlebar
dialog
centerscreen
modal
"
null
)
;
}
async
onStartup
(
)
{
let
pendingSanitizations
=
getAndClearPendingSanitizations
(
)
;
this
.
shouldSanitizeOnShutdown
=
Services
.
prefs
.
getBoolPref
(
Sanitizer
.
PREF_SANITIZE_ON_SHUTDOWN
false
)
;
Services
.
prefs
.
addObserver
(
Sanitizer
.
PREF_SANITIZE_ON_SHUTDOWN
this
true
)
;
if
(
this
.
shouldSanitizeOnShutdown
)
{
let
itemsToClear
=
getItemsToClearFromPrefBranch
(
Sanitizer
.
PREF_SHUTDOWN_BRANCH
)
;
addPendingSanitization
(
"
shutdown
"
itemsToClear
{
}
)
;
}
Services
.
prefs
.
addObserver
(
Sanitizer
.
PREF_SHUTDOWN_BRANCH
this
true
)
;
let
shutdownClient
=
PlacesUtils
.
history
.
shutdownClient
.
jsclient
;
let
progress
=
{
isShutdown
:
true
}
;
shutdownClient
.
addBlocker
(
"
sanitize
.
js
:
Sanitize
on
shutdown
"
(
)
=
>
sanitizeOnShutdown
(
progress
)
{
fetchState
:
(
)
=
>
(
{
progress
}
)
}
)
;
this
.
shouldSanitizeNewTabContainer
=
Services
.
prefs
.
getBoolPref
(
this
.
PREF_NEWTAB_SEGREGATION
false
)
;
if
(
this
.
shouldSanitizeNewTabContainer
)
{
addPendingSanitization
(
"
newtab
-
container
"
[
]
{
}
)
;
}
let
i
=
pendingSanitizations
.
findIndex
(
s
=
>
s
.
id
=
=
"
newtab
-
container
"
)
;
if
(
i
!
=
-
1
)
{
pendingSanitizations
.
splice
(
i
1
)
;
sanitizeNewTabSegregation
(
)
;
}
for
(
let
{
itemsToClear
options
}
of
pendingSanitizations
)
{
try
{
await
this
.
sanitize
(
itemsToClear
options
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
"
A
previously
pending
sanitization
failed
:
"
+
itemsToClear
+
"
\
n
"
+
ex
)
;
}
}
}
getClearRange
(
ts
)
{
if
(
ts
=
=
=
undefined
)
ts
=
Services
.
prefs
.
getIntPref
(
Sanitizer
.
PREF_TIMESPAN
)
;
if
(
ts
=
=
=
Sanitizer
.
TIMESPAN_EVERYTHING
)
return
null
;
var
endDate
=
Date
.
now
(
)
*
1000
;
switch
(
ts
)
{
case
Sanitizer
.
TIMESPAN_5MIN
:
var
startDate
=
endDate
-
300000000
;
break
;
case
Sanitizer
.
TIMESPAN_HOUR
:
startDate
=
endDate
-
3600000000
;
break
;
case
Sanitizer
.
TIMESPAN_2HOURS
:
startDate
=
endDate
-
7200000000
;
break
;
case
Sanitizer
.
TIMESPAN_4HOURS
:
startDate
=
endDate
-
14400000000
;
break
;
case
Sanitizer
.
TIMESPAN_TODAY
:
var
d
=
new
Date
(
)
;
d
.
setHours
(
0
)
;
d
.
setMinutes
(
0
)
;
d
.
setSeconds
(
0
)
;
d
.
setMilliseconds
(
0
)
;
startDate
=
d
.
valueOf
(
)
*
1000
;
break
;
case
Sanitizer
.
TIMESPAN_24HOURS
:
startDate
=
endDate
-
86400000000
;
break
;
default
:
throw
new
Error
(
"
Invalid
time
span
for
clear
private
data
:
"
+
ts
)
;
}
return
[
startDate
endDate
]
;
}
async
sanitize
(
itemsToClear
=
null
options
=
{
}
)
{
let
progress
=
options
.
progress
|
|
{
}
;
if
(
!
itemsToClear
)
itemsToClear
=
getItemsToClearFromPrefBranch
(
this
.
PREF_CPD_BRANCH
)
;
let
promise
=
sanitizeInternal
(
this
.
items
itemsToClear
progress
options
)
;
if
(
!
progress
.
isShutdown
)
{
let
shutdownClient
=
PlacesUtils
.
history
.
shutdownClient
.
jsclient
;
shutdownClient
.
addBlocker
(
"
sanitize
.
js
:
Sanitize
"
promise
{
fetchState
:
(
)
=
>
(
{
progress
}
)
}
)
;
}
try
{
await
promise
;
}
finally
{
Services
.
obs
.
notifyObservers
(
null
"
sanitizer
-
sanitization
-
complete
"
)
;
}
}
observe
(
subject
topic
data
)
{
if
(
topic
=
=
"
nsPref
:
changed
"
)
{
if
(
data
.
startsWith
(
this
.
PREF_SHUTDOWN_BRANCH
)
&
&
this
.
shouldSanitizeOnShutdown
)
{
removePendingSanitization
(
"
shutdown
"
)
;
let
itemsToClear
=
getItemsToClearFromPrefBranch
(
Sanitizer
.
PREF_SHUTDOWN_BRANCH
)
;
addPendingSanitization
(
"
shutdown
"
itemsToClear
{
}
)
;
}
else
if
(
data
=
=
this
.
PREF_SANITIZE_ON_SHUTDOWN
)
{
this
.
shouldSanitizeOnShutdown
=
Services
.
prefs
.
getBoolPref
(
Sanitizer
.
PREF_SANITIZE_ON_SHUTDOWN
false
)
;
removePendingSanitization
(
"
shutdown
"
)
;
if
(
this
.
shouldSanitizeOnShutdown
)
{
let
itemsToClear
=
getItemsToClearFromPrefBranch
(
Sanitizer
.
PREF_SHUTDOWN_BRANCH
)
;
addPendingSanitization
(
"
shutdown
"
itemsToClear
{
}
)
;
}
}
else
if
(
data
=
=
this
.
PREF_NEWTAB_SEGREGATION
)
{
this
.
shouldSanitizeNewTabContainer
=
Services
.
prefs
.
getBoolPref
(
this
.
PREF_NEWTAB_SEGREGATION
false
)
;
removePendingSanitization
(
"
newtab
-
container
"
)
;
if
(
this
.
shouldSanitizeNewTabContainer
)
{
addPendingSanitization
(
"
newtab
-
container
"
[
]
{
}
)
;
}
}
}
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIObserver
Ci
.
nsISupportsWeakReference
]
)
async
runSanitizeOnShutdown
(
)
{
return
sanitizeOnShutdown
(
{
isShutdown
:
true
}
)
;
}
items
:
{
cache
:
{
async
clear
(
range
)
{
let
refObj
=
{
}
;
TelemetryStopwatch
.
start
(
"
FX_SANITIZE_CACHE
"
refObj
)
;
await
clearData
(
range
Ci
.
nsIClearDataService
.
CLEAR_ALL_CACHES
)
;
TelemetryStopwatch
.
finish
(
"
FX_SANITIZE_CACHE
"
refObj
)
;
}
}
cookies
:
{
async
clear
(
range
)
{
let
refObj
=
{
}
;
TelemetryStopwatch
.
start
(
"
FX_SANITIZE_COOKIES_2
"
refObj
)
;
await
clearData
(
range
Ci
.
nsIClearDataService
.
CLEAR_COOKIES
|
Ci
.
nsIClearDataService
.
CLEAR_PLUGIN_DATA
|
Ci
.
nsIClearDataService
.
CLEAR_MEDIA_DEVICES
)
;
TelemetryStopwatch
.
finish
(
"
FX_SANITIZE_COOKIES_2
"
refObj
)
;
}
}
offlineApps
:
{
async
clear
(
range
)
{
await
clearData
(
range
Ci
.
nsIClearDataService
.
CLEAR_DOM_STORAGES
)
;
}
}
history
:
{
async
clear
(
range
)
{
let
refObj
=
{
}
;
TelemetryStopwatch
.
start
(
"
FX_SANITIZE_HISTORY
"
refObj
)
;
await
clearData
(
range
Ci
.
nsIClearDataService
.
CLEAR_HISTORY
|
Ci
.
nsIClearDataService
.
CLEAR_SESSION_HISTORY
|
Ci
.
nsIClearDataService
.
CLEAR_STORAGE_ACCESS
)
;
TelemetryStopwatch
.
finish
(
"
FX_SANITIZE_HISTORY
"
refObj
)
;
}
}
formdata
:
{
async
clear
(
range
)
{
let
seenException
;
let
refObj
=
{
}
;
TelemetryStopwatch
.
start
(
"
FX_SANITIZE_FORMDATA
"
refObj
)
;
try
{
for
(
let
currentWindow
of
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
)
{
let
currentDocument
=
currentWindow
.
document
;
let
searchBar
=
currentDocument
.
getElementById
(
"
searchbar
"
)
;
if
(
searchBar
&
&
searchBar
.
textbox
)
searchBar
.
textbox
.
reset
(
)
;
let
tabBrowser
=
currentWindow
.
gBrowser
;
if
(
!
tabBrowser
)
{
continue
;
}
for
(
let
tab
of
tabBrowser
.
tabs
)
{
if
(
tabBrowser
.
isFindBarInitialized
(
tab
)
)
tabBrowser
.
getCachedFindBar
(
tab
)
.
clear
(
)
;
}
tabBrowser
.
_lastFindValue
=
"
"
;
}
}
catch
(
ex
)
{
seenException
=
ex
;
}
try
{
let
change
=
{
op
:
"
remove
"
}
;
if
(
range
)
{
[
change
.
firstUsedStart
change
.
firstUsedEnd
]
=
range
;
}
await
new
Promise
(
resolve
=
>
{
FormHistory
.
update
(
change
{
handleError
(
e
)
{
seenException
=
new
Error
(
"
Error
"
+
e
.
result
+
"
:
"
+
e
.
message
)
;
}
handleCompletion
(
)
{
resolve
(
)
;
}
}
)
;
}
)
;
}
catch
(
ex
)
{
seenException
=
ex
;
}
TelemetryStopwatch
.
finish
(
"
FX_SANITIZE_FORMDATA
"
refObj
)
;
if
(
seenException
)
{
throw
seenException
;
}
}
}
downloads
:
{
async
clear
(
range
)
{
let
refObj
=
{
}
;
TelemetryStopwatch
.
start
(
"
FX_SANITIZE_DOWNLOADS
"
refObj
)
;
await
clearData
(
range
Ci
.
nsIClearDataService
.
CLEAR_DOWNLOADS
)
;
TelemetryStopwatch
.
finish
(
"
FX_SANITIZE_DOWNLOADS
"
refObj
)
;
}
}
sessions
:
{
async
clear
(
range
)
{
let
refObj
=
{
}
;
TelemetryStopwatch
.
start
(
"
FX_SANITIZE_SESSIONS
"
refObj
)
;
await
clearData
(
range
Ci
.
nsIClearDataService
.
CLEAR_AUTH_TOKENS
|
Ci
.
nsIClearDataService
.
CLEAR_AUTH_CACHE
)
;
TelemetryStopwatch
.
finish
(
"
FX_SANITIZE_SESSIONS
"
refObj
)
;
}
}
siteSettings
:
{
async
clear
(
range
)
{
let
refObj
=
{
}
;
TelemetryStopwatch
.
start
(
"
FX_SANITIZE_SITESETTINGS
"
refObj
)
;
await
clearData
(
range
Ci
.
nsIClearDataService
.
CLEAR_PERMISSIONS
|
Ci
.
nsIClearDataService
.
CLEAR_CONTENT_PREFERENCES
|
Ci
.
nsIClearDataService
.
CLEAR_DOM_PUSH_NOTIFICATIONS
|
Ci
.
nsIClearDataService
.
CLEAR_SECURITY_SETTINGS
)
;
TelemetryStopwatch
.
finish
(
"
FX_SANITIZE_SITESETTINGS
"
refObj
)
;
}
}
openWindows
:
{
_canCloseWindow
(
win
)
{
if
(
win
.
CanCloseWindow
(
)
)
{
win
.
skipNextCanClose
=
true
;
return
true
;
}
return
false
;
}
_resetAllWindowClosures
(
windowList
)
{
for
(
let
win
of
windowList
)
{
win
.
skipNextCanClose
=
false
;
}
}
async
clear
(
range
privateStateForNewWindow
=
"
non
-
private
"
)
{
let
startDate
=
Date
.
now
(
)
;
let
windowList
=
[
]
;
for
(
let
someWin
of
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
)
{
windowList
.
push
(
someWin
)
;
if
(
!
this
.
_canCloseWindow
(
someWin
)
)
{
this
.
_resetAllWindowClosures
(
windowList
)
;
throw
new
Error
(
"
Sanitize
could
not
close
windows
:
cancelled
by
user
"
)
;
}
if
(
Date
.
now
(
)
>
(
startDate
+
60
*
1000
)
)
{
this
.
_resetAllWindowClosures
(
windowList
)
;
throw
new
Error
(
"
Sanitize
could
not
close
windows
:
timeout
"
)
;
}
}
if
(
windowList
.
length
=
=
0
)
{
return
;
}
let
refObj
=
{
}
;
TelemetryStopwatch
.
start
(
"
FX_SANITIZE_OPENWINDOWS
"
refObj
)
;
let
handler
=
Cc
[
"
mozilla
.
org
/
browser
/
clh
;
1
"
]
.
getService
(
Ci
.
nsIBrowserHandler
)
;
let
defaultArgs
=
handler
.
defaultArgs
;
let
features
=
"
chrome
all
dialog
=
no
"
+
privateStateForNewWindow
;
let
newWindow
=
windowList
[
0
]
.
openDialog
(
AppConstants
.
BROWSER_CHROME_URL
"
_blank
"
features
defaultArgs
)
;
let
onFullScreen
=
null
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
onFullScreen
=
function
(
e
)
{
newWindow
.
removeEventListener
(
"
fullscreen
"
onFullScreen
)
;
let
docEl
=
newWindow
.
document
.
documentElement
;
let
sizemode
=
docEl
.
getAttribute
(
"
sizemode
"
)
;
if
(
!
newWindow
.
fullScreen
&
&
sizemode
=
=
"
fullscreen
"
)
{
docEl
.
setAttribute
(
"
sizemode
"
"
normal
"
)
;
e
.
preventDefault
(
)
;
e
.
stopPropagation
(
)
;
return
false
;
}
return
undefined
;
}
;
newWindow
.
addEventListener
(
"
fullscreen
"
onFullScreen
)
;
}
let
promiseReady
=
new
Promise
(
resolve
=
>
{
let
newWindowOpened
=
false
;
let
onWindowOpened
=
function
(
subject
topic
data
)
{
if
(
subject
!
=
newWindow
)
return
;
Services
.
obs
.
removeObserver
(
onWindowOpened
"
browser
-
delayed
-
startup
-
finished
"
)
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
newWindow
.
removeEventListener
(
"
fullscreen
"
onFullScreen
)
;
}
newWindowOpened
=
true
;
if
(
numWindowsClosing
=
=
0
)
{
TelemetryStopwatch
.
finish
(
"
FX_SANITIZE_OPENWINDOWS
"
refObj
)
;
resolve
(
)
;
}
}
;
let
numWindowsClosing
=
windowList
.
length
;
let
onWindowClosed
=
function
(
)
{
numWindowsClosing
-
-
;
if
(
numWindowsClosing
=
=
0
)
{
Services
.
obs
.
removeObserver
(
onWindowClosed
"
xul
-
window
-
destroyed
"
)
;
if
(
newWindowOpened
)
{
TelemetryStopwatch
.
finish
(
"
FX_SANITIZE_OPENWINDOWS
"
refObj
)
;
resolve
(
)
;
}
}
}
;
Services
.
obs
.
addObserver
(
onWindowOpened
"
browser
-
delayed
-
startup
-
finished
"
)
;
Services
.
obs
.
addObserver
(
onWindowClosed
"
xul
-
window
-
destroyed
"
)
;
}
)
;
while
(
windowList
.
length
)
{
windowList
.
pop
(
)
.
close
(
)
;
}
newWindow
.
focus
(
)
;
await
promiseReady
;
}
}
pluginData
:
{
async
clear
(
range
)
{
await
clearData
(
range
Ci
.
nsIClearDataService
.
CLEAR_PLUGIN_DATA
)
;
}
}
}
}
;
async
function
sanitizeInternal
(
items
aItemsToClear
progress
options
=
{
}
)
{
let
{
ignoreTimespan
=
true
range
}
=
options
;
let
seenError
=
false
;
if
(
!
Array
.
isArray
(
aItemsToClear
)
)
throw
new
Error
(
"
Must
pass
an
array
of
items
to
clear
.
"
)
;
let
itemsToClear
=
[
.
.
.
aItemsToClear
]
;
let
uid
=
gPendingSanitizationSerial
+
+
;
if
(
!
progress
.
isShutdown
)
addPendingSanitization
(
uid
itemsToClear
options
)
;
for
(
let
k
of
itemsToClear
)
{
progress
[
k
]
=
"
ready
"
;
}
let
openWindowsIndex
=
itemsToClear
.
indexOf
(
"
openWindows
"
)
;
if
(
openWindowsIndex
!
=
-
1
)
{
itemsToClear
.
splice
(
openWindowsIndex
1
)
;
await
items
.
openWindows
.
clear
(
null
options
)
;
progress
.
openWindows
=
"
cleared
"
;
}
if
(
!
ignoreTimespan
&
&
!
range
)
{
range
=
Sanitizer
.
getClearRange
(
)
;
}
let
refObj
=
{
}
;
TelemetryStopwatch
.
start
(
"
FX_SANITIZE_TOTAL
"
refObj
)
;
let
annotateError
=
(
name
ex
)
=
>
{
progress
[
name
]
=
"
failed
"
;
seenError
=
true
;
console
.
error
(
"
Error
sanitizing
"
+
name
ex
)
;
}
;
let
handles
=
[
]
;
for
(
let
name
of
itemsToClear
)
{
let
item
=
items
[
name
]
;
try
{
handles
.
push
(
{
name
promise
:
item
.
clear
(
range
options
)
.
then
(
(
)
=
>
progress
[
name
]
=
"
cleared
"
ex
=
>
annotateError
(
name
ex
)
)
}
)
;
}
catch
(
ex
)
{
annotateError
(
name
ex
)
;
}
}
for
(
let
handle
of
handles
)
{
progress
[
handle
.
name
]
=
"
blocking
"
;
await
handle
.
promise
;
}
TelemetryStopwatch
.
finish
(
"
FX_SANITIZE_TOTAL
"
refObj
)
;
if
(
!
progress
.
isShutdown
)
removePendingSanitization
(
uid
)
;
progress
=
{
}
;
if
(
seenError
)
{
throw
new
Error
(
"
Error
sanitizing
"
)
;
}
}
class
PrincipalsCollector
{
constructor
(
)
{
this
.
principals
=
null
;
}
async
getAllPrincipals
(
progress
)
{
if
(
this
.
principals
=
=
null
)
{
this
.
principals
=
await
this
.
getAllPrincipalsInternal
(
progress
)
;
}
return
this
.
principals
;
}
async
getAllPrincipalsInternal
(
progress
)
{
progress
.
step
=
"
principals
-
quota
-
manager
"
;
let
principals
=
await
new
Promise
(
resolve
=
>
{
quotaManagerService
.
listInitializedOrigins
(
request
=
>
{
progress
.
step
=
"
principals
-
quota
-
manager
-
listInitializedOrigins
"
;
if
(
request
.
resultCode
!
=
Cr
.
NS_OK
)
{
resolve
(
[
]
)
;
return
;
}
let
list
=
[
]
;
for
(
let
item
of
request
.
result
)
{
let
principal
=
Services
.
scriptSecurityManager
.
createCodebasePrincipalFromOrigin
(
item
.
origin
)
;
let
uri
=
principal
.
URI
;
if
(
isSupportedURI
(
uri
)
)
{
list
.
push
(
principal
)
;
}
}
progress
.
step
=
"
principals
-
quota
-
manager
-
completed
"
;
resolve
(
list
)
;
}
)
;
}
)
.
catch
(
ex
=
>
{
Cu
.
reportError
(
"
QuotaManagerService
promise
failed
:
"
+
ex
)
;
return
[
]
;
}
)
;
progress
.
step
=
"
principals
-
service
-
workers
"
;
let
serviceWorkers
=
serviceWorkerManager
.
getAllRegistrations
(
)
;
for
(
let
i
=
0
;
i
<
serviceWorkers
.
length
;
i
+
+
)
{
let
sw
=
serviceWorkers
.
queryElementAt
(
i
Ci
.
nsIServiceWorkerRegistrationInfo
)
;
principals
.
push
(
sw
.
principal
)
;
}
progress
.
step
=
"
principals
-
cookies
"
;
let
enumerator
=
Services
.
cookies
.
enumerator
;
let
hosts
=
new
Set
(
)
;
for
(
let
cookie
of
enumerator
)
{
hosts
.
add
(
cookie
.
rawHost
+
ChromeUtils
.
originAttributesToSuffix
(
cookie
.
originAttributes
)
)
;
}
progress
.
step
=
"
principals
-
host
-
cookie
"
;
hosts
.
forEach
(
host
=
>
{
principals
.
push
(
Services
.
scriptSecurityManager
.
createCodebasePrincipalFromOrigin
(
"
https
:
/
/
"
+
host
)
)
;
}
)
;
progress
.
step
=
"
total
-
principals
:
"
+
principals
.
length
;
return
principals
;
}
}
async
function
sanitizeOnShutdown
(
progress
)
{
log
(
"
Sanitizing
on
shutdown
"
)
;
let
needsSyncSavePrefs
=
false
;
if
(
Sanitizer
.
shouldSanitizeOnShutdown
)
{
progress
.
advancement
=
"
shutdown
-
cleaner
"
;
let
itemsToClear
=
getItemsToClearFromPrefBranch
(
Sanitizer
.
PREF_SHUTDOWN_BRANCH
)
;
await
Sanitizer
.
sanitize
(
itemsToClear
{
progress
}
)
;
removePendingSanitization
(
"
shutdown
"
)
;
needsSyncSavePrefs
=
true
;
}
if
(
Sanitizer
.
shouldSanitizeNewTabContainer
)
{
progress
.
advancement
=
"
newtab
-
segregation
"
;
sanitizeNewTabSegregation
(
)
;
removePendingSanitization
(
"
newtab
-
container
"
)
;
needsSyncSavePrefs
=
true
;
}
if
(
needsSyncSavePrefs
)
{
Services
.
prefs
.
savePrefFile
(
null
)
;
}
let
principalsCollector
=
new
PrincipalsCollector
(
)
;
if
(
Services
.
prefs
.
getIntPref
(
PREF_COOKIE_LIFETIME
Ci
.
nsICookieService
.
ACCEPT_NORMALLY
)
=
=
Ci
.
nsICookieService
.
ACCEPT_SESSION
)
{
log
(
"
Session
-
only
configuration
detected
"
)
;
progress
.
advancement
=
"
session
-
only
"
;
let
principals
=
await
principalsCollector
.
getAllPrincipals
(
progress
)
;
await
maybeSanitizeSessionPrincipals
(
progress
principals
)
;
progress
.
advancement
=
"
done
"
;
return
;
}
progress
.
advancement
=
"
session
-
permission
"
;
for
(
let
permission
of
Services
.
perms
.
enumerator
)
{
if
(
permission
.
type
!
=
"
cookie
"
|
|
permission
.
capability
!
=
Ci
.
nsICookiePermission
.
ACCESS_SESSION
)
{
continue
;
}
if
(
!
isSupportedURI
(
permission
.
principal
.
URI
)
)
{
continue
;
}
log
(
"
Custom
session
cookie
permission
detected
for
:
"
+
permission
.
principal
.
URI
.
spec
)
;
let
principals
=
await
principalsCollector
.
getAllPrincipals
(
progress
)
;
let
selectedPrincipals
=
extractMatchingPrincipals
(
principals
permission
.
principal
.
URI
)
;
await
maybeSanitizeSessionPrincipals
(
progress
selectedPrincipals
)
;
}
progress
.
advancement
=
"
done
"
;
}
function
extractMatchingPrincipals
(
principals
matchUri
)
{
return
principals
.
filter
(
principal
=
>
{
return
Services
.
eTLD
.
hasRootDomain
(
matchUri
.
host
principal
.
URI
.
host
)
;
}
)
;
}
async
function
maybeSanitizeSessionPrincipals
(
progress
principals
)
{
log
(
"
Sanitizing
"
+
principals
.
length
+
"
principals
"
)
;
let
promises
=
[
]
;
principals
.
forEach
(
principal
=
>
{
progress
.
step
=
"
checking
-
principal
"
;
let
cookieAllowed
=
cookiesAllowedForDomainOrSubDomain
(
principal
)
;
progress
.
step
=
"
principal
-
checked
:
"
+
cookieAllowed
;
if
(
!
cookieAllowed
)
{
promises
.
push
(
sanitizeSessionPrincipal
(
progress
principal
)
)
;
}
}
)
;
progress
.
step
=
"
promises
:
"
+
promises
.
length
;
await
Promise
.
all
(
promises
)
;
progress
.
step
=
"
promises
resolved
"
;
}
function
cookiesAllowedForDomainOrSubDomain
(
principal
)
{
log
(
"
Checking
principal
:
"
+
principal
.
URI
.
spec
)
;
let
p
=
Services
.
perms
.
testPermissionFromPrincipal
(
principal
"
cookie
"
)
;
if
(
p
=
=
Ci
.
nsICookiePermission
.
ACCESS_ALLOW
)
{
log
(
"
Cookie
allowed
!
"
)
;
return
true
;
}
if
(
p
=
=
Ci
.
nsICookiePermission
.
ACCESS_DENY
|
|
p
=
=
Ci
.
nsICookiePermission
.
ACCESS_SESSION
)
{
log
(
"
Cookie
denied
or
session
!
"
)
;
return
false
;
}
if
(
p
!
=
Ci
.
nsICookiePermission
.
ACCESS_DEFAULT
)
{
log
(
"
Not
supported
cookie
permission
:
"
+
p
)
;
return
false
;
}
for
(
let
perm
of
Services
.
perms
.
enumerator
)
{
if
(
perm
.
type
!
=
"
cookie
"
)
{
continue
;
}
if
(
!
isSupportedURI
(
perm
.
principal
.
URI
)
)
{
continue
;
}
if
(
Services
.
eTLD
.
hasRootDomain
(
perm
.
principal
.
URI
.
host
principal
.
URI
.
host
)
)
{
log
(
"
Recursive
cookie
check
on
principal
:
"
+
perm
.
principal
.
URI
.
spec
)
;
return
cookiesAllowedForDomainOrSubDomain
(
perm
.
principal
)
;
}
}
log
(
"
Cookie
not
allowed
.
"
)
;
return
false
;
}
async
function
sanitizeSessionPrincipal
(
progress
principal
)
{
log
(
"
Sanitizing
principal
:
"
+
principal
.
URI
.
spec
)
;
await
new
Promise
(
resolve
=
>
{
progress
.
sanitizePrincipal
=
"
started
"
;
Services
.
clearData
.
deleteDataFromPrincipal
(
principal
true
Ci
.
nsIClearDataService
.
CLEAR_ALL_CACHES
|
Ci
.
nsIClearDataService
.
CLEAR_COOKIES
|
Ci
.
nsIClearDataService
.
CLEAR_DOM_STORAGES
|
Ci
.
nsIClearDataService
.
CLEAR_SECURITY_SETTINGS
|
Ci
.
nsIClearDataService
.
CLEAR_EME
|
Ci
.
nsIClearDataService
.
CLEAR_PLUGIN_DATA
resolve
)
;
}
)
;
progress
.
sanitizePrincipal
=
"
completed
"
;
}
function
sanitizeNewTabSegregation
(
)
{
let
identity
=
ContextualIdentityService
.
getPrivateIdentity
(
"
userContextIdInternal
.
thumbnail
"
)
;
if
(
identity
)
{
Services
.
clearData
.
deleteDataFromOriginAttributesPattern
(
{
userContextId
:
identity
.
userContextId
}
)
;
}
}
function
getItemsToClearFromPrefBranch
(
branch
)
{
branch
=
Services
.
prefs
.
getBranch
(
branch
)
;
return
Object
.
keys
(
Sanitizer
.
items
)
.
filter
(
itemName
=
>
{
try
{
return
branch
.
getBoolPref
(
itemName
)
;
}
catch
(
ex
)
{
return
false
;
}
}
)
;
}
function
addPendingSanitization
(
id
itemsToClear
options
)
{
let
pendingSanitizations
=
safeGetPendingSanitizations
(
)
;
pendingSanitizations
.
push
(
{
id
itemsToClear
options
}
)
;
Services
.
prefs
.
setStringPref
(
Sanitizer
.
PREF_PENDING_SANITIZATIONS
JSON
.
stringify
(
pendingSanitizations
)
)
;
}
function
removePendingSanitization
(
id
)
{
let
pendingSanitizations
=
safeGetPendingSanitizations
(
)
;
let
i
=
pendingSanitizations
.
findIndex
(
s
=
>
s
.
id
=
=
id
)
;
let
[
s
]
=
pendingSanitizations
.
splice
(
i
1
)
;
Services
.
prefs
.
setStringPref
(
Sanitizer
.
PREF_PENDING_SANITIZATIONS
JSON
.
stringify
(
pendingSanitizations
)
)
;
return
s
;
}
function
getAndClearPendingSanitizations
(
)
{
let
pendingSanitizations
=
safeGetPendingSanitizations
(
)
;
if
(
pendingSanitizations
.
length
)
Services
.
prefs
.
clearUserPref
(
Sanitizer
.
PREF_PENDING_SANITIZATIONS
)
;
return
pendingSanitizations
;
}
function
safeGetPendingSanitizations
(
)
{
try
{
return
JSON
.
parse
(
Services
.
prefs
.
getStringPref
(
Sanitizer
.
PREF_PENDING_SANITIZATIONS
"
[
]
"
)
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
"
Invalid
JSON
value
for
pending
sanitizations
:
"
+
ex
)
;
return
[
]
;
}
}
async
function
clearData
(
range
flags
)
{
if
(
range
)
{
await
new
Promise
(
resolve
=
>
{
Services
.
clearData
.
deleteDataInTimeRange
(
range
[
0
]
range
[
1
]
true
flags
resolve
)
;
}
)
;
}
else
{
await
new
Promise
(
resolve
=
>
{
Services
.
clearData
.
deleteData
(
flags
resolve
)
;
}
)
;
}
}
function
isSupportedURI
(
uri
)
{
return
uri
.
scheme
=
=
"
http
"
|
|
uri
.
scheme
=
=
"
https
"
|
|
uri
.
scheme
=
=
"
file
"
;
}
