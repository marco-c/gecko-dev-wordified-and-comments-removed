var
EXPORTED_SYMBOLS
=
[
"
Sanitizer
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AppConstants
:
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
PlacesUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
FormHistory
:
"
resource
:
/
/
gre
/
modules
/
FormHistory
.
jsm
"
Downloads
:
"
resource
:
/
/
gre
/
modules
/
Downloads
.
jsm
"
TelemetryStopwatch
:
"
resource
:
/
/
gre
/
modules
/
TelemetryStopwatch
.
jsm
"
setTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
ServiceWorkerCleanUp
:
"
resource
:
/
/
gre
/
modules
/
ServiceWorkerCleanUp
.
jsm
"
OfflineAppCacheHelper
:
"
resource
:
/
/
gre
/
modules
/
offlineAppCache
.
jsm
"
ContextualIdentityService
:
"
resource
:
/
/
gre
/
modules
/
ContextualIdentityService
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
sas
"
"
mozilla
.
org
/
storage
/
activity
-
service
;
1
"
"
nsIStorageActivityService
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
quotaManagerService
"
"
mozilla
.
org
/
dom
/
quota
-
manager
-
service
;
1
"
"
nsIQuotaManagerService
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
serviceWorkerManager
"
"
mozilla
.
org
/
serviceworkers
/
manager
;
1
"
"
nsIServiceWorkerManager
"
)
;
var
gPendingSanitizationSerial
=
0
;
const
YIELD_PERIOD
=
10
;
const
PREF_COOKIE_LIFETIME
=
"
network
.
cookie
.
lifetimePolicy
"
;
var
Sanitizer
=
{
PREF_SANITIZE_ON_SHUTDOWN
:
"
privacy
.
sanitize
.
sanitizeOnShutdown
"
PREF_PENDING_SANITIZATIONS
:
"
privacy
.
sanitize
.
pending
"
PREF_CPD_BRANCH
:
"
privacy
.
cpd
.
"
PREF_SHUTDOWN_BRANCH
:
"
privacy
.
clearOnShutdown
.
"
PREF_TIMESPAN
:
"
privacy
.
sanitize
.
timeSpan
"
PREF_NEWTAB_SEGREGATION
:
"
privacy
.
usercontext
.
about_newtab_segregation
.
enabled
"
TIMESPAN_EVERYTHING
:
0
TIMESPAN_HOUR
:
1
TIMESPAN_2HOURS
:
2
TIMESPAN_4HOURS
:
3
TIMESPAN_TODAY
:
4
TIMESPAN_5MIN
:
5
TIMESPAN_24HOURS
:
6
shouldSanitizeOnShutdown
:
false
shouldSanitizeNewTabContainer
:
false
showUI
(
parentWindow
)
{
let
win
=
AppConstants
.
platform
=
=
"
macosx
"
?
null
:
parentWindow
;
Services
.
ww
.
openWindow
(
win
"
chrome
:
/
/
browser
/
content
/
sanitize
.
xul
"
"
Sanitize
"
"
chrome
titlebar
dialog
centerscreen
modal
"
null
)
;
}
async
onStartup
(
)
{
let
pendingSanitizations
=
getAndClearPendingSanitizations
(
)
;
this
.
shouldSanitizeOnShutdown
=
Services
.
prefs
.
getBoolPref
(
Sanitizer
.
PREF_SANITIZE_ON_SHUTDOWN
false
)
;
Services
.
prefs
.
addObserver
(
Sanitizer
.
PREF_SANITIZE_ON_SHUTDOWN
this
true
)
;
if
(
this
.
shouldSanitizeOnShutdown
)
{
let
itemsToClear
=
getItemsToClearFromPrefBranch
(
Sanitizer
.
PREF_SHUTDOWN_BRANCH
)
;
addPendingSanitization
(
"
shutdown
"
itemsToClear
{
}
)
;
}
Services
.
prefs
.
addObserver
(
Sanitizer
.
PREF_SHUTDOWN_BRANCH
this
true
)
;
let
shutdownClient
=
PlacesUtils
.
history
.
shutdownClient
.
jsclient
;
let
progress
=
{
isShutdown
:
true
}
;
shutdownClient
.
addBlocker
(
"
sanitize
.
js
:
Sanitize
on
shutdown
"
(
)
=
>
sanitizeOnShutdown
(
progress
)
{
fetchState
:
(
)
=
>
(
{
progress
}
)
}
)
;
this
.
shouldSanitizeNewTabContainer
=
Services
.
prefs
.
getBoolPref
(
this
.
PREF_NEWTAB_SEGREGATION
false
)
;
if
(
this
.
shouldSanitizeNewTabContainer
)
{
addPendingSanitization
(
"
newtab
-
container
"
[
]
{
}
)
;
}
let
i
=
pendingSanitizations
.
findIndex
(
s
=
>
s
.
id
=
=
"
newtab
-
container
"
)
;
if
(
i
)
{
pendingSanitizations
.
splice
(
i
1
)
;
sanitizeNewTabSegregation
(
)
;
}
for
(
let
{
itemsToClear
options
}
of
pendingSanitizations
)
{
try
{
await
this
.
sanitize
(
itemsToClear
options
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
"
A
previously
pending
sanitization
failed
:
"
+
itemsToClear
+
"
\
n
"
+
ex
)
;
}
}
}
getClearRange
(
ts
)
{
if
(
ts
=
=
=
undefined
)
ts
=
Services
.
prefs
.
getIntPref
(
Sanitizer
.
PREF_TIMESPAN
)
;
if
(
ts
=
=
=
Sanitizer
.
TIMESPAN_EVERYTHING
)
return
null
;
var
endDate
=
Date
.
now
(
)
*
1000
;
switch
(
ts
)
{
case
Sanitizer
.
TIMESPAN_5MIN
:
var
startDate
=
endDate
-
300000000
;
break
;
case
Sanitizer
.
TIMESPAN_HOUR
:
startDate
=
endDate
-
3600000000
;
break
;
case
Sanitizer
.
TIMESPAN_2HOURS
:
startDate
=
endDate
-
7200000000
;
break
;
case
Sanitizer
.
TIMESPAN_4HOURS
:
startDate
=
endDate
-
14400000000
;
break
;
case
Sanitizer
.
TIMESPAN_TODAY
:
var
d
=
new
Date
(
)
;
d
.
setHours
(
0
)
;
d
.
setMinutes
(
0
)
;
d
.
setSeconds
(
0
)
;
startDate
=
d
.
valueOf
(
)
*
1000
;
break
;
case
Sanitizer
.
TIMESPAN_24HOURS
:
startDate
=
endDate
-
86400000000
;
break
;
default
:
throw
"
Invalid
time
span
for
clear
private
data
:
"
+
ts
;
}
return
[
startDate
endDate
]
;
}
async
sanitize
(
itemsToClear
=
null
options
=
{
}
)
{
let
progress
=
options
.
progress
|
|
{
}
;
if
(
!
itemsToClear
)
itemsToClear
=
getItemsToClearFromPrefBranch
(
this
.
PREF_CPD_BRANCH
)
;
let
promise
=
sanitizeInternal
(
this
.
items
itemsToClear
progress
options
)
;
if
(
!
progress
.
isShutdown
)
{
let
shutdownClient
=
PlacesUtils
.
history
.
shutdownClient
.
jsclient
;
shutdownClient
.
addBlocker
(
"
sanitize
.
js
:
Sanitize
"
promise
{
fetchState
:
(
)
=
>
(
{
progress
}
)
}
)
;
}
try
{
await
promise
;
}
finally
{
Services
.
obs
.
notifyObservers
(
null
"
sanitizer
-
sanitization
-
complete
"
)
;
}
}
observe
(
subject
topic
data
)
{
if
(
topic
=
=
"
nsPref
:
changed
"
)
{
if
(
data
.
startsWith
(
this
.
PREF_SHUTDOWN_BRANCH
)
&
&
this
.
shouldSanitizeOnShutdown
)
{
removePendingSanitization
(
"
shutdown
"
)
;
let
itemsToClear
=
getItemsToClearFromPrefBranch
(
Sanitizer
.
PREF_SHUTDOWN_BRANCH
)
;
addPendingSanitization
(
"
shutdown
"
itemsToClear
{
}
)
;
}
else
if
(
data
=
=
this
.
PREF_SANITIZE_ON_SHUTDOWN
)
{
this
.
shouldSanitizeOnShutdown
=
Services
.
prefs
.
getBoolPref
(
Sanitizer
.
PREF_SANITIZE_ON_SHUTDOWN
false
)
;
removePendingSanitization
(
"
shutdown
"
)
;
if
(
this
.
shouldSanitizeOnShutdown
)
{
let
itemsToClear
=
getItemsToClearFromPrefBranch
(
Sanitizer
.
PREF_SHUTDOWN_BRANCH
)
;
addPendingSanitization
(
"
shutdown
"
itemsToClear
{
}
)
;
}
}
else
if
(
data
=
=
this
.
PREF_NEWTAB_SEGREGATION
)
{
this
.
shouldSanitizeNewTabContainer
=
Services
.
prefs
.
getBoolPref
(
this
.
PREF_NEWTAB_SEGREGATION
false
)
;
removePendingSanitization
(
"
newtab
-
container
"
)
;
if
(
this
.
shouldSanitizeNewTabContainer
)
{
addPendingSanitization
(
"
newtab
-
container
"
[
]
{
}
)
;
}
}
}
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsiObserver
Ci
.
nsISupportsWeakReference
]
)
async
runSanitizeOnShutdown
(
)
{
return
sanitizeOnShutdown
(
{
isShutdown
:
true
}
)
;
}
items
:
{
cache
:
{
async
clear
(
range
)
{
let
seenException
;
let
refObj
=
{
}
;
TelemetryStopwatch
.
start
(
"
FX_SANITIZE_CACHE
"
refObj
)
;
try
{
Services
.
cache2
.
clear
(
)
;
}
catch
(
ex
)
{
seenException
=
ex
;
}
try
{
let
imageCache
=
Cc
[
"
mozilla
.
org
/
image
/
tools
;
1
"
]
.
getService
(
Ci
.
imgITools
)
.
getImgCacheForDocument
(
null
)
;
imageCache
.
clearCache
(
false
)
;
}
catch
(
ex
)
{
seenException
=
ex
;
}
TelemetryStopwatch
.
finish
(
"
FX_SANITIZE_CACHE
"
refObj
)
;
if
(
seenException
)
{
throw
seenException
;
}
}
}
cookies
:
{
async
clear
(
range
)
{
let
seenException
;
let
yieldCounter
=
0
;
let
refObj
=
{
}
;
TelemetryStopwatch
.
start
(
"
FX_SANITIZE_COOKIES_2
"
refObj
)
;
try
{
if
(
range
)
{
let
cookiesEnum
=
Services
.
cookies
.
enumerator
;
while
(
cookiesEnum
.
hasMoreElements
(
)
)
{
let
cookie
=
cookiesEnum
.
getNext
(
)
.
QueryInterface
(
Ci
.
nsICookie2
)
;
if
(
cookie
.
creationTime
>
range
[
0
]
)
{
Services
.
cookies
.
remove
(
cookie
.
host
cookie
.
name
cookie
.
path
false
cookie
.
originAttributes
)
;
if
(
+
+
yieldCounter
%
YIELD_PERIOD
=
=
0
)
{
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
0
)
)
;
}
}
}
}
else
{
Services
.
cookies
.
removeAll
(
)
;
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
0
)
)
;
}
}
catch
(
ex
)
{
seenException
=
ex
;
}
finally
{
TelemetryStopwatch
.
finish
(
"
FX_SANITIZE_COOKIES_2
"
refObj
)
;
}
try
{
let
mediaMgr
=
Cc
[
"
mozilla
.
org
/
mediaManagerService
;
1
"
]
.
getService
(
Ci
.
nsIMediaManagerService
)
;
mediaMgr
.
sanitizeDeviceIds
(
range
&
&
range
[
0
]
)
;
}
catch
(
ex
)
{
seenException
=
ex
;
}
try
{
await
clearPluginData
(
range
)
;
}
catch
(
ex
)
{
seenException
=
ex
;
}
if
(
seenException
)
{
throw
seenException
;
}
}
}
offlineApps
:
{
async
clear
(
range
)
{
OfflineAppCacheHelper
.
clear
(
)
;
if
(
range
)
{
let
principals
=
sas
.
getActiveOrigins
(
range
[
0
]
range
[
1
]
)
.
QueryInterface
(
Ci
.
nsIArray
)
;
let
promises
=
[
]
;
for
(
let
i
=
0
;
i
<
principals
.
length
;
+
+
i
)
{
let
principal
=
principals
.
queryElementAt
(
i
Ci
.
nsIPrincipal
)
;
if
(
principal
.
URI
.
scheme
!
=
"
http
"
&
&
principal
.
URI
.
scheme
!
=
"
https
"
&
&
principal
.
URI
.
scheme
!
=
"
file
"
)
{
continue
;
}
Services
.
obs
.
notifyObservers
(
null
"
browser
:
purge
-
domain
-
data
"
principal
.
URI
.
host
)
;
await
ServiceWorkerCleanUp
.
removeFromPrincipal
(
principal
)
;
promises
.
push
(
new
Promise
(
r
=
>
{
let
req
=
quotaManagerService
.
clearStoragesForPrincipal
(
principal
null
false
)
;
req
.
callback
=
(
)
=
>
{
r
(
)
;
}
;
}
)
)
;
}
return
Promise
.
all
(
promises
)
;
}
Services
.
obs
.
notifyObservers
(
null
"
extension
:
purge
-
localStorage
"
)
;
await
ServiceWorkerCleanUp
.
removeAll
(
)
;
let
promises
=
[
]
;
await
new
Promise
(
resolve
=
>
{
quotaManagerService
.
getUsage
(
request
=
>
{
if
(
request
.
resultCode
!
=
Cr
.
NS_OK
)
{
resolve
(
)
;
return
;
}
for
(
let
item
of
request
.
result
)
{
let
principal
=
Services
.
scriptSecurityManager
.
createCodebasePrincipalFromOrigin
(
item
.
origin
)
;
let
uri
=
principal
.
URI
;
if
(
uri
.
scheme
=
=
"
http
"
|
|
uri
.
scheme
=
=
"
https
"
|
|
uri
.
scheme
=
=
"
file
"
)
{
promises
.
push
(
new
Promise
(
r
=
>
{
let
req
=
quotaManagerService
.
clearStoragesForPrincipal
(
principal
null
false
)
;
req
.
callback
=
(
)
=
>
{
r
(
)
;
}
;
}
)
)
;
}
}
resolve
(
)
;
}
)
;
}
)
;
return
Promise
.
all
(
promises
)
;
}
}
history
:
{
async
clear
(
range
)
{
let
seenException
;
let
refObj
=
{
}
;
TelemetryStopwatch
.
start
(
"
FX_SANITIZE_HISTORY
"
refObj
)
;
try
{
if
(
range
)
{
await
PlacesUtils
.
history
.
removeVisitsByFilter
(
{
beginDate
:
new
Date
(
range
[
0
]
/
1000
)
endDate
:
new
Date
(
range
[
1
]
/
1000
)
}
)
;
}
else
{
await
PlacesUtils
.
history
.
clear
(
)
;
}
}
catch
(
ex
)
{
seenException
=
ex
;
}
finally
{
TelemetryStopwatch
.
finish
(
"
FX_SANITIZE_HISTORY
"
refObj
)
;
}
try
{
let
clearStartingTime
=
range
?
String
(
range
[
0
]
)
:
"
"
;
Services
.
obs
.
notifyObservers
(
null
"
browser
:
purge
-
session
-
history
"
clearStartingTime
)
;
}
catch
(
ex
)
{
seenException
=
ex
;
}
try
{
let
predictor
=
Cc
[
"
mozilla
.
org
/
network
/
predictor
;
1
"
]
.
getService
(
Ci
.
nsINetworkPredictor
)
;
predictor
.
reset
(
)
;
}
catch
(
ex
)
{
seenException
=
ex
;
}
if
(
seenException
)
{
throw
seenException
;
}
}
}
formdata
:
{
async
clear
(
range
)
{
let
seenException
;
let
refObj
=
{
}
;
TelemetryStopwatch
.
start
(
"
FX_SANITIZE_FORMDATA
"
refObj
)
;
try
{
let
windows
=
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
;
while
(
windows
.
hasMoreElements
(
)
)
{
let
currentWindow
=
windows
.
getNext
(
)
;
let
currentDocument
=
currentWindow
.
document
;
let
searchBar
=
currentDocument
.
getElementById
(
"
searchbar
"
)
;
if
(
searchBar
&
&
searchBar
.
textbox
)
searchBar
.
textbox
.
reset
(
)
;
let
tabBrowser
=
currentWindow
.
gBrowser
;
if
(
!
tabBrowser
)
{
continue
;
}
for
(
let
tab
of
tabBrowser
.
tabs
)
{
if
(
tabBrowser
.
isFindBarInitialized
(
tab
)
)
tabBrowser
.
getCachedFindBar
(
tab
)
.
clear
(
)
;
}
tabBrowser
.
_lastFindValue
=
"
"
;
}
}
catch
(
ex
)
{
seenException
=
ex
;
}
try
{
let
change
=
{
op
:
"
remove
"
}
;
if
(
range
)
{
[
change
.
firstUsedStart
change
.
firstUsedEnd
]
=
range
;
}
await
new
Promise
(
resolve
=
>
{
FormHistory
.
update
(
change
{
handleError
(
e
)
{
seenException
=
new
Error
(
"
Error
"
+
e
.
result
+
"
:
"
+
e
.
message
)
;
}
handleCompletion
(
)
{
resolve
(
)
;
}
}
)
;
}
)
;
}
catch
(
ex
)
{
seenException
=
ex
;
}
TelemetryStopwatch
.
finish
(
"
FX_SANITIZE_FORMDATA
"
refObj
)
;
if
(
seenException
)
{
throw
seenException
;
}
}
}
downloads
:
{
async
clear
(
range
)
{
let
refObj
=
{
}
;
TelemetryStopwatch
.
start
(
"
FX_SANITIZE_DOWNLOADS
"
refObj
)
;
try
{
let
filterByTime
=
null
;
if
(
range
)
{
let
rangeBeginMs
=
range
[
0
]
/
1000
;
let
rangeEndMs
=
range
[
1
]
/
1000
;
filterByTime
=
download
=
>
download
.
startTime
>
=
rangeBeginMs
&
&
download
.
startTime
<
=
rangeEndMs
;
}
let
list
=
await
Downloads
.
getList
(
Downloads
.
ALL
)
;
list
.
removeFinished
(
filterByTime
)
;
}
finally
{
TelemetryStopwatch
.
finish
(
"
FX_SANITIZE_DOWNLOADS
"
refObj
)
;
}
}
}
sessions
:
{
async
clear
(
range
)
{
let
refObj
=
{
}
;
TelemetryStopwatch
.
start
(
"
FX_SANITIZE_SESSIONS
"
refObj
)
;
try
{
let
sdr
=
Cc
[
"
mozilla
.
org
/
security
/
sdr
;
1
"
]
.
getService
(
Ci
.
nsISecretDecoderRing
)
;
sdr
.
logoutAndTeardown
(
)
;
Services
.
obs
.
notifyObservers
(
null
"
net
:
clear
-
active
-
logins
"
)
;
}
finally
{
TelemetryStopwatch
.
finish
(
"
FX_SANITIZE_SESSIONS
"
refObj
)
;
}
}
}
siteSettings
:
{
async
clear
(
range
)
{
let
seenException
;
let
refObj
=
{
}
;
TelemetryStopwatch
.
start
(
"
FX_SANITIZE_SITESETTINGS
"
refObj
)
;
let
startDateMS
=
range
?
range
[
0
]
/
1000
:
null
;
try
{
if
(
startDateMS
=
=
null
)
{
Services
.
perms
.
removeAll
(
)
;
}
else
{
Services
.
perms
.
removeAllSince
(
startDateMS
)
;
}
}
catch
(
ex
)
{
seenException
=
ex
;
}
try
{
let
cps
=
Cc
[
"
mozilla
.
org
/
content
-
pref
/
service
;
1
"
]
.
getService
(
Ci
.
nsIContentPrefService2
)
;
if
(
startDateMS
=
=
null
)
{
cps
.
removeAllDomains
(
null
)
;
}
else
{
cps
.
removeAllDomainsSince
(
startDateMS
null
)
;
}
}
catch
(
ex
)
{
seenException
=
ex
;
}
try
{
let
sss
=
Cc
[
"
mozilla
.
org
/
ssservice
;
1
"
]
.
getService
(
Ci
.
nsISiteSecurityService
)
;
sss
.
clearAll
(
)
;
}
catch
(
ex
)
{
seenException
=
ex
;
}
try
{
await
new
Promise
(
(
resolve
reject
)
=
>
{
let
push
=
Cc
[
"
mozilla
.
org
/
push
/
Service
;
1
"
]
.
getService
(
Ci
.
nsIPushService
)
;
push
.
clearForDomain
(
"
*
"
status
=
>
{
if
(
Components
.
isSuccessCode
(
status
)
)
{
resolve
(
)
;
}
else
{
reject
(
new
Error
(
"
Error
clearing
push
subscriptions
:
"
+
status
)
)
;
}
}
)
;
}
)
;
}
catch
(
ex
)
{
seenException
=
ex
;
}
TelemetryStopwatch
.
finish
(
"
FX_SANITIZE_SITESETTINGS
"
refObj
)
;
if
(
seenException
)
{
throw
seenException
;
}
}
}
openWindows
:
{
_canCloseWindow
(
win
)
{
if
(
win
.
CanCloseWindow
(
)
)
{
win
.
skipNextCanClose
=
true
;
return
true
;
}
return
false
;
}
_resetAllWindowClosures
(
windowList
)
{
for
(
let
win
of
windowList
)
{
win
.
skipNextCanClose
=
false
;
}
}
async
clear
(
range
privateStateForNewWindow
=
"
non
-
private
"
)
{
let
existingWindow
=
Services
.
appShell
.
hiddenDOMWindow
;
let
startDate
=
existingWindow
.
performance
.
now
(
)
;
let
windowEnumerator
=
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
;
let
windowList
=
[
]
;
while
(
windowEnumerator
.
hasMoreElements
(
)
)
{
let
someWin
=
windowEnumerator
.
getNext
(
)
;
windowList
.
push
(
someWin
)
;
if
(
!
this
.
_canCloseWindow
(
someWin
)
)
{
this
.
_resetAllWindowClosures
(
windowList
)
;
throw
new
Error
(
"
Sanitize
could
not
close
windows
:
cancelled
by
user
"
)
;
}
if
(
existingWindow
.
performance
.
now
(
)
>
(
startDate
+
60
*
1000
)
)
{
this
.
_resetAllWindowClosures
(
windowList
)
;
throw
new
Error
(
"
Sanitize
could
not
close
windows
:
timeout
"
)
;
}
}
let
refObj
=
{
}
;
TelemetryStopwatch
.
start
(
"
FX_SANITIZE_OPENWINDOWS
"
refObj
)
;
let
handler
=
Cc
[
"
mozilla
.
org
/
browser
/
clh
;
1
"
]
.
getService
(
Ci
.
nsIBrowserHandler
)
;
let
defaultArgs
=
handler
.
defaultArgs
;
let
features
=
"
chrome
all
dialog
=
no
"
+
privateStateForNewWindow
;
let
newWindow
=
existingWindow
.
openDialog
(
"
chrome
:
/
/
browser
/
content
/
"
"
_blank
"
features
defaultArgs
)
;
let
onFullScreen
=
null
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
onFullScreen
=
function
(
e
)
{
newWindow
.
removeEventListener
(
"
fullscreen
"
onFullScreen
)
;
let
docEl
=
newWindow
.
document
.
documentElement
;
let
sizemode
=
docEl
.
getAttribute
(
"
sizemode
"
)
;
if
(
!
newWindow
.
fullScreen
&
&
sizemode
=
=
"
fullscreen
"
)
{
docEl
.
setAttribute
(
"
sizemode
"
"
normal
"
)
;
e
.
preventDefault
(
)
;
e
.
stopPropagation
(
)
;
return
false
;
}
return
undefined
;
}
;
newWindow
.
addEventListener
(
"
fullscreen
"
onFullScreen
)
;
}
let
promiseReady
=
new
Promise
(
resolve
=
>
{
let
newWindowOpened
=
false
;
let
onWindowOpened
=
function
(
subject
topic
data
)
{
if
(
subject
!
=
newWindow
)
return
;
Services
.
obs
.
removeObserver
(
onWindowOpened
"
browser
-
delayed
-
startup
-
finished
"
)
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
newWindow
.
removeEventListener
(
"
fullscreen
"
onFullScreen
)
;
}
newWindowOpened
=
true
;
if
(
numWindowsClosing
=
=
0
)
{
TelemetryStopwatch
.
finish
(
"
FX_SANITIZE_OPENWINDOWS
"
refObj
)
;
resolve
(
)
;
}
}
;
let
numWindowsClosing
=
windowList
.
length
;
let
onWindowClosed
=
function
(
)
{
numWindowsClosing
-
-
;
if
(
numWindowsClosing
=
=
0
)
{
Services
.
obs
.
removeObserver
(
onWindowClosed
"
xul
-
window
-
destroyed
"
)
;
if
(
newWindowOpened
)
{
TelemetryStopwatch
.
finish
(
"
FX_SANITIZE_OPENWINDOWS
"
refObj
)
;
resolve
(
)
;
}
}
}
;
Services
.
obs
.
addObserver
(
onWindowOpened
"
browser
-
delayed
-
startup
-
finished
"
)
;
Services
.
obs
.
addObserver
(
onWindowClosed
"
xul
-
window
-
destroyed
"
)
;
}
)
;
while
(
windowList
.
length
)
{
windowList
.
pop
(
)
.
close
(
)
;
}
newWindow
.
focus
(
)
;
await
promiseReady
;
}
}
pluginData
:
{
async
clear
(
range
)
{
await
clearPluginData
(
range
)
;
}
}
}
}
;
async
function
sanitizeInternal
(
items
aItemsToClear
progress
options
=
{
}
)
{
let
{
ignoreTimespan
=
true
range
}
=
options
;
let
seenError
=
false
;
if
(
!
Array
.
isArray
(
aItemsToClear
)
)
throw
new
Error
(
"
Must
pass
an
array
of
items
to
clear
.
"
)
;
let
itemsToClear
=
[
.
.
.
aItemsToClear
]
;
let
uid
=
gPendingSanitizationSerial
+
+
;
if
(
!
progress
.
isShutdown
)
addPendingSanitization
(
uid
itemsToClear
options
)
;
for
(
let
k
of
itemsToClear
)
{
progress
[
k
]
=
"
ready
"
;
}
let
openWindowsIndex
=
itemsToClear
.
indexOf
(
"
openWindows
"
)
;
if
(
openWindowsIndex
!
=
-
1
)
{
itemsToClear
.
splice
(
openWindowsIndex
1
)
;
await
items
.
openWindows
.
clear
(
null
options
)
;
progress
.
openWindows
=
"
cleared
"
;
}
if
(
!
ignoreTimespan
&
&
!
range
)
{
range
=
Sanitizer
.
getClearRange
(
)
;
}
let
refObj
=
{
}
;
TelemetryStopwatch
.
start
(
"
FX_SANITIZE_TOTAL
"
refObj
)
;
let
annotateError
=
(
name
ex
)
=
>
{
progress
[
name
]
=
"
failed
"
;
seenError
=
true
;
console
.
error
(
"
Error
sanitizing
"
+
name
ex
)
;
}
;
let
handles
=
[
]
;
for
(
let
name
of
itemsToClear
)
{
let
item
=
items
[
name
]
;
try
{
handles
.
push
(
{
name
promise
:
item
.
clear
(
range
options
)
.
then
(
(
)
=
>
progress
[
name
]
=
"
cleared
"
ex
=
>
annotateError
(
name
ex
)
)
}
)
;
}
catch
(
ex
)
{
annotateError
(
name
ex
)
;
}
}
for
(
let
handle
of
handles
)
{
progress
[
handle
.
name
]
=
"
blocking
"
;
await
handle
.
promise
;
}
TelemetryStopwatch
.
finish
(
"
FX_SANITIZE_TOTAL
"
refObj
)
;
if
(
!
progress
.
isShutdown
)
removePendingSanitization
(
uid
)
;
progress
=
{
}
;
if
(
seenError
)
{
throw
new
Error
(
"
Error
sanitizing
"
)
;
}
}
async
function
clearPluginData
(
range
)
{
let
seenException
;
let
promiseClearPluginData
=
async
function
(
)
{
const
FLAG_CLEAR_ALL
=
Ci
.
nsIPluginHost
.
FLAG_CLEAR_ALL
;
let
ph
=
Cc
[
"
mozilla
.
org
/
plugin
/
host
;
1
"
]
.
getService
(
Ci
.
nsIPluginHost
)
;
let
age
=
range
?
(
Date
.
now
(
)
/
1000
-
range
[
0
]
/
1000000
)
:
-
1
;
if
(
!
range
|
|
age
>
=
0
)
{
let
tags
=
ph
.
getPluginTags
(
)
;
for
(
let
tag
of
tags
)
{
try
{
let
rv
=
await
new
Promise
(
resolve
=
>
ph
.
clearSiteData
(
tag
null
FLAG_CLEAR_ALL
age
resolve
)
)
;
if
(
rv
=
=
Cr
.
NS_ERROR_PLUGIN_TIME_RANGE_NOT_SUPPORTED
)
{
await
new
Promise
(
resolve
=
>
ph
.
clearSiteData
(
tag
null
FLAG_CLEAR_ALL
-
1
resolve
)
)
;
}
}
catch
(
ex
)
{
}
}
}
}
;
try
{
promiseClearPluginData
=
promiseClearPluginData
(
range
)
;
await
Promise
.
race
(
[
promiseClearPluginData
new
Promise
(
resolve
=
>
setTimeout
(
resolve
10000
)
)
]
)
;
}
catch
(
ex
)
{
seenException
=
ex
;
}
promiseClearPluginData
.
catch
(
(
)
=
>
{
}
)
;
if
(
seenException
)
{
throw
seenException
;
}
}
async
function
sanitizeOnShutdown
(
progress
)
{
if
(
Sanitizer
.
shouldSanitizeOnShutdown
)
{
let
itemsToClear
=
getItemsToClearFromPrefBranch
(
Sanitizer
.
PREF_SHUTDOWN_BRANCH
)
;
await
Sanitizer
.
sanitize
(
itemsToClear
{
progress
}
)
;
}
await
sanitizeSessionPrincipals
(
)
;
let
enumerator
=
Services
.
perms
.
enumerator
;
while
(
enumerator
.
hasMoreElements
(
)
)
{
let
permission
=
enumerator
.
getNext
(
)
.
QueryInterface
(
Ci
.
nsIPermission
)
;
if
(
permission
.
type
=
=
"
cookie
"
&
&
permission
.
capability
=
=
Ci
.
nsICookiePermission
.
ACCESS_SESSION
)
{
await
sanitizeSessionPrincipal
(
permission
.
principal
)
;
}
}
if
(
Sanitizer
.
shouldSanitizeNewTabContainer
)
{
sanitizeNewTabSegregation
(
)
;
removePendingSanitization
(
"
newtab
-
container
"
)
;
}
if
(
Sanitizer
.
shouldSanitizeOnShutdown
)
{
removePendingSanitization
(
"
shutdown
"
)
;
Services
.
prefs
.
savePrefFile
(
null
)
;
}
}
async
function
sanitizeSessionPrincipals
(
)
{
if
(
Services
.
prefs
.
getIntPref
(
PREF_COOKIE_LIFETIME
Ci
.
nsICookieService
.
ACCEPT_NORMALLY
)
!
=
Ci
.
nsICookieService
.
ACCEPT_SESSION
)
{
return
;
}
let
principals
=
await
new
Promise
(
resolve
=
>
{
quotaManagerService
.
getUsage
(
request
=
>
{
if
(
request
.
resultCode
!
=
Cr
.
NS_OK
)
{
resolve
(
[
]
)
;
return
;
}
let
list
=
[
]
;
for
(
let
item
of
request
.
result
)
{
let
principal
=
Services
.
scriptSecurityManager
.
createCodebasePrincipalFromOrigin
(
item
.
origin
)
;
let
uri
=
principal
.
URI
;
if
(
uri
.
scheme
=
=
"
http
"
|
|
uri
.
scheme
=
=
"
https
"
|
|
uri
.
scheme
=
=
"
file
"
)
{
list
.
push
(
principal
)
;
}
}
resolve
(
list
)
;
}
)
;
}
)
.
catch
(
(
)
=
>
[
]
)
;
let
serviceWorkers
=
serviceWorkerManager
.
getAllRegistrations
(
)
;
for
(
let
i
=
0
;
i
<
serviceWorkers
.
length
;
i
+
+
)
{
let
sw
=
serviceWorkers
.
queryElementAt
(
i
Ci
.
nsIServiceWorkerRegistrationInfo
)
;
principals
.
push
(
sw
.
principal
)
;
}
await
maybeSanitizeSessionPrincipals
(
principals
)
;
}
async
function
maybeSanitizeSessionPrincipals
(
principals
)
{
let
promises
=
[
]
;
for
(
let
i
=
0
;
i
<
principals
.
length
;
+
+
i
)
{
let
p
=
Services
.
perms
.
testPermissionFromPrincipal
(
principals
[
i
]
"
cookie
"
)
;
if
(
p
!
=
Ci
.
nsICookiePermission
.
ACCESS_ALLOW
&
&
p
!
=
Ci
.
nsICookiePermission
.
ACCESS_ALLOW_FIRST_PARTY_ONLY
&
&
p
!
=
Ci
.
nsICookiePermission
.
ACCESS_LIMIT_THIRD_PARTY
)
{
promises
.
push
(
sanitizeSessionPrincipal
(
principals
[
i
]
)
)
;
}
}
return
Promise
.
all
(
promises
)
;
}
async
function
sanitizeSessionPrincipal
(
principal
)
{
return
Promise
.
all
(
[
new
Promise
(
r
=
>
{
let
req
=
quotaManagerService
.
clearStoragesForPrincipal
(
principal
null
false
)
;
req
.
callback
=
(
)
=
>
{
r
(
)
;
}
;
}
)
.
catch
(
(
)
=
>
{
}
)
ServiceWorkerCleanUp
.
removeFromPrincipal
(
principal
)
.
catch
(
(
)
=
>
{
}
)
]
)
;
}
function
sanitizeNewTabSegregation
(
)
{
let
identity
=
ContextualIdentityService
.
getPrivateIdentity
(
"
userContextIdInternal
.
thumbnail
"
)
;
if
(
identity
)
{
Services
.
obs
.
notifyObservers
(
null
"
clear
-
origin
-
attributes
-
data
"
JSON
.
stringify
(
{
userContextId
:
identity
.
userContextId
}
)
)
;
}
}
function
getItemsToClearFromPrefBranch
(
branch
)
{
branch
=
Services
.
prefs
.
getBranch
(
branch
)
;
return
Object
.
keys
(
Sanitizer
.
items
)
.
filter
(
itemName
=
>
{
try
{
return
branch
.
getBoolPref
(
itemName
)
;
}
catch
(
ex
)
{
return
false
;
}
}
)
;
}
function
addPendingSanitization
(
id
itemsToClear
options
)
{
let
pendingSanitizations
=
safeGetPendingSanitizations
(
)
;
pendingSanitizations
.
push
(
{
id
itemsToClear
options
}
)
;
Services
.
prefs
.
setStringPref
(
Sanitizer
.
PREF_PENDING_SANITIZATIONS
JSON
.
stringify
(
pendingSanitizations
)
)
;
}
function
removePendingSanitization
(
id
)
{
let
pendingSanitizations
=
safeGetPendingSanitizations
(
)
;
let
i
=
pendingSanitizations
.
findIndex
(
s
=
>
s
.
id
=
=
id
)
;
let
[
s
]
=
pendingSanitizations
.
splice
(
i
1
)
;
Services
.
prefs
.
setStringPref
(
Sanitizer
.
PREF_PENDING_SANITIZATIONS
JSON
.
stringify
(
pendingSanitizations
)
)
;
return
s
;
}
function
getAndClearPendingSanitizations
(
)
{
let
pendingSanitizations
=
safeGetPendingSanitizations
(
)
;
if
(
pendingSanitizations
.
length
)
Services
.
prefs
.
clearUserPref
(
Sanitizer
.
PREF_PENDING_SANITIZATIONS
)
;
return
pendingSanitizations
;
}
function
safeGetPendingSanitizations
(
)
{
try
{
return
JSON
.
parse
(
Services
.
prefs
.
getStringPref
(
Sanitizer
.
PREF_PENDING_SANITIZATIONS
"
[
]
"
)
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
"
Invalid
JSON
value
for
pending
sanitizations
:
"
+
ex
)
;
return
[
]
;
}
}
