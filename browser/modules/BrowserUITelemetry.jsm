"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
BrowserUITelemetry
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
AppConstants
"
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
UITelemetry
"
"
resource
:
/
/
gre
/
modules
/
UITelemetry
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
RecentWindow
"
"
resource
:
/
/
/
modules
/
RecentWindow
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
CustomizableUI
"
"
resource
:
/
/
/
modules
/
CustomizableUI
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
UITour
"
"
resource
:
/
/
/
modules
/
UITour
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
Timer
"
function
(
)
{
let
timer
=
{
}
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
timer
)
;
return
timer
;
}
)
;
const
MS_SECOND
=
1000
;
const
MS_MINUTE
=
MS_SECOND
*
60
;
const
MS_HOUR
=
MS_MINUTE
*
60
;
const
LEGACY_PANEL_PLACEMENTS
=
[
"
edit
-
controls
"
"
zoom
-
controls
"
"
new
-
window
-
button
"
"
privatebrowsing
-
button
"
"
save
-
page
-
button
"
"
print
-
button
"
"
history
-
panelmenu
"
"
fullscreen
-
button
"
"
find
-
button
"
"
preferences
-
button
"
"
add
-
ons
-
button
"
"
sync
-
button
"
"
developer
-
button
"
]
;
XPCOMUtils
.
defineLazyGetter
(
this
"
DEFAULT_AREA_PLACEMENTS
"
function
(
)
{
let
result
=
{
"
nav
-
bar
"
:
[
"
back
-
button
"
"
forward
-
button
"
"
stop
-
reload
-
button
"
"
home
-
button
"
"
urlbar
-
container
"
"
downloads
-
button
"
"
library
-
button
"
"
sidebar
-
button
"
]
"
toolbar
-
menubar
"
:
[
"
menubar
-
items
"
]
"
TabsToolbar
"
:
[
"
tabbrowser
-
tabs
"
"
new
-
tab
-
button
"
"
alltabs
-
button
"
]
"
PersonalToolbar
"
:
[
"
personal
-
bookmarks
"
]
"
widget
-
overflow
-
fixed
-
list
"
:
[
]
}
;
return
result
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
DEFAULT_AREAS
"
function
(
)
{
return
Object
.
keys
(
DEFAULT_AREA_PLACEMENTS
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
PALETTE_ITEMS
"
function
(
)
{
let
result
=
[
"
bookmarks
-
menu
-
button
"
"
search
-
container
"
"
open
-
file
-
button
"
"
developer
-
button
"
"
feed
-
button
"
"
email
-
link
-
button
"
.
.
.
LEGACY_PANEL_PLACEMENTS
"
characterencoding
-
button
"
]
;
if
(
Services
.
prefs
.
getBoolPref
(
"
privacy
.
panicButton
.
enabled
"
)
)
{
result
.
push
(
"
panic
-
button
"
)
;
}
return
result
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
DEFAULT_ITEMS
"
function
(
)
{
let
result
=
[
]
;
for
(
let
[
buttons
]
of
Object
.
entries
(
DEFAULT_AREA_PLACEMENTS
)
)
{
result
=
result
.
concat
(
buttons
)
;
}
return
result
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
ALL_BUILTIN_ITEMS
"
function
(
)
{
const
SPECIAL_CASES
=
[
"
back
-
button
"
"
forward
-
button
"
"
stop
-
button
"
"
urlbar
-
go
-
button
"
"
reload
-
button
"
"
searchbar
"
"
cut
-
button
"
"
copy
-
button
"
"
paste
-
button
"
"
zoom
-
out
-
button
"
"
zoom
-
reset
-
button
"
"
zoom
-
in
-
button
"
"
BMB_bookmarksPopup
"
"
BMB_unsortedBookmarksPopup
"
"
BMB_bookmarksToolbarPopup
"
"
search
-
go
-
button
"
"
soundplaying
-
icon
"
"
restore
-
tabs
-
button
"
]
;
return
DEFAULT_ITEMS
.
concat
(
PALETTE_ITEMS
)
.
concat
(
SPECIAL_CASES
)
;
}
)
;
const
OTHER_MOUSEUP_MONITORED_ITEMS
=
[
"
PlacesChevron
"
"
PlacesToolbarItems
"
"
menubar
-
items
"
]
;
const
MOUSEDOWN_MONITORED_ITEMS
=
[
"
PanelUI
-
menu
-
button
"
]
;
const
WINDOW_DURATION_MAP
=
new
WeakMap
(
)
;
const
BUCKET_DEFAULT
=
"
__DEFAULT__
"
;
const
BUCKET_PREFIX
=
"
bucket_
"
;
const
BUCKET_SEPARATOR
=
"
|
"
;
this
.
BrowserUITelemetry
=
{
init
(
)
{
UITelemetry
.
addSimpleMeasureFunction
(
"
toolbars
"
this
.
getToolbarMeasures
.
bind
(
this
)
)
;
UITelemetry
.
addSimpleMeasureFunction
(
"
contextmenu
"
this
.
getContextMenuInfo
.
bind
(
this
)
)
;
UITelemetry
.
addSimpleMeasureFunction
(
"
UITour
"
(
)
=
>
UITour
.
getTelemetry
(
)
)
;
UITelemetry
.
addSimpleMeasureFunction
(
"
syncstate
"
this
.
getSyncState
.
bind
(
this
)
)
;
Services
.
obs
.
addObserver
(
this
"
autocomplete
-
did
-
enter
-
text
"
)
;
CustomizableUI
.
addListener
(
this
)
;
let
browserEnum
=
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
;
while
(
browserEnum
.
hasMoreElements
(
)
)
{
this
.
_registerWindow
(
browserEnum
.
getNext
(
)
)
;
}
Services
.
obs
.
addObserver
(
this
"
browser
-
delayed
-
startup
-
finished
"
)
;
this
.
_gatherFirstWindowMeasurements
(
)
;
}
observe
(
aSubject
aTopic
aData
)
{
switch
(
aTopic
)
{
case
"
browser
-
delayed
-
startup
-
finished
"
:
this
.
_registerWindow
(
aSubject
)
;
break
;
case
"
autocomplete
-
did
-
enter
-
text
"
:
let
input
=
aSubject
.
QueryInterface
(
Ci
.
nsIAutoCompleteInput
)
;
if
(
input
&
&
input
.
id
=
=
"
urlbar
"
&
&
!
input
.
inPrivateContext
&
&
input
.
popup
.
selectedIndex
!
=
-
1
)
{
this
.
_logAwesomeBarSearchResult
(
input
.
textValue
)
;
}
break
;
}
}
_ensureObjectChain
(
aKeys
aEndWith
aRoot
)
{
let
current
=
aRoot
;
let
parent
=
null
;
aKeys
.
unshift
(
this
.
_bucket
)
;
for
(
let
[
i
key
]
of
aKeys
.
entries
(
)
)
{
if
(
!
(
key
in
current
)
)
{
if
(
i
=
=
aKeys
.
length
-
1
)
{
current
[
key
]
=
aEndWith
;
}
else
{
current
[
key
]
=
{
}
;
}
}
parent
=
current
;
current
=
current
[
key
]
;
}
return
parent
;
}
_countableEvents
:
{
}
_countEvent
(
aKeyArray
root
=
this
.
_countableEvents
)
{
let
countObject
=
this
.
_ensureObjectChain
(
aKeyArray
0
root
)
;
let
lastItemKey
=
aKeyArray
[
aKeyArray
.
length
-
1
]
;
countObject
[
lastItemKey
]
+
+
;
}
_countMouseUpEvent
(
aCategory
aAction
aButton
)
{
const
BUTTONS
=
[
"
left
"
"
middle
"
"
right
"
]
;
let
buttonKey
=
BUTTONS
[
aButton
]
;
if
(
buttonKey
)
{
this
.
_countEvent
(
[
aCategory
aAction
buttonKey
]
)
;
}
}
_firstWindowMeasurements
:
null
_gatherFirstWindowMeasurements
(
)
{
Services
.
search
.
init
(
rv
=
>
{
let
win
=
RecentWindow
.
getMostRecentBrowserWindow
(
{
private
:
false
allowPopups
:
false
}
)
;
this
.
_firstWindowMeasurements
=
win
?
this
.
_getWindowMeasurements
(
win
rv
)
:
{
}
;
}
)
;
}
_registerWindow
(
aWindow
)
{
aWindow
.
addEventListener
(
"
unload
"
this
)
;
let
document
=
aWindow
.
document
;
for
(
let
areaID
of
CustomizableUI
.
areas
)
{
let
areaNode
=
document
.
getElementById
(
areaID
)
;
if
(
areaNode
)
{
(
areaNode
.
customizationTarget
|
|
areaNode
)
.
addEventListener
(
"
mouseup
"
this
)
;
}
}
for
(
let
itemID
of
OTHER_MOUSEUP_MONITORED_ITEMS
)
{
let
item
=
document
.
getElementById
(
itemID
)
;
if
(
item
)
{
item
.
addEventListener
(
"
mouseup
"
this
)
;
}
}
for
(
let
itemID
of
MOUSEDOWN_MONITORED_ITEMS
)
{
let
item
=
document
.
getElementById
(
itemID
)
;
if
(
item
)
{
item
.
addEventListener
(
"
mousedown
"
this
)
;
}
}
WINDOW_DURATION_MAP
.
set
(
aWindow
{
}
)
;
}
_unregisterWindow
(
aWindow
)
{
aWindow
.
removeEventListener
(
"
unload
"
this
)
;
let
document
=
aWindow
.
document
;
for
(
let
areaID
of
CustomizableUI
.
areas
)
{
let
areaNode
=
document
.
getElementById
(
areaID
)
;
if
(
areaNode
)
{
(
areaNode
.
customizationTarget
|
|
areaNode
)
.
removeEventListener
(
"
mouseup
"
this
)
;
}
}
for
(
let
itemID
of
OTHER_MOUSEUP_MONITORED_ITEMS
)
{
let
item
=
document
.
getElementById
(
itemID
)
;
if
(
item
)
{
item
.
removeEventListener
(
"
mouseup
"
this
)
;
}
}
for
(
let
itemID
of
MOUSEDOWN_MONITORED_ITEMS
)
{
let
item
=
document
.
getElementById
(
itemID
)
;
if
(
item
)
{
item
.
removeEventListener
(
"
mousedown
"
this
)
;
}
}
}
handleEvent
(
aEvent
)
{
switch
(
aEvent
.
type
)
{
case
"
unload
"
:
this
.
_unregisterWindow
(
aEvent
.
currentTarget
)
;
break
;
case
"
mouseup
"
:
this
.
_handleMouseUp
(
aEvent
)
;
break
;
case
"
mousedown
"
:
this
.
_handleMouseDown
(
aEvent
)
;
break
;
}
}
_handleMouseUp
(
aEvent
)
{
let
targetID
=
aEvent
.
currentTarget
.
id
;
switch
(
targetID
)
{
case
"
PlacesToolbarItems
"
:
this
.
_PlacesToolbarItemsMouseUp
(
aEvent
)
;
break
;
case
"
PlacesChevron
"
:
this
.
_PlacesChevronMouseUp
(
aEvent
)
;
break
;
case
"
menubar
-
items
"
:
this
.
_menubarMouseUp
(
aEvent
)
;
break
;
default
:
this
.
_checkForBuiltinItem
(
aEvent
)
;
}
}
_handleMouseDown
(
aEvent
)
{
if
(
aEvent
.
currentTarget
.
id
=
=
"
PanelUI
-
menu
-
button
"
)
{
this
.
_countMouseUpEvent
(
"
click
-
menu
-
button
"
"
button
"
aEvent
.
button
)
;
}
}
_PlacesChevronMouseUp
(
aEvent
)
{
let
target
=
aEvent
.
originalTarget
;
let
result
=
target
.
id
=
=
"
PlacesChevron
"
?
"
chevron
"
:
"
overflowed
-
item
"
;
this
.
_countMouseUpEvent
(
"
click
-
bookmarks
-
bar
"
result
aEvent
.
button
)
;
}
_PlacesToolbarItemsMouseUp
(
aEvent
)
{
let
target
=
aEvent
.
originalTarget
;
if
(
!
target
.
classList
.
contains
(
"
bookmark
-
item
"
)
)
{
return
;
}
let
result
=
target
.
hasAttribute
(
"
container
"
)
?
"
container
"
:
"
item
"
;
this
.
_countMouseUpEvent
(
"
click
-
bookmarks
-
bar
"
result
aEvent
.
button
)
;
}
_menubarMouseUp
(
aEvent
)
{
let
target
=
aEvent
.
originalTarget
;
let
tag
=
target
.
localName
;
let
result
=
(
tag
=
=
"
menu
"
|
|
tag
=
=
"
menuitem
"
)
?
tag
:
"
other
"
;
this
.
_countMouseUpEvent
(
"
click
-
menubar
"
result
aEvent
.
button
)
;
}
_bookmarksMenuButtonMouseUp
(
aEvent
)
{
let
bookmarksWidget
=
CustomizableUI
.
getWidget
(
"
bookmarks
-
menu
-
button
"
)
;
if
(
bookmarksWidget
.
areaType
=
=
CustomizableUI
.
TYPE_MENU_PANEL
)
{
this
.
_countMouseUpEvent
(
"
click
-
bookmarks
-
menu
-
button
"
"
in
-
panel
"
aEvent
.
button
)
;
}
else
{
let
clickedItem
=
aEvent
.
originalTarget
;
let
action
=
"
menu
"
;
if
(
clickedItem
.
getAttribute
(
"
anonid
"
)
=
=
"
button
"
)
{
let
bookmarksMenuNode
=
bookmarksWidget
.
forWindow
(
aEvent
.
target
.
ownerGlobal
)
.
node
;
action
=
bookmarksMenuNode
.
hasAttribute
(
"
starred
"
)
?
"
edit
"
:
"
add
"
;
}
this
.
_countMouseUpEvent
(
"
click
-
bookmarks
-
menu
-
button
"
action
aEvent
.
button
)
;
}
}
_checkForBuiltinItem
(
aEvent
)
{
let
item
=
aEvent
.
originalTarget
;
if
(
item
.
id
=
=
"
privatebrowsing
-
button
"
)
{
return
;
}
if
(
item
.
id
=
=
"
bookmarks
-
menu
-
button
"
|
|
getIDBasedOnFirstIDedAncestor
(
item
)
=
=
"
bookmarks
-
menu
-
button
"
)
{
this
.
_bookmarksMenuButtonMouseUp
(
aEvent
)
;
return
;
}
if
(
ALL_BUILTIN_ITEMS
.
includes
(
item
.
id
)
)
{
this
.
_countMouseUpEvent
(
"
click
-
builtin
-
item
"
item
.
id
aEvent
.
button
)
;
return
;
}
if
(
ALL_BUILTIN_ITEMS
.
includes
(
item
.
getAttribute
(
"
anonid
"
)
)
)
{
this
.
_countMouseUpEvent
(
"
click
-
builtin
-
item
"
item
.
getAttribute
(
"
anonid
"
)
aEvent
.
button
)
;
return
;
}
let
candidate
=
getIDBasedOnFirstIDedAncestor
(
item
)
;
if
(
ALL_BUILTIN_ITEMS
.
includes
(
candidate
)
)
{
this
.
_countMouseUpEvent
(
"
click
-
builtin
-
item
"
candidate
aEvent
.
button
)
;
}
}
_getWindowMeasurements
(
aWindow
searchResult
)
{
let
document
=
aWindow
.
document
;
let
result
=
{
}
;
result
.
sizemode
=
document
.
documentElement
.
getAttribute
(
"
sizemode
"
)
;
let
bookmarksBar
=
document
.
getElementById
(
"
PersonalToolbar
"
)
;
result
.
bookmarksBarEnabled
=
bookmarksBar
&
&
!
bookmarksBar
.
collapsed
;
let
menuBar
=
document
.
getElementById
(
"
toolbar
-
menubar
"
)
;
result
.
menuBarEnabled
=
menuBar
&
&
Services
.
appinfo
.
OS
!
=
"
Darwin
"
&
&
menuBar
.
getAttribute
(
"
autohide
"
)
!
=
"
true
"
;
result
.
titleBarEnabled
=
!
Services
.
prefs
.
getBoolPref
(
"
browser
.
tabs
.
drawInTitlebar
"
)
;
let
defaultKept
=
[
]
;
let
defaultMoved
=
[
]
;
let
nondefaultAdded
=
[
]
;
for
(
let
areaID
of
CustomizableUI
.
areas
)
{
let
items
=
CustomizableUI
.
getWidgetIdsInArea
(
areaID
)
;
for
(
let
item
of
items
)
{
if
(
DEFAULT_ITEMS
.
includes
(
item
)
)
{
if
(
Array
.
isArray
(
DEFAULT_AREA_PLACEMENTS
[
areaID
]
)
&
&
DEFAULT_AREA_PLACEMENTS
[
areaID
]
.
includes
(
item
)
)
{
defaultKept
.
push
(
item
)
;
}
else
{
defaultMoved
.
push
(
item
)
;
}
}
else
if
(
PALETTE_ITEMS
.
includes
(
item
)
)
{
nondefaultAdded
.
push
(
item
)
;
}
}
}
let
paletteItems
=
CustomizableUI
.
getUnusedWidgets
(
aWindow
.
gNavToolbox
.
palette
)
;
let
defaultRemoved
=
[
]
;
for
(
let
item
of
paletteItems
)
{
if
(
DEFAULT_ITEMS
.
includes
(
item
.
id
)
)
{
defaultRemoved
.
push
(
item
.
id
)
;
}
}
result
.
defaultKept
=
defaultKept
;
result
.
defaultMoved
=
defaultMoved
;
result
.
nondefaultAdded
=
nondefaultAdded
;
result
.
defaultRemoved
=
defaultRemoved
;
let
addonToolbars
=
0
;
let
toolbars
=
document
.
querySelectorAll
(
"
toolbar
[
customizable
=
true
]
"
)
;
for
(
let
toolbar
of
toolbars
)
{
if
(
!
DEFAULT_AREAS
.
includes
(
toolbar
.
id
)
)
{
addonToolbars
+
+
;
}
}
result
.
addonToolbars
=
addonToolbars
;
let
winEnumerator
=
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
;
let
visibleTabs
=
[
]
;
let
hiddenTabs
=
[
]
;
while
(
winEnumerator
.
hasMoreElements
(
)
)
{
let
someWin
=
winEnumerator
.
getNext
(
)
;
if
(
someWin
.
gBrowser
)
{
let
visibleTabsNum
=
someWin
.
gBrowser
.
visibleTabs
.
length
;
visibleTabs
.
push
(
visibleTabsNum
)
;
hiddenTabs
.
push
(
someWin
.
gBrowser
.
tabs
.
length
-
visibleTabsNum
)
;
}
}
result
.
visibleTabs
=
visibleTabs
;
result
.
hiddenTabs
=
hiddenTabs
;
if
(
Components
.
isSuccessCode
(
searchResult
)
)
{
result
.
currentSearchEngine
=
Services
.
search
.
currentEngine
.
name
;
}
return
result
;
}
getToolbarMeasures
(
)
{
let
result
=
this
.
_firstWindowMeasurements
|
|
{
}
;
result
.
countableEvents
=
this
.
_countableEvents
;
result
.
durations
=
this
.
_durations
;
return
result
;
}
getSyncState
(
)
{
let
result
=
{
}
;
for
(
let
sub
of
[
"
desktop
"
"
mobile
"
]
)
{
let
count
=
Services
.
prefs
.
getIntPref
(
"
services
.
sync
.
clients
.
devices
.
"
+
sub
0
)
;
result
[
sub
]
=
count
;
}
return
result
;
}
countCustomizationEvent
(
aEventType
)
{
this
.
_countEvent
(
[
"
customize
"
aEventType
]
)
;
}
countSearchEvent
(
source
query
selection
)
{
this
.
_countEvent
(
[
"
search
"
source
]
)
;
if
(
(
/
^
[
a
-
zA
-
Z
]
+
:
[
^
\
/
\
\
]
/
)
.
test
(
query
)
)
{
this
.
_countEvent
(
[
"
search
"
"
urlbar
-
keyword
"
]
)
;
}
if
(
selection
)
{
this
.
_countEvent
(
[
"
search
"
"
selection
"
source
selection
.
index
selection
.
kind
]
)
;
}
}
countOneoffSearchEvent
(
id
type
where
)
{
this
.
_countEvent
(
[
"
search
-
oneoff
"
id
type
where
]
)
;
}
countSearchSettingsEvent
(
source
)
{
this
.
_countEvent
(
[
"
click
-
builtin
-
item
"
source
"
search
-
settings
"
]
)
;
}
countPanicEvent
(
timeId
)
{
this
.
_countEvent
(
[
"
forget
-
button
"
timeId
]
)
;
}
countTabMutingEvent
(
action
reason
)
{
this
.
_countEvent
(
[
"
tab
-
audio
-
control
"
action
reason
|
|
"
no
reason
given
"
]
)
;
}
countSyncedTabEvent
(
what
where
)
{
this
.
_countEvent
(
[
"
synced
-
tabs
"
what
where
]
)
;
}
countSidebarEvent
(
sidebarID
action
)
{
this
.
_countEvent
(
[
"
sidebar
"
sidebarID
action
]
)
;
}
_logAwesomeBarSearchResult
(
url
)
{
let
spec
=
Services
.
search
.
parseSubmissionURL
(
url
)
;
if
(
spec
.
engine
)
{
let
matchedEngine
=
"
default
"
;
if
(
spec
.
engine
.
name
!
=
=
Services
.
search
.
currentEngine
.
name
)
{
matchedEngine
=
"
other
"
;
}
this
.
countSearchEvent
(
"
autocomplete
-
"
+
matchedEngine
)
;
}
}
_durations
:
{
customization
:
[
]
}
onCustomizeStart
(
aWindow
)
{
this
.
_countEvent
(
[
"
customize
"
"
start
"
]
)
;
let
durationMap
=
WINDOW_DURATION_MAP
.
get
(
aWindow
)
;
if
(
!
durationMap
)
{
durationMap
=
{
}
;
WINDOW_DURATION_MAP
.
set
(
aWindow
durationMap
)
;
}
durationMap
.
customization
=
{
start
:
aWindow
.
performance
.
now
(
)
bucket
:
this
.
_bucket
}
;
}
onCustomizeEnd
(
aWindow
)
{
let
durationMap
=
WINDOW_DURATION_MAP
.
get
(
aWindow
)
;
if
(
durationMap
&
&
"
customization
"
in
durationMap
)
{
let
duration
=
aWindow
.
performance
.
now
(
)
-
durationMap
.
customization
.
start
;
this
.
_durations
.
customization
.
push
(
{
duration
bucket
:
durationMap
.
customization
.
bucket
}
)
;
delete
durationMap
.
customization
;
}
}
_contextMenuItemWhitelist
:
new
Set
(
[
"
close
-
without
-
interaction
"
"
custom
-
page
-
item
"
"
unknown
"
"
navigation
"
"
back
"
"
forward
"
"
reload
"
"
stop
"
"
bookmarkpage
"
"
spell
-
no
-
suggestions
"
"
spell
-
add
-
to
-
dictionary
"
"
spell
-
undo
-
add
-
to
-
dictionary
"
"
openlinkincurrent
"
"
openlinkintab
"
"
openlink
"
"
bookmarklink
"
"
savelink
"
"
marklinkMenu
"
"
copyemail
"
"
copylink
"
"
media
-
play
"
"
media
-
pause
"
"
media
-
mute
"
"
media
-
unmute
"
"
media
-
playbackrate
"
"
media
-
playbackrate
-
050x
"
"
media
-
playbackrate
-
100x
"
"
media
-
playbackrate
-
125x
"
"
media
-
playbackrate
-
150x
"
"
media
-
playbackrate
-
200x
"
"
media
-
showcontrols
"
"
media
-
hidecontrols
"
"
video
-
fullscreen
"
"
leave
-
dom
-
fullscreen
"
"
reloadimage
"
"
viewimage
"
"
viewvideo
"
"
copyimage
-
contents
"
"
copyimage
"
"
copyvideourl
"
"
copyaudiourl
"
"
saveimage
"
"
sendimage
"
"
setDesktopBackground
"
"
viewimageinfo
"
"
viewimagedesc
"
"
savevideo
"
"
saveaudio
"
"
video
-
saveimage
"
"
sendvideo
"
"
sendaudio
"
"
ctp
-
play
"
"
ctp
-
hide
"
"
savepage
"
"
pocket
"
"
markpageMenu
"
"
viewbgimage
"
"
undo
"
"
cut
"
"
copy
"
"
paste
"
"
delete
"
"
selectall
"
"
keywordfield
"
"
searchselect
"
"
frame
"
"
showonlythisframe
"
"
openframeintab
"
"
openframe
"
"
reloadframe
"
"
bookmarkframe
"
"
saveframe
"
"
printframe
"
"
viewframesource
"
"
viewframeinfo
"
"
viewpartialsource
-
selection
"
"
viewpartialsource
-
mathml
"
"
viewsource
"
"
viewinfo
"
"
spell
-
check
-
enabled
"
"
spell
-
add
-
dictionaries
-
main
"
"
spell
-
dictionaries
"
"
spell
-
dictionaries
-
menu
"
"
spell
-
add
-
dictionaries
"
"
bidi
-
text
-
direction
-
toggle
"
"
bidi
-
page
-
direction
-
toggle
"
"
inspect
"
"
media
-
eme
-
learn
-
more
"
]
)
_contextMenuInteractions
:
{
}
registerContextMenuInteraction
(
keys
itemID
)
{
if
(
itemID
)
{
if
(
itemID
=
=
"
openlinkprivate
"
)
{
return
;
}
if
(
!
this
.
_contextMenuItemWhitelist
.
has
(
itemID
)
)
{
itemID
=
"
other
-
item
"
;
}
keys
.
push
(
itemID
)
;
}
this
.
_countEvent
(
keys
this
.
_contextMenuInteractions
)
;
}
getContextMenuInfo
(
)
{
return
this
.
_contextMenuInteractions
;
}
_bucket
:
BUCKET_DEFAULT
_bucketTimer
:
null
get
BUCKET_DEFAULT
(
)
{
return
BUCKET_DEFAULT
;
}
get
BUCKET_PREFIX
(
)
{
return
BUCKET_PREFIX
;
}
get
BUCKET_SEPARATOR
(
)
{
return
BUCKET_SEPARATOR
;
}
get
currentBucket
(
)
{
return
this
.
_bucket
;
}
setBucket
(
aName
)
{
if
(
this
.
_bucketTimer
)
{
Timer
.
clearTimeout
(
this
.
_bucketTimer
)
;
this
.
_bucketTimer
=
null
;
}
if
(
aName
)
this
.
_bucket
=
BUCKET_PREFIX
+
aName
;
else
this
.
_bucket
=
BUCKET_DEFAULT
;
}
setExpiringBucket
(
aName
aTimeSteps
aTimeOffset
=
0
)
{
if
(
aTimeSteps
.
length
=
=
=
0
)
{
this
.
setBucket
(
null
)
;
return
;
}
if
(
this
.
_bucketTimer
)
{
Timer
.
clearTimeout
(
this
.
_bucketTimer
)
;
this
.
_bucketTimer
=
null
;
}
let
steps
=
[
.
.
.
aTimeSteps
]
;
let
msec
=
steps
.
shift
(
)
;
let
postfix
=
this
.
_toTimeStr
(
msec
)
;
this
.
setBucket
(
aName
+
BUCKET_SEPARATOR
+
postfix
)
;
this
.
_bucketTimer
=
Timer
.
setTimeout
(
(
)
=
>
{
this
.
_bucketTimer
=
null
;
this
.
setExpiringBucket
(
aName
steps
aTimeOffset
+
msec
)
;
}
msec
-
aTimeOffset
)
;
}
_toTimeStr
(
aTimeMS
)
{
let
timeStr
=
"
"
;
function
reduce
(
aUnitLength
aSymbol
)
{
if
(
aTimeMS
>
=
aUnitLength
)
{
let
units
=
Math
.
floor
(
aTimeMS
/
aUnitLength
)
;
aTimeMS
=
aTimeMS
-
(
units
*
aUnitLength
)
;
timeStr
+
=
units
+
aSymbol
;
}
}
reduce
(
MS_HOUR
"
h
"
)
;
reduce
(
MS_MINUTE
"
m
"
)
;
reduce
(
MS_SECOND
"
s
"
)
;
reduce
(
1
"
ms
"
)
;
return
timeStr
;
}
}
;
function
getIDBasedOnFirstIDedAncestor
(
aNode
)
{
while
(
!
aNode
.
id
)
{
aNode
=
aNode
.
parentNode
;
if
(
!
aNode
)
{
return
null
;
}
}
return
aNode
.
id
;
}
