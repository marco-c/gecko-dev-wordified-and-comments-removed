"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
ContentLinkHandler
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
Blob
"
"
FileReader
"
]
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Feeds
"
"
resource
:
/
/
/
modules
/
Feeds
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
NetUtil
"
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
DeferredTask
"
"
resource
:
/
/
gre
/
modules
/
DeferredTask
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PromiseUtils
"
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
)
;
const
SIZES_TELEMETRY_ENUM
=
{
NO_SIZES
:
0
ANY
:
1
DIMENSION
:
2
INVALID
:
3
}
;
const
FAVICON_PARSING_TIMEOUT
=
100
;
const
FAVICON_RICH_ICON_MIN_WIDTH
=
96
;
const
PREFERRED_WIDTH
=
16
;
const
LOCAL_FAVICON_SCHEMES
=
[
"
chrome
"
"
about
"
"
resource
"
"
data
"
]
;
const
MAX_FAVICON_EXPIRATION
=
7
*
24
*
60
*
60
*
1000
;
const
TYPE_ICO
=
"
image
/
x
-
icon
"
;
const
TYPE_SVG
=
"
image
/
svg
+
xml
"
;
function
promiseBlobAsDataURL
(
blob
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
reader
=
new
FileReader
(
)
;
reader
.
addEventListener
(
"
load
"
(
)
=
>
resolve
(
reader
.
result
)
)
;
reader
.
addEventListener
(
"
error
"
reject
)
;
reader
.
readAsDataURL
(
blob
)
;
}
)
;
}
function
promiseBlobAsOctets
(
blob
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
reader
=
new
FileReader
(
)
;
reader
.
addEventListener
(
"
load
"
(
)
=
>
{
resolve
(
Array
.
from
(
reader
.
result
)
.
map
(
c
=
>
c
.
charCodeAt
(
0
)
)
)
;
}
)
;
reader
.
addEventListener
(
"
error
"
reject
)
;
reader
.
readAsBinaryString
(
blob
)
;
}
)
;
}
class
FaviconLoad
{
constructor
(
iconInfo
)
{
this
.
buffers
=
[
]
;
this
.
icon
=
iconInfo
;
this
.
channel
=
NetUtil
.
newChannel
(
{
uri
:
iconInfo
.
iconUri
loadingNode
:
iconInfo
.
node
loadingPrincipal
:
iconInfo
.
node
.
nodePrincipal
triggeringPrincipal
:
iconInfo
.
node
.
nodePrincipal
contentPolicyType
:
Ci
.
nsIContentPolicy
.
TYPE_INTERNAL_IMAGE_FAVICON
securityFlags
:
Ci
.
nsILoadInfo
.
SEC_ALLOW_CROSS_ORIGIN_DATA_INHERITS
|
Ci
.
nsILoadInfo
.
SEC_ALLOW_CHROME
|
Ci
.
nsILoadInfo
.
SEC_DISALLOW_SCRIPT
}
)
;
this
.
channel
.
loadFlags
|
=
Ci
.
nsIRequest
.
LOAD_BACKGROUND
;
this
.
channel
.
loadGroup
=
iconInfo
.
node
.
ownerGlobal
.
document
.
documentLoadGroup
;
this
.
channel
.
notificationCallbacks
=
this
;
if
(
Services
.
prefs
.
getBoolPref
(
"
network
.
http
.
tailing
.
enabled
"
true
)
&
&
this
.
channel
instanceof
Ci
.
nsIClassOfService
)
{
this
.
channel
.
addClassFlags
(
Ci
.
nsIClassOfService
.
Tail
|
Ci
.
nsIClassOfService
.
Throttleable
)
;
}
}
load
(
)
{
this
.
_deferred
=
PromiseUtils
.
defer
(
)
;
this
.
_deferred
.
promise
.
then
(
(
)
=
>
this
.
channel
=
null
(
)
=
>
this
.
channel
=
null
)
;
try
{
this
.
channel
.
asyncOpen2
(
this
)
;
}
catch
(
e
)
{
this
.
_deferred
.
reject
(
e
)
;
}
return
this
.
_deferred
.
promise
;
}
cancel
(
)
{
if
(
!
this
.
channel
)
{
return
;
}
this
.
channel
.
cancel
(
Cr
.
NS_BINDING_ABORTED
)
;
}
onStartRequest
(
request
context
)
{
}
onDataAvailable
(
request
context
inputStream
offset
count
)
{
let
data
=
NetUtil
.
readInputStreamToString
(
inputStream
count
)
;
this
.
buffers
.
push
(
Uint8Array
.
from
(
data
c
=
>
c
.
charCodeAt
(
0
)
)
)
;
}
asyncOnChannelRedirect
(
oldChannel
newChannel
flags
callback
)
{
if
(
oldChannel
=
=
this
.
channel
)
{
this
.
channel
=
newChannel
;
}
callback
.
onRedirectVerifyCallback
(
Cr
.
NS_OK
)
;
}
async
onStopRequest
(
request
context
statusCode
)
{
if
(
request
!
=
this
.
channel
)
{
return
;
}
if
(
!
Components
.
isSuccessCode
(
statusCode
)
)
{
if
(
statusCode
=
=
Cr
.
NS_BINDING_ABORTED
)
{
this
.
_deferred
.
reject
(
Components
.
Exception
(
Favicon
load
from
{
this
.
icon
.
iconUri
.
spec
}
was
cancelled
.
statusCode
)
)
;
}
else
{
this
.
_deferred
.
reject
(
Components
.
Exception
(
Favicon
at
"
{
this
.
icon
.
iconUri
.
spec
}
"
failed
to
load
.
statusCode
)
)
;
}
return
;
}
if
(
this
.
channel
instanceof
Ci
.
nsIHttpChannel
)
{
if
(
!
this
.
channel
.
requestSucceeded
)
{
this
.
_deferred
.
reject
(
Components
.
Exception
(
Favicon
at
"
{
this
.
icon
.
iconUri
.
spec
}
"
failed
to
load
:
{
this
.
channel
.
responseStatusText
}
.
Cr
.
NS_ERROR_FAILURE
)
)
;
return
;
}
}
let
expiration
=
Date
.
now
(
)
+
MAX_FAVICON_EXPIRATION
;
if
(
this
.
channel
instanceof
Ci
.
nsICacheInfoChannel
)
{
try
{
expiration
=
Math
.
min
(
this
.
channel
.
cacheTokenExpirationTime
*
1000
expiration
)
;
}
catch
(
e
)
{
}
}
try
{
let
type
=
this
.
channel
.
contentType
;
let
blob
=
new
Blob
(
this
.
buffers
{
type
}
)
;
if
(
type
!
=
"
image
/
svg
+
xml
"
)
{
let
octets
=
await
promiseBlobAsOctets
(
blob
)
;
let
sniffer
=
Cc
[
"
mozilla
.
org
/
image
/
loader
;
1
"
]
.
createInstance
(
Ci
.
nsIContentSniffer
)
;
type
=
sniffer
.
getMIMETypeFromContent
(
this
.
channel
octets
octets
.
length
)
;
if
(
!
type
)
{
throw
Components
.
Exception
(
Favicon
at
"
{
this
.
icon
.
iconUri
.
spec
}
"
did
not
match
a
known
mimetype
.
Cr
.
NS_ERROR_FAILURE
)
;
}
blob
=
blob
.
slice
(
0
blob
.
size
type
)
;
}
let
dataURL
=
await
promiseBlobAsDataURL
(
blob
)
;
this
.
_deferred
.
resolve
(
{
expiration
dataURL
}
)
;
}
catch
(
e
)
{
this
.
_deferred
.
reject
(
e
)
;
}
}
getInterface
(
iid
)
{
if
(
iid
.
equals
(
Ci
.
nsIChannelEventSink
)
)
{
return
this
;
}
throw
Cr
.
NS_ERROR_NO_INTERFACE
;
}
}
function
extractIconSize
(
aSizes
)
{
let
width
=
-
1
;
let
sizesType
;
const
re
=
/
^
(
[
1
-
9
]
[
0
-
9
]
*
)
x
[
1
-
9
]
[
0
-
9
]
*
/
i
;
if
(
aSizes
.
length
)
{
for
(
let
size
of
aSizes
)
{
if
(
size
.
toLowerCase
(
)
=
=
"
any
"
)
{
sizesType
=
SIZES_TELEMETRY_ENUM
.
ANY
;
break
;
}
else
{
let
values
=
re
.
exec
(
size
)
;
if
(
values
&
&
values
.
length
>
1
)
{
sizesType
=
SIZES_TELEMETRY_ENUM
.
DIMENSION
;
width
=
parseInt
(
values
[
1
]
)
;
break
;
}
else
{
sizesType
=
SIZES_TELEMETRY_ENUM
.
INVALID
;
break
;
}
}
}
}
else
{
sizesType
=
SIZES_TELEMETRY_ENUM
.
NO_SIZES
;
}
Services
.
telemetry
.
getHistogramById
(
"
LINK_ICON_SIZES_ATTR_USAGE
"
)
.
add
(
sizesType
)
;
if
(
width
>
0
)
Services
.
telemetry
.
getHistogramById
(
"
LINK_ICON_SIZES_ATTR_DIMENSION
"
)
.
add
(
width
)
;
return
width
;
}
function
getLinkIconURI
(
aLink
)
{
let
targetDoc
=
aLink
.
ownerDocument
;
let
uri
=
Services
.
io
.
newURI
(
aLink
.
href
targetDoc
.
characterSet
)
;
try
{
uri
=
uri
.
mutate
(
)
.
setUserPass
(
"
"
)
.
finalize
(
)
;
}
catch
(
e
)
{
}
return
uri
;
}
function
guessType
(
icon
)
{
if
(
!
icon
)
{
return
"
"
;
}
if
(
!
icon
.
type
)
{
let
extension
=
icon
.
iconUri
.
filePath
.
split
(
"
.
"
)
.
pop
(
)
;
switch
(
extension
)
{
case
"
ico
"
:
return
TYPE_ICO
;
case
"
svg
"
:
return
TYPE_SVG
;
}
}
return
icon
.
type
=
=
"
image
/
vnd
.
microsoft
.
icon
"
?
TYPE_ICO
:
icon
.
type
|
|
"
"
;
}
function
selectIcons
(
document
iconInfos
preferredWidth
)
{
if
(
iconInfos
.
length
=
=
0
)
{
return
{
richIcon
:
null
tabIcon
:
null
}
;
}
let
preferredIcon
;
let
bestSizedIcon
;
let
defaultIcon
;
let
largestRichIcon
;
for
(
let
icon
of
iconInfos
)
{
if
(
!
icon
.
isRichIcon
)
{
if
(
guessType
(
icon
)
=
=
TYPE_SVG
)
{
preferredIcon
=
icon
;
}
else
if
(
icon
.
width
=
=
preferredWidth
&
&
guessType
(
preferredIcon
)
!
=
TYPE_SVG
)
{
preferredIcon
=
icon
;
}
else
if
(
guessType
(
icon
)
=
=
TYPE_ICO
&
&
(
!
preferredIcon
|
|
guessType
(
preferredIcon
)
=
=
TYPE_ICO
)
)
{
preferredIcon
=
icon
;
}
if
(
icon
.
width
>
=
preferredWidth
&
&
(
!
bestSizedIcon
|
|
bestSizedIcon
.
width
>
=
icon
.
width
)
)
{
bestSizedIcon
=
icon
;
}
}
if
(
icon
.
isRichIcon
|
|
icon
.
width
>
=
FAVICON_RICH_ICON_MIN_WIDTH
)
{
if
(
!
largestRichIcon
|
|
largestRichIcon
.
width
<
icon
.
width
)
{
largestRichIcon
=
icon
;
}
}
else
{
defaultIcon
=
icon
;
}
}
let
tabIcon
=
null
;
if
(
preferredIcon
)
{
tabIcon
=
preferredIcon
;
}
else
if
(
bestSizedIcon
)
{
tabIcon
=
bestSizedIcon
;
}
else
if
(
defaultIcon
)
{
tabIcon
=
defaultIcon
;
}
return
{
richIcon
:
largestRichIcon
tabIcon
}
;
}
function
makeFaviconFromLink
(
aLink
aIsRichIcon
)
{
let
iconUri
=
getLinkIconURI
(
aLink
)
;
if
(
!
iconUri
)
return
null
;
let
width
=
extractIconSize
(
aLink
.
sizes
)
;
return
{
iconUri
width
isRichIcon
:
aIsRichIcon
type
:
aLink
.
type
node
:
aLink
}
;
}
class
IconLoader
{
constructor
(
chromeGlobal
)
{
this
.
chromeGlobal
=
chromeGlobal
;
}
async
load
(
iconInfo
)
{
if
(
this
.
_loader
)
{
this
.
_loader
.
cancel
(
)
;
}
if
(
LOCAL_FAVICON_SCHEMES
.
includes
(
iconInfo
.
iconUri
.
scheme
)
)
{
this
.
chromeGlobal
.
sendAsyncMessage
(
"
Link
:
SetIcon
"
{
originalURL
:
iconInfo
.
iconUri
.
spec
canUseForTab
:
!
iconInfo
.
isRichIcon
expiration
:
undefined
iconURL
:
iconInfo
.
iconUri
.
spec
}
)
;
return
;
}
try
{
this
.
_loader
=
new
FaviconLoad
(
iconInfo
)
;
let
{
dataURL
expiration
}
=
await
this
.
_loader
.
load
(
)
;
this
.
chromeGlobal
.
sendAsyncMessage
(
"
Link
:
SetIcon
"
{
originalURL
:
iconInfo
.
iconUri
.
spec
canUseForTab
:
!
iconInfo
.
isRichIcon
expiration
iconURL
:
dataURL
}
)
;
}
catch
(
e
)
{
if
(
e
.
resultCode
!
=
Cr
.
NS_BINDING_ABORTED
)
{
Cu
.
reportError
(
e
)
;
this
.
chromeGlobal
.
sendAsyncMessage
(
"
Link
:
SetFailedIcon
"
{
originalURL
:
iconInfo
.
iconUri
.
spec
canUseForTab
:
!
iconInfo
.
isRichIcon
}
)
;
}
}
finally
{
this
.
_loader
=
null
;
}
}
cancel
(
)
{
if
(
!
this
.
_loader
)
{
return
;
}
this
.
_loader
.
cancel
(
)
;
this
.
_loader
=
null
;
}
}
class
ContentLinkHandler
{
constructor
(
chromeGlobal
)
{
this
.
chromeGlobal
=
chromeGlobal
;
this
.
iconInfos
=
[
]
;
this
.
seenTabIcon
=
false
;
chromeGlobal
.
addEventListener
(
"
DOMLinkAdded
"
this
)
;
chromeGlobal
.
addEventListener
(
"
DOMLinkChanged
"
this
)
;
chromeGlobal
.
addEventListener
(
"
pageshow
"
this
)
;
chromeGlobal
.
addEventListener
(
"
pagehide
"
this
)
;
this
.
richIconLoader
=
new
IconLoader
(
chromeGlobal
)
;
this
.
tabIconLoader
=
new
IconLoader
(
chromeGlobal
)
;
this
.
iconTask
=
new
DeferredTask
(
(
)
=
>
this
.
loadIcons
(
)
FAVICON_PARSING_TIMEOUT
)
;
}
loadIcons
(
)
{
let
preferredWidth
=
PREFERRED_WIDTH
*
Math
.
ceil
(
this
.
chromeGlobal
.
content
.
devicePixelRatio
)
;
let
{
richIcon
tabIcon
}
=
selectIcons
(
this
.
chromeGlobal
.
content
.
document
this
.
iconInfos
preferredWidth
)
;
this
.
iconInfos
=
[
]
;
if
(
richIcon
)
{
this
.
richIconLoader
.
load
(
richIcon
)
;
}
if
(
tabIcon
)
{
this
.
tabIconLoader
.
load
(
tabIcon
)
;
}
}
addIcon
(
iconInfo
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
"
browser
.
chrome
.
site_icons
"
true
)
)
{
return
;
}
if
(
!
iconInfo
.
isRichIcon
)
{
this
.
seenTabIcon
=
true
;
}
this
.
iconInfos
.
push
(
iconInfo
)
;
this
.
iconTask
.
arm
(
)
;
}
onPageShow
(
event
)
{
if
(
event
.
target
!
=
this
.
chromeGlobal
.
content
.
document
)
{
return
;
}
if
(
!
this
.
seenTabIcon
&
&
Services
.
prefs
.
getBoolPref
(
"
browser
.
chrome
.
guess_favicon
"
true
)
)
{
let
baseURI
=
this
.
chromeGlobal
.
content
.
document
.
documentURIObject
;
if
(
baseURI
.
schemeIs
(
"
http
"
)
|
|
baseURI
.
schemeIs
(
"
https
"
)
)
{
let
iconUri
=
baseURI
.
mutate
(
)
.
setPathQueryRef
(
"
/
favicon
.
ico
"
)
.
finalize
(
)
;
this
.
addIcon
(
{
iconUri
width
:
-
1
isRichIcon
:
false
type
:
TYPE_ICO
node
:
this
.
chromeGlobal
.
content
.
document
}
)
;
}
}
if
(
this
.
iconTask
.
isArmed
)
{
this
.
iconTask
.
disarm
(
)
;
this
.
loadIcons
(
)
;
}
}
onPageHide
(
event
)
{
if
(
event
.
target
!
=
this
.
chromeGlobal
.
content
.
document
)
{
return
;
}
this
.
richIconLoader
.
cancel
(
)
;
this
.
tabIconLoader
.
cancel
(
)
;
this
.
iconTask
.
disarm
(
)
;
this
.
iconInfos
=
[
]
;
this
.
seenTabIcon
=
false
;
}
onLinkEvent
(
event
)
{
let
link
=
event
.
target
;
if
(
link
.
ownerGlobal
!
=
this
.
chromeGlobal
.
content
)
{
return
;
}
let
rel
=
link
.
rel
&
&
link
.
rel
.
toLowerCase
(
)
;
if
(
!
rel
|
|
!
link
.
href
)
return
;
let
feedAdded
=
false
;
let
iconAdded
=
false
;
let
searchAdded
=
false
;
let
rels
=
{
}
;
for
(
let
relString
of
rel
.
split
(
/
\
s
+
/
)
)
rels
[
relString
]
=
true
;
for
(
let
relVal
in
rels
)
{
let
isRichIcon
=
true
;
switch
(
relVal
)
{
case
"
feed
"
:
case
"
alternate
"
:
if
(
!
feedAdded
&
&
event
.
type
=
=
"
DOMLinkAdded
"
)
{
if
(
!
rels
.
feed
&
&
rels
.
alternate
&
&
rels
.
stylesheet
)
break
;
if
(
Feeds
.
isValidFeed
(
link
link
.
ownerDocument
.
nodePrincipal
"
feed
"
in
rels
)
)
{
this
.
chromeGlobal
.
sendAsyncMessage
(
"
Link
:
AddFeed
"
{
type
:
link
.
type
href
:
link
.
href
title
:
link
.
title
}
)
;
feedAdded
=
true
;
}
}
break
;
case
"
icon
"
:
isRichIcon
=
false
;
case
"
apple
-
touch
-
icon
"
:
case
"
apple
-
touch
-
icon
-
precomposed
"
:
case
"
fluid
-
icon
"
:
if
(
iconAdded
|
|
link
.
hasAttribute
(
"
mask
"
)
)
{
break
;
}
let
iconInfo
=
makeFaviconFromLink
(
link
isRichIcon
)
;
if
(
iconInfo
)
{
iconAdded
=
this
.
addIcon
(
iconInfo
)
;
}
break
;
case
"
search
"
:
if
(
Services
.
policies
&
&
!
Services
.
policies
.
isAllowed
(
"
installSearchEngine
"
)
)
{
break
;
}
if
(
!
searchAdded
&
&
event
.
type
=
=
"
DOMLinkAdded
"
)
{
let
type
=
link
.
type
&
&
link
.
type
.
toLowerCase
(
)
;
type
=
type
.
replace
(
/
^
\
s
+
|
\
s
*
(
?
:
;
.
*
)
?
/
g
"
"
)
;
let
re
=
/
^
(
?
:
https
?
|
ftp
)
:
/
i
;
if
(
type
=
=
"
application
/
opensearchdescription
+
xml
"
&
&
link
.
title
&
&
re
.
test
(
link
.
href
)
)
{
let
engine
=
{
title
:
link
.
title
href
:
link
.
href
}
;
this
.
chromeGlobal
.
sendAsyncMessage
(
"
Link
:
AddSearch
"
{
engine
url
:
link
.
ownerDocument
.
documentURI
}
)
;
searchAdded
=
true
;
}
}
break
;
}
}
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
pageshow
"
:
this
.
onPageShow
(
event
)
;
break
;
case
"
pagehide
"
:
this
.
onPageHide
(
event
)
;
break
;
default
:
this
.
onLinkEvent
(
event
)
;
}
}
}
