"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
ContentLinkHandler
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Feeds
"
"
resource
:
/
/
/
modules
/
Feeds
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
BrowserUtils
"
"
resource
:
/
/
gre
/
modules
/
BrowserUtils
.
jsm
"
)
;
const
SIZES_TELEMETRY_ENUM
=
{
NO_SIZES
:
0
ANY
:
1
DIMENSION
:
2
INVALID
:
3
}
;
const
FAVICON_PARSING_TIMEOUT
=
100
;
const
FAVICON_RICH_ICON_MIN_WIDTH
=
96
;
const
TYPE_ICO
=
"
image
/
x
-
icon
"
;
const
TYPE_SVG
=
"
image
/
svg
+
xml
"
;
function
setTimeout
(
aCallback
aDelay
)
{
let
timer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
timer
.
initWithCallback
(
aCallback
aDelay
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
return
timer
;
}
function
extractIconSize
(
aSizes
)
{
let
width
=
-
1
;
let
sizesType
;
const
re
=
/
^
(
[
1
-
9
]
[
0
-
9
]
*
)
x
[
1
-
9
]
[
0
-
9
]
*
/
i
;
if
(
aSizes
.
length
)
{
for
(
let
size
of
aSizes
)
{
if
(
size
.
toLowerCase
(
)
=
=
"
any
"
)
{
sizesType
=
SIZES_TELEMETRY_ENUM
.
ANY
;
break
;
}
else
{
let
values
=
re
.
exec
(
size
)
;
if
(
values
&
&
values
.
length
>
1
)
{
sizesType
=
SIZES_TELEMETRY_ENUM
.
DIMENSION
;
width
=
parseInt
(
values
[
1
]
)
;
break
;
}
else
{
sizesType
=
SIZES_TELEMETRY_ENUM
.
INVALID
;
break
;
}
}
}
}
else
{
sizesType
=
SIZES_TELEMETRY_ENUM
.
NO_SIZES
;
}
Services
.
telemetry
.
getHistogramById
(
"
LINK_ICON_SIZES_ATTR_USAGE
"
)
.
add
(
sizesType
)
;
if
(
width
>
0
)
Services
.
telemetry
.
getHistogramById
(
"
LINK_ICON_SIZES_ATTR_DIMENSION
"
)
.
add
(
width
)
;
return
width
;
}
function
getLinkIconURI
(
aLink
)
{
let
targetDoc
=
aLink
.
ownerDocument
;
let
uri
=
Services
.
io
.
newURI
(
aLink
.
href
targetDoc
.
characterSet
)
;
try
{
uri
=
uri
.
mutate
(
)
.
setUserPass
(
"
"
)
.
finalize
(
)
;
}
catch
(
e
)
{
}
return
uri
;
}
function
setIconForLink
(
aIconInfo
aChromeGlobal
)
{
aChromeGlobal
.
sendAsyncMessage
(
"
Link
:
SetIcon
"
{
url
:
aIconInfo
.
iconUri
.
spec
loadingPrincipal
:
aIconInfo
.
loadingPrincipal
requestContextID
:
aIconInfo
.
requestContextID
canUseForTab
:
!
aIconInfo
.
isRichIcon
}
)
;
}
function
guessType
(
icon
)
{
if
(
!
icon
)
{
return
"
"
;
}
if
(
!
icon
.
type
)
{
let
extension
=
icon
.
iconUri
.
filePath
.
split
(
"
.
"
)
.
pop
(
)
;
switch
(
extension
)
{
case
"
ico
"
:
return
TYPE_ICO
;
case
"
svg
"
:
return
TYPE_SVG
;
}
}
return
icon
.
type
=
=
"
image
/
vnd
.
microsoft
.
icon
"
?
TYPE_ICO
:
icon
.
type
|
|
"
"
;
}
function
faviconTimeoutCallback
(
aFaviconLoads
aPageUrl
aChromeGlobal
)
{
let
load
=
aFaviconLoads
.
get
(
aPageUrl
)
;
if
(
!
load
)
return
;
let
preferredIcon
;
let
preferredWidth
=
16
*
Math
.
ceil
(
aChromeGlobal
.
content
.
devicePixelRatio
)
;
let
bestSizedIcon
;
let
defaultIcon
;
let
largestRichIcon
;
for
(
let
icon
of
load
.
iconInfos
)
{
if
(
!
icon
.
isRichIcon
)
{
if
(
guessType
(
icon
)
=
=
TYPE_SVG
)
{
preferredIcon
=
icon
;
}
else
if
(
icon
.
width
=
=
preferredWidth
&
&
guessType
(
preferredIcon
)
!
=
TYPE_SVG
)
{
preferredIcon
=
icon
;
}
else
if
(
guessType
(
icon
)
=
=
TYPE_ICO
&
&
(
!
preferredIcon
|
|
guessType
(
preferredIcon
)
=
=
TYPE_ICO
)
)
{
preferredIcon
=
icon
;
}
if
(
icon
.
width
>
=
preferredWidth
&
&
(
!
bestSizedIcon
|
|
bestSizedIcon
.
width
>
=
icon
.
width
)
)
{
bestSizedIcon
=
icon
;
}
}
if
(
icon
.
isRichIcon
|
|
icon
.
width
>
=
FAVICON_RICH_ICON_MIN_WIDTH
)
{
if
(
!
largestRichIcon
|
|
largestRichIcon
.
width
<
icon
.
width
)
{
largestRichIcon
=
icon
;
}
}
else
{
defaultIcon
=
icon
;
}
}
if
(
largestRichIcon
)
{
setIconForLink
(
largestRichIcon
aChromeGlobal
)
;
}
if
(
preferredIcon
)
{
setIconForLink
(
preferredIcon
aChromeGlobal
)
;
}
else
if
(
bestSizedIcon
)
{
setIconForLink
(
bestSizedIcon
aChromeGlobal
)
;
}
else
if
(
defaultIcon
)
{
setIconForLink
(
defaultIcon
aChromeGlobal
)
;
}
load
.
timer
=
null
;
aFaviconLoads
.
delete
(
aPageUrl
)
;
}
function
getLinkRequestContextID
(
aLink
)
{
try
{
return
aLink
.
ownerDocument
.
documentLoadGroup
.
requestContextID
;
}
catch
(
e
)
{
return
null
;
}
}
function
handleFaviconLink
(
aLink
aIsRichIcon
aChromeGlobal
aFaviconLoads
)
{
let
pageUrl
=
aLink
.
ownerDocument
.
documentURI
;
let
iconUri
=
getLinkIconURI
(
aLink
)
;
if
(
!
iconUri
)
return
false
;
let
width
=
extractIconSize
(
aLink
.
sizes
)
;
let
iconInfo
=
{
iconUri
width
isRichIcon
:
aIsRichIcon
type
:
aLink
.
type
loadingPrincipal
:
aLink
.
ownerDocument
.
nodePrincipal
requestContextID
:
getLinkRequestContextID
(
aLink
)
}
;
if
(
aFaviconLoads
.
has
(
pageUrl
)
)
{
let
load
=
aFaviconLoads
.
get
(
pageUrl
)
;
load
.
iconInfos
.
push
(
iconInfo
)
;
load
.
timer
.
delay
=
FAVICON_PARSING_TIMEOUT
;
}
else
{
let
timer
=
setTimeout
(
(
)
=
>
faviconTimeoutCallback
(
aFaviconLoads
pageUrl
aChromeGlobal
)
FAVICON_PARSING_TIMEOUT
)
;
let
load
=
{
timer
iconInfos
:
[
iconInfo
]
}
;
aFaviconLoads
.
set
(
pageUrl
load
)
;
}
return
true
;
}
var
ContentLinkHandler
=
{
init
(
chromeGlobal
)
{
const
faviconLoads
=
new
Map
(
)
;
chromeGlobal
.
addEventListener
(
"
DOMLinkAdded
"
event
=
>
{
this
.
onLinkEvent
(
event
chromeGlobal
faviconLoads
)
;
}
)
;
chromeGlobal
.
addEventListener
(
"
DOMLinkChanged
"
event
=
>
{
this
.
onLinkEvent
(
event
chromeGlobal
faviconLoads
)
;
}
)
;
chromeGlobal
.
addEventListener
(
"
unload
"
event
=
>
{
for
(
const
[
pageUrl
load
]
of
faviconLoads
)
{
load
.
timer
.
cancel
(
)
;
load
.
timer
=
null
;
faviconLoads
.
delete
(
pageUrl
)
;
}
}
)
;
}
onLinkEvent
(
event
chromeGlobal
faviconLoads
)
{
var
link
=
event
.
originalTarget
;
var
rel
=
link
.
rel
&
&
link
.
rel
.
toLowerCase
(
)
;
if
(
!
link
|
|
!
link
.
ownerDocument
|
|
!
rel
|
|
!
link
.
href
)
return
;
let
window
=
link
.
ownerGlobal
;
if
(
window
!
=
window
.
top
)
return
;
var
feedAdded
=
false
;
var
iconAdded
=
false
;
var
searchAdded
=
false
;
var
rels
=
{
}
;
for
(
let
relString
of
rel
.
split
(
/
\
s
+
/
)
)
rels
[
relString
]
=
true
;
for
(
let
relVal
in
rels
)
{
let
isRichIcon
=
true
;
switch
(
relVal
)
{
case
"
feed
"
:
case
"
alternate
"
:
if
(
!
feedAdded
&
&
event
.
type
=
=
"
DOMLinkAdded
"
)
{
if
(
!
rels
.
feed
&
&
rels
.
alternate
&
&
rels
.
stylesheet
)
break
;
if
(
Feeds
.
isValidFeed
(
link
link
.
ownerDocument
.
nodePrincipal
"
feed
"
in
rels
)
)
{
chromeGlobal
.
sendAsyncMessage
(
"
Link
:
AddFeed
"
{
type
:
link
.
type
href
:
link
.
href
title
:
link
.
title
}
)
;
feedAdded
=
true
;
}
}
break
;
case
"
icon
"
:
isRichIcon
=
false
;
case
"
apple
-
touch
-
icon
"
:
case
"
apple
-
touch
-
icon
-
precomposed
"
:
case
"
fluid
-
icon
"
:
if
(
link
.
hasAttribute
(
"
mask
"
)
|
|
iconAdded
|
|
!
Services
.
prefs
.
getBoolPref
(
"
browser
.
chrome
.
site_icons
"
)
)
{
break
;
}
iconAdded
=
handleFaviconLink
(
link
isRichIcon
chromeGlobal
faviconLoads
)
;
break
;
case
"
search
"
:
if
(
Services
.
policies
&
&
!
Services
.
policies
.
isAllowed
(
"
installSearchEngine
"
)
)
{
break
;
}
if
(
!
searchAdded
&
&
event
.
type
=
=
"
DOMLinkAdded
"
)
{
var
type
=
link
.
type
&
&
link
.
type
.
toLowerCase
(
)
;
type
=
type
.
replace
(
/
^
\
s
+
|
\
s
*
(
?
:
;
.
*
)
?
/
g
"
"
)
;
let
re
=
/
^
(
?
:
https
?
|
ftp
)
:
/
i
;
if
(
type
=
=
"
application
/
opensearchdescription
+
xml
"
&
&
link
.
title
&
&
re
.
test
(
link
.
href
)
)
{
let
engine
=
{
title
:
link
.
title
href
:
link
.
href
}
;
chromeGlobal
.
sendAsyncMessage
(
"
Link
:
AddSearch
"
{
engine
url
:
link
.
ownerDocument
.
documentURI
}
)
;
searchAdded
=
true
;
}
}
break
;
}
}
}
}
;
