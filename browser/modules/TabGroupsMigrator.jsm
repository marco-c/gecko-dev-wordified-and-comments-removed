"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
TabGroupsMigrator
"
]
;
const
{
classes
:
Cc
interfaces
:
Ci
results
:
Cr
utils
:
Cu
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Services
"
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PlacesUtils
"
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Task
"
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
OS
"
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
AsyncShutdown
"
"
resource
:
/
/
gre
/
modules
/
AsyncShutdown
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gBrowserBundle
"
function
(
)
{
return
Services
.
strings
.
createBundle
(
'
chrome
:
/
/
browser
/
locale
/
browser
.
properties
'
)
;
}
)
;
const
RECOVERY_URL
=
"
chrome
:
/
/
browser
/
content
/
aboutTabGroupsMigration
.
xhtml
"
;
this
.
TabGroupsMigrator
=
{
bookmarkedGroupsPromise
:
null
migrate
(
stateAsSupportsString
)
{
stateAsSupportsString
.
QueryInterface
(
Ci
.
nsISupportsString
)
;
let
stateStr
=
stateAsSupportsString
.
data
;
let
state
;
try
{
state
=
JSON
.
parse
(
stateStr
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
"
Failed
to
parse
sessionstore
state
JSON
to
migrate
tab
groups
:
"
+
ex
)
;
return
;
}
let
groupData
=
this
.
_gatherGroupData
(
state
)
;
let
hiddenTabState
=
this
.
_removeHiddenTabGroupsFromState
(
state
groupData
)
;
if
(
hiddenTabState
.
windows
.
length
)
{
this
.
_createBackup
(
stateStr
)
;
this
.
_createBackgroundTabGroupRestorationPage
(
state
hiddenTabState
)
;
let
bookmarksFinishedPromise
=
this
.
_bookmarkAllGroupsFromState
(
groupData
)
;
AsyncShutdown
.
profileBeforeChange
.
addBlocker
(
"
Tab
groups
migration
bookmarks
"
bookmarksFinishedPromise
)
;
}
stateAsSupportsString
.
data
=
JSON
.
stringify
(
state
)
;
}
_gatherGroupData
(
state
)
{
let
allGroupData
=
new
Map
(
)
;
let
globalAnonGroupID
=
0
;
for
(
let
win
of
state
.
windows
)
{
if
(
win
.
extData
&
&
win
.
extData
[
"
tabview
-
group
"
]
)
{
let
groupInfo
=
{
}
;
try
{
groupInfo
=
JSON
.
parse
(
win
.
extData
[
"
tabview
-
group
"
]
)
;
}
catch
(
ex
)
{
}
let
windowGroupData
=
new
Map
(
)
;
let
activeGroupID
=
null
;
let
tabsWithoutGroup
=
[
]
;
for
(
let
tab
of
win
.
tabs
)
{
let
group
;
try
{
let
tabViewData
=
tab
.
extData
&
&
tab
.
extData
[
"
tabview
-
tab
"
]
&
&
JSON
.
parse
(
tab
.
extData
[
"
tabview
-
tab
"
]
)
;
if
(
tabViewData
&
&
(
"
groupID
"
in
tabViewData
)
)
{
group
=
tabViewData
.
groupID
+
"
"
;
}
}
catch
(
ex
)
{
}
if
(
!
group
)
{
if
(
activeGroupID
)
{
group
=
activeGroupID
;
}
else
{
if
(
!
tabsWithoutGroup
)
{
Cu
.
reportError
(
"
ERROR
:
the
list
of
tabs
without
groups
was
"
+
"
nulled
out
but
there
'
s
no
active
group
ID
?
"
+
"
This
should
never
happen
!
"
)
;
tabsWithoutGroup
=
[
]
;
}
tabsWithoutGroup
.
push
(
tab
)
;
continue
;
}
}
let
groupData
=
windowGroupData
.
get
(
group
)
;
if
(
!
groupData
)
{
let
title
=
(
groupInfo
[
group
]
&
&
groupInfo
[
group
]
.
title
)
|
|
"
"
;
groupData
=
{
tabs
:
[
]
tabGroupsMigrationTitle
:
title
}
;
if
(
!
title
)
{
groupData
.
anonGroupID
=
+
+
globalAnonGroupID
;
groupData
.
tabGroupsMigrationTitle
=
gBrowserBundle
.
formatStringFromName
(
"
tabgroups
.
migration
.
anonGroup
"
[
groupData
.
anonGroupID
]
1
)
;
}
if
(
!
activeGroupID
&
&
!
tab
.
hidden
)
{
activeGroupID
=
group
;
groupData
.
tabs
=
tabsWithoutGroup
;
tabsWithoutGroup
=
null
;
}
windowGroupData
.
set
(
group
groupData
)
;
}
groupData
.
tabs
.
push
(
tab
)
;
}
if
(
tabsWithoutGroup
&
&
tabsWithoutGroup
.
length
)
{
windowGroupData
.
set
(
"
active
group
"
{
tabs
:
tabsWithoutGroup
anonGroupID
:
+
+
globalAnonGroupID
}
)
;
}
allGroupData
.
set
(
win
windowGroupData
)
;
}
}
return
allGroupData
;
}
_createBackup
(
stateStr
)
{
let
dest
=
Services
.
dirsvc
.
get
(
"
ProfD
"
Ci
.
nsIFile
)
;
dest
.
append
(
"
tabgroups
-
session
-
backup
.
json
"
)
;
let
promise
=
OS
.
File
.
writeAtomic
(
dest
.
path
stateStr
{
encoding
:
"
utf
-
8
"
}
)
;
AsyncShutdown
.
webWorkersShutdown
.
addBlocker
(
"
TabGroupsMigrator
"
promise
)
;
return
promise
;
}
_groupSorter
(
a
b
)
{
if
(
!
a
.
anonGroupID
)
{
return
-
1
;
}
if
(
!
b
.
anonGroupID
)
{
return
1
;
}
return
a
.
anonGroupID
-
b
.
anonGroupID
;
}
_bookmarkAllGroupsFromState
:
Task
.
async
(
function
*
(
groupData
)
{
this
.
bookmarkedGroupsPromise
=
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
PlacesUtils
.
bookmarks
.
menuGuid
type
:
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
index
:
0
title
:
gBrowserBundle
.
GetStringFromName
(
"
tabgroups
.
migration
.
tabGroupBookmarkFolderName
"
)
}
)
.
catch
(
Cu
.
reportError
)
;
let
tabgroupsFolder
=
yield
this
.
bookmarkedGroupsPromise
;
for
(
let
[
windowGroupMap
]
of
groupData
)
{
let
windowGroups
=
[
.
.
.
windowGroupMap
.
values
(
)
]
.
sort
(
this
.
_groupSorter
)
;
for
(
let
group
of
windowGroups
)
{
let
groupFolder
=
yield
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
tabgroupsFolder
.
guid
type
:
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
title
:
group
.
tabGroupsMigrationTitle
}
)
.
catch
(
Cu
.
reportError
)
;
for
(
let
tab
of
group
.
tabs
)
{
let
entry
=
tab
.
entries
[
tab
.
index
-
1
]
;
yield
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
groupFolder
.
guid
title
:
tab
.
title
|
|
entry
.
title
url
:
entry
.
url
}
)
.
catch
(
Cu
.
reportError
)
;
}
}
}
}
)
_removeHiddenTabGroupsFromState
(
state
groups
)
{
let
stateToReturn
=
{
windows
:
[
]
}
;
for
(
let
win
of
state
.
windows
)
{
let
groupInfoForWindow
=
groups
.
get
(
win
)
;
let
hiddenGroupIDs
=
new
Set
(
)
;
for
(
let
i
=
win
.
tabs
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
let
tab
=
win
.
tabs
[
i
]
;
let
tabGroupInfo
=
null
;
try
{
tabGroupInfo
=
tab
.
extData
&
&
tab
.
extData
[
"
tabview
-
tab
"
]
&
&
JSON
.
parse
(
tab
.
extData
[
"
tabview
-
tab
"
]
)
;
}
catch
(
ex
)
{
}
if
(
tab
.
extData
)
{
delete
tab
.
extData
[
"
tabview
-
tab
"
]
;
if
(
Object
.
keys
(
tab
.
extData
)
.
length
=
=
0
)
{
delete
tab
.
extData
;
}
}
if
(
tabGroupInfo
&
&
tab
.
hidden
)
{
hiddenGroupIDs
.
add
(
tabGroupInfo
.
groupID
)
;
win
.
tabs
.
splice
(
i
1
)
;
tab
.
hidden
=
false
;
}
}
if
(
groupInfoForWindow
)
{
let
windowsToReturn
=
[
]
;
for
(
let
groupID
of
hiddenGroupIDs
)
{
let
group
=
groupInfoForWindow
.
get
(
"
"
+
groupID
)
;
if
(
group
)
{
windowsToReturn
.
push
(
group
)
;
}
}
windowsToReturn
.
sort
(
this
.
_groupSorter
)
;
stateToReturn
.
windows
=
stateToReturn
.
windows
.
concat
(
windowsToReturn
)
;
}
if
(
win
.
extData
)
{
delete
win
.
extData
[
"
tabview
-
group
"
]
;
delete
win
.
extData
[
"
tabview
-
groups
"
]
;
delete
win
.
extData
[
"
tabview
-
ui
"
]
;
delete
win
.
extData
[
"
tabview
-
visibility
"
]
;
if
(
Object
.
keys
(
win
.
extData
)
.
length
=
=
0
)
{
delete
win
.
extData
;
}
}
}
return
stateToReturn
;
}
_createBackgroundTabGroupRestorationPage
(
state
backgroundData
)
{
let
win
=
state
.
windows
[
(
state
.
selectedWindow
|
|
1
)
-
1
]
;
let
formdata
=
{
id
:
{
sessionData
:
JSON
.
stringify
(
backgroundData
)
}
url
:
RECOVERY_URL
}
;
let
newTab
=
{
entries
:
[
{
url
:
RECOVERY_URL
}
]
formdata
index
:
1
}
;
win
.
selected
=
win
.
tabs
.
push
(
newTab
)
;
}
}
;
