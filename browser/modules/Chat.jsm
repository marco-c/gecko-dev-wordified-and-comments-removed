"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
Chat
"
"
kDefaultButtonSet
"
]
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PrivateBrowsingUtils
"
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
const
kNSXUL
=
"
http
:
/
/
www
.
mozilla
.
org
/
keymaster
/
gatekeeper
/
there
.
is
.
only
.
xul
"
;
const
kDefaultButtonSet
=
new
Set
(
[
"
minimize
"
"
swap
"
"
close
"
]
)
;
const
kHiddenDefaultButtons
=
new
Set
(
[
"
minimize
"
"
close
"
]
)
;
var
gCustomButtons
=
new
Map
(
)
;
function
isWindowChromeless
(
win
)
{
let
docElem
=
win
.
document
.
documentElement
;
let
chromeless
=
docElem
.
getAttribute
(
"
chromehidden
"
)
.
includes
(
"
extrachrome
"
)
|
|
docElem
.
getAttribute
(
'
chromehidden
'
)
.
includes
(
"
toolbar
"
)
;
return
chromeless
;
}
function
isWindowGoodForChats
(
win
)
{
return
!
win
.
closed
&
&
!
!
win
.
document
.
getElementById
(
"
pinnedchats
"
)
&
&
!
isWindowChromeless
(
win
)
&
&
!
PrivateBrowsingUtils
.
isWindowPrivate
(
win
)
;
}
function
getChromeWindow
(
contentWin
)
{
return
contentWin
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebNavigation
)
.
QueryInterface
(
Ci
.
nsIDocShellTreeItem
)
.
rootTreeItem
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindow
)
;
}
var
Chat
=
{
get
chatboxes
(
)
{
return
function
*
(
)
{
let
winEnum
=
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
;
while
(
winEnum
.
hasMoreElements
(
)
)
{
let
win
=
winEnum
.
getNext
(
)
;
let
chatbar
=
win
.
document
.
getElementById
(
"
pinnedchats
"
)
;
if
(
!
chatbar
)
continue
;
let
chatboxes
=
[
.
.
.
chatbar
.
children
]
;
for
(
let
chatbox
of
chatboxes
)
{
yield
chatbox
;
}
}
winEnum
=
Services
.
wm
.
getEnumerator
(
"
Social
:
Chat
"
)
;
while
(
winEnum
.
hasMoreElements
(
)
)
{
let
win
=
winEnum
.
getNext
(
)
;
if
(
win
.
closed
)
continue
;
yield
win
.
document
.
getElementById
(
"
chatter
"
)
;
}
}
(
)
;
}
open
:
function
(
contentWindow
origin
title
url
mode
focus
callback
)
{
let
chromeWindow
=
this
.
findChromeWindowForChats
(
contentWindow
)
;
if
(
!
chromeWindow
)
{
Cu
.
reportError
(
"
Failed
to
open
a
chat
window
-
no
host
window
could
be
found
.
"
)
;
return
null
;
}
let
chatbar
=
chromeWindow
.
document
.
getElementById
(
"
pinnedchats
"
)
;
chatbar
.
hidden
=
false
;
let
chatbox
=
chatbar
.
openChat
(
origin
title
url
mode
callback
)
;
chromeWindow
.
getAttention
(
)
;
if
(
focus
=
=
=
undefined
)
{
let
dwu
=
chromeWindow
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
focus
=
dwu
.
isHandlingUserInput
;
}
if
(
focus
)
{
chatbar
.
focus
(
)
;
}
return
chatbox
;
}
closeAll
:
function
(
origin
)
{
for
(
let
chatbox
of
this
.
chatboxes
)
{
if
(
chatbox
.
content
.
getAttribute
(
"
origin
"
)
!
=
origin
)
{
continue
;
}
chatbox
.
close
(
)
;
}
}
focus
:
function
(
win
)
{
let
chatbar
=
win
.
document
.
getElementById
(
"
pinnedchats
"
)
;
if
(
chatbar
&
&
!
chatbar
.
hidden
)
{
chatbar
.
focus
(
)
;
}
}
findChromeWindowForChats
:
function
(
preferredWindow
)
{
if
(
preferredWindow
)
{
preferredWindow
=
getChromeWindow
(
preferredWindow
)
;
if
(
isWindowGoodForChats
(
preferredWindow
)
)
{
return
preferredWindow
;
}
}
let
mostRecent
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
if
(
isWindowGoodForChats
(
mostRecent
)
)
return
mostRecent
;
let
topMost
enumerator
;
let
os
=
Services
.
appinfo
.
OS
;
const
BROKEN_WM_Z_ORDER
=
os
!
=
"
WINNT
"
&
&
os
!
=
"
Darwin
"
;
if
(
BROKEN_WM_Z_ORDER
)
{
enumerator
=
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
;
}
else
{
enumerator
=
Services
.
wm
.
getZOrderDOMWindowEnumerator
(
"
navigator
:
browser
"
false
)
;
}
while
(
enumerator
.
hasMoreElements
(
)
)
{
let
win
=
enumerator
.
getNext
(
)
;
if
(
!
win
.
closed
&
&
isWindowGoodForChats
(
win
)
)
topMost
=
win
;
}
return
topMost
;
}
registerButton
:
function
(
button
)
{
if
(
gCustomButtons
.
has
(
button
.
id
)
)
return
;
gCustomButtons
.
set
(
button
.
id
button
)
;
}
loadButtonSet
:
function
(
chatbox
buttonSet
=
kDefaultButtonSet
)
{
if
(
!
buttonSet
)
return
;
if
(
typeof
buttonSet
=
=
"
string
"
)
{
buttonSet
=
buttonSet
.
split
(
"
"
)
.
map
(
button
=
>
button
.
trim
(
)
)
;
}
chatbox
.
setAttribute
(
"
buttonSet
"
[
.
.
.
buttonSet
]
.
join
(
"
"
)
)
;
let
isUndocked
=
!
chatbox
.
chatbar
;
let
document
=
chatbox
.
ownerDocument
;
let
titlebarNode
=
document
.
getAnonymousElementByAttribute
(
chatbox
"
class
"
"
chat
-
titlebar
"
)
;
let
buttonsSeen
=
new
Set
(
)
;
for
(
let
buttonId
of
buttonSet
)
{
buttonId
=
buttonId
.
trim
(
)
;
buttonsSeen
.
add
(
buttonId
)
;
let
nodes
node
;
if
(
kDefaultButtonSet
.
has
(
buttonId
)
)
{
node
=
document
.
getAnonymousElementByAttribute
(
chatbox
"
anonid
"
buttonId
)
;
if
(
!
node
)
continue
;
node
.
hidden
=
isUndocked
&
&
kHiddenDefaultButtons
.
has
(
buttonId
)
?
true
:
false
;
}
else
if
(
gCustomButtons
.
has
(
buttonId
)
)
{
let
button
=
gCustomButtons
.
get
(
buttonId
)
;
let
buttonClass
=
"
chat
-
"
+
buttonId
;
nodes
=
titlebarNode
.
getElementsByClassName
(
buttonClass
)
;
node
=
nodes
&
&
nodes
.
length
?
nodes
[
0
]
:
null
;
if
(
!
node
)
{
if
(
button
.
onBuild
)
{
node
=
button
.
onBuild
(
chatbox
)
;
}
else
{
node
=
document
.
createElementNS
(
kNSXUL
"
toolbarbutton
"
)
;
node
.
classList
.
add
(
buttonClass
)
;
node
.
classList
.
add
(
"
chat
-
toolbarbutton
"
)
;
}
if
(
button
.
onCommand
)
{
node
.
addEventListener
(
"
command
"
e
=
>
{
button
.
onCommand
(
e
chatbox
)
;
}
)
;
}
titlebarNode
.
appendChild
(
node
)
;
}
node
.
hidden
=
isUndocked
&
&
!
button
.
visibleWhenUndocked
;
}
else
{
Cu
.
reportError
(
"
Chatbox
button
'
"
+
buttonId
+
"
'
could
not
be
found
!
\
n
"
)
;
}
}
for
(
let
button
of
kDefaultButtonSet
)
{
if
(
!
buttonsSeen
.
has
(
button
)
)
document
.
getAnonymousElementByAttribute
(
chatbox
"
anonid
"
button
)
.
hidden
=
true
;
}
}
}
;
