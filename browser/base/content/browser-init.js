let
_resolveDelayedStartup
;
var
delayedStartupPromise
=
new
Promise
(
resolve
=
>
{
_resolveDelayedStartup
=
resolve
;
}
)
;
var
gBrowserInit
=
{
delayedStartupFinished
:
false
domContentLoaded
:
false
_tabToAdopt
:
undefined
_firstContentWindowPaintDeferred
:
Promise
.
withResolvers
(
)
idleTasksFinished
:
Promise
.
withResolvers
(
)
_setupFirstContentWindowPaintPromise
(
)
{
let
lastTransactionId
=
window
.
windowUtils
.
lastTransactionId
;
let
layerTreeListener
=
(
)
=
>
{
if
(
this
.
getTabToAdopt
(
)
)
{
return
;
}
removeEventListener
(
"
MozLayerTreeReady
"
layerTreeListener
)
;
let
listener
=
e
=
>
{
if
(
e
.
transactionId
>
lastTransactionId
)
{
window
.
removeEventListener
(
"
MozAfterPaint
"
listener
)
;
this
.
_firstContentWindowPaintDeferred
.
resolve
(
)
;
}
}
;
addEventListener
(
"
MozAfterPaint
"
listener
)
;
}
;
addEventListener
(
"
MozLayerTreeReady
"
layerTreeListener
)
;
}
getTabToAdopt
(
)
{
if
(
this
.
_tabToAdopt
!
=
=
undefined
)
{
return
this
.
_tabToAdopt
;
}
if
(
window
.
arguments
&
&
window
.
XULElement
.
isInstance
(
window
.
arguments
[
0
]
)
)
{
this
.
_tabToAdopt
=
window
.
arguments
[
0
]
;
window
.
arguments
[
0
]
=
null
;
}
else
{
this
.
_tabToAdopt
=
null
;
}
return
this
.
_tabToAdopt
;
}
_clearTabToAdopt
(
)
{
this
.
_tabToAdopt
=
null
;
}
isAdoptingTab
(
)
{
return
!
!
this
.
getTabToAdopt
(
)
;
}
onBeforeInitialXULLayout
(
)
{
this
.
_setupFirstContentWindowPaintPromise
(
)
;
updateBookmarkToolbarVisibility
(
)
;
if
(
ChromeUtils
.
shouldResistFingerprinting
(
"
RoundWindowSize
"
null
)
)
{
document
.
documentElement
.
setAttribute
(
"
sizemode
"
"
normal
"
)
;
}
else
if
(
!
document
.
documentElement
.
hasAttribute
(
"
width
"
)
)
{
const
TARGET_WIDTH
=
1280
;
const
TARGET_HEIGHT
=
1040
;
let
width
=
Math
.
min
(
screen
.
availWidth
*
0
.
9
TARGET_WIDTH
)
;
let
height
=
Math
.
min
(
screen
.
availHeight
*
0
.
9
TARGET_HEIGHT
)
;
document
.
documentElement
.
setAttribute
(
"
width
"
width
)
;
document
.
documentElement
.
setAttribute
(
"
height
"
height
)
;
if
(
width
<
TARGET_WIDTH
&
&
height
<
TARGET_HEIGHT
)
{
document
.
documentElement
.
setAttribute
(
"
sizemode
"
"
maximized
"
)
;
}
}
if
(
AppConstants
.
MENUBAR_CAN_AUTOHIDE
)
{
const
toolbarMenubar
=
document
.
getElementById
(
"
toolbar
-
menubar
"
)
;
if
(
!
toolbarMenubar
.
hasAttribute
(
"
autohide
"
)
)
{
toolbarMenubar
.
setAttribute
(
"
autohide
"
true
)
;
}
document
.
l10n
.
setAttributes
(
toolbarMenubar
"
toolbar
-
context
-
menu
-
menu
-
bar
-
cmd
"
)
;
toolbarMenubar
.
setAttribute
(
"
data
-
l10n
-
attrs
"
"
toolbarname
"
)
;
}
AutoHideMenubar
.
init
(
)
;
window
.
TabBarVisibility
.
update
(
)
;
TabsInTitlebar
.
init
(
)
;
new
LightweightThemeConsumer
(
document
)
;
if
(
Services
.
prefs
.
getBoolPref
(
"
toolkit
.
legacyUserProfileCustomizations
.
windowIcon
"
false
)
)
{
document
.
documentElement
.
setAttribute
(
"
icon
"
"
main
-
window
"
)
;
}
ToolbarIconColor
.
init
(
)
;
}
onDOMContentLoaded
(
)
{
window
.
docShell
.
treeOwner
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIAppWindow
)
.
XULBrowserWindow
=
window
.
XULBrowserWindow
;
window
.
browserDOMWindow
=
new
nsBrowserAccess
(
)
;
gBrowser
=
window
.
_gBrowser
;
delete
window
.
_gBrowser
;
gBrowser
.
init
(
)
;
BrowserWindowTracker
.
track
(
window
)
;
FirefoxViewHandler
.
init
(
)
;
gNavToolbox
.
palette
=
document
.
getElementById
(
"
BrowserToolbarPalette
"
)
.
content
;
for
(
let
area
of
CustomizableUI
.
areas
)
{
let
type
=
CustomizableUI
.
getAreaType
(
area
)
;
if
(
type
=
=
CustomizableUI
.
TYPE_TOOLBAR
)
{
let
node
=
document
.
getElementById
(
area
)
;
CustomizableUI
.
registerToolbarNode
(
node
)
;
}
}
BrowserSearch
.
initPlaceHolder
(
)
;
this
.
_callWithURIToLoad
(
uriToLoad
=
>
{
let
url
;
try
{
url
=
Services
.
io
.
newURI
(
uriToLoad
)
;
}
catch
(
e
)
{
return
;
}
let
nonQuery
=
url
.
prePath
+
url
.
filePath
;
if
(
nonQuery
in
gPageIcons
)
{
gBrowser
.
setIcon
(
gBrowser
.
selectedTab
gPageIcons
[
nonQuery
]
)
;
}
}
)
;
updateFxaToolbarMenu
(
gFxaToolbarEnabled
true
)
;
updatePrintCommands
(
gPrintEnabled
)
;
gUnifiedExtensions
.
init
(
)
;
this
.
_setInitialFocus
(
)
;
this
.
domContentLoaded
=
true
;
}
onLoad
(
)
{
gBrowser
.
addEventListener
(
"
DOMUpdateBlockedPopups
"
e
=
>
PopupBlockerObserver
.
handleEvent
(
e
)
)
;
gBrowser
.
addEventListener
(
"
TranslationsParent
:
LanguageState
"
FullPageTranslationsPanel
)
;
gBrowser
.
addEventListener
(
"
TranslationsParent
:
OfferTranslation
"
FullPageTranslationsPanel
)
;
gBrowser
.
addTabsProgressListener
(
FullPageTranslationsPanel
)
;
window
.
addEventListener
(
"
AppCommand
"
HandleAppCommandEvent
true
)
;
CaptivePortalWatcher
.
init
(
)
;
ZoomUI
.
init
(
window
)
;
if
(
!
gMultiProcessBrowser
)
{
gBrowser
.
tabpanels
.
addEventListener
(
"
click
"
contentAreaClick
{
capture
:
true
mozSystemGroup
:
true
}
)
;
}
gBrowser
.
addProgressListener
(
window
.
XULBrowserWindow
)
;
gBrowser
.
addTabsProgressListener
(
window
.
TabsProgressListener
)
;
SidebarController
.
init
(
)
;
DownloadsButton
.
init
(
)
;
Services
.
obs
.
notifyObservers
(
window
"
browser
-
window
-
before
-
show
"
)
;
if
(
!
window
.
toolbar
.
visible
)
{
gURLBar
.
readOnly
=
true
;
}
gUIDensity
.
init
(
)
;
TabletModeUpdater
.
init
(
)
;
CombinedStopReload
.
ensureInitialized
(
)
;
gPrivateBrowsingUI
.
init
(
)
;
BrowserSearch
.
init
(
)
;
BrowserPageActions
.
init
(
)
;
if
(
gToolbarKeyNavEnabled
)
{
ToolbarKeyboardNavigator
.
init
(
)
;
}
gRemoteControl
.
updateVisualCue
(
)
;
let
tabToAdopt
=
this
.
getTabToAdopt
(
)
;
if
(
tabToAdopt
)
{
let
evt
=
new
CustomEvent
(
"
before
-
initial
-
tab
-
adopted
"
{
bubbles
:
true
}
)
;
gBrowser
.
tabpanels
.
dispatchEvent
(
evt
)
;
gBrowser
.
stop
(
)
;
gURLBar
.
removeAttribute
(
"
focused
"
)
;
let
swapBrowsers
=
(
)
=
>
{
try
{
gBrowser
.
swapBrowsersAndCloseOther
(
gBrowser
.
selectedTab
tabToAdopt
)
;
}
catch
(
e
)
{
console
.
error
(
e
)
;
}
this
.
_clearTabToAdopt
(
)
;
}
;
if
(
tabToAdopt
.
linkedBrowser
.
isRemoteBrowser
)
{
addEventListener
(
"
MozAfterPaint
"
swapBrowsers
{
once
:
true
}
)
;
}
else
{
swapBrowsers
(
)
;
}
}
this
.
_boundDelayedStartup
=
this
.
_delayedStartup
.
bind
(
this
)
;
window
.
addEventListener
(
"
MozAfterPaint
"
this
.
_boundDelayedStartup
)
;
if
(
!
PrivateBrowsingUtils
.
enabled
)
{
document
.
getElementById
(
"
Tools
:
PrivateBrowsing
"
)
.
hidden
=
true
;
document
.
getElementById
(
"
key_privatebrowsing
"
)
.
remove
(
)
;
}
if
(
BrowserUIUtils
.
quitShortcutDisabled
)
{
document
.
getElementById
(
"
key_quitApplication
"
)
.
remove
(
)
;
document
.
getElementById
(
"
menu_FileQuitItem
"
)
.
removeAttribute
(
"
key
"
)
;
PanelMultiView
.
getViewNode
(
document
"
appMenu
-
quit
-
button2
"
)
?
.
removeAttribute
(
"
key
"
)
;
}
this
.
_loadHandled
=
true
;
}
_cancelDelayedStartup
(
)
{
window
.
removeEventListener
(
"
MozAfterPaint
"
this
.
_boundDelayedStartup
)
;
this
.
_boundDelayedStartup
=
null
;
}
_delayedStartup
(
)
{
let
{
TelemetryTimestamps
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
TelemetryTimestamps
.
sys
.
mjs
"
)
;
TelemetryTimestamps
.
add
(
"
delayedStartupStarted
"
)
;
this
.
_cancelDelayedStartup
(
)
;
Services
.
appShell
.
hiddenDOMWindow
;
gBrowser
.
addEventListener
(
"
PermissionStateChange
"
function
(
)
{
gIdentityHandler
.
refreshIdentityBlock
(
)
;
gPermissionPanel
.
updateSharingIndicator
(
)
;
}
true
)
;
this
.
_handleURIToLoad
(
)
;
Services
.
obs
.
addObserver
(
gIdentityHandler
"
perm
-
changed
"
)
;
Services
.
obs
.
addObserver
(
gRemoteControl
"
devtools
-
socket
"
)
;
Services
.
obs
.
addObserver
(
gRemoteControl
"
marionette
-
listening
"
)
;
Services
.
obs
.
addObserver
(
gRemoteControl
"
remote
-
listening
"
)
;
Services
.
obs
.
addObserver
(
gSessionHistoryObserver
"
browser
:
purge
-
session
-
history
"
)
;
Services
.
obs
.
addObserver
(
gStoragePressureObserver
"
QuotaManager
:
:
StoragePressure
"
)
;
Services
.
obs
.
addObserver
(
gXPInstallObserver
"
addon
-
install
-
disabled
"
)
;
Services
.
obs
.
addObserver
(
gXPInstallObserver
"
addon
-
install
-
started
"
)
;
Services
.
obs
.
addObserver
(
gXPInstallObserver
"
addon
-
install
-
blocked
"
)
;
Services
.
obs
.
addObserver
(
gXPInstallObserver
"
addon
-
install
-
fullscreen
-
blocked
"
)
;
Services
.
obs
.
addObserver
(
gXPInstallObserver
"
addon
-
install
-
origin
-
blocked
"
)
;
Services
.
obs
.
addObserver
(
gXPInstallObserver
"
addon
-
install
-
policy
-
blocked
"
)
;
Services
.
obs
.
addObserver
(
gXPInstallObserver
"
addon
-
install
-
webapi
-
blocked
"
)
;
Services
.
obs
.
addObserver
(
gXPInstallObserver
"
addon
-
install
-
failed
"
)
;
Services
.
obs
.
addObserver
(
gXPInstallObserver
"
addon
-
install
-
confirmation
"
)
;
Services
.
obs
.
addObserver
(
gKeywordURIFixup
"
keyword
-
uri
-
fixup
"
)
;
BrowserOffline
.
init
(
)
;
CanvasPermissionPromptHelper
.
init
(
)
;
WebAuthnPromptHelper
.
init
(
)
;
XPCOMUtils
.
callModulesFromCategory
(
"
browser
-
window
-
delayed
-
startup
"
window
)
;
FullZoom
.
init
(
)
;
PanelUI
.
init
(
shouldSuppressPopupNotifications
)
;
UpdateUrlbarSearchSplitterState
(
)
;
BookmarkingUI
.
init
(
)
;
BrowserSearch
.
delayedStartupInit
(
)
;
gProtectionsHandler
.
init
(
)
;
let
safeMode
=
document
.
getElementById
(
"
helpSafeMode
"
)
;
if
(
Services
.
appinfo
.
inSafeMode
)
{
document
.
l10n
.
setAttributes
(
safeMode
"
menu
-
help
-
exit
-
troubleshoot
-
mode
"
)
;
safeMode
.
setAttribute
(
"
appmenu
-
data
-
l10n
-
id
"
"
appmenu
-
help
-
exit
-
troubleshoot
-
mode
"
)
;
}
gBidiUI
=
isBidiEnabled
(
)
;
if
(
gBidiUI
)
{
document
.
getElementById
(
"
documentDirection
-
separator
"
)
.
hidden
=
false
;
document
.
getElementById
(
"
documentDirection
-
swap
"
)
.
hidden
=
false
;
document
.
getElementById
(
"
textfieldDirection
-
separator
"
)
.
hidden
=
false
;
document
.
getElementById
(
"
textfieldDirection
-
swap
"
)
.
hidden
=
false
;
}
if
(
!
Services
.
prefs
.
getBoolPref
(
"
ui
.
click_hold_context_menus
"
false
)
)
{
SetClickAndHoldHandlers
(
)
;
}
function
initBackForwardButtonTooltip
(
tooltipId
l10nId
shortcutId
)
{
let
shortcut
=
document
.
getElementById
(
shortcutId
)
;
shortcut
=
ShortcutUtils
.
prettifyShortcut
(
shortcut
)
;
let
tooltip
=
document
.
getElementById
(
tooltipId
)
;
document
.
l10n
.
setAttributes
(
tooltip
l10nId
{
shortcut
}
)
;
}
initBackForwardButtonTooltip
(
"
back
-
button
-
tooltip
-
description
"
"
navbar
-
tooltip
-
back
-
2
"
"
goBackKb
"
)
;
initBackForwardButtonTooltip
(
"
forward
-
button
-
tooltip
-
description
"
"
navbar
-
tooltip
-
forward
-
2
"
"
goForwardKb
"
)
;
PlacesToolbarHelper
.
init
(
)
;
ctrlTab
.
readPref
(
)
;
Services
.
prefs
.
addObserver
(
ctrlTab
.
prefName
ctrlTab
)
;
DownloadsButton
.
initializeIndicator
(
)
;
if
(
AppConstants
.
platform
!
=
"
macosx
"
)
{
updateEditUIVisibility
(
)
;
let
placesContext
=
document
.
getElementById
(
"
placesContext
"
)
;
placesContext
.
addEventListener
(
"
popupshowing
"
updateEditUIVisibility
)
;
placesContext
.
addEventListener
(
"
popuphiding
"
updateEditUIVisibility
)
;
}
FullScreen
.
init
(
)
;
MenuTouchModeObserver
.
init
(
)
;
if
(
AppConstants
.
MOZ_DATA_REPORTING
)
{
gDataNotificationInfoBar
.
init
(
)
;
}
if
(
!
AppConstants
.
MOZILLA_OFFICIAL
)
{
DevelopmentHelpers
.
init
(
)
;
}
gExtensionsNotifications
.
init
(
)
;
let
wasMinimized
=
window
.
windowState
=
=
window
.
STATE_MINIMIZED
;
window
.
addEventListener
(
"
sizemodechange
"
(
)
=
>
{
let
isMinimized
=
window
.
windowState
=
=
window
.
STATE_MINIMIZED
;
if
(
wasMinimized
!
=
isMinimized
)
{
wasMinimized
=
isMinimized
;
UpdatePopupNotificationsVisibility
(
)
;
}
}
)
;
window
.
addEventListener
(
"
mousemove
"
MousePosTracker
)
;
window
.
addEventListener
(
"
dragover
"
MousePosTracker
)
;
gNavToolbox
.
addEventListener
(
"
customizationstarting
"
CustomizationHandler
)
;
gNavToolbox
.
addEventListener
(
"
aftercustomization
"
CustomizationHandler
)
;
SessionStore
.
promiseInitialized
.
then
(
(
)
=
>
{
if
(
window
.
closed
)
{
return
;
}
RestoreLastSessionObserver
.
init
(
)
;
SidebarController
.
startDelayedLoad
(
)
;
PanicButtonNotifier
.
init
(
)
;
}
)
;
if
(
BrowserHandler
.
kiosk
)
{
if
(
!
gURLBar
.
readOnly
)
{
window
.
fullScreen
=
true
;
}
}
if
(
Services
.
policies
.
status
=
=
=
Services
.
policies
.
ACTIVE
)
{
if
(
!
Services
.
policies
.
isAllowed
(
"
hideShowMenuBar
"
)
)
{
document
.
getElementById
(
"
toolbar
-
menubar
"
)
.
removeAttribute
(
"
toolbarname
"
)
;
}
if
(
!
Services
.
policies
.
isAllowed
(
"
filepickers
"
)
)
{
let
savePageCommand
=
document
.
getElementById
(
"
Browser
:
SavePage
"
)
;
let
openFileCommand
=
document
.
getElementById
(
"
Browser
:
OpenFile
"
)
;
savePageCommand
.
setAttribute
(
"
disabled
"
"
true
"
)
;
openFileCommand
.
setAttribute
(
"
disabled
"
"
true
"
)
;
document
.
addEventListener
(
"
FilePickerBlocked
"
function
(
event
)
{
let
browser
=
event
.
target
;
let
notificationBox
=
browser
.
getTabBrowser
(
)
?
.
getNotificationBox
(
browser
)
;
if
(
notificationBox
&
&
!
notificationBox
.
getNotificationWithValue
(
"
filepicker
-
blocked
"
)
)
{
notificationBox
.
appendNotification
(
"
filepicker
-
blocked
"
{
label
:
{
"
l10n
-
id
"
:
"
filepicker
-
blocked
-
infobar
"
}
priority
:
notificationBox
.
PRIORITY_INFO_LOW
}
)
;
}
}
)
;
}
let
policies
=
Services
.
policies
.
getActivePolicies
(
)
;
if
(
"
ManagedBookmarks
"
in
policies
)
{
let
managedBookmarks
=
policies
.
ManagedBookmarks
;
let
children
=
managedBookmarks
.
filter
(
child
=
>
!
(
"
toplevel_name
"
in
child
)
)
;
if
(
children
.
length
)
{
let
managedBookmarksButton
=
document
.
createXULElement
(
"
toolbarbutton
"
)
;
managedBookmarksButton
.
setAttribute
(
"
id
"
"
managed
-
bookmarks
"
)
;
managedBookmarksButton
.
setAttribute
(
"
class
"
"
bookmark
-
item
"
)
;
let
toplevel
=
managedBookmarks
.
find
(
element
=
>
"
toplevel_name
"
in
element
)
;
if
(
toplevel
)
{
managedBookmarksButton
.
setAttribute
(
"
label
"
toplevel
.
toplevel_name
)
;
}
else
{
document
.
l10n
.
setAttributes
(
managedBookmarksButton
"
managed
-
bookmarks
"
)
;
}
managedBookmarksButton
.
setAttribute
(
"
context
"
"
placesContext
"
)
;
managedBookmarksButton
.
setAttribute
(
"
container
"
"
true
"
)
;
managedBookmarksButton
.
setAttribute
(
"
removable
"
"
false
"
)
;
managedBookmarksButton
.
setAttribute
(
"
type
"
"
menu
"
)
;
let
managedBookmarksPopup
=
document
.
createXULElement
(
"
menupopup
"
)
;
managedBookmarksPopup
.
setAttribute
(
"
id
"
"
managed
-
bookmarks
-
popup
"
)
;
managedBookmarksPopup
.
setAttribute
(
"
oncommand
"
"
PlacesToolbarHelper
.
openManagedBookmark
(
event
)
;
"
)
;
managedBookmarksPopup
.
setAttribute
(
"
ondragover
"
"
event
.
dataTransfer
.
effectAllowed
=
'
none
'
;
"
)
;
managedBookmarksPopup
.
setAttribute
(
"
ondragstart
"
"
PlacesToolbarHelper
.
onDragStartManaged
(
event
)
;
"
)
;
managedBookmarksPopup
.
setAttribute
(
"
onpopupshowing
"
"
PlacesToolbarHelper
.
populateManagedBookmarks
(
this
)
;
"
)
;
managedBookmarksPopup
.
setAttribute
(
"
placespopup
"
"
true
"
)
;
managedBookmarksPopup
.
setAttribute
(
"
is
"
"
places
-
popup
"
)
;
managedBookmarksPopup
.
classList
.
add
(
"
toolbar
-
menupopup
"
)
;
managedBookmarksButton
.
appendChild
(
managedBookmarksPopup
)
;
gNavToolbox
.
palette
.
appendChild
(
managedBookmarksButton
)
;
CustomizableUI
.
ensureWidgetPlacedInWindow
(
"
managed
-
bookmarks
"
window
)
;
if
(
!
CustomizableUI
.
getPlacementOfWidget
(
"
managed
-
bookmarks
"
)
)
{
CustomizableUI
.
addWidgetToArea
(
"
managed
-
bookmarks
"
CustomizableUI
.
AREA_BOOKMARKS
0
)
;
}
}
}
}
CaptivePortalWatcher
.
delayedStartup
(
)
;
ShoppingSidebarManager
.
ensureInitialized
(
)
;
SessionStore
.
promiseAllWindowsRestored
.
then
(
(
)
=
>
{
this
.
_schedulePerWindowIdleTasks
(
)
;
document
.
documentElement
.
setAttribute
(
"
sessionrestored
"
"
true
"
)
;
}
)
;
this
.
delayedStartupFinished
=
true
;
_resolveDelayedStartup
(
)
;
Services
.
obs
.
notifyObservers
(
window
"
browser
-
delayed
-
startup
-
finished
"
)
;
TelemetryTimestamps
.
add
(
"
delayedStartupFinished
"
)
;
}
get
firstContentWindowPaintPromise
(
)
{
return
this
.
_firstContentWindowPaintDeferred
.
promise
;
}
_setInitialFocus
(
)
{
let
initiallyFocusedElement
=
document
.
commandDispatcher
.
focusedElement
;
let
shouldRemoveFocusedAttribute
=
true
;
this
.
_callWithURIToLoad
(
uriToLoad
=
>
{
if
(
isBlankPageURL
(
uriToLoad
)
|
|
uriToLoad
=
=
"
about
:
privatebrowsing
"
|
|
this
.
getTabToAdopt
(
)
?
.
isEmpty
)
{
gURLBar
.
select
(
)
;
shouldRemoveFocusedAttribute
=
false
;
return
;
}
let
promise
=
gBrowser
.
selectedBrowser
.
isRemoteBrowser
?
this
.
firstContentWindowPaintPromise
:
Promise
.
resolve
(
)
;
promise
.
then
(
(
)
=
>
{
if
(
document
.
commandDispatcher
.
focusedElement
=
=
initiallyFocusedElement
)
{
gBrowser
.
selectedBrowser
.
focus
(
)
;
}
}
)
;
}
)
;
if
(
shouldRemoveFocusedAttribute
)
{
window
.
requestAnimationFrame
(
(
)
=
>
{
if
(
shouldRemoveFocusedAttribute
)
{
gURLBar
.
removeAttribute
(
"
focused
"
)
;
}
}
)
;
}
}
_handleURIToLoad
(
)
{
this
.
_callWithURIToLoad
(
uriToLoad
=
>
{
if
(
!
uriToLoad
)
{
return
;
}
if
(
Array
.
isArray
(
uriToLoad
)
)
{
try
{
gBrowser
.
loadTabs
(
uriToLoad
{
inBackground
:
false
replace
:
true
userContextId
:
window
.
arguments
[
5
]
triggeringPrincipal
:
window
.
arguments
[
8
]
|
|
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
allowInheritPrincipal
:
window
.
arguments
[
9
]
csp
:
window
.
arguments
[
10
]
fromExternal
:
true
}
)
;
}
catch
(
e
)
{
}
}
else
if
(
window
.
arguments
.
length
>
=
3
)
{
let
userContextId
=
window
.
arguments
[
5
]
!
=
undefined
?
window
.
arguments
[
5
]
:
Ci
.
nsIScriptSecurityManager
.
DEFAULT_USER_CONTEXT_ID
;
let
hasValidUserGestureActivation
=
undefined
;
let
fromExternal
=
undefined
;
let
globalHistoryOptions
=
undefined
;
let
triggeringRemoteType
=
undefined
;
let
forceAllowDataURI
=
false
;
let
wasSchemelessInput
=
false
;
if
(
window
.
arguments
[
1
]
)
{
if
(
!
(
window
.
arguments
[
1
]
instanceof
Ci
.
nsIPropertyBag2
)
)
{
throw
new
Error
(
"
window
.
arguments
[
1
]
must
be
null
or
Ci
.
nsIPropertyBag2
!
"
)
;
}
let
extraOptions
=
window
.
arguments
[
1
]
;
if
(
extraOptions
.
hasKey
(
"
hasValidUserGestureActivation
"
)
)
{
hasValidUserGestureActivation
=
extraOptions
.
getPropertyAsBool
(
"
hasValidUserGestureActivation
"
)
;
}
if
(
extraOptions
.
hasKey
(
"
fromExternal
"
)
)
{
fromExternal
=
extraOptions
.
getPropertyAsBool
(
"
fromExternal
"
)
;
}
if
(
extraOptions
.
hasKey
(
"
triggeringSponsoredURL
"
)
)
{
globalHistoryOptions
=
{
triggeringSponsoredURL
:
extraOptions
.
getPropertyAsACString
(
"
triggeringSponsoredURL
"
)
}
;
if
(
extraOptions
.
hasKey
(
"
triggeringSponsoredURLVisitTimeMS
"
)
)
{
globalHistoryOptions
.
triggeringSponsoredURLVisitTimeMS
=
extraOptions
.
getPropertyAsUint64
(
"
triggeringSponsoredURLVisitTimeMS
"
)
;
}
}
if
(
extraOptions
.
hasKey
(
"
triggeringRemoteType
"
)
)
{
triggeringRemoteType
=
extraOptions
.
getPropertyAsACString
(
"
triggeringRemoteType
"
)
;
}
if
(
extraOptions
.
hasKey
(
"
forceAllowDataURI
"
)
)
{
forceAllowDataURI
=
extraOptions
.
getPropertyAsBool
(
"
forceAllowDataURI
"
)
;
}
if
(
extraOptions
.
hasKey
(
"
wasSchemelessInput
"
)
)
{
wasSchemelessInput
=
extraOptions
.
getPropertyAsBool
(
"
wasSchemelessInput
"
)
;
}
}
try
{
openLinkIn
(
uriToLoad
"
current
"
{
referrerInfo
:
window
.
arguments
[
2
]
|
|
null
postData
:
window
.
arguments
[
3
]
|
|
null
allowThirdPartyFixup
:
window
.
arguments
[
4
]
|
|
false
userContextId
originPrincipal
:
window
.
arguments
[
6
]
originStoragePrincipal
:
window
.
arguments
[
7
]
triggeringPrincipal
:
window
.
arguments
[
8
]
allowInheritPrincipal
:
window
.
arguments
[
9
]
!
=
=
false
csp
:
window
.
arguments
[
10
]
forceAboutBlankViewerInCurrent
:
!
!
window
.
arguments
[
6
]
forceAllowDataURI
hasValidUserGestureActivation
fromExternal
globalHistoryOptions
triggeringRemoteType
wasSchemelessInput
}
)
;
}
catch
(
e
)
{
console
.
error
(
e
)
;
}
window
.
focus
(
)
;
}
else
{
loadOneOrMoreURIs
(
uriToLoad
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
null
)
;
}
}
)
;
}
_schedulePerWindowIdleTasks
(
)
{
if
(
window
.
closed
)
{
return
;
}
function
scheduleIdleTask
(
func
options
)
{
requestIdleCallback
(
function
idleTaskRunner
(
)
{
if
(
!
window
.
closed
)
{
func
(
)
;
}
}
options
)
;
}
scheduleIdleTask
(
(
)
=
>
{
gSync
.
init
(
)
;
}
)
;
scheduleIdleTask
(
(
)
=
>
{
let
reduceMotionQuery
=
window
.
matchMedia
(
"
(
prefers
-
reduced
-
motion
:
reduce
)
"
)
;
function
readSetting
(
)
{
gReduceMotionSetting
=
reduceMotionQuery
.
matches
;
}
reduceMotionQuery
.
addListener
(
readSetting
)
;
readSetting
(
)
;
}
)
;
scheduleIdleTask
(
(
)
=
>
{
gGestureSupport
.
init
(
true
)
;
gHistorySwipeAnimation
.
init
(
)
;
}
)
;
scheduleIdleTask
(
(
)
=
>
{
gBrowserThumbnails
.
init
(
)
;
}
)
;
scheduleIdleTask
(
(
)
=
>
{
try
{
DownloadsCommon
.
initializeAllDataLinks
(
)
;
ChromeUtils
.
importESModule
(
"
resource
:
/
/
/
modules
/
DownloadsTaskbar
.
sys
.
mjs
"
)
.
DownloadsTaskbar
.
registerIndicator
(
window
)
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
ChromeUtils
.
importESModule
(
"
resource
:
/
/
/
modules
/
DownloadsMacFinderProgress
.
sys
.
mjs
"
)
.
DownloadsMacFinderProgress
.
register
(
)
;
}
Services
.
telemetry
.
setEventRecordingEnabled
(
"
downloads
"
true
)
;
}
catch
(
ex
)
{
console
.
error
(
ex
)
;
}
}
{
timeout
:
10000
}
)
;
if
(
Win7Features
)
{
scheduleIdleTask
(
(
)
=
>
Win7Features
.
onOpenWindow
(
)
)
;
}
scheduleIdleTask
(
async
(
)
=
>
{
NewTabPagePreloading
.
maybeCreatePreloadedBrowser
(
window
)
;
}
)
;
scheduleIdleTask
(
(
)
=
>
{
gGfxUtils
.
init
(
)
;
}
)
;
scheduleIdleTask
(
(
)
=
>
{
this
.
idleTasksFinished
.
resolve
(
)
;
Services
.
obs
.
notifyObservers
(
window
"
browser
-
idle
-
startup
-
tasks
-
finished
"
)
;
}
)
;
scheduleIdleTask
(
(
)
=
>
{
gProfiles
.
init
(
)
;
}
)
;
}
get
uriToLoadPromise
(
)
{
delete
this
.
uriToLoadPromise
;
return
(
this
.
uriToLoadPromise
=
(
function
(
)
{
let
uri
=
window
.
arguments
?
.
[
0
]
;
if
(
!
uri
|
|
window
.
XULElement
.
isInstance
(
uri
)
)
{
return
null
;
}
let
defaultArgs
=
BrowserHandler
.
defaultArgs
;
if
(
uri
!
=
defaultArgs
)
{
AboutNewTab
.
noteNonDefaultStartup
(
)
;
if
(
uri
instanceof
Ci
.
nsIArray
)
{
return
Array
.
from
(
uri
.
enumerate
(
Ci
.
nsISupportsString
)
supportStr
=
>
supportStr
.
data
)
;
}
else
if
(
uri
instanceof
Ci
.
nsISupportsString
)
{
return
uri
.
data
;
}
return
uri
;
}
let
willOverride
=
SessionStartup
.
willOverrideHomepage
;
if
(
typeof
willOverride
=
=
"
boolean
"
)
{
return
willOverride
?
null
:
uri
;
}
return
willOverride
.
then
(
willOverrideHomepage
=
>
willOverrideHomepage
?
null
:
uri
)
;
}
)
(
)
)
;
}
_callWithURIToLoad
(
callback
)
{
let
uriToLoad
=
this
.
uriToLoadPromise
;
if
(
uriToLoad
&
&
uriToLoad
.
then
)
{
uriToLoad
.
then
(
callback
)
;
}
else
{
callback
(
uriToLoad
)
;
}
}
onUnload
(
)
{
gUIDensity
.
uninit
(
)
;
TabsInTitlebar
.
uninit
(
)
;
ToolbarIconColor
.
uninit
(
)
;
if
(
!
this
.
_loadHandled
)
{
return
;
}
CombinedStopReload
.
uninit
(
)
;
gGestureSupport
.
init
(
false
)
;
gHistorySwipeAnimation
.
uninit
(
)
;
FullScreen
.
uninit
(
)
;
gSync
.
uninit
(
)
;
gExtensionsNotifications
.
uninit
(
)
;
gUnifiedExtensions
.
uninit
(
)
;
try
{
gBrowser
.
removeProgressListener
(
window
.
XULBrowserWindow
)
;
gBrowser
.
removeTabsProgressListener
(
window
.
TabsProgressListener
)
;
}
catch
(
ex
)
{
}
PlacesToolbarHelper
.
uninit
(
)
;
BookmarkingUI
.
uninit
(
)
;
TabletModeUpdater
.
uninit
(
)
;
gTabletModePageCounter
.
finish
(
)
;
CaptivePortalWatcher
.
uninit
(
)
;
SidebarController
.
uninit
(
)
;
DownloadsButton
.
uninit
(
)
;
if
(
gToolbarKeyNavEnabled
)
{
ToolbarKeyboardNavigator
.
uninit
(
)
;
}
BrowserSearch
.
uninit
(
)
;
NewTabPagePreloading
.
removePreloadedBrowser
(
window
)
;
FirefoxViewHandler
.
uninit
(
)
;
if
(
this
.
_boundDelayedStartup
)
{
this
.
_cancelDelayedStartup
(
)
;
}
else
{
if
(
Win7Features
)
{
Win7Features
.
onCloseWindow
(
)
;
}
Services
.
prefs
.
removeObserver
(
ctrlTab
.
prefName
ctrlTab
)
;
ctrlTab
.
uninit
(
)
;
gBrowserThumbnails
.
uninit
(
)
;
gProtectionsHandler
.
uninit
(
)
;
FullZoom
.
destroy
(
)
;
Services
.
obs
.
removeObserver
(
gIdentityHandler
"
perm
-
changed
"
)
;
Services
.
obs
.
removeObserver
(
gRemoteControl
"
devtools
-
socket
"
)
;
Services
.
obs
.
removeObserver
(
gRemoteControl
"
marionette
-
listening
"
)
;
Services
.
obs
.
removeObserver
(
gRemoteControl
"
remote
-
listening
"
)
;
Services
.
obs
.
removeObserver
(
gSessionHistoryObserver
"
browser
:
purge
-
session
-
history
"
)
;
Services
.
obs
.
removeObserver
(
gStoragePressureObserver
"
QuotaManager
:
:
StoragePressure
"
)
;
Services
.
obs
.
removeObserver
(
gXPInstallObserver
"
addon
-
install
-
disabled
"
)
;
Services
.
obs
.
removeObserver
(
gXPInstallObserver
"
addon
-
install
-
started
"
)
;
Services
.
obs
.
removeObserver
(
gXPInstallObserver
"
addon
-
install
-
blocked
"
)
;
Services
.
obs
.
removeObserver
(
gXPInstallObserver
"
addon
-
install
-
fullscreen
-
blocked
"
)
;
Services
.
obs
.
removeObserver
(
gXPInstallObserver
"
addon
-
install
-
origin
-
blocked
"
)
;
Services
.
obs
.
removeObserver
(
gXPInstallObserver
"
addon
-
install
-
policy
-
blocked
"
)
;
Services
.
obs
.
removeObserver
(
gXPInstallObserver
"
addon
-
install
-
webapi
-
blocked
"
)
;
Services
.
obs
.
removeObserver
(
gXPInstallObserver
"
addon
-
install
-
failed
"
)
;
Services
.
obs
.
removeObserver
(
gXPInstallObserver
"
addon
-
install
-
confirmation
"
)
;
Services
.
obs
.
removeObserver
(
gKeywordURIFixup
"
keyword
-
uri
-
fixup
"
)
;
MenuTouchModeObserver
.
uninit
(
)
;
BrowserOffline
.
uninit
(
)
;
CanvasPermissionPromptHelper
.
uninit
(
)
;
WebAuthnPromptHelper
.
uninit
(
)
;
PanelUI
.
uninit
(
)
;
}
gBrowser
.
destroy
(
)
;
window
.
XULBrowserWindow
=
null
;
window
.
docShell
.
treeOwner
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIAppWindow
)
.
XULBrowserWindow
=
null
;
window
.
browserDOMWindow
=
null
;
}
}
;
