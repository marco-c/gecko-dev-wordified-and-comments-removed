var
FullZoom
=
{
name
:
"
browser
.
content
.
full
-
zoom
"
_siteSpecificPref
:
undefined
updateBackgroundTabs
:
undefined
_browserTokenMap
:
new
WeakMap
(
)
_initialLocations
:
new
WeakMap
(
)
get
siteSpecific
(
)
{
if
(
this
.
_siteSpecificPref
=
=
=
undefined
)
{
this
.
_siteSpecificPref
=
!
Services
.
prefs
.
getBoolPref
(
"
privacy
.
resistFingerprinting
"
)
&
&
Services
.
prefs
.
getBoolPref
(
"
browser
.
zoom
.
siteSpecific
"
)
;
}
return
this
.
_siteSpecificPref
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIObserver
Ci
.
nsIContentPrefObserver
Ci
.
nsISupportsWeakReference
]
)
init
:
function
FullZoom_init
(
)
{
gBrowser
.
addEventListener
(
"
DoZoomEnlargeBy10
"
this
)
;
gBrowser
.
addEventListener
(
"
DoZoomReduceBy10
"
this
)
;
this
.
_cps2
=
Cc
[
"
mozilla
.
org
/
content
-
pref
/
service
;
1
"
]
.
getService
(
Ci
.
nsIContentPrefService2
)
;
this
.
_cps2
.
addObserverForName
(
this
.
name
this
)
;
this
.
updateBackgroundTabs
=
Services
.
prefs
.
getBoolPref
(
"
browser
.
zoom
.
updateBackgroundTabs
"
)
;
Services
.
prefs
.
addObserver
(
"
browser
.
zoom
.
"
this
true
)
;
Services
.
prefs
.
addObserver
(
"
privacy
.
resistFingerprinting
"
this
true
)
;
for
(
let
browser
of
gBrowser
.
browsers
)
{
if
(
this
.
_initialLocations
.
has
(
browser
)
)
{
this
.
onLocationChange
(
.
.
.
this
.
_initialLocations
.
get
(
browser
)
browser
)
;
}
}
this
.
_initialLocations
=
null
;
}
destroy
:
function
FullZoom_destroy
(
)
{
Services
.
prefs
.
removeObserver
(
"
browser
.
zoom
.
"
this
)
;
this
.
_cps2
.
removeObserverForName
(
this
.
name
this
)
;
gBrowser
.
removeEventListener
(
"
DoZoomEnlargeBy10
"
this
)
;
gBrowser
.
removeEventListener
(
"
DoZoomReduceBy10
"
this
)
;
}
handleEvent
:
function
FullZoom_handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
DoZoomEnlargeBy10
"
:
this
.
changeZoomBy
(
this
.
_getTargetedBrowser
(
event
)
0
.
1
)
;
break
;
case
"
DoZoomReduceBy10
"
:
this
.
changeZoomBy
(
this
.
_getTargetedBrowser
(
event
)
-
0
.
1
)
;
break
;
}
}
observe
(
aSubject
aTopic
aData
)
{
switch
(
aTopic
)
{
case
"
nsPref
:
changed
"
:
switch
(
aData
)
{
case
"
privacy
.
resistFingerprinting
"
:
case
"
browser
.
zoom
.
siteSpecific
"
:
this
.
_siteSpecificPref
=
undefined
;
break
;
case
"
browser
.
zoom
.
updateBackgroundTabs
"
:
this
.
updateBackgroundTabs
=
Services
.
prefs
.
getBoolPref
(
"
browser
.
zoom
.
updateBackgroundTabs
"
)
;
break
;
}
break
;
}
}
onContentPrefSet
:
function
FullZoom_onContentPrefSet
(
aGroup
aName
aValue
aIsPrivate
)
{
this
.
_onContentPrefChanged
(
aGroup
aValue
aIsPrivate
)
;
}
onContentPrefRemoved
:
function
FullZoom_onContentPrefRemoved
(
aGroup
aName
aIsPrivate
)
{
this
.
_onContentPrefChanged
(
aGroup
undefined
aIsPrivate
)
;
}
_onContentPrefChanged
:
function
FullZoom__onContentPrefChanged
(
aGroup
aValue
aIsPrivate
)
{
if
(
this
.
_isNextContentPrefChangeInternal
)
{
delete
this
.
_isNextContentPrefChangeInternal
;
return
;
}
let
browser
=
gBrowser
.
selectedBrowser
;
if
(
!
browser
.
currentURI
)
{
return
;
}
if
(
this
.
_isPDFViewer
(
browser
)
)
{
return
;
}
let
ctxt
=
this
.
_loadContextFromBrowser
(
browser
)
;
let
domain
=
this
.
_cps2
.
extractDomain
(
browser
.
currentURI
.
spec
)
;
if
(
aGroup
)
{
if
(
aGroup
=
=
domain
&
&
ctxt
.
usePrivateBrowsing
=
=
aIsPrivate
)
{
this
.
_applyPrefToZoom
(
aValue
browser
)
;
}
return
;
}
let
hasPref
=
false
;
let
token
=
this
.
_getBrowserToken
(
browser
)
;
this
.
_cps2
.
getByDomainAndName
(
browser
.
currentURI
.
spec
this
.
name
ctxt
{
handleResult
(
)
{
hasPref
=
true
;
}
handleCompletion
:
(
)
=
>
{
if
(
!
hasPref
&
&
token
.
isCurrent
)
{
this
.
_applyPrefToZoom
(
undefined
browser
)
;
}
}
}
)
;
}
onLocationChange
:
function
FullZoom_onLocationChange
(
aURI
aIsTabSwitch
aBrowser
)
{
let
browser
=
aBrowser
|
|
gBrowser
.
selectedBrowser
;
if
(
this
.
_initialLocations
)
{
this
.
_initialLocations
.
set
(
browser
[
aURI
aIsTabSwitch
]
)
;
return
;
}
this
.
_ignorePendingZoomAccesses
(
browser
)
;
if
(
!
aURI
|
|
(
aIsTabSwitch
&
&
!
this
.
siteSpecific
)
)
{
this
.
_notifyOnLocationChange
(
browser
)
;
return
;
}
if
(
aURI
.
spec
=
=
"
about
:
blank
"
)
{
if
(
!
browser
.
contentPrincipal
|
|
browser
.
contentPrincipal
.
isNullPrincipal
)
{
this
.
_applyPrefToZoom
(
1
browser
this
.
_notifyOnLocationChange
.
bind
(
this
browser
)
)
;
}
else
{
this
.
_applyPrefToZoom
(
undefined
browser
this
.
_notifyOnLocationChange
.
bind
(
this
browser
)
)
;
}
return
;
}
if
(
!
aIsTabSwitch
&
&
browser
.
isSyntheticDocument
)
{
ZoomManager
.
setZoomForBrowser
(
browser
1
)
;
this
.
_notifyOnLocationChange
(
browser
)
;
return
;
}
if
(
this
.
_isPDFViewer
(
browser
)
)
{
this
.
_applyPrefToZoom
(
1
browser
this
.
_notifyOnLocationChange
.
bind
(
this
browser
)
)
;
return
;
}
let
ctxt
=
this
.
_loadContextFromBrowser
(
browser
)
;
let
pref
=
this
.
_cps2
.
getCachedByDomainAndName
(
aURI
.
spec
this
.
name
ctxt
)
;
if
(
pref
)
{
this
.
_applyPrefToZoom
(
pref
.
value
browser
this
.
_notifyOnLocationChange
.
bind
(
this
browser
)
)
;
return
;
}
let
value
=
undefined
;
let
token
=
this
.
_getBrowserToken
(
browser
)
;
this
.
_cps2
.
getByDomainAndName
(
aURI
.
spec
this
.
name
ctxt
{
handleResult
(
resultPref
)
{
value
=
resultPref
.
value
;
}
handleCompletion
:
(
)
=
>
{
if
(
!
token
.
isCurrent
)
{
this
.
_notifyOnLocationChange
(
browser
)
;
return
;
}
this
.
_applyPrefToZoom
(
value
browser
this
.
_notifyOnLocationChange
.
bind
(
this
browser
)
)
;
}
}
)
;
}
updateMenu
:
function
FullZoom_updateMenu
(
)
{
var
menuItem
=
document
.
getElementById
(
"
toggle_zoom
"
)
;
menuItem
.
setAttribute
(
"
checked
"
!
ZoomManager
.
useFullZoom
)
;
}
async
reduce
(
)
{
let
browser
=
gBrowser
.
selectedBrowser
;
if
(
browser
.
currentURI
.
spec
.
startsWith
(
"
about
:
reader
"
)
)
{
browser
.
sendMessageToActor
(
"
Reader
:
ZoomOut
"
{
}
"
AboutReader
"
)
;
}
else
if
(
this
.
_isPDFViewer
(
browser
)
)
{
browser
.
messageManager
.
sendAsyncMessage
(
"
PDFJS
:
ZoomOut
"
)
;
}
else
{
ZoomManager
.
reduce
(
)
;
this
.
_ignorePendingZoomAccesses
(
browser
)
;
await
this
.
_applyZoomToPref
(
browser
)
;
}
}
async
enlarge
(
)
{
let
browser
=
gBrowser
.
selectedBrowser
;
if
(
browser
.
currentURI
.
spec
.
startsWith
(
"
about
:
reader
"
)
)
{
browser
.
sendMessageToActor
(
"
Reader
:
ZoomIn
"
{
}
"
AboutReader
"
)
;
}
else
if
(
this
.
_isPDFViewer
(
browser
)
)
{
browser
.
messageManager
.
sendAsyncMessage
(
"
PDFJS
:
ZoomIn
"
)
;
}
else
{
ZoomManager
.
enlarge
(
)
;
this
.
_ignorePendingZoomAccesses
(
browser
)
;
await
this
.
_applyZoomToPref
(
browser
)
;
}
}
changeZoomBy
(
aBrowser
aValue
)
{
if
(
aBrowser
.
currentURI
.
spec
.
startsWith
(
"
about
:
reader
"
)
)
{
const
message
=
aValue
>
0
?
"
Reader
:
:
ZoomIn
"
:
"
Reader
:
ZoomOut
"
;
aBrowser
.
sendMessageToActor
(
message
{
}
"
AboutReader
"
)
;
return
;
}
else
if
(
this
.
_isPDFViewer
(
aBrowser
)
)
{
const
message
=
aValue
>
0
?
"
PDFJS
:
:
ZoomIn
"
:
"
PDFJS
:
ZoomOut
"
;
aBrowser
.
messageManager
.
sendAsyncMessage
(
message
)
;
return
;
}
let
zoom
=
ZoomManager
.
getZoomForBrowser
(
aBrowser
)
;
zoom
+
=
aValue
;
if
(
zoom
<
ZoomManager
.
MIN
)
{
zoom
=
ZoomManager
.
MIN
;
}
else
if
(
zoom
>
ZoomManager
.
MAX
)
{
zoom
=
ZoomManager
.
MAX
;
}
ZoomManager
.
setZoomForBrowser
(
aBrowser
zoom
)
;
this
.
_ignorePendingZoomAccesses
(
aBrowser
)
;
this
.
_applyZoomToPref
(
aBrowser
)
;
}
setZoom
(
value
browser
=
gBrowser
.
selectedBrowser
)
{
if
(
this
.
_isPDFViewer
(
browser
)
)
{
return
;
}
ZoomManager
.
setZoomForBrowser
(
browser
value
)
;
this
.
_ignorePendingZoomAccesses
(
browser
)
;
this
.
_applyZoomToPref
(
browser
)
;
}
reset
:
function
FullZoom_reset
(
browser
=
gBrowser
.
selectedBrowser
)
{
let
forceValue
;
if
(
browser
.
currentURI
.
spec
.
startsWith
(
"
about
:
reader
"
)
)
{
browser
.
sendMessageToActor
(
"
Reader
:
ResetZoom
"
{
}
"
AboutReader
"
)
;
}
else
if
(
this
.
_isPDFViewer
(
browser
)
)
{
browser
.
messageManager
.
sendAsyncMessage
(
"
PDFJS
:
ZoomReset
"
)
;
forceValue
=
1
;
}
let
token
=
this
.
_getBrowserToken
(
browser
)
;
let
result
=
ZoomUI
.
getGlobalValue
(
)
.
then
(
value
=
>
{
if
(
token
.
isCurrent
)
{
ZoomManager
.
setZoomForBrowser
(
browser
forceValue
|
|
value
)
;
this
.
_ignorePendingZoomAccesses
(
browser
)
;
}
}
)
;
this
.
_removePref
(
browser
)
;
return
result
;
}
_applyPrefToZoom
:
function
FullZoom__applyPrefToZoom
(
aValue
aBrowser
aCallback
)
{
if
(
gInPrintPreviewMode
)
{
this
.
_executeSoon
(
aCallback
)
;
return
;
}
if
(
!
aBrowser
.
mInitialized
|
|
aBrowser
.
isSyntheticDocument
|
|
(
!
this
.
siteSpecific
&
&
aBrowser
.
tabHasCustomZoom
)
)
{
this
.
_executeSoon
(
aCallback
)
;
return
;
}
if
(
aValue
!
=
=
undefined
&
&
this
.
siteSpecific
)
{
ZoomManager
.
setZoomForBrowser
(
aBrowser
this
.
_ensureValid
(
aValue
)
)
;
this
.
_ignorePendingZoomAccesses
(
aBrowser
)
;
this
.
_executeSoon
(
aCallback
)
;
return
;
}
let
token
=
this
.
_getBrowserToken
(
aBrowser
)
;
ZoomUI
.
getGlobalValue
(
)
.
then
(
value
=
>
{
if
(
token
.
isCurrent
)
{
ZoomManager
.
setZoomForBrowser
(
aBrowser
value
)
;
this
.
_ignorePendingZoomAccesses
(
aBrowser
)
;
}
this
.
_executeSoon
(
aCallback
)
;
}
)
;
}
_applyZoomToPref
:
function
FullZoom__applyZoomToPref
(
browser
)
{
if
(
!
this
.
siteSpecific
|
|
gInPrintPreviewMode
|
|
browser
.
isSyntheticDocument
)
{
browser
.
tabHasCustomZoom
=
!
this
.
siteSpecific
;
return
null
;
}
return
new
Promise
(
resolve
=
>
{
this
.
_cps2
.
set
(
browser
.
currentURI
.
spec
this
.
name
ZoomManager
.
getZoomForBrowser
(
browser
)
this
.
_loadContextFromBrowser
(
browser
)
{
handleCompletion
:
(
)
=
>
{
this
.
_isNextContentPrefChangeInternal
=
true
;
resolve
(
)
;
}
}
)
;
}
)
;
}
_removePref
:
function
FullZoom__removePref
(
browser
)
{
if
(
browser
.
isSyntheticDocument
)
{
return
;
}
let
ctxt
=
this
.
_loadContextFromBrowser
(
browser
)
;
this
.
_cps2
.
removeByDomainAndName
(
browser
.
currentURI
.
spec
this
.
name
ctxt
{
handleCompletion
:
(
)
=
>
{
this
.
_isNextContentPrefChangeInternal
=
true
;
}
}
)
;
}
_getBrowserToken
:
function
FullZoom__getBrowserToken
(
browser
)
{
let
map
=
this
.
_browserTokenMap
;
if
(
!
map
.
has
(
browser
)
)
{
map
.
set
(
browser
0
)
;
}
return
{
token
:
map
.
get
(
browser
)
get
isCurrent
(
)
{
return
map
.
get
(
browser
)
=
=
=
this
.
token
&
&
browser
.
mInitialized
;
}
}
;
}
_getTargetedBrowser
:
function
FullZoom__getTargetedBrowser
(
event
)
{
let
target
=
event
.
originalTarget
;
const
XUL_NS
=
"
http
:
/
/
www
.
mozilla
.
org
/
keymaster
/
gatekeeper
/
there
.
is
.
only
.
xul
"
;
if
(
target
instanceof
window
.
XULElement
&
&
target
.
localName
=
=
"
browser
"
&
&
target
.
namespaceURI
=
=
XUL_NS
)
{
return
target
;
}
if
(
target
.
nodeType
=
=
Node
.
DOCUMENT_NODE
)
{
return
target
.
ownerGlobal
.
docShell
.
chromeEventHandler
;
}
throw
new
Error
(
"
Unexpected
zoom
event
source
"
)
;
}
_ignorePendingZoomAccesses
:
function
FullZoom__ignorePendingZoomAccesses
(
browser
)
{
let
map
=
this
.
_browserTokenMap
;
map
.
set
(
browser
(
map
.
get
(
browser
)
|
|
0
)
+
1
)
;
}
_ensureValid
:
function
FullZoom__ensureValid
(
aValue
)
{
if
(
isNaN
(
aValue
)
)
{
return
1
;
}
if
(
aValue
<
ZoomManager
.
MIN
)
{
return
ZoomManager
.
MIN
;
}
if
(
aValue
>
ZoomManager
.
MAX
)
{
return
ZoomManager
.
MAX
;
}
return
aValue
;
}
_loadContextFromBrowser
:
function
FullZoom__loadContextFromBrowser
(
browser
)
{
return
browser
.
loadContext
;
}
_notifyOnLocationChange
:
function
FullZoom__notifyOnLocationChange
(
browser
)
{
this
.
_executeSoon
(
function
(
)
{
Services
.
obs
.
notifyObservers
(
browser
"
browser
-
fullZoom
:
location
-
change
"
)
;
}
)
;
}
_executeSoon
:
function
FullZoom__executeSoon
(
callback
)
{
if
(
!
callback
)
{
return
;
}
Services
.
tm
.
dispatchToMainThread
(
callback
)
;
}
_isPDFViewer
(
browser
)
{
return
!
!
(
browser
.
contentPrincipal
&
&
browser
.
contentPrincipal
.
URI
&
&
browser
.
contentPrincipal
.
URI
.
spec
=
=
"
resource
:
/
/
pdf
.
js
/
web
/
viewer
.
html
"
)
;
}
}
;
