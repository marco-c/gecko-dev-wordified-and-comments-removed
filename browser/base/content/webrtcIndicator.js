const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
webrtcUI
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
/
modules
/
webrtcUI
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
SitePermissions
"
"
resource
:
/
/
/
modules
/
SitePermissions
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
gScreenManager
"
"
mozilla
.
org
/
gfx
/
screenmanager
;
1
"
"
nsIScreenManager
"
)
;
function
updateIndicatorState
(
)
{
WebRTCIndicator
.
updateIndicatorState
(
)
;
}
const
WebRTCIndicator
=
{
init
(
event
)
{
addEventListener
(
"
load
"
this
)
;
this
.
positionCustomized
=
false
;
this
.
updatingIndicatorState
=
false
;
this
.
loaded
=
false
;
}
updateIndicatorState
(
initialLayout
=
false
)
{
if
(
!
this
.
loaded
)
{
return
;
}
this
.
updatingIndicatorState
=
true
;
this
.
updateWindowAttr
(
"
sharingvideo
"
webrtcUI
.
showCameraIndicator
)
;
this
.
updateWindowAttr
(
"
sharingaudio
"
webrtcUI
.
showMicrophoneIndicator
)
;
this
.
updateWindowAttr
(
"
sharingscreen
"
webrtcUI
.
showScreenSharingIndicator
.
startsWith
(
"
Screen
"
)
)
;
let
sharingWindow
=
webrtcUI
.
showScreenSharingIndicator
.
startsWith
(
"
Window
"
)
;
this
.
updateWindowAttr
(
"
sharingwindow
"
sharingWindow
)
;
if
(
sharingWindow
)
{
let
activeStreams
=
webrtcUI
.
getActiveStreams
(
false
false
false
true
)
;
let
hasBrowserWindow
=
activeStreams
.
some
(
stream
=
>
{
return
stream
.
devices
.
some
(
device
=
>
device
.
scary
)
;
}
)
;
this
.
updateWindowAttr
(
"
sharingbrowserwindow
"
hasBrowserWindow
)
;
this
.
sharingBrowserWindow
=
hasBrowserWindow
;
}
else
{
this
.
updateWindowAttr
(
"
sharingbrowserwindow
"
)
;
this
.
sharingBrowserWindow
=
false
;
}
window
.
sizeToContent
(
)
;
this
.
ensureOnScreen
(
)
;
if
(
!
this
.
positionCustomized
)
{
this
.
centerOnPrimaryDisplay
(
)
;
}
this
.
updatingIndicatorState
=
false
;
}
ensureOnScreen
(
)
{
let
desiredX
=
Math
.
max
(
window
.
screenX
screen
.
availLeft
)
;
let
maxX
=
screen
.
availLeft
+
screen
.
availWidth
-
document
.
documentElement
.
clientWidth
;
window
.
moveTo
(
Math
.
min
(
desiredX
maxX
)
window
.
screenY
)
;
}
centerOnPrimaryDisplay
(
)
{
let
{
height
:
windowHeight
width
:
windowWidth
}
=
window
.
windowUtils
.
getBoundsWithoutFlushing
(
document
.
documentElement
)
;
let
screen
=
gScreenManager
.
primaryScreen
;
let
scaleFactor
=
screen
.
contentsScaleFactor
/
screen
.
defaultCSSScaleFactor
;
let
widthDevPix
=
{
}
;
screen
.
GetRectDisplayPix
(
{
}
{
}
widthDevPix
{
}
)
;
let
screenWidth
=
widthDevPix
.
value
*
scaleFactor
;
let
availTopDevPix
=
{
}
;
let
availHeightDevPix
=
{
}
;
screen
.
GetAvailRectDisplayPix
(
{
}
availTopDevPix
{
}
availHeightDevPix
)
;
let
availHeight
=
(
availTopDevPix
.
value
+
availHeightDevPix
.
value
)
*
scaleFactor
;
window
.
moveTo
(
(
screenWidth
-
windowWidth
)
/
2
availHeight
-
windowHeight
)
;
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
load
"
:
{
this
.
onLoad
(
event
)
;
break
;
}
case
"
click
"
:
{
this
.
onClick
(
event
)
;
break
;
}
case
"
MozUpdateWindowPos
"
:
{
if
(
!
this
.
updatingIndicatorState
)
{
this
.
positionCustomized
=
true
;
}
break
;
}
}
}
onLoad
(
)
{
this
.
loaded
=
true
;
this
.
updateIndicatorState
(
true
)
;
this
.
centerOnPrimaryDisplay
(
)
;
window
.
addEventListener
(
"
click
"
this
)
;
window
.
windowRoot
.
addEventListener
(
"
MozUpdateWindowPos
"
this
)
;
let
ev
=
new
CustomEvent
(
"
AlertActive
"
{
bubbles
:
true
cancelable
:
true
}
)
;
document
.
documentElement
.
dispatchEvent
(
ev
)
;
this
.
loaded
=
true
;
}
onClick
(
event
)
{
switch
(
event
.
target
.
id
)
{
case
"
stop
-
sharing
-
screen
"
:
{
let
activeStreams
=
webrtcUI
.
getActiveStreams
(
false
false
true
false
)
;
this
.
stopSharingScreen
(
activeStreams
)
;
break
;
}
case
"
stop
-
sharing
-
window
"
:
{
let
activeStreams
=
webrtcUI
.
getActiveStreams
(
false
false
false
true
)
;
if
(
this
.
sharingBrowserWindow
)
{
let
browserWindowStreams
=
activeStreams
.
filter
(
stream
=
>
{
return
stream
.
devices
.
some
(
device
=
>
device
.
scary
)
;
}
)
;
this
.
stopSharingScreen
(
browserWindowStreams
)
;
}
else
{
this
.
stopSharingScreen
(
activeStreams
)
;
}
break
;
}
case
"
microphone
-
button
"
:
case
"
camera
-
button
"
:
{
let
activeStreams
=
webrtcUI
.
getActiveStreams
(
true
true
false
)
;
this
.
showSharingDoorhanger
(
activeStreams
)
;
break
;
}
case
"
minimize
"
:
{
window
.
minimize
(
)
;
break
;
}
}
}
stopSharingScreen
(
activeStreams
)
{
if
(
!
activeStreams
.
length
)
{
return
;
}
let
chosenStream
=
activeStreams
[
activeStreams
.
length
-
1
]
;
let
{
browser
}
=
chosenStream
;
let
gBrowser
=
browser
.
getTabBrowser
(
)
;
if
(
!
gBrowser
)
{
Cu
.
reportError
(
"
Can
'
t
stop
sharing
screen
-
cannot
find
gBrowser
.
"
)
;
return
;
}
let
tab
=
gBrowser
.
getTabForBrowser
(
browser
)
;
if
(
!
tab
)
{
Cu
.
reportError
(
"
Can
'
t
stop
sharing
screen
-
cannot
find
tab
.
"
)
;
return
;
}
let
permissions
=
SitePermissions
.
getAllPermissionDetailsForBrowser
(
browser
)
;
let
webrtcState
=
tab
.
_sharingState
.
webRTC
;
let
windowId
=
screen
:
{
webrtcState
.
windowId
}
;
if
(
webrtcState
.
screen
)
{
let
found
=
false
;
for
(
let
permission
of
permissions
)
{
if
(
permission
.
id
!
=
"
screen
"
)
{
continue
;
}
found
=
true
;
permission
.
sharingState
=
webrtcState
.
screen
;
break
;
}
if
(
!
found
)
{
permissions
.
push
(
{
id
:
"
screen
"
state
:
SitePermissions
.
ALLOW
scope
:
SitePermissions
.
SCOPE_REQUEST
sharingState
:
webrtcState
.
screen
}
)
;
}
}
let
permission
=
permissions
.
find
(
perm
=
>
{
return
perm
.
id
=
=
"
screen
"
;
}
)
;
if
(
!
permission
)
{
Cu
.
reportError
(
"
Can
'
t
stop
sharing
screen
-
cannot
find
screen
permission
.
"
)
;
return
;
}
let
bc
=
webrtcState
.
browsingContext
;
bc
.
currentWindowGlobal
.
getActor
(
"
WebRTC
"
)
.
sendAsyncMessage
(
"
webrtc
:
StopSharing
"
windowId
)
;
webrtcUI
.
forgetActivePermissionsFromBrowser
(
browser
)
;
SitePermissions
.
removeFromPrincipal
(
browser
.
contentPrincipal
permission
.
id
browser
)
;
}
showSharingDoorhanger
(
activeStreams
)
{
if
(
!
activeStreams
.
length
)
{
return
;
}
let
index
=
activeStreams
.
length
-
1
;
webrtcUI
.
showSharingDoorhanger
(
activeStreams
[
index
]
)
;
}
updateWindowAttr
(
attr
value
)
{
let
docEl
=
document
.
documentElement
;
if
(
value
)
{
docEl
.
setAttribute
(
attr
"
true
"
)
;
}
else
{
docEl
.
removeAttribute
(
attr
)
;
}
}
}
;
WebRTCIndicator
.
init
(
)
;
