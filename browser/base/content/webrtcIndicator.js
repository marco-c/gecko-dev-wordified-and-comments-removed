const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
const
{
webrtcUI
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
/
modules
/
webrtcUI
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
MacOSWebRTCStatusbarIndicator
"
"
resource
:
/
/
/
modules
/
webrtcUI
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
BrowserWindowTracker
"
"
resource
:
/
/
/
modules
/
BrowserWindowTracker
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PluralForm
"
"
resource
:
/
/
gre
/
modules
/
PluralForm
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
gScreenManager
"
"
mozilla
.
org
/
gfx
/
screenmanager
;
1
"
"
nsIScreenManager
"
)
;
function
updateIndicatorState
(
)
{
WebRTCIndicator
.
updateIndicatorState
(
)
;
}
function
closingInternally
(
)
{
WebRTCIndicator
.
closingInternally
(
)
;
}
const
WebRTCIndicator
=
{
init
(
event
)
{
addEventListener
(
"
load
"
this
)
;
addEventListener
(
"
unload
"
this
)
;
this
.
positionCustomized
=
false
;
this
.
updatingIndicatorState
=
false
;
this
.
loaded
=
false
;
this
.
isClosingInternally
=
false
;
this
.
statusBar
=
null
;
this
.
statusBarMenus
=
new
Set
(
)
;
this
.
showGlobalMuteToggles
=
Services
.
prefs
.
getBoolPref
(
"
privacy
.
webrtc
.
globalMuteToggles
"
false
)
;
this
.
hideGlobalIndicator
=
Services
.
prefs
.
getBoolPref
(
"
privacy
.
webrtc
.
hideGlobalIndicator
"
false
)
;
if
(
this
.
hideGlobalIndicator
)
{
this
.
setVisibility
(
false
)
;
}
}
setVisibility
(
isVisible
)
{
let
baseWin
=
window
.
docShell
.
treeOwner
.
QueryInterface
(
Ci
.
nsIBaseWindow
)
;
baseWin
.
visibility
=
isVisible
;
document
.
documentElement
.
setAttribute
(
"
visible
"
isVisible
)
;
document
.
documentElement
.
setAttribute
(
"
inwindowmenu
"
isVisible
)
;
}
updateIndicatorState
(
)
{
if
(
!
this
.
loaded
)
{
return
;
}
this
.
updatingIndicatorState
=
true
;
let
showCameraIndicator
=
webrtcUI
.
showCameraIndicator
;
let
showMicrophoneIndicator
=
webrtcUI
.
showMicrophoneIndicator
;
let
showScreenSharingIndicator
=
webrtcUI
.
showScreenSharingIndicator
;
if
(
this
.
statusBar
)
{
let
statusMenus
=
new
Map
(
[
[
"
Camera
"
showCameraIndicator
]
[
"
Microphone
"
showMicrophoneIndicator
]
[
"
Screen
"
showScreenSharingIndicator
]
]
)
;
for
(
let
[
name
shouldShow
]
of
statusMenus
)
{
let
menu
=
document
.
getElementById
(
webRTC
-
sharing
{
name
}
-
menu
)
;
if
(
shouldShow
&
&
!
this
.
statusBarMenus
.
has
(
menu
)
)
{
this
.
statusBar
.
addItem
(
menu
)
;
this
.
statusBarMenus
.
add
(
menu
)
;
}
else
if
(
!
shouldShow
&
&
this
.
statusBarMenus
.
has
(
menu
)
)
{
this
.
statusBar
.
removeItem
(
menu
)
;
this
.
statusBarMenus
.
delete
(
menu
)
;
}
}
}
if
(
!
this
.
showGlobalMuteToggles
&
&
!
webrtcUI
.
showScreenSharingIndicator
)
{
this
.
setVisibility
(
false
)
;
}
else
if
(
!
this
.
hideGlobalIndicator
)
{
this
.
setVisibility
(
true
)
;
}
if
(
this
.
showGlobalMuteToggles
)
{
this
.
updateWindowAttr
(
"
sharingvideo
"
showCameraIndicator
)
;
this
.
updateWindowAttr
(
"
sharingaudio
"
showMicrophoneIndicator
)
;
}
let
sharingScreen
=
showScreenSharingIndicator
.
startsWith
(
"
Screen
"
)
;
this
.
updateWindowAttr
(
"
sharingscreen
"
sharingScreen
)
;
let
sharingWindow
=
showScreenSharingIndicator
.
startsWith
(
"
Window
"
)
;
this
.
updateWindowAttr
(
"
sharingwindow
"
sharingWindow
)
;
if
(
sharingWindow
)
{
let
activeStreams
=
webrtcUI
.
getActiveStreams
(
false
false
false
true
)
;
let
hasBrowserWindow
=
activeStreams
.
some
(
stream
=
>
{
return
stream
.
devices
.
some
(
device
=
>
device
.
scary
)
;
}
)
;
this
.
updateWindowAttr
(
"
sharingbrowserwindow
"
hasBrowserWindow
)
;
this
.
sharingBrowserWindow
=
hasBrowserWindow
;
}
else
{
this
.
updateWindowAttr
(
"
sharingbrowserwindow
"
)
;
this
.
sharingBrowserWindow
=
false
;
}
let
displayShare
=
document
.
getElementById
(
"
display
-
share
"
)
;
let
labelledBy
;
if
(
sharingScreen
)
{
labelledBy
=
"
screen
-
share
-
info
"
;
}
else
if
(
this
.
sharingBrowserWindow
)
{
labelledBy
=
"
browser
-
window
-
share
-
info
"
;
}
else
if
(
sharingWindow
)
{
labelledBy
=
"
window
-
share
-
info
"
;
}
displayShare
.
setAttribute
(
"
aria
-
labelledby
"
labelledBy
)
;
if
(
window
.
windowState
!
=
window
.
STATE_MINIMIZED
)
{
let
docElStyle
=
document
.
documentElement
.
style
;
docElStyle
.
minWidth
=
docElStyle
.
maxWidth
=
"
unset
"
;
docElStyle
.
minHeight
=
docElStyle
.
maxHeight
=
"
unset
"
;
window
.
sizeToContent
(
)
;
if
(
AppConstants
.
platform
=
=
"
linux
"
)
{
let
{
width
height
}
=
window
.
windowUtils
.
getBoundsWithoutFlushing
(
document
.
documentElement
)
;
docElStyle
.
minWidth
=
docElStyle
.
maxWidth
=
{
width
}
px
;
docElStyle
.
minHeight
=
docElStyle
.
maxHeight
=
{
height
}
px
;
}
this
.
ensureOnScreen
(
)
;
if
(
!
this
.
positionCustomized
)
{
this
.
centerOnLatestBrowser
(
)
;
}
}
this
.
updatingIndicatorState
=
false
;
}
ensureOnScreen
(
)
{
let
desiredX
=
Math
.
max
(
window
.
screenX
screen
.
availLeft
)
;
let
maxX
=
screen
.
availLeft
+
screen
.
availWidth
-
document
.
documentElement
.
clientWidth
;
window
.
moveTo
(
Math
.
min
(
desiredX
maxX
)
window
.
screenY
)
;
}
centerOnLatestBrowser
(
)
{
let
activeStreams
=
webrtcUI
.
getActiveStreams
(
true
true
true
true
)
;
if
(
!
activeStreams
.
length
)
{
return
;
}
let
browser
=
activeStreams
[
activeStreams
.
length
-
1
]
.
browser
;
let
browserWindow
=
browser
.
ownerGlobal
;
let
browserRect
=
browserWindow
.
windowUtils
.
getBoundsWithoutFlushing
(
browser
)
;
let
{
width
:
windowWidth
}
=
window
.
windowUtils
.
getBoundsWithoutFlushing
(
document
.
documentElement
)
;
window
.
moveTo
(
browserWindow
.
mozInnerScreenX
+
browserRect
.
left
+
(
browserRect
.
width
-
windowWidth
)
/
2
browserWindow
.
mozInnerScreenY
+
browserRect
.
top
)
;
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
load
"
:
{
this
.
onLoad
(
)
;
break
;
}
case
"
unload
"
:
{
this
.
onUnload
(
)
;
break
;
}
case
"
click
"
:
{
this
.
onClick
(
event
)
;
break
;
}
case
"
change
"
:
{
this
.
onChange
(
event
)
;
break
;
}
case
"
MozUpdateWindowPos
"
:
{
if
(
!
this
.
updatingIndicatorState
)
{
this
.
positionCustomized
=
true
;
}
break
;
}
case
"
sizemodechange
"
:
{
if
(
window
.
windowState
!
=
window
.
STATE_MINIMIZED
)
{
this
.
updateIndicatorState
(
)
;
}
break
;
}
case
"
popupshowing
"
:
{
this
.
onPopupShowing
(
event
)
;
break
;
}
case
"
popuphiding
"
:
{
this
.
onPopupHiding
(
event
)
;
break
;
}
case
"
command
"
:
{
this
.
onCommand
(
event
)
;
break
;
}
case
"
DOMWindowClose
"
:
case
"
close
"
:
{
this
.
onClose
(
event
)
;
break
;
}
}
}
onLoad
(
)
{
this
.
loaded
=
true
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
|
|
AppConstants
.
platform
=
=
"
win
"
)
{
this
.
statusBar
=
Cc
[
"
mozilla
.
org
/
widget
/
systemstatusbar
;
1
"
]
.
getService
(
Ci
.
nsISystemStatusBar
)
;
}
this
.
updateIndicatorState
(
)
;
window
.
addEventListener
(
"
click
"
this
)
;
window
.
addEventListener
(
"
change
"
this
)
;
window
.
addEventListener
(
"
sizemodechange
"
this
)
;
window
.
addEventListener
(
"
DOMWindowClose
"
this
)
;
window
.
addEventListener
(
"
close
"
this
)
;
if
(
this
.
statusBar
)
{
window
.
addEventListener
(
"
popupshowing
"
this
)
;
window
.
addEventListener
(
"
popuphiding
"
this
)
;
window
.
addEventListener
(
"
command
"
this
)
;
}
window
.
windowRoot
.
addEventListener
(
"
MozUpdateWindowPos
"
this
)
;
let
ev
=
new
CustomEvent
(
"
AlertActive
"
{
bubbles
:
true
cancelable
:
true
}
)
;
document
.
documentElement
.
dispatchEvent
(
ev
)
;
this
.
loaded
=
true
;
}
onClose
(
event
)
{
if
(
!
this
.
showGlobalMuteToggles
&
&
(
webrtcUI
.
showCameraIndicator
|
|
webrtcUI
.
showMicrophoneIndicator
)
)
{
event
.
preventDefault
(
)
;
this
.
setVisibility
(
false
)
;
}
if
(
!
this
.
isClosingInternally
)
{
let
activeStreams
=
webrtcUI
.
getActiveStreams
(
this
.
showGlobalMuteToggles
this
.
showGlobalMuteToggles
true
true
)
;
webrtcUI
.
stopSharingStreams
(
activeStreams
this
.
showGlobalMuteToggles
this
.
showGlobalMuteToggles
true
true
)
;
}
}
onUnload
(
)
{
Services
.
ppmm
.
sharedData
.
set
(
"
WebRTC
:
GlobalCameraMute
"
false
)
;
Services
.
ppmm
.
sharedData
.
set
(
"
WebRTC
:
GlobalMicrophoneMute
"
false
)
;
Services
.
ppmm
.
sharedData
.
flush
(
)
;
if
(
this
.
statusBar
)
{
for
(
let
menu
of
this
.
statusBarMenus
)
{
this
.
statusBar
.
removeItem
(
menu
)
;
}
}
}
onClick
(
event
)
{
switch
(
event
.
target
.
id
)
{
case
"
stop
-
sharing
"
:
{
let
activeStreams
=
webrtcUI
.
getActiveStreams
(
false
false
true
true
)
;
if
(
!
activeStreams
.
length
)
{
return
;
}
webrtcUI
.
stopSharingStreams
(
activeStreams
false
false
true
true
)
;
break
;
}
case
"
minimize
"
:
{
window
.
minimize
(
)
;
break
;
}
}
}
onChange
(
event
)
{
switch
(
event
.
target
.
id
)
{
case
"
microphone
-
mute
-
toggle
"
:
{
this
.
toggleMicrophoneMute
(
event
.
target
)
;
break
;
}
case
"
camera
-
mute
-
toggle
"
:
{
this
.
toggleCameraMute
(
event
.
target
)
;
break
;
}
}
}
onPopupShowing
(
event
)
{
if
(
!
this
.
eventIsForDeviceMenuPopup
(
event
)
)
{
return
;
}
let
menupopup
=
event
.
target
;
let
type
=
menupopup
.
getAttribute
(
"
type
"
)
;
if
(
document
.
documentElement
.
getAttribute
(
"
visible
"
)
!
=
"
true
"
)
{
let
baseWin
=
window
.
docShell
.
treeOwner
.
QueryInterface
(
Ci
.
nsIBaseWindow
)
;
baseWin
.
visibility
=
false
;
}
let
activeStreams
;
if
(
type
=
=
"
Camera
"
)
{
activeStreams
=
webrtcUI
.
getActiveStreams
(
true
false
false
)
;
}
else
if
(
type
=
=
"
Microphone
"
)
{
activeStreams
=
webrtcUI
.
getActiveStreams
(
false
true
false
)
;
}
else
if
(
type
=
=
"
Screen
"
)
{
activeStreams
=
webrtcUI
.
getActiveStreams
(
false
false
true
true
)
;
type
=
webrtcUI
.
showScreenSharingIndicator
;
}
let
bundle
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
browser
/
locale
/
webrtcIndicator
.
properties
"
)
;
if
(
!
activeStreams
.
length
)
{
event
.
preventDefault
(
)
;
return
;
}
if
(
activeStreams
.
length
=
=
1
)
{
let
stream
=
activeStreams
[
0
]
;
let
menuitem
=
document
.
createXULElement
(
"
menuitem
"
)
;
let
labelId
=
webrtcIndicator
.
sharing
{
type
}
With
.
menuitem
;
let
label
=
stream
.
browser
.
contentTitle
|
|
stream
.
uri
;
menuitem
.
setAttribute
(
"
label
"
bundle
.
formatStringFromName
(
labelId
[
label
]
)
)
;
menuitem
.
setAttribute
(
"
disabled
"
"
true
"
)
;
menupopup
.
appendChild
(
menuitem
)
;
menuitem
=
document
.
createXULElement
(
"
menuitem
"
)
;
menuitem
.
setAttribute
(
"
label
"
bundle
.
GetStringFromName
(
"
webrtcIndicator
.
controlSharing
.
menuitem
"
)
)
;
menuitem
.
stream
=
stream
;
menupopup
.
appendChild
(
menuitem
)
;
return
;
}
let
menuitem
=
document
.
createXULElement
(
"
menuitem
"
)
;
let
labelId
=
webrtcIndicator
.
sharing
{
type
}
WithNTabs
.
menuitem
;
let
count
=
activeStreams
.
length
;
let
label
=
PluralForm
.
get
(
count
bundle
.
GetStringFromName
(
labelId
)
)
.
replace
(
"
#
1
"
count
)
;
menuitem
.
setAttribute
(
"
label
"
label
)
;
menuitem
.
setAttribute
(
"
disabled
"
"
true
"
)
;
menupopup
.
appendChild
(
menuitem
)
;
for
(
let
stream
of
activeStreams
)
{
let
item
=
document
.
createXULElement
(
"
menuitem
"
)
;
labelId
=
"
webrtcIndicator
.
controlSharingOn
.
menuitem
"
;
label
=
stream
.
browser
.
contentTitle
|
|
stream
.
uri
;
item
.
setAttribute
(
"
label
"
bundle
.
formatStringFromName
(
labelId
[
label
]
)
)
;
item
.
stream
=
stream
;
menupopup
.
appendChild
(
item
)
;
}
}
onPopupHiding
(
event
)
{
if
(
!
this
.
eventIsForDeviceMenuPopup
(
event
)
)
{
return
;
}
let
menu
=
event
.
target
;
while
(
menu
.
firstChild
)
{
menu
.
firstChild
.
remove
(
)
;
}
}
onCommand
(
event
)
{
webrtcUI
.
showSharingDoorhanger
(
event
.
target
.
stream
event
)
;
}
eventIsForDeviceMenuPopup
(
event
)
{
let
menupopup
=
event
.
target
;
let
type
=
menupopup
.
getAttribute
(
"
type
"
)
;
return
[
"
Camera
"
"
Microphone
"
"
Screen
"
]
.
includes
(
type
)
;
}
toggleMicrophoneMute
(
toggleEl
)
{
Services
.
ppmm
.
sharedData
.
set
(
"
WebRTC
:
GlobalMicrophoneMute
"
toggleEl
.
checked
)
;
Services
.
ppmm
.
sharedData
.
flush
(
)
;
let
l10nId
=
"
webrtc
-
microphone
-
"
+
(
toggleEl
.
checked
?
"
muted
"
:
"
unmuted
"
)
;
document
.
l10n
.
setAttributes
(
toggleEl
l10nId
)
;
}
toggleCameraMute
(
toggleEl
)
{
Services
.
ppmm
.
sharedData
.
set
(
"
WebRTC
:
GlobalCameraMute
"
toggleEl
.
checked
)
;
Services
.
ppmm
.
sharedData
.
flush
(
)
;
let
l10nId
=
"
webrtc
-
camera
-
"
+
(
toggleEl
.
checked
?
"
muted
"
:
"
unmuted
"
)
;
document
.
l10n
.
setAttributes
(
toggleEl
l10nId
)
;
}
updateWindowAttr
(
attr
value
)
{
let
docEl
=
document
.
documentElement
;
if
(
value
)
{
docEl
.
setAttribute
(
attr
"
true
"
)
;
}
else
{
docEl
.
removeAttribute
(
attr
)
;
}
}
closingInternally
(
)
{
this
.
isClosingInternally
=
true
;
}
}
;
WebRTCIndicator
.
init
(
)
;
