const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
webrtcUI
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
/
modules
/
webrtcUI
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
AppConstants
"
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
MacOSWebRTCStatusbarIndicator
"
"
resource
:
/
/
/
modules
/
webrtcUI
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
BrowserWindowTracker
"
"
resource
:
/
/
/
modules
/
BrowserWindowTracker
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
gScreenManager
"
"
mozilla
.
org
/
gfx
/
screenmanager
;
1
"
"
nsIScreenManager
"
)
;
function
updateIndicatorState
(
)
{
WebRTCIndicator
.
updateIndicatorState
(
)
;
}
function
closingInternally
(
)
{
WebRTCIndicator
.
closingInternally
(
)
;
}
const
WebRTCIndicator
=
{
init
(
event
)
{
addEventListener
(
"
load
"
this
)
;
addEventListener
(
"
unload
"
this
)
;
this
.
positionCustomized
=
false
;
this
.
updatingIndicatorState
=
false
;
this
.
loaded
=
false
;
this
.
isClosingInternally
=
false
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
this
.
macOSIndicator
=
new
MacOSWebRTCStatusbarIndicator
(
)
;
}
if
(
Services
.
prefs
.
getBoolPref
(
"
privacy
.
webrtc
.
hideGlobalIndicator
"
false
)
)
{
let
baseWin
=
window
.
docShell
.
treeOwner
.
QueryInterface
(
Ci
.
nsIBaseWindow
)
;
baseWin
.
visibility
=
false
;
}
}
updateIndicatorState
(
)
{
if
(
this
.
macOSIndicator
)
{
this
.
macOSIndicator
.
updateIndicatorState
(
)
;
}
if
(
!
this
.
loaded
)
{
return
;
}
this
.
updatingIndicatorState
=
true
;
this
.
updateWindowAttr
(
"
sharingvideo
"
webrtcUI
.
showCameraIndicator
)
;
this
.
updateWindowAttr
(
"
sharingaudio
"
webrtcUI
.
showMicrophoneIndicator
)
;
let
sharingScreen
=
webrtcUI
.
showScreenSharingIndicator
.
startsWith
(
"
Screen
"
)
;
this
.
updateWindowAttr
(
"
sharingscreen
"
sharingScreen
)
;
let
sharingWindow
=
webrtcUI
.
showScreenSharingIndicator
.
startsWith
(
"
Window
"
)
;
this
.
updateWindowAttr
(
"
sharingwindow
"
sharingWindow
)
;
if
(
sharingWindow
)
{
let
activeStreams
=
webrtcUI
.
getActiveStreams
(
false
false
false
true
)
;
let
hasBrowserWindow
=
activeStreams
.
some
(
stream
=
>
{
return
stream
.
devices
.
some
(
device
=
>
device
.
scary
)
;
}
)
;
this
.
updateWindowAttr
(
"
sharingbrowserwindow
"
hasBrowserWindow
)
;
this
.
sharingBrowserWindow
=
hasBrowserWindow
;
}
else
{
this
.
updateWindowAttr
(
"
sharingbrowserwindow
"
)
;
this
.
sharingBrowserWindow
=
false
;
}
let
displayShare
=
document
.
getElementById
(
"
display
-
share
"
)
;
let
labelledBy
;
if
(
sharingScreen
)
{
labelledBy
=
"
screen
-
share
-
info
"
;
}
else
if
(
this
.
sharingBrowserWindow
)
{
labelledBy
=
"
browser
-
window
-
share
-
info
"
;
}
else
if
(
sharingWindow
)
{
labelledBy
=
"
window
-
share
-
info
"
;
}
displayShare
.
setAttribute
(
"
aria
-
labelledby
"
labelledBy
)
;
if
(
window
.
windowState
!
=
window
.
STATE_MINIMIZED
)
{
let
docElStyle
=
document
.
documentElement
.
style
;
docElStyle
.
minWidth
=
docElStyle
.
maxWidth
=
"
unset
"
;
docElStyle
.
minHeight
=
docElStyle
.
maxHeight
=
"
unset
"
;
window
.
sizeToContent
(
)
;
if
(
AppConstants
.
platform
=
=
"
linux
"
)
{
let
{
width
height
}
=
window
.
windowUtils
.
getBoundsWithoutFlushing
(
document
.
documentElement
)
;
docElStyle
.
minWidth
=
docElStyle
.
maxWidth
=
{
width
}
px
;
docElStyle
.
minHeight
=
docElStyle
.
maxHeight
=
{
height
}
px
;
}
this
.
ensureOnScreen
(
)
;
if
(
!
this
.
positionCustomized
)
{
this
.
centerOnLatestBrowser
(
)
;
}
}
this
.
updatingIndicatorState
=
false
;
}
ensureOnScreen
(
)
{
let
desiredX
=
Math
.
max
(
window
.
screenX
screen
.
availLeft
)
;
let
maxX
=
screen
.
availLeft
+
screen
.
availWidth
-
document
.
documentElement
.
clientWidth
;
window
.
moveTo
(
Math
.
min
(
desiredX
maxX
)
window
.
screenY
)
;
}
centerOnLatestBrowser
(
)
{
let
activeStreams
=
webrtcUI
.
getActiveStreams
(
true
true
true
true
)
;
if
(
!
activeStreams
.
length
)
{
return
;
}
let
browser
=
activeStreams
[
activeStreams
.
length
-
1
]
.
browser
;
let
browserWindow
=
browser
.
ownerGlobal
;
let
browserRect
=
browserWindow
.
windowUtils
.
getBoundsWithoutFlushing
(
browser
)
;
let
{
width
:
windowWidth
}
=
window
.
windowUtils
.
getBoundsWithoutFlushing
(
document
.
documentElement
)
;
window
.
moveTo
(
browserWindow
.
mozInnerScreenX
+
browserRect
.
left
+
(
browserRect
.
width
-
windowWidth
)
/
2
browserWindow
.
mozInnerScreenY
+
browserRect
.
top
)
;
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
load
"
:
{
this
.
onLoad
(
)
;
break
;
}
case
"
unload
"
:
{
this
.
onUnload
(
)
;
break
;
}
case
"
click
"
:
{
this
.
onClick
(
event
)
;
break
;
}
case
"
MozUpdateWindowPos
"
:
{
if
(
!
this
.
updatingIndicatorState
)
{
this
.
positionCustomized
=
true
;
}
break
;
}
case
"
sizemodechange
"
:
{
if
(
window
.
windowState
!
=
window
.
STATE_MINIMIZED
)
{
this
.
updateIndicatorState
(
)
;
}
break
;
}
}
}
onLoad
(
)
{
this
.
loaded
=
true
;
this
.
updateIndicatorState
(
)
;
window
.
addEventListener
(
"
click
"
this
)
;
window
.
addEventListener
(
"
sizemodechange
"
this
)
;
window
.
windowRoot
.
addEventListener
(
"
MozUpdateWindowPos
"
this
)
;
let
ev
=
new
CustomEvent
(
"
AlertActive
"
{
bubbles
:
true
cancelable
:
true
}
)
;
document
.
documentElement
.
dispatchEvent
(
ev
)
;
this
.
loaded
=
true
;
}
onUnload
(
)
{
if
(
this
.
macOSIndicator
)
{
this
.
macOSIndicator
.
close
(
)
;
this
.
macOSIndicator
=
null
;
}
if
(
!
this
.
isClosingInternally
)
{
let
activeStreams
=
webrtcUI
.
getActiveStreams
(
true
true
true
true
)
;
webrtcUI
.
stopSharingStreams
(
activeStreams
)
;
}
}
onClick
(
event
)
{
switch
(
event
.
target
.
id
)
{
case
"
stop
-
sharing
"
:
{
let
activeStreams
=
webrtcUI
.
getActiveStreams
(
false
false
true
true
)
;
if
(
!
activeStreams
.
length
)
{
return
;
}
webrtcUI
.
stopSharingStreams
(
activeStreams
false
false
true
true
)
;
break
;
}
case
"
microphone
-
button
"
:
case
"
camera
-
button
"
:
{
let
activeStreams
=
webrtcUI
.
getActiveStreams
(
true
true
false
)
;
this
.
showSharingDoorhanger
(
activeStreams
)
;
break
;
}
case
"
minimize
"
:
{
window
.
minimize
(
)
;
break
;
}
}
}
showSharingDoorhanger
(
activeStreams
)
{
if
(
!
activeStreams
.
length
)
{
return
;
}
let
index
=
activeStreams
.
length
-
1
;
webrtcUI
.
showSharingDoorhanger
(
activeStreams
[
index
]
)
;
}
updateWindowAttr
(
attr
value
)
{
let
docEl
=
document
.
documentElement
;
if
(
value
)
{
docEl
.
setAttribute
(
attr
"
true
"
)
;
}
else
{
docEl
.
removeAttribute
(
attr
)
;
}
}
closingInternally
(
)
{
this
.
isClosingInternally
=
true
;
}
}
;
WebRTCIndicator
.
init
(
)
;
