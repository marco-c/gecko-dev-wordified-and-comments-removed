"
use
strict
"
;
var
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
FxAccounts
.
jsm
"
)
;
var
fxAccountsCommon
=
{
}
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
FxAccountsCommon
.
js
"
fxAccountsCommon
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
sync
/
util
.
js
"
)
;
const
ACTION_URL_PARAM
=
"
action
"
;
const
OBSERVER_TOPICS
=
[
fxAccountsCommon
.
ONVERIFIED_NOTIFICATION
fxAccountsCommon
.
ONLOGOUT_NOTIFICATION
]
;
function
log
(
msg
)
{
}
function
updateDisplayedEmail
(
user
)
{
let
emailDiv
=
document
.
getElementById
(
"
email
"
)
;
if
(
emailDiv
&
&
user
)
{
emailDiv
.
textContent
=
user
.
email
;
}
}
var
wrapper
=
{
iframe
:
null
init
(
url
urlParams
)
{
Utils
.
ensureMPUnlocked
(
)
;
let
iframe
=
document
.
getElementById
(
"
remote
"
)
;
this
.
iframe
=
iframe
;
let
docShell
=
this
.
iframe
.
frameLoader
.
docShell
;
docShell
.
QueryInterface
(
Ci
.
nsIWebProgress
)
;
docShell
.
addProgressListener
(
this
.
iframeListener
Ci
.
nsIWebProgress
.
NOTIFY_STATE_DOCUMENT
|
Ci
.
nsIWebProgress
.
NOTIFY_LOCATION
)
;
let
urlParamStr
=
urlParams
.
toString
(
)
;
if
(
urlParamStr
)
{
url
+
=
(
url
.
includes
(
"
?
"
)
?
"
&
"
:
"
?
"
)
+
urlParamStr
;
}
this
.
url
=
url
;
let
webNav
=
iframe
.
frameLoader
.
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
;
webNav
.
loadURI
(
url
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_REPLACE_HISTORY
null
null
null
)
;
}
retry
(
)
{
let
webNav
=
this
.
iframe
.
frameLoader
.
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
;
webNav
.
loadURI
(
this
.
url
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_BYPASS_HISTORY
null
null
null
)
;
}
iframeListener
:
{
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIWebProgressListener
Ci
.
nsISupportsWeakReference
Ci
.
nsISupports
]
)
onStateChange
(
aWebProgress
aRequest
aState
aStatus
)
{
let
failure
=
false
;
if
(
(
aState
&
Ci
.
nsIWebProgressListener
.
STATE_REDIRECTING
)
)
{
failure
=
true
;
}
else
if
(
(
aState
&
Ci
.
nsIWebProgressListener
.
STATE_STOP
)
)
{
if
(
aRequest
instanceof
Ci
.
nsIHttpChannel
)
{
try
{
failure
=
aRequest
.
responseStatus
!
=
200
;
}
catch
(
e
)
{
failure
=
aStatus
!
=
Components
.
results
.
NS_OK
;
}
}
}
if
(
failure
&
&
aStatus
!
=
Components
.
results
.
NS_BINDING_ABORTED
)
{
aRequest
.
cancel
(
Components
.
results
.
NS_BINDING_ABORTED
)
;
setErrorPage
(
"
networkError
"
)
;
}
}
onLocationChange
(
aWebProgress
aRequest
aLocation
aFlags
)
{
if
(
aRequest
&
&
aFlags
&
Ci
.
nsIWebProgressListener
.
LOCATION_CHANGE_ERROR_PAGE
)
{
aRequest
.
cancel
(
Components
.
results
.
NS_BINDING_ABORTED
)
;
setErrorPage
(
"
networkError
"
)
;
}
}
}
}
;
function
getStarted
(
)
{
show
(
"
remote
"
)
;
}
function
retry
(
)
{
show
(
"
remote
"
)
;
wrapper
.
retry
(
)
;
}
function
openPrefs
(
)
{
window
.
location
=
"
about
:
preferences
#
sync
"
;
}
function
init
(
)
{
fxAccounts
.
getSignedInUser
(
)
.
then
(
user
=
>
{
if
(
window
.
closed
)
{
return
Promise
.
resolve
(
)
;
}
updateDisplayedEmail
(
user
)
;
let
urlParams
=
new
URLSearchParams
(
document
.
URL
.
split
(
"
?
"
)
[
1
]
|
|
"
"
)
;
let
action
=
urlParams
.
get
(
ACTION_URL_PARAM
)
;
urlParams
.
delete
(
ACTION_URL_PARAM
)
;
switch
(
action
)
{
case
"
signin
"
:
if
(
user
)
{
show
(
"
stage
"
"
manage
"
)
;
}
else
{
return
fxAccounts
.
promiseAccountsSignInURI
(
)
.
then
(
url
=
>
{
show
(
"
remote
"
)
;
wrapper
.
init
(
url
urlParams
)
;
}
)
;
}
break
;
case
"
signup
"
:
if
(
user
)
{
show
(
"
stage
"
"
manage
"
)
;
}
else
{
return
fxAccounts
.
promiseAccountsSignUpURI
(
)
.
then
(
url
=
>
{
show
(
"
remote
"
)
;
wrapper
.
init
(
url
urlParams
)
;
}
)
;
}
break
;
case
"
reauth
"
:
return
fxAccounts
.
promiseAccountsForceSigninURI
(
)
.
then
(
url
=
>
{
show
(
"
remote
"
)
;
wrapper
.
init
(
url
urlParams
)
;
}
)
;
default
:
if
(
user
)
{
show
(
"
stage
"
"
manage
"
)
;
}
else
{
return
migrateToDevEdition
(
urlParams
)
.
then
(
migrated
=
>
{
if
(
!
migrated
)
{
show
(
"
stage
"
"
intro
"
)
;
return
fxAccounts
.
promiseAccountsSignUpURI
(
)
.
then
(
uri
=
>
wrapper
.
init
(
uri
urlParams
)
)
;
}
return
Promise
.
resolve
(
)
;
}
)
;
}
break
;
}
return
Promise
.
resolve
(
)
;
}
)
.
catch
(
err
=
>
{
console
.
log
(
"
Configuration
or
sign
in
error
"
err
)
;
setErrorPage
(
"
configError
"
)
;
}
)
;
}
function
setErrorPage
(
errorType
)
{
show
(
"
stage
"
errorType
)
;
}
function
show
(
id
childId
)
{
let
allTop
=
document
.
querySelectorAll
(
"
body
>
div
iframe
"
)
;
for
(
let
elt
of
allTop
)
{
if
(
elt
.
getAttribute
(
"
id
"
)
=
=
id
)
{
elt
.
style
.
display
=
"
block
"
;
}
else
{
elt
.
style
.
display
=
"
none
"
;
}
}
if
(
childId
)
{
let
allSecond
=
document
.
querySelectorAll
(
"
#
"
+
id
+
"
>
div
"
)
;
for
(
let
elt
of
allSecond
)
{
if
(
elt
.
getAttribute
(
"
id
"
)
=
=
childId
)
{
elt
.
style
.
display
=
"
block
"
;
}
else
{
elt
.
style
.
display
=
"
none
"
;
}
}
}
}
function
migrateToDevEdition
(
urlParams
)
{
let
defaultProfilePath
;
try
{
defaultProfilePath
=
window
.
getDefaultProfilePath
(
)
;
}
catch
(
e
)
{
}
if
(
!
defaultProfilePath
|
|
!
Services
.
prefs
.
getBoolPref
(
"
identity
.
fxaccounts
.
migrateToDevEdition
"
false
)
)
{
return
Promise
.
resolve
(
false
)
;
}
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
let
fxAccountsStorage
=
OS
.
Path
.
join
(
defaultProfilePath
fxAccountsCommon
.
DEFAULT_STORAGE_FILENAME
)
;
return
OS
.
File
.
read
(
fxAccountsStorage
{
encoding
:
"
utf
-
8
"
}
)
.
then
(
text
=
>
{
let
accountData
=
JSON
.
parse
(
text
)
.
accountData
;
updateDisplayedEmail
(
accountData
)
;
return
fxAccounts
.
setSignedInUser
(
accountData
)
;
}
)
.
then
(
(
)
=
>
{
return
fxAccounts
.
promiseAccountsForceSigninURI
(
)
.
then
(
url
=
>
{
show
(
"
remote
"
)
;
wrapper
.
init
(
url
urlParams
)
;
}
)
;
}
)
.
catch
(
error
=
>
{
log
(
"
Failed
to
migrate
FX
Account
:
"
+
error
)
;
show
(
"
stage
"
"
intro
"
)
;
fxAccounts
.
promiseAccountsSignUpURI
(
)
.
then
(
uri
=
>
{
wrapper
.
init
(
uri
urlParams
)
}
)
.
catch
(
e
=
>
{
console
.
log
(
"
Failed
to
load
signup
page
"
e
)
;
setErrorPage
(
"
configError
"
)
;
}
)
;
}
)
.
then
(
(
)
=
>
{
Services
.
prefs
.
setBoolPref
(
"
identity
.
fxaccounts
.
migrateToDevEdition
"
false
)
;
return
true
;
}
)
.
catch
(
err
=
>
{
Cu
.
reportError
(
"
Failed
to
reset
the
migrateToDevEdition
pref
:
"
+
err
)
;
return
false
;
}
)
;
}
function
getDefaultProfilePath
(
)
{
let
defaultProfile
=
Cc
[
"
mozilla
.
org
/
toolkit
/
profile
-
service
;
1
"
]
.
getService
(
Ci
.
nsIToolkitProfileService
)
.
defaultProfile
;
return
defaultProfile
.
rootDir
.
path
;
}
document
.
addEventListener
(
"
DOMContentLoaded
"
function
(
)
{
init
(
)
;
var
buttonGetStarted
=
document
.
getElementById
(
"
buttonGetStarted
"
)
;
buttonGetStarted
.
addEventListener
(
"
click
"
getStarted
)
;
var
buttonRetry
=
document
.
getElementById
(
"
buttonRetry
"
)
;
buttonRetry
.
addEventListener
(
"
click
"
retry
)
;
var
buttonOpenPrefs
=
document
.
getElementById
(
"
buttonOpenPrefs
"
)
;
buttonOpenPrefs
.
addEventListener
(
"
click
"
openPrefs
)
;
}
{
capture
:
true
once
:
true
}
)
;
function
initObservers
(
)
{
function
observe
(
subject
topic
data
)
{
log
(
"
about
:
accounts
observed
"
+
topic
)
;
if
(
topic
=
=
fxAccountsCommon
.
ONLOGOUT_NOTIFICATION
)
{
window
.
location
=
"
about
:
accounts
?
action
=
signin
"
;
return
;
}
openPrefs
(
)
;
}
for
(
let
topic
of
OBSERVER_TOPICS
)
{
Services
.
obs
.
addObserver
(
observe
topic
)
;
}
window
.
addEventListener
(
"
unload
"
function
(
event
)
{
log
(
"
about
:
accounts
unloading
"
)
for
(
let
topic
of
OBSERVER_TOPICS
)
{
Services
.
obs
.
removeObserver
(
observe
topic
)
;
}
}
)
;
}
initObservers
(
)
;
