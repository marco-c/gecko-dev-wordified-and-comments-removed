var
TabsInTitlebar
=
{
init
:
function
(
)
{
this
.
_readPref
(
)
;
Services
.
prefs
.
addObserver
(
this
.
_prefName
this
false
)
;
let
menu
=
document
.
getElementById
(
"
toolbar
-
menubar
"
)
;
this
.
_menuObserver
=
new
MutationObserver
(
this
.
_onMenuMutate
)
;
this
.
_menuObserver
.
observe
(
menu
{
attributes
:
true
}
)
;
this
.
onAreaReset
=
function
(
aArea
)
{
if
(
aArea
=
=
CustomizableUI
.
AREA_TABSTRIP
|
|
aArea
=
=
CustomizableUI
.
AREA_MENUBAR
)
this
.
_update
(
true
)
;
}
;
this
.
onWidgetAdded
=
this
.
onWidgetRemoved
=
function
(
aWidgetId
aArea
)
{
if
(
aArea
=
=
CustomizableUI
.
AREA_TABSTRIP
|
|
aArea
=
=
CustomizableUI
.
AREA_MENUBAR
)
this
.
_update
(
true
)
;
}
;
CustomizableUI
.
addListener
(
this
)
;
this
.
_initialized
=
true
;
}
allowedBy
:
function
(
condition
allow
)
{
if
(
allow
)
{
if
(
condition
in
this
.
_disallowed
)
{
delete
this
.
_disallowed
[
condition
]
;
this
.
_update
(
true
)
;
}
}
else
{
if
(
!
(
condition
in
this
.
_disallowed
)
)
{
this
.
_disallowed
[
condition
]
=
null
;
this
.
_update
(
true
)
;
}
}
}
updateAppearance
:
function
updateAppearance
(
aForce
)
{
this
.
_update
(
aForce
)
;
}
get
enabled
(
)
{
return
document
.
documentElement
.
getAttribute
(
"
tabsintitlebar
"
)
=
=
"
true
"
;
}
observe
:
function
(
subject
topic
data
)
{
if
(
topic
=
=
"
nsPref
:
changed
"
)
this
.
_readPref
(
)
;
}
_onMenuMutate
:
function
(
aMutations
)
{
for
(
let
mutation
of
aMutations
)
{
if
(
mutation
.
attributeName
=
=
"
inactive
"
|
|
mutation
.
attributeName
=
=
"
autohide
"
)
{
TabsInTitlebar
.
_update
(
true
)
;
return
;
}
}
}
_initialized
:
false
_disallowed
:
{
}
_prefName
:
"
browser
.
tabs
.
drawInTitlebar
"
_lastSizeMode
:
null
haveUpdatedTitlebarDisplay
:
false
_readPref
:
function
(
)
{
this
.
allowedBy
(
"
pref
"
Services
.
prefs
.
getBoolPref
(
this
.
_prefName
)
)
;
}
_update
:
function
(
aForce
=
false
)
{
let
=
id
=
>
document
.
getElementById
(
id
)
;
let
rect
=
ele
=
>
ele
.
getBoundingClientRect
(
)
;
let
verticalMargins
=
cstyle
=
>
parseFloat
(
cstyle
.
marginBottom
)
+
parseFloat
(
cstyle
.
marginTop
)
;
if
(
!
this
.
_initialized
|
|
window
.
fullScreen
)
return
;
let
allowed
=
true
;
if
(
!
aForce
)
{
let
sizemode
=
document
.
documentElement
.
getAttribute
(
"
sizemode
"
)
;
if
(
this
.
_lastSizeMode
=
=
sizemode
)
{
return
;
}
let
oldSizeMode
=
this
.
_lastSizeMode
;
this
.
_lastSizeMode
=
sizemode
;
if
(
oldSizeMode
=
=
"
fullscreen
"
)
{
return
;
}
}
for
(
let
something
in
this
.
_disallowed
)
{
allowed
=
false
;
break
;
}
let
titlebar
=
(
"
titlebar
"
)
;
let
titlebarContent
=
(
"
titlebar
-
content
"
)
;
let
menubar
=
(
"
toolbar
-
menubar
"
)
;
if
(
allowed
)
{
document
.
documentElement
.
setAttribute
(
"
tabsintitlebar
"
"
true
"
)
;
updateTitlebarDisplay
(
)
;
let
tabsToolbar
=
(
"
TabsToolbar
"
)
;
let
tabsStyles
=
window
.
getComputedStyle
(
tabsToolbar
)
;
let
fullTabsHeight
=
rect
(
tabsToolbar
)
.
height
+
verticalMargins
(
tabsStyles
)
;
let
captionButtonsBoxWidth
=
rect
(
(
"
titlebar
-
buttonbox
-
container
"
)
)
.
width
;
let
secondaryButtonsWidth
menuHeight
fullMenuHeight
menuStyles
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
secondaryButtonsWidth
=
rect
(
(
"
titlebar
-
secondary
-
buttonbox
"
)
)
.
width
;
menuHeight
=
0
;
fullMenuHeight
=
0
;
}
else
{
menuHeight
=
rect
(
menubar
)
.
height
;
menuStyles
=
window
.
getComputedStyle
(
menubar
)
;
fullMenuHeight
=
verticalMargins
(
menuStyles
)
+
menuHeight
;
}
let
titlebarContentHeight
=
rect
(
titlebarContent
)
.
height
;
if
(
menuHeight
)
{
let
menuTitlebarDelta
=
titlebarContentHeight
-
fullMenuHeight
;
let
paddingBottom
;
if
(
menuTitlebarDelta
>
0
)
{
fullMenuHeight
+
=
menuTitlebarDelta
;
if
(
(
paddingBottom
=
menuStyles
.
paddingBottom
)
)
{
menuTitlebarDelta
+
=
parseFloat
(
paddingBottom
)
;
}
menubar
.
style
.
paddingBottom
=
menuTitlebarDelta
+
"
px
"
;
}
else
if
(
menuTitlebarDelta
<
0
&
&
(
paddingBottom
=
menuStyles
.
paddingBottom
)
)
{
let
existingPadding
=
parseFloat
(
paddingBottom
)
;
let
desiredPadding
=
Math
.
max
(
0
existingPadding
+
menuTitlebarDelta
)
;
menubar
.
style
.
paddingBottom
=
desiredPadding
+
"
px
"
;
fullMenuHeight
+
=
desiredPadding
-
existingPadding
;
}
}
let
tabAndMenuHeight
=
fullTabsHeight
+
fullMenuHeight
;
if
(
tabAndMenuHeight
>
titlebarContentHeight
)
{
let
extraMargin
=
tabAndMenuHeight
-
titlebarContentHeight
;
if
(
AppConstants
.
platform
!
=
"
macosx
"
)
{
titlebarContent
.
style
.
marginBottom
=
extraMargin
+
"
px
"
;
}
titlebarContentHeight
+
=
extraMargin
;
}
else
{
titlebarContent
.
style
.
removeProperty
(
"
margin
-
bottom
"
)
;
}
titlebar
.
style
.
marginBottom
=
"
-
"
+
titlebarContentHeight
+
"
px
"
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
this
.
_sizePlaceholder
(
"
fullscreen
-
button
"
secondaryButtonsWidth
)
;
}
this
.
_sizePlaceholder
(
"
caption
-
buttons
"
captionButtonsBoxWidth
)
;
if
(
!
this
.
_draghandles
)
{
this
.
_draghandles
=
{
}
;
let
tmp
=
{
}
;
Components
.
utils
.
import
(
"
resource
:
/
/
gre
/
modules
/
WindowDraggingUtils
.
jsm
"
tmp
)
;
let
mouseDownCheck
=
function
(
)
{
return
!
this
.
_dragBindingAlive
&
&
TabsInTitlebar
.
enabled
;
}
;
this
.
_draghandles
.
tabsToolbar
=
new
tmp
.
WindowDraggingElement
(
tabsToolbar
)
;
this
.
_draghandles
.
tabsToolbar
.
mouseDownCheck
=
mouseDownCheck
;
this
.
_draghandles
.
navToolbox
=
new
tmp
.
WindowDraggingElement
(
gNavToolbox
)
;
this
.
_draghandles
.
navToolbox
.
mouseDownCheck
=
mouseDownCheck
;
}
}
else
{
document
.
documentElement
.
removeAttribute
(
"
tabsintitlebar
"
)
;
updateTitlebarDisplay
(
)
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
let
secondaryButtonsWidth
=
rect
(
(
"
titlebar
-
secondary
-
buttonbox
"
)
)
.
width
;
this
.
_sizePlaceholder
(
"
fullscreen
-
button
"
secondaryButtonsWidth
)
;
}
titlebarContent
.
style
.
marginTop
=
"
"
;
titlebarContent
.
style
.
marginBottom
=
"
"
;
titlebar
.
style
.
marginBottom
=
"
"
;
menubar
.
style
.
paddingBottom
=
"
"
;
}
ToolbarIconColor
.
inferFromText
(
)
;
if
(
CustomizationHandler
.
isCustomizing
(
)
)
{
gCustomizeMode
.
updateLWTStyling
(
)
;
}
}
_sizePlaceholder
:
function
(
type
width
)
{
Array
.
forEach
(
document
.
querySelectorAll
(
"
.
titlebar
-
placeholder
[
type
=
'
"
+
type
+
"
'
]
"
)
function
(
node
)
{
node
.
width
=
width
;
}
)
;
}
uninit
:
function
(
)
{
this
.
_initialized
=
false
;
Services
.
prefs
.
removeObserver
(
this
.
_prefName
this
)
;
this
.
_menuObserver
.
disconnect
(
)
;
CustomizableUI
.
removeListener
(
this
)
;
}
}
;
function
updateTitlebarDisplay
(
)
{
if
(
!
TabsInTitlebar
.
haveUpdatedTitlebarDisplay
)
{
if
(
AppConstants
.
platform
=
=
"
win
"
&
&
Services
.
focus
.
activeWindow
!
=
window
)
{
if
(
!
TabsInTitlebar
.
_titlebarUpdateListener
)
{
TabsInTitlebar
.
_titlebarUpdateListener
=
e
=
>
{
window
.
removeEventListener
(
"
activate
"
TabsInTitlebar
.
_titlebarUpdateListener
)
;
updateTitlebarDisplay
(
)
;
}
;
window
.
addEventListener
(
"
activate
"
TabsInTitlebar
.
_titlebarUpdateListener
)
;
}
return
;
}
TabsInTitlebar
.
haveUpdatedTitlebarDisplay
=
true
;
}
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
if
(
TabsInTitlebar
.
enabled
)
{
document
.
documentElement
.
setAttribute
(
"
chromemargin
-
nonlwtheme
"
"
0
-
1
-
1
-
1
"
)
;
document
.
documentElement
.
setAttribute
(
"
chromemargin
"
"
0
-
1
-
1
-
1
"
)
;
document
.
documentElement
.
removeAttribute
(
"
drawtitle
"
)
;
}
else
{
document
.
documentElement
.
setAttribute
(
"
chromemargin
-
nonlwtheme
"
"
"
)
;
let
isCustomizing
=
document
.
documentElement
.
hasAttribute
(
"
customizing
"
)
;
let
hasLWTheme
=
document
.
documentElement
.
hasAttribute
(
"
lwtheme
"
)
;
let
isPrivate
=
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
;
if
(
(
!
hasLWTheme
|
|
isCustomizing
)
&
&
!
isPrivate
)
{
document
.
documentElement
.
removeAttribute
(
"
chromemargin
"
)
;
}
document
.
documentElement
.
setAttribute
(
"
drawtitle
"
"
true
"
)
;
}
}
else
{
if
(
TabsInTitlebar
.
enabled
)
document
.
documentElement
.
setAttribute
(
"
chromemargin
"
"
0
2
2
2
"
)
;
else
document
.
documentElement
.
removeAttribute
(
"
chromemargin
"
)
;
}
}
function
onTitlebarMaxClick
(
)
{
if
(
window
.
windowState
=
=
window
.
STATE_MAXIMIZED
)
window
.
restore
(
)
;
else
window
.
maximize
(
)
;
}
