var
BrowserPageActions
=
{
get
mainButtonNode
(
)
{
delete
this
.
mainButtonNode
;
return
this
.
mainButtonNode
=
document
.
getElementById
(
"
pageActionButton
"
)
;
}
get
panelNode
(
)
{
delete
this
.
panelNode
;
return
this
.
panelNode
=
document
.
getElementById
(
"
pageActionPanel
"
)
;
}
get
multiViewNode
(
)
{
delete
this
.
multiViewNode
;
return
this
.
multiViewNode
=
document
.
getElementById
(
"
pageActionPanelMultiView
"
)
;
}
get
mainViewNode
(
)
{
delete
this
.
mainViewNode
;
return
this
.
mainViewNode
=
document
.
getElementById
(
"
pageActionPanelMainView
"
)
;
}
get
mainViewBodyNode
(
)
{
delete
this
.
mainViewBodyNode
;
return
this
.
mainViewBodyNode
=
this
.
mainViewNode
.
querySelector
(
"
.
panel
-
subview
-
body
"
)
;
}
init
(
)
{
this
.
placeAllActions
(
)
;
}
placeAllActions
(
)
{
for
(
let
action
of
PageActions
.
actions
)
{
action
.
onBeforePlacedInWindow
(
window
)
;
this
.
placeActionInPanel
(
action
)
;
}
let
actionsInUrlbar
=
PageActions
.
actionsInUrlbar
(
window
)
;
for
(
let
i
=
actionsInUrlbar
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
let
action
=
actionsInUrlbar
[
i
]
;
this
.
placeActionInUrlbar
(
action
)
;
}
}
placeAction
(
action
)
{
action
.
onBeforePlacedInWindow
(
window
)
;
this
.
placeActionInPanel
(
action
)
;
this
.
placeActionInUrlbar
(
action
)
;
}
placeActionInPanel
(
action
)
{
let
id
=
this
.
panelButtonNodeIDForActionID
(
action
.
id
)
;
let
node
=
document
.
getElementById
(
id
)
;
if
(
!
node
)
{
let
panelViewNode
;
[
node
panelViewNode
]
=
this
.
_makePanelButtonNodeForAction
(
action
)
;
node
.
id
=
id
;
let
insertBeforeID
=
PageActions
.
nextActionIDInPanel
(
action
)
;
let
insertBeforeNode
=
insertBeforeID
?
this
.
panelButtonNodeForActionID
(
insertBeforeID
)
:
null
;
this
.
mainViewBodyNode
.
insertBefore
(
node
insertBeforeNode
)
;
this
.
updateAction
(
action
)
;
this
.
_updateActionDisabledInPanel
(
action
)
;
action
.
onPlacedInPanel
(
node
)
;
if
(
panelViewNode
)
{
action
.
subview
.
onPlaced
(
panelViewNode
)
;
}
}
}
_makePanelButtonNodeForAction
(
action
)
{
if
(
action
.
__isSeparator
)
{
let
node
=
document
.
createElement
(
"
toolbarseparator
"
)
;
return
[
node
null
]
;
}
let
buttonNode
=
document
.
createElement
(
"
toolbarbutton
"
)
;
buttonNode
.
classList
.
add
(
"
subviewbutton
"
"
subviewbutton
-
iconic
"
"
pageAction
-
panel
-
button
"
)
;
buttonNode
.
setAttribute
(
"
actionid
"
action
.
id
)
;
if
(
action
.
nodeAttributes
)
{
for
(
let
name
in
action
.
nodeAttributes
)
{
buttonNode
.
setAttribute
(
name
action
.
nodeAttributes
[
name
]
)
;
}
}
let
panelViewNode
=
null
;
if
(
action
.
subview
)
{
buttonNode
.
classList
.
add
(
"
subviewbutton
-
nav
"
)
;
panelViewNode
=
this
.
_makePanelViewNodeForAction
(
action
false
)
;
this
.
multiViewNode
.
_panelViews
=
null
;
this
.
multiViewNode
.
appendChild
(
panelViewNode
)
;
}
buttonNode
.
addEventListener
(
"
command
"
event
=
>
{
this
.
doCommandForAction
(
action
event
buttonNode
)
;
}
)
;
return
[
buttonNode
panelViewNode
]
;
}
_makePanelViewNodeForAction
(
action
forUrlbar
)
{
let
panelViewNode
=
document
.
createElement
(
"
panelview
"
)
;
panelViewNode
.
id
=
this
.
_panelViewNodeIDForActionID
(
action
.
id
forUrlbar
)
;
panelViewNode
.
classList
.
add
(
"
PanelUI
-
subView
"
)
;
let
bodyNode
=
document
.
createElement
(
"
vbox
"
)
;
bodyNode
.
id
=
panelViewNode
.
id
+
"
-
body
"
;
bodyNode
.
classList
.
add
(
"
panel
-
subview
-
body
"
)
;
panelViewNode
.
appendChild
(
bodyNode
)
;
for
(
let
button
of
action
.
subview
.
buttons
)
{
let
buttonNode
=
document
.
createElement
(
"
toolbarbutton
"
)
;
buttonNode
.
id
=
this
.
_panelViewButtonNodeIDForActionID
(
action
.
id
button
.
id
forUrlbar
)
;
buttonNode
.
classList
.
add
(
"
subviewbutton
"
"
subviewbutton
-
iconic
"
)
;
buttonNode
.
setAttribute
(
"
label
"
button
.
title
)
;
if
(
button
.
shortcut
)
{
buttonNode
.
setAttribute
(
"
shortcut
"
button
.
shortcut
)
;
}
if
(
button
.
disabled
)
{
buttonNode
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
buttonNode
.
addEventListener
(
"
command
"
event
=
>
{
button
.
onCommand
(
event
buttonNode
)
;
}
)
;
bodyNode
.
appendChild
(
buttonNode
)
;
}
return
panelViewNode
;
}
togglePanelForAction
(
action
panelNode
=
null
)
{
let
aaPanelNode
=
this
.
activatedActionPanelNode
;
if
(
panelNode
)
{
if
(
panelNode
.
state
!
=
"
closed
"
)
{
panelNode
.
hidePopup
(
)
;
return
;
}
if
(
aaPanelNode
)
{
aaPanelNode
.
hidePopup
(
)
;
}
}
else
if
(
aaPanelNode
)
{
aaPanelNode
.
hidePopup
(
)
;
return
;
}
else
{
panelNode
=
this
.
_makeActivatedActionPanelForAction
(
action
)
;
}
this
.
panelNode
.
hidePopup
(
)
;
let
anchorNode
=
this
.
panelAnchorNodeForAction
(
action
)
;
anchorNode
.
setAttribute
(
"
open
"
"
true
"
)
;
panelNode
.
addEventListener
(
"
popuphiding
"
(
)
=
>
{
anchorNode
.
removeAttribute
(
"
open
"
)
;
}
{
once
:
true
}
)
;
panelNode
.
openPopup
(
anchorNode
"
bottomcenter
topright
"
)
;
}
_makeActivatedActionPanelForAction
(
action
)
{
let
panelNode
=
document
.
createElement
(
"
panel
"
)
;
panelNode
.
id
=
this
.
_activatedActionPanelID
;
panelNode
.
classList
.
add
(
"
cui
-
widget
-
panel
"
)
;
panelNode
.
setAttribute
(
"
actionID
"
action
.
id
)
;
panelNode
.
setAttribute
(
"
role
"
"
group
"
)
;
panelNode
.
setAttribute
(
"
type
"
"
arrow
"
)
;
panelNode
.
setAttribute
(
"
flip
"
"
slide
"
)
;
panelNode
.
setAttribute
(
"
noautofocus
"
"
true
"
)
;
panelNode
.
setAttribute
(
"
tabspecific
"
"
true
"
)
;
panelNode
.
setAttribute
(
"
photon
"
"
true
"
)
;
if
(
this
.
_disablePanelAnimations
)
{
panelNode
.
setAttribute
(
"
animate
"
"
false
"
)
;
}
let
panelViewNode
=
null
;
let
iframeNode
=
null
;
if
(
action
.
subview
)
{
let
multiViewNode
=
document
.
createElement
(
"
panelmultiview
"
)
;
panelViewNode
=
this
.
_makePanelViewNodeForAction
(
action
true
)
;
multiViewNode
.
appendChild
(
panelViewNode
)
;
panelNode
.
appendChild
(
multiViewNode
)
;
}
else
if
(
action
.
wantsIframe
)
{
iframeNode
=
document
.
createElement
(
"
iframe
"
)
;
iframeNode
.
setAttribute
(
"
type
"
"
content
"
)
;
panelNode
.
appendChild
(
iframeNode
)
;
}
let
popupSet
=
document
.
getElementById
(
"
mainPopupSet
"
)
;
popupSet
.
appendChild
(
panelNode
)
;
panelNode
.
addEventListener
(
"
popuphidden
"
(
)
=
>
{
panelNode
.
remove
(
)
;
}
{
once
:
true
}
)
;
if
(
iframeNode
)
{
panelNode
.
addEventListener
(
"
popupshowing
"
(
)
=
>
{
action
.
onIframeShowing
(
iframeNode
panelNode
)
;
}
{
once
:
true
}
)
;
panelNode
.
addEventListener
(
"
popuphiding
"
(
)
=
>
{
action
.
onIframeHiding
(
iframeNode
panelNode
)
;
}
{
once
:
true
}
)
;
panelNode
.
addEventListener
(
"
popuphidden
"
(
)
=
>
{
action
.
onIframeHidden
(
iframeNode
panelNode
)
;
}
{
once
:
true
}
)
;
}
if
(
panelViewNode
)
{
action
.
subview
.
onPlaced
(
panelViewNode
)
;
panelNode
.
addEventListener
(
"
popupshowing
"
(
)
=
>
{
action
.
subview
.
onShowing
(
panelViewNode
)
;
}
{
once
:
true
}
)
;
}
return
panelNode
;
}
get
_disablePanelAnimations
(
)
{
return
this
.
__disablePanelAnimations
|
|
false
;
}
set
_disablePanelAnimations
(
val
)
{
this
.
__disablePanelAnimations
=
val
;
if
(
val
)
{
this
.
panelNode
.
setAttribute
(
"
animate
"
"
false
"
)
;
}
else
{
this
.
panelNode
.
removeAttribute
(
"
animate
"
)
;
}
}
panelAnchorNodeForAction
(
action
event
)
{
if
(
event
&
&
event
.
target
.
closest
(
"
panel
"
)
)
{
return
this
.
mainButtonNode
;
}
let
potentialAnchorNodeIDs
=
[
action
&
&
action
.
anchorIDOverride
action
&
&
this
.
urlbarButtonNodeIDForActionID
(
action
.
id
)
this
.
mainButtonNode
.
id
"
identity
-
icon
"
]
;
let
dwu
=
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
for
(
let
id
of
potentialAnchorNodeIDs
)
{
if
(
id
)
{
let
node
=
document
.
getElementById
(
id
)
;
if
(
node
&
&
!
node
.
hidden
)
{
let
bounds
=
dwu
.
getBoundsWithoutFlushing
(
node
)
;
if
(
bounds
.
height
>
0
&
&
bounds
.
width
>
0
)
{
return
node
;
}
}
}
}
let
id
=
action
?
action
.
id
:
"
<
no
action
>
"
;
throw
new
Error
(
PageActions
:
No
anchor
node
for
{
id
}
)
;
}
get
activatedActionPanelNode
(
)
{
return
document
.
getElementById
(
this
.
_activatedActionPanelID
)
;
}
get
_activatedActionPanelID
(
)
{
return
"
pageActionActivatedActionPanel
"
;
}
placeActionInUrlbar
(
action
)
{
let
id
=
this
.
urlbarButtonNodeIDForActionID
(
action
.
id
)
;
let
node
=
document
.
getElementById
(
id
)
;
if
(
!
action
.
shouldShowInUrlbar
(
window
)
)
{
if
(
node
)
{
if
(
action
.
__urlbarNodeInMarkup
)
{
node
.
hidden
=
true
;
}
else
{
node
.
remove
(
)
;
}
}
return
;
}
let
newlyPlaced
=
false
;
if
(
action
.
__urlbarNodeInMarkup
)
{
newlyPlaced
=
node
&
&
node
.
hidden
;
node
.
hidden
=
false
;
}
else
if
(
!
node
)
{
newlyPlaced
=
true
;
node
=
this
.
_makeUrlbarButtonNode
(
action
)
;
node
.
id
=
id
;
}
if
(
newlyPlaced
)
{
let
insertBeforeID
=
PageActions
.
nextActionIDInUrlbar
(
window
action
)
;
let
insertBeforeNode
=
insertBeforeID
?
this
.
urlbarButtonNodeForActionID
(
insertBeforeID
)
:
null
;
this
.
mainButtonNode
.
parentNode
.
insertBefore
(
node
insertBeforeNode
)
;
this
.
updateAction
(
action
)
;
action
.
onPlacedInUrlbar
(
node
)
;
if
(
!
node
.
hasAttribute
(
"
tooltiptext
"
)
)
{
let
panelNode
=
this
.
panelButtonNodeForActionID
(
action
.
id
)
;
if
(
panelNode
)
{
node
.
setAttribute
(
"
tooltiptext
"
panelNode
.
getAttribute
(
"
label
"
)
)
;
}
}
}
}
_makeUrlbarButtonNode
(
action
)
{
let
buttonNode
=
document
.
createElement
(
"
image
"
)
;
buttonNode
.
classList
.
add
(
"
urlbar
-
icon
"
"
urlbar
-
page
-
action
"
)
;
buttonNode
.
setAttribute
(
"
actionid
"
action
.
id
)
;
buttonNode
.
setAttribute
(
"
role
"
"
button
"
)
;
if
(
action
.
nodeAttributes
)
{
for
(
let
name
in
action
.
nodeAttributes
)
{
buttonNode
.
setAttribute
(
name
action
.
nodeAttributes
[
name
]
)
;
}
}
buttonNode
.
addEventListener
(
"
click
"
event
=
>
{
this
.
doCommandForAction
(
action
event
buttonNode
)
;
}
)
;
return
buttonNode
;
}
removeAction
(
action
)
{
this
.
_removeActionFromPanel
(
action
)
;
this
.
_removeActionFromUrlbar
(
action
)
;
action
.
onRemovedFromWindow
(
window
)
;
}
_removeActionFromPanel
(
action
)
{
let
node
=
this
.
panelButtonNodeForActionID
(
action
.
id
)
;
if
(
node
)
{
node
.
remove
(
)
;
}
if
(
action
.
subview
)
{
let
panelViewNodeID
=
this
.
_panelViewNodeIDForActionID
(
action
.
id
false
)
;
let
panelViewNode
=
document
.
getElementById
(
panelViewNodeID
)
;
if
(
panelViewNode
)
{
panelViewNode
.
remove
(
)
;
}
}
if
(
!
PageActions
.
nonBuiltInActions
.
length
)
{
let
separator
=
document
.
getElementById
(
this
.
panelButtonNodeIDForActionID
(
PageActions
.
ACTION_ID_BUILT_IN_SEPARATOR
)
)
;
if
(
separator
)
{
separator
.
remove
(
)
;
}
}
}
_removeActionFromUrlbar
(
action
)
{
let
node
=
this
.
urlbarButtonNodeForActionID
(
action
.
id
)
;
if
(
node
)
{
node
.
remove
(
)
;
}
}
updateAction
(
action
propertyName
=
null
)
{
let
propertyNames
=
propertyName
?
[
propertyName
]
:
[
"
iconURL
"
"
title
"
"
tooltip
"
]
;
for
(
let
name
of
propertyNames
)
{
let
upper
=
name
[
0
]
.
toUpperCase
(
)
+
name
.
substr
(
1
)
;
this
[
_updateAction
{
upper
}
]
(
action
)
;
}
}
_updateActionDisabled
(
action
)
{
this
.
_updateActionDisabledInPanel
(
action
)
;
this
.
placeActionInUrlbar
(
action
)
;
}
_updateActionDisabledInPanel
(
action
)
{
let
panelButton
=
this
.
panelButtonNodeForActionID
(
action
.
id
)
;
if
(
panelButton
)
{
if
(
action
.
getDisabled
(
window
)
)
{
panelButton
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
else
{
panelButton
.
removeAttribute
(
"
disabled
"
)
;
}
}
}
_updateActionIconURL
(
action
)
{
let
nodes
=
[
this
.
panelButtonNodeForActionID
(
action
.
id
)
this
.
urlbarButtonNodeForActionID
(
action
.
id
)
]
.
filter
(
n
=
>
!
!
n
)
;
for
(
let
node
of
nodes
)
{
for
(
let
size
of
[
16
32
]
)
{
let
url
=
action
.
iconURLForSize
(
size
window
)
;
let
prop
=
-
-
pageAction
-
image
-
{
size
}
px
;
if
(
url
)
{
node
.
style
.
setProperty
(
prop
url
(
"
{
url
}
"
)
)
;
}
else
{
node
.
style
.
removeProperty
(
prop
)
;
}
}
}
}
_updateActionTitle
(
action
)
{
let
title
=
action
.
getTitle
(
window
)
;
if
(
!
title
)
{
return
;
}
let
attrNamesByNodeFnName
=
{
panelButtonNodeForActionID
:
"
label
"
urlbarButtonNodeForActionID
:
"
aria
-
label
"
}
;
for
(
let
[
fnName
attrName
]
of
Object
.
entries
(
attrNamesByNodeFnName
)
)
{
let
node
=
this
[
fnName
]
(
action
.
id
)
;
if
(
node
)
{
node
.
setAttribute
(
attrName
title
)
;
}
}
this
.
_updateActionTooltip
(
action
)
;
}
_updateActionTooltip
(
action
)
{
let
node
=
this
.
urlbarButtonNodeForActionID
(
action
.
id
)
;
if
(
node
)
{
let
tooltip
=
action
.
getTooltip
(
window
)
|
|
action
.
getTitle
(
window
)
;
node
.
setAttribute
(
"
tooltiptext
"
tooltip
)
;
}
}
doCommandForAction
(
action
event
buttonNode
)
{
if
(
event
&
&
event
.
type
=
=
"
click
"
&
&
event
.
button
!
=
0
)
{
return
;
}
PageActions
.
logTelemetry
(
"
used
"
action
buttonNode
)
;
if
(
action
.
subview
&
&
buttonNode
&
&
buttonNode
.
closest
(
"
panel
"
)
=
=
this
.
panelNode
)
{
let
panelViewNodeID
=
this
.
_panelViewNodeIDForActionID
(
action
.
id
false
)
;
let
panelViewNode
=
document
.
getElementById
(
panelViewNodeID
)
;
action
.
subview
.
onShowing
(
panelViewNode
)
;
this
.
multiViewNode
.
showSubView
(
panelViewNode
buttonNode
)
;
return
;
}
this
.
panelNode
.
hidePopup
(
)
;
if
(
action
.
subview
|
|
action
.
wantsIframe
)
{
this
.
togglePanelForAction
(
action
)
;
return
;
}
action
.
onCommand
(
event
buttonNode
)
;
}
actionForNode
(
node
)
{
if
(
!
node
)
{
return
null
;
}
let
actionID
=
this
.
_actionIDForNodeID
(
node
.
id
)
;
let
action
=
PageActions
.
actionForID
(
actionID
)
;
if
(
!
action
)
{
for
(
let
n
=
node
.
parentNode
;
n
&
&
!
action
;
n
=
n
.
parentNode
)
{
if
(
n
.
id
=
=
"
page
-
action
-
buttons
"
|
|
n
.
localName
=
=
"
panelview
"
)
{
break
;
}
actionID
=
this
.
_actionIDForNodeID
(
n
.
id
)
;
action
=
PageActions
.
actionForID
(
actionID
)
;
}
}
return
action
;
}
panelButtonNodeForActionID
(
actionID
)
{
return
document
.
getElementById
(
this
.
panelButtonNodeIDForActionID
(
actionID
)
)
;
}
panelButtonNodeIDForActionID
(
actionID
)
{
return
pageAction
-
panel
-
{
actionID
}
;
}
urlbarButtonNodeForActionID
(
actionID
)
{
return
document
.
getElementById
(
this
.
urlbarButtonNodeIDForActionID
(
actionID
)
)
;
}
urlbarButtonNodeIDForActionID
(
actionID
)
{
let
action
=
PageActions
.
actionForID
(
actionID
)
;
if
(
action
&
&
action
.
urlbarIDOverride
)
{
return
action
.
urlbarIDOverride
;
}
return
pageAction
-
urlbar
-
{
actionID
}
;
}
_panelViewNodeIDForActionID
(
actionID
forUrlbar
)
{
let
placementID
=
forUrlbar
?
"
urlbar
"
:
"
panel
"
;
return
pageAction
-
{
placementID
}
-
{
actionID
}
-
subview
;
}
_panelViewButtonNodeIDForActionID
(
actionID
buttonID
forUrlbar
)
{
let
placementID
=
forUrlbar
?
"
urlbar
"
:
"
panel
"
;
return
pageAction
-
{
placementID
}
-
{
actionID
}
-
{
buttonID
}
;
}
_actionIDForNodeID
(
nodeID
)
{
if
(
!
nodeID
)
{
return
null
;
}
let
match
=
nodeID
.
match
(
/
^
pageAction
-
(
?
:
panel
|
urlbar
)
-
(
.
+
)
/
)
;
if
(
match
)
{
return
match
[
1
]
;
}
for
(
let
action
of
PageActions
.
actions
)
{
if
(
action
.
urlbarIDOverride
&
&
action
.
urlbarIDOverride
=
=
nodeID
)
{
return
action
.
id
;
}
}
return
null
;
}
mainButtonClicked
(
event
)
{
event
.
stopPropagation
(
)
;
if
(
(
event
.
type
=
=
"
mousedown
"
&
&
event
.
button
!
=
0
)
|
|
(
event
.
type
=
=
"
keypress
"
&
&
event
.
charCode
!
=
KeyEvent
.
DOM_VK_SPACE
&
&
event
.
keyCode
!
=
KeyEvent
.
DOM_VK_RETURN
)
)
{
return
;
}
let
panelNode
=
this
.
activatedActionPanelNode
;
if
(
panelNode
&
&
panelNode
.
anchorNode
.
id
=
=
this
.
mainButtonNode
.
id
)
{
panelNode
.
hidePopup
(
)
;
return
;
}
if
(
this
.
panelNode
.
state
=
=
"
open
"
)
{
this
.
panelNode
.
hidePopup
(
)
;
}
else
if
(
this
.
panelNode
.
state
=
=
"
closed
"
)
{
this
.
showPanel
(
event
)
;
}
}
showPanel
(
event
=
null
)
{
for
(
let
action
of
PageActions
.
actions
)
{
let
buttonNode
=
this
.
panelButtonNodeForActionID
(
action
.
id
)
;
action
.
onShowingInPanel
(
buttonNode
)
;
}
this
.
panelNode
.
hidden
=
false
;
this
.
panelNode
.
addEventListener
(
"
popuphiding
"
(
)
=
>
{
this
.
mainButtonNode
.
removeAttribute
(
"
open
"
)
;
}
{
once
:
true
}
)
;
this
.
mainButtonNode
.
setAttribute
(
"
open
"
"
true
"
)
;
this
.
panelNode
.
openPopup
(
this
.
mainButtonNode
{
position
:
"
bottomcenter
topright
"
triggerEvent
:
event
}
)
;
}
onContextMenuShowing
(
event
popup
)
{
if
(
event
.
target
!
=
popup
)
{
return
;
}
this
.
_contextAction
=
this
.
actionForNode
(
popup
.
triggerNode
)
;
if
(
!
this
.
_contextAction
)
{
event
.
preventDefault
(
)
;
return
;
}
let
state
;
if
(
this
.
_contextAction
.
_isBuiltIn
)
{
state
=
this
.
_contextAction
.
pinnedToUrlbar
?
"
builtInPinned
"
:
"
builtInUnpinned
"
;
}
else
{
state
=
this
.
_contextAction
.
pinnedToUrlbar
?
"
extensionPinned
"
:
"
extensionUnpinned
"
;
}
popup
.
setAttribute
(
"
state
"
state
)
;
}
togglePinningForContextAction
(
)
{
if
(
!
this
.
_contextAction
)
{
return
;
}
let
action
=
this
.
_contextAction
;
this
.
_contextAction
=
null
;
let
telemetryType
=
action
.
pinnedToUrlbar
?
"
removed
"
:
"
added
"
;
PageActions
.
logTelemetry
(
telemetryType
action
)
;
action
.
pinnedToUrlbar
=
!
action
.
pinnedToUrlbar
;
}
openAboutAddonsForContextAction
(
)
{
if
(
!
this
.
_contextAction
)
{
return
;
}
let
action
=
this
.
_contextAction
;
this
.
_contextAction
=
null
;
PageActions
.
logTelemetry
(
"
managed
"
action
)
;
let
viewID
=
"
addons
:
/
/
detail
/
"
+
encodeURIComponent
(
action
.
extensionID
)
;
window
.
BrowserOpenAddonsMgr
(
viewID
)
;
}
_contextAction
:
null
takeActionTitleFromPanel
(
action
)
{
let
titleOrAttrNameOnPanel
=
action
.
getTitle
(
)
;
let
attrValueOnPanel
=
this
.
panelNode
.
getAttribute
(
titleOrAttrNameOnPanel
)
;
if
(
attrValueOnPanel
)
{
this
.
panelNode
.
removeAttribute
(
titleOrAttrNameOnPanel
)
;
action
.
setTitle
(
attrValueOnPanel
)
;
}
}
takeNodeAttributeFromPanel
(
node
attrName
)
{
let
panelAttrName
=
node
.
getAttribute
(
attrName
)
;
if
(
!
panelAttrName
&
&
attrName
=
=
"
title
"
)
{
attrName
=
"
label
"
;
panelAttrName
=
node
.
getAttribute
(
attrName
)
;
}
if
(
panelAttrName
)
{
let
attrValue
=
this
.
panelNode
.
getAttribute
(
panelAttrName
)
;
if
(
attrValue
)
{
node
.
setAttribute
(
attrName
attrValue
)
;
}
}
}
onLocationChange
(
)
{
for
(
let
action
of
PageActions
.
actions
)
{
action
.
onLocationChange
(
window
)
;
}
}
}
;
var
BrowserPageActionFeedback
=
{
get
panelNode
(
)
{
delete
this
.
panelNode
;
return
this
.
panelNode
=
document
.
getElementById
(
"
pageActionFeedback
"
)
;
}
get
feedbackAnimationBox
(
)
{
delete
this
.
feedbackAnimationBox
;
return
this
.
feedbackAnimationBox
=
document
.
getElementById
(
"
pageActionFeedbackAnimatableBox
"
)
;
}
get
feedbackLabel
(
)
{
delete
this
.
feedbackLabel
;
return
this
.
feedbackLabel
=
document
.
getElementById
(
"
pageActionFeedbackMessage
"
)
;
}
show
(
action
event
textContentOverride
)
{
this
.
feedbackLabel
.
textContent
=
this
.
panelNode
.
getAttribute
(
(
textContentOverride
|
|
action
.
id
)
+
"
Feedback
"
)
;
this
.
panelNode
.
hidden
=
false
;
let
anchor
=
BrowserPageActions
.
panelAnchorNodeForAction
(
action
event
)
;
this
.
panelNode
.
openPopup
(
anchor
{
position
:
"
bottomcenter
topright
"
triggerEvent
:
event
}
)
;
this
.
panelNode
.
addEventListener
(
"
popupshown
"
(
)
=
>
{
this
.
feedbackAnimationBox
.
setAttribute
(
"
animate
"
"
true
"
)
;
setTimeout
(
(
)
=
>
{
this
.
panelNode
.
hidePopup
(
true
)
;
}
Services
.
prefs
.
getIntPref
(
"
browser
.
pageActions
.
feedbackTimeoutMS
"
1120
)
)
;
}
{
once
:
true
}
)
;
this
.
panelNode
.
addEventListener
(
"
popuphidden
"
(
)
=
>
{
this
.
feedbackAnimationBox
.
removeAttribute
(
"
animate
"
)
;
}
{
once
:
true
}
)
;
}
}
;
BrowserPageActions
.
bookmark
=
{
onShowingInPanel
(
buttonNode
)
{
BookmarkingUI
.
updateBookmarkPageMenuItem
(
)
;
}
onCommand
(
event
buttonNode
)
{
BrowserPageActions
.
panelNode
.
hidePopup
(
)
;
BookmarkingUI
.
onStarCommand
(
event
)
;
}
}
;
BrowserPageActions
.
copyURL
=
{
onPlacedInPanel
(
buttonNode
)
{
let
action
=
PageActions
.
actionForID
(
"
copyURL
"
)
;
BrowserPageActions
.
takeActionTitleFromPanel
(
action
)
;
}
onCommand
(
event
buttonNode
)
{
BrowserPageActions
.
panelNode
.
hidePopup
(
)
;
Cc
[
"
mozilla
.
org
/
widget
/
clipboardhelper
;
1
"
]
.
getService
(
Ci
.
nsIClipboardHelper
)
.
copyString
(
gURLBar
.
makeURIReadable
(
gBrowser
.
selectedBrowser
.
currentURI
)
.
displaySpec
)
;
let
action
=
PageActions
.
actionForID
(
"
copyURL
"
)
;
BrowserPageActionFeedback
.
show
(
action
event
)
;
}
}
;
BrowserPageActions
.
emailLink
=
{
onPlacedInPanel
(
buttonNode
)
{
let
action
=
PageActions
.
actionForID
(
"
emailLink
"
)
;
BrowserPageActions
.
takeActionTitleFromPanel
(
action
)
;
}
onCommand
(
event
buttonNode
)
{
BrowserPageActions
.
panelNode
.
hidePopup
(
)
;
MailIntegration
.
sendLinkForBrowser
(
gBrowser
.
selectedBrowser
)
;
}
}
;
BrowserPageActions
.
sendToDevice
=
{
onPlacedInPanel
(
buttonNode
)
{
let
action
=
PageActions
.
actionForID
(
"
sendToDevice
"
)
;
BrowserPageActions
.
takeActionTitleFromPanel
(
action
)
;
}
onSubviewPlaced
(
panelViewNode
)
{
let
bodyNode
=
panelViewNode
.
firstChild
;
for
(
let
node
of
bodyNode
.
childNodes
)
{
BrowserPageActions
.
takeNodeAttributeFromPanel
(
node
"
title
"
)
;
BrowserPageActions
.
takeNodeAttributeFromPanel
(
node
"
shortcut
"
)
;
}
}
onLocationChange
(
)
{
let
action
=
PageActions
.
actionForID
(
"
sendToDevice
"
)
;
let
browser
=
gBrowser
.
selectedBrowser
;
let
url
=
browser
.
currentURI
.
spec
;
action
.
setDisabled
(
!
gSync
.
isSendableURI
(
url
)
window
)
;
}
onShowingSubview
(
panelViewNode
)
{
let
browser
=
gBrowser
.
selectedBrowser
;
let
url
=
browser
.
currentURI
.
spec
;
let
title
=
browser
.
contentTitle
;
let
bodyNode
=
panelViewNode
.
firstChild
;
let
panelNode
=
panelViewNode
.
closest
(
"
panel
"
)
;
gSync
.
populateSendTabToDevicesMenu
(
bodyNode
url
title
(
clientId
name
clientType
lastModified
)
=
>
{
if
(
!
name
)
{
return
document
.
createElement
(
"
toolbarseparator
"
)
;
}
let
item
=
document
.
createElement
(
"
toolbarbutton
"
)
;
item
.
classList
.
add
(
"
pageAction
-
sendToDevice
-
device
"
"
subviewbutton
"
)
;
if
(
clientId
)
{
item
.
classList
.
add
(
"
subviewbutton
-
iconic
"
)
;
item
.
setAttribute
(
"
tooltiptext
"
gSync
.
formatLastSyncDate
(
lastModified
)
)
;
}
item
.
addEventListener
(
"
command
"
event
=
>
{
if
(
panelNode
)
{
panelNode
.
hidePopup
(
)
;
}
if
(
event
.
target
.
classList
.
contains
(
"
sendtab
-
target
"
)
)
{
let
action
=
PageActions
.
actionForID
(
"
sendToDevice
"
)
;
let
textOverride
=
gSync
.
offline
&
&
"
sendToDeviceOffline
"
;
BrowserPageActionFeedback
.
show
(
action
event
textOverride
)
;
}
}
)
;
return
item
;
}
)
;
bodyNode
.
removeAttribute
(
"
state
"
)
;
if
(
gSync
.
syncConfiguredAndLoading
)
{
bodyNode
.
setAttribute
(
"
state
"
"
notready
"
)
;
Services
.
tm
.
dispatchToMainThread
(
async
(
)
=
>
{
await
Weave
.
Service
.
sync
(
{
why
:
"
pageactions
"
engines
:
[
]
}
)
;
if
(
!
window
.
closed
&
&
!
gSync
.
syncConfiguredAndLoading
)
{
this
.
onShowingSubview
(
panelViewNode
)
;
}
}
)
;
}
}
}
;
