ChromeUtils
.
defineModuleGetter
(
this
"
SiteSpecificBrowser
"
"
resource
:
/
/
/
modules
/
SiteSpecificBrowserService
.
jsm
"
)
;
var
BrowserPageActions
=
{
get
mainButtonNode
(
)
{
delete
this
.
mainButtonNode
;
return
(
this
.
mainButtonNode
=
document
.
getElementById
(
"
pageActionButton
"
)
)
;
}
get
panelNode
(
)
{
delete
this
.
panelNode
;
return
(
this
.
panelNode
=
document
.
getElementById
(
"
pageActionPanel
"
)
)
;
}
get
multiViewNode
(
)
{
delete
this
.
multiViewNode
;
return
(
this
.
multiViewNode
=
document
.
getElementById
(
"
pageActionPanelMultiView
"
)
)
;
}
get
mainViewNode
(
)
{
delete
this
.
mainViewNode
;
return
(
this
.
mainViewNode
=
document
.
getElementById
(
"
pageActionPanelMainView
"
)
)
;
}
get
mainViewBodyNode
(
)
{
delete
this
.
mainViewBodyNode
;
return
(
this
.
mainViewBodyNode
=
this
.
mainViewNode
.
querySelector
(
"
.
panel
-
subview
-
body
"
)
)
;
}
init
(
)
{
this
.
placeAllActions
(
)
;
this
.
_onPanelShowing
=
this
.
_onPanelShowing
.
bind
(
this
)
;
this
.
panelNode
.
addEventListener
(
"
popupshowing
"
this
.
_onPanelShowing
)
;
this
.
panelNode
.
addEventListener
(
"
popuphiding
"
(
)
=
>
{
this
.
mainButtonNode
.
removeAttribute
(
"
open
"
)
;
}
)
;
}
_onPanelShowing
(
)
{
this
.
placeLazyActionsInPanel
(
)
;
for
(
let
action
of
PageActions
.
actionsInPanel
(
window
)
)
{
let
buttonNode
=
this
.
panelButtonNodeForActionID
(
action
.
id
)
;
action
.
onShowingInPanel
(
buttonNode
)
;
}
}
placeLazyActionsInPanel
(
)
{
let
actions
=
this
.
_actionsToLazilyPlaceInPanel
;
this
.
_actionsToLazilyPlaceInPanel
=
[
]
;
for
(
let
action
of
actions
)
{
this
.
_placeActionInPanelNow
(
action
)
;
}
}
_actionsToLazilyPlaceInPanel
:
[
]
placeAllActions
(
)
{
let
panelActions
=
PageActions
.
actionsInPanel
(
window
)
;
for
(
let
action
of
panelActions
)
{
this
.
placeActionInPanel
(
action
)
;
}
let
urlbarActions
=
PageActions
.
actionsInUrlbar
(
window
)
;
for
(
let
action
of
urlbarActions
)
{
this
.
placeActionInUrlbar
(
action
)
;
}
}
placeAction
(
action
)
{
this
.
placeActionInPanel
(
action
)
;
this
.
placeActionInUrlbar
(
action
)
;
}
placeActionInPanel
(
action
)
{
if
(
this
.
panelNode
.
state
!
=
"
closed
"
)
{
this
.
_placeActionInPanelNow
(
action
)
;
}
else
{
this
.
_actionsToLazilyPlaceInPanel
.
push
(
action
)
;
}
}
_placeActionInPanelNow
(
action
)
{
if
(
action
.
shouldShowInPanel
(
window
)
)
{
this
.
_addActionToPanel
(
action
)
;
}
else
{
this
.
_removeActionFromPanel
(
action
)
;
}
}
_addActionToPanel
(
action
)
{
let
id
=
this
.
panelButtonNodeIDForActionID
(
action
.
id
)
;
let
node
=
document
.
getElementById
(
id
)
;
if
(
node
)
{
return
;
}
this
.
_maybeNotifyBeforePlacedInWindow
(
action
)
;
node
=
this
.
_makePanelButtonNodeForAction
(
action
)
;
node
.
id
=
id
;
let
insertBeforeNode
=
this
.
_getNextNode
(
action
false
)
;
this
.
mainViewBodyNode
.
insertBefore
(
node
insertBeforeNode
)
;
this
.
updateAction
(
action
null
{
panelNode
:
node
}
)
;
this
.
_updateActionDisabledInPanel
(
action
node
)
;
action
.
onPlacedInPanel
(
node
)
;
this
.
_addOrRemoveSeparatorsInPanel
(
)
;
}
_removeActionFromPanel
(
action
)
{
let
lazyIndex
=
this
.
_actionsToLazilyPlaceInPanel
.
findIndex
(
a
=
>
a
.
id
=
=
action
.
id
)
;
if
(
lazyIndex
>
=
0
)
{
this
.
_actionsToLazilyPlaceInPanel
.
splice
(
lazyIndex
1
)
;
}
let
node
=
this
.
panelButtonNodeForActionID
(
action
.
id
)
;
if
(
!
node
)
{
return
;
}
node
.
remove
(
)
;
if
(
action
.
getWantsSubview
(
window
)
)
{
let
panelViewNodeID
=
this
.
_panelViewNodeIDForActionID
(
action
.
id
false
)
;
let
panelViewNode
=
document
.
getElementById
(
panelViewNodeID
)
;
if
(
panelViewNode
)
{
panelViewNode
.
remove
(
)
;
}
}
this
.
_addOrRemoveSeparatorsInPanel
(
)
;
}
_addOrRemoveSeparatorsInPanel
(
)
{
let
actions
=
PageActions
.
actionsInPanel
(
window
)
;
let
ids
=
[
PageActions
.
ACTION_ID_BUILT_IN_SEPARATOR
PageActions
.
ACTION_ID_TRANSIENT_SEPARATOR
]
;
for
(
let
id
of
ids
)
{
let
sep
=
actions
.
find
(
a
=
>
a
.
id
=
=
id
)
;
if
(
sep
)
{
this
.
_addActionToPanel
(
sep
)
;
}
else
{
let
node
=
this
.
panelButtonNodeForActionID
(
id
)
;
if
(
node
)
{
node
.
remove
(
)
;
}
}
}
}
_getNextNode
(
action
forUrlbar
)
{
let
actions
=
forUrlbar
?
PageActions
.
actionsInUrlbar
(
window
)
:
PageActions
.
actionsInPanel
(
window
)
;
let
index
=
actions
.
findIndex
(
a
=
>
a
.
id
=
=
action
.
id
)
;
if
(
index
<
0
)
{
return
null
;
}
for
(
let
i
=
index
+
1
;
i
<
actions
.
length
;
i
+
+
)
{
let
node
=
forUrlbar
?
this
.
urlbarButtonNodeForActionID
(
actions
[
i
]
.
id
)
:
this
.
panelButtonNodeForActionID
(
actions
[
i
]
.
id
)
;
if
(
node
)
{
return
node
;
}
}
return
null
;
}
_maybeNotifyBeforePlacedInWindow
(
action
)
{
if
(
!
this
.
_isActionPlacedInWindow
(
action
)
)
{
action
.
onBeforePlacedInWindow
(
window
)
;
}
}
_isActionPlacedInWindow
(
action
)
{
if
(
this
.
panelButtonNodeForActionID
(
action
.
id
)
)
{
return
true
;
}
let
urlbarNode
=
this
.
urlbarButtonNodeForActionID
(
action
.
id
)
;
return
urlbarNode
&
&
!
urlbarNode
.
hidden
;
}
_makePanelButtonNodeForAction
(
action
)
{
if
(
action
.
__isSeparator
)
{
let
node
=
document
.
createXULElement
(
"
toolbarseparator
"
)
;
return
node
;
}
let
buttonNode
=
document
.
createXULElement
(
"
toolbarbutton
"
)
;
buttonNode
.
classList
.
add
(
"
subviewbutton
"
"
subviewbutton
-
iconic
"
"
pageAction
-
panel
-
button
"
)
;
if
(
action
.
isBadged
)
{
buttonNode
.
setAttribute
(
"
badged
"
"
true
"
)
;
}
buttonNode
.
setAttribute
(
"
actionid
"
action
.
id
)
;
buttonNode
.
addEventListener
(
"
command
"
event
=
>
{
this
.
doCommandForAction
(
action
event
buttonNode
)
;
}
)
;
return
buttonNode
;
}
_makePanelViewNodeForAction
(
action
forUrlbar
)
{
let
panelViewNode
=
document
.
createXULElement
(
"
panelview
"
)
;
panelViewNode
.
id
=
this
.
_panelViewNodeIDForActionID
(
action
.
id
forUrlbar
)
;
panelViewNode
.
classList
.
add
(
"
PanelUI
-
subView
"
)
;
let
bodyNode
=
document
.
createXULElement
(
"
vbox
"
)
;
bodyNode
.
id
=
panelViewNode
.
id
+
"
-
body
"
;
bodyNode
.
classList
.
add
(
"
panel
-
subview
-
body
"
)
;
panelViewNode
.
appendChild
(
bodyNode
)
;
return
panelViewNode
;
}
togglePanelForAction
(
action
panelNode
=
null
event
=
null
)
{
let
aaPanelNode
=
this
.
activatedActionPanelNode
;
if
(
panelNode
)
{
if
(
panelNode
.
state
!
=
"
closed
"
)
{
PanelMultiView
.
hidePopup
(
panelNode
)
;
return
;
}
if
(
aaPanelNode
)
{
PanelMultiView
.
hidePopup
(
aaPanelNode
)
;
}
}
else
if
(
aaPanelNode
)
{
PanelMultiView
.
hidePopup
(
aaPanelNode
)
;
return
;
}
else
{
panelNode
=
this
.
_makeActivatedActionPanelForAction
(
action
)
;
}
PanelMultiView
.
hidePopup
(
this
.
panelNode
)
;
let
anchorNode
=
this
.
panelAnchorNodeForAction
(
action
)
;
anchorNode
.
setAttribute
(
"
open
"
"
true
"
)
;
panelNode
.
addEventListener
(
"
popuphiding
"
(
)
=
>
{
anchorNode
.
removeAttribute
(
"
open
"
)
;
}
{
once
:
true
}
)
;
PanelMultiView
.
openPopup
(
panelNode
anchorNode
{
position
:
"
bottomcenter
topright
"
triggerEvent
:
event
}
)
.
catch
(
Cu
.
reportError
)
;
}
_makeActivatedActionPanelForAction
(
action
)
{
let
panelNode
=
document
.
createXULElement
(
"
panel
"
)
;
panelNode
.
id
=
this
.
_activatedActionPanelID
;
panelNode
.
classList
.
add
(
"
cui
-
widget
-
panel
"
"
panel
-
no
-
padding
"
)
;
panelNode
.
setAttribute
(
"
actionID
"
action
.
id
)
;
panelNode
.
setAttribute
(
"
role
"
"
group
"
)
;
panelNode
.
setAttribute
(
"
type
"
"
arrow
"
)
;
panelNode
.
setAttribute
(
"
flip
"
"
slide
"
)
;
panelNode
.
setAttribute
(
"
noautofocus
"
"
true
"
)
;
panelNode
.
setAttribute
(
"
tabspecific
"
"
true
"
)
;
let
panelViewNode
=
null
;
let
iframeNode
=
null
;
if
(
action
.
getWantsSubview
(
window
)
)
{
let
multiViewNode
=
document
.
createXULElement
(
"
panelmultiview
"
)
;
panelViewNode
=
this
.
_makePanelViewNodeForAction
(
action
true
)
;
multiViewNode
.
setAttribute
(
"
mainViewId
"
panelViewNode
.
id
)
;
multiViewNode
.
appendChild
(
panelViewNode
)
;
panelNode
.
appendChild
(
multiViewNode
)
;
}
else
if
(
action
.
wantsIframe
)
{
iframeNode
=
document
.
createXULElement
(
"
iframe
"
)
;
iframeNode
.
setAttribute
(
"
type
"
"
content
"
)
;
panelNode
.
appendChild
(
iframeNode
)
;
}
let
popupSet
=
document
.
getElementById
(
"
mainPopupSet
"
)
;
popupSet
.
appendChild
(
panelNode
)
;
panelNode
.
addEventListener
(
"
popuphidden
"
(
)
=
>
{
PanelMultiView
.
removePopup
(
panelNode
)
;
}
{
once
:
true
}
)
;
if
(
iframeNode
)
{
panelNode
.
addEventListener
(
"
popupshowing
"
(
)
=
>
{
action
.
onIframeShowing
(
iframeNode
panelNode
)
;
}
{
once
:
true
}
)
;
panelNode
.
addEventListener
(
"
popupshown
"
(
)
=
>
{
iframeNode
.
focus
(
)
;
}
{
once
:
true
}
)
;
panelNode
.
addEventListener
(
"
popuphiding
"
(
)
=
>
{
action
.
onIframeHiding
(
iframeNode
panelNode
)
;
}
{
once
:
true
}
)
;
panelNode
.
addEventListener
(
"
popuphidden
"
(
)
=
>
{
action
.
onIframeHidden
(
iframeNode
panelNode
)
;
}
{
once
:
true
}
)
;
}
if
(
panelViewNode
)
{
action
.
onSubviewPlaced
(
panelViewNode
)
;
panelNode
.
addEventListener
(
"
popupshowing
"
(
)
=
>
{
action
.
onSubviewShowing
(
panelViewNode
)
;
}
{
once
:
true
}
)
;
}
return
panelNode
;
}
panelAnchorNodeForAction
(
action
event
)
{
if
(
event
&
&
event
.
target
.
closest
(
"
panel
"
)
=
=
this
.
panelNode
)
{
return
this
.
mainButtonNode
;
}
let
potentialAnchorNodeIDs
=
[
action
&
&
action
.
anchorIDOverride
action
&
&
this
.
urlbarButtonNodeIDForActionID
(
action
.
id
)
this
.
mainButtonNode
.
id
"
identity
-
icon
"
"
urlbar
-
search
-
button
"
]
;
for
(
let
id
of
potentialAnchorNodeIDs
)
{
if
(
id
)
{
let
node
=
document
.
getElementById
(
id
)
;
if
(
node
&
&
!
node
.
hidden
)
{
let
bounds
=
window
.
windowUtils
.
getBoundsWithoutFlushing
(
node
)
;
if
(
bounds
.
height
>
0
&
&
bounds
.
width
>
0
)
{
return
node
;
}
}
}
}
let
id
=
action
?
action
.
id
:
"
<
no
action
>
"
;
throw
new
Error
(
PageActions
:
No
anchor
node
for
{
id
}
)
;
}
get
activatedActionPanelNode
(
)
{
return
document
.
getElementById
(
this
.
_activatedActionPanelID
)
;
}
get
_activatedActionPanelID
(
)
{
return
"
pageActionActivatedActionPanel
"
;
}
placeActionInUrlbar
(
action
)
{
let
id
=
this
.
urlbarButtonNodeIDForActionID
(
action
.
id
)
;
let
node
=
document
.
getElementById
(
id
)
;
if
(
!
action
.
shouldShowInUrlbar
(
window
)
)
{
if
(
node
)
{
if
(
action
.
__urlbarNodeInMarkup
)
{
node
.
hidden
=
true
;
}
else
{
node
.
remove
(
)
;
}
}
return
;
}
let
newlyPlaced
=
false
;
if
(
action
.
__urlbarNodeInMarkup
)
{
this
.
_maybeNotifyBeforePlacedInWindow
(
action
)
;
node
=
document
.
getElementById
(
id
)
;
if
(
!
node
)
{
return
;
}
newlyPlaced
=
node
.
hidden
;
node
.
hidden
=
false
;
}
else
if
(
!
node
)
{
newlyPlaced
=
true
;
this
.
_maybeNotifyBeforePlacedInWindow
(
action
)
;
node
=
this
.
_makeUrlbarButtonNode
(
action
)
;
node
.
id
=
id
;
}
if
(
!
newlyPlaced
)
{
return
;
}
let
insertBeforeNode
=
this
.
_getNextNode
(
action
true
)
;
this
.
mainButtonNode
.
parentNode
.
insertBefore
(
node
insertBeforeNode
)
;
this
.
updateAction
(
action
null
{
urlbarNode
:
node
}
)
;
action
.
onPlacedInUrlbar
(
node
)
;
}
_makeUrlbarButtonNode
(
action
)
{
let
buttonNode
=
document
.
createXULElement
(
"
image
"
)
;
buttonNode
.
classList
.
add
(
"
urlbar
-
icon
"
"
urlbar
-
page
-
action
"
)
;
buttonNode
.
setAttribute
(
"
actionid
"
action
.
id
)
;
buttonNode
.
setAttribute
(
"
role
"
"
button
"
)
;
let
commandHandler
=
event
=
>
{
this
.
doCommandForAction
(
action
event
buttonNode
)
;
}
;
buttonNode
.
addEventListener
(
"
click
"
commandHandler
)
;
buttonNode
.
addEventListener
(
"
keypress
"
commandHandler
)
;
return
buttonNode
;
}
removeAction
(
action
)
{
this
.
_removeActionFromPanel
(
action
)
;
this
.
_removeActionFromUrlbar
(
action
)
;
action
.
onRemovedFromWindow
(
window
)
;
}
_removeActionFromUrlbar
(
action
)
{
let
node
=
this
.
urlbarButtonNodeForActionID
(
action
.
id
)
;
if
(
node
)
{
node
.
remove
(
)
;
}
}
updateAction
(
action
propertyName
=
null
opts
=
{
}
)
{
let
anyNodeGiven
=
"
panelNode
"
in
opts
|
|
"
urlbarNode
"
in
opts
;
let
panelNode
=
anyNodeGiven
?
opts
.
panelNode
|
|
null
:
this
.
panelButtonNodeForActionID
(
action
.
id
)
;
let
urlbarNode
=
anyNodeGiven
?
opts
.
urlbarNode
|
|
null
:
this
.
urlbarButtonNodeForActionID
(
action
.
id
)
;
let
value
=
opts
.
value
|
|
undefined
;
if
(
propertyName
)
{
this
[
this
.
_updateMethods
[
propertyName
]
]
(
action
panelNode
urlbarNode
value
)
;
}
else
{
for
(
let
name
of
[
"
iconURL
"
"
title
"
"
tooltip
"
"
wantsSubview
"
]
)
{
this
[
this
.
_updateMethods
[
name
]
]
(
action
panelNode
urlbarNode
value
)
;
}
}
}
_updateMethods
:
{
disabled
:
"
_updateActionDisabled
"
iconURL
:
"
_updateActionIconURL
"
title
:
"
_updateActionTitle
"
tooltip
:
"
_updateActionTooltip
"
wantsSubview
:
"
_updateActionWantsSubview
"
}
_updateActionDisabled
(
action
panelNode
urlbarNode
disabled
=
action
.
getDisabled
(
window
)
)
{
if
(
action
.
__transient
)
{
this
.
placeActionInPanel
(
action
)
;
}
else
{
this
.
_updateActionDisabledInPanel
(
action
panelNode
disabled
)
;
}
this
.
placeActionInUrlbar
(
action
)
;
}
_updateActionDisabledInPanel
(
action
panelNode
disabled
=
action
.
getDisabled
(
window
)
)
{
if
(
panelNode
)
{
if
(
disabled
)
{
panelNode
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
else
{
panelNode
.
removeAttribute
(
"
disabled
"
)
;
}
}
}
_updateActionIconURL
(
action
panelNode
urlbarNode
properties
=
action
.
getIconProperties
(
window
)
)
{
for
(
let
[
prop
value
]
of
Object
.
entries
(
properties
)
)
{
if
(
panelNode
)
{
panelNode
.
style
.
setProperty
(
prop
value
)
;
}
if
(
urlbarNode
)
{
urlbarNode
.
style
.
setProperty
(
prop
value
)
;
}
}
}
_updateActionTitle
(
action
panelNode
urlbarNode
title
=
action
.
getTitle
(
window
)
)
{
if
(
!
title
)
{
return
;
}
if
(
panelNode
)
{
panelNode
.
setAttribute
(
"
label
"
title
)
;
}
if
(
urlbarNode
)
{
if
(
urlbarNode
.
nodeName
!
=
"
hbox
"
)
{
urlbarNode
.
setAttribute
(
"
aria
-
label
"
title
)
;
}
let
tooltip
=
action
.
getTooltip
(
window
)
;
if
(
!
tooltip
&
&
title
)
{
urlbarNode
.
setAttribute
(
"
tooltiptext
"
title
)
;
}
}
}
_updateActionTooltip
(
action
panelNode
urlbarNode
tooltip
=
action
.
getTooltip
(
window
)
)
{
if
(
urlbarNode
)
{
if
(
!
tooltip
)
{
tooltip
=
action
.
getTitle
(
window
)
;
}
if
(
tooltip
)
{
urlbarNode
.
setAttribute
(
"
tooltiptext
"
tooltip
)
;
}
}
}
_updateActionWantsSubview
(
action
panelNode
urlbarNode
wantsSubview
=
action
.
getWantsSubview
(
window
)
)
{
if
(
!
panelNode
)
{
return
;
}
let
panelViewID
=
this
.
_panelViewNodeIDForActionID
(
action
.
id
false
)
;
let
panelViewNode
=
document
.
getElementById
(
panelViewID
)
;
panelNode
.
classList
.
toggle
(
"
subviewbutton
-
nav
"
wantsSubview
)
;
if
(
!
wantsSubview
)
{
if
(
panelViewNode
)
{
panelViewNode
.
remove
(
)
;
}
return
;
}
if
(
!
panelViewNode
)
{
panelViewNode
=
this
.
_makePanelViewNodeForAction
(
action
false
)
;
this
.
multiViewNode
.
appendChild
(
panelViewNode
)
;
action
.
onSubviewPlaced
(
panelViewNode
)
;
}
}
doCommandForAction
(
action
event
buttonNode
)
{
if
(
event
&
&
event
.
type
=
=
"
click
"
&
&
(
event
.
button
!
=
0
|
|
(
AppConstants
.
platform
=
=
"
macosx
"
&
&
event
.
ctrlKey
)
)
)
{
return
;
}
if
(
event
&
&
event
.
type
=
=
"
keypress
"
)
{
if
(
event
.
key
!
=
"
"
&
&
event
.
key
!
=
"
Enter
"
)
{
return
;
}
event
.
stopPropagation
(
)
;
}
if
(
action
.
getWantsSubview
(
window
)
&
&
buttonNode
&
&
buttonNode
.
closest
(
"
panel
"
)
=
=
this
.
panelNode
)
{
let
panelViewNodeID
=
this
.
_panelViewNodeIDForActionID
(
action
.
id
false
)
;
let
panelViewNode
=
document
.
getElementById
(
panelViewNodeID
)
;
action
.
onSubviewShowing
(
panelViewNode
)
;
this
.
multiViewNode
.
showSubView
(
panelViewNode
buttonNode
)
;
return
;
}
PanelMultiView
.
hidePopup
(
this
.
panelNode
)
;
let
aaPanelNode
=
this
.
activatedActionPanelNode
;
if
(
!
aaPanelNode
|
|
aaPanelNode
.
getAttribute
(
"
actionID
"
)
!
=
action
.
id
)
{
action
.
onCommand
(
event
buttonNode
)
;
}
if
(
action
.
getWantsSubview
(
window
)
|
|
action
.
wantsIframe
)
{
this
.
togglePanelForAction
(
action
null
event
)
;
}
}
actionForNode
(
node
)
{
if
(
!
node
)
{
return
null
;
}
let
actionID
=
this
.
_actionIDForNodeID
(
node
.
id
)
;
let
action
=
PageActions
.
actionForID
(
actionID
)
;
if
(
!
action
)
{
for
(
let
n
=
node
.
parentNode
;
n
&
&
!
action
;
n
=
n
.
parentNode
)
{
if
(
n
.
id
=
=
"
page
-
action
-
buttons
"
|
|
n
.
localName
=
=
"
panelview
"
)
{
break
;
}
actionID
=
this
.
_actionIDForNodeID
(
n
.
id
)
;
action
=
PageActions
.
actionForID
(
actionID
)
;
}
}
return
action
&
&
!
action
.
__isSeparator
?
action
:
null
;
}
panelButtonNodeForActionID
(
actionID
)
{
return
document
.
getElementById
(
this
.
panelButtonNodeIDForActionID
(
actionID
)
)
;
}
panelButtonNodeIDForActionID
(
actionID
)
{
return
pageAction
-
panel
-
{
actionID
}
;
}
urlbarButtonNodeForActionID
(
actionID
)
{
return
document
.
getElementById
(
this
.
urlbarButtonNodeIDForActionID
(
actionID
)
)
;
}
urlbarButtonNodeIDForActionID
(
actionID
)
{
let
action
=
PageActions
.
actionForID
(
actionID
)
;
if
(
action
&
&
action
.
urlbarIDOverride
)
{
return
action
.
urlbarIDOverride
;
}
return
pageAction
-
urlbar
-
{
actionID
}
;
}
_panelViewNodeIDForActionID
(
actionID
forUrlbar
)
{
let
placementID
=
forUrlbar
?
"
urlbar
"
:
"
panel
"
;
return
pageAction
-
{
placementID
}
-
{
actionID
}
-
subview
;
}
_actionIDForNodeID
(
nodeID
)
{
if
(
!
nodeID
)
{
return
null
;
}
let
match
=
nodeID
.
match
(
/
^
pageAction
-
(
?
:
panel
|
urlbar
)
-
(
.
+
)
/
)
;
if
(
match
)
{
return
match
[
1
]
;
}
for
(
let
action
of
PageActions
.
actions
)
{
if
(
action
.
urlbarIDOverride
&
&
action
.
urlbarIDOverride
=
=
nodeID
)
{
return
action
.
id
;
}
}
return
null
;
}
mainButtonClicked
(
event
)
{
event
.
stopPropagation
(
)
;
if
(
(
event
.
type
=
=
"
mousedown
"
&
&
(
event
.
button
!
=
0
|
|
(
AppConstants
.
platform
=
=
"
macosx
"
&
&
event
.
ctrlKey
)
)
)
|
|
(
event
.
type
=
=
"
keypress
"
&
&
event
.
charCode
!
=
KeyEvent
.
DOM_VK_SPACE
&
&
event
.
keyCode
!
=
KeyEvent
.
DOM_VK_RETURN
)
)
{
return
;
}
let
panelNode
=
this
.
activatedActionPanelNode
;
if
(
panelNode
&
&
panelNode
.
anchorNode
.
id
=
=
this
.
mainButtonNode
.
id
)
{
PanelMultiView
.
hidePopup
(
panelNode
)
;
return
;
}
if
(
this
.
panelNode
.
state
=
=
"
open
"
)
{
PanelMultiView
.
hidePopup
(
this
.
panelNode
)
;
}
else
if
(
this
.
panelNode
.
state
=
=
"
closed
"
)
{
this
.
showPanel
(
event
)
;
}
}
showPanel
(
event
=
null
)
{
this
.
panelNode
.
hidden
=
false
;
this
.
mainButtonNode
.
setAttribute
(
"
open
"
"
true
"
)
;
PanelMultiView
.
openPopup
(
this
.
panelNode
this
.
mainButtonNode
{
position
:
"
bottomcenter
topright
"
triggerEvent
:
event
}
)
.
catch
(
Cu
.
reportError
)
;
}
onContextMenuShowing
(
event
popup
)
{
if
(
event
.
target
!
=
popup
)
{
return
;
}
this
.
_contextAction
=
this
.
actionForNode
(
popup
.
triggerNode
)
;
if
(
!
this
.
_contextAction
)
{
event
.
preventDefault
(
)
;
return
;
}
let
state
;
if
(
this
.
_contextAction
.
_isMozillaAction
)
{
state
=
this
.
_contextAction
.
pinnedToUrlbar
?
"
builtInPinned
"
:
"
builtInUnpinned
"
;
}
else
{
state
=
this
.
_contextAction
.
pinnedToUrlbar
?
"
extensionPinned
"
:
"
extensionUnpinned
"
;
}
popup
.
setAttribute
(
"
state
"
state
)
;
}
togglePinningForContextAction
(
)
{
if
(
!
this
.
_contextAction
)
{
return
;
}
let
action
=
this
.
_contextAction
;
this
.
_contextAction
=
null
;
action
.
pinnedToUrlbar
=
!
action
.
pinnedToUrlbar
;
}
openAboutAddonsForContextAction
(
)
{
if
(
!
this
.
_contextAction
)
{
return
;
}
let
action
=
this
.
_contextAction
;
this
.
_contextAction
=
null
;
AMTelemetry
.
recordActionEvent
(
{
object
:
"
pageAction
"
action
:
"
manage
"
extra
:
{
addonId
:
action
.
extensionID
}
}
)
;
let
viewID
=
"
addons
:
/
/
detail
/
"
+
encodeURIComponent
(
action
.
extensionID
)
;
window
.
BrowserOpenAddonsMgr
(
viewID
)
;
}
_contextAction
:
null
takeActionTitleFromPanel
(
action
)
{
let
titleOrAttrNameOnPanel
=
action
.
getTitle
(
)
;
let
attrValueOnPanel
=
this
.
panelNode
.
getAttribute
(
titleOrAttrNameOnPanel
)
;
if
(
attrValueOnPanel
)
{
this
.
panelNode
.
removeAttribute
(
titleOrAttrNameOnPanel
)
;
action
.
setTitle
(
attrValueOnPanel
)
;
}
}
takeNodeAttributeFromPanel
(
node
attrName
)
{
let
panelAttrName
=
node
.
getAttribute
(
attrName
)
;
if
(
!
panelAttrName
&
&
attrName
=
=
"
title
"
)
{
attrName
=
"
label
"
;
panelAttrName
=
node
.
getAttribute
(
attrName
)
;
}
if
(
panelAttrName
)
{
let
attrValue
=
this
.
panelNode
.
getAttribute
(
panelAttrName
)
;
if
(
attrValue
)
{
node
.
setAttribute
(
attrName
attrValue
)
;
}
}
}
onLocationChange
(
)
{
for
(
let
action
of
PageActions
.
actions
)
{
action
.
onLocationChange
(
window
)
;
}
}
}
;
function
showBrowserPageActionFeedback
(
action
event
=
null
messageId
=
null
)
{
let
anchor
=
BrowserPageActions
.
panelAnchorNodeForAction
(
action
event
)
;
ConfirmationHint
.
show
(
anchor
messageId
|
|
action
.
id
{
event
hideArrow
:
true
}
)
;
}
BrowserPageActions
.
bookmark
=
{
onShowingInPanel
(
buttonNode
)
{
}
onCommand
(
event
buttonNode
)
{
PanelMultiView
.
hidePopup
(
BrowserPageActions
.
panelNode
)
;
BookmarkingUI
.
onStarCommand
(
event
)
;
}
}
;
BrowserPageActions
.
pinTab
=
{
updateState
(
)
{
let
action
=
PageActions
.
actionForID
(
"
pinTab
"
)
;
let
{
pinned
}
=
gBrowser
.
selectedTab
;
if
(
pinned
)
{
action
.
setTitle
(
BrowserPageActions
.
panelNode
.
getAttribute
(
"
unpinTab
-
title
"
)
)
;
}
else
{
action
.
setTitle
(
BrowserPageActions
.
panelNode
.
getAttribute
(
"
pinTab
-
title
"
)
)
;
}
let
panelButton
=
BrowserPageActions
.
panelButtonNodeForActionID
(
action
.
id
)
;
if
(
panelButton
)
{
panelButton
.
toggleAttribute
(
"
pinned
"
pinned
)
;
}
let
urlbarButton
=
BrowserPageActions
.
urlbarButtonNodeForActionID
(
action
.
id
)
;
if
(
urlbarButton
)
{
urlbarButton
.
toggleAttribute
(
"
pinned
"
pinned
)
;
}
}
onCommand
(
event
buttonNode
)
{
if
(
gBrowser
.
selectedTab
.
pinned
)
{
gBrowser
.
unpinTab
(
gBrowser
.
selectedTab
)
;
}
else
{
gBrowser
.
pinTab
(
gBrowser
.
selectedTab
)
;
}
}
}
;
BrowserPageActions
.
launchSSB
=
{
updateState
(
)
{
let
action
=
PageActions
.
actionForID
(
"
launchSSB
"
)
;
let
browser
=
gBrowser
.
selectedBrowser
;
action
.
setDisabled
(
!
browser
.
currentURI
.
schemeIs
(
"
https
"
)
window
)
;
}
async
onCommand
(
event
buttonNode
)
{
if
(
!
gBrowser
.
currentURI
.
schemeIs
(
"
https
"
)
)
{
return
;
}
let
ssb
=
await
SiteSpecificBrowser
.
createFromBrowser
(
gBrowser
.
selectedBrowser
)
;
await
ssb
.
install
(
)
;
ssb
.
launch
(
gBrowser
.
selectedBrowser
.
currentURI
)
;
gBrowser
.
removeTab
(
gBrowser
.
selectedTab
{
closeWindowWithLastTab
:
false
}
)
;
}
}
;
BrowserPageActions
.
copyURL
=
{
onBeforePlacedInWindow
(
browserWindow
)
{
let
action
=
PageActions
.
actionForID
(
"
copyURL
"
)
;
BrowserPageActions
.
takeActionTitleFromPanel
(
action
)
;
}
onCommand
(
event
buttonNode
)
{
PanelMultiView
.
hidePopup
(
BrowserPageActions
.
panelNode
)
;
Cc
[
"
mozilla
.
org
/
widget
/
clipboardhelper
;
1
"
]
.
getService
(
Ci
.
nsIClipboardHelper
)
.
copyString
(
gURLBar
.
makeURIReadable
(
gBrowser
.
selectedBrowser
.
currentURI
)
.
displaySpec
)
;
let
action
=
PageActions
.
actionForID
(
"
copyURL
"
)
;
showBrowserPageActionFeedback
(
action
event
)
;
}
}
;
BrowserPageActions
.
emailLink
=
{
onBeforePlacedInWindow
(
browserWindow
)
{
let
action
=
PageActions
.
actionForID
(
"
emailLink
"
)
;
BrowserPageActions
.
takeActionTitleFromPanel
(
action
)
;
}
onCommand
(
event
buttonNode
)
{
PanelMultiView
.
hidePopup
(
BrowserPageActions
.
panelNode
)
;
MailIntegration
.
sendLinkForBrowser
(
gBrowser
.
selectedBrowser
)
;
}
}
;
BrowserPageActions
.
sendToDevice
=
{
onBeforePlacedInWindow
(
browserWindow
)
{
this
.
_updateTitle
(
)
;
gBrowser
.
addEventListener
(
"
TabMultiSelect
"
event
=
>
{
this
.
_updateTitle
(
)
;
}
)
;
}
_updateTitle
(
)
{
let
action
=
PageActions
.
actionForID
(
"
sendToDevice
"
)
;
let
string
=
gBrowserBundle
.
GetStringFromName
(
"
pageAction
.
sendTabsToDevice
.
label
"
)
;
let
tabCount
=
gBrowser
.
selectedTabs
.
length
;
let
title
=
PluralForm
.
get
(
tabCount
string
)
.
replace
(
"
#
1
"
tabCount
)
;
action
.
setTitle
(
title
window
)
;
}
onSubviewPlaced
(
panelViewNode
)
{
let
bodyNode
=
panelViewNode
.
querySelector
(
"
.
panel
-
subview
-
body
"
)
;
let
notReady
=
document
.
createXULElement
(
"
toolbarbutton
"
)
;
notReady
.
classList
.
add
(
"
subviewbutton
"
"
subviewbutton
-
iconic
"
"
pageAction
-
sendToDevice
-
notReady
"
)
;
notReady
.
setAttribute
(
"
label
"
"
sendToDevice
-
notReadyTitle
"
)
;
notReady
.
setAttribute
(
"
disabled
"
"
true
"
)
;
bodyNode
.
appendChild
(
notReady
)
;
for
(
let
node
of
bodyNode
.
children
)
{
BrowserPageActions
.
takeNodeAttributeFromPanel
(
node
"
title
"
)
;
BrowserPageActions
.
takeNodeAttributeFromPanel
(
node
"
shortcut
"
)
;
}
}
onLocationChange
(
)
{
let
action
=
PageActions
.
actionForID
(
"
sendToDevice
"
)
;
let
browser
=
gBrowser
.
selectedBrowser
;
let
url
=
browser
.
currentURI
.
spec
;
action
.
setDisabled
(
!
gSync
.
isSendableURI
(
url
)
window
)
;
}
onShowingSubview
(
panelViewNode
)
{
gSync
.
populateSendTabToDevicesView
(
panelViewNode
)
;
}
}
;
BrowserPageActions
.
addSearchEngine
=
{
get
action
(
)
{
return
PageActions
.
actionForID
(
"
addSearchEngine
"
)
;
}
get
engines
(
)
{
return
gBrowser
.
selectedBrowser
.
engines
|
|
[
]
;
}
get
strings
(
)
{
delete
this
.
strings
;
let
uri
=
"
chrome
:
/
/
browser
/
locale
/
search
.
properties
"
;
return
(
this
.
strings
=
Services
.
strings
.
createBundle
(
uri
)
)
;
}
updateEngines
(
)
{
this
.
action
.
setDisabled
(
!
this
.
engines
.
length
window
)
;
if
(
this
.
action
.
shouldShowInUrlbar
(
window
)
)
{
this
.
_updateTitleAndIcon
(
)
;
}
}
_updateTitleAndIcon
(
)
{
if
(
!
this
.
engines
.
length
)
{
return
;
}
let
title
=
this
.
strings
.
GetStringFromName
(
"
searchAddFoundEngine2
"
)
;
this
.
action
.
setTitle
(
title
window
)
;
this
.
action
.
setIconURL
(
this
.
engines
[
0
]
.
icon
window
)
;
}
onShowingInPanel
(
)
{
this
.
_updateTitleAndIcon
(
)
;
this
.
action
.
setWantsSubview
(
this
.
engines
.
length
>
1
window
)
;
let
button
=
BrowserPageActions
.
panelButtonNodeForActionID
(
this
.
action
.
id
)
;
button
.
setAttribute
(
"
image
"
this
.
engines
[
0
]
.
icon
)
;
button
.
setAttribute
(
"
uri
"
this
.
engines
[
0
]
.
uri
)
;
button
.
setAttribute
(
"
crop
"
"
center
"
)
;
}
onSubviewShowing
(
panelViewNode
)
{
let
body
=
panelViewNode
.
querySelector
(
"
.
panel
-
subview
-
body
"
)
;
while
(
body
.
firstChild
)
{
body
.
firstChild
.
remove
(
)
;
}
for
(
let
engine
of
this
.
engines
)
{
let
button
=
document
.
createXULElement
(
"
toolbarbutton
"
)
;
button
.
classList
.
add
(
"
subviewbutton
"
"
subviewbutton
-
iconic
"
)
;
button
.
setAttribute
(
"
label
"
engine
.
title
)
;
button
.
setAttribute
(
"
image
"
engine
.
icon
)
;
button
.
setAttribute
(
"
uri
"
engine
.
uri
)
;
button
.
addEventListener
(
"
command
"
event
=
>
{
let
panelNode
=
panelViewNode
.
closest
(
"
panel
"
)
;
PanelMultiView
.
hidePopup
(
panelNode
)
;
this
.
_installEngine
(
button
.
getAttribute
(
"
uri
"
)
button
.
getAttribute
(
"
image
"
)
)
;
}
)
;
body
.
appendChild
(
button
)
;
}
}
onCommand
(
event
buttonNode
)
{
if
(
!
buttonNode
.
closest
(
"
panel
"
)
)
{
let
manyEngines
=
this
.
engines
.
length
>
1
;
this
.
action
.
setWantsSubview
(
manyEngines
window
)
;
if
(
manyEngines
)
{
return
;
}
}
let
engine
=
this
.
engines
[
0
]
;
this
.
_installEngine
(
engine
.
uri
engine
.
icon
)
;
}
_installEngine
(
uri
image
)
{
Services
.
search
.
addEngine
(
uri
image
false
)
.
then
(
engine
=
>
{
showBrowserPageActionFeedback
(
this
.
action
)
;
}
errorCode
=
>
{
if
(
errorCode
!
=
Ci
.
nsISearchService
.
ERROR_DUPLICATE_ENGINE
)
{
return
;
}
const
kSearchBundleURI
=
"
chrome
:
/
/
global
/
locale
/
search
/
search
.
properties
"
;
let
searchBundle
=
Services
.
strings
.
createBundle
(
kSearchBundleURI
)
;
let
brandBundle
=
document
.
getElementById
(
"
bundle_brand
"
)
;
let
brandName
=
brandBundle
.
getString
(
"
brandShortName
"
)
;
let
title
=
searchBundle
.
GetStringFromName
(
"
error_invalid_engine_title
"
)
;
let
text
=
searchBundle
.
formatStringFromName
(
"
error_duplicate_engine_msg
"
[
brandName
uri
]
)
;
Services
.
prompt
.
QueryInterface
(
Ci
.
nsIPromptFactory
)
;
let
prompt
=
Services
.
prompt
.
getPrompt
(
gBrowser
.
contentWindow
Ci
.
nsIPrompt
)
;
prompt
.
QueryInterface
(
Ci
.
nsIWritablePropertyBag2
)
;
prompt
.
setPropertyAsBool
(
"
allowTabModal
"
true
)
;
prompt
.
alert
(
title
text
)
;
}
)
;
}
}
;
BrowserPageActions
.
shareURL
=
{
onCommand
(
event
buttonNode
)
{
let
browser
=
gBrowser
.
selectedBrowser
;
let
currentURI
=
gURLBar
.
makeURIReadable
(
browser
.
currentURI
)
.
displaySpec
;
this
.
_windowsUIUtils
.
shareUrl
(
currentURI
browser
.
contentTitle
)
;
}
onShowingInPanel
(
buttonNode
)
{
this
.
_cached
=
false
;
}
onBeforePlacedInWindow
(
browserWindow
)
{
let
action
=
PageActions
.
actionForID
(
"
shareURL
"
)
;
BrowserPageActions
.
takeActionTitleFromPanel
(
action
)
;
}
onShowingSubview
(
panelViewNode
)
{
let
bodyNode
=
panelViewNode
.
querySelector
(
"
.
panel
-
subview
-
body
"
)
;
if
(
this
.
_cached
&
&
bodyNode
.
children
.
length
)
{
return
;
}
let
sharingService
=
this
.
_sharingService
;
let
url
=
gBrowser
.
selectedBrowser
.
currentURI
;
let
currentURI
=
gURLBar
.
makeURIReadable
(
url
)
.
displaySpec
;
let
shareProviders
=
sharingService
.
getSharingProviders
(
currentURI
)
;
let
fragment
=
document
.
createDocumentFragment
(
)
;
let
onCommand
=
event
=
>
{
let
shareName
=
event
.
target
.
getAttribute
(
"
share
-
name
"
)
;
if
(
shareName
)
{
sharingService
.
shareUrl
(
shareName
currentURI
gBrowser
.
selectedBrowser
.
contentTitle
)
;
}
else
if
(
event
.
target
.
classList
.
contains
(
"
share
-
more
-
button
"
)
)
{
sharingService
.
openSharingPreferences
(
)
;
}
PanelMultiView
.
hidePopup
(
BrowserPageActions
.
panelNode
)
;
}
;
shareProviders
.
forEach
(
function
(
share
)
{
let
item
=
document
.
createXULElement
(
"
toolbarbutton
"
)
;
item
.
setAttribute
(
"
label
"
share
.
menuItemTitle
)
;
item
.
setAttribute
(
"
share
-
name
"
share
.
name
)
;
item
.
setAttribute
(
"
image
"
share
.
image
)
;
item
.
classList
.
add
(
"
subviewbutton
"
"
subviewbutton
-
iconic
"
)
;
item
.
addEventListener
(
"
command
"
onCommand
)
;
fragment
.
appendChild
(
item
)
;
}
)
;
let
item
=
document
.
createXULElement
(
"
toolbarbutton
"
)
;
item
.
setAttribute
(
"
label
"
BrowserPageActions
.
panelNode
.
getAttribute
(
"
shareMore
-
label
"
)
)
;
item
.
classList
.
add
(
"
subviewbutton
"
"
subviewbutton
-
iconic
"
"
share
-
more
-
button
"
)
;
item
.
addEventListener
(
"
command
"
onCommand
)
;
fragment
.
appendChild
(
item
)
;
while
(
bodyNode
.
firstChild
)
{
bodyNode
.
firstChild
.
remove
(
)
;
}
bodyNode
.
appendChild
(
fragment
)
;
this
.
_cached
=
true
;
}
}
;
XPCOMUtils
.
defineLazyServiceGetters
(
BrowserPageActions
.
shareURL
{
_sharingService
:
[
"
mozilla
.
org
/
widget
/
macsharingservice
;
1
"
"
nsIMacSharingService
"
]
_windowsUIUtils
:
[
"
mozilla
.
org
/
windows
-
ui
-
utils
;
1
"
"
nsIWindowsUIUtils
"
]
}
)
;
