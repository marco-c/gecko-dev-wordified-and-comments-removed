ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
DownloadUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
UpdateUtils
"
"
resource
:
/
/
gre
/
modules
/
UpdateUtils
.
jsm
"
)
;
const
PREF_APP_UPDATE_CANCELATIONS_OSX
=
"
app
.
update
.
cancelations
.
osx
"
;
const
PREF_APP_UPDATE_ELEVATE_NEVER
=
"
app
.
update
.
elevate
.
never
"
;
var
gAppUpdater
;
function
onUnload
(
aEvent
)
{
if
(
gAppUpdater
.
isChecking
)
gAppUpdater
.
checker
.
stopChecking
(
Components
.
interfaces
.
nsIUpdateChecker
.
CURRENT_CHECK
)
;
gAppUpdater
.
removeDownloadListener
(
)
;
gAppUpdater
=
null
;
}
function
appUpdater
(
options
=
{
}
)
{
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
aus
"
"
mozilla
.
org
/
updates
/
update
-
service
;
1
"
"
nsIApplicationUpdateService
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
checker
"
"
mozilla
.
org
/
updates
/
update
-
checker
;
1
"
"
nsIUpdateChecker
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
um
"
"
mozilla
.
org
/
updates
/
update
-
manager
;
1
"
"
nsIUpdateManager
"
)
;
this
.
options
=
options
;
this
.
updateDeck
=
document
.
getElementById
(
"
updateDeck
"
)
;
if
(
Services
.
wm
.
getMostRecentWindow
(
"
Update
:
Wizard
"
)
&
&
!
this
.
isApplied
)
{
this
.
updateDeck
.
hidden
=
true
;
return
;
}
this
.
bundle
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
browser
/
locale
/
browser
.
properties
"
)
;
let
manualURL
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
update
.
url
.
manual
"
)
;
let
manualLink
=
document
.
getElementById
(
"
manualLink
"
)
;
manualLink
.
textContent
=
manualURL
;
manualLink
.
href
=
manualURL
;
document
.
getElementById
(
"
failedLink
"
)
.
href
=
manualURL
;
if
(
this
.
updateDisabledAndLocked
)
{
this
.
selectPanel
(
"
adminDisabled
"
)
;
return
;
}
if
(
this
.
isPending
|
|
this
.
isApplied
)
{
this
.
selectPanel
(
"
apply
"
)
;
return
;
}
if
(
this
.
aus
.
isOtherInstanceHandlingUpdates
)
{
this
.
selectPanel
(
"
otherInstanceHandlingUpdates
"
)
;
return
;
}
if
(
this
.
isDownloading
)
{
this
.
startDownload
(
)
;
return
;
}
if
(
!
this
.
updateEnabled
|
|
Services
.
prefs
.
prefHasUserValue
(
PREF_APP_UPDATE_ELEVATE_NEVER
)
)
{
this
.
selectPanel
(
"
checkForUpdates
"
)
;
return
;
}
this
.
checkForUpdates
(
)
;
}
appUpdater
.
prototype
=
{
isChecking
:
false
get
isPending
(
)
{
if
(
this
.
update
)
{
return
this
.
update
.
state
=
=
"
pending
"
|
|
this
.
update
.
state
=
=
"
pending
-
service
"
|
|
this
.
update
.
state
=
=
"
pending
-
elevate
"
;
}
return
this
.
um
.
activeUpdate
&
&
(
this
.
um
.
activeUpdate
.
state
=
=
"
pending
"
|
|
this
.
um
.
activeUpdate
.
state
=
=
"
pending
-
service
"
|
|
this
.
um
.
activeUpdate
.
state
=
=
"
pending
-
elevate
"
)
;
}
get
isApplied
(
)
{
if
(
this
.
update
)
return
this
.
update
.
state
=
=
"
applied
"
|
|
this
.
update
.
state
=
=
"
applied
-
service
"
;
return
this
.
um
.
activeUpdate
&
&
(
this
.
um
.
activeUpdate
.
state
=
=
"
applied
"
|
|
this
.
um
.
activeUpdate
.
state
=
=
"
applied
-
service
"
)
;
}
get
isDownloading
(
)
{
if
(
this
.
update
)
return
this
.
update
.
state
=
=
"
downloading
"
;
return
this
.
um
.
activeUpdate
&
&
this
.
um
.
activeUpdate
.
state
=
=
"
downloading
"
;
}
get
updateDisabledAndLocked
(
)
{
return
(
!
this
.
updateEnabled
&
&
Services
.
prefs
.
prefIsLocked
(
"
app
.
update
.
enabled
"
)
)
|
|
(
Services
.
policies
&
&
!
Services
.
policies
.
isAllowed
(
"
appUpdate
"
)
)
;
}
get
updateEnabled
(
)
{
try
{
return
Services
.
prefs
.
getBoolPref
(
"
app
.
update
.
enabled
"
)
;
}
catch
(
e
)
{
}
return
true
;
}
get
backgroundUpdateEnabled
(
)
{
return
this
.
updateEnabled
&
&
gAppUpdater
.
aus
.
canStageUpdates
;
}
get
updateAuto
(
)
{
try
{
return
Services
.
prefs
.
getBoolPref
(
"
app
.
update
.
auto
"
)
;
}
catch
(
e
)
{
}
return
true
;
}
selectPanel
(
aChildID
)
{
let
panel
=
document
.
getElementById
(
aChildID
)
;
let
button
=
panel
.
querySelector
(
"
button
"
)
;
if
(
button
)
{
if
(
aChildID
=
=
"
downloadAndInstall
"
)
{
let
updateVersion
=
gAppUpdater
.
update
.
displayVersion
;
if
(
/
a
\
d
+
/
.
test
(
updateVersion
)
)
{
let
buildID
=
gAppUpdater
.
update
.
buildID
;
let
year
=
buildID
.
slice
(
0
4
)
;
let
month
=
buildID
.
slice
(
4
6
)
;
let
day
=
buildID
.
slice
(
6
8
)
;
updateVersion
+
=
(
{
year
}
-
{
month
}
-
{
day
}
)
;
}
button
.
label
=
this
.
bundle
.
formatStringFromName
(
"
update
.
downloadAndInstallButton
.
label
"
[
updateVersion
]
1
)
;
button
.
accessKey
=
this
.
bundle
.
GetStringFromName
(
"
update
.
downloadAndInstallButton
.
accesskey
"
)
;
}
this
.
updateDeck
.
selectedPanel
=
panel
;
if
(
this
.
options
.
buttonAutoFocus
&
&
(
!
document
.
commandDispatcher
.
focusedElement
|
|
document
.
commandDispatcher
.
focusedElement
.
localName
=
=
"
button
"
)
)
{
button
.
focus
(
)
;
}
}
else
{
this
.
updateDeck
.
selectedPanel
=
panel
;
}
}
checkForUpdates
(
)
{
if
(
Services
.
prefs
.
prefHasUserValue
(
PREF_APP_UPDATE_CANCELATIONS_OSX
)
)
{
Services
.
prefs
.
clearUserPref
(
PREF_APP_UPDATE_CANCELATIONS_OSX
)
;
}
if
(
Services
.
prefs
.
prefHasUserValue
(
PREF_APP_UPDATE_ELEVATE_NEVER
)
)
{
Services
.
prefs
.
clearUserPref
(
PREF_APP_UPDATE_ELEVATE_NEVER
)
;
}
this
.
selectPanel
(
"
checkingForUpdates
"
)
;
this
.
isChecking
=
true
;
this
.
checker
.
checkForUpdates
(
this
.
updateCheckListener
true
)
;
}
buttonRestartAfterDownload
(
)
{
if
(
!
this
.
isPending
&
&
!
this
.
isApplied
)
{
return
;
}
gAppUpdater
.
selectPanel
(
"
restarting
"
)
;
let
cancelQuit
=
Components
.
classes
[
"
mozilla
.
org
/
supports
-
PRBool
;
1
"
]
.
createInstance
(
Components
.
interfaces
.
nsISupportsPRBool
)
;
Services
.
obs
.
notifyObservers
(
cancelQuit
"
quit
-
application
-
requested
"
"
restart
"
)
;
if
(
cancelQuit
.
data
)
{
gAppUpdater
.
selectPanel
(
"
apply
"
)
;
return
;
}
if
(
Services
.
appinfo
.
inSafeMode
)
{
Services
.
startup
.
restartInSafeMode
(
Components
.
interfaces
.
nsIAppStartup
.
eAttemptQuit
)
;
return
;
}
Services
.
startup
.
quit
(
Components
.
interfaces
.
nsIAppStartup
.
eAttemptQuit
|
Components
.
interfaces
.
nsIAppStartup
.
eRestart
)
;
}
updateCheckListener
:
{
onCheckComplete
(
aRequest
aUpdates
aUpdateCount
)
{
gAppUpdater
.
isChecking
=
false
;
gAppUpdater
.
update
=
gAppUpdater
.
aus
.
selectUpdate
(
aUpdates
aUpdates
.
length
)
;
if
(
!
gAppUpdater
.
update
)
{
gAppUpdater
.
selectPanel
(
"
noUpdatesFound
"
)
;
return
;
}
if
(
gAppUpdater
.
update
.
unsupported
)
{
if
(
gAppUpdater
.
update
.
detailsURL
)
{
let
unsupportedLink
=
document
.
getElementById
(
"
unsupportedLink
"
)
;
unsupportedLink
.
href
=
gAppUpdater
.
update
.
detailsURL
;
}
gAppUpdater
.
selectPanel
(
"
unsupportedSystem
"
)
;
return
;
}
if
(
!
gAppUpdater
.
aus
.
canApplyUpdates
)
{
gAppUpdater
.
selectPanel
(
"
manualUpdate
"
)
;
return
;
}
if
(
gAppUpdater
.
updateAuto
)
gAppUpdater
.
startDownload
(
)
;
else
gAppUpdater
.
selectPanel
(
"
downloadAndInstall
"
)
;
}
onError
(
aRequest
aUpdate
)
{
gAppUpdater
.
isChecking
=
false
;
gAppUpdater
.
selectPanel
(
"
noUpdatesFound
"
)
;
}
QueryInterface
(
aIID
)
{
if
(
!
aIID
.
equals
(
Components
.
interfaces
.
nsIUpdateCheckListener
)
&
&
!
aIID
.
equals
(
Components
.
interfaces
.
nsISupports
)
)
throw
Components
.
results
.
NS_ERROR_NO_INTERFACE
;
return
this
;
}
}
startDownload
(
)
{
if
(
!
this
.
update
)
this
.
update
=
this
.
um
.
activeUpdate
;
this
.
update
.
QueryInterface
(
Components
.
interfaces
.
nsIWritablePropertyBag
)
;
this
.
update
.
setProperty
(
"
foregroundDownload
"
"
true
"
)
;
this
.
aus
.
pauseDownload
(
)
;
let
state
=
this
.
aus
.
downloadUpdate
(
this
.
update
false
)
;
if
(
state
=
=
"
failed
"
)
{
this
.
selectPanel
(
"
downloadFailed
"
)
;
return
;
}
this
.
setupDownloadingUI
(
)
;
}
setupDownloadingUI
(
)
{
this
.
downloadStatus
=
document
.
getElementById
(
"
downloadStatus
"
)
;
this
.
downloadStatus
.
textContent
=
DownloadUtils
.
getTransferTotal
(
0
this
.
update
.
selectedPatch
.
size
)
;
this
.
selectPanel
(
"
downloading
"
)
;
this
.
aus
.
addDownloadListener
(
this
)
;
}
removeDownloadListener
(
)
{
if
(
this
.
aus
)
{
this
.
aus
.
removeDownloadListener
(
this
)
;
}
}
onStartRequest
(
aRequest
aContext
)
{
}
onStopRequest
(
aRequest
aContext
aStatusCode
)
{
switch
(
aStatusCode
)
{
case
Components
.
results
.
NS_ERROR_UNEXPECTED
:
if
(
this
.
update
.
selectedPatch
.
state
=
=
"
download
-
failed
"
&
&
(
this
.
update
.
isCompleteUpdate
|
|
this
.
update
.
patchCount
!
=
2
)
)
{
this
.
removeDownloadListener
(
)
;
this
.
selectPanel
(
"
downloadFailed
"
)
;
break
;
}
break
;
case
Components
.
results
.
NS_BINDING_ABORTED
:
break
;
case
Components
.
results
.
NS_OK
:
this
.
removeDownloadListener
(
)
;
if
(
this
.
backgroundUpdateEnabled
)
{
this
.
selectPanel
(
"
applying
"
)
;
let
self
=
this
;
Services
.
obs
.
addObserver
(
function
observer
(
aSubject
aTopic
aData
)
{
let
status
=
aData
;
if
(
status
=
=
"
applied
"
|
|
status
=
=
"
applied
-
service
"
|
|
status
=
=
"
pending
"
|
|
status
=
=
"
pending
-
service
"
|
|
status
=
=
"
pending
-
elevate
"
)
{
self
.
selectPanel
(
"
apply
"
)
;
}
else
if
(
status
=
=
"
failed
"
)
{
self
.
selectPanel
(
"
downloadFailed
"
)
;
}
else
if
(
status
=
=
"
downloading
"
)
{
self
.
setupDownloadingUI
(
)
;
return
;
}
Services
.
obs
.
removeObserver
(
observer
"
update
-
staged
"
)
;
}
"
update
-
staged
"
)
;
}
else
{
this
.
selectPanel
(
"
apply
"
)
;
}
break
;
default
:
this
.
removeDownloadListener
(
)
;
this
.
selectPanel
(
"
downloadFailed
"
)
;
break
;
}
}
onStatus
(
aRequest
aContext
aStatus
aStatusArg
)
{
}
onProgress
(
aRequest
aContext
aProgress
aProgressMax
)
{
this
.
downloadStatus
.
textContent
=
DownloadUtils
.
getTransferTotal
(
aProgress
aProgressMax
)
;
}
QueryInterface
(
aIID
)
{
if
(
!
aIID
.
equals
(
Components
.
interfaces
.
nsIProgressEventSink
)
&
&
!
aIID
.
equals
(
Components
.
interfaces
.
nsIRequestObserver
)
&
&
!
aIID
.
equals
(
Components
.
interfaces
.
nsISupports
)
)
throw
Components
.
results
.
NS_ERROR_NO_INTERFACE
;
return
this
;
}
}
;
