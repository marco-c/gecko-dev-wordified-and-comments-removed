var
FeedHandler
=
{
buildFeedList
(
container
isSubview
)
{
let
feeds
=
gBrowser
.
selectedBrowser
.
feeds
;
if
(
!
isSubview
&
&
feeds
=
=
null
)
{
container
.
parentNode
.
removeAttribute
(
"
open
"
)
;
return
false
;
}
for
(
let
i
=
container
.
childNodes
.
length
-
1
;
i
>
=
0
;
-
-
i
)
{
let
node
=
container
.
childNodes
[
i
]
;
if
(
isSubview
&
&
node
.
localName
=
=
"
label
"
)
continue
;
container
.
removeChild
(
node
)
;
}
if
(
!
feeds
|
|
feeds
.
length
<
=
1
)
return
false
;
let
itemNodeType
=
isSubview
?
"
toolbarbutton
"
:
"
menuitem
"
;
for
(
let
feedInfo
of
feeds
)
{
let
item
=
document
.
createElement
(
itemNodeType
)
;
let
baseTitle
=
feedInfo
.
title
|
|
feedInfo
.
href
;
item
.
setAttribute
(
"
label
"
baseTitle
)
;
item
.
setAttribute
(
"
feed
"
feedInfo
.
href
)
;
item
.
setAttribute
(
"
tooltiptext
"
feedInfo
.
href
)
;
item
.
setAttribute
(
"
crop
"
"
center
"
)
;
let
className
=
"
feed
-
"
+
itemNodeType
;
if
(
isSubview
)
{
className
+
=
"
subviewbutton
"
;
}
item
.
setAttribute
(
"
class
"
className
)
;
container
.
appendChild
(
item
)
;
}
return
true
;
}
subscribeToFeed
(
href
event
)
{
if
(
!
href
)
href
=
event
.
target
.
getAttribute
(
"
feed
"
)
;
urlSecurityCheck
(
href
gBrowser
.
contentPrincipal
Ci
.
nsIScriptSecurityManager
.
DISALLOW_INHERIT_PRINCIPAL
)
;
let
feedURI
=
makeURI
(
href
document
.
characterSet
)
;
if
(
/
^
https
?
/
.
test
(
feedURI
.
scheme
)
)
href
=
"
feed
:
"
+
href
;
this
.
loadFeed
(
href
event
)
;
}
loadFeed
(
href
event
)
{
let
feeds
=
gBrowser
.
selectedBrowser
.
feeds
;
try
{
openUILink
(
href
event
{
ignoreAlt
:
true
}
)
;
}
finally
{
gBrowser
.
selectedBrowser
.
feeds
=
feeds
;
}
}
get
_feedMenuitem
(
)
{
delete
this
.
_feedMenuitem
;
return
this
.
_feedMenuitem
=
document
.
getElementById
(
"
singleFeedMenuitemState
"
)
;
}
get
_feedMenupopup
(
)
{
delete
this
.
_feedMenupopup
;
return
this
.
_feedMenupopup
=
document
.
getElementById
(
"
multipleFeedsMenuState
"
)
;
}
updateFeeds
(
)
{
if
(
this
.
_updateFeedTimeout
)
clearTimeout
(
this
.
_updateFeedTimeout
)
;
let
feeds
=
gBrowser
.
selectedBrowser
.
feeds
;
let
haveFeeds
=
feeds
&
&
feeds
.
length
>
0
;
let
feedButton
=
document
.
getElementById
(
"
feed
-
button
"
)
;
if
(
feedButton
)
{
if
(
haveFeeds
)
{
feedButton
.
removeAttribute
(
"
disabled
"
)
;
}
else
{
feedButton
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
}
if
(
!
haveFeeds
)
{
this
.
_feedMenuitem
.
setAttribute
(
"
disabled
"
"
true
"
)
;
this
.
_feedMenuitem
.
removeAttribute
(
"
hidden
"
)
;
this
.
_feedMenupopup
.
setAttribute
(
"
hidden
"
"
true
"
)
;
return
;
}
if
(
feeds
.
length
>
1
)
{
this
.
_feedMenuitem
.
setAttribute
(
"
hidden
"
"
true
"
)
;
this
.
_feedMenupopup
.
removeAttribute
(
"
hidden
"
)
;
}
else
{
this
.
_feedMenuitem
.
setAttribute
(
"
feed
"
feeds
[
0
]
.
href
)
;
this
.
_feedMenuitem
.
removeAttribute
(
"
disabled
"
)
;
this
.
_feedMenuitem
.
removeAttribute
(
"
hidden
"
)
;
this
.
_feedMenupopup
.
setAttribute
(
"
hidden
"
"
true
"
)
;
}
}
addFeed
(
link
browserForLink
)
{
if
(
!
browserForLink
.
feeds
)
browserForLink
.
feeds
=
[
]
;
browserForLink
.
feeds
.
push
(
{
href
:
link
.
href
title
:
link
.
title
}
)
;
if
(
browserForLink
=
=
gBrowser
.
selectedBrowser
)
{
if
(
this
.
_updateFeedTimeout
)
clearTimeout
(
this
.
_updateFeedTimeout
)
;
this
.
_updateFeedTimeout
=
setTimeout
(
this
.
updateFeeds
.
bind
(
this
)
100
)
;
}
}
_getFileDisplayName
(
file
)
{
switch
(
AppConstants
.
platform
)
{
case
"
win
"
:
if
(
file
instanceof
Ci
.
nsILocalFileWin
)
{
try
{
return
file
.
getVersionInfoField
(
"
FileDescription
"
)
;
}
catch
(
e
)
{
}
}
break
;
case
"
macosx
"
:
if
(
file
instanceof
Ci
.
nsILocalFileMac
)
{
try
{
return
file
.
bundleDisplayName
;
}
catch
(
e
)
{
}
}
break
;
}
return
file
.
leafName
;
}
chooseClientApp
(
aTitle
aPrefName
aBrowser
)
{
let
fp
=
Cc
[
"
mozilla
.
org
/
filepicker
;
1
"
]
.
createInstance
(
Ci
.
nsIFilePicker
)
;
fp
.
init
(
window
aTitle
Ci
.
nsIFilePicker
.
modeOpen
)
;
fp
.
appendFilters
(
Ci
.
nsIFilePicker
.
filterApps
)
;
fp
.
open
(
(
aResult
)
=
>
{
if
(
aResult
=
=
Ci
.
nsIFilePicker
.
returnOK
)
{
let
selectedApp
=
fp
.
file
;
if
(
selectedApp
)
{
let
appName
=
"
"
;
switch
(
AppConstants
.
platform
)
{
case
"
win
"
:
appName
=
AppConstants
.
MOZ_APP_NAME
+
"
.
exe
"
;
break
;
case
"
macosx
"
:
appName
=
AppConstants
.
MOZ_MACBUNDLE_NAME
;
break
;
default
:
appName
=
AppConstants
.
MOZ_APP_NAME
+
"
-
bin
"
;
break
;
}
if
(
fp
.
file
.
leafName
!
=
appName
)
{
Services
.
prefs
.
setComplexValue
(
aPrefName
Ci
.
nsILocalFile
selectedApp
)
;
aBrowser
.
messageManager
.
sendAsyncMessage
(
"
FeedWriter
:
SetApplicationLauncherMenuItem
"
{
name
:
this
.
_getFileDisplayName
(
selectedApp
)
type
:
"
SelectedAppMenuItem
"
}
)
;
}
}
}
}
)
;
}
executeClientApp
(
aSpec
aTitle
aSubtitle
aFeedHandler
)
{
let
clientApp
=
null
;
if
(
aFeedHandler
=
=
"
default
"
)
{
clientApp
=
Cc
[
"
mozilla
.
org
/
browser
/
shell
-
service
;
1
"
]
.
getService
(
Ci
.
nsIShellService
)
.
defaultFeedReader
;
}
else
{
clientApp
=
Services
.
prefs
.
getComplexValue
(
aFeedHandler
Ci
.
nsILocalFile
)
;
}
let
feedURI
=
NetUtil
.
newURI
(
aSpec
)
;
if
(
feedURI
.
schemeIs
(
"
http
"
)
)
{
feedURI
.
scheme
=
"
feed
"
;
aSpec
=
feedURI
.
spec
;
}
else
{
aSpec
=
"
feed
:
"
+
aSpec
;
}
try
{
let
ss
=
Cc
[
"
mozilla
.
org
/
browser
/
shell
-
service
;
1
"
]
.
getService
(
Ci
.
nsIShellService
)
;
ss
.
openApplicationWithURI
(
clientApp
aSpec
)
;
}
catch
(
e
)
{
let
p
=
Cc
[
"
mozilla
.
org
/
process
/
util
;
1
"
]
.
createInstance
(
Ci
.
nsIProcess
)
;
p
.
init
(
clientApp
)
;
p
.
run
(
false
[
aSpec
]
1
)
;
}
}
init
(
)
{
window
.
messageManager
.
addMessageListener
(
"
FeedWriter
:
ChooseClientApp
"
this
)
;
window
.
messageManager
.
addMessageListener
(
"
FeedWriter
:
RequestClientAppName
"
this
)
;
window
.
messageManager
.
addMessageListener
(
"
FeedWriter
:
SetFeedCharPref
"
this
)
;
window
.
messageManager
.
addMessageListener
(
"
FeedWriter
:
SetFeedComplexString
"
this
)
;
window
.
messageManager
.
addMessageListener
(
"
FeedWriter
:
ShownFirstRun
"
this
)
;
Services
.
ppmm
.
addMessageListener
(
"
FeedConverter
:
ExecuteClientApp
"
this
)
;
}
uninit
(
)
{
Services
.
ppmm
.
removeMessageListener
(
"
FeedConverter
:
ExecuteClientApp
"
this
)
;
}
receiveMessage
(
msg
)
{
switch
(
msg
.
name
)
{
case
"
FeedWriter
:
ChooseClientApp
"
:
this
.
chooseClientApp
(
msg
.
data
.
title
msg
.
data
.
prefName
msg
.
target
)
;
break
;
case
"
FeedWriter
:
RequestClientAppName
"
:
let
selectedClientApp
;
try
{
selectedClientApp
=
Services
.
prefs
.
getComplexValue
(
msg
.
data
.
feedTypePref
Ci
.
nsILocalFile
)
;
}
catch
(
ex
)
{
}
let
defaultClientApp
=
null
;
try
{
defaultClientApp
=
Cc
[
"
mozilla
.
org
/
browser
/
shell
-
service
;
1
"
]
.
getService
(
Ci
.
nsIShellService
)
.
defaultFeedReader
;
}
catch
(
ex
)
{
}
if
(
selectedClientApp
&
&
selectedClientApp
.
exists
(
)
)
{
if
(
defaultClientApp
&
&
selectedClientApp
.
path
!
=
defaultClientApp
.
path
)
{
msg
.
target
.
messageManager
.
sendAsyncMessage
(
"
FeedWriter
:
SetApplicationLauncherMenuItem
"
{
name
:
this
.
_getFileDisplayName
(
defaultClientApp
)
type
:
"
DefaultAppMenuItem
"
}
)
;
}
msg
.
target
.
messageManager
.
sendAsyncMessage
(
"
FeedWriter
:
SetApplicationLauncherMenuItem
"
{
name
:
this
.
_getFileDisplayName
(
selectedClientApp
)
type
:
"
SelectedAppMenuItem
"
}
)
;
}
break
;
case
"
FeedWriter
:
ShownFirstRun
"
:
Services
.
prefs
.
setBoolPref
(
"
browser
.
feeds
.
showFirstRunUI
"
false
)
;
break
;
case
"
FeedWriter
:
SetFeedCharPref
"
:
Services
.
prefs
.
setCharPref
(
msg
.
data
.
pref
msg
.
data
.
value
)
;
break
;
case
"
FeedWriter
:
SetFeedComplexString
"
:
{
let
supportsString
=
Cc
[
"
mozilla
.
org
/
supports
-
string
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsString
)
;
supportsString
.
data
=
msg
.
data
.
value
;
Services
.
prefs
.
setComplexValue
(
msg
.
data
.
pref
Ci
.
nsISupportsString
supportsString
)
;
break
;
}
case
"
FeedConverter
:
ExecuteClientApp
"
:
this
.
executeClientApp
(
msg
.
data
.
spec
msg
.
data
.
title
msg
.
data
.
subtitle
msg
.
data
.
feedHandler
)
;
break
;
}
}
}
;
