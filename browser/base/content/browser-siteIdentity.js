var
gIdentityHandler
=
{
_uri
:
null
_uriHasHost
:
false
_pageExtensionPolicy
:
null
_isSecureInternalUI
:
false
_isSecureContext
:
false
_secInfo
:
null
_state
:
0
_secureInternalUIWhitelist
:
/
^
(
?
:
accounts
|
addons
|
cache
|
certificate
|
config
|
crashes
|
downloads
|
license
|
logins
|
preferences
|
protections
|
rights
|
sessionrestore
|
support
|
welcomeback
)
(
?
:
[
?
#
]
|
)
/
i
get
_isBrokenConnection
(
)
{
return
this
.
_state
&
Ci
.
nsIWebProgressListener
.
STATE_IS_BROKEN
;
}
get
_isSecureConnection
(
)
{
return
(
!
this
.
_isURILoadedFromFile
&
&
this
.
_state
&
Ci
.
nsIWebProgressListener
.
STATE_IS_SECURE
)
;
}
get
_isEV
(
)
{
return
(
!
this
.
_isURILoadedFromFile
&
&
this
.
_state
&
Ci
.
nsIWebProgressListener
.
STATE_IDENTITY_EV_TOPLEVEL
)
;
}
get
_isMixedActiveContentLoaded
(
)
{
return
(
this
.
_state
&
Ci
.
nsIWebProgressListener
.
STATE_LOADED_MIXED_ACTIVE_CONTENT
)
;
}
get
_isMixedActiveContentBlocked
(
)
{
return
(
this
.
_state
&
Ci
.
nsIWebProgressListener
.
STATE_BLOCKED_MIXED_ACTIVE_CONTENT
)
;
}
get
_isMixedPassiveContentLoaded
(
)
{
return
(
this
.
_state
&
Ci
.
nsIWebProgressListener
.
STATE_LOADED_MIXED_DISPLAY_CONTENT
)
;
}
get
_isCertUserOverridden
(
)
{
return
this
.
_state
&
Ci
.
nsIWebProgressListener
.
STATE_CERT_USER_OVERRIDDEN
;
}
get
_isCertDistrustImminent
(
)
{
return
this
.
_state
&
Ci
.
nsIWebProgressListener
.
STATE_CERT_DISTRUST_IMMINENT
;
}
get
_isAboutCertErrorPage
(
)
{
return
(
gBrowser
.
selectedBrowser
.
documentURI
&
&
gBrowser
.
selectedBrowser
.
documentURI
.
scheme
=
=
"
about
"
&
&
gBrowser
.
selectedBrowser
.
documentURI
.
pathQueryRef
.
startsWith
(
"
certerror
"
)
)
;
}
get
_identityPopup
(
)
{
delete
this
.
_identityPopup
;
return
(
this
.
_identityPopup
=
document
.
getElementById
(
"
identity
-
popup
"
)
)
;
}
get
_identityBox
(
)
{
delete
this
.
_identityBox
;
return
(
this
.
_identityBox
=
document
.
getElementById
(
"
identity
-
box
"
)
)
;
}
get
_identityPopupMultiView
(
)
{
delete
this
.
_identityPopupMultiView
;
return
(
this
.
_identityPopupMultiView
=
document
.
getElementById
(
"
identity
-
popup
-
multiView
"
)
)
;
}
get
_identityPopupMainView
(
)
{
delete
this
.
_identityPopupMainView
;
return
(
this
.
_identityPopupMainView
=
document
.
getElementById
(
"
identity
-
popup
-
mainView
"
)
)
;
}
get
_identityPopupMainViewHeaderLabel
(
)
{
delete
this
.
_identityPopupMainViewHeaderLabel
;
return
(
this
.
_identityPopupMainViewHeaderLabel
=
document
.
getElementById
(
"
identity
-
popup
-
mainView
-
panel
-
header
-
span
"
)
)
;
}
get
_identityPopupSecurityView
(
)
{
delete
this
.
_identityPopupSecurityView
;
return
(
this
.
_identityPopupSecurityView
=
document
.
getElementById
(
"
identity
-
popup
-
securityView
"
)
)
;
}
get
_identityPopupSecurityEVContentOwner
(
)
{
delete
this
.
_identityPopupSecurityEVContentOwner
;
return
(
this
.
_identityPopupSecurityEVContentOwner
=
document
.
getElementById
(
"
identity
-
popup
-
security
-
ev
-
content
-
owner
"
)
)
;
}
get
_identityPopupContentOwner
(
)
{
delete
this
.
_identityPopupContentOwner
;
return
(
this
.
_identityPopupContentOwner
=
document
.
getElementById
(
"
identity
-
popup
-
content
-
owner
"
)
)
;
}
get
_identityPopupContentSupp
(
)
{
delete
this
.
_identityPopupContentSupp
;
return
(
this
.
_identityPopupContentSupp
=
document
.
getElementById
(
"
identity
-
popup
-
content
-
supplemental
"
)
)
;
}
get
_identityPopupContentVerif
(
)
{
delete
this
.
_identityPopupContentVerif
;
return
(
this
.
_identityPopupContentVerif
=
document
.
getElementById
(
"
identity
-
popup
-
content
-
verifier
"
)
)
;
}
get
_identityPopupCustomRootLearnMore
(
)
{
delete
this
.
_identityPopupCustomRootLearnMore
;
return
(
this
.
_identityPopupCustomRootLearnMore
=
document
.
getElementById
(
"
identity
-
popup
-
custom
-
root
-
learn
-
more
"
)
)
;
}
get
_identityPopupMixedContentLearnMore
(
)
{
delete
this
.
_identityPopupMixedContentLearnMore
;
return
(
this
.
_identityPopupMixedContentLearnMore
=
[
.
.
.
document
.
querySelectorAll
(
"
.
identity
-
popup
-
mcb
-
learn
-
more
"
)
]
)
;
}
get
_identityIconLabel
(
)
{
delete
this
.
_identityIconLabel
;
return
(
this
.
_identityIconLabel
=
document
.
getElementById
(
"
identity
-
icon
-
label
"
)
)
;
}
get
_overrideService
(
)
{
delete
this
.
_overrideService
;
return
(
this
.
_overrideService
=
Cc
[
"
mozilla
.
org
/
security
/
certoverride
;
1
"
]
.
getService
(
Ci
.
nsICertOverrideService
)
)
;
}
get
_identityIcon
(
)
{
delete
this
.
_identityIcon
;
return
(
this
.
_identityIcon
=
document
.
getElementById
(
"
identity
-
icon
"
)
)
;
}
get
_permissionList
(
)
{
delete
this
.
_permissionList
;
return
(
this
.
_permissionList
=
document
.
getElementById
(
"
identity
-
popup
-
permission
-
list
"
)
)
;
}
get
_permissionEmptyHint
(
)
{
delete
this
.
_permissionEmptyHint
;
return
(
this
.
_permissionEmptyHint
=
document
.
getElementById
(
"
identity
-
popup
-
permission
-
empty
-
hint
"
)
)
;
}
get
_permissionReloadHint
(
)
{
delete
this
.
_permissionReloadHint
;
return
(
this
.
_permissionReloadHint
=
document
.
getElementById
(
"
identity
-
popup
-
permission
-
reload
-
hint
"
)
)
;
}
get
_popupExpander
(
)
{
delete
this
.
_popupExpander
;
return
(
this
.
_popupExpander
=
document
.
getElementById
(
"
identity
-
popup
-
security
-
expander
"
)
)
;
}
get
_clearSiteDataFooter
(
)
{
delete
this
.
_clearSiteDataFooter
;
return
(
this
.
_clearSiteDataFooter
=
document
.
getElementById
(
"
identity
-
popup
-
clear
-
sitedata
-
footer
"
)
)
;
}
get
_permissionAnchors
(
)
{
delete
this
.
_permissionAnchors
;
let
permissionAnchors
=
{
}
;
for
(
let
anchor
of
document
.
getElementById
(
"
blocked
-
permissions
-
container
"
)
.
children
)
{
permissionAnchors
[
anchor
.
getAttribute
(
"
data
-
permission
-
id
"
)
]
=
anchor
;
}
return
(
this
.
_permissionAnchors
=
permissionAnchors
)
;
}
get
_geoSharingIcon
(
)
{
delete
this
.
_geoSharingIcon
;
return
(
this
.
_geoSharingIcon
=
document
.
getElementById
(
"
geo
-
sharing
-
icon
"
)
)
;
}
get
_xrSharingIcon
(
)
{
delete
this
.
_xrSharingIcon
;
return
(
this
.
_xrSharingIcon
=
document
.
getElementById
(
"
xr
-
sharing
-
icon
"
)
)
;
}
get
_webRTCSharingIcon
(
)
{
delete
this
.
_webRTCSharingIcon
;
return
(
this
.
_webRTCSharingIcon
=
document
.
getElementById
(
"
webrtc
-
sharing
-
icon
"
)
)
;
}
get
_insecureConnectionIconEnabled
(
)
{
delete
this
.
_insecureConnectionIconEnabled
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
_insecureConnectionIconEnabled
"
"
security
.
insecure_connection_icon
.
enabled
"
)
;
return
this
.
_insecureConnectionIconEnabled
;
}
get
_insecureConnectionIconPBModeEnabled
(
)
{
delete
this
.
_insecureConnectionIconPBModeEnabled
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
_insecureConnectionIconPBModeEnabled
"
"
security
.
insecure_connection_icon
.
pbmode
.
enabled
"
)
;
return
this
.
_insecureConnectionIconPBModeEnabled
;
}
get
_insecureConnectionTextEnabled
(
)
{
delete
this
.
_insecureConnectionTextEnabled
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
_insecureConnectionTextEnabled
"
"
security
.
insecure_connection_text
.
enabled
"
)
;
return
this
.
_insecureConnectionTextEnabled
;
}
get
_insecureConnectionTextPBModeEnabled
(
)
{
delete
this
.
_insecureConnectionTextPBModeEnabled
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
_insecureConnectionTextPBModeEnabled
"
"
security
.
insecure_connection_text
.
pbmode
.
enabled
"
)
;
return
this
.
_insecureConnectionTextPBModeEnabled
;
}
get
_protectionsPanelEnabled
(
)
{
delete
this
.
_protectionsPanelEnabled
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
_protectionsPanelEnabled
"
"
browser
.
protections_panel
.
enabled
"
false
)
;
return
this
.
_protectionsPanelEnabled
;
}
get
_useGrayLockIcon
(
)
{
delete
this
.
_useGrayLockIcon
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
_useGrayLockIcon
"
"
security
.
secure_connection_icon_color_gray
"
false
)
;
return
this
.
_useGrayLockIcon
;
}
async
clearSiteData
(
event
)
{
if
(
!
this
.
_uriHasHost
)
{
return
;
}
let
host
=
this
.
_uri
.
host
;
await
SiteDataManager
.
updateSites
(
)
;
let
baseDomain
=
SiteDataManager
.
getBaseDomainFromHost
(
host
)
;
let
siteData
=
await
SiteDataManager
.
getSites
(
baseDomain
)
;
PanelMultiView
.
hidePopup
(
this
.
_identityPopup
)
;
if
(
siteData
&
&
siteData
.
length
)
{
let
hosts
=
siteData
.
map
(
site
=
>
site
.
host
)
;
if
(
SiteDataManager
.
promptSiteDataRemoval
(
window
hosts
)
)
{
SiteDataManager
.
remove
(
hosts
)
;
}
}
event
.
stopPropagation
(
)
;
}
openPermissionPreferences
(
)
{
openPreferences
(
"
privacy
-
permissions
"
)
;
}
handleMoreInfoClick
(
event
)
{
displaySecurityInfo
(
)
;
event
.
stopPropagation
(
)
;
PanelMultiView
.
hidePopup
(
this
.
_identityPopup
)
;
}
showSecuritySubView
(
)
{
this
.
_identityPopupMultiView
.
showSubView
(
"
identity
-
popup
-
securityView
"
this
.
_popupExpander
)
;
Services
.
focus
.
clearFocus
(
window
)
;
}
disableMixedContentProtection
(
)
{
const
kMIXED_CONTENT_UNBLOCK_EVENT
=
2
;
let
histogram
=
Services
.
telemetry
.
getHistogramById
(
"
MIXED_CONTENT_UNBLOCK_COUNTER
"
)
;
histogram
.
add
(
kMIXED_CONTENT_UNBLOCK_EVENT
)
;
BrowserReloadWithFlags
(
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_ALLOW_MIXED_CONTENT
)
;
PanelMultiView
.
hidePopup
(
this
.
_identityPopup
)
;
}
enableMixedContentProtection
(
)
{
gBrowser
.
selectedBrowser
.
sendMessageToActor
(
"
MixedContent
:
ReenableProtection
"
{
}
"
BrowserTab
"
)
;
BrowserReload
(
)
;
PanelMultiView
.
hidePopup
(
this
.
_identityPopup
)
;
}
removeCertException
(
)
{
if
(
!
this
.
_uriHasHost
)
{
Cu
.
reportError
(
"
Trying
to
revoke
a
cert
exception
on
a
URI
without
a
host
?
"
)
;
return
;
}
let
host
=
this
.
_uri
.
host
;
let
port
=
this
.
_uri
.
port
>
0
?
this
.
_uri
.
port
:
443
;
this
.
_overrideService
.
clearValidityOverride
(
host
port
)
;
BrowserReloadSkipCache
(
)
;
PanelMultiView
.
hidePopup
(
this
.
_identityPopup
)
;
}
getIdentityData
(
)
{
var
result
=
{
}
;
var
cert
=
this
.
_secInfo
.
serverCert
;
result
.
subjectOrg
=
cert
.
organization
;
if
(
cert
.
subjectName
)
{
result
.
subjectNameFields
=
{
}
;
cert
.
subjectName
.
split
(
"
"
)
.
forEach
(
function
(
v
)
{
var
field
=
v
.
split
(
"
=
"
)
;
this
[
field
[
0
]
]
=
field
[
1
]
;
}
result
.
subjectNameFields
)
;
result
.
city
=
result
.
subjectNameFields
.
L
;
result
.
state
=
result
.
subjectNameFields
.
ST
;
result
.
country
=
result
.
subjectNameFields
.
C
;
}
result
.
caOrg
=
cert
.
issuerOrganization
|
|
cert
.
issuerCommonName
;
result
.
cert
=
cert
;
return
result
;
}
updateIdentity
(
state
uri
)
{
let
shouldHidePopup
=
this
.
_uri
&
&
this
.
_uri
.
spec
!
=
uri
.
spec
;
this
.
_state
=
state
;
this
.
setURI
(
uri
)
;
this
.
_secInfo
=
gBrowser
.
securityUI
.
secInfo
;
this
.
_isSecureContext
=
gBrowser
.
securityUI
.
isSecureContext
;
this
.
refreshIdentityBlock
(
)
;
if
(
shouldHidePopup
)
{
PanelMultiView
.
hidePopup
(
this
.
_identityPopup
)
;
}
if
(
this
.
_isCertDistrustImminent
)
{
let
consoleMsg
=
Cc
[
"
mozilla
.
org
/
scripterror
;
1
"
]
.
createInstance
(
Ci
.
nsIScriptError
)
;
let
windowId
=
gBrowser
.
selectedBrowser
.
innerWindowID
;
let
message
=
gBrowserBundle
.
GetStringFromName
(
"
certImminentDistrust
.
message
"
)
;
consoleMsg
.
initWithWindowID
(
message
uri
.
prePath
null
0
0
Ci
.
nsIScriptError
.
warningFlag
"
SSL
"
windowId
)
;
Services
.
console
.
logMessage
(
consoleMsg
)
;
}
}
updateSharingIndicator
(
)
{
let
tab
=
gBrowser
.
selectedTab
;
this
.
_sharingState
=
tab
.
_sharingState
;
this
.
_webRTCSharingIcon
.
removeAttribute
(
"
paused
"
)
;
this
.
_webRTCSharingIcon
.
removeAttribute
(
"
sharing
"
)
;
this
.
_geoSharingIcon
.
removeAttribute
(
"
sharing
"
)
;
this
.
_xrSharingIcon
.
removeAttribute
(
"
sharing
"
)
;
if
(
this
.
_sharingState
)
{
if
(
this
.
_sharingState
&
&
this
.
_sharingState
.
webRTC
&
&
this
.
_sharingState
.
webRTC
.
sharing
)
{
this
.
_webRTCSharingIcon
.
setAttribute
(
"
sharing
"
this
.
_sharingState
.
webRTC
.
sharing
)
;
if
(
this
.
_sharingState
.
webRTC
.
paused
)
{
this
.
_webRTCSharingIcon
.
setAttribute
(
"
paused
"
"
true
"
)
;
}
}
if
(
this
.
_sharingState
.
geo
)
{
this
.
_geoSharingIcon
.
setAttribute
(
"
sharing
"
this
.
_sharingState
.
geo
)
;
}
if
(
this
.
_sharingState
.
xr
)
{
this
.
_xrSharingIcon
.
setAttribute
(
"
sharing
"
this
.
_sharingState
.
xr
)
;
}
}
if
(
this
.
_identityPopup
.
state
=
=
"
open
"
)
{
this
.
updateSitePermissions
(
)
;
PanelView
.
forNode
(
this
.
_identityPopupMainView
)
.
descriptionHeightWorkaround
(
)
;
}
}
getEffectiveHost
(
)
{
if
(
!
this
.
_IDNService
)
{
this
.
_IDNService
=
Cc
[
"
mozilla
.
org
/
network
/
idn
-
service
;
1
"
]
.
getService
(
Ci
.
nsIIDNService
)
;
}
try
{
return
this
.
_IDNService
.
convertToDisplayIDN
(
this
.
_uri
.
host
{
}
)
;
}
catch
(
e
)
{
return
this
.
_uri
.
host
;
}
}
getHostForDisplay
(
)
{
let
host
=
"
"
;
try
{
host
=
this
.
getEffectiveHost
(
)
;
}
catch
(
e
)
{
}
if
(
this
.
_uri
.
schemeIs
(
"
about
"
)
)
{
host
=
"
about
:
"
+
this
.
_uri
.
filePath
;
}
if
(
this
.
_uri
.
schemeIs
(
"
chrome
"
)
)
{
host
=
this
.
_uri
.
spec
;
}
let
readerStrippedURI
=
ReaderMode
.
getOriginalUrlObjectForDisplay
(
this
.
_uri
.
displaySpec
)
;
if
(
readerStrippedURI
)
{
host
=
readerStrippedURI
.
host
;
}
if
(
this
.
_pageExtensionPolicy
)
{
host
=
this
.
_pageExtensionPolicy
.
name
;
}
if
(
!
host
)
{
host
=
this
.
_uri
.
specIgnoringRef
;
}
return
host
;
}
get
pointerlockFsWarningClassName
(
)
{
if
(
this
.
_uriHasHost
&
&
this
.
_isSecureConnection
)
{
return
"
verifiedDomain
"
;
}
return
"
unknownIdentity
"
;
}
_hasCustomRoot
(
)
{
let
issuerCert
=
null
;
issuerCert
=
this
.
_secInfo
.
succeededCertChain
[
this
.
_secInfo
.
succeededCertChain
.
length
-
1
]
;
return
!
issuerCert
.
isBuiltInRoot
;
}
_hasInvalidPageProxyState
(
)
{
return
(
!
this
.
_uriHasHost
&
&
this
.
_uri
&
&
isBlankPageURL
(
this
.
_uri
.
spec
)
&
&
!
this
.
_uri
.
schemeIs
(
"
moz
-
extension
"
)
)
;
}
_refreshIdentityIcons
(
)
{
let
icon_label
=
"
"
;
let
tooltip
=
"
"
;
if
(
this
.
_isSecureInternalUI
)
{
this
.
_identityBox
.
className
=
"
chromeUI
"
;
let
brandBundle
=
document
.
getElementById
(
"
bundle_brand
"
)
;
icon_label
=
brandBundle
.
getString
(
"
brandShorterName
"
)
;
}
else
if
(
this
.
_pageExtensionPolicy
)
{
this
.
_identityBox
.
className
=
"
extensionPage
"
;
let
extensionName
=
this
.
_pageExtensionPolicy
.
name
;
icon_label
=
gNavigatorBundle
.
getFormattedString
(
"
identity
.
extension
.
label
"
[
extensionName
]
)
;
}
else
if
(
this
.
_uriHasHost
&
&
this
.
_isSecureConnection
)
{
this
.
_identityBox
.
className
=
"
verifiedDomain
"
;
if
(
this
.
_isMixedActiveContentBlocked
)
{
this
.
_identityBox
.
classList
.
add
(
"
mixedActiveBlocked
"
)
;
}
if
(
!
this
.
_isCertUserOverridden
)
{
tooltip
=
gNavigatorBundle
.
getFormattedString
(
"
identity
.
identified
.
verifier
"
[
this
.
getIdentityData
(
)
.
caOrg
]
)
;
}
}
else
if
(
this
.
_isBrokenConnection
)
{
this
.
_identityBox
.
className
=
"
unknownIdentity
"
;
if
(
this
.
_isMixedActiveContentLoaded
)
{
this
.
_identityBox
.
classList
.
add
(
"
mixedActiveContent
"
)
;
}
else
if
(
this
.
_isMixedActiveContentBlocked
)
{
this
.
_identityBox
.
classList
.
add
(
"
mixedDisplayContentLoadedActiveBlocked
"
)
;
}
else
if
(
this
.
_isMixedPassiveContentLoaded
)
{
this
.
_identityBox
.
classList
.
add
(
"
mixedDisplayContent
"
)
;
}
else
{
this
.
_identityBox
.
classList
.
add
(
"
weakCipher
"
)
;
}
}
else
if
(
this
.
_isAboutCertErrorPage
)
{
this
.
_identityBox
.
className
=
"
certErrorPage
"
;
}
else
if
(
this
.
_isSecureContext
|
|
(
gBrowser
.
selectedBrowser
.
documentURI
&
&
(
gBrowser
.
selectedBrowser
.
documentURI
.
scheme
=
=
"
about
"
|
|
gBrowser
.
selectedBrowser
.
documentURI
.
scheme
=
=
"
chrome
"
)
)
)
{
this
.
_identityBox
.
className
=
"
unknownIdentity
"
;
}
else
{
let
warnOnInsecure
=
this
.
_insecureConnectionIconEnabled
|
|
(
this
.
_insecureConnectionIconPBModeEnabled
&
&
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
;
let
className
=
warnOnInsecure
?
"
notSecure
"
:
"
unknownIdentity
"
;
this
.
_identityBox
.
className
=
className
;
tooltip
=
warnOnInsecure
?
gNavigatorBundle
.
getString
(
"
identity
.
notSecure
.
tooltip
"
)
:
"
"
;
let
warnTextOnInsecure
=
this
.
_insecureConnectionTextEnabled
|
|
(
this
.
_insecureConnectionTextPBModeEnabled
&
&
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
;
if
(
warnTextOnInsecure
)
{
icon_label
=
gNavigatorBundle
.
getString
(
"
identity
.
notSecure
.
label
"
)
;
this
.
_identityBox
.
classList
.
add
(
"
notSecureText
"
)
;
}
}
if
(
this
.
_isCertUserOverridden
)
{
this
.
_identityBox
.
classList
.
add
(
"
certUserOverridden
"
)
;
tooltip
=
gNavigatorBundle
.
getString
(
"
identity
.
identified
.
verified_by_you
"
)
;
}
this
.
_updateAttribute
(
this
.
_identityIcon
"
lock
-
icon
-
gray
"
this
.
_useGrayLockIcon
)
;
this
.
_identityIcon
.
setAttribute
(
"
tooltiptext
"
tooltip
)
;
if
(
this
.
_pageExtensionPolicy
)
{
let
extensionName
=
this
.
_pageExtensionPolicy
.
name
;
this
.
_identityIcon
.
setAttribute
(
"
tooltiptext
"
gNavigatorBundle
.
getFormattedString
(
"
identity
.
extension
.
tooltip
"
[
extensionName
]
)
)
;
}
this
.
_identityIconLabel
.
setAttribute
(
"
tooltiptext
"
tooltip
)
;
this
.
_identityIconLabel
.
setAttribute
(
"
value
"
icon_label
)
;
this
.
_identityIconLabel
.
collapsed
=
!
icon_label
;
}
_refreshPermissionIcons
(
)
{
let
permissionAnchors
=
this
.
_permissionAnchors
;
for
(
let
icon
of
Object
.
values
(
permissionAnchors
)
)
{
icon
.
removeAttribute
(
"
showing
"
)
;
}
let
hasGrantedPermissions
=
false
;
let
permissions
=
SitePermissions
.
getAllForBrowser
(
gBrowser
.
selectedBrowser
)
;
for
(
let
permission
of
permissions
)
{
if
(
permission
.
state
=
=
SitePermissions
.
BLOCK
|
|
permission
.
state
=
=
SitePermissions
.
AUTOPLAY_BLOCKED_ALL
)
{
let
icon
=
permissionAnchors
[
permission
.
id
]
;
if
(
icon
)
{
icon
.
setAttribute
(
"
showing
"
"
true
"
)
;
}
}
else
if
(
permission
.
state
!
=
SitePermissions
.
UNKNOWN
)
{
hasGrantedPermissions
=
true
;
}
}
if
(
hasGrantedPermissions
)
{
this
.
_identityBox
.
classList
.
add
(
"
grantedPermissions
"
)
;
}
if
(
gBrowser
.
selectedBrowser
.
popupBlocker
.
getBlockedPopupCount
(
)
)
{
let
icon
=
permissionAnchors
.
popup
;
icon
.
setAttribute
(
"
showing
"
"
true
"
)
;
}
}
refreshIdentityBlock
(
)
{
if
(
!
this
.
_identityBox
)
{
return
;
}
if
(
this
.
_hasInvalidPageProxyState
(
)
)
{
return
;
}
this
.
_refreshIdentityIcons
(
)
;
this
.
_refreshPermissionIcons
(
)
;
gProtectionsHandler
.
_trackingProtectionIconContainer
.
classList
.
toggle
(
"
chromeUI
"
this
.
_isSecureInternalUI
)
;
}
refreshIdentityPopup
(
)
{
this
.
_clearSiteDataFooter
.
hidden
=
true
;
if
(
this
.
_uriHasHost
)
{
SiteDataManager
.
hasSiteData
(
this
.
_uri
.
asciiHost
)
.
then
(
hasData
=
>
{
this
.
_clearSiteDataFooter
.
hidden
=
!
hasData
;
}
)
;
}
let
baseURL
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
;
this
.
_identityPopupMixedContentLearnMore
.
forEach
(
e
=
>
e
.
setAttribute
(
"
href
"
baseURL
+
"
mixed
-
content
"
)
)
;
this
.
_identityPopupCustomRootLearnMore
.
setAttribute
(
"
href
"
baseURL
+
"
enterprise
-
roots
"
)
;
this
.
_popupExpander
.
tooltipText
=
gNavigatorBundle
.
getString
(
"
identity
.
showDetails
.
tooltip
"
)
;
let
customRoot
=
false
;
let
connection
=
"
not
-
secure
"
;
if
(
this
.
_isSecureInternalUI
)
{
connection
=
"
chrome
"
;
}
else
if
(
this
.
_pageExtensionPolicy
)
{
connection
=
"
extension
"
;
}
else
if
(
this
.
_isURILoadedFromFile
)
{
connection
=
"
file
"
;
}
else
if
(
this
.
_isEV
)
{
connection
=
"
secure
-
ev
"
;
}
else
if
(
this
.
_isCertUserOverridden
)
{
connection
=
"
secure
-
cert
-
user
-
overridden
"
;
}
else
if
(
this
.
_isSecureConnection
)
{
connection
=
"
secure
"
;
customRoot
=
this
.
_hasCustomRoot
(
)
;
}
else
if
(
this
.
_isAboutCertErrorPage
)
{
connection
=
"
cert
-
error
-
page
"
;
}
let
mixedcontent
=
[
]
;
if
(
this
.
_isMixedPassiveContentLoaded
)
{
mixedcontent
.
push
(
"
passive
-
loaded
"
)
;
}
if
(
this
.
_isMixedActiveContentLoaded
)
{
mixedcontent
.
push
(
"
active
-
loaded
"
)
;
}
else
if
(
this
.
_isMixedActiveContentBlocked
)
{
mixedcontent
.
push
(
"
active
-
blocked
"
)
;
}
mixedcontent
=
mixedcontent
.
join
(
"
"
)
;
let
ciphers
=
"
"
;
if
(
this
.
_isBrokenConnection
&
&
!
this
.
_isMixedActiveContentLoaded
&
&
!
this
.
_isMixedPassiveContentLoaded
)
{
ciphers
=
"
weak
"
;
}
this
.
_updateAttribute
(
this
.
_identityPopup
"
lock
-
icon
-
gray
"
this
.
_useGrayLockIcon
)
;
let
elementIDs
=
[
"
identity
-
popup
"
"
identity
-
popup
-
securityView
-
body
"
]
;
for
(
let
id
of
elementIDs
)
{
let
element
=
document
.
getElementById
(
id
)
;
this
.
_updateAttribute
(
element
"
connection
"
connection
)
;
this
.
_updateAttribute
(
element
"
ciphers
"
ciphers
)
;
this
.
_updateAttribute
(
element
"
mixedcontent
"
mixedcontent
)
;
this
.
_updateAttribute
(
element
"
isbroken
"
this
.
_isBrokenConnection
)
;
this
.
_updateAttribute
(
element
"
customroot
"
customRoot
)
;
}
let
supplemental
=
"
"
;
let
verifier
=
"
"
;
let
host
=
this
.
getHostForDisplay
(
)
;
let
owner
=
"
"
;
if
(
this
.
_isSecureConnection
|
|
this
.
_isCertUserOverridden
)
{
verifier
=
this
.
_identityIconLabel
.
tooltipText
;
}
if
(
this
.
_isEV
)
{
let
iData
=
this
.
getIdentityData
(
)
;
owner
=
iData
.
subjectOrg
;
verifier
=
this
.
_identityIconLabel
.
tooltipText
;
if
(
iData
.
city
)
{
supplemental
+
=
iData
.
city
+
"
\
n
"
;
}
if
(
iData
.
state
&
&
iData
.
country
)
{
supplemental
+
=
gNavigatorBundle
.
getFormattedString
(
"
identity
.
identified
.
state_and_country
"
[
iData
.
state
iData
.
country
]
)
;
}
else
if
(
iData
.
state
)
{
supplemental
+
=
iData
.
state
;
}
else
if
(
iData
.
country
)
{
supplemental
+
=
iData
.
country
;
}
}
this
.
_identityPopupMainViewHeaderLabel
.
textContent
=
gNavigatorBundle
.
getFormattedString
(
"
identity
.
headerMainWithHost
"
[
host
]
)
;
this
.
_identityPopupSecurityView
.
setAttribute
(
"
title
"
gNavigatorBundle
.
getFormattedString
(
"
identity
.
headerSecurityWithHost
"
[
host
]
)
)
;
this
.
_identityPopupSecurityEVContentOwner
.
textContent
=
gNavigatorBundle
.
getFormattedString
(
"
identity
.
ev
.
contentOwner2
"
[
owner
]
)
;
this
.
_identityPopupContentOwner
.
textContent
=
owner
;
this
.
_identityPopupContentSupp
.
textContent
=
supplemental
;
this
.
_identityPopupContentVerif
.
textContent
=
verifier
;
this
.
updateSitePermissions
(
)
;
}
setURI
(
uri
)
{
this
.
_uri
=
uri
;
try
{
this
.
_uriHasHost
=
!
!
this
.
_uri
.
host
;
}
catch
(
ex
)
{
this
.
_uriHasHost
=
false
;
}
this
.
_isSecureInternalUI
=
uri
.
schemeIs
(
"
about
"
)
&
&
this
.
_secureInternalUIWhitelist
.
test
(
uri
.
pathQueryRef
)
;
this
.
_pageExtensionPolicy
=
WebExtensionPolicy
.
getByURI
(
uri
)
;
this
.
_isURILoadedFromFile
=
false
;
let
chanOptions
=
{
uri
:
this
.
_uri
loadUsingSystemPrincipal
:
true
}
;
let
resolvedURI
;
try
{
resolvedURI
=
NetUtil
.
newChannel
(
chanOptions
)
.
URI
;
if
(
resolvedURI
.
schemeIs
(
"
jar
"
)
)
{
resolvedURI
=
NetUtil
.
newURI
(
resolvedURI
.
pathQueryRef
)
;
}
this
.
_isURILoadedFromFile
=
resolvedURI
.
schemeIs
(
"
file
"
)
;
}
catch
(
ex
)
{
}
}
handleIdentityButtonEvent
(
event
)
{
event
.
stopPropagation
(
)
;
if
(
(
event
.
type
=
=
"
click
"
&
&
event
.
button
!
=
0
)
|
|
(
event
.
type
=
=
"
keypress
"
&
&
event
.
charCode
!
=
KeyEvent
.
DOM_VK_SPACE
&
&
event
.
keyCode
!
=
KeyEvent
.
DOM_VK_RETURN
)
)
{
return
;
}
if
(
!
this
.
_sharingState
&
&
gURLBar
.
getAttribute
(
"
pageproxystate
"
)
!
=
"
valid
"
)
{
return
;
}
if
(
document
.
fullscreen
)
{
this
.
_exitedEventReceived
=
false
;
this
.
_event
=
event
;
Services
.
obs
.
addObserver
(
this
"
fullscreen
-
painted
"
)
;
window
.
addEventListener
(
"
MozDOMFullscreen
:
Exited
"
(
)
=
>
{
this
.
_exitedEventReceived
=
true
;
}
{
once
:
true
}
)
;
document
.
exitFullscreen
(
)
;
return
;
}
this
.
_openPopup
(
event
)
;
}
_openPopup
(
event
)
{
this
.
_identityPopup
.
hidden
=
false
;
this
.
_permissionReloadHint
.
setAttribute
(
"
hidden
"
"
true
"
)
;
this
.
refreshIdentityPopup
(
)
;
this
.
_identityBox
.
setAttribute
(
"
open
"
"
true
"
)
;
if
(
gProtectionsHandler
.
_protectionsPopup
.
state
!
=
"
closed
"
)
{
PanelMultiView
.
hidePopup
(
gProtectionsHandler
.
_protectionsPopup
)
;
}
PanelMultiView
.
openPopup
(
this
.
_identityPopup
this
.
_identityIcon
{
position
:
"
bottomcenter
topleft
"
triggerEvent
:
event
}
)
.
catch
(
Cu
.
reportError
)
;
}
onPopupShown
(
event
)
{
if
(
event
.
target
=
=
this
.
_identityPopup
)
{
window
.
addEventListener
(
"
focus
"
this
true
)
;
}
}
onPopupHidden
(
event
)
{
if
(
event
.
target
=
=
this
.
_identityPopup
)
{
window
.
removeEventListener
(
"
focus
"
this
true
)
;
this
.
_identityBox
.
removeAttribute
(
"
open
"
)
;
}
}
handleEvent
(
event
)
{
let
elem
=
document
.
activeElement
;
let
position
=
elem
.
compareDocumentPosition
(
this
.
_identityPopup
)
;
if
(
!
(
position
&
(
Node
.
DOCUMENT_POSITION_CONTAINS
|
Node
.
DOCUMENT_POSITION_CONTAINED_BY
)
)
&
&
!
this
.
_identityPopup
.
hasAttribute
(
"
noautohide
"
)
)
{
PanelMultiView
.
hidePopup
(
this
.
_identityPopup
)
;
}
}
observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
"
perm
-
changed
"
:
{
if
(
subject
&
&
SitePermissions
.
listPermissions
(
)
.
includes
(
subject
.
QueryInterface
(
Ci
.
nsIPermission
)
.
type
)
)
{
this
.
refreshIdentityBlock
(
)
;
}
break
;
}
case
"
fullscreen
-
painted
"
:
{
if
(
subject
!
=
window
|
|
!
this
.
_exitedEventReceived
)
{
return
;
}
Services
.
obs
.
removeObserver
(
this
"
fullscreen
-
painted
"
)
;
this
.
_openPopup
(
this
.
_event
)
;
delete
this
.
_event
;
break
;
}
}
}
onDragStart
(
event
)
{
const
TEXT_SIZE
=
14
;
const
IMAGE_SIZE
=
16
;
const
SPACING
=
5
;
if
(
gURLBar
.
getAttribute
(
"
pageproxystate
"
)
!
=
"
valid
"
)
{
return
;
}
let
value
=
gBrowser
.
currentURI
.
displaySpec
;
let
urlString
=
value
+
"
\
n
"
+
gBrowser
.
contentTitle
;
let
htmlString
=
'
<
a
href
=
"
'
+
value
+
'
"
>
'
+
value
+
"
<
/
a
>
"
;
let
windowUtils
=
window
.
windowUtils
;
let
scale
=
windowUtils
.
screenPixelsPerCSSPixel
/
windowUtils
.
fullZoom
;
let
canvas
=
document
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
"
canvas
"
)
;
canvas
.
width
=
550
*
scale
;
let
ctx
=
canvas
.
getContext
(
"
2d
"
)
;
ctx
.
font
=
{
TEXT_SIZE
*
scale
}
px
sans
-
serif
;
let
tabIcon
=
gBrowser
.
selectedTab
.
iconImage
;
let
image
=
new
Image
(
)
;
image
.
src
=
tabIcon
.
src
;
let
textWidth
=
ctx
.
measureText
(
value
)
.
width
/
scale
;
let
textHeight
=
parseInt
(
ctx
.
font
10
)
/
scale
;
let
imageHorizontalOffset
imageVerticalOffset
;
imageHorizontalOffset
=
imageVerticalOffset
=
SPACING
;
let
textHorizontalOffset
=
image
.
width
?
IMAGE_SIZE
+
SPACING
*
2
:
SPACING
;
let
textVerticalOffset
=
textHeight
+
SPACING
-
1
;
let
backgroundColor
=
"
white
"
;
let
textColor
=
"
black
"
;
let
totalWidth
=
image
.
width
?
textWidth
+
IMAGE_SIZE
+
3
*
SPACING
:
textWidth
+
2
*
SPACING
;
let
totalHeight
=
image
.
width
?
IMAGE_SIZE
+
2
*
SPACING
:
textHeight
+
2
*
SPACING
;
ctx
.
fillStyle
=
backgroundColor
;
ctx
.
fillRect
(
0
0
totalWidth
*
scale
totalHeight
*
scale
)
;
ctx
.
fillStyle
=
textColor
;
ctx
.
fillText
(
{
value
}
textHorizontalOffset
*
scale
textVerticalOffset
*
scale
)
;
try
{
ctx
.
drawImage
(
image
imageHorizontalOffset
*
scale
imageVerticalOffset
*
scale
IMAGE_SIZE
*
scale
IMAGE_SIZE
*
scale
)
;
}
catch
(
e
)
{
}
let
dt
=
event
.
dataTransfer
;
dt
.
setData
(
"
text
/
x
-
moz
-
url
"
urlString
)
;
dt
.
setData
(
"
text
/
uri
-
list
"
value
)
;
dt
.
setData
(
"
text
/
plain
"
value
)
;
dt
.
setData
(
"
text
/
html
"
htmlString
)
;
dt
.
setDragImage
(
canvas
16
16
)
;
gURLBar
.
view
.
close
(
)
;
}
onLocationChange
(
)
{
this
.
_permissionReloadHint
.
setAttribute
(
"
hidden
"
"
true
"
)
;
if
(
!
this
.
_permissionList
.
hasChildNodes
(
)
)
{
this
.
_permissionEmptyHint
.
removeAttribute
(
"
hidden
"
)
;
}
}
_updateAttribute
(
elem
attr
value
)
{
if
(
value
)
{
elem
.
setAttribute
(
attr
value
)
;
}
else
{
elem
.
removeAttribute
(
attr
)
;
}
}
updateSitePermissions
(
)
{
while
(
this
.
_permissionList
.
hasChildNodes
(
)
)
{
this
.
_permissionList
.
removeChild
(
this
.
_permissionList
.
lastChild
)
;
}
let
permissions
=
SitePermissions
.
getAllPermissionDetailsForBrowser
(
gBrowser
.
selectedBrowser
)
;
if
(
this
.
_sharingState
&
&
this
.
_sharingState
.
geo
)
{
let
geoPermission
=
permissions
.
find
(
perm
=
>
perm
.
id
=
=
=
"
geo
"
)
;
if
(
geoPermission
)
{
geoPermission
.
sharingState
=
true
;
}
else
{
permissions
.
push
(
{
id
:
"
geo
"
state
:
SitePermissions
.
ALLOW
scope
:
SitePermissions
.
SCOPE_REQUEST
sharingState
:
true
}
)
;
}
}
if
(
this
.
_sharingState
&
&
this
.
_sharingState
.
xr
)
{
let
xrPermission
=
permissions
.
find
(
perm
=
>
perm
.
id
=
=
=
"
xr
"
)
;
if
(
xrPermission
)
{
xrPermission
.
sharingState
=
true
;
}
else
{
permissions
.
push
(
{
id
:
"
xr
"
state
:
SitePermissions
.
ALLOW
scope
:
SitePermissions
.
SCOPE_REQUEST
sharingState
:
true
}
)
;
}
}
if
(
this
.
_sharingState
&
&
this
.
_sharingState
.
webRTC
)
{
let
webrtcState
=
this
.
_sharingState
.
webRTC
;
for
(
let
id
of
[
"
camera
"
"
microphone
"
"
screen
"
]
)
{
if
(
webrtcState
[
id
]
)
{
let
found
=
false
;
for
(
let
permission
of
permissions
)
{
if
(
permission
.
id
!
=
id
)
{
continue
;
}
found
=
true
;
permission
.
sharingState
=
webrtcState
[
id
]
;
break
;
}
if
(
!
found
)
{
permissions
.
push
(
{
id
state
:
SitePermissions
.
ALLOW
scope
:
SitePermissions
.
SCOPE_REQUEST
sharingState
:
webrtcState
[
id
]
}
)
;
}
}
}
}
let
totalBlockedPopups
=
gBrowser
.
selectedBrowser
.
popupBlocker
.
getBlockedPopupCount
(
)
;
let
hasBlockedPopupIndicator
=
false
;
for
(
let
permission
of
permissions
)
{
if
(
permission
.
id
=
=
"
storage
-
access
"
)
{
continue
;
}
let
item
=
this
.
_createPermissionItem
(
permission
)
;
if
(
!
item
)
{
continue
;
}
this
.
_permissionList
.
appendChild
(
item
)
;
if
(
permission
.
id
=
=
"
popup
"
&
&
totalBlockedPopups
)
{
this
.
_createBlockedPopupIndicator
(
totalBlockedPopups
)
;
hasBlockedPopupIndicator
=
true
;
}
else
if
(
permission
.
id
=
=
"
geo
"
&
&
permission
.
state
=
=
=
SitePermissions
.
ALLOW
)
{
this
.
_createGeoLocationLastAccessIndicator
(
)
;
}
}
if
(
totalBlockedPopups
&
&
!
hasBlockedPopupIndicator
)
{
let
permission
=
{
id
:
"
popup
"
state
:
SitePermissions
.
getDefault
(
"
popup
"
)
scope
:
SitePermissions
.
SCOPE_PERSISTENT
}
;
let
item
=
this
.
_createPermissionItem
(
permission
)
;
this
.
_permissionList
.
appendChild
(
item
)
;
this
.
_createBlockedPopupIndicator
(
totalBlockedPopups
)
;
}
if
(
!
this
.
_permissionList
.
hasChildNodes
(
)
&
&
this
.
_permissionReloadHint
.
hasAttribute
(
"
hidden
"
)
)
{
this
.
_permissionEmptyHint
.
removeAttribute
(
"
hidden
"
)
;
}
else
{
this
.
_permissionEmptyHint
.
setAttribute
(
"
hidden
"
"
true
"
)
;
}
}
_createPermissionItem
(
aPermission
)
{
let
container
=
document
.
createXULElement
(
"
hbox
"
)
;
container
.
setAttribute
(
"
class
"
"
identity
-
popup
-
permission
-
item
"
)
;
container
.
setAttribute
(
"
align
"
"
center
"
)
;
container
.
setAttribute
(
"
role
"
"
group
"
)
;
let
img
=
document
.
createXULElement
(
"
image
"
)
;
img
.
classList
.
add
(
"
identity
-
popup
-
permission
-
icon
"
aPermission
.
id
+
"
-
icon
"
)
;
if
(
aPermission
.
state
=
=
SitePermissions
.
BLOCK
|
|
aPermission
.
state
=
=
SitePermissions
.
AUTOPLAY_BLOCKED_ALL
)
{
img
.
classList
.
add
(
"
blocked
-
permission
-
icon
"
)
;
}
if
(
aPermission
.
sharingState
=
=
Ci
.
nsIMediaManagerService
.
STATE_CAPTURE_ENABLED
|
|
(
aPermission
.
id
=
=
"
screen
"
&
&
aPermission
.
sharingState
&
&
!
aPermission
.
sharingState
.
includes
(
"
Paused
"
)
)
)
{
img
.
classList
.
add
(
"
in
-
use
"
)
;
window
.
promiseDocumentFlushed
(
(
)
=
>
{
let
sharingIconBlink
=
this
.
_webRTCSharingIcon
.
getAnimations
(
)
[
0
]
;
let
imgBlink
=
img
.
getAnimations
(
)
[
0
]
;
return
[
sharingIconBlink
imgBlink
]
;
}
)
.
then
(
(
[
sharingIconBlink
imgBlink
]
)
=
>
{
if
(
sharingIconBlink
&
&
imgBlink
)
{
imgBlink
.
startTime
=
sharingIconBlink
.
startTime
;
}
}
)
;
}
let
nameLabel
=
document
.
createXULElement
(
"
label
"
)
;
nameLabel
.
setAttribute
(
"
flex
"
"
1
"
)
;
nameLabel
.
setAttribute
(
"
class
"
"
identity
-
popup
-
permission
-
label
"
)
;
let
label
=
SitePermissions
.
getPermissionLabel
(
aPermission
.
id
)
;
if
(
label
=
=
=
null
)
{
return
null
;
}
nameLabel
.
textContent
=
label
;
let
nameLabelId
=
"
identity
-
popup
-
permission
-
label
-
"
+
aPermission
.
id
;
nameLabel
.
setAttribute
(
"
id
"
nameLabelId
)
;
let
isPolicyPermission
=
[
SitePermissions
.
SCOPE_POLICY
SitePermissions
.
SCOPE_GLOBAL
]
.
includes
(
aPermission
.
scope
)
;
if
(
(
aPermission
.
id
=
=
"
popup
"
&
&
!
isPolicyPermission
)
|
|
aPermission
.
id
=
=
"
autoplay
-
media
"
)
{
let
menulist
=
document
.
createXULElement
(
"
menulist
"
)
;
let
menupopup
=
document
.
createXULElement
(
"
menupopup
"
)
;
let
block
=
document
.
createXULElement
(
"
vbox
"
)
;
block
.
setAttribute
(
"
id
"
"
identity
-
popup
-
popup
-
container
"
)
;
menulist
.
setAttribute
(
"
sizetopopup
"
"
none
"
)
;
menulist
.
setAttribute
(
"
id
"
"
identity
-
popup
-
popup
-
menulist
"
)
;
for
(
let
state
of
SitePermissions
.
getAvailableStates
(
aPermission
.
id
)
)
{
let
menuitem
=
document
.
createXULElement
(
"
menuitem
"
)
;
if
(
state
=
=
SitePermissions
.
getDefault
(
aPermission
.
id
)
)
{
menuitem
.
setAttribute
(
"
value
"
"
0
"
)
;
}
else
{
menuitem
.
setAttribute
(
"
value
"
state
)
;
}
menuitem
.
setAttribute
(
"
label
"
SitePermissions
.
getMultichoiceStateLabel
(
aPermission
.
id
state
)
)
;
menupopup
.
appendChild
(
menuitem
)
;
}
menulist
.
appendChild
(
menupopup
)
;
if
(
aPermission
.
state
=
=
SitePermissions
.
getDefault
(
aPermission
.
id
)
)
{
menulist
.
value
=
"
0
"
;
}
else
{
menulist
.
value
=
aPermission
.
state
;
}
menulist
.
addEventListener
(
"
command
"
(
)
=
>
{
SitePermissions
.
setForPrincipal
(
gBrowser
.
contentPrincipal
aPermission
.
id
menulist
.
selectedItem
.
value
)
;
}
)
;
container
.
appendChild
(
img
)
;
container
.
appendChild
(
nameLabel
)
;
container
.
appendChild
(
menulist
)
;
container
.
setAttribute
(
"
aria
-
labelledby
"
nameLabelId
)
;
block
.
appendChild
(
container
)
;
return
block
;
}
let
stateLabel
=
document
.
createXULElement
(
"
label
"
)
;
stateLabel
.
setAttribute
(
"
flex
"
"
1
"
)
;
stateLabel
.
setAttribute
(
"
class
"
"
identity
-
popup
-
permission
-
state
-
label
"
)
;
let
stateLabelId
=
"
identity
-
popup
-
permission
-
state
-
label
-
"
+
aPermission
.
id
;
stateLabel
.
setAttribute
(
"
id
"
stateLabelId
)
;
let
{
state
scope
}
=
aPermission
;
if
(
state
!
=
SitePermissions
.
ALLOW
&
&
aPermission
.
sharingState
)
{
state
=
SitePermissions
.
ALLOW
;
scope
=
SitePermissions
.
SCOPE_REQUEST
;
}
stateLabel
.
textContent
=
SitePermissions
.
getCurrentStateLabel
(
state
aPermission
.
id
scope
)
;
container
.
appendChild
(
img
)
;
container
.
appendChild
(
nameLabel
)
;
container
.
appendChild
(
stateLabel
)
;
container
.
setAttribute
(
"
aria
-
labelledby
"
nameLabelId
+
"
"
+
stateLabelId
)
;
if
(
isPolicyPermission
)
{
return
container
;
}
if
(
aPermission
.
id
=
=
"
geo
"
|
|
aPermission
.
id
=
=
"
xr
"
)
{
let
block
=
document
.
createXULElement
(
"
vbox
"
)
;
block
.
setAttribute
(
"
id
"
"
identity
-
popup
-
"
+
aPermission
.
id
+
"
-
container
"
)
;
let
button
=
this
.
_createPermissionClearButton
(
aPermission
block
)
;
container
.
appendChild
(
button
)
;
block
.
appendChild
(
container
)
;
return
block
;
}
let
button
=
this
.
_createPermissionClearButton
(
aPermission
container
)
;
container
.
appendChild
(
button
)
;
return
container
;
}
_removePermPersistentAllow
(
principal
id
)
{
let
perm
=
SitePermissions
.
getForPrincipal
(
principal
id
)
;
if
(
perm
.
state
=
=
SitePermissions
.
ALLOW
&
&
perm
.
scope
=
=
SitePermissions
.
SCOPE_PERSISTENT
)
{
SitePermissions
.
removeFromPrincipal
(
principal
id
)
;
}
}
_createPermissionClearButton
(
aPermission
container
)
{
let
button
=
document
.
createXULElement
(
"
button
"
)
;
button
.
setAttribute
(
"
class
"
"
identity
-
popup
-
permission
-
remove
-
button
"
)
;
let
tooltiptext
=
gNavigatorBundle
.
getString
(
"
permissions
.
remove
.
tooltip
"
)
;
button
.
setAttribute
(
"
tooltiptext
"
tooltiptext
)
;
button
.
addEventListener
(
"
command
"
(
)
=
>
{
let
browser
=
gBrowser
.
selectedBrowser
;
this
.
_permissionList
.
removeChild
(
container
)
;
if
(
aPermission
.
sharingState
)
{
if
(
aPermission
.
id
=
=
=
"
geo
"
|
|
aPermission
.
id
=
=
=
"
xr
"
)
{
let
origins
=
browser
.
getDevicePermissionOrigins
(
aPermission
.
id
)
;
for
(
let
origin
of
origins
)
{
let
principal
=
Services
.
scriptSecurityManager
.
createContentPrincipalFromOrigin
(
origin
)
;
this
.
_removePermPersistentAllow
(
principal
aPermission
.
id
)
;
}
origins
.
clear
(
)
;
}
else
if
(
[
"
camera
"
"
microphone
"
"
screen
"
]
.
includes
(
aPermission
.
id
)
)
{
let
windowId
=
this
.
_sharingState
.
webRTC
.
windowId
;
if
(
aPermission
.
id
=
=
"
screen
"
)
{
windowId
=
"
screen
:
"
+
windowId
;
}
else
{
let
origins
=
browser
.
getDevicePermissionOrigins
(
"
webrtc
"
)
;
for
(
let
origin
of
origins
)
{
let
principal
;
for
(
let
id
of
[
"
camera
"
"
microphone
"
]
)
{
if
(
this
.
_sharingState
.
webRTC
[
id
]
)
{
if
(
!
principal
)
{
principal
=
Services
.
scriptSecurityManager
.
createContentPrincipalFromOrigin
(
origin
)
;
}
this
.
_removePermPersistentAllow
(
principal
id
)
;
}
}
}
}
let
bc
=
this
.
_sharingState
.
webRTC
.
browsingContext
;
bc
.
currentWindowGlobal
.
getActor
(
"
WebRTC
"
)
.
sendAsyncMessage
(
"
webrtc
:
StopSharing
"
windowId
)
;
webrtcUI
.
forgetActivePermissionsFromBrowser
(
gBrowser
.
selectedBrowser
)
;
}
}
SitePermissions
.
removeFromPrincipal
(
gBrowser
.
contentPrincipal
aPermission
.
id
browser
)
;
this
.
_permissionReloadHint
.
removeAttribute
(
"
hidden
"
)
;
PanelView
.
forNode
(
this
.
_identityPopupMainView
)
.
descriptionHeightWorkaround
(
)
;
if
(
aPermission
.
id
=
=
=
"
geo
"
)
{
gBrowser
.
updateBrowserSharing
(
browser
{
geo
:
false
}
)
;
}
else
if
(
aPermission
.
id
=
=
=
"
xr
"
)
{
gBrowser
.
updateBrowserSharing
(
browser
{
xr
:
false
}
)
;
}
}
)
;
return
button
;
}
_getGeoLocationLastAccess
(
)
{
return
new
Promise
(
resolve
=
>
{
let
lastAccess
=
null
;
ContentPrefService2
.
getByDomainAndName
(
gBrowser
.
currentURI
.
spec
"
permissions
.
geoLocation
.
lastAccess
"
gBrowser
.
selectedBrowser
.
loadContext
{
handleResult
(
pref
)
{
lastAccess
=
pref
.
value
;
}
handleCompletion
(
)
{
resolve
(
lastAccess
)
;
}
}
)
;
}
)
;
}
async
_createGeoLocationLastAccessIndicator
(
)
{
let
lastAccessStr
=
await
this
.
_getGeoLocationLastAccess
(
)
;
if
(
lastAccessStr
=
=
null
)
{
return
;
}
let
lastAccess
=
new
Date
(
lastAccessStr
)
;
if
(
isNaN
(
lastAccess
)
)
{
Cu
.
reportError
(
"
Invalid
timestamp
for
last
geolocation
access
"
)
;
return
;
}
let
icon
=
document
.
createXULElement
(
"
image
"
)
;
icon
.
setAttribute
(
"
class
"
"
popup
-
subitem
"
)
;
let
indicator
=
document
.
createXULElement
(
"
hbox
"
)
;
indicator
.
setAttribute
(
"
class
"
"
identity
-
popup
-
permission
-
item
"
)
;
indicator
.
setAttribute
(
"
align
"
"
center
"
)
;
indicator
.
setAttribute
(
"
id
"
"
geo
-
access
-
indicator
-
item
"
)
;
let
timeFormat
=
new
Services
.
intl
.
RelativeTimeFormat
(
undefined
{
}
)
;
let
text
=
document
.
createXULElement
(
"
label
"
)
;
text
.
setAttribute
(
"
flex
"
"
1
"
)
;
text
.
setAttribute
(
"
class
"
"
identity
-
popup
-
permission
-
label
"
)
;
text
.
textContent
=
gNavigatorBundle
.
getFormattedString
(
"
geolocationLastAccessIndicatorText
"
[
timeFormat
.
formatBestUnit
(
lastAccess
)
]
)
;
indicator
.
appendChild
(
icon
)
;
indicator
.
appendChild
(
text
)
;
let
geoContainer
=
document
.
getElementById
(
"
identity
-
popup
-
geo
-
container
"
)
;
if
(
geoContainer
)
{
geoContainer
.
appendChild
(
indicator
)
;
}
}
_createBlockedPopupIndicator
(
aTotalBlockedPopups
)
{
let
indicator
=
document
.
createXULElement
(
"
hbox
"
)
;
indicator
.
setAttribute
(
"
class
"
"
identity
-
popup
-
permission
-
item
"
)
;
indicator
.
setAttribute
(
"
align
"
"
center
"
)
;
indicator
.
setAttribute
(
"
id
"
"
blocked
-
popup
-
indicator
-
item
"
)
;
let
icon
=
document
.
createXULElement
(
"
image
"
)
;
icon
.
setAttribute
(
"
class
"
"
popup
-
subitem
"
)
;
let
text
=
document
.
createXULElement
(
"
label
"
{
is
:
"
text
-
link
"
}
)
;
text
.
setAttribute
(
"
flex
"
"
1
"
)
;
text
.
setAttribute
(
"
class
"
"
identity
-
popup
-
permission
-
label
"
)
;
let
messageBase
=
gNavigatorBundle
.
getString
(
"
popupShowBlockedPopupsIndicatorText
"
)
;
let
message
=
PluralForm
.
get
(
aTotalBlockedPopups
messageBase
)
.
replace
(
"
#
1
"
aTotalBlockedPopups
)
;
text
.
textContent
=
message
;
text
.
addEventListener
(
"
click
"
(
)
=
>
{
gBrowser
.
selectedBrowser
.
popupBlocker
.
unblockAllPopups
(
)
;
}
)
;
indicator
.
appendChild
(
icon
)
;
indicator
.
appendChild
(
text
)
;
document
.
getElementById
(
"
identity
-
popup
-
popup
-
container
"
)
.
appendChild
(
indicator
)
;
}
}
;
