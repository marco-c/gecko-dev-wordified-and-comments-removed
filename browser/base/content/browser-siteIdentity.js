var
gIdentityHandler
=
{
_uri
:
null
_uriHasHost
:
false
_pageExtensionPolicy
:
null
_isSecureInternalUI
:
false
_secInfo
:
null
_state
:
0
_secureInternalUIWhitelist
:
/
^
(
?
:
accounts
|
addons
|
cache
|
config
|
crashes
|
customizing
|
downloads
|
healthreport
|
license
|
permissions
|
preferences
|
rights
|
sessionrestore
|
support
|
welcomeback
)
(
?
:
[
?
#
]
|
)
/
i
get
_isBroken
(
)
{
return
this
.
_state
&
Ci
.
nsIWebProgressListener
.
STATE_IS_BROKEN
;
}
get
_isSecure
(
)
{
return
!
this
.
_isURILoadedFromFile
&
&
this
.
_state
&
Ci
.
nsIWebProgressListener
.
STATE_IS_SECURE
;
}
get
_isEV
(
)
{
return
!
this
.
_isURILoadedFromFile
&
&
this
.
_state
&
Ci
.
nsIWebProgressListener
.
STATE_IDENTITY_EV_TOPLEVEL
;
}
get
_isMixedActiveContentLoaded
(
)
{
return
this
.
_state
&
Ci
.
nsIWebProgressListener
.
STATE_LOADED_MIXED_ACTIVE_CONTENT
;
}
get
_isMixedActiveContentBlocked
(
)
{
return
this
.
_state
&
Ci
.
nsIWebProgressListener
.
STATE_BLOCKED_MIXED_ACTIVE_CONTENT
;
}
get
_isMixedPassiveContentLoaded
(
)
{
return
this
.
_state
&
Ci
.
nsIWebProgressListener
.
STATE_LOADED_MIXED_DISPLAY_CONTENT
;
}
get
_isCertUserOverridden
(
)
{
return
this
.
_state
&
Ci
.
nsIWebProgressListener
.
STATE_CERT_USER_OVERRIDDEN
;
}
get
_isCertDistrustImminent
(
)
{
return
this
.
_state
&
Ci
.
nsIWebProgressListener
.
STATE_CERT_DISTRUST_IMMINENT
;
}
get
_hasInsecureLoginForms
(
)
{
return
LoginManagerParent
.
hasInsecureLoginForms
(
gBrowser
.
selectedBrowser
)
&
&
Services
.
prefs
.
getBoolPref
(
"
security
.
insecure_password
.
ui
.
enabled
"
)
;
}
get
_identityPopup
(
)
{
delete
this
.
_identityPopup
;
return
this
.
_identityPopup
=
document
.
getElementById
(
"
identity
-
popup
"
)
;
}
get
_identityBox
(
)
{
delete
this
.
_identityBox
;
return
this
.
_identityBox
=
document
.
getElementById
(
"
identity
-
box
"
)
;
}
get
_identityPopupMultiView
(
)
{
delete
this
.
_identityPopupMultiView
;
return
this
.
_identityPopupMultiView
=
document
.
getElementById
(
"
identity
-
popup
-
multiView
"
)
;
}
get
_identityPopupMainView
(
)
{
delete
this
.
_identityPopupMainView
;
return
this
.
_identityPopupMainView
=
document
.
getElementById
(
"
identity
-
popup
-
mainView
"
)
;
}
get
_identityPopupMainViewHeaderLabel
(
)
{
delete
this
.
_identityPopupMainViewHeaderLabel
;
return
this
.
_identityPopupMainViewHeaderLabel
=
document
.
getElementById
(
"
identity
-
popup
-
mainView
-
panel
-
header
-
span
"
)
;
}
get
_identityPopupContentHost
(
)
{
delete
this
.
_identityPopupContentHost
;
return
this
.
_identityPopupContentHost
=
document
.
getElementById
(
"
identity
-
popup
-
host
"
)
;
}
get
_identityPopupContentOwner
(
)
{
delete
this
.
_identityPopupContentOwner
;
return
this
.
_identityPopupContentOwner
=
document
.
getElementById
(
"
identity
-
popup
-
content
-
owner
"
)
;
}
get
_identityPopupContentSupp
(
)
{
delete
this
.
_identityPopupContentSupp
;
return
this
.
_identityPopupContentSupp
=
document
.
getElementById
(
"
identity
-
popup
-
content
-
supplemental
"
)
;
}
get
_identityPopupContentVerif
(
)
{
delete
this
.
_identityPopupContentVerif
;
return
this
.
_identityPopupContentVerif
=
document
.
getElementById
(
"
identity
-
popup
-
content
-
verifier
"
)
;
}
get
_identityPopupMixedContentLearnMore
(
)
{
delete
this
.
_identityPopupMixedContentLearnMore
;
return
this
.
_identityPopupMixedContentLearnMore
=
[
.
.
.
document
.
querySelectorAll
(
"
.
identity
-
popup
-
mcb
-
learn
-
more
"
)
]
;
}
get
_identityPopupInsecureLoginFormsLearnMore
(
)
{
delete
this
.
_identityPopupInsecureLoginFormsLearnMore
;
return
this
.
_identityPopupInsecureLoginFormsLearnMore
=
document
.
getElementById
(
"
identity
-
popup
-
insecure
-
login
-
forms
-
learn
-
more
"
)
;
}
get
_identityIconLabels
(
)
{
delete
this
.
_identityIconLabels
;
return
this
.
_identityIconLabels
=
document
.
getElementById
(
"
identity
-
icon
-
labels
"
)
;
}
get
_identityIconLabel
(
)
{
delete
this
.
_identityIconLabel
;
return
this
.
_identityIconLabel
=
document
.
getElementById
(
"
identity
-
icon
-
label
"
)
;
}
get
_connectionIcon
(
)
{
delete
this
.
_connectionIcon
;
return
this
.
_connectionIcon
=
document
.
getElementById
(
"
connection
-
icon
"
)
;
}
get
_extensionIcon
(
)
{
delete
this
.
_extensionIcon
;
return
this
.
_extensionIcon
=
document
.
getElementById
(
"
extension
-
icon
"
)
;
}
get
_overrideService
(
)
{
delete
this
.
_overrideService
;
return
this
.
_overrideService
=
Cc
[
"
mozilla
.
org
/
security
/
certoverride
;
1
"
]
.
getService
(
Ci
.
nsICertOverrideService
)
;
}
get
_identityIconCountryLabel
(
)
{
delete
this
.
_identityIconCountryLabel
;
return
this
.
_identityIconCountryLabel
=
document
.
getElementById
(
"
identity
-
icon
-
country
-
label
"
)
;
}
get
_identityIcon
(
)
{
delete
this
.
_identityIcon
;
return
this
.
_identityIcon
=
document
.
getElementById
(
"
identity
-
icon
"
)
;
}
get
_permissionList
(
)
{
delete
this
.
_permissionList
;
return
this
.
_permissionList
=
document
.
getElementById
(
"
identity
-
popup
-
permission
-
list
"
)
;
}
get
_permissionEmptyHint
(
)
{
delete
this
.
_permissionEmptyHint
;
return
this
.
_permissionEmptyHint
=
document
.
getElementById
(
"
identity
-
popup
-
permission
-
empty
-
hint
"
)
;
}
get
_permissionReloadHint
(
)
{
delete
this
.
_permissionReloadHint
;
return
this
.
_permissionReloadHint
=
document
.
getElementById
(
"
identity
-
popup
-
permission
-
reload
-
hint
"
)
;
}
get
_popupExpander
(
)
{
delete
this
.
_popupExpander
;
return
this
.
_popupExpander
=
document
.
getElementById
(
"
identity
-
popup
-
security
-
expander
"
)
;
}
get
_clearSiteDataFooter
(
)
{
delete
this
.
_clearSiteDataFooter
;
return
this
.
_clearSiteDataFooter
=
document
.
getElementById
(
"
identity
-
popup
-
clear
-
sitedata
-
footer
"
)
;
}
get
_permissionAnchors
(
)
{
delete
this
.
_permissionAnchors
;
let
permissionAnchors
=
{
}
;
for
(
let
anchor
of
document
.
getElementById
(
"
blocked
-
permissions
-
container
"
)
.
children
)
{
permissionAnchors
[
anchor
.
getAttribute
(
"
data
-
permission
-
id
"
)
]
=
anchor
;
}
return
this
.
_permissionAnchors
=
permissionAnchors
;
}
get
_insecureConnectionIconEnabled
(
)
{
delete
this
.
_insecureConnectionIconEnabled
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
_insecureConnectionIconEnabled
"
"
security
.
insecure_connection_icon
.
enabled
"
)
;
return
this
.
_insecureConnectionIconEnabled
;
}
get
_insecureConnectionIconPBModeEnabled
(
)
{
delete
this
.
_insecureConnectionIconPBModeEnabled
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
_insecureConnectionIconPBModeEnabled
"
"
security
.
insecure_connection_icon
.
pbmode
.
enabled
"
)
;
return
this
.
_insecureConnectionIconPBModeEnabled
;
}
get
_insecureConnectionTextEnabled
(
)
{
delete
this
.
_insecureConnectionTextEnabled
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
_insecureConnectionTextEnabled
"
"
security
.
insecure_connection_text
.
enabled
"
)
;
return
this
.
_insecureConnectionTextEnabled
;
}
get
_insecureConnectionTextPBModeEnabled
(
)
{
delete
this
.
_insecureConnectionTextPBModeEnabled
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
_insecureConnectionTextPBModeEnabled
"
"
security
.
insecure_connection_text
.
pbmode
.
enabled
"
)
;
return
this
.
_insecureConnectionTextPBModeEnabled
;
}
async
clearSiteData
(
event
)
{
if
(
!
this
.
_uriHasHost
)
{
return
;
}
let
host
=
this
.
_uri
.
host
;
await
SiteDataManager
.
updateSites
(
)
;
let
baseDomain
=
SiteDataManager
.
getBaseDomainFromHost
(
host
)
;
let
siteData
=
await
SiteDataManager
.
getSites
(
baseDomain
)
;
PanelMultiView
.
hidePopup
(
this
.
_identityPopup
)
;
if
(
siteData
&
&
siteData
.
length
)
{
let
hosts
=
siteData
.
map
(
site
=
>
site
.
host
)
;
if
(
SiteDataManager
.
promptSiteDataRemoval
(
window
hosts
)
)
{
SiteDataManager
.
remove
(
hosts
)
;
}
}
event
.
stopPropagation
(
)
;
}
openPermissionPreferences
(
)
{
openPreferences
(
"
privacy
-
permissions
"
{
origin
:
"
identityPopup
-
permissions
-
PreferencesButton
"
}
)
;
}
recordClick
(
object
)
{
let
extra
=
{
}
;
for
(
let
blocker
of
ContentBlocking
.
blockers
)
{
extra
[
blocker
.
telemetryIdentifier
]
=
blocker
.
activated
?
"
true
"
:
"
false
"
;
}
Services
.
telemetry
.
recordEvent
(
"
security
.
ui
.
identitypopup
"
"
click
"
object
null
extra
)
;
}
handleMoreInfoClick
(
event
)
{
displaySecurityInfo
(
)
;
event
.
stopPropagation
(
)
;
PanelMultiView
.
hidePopup
(
this
.
_identityPopup
)
;
}
showSecuritySubView
(
)
{
this
.
_identityPopupMultiView
.
showSubView
(
"
identity
-
popup
-
securityView
"
this
.
_popupExpander
)
;
Services
.
focus
.
clearFocus
(
window
)
;
}
disableMixedContentProtection
(
)
{
const
kMIXED_CONTENT_UNBLOCK_EVENT
=
2
;
let
histogram
=
Services
.
telemetry
.
getHistogramById
(
"
MIXED_CONTENT_UNBLOCK_COUNTER
"
)
;
histogram
.
add
(
kMIXED_CONTENT_UNBLOCK_EVENT
)
;
BrowserReloadWithFlags
(
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_ALLOW_MIXED_CONTENT
)
;
PanelMultiView
.
hidePopup
(
this
.
_identityPopup
)
;
}
enableMixedContentProtection
(
)
{
gBrowser
.
selectedBrowser
.
messageManager
.
sendAsyncMessage
(
"
MixedContent
:
ReenableProtection
"
{
}
)
;
BrowserReload
(
)
;
PanelMultiView
.
hidePopup
(
this
.
_identityPopup
)
;
}
removeCertException
(
)
{
if
(
!
this
.
_uriHasHost
)
{
Cu
.
reportError
(
"
Trying
to
revoke
a
cert
exception
on
a
URI
without
a
host
?
"
)
;
return
;
}
let
host
=
this
.
_uri
.
host
;
let
port
=
this
.
_uri
.
port
>
0
?
this
.
_uri
.
port
:
443
;
this
.
_overrideService
.
clearValidityOverride
(
host
port
)
;
BrowserReloadSkipCache
(
)
;
PanelMultiView
.
hidePopup
(
this
.
_identityPopup
)
;
}
getIdentityData
(
)
{
var
result
=
{
}
;
var
cert
=
this
.
_secInfo
.
serverCert
;
result
.
subjectOrg
=
cert
.
organization
;
if
(
cert
.
subjectName
)
{
result
.
subjectNameFields
=
{
}
;
cert
.
subjectName
.
split
(
"
"
)
.
forEach
(
function
(
v
)
{
var
field
=
v
.
split
(
"
=
"
)
;
this
[
field
[
0
]
]
=
field
[
1
]
;
}
result
.
subjectNameFields
)
;
result
.
city
=
result
.
subjectNameFields
.
L
;
result
.
state
=
result
.
subjectNameFields
.
ST
;
result
.
country
=
result
.
subjectNameFields
.
C
;
}
result
.
caOrg
=
cert
.
issuerOrganization
|
|
cert
.
issuerCommonName
;
result
.
cert
=
cert
;
return
result
;
}
updateIdentity
(
state
uri
)
{
let
shouldHidePopup
=
this
.
_uri
&
&
(
this
.
_uri
.
spec
!
=
uri
.
spec
)
;
this
.
_state
=
state
;
this
.
setURI
(
uri
)
;
this
.
_secInfo
=
gBrowser
.
securityUI
.
secInfo
;
this
.
refreshIdentityBlock
(
)
;
if
(
shouldHidePopup
)
{
PanelMultiView
.
hidePopup
(
this
.
_identityPopup
)
;
}
if
(
this
.
_isCertDistrustImminent
)
{
let
consoleMsg
=
Cc
[
"
mozilla
.
org
/
scripterror
;
1
"
]
.
createInstance
(
Ci
.
nsIScriptError
)
;
let
windowId
=
gBrowser
.
selectedBrowser
.
innerWindowID
;
let
message
=
gBrowserBundle
.
GetStringFromName
(
"
certImminentDistrust
.
message
"
)
;
consoleMsg
.
initWithWindowID
(
message
uri
.
prePath
null
0
0
Ci
.
nsIScriptError
.
warningFlag
"
SSL
"
windowId
)
;
Services
.
console
.
logMessage
(
consoleMsg
)
;
}
}
refreshForInsecureLoginForms
(
)
{
if
(
!
this
.
_uri
)
{
return
;
}
this
.
refreshIdentityBlock
(
)
;
}
updateSharingIndicator
(
)
{
let
tab
=
gBrowser
.
selectedTab
;
this
.
_sharingState
=
tab
.
_sharingState
;
this
.
_identityBox
.
removeAttribute
(
"
paused
"
)
;
this
.
_identityBox
.
removeAttribute
(
"
sharing
"
)
;
if
(
this
.
_sharingState
&
&
this
.
_sharingState
.
sharing
)
{
this
.
_identityBox
.
setAttribute
(
"
sharing
"
this
.
_sharingState
.
sharing
)
;
if
(
this
.
_sharingState
.
paused
)
{
this
.
_identityBox
.
setAttribute
(
"
paused
"
"
true
"
)
;
}
}
if
(
this
.
_identityPopup
.
state
=
=
"
open
"
)
{
this
.
updateSitePermissions
(
)
;
PanelView
.
forNode
(
this
.
_identityPopupMainView
)
.
descriptionHeightWorkaround
(
)
;
}
}
getEffectiveHost
(
)
{
if
(
!
this
.
_IDNService
)
this
.
_IDNService
=
Cc
[
"
mozilla
.
org
/
network
/
idn
-
service
;
1
"
]
.
getService
(
Ci
.
nsIIDNService
)
;
try
{
return
this
.
_IDNService
.
convertToDisplayIDN
(
this
.
_uri
.
host
{
}
)
;
}
catch
(
e
)
{
return
this
.
_uri
.
host
;
}
}
get
pointerlockFsWarningClassName
(
)
{
if
(
this
.
_uriHasHost
&
&
this
.
_isEV
)
{
return
"
verifiedIdentity
"
;
}
if
(
this
.
_uriHasHost
&
&
this
.
_isSecure
)
{
return
"
verifiedDomain
"
;
}
return
"
unknownIdentity
"
;
}
refreshIdentityBlock
(
)
{
if
(
!
this
.
_identityBox
)
{
return
;
}
let
icon_label
=
"
"
;
let
tooltip
=
"
"
;
let
icon_country_label
=
"
"
;
let
icon_labels_dir
=
"
ltr
"
;
if
(
this
.
_isSecureInternalUI
)
{
this
.
_identityBox
.
className
=
"
chromeUI
"
;
let
brandBundle
=
document
.
getElementById
(
"
bundle_brand
"
)
;
icon_label
=
brandBundle
.
getString
(
"
brandShorterName
"
)
;
}
else
if
(
this
.
_uriHasHost
&
&
this
.
_isEV
)
{
this
.
_identityBox
.
className
=
"
verifiedIdentity
"
;
if
(
this
.
_isMixedActiveContentBlocked
)
{
this
.
_identityBox
.
classList
.
add
(
"
mixedActiveBlocked
"
)
;
}
if
(
!
this
.
_isCertUserOverridden
)
{
let
iData
=
this
.
getIdentityData
(
)
;
tooltip
=
gNavigatorBundle
.
getFormattedString
(
"
identity
.
identified
.
verifier
"
[
iData
.
caOrg
]
)
;
icon_label
=
iData
.
subjectOrg
;
if
(
iData
.
country
)
icon_country_label
=
"
(
"
+
iData
.
country
+
"
)
"
;
icon_labels_dir
=
/
^
[
\
u0590
-
\
u08ff
\
ufb1d
-
\
ufdff
\
ufe70
-
\
ufefc
\
ud802
\
ud803
\
ud83a
\
ud83b
]
/
.
test
(
icon_label
)
?
"
rtl
"
:
"
ltr
"
;
}
}
else
if
(
this
.
_pageExtensionPolicy
)
{
this
.
_identityBox
.
className
=
"
extensionPage
"
;
let
extensionName
=
this
.
_pageExtensionPolicy
.
name
;
icon_label
=
gNavigatorBundle
.
getFormattedString
(
"
identity
.
extension
.
label
"
[
extensionName
]
)
;
}
else
if
(
this
.
_uriHasHost
&
&
this
.
_isSecure
)
{
this
.
_identityBox
.
className
=
"
verifiedDomain
"
;
if
(
this
.
_isMixedActiveContentBlocked
)
{
this
.
_identityBox
.
classList
.
add
(
"
mixedActiveBlocked
"
)
;
}
if
(
!
this
.
_isCertUserOverridden
)
{
tooltip
=
gNavigatorBundle
.
getFormattedString
(
"
identity
.
identified
.
verifier
"
[
this
.
getIdentityData
(
)
.
caOrg
]
)
;
}
}
else
if
(
!
this
.
_uriHasHost
)
{
this
.
_identityBox
.
className
=
"
unknownIdentity
"
;
}
else
if
(
gBrowser
.
selectedBrowser
.
documentURI
&
&
(
gBrowser
.
selectedBrowser
.
documentURI
.
scheme
=
=
"
about
"
|
|
gBrowser
.
selectedBrowser
.
documentURI
.
scheme
=
=
"
chrome
"
)
)
{
this
.
_identityBox
.
className
=
"
unknownIdentity
"
;
}
else
{
if
(
this
.
_isBroken
)
{
this
.
_identityBox
.
className
=
"
unknownIdentity
"
;
if
(
this
.
_isMixedActiveContentLoaded
)
{
this
.
_identityBox
.
classList
.
add
(
"
mixedActiveContent
"
)
;
}
else
if
(
this
.
_isMixedActiveContentBlocked
)
{
this
.
_identityBox
.
classList
.
add
(
"
mixedDisplayContentLoadedActiveBlocked
"
)
;
}
else
if
(
this
.
_isMixedPassiveContentLoaded
)
{
this
.
_identityBox
.
classList
.
add
(
"
mixedDisplayContent
"
)
;
}
else
{
this
.
_identityBox
.
classList
.
add
(
"
weakCipher
"
)
;
}
}
else
{
let
warnOnInsecure
=
this
.
_insecureConnectionIconEnabled
|
|
(
this
.
_insecureConnectionIconPBModeEnabled
&
&
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
;
let
className
=
warnOnInsecure
?
"
notSecure
"
:
"
unknownIdentity
"
;
this
.
_identityBox
.
className
=
className
;
let
warnTextOnInsecure
=
this
.
_insecureConnectionTextEnabled
|
|
(
this
.
_insecureConnectionTextPBModeEnabled
&
&
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
;
if
(
warnTextOnInsecure
)
{
icon_label
=
gNavigatorBundle
.
getString
(
"
identity
.
notSecure
.
label
"
)
;
this
.
_identityBox
.
classList
.
add
(
"
notSecureText
"
)
;
}
}
if
(
this
.
_hasInsecureLoginForms
)
{
this
.
_identityBox
.
classList
.
add
(
"
insecureLoginForms
"
)
;
}
}
if
(
this
.
_isCertUserOverridden
)
{
this
.
_identityBox
.
classList
.
add
(
"
certUserOverridden
"
)
;
tooltip
=
gNavigatorBundle
.
getString
(
"
identity
.
identified
.
verified_by_you
"
)
;
}
let
permissionAnchors
=
this
.
_permissionAnchors
;
for
(
let
icon
of
Object
.
values
(
permissionAnchors
)
)
{
icon
.
removeAttribute
(
"
showing
"
)
;
}
let
hasGrantedPermissions
=
false
;
let
permissions
=
SitePermissions
.
getAllForBrowser
(
gBrowser
.
selectedBrowser
)
;
for
(
let
permission
of
permissions
)
{
if
(
permission
.
state
=
=
SitePermissions
.
BLOCK
)
{
let
icon
=
permissionAnchors
[
permission
.
id
]
;
if
(
icon
)
{
icon
.
setAttribute
(
"
showing
"
"
true
"
)
;
}
}
else
if
(
permission
.
state
!
=
SitePermissions
.
UNKNOWN
)
{
hasGrantedPermissions
=
true
;
}
}
if
(
hasGrantedPermissions
)
{
this
.
_identityBox
.
classList
.
add
(
"
grantedPermissions
"
)
;
}
if
(
gBrowser
.
selectedBrowser
.
blockedPopups
&
&
gBrowser
.
selectedBrowser
.
blockedPopups
.
length
)
{
let
icon
=
permissionAnchors
.
popup
;
icon
.
setAttribute
(
"
showing
"
"
true
"
)
;
}
this
.
_connectionIcon
.
setAttribute
(
"
tooltiptext
"
tooltip
)
;
if
(
this
.
_pageExtensionPolicy
)
{
let
extensionName
=
this
.
_pageExtensionPolicy
.
name
;
this
.
_extensionIcon
.
setAttribute
(
"
tooltiptext
"
gNavigatorBundle
.
getFormattedString
(
"
identity
.
extension
.
tooltip
"
[
extensionName
]
)
)
;
}
this
.
_identityIconLabels
.
setAttribute
(
"
tooltiptext
"
tooltip
)
;
this
.
_identityIcon
.
setAttribute
(
"
tooltiptext
"
gNavigatorBundle
.
getString
(
"
identity
.
icon
.
tooltip
"
)
)
;
this
.
_identityIconLabel
.
setAttribute
(
"
value
"
icon_label
)
;
this
.
_identityIconCountryLabel
.
setAttribute
(
"
value
"
icon_country_label
)
;
this
.
_identityIconLabel
.
setAttribute
(
"
crop
"
icon_country_label
?
"
end
"
:
"
center
"
)
;
this
.
_identityIconLabel
.
parentNode
.
style
.
direction
=
icon_labels_dir
;
this
.
_identityIconLabel
.
parentNode
.
collapsed
=
!
icon_label
;
}
refreshIdentityPopup
(
)
{
this
.
_clearSiteDataFooter
.
hidden
=
true
;
if
(
this
.
_uriHasHost
)
{
let
host
=
this
.
_uri
.
host
;
SiteDataManager
.
updateSites
(
)
.
then
(
async
(
)
=
>
{
let
baseDomain
=
SiteDataManager
.
getBaseDomainFromHost
(
host
)
;
let
siteData
=
await
SiteDataManager
.
getSites
(
baseDomain
)
;
if
(
siteData
&
&
siteData
.
length
)
{
this
.
_clearSiteDataFooter
.
hidden
=
false
;
}
}
)
;
}
let
baseURL
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
;
this
.
_identityPopupMixedContentLearnMore
.
forEach
(
e
=
>
e
.
setAttribute
(
"
href
"
baseURL
+
"
mixed
-
content
"
)
)
;
this
.
_identityPopupInsecureLoginFormsLearnMore
.
setAttribute
(
"
href
"
baseURL
+
"
insecure
-
password
"
)
;
this
.
_popupExpander
.
tooltipText
=
gNavigatorBundle
.
getString
(
"
identity
.
showDetails
.
tooltip
"
)
;
let
connection
=
"
not
-
secure
"
;
if
(
this
.
_isSecureInternalUI
)
{
connection
=
"
chrome
"
;
}
else
if
(
this
.
_pageExtensionPolicy
)
{
connection
=
"
extension
"
;
}
else
if
(
this
.
_isURILoadedFromFile
)
{
connection
=
"
file
"
;
}
else
if
(
this
.
_isEV
)
{
connection
=
"
secure
-
ev
"
;
}
else
if
(
this
.
_isCertUserOverridden
)
{
connection
=
"
secure
-
cert
-
user
-
overridden
"
;
}
else
if
(
this
.
_isSecure
)
{
connection
=
"
secure
"
;
}
let
loginforms
=
"
secure
"
;
if
(
this
.
_hasInsecureLoginForms
)
{
loginforms
=
"
insecure
"
;
}
let
mixedcontent
=
[
]
;
if
(
this
.
_isMixedPassiveContentLoaded
)
{
mixedcontent
.
push
(
"
passive
-
loaded
"
)
;
}
if
(
this
.
_isMixedActiveContentLoaded
)
{
mixedcontent
.
push
(
"
active
-
loaded
"
)
;
}
else
if
(
this
.
_isMixedActiveContentBlocked
)
{
mixedcontent
.
push
(
"
active
-
blocked
"
)
;
}
mixedcontent
=
mixedcontent
.
join
(
"
"
)
;
let
ciphers
=
"
"
;
if
(
this
.
_isBroken
&
&
!
this
.
_isMixedActiveContentLoaded
&
&
!
this
.
_isMixedPassiveContentLoaded
)
{
ciphers
=
"
weak
"
;
}
let
elementIDs
=
[
"
identity
-
popup
"
"
identity
-
popup
-
securityView
-
body
"
]
;
function
updateAttribute
(
elem
attr
value
)
{
if
(
value
)
{
elem
.
setAttribute
(
attr
value
)
;
}
else
{
elem
.
removeAttribute
(
attr
)
;
}
}
for
(
let
id
of
elementIDs
)
{
let
element
=
document
.
getElementById
(
id
)
;
updateAttribute
(
element
"
connection
"
connection
)
;
updateAttribute
(
element
"
loginforms
"
loginforms
)
;
updateAttribute
(
element
"
ciphers
"
ciphers
)
;
updateAttribute
(
element
"
mixedcontent
"
mixedcontent
)
;
updateAttribute
(
element
"
isbroken
"
this
.
_isBroken
)
;
}
let
supplemental
=
"
"
;
let
verifier
=
"
"
;
let
host
=
"
"
;
let
owner
=
"
"
;
try
{
host
=
this
.
getEffectiveHost
(
)
;
}
catch
(
e
)
{
}
if
(
this
.
_pageExtensionPolicy
)
{
host
=
this
.
_pageExtensionPolicy
.
name
;
}
if
(
!
host
)
{
host
=
this
.
_uri
.
specIgnoringRef
;
}
if
(
this
.
_isSecure
|
|
this
.
_isCertUserOverridden
)
{
verifier
=
this
.
_identityIconLabels
.
tooltipText
;
}
if
(
this
.
_isEV
)
{
let
iData
=
this
.
getIdentityData
(
)
;
host
=
owner
=
iData
.
subjectOrg
;
verifier
=
this
.
_identityIconLabels
.
tooltipText
;
if
(
iData
.
city
)
supplemental
+
=
iData
.
city
+
"
\
n
"
;
if
(
iData
.
state
&
&
iData
.
country
)
supplemental
+
=
gNavigatorBundle
.
getFormattedString
(
"
identity
.
identified
.
state_and_country
"
[
iData
.
state
iData
.
country
]
)
;
else
if
(
iData
.
state
)
supplemental
+
=
iData
.
state
;
else
if
(
iData
.
country
)
supplemental
+
=
iData
.
country
;
}
this
.
_identityPopupMainViewHeaderLabel
.
textContent
=
gNavigatorBundle
.
getFormattedString
(
"
identity
.
headerWithHost
"
[
host
]
)
;
this
.
_identityPopupContentHost
.
textContent
=
host
;
this
.
_identityPopupContentOwner
.
textContent
=
owner
;
this
.
_identityPopupContentSupp
.
textContent
=
supplemental
;
this
.
_identityPopupContentVerif
.
textContent
=
verifier
;
this
.
updateSitePermissions
(
)
;
}
setURI
(
uri
)
{
this
.
_uri
=
uri
;
try
{
this
.
_uriHasHost
=
!
!
this
.
_uri
.
host
;
}
catch
(
ex
)
{
this
.
_uriHasHost
=
false
;
}
this
.
_isSecureInternalUI
=
uri
.
schemeIs
(
"
about
"
)
&
&
this
.
_secureInternalUIWhitelist
.
test
(
uri
.
pathQueryRef
)
;
this
.
_pageExtensionPolicy
=
WebExtensionPolicy
.
getByURI
(
uri
)
;
this
.
_isURILoadedFromFile
=
false
;
let
chanOptions
=
{
uri
:
this
.
_uri
loadUsingSystemPrincipal
:
true
}
;
let
resolvedURI
;
try
{
resolvedURI
=
NetUtil
.
newChannel
(
chanOptions
)
.
URI
;
if
(
resolvedURI
.
schemeIs
(
"
jar
"
)
)
{
resolvedURI
=
NetUtil
.
newURI
(
resolvedURI
.
pathQueryRef
)
;
}
this
.
_isURILoadedFromFile
=
resolvedURI
.
schemeIs
(
"
file
"
)
;
}
catch
(
ex
)
{
}
}
handleIdentityButtonEvent
(
event
)
{
event
.
stopPropagation
(
)
;
if
(
(
event
.
type
=
=
"
click
"
&
&
event
.
button
!
=
0
)
|
|
(
event
.
type
=
=
"
keypress
"
&
&
event
.
charCode
!
=
KeyEvent
.
DOM_VK_SPACE
&
&
event
.
keyCode
!
=
KeyEvent
.
DOM_VK_RETURN
)
)
{
return
;
}
if
(
!
this
.
_sharingState
&
&
gURLBar
.
getAttribute
(
"
pageproxystate
"
)
!
=
"
valid
"
)
{
return
;
}
this
.
_identityPopup
.
hidden
=
false
;
this
.
_permissionReloadHint
.
setAttribute
(
"
hidden
"
"
true
"
)
;
this
.
refreshIdentityPopup
(
)
;
this
.
_identityBox
.
setAttribute
(
"
open
"
"
true
"
)
;
PanelMultiView
.
openPopup
(
this
.
_identityPopup
this
.
_identityIcon
{
position
:
"
bottomcenter
topleft
"
triggerEvent
:
event
}
)
.
catch
(
Cu
.
reportError
)
;
}
onPopupShown
(
event
)
{
if
(
event
.
target
=
=
this
.
_identityPopup
)
{
window
.
addEventListener
(
"
focus
"
this
true
)
;
}
let
extra
=
{
}
;
for
(
let
blocker
of
ContentBlocking
.
blockers
)
{
extra
[
blocker
.
telemetryIdentifier
]
=
blocker
.
activated
?
"
true
"
:
"
false
"
;
}
let
shieldStatus
=
ContentBlocking
.
iconBox
.
hasAttribute
(
"
active
"
)
?
"
shield
-
showing
"
:
"
shield
-
hidden
"
;
Services
.
telemetry
.
recordEvent
(
"
security
.
ui
.
identitypopup
"
"
open
"
"
identity_popup
"
shieldStatus
extra
)
;
}
onPopupHidden
(
event
)
{
if
(
event
.
target
=
=
this
.
_identityPopup
)
{
window
.
removeEventListener
(
"
focus
"
this
true
)
;
this
.
_identityBox
.
removeAttribute
(
"
open
"
)
;
}
}
handleEvent
(
event
)
{
let
elem
=
document
.
activeElement
;
let
position
=
elem
.
compareDocumentPosition
(
this
.
_identityPopup
)
;
if
(
!
(
position
&
(
Node
.
DOCUMENT_POSITION_CONTAINS
|
Node
.
DOCUMENT_POSITION_CONTAINED_BY
)
)
&
&
!
this
.
_identityPopup
.
hasAttribute
(
"
noautohide
"
)
)
{
PanelMultiView
.
hidePopup
(
this
.
_identityPopup
)
;
}
}
observe
(
subject
topic
data
)
{
if
(
topic
=
=
"
perm
-
changed
"
&
&
subject
&
&
SitePermissions
.
listPermissions
(
)
.
includes
(
subject
.
QueryInterface
(
Ci
.
nsIPermission
)
.
type
)
)
{
this
.
refreshIdentityBlock
(
)
;
}
}
onDragStart
(
event
)
{
if
(
gURLBar
.
getAttribute
(
"
pageproxystate
"
)
!
=
"
valid
"
)
return
;
let
value
=
gBrowser
.
currentURI
.
displaySpec
;
let
urlString
=
value
+
"
\
n
"
+
gBrowser
.
contentTitle
;
let
htmlString
=
"
<
a
href
=
\
"
"
+
value
+
"
\
"
>
"
+
value
+
"
<
/
a
>
"
;
let
dt
=
event
.
dataTransfer
;
dt
.
setData
(
"
text
/
x
-
moz
-
url
"
urlString
)
;
dt
.
setData
(
"
text
/
uri
-
list
"
value
)
;
dt
.
setData
(
"
text
/
plain
"
value
)
;
dt
.
setData
(
"
text
/
html
"
htmlString
)
;
dt
.
setDragImage
(
this
.
_identityIcon
16
16
)
;
}
onLocationChange
(
)
{
this
.
_permissionReloadHint
.
setAttribute
(
"
hidden
"
"
true
"
)
;
if
(
!
this
.
_permissionList
.
hasChildNodes
(
)
)
{
this
.
_permissionEmptyHint
.
removeAttribute
(
"
hidden
"
)
;
}
}
updateSitePermissions
(
)
{
while
(
this
.
_permissionList
.
hasChildNodes
(
)
)
this
.
_permissionList
.
removeChild
(
this
.
_permissionList
.
lastChild
)
;
let
permissions
=
SitePermissions
.
getAllPermissionDetailsForBrowser
(
gBrowser
.
selectedBrowser
)
;
if
(
this
.
_sharingState
)
{
for
(
let
id
of
[
"
camera
"
"
microphone
"
"
screen
"
]
)
{
if
(
this
.
_sharingState
[
id
]
)
{
let
found
=
false
;
for
(
let
permission
of
permissions
)
{
if
(
permission
.
id
!
=
id
)
continue
;
found
=
true
;
permission
.
sharingState
=
this
.
_sharingState
[
id
]
;
break
;
}
if
(
!
found
)
{
permissions
.
push
(
{
id
state
:
SitePermissions
.
ALLOW
scope
:
SitePermissions
.
SCOPE_REQUEST
sharingState
:
this
.
_sharingState
[
id
]
}
)
;
}
}
}
}
let
hasBlockedPopupIndicator
=
false
;
for
(
let
permission
of
permissions
)
{
if
(
permission
.
id
=
=
"
storage
-
access
"
)
{
continue
;
}
let
item
=
this
.
_createPermissionItem
(
permission
)
;
if
(
!
item
)
{
continue
;
}
this
.
_permissionList
.
appendChild
(
item
)
;
if
(
permission
.
id
=
=
"
popup
"
&
&
gBrowser
.
selectedBrowser
.
blockedPopups
&
&
gBrowser
.
selectedBrowser
.
blockedPopups
.
length
)
{
this
.
_createBlockedPopupIndicator
(
)
;
hasBlockedPopupIndicator
=
true
;
}
}
if
(
gBrowser
.
selectedBrowser
.
blockedPopups
&
&
gBrowser
.
selectedBrowser
.
blockedPopups
.
length
&
&
!
hasBlockedPopupIndicator
)
{
let
permission
=
{
id
:
"
popup
"
state
:
SitePermissions
.
getDefault
(
"
popup
"
)
scope
:
SitePermissions
.
SCOPE_PERSISTENT
}
;
let
item
=
this
.
_createPermissionItem
(
permission
)
;
this
.
_permissionList
.
appendChild
(
item
)
;
this
.
_createBlockedPopupIndicator
(
)
;
}
if
(
!
this
.
_permissionList
.
hasChildNodes
(
)
&
&
this
.
_permissionReloadHint
.
hasAttribute
(
"
hidden
"
)
)
{
this
.
_permissionEmptyHint
.
removeAttribute
(
"
hidden
"
)
;
}
else
{
this
.
_permissionEmptyHint
.
setAttribute
(
"
hidden
"
"
true
"
)
;
}
}
_createPermissionItem
(
aPermission
)
{
let
container
=
document
.
createXULElement
(
"
hbox
"
)
;
container
.
setAttribute
(
"
class
"
"
identity
-
popup
-
permission
-
item
"
)
;
container
.
setAttribute
(
"
align
"
"
center
"
)
;
container
.
setAttribute
(
"
role
"
"
group
"
)
;
let
img
=
document
.
createXULElement
(
"
image
"
)
;
img
.
classList
.
add
(
"
identity
-
popup
-
permission
-
icon
"
)
;
if
(
aPermission
.
id
=
=
"
plugin
:
flash
"
)
{
img
.
classList
.
add
(
"
plugin
-
icon
"
)
;
}
else
{
img
.
classList
.
add
(
aPermission
.
id
+
"
-
icon
"
)
;
}
if
(
aPermission
.
state
=
=
SitePermissions
.
BLOCK
)
img
.
classList
.
add
(
"
blocked
-
permission
-
icon
"
)
;
if
(
aPermission
.
sharingState
=
=
Ci
.
nsIMediaManagerService
.
STATE_CAPTURE_ENABLED
|
|
(
aPermission
.
id
=
=
"
screen
"
&
&
aPermission
.
sharingState
&
&
!
aPermission
.
sharingState
.
includes
(
"
Paused
"
)
)
)
{
img
.
classList
.
add
(
"
in
-
use
"
)
;
window
.
promiseDocumentFlushed
(
(
)
=
>
{
let
sharingIconBlink
=
document
.
getElementById
(
"
sharing
-
icon
"
)
.
getAnimations
(
)
[
0
]
;
let
imgBlink
=
img
.
getAnimations
(
)
[
0
]
;
return
[
sharingIconBlink
imgBlink
]
;
}
)
.
then
(
(
[
sharingIconBlink
imgBlink
]
)
=
>
{
if
(
sharingIconBlink
&
&
imgBlink
)
{
imgBlink
.
startTime
=
sharingIconBlink
.
startTime
;
}
}
)
;
}
let
nameLabel
=
document
.
createXULElement
(
"
label
"
)
;
nameLabel
.
setAttribute
(
"
flex
"
"
1
"
)
;
nameLabel
.
setAttribute
(
"
class
"
"
identity
-
popup
-
permission
-
label
"
)
;
let
label
=
SitePermissions
.
getPermissionLabel
(
aPermission
.
id
)
;
if
(
label
=
=
=
null
)
{
return
null
;
}
nameLabel
.
textContent
=
label
;
let
nameLabelId
=
"
identity
-
popup
-
permission
-
label
-
"
+
aPermission
.
id
;
nameLabel
.
setAttribute
(
"
id
"
nameLabelId
)
;
let
isPolicyPermission
=
[
SitePermissions
.
SCOPE_POLICY
SitePermissions
.
SCOPE_GLOBAL
]
.
includes
(
aPermission
.
scope
)
;
if
(
(
aPermission
.
id
=
=
"
popup
"
&
&
!
isPolicyPermission
)
|
|
aPermission
.
id
=
=
"
autoplay
-
media
"
)
{
let
menulist
=
document
.
createXULElement
(
"
menulist
"
)
;
let
menupopup
=
document
.
createXULElement
(
"
menupopup
"
)
;
let
block
=
document
.
createXULElement
(
"
vbox
"
)
;
block
.
setAttribute
(
"
id
"
"
identity
-
popup
-
popup
-
container
"
)
;
menulist
.
setAttribute
(
"
sizetopopup
"
"
none
"
)
;
menulist
.
setAttribute
(
"
class
"
"
identity
-
popup
-
popup
-
menulist
"
)
;
menulist
.
setAttribute
(
"
id
"
"
identity
-
popup
-
popup
-
menulist
"
)
;
for
(
let
state
of
SitePermissions
.
getAvailableStates
(
aPermission
.
id
)
)
{
let
menuitem
=
document
.
createXULElement
(
"
menuitem
"
)
;
if
(
state
=
=
SitePermissions
.
getDefault
(
aPermission
.
id
)
)
{
menuitem
.
setAttribute
(
"
value
"
"
0
"
)
;
}
else
{
menuitem
.
setAttribute
(
"
value
"
state
)
;
}
menuitem
.
setAttribute
(
"
label
"
SitePermissions
.
getMultichoiceStateLabel
(
state
)
)
;
menupopup
.
appendChild
(
menuitem
)
;
}
menulist
.
appendChild
(
menupopup
)
;
if
(
aPermission
.
state
=
=
SitePermissions
.
getDefault
(
aPermission
.
id
)
)
{
menulist
.
value
=
"
0
"
;
}
else
{
menulist
.
value
=
aPermission
.
state
;
}
menulist
.
addEventListener
(
"
command
"
(
)
=
>
{
SitePermissions
.
set
(
gBrowser
.
currentURI
aPermission
.
id
menulist
.
selectedItem
.
value
)
;
}
)
;
container
.
appendChild
(
img
)
;
container
.
appendChild
(
nameLabel
)
;
container
.
appendChild
(
menulist
)
;
container
.
setAttribute
(
"
aria
-
labelledby
"
nameLabelId
)
;
block
.
appendChild
(
container
)
;
return
block
;
}
let
stateLabel
=
document
.
createXULElement
(
"
label
"
)
;
stateLabel
.
setAttribute
(
"
flex
"
"
1
"
)
;
stateLabel
.
setAttribute
(
"
class
"
"
identity
-
popup
-
permission
-
state
-
label
"
)
;
let
stateLabelId
=
"
identity
-
popup
-
permission
-
state
-
label
-
"
+
aPermission
.
id
;
stateLabel
.
setAttribute
(
"
id
"
stateLabelId
)
;
let
{
state
scope
}
=
aPermission
;
if
(
state
!
=
SitePermissions
.
ALLOW
&
&
aPermission
.
sharingState
)
{
state
=
SitePermissions
.
ALLOW
;
scope
=
SitePermissions
.
SCOPE_REQUEST
;
}
stateLabel
.
textContent
=
SitePermissions
.
getCurrentStateLabel
(
state
aPermission
.
id
scope
)
;
container
.
appendChild
(
img
)
;
container
.
appendChild
(
nameLabel
)
;
container
.
appendChild
(
stateLabel
)
;
container
.
setAttribute
(
"
aria
-
labelledby
"
nameLabelId
+
"
"
+
stateLabelId
)
;
if
(
isPolicyPermission
)
{
return
container
;
}
let
button
=
document
.
createXULElement
(
"
button
"
)
;
button
.
setAttribute
(
"
class
"
"
identity
-
popup
-
permission
-
remove
-
button
"
)
;
let
tooltiptext
=
aPermission
.
isPromptable
?
gNavigatorBundle
.
getString
(
"
permissions
.
remove
.
tooltip
"
)
:
gNavigatorBundle
.
getString
(
"
permissions
.
remove
.
tooltip
.
noPrompt
"
)
;
button
.
setAttribute
(
"
tooltiptext
"
tooltiptext
)
;
button
.
addEventListener
(
"
command
"
(
)
=
>
{
let
browser
=
gBrowser
.
selectedBrowser
;
this
.
_permissionList
.
removeChild
(
container
)
;
if
(
aPermission
.
sharingState
&
&
[
"
camera
"
"
microphone
"
"
screen
"
]
.
includes
(
aPermission
.
id
)
)
{
let
windowId
=
this
.
_sharingState
.
windowId
;
if
(
aPermission
.
id
=
=
"
screen
"
)
{
windowId
=
"
screen
:
"
+
windowId
;
}
else
{
let
uris
=
browser
.
_devicePermissionURIs
|
|
[
]
;
for
(
let
uri
of
uris
)
{
for
(
let
id
of
[
"
camera
"
"
microphone
"
]
)
{
if
(
this
.
_sharingState
[
id
]
)
{
let
perm
=
SitePermissions
.
get
(
uri
id
)
;
if
(
perm
.
state
=
=
SitePermissions
.
ALLOW
&
&
perm
.
scope
=
=
SitePermissions
.
SCOPE_PERSISTENT
)
{
SitePermissions
.
remove
(
uri
id
)
;
}
}
}
}
}
browser
.
messageManager
.
sendAsyncMessage
(
"
webrtc
:
StopSharing
"
windowId
)
;
webrtcUI
.
forgetActivePermissionsFromBrowser
(
gBrowser
.
selectedBrowser
)
;
}
SitePermissions
.
remove
(
gBrowser
.
currentURI
aPermission
.
id
browser
)
;
this
.
_permissionReloadHint
.
removeAttribute
(
"
hidden
"
)
;
PanelView
.
forNode
(
this
.
_identityPopupMainView
)
.
descriptionHeightWorkaround
(
)
;
}
)
;
container
.
appendChild
(
button
)
;
return
container
;
}
_createBlockedPopupIndicator
(
)
{
let
indicator
=
document
.
createXULElement
(
"
hbox
"
)
;
indicator
.
setAttribute
(
"
class
"
"
identity
-
popup
-
permission
-
item
"
)
;
indicator
.
setAttribute
(
"
align
"
"
center
"
)
;
indicator
.
setAttribute
(
"
id
"
"
blocked
-
popup
-
indicator
-
item
"
)
;
let
icon
=
document
.
createXULElement
(
"
image
"
)
;
icon
.
setAttribute
(
"
class
"
"
popup
-
subitem
identity
-
popup
-
permission
-
icon
"
)
;
let
text
=
document
.
createXULElement
(
"
label
"
)
;
text
.
setAttribute
(
"
flex
"
"
1
"
)
;
text
.
setAttribute
(
"
class
"
"
identity
-
popup
-
permission
-
label
text
-
link
"
)
;
let
popupCount
=
gBrowser
.
selectedBrowser
.
blockedPopups
.
length
;
let
messageBase
=
gNavigatorBundle
.
getString
(
"
popupShowBlockedPopupsIndicatorText
"
)
;
let
message
=
PluralForm
.
get
(
popupCount
messageBase
)
.
replace
(
"
#
1
"
popupCount
)
;
text
.
textContent
=
message
;
text
.
addEventListener
(
"
click
"
(
)
=
>
{
gPopupBlockerObserver
.
showAllBlockedPopups
(
gBrowser
.
selectedBrowser
)
;
}
)
;
indicator
.
appendChild
(
icon
)
;
indicator
.
appendChild
(
text
)
;
document
.
getElementById
(
"
identity
-
popup
-
popup
-
container
"
)
.
appendChild
(
indicator
)
;
}
}
;
