var
gIdentityHandler
=
{
_uri
:
null
_uriHasHost
:
false
_pageExtensionPolicy
:
null
_isSecureInternalUI
:
false
_isSecureContext
:
false
_secInfo
:
null
_state
:
0
_secureInternalPages
:
/
^
(
?
:
accounts
|
addons
|
cache
|
certificate
|
config
|
crashes
|
downloads
|
license
|
logins
|
preferences
|
protections
|
rights
|
sessionrestore
|
support
|
welcomeback
|
ion
)
(
?
:
[
?
#
]
|
)
/
i
get
_isBrokenConnection
(
)
{
return
this
.
_state
&
Ci
.
nsIWebProgressListener
.
STATE_IS_BROKEN
;
}
get
_isSecureConnection
(
)
{
return
(
!
this
.
_isURILoadedFromFile
&
&
this
.
_state
&
Ci
.
nsIWebProgressListener
.
STATE_IS_SECURE
)
;
}
get
_isEV
(
)
{
return
(
!
this
.
_isURILoadedFromFile
&
&
this
.
_state
&
Ci
.
nsIWebProgressListener
.
STATE_IDENTITY_EV_TOPLEVEL
)
;
}
get
_isMixedActiveContentLoaded
(
)
{
return
(
this
.
_state
&
Ci
.
nsIWebProgressListener
.
STATE_LOADED_MIXED_ACTIVE_CONTENT
)
;
}
get
_isMixedActiveContentBlocked
(
)
{
return
(
this
.
_state
&
Ci
.
nsIWebProgressListener
.
STATE_BLOCKED_MIXED_ACTIVE_CONTENT
)
;
}
get
_isMixedPassiveContentLoaded
(
)
{
return
(
this
.
_state
&
Ci
.
nsIWebProgressListener
.
STATE_LOADED_MIXED_DISPLAY_CONTENT
)
;
}
get
_isContentHttpsOnlyModeUpgraded
(
)
{
return
(
this
.
_state
&
Ci
.
nsIWebProgressListener
.
STATE_HTTPS_ONLY_MODE_UPGRADED
)
;
}
get
_isContentHttpsOnlyModeUpgradeFailed
(
)
{
return
(
this
.
_state
&
Ci
.
nsIWebProgressListener
.
STATE_HTTPS_ONLY_MODE_UPGRADE_FAILED
)
;
}
get
_isCertUserOverridden
(
)
{
return
this
.
_state
&
Ci
.
nsIWebProgressListener
.
STATE_CERT_USER_OVERRIDDEN
;
}
get
_isAboutCertErrorPage
(
)
{
return
(
gBrowser
.
selectedBrowser
.
documentURI
&
&
gBrowser
.
selectedBrowser
.
documentURI
.
scheme
=
=
"
about
"
&
&
gBrowser
.
selectedBrowser
.
documentURI
.
pathQueryRef
.
startsWith
(
"
certerror
"
)
)
;
}
get
_isAboutNetErrorPage
(
)
{
return
(
gBrowser
.
selectedBrowser
.
documentURI
&
&
gBrowser
.
selectedBrowser
.
documentURI
.
scheme
=
=
"
about
"
&
&
gBrowser
.
selectedBrowser
.
documentURI
.
pathQueryRef
.
startsWith
(
"
neterror
"
)
)
;
}
get
_isAboutHttpsOnlyErrorPage
(
)
{
return
(
gBrowser
.
selectedBrowser
.
documentURI
&
&
gBrowser
.
selectedBrowser
.
documentURI
.
scheme
=
=
"
about
"
&
&
gBrowser
.
selectedBrowser
.
documentURI
.
pathQueryRef
.
startsWith
(
"
httpsonlyerror
"
)
)
;
}
get
_isPDFViewer
(
)
{
return
gBrowser
.
contentPrincipal
?
.
originNoSuffix
=
=
"
resource
:
/
/
pdf
.
js
"
;
}
get
_isPotentiallyTrustworthy
(
)
{
return
(
!
this
.
_isBrokenConnection
&
&
!
this
.
_isPDFViewer
&
&
(
this
.
_isSecureContext
|
|
(
gBrowser
.
selectedBrowser
.
documentURI
&
&
gBrowser
.
selectedBrowser
.
documentURI
.
scheme
=
=
"
chrome
"
)
)
)
;
}
get
_isAboutBlockedPage
(
)
{
return
(
gBrowser
.
selectedBrowser
.
documentURI
&
&
gBrowser
.
selectedBrowser
.
documentURI
.
scheme
=
=
"
about
"
&
&
gBrowser
.
selectedBrowser
.
documentURI
.
pathQueryRef
.
startsWith
(
"
blocked
"
)
)
;
}
_popupInitialized
:
false
_initializePopup
(
)
{
if
(
!
this
.
_popupInitialized
)
{
let
wrapper
=
document
.
getElementById
(
"
template
-
identity
-
popup
"
)
;
wrapper
.
replaceWith
(
wrapper
.
content
)
;
this
.
_popupInitialized
=
true
;
}
}
hidePopup
(
)
{
if
(
this
.
_popupInitialized
)
{
PanelMultiView
.
hidePopup
(
this
.
_identityPopup
)
;
}
}
get
_identityPopup
(
)
{
if
(
!
this
.
_popupInitialized
)
{
return
null
;
}
delete
this
.
_identityPopup
;
return
(
this
.
_identityPopup
=
document
.
getElementById
(
"
identity
-
popup
"
)
)
;
}
get
_identityBox
(
)
{
delete
this
.
_identityBox
;
return
(
this
.
_identityBox
=
document
.
getElementById
(
"
identity
-
box
"
)
)
;
}
get
_identityIconBox
(
)
{
delete
this
.
_identityIconBox
;
return
(
this
.
_identityIconBox
=
document
.
getElementById
(
"
identity
-
icon
-
box
"
)
)
;
}
get
_identityPopupMultiView
(
)
{
delete
this
.
_identityPopupMultiView
;
return
(
this
.
_identityPopupMultiView
=
document
.
getElementById
(
"
identity
-
popup
-
multiView
"
)
)
;
}
get
_identityPopupMainView
(
)
{
delete
this
.
_identityPopupMainView
;
return
(
this
.
_identityPopupMainView
=
document
.
getElementById
(
"
identity
-
popup
-
mainView
"
)
)
;
}
get
_identityPopupMainViewHeaderLabel
(
)
{
delete
this
.
_identityPopupMainViewHeaderLabel
;
return
(
this
.
_identityPopupMainViewHeaderLabel
=
document
.
getElementById
(
"
identity
-
popup
-
mainView
-
panel
-
header
-
span
"
)
)
;
}
get
_identityPopupSecurityView
(
)
{
delete
this
.
_identityPopupSecurityView
;
return
(
this
.
_identityPopupSecurityView
=
document
.
getElementById
(
"
identity
-
popup
-
securityView
"
)
)
;
}
get
_identityPopupHttpsOnlyModeMenuList
(
)
{
delete
this
.
_identityPopupHttpsOnlyModeMenuList
;
return
(
this
.
_identityPopupHttpsOnlyModeMenuList
=
document
.
getElementById
(
"
identity
-
popup
-
security
-
httpsonlymode
-
menulist
"
)
)
;
}
get
_identityPopupHttpsOnlyModeMenuListTempItem
(
)
{
delete
this
.
_identityPopupHttpsOnlyModeMenuListTempItem
;
return
(
this
.
_identityPopupHttpsOnlyModeMenuListTempItem
=
document
.
getElementById
(
"
identity
-
popup
-
security
-
menulist
-
tempitem
"
)
)
;
}
get
_identityPopupSecurityEVContentOwner
(
)
{
delete
this
.
_identityPopupSecurityEVContentOwner
;
return
(
this
.
_identityPopupSecurityEVContentOwner
=
document
.
getElementById
(
"
identity
-
popup
-
security
-
ev
-
content
-
owner
"
)
)
;
}
get
_identityPopupContentOwner
(
)
{
delete
this
.
_identityPopupContentOwner
;
return
(
this
.
_identityPopupContentOwner
=
document
.
getElementById
(
"
identity
-
popup
-
content
-
owner
"
)
)
;
}
get
_identityPopupContentSupp
(
)
{
delete
this
.
_identityPopupContentSupp
;
return
(
this
.
_identityPopupContentSupp
=
document
.
getElementById
(
"
identity
-
popup
-
content
-
supplemental
"
)
)
;
}
get
_identityPopupContentVerif
(
)
{
delete
this
.
_identityPopupContentVerif
;
return
(
this
.
_identityPopupContentVerif
=
document
.
getElementById
(
"
identity
-
popup
-
content
-
verifier
"
)
)
;
}
get
_identityPopupCustomRootLearnMore
(
)
{
delete
this
.
_identityPopupCustomRootLearnMore
;
return
(
this
.
_identityPopupCustomRootLearnMore
=
document
.
getElementById
(
"
identity
-
popup
-
custom
-
root
-
learn
-
more
"
)
)
;
}
get
_identityPopupMixedContentLearnMore
(
)
{
delete
this
.
_identityPopupMixedContentLearnMore
;
return
(
this
.
_identityPopupMixedContentLearnMore
=
[
.
.
.
document
.
querySelectorAll
(
"
.
identity
-
popup
-
mcb
-
learn
-
more
"
)
]
)
;
}
get
_identityIconLabel
(
)
{
delete
this
.
_identityIconLabel
;
return
(
this
.
_identityIconLabel
=
document
.
getElementById
(
"
identity
-
icon
-
label
"
)
)
;
}
get
_overrideService
(
)
{
delete
this
.
_overrideService
;
return
(
this
.
_overrideService
=
Cc
[
"
mozilla
.
org
/
security
/
certoverride
;
1
"
]
.
getService
(
Ci
.
nsICertOverrideService
)
)
;
}
get
_identityIcon
(
)
{
delete
this
.
_identityIcon
;
return
(
this
.
_identityIcon
=
document
.
getElementById
(
"
identity
-
icon
"
)
)
;
}
get
_popupExpander
(
)
{
delete
this
.
_popupExpander
;
return
(
this
.
_popupExpander
=
document
.
getElementById
(
"
identity
-
popup
-
security
-
expander
"
)
)
;
}
get
_clearSiteDataFooter
(
)
{
delete
this
.
_clearSiteDataFooter
;
return
(
this
.
_clearSiteDataFooter
=
document
.
getElementById
(
"
identity
-
popup
-
clear
-
sitedata
-
footer
"
)
)
;
}
get
_insecureConnectionIconEnabled
(
)
{
delete
this
.
_insecureConnectionIconEnabled
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
_insecureConnectionIconEnabled
"
"
security
.
insecure_connection_icon
.
enabled
"
)
;
return
this
.
_insecureConnectionIconEnabled
;
}
get
_insecureConnectionIconPBModeEnabled
(
)
{
delete
this
.
_insecureConnectionIconPBModeEnabled
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
_insecureConnectionIconPBModeEnabled
"
"
security
.
insecure_connection_icon
.
pbmode
.
enabled
"
)
;
return
this
.
_insecureConnectionIconPBModeEnabled
;
}
get
_insecureConnectionTextEnabled
(
)
{
delete
this
.
_insecureConnectionTextEnabled
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
_insecureConnectionTextEnabled
"
"
security
.
insecure_connection_text
.
enabled
"
)
;
return
this
.
_insecureConnectionTextEnabled
;
}
get
_insecureConnectionTextPBModeEnabled
(
)
{
delete
this
.
_insecureConnectionTextPBModeEnabled
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
_insecureConnectionTextPBModeEnabled
"
"
security
.
insecure_connection_text
.
pbmode
.
enabled
"
)
;
return
this
.
_insecureConnectionTextPBModeEnabled
;
}
get
_protectionsPanelEnabled
(
)
{
delete
this
.
_protectionsPanelEnabled
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
_protectionsPanelEnabled
"
"
browser
.
protections_panel
.
enabled
"
false
)
;
return
this
.
_protectionsPanelEnabled
;
}
get
_httpsOnlyModeEnabled
(
)
{
delete
this
.
_httpsOnlyModeEnabled
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
_httpsOnlyModeEnabled
"
"
dom
.
security
.
https_only_mode
"
)
;
return
this
.
_httpsOnlyModeEnabled
;
}
get
_httpsOnlyModeEnabledPBM
(
)
{
delete
this
.
_httpsOnlyModeEnabledPBM
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
_httpsOnlyModeEnabledPBM
"
"
dom
.
security
.
https_only_mode_pbm
"
)
;
return
this
.
_httpsOnlyModeEnabledPBM
;
}
get
_useGrayLockIcon
(
)
{
delete
this
.
_useGrayLockIcon
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
_useGrayLockIcon
"
"
security
.
secure_connection_icon_color_gray
"
false
)
;
return
this
.
_useGrayLockIcon
;
}
async
clearSiteData
(
event
)
{
if
(
!
this
.
_uriHasHost
)
{
return
;
}
let
host
=
this
.
_uri
.
host
;
let
hidden
=
new
Promise
(
c
=
>
{
this
.
_identityPopup
.
addEventListener
(
"
popuphidden
"
c
{
once
:
true
}
)
;
}
)
;
PanelMultiView
.
hidePopup
(
this
.
_identityPopup
)
;
await
hidden
;
let
baseDomain
=
SiteDataManager
.
getBaseDomainFromHost
(
host
)
;
if
(
SiteDataManager
.
promptSiteDataRemoval
(
window
null
baseDomain
)
)
{
let
siteData
=
await
SiteDataManager
.
getSites
(
baseDomain
)
;
if
(
siteData
&
&
siteData
.
length
)
{
let
hosts
=
siteData
.
map
(
site
=
>
site
.
host
)
;
SiteDataManager
.
remove
(
hosts
)
;
}
}
event
.
stopPropagation
(
)
;
}
handleMoreInfoClick
(
event
)
{
displaySecurityInfo
(
)
;
event
.
stopPropagation
(
)
;
PanelMultiView
.
hidePopup
(
this
.
_identityPopup
)
;
}
showSecuritySubView
(
)
{
this
.
_identityPopupMultiView
.
showSubView
(
"
identity
-
popup
-
securityView
"
this
.
_popupExpander
)
;
Services
.
focus
.
clearFocus
(
window
)
;
}
disableMixedContentProtection
(
)
{
const
kMIXED_CONTENT_UNBLOCK_EVENT
=
2
;
let
histogram
=
Services
.
telemetry
.
getHistogramById
(
"
MIXED_CONTENT_UNBLOCK_COUNTER
"
)
;
histogram
.
add
(
kMIXED_CONTENT_UNBLOCK_EVENT
)
;
BrowserReloadWithFlags
(
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_ALLOW_MIXED_CONTENT
)
;
if
(
this
.
_popupInitialized
)
{
PanelMultiView
.
hidePopup
(
this
.
_identityPopup
)
;
}
}
enableMixedContentProtection
(
)
{
gBrowser
.
selectedBrowser
.
sendMessageToActor
(
"
MixedContent
:
ReenableProtection
"
{
}
"
BrowserTab
"
)
;
BrowserReload
(
)
;
if
(
this
.
_popupInitialized
)
{
PanelMultiView
.
hidePopup
(
this
.
_identityPopup
)
;
}
}
removeCertException
(
)
{
if
(
!
this
.
_uriHasHost
)
{
Cu
.
reportError
(
"
Trying
to
revoke
a
cert
exception
on
a
URI
without
a
host
?
"
)
;
return
;
}
let
host
=
this
.
_uri
.
host
;
let
port
=
this
.
_uri
.
port
>
0
?
this
.
_uri
.
port
:
443
;
this
.
_overrideService
.
clearValidityOverride
(
host
port
)
;
BrowserReloadSkipCache
(
)
;
if
(
this
.
_popupInitialized
)
{
PanelMultiView
.
hidePopup
(
this
.
_identityPopup
)
;
}
}
_getHttpsOnlyPermission
(
)
{
const
{
state
}
=
SitePermissions
.
getForPrincipal
(
gBrowser
.
contentPrincipal
"
https
-
only
-
load
-
insecure
"
)
;
switch
(
state
)
{
case
Ci
.
nsIHttpsOnlyModePermission
.
LOAD_INSECURE_ALLOW_SESSION
:
return
2
;
case
Ci
.
nsIHttpsOnlyModePermission
.
LOAD_INSECURE_ALLOW
:
return
1
;
default
:
return
0
;
}
}
changeHttpsOnlyPermission
(
)
{
const
oldValue
=
this
.
_getHttpsOnlyPermission
(
)
;
let
newValue
=
parseInt
(
this
.
_identityPopupHttpsOnlyModeMenuList
.
selectedItem
.
value
10
)
;
if
(
newValue
=
=
=
oldValue
)
{
return
;
}
if
(
newValue
=
=
=
1
&
&
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
{
newValue
=
2
;
}
let
principal
=
gBrowser
.
contentPrincipal
;
let
newURI
;
if
(
this
.
_isAboutHttpsOnlyErrorPage
)
{
newURI
=
gBrowser
.
currentURI
.
mutate
(
)
.
setScheme
(
"
http
"
)
.
finalize
(
)
;
principal
=
Services
.
scriptSecurityManager
.
createContentPrincipal
(
newURI
gBrowser
.
contentPrincipal
.
originAttributes
)
;
}
if
(
newValue
=
=
=
0
)
{
SitePermissions
.
removeFromPrincipal
(
principal
"
https
-
only
-
load
-
insecure
"
)
;
}
else
if
(
newValue
=
=
=
1
)
{
SitePermissions
.
setForPrincipal
(
principal
"
https
-
only
-
load
-
insecure
"
Ci
.
nsIHttpsOnlyModePermission
.
LOAD_INSECURE_ALLOW
SitePermissions
.
SCOPE_PERSISTENT
)
;
}
else
{
SitePermissions
.
setForPrincipal
(
principal
"
https
-
only
-
load
-
insecure
"
Ci
.
nsIHttpsOnlyModePermission
.
LOAD_INSECURE_ALLOW_SESSION
SitePermissions
.
SCOPE_SESSION
)
;
}
if
(
this
.
_isAboutHttpsOnlyErrorPage
)
{
gBrowser
.
loadURI
(
newURI
.
spec
{
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
loadFlags
:
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_REPLACE_HISTORY
}
)
;
if
(
this
.
_popupInitialized
)
{
PanelMultiView
.
hidePopup
(
this
.
_identityPopup
)
;
}
return
;
}
if
(
newValue
+
oldValue
!
=
=
3
)
{
BrowserReloadSkipCache
(
)
;
if
(
this
.
_popupInitialized
)
{
PanelMultiView
.
hidePopup
(
this
.
_identityPopup
)
;
}
return
;
}
this
.
refreshIdentityPopup
(
)
;
}
getIdentityData
(
)
{
var
result
=
{
}
;
var
cert
=
this
.
_secInfo
.
serverCert
;
result
.
subjectOrg
=
cert
.
organization
;
if
(
cert
.
subjectName
)
{
result
.
subjectNameFields
=
{
}
;
cert
.
subjectName
.
split
(
"
"
)
.
forEach
(
function
(
v
)
{
var
field
=
v
.
split
(
"
=
"
)
;
this
[
field
[
0
]
]
=
field
[
1
]
;
}
result
.
subjectNameFields
)
;
result
.
city
=
result
.
subjectNameFields
.
L
;
result
.
state
=
result
.
subjectNameFields
.
ST
;
result
.
country
=
result
.
subjectNameFields
.
C
;
}
result
.
caOrg
=
cert
.
issuerOrganization
|
|
cert
.
issuerCommonName
;
result
.
cert
=
cert
;
return
result
;
}
updateIdentity
(
state
uri
)
{
let
shouldHidePopup
=
this
.
_uri
&
&
this
.
_uri
.
spec
!
=
uri
.
spec
;
this
.
_state
=
state
;
this
.
setURI
(
uri
)
;
this
.
_secInfo
=
gBrowser
.
securityUI
.
secInfo
;
this
.
_isSecureContext
=
gBrowser
.
securityUI
.
isSecureContext
;
this
.
refreshIdentityBlock
(
)
;
if
(
shouldHidePopup
)
{
this
.
hidePopup
(
)
;
gPermissionPanel
.
hidePopup
(
)
;
}
}
getEffectiveHost
(
)
{
if
(
!
this
.
_IDNService
)
{
this
.
_IDNService
=
Cc
[
"
mozilla
.
org
/
network
/
idn
-
service
;
1
"
]
.
getService
(
Ci
.
nsIIDNService
)
;
}
try
{
return
this
.
_IDNService
.
convertToDisplayIDN
(
this
.
_uri
.
host
{
}
)
;
}
catch
(
e
)
{
return
this
.
_uri
.
host
;
}
}
getHostForDisplay
(
)
{
let
host
=
"
"
;
try
{
host
=
this
.
getEffectiveHost
(
)
;
}
catch
(
e
)
{
}
if
(
this
.
_uri
.
schemeIs
(
"
about
"
)
)
{
host
=
"
about
:
"
+
this
.
_uri
.
filePath
;
}
if
(
this
.
_uri
.
schemeIs
(
"
chrome
"
)
)
{
host
=
this
.
_uri
.
spec
;
}
let
readerStrippedURI
=
ReaderMode
.
getOriginalUrlObjectForDisplay
(
this
.
_uri
.
displaySpec
)
;
if
(
readerStrippedURI
)
{
host
=
readerStrippedURI
.
host
;
}
if
(
this
.
_pageExtensionPolicy
)
{
host
=
this
.
_pageExtensionPolicy
.
name
;
}
if
(
!
host
)
{
host
=
this
.
_uri
.
specIgnoringRef
;
}
return
host
;
}
get
pointerlockFsWarningClassName
(
)
{
if
(
this
.
_uriHasHost
&
&
this
.
_isSecureConnection
)
{
return
"
verifiedDomain
"
;
}
return
"
unknownIdentity
"
;
}
_hasCustomRoot
(
)
{
let
issuerCert
=
null
;
issuerCert
=
this
.
_secInfo
.
succeededCertChain
[
this
.
_secInfo
.
succeededCertChain
.
length
-
1
]
;
return
!
issuerCert
.
isBuiltInRoot
;
}
_hasInvalidPageProxyState
(
)
{
return
(
!
this
.
_uriHasHost
&
&
this
.
_uri
&
&
isBlankPageURL
(
this
.
_uri
.
spec
)
&
&
!
this
.
_uri
.
schemeIs
(
"
moz
-
extension
"
)
)
;
}
_refreshIdentityIcons
(
)
{
let
icon_label
=
"
"
;
let
tooltip
=
"
"
;
if
(
this
.
_isSecureInternalUI
)
{
this
.
_identityBox
.
className
=
"
chromeUI
"
;
let
brandBundle
=
document
.
getElementById
(
"
bundle_brand
"
)
;
icon_label
=
brandBundle
.
getString
(
"
brandShorterName
"
)
;
}
else
if
(
this
.
_pageExtensionPolicy
)
{
this
.
_identityBox
.
className
=
"
extensionPage
"
;
let
extensionName
=
this
.
_pageExtensionPolicy
.
name
;
icon_label
=
gNavigatorBundle
.
getFormattedString
(
"
identity
.
extension
.
label
"
[
extensionName
]
)
;
}
else
if
(
this
.
_uriHasHost
&
&
this
.
_isSecureConnection
)
{
this
.
_identityBox
.
className
=
"
verifiedDomain
"
;
if
(
this
.
_isMixedActiveContentBlocked
)
{
this
.
_identityBox
.
classList
.
add
(
"
mixedActiveBlocked
"
)
;
}
if
(
!
this
.
_isCertUserOverridden
)
{
tooltip
=
gNavigatorBundle
.
getFormattedString
(
"
identity
.
identified
.
verifier
"
[
this
.
getIdentityData
(
)
.
caOrg
]
)
;
}
}
else
if
(
this
.
_isBrokenConnection
)
{
this
.
_identityBox
.
className
=
"
unknownIdentity
"
;
if
(
this
.
_isMixedActiveContentLoaded
)
{
this
.
_identityBox
.
classList
.
add
(
"
mixedActiveContent
"
)
;
}
else
if
(
this
.
_isMixedActiveContentBlocked
)
{
this
.
_identityBox
.
classList
.
add
(
"
mixedDisplayContentLoadedActiveBlocked
"
)
;
}
else
if
(
this
.
_isMixedPassiveContentLoaded
)
{
this
.
_identityBox
.
classList
.
add
(
"
mixedDisplayContent
"
)
;
}
else
{
this
.
_identityBox
.
classList
.
add
(
"
weakCipher
"
)
;
}
}
else
if
(
this
.
_isAboutCertErrorPage
)
{
this
.
_identityBox
.
className
=
"
certErrorPage
"
;
}
else
if
(
this
.
_isAboutHttpsOnlyErrorPage
)
{
this
.
_identityBox
.
className
=
"
httpsOnlyErrorPage
"
;
}
else
if
(
this
.
_isAboutNetErrorPage
|
|
this
.
_isAboutBlockedPage
)
{
this
.
_identityBox
.
className
=
"
unknownIdentity
"
;
}
else
if
(
this
.
_isPotentiallyTrustworthy
)
{
this
.
_identityBox
.
className
=
"
localResource
"
;
}
else
{
let
warnOnInsecure
=
this
.
_insecureConnectionIconEnabled
|
|
(
this
.
_insecureConnectionIconPBModeEnabled
&
&
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
;
let
className
=
warnOnInsecure
?
"
notSecure
"
:
"
unknownIdentity
"
;
this
.
_identityBox
.
className
=
className
;
tooltip
=
warnOnInsecure
?
gNavigatorBundle
.
getString
(
"
identity
.
notSecure
.
tooltip
"
)
:
"
"
;
let
warnTextOnInsecure
=
this
.
_insecureConnectionTextEnabled
|
|
(
this
.
_insecureConnectionTextPBModeEnabled
&
&
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
;
if
(
warnTextOnInsecure
)
{
icon_label
=
gNavigatorBundle
.
getString
(
"
identity
.
notSecure
.
label
"
)
;
this
.
_identityBox
.
classList
.
add
(
"
notSecureText
"
)
;
}
}
if
(
this
.
_isCertUserOverridden
)
{
this
.
_identityBox
.
classList
.
add
(
"
certUserOverridden
"
)
;
tooltip
=
gNavigatorBundle
.
getString
(
"
identity
.
identified
.
verified_by_you
"
)
;
}
this
.
_updateAttribute
(
this
.
_identityIcon
"
lock
-
icon
-
gray
"
this
.
_useGrayLockIcon
)
;
this
.
_identityIcon
.
setAttribute
(
"
tooltiptext
"
tooltip
)
;
if
(
this
.
_pageExtensionPolicy
)
{
let
extensionName
=
this
.
_pageExtensionPolicy
.
name
;
this
.
_identityIcon
.
setAttribute
(
"
tooltiptext
"
gNavigatorBundle
.
getFormattedString
(
"
identity
.
extension
.
tooltip
"
[
extensionName
]
)
)
;
}
this
.
_identityIconLabel
.
setAttribute
(
"
tooltiptext
"
tooltip
)
;
this
.
_identityIconLabel
.
setAttribute
(
"
value
"
icon_label
)
;
this
.
_identityIconLabel
.
collapsed
=
!
icon_label
;
}
refreshIdentityBlock
(
)
{
if
(
!
this
.
_identityBox
)
{
return
;
}
this
.
_refreshIdentityIcons
(
)
;
if
(
this
.
_hasInvalidPageProxyState
(
)
)
{
gPermissionPanel
.
hidePermissionIcons
(
)
;
}
else
{
gPermissionPanel
.
refreshPermissionIcons
(
)
;
}
gProtectionsHandler
.
_trackingProtectionIconContainer
.
classList
.
toggle
(
"
chromeUI
"
this
.
_isSecureInternalUI
)
;
}
refreshIdentityPopup
(
)
{
this
.
_clearSiteDataFooter
.
hidden
=
true
;
if
(
this
.
_uriHasHost
)
{
SiteDataManager
.
hasSiteData
(
this
.
_uri
.
asciiHost
)
.
then
(
hasData
=
>
{
this
.
_clearSiteDataFooter
.
hidden
=
!
hasData
;
}
)
;
}
let
baseURL
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
;
this
.
_identityPopupMixedContentLearnMore
.
forEach
(
e
=
>
e
.
setAttribute
(
"
href
"
baseURL
+
"
mixed
-
content
"
)
)
;
this
.
_identityPopupCustomRootLearnMore
.
setAttribute
(
"
href
"
baseURL
+
"
enterprise
-
roots
"
)
;
this
.
_popupExpander
.
tooltipText
=
gNavigatorBundle
.
getString
(
"
identity
.
showDetails
.
tooltip
"
)
;
let
customRoot
=
false
;
let
connection
=
"
not
-
secure
"
;
if
(
this
.
_isSecureInternalUI
)
{
connection
=
"
chrome
"
;
}
else
if
(
this
.
_pageExtensionPolicy
)
{
connection
=
"
extension
"
;
}
else
if
(
this
.
_isURILoadedFromFile
)
{
connection
=
"
file
"
;
}
else
if
(
this
.
_isEV
)
{
connection
=
"
secure
-
ev
"
;
}
else
if
(
this
.
_isCertUserOverridden
)
{
connection
=
"
secure
-
cert
-
user
-
overridden
"
;
}
else
if
(
this
.
_isSecureConnection
)
{
connection
=
"
secure
"
;
customRoot
=
this
.
_hasCustomRoot
(
)
;
}
else
if
(
this
.
_isAboutCertErrorPage
)
{
connection
=
"
cert
-
error
-
page
"
;
}
else
if
(
this
.
_isAboutHttpsOnlyErrorPage
)
{
connection
=
"
https
-
only
-
error
-
page
"
;
}
else
if
(
this
.
_isAboutNetErrorPage
|
|
this
.
_isAboutBlockedPage
)
{
connection
=
"
not
-
secure
"
;
}
else
if
(
this
.
_isPotentiallyTrustworthy
)
{
connection
=
"
file
"
;
}
let
mixedcontent
=
[
]
;
if
(
this
.
_isMixedPassiveContentLoaded
)
{
mixedcontent
.
push
(
"
passive
-
loaded
"
)
;
}
if
(
this
.
_isMixedActiveContentLoaded
)
{
mixedcontent
.
push
(
"
active
-
loaded
"
)
;
}
else
if
(
this
.
_isMixedActiveContentBlocked
)
{
mixedcontent
.
push
(
"
active
-
blocked
"
)
;
}
mixedcontent
=
mixedcontent
.
join
(
"
"
)
;
let
ciphers
=
"
"
;
if
(
this
.
_isBrokenConnection
&
&
!
this
.
_isMixedActiveContentLoaded
&
&
!
this
.
_isMixedPassiveContentLoaded
)
{
ciphers
=
"
weak
"
;
}
this
.
_updateAttribute
(
this
.
_identityPopup
"
lock
-
icon
-
gray
"
this
.
_useGrayLockIcon
)
;
const
privateBrowsingWindow
=
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
;
let
httpsOnlyStatus
=
"
"
;
if
(
this
.
_httpsOnlyModeEnabled
|
|
(
privateBrowsingWindow
&
&
this
.
_httpsOnlyModeEnabledPBM
)
)
{
let
value
=
this
.
_getHttpsOnlyPermission
(
)
;
if
(
privateBrowsingWindow
)
{
if
(
value
=
=
=
2
)
{
value
=
1
;
}
this
.
_identityPopupHttpsOnlyModeMenuListTempItem
.
style
.
display
=
"
none
"
;
}
else
{
this
.
_identityPopupHttpsOnlyModeMenuListTempItem
.
style
.
display
=
"
"
;
}
this
.
_identityPopupHttpsOnlyModeMenuList
.
value
=
value
;
if
(
value
>
0
)
{
httpsOnlyStatus
=
"
exception
"
;
}
else
if
(
this
.
_isAboutHttpsOnlyErrorPage
)
{
httpsOnlyStatus
=
"
failed
-
top
"
;
}
else
if
(
this
.
_isContentHttpsOnlyModeUpgradeFailed
)
{
httpsOnlyStatus
=
"
failed
-
sub
"
;
}
else
if
(
this
.
_isContentHttpsOnlyModeUpgraded
)
{
httpsOnlyStatus
=
"
upgraded
"
;
}
}
let
elementIDs
=
[
"
identity
-
popup
"
"
identity
-
popup
-
securityView
-
body
"
]
;
for
(
let
id
of
elementIDs
)
{
let
element
=
document
.
getElementById
(
id
)
;
this
.
_updateAttribute
(
element
"
connection
"
connection
)
;
this
.
_updateAttribute
(
element
"
ciphers
"
ciphers
)
;
this
.
_updateAttribute
(
element
"
mixedcontent
"
mixedcontent
)
;
this
.
_updateAttribute
(
element
"
isbroken
"
this
.
_isBrokenConnection
)
;
this
.
_updateAttribute
(
element
"
customroot
"
customRoot
)
;
this
.
_updateAttribute
(
element
"
httpsonlystatus
"
httpsOnlyStatus
)
;
}
let
supplemental
=
"
"
;
let
verifier
=
"
"
;
let
host
=
this
.
getHostForDisplay
(
)
;
let
owner
=
"
"
;
if
(
this
.
_isSecureConnection
|
|
this
.
_isCertUserOverridden
)
{
verifier
=
this
.
_identityIconLabel
.
tooltipText
;
}
if
(
this
.
_isEV
)
{
let
iData
=
this
.
getIdentityData
(
)
;
owner
=
iData
.
subjectOrg
;
verifier
=
this
.
_identityIconLabel
.
tooltipText
;
if
(
iData
.
city
)
{
supplemental
+
=
iData
.
city
+
"
\
n
"
;
}
if
(
iData
.
state
&
&
iData
.
country
)
{
supplemental
+
=
gNavigatorBundle
.
getFormattedString
(
"
identity
.
identified
.
state_and_country
"
[
iData
.
state
iData
.
country
]
)
;
}
else
if
(
iData
.
state
)
{
supplemental
+
=
iData
.
state
;
}
else
if
(
iData
.
country
)
{
supplemental
+
=
iData
.
country
;
}
}
this
.
_identityPopupMainViewHeaderLabel
.
textContent
=
gNavigatorBundle
.
getFormattedString
(
"
identity
.
headerMainWithHost
"
[
host
]
)
;
this
.
_identityPopupSecurityView
.
setAttribute
(
"
title
"
gNavigatorBundle
.
getFormattedString
(
"
identity
.
headerSecurityWithHost
"
[
host
]
)
)
;
this
.
_identityPopupSecurityEVContentOwner
.
textContent
=
gNavigatorBundle
.
getFormattedString
(
"
identity
.
ev
.
contentOwner2
"
[
owner
]
)
;
this
.
_identityPopupContentOwner
.
textContent
=
owner
;
this
.
_identityPopupContentSupp
.
textContent
=
supplemental
;
this
.
_identityPopupContentVerif
.
textContent
=
verifier
;
}
setURI
(
uri
)
{
if
(
uri
.
schemeIs
(
"
view
-
source
"
)
)
{
uri
=
Services
.
io
.
newURI
(
uri
.
spec
.
replace
(
/
^
view
-
source
:
/
i
"
"
)
)
;
}
this
.
_uri
=
uri
;
try
{
this
.
_uriHasHost
=
!
!
this
.
_uri
.
host
;
}
catch
(
ex
)
{
this
.
_uriHasHost
=
false
;
}
this
.
_isSecureInternalUI
=
uri
.
schemeIs
(
"
about
"
)
&
&
this
.
_secureInternalPages
.
test
(
uri
.
pathQueryRef
)
;
this
.
_pageExtensionPolicy
=
WebExtensionPolicy
.
getByURI
(
uri
)
;
this
.
_isURILoadedFromFile
=
false
;
let
chanOptions
=
{
uri
:
this
.
_uri
loadUsingSystemPrincipal
:
true
}
;
let
resolvedURI
;
try
{
resolvedURI
=
NetUtil
.
newChannel
(
chanOptions
)
.
URI
;
if
(
resolvedURI
.
schemeIs
(
"
jar
"
)
)
{
resolvedURI
=
NetUtil
.
newURI
(
resolvedURI
.
pathQueryRef
)
;
}
this
.
_isURILoadedFromFile
=
resolvedURI
.
schemeIs
(
"
file
"
)
;
}
catch
(
ex
)
{
}
}
handleIdentityButtonEvent
(
event
)
{
event
.
stopPropagation
(
)
;
if
(
(
event
.
type
=
=
"
click
"
&
&
event
.
button
!
=
0
)
|
|
(
event
.
type
=
=
"
keypress
"
&
&
event
.
charCode
!
=
KeyEvent
.
DOM_VK_SPACE
&
&
event
.
keyCode
!
=
KeyEvent
.
DOM_VK_RETURN
)
)
{
return
;
}
if
(
gURLBar
.
getAttribute
(
"
pageproxystate
"
)
!
=
"
valid
"
)
{
return
;
}
this
.
_openPopup
(
event
)
;
}
_openPopup
(
event
)
{
this
.
_initializePopup
(
)
;
this
.
refreshIdentityPopup
(
)
;
this
.
_identityIconBox
.
setAttribute
(
"
open
"
"
true
"
)
;
let
openPanels
=
Array
.
from
(
document
.
querySelectorAll
(
"
panel
[
openpanel
]
"
)
)
;
for
(
let
panel
of
openPanels
)
{
PanelMultiView
.
hidePopup
(
panel
)
;
}
PanelMultiView
.
openPopup
(
this
.
_identityPopup
this
.
_identityIconBox
{
position
:
"
bottomcenter
topleft
"
triggerEvent
:
event
}
)
.
catch
(
Cu
.
reportError
)
;
}
onPopupShown
(
event
)
{
if
(
event
.
target
=
=
this
.
_identityPopup
)
{
PopupNotifications
.
suppressWhileOpen
(
this
.
_identityPopup
)
;
window
.
addEventListener
(
"
focus
"
this
true
)
;
}
}
onPopupHidden
(
event
)
{
if
(
event
.
target
=
=
this
.
_identityPopup
)
{
window
.
removeEventListener
(
"
focus
"
this
true
)
;
this
.
_identityIconBox
.
removeAttribute
(
"
open
"
)
;
}
}
handleEvent
(
event
)
{
let
elem
=
document
.
activeElement
;
let
position
=
elem
.
compareDocumentPosition
(
this
.
_identityPopup
)
;
if
(
!
(
position
&
(
Node
.
DOCUMENT_POSITION_CONTAINS
|
Node
.
DOCUMENT_POSITION_CONTAINED_BY
)
)
&
&
!
this
.
_identityPopup
.
hasAttribute
(
"
noautohide
"
)
)
{
PanelMultiView
.
hidePopup
(
this
.
_identityPopup
)
;
}
}
observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
"
perm
-
changed
"
:
{
if
(
!
subject
)
{
return
;
}
let
{
type
}
=
subject
.
QueryInterface
(
Ci
.
nsIPermission
)
;
if
(
SitePermissions
.
isSitePermission
(
type
)
)
{
this
.
refreshIdentityBlock
(
)
;
}
break
;
}
}
}
onDragStart
(
event
)
{
const
TEXT_SIZE
=
14
;
const
IMAGE_SIZE
=
16
;
const
SPACING
=
5
;
if
(
gURLBar
.
getAttribute
(
"
pageproxystate
"
)
!
=
"
valid
"
)
{
return
;
}
let
value
=
gBrowser
.
currentURI
.
displaySpec
;
let
urlString
=
value
+
"
\
n
"
+
gBrowser
.
contentTitle
;
let
htmlString
=
'
<
a
href
=
"
'
+
value
+
'
"
>
'
+
value
+
"
<
/
a
>
"
;
let
windowUtils
=
window
.
windowUtils
;
let
scale
=
windowUtils
.
screenPixelsPerCSSPixel
/
windowUtils
.
fullZoom
;
let
canvas
=
document
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
"
canvas
"
)
;
canvas
.
width
=
550
*
scale
;
let
ctx
=
canvas
.
getContext
(
"
2d
"
)
;
ctx
.
font
=
{
TEXT_SIZE
*
scale
}
px
sans
-
serif
;
let
tabIcon
=
gBrowser
.
selectedTab
.
iconImage
;
let
image
=
new
Image
(
)
;
image
.
src
=
tabIcon
.
src
;
let
textWidth
=
ctx
.
measureText
(
value
)
.
width
/
scale
;
let
textHeight
=
parseInt
(
ctx
.
font
10
)
/
scale
;
let
imageHorizontalOffset
imageVerticalOffset
;
imageHorizontalOffset
=
imageVerticalOffset
=
SPACING
;
let
textHorizontalOffset
=
image
.
width
?
IMAGE_SIZE
+
SPACING
*
2
:
SPACING
;
let
textVerticalOffset
=
textHeight
+
SPACING
-
1
;
let
backgroundColor
=
"
white
"
;
let
textColor
=
"
black
"
;
let
totalWidth
=
image
.
width
?
textWidth
+
IMAGE_SIZE
+
3
*
SPACING
:
textWidth
+
2
*
SPACING
;
let
totalHeight
=
image
.
width
?
IMAGE_SIZE
+
2
*
SPACING
:
textHeight
+
2
*
SPACING
;
ctx
.
fillStyle
=
backgroundColor
;
ctx
.
fillRect
(
0
0
totalWidth
*
scale
totalHeight
*
scale
)
;
ctx
.
fillStyle
=
textColor
;
ctx
.
fillText
(
{
value
}
textHorizontalOffset
*
scale
textVerticalOffset
*
scale
)
;
try
{
ctx
.
drawImage
(
image
imageHorizontalOffset
*
scale
imageVerticalOffset
*
scale
IMAGE_SIZE
*
scale
IMAGE_SIZE
*
scale
)
;
}
catch
(
e
)
{
}
let
dt
=
event
.
dataTransfer
;
dt
.
setData
(
"
text
/
x
-
moz
-
url
"
urlString
)
;
dt
.
setData
(
"
text
/
uri
-
list
"
value
)
;
dt
.
setData
(
"
text
/
plain
"
value
)
;
dt
.
setData
(
"
text
/
html
"
htmlString
)
;
dt
.
setDragImage
(
canvas
16
16
)
;
gURLBar
.
view
.
close
(
)
;
}
_updateAttribute
(
elem
attr
value
)
{
if
(
value
)
{
elem
.
setAttribute
(
attr
value
)
;
}
else
{
elem
.
removeAttribute
(
attr
)
;
}
}
}
;
