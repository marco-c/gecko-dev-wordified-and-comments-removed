var
gBrowserThumbnails
=
{
PREF_DISK_CACHE_SSL
:
"
browser
.
cache
.
disk_cache_ssl
"
PREF_ACTIVITY_STREAM_ENABLED
:
"
browser
.
newtabpage
.
activity
-
stream
.
enabled
"
_activityStreamEnabled
:
null
_captureDelayMS
:
1000
_sslDiskCacheEnabled
:
null
_timeouts
:
null
_topSiteURLsRefreshTimer
:
null
_tabEvents
:
[
"
TabClose
"
"
TabSelect
"
]
init
:
function
Thumbnails_init
(
)
{
PageThumbs
.
addExpirationFilter
(
this
)
;
gBrowser
.
addTabsProgressListener
(
this
)
;
Services
.
prefs
.
addObserver
(
this
.
PREF_DISK_CACHE_SSL
this
)
;
Services
.
prefs
.
addObserver
(
this
.
PREF_ACTIVITY_STREAM_ENABLED
this
)
;
this
.
_sslDiskCacheEnabled
=
Services
.
prefs
.
getBoolPref
(
this
.
PREF_DISK_CACHE_SSL
)
;
this
.
_activityStreamEnabled
=
Services
.
prefs
.
getBoolPref
(
this
.
PREF_ACTIVITY_STREAM_ENABLED
)
;
this
.
_tabEvents
.
forEach
(
function
(
aEvent
)
{
gBrowser
.
tabContainer
.
addEventListener
(
aEvent
this
)
;
}
this
)
;
this
.
_timeouts
=
new
WeakMap
(
)
;
}
uninit
:
function
Thumbnails_uninit
(
)
{
PageThumbs
.
removeExpirationFilter
(
this
)
;
gBrowser
.
removeTabsProgressListener
(
this
)
;
Services
.
prefs
.
removeObserver
(
this
.
PREF_DISK_CACHE_SSL
this
)
;
Services
.
prefs
.
removeObserver
(
this
.
PREF_ACTIVITY_STREAM_ENABLED
this
)
;
if
(
this
.
_topSiteURLsRefreshTimer
)
{
this
.
_topSiteURLsRefreshTimer
.
cancel
(
)
;
this
.
_topSiteURLsRefreshTimer
=
null
;
}
this
.
_tabEvents
.
forEach
(
function
(
aEvent
)
{
gBrowser
.
tabContainer
.
removeEventListener
(
aEvent
this
)
;
}
this
)
;
}
handleEvent
:
function
Thumbnails_handleEvent
(
aEvent
)
{
switch
(
aEvent
.
type
)
{
case
"
scroll
"
:
let
browser
=
aEvent
.
currentTarget
;
if
(
this
.
_timeouts
.
has
(
browser
)
)
this
.
_delayedCapture
(
browser
)
;
break
;
case
"
TabSelect
"
:
this
.
_delayedCapture
(
aEvent
.
target
.
linkedBrowser
)
;
break
;
case
"
TabClose
"
:
{
this
.
_cancelDelayedCapture
(
aEvent
.
target
.
linkedBrowser
)
;
break
;
}
}
}
observe
:
function
Thumbnails_observe
(
subject
topic
data
)
{
switch
(
data
)
{
case
this
.
PREF_DISK_CACHE_SSL
:
this
.
_sslDiskCacheEnabled
=
Services
.
prefs
.
getBoolPref
(
this
.
PREF_DISK_CACHE_SSL
)
;
break
;
case
this
.
PREF_ACTIVITY_STREAM_ENABLED
:
this
.
_activityStreamEnabled
=
Services
.
prefs
.
getBoolPref
(
this
.
PREF_ACTIVITY_STREAM_ENABLED
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
_topSiteURLs
"
getTopSiteURLs
)
;
break
;
}
}
clearTopSiteURLCache
:
function
Thumbnails_clearTopSiteURLCache
(
)
{
if
(
this
.
_topSiteURLsRefreshTimer
)
{
this
.
_topSiteURLsRefreshTimer
.
cancel
(
)
;
this
.
_topSiteURLsRefreshTimer
=
null
;
}
delete
this
.
_topSiteURLs
;
XPCOMUtils
.
defineLazyGetter
(
this
"
_topSiteURLs
"
getTopSiteURLs
)
;
}
notify
:
function
Thumbnails_notify
(
timer
)
{
gBrowserThumbnails
.
_topSiteURLsRefreshTimer
=
null
;
gBrowserThumbnails
.
clearTopSiteURLCache
(
)
;
}
async
filterForThumbnailExpiration
(
aCallback
)
{
const
topSites
=
await
this
.
_topSiteURLs
;
aCallback
(
topSites
)
;
}
onStateChange
:
function
Thumbnails_onStateChange
(
aBrowser
aWebProgress
aRequest
aStateFlags
aStatus
)
{
if
(
aStateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_STOP
&
&
aStateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_IS_NETWORK
)
this
.
_delayedCapture
(
aBrowser
)
;
}
async
_capture
(
aBrowser
)
{
const
topSites
=
await
this
.
_topSiteURLs
;
if
(
!
aBrowser
.
currentURI
|
|
topSites
.
indexOf
(
aBrowser
.
currentURI
.
spec
)
=
=
-
1
)
return
;
this
.
_shouldCapture
(
aBrowser
function
(
aResult
)
{
if
(
aResult
)
{
PageThumbs
.
captureAndStoreIfStale
(
aBrowser
)
;
}
}
)
;
}
_delayedCapture
:
function
Thumbnails_delayedCapture
(
aBrowser
)
{
if
(
this
.
_timeouts
.
has
(
aBrowser
)
)
{
this
.
_cancelDelayedCallbacks
(
aBrowser
)
;
}
else
{
aBrowser
.
addEventListener
(
"
scroll
"
this
true
)
;
}
let
idleCallback
=
(
)
=
>
{
this
.
_cancelDelayedCapture
(
aBrowser
)
;
this
.
_capture
(
aBrowser
)
;
}
;
let
timeoutId
=
setTimeout
(
(
)
=
>
{
let
idleCallbackId
=
requestIdleCallback
(
idleCallback
{
timeout
:
this
.
_captureDelayMS
*
30
}
)
;
this
.
_timeouts
.
set
(
aBrowser
{
isTimeout
:
false
id
:
idleCallbackId
}
)
;
}
this
.
_captureDelayMS
)
;
this
.
_timeouts
.
set
(
aBrowser
{
isTimeout
:
true
id
:
timeoutId
}
)
;
}
_shouldCapture
:
function
Thumbnails_shouldCapture
(
aBrowser
aCallback
)
{
if
(
aBrowser
!
=
gBrowser
.
selectedBrowser
|
|
gBrowser
.
currentURI
.
schemeIs
(
"
about
"
)
)
{
aCallback
(
false
)
;
return
;
}
PageThumbs
.
shouldStoreThumbnail
(
aBrowser
aCallback
)
;
}
_cancelDelayedCapture
:
function
Thumbnails_cancelDelayedCapture
(
aBrowser
)
{
if
(
this
.
_timeouts
.
has
(
aBrowser
)
)
{
aBrowser
.
removeEventListener
(
"
scroll
"
this
)
;
this
.
_cancelDelayedCallbacks
(
aBrowser
)
;
this
.
_timeouts
.
delete
(
aBrowser
)
;
}
}
_cancelDelayedCallbacks
:
function
Thumbnails_cancelDelayedCallbacks
(
aBrowser
)
{
let
timeoutData
=
this
.
_timeouts
.
get
(
aBrowser
)
;
if
(
timeoutData
.
isTimeout
)
{
clearTimeout
(
timeoutData
.
id
)
;
}
else
{
window
.
cancelIdleCallback
(
timeoutData
.
id
)
;
}
}
}
;
async
function
getTopSiteURLs
(
)
{
let
sites
=
[
]
;
if
(
gBrowserThumbnails
.
_activityStreamEnabled
)
{
sites
=
await
NewTabUtils
.
activityStreamLinks
.
getTopSites
(
)
;
}
else
{
gBrowserThumbnails
.
_topSiteURLsRefreshTimer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
gBrowserThumbnails
.
_topSiteURLsRefreshTimer
.
initWithCallback
(
gBrowserThumbnails
60
*
1000
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
sites
=
NewTabUtils
.
links
.
getLinks
(
)
;
}
return
sites
.
reduce
(
(
urls
link
)
=
>
{
if
(
link
)
urls
.
push
(
link
.
url
)
;
return
urls
;
}
[
]
)
;
}
XPCOMUtils
.
defineLazyGetter
(
gBrowserThumbnails
"
_topSiteURLs
"
getTopSiteURLs
)
;
