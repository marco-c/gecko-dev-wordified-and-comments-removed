Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
if
(
AppConstants
.
MOZ_SERVICES_CLOUDSYNC
)
{
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
CloudSync
"
"
resource
:
/
/
gre
/
modules
/
CloudSync
.
jsm
"
)
;
}
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
fxAccounts
"
"
resource
:
/
/
gre
/
modules
/
FxAccounts
.
jsm
"
)
;
var
gSyncUI
=
{
_obs
:
[
"
weave
:
service
:
sync
:
start
"
"
weave
:
service
:
sync
:
finish
"
"
weave
:
service
:
sync
:
error
"
"
weave
:
service
:
setup
-
complete
"
"
weave
:
service
:
login
:
start
"
"
weave
:
service
:
login
:
finish
"
"
weave
:
service
:
login
:
error
"
"
weave
:
service
:
logout
:
finish
"
"
weave
:
service
:
start
-
over
"
"
weave
:
service
:
start
-
over
:
finish
"
"
weave
:
ui
:
login
:
error
"
"
weave
:
ui
:
sync
:
error
"
"
weave
:
ui
:
sync
:
finish
"
"
weave
:
ui
:
clear
-
error
"
]
_unloaded
:
false
_numActiveSyncTasks
:
0
init
:
function
(
)
{
Cu
.
import
(
"
resource
:
/
/
services
-
common
/
stringbundle
.
js
"
)
;
if
(
this
.
weaveService
.
ready
)
{
this
.
initUI
(
)
;
return
;
}
this
.
updateUI
(
)
;
Services
.
obs
.
addObserver
(
this
"
weave
:
service
:
ready
"
true
)
;
window
.
addEventListener
(
"
unload
"
function
onUnload
(
)
{
gSyncUI
.
_unloaded
=
true
;
window
.
removeEventListener
(
"
unload
"
onUnload
false
)
;
Services
.
obs
.
removeObserver
(
gSyncUI
"
weave
:
service
:
ready
"
)
;
if
(
Weave
.
Status
.
ready
)
{
gSyncUI
.
_obs
.
forEach
(
function
(
topic
)
{
Services
.
obs
.
removeObserver
(
gSyncUI
topic
)
;
}
)
;
}
}
false
)
;
}
initUI
:
function
SUI_initUI
(
)
{
if
(
gBrowser
)
{
this
.
_obs
.
push
(
"
weave
:
notification
:
added
"
)
;
}
this
.
_obs
.
forEach
(
function
(
topic
)
{
Services
.
obs
.
addObserver
(
this
topic
true
)
;
}
this
)
;
let
broadcaster
=
document
.
getElementById
(
"
sync
-
status
"
)
;
broadcaster
.
setAttribute
(
"
label
"
this
.
_stringBundle
.
GetStringFromName
(
"
syncnow
.
label
"
)
)
;
if
(
Services
.
prefs
.
getBoolPref
(
"
services
.
sync
.
syncedTabsUIRefresh
"
)
)
{
let
sidebarBroadcaster
=
document
.
getElementById
(
"
viewTabsSidebar
"
)
;
sidebarBroadcaster
.
removeAttribute
(
"
hidden
"
)
;
}
this
.
maybeMoveSyncedTabsButton
(
)
;
this
.
updateUI
(
)
;
}
_needsSetup
(
)
{
if
(
this
.
weaveService
.
fxAccountsEnabled
)
{
return
fxAccounts
.
getSignedInUser
(
)
.
then
(
user
=
>
{
return
!
(
user
&
&
user
.
verified
)
;
}
)
;
}
let
firstSync
=
"
"
;
try
{
firstSync
=
Services
.
prefs
.
getCharPref
(
"
services
.
sync
.
firstSync
"
)
;
}
catch
(
e
)
{
}
return
Promise
.
resolve
(
Weave
.
Status
.
checkSetup
(
)
=
=
Weave
.
CLIENT_NOT_CONFIGURED
|
|
firstSync
=
=
"
notReady
"
)
;
}
_needsVerification
(
)
{
if
(
this
.
weaveService
.
fxAccountsEnabled
)
{
return
fxAccounts
.
getSignedInUser
(
)
.
then
(
user
=
>
{
if
(
!
user
)
{
return
false
;
}
return
!
user
.
verified
;
}
)
;
}
return
Promise
.
resolve
(
false
)
;
}
_loginFailed
:
function
(
)
{
if
(
!
this
.
weaveService
.
ready
)
{
this
.
log
.
debug
(
"
_loginFailed
has
sync
not
ready
so
returning
false
"
)
;
return
false
;
}
this
.
log
.
debug
(
"
_loginFailed
has
sync
state
=
{
sync
}
"
{
sync
:
Weave
.
Status
.
login
}
)
;
return
Weave
.
Status
.
login
=
=
Weave
.
LOGIN_FAILED_LOGIN_REJECTED
;
}
updateUI
(
)
{
this
.
_promiseUpdateUI
(
)
.
catch
(
err
=
>
{
this
.
log
.
error
(
"
updateUI
failed
"
err
)
;
}
)
}
_promiseUpdateUI
(
)
{
return
this
.
_needsSetup
(
)
.
then
(
needsSetup
=
>
{
let
loginFailed
=
this
.
_loginFailed
(
)
;
document
.
getElementById
(
"
sync
-
reauth
-
state
"
)
.
hidden
=
true
;
document
.
getElementById
(
"
sync
-
setup
-
state
"
)
.
hidden
=
true
;
document
.
getElementById
(
"
sync
-
syncnow
-
state
"
)
.
hidden
=
true
;
if
(
CloudSync
&
&
CloudSync
.
ready
&
&
CloudSync
(
)
.
adapters
.
count
)
{
document
.
getElementById
(
"
sync
-
syncnow
-
state
"
)
.
hidden
=
false
;
}
else
if
(
loginFailed
)
{
document
.
getElementById
(
"
sync
-
reauth
-
state
"
)
.
hidden
=
false
;
}
else
if
(
needsSetup
)
{
document
.
getElementById
(
"
sync
-
setup
-
state
"
)
.
hidden
=
false
;
}
else
{
document
.
getElementById
(
"
sync
-
syncnow
-
state
"
)
.
hidden
=
false
;
}
return
this
.
_updateSyncButtonsTooltip
(
)
;
}
)
;
}
onActivityStart
(
)
{
if
(
!
gBrowser
)
return
;
this
.
log
.
debug
(
"
onActivityStart
with
numActive
"
this
.
_numActiveSyncTasks
)
;
if
(
+
+
this
.
_numActiveSyncTasks
=
=
1
)
{
let
broadcaster
=
document
.
getElementById
(
"
sync
-
status
"
)
;
broadcaster
.
setAttribute
(
"
syncstatus
"
"
active
"
)
;
broadcaster
.
setAttribute
(
"
label
"
this
.
_stringBundle
.
GetStringFromName
(
"
syncing2
.
label
"
)
)
;
broadcaster
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
this
.
updateUI
(
)
;
}
onActivityStop
(
)
{
if
(
!
gBrowser
)
return
;
this
.
log
.
debug
(
"
onActivityStop
with
numActive
"
this
.
_numActiveSyncTasks
)
;
if
(
-
-
this
.
_numActiveSyncTasks
)
{
if
(
this
.
_numActiveSyncTasks
<
0
)
{
this
.
log
.
error
(
"
mismatched
onActivityStart
/
Stop
calls
"
new
Error
(
"
active
=
"
+
this
.
_numActiveSyncTasks
)
)
;
}
return
;
}
let
broadcaster
=
document
.
getElementById
(
"
sync
-
status
"
)
;
broadcaster
.
removeAttribute
(
"
syncstatus
"
)
;
broadcaster
.
removeAttribute
(
"
disabled
"
)
;
broadcaster
.
setAttribute
(
"
label
"
this
.
_stringBundle
.
GetStringFromName
(
"
syncnow
.
label
"
)
)
;
this
.
updateUI
(
)
;
}
onLoginError
:
function
SUI_onLoginError
(
)
{
this
.
log
.
debug
(
"
onLoginError
:
login
=
{
login
}
sync
=
{
sync
}
"
Weave
.
Status
)
;
this
.
updateUI
(
)
;
}
onLogout
:
function
SUI_onLogout
(
)
{
this
.
updateUI
(
)
;
}
_getAppName
:
function
(
)
{
let
brand
=
new
StringBundle
(
"
chrome
:
/
/
branding
/
locale
/
brand
.
properties
"
)
;
return
brand
.
get
(
"
brandShortName
"
)
;
}
doSync
(
)
{
this
.
_needsSetup
(
)
.
then
(
needsSetup
=
>
{
if
(
!
needsSetup
)
{
setTimeout
(
(
)
=
>
Weave
.
Service
.
errorHandler
.
syncAndReportErrors
(
)
0
)
;
}
Services
.
obs
.
notifyObservers
(
null
"
cloudsync
:
user
-
sync
"
null
)
;
}
)
.
catch
(
err
=
>
{
this
.
log
.
error
(
"
Failed
to
force
a
sync
"
err
)
;
}
)
;
}
handleToolbarButton
(
)
{
this
.
_needsSetup
(
)
.
then
(
needsSetup
=
>
{
if
(
needsSetup
|
|
this
.
_loginFailed
(
)
)
{
this
.
openSetup
(
)
;
}
else
{
return
this
.
doSync
(
)
;
}
}
)
.
catch
(
err
=
>
{
this
.
log
.
error
(
"
Failed
to
handle
toolbar
button
command
"
err
)
;
}
)
;
}
openSetup
:
function
SUI_openSetup
(
wizardType
entryPoint
=
"
syncbutton
"
)
{
if
(
this
.
weaveService
.
fxAccountsEnabled
)
{
if
(
UITour
.
tourBrowsersByWindow
.
get
(
window
)
&
&
UITour
.
tourBrowsersByWindow
.
get
(
window
)
.
has
(
gBrowser
.
selectedBrowser
)
)
{
entryPoint
=
"
uitour
"
;
}
this
.
openPrefs
(
entryPoint
)
;
}
else
{
let
win
=
Services
.
wm
.
getMostRecentWindow
(
"
Weave
:
AccountSetup
"
)
;
if
(
win
)
win
.
focus
(
)
;
else
{
window
.
openDialog
(
"
chrome
:
/
/
browser
/
content
/
sync
/
setup
.
xul
"
"
weaveSetup
"
"
centerscreen
chrome
resizable
=
no
"
wizardType
)
;
}
}
}
openAddDevice
:
function
(
)
{
if
(
!
Weave
.
Utils
.
ensureMPUnlocked
(
)
)
return
;
let
win
=
Services
.
wm
.
getMostRecentWindow
(
"
Sync
:
AddDevice
"
)
;
if
(
win
)
win
.
focus
(
)
;
else
window
.
openDialog
(
"
chrome
:
/
/
browser
/
content
/
sync
/
addDevice
.
xul
"
"
syncAddDevice
"
"
centerscreen
chrome
resizable
=
no
"
)
;
}
openPrefs
:
function
(
entryPoint
)
{
openPreferences
(
"
paneSync
"
{
urlParams
:
{
entrypoint
:
entryPoint
}
}
)
;
}
openSignInAgainPage
:
function
(
entryPoint
=
"
syncbutton
"
)
{
gFxAccounts
.
openSignInAgainPage
(
entryPoint
)
;
}
openSyncedTabsPanel
(
)
{
let
placement
=
CustomizableUI
.
getPlacementOfWidget
(
"
sync
-
button
"
)
;
let
area
=
placement
?
placement
.
area
:
CustomizableUI
.
AREA_NAVBAR
;
let
anchor
=
document
.
getElementById
(
"
sync
-
button
"
)
|
|
document
.
getElementById
(
"
PanelUI
-
menu
-
button
"
)
;
if
(
area
=
=
CustomizableUI
.
AREA_PANEL
)
{
PanelUI
.
show
(
)
.
then
(
(
)
=
>
{
PanelUI
.
showSubView
(
"
PanelUI
-
remotetabs
"
anchor
area
)
;
}
)
.
catch
(
Cu
.
reportError
)
;
}
else
{
PanelUI
.
showSubView
(
"
PanelUI
-
remotetabs
"
anchor
area
)
;
}
}
maybeMoveSyncedTabsButton
(
)
{
const
prefName
=
"
browser
.
migrated
-
sync
-
button
"
;
let
migrated
=
false
;
try
{
migrated
=
Services
.
prefs
.
getBoolPref
(
prefName
)
;
}
catch
(
_
)
{
}
if
(
migrated
)
{
return
;
}
if
(
!
CustomizableUI
.
getPlacementOfWidget
(
"
sync
-
button
"
)
)
{
CustomizableUI
.
addWidgetToArea
(
"
sync
-
button
"
CustomizableUI
.
AREA_PANEL
)
;
}
Services
.
prefs
.
setBoolPref
(
prefName
true
)
;
}
_updateSyncButtonsTooltip
:
Task
.
async
(
function
*
(
)
{
if
(
!
gBrowser
)
return
;
let
email
;
try
{
email
=
Services
.
prefs
.
getCharPref
(
"
services
.
sync
.
username
"
)
;
}
catch
(
ex
)
{
}
let
needsSetup
=
yield
this
.
_needsSetup
(
)
;
let
needsVerification
=
yield
this
.
_needsVerification
(
)
;
let
loginFailed
=
this
.
_loginFailed
(
)
;
let
tooltiptext
;
if
(
needsVerification
)
{
tooltiptext
=
gFxAccounts
.
strings
.
formatStringFromName
(
"
verifyDescription
"
[
email
]
1
)
;
}
else
if
(
needsSetup
)
{
tooltiptext
=
this
.
_stringBundle
.
GetStringFromName
(
"
signInToSync
.
description
"
)
;
}
else
if
(
loginFailed
)
{
tooltiptext
=
gFxAccounts
.
strings
.
formatStringFromName
(
"
reconnectDescription
"
[
email
]
1
)
;
}
else
{
try
{
let
lastSync
=
new
Date
(
Services
.
prefs
.
getCharPref
(
"
services
.
sync
.
lastSync
"
)
)
;
let
lastSyncDateString
=
lastSync
.
toLocaleDateString
(
undefined
{
weekday
:
'
long
'
hour
:
'
numeric
'
minute
:
'
numeric
'
}
)
;
tooltiptext
=
this
.
_stringBundle
.
formatStringFromName
(
"
lastSync2
.
label
"
[
lastSyncDateString
]
1
)
;
}
catch
(
e
)
{
}
}
if
(
!
gBrowser
)
return
;
let
broadcaster
=
document
.
getElementById
(
"
sync
-
status
"
)
;
if
(
broadcaster
)
{
if
(
tooltiptext
)
{
broadcaster
.
setAttribute
(
"
tooltiptext
"
tooltiptext
)
;
}
else
{
broadcaster
.
removeAttribute
(
"
tooltiptext
"
)
;
}
}
}
)
onSyncFinish
:
function
SUI_onSyncFinish
(
)
{
let
title
=
this
.
_stringBundle
.
GetStringFromName
(
"
error
.
sync
.
title
"
)
;
}
observe
:
function
SUI_observe
(
subject
topic
data
)
{
this
.
log
.
debug
(
"
observed
"
topic
)
;
if
(
this
.
_unloaded
)
{
Cu
.
reportError
(
"
SyncUI
observer
called
after
unload
:
"
+
topic
)
;
return
;
}
if
(
subject
&
&
typeof
subject
=
=
"
object
"
&
&
(
"
wrappedJSObject
"
in
subject
)
&
&
(
"
observersModuleSubjectWrapper
"
in
subject
.
wrappedJSObject
)
)
{
subject
=
subject
.
wrappedJSObject
.
object
;
}
switch
(
topic
)
{
case
"
weave
:
service
:
sync
:
start
"
:
this
.
onActivityStart
(
)
;
break
;
case
"
weave
:
service
:
sync
:
finish
"
:
case
"
weave
:
service
:
sync
:
error
"
:
this
.
onActivityStop
(
)
;
break
;
}
switch
(
topic
)
{
case
"
weave
:
ui
:
sync
:
finish
"
:
this
.
onSyncFinish
(
)
;
break
;
case
"
weave
:
ui
:
sync
:
error
"
:
case
"
weave
:
service
:
setup
-
complete
"
:
case
"
weave
:
service
:
login
:
finish
"
:
case
"
weave
:
service
:
login
:
start
"
:
case
"
weave
:
service
:
start
-
over
"
:
this
.
updateUI
(
)
;
break
;
case
"
weave
:
ui
:
login
:
error
"
:
case
"
weave
:
service
:
login
:
error
"
:
this
.
onLoginError
(
)
;
break
;
case
"
weave
:
service
:
logout
:
finish
"
:
this
.
onLogout
(
)
;
break
;
case
"
weave
:
service
:
start
-
over
:
finish
"
:
this
.
updateUI
(
)
;
break
;
case
"
weave
:
service
:
ready
"
:
this
.
initUI
(
)
;
break
;
case
"
weave
:
notification
:
added
"
:
this
.
initNotifications
(
)
;
break
;
}
}
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIObserver
Ci
.
nsISupportsWeakReference
]
)
}
;
XPCOMUtils
.
defineLazyGetter
(
gSyncUI
"
_stringBundle
"
function
(
)
{
return
Cc
[
"
mozilla
.
org
/
intl
/
stringbundle
;
1
"
]
.
getService
(
Ci
.
nsIStringBundleService
)
.
createBundle
(
"
chrome
:
/
/
weave
/
locale
/
services
/
sync
.
properties
"
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
gSyncUI
"
log
"
function
(
)
{
return
Log
.
repository
.
getLogger
(
"
browserwindow
.
syncui
"
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
gSyncUI
"
weaveService
"
function
(
)
{
return
Components
.
classes
[
"
mozilla
.
org
/
weave
/
service
;
1
"
]
.
getService
(
Components
.
interfaces
.
nsISupports
)
.
wrappedJSObject
;
}
)
;
