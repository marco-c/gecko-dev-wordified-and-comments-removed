const
{
AddonManager
document
:
gDoc
Services
XPCOMUtils
}
=
window
.
docShell
.
chromeEventHandler
.
ownerGlobal
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
BuiltInThemes
:
"
resource
:
/
/
/
modules
/
BuiltInThemes
.
jsm
"
}
)
;
const
HOMEPAGE_PREF
=
"
browser
.
startup
.
homepage
"
;
const
NEWTAB_PREF
=
"
browser
.
newtabpage
.
enabled
"
;
const
SCREEN_STRINGS
=
[
{
title
:
"
upgrade
-
dialog
-
start
-
title
"
subtitle
:
"
upgrade
-
dialog
-
start
-
subtitle
"
primary
:
"
upgrade
-
dialog
-
colorway
-
primary
-
button
"
secondary
:
"
upgrade
-
dialog
-
colorway
-
secondary
-
button
"
}
{
title
:
"
upgrade
-
dialog
-
thankyou
-
title
"
subtitle
:
"
upgrade
-
dialog
-
thankyou
-
subtitle
"
primary
:
"
upgrade
-
dialog
-
thankyou
-
primary
-
button
"
}
]
;
const
THEME_IDS
=
[
[
"
firefox
-
compact
-
light
mozilla
.
org
"
"
default
-
theme
mozilla
.
org
"
"
firefox
-
compact
-
dark
mozilla
.
org
"
]
[
"
abstract
-
soft
-
colorway
mozilla
.
org
"
"
abstract
-
balanced
-
colorway
mozilla
.
org
"
"
abstract
-
bold
-
colorway
mozilla
.
org
"
]
[
"
cheers
-
soft
-
colorway
mozilla
.
org
"
"
cheers
-
balanced
-
colorway
mozilla
.
org
"
"
cheers
-
bold
-
colorway
mozilla
.
org
"
]
[
"
foto
-
soft
-
colorway
mozilla
.
org
"
"
foto
-
balanced
-
colorway
mozilla
.
org
"
"
foto
-
bold
-
colorway
mozilla
.
org
"
]
[
"
lush
-
soft
-
colorway
mozilla
.
org
"
"
lush
-
balanced
-
colorway
mozilla
.
org
"
"
lush
-
bold
-
colorway
mozilla
.
org
"
]
[
"
graffiti
-
soft
-
colorway
mozilla
.
org
"
"
graffiti
-
balanced
-
colorway
mozilla
.
org
"
"
graffiti
-
bold
-
colorway
mozilla
.
org
"
]
[
"
elemental
-
soft
-
colorway
mozilla
.
org
"
"
elemental
-
balanced
-
colorway
mozilla
.
org
"
"
elemental
-
bold
-
colorway
mozilla
.
org
"
]
]
;
const
CLEANUP
=
[
]
;
addEventListener
(
"
pagehide
"
(
)
=
>
CLEANUP
.
forEach
(
f
=
>
f
(
)
)
{
once
:
true
}
)
;
let
gPrevTheme
=
AddonManager
.
getAddonsByTypes
(
[
"
theme
"
]
)
.
then
(
addons
=
>
{
for
(
const
{
id
isActive
}
of
addons
)
{
if
(
isActive
)
{
CLEANUP
.
push
(
(
)
=
>
gPrevTheme
&
&
enableTheme
(
id
)
)
;
return
{
id
}
;
}
}
return
{
id
:
THEME_IDS
[
0
]
[
1
]
}
;
}
)
;
async
function
enableTheme
(
id
)
{
await
BuiltInThemes
.
ensureBuiltInThemes
(
)
;
(
await
AddonManager
.
getAddonByID
(
id
)
)
?
.
enable
(
)
;
}
function
adjustModalBackdrop
(
)
{
const
{
classList
}
=
gDoc
.
getElementById
(
"
window
-
modal
-
dialog
"
)
;
classList
.
add
(
"
showToolbar
"
)
;
CLEANUP
.
push
(
(
)
=
>
classList
.
remove
(
"
showToolbar
"
)
)
;
}
function
recordEvent
(
obj
val
)
{
Services
.
telemetry
.
recordEvent
(
"
upgrade_dialog
"
"
content
"
obj
{
val
}
)
;
}
let
gCloseReason
=
"
external
"
;
CLEANUP
.
push
(
(
)
=
>
recordEvent
(
"
close
"
gCloseReason
)
)
;
function
closeDialog
(
reason
)
{
gCloseReason
=
reason
;
close
(
)
;
}
const
QUIT_TOPIC
=
"
quit
-
application
-
requested
"
;
const
QUIT_OBSERVER
=
(
)
=
>
closeDialog
(
QUIT_TOPIC
)
;
Services
.
obs
.
addObserver
(
QUIT_OBSERVER
QUIT_TOPIC
)
;
CLEANUP
.
push
(
(
)
=
>
Services
.
obs
.
removeObserver
(
QUIT_OBSERVER
QUIT_TOPIC
)
)
;
function
triggerTransition
(
callback
)
{
requestAnimationFrame
(
(
)
=
>
requestAnimationFrame
(
callback
)
)
;
}
function
onLoad
(
ready
)
{
if
(
Cu
.
isInAutomation
)
{
Math
.
random
=
(
)
=
>
0
;
}
const
{
body
}
=
document
;
const
logo
=
document
.
querySelector
(
"
.
logo
"
)
;
const
title
=
document
.
getElementById
(
"
title
"
)
;
const
subtitle
=
document
.
getElementById
(
"
subtitle
"
)
;
const
colorways
=
document
.
querySelector
(
"
.
colorways
"
)
;
const
themes
=
document
.
querySelector
(
"
.
themes
"
)
;
const
variations
=
document
.
querySelector
(
"
.
variations
"
)
;
const
checkbox
=
document
.
querySelector
(
"
.
checkbox
"
)
;
const
primary
=
document
.
getElementById
(
"
primary
"
)
;
const
secondary
=
document
.
getElementById
(
"
secondary
"
)
;
function
showVariations
(
themeRadio
)
{
let
l10nIds
themeName
;
const
{
l10nArgs
}
=
themeRadio
.
dataset
;
if
(
l10nArgs
)
{
const
{
colorwayName
}
=
JSON
.
parse
(
l10nArgs
)
;
variations
.
firstElementChild
.
textContent
=
colorwayName
;
l10nIds
=
[
"
upgrade
-
dialog
-
colorway
-
variation
-
soft
"
"
upgrade
-
dialog
-
colorway
-
variation
-
balanced
"
"
upgrade
-
dialog
-
colorway
-
variation
-
bold
"
]
;
themeName
=
colorwayName
.
toLowerCase
(
)
;
}
else
{
l10nIds
=
[
"
upgrade
-
dialog
-
colorway
-
default
-
theme
"
"
upgrade
-
dialog
-
theme
-
light
"
"
upgrade
-
dialog
-
colorway
-
theme
-
auto
"
"
upgrade
-
dialog
-
theme
-
dark
"
]
;
themeName
=
"
default
"
;
}
l10nIds
.
reduceRight
(
(
node
l10nId
)
=
>
{
node
.
dataset
.
l10nId
=
"
"
;
document
.
l10n
.
setAttributes
(
node
l10nId
)
;
return
node
.
previousElementSibling
;
}
variations
.
lastElementChild
)
;
variations
.
classList
=
variations
{
themeName
}
in
;
triggerTransition
(
(
)
=
>
variations
.
classList
.
remove
(
"
in
"
)
)
;
dispatchEvent
(
new
CustomEvent
(
"
variations
"
)
)
;
}
new
MutationObserver
(
list
=
>
list
.
forEach
(
(
{
target
}
)
=
>
{
if
(
target
.
type
=
=
=
"
radio
"
&
&
!
target
.
hasAttribute
(
"
aria
-
label
"
)
)
{
target
.
setAttribute
(
"
aria
-
label
"
target
.
textContent
)
;
}
}
)
)
.
observe
(
variations
{
attributes
:
true
subtree
:
true
}
)
;
function
showColorways
(
)
{
variations
.
querySelectorAll
(
"
input
"
)
[
2
*
matchMedia
(
"
(
prefers
-
color
-
scheme
:
dark
)
"
)
.
matches
]
.
checked
=
true
;
const
getVariantIndex
=
(
)
=
>
[
.
.
.
variations
.
children
]
.
indexOf
(
variations
.
querySelector
(
"
:
checked
"
)
)
-
1
;
const
enableVariant
=
(
)
=
>
enableTheme
(
THEME_IDS
[
variations
.
getAttribute
(
"
next
"
)
?
?
0
]
[
getVariantIndex
(
)
]
)
;
const
random
=
Math
.
floor
(
Math
.
random
(
)
*
(
THEME_IDS
.
length
-
1
)
)
+
1
;
const
selected
=
themes
.
children
[
random
]
;
selected
.
checked
=
true
;
recordEvent
(
"
show
"
random
-
{
random
}
)
;
triggerTransition
(
(
)
=
>
variations
.
setAttribute
(
"
next
"
random
)
)
;
setTimeout
(
(
)
=
>
{
enableVariant
(
)
;
showVariations
(
selected
)
;
}
400
)
;
variations
.
addEventListener
(
"
click
"
(
{
target
:
button
}
)
=
>
{
if
(
button
.
type
=
=
=
"
radio
"
)
{
enableVariant
(
)
;
recordEvent
(
"
theme
"
variant
-
{
getVariantIndex
(
)
}
)
;
}
}
)
;
let
nextButton
;
themes
.
addEventListener
(
"
click
"
(
{
target
:
button
}
)
=
>
{
if
(
button
.
parentNode
=
=
=
themes
)
{
variations
.
setAttribute
(
"
next
"
[
.
.
.
themes
.
children
]
.
indexOf
(
button
)
)
;
if
(
!
nextButton
)
{
variations
.
classList
.
add
(
"
out
"
)
;
setTimeout
(
(
)
=
>
{
variations
.
classList
.
remove
(
"
out
"
)
;
enableVariant
(
)
;
recordEvent
(
"
theme
"
theme
-
{
variations
.
getAttribute
(
"
next
"
)
}
)
;
showVariations
(
nextButton
)
;
nextButton
=
null
;
}
500
)
;
}
nextButton
=
button
;
}
}
)
;
[
.
.
.
themes
.
children
]
.
forEach
(
input
=
>
{
new
Image
(
)
.
src
=
getComputedStyle
(
input
"
:
:
before
"
)
.
backgroundImage
.
match
(
/
resource
:
[
^
"
]
+
/
)
?
.
[
0
]
;
}
)
;
colorways
.
classList
.
remove
(
"
hidden
"
)
;
adjustModalBackdrop
(
)
;
if
(
Services
.
prefs
.
prefHasUserValue
(
HOMEPAGE_PREF
)
|
|
Services
.
prefs
.
prefHasUserValue
(
NEWTAB_PREF
)
)
{
checkbox
.
classList
.
remove
(
"
hidden
"
)
;
recordEvent
(
"
show
"
checkbox
.
lastElementChild
.
dataset
.
l10nId
)
;
}
else
{
checkbox
.
remove
(
)
;
checkbox
.
firstElementChild
.
checked
=
false
;
}
return
selected
;
}
function
removeColorways
(
)
{
body
.
classList
.
add
(
"
confetti
"
)
;
logo
.
classList
.
remove
(
"
hidden
"
)
;
colorways
.
remove
(
)
;
checkbox
.
remove
(
)
;
}
function
handleCheckbox
(
)
{
if
(
checkbox
.
firstElementChild
.
checked
)
{
Services
.
prefs
.
clearUserPref
(
HOMEPAGE_PREF
)
;
Services
.
prefs
.
clearUserPref
(
NEWTAB_PREF
)
;
recordEvent
(
"
button
"
checkbox
.
lastElementChild
.
dataset
.
l10nId
)
;
}
}
let
busy
=
false
;
let
current
=
-
1
;
(
async
function
advance
(
{
target
}
=
{
}
)
{
if
(
target
)
{
recordEvent
(
"
button
"
(
busy
?
"
busy
:
"
:
"
"
)
+
target
.
dataset
.
l10nId
)
;
}
if
(
busy
)
{
return
;
}
busy
=
true
;
let
toFocus
=
primary
;
if
(
+
+
current
=
=
=
0
)
{
primary
.
addEventListener
(
"
click
"
advance
)
;
secondary
.
addEventListener
(
"
click
"
advance
)
;
recordEvent
(
"
show
"
{
SCREEN_STRINGS
.
length
}
-
screens
)
;
await
document
.
l10n
.
ready
;
await
gPrevTheme
;
toFocus
=
showColorways
(
)
;
}
else
{
const
{
l10nId
}
=
target
.
dataset
;
switch
(
l10nId
)
{
case
"
upgrade
-
dialog
-
colorway
-
primary
-
button
"
:
gPrevTheme
=
null
;
handleCheckbox
(
)
;
removeColorways
(
)
;
break
;
case
"
upgrade
-
dialog
-
colorway
-
secondary
-
button
"
:
enableTheme
(
(
await
gPrevTheme
)
.
id
)
;
removeColorways
(
)
;
break
;
case
"
upgrade
-
dialog
-
thankyou
-
primary
-
button
"
:
closeDialog
(
"
complete
"
)
;
return
;
}
}
if
(
current
=
=
=
SCREEN_STRINGS
.
length
-
1
)
{
setTimeout
(
(
)
=
>
closeDialog
(
"
autoclose
"
)
20000
)
;
}
const
strings
=
SCREEN_STRINGS
[
current
]
;
const
translatedElements
=
[
]
;
for
(
let
el
of
[
title
subtitle
primary
secondary
]
)
{
const
stringId
=
strings
[
el
.
id
]
;
if
(
stringId
)
{
document
.
l10n
.
setAttributes
(
el
stringId
)
;
translatedElements
.
push
(
el
)
;
el
.
classList
.
remove
(
"
hidden
"
)
;
el
.
disabled
=
false
;
}
else
{
el
.
classList
.
add
(
"
hidden
"
)
;
el
.
disabled
=
true
;
el
.
textContent
=
"
"
;
}
}
await
document
.
l10n
.
translateElements
(
translatedElements
)
;
requestAnimationFrame
(
(
)
=
>
{
toFocus
.
focus
(
{
preventFocusRing
:
true
}
)
;
if
(
current
=
=
=
0
)
{
body
.
style
.
minHeight
=
getComputedStyle
(
body
)
.
height
;
ready
(
)
;
}
dispatchEvent
(
new
CustomEvent
(
"
ready
"
)
)
;
}
)
;
recordEvent
(
"
show
"
primary
.
dataset
.
l10nId
)
;
busy
=
false
;
}
)
(
)
;
}
document
.
mozSubdialogReady
=
new
Promise
(
resolve
=
>
document
.
addEventListener
(
"
DOMContentLoaded
"
(
)
=
>
onLoad
(
resolve
)
{
once
:
true
}
)
)
;
