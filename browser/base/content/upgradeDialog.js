const
{
AddonManager
document
:
gDoc
getShellService
}
=
window
.
docShell
.
chromeEventHandler
.
ownerGlobal
;
const
SHELL
=
getShellService
(
)
;
const
IS_DEFAULT
=
SHELL
.
isDefaultBrowser
(
)
;
const
CAN_PIN
=
(
(
)
=
>
{
try
{
SHELL
.
QueryInterface
(
Ci
.
nsIWindowsShellService
)
.
checkPinCurrentAppToTaskbar
(
)
;
return
true
;
}
catch
(
ex
)
{
return
false
;
}
}
)
(
)
;
const
NEED_PIN
=
Promise
.
resolve
(
CAN_PIN
&
&
SHELL
.
isCurrentAppPinnedToTaskbarAsync
(
)
.
then
(
pinned
=
>
!
pinned
)
)
;
const
PIN_OR_THEME_STRING
=
NEED_PIN
.
then
(
pin
=
>
pin
?
"
upgrade
-
dialog
-
new
-
primary
-
pin
-
button
"
:
"
upgrade
-
dialog
-
new
-
primary
-
theme
-
button
"
)
;
const
PRIMARY_OR_DEFAULT_STRING
=
NEED_PIN
.
then
(
pin
=
>
pin
?
"
upgrade
-
dialog
-
new
-
primary
-
primary
-
button
"
:
"
upgrade
-
dialog
-
new
-
primary
-
default
-
button
"
)
;
const
SCREEN_STRINGS
=
[
{
title
:
"
upgrade
-
dialog
-
new
-
title
"
primary
:
IS_DEFAULT
?
PIN_OR_THEME_STRING
:
PRIMARY_OR_DEFAULT_STRING
secondary
:
"
upgrade
-
dialog
-
new
-
secondary
-
button
"
}
{
title
:
"
upgrade
-
dialog
-
theme
-
title
"
primary
:
"
upgrade
-
dialog
-
theme
-
primary
-
button
"
secondary
:
"
upgrade
-
dialog
-
theme
-
secondary
-
button
"
}
]
;
const
THEME_IDS
=
[
"
default
-
theme
mozilla
.
org
"
"
firefox
-
compact
-
light
mozilla
.
org
"
"
firefox
-
compact
-
dark
mozilla
.
org
"
"
firefox
-
alpenglow
mozilla
.
org
"
]
;
const
CLEANUP
=
[
]
;
addEventListener
(
"
pagehide
"
(
)
=
>
CLEANUP
.
forEach
(
f
=
>
f
(
)
)
{
once
:
true
}
)
;
let
gPrevTheme
=
AddonManager
.
getAddonsByTypes
(
[
"
theme
"
]
)
.
then
(
addons
=
>
{
for
(
const
{
id
isActive
screenshots
}
of
addons
)
{
if
(
isActive
)
{
if
(
!
THEME_IDS
.
includes
(
id
)
)
{
THEME_IDS
.
push
(
id
)
;
}
CLEANUP
.
push
(
(
)
=
>
gPrevTheme
&
&
enableTheme
(
id
)
)
;
return
{
id
swatch
:
screenshots
?
.
[
0
]
.
url
}
;
}
}
return
{
}
;
}
)
;
async
function
enableTheme
(
id
)
{
(
await
AddonManager
.
getAddonByID
(
id
)
)
.
enable
(
)
;
}
function
adjustModalBackdrop
(
)
{
const
{
classList
}
=
gDoc
.
getElementById
(
"
window
-
modal
-
dialog
"
)
;
classList
.
add
(
"
showToolbar
"
)
;
CLEANUP
.
push
(
(
)
=
>
classList
.
remove
(
"
showToolbar
"
)
)
;
}
function
onLoad
(
ready
)
{
const
title
=
document
.
getElementById
(
"
title
"
)
;
const
subtitle
=
document
.
getElementById
(
"
subtitle
"
)
;
const
items
=
document
.
querySelector
(
"
.
items
"
)
;
const
themes
=
document
.
querySelector
(
"
.
themes
"
)
;
const
primary
=
document
.
getElementById
(
"
primary
"
)
;
const
secondary
=
document
.
getElementById
(
"
secondary
"
)
;
const
steps
=
document
.
querySelector
(
"
.
steps
"
)
;
let
current
=
-
1
;
(
async
function
advance
(
{
target
}
=
{
}
)
{
switch
(
+
+
current
)
{
case
0
:
primary
.
addEventListener
(
"
click
"
advance
)
;
secondary
.
addEventListener
(
"
click
"
advance
)
;
break
;
case
1
:
if
(
target
=
=
=
primary
)
{
if
(
!
IS_DEFAULT
)
{
SHELL
.
setAsDefault
(
)
;
}
if
(
await
NEED_PIN
)
{
try
{
SHELL
.
pinCurrentAppToTaskbar
(
)
;
}
catch
(
ex
)
{
}
}
}
else
if
(
target
=
=
=
secondary
&
&
IS_DEFAULT
&
&
!
(
await
NEED_PIN
)
)
{
window
.
close
(
)
;
return
;
}
const
{
id
swatch
}
=
await
gPrevTheme
;
themes
.
children
[
THEME_IDS
.
indexOf
(
id
)
]
.
checked
=
true
;
themes
.
addEventListener
(
"
click
"
(
{
target
:
button
}
)
=
>
{
if
(
button
.
parentNode
=
=
=
themes
)
{
const
index
=
[
.
.
.
themes
.
children
]
.
indexOf
(
button
)
;
enableTheme
(
THEME_IDS
[
index
]
)
;
}
}
)
;
if
(
themes
.
childElementCount
>
THEME_IDS
.
length
)
{
themes
.
removeChild
(
themes
.
lastElementChild
)
;
}
else
if
(
swatch
)
{
themes
.
lastElementChild
.
style
.
setProperty
(
"
-
-
theme
-
swatch
"
url
(
"
{
swatch
}
"
)
)
;
}
subtitle
.
remove
(
)
;
items
.
remove
(
)
;
themes
.
classList
.
remove
(
"
hidden
"
)
;
steps
.
appendChild
(
steps
.
firstChild
)
;
adjustModalBackdrop
(
)
;
break
;
case
2
:
if
(
target
=
=
=
primary
)
{
gPrevTheme
=
null
;
}
window
.
close
(
)
;
return
;
}
const
strings
=
SCREEN_STRINGS
[
current
]
;
document
.
l10n
.
setAttributes
(
title
strings
.
title
)
;
document
.
l10n
.
setAttributes
(
primary
await
strings
.
primary
)
;
document
.
l10n
.
setAttributes
(
secondary
strings
.
secondary
)
;
requestAnimationFrame
(
(
)
=
>
{
primary
.
focus
(
)
;
if
(
current
=
=
=
0
)
{
document
.
body
.
style
.
minHeight
=
getComputedStyle
(
document
.
body
)
.
height
;
ready
(
)
;
}
dispatchEvent
(
new
CustomEvent
(
"
ready
"
)
)
;
}
)
;
}
)
(
)
;
}
document
.
mozSubdialogReady
=
new
Promise
(
resolve
=
>
document
.
addEventListener
(
"
DOMContentLoaded
"
(
)
=
>
onLoad
(
resolve
)
{
once
:
true
}
)
)
;
