var
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
var
gContent
=
content
;
docShell
.
isAppTab
=
true
;
var
gHookedWindowCloseForPanelClose
=
false
;
var
gDOMContentLoaded
=
false
;
addEventListener
(
"
DOMContentLoaded
"
function
(
event
)
{
if
(
event
.
target
=
=
content
.
document
)
{
gDOMContentLoaded
=
true
;
sendAsyncMessage
(
"
DOMContentLoaded
"
)
;
}
}
)
;
addEventListener
(
"
unload
"
function
(
event
)
{
if
(
event
.
target
=
=
content
.
document
)
{
gDOMContentLoaded
=
false
;
gHookedWindowCloseForPanelClose
=
false
;
}
}
true
)
;
var
gDOMTitleChangedByUs
=
false
;
addEventListener
(
"
DOMTitleChanged
"
function
(
e
)
{
if
(
!
gDOMTitleChangedByUs
)
{
sendAsyncMessage
(
"
Social
:
DOMTitleChanged
"
{
title
:
e
.
target
.
title
}
)
;
}
gDOMTitleChangedByUs
=
false
;
}
)
;
addMessageListener
(
"
Social
:
OpenGraphData
"
(
message
)
=
>
{
let
ev
=
new
content
.
CustomEvent
(
"
OpenGraphData
"
{
detail
:
JSON
.
stringify
(
message
.
data
)
}
)
;
content
.
dispatchEvent
(
ev
)
;
}
)
;
addMessageListener
(
"
Social
:
ClearFrame
"
(
message
)
=
>
{
docShell
.
createAboutBlankContentViewer
(
null
)
;
}
)
;
const
SocialErrorListener
=
{
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIDOMEventListener
Ci
.
nsIWebProgressListener
Ci
.
nsISupportsWeakReference
Ci
.
nsISupports
]
)
defaultTemplate
:
"
about
:
socialerror
?
mode
=
tryAgainOnly
&
url
=
%
{
url
}
&
origin
=
%
{
origin
}
"
urlTemplate
:
null
init
(
)
{
addMessageListener
(
"
Loop
:
MonitorPeerConnectionLifecycle
"
this
)
;
addMessageListener
(
"
Loop
:
GetAllWebrtcStats
"
this
)
;
addMessageListener
(
"
Social
:
CustomEvent
"
this
)
;
addMessageListener
(
"
Social
:
EnsureFocus
"
this
)
;
addMessageListener
(
"
Social
:
EnsureFocusElement
"
this
)
;
addMessageListener
(
"
Social
:
HookWindowCloseForPanelClose
"
this
)
;
addMessageListener
(
"
Social
:
ListenForEvents
"
this
)
;
addMessageListener
(
"
Social
:
SetDocumentTitle
"
this
)
;
addMessageListener
(
"
Social
:
SetErrorURL
"
this
)
;
addMessageListener
(
"
Social
:
DisableDialogs
"
this
)
;
addMessageListener
(
"
Social
:
WaitForDocumentVisible
"
this
)
;
addMessageListener
(
"
WaitForDOMContentLoaded
"
this
)
;
let
webProgress
=
docShell
.
QueryInterface
(
Components
.
interfaces
.
nsIInterfaceRequestor
)
.
getInterface
(
Components
.
interfaces
.
nsIWebProgress
)
;
webProgress
.
addProgressListener
(
this
Ci
.
nsIWebProgress
.
NOTIFY_STATE_REQUEST
|
Ci
.
nsIWebProgress
.
NOTIFY_LOCATION
)
;
}
receiveMessage
(
message
)
{
let
document
=
content
.
document
;
switch
(
message
.
name
)
{
case
"
Loop
:
GetAllWebrtcStats
"
:
content
.
WebrtcGlobalInformation
.
getAllStats
(
allStats
=
>
{
content
.
WebrtcGlobalInformation
.
getLogging
(
"
"
logs
=
>
{
sendAsyncMessage
(
"
Loop
:
GetAllWebrtcStats
"
{
allStats
:
allStats
logs
:
logs
}
)
;
}
)
;
}
message
.
data
.
peerConnectionID
)
;
break
;
case
"
Loop
:
MonitorPeerConnectionLifecycle
"
:
let
ourID
=
content
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
.
currentInnerWindowID
;
let
onPCLifecycleChange
=
(
pc
winID
type
)
=
>
{
if
(
winID
!
=
ourID
)
{
return
;
}
sendAsyncMessage
(
"
Loop
:
PeerConnectionLifecycleChange
"
{
iceConnectionState
:
pc
.
iceConnectionState
locationHash
:
content
.
location
.
hash
peerConnectionID
:
pc
.
id
type
:
type
}
)
;
}
;
let
pc_static
=
new
content
.
RTCPeerConnectionStatic
(
)
;
pc_static
.
registerPeerConnectionLifecycleCallback
(
onPCLifecycleChange
)
;
break
;
case
"
Social
:
CustomEvent
"
:
let
ev
=
new
content
.
CustomEvent
(
message
.
data
.
name
message
.
data
.
detail
?
{
detail
:
message
.
data
.
detail
}
:
null
)
;
content
.
dispatchEvent
(
ev
)
;
break
;
case
"
Social
:
EnsureFocus
"
:
Services
.
focus
.
focusedWindow
=
content
;
sendAsyncMessage
(
"
Social
:
FocusEnsured
"
)
;
break
;
case
"
Social
:
EnsureFocusElement
"
:
let
fm
=
Services
.
focus
;
fm
.
moveFocus
(
document
.
defaultView
null
fm
.
MOVEFOCUS_FIRST
fm
.
FLAG_NOSCROLL
)
;
sendAsyncMessage
(
"
Social
:
FocusEnsured
"
)
;
break
;
case
"
Social
:
HookWindowCloseForPanelClose
"
:
if
(
gHookedWindowCloseForPanelClose
)
{
break
;
}
gHookedWindowCloseForPanelClose
=
true
;
let
dwu
=
content
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
dwu
.
allowScriptsToClose
(
)
;
content
.
addEventListener
(
"
DOMWindowClose
"
function
_mozSocialDOMWindowClose
(
evt
)
{
evt
.
preventDefault
(
)
;
sendAsyncMessage
(
"
Social
:
DOMWindowClose
"
)
;
}
true
)
;
break
;
case
"
Social
:
ListenForEvents
"
:
for
(
let
eventName
of
message
.
data
.
eventNames
)
{
content
.
addEventListener
(
eventName
this
)
;
}
break
;
case
"
Social
:
SetDocumentTitle
"
:
let
title
=
message
.
data
.
title
;
if
(
title
&
&
(
title
=
title
.
trim
(
)
)
)
{
gDOMTitleChangedByUs
=
true
;
document
.
title
=
title
;
}
break
;
case
"
Social
:
SetErrorURL
"
:
this
.
urlTemplate
=
message
.
data
.
template
;
break
;
case
"
Social
:
WaitForDocumentVisible
"
:
if
(
!
document
.
hidden
)
{
sendAsyncMessage
(
"
Social
:
DocumentVisible
"
)
;
break
;
}
document
.
addEventListener
(
"
visibilitychange
"
function
onVisibilityChanged
(
)
{
document
.
removeEventListener
(
"
visibilitychange
"
onVisibilityChanged
)
;
sendAsyncMessage
(
"
Social
:
DocumentVisible
"
)
;
}
)
;
break
;
case
"
Social
:
DisableDialogs
"
:
let
windowUtils
=
content
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
windowUtils
.
disableDialogs
(
)
;
break
;
case
"
WaitForDOMContentLoaded
"
:
if
(
gDOMContentLoaded
)
{
sendAsyncMessage
(
"
DOMContentLoaded
"
)
;
}
break
;
}
}
handleEvent
:
function
(
event
)
{
sendAsyncMessage
(
"
Social
:
CustomEvent
"
{
name
:
event
.
type
}
)
;
}
setErrorPage
(
)
{
let
frame
=
docShell
.
chromeEventHandler
;
let
origin
=
frame
.
getAttribute
(
"
origin
"
)
;
let
src
=
frame
.
getAttribute
(
"
src
"
)
;
if
(
src
=
=
"
about
:
providerdirectory
"
)
{
frame
=
content
.
document
.
getElementById
(
"
activation
-
frame
"
)
;
src
=
frame
.
getAttribute
(
"
src
"
)
;
}
let
url
=
this
.
urlTemplate
|
|
this
.
defaultTemplate
;
url
=
url
.
replace
(
"
%
{
url
}
"
encodeURIComponent
(
src
)
)
;
url
=
url
.
replace
(
"
%
{
origin
}
"
encodeURIComponent
(
origin
)
)
;
if
(
frame
!
=
docShell
.
chromeEventHandler
)
{
frame
.
setAttribute
(
"
src
"
url
)
;
}
else
{
let
webNav
=
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
;
webNav
.
loadURI
(
url
null
null
null
null
)
;
}
sendAsyncMessage
(
"
Social
:
ErrorPageNotify
"
{
origin
:
origin
url
:
src
}
)
;
}
onStateChange
(
aWebProgress
aRequest
aState
aStatus
)
{
let
failure
=
false
;
if
(
(
aState
&
Ci
.
nsIWebProgressListener
.
STATE_IS_REQUEST
)
)
return
;
if
(
(
aState
&
Ci
.
nsIWebProgressListener
.
STATE_STOP
)
)
{
if
(
aRequest
instanceof
Ci
.
nsIHttpChannel
)
{
try
{
failure
=
aRequest
.
responseStatus
>
=
400
&
&
aRequest
.
responseStatus
<
600
;
}
catch
(
e
)
{
failure
=
aStatus
!
=
Components
.
results
.
NS_OK
;
}
}
}
if
(
failure
&
&
aStatus
!
=
Components
.
results
.
NS_BINDING_ABORTED
)
{
if
(
docShell
.
hasTrackingContentBlocked
)
{
let
frame
=
docShell
.
chromeEventHandler
;
let
src
=
frame
.
getAttribute
(
"
src
"
)
;
if
(
aRequest
&
&
aRequest
.
name
!
=
src
)
{
Cu
.
reportError
(
"
SocialErrorListener
ignoring
blocked
content
error
for
"
+
aRequest
.
name
)
;
return
;
}
}
aRequest
.
cancel
(
Components
.
results
.
NS_BINDING_ABORTED
)
;
this
.
setErrorPage
(
)
;
}
}
onLocationChange
(
aWebProgress
aRequest
aLocation
aFlags
)
{
if
(
aRequest
&
&
aFlags
&
Ci
.
nsIWebProgressListener
.
LOCATION_CHANGE_ERROR_PAGE
)
{
aRequest
.
cancel
(
Components
.
results
.
NS_BINDING_ABORTED
)
;
this
.
setErrorPage
(
)
;
}
}
onProgressChange
(
)
{
}
onStatusChange
(
)
{
}
onSecurityChange
(
)
{
}
}
;
SocialErrorListener
.
init
(
)
;
