ChromeUtils
.
defineESModuleGetters
(
this
{
ContentBlockingAllowList
:
"
resource
:
/
/
gre
/
modules
/
ContentBlockingAllowList
.
sys
.
mjs
"
E10SUtils
:
"
resource
:
/
/
gre
/
modules
/
E10SUtils
.
sys
.
mjs
"
PanelMultiView
:
"
moz
-
src
:
/
/
/
browser
/
components
/
customizableui
/
PanelMultiView
.
sys
.
mjs
"
PlacesUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
sys
.
mjs
"
SiteDataManager
:
"
resource
:
/
/
/
modules
/
SiteDataManager
.
sys
.
mjs
"
UrlbarPrefs
:
"
moz
-
src
:
/
/
/
browser
/
components
/
urlbar
/
UrlbarPrefs
.
sys
.
mjs
"
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
insecureConnectionTextEnabled
"
"
security
.
insecure_connection_text
.
enabled
"
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
insecureConnectionTextPBModeEnabled
"
"
security
.
insecure_connection_text
.
pbmode
.
enabled
"
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
httpsOnlyModeEnabled
"
"
dom
.
security
.
https_only_mode
"
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
httpsFirstModeEnabled
"
"
dom
.
security
.
https_first
"
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
schemelessHttpsFirstModeEnabled
"
"
dom
.
security
.
https_first_schemeless
"
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
httpsFirstModeEnabledPBM
"
"
dom
.
security
.
https_first_pbm
"
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
httpsOnlyModeEnabledPBM
"
"
dom
.
security
.
https_only_mode_pbm
"
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
popupClickjackDelay
"
"
security
.
notification_enable_delay
"
500
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
smartblockEmbedsEnabledPref
"
"
extensions
.
webcompat
.
smartblockEmbeds
.
enabled
"
false
)
;
const
ETP_ENABLED_ASSETS
=
{
label
:
"
trustpanel
-
etp
-
label
-
enabled
"
description
:
"
trustpanel
-
etp
-
description
-
enabled
"
header
:
"
trustpanel
-
header
-
enabled
"
innerDescription
:
"
trustpanel
-
description
-
enabled2
"
}
;
const
ETP_DISABLED_ASSETS
=
{
label
:
"
trustpanel
-
etp
-
label
-
disabled
"
description
:
"
trustpanel
-
etp
-
description
-
disabled
"
header
:
"
trustpanel
-
header
-
disabled
"
innerDescription
:
"
trustpanel
-
description
-
disabled
"
}
;
const
SMARTBLOCK_EMBED_INFO
=
[
{
matchPatterns
:
[
"
https
:
/
/
itisatracker
.
org
/
*
"
]
shimId
:
"
EmbedTestShim
"
displayName
:
"
Test
"
}
{
matchPatterns
:
[
"
https
:
/
/
www
.
instagram
.
com
/
*
"
"
https
:
/
/
platform
.
instagram
.
com
/
*
"
]
shimId
:
"
InstagramEmbed
"
displayName
:
"
Instagram
"
}
{
matchPatterns
:
[
"
https
:
/
/
www
.
tiktok
.
com
/
*
"
]
shimId
:
"
TiktokEmbed
"
displayName
:
"
Tiktok
"
}
{
matchPatterns
:
[
"
https
:
/
/
platform
.
twitter
.
com
/
*
"
]
shimId
:
"
TwitterEmbed
"
displayName
:
"
X
"
}
{
matchPatterns
:
[
"
https
:
/
/
*
.
disqus
.
com
/
*
"
]
shimId
:
"
DisqusEmbed
"
displayName
:
"
Disqus
"
}
]
;
class
TrustPanel
{
#
state
=
null
;
#
secInfo
=
null
;
#
uri
=
null
;
#
uriHasHost
=
null
;
#
pageExtensionPolicy
=
null
;
#
isSecureContext
=
null
;
#
isSecureInternalUI
=
null
;
#
lastEvent
=
null
;
#
popupToggleDelayTimer
=
null
;
#
openingReason
=
null
;
#
blockers
=
{
SocialTracking
ThirdPartyCookies
TrackingProtection
Fingerprinting
Cryptomining
}
;
init
(
)
{
for
(
let
blocker
of
Object
.
values
(
this
.
#
blockers
)
)
{
if
(
blocker
.
init
)
{
blocker
.
init
(
)
;
}
}
Services
.
obs
.
addObserver
(
this
"
smartblock
:
open
-
protections
-
panel
"
)
;
}
uninit
(
)
{
for
(
let
blocker
of
Object
.
values
(
this
.
#
blockers
)
)
{
if
(
blocker
.
uninit
)
{
blocker
.
uninit
(
)
;
}
}
Services
.
obs
.
removeObserver
(
this
"
smartblock
:
open
-
protections
-
panel
"
)
;
}
get
#
popup
(
)
{
return
document
.
getElementById
(
"
trustpanel
-
popup
"
)
;
}
get
#
enabled
(
)
{
return
UrlbarPrefs
.
get
(
"
trustPanel
.
featureGate
"
)
;
}
handleProtectionsButtonEvent
(
event
)
{
event
.
stopPropagation
(
)
;
if
(
(
event
.
type
=
=
"
click
"
&
&
event
.
button
!
=
0
)
|
|
(
event
.
type
=
=
"
keypress
"
&
&
event
.
charCode
!
=
KeyEvent
.
DOM_VK_SPACE
&
&
event
.
keyCode
!
=
KeyEvent
.
DOM_VK_RETURN
)
)
{
return
;
}
this
.
showPopup
(
{
event
openingReason
:
"
shieldButtonClicked
"
}
)
;
}
onContentBlockingEvent
(
event
_webProgress
_isSimulated
_previousState
)
{
if
(
!
this
.
#
enabled
)
{
return
;
}
this
.
anyDetected
=
false
;
this
.
anyBlocking
=
false
;
this
.
#
lastEvent
=
event
;
this
.
hasException
=
ContentBlockingAllowList
.
canHandle
(
window
.
gBrowser
.
selectedBrowser
)
&
&
ContentBlockingAllowList
.
includes
(
window
.
gBrowser
.
selectedBrowser
)
;
for
(
let
blocker
of
Object
.
values
(
this
.
#
blockers
)
)
{
blocker
.
activated
=
blocker
.
isBlocking
(
event
)
;
this
.
anyDetected
=
this
.
anyDetected
|
|
blocker
.
isDetected
(
event
)
;
this
.
anyBlocking
=
this
.
anyBlocking
|
|
blocker
.
activated
;
}
}
#
initializePopup
(
)
{
if
(
!
this
.
#
popup
)
{
let
wrapper
=
document
.
getElementById
(
"
template
-
trustpanel
-
popup
"
)
;
wrapper
.
replaceWith
(
wrapper
.
content
)
;
document
.
getElementById
(
"
trustpanel
-
popup
-
connection
"
)
.
addEventListener
(
"
click
"
event
=
>
this
.
#
openSecurityInformationSubview
(
event
)
)
;
document
.
getElementById
(
"
trustpanel
-
blocker
-
see
-
all
"
)
.
addEventListener
(
"
click
"
event
=
>
this
.
#
openBlockerSubview
(
event
)
)
;
document
.
getElementById
(
"
trustpanel
-
privacy
-
link
"
)
.
addEventListener
(
"
click
"
(
)
=
>
window
.
openTrustedLinkIn
(
"
about
:
preferences
#
privacy
"
"
tab
"
)
)
;
document
.
getElementById
(
"
trustpanel
-
clear
-
cookies
-
button
"
)
.
addEventListener
(
"
click
"
event
=
>
this
.
#
showClearCookiesSubview
(
event
)
)
;
document
.
getElementById
(
"
trustpanel
-
siteinformation
-
morelink
"
)
.
addEventListener
(
"
click
"
(
)
=
>
this
.
#
showSecurityPopup
(
)
)
;
document
.
getElementById
(
"
trustpanel
-
clear
-
cookie
-
cancel
"
)
.
addEventListener
(
"
click
"
(
)
=
>
this
.
#
hidePopup
(
)
)
;
document
.
getElementById
(
"
trustpanel
-
clear
-
cookie
-
clear
"
)
.
addEventListener
(
"
click
"
(
)
=
>
this
.
#
clearSiteData
(
)
)
;
document
.
getElementById
(
"
trustpanel
-
toggle
"
)
.
addEventListener
(
"
click
"
(
)
=
>
this
.
#
toggleTrackingProtection
(
)
)
;
document
.
getElementById
(
"
identity
-
popup
-
remove
-
cert
-
exception
"
)
.
addEventListener
(
"
click
"
(
)
=
>
this
.
#
removeCertException
(
)
)
;
document
.
getElementById
(
"
trustpanel
-
popup
-
security
-
httpsonlymode
-
menulist
"
)
.
addEventListener
(
"
command
"
(
)
=
>
this
.
#
changeHttpsOnlyPermission
(
)
)
;
this
.
#
popup
.
addEventListener
(
"
popupshown
"
this
)
;
}
}
showPopup
(
opts
=
{
}
)
{
this
.
#
initializePopup
(
)
;
this
.
#
updatePopup
(
)
;
this
.
#
openingReason
=
opts
.
reason
;
let
anchor
=
document
.
getElementById
(
"
trust
-
icon
-
container
"
)
;
PanelMultiView
.
openPopup
(
this
.
#
popup
anchor
{
position
:
"
bottomleft
topleft
"
}
)
;
}
async
#
hidePopup
(
)
{
let
hidden
=
new
Promise
(
c
=
>
{
this
.
#
popup
.
addEventListener
(
"
popuphidden
"
c
{
once
:
true
}
)
;
}
)
;
PanelMultiView
.
hidePopup
(
this
.
#
popup
)
;
await
hidden
;
}
updateIdentity
(
state
uri
)
{
if
(
!
this
.
#
enabled
)
{
return
;
}
try
{
this
.
#
uriHasHost
=
!
!
uri
.
host
;
}
catch
(
ex
)
{
this
.
#
uriHasHost
=
false
;
}
this
.
#
state
=
state
;
this
.
#
uri
=
uri
;
this
.
#
secInfo
=
gBrowser
.
securityUI
.
secInfo
;
this
.
#
pageExtensionPolicy
=
WebExtensionPolicy
.
getByURI
(
uri
)
;
this
.
#
isSecureContext
=
this
.
#
getIsSecureContext
(
)
;
this
.
#
isSecureInternalUI
=
false
;
if
(
this
.
#
uri
.
schemeIs
(
"
about
"
)
)
{
let
module
=
E10SUtils
.
getAboutModule
(
this
.
#
uri
)
;
if
(
module
)
{
let
flags
=
module
.
getURIFlags
(
this
.
#
uri
)
;
this
.
#
isSecureInternalUI
=
!
!
(
flags
&
Ci
.
nsIAboutModule
.
IS_SECURE_CHROME_UI
)
;
}
}
this
.
#
updateUrlbarIcon
(
)
;
}
#
updateUrlbarIcon
(
)
{
let
icon
=
document
.
getElementById
(
"
trust
-
icon
-
container
"
)
;
icon
.
className
=
this
.
#
isSecurePage
(
)
?
"
secure
"
:
"
insecure
"
;
if
(
this
.
#
isURILoadedFromFile
)
{
icon
.
classList
.
add
(
"
file
"
)
;
}
if
(
!
this
.
#
trackingProtectionEnabled
)
{
icon
.
classList
.
add
(
"
inactive
"
)
;
}
icon
.
classList
.
toggle
(
"
chickletShown
"
this
.
#
isSecureInternalUI
)
;
}
async
#
updatePopup
(
)
{
let
secureConnection
=
this
.
#
isSecurePage
(
)
;
let
connection
=
secureConnection
?
"
secure
"
:
"
not
-
secure
"
;
this
.
#
popup
.
setAttribute
(
"
connection
"
connection
)
;
this
.
#
popup
.
setAttribute
(
"
tracking
-
protection
"
this
.
#
trackingProtectionStatus
(
)
)
;
let
assets
=
this
.
#
trackingProtectionEnabled
?
ETP_ENABLED_ASSETS
:
ETP_DISABLED_ASSETS
;
let
host
=
window
.
gIdentityHandler
.
getHostForDisplay
(
)
;
this
.
host
=
host
;
if
(
this
.
#
uri
)
{
let
favicon
=
await
PlacesUtils
.
favicons
.
getFaviconForPage
(
this
.
#
uri
)
;
document
.
getElementById
(
"
trustpanel
-
popup
-
icon
"
)
.
src
=
favicon
?
.
uri
.
spec
?
?
"
"
;
}
let
toggle
=
document
.
getElementById
(
"
trustpanel
-
toggle
"
)
;
toggle
.
toggleAttribute
(
"
pressed
"
this
.
#
trackingProtectionEnabled
)
;
document
.
l10n
.
setAttributes
(
toggle
this
.
#
trackingProtectionEnabled
?
"
trustpanel
-
etp
-
toggle
-
on
"
:
"
trustpanel
-
etp
-
toggle
-
off
"
{
host
}
)
;
let
hostElement
=
document
.
getElementById
(
"
trustpanel
-
popup
-
host
"
)
;
hostElement
.
setAttribute
(
"
value
"
host
)
;
hostElement
.
setAttribute
(
"
tooltiptext
"
host
)
;
document
.
l10n
.
setAttributes
(
document
.
getElementById
(
"
trustpanel
-
etp
-
label
"
)
assets
.
label
)
;
document
.
l10n
.
setAttributes
(
document
.
getElementById
(
"
trustpanel
-
etp
-
description
"
)
assets
.
description
)
;
document
.
l10n
.
setAttributes
(
document
.
getElementById
(
"
trustpanel
-
header
"
)
assets
.
header
)
;
document
.
l10n
.
setAttributes
(
document
.
getElementById
(
"
trustpanel
-
description
"
)
assets
.
innerDescription
)
;
document
.
l10n
.
setAttributes
(
document
.
getElementById
(
"
trustpanel
-
connection
-
label
"
)
secureConnection
?
"
trustpanel
-
connection
-
label
-
secure
"
:
"
trustpanel
-
connection
-
label
-
insecure
"
)
;
let
canHandle
=
ContentBlockingAllowList
.
canHandle
(
window
.
gBrowser
.
selectedBrowser
)
;
document
.
getElementById
(
"
trustpanel
-
toggle
"
)
.
toggleAttribute
(
"
disabled
"
!
canHandle
)
;
document
.
getElementById
(
"
trustpanel
-
toggle
-
section
"
)
.
toggleAttribute
(
"
disabled
"
!
canHandle
)
;
if
(
!
this
.
anyDetected
)
{
document
.
getElementById
(
"
trustpanel
-
blocker
-
section
"
)
.
hidden
=
true
;
}
else
{
let
count
=
this
.
#
fetchSmartBlocked
(
)
.
length
;
let
blocked
=
[
]
;
let
detected
=
[
]
;
for
(
let
blocker
of
Object
.
values
(
this
.
#
blockers
)
)
{
if
(
blocker
.
isBlocking
(
this
.
#
lastEvent
)
)
{
blocked
.
push
(
blocker
)
;
count
+
=
await
blocker
.
getBlockerCount
(
)
;
}
else
if
(
blocker
.
isDetected
(
this
.
#
lastEvent
)
)
{
detected
.
push
(
blocker
)
;
}
}
document
.
l10n
.
setArgs
(
document
.
getElementById
(
"
trustpanel
-
blocker
-
section
-
header
"
)
{
count
}
)
;
this
.
#
addButtons
(
"
trustpanel
-
blocked
"
blocked
true
)
;
this
.
#
addButtons
(
"
trustpanel
-
detected
"
detected
false
)
;
document
.
getElementById
(
"
trustpanel
-
blocker
-
section
"
)
.
removeAttribute
(
"
hidden
"
)
;
document
.
getElementById
(
"
trustpanel
-
smartblock
-
section
"
)
.
toggleAttribute
(
"
hidden
"
!
this
.
#
addSmartblockEmbedToggles
(
)
)
;
}
}
async
#
showSecurityPopup
(
)
{
await
this
.
#
hidePopup
(
)
;
window
.
BrowserCommands
.
pageInfo
(
null
"
securityTab
"
)
;
}
#
removeCertException
(
)
{
let
overrideService
=
Cc
[
"
mozilla
.
org
/
security
/
certoverride
;
1
"
]
.
getService
(
Ci
.
nsICertOverrideService
)
;
overrideService
.
clearValidityOverride
(
this
.
#
uri
.
host
this
.
#
uri
.
port
>
0
?
this
.
#
uri
.
port
:
443
gBrowser
.
contentPrincipal
.
originAttributes
)
;
BrowserCommands
.
reloadSkipCache
(
)
;
PanelMultiView
.
hidePopup
(
this
.
#
popup
)
;
}
#
trackingProtectionStatus
(
)
{
if
(
!
this
.
#
isSecurePage
(
)
)
{
return
"
warning
"
;
}
return
this
.
#
trackingProtectionEnabled
?
"
enabled
"
:
"
disabled
"
;
}
#
openSecurityInformationSubview
(
event
)
{
document
.
l10n
.
setAttributes
(
document
.
getElementById
(
"
trustpanel
-
securityInformationView
"
)
"
trustpanel
-
site
-
information
-
header
"
{
host
:
this
.
host
}
)
;
let
customRoot
=
this
.
#
isSecureConnection
?
this
.
#
hasCustomRoot
(
)
:
false
;
let
connection
=
this
.
#
connectionState
(
)
;
let
mixedcontent
=
this
.
#
mixedContentState
(
)
;
let
ciphers
=
this
.
#
ciphersState
(
)
;
let
httpsOnlyStatus
=
this
.
#
httpsOnlyState
(
)
;
let
elementIDs
=
[
"
trustpanel
-
popup
"
"
identity
-
popup
-
securityView
-
extended
-
info
"
]
;
for
(
let
id
of
elementIDs
)
{
let
element
=
document
.
getElementById
(
id
)
;
this
.
#
updateAttribute
(
element
"
connection
"
connection
)
;
this
.
#
updateAttribute
(
element
"
ciphers
"
ciphers
)
;
this
.
#
updateAttribute
(
element
"
mixedcontent
"
mixedcontent
)
;
this
.
#
updateAttribute
(
element
"
isbroken
"
this
.
#
isBrokenConnection
)
;
this
.
#
updateAttribute
(
element
"
customroot
"
customRoot
)
;
this
.
#
updateAttribute
(
element
"
httpsonlystatus
"
httpsOnlyStatus
)
;
}
let
{
supplemental
owner
verifier
}
=
this
.
#
supplementalText
(
)
;
document
.
getElementById
(
"
identity
-
popup
-
content
-
supplemental
"
)
.
textContent
=
supplemental
;
document
.
getElementById
(
"
identity
-
popup
-
content
-
verifier
"
)
.
textContent
=
verifier
;
document
.
getElementById
(
"
identity
-
popup
-
content
-
owner
"
)
.
textContent
=
owner
;
document
.
getElementById
(
"
trustpanel
-
popup
-
multiView
"
)
.
showSubView
(
"
trustpanel
-
securityInformationView
"
event
.
target
)
;
}
async
#
openBlockerSubview
(
event
)
{
document
.
l10n
.
setAttributes
(
document
.
getElementById
(
"
trustpanel
-
blockerView
"
)
"
trustpanel
-
blocker
-
header
"
{
host
:
this
.
host
}
)
;
document
.
getElementById
(
"
trustpanel
-
popup
-
multiView
"
)
.
showSubView
(
"
trustpanel
-
blockerView
"
event
.
target
)
;
}
async
#
openBlockerDetailsSubview
(
event
blocker
blocking
)
{
let
count
=
await
blocker
.
getBlockerCount
(
)
;
let
blockingKey
=
blocking
?
"
blocking
"
:
"
not
-
blocking
"
;
document
.
l10n
.
setAttributes
(
document
.
getElementById
(
"
trustpanel
-
blockerDetailsView
"
)
blocker
.
l10nKeys
.
title
[
blockingKey
]
)
;
document
.
l10n
.
setAttributes
(
document
.
getElementById
(
"
trustpanel
-
blocker
-
details
-
header
"
)
trustpanel
-
{
blocker
.
l10nKeys
.
general
}
-
{
blockingKey
}
-
tab
-
header
{
count
}
)
;
document
.
l10n
.
setAttributes
(
document
.
getElementById
(
"
trustpanel
-
blocker
-
details
-
content
"
)
protections
-
panel
-
{
blocker
.
l10nKeys
.
content
}
)
;
let
listHeaderId
;
if
(
blocker
.
l10nKeys
.
general
=
=
"
fingerprinter
"
)
{
listHeaderId
=
"
trustpanel
-
fingerprinter
-
list
-
header
"
;
}
else
if
(
blocker
.
l10nKeys
.
general
=
=
"
cryptominer
"
)
{
listHeaderId
=
"
trustpanel
-
cryptominer
-
tab
-
list
-
header
"
;
}
else
{
listHeaderId
=
"
trustpanel
-
tracking
-
content
-
tab
-
list
-
header
"
;
}
document
.
l10n
.
setAttributes
(
document
.
getElementById
(
"
trustpanel
-
blocker
-
details
-
list
-
header
"
)
listHeaderId
)
;
let
{
items
}
=
await
blocker
.
_generateSubViewListItems
(
)
;
document
.
getElementById
(
"
trustpanel
-
blocker
-
items
"
)
.
replaceChildren
(
items
)
;
document
.
getElementById
(
"
trustpanel
-
popup
-
multiView
"
)
.
showSubView
(
"
trustpanel
-
blockerDetailsView
"
event
.
target
)
;
}
async
#
showClearCookiesSubview
(
event
)
{
document
.
l10n
.
setAttributes
(
document
.
getElementById
(
"
trustpanel
-
clearcookiesView
"
)
"
trustpanel
-
clear
-
cookies
-
header
"
{
host
:
window
.
gIdentityHandler
.
getHostForDisplay
(
)
}
)
;
document
.
getElementById
(
"
trustpanel
-
popup
-
multiView
"
)
.
showSubView
(
"
trustpanel
-
clearcookiesView
"
event
.
target
)
;
}
async
#
addButtons
(
section
blockers
blocking
)
{
let
sectionElement
=
document
.
getElementById
(
section
)
;
if
(
!
blockers
.
length
)
{
sectionElement
.
hidden
=
true
;
return
;
}
let
children
=
blockers
.
map
(
async
blocker
=
>
{
let
button
=
document
.
createElement
(
"
moz
-
button
"
)
;
button
.
classList
.
add
(
"
moz
-
button
-
subviewbutton
-
nav
"
)
;
button
.
setAttribute
(
"
iconsrc
"
blocker
.
iconSrc
)
;
button
.
setAttribute
(
"
type
"
"
ghost
icon
"
)
;
document
.
l10n
.
setAttributes
(
button
trustpanel
-
list
-
label
-
{
blocker
.
l10nKeys
.
general
}
{
count
:
await
blocker
.
getBlockerCount
(
)
}
)
;
button
.
addEventListener
(
"
click
"
event
=
>
this
.
#
openBlockerDetailsSubview
(
event
blocker
blocking
)
)
;
return
button
;
}
)
;
sectionElement
.
hidden
=
false
;
sectionElement
.
querySelector
(
"
.
trustpanel
-
blocker
-
buttons
"
)
.
replaceChildren
(
.
.
.
(
await
Promise
.
all
(
children
)
)
)
;
}
get
#
trackingProtectionEnabled
(
)
{
return
(
!
ContentBlockingAllowList
.
canHandle
(
window
.
gBrowser
.
selectedBrowser
)
|
|
!
ContentBlockingAllowList
.
includes
(
window
.
gBrowser
.
selectedBrowser
)
)
;
}
#
isSecurePage
(
)
{
return
(
this
.
#
state
&
Ci
.
nsIWebProgressListener
.
STATE_IS_SECURE
|
|
this
.
#
isInternalSecurePage
(
this
.
#
uri
)
|
|
this
.
#
isPotentiallyTrustworthy
)
;
}
#
isInternalSecurePage
(
uri
)
{
if
(
uri
&
&
uri
.
schemeIs
(
"
about
"
)
)
{
let
module
=
E10SUtils
.
getAboutModule
(
uri
)
;
if
(
module
)
{
let
flags
=
module
.
getURIFlags
(
uri
)
;
if
(
flags
&
Ci
.
nsIAboutModule
.
IS_SECURE_CHROME_UI
)
{
return
true
;
}
}
}
return
false
;
}
#
clearSiteData
(
)
{
let
baseDomain
=
SiteDataManager
.
getBaseDomainFromHost
(
this
.
#
uri
.
host
)
;
SiteDataManager
.
remove
(
baseDomain
)
;
this
.
#
hidePopup
(
)
;
}
#
toggleTrackingProtection
(
)
{
if
(
this
.
#
trackingProtectionEnabled
)
{
ContentBlockingAllowList
.
add
(
window
.
gBrowser
.
selectedBrowser
)
;
}
else
{
ContentBlockingAllowList
.
remove
(
window
.
gBrowser
.
selectedBrowser
)
;
}
PanelMultiView
.
hidePopup
(
this
.
#
popup
)
;
window
.
BrowserCommands
.
reload
(
)
;
}
#
isHttpsOnlyModeActive
(
isWindowPrivate
)
{
return
httpsOnlyModeEnabled
|
|
(
isWindowPrivate
&
&
httpsOnlyModeEnabledPBM
)
;
}
#
isHttpsFirstModeActive
(
isWindowPrivate
)
{
return
(
!
this
.
#
isHttpsOnlyModeActive
(
isWindowPrivate
)
&
&
(
httpsFirstModeEnabled
|
|
(
isWindowPrivate
&
&
httpsFirstModeEnabledPBM
)
)
)
;
}
#
isSchemelessHttpsFirstModeActive
(
isWindowPrivate
)
{
return
(
!
this
.
#
isHttpsOnlyModeActive
(
isWindowPrivate
)
&
&
!
this
.
#
isHttpsFirstModeActive
(
isWindowPrivate
)
&
&
schemelessHttpsFirstModeEnabled
)
;
}
#
getIdentityData
(
)
{
var
result
=
{
}
;
var
cert
=
this
.
#
secInfo
.
serverCert
;
result
.
subjectOrg
=
cert
.
organization
;
if
(
cert
.
subjectName
)
{
result
.
subjectNameFields
=
{
}
;
cert
.
subjectName
.
split
(
"
"
)
.
forEach
(
function
(
v
)
{
var
field
=
v
.
split
(
"
=
"
)
;
this
[
field
[
0
]
]
=
field
[
1
]
;
}
result
.
subjectNameFields
)
;
result
.
city
=
result
.
subjectNameFields
.
L
;
result
.
state
=
result
.
subjectNameFields
.
ST
;
result
.
country
=
result
.
subjectNameFields
.
C
;
}
result
.
caOrg
=
cert
.
issuerOrganization
|
|
cert
.
issuerCommonName
;
result
.
cert
=
cert
;
return
result
;
}
#
getIsSecureContext
(
)
{
if
(
gBrowser
.
contentPrincipal
?
.
originNoSuffix
!
=
"
resource
:
/
/
pdf
.
js
"
)
{
return
gBrowser
.
securityUI
.
isSecureContext
;
}
let
principal
;
try
{
principal
=
Services
.
scriptSecurityManager
.
createContentPrincipal
(
gBrowser
.
selectedBrowser
.
documentURI
{
}
)
;
return
principal
.
isOriginPotentiallyTrustworthy
;
}
catch
(
error
)
{
console
.
error
(
"
Error
while
computing
isPotentiallyTrustWorthy
for
pdf
viewer
page
:
"
error
)
;
return
false
;
}
}
#
hasCustomRoot
(
)
{
return
!
this
.
#
secInfo
.
isBuiltCertChainRootBuiltInRoot
;
}
get
#
isBrokenConnection
(
)
{
return
this
.
#
state
&
Ci
.
nsIWebProgressListener
.
STATE_IS_BROKEN
;
}
get
#
isSecureConnection
(
)
{
return
(
!
this
.
#
isURILoadedFromFile
&
&
this
.
#
state
&
Ci
.
nsIWebProgressListener
.
STATE_IS_SECURE
)
;
}
get
#
isEV
(
)
{
return
(
!
this
.
#
isURILoadedFromFile
&
&
this
.
#
state
&
Ci
.
nsIWebProgressListener
.
STATE_IDENTITY_EV_TOPLEVEL
)
;
}
get
#
isAssociatedIdentity
(
)
{
return
this
.
#
state
&
Ci
.
nsIWebProgressListener
.
STATE_IDENTITY_ASSOCIATED
;
}
get
#
isMixedActiveContentLoaded
(
)
{
return
(
this
.
#
state
&
Ci
.
nsIWebProgressListener
.
STATE_LOADED_MIXED_ACTIVE_CONTENT
)
;
}
get
#
isMixedActiveContentBlocked
(
)
{
return
(
this
.
#
state
&
Ci
.
nsIWebProgressListener
.
STATE_BLOCKED_MIXED_ACTIVE_CONTENT
)
;
}
get
#
isMixedPassiveContentLoaded
(
)
{
return
(
this
.
#
state
&
Ci
.
nsIWebProgressListener
.
STATE_LOADED_MIXED_DISPLAY_CONTENT
)
;
}
get
#
isContentHttpsOnlyModeUpgraded
(
)
{
return
(
this
.
#
state
&
Ci
.
nsIWebProgressListener
.
STATE_HTTPS_ONLY_MODE_UPGRADED
)
;
}
get
#
isContentHttpsOnlyModeUpgradeFailed
(
)
{
return
(
this
.
#
state
&
Ci
.
nsIWebProgressListener
.
STATE_HTTPS_ONLY_MODE_UPGRADE_FAILED
)
;
}
get
#
isContentHttpsFirstModeUpgraded
(
)
{
return
(
this
.
#
state
&
Ci
.
nsIWebProgressListener
.
STATE_HTTPS_ONLY_MODE_UPGRADED_FIRST
)
;
}
get
#
isCertUserOverridden
(
)
{
return
this
.
#
state
&
Ci
.
nsIWebProgressListener
.
STATE_CERT_USER_OVERRIDDEN
;
}
get
#
isCertErrorPage
(
)
{
let
{
documentURI
}
=
gBrowser
.
selectedBrowser
;
if
(
documentURI
?
.
scheme
!
=
"
about
"
)
{
return
false
;
}
return
(
documentURI
.
filePath
=
=
"
certerror
"
|
|
(
documentURI
.
filePath
=
=
"
neterror
"
&
&
new
URLSearchParams
(
documentURI
.
query
)
.
get
(
"
e
"
)
=
=
"
nssFailure2
"
)
)
;
}
get
#
isSecurelyConnectedAboutNetErrorPage
(
)
{
let
{
documentURI
}
=
gBrowser
.
selectedBrowser
;
if
(
documentURI
?
.
scheme
!
=
"
about
"
|
|
documentURI
.
filePath
!
=
"
neterror
"
)
{
return
false
;
}
let
error
=
new
URLSearchParams
(
documentURI
.
query
)
.
get
(
"
e
"
)
;
return
error
=
=
=
"
httpErrorPage
"
|
|
error
=
=
=
"
serverError
"
;
}
get
#
isAboutNetErrorPage
(
)
{
let
{
documentURI
}
=
gBrowser
.
selectedBrowser
;
return
documentURI
?
.
scheme
=
=
"
about
"
&
&
documentURI
.
filePath
=
=
"
neterror
"
;
}
get
#
isAboutHttpsOnlyErrorPage
(
)
{
let
{
documentURI
}
=
gBrowser
.
selectedBrowser
;
return
(
documentURI
?
.
scheme
=
=
"
about
"
&
&
documentURI
.
filePath
=
=
"
httpsonlyerror
"
)
;
}
get
#
isPotentiallyTrustworthy
(
)
{
return
(
!
this
.
#
isBrokenConnection
&
&
(
this
.
#
isSecureContext
|
|
gBrowser
.
selectedBrowser
.
documentURI
?
.
scheme
=
=
"
chrome
"
)
)
;
}
get
#
isAboutBlockedPage
(
)
{
let
{
documentURI
}
=
gBrowser
.
selectedBrowser
;
return
documentURI
?
.
scheme
=
=
"
about
"
&
&
documentURI
.
filePath
=
=
"
blocked
"
;
}
get
#
isURILoadedFromFile
(
)
{
return
this
.
#
uri
.
schemeIs
(
"
file
"
)
;
}
#
supplementalText
(
)
{
let
supplemental
=
"
"
;
let
verifier
=
"
"
;
let
owner
=
"
"
;
if
(
this
.
#
isSecureConnection
|
|
this
.
#
isCertUserOverridden
)
{
verifier
=
this
.
#
tooltipText
(
)
;
}
if
(
this
.
#
isEV
)
{
let
iData
=
this
.
#
getIdentityData
(
)
;
owner
=
iData
.
subjectOrg
;
verifier
=
this
.
_identityIconLabel
.
tooltipText
;
if
(
iData
.
city
)
{
supplemental
+
=
iData
.
city
+
"
\
n
"
;
}
if
(
iData
.
state
&
&
iData
.
country
)
{
supplemental
+
=
gNavigatorBundle
.
getFormattedString
(
"
identity
.
identified
.
state_and_country
"
[
iData
.
state
iData
.
country
]
)
;
}
else
if
(
iData
.
state
)
{
supplemental
+
=
iData
.
state
;
}
else
if
(
iData
.
country
)
{
supplemental
+
=
iData
.
country
;
}
}
return
{
supplemental
verifier
owner
}
;
}
#
tooltipText
(
)
{
let
tooltip
=
"
"
;
let
warnTextOnInsecure
=
insecureConnectionTextEnabled
|
|
(
insecureConnectionTextPBModeEnabled
&
&
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
;
if
(
this
.
#
uriHasHost
&
&
this
.
#
isSecureConnection
)
{
if
(
!
this
.
_isCertUserOverridden
)
{
tooltip
=
gNavigatorBundle
.
getFormattedString
(
"
identity
.
identified
.
verifier
"
[
this
.
#
getIdentityData
(
)
.
caOrg
]
)
;
}
}
else
if
(
this
.
#
isBrokenConnection
)
{
if
(
this
.
#
isMixedActiveContentLoaded
)
{
this
.
_identityBox
.
classList
.
add
(
"
mixedActiveContent
"
)
;
if
(
UrlbarPrefs
.
getScotchBonnetPref
(
"
trimHttps
"
)
&
&
warnTextOnInsecure
)
{
tooltip
=
gNavigatorBundle
.
getString
(
"
identity
.
notSecure
.
tooltip
"
)
;
}
}
}
else
if
(
!
this
.
#
isPotentiallyTrustworthy
)
{
tooltip
=
gNavigatorBundle
.
getString
(
"
identity
.
notSecure
.
tooltip
"
)
;
}
if
(
this
.
_isCertUserOverridden
)
{
tooltip
=
gNavigatorBundle
.
getString
(
"
identity
.
identified
.
verified_by_you
"
)
;
}
return
tooltip
;
}
#
connectionState
(
)
{
let
connection
=
"
not
-
secure
"
;
if
(
this
.
#
isSecureInternalUI
)
{
connection
=
"
chrome
"
;
}
else
if
(
this
.
#
pageExtensionPolicy
)
{
connection
=
"
extension
"
;
}
else
if
(
this
.
#
isURILoadedFromFile
)
{
connection
=
"
file
"
;
}
else
if
(
this
.
#
isEV
)
{
connection
=
"
secure
-
ev
"
;
}
else
if
(
this
.
#
isCertUserOverridden
)
{
connection
=
"
secure
-
cert
-
user
-
overridden
"
;
}
else
if
(
this
.
#
isSecureConnection
)
{
connection
=
"
secure
"
;
}
else
if
(
this
.
#
isCertErrorPage
)
{
connection
=
"
cert
-
error
-
page
"
;
}
else
if
(
this
.
#
isAboutHttpsOnlyErrorPage
)
{
connection
=
"
https
-
only
-
error
-
page
"
;
}
else
if
(
this
.
#
isAboutBlockedPage
)
{
connection
=
"
not
-
secure
"
;
}
else
if
(
this
.
#
isSecurelyConnectedAboutNetErrorPage
)
{
connection
=
"
secure
"
;
}
else
if
(
this
.
#
isAboutNetErrorPage
)
{
connection
=
"
net
-
error
-
page
"
;
}
else
if
(
this
.
#
isAssociatedIdentity
)
{
connection
=
"
associated
"
;
}
else
if
(
this
.
#
isPotentiallyTrustworthy
)
{
connection
=
"
file
"
;
}
return
connection
;
}
#
mixedContentState
(
)
{
let
mixedcontent
=
[
]
;
if
(
this
.
#
isMixedPassiveContentLoaded
)
{
mixedcontent
.
push
(
"
passive
-
loaded
"
)
;
}
if
(
this
.
#
isMixedActiveContentLoaded
)
{
mixedcontent
.
push
(
"
active
-
loaded
"
)
;
}
else
if
(
this
.
#
isMixedActiveContentBlocked
)
{
mixedcontent
.
push
(
"
active
-
blocked
"
)
;
}
return
mixedcontent
;
}
#
ciphersState
(
)
{
if
(
this
.
#
isBrokenConnection
&
&
!
this
.
#
isMixedActiveContentLoaded
&
&
!
this
.
#
isMixedPassiveContentLoaded
)
{
return
"
weak
"
;
}
return
"
"
;
}
#
httpsOnlyState
(
)
{
const
privateBrowsingWindow
=
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
;
const
isHttpsOnlyModeActive
=
this
.
#
isHttpsOnlyModeActive
(
privateBrowsingWindow
)
;
const
isHttpsFirstModeActive
=
this
.
#
isHttpsFirstModeActive
(
privateBrowsingWindow
)
;
const
isSchemelessHttpsFirstModeActive
=
this
.
#
isSchemelessHttpsFirstModeActive
(
privateBrowsingWindow
)
;
let
httpsOnlyStatus
=
"
"
;
if
(
isHttpsFirstModeActive
|
|
isHttpsOnlyModeActive
|
|
isSchemelessHttpsFirstModeActive
)
{
let
value
=
this
.
#
getHttpsOnlyPermission
(
)
;
document
.
getElementById
(
"
trustpanel
-
popup
-
security
-
httpsonlymode
"
)
.
hidden
=
isSchemelessHttpsFirstModeActive
;
document
.
getElementById
(
"
trustpanel
-
popup
-
security
-
menulist
-
off
-
item
"
)
.
hidden
=
privateBrowsingWindow
&
&
value
!
=
1
;
document
.
getElementById
(
"
trustpanel
-
popup
-
security
-
httpsonlymode
-
menulist
"
)
.
value
=
value
;
if
(
value
>
0
)
{
httpsOnlyStatus
=
"
exception
"
;
}
else
if
(
this
.
#
isAboutHttpsOnlyErrorPage
|
|
(
isHttpsFirstModeActive
&
&
this
.
#
isContentHttpsOnlyModeUpgradeFailed
)
)
{
httpsOnlyStatus
=
"
failed
-
top
"
;
}
else
if
(
this
.
#
isContentHttpsOnlyModeUpgradeFailed
)
{
httpsOnlyStatus
=
"
failed
-
sub
"
;
}
else
if
(
this
.
#
isContentHttpsOnlyModeUpgraded
|
|
this
.
#
isContentHttpsFirstModeUpgraded
)
{
httpsOnlyStatus
=
"
upgraded
"
;
}
}
return
httpsOnlyStatus
;
}
#
getHttpsOnlyPermission
(
)
{
let
uri
=
gBrowser
.
currentURI
;
if
(
uri
instanceof
Ci
.
nsINestedURI
)
{
uri
=
uri
.
QueryInterface
(
Ci
.
nsINestedURI
)
.
innermostURI
;
}
if
(
!
uri
.
schemeIs
(
"
http
"
)
&
&
!
uri
.
schemeIs
(
"
https
"
)
)
{
return
-
1
;
}
uri
=
uri
.
mutate
(
)
.
setScheme
(
"
http
"
)
.
finalize
(
)
;
const
principal
=
Services
.
scriptSecurityManager
.
createContentPrincipal
(
uri
gBrowser
.
contentPrincipal
.
originAttributes
)
;
const
{
state
}
=
SitePermissions
.
getForPrincipal
(
principal
"
https
-
only
-
load
-
insecure
"
)
;
switch
(
state
)
{
case
Ci
.
nsIHttpsOnlyModePermission
.
LOAD_INSECURE_ALLOW_SESSION
:
return
2
;
case
Ci
.
nsIHttpsOnlyModePermission
.
LOAD_INSECURE_ALLOW
:
return
1
;
default
:
return
0
;
}
}
#
changeHttpsOnlyPermission
(
)
{
const
oldValue
=
this
.
#
getHttpsOnlyPermission
(
)
;
if
(
oldValue
<
0
)
{
console
.
error
(
"
Did
not
update
HTTPS
-
Only
permission
since
scheme
is
incompatible
"
)
;
return
;
}
let
menulist
=
document
.
getElementById
(
"
trustpanel
-
popup
-
security
-
httpsonlymode
-
menulist
"
)
;
let
newValue
=
parseInt
(
menulist
.
selectedItem
.
value
10
)
;
if
(
newValue
=
=
=
oldValue
)
{
return
;
}
let
newURI
=
gBrowser
.
currentURI
;
if
(
newURI
instanceof
Ci
.
nsINestedURI
)
{
newURI
=
newURI
.
QueryInterface
(
Ci
.
nsINestedURI
)
.
innermostURI
;
}
newURI
=
newURI
.
mutate
(
)
.
setScheme
(
"
http
"
)
.
finalize
(
)
;
const
principal
=
Services
.
scriptSecurityManager
.
createContentPrincipal
(
newURI
gBrowser
.
contentPrincipal
.
originAttributes
)
;
if
(
newValue
=
=
=
0
)
{
SitePermissions
.
removeFromPrincipal
(
principal
"
https
-
only
-
load
-
insecure
"
)
;
}
else
if
(
newValue
=
=
=
1
)
{
SitePermissions
.
setForPrincipal
(
principal
"
https
-
only
-
load
-
insecure
"
Ci
.
nsIHttpsOnlyModePermission
.
LOAD_INSECURE_ALLOW
SitePermissions
.
SCOPE_PERSISTENT
)
;
}
else
{
SitePermissions
.
setForPrincipal
(
principal
"
https
-
only
-
load
-
insecure
"
Ci
.
nsIHttpsOnlyModePermission
.
LOAD_INSECURE_ALLOW_SESSION
SitePermissions
.
SCOPE_SESSION
)
;
}
if
(
this
.
#
isAboutHttpsOnlyErrorPage
)
{
gBrowser
.
loadURI
(
newURI
{
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
loadFlags
:
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_REPLACE_HISTORY
}
)
;
PanelMultiView
.
hidePopup
(
this
.
#
popup
)
;
return
;
}
if
(
newValue
+
oldValue
!
=
=
3
)
{
BrowserCommands
.
reloadSkipCache
(
)
;
PanelMultiView
.
hidePopup
(
this
.
#
popup
)
;
gBrowser
.
selectedBrowser
.
focus
(
)
;
}
}
#
addSmartblockEmbedToggles
(
)
{
if
(
!
smartblockEmbedsEnabledPref
)
{
return
false
;
}
let
container
=
document
.
getElementById
(
"
trustpanel
-
smartblock
-
toggle
-
container
"
)
;
container
.
replaceChildren
(
)
;
let
contentBlockingEvents
=
gBrowser
.
selectedBrowser
.
getContentBlockingEvents
(
)
;
let
somethingAllowedOrReplaced
=
contentBlockingEvents
&
Ci
.
nsIWebProgressListener
.
STATE_ALLOWED_TRACKING_CONTENT
|
|
contentBlockingEvents
&
Ci
.
nsIWebProgressListener
.
STATE_REPLACED_TRACKING_CONTENT
;
if
(
!
somethingAllowedOrReplaced
)
{
return
false
;
}
let
blocked
=
this
.
#
fetchSmartBlocked
(
)
;
if
(
!
blocked
.
length
)
{
return
false
;
}
for
(
let
{
shimAllowed
shimInfo
}
of
blocked
)
{
const
{
shimId
displayName
}
=
shimInfo
;
let
existingToggle
=
document
.
getElementById
(
trustpanel
-
smartblock
-
{
shimId
.
toLowerCase
(
)
}
-
toggle
)
;
if
(
existingToggle
)
{
if
(
shimAllowed
)
{
existingToggle
.
setAttribute
(
"
pressed
"
true
)
;
}
continue
;
}
let
toggle
=
document
.
createElement
(
"
moz
-
toggle
"
)
;
toggle
.
setAttribute
(
"
id
"
trustpanel
-
smartblock
-
{
shimId
.
toLowerCase
(
)
}
-
toggle
)
;
toggle
.
setAttribute
(
"
data
-
l10n
-
attrs
"
"
label
"
)
;
document
.
l10n
.
setAttributes
(
toggle
"
protections
-
panel
-
smartblock
-
blocking
-
toggle
"
{
trackername
:
displayName
}
)
;
toggle
.
toggleAttribute
(
"
pressed
"
!
!
shimAllowed
)
;
toggle
.
addEventListener
(
"
toggle
"
event
=
>
{
if
(
event
.
target
.
pressed
)
{
this
.
#
sendUnblockMessageToSmartblock
(
shimId
)
;
}
else
{
this
.
#
sendReblockMessageToSmartblock
(
shimId
)
;
}
PanelMultiView
.
hidePopup
(
this
.
#
popup
)
;
}
)
;
container
.
insertAdjacentElement
(
"
beforeend
"
toggle
)
;
}
return
true
;
}
#
fetchSmartBlocked
(
)
{
let
blocked
=
[
]
;
let
contentBlockingLog
=
JSON
.
parse
(
gBrowser
.
selectedBrowser
.
getContentBlockingLog
(
)
)
;
for
(
let
[
origin
actions
]
of
Object
.
entries
(
contentBlockingLog
)
)
{
let
shimAllowed
=
actions
.
some
(
(
[
flag
]
)
=
>
(
flag
&
Ci
.
nsIWebProgressListener
.
STATE_ALLOWED_TRACKING_CONTENT
)
!
=
0
)
;
let
shimDetected
=
actions
.
some
(
(
[
flag
]
)
=
>
(
flag
&
Ci
.
nsIWebProgressListener
.
STATE_REPLACED_TRACKING_CONTENT
)
!
=
0
)
;
if
(
!
shimAllowed
&
&
!
shimDetected
)
{
continue
;
}
let
shimInfo
=
SMARTBLOCK_EMBED_INFO
.
find
(
element
=
>
{
let
matchPatternSet
=
new
MatchPatternSet
(
element
.
matchPatterns
)
;
return
matchPatternSet
.
matches
(
origin
)
;
}
)
;
if
(
!
shimInfo
)
{
continue
;
}
blocked
.
push
(
{
shimAllowed
shimInfo
}
)
;
}
return
blocked
;
}
async
observe
(
subject
topic
)
{
switch
(
topic
)
{
case
"
smartblock
:
open
-
protections
-
panel
"
:
{
if
(
gBrowser
.
selectedBrowser
.
browserId
!
=
=
subject
.
browserId
)
{
break
;
}
this
.
#
initializePopup
(
)
;
let
multiview
=
document
.
getElementById
(
"
trustpanel
-
popup
-
multiView
"
)
;
/
/
TODO
:
https
:
/
/
bugzilla
.
mozilla
.
org
/
show_bug
.
cgi
?
id
=
1999928
/
/
This
currently
opens
as
a
standalone
panel
we
would
like
to
open
/
/
the
panel
with
a
back
button
and
title
the
same
way
as
if
it
/
/
were
accessed
via
the
urlbar
icon
.
let
initialMainViewId
=
multiview
.
getAttribute
(
"
mainViewId
"
)
;
this
.
#
popup
.
addEventListener
(
"
popuphidden
"
(
)
=
>
{
multiview
.
setAttribute
(
"
mainViewId
"
initialMainViewId
)
;
}
{
once
:
true
}
)
;
multiview
.
setAttribute
(
"
mainViewId
"
"
trustpanel
-
blockerView
"
)
;
this
.
showPopup
(
{
reason
:
"
embedPlaceholderButton
"
}
)
;
break
;
}
}
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
popupshown
"
:
this
.
onPopupShown
(
event
)
;
break
;
}
}
onPopupShown
(
)
{
if
(
this
.
#
openingReason
=
=
"
embedPlaceholderButton
"
)
{
this
.
#
disablePopupToggles
(
)
;
this
.
#
popupToggleDelayTimer
=
setTimeout
(
(
)
=
>
{
this
.
#
enablePopupToggles
(
)
;
}
popupClickjackDelay
)
;
}
}
#
sendUnblockMessageToSmartblock
(
shimId
)
{
Services
.
obs
.
notifyObservers
(
gBrowser
.
selectedTab
"
smartblock
:
unblock
-
embed
"
shimId
)
;
}
#
sendReblockMessageToSmartblock
(
shimId
)
{
Services
.
obs
.
notifyObservers
(
gBrowser
.
selectedTab
"
smartblock
:
reblock
-
embed
"
shimId
)
;
}
#
resetToggleSecDelay
(
)
{
clearTimeout
(
this
.
#
popupToggleDelayTimer
)
;
this
.
#
popupToggleDelayTimer
=
setTimeout
(
(
)
=
>
{
this
.
#
enablePopupToggles
(
)
;
}
popupClickjackDelay
)
;
}
#
disablePopupToggles
(
)
{
this
.
#
popup
.
querySelectorAll
(
"
moz
-
toggle
"
)
.
forEach
(
toggle
=
>
{
toggle
.
setAttribute
(
"
disabled
"
true
)
;
toggle
.
addEventListener
(
"
pointerdown
"
this
.
#
resetToggleReference
)
;
}
)
;
}
#
resetToggleReference
=
this
.
#
resetToggleSecDelay
.
bind
(
this
)
;
#
enablePopupToggles
(
)
{
this
.
#
popup
.
querySelectorAll
(
"
moz
-
toggle
"
)
.
forEach
(
toggle
=
>
{
toggle
.
removeAttribute
(
"
disabled
"
)
;
toggle
.
removeEventListener
(
"
pointerdown
"
this
.
#
resetToggleReference
)
;
}
)
;
}
#
updateAttribute
(
elem
attr
value
)
{
if
(
value
)
{
elem
.
setAttribute
(
attr
value
)
;
}
else
{
elem
.
removeAttribute
(
attr
)
;
}
}
}
var
gTrustPanelHandler
=
new
TrustPanel
(
)
;
