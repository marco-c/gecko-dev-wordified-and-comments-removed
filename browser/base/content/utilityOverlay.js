var
{
AppConstants
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
sys
.
mjs
"
)
;
var
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
ChromeUtils
.
defineESModuleGetters
(
this
{
BrowserUtils
:
"
resource
:
/
/
gre
/
modules
/
BrowserUtils
.
sys
.
mjs
"
ContextualIdentityService
:
"
resource
:
/
/
gre
/
modules
/
ContextualIdentityService
.
sys
.
mjs
"
PrivateBrowsingUtils
:
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
sys
.
mjs
"
ShellService
:
"
resource
:
/
/
/
modules
/
ShellService
.
sys
.
mjs
"
URILoadingHelper
:
"
resource
:
/
/
/
modules
/
URILoadingHelper
.
sys
.
mjs
"
}
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AboutNewTab
:
"
resource
:
/
/
/
modules
/
AboutNewTab
.
jsm
"
BrowserWindowTracker
:
"
resource
:
/
/
/
modules
/
BrowserWindowTracker
.
jsm
"
ExtensionSettingsStore
:
"
resource
:
/
/
gre
/
modules
/
ExtensionSettingsStore
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
ReferrerInfo
"
(
)
=
>
Components
.
Constructor
(
"
mozilla
.
org
/
referrer
-
info
;
1
"
"
nsIReferrerInfo
"
"
init
"
)
)
;
Object
.
defineProperty
(
this
"
BROWSER_NEW_TAB_URL
"
{
enumerable
:
true
get
(
)
{
if
(
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
{
if
(
!
PrivateBrowsingUtils
.
permanentPrivateBrowsing
&
&
!
AboutNewTab
.
newTabURLOverridden
)
{
return
"
about
:
privatebrowsing
"
;
}
let
extensionControlled
=
Services
.
prefs
.
getBoolPref
(
"
browser
.
newtab
.
extensionControlled
"
false
)
;
let
privateAllowed
=
Services
.
prefs
.
getBoolPref
(
"
browser
.
newtab
.
privateAllowed
"
false
)
;
if
(
!
privateAllowed
&
&
(
extensionControlled
|
|
AboutNewTab
.
newTabURL
.
startsWith
(
"
moz
-
extension
:
/
/
"
)
)
)
{
return
"
about
:
privatebrowsing
"
;
}
}
return
AboutNewTab
.
newTabURL
;
}
}
)
;
var
TAB_DROP_TYPE
=
"
application
/
x
-
moz
-
tabbrowser
-
tab
"
;
var
gBidiUI
=
false
;
function
isBlankPageURL
(
aURL
)
{
return
(
aURL
=
=
"
about
:
blank
"
|
|
aURL
=
=
"
about
:
home
"
|
|
aURL
=
=
BROWSER_NEW_TAB_URL
|
|
aURL
=
=
"
chrome
:
/
/
browser
/
content
/
blanktab
.
html
"
)
;
}
function
doGetProtocolFlags
(
aURI
)
{
return
Services
.
io
.
getDynamicProtocolFlags
(
aURI
)
;
}
function
openUILink
(
url
event
aIgnoreButton
aIgnoreAlt
aAllowThirdPartyFixup
aPostData
aReferrerInfo
)
{
return
URILoadingHelper
.
openUILink
(
window
url
event
aIgnoreButton
aIgnoreAlt
aAllowThirdPartyFixup
aPostData
aReferrerInfo
)
;
}
function
getRootEvent
(
aEvent
)
{
return
BrowserUtils
.
getRootEvent
(
aEvent
)
;
}
function
whereToOpenLink
(
e
ignoreButton
ignoreAlt
)
{
return
BrowserUtils
.
whereToOpenLink
(
e
ignoreButton
ignoreAlt
)
;
}
function
openTrustedLinkIn
(
url
where
params
)
{
URILoadingHelper
.
openTrustedLinkIn
(
window
url
where
params
)
;
}
function
openWebLinkIn
(
url
where
params
)
{
URILoadingHelper
.
openWebLinkIn
(
window
url
where
params
)
;
}
function
openLinkIn
(
url
where
params
)
{
return
URILoadingHelper
.
openLinkIn
(
window
url
where
params
)
;
}
function
checkForMiddleClick
(
node
event
)
{
if
(
node
.
getAttribute
(
"
disabled
"
)
=
=
"
true
"
)
{
return
;
}
if
(
event
.
target
.
tagName
=
=
"
menuitem
"
)
{
return
;
}
if
(
event
.
button
=
=
1
)
{
let
cmdEvent
=
document
.
createEvent
(
"
xulcommandevent
"
)
;
cmdEvent
.
initCommandEvent
(
"
command
"
true
true
window
0
event
.
ctrlKey
event
.
altKey
event
.
shiftKey
event
.
metaKey
0
event
event
.
mozInputSource
)
;
node
.
dispatchEvent
(
cmdEvent
)
;
event
.
stopPropagation
(
)
;
event
.
preventDefault
(
)
;
closeMenus
(
event
.
target
)
;
}
}
function
createUserContextMenu
(
event
{
isContextMenu
=
false
excludeUserContextId
=
0
showDefaultTab
=
false
useAccessKeys
=
true
}
=
{
}
)
{
while
(
event
.
target
.
hasChildNodes
(
)
)
{
event
.
target
.
firstChild
.
remove
(
)
;
}
let
bundle
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
browser
/
locale
/
browser
.
properties
"
)
;
let
docfrag
=
document
.
createDocumentFragment
(
)
;
if
(
excludeUserContextId
|
|
showDefaultTab
)
{
let
menuitem
=
document
.
createXULElement
(
"
menuitem
"
)
;
menuitem
.
setAttribute
(
"
data
-
usercontextid
"
"
0
"
)
;
menuitem
.
setAttribute
(
"
label
"
bundle
.
GetStringFromName
(
"
userContextNone
.
label
"
)
)
;
menuitem
.
setAttribute
(
"
accesskey
"
bundle
.
GetStringFromName
(
"
userContextNone
.
accesskey
"
)
)
;
if
(
!
isContextMenu
)
{
menuitem
.
setAttribute
(
"
command
"
"
Browser
:
NewUserContextTab
"
)
;
}
docfrag
.
appendChild
(
menuitem
)
;
let
menuseparator
=
document
.
createXULElement
(
"
menuseparator
"
)
;
docfrag
.
appendChild
(
menuseparator
)
;
}
ContextualIdentityService
.
getPublicIdentities
(
)
.
forEach
(
identity
=
>
{
if
(
identity
.
userContextId
=
=
excludeUserContextId
)
{
return
;
}
let
menuitem
=
document
.
createXULElement
(
"
menuitem
"
)
;
menuitem
.
setAttribute
(
"
data
-
usercontextid
"
identity
.
userContextId
)
;
menuitem
.
setAttribute
(
"
label
"
ContextualIdentityService
.
getUserContextLabel
(
identity
.
userContextId
)
)
;
if
(
identity
.
accessKey
&
&
useAccessKeys
)
{
menuitem
.
setAttribute
(
"
accesskey
"
bundle
.
GetStringFromName
(
identity
.
accessKey
)
)
;
}
menuitem
.
classList
.
add
(
"
menuitem
-
iconic
"
)
;
menuitem
.
classList
.
add
(
"
identity
-
color
-
"
+
identity
.
color
)
;
if
(
!
isContextMenu
)
{
menuitem
.
setAttribute
(
"
command
"
"
Browser
:
NewUserContextTab
"
)
;
}
menuitem
.
classList
.
add
(
"
identity
-
icon
-
"
+
identity
.
icon
)
;
docfrag
.
appendChild
(
menuitem
)
;
}
)
;
if
(
!
isContextMenu
)
{
docfrag
.
appendChild
(
document
.
createXULElement
(
"
menuseparator
"
)
)
;
let
menuitem
=
document
.
createXULElement
(
"
menuitem
"
)
;
menuitem
.
setAttribute
(
"
label
"
bundle
.
GetStringFromName
(
"
userContext
.
aboutPage
.
label
"
)
)
;
if
(
useAccessKeys
)
{
menuitem
.
setAttribute
(
"
accesskey
"
bundle
.
GetStringFromName
(
"
userContext
.
aboutPage
.
accesskey
"
)
)
;
}
menuitem
.
setAttribute
(
"
command
"
"
Browser
:
OpenAboutContainers
"
)
;
docfrag
.
appendChild
(
menuitem
)
;
}
event
.
target
.
appendChild
(
docfrag
)
;
return
true
;
}
function
closeMenus
(
node
)
{
if
(
"
tagName
"
in
node
)
{
if
(
node
.
namespaceURI
=
=
"
http
:
/
/
www
.
mozilla
.
org
/
keymaster
/
gatekeeper
/
there
.
is
.
only
.
xul
"
&
&
(
node
.
tagName
=
=
"
menupopup
"
|
|
node
.
tagName
=
=
"
popup
"
)
)
{
node
.
hidePopup
(
)
;
}
closeMenus
(
node
.
parentNode
)
;
}
}
function
eventMatchesKey
(
aEvent
aKey
)
{
let
keyPressed
=
aKey
.
getAttribute
(
"
key
"
)
.
toLowerCase
(
)
;
let
keyModifiers
=
aKey
.
getAttribute
(
"
modifiers
"
)
;
let
modifiers
=
[
"
Alt
"
"
Control
"
"
Meta
"
"
Shift
"
]
;
if
(
aEvent
.
key
!
=
keyPressed
)
{
return
false
;
}
let
eventModifiers
=
modifiers
.
filter
(
modifier
=
>
aEvent
.
getModifierState
(
modifier
)
)
;
if
(
eventModifiers
.
length
&
&
!
keyModifiers
.
length
)
{
return
false
;
}
if
(
keyModifiers
)
{
keyModifiers
=
keyModifiers
.
split
(
/
[
\
s
]
+
/
)
;
keyModifiers
.
forEach
(
function
(
modifier
index
)
{
if
(
modifier
=
=
"
accel
"
)
{
keyModifiers
[
index
]
=
AppConstants
.
platform
=
=
"
macosx
"
?
"
Meta
"
:
"
Control
"
;
}
else
{
keyModifiers
[
index
]
=
modifier
[
0
]
.
toUpperCase
(
)
+
modifier
.
slice
(
1
)
;
}
}
)
;
return
modifiers
.
every
(
modifier
=
>
keyModifiers
.
includes
(
modifier
)
=
=
aEvent
.
getModifierState
(
modifier
)
)
;
}
return
true
;
}
function
gatherTextUnder
(
root
)
{
var
text
=
"
"
;
var
node
=
root
.
firstChild
;
var
depth
=
1
;
while
(
node
&
&
depth
>
0
)
{
if
(
node
.
nodeType
=
=
Node
.
TEXT_NODE
)
{
text
+
=
"
"
+
node
.
data
;
}
else
if
(
HTMLImageElement
.
isInstance
(
node
)
)
{
var
altText
=
node
.
getAttribute
(
"
alt
"
)
;
if
(
altText
&
&
altText
!
=
"
"
)
{
text
+
=
"
"
+
altText
;
}
}
if
(
node
.
hasChildNodes
(
)
)
{
node
=
node
.
firstChild
;
depth
+
+
;
}
else
{
while
(
depth
>
0
&
&
!
node
.
nextSibling
)
{
node
=
node
.
parentNode
;
depth
-
-
;
}
if
(
node
.
nextSibling
)
{
node
=
node
.
nextSibling
;
}
}
}
text
=
text
.
trim
(
)
;
text
=
text
.
replace
(
/
\
s
+
/
g
"
"
)
;
return
text
;
}
function
getShellService
(
)
{
return
ShellService
;
}
function
isBidiEnabled
(
)
{
if
(
Services
.
prefs
.
getBoolPref
(
"
bidi
.
browser
.
ui
"
false
)
)
{
return
true
;
}
const
isRTL
=
Services
.
locale
.
isAppLocaleRTL
;
if
(
isRTL
)
{
Services
.
prefs
.
setBoolPref
(
"
bidi
.
browser
.
ui
"
true
)
;
}
return
isRTL
;
}
function
openAboutDialog
(
)
{
for
(
let
win
of
Services
.
wm
.
getEnumerator
(
"
Browser
:
About
"
)
)
{
if
(
win
.
closed
)
{
continue
;
}
win
.
focus
(
)
;
return
;
}
var
features
=
"
chrome
"
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
features
+
=
"
centerscreen
dependent
"
;
}
else
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
features
+
=
"
centerscreen
resizable
=
no
minimizable
=
no
"
;
}
else
{
features
+
=
"
centerscreen
dependent
dialog
=
no
"
;
}
window
.
openDialog
(
"
chrome
:
/
/
browser
/
content
/
aboutDialog
.
xhtml
"
"
"
features
)
;
}
async
function
openPreferences
(
paneID
extraArgs
)
{
function
internalPrefCategoryNameToFriendlyName
(
aName
)
{
return
(
aName
|
|
"
"
)
.
replace
(
/
^
pane
.
/
function
(
toReplace
)
{
return
toReplace
[
4
]
.
toLowerCase
(
)
;
}
)
;
}
let
win
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
let
friendlyCategoryName
=
internalPrefCategoryNameToFriendlyName
(
paneID
)
;
let
params
;
if
(
extraArgs
&
&
extraArgs
.
urlParams
)
{
params
=
new
URLSearchParams
(
)
;
let
urlParams
=
extraArgs
.
urlParams
;
for
(
let
name
in
urlParams
)
{
if
(
urlParams
[
name
]
!
=
=
undefined
)
{
params
.
set
(
name
urlParams
[
name
]
)
;
}
}
}
let
preferencesURL
=
"
about
:
preferences
"
+
(
params
?
"
?
"
+
params
:
"
"
)
+
(
friendlyCategoryName
?
"
#
"
+
friendlyCategoryName
:
"
"
)
;
let
newLoad
=
true
;
let
browser
=
null
;
if
(
!
win
)
{
let
windowArguments
=
Cc
[
"
mozilla
.
org
/
array
;
1
"
]
.
createInstance
(
Ci
.
nsIMutableArray
)
;
let
supportsStringPrefURL
=
Cc
[
"
mozilla
.
org
/
supports
-
string
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsString
)
;
supportsStringPrefURL
.
data
=
preferencesURL
;
windowArguments
.
appendElement
(
supportsStringPrefURL
)
;
win
=
Services
.
ww
.
openWindow
(
null
AppConstants
.
BROWSER_CHROME_URL
"
_blank
"
"
chrome
dialog
=
no
all
"
windowArguments
)
;
}
else
{
let
shouldReplaceFragment
=
friendlyCategoryName
?
"
whenComparingAndReplace
"
:
"
whenComparing
"
;
newLoad
=
!
win
.
switchToTabHavingURI
(
preferencesURL
true
{
ignoreFragment
:
shouldReplaceFragment
replaceQueryString
:
true
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
}
)
;
browser
=
win
.
gBrowser
.
selectedBrowser
;
}
if
(
!
newLoad
&
&
paneID
)
{
if
(
browser
.
contentDocument
?
.
readyState
!
=
"
complete
"
)
{
await
new
Promise
(
resolve
=
>
{
browser
.
addEventListener
(
"
load
"
resolve
{
capture
:
true
once
:
true
}
)
;
}
)
;
}
browser
.
contentWindow
.
gotoPref
(
paneID
)
;
}
}
function
openTroubleshootingPage
(
)
{
openTrustedLinkIn
(
"
about
:
support
"
"
tab
"
)
;
}
function
openFeedbackPage
(
)
{
var
url
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
feedback
.
baseURL
"
)
;
openTrustedLinkIn
(
url
"
tab
"
)
;
}
function
openSwitchingDevicesPage
(
)
{
let
url
=
getHelpLinkURL
(
"
switching
-
devices
"
)
;
let
parsedUrl
=
new
URL
(
url
)
;
parsedUrl
.
searchParams
.
set
(
"
utm_content
"
"
switch
-
to
-
new
-
device
"
)
;
parsedUrl
.
searchParams
.
set
(
"
utm_source
"
"
help
-
menu
"
)
;
parsedUrl
.
searchParams
.
set
(
"
utm_medium
"
"
firefox
-
desktop
"
)
;
parsedUrl
.
searchParams
.
set
(
"
utm_campaign
"
"
migration
"
)
;
openTrustedLinkIn
(
parsedUrl
.
href
"
tab
"
)
;
}
function
buildHelpMenu
(
)
{
document
.
getElementById
(
"
feedbackPage
"
)
.
disabled
=
!
Services
.
policies
.
isAllowed
(
"
feedbackCommands
"
)
;
document
.
getElementById
(
"
helpSafeMode
"
)
.
disabled
=
!
Services
.
policies
.
isAllowed
(
"
safeMode
"
)
;
document
.
getElementById
(
"
troubleShooting
"
)
.
disabled
=
!
Services
.
policies
.
isAllowed
(
"
aboutSupport
"
)
;
let
supportMenu
=
Services
.
policies
.
getSupportMenu
(
)
;
if
(
supportMenu
)
{
let
menuitem
=
document
.
getElementById
(
"
helpPolicySupport
"
)
;
menuitem
.
hidden
=
false
;
menuitem
.
setAttribute
(
"
label
"
supportMenu
.
Title
)
;
if
(
"
AccessKey
"
in
supportMenu
)
{
menuitem
.
setAttribute
(
"
accesskey
"
supportMenu
.
AccessKey
)
;
}
document
.
getElementById
(
"
helpPolicySeparator
"
)
.
hidden
=
false
;
}
if
(
typeof
gSafeBrowsing
!
=
"
undefined
"
)
{
gSafeBrowsing
.
setReportPhishingMenu
(
)
;
}
let
reportSiteIssueEnabled
=
Services
.
prefs
.
getBoolPref
(
"
extensions
.
webcompat
-
reporter
.
enabled
"
false
)
;
let
reportSiteIssue
=
document
.
getElementById
(
"
help_reportSiteIssue
"
)
;
reportSiteIssue
.
hidden
=
!
reportSiteIssueEnabled
;
if
(
reportSiteIssueEnabled
)
{
let
uri
=
gBrowser
.
currentURI
;
let
isReportablePage
=
uri
&
&
(
uri
.
schemeIs
(
"
http
"
)
|
|
uri
.
schemeIs
(
"
https
"
)
)
;
reportSiteIssue
.
disabled
=
!
isReportablePage
;
}
if
(
NimbusFeatures
.
deviceMigration
.
getVariable
(
"
helpMenuHidden
"
)
)
{
let
helpMenuItem
=
document
.
getElementById
(
"
helpSwitchDevice
"
)
;
helpMenuItem
.
hidden
=
true
;
}
}
function
isElementVisible
(
aElement
)
{
if
(
!
aElement
)
{
return
false
;
}
var
rect
=
aElement
.
getBoundingClientRect
(
)
;
return
rect
.
height
>
0
&
&
rect
.
width
>
0
;
}
function
makeURLAbsolute
(
aBase
aUrl
)
{
return
makeURI
(
aUrl
null
makeURI
(
aBase
)
)
.
spec
;
}
function
getHelpLinkURL
(
aHelpTopic
)
{
var
url
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
;
return
url
+
aHelpTopic
;
}
function
openHelpLink
(
aHelpTopic
aCalledFromModal
aWhere
)
{
var
url
=
getHelpLinkURL
(
aHelpTopic
)
;
var
where
=
aWhere
;
if
(
!
aWhere
)
{
where
=
aCalledFromModal
?
"
window
"
:
"
tab
"
;
}
openTrustedLinkIn
(
url
where
)
;
}
function
openPrefsHelp
(
aEvent
)
{
let
helpTopic
=
aEvent
.
target
.
getAttribute
(
"
helpTopic
"
)
;
openHelpLink
(
helpTopic
)
;
}
