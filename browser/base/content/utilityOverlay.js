Components
.
utils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
Components
.
utils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ContextualIdentityService
.
jsm
"
)
;
Components
.
utils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Components
.
utils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Components
.
utils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
Components
.
utils
.
import
(
"
resource
:
/
/
/
modules
/
RecentWindow
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
ShellService
"
"
resource
:
/
/
/
modules
/
ShellService
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
aboutNewTabService
"
"
mozilla
.
org
/
browser
/
aboutnewtab
-
service
;
1
"
"
nsIAboutNewTabService
"
)
;
this
.
__defineGetter__
(
"
BROWSER_NEW_TAB_URL
"
(
)
=
>
{
if
(
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
&
&
!
PrivateBrowsingUtils
.
permanentPrivateBrowsing
&
&
!
aboutNewTabService
.
overridden
)
{
return
"
about
:
privatebrowsing
"
;
}
return
aboutNewTabService
.
newTabURL
;
}
)
;
var
TAB_DROP_TYPE
=
"
application
/
x
-
moz
-
tabbrowser
-
tab
"
;
var
gBidiUI
=
false
;
function
isBlankPageURL
(
aURL
)
{
return
aURL
=
=
"
about
:
blank
"
|
|
aURL
=
=
BROWSER_NEW_TAB_URL
;
}
function
getBrowserURL
(
)
{
return
"
chrome
:
/
/
browser
/
content
/
browser
.
xul
"
;
}
function
getTopWin
(
skipPopups
)
{
if
(
top
.
document
.
documentElement
.
getAttribute
(
"
windowtype
"
)
=
=
"
navigator
:
browser
"
&
&
(
!
skipPopups
|
|
top
.
toolbar
.
visible
)
)
return
top
;
let
isPrivate
=
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
;
return
RecentWindow
.
getMostRecentBrowserWindow
(
{
private
:
isPrivate
allowPopups
:
!
skipPopups
}
)
;
}
function
openTopWin
(
url
)
{
openUILinkIn
(
url
"
current
"
)
;
}
function
getBoolPref
(
prefname
def
)
{
try
{
return
Services
.
prefs
.
getBoolPref
(
prefname
)
;
}
catch
(
er
)
{
return
def
;
}
}
function
openUILink
(
url
event
aIgnoreButton
aIgnoreAlt
aAllowThirdPartyFixup
aPostData
aReferrerURI
)
{
let
params
;
if
(
aIgnoreButton
&
&
typeof
aIgnoreButton
=
=
"
object
"
)
{
params
=
aIgnoreButton
;
aIgnoreButton
=
params
.
ignoreButton
;
aIgnoreAlt
=
params
.
ignoreAlt
;
delete
params
.
ignoreButton
;
delete
params
.
ignoreAlt
;
}
else
{
params
=
{
allowThirdPartyFixup
:
aAllowThirdPartyFixup
postData
:
aPostData
referrerURI
:
aReferrerURI
referrerPolicy
:
Components
.
interfaces
.
nsIHttpChannel
.
REFERRER_POLICY_DEFAULT
initiatingDoc
:
event
?
event
.
target
.
ownerDocument
:
null
}
;
}
let
where
=
whereToOpenLink
(
event
aIgnoreButton
aIgnoreAlt
)
;
openUILinkIn
(
url
where
params
)
;
}
function
whereToOpenLink
(
e
ignoreButton
ignoreAlt
)
{
if
(
!
e
)
return
"
current
"
;
var
shift
=
e
.
shiftKey
;
var
ctrl
=
e
.
ctrlKey
;
var
meta
=
e
.
metaKey
;
var
alt
=
e
.
altKey
&
&
!
ignoreAlt
;
var
middle
=
!
ignoreButton
&
&
e
.
button
=
=
1
;
var
middleUsesTabs
=
getBoolPref
(
"
browser
.
tabs
.
opentabfor
.
middleclick
"
true
)
;
var
metaKey
=
AppConstants
.
platform
=
=
"
macosx
"
?
meta
:
ctrl
;
if
(
metaKey
|
|
(
middle
&
&
middleUsesTabs
)
)
return
shift
?
"
tabshifted
"
:
"
tab
"
;
if
(
alt
&
&
getBoolPref
(
"
browser
.
altClickSave
"
false
)
)
return
"
save
"
;
if
(
shift
|
|
(
middle
&
&
!
middleUsesTabs
)
)
return
"
window
"
;
return
"
current
"
;
}
function
openUILinkIn
(
url
where
aAllowThirdPartyFixup
aPostData
aReferrerURI
)
{
var
params
;
if
(
arguments
.
length
=
=
3
&
&
typeof
arguments
[
2
]
=
=
"
object
"
)
{
params
=
aAllowThirdPartyFixup
;
}
else
{
params
=
{
allowThirdPartyFixup
:
aAllowThirdPartyFixup
postData
:
aPostData
referrerURI
:
aReferrerURI
referrerPolicy
:
Components
.
interfaces
.
nsIHttpChannel
.
REFERRER_POLICY_DEFAULT
}
;
}
params
.
fromChrome
=
true
;
openLinkIn
(
url
where
params
)
;
}
function
openLinkIn
(
url
where
params
)
{
if
(
!
where
|
|
!
url
)
return
;
const
Cc
=
Components
.
classes
;
const
Ci
=
Components
.
interfaces
;
var
aFromChrome
=
params
.
fromChrome
;
var
aAllowThirdPartyFixup
=
params
.
allowThirdPartyFixup
;
var
aPostData
=
params
.
postData
;
var
aCharset
=
params
.
charset
;
var
aReferrerURI
=
params
.
referrerURI
;
var
aReferrerPolicy
=
(
'
referrerPolicy
'
in
params
?
params
.
referrerPolicy
:
Ci
.
nsIHttpChannel
.
REFERRER_POLICY_DEFAULT
)
;
var
aRelatedToCurrent
=
params
.
relatedToCurrent
;
var
aAllowMixedContent
=
params
.
allowMixedContent
;
var
aInBackground
=
params
.
inBackground
;
var
aDisallowInheritPrincipal
=
params
.
disallowInheritPrincipal
;
var
aInitiatingDoc
=
params
.
initiatingDoc
;
var
aIsPrivate
=
params
.
private
;
var
aSkipTabAnimation
=
params
.
skipTabAnimation
;
var
aAllowPinnedTabHostChange
=
!
!
params
.
allowPinnedTabHostChange
;
var
aNoReferrer
=
params
.
noReferrer
;
var
aAllowPopups
=
!
!
params
.
allowPopups
;
var
aUserContextId
=
params
.
userContextId
;
var
aIndicateErrorPageLoad
=
params
.
indicateErrorPageLoad
;
var
aPrincipal
=
params
.
originPrincipal
;
var
aForceAboutBlankViewerInCurrent
=
params
.
forceAboutBlankViewerInCurrent
;
var
w
=
getTopWin
(
)
;
if
(
(
where
=
=
"
tab
"
|
|
where
=
=
"
tabshifted
"
)
&
&
w
&
&
!
w
.
toolbar
.
visible
)
{
w
=
getTopWin
(
true
)
;
aRelatedToCurrent
=
false
;
}
var
aCurrentBrowser
=
params
.
currentBrowser
|
|
(
w
&
&
w
.
gBrowser
.
selectedBrowser
)
;
if
(
where
=
=
"
save
"
)
{
if
(
"
isContentWindowPrivate
"
in
params
)
{
saveURL
(
url
null
null
true
true
aNoReferrer
?
null
:
aReferrerURI
null
params
.
isContentWindowPrivate
)
;
}
else
{
if
(
!
aInitiatingDoc
)
{
Components
.
utils
.
reportError
(
"
openUILink
/
openLinkIn
was
called
with
"
+
"
where
=
=
'
save
'
but
without
initiatingDoc
.
See
bug
814264
.
"
)
;
return
;
}
saveURL
(
url
null
null
true
true
aNoReferrer
?
null
:
aReferrerURI
aInitiatingDoc
)
;
}
return
;
}
if
(
!
w
|
|
where
=
=
"
window
"
)
{
var
sa
=
Cc
[
"
mozilla
.
org
/
array
;
1
"
]
.
createInstance
(
Ci
.
nsIMutableArray
)
;
var
wuri
=
Cc
[
"
mozilla
.
org
/
supports
-
string
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsString
)
;
wuri
.
data
=
url
;
let
charset
=
null
;
if
(
aCharset
)
{
charset
=
Cc
[
"
mozilla
.
org
/
supports
-
string
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsString
)
;
charset
.
data
=
"
charset
=
"
+
aCharset
;
}
var
allowThirdPartyFixupSupports
=
Cc
[
"
mozilla
.
org
/
supports
-
PRBool
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsPRBool
)
;
allowThirdPartyFixupSupports
.
data
=
aAllowThirdPartyFixup
;
var
referrerURISupports
=
null
;
if
(
aReferrerURI
&
&
!
aNoReferrer
)
{
referrerURISupports
=
Cc
[
"
mozilla
.
org
/
supports
-
string
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsString
)
;
referrerURISupports
.
data
=
aReferrerURI
.
spec
;
}
var
referrerPolicySupports
=
Cc
[
"
mozilla
.
org
/
supports
-
PRUint32
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsPRUint32
)
;
referrerPolicySupports
.
data
=
aReferrerPolicy
;
var
userContextIdSupports
=
Cc
[
"
mozilla
.
org
/
supports
-
PRUint32
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsPRUint32
)
;
userContextIdSupports
.
data
=
aUserContextId
;
sa
.
appendElement
(
wuri
false
)
;
sa
.
appendElement
(
charset
false
)
;
sa
.
appendElement
(
referrerURISupports
false
)
;
sa
.
appendElement
(
aPostData
false
)
;
sa
.
appendElement
(
allowThirdPartyFixupSupports
false
)
;
sa
.
appendElement
(
referrerPolicySupports
false
)
;
sa
.
appendElement
(
userContextIdSupports
false
)
;
sa
.
appendElement
(
aPrincipal
false
)
;
let
features
=
"
chrome
dialog
=
no
all
"
;
if
(
aIsPrivate
)
{
features
+
=
"
private
"
;
}
Services
.
ww
.
openWindow
(
w
|
|
window
getBrowserURL
(
)
null
features
sa
)
;
return
;
}
let
loadInBackground
=
where
=
=
"
current
"
?
false
:
aInBackground
;
if
(
loadInBackground
=
=
null
)
{
loadInBackground
=
aFromChrome
?
false
:
getBoolPref
(
"
browser
.
tabs
.
loadInBackground
"
)
;
}
let
uriObj
;
if
(
where
=
=
"
current
"
)
{
try
{
uriObj
=
Services
.
io
.
newURI
(
url
null
null
)
;
}
catch
(
e
)
{
}
}
let
tab
=
aCurrentBrowser
.
ownerGlobal
.
gBrowser
.
getTabForBrowser
(
aCurrentBrowser
)
;
if
(
where
=
=
"
current
"
&
&
tab
.
pinned
&
&
!
aAllowPinnedTabHostChange
)
{
try
{
if
(
!
uriObj
|
|
(
!
uriObj
.
schemeIs
(
"
javascript
"
)
&
&
aCurrentBrowser
.
currentURI
.
host
!
=
uriObj
.
host
)
)
{
where
=
"
tab
"
;
loadInBackground
=
false
;
}
}
catch
(
err
)
{
where
=
"
tab
"
;
loadInBackground
=
false
;
}
}
w
.
focus
(
)
;
switch
(
where
)
{
case
"
current
"
:
let
flags
=
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_NONE
;
if
(
aAllowThirdPartyFixup
)
{
flags
|
=
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP
;
flags
|
=
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_FIXUP_SCHEME_TYPOS
;
}
if
(
aDisallowInheritPrincipal
&
&
!
(
uriObj
&
&
uriObj
.
schemeIs
(
"
javascript
"
)
)
)
{
flags
|
=
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_DISALLOW_INHERIT_PRINCIPAL
;
}
if
(
aAllowPopups
)
{
flags
|
=
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_ALLOW_POPUPS
;
}
if
(
aIndicateErrorPageLoad
)
{
flags
|
=
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_ERROR_LOAD_CHANGES_RV
;
}
if
(
aForceAboutBlankViewerInCurrent
)
{
w
.
gBrowser
.
selectedBrowser
.
createAboutBlankContentViewer
(
aPrincipal
)
;
}
aCurrentBrowser
.
loadURIWithFlags
(
url
{
flags
:
flags
referrerURI
:
aNoReferrer
?
null
:
aReferrerURI
referrerPolicy
:
aReferrerPolicy
postData
:
aPostData
userContextId
:
aUserContextId
}
)
;
break
;
case
"
tabshifted
"
:
loadInBackground
=
!
loadInBackground
;
case
"
tab
"
:
w
.
gBrowser
.
loadOneTab
(
url
{
referrerURI
:
aReferrerURI
referrerPolicy
:
aReferrerPolicy
charset
:
aCharset
postData
:
aPostData
inBackground
:
loadInBackground
allowThirdPartyFixup
:
aAllowThirdPartyFixup
relatedToCurrent
:
aRelatedToCurrent
skipAnimation
:
aSkipTabAnimation
allowMixedContent
:
aAllowMixedContent
noReferrer
:
aNoReferrer
userContextId
:
aUserContextId
originPrincipal
:
aPrincipal
}
)
;
break
;
}
aCurrentBrowser
.
focus
(
)
;
if
(
!
loadInBackground
&
&
w
.
isBlankPageURL
(
url
)
)
{
w
.
focusAndSelectUrlBar
(
)
;
}
}
function
checkForMiddleClick
(
node
event
)
{
if
(
node
.
getAttribute
(
"
disabled
"
)
=
=
"
true
"
)
return
;
if
(
event
.
button
=
=
1
)
{
var
target
=
node
.
hasAttribute
(
"
oncommand
"
)
?
node
:
node
.
ownerDocument
.
getElementById
(
node
.
getAttribute
(
"
command
"
)
)
;
var
fn
=
new
Function
(
"
event
"
target
.
getAttribute
(
"
oncommand
"
)
)
;
fn
.
call
(
target
event
)
;
closeMenus
(
event
.
target
)
;
}
}
function
createUserContextMenu
(
event
addCommandAttribute
=
true
excludeUserContextId
=
0
)
{
while
(
event
.
target
.
hasChildNodes
(
)
)
{
event
.
target
.
removeChild
(
event
.
target
.
firstChild
)
;
}
let
bundle
=
document
.
getElementById
(
"
bundle_browser
"
)
;
let
docfrag
=
document
.
createDocumentFragment
(
)
;
if
(
excludeUserContextId
)
{
let
menuitem
=
document
.
createElement
(
"
menuitem
"
)
;
menuitem
.
setAttribute
(
"
data
-
usercontextid
"
"
0
"
)
;
menuitem
.
setAttribute
(
"
label
"
bundle
.
getString
(
"
userContextNone
.
label
"
)
)
;
menuitem
.
setAttribute
(
"
accesskey
"
bundle
.
getString
(
"
userContextNone
.
accesskey
"
)
)
;
docfrag
.
appendChild
(
menuitem
)
;
let
menuseparator
=
document
.
createElement
(
"
menuseparator
"
)
;
docfrag
.
appendChild
(
menuseparator
)
;
}
ContextualIdentityService
.
getIdentities
(
)
.
forEach
(
identity
=
>
{
if
(
identity
.
userContextId
=
=
excludeUserContextId
)
{
return
;
}
let
menuitem
=
document
.
createElement
(
"
menuitem
"
)
;
menuitem
.
setAttribute
(
"
data
-
usercontextid
"
identity
.
userContextId
)
;
menuitem
.
setAttribute
(
"
label
"
ContextualIdentityService
.
getUserContextLabel
(
identity
.
userContextId
)
)
;
if
(
identity
.
accessKey
)
{
menuitem
.
setAttribute
(
"
accesskey
"
bundle
.
getString
(
identity
.
accessKey
)
)
;
}
menuitem
.
classList
.
add
(
"
menuitem
-
iconic
"
)
;
if
(
addCommandAttribute
)
{
menuitem
.
setAttribute
(
"
command
"
"
Browser
:
NewUserContextTab
"
)
;
}
menuitem
.
setAttribute
(
"
image
"
identity
.
icon
)
;
docfrag
.
appendChild
(
menuitem
)
;
}
)
;
event
.
target
.
appendChild
(
docfrag
)
;
return
true
;
}
function
closeMenus
(
node
)
{
if
(
"
tagName
"
in
node
)
{
if
(
node
.
namespaceURI
=
=
"
http
:
/
/
www
.
mozilla
.
org
/
keymaster
/
gatekeeper
/
there
.
is
.
only
.
xul
"
&
&
(
node
.
tagName
=
=
"
menupopup
"
|
|
node
.
tagName
=
=
"
popup
"
)
)
node
.
hidePopup
(
)
;
closeMenus
(
node
.
parentNode
)
;
}
}
function
eventMatchesKey
(
aEvent
aKey
)
{
let
keyPressed
=
aKey
.
getAttribute
(
"
key
"
)
.
toLowerCase
(
)
;
let
keyModifiers
=
aKey
.
getAttribute
(
"
modifiers
"
)
;
let
modifiers
=
[
"
Alt
"
"
Control
"
"
Meta
"
"
Shift
"
]
;
if
(
aEvent
.
key
!
=
keyPressed
)
{
return
false
;
}
let
eventModifiers
=
modifiers
.
filter
(
modifier
=
>
aEvent
.
getModifierState
(
modifier
)
)
;
if
(
eventModifiers
.
length
>
0
&
&
keyModifiers
.
length
=
=
0
)
{
return
false
;
}
if
(
keyModifiers
)
{
keyModifiers
=
keyModifiers
.
split
(
/
[
\
s
]
+
/
)
;
keyModifiers
.
forEach
(
function
(
modifier
index
)
{
if
(
modifier
=
=
"
accel
"
)
{
keyModifiers
[
index
]
=
AppConstants
.
platform
=
=
"
macosx
"
?
"
Meta
"
:
"
Control
"
;
}
else
{
keyModifiers
[
index
]
=
modifier
[
0
]
.
toUpperCase
(
)
+
modifier
.
slice
(
1
)
;
}
}
)
;
return
modifiers
.
every
(
modifier
=
>
keyModifiers
.
includes
(
modifier
)
=
=
aEvent
.
getModifierState
(
modifier
)
)
;
}
return
true
;
}
function
gatherTextUnder
(
root
)
{
var
text
=
"
"
;
var
node
=
root
.
firstChild
;
var
depth
=
1
;
while
(
node
&
&
depth
>
0
)
{
if
(
node
.
nodeType
=
=
Node
.
TEXT_NODE
)
{
text
+
=
"
"
+
node
.
data
;
}
else
if
(
node
instanceof
HTMLImageElement
)
{
var
altText
=
node
.
getAttribute
(
"
alt
"
)
;
if
(
altText
&
&
altText
!
=
"
"
)
{
text
+
=
"
"
+
altText
;
}
}
if
(
node
.
hasChildNodes
(
)
)
{
node
=
node
.
firstChild
;
depth
+
+
;
}
else
{
while
(
depth
>
0
&
&
!
node
.
nextSibling
)
{
node
=
node
.
parentNode
;
depth
-
-
;
}
if
(
node
.
nextSibling
)
{
node
=
node
.
nextSibling
;
}
}
}
text
=
text
.
trim
(
)
;
text
=
text
.
replace
(
/
\
s
+
/
g
"
"
)
;
return
text
;
}
function
getShellService
(
)
{
return
ShellService
;
}
function
isBidiEnabled
(
)
{
if
(
getBoolPref
(
"
bidi
.
browser
.
ui
"
false
)
)
return
true
;
var
chromeReg
=
Components
.
classes
[
"
mozilla
.
org
/
chrome
/
chrome
-
registry
;
1
"
]
.
getService
(
Components
.
interfaces
.
nsIXULChromeRegistry
)
;
if
(
chromeReg
.
isLocaleRTL
(
"
global
"
)
)
return
true
;
var
rv
=
false
;
try
{
var
localeService
=
Components
.
classes
[
"
mozilla
.
org
/
intl
/
nslocaleservice
;
1
"
]
.
getService
(
Components
.
interfaces
.
nsILocaleService
)
;
var
systemLocale
=
localeService
.
getSystemLocale
(
)
.
getCategory
(
"
NSILOCALE_CTYPE
"
)
.
substr
(
0
3
)
;
switch
(
systemLocale
)
{
case
"
ar
-
"
:
case
"
he
-
"
:
case
"
fa
-
"
:
case
"
ug
-
"
:
case
"
ur
-
"
:
case
"
syr
"
:
rv
=
true
;
Services
.
prefs
.
setBoolPref
(
"
bidi
.
browser
.
ui
"
true
)
;
}
}
catch
(
e
)
{
}
return
rv
;
}
function
openAboutDialog
(
)
{
var
enumerator
=
Services
.
wm
.
getEnumerator
(
"
Browser
:
About
"
)
;
while
(
enumerator
.
hasMoreElements
(
)
)
{
let
win
=
enumerator
.
getNext
(
)
;
if
(
win
.
closed
)
{
continue
;
}
win
.
focus
(
)
;
return
;
}
var
features
=
"
chrome
"
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
features
+
=
"
centerscreen
dependent
"
;
}
else
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
features
+
=
"
resizable
=
no
minimizable
=
no
"
;
}
else
{
features
+
=
"
centerscreen
dependent
dialog
=
no
"
;
}
window
.
openDialog
(
"
chrome
:
/
/
browser
/
content
/
aboutDialog
.
xul
"
"
"
features
)
;
}
function
openPreferences
(
paneID
extraArgs
)
{
function
switchToAdvancedSubPane
(
doc
)
{
if
(
extraArgs
&
&
extraArgs
[
"
advancedTab
"
]
)
{
let
advancedPaneTabs
=
doc
.
getElementById
(
"
advancedPrefs
"
)
;
advancedPaneTabs
.
selectedTab
=
doc
.
getElementById
(
extraArgs
[
"
advancedTab
"
]
)
;
}
}
function
internalPrefCategoryNameToFriendlyName
(
aName
)
{
return
(
aName
|
|
"
"
)
.
replace
(
/
^
pane
.
/
function
(
toReplace
)
{
return
toReplace
[
4
]
.
toLowerCase
(
)
;
}
)
;
}
let
win
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
let
friendlyCategoryName
=
internalPrefCategoryNameToFriendlyName
(
paneID
)
;
let
params
;
if
(
extraArgs
&
&
extraArgs
[
"
urlParams
"
]
)
{
params
=
new
URLSearchParams
(
)
;
let
urlParams
=
extraArgs
[
"
urlParams
"
]
;
for
(
let
name
in
urlParams
)
{
if
(
urlParams
[
name
]
!
=
=
undefined
)
{
params
.
set
(
name
urlParams
[
name
]
)
;
}
}
}
let
preferencesURL
=
"
about
:
preferences
"
+
(
params
?
"
?
"
+
params
:
"
"
)
+
(
friendlyCategoryName
?
"
#
"
+
friendlyCategoryName
:
"
"
)
;
let
newLoad
=
true
;
let
browser
=
null
;
if
(
!
win
)
{
const
Cc
=
Components
.
classes
;
const
Ci
=
Components
.
interfaces
;
let
windowArguments
=
Cc
[
"
mozilla
.
org
/
array
;
1
"
]
.
createInstance
(
Ci
.
nsIMutableArray
)
;
let
supportsStringPrefURL
=
Cc
[
"
mozilla
.
org
/
supports
-
string
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsString
)
;
supportsStringPrefURL
.
data
=
preferencesURL
;
windowArguments
.
appendElement
(
supportsStringPrefURL
false
)
;
win
=
Services
.
ww
.
openWindow
(
null
Services
.
prefs
.
getCharPref
(
"
browser
.
chromeURL
"
)
"
_blank
"
"
chrome
dialog
=
no
all
"
windowArguments
)
;
}
else
{
let
shouldReplaceFragment
=
friendlyCategoryName
?
"
whenComparingAndReplace
"
:
"
whenComparing
"
;
newLoad
=
!
win
.
switchToTabHavingURI
(
preferencesURL
true
{
ignoreFragment
:
shouldReplaceFragment
replaceQueryString
:
true
}
)
;
browser
=
win
.
gBrowser
.
selectedBrowser
;
}
if
(
newLoad
)
{
Services
.
obs
.
addObserver
(
function
advancedPaneLoadedObs
(
prefWin
topic
data
)
{
if
(
!
browser
)
{
browser
=
win
.
gBrowser
.
selectedBrowser
;
}
if
(
prefWin
!
=
browser
.
contentWindow
)
{
return
;
}
Services
.
obs
.
removeObserver
(
advancedPaneLoadedObs
"
advanced
-
pane
-
loaded
"
)
;
switchToAdvancedSubPane
(
browser
.
contentDocument
)
;
}
"
advanced
-
pane
-
loaded
"
false
)
;
}
else
{
if
(
paneID
)
{
browser
.
contentWindow
.
gotoPref
(
paneID
)
;
}
switchToAdvancedSubPane
(
browser
.
contentDocument
)
;
}
}
function
openAdvancedPreferences
(
tabID
)
{
openPreferences
(
"
paneAdvanced
"
{
"
advancedTab
"
:
tabID
}
)
;
}
function
openTroubleshootingPage
(
)
{
openUILinkIn
(
"
about
:
support
"
"
tab
"
)
;
}
function
openHealthReport
(
)
{
openUILinkIn
(
"
about
:
healthreport
"
"
tab
"
)
;
}
function
openFeedbackPage
(
)
{
var
url
=
Components
.
classes
[
"
mozilla
.
org
/
toolkit
/
URLFormatterService
;
1
"
]
.
getService
(
Components
.
interfaces
.
nsIURLFormatter
)
.
formatURLPref
(
"
app
.
feedback
.
baseURL
"
)
;
openUILinkIn
(
url
"
tab
"
)
;
}
function
openTourPage
(
)
{
let
scope
=
{
}
Components
.
utils
.
import
(
"
resource
:
/
/
/
modules
/
UITour
.
jsm
"
scope
)
;
openUILinkIn
(
scope
.
UITour
.
url
"
tab
"
)
;
}
function
buildHelpMenu
(
)
{
if
(
typeof
gSafeBrowsing
!
=
"
undefined
"
)
{
gSafeBrowsing
.
setReportPhishingMenu
(
)
;
}
}
function
isElementVisible
(
aElement
)
{
if
(
!
aElement
)
return
false
;
var
bo
=
aElement
.
boxObject
;
return
(
bo
.
height
>
0
&
&
bo
.
width
>
0
)
;
}
function
makeURLAbsolute
(
aBase
aUrl
)
{
return
makeURI
(
aUrl
null
makeURI
(
aBase
)
)
.
spec
;
}
function
openNewTabWith
(
aURL
aDocument
aPostData
aEvent
aAllowThirdPartyFixup
aReferrer
aReferrerPolicy
)
{
let
originCharset
=
null
;
if
(
document
.
documentElement
.
getAttribute
(
"
windowtype
"
)
=
=
"
navigator
:
browser
"
)
originCharset
=
gBrowser
.
selectedBrowser
.
characterSet
;
openLinkIn
(
aURL
aEvent
&
&
aEvent
.
shiftKey
?
"
tabshifted
"
:
"
tab
"
{
charset
:
originCharset
postData
:
aPostData
allowThirdPartyFixup
:
aAllowThirdPartyFixup
referrerURI
:
aReferrer
referrerPolicy
:
aReferrerPolicy
}
)
;
}
function
openNewWindowWith
(
aURL
aDocument
aPostData
aAllowThirdPartyFixup
aReferrer
aReferrerPolicy
)
{
let
originCharset
=
null
;
if
(
document
.
documentElement
.
getAttribute
(
"
windowtype
"
)
=
=
"
navigator
:
browser
"
)
originCharset
=
gBrowser
.
selectedBrowser
.
characterSet
;
openLinkIn
(
aURL
"
window
"
{
charset
:
originCharset
postData
:
aPostData
allowThirdPartyFixup
:
aAllowThirdPartyFixup
referrerURI
:
aReferrer
referrerPolicy
:
aReferrerPolicy
}
)
;
}
function
getHelpLinkURL
(
aHelpTopic
)
{
var
url
=
Components
.
classes
[
"
mozilla
.
org
/
toolkit
/
URLFormatterService
;
1
"
]
.
getService
(
Components
.
interfaces
.
nsIURLFormatter
)
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
;
return
url
+
aHelpTopic
;
}
function
openHelpLink
(
aHelpTopic
aCalledFromModal
aWhere
)
{
var
url
=
getHelpLinkURL
(
aHelpTopic
)
;
var
where
=
aWhere
;
if
(
!
aWhere
)
where
=
aCalledFromModal
?
"
window
"
:
"
tab
"
;
openUILinkIn
(
url
where
)
;
}
function
openPrefsHelp
(
)
{
var
instantApply
=
getBoolPref
(
"
browser
.
preferences
.
instantApply
"
)
;
var
helpTopic
=
document
.
getElementsByTagName
(
"
prefwindow
"
)
[
0
]
.
currentPane
.
helpTopic
;
openHelpLink
(
helpTopic
!
instantApply
)
;
}
function
trimURL
(
aURL
)
{
let
url
=
aURL
.
replace
(
/
^
(
(
?
:
http
|
https
|
ftp
)
:
\
/
\
/
[
^
/
]
+
)
\
/
/
"
1
"
)
;
if
(
!
url
.
startsWith
(
"
http
:
/
/
"
)
)
{
return
url
;
}
let
urlWithoutProtocol
=
url
.
substring
(
7
)
;
let
flags
=
Services
.
uriFixup
.
FIXUP_FLAG_ALLOW_KEYWORD_LOOKUP
|
Services
.
uriFixup
.
FIXUP_FLAG_FIX_SCHEME_TYPOS
;
let
fixedUpURL
expectedURLSpec
;
try
{
fixedUpURL
=
Services
.
uriFixup
.
createFixupURI
(
urlWithoutProtocol
flags
)
;
expectedURLSpec
=
makeURI
(
aURL
)
.
spec
;
}
catch
(
ex
)
{
return
url
;
}
if
(
fixedUpURL
.
spec
=
=
expectedURLSpec
)
{
return
urlWithoutProtocol
;
}
return
url
;
}
