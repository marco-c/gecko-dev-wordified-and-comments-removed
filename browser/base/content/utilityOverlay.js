ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PrivateBrowsingUtils
"
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
BrowserWindowTracker
:
"
resource
:
/
/
/
modules
/
BrowserWindowTracker
.
jsm
"
ContextualIdentityService
:
"
resource
:
/
/
gre
/
modules
/
ContextualIdentityService
.
jsm
"
ShellService
:
"
resource
:
/
/
/
modules
/
ShellService
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
aboutNewTabService
"
"
mozilla
.
org
/
browser
/
aboutnewtab
-
service
;
1
"
"
nsIAboutNewTabService
"
)
;
Object
.
defineProperty
(
this
"
BROWSER_NEW_TAB_URL
"
{
configurable
:
true
enumerable
:
true
get
(
)
{
if
(
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
&
&
!
PrivateBrowsingUtils
.
permanentPrivateBrowsing
&
&
!
aboutNewTabService
.
overridden
)
{
return
"
about
:
privatebrowsing
"
;
}
return
aboutNewTabService
.
newTabURL
;
}
}
)
;
var
TAB_DROP_TYPE
=
"
application
/
x
-
moz
-
tabbrowser
-
tab
"
;
var
gBidiUI
=
false
;
function
isBlankPageURL
(
aURL
)
{
return
aURL
=
=
"
about
:
blank
"
|
|
aURL
=
=
"
about
:
home
"
|
|
aURL
=
=
"
about
:
welcome
"
|
|
aURL
=
=
BROWSER_NEW_TAB_URL
;
}
function
getBrowserURL
(
)
{
return
"
chrome
:
/
/
browser
/
content
/
browser
.
xul
"
;
}
function
getTopWin
(
skipPopups
)
{
if
(
top
.
document
.
documentElement
.
getAttribute
(
"
windowtype
"
)
=
=
"
navigator
:
browser
"
&
&
(
!
skipPopups
|
|
top
.
toolbar
.
visible
)
)
return
top
;
return
BrowserWindowTracker
.
getTopWindow
(
{
private
:
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
allowPopups
:
!
skipPopups
}
)
;
}
function
getBoolPref
(
prefname
def
)
{
try
{
return
Services
.
prefs
.
getBoolPref
(
prefname
)
;
}
catch
(
er
)
{
return
def
;
}
}
function
doGetProtocolFlags
(
aURI
)
{
let
handler
=
Services
.
io
.
getProtocolHandler
(
aURI
.
scheme
)
;
return
handler
instanceof
Ci
.
nsIProtocolHandlerWithDynamicFlags
?
handler
.
QueryInterface
(
Ci
.
nsIProtocolHandlerWithDynamicFlags
)
.
getFlagsForURI
(
aURI
)
:
handler
.
protocolFlags
;
}
function
openUILink
(
url
event
aIgnoreButton
aIgnoreAlt
aAllowThirdPartyFixup
aPostData
aReferrerURI
)
{
let
params
;
if
(
aIgnoreButton
&
&
typeof
aIgnoreButton
=
=
"
object
"
)
{
params
=
aIgnoreButton
;
aIgnoreButton
=
params
.
ignoreButton
;
aIgnoreAlt
=
params
.
ignoreAlt
;
delete
params
.
ignoreButton
;
delete
params
.
ignoreAlt
;
}
else
{
params
=
{
allowThirdPartyFixup
:
aAllowThirdPartyFixup
postData
:
aPostData
referrerURI
:
aReferrerURI
referrerPolicy
:
Ci
.
nsIHttpChannel
.
REFERRER_POLICY_UNSET
initiatingDoc
:
event
?
event
.
target
.
ownerDocument
:
null
}
;
}
if
(
!
params
.
triggeringPrincipal
)
{
throw
new
Error
(
"
Required
argument
triggeringPrincipal
missing
within
openUILink
"
)
;
}
let
where
=
whereToOpenLink
(
event
aIgnoreButton
aIgnoreAlt
)
;
openUILinkIn
(
url
where
params
)
;
}
function
whereToOpenLink
(
e
ignoreButton
ignoreAlt
)
{
if
(
!
e
)
return
"
current
"
;
var
shift
=
e
.
shiftKey
;
var
ctrl
=
e
.
ctrlKey
;
var
meta
=
e
.
metaKey
;
var
alt
=
e
.
altKey
&
&
!
ignoreAlt
;
var
middle
=
!
ignoreButton
&
&
e
.
button
=
=
1
;
var
middleUsesTabs
=
getBoolPref
(
"
browser
.
tabs
.
opentabfor
.
middleclick
"
true
)
;
var
metaKey
=
AppConstants
.
platform
=
=
"
macosx
"
?
meta
:
ctrl
;
if
(
metaKey
|
|
(
middle
&
&
middleUsesTabs
)
)
return
shift
?
"
tabshifted
"
:
"
tab
"
;
if
(
alt
&
&
getBoolPref
(
"
browser
.
altClickSave
"
false
)
)
return
"
save
"
;
if
(
shift
|
|
(
middle
&
&
!
middleUsesTabs
)
)
return
"
window
"
;
return
"
current
"
;
}
function
openTrustedLinkIn
(
url
where
aParams
)
{
var
params
=
aParams
;
if
(
!
params
)
{
params
=
{
}
;
}
if
(
!
params
.
triggeringPrincipal
)
{
params
.
triggeringPrincipal
=
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
;
}
openUILinkIn
(
url
where
params
)
;
}
function
openWebLinkIn
(
url
where
params
)
{
if
(
!
params
)
{
params
=
{
}
;
}
if
(
!
params
.
triggeringPrincipal
)
{
params
.
triggeringPrincipal
=
Services
.
scriptSecurityManager
.
createNullPrincipal
(
{
}
)
;
}
openUILinkIn
(
url
where
params
)
;
}
function
openUILinkIn
(
url
where
aAllowThirdPartyFixup
aPostData
aReferrerURI
)
{
var
params
;
if
(
arguments
.
length
=
=
3
&
&
typeof
arguments
[
2
]
=
=
"
object
"
)
{
params
=
aAllowThirdPartyFixup
;
}
else
{
throw
new
Error
(
"
Required
argument
triggeringPrincipal
missing
within
openUILinkIn
"
)
;
}
params
.
fromChrome
=
true
;
openLinkIn
(
url
where
params
)
;
}
function
openLinkIn
(
url
where
params
)
{
if
(
!
where
|
|
!
url
)
return
;
var
aFromChrome
=
params
.
fromChrome
;
var
aAllowThirdPartyFixup
=
params
.
allowThirdPartyFixup
;
var
aPostData
=
params
.
postData
;
var
aCharset
=
params
.
charset
;
var
aReferrerURI
=
params
.
referrerURI
;
var
aReferrerPolicy
=
(
"
referrerPolicy
"
in
params
?
params
.
referrerPolicy
:
Ci
.
nsIHttpChannel
.
REFERRER_POLICY_UNSET
)
;
var
aRelatedToCurrent
=
params
.
relatedToCurrent
;
var
aAllowMixedContent
=
params
.
allowMixedContent
;
var
aForceAllowDataURI
=
params
.
forceAllowDataURI
;
var
aInBackground
=
params
.
inBackground
;
var
aDisallowInheritPrincipal
=
params
.
disallowInheritPrincipal
;
var
aInitiatingDoc
=
params
.
initiatingDoc
;
var
aIsPrivate
=
params
.
private
;
var
aSkipTabAnimation
=
params
.
skipTabAnimation
;
var
aAllowPinnedTabHostChange
=
!
!
params
.
allowPinnedTabHostChange
;
var
aNoReferrer
=
params
.
noReferrer
;
var
aAllowPopups
=
!
!
params
.
allowPopups
;
var
aUserContextId
=
params
.
userContextId
;
var
aIndicateErrorPageLoad
=
params
.
indicateErrorPageLoad
;
var
aPrincipal
=
params
.
originPrincipal
;
var
aTriggeringPrincipal
=
params
.
triggeringPrincipal
;
var
aForceAboutBlankViewerInCurrent
=
params
.
forceAboutBlankViewerInCurrent
;
var
aResolveOnNewTabCreated
=
params
.
resolveOnNewTabCreated
;
if
(
where
=
=
"
save
"
)
{
if
(
"
isContentWindowPrivate
"
in
params
)
{
saveURL
(
url
null
null
true
true
aNoReferrer
?
null
:
aReferrerURI
null
params
.
isContentWindowPrivate
aPrincipal
)
;
}
else
{
if
(
!
aInitiatingDoc
)
{
Cu
.
reportError
(
"
openUILink
/
openLinkIn
was
called
with
"
+
"
where
=
=
'
save
'
but
without
initiatingDoc
.
See
bug
814264
.
"
)
;
return
;
}
saveURL
(
url
null
null
true
true
aNoReferrer
?
null
:
aReferrerURI
aInitiatingDoc
)
;
}
return
;
}
let
w
;
if
(
where
=
=
"
current
"
&
&
params
.
targetBrowser
)
{
w
=
params
.
targetBrowser
.
ownerGlobal
;
}
else
{
w
=
getTopWin
(
)
;
}
if
(
(
where
=
=
"
tab
"
|
|
where
=
=
"
tabshifted
"
)
&
&
w
&
&
!
w
.
toolbar
.
visible
)
{
w
=
getTopWin
(
true
)
;
aRelatedToCurrent
=
false
;
}
function
useOAForPrincipal
(
principal
)
{
if
(
principal
&
&
principal
.
isCodebasePrincipal
)
{
let
attrs
=
{
userContextId
:
aUserContextId
privateBrowsingId
:
aIsPrivate
|
|
(
w
&
&
PrivateBrowsingUtils
.
isWindowPrivate
(
w
)
)
}
;
return
Services
.
scriptSecurityManager
.
createCodebasePrincipal
(
principal
.
URI
attrs
)
;
}
return
principal
;
}
aPrincipal
=
useOAForPrincipal
(
aPrincipal
)
;
aTriggeringPrincipal
=
useOAForPrincipal
(
aTriggeringPrincipal
)
;
if
(
!
w
|
|
where
=
=
"
window
"
)
{
let
features
=
"
chrome
dialog
=
no
all
"
;
if
(
aIsPrivate
)
{
features
+
=
"
private
"
;
aNoReferrer
=
true
;
}
var
sa
=
Cc
[
"
mozilla
.
org
/
array
;
1
"
]
.
createInstance
(
Ci
.
nsIMutableArray
)
;
var
wuri
=
Cc
[
"
mozilla
.
org
/
supports
-
string
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsString
)
;
wuri
.
data
=
url
;
let
charset
=
null
;
if
(
aCharset
)
{
charset
=
Cc
[
"
mozilla
.
org
/
supports
-
string
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsString
)
;
charset
.
data
=
"
charset
=
"
+
aCharset
;
}
var
allowThirdPartyFixupSupports
=
Cc
[
"
mozilla
.
org
/
supports
-
PRBool
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsPRBool
)
;
allowThirdPartyFixupSupports
.
data
=
aAllowThirdPartyFixup
;
var
referrerURISupports
=
null
;
if
(
aReferrerURI
&
&
!
aNoReferrer
)
{
referrerURISupports
=
Cc
[
"
mozilla
.
org
/
supports
-
string
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsString
)
;
referrerURISupports
.
data
=
aReferrerURI
.
spec
;
}
var
referrerPolicySupports
=
Cc
[
"
mozilla
.
org
/
supports
-
PRUint32
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsPRUint32
)
;
referrerPolicySupports
.
data
=
aReferrerPolicy
;
var
userContextIdSupports
=
Cc
[
"
mozilla
.
org
/
supports
-
PRUint32
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsPRUint32
)
;
userContextIdSupports
.
data
=
aUserContextId
;
sa
.
appendElement
(
wuri
)
;
sa
.
appendElement
(
charset
)
;
sa
.
appendElement
(
referrerURISupports
)
;
sa
.
appendElement
(
aPostData
)
;
sa
.
appendElement
(
allowThirdPartyFixupSupports
)
;
sa
.
appendElement
(
referrerPolicySupports
)
;
sa
.
appendElement
(
userContextIdSupports
)
;
sa
.
appendElement
(
aPrincipal
)
;
sa
.
appendElement
(
aTriggeringPrincipal
)
;
const
sourceWindow
=
(
w
|
|
window
)
;
let
win
;
if
(
params
.
frameOuterWindowID
!
=
undefined
&
&
sourceWindow
)
{
const
sourceTabBrowser
=
sourceWindow
.
gBrowser
.
selectedBrowser
;
let
delayedStartupObserver
=
aSubject
=
>
{
if
(
aSubject
=
=
win
)
{
Services
.
obs
.
removeObserver
(
delayedStartupObserver
"
browser
-
delayed
-
startup
-
finished
"
)
;
Services
.
obs
.
notifyObservers
(
{
wrappedJSObject
:
{
url
createdTabBrowser
:
win
.
gBrowser
.
selectedBrowser
sourceTabBrowser
sourceFrameOuterWindowID
:
params
.
frameOuterWindowID
}
}
"
webNavigation
-
createdNavigationTarget
"
)
;
}
}
;
Services
.
obs
.
addObserver
(
delayedStartupObserver
"
browser
-
delayed
-
startup
-
finished
"
)
;
}
win
=
Services
.
ww
.
openWindow
(
sourceWindow
getBrowserURL
(
)
null
features
sa
)
;
return
;
}
w
.
focus
(
)
;
let
targetBrowser
;
let
loadInBackground
;
let
uriObj
;
if
(
where
=
=
"
current
"
)
{
targetBrowser
=
params
.
targetBrowser
|
|
w
.
gBrowser
.
selectedBrowser
;
loadInBackground
=
false
;
try
{
uriObj
=
Services
.
io
.
newURI
(
url
)
;
}
catch
(
e
)
{
}
if
(
w
.
gBrowser
.
getTabForBrowser
(
targetBrowser
)
.
pinned
&
&
!
aAllowPinnedTabHostChange
)
{
try
{
if
(
!
uriObj
|
|
(
!
uriObj
.
schemeIs
(
"
javascript
"
)
&
&
targetBrowser
.
currentURI
.
host
!
=
uriObj
.
host
)
)
{
where
=
"
tab
"
;
loadInBackground
=
false
;
}
}
catch
(
err
)
{
where
=
"
tab
"
;
loadInBackground
=
false
;
}
}
}
else
{
loadInBackground
=
aInBackground
;
if
(
loadInBackground
=
=
null
)
{
loadInBackground
=
aFromChrome
?
false
:
getBoolPref
(
"
browser
.
tabs
.
loadInBackground
"
)
;
}
}
let
focusUrlBar
=
false
;
switch
(
where
)
{
case
"
current
"
:
let
flags
=
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_NONE
;
if
(
aAllowThirdPartyFixup
)
{
flags
|
=
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP
;
flags
|
=
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_FIXUP_SCHEME_TYPOS
;
}
if
(
aDisallowInheritPrincipal
&
&
!
(
uriObj
&
&
uriObj
.
schemeIs
(
"
javascript
"
)
)
)
{
flags
|
=
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_DISALLOW_INHERIT_PRINCIPAL
;
}
if
(
aAllowPopups
)
{
flags
|
=
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_ALLOW_POPUPS
;
}
if
(
aIndicateErrorPageLoad
)
{
flags
|
=
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_ERROR_LOAD_CHANGES_RV
;
}
if
(
aForceAllowDataURI
)
{
flags
|
=
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_FORCE_ALLOW_DATA_URI
;
}
let
{
URI_INHERITS_SECURITY_CONTEXT
}
=
Ci
.
nsIProtocolHandler
;
if
(
aForceAboutBlankViewerInCurrent
&
&
(
!
uriObj
|
|
(
doGetProtocolFlags
(
uriObj
)
&
URI_INHERITS_SECURITY_CONTEXT
)
)
)
{
targetBrowser
.
createAboutBlankContentViewer
(
aPrincipal
)
;
}
targetBrowser
.
loadURI
(
url
{
triggeringPrincipal
:
aTriggeringPrincipal
flags
referrerURI
:
aNoReferrer
?
null
:
aReferrerURI
referrerPolicy
:
aReferrerPolicy
postData
:
aPostData
userContextId
:
aUserContextId
}
)
;
focusUrlBar
=
w
.
document
.
activeElement
=
=
w
.
gURLBar
.
inputField
&
&
w
.
isBlankPageURL
(
url
)
;
break
;
case
"
tabshifted
"
:
loadInBackground
=
!
loadInBackground
;
case
"
tab
"
:
focusUrlBar
=
!
loadInBackground
&
&
w
.
isBlankPageURL
(
url
)
&
&
!
aboutNewTabService
.
willNotifyUser
;
let
tabUsedForLoad
=
w
.
gBrowser
.
loadOneTab
(
url
{
referrerURI
:
aReferrerURI
referrerPolicy
:
aReferrerPolicy
charset
:
aCharset
postData
:
aPostData
inBackground
:
loadInBackground
allowThirdPartyFixup
:
aAllowThirdPartyFixup
relatedToCurrent
:
aRelatedToCurrent
skipAnimation
:
aSkipTabAnimation
allowMixedContent
:
aAllowMixedContent
noReferrer
:
aNoReferrer
userContextId
:
aUserContextId
originPrincipal
:
aPrincipal
triggeringPrincipal
:
aTriggeringPrincipal
focusUrlBar
}
)
;
targetBrowser
=
tabUsedForLoad
.
linkedBrowser
;
if
(
aResolveOnNewTabCreated
)
{
aResolveOnNewTabCreated
(
targetBrowser
)
;
}
if
(
params
.
frameOuterWindowID
!
=
undefined
&
&
w
)
{
Services
.
obs
.
notifyObservers
(
{
wrappedJSObject
:
{
url
createdTabBrowser
:
targetBrowser
sourceTabBrowser
:
w
.
gBrowser
.
selectedBrowser
sourceFrameOuterWindowID
:
params
.
frameOuterWindowID
}
}
"
webNavigation
-
createdNavigationTarget
"
)
;
}
break
;
}
if
(
!
focusUrlBar
&
&
targetBrowser
=
=
w
.
gBrowser
.
selectedBrowser
)
{
targetBrowser
.
focus
(
)
;
}
}
function
checkForMiddleClick
(
node
event
)
{
if
(
node
.
getAttribute
(
"
disabled
"
)
=
=
"
true
"
)
return
;
if
(
event
.
button
=
=
1
)
{
var
target
=
node
.
hasAttribute
(
"
oncommand
"
)
?
node
:
node
.
ownerDocument
.
getElementById
(
node
.
getAttribute
(
"
command
"
)
)
;
var
fn
=
new
Function
(
"
event
"
target
.
getAttribute
(
"
oncommand
"
)
)
;
fn
.
call
(
target
event
)
;
closeMenus
(
event
.
target
)
;
}
}
function
createUserContextMenu
(
event
{
isContextMenu
=
false
excludeUserContextId
=
0
showDefaultTab
=
false
useAccessKeys
=
true
}
=
{
}
)
{
while
(
event
.
target
.
hasChildNodes
(
)
)
{
event
.
target
.
firstChild
.
remove
(
)
;
}
let
bundle
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
browser
/
locale
/
browser
.
properties
"
)
;
let
docfrag
=
document
.
createDocumentFragment
(
)
;
if
(
excludeUserContextId
|
|
showDefaultTab
)
{
let
menuitem
=
document
.
createElement
(
"
menuitem
"
)
;
menuitem
.
setAttribute
(
"
data
-
usercontextid
"
"
0
"
)
;
menuitem
.
setAttribute
(
"
label
"
bundle
.
GetStringFromName
(
"
userContextNone
.
label
"
)
)
;
menuitem
.
setAttribute
(
"
accesskey
"
bundle
.
GetStringFromName
(
"
userContextNone
.
accesskey
"
)
)
;
docfrag
.
appendChild
(
menuitem
)
;
let
menuseparator
=
document
.
createElement
(
"
menuseparator
"
)
;
docfrag
.
appendChild
(
menuseparator
)
;
}
ContextualIdentityService
.
getPublicIdentities
(
)
.
forEach
(
identity
=
>
{
if
(
identity
.
userContextId
=
=
excludeUserContextId
)
{
return
;
}
let
menuitem
=
document
.
createElement
(
"
menuitem
"
)
;
menuitem
.
setAttribute
(
"
data
-
usercontextid
"
identity
.
userContextId
)
;
menuitem
.
setAttribute
(
"
label
"
ContextualIdentityService
.
getUserContextLabel
(
identity
.
userContextId
)
)
;
if
(
identity
.
accessKey
&
&
useAccessKeys
)
{
menuitem
.
setAttribute
(
"
accesskey
"
bundle
.
GetStringFromName
(
identity
.
accessKey
)
)
;
}
menuitem
.
classList
.
add
(
"
menuitem
-
iconic
"
)
;
menuitem
.
setAttribute
(
"
data
-
identity
-
color
"
identity
.
color
)
;
if
(
!
isContextMenu
)
{
menuitem
.
setAttribute
(
"
command
"
"
Browser
:
NewUserContextTab
"
)
;
}
menuitem
.
setAttribute
(
"
data
-
identity
-
icon
"
identity
.
icon
)
;
docfrag
.
appendChild
(
menuitem
)
;
}
)
;
if
(
!
isContextMenu
)
{
docfrag
.
appendChild
(
document
.
createElement
(
"
menuseparator
"
)
)
;
let
menuitem
=
document
.
createElement
(
"
menuitem
"
)
;
menuitem
.
setAttribute
(
"
label
"
bundle
.
GetStringFromName
(
"
userContext
.
aboutPage
.
label
"
)
)
;
if
(
useAccessKeys
)
{
menuitem
.
setAttribute
(
"
accesskey
"
bundle
.
GetStringFromName
(
"
userContext
.
aboutPage
.
accesskey
"
)
)
;
}
menuitem
.
setAttribute
(
"
command
"
"
Browser
:
OpenAboutContainers
"
)
;
docfrag
.
appendChild
(
menuitem
)
;
}
event
.
target
.
appendChild
(
docfrag
)
;
return
true
;
}
function
closeMenus
(
node
)
{
if
(
"
tagName
"
in
node
)
{
if
(
node
.
namespaceURI
=
=
"
http
:
/
/
www
.
mozilla
.
org
/
keymaster
/
gatekeeper
/
there
.
is
.
only
.
xul
"
&
&
(
node
.
tagName
=
=
"
menupopup
"
|
|
node
.
tagName
=
=
"
popup
"
)
)
node
.
hidePopup
(
)
;
closeMenus
(
node
.
parentNode
)
;
}
}
function
eventMatchesKey
(
aEvent
aKey
)
{
let
keyPressed
=
aKey
.
getAttribute
(
"
key
"
)
.
toLowerCase
(
)
;
let
keyModifiers
=
aKey
.
getAttribute
(
"
modifiers
"
)
;
let
modifiers
=
[
"
Alt
"
"
Control
"
"
Meta
"
"
Shift
"
]
;
if
(
aEvent
.
key
!
=
keyPressed
)
{
return
false
;
}
let
eventModifiers
=
modifiers
.
filter
(
modifier
=
>
aEvent
.
getModifierState
(
modifier
)
)
;
if
(
eventModifiers
.
length
>
0
&
&
keyModifiers
.
length
=
=
0
)
{
return
false
;
}
if
(
keyModifiers
)
{
keyModifiers
=
keyModifiers
.
split
(
/
[
\
s
]
+
/
)
;
keyModifiers
.
forEach
(
function
(
modifier
index
)
{
if
(
modifier
=
=
"
accel
"
)
{
keyModifiers
[
index
]
=
AppConstants
.
platform
=
=
"
macosx
"
?
"
Meta
"
:
"
Control
"
;
}
else
{
keyModifiers
[
index
]
=
modifier
[
0
]
.
toUpperCase
(
)
+
modifier
.
slice
(
1
)
;
}
}
)
;
return
modifiers
.
every
(
modifier
=
>
keyModifiers
.
includes
(
modifier
)
=
=
aEvent
.
getModifierState
(
modifier
)
)
;
}
return
true
;
}
function
gatherTextUnder
(
root
)
{
var
text
=
"
"
;
var
node
=
root
.
firstChild
;
var
depth
=
1
;
while
(
node
&
&
depth
>
0
)
{
if
(
node
.
nodeType
=
=
Node
.
TEXT_NODE
)
{
text
+
=
"
"
+
node
.
data
;
}
else
if
(
node
instanceof
HTMLImageElement
)
{
var
altText
=
node
.
getAttribute
(
"
alt
"
)
;
if
(
altText
&
&
altText
!
=
"
"
)
{
text
+
=
"
"
+
altText
;
}
}
if
(
node
.
hasChildNodes
(
)
)
{
node
=
node
.
firstChild
;
depth
+
+
;
}
else
{
while
(
depth
>
0
&
&
!
node
.
nextSibling
)
{
node
=
node
.
parentNode
;
depth
-
-
;
}
if
(
node
.
nextSibling
)
{
node
=
node
.
nextSibling
;
}
}
}
text
=
text
.
trim
(
)
;
text
=
text
.
replace
(
/
\
s
+
/
g
"
"
)
;
return
text
;
}
function
getShellService
(
)
{
return
ShellService
;
}
function
isBidiEnabled
(
)
{
if
(
getBoolPref
(
"
bidi
.
browser
.
ui
"
false
)
)
return
true
;
const
isRTL
=
Services
.
locale
.
isAppLocaleRTL
;
if
(
isRTL
)
{
Services
.
prefs
.
setBoolPref
(
"
bidi
.
browser
.
ui
"
true
)
;
}
return
isRTL
;
}
function
openAboutDialog
(
)
{
var
enumerator
=
Services
.
wm
.
getEnumerator
(
"
Browser
:
About
"
)
;
while
(
enumerator
.
hasMoreElements
(
)
)
{
let
win
=
enumerator
.
getNext
(
)
;
if
(
win
.
closed
)
{
continue
;
}
win
.
focus
(
)
;
return
;
}
var
features
=
"
chrome
"
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
features
+
=
"
centerscreen
dependent
"
;
}
else
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
features
+
=
"
resizable
=
no
minimizable
=
no
"
;
}
else
{
features
+
=
"
centerscreen
dependent
dialog
=
no
"
;
}
window
.
openDialog
(
"
chrome
:
/
/
browser
/
content
/
aboutDialog
.
xul
"
"
"
features
)
;
}
function
openPreferences
(
paneID
extraArgs
)
{
let
histogram
=
Services
.
telemetry
.
getHistogramById
(
"
FX_PREFERENCES_OPENED_VIA
"
)
;
if
(
extraArgs
&
&
extraArgs
.
origin
)
{
histogram
.
add
(
extraArgs
.
origin
)
;
}
else
{
histogram
.
add
(
"
other
"
)
;
}
function
internalPrefCategoryNameToFriendlyName
(
aName
)
{
return
(
aName
|
|
"
"
)
.
replace
(
/
^
pane
.
/
function
(
toReplace
)
{
return
toReplace
[
4
]
.
toLowerCase
(
)
;
}
)
;
}
let
win
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
let
friendlyCategoryName
=
internalPrefCategoryNameToFriendlyName
(
paneID
)
;
let
params
;
if
(
extraArgs
&
&
extraArgs
.
urlParams
)
{
params
=
new
URLSearchParams
(
)
;
let
urlParams
=
extraArgs
.
urlParams
;
for
(
let
name
in
urlParams
)
{
if
(
urlParams
[
name
]
!
=
=
undefined
)
{
params
.
set
(
name
urlParams
[
name
]
)
;
}
}
}
let
preferencesURL
=
"
about
:
preferences
"
+
(
params
?
"
?
"
+
params
:
"
"
)
+
(
friendlyCategoryName
?
"
#
"
+
friendlyCategoryName
:
"
"
)
;
let
newLoad
=
true
;
let
browser
=
null
;
if
(
!
win
)
{
let
windowArguments
=
Cc
[
"
mozilla
.
org
/
array
;
1
"
]
.
createInstance
(
Ci
.
nsIMutableArray
)
;
let
supportsStringPrefURL
=
Cc
[
"
mozilla
.
org
/
supports
-
string
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsString
)
;
supportsStringPrefURL
.
data
=
preferencesURL
;
windowArguments
.
appendElement
(
supportsStringPrefURL
)
;
win
=
Services
.
ww
.
openWindow
(
null
Services
.
prefs
.
getCharPref
(
"
browser
.
chromeURL
"
)
"
_blank
"
"
chrome
dialog
=
no
all
"
windowArguments
)
;
}
else
{
let
shouldReplaceFragment
=
friendlyCategoryName
?
"
whenComparingAndReplace
"
:
"
whenComparing
"
;
newLoad
=
!
win
.
switchToTabHavingURI
(
preferencesURL
true
{
ignoreFragment
:
shouldReplaceFragment
replaceQueryString
:
true
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
}
)
;
browser
=
win
.
gBrowser
.
selectedBrowser
;
}
if
(
newLoad
)
{
Services
.
obs
.
addObserver
(
function
panesLoadedObs
(
prefWin
topic
data
)
{
if
(
!
browser
)
{
browser
=
win
.
gBrowser
.
selectedBrowser
;
}
if
(
prefWin
!
=
browser
.
contentWindow
)
{
return
;
}
Services
.
obs
.
removeObserver
(
panesLoadedObs
"
sync
-
pane
-
loaded
"
)
;
}
"
sync
-
pane
-
loaded
"
)
;
}
else
if
(
paneID
)
{
browser
.
contentWindow
.
gotoPref
(
paneID
)
;
}
}
function
openTroubleshootingPage
(
)
{
openTrustedLinkIn
(
"
about
:
support
"
"
tab
"
)
;
}
function
openFeedbackPage
(
)
{
var
url
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
feedback
.
baseURL
"
)
;
openTrustedLinkIn
(
url
"
tab
"
)
;
}
function
openTourPage
(
)
{
let
scope
=
{
}
;
ChromeUtils
.
import
(
"
resource
:
/
/
/
modules
/
UITour
.
jsm
"
scope
)
;
openTrustedLinkIn
(
scope
.
UITour
.
url
"
tab
"
)
;
}
function
buildHelpMenu
(
)
{
document
.
getElementById
(
"
feedbackPage
"
)
.
disabled
=
!
Services
.
policies
.
isAllowed
(
"
feedbackCommands
"
)
;
document
.
getElementById
(
"
helpSafeMode
"
)
.
disabled
=
!
Services
.
policies
.
isAllowed
(
"
safeMode
"
)
;
if
(
typeof
gSafeBrowsing
!
=
"
undefined
"
)
{
gSafeBrowsing
.
setReportPhishingMenu
(
)
;
}
}
function
isElementVisible
(
aElement
)
{
if
(
!
aElement
)
return
false
;
var
bo
=
aElement
.
boxObject
;
return
(
bo
.
height
>
0
&
&
bo
.
width
>
0
)
;
}
function
makeURLAbsolute
(
aBase
aUrl
)
{
return
makeURI
(
aUrl
null
makeURI
(
aBase
)
)
.
spec
;
}
function
openNewTabWith
(
aURL
aShiftKey
aParams
=
{
}
)
{
if
(
document
.
documentElement
.
getAttribute
(
"
windowtype
"
)
=
=
"
navigator
:
browser
"
)
aParams
.
charset
=
gBrowser
.
selectedBrowser
.
characterSet
;
openLinkIn
(
aURL
aShiftKey
?
"
tabshifted
"
:
"
tab
"
aParams
)
;
}
function
openNewWindowWith
(
aURL
aParams
=
{
}
)
{
if
(
document
.
documentElement
.
getAttribute
(
"
windowtype
"
)
=
=
"
navigator
:
browser
"
)
aParams
.
charset
=
gBrowser
.
selectedBrowser
.
characterSet
;
openLinkIn
(
aURL
"
window
"
aParams
)
;
}
function
getHelpLinkURL
(
aHelpTopic
)
{
var
url
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
;
return
url
+
aHelpTopic
;
}
function
openHelpLink
(
aHelpTopic
aCalledFromModal
aWhere
)
{
var
url
=
getHelpLinkURL
(
aHelpTopic
)
;
var
where
=
aWhere
;
if
(
!
aWhere
)
where
=
aCalledFromModal
?
"
window
"
:
"
tab
"
;
openTrustedLinkIn
(
url
where
)
;
}
function
openPrefsHelp
(
)
{
var
instantApply
=
getBoolPref
(
"
browser
.
preferences
.
instantApply
"
)
;
var
helpTopic
=
document
.
documentElement
.
getAttribute
(
"
helpTopic
"
)
;
openHelpLink
(
helpTopic
!
instantApply
)
;
}
function
trimURL
(
aURL
)
{
let
url
=
aURL
.
replace
(
/
^
(
(
?
:
http
|
https
|
ftp
)
:
\
/
\
/
[
^
/
]
+
)
\
/
/
"
1
"
)
;
if
(
!
url
.
startsWith
(
"
http
:
/
/
"
)
)
{
return
url
;
}
let
urlWithoutProtocol
=
url
.
substring
(
7
)
;
let
flags
=
Services
.
uriFixup
.
FIXUP_FLAG_ALLOW_KEYWORD_LOOKUP
|
Services
.
uriFixup
.
FIXUP_FLAG_FIX_SCHEME_TYPOS
;
let
fixedUpURL
expectedURLSpec
;
try
{
fixedUpURL
=
Services
.
uriFixup
.
createFixupURI
(
urlWithoutProtocol
flags
)
;
expectedURLSpec
=
makeURI
(
aURL
)
.
displaySpec
;
}
catch
(
ex
)
{
return
url
;
}
if
(
fixedUpURL
.
displaySpec
=
=
expectedURLSpec
)
{
return
urlWithoutProtocol
;
}
return
url
;
}
