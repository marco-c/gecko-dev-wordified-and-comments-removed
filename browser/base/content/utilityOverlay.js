var
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
var
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AboutNewTab
:
"
resource
:
/
/
/
modules
/
AboutNewTab
.
jsm
"
BrowserUtils
:
"
resource
:
/
/
gre
/
modules
/
BrowserUtils
.
jsm
"
BrowserWindowTracker
:
"
resource
:
/
/
/
modules
/
BrowserWindowTracker
.
jsm
"
ContextualIdentityService
:
"
resource
:
/
/
gre
/
modules
/
ContextualIdentityService
.
jsm
"
ExtensionSettingsStore
:
"
resource
:
/
/
gre
/
modules
/
ExtensionSettingsStore
.
jsm
"
PrivateBrowsingUtils
:
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
ShellService
:
"
resource
:
/
/
/
modules
/
ShellService
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
ReferrerInfo
"
(
)
=
>
Components
.
Constructor
(
"
mozilla
.
org
/
referrer
-
info
;
1
"
"
nsIReferrerInfo
"
"
init
"
)
)
;
Object
.
defineProperty
(
this
"
BROWSER_NEW_TAB_URL
"
{
enumerable
:
true
get
(
)
{
if
(
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
{
if
(
!
PrivateBrowsingUtils
.
permanentPrivateBrowsing
&
&
!
AboutNewTab
.
newTabURLOverridden
)
{
return
"
about
:
privatebrowsing
"
;
}
let
extensionControlled
=
Services
.
prefs
.
getBoolPref
(
"
browser
.
newtab
.
extensionControlled
"
false
)
;
let
privateAllowed
=
Services
.
prefs
.
getBoolPref
(
"
browser
.
newtab
.
privateAllowed
"
false
)
;
if
(
!
privateAllowed
&
&
(
extensionControlled
|
|
AboutNewTab
.
newTabURL
.
startsWith
(
"
moz
-
extension
:
/
/
"
)
)
)
{
return
"
about
:
privatebrowsing
"
;
}
}
return
AboutNewTab
.
newTabURL
;
}
}
)
;
var
TAB_DROP_TYPE
=
"
application
/
x
-
moz
-
tabbrowser
-
tab
"
;
var
gBidiUI
=
false
;
function
isBlankPageURL
(
aURL
)
{
return
(
aURL
=
=
"
about
:
blank
"
|
|
aURL
=
=
"
about
:
home
"
|
|
aURL
=
=
"
about
:
welcome
"
|
|
aURL
=
=
BROWSER_NEW_TAB_URL
)
;
}
function
getTopWin
(
{
skipPopups
forceNonPrivate
}
=
{
}
)
{
if
(
top
.
document
.
documentElement
.
getAttribute
(
"
windowtype
"
)
=
=
"
navigator
:
browser
"
&
&
(
!
skipPopups
|
|
top
.
toolbar
.
visible
)
&
&
(
!
forceNonPrivate
|
|
!
PrivateBrowsingUtils
.
isWindowPrivate
(
top
)
)
)
{
return
top
;
}
return
BrowserWindowTracker
.
getTopWindow
(
{
private
:
!
forceNonPrivate
&
&
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
allowPopups
:
!
skipPopups
}
)
;
}
function
doGetProtocolFlags
(
aURI
)
{
let
handler
=
Services
.
io
.
getProtocolHandler
(
aURI
.
scheme
)
;
return
handler
instanceof
Ci
.
nsIProtocolHandlerWithDynamicFlags
?
handler
.
QueryInterface
(
Ci
.
nsIProtocolHandlerWithDynamicFlags
)
.
getFlagsForURI
(
aURI
)
:
handler
.
protocolFlags
;
}
function
openUILink
(
url
event
aIgnoreButton
aIgnoreAlt
aAllowThirdPartyFixup
aPostData
aReferrerInfo
)
{
event
=
getRootEvent
(
event
)
;
let
params
;
if
(
aIgnoreButton
&
&
typeof
aIgnoreButton
=
=
"
object
"
)
{
params
=
aIgnoreButton
;
aIgnoreButton
=
params
.
ignoreButton
;
aIgnoreAlt
=
params
.
ignoreAlt
;
delete
params
.
ignoreButton
;
delete
params
.
ignoreAlt
;
}
else
{
params
=
{
allowThirdPartyFixup
:
aAllowThirdPartyFixup
postData
:
aPostData
referrerInfo
:
aReferrerInfo
initiatingDoc
:
event
?
event
.
target
.
ownerDocument
:
null
}
;
}
if
(
!
params
.
triggeringPrincipal
)
{
throw
new
Error
(
"
Required
argument
triggeringPrincipal
missing
within
openUILink
"
)
;
}
let
where
=
whereToOpenLink
(
event
aIgnoreButton
aIgnoreAlt
)
;
openUILinkIn
(
url
where
params
)
;
}
function
getRootEvent
(
aEvent
)
{
return
BrowserUtils
.
getRootEvent
(
aEvent
)
;
}
function
whereToOpenLink
(
e
ignoreButton
ignoreAlt
)
{
return
BrowserUtils
.
whereToOpenLink
(
e
ignoreButton
ignoreAlt
)
;
}
function
openTrustedLinkIn
(
url
where
aParams
)
{
var
params
=
aParams
;
if
(
!
params
)
{
params
=
{
}
;
}
if
(
!
params
.
triggeringPrincipal
)
{
params
.
triggeringPrincipal
=
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
;
}
openUILinkIn
(
url
where
params
)
;
}
function
openWebLinkIn
(
url
where
params
)
{
if
(
!
params
)
{
params
=
{
}
;
}
if
(
!
params
.
triggeringPrincipal
)
{
params
.
triggeringPrincipal
=
Services
.
scriptSecurityManager
.
createNullPrincipal
(
{
}
)
;
}
if
(
params
.
triggeringPrincipal
.
isSystemPrincipal
)
{
throw
new
Error
(
"
System
principal
should
never
be
passed
into
openWebLinkIn
(
)
"
)
;
}
openUILinkIn
(
url
where
params
)
;
}
function
openUILinkIn
(
url
where
aAllowThirdPartyFixup
aPostData
aReferrerInfo
)
{
var
params
;
if
(
arguments
.
length
=
=
3
&
&
typeof
arguments
[
2
]
=
=
"
object
"
)
{
params
=
aAllowThirdPartyFixup
;
}
if
(
!
params
|
|
!
params
.
triggeringPrincipal
)
{
throw
new
Error
(
"
Required
argument
triggeringPrincipal
missing
within
openUILinkIn
"
)
;
}
params
.
fromChrome
=
params
.
fromChrome
?
?
true
;
openLinkIn
(
url
where
params
)
;
}
function
openLinkIn
(
url
where
params
)
{
if
(
!
where
|
|
!
url
)
{
return
;
}
var
aFromChrome
=
params
.
fromChrome
;
var
aAllowThirdPartyFixup
=
params
.
allowThirdPartyFixup
;
var
aPostData
=
params
.
postData
;
var
aCharset
=
params
.
charset
;
var
aReferrerInfo
=
params
.
referrerInfo
?
params
.
referrerInfo
:
new
ReferrerInfo
(
Ci
.
nsIReferrerInfo
.
EMPTY
true
null
)
;
var
aRelatedToCurrent
=
params
.
relatedToCurrent
;
var
aAllowInheritPrincipal
=
!
!
params
.
allowInheritPrincipal
;
var
aForceAllowDataURI
=
params
.
forceAllowDataURI
;
var
aInBackground
=
params
.
inBackground
;
var
aInitiatingDoc
=
params
.
initiatingDoc
;
var
aIsPrivate
=
params
.
private
;
var
aForceNonPrivate
=
params
.
forceNonPrivate
;
var
aSkipTabAnimation
=
params
.
skipTabAnimation
;
var
aAllowPinnedTabHostChange
=
!
!
params
.
allowPinnedTabHostChange
;
var
aAllowPopups
=
!
!
params
.
allowPopups
;
var
aUserContextId
=
params
.
userContextId
;
var
aIndicateErrorPageLoad
=
params
.
indicateErrorPageLoad
;
var
aPrincipal
=
params
.
originPrincipal
;
var
aStoragePrincipal
=
params
.
originStoragePrincipal
;
var
aTriggeringPrincipal
=
params
.
triggeringPrincipal
;
var
aCsp
=
params
.
csp
;
var
aForceAboutBlankViewerInCurrent
=
params
.
forceAboutBlankViewerInCurrent
;
var
aResolveOnNewTabCreated
=
params
.
resolveOnNewTabCreated
;
var
aResolveOnContentBrowserReady
=
params
.
resolveOnContentBrowserCreated
;
var
aGlobalHistoryOptions
=
params
.
globalHistoryOptions
;
if
(
!
aTriggeringPrincipal
)
{
throw
new
Error
(
"
Must
load
with
a
triggering
Principal
"
)
;
}
if
(
where
=
=
"
save
"
)
{
if
(
"
isContentWindowPrivate
"
in
params
)
{
saveURL
(
url
null
null
null
true
true
aReferrerInfo
null
null
params
.
isContentWindowPrivate
aPrincipal
)
;
}
else
{
if
(
!
aInitiatingDoc
)
{
Cu
.
reportError
(
"
openUILink
/
openLinkIn
was
called
with
"
+
"
where
=
=
'
save
'
but
without
initiatingDoc
.
See
bug
814264
.
"
)
;
return
;
}
saveURL
(
url
null
null
null
true
true
aReferrerInfo
null
aInitiatingDoc
)
;
}
return
;
}
let
w
;
if
(
where
=
=
"
current
"
&
&
params
.
targetBrowser
)
{
w
=
params
.
targetBrowser
.
ownerGlobal
;
}
else
{
w
=
getTopWin
(
{
forceNonPrivate
:
aForceNonPrivate
}
)
;
}
if
(
(
where
=
=
"
tab
"
|
|
where
=
=
"
tabshifted
"
)
&
&
w
&
&
!
w
.
toolbar
.
visible
)
{
w
=
getTopWin
(
{
skipPopups
:
true
forceNonPrivate
:
aForceNonPrivate
}
)
;
aRelatedToCurrent
=
false
;
}
function
useOAForPrincipal
(
principal
)
{
if
(
principal
&
&
principal
.
isContentPrincipal
)
{
let
attrs
=
{
userContextId
:
aUserContextId
privateBrowsingId
:
aIsPrivate
|
|
(
w
&
&
PrivateBrowsingUtils
.
isWindowPrivate
(
w
)
)
firstPartyDomain
:
principal
.
originAttributes
.
firstPartyDomain
}
;
return
Services
.
scriptSecurityManager
.
principalWithOA
(
principal
attrs
)
;
}
return
principal
;
}
aPrincipal
=
useOAForPrincipal
(
aPrincipal
)
;
aStoragePrincipal
=
useOAForPrincipal
(
aStoragePrincipal
)
;
aTriggeringPrincipal
=
useOAForPrincipal
(
aTriggeringPrincipal
)
;
if
(
!
w
|
|
where
=
=
"
window
"
)
{
let
features
=
"
chrome
dialog
=
no
all
"
;
if
(
aIsPrivate
)
{
features
+
=
"
private
"
;
aReferrerInfo
=
new
ReferrerInfo
(
aReferrerInfo
.
referrerPolicy
false
aReferrerInfo
.
originalReferrer
)
;
}
else
if
(
aForceNonPrivate
)
{
features
+
=
"
non
-
private
"
;
}
var
sa
=
Cc
[
"
mozilla
.
org
/
array
;
1
"
]
.
createInstance
(
Ci
.
nsIMutableArray
)
;
var
wuri
=
Cc
[
"
mozilla
.
org
/
supports
-
string
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsString
)
;
wuri
.
data
=
url
;
let
extraOptions
=
Cc
[
"
mozilla
.
org
/
hash
-
property
-
bag
;
1
"
]
.
createInstance
(
Ci
.
nsIWritablePropertyBag2
)
;
if
(
params
.
hasValidUserGestureActivation
!
=
=
undefined
)
{
extraOptions
.
setPropertyAsBool
(
"
hasValidUserGestureActivation
"
params
.
hasValidUserGestureActivation
)
;
}
if
(
params
.
fromExternal
!
=
=
undefined
)
{
extraOptions
.
setPropertyAsBool
(
"
fromExternal
"
params
.
fromExternal
)
;
}
if
(
aGlobalHistoryOptions
?
.
triggeringSponsoredURL
)
{
extraOptions
.
setPropertyAsACString
(
"
triggeringSponsoredURL
"
aGlobalHistoryOptions
.
triggeringSponsoredURL
)
;
if
(
aGlobalHistoryOptions
.
triggeringSponsoredURLVisitTimeMS
)
{
extraOptions
.
setPropertyAsUint64
(
"
triggeringSponsoredURLVisitTimeMS
"
aGlobalHistoryOptions
.
triggeringSponsoredURLVisitTimeMS
)
;
}
}
var
allowThirdPartyFixupSupports
=
Cc
[
"
mozilla
.
org
/
supports
-
PRBool
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsPRBool
)
;
allowThirdPartyFixupSupports
.
data
=
aAllowThirdPartyFixup
;
var
userContextIdSupports
=
Cc
[
"
mozilla
.
org
/
supports
-
PRUint32
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsPRUint32
)
;
userContextIdSupports
.
data
=
aUserContextId
;
sa
.
appendElement
(
wuri
)
;
sa
.
appendElement
(
extraOptions
)
;
sa
.
appendElement
(
aReferrerInfo
)
;
sa
.
appendElement
(
aPostData
)
;
sa
.
appendElement
(
allowThirdPartyFixupSupports
)
;
sa
.
appendElement
(
userContextIdSupports
)
;
sa
.
appendElement
(
aPrincipal
)
;
sa
.
appendElement
(
aStoragePrincipal
)
;
sa
.
appendElement
(
aTriggeringPrincipal
)
;
sa
.
appendElement
(
null
)
;
sa
.
appendElement
(
aCsp
)
;
const
sourceWindow
=
w
|
|
window
;
let
win
;
function
waitForWindowStartup
(
)
{
return
new
Promise
(
resolve
=
>
{
const
delayedStartupObserver
=
aSubject
=
>
{
if
(
aSubject
=
=
win
)
{
Services
.
obs
.
removeObserver
(
delayedStartupObserver
"
browser
-
delayed
-
startup
-
finished
"
)
;
resolve
(
)
;
}
}
;
Services
.
obs
.
addObserver
(
delayedStartupObserver
"
browser
-
delayed
-
startup
-
finished
"
)
;
}
)
;
}
if
(
params
.
frameID
!
=
undefined
&
&
sourceWindow
)
{
const
sourceTabBrowser
=
sourceWindow
.
gBrowser
.
selectedBrowser
;
waitForWindowStartup
(
)
.
then
(
(
)
=
>
{
Services
.
obs
.
notifyObservers
(
{
wrappedJSObject
:
{
url
createdTabBrowser
:
win
.
gBrowser
.
selectedBrowser
sourceTabBrowser
sourceFrameID
:
params
.
frameID
}
}
"
webNavigation
-
createdNavigationTarget
"
)
;
}
)
;
}
if
(
aResolveOnContentBrowserReady
)
{
waitForWindowStartup
(
)
.
then
(
(
)
=
>
aResolveOnContentBrowserReady
(
win
.
gBrowser
.
selectedBrowser
)
)
;
}
win
=
Services
.
ww
.
openWindow
(
sourceWindow
AppConstants
.
BROWSER_CHROME_URL
null
features
sa
)
;
return
;
}
w
.
focus
(
)
;
let
targetBrowser
;
let
loadInBackground
;
let
uriObj
;
if
(
where
=
=
"
current
"
)
{
targetBrowser
=
params
.
targetBrowser
|
|
w
.
gBrowser
.
selectedBrowser
;
loadInBackground
=
false
;
try
{
uriObj
=
Services
.
io
.
newURI
(
url
)
;
}
catch
(
e
)
{
}
let
tab
=
w
.
gBrowser
.
getTabForBrowser
(
targetBrowser
)
;
if
(
tab
=
=
w
.
FirefoxViewHandler
.
tab
)
{
where
=
"
tab
"
;
targetBrowser
=
null
;
}
else
if
(
!
aAllowPinnedTabHostChange
&
&
tab
.
pinned
&
&
url
!
=
"
about
:
crashcontent
"
)
{
try
{
if
(
!
uriObj
|
|
(
!
uriObj
.
schemeIs
(
"
javascript
"
)
&
&
targetBrowser
.
currentURI
.
host
!
=
uriObj
.
host
)
)
{
where
=
"
tab
"
;
targetBrowser
=
null
;
}
}
catch
(
err
)
{
where
=
"
tab
"
;
targetBrowser
=
null
;
}
}
}
else
{
loadInBackground
=
aInBackground
;
if
(
loadInBackground
=
=
null
)
{
loadInBackground
=
aFromChrome
?
false
:
Services
.
prefs
.
getBoolPref
(
"
browser
.
tabs
.
loadInBackground
"
)
;
}
}
let
focusUrlBar
=
false
;
switch
(
where
)
{
case
"
current
"
:
let
flags
=
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_NONE
;
if
(
aAllowThirdPartyFixup
)
{
flags
|
=
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP
;
flags
|
=
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_FIXUP_SCHEME_TYPOS
;
}
if
(
!
aAllowInheritPrincipal
)
{
flags
|
=
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_DISALLOW_INHERIT_PRINCIPAL
;
}
if
(
aAllowPopups
)
{
flags
|
=
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_ALLOW_POPUPS
;
}
if
(
aIndicateErrorPageLoad
)
{
flags
|
=
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_ERROR_LOAD_CHANGES_RV
;
}
if
(
aForceAllowDataURI
)
{
flags
|
=
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_FORCE_ALLOW_DATA_URI
;
}
if
(
params
.
fromExternal
)
{
flags
|
=
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_FROM_EXTERNAL
;
}
let
{
URI_INHERITS_SECURITY_CONTEXT
}
=
Ci
.
nsIProtocolHandler
;
if
(
aForceAboutBlankViewerInCurrent
&
&
(
!
uriObj
|
|
doGetProtocolFlags
(
uriObj
)
&
URI_INHERITS_SECURITY_CONTEXT
)
)
{
targetBrowser
.
createAboutBlankContentViewer
(
aPrincipal
aStoragePrincipal
)
;
}
targetBrowser
.
loadURI
(
url
{
triggeringPrincipal
:
aTriggeringPrincipal
csp
:
aCsp
flags
referrerInfo
:
aReferrerInfo
postData
:
aPostData
userContextId
:
aUserContextId
hasValidUserGestureActivation
:
params
.
hasValidUserGestureActivation
globalHistoryOptions
:
aGlobalHistoryOptions
}
)
;
if
(
aResolveOnContentBrowserReady
)
{
aResolveOnContentBrowserReady
(
targetBrowser
)
;
}
focusUrlBar
=
w
.
document
.
activeElement
=
=
w
.
gURLBar
.
inputField
&
&
w
.
isBlankPageURL
(
url
)
;
break
;
case
"
tabshifted
"
:
loadInBackground
=
!
loadInBackground
;
case
"
tab
"
:
focusUrlBar
=
!
loadInBackground
&
&
w
.
isBlankPageURL
(
url
)
&
&
!
AboutNewTab
.
willNotifyUser
;
let
tabUsedForLoad
=
w
.
gBrowser
.
loadOneTab
(
url
{
referrerInfo
:
aReferrerInfo
charset
:
aCharset
postData
:
aPostData
inBackground
:
loadInBackground
allowThirdPartyFixup
:
aAllowThirdPartyFixup
relatedToCurrent
:
aRelatedToCurrent
skipAnimation
:
aSkipTabAnimation
userContextId
:
aUserContextId
originPrincipal
:
aPrincipal
originStoragePrincipal
:
aStoragePrincipal
triggeringPrincipal
:
aTriggeringPrincipal
allowInheritPrincipal
:
aAllowInheritPrincipal
csp
:
aCsp
focusUrlBar
openerBrowser
:
params
.
openerBrowser
fromExternal
:
params
.
fromExternal
globalHistoryOptions
:
aGlobalHistoryOptions
}
)
;
targetBrowser
=
tabUsedForLoad
.
linkedBrowser
;
if
(
aResolveOnNewTabCreated
)
{
aResolveOnNewTabCreated
(
targetBrowser
)
;
}
if
(
aResolveOnContentBrowserReady
)
{
aResolveOnContentBrowserReady
(
targetBrowser
)
;
}
if
(
params
.
frameID
!
=
undefined
&
&
w
)
{
Services
.
obs
.
notifyObservers
(
{
wrappedJSObject
:
{
url
createdTabBrowser
:
targetBrowser
sourceTabBrowser
:
w
.
gBrowser
.
selectedBrowser
sourceFrameID
:
params
.
frameID
}
}
"
webNavigation
-
createdNavigationTarget
"
)
;
}
break
;
}
if
(
!
params
.
avoidBrowserFocus
&
&
!
focusUrlBar
&
&
targetBrowser
=
=
w
.
gBrowser
.
selectedBrowser
)
{
targetBrowser
.
focus
(
)
;
}
}
function
checkForMiddleClick
(
node
event
)
{
if
(
node
.
getAttribute
(
"
disabled
"
)
=
=
"
true
"
)
{
return
;
}
if
(
event
.
target
.
tagName
=
=
"
menuitem
"
)
{
return
;
}
if
(
event
.
button
=
=
1
)
{
let
cmdEvent
=
document
.
createEvent
(
"
xulcommandevent
"
)
;
cmdEvent
.
initCommandEvent
(
"
command
"
true
true
window
0
event
.
ctrlKey
event
.
altKey
event
.
shiftKey
event
.
metaKey
0
event
event
.
mozInputSource
)
;
node
.
dispatchEvent
(
cmdEvent
)
;
event
.
stopPropagation
(
)
;
event
.
preventDefault
(
)
;
closeMenus
(
event
.
target
)
;
}
}
function
createUserContextMenu
(
event
{
isContextMenu
=
false
excludeUserContextId
=
0
showDefaultTab
=
false
useAccessKeys
=
true
}
=
{
}
)
{
while
(
event
.
target
.
hasChildNodes
(
)
)
{
event
.
target
.
firstChild
.
remove
(
)
;
}
let
bundle
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
browser
/
locale
/
browser
.
properties
"
)
;
let
docfrag
=
document
.
createDocumentFragment
(
)
;
if
(
excludeUserContextId
|
|
showDefaultTab
)
{
let
menuitem
=
document
.
createXULElement
(
"
menuitem
"
)
;
menuitem
.
setAttribute
(
"
data
-
usercontextid
"
"
0
"
)
;
menuitem
.
setAttribute
(
"
label
"
bundle
.
GetStringFromName
(
"
userContextNone
.
label
"
)
)
;
menuitem
.
setAttribute
(
"
accesskey
"
bundle
.
GetStringFromName
(
"
userContextNone
.
accesskey
"
)
)
;
if
(
!
isContextMenu
)
{
menuitem
.
setAttribute
(
"
command
"
"
Browser
:
NewUserContextTab
"
)
;
}
docfrag
.
appendChild
(
menuitem
)
;
let
menuseparator
=
document
.
createXULElement
(
"
menuseparator
"
)
;
docfrag
.
appendChild
(
menuseparator
)
;
}
ContextualIdentityService
.
getPublicIdentities
(
)
.
forEach
(
identity
=
>
{
if
(
identity
.
userContextId
=
=
excludeUserContextId
)
{
return
;
}
let
menuitem
=
document
.
createXULElement
(
"
menuitem
"
)
;
menuitem
.
setAttribute
(
"
data
-
usercontextid
"
identity
.
userContextId
)
;
menuitem
.
setAttribute
(
"
label
"
ContextualIdentityService
.
getUserContextLabel
(
identity
.
userContextId
)
)
;
if
(
identity
.
accessKey
&
&
useAccessKeys
)
{
menuitem
.
setAttribute
(
"
accesskey
"
bundle
.
GetStringFromName
(
identity
.
accessKey
)
)
;
}
menuitem
.
classList
.
add
(
"
menuitem
-
iconic
"
)
;
menuitem
.
classList
.
add
(
"
identity
-
color
-
"
+
identity
.
color
)
;
if
(
!
isContextMenu
)
{
menuitem
.
setAttribute
(
"
command
"
"
Browser
:
NewUserContextTab
"
)
;
}
menuitem
.
classList
.
add
(
"
identity
-
icon
-
"
+
identity
.
icon
)
;
docfrag
.
appendChild
(
menuitem
)
;
}
)
;
if
(
!
isContextMenu
)
{
docfrag
.
appendChild
(
document
.
createXULElement
(
"
menuseparator
"
)
)
;
let
menuitem
=
document
.
createXULElement
(
"
menuitem
"
)
;
menuitem
.
setAttribute
(
"
label
"
bundle
.
GetStringFromName
(
"
userContext
.
aboutPage
.
label
"
)
)
;
if
(
useAccessKeys
)
{
menuitem
.
setAttribute
(
"
accesskey
"
bundle
.
GetStringFromName
(
"
userContext
.
aboutPage
.
accesskey
"
)
)
;
}
menuitem
.
setAttribute
(
"
command
"
"
Browser
:
OpenAboutContainers
"
)
;
docfrag
.
appendChild
(
menuitem
)
;
}
event
.
target
.
appendChild
(
docfrag
)
;
return
true
;
}
function
closeMenus
(
node
)
{
if
(
"
tagName
"
in
node
)
{
if
(
node
.
namespaceURI
=
=
"
http
:
/
/
www
.
mozilla
.
org
/
keymaster
/
gatekeeper
/
there
.
is
.
only
.
xul
"
&
&
(
node
.
tagName
=
=
"
menupopup
"
|
|
node
.
tagName
=
=
"
popup
"
)
)
{
node
.
hidePopup
(
)
;
}
closeMenus
(
node
.
parentNode
)
;
}
}
function
eventMatchesKey
(
aEvent
aKey
)
{
let
keyPressed
=
aKey
.
getAttribute
(
"
key
"
)
.
toLowerCase
(
)
;
let
keyModifiers
=
aKey
.
getAttribute
(
"
modifiers
"
)
;
let
modifiers
=
[
"
Alt
"
"
Control
"
"
Meta
"
"
Shift
"
]
;
if
(
aEvent
.
key
!
=
keyPressed
)
{
return
false
;
}
let
eventModifiers
=
modifiers
.
filter
(
modifier
=
>
aEvent
.
getModifierState
(
modifier
)
)
;
if
(
eventModifiers
.
length
&
&
!
keyModifiers
.
length
)
{
return
false
;
}
if
(
keyModifiers
)
{
keyModifiers
=
keyModifiers
.
split
(
/
[
\
s
]
+
/
)
;
keyModifiers
.
forEach
(
function
(
modifier
index
)
{
if
(
modifier
=
=
"
accel
"
)
{
keyModifiers
[
index
]
=
AppConstants
.
platform
=
=
"
macosx
"
?
"
Meta
"
:
"
Control
"
;
}
else
{
keyModifiers
[
index
]
=
modifier
[
0
]
.
toUpperCase
(
)
+
modifier
.
slice
(
1
)
;
}
}
)
;
return
modifiers
.
every
(
modifier
=
>
keyModifiers
.
includes
(
modifier
)
=
=
aEvent
.
getModifierState
(
modifier
)
)
;
}
return
true
;
}
function
gatherTextUnder
(
root
)
{
var
text
=
"
"
;
var
node
=
root
.
firstChild
;
var
depth
=
1
;
while
(
node
&
&
depth
>
0
)
{
if
(
node
.
nodeType
=
=
Node
.
TEXT_NODE
)
{
text
+
=
"
"
+
node
.
data
;
}
else
if
(
HTMLImageElement
.
isInstance
(
node
)
)
{
var
altText
=
node
.
getAttribute
(
"
alt
"
)
;
if
(
altText
&
&
altText
!
=
"
"
)
{
text
+
=
"
"
+
altText
;
}
}
if
(
node
.
hasChildNodes
(
)
)
{
node
=
node
.
firstChild
;
depth
+
+
;
}
else
{
while
(
depth
>
0
&
&
!
node
.
nextSibling
)
{
node
=
node
.
parentNode
;
depth
-
-
;
}
if
(
node
.
nextSibling
)
{
node
=
node
.
nextSibling
;
}
}
}
text
=
text
.
trim
(
)
;
text
=
text
.
replace
(
/
\
s
+
/
g
"
"
)
;
return
text
;
}
function
getShellService
(
)
{
return
ShellService
;
}
function
isBidiEnabled
(
)
{
if
(
Services
.
prefs
.
getBoolPref
(
"
bidi
.
browser
.
ui
"
false
)
)
{
return
true
;
}
const
isRTL
=
Services
.
locale
.
isAppLocaleRTL
;
if
(
isRTL
)
{
Services
.
prefs
.
setBoolPref
(
"
bidi
.
browser
.
ui
"
true
)
;
}
return
isRTL
;
}
function
openAboutDialog
(
)
{
for
(
let
win
of
Services
.
wm
.
getEnumerator
(
"
Browser
:
About
"
)
)
{
if
(
win
.
closed
)
{
continue
;
}
win
.
focus
(
)
;
return
;
}
var
features
=
"
chrome
"
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
features
+
=
"
centerscreen
dependent
"
;
}
else
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
features
+
=
"
resizable
=
no
minimizable
=
no
"
;
}
else
{
features
+
=
"
centerscreen
dependent
dialog
=
no
"
;
}
window
.
openDialog
(
"
chrome
:
/
/
browser
/
content
/
aboutDialog
.
xhtml
"
"
"
features
)
;
}
async
function
openPreferences
(
paneID
extraArgs
)
{
function
internalPrefCategoryNameToFriendlyName
(
aName
)
{
return
(
aName
|
|
"
"
)
.
replace
(
/
^
pane
.
/
function
(
toReplace
)
{
return
toReplace
[
4
]
.
toLowerCase
(
)
;
}
)
;
}
let
win
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
let
friendlyCategoryName
=
internalPrefCategoryNameToFriendlyName
(
paneID
)
;
let
params
;
if
(
extraArgs
&
&
extraArgs
.
urlParams
)
{
params
=
new
URLSearchParams
(
)
;
let
urlParams
=
extraArgs
.
urlParams
;
for
(
let
name
in
urlParams
)
{
if
(
urlParams
[
name
]
!
=
=
undefined
)
{
params
.
set
(
name
urlParams
[
name
]
)
;
}
}
}
let
preferencesURL
=
"
about
:
preferences
"
+
(
params
?
"
?
"
+
params
:
"
"
)
+
(
friendlyCategoryName
?
"
#
"
+
friendlyCategoryName
:
"
"
)
;
let
newLoad
=
true
;
let
browser
=
null
;
if
(
!
win
)
{
let
windowArguments
=
Cc
[
"
mozilla
.
org
/
array
;
1
"
]
.
createInstance
(
Ci
.
nsIMutableArray
)
;
let
supportsStringPrefURL
=
Cc
[
"
mozilla
.
org
/
supports
-
string
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsString
)
;
supportsStringPrefURL
.
data
=
preferencesURL
;
windowArguments
.
appendElement
(
supportsStringPrefURL
)
;
win
=
Services
.
ww
.
openWindow
(
null
AppConstants
.
BROWSER_CHROME_URL
"
_blank
"
"
chrome
dialog
=
no
all
"
windowArguments
)
;
}
else
{
let
shouldReplaceFragment
=
friendlyCategoryName
?
"
whenComparingAndReplace
"
:
"
whenComparing
"
;
newLoad
=
!
win
.
switchToTabHavingURI
(
preferencesURL
true
{
ignoreFragment
:
shouldReplaceFragment
replaceQueryString
:
true
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
}
)
;
browser
=
win
.
gBrowser
.
selectedBrowser
;
}
if
(
!
newLoad
&
&
paneID
)
{
if
(
browser
.
contentDocument
?
.
readyState
!
=
"
complete
"
)
{
await
new
Promise
(
resolve
=
>
{
browser
.
addEventListener
(
"
load
"
resolve
{
capture
:
true
once
:
true
}
)
;
}
)
;
}
browser
.
contentWindow
.
gotoPref
(
paneID
)
;
}
}
function
openTroubleshootingPage
(
)
{
openTrustedLinkIn
(
"
about
:
support
"
"
tab
"
)
;
}
function
openFeedbackPage
(
)
{
var
url
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
feedback
.
baseURL
"
)
;
openTrustedLinkIn
(
url
"
tab
"
)
;
}
function
buildHelpMenu
(
)
{
document
.
getElementById
(
"
feedbackPage
"
)
.
disabled
=
!
Services
.
policies
.
isAllowed
(
"
feedbackCommands
"
)
;
document
.
getElementById
(
"
helpSafeMode
"
)
.
disabled
=
!
Services
.
policies
.
isAllowed
(
"
safeMode
"
)
;
let
supportMenu
=
Services
.
policies
.
getSupportMenu
(
)
;
if
(
supportMenu
)
{
let
menuitem
=
document
.
getElementById
(
"
helpPolicySupport
"
)
;
menuitem
.
hidden
=
false
;
menuitem
.
setAttribute
(
"
label
"
supportMenu
.
Title
)
;
if
(
"
AccessKey
"
in
supportMenu
)
{
menuitem
.
setAttribute
(
"
accesskey
"
supportMenu
.
AccessKey
)
;
}
document
.
getElementById
(
"
helpPolicySeparator
"
)
.
hidden
=
false
;
}
if
(
typeof
gSafeBrowsing
!
=
"
undefined
"
)
{
gSafeBrowsing
.
setReportPhishingMenu
(
)
;
}
let
reportSiteIssueEnabled
=
Services
.
prefs
.
getBoolPref
(
"
extensions
.
webcompat
-
reporter
.
enabled
"
false
)
;
let
reportSiteIssue
=
document
.
getElementById
(
"
help_reportSiteIssue
"
)
;
reportSiteIssue
.
hidden
=
!
reportSiteIssueEnabled
;
if
(
reportSiteIssueEnabled
)
{
let
uri
=
gBrowser
.
currentURI
;
let
isReportablePage
=
uri
&
&
(
uri
.
schemeIs
(
"
http
"
)
|
|
uri
.
schemeIs
(
"
https
"
)
)
;
reportSiteIssue
.
disabled
=
!
isReportablePage
;
}
}
function
isElementVisible
(
aElement
)
{
if
(
!
aElement
)
{
return
false
;
}
var
rect
=
aElement
.
getBoundingClientRect
(
)
;
return
rect
.
height
>
0
&
&
rect
.
width
>
0
;
}
function
makeURLAbsolute
(
aBase
aUrl
)
{
return
makeURI
(
aUrl
null
makeURI
(
aBase
)
)
.
spec
;
}
function
getHelpLinkURL
(
aHelpTopic
)
{
var
url
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
;
return
url
+
aHelpTopic
;
}
function
openHelpLink
(
aHelpTopic
aCalledFromModal
aWhere
)
{
var
url
=
getHelpLinkURL
(
aHelpTopic
)
;
var
where
=
aWhere
;
if
(
!
aWhere
)
{
where
=
aCalledFromModal
?
"
window
"
:
"
tab
"
;
}
openTrustedLinkIn
(
url
where
)
;
}
function
openPrefsHelp
(
aEvent
)
{
let
helpTopic
=
aEvent
.
target
.
getAttribute
(
"
helpTopic
"
)
;
openHelpLink
(
helpTopic
)
;
}
