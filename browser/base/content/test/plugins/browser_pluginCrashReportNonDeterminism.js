const
{
PromiseUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
)
;
const
CRASH_URL
=
"
http
:
/
/
example
.
com
/
browser
/
browser
/
base
/
content
/
test
/
plugins
/
plugin_crashCommentAndURL
.
html
"
;
const
CRASHED_MESSAGE
=
"
BrowserPlugins
:
NPAPIPluginProcessCrashed
"
;
function
preparePlugin
(
browser
pluginFallbackState
)
{
return
ContentTask
.
spawn
(
browser
pluginFallbackState
async
function
(
contentPluginFallbackState
)
{
let
plugin
=
content
.
document
.
getElementById
(
"
plugin
"
)
;
plugin
.
QueryInterface
(
Ci
.
nsIObjectLoadingContent
)
;
let
statusDiv
;
await
ContentTaskUtils
.
waitForCondition
(
(
)
=
>
{
statusDiv
=
plugin
.
openOrClosedShadowRoot
.
getElementById
(
"
submitStatus
"
)
;
return
statusDiv
&
&
statusDiv
.
getAttribute
(
"
status
"
)
=
=
"
please
"
;
}
"
Timed
out
waiting
for
plugin
to
be
in
crash
report
state
"
)
;
statusDiv
.
removeAttribute
(
"
status
"
)
;
Object
.
defineProperty
(
plugin
"
pluginFallbackType
"
{
get
(
)
{
return
contentPluginFallbackState
;
}
}
)
;
return
plugin
.
runID
;
}
)
.
then
(
(
runID
)
=
>
{
browser
.
messageManager
.
sendAsyncMessage
(
"
BrowserPlugins
:
Test
:
ClearCrashData
"
)
;
return
runID
;
}
)
;
}
setTestPluginEnabledState
(
Ci
.
nsIPluginTag
.
STATE_ENABLED
)
;
let
crashDeferred
=
null
;
let
crashObserver
=
(
subject
topic
data
)
=
>
{
if
(
topic
!
=
"
plugin
-
crashed
"
)
{
return
;
}
let
propBag
=
subject
.
QueryInterface
(
Ci
.
nsIPropertyBag2
)
;
let
minidumpID
=
propBag
.
getPropertyAsAString
(
"
pluginDumpID
"
)
;
Services
.
crashmanager
.
ensureCrashIsPresent
(
minidumpID
)
.
then
(
(
)
=
>
{
let
minidumpDir
=
Services
.
dirsvc
.
get
(
"
ProfD
"
Ci
.
nsIFile
)
;
minidumpDir
.
append
(
"
minidumps
"
)
;
let
pluginDumpFile
=
minidumpDir
.
clone
(
)
;
pluginDumpFile
.
append
(
minidumpID
+
"
.
dmp
"
)
;
let
extraFile
=
minidumpDir
.
clone
(
)
;
extraFile
.
append
(
minidumpID
+
"
.
extra
"
)
;
ok
(
pluginDumpFile
.
exists
(
)
"
Found
minidump
"
)
;
ok
(
extraFile
.
exists
(
)
"
Found
extra
file
"
)
;
pluginDumpFile
.
remove
(
false
)
;
extraFile
.
remove
(
false
)
;
crashDeferred
.
resolve
(
)
;
}
)
;
}
;
Services
.
obs
.
addObserver
(
crashObserver
"
plugin
-
crashed
"
)
;
Services
.
prefs
.
setBoolPref
(
"
plugins
.
testmode
"
true
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
"
plugins
.
testmode
"
)
;
Services
.
obs
.
removeObserver
(
crashObserver
"
plugin
-
crashed
"
)
;
}
)
;
add_task
(
async
function
testChromeHearsPluginCrashFirst
(
)
{
crashDeferred
=
PromiseUtils
.
defer
(
)
;
let
win
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
{
remote
:
true
}
)
;
let
browser
=
win
.
gBrowser
.
selectedBrowser
;
BrowserTestUtils
.
loadURI
(
browser
CRASH_URL
)
;
await
BrowserTestUtils
.
browserLoaded
(
browser
)
;
let
runID
=
await
preparePlugin
(
browser
Ci
.
nsIObjectLoadingContent
.
PLUGIN_ACTIVE
)
;
let
mm
=
browser
.
messageManager
;
mm
.
sendAsyncMessage
(
CRASHED_MESSAGE
{
pluginName
:
"
"
runID
state
:
"
please
"
}
)
;
await
ContentTask
.
spawn
(
browser
null
async
function
(
)
{
let
plugin
=
content
.
document
.
getElementById
(
"
plugin
"
)
;
plugin
.
QueryInterface
(
Ci
.
nsIObjectLoadingContent
)
;
let
statusDiv
=
plugin
.
openOrClosedShadowRoot
.
getElementById
(
"
submitStatus
"
)
;
if
(
statusDiv
.
getAttribute
(
"
status
"
)
=
=
"
please
"
)
{
Assert
.
ok
(
false
"
Did
not
expect
plugin
to
be
in
crash
report
mode
yet
.
"
)
;
return
;
}
Object
.
defineProperty
(
plugin
"
pluginFallbackType
"
{
get
(
)
{
return
Ci
.
nsIObjectLoadingContent
.
PLUGIN_CRASHED
;
}
}
)
;
let
event
=
new
content
.
PluginCrashedEvent
(
"
PluginCrashed
"
{
pluginName
:
"
"
pluginDumpID
:
"
"
browserDumpID
:
"
"
submittedCrashReport
:
false
bubbles
:
true
cancelable
:
true
}
)
;
plugin
.
dispatchEvent
(
event
)
;
Assert
.
equal
(
statusDiv
.
getAttribute
(
"
status
"
)
"
please
"
"
Should
have
been
showing
crash
report
UI
"
)
;
}
)
;
await
BrowserTestUtils
.
closeWindow
(
win
)
;
await
crashDeferred
.
promise
;
}
)
;
add_task
(
async
function
testContentHearsCrashFirst
(
)
{
crashDeferred
=
PromiseUtils
.
defer
(
)
;
let
win
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
{
remote
:
true
}
)
;
let
browser
=
win
.
gBrowser
.
selectedBrowser
;
BrowserTestUtils
.
loadURI
(
browser
CRASH_URL
)
;
await
BrowserTestUtils
.
browserLoaded
(
browser
)
;
let
runID
=
await
preparePlugin
(
browser
Ci
.
nsIObjectLoadingContent
.
PLUGIN_CRASHED
)
;
await
ContentTask
.
spawn
(
browser
null
async
function
(
)
{
let
plugin
=
content
.
document
.
getElementById
(
"
plugin
"
)
;
plugin
.
QueryInterface
(
Ci
.
nsIObjectLoadingContent
)
;
let
statusDiv
=
plugin
.
openOrClosedShadowRoot
.
getElementById
(
"
submitStatus
"
)
;
if
(
statusDiv
.
getAttribute
(
"
status
"
)
=
=
"
please
"
)
{
Assert
.
ok
(
false
"
Did
not
expect
plugin
to
be
in
crash
report
mode
yet
.
"
)
;
}
let
event
=
new
content
.
PluginCrashedEvent
(
"
PluginCrashed
"
{
pluginName
:
"
"
pluginDumpID
:
"
"
browserDumpID
:
"
"
submittedCrashReport
:
false
bubbles
:
true
cancelable
:
true
}
)
;
plugin
.
dispatchEvent
(
event
)
;
Assert
.
notEqual
(
statusDiv
.
getAttribute
(
"
status
"
)
"
please
"
"
Should
not
yet
be
showing
crash
report
UI
"
)
;
}
)
;
let
mm
=
browser
.
messageManager
;
mm
.
sendAsyncMessage
(
CRASHED_MESSAGE
{
pluginName
:
"
"
runID
state
:
"
please
"
}
)
;
await
ContentTask
.
spawn
(
browser
null
async
function
(
)
{
let
plugin
=
content
.
document
.
getElementById
(
"
plugin
"
)
;
plugin
.
QueryInterface
(
Ci
.
nsIObjectLoadingContent
)
;
let
statusDiv
=
plugin
.
openOrClosedShadowRoot
.
getElementById
(
"
submitStatus
"
)
;
Assert
.
equal
(
statusDiv
.
getAttribute
(
"
status
"
)
"
please
"
"
Should
have
been
showing
crash
report
UI
"
)
;
}
)
;
await
BrowserTestUtils
.
closeWindow
(
win
)
;
await
crashDeferred
.
promise
;
}
)
;
