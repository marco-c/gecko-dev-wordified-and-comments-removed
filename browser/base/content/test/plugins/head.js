var
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PlacesUtils
"
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PromiseUtils
"
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetters
(
this
{
uuidGen
:
[
"
mozilla
.
org
/
uuid
-
generator
;
1
"
"
nsIUUIDGenerator
"
]
}
)
;
function
waitForMs
(
aMs
)
{
return
new
Promise
(
resolve
=
>
{
setTimeout
(
done
aMs
)
;
function
done
(
)
{
resolve
(
true
)
;
}
}
)
;
}
function
promiseTabLoadEvent
(
tab
url
)
{
info
(
"
Wait
tab
event
:
load
"
)
;
function
handle
(
loadedUrl
)
{
if
(
loadedUrl
=
=
=
"
about
:
blank
"
|
|
(
url
&
&
loadedUrl
!
=
=
url
)
)
{
info
(
Skipping
spurious
load
event
for
{
loadedUrl
}
)
;
return
false
;
}
info
(
"
Tab
event
received
:
load
"
)
;
return
true
;
}
let
loaded
=
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
false
handle
)
;
if
(
url
)
{
BrowserTestUtils
.
loadURI
(
tab
.
linkedBrowser
url
)
;
}
return
loaded
;
}
function
waitForCondition
(
condition
nextTest
errorMsg
aTries
aWait
)
{
let
tries
=
0
;
let
maxTries
=
aTries
|
|
100
;
let
maxWait
=
aWait
|
|
100
;
let
interval
=
setInterval
(
function
(
)
{
if
(
tries
>
=
maxTries
)
{
ok
(
false
errorMsg
)
;
moveOn
(
)
;
}
let
conditionPassed
;
try
{
conditionPassed
=
condition
(
)
;
}
catch
(
e
)
{
ok
(
false
e
+
"
\
n
"
+
e
.
stack
)
;
conditionPassed
=
false
;
}
if
(
conditionPassed
)
{
moveOn
(
)
;
}
tries
+
+
;
}
maxWait
)
;
let
moveOn
=
function
(
)
{
clearInterval
(
interval
)
;
nextTest
(
)
;
}
;
}
function
promiseForCondition
(
aConditionFn
aMessage
aTries
aWait
)
{
return
new
Promise
(
resolve
=
>
{
waitForCondition
(
aConditionFn
resolve
aMessage
|
|
"
Condition
didn
'
t
pass
.
"
aTries
aWait
)
;
}
)
;
}
function
promiseForPluginInfo
(
aId
aBrowser
)
{
let
browser
=
aBrowser
|
|
gTestBrowser
;
return
SpecialPowers
.
spawn
(
browser
[
aId
]
async
function
(
contentId
)
{
let
plugin
=
content
.
document
.
getElementById
(
contentId
)
;
if
(
!
(
plugin
instanceof
Ci
.
nsIObjectLoadingContent
)
)
{
throw
new
Error
(
"
no
plugin
found
"
)
;
}
return
{
pluginFallbackType
:
plugin
.
pluginFallbackType
activated
:
plugin
.
activated
hasRunningPlugin
:
plugin
.
hasRunningPlugin
displayedType
:
plugin
.
displayedType
}
;
}
)
;
}
function
promiseWaitForFocus
(
aWindow
)
{
return
new
Promise
(
resolve
=
>
{
waitForFocus
(
resolve
aWindow
)
;
}
)
;
}
function
waitForNotificationBar
(
notificationID
browser
callback
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
notification
;
let
notificationBox
=
gBrowser
.
getNotificationBox
(
browser
)
;
waitForCondition
(
(
)
=
>
(
notification
=
notificationBox
.
getNotificationWithValue
(
notificationID
)
)
(
)
=
>
{
ok
(
notification
Successfully
got
the
{
notificationID
}
notification
bar
)
;
if
(
callback
)
{
callback
(
notification
)
;
}
resolve
(
notification
)
;
}
Waited
too
long
for
the
{
notificationID
}
notification
bar
)
;
}
)
;
}
function
promiseForNotificationBar
(
notificationID
browser
)
{
return
new
Promise
(
resolve
=
>
{
waitForNotificationBar
(
notificationID
browser
resolve
)
;
}
)
;
}
function
waitForNotificationShown
(
notification
callback
)
{
if
(
PopupNotifications
.
panel
.
state
=
=
"
open
"
)
{
executeSoon
(
callback
)
;
return
;
}
PopupNotifications
.
panel
.
addEventListener
(
"
popupshown
"
function
(
e
)
{
callback
(
)
;
}
{
once
:
true
}
)
;
notification
.
reshow
(
)
;
}
function
promiseForNotificationShown
(
notification
)
{
return
new
Promise
(
resolve
=
>
{
waitForNotificationShown
(
notification
resolve
)
;
}
)
;
}
