var
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PlacesUtils
"
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PromiseUtils
"
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetters
(
this
{
uuidGen
:
[
"
mozilla
.
org
/
uuid
-
generator
;
1
"
"
nsIUUIDGenerator
"
]
}
)
;
function
waitForMs
(
aMs
)
{
return
new
Promise
(
resolve
=
>
{
setTimeout
(
done
aMs
)
;
function
done
(
)
{
resolve
(
true
)
;
}
}
)
;
}
function
promiseTabLoadEvent
(
tab
url
)
{
info
(
"
Wait
tab
event
:
load
"
)
;
function
handle
(
loadedUrl
)
{
if
(
loadedUrl
=
=
=
"
about
:
blank
"
|
|
(
url
&
&
loadedUrl
!
=
=
url
)
)
{
info
(
Skipping
spurious
load
event
for
{
loadedUrl
}
)
;
return
false
;
}
info
(
"
Tab
event
received
:
load
"
)
;
return
true
;
}
let
loaded
=
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
false
handle
)
;
if
(
url
)
{
BrowserTestUtils
.
loadURI
(
tab
.
linkedBrowser
url
)
;
}
return
loaded
;
}
function
waitForCondition
(
condition
nextTest
errorMsg
aTries
aWait
)
{
let
tries
=
0
;
let
maxTries
=
aTries
|
|
100
;
let
maxWait
=
aWait
|
|
100
;
let
interval
=
setInterval
(
function
(
)
{
if
(
tries
>
=
maxTries
)
{
ok
(
false
errorMsg
)
;
moveOn
(
)
;
}
let
conditionPassed
;
try
{
conditionPassed
=
condition
(
)
;
}
catch
(
e
)
{
ok
(
false
e
+
"
\
n
"
+
e
.
stack
)
;
conditionPassed
=
false
;
}
if
(
conditionPassed
)
{
moveOn
(
)
;
}
tries
+
+
;
}
maxWait
)
;
let
moveOn
=
function
(
)
{
clearInterval
(
interval
)
;
nextTest
(
)
;
}
;
}
function
promiseForCondition
(
aConditionFn
aMessage
aTries
aWait
)
{
return
new
Promise
(
resolve
=
>
{
waitForCondition
(
aConditionFn
resolve
aMessage
|
|
"
Condition
didn
'
t
pass
.
"
aTries
aWait
)
;
}
)
;
}
function
getTestPlugin
(
aName
)
{
let
pluginName
=
aName
|
|
"
Test
Plug
-
in
"
;
let
ph
=
Cc
[
"
mozilla
.
org
/
plugin
/
host
;
1
"
]
.
getService
(
Ci
.
nsIPluginHost
)
;
let
tags
=
ph
.
getPluginTags
(
)
;
for
(
let
i
=
0
;
i
<
tags
.
length
;
i
+
+
)
{
if
(
tags
[
i
]
.
name
=
=
pluginName
)
{
return
tags
[
i
]
;
}
}
ok
(
false
"
Unable
to
find
plugin
"
)
;
return
null
;
}
function
setTestPluginEnabledState
(
newEnabledState
pluginName
)
{
let
name
=
pluginName
|
|
"
Test
Plug
-
in
"
;
let
plugin
=
getTestPlugin
(
name
)
;
plugin
.
enabledState
=
newEnabledState
;
}
function
getTestPluginEnabledState
(
pluginName
)
{
let
name
=
pluginName
|
|
"
Test
Plug
-
in
"
;
let
plugin
=
getTestPlugin
(
name
)
;
return
plugin
.
enabledState
;
}
function
promiseForPluginInfo
(
aId
aBrowser
)
{
let
browser
=
aBrowser
|
|
gTestBrowser
;
return
SpecialPowers
.
spawn
(
browser
[
aId
]
async
function
(
contentId
)
{
let
plugin
=
content
.
document
.
getElementById
(
contentId
)
;
if
(
!
(
plugin
instanceof
Ci
.
nsIObjectLoadingContent
)
)
{
throw
new
Error
(
"
no
plugin
found
"
)
;
}
return
{
pluginFallbackType
:
plugin
.
pluginFallbackType
activated
:
plugin
.
activated
hasRunningPlugin
:
plugin
.
hasRunningPlugin
displayedType
:
plugin
.
displayedType
}
;
}
)
;
}
function
promisePlayObject
(
aId
aBrowser
)
{
let
browser
=
aBrowser
|
|
gTestBrowser
;
return
SpecialPowers
.
spawn
(
browser
[
aId
]
async
function
(
contentId
)
{
content
.
document
.
getElementById
(
contentId
)
.
playPlugin
(
)
;
}
)
;
}
function
promiseCrashObject
(
aId
aBrowser
)
{
let
browser
=
aBrowser
|
|
gTestBrowser
;
return
SpecialPowers
.
spawn
(
browser
[
aId
]
async
function
(
contentId
)
{
let
plugin
=
content
.
document
.
getElementById
(
contentId
)
;
Cu
.
waiveXrays
(
plugin
)
.
crash
(
)
;
}
)
;
}
function
promiseObjectValueResult
(
aId
aBrowser
)
{
let
browser
=
aBrowser
|
|
gTestBrowser
;
return
SpecialPowers
.
spawn
(
browser
[
aId
]
async
function
(
contentId
)
{
let
plugin
=
content
.
document
.
getElementById
(
contentId
)
;
return
Cu
.
waiveXrays
(
plugin
)
.
getObjectValue
(
)
;
}
)
;
}
function
promiseReloadPlugin
(
aId
aBrowser
)
{
let
browser
=
aBrowser
|
|
gTestBrowser
;
return
SpecialPowers
.
spawn
(
browser
[
aId
]
async
function
(
contentId
)
{
let
plugin
=
content
.
document
.
getElementById
(
contentId
)
;
plugin
.
src
=
plugin
.
src
;
}
)
;
}
function
clearAllPluginPermissions
(
)
{
for
(
let
perm
of
Services
.
perms
.
all
)
{
if
(
perm
.
type
.
startsWith
(
"
plugin
"
)
)
{
info
(
"
removing
permission
:
"
+
perm
.
principal
.
origin
+
"
"
+
perm
.
type
+
"
\
n
"
)
;
Services
.
perms
.
removePermission
(
perm
)
;
}
}
}
let
JSONBlocklistWrapper
=
{
async
loadBlocklistData
(
url
)
{
const
fullURL
=
{
url
}
-
plugins
.
json
;
let
jsonObj
;
try
{
jsonObj
=
await
(
await
fetch
(
fullURL
)
)
.
json
(
)
;
}
catch
(
ex
)
{
ok
(
false
ex
)
;
}
info
(
Loaded
{
fullURL
}
)
;
return
this
.
loadBlocklistRawData
(
{
plugins
:
jsonObj
}
)
;
}
async
loadBlocklistRawData
(
data
)
{
const
bsPass
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Blocklist
.
jsm
"
null
)
;
const
blocklistMapping
=
{
extensions
:
bsPass
.
ExtensionBlocklistRS
plugins
:
bsPass
.
PluginBlocklistRS
}
;
for
(
const
[
dataProp
blocklistObj
]
of
Object
.
entries
(
blocklistMapping
)
)
{
let
newData
=
data
[
dataProp
]
;
if
(
!
newData
)
{
continue
;
}
if
(
!
Array
.
isArray
(
newData
)
)
{
throw
new
Error
(
"
Expected
an
array
of
new
items
to
put
in
the
"
+
dataProp
+
"
blocklist
!
"
)
;
}
for
(
let
item
of
newData
)
{
if
(
!
item
.
id
)
{
item
.
id
=
uuidGen
.
generateUUID
(
)
.
number
.
slice
(
1
-
1
)
;
}
if
(
!
item
.
last_modified
)
{
item
.
last_modified
=
Date
.
now
(
)
;
}
}
await
blocklistObj
.
ensureInitialized
(
)
;
let
db
=
await
blocklistObj
.
_client
.
db
;
await
db
.
importChanges
(
{
}
42
newData
{
clear
:
true
}
)
;
await
blocklistObj
.
_onUpdate
(
)
;
}
}
}
;
async
function
asyncSetAndUpdateBlocklist
(
aURL
aBrowser
)
{
let
doTestRemote
=
aBrowser
?
aBrowser
.
isRemoteBrowser
:
false
;
let
localPromise
=
TestUtils
.
topicObserved
(
"
plugin
-
blocklist
-
updated
"
)
;
info
(
"
*
*
*
loading
blocklist
:
"
+
aURL
)
;
await
JSONBlocklistWrapper
.
loadBlocklistData
(
aURL
)
;
info
(
"
*
*
*
waiting
on
local
load
"
)
;
await
localPromise
;
if
(
doTestRemote
)
{
info
(
"
*
*
*
waiting
on
remote
load
"
)
;
await
SpecialPowers
.
spawn
(
aBrowser
[
]
(
)
=
>
{
}
)
;
}
info
(
"
*
*
*
blocklist
loaded
.
"
)
;
}
function
promisePopupNotification
(
aName
aBrowser
)
{
return
new
Promise
(
resolve
=
>
{
waitForCondition
(
(
)
=
>
PopupNotifications
.
getNotification
(
aName
aBrowser
)
(
)
=
>
{
ok
(
!
!
PopupNotifications
.
getNotification
(
aName
aBrowser
)
aName
+
"
notification
appeared
"
)
;
resolve
(
)
;
}
"
timeout
waiting
for
popup
notification
"
+
aName
)
;
}
)
;
}
function
promiseWaitForFocus
(
aWindow
)
{
return
new
Promise
(
resolve
=
>
{
waitForFocus
(
resolve
aWindow
)
;
}
)
;
}
function
waitForNotificationBar
(
notificationID
browser
callback
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
notification
;
let
notificationBox
=
gBrowser
.
getNotificationBox
(
browser
)
;
waitForCondition
(
(
)
=
>
(
notification
=
notificationBox
.
getNotificationWithValue
(
notificationID
)
)
(
)
=
>
{
ok
(
notification
Successfully
got
the
{
notificationID
}
notification
bar
)
;
if
(
callback
)
{
callback
(
notification
)
;
}
resolve
(
notification
)
;
}
Waited
too
long
for
the
{
notificationID
}
notification
bar
)
;
}
)
;
}
function
promiseForNotificationBar
(
notificationID
browser
)
{
return
new
Promise
(
resolve
=
>
{
waitForNotificationBar
(
notificationID
browser
resolve
)
;
}
)
;
}
function
waitForNotificationShown
(
notification
callback
)
{
if
(
PopupNotifications
.
panel
.
state
=
=
"
open
"
)
{
executeSoon
(
callback
)
;
return
;
}
PopupNotifications
.
panel
.
addEventListener
(
"
popupshown
"
function
(
e
)
{
callback
(
)
;
}
{
once
:
true
}
)
;
notification
.
reshow
(
)
;
}
function
promiseForNotificationShown
(
notification
)
{
return
new
Promise
(
resolve
=
>
{
waitForNotificationShown
(
notification
resolve
)
;
}
)
;
}
function
promiseUpdatePluginBindings
(
browser
)
{
return
SpecialPowers
.
spawn
(
browser
[
]
async
function
(
)
{
let
doc
=
content
.
document
;
let
elems
=
doc
.
getElementsByTagName
(
"
embed
"
)
;
if
(
!
elems
|
|
elems
.
length
<
1
)
{
elems
=
doc
.
getElementsByTagName
(
"
object
"
)
;
}
if
(
elems
&
&
elems
.
length
)
{
elems
[
0
]
.
clientTop
;
}
}
)
;
}
