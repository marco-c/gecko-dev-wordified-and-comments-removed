var
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PlacesUtils
"
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PromiseUtils
"
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
)
;
function
waitForMs
(
aMs
)
{
return
new
Promise
(
(
resolve
)
=
>
{
setTimeout
(
done
aMs
)
;
function
done
(
)
{
resolve
(
true
)
;
}
}
)
;
}
function
promiseTabLoadEvent
(
tab
url
)
{
info
(
"
Wait
tab
event
:
load
"
)
;
function
handle
(
loadedUrl
)
{
if
(
loadedUrl
=
=
=
"
about
:
blank
"
|
|
(
url
&
&
loadedUrl
!
=
=
url
)
)
{
info
(
Skipping
spurious
load
event
for
{
loadedUrl
}
)
;
return
false
;
}
info
(
"
Tab
event
received
:
load
"
)
;
return
true
;
}
let
loaded
=
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
false
handle
)
;
if
(
url
)
BrowserTestUtils
.
loadURI
(
tab
.
linkedBrowser
url
)
;
return
loaded
;
}
function
waitForCondition
(
condition
nextTest
errorMsg
aTries
aWait
)
{
let
tries
=
0
;
let
maxTries
=
aTries
|
|
100
;
let
maxWait
=
aWait
|
|
100
;
let
interval
=
setInterval
(
function
(
)
{
if
(
tries
>
=
maxTries
)
{
ok
(
false
errorMsg
)
;
moveOn
(
)
;
}
let
conditionPassed
;
try
{
conditionPassed
=
condition
(
)
;
}
catch
(
e
)
{
ok
(
false
e
+
"
\
n
"
+
e
.
stack
)
;
conditionPassed
=
false
;
}
if
(
conditionPassed
)
{
moveOn
(
)
;
}
tries
+
+
;
}
maxWait
)
;
let
moveOn
=
function
(
)
{
clearInterval
(
interval
)
;
nextTest
(
)
;
}
;
}
function
promiseForCondition
(
aConditionFn
aMessage
aTries
aWait
)
{
return
new
Promise
(
(
resolve
)
=
>
{
waitForCondition
(
aConditionFn
resolve
(
aMessage
|
|
"
Condition
didn
'
t
pass
.
"
)
aTries
aWait
)
;
}
)
;
}
function
getTestPlugin
(
aName
)
{
let
pluginName
=
aName
|
|
"
Test
Plug
-
in
"
;
let
ph
=
Cc
[
"
mozilla
.
org
/
plugin
/
host
;
1
"
]
.
getService
(
Ci
.
nsIPluginHost
)
;
let
tags
=
ph
.
getPluginTags
(
)
;
for
(
let
i
=
0
;
i
<
tags
.
length
;
i
+
+
)
{
if
(
tags
[
i
]
.
name
=
=
pluginName
)
return
tags
[
i
]
;
}
ok
(
false
"
Unable
to
find
plugin
"
)
;
return
null
;
}
function
setTestPluginEnabledState
(
newEnabledState
pluginName
)
{
let
name
=
pluginName
|
|
"
Test
Plug
-
in
"
;
let
plugin
=
getTestPlugin
(
name
)
;
plugin
.
enabledState
=
newEnabledState
;
}
function
getTestPluginEnabledState
(
pluginName
)
{
let
name
=
pluginName
|
|
"
Test
Plug
-
in
"
;
let
plugin
=
getTestPlugin
(
name
)
;
return
plugin
.
enabledState
;
}
function
promiseForPluginInfo
(
aId
aBrowser
)
{
let
browser
=
aBrowser
|
|
gTestBrowser
;
return
ContentTask
.
spawn
(
browser
aId
async
function
(
contentId
)
{
let
plugin
=
content
.
document
.
getElementById
(
contentId
)
;
if
(
!
(
plugin
instanceof
Ci
.
nsIObjectLoadingContent
)
)
throw
new
Error
(
"
no
plugin
found
"
)
;
return
{
pluginFallbackType
:
plugin
.
pluginFallbackType
activated
:
plugin
.
activated
hasRunningPlugin
:
plugin
.
hasRunningPlugin
displayedType
:
plugin
.
displayedType
}
;
}
)
;
}
function
promisePlayObject
(
aId
aBrowser
)
{
let
browser
=
aBrowser
|
|
gTestBrowser
;
return
ContentTask
.
spawn
(
browser
aId
async
function
(
contentId
)
{
let
plugin
=
content
.
document
.
getElementById
(
contentId
)
;
let
objLoadingContent
=
plugin
.
QueryInterface
(
Ci
.
nsIObjectLoadingContent
)
;
objLoadingContent
.
playPlugin
(
)
;
}
)
;
}
function
promiseCrashObject
(
aId
aBrowser
)
{
let
browser
=
aBrowser
|
|
gTestBrowser
;
return
ContentTask
.
spawn
(
browser
aId
async
function
(
contentId
)
{
let
plugin
=
content
.
document
.
getElementById
(
contentId
)
;
Cu
.
waiveXrays
(
plugin
)
.
crash
(
)
;
}
)
;
}
function
promiseObjectValueResult
(
aId
aBrowser
)
{
let
browser
=
aBrowser
|
|
gTestBrowser
;
return
ContentTask
.
spawn
(
browser
aId
async
function
(
contentId
)
{
let
plugin
=
content
.
document
.
getElementById
(
contentId
)
;
return
Cu
.
waiveXrays
(
plugin
)
.
getObjectValue
(
)
;
}
)
;
}
function
promiseReloadPlugin
(
aId
aBrowser
)
{
let
browser
=
aBrowser
|
|
gTestBrowser
;
return
ContentTask
.
spawn
(
browser
aId
async
function
(
contentId
)
{
let
plugin
=
content
.
document
.
getElementById
(
contentId
)
;
plugin
.
src
=
plugin
.
src
;
}
)
;
}
function
clearAllPluginPermissions
(
)
{
let
perms
=
Services
.
perms
.
enumerator
;
while
(
perms
.
hasMoreElements
(
)
)
{
let
perm
=
perms
.
getNext
(
)
;
if
(
perm
.
type
.
startsWith
(
"
plugin
"
)
)
{
info
(
"
removing
permission
:
"
+
perm
.
principal
.
origin
+
"
"
+
perm
.
type
+
"
\
n
"
)
;
Services
.
perms
.
removePermission
(
perm
)
;
}
}
}
function
updateBlocklist
(
aCallback
)
{
let
blocklistNotifier
=
Cc
[
"
mozilla
.
org
/
extensions
/
blocklist
;
1
"
]
.
getService
(
Ci
.
nsITimerCallback
)
;
let
observer
=
function
(
)
{
Services
.
obs
.
removeObserver
(
observer
"
blocklist
-
updated
"
)
;
SimpleTest
.
executeSoon
(
aCallback
)
;
}
;
Services
.
obs
.
addObserver
(
observer
"
blocklist
-
updated
"
)
;
blocklistNotifier
.
notify
(
null
)
;
}
var
_originalTestBlocklistURL
=
null
;
function
setAndUpdateBlocklist
(
aURL
aCallback
)
{
if
(
!
_originalTestBlocklistURL
)
{
_originalTestBlocklistURL
=
Services
.
prefs
.
getCharPref
(
"
extensions
.
blocklist
.
url
"
)
;
}
Services
.
prefs
.
setCharPref
(
"
extensions
.
blocklist
.
url
"
aURL
)
;
updateBlocklist
(
aCallback
)
;
}
async
function
asyncSetAndUpdateBlocklist
(
aURL
aBrowser
)
{
info
(
"
*
*
*
loading
new
blocklist
:
"
+
aURL
)
;
let
doTestRemote
=
aBrowser
?
aBrowser
.
isRemoteBrowser
:
false
;
if
(
!
_originalTestBlocklistURL
)
{
_originalTestBlocklistURL
=
Services
.
prefs
.
getCharPref
(
"
extensions
.
blocklist
.
url
"
)
;
}
Services
.
prefs
.
setCharPref
(
"
extensions
.
blocklist
.
url
"
aURL
)
;
let
localPromise
=
TestUtils
.
topicObserved
(
"
blocklist
-
updated
"
)
;
let
blocklistNotifier
=
Cc
[
"
mozilla
.
org
/
extensions
/
blocklist
;
1
"
]
.
getService
(
Ci
.
nsITimerCallback
)
;
blocklistNotifier
.
notify
(
null
)
;
info
(
"
*
*
*
waiting
on
local
load
"
)
;
await
localPromise
;
if
(
doTestRemote
)
{
info
(
"
*
*
*
waiting
on
remote
load
"
)
;
await
ContentTask
.
spawn
(
aBrowser
null
(
)
=
>
{
}
)
;
}
info
(
"
*
*
*
blocklist
loaded
.
"
)
;
}
function
resetBlocklist
(
)
{
Services
.
prefs
.
setCharPref
(
"
extensions
.
blocklist
.
url
"
_originalTestBlocklistURL
)
;
}
function
promisePopupNotification
(
aName
aBrowser
)
{
return
new
Promise
(
(
resolve
)
=
>
{
waitForCondition
(
(
)
=
>
PopupNotifications
.
getNotification
(
aName
aBrowser
)
(
)
=
>
{
ok
(
!
!
PopupNotifications
.
getNotification
(
aName
aBrowser
)
aName
+
"
notification
appeared
"
)
;
resolve
(
)
;
}
"
timeout
waiting
for
popup
notification
"
+
aName
)
;
}
)
;
}
function
promiseWaitForFocus
(
aWindow
)
{
return
new
Promise
(
(
resolve
)
=
>
{
waitForFocus
(
resolve
aWindow
)
;
}
)
;
}
function
waitForNotificationBar
(
notificationID
browser
callback
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
notification
;
let
notificationBox
=
gBrowser
.
getNotificationBox
(
browser
)
;
waitForCondition
(
(
)
=
>
(
notification
=
notificationBox
.
getNotificationWithValue
(
notificationID
)
)
(
)
=
>
{
ok
(
notification
Successfully
got
the
{
notificationID
}
notification
bar
)
;
if
(
callback
)
{
callback
(
notification
)
;
}
resolve
(
notification
)
;
}
Waited
too
long
for
the
{
notificationID
}
notification
bar
)
;
}
)
;
}
function
promiseForNotificationBar
(
notificationID
browser
)
{
return
new
Promise
(
(
resolve
)
=
>
{
waitForNotificationBar
(
notificationID
browser
resolve
)
;
}
)
;
}
function
waitForNotificationShown
(
notification
callback
)
{
if
(
PopupNotifications
.
panel
.
state
=
=
"
open
"
)
{
executeSoon
(
callback
)
;
return
;
}
PopupNotifications
.
panel
.
addEventListener
(
"
popupshown
"
function
(
e
)
{
callback
(
)
;
}
{
once
:
true
}
)
;
notification
.
reshow
(
)
;
}
function
promiseForNotificationShown
(
notification
)
{
return
new
Promise
(
(
resolve
)
=
>
{
waitForNotificationShown
(
notification
resolve
)
;
}
)
;
}
function
promiseUpdatePluginBindings
(
browser
)
{
return
ContentTask
.
spawn
(
browser
{
}
async
function
(
)
{
let
doc
=
content
.
document
;
let
elems
=
doc
.
getElementsByTagName
(
"
embed
"
)
;
if
(
!
elems
|
|
elems
.
length
<
1
)
{
elems
=
doc
.
getElementsByTagName
(
"
object
"
)
;
}
if
(
elems
&
&
elems
.
length
>
0
)
{
elems
[
0
]
.
clientTop
;
}
}
)
;
}
