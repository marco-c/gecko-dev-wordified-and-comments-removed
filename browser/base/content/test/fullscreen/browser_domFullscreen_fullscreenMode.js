"
use
strict
"
;
SimpleTest
.
ignoreAllUncaughtExceptions
(
true
)
;
function
listenOneEvent
(
aEvent
aListener
)
{
function
listener
(
evt
)
{
removeEventListener
(
aEvent
listener
)
;
aListener
(
evt
)
;
}
addEventListener
(
aEvent
listener
)
;
}
function
queryFullscreenState
(
browser
)
{
return
SpecialPowers
.
spawn
(
browser
[
]
(
)
=
>
{
return
{
inDOMFullscreen
:
!
!
content
.
document
.
fullscreenElement
inFullscreen
:
content
.
fullScreen
}
;
}
)
;
}
function
captureUnexpectedFullscreenChange
(
)
{
ok
(
false
"
catched
an
unexpected
fullscreen
change
"
)
;
}
const
FS_CHANGE_DOM
=
1
<
<
0
;
const
FS_CHANGE_SIZE
=
1
<
<
1
;
const
FS_CHANGE_BOTH
=
FS_CHANGE_DOM
|
FS_CHANGE_SIZE
;
function
waitForDocActivated
(
aBrowser
)
{
return
SpecialPowers
.
spawn
(
aBrowser
[
]
(
)
=
>
{
return
ContentTaskUtils
.
waitForCondition
(
(
)
=
>
content
.
browsingContext
.
isActive
&
&
content
.
document
.
hasFocus
(
)
)
;
}
)
;
}
function
waitForFullscreenChanges
(
aBrowser
aFlags
)
{
return
new
Promise
(
resolve
=
>
{
let
fullscreenData
=
null
;
let
sizemodeChanged
=
false
;
function
tryResolve
(
)
{
if
(
(
!
(
aFlags
&
FS_CHANGE_DOM
)
|
|
fullscreenData
)
&
&
(
!
(
aFlags
&
FS_CHANGE_SIZE
)
|
|
sizemodeChanged
)
)
{
waitForDocActivated
(
aBrowser
)
.
then
(
(
)
=
>
{
if
(
!
fullscreenData
)
{
queryFullscreenState
(
aBrowser
)
.
then
(
resolve
)
;
}
else
{
resolve
(
fullscreenData
)
;
}
}
)
;
}
}
if
(
aFlags
&
FS_CHANGE_SIZE
)
{
listenOneEvent
(
"
sizemodechange
"
(
)
=
>
{
sizemodeChanged
=
true
;
tryResolve
(
)
;
}
)
;
}
if
(
aFlags
&
FS_CHANGE_DOM
)
{
BrowserTestUtils
.
waitForContentEvent
(
aBrowser
"
fullscreenchange
"
)
.
then
(
async
(
)
=
>
{
fullscreenData
=
await
queryFullscreenState
(
aBrowser
)
;
tryResolve
(
)
;
}
)
;
}
}
)
;
}
var
gTests
=
[
{
desc
:
"
document
method
"
affectsFullscreenMode
:
false
exitFunc
:
browser
=
>
{
SpecialPowers
.
spawn
(
browser
[
]
(
)
=
>
{
content
.
document
.
exitFullscreen
(
)
;
}
)
;
}
}
{
desc
:
"
escape
key
"
affectsFullscreenMode
:
false
exitFunc
:
(
)
=
>
{
executeSoon
(
(
)
=
>
EventUtils
.
synthesizeKey
(
"
KEY_Escape
"
)
)
;
}
}
{
desc
:
"
F11
key
"
affectsFullscreenMode
:
true
exitFunc
(
)
{
executeSoon
(
(
)
=
>
EventUtils
.
synthesizeKey
(
"
KEY_F11
"
)
)
;
}
}
]
;
function
checkState
(
expectedStates
contentStates
)
{
is
(
contentStates
.
inDOMFullscreen
expectedStates
.
inDOMFullscreen
"
The
DOM
fullscreen
state
of
the
content
should
match
"
)
;
is
(
!
!
document
.
fullscreenElement
expectedStates
.
inDOMFullscreen
"
The
DOM
fullscreen
state
of
the
chrome
should
match
"
)
;
is
(
window
.
fullScreen
expectedStates
.
inFullscreen
"
The
fullscreen
state
of
the
chrome
should
match
"
)
;
}
const
kPage
=
"
https
:
/
/
example
.
org
/
browser
/
browser
/
"
+
"
base
/
content
/
test
/
general
/
dummy_page
.
html
"
;
add_task
(
async
function
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
full
-
screen
-
api
.
transition
-
duration
.
enter
"
"
0
0
"
]
[
"
full
-
screen
-
api
.
transition
-
duration
.
leave
"
"
0
0
"
]
]
}
)
;
registerCleanupFunction
(
async
function
(
)
{
if
(
window
.
fullScreen
)
{
let
fullscreenPromise
=
waitForFullscreenChanges
(
gBrowser
.
selectedBrowser
FS_CHANGE_SIZE
)
;
executeSoon
(
(
)
=
>
BrowserFullScreen
(
)
)
;
await
fullscreenPromise
;
}
}
)
;
let
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
{
gBrowser
url
:
kPage
}
)
;
let
browser
=
tab
.
linkedBrowser
;
await
waitForDocActivated
(
browser
)
;
for
(
let
test
of
gTests
)
{
let
contentStates
;
info
(
"
Testing
exit
DOM
fullscreen
via
"
+
test
.
desc
)
;
contentStates
=
await
queryFullscreenState
(
browser
)
;
checkState
(
{
inDOMFullscreen
:
false
inFullscreen
:
false
}
contentStates
)
;
info
(
"
>
Enter
DOM
fullscreen
"
)
;
let
fullscreenPromise
=
waitForFullscreenChanges
(
browser
FS_CHANGE_BOTH
)
;
await
SpecialPowers
.
spawn
(
browser
[
]
(
)
=
>
{
content
.
document
.
body
.
requestFullscreen
(
)
;
}
)
;
contentStates
=
await
fullscreenPromise
;
checkState
(
{
inDOMFullscreen
:
true
inFullscreen
:
true
}
contentStates
)
;
info
(
"
>
Exit
DOM
fullscreen
"
)
;
fullscreenPromise
=
waitForFullscreenChanges
(
browser
FS_CHANGE_BOTH
)
;
test
.
exitFunc
(
browser
)
;
contentStates
=
await
fullscreenPromise
;
checkState
(
{
inDOMFullscreen
:
false
inFullscreen
:
false
}
contentStates
)
;
info
(
"
>
Enter
fullscreen
mode
"
)
;
fullscreenPromise
=
waitForFullscreenChanges
(
browser
FS_CHANGE_SIZE
)
;
executeSoon
(
(
)
=
>
BrowserFullScreen
(
)
)
;
contentStates
=
await
fullscreenPromise
;
checkState
(
{
inDOMFullscreen
:
false
inFullscreen
:
true
}
contentStates
)
;
info
(
"
>
Enter
DOM
fullscreen
in
fullscreen
mode
"
)
;
fullscreenPromise
=
waitForFullscreenChanges
(
browser
FS_CHANGE_DOM
)
;
await
SpecialPowers
.
spawn
(
browser
[
]
(
)
=
>
{
content
.
document
.
body
.
requestFullscreen
(
)
;
}
)
;
contentStates
=
await
fullscreenPromise
;
checkState
(
{
inDOMFullscreen
:
true
inFullscreen
:
true
}
contentStates
)
;
info
(
"
>
Exit
DOM
fullscreen
in
fullscreen
mode
"
)
;
fullscreenPromise
=
waitForFullscreenChanges
(
browser
test
.
affectsFullscreenMode
?
FS_CHANGE_BOTH
:
FS_CHANGE_DOM
)
;
test
.
exitFunc
(
browser
)
;
contentStates
=
await
fullscreenPromise
;
checkState
(
{
inDOMFullscreen
:
false
inFullscreen
:
!
test
.
affectsFullscreenMode
}
contentStates
)
;
if
(
window
.
fullScreen
)
{
info
(
"
>
Cleanup
"
)
;
fullscreenPromise
=
waitForFullscreenChanges
(
browser
FS_CHANGE_SIZE
)
;
executeSoon
(
(
)
=
>
BrowserFullScreen
(
)
)
;
await
fullscreenPromise
;
}
}
BrowserTestUtils
.
removeTab
(
tab
)
;
}
)
;
