requestLongerTimeout
(
5
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ActorManagerParent
"
"
resource
:
/
/
gre
/
modules
/
ActorManagerParent
.
jsm
"
)
;
var
isDevtools
=
SimpleTest
.
harnessParameters
.
subsuite
=
=
"
devtools
"
;
var
gExceptionPaths
=
[
"
chrome
:
/
/
browser
/
content
/
defaultthemes
/
"
"
resource
:
/
/
app
/
defaults
/
settings
/
blocklists
/
"
"
resource
:
/
/
app
/
defaults
/
settings
/
main
/
"
"
resource
:
/
/
app
/
defaults
/
settings
/
pinning
/
"
"
resource
:
/
/
app
/
defaults
/
preferences
/
"
"
resource
:
/
/
gre
/
modules
/
commonjs
/
"
"
resource
:
/
/
gre
/
defaults
/
pref
/
"
"
resource
:
/
/
payments
/
"
"
resource
:
/
/
normandy
-
content
/
shield
-
content
-
frame
.
js
"
"
resource
:
/
/
normandy
-
content
/
shield
-
content
-
process
.
js
"
"
resource
:
/
/
activity
-
stream
/
data
/
content
/
tippytop
/
images
/
"
"
resource
:
/
/
activity
-
stream
/
prerendered
/
"
"
resource
:
/
/
pdf
.
js
/
web
/
images
/
"
"
resource
:
/
/
formautofill
/
addressmetadata
/
"
"
resource
:
/
/
search
-
plugins
/
"
]
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
gExceptionPaths
.
push
(
"
resource
:
/
/
gre
/
res
/
cursors
/
"
)
;
gExceptionPaths
.
push
(
"
resource
:
/
/
gre
/
res
/
touchbar
/
"
)
;
}
var
whitelist
=
[
{
file
:
"
chrome
:
/
/
pdf
.
js
/
locale
/
chrome
.
properties
"
}
{
file
:
"
chrome
:
/
/
pdf
.
js
/
locale
/
viewer
.
properties
"
}
{
file
:
"
chrome
:
/
/
pippki
/
content
/
load_device
.
xul
"
}
{
file
:
"
chrome
:
/
/
global
/
locale
/
fallbackMenubar
.
properties
"
platforms
:
[
"
linux
"
"
win
"
]
}
{
file
:
"
chrome
:
/
/
global
/
locale
/
printPageSetup
.
dtd
"
platforms
:
[
"
linux
"
"
macosx
"
]
}
{
file
:
"
chrome
:
/
/
global
/
locale
/
printPreviewProgress
.
dtd
"
platforms
:
[
"
macosx
"
]
}
{
file
:
"
chrome
:
/
/
global
/
locale
/
printProgress
.
dtd
"
platforms
:
[
"
macosx
"
]
}
{
file
:
"
chrome
:
/
/
global
/
skin
/
aboutRights
.
css
"
skipUnofficial
:
true
}
{
file
:
"
chrome
:
/
/
devtools
/
content
/
inspector
/
markup
/
markup
.
xhtml
"
isFromDevTools
:
true
}
{
file
:
"
resource
:
/
/
gre
/
modules
/
reflect
.
jsm
"
}
{
file
:
"
resource
:
/
/
gre
/
defaults
/
autoconfig
/
prefcalls
.
js
"
}
{
file
:
"
resource
:
/
/
gre
/
greprefs
.
js
"
}
{
file
:
"
resource
:
/
/
pdf
.
js
/
build
/
pdf
.
worker
.
js
"
}
{
file
:
"
resource
:
/
/
gre
/
res
/
fonts
/
mathfontSTIXGeneral
.
properties
"
}
{
file
:
"
resource
:
/
/
gre
/
res
/
fonts
/
mathfontUnicode
.
properties
"
}
{
file
:
"
resource
:
/
/
gre
/
modules
/
ClusterLib
.
js
"
}
{
file
:
"
resource
:
/
/
gre
/
modules
/
ColorConversion
.
js
"
}
{
file
:
"
chrome
:
/
/
global
/
content
/
win
.
xul
"
}
{
file
:
"
resource
:
/
/
gre
/
chrome
/
en
-
US
/
locale
/
en
-
US
/
global
-
platform
/
mac
/
accessible
.
properties
"
platforms
:
[
"
linux
"
"
win
"
]
}
{
file
:
"
resource
:
/
/
gre
/
chrome
/
en
-
US
/
locale
/
en
-
US
/
global
-
platform
/
mac
/
intl
.
properties
"
platforms
:
[
"
linux
"
"
win
"
]
}
{
file
:
"
resource
:
/
/
gre
/
chrome
/
en
-
US
/
locale
/
en
-
US
/
global
-
platform
/
mac
/
platformKeys
.
properties
"
platforms
:
[
"
linux
"
"
win
"
]
}
{
file
:
"
resource
:
/
/
gre
/
chrome
/
en
-
US
/
locale
/
en
-
US
/
global
-
platform
/
unix
/
accessible
.
properties
"
platforms
:
[
"
macosx
"
"
win
"
]
}
{
file
:
"
resource
:
/
/
gre
/
chrome
/
en
-
US
/
locale
/
en
-
US
/
global
-
platform
/
unix
/
intl
.
properties
"
platforms
:
[
"
macosx
"
"
win
"
]
}
{
file
:
"
resource
:
/
/
gre
/
chrome
/
en
-
US
/
locale
/
en
-
US
/
global
-
platform
/
unix
/
platformKeys
.
properties
"
platforms
:
[
"
macosx
"
"
win
"
]
}
{
file
:
"
resource
:
/
/
gre
/
chrome
/
en
-
US
/
locale
/
en
-
US
/
global
-
platform
/
win
/
accessible
.
properties
"
platforms
:
[
"
linux
"
"
macosx
"
]
}
{
file
:
"
resource
:
/
/
gre
/
chrome
/
en
-
US
/
locale
/
en
-
US
/
global
-
platform
/
win
/
intl
.
properties
"
platforms
:
[
"
linux
"
"
macosx
"
]
}
{
file
:
"
resource
:
/
/
gre
/
chrome
/
en
-
US
/
locale
/
en
-
US
/
global
-
platform
/
win
/
platformKeys
.
properties
"
platforms
:
[
"
linux
"
"
macosx
"
]
}
{
file
:
"
resource
:
/
/
pdf
.
js
/
web
/
debugger
.
js
"
}
{
file
:
"
resource
:
/
/
app
/
modules
/
translation
/
BingTranslator
.
jsm
"
}
{
file
:
"
resource
:
/
/
app
/
modules
/
translation
/
GoogleTranslator
.
jsm
"
}
{
file
:
"
resource
:
/
/
app
/
modules
/
translation
/
YandexTranslator
.
jsm
"
}
{
file
:
"
chrome
:
/
/
browser
/
locale
/
taskbar
.
properties
"
platforms
:
[
"
linux
"
"
macosx
"
]
}
{
file
:
"
chrome
:
/
/
global
/
skin
/
icons
/
error
-
16
.
png
"
}
{
file
:
"
chrome
:
/
/
marionette
/
content
/
test_anonymous_content
.
xul
"
}
{
file
:
"
chrome
:
/
/
marionette
/
content
/
test_dialog
.
properties
"
}
{
file
:
"
chrome
:
/
/
marionette
/
content
/
test_dialog
.
xul
"
}
{
file
:
"
chrome
:
/
/
mozapps
/
skin
/
downloads
/
buttons
.
png
"
platforms
:
[
"
macosx
"
]
}
{
file
:
"
chrome
:
/
/
mozapps
/
skin
/
downloads
/
downloadButtons
.
png
"
platforms
:
[
"
linux
"
"
win
"
]
}
{
file
:
"
chrome
:
/
/
mozapps
/
skin
/
update
/
downloadButtons
.
png
"
platforms
:
[
"
linux
"
]
}
{
file
:
"
chrome
:
/
/
pippki
/
content
/
resetpassword
.
xul
"
}
{
file
:
"
resource
:
/
/
gre
/
modules
/
Battery
.
jsm
"
}
{
file
:
"
resource
:
/
/
gre
/
modules
/
Manifest
.
jsm
"
}
{
file
:
"
resource
:
/
/
gre
/
modules
/
accessibility
/
AccessFu
.
jsm
"
}
{
file
:
"
resource
:
/
/
gre
/
modules
/
PerfMeasurement
.
jsm
"
}
{
file
:
"
chrome
:
/
/
global
/
content
/
test
-
ipc
.
xul
"
}
{
file
:
"
resource
:
/
/
gre
/
modules
/
Promise
.
jsm
"
}
{
file
:
"
resource
:
/
/
gre
/
modules
/
ZipUtils
.
jsm
"
}
{
file
:
AppConstants
.
BROWSER_CHROME_URL
=
=
"
chrome
:
/
/
browser
/
content
/
browser
.
xul
"
?
"
chrome
:
/
/
browser
/
content
/
browser
.
xhtml
"
:
"
chrome
:
/
/
browser
/
content
/
browser
.
xul
"
}
{
file
:
"
chrome
:
/
/
devtools
/
skin
/
images
/
aboutdebugging
-
firefox
-
aurora
.
svg
"
isFromDevTools
:
true
}
{
file
:
"
chrome
:
/
/
devtools
/
skin
/
images
/
aboutdebugging
-
firefox
-
beta
.
svg
"
isFromDevTools
:
true
}
{
file
:
"
chrome
:
/
/
devtools
/
skin
/
images
/
aboutdebugging
-
firefox
-
release
.
svg
"
isFromDevTools
:
true
}
{
file
:
"
chrome
:
/
/
devtools
/
skin
/
images
/
next
.
svg
"
isFromDevTools
:
true
}
{
file
:
"
resource
:
/
/
gre
-
resources
/
featuregates
/
FeatureGate
.
jsm
"
}
{
file
:
"
resource
:
/
/
gre
-
resources
/
featuregates
/
FeatureGateImplementation
.
jsm
"
}
{
file
:
"
resource
:
/
/
gre
-
resources
/
featuregates
/
feature_definitions
.
json
"
}
{
file
:
"
resource
:
/
/
gre
/
modules
/
kvstore
.
jsm
"
}
{
file
:
"
chrome
:
/
/
devtools
/
content
/
aboutdebugging
-
new
/
tmp
-
locale
/
en
-
US
/
aboutdebugging
.
ftl
"
isFromDevTools
:
true
}
{
file
:
"
resource
:
/
/
app
/
localization
/
en
-
US
/
browser
/
touchbar
/
touchbar
.
ftl
"
platforms
:
[
"
linux
"
"
win
"
]
}
]
;
whitelist
=
new
Set
(
whitelist
.
filter
(
item
=
>
(
"
isFromDevTools
"
in
item
)
=
=
isDevtools
&
&
(
!
item
.
skipUnofficial
|
|
!
AppConstants
.
MOZILLA_OFFICIAL
)
&
&
(
!
item
.
platforms
|
|
item
.
platforms
.
includes
(
AppConstants
.
platform
)
)
)
.
map
(
item
=
>
item
.
file
)
)
;
const
ignorableWhitelist
=
new
Set
(
[
"
resource
:
/
/
app
/
blocklist
.
xml
"
"
resource
:
/
/
gre
/
gmp
-
clearkey
/
0
.
1
/
manifest
.
json
"
"
resource
:
/
/
gre
/
res
/
test
.
properties
"
]
)
;
for
(
let
entry
of
ignorableWhitelist
)
{
whitelist
.
add
(
entry
)
;
}
if
(
!
isDevtools
)
{
whitelist
.
add
(
"
resource
:
/
/
services
-
sync
/
service
.
js
"
)
;
for
(
let
module
of
[
"
addons
.
js
"
"
bookmarks
.
js
"
"
forms
.
js
"
"
history
.
js
"
"
passwords
.
js
"
"
prefs
.
js
"
"
tabs
.
js
"
"
extension
-
storage
.
js
"
]
)
{
whitelist
.
add
(
"
resource
:
/
/
services
-
sync
/
engines
/
"
+
module
)
;
}
}
if
(
AppConstants
.
MOZ_CODE_COVERAGE
)
{
whitelist
.
add
(
"
chrome
:
/
/
marionette
/
content
/
PerTestCoverageUtils
.
jsm
"
)
;
}
const
gInterestingCategories
=
new
Set
(
[
"
agent
-
style
-
sheets
"
"
addon
-
provider
-
module
"
"
webextension
-
modules
"
"
webextension
-
scripts
"
"
webextension
-
schemas
"
"
webextension
-
scripts
-
addon
"
"
webextension
-
scripts
-
content
"
"
webextension
-
scripts
-
devtools
"
]
)
;
var
gChromeReg
=
Cc
[
"
mozilla
.
org
/
chrome
/
chrome
-
registry
;
1
"
]
.
getService
(
Ci
.
nsIChromeRegistry
)
;
var
gChromeMap
=
new
Map
(
)
;
var
gOverrideMap
=
new
Map
(
)
;
var
gComponentsSet
=
new
Set
(
)
;
var
gReferencesFromCode
=
new
Map
(
)
;
var
resHandler
=
Services
.
io
.
getProtocolHandler
(
"
resource
"
)
.
QueryInterface
(
Ci
.
nsIResProtocolHandler
)
;
var
gResourceMap
=
[
]
;
function
trackResourcePrefix
(
prefix
)
{
let
uri
=
Services
.
io
.
newURI
(
"
resource
:
/
/
"
+
prefix
+
"
/
"
)
;
gResourceMap
.
unshift
(
[
prefix
resHandler
.
resolveURI
(
uri
)
]
)
;
}
trackResourcePrefix
(
"
gre
"
)
;
trackResourcePrefix
(
"
app
"
)
;
function
getBaseUriForChromeUri
(
chromeUri
)
{
let
chromeFile
=
chromeUri
+
"
gobbledygooknonexistentfile
.
reallynothere
"
;
let
uri
=
Services
.
io
.
newURI
(
chromeFile
)
;
let
fileUri
=
gChromeReg
.
convertChromeURL
(
uri
)
;
return
fileUri
.
resolve
(
"
.
"
)
;
}
function
trackChromeUri
(
uri
)
{
gChromeMap
.
set
(
getBaseUriForChromeUri
(
uri
)
uri
)
;
}
trackResourcePrefix
(
"
formautofill
"
)
;
trackChromeUri
(
"
chrome
:
/
/
formautofill
/
content
/
"
)
;
function
parseManifest
(
manifestUri
)
{
return
fetchFile
(
manifestUri
.
spec
)
.
then
(
data
=
>
{
for
(
let
line
of
data
.
split
(
"
\
n
"
)
)
{
let
[
type
.
.
.
argv
]
=
line
.
split
(
/
\
s
+
/
)
;
if
(
type
=
=
"
content
"
|
|
type
=
=
"
skin
"
|
|
type
=
=
"
locale
"
)
{
let
chromeUri
=
chrome
:
/
/
{
argv
[
0
]
}
/
{
type
}
/
;
if
(
chromeUri
=
=
=
"
chrome
:
/
/
webcompat
-
reporter
/
locale
/
"
)
{
gChromeMap
.
set
(
"
chrome
:
/
/
webcompat
-
reporter
/
locale
/
"
true
)
;
}
else
{
trackChromeUri
(
chromeUri
)
;
}
}
else
if
(
type
=
=
"
override
"
|
|
type
=
=
"
overlay
"
)
{
let
os
=
"
os
=
"
+
Services
.
appinfo
.
OS
;
if
(
!
argv
.
some
(
s
=
>
s
.
startsWith
(
"
os
=
"
)
&
&
s
!
=
os
)
)
{
gOverrideMap
.
set
(
Services
.
io
.
newURI
(
argv
[
1
]
)
.
specIgnoringRef
Services
.
io
.
newURI
(
argv
[
0
]
)
.
specIgnoringRef
)
;
}
}
else
if
(
type
=
=
"
category
"
&
&
gInterestingCategories
.
has
(
argv
[
0
]
)
)
{
gReferencesFromCode
.
set
(
argv
[
2
]
null
)
;
}
else
if
(
type
=
=
"
resource
"
)
{
trackResourcePrefix
(
argv
[
0
]
)
;
}
else
if
(
type
=
=
"
component
"
)
{
gComponentsSet
.
add
(
argv
[
1
]
)
;
}
}
}
)
;
}
async
function
parseJsonManifest
(
uri
)
{
let
raw
=
await
fetchFile
(
uri
.
spec
)
;
let
data
;
try
{
data
=
JSON
.
parse
(
raw
)
;
}
catch
(
ex
)
{
return
uri
;
}
if
(
data
.
manifest_version
!
=
=
2
)
{
return
uri
;
}
if
(
data
.
experiment_apis
)
{
for
(
let
api
of
Object
.
values
(
data
.
experiment_apis
)
)
{
if
(
api
.
parent
&
&
api
.
parent
.
script
)
{
let
script
=
uri
.
resolve
(
api
.
parent
.
script
)
;
gReferencesFromCode
.
set
(
script
null
)
;
}
}
}
return
null
;
}
function
addCodeReference
(
url
fromURI
)
{
let
from
=
convertToCodeURI
(
fromURI
.
spec
)
;
if
(
url
=
=
from
)
return
;
let
ref
;
if
(
gReferencesFromCode
.
has
(
url
)
)
{
ref
=
gReferencesFromCode
.
get
(
url
)
;
if
(
ref
=
=
=
null
)
return
;
}
else
{
ref
=
new
Set
(
)
;
gReferencesFromCode
.
set
(
url
ref
)
;
}
ref
.
add
(
from
)
;
}
function
listCodeReferences
(
refs
)
{
let
refList
=
[
]
;
if
(
refs
)
{
for
(
let
ref
of
refs
)
{
refList
.
push
(
ref
)
;
}
}
return
refList
.
join
(
"
"
)
;
}
function
parseCSSFile
(
fileUri
)
{
return
fetchFile
(
fileUri
.
spec
)
.
then
(
data
=
>
{
for
(
let
line
of
data
.
split
(
"
\
n
"
)
)
{
let
urls
=
line
.
match
(
/
url
\
(
[
^
(
)
]
+
\
)
/
g
)
;
if
(
!
urls
)
{
let
importMatch
=
line
.
match
(
/
import
[
'
"
]
?
(
[
^
'
"
]
*
)
[
'
"
]
?
/
)
;
if
(
importMatch
&
&
importMatch
[
1
]
)
{
let
url
=
Services
.
io
.
newURI
(
importMatch
[
1
]
null
fileUri
)
.
spec
;
addCodeReference
(
convertToCodeURI
(
url
)
fileUri
)
;
}
continue
;
}
for
(
let
url
of
urls
)
{
url
=
url
.
replace
(
/
url
\
(
(
[
^
)
]
*
)
\
)
/
"
1
"
)
.
replace
(
/
^
"
(
.
*
)
"
/
"
1
"
)
.
replace
(
/
^
'
(
.
*
)
'
/
"
1
"
)
;
if
(
url
.
startsWith
(
"
data
:
"
)
)
continue
;
try
{
url
=
Services
.
io
.
newURI
(
url
null
fileUri
)
.
specIgnoringRef
;
addCodeReference
(
convertToCodeURI
(
url
)
fileUri
)
;
}
catch
(
e
)
{
ok
(
false
"
unexpected
error
while
resolving
this
URI
:
"
+
url
)
;
}
}
}
}
)
;
}
function
parseCodeFile
(
fileUri
)
{
return
fetchFile
(
fileUri
.
spec
)
.
then
(
data
=
>
{
let
baseUri
;
for
(
let
line
of
data
.
split
(
"
\
n
"
)
)
{
let
urls
=
line
.
match
(
/
[
"
'
]
chrome
:
\
/
\
/
[
a
-
zA
-
Z0
-
9
-
]
+
\
/
(
content
|
skin
|
locale
)
\
/
[
^
"
'
]
*
[
"
'
]
/
g
)
;
if
(
!
urls
)
{
urls
=
line
.
match
(
/
[
"
'
]
resource
:
\
/
\
/
[
^
"
'
]
+
[
"
'
]
/
g
)
;
if
(
urls
&
&
isDevtools
&
&
/
baseURI
:
"
resource
:
\
/
\
/
devtools
\
/
/
.
test
(
line
)
)
{
baseUri
=
Services
.
io
.
newURI
(
urls
[
0
]
.
slice
(
1
-
1
)
)
;
continue
;
}
}
if
(
!
urls
)
{
urls
=
line
.
match
(
/
[
a
-
z0
-
9_
\
/
-
]
+
\
.
ftl
/
i
)
;
if
(
urls
)
{
urls
=
urls
[
0
]
;
let
grePrefix
=
Services
.
io
.
newURI
(
"
resource
:
/
/
gre
/
localization
/
en
-
US
/
"
)
;
let
appPrefix
=
Services
.
io
.
newURI
(
"
resource
:
/
/
app
/
localization
/
en
-
US
/
"
)
;
let
grePrefixUrl
=
Services
.
io
.
newURI
(
urls
null
grePrefix
)
.
spec
;
let
appPrefixUrl
=
Services
.
io
.
newURI
(
urls
null
appPrefix
)
.
spec
;
addCodeReference
(
grePrefixUrl
fileUri
)
;
addCodeReference
(
appPrefixUrl
fileUri
)
;
continue
;
}
}
if
(
!
urls
)
{
let
match
=
line
.
match
(
"
(
?
:
src
|
href
)
=
[
\
"
'
]
(
[
^
&
\
"
'
]
+
)
"
)
;
if
(
match
&
&
match
[
1
]
)
{
let
url
=
Services
.
io
.
newURI
(
match
[
1
]
null
fileUri
)
.
spec
;
addCodeReference
(
convertToCodeURI
(
url
)
fileUri
)
;
}
if
(
isDevtools
)
{
let
rules
=
[
[
"
devtools
/
client
/
locales
"
"
chrome
:
/
/
devtools
/
locale
"
]
[
"
devtools
/
shared
/
locales
"
"
chrome
:
/
/
devtools
-
shared
/
locale
"
]
[
"
devtools
/
shared
/
platform
"
"
resource
:
/
/
devtools
/
shared
/
platform
/
chrome
"
]
[
"
devtools
"
"
resource
:
/
/
devtools
"
]
]
;
match
=
line
.
match
(
/
[
"
'
]
(
(
?
:
devtools
)
\
/
[
^
\
\
#
"
'
]
+
)
[
"
'
]
/
)
;
if
(
match
&
&
match
[
1
]
)
{
let
path
=
match
[
1
]
;
for
(
let
rule
of
rules
)
{
if
(
path
.
startsWith
(
rule
[
0
]
+
"
/
"
)
)
{
path
=
path
.
replace
(
rule
[
0
]
rule
[
1
]
)
;
if
(
!
/
\
.
(
properties
|
js
|
jsm
|
json
|
css
)
/
.
test
(
path
)
)
path
+
=
"
.
js
"
;
addCodeReference
(
path
fileUri
)
;
break
;
}
}
}
match
=
line
.
match
(
/
require
\
(
[
'
"
]
(
\
.
[
^
'
"
]
+
)
[
'
"
]
\
)
/
)
;
if
(
match
&
&
match
[
1
]
)
{
let
url
=
match
[
1
]
;
url
=
Services
.
io
.
newURI
(
url
null
baseUri
|
|
fileUri
)
.
spec
;
url
=
convertToCodeURI
(
url
)
;
if
(
!
/
\
.
(
properties
|
js
|
jsm
|
json
|
css
)
/
.
test
(
url
)
)
url
+
=
"
.
js
"
;
if
(
url
.
startsWith
(
"
resource
:
/
/
"
)
)
{
addCodeReference
(
url
fileUri
)
;
}
else
{
}
}
}
continue
;
}
for
(
let
url
of
urls
)
{
url
=
url
.
slice
(
1
-
1
)
;
if
(
url
.
endsWith
(
"
\
\
"
)
)
{
url
=
url
.
slice
(
0
-
1
)
;
}
let
pos
=
url
.
indexOf
(
"
?
"
)
;
if
(
pos
!
=
-
1
)
{
url
=
url
.
slice
(
0
pos
)
;
}
try
{
url
=
Services
.
io
.
newURI
(
url
)
.
specIgnoringRef
;
}
catch
(
e
)
{
continue
;
}
if
(
isDevtools
&
&
line
.
includes
(
"
require
(
"
)
&
&
!
/
\
.
(
properties
|
js
|
jsm
|
json
|
css
)
/
.
test
(
url
)
)
url
+
=
"
.
js
"
;
addCodeReference
(
url
fileUri
)
;
}
}
}
)
;
}
function
convertToCodeURI
(
fileUri
)
{
let
baseUri
=
fileUri
;
let
path
=
"
"
;
while
(
true
)
{
let
slashPos
=
baseUri
.
lastIndexOf
(
"
/
"
baseUri
.
length
-
2
)
;
if
(
slashPos
<
=
0
)
{
for
(
let
res
of
gResourceMap
)
{
if
(
fileUri
.
startsWith
(
res
[
1
]
)
)
return
fileUri
.
replace
(
res
[
1
]
"
resource
:
/
/
"
+
res
[
0
]
+
"
/
"
)
;
}
return
fileUri
;
}
path
=
baseUri
.
slice
(
slashPos
+
1
)
+
path
;
baseUri
=
baseUri
.
slice
(
0
slashPos
+
1
)
;
if
(
gChromeMap
.
has
(
baseUri
)
)
return
gChromeMap
.
get
(
baseUri
)
+
path
;
}
}
function
chromeFileExists
(
aURI
)
{
let
available
=
0
;
try
{
let
channel
=
NetUtil
.
newChannel
(
{
uri
:
aURI
loadUsingSystemPrincipal
:
true
}
)
;
let
stream
=
channel
.
open
(
)
;
let
sstream
=
Cc
[
"
mozilla
.
org
/
scriptableinputstream
;
1
"
]
.
createInstance
(
Ci
.
nsIScriptableInputStream
)
;
sstream
.
init
(
stream
)
;
available
=
sstream
.
available
(
)
;
sstream
.
close
(
)
;
}
catch
(
e
)
{
if
(
e
.
result
!
=
Cr
.
NS_ERROR_FILE_NOT_FOUND
&
&
e
.
result
!
=
Cr
.
NS_ERROR_NOT_AVAILABLE
)
{
todo
(
false
"
Failed
to
check
if
"
+
aURI
+
"
exists
:
"
+
e
)
;
}
}
return
available
>
0
;
}
function
findChromeUrlsFromArray
(
array
prefix
)
{
for
(
let
index
=
0
;
(
index
=
array
.
indexOf
(
prefix
.
charCodeAt
(
0
)
index
)
)
!
=
-
1
;
+
+
index
)
{
let
found
=
true
;
for
(
let
i
=
1
;
i
<
prefix
.
length
;
+
+
i
)
{
if
(
array
[
index
+
i
]
!
=
prefix
.
charCodeAt
(
i
)
)
{
found
=
false
;
break
;
}
}
if
(
!
found
)
continue
;
let
end
=
Math
.
min
(
array
.
indexOf
(
0
index
)
array
.
indexOf
(
'
"
'
.
charCodeAt
(
0
)
index
)
array
.
indexOf
(
"
)
"
.
charCodeAt
(
0
)
index
)
array
.
indexOf
(
"
#
"
.
charCodeAt
(
0
)
index
)
)
;
let
string
=
"
"
;
for
(
;
index
<
end
;
+
+
index
)
{
string
+
=
String
.
fromCharCode
(
array
[
index
]
)
;
}
if
(
/
chrome
:
\
/
\
/
[
a
-
zA
-
Z09
-
]
+
\
/
(
content
|
skin
|
locale
)
\
/
/
.
test
(
string
)
|
|
/
resource
:
\
/
\
/
[
a
-
zA
-
Z09
-
]
*
\
/
.
*
\
.
[
a
-
z
]
+
/
.
test
(
string
)
)
gReferencesFromCode
.
set
(
string
null
)
;
}
}
function
addActorModules
(
)
{
let
groups
=
[
.
.
.
ActorManagerParent
.
parentGroups
.
values
(
)
.
.
.
ActorManagerParent
.
childGroups
.
values
(
)
.
.
.
ActorManagerParent
.
singletons
.
values
(
)
]
;
for
(
let
group
of
groups
)
{
for
(
let
{
module
}
of
group
.
actors
.
values
(
)
)
{
gReferencesFromCode
.
set
(
module
null
)
;
}
}
}
add_task
(
async
function
checkAllTheFiles
(
)
{
let
libxulPath
=
OS
.
Constants
.
Path
.
libxul
;
if
(
AppConstants
.
platform
!
=
"
macosx
"
)
libxulPath
=
OS
.
Constants
.
Path
.
libDir
+
"
/
"
+
libxulPath
;
let
libxul
=
await
OS
.
File
.
read
(
libxulPath
)
;
findChromeUrlsFromArray
(
libxul
"
chrome
:
/
/
"
)
;
findChromeUrlsFromArray
(
libxul
"
resource
:
/
/
"
)
;
let
uint16
=
new
Uint16Array
(
libxul
.
buffer
)
;
findChromeUrlsFromArray
(
uint16
"
chrome
:
/
/
"
)
;
findChromeUrlsFromArray
(
uint16
"
resource
:
/
/
"
)
;
const
kCodeExtensions
=
[
"
.
xul
"
"
.
xml
"
"
.
xsl
"
"
.
js
"
"
.
jsm
"
"
.
json
"
"
.
html
"
"
.
xhtml
"
]
;
let
appDir
=
Services
.
dirsvc
.
get
(
"
GreD
"
Ci
.
nsIFile
)
;
let
uris
=
await
generateURIsFromDirTree
(
appDir
[
"
.
css
"
"
.
manifest
"
"
.
jpg
"
"
.
png
"
"
.
gif
"
"
.
svg
"
"
.
ftl
"
"
.
dtd
"
"
.
properties
"
]
.
concat
(
kCodeExtensions
)
)
;
let
manifestURIs
=
[
]
;
let
jsonManifests
=
[
]
;
uris
=
uris
.
filter
(
uri
=
>
{
let
path
=
uri
.
pathQueryRef
;
if
(
path
.
endsWith
(
"
.
manifest
"
)
)
{
manifestURIs
.
push
(
uri
)
;
return
false
;
}
else
if
(
path
.
endsWith
(
"
/
manifest
.
json
"
)
)
{
jsonManifests
.
push
(
uri
)
;
return
false
;
}
return
true
;
}
)
;
await
throttledMapPromises
(
manifestURIs
parseManifest
)
;
let
nonWebextManifests
=
(
await
Promise
.
all
(
jsonManifests
.
map
(
parseJsonManifest
)
)
)
.
filter
(
uri
=
>
!
!
uri
)
;
uris
.
push
(
.
.
.
nonWebextManifests
)
;
addActorModules
(
)
;
let
allPromises
=
[
]
;
for
(
let
uri
of
uris
)
{
let
path
=
uri
.
pathQueryRef
;
if
(
path
.
endsWith
(
"
.
css
"
)
)
allPromises
.
push
(
[
parseCSSFile
uri
]
)
;
else
if
(
kCodeExtensions
.
some
(
ext
=
>
path
.
endsWith
(
ext
)
)
)
allPromises
.
push
(
[
parseCodeFile
uri
]
)
;
}
await
throttledMapPromises
(
allPromises
(
[
task
uri
]
)
=
>
task
(
uri
)
)
;
let
devtoolsPrefixes
=
[
"
chrome
:
/
/
webide
/
"
"
chrome
:
/
/
devtools
"
"
resource
:
/
/
devtools
/
"
"
resource
:
/
/
devtools
-
client
-
jsonview
/
"
"
resource
:
/
/
devtools
-
client
-
shared
/
"
"
resource
:
/
/
app
/
modules
/
devtools
"
"
resource
:
/
/
gre
/
modules
/
devtools
"
"
resource
:
/
/
app
/
localization
/
en
-
US
/
startup
/
aboutDevTools
.
ftl
"
"
resource
:
/
/
app
/
localization
/
en
-
US
/
devtools
/
"
"
resource
:
/
/
gre
/
localization
/
en
-
US
/
toolkit
/
main
-
window
/
editmenu
.
ftl
"
]
;
let
hasDevtoolsPrefix
=
uri
=
>
devtoolsPrefixes
.
some
(
prefix
=
>
uri
.
startsWith
(
prefix
)
)
;
let
chromeFiles
=
[
]
;
for
(
let
uri
of
uris
)
{
uri
=
convertToCodeURI
(
uri
.
spec
)
;
if
(
(
uri
.
startsWith
(
"
chrome
:
/
/
"
)
|
|
uri
.
startsWith
(
"
resource
:
/
/
"
)
)
&
&
isDevtools
=
=
hasDevtoolsPrefix
(
uri
)
)
chromeFiles
.
push
(
uri
)
;
}
if
(
isDevtools
)
{
gReferencesFromCode
.
set
(
AppConstants
.
BROWSER_CHROME_URL
null
)
;
gReferencesFromCode
.
set
(
"
chrome
:
/
/
browser
/
skin
/
browser
.
css
"
null
)
;
}
let
isUnreferenced
=
file
=
>
{
if
(
gExceptionPaths
.
some
(
e
=
>
file
.
startsWith
(
e
)
)
)
return
false
;
if
(
gReferencesFromCode
.
has
(
file
)
)
{
let
refs
=
gReferencesFromCode
.
get
(
file
)
;
if
(
refs
=
=
=
null
)
return
false
;
for
(
let
ref
of
refs
)
{
if
(
isDevtools
)
{
if
(
ref
.
startsWith
(
"
resource
:
/
/
app
/
components
/
"
)
|
|
(
file
.
startsWith
(
"
chrome
:
/
/
"
)
&
&
ref
.
startsWith
(
"
resource
:
/
/
"
)
)
)
return
false
;
}
if
(
gReferencesFromCode
.
has
(
ref
)
)
{
let
refType
=
gReferencesFromCode
.
get
(
ref
)
;
if
(
refType
=
=
=
null
|
|
refType
=
=
"
whitelist
"
|
|
refType
=
=
"
whitelist
-
direct
"
)
return
false
;
}
}
}
return
!
gOverrideMap
.
has
(
file
)
|
|
isUnreferenced
(
gOverrideMap
.
get
(
file
)
)
;
}
;
let
unreferencedFiles
=
chromeFiles
;
let
removeReferenced
=
useWhitelist
=
>
{
let
foundReference
=
false
;
unreferencedFiles
=
unreferencedFiles
.
filter
(
f
=
>
{
let
rv
=
isUnreferenced
(
f
)
;
if
(
rv
&
&
f
.
startsWith
(
"
resource
:
/
/
app
/
"
)
)
rv
=
isUnreferenced
(
f
.
replace
(
"
resource
:
/
/
app
/
"
"
resource
:
/
/
/
"
)
)
;
if
(
rv
&
&
/
^
resource
:
\
/
\
/
(
?
:
app
|
gre
)
\
/
components
\
/
[
^
/
]
+
\
.
js
/
.
test
(
f
)
)
rv
=
!
gComponentsSet
.
has
(
f
.
replace
(
/
.
*
\
/
/
"
"
)
)
;
if
(
!
rv
)
{
foundReference
=
true
;
if
(
useWhitelist
)
{
info
(
"
indirectly
whitelisted
file
:
"
+
f
+
"
used
from
"
+
listCodeReferences
(
gReferencesFromCode
.
get
(
f
)
)
)
;
}
gReferencesFromCode
.
set
(
f
useWhitelist
?
"
whitelist
"
:
null
)
;
}
return
rv
;
}
)
;
return
foundReference
;
}
;
while
(
removeReferenced
(
false
)
)
{
}
unreferencedFiles
=
unreferencedFiles
.
filter
(
file
=
>
{
if
(
whitelist
.
has
(
file
)
)
{
whitelist
.
delete
(
file
)
;
gReferencesFromCode
.
set
(
file
"
whitelist
-
direct
"
)
;
return
false
;
}
return
true
;
}
)
;
while
(
removeReferenced
(
true
)
)
{
}
unreferencedFiles
.
sort
(
)
;
if
(
isDevtools
)
{
unreferencedFiles
=
unreferencedFiles
.
filter
(
file
=
>
{
if
(
file
.
startsWith
(
"
resource
:
/
/
"
)
)
{
info
(
"
unreferenced
devtools
resource
file
:
"
+
file
)
;
return
false
;
}
return
true
;
}
)
;
}
is
(
unreferencedFiles
.
length
0
"
there
should
be
no
unreferenced
files
"
)
;
for
(
let
file
of
unreferencedFiles
)
{
let
refs
=
gReferencesFromCode
.
get
(
file
)
;
if
(
refs
=
=
=
undefined
)
{
ok
(
false
"
unreferenced
file
:
"
+
file
)
;
}
else
{
let
refList
=
listCodeReferences
(
refs
)
;
let
msg
=
"
file
only
referenced
from
unreferenced
files
:
"
+
file
;
if
(
refList
)
msg
+
=
"
referenced
from
"
+
refList
;
ok
(
false
msg
)
;
}
}
for
(
let
file
of
whitelist
)
{
if
(
ignorableWhitelist
.
has
(
file
)
)
info
(
"
ignored
unused
whitelist
entry
:
"
+
file
)
;
else
ok
(
false
"
unused
whitelist
entry
:
"
+
file
)
;
}
for
(
let
[
file
refs
]
of
gReferencesFromCode
)
{
if
(
isDevtools
!
=
devtoolsPrefixes
.
some
(
prefix
=
>
file
.
startsWith
(
prefix
)
)
)
continue
;
if
(
(
file
.
startsWith
(
"
chrome
:
/
/
"
)
|
|
file
.
startsWith
(
"
resource
:
/
/
"
)
)
&
&
!
chromeFileExists
(
file
)
)
{
let
pathParts
=
file
.
match
(
"
chrome
:
/
/
(
[
^
/
]
+
)
/
content
/
(
[
^
/
.
]
+
)
\
.
xul
"
)
|
|
file
.
match
(
"
chrome
:
/
/
(
[
^
/
]
+
)
/
skin
/
(
[
^
/
.
]
+
)
\
.
css
"
)
;
if
(
pathParts
&
&
pathParts
[
1
]
=
=
pathParts
[
2
]
)
continue
;
let
refList
=
listCodeReferences
(
refs
)
;
let
msg
=
"
missing
file
:
"
+
file
;
if
(
refList
)
msg
+
=
"
referenced
from
"
+
refList
;
info
(
msg
)
;
}
}
}
)
;
