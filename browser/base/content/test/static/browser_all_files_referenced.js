requestLongerTimeout
(
5
)
;
var
isDevtools
=
SimpleTest
.
harnessParameters
.
subsuite
=
=
"
devtools
"
;
var
gExceptionPaths
=
[
"
resource
:
/
/
app
/
defaults
/
settings
/
blocklists
/
"
"
resource
:
/
/
app
/
defaults
/
settings
/
security
-
state
/
"
"
resource
:
/
/
app
/
defaults
/
settings
/
main
/
"
"
resource
:
/
/
app
/
defaults
/
preferences
/
"
"
resource
:
/
/
gre
/
modules
/
commonjs
/
"
"
resource
:
/
/
gre
/
defaults
/
pref
/
"
"
chrome
:
/
/
global
/
content
/
certviewer
/
components
/
"
"
chrome
:
/
/
activity
-
stream
/
content
/
data
/
content
/
tippytop
/
images
/
"
"
chrome
:
/
/
activity
-
stream
/
content
/
data
/
content
/
tippytop
/
favicons
/
"
"
chrome
:
/
/
activity
-
stream
/
content
/
data
/
content
/
assets
/
remote
/
"
"
chrome
:
/
/
browser
/
content
/
assets
/
moz
-
vpn
.
svg
"
"
chrome
:
/
/
browser
/
content
/
assets
/
vpn
-
logo
.
svg
"
"
chrome
:
/
/
browser
/
content
/
assets
/
focus
-
promo
.
png
"
"
chrome
:
/
/
browser
/
content
/
assets
/
klar
-
qr
-
code
.
svg
"
"
resource
:
/
/
pdf
.
js
/
web
/
images
/
"
"
resource
:
/
/
gre
-
resources
/
autofill
/
"
"
resource
:
/
/
search
-
extensions
/
"
"
resource
:
/
/
gre
/
modules
/
services
-
automation
/
"
"
resource
:
/
/
services
-
automation
/
ServicesAutomation
.
jsm
"
"
chrome
:
/
/
browser
/
content
/
certerror
/
supportpages
/
"
"
resource
:
/
/
usercontext
-
content
/
builtin
-
themes
/
"
"
chrome
:
/
/
browser
/
content
/
pagedata
/
schemas
/
"
"
resource
:
/
/
nimbus
/
schemas
/
"
"
resource
:
/
/
activity
-
stream
/
schemas
"
"
resource
:
/
/
app
/
localization
/
en
-
US
/
browser
/
featureCallout
.
ftl
"
]
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
gExceptionPaths
.
push
(
"
resource
:
/
/
gre
/
res
/
cursors
/
"
)
;
gExceptionPaths
.
push
(
"
resource
:
/
/
gre
/
res
/
touchbar
/
"
)
;
}
if
(
AppConstants
.
MOZ_BACKGROUNDTASKS
)
{
gExceptionPaths
.
push
(
"
resource
:
/
/
gre
/
defaults
/
backgroundtasks
/
"
)
;
gExceptionPaths
.
push
(
"
resource
:
/
/
app
/
defaults
/
backgroundtasks
/
"
)
;
gExceptionPaths
.
push
(
"
resource
:
/
/
gre
/
modules
/
backgroundtasks
/
"
)
;
}
if
(
AppConstants
.
NIGHTLY_BUILD
)
{
gExceptionPaths
.
push
(
"
resource
:
/
/
builtin
-
addons
/
translations
/
"
)
;
}
if
(
AppConstants
.
NIGHTLY_BUILD
)
{
gExceptionPaths
.
push
(
"
chrome
:
/
/
browser
/
content
/
places
/
interactionsViewer
.
html
"
)
;
}
var
whitelist
=
[
{
file
:
"
chrome
:
/
/
pdf
.
js
/
locale
/
chrome
.
properties
"
}
{
file
:
"
chrome
:
/
/
pdf
.
js
/
locale
/
viewer
.
properties
"
}
{
file
:
"
chrome
:
/
/
pippki
/
content
/
load_device
.
xhtml
"
}
{
file
:
"
chrome
:
/
/
global
/
locale
/
fallbackMenubar
.
properties
"
platforms
:
[
"
linux
"
"
win
"
]
}
{
file
:
"
resource
:
/
/
gre
/
localization
/
en
-
US
/
toolkit
/
printing
/
printDialogs
.
ftl
"
platforms
:
[
"
linux
"
"
macosx
"
]
}
{
file
:
"
chrome
:
/
/
global
/
skin
/
aboutRights
.
css
"
skipUnofficial
:
true
}
{
file
:
"
chrome
:
/
/
devtools
/
content
/
inspector
/
markup
/
markup
.
xhtml
"
isFromDevTools
:
true
}
{
file
:
"
resource
:
/
/
gre
/
modules
/
reflect
.
jsm
"
}
{
file
:
"
resource
:
/
/
gre
/
defaults
/
autoconfig
/
prefcalls
.
js
"
}
{
file
:
"
chrome
:
/
/
browser
/
content
/
preferences
/
more
-
from
-
mozilla
-
qr
-
code
-
simple
.
svg
"
}
{
file
:
"
chrome
:
/
/
browser
/
content
/
preferences
/
more
-
from
-
mozilla
-
qr
-
code
-
simple
-
cn
.
svg
"
}
{
file
:
"
resource
:
/
/
gre
/
greprefs
.
js
"
}
{
file
:
"
resource
:
/
/
gre
/
res
/
fonts
/
mathfontSTIXGeneral
.
properties
"
}
{
file
:
"
resource
:
/
/
gre
/
res
/
fonts
/
mathfontUnicode
.
properties
"
}
{
file
:
"
resource
:
/
/
gre
/
localization
/
en
-
US
/
toolkit
/
global
/
cspErrors
.
ftl
"
}
{
file
:
"
resource
:
/
/
gre
/
chrome
/
en
-
US
/
locale
/
en
-
US
/
global
-
platform
/
mac
/
accessible
.
properties
"
platforms
:
[
"
linux
"
"
win
"
]
}
{
file
:
"
resource
:
/
/
gre
/
chrome
/
en
-
US
/
locale
/
en
-
US
/
global
-
platform
/
mac
/
intl
.
properties
"
platforms
:
[
"
linux
"
"
win
"
]
}
{
file
:
"
resource
:
/
/
gre
/
chrome
/
en
-
US
/
locale
/
en
-
US
/
global
-
platform
/
mac
/
platformKeys
.
properties
"
platforms
:
[
"
linux
"
"
win
"
]
}
{
file
:
"
resource
:
/
/
gre
/
chrome
/
en
-
US
/
locale
/
en
-
US
/
global
-
platform
/
unix
/
accessible
.
properties
"
platforms
:
[
"
macosx
"
"
win
"
]
}
{
file
:
"
resource
:
/
/
gre
/
chrome
/
en
-
US
/
locale
/
en
-
US
/
global
-
platform
/
unix
/
intl
.
properties
"
platforms
:
[
"
macosx
"
"
win
"
]
}
{
file
:
"
resource
:
/
/
gre
/
chrome
/
en
-
US
/
locale
/
en
-
US
/
global
-
platform
/
unix
/
platformKeys
.
properties
"
platforms
:
[
"
macosx
"
"
win
"
]
}
{
file
:
"
resource
:
/
/
gre
/
chrome
/
en
-
US
/
locale
/
en
-
US
/
global
-
platform
/
win
/
accessible
.
properties
"
platforms
:
[
"
linux
"
"
macosx
"
]
}
{
file
:
"
resource
:
/
/
gre
/
chrome
/
en
-
US
/
locale
/
en
-
US
/
global
-
platform
/
win
/
intl
.
properties
"
platforms
:
[
"
linux
"
"
macosx
"
]
}
{
file
:
"
resource
:
/
/
gre
/
chrome
/
en
-
US
/
locale
/
en
-
US
/
global
-
platform
/
win
/
platformKeys
.
properties
"
platforms
:
[
"
linux
"
"
macosx
"
]
}
{
file
:
"
resource
:
/
/
pdf
.
js
/
web
/
debugger
.
js
"
}
{
file
:
"
resource
:
/
/
pdf
.
js
/
web
/
debugger
.
css
"
}
{
file
:
"
resource
:
/
/
app
/
modules
/
translation
/
BingTranslator
.
jsm
"
}
{
file
:
"
resource
:
/
/
app
/
modules
/
translation
/
GoogleTranslator
.
jsm
"
}
{
file
:
"
resource
:
/
/
app
/
modules
/
translation
/
YandexTranslator
.
jsm
"
}
{
file
:
"
chrome
:
/
/
browser
/
locale
/
taskbar
.
properties
"
platforms
:
[
"
linux
"
"
macosx
"
]
}
{
file
:
"
resource
:
/
/
gre
/
modules
/
OSCrypto
.
jsm
"
platforms
:
[
"
linux
"
"
macosx
"
]
}
{
file
:
"
chrome
:
/
/
remote
/
content
/
marionette
/
test_dialog
.
properties
"
}
{
file
:
"
chrome
:
/
/
remote
/
content
/
marionette
/
test_dialog
.
xhtml
"
}
{
file
:
"
chrome
:
/
/
remote
/
content
/
marionette
/
test_menupopup
.
xhtml
"
}
{
file
:
"
chrome
:
/
/
remote
/
content
/
marionette
/
test_no_xul
.
xhtml
"
}
{
file
:
"
chrome
:
/
/
remote
/
content
/
marionette
/
test
.
xhtml
"
}
{
file
:
"
chrome
:
/
/
pippki
/
content
/
resetpassword
.
xhtml
"
}
{
file
:
"
resource
:
/
/
gre
/
modules
/
Manifest
.
jsm
"
}
{
file
:
"
chrome
:
/
/
global
/
content
/
test
-
ipc
.
xhtml
"
}
{
file
:
"
chrome
:
/
/
devtools
/
skin
/
images
/
aboutdebugging
-
firefox
-
aurora
.
svg
"
isFromDevTools
:
true
}
{
file
:
"
chrome
:
/
/
devtools
/
skin
/
images
/
aboutdebugging
-
firefox
-
beta
.
svg
"
isFromDevTools
:
true
}
{
file
:
"
chrome
:
/
/
devtools
/
skin
/
images
/
aboutdebugging
-
firefox
-
release
.
svg
"
isFromDevTools
:
true
}
{
file
:
"
chrome
:
/
/
devtools
/
skin
/
images
/
next
.
svg
"
isFromDevTools
:
true
}
{
file
:
"
resource
:
/
/
app
/
localization
/
en
-
US
/
browser
/
touchbar
/
touchbar
.
ftl
"
platforms
:
[
"
linux
"
"
win
"
]
}
{
file
:
"
resource
:
/
/
gre
/
localization
/
en
-
US
/
toolkit
/
about
/
aboutCompat
.
ftl
"
}
{
file
:
"
resource
:
/
/
gre
/
localization
/
en
-
US
/
dom
/
media
.
ftl
"
}
{
file
:
"
resource
:
/
/
gre
/
localization
/
en
-
US
/
toolkit
/
updates
/
backgroundupdate
.
ftl
"
}
{
file
:
"
resource
:
/
/
gre
/
localization
/
en
-
US
/
toolkit
/
about
/
aboutThirdParty
.
ftl
"
platforms
:
[
"
linux
"
"
macosx
"
]
}
{
file
:
"
chrome
:
/
/
browser
/
content
/
screenshots
/
copied
-
notification
.
svg
"
}
{
file
:
"
resource
:
/
/
app
/
modules
/
SnapshotSelector
.
sys
.
mjs
"
}
{
file
:
"
resource
:
/
/
gre
/
localization
/
en
-
US
/
toolkit
/
global
/
run
-
from
-
dmg
.
ftl
"
}
{
file
:
"
resource
:
/
/
gre
/
modules
/
LangPackMatcher
.
sys
.
mjs
"
}
{
file
:
"
resource
:
/
/
gre
/
modules
/
PluralForm
.
sys
.
mjs
"
}
]
;
if
(
AppConstants
.
NIGHTLY_BUILD
&
&
AppConstants
.
platform
!
=
"
win
"
)
{
whitelist
.
push
(
{
file
:
"
chrome
:
/
/
fxr
/
content
/
fxrui
.
html
"
}
)
;
}
if
(
AppConstants
.
platform
=
=
"
android
"
)
{
whitelist
.
push
(
{
file
:
"
resource
:
/
/
gre
/
localization
/
en
-
US
/
toolkit
/
about
/
aboutGlean
.
ftl
"
}
)
;
}
if
(
AppConstants
.
MOZ_UPDATE_AGENT
&
&
!
AppConstants
.
MOZ_BACKGROUNDTASKS
)
{
whitelist
.
push
(
{
file
:
"
resource
:
/
/
gre
/
modules
/
TaskScheduler
.
jsm
"
}
)
;
}
whitelist
=
new
Set
(
whitelist
.
filter
(
item
=
>
"
isFromDevTools
"
in
item
=
=
isDevtools
&
&
(
!
item
.
skipUnofficial
|
|
!
AppConstants
.
MOZILLA_OFFICIAL
)
&
&
(
!
item
.
platforms
|
|
item
.
platforms
.
includes
(
AppConstants
.
platform
)
)
)
.
map
(
item
=
>
item
.
file
)
)
;
const
ignorableWhitelist
=
new
Set
(
[
"
resource
:
/
/
app
/
blocklist
.
xml
"
"
resource
:
/
/
gre
/
gmp
-
clearkey
/
0
.
1
/
manifest
.
json
"
"
resource
:
/
/
gre
/
res
/
test
.
properties
"
]
)
;
for
(
let
entry
of
ignorableWhitelist
)
{
whitelist
.
add
(
entry
)
;
}
if
(
!
isDevtools
)
{
for
(
let
module
of
[
"
addons
.
js
"
"
bookmarks
.
js
"
"
forms
.
js
"
"
history
.
js
"
"
passwords
.
js
"
"
prefs
.
js
"
"
tabs
.
js
"
"
extension
-
storage
.
js
"
]
)
{
whitelist
.
add
(
"
resource
:
/
/
services
-
sync
/
engines
/
"
+
module
)
;
}
if
(
!
AppConstants
.
ENABLE_WEBDRIVER
)
{
whitelist
.
add
(
"
resource
:
/
/
gre
/
modules
/
jsdebugger
.
jsm
"
)
;
}
}
if
(
AppConstants
.
MOZ_CODE_COVERAGE
)
{
whitelist
.
add
(
"
chrome
:
/
/
remote
/
content
/
marionette
/
PerTestCoverageUtils
.
jsm
"
)
;
}
const
gInterestingCategories
=
new
Set
(
[
"
agent
-
style
-
sheets
"
"
addon
-
provider
-
module
"
"
webextension
-
modules
"
"
webextension
-
scripts
"
"
webextension
-
schemas
"
"
webextension
-
scripts
-
addon
"
"
webextension
-
scripts
-
content
"
"
webextension
-
scripts
-
devtools
"
]
)
;
var
gChromeReg
=
Cc
[
"
mozilla
.
org
/
chrome
/
chrome
-
registry
;
1
"
]
.
getService
(
Ci
.
nsIChromeRegistry
)
;
var
gChromeMap
=
new
Map
(
)
;
var
gOverrideMap
=
new
Map
(
)
;
var
gComponentsSet
=
new
Set
(
)
;
var
gReferencesFromCode
=
new
Map
(
)
;
var
resHandler
=
Services
.
io
.
getProtocolHandler
(
"
resource
"
)
.
QueryInterface
(
Ci
.
nsIResProtocolHandler
)
;
var
gResourceMap
=
[
]
;
function
trackResourcePrefix
(
prefix
)
{
let
uri
=
Services
.
io
.
newURI
(
"
resource
:
/
/
"
+
prefix
+
"
/
"
)
;
gResourceMap
.
unshift
(
[
prefix
resHandler
.
resolveURI
(
uri
)
]
)
;
}
trackResourcePrefix
(
"
gre
"
)
;
trackResourcePrefix
(
"
app
"
)
;
function
getBaseUriForChromeUri
(
chromeUri
)
{
let
chromeFile
=
chromeUri
+
"
gobbledygooknonexistentfile
.
reallynothere
"
;
let
uri
=
Services
.
io
.
newURI
(
chromeFile
)
;
let
fileUri
=
gChromeReg
.
convertChromeURL
(
uri
)
;
return
fileUri
.
resolve
(
"
.
"
)
;
}
function
trackChromeUri
(
uri
)
{
gChromeMap
.
set
(
getBaseUriForChromeUri
(
uri
)
uri
)
;
}
trackResourcePrefix
(
"
autofill
"
)
;
trackChromeUri
(
"
chrome
:
/
/
formautofill
/
content
/
"
)
;
function
parseManifest
(
manifestUri
)
{
return
fetchFile
(
manifestUri
.
spec
)
.
then
(
data
=
>
{
for
(
let
line
of
data
.
split
(
"
\
n
"
)
)
{
let
[
type
.
.
.
argv
]
=
line
.
split
(
/
\
s
+
/
)
;
if
(
type
=
=
"
content
"
|
|
type
=
=
"
skin
"
|
|
type
=
=
"
locale
"
)
{
let
chromeUri
=
chrome
:
/
/
{
argv
[
0
]
}
/
{
type
}
/
;
if
(
chromeUri
=
=
=
"
chrome
:
/
/
report
-
site
-
issue
/
locale
/
"
)
{
gChromeMap
.
set
(
"
chrome
:
/
/
report
-
site
-
issue
/
locale
/
"
true
)
;
}
else
{
trackChromeUri
(
chromeUri
)
;
}
}
else
if
(
type
=
=
"
override
"
|
|
type
=
=
"
overlay
"
)
{
let
os
=
"
os
=
"
+
Services
.
appinfo
.
OS
;
if
(
!
argv
.
some
(
s
=
>
s
.
startsWith
(
"
os
=
"
)
&
&
s
!
=
os
)
)
{
gOverrideMap
.
set
(
Services
.
io
.
newURI
(
argv
[
1
]
)
.
specIgnoringRef
Services
.
io
.
newURI
(
argv
[
0
]
)
.
specIgnoringRef
)
;
}
}
else
if
(
type
=
=
"
category
"
&
&
gInterestingCategories
.
has
(
argv
[
0
]
)
)
{
gReferencesFromCode
.
set
(
argv
[
2
]
null
)
;
}
else
if
(
type
=
=
"
resource
"
)
{
trackResourcePrefix
(
argv
[
0
]
)
;
}
else
if
(
type
=
=
"
component
"
)
{
gComponentsSet
.
add
(
argv
[
1
]
)
;
}
}
}
)
;
}
async
function
parseJsonManifest
(
uri
)
{
uri
=
Services
.
io
.
newURI
(
convertToCodeURI
(
uri
.
spec
)
)
;
let
raw
=
await
fetchFile
(
uri
.
spec
)
;
let
data
;
try
{
data
=
JSON
.
parse
(
raw
)
;
}
catch
(
ex
)
{
return
uri
;
}
if
(
data
.
manifest_version
!
=
=
2
)
{
return
uri
;
}
if
(
data
.
background
?
.
scripts
)
{
for
(
let
bgscript
of
data
.
background
.
scripts
)
{
gReferencesFromCode
.
set
(
uri
.
resolve
(
bgscript
)
null
)
;
}
}
if
(
data
.
icons
)
{
for
(
let
icon
of
Object
.
values
(
data
.
icons
)
)
{
gReferencesFromCode
.
set
(
uri
.
resolve
(
icon
)
null
)
;
}
}
if
(
data
.
experiment_apis
)
{
for
(
let
api
of
Object
.
values
(
data
.
experiment_apis
)
)
{
if
(
api
.
parent
&
&
api
.
parent
.
script
)
{
let
script
=
uri
.
resolve
(
api
.
parent
.
script
)
;
gReferencesFromCode
.
set
(
script
null
)
;
}
if
(
api
.
schema
)
{
gReferencesFromCode
.
set
(
uri
.
resolve
(
api
.
schema
)
null
)
;
}
}
}
if
(
data
.
theme_experiment
&
&
data
.
theme_experiment
.
stylesheet
)
{
let
stylesheet
=
uri
.
resolve
(
data
.
theme_experiment
.
stylesheet
)
;
gReferencesFromCode
.
set
(
stylesheet
null
)
;
}
for
(
let
themeKey
of
[
"
theme
"
"
dark_theme
"
]
)
{
if
(
data
?
.
[
themeKey
]
?
.
images
?
.
additional_backgrounds
)
{
for
(
let
background
of
data
[
themeKey
]
.
images
.
additional_backgrounds
)
{
gReferencesFromCode
.
set
(
uri
.
resolve
(
background
)
null
)
;
}
}
}
return
null
;
}
function
addCodeReference
(
url
fromURI
)
{
let
from
=
convertToCodeURI
(
fromURI
.
spec
)
;
if
(
url
=
=
from
)
{
return
;
}
let
ref
;
if
(
gReferencesFromCode
.
has
(
url
)
)
{
ref
=
gReferencesFromCode
.
get
(
url
)
;
if
(
ref
=
=
=
null
)
{
return
;
}
}
else
{
ref
=
new
Set
(
)
;
gReferencesFromCode
.
set
(
url
ref
)
;
}
ref
.
add
(
from
)
;
}
function
listCodeReferences
(
refs
)
{
let
refList
=
[
]
;
if
(
refs
)
{
for
(
let
ref
of
refs
)
{
refList
.
push
(
ref
)
;
}
}
return
refList
.
join
(
"
"
)
;
}
function
parseCSSFile
(
fileUri
)
{
return
fetchFile
(
fileUri
.
spec
)
.
then
(
data
=
>
{
for
(
let
line
of
data
.
split
(
"
\
n
"
)
)
{
let
urls
=
line
.
match
(
/
url
\
(
[
^
(
)
]
+
\
)
/
g
)
;
if
(
!
urls
)
{
let
importMatch
=
line
.
match
(
/
import
[
'
"
]
?
(
[
^
'
"
]
*
)
[
'
"
]
?
/
)
;
if
(
importMatch
&
&
importMatch
[
1
]
)
{
let
url
=
Services
.
io
.
newURI
(
importMatch
[
1
]
null
fileUri
)
.
spec
;
addCodeReference
(
convertToCodeURI
(
url
)
fileUri
)
;
}
continue
;
}
for
(
let
url
of
urls
)
{
url
=
url
.
replace
(
/
url
\
(
(
[
^
)
]
*
)
\
)
/
"
1
"
)
.
replace
(
/
^
"
(
.
*
)
"
/
"
1
"
)
.
replace
(
/
^
'
(
.
*
)
'
/
"
1
"
)
;
if
(
url
.
startsWith
(
"
data
:
"
)
)
{
continue
;
}
try
{
url
=
Services
.
io
.
newURI
(
url
null
fileUri
)
.
specIgnoringRef
;
addCodeReference
(
convertToCodeURI
(
url
)
fileUri
)
;
}
catch
(
e
)
{
ok
(
false
"
unexpected
error
while
resolving
this
URI
:
"
+
url
)
;
}
}
}
}
)
;
}
function
parseCodeFile
(
fileUri
)
{
return
fetchFile
(
fileUri
.
spec
)
.
then
(
data
=
>
{
let
baseUri
;
for
(
let
line
of
data
.
split
(
"
\
n
"
)
)
{
let
urls
=
line
.
match
(
/
[
"
'
]
chrome
:
\
/
\
/
[
a
-
zA
-
Z0
-
9
-
]
+
\
/
(
content
|
skin
|
locale
)
\
/
[
^
"
'
]
*
[
"
'
]
/
g
)
;
if
(
!
urls
)
{
urls
=
line
.
match
(
/
[
"
'
]
resource
:
\
/
\
/
[
^
"
'
]
+
[
"
'
]
/
g
)
;
if
(
urls
&
&
isDevtools
&
&
/
baseURI
:
"
resource
:
\
/
\
/
devtools
\
/
/
.
test
(
line
)
)
{
baseUri
=
Services
.
io
.
newURI
(
urls
[
0
]
.
slice
(
1
-
1
)
)
;
continue
;
}
}
if
(
!
urls
)
{
urls
=
line
.
match
(
/
[
a
-
z0
-
9_
\
/
-
]
+
\
.
ftl
/
i
)
;
if
(
urls
)
{
urls
=
urls
[
0
]
;
let
grePrefix
=
Services
.
io
.
newURI
(
"
resource
:
/
/
gre
/
localization
/
en
-
US
/
"
)
;
let
appPrefix
=
Services
.
io
.
newURI
(
"
resource
:
/
/
app
/
localization
/
en
-
US
/
"
)
;
let
grePrefixUrl
=
Services
.
io
.
newURI
(
urls
null
grePrefix
)
.
spec
;
let
appPrefixUrl
=
Services
.
io
.
newURI
(
urls
null
appPrefix
)
.
spec
;
addCodeReference
(
grePrefixUrl
fileUri
)
;
addCodeReference
(
appPrefixUrl
fileUri
)
;
continue
;
}
}
if
(
!
urls
)
{
let
match
=
line
.
match
(
"
(
?
:
src
|
href
)
=
[
\
"
'
]
(
[
^
&
\
"
'
]
+
)
"
)
;
if
(
match
&
&
match
[
1
]
)
{
let
url
=
Services
.
io
.
newURI
(
match
[
1
]
null
fileUri
)
.
spec
;
addCodeReference
(
convertToCodeURI
(
url
)
fileUri
)
;
}
match
=
line
.
match
(
/
from
\
W
*
[
'
"
]
(
.
*
?
)
[
'
"
]
/
)
;
if
(
match
?
.
[
1
]
)
{
let
url
=
match
[
1
]
;
url
=
Services
.
io
.
newURI
(
url
null
baseUri
|
|
fileUri
)
.
spec
;
url
=
convertToCodeURI
(
url
)
;
addCodeReference
(
url
fileUri
)
;
}
if
(
isDevtools
)
{
let
rules
=
[
[
"
devtools
/
client
/
locales
"
"
chrome
:
/
/
devtools
/
locale
"
]
[
"
devtools
/
shared
/
locales
"
"
chrome
:
/
/
devtools
-
shared
/
locale
"
]
[
"
devtools
/
shared
/
platform
"
"
resource
:
/
/
devtools
/
shared
/
platform
/
chrome
"
]
[
"
devtools
"
"
resource
:
/
/
devtools
"
]
]
;
match
=
line
.
match
(
/
[
"
'
]
(
(
?
:
devtools
)
\
/
[
^
\
\
#
"
'
]
+
)
[
"
'
]
/
)
;
if
(
match
&
&
match
[
1
]
)
{
let
path
=
match
[
1
]
;
for
(
let
rule
of
rules
)
{
if
(
path
.
startsWith
(
rule
[
0
]
+
"
/
"
)
)
{
path
=
path
.
replace
(
rule
[
0
]
rule
[
1
]
)
;
if
(
!
/
\
.
(
properties
|
js
|
jsm
|
mjs
|
json
|
css
)
/
.
test
(
path
)
)
{
path
+
=
"
.
js
"
;
}
addCodeReference
(
path
fileUri
)
;
break
;
}
}
}
match
=
line
.
match
(
/
require
\
(
[
'
"
]
(
\
.
[
^
'
"
]
+
)
[
'
"
]
\
)
/
)
;
if
(
match
&
&
match
[
1
]
)
{
let
url
=
match
[
1
]
;
url
=
Services
.
io
.
newURI
(
url
null
baseUri
|
|
fileUri
)
.
spec
;
url
=
convertToCodeURI
(
url
)
;
if
(
!
/
\
.
(
properties
|
js
|
jsm
|
mjs
|
json
|
css
)
/
.
test
(
url
)
)
{
url
+
=
"
.
js
"
;
}
if
(
url
.
startsWith
(
"
resource
:
/
/
"
)
)
{
addCodeReference
(
url
fileUri
)
;
}
else
{
}
}
}
continue
;
}
for
(
let
url
of
urls
)
{
url
=
url
.
slice
(
1
-
1
)
;
if
(
url
.
endsWith
(
"
\
\
"
)
)
{
url
=
url
.
slice
(
0
-
1
)
;
}
let
pos
=
url
.
indexOf
(
"
?
"
)
;
if
(
pos
!
=
-
1
)
{
url
=
url
.
slice
(
0
pos
)
;
}
try
{
url
=
Services
.
io
.
newURI
(
url
)
.
specIgnoringRef
;
}
catch
(
e
)
{
continue
;
}
if
(
isDevtools
&
&
line
.
includes
(
"
require
(
"
)
&
&
!
/
\
.
(
properties
|
js
|
jsm
|
mjs
|
json
|
css
)
/
.
test
(
url
)
)
{
url
+
=
"
.
js
"
;
}
addCodeReference
(
url
fileUri
)
;
}
}
}
)
;
}
function
convertToCodeURI
(
fileUri
)
{
let
baseUri
=
fileUri
;
let
path
=
"
"
;
while
(
true
)
{
let
slashPos
=
baseUri
.
lastIndexOf
(
"
/
"
baseUri
.
length
-
2
)
;
if
(
slashPos
<
=
0
)
{
for
(
let
res
of
gResourceMap
)
{
if
(
fileUri
.
startsWith
(
res
[
1
]
)
)
{
return
fileUri
.
replace
(
res
[
1
]
"
resource
:
/
/
"
+
res
[
0
]
+
"
/
"
)
;
}
}
return
fileUri
;
}
path
=
baseUri
.
slice
(
slashPos
+
1
)
+
path
;
baseUri
=
baseUri
.
slice
(
0
slashPos
+
1
)
;
if
(
gChromeMap
.
has
(
baseUri
)
)
{
return
gChromeMap
.
get
(
baseUri
)
+
path
;
}
}
}
async
function
chromeFileExists
(
aURI
)
{
try
{
return
await
PerfTestHelpers
.
checkURIExists
(
aURI
)
;
}
catch
(
e
)
{
todo
(
false
Failed
to
check
if
{
aURI
}
exists
:
{
e
}
)
;
return
false
;
}
}
function
findChromeUrlsFromArray
(
array
prefix
)
{
for
(
let
index
=
0
;
(
index
=
array
.
indexOf
(
prefix
.
charCodeAt
(
0
)
index
)
)
!
=
-
1
;
+
+
index
)
{
let
found
=
true
;
for
(
let
i
=
1
;
i
<
prefix
.
length
;
+
+
i
)
{
if
(
array
[
index
+
i
]
!
=
prefix
.
charCodeAt
(
i
)
)
{
found
=
false
;
break
;
}
}
if
(
!
found
)
{
continue
;
}
let
end
=
Math
.
min
(
array
.
indexOf
(
0
index
)
array
.
indexOf
(
'
"
'
.
charCodeAt
(
0
)
index
)
array
.
indexOf
(
"
)
"
.
charCodeAt
(
0
)
index
)
array
.
indexOf
(
"
#
"
.
charCodeAt
(
0
)
index
)
)
;
let
string
=
"
"
;
for
(
;
index
<
end
;
+
+
index
)
{
string
+
=
String
.
fromCharCode
(
array
[
index
]
)
;
}
if
(
/
chrome
:
\
/
\
/
[
a
-
zA
-
Z09
-
]
+
\
/
(
content
|
skin
|
locale
)
\
/
/
.
test
(
string
)
|
|
/
resource
:
\
/
\
/
[
a
-
zA
-
Z09
-
]
*
\
/
.
*
\
.
[
a
-
z
]
+
/
.
test
(
string
)
)
{
gReferencesFromCode
.
set
(
string
null
)
;
}
}
}
add_task
(
async
function
checkAllTheFiles
(
)
{
const
libxul
=
await
IOUtils
.
read
(
PathUtils
.
xulLibraryPath
)
;
findChromeUrlsFromArray
(
libxul
"
chrome
:
/
/
"
)
;
findChromeUrlsFromArray
(
libxul
"
resource
:
/
/
"
)
;
let
uint16
=
new
Uint16Array
(
libxul
.
buffer
)
;
findChromeUrlsFromArray
(
uint16
"
chrome
:
/
/
"
)
;
findChromeUrlsFromArray
(
uint16
"
resource
:
/
/
"
)
;
const
kCodeExtensions
=
[
"
.
xml
"
"
.
xsl
"
"
.
mjs
"
"
.
js
"
"
.
jsm
"
"
.
json
"
"
.
html
"
"
.
xhtml
"
]
;
let
appDir
=
Services
.
dirsvc
.
get
(
"
GreD
"
Ci
.
nsIFile
)
;
let
uris
=
await
generateURIsFromDirTree
(
appDir
[
"
.
css
"
"
.
manifest
"
"
.
jpg
"
"
.
png
"
"
.
gif
"
"
.
svg
"
"
.
ftl
"
"
.
dtd
"
"
.
properties
"
]
.
concat
(
kCodeExtensions
)
)
;
let
manifestURIs
=
[
]
;
let
jsonManifests
=
[
]
;
uris
=
uris
.
filter
(
uri
=
>
{
let
path
=
uri
.
pathQueryRef
;
if
(
path
.
endsWith
(
"
.
manifest
"
)
)
{
manifestURIs
.
push
(
uri
)
;
return
false
;
}
else
if
(
path
.
endsWith
(
"
/
manifest
.
json
"
)
)
{
jsonManifests
.
push
(
uri
)
;
return
false
;
}
return
true
;
}
)
;
await
PerfTestHelpers
.
throttledMapPromises
(
manifestURIs
parseManifest
)
;
for
(
let
jsm
of
Components
.
manager
.
getComponentJSMs
(
)
)
{
gReferencesFromCode
.
set
(
jsm
null
)
;
}
for
(
let
esModule
of
Components
.
manager
.
getComponentESModules
(
)
)
{
gReferencesFromCode
.
set
(
esModule
null
)
;
}
let
nonWebextManifests
=
(
await
Promise
.
all
(
jsonManifests
.
map
(
parseJsonManifest
)
)
)
.
filter
(
uri
=
>
!
!
uri
)
;
uris
.
push
(
.
.
.
nonWebextManifests
)
;
let
allPromises
=
[
]
;
for
(
let
uri
of
uris
)
{
let
path
=
uri
.
pathQueryRef
;
if
(
path
.
endsWith
(
"
.
css
"
)
)
{
allPromises
.
push
(
[
parseCSSFile
uri
]
)
;
}
else
if
(
kCodeExtensions
.
some
(
ext
=
>
path
.
endsWith
(
ext
)
)
)
{
allPromises
.
push
(
[
parseCodeFile
uri
]
)
;
}
}
await
PerfTestHelpers
.
throttledMapPromises
(
allPromises
(
[
task
uri
]
)
=
>
task
(
uri
)
)
;
let
devtoolsPrefixes
=
[
"
chrome
:
/
/
devtools
"
"
resource
:
/
/
devtools
/
"
"
resource
:
/
/
devtools
-
client
-
jsonview
/
"
"
resource
:
/
/
devtools
-
client
-
shared
/
"
"
resource
:
/
/
app
/
modules
/
devtools
"
"
resource
:
/
/
gre
/
modules
/
devtools
"
"
resource
:
/
/
app
/
localization
/
en
-
US
/
startup
/
aboutDevTools
.
ftl
"
"
resource
:
/
/
app
/
localization
/
en
-
US
/
devtools
/
"
]
;
let
hasDevtoolsPrefix
=
uri
=
>
devtoolsPrefixes
.
some
(
prefix
=
>
uri
.
startsWith
(
prefix
)
)
;
let
chromeFiles
=
[
]
;
for
(
let
uri
of
uris
)
{
uri
=
convertToCodeURI
(
uri
.
spec
)
;
if
(
(
uri
.
startsWith
(
"
chrome
:
/
/
"
)
|
|
uri
.
startsWith
(
"
resource
:
/
/
"
)
)
&
&
isDevtools
=
=
hasDevtoolsPrefix
(
uri
)
)
{
chromeFiles
.
push
(
uri
)
;
}
}
if
(
isDevtools
)
{
gReferencesFromCode
.
set
(
AppConstants
.
BROWSER_CHROME_URL
null
)
;
gReferencesFromCode
.
set
(
"
chrome
:
/
/
browser
/
skin
/
browser
.
css
"
null
)
;
}
let
isUnreferenced
=
file
=
>
{
if
(
gExceptionPaths
.
some
(
e
=
>
file
.
startsWith
(
e
)
)
)
{
return
false
;
}
if
(
gReferencesFromCode
.
has
(
file
)
)
{
let
refs
=
gReferencesFromCode
.
get
(
file
)
;
if
(
refs
=
=
=
null
)
{
return
false
;
}
for
(
let
ref
of
refs
)
{
if
(
isDevtools
)
{
if
(
ref
.
startsWith
(
"
resource
:
/
/
app
/
components
/
"
)
|
|
(
file
.
startsWith
(
"
chrome
:
/
/
"
)
&
&
ref
.
startsWith
(
"
resource
:
/
/
"
)
)
)
{
return
false
;
}
}
if
(
gReferencesFromCode
.
has
(
ref
)
)
{
let
refType
=
gReferencesFromCode
.
get
(
ref
)
;
if
(
refType
=
=
=
null
|
|
refType
=
=
"
whitelist
"
|
|
refType
=
=
"
whitelist
-
direct
"
)
{
return
false
;
}
}
}
}
return
!
gOverrideMap
.
has
(
file
)
|
|
isUnreferenced
(
gOverrideMap
.
get
(
file
)
)
;
}
;
let
unreferencedFiles
=
chromeFiles
;
let
removeReferenced
=
useWhitelist
=
>
{
let
foundReference
=
false
;
unreferencedFiles
=
unreferencedFiles
.
filter
(
f
=
>
{
let
rv
=
isUnreferenced
(
f
)
;
if
(
rv
&
&
f
.
startsWith
(
"
resource
:
/
/
app
/
"
)
)
{
rv
=
isUnreferenced
(
f
.
replace
(
"
resource
:
/
/
app
/
"
"
resource
:
/
/
/
"
)
)
;
}
if
(
rv
&
&
/
^
resource
:
\
/
\
/
(
?
:
app
|
gre
)
\
/
components
\
/
[
^
/
]
+
\
.
js
/
.
test
(
f
)
)
{
rv
=
!
gComponentsSet
.
has
(
f
.
replace
(
/
.
*
\
/
/
"
"
)
)
;
}
if
(
!
rv
)
{
foundReference
=
true
;
if
(
useWhitelist
)
{
info
(
"
indirectly
whitelisted
file
:
"
+
f
+
"
used
from
"
+
listCodeReferences
(
gReferencesFromCode
.
get
(
f
)
)
)
;
}
gReferencesFromCode
.
set
(
f
useWhitelist
?
"
whitelist
"
:
null
)
;
}
return
rv
;
}
)
;
return
foundReference
;
}
;
while
(
removeReferenced
(
false
)
)
{
}
unreferencedFiles
=
unreferencedFiles
.
filter
(
file
=
>
{
if
(
whitelist
.
has
(
file
)
)
{
whitelist
.
delete
(
file
)
;
gReferencesFromCode
.
set
(
file
"
whitelist
-
direct
"
)
;
return
false
;
}
return
true
;
}
)
;
while
(
removeReferenced
(
true
)
)
{
}
unreferencedFiles
.
sort
(
)
;
if
(
isDevtools
)
{
unreferencedFiles
=
unreferencedFiles
.
filter
(
file
=
>
{
if
(
file
.
startsWith
(
"
resource
:
/
/
"
)
)
{
info
(
"
unreferenced
devtools
resource
file
:
"
+
file
)
;
return
false
;
}
return
true
;
}
)
;
}
is
(
unreferencedFiles
.
length
0
"
there
should
be
no
unreferenced
files
"
)
;
for
(
let
file
of
unreferencedFiles
)
{
let
refs
=
gReferencesFromCode
.
get
(
file
)
;
if
(
refs
=
=
=
undefined
)
{
ok
(
false
"
unreferenced
file
:
"
+
file
)
;
}
else
{
let
refList
=
listCodeReferences
(
refs
)
;
let
msg
=
"
file
only
referenced
from
unreferenced
files
:
"
+
file
;
if
(
refList
)
{
msg
+
=
"
referenced
from
"
+
refList
;
}
ok
(
false
msg
)
;
}
}
for
(
let
file
of
whitelist
)
{
if
(
ignorableWhitelist
.
has
(
file
)
)
{
info
(
"
ignored
unused
whitelist
entry
:
"
+
file
)
;
}
else
{
ok
(
false
"
unused
whitelist
entry
:
"
+
file
)
;
}
}
for
(
let
[
file
refs
]
of
gReferencesFromCode
)
{
if
(
isDevtools
!
=
devtoolsPrefixes
.
some
(
prefix
=
>
file
.
startsWith
(
prefix
)
)
)
{
continue
;
}
if
(
(
file
.
startsWith
(
"
chrome
:
/
/
"
)
|
|
file
.
startsWith
(
"
resource
:
/
/
"
)
)
&
&
!
(
await
chromeFileExists
(
file
)
)
)
{
let
pathParts
=
file
.
match
(
"
chrome
:
/
/
(
[
^
/
]
+
)
/
content
/
(
[
^
/
.
]
+
)
.
xul
"
)
|
|
file
.
match
(
"
chrome
:
/
/
(
[
^
/
]
+
)
/
skin
/
(
[
^
/
.
]
+
)
.
css
"
)
;
if
(
pathParts
&
&
pathParts
[
1
]
=
=
pathParts
[
2
]
)
{
continue
;
}
let
refList
=
listCodeReferences
(
refs
)
;
let
msg
=
"
missing
file
:
"
+
file
;
if
(
refList
)
{
msg
+
=
"
referenced
from
"
+
refList
;
}
info
(
msg
)
;
}
}
}
)
;
