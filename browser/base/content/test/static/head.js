"
use
strict
"
;
const
LocalFile
=
new
Components
.
Constructor
(
"
mozilla
.
org
/
file
/
local
;
1
"
Ci
.
nsIFile
"
initWithPath
"
)
;
const
ZipReader
=
new
Components
.
Constructor
(
"
mozilla
.
org
/
libjar
/
zip
-
reader
;
1
"
"
nsIZipReader
"
"
open
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
function
generateURIsFromDirTree
(
dir
extensions
)
{
if
(
!
Array
.
isArray
(
extensions
)
)
{
extensions
=
[
extensions
]
;
}
let
dirQueue
=
[
dir
.
path
]
;
return
(
async
function
(
)
{
let
rv
=
[
]
;
while
(
dirQueue
.
length
)
{
let
nextDir
=
dirQueue
.
shift
(
)
;
let
{
subdirs
files
}
=
await
iterateOverPath
(
nextDir
extensions
)
;
dirQueue
.
push
(
.
.
.
subdirs
)
;
rv
.
push
(
.
.
.
files
)
;
}
return
rv
;
}
)
(
)
;
}
function
iterateOverPath
(
path
extensions
)
{
let
iterator
=
new
OS
.
File
.
DirectoryIterator
(
path
)
;
let
parentDir
=
new
LocalFile
(
path
)
;
let
subdirs
=
[
]
;
let
files
=
[
]
;
let
pathEntryIterator
=
(
entry
)
=
>
{
if
(
entry
.
isDir
)
{
subdirs
.
push
(
entry
.
path
)
;
}
else
if
(
extensions
.
some
(
(
extension
)
=
>
entry
.
name
.
endsWith
(
extension
)
)
)
{
let
file
=
parentDir
.
clone
(
)
;
file
.
append
(
entry
.
name
)
;
if
(
file
.
exists
(
)
)
{
let
uriSpec
=
getURLForFile
(
file
)
;
files
.
push
(
Services
.
io
.
newURI
(
uriSpec
)
)
;
}
}
else
if
(
entry
.
name
.
endsWith
(
"
.
ja
"
)
|
|
entry
.
name
.
endsWith
(
"
.
jar
"
)
|
|
entry
.
name
.
endsWith
(
"
.
zip
"
)
|
|
entry
.
name
.
endsWith
(
"
.
xpi
"
)
)
{
let
file
=
parentDir
.
clone
(
)
;
file
.
append
(
entry
.
name
)
;
for
(
let
extension
of
extensions
)
{
let
jarEntryIterator
=
generateEntriesFromJarFile
(
file
extension
)
;
files
.
push
(
.
.
.
jarEntryIterator
)
;
}
}
}
;
return
new
Promise
(
(
resolve
reject
)
=
>
{
(
async
function
(
)
{
try
{
await
iterator
.
forEach
(
pathEntryIterator
)
;
resolve
(
{
files
subdirs
}
)
;
}
catch
(
ex
)
{
reject
(
ex
)
;
}
finally
{
iterator
.
close
(
)
;
}
}
)
(
)
;
}
)
;
}
function
getURLForFile
(
file
)
{
let
fileHandler
=
Services
.
io
.
getProtocolHandler
(
"
file
"
)
;
fileHandler
=
fileHandler
.
QueryInterface
(
Ci
.
nsIFileProtocolHandler
)
;
return
fileHandler
.
getURLSpecFromActualFile
(
file
)
;
}
function
*
generateEntriesFromJarFile
(
jarFile
extension
)
{
let
zr
=
new
ZipReader
(
jarFile
)
;
let
entryEnumerator
=
zr
.
findEntries
(
"
*
"
+
extension
+
"
"
)
;
const
kURIStart
=
getURLForFile
(
jarFile
)
;
while
(
entryEnumerator
.
hasMore
(
)
)
{
let
entry
=
entryEnumerator
.
getNext
(
)
;
if
(
entry
.
startsWith
(
"
jsloader
"
)
|
|
entry
.
startsWith
(
"
jssubloader
"
)
)
{
continue
;
}
let
entryURISpec
=
"
jar
:
"
+
kURIStart
+
"
!
/
"
+
entry
;
yield
Services
.
io
.
newURI
(
entryURISpec
)
;
}
zr
.
close
(
)
;
}
function
fetchFile
(
uri
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
xhr
=
new
XMLHttpRequest
(
)
;
xhr
.
responseType
=
"
text
"
;
xhr
.
open
(
"
GET
"
uri
true
)
;
xhr
.
onreadystatechange
=
function
(
)
{
if
(
this
.
readyState
!
=
this
.
DONE
)
{
return
;
}
try
{
resolve
(
this
.
responseText
)
;
}
catch
(
ex
)
{
ok
(
false
Script
error
reading
{
uri
}
:
{
ex
}
)
;
resolve
(
"
"
)
;
}
}
;
xhr
.
onerror
=
error
=
>
{
ok
(
false
XHR
error
reading
{
uri
}
:
{
error
}
)
;
resolve
(
"
"
)
;
}
;
xhr
.
send
(
null
)
;
}
)
;
}
