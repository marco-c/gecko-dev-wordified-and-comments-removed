"
use
strict
"
;
const
LocalFile
=
new
Components
.
Constructor
(
"
mozilla
.
org
/
file
/
local
;
1
"
Ci
.
nsIFile
"
initWithPath
"
)
;
const
ZipReader
=
new
Components
.
Constructor
(
"
mozilla
.
org
/
libjar
/
zip
-
reader
;
1
"
"
nsIZipReader
"
"
open
"
)
;
const
IS_ALPHA
=
/
^
[
a
-
z
]
+
/
i
;
var
{
PerfTestHelpers
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
PerfTestHelpers
.
sys
.
mjs
"
)
;
const
kESModuleList
=
new
Set
(
[
/
browser
\
/
lockwise
-
card
.
js
/
/
browser
\
/
monitor
-
card
.
js
/
/
browser
\
/
proxy
-
card
.
js
/
/
browser
\
/
vpn
-
card
.
js
/
/
toolkit
\
/
content
\
/
global
\
/
certviewer
\
/
components
\
/
.
*
\
.
js
/
/
toolkit
\
/
content
\
/
global
\
/
certviewer
\
/
.
*
\
.
js
/
/
toolkit
\
/
content
\
/
global
\
/
ml
\
/
transformers
.
*
\
.
js
/
/
chrome
\
/
pdfjs
\
/
content
\
/
web
\
/
.
*
\
.
js
/
]
)
;
function
uriIsESModule
(
uri
)
{
if
(
uri
.
filePath
.
endsWith
(
"
.
mjs
"
)
)
{
return
true
;
}
for
(
let
allowlistItem
of
kESModuleList
)
{
if
(
allowlistItem
.
test
(
uri
.
spec
)
)
{
return
true
;
}
}
return
false
;
}
function
generateURIsFromDirTree
(
dir
extensions
)
{
if
(
!
Array
.
isArray
(
extensions
)
)
{
extensions
=
[
extensions
]
;
}
let
dirQueue
=
[
dir
.
path
]
;
return
(
async
function
(
)
{
let
rv
=
[
]
;
while
(
dirQueue
.
length
)
{
let
nextDir
=
dirQueue
.
shift
(
)
;
let
{
subdirs
files
}
=
await
iterateOverPath
(
nextDir
extensions
)
;
dirQueue
.
push
(
.
.
.
subdirs
)
;
rv
.
push
(
.
.
.
files
)
;
}
return
rv
;
}
)
(
)
;
}
async
function
iterateOverPath
(
path
extensions
)
{
const
children
=
await
IOUtils
.
getChildren
(
path
)
;
const
files
=
[
]
;
const
subdirs
=
[
]
;
for
(
const
entry
of
children
)
{
let
stat
;
try
{
stat
=
await
IOUtils
.
stat
(
entry
)
;
}
catch
(
error
)
{
if
(
error
.
name
=
=
=
"
NotFoundError
"
)
{
continue
;
}
throw
error
;
}
if
(
stat
.
type
=
=
=
"
directory
"
)
{
subdirs
.
push
(
entry
)
;
}
else
if
(
extensions
.
some
(
extension
=
>
entry
.
endsWith
(
extension
)
)
)
{
if
(
await
IOUtils
.
exists
(
entry
)
)
{
const
spec
=
PathUtils
.
toFileURI
(
entry
)
;
files
.
push
(
Services
.
io
.
newURI
(
spec
)
)
;
}
}
else
if
(
entry
.
endsWith
(
"
.
ja
"
)
|
|
entry
.
endsWith
(
"
.
jar
"
)
|
|
entry
.
endsWith
(
"
.
zip
"
)
|
|
entry
.
endsWith
(
"
.
xpi
"
)
)
{
const
file
=
new
LocalFile
(
entry
)
;
for
(
const
extension
of
extensions
)
{
files
.
push
(
.
.
.
generateEntriesFromJarFile
(
file
extension
)
)
;
}
}
}
return
{
files
subdirs
}
;
}
function
getURLForFile
(
file
)
{
let
fileHandler
=
Services
.
io
.
getProtocolHandler
(
"
file
"
)
;
fileHandler
=
fileHandler
.
QueryInterface
(
Ci
.
nsIFileProtocolHandler
)
;
return
fileHandler
.
getURLSpecFromActualFile
(
file
)
;
}
function
*
generateEntriesFromJarFile
(
jarFile
extension
)
{
let
zr
=
new
ZipReader
(
jarFile
)
;
const
kURIStart
=
getURLForFile
(
jarFile
)
;
for
(
let
entry
of
zr
.
findEntries
(
"
*
"
+
extension
+
"
"
)
)
{
if
(
entry
.
startsWith
(
"
jsloader
"
)
|
|
entry
.
startsWith
(
"
jssubloader
"
)
)
{
continue
;
}
let
entryURISpec
=
"
jar
:
"
+
kURIStart
+
"
!
/
"
+
entry
;
yield
Services
.
io
.
newURI
(
entryURISpec
)
;
}
zr
.
close
(
)
;
}
function
fetchFile
(
uri
)
{
return
new
Promise
(
resolve
=
>
{
let
xhr
=
new
XMLHttpRequest
(
)
;
xhr
.
responseType
=
"
text
"
;
xhr
.
open
(
"
GET
"
uri
true
)
;
xhr
.
onreadystatechange
=
function
(
)
{
if
(
this
.
readyState
!
=
this
.
DONE
)
{
return
;
}
try
{
resolve
(
this
.
responseText
)
;
}
catch
(
ex
)
{
ok
(
false
Script
error
reading
{
uri
}
:
{
ex
}
)
;
resolve
(
"
"
)
;
}
}
;
xhr
.
onerror
=
error
=
>
{
ok
(
false
XHR
error
reading
{
uri
}
:
{
error
}
)
;
resolve
(
"
"
)
;
}
;
xhr
.
send
(
null
)
;
}
)
;
}
function
hasExpectedCapitalization
(
word
expectCapitalized
)
{
let
firstChar
=
word
[
0
]
;
if
(
!
IS_ALPHA
.
test
(
firstChar
)
)
{
return
true
;
}
let
isCapitalized
=
firstChar
=
=
firstChar
.
toLocaleUpperCase
(
"
en
-
US
"
)
;
return
isCapitalized
=
=
expectCapitalized
;
}
