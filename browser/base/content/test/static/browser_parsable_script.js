const
kWhitelist
=
new
Set
(
[
/
browser
\
/
content
\
/
browser
\
/
places
\
/
controller
.
js
/
]
)
;
const
init
=
Cc
[
"
mozilla
.
org
/
jsreflect
;
1
"
]
.
createInstance
(
)
;
init
(
)
;
function
uriIsWhiteListed
(
uri
)
{
for
(
let
whitelistItem
of
kWhitelist
)
{
if
(
whitelistItem
.
test
(
uri
.
spec
)
)
{
return
true
;
}
}
return
false
;
}
function
parsePromise
(
uri
)
{
let
promise
=
new
Promise
(
(
resolve
reject
)
=
>
{
let
xhr
=
new
XMLHttpRequest
(
)
;
xhr
.
open
(
"
GET
"
uri
true
)
;
xhr
.
onreadystatechange
=
function
(
)
{
if
(
this
.
readyState
=
=
this
.
DONE
)
{
let
scriptText
=
this
.
responseText
;
try
{
info
(
"
Checking
"
+
uri
)
;
Reflect
.
parse
(
scriptText
{
source
:
uri
}
)
;
resolve
(
true
)
;
}
catch
(
ex
)
{
let
errorMsg
=
"
Script
error
reading
"
+
uri
+
"
:
"
+
ex
;
ok
(
false
errorMsg
)
;
resolve
(
false
)
;
}
}
}
;
xhr
.
onerror
=
(
error
)
=
>
{
ok
(
false
"
XHR
error
reading
"
+
uri
+
"
:
"
+
error
)
;
resolve
(
false
)
;
}
;
xhr
.
overrideMimeType
(
"
application
/
javascript
"
)
;
xhr
.
send
(
null
)
;
}
)
;
return
promise
;
}
add_task
(
async
function
checkAllTheJS
(
)
{
let
parseRequested
=
Services
.
prefs
.
prefHasUserValue
(
"
parse
"
)
;
let
parseValue
=
parseRequested
&
&
Services
.
prefs
.
getCharPref
(
"
parse
"
)
;
if
(
SpecialPowers
.
isDebugBuild
)
{
if
(
!
parseRequested
)
{
ok
(
true
"
Test
disabled
on
debug
build
.
To
run
execute
:
.
/
mach
"
+
"
mochitest
-
browser
-
-
setpref
parse
=
<
case_sensitive_filter
>
"
+
"
browser
/
base
/
content
/
test
/
general
/
browser_parsable_script
.
js
"
)
;
return
;
}
requestLongerTimeout
(
30
)
;
}
let
uris
;
if
(
parseValue
&
&
parseValue
.
includes
(
"
:
"
)
)
{
uris
=
[
NetUtil
.
newURI
(
parseValue
)
]
;
}
else
{
let
appDir
=
Services
.
dirsvc
.
get
(
"
GreD
"
Ci
.
nsIFile
)
;
let
startTimeMs
=
Date
.
now
(
)
;
info
(
"
Collecting
URIs
"
)
;
uris
=
await
generateURIsFromDirTree
(
appDir
[
"
.
js
"
"
.
jsm
"
]
)
;
info
(
"
Collected
URIs
in
"
+
(
Date
.
now
(
)
-
startTimeMs
)
+
"
ms
"
)
;
if
(
parseValue
)
{
uris
=
uris
.
filter
(
uri
=
>
{
if
(
uri
.
spec
.
includes
(
parseValue
)
)
{
return
true
;
}
info
(
"
Not
checking
filtered
out
"
+
uri
.
spec
)
;
return
false
;
}
)
;
}
}
let
allPromises
=
[
]
;
for
(
let
uri
of
uris
)
{
if
(
uriIsWhiteListed
(
uri
)
)
{
info
(
"
Not
checking
whitelisted
"
+
uri
.
spec
)
;
continue
;
}
allPromises
.
push
(
parsePromise
(
uri
.
spec
)
)
;
}
let
promiseResults
=
await
Promise
.
all
(
allPromises
)
;
is
(
promiseResults
.
filter
(
(
x
)
=
>
!
x
)
.
length
0
"
There
should
be
0
parsing
errors
"
)
;
}
)
;
