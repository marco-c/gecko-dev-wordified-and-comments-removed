requestLongerTimeout
(
2
)
;
const
kWhitelist
=
new
Set
(
[
/
browser
\
/
content
\
/
browser
\
/
places
\
/
controller
.
js
/
]
)
;
const
kESModuleList
=
new
Set
(
[
/
browser
\
/
aboutlogins
\
/
components
\
/
.
*
\
.
js
/
/
browser
\
/
aboutlogins
\
/
.
*
\
.
js
/
/
browser
\
/
protections
.
js
/
/
browser
\
/
lockwise
-
card
.
js
/
/
browser
\
/
monitor
-
card
.
js
/
/
browser
\
/
proxy
-
card
.
js
/
/
browser
\
/
vpn
-
card
.
js
/
/
browser
\
/
content
\
/
browser
\
/
certerror
\
/
aboutNetError
\
.
js
/
/
browser
\
/
content
\
/
browser
\
/
myfirefox
\
.
js
/
/
browser
\
/
content
\
/
browser
\
/
tabs
-
pickup
\
.
js
/
/
toolkit
\
/
content
\
/
global
\
/
certviewer
\
/
components
\
/
.
*
\
.
js
/
/
toolkit
\
/
content
\
/
global
\
/
certviewer
\
/
.
*
\
.
js
/
/
chrome
\
/
pdfjs
\
/
content
\
/
web
\
/
.
*
\
.
js
/
]
)
;
const
init
=
Cc
[
"
mozilla
.
org
/
jsreflect
;
1
"
]
.
createInstance
(
)
;
init
(
)
;
function
uriIsWhiteListed
(
uri
)
{
for
(
let
whitelistItem
of
kWhitelist
)
{
if
(
whitelistItem
.
test
(
uri
.
spec
)
)
{
return
true
;
}
}
return
false
;
}
function
uriIsESModule
(
uri
)
{
for
(
let
whitelistItem
of
kESModuleList
)
{
if
(
whitelistItem
.
test
(
uri
.
spec
)
)
{
return
true
;
}
}
return
false
;
}
function
parsePromise
(
uri
parseTarget
)
{
let
promise
=
new
Promise
(
(
resolve
reject
)
=
>
{
let
xhr
=
new
XMLHttpRequest
(
)
;
xhr
.
open
(
"
GET
"
uri
true
)
;
xhr
.
onreadystatechange
=
function
(
)
{
if
(
this
.
readyState
=
=
this
.
DONE
)
{
let
scriptText
=
this
.
responseText
;
try
{
info
(
Checking
{
parseTarget
}
{
uri
}
)
;
let
parseOpts
=
{
source
:
uri
target
:
parseTarget
}
;
Reflect
.
parse
(
scriptText
parseOpts
)
;
resolve
(
true
)
;
}
catch
(
ex
)
{
let
errorMsg
=
"
Script
error
reading
"
+
uri
+
"
:
"
+
ex
;
ok
(
false
errorMsg
)
;
resolve
(
false
)
;
}
}
}
;
xhr
.
onerror
=
error
=
>
{
ok
(
false
"
XHR
error
reading
"
+
uri
+
"
:
"
+
error
)
;
resolve
(
false
)
;
}
;
xhr
.
overrideMimeType
(
"
application
/
javascript
"
)
;
xhr
.
send
(
null
)
;
}
)
;
return
promise
;
}
add_task
(
async
function
checkAllTheJS
(
)
{
let
parseRequested
=
Services
.
prefs
.
prefHasUserValue
(
"
parse
"
)
;
let
parseValue
=
parseRequested
&
&
Services
.
prefs
.
getCharPref
(
"
parse
"
)
;
if
(
SpecialPowers
.
isDebugBuild
)
{
if
(
!
parseRequested
)
{
ok
(
true
"
Test
disabled
on
debug
build
.
To
run
execute
:
.
/
mach
"
+
"
mochitest
-
browser
-
-
setpref
parse
=
<
case_sensitive_filter
>
"
+
"
browser
/
base
/
content
/
test
/
general
/
browser_parsable_script
.
js
"
)
;
return
;
}
requestLongerTimeout
(
30
)
;
}
let
uris
;
if
(
parseValue
&
&
parseValue
.
includes
(
"
:
"
)
)
{
uris
=
[
NetUtil
.
newURI
(
parseValue
)
]
;
}
else
{
let
appDir
=
Services
.
dirsvc
.
get
(
"
GreD
"
Ci
.
nsIFile
)
;
let
startTimeMs
=
Date
.
now
(
)
;
info
(
"
Collecting
URIs
"
)
;
uris
=
await
generateURIsFromDirTree
(
appDir
[
"
.
js
"
"
.
jsm
"
]
)
;
info
(
"
Collected
URIs
in
"
+
(
Date
.
now
(
)
-
startTimeMs
)
+
"
ms
"
)
;
if
(
parseValue
)
{
uris
=
uris
.
filter
(
uri
=
>
{
if
(
uri
.
spec
.
includes
(
parseValue
)
)
{
return
true
;
}
info
(
"
Not
checking
filtered
out
"
+
uri
.
spec
)
;
return
false
;
}
)
;
}
}
await
throttledMapPromises
(
uris
uri
=
>
{
if
(
uriIsWhiteListed
(
uri
)
)
{
info
(
"
Not
checking
whitelisted
"
+
uri
.
spec
)
;
return
undefined
;
}
let
target
=
"
script
"
;
if
(
uriIsESModule
(
uri
)
)
{
target
=
"
module
"
;
}
return
parsePromise
(
uri
.
spec
target
)
;
}
)
;
ok
(
true
"
All
files
parsed
"
)
;
}
)
;
