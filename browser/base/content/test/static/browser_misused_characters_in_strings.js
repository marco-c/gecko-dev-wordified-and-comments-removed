let
gWhitelist
=
[
{
file
:
"
search
.
properties
"
key
:
"
searchForSomethingWith
"
type
:
"
single
-
quote
"
}
{
file
:
"
netError
.
dtd
"
key
:
"
certerror
.
introPara
"
type
:
"
single
-
quote
"
}
{
file
:
"
netError
.
dtd
"
key
:
"
inadequateSecurityError
.
longDesc
"
type
:
"
single
-
quote
"
}
{
file
:
"
netError
.
dtd
"
key
:
"
certerror
.
wrongSystemTime2
"
type
:
"
single
-
quote
"
}
{
file
:
"
netError
.
dtd
"
key
:
"
certerror
.
wrongSystemTimeWithoutReference
"
type
:
"
single
-
quote
"
}
{
file
:
"
phishing
-
afterload
-
warning
-
message
.
dtd
"
key
:
"
safeb
.
blocked
.
malwarePage
.
shortDesc
"
type
:
"
single
-
quote
"
}
{
file
:
"
phishing
-
afterload
-
warning
-
message
.
dtd
"
key
:
"
safeb
.
blocked
.
unwantedPage
.
shortDesc
"
type
:
"
single
-
quote
"
}
{
file
:
"
phishing
-
afterload
-
warning
-
message
.
dtd
"
key
:
"
safeb
.
blocked
.
phishingPage
.
shortDesc2
"
type
:
"
single
-
quote
"
}
{
file
:
"
mathfont
.
properties
"
key
:
"
operator
.
\
\
u002E
\
\
u002E
\
\
u002E
.
postfix
"
type
:
"
ellipsis
"
}
{
file
:
"
layout_errors
.
properties
"
key
:
"
ImageMapRectBoundsError
"
type
:
"
double
-
quote
"
}
{
file
:
"
layout_errors
.
properties
"
key
:
"
ImageMapCircleWrongNumberOfCoords
"
type
:
"
double
-
quote
"
}
{
file
:
"
layout_errors
.
properties
"
key
:
"
ImageMapCircleNegativeRadius
"
type
:
"
double
-
quote
"
}
{
file
:
"
layout_errors
.
properties
"
key
:
"
ImageMapPolyWrongNumberOfCoords
"
type
:
"
double
-
quote
"
}
{
file
:
"
layout_errors
.
properties
"
key
:
"
ImageMapPolyOddNumberOfCoords
"
type
:
"
double
-
quote
"
}
{
file
:
"
xbl
.
properties
"
key
:
"
CommandNotInChrome
"
type
:
"
double
-
quote
"
}
{
file
:
"
dom
.
properties
"
key
:
"
PatternAttributeCompileFailure
"
type
:
"
single
-
quote
"
}
{
file
:
"
pipnss
.
properties
"
key
:
"
certErrorMismatchSingle2
"
type
:
"
double
-
quote
"
}
{
file
:
"
pipnss
.
properties
"
key
:
"
certErrorCodePrefix2
"
type
:
"
double
-
quote
"
}
{
file
:
"
aboutSupport
.
dtd
"
key
:
"
aboutSupport
.
pageSubtitle
"
type
:
"
single
-
quote
"
}
{
file
:
"
aboutSupport
.
dtd
"
key
:
"
aboutSupport
.
userJSDescription
"
type
:
"
single
-
quote
"
}
{
file
:
"
netError
.
dtd
"
key
:
"
inadequateSecurityError
.
longDesc
"
type
:
"
single
-
quote
"
}
{
file
:
"
netErrorApp
.
dtd
"
key
:
"
securityOverride
.
warningContent
"
type
:
"
single
-
quote
"
}
{
file
:
"
pocket
.
properties
"
key
:
"
tos
"
type
:
"
double
-
quote
"
}
{
file
:
"
aboutNetworking
.
dtd
"
key
:
"
aboutNetworking
.
logTutorial
"
type
:
"
single
-
quote
"
}
{
file
:
"
preferences
.
properties
"
key
:
"
searchResults
.
needHelp
"
type
:
"
double
-
quote
"
}
]
;
function
ignoredError
(
filepath
key
type
)
{
for
(
let
index
in
gWhitelist
)
{
let
whitelistItem
=
gWhitelist
[
index
]
;
if
(
filepath
.
endsWith
(
whitelistItem
.
file
)
&
&
key
=
=
whitelistItem
.
key
&
&
type
=
=
whitelistItem
.
type
)
{
gWhitelist
.
splice
(
index
1
)
;
return
true
;
}
}
return
false
;
}
function
testForError
(
filepath
key
str
pattern
type
helpText
)
{
if
(
str
.
match
(
pattern
)
&
&
!
ignoredError
(
filepath
key
type
)
)
{
ok
(
false
{
filepath
}
with
key
=
{
key
}
has
a
misused
{
type
}
.
{
helpText
}
)
;
}
}
function
testForErrors
(
filepath
key
str
)
{
testForError
(
filepath
key
str
/
\
w
'
\
w
/
"
apostrophe
"
"
Strings
with
apostrophes
should
use
foo
\
u2019s
instead
of
foo
'
s
.
"
)
;
testForError
(
filepath
key
str
/
\
w
\
u2018
\
w
/
"
incorrect
-
apostrophe
"
"
Strings
with
apostrophes
should
use
foo
\
u2019s
instead
of
foo
\
u2018s
.
"
)
;
testForError
(
filepath
key
str
/
'
.
+
'
/
"
single
-
quote
"
"
Single
-
quoted
strings
should
use
Unicode
\
u2018foo
\
u2019
instead
of
'
foo
'
.
"
)
;
testForError
(
filepath
key
str
/
"
/
"
double
-
quote
"
"
Double
-
quoted
strings
should
use
Unicode
\
u201cfoo
\
u201d
instead
of
\
"
foo
\
"
.
"
)
;
testForError
(
filepath
key
str
/
\
.
\
.
\
.
/
"
ellipsis
"
"
Strings
with
an
ellipsis
should
use
the
Unicode
\
u2026
character
instead
of
three
periods
.
"
)
;
}
async
function
getAllTheFiles
(
extension
)
{
let
appDirGreD
=
Services
.
dirsvc
.
get
(
"
GreD
"
Ci
.
nsIFile
)
;
let
appDirXCurProcD
=
Services
.
dirsvc
.
get
(
"
XCurProcD
"
Ci
.
nsIFile
)
;
if
(
appDirGreD
.
contains
(
appDirXCurProcD
)
)
{
return
await
generateURIsFromDirTree
(
appDirGreD
[
extension
]
)
;
}
if
(
appDirXCurProcD
.
contains
(
appDirGreD
)
)
{
return
await
generateURIsFromDirTree
(
appDirXCurProcD
[
extension
]
)
;
}
let
urisGreD
=
await
generateURIsFromDirTree
(
appDirGreD
[
extension
]
)
;
let
urisXCurProcD
=
await
generateURIsFromDirTree
(
appDirXCurProcD
[
extension
]
)
;
return
Array
.
from
(
new
Set
(
urisGreD
.
concat
(
appDirXCurProcD
)
)
)
;
}
add_task
(
async
function
checkAllTheProperties
(
)
{
let
uris
=
await
getAllTheFiles
(
"
.
properties
"
)
;
ok
(
uris
.
length
Found
{
uris
.
length
}
.
properties
files
to
scan
for
misused
characters
)
;
for
(
let
uri
of
uris
)
{
let
bundle
=
Services
.
strings
.
createBundle
(
uri
.
spec
)
;
let
enumerator
=
bundle
.
getSimpleEnumeration
(
)
;
while
(
enumerator
.
hasMoreElements
(
)
)
{
let
entity
=
enumerator
.
getNext
(
)
.
QueryInterface
(
Ci
.
nsIPropertyElement
)
;
testForErrors
(
uri
.
spec
entity
.
key
entity
.
value
)
;
}
}
}
)
;
var
checkDTD
=
async
function
(
aURISpec
)
{
let
rawContents
=
await
fetchFile
(
aURISpec
)
;
let
entities
=
rawContents
.
match
(
/
<
!
ENTITY
\
s
+
(
[
\
w
\
.
]
*
)
\
s
+
(
"
[
^
"
]
*
"
|
'
[
^
'
]
*
'
)
\
s
*
>
/
g
)
;
if
(
!
entities
)
{
return
;
}
for
(
let
entity
of
entities
)
{
let
[
key
str
]
=
entity
.
match
(
/
<
!
ENTITY
\
s
+
(
[
\
w
\
.
]
*
)
\
s
+
(
"
[
^
"
]
*
"
|
'
[
^
'
]
*
'
)
\
s
*
>
/
)
;
str
=
str
.
slice
(
1
-
1
)
;
testForErrors
(
aURISpec
key
str
)
;
}
}
;
add_task
(
async
function
checkAllTheDTDs
(
)
{
let
uris
=
await
getAllTheFiles
(
"
.
dtd
"
)
;
ok
(
uris
.
length
Found
{
uris
.
length
}
.
dtd
files
to
scan
for
misused
characters
)
;
for
(
let
uri
of
uris
)
{
await
checkDTD
(
uri
.
spec
)
;
}
let
dtdLocation
=
gTestPath
.
replace
(
/
\
/
[
^
\
/
]
*
/
i
"
/
bug1262648_string_with_newlines
.
dtd
"
)
;
await
checkDTD
(
dtdLocation
)
;
}
)
;
add_task
(
async
function
ensureWhiteListIsEmpty
(
)
{
is
(
gWhitelist
.
length
0
"
No
remaining
whitelist
entries
exist
"
)
;
}
)
;
