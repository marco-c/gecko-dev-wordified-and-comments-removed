"
use
strict
"
;
const
{
CustomizableUITestUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
CustomizableUITestUtils
.
sys
.
mjs
"
)
;
const
{
AppMenuNotifications
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
AppMenuNotifications
.
sys
.
mjs
"
)
;
const
NAMES
=
new
Set
(
[
"
Mozilla
"
"
Nightly
"
"
Firefox
"
]
)
;
const
PHRASES
=
new
Set
(
[
"
Troubleshoot
Mode
"
]
)
;
let
gCUITestUtils
=
new
CustomizableUITestUtils
(
window
)
;
let
gLocalization
=
new
Localization
(
[
"
browser
/
newtab
/
asrouter
.
ftl
"
]
true
)
;
async
function
*
iterateSubviews
(
parentView
)
{
let
navButtons
=
Array
.
from
(
parentView
.
querySelectorAll
(
"
.
subviewbutton
-
nav
:
not
(
[
disabled
]
)
:
not
(
[
hidden
]
)
"
)
)
;
if
(
!
navButtons
)
{
return
;
}
for
(
let
button
of
navButtons
)
{
info
(
"
Click
"
+
button
.
id
)
;
let
panel
=
parentView
.
closest
(
"
panel
"
)
;
let
panelmultiview
=
parentView
.
closest
(
"
panelmultiview
"
)
;
let
promiseViewShown
=
BrowserTestUtils
.
waitForEvent
(
panel
"
ViewShown
"
)
;
button
.
click
(
)
;
let
viewShownEvent
=
await
promiseViewShown
;
yield
viewShownEvent
.
originalTarget
;
info
(
"
Shown
"
+
viewShownEvent
.
originalTarget
.
id
)
;
yield
*
iterateSubviews
(
viewShownEvent
.
originalTarget
)
;
promiseViewShown
=
BrowserTestUtils
.
waitForEvent
(
parentView
"
ViewShown
"
)
;
panelmultiview
.
goBack
(
)
;
await
promiseViewShown
;
}
}
function
checkToolbarButtons
(
view
)
{
let
toolbarbuttons
=
view
.
querySelectorAll
(
"
toolbarbutton
"
)
;
info
(
"
Checking
toolbarbuttons
in
subview
with
id
"
+
view
.
id
)
;
for
(
let
toolbarbutton
of
toolbarbuttons
)
{
let
strings
=
[
toolbarbutton
.
label
toolbarbutton
.
textContent
toolbarbutton
.
toolTipText
GetDynamicShortcutTooltipText
(
toolbarbutton
.
id
)
]
;
info
(
"
Checking
toolbarbutton
"
+
toolbarbutton
.
id
)
;
for
(
let
string
of
strings
)
{
checkSentenceCase
(
string
toolbarbutton
.
id
)
;
}
}
}
function
checkSubheaders
(
view
)
{
let
subheaders
=
view
.
querySelectorAll
(
"
h2
"
)
;
info
(
"
Checking
subheaders
in
subview
with
id
"
+
view
.
id
)
;
for
(
let
subheader
of
subheaders
)
{
checkSentenceCase
(
subheader
.
textContent
subheader
.
id
)
;
}
}
async
function
checkUpdateBanner
(
view
)
{
let
banner
=
view
.
querySelector
(
"
#
appMenu
-
update
-
banner
"
)
;
const
notifications
=
[
"
update
-
downloading
"
"
update
-
available
"
"
update
-
manual
"
"
update
-
unsupported
"
"
update
-
restart
"
]
;
for
(
const
notification
of
notifications
)
{
banner
.
removeAttribute
(
"
label
"
)
;
let
labelPromise
=
BrowserTestUtils
.
waitForMutationCondition
(
banner
{
attributes
:
true
attributeFilter
:
[
"
label
"
]
}
(
)
=
>
!
!
banner
.
getAttribute
(
"
label
"
)
)
;
AppMenuNotifications
.
showNotification
(
notification
)
;
await
labelPromise
;
checkSentenceCase
(
banner
.
label
banner
.
id
)
;
AppMenuNotifications
.
removeNotification
(
/
.
*
/
)
;
}
}
function
checkSentenceCase
(
string
elementID
)
{
if
(
!
string
|
|
!
elementID
)
{
return
;
}
info
(
"
Testing
string
:
"
+
string
)
;
let
words
=
string
.
trim
(
)
.
split
(
/
\
s
+
/
)
;
let
result
=
hasExpectedCapitalization
(
words
[
0
]
true
)
;
if
(
result
)
{
for
(
let
wordIndex
=
1
;
wordIndex
<
words
.
length
;
+
+
wordIndex
)
{
let
word
=
words
[
wordIndex
]
;
if
(
word
)
{
if
(
isPartOfPhrase
(
words
wordIndex
)
)
{
result
=
hasExpectedCapitalization
(
word
true
)
;
}
else
{
let
isName
=
NAMES
.
has
(
word
)
;
result
=
hasExpectedCapitalization
(
word
isName
)
;
}
if
(
!
result
)
{
break
;
}
}
}
}
Assert
.
ok
(
result
{
string
}
for
{
elementID
}
should
have
sentence
casing
.
)
;
}
function
isPartOfPhrase
(
words
wordIndex
)
{
let
word
=
words
[
wordIndex
]
;
info
(
Checking
if
{
word
}
is
part
of
a
phrase
)
;
for
(
let
phrase
of
PHRASES
)
{
let
phraseFragments
=
phrase
.
split
(
"
"
)
;
let
fragmentIndex
=
phraseFragments
.
indexOf
(
word
)
;
if
(
fragmentIndex
=
=
-
1
|
|
words
.
length
-
phraseFragments
.
length
<
0
|
|
fragmentIndex
>
wordIndex
)
{
continue
;
}
let
wordsSlice
=
words
.
slice
(
wordIndex
-
fragmentIndex
wordIndex
+
phraseFragments
.
length
)
;
let
matches
=
wordsSlice
.
every
(
(
w
index
)
=
>
{
return
phraseFragments
[
index
]
=
=
=
w
;
}
)
;
if
(
matches
)
{
info
(
{
word
}
is
part
of
phrase
{
phrase
}
)
;
return
true
;
}
}
return
false
;
}
add_task
(
async
function
test_sentence_case_appmenu
(
)
{
await
gCUITestUtils
.
openMainMenu
(
)
;
registerCleanupFunction
(
async
(
)
=
>
{
await
gCUITestUtils
.
hideMainMenu
(
)
;
}
)
;
checkToolbarButtons
(
PanelUI
.
mainView
)
;
checkSubheaders
(
PanelUI
.
mainView
)
;
for
await
(
const
view
of
iterateSubviews
(
PanelUI
.
mainView
)
)
{
checkToolbarButtons
(
view
)
;
checkSubheaders
(
view
)
;
}
await
checkUpdateBanner
(
PanelUI
.
mainView
)
;
}
)
;
add_task
(
async
function
test_sentence_case_all_tabs_panel
(
)
{
gTabsPanel
.
init
(
)
;
const
allTabsView
=
document
.
getElementById
(
"
allTabsMenu
-
allTabsView
"
)
;
let
allTabsPopupShownPromise
=
BrowserTestUtils
.
waitForEvent
(
allTabsView
"
ViewShown
"
)
;
gTabsPanel
.
showAllTabsPanel
(
)
;
await
allTabsPopupShownPromise
;
registerCleanupFunction
(
async
(
)
=
>
{
let
allTabsPopupHiddenPromise
=
BrowserTestUtils
.
waitForEvent
(
allTabsView
.
panelMultiView
"
PanelMultiViewHidden
"
)
;
gTabsPanel
.
hideAllTabsPanel
(
)
;
await
allTabsPopupHiddenPromise
;
}
)
;
checkToolbarButtons
(
gTabsPanel
.
allTabsView
)
;
checkSubheaders
(
gTabsPanel
.
allTabsView
)
;
for
await
(
const
view
of
iterateSubviews
(
gTabsPanel
.
allTabsView
)
)
{
checkToolbarButtons
(
view
)
;
checkSubheaders
(
view
)
;
}
}
)
;
