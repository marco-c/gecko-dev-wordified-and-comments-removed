"
use
strict
"
;
const
{
CustomizableUITestUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
CustomizableUITestUtils
.
jsm
"
)
;
const
NAMES
=
new
Set
(
[
"
Mozilla
"
"
Nightly
"
"
Firefox
"
]
)
;
const
PHRASES
=
new
Set
(
[
"
Troubleshoot
Mode
"
]
)
;
let
gCUITestUtils
=
new
CustomizableUITestUtils
(
window
)
;
let
gLocalization
=
new
Localization
(
[
"
browser
/
newtab
/
asrouter
.
ftl
"
]
true
)
;
const
SPECIAL_GETTERS
=
{
"
appMenu
-
protonMainView
"
:
{
"
appMenu
-
proton
-
update
-
banner
"
:
function
(
button
)
{
let
result
=
[
]
;
for
(
let
attr
of
button
.
attributes
)
{
if
(
attr
.
name
.
startsWith
(
"
label
-
"
)
)
{
result
.
push
(
attr
.
value
)
;
}
}
Assert
.
ok
(
!
!
result
.
length
"
Should
have
found
at
least
1
label
-
attribute
on
"
+
"
appMenu
-
update
-
banner
to
check
for
sentence
case
.
"
)
;
return
result
;
}
}
}
;
async
function
*
iterateSubviews
(
parentView
)
{
let
navButtons
=
Array
.
from
(
parentView
.
querySelectorAll
(
"
.
subviewbutton
-
nav
:
not
(
[
disabled
]
)
"
)
)
;
if
(
!
navButtons
)
{
return
;
}
for
(
let
button
of
navButtons
)
{
info
(
"
Click
"
+
button
.
id
)
;
let
promiseViewShown
=
BrowserTestUtils
.
waitForEvent
(
PanelUI
.
panel
"
ViewShown
"
)
;
button
.
click
(
)
;
let
viewShownEvent
=
await
promiseViewShown
;
yield
viewShownEvent
.
originalTarget
;
info
(
"
Shown
"
+
viewShownEvent
.
originalTarget
.
id
)
;
yield
*
iterateSubviews
(
viewShownEvent
.
originalTarget
)
;
promiseViewShown
=
BrowserTestUtils
.
waitForEvent
(
parentView
"
ViewShown
"
)
;
PanelUI
.
multiView
.
goBack
(
)
;
await
promiseViewShown
;
}
}
function
checkToolbarButtons
(
view
)
{
let
toolbarbuttons
=
view
.
querySelectorAll
(
"
toolbarbutton
"
)
;
info
(
"
Checking
toolbarbuttons
in
subview
with
id
"
+
view
.
id
)
;
for
(
let
toolbarbutton
of
toolbarbuttons
)
{
let
strings
;
if
(
SPECIAL_GETTERS
[
view
.
id
]
&
&
SPECIAL_GETTERS
[
view
.
id
]
[
toolbarbutton
.
id
]
)
{
strings
=
SPECIAL_GETTERS
[
view
.
id
]
[
toolbarbutton
.
id
]
(
toolbarbutton
)
;
}
else
{
strings
=
[
toolbarbutton
.
label
toolbarbutton
.
textContent
toolbarbutton
.
toolTipText
GetDynamicShortcutTooltipText
(
toolbarbutton
.
id
)
]
;
}
info
(
"
Checking
toolbarbutton
"
+
toolbarbutton
.
id
)
;
for
(
let
string
of
strings
)
{
checkSentenceCase
(
string
toolbarbutton
.
id
)
;
}
}
}
function
checkSubheaders
(
view
)
{
let
subheaders
=
view
.
querySelectorAll
(
"
h2
"
)
;
info
(
"
Checking
subheaders
in
subview
with
id
"
+
view
.
id
)
;
for
(
let
subheader
of
subheaders
)
{
checkSentenceCase
(
subheader
.
textContent
subheader
.
id
)
;
}
}
function
checkSentenceCase
(
string
elementID
)
{
if
(
!
string
|
|
!
elementID
)
{
return
;
}
info
(
"
Testing
string
:
"
+
string
)
;
let
words
=
string
.
trim
(
)
.
split
(
/
\
s
+
/
)
;
let
result
=
hasExpectedCapitalization
(
words
[
0
]
true
)
;
if
(
result
)
{
for
(
let
wordIndex
=
1
;
wordIndex
<
words
.
length
;
+
+
wordIndex
)
{
let
word
=
words
[
wordIndex
]
;
if
(
word
)
{
if
(
isPartOfPhrase
(
words
wordIndex
)
)
{
result
=
hasExpectedCapitalization
(
word
true
)
;
}
else
{
let
isName
=
NAMES
.
has
(
word
)
;
result
=
hasExpectedCapitalization
(
word
isName
)
;
}
if
(
!
result
)
{
break
;
}
}
}
}
Assert
.
ok
(
result
{
string
}
for
{
elementID
}
should
have
sentence
casing
.
)
;
}
function
isPartOfPhrase
(
words
wordIndex
)
{
let
word
=
words
[
wordIndex
]
;
info
(
Checking
if
{
word
}
is
part
of
a
phrase
)
;
for
(
let
phrase
of
PHRASES
)
{
let
phraseFragments
=
phrase
.
split
(
"
"
)
;
let
fragmentIndex
=
phraseFragments
.
indexOf
(
word
)
;
if
(
fragmentIndex
=
=
-
1
|
|
words
.
length
-
phraseFragments
.
length
<
0
|
|
fragmentIndex
>
wordIndex
)
{
continue
;
}
let
wordsSlice
=
words
.
slice
(
wordIndex
-
fragmentIndex
wordIndex
+
phraseFragments
.
length
)
;
let
matches
=
wordsSlice
.
every
(
(
w
index
)
=
>
{
return
phraseFragments
[
index
]
=
=
=
w
;
}
)
;
if
(
matches
)
{
info
(
{
word
}
is
part
of
phrase
{
phrase
}
)
;
return
true
;
}
}
return
false
;
}
add_task
(
async
function
test_sentence_case_appmenu
(
)
{
await
gCUITestUtils
.
openMainMenu
(
)
;
registerCleanupFunction
(
async
(
)
=
>
{
await
gCUITestUtils
.
hideMainMenu
(
)
;
}
)
;
checkToolbarButtons
(
PanelUI
.
mainView
)
;
checkSubheaders
(
PanelUI
.
mainView
)
;
for
await
(
const
view
of
iterateSubviews
(
PanelUI
.
mainView
)
)
{
checkToolbarButtons
(
view
)
;
checkSubheaders
(
view
)
;
}
}
)
;
