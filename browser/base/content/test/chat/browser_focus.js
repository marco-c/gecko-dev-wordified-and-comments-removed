Components
.
utils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Promise
.
jsm
"
this
)
;
const
CHAT_URL
=
"
https
:
/
/
example
.
com
/
browser
/
browser
/
base
/
content
/
test
/
chat
/
chat
.
html
"
;
function
isTabFocused
(
)
{
let
tabb
=
gBrowser
.
getBrowserForTab
(
gBrowser
.
selectedTab
)
;
let
elt
=
Services
.
focus
.
getFocusedElementForWindow
(
window
false
{
}
)
;
return
elt
=
=
tabb
;
}
function
isChatFocused
(
chat
)
{
let
elt
=
Services
.
focus
.
getFocusedElementForWindow
(
window
false
{
}
)
;
return
elt
=
=
chat
.
content
;
}
var
chatbar
=
document
.
getElementById
(
"
pinnedchats
"
)
;
function
*
setUp
(
)
{
let
html
=
'
<
input
id
=
"
theinput
"
>
<
button
id
=
"
chat
-
opener
"
>
<
/
button
>
'
;
let
url
=
"
data
:
text
/
html
;
charset
=
utf
-
8
"
+
encodeURI
(
html
)
;
let
tab
=
gBrowser
.
selectedTab
=
gBrowser
.
addTab
(
url
{
skipAnimation
:
true
}
)
;
yield
promiseOneEvent
(
tab
.
linkedBrowser
"
load
"
true
)
;
tab
.
linkedBrowser
.
contentDocument
.
getElementById
(
"
theinput
"
)
.
focus
(
)
;
registerCleanupFunction
(
function
(
)
{
gBrowser
.
removeTab
(
tab
)
;
}
)
;
}
add_chat_task
(
function
*
testDefaultFocus
(
)
{
yield
setUp
(
)
;
let
chat
=
yield
promiseOpenChat
(
"
http
:
/
/
example
.
com
"
)
;
Assert
.
equal
(
numChatsInWindow
(
window
)
1
"
should
be
1
chat
open
"
)
;
Assert
.
ok
(
isTabFocused
(
)
"
the
tab
should
remain
focused
.
"
)
;
Assert
.
ok
(
!
isChatFocused
(
chat
)
"
the
chat
should
not
be
focused
.
"
)
;
}
)
;
add_chat_task
(
function
*
testDefaultFocusUserInput
(
)
{
todo
(
false
"
BrowserTestUtils
.
synthesizeMouseAtCenter
doesn
'
t
move
the
user
"
+
"
focus
to
the
chat
window
even
though
we
'
re
recording
a
click
correctly
.
"
)
;
return
;
yield
setUp
(
)
;
let
browser
=
gBrowser
.
selectedTab
.
linkedBrowser
;
let
mm
=
browser
.
messageManager
;
let
deferred
=
Promise
.
defer
(
)
;
mm
.
addMessageListener
(
"
ChatOpenerClicked
"
function
handler
(
)
{
mm
.
removeMessageListener
(
"
ChatOpenerClicked
"
handler
)
;
promiseOpenChat
(
"
http
:
/
/
example
.
com
"
)
.
then
(
chat
=
>
deferred
.
resolve
(
chat
)
)
;
}
)
;
yield
ContentTask
.
spawn
(
browser
null
function
*
(
)
{
let
button
=
content
.
document
.
getElementById
(
"
chat
-
opener
"
)
;
button
.
addEventListener
(
"
click
"
function
onclick
(
)
{
button
.
removeEventListener
(
"
click
"
onclick
)
;
sendAsyncMessage
(
"
ChatOpenerClicked
"
)
;
}
)
;
}
)
;
yield
BrowserTestUtils
.
synthesizeMouseAtCenter
(
"
#
chat
-
opener
"
{
}
browser
)
;
let
chat
=
yield
deferred
.
promise
;
Assert
.
equal
(
numChatsInWindow
(
window
)
1
"
should
be
1
chat
open
"
)
;
yield
promiseWaitForCondition
(
(
)
=
>
!
isTabFocused
(
)
)
;
Assert
.
ok
(
!
isTabFocused
(
)
"
the
tab
should
have
lost
focus
.
"
)
;
Assert
.
ok
(
isChatFocused
(
chat
)
"
the
chat
should
have
got
focus
.
"
)
;
}
)
;
add_chat_task
(
function
*
testExplicitFocus
(
)
{
yield
setUp
(
)
;
let
chat
=
yield
promiseOpenChat
(
"
http
:
/
/
example
.
com
"
undefined
true
)
;
Assert
.
equal
(
numChatsInWindow
(
window
)
1
"
should
be
1
chat
open
"
)
;
yield
promiseWaitForCondition
(
(
)
=
>
!
isTabFocused
(
)
)
;
Assert
.
ok
(
!
isTabFocused
(
)
"
the
tab
should
have
lost
focus
.
"
)
;
Assert
.
ok
(
isChatFocused
(
chat
)
"
the
chat
should
have
got
focus
.
"
)
;
}
)
;
add_chat_task
(
function
*
testNoFocusOnAutoRestore
(
)
{
yield
setUp
(
)
;
let
chat
=
yield
promiseOpenChat
(
"
http
:
/
/
example
.
com
"
"
minimized
"
)
;
Assert
.
ok
(
chat
.
minimized
"
chat
is
minimized
"
)
;
Assert
.
equal
(
numChatsInWindow
(
window
)
1
"
should
be
1
chat
open
"
)
;
Assert
.
ok
(
isTabFocused
(
)
"
the
tab
should
remain
focused
.
"
)
;
Assert
.
ok
(
!
isChatFocused
(
chat
)
"
the
chat
should
not
be
focused
.
"
)
;
yield
promiseOpenChat
(
"
http
:
/
/
example
.
com
"
)
;
Assert
.
ok
(
!
chat
.
minimized
"
chat
should
be
restored
"
)
;
Assert
.
ok
(
isTabFocused
(
)
"
the
tab
should
remain
focused
.
"
)
;
Assert
.
ok
(
!
isChatFocused
(
chat
)
"
the
chat
should
not
be
focused
.
"
)
;
}
)
;
add_chat_task
(
function
*
testFocusOnExplicitRestore
(
)
{
yield
setUp
(
)
;
let
chat
=
yield
promiseOpenChat
(
"
http
:
/
/
example
.
com
"
)
;
Assert
.
ok
(
!
chat
.
minimized
"
chat
should
have
been
opened
restored
"
)
;
Assert
.
ok
(
isTabFocused
(
)
"
the
tab
should
remain
focused
.
"
)
;
Assert
.
ok
(
!
isChatFocused
(
chat
)
"
the
chat
should
not
be
focused
.
"
)
;
chat
.
minimized
=
true
;
Assert
.
ok
(
isTabFocused
(
)
"
tab
should
still
be
focused
"
)
;
Assert
.
ok
(
!
isChatFocused
(
chat
)
"
the
chat
should
not
be
focused
.
"
)
;
let
promise
=
promiseOneMessage
(
chat
.
content
"
Social
:
FocusEnsured
"
)
;
chat
.
onTitlebarClick
(
{
button
:
0
}
)
;
yield
promise
;
Assert
.
ok
(
!
chat
.
minimized
"
chat
should
have
been
restored
"
)
;
Assert
.
ok
(
isChatFocused
(
chat
)
"
chat
should
be
focused
"
)
;
Assert
.
strictEqual
(
chat
chatbar
.
selectedChat
"
chat
is
marked
selected
"
)
;
}
)
;
add_chat_task
(
function
*
testMinimizeFocused
(
)
{
yield
setUp
(
)
;
let
chat1
=
yield
promiseOpenChat
(
"
http
:
/
/
example
.
com
#
1
"
)
;
let
chat2
=
yield
promiseOpenChat
(
"
http
:
/
/
example
.
com
#
2
"
)
;
Assert
.
equal
(
numChatsInWindow
(
window
)
2
"
2
chats
open
"
)
;
Assert
.
strictEqual
(
chatbar
.
selectedChat
chat2
"
chat2
is
selected
"
)
;
let
promise
=
promiseOneMessage
(
chat1
.
content
"
Social
:
FocusEnsured
"
)
;
chatbar
.
selectedChat
=
chat1
;
chatbar
.
focus
(
)
;
yield
promise
;
Assert
.
strictEqual
(
chat1
chatbar
.
selectedChat
"
chat1
is
marked
selected
"
)
;
Assert
.
notStrictEqual
(
chat2
chatbar
.
selectedChat
"
chat2
is
not
marked
selected
"
)
;
todo
(
false
"
Bug
1245803
should
re
-
enable
the
test
below
to
have
a
chat
window
"
+
"
re
-
gain
focus
when
another
chat
window
is
minimized
.
"
)
;
return
;
promise
=
promiseOneMessage
(
chat2
.
content
"
Social
:
FocusEnsured
"
)
;
chat1
.
minimized
=
true
;
yield
promise
;
Assert
.
notStrictEqual
(
chat1
chatbar
.
selectedChat
"
chat1
is
not
marked
selected
"
)
;
Assert
.
strictEqual
(
chat2
chatbar
.
selectedChat
"
chat2
is
marked
selected
"
)
;
}
)
;
add_chat_task
(
function
*
testTab
(
)
{
yield
setUp
(
)
;
function
sendTabAndWaitForFocus
(
chat
eltid
)
{
EventUtils
.
sendKey
(
"
tab
"
)
;
return
ContentTask
.
spawn
(
chat
.
content
{
eltid
:
eltid
}
function
*
(
args
)
{
let
doc
=
content
.
document
;
yield
new
Promise
(
function
(
resolve
reject
)
{
let
tries
=
0
;
let
interval
=
content
.
setInterval
(
function
(
)
{
if
(
tries
>
=
30
)
{
clearInterval
(
interval
)
;
reject
(
"
never
got
focus
"
)
;
return
;
}
tries
+
+
;
let
elt
=
args
.
eltid
?
doc
.
getElementById
(
args
.
eltid
)
:
doc
.
documentElement
;
if
(
doc
.
activeElement
=
=
elt
)
{
content
.
clearInterval
(
interval
)
;
resolve
(
)
;
}
info
(
"
retrying
wait
for
focus
:
"
+
tries
)
;
info
(
"
(
the
active
element
is
"
+
doc
.
activeElement
+
"
/
"
+
doc
.
activeElement
.
getAttribute
(
"
id
"
)
+
"
)
"
)
;
}
100
)
;
info
(
"
waiting
for
element
"
+
args
.
eltid
+
"
to
get
focus
"
)
;
}
)
;
}
)
;
}
let
chat1
=
yield
promiseOpenChat
(
CHAT_URL
+
"
#
1
"
)
;
let
chat2
=
yield
promiseOpenChat
(
CHAT_URL
+
"
#
2
"
)
;
chatbar
.
selectedChat
=
chat2
;
let
promise
=
promiseOneMessage
(
chat2
.
content
"
Social
:
FocusEnsured
"
)
;
chatbar
.
focus
(
)
;
info
(
"
waiting
for
second
chat
to
get
focus
"
)
;
yield
promise
;
yield
sendTabAndWaitForFocus
(
chat2
"
input1
"
)
;
Assert
.
ok
(
isChatFocused
(
chat2
)
"
new
chat
still
focused
after
first
tab
"
)
;
yield
sendTabAndWaitForFocus
(
chat2
"
input2
"
)
;
Assert
.
ok
(
isChatFocused
(
chat2
)
"
new
chat
still
focused
after
tab
"
)
;
yield
sendTabAndWaitForFocus
(
chat2
"
iframe
"
)
;
Assert
.
ok
(
isChatFocused
(
chat2
)
"
new
chat
still
focused
after
tab
"
)
;
yield
sendTabAndWaitForFocus
(
chat1
null
)
;
Assert
.
ok
(
isChatFocused
(
chat1
)
"
first
chat
is
focused
"
)
;
}
)
;
add_chat_task
(
function
*
testFocusedElement
(
)
{
yield
setUp
(
)
;
let
chat
=
yield
promiseOpenChat
(
CHAT_URL
undefined
true
)
;
yield
ContentTask
.
spawn
(
chat
.
content
null
function
*
(
)
{
content
.
document
.
getElementById
(
"
input2
"
)
.
focus
(
)
;
}
)
;
let
tabb
=
gBrowser
.
getBrowserForTab
(
gBrowser
.
selectedTab
)
;
let
promise
=
promiseOneEvent
(
tabb
.
contentWindow
"
focus
"
)
;
Services
.
focus
.
moveFocus
(
tabb
.
contentWindow
null
Services
.
focus
.
MOVEFOCUS_ROOT
0
)
;
yield
promise
;
promise
=
promiseOneMessage
(
chat
.
content
"
Social
:
FocusEnsured
"
)
;
chatbar
.
focus
(
)
;
yield
promise
;
yield
ContentTask
.
spawn
(
chat
.
content
null
function
*
(
)
{
is
(
content
.
document
.
activeElement
.
getAttribute
(
"
id
"
)
"
input2
"
"
correct
input
field
still
has
focus
"
)
;
}
)
;
}
)
;
