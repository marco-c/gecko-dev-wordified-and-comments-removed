var
Chat
=
Cu
.
import
(
"
resource
:
/
/
/
modules
/
Chat
.
jsm
"
{
}
)
.
Chat
;
const
kDefaultButtonSet
=
new
Set
(
[
"
minimize
"
"
swap
"
"
close
"
]
)
;
function
promiseOpenChat
(
url
mode
focus
buttonSet
=
null
)
{
let
uri
=
Services
.
io
.
newURI
(
url
null
null
)
;
let
origin
=
uri
.
prePath
;
let
title
=
origin
;
return
new
Promise
(
resolve
=
>
{
let
callback
=
function
(
chatbox
)
{
let
mm
=
chatbox
.
content
.
messageManager
;
mm
.
sendAsyncMessage
(
"
WaitForDOMContentLoaded
"
)
;
mm
.
addMessageListener
(
"
DOMContentLoaded
"
function
cb
(
)
{
mm
.
removeMessageListener
(
"
DOMContentLoaded
"
cb
)
;
resolve
(
chatbox
)
;
}
)
;
}
let
chatbox
=
Chat
.
open
(
null
{
origin
:
origin
title
:
title
url
:
url
mode
:
mode
focus
:
focus
}
callback
)
;
if
(
buttonSet
)
{
chatbox
.
setAttribute
(
"
buttonSet
"
buttonSet
)
;
}
}
)
;
}
function
promiseOpenChatCallback
(
url
mode
)
{
let
uri
=
Services
.
io
.
newURI
(
url
null
null
)
;
let
origin
=
uri
.
prePath
;
let
title
=
origin
;
return
new
Promise
(
resolve
=
>
{
Chat
.
open
(
null
{
origin
title
url
mode
}
resolve
)
;
}
)
;
}
function
promiseOneEvent
(
target
eventName
capture
)
{
return
new
Promise
(
resolve
=
>
{
target
.
addEventListener
(
eventName
function
handler
(
event
)
{
target
.
removeEventListener
(
eventName
handler
capture
)
;
resolve
(
)
;
}
capture
)
;
}
)
;
}
function
promiseOneMessage
(
target
messageName
)
{
return
new
Promise
(
resolve
=
>
{
let
mm
=
target
.
messageManager
;
mm
.
addMessageListener
(
messageName
function
handler
(
)
{
mm
.
removeMessageListener
(
messageName
handler
)
;
resolve
(
)
;
}
)
;
}
)
;
}
function
numChatsInWindow
(
win
)
{
let
chatbar
=
win
.
document
.
getElementById
(
"
pinnedchats
"
)
;
return
chatbar
.
childElementCount
;
}
function
promiseWaitForFocus
(
)
{
return
new
Promise
(
resolve
=
>
waitForFocus
(
resolve
)
)
;
}
function
add_chat_task
(
genFunction
)
{
add_task
(
function
*
(
)
{
info
(
"
Starting
chat
test
"
+
genFunction
.
name
)
;
try
{
yield
genFunction
(
)
;
}
finally
{
info
(
"
Finished
chat
test
"
+
genFunction
.
name
+
"
-
cleaning
up
.
"
)
;
while
(
chatbar
.
childNodes
.
length
)
{
chatbar
.
childNodes
[
0
]
.
close
(
)
;
}
let
winEnum
=
Services
.
wm
.
getEnumerator
(
"
Social
:
Chat
"
)
;
while
(
winEnum
.
hasMoreElements
(
)
)
{
let
win
=
winEnum
.
getNext
(
)
;
if
(
win
.
closed
)
{
continue
;
}
win
.
close
(
)
;
}
}
}
)
;
}
function
waitForCondition
(
condition
nextTest
errorMsg
)
{
var
tries
=
0
;
var
interval
=
setInterval
(
function
(
)
{
if
(
tries
>
=
100
)
{
ok
(
false
errorMsg
)
;
moveOn
(
)
;
}
var
conditionPassed
;
try
{
conditionPassed
=
condition
(
)
;
}
catch
(
e
)
{
ok
(
false
e
+
"
\
n
"
+
e
.
stack
)
;
conditionPassed
=
false
;
}
if
(
conditionPassed
)
{
moveOn
(
)
;
}
tries
+
+
;
}
100
)
;
var
moveOn
=
function
(
)
{
clearInterval
(
interval
)
;
nextTest
(
)
;
}
;
}
function
promiseWaitForCondition
(
aConditionFn
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
waitForCondition
(
aConditionFn
resolve
"
Condition
didn
'
t
pass
.
"
)
;
}
)
;
}
