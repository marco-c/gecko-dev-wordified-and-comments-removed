"
use
strict
"
;
const
TEST_SECURITY_DELAY
=
5000
;
SimpleTest
.
requestCompleteLog
(
)
;
function
showNotification
(
)
{
PopupNotifications
.
show
(
gBrowser
.
selectedBrowser
"
foo
"
"
Hello
World
!
"
"
default
-
notification
-
icon
"
{
label
:
"
ok
"
accessKey
:
"
o
"
callback
:
(
)
=
>
{
}
}
[
{
label
:
"
cancel
"
accessKey
:
"
c
"
callback
:
(
)
=
>
{
}
}
]
{
persistent
:
true
}
)
;
}
add_setup
(
async
function
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
security
.
notification_enable_delay
"
TEST_SECURITY_DELAY
]
]
}
)
;
}
)
;
async
function
ensureSecurityDelayReady
(
)
{
await
TestUtils
.
waitForCondition
(
(
)
=
>
performance
.
now
(
)
>
TEST_SECURITY_DELAY
"
Wait
for
performance
.
now
(
)
>
SECURITY_DELAY
"
500
50
)
;
}
async
function
runPopupNotificationSecurityDelayTest
(
{
onSecurityDelayExpired
cleanupFn
=
(
)
=
>
{
}
}
)
{
await
ensureSecurityDelayReady
(
)
;
info
(
"
Open
a
notification
.
"
)
;
let
popupShownPromise
=
waitForNotificationPanel
(
)
;
showNotification
(
)
;
await
popupShownPromise
;
ok
(
PopupNotifications
.
isPanelOpen
"
PopupNotification
should
be
open
after
show
call
.
"
)
;
info
(
"
Trigger
main
action
via
button
click
during
the
initial
security
delay
.
"
)
;
triggerMainCommand
(
PopupNotifications
.
panel
)
;
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
0
)
)
;
ok
(
PopupNotifications
.
isPanelOpen
"
PopupNotification
should
still
be
open
.
"
)
;
let
notification
=
PopupNotifications
.
getNotification
(
"
foo
"
gBrowser
.
selectedBrowser
)
;
ok
(
notification
"
Notification
should
still
be
open
because
we
clicked
during
the
security
delay
.
"
)
;
if
(
!
notification
)
{
await
cleanupFn
(
)
;
return
;
}
info
(
"
Wait
for
security
delay
to
expire
.
"
)
;
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
TEST_SECURITY_DELAY
+
500
)
)
;
info
(
"
Run
test
specific
actions
which
restarts
the
security
delay
.
"
)
;
await
onSecurityDelayExpired
(
)
;
info
(
"
Trigger
main
action
via
button
click
during
the
new
security
delay
.
"
)
;
triggerMainCommand
(
PopupNotifications
.
panel
)
;
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
0
)
)
;
ok
(
PopupNotifications
.
isPanelOpen
"
PopupNotification
should
still
be
open
.
"
)
;
notification
=
PopupNotifications
.
getNotification
(
"
foo
"
gBrowser
.
selectedBrowser
)
;
ok
(
notification
"
Notification
should
still
be
open
because
we
clicked
during
the
security
delay
.
"
)
;
if
(
!
notification
)
{
await
cleanupFn
(
)
;
return
;
}
let
fakeTimeShown
=
TEST_SECURITY_DELAY
+
500
;
info
(
Manually
set
timeShown
to
{
fakeTimeShown
}
ms
in
the
past
.
)
;
notification
.
timeShown
=
performance
.
now
(
)
-
fakeTimeShown
;
info
(
"
Trigger
main
action
via
button
click
outside
security
delay
"
)
;
let
notificationHiddenPromise
=
waitForNotificationPanelHidden
(
)
;
triggerMainCommand
(
PopupNotifications
.
panel
)
;
info
(
"
Wait
for
panel
to
be
hidden
.
"
)
;
await
notificationHiddenPromise
;
ok
(
!
PopupNotifications
.
getNotification
(
"
foo
"
gBrowser
.
selectedBrowser
)
"
Should
no
longer
see
the
notification
.
"
)
;
info
(
"
Cleanup
.
"
)
;
await
cleanupFn
(
)
;
}
add_task
(
async
function
test_timeShownMultipleNotifications
(
)
{
await
ensureSecurityDelayReady
(
)
;
ok
(
!
PopupNotifications
.
isPanelOpen
"
PopupNotification
panel
should
not
be
open
initially
.
"
)
;
info
(
"
Open
the
first
notification
.
"
)
;
let
popupShownPromise
=
waitForNotificationPanel
(
)
;
showNotification
(
)
;
await
popupShownPromise
;
ok
(
PopupNotifications
.
isPanelOpen
"
PopupNotification
should
be
open
after
first
show
call
.
"
)
;
is
(
PopupNotifications
.
_currentNotifications
.
length
1
"
There
should
only
be
one
notification
"
)
;
let
notification
=
PopupNotifications
.
getNotification
(
"
foo
"
gBrowser
.
selectedBrowser
)
;
is
(
notification
?
.
id
"
foo
"
"
There
should
be
a
notification
with
id
foo
"
)
;
ok
(
notification
.
timeShown
"
The
notification
should
have
timeShown
set
"
)
;
info
(
"
Call
show
again
with
the
same
notification
id
while
the
PopupNotification
panel
is
still
open
.
"
)
;
showNotification
(
)
;
ok
(
PopupNotifications
.
isPanelOpen
"
PopupNotification
should
still
open
after
second
show
call
.
"
)
;
notification
=
PopupNotifications
.
getNotification
(
"
foo
"
gBrowser
.
selectedBrowser
)
;
is
(
PopupNotifications
.
_currentNotifications
.
length
1
"
There
should
still
only
be
one
notification
"
)
;
is
(
notification
?
.
id
"
foo
"
"
There
should
still
be
a
notification
with
id
foo
"
)
;
ok
(
notification
.
timeShown
"
The
notification
should
have
timeShown
set
"
)
;
let
notificationHiddenPromise
=
waitForNotificationPanelHidden
(
)
;
info
(
"
Trigger
main
action
via
button
click
during
security
delay
"
)
;
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
0
)
)
;
triggerMainCommand
(
PopupNotifications
.
panel
)
;
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
0
)
)
;
ok
(
PopupNotifications
.
isPanelOpen
"
PopupNotification
should
still
be
open
.
"
)
;
notification
=
PopupNotifications
.
getNotification
(
"
foo
"
gBrowser
.
selectedBrowser
)
;
ok
(
notification
"
Notification
should
still
be
open
because
we
clicked
during
the
security
delay
.
"
)
;
if
(
!
notification
)
{
return
;
}
let
fakeTimeShown
=
TEST_SECURITY_DELAY
+
500
;
info
(
Manually
set
timeShown
to
{
fakeTimeShown
}
ms
in
the
past
.
)
;
notification
.
timeShown
=
performance
.
now
(
)
-
fakeTimeShown
;
info
(
"
Trigger
main
action
via
button
click
outside
security
delay
"
)
;
triggerMainCommand
(
PopupNotifications
.
panel
)
;
info
(
"
Wait
for
panel
to
be
hidden
.
"
)
;
await
notificationHiddenPromise
;
ok
(
!
PopupNotifications
.
getNotification
(
"
foo
"
gBrowser
.
selectedBrowser
)
"
Should
no
longer
see
the
notification
.
"
)
;
}
)
;
add_task
(
async
function
test_notificationReshowTabSwitch
(
)
{
await
runPopupNotificationSecurityDelayTest
(
{
onSecurityDelayExpired
:
async
(
)
=
>
{
let
panelHiddenPromise
=
waitForNotificationPanelHidden
(
)
;
let
panelShownPromise
;
info
(
"
Open
a
new
tab
which
hides
the
notification
panel
.
"
)
;
await
BrowserTestUtils
.
withNewTab
(
"
https
:
/
/
example
.
com
"
async
(
)
=
>
{
info
(
"
Wait
for
panel
to
be
hidden
by
tab
switch
.
"
)
;
await
panelHiddenPromise
;
panelShownPromise
=
waitForNotificationPanel
(
)
;
}
)
;
info
(
"
Wait
for
the
panel
to
show
again
after
the
tab
close
.
We
'
re
showing
the
original
tab
again
.
"
)
;
await
panelShownPromise
;
ok
(
PopupNotifications
.
isPanelOpen
"
PopupNotification
should
be
shown
after
tab
close
.
"
)
;
let
notification
=
PopupNotifications
.
getNotification
(
"
foo
"
gBrowser
.
selectedBrowser
)
;
is
(
notification
?
.
id
"
foo
"
"
There
should
still
be
a
notification
with
id
foo
"
)
;
info
(
"
Because
we
re
-
show
the
panel
after
tab
close
/
switch
the
security
delay
should
have
reset
.
"
)
;
}
}
)
;
}
)
;
add_task
(
async
function
test_notificationWindowMove
(
)
{
let
screenX
screenY
;
await
runPopupNotificationSecurityDelayTest
(
{
onSecurityDelayExpired
:
async
(
)
=
>
{
info
(
"
Reposition
the
window
"
)
;
screenX
=
window
.
screenX
;
screenY
=
window
.
screenY
;
let
promisePopupPositioned
=
BrowserTestUtils
.
waitForEvent
(
PopupNotifications
.
panel
"
popuppositioned
"
)
;
window
.
moveTo
(
200
200
)
;
await
promisePopupPositioned
;
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
0
)
)
;
}
cleanupFn
:
async
(
)
=
>
{
window
.
moveTo
(
screenX
screenY
)
;
}
}
)
;
}
)
;
add_task
(
async
function
test_notificationDuringFullScreenTransition
(
)
{
let
loggingObserver
=
{
observe
(
subject
topic
)
{
info
(
"
Observed
topic
:
"
+
topic
)
;
}
}
;
Services
.
obs
.
addObserver
(
loggingObserver
"
fullscreen
-
transition
-
start
"
)
;
Services
.
obs
.
addObserver
(
loggingObserver
"
fullscreen
-
transition
-
end
"
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
obs
.
removeObserver
(
loggingObserver
"
fullscreen
-
transition
-
start
"
)
;
Services
.
obs
.
removeObserver
(
loggingObserver
"
fullscreen
-
transition
-
end
"
)
;
}
)
;
if
(
Services
.
appinfo
.
OS
=
=
"
Linux
"
)
{
ok
(
"
Skipping
test
on
Linux
because
of
disabled
full
screen
transition
in
CI
.
"
)
;
return
;
}
if
(
Services
.
appinfo
.
OS
=
=
"
Darwin
"
)
{
ok
(
"
Skipping
test
on
macOS
because
of
intermittent
failures
.
"
)
;
return
;
}
await
BrowserTestUtils
.
withNewTab
(
"
https
:
/
/
example
.
com
"
async
browser
=
>
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
security
.
notification_enable_delay
"
1
]
[
"
full
-
screen
-
api
.
transition
-
duration
.
leave
"
"
1000
1000
"
]
[
"
full
-
screen
-
api
.
allow
-
trusted
-
requests
-
only
"
false
]
[
"
full
-
screen
-
api
.
macos
-
native
-
full
-
screen
"
false
]
]
}
)
;
await
ensureSecurityDelayReady
(
)
;
ok
(
!
PopupNotifications
.
isPanelOpen
"
PopupNotification
panel
should
not
be
open
initially
.
"
)
;
info
(
"
Open
a
notification
.
"
)
;
let
popupShownPromise
=
waitForNotificationPanel
(
)
;
showNotification
(
)
;
await
popupShownPromise
;
ok
(
PopupNotifications
.
isPanelOpen
"
PopupNotification
should
be
open
after
show
call
.
"
)
;
let
notification
=
PopupNotifications
.
getNotification
(
"
foo
"
browser
)
;
is
(
notification
?
.
id
"
foo
"
"
There
should
be
a
notification
with
id
foo
"
)
;
info
(
"
Open
a
new
tab
via
window
.
open
enter
full
screen
and
remove
the
tab
.
"
)
;
let
transitionStartCount
=
0
;
let
transitionEndCount
=
0
;
let
promiseFullScreenTransitionStart
=
TestUtils
.
topicObserved
(
"
fullscreen
-
transition
-
start
"
(
)
=
>
{
transitionStartCount
+
+
;
return
transitionStartCount
=
=
2
;
}
)
;
let
promiseFullScreenTransitionEnd
=
TestUtils
.
topicObserved
(
"
fullscreen
-
transition
-
end
"
(
)
=
>
{
transitionEndCount
+
+
;
return
transitionEndCount
=
=
2
;
}
)
;
let
notificationShownPromise
=
waitForNotificationPanel
(
)
;
await
SpecialPowers
.
spawn
(
browser
[
]
(
)
=
>
{
content
.
eval
(
let
button
=
document
.
createElement
(
"
button
"
)
;
button
.
id
=
"
triggerBtn
"
;
button
.
innerText
=
"
Open
Popup
"
;
button
.
addEventListener
(
"
click
"
(
)
=
>
{
let
popup
=
window
.
open
(
"
about
:
blank
"
)
;
popup
.
document
.
write
(
"
<
script
>
setTimeout
(
(
)
=
>
document
.
documentElement
.
requestFullscreen
(
)
500
)
<
/
script
>
"
)
;
popup
.
document
.
write
(
"
<
script
>
setTimeout
(
(
)
=
>
window
.
close
(
)
1500
)
<
/
script
>
"
)
;
}
)
;
/
/
Insert
button
at
the
top
so
the
synthesized
click
works
.
Otherwise
/
/
the
button
may
be
outside
of
the
viewport
.
document
.
body
.
prepend
(
button
)
;
)
;
}
)
;
let
timeClick
=
performance
.
now
(
)
;
await
BrowserTestUtils
.
synthesizeMouseAtCenter
(
"
#
triggerBtn
"
{
}
browser
)
;
info
(
"
Wait
for
the
exit
transition
to
start
.
It
'
s
the
second
transition
.
"
)
;
await
promiseFullScreenTransitionStart
;
info
(
"
Full
screen
transition
start
"
)
;
ok
(
true
"
Full
screen
transition
started
"
)
;
ok
(
window
.
isInFullScreenTransition
"
Full
screen
transition
is
still
running
.
"
)
;
info
(
"
Wait
for
notification
to
re
-
show
on
tab
switch
after
the
popup
has
been
closed
"
)
;
await
notificationShownPromise
;
ok
(
window
.
isInFullScreenTransition
"
Full
screen
transition
is
still
running
.
"
)
;
info
(
"
about
to
trigger
notification
.
time
between
btn
click
and
notification
show
:
"
+
(
performance
.
now
(
)
-
timeClick
)
)
;
info
(
"
Trigger
main
action
via
button
click
during
the
extended
security
delay
.
"
)
;
triggerMainCommand
(
PopupNotifications
.
panel
)
;
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
0
)
)
;
ok
(
PopupNotifications
.
isPanelOpen
"
PopupNotification
should
still
be
open
.
"
)
;
notification
=
PopupNotifications
.
getNotification
(
"
foo
"
gBrowser
.
selectedBrowser
)
;
ok
(
notification
"
Notification
should
still
be
open
because
we
clicked
during
the
security
delay
.
"
)
;
info
(
"
Wait
for
full
screen
transition
end
.
"
)
;
await
promiseFullScreenTransitionEnd
;
info
(
"
Full
screen
transition
end
"
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
)
;
}
)
;
