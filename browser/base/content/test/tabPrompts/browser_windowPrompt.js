"
use
strict
"
;
add_task
(
async
function
test_check_window_modal_prompt_service
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
prompts
.
windowPromptSubDialog
"
true
]
]
}
)
;
let
dialogPromise
=
BrowserTestUtils
.
promiseAlertDialogOpen
(
)
;
setTimeout
(
(
)
=
>
Services
.
prompt
.
alert
(
window
"
Some
title
"
"
some
message
"
)
0
)
;
let
dialogWin
=
await
dialogPromise
;
is
(
dialogWin
.
document
.
getElementById
(
"
infoTitle
"
)
.
textContent
"
Some
title
"
"
Title
should
be
correct
.
"
)
;
ok
(
!
dialogWin
.
document
.
getElementById
(
"
infoTitle
"
)
.
hidden
"
Title
should
be
shown
.
"
)
;
is
(
dialogWin
.
document
.
getElementById
(
"
infoBody
"
)
.
textContent
"
some
message
"
"
Body
text
should
be
correct
.
"
)
;
ok
(
dialogWin
?
.
docShell
?
.
chromeEventHandler
"
Should
have
embedded
the
dialog
.
"
)
;
for
(
let
menu
of
document
.
querySelectorAll
(
"
menubar
>
menu
"
)
)
{
ok
(
menu
.
disabled
Menu
{
menu
.
id
}
should
be
disabled
.
)
;
}
let
container
=
dialogWin
.
docShell
.
chromeEventHandler
.
closest
(
"
dialog
"
)
;
let
closedPromise
=
BrowserTestUtils
.
waitForMutationCondition
(
container
{
childList
:
true
attributes
:
true
}
(
)
=
>
!
container
.
hasChildNodes
(
)
&
&
!
container
.
open
)
;
EventUtils
.
sendKey
(
"
ESCAPE
"
)
;
await
closedPromise
;
await
BrowserTestUtils
.
waitForMutationCondition
(
document
.
querySelector
(
"
menubar
>
menu
"
)
{
attributes
:
true
}
(
)
=
>
!
document
.
querySelector
(
"
menubar
>
menu
"
)
.
disabled
)
;
for
(
let
menu
of
document
.
querySelectorAll
(
"
menubar
>
menu
"
)
)
{
ok
(
!
menu
.
disabled
Menu
{
menu
.
id
}
should
not
be
disabled
anymore
.
)
;
}
}
)
;
add_task
(
async
function
test_check_window_modal_prompt_service
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
prompts
.
windowPromptSubDialog
"
true
]
]
}
)
;
let
dialogPromise
=
BrowserTestUtils
.
promiseAlertDialogOpen
(
)
;
setTimeout
(
(
)
=
>
Services
.
prompt
.
alert
(
window
"
Some
title
"
"
some
message
"
)
0
)
;
let
dialogWin
=
await
dialogPromise
;
ok
(
dialogWin
?
.
docShell
?
.
chromeEventHandler
"
Should
have
embedded
the
dialog
.
"
)
;
let
container
=
dialogWin
.
docShell
.
chromeEventHandler
.
closest
(
"
dialog
"
)
;
let
closedPromise
=
BrowserTestUtils
.
waitForMutationCondition
(
container
{
childList
:
true
attributes
:
true
}
(
)
=
>
!
container
.
hasChildNodes
(
)
&
&
!
container
.
open
)
;
container
.
close
(
)
;
await
closedPromise
;
for
(
let
menu
of
document
.
querySelectorAll
(
"
menubar
>
menu
"
)
)
{
ok
(
!
menu
.
disabled
Menu
{
menu
.
id
}
should
not
be
disabled
anymore
.
)
;
}
}
)
;
add_task
(
async
function
test_check_multiple_prompts
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
prompts
.
windowPromptSubDialog
"
true
]
]
}
)
;
let
container
=
document
.
getElementById
(
"
window
-
modal
-
dialog
"
)
;
let
dialogPromise
=
BrowserTestUtils
.
promiseAlertDialogOpen
(
)
;
let
firstDialogClosedPromise
=
new
Promise
(
resolve
=
>
{
setTimeout
(
(
)
=
>
{
Services
.
prompt
.
alert
(
window
"
Some
title
"
"
some
message
"
)
;
resolve
(
)
;
}
0
)
;
}
)
;
let
dialogWin
=
await
dialogPromise
;
ok
(
dialogWin
?
.
docShell
?
.
chromeEventHandler
"
Should
have
embedded
the
dialog
.
"
)
;
is
(
container
.
childElementCount
1
"
Should
only
have
1
dialog
in
the
DOM
.
"
)
;
let
secondDialogClosedPromise
=
new
Promise
(
resolve
=
>
{
setTimeout
(
(
)
=
>
{
Services
.
prompt
.
alert
(
window
"
Another
title
"
"
another
message
"
)
;
resolve
(
)
;
}
0
)
;
}
)
;
dialogPromise
=
BrowserTestUtils
.
promiseAlertDialogOpen
(
)
;
info
(
"
Accepting
dialog
"
)
;
dialogWin
.
document
.
querySelector
(
"
dialog
"
)
.
acceptDialog
(
)
;
let
oldWin
=
dialogWin
;
info
(
"
Second
dialog
should
automatically
come
up
.
"
)
;
dialogWin
=
await
dialogPromise
;
isnot
(
oldWin
dialogWin
"
Opened
a
new
dialog
.
"
)
;
ok
(
container
.
open
"
Dialog
should
be
open
.
"
)
;
info
(
"
Now
close
the
second
dialog
.
"
)
;
dialogWin
.
document
.
querySelector
(
"
dialog
"
)
.
acceptDialog
(
)
;
await
firstDialogClosedPromise
;
await
secondDialogClosedPromise
;
await
BrowserTestUtils
.
waitForMutationCondition
(
container
{
childList
:
true
attributes
:
true
}
(
)
=
>
!
container
.
hasChildNodes
(
)
&
&
!
container
.
open
)
;
for
(
let
menu
of
document
.
querySelectorAll
(
"
menubar
>
menu
"
)
)
{
ok
(
!
menu
.
disabled
Menu
{
menu
.
id
}
should
not
be
disabled
anymore
.
)
;
}
}
)
;
add_task
(
async
function
test_check_minimize_response
(
)
{
if
(
AppConstants
.
platform
=
=
"
linux
"
)
{
return
;
}
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
prompts
.
windowPromptSubDialog
"
true
]
]
}
)
;
window
.
minimize
(
)
;
is
(
window
.
windowState
window
.
STATE_MINIMIZED
"
Should
be
minimized
.
"
)
;
let
dialogPromise
=
BrowserTestUtils
.
promiseAlertDialogOpen
(
)
;
Services
.
prompt
.
asyncAlert
(
window
.
browsingContext
Ci
.
nsIPrompt
.
MODAL_TYPE_INTERNAL_WINDOW
"
Some
title
"
"
some
message
"
)
;
let
dialogWin
=
await
dialogPromise
;
isnot
(
window
.
windowState
window
.
STATE_MINIMIZED
"
Should
no
longer
be
minimized
.
"
)
;
is
(
dialogWin
.
document
.
getElementById
(
"
infoTitle
"
)
.
textContent
"
Some
title
"
"
Title
should
be
correct
.
"
)
;
let
container
=
dialogWin
.
docShell
.
chromeEventHandler
.
closest
(
"
dialog
"
)
;
let
closedPromise
=
BrowserTestUtils
.
waitForMutationCondition
(
container
{
childList
:
true
attributes
:
true
}
(
)
=
>
!
container
.
hasChildNodes
(
)
&
&
!
container
.
open
)
;
EventUtils
.
sendKey
(
"
ESCAPE
"
)
;
await
closedPromise
;
await
BrowserTestUtils
.
waitForMutationCondition
(
document
.
querySelector
(
"
menubar
>
menu
"
)
{
attributes
:
true
}
(
)
=
>
!
document
.
querySelector
(
"
menubar
>
menu
"
)
.
disabled
)
;
}
)
;
add_task
(
async
function
test_closed_callback
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
prompts
.
windowPromptSubDialog
"
true
]
]
}
)
;
let
promptClosedPromise
=
Services
.
prompt
.
asyncAlert
(
window
.
browsingContext
Services
.
prompt
.
MODAL_TYPE_INTERNAL_WINDOW
"
Hello
"
"
Hello
World
!
"
)
;
let
dialog
=
gDialogBox
.
_dialog
;
ok
(
dialog
"
gDialogBox
should
have
a
dialog
"
)
;
dialog
.
close
(
)
;
info
(
"
Waiting
for
prompt
close
"
)
;
await
promptClosedPromise
;
ok
(
!
gDialogBox
.
_dialog
"
gDialogBox
should
no
longer
have
a
dialog
"
)
;
}
)
;
