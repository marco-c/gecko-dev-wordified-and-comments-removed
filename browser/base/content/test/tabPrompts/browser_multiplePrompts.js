"
use
strict
"
;
const
CONTENT_PROMPT_SUBDIALOG
=
Services
.
prefs
.
getBoolPref
(
"
prompts
.
contentPromptSubDialog
"
false
)
;
async
function
closeDialogs
(
tab
dialogCount
)
{
let
dialogElementsCount
=
dialogCount
;
let
dialogs
=
tab
.
linkedBrowser
.
tabDialogBox
.
getContentDialogManager
(
)
.
dialogs
;
is
(
dialogs
.
length
dialogElementsCount
"
There
should
be
"
+
dialogElementsCount
+
"
dialog
(
s
)
.
"
)
;
let
i
=
dialogElementsCount
-
1
;
for
(
let
dialog
of
dialogs
)
{
dialog
.
focus
(
true
)
;
await
dialog
.
_dialogReady
;
let
dialogWindow
=
dialog
.
frameContentWindow
;
let
expectedType
=
[
"
alert
"
"
prompt
"
"
confirm
"
]
[
i
%
3
]
;
is
(
dialogWindow
.
Dialog
.
args
.
text
expectedType
+
"
countdown
#
"
+
i
"
The
#
"
+
i
+
"
alert
should
be
labelled
as
such
.
"
)
;
i
-
-
;
dialogWindow
.
Dialog
.
ui
.
button0
.
click
(
)
;
await
new
Promise
(
function
(
resolve
)
{
Services
.
tm
.
dispatchToMainThread
(
resolve
)
;
}
)
;
}
dialogs
=
tab
.
linkedBrowser
.
tabDialogBox
.
getContentDialogManager
(
)
.
dialogs
;
is
(
dialogs
.
length
0
"
Dialogs
should
all
be
dismissed
.
"
)
;
}
async
function
closeTabModals
(
tab
promptCount
)
{
let
promptElementsCount
=
promptCount
;
while
(
promptElementsCount
-
-
)
{
let
promptElements
=
tab
.
linkedBrowser
.
parentNode
.
querySelectorAll
(
"
tabmodalprompt
"
)
;
is
(
promptElements
.
length
promptElementsCount
+
1
"
There
should
be
"
+
(
promptElementsCount
+
1
)
+
"
prompt
(
s
)
.
"
)
;
let
i
=
0
;
for
(
let
promptElement
of
promptElements
)
{
let
prompt
=
tab
.
linkedBrowser
.
tabModalPromptBox
.
getPrompt
(
promptElement
)
;
let
expectedType
=
[
"
alert
"
"
prompt
"
"
confirm
"
]
[
i
%
3
]
;
is
(
prompt
.
Dialog
.
args
.
text
expectedType
+
"
countdown
#
"
+
i
"
The
#
"
+
i
+
"
alert
should
be
labelled
as
such
.
"
)
;
if
(
i
!
=
=
promptElementsCount
)
{
is
(
prompt
.
element
.
hidden
true
"
This
prompt
should
be
hidden
.
"
)
;
i
+
+
;
continue
;
}
is
(
prompt
.
element
.
hidden
false
"
The
last
prompt
should
not
be
hidden
.
"
)
;
prompt
.
onButtonClick
(
0
)
;
await
new
Promise
(
function
(
resolve
)
{
Services
.
tm
.
dispatchToMainThread
(
resolve
)
;
}
)
;
}
}
let
promptElements
=
tab
.
linkedBrowser
.
parentNode
.
querySelectorAll
(
"
tabmodalprompt
"
)
;
is
(
promptElements
.
length
0
"
Prompts
should
all
be
dismissed
.
"
)
;
}
add_task
(
async
function
(
)
{
const
PROMPTCOUNT
=
9
;
let
unopenedPromptCount
=
PROMPTCOUNT
;
let
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
"
http
:
/
/
example
.
com
"
true
)
;
info
(
"
Tab
loaded
"
)
;
let
promptsOpenedPromise
=
BrowserTestUtils
.
waitForEvent
(
tab
.
linkedBrowser
"
DOMWillOpenModalDialog
"
false
(
)
=
>
{
unopenedPromptCount
-
-
;
return
unopenedPromptCount
=
=
0
;
}
)
;
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
PROMPTCOUNT
]
maxPrompts
=
>
{
var
i
=
maxPrompts
;
let
fns
=
[
"
alert
"
"
prompt
"
"
confirm
"
]
;
function
openDialog
(
)
{
i
-
-
;
if
(
i
)
{
SpecialPowers
.
Services
.
tm
.
dispatchToMainThread
(
openDialog
)
;
}
content
[
fns
[
i
%
3
]
]
(
fns
[
i
%
3
]
+
"
countdown
#
"
+
i
)
;
}
SpecialPowers
.
Services
.
tm
.
dispatchToMainThread
(
openDialog
)
;
}
)
;
await
promptsOpenedPromise
;
if
(
CONTENT_PROMPT_SUBDIALOG
)
{
await
closeDialogs
(
tab
PROMPTCOUNT
)
;
}
else
{
await
closeTabModals
(
tab
PROMPTCOUNT
)
;
}
BrowserTestUtils
.
removeTab
(
tab
)
;
}
)
;
