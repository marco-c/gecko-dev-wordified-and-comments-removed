"
use
strict
"
;
const
{
PromptTestUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
PromptTestUtils
.
sys
.
mjs
"
)
;
const
{
TabStateFlusher
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
/
modules
/
sessionstore
/
TabStateFlusher
.
sys
.
mjs
"
)
;
const
TEST_ROOT
=
getRootDirectory
(
gTestPath
)
.
replace
(
"
chrome
:
/
/
mochitests
/
content
"
"
https
:
/
/
example
.
com
"
)
;
async
function
addTab
(
url
)
{
let
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
{
gBrowser
url
animate
:
false
}
)
;
return
tab
;
}
async
function
addBeforeUnloadTab
(
)
{
let
tab
=
await
addTab
(
TEST_ROOT
+
"
file_beforeunload_stop
.
html
"
)
;
await
BrowserTestUtils
.
synthesizeMouseAtCenter
(
"
body
"
{
}
tab
.
linkedBrowser
.
browsingContext
)
;
Assert
.
ok
(
tab
.
linkedBrowser
.
hasBeforeUnload
"
Added
tab
has
a
beforeUnload
prompt
"
)
;
return
tab
;
}
add_task
(
async
function
test_closeGroupAndAcceptPrompt
(
)
{
await
SimpleTest
.
requestCompleteLog
(
)
;
let
tab1
=
await
addTab
(
"
about
:
mozilla
"
)
;
let
tab2
=
await
addBeforeUnloadTab
(
)
;
let
group
=
gBrowser
.
addTabGroup
(
[
tab1
tab2
]
)
;
let
promptHandled
=
PromptTestUtils
.
handleNextPrompt
(
window
{
modalType
:
Services
.
prompt
.
MODAL_TYPE_CONTENT
}
{
buttonNumClick
:
0
}
)
;
let
groupRemoved
=
BrowserTestUtils
.
waitForEvent
(
group
"
TabGroupRemoved
"
)
;
gBrowser
.
removeTabGroup
(
group
)
;
await
Promise
.
allSettled
(
[
promptHandled
groupRemoved
]
)
;
Assert
.
ok
(
!
gBrowser
.
getAllTabGroups
(
)
.
length
"
Tab
group
was
removed
"
)
;
}
)
;
add_task
(
async
function
test_closeGroupAndRejectPrompt
(
)
{
let
tab1
=
await
addTab
(
"
about
:
mozilla
"
)
;
let
tab2
=
await
addBeforeUnloadTab
(
)
;
let
groupCreated
=
BrowserTestUtils
.
waitForEvent
(
window
"
TabGroupCreate
"
)
;
let
group
=
gBrowser
.
addTabGroup
(
[
tab1
tab2
]
)
;
await
groupCreated
;
let
promptHandled
=
PromptTestUtils
.
handleNextPrompt
(
tab2
.
linkedBrowser
{
modalType
:
Services
.
prompt
.
MODAL_TYPE_CONTENT
}
{
buttonNumClick
:
1
}
)
;
gBrowser
.
removeTabGroup
(
group
)
;
await
promptHandled
;
Assert
.
equal
(
gBrowser
.
getAllTabGroups
(
)
.
length
1
"
Tab
group
is
still
open
"
)
;
Assert
.
equal
(
group
.
tabs
.
length
2
"
Both
tabs
in
group
remain
open
"
)
;
let
groupRemoved
=
BrowserTestUtils
.
waitForEvent
(
group
"
TabGroupRemoved
"
)
;
gBrowser
.
removeTabGroup
(
group
{
skipPermitUnload
:
true
}
)
;
await
groupRemoved
;
}
)
;
add_task
(
async
function
test_closeGroupAndRejectAnyPrompt
(
)
{
let
tab1
=
await
addBeforeUnloadTab
(
)
;
let
tab2
=
await
addBeforeUnloadTab
(
)
;
let
group
=
gBrowser
.
addTabGroup
(
[
tab1
tab2
]
)
;
let
firstPromptHandled
=
PromptTestUtils
.
handleNextPrompt
(
tab1
.
linkedBrowser
{
modalType
:
Services
.
prompt
.
MODAL_TYPE_CONTENT
}
{
buttonNumClick
:
0
}
)
;
let
secondPromptHandled
=
PromptTestUtils
.
handleNextPrompt
(
tab2
.
linkedBrowser
{
modalType
:
Services
.
prompt
.
MODAL_TYPE_CONTENT
}
{
buttonNumClick
:
1
}
)
;
let
groupRemoved
=
gBrowser
.
removeTabGroup
(
group
)
;
await
Promise
.
race
(
[
firstPromptHandled
secondPromptHandled
]
)
;
await
groupRemoved
;
Assert
.
equal
(
gBrowser
.
getAllTabGroups
(
)
.
length
1
"
Tab
group
is
still
open
"
)
;
Assert
.
equal
(
group
.
tabs
.
length
2
"
Both
tabs
in
group
remain
open
"
)
;
groupRemoved
=
BrowserTestUtils
.
waitForEvent
(
group
"
TabGroupRemoved
"
)
;
gBrowser
.
removeTabGroup
(
group
{
skipPermitUnload
:
true
}
)
;
await
groupRemoved
;
}
)
;
add_task
(
async
function
test_closeMultipleTabsAndRejectFromGroup
(
)
{
let
group1Tab1
=
await
addTab
(
"
about
:
mozilla
"
)
;
let
group1Tab2
=
await
addBeforeUnloadTab
(
)
;
let
group2Tab1
=
await
addBeforeUnloadTab
(
)
;
let
group2Tab2
=
await
addTab
(
"
about
:
mozilla
"
)
;
let
group1
=
gBrowser
.
addTabGroup
(
[
group1Tab1
group1Tab2
]
{
id
:
"
leave
-
open
"
label
:
"
leave
open
"
}
)
;
gBrowser
.
addTabGroup
(
[
group2Tab1
group2Tab2
]
{
id
:
"
close
"
label
:
"
close
"
}
)
;
let
firstPromptHandled
=
PromptTestUtils
.
handleNextPrompt
(
group1Tab2
.
linkedBrowser
{
modalType
:
Services
.
prompt
.
MODAL_TYPE_CONTENT
}
{
buttonNumClick
:
1
}
)
;
let
secondPromptHandled
=
PromptTestUtils
.
handleNextPrompt
(
group2Tab1
.
linkedBrowser
{
modalType
:
Services
.
prompt
.
MODAL_TYPE_CONTENT
}
{
buttonNumClick
:
0
}
)
;
gBrowser
.
removeTabsToTheEndFrom
(
gBrowser
.
tabs
[
0
]
)
;
await
Promise
.
allSettled
(
[
firstPromptHandled
secondPromptHandled
]
)
;
Assert
.
equal
(
gBrowser
.
tabs
.
length
3
"
3
tabs
remain
open
"
)
;
Assert
.
equal
(
gBrowser
.
getAllTabGroups
(
)
[
0
]
.
id
group1
.
id
"
Group
1
is
still
open
"
)
;
await
gBrowser
.
removeTabGroup
(
group1
{
skipPermitUnload
:
true
}
)
;
}
)
;
add_task
(
async
function
test_cancelClosingASavingGroup
(
)
{
let
tab1
=
await
addBeforeUnloadTab
(
)
;
let
tab2
=
await
addTab
(
"
about
:
mozilla
"
)
;
await
TabStateFlusher
.
flush
(
tab1
.
linkedBrowser
)
;
let
group
=
gBrowser
.
addTabGroup
(
[
tab1
tab2
]
)
;
group
.
save
(
)
;
Assert
.
equal
(
SessionStore
.
getCurrentState
(
)
.
savedGroups
.
length
1
"
Group
is
saved
"
)
;
let
promptHandled
=
PromptTestUtils
.
handleNextPrompt
(
tab1
.
linkedBrowser
{
modalType
:
Services
.
prompt
.
MODAL_TYPE_CONTENT
}
{
buttonNumClick
:
1
}
)
;
let
groupRemoved
=
gBrowser
.
removeTabGroup
(
group
)
;
await
Promise
.
allSettled
(
[
promptHandled
groupRemoved
]
)
;
Assert
.
equal
(
gBrowser
.
getAllTabGroups
(
)
.
length
1
"
Group
is
still
open
"
)
;
Assert
.
ok
(
!
SessionStore
.
getCurrentState
(
)
.
savedGroups
.
length
"
Group
is
no
longer
saved
after
close
was
canceled
"
)
;
await
gBrowser
.
removeTabGroup
(
group
{
skipPermitUnload
:
true
}
)
;
}
)
;
