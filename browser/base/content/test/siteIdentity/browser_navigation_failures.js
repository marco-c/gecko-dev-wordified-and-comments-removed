const
kSecureURI
=
getRootDirectory
(
gTestPath
)
.
replace
(
"
chrome
:
/
/
mochitests
/
content
"
"
https
:
/
/
example
.
com
"
)
+
"
dummy_page
.
html
"
;
add_task
(
async
function
(
)
{
await
BrowserTestUtils
.
withNewTab
(
kSecureURI
async
browser
=
>
{
let
identityMode
=
window
.
document
.
getElementById
(
"
identity
-
box
"
)
.
className
;
is
(
identityMode
"
verifiedDomain
"
"
identity
should
be
secure
before
"
)
;
const
TLS_HANDSHAKE_FAILURE_URI
=
"
https
:
/
/
ssl3
.
example
.
com
/
"
;
BrowserTestUtils
.
loadURI
(
browser
TLS_HANDSHAKE_FAILURE_URI
)
;
await
BrowserTestUtils
.
browserLoaded
(
browser
false
TLS_HANDSHAKE_FAILURE_URI
true
)
;
let
newIdentityMode
=
window
.
document
.
getElementById
(
"
identity
-
box
"
)
.
className
;
is
(
newIdentityMode
"
certErrorPage
notSecureText
"
"
identity
should
be
unknown
(
not
secure
)
after
"
)
;
}
)
;
}
)
;
add_task
(
async
function
(
)
{
await
BrowserTestUtils
.
withNewTab
(
kSecureURI
async
browser
=
>
{
let
identityMode
=
window
.
document
.
getElementById
(
"
identity
-
box
"
)
.
className
;
is
(
identityMode
"
verifiedDomain
"
"
identity
should
be
secure
before
"
)
;
const
BAD_ABOUT_PAGE_URI
=
"
about
:
somethingthatdoesnotexist
"
;
BrowserTestUtils
.
loadURI
(
browser
BAD_ABOUT_PAGE_URI
)
;
await
BrowserTestUtils
.
browserLoaded
(
browser
false
BAD_ABOUT_PAGE_URI
true
)
;
let
newIdentityMode
=
window
.
document
.
getElementById
(
"
identity
-
box
"
)
.
className
;
is
(
newIdentityMode
"
unknownIdentity
"
"
identity
should
be
unknown
(
not
secure
)
after
"
)
;
}
)
;
}
)
;
function
startServer
(
cert
)
{
let
tlsServer
=
Cc
[
"
mozilla
.
org
/
network
/
tls
-
server
-
socket
;
1
"
]
.
createInstance
(
Ci
.
nsITLSServerSocket
)
;
tlsServer
.
init
(
-
1
true
-
1
)
;
tlsServer
.
serverCert
=
cert
;
let
input
output
;
let
listener
=
{
onSocketAccepted
(
socket
transport
)
{
let
connectionInfo
=
transport
.
securityInfo
.
QueryInterface
(
Ci
.
nsITLSServerConnectionInfo
)
;
connectionInfo
.
setSecurityObserver
(
listener
)
;
input
=
transport
.
openInputStream
(
0
0
0
)
;
output
=
transport
.
openOutputStream
(
0
0
0
)
;
}
onHandshakeDone
(
socket
status
)
{
input
.
asyncWait
(
{
onInputStreamReady
(
readyInput
)
{
try
{
input
.
close
(
)
;
output
.
close
(
)
;
}
catch
(
e
)
{
info
(
e
)
;
}
}
}
0
0
Services
.
tm
.
currentThread
)
;
}
onStopListening
(
)
{
}
}
;
tlsServer
.
setSessionTickets
(
false
)
;
tlsServer
.
asyncListen
(
listener
)
;
return
tlsServer
;
}
add_task
(
async
function
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
network
.
dns
.
disableIPv6
"
true
]
]
}
)
;
let
certService
=
Cc
[
"
mozilla
.
org
/
security
/
local
-
cert
-
service
;
1
"
]
.
getService
(
Ci
.
nsILocalCertService
)
;
let
certOverrideService
=
Cc
[
"
mozilla
.
org
/
security
/
certoverride
;
1
"
]
.
getService
(
Ci
.
nsICertOverrideService
)
;
let
cert
=
await
new
Promise
(
(
resolve
reject
)
=
>
{
certService
.
getOrCreateCert
(
"
broken
-
tls
-
server
"
{
handleCert
(
c
rv
)
{
if
(
!
Components
.
isSuccessCode
(
rv
)
)
{
reject
(
rv
)
;
return
;
}
resolve
(
c
)
;
}
}
)
;
}
)
;
let
server
=
startServer
(
cert
)
;
let
overrideBits
=
Ci
.
nsICertOverrideService
.
ERROR_UNTRUSTED
|
Ci
.
nsICertOverrideService
.
ERROR_MISMATCH
;
certOverrideService
.
rememberValidityOverride
(
"
localhost
"
server
.
port
{
}
cert
overrideBits
true
)
;
registerCleanupFunction
(
(
)
=
>
{
certOverrideService
.
clearValidityOverride
(
"
localhost
"
server
.
port
{
}
)
;
server
.
close
(
)
;
}
)
;
await
BrowserTestUtils
.
withNewTab
(
"
about
:
blank
"
async
browser
=
>
{
const
TLS_HANDSHAKE_FAILURE_URI
=
https
:
/
/
localhost
:
{
server
.
port
}
/
;
BrowserTestUtils
.
loadURI
(
browser
TLS_HANDSHAKE_FAILURE_URI
)
;
await
BrowserTestUtils
.
browserLoaded
(
browser
false
TLS_HANDSHAKE_FAILURE_URI
true
)
;
let
identityMode
=
window
.
document
.
getElementById
(
"
identity
-
box
"
)
.
className
;
is
(
identityMode
"
certErrorPage
notSecureText
"
"
identity
should
be
'
unknown
'
"
)
;
}
)
;
}
)
;
