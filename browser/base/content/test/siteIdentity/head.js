Components
.
utils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Promise
"
"
resource
:
/
/
gre
/
modules
/
Promise
.
jsm
"
)
;
function
is_hidden
(
element
)
{
var
style
=
element
.
ownerGlobal
.
getComputedStyle
(
element
)
;
if
(
style
.
display
=
=
"
none
"
)
return
true
;
if
(
style
.
visibility
!
=
"
visible
"
)
return
true
;
if
(
style
.
display
=
=
"
-
moz
-
popup
"
)
return
[
"
hiding
"
"
closed
"
]
.
indexOf
(
element
.
state
)
!
=
-
1
;
if
(
element
.
parentNode
!
=
element
.
ownerDocument
)
return
is_hidden
(
element
.
parentNode
)
;
return
false
;
}
function
is_visible
(
element
)
{
var
style
=
element
.
ownerGlobal
.
getComputedStyle
(
element
)
;
if
(
style
.
display
=
=
"
none
"
)
return
false
;
if
(
style
.
visibility
!
=
"
visible
"
)
return
false
;
if
(
style
.
display
=
=
"
-
moz
-
popup
"
&
&
element
.
state
!
=
"
open
"
)
return
false
;
if
(
element
.
parentNode
!
=
element
.
ownerDocument
)
return
is_visible
(
element
.
parentNode
)
;
return
true
;
}
function
waitForNewTabEvent
(
aTabBrowser
)
{
return
BrowserTestUtils
.
waitForEvent
(
aTabBrowser
.
tabContainer
"
TabOpen
"
)
;
}
function
promiseTabLoadEvent
(
tab
url
)
{
info
(
"
Wait
tab
event
:
load
"
)
;
function
handle
(
loadedUrl
)
{
if
(
loadedUrl
=
=
=
"
about
:
blank
"
|
|
(
url
&
&
loadedUrl
!
=
=
url
)
)
{
info
(
Skipping
spurious
load
event
for
{
loadedUrl
}
)
;
return
false
;
}
info
(
"
Tab
event
received
:
load
"
)
;
return
true
;
}
let
loaded
=
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
false
handle
)
;
if
(
url
)
BrowserTestUtils
.
loadURI
(
tab
.
linkedBrowser
url
)
;
return
loaded
;
}
function
isSecurityState
(
browser
expectedState
)
{
let
ui
=
browser
.
securityUI
;
if
(
!
ui
)
{
ok
(
false
"
No
security
UI
to
get
the
security
state
"
)
;
return
;
}
const
wpl
=
Components
.
interfaces
.
nsIWebProgressListener
;
let
isSecure
=
ui
.
state
&
wpl
.
STATE_IS_SECURE
;
let
isBroken
=
ui
.
state
&
wpl
.
STATE_IS_BROKEN
;
let
isInsecure
=
ui
.
state
&
wpl
.
STATE_IS_INSECURE
;
let
actualState
;
if
(
isSecure
&
&
!
(
isBroken
|
|
isInsecure
)
)
{
actualState
=
"
secure
"
;
}
else
if
(
isBroken
&
&
!
(
isSecure
|
|
isInsecure
)
)
{
actualState
=
"
broken
"
;
}
else
if
(
isInsecure
&
&
!
(
isSecure
|
|
isBroken
)
)
{
actualState
=
"
insecure
"
;
}
else
{
actualState
=
"
unknown
"
;
}
is
(
expectedState
actualState
"
Expected
state
"
+
expectedState
+
"
and
the
actual
state
is
"
+
actualState
+
"
.
"
)
;
}
function
assertMixedContentBlockingState
(
tabbrowser
states
=
{
}
)
{
if
(
!
tabbrowser
|
|
!
(
"
activeLoaded
"
in
states
)
|
|
!
(
"
activeBlocked
"
in
states
)
|
|
!
(
"
passiveLoaded
"
in
states
)
)
{
throw
new
Error
(
"
assertMixedContentBlockingState
requires
a
browser
and
a
states
object
"
)
;
}
let
{
passiveLoaded
activeLoaded
activeBlocked
}
=
states
;
let
{
gIdentityHandler
}
=
tabbrowser
.
ownerGlobal
;
let
doc
=
tabbrowser
.
ownerDocument
;
let
identityBox
=
gIdentityHandler
.
_identityBox
;
let
classList
=
identityBox
.
classList
;
let
connectionIcon
=
doc
.
getElementById
(
"
connection
-
icon
"
)
;
let
connectionIconImage
=
tabbrowser
.
ownerGlobal
.
getComputedStyle
(
connectionIcon
)
.
getPropertyValue
(
"
list
-
style
-
image
"
)
;
let
stateSecure
=
gIdentityHandler
.
_state
&
Ci
.
nsIWebProgressListener
.
STATE_IS_SECURE
;
let
stateBroken
=
gIdentityHandler
.
_state
&
Ci
.
nsIWebProgressListener
.
STATE_IS_BROKEN
;
let
stateInsecure
=
gIdentityHandler
.
_state
&
Ci
.
nsIWebProgressListener
.
STATE_IS_INSECURE
;
let
stateActiveBlocked
=
gIdentityHandler
.
_state
&
Ci
.
nsIWebProgressListener
.
STATE_BLOCKED_MIXED_ACTIVE_CONTENT
;
let
stateActiveLoaded
=
gIdentityHandler
.
_state
&
Ci
.
nsIWebProgressListener
.
STATE_LOADED_MIXED_ACTIVE_CONTENT
;
let
statePassiveLoaded
=
gIdentityHandler
.
_state
&
Ci
.
nsIWebProgressListener
.
STATE_LOADED_MIXED_DISPLAY_CONTENT
;
is
(
activeBlocked
!
!
stateActiveBlocked
"
Expected
state
for
activeBlocked
matches
UI
state
"
)
;
is
(
activeLoaded
!
!
stateActiveLoaded
"
Expected
state
for
activeLoaded
matches
UI
state
"
)
;
is
(
passiveLoaded
!
!
statePassiveLoaded
"
Expected
state
for
passiveLoaded
matches
UI
state
"
)
;
if
(
stateInsecure
)
{
ok
(
classList
.
contains
(
"
unknownIdentity
"
)
"
unknownIdentity
on
HTTP
page
"
)
;
ok
(
is_hidden
(
connectionIcon
)
"
connection
icon
should
be
hidden
"
)
;
ok
(
!
classList
.
contains
(
"
mixedActiveContent
"
)
"
No
MCB
icon
on
HTTP
page
"
)
;
ok
(
!
classList
.
contains
(
"
mixedActiveBlocked
"
)
"
No
MCB
icon
on
HTTP
page
"
)
;
ok
(
!
classList
.
contains
(
"
mixedDisplayContent
"
)
"
No
MCB
icon
on
HTTP
page
"
)
;
ok
(
!
classList
.
contains
(
"
mixedDisplayContentLoadedActiveBlocked
"
)
"
No
MCB
icon
on
HTTP
page
"
)
;
}
else
{
is
(
classList
.
contains
(
"
mixedActiveContent
"
)
activeLoaded
"
identityBox
has
expected
class
for
activeLoaded
"
)
;
is
(
classList
.
contains
(
"
mixedActiveBlocked
"
)
activeBlocked
&
&
!
passiveLoaded
"
identityBox
has
expected
class
for
activeBlocked
&
&
!
passiveLoaded
"
)
;
is
(
classList
.
contains
(
"
mixedDisplayContent
"
)
passiveLoaded
&
&
!
(
activeLoaded
|
|
activeBlocked
)
"
identityBox
has
expected
class
for
passiveLoaded
&
&
!
(
activeLoaded
|
|
activeBlocked
)
"
)
;
is
(
classList
.
contains
(
"
mixedDisplayContentLoadedActiveBlocked
"
)
passiveLoaded
&
&
activeBlocked
"
identityBox
has
expected
class
for
passiveLoaded
&
&
activeBlocked
"
)
;
ok
(
!
is_hidden
(
connectionIcon
)
"
connection
icon
should
be
visible
"
)
;
if
(
activeLoaded
)
{
is
(
connectionIconImage
"
url
(
\
"
chrome
:
/
/
browser
/
skin
/
connection
-
mixed
-
active
-
loaded
.
svg
\
"
)
"
"
Using
active
loaded
icon
"
)
;
}
if
(
activeBlocked
&
&
!
passiveLoaded
)
{
is
(
connectionIconImage
"
url
(
\
"
chrome
:
/
/
browser
/
skin
/
connection
-
secure
.
svg
\
"
)
"
"
Using
active
blocked
icon
"
)
;
}
if
(
passiveLoaded
&
&
!
(
activeLoaded
|
|
activeBlocked
)
)
{
is
(
connectionIconImage
"
url
(
\
"
chrome
:
/
/
browser
/
skin
/
connection
-
mixed
-
passive
-
loaded
.
svg
\
"
)
"
"
Using
passive
loaded
icon
"
)
;
}
if
(
passiveLoaded
&
&
activeBlocked
)
{
is
(
connectionIconImage
"
url
(
\
"
chrome
:
/
/
browser
/
skin
/
connection
-
mixed
-
passive
-
loaded
.
svg
\
"
)
"
"
Using
active
blocked
and
passive
loaded
icon
"
)
;
}
}
gIdentityHandler
.
_identityBox
.
click
(
)
;
let
popupAttr
=
doc
.
getElementById
(
"
identity
-
popup
"
)
.
getAttribute
(
"
mixedcontent
"
)
;
let
bodyAttr
=
doc
.
getElementById
(
"
identity
-
popup
-
securityView
-
body
"
)
.
getAttribute
(
"
mixedcontent
"
)
;
is
(
popupAttr
.
includes
(
"
active
-
loaded
"
)
activeLoaded
"
identity
-
popup
has
expected
attr
for
activeLoaded
"
)
;
is
(
bodyAttr
.
includes
(
"
active
-
loaded
"
)
activeLoaded
"
securityView
-
body
has
expected
attr
for
activeLoaded
"
)
;
is
(
popupAttr
.
includes
(
"
active
-
blocked
"
)
activeBlocked
"
identity
-
popup
has
expected
attr
for
activeBlocked
"
)
;
is
(
bodyAttr
.
includes
(
"
active
-
blocked
"
)
activeBlocked
"
securityView
-
body
has
expected
attr
for
activeBlocked
"
)
;
is
(
popupAttr
.
includes
(
"
passive
-
loaded
"
)
passiveLoaded
"
identity
-
popup
has
expected
attr
for
passiveLoaded
"
)
;
is
(
bodyAttr
.
includes
(
"
passive
-
loaded
"
)
passiveLoaded
"
securityView
-
body
has
expected
attr
for
passiveLoaded
"
)
;
let
securityView
=
doc
.
getElementById
(
"
identity
-
popup
-
securityView
"
)
;
let
securityViewBG
=
tabbrowser
.
ownerGlobal
.
getComputedStyle
(
securityView
)
.
getPropertyValue
(
"
background
-
image
"
)
;
let
securityContentBG
=
tabbrowser
.
ownerGlobal
.
getComputedStyle
(
securityView
)
.
getPropertyValue
(
"
background
-
image
"
)
;
if
(
stateInsecure
)
{
is
(
securityViewBG
"
url
(
\
"
chrome
:
/
/
browser
/
skin
/
controlcenter
/
conn
-
not
-
secure
.
svg
\
"
)
"
"
CC
using
'
not
secure
'
icon
"
)
;
is
(
securityContentBG
"
url
(
\
"
chrome
:
/
/
browser
/
skin
/
controlcenter
/
conn
-
not
-
secure
.
svg
\
"
)
"
"
CC
using
'
not
secure
'
icon
"
)
;
}
if
(
stateSecure
)
{
is
(
securityViewBG
"
url
(
\
"
chrome
:
/
/
browser
/
skin
/
controlcenter
/
connection
.
svg
#
connection
-
secure
\
"
)
"
"
CC
using
secure
icon
"
)
;
is
(
securityContentBG
"
url
(
\
"
chrome
:
/
/
browser
/
skin
/
controlcenter
/
connection
.
svg
#
connection
-
secure
\
"
)
"
"
CC
using
secure
icon
"
)
;
}
if
(
stateBroken
)
{
if
(
activeLoaded
)
{
is
(
securityViewBG
"
url
(
\
"
chrome
:
/
/
browser
/
skin
/
controlcenter
/
mcb
-
disabled
.
svg
\
"
)
"
"
CC
using
active
loaded
icon
"
)
;
is
(
securityContentBG
"
url
(
\
"
chrome
:
/
/
browser
/
skin
/
controlcenter
/
mcb
-
disabled
.
svg
\
"
)
"
"
CC
using
active
loaded
icon
"
)
;
}
else
if
(
activeBlocked
|
|
passiveLoaded
)
{
is
(
securityViewBG
"
url
(
\
"
chrome
:
/
/
browser
/
skin
/
controlcenter
/
connection
.
svg
#
connection
-
degraded
\
"
)
"
"
CC
using
degraded
icon
"
)
;
is
(
securityContentBG
"
url
(
\
"
chrome
:
/
/
browser
/
skin
/
controlcenter
/
connection
.
svg
#
connection
-
degraded
\
"
)
"
"
CC
using
degraded
icon
"
)
;
}
else
{
is
(
securityViewBG
"
url
(
\
"
chrome
:
/
/
browser
/
skin
/
controlcenter
/
connection
.
svg
#
connection
-
degraded
\
"
)
"
"
CC
using
degraded
icon
"
)
;
is
(
securityContentBG
"
url
(
\
"
chrome
:
/
/
browser
/
skin
/
controlcenter
/
connection
.
svg
#
connection
-
degraded
\
"
)
"
"
CC
using
degraded
icon
"
)
;
}
}
if
(
activeLoaded
|
|
activeBlocked
|
|
passiveLoaded
)
{
doc
.
getElementById
(
"
identity
-
popup
-
security
-
expander
"
)
.
click
(
)
;
is
(
Array
.
filter
(
doc
.
querySelectorAll
(
"
[
observes
=
identity
-
popup
-
mcb
-
learn
-
more
]
"
)
element
=
>
!
is_hidden
(
element
)
)
.
length
1
"
The
'
Learn
more
'
link
should
be
visible
once
.
"
)
;
}
gIdentityHandler
.
_identityPopup
.
hidden
=
true
;
return
new
Promise
(
resolve
=
>
executeSoon
(
resolve
)
)
;
}
async
function
loadBadCertPage
(
url
)
{
const
EXCEPTION_DIALOG_URI
=
"
chrome
:
/
/
pippki
/
content
/
exceptionDialog
.
xul
"
;
let
exceptionDialogResolved
=
new
Promise
(
function
(
resolve
)
{
let
certExceptionDialogObserver
=
{
observe
(
aSubject
aTopic
aData
)
{
if
(
aTopic
=
=
"
cert
-
exception
-
ui
-
ready
"
)
{
Services
.
obs
.
removeObserver
(
this
"
cert
-
exception
-
ui
-
ready
"
)
;
let
certExceptionDialog
=
getCertExceptionDialog
(
EXCEPTION_DIALOG_URI
)
;
ok
(
certExceptionDialog
"
found
exception
dialog
"
)
;
executeSoon
(
function
(
)
{
certExceptionDialog
.
documentElement
.
getButton
(
"
extra1
"
)
.
click
(
)
;
resolve
(
)
;
}
)
;
}
}
}
;
Services
.
obs
.
addObserver
(
certExceptionDialogObserver
"
cert
-
exception
-
ui
-
ready
"
)
;
}
)
;
let
loaded
=
BrowserTestUtils
.
waitForErrorPage
(
gBrowser
.
selectedBrowser
)
;
await
BrowserTestUtils
.
loadURI
(
gBrowser
.
selectedBrowser
url
)
;
await
loaded
;
await
ContentTask
.
spawn
(
gBrowser
.
selectedBrowser
null
async
function
(
)
{
content
.
document
.
getElementById
(
"
exceptionDialogButton
"
)
.
click
(
)
;
}
)
;
await
exceptionDialogResolved
;
await
BrowserTestUtils
.
browserLoaded
(
gBrowser
.
selectedBrowser
)
;
}
function
getCertExceptionDialog
(
aLocation
)
{
let
enumerator
=
Services
.
wm
.
getXULWindowEnumerator
(
null
)
;
while
(
enumerator
.
hasMoreElements
(
)
)
{
let
win
=
enumerator
.
getNext
(
)
;
let
windowDocShell
=
win
.
QueryInterface
(
Ci
.
nsIXULWindow
)
.
docShell
;
let
containedDocShells
=
windowDocShell
.
getDocShellEnumerator
(
Ci
.
nsIDocShellTreeItem
.
typeChrome
Ci
.
nsIDocShell
.
ENUMERATE_FORWARDS
)
;
while
(
containedDocShells
.
hasMoreElements
(
)
)
{
let
childDocShell
=
containedDocShells
.
getNext
(
)
;
let
childDoc
=
childDocShell
.
QueryInterface
(
Ci
.
nsIDocShell
)
.
contentViewer
.
DOMDocument
;
if
(
childDoc
.
location
.
href
=
=
aLocation
)
{
return
childDoc
;
}
}
}
return
undefined
;
}
