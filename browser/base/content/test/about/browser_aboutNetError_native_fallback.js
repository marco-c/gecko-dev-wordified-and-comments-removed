"
use
strict
"
;
let
oldProxyType
=
Services
.
prefs
.
getIntPref
(
"
network
.
proxy
.
type
"
)
;
function
reset
(
)
{
Services
.
prefs
.
clearUserPref
(
"
network
.
trr
.
display_fallback_warning
"
)
;
Services
.
prefs
.
clearUserPref
(
"
network
.
trr
.
mode
"
)
;
Services
.
prefs
.
clearUserPref
(
"
network
.
dns
.
native
-
is
-
localhost
"
)
;
Services
.
prefs
.
clearUserPref
(
"
doh
-
rollout
.
disable
-
heuristics
"
)
;
Services
.
prefs
.
setIntPref
(
"
network
.
proxy
.
type
"
oldProxyType
)
;
Services
.
prefs
.
clearUserPref
(
"
network
.
trr
.
uri
"
)
;
Services
.
dns
.
setHeuristicDetectionResult
(
Ci
.
nsITRRSkipReason
.
TRR_OK
)
;
}
async
function
verifyLoad
(
url
testName
)
{
let
browser
;
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
(
)
=
>
{
gBrowser
.
selectedTab
=
BrowserTestUtils
.
addTab
(
gBrowser
url
)
;
browser
=
gBrowser
.
selectedBrowser
;
}
true
)
;
await
SpecialPowers
.
spawn
(
browser
[
{
url
testName
}
]
function
(
args
)
{
const
doc
=
content
.
document
;
ok
(
doc
.
documentURI
=
=
args
.
url
"
Should
have
loaded
page
:
"
+
args
.
testName
)
;
}
)
;
BrowserTestUtils
.
removeTab
(
gBrowser
.
selectedTab
)
;
}
async
function
verifyError
(
url
fallbackWarning
testName
)
{
Services
.
telemetry
.
clearEvents
(
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
{
let
events
=
Services
.
telemetry
.
snapshotEvents
(
Ci
.
nsITelemetry
.
DATASET_PRERELEASE_CHANNELS
true
)
.
content
;
return
!
events
|
|
!
events
.
length
;
}
)
;
Services
.
telemetry
.
setEventRecordingEnabled
(
"
security
.
doh
.
neterror
"
true
)
;
let
browser
;
let
pageLoaded
;
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
(
)
=
>
{
gBrowser
.
selectedTab
=
BrowserTestUtils
.
addTab
(
gBrowser
url
)
;
browser
=
gBrowser
.
selectedBrowser
;
pageLoaded
=
BrowserTestUtils
.
waitForErrorPage
(
browser
)
;
}
false
)
;
info
(
"
Loading
and
waiting
for
the
net
error
"
)
;
await
pageLoaded
;
await
SpecialPowers
.
spawn
(
browser
[
{
url
fallbackWarning
testName
}
]
function
(
args
)
{
const
doc
=
content
.
document
;
ok
(
doc
.
documentURI
.
startsWith
(
"
about
:
neterror
"
)
)
;
"
Should
be
showing
error
page
:
"
+
args
.
testName
;
const
titleEl
=
doc
.
querySelector
(
"
.
title
-
text
"
)
;
const
actualDataL10nID
=
titleEl
.
getAttribute
(
"
data
-
l10n
-
id
"
)
;
if
(
args
.
fallbackWarning
)
{
is
(
actualDataL10nID
"
dns
-
not
-
found
-
native
-
fallback
-
title2
"
"
Correct
fallback
warning
error
page
title
is
set
:
"
+
args
.
testName
)
;
}
else
{
ok
(
actualDataL10nID
!
=
"
dns
-
not
-
found
-
native
-
fallback
-
title2
"
"
Should
not
show
fallback
warning
:
"
+
args
.
testName
)
;
}
}
)
;
if
(
fallbackWarning
)
{
let
loadEvent
=
await
TestUtils
.
waitForCondition
(
(
)
=
>
{
let
events
=
Services
.
telemetry
.
snapshotEvents
(
Ci
.
nsITelemetry
.
DATASET_PRERELEASE_CHANNELS
true
)
.
content
;
return
events
?
.
find
(
e
=
>
e
[
1
]
=
=
"
security
.
doh
.
neterror
"
&
&
e
[
2
]
=
=
"
load
"
)
;
}
"
recorded
telemetry
for
the
load
"
)
;
loadEvent
.
shift
(
)
;
Assert
.
deepEqual
(
loadEvent
[
"
security
.
doh
.
neterror
"
"
load
"
"
dohwarning
"
"
NativeFallbackWarning
"
{
mode
:
"
2
"
provider_key
:
"
0
.
0
.
0
.
0
"
skip_reason
:
"
TRR_HEURISTIC_TRIPPED_CANARY
"
}
]
)
;
}
BrowserTestUtils
.
removeTab
(
gBrowser
.
selectedTab
)
;
}
add_task
(
async
function
nativeFallbackWarnings
(
)
{
Services
.
prefs
.
setBoolPref
(
"
network
.
dns
.
native
-
is
-
localhost
"
true
)
;
Services
.
prefs
.
setBoolPref
(
"
doh
-
rollout
.
disable
-
heuristics
"
true
)
;
Services
.
prefs
.
setCharPref
(
"
network
.
trr
.
uri
"
"
https
:
/
/
0
.
0
.
0
.
0
/
dns
-
query
"
)
;
registerCleanupFunction
(
reset
)
;
Services
.
prefs
.
setIntPref
(
"
network
.
trr
.
mode
"
Ci
.
nsIDNSService
.
MODE_NATIVEONLY
)
;
Services
.
dns
.
clearCache
(
true
)
;
await
verifyLoad
(
"
https
:
/
/
www
.
example
.
com
/
"
"
valid
url
no
error
"
)
;
await
verifyError
(
"
https
:
/
/
does
-
not
-
exist
.
test
"
false
"
non
existent
url
"
)
;
Services
.
prefs
.
setIntPref
(
"
network
.
proxy
.
type
"
0
)
;
Services
.
prefs
.
setIntPref
(
"
network
.
trr
.
mode
"
Ci
.
nsIRequest
.
TRR_FIRST_MODE
)
;
Services
.
prefs
.
setBoolPref
(
"
network
.
trr
.
display_fallback_warning
"
true
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
{
return
Services
.
dns
.
currentTrrMode
=
=
=
Ci
.
nsIRequest
.
TRR_FIRST_MODE
;
}
)
;
Services
.
dns
.
setHeuristicDetectionResult
(
Ci
.
nsITRRSkipReason
.
TRR_HEURISTIC_TRIPPED_CANARY
)
;
Services
.
dns
.
clearCache
(
true
)
;
await
verifyError
(
"
https
:
/
/
www
.
example
.
com
"
true
"
canary
heuristic
tripped
"
)
;
await
verifyError
(
"
https
:
/
/
does
-
not
-
exist
.
test
"
true
"
canary
heuristic
tripped
-
non
existent
url
"
)
;
reset
(
)
;
}
)
;
