"
use
strict
"
;
const
bookmarksInfo
=
[
{
title
:
"
firefox
"
url
:
"
http
:
/
/
example
.
com
"
}
{
title
:
"
rules
"
url
:
"
http
:
/
/
example
.
com
/
2
"
}
{
title
:
"
yo
"
url
:
"
http
:
/
/
example
.
com
/
2
"
}
]
;
async
function
emptyToolbarMessageVisible
(
visible
win
=
window
)
{
info
(
"
Empty
toolbar
message
should
be
"
+
(
visible
?
"
visible
"
:
"
hidden
"
)
)
;
let
emptyMessage
=
win
.
document
.
getElementById
(
"
personal
-
toolbar
-
empty
"
)
;
await
BrowserTestUtils
.
waitForMutationCondition
(
emptyMessage
{
attributes
:
true
attributeFilter
:
[
"
hidden
"
]
}
(
)
=
>
emptyMessage
.
hidden
!
=
visible
)
;
}
add_setup
(
async
function
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
newtab
.
preload
"
false
]
[
"
test
.
wait300msAfterTabSwitch
"
true
]
]
}
)
;
let
Bookmarks
=
PlacesUtils
.
bookmarks
;
let
toolbarBookmarks
=
[
]
;
let
unfiledBookmarks
=
[
]
;
let
guidBookmarkTuples
=
[
[
Bookmarks
.
toolbarGuid
toolbarBookmarks
]
[
Bookmarks
.
unfiledGuid
unfiledBookmarks
]
]
;
for
(
let
[
parentGuid
arr
]
of
guidBookmarkTuples
)
{
await
Bookmarks
.
fetch
(
{
parentGuid
}
bookmark
=
>
arr
.
push
(
bookmark
)
)
;
}
await
Promise
.
all
(
[
.
.
.
toolbarBookmarks
.
.
.
unfiledBookmarks
]
.
map
(
async
bookmark
=
>
{
bookmark
.
parentGuid
=
Bookmarks
.
menuGuid
;
return
Bookmarks
.
update
(
bookmark
)
;
}
)
)
;
registerCleanupFunction
(
async
(
)
=
>
{
for
(
let
[
parentGuid
arr
]
of
guidBookmarkTuples
)
{
await
Promise
.
all
(
arr
.
map
(
async
bookmark
=
>
{
bookmark
.
parentGuid
=
parentGuid
;
return
Bookmarks
.
update
(
bookmark
)
;
}
)
)
;
}
}
)
;
}
)
;
add_task
(
async
function
bookmarks_toolbar_not_shown_when_empty
(
)
{
let
bookmarks
=
await
PlacesUtils
.
bookmarks
.
insertTree
(
{
guid
:
PlacesUtils
.
bookmarks
.
toolbarGuid
children
:
bookmarksInfo
}
)
;
let
exampleTab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
{
gBrowser
opening
:
"
https
:
/
/
example
.
com
"
}
)
;
let
newtab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
{
gBrowser
opening
:
"
about
:
newtab
"
}
)
;
let
emptyMessage
=
document
.
getElementById
(
"
personal
-
toolbar
-
empty
"
)
;
let
placesItems
=
document
.
getElementById
(
"
PlacesToolbarItems
"
)
;
let
promiseBookmarksOnToolbar
=
BrowserTestUtils
.
waitForMutationCondition
(
placesItems
{
childList
:
true
}
(
)
=
>
placesItems
.
childNodes
.
length
)
;
await
waitForBookmarksToolbarVisibility
(
{
visible
:
true
message
:
"
Toolbar
should
be
visible
on
newtab
"
}
)
;
await
promiseBookmarksOnToolbar
;
await
emptyToolbarMessageVisible
(
false
)
;
let
promiseToolbar
=
waitForBookmarksToolbarVisibility
(
{
visible
:
false
message
:
"
Toolbar
should
be
hidden
on
example
.
com
"
}
)
;
await
BrowserTestUtils
.
switchTab
(
gBrowser
exampleTab
)
;
await
promiseToolbar
;
CustomizableUI
.
addWidgetToArea
(
"
personal
-
bookmarks
"
CustomizableUI
.
AREA_TABSTRIP
)
;
CustomizableUI
.
removeWidgetFromArea
(
"
import
-
button
"
)
;
await
BrowserTestUtils
.
switchTab
(
gBrowser
newtab
)
;
await
waitForBookmarksToolbarVisibility
(
{
visible
:
true
message
:
"
Toolbar
is
visible
when
there
are
no
items
in
the
toolbar
area
"
}
)
;
await
emptyToolbarMessageVisible
(
true
)
;
let
winPromise
=
BrowserTestUtils
.
domWindowOpenedAndLoaded
(
)
;
EventUtils
.
synthesizeMouseAtCenter
(
emptyMessage
.
querySelector
(
"
.
text
-
link
"
)
{
}
)
;
let
libraryWin
=
await
winPromise
;
is
(
libraryWin
.
document
.
location
.
href
"
chrome
:
/
/
browser
/
content
/
places
/
places
.
xhtml
"
"
Should
have
opened
library
.
"
)
;
await
BrowserTestUtils
.
closeWindow
(
libraryWin
)
;
CustomizableUI
.
addWidgetToArea
(
"
personal
-
bookmarks
"
CustomizableUI
.
AREA_BOOKMARKS
)
;
await
BrowserTestUtils
.
switchTab
(
gBrowser
exampleTab
)
;
await
BrowserTestUtils
.
switchTab
(
gBrowser
newtab
)
;
promiseBookmarksOnToolbar
=
BrowserTestUtils
.
waitForMutationCondition
(
placesItems
{
childList
:
true
}
(
)
=
>
placesItems
.
childNodes
.
length
)
;
await
waitForBookmarksToolbarVisibility
(
{
visible
:
true
message
:
"
Toolbar
should
be
visible
with
Bookmarks
Toolbar
Items
restored
"
}
)
;
await
promiseBookmarksOnToolbar
;
await
emptyToolbarMessageVisible
(
false
)
;
await
PlacesUtils
.
bookmarks
.
remove
(
bookmarks
)
;
await
BrowserTestUtils
.
switchTab
(
gBrowser
exampleTab
)
;
await
BrowserTestUtils
.
switchTab
(
gBrowser
newtab
)
;
await
waitForBookmarksToolbarVisibility
(
{
visible
:
true
message
:
"
Toolbar
is
visible
when
there
are
no
items
or
nested
bookmarks
in
the
toolbar
area
"
}
)
;
await
emptyToolbarMessageVisible
(
true
)
;
CustomizableUI
.
addWidgetToArea
(
"
characterencoding
-
button
"
CustomizableUI
.
AREA_BOOKMARKS
)
;
await
BrowserTestUtils
.
switchTab
(
gBrowser
exampleTab
)
;
await
BrowserTestUtils
.
switchTab
(
gBrowser
newtab
)
;
await
waitForBookmarksToolbarVisibility
(
{
visible
:
true
message
:
"
Toolbar
is
visible
when
there
is
a
visible
button
in
the
toolbar
"
}
)
;
await
emptyToolbarMessageVisible
(
false
)
;
await
BrowserTestUtils
.
removeTab
(
newtab
)
;
await
BrowserTestUtils
.
removeTab
(
exampleTab
)
;
CustomizableUI
.
reset
(
)
;
}
)
;
