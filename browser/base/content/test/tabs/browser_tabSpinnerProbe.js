"
use
strict
"
;
const
MIN_HANG_TIME
=
500
;
const
MAX_HANG_TIME
=
5
*
1000
;
function
sum
(
aArray
)
{
return
aArray
.
reduce
(
function
(
previousValue
currentValue
)
{
return
previousValue
+
currentValue
;
}
)
;
}
function
hangContentProcess
(
browser
aMs
)
{
return
ContentTask
.
spawn
(
browser
aMs
async
function
(
ms
)
{
let
then
=
Date
.
now
(
)
;
while
(
Date
.
now
(
)
-
then
<
ms
)
{
}
}
)
;
}
async
function
testProbe
(
aProbe
)
{
info
(
Testing
probe
:
{
aProbe
}
)
;
let
histogram
=
Services
.
telemetry
.
getHistogramById
(
aProbe
)
;
let
buckets
=
histogram
.
snapshot
(
)
.
ranges
.
filter
(
function
(
value
)
{
return
(
value
>
MIN_HANG_TIME
&
&
value
<
MAX_HANG_TIME
)
;
}
)
;
let
delayTime
=
buckets
[
0
]
;
delayTime
+
=
gBrowser
.
selectedTab
.
linkedBrowser
.
getTabBrowser
(
)
.
_getSwitcher
(
)
.
TAB_SWITCH_TIMEOUT
;
let
origTab
=
gBrowser
.
selectedTab
;
let
hangTab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
)
;
let
hangBrowser
=
hangTab
.
linkedBrowser
;
ok
(
hangBrowser
.
isRemoteBrowser
"
New
tab
should
be
remote
.
"
)
;
ok
(
hangBrowser
.
frameLoader
.
tabParent
.
hasPresented
"
New
tab
has
presented
.
"
)
;
await
BrowserTestUtils
.
switchTab
(
gBrowser
origTab
)
;
let
tabHangPromise
=
hangContentProcess
(
hangBrowser
delayTime
)
;
histogram
.
clear
(
)
;
let
hangTabSwitch
=
BrowserTestUtils
.
switchTab
(
gBrowser
hangTab
)
;
await
tabHangPromise
;
await
hangTabSwitch
;
let
snapshot
=
histogram
.
snapshot
(
)
;
BrowserTestUtils
.
removeTab
(
hangTab
)
;
ok
(
sum
(
snapshot
.
counts
)
>
0
Spinner
probe
should
now
have
a
value
in
some
bucket
)
;
}
add_task
(
async
function
setup
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
dom
.
ipc
.
processCount
"
1
]
[
"
browser
.
tabs
.
remote
.
force
-
paint
"
false
]
]
}
)
;
}
)
;
add_task
(
testProbe
.
bind
(
null
"
FX_TAB_SWITCH_SPINNER_VISIBLE_MS
"
)
)
;
add_task
(
testProbe
.
bind
(
null
"
FX_TAB_SWITCH_SPINNER_VISIBLE_LONG_MS
"
)
)
;
