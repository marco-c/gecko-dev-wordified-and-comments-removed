"
use
strict
"
;
const
{
TabStateFlusher
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
/
modules
/
sessionstore
/
TabStateFlusher
.
jsm
"
)
;
const
CATEGORIES
=
[
"
stop
"
"
back
"
"
forward
"
"
historyNavigation
"
"
reload
"
"
tabClosed
"
"
newURI
"
]
;
const
PAGE_2
=
"
data
:
text
/
html
<
html
>
Page
2
<
/
html
>
"
;
const
PROBE_TESTS
=
[
{
name
:
"
Stopping
the
browser
"
category
:
"
stop
"
prepare
(
browser
)
{
}
doAction
(
browser
)
{
document
.
getElementById
(
"
Browser
:
Stop
"
)
.
doCommand
(
)
;
}
}
{
name
:
"
Going
back
to
a
previous
page
"
category
:
"
back
"
async
prepare
(
browser
)
{
BrowserTestUtils
.
loadURI
(
browser
PAGE_2
)
;
await
BrowserTestUtils
.
browserLoaded
(
browser
)
;
}
async
doAction
(
browser
)
{
let
pageShow
=
BrowserTestUtils
.
waitForContentEvent
(
browser
"
pageshow
"
)
;
document
.
getElementById
(
"
Browser
:
Back
"
)
.
doCommand
(
)
;
await
pageShow
;
}
}
{
name
:
"
Going
forward
to
the
next
page
"
category
:
"
forward
"
async
prepare
(
browser
)
{
BrowserTestUtils
.
loadURI
(
browser
PAGE_2
)
;
await
BrowserTestUtils
.
browserLoaded
(
browser
)
;
let
pageShow
=
BrowserTestUtils
.
waitForContentEvent
(
browser
"
pageshow
"
)
;
browser
.
goBack
(
)
;
await
pageShow
;
}
async
doAction
(
browser
)
{
let
pageShow
=
BrowserTestUtils
.
waitForContentEvent
(
browser
"
pageshow
"
)
;
document
.
getElementById
(
"
Browser
:
Forward
"
)
.
doCommand
(
)
;
await
pageShow
;
}
}
{
name
:
"
Going
backward
to
a
previous
page
via
gotoIndex
"
category
:
"
historyNavigation
"
async
prepare
(
browser
)
{
BrowserTestUtils
.
loadURI
(
browser
PAGE_2
)
;
await
BrowserTestUtils
.
browserLoaded
(
browser
)
;
BrowserTestUtils
.
loadURI
(
browser
"
http
:
/
/
example
.
com
"
)
;
await
BrowserTestUtils
.
browserLoaded
(
browser
)
;
await
TabStateFlusher
.
flush
(
browser
)
;
}
async
doAction
(
browser
)
{
let
pageShow
=
BrowserTestUtils
.
waitForContentEvent
(
browser
"
pageshow
"
)
;
synthesizeHistoryNavigationToIndex
(
0
)
;
await
pageShow
;
}
}
{
name
:
"
Going
forward
to
a
previous
page
via
gotoIndex
"
category
:
"
historyNavigation
"
async
prepare
(
browser
)
{
BrowserTestUtils
.
loadURI
(
browser
PAGE_2
)
;
await
BrowserTestUtils
.
browserLoaded
(
browser
)
;
BrowserTestUtils
.
loadURI
(
browser
"
http
:
/
/
example
.
com
"
)
;
await
BrowserTestUtils
.
browserLoaded
(
browser
)
;
let
pageShow
=
BrowserTestUtils
.
waitForContentEvent
(
browser
"
pageshow
"
)
;
browser
.
gotoIndex
(
0
)
;
await
pageShow
;
await
TabStateFlusher
.
flush
(
browser
)
;
}
async
doAction
(
browser
)
{
let
pageShow
=
BrowserTestUtils
.
waitForContentEvent
(
browser
"
pageshow
"
)
;
synthesizeHistoryNavigationToIndex
(
2
)
;
await
pageShow
;
}
}
{
name
:
"
Reloading
the
browser
"
category
:
"
reload
"
prepare
(
browser
)
{
}
async
doAction
(
browser
)
{
document
.
getElementById
(
"
Browser
:
Reload
"
)
.
doCommand
(
)
;
await
BrowserTestUtils
.
browserLoaded
(
browser
)
;
}
}
{
name
:
"
Browsing
to
a
new
URL
"
category
:
"
newURI
"
prepare
(
browser
)
{
}
async
doAction
(
browser
)
{
openTrustedLinkIn
(
PAGE_2
"
current
"
)
;
await
BrowserTestUtils
.
browserLoaded
(
browser
)
;
}
}
]
;
function
assertOnlyOneTypeSet
(
snapshot
category
)
{
let
categoryIndex
=
CATEGORIES
.
indexOf
(
category
)
;
Assert
.
equal
(
snapshot
.
values
[
categoryIndex
]
1
Should
have
seen
the
{
category
}
count
increment
.
)
;
Assert
.
equal
(
Object
.
values
(
snapshot
.
values
)
.
reduce
(
(
a
b
)
=
>
a
+
b
0
)
1
"
Should
only
be
1
collected
value
.
"
)
;
}
function
synthesizeHistoryNavigationToIndex
(
index
)
{
let
popup
=
document
.
getElementById
(
"
backForwardMenu
"
)
;
FillHistoryMenu
(
popup
)
;
Assert
.
ok
(
popup
.
childElementCount
>
0
"
Should
have
some
items
in
the
back
/
forward
menu
"
)
;
let
menuitem
=
popup
.
querySelector
(
menuitem
[
index
=
"
{
index
}
"
]
)
;
Assert
.
ok
(
menuitem
Should
find
a
menuitem
with
index
{
index
}
)
;
let
cmdEvent
=
new
CustomEvent
(
"
command
"
{
bubbles
:
true
cancelable
:
true
}
)
;
menuitem
.
dispatchEvent
(
cmdEvent
)
;
}
add_task
(
async
function
test_probes
(
)
{
let
oldCanRecord
=
Services
.
telemetry
.
canRecordExtended
;
Services
.
telemetry
.
canRecordExtended
=
true
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
telemetry
.
canRecordExtended
=
oldCanRecord
;
}
)
;
let
histogram
=
Services
.
telemetry
.
getHistogramById
(
"
BUSY_TAB_ABANDONED
"
)
;
for
(
let
probeTest
of
PROBE_TESTS
)
{
await
BrowserTestUtils
.
withNewTab
(
{
gBrowser
url
:
"
http
:
/
/
example
.
com
"
}
async
function
(
browser
)
{
let
tab
=
gBrowser
.
getTabForBrowser
(
browser
)
;
info
(
Test
:
"
{
probeTest
.
name
}
"
)
;
await
probeTest
.
prepare
(
browser
)
;
tab
.
setAttribute
(
"
busy
"
true
)
;
histogram
.
clear
(
)
;
await
probeTest
.
doAction
(
browser
)
;
let
snapshot
=
histogram
.
snapshot
(
)
;
assertOnlyOneTypeSet
(
snapshot
probeTest
.
category
)
;
}
)
;
}
histogram
.
clear
(
)
;
let
newTab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
)
;
newTab
.
setAttribute
(
"
busy
"
true
)
;
BrowserTestUtils
.
removeTab
(
newTab
)
;
let
snapshot
=
histogram
.
snapshot
(
)
;
assertOnlyOneTypeSet
(
snapshot
"
tabClosed
"
)
;
}
)
;
