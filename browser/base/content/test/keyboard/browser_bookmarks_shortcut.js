"
use
strict
"
;
add_setup
(
async
function
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
test
.
wait300msAfterTabSwitch
"
true
]
]
}
)
;
}
)
;
add_task
(
async
function
testBookmarksToolbarShortcut
(
)
{
let
blankTab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
{
gBrowser
opening
:
"
example
.
com
"
waitForLoad
:
false
}
)
;
info
(
"
Toggle
toolbar
visibility
on
"
)
;
let
toolbar
=
document
.
getElementById
(
"
PersonalToolbar
"
)
;
ok
(
toolbar
.
hasAttribute
(
"
collapsed
"
)
"
Toolbar
bar
should
already
be
collapsed
"
)
;
EventUtils
.
synthesizeKey
(
"
b
"
{
shiftKey
:
true
accelKey
:
true
}
)
;
toolbar
=
document
.
getElementById
(
"
PersonalToolbar
"
)
;
await
BrowserTestUtils
.
waitForAttributeRemoval
(
"
collapsed
"
toolbar
)
;
ok
(
true
"
bookmarks
toolbar
is
visible
"
)
;
await
testIsBookmarksMenuItemStateChecked
(
"
always
"
)
;
info
(
"
Toggle
toolbar
visibility
off
"
)
;
EventUtils
.
synthesizeKey
(
"
b
"
{
shiftKey
:
true
accelKey
:
true
}
)
;
toolbar
=
document
.
getElementById
(
"
PersonalToolbar
"
)
;
await
BrowserTestUtils
.
waitForAttribute
(
"
collapsed
"
toolbar
"
"
)
;
ok
(
true
"
bookmarks
toolbar
is
not
visible
"
)
;
await
testIsBookmarksMenuItemStateChecked
(
"
never
"
)
;
await
BrowserTestUtils
.
removeTab
(
blankTab
)
;
}
)
;
add_task
(
async
function
testNewBookmarksLibraryShortcut
(
)
{
let
blankTab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
{
gBrowser
opening
:
"
example
.
com
"
waitForLoad
:
false
}
)
;
info
(
"
Check
that
the
bookmarks
library
windows
opens
.
"
)
;
let
bookmarksLibraryOpened
=
promiseOpenBookmarksLibrary
(
)
;
await
EventUtils
.
synthesizeKey
(
"
o
"
{
shiftKey
:
true
accelKey
:
true
}
)
;
let
win
=
await
bookmarksLibraryOpened
;
ok
(
true
"
Bookmarks
library
successfully
opened
.
"
)
;
win
.
close
(
)
;
await
BrowserTestUtils
.
removeTab
(
blankTab
)
;
}
)
;
async
function
testIsBookmarksMenuItemStateChecked
(
expected
)
{
info
(
"
Test
that
the
toolbar
menuitem
state
is
correct
.
"
)
;
let
contextMenu
=
document
.
getElementById
(
"
toolbar
-
context
-
menu
"
)
;
let
target
=
document
.
getElementById
(
"
PanelUI
-
menu
-
button
"
)
;
await
openContextMenu
(
contextMenu
target
)
;
let
menuitems
=
[
"
always
"
"
never
"
"
newtab
"
]
.
map
(
e
=
>
document
.
querySelector
(
menuitem
[
data
-
visibility
-
enum
=
"
{
e
}
"
]
)
)
;
let
checkedItem
=
menuitems
.
filter
(
m
=
>
m
.
hasAttribute
(
"
checked
"
)
)
;
is
(
checkedItem
.
length
1
"
should
have
only
one
menuitem
checked
"
)
;
is
(
checkedItem
[
0
]
.
dataset
.
visibilityEnum
expected
checked
menuitem
should
be
{
expected
}
)
;
for
(
let
menuitem
of
menuitems
)
{
if
(
menuitem
.
dataset
.
visibilityEnum
=
=
expected
)
{
ok
(
!
menuitem
.
hasAttribute
(
"
key
"
)
"
dont
show
shortcut
on
current
state
"
)
;
}
else
{
is
(
menuitem
.
hasAttribute
(
"
key
"
)
menuitem
.
dataset
.
visibilityEnum
!
=
"
newtab
"
"
shortcut
is
on
the
menuitem
opposite
of
the
current
state
excluding
newtab
"
)
;
}
}
await
closeContextMenu
(
contextMenu
)
;
}
async
function
promiseOpenBookmarksLibrary
(
)
{
return
BrowserTestUtils
.
domWindowOpened
(
null
async
win
=
>
{
await
BrowserTestUtils
.
waitForEvent
(
win
"
load
"
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
win
.
document
.
documentURI
=
=
=
"
chrome
:
/
/
browser
/
content
/
places
/
places
.
xhtml
"
)
;
return
true
;
}
)
;
}
async
function
openContextMenu
(
contextMenu
target
)
{
info
(
"
Opening
context
menu
.
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
target
{
type
:
"
contextmenu
"
}
)
;
await
BrowserTestUtils
.
waitForPopupEvent
(
contextMenu
"
shown
"
)
;
let
bookmarksToolbarMenu
=
document
.
querySelector
(
"
#
toggle_PersonalToolbar
"
)
;
let
subMenu
=
bookmarksToolbarMenu
.
querySelector
(
"
menupopup
"
)
;
bookmarksToolbarMenu
.
openMenu
(
true
)
;
await
BrowserTestUtils
.
waitForPopupEvent
(
subMenu
"
shown
"
)
;
}
async
function
closeContextMenu
(
contextMenu
)
{
info
(
"
Closing
context
menu
.
"
)
;
contextMenu
.
hidePopup
(
)
;
await
BrowserTestUtils
.
waitForPopupEvent
(
contextMenu
"
hidden
"
)
;
}
