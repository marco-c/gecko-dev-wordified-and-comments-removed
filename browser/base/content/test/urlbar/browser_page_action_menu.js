"
use
strict
"
;
const
mockRemoteClients
=
[
{
id
:
"
0
"
name
:
"
foo
"
type
:
"
mobile
"
}
{
id
:
"
1
"
name
:
"
bar
"
type
:
"
desktop
"
}
{
id
:
"
2
"
name
:
"
baz
"
type
:
"
mobile
"
}
]
;
add_task
(
async
function
bookmark
(
)
{
let
url
=
"
http
:
/
/
example
.
com
/
browser_page_action_menu
"
;
await
BrowserTestUtils
.
withNewTab
(
url
async
(
)
=
>
{
await
promisePageActionPanelOpen
(
)
;
let
bookmarkButton
=
document
.
getElementById
(
"
page
-
action
-
bookmark
-
button
"
)
;
Assert
.
equal
(
bookmarkButton
.
label
"
Bookmark
This
Page
"
)
;
Assert
.
ok
(
!
bookmarkButton
.
hasAttribute
(
"
starred
"
)
)
;
let
hiddenPromise
=
promisePageActionPanelHidden
(
)
;
EventUtils
.
synthesizeMouseAtCenter
(
bookmarkButton
{
}
)
;
await
hiddenPromise
;
await
new
Promise
(
resolve
=
>
{
if
(
StarUI
.
panel
.
state
=
=
"
open
"
)
{
resolve
(
)
;
return
;
}
StarUI
.
panel
.
addEventListener
(
"
popupshown
"
resolve
{
once
:
true
}
)
;
}
)
;
StarUI
.
panel
.
hidePopup
(
)
;
await
promisePageActionPanelOpen
(
)
;
Assert
.
equal
(
bookmarkButton
.
label
"
Edit
This
Bookmark
"
)
;
Assert
.
ok
(
bookmarkButton
.
hasAttribute
(
"
starred
"
)
)
;
Assert
.
equal
(
bookmarkButton
.
getAttribute
(
"
starred
"
)
"
true
"
)
;
hiddenPromise
=
promisePageActionPanelHidden
(
)
;
EventUtils
.
synthesizeMouseAtCenter
(
bookmarkButton
{
}
)
;
await
hiddenPromise
;
await
new
Promise
(
resolve
=
>
{
if
(
StarUI
.
panel
.
state
=
=
"
open
"
)
{
resolve
(
)
;
return
;
}
StarUI
.
panel
.
addEventListener
(
"
popupshown
"
resolve
{
once
:
true
}
)
;
}
)
;
let
onItemRemovedPromise
=
PlacesTestUtils
.
waitForNotification
(
"
onItemRemoved
"
(
id
parentId
index
type
itemUrl
)
=
>
url
=
=
itemUrl
.
spec
)
;
StarUI
.
_element
(
"
editBookmarkPanelRemoveButton
"
)
.
click
(
)
;
await
onItemRemovedPromise
;
await
promisePageActionPanelOpen
(
)
;
Assert
.
equal
(
bookmarkButton
.
label
"
Bookmark
This
Page
"
)
;
Assert
.
ok
(
!
bookmarkButton
.
hasAttribute
(
"
starred
"
)
)
;
hiddenPromise
=
promisePageActionPanelHidden
(
)
;
gPageActionPanel
.
hidePopup
(
)
;
await
hiddenPromise
;
}
)
;
}
)
;
add_task
(
async
function
emailLink
(
)
{
let
originalFn
=
MailIntegration
.
sendLinkForBrowser
;
let
fnCalled
=
false
;
MailIntegration
.
sendLinkForBrowser
=
(
)
=
>
{
fnCalled
=
true
;
}
;
registerCleanupFunction
(
(
)
=
>
{
MailIntegration
.
sendLinkForBrowser
=
originalFn
;
}
)
;
await
promisePageActionPanelOpen
(
)
;
let
emailLinkButton
=
document
.
getElementById
(
"
page
-
action
-
email
-
link
-
button
"
)
;
let
hiddenPromise
=
promisePageActionPanelHidden
(
)
;
EventUtils
.
synthesizeMouseAtCenter
(
emailLinkButton
{
}
)
;
await
hiddenPromise
;
Assert
.
ok
(
fnCalled
)
;
}
)
;
add_task
(
async
function
sendToDevice_nonSendable
(
)
{
await
BrowserTestUtils
.
withNewTab
(
"
about
:
blank
"
async
(
)
=
>
{
await
promisePageActionPanelOpen
(
)
;
let
sendToDeviceButton
=
document
.
getElementById
(
"
page
-
action
-
send
-
to
-
device
-
button
"
)
;
Assert
.
ok
(
sendToDeviceButton
.
disabled
)
;
let
hiddenPromise
=
promisePageActionPanelHidden
(
)
;
gPageActionPanel
.
hidePopup
(
)
;
await
hiddenPromise
;
}
)
;
}
)
;
add_task
(
async
function
sendToDevice_syncNotReady
(
)
{
await
BrowserTestUtils
.
withNewTab
(
"
http
:
/
/
example
.
com
/
"
async
(
)
=
>
{
let
syncReadyMock
=
mockReturn
(
gSync
"
syncReady
"
false
)
;
let
signedInMock
=
mockReturn
(
gSync
"
isSignedIn
"
true
)
;
let
remoteClientsMock
;
let
origSync
=
Weave
.
Service
.
sync
;
Weave
.
Service
.
sync
=
(
)
=
>
{
mockReturn
(
gSync
"
syncReady
"
true
)
;
remoteClientsMock
=
mockReturn
(
gSync
"
remoteClients
"
mockRemoteClients
)
;
}
;
let
origSetupSendToDeviceView
=
gPageActionButton
.
setupSendToDeviceView
;
gPageActionButton
.
setupSendToDeviceView
=
(
)
=
>
{
this
.
numCall
+
+
|
|
(
this
.
numCall
=
1
)
;
origSetupSendToDeviceView
.
call
(
gPageActionButton
)
;
testSendTabToDeviceMenu
(
this
.
numCall
)
;
}
let
cleanUp
=
(
)
=
>
{
Weave
.
Service
.
sync
=
origSync
;
gPageActionButton
.
setupSendToDeviceView
=
origSetupSendToDeviceView
;
signedInMock
.
restore
(
)
;
syncReadyMock
.
restore
(
)
;
remoteClientsMock
.
restore
(
)
;
}
;
registerCleanupFunction
(
cleanUp
)
;
await
promisePageActionPanelOpen
(
)
;
let
sendToDeviceButton
=
document
.
getElementById
(
"
page
-
action
-
send
-
to
-
device
-
button
"
)
;
Assert
.
ok
(
!
sendToDeviceButton
.
disabled
)
;
let
viewPromise
=
promisePageActionViewShown
(
)
;
EventUtils
.
synthesizeMouseAtCenter
(
sendToDeviceButton
{
}
)
;
let
view
=
await
viewPromise
;
Assert
.
equal
(
view
.
id
"
page
-
action
-
sendToDeviceView
"
)
;
function
testSendTabToDeviceMenu
(
numCall
)
{
if
(
numCall
=
=
1
)
{
checkSendToDeviceItems
(
[
{
id
:
"
page
-
action
-
sendToDevice
-
fxa
-
button
"
display
:
"
none
"
}
{
id
:
"
page
-
action
-
no
-
devices
-
button
"
display
:
"
none
"
disabled
:
true
}
{
id
:
"
page
-
action
-
sync
-
not
-
ready
-
button
"
disabled
:
true
}
]
)
;
}
else
if
(
numCall
=
=
2
)
{
let
expectedItems
=
[
{
id
:
"
page
-
action
-
sendToDevice
-
fxa
-
button
"
display
:
"
none
"
}
{
id
:
"
page
-
action
-
no
-
devices
-
button
"
display
:
"
none
"
disabled
:
true
}
{
id
:
"
page
-
action
-
sync
-
not
-
ready
-
button
"
display
:
"
none
"
disabled
:
true
}
]
;
for
(
let
client
of
mockRemoteClients
)
{
expectedItems
.
push
(
{
attrs
:
{
clientId
:
client
.
id
label
:
client
.
name
clientType
:
client
.
type
}
}
)
;
}
expectedItems
.
push
(
null
{
label
:
"
Send
to
All
Devices
"
}
)
;
checkSendToDeviceItems
(
expectedItems
)
;
}
else
{
ok
(
false
"
This
should
never
happen
"
)
;
}
}
let
hiddenPromise
=
promisePageActionPanelHidden
(
)
;
gPageActionPanel
.
hidePopup
(
)
;
await
hiddenPromise
;
cleanUp
(
)
;
}
)
;
}
)
;
add_task
(
async
function
sendToDevice_notSignedIn
(
)
{
await
BrowserTestUtils
.
withNewTab
(
"
http
:
/
/
example
.
com
/
"
async
(
)
=
>
{
await
promiseSyncReady
(
)
;
await
promisePageActionPanelOpen
(
)
;
let
sendToDeviceButton
=
document
.
getElementById
(
"
page
-
action
-
send
-
to
-
device
-
button
"
)
;
Assert
.
ok
(
!
sendToDeviceButton
.
disabled
)
;
let
viewPromise
=
promisePageActionViewShown
(
)
;
EventUtils
.
synthesizeMouseAtCenter
(
sendToDeviceButton
{
}
)
;
let
view
=
await
viewPromise
;
Assert
.
equal
(
view
.
id
"
page
-
action
-
sendToDeviceView
"
)
;
checkSendToDeviceItems
(
[
{
id
:
"
page
-
action
-
sendToDevice
-
fxa
-
button
"
}
{
id
:
"
page
-
action
-
no
-
devices
-
button
"
display
:
"
none
"
disabled
:
true
}
{
id
:
"
page
-
action
-
sync
-
not
-
ready
-
button
"
display
:
"
none
"
disabled
:
true
}
]
)
;
let
body
=
view
.
firstChild
;
let
fxaButton
=
body
.
childNodes
[
0
]
;
Assert
.
equal
(
fxaButton
.
id
"
page
-
action
-
sendToDevice
-
fxa
-
button
"
)
;
let
prefsTabPromise
=
BrowserTestUtils
.
waitForNewTab
(
gBrowser
)
;
let
hiddenPromise
=
promisePageActionPanelHidden
(
)
;
EventUtils
.
synthesizeMouseAtCenter
(
fxaButton
{
}
)
;
let
values
=
await
Promise
.
all
(
[
prefsTabPromise
hiddenPromise
]
)
;
let
tab
=
values
[
0
]
;
let
urlObj
=
new
URL
(
gBrowser
.
selectedBrowser
.
currentURI
.
spec
)
;
let
url
=
urlObj
.
protocol
+
urlObj
.
pathname
+
urlObj
.
hash
;
Assert
.
equal
(
url
"
about
:
preferences
#
sync
"
)
;
await
BrowserTestUtils
.
removeTab
(
tab
)
;
}
)
;
}
)
;
add_task
(
async
function
sendToDevice_noDevices
(
)
{
await
BrowserTestUtils
.
withNewTab
(
"
http
:
/
/
example
.
com
/
"
async
(
)
=
>
{
await
promiseSyncReady
(
)
;
UIState
.
_internal
.
_state
=
{
status
:
UIState
.
STATUS_SIGNED_IN
}
;
await
promisePageActionPanelOpen
(
)
;
let
sendToDeviceButton
=
document
.
getElementById
(
"
page
-
action
-
send
-
to
-
device
-
button
"
)
;
Assert
.
ok
(
!
sendToDeviceButton
.
disabled
)
;
let
viewPromise
=
promisePageActionViewShown
(
)
;
EventUtils
.
synthesizeMouseAtCenter
(
sendToDeviceButton
{
}
)
;
let
view
=
await
viewPromise
;
Assert
.
equal
(
view
.
id
"
page
-
action
-
sendToDeviceView
"
)
;
checkSendToDeviceItems
(
[
{
id
:
"
page
-
action
-
sendToDevice
-
fxa
-
button
"
display
:
"
none
"
}
{
id
:
"
page
-
action
-
no
-
devices
-
button
"
disabled
:
true
}
{
id
:
"
page
-
action
-
sync
-
not
-
ready
-
button
"
display
:
"
none
"
disabled
:
true
}
]
)
;
let
hiddenPromise
=
promisePageActionPanelHidden
(
)
;
gPageActionPanel
.
hidePopup
(
)
;
await
hiddenPromise
;
await
UIState
.
reset
(
)
;
}
)
;
}
)
;
add_task
(
async
function
sendToDevice_devices
(
)
{
await
BrowserTestUtils
.
withNewTab
(
"
http
:
/
/
example
.
com
/
"
async
(
)
=
>
{
await
promiseSyncReady
(
)
;
UIState
.
_internal
.
_state
=
{
status
:
UIState
.
STATUS_SIGNED_IN
}
;
let
remoteClientsMock
=
mockReturn
(
gSync
"
remoteClients
"
mockRemoteClients
)
;
let
cleanUp
=
(
)
=
>
{
remoteClientsMock
.
restore
(
)
;
}
;
registerCleanupFunction
(
cleanUp
)
;
await
promisePageActionPanelOpen
(
)
;
let
sendToDeviceButton
=
document
.
getElementById
(
"
page
-
action
-
send
-
to
-
device
-
button
"
)
;
Assert
.
ok
(
!
sendToDeviceButton
.
disabled
)
;
let
viewPromise
=
promisePageActionViewShown
(
)
;
EventUtils
.
synthesizeMouseAtCenter
(
sendToDeviceButton
{
}
)
;
let
view
=
await
viewPromise
;
Assert
.
equal
(
view
.
id
"
page
-
action
-
sendToDeviceView
"
)
;
let
expectedItems
=
[
{
id
:
"
page
-
action
-
sendToDevice
-
fxa
-
button
"
display
:
"
none
"
}
{
id
:
"
page
-
action
-
no
-
devices
-
button
"
display
:
"
none
"
disabled
:
true
}
{
id
:
"
page
-
action
-
sync
-
not
-
ready
-
button
"
display
:
"
none
"
disabled
:
true
}
]
;
for
(
let
client
of
mockRemoteClients
)
{
expectedItems
.
push
(
{
attrs
:
{
clientId
:
client
.
id
label
:
client
.
name
clientType
:
client
.
type
}
}
)
;
}
expectedItems
.
push
(
null
{
label
:
"
Send
to
All
Devices
"
}
)
;
checkSendToDeviceItems
(
expectedItems
)
;
let
hiddenPromise
=
promisePageActionPanelHidden
(
)
;
gPageActionPanel
.
hidePopup
(
)
;
await
hiddenPromise
;
cleanUp
(
)
;
await
UIState
.
reset
(
)
;
}
)
;
}
)
;
function
promiseSyncReady
(
)
{
let
service
=
Cc
[
"
mozilla
.
org
/
weave
/
service
;
1
"
]
.
getService
(
Components
.
interfaces
.
nsISupports
)
.
wrappedJSObject
;
return
service
.
whenLoaded
(
)
.
then
(
(
)
=
>
{
UIState
.
isReady
(
)
;
return
UIState
.
refresh
(
)
;
}
)
;
}
function
checkSendToDeviceItems
(
expectedItems
)
{
let
body
=
document
.
getElementById
(
"
page
-
action
-
sendToDeviceView
-
body
"
)
;
Assert
.
equal
(
body
.
childNodes
.
length
expectedItems
.
length
)
;
for
(
let
i
=
0
;
i
<
expectedItems
.
length
;
i
+
+
)
{
let
expected
=
expectedItems
[
i
]
;
let
actual
=
body
.
childNodes
[
i
]
;
if
(
!
expected
)
{
Assert
.
equal
(
actual
.
localName
"
toolbarseparator
"
)
;
continue
;
}
if
(
"
id
"
in
expected
)
{
Assert
.
equal
(
actual
.
id
expected
.
id
)
;
}
let
display
=
"
display
"
in
expected
?
expected
.
display
:
"
-
moz
-
box
"
;
Assert
.
equal
(
getComputedStyle
(
actual
)
.
display
display
)
;
let
disabled
=
"
disabled
"
in
expected
?
expected
.
disabled
:
false
;
Assert
.
equal
(
actual
.
disabled
disabled
)
;
if
(
"
attrs
"
in
expected
)
{
for
(
let
name
in
expected
.
attrs
)
{
Assert
.
ok
(
actual
.
hasAttribute
(
name
)
)
;
Assert
.
equal
(
actual
.
getAttribute
(
name
)
expected
.
attrs
[
name
]
)
;
}
}
}
}
function
mockReturn
(
obj
symbol
fixture
)
{
let
getter
=
Object
.
getOwnPropertyDescriptor
(
obj
symbol
)
.
get
;
if
(
getter
)
{
Object
.
defineProperty
(
obj
symbol
{
get
(
)
{
return
fixture
;
}
}
)
;
return
{
restore
(
)
{
Object
.
defineProperty
(
obj
symbol
{
get
:
getter
}
)
;
}
}
}
let
func
=
obj
[
symbol
]
;
obj
[
symbol
]
=
(
)
=
>
fixture
;
return
{
restore
(
)
{
obj
[
symbol
]
=
func
;
}
}
}
