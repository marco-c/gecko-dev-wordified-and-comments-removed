"
use
strict
"
;
Services
.
scriptloader
.
loadSubScript
(
"
resource
:
/
/
testing
-
common
/
sinon
-
2
.
3
.
2
.
js
"
)
;
registerCleanupFunction
(
function
(
)
{
delete
window
.
sinon
;
}
)
;
const
mockRemoteClients
=
[
{
id
:
"
0
"
name
:
"
foo
"
type
:
"
mobile
"
}
{
id
:
"
1
"
name
:
"
bar
"
type
:
"
desktop
"
}
{
id
:
"
2
"
name
:
"
baz
"
type
:
"
mobile
"
}
]
;
add_task
(
async
function
bookmark
(
)
{
let
url
=
"
http
:
/
/
example
.
com
/
browser_page_action_menu
"
;
await
BrowserTestUtils
.
withNewTab
(
url
async
(
)
=
>
{
await
promisePageActionPanelOpen
(
)
;
let
bookmarkButton
=
document
.
getElementById
(
"
page
-
action
-
bookmark
-
button
"
)
;
Assert
.
equal
(
bookmarkButton
.
label
"
Bookmark
This
Page
"
)
;
Assert
.
ok
(
!
bookmarkButton
.
hasAttribute
(
"
starred
"
)
)
;
let
hiddenPromise
=
promisePageActionPanelHidden
(
)
;
EventUtils
.
synthesizeMouseAtCenter
(
bookmarkButton
{
}
)
;
await
hiddenPromise
;
await
new
Promise
(
resolve
=
>
{
if
(
StarUI
.
panel
.
state
=
=
"
open
"
)
{
resolve
(
)
;
return
;
}
StarUI
.
panel
.
addEventListener
(
"
popupshown
"
resolve
{
once
:
true
}
)
;
}
)
;
StarUI
.
panel
.
hidePopup
(
)
;
await
promisePageActionPanelOpen
(
)
;
Assert
.
equal
(
bookmarkButton
.
label
"
Edit
This
Bookmark
"
)
;
Assert
.
ok
(
bookmarkButton
.
hasAttribute
(
"
starred
"
)
)
;
Assert
.
equal
(
bookmarkButton
.
getAttribute
(
"
starred
"
)
"
true
"
)
;
hiddenPromise
=
promisePageActionPanelHidden
(
)
;
EventUtils
.
synthesizeMouseAtCenter
(
bookmarkButton
{
}
)
;
await
hiddenPromise
;
await
new
Promise
(
resolve
=
>
{
if
(
StarUI
.
panel
.
state
=
=
"
open
"
)
{
resolve
(
)
;
return
;
}
StarUI
.
panel
.
addEventListener
(
"
popupshown
"
resolve
{
once
:
true
}
)
;
}
)
;
let
onItemRemovedPromise
=
PlacesTestUtils
.
waitForNotification
(
"
onItemRemoved
"
(
id
parentId
index
type
itemUrl
)
=
>
url
=
=
itemUrl
.
spec
)
;
StarUI
.
_element
(
"
editBookmarkPanelRemoveButton
"
)
.
click
(
)
;
await
onItemRemovedPromise
;
await
promisePageActionPanelOpen
(
)
;
Assert
.
equal
(
bookmarkButton
.
label
"
Bookmark
This
Page
"
)
;
Assert
.
ok
(
!
bookmarkButton
.
hasAttribute
(
"
starred
"
)
)
;
hiddenPromise
=
promisePageActionPanelHidden
(
)
;
gPageActionPanel
.
hidePopup
(
)
;
await
hiddenPromise
;
}
)
;
}
)
;
add_task
(
async
function
emailLink
(
)
{
let
originalFn
=
MailIntegration
.
sendLinkForBrowser
;
let
fnCalled
=
false
;
MailIntegration
.
sendLinkForBrowser
=
(
)
=
>
{
fnCalled
=
true
;
}
;
registerCleanupFunction
(
(
)
=
>
{
MailIntegration
.
sendLinkForBrowser
=
originalFn
;
}
)
;
await
promisePageActionPanelOpen
(
)
;
let
emailLinkButton
=
document
.
getElementById
(
"
page
-
action
-
email
-
link
-
button
"
)
;
let
hiddenPromise
=
promisePageActionPanelHidden
(
)
;
EventUtils
.
synthesizeMouseAtCenter
(
emailLinkButton
{
}
)
;
await
hiddenPromise
;
Assert
.
ok
(
fnCalled
)
;
}
)
;
add_task
(
async
function
sendToDevice_nonSendable
(
)
{
await
BrowserTestUtils
.
withNewTab
(
"
about
:
blank
"
async
(
)
=
>
{
await
promiseSyncReady
(
)
;
await
promisePageActionPanelOpen
(
)
;
let
sendToDeviceButton
=
document
.
getElementById
(
"
page
-
action
-
send
-
to
-
device
-
button
"
)
;
Assert
.
ok
(
sendToDeviceButton
.
disabled
)
;
let
hiddenPromise
=
promisePageActionPanelHidden
(
)
;
gPageActionPanel
.
hidePopup
(
)
;
await
hiddenPromise
;
}
)
;
}
)
;
add_task
(
async
function
sendToDevice_syncNotReady_other_states
(
)
{
await
BrowserTestUtils
.
withNewTab
(
"
http
:
/
/
example
.
com
/
"
async
(
)
=
>
{
await
promiseSyncReady
(
)
;
const
sandbox
=
sinon
.
sandbox
.
create
(
)
;
sandbox
.
stub
(
gSync
"
syncReady
"
)
.
get
(
(
)
=
>
false
)
;
sandbox
.
stub
(
Weave
.
Service
.
clientsEngine
"
lastSync
"
)
.
get
(
(
)
=
>
0
)
;
sandbox
.
stub
(
UIState
"
get
"
)
.
returns
(
{
status
:
UIState
.
STATUS_NOT_VERIFIED
}
)
;
sandbox
.
stub
(
gSync
"
isSendableURI
"
)
.
returns
(
true
)
;
let
cleanUp
=
(
)
=
>
{
sandbox
.
restore
(
)
;
}
;
registerCleanupFunction
(
cleanUp
)
;
await
promisePageActionPanelOpen
(
)
;
let
sendToDeviceButton
=
document
.
getElementById
(
"
page
-
action
-
send
-
to
-
device
-
button
"
)
;
Assert
.
ok
(
!
sendToDeviceButton
.
disabled
)
;
let
viewPromise
=
promisePageActionViewShown
(
)
;
EventUtils
.
synthesizeMouseAtCenter
(
sendToDeviceButton
{
}
)
;
let
view
=
await
viewPromise
;
Assert
.
equal
(
view
.
id
"
page
-
action
-
sendToDeviceView
"
)
;
let
expectedItems
=
[
{
id
:
"
page
-
action
-
sync
-
not
-
ready
-
button
"
display
:
"
none
"
disabled
:
true
}
{
attrs
:
{
label
:
"
Account
Not
Verified
"
}
disabled
:
true
}
null
{
attrs
:
{
label
:
"
Verify
Your
Account
.
.
.
"
}
}
]
;
checkSendToDeviceItems
(
expectedItems
)
;
let
hiddenPromise
=
promisePageActionPanelHidden
(
)
;
gPageActionPanel
.
hidePopup
(
)
;
await
hiddenPromise
;
cleanUp
(
)
;
}
)
;
}
)
;
add_task
(
async
function
sendToDevice_syncNotReady_configured
(
)
{
await
BrowserTestUtils
.
withNewTab
(
"
http
:
/
/
example
.
com
/
"
async
(
)
=
>
{
await
promiseSyncReady
(
)
;
const
sandbox
=
sinon
.
sandbox
.
create
(
)
;
const
syncReady
=
sandbox
.
stub
(
gSync
"
syncReady
"
)
.
get
(
(
)
=
>
false
)
;
const
lastSync
=
sandbox
.
stub
(
Weave
.
Service
.
clientsEngine
"
lastSync
"
)
.
get
(
(
)
=
>
0
)
;
sandbox
.
stub
(
UIState
"
get
"
)
.
returns
(
{
status
:
UIState
.
STATUS_SIGNED_IN
}
)
;
sandbox
.
stub
(
gSync
"
isSendableURI
"
)
.
returns
(
true
)
;
sandbox
.
stub
(
Weave
.
Service
"
sync
"
)
.
callsFake
(
(
)
=
>
{
syncReady
.
get
(
(
)
=
>
true
)
;
lastSync
.
get
(
(
)
=
>
Date
.
now
(
)
)
;
sandbox
.
stub
(
gSync
"
remoteClients
"
)
.
get
(
(
)
=
>
mockRemoteClients
)
;
}
)
;
const
setupSendToDeviceView
=
gPageActionButton
.
setupSendToDeviceView
;
sandbox
.
stub
(
gPageActionButton
"
setupSendToDeviceView
"
)
.
callsFake
(
(
)
=
>
{
this
.
numCall
+
+
|
|
(
this
.
numCall
=
1
)
;
setupSendToDeviceView
.
call
(
gPageActionButton
)
;
testSendTabToDeviceMenu
(
this
.
numCall
)
;
}
)
;
let
cleanUp
=
(
)
=
>
{
sandbox
.
restore
(
)
;
}
;
registerCleanupFunction
(
cleanUp
)
;
await
promisePageActionPanelOpen
(
)
;
let
sendToDeviceButton
=
document
.
getElementById
(
"
page
-
action
-
send
-
to
-
device
-
button
"
)
;
Assert
.
ok
(
!
sendToDeviceButton
.
disabled
)
;
let
viewPromise
=
promisePageActionViewShown
(
)
;
EventUtils
.
synthesizeMouseAtCenter
(
sendToDeviceButton
{
}
)
;
let
view
=
await
viewPromise
;
Assert
.
equal
(
view
.
id
"
page
-
action
-
sendToDeviceView
"
)
;
function
testSendTabToDeviceMenu
(
numCall
)
{
if
(
numCall
=
=
1
)
{
checkSendToDeviceItems
(
[
{
id
:
"
page
-
action
-
sync
-
not
-
ready
-
button
"
disabled
:
true
}
]
)
;
}
else
if
(
numCall
=
=
2
)
{
let
expectedItems
=
[
{
id
:
"
page
-
action
-
sync
-
not
-
ready
-
button
"
display
:
"
none
"
disabled
:
true
}
]
;
for
(
let
client
of
mockRemoteClients
)
{
expectedItems
.
push
(
{
attrs
:
{
clientId
:
client
.
id
label
:
client
.
name
clientType
:
client
.
type
}
}
)
;
}
expectedItems
.
push
(
null
{
attrs
:
{
label
:
"
Send
to
All
Devices
"
}
}
)
;
checkSendToDeviceItems
(
expectedItems
)
;
}
else
{
ok
(
false
"
This
should
never
happen
"
)
;
}
}
let
hiddenPromise
=
promisePageActionPanelHidden
(
)
;
gPageActionPanel
.
hidePopup
(
)
;
await
hiddenPromise
;
cleanUp
(
)
;
}
)
;
}
)
;
add_task
(
async
function
sendToDevice_notSignedIn
(
)
{
await
BrowserTestUtils
.
withNewTab
(
"
http
:
/
/
example
.
com
/
"
async
(
)
=
>
{
await
promiseSyncReady
(
)
;
await
promisePageActionPanelOpen
(
)
;
let
sendToDeviceButton
=
document
.
getElementById
(
"
page
-
action
-
send
-
to
-
device
-
button
"
)
;
Assert
.
ok
(
!
sendToDeviceButton
.
disabled
)
;
let
viewPromise
=
promisePageActionViewShown
(
)
;
EventUtils
.
synthesizeMouseAtCenter
(
sendToDeviceButton
{
}
)
;
let
view
=
await
viewPromise
;
Assert
.
equal
(
view
.
id
"
page
-
action
-
sendToDeviceView
"
)
;
let
expectedItems
=
[
{
id
:
"
page
-
action
-
sync
-
not
-
ready
-
button
"
display
:
"
none
"
disabled
:
true
}
{
attrs
:
{
label
:
"
Not
Connected
to
Sync
"
}
disabled
:
true
}
null
{
attrs
:
{
label
:
"
Learn
About
Sending
Tabs
.
.
.
"
}
}
]
;
checkSendToDeviceItems
(
expectedItems
)
;
let
hiddenPromise
=
promisePageActionPanelHidden
(
)
;
gPageActionPanel
.
hidePopup
(
)
;
await
hiddenPromise
;
}
)
;
}
)
;
add_task
(
async
function
sendToDevice_noDevices
(
)
{
await
BrowserTestUtils
.
withNewTab
(
"
http
:
/
/
example
.
com
/
"
async
(
)
=
>
{
await
promiseSyncReady
(
)
;
const
sandbox
=
sinon
.
sandbox
.
create
(
)
;
sandbox
.
stub
(
gSync
"
syncReady
"
)
.
get
(
(
)
=
>
true
)
;
sandbox
.
stub
(
Weave
.
Service
.
clientsEngine
"
lastSync
"
)
.
get
(
(
)
=
>
Date
.
now
(
)
)
;
sandbox
.
stub
(
UIState
"
get
"
)
.
returns
(
{
status
:
UIState
.
STATUS_SIGNED_IN
}
)
;
sandbox
.
stub
(
gSync
"
isSendableURI
"
)
.
returns
(
true
)
;
sandbox
.
stub
(
gSync
"
remoteClients
"
)
.
get
(
(
)
=
>
[
]
)
;
let
cleanUp
=
(
)
=
>
{
sandbox
.
restore
(
)
;
}
;
registerCleanupFunction
(
cleanUp
)
;
await
promisePageActionPanelOpen
(
)
;
let
sendToDeviceButton
=
document
.
getElementById
(
"
page
-
action
-
send
-
to
-
device
-
button
"
)
;
Assert
.
ok
(
!
sendToDeviceButton
.
disabled
)
;
let
viewPromise
=
promisePageActionViewShown
(
)
;
EventUtils
.
synthesizeMouseAtCenter
(
sendToDeviceButton
{
}
)
;
let
view
=
await
viewPromise
;
Assert
.
equal
(
view
.
id
"
page
-
action
-
sendToDeviceView
"
)
;
let
expectedItems
=
[
{
id
:
"
page
-
action
-
sync
-
not
-
ready
-
button
"
display
:
"
none
"
disabled
:
true
}
{
attrs
:
{
label
:
"
No
Devices
Connected
"
}
disabled
:
true
}
null
{
attrs
:
{
label
:
"
Learn
About
Sending
Tabs
.
.
.
"
}
}
]
;
checkSendToDeviceItems
(
expectedItems
)
;
let
hiddenPromise
=
promisePageActionPanelHidden
(
)
;
gPageActionPanel
.
hidePopup
(
)
;
await
hiddenPromise
;
cleanUp
(
)
;
await
UIState
.
reset
(
)
;
}
)
;
}
)
;
add_task
(
async
function
sendToDevice_devices
(
)
{
await
BrowserTestUtils
.
withNewTab
(
"
http
:
/
/
example
.
com
/
"
async
(
)
=
>
{
await
promiseSyncReady
(
)
;
const
sandbox
=
sinon
.
sandbox
.
create
(
)
;
sandbox
.
stub
(
gSync
"
syncReady
"
)
.
get
(
(
)
=
>
true
)
;
sandbox
.
stub
(
Weave
.
Service
.
clientsEngine
"
lastSync
"
)
.
get
(
(
)
=
>
Date
.
now
(
)
)
;
sandbox
.
stub
(
UIState
"
get
"
)
.
returns
(
{
status
:
UIState
.
STATUS_SIGNED_IN
}
)
;
sandbox
.
stub
(
gSync
"
isSendableURI
"
)
.
returns
(
true
)
;
sandbox
.
stub
(
gSync
"
remoteClients
"
)
.
get
(
(
)
=
>
mockRemoteClients
)
;
let
cleanUp
=
(
)
=
>
{
sandbox
.
restore
(
)
;
}
;
registerCleanupFunction
(
cleanUp
)
;
await
promisePageActionPanelOpen
(
)
;
let
sendToDeviceButton
=
document
.
getElementById
(
"
page
-
action
-
send
-
to
-
device
-
button
"
)
;
Assert
.
ok
(
!
sendToDeviceButton
.
disabled
)
;
let
viewPromise
=
promisePageActionViewShown
(
)
;
EventUtils
.
synthesizeMouseAtCenter
(
sendToDeviceButton
{
}
)
;
let
view
=
await
viewPromise
;
Assert
.
equal
(
view
.
id
"
page
-
action
-
sendToDeviceView
"
)
;
let
expectedItems
=
[
{
id
:
"
page
-
action
-
sync
-
not
-
ready
-
button
"
display
:
"
none
"
disabled
:
true
}
]
;
for
(
let
client
of
mockRemoteClients
)
{
expectedItems
.
push
(
{
attrs
:
{
clientId
:
client
.
id
label
:
client
.
name
clientType
:
client
.
type
}
}
)
;
}
expectedItems
.
push
(
null
{
attrs
:
{
label
:
"
Send
to
All
Devices
"
}
}
)
;
checkSendToDeviceItems
(
expectedItems
)
;
let
hiddenPromise
=
promisePageActionPanelHidden
(
)
;
gPageActionPanel
.
hidePopup
(
)
;
await
hiddenPromise
;
cleanUp
(
)
;
}
)
;
}
)
;
function
promiseSyncReady
(
)
{
let
service
=
Cc
[
"
mozilla
.
org
/
weave
/
service
;
1
"
]
.
getService
(
Components
.
interfaces
.
nsISupports
)
.
wrappedJSObject
;
return
service
.
whenLoaded
(
)
.
then
(
(
)
=
>
{
UIState
.
isReady
(
)
;
return
UIState
.
refresh
(
)
;
}
)
;
}
function
checkSendToDeviceItems
(
expectedItems
)
{
let
body
=
document
.
getElementById
(
"
page
-
action
-
sendToDeviceView
-
body
"
)
;
Assert
.
equal
(
body
.
childNodes
.
length
expectedItems
.
length
)
;
for
(
let
i
=
0
;
i
<
expectedItems
.
length
;
i
+
+
)
{
let
expected
=
expectedItems
[
i
]
;
let
actual
=
body
.
childNodes
[
i
]
;
if
(
!
expected
)
{
Assert
.
equal
(
actual
.
localName
"
toolbarseparator
"
)
;
continue
;
}
if
(
"
id
"
in
expected
)
{
Assert
.
equal
(
actual
.
id
expected
.
id
)
;
}
let
display
=
"
display
"
in
expected
?
expected
.
display
:
"
-
moz
-
box
"
;
Assert
.
equal
(
getComputedStyle
(
actual
)
.
display
display
)
;
let
disabled
=
"
disabled
"
in
expected
?
expected
.
disabled
:
false
;
Assert
.
equal
(
actual
.
disabled
disabled
)
;
if
(
"
attrs
"
in
expected
)
{
for
(
let
name
in
expected
.
attrs
)
{
Assert
.
ok
(
actual
.
hasAttribute
(
name
)
)
;
let
attrVal
=
actual
.
getAttribute
(
name
)
if
(
name
=
=
"
label
"
)
{
attrVal
=
attrVal
.
normalize
(
"
NFKC
"
)
;
}
Assert
.
equal
(
attrVal
expected
.
attrs
[
name
]
)
;
}
}
}
}
