"
use
strict
"
;
Services
.
scriptloader
.
loadSubScript
(
"
resource
:
/
/
testing
-
common
/
sinon
-
2
.
3
.
2
.
js
"
)
;
registerCleanupFunction
(
function
(
)
{
delete
window
.
sinon
;
}
)
;
const
lastModifiedFixture
=
1507655615
.
87
;
const
mockTargets
=
[
{
id
:
"
0
"
name
:
"
foo
"
type
:
"
phone
"
clientRecord
:
{
id
:
"
cli0
"
serverLastModified
:
lastModifiedFixture
type
:
"
phone
"
}
}
{
id
:
"
1
"
name
:
"
bar
"
type
:
"
desktop
"
clientRecord
:
{
id
:
"
cli1
"
serverLastModified
:
lastModifiedFixture
type
:
"
desktop
"
}
}
{
id
:
"
2
"
name
:
"
baz
"
type
:
"
phone
"
clientRecord
:
{
id
:
"
cli2
"
serverLastModified
:
lastModifiedFixture
type
:
"
phone
"
}
}
{
id
:
"
3
"
name
:
"
no
client
record
device
"
type
:
"
phone
"
}
]
;
add_task
(
async
function
bookmark
(
)
{
let
url
=
"
http
:
/
/
example
.
com
/
browser_page_action_menu
"
;
await
BrowserTestUtils
.
withNewTab
(
url
async
(
)
=
>
{
await
promisePageActionPanelOpen
(
)
;
let
bookmarkButton
=
document
.
getElementById
(
"
pageAction
-
panel
-
bookmark
"
)
;
Assert
.
equal
(
bookmarkButton
.
label
"
Bookmark
This
Page
"
)
;
Assert
.
ok
(
!
bookmarkButton
.
hasAttribute
(
"
starred
"
)
)
;
let
hiddenPromise
=
promisePageActionPanelHidden
(
)
;
EventUtils
.
synthesizeMouseAtCenter
(
bookmarkButton
{
}
)
;
await
hiddenPromise
;
await
new
Promise
(
resolve
=
>
{
if
(
StarUI
.
panel
.
state
=
=
"
open
"
)
{
resolve
(
)
;
return
;
}
StarUI
.
panel
.
addEventListener
(
"
popupshown
"
resolve
{
once
:
true
}
)
;
}
)
;
Assert
.
equal
(
BookmarkingUI
.
starBox
.
getAttribute
(
"
open
"
)
"
true
"
"
Star
has
open
attribute
"
)
;
StarUI
.
panel
.
hidePopup
(
)
;
Assert
.
ok
(
!
BookmarkingUI
.
starBox
.
hasAttribute
(
"
open
"
)
"
Star
no
longer
has
open
attribute
"
)
;
await
promisePageActionPanelOpen
(
)
;
Assert
.
equal
(
bookmarkButton
.
label
"
Edit
This
Bookmark
"
)
;
Assert
.
ok
(
bookmarkButton
.
hasAttribute
(
"
starred
"
)
)
;
Assert
.
equal
(
bookmarkButton
.
getAttribute
(
"
starred
"
)
"
true
"
)
;
hiddenPromise
=
promisePageActionPanelHidden
(
)
;
EventUtils
.
synthesizeMouseAtCenter
(
bookmarkButton
{
}
)
;
await
hiddenPromise
;
await
new
Promise
(
resolve
=
>
{
if
(
StarUI
.
panel
.
state
=
=
"
open
"
)
{
resolve
(
)
;
return
;
}
StarUI
.
panel
.
addEventListener
(
"
popupshown
"
resolve
{
once
:
true
}
)
;
}
)
;
let
onItemRemovedPromise
=
PlacesTestUtils
.
waitForNotification
(
"
onItemRemoved
"
(
id
parentId
index
type
itemUrl
)
=
>
url
=
=
itemUrl
.
spec
)
;
StarUI
.
_element
(
"
editBookmarkPanelRemoveButton
"
)
.
click
(
)
;
await
onItemRemovedPromise
;
await
promisePageActionPanelOpen
(
)
;
Assert
.
equal
(
bookmarkButton
.
label
"
Bookmark
This
Page
"
)
;
Assert
.
ok
(
!
bookmarkButton
.
hasAttribute
(
"
starred
"
)
)
;
hiddenPromise
=
promisePageActionPanelHidden
(
)
;
BrowserPageActions
.
panelNode
.
hidePopup
(
)
;
await
hiddenPromise
;
}
)
;
}
)
;
add_task
(
async
function
emailLink
(
)
{
let
url
=
"
http
:
/
/
example
.
com
/
"
;
await
BrowserTestUtils
.
withNewTab
(
url
async
(
)
=
>
{
let
originalFn
=
MailIntegration
.
sendLinkForBrowser
;
let
fnCalled
=
false
;
MailIntegration
.
sendLinkForBrowser
=
(
)
=
>
{
fnCalled
=
true
;
}
;
registerCleanupFunction
(
(
)
=
>
{
MailIntegration
.
sendLinkForBrowser
=
originalFn
;
}
)
;
await
promisePageActionPanelOpen
(
)
;
let
emailLinkButton
=
document
.
getElementById
(
"
pageAction
-
panel
-
emailLink
"
)
;
let
hiddenPromise
=
promisePageActionPanelHidden
(
)
;
EventUtils
.
synthesizeMouseAtCenter
(
emailLinkButton
{
}
)
;
await
hiddenPromise
;
Assert
.
ok
(
fnCalled
)
;
}
)
;
}
)
;
add_task
(
async
function
copyURLFromPanel
(
)
{
let
url
=
"
http
:
/
/
example
.
com
/
"
;
await
BrowserTestUtils
.
withNewTab
(
url
async
(
)
=
>
{
let
action
=
PageActions
.
_builtInActions
.
find
(
a
=
>
a
.
id
=
=
"
copyURL
"
)
;
action
.
pinnedToUrlbar
=
true
;
registerCleanupFunction
(
(
)
=
>
action
.
pinnedToUrlbar
=
false
)
;
await
promisePageActionPanelOpen
(
)
;
Assert
.
ok
(
true
"
page
action
panel
opened
"
)
;
let
copyURLButton
=
document
.
getElementById
(
"
pageAction
-
panel
-
copyURL
"
)
;
let
hiddenPromise
=
promisePageActionPanelHidden
(
)
;
EventUtils
.
synthesizeMouseAtCenter
(
copyURLButton
{
}
)
;
await
hiddenPromise
;
let
feedbackPanel
=
document
.
getElementById
(
"
confirmation
-
hint
"
)
;
let
feedbackShownPromise
=
BrowserTestUtils
.
waitForEvent
(
feedbackPanel
"
popupshown
"
)
;
await
feedbackShownPromise
;
Assert
.
equal
(
feedbackPanel
.
anchorNode
.
id
"
pageActionButton
"
"
Feedback
menu
should
be
anchored
on
the
main
Page
Action
button
"
)
;
let
feedbackHiddenPromise
=
promisePanelHidden
(
"
confirmation
-
hint
"
)
;
await
feedbackHiddenPromise
;
action
.
pinnedToUrlbar
=
false
;
}
)
;
}
)
;
add_task
(
async
function
copyURLFromURLBar
(
)
{
let
url
=
"
http
:
/
/
example
.
com
/
"
;
await
BrowserTestUtils
.
withNewTab
(
url
async
(
)
=
>
{
let
action
=
PageActions
.
_builtInActions
.
find
(
a
=
>
a
.
id
=
=
"
copyURL
"
)
;
action
.
pinnedToUrlbar
=
true
;
registerCleanupFunction
(
(
)
=
>
action
.
pinnedToUrlbar
=
false
)
;
let
copyURLButton
=
document
.
getElementById
(
"
pageAction
-
urlbar
-
copyURL
"
)
;
let
feedbackShownPromise
=
promisePanelShown
(
"
confirmation
-
hint
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
copyURLButton
{
}
)
;
await
feedbackShownPromise
;
let
panel
=
document
.
getElementById
(
"
confirmation
-
hint
"
)
;
Assert
.
equal
(
panel
.
anchorNode
.
id
"
pageAction
-
urlbar
-
copyURL
"
"
Feedback
menu
should
be
anchored
on
the
main
URL
bar
button
"
)
;
let
feedbackHiddenPromise
=
promisePanelHidden
(
"
confirmation
-
hint
"
)
;
await
feedbackHiddenPromise
;
action
.
pinnedToUrlbar
=
false
;
}
)
;
}
)
;
add_task
(
async
function
sendToDevice_nonSendable
(
)
{
await
BrowserTestUtils
.
withNewTab
(
"
about
:
about
"
async
(
)
=
>
{
await
promiseSyncReady
(
)
;
await
promisePageActionPanelOpen
(
)
;
Assert
.
equal
(
BrowserPageActions
.
mainButtonNode
.
getAttribute
(
"
open
"
)
"
true
"
"
Main
button
has
'
open
'
attribute
"
)
;
let
panelButton
=
BrowserPageActions
.
panelButtonNodeForActionID
(
"
sendToDevice
"
)
;
Assert
.
equal
(
panelButton
.
disabled
true
"
The
panel
button
should
be
disabled
"
)
;
let
hiddenPromise
=
promisePageActionPanelHidden
(
)
;
BrowserPageActions
.
panelNode
.
hidePopup
(
)
;
await
hiddenPromise
;
Assert
.
ok
(
!
BrowserPageActions
.
mainButtonNode
.
hasAttribute
(
"
open
"
)
"
Main
button
no
longer
has
'
open
'
attribute
"
)
;
let
urlbarButton
=
BrowserPageActions
.
urlbarButtonNodeForActionID
(
"
sendToDevice
"
)
;
Assert
.
equal
(
urlbarButton
null
"
The
urlbar
button
shouldn
'
t
exist
"
)
;
}
)
;
}
)
;
add_task
(
async
function
sendToDevice_syncNotReady_other_states
(
)
{
await
BrowserTestUtils
.
withNewTab
(
"
http
:
/
/
example
.
com
/
"
async
(
)
=
>
{
await
promiseSyncReady
(
)
;
const
sandbox
=
sinon
.
sandbox
.
create
(
)
;
sandbox
.
stub
(
gSync
"
syncReady
"
)
.
get
(
(
)
=
>
false
)
;
sandbox
.
stub
(
UIState
"
get
"
)
.
returns
(
{
status
:
UIState
.
STATUS_NOT_VERIFIED
}
)
;
sandbox
.
stub
(
gSync
"
isSendableURI
"
)
.
returns
(
true
)
;
let
cleanUp
=
(
)
=
>
{
sandbox
.
restore
(
)
;
}
;
registerCleanupFunction
(
cleanUp
)
;
await
promisePageActionPanelOpen
(
)
;
let
sendToDeviceButton
=
document
.
getElementById
(
"
pageAction
-
panel
-
sendToDevice
"
)
;
Assert
.
ok
(
!
sendToDeviceButton
.
disabled
)
;
let
viewPromise
=
promisePageActionViewShown
(
)
;
EventUtils
.
synthesizeMouseAtCenter
(
sendToDeviceButton
{
}
)
;
let
view
=
await
viewPromise
;
Assert
.
equal
(
view
.
id
"
pageAction
-
panel
-
sendToDevice
-
subview
"
)
;
let
expectedItems
=
[
{
className
:
"
pageAction
-
sendToDevice
-
notReady
"
display
:
"
none
"
disabled
:
true
}
{
attrs
:
{
label
:
"
Account
Not
Verified
"
}
disabled
:
true
}
null
{
attrs
:
{
label
:
"
Verify
Your
Account
.
.
.
"
}
}
]
;
checkSendToDeviceItems
(
expectedItems
)
;
let
hiddenPromise
=
promisePageActionPanelHidden
(
)
;
BrowserPageActions
.
panelNode
.
hidePopup
(
)
;
await
hiddenPromise
;
cleanUp
(
)
;
}
)
;
}
)
;
add_task
(
async
function
sendToDevice_syncNotReady_configured
(
)
{
await
BrowserTestUtils
.
withNewTab
(
"
http
:
/
/
example
.
com
/
"
async
(
)
=
>
{
await
promiseSyncReady
(
)
;
const
sandbox
=
sinon
.
sandbox
.
create
(
)
;
const
syncReady
=
sandbox
.
stub
(
gSync
"
syncReady
"
)
.
get
(
(
)
=
>
false
)
;
const
hasSyncedThisSession
=
sandbox
.
stub
(
Weave
.
Service
.
clientsEngine
"
hasSyncedThisSession
"
)
.
get
(
(
)
=
>
false
)
;
sandbox
.
stub
(
UIState
"
get
"
)
.
returns
(
{
status
:
UIState
.
STATUS_SIGNED_IN
}
)
;
sandbox
.
stub
(
gSync
"
isSendableURI
"
)
.
returns
(
true
)
;
sandbox
.
stub
(
Weave
.
Service
"
sync
"
)
.
callsFake
(
(
)
=
>
{
syncReady
.
get
(
(
)
=
>
true
)
;
hasSyncedThisSession
.
get
(
(
)
=
>
true
)
;
sandbox
.
stub
(
gSync
"
sendTabTargets
"
)
.
get
(
(
)
=
>
mockTargets
)
;
sandbox
.
stub
(
Weave
.
Service
.
clientsEngine
"
getClientType
"
)
.
callsFake
(
id
=
>
mockTargets
.
find
(
c
=
>
c
.
clientRecord
&
&
c
.
clientRecord
.
id
=
=
id
)
.
clientRecord
.
type
)
;
}
)
;
let
onShowingSubview
=
BrowserPageActions
.
sendToDevice
.
onShowingSubview
;
sandbox
.
stub
(
BrowserPageActions
.
sendToDevice
"
onShowingSubview
"
)
.
callsFake
(
(
.
.
.
args
)
=
>
{
this
.
numCall
+
+
|
|
(
this
.
numCall
=
1
)
;
onShowingSubview
.
call
(
BrowserPageActions
.
sendToDevice
.
.
.
args
)
;
testSendTabToDeviceMenu
(
this
.
numCall
)
;
}
)
;
let
cleanUp
=
(
)
=
>
{
sandbox
.
restore
(
)
;
}
;
registerCleanupFunction
(
cleanUp
)
;
await
promisePageActionPanelOpen
(
)
;
let
sendToDeviceButton
=
document
.
getElementById
(
"
pageAction
-
panel
-
sendToDevice
"
)
;
Assert
.
ok
(
!
sendToDeviceButton
.
disabled
)
;
let
viewPromise
=
promisePageActionViewShown
(
)
;
EventUtils
.
synthesizeMouseAtCenter
(
sendToDeviceButton
{
}
)
;
let
view
=
await
viewPromise
;
Assert
.
equal
(
view
.
id
"
pageAction
-
panel
-
sendToDevice
-
subview
"
)
;
function
testSendTabToDeviceMenu
(
numCall
)
{
if
(
numCall
=
=
1
)
{
checkSendToDeviceItems
(
[
{
className
:
"
pageAction
-
sendToDevice
-
notReady
"
disabled
:
true
}
]
)
;
}
else
if
(
numCall
=
=
2
)
{
let
expectedItems
=
[
{
className
:
"
pageAction
-
sendToDevice
-
notReady
"
display
:
"
none
"
disabled
:
true
}
]
;
for
(
let
target
of
mockTargets
)
{
const
attrs
=
{
clientId
:
target
.
id
label
:
target
.
name
clientType
:
target
.
type
}
;
if
(
target
.
clientRecord
&
&
target
.
clientRecord
.
serverLastModified
)
{
attrs
.
tooltiptext
=
gSync
.
formatLastSyncDate
(
new
Date
(
target
.
clientRecord
.
serverLastModified
*
1000
)
)
;
}
expectedItems
.
push
(
{
attrs
}
)
;
}
expectedItems
.
push
(
null
{
attrs
:
{
label
:
"
Send
to
All
Devices
"
}
}
)
;
checkSendToDeviceItems
(
expectedItems
)
;
}
else
{
ok
(
false
"
This
should
never
happen
"
)
;
}
}
let
hiddenPromise
=
promisePageActionPanelHidden
(
)
;
BrowserPageActions
.
panelNode
.
hidePopup
(
)
;
await
hiddenPromise
;
cleanUp
(
)
;
}
)
;
}
)
;
add_task
(
async
function
sendToDevice_notSignedIn
(
)
{
await
BrowserTestUtils
.
withNewTab
(
"
http
:
/
/
example
.
com
/
"
async
(
)
=
>
{
await
promiseSyncReady
(
)
;
await
promisePageActionPanelOpen
(
)
;
let
sendToDeviceButton
=
document
.
getElementById
(
"
pageAction
-
panel
-
sendToDevice
"
)
;
Assert
.
ok
(
!
sendToDeviceButton
.
disabled
)
;
let
viewPromise
=
promisePageActionViewShown
(
)
;
EventUtils
.
synthesizeMouseAtCenter
(
sendToDeviceButton
{
}
)
;
let
view
=
await
viewPromise
;
Assert
.
equal
(
view
.
id
"
pageAction
-
panel
-
sendToDevice
-
subview
"
)
;
let
expectedItems
=
[
{
className
:
"
pageAction
-
sendToDevice
-
notReady
"
display
:
"
none
"
disabled
:
true
}
{
attrs
:
{
label
:
"
Not
Connected
to
Sync
"
}
disabled
:
true
}
null
{
attrs
:
{
label
:
"
Sign
in
to
Sync
.
.
.
"
}
}
{
attrs
:
{
label
:
"
Learn
About
Sending
Tabs
.
.
.
"
}
}
]
;
checkSendToDeviceItems
(
expectedItems
)
;
let
hiddenPromise
=
promisePageActionPanelHidden
(
)
;
BrowserPageActions
.
panelNode
.
hidePopup
(
)
;
await
hiddenPromise
;
}
)
;
}
)
;
add_task
(
async
function
sendToDevice_noDevices
(
)
{
await
BrowserTestUtils
.
withNewTab
(
"
http
:
/
/
example
.
com
/
"
async
(
)
=
>
{
await
promiseSyncReady
(
)
;
const
sandbox
=
sinon
.
sandbox
.
create
(
)
;
sandbox
.
stub
(
gSync
"
syncReady
"
)
.
get
(
(
)
=
>
true
)
;
sandbox
.
stub
(
Weave
.
Service
.
clientsEngine
"
hasSyncedThisSession
"
)
.
get
(
(
)
=
>
true
)
;
sandbox
.
stub
(
Weave
.
Service
.
clientsEngine
"
fxaDevices
"
)
.
get
(
(
)
=
>
[
]
)
;
sandbox
.
stub
(
UIState
"
get
"
)
.
returns
(
{
status
:
UIState
.
STATUS_SIGNED_IN
}
)
;
sandbox
.
stub
(
gSync
"
isSendableURI
"
)
.
returns
(
true
)
;
sandbox
.
stub
(
Weave
.
Service
.
clientsEngine
"
getClientType
"
)
.
callsFake
(
id
=
>
mockTargets
.
find
(
c
=
>
c
.
clientRecord
&
&
c
.
clientRecord
.
id
=
=
id
)
.
clientRecord
.
type
)
;
let
cleanUp
=
(
)
=
>
{
sandbox
.
restore
(
)
;
}
;
registerCleanupFunction
(
cleanUp
)
;
await
promisePageActionPanelOpen
(
)
;
let
sendToDeviceButton
=
document
.
getElementById
(
"
pageAction
-
panel
-
sendToDevice
"
)
;
Assert
.
ok
(
!
sendToDeviceButton
.
disabled
)
;
let
viewPromise
=
promisePageActionViewShown
(
)
;
EventUtils
.
synthesizeMouseAtCenter
(
sendToDeviceButton
{
}
)
;
let
view
=
await
viewPromise
;
Assert
.
equal
(
view
.
id
"
pageAction
-
panel
-
sendToDevice
-
subview
"
)
;
let
expectedItems
=
[
{
className
:
"
pageAction
-
sendToDevice
-
notReady
"
display
:
"
none
"
disabled
:
true
}
{
attrs
:
{
label
:
"
No
Devices
Connected
"
}
disabled
:
true
}
null
{
attrs
:
{
label
:
"
Connect
Another
Device
.
.
.
"
}
}
{
attrs
:
{
label
:
"
Learn
About
Sending
Tabs
.
.
.
"
}
}
]
;
checkSendToDeviceItems
(
expectedItems
)
;
let
hiddenPromise
=
promisePageActionPanelHidden
(
)
;
BrowserPageActions
.
panelNode
.
hidePopup
(
)
;
await
hiddenPromise
;
cleanUp
(
)
;
await
UIState
.
reset
(
)
;
}
)
;
}
)
;
add_task
(
async
function
sendToDevice_devices
(
)
{
await
BrowserTestUtils
.
withNewTab
(
"
http
:
/
/
example
.
com
/
"
async
(
)
=
>
{
await
promiseSyncReady
(
)
;
const
sandbox
=
sinon
.
sandbox
.
create
(
)
;
sandbox
.
stub
(
gSync
"
syncReady
"
)
.
get
(
(
)
=
>
true
)
;
sandbox
.
stub
(
Weave
.
Service
.
clientsEngine
"
hasSyncedThisSession
"
)
.
get
(
(
)
=
>
true
)
;
sandbox
.
stub
(
UIState
"
get
"
)
.
returns
(
{
status
:
UIState
.
STATUS_SIGNED_IN
}
)
;
sandbox
.
stub
(
gSync
"
isSendableURI
"
)
.
returns
(
true
)
;
sandbox
.
stub
(
gSync
"
sendTabTargets
"
)
.
get
(
(
)
=
>
mockTargets
)
;
sandbox
.
stub
(
Weave
.
Service
.
clientsEngine
"
getClientType
"
)
.
callsFake
(
id
=
>
mockTargets
.
find
(
c
=
>
c
.
clientRecord
&
&
c
.
clientRecord
.
id
=
=
id
)
.
clientRecord
.
type
)
;
let
cleanUp
=
(
)
=
>
{
sandbox
.
restore
(
)
;
}
;
registerCleanupFunction
(
cleanUp
)
;
await
promisePageActionPanelOpen
(
)
;
let
sendToDeviceButton
=
document
.
getElementById
(
"
pageAction
-
panel
-
sendToDevice
"
)
;
Assert
.
ok
(
!
sendToDeviceButton
.
disabled
)
;
let
viewPromise
=
promisePageActionViewShown
(
)
;
EventUtils
.
synthesizeMouseAtCenter
(
sendToDeviceButton
{
}
)
;
let
view
=
await
viewPromise
;
Assert
.
equal
(
view
.
id
"
pageAction
-
panel
-
sendToDevice
-
subview
"
)
;
let
expectedItems
=
[
{
className
:
"
pageAction
-
sendToDevice
-
notReady
"
display
:
"
none
"
disabled
:
true
}
]
;
for
(
let
target
of
mockTargets
)
{
expectedItems
.
push
(
{
attrs
:
{
clientId
:
target
.
id
label
:
target
.
name
clientType
:
target
.
type
}
}
)
;
}
expectedItems
.
push
(
null
{
attrs
:
{
label
:
"
Send
to
All
Devices
"
}
}
)
;
checkSendToDeviceItems
(
expectedItems
)
;
let
hiddenPromise
=
promisePageActionPanelHidden
(
)
;
BrowserPageActions
.
panelNode
.
hidePopup
(
)
;
await
hiddenPromise
;
cleanUp
(
)
;
}
)
;
}
)
;
add_task
(
async
function
sendToDevice_title
(
)
{
await
BrowserTestUtils
.
withNewTab
(
"
http
:
/
/
example
.
com
/
a
"
async
otherBrowser
=
>
{
await
BrowserTestUtils
.
withNewTab
(
"
http
:
/
/
example
.
com
/
b
"
async
(
)
=
>
{
await
promiseSyncReady
(
)
;
const
sandbox
=
sinon
.
sandbox
.
create
(
)
;
sandbox
.
stub
(
gSync
"
syncReady
"
)
.
get
(
(
)
=
>
true
)
;
sandbox
.
stub
(
Weave
.
Service
.
clientsEngine
"
hasSyncedThisSession
"
)
.
get
(
(
)
=
>
true
)
;
sandbox
.
stub
(
UIState
"
get
"
)
.
returns
(
{
status
:
UIState
.
STATUS_SIGNED_IN
}
)
;
sandbox
.
stub
(
gSync
"
isSendableURI
"
)
.
returns
(
true
)
;
sandbox
.
stub
(
gSync
"
sendTabTargets
"
)
.
get
(
(
)
=
>
[
]
)
;
sandbox
.
stub
(
Weave
.
Service
.
clientsEngine
"
getClientType
"
)
.
callsFake
(
id
=
>
mockTargets
.
find
(
c
=
>
c
.
clientRecord
&
&
c
.
clientRecord
.
id
=
=
id
)
.
clientRecord
.
type
)
;
let
cleanUp
=
(
)
=
>
{
sandbox
.
restore
(
)
;
}
;
registerCleanupFunction
(
cleanUp
)
;
await
promisePageActionPanelOpen
(
)
;
let
sendToDeviceButton
=
document
.
getElementById
(
"
pageAction
-
panel
-
sendToDevice
"
)
;
Assert
.
ok
(
!
sendToDeviceButton
.
disabled
)
;
Assert
.
equal
(
sendToDeviceButton
.
label
"
Send
Tab
to
Device
"
)
;
Assert
.
equal
(
PageActions
.
actionForID
(
"
sendToDevice
"
)
.
getTitle
(
window
)
"
Send
Tab
to
Device
"
)
;
let
hiddenPromise
=
promisePageActionPanelHidden
(
)
;
BrowserPageActions
.
panelNode
.
hidePopup
(
)
;
await
hiddenPromise
;
gBrowser
.
addToMultiSelectedTabs
(
gBrowser
.
getTabForBrowser
(
otherBrowser
)
false
)
;
await
promisePageActionPanelOpen
(
)
;
Assert
.
ok
(
!
sendToDeviceButton
.
disabled
)
;
Assert
.
equal
(
sendToDeviceButton
.
label
"
Send
2
Tabs
to
Device
"
)
;
Assert
.
equal
(
PageActions
.
actionForID
(
"
sendToDevice
"
)
.
getTitle
(
window
)
"
Send
2
Tabs
to
Device
"
)
;
hiddenPromise
=
promisePageActionPanelHidden
(
)
;
BrowserPageActions
.
panelNode
.
hidePopup
(
)
;
await
hiddenPromise
;
cleanUp
(
)
;
await
UIState
.
reset
(
)
;
}
)
;
}
)
;
}
)
;
add_task
(
async
function
sendToDevice_inUrlbar
(
)
{
await
BrowserTestUtils
.
withNewTab
(
"
http
:
/
/
example
.
com
/
"
async
(
)
=
>
{
await
promiseSyncReady
(
)
;
const
sandbox
=
sinon
.
sandbox
.
create
(
)
;
sandbox
.
stub
(
gSync
"
syncReady
"
)
.
get
(
(
)
=
>
true
)
;
sandbox
.
stub
(
Weave
.
Service
.
clientsEngine
"
hasSyncedThisSession
"
)
.
get
(
(
)
=
>
true
)
;
sandbox
.
stub
(
UIState
"
get
"
)
.
returns
(
{
status
:
UIState
.
STATUS_SIGNED_IN
}
)
;
sandbox
.
stub
(
gSync
"
isSendableURI
"
)
.
returns
(
true
)
;
sandbox
.
stub
(
gSync
"
sendTabTargets
"
)
.
get
(
(
)
=
>
mockTargets
)
;
sandbox
.
stub
(
Weave
.
Service
.
clientsEngine
"
getClientType
"
)
.
callsFake
(
id
=
>
mockTargets
.
find
(
c
=
>
c
.
clientRecord
&
&
c
.
clientRecord
.
id
=
=
id
)
.
clientRecord
.
type
)
;
let
cleanUp
=
(
)
=
>
{
sandbox
.
restore
(
)
;
}
;
registerCleanupFunction
(
cleanUp
)
;
let
action
=
PageActions
.
actionForID
(
"
sendToDevice
"
)
;
action
.
pinnedToUrlbar
=
true
;
let
urlbarButton
=
document
.
getElementById
(
BrowserPageActions
.
urlbarButtonNodeIDForActionID
(
action
.
id
)
)
;
Assert
.
notEqual
(
urlbarButton
null
"
The
urlbar
button
should
exist
"
)
;
Assert
.
ok
(
!
urlbarButton
.
disabled
"
The
urlbar
button
should
not
be
disabled
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
urlbarButton
{
}
)
;
await
promisePanelShown
(
BrowserPageActions
.
_activatedActionPanelID
)
;
Assert
.
equal
(
urlbarButton
.
getAttribute
(
"
open
"
)
"
true
"
"
Button
has
open
attribute
"
)
;
let
expectedItems
=
[
{
className
:
"
pageAction
-
sendToDevice
-
notReady
"
display
:
"
none
"
disabled
:
true
}
]
;
for
(
let
target
of
mockTargets
)
{
expectedItems
.
push
(
{
attrs
:
{
clientId
:
target
.
id
label
:
target
.
name
clientType
:
target
.
type
}
}
)
;
}
expectedItems
.
push
(
null
{
attrs
:
{
label
:
"
Send
to
All
Devices
"
}
}
)
;
checkSendToDeviceItems
(
expectedItems
true
)
;
let
bodyID
=
BrowserPageActions
.
_panelViewNodeIDForActionID
(
"
sendToDevice
"
true
)
+
"
-
body
"
;
let
body
=
document
.
getElementById
(
bodyID
)
;
let
deviceMenuItem
=
body
.
querySelector
(
"
.
sendtab
-
target
"
)
;
Assert
.
notEqual
(
deviceMenuItem
null
)
;
let
dwu
=
window
.
windowUtils
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
{
let
bounds
=
dwu
.
getBoundsWithoutFlushing
(
deviceMenuItem
)
;
return
bounds
.
height
>
0
&
&
bounds
.
width
>
0
;
}
"
Waiting
for
first
device
menu
item
to
appear
"
)
;
let
hiddenPromise
=
promisePanelHidden
(
BrowserPageActions
.
_activatedActionPanelID
)
;
EventUtils
.
synthesizeMouseAtCenter
(
deviceMenuItem
{
}
)
;
info
(
"
Waiting
for
Send
to
Device
panel
to
close
after
clicking
a
device
"
)
;
await
hiddenPromise
;
Assert
.
ok
(
!
urlbarButton
.
hasAttribute
(
"
open
"
)
"
URL
bar
button
no
longer
has
open
attribute
"
)
;
info
(
"
Waiting
for
the
Sent
!
notification
panel
to
open
"
)
;
await
promisePanelShown
(
ConfirmationHint
.
_panel
.
id
)
;
Assert
.
equal
(
ConfirmationHint
.
_panel
.
anchorNode
.
id
urlbarButton
.
id
)
;
info
(
"
Waiting
for
the
Sent
!
notification
panel
to
close
"
)
;
await
promisePanelHidden
(
ConfirmationHint
.
_panel
.
id
)
;
action
.
pinnedToUrlbar
=
false
;
cleanUp
(
)
;
}
)
;
}
)
;
add_task
(
async
function
contextMenu
(
)
{
let
url
=
"
http
:
/
/
example
.
com
/
"
;
await
BrowserTestUtils
.
withNewTab
(
url
async
(
)
=
>
{
await
promisePageActionPanelOpen
(
)
;
let
bookmarkButton
=
document
.
getElementById
(
"
pageAction
-
panel
-
bookmark
"
)
;
let
contextMenuPromise
=
promisePanelShown
(
"
pageActionContextMenu
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
bookmarkButton
{
type
:
"
contextmenu
"
button
:
2
}
)
;
await
contextMenuPromise
;
let
menuItems
=
collectContextMenuItems
(
)
;
Assert
.
equal
(
menuItems
.
length
1
"
Context
menu
has
one
child
"
)
;
Assert
.
equal
(
menuItems
[
0
]
.
label
"
Remove
from
Address
Bar
"
"
Context
menu
is
in
the
'
remove
'
state
"
)
;
contextMenuPromise
=
promisePanelHidden
(
"
pageActionContextMenu
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
menuItems
[
0
]
{
}
)
;
await
contextMenuPromise
;
let
starButtonBox
=
document
.
getElementById
(
"
star
-
button
-
box
"
)
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
{
return
starButtonBox
.
hidden
;
}
"
Waiting
for
star
button
to
become
hidden
"
)
;
contextMenuPromise
=
promisePanelShown
(
"
pageActionContextMenu
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
bookmarkButton
{
type
:
"
contextmenu
"
button
:
2
}
)
;
await
contextMenuPromise
;
menuItems
=
collectContextMenuItems
(
)
;
Assert
.
equal
(
menuItems
.
length
1
"
Context
menu
has
one
child
"
)
;
Assert
.
equal
(
menuItems
[
0
]
.
label
"
Add
to
Address
Bar
"
"
Context
menu
is
in
the
'
add
'
state
"
)
;
contextMenuPromise
=
promisePanelHidden
(
"
pageActionContextMenu
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
menuItems
[
0
]
{
}
)
;
await
contextMenuPromise
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
{
return
!
starButtonBox
.
hidden
;
}
"
Waiting
for
star
button
to
become
unhidden
"
)
;
contextMenuPromise
=
promisePanelShown
(
"
pageActionContextMenu
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
starButtonBox
{
type
:
"
contextmenu
"
button
:
2
}
)
;
await
contextMenuPromise
;
menuItems
=
collectContextMenuItems
(
)
;
Assert
.
equal
(
menuItems
.
length
1
"
Context
menu
has
one
child
"
)
;
Assert
.
equal
(
menuItems
[
0
]
.
label
"
Remove
from
Address
Bar
"
"
Context
menu
is
in
the
'
remove
'
state
"
)
;
contextMenuPromise
=
promisePanelHidden
(
"
pageActionContextMenu
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
menuItems
[
0
]
{
}
)
;
await
contextMenuPromise
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
{
return
starButtonBox
.
hidden
;
}
"
Waiting
for
star
button
to
become
hidden
"
)
;
await
promisePageActionPanelOpen
(
)
;
contextMenuPromise
=
promisePanelShown
(
"
pageActionContextMenu
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
bookmarkButton
{
type
:
"
contextmenu
"
button
:
2
}
)
;
await
contextMenuPromise
;
menuItems
=
collectContextMenuItems
(
)
;
Assert
.
equal
(
menuItems
.
length
1
"
Context
menu
has
one
child
"
)
;
Assert
.
equal
(
menuItems
[
0
]
.
label
"
Add
to
Address
Bar
"
"
Context
menu
is
in
the
'
add
'
state
"
)
;
contextMenuPromise
=
promisePanelHidden
(
"
pageActionContextMenu
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
menuItems
[
0
]
{
}
)
;
await
contextMenuPromise
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
{
return
!
starButtonBox
.
hidden
;
}
"
Waiting
for
star
button
to
become
unhidden
"
)
;
}
)
;
EventUtils
.
synthesizeMouseAtCenter
(
gURLBar
{
type
:
"
mousemove
"
}
)
;
gURLBar
.
focus
(
)
;
}
)
;
function
promiseSyncReady
(
)
{
let
service
=
Cc
[
"
mozilla
.
org
/
weave
/
service
;
1
"
]
.
getService
(
Ci
.
nsISupports
)
.
wrappedJSObject
;
return
service
.
whenLoaded
(
)
.
then
(
(
)
=
>
{
UIState
.
isReady
(
)
;
return
UIState
.
refresh
(
)
;
}
)
;
}
function
checkSendToDeviceItems
(
expectedItems
forUrlbar
=
false
)
{
let
bodyID
=
BrowserPageActions
.
_panelViewNodeIDForActionID
(
"
sendToDevice
"
forUrlbar
)
+
"
-
body
"
;
let
body
=
document
.
getElementById
(
bodyID
)
;
Assert
.
equal
(
body
.
children
.
length
expectedItems
.
length
)
;
for
(
let
i
=
0
;
i
<
expectedItems
.
length
;
i
+
+
)
{
let
expected
=
expectedItems
[
i
]
;
let
actual
=
body
.
children
[
i
]
;
if
(
!
expected
)
{
Assert
.
equal
(
actual
.
localName
"
toolbarseparator
"
)
;
continue
;
}
if
(
"
id
"
in
expected
)
{
Assert
.
equal
(
actual
.
id
expected
.
id
)
;
}
if
(
"
className
"
in
expected
)
{
let
expectedNames
=
expected
.
className
.
split
(
/
\
s
+
/
)
;
for
(
let
name
of
expectedNames
)
{
Assert
.
ok
(
actual
.
classList
.
contains
(
name
)
classList
contains
:
{
name
}
)
;
}
}
let
display
=
"
display
"
in
expected
?
expected
.
display
:
"
-
moz
-
box
"
;
Assert
.
equal
(
getComputedStyle
(
actual
)
.
display
display
)
;
let
disabled
=
"
disabled
"
in
expected
?
expected
.
disabled
:
false
;
Assert
.
equal
(
actual
.
disabled
disabled
)
;
if
(
"
attrs
"
in
expected
)
{
for
(
let
name
in
expected
.
attrs
)
{
Assert
.
ok
(
actual
.
hasAttribute
(
name
)
)
;
let
attrVal
=
actual
.
getAttribute
(
name
)
;
if
(
name
=
=
"
label
"
)
{
attrVal
=
attrVal
.
normalize
(
"
NFKC
"
)
;
}
Assert
.
equal
(
attrVal
expected
.
attrs
[
name
]
)
;
}
}
}
}
function
collectContextMenuItems
(
)
{
let
contextMenu
=
document
.
getElementById
(
"
pageActionContextMenu
"
)
;
return
Array
.
filter
(
contextMenu
.
children
node
=
>
{
return
window
.
getComputedStyle
(
node
)
.
visibility
=
=
"
visible
"
;
}
)
;
}
