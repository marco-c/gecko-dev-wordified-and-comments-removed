"
use
strict
"
;
ChromeUtils
.
import
(
"
resource
:
/
/
/
modules
/
BrowserUITelemetry
.
jsm
"
)
;
const
SUGGEST_URLBAR_PREF
=
"
browser
.
urlbar
.
suggest
.
searches
"
;
const
TEST_ENGINE_BASENAME
=
"
searchSuggestionEngine
.
xml
"
;
add_task
(
async
function
prepare
(
)
{
let
suggestionsEnabled
=
Services
.
prefs
.
getBoolPref
(
SUGGEST_URLBAR_PREF
)
;
Services
.
prefs
.
setBoolPref
(
SUGGEST_URLBAR_PREF
true
)
;
let
engine
=
await
promiseNewSearchEngine
(
TEST_ENGINE_BASENAME
)
;
let
oldCurrentEngine
=
Services
.
search
.
currentEngine
;
Services
.
search
.
currentEngine
=
engine
;
registerCleanupFunction
(
async
function
(
)
{
Services
.
prefs
.
setBoolPref
(
SUGGEST_URLBAR_PREF
suggestionsEnabled
)
;
Services
.
search
.
currentEngine
=
oldCurrentEngine
;
await
PlacesTestUtils
.
clearHistory
(
)
;
gURLBar
.
blur
(
)
;
Assert
.
ok
(
!
gURLBar
.
popup
.
popupOpen
"
popup
should
be
closed
"
)
;
}
)
;
await
new
Promise
(
resolve
=
>
{
EventUtils
.
synthesizeNativeMouseMove
(
window
.
document
.
documentElement
0
0
resolve
)
;
}
)
;
}
)
;
add_task
(
async
function
heuristicResultMouse
(
)
{
await
compareCounts
(
async
function
(
)
{
let
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
)
;
gURLBar
.
focus
(
)
;
await
promiseAutocompleteResultPopup
(
"
heuristicResult
"
)
;
let
action
=
getActionAtIndex
(
0
)
;
Assert
.
ok
(
!
!
action
"
there
should
be
an
action
at
index
0
"
)
;
Assert
.
equal
(
action
.
type
"
searchengine
"
"
type
should
be
searchengine
"
)
;
let
loadPromise
=
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
)
;
gURLBar
.
popup
.
richlistbox
.
getItemAtIndex
(
0
)
.
click
(
)
;
await
loadPromise
;
await
BrowserTestUtils
.
removeTab
(
tab
)
;
}
)
;
}
)
;
add_task
(
async
function
heuristicResultKeyboard
(
)
{
await
compareCounts
(
async
function
(
)
{
let
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
)
;
gURLBar
.
focus
(
)
;
await
promiseAutocompleteResultPopup
(
"
heuristicResult
"
)
;
let
action
=
getActionAtIndex
(
0
)
;
Assert
.
ok
(
!
!
action
"
there
should
be
an
action
at
index
0
"
)
;
Assert
.
equal
(
action
.
type
"
searchengine
"
"
type
should
be
searchengine
"
)
;
let
loadPromise
=
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
)
;
EventUtils
.
sendKey
(
"
return
"
)
;
await
loadPromise
;
await
BrowserTestUtils
.
removeTab
(
tab
)
;
}
)
;
}
)
;
add_task
(
async
function
searchSuggestionMouse
(
)
{
await
compareCounts
(
async
function
(
)
{
let
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
)
;
gURLBar
.
focus
(
)
;
await
promiseAutocompleteResultPopup
(
"
searchSuggestion
"
)
;
let
idx
=
getFirstSuggestionIndex
(
)
;
Assert
.
ok
(
idx
>
=
0
"
there
should
be
a
first
suggestion
"
)
;
let
loadPromise
=
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
)
;
gURLBar
.
popup
.
richlistbox
.
getItemAtIndex
(
idx
)
.
click
(
)
;
await
loadPromise
;
await
BrowserTestUtils
.
removeTab
(
tab
)
;
}
)
;
}
)
;
add_task
(
async
function
searchSuggestionKeyboard
(
)
{
await
compareCounts
(
async
function
(
)
{
let
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
)
;
gURLBar
.
focus
(
)
;
await
promiseAutocompleteResultPopup
(
"
searchSuggestion
"
)
;
let
idx
=
getFirstSuggestionIndex
(
)
;
Assert
.
ok
(
idx
>
=
0
"
there
should
be
a
first
suggestion
"
)
;
let
loadPromise
=
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
)
;
while
(
idx
-
-
)
{
EventUtils
.
sendKey
(
"
down
"
)
;
}
EventUtils
.
sendKey
(
"
return
"
)
;
await
loadPromise
;
await
BrowserTestUtils
.
removeTab
(
tab
)
;
}
)
;
}
)
;
async
function
compareCounts
(
clickCallback
)
{
let
engine
=
Services
.
search
.
currentEngine
;
let
engineID
=
"
org
.
mozilla
.
testsearchsuggestions
"
;
let
uiTelemCount
=
0
;
let
bucket
=
BrowserUITelemetry
.
currentBucket
;
let
events
=
BrowserUITelemetry
.
getToolbarMeasures
(
)
.
countableEvents
;
if
(
events
[
bucket
]
&
&
events
[
bucket
]
.
search
&
&
events
[
bucket
]
.
search
.
urlbar
)
{
uiTelemCount
=
events
[
bucket
]
.
search
.
urlbar
;
}
let
histogramCount
=
0
;
let
histogramKey
=
engineID
+
"
.
urlbar
"
;
let
histogram
;
try
{
histogram
=
Services
.
telemetry
.
getKeyedHistogramById
(
"
SEARCH_COUNTS
"
)
;
}
catch
(
ex
)
{
}
if
(
histogram
)
{
let
snapshot
=
histogram
.
snapshot
(
)
;
if
(
histogramKey
in
snapshot
)
{
histogramCount
=
snapshot
[
histogramKey
]
.
sum
;
}
}
Object
.
defineProperty
(
engine
.
wrappedJSObject
"
identifier
"
{
value
:
engineID
}
)
;
gURLBar
.
focus
(
)
;
await
clickCallback
(
)
;
events
=
BrowserUITelemetry
.
getToolbarMeasures
(
)
.
countableEvents
;
Assert
.
ok
(
bucket
in
events
"
bucket
should
be
recorded
"
)
;
events
=
events
[
bucket
]
;
Assert
.
ok
(
"
search
"
in
events
"
search
should
be
recorded
"
)
;
events
=
events
.
search
;
Assert
.
ok
(
"
urlbar
"
in
events
"
urlbar
should
be
recorded
"
)
;
Assert
.
equal
(
events
.
urlbar
uiTelemCount
+
1
"
clicked
suggestion
should
be
recorded
"
)
;
histogram
=
Services
.
telemetry
.
getKeyedHistogramById
(
"
SEARCH_COUNTS
"
)
;
let
snapshot
=
histogram
.
snapshot
(
)
;
Assert
.
ok
(
histogramKey
in
snapshot
"
histogram
with
key
should
be
recorded
"
)
;
Assert
.
equal
(
snapshot
[
histogramKey
]
.
sum
histogramCount
+
1
"
histogram
sum
should
be
incremented
"
)
;
}
function
getActionAtIndex
(
index
)
{
let
controller
=
gURLBar
.
popup
.
input
.
controller
;
if
(
controller
.
matchCount
<
=
index
)
{
return
null
;
}
let
url
=
controller
.
getValueAt
(
index
)
;
let
mozActionMatch
=
url
.
match
(
/
^
moz
-
action
:
(
[
^
]
+
)
(
.
*
)
/
)
;
if
(
!
mozActionMatch
)
{
let
msg
=
"
result
at
index
"
+
index
+
"
is
not
a
moz
-
action
:
"
+
url
;
Assert
.
ok
(
false
msg
)
;
throw
new
Error
(
msg
)
;
}
let
[
type
paramStr
]
=
mozActionMatch
;
return
{
type
params
:
JSON
.
parse
(
paramStr
)
}
;
}
function
getFirstSuggestionIndex
(
)
{
let
controller
=
gURLBar
.
popup
.
input
.
controller
;
let
matchCount
=
controller
.
matchCount
;
for
(
let
i
=
0
;
i
<
matchCount
;
i
+
+
)
{
let
url
=
controller
.
getValueAt
(
i
)
;
let
mozActionMatch
=
url
.
match
(
/
^
moz
-
action
:
(
[
^
]
+
)
(
.
*
)
/
)
;
if
(
mozActionMatch
)
{
let
[
type
paramStr
]
=
mozActionMatch
;
let
params
=
JSON
.
parse
(
paramStr
)
;
if
(
type
=
=
"
searchengine
"
&
&
"
searchSuggestion
"
in
params
)
{
return
i
;
}
}
}
return
-
1
;
}
