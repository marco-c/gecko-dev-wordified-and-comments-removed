"
use
strict
"
;
const
TEST_ROOT
=
getRootDirectory
(
gTestPath
)
.
replace
(
"
chrome
:
/
/
mochitests
/
content
/
"
"
https
:
/
/
example
.
com
/
"
)
;
const
TEST_PAGE
=
TEST_ROOT
+
"
get_user_media
.
html
"
;
async
function
testNotificationSilencing
(
aBrowser
)
{
let
hasIndicator
=
Services
.
wm
.
getEnumerator
(
"
Browser
:
WebRTCGlobalIndicator
"
)
.
hasMoreElements
(
)
;
let
window
=
aBrowser
.
ownerGlobal
;
let
alertsService
=
Cc
[
"
mozilla
.
org
/
alerts
-
service
;
1
"
]
.
getService
(
Ci
.
nsIAlertsService
)
.
QueryInterface
(
Ci
.
nsIAlertsDoNotDisturb
)
;
Assert
.
ok
(
alertsService
"
Alerts
Service
implements
nsIAlertsDoNotDisturb
"
)
;
Assert
.
ok
(
!
alertsService
.
suppressForScreenSharing
"
Should
not
be
silencing
notifications
to
start
.
"
)
;
let
observerPromise
=
expectObserverCalled
(
"
getUserMedia
:
request
"
1
aBrowser
)
;
let
promise
=
promisePopupNotificationShown
(
"
webRTC
-
shareDevices
"
null
window
)
;
let
indicatorPromise
=
hasIndicator
?
Promise
.
resolve
(
)
:
promiseIndicatorWindow
(
)
;
await
promiseRequestDevice
(
false
true
null
"
screen
"
aBrowser
)
;
await
promise
;
await
observerPromise
;
checkDeviceSelectors
(
[
"
screen
"
]
window
)
;
let
document
=
window
.
document
;
let
menulist
=
document
.
getElementById
(
"
webRTC
-
selectWindow
-
menulist
"
)
;
menulist
.
getItemAtIndex
(
menulist
.
itemCount
-
1
)
.
doCommand
(
)
;
let
notification
=
window
.
PopupNotifications
.
panel
.
firstElementChild
;
Assert
.
ok
(
notification
.
hasAttribute
(
"
warninghidden
"
)
"
Notification
silencing
warning
message
is
hidden
by
default
"
)
;
let
checkbox
=
notification
.
checkbox
;
Assert
.
ok
(
!
!
checkbox
"
Notification
silencing
checkbox
is
present
"
)
;
Assert
.
ok
(
!
checkbox
.
checked
"
checkbox
is
not
checked
by
default
"
)
;
checkbox
.
click
(
)
;
Assert
.
ok
(
checkbox
.
checked
"
checkbox
now
checked
"
)
;
Assert
.
ok
(
!
notification
.
button
.
disabled
"
Allow
button
is
not
disabled
"
)
;
Assert
.
ok
(
notification
.
hasAttribute
(
"
warninghidden
"
)
"
No
warning
message
is
shown
"
)
;
let
observerPromise1
=
expectObserverCalled
(
"
getUserMedia
:
response
:
allow
"
1
aBrowser
)
;
let
observerPromise2
=
expectObserverCalled
(
"
recording
-
device
-
events
"
1
aBrowser
)
;
await
promiseMessage
(
"
ok
"
(
)
=
>
{
notification
.
button
.
click
(
)
;
}
1
aBrowser
)
;
await
observerPromise1
;
await
observerPromise2
;
let
indicator
=
await
indicatorPromise
;
Assert
.
ok
(
alertsService
.
suppressForScreenSharing
"
Should
now
be
silencing
notifications
"
)
;
let
indicatorClosedPromise
=
hasIndicator
?
Promise
.
resolve
(
)
:
BrowserTestUtils
.
domWindowClosed
(
indicator
)
;
await
stopSharing
(
"
screen
"
true
aBrowser
window
)
;
await
indicatorClosedPromise
;
Assert
.
ok
(
!
alertsService
.
suppressForScreenSharing
"
Should
no
longer
be
silencing
notifications
"
)
;
}
add_setup
(
async
function
(
)
{
let
prefs
=
[
[
PREF_PERMISSION_FAKE
true
]
[
PREF_AUDIO_LOOPBACK
"
"
]
[
PREF_VIDEO_LOOPBACK
"
"
]
[
PREF_FAKE_STREAMS
true
]
[
PREF_FOCUS_SOURCE
false
]
]
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
prefs
}
)
;
}
)
;
add_task
(
async
function
testNormalWindow
(
)
{
await
BrowserTestUtils
.
withNewTab
(
{
gBrowser
url
:
TEST_PAGE
}
async
browser
=
>
{
await
testNotificationSilencing
(
browser
)
;
}
)
;
}
)
;
add_task
(
async
function
testPrivateWindow
(
)
{
let
privateWindow
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
{
private
:
true
}
)
;
await
BrowserTestUtils
.
withNewTab
(
{
gBrowser
:
privateWindow
.
gBrowser
url
:
TEST_PAGE
}
async
browser
=
>
{
await
testNotificationSilencing
(
browser
)
;
}
)
;
await
BrowserTestUtils
.
closeWindow
(
privateWindow
)
;
}
)
;
add_task
(
async
function
testWhileSharingMic
(
)
{
await
BrowserTestUtils
.
withNewTab
(
{
gBrowser
url
:
TEST_PAGE
}
async
browser
=
>
{
let
promise
=
promisePopupNotificationShown
(
"
webRTC
-
shareDevices
"
)
;
let
observerPromise
=
expectObserverCalled
(
"
getUserMedia
:
request
"
)
;
await
promiseRequestDevice
(
true
true
)
;
await
promise
;
await
observerPromise
;
let
indicatorPromise
=
promiseIndicatorWindow
(
)
;
let
observerPromise1
=
expectObserverCalled
(
"
getUserMedia
:
response
:
allow
"
)
;
let
observerPromise2
=
expectObserverCalled
(
"
recording
-
device
-
events
"
)
;
promise
=
promiseMessage
(
"
ok
"
(
)
=
>
{
PopupNotifications
.
panel
.
firstElementChild
.
button
.
click
(
)
;
}
)
;
await
observerPromise1
;
await
observerPromise2
;
await
promise
;
Assert
.
deepEqual
(
await
getMediaCaptureState
(
)
{
audio
:
true
video
:
true
}
"
expected
camera
and
microphone
to
be
shared
"
)
;
let
indicator
=
await
indicatorPromise
;
await
checkSharingUI
(
{
audio
:
true
video
:
true
}
)
;
await
testNotificationSilencing
(
browser
)
;
let
indicatorClosedPromise
=
BrowserTestUtils
.
domWindowClosed
(
indicator
)
;
await
closeStream
(
)
;
await
indicatorClosedPromise
;
}
)
;
}
)
;
