ChromeUtils
.
defineESModuleGetters
(
this
{
PlacesTestUtils
:
"
resource
:
/
/
testing
-
common
/
PlacesTestUtils
.
sys
.
mjs
"
Timer
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
sys
.
mjs
"
PermissionTestUtils
:
"
resource
:
/
/
testing
-
common
/
PermissionTestUtils
.
sys
.
mjs
"
FileTestUtils
:
"
resource
:
/
/
testing
-
common
/
FileTestUtils
.
sys
.
mjs
"
Downloads
:
"
resource
:
/
/
gre
/
modules
/
Downloads
.
sys
.
mjs
"
}
)
;
const
kMsecPerMin
=
60
*
1000
;
const
kUsecPerMin
=
60
*
1000000
;
let
today
=
Date
.
now
(
)
-
new
Date
(
)
.
setHours
(
0
0
0
0
)
;
let
nowMSec
=
Date
.
now
(
)
;
let
nowUSec
=
nowMSec
*
1000
;
let
fileURL
;
const
TEST_TARGET_FILE_NAME
=
"
test
-
download
.
txt
"
;
const
TEST_QUOTA_USAGE_HOST
=
"
example
.
com
"
;
const
TEST_QUOTA_USAGE_ORIGIN
=
"
https
:
/
/
"
+
TEST_QUOTA_USAGE_HOST
;
const
TEST_QUOTA_USAGE_URL
=
getRootDirectory
(
gTestPath
)
.
replace
(
"
chrome
:
/
/
mochitests
/
content
"
TEST_QUOTA_USAGE_ORIGIN
)
+
"
site_data_test
.
html
"
;
const
siteOrigins
=
[
"
https
:
/
/
www
.
example
.
com
"
"
https
:
/
/
example
.
org
"
"
http
:
/
/
localhost
:
8000
"
"
http
:
/
/
localhost
:
3000
"
]
;
async
function
promiseHistoryClearedState
(
aURIs
aShouldBeCleared
)
{
for
(
let
uri
of
aURIs
)
{
let
visited
=
await
PlacesUtils
.
history
.
hasVisits
(
uri
)
;
Assert
.
equal
(
visited
!
aShouldBeCleared
history
visit
{
uri
.
spec
}
should
{
aShouldBeCleared
?
"
no
longer
"
:
"
still
"
}
exist
)
;
}
}
function
boolPrefIs
(
aPrefName
aExpectedVal
aMsg
)
{
is
(
Services
.
prefs
.
getBoolPref
(
"
privacy
.
"
+
aPrefName
)
aExpectedVal
aMsg
)
;
}
async
function
downloadExists
(
aPath
)
{
let
publicList
=
await
Downloads
.
getList
(
Downloads
.
PUBLIC
)
;
let
listArray
=
await
publicList
.
getAll
(
)
;
return
listArray
.
some
(
i
=
>
i
.
target
.
path
=
=
aPath
)
;
}
async
function
ensureDownloadsClearedState
(
aDownloadIDs
aShouldBeCleared
)
{
let
niceStr
=
aShouldBeCleared
?
"
no
longer
"
:
"
still
"
;
for
(
let
id
of
aDownloadIDs
)
{
is
(
await
downloadExists
(
id
)
!
aShouldBeCleared
"
download
"
+
id
+
"
should
"
+
niceStr
+
"
exist
"
)
;
}
}
async
function
formNameExists
(
name
)
{
return
!
!
(
await
FormHistory
.
count
(
{
fieldname
:
name
}
)
)
;
}
function
promiseAddFormEntryWithMinutesAgo
(
aMinutesAgo
)
{
let
name
=
aMinutesAgo
+
"
-
minutes
-
ago
"
;
let
timestamp
=
nowUSec
-
aMinutesAgo
*
kUsecPerMin
;
return
FormHistory
.
update
(
{
op
:
"
add
"
fieldname
:
name
value
:
"
dummy
"
firstUsed
:
timestamp
}
)
;
}
async
function
addDownloadWithMinutesAgo
(
aExpectedPathList
aMinutesAgo
)
{
let
publicList
=
await
Downloads
.
getList
(
Downloads
.
PUBLIC
)
;
let
name
=
"
fakefile
-
"
+
aMinutesAgo
+
"
-
minutes
-
ago
"
;
let
download
=
await
Downloads
.
createDownload
(
{
source
:
"
https
:
/
/
bugzilla
.
mozilla
.
org
/
show_bug
.
cgi
?
id
=
480169
"
target
:
name
}
)
;
download
.
startTime
=
new
Date
(
nowMSec
-
aMinutesAgo
*
kMsecPerMin
)
;
download
.
canceled
=
true
;
publicList
.
add
(
download
)
;
ok
(
await
downloadExists
(
name
)
"
Sanity
check
:
download
"
+
name
+
"
should
exist
after
creating
it
"
)
;
aExpectedPathList
.
push
(
name
)
;
}
async
function
addToDownloadList
(
)
{
const
url
=
createFileURL
(
)
;
const
downloadsList
=
await
Downloads
.
getList
(
Downloads
.
PUBLIC
)
;
let
timeOptions
=
[
1
2
4
24
128
128
]
;
let
buffer
=
100000
;
for
(
let
i
=
0
;
i
<
timeOptions
.
length
;
i
+
+
)
{
let
timeDownloaded
=
60
*
kMsecPerMin
*
timeOptions
[
i
]
;
if
(
timeOptions
[
i
]
=
=
=
24
)
{
timeDownloaded
=
today
;
}
let
download
=
await
Downloads
.
createDownload
(
{
source
:
{
url
:
url
.
spec
isPrivate
:
false
}
target
:
{
path
:
FileTestUtils
.
getTempFile
(
TEST_TARGET_FILE_NAME
)
.
path
}
startTime
:
{
getTime
:
_
=
>
{
return
nowMSec
-
timeDownloaded
+
buffer
;
}
}
}
)
;
Assert
.
ok
(
!
!
download
)
;
downloadsList
.
add
(
download
)
;
}
let
items
=
await
downloadsList
.
getAll
(
)
;
Assert
.
equal
(
items
.
length
6
"
Items
were
added
to
the
list
"
)
;
}
async
function
addToSiteUsage
(
)
{
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
TEST_QUOTA_USAGE_URL
false
)
;
await
BrowserTestUtils
.
waitForContentEvent
(
gBrowser
.
selectedBrowser
"
test
-
indexedDB
-
done
"
false
null
true
)
;
BrowserTestUtils
.
removeTab
(
gBrowser
.
selectedTab
)
;
let
siteLastAccessed
=
[
1
2
4
24
]
;
let
staticUsage
=
4096
*
6
;
const
buffer
=
10000
;
for
(
let
index
=
0
;
index
<
siteLastAccessed
.
length
;
index
+
+
)
{
let
lastAccessedTime
=
60
*
kMsecPerMin
*
siteLastAccessed
[
index
]
;
if
(
siteLastAccessed
[
index
]
=
=
=
24
)
{
lastAccessedTime
=
today
;
}
let
site
=
SiteDataManager
.
_testInsertSite
(
siteOrigins
[
index
]
{
quotaUsage
:
staticUsage
lastAccessed
:
(
nowMSec
-
lastAccessedTime
+
buffer
)
*
1000
}
)
;
Assert
.
ok
(
site
"
Site
added
successfully
"
)
;
}
}
function
createFileURL
(
)
{
if
(
!
fileURL
)
{
let
file
=
Services
.
dirsvc
.
get
(
"
TmpD
"
Ci
.
nsIFile
)
;
file
.
append
(
"
foo
.
txt
"
)
;
file
.
createUnique
(
Ci
.
nsIFile
.
NORMAL_FILE_TYPE
0o600
)
;
fileURL
=
Services
.
io
.
newFileURI
(
file
)
;
}
return
fileURL
;
}
add_setup
(
async
function
(
)
{
requestLongerTimeout
(
3
)
;
await
blankSlate
(
)
;
registerCleanupFunction
(
async
function
(
)
{
await
blankSlate
(
)
;
await
PlacesTestUtils
.
promiseAsyncUpdates
(
)
;
}
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
privacy
.
sanitize
.
useOldClearHistoryDialog
"
false
]
]
}
)
;
await
openPreferencesViaOpenPreferencesAPI
(
"
privacy
"
{
leaveOpen
:
true
}
)
;
BrowserTestUtils
.
removeTab
(
gBrowser
.
selectedTab
)
;
}
)
;
async
function
blankSlate
(
)
{
let
publicList
=
await
Downloads
.
getList
(
Downloads
.
PUBLIC
)
;
let
downloads
=
await
publicList
.
getAll
(
)
;
for
(
let
download
of
downloads
)
{
await
publicList
.
remove
(
download
)
;
await
download
.
finalize
(
true
)
;
}
await
FormHistory
.
update
(
{
op
:
"
remove
"
}
)
;
await
PlacesUtils
.
history
.
clear
(
)
;
}
function
DialogHelper
(
browserWin
=
window
mode
=
null
)
{
this
.
_browserWin
=
browserWin
;
this
.
win
=
null
;
this
.
_mode
=
mode
;
this
.
promiseClosed
=
new
Promise
(
resolve
=
>
{
this
.
_resolveClosed
=
resolve
;
}
)
;
}
DialogHelper
.
prototype
=
{
acceptDialog
(
)
{
let
dialogEl
=
this
.
win
.
document
.
querySelector
(
"
dialog
"
)
;
is
(
dialogEl
.
getButton
(
"
accept
"
)
.
disabled
false
"
Dialog
'
s
OK
button
should
not
be
disabled
"
)
;
dialogEl
.
acceptDialog
(
)
;
}
cancelDialog
(
)
{
this
.
win
.
document
.
querySelector
(
"
dialog
"
)
.
cancelDialog
(
)
;
}
checkPrefCheckbox
(
aPrefName
aCheckState
)
{
var
cb
=
this
.
win
.
document
.
querySelectorAll
(
"
checkbox
[
id
=
'
"
+
aPrefName
+
"
'
]
"
)
;
is
(
cb
.
length
1
"
found
checkbox
for
"
+
aPrefName
+
"
id
"
)
;
if
(
cb
[
0
]
.
checked
!
=
aCheckState
)
{
cb
[
0
]
.
click
(
)
;
}
}
validateCheckbox
(
aCheckboxId
aCheckState
)
{
let
cb
=
this
.
win
.
document
.
querySelectorAll
(
"
checkbox
[
id
=
'
"
+
aCheckboxId
+
"
'
]
"
)
;
is
(
cb
.
length
1
found
checkbox
for
id
=
{
aCheckboxId
}
)
;
is
(
cb
[
0
]
.
checked
aCheckState
checkbox
for
{
aCheckboxId
}
is
{
aCheckState
}
)
;
}
_checkAllCheckboxesCustom
(
check
)
{
var
cb
=
this
.
win
.
document
.
querySelectorAll
(
"
checkbox
[
id
]
"
)
;
ok
(
cb
.
length
"
found
checkboxes
for
ids
"
)
;
for
(
var
i
=
0
;
i
<
cb
.
length
;
+
+
i
)
{
if
(
cb
[
i
]
.
checked
!
=
check
)
{
cb
[
i
]
.
click
(
)
;
}
}
}
checkAllCheckboxes
(
)
{
this
.
_checkAllCheckboxesCustom
(
true
)
;
}
uncheckAllCheckboxes
(
)
{
this
.
_checkAllCheckboxesCustom
(
false
)
;
}
setMode
(
value
)
{
this
.
_mode
=
value
;
}
getDurationDropdown
(
)
{
return
this
.
win
.
document
.
getElementById
(
"
sanitizeDurationChoice
"
)
;
}
getWarningPanel
(
)
{
return
this
.
win
.
document
.
getElementById
(
"
sanitizeEverythingWarningBox
"
)
;
}
isWarningPanelVisible
(
)
{
return
!
this
.
getWarningPanel
(
)
.
hidden
;
}
async
open
(
)
{
let
dialogPromise
=
BrowserTestUtils
.
promiseAlertDialogOpen
(
null
"
chrome
:
/
/
browser
/
content
/
sanitize_v2
.
xhtml
"
{
isSubDialog
:
true
}
)
;
executeSoon
(
(
)
=
>
{
Sanitizer
.
showUI
(
this
.
_browserWin
this
.
_mode
)
;
}
)
;
this
.
win
=
await
dialogPromise
;
this
.
win
.
addEventListener
(
"
load
"
(
)
=
>
{
executeSoon
(
async
(
)
=
>
{
await
this
.
win
.
gSanitizePromptDialog
.
dataSizesFinishedUpdatingPromise
;
this
.
onload
(
)
;
}
)
;
}
{
once
:
true
}
)
;
this
.
win
.
addEventListener
(
"
unload
"
(
)
=
>
{
(
async
(
)
=
>
{
if
(
this
.
onunload
)
{
await
this
.
onunload
(
)
;
}
await
PlacesTestUtils
.
promiseAsyncUpdates
(
)
;
this
.
_resolveClosed
(
)
;
this
.
win
=
null
;
}
)
(
)
;
}
{
once
:
true
}
)
;
}
selectDuration
(
aDurVal
)
{
this
.
getDurationDropdown
(
)
.
value
=
aDurVal
;
if
(
aDurVal
=
=
=
Sanitizer
.
TIMESPAN_EVERYTHING
)
{
is
(
this
.
isWarningPanelVisible
(
)
true
"
Warning
panel
should
be
visible
for
TIMESPAN_EVERYTHING
"
)
;
}
else
{
is
(
this
.
isWarningPanelVisible
(
)
false
"
Warning
panel
should
not
be
visible
for
non
-
TIMESPAN_EVERYTHING
"
)
;
}
}
}
;
function
intPrefIs
(
aPrefName
aExpectedVal
aMsg
)
{
is
(
Services
.
prefs
.
getIntPref
(
"
privacy
.
"
+
aPrefName
)
aExpectedVal
aMsg
)
;
}
function
visitTimeForMinutesAgo
(
aMinutesAgo
)
{
return
nowUSec
-
aMinutesAgo
*
kUsecPerMin
;
}
function
promiseSanitizationComplete
(
)
{
return
TestUtils
.
topicObserved
(
"
sanitizer
-
sanitization
-
complete
"
)
;
}
async
function
validateDataSizes
(
dialogHelper
)
{
let
timespans
=
[
"
TIMESPAN_HOUR
"
"
TIMESPAN_2HOURS
"
"
TIMESPAN_4HOURS
"
"
TIMESPAN_TODAY
"
"
TIMESPAN_EVERYTHING
"
]
;
let
cacheUsage
=
await
SiteDataManager
.
getCacheSize
(
)
;
let
quotaUsage
=
await
SiteDataManager
.
getQuotaUsageForTimeRanges
(
timespans
)
;
for
(
let
i
=
0
;
i
<
timespans
.
length
;
i
+
+
)
{
dialogHelper
.
selectDuration
(
Sanitizer
[
timespans
[
i
]
]
)
;
let
clearCookiesAndSiteDataCheckbox
=
dialogHelper
.
win
.
document
.
getElementById
(
"
cookiesAndStorage
"
)
;
let
clearCacheCheckbox
=
dialogHelper
.
win
.
document
.
getElementById
(
"
cache
"
)
;
let
[
convertedQuotaUsage
]
=
DownloadUtils
.
convertByteUnits
(
quotaUsage
[
timespans
[
i
]
]
)
;
let
[
convertedCacheUnit
]
=
DownloadUtils
.
convertByteUnits
(
cacheUsage
)
;
await
dialogHelper
.
win
.
document
.
l10n
.
translateElements
(
[
clearCookiesAndSiteDataCheckbox
clearCacheCheckbox
]
)
;
ok
(
clearCacheCheckbox
.
label
.
includes
(
convertedCacheUnit
)
"
Should
show
the
cache
usage
"
)
;
ok
(
clearCookiesAndSiteDataCheckbox
.
label
.
includes
(
convertedQuotaUsage
)
Should
show
the
quota
usage
as
{
convertedQuotaUsage
}
)
;
}
}
async
function
performActionsOnDialog
(
{
context
=
"
browser
"
timespan
=
Sanitizer
.
TIMESPAN_HOUR
historyFormDataAndDownloads
=
true
cookiesAndStorage
=
true
cache
=
false
siteSettings
=
false
}
)
{
let
dh
=
new
DialogHelper
(
)
;
dh
.
setMode
(
context
)
;
dh
.
onload
=
function
(
)
{
this
.
selectDuration
(
timespan
)
;
this
.
checkPrefCheckbox
(
"
historyFormDataAndDownloads
"
historyFormDataAndDownloads
)
;
this
.
checkPrefCheckbox
(
"
cookiesAndStorage
"
cookiesAndStorage
)
;
this
.
checkPrefCheckbox
(
"
cache
"
cache
)
;
this
.
checkPrefCheckbox
(
"
siteSettings
"
siteSettings
)
;
this
.
acceptDialog
(
)
;
}
;
dh
.
open
(
)
;
await
dh
.
promiseClosed
;
}
add_task
(
async
function
default_state
(
)
{
let
dh
=
new
DialogHelper
(
)
;
dh
.
onload
=
function
(
)
{
this
.
selectDuration
(
Sanitizer
.
TIMESPAN_HOUR
)
;
this
.
acceptDialog
(
)
;
}
;
dh
.
open
(
)
;
await
dh
.
promiseClosed
;
}
)
;
add_task
(
async
function
test_cancel
(
)
{
let
uris
=
[
]
;
let
places
=
[
]
;
let
pURI
;
for
(
let
i
=
0
;
i
<
30
;
i
+
+
)
{
pURI
=
makeURI
(
"
https
:
/
/
"
+
i
+
"
-
minutes
-
ago
.
com
/
"
)
;
places
.
push
(
{
uri
:
pURI
visitDate
:
visitTimeForMinutesAgo
(
i
)
}
)
;
uris
.
push
(
pURI
)
;
}
await
PlacesTestUtils
.
addVisits
(
places
)
;
let
dh
=
new
DialogHelper
(
)
;
dh
.
onload
=
function
(
)
{
this
.
selectDuration
(
Sanitizer
.
TIMESPAN_HOUR
)
;
this
.
checkPrefCheckbox
(
"
historyFormDataAndDownloads
"
false
)
;
this
.
cancelDialog
(
)
;
}
;
dh
.
onunload
=
async
function
(
)
{
await
promiseHistoryClearedState
(
uris
false
)
;
await
blankSlate
(
)
;
await
promiseHistoryClearedState
(
uris
true
)
;
}
;
dh
.
open
(
)
;
await
dh
.
promiseClosed
;
}
)
;
add_task
(
async
function
test_everything
(
)
{
let
uris
=
[
]
;
let
places
=
[
]
;
let
pURI
;
[
10
70
130
250
]
.
forEach
(
function
(
aValue
)
{
pURI
=
makeURI
(
"
https
:
/
/
"
+
aValue
+
"
-
minutes
-
ago
.
com
/
"
)
;
places
.
push
(
{
uri
:
pURI
visitDate
:
visitTimeForMinutesAgo
(
aValue
)
}
)
;
uris
.
push
(
pURI
)
;
}
)
;
let
promiseSanitized
=
promiseSanitizationComplete
(
)
;
await
PlacesTestUtils
.
addVisits
(
places
)
;
let
dh
=
new
DialogHelper
(
)
;
dh
.
onload
=
function
(
)
{
is
(
this
.
isWarningPanelVisible
(
)
false
"
Warning
panel
should
be
hidden
after
previously
accepting
dialog
"
+
"
with
a
predefined
timespan
"
)
;
this
.
selectDuration
(
Sanitizer
.
TIMESPAN_EVERYTHING
)
;
this
.
checkPrefCheckbox
(
"
historyFormDataAndDownloads
"
true
)
;
this
.
acceptDialog
(
)
;
}
;
dh
.
onunload
=
async
function
(
)
{
await
promiseSanitized
;
intPrefIs
(
"
sanitize
.
timeSpan
"
Sanitizer
.
TIMESPAN_EVERYTHING
"
timeSpan
pref
should
be
everything
after
accepting
dialog
"
+
"
with
everything
selected
"
)
;
await
promiseHistoryClearedState
(
uris
true
)
;
}
;
dh
.
open
(
)
;
await
dh
.
promiseClosed
;
}
)
;
add_task
(
async
function
test_everything_warning
(
)
{
let
uris
=
[
]
;
let
places
=
[
]
;
let
pURI
;
[
10
70
130
250
]
.
forEach
(
function
(
aValue
)
{
pURI
=
makeURI
(
"
https
:
/
/
"
+
aValue
+
"
-
minutes
-
ago
.
com
/
"
)
;
places
.
push
(
{
uri
:
pURI
visitDate
:
visitTimeForMinutesAgo
(
aValue
)
}
)
;
uris
.
push
(
pURI
)
;
}
)
;
let
promiseSanitized
=
promiseSanitizationComplete
(
)
;
await
PlacesTestUtils
.
addVisits
(
places
)
;
let
dh
=
new
DialogHelper
(
)
;
dh
.
onload
=
function
(
)
{
is
(
this
.
isWarningPanelVisible
(
)
true
"
Warning
panel
should
be
visible
after
previously
accepting
dialog
"
+
"
with
clearing
everything
"
)
;
this
.
selectDuration
(
Sanitizer
.
TIMESPAN_EVERYTHING
)
;
this
.
checkPrefCheckbox
(
"
historyFormDataAndDownloads
"
true
)
;
this
.
acceptDialog
(
)
;
}
;
dh
.
onunload
=
async
function
(
)
{
intPrefIs
(
"
sanitize
.
timeSpan
"
Sanitizer
.
TIMESPAN_EVERYTHING
"
timeSpan
pref
should
be
everything
after
accepting
dialog
"
+
"
with
everything
selected
"
)
;
await
promiseSanitized
;
await
promiseHistoryClearedState
(
uris
true
)
;
}
;
dh
.
open
(
)
;
await
dh
.
promiseClosed
;
}
)
;
add_task
(
async
function
test_history_downloads_checked
(
)
{
let
downloadIDs
=
[
]
;
for
(
let
i
=
0
;
i
<
5
;
i
+
+
)
{
await
addDownloadWithMinutesAgo
(
downloadIDs
i
)
;
}
let
olderDownloadIDs
=
[
]
;
for
(
let
i
=
0
;
i
<
5
;
i
+
+
)
{
await
addDownloadWithMinutesAgo
(
olderDownloadIDs
61
+
i
)
;
}
let
uris
=
[
]
;
let
places
=
[
]
;
let
pURI
;
for
(
let
i
=
0
;
i
<
30
;
i
+
+
)
{
pURI
=
makeURI
(
"
https
:
/
/
"
+
i
+
"
-
minutes
-
ago
.
com
/
"
)
;
places
.
push
(
{
uri
:
pURI
visitDate
:
visitTimeForMinutesAgo
(
i
)
}
)
;
uris
.
push
(
pURI
)
;
}
let
olderURIs
=
[
]
;
for
(
let
i
=
0
;
i
<
5
;
i
+
+
)
{
pURI
=
makeURI
(
"
https
:
/
/
"
+
(
61
+
i
)
+
"
-
minutes
-
ago
.
com
/
"
)
;
places
.
push
(
{
uri
:
pURI
visitDate
:
visitTimeForMinutesAgo
(
61
+
i
)
}
)
;
olderURIs
.
push
(
pURI
)
;
}
let
promiseSanitized
=
promiseSanitizationComplete
(
)
;
await
PlacesTestUtils
.
addVisits
(
places
)
;
let
dh
=
new
DialogHelper
(
)
;
dh
.
onload
=
function
(
)
{
this
.
selectDuration
(
Sanitizer
.
TIMESPAN_HOUR
)
;
this
.
checkPrefCheckbox
(
"
historyFormDataAndDownloads
"
true
)
;
this
.
acceptDialog
(
)
;
}
;
dh
.
onunload
=
async
function
(
)
{
intPrefIs
(
"
sanitize
.
timeSpan
"
Sanitizer
.
TIMESPAN_HOUR
"
timeSpan
pref
should
be
hour
after
accepting
dialog
with
"
+
"
hour
selected
"
)
;
await
promiseSanitized
;
await
promiseHistoryClearedState
(
uris
true
)
;
await
ensureDownloadsClearedState
(
downloadIDs
true
)
;
await
promiseHistoryClearedState
(
olderURIs
false
)
;
await
ensureDownloadsClearedState
(
olderDownloadIDs
false
)
;
await
blankSlate
(
)
;
await
promiseHistoryClearedState
(
olderURIs
true
)
;
await
ensureDownloadsClearedState
(
olderDownloadIDs
true
)
;
}
;
dh
.
open
(
)
;
await
dh
.
promiseClosed
;
}
)
;
add_task
(
async
function
test_cannot_clear_history
(
)
{
let
formEntries
=
[
await
promiseAddFormEntryWithMinutesAgo
(
10
)
]
;
let
promiseSanitized
=
promiseSanitizationComplete
(
)
;
let
pURI
=
makeURI
(
"
https
:
/
/
"
+
10
+
"
-
minutes
-
ago
.
com
/
"
)
;
await
PlacesTestUtils
.
addVisits
(
{
uri
:
pURI
visitDate
:
visitTimeForMinutesAgo
(
10
)
}
)
;
let
uris
=
[
pURI
]
;
let
dh
=
new
DialogHelper
(
)
;
dh
.
onload
=
function
(
)
{
var
cb
=
this
.
win
.
document
.
querySelectorAll
(
"
checkbox
[
id
=
'
historyFormDataAndDownloads
'
]
"
)
;
ok
(
cb
.
length
=
=
1
&
&
!
cb
[
0
]
.
disabled
"
There
is
history
checkbox
to
clear
history
should
be
enabled
.
"
)
;
this
.
checkAllCheckboxes
(
)
;
this
.
acceptDialog
(
)
;
}
;
dh
.
onunload
=
async
function
(
)
{
await
promiseSanitized
;
await
promiseHistoryClearedState
(
uris
true
)
;
let
exists
=
await
formNameExists
(
formEntries
[
0
]
)
;
ok
(
!
exists
"
form
entry
"
+
formEntries
[
0
]
+
"
should
no
longer
exist
"
)
;
}
;
dh
.
open
(
)
;
await
dh
.
promiseClosed
;
}
)
;
add_task
(
async
function
test_no_formdata_history_to_clear
(
)
{
let
promiseSanitized
=
promiseSanitizationComplete
(
)
;
let
dh
=
new
DialogHelper
(
)
;
dh
.
onload
=
function
(
)
{
var
cb
=
this
.
win
.
document
.
querySelectorAll
(
"
checkbox
[
id
=
'
historyFormDataAndDownloads
'
]
"
)
;
ok
(
cb
.
length
=
=
1
&
&
!
cb
[
0
]
.
disabled
&
&
cb
[
0
]
.
checked
"
There
is
no
history
but
history
checkbox
should
always
be
enabled
"
+
"
and
will
be
checked
from
previous
preference
.
"
)
;
this
.
acceptDialog
(
)
;
}
;
dh
.
open
(
)
;
await
dh
.
promiseClosed
;
await
promiseSanitized
;
}
)
;
add_task
(
async
function
test_form_entries
(
)
{
let
formEntry
=
await
promiseAddFormEntryWithMinutesAgo
(
10
)
;
let
promiseSanitized
=
promiseSanitizationComplete
(
)
;
let
dh
=
new
DialogHelper
(
)
;
dh
.
onload
=
function
(
)
{
var
cb
=
this
.
win
.
document
.
querySelectorAll
(
"
checkbox
[
id
=
'
historyFormDataAndDownloads
'
]
"
)
;
is
(
cb
.
length
1
"
There
is
only
one
checkbox
for
history
and
form
data
"
)
;
ok
(
!
cb
[
0
]
.
disabled
"
The
checkbox
is
enabled
"
)
;
ok
(
cb
[
0
]
.
checked
"
The
checkbox
is
checked
"
)
;
this
.
acceptDialog
(
)
;
}
;
dh
.
onunload
=
async
function
(
)
{
await
promiseSanitized
;
let
exists
=
await
formNameExists
(
formEntry
)
;
ok
(
!
exists
"
form
entry
"
+
formEntry
+
"
should
no
longer
exist
"
)
;
}
;
dh
.
open
(
)
;
await
dh
.
promiseClosed
;
}
)
;
add_task
(
async
function
test_cookie_sizes
(
)
{
await
clearAndValidateDataSizes
(
{
clearCookies
:
true
clearCache
:
false
clearDownloads
:
false
timespan
:
Sanitizer
.
TIMESPAN_HOUR
}
)
;
await
clearAndValidateDataSizes
(
{
clearCookies
:
true
clearCache
:
false
clearDownloads
:
false
timespan
:
Sanitizer
.
TIMESPAN_4HOURS
}
)
;
await
clearAndValidateDataSizes
(
{
clearCookies
:
true
clearCache
:
false
clearDownloads
:
false
timespan
:
Sanitizer
.
TIMESPAN_EVERYTHING
}
)
;
}
)
;
add_task
(
async
function
test_cache_sizes
(
)
{
await
clearAndValidateDataSizes
(
{
clearCookies
:
false
clearCache
:
true
clearDownloads
:
false
timespan
:
Sanitizer
.
TIMESPAN_HOUR
}
)
;
await
clearAndValidateDataSizes
(
{
clearCookies
:
false
clearCache
:
true
clearDownloads
:
false
timespan
:
Sanitizer
.
TIMESPAN_4HOURS
}
)
;
await
clearAndValidateDataSizes
(
{
clearCookies
:
false
clearCache
:
true
clearDownloads
:
false
timespan
:
Sanitizer
.
TIMESPAN_EVERYTHING
}
)
;
}
)
;
add_task
(
async
function
test_downloads_sizes
(
)
{
await
clearAndValidateDataSizes
(
{
clearCookies
:
false
clearCache
:
false
clearDownloads
:
true
timespan
:
Sanitizer
.
TIMESPAN_HOUR
}
)
;
await
clearAndValidateDataSizes
(
{
clearCookies
:
false
clearCache
:
false
clearDownloads
:
true
timespan
:
Sanitizer
.
TIMESPAN_4HOURS
}
)
;
await
clearAndValidateDataSizes
(
{
clearCookies
:
false
clearCache
:
false
clearDownloads
:
true
timespan
:
Sanitizer
.
TIMESPAN_EVERYTHING
}
)
;
}
)
;
add_task
(
async
function
test_all_data_sizes
(
)
{
await
clearAndValidateDataSizes
(
{
clearCookies
:
true
clearCache
:
true
clearDownloads
:
true
timespan
:
Sanitizer
.
TIMESPAN_HOUR
}
)
;
await
clearAndValidateDataSizes
(
{
clearCookies
:
true
clearCache
:
true
clearDownloads
:
true
timespan
:
Sanitizer
.
TIMESPAN_4HOURS
}
)
;
await
clearAndValidateDataSizes
(
{
clearCookies
:
true
clearCache
:
true
clearDownloads
:
true
timespan
:
Sanitizer
.
TIMESPAN_EVERYTHING
}
)
;
}
)
;
add_task
(
async
function
test_clear_on_shutdown
(
)
{
await
openPreferencesViaOpenPreferencesAPI
(
"
privacy
"
{
leaveOpen
:
true
}
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
privacy
.
sanitize
.
sanitizeOnShutdown
"
true
]
]
}
)
;
let
dh
=
new
DialogHelper
(
)
;
dh
.
setMode
(
"
clearOnShutdown
"
)
;
dh
.
onload
=
async
function
(
)
{
this
.
uncheckAllCheckboxes
(
)
;
this
.
checkPrefCheckbox
(
"
historyFormDataAndDownloads
"
false
)
;
this
.
checkPrefCheckbox
(
"
cookiesAndStorage
"
true
)
;
this
.
acceptDialog
(
)
;
}
;
dh
.
open
(
)
;
await
dh
.
promiseClosed
;
let
downloadIDs
=
[
]
;
for
(
let
i
=
0
;
i
<
5
;
i
+
+
)
{
await
addDownloadWithMinutesAgo
(
downloadIDs
i
)
;
}
let
olderDownloadIDs
=
[
]
;
for
(
let
i
=
0
;
i
<
5
;
i
+
+
)
{
await
addDownloadWithMinutesAgo
(
olderDownloadIDs
61
+
i
)
;
}
boolPrefIs
(
"
clearOnShutdown_v2
.
historyFormDataAndDownloads
"
false
"
clearOnShutdown_v2
history
should
be
false
"
)
;
boolPrefIs
(
"
clearOnShutdown_v2
.
cookiesAndStorage
"
true
"
clearOnShutdown_v2
cookies
should
be
true
"
)
;
boolPrefIs
(
"
clearOnShutdown_v2
.
cache
"
false
"
clearOnShutdown_v2
cache
should
be
false
"
)
;
await
createDummyDataForHost
(
"
example
.
org
"
)
;
await
createDummyDataForHost
(
"
example
.
com
"
)
;
ok
(
await
SiteDataTestUtils
.
hasIndexedDB
(
"
https
:
/
/
example
.
org
"
)
"
We
have
indexedDB
data
for
example
.
org
"
)
;
ok
(
await
SiteDataTestUtils
.
hasIndexedDB
(
"
https
:
/
/
example
.
com
"
)
"
We
have
indexedDB
data
for
example
.
com
"
)
;
await
Sanitizer
.
runSanitizeOnShutdown
(
)
;
ok
(
!
(
await
SiteDataTestUtils
.
hasIndexedDB
(
"
https
:
/
/
example
.
org
"
)
)
"
We
don
'
t
have
indexedDB
data
for
example
.
org
"
)
;
ok
(
!
(
await
SiteDataTestUtils
.
hasIndexedDB
(
"
https
:
/
/
example
.
com
"
)
)
"
We
don
'
t
have
indexedDB
data
for
example
.
com
"
)
;
await
ensureDownloadsClearedState
(
downloadIDs
false
)
;
await
ensureDownloadsClearedState
(
olderDownloadIDs
false
)
;
dh
=
new
DialogHelper
(
)
;
dh
.
setMode
(
"
clearOnShutdown
"
)
;
dh
.
onload
=
async
function
(
)
{
this
.
uncheckAllCheckboxes
(
)
;
this
.
checkPrefCheckbox
(
"
historyFormDataAndDownloads
"
true
)
;
this
.
acceptDialog
(
)
;
}
;
dh
.
open
(
)
;
await
dh
.
promiseClosed
;
boolPrefIs
(
"
clearOnShutdown_v2
.
historyFormDataAndDownloads
"
true
"
clearOnShutdown_v2
history
should
be
true
"
)
;
boolPrefIs
(
"
clearOnShutdown_v2
.
cookiesAndStorage
"
false
"
clearOnShutdown_v2
cookies
should
be
false
"
)
;
boolPrefIs
(
"
clearOnShutdown_v2
.
cache
"
false
"
clearOnShutdown_v2
cache
should
be
false
"
)
;
ok
(
await
SiteDataTestUtils
.
hasIndexedDB
(
"
https
:
/
/
example
.
org
"
)
"
We
have
indexedDB
data
for
example
.
org
"
)
;
ok
(
await
SiteDataTestUtils
.
hasIndexedDB
(
"
https
:
/
/
example
.
com
"
)
"
We
have
indexedDB
data
for
example
.
com
"
)
;
await
Sanitizer
.
runSanitizeOnShutdown
(
)
;
ok
(
await
SiteDataTestUtils
.
hasIndexedDB
(
"
https
:
/
/
example
.
org
"
)
"
We
have
indexedDB
data
for
example
.
org
"
)
;
ok
(
await
SiteDataTestUtils
.
hasIndexedDB
(
"
https
:
/
/
example
.
com
"
)
"
We
have
indexedDB
data
for
example
.
com
"
)
;
await
ensureDownloadsClearedState
(
downloadIDs
true
)
;
await
ensureDownloadsClearedState
(
olderDownloadIDs
true
)
;
await
SiteDataTestUtils
.
clear
(
)
;
BrowserTestUtils
.
removeTab
(
gBrowser
.
selectedTab
)
;
}
)
;
add_task
(
async
function
test_defaults_prefs
(
)
{
let
dh
=
new
DialogHelper
(
)
;
dh
.
setMode
(
"
clearSiteData
"
)
;
dh
.
onload
=
function
(
)
{
this
.
validateCheckbox
(
"
historyFormDataAndDownloads
"
false
)
;
this
.
validateCheckbox
(
"
cache
"
true
)
;
this
.
validateCheckbox
(
"
cookiesAndStorage
"
true
)
;
this
.
validateCheckbox
(
"
siteSettings
"
false
)
;
this
.
cancelDialog
(
)
;
}
;
dh
.
open
(
)
;
await
dh
.
promiseClosed
;
dh
=
new
DialogHelper
(
)
;
dh
.
onload
=
function
(
)
{
this
.
validateCheckbox
(
"
historyFormDataAndDownloads
"
true
)
;
this
.
validateCheckbox
(
"
cache
"
true
)
;
this
.
validateCheckbox
(
"
cookiesAndStorage
"
true
)
;
this
.
validateCheckbox
(
"
siteSettings
"
false
)
;
this
.
cancelDialog
(
)
;
}
;
dh
.
open
(
)
;
await
dh
.
promiseClosed
;
}
)
;
async
function
clearAndValidateDataSizes
(
{
clearCache
clearDownloads
clearCookies
timespan
}
)
{
await
blankSlate
(
)
;
await
addToDownloadList
(
)
;
await
addToSiteUsage
(
)
;
let
promiseSanitized
=
promiseSanitizationComplete
(
)
;
await
openPreferencesViaOpenPreferencesAPI
(
"
privacy
"
{
leaveOpen
:
true
}
)
;
let
dh
=
new
DialogHelper
(
)
;
dh
.
onload
=
async
function
(
)
{
await
validateDataSizes
(
this
)
;
this
.
checkPrefCheckbox
(
"
cache
"
clearCache
)
;
this
.
checkPrefCheckbox
(
"
cookiesAndStorage
"
clearCookies
)
;
this
.
checkPrefCheckbox
(
"
historyFormDataAndDownloads
"
clearDownloads
)
;
this
.
selectDuration
(
timespan
)
;
this
.
acceptDialog
(
)
;
}
;
dh
.
onunload
=
async
function
(
)
{
await
promiseSanitized
;
}
;
dh
.
open
(
)
;
await
dh
.
promiseClosed
;
let
dh2
=
new
DialogHelper
(
)
;
dh2
.
onload
=
async
function
(
)
{
await
validateDataSizes
(
this
)
;
this
.
acceptDialog
(
)
;
}
;
dh2
.
open
(
)
;
await
dh2
.
promiseClosed
;
await
SiteDataTestUtils
.
clear
(
)
;
BrowserTestUtils
.
removeTab
(
gBrowser
.
selectedTab
)
;
}
add_task
(
async
function
testEntryPointTelemetry
(
)
{
Services
.
fog
.
testResetFOG
(
)
;
const
EXPECTED_CONTEXT_COUNTS
=
{
browser
:
3
history
:
2
clearData
:
1
}
;
for
(
let
key
in
EXPECTED_CONTEXT_COUNTS
)
{
Services
.
fog
.
testResetFOG
(
)
;
for
(
let
i
=
0
;
i
<
EXPECTED_CONTEXT_COUNTS
[
key
]
;
i
+
+
)
{
await
performActionsOnDialog
(
{
context
:
key
}
)
;
}
is
(
Glean
.
privacySanitize
.
dialogOpen
.
testGetValue
(
)
.
length
EXPECTED_CONTEXT_COUNTS
[
key
]
There
should
be
{
EXPECTED_CONTEXT_COUNTS
[
key
]
}
opens
from
{
key
}
context
)
;
}
}
)
;
add_task
(
async
function
testTimespanTelemetry
(
)
{
Services
.
fog
.
testResetFOG
(
)
;
const
EXPECTED_TIMESPANS
=
[
Sanitizer
.
TIMESPAN_HOUR
Sanitizer
.
TIMESPAN_2HOURS
Sanitizer
.
TIMESPAN_4HOURS
Sanitizer
.
TIMESPAN_EVERYTHING
]
;
for
(
let
timespan
of
EXPECTED_TIMESPANS
)
{
await
performActionsOnDialog
(
{
timespan
}
)
;
}
for
(
let
index
in
EXPECTED_TIMESPANS
)
{
is
(
Glean
.
privacySanitize
.
clearingTimeSpanSelected
.
testGetValue
(
)
[
index
]
.
extra
.
time_span
EXPECTED_TIMESPANS
[
index
]
.
toString
(
)
Selected
timespan
should
be
{
EXPECTED_TIMESPANS
[
index
]
}
)
;
}
}
)
;
add_task
(
async
function
testLoadtimeTelemetry
(
)
{
Services
.
fog
.
testResetFOG
(
)
;
let
EXPECTED_CONTEXT_COUNTS
=
{
browser
:
2
history
:
3
clearData
:
2
}
;
for
(
let
context
in
EXPECTED_CONTEXT_COUNTS
)
{
for
(
let
i
=
0
;
i
<
EXPECTED_CONTEXT_COUNTS
[
context
]
;
i
+
+
)
{
await
performActionsOnDialog
(
{
context
}
)
;
}
}
let
loadTimeDistribution
=
Glean
.
privacySanitize
.
loadTime
.
testGetValue
(
)
;
let
expectedNumberOfCounts
=
Object
.
entries
(
EXPECTED_CONTEXT_COUNTS
)
.
reduce
(
(
acc
[
key
value
]
)
=
>
acc
+
value
0
)
;
is
(
Object
.
entries
(
loadTimeDistribution
.
values
)
.
reduce
(
(
acc
[
bucket
count
]
)
=
>
acc
+
count
0
)
expectedNumberOfCounts
Only
{
expectedNumberOfCounts
}
buckets
with
samples
)
;
}
)
;
add_task
(
async
function
testClearingOptionsTelemetry
(
)
{
Services
.
fog
.
testResetFOG
(
)
;
let
expectedObject
=
{
context
:
"
clearSiteData
"
history_form_data_downloads
:
"
true
"
cookies_and_storage
:
"
false
"
cache
:
"
true
"
site_settings
:
"
true
"
}
;
await
performActionsOnDialog
(
{
context
:
"
clearSiteData
"
historyFormDataAndDownloads
:
true
cookiesAndStorage
:
false
cache
:
true
siteSettings
:
true
}
)
;
let
telemetryObject
=
Glean
.
privacySanitize
.
clear
.
testGetValue
(
)
;
Assert
.
equal
(
telemetryObject
.
length
1
"
There
should
be
only
1
telemetry
object
recorded
"
)
;
Assert
.
deepEqual
(
expectedObject
telemetryObject
[
0
]
.
extra
Expected
{
telemetryObject
}
to
be
the
same
as
{
expectedObject
}
)
;
}
)
;
