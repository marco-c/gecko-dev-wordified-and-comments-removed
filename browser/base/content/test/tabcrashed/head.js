"
use
strict
"
;
const
{
TelemetryTestUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
TelemetryTestUtils
.
sys
.
mjs
"
)
;
function
promiseCrashReport
(
expectedExtra
=
{
}
)
{
return
(
async
function
(
)
{
info
(
"
Starting
wait
on
crash
-
report
-
status
"
)
;
let
[
subject
]
=
await
TestUtils
.
topicObserved
(
"
crash
-
report
-
status
"
(
unused
data
)
=
>
{
return
data
=
=
"
success
"
;
}
)
;
info
(
"
Topic
observed
!
"
)
;
if
(
!
(
subject
instanceof
Ci
.
nsIPropertyBag2
)
)
{
throw
new
Error
(
"
Subject
was
not
a
Ci
.
nsIPropertyBag2
"
)
;
}
let
remoteID
=
getPropertyBagValue
(
subject
"
serverCrashID
"
)
;
if
(
!
remoteID
)
{
throw
new
Error
(
"
Report
should
have
a
server
ID
"
)
;
}
let
file
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsIFile
)
;
file
.
initWithPath
(
Services
.
crashmanager
.
_submittedDumpsDir
)
;
file
.
append
(
remoteID
+
"
.
txt
"
)
;
if
(
!
file
.
exists
(
)
)
{
throw
new
Error
(
"
Report
should
have
been
received
by
the
server
"
)
;
}
file
.
remove
(
false
)
;
let
extra
=
getPropertyBagValue
(
subject
"
extra
"
)
;
if
(
!
(
extra
instanceof
Ci
.
nsIPropertyBag2
)
)
{
throw
new
Error
(
"
extra
was
not
a
Ci
.
nsIPropertyBag2
"
)
;
}
info
(
"
Iterating
crash
report
extra
keys
"
)
;
for
(
let
{
name
:
key
}
of
extra
.
enumerator
)
{
let
value
=
extra
.
getPropertyAsAString
(
key
)
;
if
(
key
in
expectedExtra
)
{
if
(
expectedExtra
[
key
]
=
=
null
)
{
ok
(
false
Got
unexpected
key
{
key
}
with
value
{
value
}
)
;
}
else
{
is
(
value
expectedExtra
[
key
]
Crash
report
had
the
right
extra
value
for
{
key
}
)
;
}
}
}
}
)
(
)
;
}
function
getPropertyBagValue
(
bag
key
)
{
try
{
let
val
=
bag
.
getProperty
(
key
)
;
return
val
;
}
catch
(
e
)
{
if
(
e
.
result
!
=
Cr
.
NS_ERROR_FAILURE
)
{
throw
e
;
}
}
return
null
;
}
async
function
setupLocalCrashReportServer
(
)
{
const
SERVER_URL
=
"
http
:
/
/
example
.
com
/
browser
/
toolkit
/
crashreporter
/
test
/
browser
/
crashreport
.
sjs
"
;
let
noReport
=
Services
.
env
.
get
(
"
MOZ_CRASHREPORTER_NO_REPORT
"
)
;
let
serverUrl
=
Services
.
env
.
get
(
"
MOZ_CRASHREPORTER_URL
"
)
;
Services
.
env
.
set
(
"
MOZ_CRASHREPORTER_NO_REPORT
"
"
"
)
;
Services
.
env
.
set
(
"
MOZ_CRASHREPORTER_URL
"
SERVER_URL
)
;
registerCleanupFunction
(
function
(
)
{
Services
.
env
.
set
(
"
MOZ_CRASHREPORTER_NO_REPORT
"
noReport
)
;
Services
.
env
.
set
(
"
MOZ_CRASHREPORTER_URL
"
serverUrl
)
;
}
)
;
}
function
prepareNoDump
(
)
{
let
originalGetDumpID
=
TabCrashHandler
.
getDumpID
;
TabCrashHandler
.
getDumpID
=
function
(
)
{
return
null
;
}
;
registerCleanupFunction
(
(
)
=
>
{
TabCrashHandler
.
getDumpID
=
originalGetDumpID
;
}
)
;
}
const
kBuildidMatchEnv
=
"
MOZ_BUILDID_MATCH_DONTSEND
"
;
function
setBuildidMatchDontSendEnv
(
)
{
info
(
"
Setting
"
+
kBuildidMatchEnv
+
"
=
1
"
)
;
Services
.
env
.
set
(
kBuildidMatchEnv
"
1
"
)
;
}
function
unsetBuildidMatchDontSendEnv
(
)
{
info
(
"
Setting
"
+
kBuildidMatchEnv
+
"
=
0
"
)
;
Services
.
env
.
set
(
kBuildidMatchEnv
"
0
"
)
;
}
function
getEventPromise
(
eventName
eventKind
)
{
return
new
Promise
(
function
(
resolve
)
{
info
(
"
Installing
event
listener
(
"
+
eventKind
+
"
)
"
)
;
window
.
addEventListener
(
eventName
(
)
=
>
{
ok
(
true
"
Received
"
+
eventName
+
"
(
"
+
eventKind
+
"
)
event
"
)
;
info
(
"
Call
resolve
(
)
for
"
+
eventKind
+
"
event
"
)
;
resolve
(
)
;
}
{
once
:
true
}
)
;
info
(
"
Installed
event
listener
(
"
+
eventKind
+
"
)
"
)
;
}
)
;
}
async
function
ensureBuildID
(
)
{
let
profD
=
Services
.
dirsvc
.
get
(
"
GreD
"
Ci
.
nsIFile
)
;
let
platformIniOrig
=
await
IOUtils
.
readUTF8
(
PathUtils
.
join
(
profD
.
path
"
platform
.
ini
"
)
)
;
let
buildID
=
Services
.
appinfo
.
platformBuildID
;
return
platformIniOrig
.
indexOf
(
buildID
)
>
0
;
}
async
function
openNewTab
(
forceCrash
)
{
const
PAGE
=
"
data
:
text
/
html
<
html
>
<
body
>
A
%
20regular
%
20everyday
%
20normal
%
20page
.
"
;
let
options
=
{
gBrowser
PAGE
waitForLoad
:
false
waitForStateStop
:
false
forceNewProcess
:
true
}
;
let
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
options
)
;
if
(
forceCrash
=
=
=
true
)
{
let
browser
=
tab
.
linkedBrowser
;
await
BrowserTestUtils
.
crashFrame
(
browser
false
true
null
)
;
}
return
tab
;
}
async
function
closeTab
(
tab
)
{
await
TestUtils
.
waitForTick
(
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
}
function
getFalsePositiveTelemetry
(
)
{
const
scalars
=
TelemetryTestUtils
.
getProcessScalars
(
"
parent
"
)
;
return
scalars
[
"
dom
.
contentprocess
.
buildID_mismatch_false_positive
"
]
;
}
async
function
forceCleanProcesses
(
)
{
const
origPrefValue
=
SpecialPowers
.
getBoolPref
(
"
dom
.
ipc
.
processPrelaunch
.
enabled
"
)
;
await
SpecialPowers
.
setBoolPref
(
"
dom
.
ipc
.
processPrelaunch
.
enabled
"
!
origPrefValue
)
;
await
SpecialPowers
.
setBoolPref
(
"
dom
.
ipc
.
processPrelaunch
.
enabled
"
origPrefValue
)
;
const
currPrefValue
=
SpecialPowers
.
getBoolPref
(
"
dom
.
ipc
.
processPrelaunch
.
enabled
"
)
;
Assert
.
strictEqual
(
currPrefValue
origPrefValue
"
processPrelaunch
properly
re
-
enabled
"
)
;
}
