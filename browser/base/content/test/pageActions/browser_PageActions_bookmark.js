"
use
strict
"
;
add_task
(
async
function
starButtonCtrlClick
(
)
{
let
url
=
"
http
:
/
/
example
.
com
/
browser_page_action_star_button
"
;
await
BrowserTestUtils
.
withNewTab
(
url
async
(
)
=
>
{
StarUI
.
_createPanelIfNeeded
(
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
BookmarkingUI
.
status
!
=
BookmarkingUI
.
STATUS_UPDATING
)
;
const
popup
=
document
.
getElementById
(
"
editBookmarkPanel
"
)
;
const
starButtonBox
=
document
.
getElementById
(
"
star
-
button
-
box
"
)
;
let
shownPromise
=
promisePanelShown
(
popup
)
;
EventUtils
.
synthesizeMouseAtCenter
(
starButtonBox
{
ctrlKey
:
true
}
)
;
await
shownPromise
;
ok
(
true
"
Panel
shown
after
button
pressed
"
)
;
let
hiddenPromise
=
promisePanelHidden
(
popup
)
;
document
.
getElementById
(
"
editBookmarkPanelRemoveButton
"
)
.
click
(
)
;
await
hiddenPromise
;
}
)
;
}
)
;
add_task
(
async
function
bookmark
(
)
{
let
url
=
"
http
:
/
/
example
.
com
/
browser_page_action_menu
"
;
await
BrowserTestUtils
.
withNewTab
(
url
async
(
)
=
>
{
let
bookmarkButton
=
BrowserPageActions
.
urlbarButtonNodeForActionID
(
"
bookmark
"
)
;
let
tooltipText
=
bookmarkButton
.
getAttribute
(
"
tooltiptext
"
)
;
Assert
.
ok
(
tooltipText
.
startsWith
(
"
Bookmark
this
page
"
)
Expecting
the
tooltip
text
to
be
updated
.
Tooltip
text
:
{
tooltipText
}
)
;
Assert
.
ok
(
!
bookmarkButton
.
hasAttribute
(
"
starred
"
)
)
;
info
(
"
Click
the
button
.
"
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
BookmarkingUI
.
status
!
=
BookmarkingUI
.
STATUS_UPDATING
)
;
let
onItemAddedPromise
=
PlacesTestUtils
.
waitForNotification
(
"
bookmark
-
added
"
events
=
>
events
.
some
(
event
=
>
event
.
url
=
=
url
)
"
places
"
)
;
let
promise
=
BrowserTestUtils
.
waitForPopupEvent
(
StarUI
.
panel
"
shown
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
bookmarkButton
{
}
)
;
await
promise
;
await
onItemAddedPromise
;
Assert
.
equal
(
BookmarkingUI
.
starBox
.
getAttribute
(
"
open
"
)
"
true
"
"
Star
has
open
attribute
"
)
;
tooltipText
=
bookmarkButton
.
getAttribute
(
"
tooltiptext
"
)
;
Assert
.
ok
(
tooltipText
.
startsWith
(
"
Edit
this
bookmark
"
)
Expecting
the
tooltip
text
to
be
updated
.
Tooltip
text
:
{
tooltipText
}
)
;
Assert
.
equal
(
bookmarkButton
.
firstChild
.
getAttribute
(
"
starred
"
)
"
true
"
)
;
StarUI
.
panel
.
hidePopup
(
)
;
Assert
.
ok
(
!
BookmarkingUI
.
starBox
.
hasAttribute
(
"
open
"
)
"
Star
no
longer
has
open
attribute
"
)
;
info
(
"
Click
it
again
.
"
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
BookmarkingUI
.
status
!
=
BookmarkingUI
.
STATUS_UPDATING
)
;
promise
=
BrowserTestUtils
.
waitForPopupEvent
(
StarUI
.
panel
"
shown
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
bookmarkButton
{
}
)
;
await
promise
;
let
onItemRemovedPromise
=
PlacesTestUtils
.
waitForNotification
(
"
bookmark
-
removed
"
events
=
>
events
.
some
(
event
=
>
event
.
url
=
=
url
)
"
places
"
)
;
StarUI
.
_element
(
"
editBookmarkPanelRemoveButton
"
)
.
click
(
)
;
await
onItemRemovedPromise
;
let
contextMenuPromise
=
promisePopupNotShown
(
"
pageActionContextMenu
"
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
BookmarkingUI
.
status
!
=
BookmarkingUI
.
STATUS_UPDATING
)
;
EventUtils
.
synthesizeMouseAtCenter
(
bookmarkButton
{
type
:
"
contextmenu
"
button
:
2
}
)
;
await
contextMenuPromise
;
}
)
;
}
)
;
add_task
(
async
function
bookmarkDelayedApply
(
)
{
const
url
=
"
http
:
/
/
example
.
com
/
browser_page_action_menu_delayed_apply
"
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
bookmarks
.
editDialog
.
delayedApply
.
enabled
"
true
]
]
}
)
;
const
win
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
registerCleanupFunction
(
async
(
)
=
>
{
await
BrowserTestUtils
.
closeWindow
(
win
)
;
}
)
;
await
BrowserTestUtils
.
withNewTab
(
{
gBrowser
:
win
.
gBrowser
url
}
async
(
)
=
>
{
const
bookmarkButton
=
win
.
BrowserPageActions
.
urlbarButtonNodeForActionID
(
"
bookmark
"
)
;
Assert
.
ok
(
!
bookmarkButton
.
hasAttribute
(
"
starred
"
)
)
;
info
(
"
Click
the
button
.
"
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
BookmarkingUI
.
status
!
=
BookmarkingUI
.
STATUS_UPDATING
)
;
const
starUIPanel
=
win
.
StarUI
.
panel
;
let
panelShown
=
BrowserTestUtils
.
waitForPopupEvent
(
starUIPanel
"
shown
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
bookmarkButton
{
}
win
)
;
await
panelShown
;
is
(
await
PlacesUtils
.
bookmarks
.
fetch
(
{
url
}
)
null
"
Bookmark
has
not
been
created
before
save
.
"
)
;
Assert
.
equal
(
bookmarkButton
.
firstChild
.
getAttribute
(
"
starred
"
)
"
true
"
)
;
info
(
"
Save
the
bookmark
.
"
)
;
const
onItemAddedPromise
=
PlacesTestUtils
.
waitForNotification
(
"
bookmark
-
added
"
events
=
>
events
.
some
(
event
=
>
event
.
url
=
=
url
)
"
places
"
)
;
starUIPanel
.
hidePopup
(
)
;
await
onItemAddedPromise
;
info
(
"
Click
it
again
.
"
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
BookmarkingUI
.
status
!
=
BookmarkingUI
.
STATUS_UPDATING
)
;
panelShown
=
BrowserTestUtils
.
waitForPopupEvent
(
starUIPanel
"
shown
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
bookmarkButton
{
}
win
)
;
await
panelShown
;
info
(
"
Remove
the
bookmark
.
"
)
;
const
onItemRemovedPromise
=
PlacesTestUtils
.
waitForNotification
(
"
bookmark
-
removed
"
events
=
>
events
.
some
(
event
=
>
event
.
url
=
=
url
)
"
places
"
)
;
win
.
StarUI
.
_element
(
"
editBookmarkPanelRemoveButton
"
)
.
click
(
)
;
await
onItemRemovedPromise
;
}
)
;
}
)
;
add_task
(
async
function
bookmarkDelayedApplyNoEditDialog
(
)
{
const
url
=
"
http
:
/
/
example
.
com
/
browser_page_action_menu_delayed_apply_no_edit_dialog
"
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
bookmarks
.
editDialog
.
delayedApply
.
enabled
"
true
]
[
"
browser
.
bookmarks
.
editDialog
.
showForNewBookmarks
"
false
]
]
}
)
;
const
win
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
registerCleanupFunction
(
async
(
)
=
>
{
await
BrowserTestUtils
.
closeWindow
(
win
)
;
await
PlacesUtils
.
bookmarks
.
eraseEverything
(
)
;
}
)
;
await
BrowserTestUtils
.
withNewTab
(
{
gBrowser
:
win
.
gBrowser
url
}
async
(
)
=
>
{
info
(
"
Click
the
button
.
"
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
BookmarkingUI
.
status
!
=
BookmarkingUI
.
STATUS_UPDATING
)
;
const
bookmarkButton
=
win
.
document
.
getElementById
(
BrowserPageActions
.
urlbarButtonNodeIDForActionID
(
"
bookmark
"
)
)
;
const
onItemAddedPromise
=
PlacesTestUtils
.
waitForNotification
(
"
bookmark
-
added
"
events
=
>
events
.
some
(
event
=
>
event
.
url
=
=
url
)
"
places
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
bookmarkButton
{
}
win
)
;
await
onItemAddedPromise
;
}
)
;
}
)
;
