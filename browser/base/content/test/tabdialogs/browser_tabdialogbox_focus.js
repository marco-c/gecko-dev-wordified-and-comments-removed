"
use
strict
"
;
const
TEST_ROOT_CHROME
=
getRootDirectory
(
gTestPath
)
;
const
TEST_DIALOG_PATH
=
TEST_ROOT_CHROME
+
"
subdialog
.
xhtml
"
;
add_task
(
async
function
test_tabdialogbox_tab_switch_focus
(
)
{
let
tabPromises
=
[
]
;
for
(
let
i
=
0
;
i
<
3
;
i
+
=
1
)
{
tabPromises
.
push
(
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
"
http
:
/
/
example
.
com
"
true
)
)
;
}
let
tabs
=
await
Promise
.
all
(
tabPromises
)
;
let
dialogs
=
[
]
;
for
(
let
i
=
0
;
i
<
2
;
i
+
=
1
)
{
let
dialogBox
=
gBrowser
.
getTabDialogBox
(
tabs
[
i
]
.
linkedBrowser
)
;
dialogBox
.
open
(
TEST_DIALOG_PATH
)
;
dialogs
.
push
(
dialogBox
.
getTabDialogManager
(
)
.
_topDialog
)
;
}
await
Promise
.
all
(
[
dialogs
[
0
]
.
_dialogReady
dialogs
[
1
]
.
_dialogReady
]
)
;
await
BrowserTestUtils
.
switchTab
(
gBrowser
tabs
[
0
]
)
;
let
dialogTextbox
=
dialogs
[
0
]
.
_frame
.
contentDocument
.
querySelector
(
"
#
textbox
"
)
;
is
(
Services
.
focus
.
focusedElement
dialogTextbox
"
Dialog
textbox
is
focused
"
)
;
await
BrowserTestUtils
.
switchTab
(
gBrowser
tabs
[
1
]
)
;
let
dialogTextbox2
=
dialogs
[
1
]
.
_frame
.
contentDocument
.
querySelector
(
"
#
textbox
"
)
;
is
(
Services
.
focus
.
focusedElement
dialogTextbox2
"
Dialog2
textbox
is
focused
"
)
;
await
BrowserTestUtils
.
switchTab
(
gBrowser
tabs
[
2
]
)
;
is
(
Services
.
focus
.
focusedElement
tabs
[
2
]
.
linkedBrowser
"
Top
level
browser
is
focused
"
)
;
tabs
.
forEach
(
tab
=
>
{
BrowserTestUtils
.
removeTab
(
tab
)
;
}
)
;
}
)
;
add_task
(
async
function
test_tabdialogbox_multiple_focus
(
)
{
await
BrowserTestUtils
.
withNewTab
(
gBrowser
async
browser
=
>
{
let
dialogBox
=
gBrowser
.
getTabDialogBox
(
browser
)
;
let
dialogAClose
=
dialogBox
.
open
(
TEST_DIALOG_PATH
{
}
{
testCustomFocusHandler
:
true
}
)
.
closedPromise
;
let
dialogBClose
=
dialogBox
.
open
(
TEST_DIALOG_PATH
)
.
closedPromise
;
let
dialogCClose
=
dialogBox
.
open
(
TEST_DIALOG_PATH
{
}
{
testCustomFocusHandler
:
true
}
)
.
closedPromise
;
let
dialogs
=
dialogBox
.
_tabDialogManager
.
_dialogs
;
let
[
dialogA
dialogB
dialogC
]
=
dialogs
;
await
Promise
.
all
(
dialogs
.
map
(
dialog
=
>
dialog
.
_dialogReady
)
)
;
let
dialogElementA
=
dialogA
.
_frame
.
contentDocument
.
querySelector
(
"
#
custom
-
focus
-
el
"
)
;
is
(
Services
.
focus
.
focusedElement
dialogElementA
"
Dialog
A
custom
focus
target
is
focused
"
)
;
dialogA
.
close
(
)
;
await
dialogAClose
;
let
dialogElementB
=
dialogB
.
_frame
.
contentDocument
.
querySelector
(
"
#
textbox
"
)
;
is
(
Services
.
focus
.
focusedElement
dialogElementB
"
Dialog
B
default
focus
target
is
focused
"
)
;
dialogB
.
close
(
)
;
await
dialogBClose
;
let
dialogElementC
=
dialogC
.
_frame
.
contentDocument
.
querySelector
(
"
#
custom
-
focus
-
el
"
)
;
is
(
Services
.
focus
.
focusedElement
dialogElementC
"
Dialog
C
custom
focus
target
is
focused
"
)
;
dialogC
.
close
(
)
;
await
dialogCClose
;
is
(
dialogBox
.
_tabDialogManager
.
_dialogs
.
length
0
"
All
dialogs
should
be
closed
"
)
;
is
(
Services
.
focus
.
focusedElement
browser
"
Focus
should
be
back
on
the
browser
"
)
;
}
)
;
}
)
;
add_task
(
async
function
test_tabdialogbox_tab_switch_hidden
(
)
{
let
tabPromises
=
[
]
;
for
(
let
i
=
0
;
i
<
2
;
i
+
=
1
)
{
tabPromises
.
push
(
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
"
http
:
/
/
example
.
com
"
true
)
)
;
}
let
tabs
=
await
Promise
.
all
(
tabPromises
)
;
let
dialogs
=
[
]
;
let
dialogBox
dialogBoxManager
browser
;
for
(
let
i
=
0
;
i
<
2
;
i
+
=
1
)
{
dialogBox
=
gBrowser
.
getTabDialogBox
(
tabs
[
i
]
.
linkedBrowser
)
;
browser
=
tabs
[
i
]
.
linkedBrowser
;
dialogBox
.
open
(
TEST_DIALOG_PATH
)
;
dialogBoxManager
=
dialogBox
.
getTabDialogManager
(
)
;
dialogs
.
push
(
dialogBoxManager
.
_topDialog
)
;
}
await
Promise
.
all
(
[
dialogs
[
0
]
.
_dialogReady
dialogs
[
1
]
.
_dialogReady
]
)
;
dialogBoxManager
.
hideDialog
(
browser
)
;
ok
(
BrowserTestUtils
.
is_hidden
(
dialogBoxManager
.
_dialogStack
)
"
Dialog
stack
is
hidden
"
)
;
await
BrowserTestUtils
.
switchTab
(
gBrowser
tabs
[
0
]
)
;
dialogBoxManager
=
gBrowser
.
getTabDialogBox
(
tabs
[
0
]
.
linkedBrowser
)
.
getTabDialogManager
(
)
;
is
(
dialogBoxManager
.
_dialogStack
.
hidden
false
"
Dialog
stack
is
showing
"
)
;
tabs
.
forEach
(
tab
=
>
{
BrowserTestUtils
.
removeTab
(
tab
)
;
}
)
;
}
)
;
