const
BASE
=
getRootDirectory
(
gTestPath
)
.
replace
(
"
chrome
:
/
/
mochitests
/
content
/
"
"
https
:
/
/
example
.
com
/
"
)
;
function
promisePopupNotificationShown
(
name
)
{
return
new
Promise
(
resolve
=
>
{
function
popupshown
(
)
{
let
notification
=
PopupNotifications
.
getNotification
(
name
)
;
if
(
!
notification
)
{
return
;
}
ok
(
notification
{
name
}
notification
shown
)
;
ok
(
PopupNotifications
.
isPanelOpen
"
notification
panel
open
"
)
;
PopupNotifications
.
panel
.
removeEventListener
(
"
popupshown
"
popupshown
)
;
resolve
(
PopupNotifications
.
panel
.
firstChild
)
;
}
PopupNotifications
.
panel
.
addEventListener
(
"
popupshown
"
popupshown
)
;
}
)
;
}
function
promiseInstallEvent
(
addon
event
)
{
return
new
Promise
(
resolve
=
>
{
let
listener
=
{
}
;
listener
[
event
]
=
(
install
arg
)
=
>
{
if
(
install
.
addon
.
id
=
=
addon
.
id
)
{
AddonManager
.
removeInstallListener
(
listener
)
;
resolve
(
arg
)
;
}
}
;
AddonManager
.
addInstallListener
(
listener
)
;
}
)
;
}
function
promiseInstallAddon
(
url
)
{
return
AddonManager
.
getInstallForURL
(
url
null
"
application
/
x
-
xpinstall
"
)
.
then
(
install
=
>
{
ok
(
install
"
Created
install
"
)
;
return
new
Promise
(
resolve
=
>
{
install
.
addListener
(
{
onInstallEnded
(
_install
addon
)
{
resolve
(
addon
)
;
}
}
)
;
install
.
install
(
)
;
}
)
;
}
)
;
}
function
isDefaultIcon
(
icon
)
{
return
(
icon
=
=
"
chrome
:
/
/
browser
/
content
/
extension
.
svg
"
|
|
icon
=
=
"
chrome
:
/
/
mozapps
/
skin
/
extensions
/
extensionGeneric
.
svg
"
)
;
}
function
is_hidden
(
element
)
{
var
style
=
element
.
ownerGlobal
.
getComputedStyle
(
element
)
;
if
(
style
.
display
=
=
"
none
"
)
return
true
;
if
(
style
.
visibility
!
=
"
visible
"
)
return
true
;
if
(
style
.
display
=
=
"
-
moz
-
popup
"
)
return
[
"
hiding
"
"
closed
"
]
.
indexOf
(
element
.
state
)
!
=
-
1
;
if
(
element
.
parentNode
!
=
element
.
ownerDocument
)
return
is_hidden
(
element
.
parentNode
)
;
return
false
;
}
function
is_visible
(
element
)
{
var
style
=
element
.
ownerGlobal
.
getComputedStyle
(
element
)
;
if
(
style
.
display
=
=
"
none
"
)
return
false
;
if
(
style
.
visibility
!
=
"
visible
"
)
return
false
;
if
(
style
.
display
=
=
"
-
moz
-
popup
"
&
&
element
.
state
!
=
"
open
"
)
return
false
;
if
(
element
.
parentNode
!
=
element
.
ownerDocument
)
return
is_visible
(
element
.
parentNode
)
;
return
true
;
}
function
checkPermissionString
(
string
key
param
msg
)
{
let
localizedString
=
param
?
gBrowserBundle
.
formatStringFromName
(
key
[
param
]
1
)
:
gBrowserBundle
.
GetStringFromName
(
key
)
;
if
(
localizedString
.
includes
(
"
%
S
"
)
)
{
let
i
=
localizedString
.
indexOf
(
"
%
S
"
)
;
ok
(
string
.
startsWith
(
localizedString
.
slice
(
0
i
)
)
msg
)
;
ok
(
string
.
endsWith
(
localizedString
.
slice
(
i
+
2
)
)
msg
)
;
}
else
{
is
(
string
localizedString
msg
)
;
}
}
async
function
testInstallMethod
(
installFn
)
{
const
PERMS_XPI
=
"
browser_webext_permissions
.
xpi
"
;
const
NO_PERMS_XPI
=
"
browser_webext_nopermissions
.
xpi
"
;
const
ID
=
"
permissions
test
.
mozilla
.
org
"
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
extensions
.
webapi
.
testing
"
true
]
[
"
extensions
.
install
.
requireBuiltInCerts
"
false
]
[
"
extensions
.
webextPermissionPrompts
"
true
]
]
}
)
;
let
testURI
=
makeURI
(
"
https
:
/
/
example
.
com
/
"
)
;
Services
.
perms
.
add
(
testURI
"
install
"
Services
.
perms
.
ALLOW_ACTION
)
;
registerCleanupFunction
(
(
)
=
>
Services
.
perms
.
remove
(
testURI
"
install
"
)
)
;
async
function
runOnce
(
filename
cancel
)
{
let
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
)
;
let
installPromise
=
new
Promise
(
resolve
=
>
{
let
listener
=
{
onDownloadCancelled
(
)
{
AddonManager
.
removeInstallListener
(
listener
)
;
resolve
(
false
)
;
}
onDownloadFailed
(
)
{
AddonManager
.
removeInstallListener
(
listener
)
;
resolve
(
false
)
;
}
onInstallCancelled
(
)
{
AddonManager
.
removeInstallListener
(
listener
)
;
resolve
(
false
)
;
}
onInstallEnded
(
)
{
AddonManager
.
removeInstallListener
(
listener
)
;
resolve
(
true
)
;
}
onInstallFailed
(
)
{
AddonManager
.
removeInstallListener
(
listener
)
;
resolve
(
false
)
;
}
}
;
AddonManager
.
addInstallListener
(
listener
)
;
}
)
;
let
installMethodPromise
=
installFn
(
filename
)
;
let
panel
=
await
promisePopupNotificationShown
(
"
addon
-
webext
-
permissions
"
)
;
let
icon
=
panel
.
getAttribute
(
"
icon
"
)
;
let
ul
=
document
.
getElementById
(
"
addon
-
webext
-
perm
-
list
"
)
;
let
header
=
document
.
getElementById
(
"
addon
-
webext
-
perm
-
intro
"
)
;
if
(
filename
=
=
PERMS_XPI
)
{
ok
(
icon
.
startsWith
(
"
jar
:
file
:
/
/
"
)
"
Icon
is
a
jar
url
"
)
;
ok
(
icon
.
endsWith
(
"
/
icon
.
png
"
)
"
Icon
is
icon
.
png
inside
a
jar
"
)
;
is
(
header
.
getAttribute
(
"
hidden
"
)
"
"
"
Permission
list
header
is
visible
"
)
;
is
(
ul
.
childElementCount
5
"
Permissions
list
has
5
entries
"
)
;
checkPermissionString
(
ul
.
children
[
0
]
.
textContent
"
webextPerms
.
hostDescription
.
wildcard
"
"
wildcard
.
domain
"
"
First
permission
is
domain
permission
"
)
;
checkPermissionString
(
ul
.
children
[
1
]
.
textContent
"
webextPerms
.
hostDescription
.
oneSite
"
"
singlehost
.
domain
"
"
Second
permission
is
single
host
permission
"
)
;
checkPermissionString
(
ul
.
children
[
2
]
.
textContent
"
webextPerms
.
description
.
nativeMessaging
"
null
"
Third
permission
is
nativeMessaging
"
)
;
checkPermissionString
(
ul
.
children
[
3
]
.
textContent
"
webextPerms
.
description
.
tabs
"
null
"
Fourth
permission
is
tabs
"
)
;
checkPermissionString
(
ul
.
children
[
4
]
.
textContent
"
webextPerms
.
description
.
history
"
null
"
Fifth
permission
is
history
"
)
;
}
else
if
(
filename
=
=
NO_PERMS_XPI
)
{
ok
(
isDefaultIcon
(
icon
)
"
Icon
is
the
default
extension
icon
"
)
;
is
(
header
.
getAttribute
(
"
hidden
"
)
"
true
"
"
Permission
list
header
is
hidden
"
)
;
is
(
ul
.
childElementCount
0
"
Permissions
list
has
0
entries
"
)
;
}
if
(
cancel
)
{
panel
.
secondaryButton
.
click
(
)
;
try
{
await
installMethodPromise
;
}
catch
(
err
)
{
}
}
else
{
let
postInstallPromise
=
promisePopupNotificationShown
(
"
addon
-
installed
"
)
;
panel
.
button
.
click
(
)
;
panel
=
await
postInstallPromise
;
panel
.
button
.
click
(
)
;
await
installMethodPromise
;
}
let
result
=
await
installPromise
;
let
addon
=
await
AddonManager
.
getAddonByID
(
ID
)
;
if
(
cancel
)
{
ok
(
!
result
"
Installation
was
cancelled
"
)
;
is
(
addon
null
"
Extension
is
not
installed
"
)
;
}
else
{
ok
(
result
"
Installation
completed
"
)
;
isnot
(
addon
null
"
Extension
is
installed
"
)
;
addon
.
uninstall
(
)
;
}
await
BrowserTestUtils
.
removeTab
(
tab
)
;
}
await
runOnce
(
NO_PERMS_XPI
true
)
;
await
runOnce
(
PERMS_XPI
true
)
;
await
runOnce
(
PERMS_XPI
false
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
let
testCleanup
;
add_task
(
async
function
(
)
{
let
addons
=
await
AddonManager
.
getAllAddons
(
)
;
let
existingAddons
=
new
Set
(
addons
.
map
(
a
=
>
a
.
id
)
)
;
registerCleanupFunction
(
async
function
(
)
{
if
(
testCleanup
)
{
await
testCleanup
(
)
;
testCleanup
=
null
;
}
for
(
let
addon
of
await
AddonManager
.
getAllAddons
(
)
)
{
if
(
!
existingAddons
.
has
(
addon
.
id
)
)
{
ok
(
false
Addon
{
addon
.
id
}
was
left
installed
at
the
end
of
the
test
)
;
addon
.
uninstall
(
)
;
}
}
}
)
;
}
)
;
