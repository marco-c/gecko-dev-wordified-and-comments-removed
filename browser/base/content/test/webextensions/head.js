ChromeUtils
.
defineModuleGetter
(
this
"
AddonTestUtils
"
"
resource
:
/
/
testing
-
common
/
AddonTestUtils
.
jsm
"
)
;
const
BASE
=
getRootDirectory
(
gTestPath
)
.
replace
(
"
chrome
:
/
/
mochitests
/
content
/
"
"
https
:
/
/
example
.
com
/
"
)
;
var
{
ExtensionsUI
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
/
modules
/
ExtensionsUI
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
Management
"
(
)
=
>
{
const
{
Management
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Extension
.
jsm
"
null
)
;
return
Management
;
}
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
CustomizableUITestUtils
.
jsm
"
this
)
;
let
gCUITestUtils
=
new
CustomizableUITestUtils
(
window
)
;
function
promisePopupNotificationShown
(
name
)
{
return
new
Promise
(
resolve
=
>
{
function
popupshown
(
)
{
let
notification
=
PopupNotifications
.
getNotification
(
name
)
;
if
(
!
notification
)
{
return
;
}
ok
(
notification
{
name
}
notification
shown
)
;
ok
(
PopupNotifications
.
isPanelOpen
"
notification
panel
open
"
)
;
PopupNotifications
.
panel
.
removeEventListener
(
"
popupshown
"
popupshown
)
;
resolve
(
PopupNotifications
.
panel
.
firstElementChild
)
;
}
PopupNotifications
.
panel
.
addEventListener
(
"
popupshown
"
popupshown
)
;
}
)
;
}
function
promiseAppMenuNotificationShown
(
id
)
{
const
{
AppMenuNotifications
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppMenuNotifications
.
jsm
"
)
;
return
new
Promise
(
resolve
=
>
{
function
popupshown
(
)
{
let
notification
=
AppMenuNotifications
.
activeNotification
;
if
(
!
notification
)
{
return
;
}
is
(
notification
.
id
id
{
id
}
notification
shown
)
;
ok
(
PanelUI
.
isNotificationPanelOpen
"
notification
panel
open
"
)
;
PanelUI
.
notificationPanel
.
removeEventListener
(
"
popupshown
"
popupshown
)
;
let
popupnotificationID
=
PanelUI
.
_getPopupId
(
notification
)
;
let
popupnotification
=
document
.
getElementById
(
popupnotificationID
)
;
resolve
(
popupnotification
)
;
}
PanelUI
.
notificationPanel
.
addEventListener
(
"
popupshown
"
popupshown
)
;
}
)
;
}
function
promiseInstallEvent
(
addon
event
)
{
return
new
Promise
(
resolve
=
>
{
let
listener
=
{
}
;
listener
[
event
]
=
(
install
arg
)
=
>
{
if
(
install
.
addon
.
id
=
=
addon
.
id
)
{
AddonManager
.
removeInstallListener
(
listener
)
;
resolve
(
arg
)
;
}
}
;
AddonManager
.
addInstallListener
(
listener
)
;
}
)
;
}
async
function
promiseInstallAddon
(
url
installTelemetryInfo
)
{
let
install
=
await
AddonManager
.
getInstallForURL
(
url
"
application
/
x
-
xpinstall
"
null
null
null
null
null
installTelemetryInfo
)
;
install
.
install
(
)
;
let
addon
=
await
new
Promise
(
resolve
=
>
{
install
.
addListener
(
{
onInstallEnded
(
_install
_addon
)
{
resolve
(
_addon
)
;
}
}
)
;
}
)
;
if
(
addon
.
isWebExtension
)
{
await
new
Promise
(
resolve
=
>
{
function
listener
(
event
extension
)
{
if
(
extension
.
id
=
=
addon
.
id
)
{
Management
.
off
(
"
ready
"
listener
)
;
resolve
(
)
;
}
}
Management
.
on
(
"
ready
"
listener
)
;
}
)
;
}
return
addon
;
}
async
function
waitForUpdate
(
addon
)
{
let
installPromise
=
promiseInstallEvent
(
addon
"
onInstallEnded
"
)
;
let
readyPromise
=
new
Promise
(
resolve
=
>
{
function
listener
(
event
extension
)
{
if
(
extension
.
id
=
=
addon
.
id
)
{
Management
.
off
(
"
ready
"
listener
)
;
resolve
(
)
;
}
}
Management
.
on
(
"
ready
"
listener
)
;
}
)
;
let
[
newAddon
]
=
await
Promise
.
all
(
[
installPromise
readyPromise
]
)
;
return
newAddon
;
}
function
isDefaultIcon
(
icon
)
{
return
(
icon
=
=
"
chrome
:
/
/
browser
/
content
/
extension
.
svg
"
|
|
icon
=
=
"
chrome
:
/
/
mozapps
/
skin
/
extensions
/
extensionGeneric
.
svg
"
)
;
}
function
checkPermissionString
(
string
key
param
msg
)
{
let
localizedString
=
param
?
gBrowserBundle
.
formatStringFromName
(
key
[
param
]
1
)
:
gBrowserBundle
.
GetStringFromName
(
key
)
;
if
(
localizedString
.
includes
(
"
%
S
"
)
)
{
let
i
=
localizedString
.
indexOf
(
"
%
S
"
)
;
ok
(
string
.
startsWith
(
localizedString
.
slice
(
0
i
)
)
msg
)
;
ok
(
string
.
endsWith
(
localizedString
.
slice
(
i
+
2
)
)
msg
)
;
}
else
{
is
(
string
localizedString
msg
)
;
}
}
function
checkNotification
(
panel
checkIcon
permissions
)
{
let
icon
=
panel
.
getAttribute
(
"
icon
"
)
;
let
ul
=
document
.
getElementById
(
"
addon
-
webext
-
perm
-
list
"
)
;
let
header
=
document
.
getElementById
(
"
addon
-
webext
-
perm
-
intro
"
)
;
if
(
checkIcon
instanceof
RegExp
)
{
ok
(
checkIcon
.
test
(
icon
)
Notification
icon
is
correct
{
JSON
.
stringify
(
icon
)
}
~
=
{
checkIcon
}
)
;
}
else
if
(
typeof
checkIcon
=
=
"
function
"
)
{
ok
(
checkIcon
(
icon
)
"
Notification
icon
is
correct
"
)
;
}
else
{
is
(
icon
checkIcon
"
Notification
icon
is
correct
"
)
;
}
is
(
ul
.
childElementCount
permissions
.
length
Permissions
list
has
{
permissions
.
length
}
entries
)
;
if
(
permissions
.
length
=
=
0
)
{
is
(
header
.
getAttribute
(
"
hidden
"
)
"
true
"
"
Permissions
header
is
hidden
"
)
;
}
else
{
is
(
header
.
getAttribute
(
"
hidden
"
)
"
"
"
Permissions
header
is
visible
"
)
;
}
for
(
let
i
in
permissions
)
{
let
[
key
param
]
=
permissions
[
i
]
;
checkPermissionString
(
ul
.
children
[
i
]
.
textContent
key
param
Permission
number
{
i
+
1
}
is
correct
)
;
}
}
async
function
testInstallMethod
(
installFn
telemetryBase
)
{
const
PERMS_XPI
=
"
browser_webext_permissions
.
xpi
"
;
const
NO_PERMS_XPI
=
"
browser_webext_nopermissions
.
xpi
"
;
const
ID
=
"
permissions
test
.
mozilla
.
org
"
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
extensions
.
webapi
.
testing
"
true
]
[
"
extensions
.
install
.
requireBuiltInCerts
"
false
]
]
}
)
;
if
(
telemetryBase
!
=
=
undefined
)
{
hookExtensionsTelemetry
(
)
;
}
let
testURI
=
makeURI
(
"
https
:
/
/
example
.
com
/
"
)
;
Services
.
perms
.
add
(
testURI
"
install
"
Services
.
perms
.
ALLOW_ACTION
)
;
registerCleanupFunction
(
(
)
=
>
Services
.
perms
.
remove
(
testURI
"
install
"
)
)
;
async
function
runOnce
(
filename
cancel
)
{
let
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
)
;
let
installPromise
=
new
Promise
(
resolve
=
>
{
let
listener
=
{
onDownloadCancelled
(
)
{
AddonManager
.
removeInstallListener
(
listener
)
;
resolve
(
false
)
;
}
onDownloadFailed
(
)
{
AddonManager
.
removeInstallListener
(
listener
)
;
resolve
(
false
)
;
}
onInstallCancelled
(
)
{
AddonManager
.
removeInstallListener
(
listener
)
;
resolve
(
false
)
;
}
onInstallEnded
(
)
{
AddonManager
.
removeInstallListener
(
listener
)
;
resolve
(
true
)
;
}
onInstallFailed
(
)
{
AddonManager
.
removeInstallListener
(
listener
)
;
resolve
(
false
)
;
}
}
;
AddonManager
.
addInstallListener
(
listener
)
;
}
)
;
let
installMethodPromise
=
installFn
(
filename
)
;
let
panel
=
await
promisePopupNotificationShown
(
"
addon
-
webext
-
permissions
"
)
;
if
(
filename
=
=
PERMS_XPI
)
{
checkNotification
(
panel
/
^
jar
:
file
:
\
/
\
/
.
*
\
/
icon
\
.
png
/
[
[
"
webextPerms
.
hostDescription
.
wildcard
"
"
wildcard
.
domain
"
]
[
"
webextPerms
.
hostDescription
.
oneSite
"
"
singlehost
.
domain
"
]
[
"
webextPerms
.
description
.
nativeMessaging
"
]
[
"
webextPerms
.
description
.
history
"
]
[
"
webextPerms
.
description
.
tabs
"
]
]
)
;
}
else
if
(
filename
=
=
NO_PERMS_XPI
)
{
checkNotification
(
panel
isDefaultIcon
[
]
)
;
}
if
(
cancel
)
{
panel
.
secondaryButton
.
click
(
)
;
try
{
await
installMethodPromise
;
}
catch
(
err
)
{
}
}
else
{
let
postInstallPromise
=
promiseAppMenuNotificationShown
(
"
addon
-
installed
"
)
;
panel
.
button
.
click
(
)
;
panel
=
await
postInstallPromise
;
panel
.
button
.
click
(
)
;
await
installMethodPromise
;
}
let
result
=
await
installPromise
;
let
addon
=
await
AddonManager
.
getAddonByID
(
ID
)
;
if
(
cancel
)
{
ok
(
!
result
"
Installation
was
cancelled
"
)
;
is
(
addon
null
"
Extension
is
not
installed
"
)
;
}
else
{
ok
(
result
"
Installation
completed
"
)
;
isnot
(
addon
null
"
Extension
is
installed
"
)
;
await
addon
.
uninstall
(
)
;
}
BrowserTestUtils
.
removeTab
(
tab
)
;
}
await
runOnce
(
NO_PERMS_XPI
true
)
;
await
runOnce
(
PERMS_XPI
true
)
;
await
runOnce
(
PERMS_XPI
false
)
;
if
(
telemetryBase
!
=
=
undefined
)
{
expectTelemetry
(
[
{
telemetryBase
}
Rejected
{
telemetryBase
}
Rejected
{
telemetryBase
}
Accepted
]
)
;
}
await
SpecialPowers
.
popPrefEnv
(
)
;
}
async
function
interactiveUpdateTest
(
autoUpdate
checkFn
)
{
AddonTestUtils
.
initMochitest
(
this
)
;
const
ID
=
"
update2
tests
.
mozilla
.
org
"
;
const
FAKE_INSTALL_SOURCE
=
"
fake
-
install
-
source
"
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
extensions
.
install
.
requireBuiltInCerts
"
false
]
[
"
extensions
.
update
.
requireBuiltInCerts
"
false
]
[
"
extensions
.
update
.
autoUpdateDefault
"
autoUpdate
]
[
"
extensions
.
update
.
url
"
{
BASE
}
/
browser_webext_update
.
json
]
]
}
)
;
AddonTestUtils
.
hookAMTelemetryEvents
(
)
;
async
function
triggerUpdate
(
win
addon
)
{
let
manualUpdatePromise
;
if
(
!
autoUpdate
)
{
manualUpdatePromise
=
new
Promise
(
resolve
=
>
{
let
listener
=
{
onNewInstall
(
)
{
AddonManager
.
removeInstallListener
(
listener
)
;
resolve
(
)
;
}
}
;
AddonManager
.
addInstallListener
(
listener
)
;
}
)
;
}
let
promise
=
checkFn
(
win
addon
)
;
if
(
manualUpdatePromise
)
{
await
manualUpdatePromise
;
let
list
=
win
.
document
.
getElementById
(
"
addon
-
list
"
)
;
list
.
clientHeight
;
let
item
=
list
.
itemChildren
.
find
(
_item
=
>
_item
.
value
=
=
ID
)
;
EventUtils
.
synthesizeMouseAtCenter
(
item
.
_updateBtn
{
}
win
)
;
}
return
{
promise
}
;
}
BrowserTestUtils
.
loadURI
(
gBrowser
.
selectedBrowser
"
about
:
robots
"
)
;
await
BrowserTestUtils
.
browserLoaded
(
gBrowser
.
selectedBrowser
)
;
let
addon
=
await
promiseInstallAddon
(
{
BASE
}
/
browser_webext_update1
.
xpi
{
source
:
FAKE_INSTALL_SOURCE
}
)
;
ok
(
addon
"
Addon
was
installed
"
)
;
is
(
addon
.
version
"
1
.
0
"
"
Version
1
of
the
addon
is
installed
"
)
;
let
win
=
await
BrowserOpenAddonsMgr
(
"
addons
:
/
/
list
/
extension
"
)
;
let
popupPromise
=
promisePopupNotificationShown
(
"
addon
-
webext
-
permissions
"
)
;
let
{
promise
:
checkPromise
}
=
await
triggerUpdate
(
win
addon
)
;
let
panel
=
await
popupPromise
;
let
cancelPromise
=
promiseInstallEvent
(
addon
"
onInstallCancelled
"
)
;
panel
.
secondaryButton
.
click
(
)
;
await
cancelPromise
;
addon
=
await
AddonManager
.
getAddonByID
(
ID
)
;
is
(
addon
.
version
"
1
.
0
"
"
Should
still
be
running
the
old
version
"
)
;
await
checkPromise
;
popupPromise
=
promisePopupNotificationShown
(
"
addon
-
webext
-
permissions
"
)
;
checkPromise
=
(
await
triggerUpdate
(
win
addon
)
)
.
promise
;
let
updatePromise
=
waitForUpdate
(
addon
)
;
panel
=
await
popupPromise
;
panel
.
button
.
click
(
)
;
addon
=
await
updatePromise
;
is
(
addon
.
version
"
2
.
0
"
"
Should
have
upgraded
"
)
;
await
checkPromise
;
BrowserTestUtils
.
removeTab
(
gBrowser
.
selectedTab
)
;
await
addon
.
uninstall
(
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
const
collectedUpdateEvents
=
AddonTestUtils
.
getAMTelemetryEvents
(
)
.
filter
(
evt
=
>
{
return
evt
.
method
=
=
=
"
update
"
;
}
)
;
Assert
.
deepEqual
(
collectedUpdateEvents
.
map
(
evt
=
>
evt
.
extra
.
step
)
[
"
started
"
"
download_started
"
"
download_completed
"
"
permissions_prompt
"
"
cancelled
"
"
started
"
"
download_started
"
"
download_completed
"
"
permissions_prompt
"
"
completed
"
]
"
Got
the
expected
sequence
on
update
telemetry
events
"
)
;
ok
(
collectedUpdateEvents
.
every
(
evt
=
>
evt
.
extra
.
addon_id
=
=
=
ID
)
"
Every
update
telemetry
event
should
have
the
expected
addon_id
extra
var
"
)
;
ok
(
collectedUpdateEvents
.
every
(
evt
=
>
evt
.
extra
.
source
=
=
=
FAKE_INSTALL_SOURCE
)
"
Every
update
telemetry
event
should
have
the
expected
source
extra
var
"
)
;
ok
(
collectedUpdateEvents
.
every
(
evt
=
>
evt
.
extra
.
updated_from
=
=
=
"
user
"
)
"
Every
update
telemetry
event
should
have
the
update_from
extra
var
'
user
'
"
)
;
let
hasPermissionsExtras
=
collectedUpdateEvents
.
filter
(
evt
=
>
{
return
evt
.
extra
.
step
=
=
=
"
permissions_prompt
"
;
}
)
.
every
(
evt
=
>
{
return
Number
.
isInteger
(
parseInt
(
evt
.
extra
.
num_strings
10
)
)
;
}
)
;
ok
(
hasPermissionsExtras
"
Every
'
permissions_prompt
'
update
telemetry
event
should
have
the
permissions
extra
vars
"
)
;
let
hasDownloadTimeExtras
=
collectedUpdateEvents
.
filter
(
evt
=
>
{
return
evt
.
extra
.
step
=
=
=
"
download_completed
"
;
}
)
.
every
(
evt
=
>
{
const
download_time
=
parseInt
(
evt
.
extra
.
download_time
10
)
;
return
!
isNaN
(
download_time
)
&
&
download_time
>
0
;
}
)
;
ok
(
hasDownloadTimeExtras
"
Every
'
download_completed
'
update
telemetry
event
should
have
a
download_time
extra
vars
"
)
;
}
let
testCleanup
;
add_task
(
async
function
(
)
{
let
addons
=
await
AddonManager
.
getAllAddons
(
)
;
let
existingAddons
=
new
Set
(
addons
.
map
(
a
=
>
a
.
id
)
)
;
registerCleanupFunction
(
async
function
(
)
{
if
(
testCleanup
)
{
await
testCleanup
(
)
;
testCleanup
=
null
;
}
for
(
let
addon
of
await
AddonManager
.
getAllAddons
(
)
)
{
if
(
!
existingAddons
.
has
(
addon
.
id
)
)
{
ok
(
false
Addon
{
addon
.
id
}
was
left
installed
at
the
end
of
the
test
)
;
await
addon
.
uninstall
(
)
;
}
}
}
)
;
}
)
;
let
collectedTelemetry
=
[
]
;
function
hookExtensionsTelemetry
(
)
{
let
originalHistogram
=
ExtensionsUI
.
histogram
;
ExtensionsUI
.
histogram
=
{
add
(
value
)
{
collectedTelemetry
.
push
(
value
)
;
}
}
;
registerCleanupFunction
(
(
)
=
>
{
is
(
collectedTelemetry
.
length
0
"
No
unexamined
telemetry
after
test
is
finished
"
)
;
ExtensionsUI
.
histogram
=
originalHistogram
;
}
)
;
}
function
expectTelemetry
(
values
)
{
Assert
.
deepEqual
(
values
collectedTelemetry
)
;
collectedTelemetry
=
[
]
;
}
