const
{
AddonManagerPrivate
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
)
;
const
{
AddonTestUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
AddonTestUtils
.
jsm
"
)
;
AddonTestUtils
.
initMochitest
(
this
)
;
const
ID
=
"
update2
tests
.
mozilla
.
org
"
;
const
ID_ICON
=
"
update_icon2
tests
.
mozilla
.
org
"
;
const
ID_PERMS
=
"
update_perms
tests
.
mozilla
.
org
"
;
const
ID_LEGACY
=
"
legacy_update
tests
.
mozilla
.
org
"
;
const
FAKE_INSTALL_TELEMETRY_SOURCE
=
"
fake
-
install
-
source
"
;
requestLongerTimeout
(
2
)
;
function
promiseViewLoaded
(
tab
viewid
)
{
let
win
=
tab
.
linkedBrowser
.
contentWindow
;
if
(
win
.
gViewController
&
&
!
win
.
gViewController
.
isLoading
&
&
win
.
gViewController
.
currentViewId
=
=
viewid
)
{
return
Promise
.
resolve
(
)
;
}
return
new
Promise
(
resolve
=
>
{
function
listener
(
)
{
if
(
win
.
gViewController
.
currentViewId
!
=
viewid
)
{
return
;
}
win
.
document
.
removeEventListener
(
"
ViewChanged
"
listener
)
;
resolve
(
)
;
}
win
.
document
.
addEventListener
(
"
ViewChanged
"
listener
)
;
}
)
;
}
function
getBadgeStatus
(
)
{
let
menuButton
=
document
.
getElementById
(
"
PanelUI
-
menu
-
button
"
)
;
return
menuButton
.
getAttribute
(
"
badge
-
status
"
)
;
}
add_task
(
async
function
setup
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
extensions
.
install
.
requireBuiltInCerts
"
false
]
[
"
extensions
.
update
.
requireBuiltInCerts
"
false
]
]
}
)
;
BrowserTestUtils
.
loadURI
(
gBrowser
.
selectedBrowser
"
about
:
robots
"
)
;
await
BrowserTestUtils
.
browserLoaded
(
gBrowser
.
selectedBrowser
)
;
registerCleanupFunction
(
async
function
(
)
{
BrowserTestUtils
.
loadURI
(
gBrowser
.
selectedBrowser
"
about
:
blank
"
)
;
await
BrowserTestUtils
.
browserLoaded
(
gBrowser
.
selectedBrowser
)
;
}
)
;
}
)
;
hookExtensionsTelemetry
(
)
;
AddonTestUtils
.
hookAMTelemetryEvents
(
)
;
async
function
backgroundUpdateTest
(
url
id
checkIconFn
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
extensions
.
update
.
enabled
"
true
]
[
"
extensions
.
update
.
background
.
url
"
{
BASE
}
/
browser_webext_update
.
json
]
]
}
)
;
let
addon
=
await
promiseInstallAddon
(
url
{
source
:
FAKE_INSTALL_TELEMETRY_SOURCE
}
)
;
let
addonId
=
addon
.
id
;
ok
(
addon
"
Addon
was
installed
"
)
;
is
(
getBadgeStatus
(
)
"
"
"
Should
not
start
out
with
an
addon
alert
badge
"
)
;
let
updatePromise
=
promiseInstallEvent
(
addon
"
onDownloadEnded
"
)
;
AddonManagerPrivate
.
backgroundUpdateCheck
(
)
;
await
updatePromise
;
is
(
getBadgeStatus
(
)
"
addon
-
alert
"
"
Should
have
addon
alert
badge
"
)
;
await
gCUITestUtils
.
openMainMenu
(
)
;
let
addons
=
PanelUI
.
addonNotificationContainer
;
is
(
addons
.
children
.
length
1
"
Have
a
menu
entry
for
the
update
"
)
;
let
tabPromise
=
BrowserTestUtils
.
waitForNewTab
(
gBrowser
"
about
:
addons
"
)
;
let
popupPromise
=
promisePopupNotificationShown
(
"
addon
-
webext
-
permissions
"
)
;
addons
.
children
[
0
]
.
click
(
)
;
ok
(
PanelUI
.
panel
.
state
!
=
"
open
"
"
Main
menu
is
closed
or
closing
.
"
)
;
let
tab
=
await
tabPromise
;
is
(
tab
.
linkedBrowser
.
currentURI
.
spec
"
about
:
addons
"
"
Browser
is
at
about
:
addons
"
)
;
const
VIEW
=
"
addons
:
/
/
list
/
extension
"
;
await
promiseViewLoaded
(
tab
VIEW
)
;
let
win
=
tab
.
linkedBrowser
.
contentWindow
;
ok
(
!
win
.
gViewController
.
isLoading
"
about
:
addons
view
is
fully
loaded
"
)
;
is
(
win
.
gViewController
.
currentViewId
VIEW
"
about
:
addons
is
at
extensions
list
"
)
;
let
panel
=
await
popupPromise
;
checkIconFn
(
panel
.
getAttribute
(
"
icon
"
)
)
;
let
list
=
document
.
getElementById
(
"
addon
-
webext
-
perm
-
list
"
)
;
is
(
list
.
childElementCount
1
"
Permissions
list
contains
1
entry
"
)
;
panel
.
secondaryButton
.
click
(
)
;
addon
=
await
AddonManager
.
getAddonByID
(
id
)
;
is
(
addon
.
version
"
1
.
0
"
"
Should
still
be
running
the
old
version
"
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
is
(
getBadgeStatus
(
)
"
"
"
Addon
alert
badge
should
be
gone
"
)
;
await
gCUITestUtils
.
openMainMenu
(
)
;
addons
=
PanelUI
.
addonNotificationContainer
;
is
(
addons
.
children
.
length
0
"
Update
menu
entries
should
be
gone
"
)
;
await
gCUITestUtils
.
hideMainMenu
(
)
;
updatePromise
=
promiseInstallEvent
(
addon
"
onDownloadEnded
"
)
;
await
AddonManagerPrivate
.
backgroundUpdateCheck
(
)
;
await
updatePromise
;
is
(
getBadgeStatus
(
)
"
addon
-
alert
"
"
Should
have
addon
alert
badge
"
)
;
await
gCUITestUtils
.
openMainMenu
(
)
;
addons
=
PanelUI
.
addonNotificationContainer
;
is
(
addons
.
children
.
length
1
"
Have
a
menu
entry
for
the
update
"
)
;
tabPromise
=
BrowserTestUtils
.
waitForNewTab
(
gBrowser
"
about
:
addons
"
)
;
popupPromise
=
promisePopupNotificationShown
(
"
addon
-
webext
-
permissions
"
)
;
addons
.
children
[
0
]
.
click
(
)
;
tab
=
await
tabPromise
;
is
(
tab
.
linkedBrowser
.
currentURI
.
spec
"
about
:
addons
"
)
;
await
promiseViewLoaded
(
tab
VIEW
)
;
win
=
tab
.
linkedBrowser
.
contentWindow
;
ok
(
!
win
.
gViewController
.
isLoading
"
about
:
addons
view
is
fully
loaded
"
)
;
is
(
win
.
gViewController
.
currentViewId
VIEW
"
about
:
addons
is
at
extensions
list
"
)
;
updatePromise
=
waitForUpdate
(
addon
)
;
panel
=
await
popupPromise
;
panel
.
button
.
click
(
)
;
addon
=
await
updatePromise
;
is
(
addon
.
version
"
2
.
0
"
"
Should
have
upgraded
to
the
new
version
"
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
is
(
getBadgeStatus
(
)
"
"
"
Addon
alert
badge
should
be
gone
"
)
;
expectTelemetry
(
[
"
updateRejected
"
"
updateAccepted
"
]
)
;
await
addon
.
uninstall
(
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
const
amEvents
=
AddonTestUtils
.
getAMTelemetryEvents
(
)
;
const
updateEvents
=
amEvents
.
filter
(
evt
=
>
evt
.
method
=
=
=
"
update
"
)
.
map
(
evt
=
>
{
delete
evt
.
value
;
return
evt
;
}
)
;
Assert
.
deepEqual
(
updateEvents
.
map
(
evt
=
>
evt
.
extra
&
&
evt
.
extra
.
step
)
[
"
started
"
"
download_started
"
"
download_completed
"
"
permissions_prompt
"
"
cancelled
"
"
started
"
"
download_started
"
"
download_completed
"
"
permissions_prompt
"
"
completed
"
]
"
Got
the
steps
from
the
collected
telemetry
events
"
)
;
const
method
=
"
update
"
;
const
object
=
"
extension
"
;
const
baseExtra
=
{
addon_id
:
addonId
source
:
FAKE_INSTALL_TELEMETRY_SOURCE
step
:
"
permissions_prompt
"
updated_from
:
"
app
"
}
;
Assert
.
deepEqual
(
updateEvents
.
filter
(
evt
=
>
evt
.
extra
&
&
evt
.
extra
.
step
=
=
=
"
permissions_prompt
"
)
[
{
method
object
extra
:
{
.
.
.
baseExtra
num_strings
:
"
1
"
}
}
{
method
object
extra
:
{
.
.
.
baseExtra
num_strings
:
"
1
"
}
}
]
"
Got
the
expected
permission_prompts
events
"
)
;
}
function
checkDefaultIcon
(
icon
)
{
is
(
icon
"
chrome
:
/
/
mozapps
/
skin
/
extensions
/
extensionGeneric
.
svg
"
"
Popup
has
the
default
extension
icon
"
)
;
}
add_task
(
(
)
=
>
backgroundUpdateTest
(
{
BASE
}
/
browser_webext_update1
.
xpi
ID
checkDefaultIcon
)
)
;
function
checkNonDefaultIcon
(
icon
)
{
ok
(
icon
.
startsWith
(
"
jar
:
file
:
/
/
"
)
"
Icon
is
a
jar
url
"
)
;
ok
(
icon
.
endsWith
(
"
/
icon
.
png
"
)
"
Icon
is
icon
.
png
inside
a
jar
"
)
;
}
add_task
(
(
)
=
>
backgroundUpdateTest
(
{
BASE
}
/
browser_webext_update_icon1
.
xpi
ID_ICON
checkNonDefaultIcon
)
)
;
