"
use
strict
"
;
const
EXPECTED_REFLOWS
=
[
{
stack
:
[
"
clientPos
chrome
:
/
/
browser
/
content
/
tabbrowser
/
tabs
.
js
"
"
startTabDrag
chrome
:
/
/
browser
/
content
/
tabbrowser
/
tabs
.
js
"
"
on_dragstart
chrome
:
/
/
browser
/
content
/
tabbrowser
/
tabs
.
js
"
"
handleEvent
chrome
:
/
/
browser
/
content
/
tabbrowser
/
tabs
.
js
"
"
synthesizeMouseAtPoint
chrome
:
/
/
mochikit
/
content
/
tests
/
SimpleTest
/
EventUtils
.
js
"
"
synthesizeMouse
chrome
:
/
/
mochikit
/
content
/
tests
/
SimpleTest
/
EventUtils
.
js
"
"
synthesizePlainDragAndDrop
chrome
:
/
/
mochikit
/
content
/
tests
/
SimpleTest
/
EventUtils
.
js
"
]
maxCount
:
2
}
{
stack
:
[
"
get
scrollPosition
chrome
:
/
/
global
/
content
/
elements
/
arrowscrollbox
.
js
"
"
startTabDrag
chrome
:
/
/
browser
/
content
/
tabbrowser
/
tabs
.
js
"
"
on_dragstart
chrome
:
/
/
browser
/
content
/
tabbrowser
/
tabs
.
js
"
"
handleEvent
chrome
:
/
/
browser
/
content
/
tabbrowser
/
tabs
.
js
"
"
synthesizeMouseAtPoint
chrome
:
/
/
mochikit
/
content
/
tests
/
SimpleTest
/
EventUtils
.
js
"
"
synthesizeMouse
chrome
:
/
/
mochikit
/
content
/
tests
/
SimpleTest
/
EventUtils
.
js
"
"
synthesizePlainDragAndDrop
chrome
:
/
/
mochikit
/
content
/
tests
/
SimpleTest
/
EventUtils
.
js
"
]
}
]
;
add_task
(
async
function
test_detach_not_overflowed
(
)
{
await
ensureNoPreloadedBrowser
(
)
;
await
createTabs
(
1
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
{
return
!
gBrowser
.
tabContainer
.
overflowing
;
}
)
;
let
win
;
await
withPerfObserver
(
async
function
(
)
{
win
=
await
detachTab
(
gBrowser
.
tabs
[
1
]
)
;
}
{
expectedReflows
:
EXPECTED_REFLOWS
frames
:
{
filter
:
(
)
=
>
[
]
}
}
)
;
await
BrowserTestUtils
.
closeWindow
(
win
)
;
win
=
null
;
}
)
;
add_task
(
async
function
test_detach_overflowed
(
)
{
const
TAB_COUNT_FOR_OVERFLOW
=
computeMaxTabCount
(
)
;
await
createTabs
(
TAB_COUNT_FOR_OVERFLOW
+
1
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
{
return
gBrowser
.
tabContainer
.
overflowing
;
}
)
;
let
win
;
await
withPerfObserver
(
async
function
(
)
{
win
=
await
detachTab
(
gBrowser
.
tabs
[
Math
.
floor
(
TAB_COUNT_FOR_OVERFLOW
/
2
)
]
)
;
}
{
expectedReflows
:
EXPECTED_REFLOWS
frames
:
{
filter
:
(
)
=
>
[
]
}
}
)
;
await
BrowserTestUtils
.
closeWindow
(
win
)
;
win
=
null
;
await
removeAllButFirstTab
(
)
;
}
)
;
async
function
detachTab
(
tab
)
{
let
newWindowPromise
=
BrowserTestUtils
.
waitForNewWindow
(
)
;
await
EventUtils
.
synthesizePlainDragAndDrop
(
{
srcElement
:
tab
destElement
:
null
stepX
:
0
stepY
:
100
}
)
;
return
newWindowPromise
;
}
