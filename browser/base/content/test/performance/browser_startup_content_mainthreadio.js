"
use
strict
"
;
const
kDumpAllStacks
=
false
;
const
LINUX
=
AppConstants
.
platform
=
=
"
linux
"
;
const
WIN
=
AppConstants
.
platform
=
=
"
win
"
;
const
MAC
=
AppConstants
.
platform
=
=
"
macosx
"
;
const
processes
=
{
"
Web
Content
"
:
[
{
path
:
"
GreD
:
omni
.
ja
"
condition
:
!
WIN
stat
:
1
}
{
path
:
"
XCurProcD
:
omni
.
ja
"
condition
:
!
WIN
stat
:
1
}
{
path
:
"
XCurProcD
:
"
condition
:
WIN
stat
:
1
}
{
path
:
"
XREAppFeat
:
formautofill
mozilla
.
org
.
xpi
"
condition
:
!
WIN
ignoreIfUnused
:
true
stat
:
1
}
{
path
:
"
*
ShaderCache
*
"
condition
:
WIN
ignoreIfUnused
:
true
stat
:
3
}
]
"
Privileged
Content
"
:
[
{
path
:
"
GreD
:
omni
.
ja
"
condition
:
!
WIN
stat
:
1
}
{
path
:
"
XCurProcD
:
omni
.
ja
"
condition
:
!
WIN
stat
:
1
}
{
path
:
"
XCurProcD
:
"
condition
:
WIN
stat
:
1
}
]
WebExtensions
:
[
{
path
:
"
GreD
:
omni
.
ja
"
condition
:
!
WIN
stat
:
1
}
{
path
:
"
XCurProcD
:
omni
.
ja
"
condition
:
!
WIN
stat
:
1
}
{
path
:
"
XCurProcD
:
"
condition
:
WIN
stat
:
1
}
]
}
;
function
expandPathWithDirServiceKey
(
path
)
{
if
(
path
.
includes
(
"
:
"
)
)
{
let
[
prefix
suffix
]
=
path
.
split
(
"
:
"
)
;
let
[
key
property
]
=
prefix
.
split
(
"
.
"
)
;
let
dir
=
Services
.
dirsvc
.
get
(
key
Ci
.
nsIFile
)
;
if
(
property
)
{
dir
=
dir
[
property
]
;
}
let
dirPath
=
dir
.
path
;
while
(
dir
&
&
!
dir
.
isSymlink
(
)
)
{
dir
=
dir
.
parent
;
}
if
(
dir
)
{
dirPath
=
dirPath
.
replace
(
dir
.
path
dir
.
target
)
;
}
path
=
dirPath
;
if
(
suffix
)
{
path
+
=
"
/
"
+
suffix
;
}
}
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
path
=
path
.
replace
(
/
\
/
/
g
"
\
\
"
)
;
}
return
path
;
}
function
getStackFromProfile
(
profile
stack
)
{
const
stackPrefixCol
=
profile
.
stackTable
.
schema
.
prefix
;
const
stackFrameCol
=
profile
.
stackTable
.
schema
.
frame
;
const
frameLocationCol
=
profile
.
frameTable
.
schema
.
location
;
let
result
=
[
]
;
while
(
stack
)
{
let
sp
=
profile
.
stackTable
.
data
[
stack
]
;
let
frame
=
profile
.
frameTable
.
data
[
sp
[
stackFrameCol
]
]
;
stack
=
sp
[
stackPrefixCol
]
;
frame
=
profile
.
stringTable
[
frame
[
frameLocationCol
]
]
;
if
(
frame
!
=
"
js
:
:
RunScript
"
&
&
!
frame
.
startsWith
(
"
next
(
self
-
hosted
:
"
)
)
{
result
.
push
(
frame
)
;
}
}
return
result
;
}
function
getIOMarkersFromProfile
(
profile
)
{
const
nameCol
=
profile
.
markers
.
schema
.
name
;
const
dataCol
=
profile
.
markers
.
schema
.
data
;
let
markers
=
[
]
;
for
(
let
m
of
profile
.
markers
.
data
)
{
let
markerName
=
profile
.
stringTable
[
m
[
nameCol
]
]
;
if
(
markerName
!
=
"
FileIO
"
)
{
continue
;
}
let
markerData
=
m
[
dataCol
]
;
if
(
markerData
.
source
=
=
"
sqlite
-
mainthread
"
)
{
continue
;
}
let
samples
=
markerData
.
stack
.
samples
;
let
stack
=
samples
.
data
[
0
]
[
samples
.
schema
.
stack
]
;
markers
.
push
(
{
operation
:
markerData
.
operation
filename
:
markerData
.
filename
source
:
markerData
.
source
stackId
:
stack
}
)
;
}
return
markers
;
}
function
pathMatches
(
path
filename
)
{
path
=
path
.
toLowerCase
(
)
;
return
(
path
=
=
filename
|
|
(
path
.
startsWith
(
"
*
"
)
&
&
path
.
endsWith
(
"
*
"
)
&
&
filename
.
includes
(
path
.
slice
(
1
-
1
)
)
)
|
|
(
path
.
endsWith
(
"
*
"
)
&
&
filename
.
startsWith
(
path
.
slice
(
0
-
1
)
)
)
|
|
(
path
.
startsWith
(
"
*
"
)
&
&
filename
.
endsWith
(
path
.
slice
(
1
)
)
)
)
;
}
add_task
(
async
function
(
)
{
if
(
!
AppConstants
.
NIGHTLY_BUILD
&
&
!
AppConstants
.
MOZ_DEV_EDITION
&
&
!
AppConstants
.
DEBUG
)
{
ok
(
!
(
"
mozilla
.
org
/
test
/
startuprecorder
;
1
"
in
Cc
)
"
the
startup
recorder
component
shouldn
'
t
exist
in
this
non
-
nightly
/
non
-
devedition
/
"
+
"
non
-
debug
build
.
"
)
;
return
;
}
TestUtils
.
assertPackagedBuild
(
)
;
let
startupRecorder
=
Cc
[
"
mozilla
.
org
/
test
/
startuprecorder
;
1
"
]
.
getService
(
)
.
wrappedJSObject
;
await
startupRecorder
.
done
;
for
(
let
process
in
processes
)
{
processes
[
process
]
=
processes
[
process
]
.
filter
(
entry
=
>
!
(
"
condition
"
in
entry
)
|
|
entry
.
condition
)
;
processes
[
process
]
.
forEach
(
entry
=
>
{
entry
.
listedPath
=
entry
.
path
;
entry
.
path
=
expandPathWithDirServiceKey
(
entry
.
path
)
;
}
)
;
}
let
tmpPath
=
expandPathWithDirServiceKey
(
"
TmpD
:
"
)
.
toLowerCase
(
)
;
let
shouldPass
=
true
;
for
(
let
procName
in
processes
)
{
let
knownIOList
=
processes
[
procName
]
;
info
(
known
main
thread
IO
paths
for
{
procName
}
process
:
\
n
+
knownIOList
.
map
(
e
=
>
{
let
operations
=
Object
.
keys
(
e
)
.
filter
(
k
=
>
!
[
"
path
"
"
condition
"
]
.
includes
(
k
)
)
.
map
(
k
=
>
{
k
}
:
{
e
[
k
]
}
)
;
return
{
e
.
path
}
-
{
operations
.
join
(
"
"
)
}
;
}
)
.
join
(
"
\
n
"
)
)
;
let
profile
;
for
(
let
process
of
startupRecorder
.
data
.
profile
.
processes
)
{
if
(
process
.
threads
[
0
]
.
processName
=
=
procName
)
{
profile
=
process
.
threads
[
0
]
;
break
;
}
}
if
(
procName
=
=
"
Privileged
Content
"
&
&
!
profile
)
{
todo
(
false
profile
for
{
procName
}
process
not
found
)
;
}
else
{
ok
(
profile
Found
profile
for
{
procName
}
process
)
;
}
if
(
!
profile
)
{
continue
;
}
let
markers
=
getIOMarkersFromProfile
(
profile
)
;
for
(
let
marker
of
markers
)
{
if
(
marker
.
operation
=
=
"
create
/
open
"
)
{
continue
;
}
if
(
!
marker
.
filename
)
{
continue
;
}
let
filename
=
marker
.
filename
.
toLowerCase
(
)
;
if
(
!
WIN
&
&
filename
=
=
"
/
dev
/
urandom
"
)
{
continue
;
}
if
(
LINUX
&
&
filename
.
startsWith
(
"
/
dev
/
shm
/
"
)
)
{
continue
;
}
if
(
LINUX
&
&
filename
.
startsWith
(
"
/
memfd
:
"
)
)
{
continue
;
}
if
(
MAC
&
&
filename
.
startsWith
(
tmpPath
+
"
/
org
.
mozilla
.
ipc
.
"
)
)
{
continue
;
}
let
expected
=
false
;
for
(
let
entry
of
knownIOList
)
{
if
(
pathMatches
(
entry
.
path
filename
)
)
{
entry
[
marker
.
operation
]
=
(
entry
[
marker
.
operation
]
|
|
0
)
-
1
;
entry
.
_used
=
true
;
expected
=
true
;
break
;
}
}
if
(
!
expected
)
{
record
(
false
unexpected
{
marker
.
operation
}
on
{
marker
.
filename
}
in
{
procName
}
process
undefined
"
"
+
getStackFromProfile
(
profile
marker
.
stackId
)
.
join
(
"
\
n
"
)
)
;
shouldPass
=
false
;
}
info
(
(
{
marker
.
source
}
)
{
marker
.
operation
}
-
{
marker
.
filename
}
)
;
if
(
kDumpAllStacks
)
{
info
(
getStackFromProfile
(
profile
marker
.
stackId
)
.
map
(
f
=
>
"
"
+
f
)
.
join
(
"
\
n
"
)
)
;
}
}
if
(
!
knownIOList
.
length
)
{
continue
;
}
is
(
!
!
markers
.
length
!
AppConstants
.
RELEASE_OR_BETA
procName
+
"
startup
profiles
should
have
IO
markers
in
builds
that
are
not
RELEASE_OR_BETA
"
)
;
if
(
!
markers
.
length
)
{
continue
;
}
for
(
let
entry
of
knownIOList
)
{
for
(
let
op
in
entry
)
{
if
(
[
"
listedPath
"
"
path
"
"
condition
"
"
ignoreIfUnused
"
"
_used
"
]
.
includes
(
op
)
)
{
continue
;
}
let
message
=
{
op
}
on
{
entry
.
path
}
;
if
(
entry
[
op
]
=
=
0
)
{
message
+
=
"
as
many
times
as
expected
"
;
}
else
if
(
entry
[
op
]
>
0
)
{
message
+
=
allowed
{
entry
[
op
]
}
more
times
;
}
else
{
message
+
=
{
entry
[
op
]
*
-
1
}
more
times
than
expected
;
}
Assert
.
greaterOrEqual
(
entry
[
op
]
0
{
message
}
in
{
procName
}
process
)
;
}
if
(
!
(
"
_used
"
in
entry
)
&
&
!
entry
.
ignoreIfUnused
)
{
ok
(
false
no
main
thread
IO
when
we
expected
some
for
process
{
procName
}
:
{
entry
.
path
}
(
{
entry
.
listedPath
}
)
)
;
shouldPass
=
false
;
}
}
}
if
(
shouldPass
)
{
ok
(
shouldPass
"
No
unexpected
main
thread
I
/
O
during
startup
"
)
;
}
else
{
const
filename
=
"
profile_startup_content_mainthreadio
.
json
"
;
let
path
=
Services
.
env
.
get
(
"
MOZ_UPLOAD_DIR
"
)
;
let
profilePath
=
PathUtils
.
join
(
path
filename
)
;
await
IOUtils
.
writeJSON
(
profilePath
startupRecorder
.
data
.
profile
)
;
ok
(
false
"
Unexpected
main
thread
I
/
O
behavior
during
child
process
startup
;
"
+
open
the
{
filename
}
artifact
in
the
Firefox
Profiler
to
see
what
happened
)
;
}
}
)
;
