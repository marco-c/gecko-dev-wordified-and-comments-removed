"
use
strict
"
;
const
{
AddonManager
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
)
;
const
kDumpAllStacks
=
false
;
const
LINUX
=
AppConstants
.
platform
=
=
"
linux
"
;
const
WIN
=
AppConstants
.
platform
=
=
"
win
"
;
const
MAC
=
AppConstants
.
platform
=
=
"
macosx
"
;
const
startupPhases
=
{
"
before
profile
selection
"
:
[
{
path
:
"
UAppData
:
Crash
Reports
/
InstallTime20
*
"
condition
:
AppConstants
.
MOZ_CRASHREPORTER
stat
:
1
read
:
1
write
:
2
close
:
1
}
{
path
:
"
UAppData
:
Crash
Reports
/
LastCrash
"
condition
:
WIN
&
&
AppConstants
.
MOZ_CRASHREPORTER
stat
:
1
read
:
1
}
{
path
:
"
UAppData
:
Crash
Reports
/
LastCrash
"
condition
:
!
WIN
&
&
AppConstants
.
MOZ_CRASHREPORTER
ignoreIfUnused
:
true
read
:
1
close
:
1
}
{
path
:
"
UAppData
:
profiles
.
ini
"
ignoreIfUnused
:
true
condition
:
MAC
stat
:
1
read
:
1
close
:
1
}
{
path
:
"
UAppData
:
profiles
.
ini
"
condition
:
WIN
ignoreIfUnused
:
true
read
:
1
stat
:
1
}
{
path
:
"
ProfD
:
"
condition
:
WIN
stat
:
1
}
{
path
:
"
ProfLD
:
.
startup
-
incomplete
"
condition
:
!
WIN
close
:
1
}
{
path
:
"
ProfLD
:
compatibility
.
ini
"
condition
:
!
WIN
write
:
18
close
:
1
}
{
path
:
"
GreD
:
omni
.
ja
"
condition
:
!
WIN
stat
:
1
}
{
path
:
"
XCurProcD
:
omni
.
ja
"
condition
:
!
WIN
stat
:
1
}
{
path
:
"
ProfD
:
parent
.
lock
"
condition
:
WIN
stat
:
1
}
{
path
:
"
ProfD
:
minidumps
"
condition
:
WIN
stat
:
1
}
{
path
:
"
XCurProcD
:
defaults
/
preferences
"
condition
:
WIN
stat
:
1
}
{
path
:
"
ProfLDS
:
startupCache
/
scriptCache
-
child
-
current
.
bin
"
condition
:
WIN
stat
:
1
}
{
path
:
"
ProfLDS
:
startupCache
/
scriptCache
-
child
.
bin
"
condition
:
WIN
stat
:
1
}
{
path
:
"
ProfLDS
:
startupCache
/
scriptCache
-
current
.
bin
"
condition
:
WIN
stat
:
1
}
{
path
:
"
ProfLDS
:
startupCache
/
scriptCache
.
bin
"
condition
:
WIN
stat
:
1
}
{
path
:
"
PrfDef
:
channel
-
prefs
.
js
"
stat
:
1
read
:
1
close
:
1
}
{
path
:
"
PrefD
:
prefs
.
js
"
stat
:
1
read
:
1
close
:
1
}
{
path
:
"
PrefD
:
user
.
js
"
stat
:
1
read
:
1
close
:
1
}
{
path
:
"
*
ld
.
so
.
conf
*
"
condition
:
LINUX
ignoreIfUnused
:
true
read
:
22
close
:
11
}
{
path
:
"
ProfD
:
xulstore
/
data
.
mdb
"
condition
:
WIN
write
:
1
fsync
:
1
}
]
"
before
opening
first
browser
window
"
:
[
{
path
:
"
ProfD
:
"
condition
:
WIN
stat
:
1
}
{
path
:
"
XCurProcD
:
blocklist
.
xml
"
condition
:
WIN
stat
:
1
}
{
path
:
"
ProfD
:
cookies
.
sqlite
-
journal
"
condition
:
!
LINUX
stat
:
3
write
:
4
}
{
path
:
"
ProfD
:
cookies
.
sqlite
"
condition
:
!
LINUX
stat
:
2
read
:
2
write
:
1
}
{
path
:
"
ProfD
:
cookies
.
sqlite
-
wal
"
condition
:
WIN
stat
:
2
}
{
path
:
"
ProfD
:
permissions
.
sqlite
"
condition
:
WIN
|
|
MAC
fsync
:
7
read
:
2
stat
:
1
write
:
10
}
{
path
:
"
ProfD
:
permissions
.
sqlite
-
journal
"
condition
:
WIN
|
|
MAC
fsync
:
7
stat
:
26
write
:
38
}
{
path
:
"
ProfD
:
permissions
.
sqlite
-
wal
"
condition
:
WIN
stat
:
20
}
{
path
:
"
*
.
savedState
/
restorecount
.
plist
"
condition
:
MAC
ignoreIfUnused
:
true
write
:
1
}
{
path
:
"
*
ld
.
so
.
conf
*
"
condition
:
LINUX
ignoreIfUnused
:
true
read
:
22
close
:
11
}
{
path
:
"
/
etc
/
mime
.
types
"
condition
:
LINUX
read
:
3
close
:
3
}
{
path
:
"
ProfD
:
extensions
"
condition
:
WIN
stat
:
1
}
{
path
:
"
XCurProcD
:
extensions
"
condition
:
WIN
stat
:
1
}
{
path
:
"
UAppData
:
"
ignoreIfUnused
:
true
condition
:
WIN
stat
:
1
}
{
path
:
"
ProfD
:
xulstore
/
data
.
mdb
"
condition
:
WIN
read
:
1
}
]
"
before
first
paint
"
:
[
{
path
:
"
OldUpdRootD
:
"
condition
:
WIN
stat
:
1
}
{
path
:
"
UpdRootD
:
updates
/
0
/
update
.
status
"
condition
:
WIN
stat
:
1
}
{
path
:
"
UserPlugins
.
parent
:
"
condition
:
WIN
stat
:
1
}
{
path
:
"
XREAppFeat
:
formautofill
mozilla
.
org
.
xpi
"
condition
:
!
WIN
stat
:
1
close
:
1
}
{
path
:
"
XREAppDist
:
distribution
.
ini
"
condition
:
WIN
stat
:
1
}
{
path
:
"
*
WindowsApps
/
microsoft
.
windowscommunicationsapps
*
"
condition
:
WIN
ignoreIfUnused
:
true
stat
:
3
}
{
path
:
"
*
Fonts
/
StaticCache
.
dat
"
condition
:
WIN
ignoreIfUnused
:
true
read
:
1
}
{
path
:
"
UAppData
:
"
ignoreIfUnused
:
true
condition
:
WIN
stat
:
1
}
{
path
:
"
GreD
:
ScalarArtifactDefinitions
.
json
"
condition
:
WIN
&
&
!
AppConstants
.
MOZILLA_OFFICIAL
stat
:
1
}
{
path
:
"
GreD
:
EventArtifactDefinitions
.
json
"
condition
:
WIN
&
&
!
AppConstants
.
MOZILLA_OFFICIAL
stat
:
1
}
{
path
:
"
ProfD
:
xulstore
/
data
.
mdb
"
condition
:
MAC
write
:
3
}
]
"
before
handling
user
events
"
:
[
{
path
:
"
GreD
:
update
.
test
"
ignoreIfUnused
:
true
condition
:
LINUX
close
:
1
}
{
path
:
"
ProfD
:
cert9
.
db
"
condition
:
WIN
read
:
2
stat
:
2
}
{
path
:
"
ProfD
:
cert9
.
db
"
condition
:
WIN
ignoreIfUnused
:
true
canonicalize
:
true
stat
:
2
}
{
path
:
"
ProfD
:
cert9
.
db
-
journal
"
condition
:
WIN
canonicalize
:
true
stat
:
2
}
{
path
:
"
ProfD
:
cert9
.
db
-
wal
"
condition
:
WIN
canonicalize
:
true
stat
:
2
}
{
path
:
"
ProfD
:
pkcs11
.
txt
"
condition
:
WIN
read
:
2
}
{
path
:
"
ProfD
:
key4
.
db
"
condition
:
WIN
read
:
2
stat
:
2
}
{
path
:
"
ProfD
:
key4
.
db
"
condition
:
WIN
ignoreIfUnused
:
true
canonicalize
:
true
stat
:
2
}
{
path
:
"
ProfD
:
key4
.
db
-
journal
"
condition
:
WIN
canonicalize
:
true
stat
:
5
}
{
path
:
"
ProfD
:
key4
.
db
-
wal
"
condition
:
WIN
canonicalize
:
true
stat
:
5
}
{
path
:
"
XREAppFeat
:
webcompat
-
reporter
mozilla
.
org
.
xpi
"
condition
:
!
WIN
ignoreIfUnused
:
true
stat
:
1
close
:
1
}
{
path
:
"
XCurProcD
:
extensions
"
condition
:
WIN
stat
:
1
}
]
"
before
becoming
idle
"
:
[
{
path
:
"
XREAppFeat
:
screenshots
mozilla
.
org
.
xpi
"
ignoreIfUnused
:
true
close
:
1
}
{
path
:
"
XREAppFeat
:
webcompat
-
reporter
mozilla
.
org
.
xpi
"
ignoreIfUnused
:
true
stat
:
1
close
:
1
}
{
path
:
"
ProfD
:
places
.
sqlite
-
journal
"
ignoreIfUnused
:
true
fsync
:
1
stat
:
4
write
:
2
}
{
path
:
"
ProfD
:
places
.
sqlite
-
wal
"
ignoreIfUnused
:
true
stat
:
4
fsync
:
3
write
:
148
}
{
path
:
"
ProfD
:
places
.
sqlite
-
shm
"
condition
:
WIN
ignoreIfUnused
:
true
stat
:
1
}
{
path
:
"
ProfD
:
places
.
sqlite
"
ignoreIfUnused
:
true
fsync
:
2
read
:
1
stat
:
3
write
:
1310
}
{
path
:
"
ProfD
:
favicons
.
sqlite
-
journal
"
ignoreIfUnused
:
true
fsync
:
2
stat
:
7
write
:
7
}
{
path
:
"
ProfD
:
favicons
.
sqlite
-
wal
"
ignoreIfUnused
:
true
fsync
:
2
stat
:
7
write
:
15
}
{
path
:
"
ProfD
:
favicons
.
sqlite
-
shm
"
condition
:
WIN
ignoreIfUnused
:
true
stat
:
2
}
{
path
:
"
ProfD
:
favicons
.
sqlite
"
ignoreIfUnused
:
true
fsync
:
3
read
:
4
stat
:
4
write
:
1300
}
{
path
:
"
ProfD
:
key4
.
db
-
journal
"
condition
:
WIN
canonicalize
:
true
stat
:
2
}
{
path
:
"
ProfD
:
key4
.
db
-
wal
"
condition
:
WIN
canonicalize
:
true
stat
:
2
}
{
path
:
"
ProfD
:
"
condition
:
WIN
ignoreIfUnused
:
true
stat
:
3
}
]
}
;
for
(
let
name
of
[
"
d3d11layers
"
"
d3d9video
"
"
glcontext
"
"
d3d11video
"
"
wmfvpxvideo
"
]
)
{
startupPhases
[
"
before
first
paint
"
]
.
push
(
{
path
:
ProfD
:
{
name
}
.
guard
ignoreIfUnused
:
true
stat
:
1
}
)
;
}
function
expandWhitelistPath
(
path
canonicalize
=
false
)
{
if
(
path
.
includes
(
"
:
"
)
)
{
let
[
prefix
suffix
]
=
path
.
split
(
"
:
"
)
;
let
[
key
property
]
=
prefix
.
split
(
"
.
"
)
;
let
dir
=
Services
.
dirsvc
.
get
(
key
Ci
.
nsIFile
)
;
if
(
property
)
{
dir
=
dir
[
property
]
;
}
if
(
canonicalize
)
{
path
=
dir
.
QueryInterface
(
Ci
.
nsILocalFileWin
)
.
canonicalPath
;
}
else
{
let
dirPath
=
dir
.
path
;
while
(
dir
&
&
!
dir
.
isSymlink
(
)
)
{
dir
=
dir
.
parent
;
}
if
(
dir
)
{
dirPath
=
dirPath
.
replace
(
dir
.
path
dir
.
target
)
;
}
path
=
dirPath
;
}
if
(
suffix
)
{
path
+
=
"
/
"
+
suffix
;
}
}
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
path
=
path
.
replace
(
/
\
/
/
g
"
\
\
"
)
;
}
return
path
;
}
function
getStackFromProfile
(
profile
stack
)
{
const
stackPrefixCol
=
profile
.
stackTable
.
schema
.
prefix
;
const
stackFrameCol
=
profile
.
stackTable
.
schema
.
frame
;
const
frameLocationCol
=
profile
.
frameTable
.
schema
.
location
;
let
result
=
[
]
;
while
(
stack
)
{
let
sp
=
profile
.
stackTable
.
data
[
stack
]
;
let
frame
=
profile
.
frameTable
.
data
[
sp
[
stackFrameCol
]
]
;
stack
=
sp
[
stackPrefixCol
]
;
frame
=
profile
.
stringTable
[
frame
[
frameLocationCol
]
]
;
if
(
frame
!
=
"
js
:
:
RunScript
"
&
&
!
frame
.
startsWith
(
"
next
(
self
-
hosted
:
"
)
)
{
result
.
push
(
frame
)
;
}
}
return
result
;
}
function
pathMatches
(
path
filename
)
{
path
=
path
.
toLowerCase
(
)
;
return
(
path
=
=
filename
|
|
(
path
.
startsWith
(
"
*
"
)
&
&
path
.
endsWith
(
"
*
"
)
&
&
filename
.
includes
(
path
.
slice
(
1
-
1
)
)
)
|
|
(
path
.
endsWith
(
"
*
"
)
&
&
filename
.
startsWith
(
path
.
slice
(
0
-
1
)
)
)
|
|
(
path
.
startsWith
(
"
*
"
)
&
&
filename
.
endsWith
(
path
.
slice
(
1
)
)
)
)
;
}
add_task
(
async
function
(
)
{
if
(
!
AppConstants
.
NIGHTLY_BUILD
&
&
!
AppConstants
.
MOZ_DEV_EDITION
&
&
!
AppConstants
.
DEBUG
)
{
ok
(
!
(
"
mozilla
.
org
/
test
/
startuprecorder
;
1
"
in
Cc
)
"
the
startup
recorder
component
shouldn
'
t
exist
in
this
non
-
nightly
/
non
-
devedition
/
"
+
"
non
-
debug
build
.
"
)
;
return
;
}
{
let
omniJa
=
Services
.
dirsvc
.
get
(
"
XCurProcD
"
Ci
.
nsIFile
)
;
omniJa
.
append
(
"
omni
.
ja
"
)
;
if
(
!
omniJa
.
exists
(
)
)
{
ok
(
false
"
This
test
requires
a
packaged
build
"
+
"
run
'
mach
package
'
and
then
use
-
-
appname
=
dist
"
)
;
return
;
}
}
let
startupRecorder
=
Cc
[
"
mozilla
.
org
/
test
/
startuprecorder
;
1
"
]
.
getService
(
)
.
wrappedJSObject
;
await
startupRecorder
.
done
;
{
let
addons
=
await
AddonManager
.
getAddonsByTypes
(
[
"
extension
"
]
)
;
for
(
let
addon
of
addons
)
{
if
(
addon
.
isSystem
)
{
startupPhases
[
"
before
opening
first
browser
window
"
]
.
push
(
{
path
:
XREAppFeat
:
{
addon
.
id
}
.
xpi
stat
:
3
close
:
2
}
)
;
startupPhases
[
"
before
handling
user
events
"
]
.
push
(
{
path
:
XREAppFeat
:
{
addon
.
id
}
.
xpi
condition
:
WIN
stat
:
2
}
)
;
}
}
}
let
profile
=
startupRecorder
.
data
.
profile
.
threads
[
0
]
;
let
phases
=
{
}
;
{
const
nameCol
=
profile
.
markers
.
schema
.
name
;
const
dataCol
=
profile
.
markers
.
schema
.
data
;
let
markersForCurrentPhase
=
[
]
;
let
foundIOMarkers
=
false
;
for
(
let
m
of
profile
.
markers
.
data
)
{
let
markerName
=
profile
.
stringTable
[
m
[
nameCol
]
]
;
if
(
markerName
.
startsWith
(
"
startupRecorder
:
"
)
)
{
phases
[
markerName
.
split
(
"
startupRecorder
:
"
)
[
1
]
]
=
markersForCurrentPhase
;
markersForCurrentPhase
=
[
]
;
continue
;
}
if
(
markerName
!
=
"
FileIO
"
)
{
continue
;
}
let
markerData
=
m
[
dataCol
]
;
if
(
markerData
.
source
=
=
"
sqlite
-
mainthread
"
)
{
continue
;
}
let
samples
=
markerData
.
stack
.
samples
;
let
stack
=
samples
.
data
[
0
]
[
samples
.
schema
.
stack
]
;
markersForCurrentPhase
.
push
(
{
operation
:
markerData
.
operation
filename
:
markerData
.
filename
source
:
markerData
.
source
stackId
:
stack
}
)
;
foundIOMarkers
=
true
;
}
is
(
foundIOMarkers
!
AppConstants
.
RELEASE_OR_BETA
"
The
IO
interposer
should
be
enabled
in
builds
that
are
not
RELEASE_OR_BETA
"
)
;
if
(
!
foundIOMarkers
)
{
return
;
}
}
for
(
let
phase
in
startupPhases
)
{
startupPhases
[
phase
]
=
startupPhases
[
phase
]
.
filter
(
entry
=
>
!
(
"
condition
"
in
entry
)
|
|
entry
.
condition
)
;
startupPhases
[
phase
]
.
forEach
(
entry
=
>
{
entry
.
listedPath
=
entry
.
path
;
entry
.
path
=
expandWhitelistPath
(
entry
.
path
entry
.
canonicalize
)
;
}
)
;
}
let
tmpPath
=
expandWhitelistPath
(
"
TmpD
:
"
)
.
toLowerCase
(
)
;
let
shouldPass
=
true
;
for
(
let
phase
in
phases
)
{
let
whitelist
=
startupPhases
[
phase
]
;
info
(
whitelisted
paths
{
phase
}
:
\
n
+
whitelist
.
map
(
e
=
>
{
let
operations
=
Object
.
keys
(
e
)
.
filter
(
k
=
>
k
!
=
"
path
"
)
.
map
(
k
=
>
{
k
}
:
{
e
[
k
]
}
)
;
return
{
e
.
path
}
-
{
operations
.
join
(
"
"
)
}
;
}
)
.
join
(
"
\
n
"
)
)
;
let
markers
=
phases
[
phase
]
;
for
(
let
marker
of
markers
)
{
if
(
marker
.
operation
=
=
"
create
/
open
"
)
{
continue
;
}
let
filename
=
marker
.
filename
.
toLowerCase
(
)
;
if
(
!
filename
)
{
continue
;
}
if
(
!
WIN
&
&
filename
=
=
"
/
dev
/
urandom
"
)
{
continue
;
}
if
(
LINUX
&
&
filename
.
startsWith
(
"
/
dev
/
shm
/
"
)
)
{
continue
;
}
if
(
MAC
&
&
filename
.
startsWith
(
tmpPath
+
"
/
org
.
mozilla
.
ipc
.
"
)
)
{
continue
;
}
let
expected
=
false
;
for
(
let
entry
of
whitelist
)
{
if
(
pathMatches
(
entry
.
path
filename
)
)
{
entry
[
marker
.
operation
]
=
(
entry
[
marker
.
operation
]
|
|
0
)
-
1
;
entry
.
_used
=
true
;
expected
=
true
;
break
;
}
}
if
(
!
expected
)
{
record
(
false
unexpected
{
marker
.
operation
}
on
{
marker
.
filename
}
{
phase
}
undefined
"
"
+
getStackFromProfile
(
profile
marker
.
stackId
)
.
join
(
"
\
n
"
)
)
;
shouldPass
=
false
;
}
info
(
(
{
marker
.
source
}
)
{
marker
.
operation
}
-
{
marker
.
filename
}
)
;
if
(
kDumpAllStacks
)
{
info
(
getStackFromProfile
(
profile
marker
.
stackId
)
.
map
(
f
=
>
"
"
+
f
)
.
join
(
"
\
n
"
)
)
;
}
}
for
(
let
entry
of
whitelist
)
{
for
(
let
op
in
entry
)
{
if
(
[
"
listedPath
"
"
path
"
"
condition
"
"
canonicalize
"
"
ignoreIfUnused
"
"
_used
"
]
.
includes
(
op
)
)
{
continue
;
}
let
message
=
{
op
}
on
{
entry
.
path
}
;
if
(
entry
[
op
]
=
=
0
)
{
message
+
=
"
as
many
times
as
expected
"
;
}
else
if
(
entry
[
op
]
>
0
)
{
message
+
=
allowed
{
entry
[
op
]
}
more
times
;
}
else
{
message
+
=
{
entry
[
op
]
*
-
1
}
more
times
than
expected
;
}
ok
(
entry
[
op
]
>
=
0
{
message
}
{
phase
}
)
;
}
if
(
!
(
"
_used
"
in
entry
)
&
&
!
entry
.
ignoreIfUnused
)
{
ok
(
false
unused
whitelist
entry
{
phase
}
:
{
entry
.
path
}
(
{
entry
.
listedPath
}
)
)
;
shouldPass
=
false
;
}
}
}
if
(
shouldPass
)
{
ok
(
shouldPass
"
No
unexpected
main
thread
I
/
O
during
startup
"
)
;
}
else
{
const
filename
=
"
profile_startup_mainthreadio
.
json
"
;
let
path
=
Cc
[
"
mozilla
.
org
/
process
/
environment
;
1
"
]
.
getService
(
Ci
.
nsIEnvironment
)
.
get
(
"
MOZ_UPLOAD_DIR
"
)
;
let
encoder
=
new
TextEncoder
(
)
;
let
profilePath
=
OS
.
Path
.
join
(
path
filename
)
;
await
OS
.
File
.
writeAtomic
(
profilePath
encoder
.
encode
(
JSON
.
stringify
(
startupRecorder
.
data
.
profile
)
)
)
;
ok
(
false
"
Unexpected
main
thread
I
/
O
behavior
during
startup
;
open
the
"
+
{
filename
}
artifact
in
the
Firefox
Profiler
to
see
what
happened
)
;
}
}
)
;
