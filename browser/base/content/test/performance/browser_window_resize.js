"
use
strict
"
;
const
EXPECTED_REFLOWS
=
[
]
;
const
gToolbar
=
document
.
getElementById
(
"
PersonalToolbar
"
)
;
async
function
toggleBookmarksToolbar
(
visible
)
{
let
transitionPromise
=
BrowserTestUtils
.
waitForEvent
(
gToolbar
"
transitionend
"
e
=
>
e
.
propertyName
=
=
"
max
-
height
"
)
;
setToolbarVisibility
(
gToolbar
visible
)
;
await
transitionPromise
;
}
async
function
resizeWindow
(
win
width
height
)
{
let
toolbarEvent
=
BrowserTestUtils
.
waitForEvent
(
win
"
BookmarksToolbarVisibilityUpdated
"
)
;
let
resizeEvent
=
BrowserTestUtils
.
waitForEvent
(
win
"
resize
"
)
;
let
dwu
=
win
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
dwu
.
ensureDirtyRootFrame
(
)
;
win
.
resizeTo
(
width
height
)
;
await
resizeEvent
;
forceImmediateToolbarOverflowHandling
(
win
)
;
await
toolbarEvent
;
}
add_task
(
async
function
(
)
{
const
BOOKMARKS_COUNT
=
150
;
const
STARTING_WIDTH
=
600
;
const
STARTING_HEIGHT
=
400
;
const
SMALL_WIDTH
=
150
;
const
SMALL_HEIGHT
=
150
;
await
PlacesUtils
.
bookmarks
.
eraseEverything
(
)
;
await
PlacesUtils
.
bookmarks
.
insertTree
(
{
guid
:
PlacesUtils
.
bookmarks
.
toolbarGuid
children
:
Array
(
BOOKMARKS_COUNT
)
.
fill
(
"
"
)
.
map
(
(
_
i
)
=
>
(
{
url
:
http
:
/
/
test
.
places
.
{
i
}
/
}
)
)
}
)
;
let
wasCollapsed
=
gToolbar
.
collapsed
;
Assert
.
ok
(
wasCollapsed
"
The
toolbar
is
collapsed
by
default
"
)
;
if
(
wasCollapsed
)
{
let
promiseReady
=
BrowserTestUtils
.
waitForEvent
(
gToolbar
"
BookmarksToolbarVisibilityUpdated
"
)
;
await
toggleBookmarksToolbar
(
true
)
;
await
promiseReady
;
}
registerCleanupFunction
(
async
(
)
=
>
{
if
(
wasCollapsed
)
{
await
toggleBookmarksToolbar
(
false
)
;
}
await
PlacesUtils
.
bookmarks
.
eraseEverything
(
)
;
await
PlacesUtils
.
history
.
clear
(
)
;
}
)
;
let
win
=
await
prepareSettledWindow
(
)
;
if
(
win
.
screen
.
availWidth
<
STARTING_WIDTH
|
|
win
.
screen
.
availHeight
<
STARTING_HEIGHT
)
{
Assert
.
ok
(
false
"
This
test
is
running
on
too
small
a
display
-
"
+
(
{
STARTING_WIDTH
}
x
{
STARTING_HEIGHT
}
min
)
)
;
return
;
}
await
resizeWindow
(
win
STARTING_WIDTH
STARTING_HEIGHT
)
;
await
withPerfObserver
(
async
function
(
)
{
await
resizeWindow
(
win
SMALL_WIDTH
SMALL_HEIGHT
)
;
await
resizeWindow
(
win
STARTING_WIDTH
STARTING_HEIGHT
)
;
}
{
expectedReflows
:
EXPECTED_REFLOWS
frames
:
{
filter
:
(
)
=
>
[
]
}
}
win
)
;
await
BrowserTestUtils
.
closeWindow
(
win
)
;
}
)
;
