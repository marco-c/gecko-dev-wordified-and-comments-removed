"
use
strict
"
;
const
EXPECTED_REFLOWS
=
[
]
;
add_task
(
async
function
(
)
{
Services
.
obs
.
notifyObservers
(
null
"
startupcache
-
invalidate
"
)
;
Services
.
obs
.
notifyObservers
(
null
"
chrome
-
flush
-
caches
"
)
;
let
bookmarksToolbarRect
=
await
getBookmarksToolbarRect
(
)
;
let
win
=
window
.
openDialog
(
AppConstants
.
BROWSER_CHROME_URL
"
_blank
"
"
chrome
all
dialog
=
no
remote
suppressanimation
"
"
about
:
home
"
)
;
await
disableFxaBadge
(
)
;
let
alreadyFocused
=
false
;
let
inRange
=
(
val
min
max
)
=
>
min
<
=
val
&
&
val
<
=
max
;
let
tabBoundingRect
=
undefined
;
let
expectations
=
{
expectedReflows
:
EXPECTED_REFLOWS
frames
:
{
filter
(
rects
frame
)
{
if
(
!
alreadyFocused
&
&
isLikelyFocusChange
(
rects
frame
)
)
{
todo
(
false
"
bug
1445161
-
the
window
should
be
focused
at
first
paint
"
+
rects
.
toSource
(
)
)
;
return
[
]
;
}
alreadyFocused
=
true
;
return
rects
;
}
exceptions
:
[
{
name
:
"
bug
1421463
-
reload
toolbar
icon
shouldn
'
t
flicker
"
condition
:
r
=
>
inRange
(
r
.
h
13
14
)
&
&
inRange
(
r
.
w
14
16
)
&
&
inRange
(
r
.
y1
40
80
)
&
&
inRange
(
r
.
x1
65
100
)
}
{
name
:
"
bug
1555842
-
the
urlbar
shouldn
'
t
flicker
"
condition
:
r
=
>
{
let
inputFieldRect
=
win
.
gURLBar
.
inputField
.
getBoundingClientRect
(
)
;
return
(
(
!
AppConstants
.
DEBUG
|
|
(
AppConstants
.
platform
=
=
"
linux
"
&
&
AppConstants
.
ASAN
)
)
&
&
r
.
x1
>
=
inputFieldRect
.
left
&
&
r
.
x2
<
=
inputFieldRect
.
right
&
&
r
.
y1
>
=
inputFieldRect
.
top
&
&
r
.
y2
<
=
inputFieldRect
.
bottom
)
;
}
}
{
name
:
"
Initial
bookmark
icon
appearing
after
startup
"
condition
:
r
=
>
r
.
w
=
=
16
&
&
r
.
h
=
=
16
&
&
inRange
(
r
.
y1
bookmarksToolbarRect
.
top
bookmarksToolbarRect
.
top
+
bookmarksToolbarRect
.
height
/
2
)
&
&
inRange
(
r
.
x1
11
13
)
}
{
name
:
"
Initial
bookmark
text
(
'
Getting
Started
'
or
'
Get
Involved
'
)
appearing
after
startup
"
condition
:
r
=
>
inRange
(
r
.
w
25
120
)
&
&
inRange
(
r
.
h
9
15
)
&
&
inRange
(
r
.
y1
bookmarksToolbarRect
.
top
bookmarksToolbarRect
.
top
+
bookmarksToolbarRect
.
height
/
2
)
&
&
inRange
(
r
.
x1
30
90
)
}
{
name
:
"
Shadow
around
active
tab
should
not
flicker
on
macOS
(
bug
1960967
)
"
condition
(
r
)
{
const
tabRect
=
tabBoundingRect
?
tabBoundingRect
:
(
tabBoundingRect
=
gBrowser
.
tabContainer
.
querySelector
(
"
tab
[
selected
=
true
]
.
tab
-
background
"
)
.
getBoundingClientRect
(
)
)
;
return
(
inRange
(
r
.
x1
tabRect
.
x
-
2
tabRect
.
x
+
2
)
&
&
inRange
(
r
.
y1
tabRect
.
y
-
2
tabRect
.
y
+
2
)
&
&
inRange
(
r
.
w
tabRect
.
width
-
4
tabRect
.
width
+
4
)
&
&
inRange
(
r
.
h
tabRect
.
height
-
4
tabRect
.
height
+
4
)
)
;
}
}
]
}
}
;
await
withPerfObserver
(
async
function
(
)
{
await
new
Promise
(
resolve
=
>
{
win
.
addEventListener
(
"
DOMContentLoaded
"
(
)
=
>
{
delete
win
.
Marionette
;
win
.
Marionette
=
{
running
:
false
}
;
resolve
(
)
;
}
{
once
:
true
}
)
;
}
)
;
await
TestUtils
.
topicObserved
(
"
browser
-
delayed
-
startup
-
finished
"
subject
=
>
subject
=
=
win
)
;
let
promises
=
[
BrowserTestUtils
.
firstBrowserLoaded
(
win
false
)
BrowserTestUtils
.
browserStopped
(
win
.
gBrowser
.
selectedBrowser
"
about
:
home
"
)
]
;
await
Promise
.
all
(
promises
)
;
await
new
Promise
(
resolve
=
>
{
(
function
waitForIdle
(
count
=
10
)
{
if
(
!
count
)
{
resolve
(
)
;
return
;
}
Services
.
tm
.
idleDispatchToMainThread
(
(
)
=
>
{
waitForIdle
(
count
-
1
)
;
}
)
;
}
)
(
)
;
}
)
;
}
expectations
win
)
;
await
BrowserTestUtils
.
closeWindow
(
win
)
;
}
)
;
