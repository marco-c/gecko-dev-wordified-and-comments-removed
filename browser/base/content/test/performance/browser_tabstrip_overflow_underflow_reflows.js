"
use
strict
"
;
const
EXPECTED_OVERFLOW_REFLOWS
=
[
{
stack
:
[
"
select
chrome
:
/
/
global
/
content
/
bindings
/
textbox
.
xml
"
"
focusAndSelectUrlBar
chrome
:
/
/
browser
/
content
/
browser
.
js
"
"
_adjustFocusAfterTabSwitch
chrome
:
/
/
browser
/
content
/
tabbrowser
.
js
"
]
}
]
;
const
EXPECTED_UNDERFLOW_REFLOWS
=
[
]
;
add_task
(
async
function
(
)
{
await
ensureNoPreloadedBrowser
(
)
;
const
TAB_COUNT_FOR_OVERFLOW
=
computeMaxTabCount
(
)
;
await
createTabs
(
TAB_COUNT_FOR_OVERFLOW
)
;
await
withPerfObserver
(
async
function
(
)
{
let
switchDone
=
BrowserTestUtils
.
waitForEvent
(
window
"
TabSwitchDone
"
)
;
BrowserOpenTab
(
)
;
await
BrowserTestUtils
.
waitForEvent
(
gBrowser
.
selectedTab
"
transitionend
"
false
e
=
>
e
.
propertyName
=
=
=
"
max
-
width
"
)
;
await
switchDone
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
{
return
gBrowser
.
tabContainer
.
arrowScrollbox
.
hasAttribute
(
"
scrolledtoend
"
)
;
}
)
;
}
{
expectedReflows
:
EXPECTED_OVERFLOW_REFLOWS
}
)
;
Assert
.
ok
(
gBrowser
.
tabContainer
.
hasAttribute
(
"
overflow
"
)
"
Tabs
should
now
be
overflowed
.
"
)
;
await
withPerfObserver
(
async
function
(
)
{
let
switchDone
=
BrowserTestUtils
.
waitForEvent
(
window
"
TabSwitchDone
"
)
;
BrowserOpenTab
(
)
;
await
switchDone
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
{
return
gBrowser
.
tabContainer
.
arrowScrollbox
.
hasAttribute
(
"
scrolledtoend
"
)
;
}
)
;
}
{
expectedReflows
:
[
]
}
)
;
await
withPerfObserver
(
async
function
(
)
{
let
switchDone
=
BrowserTestUtils
.
waitForEvent
(
window
"
TabSwitchDone
"
)
;
BrowserTestUtils
.
removeTab
(
gBrowser
.
selectedTab
{
animate
:
true
}
)
;
await
switchDone
;
}
{
expectedReflows
:
[
]
}
)
;
let
lastTab
=
gBrowser
.
selectedTab
;
let
arrowScrollbox
=
gBrowser
.
tabContainer
.
arrowScrollbox
;
Assert
.
ok
(
arrowScrollbox
.
scrollPosition
>
0
"
First
tab
should
be
partially
scrolled
out
of
view
.
"
)
;
await
withPerfObserver
(
async
function
(
)
{
let
firstTab
=
gBrowser
.
tabContainer
.
firstChild
;
await
BrowserTestUtils
.
switchTab
(
gBrowser
firstTab
)
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
{
return
gBrowser
.
tabContainer
.
arrowScrollbox
.
hasAttribute
(
"
scrolledtostart
"
)
;
}
)
;
}
{
expectedReflows
:
[
]
}
)
;
BrowserTestUtils
.
removeTab
(
lastTab
)
;
Assert
.
ok
(
gBrowser
.
tabContainer
.
hasAttribute
(
"
overflow
"
)
"
Tabs
should
still
be
overflowed
.
"
)
;
while
(
gBrowser
.
tabContainer
.
hasAttribute
(
"
overflow
"
)
)
{
lastTab
=
gBrowser
.
tabContainer
.
lastElementChild
;
if
(
gBrowser
.
selectedTab
!
=
=
lastTab
)
{
await
BrowserTestUtils
.
switchTab
(
gBrowser
lastTab
)
;
}
await
withPerfObserver
(
async
function
(
)
{
let
switchDone
=
BrowserTestUtils
.
waitForEvent
(
window
"
TabSwitchDone
"
)
;
BrowserTestUtils
.
removeTab
(
lastTab
{
animate
:
true
}
)
;
await
switchDone
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
!
lastTab
.
isConnected
)
;
}
{
expectedReflows
:
EXPECTED_UNDERFLOW_REFLOWS
}
)
;
}
await
removeAllButFirstTab
(
)
;
}
)
;
