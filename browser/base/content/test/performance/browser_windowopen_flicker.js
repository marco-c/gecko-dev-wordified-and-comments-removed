"
use
strict
"
;
add_task
(
async
function
(
)
{
Services
.
obs
.
notifyObservers
(
null
"
startupcache
-
invalidate
"
)
;
Services
.
obs
.
notifyObservers
(
null
"
chrome
-
flush
-
skin
-
caches
"
)
;
Services
.
obs
.
notifyObservers
(
null
"
chrome
-
flush
-
caches
"
)
;
let
win
=
window
.
openDialog
(
"
chrome
:
/
/
browser
/
content
/
"
"
_blank
"
"
chrome
all
dialog
=
no
remote
suppressanimation
"
"
about
:
home
"
)
;
await
new
Promise
(
resolve
=
>
{
win
.
addEventListener
(
"
DOMContentLoaded
"
(
)
=
>
{
delete
win
.
Marionette
;
win
.
Marionette
=
{
running
:
false
}
;
resolve
(
)
;
}
{
once
:
true
}
)
;
}
)
;
let
canvas
=
win
.
document
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
"
canvas
"
)
;
canvas
.
mozOpaque
=
true
;
let
ctx
=
canvas
.
getContext
(
"
2d
"
{
alpha
:
false
willReadFrequently
:
true
}
)
;
let
frames
=
[
]
;
let
afterPaintListener
=
event
=
>
{
let
width
height
;
canvas
.
width
=
width
=
win
.
innerWidth
;
canvas
.
height
=
height
=
win
.
innerHeight
;
ctx
.
drawWindow
(
win
0
0
width
height
"
white
"
ctx
.
DRAWWINDOW_DO_NOT_FLUSH
|
ctx
.
DRAWWINDOW_DRAW_VIEW
|
ctx
.
DRAWWINDOW_ASYNC_DECODE_IMAGES
|
ctx
.
DRAWWINDOW_USE_WIDGET_LAYERS
)
;
frames
.
push
(
{
data
:
Cu
.
cloneInto
(
ctx
.
getImageData
(
0
0
width
height
)
.
data
{
}
)
width
height
}
)
;
}
;
win
.
addEventListener
(
"
MozAfterPaint
"
afterPaintListener
)
;
await
TestUtils
.
topicObserved
(
"
browser
-
delayed
-
startup
-
finished
"
subject
=
>
subject
=
=
win
)
;
await
BrowserTestUtils
.
firstBrowserLoaded
(
win
false
)
;
await
BrowserTestUtils
.
browserStopped
(
win
.
gBrowser
.
selectedBrowser
"
about
:
home
"
)
;
await
new
Promise
(
resolve
=
>
{
(
function
waitForIdle
(
count
=
10
)
{
if
(
!
count
)
{
resolve
(
)
;
return
;
}
Services
.
tm
.
idleDispatchToMainThread
(
(
)
=
>
{
waitForIdle
(
count
-
1
)
;
}
)
;
}
)
(
)
;
}
)
;
win
.
removeEventListener
(
"
MozAfterPaint
"
afterPaintListener
)
;
let
unexpectedRects
=
0
;
let
ignoreTinyPaint
=
true
;
for
(
let
i
=
1
;
i
<
frames
.
length
;
+
+
i
)
{
let
frame
=
frames
[
i
]
previousFrame
=
frames
[
i
-
1
]
;
if
(
ignoreTinyPaint
&
&
previousFrame
.
width
=
=
1
&
&
previousFrame
.
height
=
=
1
)
{
todo
(
false
"
shouldn
'
t
initially
paint
a
1x1px
window
"
)
;
continue
;
}
ignoreTinyPaint
=
false
;
let
rects
=
compareFrames
(
frame
previousFrame
)
.
filter
(
rect
=
>
{
let
inRange
=
(
val
min
max
)
=
>
min
<
=
val
&
&
val
<
=
max
;
let
width
=
frame
.
width
;
const
spaceBeforeFirstTab
=
AppConstants
.
platform
=
=
"
macosx
"
?
100
:
0
;
let
inFirstTab
=
r
=
>
inRange
(
r
.
x1
spaceBeforeFirstTab
spaceBeforeFirstTab
+
50
)
&
&
r
.
y1
<
30
;
let
exceptions
=
[
{
name
:
"
bug
1403648
-
urlbar
down
arrow
shouldn
'
t
flicker
"
condition
:
r
=
>
inRange
(
r
.
h
3
5
)
&
&
inRange
(
r
.
w
7
9
)
&
&
inRange
(
r
.
y1
40
80
)
&
&
inRange
(
r
.
x1
width
*
.
75
width
*
.
9
)
}
{
name
:
"
bug
1421463
-
reload
toolbar
icon
shouldn
'
t
flicker
"
condition
:
r
=
>
r
.
h
=
=
13
&
&
inRange
(
r
.
w
14
16
)
&
&
inRange
(
r
.
y1
40
80
)
&
&
AppConstants
.
MOZ_DEV_EDITION
?
inRange
(
r
.
x1
100
120
)
:
inRange
(
r
.
x1
65
100
)
}
{
name
:
"
bug
1401955
-
about
:
home
favicon
should
be
visible
at
first
paint
"
condition
:
r
=
>
inFirstTab
(
r
)
&
&
inRange
(
r
.
h
14
15
)
&
&
inRange
(
r
.
w
14
15
)
}
]
;
let
rectText
=
{
rect
.
toSource
(
)
}
window
width
:
{
width
}
;
for
(
let
e
of
exceptions
)
{
if
(
e
.
condition
(
rect
)
)
{
todo
(
false
e
.
name
+
"
"
+
rectText
)
;
return
false
;
}
}
ok
(
false
"
unexpected
changed
rect
:
"
+
rectText
)
;
return
true
;
}
)
;
if
(
!
rects
.
length
)
{
info
(
"
ignoring
identical
frame
"
)
;
continue
;
}
if
(
!
unexpectedRects
)
{
dumpFrame
(
previousFrame
)
;
}
unexpectedRects
+
=
rects
.
length
;
dumpFrame
(
frame
)
;
}
is
(
unexpectedRects
0
"
should
have
0
unknown
flickering
areas
"
)
;
await
BrowserTestUtils
.
closeWindow
(
win
)
;
}
)
;
