"
use
strict
"
;
const
LINUX
=
AppConstants
.
platform
=
=
"
linux
"
;
const
WIN
=
AppConstants
.
platform
=
=
"
win
"
;
const
MAC
=
AppConstants
.
platform
=
=
"
macosx
"
;
const
WEBRENDER
=
window
.
windowUtils
.
layerManagerType
.
startsWith
(
"
WebRender
"
)
;
const
SKELETONUI
=
Services
.
prefs
.
getBoolPref
(
"
browser
.
startup
.
preXulSkeletonUI
"
false
)
;
const
GPUPROCESS
=
(
(
WIN
|
|
LINUX
)
&
&
Services
.
prefs
.
getBoolPref
(
"
layers
.
gpu
-
process
.
enabled
"
)
)
|
|
Services
.
prefs
.
getBoolPref
(
"
layers
.
gpu
-
process
.
force
-
enabled
"
)
;
const
startupPhases
=
{
"
before
profile
selection
"
:
[
]
"
before
opening
first
browser
window
"
:
[
]
"
before
first
paint
"
:
[
{
name
:
"
PLayerTransaction
:
:
Msg_GetTextureFactoryIdentifier
"
condition
:
(
MAC
|
|
LINUX
)
&
&
!
WEBRENDER
maxCount
:
1
}
{
name
:
"
PLayerTransaction
:
:
Msg_GetTextureFactoryIdentifier
"
condition
:
WIN
&
&
!
WEBRENDER
maxCount
:
3
}
{
name
:
"
PWebRenderBridge
:
:
Msg_EnsureConnected
"
condition
:
WIN
&
&
WEBRENDER
maxCount
:
3
}
{
name
:
"
PWebRenderBridge
:
:
Msg_EnsureConnected
"
condition
:
(
MAC
|
|
LINUX
)
&
&
WEBRENDER
maxCount
:
1
}
{
name
:
"
PCompositorBridge
:
:
Msg_NotifyChildCreated
"
condition
:
!
GPUPROCESS
ignoreIfUnused
:
true
maxCount
:
1
}
{
name
:
"
PCompositorBridge
:
:
Msg_NotifyChildCreated
"
condition
:
GPUPROCESS
ignoreIfUnused
:
true
maxCount
:
2
}
{
name
:
"
PCompositorBridge
:
:
Msg_MapAndNotifyChildCreated
"
condition
:
GPUPROCESS
ignoreIfUnused
:
true
maxCount
:
2
}
{
name
:
"
PCompositorBridge
:
:
Msg_FlushRendering
"
condition
:
MAC
maxCount
:
1
}
{
name
:
"
PCompositorBridge
:
:
Msg_FlushRendering
"
condition
:
WIN
ignoreIfUnused
:
true
maxCount
:
1
}
{
name
:
"
PCompositorBridge
:
:
Msg_Initialize
"
condition
:
GPUPROCESS
ignoreIfUnused
:
true
maxCount
:
3
}
{
name
:
"
PCompositorWidget
:
:
Msg_Initialize
"
condition
:
WIN
ignoreIfUnused
:
true
maxCount
:
3
}
{
name
:
"
PGPU
:
:
Msg_AddLayerTreeIdMapping
"
condition
:
GPUPROCESS
ignoreIfUnused
:
true
maxCount
:
5
}
{
name
:
"
PCompositorBridge
:
:
Msg_MakeSnapshot
"
condition
:
WIN
&
&
!
WEBRENDER
ignoreIfUnused
:
true
maxCount
:
1
}
{
name
:
"
PWebRenderBridge
:
:
Msg_GetSnapshot
"
condition
:
WIN
&
&
WEBRENDER
ignoreIfUnused
:
true
maxCount
:
1
}
{
name
:
"
PCompositorBridge
:
:
Msg_WillClose
"
condition
:
WIN
ignoreIfUnused
:
true
maxCount
:
2
}
{
name
:
"
PAPZInputBridge
:
:
Msg_ProcessUnhandledEvent
"
condition
:
WIN
ignoreIfUnused
:
true
maxCount
:
2
}
{
name
:
"
PGPU
:
:
Msg_GetDeviceStatus
"
condition
:
WIN
&
&
(
WEBRENDER
|
|
SKELETONUI
)
ignoreIfUnused
:
true
maxCount
:
1
}
{
name
:
"
PCompositorBridge
:
:
Msg_Resume
"
condition
:
LINUX
ignoreIfUnused
:
true
maxCount
:
1
}
]
"
before
handling
user
events
"
:
[
{
name
:
"
PCompositorBridge
:
:
Msg_FlushRendering
"
condition
:
MAC
ignoreIfUnused
:
true
maxCount
:
1
}
{
name
:
"
PCompositorBridge
:
:
Msg_FlushRendering
"
condition
:
LINUX
ignoreIfUnused
:
true
maxCount
:
2
}
{
name
:
"
PLayerTransaction
:
:
Msg_GetTextureFactoryIdentifier
"
condition
:
(
!
MAC
&
&
!
WEBRENDER
)
|
|
(
WIN
&
&
WEBRENDER
)
ignoreIfUnused
:
true
maxCount
:
1
}
{
name
:
"
PCompositorBridge
:
:
Msg_Initialize
"
condition
:
WIN
ignoreIfUnused
:
true
maxCount
:
1
}
{
name
:
"
PCompositorWidget
:
:
Msg_Initialize
"
condition
:
WIN
ignoreIfUnused
:
true
maxCount
:
1
}
{
name
:
"
PCompositorBridge
:
:
Msg_WillClose
"
condition
:
WIN
ignoreIfUnused
:
true
maxCount
:
2
}
{
name
:
"
PCompositorBridge
:
:
Msg_MakeSnapshot
"
condition
:
WIN
ignoreIfUnused
:
true
maxCount
:
1
}
{
name
:
"
PWebRenderBridge
:
:
Msg_GetSnapshot
"
condition
:
WIN
&
&
WEBRENDER
ignoreIfUnused
:
true
maxCount
:
1
}
{
name
:
"
PAPZInputBridge
:
:
Msg_ProcessUnhandledEvent
"
condition
:
WIN
ignoreIfUnused
:
true
maxCount
:
1
}
{
name
:
"
PAPZInputBridge
:
:
Msg_ReceiveMouseInputEvent
"
condition
:
WIN
ignoreIfUnused
:
true
maxCount
:
1
}
{
name
:
"
PWebRenderBridge
:
:
Msg_EnsureConnected
"
condition
:
WIN
&
&
WEBRENDER
ignoreIfUnused
:
true
maxCount
:
1
}
{
name
:
"
PContent
:
:
Reply_BeginDriverCrashGuard
"
condition
:
WIN
ignoreIfUnused
:
true
maxCount
:
1
}
{
name
:
"
PContent
:
:
Reply_EndDriverCrashGuard
"
condition
:
WIN
ignoreIfUnused
:
true
maxCount
:
1
}
{
name
:
"
PCompositorBridge
:
:
Msg_Resume
"
condition
:
LINUX
ignoreIfUnused
:
true
maxCount
:
1
}
]
"
before
becoming
idle
"
:
[
{
name
:
"
PCompositorBridge
:
:
Msg_NotifyChildCreated
"
ignoreIfUnused
:
true
maxCount
:
1
}
{
name
:
"
PAPZInputBridge
:
:
Msg_ProcessUnhandledEvent
"
condition
:
WIN
ignoreIfUnused
:
true
maxCount
:
1
}
{
name
:
"
PAPZInputBridge
:
:
Msg_ReceiveMouseInputEvent
"
condition
:
WIN
ignoreIfUnused
:
true
maxCount
:
1
}
{
name
:
"
PLayerTransaction
:
:
Msg_GetTextureFactoryIdentifier
"
condition
:
WIN
|
|
LINUX
ignoreIfUnused
:
true
maxCount
:
1
}
{
name
:
"
PWebRenderBridge
:
:
Msg_EnsureConnected
"
condition
:
(
WIN
|
|
LINUX
)
&
&
WEBRENDER
ignoreIfUnused
:
true
maxCount
:
1
}
{
name
:
"
PCompositorBridge
:
:
Msg_Initialize
"
condition
:
WIN
ignoreIfUnused
:
true
maxCount
:
1
}
{
name
:
"
PCompositorWidget
:
:
Msg_Initialize
"
condition
:
WIN
ignoreIfUnused
:
true
maxCount
:
1
}
{
name
:
"
PCompositorBridge
:
:
Msg_MapAndNotifyChildCreated
"
condition
:
WIN
ignoreIfUnused
:
true
maxCount
:
1
}
{
name
:
"
PCompositorBridge
:
:
Msg_FlushRendering
"
condition
:
MAC
|
|
SKELETONUI
ignoreIfUnused
:
true
maxCount
:
1
}
{
name
:
"
PCompositorBridge
:
:
Msg_FlushRendering
"
condition
:
LINUX
ignoreIfUnused
:
true
maxCount
:
1
}
{
name
:
"
PWebRenderBridge
:
:
Msg_GetSnapshot
"
condition
:
WIN
&
&
WEBRENDER
ignoreIfUnused
:
true
maxCount
:
1
}
{
name
:
"
PCompositorBridge
:
:
Msg_MakeSnapshot
"
condition
:
WIN
ignoreIfUnused
:
true
maxCount
:
1
}
{
name
:
"
PCompositorBridge
:
:
Msg_WillClose
"
condition
:
WIN
ignoreIfUnused
:
true
maxCount
:
2
}
{
name
:
"
PGPU
:
:
Msg_AddLayerTreeIdMapping
"
condition
:
GPUPROCESS
ignoreIfUnused
:
true
maxCount
:
1
}
]
}
;
add_task
(
async
function
(
)
{
if
(
!
AppConstants
.
NIGHTLY_BUILD
&
&
!
AppConstants
.
MOZ_DEV_EDITION
&
&
!
AppConstants
.
DEBUG
)
{
ok
(
!
(
"
mozilla
.
org
/
test
/
startuprecorder
;
1
"
in
Cc
)
"
the
startup
recorder
component
shouldn
'
t
exist
in
this
non
-
nightly
/
non
-
devedition
/
"
+
"
non
-
debug
build
.
"
)
;
return
;
}
let
startupRecorder
=
Cc
[
"
mozilla
.
org
/
test
/
startuprecorder
;
1
"
]
.
getService
(
)
.
wrappedJSObject
;
await
startupRecorder
.
done
;
let
profile
=
startupRecorder
.
data
.
profile
.
threads
[
0
]
;
let
phases
=
{
}
;
{
const
nameCol
=
profile
.
markers
.
schema
.
name
;
const
dataCol
=
profile
.
markers
.
schema
.
data
;
const
startTimeCol
=
profile
.
markers
.
schema
.
startTime
;
let
markersForCurrentPhase
=
[
]
;
for
(
let
m
of
profile
.
markers
.
data
)
{
let
markerName
=
profile
.
stringTable
[
m
[
nameCol
]
]
;
if
(
markerName
.
startsWith
(
"
startupRecorder
:
"
)
)
{
phases
[
markerName
.
split
(
"
startupRecorder
:
"
)
[
1
]
]
=
markersForCurrentPhase
;
markersForCurrentPhase
=
[
]
;
continue
;
}
let
markerData
=
m
[
dataCol
]
;
if
(
!
markerData
|
|
markerData
.
category
!
=
"
Sync
IPC
"
|
|
!
m
[
startTimeCol
]
)
{
continue
;
}
markersForCurrentPhase
.
push
(
markerName
)
;
}
}
for
(
let
phase
in
startupPhases
)
{
startupPhases
[
phase
]
=
startupPhases
[
phase
]
.
filter
(
entry
=
>
!
(
"
condition
"
in
entry
)
|
|
entry
.
condition
)
;
}
let
shouldPass
=
true
;
for
(
let
phase
in
phases
)
{
let
knownIPCList
=
startupPhases
[
phase
]
;
if
(
knownIPCList
.
length
)
{
info
(
known
sync
IPC
{
phase
}
:
\
n
+
knownIPCList
.
map
(
e
=
>
{
e
.
name
}
-
at
most
{
e
.
maxCount
}
times
)
.
join
(
"
\
n
"
)
)
;
}
let
markers
=
phases
[
phase
]
;
for
(
let
marker
of
markers
)
{
let
expected
=
false
;
for
(
let
entry
of
knownIPCList
)
{
if
(
marker
=
=
entry
.
name
)
{
entry
.
useCount
=
(
entry
.
useCount
|
|
0
)
+
1
;
expected
=
true
;
break
;
}
}
if
(
!
expected
)
{
ok
(
false
unexpected
{
marker
}
sync
IPC
{
phase
}
)
;
shouldPass
=
false
;
}
}
for
(
let
entry
of
knownIPCList
)
{
entry
.
useCount
=
entry
.
useCount
|
|
0
;
let
message
=
sync
IPC
{
entry
.
name
}
;
if
(
entry
.
useCount
=
=
entry
.
maxCount
)
{
message
+
=
"
happened
as
many
times
as
expected
"
;
}
else
if
(
entry
.
useCount
<
entry
.
maxCount
)
{
message
+
=
allowed
{
entry
.
maxCount
}
but
only
happened
{
entry
.
useCount
}
times
;
}
else
{
message
+
=
happened
{
entry
.
useCount
}
but
max
is
{
entry
.
maxCount
}
;
shouldPass
=
false
;
}
Assert
.
lessOrEqual
(
entry
.
useCount
entry
.
maxCount
{
message
}
{
phase
}
)
;
if
(
entry
.
useCount
=
=
0
&
&
!
entry
.
ignoreIfUnused
)
{
ok
(
false
unused
known
IPC
entry
{
phase
}
:
{
entry
.
name
}
)
;
shouldPass
=
false
;
}
}
}
if
(
shouldPass
)
{
ok
(
shouldPass
"
No
unexpected
sync
IPC
during
startup
"
)
;
}
else
{
const
filename
=
"
profile_startup_syncIPC
.
json
"
;
let
path
=
Services
.
env
.
get
(
"
MOZ_UPLOAD_DIR
"
)
;
let
profilePath
=
PathUtils
.
join
(
path
filename
)
;
await
IOUtils
.
writeJSON
(
profilePath
startupRecorder
.
data
.
profile
)
;
ok
(
false
Unexpected
sync
IPC
behavior
during
startup
;
open
the
{
filename
}
+
"
artifact
in
the
Firefox
Profiler
to
see
what
happened
"
)
;
}
}
)
;
