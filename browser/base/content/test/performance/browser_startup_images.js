"
use
strict
"
;
const
knownUnshownImages
=
[
{
file
:
"
chrome
:
/
/
global
/
skin
/
icons
/
arrow
-
left
.
svg
"
platforms
:
[
"
linux
"
"
win
"
"
macosx
"
]
}
{
file
:
"
chrome
:
/
/
browser
/
skin
/
toolbar
-
drag
-
indicator
.
svg
"
platforms
:
[
"
linux
"
"
win
"
"
macosx
"
]
}
{
file
:
"
chrome
:
/
/
global
/
skin
/
icons
/
chevron
.
svg
"
platforms
:
[
"
win
"
"
linux
"
"
macosx
"
]
intermittentShown
:
[
"
win
"
"
linux
"
]
}
{
file
:
"
chrome
:
/
/
global
/
skin
/
icons
/
highlights
.
svg
"
platforms
:
[
"
win
"
"
linux
"
"
macosx
"
]
intermittentShown
:
[
"
win
"
"
linux
"
]
intermittentNotLoaded
:
Services
.
prefs
.
getBoolPref
(
"
browser
.
tabs
.
groups
.
smart
.
enabled
"
true
)
?
[
]
:
[
"
win
"
"
linux
"
"
macosx
"
]
}
]
;
add_task
(
async
function
(
)
{
if
(
!
AppConstants
.
DEBUG
)
{
ok
(
false
"
You
need
to
run
this
test
on
a
debug
build
.
"
)
;
}
let
startupRecorder
=
Cc
[
"
mozilla
.
org
/
test
/
startuprecorder
;
1
"
]
.
getService
(
)
.
wrappedJSObject
;
await
startupRecorder
.
done
;
let
data
=
Cu
.
cloneInto
(
startupRecorder
.
data
.
images
{
}
)
;
let
knownImagesForPlatform
=
knownUnshownImages
.
filter
(
el
=
>
{
return
el
.
platforms
.
includes
(
AppConstants
.
platform
)
;
}
)
;
{
let
results
=
await
PerfTestHelpers
.
throttledMapPromises
(
knownImagesForPlatform
async
image
=
>
(
{
uri
:
image
.
file
exists
:
await
PerfTestHelpers
.
checkURIExists
(
image
.
file
)
}
)
)
;
for
(
let
{
uri
exists
}
of
results
)
{
ok
(
exists
Unshown
image
entry
{
uri
}
must
exist
)
;
}
}
let
loadedImages
=
data
[
"
image
-
loading
"
]
;
let
shownImages
=
data
[
"
image
-
drawing
"
]
;
for
(
let
loaded
of
loadedImages
.
values
(
)
)
{
let
knownImage
=
knownImagesForPlatform
.
find
(
el
=
>
{
if
(
window
.
devicePixelRatio
>
=
2
&
&
el
.
hidpi
&
&
el
.
hidpi
=
=
loaded
)
{
return
true
;
}
return
el
.
file
=
=
loaded
;
}
)
;
if
(
knownImage
)
{
if
(
!
knownImage
.
intermittentShown
|
|
!
knownImage
.
intermittentShown
.
includes
(
AppConstants
.
platform
)
)
{
todo
(
shownImages
.
has
(
loaded
)
Image
{
loaded
}
should
not
have
been
shown
.
)
;
}
continue
;
}
ok
(
shownImages
.
has
(
loaded
)
Loaded
image
{
loaded
}
should
have
been
shown
.
)
;
}
for
(
let
item
of
knownImagesForPlatform
)
{
if
(
!
item
.
intermittentNotLoaded
|
|
!
item
.
intermittentNotLoaded
.
includes
(
AppConstants
.
platform
)
)
{
if
(
window
.
devicePixelRatio
>
=
2
&
&
item
.
hidpi
)
{
if
(
item
.
hidpi
!
=
"
<
not
loaded
>
"
)
{
ok
(
loadedImages
.
has
(
item
.
hidpi
)
Image
{
item
.
hidpi
}
should
have
been
loaded
.
)
;
}
}
else
{
ok
(
loadedImages
.
has
(
item
.
file
)
Image
{
item
.
file
}
should
have
been
loaded
.
)
;
}
}
}
}
)
;
