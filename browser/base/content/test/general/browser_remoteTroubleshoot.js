var
{
WebChannel
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
WebChannel
.
sys
.
mjs
"
)
;
const
{
PermissionTestUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
PermissionTestUtils
.
sys
.
mjs
"
)
;
const
TEST_URL_TAIL
=
"
example
.
com
/
browser
/
browser
/
base
/
content
/
test
/
general
/
test_remoteTroubleshoot
.
html
"
;
const
TEST_URI_GOOD
=
Services
.
io
.
newURI
(
"
https
:
/
/
"
+
TEST_URL_TAIL
)
;
const
TEST_URI_BAD
=
Services
.
io
.
newURI
(
"
http
:
/
/
"
+
TEST_URL_TAIL
)
;
const
TEST_URI_GOOD_OBJECT
=
Services
.
io
.
newURI
(
"
https
:
/
/
"
+
TEST_URL_TAIL
+
"
?
object
"
)
;
function
promiseChannelResponse
(
channelID
originOrPermission
)
{
return
new
Promise
(
resolve
=
>
{
let
channel
=
new
WebChannel
(
channelID
originOrPermission
)
;
channel
.
listen
(
(
id
data
)
=
>
{
channel
.
stopListening
(
)
;
resolve
(
data
)
;
}
)
;
}
)
;
}
function
promiseNewChannelResponse
(
uri
)
{
let
channelPromise
=
promiseChannelResponse
(
"
test
-
remote
-
troubleshooting
-
backchannel
"
uri
)
;
let
tab
=
gBrowser
.
addTab
(
uri
.
spec
{
inBackground
:
false
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
}
)
;
return
promiseTabLoaded
(
tab
)
.
then
(
(
)
=
>
channelPromise
)
.
then
(
data
=
>
{
gBrowser
.
removeTab
(
tab
)
;
return
data
;
}
)
;
}
add_task
(
async
function
(
)
{
let
got
=
await
promiseNewChannelResponse
(
TEST_URI_GOOD
)
;
Assert
.
ok
(
got
.
message
.
errno
=
=
=
2
"
should
have
failed
with
errno
2
no
such
channel
"
)
;
PermissionTestUtils
.
add
(
TEST_URI_GOOD
"
remote
-
troubleshooting
"
Services
.
perms
.
ALLOW_ACTION
)
;
registerCleanupFunction
(
(
)
=
>
{
PermissionTestUtils
.
remove
(
TEST_URI_GOOD
"
remote
-
troubleshooting
"
)
;
}
)
;
got
=
await
promiseNewChannelResponse
(
TEST_URI_GOOD
)
;
Assert
.
ok
(
got
.
message
.
addons
"
should
have
addons
"
)
;
Assert
.
ok
(
got
.
message
.
graphics
"
should
have
graphics
"
)
;
Assert
.
equal
(
got
.
message
.
application
.
buildID
Services
.
appinfo
.
appBuildID
"
should
have
correct
build
ID
"
)
;
let
updateChannel
=
null
;
try
{
updateChannel
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
UpdateUtils
.
sys
.
mjs
"
)
.
UpdateUtils
.
UpdateChannel
;
}
catch
(
ex
)
{
}
if
(
!
updateChannel
)
{
Assert
.
ok
(
!
(
"
updateChannel
"
in
got
.
message
.
application
)
"
should
not
have
update
channel
where
not
available
.
"
)
;
}
else
{
Assert
.
equal
(
got
.
message
.
application
.
updateChannel
updateChannel
"
should
have
correct
update
channel
.
"
)
;
}
Assert
.
ok
(
!
got
.
message
.
modifiedPreferences
"
should
not
have
a
modifiedPreferences
key
"
)
;
Assert
.
ok
(
!
got
.
message
.
printingPreferences
"
should
not
have
a
printingPreferences
key
"
)
;
Assert
.
ok
(
!
got
.
message
.
crashes
"
should
not
have
crash
info
"
)
;
got
=
await
promiseNewChannelResponse
(
TEST_URI_BAD
)
;
Assert
.
ok
(
got
.
message
.
errno
=
=
=
2
"
should
have
failed
with
errno
2
no
such
channel
"
)
;
let
webchannelWhitelistPref
=
"
webchannel
.
allowObject
.
urlWhitelist
"
;
let
origWhitelist
=
Services
.
prefs
.
getCharPref
(
webchannelWhitelistPref
)
;
let
newWhitelist
=
origWhitelist
+
"
https
:
/
/
example
.
com
"
;
Services
.
prefs
.
setCharPref
(
webchannelWhitelistPref
newWhitelist
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
webchannelWhitelistPref
)
;
}
)
;
got
=
await
promiseNewChannelResponse
(
TEST_URI_GOOD_OBJECT
)
;
Assert
.
ok
(
got
.
message
"
should
have
gotten
some
data
back
"
)
;
}
)
;
