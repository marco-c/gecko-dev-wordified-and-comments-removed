XPCOMUtils
.
defineLazyGetter
(
this
"
docShell
"
(
)
=
>
{
return
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebNavigation
)
.
QueryInterface
(
Ci
.
nsIDocShell
)
;
}
)
;
const
EXPECTED_REFLOWS
=
[
"
adjustTabstrip
chrome
:
/
/
browser
/
content
/
tabbrowser
.
xml
|
"
+
"
_handleNewTab
chrome
:
/
/
browser
/
content
/
tabbrowser
.
xml
|
"
+
"
onxbltransitionend
chrome
:
/
/
browser
/
content
/
tabbrowser
.
xml
|
"
"
_adjustFocusAfterTabSwitch
chrome
:
/
/
browser
/
content
/
tabbrowser
.
xml
|
"
+
"
updateCurrentBrowser
chrome
:
/
/
browser
/
content
/
tabbrowser
.
xml
|
"
+
"
onselect
chrome
:
/
/
browser
/
content
/
browser
.
xul
|
"
"
openLinkIn
chrome
:
/
/
browser
/
content
/
utilityOverlay
.
js
|
"
+
"
openUILinkIn
chrome
:
/
/
browser
/
content
/
utilityOverlay
.
js
|
"
+
"
BrowserOpenTab
chrome
:
/
/
browser
/
content
/
browser
.
js
|
"
"
get_scrollPosition
chrome
:
/
/
global
/
content
/
bindings
/
scrollbox
.
xml
|
"
+
"
_fillTrailingGap
chrome
:
/
/
browser
/
content
/
tabbrowser
.
xml
|
"
+
"
_handleNewTab
chrome
:
/
/
browser
/
content
/
tabbrowser
.
xml
|
"
+
"
onxbltransitionend
chrome
:
/
/
browser
/
content
/
tabbrowser
.
xml
|
"
"
ssi_getWindowDimension
resource
:
/
/
/
modules
/
sessionstore
/
SessionStore
.
jsm
|
"
+
"
ssi_updateWindowFeatures
/
<
resource
:
/
/
/
modules
/
sessionstore
/
SessionStore
.
jsm
|
"
+
"
ssi_updateWindowFeatures
resource
:
/
/
/
modules
/
sessionstore
/
SessionStore
.
jsm
|
"
+
"
ssi_collectWindowData
resource
:
/
/
/
modules
/
sessionstore
/
SessionStore
.
jsm
|
"
"
select
chrome
:
/
/
global
/
content
/
bindings
/
textbox
.
xml
|
"
+
"
focusAndSelectUrlBar
chrome
:
/
/
browser
/
content
/
browser
.
js
|
"
+
"
openLinkIn
chrome
:
/
/
browser
/
content
/
utilityOverlay
.
js
|
"
+
"
openUILinkIn
chrome
:
/
/
browser
/
content
/
utilityOverlay
.
js
|
"
+
"
BrowserOpenTab
chrome
:
/
/
browser
/
content
/
browser
.
js
|
"
]
;
const
PREF_PRELOAD
=
"
browser
.
newtab
.
preload
"
;
const
PREF_NEWTAB_DIRECTORYSOURCE
=
"
browser
.
newtabpage
.
directory
.
source
"
;
add_task
(
function
*
(
)
{
let
DirectoryLinksProvider
=
Cu
.
import
(
"
resource
:
/
/
/
modules
/
DirectoryLinksProvider
.
jsm
"
{
}
)
.
DirectoryLinksProvider
;
let
NewTabUtils
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
NewTabUtils
.
jsm
"
{
}
)
.
NewTabUtils
;
let
Promise
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Promise
.
jsm
"
{
}
)
.
Promise
;
function
watchLinksChangeOnce
(
)
{
let
deferred
=
Promise
.
defer
(
)
;
let
observer
=
{
onManyLinksChanged
:
(
)
=
>
{
DirectoryLinksProvider
.
removeObserver
(
observer
)
;
NewTabUtils
.
links
.
populateCache
(
(
)
=
>
{
NewTabUtils
.
allPages
.
update
(
)
;
deferred
.
resolve
(
)
;
}
true
)
;
}
}
;
observer
.
onDownloadFail
=
observer
.
onManyLinksChanged
;
DirectoryLinksProvider
.
addObserver
(
observer
)
;
return
deferred
.
promise
;
}
let
gOrigDirectorySource
=
Services
.
prefs
.
getCharPref
(
PREF_NEWTAB_DIRECTORYSOURCE
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
PREF_PRELOAD
)
;
Services
.
prefs
.
setCharPref
(
PREF_NEWTAB_DIRECTORYSOURCE
gOrigDirectorySource
)
;
return
watchLinksChangeOnce
(
)
;
}
)
;
Services
.
prefs
.
setBoolPref
(
PREF_PRELOAD
false
)
;
Services
.
prefs
.
setCharPref
(
PREF_NEWTAB_DIRECTORYSOURCE
'
data
:
application
/
json
{
"
test
"
:
1
}
'
)
;
yield
watchLinksChangeOnce
(
)
;
let
target
=
gBrowser
.
selectedBrowser
;
let
rect
=
target
.
getBoundingClientRect
(
)
;
let
left
=
rect
.
left
+
1
;
let
top
=
rect
.
top
+
1
;
let
utils
=
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
utils
.
sendMouseEvent
(
"
mousedown
"
left
top
0
1
0
false
0
0
)
;
utils
.
sendMouseEvent
(
"
mouseup
"
left
top
0
1
0
false
0
0
)
;
docShell
.
addWeakReflowObserver
(
observer
)
;
BrowserOpenTab
(
)
;
yield
waitForTransitionEnd
(
)
;
docShell
.
removeWeakReflowObserver
(
observer
)
;
gBrowser
.
removeCurrentTab
(
)
;
}
)
;
var
observer
=
{
reflow
:
function
(
start
end
)
{
let
path
=
(
new
Error
(
)
.
stack
)
.
split
(
"
\
n
"
)
.
slice
(
1
)
.
map
(
line
=
>
{
return
line
.
replace
(
/
:
\
d
+
:
\
d
+
/
"
"
)
;
}
)
.
join
(
"
|
"
)
;
let
pathWithLineNumbers
=
(
new
Error
(
)
.
stack
)
.
split
(
"
\
n
"
)
.
slice
(
1
)
.
join
(
"
|
"
)
;
if
(
path
=
=
=
"
"
)
{
return
;
}
for
(
let
stack
of
EXPECTED_REFLOWS
)
{
if
(
path
.
startsWith
(
stack
)
)
{
ok
(
true
"
expected
uninterruptible
reflow
'
"
+
stack
+
"
'
"
)
;
return
;
}
}
ok
(
false
"
unexpected
uninterruptible
reflow
'
"
+
pathWithLineNumbers
+
"
'
"
)
;
}
reflowInterruptible
:
function
(
start
end
)
{
}
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIReflowObserver
Ci
.
nsISupportsWeakReference
]
)
}
;
function
waitForTransitionEnd
(
)
{
return
new
Promise
(
resolve
=
>
{
let
tab
=
gBrowser
.
selectedTab
;
tab
.
addEventListener
(
"
transitionend
"
function
onEnd
(
event
)
{
if
(
event
.
propertyName
=
=
=
"
max
-
width
"
)
{
tab
.
removeEventListener
(
"
transitionend
"
onEnd
)
;
resolve
(
)
;
}
}
)
;
}
)
;
}
