Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Promise
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
WebChannel
"
"
resource
:
/
/
gre
/
modules
/
WebChannel
.
jsm
"
)
;
const
HTTP_PATH
=
"
http
:
/
/
example
.
com
"
;
const
HTTP_ENDPOINT
=
"
/
browser
/
browser
/
base
/
content
/
test
/
general
/
browser_web_channel
.
html
"
;
const
HTTP_MISMATCH_PATH
=
"
http
:
/
/
example
.
org
"
;
const
HTTP_IFRAME_PATH
=
"
http
:
/
/
mochi
.
test
:
8888
"
;
const
HTTP_REDIRECTED_IFRAME_PATH
=
"
http
:
/
/
example
.
org
"
;
var
gTests
=
[
{
desc
:
"
WebChannel
generic
message
"
run
:
function
*
(
)
{
return
new
Promise
(
function
(
resolve
reject
)
{
let
tab
;
let
channel
=
new
WebChannel
(
"
generic
"
Services
.
io
.
newURI
(
HTTP_PATH
null
null
)
)
;
channel
.
listen
(
function
(
id
message
target
)
{
is
(
id
"
generic
"
)
;
is
(
message
.
something
.
nested
"
hello
"
)
;
channel
.
stopListening
(
)
;
gBrowser
.
removeTab
(
tab
)
;
resolve
(
)
;
}
)
;
tab
=
gBrowser
.
addTab
(
HTTP_PATH
+
HTTP_ENDPOINT
+
"
?
generic
"
)
;
}
)
;
}
}
{
desc
:
"
WebChannel
generic
message
in
a
private
window
.
"
run
:
function
*
(
)
{
let
promiseTestDone
=
new
Promise
(
function
(
resolve
reject
)
{
let
channel
=
new
WebChannel
(
"
generic
"
Services
.
io
.
newURI
(
HTTP_PATH
null
null
)
)
;
channel
.
listen
(
function
(
id
message
target
)
{
is
(
id
"
generic
"
)
;
is
(
message
.
something
.
nested
"
hello
"
)
;
channel
.
stopListening
(
)
;
resolve
(
)
;
}
)
;
}
)
;
const
url
=
HTTP_PATH
+
HTTP_ENDPOINT
+
"
?
generic
"
;
let
privateWindow
=
yield
BrowserTestUtils
.
openNewBrowserWindow
(
{
private
:
true
}
)
;
yield
BrowserTestUtils
.
openNewForegroundTab
(
privateWindow
.
gBrowser
url
)
;
yield
promiseTestDone
;
yield
BrowserTestUtils
.
closeWindow
(
privateWindow
)
;
}
}
{
desc
:
"
WebChannel
two
way
communication
"
run
:
function
*
(
)
{
return
new
Promise
(
function
(
resolve
reject
)
{
let
tab
;
let
channel
=
new
WebChannel
(
"
twoway
"
Services
.
io
.
newURI
(
HTTP_PATH
null
null
)
)
;
channel
.
listen
(
function
(
id
message
sender
)
{
is
(
id
"
twoway
"
"
bad
id
"
)
;
ok
(
message
.
command
"
command
not
ok
"
)
;
if
(
message
.
command
=
=
=
"
one
"
)
{
channel
.
send
(
{
data
:
{
nested
:
true
}
}
sender
)
;
}
if
(
message
.
command
=
=
=
"
two
"
)
{
is
(
message
.
detail
.
data
.
nested
true
)
;
channel
.
stopListening
(
)
;
gBrowser
.
removeTab
(
tab
)
;
resolve
(
)
;
}
}
)
;
tab
=
gBrowser
.
addTab
(
HTTP_PATH
+
HTTP_ENDPOINT
+
"
?
twoway
"
)
;
}
)
;
}
}
{
desc
:
"
WebChannel
two
way
communication
in
an
iframe
"
run
:
function
*
(
)
{
let
parentChannel
=
new
WebChannel
(
"
echo
"
Services
.
io
.
newURI
(
HTTP_PATH
null
null
)
)
;
let
iframeChannel
=
new
WebChannel
(
"
twoway
"
Services
.
io
.
newURI
(
HTTP_IFRAME_PATH
null
null
)
)
;
let
promiseTestDone
=
new
Promise
(
function
(
resolve
reject
)
{
parentChannel
.
listen
(
function
(
id
message
sender
)
{
reject
(
new
Error
(
"
WebChannel
message
incorrectly
sent
to
parent
"
)
)
;
}
)
;
iframeChannel
.
listen
(
function
(
id
message
sender
)
{
is
(
id
"
twoway
"
"
bad
id
(
2
)
"
)
;
ok
(
message
.
command
"
command
not
ok
(
2
)
"
)
;
if
(
message
.
command
=
=
=
"
one
"
)
{
iframeChannel
.
send
(
{
data
:
{
nested
:
true
}
}
sender
)
;
}
if
(
message
.
command
=
=
=
"
two
"
)
{
is
(
message
.
detail
.
data
.
nested
true
)
;
resolve
(
)
;
}
}
)
;
}
)
;
yield
BrowserTestUtils
.
withNewTab
(
{
gBrowser
:
gBrowser
url
:
HTTP_PATH
+
HTTP_ENDPOINT
+
"
?
iframe
"
}
function
*
(
)
{
yield
promiseTestDone
;
parentChannel
.
stopListening
(
)
;
iframeChannel
.
stopListening
(
)
;
}
)
;
}
}
{
desc
:
"
WebChannel
response
to
a
redirected
iframe
"
run
:
function
*
(
)
{
let
preRedirectChannel
=
new
WebChannel
(
"
pre_redirect
"
Services
.
io
.
newURI
(
HTTP_IFRAME_PATH
null
null
)
)
;
let
postRedirectChannel
=
new
WebChannel
(
"
post_redirect
"
Services
.
io
.
newURI
(
HTTP_REDIRECTED_IFRAME_PATH
null
null
)
)
;
let
promiseTestDone
=
new
Promise
(
function
(
resolve
reject
)
{
preRedirectChannel
.
listen
(
function
(
id
message
preRedirectSender
)
{
if
(
message
.
command
=
=
=
"
redirecting
"
)
{
postRedirectChannel
.
listen
(
function
(
aId
aMessage
aPostRedirectSender
)
{
is
(
aId
"
post_redirect
"
)
;
isnot
(
aMessage
.
command
"
no_response_expected
"
)
;
if
(
aMessage
.
command
=
=
=
"
loaded
"
)
{
preRedirectChannel
.
send
(
{
command
:
"
no_response_expected
"
}
preRedirectSender
)
;
postRedirectChannel
.
send
(
{
command
:
"
done
"
}
aPostRedirectSender
)
;
}
else
if
(
aMessage
.
command
=
=
=
"
done
"
)
{
resolve
(
)
;
}
else
{
reject
(
new
Error
(
Unexpected
command
{
aMessage
.
command
}
)
)
;
}
}
)
;
}
else
{
reject
(
new
Error
(
Unexpected
command
{
message
.
command
}
)
)
;
}
}
)
;
}
)
;
yield
BrowserTestUtils
.
withNewTab
(
{
gBrowser
:
gBrowser
url
:
HTTP_PATH
+
HTTP_ENDPOINT
+
"
?
iframe_pre_redirect
"
}
function
*
(
)
{
yield
promiseTestDone
;
preRedirectChannel
.
stopListening
(
)
;
postRedirectChannel
.
stopListening
(
)
;
}
)
;
}
}
{
desc
:
"
WebChannel
multichannel
"
run
:
function
*
(
)
{
return
new
Promise
(
function
(
resolve
reject
)
{
let
tab
;
let
channel
=
new
WebChannel
(
"
multichannel
"
Services
.
io
.
newURI
(
HTTP_PATH
null
null
)
)
;
channel
.
listen
(
function
(
id
message
sender
)
{
is
(
id
"
multichannel
"
)
;
gBrowser
.
removeTab
(
tab
)
;
resolve
(
)
;
}
)
;
tab
=
gBrowser
.
addTab
(
HTTP_PATH
+
HTTP_ENDPOINT
+
"
?
multichannel
"
)
;
}
)
;
}
}
{
desc
:
"
WebChannel
unsolicited
send
using
system
principal
"
run
:
function
*
(
)
{
let
channel
=
new
WebChannel
(
"
echo
"
Services
.
io
.
newURI
(
HTTP_PATH
null
null
)
)
;
let
messagePromise
=
new
Promise
(
function
(
resolve
reject
)
{
channel
.
listen
(
function
(
id
message
sender
)
{
is
(
id
"
echo
"
)
;
is
(
message
.
command
"
unsolicited
"
)
;
resolve
(
)
}
)
;
}
)
;
yield
BrowserTestUtils
.
withNewTab
(
{
gBrowser
url
:
HTTP_PATH
+
HTTP_ENDPOINT
+
"
?
unsolicited
"
}
function
*
(
targetBrowser
)
{
channel
.
send
(
{
command
:
"
unsolicited
"
}
{
browser
:
targetBrowser
principal
:
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
}
)
;
yield
messagePromise
;
channel
.
stopListening
(
)
;
}
)
;
}
}
{
desc
:
"
WebChannel
unsolicited
send
using
target
origin
'
s
principal
"
run
:
function
*
(
)
{
let
targetURI
=
Services
.
io
.
newURI
(
HTTP_PATH
null
null
)
;
let
channel
=
new
WebChannel
(
"
echo
"
targetURI
)
;
let
messagePromise
=
new
Promise
(
function
(
resolve
reject
)
{
channel
.
listen
(
function
(
id
message
sender
)
{
is
(
id
"
echo
"
)
;
is
(
message
.
command
"
unsolicited
"
)
;
resolve
(
)
;
}
)
;
}
)
;
yield
BrowserTestUtils
.
withNewTab
(
{
gBrowser
url
:
HTTP_PATH
+
HTTP_ENDPOINT
+
"
?
unsolicited
"
}
function
*
(
targetBrowser
)
{
channel
.
send
(
{
command
:
"
unsolicited
"
}
{
browser
:
targetBrowser
principal
:
Services
.
scriptSecurityManager
.
getNoAppCodebasePrincipal
(
targetURI
)
}
)
;
yield
messagePromise
;
channel
.
stopListening
(
)
;
}
)
;
}
}
{
desc
:
"
WebChannel
unsolicited
send
with
principal
mismatch
"
run
:
function
*
(
)
{
let
targetURI
=
Services
.
io
.
newURI
(
HTTP_PATH
null
null
)
;
let
channel
=
new
WebChannel
(
"
echo
"
targetURI
)
;
let
messagePromise
=
new
Promise
(
function
(
resolve
reject
)
{
channel
.
listen
(
function
(
id
message
sender
)
{
is
(
id
"
echo
"
)
;
if
(
message
.
command
=
=
=
"
done
"
)
{
resolve
(
)
;
}
else
{
reject
(
new
Error
(
Unexpected
command
{
message
.
command
}
)
)
;
}
}
)
;
}
)
;
yield
BrowserTestUtils
.
withNewTab
(
{
gBrowser
:
gBrowser
url
:
HTTP_PATH
+
HTTP_ENDPOINT
+
"
?
unsolicited
"
}
function
*
(
targetBrowser
)
{
let
mismatchURI
=
Services
.
io
.
newURI
(
HTTP_MISMATCH_PATH
null
null
)
;
let
mismatchPrincipal
=
Services
.
scriptSecurityManager
.
getNoAppCodebasePrincipal
(
mismatchURI
)
;
channel
.
send
(
{
command
:
"
unsolicited_no_response_expected
"
}
{
browser
:
targetBrowser
principal
:
mismatchPrincipal
}
)
;
let
targetPrincipal
=
Services
.
scriptSecurityManager
.
getNoAppCodebasePrincipal
(
targetURI
)
;
channel
.
send
(
{
command
:
"
done
"
}
{
browser
:
targetBrowser
principal
:
targetPrincipal
}
)
;
yield
messagePromise
;
channel
.
stopListening
(
)
;
}
)
;
}
}
{
desc
:
"
WebChannel
non
-
window
target
"
run
:
function
*
(
)
{
let
channel
=
new
WebChannel
(
"
not_a_window
"
Services
.
io
.
newURI
(
HTTP_PATH
null
null
)
)
;
let
testDonePromise
=
new
Promise
(
function
(
resolve
reject
)
{
channel
.
listen
(
function
(
id
message
sender
)
{
if
(
message
.
command
=
=
=
"
start
"
)
{
channel
.
send
(
{
command
:
"
done
"
}
sender
)
;
}
else
if
(
message
.
command
=
=
=
"
done
"
)
{
resolve
(
)
;
}
else
{
reject
(
new
Error
(
Unexpected
command
{
message
.
command
}
)
)
;
}
}
)
;
}
)
;
yield
BrowserTestUtils
.
withNewTab
(
{
gBrowser
url
:
HTTP_PATH
+
HTTP_ENDPOINT
+
"
?
bubbles
"
}
function
*
(
)
{
yield
testDonePromise
;
channel
.
stopListening
(
)
;
}
)
;
}
}
{
desc
:
"
WebChannel
disallows
non
-
string
message
from
non
-
whitelisted
origin
"
run
:
function
*
(
)
{
let
channel
=
new
WebChannel
(
"
objects
"
Services
.
io
.
newURI
(
HTTP_PATH
null
null
)
)
;
let
testDonePromise
=
new
Promise
(
(
resolve
reject
)
=
>
{
channel
.
listen
(
(
id
message
sender
)
=
>
{
is
(
id
"
objects
"
)
;
is
(
message
.
type
"
string
"
)
;
resolve
(
)
;
}
)
;
}
)
;
yield
BrowserTestUtils
.
withNewTab
(
{
gBrowser
url
:
HTTP_PATH
+
HTTP_ENDPOINT
+
"
?
object
"
}
function
*
(
)
{
yield
testDonePromise
;
channel
.
stopListening
(
)
;
}
)
;
}
}
{
desc
:
"
WebChannel
allows
both
string
and
non
-
string
message
from
whitelisted
origin
"
run
:
function
*
(
)
{
let
channel
=
new
WebChannel
(
"
objects
"
Services
.
io
.
newURI
(
HTTP_PATH
null
null
)
)
;
let
testDonePromise
=
new
Promise
(
(
resolve
reject
)
=
>
{
let
sawObject
=
false
;
let
sawString
=
false
;
channel
.
listen
(
(
id
message
sender
)
=
>
{
is
(
id
"
objects
"
)
;
if
(
message
.
type
=
=
=
"
object
"
)
{
ok
(
!
sawObject
)
;
sawObject
=
true
;
}
else
if
(
message
.
type
=
=
=
"
string
"
)
{
ok
(
!
sawString
)
;
sawString
=
true
;
}
else
{
reject
(
new
Error
(
Unknown
message
type
:
{
message
.
type
}
)
)
}
if
(
sawObject
&
&
sawString
)
{
resolve
(
)
;
}
}
)
;
}
)
;
const
webchannelWhitelistPref
=
"
webchannel
.
allowObject
.
urlWhitelist
"
;
let
origWhitelist
=
Services
.
prefs
.
getCharPref
(
webchannelWhitelistPref
)
;
let
newWhitelist
=
origWhitelist
+
"
"
+
HTTP_PATH
;
Services
.
prefs
.
setCharPref
(
webchannelWhitelistPref
newWhitelist
)
;
yield
BrowserTestUtils
.
withNewTab
(
{
gBrowser
url
:
HTTP_PATH
+
HTTP_ENDPOINT
+
"
?
object
"
}
function
*
(
)
{
yield
testDonePromise
;
Services
.
prefs
.
setCharPref
(
webchannelWhitelistPref
origWhitelist
)
;
channel
.
stopListening
(
)
;
}
)
;
}
}
{
desc
:
"
WebChannel
errors
handling
the
message
are
delivered
back
to
content
"
run
:
function
*
(
)
{
const
ERRNO_UNKNOWN_ERROR
=
999
;
let
channel
=
new
WebChannel
(
"
error
"
Services
.
io
.
newURI
(
HTTP_PATH
null
null
)
)
;
let
echoChannel
=
new
WebChannel
(
"
echo
"
Services
.
io
.
newURI
(
HTTP_PATH
null
null
)
)
;
let
testDonePromise
=
new
Promise
(
(
resolve
reject
)
=
>
{
echoChannel
.
listen
(
(
id
message
sender
)
=
>
{
is
(
id
"
echo
"
)
;
is
(
message
.
error
"
oh
no
"
)
;
is
(
message
.
errno
ERRNO_UNKNOWN_ERROR
)
;
resolve
(
)
;
}
)
;
channel
.
listen
(
(
id
message
sender
)
=
>
{
is
(
id
"
error
"
)
;
is
(
message
.
command
"
oops
"
)
;
throw
new
Error
(
"
oh
no
"
)
;
}
)
;
}
)
;
yield
BrowserTestUtils
.
withNewTab
(
{
gBrowser
url
:
HTTP_PATH
+
HTTP_ENDPOINT
+
"
?
error_thrown
"
}
function
*
(
)
{
yield
testDonePromise
;
channel
.
stopListening
(
)
;
echoChannel
.
stopListening
(
)
;
}
)
;
}
}
{
desc
:
"
WebChannel
errors
due
to
an
invalid
channel
are
delivered
back
to
content
"
run
:
function
*
(
)
{
const
ERRNO_NO_SUCH_CHANNEL
=
2
;
let
echoChannel
=
new
WebChannel
(
"
echo
"
Services
.
io
.
newURI
(
HTTP_PATH
null
null
)
)
;
let
testDonePromise
=
new
Promise
(
(
resolve
reject
)
=
>
{
echoChannel
.
listen
(
(
id
message
sender
)
=
>
{
is
(
id
"
echo
"
)
;
is
(
message
.
error
"
No
Such
Channel
"
)
;
is
(
message
.
errno
ERRNO_NO_SUCH_CHANNEL
)
;
resolve
(
)
;
}
)
;
}
)
;
yield
BrowserTestUtils
.
withNewTab
(
{
gBrowser
url
:
HTTP_PATH
+
HTTP_ENDPOINT
+
"
?
error_invalid_channel
"
}
function
*
(
)
{
yield
testDonePromise
;
echoChannel
.
stopListening
(
)
;
}
)
;
}
}
]
;
function
test
(
)
{
waitForExplicitFinish
(
)
;
Task
.
spawn
(
function
*
(
)
{
for
(
let
testCase
of
gTests
)
{
info
(
"
Running
:
"
+
testCase
.
desc
)
;
yield
testCase
.
run
(
)
;
}
}
)
.
then
(
finish
ex
=
>
{
ok
(
false
"
Unexpected
Exception
:
"
+
ex
)
;
finish
(
)
;
}
)
;
}
