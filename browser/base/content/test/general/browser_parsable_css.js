let
whitelist
=
[
{
sourceName
:
/
codemirror
\
.
css
/
i
isFromDevTools
:
true
}
{
sourceName
:
/
devtools
\
/
client
\
/
debugger
\
/
new
\
/
styles
.
css
/
i
isFromDevTools
:
true
}
{
sourceName
:
/
web
\
/
viewer
\
.
css
/
i
errorMessage
:
/
Unknown
pseudo
-
class
.
*
(
fullscreen
|
selection
)
/
i
isFromDevTools
:
false
}
{
sourceName
:
/
aboutaccounts
\
/
(
main
|
normalize
)
\
.
css
/
i
isFromDevTools
:
false
}
{
sourceName
:
/
highlighters
\
.
css
/
i
errorMessage
:
/
Unknown
pseudo
-
class
.
*
moz
-
native
-
anonymous
/
i
isFromDevTools
:
true
}
{
sourceName
:
/
responsive
-
ua
\
.
css
/
i
errorMessage
:
/
Unknown
pseudo
-
class
.
*
moz
-
dropdown
-
list
/
i
isFromDevTools
:
true
}
]
;
let
allowedImageReferences
=
[
{
file
:
"
chrome
:
/
/
devtools
/
skin
/
images
/
dock
-
bottom
-
minimize
2x
.
png
"
from
:
"
chrome
:
/
/
devtools
/
skin
/
toolbox
.
css
"
isFromDevTools
:
true
}
{
file
:
"
chrome
:
/
/
devtools
/
skin
/
images
/
dock
-
bottom
-
maximize
2x
.
png
"
from
:
"
chrome
:
/
/
devtools
/
skin
/
toolbox
.
css
"
isFromDevTools
:
true
}
{
file
:
"
chrome
/
devtools
/
modules
/
devtools
/
client
/
themes
/
images
/
filter
.
svg
"
from
:
"
chrome
/
devtools
/
modules
/
devtools
/
client
/
themes
/
common
.
css
"
isFromDevTools
:
true
}
]
;
var
moduleLocation
=
gTestPath
.
replace
(
/
\
/
[
^
\
/
]
*
/
i
"
/
parsingTestHelpers
.
jsm
"
)
;
var
{
generateURIsFromDirTree
}
=
Cu
.
import
(
moduleLocation
{
}
)
;
const
kPathSuffix
=
"
?
always
-
parse
-
css
-
"
+
Math
.
random
(
)
;
function
ignoredError
(
aErrorObject
)
{
for
(
let
whitelistItem
of
whitelist
)
{
let
matches
=
true
;
for
(
let
prop
of
[
"
sourceName
"
"
errorMessage
"
]
)
{
if
(
whitelistItem
.
hasOwnProperty
(
prop
)
&
&
!
whitelistItem
[
prop
]
.
test
(
aErrorObject
[
prop
]
|
|
"
"
)
)
{
matches
=
false
;
break
;
}
}
if
(
matches
)
{
whitelistItem
.
used
=
true
;
return
true
;
}
}
return
false
;
}
function
once
(
target
name
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
cb
=
(
)
=
>
{
target
.
removeEventListener
(
name
cb
)
;
resolve
(
)
;
}
;
target
.
addEventListener
(
name
cb
)
;
}
)
;
}
function
fetchFile
(
uri
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
xhr
=
new
XMLHttpRequest
(
)
;
xhr
.
open
(
"
GET
"
uri
true
)
;
xhr
.
onreadystatechange
=
function
(
)
{
if
(
this
.
readyState
!
=
this
.
DONE
)
{
return
;
}
try
{
resolve
(
this
.
responseText
)
;
}
catch
(
ex
)
{
ok
(
false
Script
error
reading
{
uri
}
:
{
ex
}
)
;
resolve
(
"
"
)
;
}
}
;
xhr
.
onerror
=
error
=
>
{
ok
(
false
XHR
error
reading
{
uri
}
:
{
error
}
)
;
resolve
(
"
"
)
;
}
;
xhr
.
send
(
null
)
;
}
)
;
}
var
gChromeReg
=
Cc
[
"
mozilla
.
org
/
chrome
/
chrome
-
registry
;
1
"
]
.
getService
(
Ci
.
nsIChromeRegistry
)
;
var
gChromeMap
=
new
Map
(
)
;
function
getBaseUriForChromeUri
(
chromeUri
)
{
let
chromeFile
=
chromeUri
+
"
gobbledygooknonexistentfile
.
reallynothere
"
;
let
uri
=
Services
.
io
.
newURI
(
chromeFile
null
null
)
;
let
fileUri
=
gChromeReg
.
convertChromeURL
(
uri
)
;
return
fileUri
.
resolve
(
"
.
"
)
;
}
function
parseManifest
(
manifestUri
)
{
return
fetchFile
(
manifestUri
.
spec
)
.
then
(
data
=
>
{
for
(
let
line
of
data
.
split
(
'
\
n
'
)
)
{
let
[
type
.
.
.
argv
]
=
line
.
split
(
/
\
s
+
/
)
;
let
component
;
if
(
type
=
=
"
content
"
|
|
type
=
=
"
skin
"
)
{
[
component
]
=
argv
;
}
else
{
continue
;
}
let
chromeUri
=
chrome
:
/
/
{
component
}
/
{
type
}
/
;
gChromeMap
.
set
(
getBaseUriForChromeUri
(
chromeUri
)
chromeUri
)
;
}
}
)
;
}
function
convertToChromeUri
(
fileUri
)
{
let
baseUri
=
fileUri
.
spec
;
let
path
=
"
"
;
while
(
true
)
{
let
slashPos
=
baseUri
.
lastIndexOf
(
"
/
"
baseUri
.
length
-
2
)
;
if
(
slashPos
<
0
)
{
info
(
File
not
accessible
from
chrome
protocol
:
{
fileUri
.
path
}
)
;
return
fileUri
;
}
path
=
baseUri
.
slice
(
slashPos
+
1
)
+
path
;
baseUri
=
baseUri
.
slice
(
0
slashPos
+
1
)
;
if
(
gChromeMap
.
has
(
baseUri
)
)
{
let
chromeBaseUri
=
gChromeMap
.
get
(
baseUri
)
;
let
chromeUri
=
{
chromeBaseUri
}
{
path
}
;
return
Services
.
io
.
newURI
(
chromeUri
null
null
)
;
}
}
}
function
messageIsCSSError
(
msg
)
{
if
(
(
msg
instanceof
Ci
.
nsIScriptError
)
&
&
msg
.
category
.
includes
(
"
CSS
"
)
&
&
msg
.
sourceName
.
endsWith
(
kPathSuffix
)
)
{
let
sourceName
=
msg
.
sourceName
.
slice
(
0
-
kPathSuffix
.
length
)
;
let
msgInfo
=
{
sourceName
errorMessage
:
msg
.
errorMessage
}
;
if
(
!
ignoredError
(
msgInfo
)
)
{
ok
(
false
Got
error
message
for
{
sourceName
}
:
{
msg
.
errorMessage
}
)
;
return
true
;
}
info
(
Ignored
error
for
{
sourceName
}
because
of
filter
.
)
;
}
return
false
;
}
let
imageURIsToReferencesMap
=
new
Map
(
)
;
function
processCSSRules
(
sheet
)
{
for
(
let
rule
of
sheet
.
cssRules
)
{
if
(
rule
instanceof
CSSMediaRule
)
{
processCSSRules
(
rule
)
;
continue
;
}
if
(
!
(
rule
instanceof
CSSStyleRule
)
)
continue
;
let
urls
=
rule
.
cssText
.
match
(
/
url
\
(
"
[
^
"
]
*
"
\
)
/
g
)
;
if
(
!
urls
)
continue
;
for
(
let
url
of
urls
)
{
url
=
url
.
replace
(
/
url
\
(
"
(
.
*
)
"
\
)
/
"
1
"
)
;
if
(
url
.
startsWith
(
"
data
:
"
)
)
continue
;
let
baseURI
=
Services
.
io
.
newURI
(
rule
.
parentStyleSheet
.
href
null
null
)
;
url
=
Services
.
io
.
newURI
(
url
null
baseURI
)
.
specIgnoringRef
;
let
baseUrl
=
baseURI
.
spec
.
split
(
"
?
always
-
parse
-
css
"
)
[
0
]
;
if
(
!
imageURIsToReferencesMap
.
has
(
url
)
)
{
imageURIsToReferencesMap
.
set
(
url
new
Set
(
[
baseUrl
]
)
)
;
}
else
{
imageURIsToReferencesMap
.
get
(
url
)
.
add
(
baseUrl
)
;
}
}
}
}
function
chromeFileExists
(
aURI
)
{
let
available
=
0
;
try
{
let
channel
=
NetUtil
.
newChannel
(
{
uri
:
aURI
loadUsingSystemPrincipal
:
true
}
)
;
let
stream
=
channel
.
open
(
)
;
let
sstream
=
Cc
[
"
mozilla
.
org
/
scriptableinputstream
;
1
"
]
.
createInstance
(
Ci
.
nsIScriptableInputStream
)
;
sstream
.
init
(
stream
)
;
available
=
sstream
.
available
(
)
;
sstream
.
close
(
)
;
}
catch
(
e
)
{
if
(
e
.
result
!
=
Components
.
results
.
NS_ERROR_FILE_NOT_FOUND
)
{
dump
(
"
Checking
"
+
aURI
+
"
:
"
+
e
+
"
\
n
"
)
;
Cu
.
reportError
(
e
)
;
}
}
return
available
>
0
;
}
add_task
(
function
*
checkAllTheCSS
(
)
{
let
appDir
=
Services
.
dirsvc
.
get
(
"
XCurProcD
"
Ci
.
nsIFile
)
;
let
uris
=
yield
generateURIsFromDirTree
(
appDir
[
"
.
css
"
"
.
manifest
"
]
)
;
let
testFile
=
getRootDirectory
(
gTestPath
)
+
"
dummy_page
.
html
"
;
let
windowless
=
Services
.
appShell
.
createWindowlessBrowser
(
)
;
let
iframe
=
windowless
.
document
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
"
html
:
iframe
"
)
;
windowless
.
document
.
documentElement
.
appendChild
(
iframe
)
;
let
iframeLoaded
=
once
(
iframe
'
load
'
)
;
iframe
.
contentWindow
.
location
=
testFile
;
yield
iframeLoaded
;
let
doc
=
iframe
.
contentWindow
.
document
;
let
manifestPromises
=
[
]
;
uris
=
uris
.
filter
(
uri
=
>
{
if
(
uri
.
path
.
endsWith
(
"
.
manifest
"
)
)
{
manifestPromises
.
push
(
parseManifest
(
uri
)
)
;
return
false
;
}
return
true
;
}
)
;
yield
Promise
.
all
(
manifestPromises
)
;
let
allPromises
=
[
]
;
let
isDevtools
=
SimpleTest
.
harnessParameters
.
subsuite
=
=
"
devtools
"
;
let
devtoolsPathBits
=
[
"
webide
"
"
devtools
"
]
;
uris
=
uris
.
filter
(
uri
=
>
isDevtools
=
=
devtoolsPathBits
.
some
(
path
=
>
uri
.
spec
.
includes
(
path
)
)
)
;
for
(
let
uri
of
uris
)
{
let
linkEl
=
doc
.
createElement
(
"
link
"
)
;
linkEl
.
setAttribute
(
"
rel
"
"
stylesheet
"
)
;
let
promiseForThisSpec
=
Promise
.
defer
(
)
;
let
onLoad
=
(
e
)
=
>
{
processCSSRules
(
linkEl
.
sheet
)
;
promiseForThisSpec
.
resolve
(
)
;
linkEl
.
removeEventListener
(
"
load
"
onLoad
)
;
linkEl
.
removeEventListener
(
"
error
"
onError
)
;
}
;
let
onError
=
(
e
)
=
>
{
ok
(
false
"
Loading
"
+
linkEl
.
getAttribute
(
"
href
"
)
+
"
threw
an
error
!
"
)
;
promiseForThisSpec
.
resolve
(
)
;
linkEl
.
removeEventListener
(
"
load
"
onLoad
)
;
linkEl
.
removeEventListener
(
"
error
"
onError
)
;
}
;
linkEl
.
addEventListener
(
"
load
"
onLoad
)
;
linkEl
.
addEventListener
(
"
error
"
onError
)
;
linkEl
.
setAttribute
(
"
type
"
"
text
/
css
"
)
;
let
chromeUri
=
convertToChromeUri
(
uri
)
;
linkEl
.
setAttribute
(
"
href
"
chromeUri
.
spec
+
kPathSuffix
)
;
allPromises
.
push
(
promiseForThisSpec
.
promise
)
;
doc
.
head
.
appendChild
(
linkEl
)
;
}
yield
Promise
.
all
(
allPromises
)
;
for
(
let
[
image
references
]
of
imageURIsToReferencesMap
)
{
if
(
!
chromeFileExists
(
image
)
)
{
for
(
let
ref
of
references
)
{
let
ignored
=
false
;
for
(
let
item
of
allowedImageReferences
)
{
if
(
image
.
endsWith
(
item
.
file
)
&
&
ref
.
endsWith
(
item
.
from
)
&
&
isDevtools
=
=
item
.
isFromDevTools
&
&
(
!
item
.
platforms
|
|
item
.
platforms
.
includes
(
AppConstants
.
platform
)
)
)
{
item
.
used
=
true
;
ignored
=
true
;
break
;
}
}
if
(
!
ignored
)
ok
(
false
"
missing
"
+
image
+
"
referenced
from
"
+
ref
)
;
}
}
}
let
messages
=
Services
.
console
.
getMessageArray
(
)
;
let
errors
=
messages
.
filter
(
messageIsCSSError
)
;
is
(
errors
.
length
0
"
All
the
styles
(
"
+
allPromises
.
length
+
"
)
loaded
without
errors
.
"
)
;
for
(
let
item
of
whitelist
)
{
if
(
!
item
.
used
&
&
isDevtools
=
=
item
.
isFromDevTools
)
{
ok
(
false
"
Unused
whitelist
item
.
"
+
(
item
.
sourceName
?
"
sourceName
:
"
+
item
.
sourceName
:
"
"
)
+
(
item
.
errorMessage
?
"
errorMessage
:
"
+
item
.
errorMessage
:
"
"
)
)
;
}
}
for
(
let
item
of
allowedImageReferences
)
{
if
(
!
item
.
used
&
&
isDevtools
=
=
item
.
isFromDevTools
&
&
(
!
item
.
platforms
|
|
item
.
platforms
.
includes
(
AppConstants
.
platform
)
)
)
{
ok
(
false
"
Unused
file
whitelist
item
.
"
+
"
file
:
"
+
item
.
file
+
"
from
:
"
+
item
.
from
)
;
}
}
iframe
.
remove
(
)
;
doc
.
head
.
innerHTML
=
'
'
;
doc
=
null
;
iframe
=
null
;
windowless
.
close
(
)
;
windowless
=
null
;
imageURIsToReferencesMap
=
null
;
}
)
;
