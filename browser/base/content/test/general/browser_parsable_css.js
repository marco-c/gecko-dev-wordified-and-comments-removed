const
kWhitelist
=
[
{
sourceName
:
/
codemirror
\
.
css
/
i
}
{
sourceName
:
/
web
\
/
viewer
\
.
css
/
i
errorMessage
:
/
Unknown
pseudo
-
class
.
*
(
fullscreen
|
selection
)
/
i
}
{
sourceName
:
/
aboutaccounts
\
/
(
main
|
normalize
)
\
.
css
/
i
}
{
sourceName
:
/
loop
\
/
.
*
sdk
-
content
\
/
.
*
\
.
css
/
i
}
{
sourceName
:
/
loop
\
/
.
*
\
.
css
/
i
errorMessage
:
/
Unknown
pseudo
-
class
.
*
placeholder
/
i
}
{
sourceName
:
/
loop
\
/
.
*
shared
\
/
css
\
/
conversation
.
css
/
i
errorMessage
:
/
Error
in
parsing
value
for
'
display
'
/
i
}
{
sourceName
:
/
loop
\
/
.
*
shared
\
/
css
\
/
common
.
css
/
i
errorMessage
:
/
Unknown
property
'
user
-
select
'
/
i
}
{
sourceName
:
/
loop
\
/
.
*
css
\
/
panel
.
css
/
i
errorMessage
:
/
Expected
color
but
found
'
none
'
/
i
}
{
sourceName
:
/
highlighter
\
.
css
/
i
errorMessage
:
/
Unknown
pseudo
-
class
.
*
moz
-
native
-
anonymous
/
i
}
]
;
var
moduleLocation
=
gTestPath
.
replace
(
/
\
/
[
^
\
/
]
*
/
i
"
/
parsingTestHelpers
.
jsm
"
)
;
var
{
generateURIsFromDirTree
}
=
Cu
.
import
(
moduleLocation
{
}
)
;
function
ignoredError
(
aErrorObject
)
{
for
(
let
whitelistItem
of
kWhitelist
)
{
let
matches
=
true
;
for
(
let
prop
in
whitelistItem
)
{
if
(
!
whitelistItem
[
prop
]
.
test
(
aErrorObject
[
prop
]
|
|
"
"
)
)
{
matches
=
false
;
break
;
}
}
if
(
matches
)
{
return
true
;
}
}
return
false
;
}
function
once
(
target
name
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
cb
=
(
)
=
>
{
target
.
removeEventListener
(
name
cb
)
;
resolve
(
)
;
}
;
target
.
addEventListener
(
name
cb
)
;
}
)
;
}
function
messageIsCSSError
(
msg
innerWindowID
outerWindowID
)
{
if
(
(
msg
instanceof
Ci
.
nsIScriptError
)
&
&
msg
.
category
.
includes
(
"
CSS
"
)
&
&
msg
.
innerWindowID
=
=
=
innerWindowID
&
&
msg
.
outerWindowID
=
=
=
outerWindowID
)
{
if
(
!
ignoredError
(
msg
)
)
{
ok
(
false
"
Got
error
message
for
"
+
msg
.
sourceName
+
"
:
"
+
msg
.
errorMessage
)
;
return
true
;
}
info
(
"
Ignored
error
for
"
+
msg
.
sourceName
+
"
because
of
filter
.
"
)
;
}
return
false
;
}
add_task
(
function
checkAllTheCSS
(
)
{
let
appDir
=
Services
.
dirsvc
.
get
(
"
XCurProcD
"
Ci
.
nsIFile
)
;
let
uris
=
yield
generateURIsFromDirTree
(
appDir
"
.
css
"
)
;
let
resHandler
=
Services
.
io
.
getProtocolHandler
(
"
resource
"
)
.
QueryInterface
(
Ci
.
nsISubstitutingProtocolHandler
)
;
let
resURI
=
Services
.
io
.
newURI
(
'
resource
:
/
/
testing
-
common
/
resource_test_file
.
html
'
null
null
)
;
let
testFile
=
resHandler
.
resolveURI
(
resURI
)
;
let
windowless
=
Services
.
appShell
.
createWindowlessBrowser
(
)
;
let
iframe
=
windowless
.
document
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
"
html
:
iframe
"
)
;
windowless
.
document
.
documentElement
.
appendChild
(
iframe
)
;
let
iframeLoaded
=
once
(
iframe
'
load
'
)
;
iframe
.
contentWindow
.
location
=
testFile
;
yield
iframeLoaded
;
let
doc
=
iframe
.
contentWindow
.
document
;
let
windowUtils
=
iframe
.
contentWindow
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
let
innerWindowID
=
windowUtils
.
currentInnerWindowID
;
let
outerWindowID
=
windowUtils
.
outerWindowID
;
let
allPromises
=
[
]
;
for
(
let
uri
of
uris
)
{
let
linkEl
=
doc
.
createElement
(
"
link
"
)
;
linkEl
.
setAttribute
(
"
rel
"
"
stylesheet
"
)
;
let
promiseForThisSpec
=
Promise
.
defer
(
)
;
let
onLoad
=
(
e
)
=
>
{
promiseForThisSpec
.
resolve
(
)
;
linkEl
.
removeEventListener
(
"
load
"
onLoad
)
;
linkEl
.
removeEventListener
(
"
error
"
onError
)
;
}
;
let
onError
=
(
e
)
=
>
{
ok
(
false
"
Loading
"
+
linkEl
.
getAttribute
(
"
href
"
)
+
"
threw
an
error
!
"
)
;
promiseForThisSpec
.
resolve
(
)
;
linkEl
.
removeEventListener
(
"
load
"
onLoad
)
;
linkEl
.
removeEventListener
(
"
error
"
onError
)
;
}
;
linkEl
.
addEventListener
(
"
load
"
onLoad
)
;
linkEl
.
addEventListener
(
"
error
"
onError
)
;
linkEl
.
setAttribute
(
"
type
"
"
text
/
css
"
)
;
linkEl
.
setAttribute
(
"
href
"
uri
.
spec
)
;
allPromises
.
push
(
promiseForThisSpec
.
promise
)
;
doc
.
head
.
appendChild
(
linkEl
)
;
}
yield
Promise
.
all
(
allPromises
)
;
let
messages
=
Services
.
console
.
getMessageArray
(
)
;
let
errors
=
messages
.
filter
(
m
=
>
messageIsCSSError
(
m
innerWindowID
outerWindowID
)
)
;
is
(
errors
.
length
0
"
All
the
styles
(
"
+
allPromises
.
length
+
"
)
loaded
without
errors
.
"
)
;
iframe
.
remove
(
)
;
doc
.
head
.
innerHTML
=
'
'
;
doc
=
null
;
iframe
=
null
;
}
)
;
