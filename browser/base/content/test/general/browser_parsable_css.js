const
kWhitelist
=
[
{
sourceName
:
/
codemirror
\
.
css
/
i
}
{
sourceName
:
/
web
\
/
viewer
\
.
css
/
i
errorMessage
:
/
Unknown
pseudo
-
class
.
*
(
fullscreen
|
selection
)
/
i
}
{
sourceName
:
/
aboutaccounts
\
/
(
main
|
normalize
)
\
.
css
/
i
}
{
sourceName
:
/
loop
\
/
.
*
sdk
-
content
\
/
.
*
\
.
css
/
i
}
{
sourceName
:
/
loop
\
/
.
*
\
.
css
/
i
errorMessage
:
/
Unknown
pseudo
-
class
.
*
placeholder
/
i
}
{
sourceName
:
/
loop
\
/
.
*
shared
\
/
css
\
/
common
.
css
/
i
errorMessage
:
/
Unknown
property
'
user
-
select
'
/
i
}
{
sourceName
:
/
highlighters
\
.
css
/
i
errorMessage
:
/
Unknown
pseudo
-
class
.
*
moz
-
native
-
anonymous
/
i
}
]
;
var
moduleLocation
=
gTestPath
.
replace
(
/
\
/
[
^
\
/
]
*
/
i
"
/
parsingTestHelpers
.
jsm
"
)
;
var
{
generateURIsFromDirTree
}
=
Cu
.
import
(
moduleLocation
{
}
)
;
const
kPathSuffix
=
"
?
always
-
parse
-
css
-
"
+
Math
.
random
(
)
;
function
ignoredError
(
aErrorObject
)
{
for
(
let
whitelistItem
of
kWhitelist
)
{
let
matches
=
true
;
for
(
let
prop
in
whitelistItem
)
{
if
(
!
whitelistItem
[
prop
]
.
test
(
aErrorObject
[
prop
]
|
|
"
"
)
)
{
matches
=
false
;
break
;
}
}
if
(
matches
)
{
return
true
;
}
}
return
false
;
}
function
once
(
target
name
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
cb
=
(
)
=
>
{
target
.
removeEventListener
(
name
cb
)
;
resolve
(
)
;
}
;
target
.
addEventListener
(
name
cb
)
;
}
)
;
}
function
fetchFile
(
uri
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
xhr
=
new
XMLHttpRequest
(
)
;
xhr
.
open
(
"
GET
"
uri
true
)
;
xhr
.
onreadystatechange
=
function
(
)
{
if
(
this
.
readyState
!
=
this
.
DONE
)
{
return
;
}
try
{
resolve
(
this
.
responseText
)
;
}
catch
(
ex
)
{
ok
(
false
Script
error
reading
{
uri
}
:
{
ex
}
)
;
resolve
(
"
"
)
;
}
}
;
xhr
.
onerror
=
error
=
>
{
ok
(
false
XHR
error
reading
{
uri
}
:
{
error
}
)
;
resolve
(
"
"
)
;
}
;
xhr
.
send
(
null
)
;
}
)
;
}
var
gChromeReg
=
Cc
[
"
mozilla
.
org
/
chrome
/
chrome
-
registry
;
1
"
]
.
getService
(
Ci
.
nsIChromeRegistry
)
;
var
gChromeMap
=
new
Map
(
)
;
function
getBaseUriForChromeUri
(
chromeUri
)
{
let
chromeFile
=
chromeUri
+
"
gobbledygooknonexistentfile
.
reallynothere
"
;
let
uri
=
Services
.
io
.
newURI
(
chromeFile
null
null
)
;
let
fileUri
=
gChromeReg
.
convertChromeURL
(
uri
)
;
return
fileUri
.
resolve
(
"
.
"
)
;
}
function
parseManifest
(
manifestUri
)
{
return
fetchFile
(
manifestUri
.
spec
)
.
then
(
data
=
>
{
for
(
let
line
of
data
.
split
(
'
\
n
'
)
)
{
let
[
type
.
.
.
argv
]
=
line
.
split
(
/
\
s
+
/
)
;
let
component
;
if
(
type
=
=
"
content
"
|
|
type
=
=
"
skin
"
)
{
[
component
]
=
argv
;
}
else
{
continue
;
}
let
chromeUri
=
chrome
:
/
/
{
component
}
/
{
type
}
/
;
gChromeMap
.
set
(
getBaseUriForChromeUri
(
chromeUri
)
chromeUri
)
;
}
}
)
;
}
function
convertToChromeUri
(
fileUri
)
{
let
baseUri
=
fileUri
.
spec
;
let
path
=
"
"
;
while
(
true
)
{
let
slashPos
=
baseUri
.
lastIndexOf
(
"
/
"
baseUri
.
length
-
2
)
;
if
(
slashPos
<
0
)
{
info
(
File
not
accessible
from
chrome
protocol
:
{
fileUri
.
path
}
)
;
return
fileUri
;
}
path
=
baseUri
.
slice
(
slashPos
+
1
)
+
path
;
baseUri
=
baseUri
.
slice
(
0
slashPos
+
1
)
;
if
(
gChromeMap
.
has
(
baseUri
)
)
{
let
chromeBaseUri
=
gChromeMap
.
get
(
baseUri
)
;
let
chromeUri
=
{
chromeBaseUri
}
{
path
}
;
return
Services
.
io
.
newURI
(
chromeUri
null
null
)
;
}
}
}
function
messageIsCSSError
(
msg
)
{
if
(
(
msg
instanceof
Ci
.
nsIScriptError
)
&
&
msg
.
category
.
includes
(
"
CSS
"
)
&
&
msg
.
sourceName
.
endsWith
(
kPathSuffix
)
)
{
let
sourceName
=
msg
.
sourceName
.
slice
(
0
-
kPathSuffix
.
length
)
;
let
msgInfo
=
{
sourceName
errorMessage
:
msg
.
errorMessage
}
;
if
(
!
ignoredError
(
msgInfo
)
)
{
ok
(
false
Got
error
message
for
{
sourceName
}
:
{
msg
.
errorMessage
}
)
;
return
true
;
}
info
(
Ignored
error
for
{
sourceName
}
because
of
filter
.
)
;
}
return
false
;
}
add_task
(
function
*
checkAllTheCSS
(
)
{
let
appDir
=
Services
.
dirsvc
.
get
(
"
XCurProcD
"
Ci
.
nsIFile
)
;
let
uris
=
yield
generateURIsFromDirTree
(
appDir
[
"
.
css
"
"
.
manifest
"
]
)
;
let
testFile
=
getRootDirectory
(
gTestPath
)
+
"
dummy_page
.
html
"
;
let
windowless
=
Services
.
appShell
.
createWindowlessBrowser
(
)
;
let
iframe
=
windowless
.
document
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
"
html
:
iframe
"
)
;
windowless
.
document
.
documentElement
.
appendChild
(
iframe
)
;
let
iframeLoaded
=
once
(
iframe
'
load
'
)
;
iframe
.
contentWindow
.
location
=
testFile
;
yield
iframeLoaded
;
let
doc
=
iframe
.
contentWindow
.
document
;
let
manifestPromises
=
[
]
;
uris
=
uris
.
filter
(
uri
=
>
{
if
(
uri
.
path
.
endsWith
(
"
.
manifest
"
)
)
{
manifestPromises
.
push
(
parseManifest
(
uri
)
)
;
return
false
;
}
return
true
;
}
)
;
yield
Promise
.
all
(
manifestPromises
)
;
let
allPromises
=
[
]
;
let
isDevtools
=
SimpleTest
.
harnessParameters
.
subsuite
=
=
"
devtools
"
;
let
devtoolsPathBits
=
[
"
webide
"
"
devtools
"
]
;
uris
=
uris
.
filter
(
uri
=
>
isDevtools
=
=
devtoolsPathBits
.
some
(
path
=
>
uri
.
spec
.
includes
(
path
)
)
)
;
for
(
let
uri
of
uris
)
{
let
linkEl
=
doc
.
createElement
(
"
link
"
)
;
linkEl
.
setAttribute
(
"
rel
"
"
stylesheet
"
)
;
let
promiseForThisSpec
=
Promise
.
defer
(
)
;
let
onLoad
=
(
e
)
=
>
{
promiseForThisSpec
.
resolve
(
)
;
linkEl
.
removeEventListener
(
"
load
"
onLoad
)
;
linkEl
.
removeEventListener
(
"
error
"
onError
)
;
}
;
let
onError
=
(
e
)
=
>
{
ok
(
false
"
Loading
"
+
linkEl
.
getAttribute
(
"
href
"
)
+
"
threw
an
error
!
"
)
;
promiseForThisSpec
.
resolve
(
)
;
linkEl
.
removeEventListener
(
"
load
"
onLoad
)
;
linkEl
.
removeEventListener
(
"
error
"
onError
)
;
}
;
linkEl
.
addEventListener
(
"
load
"
onLoad
)
;
linkEl
.
addEventListener
(
"
error
"
onError
)
;
linkEl
.
setAttribute
(
"
type
"
"
text
/
css
"
)
;
let
chromeUri
=
convertToChromeUri
(
uri
)
;
linkEl
.
setAttribute
(
"
href
"
chromeUri
.
spec
+
kPathSuffix
)
;
allPromises
.
push
(
promiseForThisSpec
.
promise
)
;
doc
.
head
.
appendChild
(
linkEl
)
;
}
yield
Promise
.
all
(
allPromises
)
;
let
messages
=
Services
.
console
.
getMessageArray
(
)
;
let
errors
=
messages
.
filter
(
messageIsCSSError
)
;
is
(
errors
.
length
0
"
All
the
styles
(
"
+
allPromises
.
length
+
"
)
loaded
without
errors
.
"
)
;
iframe
.
remove
(
)
;
doc
.
head
.
innerHTML
=
'
'
;
doc
=
null
;
iframe
=
null
;
windowless
.
close
(
)
;
windowless
=
null
;
}
)
;
