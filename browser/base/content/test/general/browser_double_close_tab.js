"
use
strict
"
;
const
TEST_PAGE
=
"
http
:
/
/
mochi
.
test
:
8888
/
browser
/
browser
/
base
/
content
/
test
/
general
/
file_double_close_tab
.
html
"
;
var
testTab
;
function
waitForDialog
(
callback
)
{
function
onDialogLoaded
(
nodeOrDialogWindow
)
{
let
node
=
nodeOrDialogWindow
.
document
.
querySelector
(
"
dialog
"
)
;
Services
.
obs
.
removeObserver
(
onDialogLoaded
"
common
-
dialog
-
loaded
"
)
;
Promise
.
resolve
(
)
.
then
(
(
)
=
>
callback
(
node
)
)
;
}
Services
.
obs
.
addObserver
(
onDialogLoaded
"
common
-
dialog
-
loaded
"
)
;
}
function
waitForDialogDestroyed
(
node
callback
)
{
let
observer
=
new
MutationObserver
(
function
(
)
{
if
(
!
node
.
parentNode
)
{
ok
(
true
"
Dialog
is
gone
"
)
;
done
(
)
;
}
}
)
;
observer
.
observe
(
node
.
parentNode
{
childList
:
true
}
)
;
node
.
ownerGlobal
.
addEventListener
(
"
unload
"
done
)
;
let
failureTimeout
=
setTimeout
(
function
(
)
{
ok
(
false
"
Dialog
should
have
been
destroyed
"
)
;
done
(
)
;
}
10000
)
;
function
done
(
)
{
clearTimeout
(
failureTimeout
)
;
observer
.
disconnect
(
)
;
observer
=
null
;
node
.
ownerGlobal
.
removeEventListener
(
"
unload
"
done
)
;
SimpleTest
.
executeSoon
(
callback
)
;
}
}
add_task
(
async
function
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
dom
.
require_user_interaction_for_beforeunload
"
false
]
]
}
)
;
testTab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
TEST_PAGE
)
;
await
new
Promise
(
resolveOuter
=
>
{
waitForDialog
(
dialogNode
=
>
{
waitForDialogDestroyed
(
dialogNode
(
)
=
>
{
let
doCompletion
=
(
)
=
>
setTimeout
(
resolveOuter
0
)
;
info
(
"
Now
checking
if
dialog
is
destroyed
"
)
;
ok
(
!
dialogNode
.
ownerGlobal
|
|
dialogNode
.
ownerGlobal
.
closed
"
onbeforeunload
dialog
should
be
gone
.
"
)
;
if
(
dialogNode
.
ownerGlobal
&
&
!
dialogNode
.
ownerGlobal
.
closed
)
{
dialogNode
.
acceptDialog
(
)
;
}
doCompletion
(
)
;
}
)
;
testTab
.
closeButton
.
click
(
)
;
}
)
;
testTab
.
closeButton
.
click
(
)
;
}
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
!
testTab
.
parentNode
)
;
ok
(
!
testTab
.
parentNode
"
Tab
should
be
closed
completely
"
)
;
}
)
;
registerCleanupFunction
(
async
function
(
)
{
if
(
testTab
.
parentNode
)
{
try
{
await
SpecialPowers
.
spawn
(
testTab
.
linkedBrowser
[
]
function
(
)
{
content
.
window
.
onbeforeunload
=
null
;
}
)
;
}
catch
(
ex
)
{
}
gBrowser
.
removeTab
(
testTab
)
;
}
}
)
;
