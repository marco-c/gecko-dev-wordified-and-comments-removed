"
use
strict
"
;
let
Preferences
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
{
}
)
.
Preferences
;
let
TelemetryReportingPolicy
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryReportingPolicy
.
jsm
"
{
}
)
.
TelemetryReportingPolicy
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gDatareportingService
"
(
)
=
>
Cc
[
"
mozilla
.
org
/
datareporting
/
service
;
1
"
]
.
getService
(
Ci
.
nsISupports
)
.
wrappedJSObject
)
;
const
PREF_BRANCH
=
"
datareporting
.
policy
.
"
;
const
PREF_DRS_ENABLED
=
"
datareporting
.
healthreport
.
service
.
enabled
"
;
const
PREF_BYPASS_NOTIFICATION
=
PREF_BRANCH
+
"
dataSubmissionPolicyBypassNotification
"
;
const
PREF_CURRENT_POLICY_VERSION
=
PREF_BRANCH
+
"
currentPolicyVersion
"
;
const
PREF_ACCEPTED_POLICY_VERSION
=
PREF_BRANCH
+
"
dataSubmissionPolicyAcceptedVersion
"
;
const
PREF_ACCEPTED_POLICY_DATE
=
PREF_BRANCH
+
"
dataSubmissionPolicyNotifiedTime
"
;
const
TEST_POLICY_VERSION
=
37
;
function
fakeShowPolicyTimeout
(
set
clear
)
{
let
reportingPolicy
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryReportingPolicy
.
jsm
"
{
}
)
.
Policy
;
reportingPolicy
.
setShowInfobarTimeout
=
set
;
reportingPolicy
.
clearShowInfobarTimeout
=
clear
;
}
function
sendSessionRestoredNotification
(
)
{
let
reportingPolicyImpl
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryReportingPolicy
.
jsm
"
{
}
)
.
TelemetryReportingPolicyImpl
;
reportingPolicyImpl
.
observe
(
null
"
sessionstore
-
windows
-
restored
"
null
)
;
}
function
promiseNextTick
(
)
{
return
new
Promise
(
resolve
=
>
executeSoon
(
resolve
)
)
;
}
function
promiseWaitForAlertActive
(
aNotificationBox
)
{
let
deferred
=
PromiseUtils
.
defer
(
)
;
aNotificationBox
.
addEventListener
(
"
AlertActive
"
function
onActive
(
)
{
aNotificationBox
.
removeEventListener
(
"
AlertActive
"
onActive
true
)
;
deferred
.
resolve
(
)
;
}
)
;
return
deferred
.
promise
;
}
function
promiseWaitForNotificationClose
(
aNotification
)
{
let
deferred
=
PromiseUtils
.
defer
(
)
;
waitForNotificationClose
(
aNotification
deferred
.
resolve
)
;
return
deferred
.
promise
;
}
function
triggerInfoBar
(
expectedTimeoutMs
)
{
let
showInfobarCallback
=
null
;
let
timeoutMs
=
null
;
fakeShowPolicyTimeout
(
(
callback
timeout
)
=
>
{
showInfobarCallback
=
callback
;
timeoutMs
=
timeout
;
}
(
)
=
>
{
}
)
;
sendSessionRestoredNotification
(
)
;
Assert
.
ok
(
!
!
showInfobarCallback
"
Must
have
a
timer
callback
.
"
)
;
if
(
expectedTimeoutMs
!
=
=
undefined
)
{
Assert
.
equal
(
timeoutMs
expectedTimeoutMs
"
Timeout
should
match
"
)
;
}
showInfobarCallback
(
)
;
}
let
checkInfobarButton
=
Task
.
async
(
function
*
(
aNotification
)
{
let
buttons
=
aNotification
.
getElementsByTagName
(
"
button
"
)
;
Assert
.
equal
(
buttons
.
length
1
"
There
is
1
button
in
the
data
reporting
notification
.
"
)
;
let
button
=
buttons
[
0
]
;
let
paneLoadedPromise
=
promiseTopicObserved
(
"
advanced
-
pane
-
loaded
"
)
;
button
.
click
(
)
;
let
preferenceWindow
=
yield
paneLoadedPromise
;
yield
promiseNextTick
(
)
;
}
)
;
add_task
(
function
*
setup
(
)
{
const
drsEnabled
=
Preferences
.
get
(
PREF_DRS_ENABLED
true
)
;
const
bypassNotification
=
Preferences
.
get
(
PREF_BYPASS_NOTIFICATION
true
)
;
const
currentPolicyVersion
=
Preferences
.
get
(
PREF_CURRENT_POLICY_VERSION
1
)
;
registerCleanupFunction
(
(
)
=
>
{
Preferences
.
set
(
PREF_DRS_ENABLED
drsEnabled
)
;
Preferences
.
set
(
PREF_BYPASS_NOTIFICATION
bypassNotification
)
;
Preferences
.
set
(
PREF_CURRENT_POLICY_VERSION
currentPolicyVersion
)
;
gDatareportingService
.
policy
.
startPolling
(
)
;
return
closeAllNotifications
(
)
;
}
)
;
Preferences
.
set
(
PREF_DRS_ENABLED
false
)
;
Preferences
.
set
(
PREF_BYPASS_NOTIFICATION
false
)
;
Preferences
.
set
(
PREF_CURRENT_POLICY_VERSION
TEST_POLICY_VERSION
)
;
gDatareportingService
.
policy
.
stopPolling
(
)
;
}
)
;
function
clearAcceptedPolicy
(
)
{
Preferences
.
reset
(
PREF_ACCEPTED_POLICY_VERSION
)
;
Preferences
.
reset
(
PREF_ACCEPTED_POLICY_DATE
)
;
}
add_task
(
function
*
test_single_window
(
)
{
clearAcceptedPolicy
(
)
;
yield
closeAllNotifications
(
)
;
let
notificationBox
=
document
.
getElementById
(
"
global
-
notificationbox
"
)
;
Assert
.
equal
(
Preferences
.
get
(
PREF_ACCEPTED_POLICY_VERSION
0
)
0
"
No
version
should
be
set
on
init
.
"
)
;
Assert
.
equal
(
Preferences
.
get
(
PREF_ACCEPTED_POLICY_DATE
0
)
0
"
No
date
should
be
set
on
init
.
"
)
;
Assert
.
ok
(
!
TelemetryReportingPolicy
.
testIsUserNotified
(
)
"
User
not
notified
about
datareporting
policy
.
"
)
;
let
alertShownPromise
=
promiseWaitForAlertActive
(
notificationBox
)
;
Assert
.
ok
(
!
TelemetryReportingPolicy
.
canUpload
(
)
"
User
should
not
be
allowed
to
upload
.
"
)
;
triggerInfoBar
(
10
*
1000
)
;
yield
alertShownPromise
;
Assert
.
equal
(
notificationBox
.
allNotifications
.
length
1
"
Notification
Displayed
.
"
)
;
Assert
.
ok
(
TelemetryReportingPolicy
.
canUpload
(
)
"
User
should
be
allowed
to
upload
now
.
"
)
;
yield
promiseNextTick
(
)
;
let
promiseClosed
=
promiseWaitForNotificationClose
(
notificationBox
.
currentNotification
)
;
yield
checkInfobarButton
(
notificationBox
.
currentNotification
)
;
yield
promiseClosed
;
Assert
.
equal
(
notificationBox
.
allNotifications
.
length
0
"
No
notifications
remain
.
"
)
;
Assert
.
ok
(
TelemetryReportingPolicy
.
canUpload
(
)
)
;
Assert
.
equal
(
TelemetryReportingPolicy
.
testIsUserNotified
(
)
true
"
User
notified
about
datareporting
policy
.
"
)
;
Assert
.
equal
(
Preferences
.
get
(
PREF_ACCEPTED_POLICY_VERSION
0
)
TEST_POLICY_VERSION
"
Version
pref
set
.
"
)
;
Assert
.
greater
(
parseInt
(
Preferences
.
get
(
PREF_ACCEPTED_POLICY_DATE
null
)
10
)
-
1
"
Date
pref
set
.
"
)
;
}
)
;
add_task
(
function
*
test_multiple_windows
(
)
{
clearAcceptedPolicy
(
)
;
yield
closeAllNotifications
(
)
;
let
otherWindow
=
yield
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
let
notificationBoxes
=
[
document
.
getElementById
(
"
global
-
notificationbox
"
)
otherWindow
.
document
.
getElementById
(
"
global
-
notificationbox
"
)
]
;
Assert
.
ok
(
notificationBoxes
[
1
]
"
2nd
window
has
a
global
notification
box
.
"
)
;
Assert
.
equal
(
Preferences
.
get
(
PREF_ACCEPTED_POLICY_VERSION
0
)
0
"
No
version
should
be
set
on
init
.
"
)
;
Assert
.
equal
(
Preferences
.
get
(
PREF_ACCEPTED_POLICY_DATE
0
)
0
"
No
date
should
be
set
on
init
.
"
)
;
Assert
.
ok
(
!
TelemetryReportingPolicy
.
testIsUserNotified
(
)
"
User
not
notified
about
datareporting
policy
.
"
)
;
let
showAlertPromises
=
[
promiseWaitForAlertActive
(
notificationBoxes
[
0
]
)
promiseWaitForAlertActive
(
notificationBoxes
[
1
]
)
]
;
Assert
.
ok
(
!
TelemetryReportingPolicy
.
canUpload
(
)
"
User
should
not
be
allowed
to
upload
.
"
)
;
triggerInfoBar
(
10
*
1000
)
;
yield
Promise
.
all
(
showAlertPromises
)
;
let
closeAlertPromises
=
[
promiseWaitForNotificationClose
(
notificationBoxes
[
0
]
.
currentNotification
)
promiseWaitForNotificationClose
(
notificationBoxes
[
1
]
.
currentNotification
)
]
;
notificationBoxes
[
0
]
.
currentNotification
.
close
(
)
;
yield
Promise
.
all
(
closeAlertPromises
)
;
yield
BrowserTestUtils
.
closeWindow
(
otherWindow
)
;
Assert
.
ok
(
TelemetryReportingPolicy
.
canUpload
(
)
"
User
should
be
allowed
to
upload
now
.
"
)
;
Assert
.
equal
(
TelemetryReportingPolicy
.
testIsUserNotified
(
)
true
"
User
notified
about
datareporting
policy
.
"
)
;
Assert
.
equal
(
Preferences
.
get
(
PREF_ACCEPTED_POLICY_VERSION
0
)
TEST_POLICY_VERSION
"
Version
pref
set
.
"
)
;
Assert
.
greater
(
parseInt
(
Preferences
.
get
(
PREF_ACCEPTED_POLICY_DATE
null
)
10
)
-
1
"
Date
pref
set
.
"
)
;
}
)
;
