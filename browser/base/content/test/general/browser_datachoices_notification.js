"
use
strict
"
;
var
{
Preferences
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
)
;
var
{
TelemetryReportingPolicy
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryReportingPolicy
.
jsm
"
)
;
const
PREF_BRANCH
=
"
datareporting
.
policy
.
"
;
const
PREF_FIRST_RUN
=
"
toolkit
.
telemetry
.
reportingpolicy
.
firstRun
"
;
const
PREF_BYPASS_NOTIFICATION
=
PREF_BRANCH
+
"
dataSubmissionPolicyBypassNotification
"
;
const
PREF_CURRENT_POLICY_VERSION
=
PREF_BRANCH
+
"
currentPolicyVersion
"
;
const
PREF_ACCEPTED_POLICY_VERSION
=
PREF_BRANCH
+
"
dataSubmissionPolicyAcceptedVersion
"
;
const
PREF_ACCEPTED_POLICY_DATE
=
PREF_BRANCH
+
"
dataSubmissionPolicyNotifiedTime
"
;
const
PREF_TELEMETRY_LOG_LEVEL
=
"
toolkit
.
telemetry
.
log
.
level
"
;
const
TEST_POLICY_VERSION
=
37
;
function
fakeShowPolicyTimeout
(
set
clear
)
{
let
reportingPolicy
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryReportingPolicy
.
jsm
"
)
.
Policy
;
reportingPolicy
.
setShowInfobarTimeout
=
set
;
reportingPolicy
.
clearShowInfobarTimeout
=
clear
;
}
function
sendSessionRestoredNotification
(
)
{
let
reportingPolicy
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryReportingPolicy
.
jsm
"
)
.
Policy
;
reportingPolicy
.
fakeSessionRestoreNotification
(
)
;
}
function
promiseNextTick
(
)
{
return
new
Promise
(
resolve
=
>
executeSoon
(
resolve
)
)
;
}
function
promiseWaitForAlertActive
(
aNotificationBox
)
{
let
deferred
=
PromiseUtils
.
defer
(
)
;
aNotificationBox
.
stack
.
addEventListener
(
"
AlertActive
"
function
(
)
{
deferred
.
resolve
(
)
;
}
{
once
:
true
}
)
;
return
deferred
.
promise
;
}
function
promiseWaitForNotificationClose
(
aNotification
)
{
let
deferred
=
PromiseUtils
.
defer
(
)
;
waitForNotificationClose
(
aNotification
deferred
.
resolve
)
;
return
deferred
.
promise
;
}
function
triggerInfoBar
(
expectedTimeoutMs
)
{
let
showInfobarCallback
=
null
;
let
timeoutMs
=
null
;
fakeShowPolicyTimeout
(
(
callback
timeout
)
=
>
{
showInfobarCallback
=
callback
;
timeoutMs
=
timeout
;
}
(
)
=
>
{
}
)
;
sendSessionRestoredNotification
(
)
;
Assert
.
ok
(
!
!
showInfobarCallback
"
Must
have
a
timer
callback
.
"
)
;
if
(
expectedTimeoutMs
!
=
=
undefined
)
{
Assert
.
equal
(
timeoutMs
expectedTimeoutMs
"
Timeout
should
match
"
)
;
}
showInfobarCallback
(
)
;
}
var
checkInfobarButton
=
async
function
(
aNotification
)
{
let
buttons
=
aNotification
.
buttonContainer
.
getElementsByTagName
(
"
button
"
)
;
Assert
.
equal
(
buttons
.
length
1
"
There
is
1
button
in
the
data
reporting
notification
.
"
)
;
let
button
=
buttons
[
0
]
;
button
.
click
(
)
;
await
promiseNextTick
(
)
;
}
;
add_task
(
async
function
setup
(
)
{
const
isFirstRun
=
Preferences
.
get
(
PREF_FIRST_RUN
true
)
;
const
bypassNotification
=
Preferences
.
get
(
PREF_BYPASS_NOTIFICATION
true
)
;
const
currentPolicyVersion
=
Preferences
.
get
(
PREF_CURRENT_POLICY_VERSION
1
)
;
registerCleanupFunction
(
(
)
=
>
{
Preferences
.
set
(
PREF_FIRST_RUN
isFirstRun
)
;
Preferences
.
set
(
PREF_BYPASS_NOTIFICATION
bypassNotification
)
;
Preferences
.
set
(
PREF_CURRENT_POLICY_VERSION
currentPolicyVersion
)
;
Preferences
.
reset
(
PREF_TELEMETRY_LOG_LEVEL
)
;
return
closeAllNotifications
(
)
;
}
)
;
Preferences
.
set
(
PREF_BYPASS_NOTIFICATION
false
)
;
Preferences
.
set
(
PREF_CURRENT_POLICY_VERSION
TEST_POLICY_VERSION
)
;
Preferences
.
set
(
PREF_FIRST_RUN
false
)
;
TelemetryReportingPolicy
.
testUpdateFirstRun
(
)
;
}
)
;
function
clearAcceptedPolicy
(
)
{
Preferences
.
reset
(
PREF_ACCEPTED_POLICY_VERSION
)
;
Preferences
.
reset
(
PREF_ACCEPTED_POLICY_DATE
)
;
}
function
assertCoherentInitialState
(
)
{
Assert
.
equal
(
Preferences
.
get
(
PREF_ACCEPTED_POLICY_VERSION
0
)
0
"
No
version
should
be
set
on
init
.
"
)
;
Assert
.
equal
(
Preferences
.
get
(
PREF_ACCEPTED_POLICY_DATE
0
)
0
"
No
date
should
be
set
on
init
.
"
)
;
Assert
.
ok
(
!
TelemetryReportingPolicy
.
testIsUserNotified
(
)
"
User
not
notified
about
datareporting
policy
.
"
)
;
}
add_task
(
async
function
test_single_window
(
)
{
clearAcceptedPolicy
(
)
;
await
closeAllNotifications
(
)
;
assertCoherentInitialState
(
)
;
let
alertShownPromise
=
promiseWaitForAlertActive
(
gNotificationBox
)
;
Assert
.
ok
(
!
TelemetryReportingPolicy
.
canUpload
(
)
"
User
should
not
be
allowed
to
upload
.
"
)
;
triggerInfoBar
(
10
*
1000
)
;
await
alertShownPromise
;
Assert
.
equal
(
gNotificationBox
.
allNotifications
.
length
1
"
Notification
Displayed
.
"
)
;
Assert
.
ok
(
TelemetryReportingPolicy
.
canUpload
(
)
"
User
should
be
allowed
to
upload
now
.
"
)
;
await
promiseNextTick
(
)
;
let
promiseClosed
=
promiseWaitForNotificationClose
(
gNotificationBox
.
currentNotification
)
;
await
checkInfobarButton
(
gNotificationBox
.
currentNotification
)
;
await
promiseClosed
;
Assert
.
equal
(
gNotificationBox
.
allNotifications
.
length
0
"
No
notifications
remain
.
"
)
;
Assert
.
ok
(
TelemetryReportingPolicy
.
canUpload
(
)
)
;
Assert
.
equal
(
TelemetryReportingPolicy
.
testIsUserNotified
(
)
true
"
User
notified
about
datareporting
policy
.
"
)
;
Assert
.
equal
(
Preferences
.
get
(
PREF_ACCEPTED_POLICY_VERSION
0
)
TEST_POLICY_VERSION
"
Version
pref
set
.
"
)
;
Assert
.
greater
(
parseInt
(
Preferences
.
get
(
PREF_ACCEPTED_POLICY_DATE
null
)
10
)
-
1
"
Date
pref
set
.
"
)
;
}
)
;
