ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
this
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PlacesUtils
"
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PlacesTestUtils
"
"
resource
:
/
/
testing
-
common
/
PlacesTestUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
BrowserTestUtils
"
"
resource
:
/
/
testing
-
common
/
BrowserTestUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
TabCrashHandler
"
"
resource
:
/
/
/
modules
/
ContentCrashHandlers
.
jsm
"
)
;
function
waitForNotificationClose
(
notification
cb
)
{
let
observer
=
new
MutationObserver
(
function
onMutatations
(
mutations
)
{
for
(
let
mutation
of
mutations
)
{
for
(
let
i
=
0
;
i
<
mutation
.
removedNodes
.
length
;
i
+
+
)
{
let
node
=
mutation
.
removedNodes
.
item
(
i
)
;
if
(
node
!
=
notification
)
{
continue
;
}
observer
.
disconnect
(
)
;
cb
(
)
;
}
}
}
)
;
observer
.
observe
(
notification
.
control
.
stack
{
childList
:
true
}
)
;
}
function
closeAllNotifications
(
)
{
if
(
!
gNotificationBox
.
currentNotification
)
{
return
Promise
.
resolve
(
)
;
}
return
new
Promise
(
resolve
=
>
{
for
(
let
notification
of
gNotificationBox
.
allNotifications
)
{
waitForNotificationClose
(
notification
function
(
)
{
if
(
gNotificationBox
.
allNotifications
.
length
=
=
=
0
)
{
resolve
(
)
;
}
}
)
;
notification
.
close
(
)
;
}
}
)
;
}
function
whenDelayedStartupFinished
(
aWindow
aCallback
)
{
Services
.
obs
.
addObserver
(
function
observer
(
aSubject
aTopic
)
{
if
(
aWindow
=
=
aSubject
)
{
Services
.
obs
.
removeObserver
(
observer
aTopic
)
;
executeSoon
(
aCallback
)
;
}
}
"
browser
-
delayed
-
startup
-
finished
"
)
;
}
function
openToolbarCustomizationUI
(
aCallback
aBrowserWin
)
{
if
(
!
aBrowserWin
)
{
aBrowserWin
=
window
;
}
aBrowserWin
.
gCustomizeMode
.
enter
(
)
;
aBrowserWin
.
gNavToolbox
.
addEventListener
(
"
customizationready
"
function
(
)
{
executeSoon
(
function
(
)
{
aCallback
(
aBrowserWin
)
;
}
)
;
}
{
once
:
true
}
)
;
}
function
closeToolbarCustomizationUI
(
aCallback
aBrowserWin
)
{
aBrowserWin
.
gNavToolbox
.
addEventListener
(
"
aftercustomization
"
function
(
)
{
executeSoon
(
aCallback
)
;
}
{
once
:
true
}
)
;
aBrowserWin
.
gCustomizeMode
.
exit
(
)
;
}
function
waitForCondition
(
condition
nextTest
errorMsg
retryTimes
)
{
retryTimes
=
typeof
retryTimes
!
=
=
"
undefined
"
?
retryTimes
:
30
;
var
tries
=
0
;
var
interval
=
setInterval
(
function
(
)
{
if
(
tries
>
=
retryTimes
)
{
ok
(
false
errorMsg
)
;
moveOn
(
)
;
}
var
conditionPassed
;
try
{
conditionPassed
=
condition
(
)
;
}
catch
(
e
)
{
ok
(
false
e
+
"
\
n
"
+
e
.
stack
)
;
conditionPassed
=
false
;
}
if
(
conditionPassed
)
{
moveOn
(
)
;
}
tries
+
+
;
}
100
)
;
var
moveOn
=
function
(
)
{
clearInterval
(
interval
)
;
nextTest
(
)
;
}
;
}
function
promiseWaitForCondition
(
aConditionFn
)
{
return
new
Promise
(
resolve
=
>
{
waitForCondition
(
aConditionFn
resolve
"
Condition
didn
'
t
pass
.
"
)
;
}
)
;
}
function
promiseWaitForEvent
(
object
eventName
capturing
=
false
chrome
=
false
)
{
return
new
Promise
(
resolve
=
>
{
function
listener
(
event
)
{
info
(
"
Saw
"
+
eventName
)
;
object
.
removeEventListener
(
eventName
listener
capturing
chrome
)
;
resolve
(
event
)
;
}
info
(
"
Waiting
for
"
+
eventName
)
;
object
.
addEventListener
(
eventName
listener
capturing
chrome
)
;
}
)
;
}
function
promiseWaitForFocus
(
aWindow
)
{
return
new
Promise
(
resolve
=
>
{
waitForFocus
(
resolve
aWindow
)
;
}
)
;
}
function
getTestPlugin
(
aName
)
{
var
pluginName
=
aName
|
|
"
Test
Plug
-
in
"
;
var
ph
=
Cc
[
"
mozilla
.
org
/
plugin
/
host
;
1
"
]
.
getService
(
Ci
.
nsIPluginHost
)
;
var
tags
=
ph
.
getPluginTags
(
)
;
for
(
var
i
=
0
;
i
<
tags
.
length
;
i
+
+
)
{
if
(
tags
[
i
]
.
name
=
=
pluginName
)
{
return
tags
[
i
]
;
}
}
ok
(
false
"
Unable
to
find
plugin
"
)
;
return
null
;
}
function
setTestPluginEnabledState
(
newEnabledState
pluginName
)
{
var
plugin
=
getTestPlugin
(
pluginName
)
;
var
oldEnabledState
=
plugin
.
enabledState
;
plugin
.
enabledState
=
newEnabledState
;
SimpleTest
.
registerCleanupFunction
(
function
(
)
{
getTestPlugin
(
pluginName
)
.
enabledState
=
oldEnabledState
;
}
)
;
}
function
pushPrefs
(
.
.
.
aPrefs
)
{
return
SpecialPowers
.
pushPrefEnv
(
{
set
:
aPrefs
}
)
;
}
function
popPrefs
(
)
{
return
SpecialPowers
.
popPrefEnv
(
)
;
}
function
updateBlocklist
(
aCallback
)
{
var
blocklistNotifier
=
Cc
[
"
mozilla
.
org
/
extensions
/
blocklist
;
1
"
]
.
getService
(
Ci
.
nsITimerCallback
)
;
var
observer
=
function
(
)
{
Services
.
obs
.
removeObserver
(
observer
"
blocklist
-
updated
"
)
;
SimpleTest
.
executeSoon
(
aCallback
)
;
}
;
Services
.
obs
.
addObserver
(
observer
"
blocklist
-
updated
"
)
;
blocklistNotifier
.
notify
(
null
)
;
}
var
_originalTestBlocklistURL
=
null
;
function
setAndUpdateBlocklist
(
aURL
aCallback
)
{
if
(
!
_originalTestBlocklistURL
)
{
_originalTestBlocklistURL
=
Services
.
prefs
.
getCharPref
(
"
extensions
.
blocklist
.
url
"
)
;
}
Services
.
prefs
.
setCharPref
(
"
extensions
.
blocklist
.
url
"
aURL
)
;
updateBlocklist
(
aCallback
)
;
}
function
resetBlocklist
(
)
{
Services
.
prefs
.
setCharPref
(
"
extensions
.
blocklist
.
url
"
_originalTestBlocklistURL
)
;
}
function
promiseWindowClosed
(
win
)
{
let
promise
=
BrowserTestUtils
.
domWindowClosed
(
win
)
;
win
.
close
(
)
;
return
promise
;
}
function
promiseOpenAndLoadWindow
(
aOptions
aWaitForDelayedStartup
=
false
)
{
return
new
Promise
(
resolve
=
>
{
let
win
=
OpenBrowserWindow
(
aOptions
)
;
if
(
aWaitForDelayedStartup
)
{
Services
.
obs
.
addObserver
(
function
onDS
(
aSubject
aTopic
aData
)
{
if
(
aSubject
!
=
win
)
{
return
;
}
Services
.
obs
.
removeObserver
(
onDS
"
browser
-
delayed
-
startup
-
finished
"
)
;
resolve
(
win
)
;
}
"
browser
-
delayed
-
startup
-
finished
"
)
;
}
else
{
win
.
addEventListener
(
"
load
"
function
(
)
{
resolve
(
win
)
;
}
{
once
:
true
}
)
;
}
}
)
;
}
async
function
whenNewTabLoaded
(
aWindow
aCallback
)
{
aWindow
.
BrowserOpenTab
(
)
;
let
expectedURL
=
aboutNewTabService
.
newTabURL
;
let
browser
=
aWindow
.
gBrowser
.
selectedBrowser
;
let
loadPromise
=
BrowserTestUtils
.
browserLoaded
(
browser
false
expectedURL
)
;
let
alreadyLoaded
=
await
ContentTask
.
spawn
(
browser
expectedURL
url
=
>
{
let
doc
=
content
.
document
;
return
doc
&
&
doc
.
readyState
=
=
=
"
complete
"
&
&
doc
.
location
.
href
=
=
url
;
}
)
;
if
(
!
alreadyLoaded
)
{
await
loadPromise
;
}
aCallback
(
)
;
}
function
whenTabLoaded
(
aTab
aCallback
)
{
promiseTabLoadEvent
(
aTab
)
.
then
(
aCallback
)
;
}
function
promiseTabLoaded
(
aTab
)
{
return
new
Promise
(
resolve
=
>
{
whenTabLoaded
(
aTab
resolve
)
;
}
)
;
}
var
FullZoomHelper
=
{
selectTabAndWaitForLocationChange
:
function
selectTabAndWaitForLocationChange
(
tab
)
{
if
(
!
tab
)
{
throw
new
Error
(
"
tab
must
be
given
.
"
)
;
}
if
(
gBrowser
.
selectedTab
=
=
tab
)
{
return
Promise
.
resolve
(
)
;
}
return
Promise
.
all
(
[
BrowserTestUtils
.
switchTab
(
gBrowser
tab
)
this
.
waitForLocationChange
(
)
]
)
;
}
removeTabAndWaitForLocationChange
:
function
removeTabAndWaitForLocationChange
(
tab
)
{
tab
=
tab
|
|
gBrowser
.
selectedTab
;
let
selected
=
gBrowser
.
selectedTab
=
=
tab
;
gBrowser
.
removeTab
(
tab
)
;
if
(
selected
)
{
return
this
.
waitForLocationChange
(
)
;
}
return
Promise
.
resolve
(
)
;
}
waitForLocationChange
:
function
waitForLocationChange
(
)
{
return
new
Promise
(
resolve
=
>
{
Services
.
obs
.
addObserver
(
function
obs
(
subj
topic
data
)
{
Services
.
obs
.
removeObserver
(
obs
topic
)
;
resolve
(
)
;
}
"
browser
-
fullZoom
:
location
-
change
"
)
;
}
)
;
}
load
:
function
load
(
tab
url
)
{
return
new
Promise
(
resolve
=
>
{
let
didLoad
=
false
;
let
didZoom
=
false
;
promiseTabLoadEvent
(
tab
)
.
then
(
event
=
>
{
didLoad
=
true
;
if
(
didZoom
)
{
resolve
(
)
;
}
}
true
)
;
this
.
waitForLocationChange
(
)
.
then
(
function
(
)
{
didZoom
=
true
;
if
(
didLoad
)
{
resolve
(
)
;
}
}
)
;
BrowserTestUtils
.
loadURI
(
tab
.
linkedBrowser
url
)
;
}
)
;
}
zoomTest
:
function
zoomTest
(
tab
val
msg
)
{
is
(
ZoomManager
.
getZoomForBrowser
(
tab
.
linkedBrowser
)
val
msg
)
;
}
enlarge
:
function
enlarge
(
)
{
return
new
Promise
(
resolve
=
>
FullZoom
.
enlarge
(
resolve
)
)
;
}
reduce
:
function
reduce
(
)
{
return
new
Promise
(
resolve
=
>
FullZoom
.
reduce
(
resolve
)
)
;
}
reset
:
function
reset
(
)
{
return
FullZoom
.
reset
(
)
;
}
BACK
:
0
FORWARD
:
1
navigate
:
function
navigate
(
direction
)
{
return
new
Promise
(
resolve
=
>
{
let
didPs
=
false
;
let
didZoom
=
false
;
BrowserTestUtils
.
waitForContentEvent
(
gBrowser
.
selectedBrowser
"
pageshow
"
true
)
.
then
(
(
)
=
>
{
didPs
=
true
;
if
(
didZoom
)
{
resolve
(
)
;
}
}
)
;
if
(
direction
=
=
this
.
BACK
)
{
gBrowser
.
goBack
(
)
;
}
else
if
(
direction
=
=
this
.
FORWARD
)
{
gBrowser
.
goForward
(
)
;
}
this
.
waitForLocationChange
(
)
.
then
(
function
(
)
{
didZoom
=
true
;
if
(
didPs
)
{
resolve
(
)
;
}
}
)
;
}
)
;
}
failAndContinue
:
function
failAndContinue
(
func
)
{
return
function
(
err
)
{
ok
(
false
err
)
;
func
(
)
;
}
;
}
}
;
function
promiseTabLoadEvent
(
tab
url
)
{
info
(
"
Wait
tab
event
:
load
"
)
;
function
handle
(
loadedUrl
)
{
if
(
loadedUrl
=
=
=
"
about
:
blank
"
|
|
(
url
&
&
loadedUrl
!
=
=
url
)
)
{
info
(
Skipping
spurious
load
event
for
{
loadedUrl
}
)
;
return
false
;
}
info
(
"
Tab
event
received
:
load
"
)
;
return
true
;
}
let
loaded
=
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
false
handle
)
;
if
(
url
)
{
BrowserTestUtils
.
loadURI
(
tab
.
linkedBrowser
url
)
;
}
return
loaded
;
}
function
waitForNewTabEvent
(
aTabBrowser
)
{
return
BrowserTestUtils
.
waitForEvent
(
aTabBrowser
.
tabContainer
"
TabOpen
"
)
;
}
function
is_hidden
(
element
)
{
var
style
=
element
.
ownerGlobal
.
getComputedStyle
(
element
)
;
if
(
style
.
display
=
=
"
none
"
)
{
return
true
;
}
if
(
style
.
visibility
!
=
"
visible
"
)
{
return
true
;
}
if
(
style
.
display
=
=
"
-
moz
-
popup
"
)
{
return
[
"
hiding
"
"
closed
"
]
.
includes
(
element
.
state
)
;
}
if
(
element
.
parentNode
!
=
element
.
ownerDocument
)
{
return
is_hidden
(
element
.
parentNode
)
;
}
return
false
;
}
function
is_element_visible
(
element
msg
)
{
isnot
(
element
null
"
Element
should
not
be
null
when
checking
visibility
"
)
;
ok
(
BrowserTestUtils
.
is_visible
(
element
)
msg
|
|
"
Element
should
be
visible
"
)
;
}
function
is_element_hidden
(
element
msg
)
{
isnot
(
element
null
"
Element
should
not
be
null
when
checking
visibility
"
)
;
ok
(
is_hidden
(
element
)
msg
|
|
"
Element
should
be
hidden
"
)
;
}
function
promisePopupShown
(
popup
)
{
return
BrowserTestUtils
.
waitForPopupEvent
(
popup
"
shown
"
)
;
}
function
promisePopupHidden
(
popup
)
{
return
BrowserTestUtils
.
waitForPopupEvent
(
popup
"
hidden
"
)
;
}
function
promiseNotificationShown
(
notification
)
{
let
win
=
notification
.
browser
.
ownerGlobal
;
if
(
win
.
PopupNotifications
.
panel
.
state
=
=
"
open
"
)
{
return
Promise
.
resolve
(
)
;
}
let
panelPromise
=
promisePopupShown
(
win
.
PopupNotifications
.
panel
)
;
notification
.
reshow
(
)
;
return
panelPromise
;
}
function
promiseOnBookmarkItemAdded
(
aExpectedURI
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
listener
=
events
=
>
{
is
(
events
.
length
1
"
Should
only
receive
one
event
.
"
)
;
info
(
"
Added
a
bookmark
to
"
+
events
[
0
]
.
url
)
;
PlacesUtils
.
observers
.
removeListener
(
[
"
bookmark
-
added
"
]
listener
)
;
if
(
events
[
0
]
.
url
=
=
aExpectedURI
.
spec
)
{
resolve
(
)
;
}
else
{
reject
(
new
Error
(
"
Added
an
unexpected
bookmark
"
)
)
;
}
}
;
info
(
"
Waiting
for
a
bookmark
to
be
added
"
)
;
PlacesUtils
.
observers
.
addListener
(
[
"
bookmark
-
added
"
]
listener
)
;
}
)
;
}
async
function
loadBadCertPage
(
url
)
{
let
loaded
=
BrowserTestUtils
.
waitForErrorPage
(
gBrowser
.
selectedBrowser
)
;
await
BrowserTestUtils
.
loadURI
(
gBrowser
.
selectedBrowser
url
)
;
await
loaded
;
await
ContentTask
.
spawn
(
gBrowser
.
selectedBrowser
null
async
function
(
)
{
content
.
document
.
getElementById
(
"
exceptionDialogButton
"
)
.
click
(
)
;
}
)
;
await
BrowserTestUtils
.
browserLoaded
(
gBrowser
.
selectedBrowser
)
;
}
async
function
promiseStylesheetsUpdated
(
browser
)
{
await
BrowserTestUtils
.
waitForMessage
(
browser
.
messageManager
"
PageStyle
:
StyleSheets
"
)
;
await
new
Promise
(
resolve
=
>
Services
.
tm
.
dispatchToMainThread
(
resolve
)
)
;
}
