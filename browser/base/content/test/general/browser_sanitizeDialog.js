Components
.
utils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
var
{
LoadContextInfo
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
LoadContextInfo
.
jsm
"
{
}
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
FormHistory
"
"
resource
:
/
/
gre
/
modules
/
FormHistory
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Downloads
"
"
resource
:
/
/
gre
/
modules
/
Downloads
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Timer
"
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PlacesTestUtils
"
"
resource
:
/
/
testing
-
common
/
PlacesTestUtils
.
jsm
"
)
;
var
tempScope
=
{
}
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
browser
/
content
/
sanitize
.
js
"
tempScope
)
;
var
Sanitizer
=
tempScope
.
Sanitizer
;
const
kMsecPerMin
=
60
*
1000
;
const
kUsecPerMin
=
60
*
1000000
;
add_task
(
async
function
init
(
)
{
requestLongerTimeout
(
3
)
;
await
blankSlate
(
)
;
registerCleanupFunction
(
async
function
(
)
{
await
blankSlate
(
)
;
await
PlacesTestUtils
.
promiseAsyncUpdates
(
)
;
}
)
;
}
)
;
add_task
(
async
function
default_state
(
)
{
let
wh
=
new
WindowHelper
(
)
;
wh
.
onload
=
function
(
)
{
this
.
selectDuration
(
Sanitizer
.
TIMESPAN_HOUR
)
;
if
(
!
this
.
getItemList
(
)
.
collapsed
)
this
.
toggleDetails
(
)
;
this
.
acceptDialog
(
)
;
}
;
wh
.
open
(
)
;
await
wh
.
promiseClosed
;
}
)
;
add_task
(
async
function
test_cancel
(
)
{
let
uris
=
[
]
;
let
places
=
[
]
;
let
pURI
;
for
(
let
i
=
0
;
i
<
30
;
i
+
+
)
{
pURI
=
makeURI
(
"
http
:
/
/
"
+
i
+
"
-
minutes
-
ago
.
com
/
"
)
;
places
.
push
(
{
uri
:
pURI
visitDate
:
visitTimeForMinutesAgo
(
i
)
}
)
;
uris
.
push
(
pURI
)
;
}
await
PlacesTestUtils
.
addVisits
(
places
)
;
let
wh
=
new
WindowHelper
(
)
;
wh
.
onload
=
function
(
)
{
this
.
selectDuration
(
Sanitizer
.
TIMESPAN_HOUR
)
;
this
.
checkPrefCheckbox
(
"
history
"
false
)
;
this
.
checkDetails
(
false
)
;
this
.
toggleDetails
(
)
;
this
.
checkDetails
(
true
)
;
this
.
toggleDetails
(
)
;
this
.
checkDetails
(
false
)
;
this
.
cancelDialog
(
)
;
}
;
wh
.
onunload
=
async
function
(
)
{
await
promiseHistoryClearedState
(
uris
false
)
;
await
blankSlate
(
)
;
await
promiseHistoryClearedState
(
uris
true
)
;
}
;
wh
.
open
(
)
;
await
wh
.
promiseClosed
;
}
)
;
add_task
(
async
function
test_history_downloads_checked
(
)
{
let
downloadIDs
=
[
]
;
for
(
let
i
=
0
;
i
<
5
;
i
+
+
)
{
await
addDownloadWithMinutesAgo
(
downloadIDs
i
)
;
}
let
olderDownloadIDs
=
[
]
;
for
(
let
i
=
0
;
i
<
5
;
i
+
+
)
{
await
addDownloadWithMinutesAgo
(
olderDownloadIDs
61
+
i
)
;
}
let
uris
=
[
]
;
let
places
=
[
]
;
let
pURI
;
for
(
let
i
=
0
;
i
<
30
;
i
+
+
)
{
pURI
=
makeURI
(
"
http
:
/
/
"
+
i
+
"
-
minutes
-
ago
.
com
/
"
)
;
places
.
push
(
{
uri
:
pURI
visitDate
:
visitTimeForMinutesAgo
(
i
)
}
)
;
uris
.
push
(
pURI
)
;
}
let
olderURIs
=
[
]
;
for
(
let
i
=
0
;
i
<
5
;
i
+
+
)
{
pURI
=
makeURI
(
"
http
:
/
/
"
+
(
61
+
i
)
+
"
-
minutes
-
ago
.
com
/
"
)
;
places
.
push
(
{
uri
:
pURI
visitDate
:
visitTimeForMinutesAgo
(
61
+
i
)
}
)
;
olderURIs
.
push
(
pURI
)
;
}
let
promiseSanitized
=
promiseSanitizationComplete
(
)
;
await
PlacesTestUtils
.
addVisits
(
places
)
;
let
wh
=
new
WindowHelper
(
)
;
wh
.
onload
=
function
(
)
{
this
.
selectDuration
(
Sanitizer
.
TIMESPAN_HOUR
)
;
this
.
checkPrefCheckbox
(
"
history
"
true
)
;
this
.
acceptDialog
(
)
;
}
;
wh
.
onunload
=
async
function
(
)
{
intPrefIs
(
"
sanitize
.
timeSpan
"
Sanitizer
.
TIMESPAN_HOUR
"
timeSpan
pref
should
be
hour
after
accepting
dialog
with
"
+
"
hour
selected
"
)
;
boolPrefIs
(
"
cpd
.
history
"
true
"
history
pref
should
be
true
after
accepting
dialog
with
"
+
"
history
checkbox
checked
"
)
;
boolPrefIs
(
"
cpd
.
downloads
"
true
"
downloads
pref
should
be
true
after
accepting
dialog
with
"
+
"
history
checkbox
checked
"
)
;
await
promiseSanitized
;
await
promiseHistoryClearedState
(
uris
true
)
;
await
ensureDownloadsClearedState
(
downloadIDs
true
)
;
await
promiseHistoryClearedState
(
olderURIs
false
)
;
await
ensureDownloadsClearedState
(
olderDownloadIDs
false
)
;
await
blankSlate
(
)
;
await
promiseHistoryClearedState
(
olderURIs
true
)
;
await
ensureDownloadsClearedState
(
olderDownloadIDs
true
)
;
}
;
wh
.
open
(
)
;
await
wh
.
promiseClosed
;
}
)
;
add_task
(
async
function
test_history_downloads_unchecked
(
)
{
let
formEntries
=
[
]
;
for
(
let
i
=
0
;
i
<
5
;
i
+
+
)
{
formEntries
.
push
(
(
await
promiseAddFormEntryWithMinutesAgo
(
i
)
)
)
;
}
let
downloadIDs
=
[
]
;
for
(
let
i
=
0
;
i
<
5
;
i
+
+
)
{
await
addDownloadWithMinutesAgo
(
downloadIDs
i
)
;
}
let
uris
=
[
]
;
let
places
=
[
]
;
let
pURI
;
for
(
let
i
=
0
;
i
<
5
;
i
+
+
)
{
pURI
=
makeURI
(
"
http
:
/
/
"
+
i
+
"
-
minutes
-
ago
.
com
/
"
)
;
places
.
push
(
{
uri
:
pURI
visitDate
:
visitTimeForMinutesAgo
(
i
)
}
)
;
uris
.
push
(
pURI
)
;
}
await
PlacesTestUtils
.
addVisits
(
places
)
;
let
wh
=
new
WindowHelper
(
)
;
wh
.
onload
=
function
(
)
{
is
(
this
.
isWarningPanelVisible
(
)
false
"
Warning
panel
should
be
hidden
after
previously
accepting
dialog
"
+
"
with
a
predefined
timespan
"
)
;
this
.
selectDuration
(
Sanitizer
.
TIMESPAN_HOUR
)
;
this
.
checkPrefCheckbox
(
"
history
"
false
)
;
this
.
checkPrefCheckbox
(
"
formdata
"
true
)
;
this
.
acceptDialog
(
)
;
}
;
wh
.
onunload
=
async
function
(
)
{
intPrefIs
(
"
sanitize
.
timeSpan
"
Sanitizer
.
TIMESPAN_HOUR
"
timeSpan
pref
should
be
hour
after
accepting
dialog
with
"
+
"
hour
selected
"
)
;
boolPrefIs
(
"
cpd
.
history
"
false
"
history
pref
should
be
false
after
accepting
dialog
with
"
+
"
history
checkbox
unchecked
"
)
;
boolPrefIs
(
"
cpd
.
downloads
"
false
"
downloads
pref
should
be
false
after
accepting
dialog
with
"
+
"
history
checkbox
unchecked
"
)
;
await
promiseHistoryClearedState
(
uris
false
)
;
await
ensureDownloadsClearedState
(
downloadIDs
false
)
;
for
(
let
entry
of
formEntries
)
{
let
exists
=
await
formNameExists
(
entry
)
;
is
(
exists
false
"
form
entry
"
+
entry
+
"
should
no
longer
exist
"
)
;
}
await
blankSlate
(
)
;
await
promiseHistoryClearedState
(
uris
true
)
;
await
ensureDownloadsClearedState
(
downloadIDs
true
)
;
}
;
wh
.
open
(
)
;
await
wh
.
promiseClosed
;
}
)
;
add_task
(
async
function
test_everything
(
)
{
let
uris
=
[
]
;
let
places
=
[
]
;
let
pURI
;
[
10
70
130
250
]
.
forEach
(
function
(
aValue
)
{
pURI
=
makeURI
(
"
http
:
/
/
"
+
aValue
+
"
-
minutes
-
ago
.
com
/
"
)
;
places
.
push
(
{
uri
:
pURI
visitDate
:
visitTimeForMinutesAgo
(
aValue
)
}
)
;
uris
.
push
(
pURI
)
;
}
)
;
let
promiseSanitized
=
promiseSanitizationComplete
(
)
;
await
PlacesTestUtils
.
addVisits
(
places
)
;
let
wh
=
new
WindowHelper
(
)
;
wh
.
onload
=
function
(
)
{
is
(
this
.
isWarningPanelVisible
(
)
false
"
Warning
panel
should
be
hidden
after
previously
accepting
dialog
"
+
"
with
a
predefined
timespan
"
)
;
this
.
selectDuration
(
Sanitizer
.
TIMESPAN_EVERYTHING
)
;
this
.
checkPrefCheckbox
(
"
history
"
true
)
;
this
.
checkDetails
(
true
)
;
this
.
toggleDetails
(
)
;
this
.
checkDetails
(
false
)
;
this
.
toggleDetails
(
)
;
this
.
checkDetails
(
true
)
;
this
.
acceptDialog
(
)
;
}
;
wh
.
onunload
=
async
function
(
)
{
await
promiseSanitized
;
intPrefIs
(
"
sanitize
.
timeSpan
"
Sanitizer
.
TIMESPAN_EVERYTHING
"
timeSpan
pref
should
be
everything
after
accepting
dialog
"
+
"
with
everything
selected
"
)
;
await
promiseHistoryClearedState
(
uris
true
)
;
}
;
wh
.
open
(
)
;
await
wh
.
promiseClosed
;
}
)
;
add_task
(
async
function
test_everything_warning
(
)
{
let
uris
=
[
]
;
let
places
=
[
]
;
let
pURI
;
[
10
70
130
250
]
.
forEach
(
function
(
aValue
)
{
pURI
=
makeURI
(
"
http
:
/
/
"
+
aValue
+
"
-
minutes
-
ago
.
com
/
"
)
;
places
.
push
(
{
uri
:
pURI
visitDate
:
visitTimeForMinutesAgo
(
aValue
)
}
)
;
uris
.
push
(
pURI
)
;
}
)
;
let
promiseSanitized
=
promiseSanitizationComplete
(
)
;
await
PlacesTestUtils
.
addVisits
(
places
)
;
let
wh
=
new
WindowHelper
(
)
;
wh
.
onload
=
function
(
)
{
is
(
this
.
isWarningPanelVisible
(
)
true
"
Warning
panel
should
be
visible
after
previously
accepting
dialog
"
+
"
with
clearing
everything
"
)
;
this
.
selectDuration
(
Sanitizer
.
TIMESPAN_EVERYTHING
)
;
this
.
checkPrefCheckbox
(
"
history
"
true
)
;
this
.
acceptDialog
(
)
;
}
;
wh
.
onunload
=
async
function
(
)
{
intPrefIs
(
"
sanitize
.
timeSpan
"
Sanitizer
.
TIMESPAN_EVERYTHING
"
timeSpan
pref
should
be
everything
after
accepting
dialog
"
+
"
with
everything
selected
"
)
;
await
promiseSanitized
;
await
promiseHistoryClearedState
(
uris
true
)
;
}
;
wh
.
open
(
)
;
await
wh
.
promiseClosed
;
}
)
;
add_task
(
async
function
test_cannot_clear_history
(
)
{
let
formEntries
=
[
(
await
promiseAddFormEntryWithMinutesAgo
(
10
)
)
]
;
let
promiseSanitized
=
promiseSanitizationComplete
(
)
;
let
pURI
=
makeURI
(
"
http
:
/
/
"
+
10
+
"
-
minutes
-
ago
.
com
/
"
)
;
await
PlacesTestUtils
.
addVisits
(
{
uri
:
pURI
visitDate
:
visitTimeForMinutesAgo
(
10
)
}
)
;
let
uris
=
[
pURI
]
;
let
wh
=
new
WindowHelper
(
)
;
wh
.
onload
=
function
(
)
{
var
cb
=
this
.
win
.
document
.
querySelectorAll
(
"
#
itemList
>
[
preference
=
'
privacy
.
cpd
.
formdata
'
]
"
)
;
ok
(
cb
.
length
=
=
1
&
&
!
cb
[
0
]
.
disabled
"
There
is
formdata
checkbox
to
"
+
"
clear
formdata
should
be
enabled
.
"
)
;
cb
=
this
.
win
.
document
.
querySelectorAll
(
"
#
itemList
>
[
preference
=
'
privacy
.
cpd
.
history
'
]
"
)
;
ok
(
cb
.
length
=
=
1
&
&
!
cb
[
0
]
.
disabled
"
There
is
history
checkbox
to
"
+
"
clear
history
should
be
enabled
.
"
)
;
this
.
checkAllCheckboxes
(
)
;
this
.
acceptDialog
(
)
;
}
;
wh
.
onunload
=
async
function
(
)
{
await
promiseSanitized
;
await
promiseHistoryClearedState
(
uris
true
)
;
let
exists
=
await
formNameExists
(
formEntries
[
0
]
)
;
is
(
exists
false
"
form
entry
"
+
formEntries
[
0
]
+
"
should
no
longer
exist
"
)
;
}
;
wh
.
open
(
)
;
await
wh
.
promiseClosed
;
}
)
;
add_task
(
async
function
test_no_formdata_history_to_clear
(
)
{
let
promiseSanitized
=
promiseSanitizationComplete
(
)
;
let
wh
=
new
WindowHelper
(
)
;
wh
.
onload
=
function
(
)
{
boolPrefIs
(
"
cpd
.
history
"
true
"
history
pref
should
be
true
after
accepting
dialog
with
"
+
"
history
checkbox
checked
"
)
;
boolPrefIs
(
"
cpd
.
formdata
"
true
"
formdata
pref
should
be
true
after
accepting
dialog
with
"
+
"
formdata
checkbox
checked
"
)
;
var
cb
=
this
.
win
.
document
.
querySelectorAll
(
"
#
itemList
>
[
preference
=
'
privacy
.
cpd
.
history
'
]
"
)
;
ok
(
cb
.
length
=
=
1
&
&
!
cb
[
0
]
.
disabled
&
&
cb
[
0
]
.
checked
"
There
is
no
history
but
history
checkbox
should
always
be
enabled
"
+
"
and
will
be
checked
from
previous
preference
.
"
)
;
this
.
acceptDialog
(
)
;
}
;
wh
.
open
(
)
;
await
wh
.
promiseClosed
;
await
promiseSanitized
;
}
)
;
add_task
(
async
function
test_form_entries
(
)
{
let
formEntry
=
(
await
promiseAddFormEntryWithMinutesAgo
(
10
)
)
;
let
promiseSanitized
=
promiseSanitizationComplete
(
)
;
let
wh
=
new
WindowHelper
(
)
;
wh
.
onload
=
function
(
)
{
boolPrefIs
(
"
cpd
.
formdata
"
true
"
formdata
pref
should
persist
previous
value
after
accepting
"
+
"
dialog
where
you
could
not
clear
formdata
.
"
)
;
var
cb
=
this
.
win
.
document
.
querySelectorAll
(
"
#
itemList
>
[
preference
=
'
privacy
.
cpd
.
formdata
'
]
"
)
;
info
(
"
There
exists
formEntries
so
the
checkbox
should
be
in
sync
with
the
pref
.
"
)
;
is
(
cb
.
length
1
"
There
is
only
one
checkbox
for
form
data
"
)
;
ok
(
!
cb
[
0
]
.
disabled
"
The
checkbox
is
enabled
"
)
;
ok
(
cb
[
0
]
.
checked
"
The
checkbox
is
checked
"
)
;
this
.
acceptDialog
(
)
;
}
;
wh
.
onunload
=
async
function
(
)
{
await
promiseSanitized
;
let
exists
=
await
formNameExists
(
formEntry
)
;
is
(
exists
false
"
form
entry
"
+
formEntry
+
"
should
no
longer
exist
"
)
;
}
;
wh
.
open
(
)
;
await
wh
.
promiseClosed
;
}
)
;
add_task
(
async
function
test_toggling_details_persists
(
)
{
{
let
wh
=
new
WindowHelper
(
)
;
wh
.
onload
=
function
(
)
{
this
.
checkAllCheckboxes
(
)
;
this
.
selectDuration
(
Sanitizer
.
TIMESPAN_EVERYTHING
)
;
this
.
toggleDetails
(
)
;
this
.
checkDetails
(
false
)
;
this
.
acceptDialog
(
)
;
}
;
wh
.
open
(
)
;
await
wh
.
promiseClosed
;
}
{
let
wh
=
new
WindowHelper
(
)
;
wh
.
onload
=
function
(
)
{
this
.
checkDetails
(
false
)
;
this
.
checkPrefCheckbox
(
"
history
"
false
)
;
this
.
acceptDialog
(
)
;
}
;
wh
.
open
(
)
;
await
wh
.
promiseClosed
;
}
{
let
wh
=
new
WindowHelper
(
)
;
wh
.
onload
=
function
(
)
{
this
.
checkDetails
(
true
)
;
this
.
checkAllCheckboxes
(
)
;
this
.
checkPrefCheckbox
(
"
siteSettings
"
false
)
;
this
.
acceptDialog
(
)
;
}
;
wh
.
open
(
)
;
await
wh
.
promiseClosed
;
}
{
let
wh
=
new
WindowHelper
(
)
;
wh
.
onload
=
function
(
)
{
this
.
checkDetails
(
true
)
;
this
.
toggleDetails
(
)
;
this
.
checkDetails
(
false
)
;
this
.
cancelDialog
(
)
;
}
;
wh
.
open
(
)
;
await
wh
.
promiseClosed
;
}
{
let
wh
=
new
WindowHelper
(
)
;
wh
.
onload
=
function
(
)
{
this
.
checkDetails
(
true
)
;
this
.
selectDuration
(
Sanitizer
.
TIMESPAN_HOUR
)
;
this
.
toggleDetails
(
)
;
this
.
checkDetails
(
false
)
;
this
.
acceptDialog
(
)
;
}
;
wh
.
open
(
)
;
await
wh
.
promiseClosed
;
}
{
let
wh
=
new
WindowHelper
(
)
;
wh
.
onload
=
function
(
)
{
this
.
checkDetails
(
false
)
;
this
.
cancelDialog
(
)
;
}
;
wh
.
open
(
)
;
await
wh
.
promiseClosed
;
}
{
let
wh
=
new
WindowHelper
(
)
;
wh
.
onload
=
function
(
)
{
this
.
checkDetails
(
false
)
;
this
.
toggleDetails
(
)
;
this
.
checkDetails
(
true
)
;
this
.
cancelDialog
(
)
;
}
;
wh
.
open
(
)
;
await
wh
.
promiseClosed
;
}
}
)
;
add_task
(
async
function
test_offline_cache
(
)
{
var
URL
=
"
http
:
/
/
www
.
example
.
com
"
;
var
URI
=
makeURI
(
URL
)
;
var
principal
=
Services
.
scriptSecurityManager
.
createCodebasePrincipal
(
URI
{
}
)
;
Services
.
perms
.
addFromPrincipal
(
principal
"
offline
-
app
"
Ci
.
nsIPermissionManager
.
ALLOW_ACTION
)
;
Services
.
perms
.
addFromPrincipal
(
principal
"
offline
-
app
"
Ci
.
nsIOfflineCacheUpdateService
.
ALLOW_NO_WARN
)
;
var
appcacheserv
=
Cc
[
"
mozilla
.
org
/
network
/
application
-
cache
-
service
;
1
"
]
.
getService
(
Ci
.
nsIApplicationCacheService
)
;
var
appcachegroupid
=
appcacheserv
.
buildGroupIDForInfo
(
makeURI
(
URL
+
"
/
manifest
"
)
LoadContextInfo
.
default
)
;
var
appcache
=
appcacheserv
.
createApplicationCache
(
appcachegroupid
)
;
var
storage
=
Services
.
cache2
.
appCacheStorage
(
LoadContextInfo
.
default
appcache
)
;
let
wh
=
new
WindowHelper
(
)
;
wh
.
onload
=
function
(
)
{
this
.
selectDuration
(
Sanitizer
.
TIMESPAN_EVERYTHING
)
;
this
.
toggleDetails
(
)
;
this
.
uncheckAllCheckboxes
(
)
;
this
.
checkPrefCheckbox
(
"
offlineApps
"
true
)
;
this
.
acceptDialog
(
)
;
}
;
wh
.
onunload
=
function
(
)
{
var
size
=
-
1
;
var
visitor
=
{
onCacheStorageInfo
(
aEntryCount
aConsumption
aCapacity
aDiskDirectory
)
{
size
=
aConsumption
;
}
}
;
storage
.
asyncVisitStorage
(
visitor
false
)
;
is
(
size
0
"
offline
application
cache
entries
evicted
"
)
;
}
;
var
cacheListener
=
{
onCacheEntryCheck
(
)
{
return
Ci
.
nsICacheEntryOpenCallback
.
ENTRY_WANTED
;
}
onCacheEntryAvailable
(
entry
isnew
unused
status
)
{
is
(
status
Cr
.
NS_OK
)
;
var
stream
=
entry
.
openOutputStream
(
0
)
;
var
content
=
"
content
"
;
stream
.
write
(
content
content
.
length
)
;
stream
.
close
(
)
;
entry
.
close
(
)
;
wh
.
open
(
)
;
}
}
;
storage
.
asyncOpenURI
(
makeURI
(
URL
)
"
"
Ci
.
nsICacheStorage
.
OPEN_TRUNCATE
cacheListener
)
;
await
wh
.
promiseClosed
;
}
)
;
add_task
(
async
function
test_offline_apps_permissions
(
)
{
var
URL
=
"
http
:
/
/
www
.
example
.
com
"
;
var
URI
=
makeURI
(
URL
)
;
var
principal
=
Services
.
scriptSecurityManager
.
createCodebasePrincipal
(
URI
{
}
)
;
let
promiseSanitized
=
promiseSanitizationComplete
(
)
;
let
wh
=
new
WindowHelper
(
)
;
wh
.
onload
=
function
(
)
{
this
.
selectDuration
(
Sanitizer
.
TIMESPAN_EVERYTHING
)
;
this
.
toggleDetails
(
)
;
this
.
uncheckAllCheckboxes
(
)
;
this
.
checkPrefCheckbox
(
"
siteSettings
"
true
)
;
this
.
acceptDialog
(
)
;
}
;
wh
.
onunload
=
async
function
(
)
{
await
promiseSanitized
;
is
(
Services
.
perms
.
testPermissionFromPrincipal
(
principal
"
offline
-
app
"
)
0
"
offline
-
app
permissions
removed
"
)
;
}
;
wh
.
open
(
)
;
await
wh
.
promiseClosed
;
}
)
;
var
now_mSec
=
Date
.
now
(
)
;
var
now_uSec
=
now_mSec
*
1000
;
function
WindowHelper
(
aWin
)
{
this
.
win
=
aWin
;
this
.
promiseClosed
=
new
Promise
(
resolve
=
>
{
this
.
_resolveClosed
=
resolve
;
}
)
;
}
WindowHelper
.
prototype
=
{
acceptDialog
(
)
{
is
(
this
.
win
.
document
.
documentElement
.
getButton
(
"
accept
"
)
.
disabled
false
"
Dialog
'
s
OK
button
should
not
be
disabled
"
)
;
this
.
win
.
document
.
documentElement
.
acceptDialog
(
)
;
}
cancelDialog
(
)
{
this
.
win
.
document
.
documentElement
.
cancelDialog
(
)
;
}
checkDetails
(
aShouldBeShown
)
{
let
button
=
this
.
getDetailsButton
(
)
;
let
list
=
this
.
getItemList
(
)
;
let
hidden
=
list
.
hidden
|
|
list
.
collapsed
;
is
(
hidden
!
aShouldBeShown
"
Details
should
be
"
+
(
aShouldBeShown
?
"
shown
"
:
"
hidden
"
)
+
"
but
were
actually
"
+
(
hidden
?
"
hidden
"
:
"
shown
"
)
)
;
let
dir
=
hidden
?
"
down
"
:
"
up
"
;
is
(
button
.
className
"
expander
-
"
+
dir
"
Details
button
should
be
"
+
dir
+
"
because
item
list
is
"
+
(
hidden
?
"
"
:
"
not
"
)
+
"
hidden
"
)
;
let
height
=
0
;
if
(
!
hidden
)
{
ok
(
list
.
boxObject
.
height
>
30
"
listbox
has
sufficient
size
"
)
;
height
+
=
list
.
boxObject
.
height
;
}
if
(
this
.
isWarningPanelVisible
(
)
)
height
+
=
this
.
getWarningPanel
(
)
.
boxObject
.
height
;
ok
(
height
<
this
.
win
.
innerHeight
"
Window
should
be
tall
enough
to
fit
warning
panel
and
item
list
"
)
;
}
checkPrefCheckbox
(
aPrefName
aCheckState
)
{
var
pref
=
"
privacy
.
cpd
.
"
+
aPrefName
;
var
cb
=
this
.
win
.
document
.
querySelectorAll
(
"
#
itemList
>
[
preference
=
'
"
+
pref
+
"
'
]
"
)
;
is
(
cb
.
length
1
"
found
checkbox
for
"
+
pref
+
"
preference
"
)
;
if
(
cb
[
0
]
.
checked
!
=
aCheckState
)
cb
[
0
]
.
click
(
)
;
}
_checkAllCheckboxesCustom
(
check
)
{
var
cb
=
this
.
win
.
document
.
querySelectorAll
(
"
#
itemList
>
[
preference
]
"
)
;
ok
(
cb
.
length
>
1
"
found
checkboxes
for
preferences
"
)
;
for
(
var
i
=
0
;
i
<
cb
.
length
;
+
+
i
)
{
var
pref
=
this
.
win
.
document
.
getElementById
(
cb
[
i
]
.
getAttribute
(
"
preference
"
)
)
;
if
(
!
!
pref
.
value
^
check
)
cb
[
i
]
.
click
(
)
;
}
}
checkAllCheckboxes
(
)
{
this
.
_checkAllCheckboxesCustom
(
true
)
;
}
uncheckAllCheckboxes
(
)
{
this
.
_checkAllCheckboxesCustom
(
false
)
;
}
getDetailsButton
(
)
{
return
this
.
win
.
document
.
getElementById
(
"
detailsExpander
"
)
;
}
getDurationDropdown
(
)
{
return
this
.
win
.
document
.
getElementById
(
"
sanitizeDurationChoice
"
)
;
}
getItemList
(
)
{
return
this
.
win
.
document
.
getElementById
(
"
itemList
"
)
;
}
getWarningPanel
(
)
{
return
this
.
win
.
document
.
getElementById
(
"
sanitizeEverythingWarningBox
"
)
;
}
isWarningPanelVisible
(
)
{
return
!
this
.
getWarningPanel
(
)
.
hidden
;
}
open
(
)
{
let
wh
=
this
;
function
windowObserver
(
aSubject
aTopic
aData
)
{
if
(
aTopic
!
=
"
domwindowopened
"
)
return
;
Services
.
ww
.
unregisterNotification
(
windowObserver
)
;
var
loaded
=
false
;
let
win
=
aSubject
.
QueryInterface
(
Ci
.
nsIDOMWindow
)
;
win
.
addEventListener
(
"
load
"
function
onload
(
event
)
{
if
(
win
.
name
!
=
=
"
SanitizeDialog
"
)
return
;
wh
.
win
=
win
;
loaded
=
true
;
executeSoon
(
(
)
=
>
wh
.
onload
(
)
)
;
}
{
once
:
true
}
)
;
win
.
addEventListener
(
"
unload
"
function
onunload
(
event
)
{
if
(
win
.
name
!
=
=
"
SanitizeDialog
"
)
{
win
.
removeEventListener
(
"
unload
"
onunload
)
;
return
;
}
if
(
!
loaded
)
return
;
win
.
removeEventListener
(
"
unload
"
onunload
)
;
wh
.
win
=
win
;
(
async
function
(
)
{
if
(
wh
.
onunload
)
{
await
wh
.
onunload
(
)
;
}
await
PlacesTestUtils
.
promiseAsyncUpdates
(
)
;
wh
.
_resolveClosed
(
)
;
}
)
(
)
;
}
)
;
}
Services
.
ww
.
registerNotification
(
windowObserver
)
;
Services
.
ww
.
openWindow
(
null
"
chrome
:
/
/
browser
/
content
/
sanitize
.
xul
"
"
SanitizeDialog
"
"
chrome
titlebar
dialog
centerscreen
modal
"
null
)
;
}
selectDuration
(
aDurVal
)
{
this
.
getDurationDropdown
(
)
.
value
=
aDurVal
;
if
(
aDurVal
=
=
=
Sanitizer
.
TIMESPAN_EVERYTHING
)
{
is
(
this
.
isWarningPanelVisible
(
)
true
"
Warning
panel
should
be
visible
for
TIMESPAN_EVERYTHING
"
)
;
}
else
{
is
(
this
.
isWarningPanelVisible
(
)
false
"
Warning
panel
should
not
be
visible
for
non
-
TIMESPAN_EVERYTHING
"
)
;
}
}
toggleDetails
(
)
{
this
.
getDetailsButton
(
)
.
click
(
)
;
}
}
;
function
promiseSanitizationComplete
(
)
{
return
promiseTopicObserved
(
"
sanitizer
-
sanitization
-
complete
"
)
;
}
async
function
addDownloadWithMinutesAgo
(
aExpectedPathList
aMinutesAgo
)
{
let
publicList
=
await
Downloads
.
getList
(
Downloads
.
PUBLIC
)
;
let
name
=
"
fakefile
-
"
+
aMinutesAgo
+
"
-
minutes
-
ago
"
;
let
download
=
await
Downloads
.
createDownload
(
{
source
:
"
https
:
/
/
bugzilla
.
mozilla
.
org
/
show_bug
.
cgi
?
id
=
480169
"
target
:
name
}
)
;
download
.
startTime
=
new
Date
(
now_mSec
-
(
aMinutesAgo
*
kMsecPerMin
)
)
;
download
.
canceled
=
true
;
publicList
.
add
(
download
)
;
ok
(
(
await
downloadExists
(
name
)
)
"
Sanity
check
:
download
"
+
name
+
"
should
exist
after
creating
it
"
)
;
aExpectedPathList
.
push
(
name
)
;
}
function
promiseAddFormEntryWithMinutesAgo
(
aMinutesAgo
)
{
let
name
=
aMinutesAgo
+
"
-
minutes
-
ago
"
;
let
timestamp
=
now_uSec
-
(
aMinutesAgo
*
kUsecPerMin
)
;
return
new
Promise
(
(
resolve
reject
)
=
>
FormHistory
.
update
(
{
op
:
"
add
"
fieldname
:
name
value
:
"
dummy
"
firstUsed
:
timestamp
}
{
handleError
(
error
)
{
reject
(
)
;
throw
new
Error
(
"
Error
occurred
updating
form
history
:
"
+
error
)
;
}
handleCompletion
(
reason
)
{
resolve
(
name
)
;
}
}
)
)
;
}
function
formNameExists
(
name
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
count
=
0
;
FormHistory
.
count
(
{
fieldname
:
name
}
{
handleResult
:
result
=
>
count
=
result
handleError
(
error
)
{
reject
(
error
)
;
throw
new
Error
(
"
Error
occurred
searching
form
history
:
"
+
error
)
;
}
handleCompletion
(
reason
)
{
if
(
!
reason
)
{
resolve
(
count
)
;
}
}
}
)
;
}
)
;
}
async
function
blankSlate
(
)
{
let
publicList
=
await
Downloads
.
getList
(
Downloads
.
PUBLIC
)
;
let
downloads
=
await
publicList
.
getAll
(
)
;
for
(
let
download
of
downloads
)
{
await
publicList
.
remove
(
download
)
;
await
download
.
finalize
(
true
)
;
}
await
new
Promise
(
(
resolve
reject
)
=
>
{
FormHistory
.
update
(
{
op
:
"
remove
"
}
{
handleCompletion
(
reason
)
{
if
(
!
reason
)
{
resolve
(
)
;
}
}
handleError
(
error
)
{
reject
(
error
)
;
throw
new
Error
(
"
Error
occurred
updating
form
history
:
"
+
error
)
;
}
}
)
;
}
)
;
await
PlacesTestUtils
.
clearHistory
(
)
;
}
function
boolPrefIs
(
aPrefName
aExpectedVal
aMsg
)
{
is
(
gPrefService
.
getBoolPref
(
"
privacy
.
"
+
aPrefName
)
aExpectedVal
aMsg
)
;
}
async
function
downloadExists
(
aPath
)
{
let
publicList
=
await
Downloads
.
getList
(
Downloads
.
PUBLIC
)
;
let
listArray
=
await
publicList
.
getAll
(
)
;
return
listArray
.
some
(
i
=
>
i
.
target
.
path
=
=
aPath
)
;
}
async
function
ensureDownloadsClearedState
(
aDownloadIDs
aShouldBeCleared
)
{
let
niceStr
=
aShouldBeCleared
?
"
no
longer
"
:
"
still
"
;
for
(
let
id
of
aDownloadIDs
)
{
is
(
(
await
downloadExists
(
id
)
)
!
aShouldBeCleared
"
download
"
+
id
+
"
should
"
+
niceStr
+
"
exist
"
)
;
}
}
function
intPrefIs
(
aPrefName
aExpectedVal
aMsg
)
{
is
(
gPrefService
.
getIntPref
(
"
privacy
.
"
+
aPrefName
)
aExpectedVal
aMsg
)
;
}
function
visitTimeForMinutesAgo
(
aMinutesAgo
)
{
return
now_uSec
-
aMinutesAgo
*
kUsecPerMin
;
}
