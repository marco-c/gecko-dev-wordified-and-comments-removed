const
PREF_NEWTAB_ENABLED
=
"
browser
.
newtabpage
.
enabled
"
;
const
PREF_NEWTAB_DIRECTORYSOURCE
=
"
browser
.
newtabpage
.
directory
.
source
"
;
Services
.
prefs
.
setBoolPref
(
PREF_NEWTAB_ENABLED
true
)
;
var
tmp
=
{
}
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Promise
.
jsm
"
tmp
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
NewTabUtils
.
jsm
"
tmp
)
;
Cu
.
import
(
"
resource
:
/
/
/
modules
/
DirectoryLinksProvider
.
jsm
"
tmp
)
;
Cu
.
import
(
"
resource
:
/
/
testing
-
common
/
PlacesTestUtils
.
jsm
"
tmp
)
;
Cc
[
"
mozilla
.
org
/
moz
/
jssubscript
-
loader
;
1
"
]
.
getService
(
Ci
.
mozIJSSubScriptLoader
)
.
loadSubScript
(
"
chrome
:
/
/
browser
/
content
/
sanitize
.
js
"
tmp
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
tmp
)
;
var
{
Promise
NewTabUtils
Sanitizer
clearTimeout
setTimeout
DirectoryLinksProvider
PlacesTestUtils
}
=
tmp
;
var
uri
=
Services
.
io
.
newURI
(
"
about
:
newtab
"
null
null
)
;
var
principal
=
Services
.
scriptSecurityManager
.
createCodebasePrincipal
(
uri
{
}
)
;
var
isMac
=
(
"
nsILocalFileMac
"
in
Ci
)
;
var
isLinux
=
(
"
mozilla
.
org
/
gnome
-
gconf
-
service
;
1
"
in
Cc
)
;
var
isWindows
=
(
"
mozilla
.
org
/
windows
-
registry
-
key
;
1
"
in
Cc
)
;
var
gWindow
=
window
;
var
gDirectorySource
=
'
data
:
application
/
json
{
"
test
"
:
1
}
'
;
var
gOrigDirectorySource
;
var
requiredSize
=
{
}
;
requiredSize
.
innerHeight
=
40
+
32
+
44
+
32
+
(
3
*
(
180
+
32
)
)
+
100
;
requiredSize
.
innerWidth
=
(
3
*
(
290
+
20
)
)
+
100
;
var
oldSize
=
{
}
;
Object
.
keys
(
requiredSize
)
.
forEach
(
prop
=
>
{
info
(
[
prop
gBrowser
.
contentWindow
[
prop
]
requiredSize
[
prop
]
]
)
;
if
(
gBrowser
.
contentWindow
[
prop
]
<
requiredSize
[
prop
]
)
{
oldSize
[
prop
]
=
gBrowser
.
contentWindow
[
prop
]
;
info
(
"
Changing
browser
"
+
prop
+
"
from
"
+
oldSize
[
prop
]
+
"
to
"
+
requiredSize
[
prop
]
)
;
gBrowser
.
contentWindow
[
prop
]
=
requiredSize
[
prop
]
;
}
}
)
;
var
screenHeight
=
{
}
;
var
screenWidth
=
{
}
;
Cc
[
"
mozilla
.
org
/
gfx
/
screenmanager
;
1
"
]
.
getService
(
Ci
.
nsIScreenManager
)
.
primaryScreen
.
GetAvailRectDisplayPix
(
{
}
{
}
screenWidth
screenHeight
)
;
screenHeight
=
screenHeight
.
value
;
screenWidth
=
screenWidth
.
value
;
if
(
screenHeight
<
gBrowser
.
contentWindow
.
outerHeight
)
{
info
(
"
Warning
:
Browser
outer
height
is
now
"
+
gBrowser
.
contentWindow
.
outerHeight
+
"
which
is
larger
than
the
"
+
"
available
screen
height
"
+
screenHeight
+
"
.
That
may
cause
problems
.
"
)
;
}
if
(
screenWidth
<
gBrowser
.
contentWindow
.
outerWidth
)
{
info
(
"
Warning
:
Browser
outer
width
is
now
"
+
gBrowser
.
contentWindow
.
outerWidth
+
"
which
is
larger
than
the
"
+
"
available
screen
width
"
+
screenWidth
+
"
.
That
may
cause
problems
.
"
)
;
}
registerCleanupFunction
(
function
(
)
{
while
(
gWindow
.
gBrowser
.
tabs
.
length
>
1
)
gWindow
.
gBrowser
.
removeTab
(
gWindow
.
gBrowser
.
tabs
[
1
]
)
;
Object
.
keys
(
oldSize
)
.
forEach
(
prop
=
>
{
if
(
oldSize
[
prop
]
)
{
gBrowser
.
contentWindow
[
prop
]
=
oldSize
[
prop
]
;
}
}
)
;
let
timer
=
NewTabUtils
.
allPages
.
_scheduleUpdateTimeout
;
if
(
timer
)
{
clearTimeout
(
timer
)
;
delete
NewTabUtils
.
allPages
.
_scheduleUpdateTimeout
;
}
Services
.
prefs
.
clearUserPref
(
PREF_NEWTAB_ENABLED
)
;
Services
.
prefs
.
setCharPref
(
PREF_NEWTAB_DIRECTORYSOURCE
gOrigDirectorySource
)
;
return
watchLinksChangeOnce
(
)
;
}
)
;
function
pushPrefs
(
.
.
.
aPrefs
)
{
return
new
Promise
(
resolve
=
>
SpecialPowers
.
pushPrefEnv
(
{
"
set
"
:
aPrefs
}
resolve
)
)
;
}
function
watchLinksChangeOnce
(
)
{
return
new
Promise
(
resolve
=
>
{
let
observer
=
{
onManyLinksChanged
:
(
)
=
>
{
DirectoryLinksProvider
.
removeObserver
(
observer
)
;
resolve
(
)
;
}
}
;
observer
.
onDownloadFail
=
observer
.
onManyLinksChanged
;
DirectoryLinksProvider
.
addObserver
(
observer
)
;
}
)
;
}
;
add_task
(
function
*
setup
(
)
{
registerCleanupFunction
(
function
(
)
{
return
new
Promise
(
resolve
=
>
{
function
cleanupAndFinish
(
)
{
PlacesTestUtils
.
clearHistory
(
)
.
then
(
(
)
=
>
{
whenPagesUpdated
(
)
.
then
(
resolve
)
;
NewTabUtils
.
restore
(
)
;
}
)
;
}
let
callbacks
=
NewTabUtils
.
links
.
_populateCallbacks
;
let
numCallbacks
=
callbacks
.
length
;
if
(
numCallbacks
)
callbacks
.
splice
(
0
numCallbacks
cleanupAndFinish
)
;
else
cleanupAndFinish
(
)
;
}
)
;
}
)
;
let
promiseReady
=
Task
.
spawn
(
function
*
(
)
{
yield
watchLinksChangeOnce
(
)
;
yield
whenPagesUpdated
(
)
;
}
)
;
gOrigDirectorySource
=
Services
.
prefs
.
getCharPref
(
PREF_NEWTAB_DIRECTORYSOURCE
)
;
Services
.
prefs
.
setCharPref
(
PREF_NEWTAB_DIRECTORYSOURCE
gDirectorySource
)
;
yield
promiseReady
;
}
)
;
var
TestRunner
=
{
run
:
function
(
)
{
this
.
_iter
=
runTests
(
)
;
this
.
next
(
)
;
}
next
:
function
(
)
{
try
{
TestRunner
.
_iter
.
next
(
)
;
}
catch
(
e
if
e
instanceof
StopIteration
)
{
TestRunner
.
finish
(
)
;
}
}
finish
:
function
(
)
{
function
cleanupAndFinish
(
)
{
PlacesTestUtils
.
clearHistory
(
)
.
then
(
(
)
=
>
{
whenPagesUpdated
(
)
.
then
(
finish
)
;
NewTabUtils
.
restore
(
)
;
}
)
;
}
let
callbacks
=
NewTabUtils
.
links
.
_populateCallbacks
;
let
numCallbacks
=
callbacks
.
length
;
if
(
numCallbacks
)
callbacks
.
splice
(
0
numCallbacks
cleanupAndFinish
)
;
else
cleanupAndFinish
(
)
;
}
}
;
function
getContentWindow
(
)
{
return
gWindow
.
gBrowser
.
selectedBrowser
.
contentWindow
;
}
function
getContentDocument
(
)
{
return
gWindow
.
gBrowser
.
selectedBrowser
.
contentDocument
;
}
function
getGrid
(
)
{
return
getContentWindow
(
)
.
gGrid
;
}
function
getCell
(
aIndex
)
{
return
getGrid
(
)
.
cells
[
aIndex
]
;
}
function
performOnCell
(
aIndex
aFn
)
{
return
ContentTask
.
spawn
(
gWindow
.
gBrowser
.
selectedBrowser
{
index
:
aIndex
fn
:
aFn
.
toString
(
)
}
function
*
(
args
)
{
let
cell
=
content
.
gGrid
.
cells
[
args
.
index
]
;
return
eval
(
"
(
"
+
args
.
fn
+
"
)
(
cell
)
"
)
;
}
)
;
}
function
setLinks
(
aLinks
)
{
return
new
Promise
(
resolve
=
>
{
let
links
=
aLinks
;
if
(
typeof
links
=
=
"
string
"
)
{
links
=
aLinks
.
split
(
/
\
s
*
\
s
*
/
)
.
map
(
function
(
id
)
{
return
{
url
:
"
http
:
/
/
example
"
+
(
id
!
=
"
-
1
"
?
id
:
"
"
)
+
"
.
com
/
"
title
:
"
site
#
"
+
id
}
;
}
)
;
}
NewTabUtils
.
links
.
populateCache
(
function
(
)
{
PlacesTestUtils
.
clearHistory
(
)
.
then
(
(
)
=
>
{
fillHistory
(
links
)
.
then
(
(
)
=
>
{
NewTabUtils
.
links
.
populateCache
(
function
(
)
{
NewTabUtils
.
allPages
.
update
(
)
;
resolve
(
)
;
}
true
)
;
}
)
;
}
)
;
}
)
;
}
)
;
}
function
fillHistory
(
aLinks
)
{
return
new
Promise
(
resolve
=
>
{
let
numLinks
=
aLinks
.
length
;
if
(
!
numLinks
)
{
executeSoon
(
resolve
)
;
return
;
}
let
transitionLink
=
Ci
.
nsINavHistoryService
.
TRANSITION_LINK
;
let
now
=
Date
.
now
(
)
*
1000
;
for
(
let
i
=
0
;
i
<
aLinks
.
length
;
i
+
+
)
{
let
link
=
aLinks
[
i
]
;
let
place
=
{
uri
:
makeURI
(
link
.
url
)
title
:
link
.
title
visits
:
[
{
visitDate
:
now
-
i
transitionType
:
transitionLink
}
]
}
;
PlacesUtils
.
asyncHistory
.
updatePlaces
(
place
{
handleError
:
(
)
=
>
ok
(
false
"
couldn
'
t
add
visit
to
history
"
)
handleResult
:
function
(
)
{
}
handleCompletion
:
function
(
)
{
if
(
-
-
numLinks
=
=
0
)
{
resolve
(
)
;
}
}
}
)
;
}
}
)
;
}
function
setPinnedLinks
(
aLinks
)
{
let
links
=
aLinks
;
if
(
typeof
links
=
=
"
string
"
)
{
links
=
aLinks
.
split
(
/
\
s
*
\
s
*
/
)
.
map
(
function
(
id
)
{
if
(
id
)
return
{
url
:
"
http
:
/
/
example
"
+
(
id
!
=
"
-
1
"
?
id
:
"
"
)
+
"
.
com
/
"
title
:
"
site
#
"
+
id
type
:
"
history
"
}
;
}
)
;
}
let
string
=
Cc
[
"
mozilla
.
org
/
supports
-
string
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsString
)
;
string
.
data
=
JSON
.
stringify
(
links
)
;
Services
.
prefs
.
setComplexValue
(
"
browser
.
newtabpage
.
pinned
"
Ci
.
nsISupportsString
string
)
;
NewTabUtils
.
pinnedLinks
.
resetCache
(
)
;
NewTabUtils
.
allPages
.
update
(
)
;
}
function
restore
(
)
{
return
new
Promise
(
resolve
=
>
{
whenPagesUpdated
(
)
.
then
(
resolve
)
;
NewTabUtils
.
restore
(
)
;
}
)
;
}
function
waitForCondition
(
aConditionFn
aMaxTries
=
50
aCheckInterval
=
100
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
tries
=
0
;
function
tryNow
(
)
{
tries
+
+
;
if
(
aConditionFn
(
)
)
{
resolve
(
)
;
}
else
if
(
tries
<
aMaxTries
)
{
tryAgain
(
)
;
}
else
{
reject
(
"
Condition
timed
out
:
"
+
aConditionFn
.
toSource
(
)
)
;
}
}
function
tryAgain
(
)
{
setTimeout
(
tryNow
aCheckInterval
)
;
}
tryAgain
(
)
;
}
)
;
}
function
*
addNewTabPageTab
(
)
{
let
tab
=
yield
BrowserTestUtils
.
openNewForegroundTab
(
gWindow
.
gBrowser
"
about
:
newtab
"
false
)
;
let
browser
=
tab
.
linkedBrowser
;
yield
waitForCondition
(
(
)
=
>
!
browser
.
contentDocument
.
hidden
)
yield
new
Promise
(
resolve
=
>
{
if
(
NewTabUtils
.
allPages
.
enabled
)
{
NewTabUtils
.
links
.
populateCache
(
function
(
)
{
whenSearchInitDone
(
)
.
then
(
resolve
)
;
}
)
;
}
else
{
resolve
(
)
;
}
}
)
;
return
tab
;
}
function
waitForBrowserLoad
(
browser
)
{
if
(
browser
.
contentDocument
.
readyState
=
=
"
complete
"
)
{
executeSoon
(
callback
)
;
return
;
}
browser
.
addEventListener
(
"
load
"
function
onLoad
(
)
{
browser
.
removeEventListener
(
"
load
"
onLoad
true
)
;
executeSoon
(
callback
)
;
}
true
)
;
}
function
*
checkGrid
(
aSitesPattern
)
{
let
length
=
aSitesPattern
.
split
(
"
"
)
.
length
;
let
foundPattern
=
yield
ContentTask
.
spawn
(
gWindow
.
gBrowser
.
selectedBrowser
{
length
:
length
}
function
*
(
args
)
{
let
grid
=
content
.
wrappedJSObject
.
gGrid
;
let
sites
=
grid
.
sites
.
slice
(
0
args
.
length
)
;
return
sites
.
map
(
function
(
aSite
)
{
if
(
!
aSite
)
return
"
"
;
let
pinned
=
aSite
.
isPinned
(
)
;
let
hasPinnedAttr
=
aSite
.
node
.
hasAttribute
(
"
pinned
"
)
;
if
(
pinned
!
=
hasPinnedAttr
)
ok
(
false
"
invalid
state
(
site
.
isPinned
(
)
!
=
site
[
pinned
]
)
"
)
;
return
aSite
.
url
.
replace
(
/
^
http
:
\
/
\
/
example
(
\
d
+
)
\
.
com
\
/
/
"
1
"
)
+
(
pinned
?
"
p
"
:
"
"
)
;
}
)
;
}
)
;
is
(
foundPattern
aSitesPattern
"
grid
status
=
"
+
aSitesPattern
)
;
}
function
blockCell
(
aIndex
)
{
return
new
Promise
(
resolve
=
>
{
whenPagesUpdated
(
)
.
then
(
resolve
)
;
performOnCell
(
aIndex
cell
=
>
{
return
cell
.
site
.
block
(
)
;
}
)
;
}
)
;
}
function
pinCell
(
aIndex
)
{
performOnCell
(
aIndex
cell
=
>
{
cell
.
site
.
pin
(
)
;
}
)
;
}
function
unpinCell
(
aIndex
)
{
return
new
Promise
(
resolve
=
>
{
whenPagesUpdated
(
)
.
then
(
resolve
)
;
performOnCell
(
aIndex
cell
=
>
{
cell
.
site
.
unpin
(
)
;
}
)
;
}
)
;
}
function
simulateDrop
(
aSourceIndex
aDestIndex
)
{
let
src
=
getCell
(
aSourceIndex
)
.
site
.
node
;
let
dest
=
getCell
(
aDestIndex
)
.
node
;
startAndCompleteDragOperation
(
src
dest
whenPagesUpdated
)
;
}
function
*
simulateExternalDrop
(
aDestIndex
)
{
let
pagesUpdatedPromise
=
whenPagesUpdated
(
)
;
yield
ContentTask
.
spawn
(
gWindow
.
gBrowser
.
selectedBrowser
aDestIndex
function
*
(
dropIndex
)
{
return
new
Promise
(
resolve
=
>
{
const
url
=
"
data
:
text
/
html
;
charset
=
utf
-
8
"
+
"
<
a
id
=
'
link
'
href
=
'
http
:
/
/
example99
.
com
/
'
>
link
<
/
a
>
"
;
let
doc
=
content
.
document
;
let
iframe
=
doc
.
createElement
(
"
iframe
"
)
;
function
iframeLoaded
(
)
{
let
link
=
iframe
.
contentDocument
.
getElementById
(
"
link
"
)
;
let
dataTransfer
=
new
iframe
.
contentWindow
.
DataTransfer
(
"
dragstart
"
false
)
;
dataTransfer
.
mozSetDataAt
(
"
text
/
x
-
moz
-
url
"
"
http
:
/
/
example99
.
com
/
"
0
)
;
let
event
=
content
.
document
.
createEvent
(
"
DragEvents
"
)
;
event
.
initDragEvent
(
"
drop
"
true
true
content
0
0
0
0
0
false
false
false
false
0
null
dataTransfer
)
;
let
target
=
content
.
gGrid
.
cells
[
dropIndex
]
.
node
;
target
.
dispatchEvent
(
event
)
;
iframe
.
remove
(
)
;
resolve
(
)
;
}
iframe
.
addEventListener
(
"
load
"
function
onLoad
(
)
{
iframe
.
removeEventListener
(
"
load
"
onLoad
)
;
content
.
setTimeout
(
iframeLoaded
0
)
;
}
)
;
iframe
.
setAttribute
(
"
src
"
url
)
;
iframe
.
style
.
width
=
"
50px
"
;
iframe
.
style
.
height
=
"
50px
"
;
iframe
.
style
.
position
=
"
absolute
"
;
iframe
.
style
.
zIndex
=
50
;
let
margin
=
doc
.
getElementById
(
"
newtab
-
search
-
container
"
)
;
margin
.
appendChild
(
iframe
)
;
}
)
;
}
)
;
yield
pagesUpdatedPromise
;
}
function
startAndCompleteDragOperation
(
aSource
aDest
aCallback
)
{
if
(
isMac
)
{
synthesizeNativeMouseLDown
(
aSource
)
;
synthesizeNativeMouseDrag
(
aDest
)
;
synthesizeNativeMouseDrag
(
aDest
10
)
;
synthesizeNativeMouseDrag
(
aDest
)
;
synthesizeNativeMouseLUp
(
aDest
)
.
then
(
aCallback
Cu
.
reportError
)
;
}
else
if
(
isWindows
)
{
synthesizeNativeMouseLDown
(
aSource
)
;
synthesizeNativeMouseLUp
(
aDest
)
.
then
(
aCallback
Cu
.
reportError
)
;
}
else
if
(
isLinux
)
{
synthesizeNativeMouseLDown
(
aSource
)
;
let
offset
=
0
;
let
interval
=
setInterval
(
(
)
=
>
{
synthesizeNativeMouseDrag
(
aSource
offset
+
=
5
)
;
}
10
)
;
aSource
.
addEventListener
(
"
dragstart
"
function
onDragStart
(
)
{
aSource
.
removeEventListener
(
"
dragstart
"
onDragStart
)
;
clearInterval
(
interval
)
;
synthesizeNativeMouseMove
(
aDest
)
;
}
)
;
aDest
.
addEventListener
(
"
dragenter
"
function
onDragEnter
(
)
{
aDest
.
removeEventListener
(
"
dragenter
"
onDragEnter
)
;
synthesizeNativeMouseLUp
(
aDest
)
.
then
(
aCallback
Cu
.
reportError
)
;
}
)
;
}
else
{
throw
"
Unsupported
platform
"
;
}
}
function
synthesizeNativeMouseLDown
(
aElement
)
{
if
(
isLinux
)
{
let
win
=
aElement
.
ownerDocument
.
defaultView
;
EventUtils
.
synthesizeMouseAtCenter
(
aElement
{
type
:
"
mousedown
"
}
win
)
;
}
else
{
let
msg
=
isWindows
?
2
:
1
;
synthesizeNativeMouseEvent
(
aElement
msg
)
;
}
}
function
synthesizeNativeMouseLUp
(
aElement
)
{
let
msg
=
isWindows
?
4
:
(
isMac
?
2
:
7
)
;
return
synthesizeNativeMouseEvent
(
aElement
msg
)
;
}
function
synthesizeNativeMouseDrag
(
aElement
aOffsetX
)
{
let
msg
=
isMac
?
6
:
1
;
synthesizeNativeMouseEvent
(
aElement
msg
aOffsetX
)
;
}
function
synthesizeNativeMouseMove
(
aElement
)
{
let
msg
=
isMac
?
5
:
1
;
synthesizeNativeMouseEvent
(
aElement
msg
)
;
}
function
synthesizeNativeMouseEvent
(
aElement
aMsg
aOffsetX
=
0
aOffsetY
=
0
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
rect
=
aElement
.
getBoundingClientRect
(
)
;
let
win
=
aElement
.
ownerDocument
.
defaultView
;
let
x
=
aOffsetX
+
win
.
mozInnerScreenX
+
rect
.
left
+
rect
.
width
/
2
;
let
y
=
aOffsetY
+
win
.
mozInnerScreenY
+
rect
.
top
+
rect
.
height
/
2
;
let
utils
=
win
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
let
scale
=
utils
.
screenPixelsPerCSSPixel
;
let
observer
=
{
observe
:
function
(
aSubject
aTopic
aData
)
{
if
(
aTopic
=
=
"
mouseevent
"
)
{
resolve
(
)
;
}
}
}
;
utils
.
sendNativeMouseEvent
(
x
*
scale
y
*
scale
aMsg
0
null
observer
)
;
}
)
;
}
function
sendDragEvent
(
aEventType
aTarget
aData
)
{
aTarget
.
dispatchEvent
(
createDragEvent
(
aEventType
aData
)
)
;
}
function
createDragEvent
(
aEventType
aData
)
{
let
dataTransfer
=
new
(
getContentWindow
(
)
)
.
DataTransfer
(
"
dragstart
"
false
)
;
dataTransfer
.
mozSetDataAt
(
"
text
/
x
-
moz
-
url
"
aData
0
)
;
let
event
=
getContentDocument
(
)
.
createEvent
(
"
DragEvents
"
)
;
event
.
initDragEvent
(
aEventType
true
true
getContentWindow
(
)
0
0
0
0
0
false
false
false
false
0
null
dataTransfer
)
;
return
event
;
}
function
whenPagesUpdated
(
)
{
return
new
Promise
(
resolve
=
>
{
let
page
=
{
observe
:
_
=
>
_
update
(
)
{
NewTabUtils
.
allPages
.
unregister
(
this
)
;
executeSoon
(
resolve
)
;
}
}
;
NewTabUtils
.
allPages
.
register
(
page
)
;
registerCleanupFunction
(
function
(
)
{
NewTabUtils
.
allPages
.
unregister
(
page
)
;
}
)
;
}
)
;
}
function
whenSearchInitDone
(
)
{
return
ContentTask
.
spawn
(
gWindow
.
gBrowser
.
selectedBrowser
{
}
function
*
(
)
{
return
new
Promise
(
resolve
=
>
{
if
(
content
.
gSearch
)
{
let
searchController
=
content
.
gSearch
.
_contentSearchController
;
if
(
searchController
.
defaultEngine
)
{
resolve
(
)
;
return
;
}
}
let
eventName
=
"
ContentSearchService
"
;
content
.
addEventListener
(
eventName
function
onEvent
(
event
)
{
if
(
event
.
detail
.
type
=
=
"
State
"
)
{
content
.
removeEventListener
(
eventName
onEvent
)
;
let
resolver
=
function
(
)
{
if
(
content
.
gSearch
.
_contentSearchController
.
defaultEngine
)
{
resolve
(
)
;
return
;
}
}
content
.
setTimeout
(
resolver
0
)
;
}
}
)
;
}
)
;
}
)
;
}
function
customizeNewTabPage
(
aTheme
)
{
return
ContentTask
.
spawn
(
gWindow
.
gBrowser
.
selectedBrowser
aTheme
function
*
(
aTheme
)
{
let
document
=
content
.
document
;
let
panel
=
document
.
getElementById
(
"
newtab
-
customize
-
panel
"
)
;
let
customizeButton
=
document
.
getElementById
(
"
newtab
-
customize
-
button
"
)
;
function
panelOpened
(
opened
)
{
return
new
Promise
(
(
resolve
)
=
>
{
let
options
=
{
attributes
:
true
oldValue
:
true
}
;
let
observer
=
new
content
.
MutationObserver
(
function
(
mutations
)
{
mutations
.
forEach
(
function
(
mutation
)
{
document
.
getElementById
(
"
newtab
-
customize
-
"
+
aTheme
)
.
click
(
)
;
observer
.
disconnect
(
)
;
if
(
opened
=
=
panel
.
hasAttribute
(
"
open
"
)
)
{
resolve
(
)
;
}
}
)
;
}
)
;
observer
.
observe
(
panel
options
)
;
}
)
;
}
let
opened
=
panelOpened
(
true
)
;
customizeButton
.
click
(
)
;
yield
opened
;
let
closed
=
panelOpened
(
false
)
;
customizeButton
.
click
(
)
;
yield
closed
;
}
)
;
}
function
hasScrollbar
(
)
{
return
ContentTask
.
spawn
(
gWindow
.
gBrowser
.
selectedBrowser
{
}
function
*
(
)
{
let
docElement
=
content
.
document
.
documentElement
;
return
docElement
.
scrollHeight
>
docElement
.
clientHeight
;
}
)
;
}
