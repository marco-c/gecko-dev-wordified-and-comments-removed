ChromeUtils
.
defineModuleGetter
(
this
"
Blocklist
"
"
resource
:
/
/
gre
/
modules
/
Blocklist
.
jsm
"
)
;
var
gPluginHandler
=
{
PREF_SESSION_PERSIST_MINUTES
:
"
plugin
.
sessionPermissionNow
.
intervalInMinutes
"
PREF_PERSISTENT_DAYS
:
"
plugin
.
persistentPermissionAlways
.
intervalInDays
"
MESSAGES
:
[
"
PluginContent
:
ShowClickToPlayNotification
"
"
PluginContent
:
RemoveNotification
"
"
PluginContent
:
InstallSinglePlugin
"
"
PluginContent
:
ShowPluginCrashedNotification
"
"
PluginContent
:
SubmitReport
"
"
PluginContent
:
LinkClickCallback
"
]
init
(
)
{
const
mm
=
window
.
messageManager
;
for
(
let
msg
of
this
.
MESSAGES
)
{
mm
.
addMessageListener
(
msg
this
)
;
}
window
.
addEventListener
(
"
unload
"
this
)
;
}
uninit
(
)
{
const
mm
=
window
.
messageManager
;
for
(
let
msg
of
this
.
MESSAGES
)
{
mm
.
removeMessageListener
(
msg
this
)
;
}
window
.
removeEventListener
(
"
unload
"
this
)
;
}
handleEvent
(
event
)
{
if
(
event
.
type
=
=
"
unload
"
)
{
this
.
uninit
(
)
;
}
}
receiveMessage
(
msg
)
{
switch
(
msg
.
name
)
{
case
"
PluginContent
:
ShowClickToPlayNotification
"
:
this
.
showClickToPlayNotification
(
msg
.
target
msg
.
data
.
plugins
msg
.
data
.
showNow
msg
.
principal
msg
.
data
.
location
)
;
break
;
case
"
PluginContent
:
RemoveNotification
"
:
this
.
removeNotification
(
msg
.
target
msg
.
data
.
name
)
;
break
;
case
"
PluginContent
:
InstallSinglePlugin
"
:
this
.
installSinglePlugin
(
msg
.
data
.
pluginInfo
)
;
break
;
case
"
PluginContent
:
ShowPluginCrashedNotification
"
:
this
.
showPluginCrashedNotification
(
msg
.
target
msg
.
data
.
messageString
msg
.
data
.
pluginID
)
;
break
;
case
"
PluginContent
:
SubmitReport
"
:
if
(
AppConstants
.
MOZ_CRASHREPORTER
)
{
this
.
submitReport
(
msg
.
data
.
runID
msg
.
data
.
keyVals
msg
.
data
.
submitURLOptIn
)
;
}
break
;
case
"
PluginContent
:
LinkClickCallback
"
:
switch
(
msg
.
data
.
name
)
{
case
"
managePlugins
"
:
case
"
openHelpPage
"
:
case
"
openPluginUpdatePage
"
:
this
[
msg
.
data
.
name
]
(
msg
.
data
.
pluginTag
)
;
break
;
}
break
;
default
:
Cu
.
reportError
(
"
gPluginHandler
did
not
expect
to
handle
message
"
+
msg
.
name
)
;
break
;
}
}
managePlugins
(
)
{
BrowserOpenAddonsMgr
(
"
addons
:
/
/
list
/
plugin
"
)
;
}
async
openPluginUpdatePage
(
pluginTag
)
{
let
url
=
await
Blocklist
.
getPluginBlockURL
(
pluginTag
)
;
openTrustedLinkIn
(
url
"
tab
"
)
;
}
submitReport
:
function
submitReport
(
runID
keyVals
submitURLOptIn
)
{
if
(
!
AppConstants
.
MOZ_CRASHREPORTER
)
{
return
;
}
Services
.
prefs
.
setBoolPref
(
"
dom
.
ipc
.
plugins
.
reportCrashURL
"
submitURLOptIn
)
;
PluginCrashReporter
.
submitCrashReport
(
runID
keyVals
)
;
}
reloadPage
(
browser
)
{
browser
.
reload
(
)
;
}
openHelpPage
(
)
{
openHelpLink
(
"
plugin
-
crashed
"
false
)
;
}
_clickToPlayNotificationEventCallback
:
function
PH_ctpEventCallback
(
event
)
{
if
(
event
=
=
"
showing
"
)
{
Services
.
telemetry
.
getHistogramById
(
"
PLUGINS_NOTIFICATION_SHOWN
"
)
.
add
(
!
this
.
options
.
primaryPlugin
)
;
let
histogramCount
=
this
.
options
.
pluginData
.
size
-
1
;
if
(
histogramCount
>
4
)
{
histogramCount
=
4
;
}
Services
.
telemetry
.
getHistogramById
(
"
PLUGINS_NOTIFICATION_PLUGIN_COUNT
"
)
.
add
(
histogramCount
)
;
}
else
if
(
event
=
=
"
dismissed
"
)
{
this
.
options
.
primaryPlugin
=
null
;
}
}
_updatePluginPermission
(
aBrowser
aPluginInfo
aNewState
)
{
let
permission
;
let
expireType
;
let
expireTime
;
let
histogram
=
Services
.
telemetry
.
getHistogramById
(
"
PLUGINS_NOTIFICATION_USER_ACTION_2
"
)
;
let
notification
=
PopupNotifications
.
getNotification
(
"
click
-
to
-
play
-
plugins
"
aBrowser
)
;
switch
(
aNewState
)
{
case
"
allownow
"
:
permission
=
Ci
.
nsIPermissionManager
.
ALLOW_ACTION
;
expireType
=
Ci
.
nsIPermissionManager
.
EXPIRE_SESSION
;
expireTime
=
Date
.
now
(
)
+
Services
.
prefs
.
getIntPref
(
this
.
PREF_SESSION_PERSIST_MINUTES
)
*
60
*
1000
;
histogram
.
add
(
0
)
;
aPluginInfo
.
fallbackType
=
Ci
.
nsIObjectLoadingContent
.
PLUGIN_ACTIVE
;
notification
.
options
.
extraAttr
=
"
active
"
;
break
;
case
"
allowalways
"
:
permission
=
Ci
.
nsIPermissionManager
.
ALLOW_ACTION
;
expireType
=
Ci
.
nsIPermissionManager
.
EXPIRE_TIME
;
expireTime
=
Date
.
now
(
)
+
Services
.
prefs
.
getIntPref
(
this
.
PREF_PERSISTENT_DAYS
)
*
24
*
60
*
60
*
1000
;
histogram
.
add
(
1
)
;
aPluginInfo
.
fallbackType
=
Ci
.
nsIObjectLoadingContent
.
PLUGIN_ACTIVE
;
notification
.
options
.
extraAttr
=
"
active
"
;
break
;
case
"
block
"
:
permission
=
Ci
.
nsIPermissionManager
.
PROMPT_ACTION
;
expireType
=
Ci
.
nsIPermissionManager
.
EXPIRE_NEVER
;
expireTime
=
0
;
histogram
.
add
(
2
)
;
switch
(
aPluginInfo
.
blocklistState
)
{
case
Ci
.
nsIBlocklistService
.
STATE_VULNERABLE_UPDATE_AVAILABLE
:
aPluginInfo
.
fallbackType
=
Ci
.
nsIObjectLoadingContent
.
PLUGIN_VULNERABLE_UPDATABLE
;
break
;
case
Ci
.
nsIBlocklistService
.
STATE_VULNERABLE_NO_UPDATE
:
aPluginInfo
.
fallbackType
=
Ci
.
nsIObjectLoadingContent
.
PLUGIN_VULNERABLE_NO_UPDATE
;
break
;
default
:
aPluginInfo
.
fallbackType
=
Ci
.
nsIObjectLoadingContent
.
PLUGIN_CLICK_TO_PLAY_QUIET
;
}
notification
.
options
.
extraAttr
=
"
inactive
"
;
break
;
case
"
blockalways
"
:
permission
=
Ci
.
nsIObjectLoadingContent
.
PLUGIN_PERMISSION_PROMPT_ACTION_QUIET
;
expireType
=
Ci
.
nsIPermissionManager
.
EXPIRE_NEVER
;
expireTime
=
0
;
histogram
.
add
(
3
)
;
aPluginInfo
.
fallbackType
=
Ci
.
nsIObjectLoadingContent
.
PLUGIN_CLICK_TO_PLAY_QUIET
;
notification
.
options
.
extraAttr
=
"
inactive
"
;
break
;
case
"
continue
"
:
aPluginInfo
.
fallbackType
=
Ci
.
nsIObjectLoadingContent
.
PLUGIN_ACTIVE
;
notification
.
options
.
extraAttr
=
"
active
"
;
break
;
case
"
continueblocking
"
:
aPluginInfo
.
fallbackType
=
Ci
.
nsIObjectLoadingContent
.
PLUGIN_CLICK_TO_PLAY_QUIET
;
notification
.
options
.
extraAttr
=
"
inactive
"
;
break
;
default
:
Cu
.
reportError
(
Error
(
"
Unexpected
plugin
state
:
"
+
aNewState
)
)
;
return
;
}
if
(
aNewState
!
=
"
continue
"
&
&
aNewState
!
=
"
continueblocking
"
)
{
let
principal
=
notification
.
options
.
principal
;
Services
.
perms
.
addFromPrincipal
(
principal
aPluginInfo
.
permissionString
permission
expireType
expireTime
)
;
aPluginInfo
.
pluginPermissionType
=
expireType
;
}
aBrowser
.
messageManager
.
sendAsyncMessage
(
"
BrowserPlugins
:
ActivatePlugins
"
{
pluginInfo
:
aPluginInfo
newState
:
aNewState
}
)
;
}
showClickToPlayNotification
(
browser
plugins
showNow
principal
location
)
{
if
(
!
principal
.
equals
(
browser
.
contentPrincipal
)
)
{
return
;
}
let
receivedURI
=
Services
.
io
.
newURI
(
location
)
;
if
(
!
browser
.
documentURI
.
equalsExceptRef
(
receivedURI
)
)
{
return
;
}
let
notification
=
PopupNotifications
.
getNotification
(
"
click
-
to
-
play
-
plugins
"
browser
)
;
let
pluginData
;
if
(
notification
)
{
pluginData
=
notification
.
options
.
pluginData
;
}
else
{
pluginData
=
new
Map
(
)
;
}
for
(
let
pluginInfo
of
plugins
)
{
if
(
pluginData
.
has
(
pluginInfo
.
permissionString
)
)
{
continue
;
}
pluginData
.
set
(
pluginInfo
.
permissionString
pluginInfo
)
;
}
let
primaryPluginPermission
=
null
;
if
(
showNow
)
{
primaryPluginPermission
=
plugins
[
0
]
.
permissionString
;
}
if
(
notification
)
{
if
(
showNow
)
{
notification
.
options
.
primaryPlugin
=
primaryPluginPermission
;
notification
.
reshow
(
)
;
}
return
;
}
if
(
plugins
.
length
=
=
1
)
{
let
pluginInfo
=
plugins
[
0
]
;
let
isWindowPrivate
=
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
;
let
active
=
pluginInfo
.
fallbackType
=
=
Ci
.
nsIObjectLoadingContent
.
PLUGIN_ACTIVE
;
let
options
=
{
dismissed
:
!
showNow
hideClose
:
!
Services
.
prefs
.
getBoolPref
(
"
privacy
.
permissionPrompts
.
showCloseButton
"
)
persistent
:
showNow
eventCallback
:
this
.
_clickToPlayNotificationEventCallback
primaryPlugin
:
primaryPluginPermission
popupIconClass
:
"
plugin
-
icon
"
extraAttr
:
active
?
"
active
"
:
"
inactive
"
pluginData
principal
}
;
let
description
;
if
(
pluginInfo
.
fallbackType
=
=
Ci
.
nsIObjectLoadingContent
.
PLUGIN_VULNERABLE_UPDATABLE
)
{
description
=
gNavigatorBundle
.
getString
(
"
flashActivate
.
outdated
.
message
"
)
;
}
else
{
description
=
gNavigatorBundle
.
getString
(
"
flashActivate
.
message
"
)
;
}
let
badge
=
document
.
getElementById
(
"
plugin
-
icon
-
badge
"
)
;
badge
.
setAttribute
(
"
animate
"
"
true
"
)
;
badge
.
addEventListener
(
"
animationend
"
function
animListener
(
event
)
{
if
(
event
.
animationName
=
=
"
blink
-
badge
"
&
&
badge
.
hasAttribute
(
"
animate
"
)
)
{
badge
.
removeAttribute
(
"
animate
"
)
;
badge
.
removeEventListener
(
"
animationend
"
animListener
)
;
}
}
)
;
let
weakBrowser
=
Cu
.
getWeakReference
(
browser
)
;
let
mainAction
=
{
callback
:
(
{
checkboxChecked
}
)
=
>
{
let
browserRef
=
weakBrowser
.
get
(
)
;
if
(
browserRef
)
{
if
(
checkboxChecked
)
{
this
.
_updatePluginPermission
(
browserRef
pluginInfo
"
allowalways
"
)
;
}
else
if
(
pluginInfo
.
fallbackType
=
=
Ci
.
nsIObjectLoadingContent
.
PLUGIN_ACTIVE
)
{
this
.
_updatePluginPermission
(
browserRef
pluginInfo
"
continue
"
)
;
}
else
{
this
.
_updatePluginPermission
(
browserRef
pluginInfo
"
allownow
"
)
;
}
}
}
label
:
gNavigatorBundle
.
getString
(
"
flashActivate
.
allow
"
)
accessKey
:
gNavigatorBundle
.
getString
(
"
flashActivate
.
allow
.
accesskey
"
)
dismiss
:
true
}
;
let
secondaryActions
=
null
;
if
(
!
isWindowPrivate
)
{
options
.
checkbox
=
{
label
:
gNavigatorBundle
.
getString
(
"
flashActivate
.
remember
"
)
}
;
secondaryActions
=
[
{
callback
:
(
{
checkboxChecked
}
)
=
>
{
let
browserRef
=
weakBrowser
.
get
(
)
;
if
(
browserRef
)
{
if
(
checkboxChecked
)
{
this
.
_updatePluginPermission
(
browserRef
pluginInfo
"
blockalways
"
)
;
}
else
if
(
pluginInfo
.
fallbackType
=
=
Ci
.
nsIObjectLoadingContent
.
PLUGIN_ACTIVE
)
{
this
.
_updatePluginPermission
(
browserRef
pluginInfo
"
block
"
)
;
}
else
{
this
.
_updatePluginPermission
(
browserRef
pluginInfo
"
continueblocking
"
)
;
}
}
}
label
:
gNavigatorBundle
.
getString
(
"
flashActivate
.
noAllow
"
)
accessKey
:
gNavigatorBundle
.
getString
(
"
flashActivate
.
noAllow
.
accesskey
"
)
dismiss
:
true
}
]
;
}
PopupNotifications
.
show
(
browser
"
click
-
to
-
play
-
plugins
"
description
"
plugins
-
notification
-
icon
"
mainAction
secondaryActions
options
)
;
let
haveInsecure
=
false
;
switch
(
pluginInfo
.
fallbackType
)
{
case
Ci
.
nsIObjectLoadingContent
.
PLUGIN_VULNERABLE_UPDATABLE
:
case
Ci
.
nsIObjectLoadingContent
.
PLUGIN_VULNERABLE_NO_UPDATE
:
haveInsecure
=
true
;
}
document
.
getElementById
(
"
plugins
-
notification
-
icon
"
)
.
classList
.
toggle
(
"
plugin
-
blocked
"
haveInsecure
)
;
}
else
{
this
.
removeNotification
(
browser
"
click
-
to
-
play
-
plugins
"
)
;
}
}
removeNotification
(
browser
name
)
{
let
notification
=
PopupNotifications
.
getNotification
(
name
browser
)
;
if
(
notification
)
PopupNotifications
.
remove
(
notification
)
;
}
contextMenuCommand
(
browser
plugin
command
)
{
browser
.
messageManager
.
sendAsyncMessage
(
"
BrowserPlugins
:
ContextMenuCommand
"
{
command
}
{
plugin
}
)
;
}
NPAPIPluginCrashed
(
subject
topic
data
)
{
let
propertyBag
=
subject
;
if
(
!
(
propertyBag
instanceof
Ci
.
nsIPropertyBag2
)
|
|
!
(
propertyBag
instanceof
Ci
.
nsIWritablePropertyBag2
)
|
|
!
propertyBag
.
hasKey
(
"
runID
"
)
|
|
!
propertyBag
.
hasKey
(
"
pluginName
"
)
)
{
Cu
.
reportError
(
"
A
NPAPI
plugin
crashed
but
the
properties
of
this
plugin
"
+
"
cannot
be
read
.
"
)
;
return
;
}
let
runID
=
propertyBag
.
getPropertyAsUint32
(
"
runID
"
)
;
let
uglyPluginName
=
propertyBag
.
getPropertyAsAString
(
"
pluginName
"
)
;
let
pluginName
=
BrowserUtils
.
makeNicePluginName
(
uglyPluginName
)
;
let
pluginDumpID
=
propertyBag
.
getPropertyAsAString
(
"
pluginDumpID
"
)
;
let
state
;
if
(
!
AppConstants
.
MOZ_CRASHREPORTER
|
|
!
gCrashReporter
.
enabled
)
{
state
=
"
noSubmit
"
;
}
else
if
(
!
pluginDumpID
)
{
state
=
"
noReport
"
;
}
else
{
state
=
"
please
"
;
}
let
mm
=
window
.
getGroupMessageManager
(
"
browsers
"
)
;
mm
.
broadcastAsyncMessage
(
"
BrowserPlugins
:
NPAPIPluginProcessCrashed
"
{
pluginName
runID
state
}
)
;
}
showPluginCrashedNotification
(
browser
messageString
pluginID
)
{
let
notificationBox
=
gBrowser
.
getNotificationBox
(
browser
)
;
let
notification
=
notificationBox
.
getNotificationWithValue
(
"
plugin
-
crashed
"
)
;
if
(
notification
)
{
return
;
}
let
priority
=
notificationBox
.
PRIORITY_WARNING_MEDIUM
;
let
iconURL
=
"
chrome
:
/
/
global
/
skin
/
plugins
/
pluginGeneric
.
svg
"
;
let
reloadLabel
=
gNavigatorBundle
.
getString
(
"
crashedpluginsMessage
.
reloadButton
.
label
"
)
;
let
reloadKey
=
gNavigatorBundle
.
getString
(
"
crashedpluginsMessage
.
reloadButton
.
accesskey
"
)
;
let
buttons
=
[
{
label
:
reloadLabel
accessKey
:
reloadKey
popup
:
null
callback
(
)
{
browser
.
reload
(
)
;
}
}
]
;
if
(
AppConstants
.
MOZ_CRASHREPORTER
&
&
PluginCrashReporter
.
hasCrashReport
(
pluginID
)
)
{
let
submitLabel
=
gNavigatorBundle
.
getString
(
"
crashedpluginsMessage
.
submitButton
.
label
"
)
;
let
submitKey
=
gNavigatorBundle
.
getString
(
"
crashedpluginsMessage
.
submitButton
.
accesskey
"
)
;
let
submitButton
=
{
label
:
submitLabel
accessKey
:
submitKey
popup
:
null
callback
:
(
)
=
>
{
PluginCrashReporter
.
submitCrashReport
(
pluginID
)
;
}
}
;
buttons
.
push
(
submitButton
)
;
}
notification
=
notificationBox
.
appendNotification
(
messageString
"
plugin
-
crashed
"
iconURL
priority
buttons
)
;
let
link
=
notification
.
ownerDocument
.
createXULElement
(
"
label
"
)
;
link
.
className
=
"
text
-
link
"
;
link
.
setAttribute
(
"
value
"
gNavigatorBundle
.
getString
(
"
crashedpluginsMessage
.
learnMore
"
)
)
;
let
crashurl
=
formatURL
(
"
app
.
support
.
baseURL
"
true
)
;
crashurl
+
=
"
plugin
-
crashed
-
notificationbar
"
;
link
.
href
=
crashurl
;
notification
.
messageText
.
appendChild
(
link
)
;
}
}
;
gPluginHandler
.
init
(
)
;
