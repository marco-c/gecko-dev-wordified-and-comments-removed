var
TrackingProtection
=
{
reportBreakageLabel
:
"
trackingprotection
"
telemetryIdentifier
:
"
tp
"
PREF_ENABLED_GLOBALLY
:
"
privacy
.
trackingprotection
.
enabled
"
PREF_ENABLED_IN_PRIVATE_WINDOWS
:
"
privacy
.
trackingprotection
.
pbmode
.
enabled
"
PREF_UI_ENABLED
:
"
browser
.
contentblocking
.
trackingprotection
.
control
-
center
.
ui
.
enabled
"
PREF_TRACKING_TABLE
:
"
urlclassifier
.
trackingTable
"
PREF_TRACKING_ANNOTATION_TABLE
:
"
urlclassifier
.
trackingAnnotationTable
"
enabledGlobally
:
false
enabledInPrivateWindows
:
false
get
categoryItem
(
)
{
delete
this
.
categoryItem
;
return
this
.
categoryItem
=
document
.
getElementById
(
"
identity
-
popup
-
content
-
blocking
-
category
-
tracking
-
protection
"
)
;
}
get
subViewList
(
)
{
delete
this
.
subViewList
;
return
this
.
subViewList
=
document
.
getElementById
(
"
identity
-
popup
-
trackersView
-
list
"
)
;
}
get
strictInfo
(
)
{
delete
this
.
strictInfo
;
return
this
.
strictInfo
=
document
.
getElementById
(
"
identity
-
popup
-
trackersView
-
strict
-
info
"
)
;
}
init
(
)
{
this
.
updateEnabled
(
)
;
Services
.
prefs
.
addObserver
(
this
.
PREF_ENABLED_GLOBALLY
this
)
;
Services
.
prefs
.
addObserver
(
this
.
PREF_ENABLED_IN_PRIVATE_WINDOWS
this
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
visible
"
this
.
PREF_UI_ENABLED
false
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
trackingTable
"
this
.
PREF_TRACKING_TABLE
false
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
trackingAnnotationTable
"
this
.
PREF_TRACKING_ANNOTATION_TABLE
false
)
;
}
uninit
(
)
{
Services
.
prefs
.
removeObserver
(
this
.
PREF_ENABLED_GLOBALLY
this
)
;
Services
.
prefs
.
removeObserver
(
this
.
PREF_ENABLED_IN_PRIVATE_WINDOWS
this
)
;
}
observe
(
)
{
this
.
updateEnabled
(
)
;
}
get
enabled
(
)
{
return
this
.
enabledGlobally
|
|
(
this
.
enabledInPrivateWindows
&
&
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
;
}
updateEnabled
(
)
{
this
.
enabledGlobally
=
Services
.
prefs
.
getBoolPref
(
this
.
PREF_ENABLED_GLOBALLY
)
;
this
.
enabledInPrivateWindows
=
Services
.
prefs
.
getBoolPref
(
this
.
PREF_ENABLED_IN_PRIVATE_WINDOWS
)
;
}
isBlockerActivated
(
state
)
{
return
state
&
Ci
.
nsIWebProgressListener
.
STATE_BLOCKED_TRACKING_CONTENT
;
}
isAllowing
(
state
)
{
return
state
&
Ci
.
nsIWebProgressListener
.
STATE_LOADED_TRACKING_CONTENT
;
}
async
updateSubView
(
)
{
let
previousURI
=
gBrowser
.
currentURI
.
spec
;
let
previousWindow
=
gBrowser
.
selectedBrowser
.
innerWindowID
;
let
contentBlockingLogJSON
=
await
gBrowser
.
selectedBrowser
.
getContentBlockingLog
(
)
;
let
contentBlockingLog
=
JSON
.
parse
(
contentBlockingLogJSON
)
;
this
.
strictInfo
.
hidden
=
this
.
enabled
;
let
fragment
=
document
.
createDocumentFragment
(
)
;
for
(
let
[
origin
actions
]
of
Object
.
entries
(
contentBlockingLog
)
)
{
let
listItem
=
await
this
.
_createListItem
(
origin
actions
)
;
if
(
listItem
)
{
fragment
.
appendChild
(
listItem
)
;
}
}
if
(
previousURI
=
=
gBrowser
.
currentURI
.
spec
&
&
previousWindow
=
=
gBrowser
.
selectedBrowser
.
innerWindowID
)
{
this
.
subViewList
.
textContent
=
"
"
;
this
.
subViewList
.
append
(
fragment
)
;
}
}
_isOnTrackingTable
(
uri
)
{
if
(
this
.
trackingTable
=
=
this
.
trackingAnnotationTable
)
{
return
true
;
}
return
new
Promise
(
resolve
=
>
{
classifierService
.
asyncClassifyLocalWithTables
(
uri
this
.
trackingTable
[
]
[
]
(
code
list
)
=
>
resolve
(
!
!
list
)
)
;
}
)
;
}
async
_createListItem
(
origin
actions
)
{
let
isDetected
=
false
;
let
isAllowed
=
false
;
for
(
let
[
state
]
of
actions
)
{
isAllowed
=
isAllowed
|
|
this
.
isAllowing
(
state
)
;
isDetected
=
isDetected
|
|
isAllowed
|
|
this
.
isBlockerActivated
(
state
)
;
}
if
(
!
isDetected
)
{
return
null
;
}
let
uri
=
Services
.
io
.
newURI
(
origin
)
;
let
isTracker
=
await
this
.
_isOnTrackingTable
(
uri
)
;
if
(
!
isTracker
)
{
return
null
;
}
let
listItem
=
document
.
createXULElement
(
"
hbox
"
)
;
listItem
.
className
=
"
identity
-
popup
-
trackersView
-
list
-
item
"
;
listItem
.
classList
.
toggle
(
"
allowed
"
isAllowed
)
;
let
image
=
document
.
createXULElement
(
"
image
"
)
;
listItem
.
append
(
image
)
;
let
label
=
document
.
createXULElement
(
"
label
"
)
;
label
.
value
=
uri
.
host
;
label
.
setAttribute
(
"
crop
"
"
end
"
)
;
listItem
.
append
(
label
)
;
return
listItem
;
}
}
;
var
ThirdPartyCookies
=
{
telemetryIdentifier
:
"
cr
"
PREF_ENABLED
:
"
network
.
cookie
.
cookieBehavior
"
PREF_REPORT_BREAKAGE_ENABLED
:
"
browser
.
contentblocking
.
rejecttrackers
.
reportBreakage
.
enabled
"
PREF_ENABLED_VALUES
:
[
Ci
.
nsICookieService
.
BEHAVIOR_REJECT_FOREIGN
Ci
.
nsICookieService
.
BEHAVIOR_REJECT_TRACKER
]
PREF_UI_ENABLED
:
"
browser
.
contentblocking
.
rejecttrackers
.
control
-
center
.
ui
.
enabled
"
get
categoryItem
(
)
{
delete
this
.
categoryItem
;
return
this
.
categoryItem
=
document
.
getElementById
(
"
identity
-
popup
-
content
-
blocking
-
category
-
3rdpartycookies
"
)
;
}
get
reportBreakageLabel
(
)
{
switch
(
this
.
behaviorPref
)
{
case
Ci
.
nsICookieService
.
BEHAVIOR_ACCEPT
:
return
"
nocookiesblocked
"
;
case
Ci
.
nsICookieService
.
BEHAVIOR_REJECT_FOREIGN
:
return
"
allthirdpartycookiesblocked
"
;
case
Ci
.
nsICookieService
.
BEHAVIOR_REJECT
:
return
"
allcookiesblocked
"
;
case
Ci
.
nsICookieService
.
BEHAVIOR_LIMIT_FOREIGN
:
return
"
cookiesfromunvisitedsitesblocked
"
;
default
:
Cu
.
reportError
(
Error
:
Unknown
cookieBehavior
pref
observed
:
{
this
.
behaviorPref
}
)
;
case
Ci
.
nsICookieService
.
BEHAVIOR_REJECT_TRACKER
:
return
"
cookierestrictions
"
;
}
}
get
categoryLabelDefault
(
)
{
delete
this
.
categoryLabelDefault
;
return
this
.
categoryLabelDefault
=
document
.
getElementById
(
"
identity
-
popup
-
content
-
blocking
-
category
-
label
-
default
"
)
;
}
get
categoryLabelTrackers
(
)
{
delete
this
.
categoryLabelTrackers
;
return
this
.
categoryLabelTrackers
=
document
.
getElementById
(
"
identity
-
popup
-
content
-
blocking
-
category
-
label
-
trackers
"
)
;
}
updateCategoryLabel
(
)
{
let
rejectTrackers
=
this
.
behaviorPref
=
=
Ci
.
nsICookieService
.
BEHAVIOR_REJECT_TRACKER
;
this
.
categoryLabelDefault
.
hidden
=
rejectTrackers
;
this
.
categoryLabelTrackers
.
hidden
=
!
rejectTrackers
;
}
init
(
)
{
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
behaviorPref
"
this
.
PREF_ENABLED
Ci
.
nsICookieService
.
BEHAVIOR_ACCEPT
this
.
updateCategoryLabel
.
bind
(
this
)
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
visible
"
this
.
PREF_UI_ENABLED
false
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
reportBreakageEnabled
"
this
.
PREF_REPORT_BREAKAGE_ENABLED
false
)
;
this
.
updateCategoryLabel
(
)
;
}
get
enabled
(
)
{
return
this
.
PREF_ENABLED_VALUES
.
includes
(
this
.
behaviorPref
)
;
}
isBlockerActivated
(
state
)
{
return
(
state
&
Ci
.
nsIWebProgressListener
.
STATE_COOKIES_BLOCKED_TRACKER
)
!
=
0
|
|
(
state
&
Ci
.
nsIWebProgressListener
.
STATE_COOKIES_BLOCKED_FOREIGN
)
!
=
0
;
}
}
;
var
ContentBlocking
=
{
MAX_INTROS
:
20
PREF_ANIMATIONS_ENABLED
:
"
toolkit
.
cosmeticAnimations
.
enabled
"
PREF_REPORT_BREAKAGE_ENABLED
:
"
browser
.
contentblocking
.
reportBreakage
.
enabled
"
PREF_REPORT_BREAKAGE_URL
:
"
browser
.
contentblocking
.
reportBreakage
.
url
"
PREF_INTRO_COUNT_CB
:
"
browser
.
contentblocking
.
introCount
"
PREF_CB_CATEGORY
:
"
browser
.
contentblocking
.
category
"
CATEGORY_PREFS
:
{
strict
:
[
[
TrackingProtection
.
PREF_TRACKING_TABLE
null
]
[
ThirdPartyCookies
.
PREF_ENABLED
Ci
.
nsICookieService
.
BEHAVIOR_REJECT_FOREIGN
]
[
TrackingProtection
.
PREF_ENABLED_IN_PRIVATE_WINDOWS
true
]
[
TrackingProtection
.
PREF_ENABLED_GLOBALLY
true
]
]
standard
:
[
[
TrackingProtection
.
PREF_TRACKING_TABLE
null
]
[
ThirdPartyCookies
.
PREF_ENABLED
null
]
[
TrackingProtection
.
PREF_ENABLED_IN_PRIVATE_WINDOWS
null
]
[
TrackingProtection
.
PREF_ENABLED_GLOBALLY
null
]
]
}
content
:
null
icon
:
null
activeTooltipText
:
null
disabledTooltipText
:
null
switchingCategory
:
false
get
prefIntroCount
(
)
{
return
this
.
PREF_INTRO_COUNT_CB
;
}
get
appMenuLabel
(
)
{
delete
this
.
appMenuLabel
;
return
this
.
appMenuLabel
=
document
.
getElementById
(
"
appMenu
-
tp
-
label
"
)
;
}
get
identityPopup
(
)
{
delete
this
.
identityPopup
;
return
this
.
identityPopup
=
document
.
getElementById
(
"
identity
-
popup
"
)
;
}
strings
:
{
get
appMenuTitle
(
)
{
delete
this
.
appMenuTitle
;
return
this
.
appMenuTitle
=
gNavigatorBundle
.
getString
(
"
contentBlocking
.
title
"
)
;
}
get
appMenuTooltip
(
)
{
delete
this
.
appMenuTooltip
;
return
this
.
appMenuTooltip
=
gNavigatorBundle
.
getString
(
"
contentBlocking
.
tooltip
"
)
;
}
}
blockers
:
[
TrackingProtection
ThirdPartyCookies
]
get
_baseURIForChannelClassifier
(
)
{
try
{
return
Services
.
io
.
newURI
(
"
https
:
/
/
"
+
gBrowser
.
selectedBrowser
.
currentURI
.
hostPort
)
;
}
catch
(
e
)
{
return
null
;
}
}
init
(
)
{
let
=
selector
=
>
document
.
querySelector
(
selector
)
;
this
.
content
=
(
"
#
identity
-
popup
-
content
-
blocking
-
content
"
)
;
this
.
icon
=
(
"
#
tracking
-
protection
-
icon
"
)
;
this
.
iconBox
=
(
"
#
tracking
-
protection
-
icon
-
box
"
)
;
this
.
animatedIcon
=
(
"
#
tracking
-
protection
-
icon
-
animatable
-
image
"
)
;
this
.
animatedIcon
.
addEventListener
(
"
animationend
"
(
)
=
>
this
.
iconBox
.
removeAttribute
(
"
animate
"
)
)
;
this
.
identityPopupMultiView
=
(
"
#
identity
-
popup
-
multiView
"
)
;
this
.
reportBreakageButton
=
(
"
#
identity
-
popup
-
content
-
blocking
-
report
-
breakage
"
)
;
this
.
reportBreakageURL
=
(
"
#
identity
-
popup
-
breakageReportView
-
collection
-
url
"
)
;
this
.
reportBreakageLearnMore
=
(
"
#
identity
-
popup
-
breakageReportView
-
learn
-
more
"
)
;
let
baseURL
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
;
this
.
reportBreakageLearnMore
.
href
=
baseURL
+
"
blocking
-
breakage
"
;
this
.
updateAnimationsEnabled
=
(
)
=
>
{
this
.
iconBox
.
toggleAttribute
(
"
animationsenabled
"
Services
.
prefs
.
getBoolPref
(
this
.
PREF_ANIMATIONS_ENABLED
false
)
)
;
}
;
for
(
let
blocker
of
this
.
blockers
)
{
if
(
blocker
.
init
)
{
blocker
.
init
(
)
;
}
}
this
.
updateAnimationsEnabled
(
)
;
Services
.
prefs
.
addObserver
(
this
.
PREF_ANIMATIONS_ENABLED
this
.
updateAnimationsEnabled
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
reportBreakageEnabled
"
this
.
PREF_REPORT_BREAKAGE_ENABLED
false
)
;
this
.
appMenuLabel
.
setAttribute
(
"
label
"
this
.
strings
.
appMenuTitle
)
;
this
.
appMenuLabel
.
setAttribute
(
"
tooltiptext
"
this
.
strings
.
appMenuTooltip
)
;
this
.
activeTooltipText
=
gNavigatorBundle
.
getString
(
"
trackingProtection
.
icon
.
activeTooltip
"
)
;
this
.
disabledTooltipText
=
gNavigatorBundle
.
getString
(
"
trackingProtection
.
icon
.
disabledTooltip
"
)
;
this
.
matchCBCategory
=
this
.
matchCBCategory
.
bind
(
this
)
;
this
.
updateCBCategory
=
this
.
updateCBCategory
.
bind
(
this
)
;
this
.
matchCBCategory
(
)
;
Services
.
prefs
.
addObserver
(
TrackingProtection
.
PREF_ENABLED_GLOBALLY
this
.
matchCBCategory
)
;
Services
.
prefs
.
addObserver
(
TrackingProtection
.
PREF_ENABLED_IN_PRIVATE_WINDOWS
this
.
matchCBCategory
)
;
Services
.
prefs
.
addObserver
(
ThirdPartyCookies
.
PREF_ENABLED
this
.
matchCBCategory
)
;
Services
.
prefs
.
addObserver
(
this
.
PREF_CB_CATEGORY
this
.
updateCBCategory
)
;
}
uninit
(
)
{
for
(
let
blocker
of
this
.
blockers
)
{
if
(
blocker
.
uninit
)
{
blocker
.
uninit
(
)
;
}
}
Services
.
prefs
.
removeObserver
(
this
.
PREF_ANIMATIONS_ENABLED
this
.
updateAnimationsEnabled
)
;
Services
.
prefs
.
removeObserver
(
TrackingProtection
.
PREF_ENABLED_GLOBALLY
this
.
matchCBCategory
)
;
Services
.
prefs
.
removeObserver
(
TrackingProtection
.
PREF_ENABLED_IN_PRIVATE_WINDOWS
this
.
matchCBCategory
)
;
Services
.
prefs
.
removeObserver
(
ThirdPartyCookies
.
PREF_ENABLED
this
.
matchCBCategory
)
;
Services
.
prefs
.
removeObserver
(
this
.
PREF_CB_CATEGORY
this
.
updateCBCategory
)
;
}
hideIdentityPopupAndReload
(
)
{
this
.
identityPopup
.
hidePopup
(
)
;
BrowserReload
(
)
;
}
openPreferences
(
origin
)
{
openPreferences
(
"
privacy
-
trackingprotection
"
{
origin
}
)
;
}
backToMainView
(
)
{
this
.
identityPopupMultiView
.
goBack
(
)
;
}
submitBreakageReport
(
)
{
this
.
identityPopup
.
hidePopup
(
)
;
let
reportEndpoint
=
Services
.
prefs
.
getStringPref
(
this
.
PREF_REPORT_BREAKAGE_URL
)
;
if
(
!
reportEndpoint
)
{
return
;
}
let
formData
=
new
FormData
(
)
;
formData
.
set
(
"
title
"
this
.
reportURI
.
host
)
;
let
urlWithoutQuery
=
this
.
reportURI
.
asciiSpec
.
replace
(
this
.
reportURI
.
query
"
"
)
;
let
body
=
Full
URL
:
{
urlWithoutQuery
}
\
n
;
body
+
=
userAgent
:
{
navigator
.
userAgent
}
\
n
;
body
+
=
"
\
n
*
*
Preferences
*
*
\
n
"
;
body
+
=
{
TrackingProtection
.
PREF_ENABLED_GLOBALLY
}
:
{
Services
.
prefs
.
getBoolPref
(
TrackingProtection
.
PREF_ENABLED_GLOBALLY
)
}
\
n
;
body
+
=
{
TrackingProtection
.
PREF_ENABLED_IN_PRIVATE_WINDOWS
}
:
{
Services
.
prefs
.
getBoolPref
(
TrackingProtection
.
PREF_ENABLED_IN_PRIVATE_WINDOWS
)
}
\
n
;
body
+
=
{
TrackingProtection
.
PREF_UI_ENABLED
}
:
{
Services
.
prefs
.
getBoolPref
(
TrackingProtection
.
PREF_UI_ENABLED
)
}
\
n
;
body
+
=
urlclassifier
.
trackingTable
:
{
Services
.
prefs
.
getStringPref
(
"
urlclassifier
.
trackingTable
"
)
}
\
n
;
body
+
=
network
.
http
.
referer
.
defaultPolicy
:
{
Services
.
prefs
.
getIntPref
(
"
network
.
http
.
referer
.
defaultPolicy
"
)
}
\
n
;
body
+
=
network
.
http
.
referer
.
defaultPolicy
.
pbmode
:
{
Services
.
prefs
.
getIntPref
(
"
network
.
http
.
referer
.
defaultPolicy
.
pbmode
"
)
}
\
n
;
body
+
=
{
ThirdPartyCookies
.
PREF_UI_ENABLED
}
:
{
Services
.
prefs
.
getBoolPref
(
ThirdPartyCookies
.
PREF_UI_ENABLED
)
}
\
n
;
body
+
=
{
ThirdPartyCookies
.
PREF_ENABLED
}
:
{
Services
.
prefs
.
getIntPref
(
ThirdPartyCookies
.
PREF_ENABLED
)
}
\
n
;
body
+
=
network
.
cookie
.
lifetimePolicy
:
{
Services
.
prefs
.
getIntPref
(
"
network
.
cookie
.
lifetimePolicy
"
)
}
\
n
;
body
+
=
privacy
.
restrict3rdpartystorage
.
expiration
:
{
Services
.
prefs
.
getIntPref
(
"
privacy
.
restrict3rdpartystorage
.
expiration
"
)
}
\
n
;
let
comments
=
document
.
getElementById
(
"
identity
-
popup
-
breakageReportView
-
collection
-
comments
"
)
;
body
+
=
"
\
n
*
*
Comments
*
*
\
n
"
+
comments
.
value
;
formData
.
set
(
"
body
"
body
)
;
let
activatedBlockers
=
[
]
;
for
(
let
blocker
of
this
.
blockers
)
{
if
(
blocker
.
activated
)
{
activatedBlockers
.
push
(
blocker
.
reportBreakageLabel
)
;
}
}
if
(
activatedBlockers
.
length
)
{
formData
.
set
(
"
labels
"
activatedBlockers
.
join
(
"
"
)
)
;
}
fetch
(
reportEndpoint
{
method
:
"
POST
"
credentials
:
"
omit
"
body
:
formData
}
)
.
then
(
function
(
response
)
{
if
(
!
response
.
ok
)
{
Cu
.
reportError
(
Content
Blocking
report
to
{
reportEndpoint
}
failed
with
status
{
response
.
status
}
)
;
}
}
)
.
catch
(
Cu
.
reportError
)
;
}
showReportBreakageSubview
(
)
{
this
.
reportURI
=
gBrowser
.
currentURI
;
let
urlWithoutQuery
=
this
.
reportURI
.
asciiSpec
.
replace
(
"
?
"
+
this
.
reportURI
.
query
"
"
)
;
this
.
reportBreakageURL
.
textContent
=
urlWithoutQuery
;
this
.
identityPopupMultiView
.
showSubView
(
"
identity
-
popup
-
breakageReportView
"
)
;
}
async
showTrackersSubview
(
)
{
await
TrackingProtection
.
updateSubView
(
)
;
this
.
identityPopupMultiView
.
showSubView
(
"
identity
-
popup
-
trackersView
"
)
;
}
shieldHistogramAdd
(
value
)
{
if
(
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
{
return
;
}
Services
.
telemetry
.
getHistogramById
(
"
TRACKING_PROTECTION_SHIELD
"
)
.
add
(
value
)
;
}
onSecurityChange
(
oldState
state
webProgress
isSimulated
contentBlockingLogJSON
)
{
let
baseURI
=
this
.
_baseURIForChannelClassifier
;
if
(
!
baseURI
)
{
this
.
iconBox
.
removeAttribute
(
"
animate
"
)
;
this
.
iconBox
.
removeAttribute
(
"
active
"
)
;
this
.
iconBox
.
removeAttribute
(
"
hasException
"
)
;
return
;
}
if
(
webProgress
.
isTopLevel
)
{
this
.
iconBox
.
removeAttribute
(
"
animate
"
)
;
}
let
anyBlockerActivated
=
false
;
for
(
let
blocker
of
this
.
blockers
)
{
blocker
.
activated
=
blocker
.
isBlockerActivated
(
state
)
;
blocker
.
categoryItem
.
classList
.
toggle
(
"
blocked
"
blocker
.
enabled
)
;
blocker
.
categoryItem
.
hidden
=
!
blocker
.
visible
;
anyBlockerActivated
=
anyBlockerActivated
|
|
blocker
.
activated
;
}
let
active
=
anyBlockerActivated
;
let
isAllowing
=
state
&
Ci
.
nsIWebProgressListener
.
STATE_LOADED_TRACKING_CONTENT
;
let
detected
=
anyBlockerActivated
|
|
isAllowing
;
let
isBrowserPrivate
=
PrivateBrowsingUtils
.
isBrowserPrivate
(
gBrowser
.
selectedBrowser
)
;
let
type
=
isBrowserPrivate
?
"
trackingprotection
-
pb
"
:
"
trackingprotection
"
;
let
hasException
=
Services
.
perms
.
testExactPermission
(
baseURI
type
)
=
=
Services
.
perms
.
ALLOW_ACTION
;
this
.
content
.
toggleAttribute
(
"
detected
"
detected
)
;
this
.
content
.
toggleAttribute
(
"
hasException
"
hasException
)
;
this
.
content
.
toggleAttribute
(
"
active
"
active
)
;
this
.
iconBox
.
toggleAttribute
(
"
active
"
active
)
;
this
.
iconBox
.
toggleAttribute
(
"
hasException
"
hasException
)
;
if
(
this
.
reportBreakageEnabled
|
|
(
ThirdPartyCookies
.
reportBreakageEnabled
&
&
ThirdPartyCookies
.
activated
&
&
!
TrackingProtection
.
activated
)
)
{
this
.
reportBreakageButton
.
removeAttribute
(
"
hidden
"
)
;
}
else
{
this
.
reportBreakageButton
.
setAttribute
(
"
hidden
"
"
true
"
)
;
}
if
(
isSimulated
)
{
this
.
iconBox
.
removeAttribute
(
"
animate
"
)
;
}
else
if
(
active
&
&
webProgress
.
isTopLevel
)
{
this
.
iconBox
.
setAttribute
(
"
animate
"
"
true
"
)
;
if
(
!
isBrowserPrivate
)
{
let
introCount
=
Services
.
prefs
.
getIntPref
(
this
.
prefIntroCount
)
;
if
(
introCount
<
this
.
MAX_INTROS
)
{
Services
.
prefs
.
setIntPref
(
this
.
prefIntroCount
+
+
introCount
)
;
Services
.
prefs
.
savePrefFile
(
null
)
;
this
.
showIntroPanel
(
)
;
}
}
}
if
(
hasException
)
{
this
.
iconBox
.
setAttribute
(
"
tooltiptext
"
this
.
disabledTooltipText
)
;
this
.
shieldHistogramAdd
(
1
)
;
}
else
if
(
active
)
{
this
.
iconBox
.
setAttribute
(
"
tooltiptext
"
this
.
activeTooltipText
)
;
this
.
shieldHistogramAdd
(
2
)
;
}
else
{
this
.
iconBox
.
removeAttribute
(
"
tooltiptext
"
)
;
this
.
shieldHistogramAdd
(
0
)
;
}
}
disableForCurrentPage
(
)
{
let
baseURI
=
this
.
_baseURIForChannelClassifier
;
if
(
PrivateBrowsingUtils
.
isBrowserPrivate
(
gBrowser
.
selectedBrowser
)
)
{
PrivateBrowsingUtils
.
addToTrackingAllowlist
(
baseURI
)
;
}
else
{
Services
.
perms
.
add
(
baseURI
"
trackingprotection
"
Services
.
perms
.
ALLOW_ACTION
)
;
}
this
.
hideIdentityPopupAndReload
(
)
;
}
enableForCurrentPage
(
)
{
let
baseURI
=
this
.
_baseURIForChannelClassifier
;
if
(
PrivateBrowsingUtils
.
isBrowserPrivate
(
gBrowser
.
selectedBrowser
)
)
{
PrivateBrowsingUtils
.
removeFromTrackingAllowlist
(
baseURI
)
;
}
else
{
Services
.
perms
.
remove
(
baseURI
"
trackingprotection
"
)
;
}
this
.
hideIdentityPopupAndReload
(
)
;
}
dontShowIntroPanelAgain
(
)
{
if
(
!
PrivateBrowsingUtils
.
isBrowserPrivate
(
gBrowser
.
selectedBrowser
)
)
{
Services
.
prefs
.
setIntPref
(
this
.
prefIntroCount
this
.
MAX_INTROS
)
;
Services
.
prefs
.
savePrefFile
(
null
)
;
}
}
async
showIntroPanel
(
)
{
let
brandBundle
=
document
.
getElementById
(
"
bundle_brand
"
)
;
let
brandShortName
=
brandBundle
.
getString
(
"
brandShortName
"
)
;
let
introTitle
=
gNavigatorBundle
.
getFormattedString
(
"
contentBlocking
.
intro
.
title
"
[
brandShortName
]
)
;
let
introDescription
;
let
variation
;
if
(
TrackingProtection
.
enabledGlobally
)
{
introDescription
=
gNavigatorBundle
.
getString
(
"
contentBlocking
.
intro
.
v2
.
description
"
)
;
variation
=
2
;
}
else
{
introDescription
=
gNavigatorBundle
.
getFormattedString
(
"
contentBlocking
.
intro
.
v1
.
description
"
[
brandShortName
]
)
;
variation
=
1
;
}
let
openStep2
=
(
)
=
>
{
this
.
dontShowIntroPanelAgain
(
)
;
let
nextURL
=
Services
.
urlFormatter
.
formatURLPref
(
"
privacy
.
trackingprotection
.
introURL
"
)
+
?
step
=
2
&
newtab
=
true
&
variation
=
{
variation
}
;
switchToTabHavingURI
(
nextURL
true
{
ignoreFragment
:
"
whenComparingAndReplace
"
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
}
)
;
}
;
let
buttons
=
[
{
label
:
gNavigatorBundle
.
getString
(
"
trackingProtection
.
intro
.
step1of3
"
)
style
:
"
text
"
}
{
callback
:
openStep2
label
:
gNavigatorBundle
.
getString
(
"
trackingProtection
.
intro
.
nextButton
.
label
"
)
style
:
"
primary
"
}
]
;
let
panelTarget
=
await
UITour
.
getTarget
(
window
"
trackingProtection
"
)
;
UITour
.
initForBrowser
(
gBrowser
.
selectedBrowser
window
)
;
UITour
.
showInfo
(
window
panelTarget
introTitle
introDescription
undefined
buttons
{
closeButtonCallback
:
(
)
=
>
this
.
dontShowIntroPanelAgain
(
)
}
)
;
}
prefsMatch
(
category
)
{
if
(
Services
.
prefs
.
prefHasUserValue
(
this
.
PREF_CB_CATEGORY
)
&
&
Services
.
prefs
.
getStringPref
(
this
.
PREF_CB_CATEGORY
)
!
=
category
)
{
return
false
;
}
for
(
let
[
pref
value
]
of
this
.
CATEGORY_PREFS
[
category
]
)
{
if
(
!
value
)
{
if
(
Services
.
prefs
.
prefHasUserValue
(
pref
)
)
{
return
false
;
}
}
else
{
let
prefType
=
Services
.
prefs
.
getPrefType
(
pref
)
;
if
(
(
prefType
=
=
Services
.
prefs
.
PREF_BOOL
&
&
Services
.
prefs
.
getBoolPref
(
pref
)
!
=
value
)
|
|
(
prefType
=
=
Services
.
prefs
.
PREF_INT
&
&
Services
.
prefs
.
getIntPref
(
pref
)
!
=
value
)
|
|
(
prefType
=
=
Services
.
prefs
.
PREF_STRING
&
&
Services
.
prefs
.
getStringPref
(
pref
)
!
=
value
)
)
{
return
false
;
}
}
}
return
true
;
}
async
matchCBCategory
(
)
{
if
(
this
.
switchingCategory
)
{
return
;
}
if
(
this
.
prefsMatch
(
"
standard
"
)
)
{
Services
.
prefs
.
setStringPref
(
this
.
PREF_CB_CATEGORY
"
standard
"
)
;
}
else
if
(
this
.
prefsMatch
(
"
strict
"
)
)
{
Services
.
prefs
.
setStringPref
(
this
.
PREF_CB_CATEGORY
"
strict
"
)
;
}
else
{
Services
.
prefs
.
setStringPref
(
this
.
PREF_CB_CATEGORY
"
custom
"
)
;
}
}
updateCBCategory
(
)
{
if
(
this
.
switchingCategory
)
{
return
;
}
this
.
switchingCategory
=
true
;
let
value
=
Services
.
prefs
.
getStringPref
(
this
.
PREF_CB_CATEGORY
)
;
this
.
setPrefsToCategory
(
value
)
;
this
.
switchingCategory
=
false
;
}
setPrefsToCategory
(
category
)
{
if
(
category
=
=
"
custom
"
)
{
return
;
}
for
(
let
[
pref
value
]
of
this
.
CATEGORY_PREFS
[
category
]
)
{
if
(
!
Services
.
prefs
.
prefIsLocked
(
pref
)
)
{
if
(
!
value
)
{
Services
.
prefs
.
clearUserPref
(
pref
)
;
}
else
{
switch
(
Services
.
prefs
.
getPrefType
(
pref
)
)
{
case
Services
.
prefs
.
PREF_BOOL
:
Services
.
prefs
.
setBoolPref
(
pref
value
)
;
break
;
case
Services
.
prefs
.
PREF_INT
:
Services
.
prefs
.
setIntPref
(
pref
value
)
;
break
;
case
Services
.
prefs
.
PREF_STRING
:
Services
.
prefs
.
setStringPref
(
pref
value
)
;
break
;
}
}
}
}
}
}
;
