"
use
strict
"
;
{
class
MozTabbrowserTabs
extends
MozElements
.
TabsBase
{
constructor
(
)
{
super
(
)
;
this
.
addEventListener
(
"
TabSelect
"
this
)
;
this
.
addEventListener
(
"
TabClose
"
this
)
;
this
.
addEventListener
(
"
TabAttrModified
"
this
)
;
this
.
addEventListener
(
"
TabHide
"
this
)
;
this
.
addEventListener
(
"
TabShow
"
this
)
;
this
.
addEventListener
(
"
transitionend
"
this
)
;
this
.
addEventListener
(
"
dblclick
"
this
)
;
this
.
addEventListener
(
"
click
"
this
)
;
this
.
addEventListener
(
"
click
"
this
true
)
;
this
.
addEventListener
(
"
keydown
"
this
{
mozSystemGroup
:
true
}
)
;
this
.
addEventListener
(
"
dragstart
"
this
)
;
this
.
addEventListener
(
"
dragover
"
this
)
;
this
.
addEventListener
(
"
drop
"
this
)
;
this
.
addEventListener
(
"
dragend
"
this
)
;
this
.
addEventListener
(
"
dragexit
"
this
)
;
}
init
(
)
{
this
.
arrowScrollbox
=
this
.
querySelector
(
"
arrowscrollbox
"
)
;
this
.
baseConnect
(
)
;
this
.
_firstTab
=
null
;
this
.
_lastTab
=
null
;
this
.
_beforeSelectedTab
=
null
;
this
.
_beforeHoveredTab
=
null
;
this
.
_afterHoveredTab
=
null
;
this
.
_hoveredTab
=
null
;
this
.
_blockDblClick
=
false
;
this
.
_tabDropIndicator
=
this
.
querySelector
(
"
.
tab
-
drop
-
indicator
"
)
;
this
.
_dragOverDelay
=
350
;
this
.
_dragTime
=
0
;
this
.
_closeButtonsUpdatePending
=
false
;
this
.
_closingTabsSpacer
=
this
.
querySelector
(
"
.
closing
-
tabs
-
spacer
"
)
;
this
.
_tabDefaultMaxWidth
=
NaN
;
this
.
_lastTabClosedByMouse
=
false
;
this
.
_hasTabTempMaxWidth
=
false
;
this
.
_scrollButtonWidth
=
0
;
this
.
_lastNumPinned
=
0
;
this
.
_pinnedTabsLayoutCache
=
null
;
this
.
_animateElement
=
this
.
arrowScrollbox
;
this
.
_tabClipWidth
=
Services
.
prefs
.
getIntPref
(
"
browser
.
tabs
.
tabClipWidth
"
)
;
this
.
_hiddenSoundPlayingTabs
=
new
Set
(
)
;
let
strId
=
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
?
"
emptyPrivateTabTitle
"
:
"
emptyTabTitle
"
;
this
.
emptyTabTitle
=
gTabBrowserBundle
.
GetStringFromName
(
"
tabs
.
"
+
strId
)
;
var
tab
=
this
.
allTabs
[
0
]
;
tab
.
label
=
this
.
emptyTabTitle
;
window
.
addEventListener
(
"
resize
"
this
)
;
this
.
boundObserve
=
(
.
.
.
args
)
=
>
this
.
observe
(
.
.
.
args
)
;
Services
.
prefs
.
addObserver
(
"
privacy
.
userContext
"
this
.
boundObserve
)
;
this
.
observe
(
null
"
nsPref
:
changed
"
"
privacy
.
userContext
.
enabled
"
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
_tabMinWidthPref
"
"
browser
.
tabs
.
tabMinWidth
"
null
(
pref
prevValue
newValue
)
=
>
(
this
.
_tabMinWidth
=
newValue
)
newValue
=
>
{
const
LIMIT
=
50
;
return
Math
.
max
(
newValue
LIMIT
)
;
}
)
;
this
.
_tabMinWidth
=
this
.
_tabMinWidthPref
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
_multiselectEnabledPref
"
"
browser
.
tabs
.
multiselect
"
null
(
pref
prevValue
newValue
)
=
>
(
this
.
_multiselectEnabled
=
newValue
)
)
;
this
.
_multiselectEnabled
=
this
.
_multiselectEnabledPref
;
this
.
_setPositionalAttributes
(
)
;
CustomizableUI
.
addListener
(
this
)
;
this
.
_updateNewTabVisibility
(
)
;
this
.
_initializeArrowScrollbox
(
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
_closeTabByDblclick
"
"
browser
.
tabs
.
closeTabByDblclick
"
false
)
;
if
(
gMultiProcessBrowser
)
{
this
.
tabbox
.
tabpanels
.
setAttribute
(
"
async
"
"
true
"
)
;
}
}
on_TabSelect
(
event
)
{
this
.
_handleTabSelect
(
)
;
}
on_TabClose
(
event
)
{
this
.
_hiddenSoundPlayingStatusChanged
(
event
.
target
{
closed
:
true
}
)
;
}
on_TabAttrModified
(
event
)
{
if
(
event
.
detail
.
changed
.
includes
(
"
soundplaying
"
)
&
&
event
.
target
.
hidden
)
{
this
.
_hiddenSoundPlayingStatusChanged
(
event
.
target
)
;
}
}
on_TabHide
(
event
)
{
if
(
event
.
target
.
soundPlaying
)
{
this
.
_hiddenSoundPlayingStatusChanged
(
event
.
target
)
;
}
}
on_TabShow
(
event
)
{
if
(
event
.
target
.
soundPlaying
)
{
this
.
_hiddenSoundPlayingStatusChanged
(
event
.
target
)
;
}
}
on_transitionend
(
event
)
{
if
(
event
.
propertyName
!
=
"
max
-
width
"
)
{
return
;
}
let
tab
=
event
.
target
?
event
.
target
.
closest
(
"
tab
"
)
:
null
;
if
(
tab
.
getAttribute
(
"
fadein
"
)
=
=
"
true
"
)
{
if
(
tab
.
_fullyOpen
)
{
this
.
_updateCloseButtons
(
)
;
}
else
{
this
.
_handleNewTab
(
tab
)
;
}
}
else
if
(
tab
.
closing
)
{
gBrowser
.
_endRemoveTab
(
tab
)
;
}
let
evt
=
new
CustomEvent
(
"
TabAnimationEnd
"
{
bubbles
:
true
}
)
;
tab
.
dispatchEvent
(
evt
)
;
}
on_dblclick
(
event
)
{
if
(
TabsInTitlebar
.
enabled
)
{
return
;
}
if
(
event
.
button
!
=
0
|
|
event
.
originalTarget
.
localName
!
=
"
scrollbox
"
)
{
return
;
}
if
(
!
this
.
_blockDblClick
)
{
BrowserOpenTab
(
)
;
}
event
.
preventDefault
(
)
;
}
on_click
(
event
)
{
if
(
event
.
eventPhase
=
=
Event
.
CAPTURING_PHASE
&
&
event
.
button
=
=
0
)
{
let
target
=
event
.
originalTarget
;
if
(
target
.
classList
.
contains
(
"
tab
-
close
-
button
"
)
)
{
if
(
this
.
_blockDblClick
)
{
target
.
_ignoredCloseButtonClicks
=
true
;
}
else
if
(
event
.
detail
>
1
&
&
!
target
.
_ignoredCloseButtonClicks
)
{
target
.
_ignoredCloseButtonClicks
=
true
;
event
.
stopPropagation
(
)
;
return
;
}
else
{
target
.
_ignoredCloseButtonClicks
=
false
;
}
}
if
(
this
.
_blockDblClick
)
{
if
(
!
(
"
_clickedTabBarOnce
"
in
this
)
)
{
this
.
_clickedTabBarOnce
=
true
;
return
;
}
delete
this
.
_clickedTabBarOnce
;
this
.
_blockDblClick
=
false
;
}
}
else
if
(
event
.
eventPhase
=
=
Event
.
BUBBLING_PHASE
&
&
event
.
button
=
=
1
)
{
let
tab
=
event
.
target
?
event
.
target
.
closest
(
"
tab
"
)
:
null
;
if
(
tab
)
{
gBrowser
.
removeTab
(
tab
{
animate
:
true
byMouse
:
event
.
mozInputSource
=
=
MouseEvent
.
MOZ_SOURCE_MOUSE
}
)
;
}
else
if
(
event
.
originalTarget
.
localName
=
=
"
scrollbox
"
)
{
let
visibleTabs
=
this
.
_getVisibleTabs
(
)
;
let
lastTab
=
visibleTabs
[
visibleTabs
.
length
-
1
]
;
let
winUtils
=
window
.
windowUtils
;
let
endOfTab
=
winUtils
.
getBoundsWithoutFlushing
(
lastTab
)
[
RTL_UI
?
"
left
"
:
"
right
"
]
;
if
(
(
!
RTL_UI
&
&
event
.
clientX
>
endOfTab
)
|
|
(
RTL_UI
&
&
event
.
clientX
<
endOfTab
)
)
{
BrowserOpenTab
(
)
;
}
}
else
{
return
;
}
event
.
stopPropagation
(
)
;
}
}
on_keydown
(
event
)
{
let
{
altKey
shiftKey
}
=
event
;
let
[
accel
nonAccel
]
=
AppConstants
.
platform
=
=
"
macosx
"
?
[
event
.
metaKey
event
.
ctrlKey
]
:
[
event
.
ctrlKey
event
.
metaKey
]
;
let
keyComboForMove
=
accel
&
&
shiftKey
&
&
!
altKey
&
&
!
nonAccel
;
let
keyComboForFocus
=
accel
&
&
!
shiftKey
&
&
!
altKey
&
&
!
nonAccel
;
if
(
!
keyComboForMove
&
&
!
keyComboForFocus
)
{
return
;
}
let
{
visibleTabs
selectedTab
}
=
gBrowser
;
let
{
arrowKeysShouldWrap
}
=
this
;
let
focusedTabIndex
=
this
.
ariaFocusedIndex
;
if
(
focusedTabIndex
=
=
-
1
)
{
focusedTabIndex
=
visibleTabs
.
indexOf
(
selectedTab
)
;
}
let
lastFocusedTabIndex
=
focusedTabIndex
;
switch
(
event
.
keyCode
)
{
case
KeyEvent
.
DOM_VK_UP
:
if
(
keyComboForMove
)
{
gBrowser
.
moveTabBackward
(
)
;
}
else
{
focusedTabIndex
-
-
;
}
break
;
case
KeyEvent
.
DOM_VK_DOWN
:
if
(
keyComboForMove
)
{
gBrowser
.
moveTabForward
(
)
;
}
else
{
focusedTabIndex
+
+
;
}
break
;
case
KeyEvent
.
DOM_VK_RIGHT
:
case
KeyEvent
.
DOM_VK_LEFT
:
if
(
keyComboForMove
)
{
gBrowser
.
moveTabOver
(
event
)
;
}
else
if
(
(
!
RTL_UI
&
&
event
.
keyCode
=
=
KeyEvent
.
DOM_VK_RIGHT
)
|
|
(
RTL_UI
&
&
event
.
keyCode
=
=
KeyEvent
.
DOM_VK_LEFT
)
)
{
focusedTabIndex
+
+
;
}
else
{
focusedTabIndex
-
-
;
}
break
;
case
KeyEvent
.
DOM_VK_HOME
:
if
(
keyComboForMove
)
{
gBrowser
.
moveTabToStart
(
)
;
}
else
{
focusedTabIndex
=
0
;
}
break
;
case
KeyEvent
.
DOM_VK_END
:
if
(
keyComboForMove
)
{
gBrowser
.
moveTabToEnd
(
)
;
}
else
{
focusedTabIndex
=
visibleTabs
.
length
-
1
;
}
break
;
case
KeyEvent
.
DOM_VK_SPACE
:
if
(
visibleTabs
[
lastFocusedTabIndex
]
.
multiselected
)
{
gBrowser
.
removeFromMultiSelectedTabs
(
visibleTabs
[
lastFocusedTabIndex
]
{
isLastMultiSelectChange
:
false
}
)
;
}
else
{
gBrowser
.
addToMultiSelectedTabs
(
visibleTabs
[
lastFocusedTabIndex
]
{
isLastMultiSelectChange
:
true
}
)
;
}
break
;
default
:
return
;
}
if
(
arrowKeysShouldWrap
)
{
if
(
focusedTabIndex
>
=
visibleTabs
.
length
)
{
focusedTabIndex
=
0
;
}
else
if
(
focusedTabIndex
<
0
)
{
focusedTabIndex
=
visibleTabs
.
length
-
1
;
}
}
else
{
focusedTabIndex
=
Math
.
min
(
visibleTabs
.
length
-
1
Math
.
max
(
0
focusedTabIndex
)
)
;
}
if
(
keyComboForFocus
&
&
focusedTabIndex
!
=
lastFocusedTabIndex
)
{
this
.
ariaFocusedItem
=
visibleTabs
[
focusedTabIndex
]
;
}
event
.
preventDefault
(
)
;
}
on_dragstart
(
event
)
{
var
tab
=
this
.
_getDragTargetTab
(
event
false
)
;
if
(
!
tab
|
|
this
.
_isCustomizing
)
{
return
;
}
let
selectedTabs
=
gBrowser
.
selectedTabs
;
let
otherSelectedTabs
=
selectedTabs
.
filter
(
selectedTab
=
>
selectedTab
!
=
tab
)
;
let
dataTransferOrderedTabs
=
[
tab
]
.
concat
(
otherSelectedTabs
)
;
let
dt
=
event
.
dataTransfer
;
for
(
let
i
=
0
;
i
<
dataTransferOrderedTabs
.
length
;
i
+
+
)
{
let
dtTab
=
dataTransferOrderedTabs
[
i
]
;
dt
.
mozSetDataAt
(
TAB_DROP_TYPE
dtTab
i
)
;
let
dtBrowser
=
dtTab
.
linkedBrowser
;
dt
.
mozSetDataAt
(
"
text
/
x
-
moz
-
text
-
internal
"
dtBrowser
.
currentURI
.
spec
i
)
;
}
dt
.
mozCursor
=
"
default
"
;
dt
.
addElement
(
tab
)
;
if
(
tab
.
multiselected
)
{
this
.
_groupSelectedTabs
(
tab
)
;
}
let
windowUtils
=
window
.
windowUtils
;
let
scale
=
windowUtils
.
screenPixelsPerCSSPixel
/
windowUtils
.
fullZoom
;
let
canvas
=
this
.
_dndCanvas
;
if
(
!
canvas
)
{
this
.
_dndCanvas
=
canvas
=
document
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
"
canvas
"
)
;
canvas
.
style
.
width
=
"
100
%
"
;
canvas
.
style
.
height
=
"
100
%
"
;
canvas
.
mozOpaque
=
true
;
}
canvas
.
width
=
160
*
scale
;
canvas
.
height
=
90
*
scale
;
let
toDrag
=
canvas
;
let
dragImageOffset
=
-
16
;
let
browser
=
tab
.
linkedBrowser
;
if
(
gMultiProcessBrowser
)
{
var
context
=
canvas
.
getContext
(
"
2d
"
)
;
context
.
fillStyle
=
"
white
"
;
context
.
fillRect
(
0
0
canvas
.
width
canvas
.
height
)
;
let
captureListener
;
let
platform
=
AppConstants
.
platform
;
if
(
platform
=
=
"
win
"
|
|
platform
=
=
"
macosx
"
)
{
captureListener
=
function
(
)
{
dt
.
updateDragImage
(
canvas
dragImageOffset
dragImageOffset
)
;
}
;
}
else
{
if
(
!
this
.
_dndPanel
)
{
this
.
_dndCanvas
=
canvas
;
this
.
_dndPanel
=
document
.
createXULElement
(
"
panel
"
)
;
this
.
_dndPanel
.
className
=
"
dragfeedback
-
tab
"
;
this
.
_dndPanel
.
setAttribute
(
"
type
"
"
drag
"
)
;
let
wrapper
=
document
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
"
div
"
)
;
wrapper
.
style
.
width
=
"
160px
"
;
wrapper
.
style
.
height
=
"
90px
"
;
wrapper
.
appendChild
(
canvas
)
;
this
.
_dndPanel
.
appendChild
(
wrapper
)
;
document
.
documentElement
.
appendChild
(
this
.
_dndPanel
)
;
}
toDrag
=
this
.
_dndPanel
;
}
PageThumbs
.
captureToCanvas
(
browser
canvas
)
.
then
(
captureListener
)
.
catch
(
e
=
>
Cu
.
reportError
(
e
)
)
;
}
else
{
PageThumbs
.
captureToCanvas
(
browser
canvas
)
.
catch
(
e
=
>
Cu
.
reportError
(
e
)
)
;
dragImageOffset
=
dragImageOffset
*
scale
;
}
dt
.
setDragImage
(
toDrag
dragImageOffset
dragImageOffset
)
;
function
clientX
(
ele
)
{
return
ele
.
getBoundingClientRect
(
)
.
left
;
}
let
tabOffsetX
=
clientX
(
tab
)
-
clientX
(
this
)
;
tab
.
_dragData
=
{
offsetX
:
event
.
screenX
-
window
.
screenX
-
tabOffsetX
offsetY
:
event
.
screenY
-
window
.
screenY
scrollX
:
this
.
arrowScrollbox
.
scrollbox
.
scrollLeft
screenX
:
event
.
screenX
movingTabs
:
(
tab
.
multiselected
?
gBrowser
.
selectedTabs
:
[
tab
]
)
.
filter
(
t
=
>
t
.
pinned
=
=
tab
.
pinned
)
}
;
event
.
stopPropagation
(
)
;
}
on_dragover
(
event
)
{
var
effects
=
this
.
_getDropEffectForTabDrag
(
event
)
;
var
ind
=
this
.
_tabDropIndicator
;
if
(
effects
=
=
"
"
|
|
effects
=
=
"
none
"
)
{
ind
.
hidden
=
true
;
return
;
}
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
var
arrowScrollbox
=
this
.
arrowScrollbox
;
var
pixelsToScroll
=
0
;
if
(
this
.
getAttribute
(
"
overflow
"
)
=
=
"
true
"
)
{
switch
(
event
.
originalTarget
)
{
case
arrowScrollbox
.
_scrollButtonUp
:
pixelsToScroll
=
arrowScrollbox
.
scrollIncrement
*
-
1
;
break
;
case
arrowScrollbox
.
_scrollButtonDown
:
pixelsToScroll
=
arrowScrollbox
.
scrollIncrement
;
break
;
}
if
(
pixelsToScroll
)
{
arrowScrollbox
.
scrollByPixels
(
(
RTL_UI
?
-
1
:
1
)
*
pixelsToScroll
true
)
;
}
}
let
draggedTab
=
event
.
dataTransfer
.
mozGetDataAt
(
TAB_DROP_TYPE
0
)
;
if
(
(
effects
=
=
"
move
"
|
|
effects
=
=
"
copy
"
)
&
&
this
=
=
draggedTab
.
container
)
{
ind
.
hidden
=
true
;
if
(
!
this
.
_isGroupTabsAnimationOver
(
)
)
{
return
;
}
this
.
_finishGroupSelectedTabs
(
draggedTab
)
;
if
(
effects
=
=
"
move
"
)
{
this
.
_animateTabMove
(
event
)
;
return
;
}
}
this
.
_finishAnimateTabMove
(
)
;
if
(
effects
=
=
"
link
"
)
{
let
tab
=
this
.
_getDragTargetTab
(
event
true
)
;
if
(
tab
)
{
if
(
!
this
.
_dragTime
)
{
this
.
_dragTime
=
Date
.
now
(
)
;
}
if
(
Date
.
now
(
)
>
=
this
.
_dragTime
+
this
.
_dragOverDelay
)
{
this
.
selectedItem
=
tab
;
}
ind
.
hidden
=
true
;
return
;
}
}
var
rect
=
arrowScrollbox
.
getBoundingClientRect
(
)
;
var
newMargin
;
if
(
pixelsToScroll
)
{
let
scrollRect
=
arrowScrollbox
.
scrollClientRect
;
let
minMargin
=
scrollRect
.
left
-
rect
.
left
;
let
maxMargin
=
Math
.
min
(
minMargin
+
scrollRect
.
width
scrollRect
.
right
)
;
if
(
RTL_UI
)
{
[
minMargin
maxMargin
]
=
[
this
.
clientWidth
-
maxMargin
this
.
clientWidth
-
minMargin
]
;
}
newMargin
=
pixelsToScroll
>
0
?
maxMargin
:
minMargin
;
}
else
{
let
newIndex
=
this
.
_getDropIndex
(
event
effects
=
=
"
link
"
)
;
let
children
=
this
.
allTabs
;
if
(
newIndex
=
=
children
.
length
)
{
let
tabRect
=
children
[
newIndex
-
1
]
.
getBoundingClientRect
(
)
;
if
(
RTL_UI
)
{
newMargin
=
rect
.
right
-
tabRect
.
left
;
}
else
{
newMargin
=
tabRect
.
right
-
rect
.
left
;
}
}
else
{
let
tabRect
=
children
[
newIndex
]
.
getBoundingClientRect
(
)
;
if
(
RTL_UI
)
{
newMargin
=
rect
.
right
-
tabRect
.
right
;
}
else
{
newMargin
=
tabRect
.
left
-
rect
.
left
;
}
}
}
ind
.
hidden
=
false
;
newMargin
+
=
ind
.
clientWidth
/
2
;
if
(
RTL_UI
)
{
newMargin
*
=
-
1
;
}
ind
.
style
.
transform
=
"
translate
(
"
+
Math
.
round
(
newMargin
)
+
"
px
)
"
;
}
on_drop
(
event
)
{
var
dt
=
event
.
dataTransfer
;
var
dropEffect
=
dt
.
dropEffect
;
var
draggedTab
;
let
movingTabs
;
if
(
dt
.
mozTypesAt
(
0
)
[
0
]
=
=
TAB_DROP_TYPE
)
{
draggedTab
=
dt
.
mozGetDataAt
(
TAB_DROP_TYPE
0
)
;
if
(
!
draggedTab
)
{
return
;
}
movingTabs
=
draggedTab
.
_dragData
.
movingTabs
;
draggedTab
.
container
.
_finishGroupSelectedTabs
(
draggedTab
)
;
}
this
.
_tabDropIndicator
.
hidden
=
true
;
event
.
stopPropagation
(
)
;
if
(
draggedTab
&
&
dropEffect
=
=
"
copy
"
)
{
let
newIndex
=
this
.
_getDropIndex
(
event
false
)
;
let
draggedTabCopy
;
for
(
let
tab
of
movingTabs
)
{
let
newTab
=
gBrowser
.
duplicateTab
(
tab
)
;
gBrowser
.
moveTabTo
(
newTab
newIndex
+
+
)
;
if
(
tab
=
=
draggedTab
)
{
draggedTabCopy
=
newTab
;
}
}
if
(
draggedTab
.
container
!
=
this
|
|
event
.
shiftKey
)
{
this
.
selectedItem
=
draggedTabCopy
;
}
}
else
if
(
draggedTab
&
&
draggedTab
.
container
=
=
this
)
{
let
oldTranslateX
=
Math
.
round
(
draggedTab
.
_dragData
.
translateX
)
;
let
tabWidth
=
Math
.
round
(
draggedTab
.
_dragData
.
tabWidth
)
;
let
translateOffset
=
oldTranslateX
%
tabWidth
;
let
newTranslateX
=
oldTranslateX
-
translateOffset
;
if
(
oldTranslateX
>
0
&
&
translateOffset
>
tabWidth
/
2
)
{
newTranslateX
+
=
tabWidth
;
}
else
if
(
oldTranslateX
<
0
&
&
-
translateOffset
>
tabWidth
/
2
)
{
newTranslateX
-
=
tabWidth
;
}
let
dropIndex
=
"
animDropIndex
"
in
draggedTab
.
_dragData
&
&
draggedTab
.
_dragData
.
animDropIndex
;
let
incrementDropIndex
=
true
;
if
(
dropIndex
&
&
dropIndex
>
movingTabs
[
0
]
.
_tPos
)
{
dropIndex
-
-
;
incrementDropIndex
=
false
;
}
let
animate
=
gBrowser
.
animationsEnabled
;
if
(
oldTranslateX
&
&
oldTranslateX
!
=
newTranslateX
&
&
animate
)
{
for
(
let
tab
of
movingTabs
)
{
tab
.
setAttribute
(
"
tabdrop
-
samewindow
"
"
true
"
)
;
tab
.
style
.
transform
=
"
translateX
(
"
+
newTranslateX
+
"
px
)
"
;
let
onTransitionEnd
=
transitionendEvent
=
>
{
if
(
transitionendEvent
.
propertyName
!
=
"
transform
"
|
|
transitionendEvent
.
originalTarget
!
=
tab
)
{
return
;
}
tab
.
removeEventListener
(
"
transitionend
"
onTransitionEnd
)
;
tab
.
removeAttribute
(
"
tabdrop
-
samewindow
"
)
;
this
.
_finishAnimateTabMove
(
)
;
if
(
dropIndex
!
=
=
false
)
{
gBrowser
.
moveTabTo
(
tab
dropIndex
)
;
if
(
incrementDropIndex
)
{
dropIndex
+
+
;
}
}
gBrowser
.
syncThrobberAnimations
(
tab
)
;
}
;
tab
.
addEventListener
(
"
transitionend
"
onTransitionEnd
)
;
}
}
else
{
this
.
_finishAnimateTabMove
(
)
;
if
(
dropIndex
!
=
=
false
)
{
for
(
let
tab
of
movingTabs
)
{
gBrowser
.
moveTabTo
(
tab
dropIndex
)
;
if
(
incrementDropIndex
)
{
dropIndex
+
+
;
}
}
}
}
}
else
if
(
draggedTab
)
{
let
newIndex
=
this
.
_getDropIndex
(
event
false
)
;
let
newTabs
=
[
]
;
for
(
let
tab
of
movingTabs
)
{
let
newTab
=
gBrowser
.
adoptTab
(
tab
newIndex
+
+
tab
=
=
draggedTab
)
;
newTabs
.
push
(
newTab
)
;
}
gBrowser
.
addRangeToMultiSelectedTabs
(
newTabs
[
0
]
newTabs
[
newTabs
.
length
-
1
]
)
;
}
else
{
let
links
;
try
{
links
=
browserDragAndDrop
.
dropLinks
(
event
true
)
;
}
catch
(
ex
)
{
}
if
(
!
links
|
|
links
.
length
=
=
=
0
)
{
return
;
}
let
inBackground
=
Services
.
prefs
.
getBoolPref
(
"
browser
.
tabs
.
loadInBackground
"
)
;
if
(
event
.
shiftKey
)
{
inBackground
=
!
inBackground
;
}
let
targetTab
=
this
.
_getDragTargetTab
(
event
true
)
;
let
userContextId
=
this
.
selectedItem
.
getAttribute
(
"
usercontextid
"
)
;
let
replace
=
!
!
targetTab
;
let
newIndex
=
this
.
_getDropIndex
(
event
true
)
;
let
urls
=
links
.
map
(
link
=
>
link
.
url
)
;
let
csp
=
browserDragAndDrop
.
getCSP
(
event
)
;
let
triggeringPrincipal
=
browserDragAndDrop
.
getTriggeringPrincipal
(
event
)
;
(
async
(
)
=
>
{
if
(
urls
.
length
>
=
Services
.
prefs
.
getIntPref
(
"
browser
.
tabs
.
maxOpenBeforeWarn
"
)
)
{
let
answer
=
await
OpenInTabsUtils
.
promiseConfirmOpenInTabs
(
urls
.
length
window
)
;
if
(
!
answer
)
{
return
;
}
}
gBrowser
.
loadTabs
(
urls
{
inBackground
replace
allowThirdPartyFixup
:
true
targetTab
newIndex
userContextId
triggeringPrincipal
csp
}
)
;
}
)
(
)
;
}
if
(
draggedTab
)
{
delete
draggedTab
.
_dragData
;
}
}
on_dragend
(
event
)
{
var
dt
=
event
.
dataTransfer
;
var
draggedTab
=
dt
.
mozGetDataAt
(
TAB_DROP_TYPE
0
)
;
if
(
draggedTab
.
hasAttribute
(
"
tabdrop
-
samewindow
"
)
)
{
return
;
}
this
.
_finishGroupSelectedTabs
(
draggedTab
)
;
this
.
_finishAnimateTabMove
(
)
;
if
(
dt
.
mozUserCancelled
|
|
dt
.
dropEffect
!
=
"
none
"
|
|
this
.
_isCustomizing
)
{
delete
draggedTab
.
_dragData
;
return
;
}
if
(
!
Services
.
prefs
.
getBoolPref
(
"
browser
.
tabs
.
allowTabDetach
"
)
)
{
return
;
}
var
eX
=
event
.
screenX
;
var
eY
=
event
.
screenY
;
var
wX
=
window
.
screenX
;
if
(
eX
>
wX
&
&
eX
<
wX
+
window
.
outerWidth
)
{
let
rect
=
window
.
windowUtils
.
getBoundsWithoutFlushing
(
this
.
arrowScrollbox
)
;
let
detachTabThresholdY
=
window
.
screenY
+
rect
.
top
+
1
.
5
*
rect
.
height
;
if
(
eY
<
detachTabThresholdY
&
&
eY
>
window
.
screenY
)
{
return
;
}
}
var
screen
=
Cc
[
"
mozilla
.
org
/
gfx
/
screenmanager
;
1
"
]
.
getService
(
Ci
.
nsIScreenManager
)
.
screenForRect
(
eX
eY
1
1
)
;
var
fullX
=
{
}
fullY
=
{
}
fullWidth
=
{
}
fullHeight
=
{
}
;
var
availX
=
{
}
availY
=
{
}
availWidth
=
{
}
availHeight
=
{
}
;
screen
.
GetRectDisplayPix
(
fullX
fullY
fullWidth
fullHeight
)
;
screen
.
GetAvailRectDisplayPix
(
availX
availY
availWidth
availHeight
)
;
var
scaleFactor
=
screen
.
contentsScaleFactor
/
screen
.
defaultCSSScaleFactor
;
availX
.
value
=
(
availX
.
value
-
fullX
.
value
)
*
scaleFactor
+
fullX
.
value
;
availY
.
value
=
(
availY
.
value
-
fullY
.
value
)
*
scaleFactor
+
fullY
.
value
;
availWidth
.
value
*
=
scaleFactor
;
availHeight
.
value
*
=
scaleFactor
;
var
winWidth
=
Math
.
min
(
window
.
outerWidth
availWidth
.
value
)
;
var
winHeight
=
Math
.
min
(
window
.
outerHeight
availHeight
.
value
)
;
var
left
=
Math
.
min
(
Math
.
max
(
eX
-
draggedTab
.
_dragData
.
offsetX
availX
.
value
)
availX
.
value
+
availWidth
.
value
-
winWidth
)
;
var
top
=
Math
.
min
(
Math
.
max
(
eY
-
draggedTab
.
_dragData
.
offsetY
availY
.
value
)
availY
.
value
+
availHeight
.
value
-
winHeight
)
;
delete
draggedTab
.
_dragData
;
if
(
gBrowser
.
tabs
.
length
=
=
1
)
{
window
.
resizeTo
(
winWidth
winHeight
)
;
window
.
moveTo
(
left
top
)
;
window
.
focus
(
)
;
}
else
{
let
props
=
{
screenX
:
left
screenY
:
top
suppressanimation
:
1
}
;
if
(
AppConstants
.
platform
!
=
"
win
"
)
{
props
.
outerWidth
=
winWidth
;
props
.
outerHeight
=
winHeight
;
}
gBrowser
.
replaceTabsWithWindow
(
draggedTab
props
)
;
}
event
.
stopPropagation
(
)
;
}
on_dragexit
(
event
)
{
this
.
_dragTime
=
0
;
var
target
=
event
.
relatedTarget
;
while
(
target
&
&
target
!
=
this
)
{
target
=
target
.
parentNode
;
}
if
(
target
)
{
return
;
}
this
.
_tabDropIndicator
.
hidden
=
true
;
event
.
stopPropagation
(
)
;
}
get
tabbox
(
)
{
return
document
.
getElementById
(
"
tabbrowser
-
tabbox
"
)
;
}
get
newTabButton
(
)
{
return
this
.
querySelector
(
"
#
tabs
-
newtab
-
button
"
)
;
}
get
allTabs
(
)
{
let
children
=
Array
.
from
(
this
.
arrowScrollbox
.
children
)
;
children
.
pop
(
)
;
children
.
pop
(
)
;
return
children
;
}
appendChild
(
tab
)
{
return
this
.
insertBefore
(
tab
null
)
;
}
insertBefore
(
tab
node
)
{
if
(
!
this
.
arrowScrollbox
)
{
throw
new
Error
(
"
Shouldn
'
t
call
this
without
arrowscrollbox
"
)
;
}
let
{
arrowScrollbox
}
=
this
;
if
(
node
=
=
null
)
{
node
=
arrowScrollbox
.
lastChild
.
previousSibling
;
}
return
arrowScrollbox
.
insertBefore
(
tab
node
)
;
}
set
_tabMinWidth
(
val
)
{
this
.
style
.
setProperty
(
"
-
-
tab
-
min
-
width
"
val
+
"
px
"
)
;
return
val
;
}
set
_multiselectEnabled
(
val
)
{
this
.
setAttribute
(
"
aria
-
multiselectable
"
!
!
val
)
;
return
val
;
}
get
_multiselectEnabled
(
)
{
return
this
.
getAttribute
(
"
aria
-
multiselectable
"
)
=
=
"
true
"
;
}
get
_isCustomizing
(
)
{
return
document
.
documentElement
.
getAttribute
(
"
customizing
"
)
=
=
"
true
"
;
}
_initializeArrowScrollbox
(
)
{
let
arrowScrollbox
=
this
.
arrowScrollbox
;
arrowScrollbox
.
shadowRoot
.
addEventListener
(
"
underflow
"
event
=
>
{
if
(
event
.
originalTarget
!
=
arrowScrollbox
.
scrollbox
|
|
event
.
detail
=
=
0
|
|
!
this
.
hasAttribute
(
"
overflow
"
)
)
{
return
;
}
this
.
removeAttribute
(
"
overflow
"
)
;
if
(
this
.
_lastTabClosedByMouse
)
{
this
.
_expandSpacerBy
(
this
.
_scrollButtonWidth
)
;
}
for
(
let
tab
of
Array
.
from
(
gBrowser
.
_removingTabs
)
)
{
gBrowser
.
removeTab
(
tab
)
;
}
this
.
_positionPinnedTabs
(
)
;
}
true
)
;
arrowScrollbox
.
shadowRoot
.
addEventListener
(
"
overflow
"
event
=
>
{
if
(
event
.
originalTarget
!
=
arrowScrollbox
.
scrollbox
|
|
event
.
detail
=
=
0
)
{
return
;
}
this
.
setAttribute
(
"
overflow
"
"
true
"
)
;
this
.
_positionPinnedTabs
(
)
;
this
.
_handleTabSelect
(
true
)
;
}
)
;
arrowScrollbox
.
_getScrollableElements
=
(
)
=
>
{
return
this
.
allTabs
.
filter
(
arrowScrollbox
.
_canScrollToElement
)
;
}
;
arrowScrollbox
.
_canScrollToElement
=
tab
=
>
{
return
!
tab
.
_pinnedUnscrollable
&
&
!
tab
.
hidden
;
}
;
}
observe
(
aSubject
aTopic
aData
)
{
switch
(
aTopic
)
{
case
"
nsPref
:
changed
"
:
let
containersEnabled
=
Services
.
prefs
.
getBoolPref
(
"
privacy
.
userContext
.
enabled
"
)
&
&
!
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
;
const
newTabLeftClickOpensContainersMenu
=
Services
.
prefs
.
getBoolPref
(
"
privacy
.
userContext
.
newTabContainerOnLeftClick
.
enabled
"
)
;
const
newTab
=
document
.
getElementById
(
"
new
-
tab
-
button
"
)
;
const
newTab2
=
this
.
newTabButton
;
for
(
let
parent
of
[
newTab
newTab2
]
)
{
if
(
!
parent
)
{
continue
;
}
parent
.
removeAttribute
(
"
type
"
)
;
if
(
parent
.
menupopup
)
{
parent
.
menupopup
.
remove
(
)
;
}
if
(
containersEnabled
)
{
parent
.
setAttribute
(
"
context
"
"
new
-
tab
-
button
-
popup
"
)
;
if
(
newTabLeftClickOpensContainersMenu
)
{
let
popup
=
document
.
getElementById
(
"
new
-
tab
-
button
-
popup
"
)
.
cloneNode
(
true
)
;
popup
.
removeAttribute
(
"
id
"
)
;
popup
.
className
=
"
new
-
tab
-
popup
"
;
popup
.
setAttribute
(
"
position
"
"
after_end
"
)
;
parent
.
prepend
(
popup
)
;
parent
.
setAttribute
(
"
type
"
"
menu
"
)
;
nodeToTooltipMap
[
parent
.
id
]
=
"
newTabAlwaysContainer
.
tooltip
"
;
}
else
{
nodeToTooltipMap
[
parent
.
id
]
=
"
newTabButton
.
tooltip
"
;
}
}
else
{
nodeToTooltipMap
[
parent
.
id
]
=
"
newTabButton
.
tooltip
"
;
parent
.
removeAttribute
(
"
context
"
"
new
-
tab
-
button
-
popup
"
)
;
}
gDynamicTooltipCache
.
delete
(
parent
.
id
)
;
}
break
;
}
}
_getVisibleTabs
(
)
{
if
(
!
gBrowser
)
{
return
this
.
allTabs
[
0
]
;
}
return
gBrowser
.
visibleTabs
;
}
_setPositionalAttributes
(
)
{
let
visibleTabs
=
this
.
_getVisibleTabs
(
)
;
if
(
!
visibleTabs
.
length
)
{
return
;
}
let
selectedTab
=
this
.
selectedItem
;
let
selectedIndex
=
visibleTabs
.
indexOf
(
selectedTab
)
;
if
(
this
.
_beforeSelectedTab
)
{
this
.
_beforeSelectedTab
.
removeAttribute
(
"
beforeselected
-
visible
"
)
;
}
if
(
selectedTab
.
closing
|
|
selectedIndex
<
=
0
)
{
this
.
_beforeSelectedTab
=
null
;
}
else
{
let
beforeSelectedTab
=
visibleTabs
[
selectedIndex
-
1
]
;
let
separatedByScrollButton
=
this
.
getAttribute
(
"
overflow
"
)
=
=
"
true
"
&
&
beforeSelectedTab
.
pinned
&
&
!
selectedTab
.
pinned
;
if
(
!
separatedByScrollButton
)
{
this
.
_beforeSelectedTab
=
beforeSelectedTab
;
this
.
_beforeSelectedTab
.
setAttribute
(
"
beforeselected
-
visible
"
"
true
"
)
;
}
}
if
(
this
.
_firstTab
)
{
this
.
_firstTab
.
removeAttribute
(
"
first
-
visible
-
tab
"
)
;
}
this
.
_firstTab
=
visibleTabs
[
0
]
;
this
.
_firstTab
.
setAttribute
(
"
first
-
visible
-
tab
"
"
true
"
)
;
if
(
this
.
_lastTab
)
{
this
.
_lastTab
.
removeAttribute
(
"
last
-
visible
-
tab
"
)
;
}
this
.
_lastTab
=
visibleTabs
[
visibleTabs
.
length
-
1
]
;
this
.
_lastTab
.
setAttribute
(
"
last
-
visible
-
tab
"
"
true
"
)
;
let
hoveredTab
=
this
.
_hoveredTab
;
if
(
hoveredTab
)
{
hoveredTab
.
_mouseleave
(
)
;
}
hoveredTab
=
this
.
querySelector
(
"
tab
:
hover
"
)
;
if
(
hoveredTab
)
{
hoveredTab
.
_mouseenter
(
)
;
}
for
(
let
i
=
0
;
i
<
visibleTabs
.
length
-
1
;
i
+
+
)
{
let
tab
=
visibleTabs
[
i
]
;
let
nextTab
=
visibleTabs
[
i
+
1
]
;
tab
.
removeAttribute
(
"
before
-
multiselected
"
)
;
if
(
nextTab
.
multiselected
)
{
tab
.
setAttribute
(
"
before
-
multiselected
"
"
true
"
)
;
}
}
}
_updateCloseButtons
(
)
{
if
(
this
.
getAttribute
(
"
overflow
"
)
=
=
"
true
"
)
{
this
.
setAttribute
(
"
closebuttons
"
"
activetab
"
)
;
return
;
}
if
(
this
.
_closeButtonsUpdatePending
)
{
return
;
}
this
.
_closeButtonsUpdatePending
=
true
;
window
.
requestAnimationFrame
(
(
)
=
>
{
window
.
requestAnimationFrame
(
(
)
=
>
{
this
.
_closeButtonsUpdatePending
=
false
;
if
(
this
.
getAttribute
(
"
overflow
"
)
=
=
"
true
"
)
{
this
.
setAttribute
(
"
closebuttons
"
"
activetab
"
)
;
return
;
}
let
rect
=
ele
=
>
{
return
window
.
windowUtils
.
getBoundsWithoutFlushing
(
ele
)
;
}
;
let
tab
=
this
.
_getVisibleTabs
(
)
[
gBrowser
.
_numPinnedTabs
]
;
if
(
tab
&
&
rect
(
tab
)
.
width
<
=
this
.
_tabClipWidth
)
{
this
.
setAttribute
(
"
closebuttons
"
"
activetab
"
)
;
}
else
{
this
.
removeAttribute
(
"
closebuttons
"
)
;
}
}
)
;
}
)
;
}
_updateHiddenTabsStatus
(
)
{
if
(
gBrowser
.
visibleTabs
.
length
<
gBrowser
.
tabs
.
length
)
{
this
.
setAttribute
(
"
hashiddentabs
"
"
true
"
)
;
}
else
{
this
.
removeAttribute
(
"
hashiddentabs
"
)
;
}
}
_handleTabSelect
(
aInstant
)
{
let
selectedTab
=
this
.
selectedItem
;
if
(
this
.
getAttribute
(
"
overflow
"
)
=
=
"
true
"
)
{
this
.
arrowScrollbox
.
ensureElementIsVisible
(
selectedTab
aInstant
)
;
}
selectedTab
.
_notselectedsinceload
=
false
;
}
_lockTabSizing
(
aTab
aTabWidth
)
{
let
tabs
=
this
.
_getVisibleTabs
(
)
;
if
(
!
tabs
.
length
)
{
return
;
}
var
isEndTab
=
aTab
.
_tPos
>
tabs
[
tabs
.
length
-
1
]
.
_tPos
;
if
(
!
this
.
_tabDefaultMaxWidth
)
{
this
.
_tabDefaultMaxWidth
=
parseFloat
(
window
.
getComputedStyle
(
aTab
)
.
maxWidth
)
;
}
this
.
_lastTabClosedByMouse
=
true
;
this
.
_scrollButtonWidth
=
window
.
windowUtils
.
getBoundsWithoutFlushing
(
this
.
arrowScrollbox
.
_scrollButtonDown
)
.
width
;
if
(
this
.
getAttribute
(
"
overflow
"
)
=
=
"
true
"
)
{
if
(
isEndTab
|
|
!
this
.
arrowScrollbox
.
_scrollButtonDown
.
disabled
)
{
return
;
}
if
(
aTab
.
owner
)
{
return
;
}
this
.
_expandSpacerBy
(
aTabWidth
)
;
}
else
{
if
(
isEndTab
&
&
!
this
.
_hasTabTempMaxWidth
)
{
return
;
}
let
numPinned
=
gBrowser
.
_numPinnedTabs
;
if
(
isEndTab
)
{
let
numNormalTabs
=
tabs
.
length
-
numPinned
;
aTabWidth
=
(
aTabWidth
*
(
numNormalTabs
+
1
)
)
/
numNormalTabs
;
if
(
aTabWidth
>
this
.
_tabDefaultMaxWidth
)
{
aTabWidth
=
this
.
_tabDefaultMaxWidth
;
}
}
aTabWidth
+
=
"
px
"
;
let
tabsToReset
=
[
]
;
for
(
let
i
=
numPinned
;
i
<
tabs
.
length
;
i
+
+
)
{
let
tab
=
tabs
[
i
]
;
tab
.
style
.
setProperty
(
"
max
-
width
"
aTabWidth
"
important
"
)
;
if
(
!
isEndTab
)
{
tab
.
style
.
transition
=
"
none
"
;
tabsToReset
.
push
(
tab
)
;
}
}
if
(
tabsToReset
.
length
)
{
window
.
promiseDocumentFlushed
(
(
)
=
>
{
}
)
.
then
(
(
)
=
>
{
window
.
requestAnimationFrame
(
(
)
=
>
{
for
(
let
tab
of
tabsToReset
)
{
tab
.
style
.
transition
=
"
"
;
}
}
)
;
}
)
;
}
this
.
_hasTabTempMaxWidth
=
true
;
gBrowser
.
addEventListener
(
"
mousemove
"
this
)
;
window
.
addEventListener
(
"
mouseout
"
this
)
;
}
}
_expandSpacerBy
(
pixels
)
{
let
spacer
=
this
.
_closingTabsSpacer
;
spacer
.
style
.
width
=
parseFloat
(
spacer
.
style
.
width
)
+
pixels
+
"
px
"
;
this
.
setAttribute
(
"
using
-
closing
-
tabs
-
spacer
"
"
true
"
)
;
gBrowser
.
addEventListener
(
"
mousemove
"
this
)
;
window
.
addEventListener
(
"
mouseout
"
this
)
;
}
_unlockTabSizing
(
)
{
gBrowser
.
removeEventListener
(
"
mousemove
"
this
)
;
window
.
removeEventListener
(
"
mouseout
"
this
)
;
if
(
this
.
_hasTabTempMaxWidth
)
{
this
.
_hasTabTempMaxWidth
=
false
;
let
tabs
=
this
.
_getVisibleTabs
(
)
;
for
(
let
i
=
0
;
i
<
tabs
.
length
;
i
+
+
)
{
tabs
[
i
]
.
style
.
maxWidth
=
"
"
;
}
}
if
(
this
.
hasAttribute
(
"
using
-
closing
-
tabs
-
spacer
"
)
)
{
this
.
removeAttribute
(
"
using
-
closing
-
tabs
-
spacer
"
)
;
this
.
_closingTabsSpacer
.
style
.
width
=
0
;
}
}
uiDensityChanged
(
)
{
this
.
_positionPinnedTabs
(
)
;
this
.
_updateCloseButtons
(
)
;
this
.
_handleTabSelect
(
true
)
;
}
_positionPinnedTabs
(
)
{
let
numPinned
=
gBrowser
.
_numPinnedTabs
;
let
doPosition
=
this
.
getAttribute
(
"
overflow
"
)
=
=
"
true
"
&
&
this
.
_getVisibleTabs
(
)
.
length
>
numPinned
&
&
numPinned
>
0
;
let
tabs
=
this
.
allTabs
;
if
(
doPosition
)
{
this
.
setAttribute
(
"
positionpinnedtabs
"
"
true
"
)
;
let
layoutData
=
this
.
_pinnedTabsLayoutCache
;
let
uiDensity
=
document
.
documentElement
.
getAttribute
(
"
uidensity
"
)
;
if
(
!
layoutData
|
|
layoutData
.
uiDensity
!
=
uiDensity
)
{
let
arrowScrollbox
=
this
.
arrowScrollbox
;
layoutData
=
this
.
_pinnedTabsLayoutCache
=
{
uiDensity
pinnedTabWidth
:
this
.
allTabs
[
0
]
.
getBoundingClientRect
(
)
.
width
scrollButtonWidth
:
arrowScrollbox
.
_scrollButtonDown
.
getBoundingClientRect
(
)
.
width
}
;
}
let
width
=
0
;
for
(
let
i
=
numPinned
-
1
;
i
>
=
0
;
i
-
-
)
{
let
tab
=
tabs
[
i
]
;
width
+
=
layoutData
.
pinnedTabWidth
;
tab
.
style
.
setProperty
(
"
margin
-
inline
-
start
"
-
(
width
+
layoutData
.
scrollButtonWidth
)
+
"
px
"
"
important
"
)
;
tab
.
_pinnedUnscrollable
=
true
;
}
this
.
style
.
paddingInlineStart
=
width
+
"
px
"
;
}
else
{
this
.
removeAttribute
(
"
positionpinnedtabs
"
)
;
for
(
let
i
=
0
;
i
<
numPinned
;
i
+
+
)
{
let
tab
=
tabs
[
i
]
;
tab
.
style
.
marginInlineStart
=
"
"
;
tab
.
_pinnedUnscrollable
=
false
;
}
this
.
style
.
paddingInlineStart
=
"
"
;
}
if
(
this
.
_lastNumPinned
!
=
numPinned
)
{
this
.
_lastNumPinned
=
numPinned
;
this
.
_handleTabSelect
(
true
)
;
}
}
_animateTabMove
(
event
)
{
let
draggedTab
=
event
.
dataTransfer
.
mozGetDataAt
(
TAB_DROP_TYPE
0
)
;
let
movingTabs
=
draggedTab
.
_dragData
.
movingTabs
;
if
(
this
.
getAttribute
(
"
movingtab
"
)
!
=
"
true
"
)
{
this
.
setAttribute
(
"
movingtab
"
"
true
"
)
;
gNavToolbox
.
setAttribute
(
"
movingtab
"
"
true
"
)
;
if
(
!
draggedTab
.
multiselected
)
{
this
.
selectedItem
=
draggedTab
;
}
}
if
(
!
(
"
animLastScreenX
"
in
draggedTab
.
_dragData
)
)
{
draggedTab
.
_dragData
.
animLastScreenX
=
draggedTab
.
_dragData
.
screenX
;
}
let
screenX
=
event
.
screenX
;
if
(
screenX
=
=
draggedTab
.
_dragData
.
animLastScreenX
)
{
return
;
}
let
ltrMove
=
screenX
>
draggedTab
.
_dragData
.
animLastScreenX
;
draggedTab
.
_dragData
.
animLastScreenX
=
screenX
;
let
pinned
=
draggedTab
.
pinned
;
let
numPinned
=
gBrowser
.
_numPinnedTabs
;
let
tabs
=
this
.
_getVisibleTabs
(
)
.
slice
(
pinned
?
0
:
numPinned
pinned
?
numPinned
:
undefined
)
;
if
(
RTL_UI
)
{
tabs
.
reverse
(
)
;
movingTabs
=
[
.
.
.
movingTabs
]
.
reverse
(
)
;
}
let
tabWidth
=
draggedTab
.
getBoundingClientRect
(
)
.
width
;
let
shiftWidth
=
tabWidth
*
movingTabs
.
length
;
draggedTab
.
_dragData
.
tabWidth
=
tabWidth
;
let
leftTab
=
tabs
[
0
]
;
let
rightTab
=
tabs
[
tabs
.
length
-
1
]
;
let
rightMovingTabScreenX
=
movingTabs
[
movingTabs
.
length
-
1
]
.
screenX
;
let
leftMovingTabScreenX
=
movingTabs
[
0
]
.
screenX
;
let
translateX
=
screenX
-
draggedTab
.
_dragData
.
screenX
;
if
(
!
pinned
)
{
translateX
+
=
this
.
arrowScrollbox
.
scrollbox
.
scrollLeft
-
draggedTab
.
_dragData
.
scrollX
;
}
let
leftBound
=
leftTab
.
screenX
-
leftMovingTabScreenX
;
let
rightBound
=
rightTab
.
screenX
+
rightTab
.
getBoundingClientRect
(
)
.
width
-
(
rightMovingTabScreenX
+
tabWidth
)
;
translateX
=
Math
.
min
(
Math
.
max
(
translateX
leftBound
)
rightBound
)
;
for
(
let
tab
of
movingTabs
)
{
tab
.
style
.
transform
=
"
translateX
(
"
+
translateX
+
"
px
)
"
;
}
draggedTab
.
_dragData
.
translateX
=
translateX
;
tabs
=
tabs
.
filter
(
t
=
>
!
movingTabs
.
includes
(
t
)
|
|
t
=
=
draggedTab
)
;
let
leftTabCenter
=
leftMovingTabScreenX
+
translateX
+
tabWidth
/
2
;
let
rightTabCenter
=
rightMovingTabScreenX
+
translateX
+
tabWidth
/
2
;
let
tabCenter
=
ltrMove
?
rightTabCenter
:
leftTabCenter
;
let
newIndex
=
-
1
;
let
oldIndex
=
"
animDropIndex
"
in
draggedTab
.
_dragData
?
draggedTab
.
_dragData
.
animDropIndex
:
movingTabs
[
0
]
.
_tPos
;
let
low
=
0
;
let
high
=
tabs
.
length
-
1
;
while
(
low
<
=
high
)
{
let
mid
=
Math
.
floor
(
(
low
+
high
)
/
2
)
;
if
(
tabs
[
mid
]
=
=
draggedTab
&
&
+
+
mid
>
high
)
{
break
;
}
screenX
=
tabs
[
mid
]
.
screenX
+
getTabShift
(
tabs
[
mid
]
oldIndex
)
;
if
(
screenX
>
tabCenter
)
{
high
=
mid
-
1
;
}
else
if
(
screenX
+
tabs
[
mid
]
.
getBoundingClientRect
(
)
.
width
<
tabCenter
)
{
low
=
mid
+
1
;
}
else
{
newIndex
=
tabs
[
mid
]
.
_tPos
;
break
;
}
}
if
(
newIndex
>
=
oldIndex
)
{
newIndex
+
+
;
}
if
(
newIndex
<
0
|
|
newIndex
=
=
oldIndex
)
{
return
;
}
draggedTab
.
_dragData
.
animDropIndex
=
newIndex
;
for
(
let
tab
of
tabs
)
{
if
(
tab
!
=
draggedTab
)
{
let
shift
=
getTabShift
(
tab
newIndex
)
;
tab
.
style
.
transform
=
shift
?
"
translateX
(
"
+
shift
+
"
px
)
"
:
"
"
;
}
}
function
getTabShift
(
tab
dropIndex
)
{
if
(
tab
.
_tPos
<
draggedTab
.
_tPos
&
&
tab
.
_tPos
>
=
dropIndex
)
{
return
RTL_UI
?
-
shiftWidth
:
shiftWidth
;
}
if
(
tab
.
_tPos
>
draggedTab
.
_tPos
&
&
tab
.
_tPos
<
dropIndex
)
{
return
RTL_UI
?
shiftWidth
:
-
shiftWidth
;
}
return
0
;
}
}
_finishAnimateTabMove
(
)
{
if
(
this
.
getAttribute
(
"
movingtab
"
)
!
=
"
true
"
)
{
return
;
}
for
(
let
tab
of
this
.
_getVisibleTabs
(
)
)
{
tab
.
style
.
transform
=
"
"
;
}
this
.
removeAttribute
(
"
movingtab
"
)
;
gNavToolbox
.
removeAttribute
(
"
movingtab
"
)
;
this
.
_handleTabSelect
(
)
;
}
_groupSelectedTabs
(
tab
)
{
let
draggedTabPos
=
tab
.
_tPos
;
let
selectedTabs
=
gBrowser
.
selectedTabs
;
let
animate
=
gBrowser
.
animationsEnabled
;
tab
.
groupingTabsData
=
{
finished
:
!
animate
}
;
let
insertAtPos
=
draggedTabPos
-
1
;
for
(
let
i
=
selectedTabs
.
indexOf
(
tab
)
-
1
;
i
>
-
1
;
i
-
-
)
{
let
movingTab
=
selectedTabs
[
i
]
;
insertAtPos
=
newIndex
(
movingTab
insertAtPos
)
;
if
(
animate
)
{
movingTab
.
groupingTabsData
=
{
}
;
addAnimationData
(
movingTab
insertAtPos
"
left
"
)
;
}
else
{
gBrowser
.
moveTabTo
(
movingTab
insertAtPos
)
;
}
insertAtPos
-
-
;
}
insertAtPos
=
draggedTabPos
+
1
;
for
(
let
i
=
selectedTabs
.
indexOf
(
tab
)
+
1
;
i
<
selectedTabs
.
length
;
i
+
+
)
{
let
movingTab
=
selectedTabs
[
i
]
;
insertAtPos
=
newIndex
(
movingTab
insertAtPos
)
;
if
(
animate
)
{
movingTab
.
groupingTabsData
=
{
}
;
addAnimationData
(
movingTab
insertAtPos
"
right
"
)
;
}
else
{
gBrowser
.
moveTabTo
(
movingTab
insertAtPos
)
;
}
insertAtPos
+
+
;
}
for
(
let
t
of
this
.
_getVisibleTabs
(
)
)
{
if
(
t
.
groupingTabsData
&
&
t
.
groupingTabsData
.
translateX
)
{
let
translateX
=
(
RTL_UI
?
-
1
:
1
)
*
t
.
groupingTabsData
.
translateX
;
t
.
style
.
transform
=
"
translateX
(
"
+
translateX
+
"
px
)
"
;
}
}
function
newIndex
(
aTab
index
)
{
if
(
aTab
.
pinned
)
{
return
Math
.
min
(
index
gBrowser
.
_numPinnedTabs
-
1
)
;
}
return
Math
.
max
(
index
gBrowser
.
_numPinnedTabs
)
;
}
function
addAnimationData
(
movingTab
movingTabNewIndex
side
)
{
let
movingTabOldIndex
=
movingTab
.
_tPos
;
if
(
movingTabOldIndex
=
=
movingTabNewIndex
)
{
return
;
}
let
movingTabWidth
=
movingTab
.
getBoundingClientRect
(
)
.
width
;
let
shift
=
(
movingTabNewIndex
-
movingTabOldIndex
)
*
movingTabWidth
;
movingTab
.
groupingTabsData
.
animate
=
true
;
movingTab
.
setAttribute
(
"
tab
-
grouping
"
"
true
"
)
;
movingTab
.
groupingTabsData
.
translateX
=
shift
;
let
onTransitionEnd
=
transitionendEvent
=
>
{
if
(
transitionendEvent
.
propertyName
!
=
"
transform
"
|
|
transitionendEvent
.
originalTarget
!
=
movingTab
)
{
return
;
}
movingTab
.
removeEventListener
(
"
transitionend
"
onTransitionEnd
)
;
movingTab
.
groupingTabsData
.
newIndex
=
movingTabNewIndex
;
movingTab
.
groupingTabsData
.
animate
=
false
;
}
;
movingTab
.
addEventListener
(
"
transitionend
"
onTransitionEnd
)
;
let
lowerIndex
=
Math
.
min
(
movingTabOldIndex
draggedTabPos
)
;
let
higherIndex
=
Math
.
max
(
movingTabOldIndex
draggedTabPos
)
;
for
(
let
i
=
lowerIndex
+
1
;
i
<
higherIndex
;
i
+
+
)
{
let
middleTab
=
gBrowser
.
visibleTabs
[
i
]
;
if
(
middleTab
.
pinned
!
=
movingTab
.
pinned
)
{
break
;
}
if
(
middleTab
.
multiselected
)
{
continue
;
}
if
(
!
middleTab
.
groupingTabsData
|
|
!
middleTab
.
groupingTabsData
.
translateX
)
{
middleTab
.
groupingTabsData
=
{
translateX
:
0
}
;
}
if
(
side
=
=
"
left
"
)
{
middleTab
.
groupingTabsData
.
translateX
-
=
movingTabWidth
;
}
else
{
middleTab
.
groupingTabsData
.
translateX
+
=
movingTabWidth
;
}
middleTab
.
setAttribute
(
"
tab
-
grouping
"
"
true
"
)
;
}
}
}
_finishGroupSelectedTabs
(
tab
)
{
if
(
!
tab
.
groupingTabsData
|
|
tab
.
groupingTabsData
.
finished
)
{
return
;
}
tab
.
groupingTabsData
.
finished
=
true
;
let
selectedTabs
=
gBrowser
.
selectedTabs
;
let
tabIndex
=
selectedTabs
.
indexOf
(
tab
)
;
for
(
let
i
=
tabIndex
-
1
;
i
>
-
1
;
i
-
-
)
{
let
movingTab
=
selectedTabs
[
i
]
;
if
(
movingTab
.
groupingTabsData
.
newIndex
)
{
gBrowser
.
moveTabTo
(
movingTab
movingTab
.
groupingTabsData
.
newIndex
)
;
}
}
for
(
let
i
=
tabIndex
+
1
;
i
<
selectedTabs
.
length
;
i
+
+
)
{
let
movingTab
=
selectedTabs
[
i
]
;
if
(
movingTab
.
groupingTabsData
.
newIndex
)
{
gBrowser
.
moveTabTo
(
movingTab
movingTab
.
groupingTabsData
.
newIndex
)
;
}
}
for
(
let
t
of
this
.
_getVisibleTabs
(
)
)
{
t
.
style
.
transform
=
"
"
;
t
.
removeAttribute
(
"
tab
-
grouping
"
)
;
delete
t
.
groupingTabsData
;
}
}
_isGroupTabsAnimationOver
(
)
{
for
(
let
tab
of
gBrowser
.
selectedTabs
)
{
if
(
tab
.
groupingTabsData
&
&
tab
.
groupingTabsData
.
animate
)
{
return
false
;
}
}
return
true
;
}
handleEvent
(
aEvent
)
{
switch
(
aEvent
.
type
)
{
case
"
resize
"
:
if
(
aEvent
.
target
!
=
window
)
{
break
;
}
this
.
_updateCloseButtons
(
)
;
this
.
_handleTabSelect
(
true
)
;
break
;
case
"
mouseout
"
:
let
relatedTarget
=
aEvent
.
relatedTarget
;
if
(
relatedTarget
&
&
relatedTarget
.
ownerDocument
=
=
document
)
{
break
;
}
case
"
mousemove
"
:
if
(
document
.
getElementById
(
"
tabContextMenu
"
)
.
state
!
=
"
open
"
)
{
this
.
_unlockTabSizing
(
)
;
}
break
;
default
:
let
methodName
=
on_
{
aEvent
.
type
}
;
if
(
methodName
in
this
)
{
this
[
methodName
]
(
aEvent
)
;
}
else
{
throw
new
Error
(
Unexpected
event
{
aEvent
.
type
}
)
;
}
}
}
_notifyBackgroundTab
(
aTab
)
{
if
(
aTab
.
pinned
|
|
aTab
.
hidden
|
|
this
.
getAttribute
(
"
overflow
"
)
!
=
"
true
"
)
{
return
;
}
this
.
_lastTabToScrollIntoView
=
aTab
;
if
(
!
this
.
_backgroundTabScrollPromise
)
{
this
.
_backgroundTabScrollPromise
=
window
.
promiseDocumentFlushed
(
(
)
=
>
{
let
lastTabRect
=
this
.
_lastTabToScrollIntoView
.
getBoundingClientRect
(
)
;
let
selectedTab
=
this
.
selectedItem
;
if
(
selectedTab
.
pinned
)
{
selectedTab
=
null
;
}
else
{
selectedTab
=
selectedTab
.
getBoundingClientRect
(
)
;
selectedTab
=
{
left
:
selectedTab
.
left
right
:
selectedTab
.
right
}
;
}
return
[
this
.
_lastTabToScrollIntoView
this
.
arrowScrollbox
.
scrollClientRect
{
left
:
lastTabRect
.
left
right
:
lastTabRect
.
right
}
selectedTab
]
;
}
)
.
then
(
(
[
tabToScrollIntoView
scrollRect
tabRect
selectedRect
]
)
=
>
{
delete
this
.
_backgroundTabScrollPromise
;
if
(
this
.
_lastTabToScrollIntoView
!
=
tabToScrollIntoView
)
{
this
.
_notifyBackgroundTab
(
this
.
_lastTabToScrollIntoView
)
;
return
;
}
delete
this
.
_lastTabToScrollIntoView
;
if
(
scrollRect
.
left
<
=
tabRect
.
left
&
&
tabRect
.
right
<
=
scrollRect
.
right
)
{
return
;
}
if
(
this
.
arrowScrollbox
.
smoothScroll
)
{
if
(
!
selectedRect
|
|
Math
.
max
(
tabRect
.
right
-
selectedRect
.
left
selectedRect
.
right
-
tabRect
.
left
)
<
=
scrollRect
.
width
)
{
this
.
arrowScrollbox
.
ensureElementIsVisible
(
tabToScrollIntoView
)
;
return
;
}
this
.
arrowScrollbox
.
scrollByPixels
(
RTL_UI
?
selectedRect
.
right
-
scrollRect
.
right
:
selectedRect
.
left
-
scrollRect
.
left
)
;
}
if
(
!
this
.
_animateElement
.
hasAttribute
(
"
highlight
"
)
)
{
this
.
_animateElement
.
setAttribute
(
"
highlight
"
"
true
"
)
;
setTimeout
(
function
(
ele
)
{
ele
.
removeAttribute
(
"
highlight
"
)
;
}
150
this
.
_animateElement
)
;
}
}
)
;
}
}
_getDragTargetTab
(
event
isLink
)
{
let
tab
=
event
.
target
;
while
(
tab
&
&
tab
.
localName
!
=
"
tab
"
)
{
tab
=
tab
.
parentNode
;
}
if
(
tab
&
&
isLink
)
{
let
{
width
}
=
tab
.
getBoundingClientRect
(
)
;
if
(
event
.
screenX
<
tab
.
screenX
+
width
*
0
.
25
|
|
event
.
screenX
>
tab
.
screenX
+
width
*
0
.
75
)
{
return
null
;
}
}
return
tab
;
}
_getDropIndex
(
event
isLink
)
{
var
tabs
=
this
.
allTabs
;
var
tab
=
this
.
_getDragTargetTab
(
event
isLink
)
;
if
(
!
RTL_UI
)
{
for
(
let
i
=
tab
?
tab
.
_tPos
:
0
;
i
<
tabs
.
length
;
i
+
+
)
{
if
(
event
.
screenX
<
tabs
[
i
]
.
screenX
+
tabs
[
i
]
.
getBoundingClientRect
(
)
.
width
/
2
)
{
return
i
;
}
}
}
else
{
for
(
let
i
=
tab
?
tab
.
_tPos
:
0
;
i
<
tabs
.
length
;
i
+
+
)
{
if
(
event
.
screenX
>
tabs
[
i
]
.
screenX
+
tabs
[
i
]
.
getBoundingClientRect
(
)
.
width
/
2
)
{
return
i
;
}
}
}
return
tabs
.
length
;
}
_getDropEffectForTabDrag
(
event
)
{
var
dt
=
event
.
dataTransfer
;
let
isMovingTabs
=
dt
.
mozItemCount
>
0
;
for
(
let
i
=
0
;
i
<
dt
.
mozItemCount
;
i
+
+
)
{
let
types
=
dt
.
mozTypesAt
(
0
)
;
if
(
types
[
0
]
!
=
TAB_DROP_TYPE
)
{
isMovingTabs
=
false
;
break
;
}
}
if
(
isMovingTabs
)
{
let
sourceNode
=
dt
.
mozGetDataAt
(
TAB_DROP_TYPE
0
)
;
if
(
sourceNode
instanceof
XULElement
&
&
sourceNode
.
localName
=
=
"
tab
"
&
&
sourceNode
.
ownerGlobal
.
isChromeWindow
&
&
sourceNode
.
ownerDocument
.
documentElement
.
getAttribute
(
"
windowtype
"
)
=
=
"
navigator
:
browser
"
&
&
sourceNode
.
ownerGlobal
.
gBrowser
.
tabContainer
=
=
sourceNode
.
container
)
{
if
(
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
!
=
PrivateBrowsingUtils
.
isWindowPrivate
(
sourceNode
.
ownerGlobal
)
)
{
return
"
none
"
;
}
if
(
window
.
gMultiProcessBrowser
!
=
sourceNode
.
ownerGlobal
.
gMultiProcessBrowser
)
{
return
"
none
"
;
}
return
dt
.
dropEffect
=
=
"
copy
"
?
"
copy
"
:
"
move
"
;
}
}
if
(
browserDragAndDrop
.
canDropLink
(
event
)
)
{
return
"
link
"
;
}
return
"
none
"
;
}
_handleNewTab
(
tab
)
{
if
(
tab
.
container
!
=
this
)
{
return
;
}
tab
.
_fullyOpen
=
true
;
gBrowser
.
tabAnimationsInProgress
-
-
;
this
.
_updateCloseButtons
(
)
;
if
(
tab
.
getAttribute
(
"
selected
"
)
=
=
"
true
"
)
{
this
.
_handleTabSelect
(
)
;
}
else
if
(
!
tab
.
hasAttribute
(
"
skipbackgroundnotify
"
)
)
{
this
.
_notifyBackgroundTab
(
tab
)
;
}
this
.
arrowScrollbox
.
_updateScrollButtonsDisabledState
(
)
;
if
(
tab
.
linkedPanel
)
{
NewTabPagePreloading
.
maybeCreatePreloadedBrowser
(
window
)
;
}
}
_canAdvanceToTab
(
aTab
)
{
return
!
aTab
.
closing
;
}
getRelatedElement
(
aTab
)
{
if
(
!
aTab
)
{
return
null
;
}
if
(
!
gBrowser
.
_initialized
)
{
return
this
.
tabbox
.
tabpanels
.
firstElementChild
;
}
gBrowser
.
_insertBrowser
(
aTab
)
;
return
document
.
getElementById
(
aTab
.
linkedPanel
)
;
}
_updateNewTabVisibility
(
)
{
let
wrap
=
n
=
>
n
.
parentNode
.
localName
=
=
"
toolbarpaletteitem
"
?
n
.
parentNode
:
n
;
let
unwrap
=
n
=
>
n
&
&
n
.
localName
=
=
"
toolbarpaletteitem
"
?
n
.
firstElementChild
:
n
;
let
sib
=
this
;
do
{
sib
=
unwrap
(
wrap
(
sib
)
.
nextElementSibling
)
;
}
while
(
sib
&
&
(
sib
.
hidden
|
|
sib
.
id
=
=
"
alltabs
-
button
"
)
)
;
const
kAttr
=
"
hasadjacentnewtabbutton
"
;
if
(
sib
&
&
sib
.
id
=
=
"
new
-
tab
-
button
"
)
{
this
.
setAttribute
(
kAttr
"
true
"
)
;
}
else
{
this
.
removeAttribute
(
kAttr
)
;
}
}
onWidgetAfterDOMChange
(
aNode
aNextNode
aContainer
)
{
if
(
aContainer
.
ownerDocument
=
=
document
&
&
aContainer
.
id
=
=
"
TabsToolbar
-
customization
-
target
"
)
{
this
.
_updateNewTabVisibility
(
)
;
}
}
onAreaNodeRegistered
(
aArea
aContainer
)
{
if
(
aContainer
.
ownerDocument
=
=
document
&
&
aArea
=
=
"
TabsToolbar
"
)
{
this
.
_updateNewTabVisibility
(
)
;
}
}
onAreaReset
(
aArea
aContainer
)
{
this
.
onAreaNodeRegistered
(
aArea
aContainer
)
;
}
_hiddenSoundPlayingStatusChanged
(
tab
opts
)
{
let
closed
=
opts
&
&
opts
.
closed
;
if
(
!
closed
&
&
tab
.
soundPlaying
&
&
tab
.
hidden
)
{
this
.
_hiddenSoundPlayingTabs
.
add
(
tab
)
;
this
.
setAttribute
(
"
hiddensoundplaying
"
"
true
"
)
;
}
else
{
this
.
_hiddenSoundPlayingTabs
.
delete
(
tab
)
;
if
(
this
.
_hiddenSoundPlayingTabs
.
size
=
=
0
)
{
this
.
removeAttribute
(
"
hiddensoundplaying
"
)
;
}
}
}
destroy
(
)
{
if
(
this
.
boundObserve
)
{
Services
.
prefs
.
removeObserver
(
"
privacy
.
userContext
"
this
.
boundObserve
)
;
}
CustomizableUI
.
removeListener
(
this
)
;
}
}
customElements
.
define
(
"
tabbrowser
-
tabs
"
MozTabbrowserTabs
{
extends
:
"
tabs
"
}
)
;
}
