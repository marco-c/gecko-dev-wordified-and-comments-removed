Components
.
utils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Components
.
utils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
AppConstants
"
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PlacesUtils
"
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
FormHistory
"
"
resource
:
/
/
gre
/
modules
/
FormHistory
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Downloads
"
"
resource
:
/
/
gre
/
modules
/
Downloads
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Promise
"
"
resource
:
/
/
gre
/
modules
/
Promise
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PromiseUtils
"
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Task
"
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
DownloadsCommon
"
"
resource
:
/
/
/
modules
/
DownloadsCommon
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
TelemetryStopwatch
"
"
resource
:
/
/
gre
/
modules
/
TelemetryStopwatch
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
console
"
"
resource
:
/
/
gre
/
modules
/
Console
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Preferences
"
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
setTimeout
"
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
const
YIELD_PERIOD
=
10
;
function
Sanitizer
(
)
{
}
Sanitizer
.
prototype
=
{
clearItem
:
function
(
aItemName
)
{
this
.
items
[
aItemName
]
.
clear
(
)
;
}
prefDomain
:
"
"
getNameFromPreference
:
function
(
aPreferenceName
)
{
return
aPreferenceName
.
substr
(
this
.
prefDomain
.
length
)
;
}
sanitize
:
Task
.
async
(
function
*
(
aItemsToClear
=
null
)
{
let
progress
=
{
}
;
let
promise
=
this
.
_sanitize
(
aItemsToClear
progress
)
;
let
shutdownClient
=
Cc
[
"
mozilla
.
org
/
browser
/
nav
-
history
-
service
;
1
"
]
.
getService
(
Ci
.
nsPIPlacesDatabase
)
.
shutdownClient
.
jsclient
;
shutdownClient
.
addBlocker
(
"
sanitize
.
js
:
Sanitize
"
promise
{
fetchState
:
(
)
=
>
{
return
{
progress
}
;
}
}
)
;
try
{
yield
promise
;
}
finally
{
Services
.
obs
.
notifyObservers
(
null
"
sanitizer
-
sanitization
-
complete
"
"
"
)
;
}
}
)
_sanitize
:
Task
.
async
(
function
*
(
aItemsToClear
progress
=
{
}
)
{
let
seenError
=
false
;
let
itemsToClear
;
if
(
Array
.
isArray
(
aItemsToClear
)
)
{
itemsToClear
=
[
.
.
.
aItemsToClear
]
;
}
else
{
let
branch
=
Services
.
prefs
.
getBranch
(
this
.
prefDomain
)
;
itemsToClear
=
Object
.
keys
(
this
.
items
)
.
filter
(
itemName
=
>
{
try
{
return
branch
.
getBoolPref
(
itemName
)
;
}
catch
(
ex
)
{
return
false
;
}
}
)
;
}
Preferences
.
set
(
Sanitizer
.
PREF_SANITIZE_IN_PROGRESS
JSON
.
stringify
(
itemsToClear
)
)
;
for
(
let
k
of
itemsToClear
)
{
progress
[
k
]
=
"
ready
"
;
}
let
openWindowsIndex
=
itemsToClear
.
indexOf
(
"
openWindows
"
)
;
if
(
openWindowsIndex
!
=
-
1
)
{
itemsToClear
.
splice
(
openWindowsIndex
1
)
;
yield
this
.
items
.
openWindows
.
clear
(
)
;
progress
.
openWindows
=
"
cleared
"
;
}
let
range
=
null
;
if
(
!
this
.
ignoreTimespan
)
{
range
=
this
.
range
|
|
Sanitizer
.
getClearRange
(
)
;
}
let
refObj
=
{
}
;
TelemetryStopwatch
.
start
(
"
FX_SANITIZE_TOTAL
"
refObj
)
;
let
annotateError
=
(
name
ex
)
=
>
{
progress
[
name
]
=
"
failed
"
;
seenError
=
true
;
console
.
error
(
"
Error
sanitizing
"
+
name
ex
)
;
}
;
let
handles
=
[
]
;
for
(
let
itemName
of
itemsToClear
)
{
let
name
=
itemName
;
let
item
=
this
.
items
[
name
]
;
try
{
handles
.
push
(
{
name
promise
:
item
.
clear
(
range
)
.
then
(
(
)
=
>
progress
[
name
]
=
"
cleared
"
ex
=
>
annotateError
(
name
ex
)
)
}
)
;
}
catch
(
ex
)
{
annotateError
(
name
ex
)
;
}
}
for
(
let
handle
of
handles
)
{
progress
[
handle
.
name
]
=
"
blocking
"
;
yield
handle
.
promise
;
}
TelemetryStopwatch
.
finish
(
"
FX_SANITIZE_TOTAL
"
refObj
)
;
Preferences
.
reset
(
Sanitizer
.
PREF_SANITIZE_IN_PROGRESS
)
;
progress
=
{
}
;
if
(
seenError
)
{
throw
new
Error
(
"
Error
sanitizing
"
)
;
}
}
)
ignoreTimespan
:
true
range
:
null
items
:
{
cache
:
{
clear
:
Task
.
async
(
function
*
(
range
)
{
let
seenException
;
let
refObj
=
{
}
;
TelemetryStopwatch
.
start
(
"
FX_SANITIZE_CACHE
"
refObj
)
;
try
{
let
cache
=
Cc
[
"
mozilla
.
org
/
netwerk
/
cache
-
storage
-
service
;
1
"
]
.
getService
(
Ci
.
nsICacheStorageService
)
;
cache
.
clear
(
)
;
}
catch
(
ex
)
{
seenException
=
ex
;
}
try
{
let
imageCache
=
Cc
[
"
mozilla
.
org
/
image
/
tools
;
1
"
]
.
getService
(
Ci
.
imgITools
)
.
getImgCacheForDocument
(
null
)
;
imageCache
.
clearCache
(
false
)
;
}
catch
(
ex
)
{
seenException
=
ex
;
}
TelemetryStopwatch
.
finish
(
"
FX_SANITIZE_CACHE
"
refObj
)
;
if
(
seenException
)
{
throw
seenException
;
}
}
)
}
cookies
:
{
clear
:
Task
.
async
(
function
*
(
range
)
{
let
seenException
;
let
yieldCounter
=
0
;
let
refObj
=
{
}
;
TelemetryStopwatch
.
start
(
"
FX_SANITIZE_COOKIES
"
refObj
)
;
TelemetryStopwatch
.
start
(
"
FX_SANITIZE_COOKIES_2
"
refObj
)
;
try
{
let
cookieMgr
=
Components
.
classes
[
"
mozilla
.
org
/
cookiemanager
;
1
"
]
.
getService
(
Ci
.
nsICookieManager
)
;
if
(
range
)
{
let
cookiesEnum
=
cookieMgr
.
enumerator
;
while
(
cookiesEnum
.
hasMoreElements
(
)
)
{
let
cookie
=
cookiesEnum
.
getNext
(
)
.
QueryInterface
(
Ci
.
nsICookie2
)
;
if
(
cookie
.
creationTime
>
range
[
0
]
)
{
cookieMgr
.
remove
(
cookie
.
host
cookie
.
name
cookie
.
path
cookie
.
originAttributes
false
)
;
if
(
+
+
yieldCounter
%
YIELD_PERIOD
=
=
0
)
{
yield
new
Promise
(
resolve
=
>
setTimeout
(
resolve
0
)
)
;
}
}
}
}
else
{
cookieMgr
.
removeAll
(
)
;
yield
new
Promise
(
resolve
=
>
setTimeout
(
resolve
0
)
)
;
}
}
catch
(
ex
)
{
seenException
=
ex
;
}
finally
{
TelemetryStopwatch
.
finish
(
"
FX_SANITIZE_COOKIES_2
"
refObj
)
;
}
try
{
let
mediaMgr
=
Components
.
classes
[
"
mozilla
.
org
/
mediaManagerService
;
1
"
]
.
getService
(
Ci
.
nsIMediaManagerService
)
;
mediaMgr
.
sanitizeDeviceIds
(
range
&
&
range
[
0
]
)
;
}
catch
(
ex
)
{
seenException
=
ex
;
}
let
promiseClearPluginCookies
;
TelemetryStopwatch
.
start
(
"
FX_SANITIZE_PLUGINS
"
refObj
)
;
try
{
promiseClearPluginCookies
=
this
.
promiseClearPluginCookies
(
range
)
;
yield
Promise
.
race
(
[
promiseClearPluginCookies
new
Promise
(
resolve
=
>
setTimeout
(
resolve
10000
)
)
]
)
;
}
catch
(
ex
)
{
seenException
=
ex
;
}
promiseClearPluginCookies
.
catch
(
(
)
=
>
{
}
)
.
then
(
(
)
=
>
{
TelemetryStopwatch
.
finish
(
"
FX_SANITIZE_PLUGINS
"
refObj
)
;
TelemetryStopwatch
.
finish
(
"
FX_SANITIZE_COOKIES
"
refObj
)
;
}
)
;
if
(
seenException
)
{
throw
seenException
;
}
}
)
promiseClearPluginCookies
:
Task
.
async
(
function
*
(
range
)
{
const
FLAG_CLEAR_ALL
=
Ci
.
nsIPluginHost
.
FLAG_CLEAR_ALL
;
let
ph
=
Cc
[
"
mozilla
.
org
/
plugin
/
host
;
1
"
]
.
getService
(
Ci
.
nsIPluginHost
)
;
let
age
=
range
?
(
Date
.
now
(
)
/
1000
-
range
[
0
]
/
1000000
)
:
-
1
;
if
(
!
range
|
|
age
>
=
0
)
{
let
tags
=
ph
.
getPluginTags
(
)
;
for
(
let
tag
of
tags
)
{
let
refObj
=
{
}
;
let
probe
=
"
"
;
if
(
/
\
bFlash
\
b
/
.
test
(
tag
.
name
)
)
{
probe
=
tag
.
loaded
?
"
FX_SANITIZE_LOADED_FLASH
"
:
"
FX_SANITIZE_UNLOADED_FLASH
"
;
TelemetryStopwatch
.
start
(
probe
refObj
)
;
}
try
{
let
rv
=
yield
new
Promise
(
resolve
=
>
ph
.
clearSiteData
(
tag
null
FLAG_CLEAR_ALL
age
resolve
)
)
;
if
(
rv
=
=
Components
.
results
.
NS_ERROR_PLUGIN_TIME_RANGE_NOT_SUPPORTED
)
{
yield
new
Promise
(
resolve
=
>
ph
.
clearSiteData
(
tag
null
FLAG_CLEAR_ALL
-
1
resolve
)
)
;
}
if
(
probe
)
{
TelemetryStopwatch
.
finish
(
probe
refObj
)
;
}
}
catch
(
ex
)
{
if
(
probe
)
{
TelemetryStopwatch
.
cancel
(
probe
refObj
)
;
}
}
}
}
}
)
}
offlineApps
:
{
clear
:
Task
.
async
(
function
*
(
range
)
{
let
refObj
=
{
}
;
TelemetryStopwatch
.
start
(
"
FX_SANITIZE_OFFLINEAPPS
"
refObj
)
;
try
{
Components
.
utils
.
import
(
"
resource
:
/
/
/
modules
/
offlineAppCache
.
jsm
"
)
;
OfflineAppCacheHelper
.
clear
(
)
;
}
finally
{
TelemetryStopwatch
.
finish
(
"
FX_SANITIZE_OFFLINEAPPS
"
refObj
)
;
}
}
)
}
history
:
{
clear
:
Task
.
async
(
function
*
(
range
)
{
let
seenException
;
let
refObj
=
{
}
;
TelemetryStopwatch
.
start
(
"
FX_SANITIZE_HISTORY
"
refObj
)
;
try
{
if
(
range
)
{
yield
PlacesUtils
.
history
.
removeVisitsByFilter
(
{
beginDate
:
new
Date
(
range
[
0
]
/
1000
)
endDate
:
new
Date
(
range
[
1
]
/
1000
)
}
)
;
}
else
{
yield
PlacesUtils
.
history
.
clear
(
)
;
}
}
catch
(
ex
)
{
seenException
=
ex
;
}
finally
{
TelemetryStopwatch
.
finish
(
"
FX_SANITIZE_HISTORY
"
refObj
)
;
}
try
{
let
clearStartingTime
=
range
?
String
(
range
[
0
]
)
:
"
"
;
Services
.
obs
.
notifyObservers
(
null
"
browser
:
purge
-
session
-
history
"
clearStartingTime
)
;
}
catch
(
ex
)
{
seenException
=
ex
;
}
try
{
let
predictor
=
Components
.
classes
[
"
mozilla
.
org
/
network
/
predictor
;
1
"
]
.
getService
(
Components
.
interfaces
.
nsINetworkPredictor
)
;
predictor
.
reset
(
)
;
}
catch
(
ex
)
{
seenException
=
ex
;
}
if
(
seenException
)
{
throw
seenException
;
}
}
)
}
formdata
:
{
clear
:
Task
.
async
(
function
*
(
range
)
{
let
seenException
;
let
refObj
=
{
}
;
TelemetryStopwatch
.
start
(
"
FX_SANITIZE_FORMDATA
"
refObj
)
;
try
{
let
windows
=
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
;
while
(
windows
.
hasMoreElements
(
)
)
{
let
currentWindow
=
windows
.
getNext
(
)
;
let
currentDocument
=
currentWindow
.
document
;
let
searchBar
=
currentDocument
.
getElementById
(
"
searchbar
"
)
;
if
(
searchBar
)
searchBar
.
textbox
.
reset
(
)
;
let
tabBrowser
=
currentWindow
.
gBrowser
;
if
(
!
tabBrowser
)
{
continue
;
}
for
(
let
tab
of
tabBrowser
.
tabs
)
{
if
(
tabBrowser
.
isFindBarInitialized
(
tab
)
)
tabBrowser
.
getFindBar
(
tab
)
.
clear
(
)
;
}
tabBrowser
.
_lastFindValue
=
"
"
;
}
}
catch
(
ex
)
{
seenException
=
ex
;
}
try
{
let
change
=
{
op
:
"
remove
"
}
;
if
(
range
)
{
[
change
.
firstUsedStart
change
.
firstUsedEnd
]
=
range
;
}
yield
new
Promise
(
resolve
=
>
{
FormHistory
.
update
(
change
{
handleError
(
e
)
{
seenException
=
new
Error
(
"
Error
"
+
e
.
result
+
"
:
"
+
e
.
message
)
;
}
handleCompletion
(
)
{
resolve
(
)
;
}
}
)
;
}
)
;
}
catch
(
ex
)
{
seenException
=
ex
;
}
TelemetryStopwatch
.
finish
(
"
FX_SANITIZE_FORMDATA
"
refObj
)
;
if
(
seenException
)
{
throw
seenException
;
}
}
)
}
downloads
:
{
clear
:
Task
.
async
(
function
*
(
range
)
{
let
refObj
=
{
}
;
TelemetryStopwatch
.
start
(
"
FX_SANITIZE_DOWNLOADS
"
refObj
)
;
try
{
let
filterByTime
=
null
;
if
(
range
)
{
let
rangeBeginMs
=
range
[
0
]
/
1000
;
let
rangeEndMs
=
range
[
1
]
/
1000
;
filterByTime
=
download
=
>
download
.
startTime
>
=
rangeBeginMs
&
&
download
.
startTime
<
=
rangeEndMs
;
}
let
list
=
yield
Downloads
.
getList
(
Downloads
.
ALL
)
;
list
.
removeFinished
(
filterByTime
)
;
}
finally
{
TelemetryStopwatch
.
finish
(
"
FX_SANITIZE_DOWNLOADS
"
refObj
)
;
}
}
)
}
sessions
:
{
clear
:
Task
.
async
(
function
*
(
range
)
{
let
refObj
=
{
}
;
TelemetryStopwatch
.
start
(
"
FX_SANITIZE_SESSIONS
"
refObj
)
;
try
{
let
sdr
=
Components
.
classes
[
"
mozilla
.
org
/
security
/
sdr
;
1
"
]
.
getService
(
Components
.
interfaces
.
nsISecretDecoderRing
)
;
sdr
.
logoutAndTeardown
(
)
;
Services
.
obs
.
notifyObservers
(
null
"
net
:
clear
-
active
-
logins
"
null
)
;
}
finally
{
TelemetryStopwatch
.
finish
(
"
FX_SANITIZE_SESSIONS
"
refObj
)
;
}
}
)
}
siteSettings
:
{
clear
:
Task
.
async
(
function
*
(
range
)
{
let
seenException
;
let
refObj
=
{
}
;
TelemetryStopwatch
.
start
(
"
FX_SANITIZE_SITESETTINGS
"
refObj
)
;
let
startDateMS
=
range
?
range
[
0
]
/
1000
:
null
;
try
{
if
(
startDateMS
=
=
null
)
{
Services
.
perms
.
removeAll
(
)
;
}
else
{
Services
.
perms
.
removeAllSince
(
startDateMS
)
;
}
}
catch
(
ex
)
{
seenException
=
ex
;
}
try
{
let
cps
=
Components
.
classes
[
"
mozilla
.
org
/
content
-
pref
/
service
;
1
"
]
.
getService
(
Components
.
interfaces
.
nsIContentPrefService2
)
;
if
(
startDateMS
=
=
null
)
{
cps
.
removeAllDomains
(
null
)
;
}
else
{
cps
.
removeAllDomainsSince
(
startDateMS
null
)
;
}
}
catch
(
ex
)
{
seenException
=
ex
;
}
try
{
let
hosts
=
Services
.
logins
.
getAllDisabledHosts
(
)
;
for
(
let
host
of
hosts
)
{
Services
.
logins
.
setLoginSavingEnabled
(
host
true
)
;
}
}
catch
(
ex
)
{
seenException
=
ex
;
}
try
{
let
sss
=
Cc
[
"
mozilla
.
org
/
ssservice
;
1
"
]
.
getService
(
Ci
.
nsISiteSecurityService
)
;
sss
.
clearAll
(
)
;
}
catch
(
ex
)
{
seenException
=
ex
;
}
try
{
let
push
=
Cc
[
"
mozilla
.
org
/
push
/
Service
;
1
"
]
.
getService
(
Ci
.
nsIPushService
)
;
push
.
clearForDomain
(
"
*
"
status
=
>
{
if
(
!
Components
.
isSuccessCode
(
status
)
)
{
dump
(
"
Error
clearing
Web
Push
data
:
"
+
status
+
"
\
n
"
)
;
}
}
)
;
}
catch
(
e
)
{
dump
(
"
Web
Push
may
not
be
available
.
\
n
"
)
;
}
TelemetryStopwatch
.
finish
(
"
FX_SANITIZE_SITESETTINGS
"
refObj
)
;
if
(
seenException
)
{
throw
seenException
;
}
}
)
}
openWindows
:
{
privateStateForNewWindow
:
"
non
-
private
"
_canCloseWindow
:
function
(
aWindow
)
{
if
(
aWindow
.
CanCloseWindow
(
)
)
{
aWindow
.
skipNextCanClose
=
true
;
return
true
;
}
return
false
;
}
_resetAllWindowClosures
:
function
(
aWindowList
)
{
for
(
let
win
of
aWindowList
)
{
win
.
skipNextCanClose
=
false
;
}
}
clear
:
Task
.
async
(
function
*
(
)
{
let
existingWindow
=
Services
.
appShell
.
hiddenDOMWindow
;
let
startDate
=
existingWindow
.
performance
.
now
(
)
;
let
windowEnumerator
=
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
;
let
windowList
=
[
]
;
while
(
windowEnumerator
.
hasMoreElements
(
)
)
{
let
someWin
=
windowEnumerator
.
getNext
(
)
;
windowList
.
push
(
someWin
)
;
if
(
!
this
.
_canCloseWindow
(
someWin
)
)
{
this
.
_resetAllWindowClosures
(
windowList
)
;
throw
new
Error
(
"
Sanitize
could
not
close
windows
:
cancelled
by
user
"
)
;
}
if
(
existingWindow
.
performance
.
now
(
)
>
(
startDate
+
60
*
1000
)
)
{
this
.
_resetAllWindowClosures
(
windowList
)
;
throw
new
Error
(
"
Sanitize
could
not
close
windows
:
timeout
"
)
;
}
}
let
refObj
=
{
}
;
TelemetryStopwatch
.
start
(
"
FX_SANITIZE_OPENWINDOWS
"
refObj
)
;
let
handler
=
Cc
[
"
mozilla
.
org
/
browser
/
clh
;
1
"
]
.
getService
(
Ci
.
nsIBrowserHandler
)
;
let
defaultArgs
=
handler
.
defaultArgs
;
let
features
=
"
chrome
all
dialog
=
no
"
+
this
.
privateStateForNewWindow
;
let
newWindow
=
existingWindow
.
openDialog
(
"
chrome
:
/
/
browser
/
content
/
"
"
_blank
"
features
defaultArgs
)
;
let
onFullScreen
=
null
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
onFullScreen
=
function
(
e
)
{
newWindow
.
removeEventListener
(
"
fullscreen
"
onFullScreen
)
;
let
docEl
=
newWindow
.
document
.
documentElement
;
let
sizemode
=
docEl
.
getAttribute
(
"
sizemode
"
)
;
if
(
!
newWindow
.
fullScreen
&
&
sizemode
=
=
"
fullscreen
"
)
{
docEl
.
setAttribute
(
"
sizemode
"
"
normal
"
)
;
e
.
preventDefault
(
)
;
e
.
stopPropagation
(
)
;
return
false
;
}
return
undefined
;
}
newWindow
.
addEventListener
(
"
fullscreen
"
onFullScreen
)
;
}
let
promiseReady
=
new
Promise
(
resolve
=
>
{
let
newWindowOpened
=
false
;
let
onWindowOpened
=
function
(
subject
topic
data
)
{
if
(
subject
!
=
newWindow
)
return
;
Services
.
obs
.
removeObserver
(
onWindowOpened
"
browser
-
delayed
-
startup
-
finished
"
)
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
newWindow
.
removeEventListener
(
"
fullscreen
"
onFullScreen
)
;
}
newWindowOpened
=
true
;
if
(
numWindowsClosing
=
=
0
)
{
TelemetryStopwatch
.
finish
(
"
FX_SANITIZE_OPENWINDOWS
"
refObj
)
;
resolve
(
)
;
}
}
let
numWindowsClosing
=
windowList
.
length
;
let
onWindowClosed
=
function
(
)
{
numWindowsClosing
-
-
;
if
(
numWindowsClosing
=
=
0
)
{
Services
.
obs
.
removeObserver
(
onWindowClosed
"
xul
-
window
-
destroyed
"
)
;
if
(
newWindowOpened
)
{
TelemetryStopwatch
.
finish
(
"
FX_SANITIZE_OPENWINDOWS
"
refObj
)
;
resolve
(
)
;
}
}
}
Services
.
obs
.
addObserver
(
onWindowOpened
"
browser
-
delayed
-
startup
-
finished
"
false
)
;
Services
.
obs
.
addObserver
(
onWindowClosed
"
xul
-
window
-
destroyed
"
false
)
;
}
)
;
while
(
windowList
.
length
)
{
windowList
.
pop
(
)
.
close
(
)
;
}
newWindow
.
focus
(
)
;
yield
promiseReady
;
}
)
}
}
}
;
Sanitizer
.
PREF_DOMAIN
=
"
privacy
.
sanitize
.
"
;
Sanitizer
.
PREF_SANITIZE_ON_SHUTDOWN
=
"
privacy
.
sanitize
.
sanitizeOnShutdown
"
;
Sanitizer
.
PREF_SANITIZE_IN_PROGRESS
=
"
privacy
.
sanitize
.
sanitizeInProgress
"
;
Sanitizer
.
PREF_SANITIZE_DID_SHUTDOWN
=
"
privacy
.
sanitize
.
didShutdownSanitize
"
;
Sanitizer
.
TIMESPAN_EVERYTHING
=
0
;
Sanitizer
.
TIMESPAN_HOUR
=
1
;
Sanitizer
.
TIMESPAN_2HOURS
=
2
;
Sanitizer
.
TIMESPAN_4HOURS
=
3
;
Sanitizer
.
TIMESPAN_TODAY
=
4
;
Sanitizer
.
TIMESPAN_5MIN
=
5
;
Sanitizer
.
TIMESPAN_24HOURS
=
6
;
Sanitizer
.
getClearRange
=
function
(
ts
)
{
if
(
ts
=
=
=
undefined
)
ts
=
Sanitizer
.
prefs
.
getIntPref
(
"
timeSpan
"
)
;
if
(
ts
=
=
=
Sanitizer
.
TIMESPAN_EVERYTHING
)
return
null
;
var
endDate
=
Date
.
now
(
)
*
1000
;
switch
(
ts
)
{
case
Sanitizer
.
TIMESPAN_5MIN
:
var
startDate
=
endDate
-
300000000
;
break
;
case
Sanitizer
.
TIMESPAN_HOUR
:
startDate
=
endDate
-
3600000000
;
break
;
case
Sanitizer
.
TIMESPAN_2HOURS
:
startDate
=
endDate
-
7200000000
;
break
;
case
Sanitizer
.
TIMESPAN_4HOURS
:
startDate
=
endDate
-
14400000000
;
break
;
case
Sanitizer
.
TIMESPAN_TODAY
:
var
d
=
new
Date
(
)
;
d
.
setHours
(
0
)
;
d
.
setMinutes
(
0
)
;
d
.
setSeconds
(
0
)
;
startDate
=
d
.
valueOf
(
)
*
1000
;
break
;
case
Sanitizer
.
TIMESPAN_24HOURS
:
startDate
=
endDate
-
86400000000
;
break
;
default
:
throw
"
Invalid
time
span
for
clear
private
data
:
"
+
ts
;
}
return
[
startDate
endDate
]
;
}
;
Sanitizer
.
_prefs
=
null
;
Sanitizer
.
__defineGetter__
(
"
prefs
"
function
(
)
{
return
Sanitizer
.
_prefs
?
Sanitizer
.
_prefs
:
Sanitizer
.
_prefs
=
Components
.
classes
[
"
mozilla
.
org
/
preferences
-
service
;
1
"
]
.
getService
(
Components
.
interfaces
.
nsIPrefService
)
.
getBranch
(
Sanitizer
.
PREF_DOMAIN
)
;
}
)
;
Sanitizer
.
showUI
=
function
(
aParentWindow
)
{
let
win
=
AppConstants
.
platform
=
=
"
macosx
"
?
null
:
aParentWindow
;
Services
.
ww
.
openWindow
(
win
"
chrome
:
/
/
browser
/
content
/
sanitize
.
xul
"
"
Sanitize
"
"
chrome
titlebar
dialog
centerscreen
modal
"
null
)
;
}
;
Sanitizer
.
sanitize
=
function
(
aParentWindow
)
{
Sanitizer
.
showUI
(
aParentWindow
)
;
}
;
Sanitizer
.
onStartup
=
Task
.
async
(
function
*
(
)
{
let
shutownSanitizationWasInterrupted
=
Preferences
.
get
(
Sanitizer
.
PREF_SANITIZE_ON_SHUTDOWN
false
)
&
&
!
Preferences
.
has
(
Sanitizer
.
PREF_SANITIZE_DID_SHUTDOWN
)
;
if
(
Preferences
.
has
(
Sanitizer
.
PREF_SANITIZE_DID_SHUTDOWN
)
)
{
Preferences
.
reset
(
Sanitizer
.
PREF_SANITIZE_DID_SHUTDOWN
)
;
Services
.
prefs
.
savePrefFile
(
null
)
;
}
let
placesClient
=
Cc
[
"
mozilla
.
org
/
browser
/
nav
-
history
-
service
;
1
"
]
.
getService
(
Ci
.
nsPIPlacesDatabase
)
.
shutdownClient
.
jsclient
;
let
deferredSanitization
=
PromiseUtils
.
defer
(
)
;
let
sanitizationInProgress
=
false
;
let
doSanitize
=
function
(
)
{
if
(
!
sanitizationInProgress
)
{
sanitizationInProgress
=
true
;
Sanitizer
.
onShutdown
(
)
.
catch
(
er
=
>
{
Promise
.
reject
(
er
)
;
}
)
.
then
(
(
)
=
>
deferredSanitization
.
resolve
(
)
)
;
}
return
deferredSanitization
.
promise
;
}
placesClient
.
addBlocker
(
"
sanitize
.
js
:
Sanitize
on
shutdown
"
doSanitize
)
;
let
lastInterruptedSanitization
=
Preferences
.
get
(
Sanitizer
.
PREF_SANITIZE_IN_PROGRESS
"
"
)
;
if
(
lastInterruptedSanitization
)
{
let
s
=
new
Sanitizer
(
)
;
let
itemsToClear
=
JSON
.
parse
(
lastInterruptedSanitization
)
;
yield
s
.
sanitize
(
itemsToClear
)
;
}
else
if
(
shutownSanitizationWasInterrupted
)
{
yield
Sanitizer
.
onShutdown
(
)
;
}
}
)
;
Sanitizer
.
onShutdown
=
Task
.
async
(
function
*
(
)
{
if
(
!
Preferences
.
get
(
Sanitizer
.
PREF_SANITIZE_ON_SHUTDOWN
)
)
{
return
;
}
let
s
=
new
Sanitizer
(
)
;
s
.
prefDomain
=
"
privacy
.
clearOnShutdown
.
"
;
yield
s
.
sanitize
(
)
;
Preferences
.
set
(
Sanitizer
.
PREF_SANITIZE_DID_SHUTDOWN
true
)
;
Services
.
prefs
.
savePrefFile
(
null
)
;
}
)
;
