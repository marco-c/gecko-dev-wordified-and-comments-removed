ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AppConstants
:
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
PlacesUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
FormHistory
:
"
resource
:
/
/
gre
/
modules
/
FormHistory
.
jsm
"
Downloads
:
"
resource
:
/
/
gre
/
modules
/
Downloads
.
jsm
"
DownloadsCommon
:
"
resource
:
/
/
/
modules
/
DownloadsCommon
.
jsm
"
TelemetryStopwatch
:
"
resource
:
/
/
gre
/
modules
/
TelemetryStopwatch
.
jsm
"
console
:
"
resource
:
/
/
gre
/
modules
/
Console
.
jsm
"
setTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
serviceWorkerManager
"
"
mozilla
.
org
/
serviceworkers
/
manager
;
1
"
"
nsIServiceWorkerManager
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
quotaManagerService
"
"
mozilla
.
org
/
dom
/
quota
-
manager
-
service
;
1
"
"
nsIQuotaManagerService
"
)
;
var
{
classes
:
Cc
interfaces
:
Ci
results
:
Cr
}
=
Components
;
const
YIELD_PERIOD
=
10
;
function
Sanitizer
(
)
{
}
Sanitizer
.
prototype
=
{
clearItem
(
aItemName
)
{
this
.
items
[
aItemName
]
.
clear
(
)
;
}
prefDomain
:
"
"
getNameFromPreference
(
aPreferenceName
)
{
return
aPreferenceName
.
substr
(
this
.
prefDomain
.
length
)
;
}
async
sanitize
(
itemsToClear
=
null
options
=
{
}
)
{
let
progress
=
options
.
progress
|
|
{
}
;
let
promise
=
this
.
_sanitize
(
itemsToClear
progress
)
;
if
(
!
progress
.
isShutdown
)
{
let
shutdownClient
=
Cc
[
"
mozilla
.
org
/
browser
/
nav
-
history
-
service
;
1
"
]
.
getService
(
Ci
.
nsPIPlacesDatabase
)
.
shutdownClient
.
jsclient
;
shutdownClient
.
addBlocker
(
"
sanitize
.
js
:
Sanitize
"
promise
{
fetchState
:
(
)
=
>
(
{
progress
}
)
}
)
;
}
try
{
await
promise
;
}
finally
{
Services
.
obs
.
notifyObservers
(
null
"
sanitizer
-
sanitization
-
complete
"
)
;
}
}
async
_sanitize
(
aItemsToClear
progress
=
{
}
)
{
let
seenError
=
false
;
let
itemsToClear
;
if
(
Array
.
isArray
(
aItemsToClear
)
)
{
itemsToClear
=
[
.
.
.
aItemsToClear
]
;
}
else
{
let
branch
=
Services
.
prefs
.
getBranch
(
this
.
prefDomain
)
;
itemsToClear
=
Object
.
keys
(
this
.
items
)
.
filter
(
itemName
=
>
{
try
{
return
branch
.
getBoolPref
(
itemName
)
;
}
catch
(
ex
)
{
return
false
;
}
}
)
;
}
Services
.
prefs
.
setStringPref
(
Sanitizer
.
PREF_SANITIZE_IN_PROGRESS
JSON
.
stringify
(
itemsToClear
)
)
;
for
(
let
k
of
itemsToClear
)
{
progress
[
k
]
=
"
ready
"
;
}
let
openWindowsIndex
=
itemsToClear
.
indexOf
(
"
openWindows
"
)
;
if
(
openWindowsIndex
!
=
-
1
)
{
itemsToClear
.
splice
(
openWindowsIndex
1
)
;
await
this
.
items
.
openWindows
.
clear
(
)
;
progress
.
openWindows
=
"
cleared
"
;
}
let
range
=
null
;
if
(
!
this
.
ignoreTimespan
)
{
range
=
this
.
range
|
|
Sanitizer
.
getClearRange
(
)
;
}
let
refObj
=
{
}
;
TelemetryStopwatch
.
start
(
"
FX_SANITIZE_TOTAL
"
refObj
)
;
let
annotateError
=
(
name
ex
)
=
>
{
progress
[
name
]
=
"
failed
"
;
seenError
=
true
;
console
.
error
(
"
Error
sanitizing
"
+
name
ex
)
;
}
;
let
handles
=
[
]
;
for
(
let
name
of
itemsToClear
)
{
let
item
=
this
.
items
[
name
]
;
try
{
handles
.
push
(
{
name
promise
:
item
.
clear
(
range
)
.
then
(
(
)
=
>
progress
[
name
]
=
"
cleared
"
ex
=
>
annotateError
(
name
ex
)
)
}
)
;
}
catch
(
ex
)
{
annotateError
(
name
ex
)
;
}
}
for
(
let
handle
of
handles
)
{
progress
[
handle
.
name
]
=
"
blocking
"
;
await
handle
.
promise
;
}
TelemetryStopwatch
.
finish
(
"
FX_SANITIZE_TOTAL
"
refObj
)
;
Services
.
prefs
.
clearUserPref
(
Sanitizer
.
PREF_SANITIZE_IN_PROGRESS
)
;
progress
=
{
}
;
if
(
seenError
)
{
throw
new
Error
(
"
Error
sanitizing
"
)
;
}
}
ignoreTimespan
:
true
range
:
null
items
:
{
cache
:
{
async
clear
(
range
)
{
let
seenException
;
let
refObj
=
{
}
;
TelemetryStopwatch
.
start
(
"
FX_SANITIZE_CACHE
"
refObj
)
;
try
{
Services
.
cache2
.
clear
(
)
;
}
catch
(
ex
)
{
seenException
=
ex
;
}
try
{
let
imageCache
=
Cc
[
"
mozilla
.
org
/
image
/
tools
;
1
"
]
.
getService
(
Ci
.
imgITools
)
.
getImgCacheForDocument
(
null
)
;
imageCache
.
clearCache
(
false
)
;
}
catch
(
ex
)
{
seenException
=
ex
;
}
TelemetryStopwatch
.
finish
(
"
FX_SANITIZE_CACHE
"
refObj
)
;
if
(
seenException
)
{
throw
seenException
;
}
}
}
cookies
:
{
async
clear
(
range
)
{
let
seenException
;
let
yieldCounter
=
0
;
let
refObj
=
{
}
;
TelemetryStopwatch
.
start
(
"
FX_SANITIZE_COOKIES_2
"
refObj
)
;
try
{
if
(
range
)
{
let
cookiesEnum
=
Services
.
cookies
.
enumerator
;
while
(
cookiesEnum
.
hasMoreElements
(
)
)
{
let
cookie
=
cookiesEnum
.
getNext
(
)
.
QueryInterface
(
Ci
.
nsICookie2
)
;
if
(
cookie
.
creationTime
>
range
[
0
]
)
{
Services
.
cookies
.
remove
(
cookie
.
host
cookie
.
name
cookie
.
path
false
cookie
.
originAttributes
)
;
if
(
+
+
yieldCounter
%
YIELD_PERIOD
=
=
0
)
{
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
0
)
)
;
}
}
}
}
else
{
Services
.
cookies
.
removeAll
(
)
;
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
0
)
)
;
}
}
catch
(
ex
)
{
seenException
=
ex
;
}
finally
{
TelemetryStopwatch
.
finish
(
"
FX_SANITIZE_COOKIES_2
"
refObj
)
;
}
try
{
let
mediaMgr
=
Components
.
classes
[
"
mozilla
.
org
/
mediaManagerService
;
1
"
]
.
getService
(
Ci
.
nsIMediaManagerService
)
;
mediaMgr
.
sanitizeDeviceIds
(
range
&
&
range
[
0
]
)
;
}
catch
(
ex
)
{
seenException
=
ex
;
}
try
{
await
Sanitizer
.
clearPluginData
(
range
)
;
}
catch
(
ex
)
{
seenException
=
ex
;
}
if
(
seenException
)
{
throw
seenException
;
}
}
}
offlineApps
:
{
async
clear
(
range
)
{
ChromeUtils
.
import
(
"
resource
:
/
/
/
modules
/
offlineAppCache
.
jsm
"
)
;
OfflineAppCacheHelper
.
clear
(
)
;
Services
.
obs
.
notifyObservers
(
null
"
extension
:
purge
-
localStorage
"
)
;
let
promises
=
[
]
;
let
serviceWorkers
=
serviceWorkerManager
.
getAllRegistrations
(
)
;
for
(
let
i
=
0
;
i
<
serviceWorkers
.
length
;
i
+
+
)
{
let
sw
=
serviceWorkers
.
queryElementAt
(
i
Ci
.
nsIServiceWorkerRegistrationInfo
)
;
promises
.
push
(
new
Promise
(
resolve
=
>
{
let
unregisterCallback
=
{
unregisterSucceeded
:
(
)
=
>
{
resolve
(
true
)
;
}
unregisterFailed
:
(
)
=
>
{
resolve
(
true
)
;
}
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIServiceWorkerUnregisterCallback
]
)
}
;
serviceWorkerManager
.
propagateUnregister
(
sw
.
principal
unregisterCallback
sw
.
scope
)
;
}
)
)
;
}
await
Promise
.
all
(
promises
)
;
promises
=
[
]
;
await
new
Promise
(
resolve
=
>
{
quotaManagerService
.
getUsage
(
request
=
>
{
if
(
request
.
resultCode
!
=
Cr
.
NS_OK
)
{
resolve
(
)
;
return
;
}
for
(
let
item
of
request
.
result
)
{
let
principal
=
Services
.
scriptSecurityManager
.
createCodebasePrincipalFromOrigin
(
item
.
origin
)
;
let
uri
=
principal
.
URI
;
if
(
uri
.
scheme
=
=
"
http
"
|
|
uri
.
scheme
=
=
"
https
"
|
|
uri
.
scheme
=
=
"
file
"
)
{
promises
.
push
(
new
Promise
(
r
=
>
{
let
req
=
quotaManagerService
.
clearStoragesForPrincipal
(
principal
null
false
)
;
req
.
callback
=
(
)
=
>
{
r
(
)
;
}
;
}
)
)
;
}
}
resolve
(
)
;
}
)
;
}
)
;
return
Promise
.
all
(
promises
)
;
}
}
history
:
{
async
clear
(
range
)
{
let
seenException
;
let
refObj
=
{
}
;
TelemetryStopwatch
.
start
(
"
FX_SANITIZE_HISTORY
"
refObj
)
;
try
{
if
(
range
)
{
await
PlacesUtils
.
history
.
removeVisitsByFilter
(
{
beginDate
:
new
Date
(
range
[
0
]
/
1000
)
endDate
:
new
Date
(
range
[
1
]
/
1000
)
}
)
;
}
else
{
await
PlacesUtils
.
history
.
clear
(
)
;
}
}
catch
(
ex
)
{
seenException
=
ex
;
}
finally
{
TelemetryStopwatch
.
finish
(
"
FX_SANITIZE_HISTORY
"
refObj
)
;
}
try
{
let
clearStartingTime
=
range
?
String
(
range
[
0
]
)
:
"
"
;
Services
.
obs
.
notifyObservers
(
null
"
browser
:
purge
-
session
-
history
"
clearStartingTime
)
;
}
catch
(
ex
)
{
seenException
=
ex
;
}
try
{
let
predictor
=
Components
.
classes
[
"
mozilla
.
org
/
network
/
predictor
;
1
"
]
.
getService
(
Components
.
interfaces
.
nsINetworkPredictor
)
;
predictor
.
reset
(
)
;
}
catch
(
ex
)
{
seenException
=
ex
;
}
if
(
seenException
)
{
throw
seenException
;
}
}
}
formdata
:
{
async
clear
(
range
)
{
let
seenException
;
let
refObj
=
{
}
;
TelemetryStopwatch
.
start
(
"
FX_SANITIZE_FORMDATA
"
refObj
)
;
try
{
let
windows
=
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
;
while
(
windows
.
hasMoreElements
(
)
)
{
let
currentWindow
=
windows
.
getNext
(
)
;
let
currentDocument
=
currentWindow
.
document
;
let
searchBar
=
currentDocument
.
getElementById
(
"
searchbar
"
)
;
if
(
searchBar
&
&
searchBar
.
textbox
)
searchBar
.
textbox
.
reset
(
)
;
let
tabBrowser
=
currentWindow
.
gBrowser
;
if
(
!
tabBrowser
)
{
continue
;
}
for
(
let
tab
of
tabBrowser
.
tabs
)
{
if
(
tabBrowser
.
isFindBarInitialized
(
tab
)
)
tabBrowser
.
getFindBar
(
tab
)
.
clear
(
)
;
}
tabBrowser
.
_lastFindValue
=
"
"
;
}
}
catch
(
ex
)
{
seenException
=
ex
;
}
try
{
let
change
=
{
op
:
"
remove
"
}
;
if
(
range
)
{
[
change
.
firstUsedStart
change
.
firstUsedEnd
]
=
range
;
}
await
new
Promise
(
resolve
=
>
{
FormHistory
.
update
(
change
{
handleError
(
e
)
{
seenException
=
new
Error
(
"
Error
"
+
e
.
result
+
"
:
"
+
e
.
message
)
;
}
handleCompletion
(
)
{
resolve
(
)
;
}
}
)
;
}
)
;
}
catch
(
ex
)
{
seenException
=
ex
;
}
TelemetryStopwatch
.
finish
(
"
FX_SANITIZE_FORMDATA
"
refObj
)
;
if
(
seenException
)
{
throw
seenException
;
}
}
}
downloads
:
{
async
clear
(
range
)
{
let
refObj
=
{
}
;
TelemetryStopwatch
.
start
(
"
FX_SANITIZE_DOWNLOADS
"
refObj
)
;
try
{
let
filterByTime
=
null
;
if
(
range
)
{
let
rangeBeginMs
=
range
[
0
]
/
1000
;
let
rangeEndMs
=
range
[
1
]
/
1000
;
filterByTime
=
download
=
>
download
.
startTime
>
=
rangeBeginMs
&
&
download
.
startTime
<
=
rangeEndMs
;
}
let
list
=
await
Downloads
.
getList
(
Downloads
.
ALL
)
;
list
.
removeFinished
(
filterByTime
)
;
}
finally
{
TelemetryStopwatch
.
finish
(
"
FX_SANITIZE_DOWNLOADS
"
refObj
)
;
}
}
}
sessions
:
{
async
clear
(
range
)
{
let
refObj
=
{
}
;
TelemetryStopwatch
.
start
(
"
FX_SANITIZE_SESSIONS
"
refObj
)
;
try
{
let
sdr
=
Components
.
classes
[
"
mozilla
.
org
/
security
/
sdr
;
1
"
]
.
getService
(
Components
.
interfaces
.
nsISecretDecoderRing
)
;
sdr
.
logoutAndTeardown
(
)
;
Services
.
obs
.
notifyObservers
(
null
"
net
:
clear
-
active
-
logins
"
)
;
}
finally
{
TelemetryStopwatch
.
finish
(
"
FX_SANITIZE_SESSIONS
"
refObj
)
;
}
}
}
siteSettings
:
{
async
clear
(
range
)
{
let
seenException
;
let
refObj
=
{
}
;
TelemetryStopwatch
.
start
(
"
FX_SANITIZE_SITESETTINGS
"
refObj
)
;
let
startDateMS
=
range
?
range
[
0
]
/
1000
:
null
;
try
{
if
(
startDateMS
=
=
null
)
{
Services
.
perms
.
removeAll
(
)
;
}
else
{
Services
.
perms
.
removeAllSince
(
startDateMS
)
;
}
}
catch
(
ex
)
{
seenException
=
ex
;
}
try
{
let
cps
=
Components
.
classes
[
"
mozilla
.
org
/
content
-
pref
/
service
;
1
"
]
.
getService
(
Components
.
interfaces
.
nsIContentPrefService2
)
;
if
(
startDateMS
=
=
null
)
{
cps
.
removeAllDomains
(
null
)
;
}
else
{
cps
.
removeAllDomainsSince
(
startDateMS
null
)
;
}
}
catch
(
ex
)
{
seenException
=
ex
;
}
try
{
let
sss
=
Cc
[
"
mozilla
.
org
/
ssservice
;
1
"
]
.
getService
(
Ci
.
nsISiteSecurityService
)
;
sss
.
clearAll
(
)
;
}
catch
(
ex
)
{
seenException
=
ex
;
}
try
{
await
new
Promise
(
(
resolve
reject
)
=
>
{
let
push
=
Cc
[
"
mozilla
.
org
/
push
/
Service
;
1
"
]
.
getService
(
Ci
.
nsIPushService
)
;
push
.
clearForDomain
(
"
*
"
status
=
>
{
if
(
Components
.
isSuccessCode
(
status
)
)
{
resolve
(
)
;
}
else
{
reject
(
new
Error
(
"
Error
clearing
push
subscriptions
:
"
+
status
)
)
;
}
}
)
;
}
)
;
}
catch
(
ex
)
{
seenException
=
ex
;
}
TelemetryStopwatch
.
finish
(
"
FX_SANITIZE_SITESETTINGS
"
refObj
)
;
if
(
seenException
)
{
throw
seenException
;
}
}
}
openWindows
:
{
privateStateForNewWindow
:
"
non
-
private
"
_canCloseWindow
(
aWindow
)
{
if
(
aWindow
.
CanCloseWindow
(
)
)
{
aWindow
.
skipNextCanClose
=
true
;
return
true
;
}
return
false
;
}
_resetAllWindowClosures
(
aWindowList
)
{
for
(
let
win
of
aWindowList
)
{
win
.
skipNextCanClose
=
false
;
}
}
async
clear
(
)
{
let
existingWindow
=
Services
.
appShell
.
hiddenDOMWindow
;
let
startDate
=
existingWindow
.
performance
.
now
(
)
;
let
windowEnumerator
=
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
;
let
windowList
=
[
]
;
while
(
windowEnumerator
.
hasMoreElements
(
)
)
{
let
someWin
=
windowEnumerator
.
getNext
(
)
;
windowList
.
push
(
someWin
)
;
if
(
!
this
.
_canCloseWindow
(
someWin
)
)
{
this
.
_resetAllWindowClosures
(
windowList
)
;
throw
new
Error
(
"
Sanitize
could
not
close
windows
:
cancelled
by
user
"
)
;
}
if
(
existingWindow
.
performance
.
now
(
)
>
(
startDate
+
60
*
1000
)
)
{
this
.
_resetAllWindowClosures
(
windowList
)
;
throw
new
Error
(
"
Sanitize
could
not
close
windows
:
timeout
"
)
;
}
}
let
refObj
=
{
}
;
TelemetryStopwatch
.
start
(
"
FX_SANITIZE_OPENWINDOWS
"
refObj
)
;
let
handler
=
Cc
[
"
mozilla
.
org
/
browser
/
clh
;
1
"
]
.
getService
(
Ci
.
nsIBrowserHandler
)
;
let
defaultArgs
=
handler
.
defaultArgs
;
let
features
=
"
chrome
all
dialog
=
no
"
+
this
.
privateStateForNewWindow
;
let
newWindow
=
existingWindow
.
openDialog
(
"
chrome
:
/
/
browser
/
content
/
"
"
_blank
"
features
defaultArgs
)
;
let
onFullScreen
=
null
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
onFullScreen
=
function
(
e
)
{
newWindow
.
removeEventListener
(
"
fullscreen
"
onFullScreen
)
;
let
docEl
=
newWindow
.
document
.
documentElement
;
let
sizemode
=
docEl
.
getAttribute
(
"
sizemode
"
)
;
if
(
!
newWindow
.
fullScreen
&
&
sizemode
=
=
"
fullscreen
"
)
{
docEl
.
setAttribute
(
"
sizemode
"
"
normal
"
)
;
e
.
preventDefault
(
)
;
e
.
stopPropagation
(
)
;
return
false
;
}
return
undefined
;
}
;
newWindow
.
addEventListener
(
"
fullscreen
"
onFullScreen
)
;
}
let
promiseReady
=
new
Promise
(
resolve
=
>
{
let
newWindowOpened
=
false
;
let
onWindowOpened
=
function
(
subject
topic
data
)
{
if
(
subject
!
=
newWindow
)
return
;
Services
.
obs
.
removeObserver
(
onWindowOpened
"
browser
-
delayed
-
startup
-
finished
"
)
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
newWindow
.
removeEventListener
(
"
fullscreen
"
onFullScreen
)
;
}
newWindowOpened
=
true
;
if
(
numWindowsClosing
=
=
0
)
{
TelemetryStopwatch
.
finish
(
"
FX_SANITIZE_OPENWINDOWS
"
refObj
)
;
resolve
(
)
;
}
}
;
let
numWindowsClosing
=
windowList
.
length
;
let
onWindowClosed
=
function
(
)
{
numWindowsClosing
-
-
;
if
(
numWindowsClosing
=
=
0
)
{
Services
.
obs
.
removeObserver
(
onWindowClosed
"
xul
-
window
-
destroyed
"
)
;
if
(
newWindowOpened
)
{
TelemetryStopwatch
.
finish
(
"
FX_SANITIZE_OPENWINDOWS
"
refObj
)
;
resolve
(
)
;
}
}
}
;
Services
.
obs
.
addObserver
(
onWindowOpened
"
browser
-
delayed
-
startup
-
finished
"
)
;
Services
.
obs
.
addObserver
(
onWindowClosed
"
xul
-
window
-
destroyed
"
)
;
}
)
;
while
(
windowList
.
length
)
{
windowList
.
pop
(
)
.
close
(
)
;
}
newWindow
.
focus
(
)
;
await
promiseReady
;
}
}
pluginData
:
{
async
clear
(
range
)
{
await
Sanitizer
.
clearPluginData
(
range
)
;
}
}
}
}
;
Sanitizer
.
PREF_DOMAIN
=
"
privacy
.
sanitize
.
"
;
Sanitizer
.
PREF_SANITIZE_ON_SHUTDOWN
=
"
privacy
.
sanitize
.
sanitizeOnShutdown
"
;
Sanitizer
.
PREF_SANITIZE_IN_PROGRESS
=
"
privacy
.
sanitize
.
sanitizeInProgress
"
;
Sanitizer
.
PREF_SANITIZE_DID_SHUTDOWN
=
"
privacy
.
sanitize
.
didShutdownSanitize
"
;
Sanitizer
.
TIMESPAN_EVERYTHING
=
0
;
Sanitizer
.
TIMESPAN_HOUR
=
1
;
Sanitizer
.
TIMESPAN_2HOURS
=
2
;
Sanitizer
.
TIMESPAN_4HOURS
=
3
;
Sanitizer
.
TIMESPAN_TODAY
=
4
;
Sanitizer
.
TIMESPAN_5MIN
=
5
;
Sanitizer
.
TIMESPAN_24HOURS
=
6
;
Sanitizer
.
getClearRange
=
function
(
ts
)
{
if
(
ts
=
=
=
undefined
)
ts
=
Sanitizer
.
prefs
.
getIntPref
(
"
timeSpan
"
)
;
if
(
ts
=
=
=
Sanitizer
.
TIMESPAN_EVERYTHING
)
return
null
;
var
endDate
=
Date
.
now
(
)
*
1000
;
switch
(
ts
)
{
case
Sanitizer
.
TIMESPAN_5MIN
:
var
startDate
=
endDate
-
300000000
;
break
;
case
Sanitizer
.
TIMESPAN_HOUR
:
startDate
=
endDate
-
3600000000
;
break
;
case
Sanitizer
.
TIMESPAN_2HOURS
:
startDate
=
endDate
-
7200000000
;
break
;
case
Sanitizer
.
TIMESPAN_4HOURS
:
startDate
=
endDate
-
14400000000
;
break
;
case
Sanitizer
.
TIMESPAN_TODAY
:
var
d
=
new
Date
(
)
;
d
.
setHours
(
0
)
;
d
.
setMinutes
(
0
)
;
d
.
setSeconds
(
0
)
;
startDate
=
d
.
valueOf
(
)
*
1000
;
break
;
case
Sanitizer
.
TIMESPAN_24HOURS
:
startDate
=
endDate
-
86400000000
;
break
;
default
:
throw
"
Invalid
time
span
for
clear
private
data
:
"
+
ts
;
}
return
[
startDate
endDate
]
;
}
;
Sanitizer
.
clearPluginData
=
async
function
(
range
)
{
let
seenException
;
let
promiseClearPluginData
=
async
function
(
)
{
const
FLAG_CLEAR_ALL
=
Ci
.
nsIPluginHost
.
FLAG_CLEAR_ALL
;
let
ph
=
Cc
[
"
mozilla
.
org
/
plugin
/
host
;
1
"
]
.
getService
(
Ci
.
nsIPluginHost
)
;
let
age
=
range
?
(
Date
.
now
(
)
/
1000
-
range
[
0
]
/
1000000
)
:
-
1
;
if
(
!
range
|
|
age
>
=
0
)
{
let
tags
=
ph
.
getPluginTags
(
)
;
for
(
let
tag
of
tags
)
{
try
{
let
rv
=
await
new
Promise
(
resolve
=
>
ph
.
clearSiteData
(
tag
null
FLAG_CLEAR_ALL
age
resolve
)
)
;
if
(
rv
=
=
Components
.
results
.
NS_ERROR_PLUGIN_TIME_RANGE_NOT_SUPPORTED
)
{
await
new
Promise
(
resolve
=
>
ph
.
clearSiteData
(
tag
null
FLAG_CLEAR_ALL
-
1
resolve
)
)
;
}
}
catch
(
ex
)
{
}
}
}
}
;
try
{
promiseClearPluginData
=
promiseClearPluginData
(
range
)
;
await
Promise
.
race
(
[
promiseClearPluginData
new
Promise
(
resolve
=
>
setTimeout
(
resolve
10000
)
)
]
)
;
}
catch
(
ex
)
{
seenException
=
ex
;
}
promiseClearPluginData
.
catch
(
(
)
=
>
{
}
)
;
if
(
seenException
)
{
throw
seenException
;
}
}
;
Sanitizer
.
_prefs
=
null
;
Sanitizer
.
__defineGetter__
(
"
prefs
"
function
(
)
{
return
Sanitizer
.
_prefs
?
Sanitizer
.
_prefs
:
Sanitizer
.
_prefs
=
Services
.
prefs
.
getBranch
(
Sanitizer
.
PREF_DOMAIN
)
;
}
)
;
Sanitizer
.
showUI
=
function
(
aParentWindow
)
{
let
win
=
AppConstants
.
platform
=
=
"
macosx
"
?
null
:
aParentWindow
;
Services
.
ww
.
openWindow
(
win
"
chrome
:
/
/
browser
/
content
/
sanitize
.
xul
"
"
Sanitize
"
"
chrome
titlebar
dialog
centerscreen
modal
"
null
)
;
}
;
Sanitizer
.
sanitize
=
function
(
aParentWindow
)
{
Sanitizer
.
showUI
(
aParentWindow
)
;
}
;
Sanitizer
.
onStartup
=
async
function
(
)
{
let
shutownSanitizationWasInterrupted
=
Services
.
prefs
.
getBoolPref
(
Sanitizer
.
PREF_SANITIZE_ON_SHUTDOWN
false
)
&
&
Services
.
prefs
.
getPrefType
(
Sanitizer
.
PREF_SANITIZE_DID_SHUTDOWN
)
=
=
Ci
.
nsIPrefBranch
.
PREF_INVALID
;
if
(
Services
.
prefs
.
prefHasUserValue
(
Sanitizer
.
PREF_SANITIZE_DID_SHUTDOWN
)
)
{
Services
.
prefs
.
clearUserPref
(
Sanitizer
.
PREF_SANITIZE_DID_SHUTDOWN
)
;
Services
.
prefs
.
savePrefFile
(
null
)
;
}
let
shutdownClient
=
Cc
[
"
mozilla
.
org
/
browser
/
nav
-
history
-
service
;
1
"
]
.
getService
(
Ci
.
nsPIPlacesDatabase
)
.
shutdownClient
.
jsclient
;
let
progress
=
{
isShutdown
:
true
}
;
shutdownClient
.
addBlocker
(
"
sanitize
.
js
:
Sanitize
on
shutdown
"
(
)
=
>
sanitizeOnShutdown
(
{
progress
}
)
{
fetchState
:
(
)
=
>
(
{
progress
}
)
}
)
;
let
lastInterruptedSanitization
=
Services
.
prefs
.
getStringPref
(
Sanitizer
.
PREF_SANITIZE_IN_PROGRESS
"
"
)
;
if
(
lastInterruptedSanitization
)
{
let
s
=
new
Sanitizer
(
)
;
let
itemsToClear
=
JSON
.
parse
(
lastInterruptedSanitization
)
;
await
s
.
sanitize
(
itemsToClear
)
;
}
else
if
(
shutownSanitizationWasInterrupted
)
{
await
sanitizeOnShutdown
(
)
;
}
}
;
var
sanitizeOnShutdown
=
async
function
(
options
=
{
}
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
Sanitizer
.
PREF_SANITIZE_ON_SHUTDOWN
)
)
{
return
;
}
let
s
=
new
Sanitizer
(
)
;
s
.
prefDomain
=
"
privacy
.
clearOnShutdown
.
"
;
await
s
.
sanitize
(
null
options
)
;
Services
.
prefs
.
setBoolPref
(
Sanitizer
.
PREF_SANITIZE_DID_SHUTDOWN
true
)
;
Services
.
prefs
.
savePrefFile
(
null
)
;
}
;
