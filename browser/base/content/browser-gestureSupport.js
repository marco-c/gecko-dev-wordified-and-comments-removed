var
gGestureSupport
=
{
_currentRotation
:
0
_lastRotateDelta
:
0
_rotateMomentumThreshold
:
0
.
75
init
:
function
GS_init
(
aAddListener
)
{
const
gestureEvents
=
[
"
SwipeGestureMayStart
"
"
SwipeGestureStart
"
"
SwipeGestureUpdate
"
"
SwipeGestureEnd
"
"
SwipeGesture
"
"
MagnifyGestureStart
"
"
MagnifyGestureUpdate
"
"
MagnifyGesture
"
"
RotateGestureStart
"
"
RotateGestureUpdate
"
"
RotateGesture
"
"
TapGesture
"
"
PressTapGesture
"
]
;
for
(
let
event
of
gestureEvents
)
{
if
(
aAddListener
)
{
gBrowser
.
tabbox
.
addEventListener
(
"
Moz
"
+
event
this
true
)
;
}
else
{
gBrowser
.
tabbox
.
removeEventListener
(
"
Moz
"
+
event
this
true
)
;
}
}
}
handleEvent
:
function
GS_handleEvent
(
aEvent
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
"
dom
.
debug
.
propagate_gesture_events_through_content
"
)
)
{
aEvent
.
stopPropagation
(
)
;
}
let
def
=
(
aThreshold
aLatched
)
=
>
(
{
threshold
:
aThreshold
latched
:
!
!
aLatched
}
)
;
switch
(
aEvent
.
type
)
{
case
"
MozSwipeGestureMayStart
"
:
if
(
this
.
_shouldDoSwipeGesture
(
aEvent
)
)
{
aEvent
.
preventDefault
(
)
;
}
break
;
case
"
MozSwipeGestureStart
"
:
aEvent
.
preventDefault
(
)
;
this
.
_setupSwipeGesture
(
)
;
break
;
case
"
MozSwipeGestureUpdate
"
:
aEvent
.
preventDefault
(
)
;
this
.
_doUpdate
(
aEvent
)
;
break
;
case
"
MozSwipeGestureEnd
"
:
aEvent
.
preventDefault
(
)
;
this
.
_doEnd
(
aEvent
)
;
break
;
case
"
MozSwipeGesture
"
:
aEvent
.
preventDefault
(
)
;
this
.
onSwipe
(
aEvent
)
;
break
;
case
"
MozMagnifyGestureStart
"
:
aEvent
.
preventDefault
(
)
;
this
.
_setupGesture
(
aEvent
"
pinch
"
def
(
25
0
)
"
out
"
"
in
"
)
;
break
;
case
"
MozRotateGestureStart
"
:
aEvent
.
preventDefault
(
)
;
this
.
_setupGesture
(
aEvent
"
twist
"
def
(
25
0
)
"
right
"
"
left
"
)
;
break
;
case
"
MozMagnifyGestureUpdate
"
:
case
"
MozRotateGestureUpdate
"
:
aEvent
.
preventDefault
(
)
;
this
.
_doUpdate
(
aEvent
)
;
break
;
case
"
MozTapGesture
"
:
aEvent
.
preventDefault
(
)
;
this
.
_doAction
(
aEvent
[
"
tap
"
]
)
;
break
;
case
"
MozRotateGesture
"
:
aEvent
.
preventDefault
(
)
;
this
.
_doAction
(
aEvent
[
"
twist
"
"
end
"
]
)
;
break
;
}
}
_setupGesture
:
function
GS__setupGesture
(
aEvent
aGesture
aPref
aInc
aDec
)
{
for
(
let
[
pref
def
]
of
Object
.
entries
(
aPref
)
)
{
aPref
[
pref
]
=
this
.
_getPref
(
aGesture
+
"
.
"
+
pref
def
)
;
}
let
offset
=
0
;
let
latchDir
=
aEvent
.
delta
>
0
?
1
:
-
1
;
let
isLatched
=
false
;
this
.
_doUpdate
=
function
GS__doUpdate
(
updateEvent
)
{
offset
+
=
updateEvent
.
delta
;
if
(
Math
.
abs
(
offset
)
>
aPref
.
threshold
)
{
let
sameDir
=
(
latchDir
^
offset
)
>
=
0
;
if
(
!
aPref
.
latched
|
|
isLatched
^
sameDir
)
{
this
.
_doAction
(
updateEvent
[
aGesture
offset
>
0
?
aInc
:
aDec
]
)
;
isLatched
=
!
isLatched
;
}
offset
=
0
;
}
}
;
this
.
_doUpdate
(
aEvent
)
;
}
_swipeNavigatesHistory
:
function
GS__swipeNavigatesHistory
(
aEvent
)
{
return
(
this
.
_getCommand
(
aEvent
[
"
swipe
"
"
left
"
]
)
=
=
"
Browser
:
BackOrBackDuplicate
"
&
&
this
.
_getCommand
(
aEvent
[
"
swipe
"
"
right
"
]
)
=
=
"
Browser
:
ForwardOrForwardDuplicate
"
)
;
}
_shouldDoSwipeGesture
:
function
GS__shouldDoSwipeGesture
(
aEvent
)
{
if
(
!
this
.
_swipeNavigatesHistory
(
aEvent
)
)
{
return
false
;
}
let
isVerticalSwipe
=
false
;
if
(
aEvent
.
direction
=
=
aEvent
.
DIRECTION_UP
)
{
if
(
gMultiProcessBrowser
|
|
window
.
content
.
pageYOffset
>
0
)
{
return
false
;
}
isVerticalSwipe
=
true
;
}
else
if
(
aEvent
.
direction
=
=
aEvent
.
DIRECTION_DOWN
)
{
if
(
gMultiProcessBrowser
|
|
window
.
content
.
pageYOffset
<
window
.
content
.
scrollMaxY
)
{
return
false
;
}
isVerticalSwipe
=
true
;
}
if
(
isVerticalSwipe
)
{
return
false
;
}
let
canGoBack
=
gHistorySwipeAnimation
.
canGoBack
(
)
;
let
canGoForward
=
gHistorySwipeAnimation
.
canGoForward
(
)
;
let
isLTR
=
gHistorySwipeAnimation
.
isLTR
;
if
(
canGoBack
)
{
aEvent
.
allowedDirections
|
=
isLTR
?
aEvent
.
DIRECTION_LEFT
:
aEvent
.
DIRECTION_RIGHT
;
}
if
(
canGoForward
)
{
aEvent
.
allowedDirections
|
=
isLTR
?
aEvent
.
DIRECTION_RIGHT
:
aEvent
.
DIRECTION_LEFT
;
}
return
canGoBack
|
|
canGoForward
;
}
_setupSwipeGesture
:
function
GS__setupSwipeGesture
(
)
{
gHistorySwipeAnimation
.
startAnimation
(
)
;
this
.
_doUpdate
=
function
GS__doUpdate
(
aEvent
)
{
gHistorySwipeAnimation
.
updateAnimation
(
aEvent
.
delta
)
;
}
;
this
.
_doEnd
=
function
GS__doEnd
(
aEvent
)
{
gHistorySwipeAnimation
.
swipeEndEventReceived
(
)
;
this
.
_doUpdate
=
function
(
)
{
}
;
this
.
_doEnd
=
function
(
)
{
}
;
}
;
}
_power
:
function
*
GS__power
(
aArray
)
{
let
num
=
1
<
<
aArray
.
length
;
while
(
-
-
num
>
=
0
)
{
yield
aArray
.
reduce
(
function
(
aPrev
aCurr
aIndex
)
{
if
(
num
&
(
1
<
<
aIndex
)
)
{
aPrev
.
push
(
aCurr
)
;
}
return
aPrev
;
}
[
]
)
;
}
}
_doAction
:
function
GS__doAction
(
aEvent
aGesture
)
{
let
command
=
this
.
_getCommand
(
aEvent
aGesture
)
;
return
command
&
&
this
.
_doCommand
(
aEvent
command
)
;
}
_getCommand
:
function
GS__getCommand
(
aEvent
aGesture
)
{
let
keyCombos
=
[
]
;
for
(
let
key
of
[
"
shift
"
"
alt
"
"
ctrl
"
"
meta
"
]
)
{
if
(
aEvent
[
key
+
"
Key
"
]
)
{
keyCombos
.
push
(
key
)
;
}
}
for
(
let
subCombo
of
this
.
_power
(
keyCombos
)
)
{
let
command
;
try
{
command
=
this
.
_getPref
(
aGesture
.
concat
(
subCombo
)
.
join
(
"
.
"
)
)
;
}
catch
(
e
)
{
}
if
(
command
)
{
return
command
;
}
}
return
null
;
}
_doCommand
:
function
GS__doCommand
(
aEvent
aCommand
)
{
let
node
=
document
.
getElementById
(
aCommand
)
;
if
(
node
)
{
if
(
node
.
getAttribute
(
"
disabled
"
)
!
=
"
true
"
)
{
let
cmdEvent
=
document
.
createEvent
(
"
xulcommandevent
"
)
;
cmdEvent
.
initCommandEvent
(
"
command
"
true
true
window
0
aEvent
.
ctrlKey
aEvent
.
altKey
aEvent
.
shiftKey
aEvent
.
metaKey
0
aEvent
aEvent
.
mozInputSource
)
;
node
.
dispatchEvent
(
cmdEvent
)
;
}
}
else
{
goDoCommand
(
aCommand
)
;
}
}
_doUpdate
(
aEvent
)
{
}
_doEnd
(
aEvent
)
{
}
onSwipe
:
function
GS_onSwipe
(
aEvent
)
{
for
(
let
dir
of
[
"
UP
"
"
RIGHT
"
"
DOWN
"
"
LEFT
"
]
)
{
if
(
aEvent
.
direction
=
=
aEvent
[
"
DIRECTION_
"
+
dir
]
)
{
this
.
_coordinateSwipeEventWithAnimation
(
aEvent
dir
)
;
break
;
}
}
}
processSwipeEvent
:
function
GS_processSwipeEvent
(
aEvent
aDir
)
{
this
.
_doAction
(
aEvent
[
"
swipe
"
aDir
.
toLowerCase
(
)
]
)
;
}
_coordinateSwipeEventWithAnimation
:
function
GS__coordinateSwipeEventWithAnimation
(
aEvent
aDir
)
{
gHistorySwipeAnimation
.
stopAnimation
(
)
;
this
.
processSwipeEvent
(
aEvent
aDir
)
;
}
_getPref
:
function
GS__getPref
(
aPref
aDef
)
{
const
branch
=
"
browser
.
gesture
.
"
;
try
{
let
type
=
typeof
aDef
;
let
getFunc
=
"
Char
"
;
if
(
type
=
=
"
boolean
"
)
{
getFunc
=
"
Bool
"
;
}
else
if
(
type
=
=
"
number
"
)
{
getFunc
=
"
Int
"
;
}
return
Services
.
prefs
[
"
get
"
+
getFunc
+
"
Pref
"
]
(
branch
+
aPref
)
;
}
catch
(
e
)
{
return
aDef
;
}
}
rotate
(
aEvent
)
{
if
(
!
(
window
.
content
.
document
instanceof
ImageDocument
)
)
{
return
;
}
let
contentElement
=
window
.
content
.
document
.
body
.
firstElementChild
;
if
(
!
contentElement
)
{
return
;
}
if
(
contentElement
.
classList
.
contains
(
"
completeRotation
"
)
)
{
this
.
_clearCompleteRotation
(
)
;
}
this
.
rotation
=
Math
.
round
(
this
.
rotation
+
aEvent
.
delta
)
;
contentElement
.
style
.
transform
=
"
rotate
(
"
+
this
.
rotation
+
"
deg
)
"
;
this
.
_lastRotateDelta
=
aEvent
.
delta
;
}
rotateEnd
(
)
{
if
(
!
(
window
.
content
.
document
instanceof
ImageDocument
)
)
{
return
;
}
let
contentElement
=
window
.
content
.
document
.
body
.
firstElementChild
;
if
(
!
contentElement
)
{
return
;
}
let
transitionRotation
=
0
;
if
(
this
.
rotation
<
=
45
)
{
transitionRotation
=
0
;
}
else
if
(
this
.
rotation
>
45
&
&
this
.
rotation
<
=
135
)
{
transitionRotation
=
90
;
}
else
if
(
this
.
rotation
>
135
&
&
this
.
rotation
<
=
225
)
{
transitionRotation
=
180
;
}
else
if
(
this
.
rotation
>
225
&
&
this
.
rotation
<
=
315
)
{
transitionRotation
=
270
;
}
else
{
transitionRotation
=
360
;
}
if
(
this
.
_lastRotateDelta
>
this
.
_rotateMomentumThreshold
&
&
this
.
rotation
>
transitionRotation
)
{
transitionRotation
+
=
90
;
}
else
if
(
this
.
_lastRotateDelta
<
-
1
*
this
.
_rotateMomentumThreshold
&
&
this
.
rotation
<
transitionRotation
)
{
transitionRotation
-
=
90
;
}
if
(
transitionRotation
!
=
this
.
rotation
)
{
contentElement
.
classList
.
add
(
"
completeRotation
"
)
;
contentElement
.
addEventListener
(
"
transitionend
"
this
.
_clearCompleteRotation
)
;
}
contentElement
.
style
.
transform
=
"
rotate
(
"
+
transitionRotation
+
"
deg
)
"
;
this
.
rotation
=
transitionRotation
;
}
get
rotation
(
)
{
return
this
.
_currentRotation
;
}
set
rotation
(
aVal
)
{
this
.
_currentRotation
=
aVal
%
360
;
if
(
this
.
_currentRotation
<
0
)
{
this
.
_currentRotation
+
=
360
;
}
}
restoreRotationState
(
)
{
if
(
gMultiProcessBrowser
)
{
return
;
}
if
(
!
(
window
.
content
.
document
instanceof
ImageDocument
)
)
{
return
;
}
let
contentElement
=
window
.
content
.
document
.
body
.
firstElementChild
;
let
transformValue
=
window
.
content
.
window
.
getComputedStyle
(
contentElement
)
.
transform
;
if
(
transformValue
=
=
"
none
"
)
{
this
.
rotation
=
0
;
return
;
}
transformValue
=
transformValue
.
split
(
"
(
"
)
[
1
]
.
split
(
"
)
"
)
[
0
]
.
split
(
"
"
)
;
this
.
rotation
=
Math
.
round
(
Math
.
atan2
(
transformValue
[
1
]
transformValue
[
0
]
)
*
(
180
/
Math
.
PI
)
)
;
}
_clearCompleteRotation
(
)
{
let
contentElement
=
window
.
content
.
document
&
&
window
.
content
.
document
instanceof
ImageDocument
&
&
window
.
content
.
document
.
body
&
&
window
.
content
.
document
.
body
.
firstElementChild
;
if
(
!
contentElement
)
{
return
;
}
contentElement
.
classList
.
remove
(
"
completeRotation
"
)
;
contentElement
.
removeEventListener
(
"
transitionend
"
this
.
_clearCompleteRotation
)
;
}
}
;
var
gHistorySwipeAnimation
=
{
active
:
false
isLTR
:
false
init
:
function
HSA_init
(
)
{
this
.
isLTR
=
document
.
documentElement
.
matches
(
"
:
-
moz
-
locale
-
dir
(
ltr
)
"
)
;
this
.
_isStoppingAnimation
=
false
;
if
(
!
this
.
_isSupported
(
)
)
{
return
;
}
if
(
!
Services
.
prefs
.
getBoolPref
(
"
browser
.
history_swipe_animation
.
disabled
"
false
)
)
{
this
.
active
=
true
;
}
}
uninit
:
function
HSA_uninit
(
)
{
this
.
active
=
false
;
this
.
isLTR
=
false
;
this
.
_removeBoxes
(
)
;
}
startAnimation
:
function
HSA_startAnimation
(
)
{
this
.
_removeBoxes
(
)
;
this
.
_isStoppingAnimation
=
false
;
this
.
_canGoBack
=
this
.
canGoBack
(
)
;
this
.
_canGoForward
=
this
.
canGoForward
(
)
;
if
(
this
.
active
)
{
this
.
_addBoxes
(
)
;
}
this
.
updateAnimation
(
0
)
;
}
stopAnimation
:
function
HSA_stopAnimation
(
)
{
if
(
!
this
.
isAnimationRunning
(
)
|
|
this
.
_isStoppingAnimation
)
{
return
;
}
let
box
=
this
.
_prevBox
.
style
.
opacity
>
0
?
this
.
_prevBox
:
this
.
_nextBox
;
if
(
box
.
style
.
opacity
>
0
)
{
this
.
_isStoppingAnimation
=
true
;
box
.
style
.
transition
=
"
opacity
0
.
2s
cubic
-
bezier
(
.
07
.
95
0
1
)
"
;
box
.
addEventListener
(
"
transitionend
"
this
true
)
;
box
.
style
.
opacity
=
0
;
}
else
{
this
.
_isStoppingAnimation
=
false
;
this
.
_removeBoxes
(
)
;
}
}
updateAnimation
:
function
HSA_updateAnimation
(
aVal
)
{
if
(
!
this
.
isAnimationRunning
(
)
|
|
this
.
_isStoppingAnimation
)
{
return
;
}
let
opacity
=
Math
.
abs
(
aVal
)
*
4
;
if
(
(
aVal
>
=
0
&
&
this
.
isLTR
)
|
|
(
aVal
<
=
0
&
&
!
this
.
isLTR
)
)
{
if
(
this
.
_canGoBack
)
{
this
.
_prevBox
.
collapsed
=
false
;
this
.
_nextBox
.
collapsed
=
true
;
this
.
_prevBox
.
style
.
opacity
=
opacity
>
1
?
1
:
opacity
;
}
}
else
if
(
this
.
_canGoForward
)
{
this
.
_nextBox
.
collapsed
=
false
;
this
.
_prevBox
.
collapsed
=
true
;
this
.
_nextBox
.
style
.
opacity
=
opacity
>
1
?
1
:
opacity
;
}
}
isAnimationRunning
:
function
HSA_isAnimationRunning
(
)
{
return
!
!
this
.
_container
;
}
canGoBack
:
function
HSA_canGoBack
(
)
{
return
gBrowser
.
webNavigation
.
canGoBack
;
}
canGoForward
:
function
HSA_canGoForward
(
)
{
return
gBrowser
.
webNavigation
.
canGoForward
;
}
swipeEndEventReceived
:
function
HSA_swipeEndEventReceived
(
)
{
this
.
stopAnimation
(
)
;
}
_isSupported
:
function
HSA__isSupported
(
)
{
return
window
.
matchMedia
(
"
(
-
moz
-
swipe
-
animation
-
enabled
)
"
)
.
matches
;
}
handleEvent
:
function
HSA_handleEvent
(
aEvent
)
{
switch
(
aEvent
.
type
)
{
case
"
transitionend
"
:
this
.
_completeFadeOut
(
)
;
break
;
}
}
_completeFadeOut
:
function
HSA__completeFadeOut
(
aEvent
)
{
if
(
!
this
.
_isStoppingAnimation
)
{
return
;
}
this
.
_isStoppingAnimation
=
false
;
gHistorySwipeAnimation
.
_removeBoxes
(
)
;
}
_addBoxes
:
function
HSA__addBoxes
(
)
{
let
browserStack
=
gBrowser
.
getPanel
(
)
.
querySelector
(
"
.
browserStack
"
)
;
this
.
_container
=
this
.
_createElement
(
"
historySwipeAnimationContainer
"
"
stack
"
)
;
browserStack
.
appendChild
(
this
.
_container
)
;
this
.
_prevBox
=
this
.
_createElement
(
"
historySwipeAnimationPreviousArrow
"
"
box
"
)
;
this
.
_prevBox
.
collapsed
=
true
;
this
.
_prevBox
.
style
.
opacity
=
0
;
this
.
_container
.
appendChild
(
this
.
_prevBox
)
;
this
.
_nextBox
=
this
.
_createElement
(
"
historySwipeAnimationNextArrow
"
"
box
"
)
;
this
.
_nextBox
.
collapsed
=
true
;
this
.
_nextBox
.
style
.
opacity
=
0
;
this
.
_container
.
appendChild
(
this
.
_nextBox
)
;
}
_removeBoxes
:
function
HSA__removeBoxes
(
)
{
this
.
_prevBox
=
null
;
this
.
_nextBox
=
null
;
if
(
this
.
_container
)
{
this
.
_container
.
remove
(
)
;
}
this
.
_container
=
null
;
}
_createElement
:
function
HSA__createElement
(
aID
aTagName
)
{
let
element
=
document
.
createXULElement
(
aTagName
)
;
element
.
id
=
aID
;
return
element
;
}
}
;
