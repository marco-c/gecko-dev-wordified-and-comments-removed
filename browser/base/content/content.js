var
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
/
modules
/
ContentWebRTC
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
/
modules
/
ContentObservers
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
InlineSpellChecker
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
InlineSpellCheckerContent
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
E10SUtils
"
"
resource
:
/
/
/
modules
/
E10SUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
BrowserUtils
"
"
resource
:
/
/
gre
/
modules
/
BrowserUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
ContentLinkHandler
"
"
resource
:
/
/
/
modules
/
ContentLinkHandler
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
LoginManagerContent
"
"
resource
:
/
/
gre
/
modules
/
LoginManagerContent
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
FormLikeFactory
"
"
resource
:
/
/
gre
/
modules
/
LoginManagerContent
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
InsecurePasswordUtils
"
"
resource
:
/
/
gre
/
modules
/
InsecurePasswordUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PluginContent
"
"
resource
:
/
/
/
modules
/
PluginContent
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PrivateBrowsingUtils
"
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
FormSubmitObserver
"
"
resource
:
/
/
/
modules
/
FormSubmitObserver
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PageMetadata
"
"
resource
:
/
/
gre
/
modules
/
PageMetadata
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PlacesUIUtils
"
"
resource
:
/
/
/
modules
/
PlacesUIUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
PageMenuChild
"
function
(
)
{
let
tmp
=
{
}
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
PageMenu
.
jsm
"
tmp
)
;
return
new
tmp
.
PageMenuChild
(
)
;
}
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Feeds
"
"
resource
:
/
/
/
modules
/
Feeds
.
jsm
"
)
;
var
global
=
this
;
var
formSubmitObserver
=
new
FormSubmitObserver
(
content
this
)
;
addMessageListener
(
"
ContextMenu
:
DoCustomCommand
"
function
(
message
)
{
E10SUtils
.
wrapHandlingUserInput
(
content
message
.
data
.
handlingUserInput
(
)
=
>
PageMenuChild
.
executeMenu
(
message
.
data
.
generatedItemId
)
)
;
}
)
;
addMessageListener
(
"
RemoteLogins
:
fillForm
"
function
(
message
)
{
LoginManagerContent
.
receiveMessage
(
message
content
)
;
}
)
;
addEventListener
(
"
DOMFormHasPassword
"
function
(
event
)
{
LoginManagerContent
.
onDOMFormHasPassword
(
event
content
)
;
let
formLike
=
FormLikeFactory
.
createFromForm
(
event
.
target
)
;
InsecurePasswordUtils
.
checkForInsecurePasswords
(
formLike
)
;
}
)
;
addEventListener
(
"
DOMInputPasswordAdded
"
function
(
event
)
{
LoginManagerContent
.
onDOMInputPasswordAdded
(
event
content
)
;
let
formLike
=
FormLikeFactory
.
createFromField
(
event
.
target
)
;
InsecurePasswordUtils
.
checkForInsecurePasswords
(
formLike
)
;
}
)
;
addEventListener
(
"
pageshow
"
function
(
event
)
{
LoginManagerContent
.
onPageShow
(
event
content
)
;
}
)
;
addEventListener
(
"
DOMAutoComplete
"
function
(
event
)
{
LoginManagerContent
.
onUsernameInput
(
event
)
;
}
)
;
addEventListener
(
"
blur
"
function
(
event
)
{
LoginManagerContent
.
onUsernameInput
(
event
)
;
}
)
;
var
handleContentContextMenu
=
function
(
event
)
{
let
defaultPrevented
=
event
.
defaultPrevented
;
if
(
!
Services
.
prefs
.
getBoolPref
(
"
dom
.
event
.
contextmenu
.
enabled
"
)
)
{
let
plugin
=
null
;
try
{
plugin
=
event
.
target
.
QueryInterface
(
Ci
.
nsIObjectLoadingContent
)
;
}
catch
(
e
)
{
}
if
(
plugin
&
&
plugin
.
displayedType
=
=
Ci
.
nsIObjectLoadingContent
.
TYPE_PLUGIN
)
{
return
;
}
defaultPrevented
=
false
;
}
if
(
defaultPrevented
)
return
;
let
addonInfo
=
{
}
;
let
subject
=
{
event
:
event
addonInfo
:
addonInfo
}
;
subject
.
wrappedJSObject
=
subject
;
Services
.
obs
.
notifyObservers
(
subject
"
content
-
contextmenu
"
null
)
;
let
doc
=
event
.
target
.
ownerDocument
;
let
docLocation
=
doc
.
mozDocumentURIIfNotForErrorPages
;
docLocation
=
docLocation
&
&
docLocation
.
spec
;
let
charSet
=
doc
.
characterSet
;
let
baseURI
=
doc
.
baseURI
;
let
referrer
=
doc
.
referrer
;
let
referrerPolicy
=
doc
.
referrerPolicy
;
let
frameOuterWindowID
=
doc
.
defaultView
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
.
outerWindowID
;
let
loginFillInfo
=
LoginManagerContent
.
getFieldContext
(
event
.
target
)
;
let
parentAllowsMixedContent
=
!
!
docShell
.
mixedContentChannel
;
if
(
Services
.
prefs
.
getBoolPref
(
"
network
.
http
.
enablePerElementReferrer
"
)
)
{
let
referrerAttrValue
=
Services
.
netUtils
.
parseAttributePolicyString
(
event
.
target
.
getAttribute
(
"
referrerpolicy
"
)
)
;
if
(
referrerAttrValue
!
=
=
Ci
.
nsIHttpChannel
.
REFERRER_POLICY_DEFAULT
)
{
referrerPolicy
=
referrerAttrValue
;
}
}
let
disableSetDesktopBg
=
null
;
let
contentType
=
null
;
let
contentDisposition
=
null
;
if
(
event
.
target
.
nodeType
=
=
Ci
.
nsIDOMNode
.
ELEMENT_NODE
&
&
event
.
target
instanceof
Ci
.
nsIImageLoadingContent
&
&
event
.
target
.
currentURI
)
{
disableSetDesktopBg
=
disableSetDesktopBackground
(
event
.
target
)
;
try
{
let
imageCache
=
Cc
[
"
mozilla
.
org
/
image
/
tools
;
1
"
]
.
getService
(
Ci
.
imgITools
)
.
getImgCacheForDocument
(
doc
)
;
let
props
=
imageCache
.
findEntryProperties
(
event
.
target
.
currentURI
doc
)
;
try
{
contentType
=
props
.
get
(
"
type
"
Ci
.
nsISupportsCString
)
.
data
;
}
catch
(
e
)
{
}
try
{
contentDisposition
=
props
.
get
(
"
content
-
disposition
"
Ci
.
nsISupportsCString
)
.
data
;
}
catch
(
e
)
{
}
}
catch
(
e
)
{
}
}
let
selectionInfo
=
BrowserUtils
.
getSelectionDetails
(
content
)
;
if
(
Services
.
appinfo
.
processType
=
=
Services
.
appinfo
.
PROCESS_TYPE_CONTENT
)
{
let
editFlags
=
SpellCheckHelper
.
isEditable
(
event
.
target
content
)
;
let
spellInfo
;
if
(
editFlags
&
(
SpellCheckHelper
.
EDITABLE
|
SpellCheckHelper
.
CONTENTEDITABLE
)
)
{
spellInfo
=
InlineSpellCheckerContent
.
initContextMenu
(
event
editFlags
this
)
;
}
docShell
.
contentViewer
.
QueryInterface
(
Ci
.
nsIContentViewerEdit
)
.
setCommandNode
(
event
.
target
)
;
event
.
target
.
ownerDocument
.
defaultView
.
updateCommands
(
"
contentcontextmenu
"
)
;
let
customMenuItems
=
PageMenuChild
.
build
(
event
.
target
)
;
let
principal
=
doc
.
nodePrincipal
;
sendRpcMessage
(
"
contextmenu
"
{
editFlags
spellInfo
customMenuItems
addonInfo
principal
docLocation
charSet
baseURI
referrer
referrerPolicy
contentType
contentDisposition
frameOuterWindowID
selectionInfo
disableSetDesktopBg
loginFillInfo
parentAllowsMixedContent
}
{
event
popupNode
:
event
.
target
}
)
;
}
else
{
let
browser
=
docShell
.
chromeEventHandler
;
let
mainWin
=
browser
.
ownerDocument
.
defaultView
;
mainWin
.
gContextMenuContentData
=
{
isRemote
:
false
event
:
event
popupNode
:
event
.
target
browser
:
browser
addonInfo
:
addonInfo
documentURIObject
:
doc
.
documentURIObject
docLocation
:
docLocation
charSet
:
charSet
referrer
:
referrer
referrerPolicy
:
referrerPolicy
contentType
:
contentType
contentDisposition
:
contentDisposition
selectionInfo
:
selectionInfo
disableSetDesktopBackground
:
disableSetDesktopBg
loginFillInfo
parentAllowsMixedContent
}
;
}
}
Cc
[
"
mozilla
.
org
/
eventlistenerservice
;
1
"
]
.
getService
(
Ci
.
nsIEventListenerService
)
.
addSystemEventListener
(
global
"
contextmenu
"
handleContentContextMenu
false
)
;
const
TLS_ERROR_REPORT_TELEMETRY_UI_SHOWN
=
0
;
const
TLS_ERROR_REPORT_TELEMETRY_EXPANDED
=
1
;
const
TLS_ERROR_REPORT_TELEMETRY_SUCCESS
=
6
;
const
TLS_ERROR_REPORT_TELEMETRY_FAILURE
=
7
;
const
SEC_ERROR_BASE
=
Ci
.
nsINSSErrorsService
.
NSS_SEC_ERROR_BASE
;
const
SEC_ERROR_UNKNOWN_ISSUER
=
SEC_ERROR_BASE
+
13
;
var
AboutNetAndCertErrorListener
=
{
init
:
function
(
chromeGlobal
)
{
addMessageListener
(
"
CertErrorDetails
"
this
)
;
chromeGlobal
.
addEventListener
(
'
AboutNetErrorLoad
'
this
false
true
)
;
chromeGlobal
.
addEventListener
(
'
AboutNetErrorSetAutomatic
'
this
false
true
)
;
chromeGlobal
.
addEventListener
(
'
AboutNetErrorOverride
'
this
false
true
)
;
}
get
isAboutNetError
(
)
{
return
content
.
document
.
documentURI
.
startsWith
(
"
about
:
neterror
"
)
;
}
get
isAboutCertError
(
)
{
return
content
.
document
.
documentURI
.
startsWith
(
"
about
:
certerror
"
)
;
}
receiveMessage
:
function
(
msg
)
{
if
(
!
this
.
isAboutCertError
)
{
return
;
}
switch
(
msg
.
name
)
{
case
"
CertErrorDetails
"
:
this
.
onCertErrorDetails
(
msg
)
;
break
;
}
}
onCertErrorDetails
(
msg
)
{
let
div
=
content
.
document
.
getElementById
(
"
certificateErrorText
"
)
;
div
.
textContent
=
msg
.
data
.
info
;
switch
(
msg
.
data
.
code
)
{
case
SEC_ERROR_UNKNOWN_ISSUER
:
let
learnMoreLink
=
content
.
document
.
getElementById
(
"
learnMoreLink
"
)
;
learnMoreLink
.
href
=
"
https
:
/
/
support
.
mozilla
.
org
/
kb
/
troubleshoot
-
SEC_ERROR_UNKNOWN_ISSUER
"
;
break
;
}
}
handleEvent
:
function
(
aEvent
)
{
if
(
!
this
.
isAboutNetError
&
&
!
this
.
isAboutCertError
)
{
return
;
}
switch
(
aEvent
.
type
)
{
case
"
AboutNetErrorLoad
"
:
this
.
onPageLoad
(
aEvent
)
;
break
;
case
"
AboutNetErrorSetAutomatic
"
:
this
.
onSetAutomatic
(
aEvent
)
;
break
;
case
"
AboutNetErrorOverride
"
:
this
.
onOverride
(
aEvent
)
;
break
;
}
}
onPageLoad
:
function
(
evt
)
{
if
(
this
.
isAboutCertError
)
{
let
originalTarget
=
evt
.
originalTarget
;
let
ownerDoc
=
originalTarget
.
ownerDocument
;
ClickEventHandler
.
onCertError
(
originalTarget
ownerDoc
)
;
}
let
automatic
=
Services
.
prefs
.
getBoolPref
(
"
security
.
ssl
.
errorReporting
.
automatic
"
)
;
content
.
dispatchEvent
(
new
content
.
CustomEvent
(
"
AboutNetErrorOptions
"
{
detail
:
JSON
.
stringify
(
{
enabled
:
Services
.
prefs
.
getBoolPref
(
"
security
.
ssl
.
errorReporting
.
enabled
"
)
automatic
:
automatic
}
)
}
)
)
;
sendAsyncMessage
(
"
Browser
:
SSLErrorReportTelemetry
"
{
reportStatus
:
TLS_ERROR_REPORT_TELEMETRY_UI_SHOWN
}
)
;
}
onSetAutomatic
:
function
(
evt
)
{
sendAsyncMessage
(
"
Browser
:
SetSSLErrorReportAuto
"
{
automatic
:
evt
.
detail
}
)
;
if
(
evt
.
detail
)
{
let
serhelper
=
Cc
[
"
mozilla
.
org
/
network
/
serialization
-
helper
;
1
"
]
.
getService
(
Ci
.
nsISerializationHelper
)
;
let
serializable
=
docShell
.
failedChannel
.
securityInfo
.
QueryInterface
(
Ci
.
nsITransportSecurityInfo
)
.
QueryInterface
(
Ci
.
nsISerializable
)
;
let
serializedSecurityInfo
=
serhelper
.
serializeToString
(
serializable
)
;
let
{
host
port
}
=
content
.
document
.
mozDocumentURIIfNotForErrorPages
;
sendAsyncMessage
(
"
Browser
:
SendSSLErrorReport
"
{
uri
:
{
host
port
}
securityInfo
:
serializedSecurityInfo
}
)
;
}
}
onOverride
:
function
(
evt
)
{
let
{
host
port
}
=
content
.
document
.
mozDocumentURIIfNotForErrorPages
;
sendAsyncMessage
(
"
Browser
:
OverrideWeakCrypto
"
{
uri
:
{
host
port
}
}
)
;
}
}
AboutNetAndCertErrorListener
.
init
(
this
)
;
var
ClickEventHandler
=
{
init
:
function
init
(
)
{
Cc
[
"
mozilla
.
org
/
eventlistenerservice
;
1
"
]
.
getService
(
Ci
.
nsIEventListenerService
)
.
addSystemEventListener
(
global
"
click
"
this
true
)
;
}
handleEvent
:
function
(
event
)
{
if
(
!
event
.
isTrusted
|
|
event
.
defaultPrevented
|
|
event
.
button
=
=
2
)
{
return
;
}
let
originalTarget
=
event
.
originalTarget
;
let
ownerDoc
=
originalTarget
.
ownerDocument
;
if
(
!
ownerDoc
)
{
return
;
}
if
(
ownerDoc
.
documentURI
.
startsWith
(
"
about
:
certerror
"
)
)
{
this
.
onCertError
(
originalTarget
ownerDoc
)
;
return
;
}
else
if
(
ownerDoc
.
documentURI
.
startsWith
(
"
about
:
blocked
"
)
)
{
this
.
onAboutBlocked
(
originalTarget
ownerDoc
)
;
return
;
}
else
if
(
ownerDoc
.
documentURI
.
startsWith
(
"
about
:
neterror
"
)
)
{
this
.
onAboutNetError
(
event
ownerDoc
.
documentURI
)
;
return
;
}
let
[
href
node
principal
]
=
this
.
_hrefAndLinkNodeForClickEvent
(
event
)
;
let
referrerPolicy
=
ownerDoc
.
referrerPolicy
;
if
(
Services
.
prefs
.
getBoolPref
(
"
network
.
http
.
enablePerElementReferrer
"
)
&
&
node
)
{
let
referrerAttrValue
=
Services
.
netUtils
.
parseAttributePolicyString
(
node
.
getAttribute
(
"
referrerpolicy
"
)
)
;
if
(
referrerAttrValue
!
=
=
Ci
.
nsIHttpChannel
.
REFERRER_POLICY_DEFAULT
)
{
referrerPolicy
=
referrerAttrValue
;
}
}
let
json
=
{
button
:
event
.
button
shiftKey
:
event
.
shiftKey
ctrlKey
:
event
.
ctrlKey
metaKey
:
event
.
metaKey
altKey
:
event
.
altKey
href
:
null
title
:
null
bookmark
:
false
referrerPolicy
:
referrerPolicy
}
;
if
(
href
)
{
try
{
BrowserUtils
.
urlSecurityCheck
(
href
principal
)
;
}
catch
(
e
)
{
return
;
}
json
.
href
=
href
;
if
(
node
)
{
json
.
title
=
node
.
getAttribute
(
"
title
"
)
;
if
(
event
.
button
=
=
0
&
&
!
event
.
ctrlKey
&
&
!
event
.
shiftKey
&
&
!
event
.
altKey
&
&
!
event
.
metaKey
)
{
json
.
bookmark
=
node
.
getAttribute
(
"
rel
"
)
=
=
"
sidebar
"
;
if
(
json
.
bookmark
)
{
event
.
preventDefault
(
)
;
}
}
}
json
.
noReferrer
=
BrowserUtils
.
linkHasNoReferrer
(
node
)
sendAsyncMessage
(
"
Content
:
Click
"
json
)
;
return
;
}
if
(
event
.
button
=
=
1
)
{
sendAsyncMessage
(
"
Content
:
Click
"
json
)
;
}
}
onCertError
:
function
(
targetElement
ownerDoc
)
{
let
docshell
=
ownerDoc
.
defaultView
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebNavigation
)
.
QueryInterface
(
Ci
.
nsIDocShell
)
;
let
serhelper
=
Cc
[
"
mozilla
.
org
/
network
/
serialization
-
helper
;
1
"
]
.
getService
(
Ci
.
nsISerializationHelper
)
;
let
serializedSecurityInfo
=
"
"
;
try
{
let
serializable
=
docShell
.
failedChannel
.
securityInfo
.
QueryInterface
(
Ci
.
nsITransportSecurityInfo
)
.
QueryInterface
(
Ci
.
nsISerializable
)
;
serializedSecurityInfo
=
serhelper
.
serializeToString
(
serializable
)
;
}
catch
(
e
)
{
}
sendAsyncMessage
(
"
Browser
:
CertExceptionError
"
{
location
:
ownerDoc
.
location
.
href
elementId
:
targetElement
.
getAttribute
(
"
id
"
)
isTopFrame
:
(
ownerDoc
.
defaultView
.
parent
=
=
=
ownerDoc
.
defaultView
)
securityInfoAsString
:
serializedSecurityInfo
}
)
;
}
onAboutBlocked
:
function
(
targetElement
ownerDoc
)
{
var
reason
=
'
phishing
'
;
if
(
/
e
=
malwareBlocked
/
.
test
(
ownerDoc
.
documentURI
)
)
{
reason
=
'
malware
'
;
}
else
if
(
/
e
=
unwantedBlocked
/
.
test
(
ownerDoc
.
documentURI
)
)
{
reason
=
'
unwanted
'
;
}
else
if
(
/
e
=
forbiddenBlocked
/
.
test
(
ownerDoc
.
documentURI
)
)
{
reason
=
'
forbidden
'
;
}
sendAsyncMessage
(
"
Browser
:
SiteBlockedError
"
{
location
:
ownerDoc
.
location
.
href
reason
:
reason
elementId
:
targetElement
.
getAttribute
(
"
id
"
)
isTopFrame
:
(
ownerDoc
.
defaultView
.
parent
=
=
=
ownerDoc
.
defaultView
)
}
)
;
}
onAboutNetError
:
function
(
event
documentURI
)
{
let
elmId
=
event
.
originalTarget
.
getAttribute
(
"
id
"
)
;
if
(
elmId
=
=
"
returnButton
"
)
{
sendAsyncMessage
(
"
Browser
:
SSLErrorGoBack
"
{
}
)
;
return
;
}
if
(
elmId
!
=
"
errorTryAgain
"
|
|
!
/
e
=
netOffline
/
.
test
(
documentURI
)
)
{
return
;
}
if
(
Services
.
io
.
offline
)
{
event
.
preventDefault
(
)
;
sendAsyncMessage
(
"
Browser
:
EnableOnlineMode
"
{
}
)
;
}
}
_hrefAndLinkNodeForClickEvent
:
function
(
event
)
{
function
isHTMLLink
(
aNode
)
{
return
(
(
aNode
instanceof
content
.
HTMLAnchorElement
&
&
aNode
.
href
)
|
|
(
aNode
instanceof
content
.
HTMLAreaElement
&
&
aNode
.
href
)
|
|
aNode
instanceof
content
.
HTMLLinkElement
)
;
}
let
node
=
event
.
target
;
while
(
node
&
&
!
isHTMLLink
(
node
)
)
{
node
=
node
.
parentNode
;
}
if
(
node
)
return
[
node
.
href
node
node
.
ownerDocument
.
nodePrincipal
]
;
let
href
baseURI
;
node
=
event
.
target
;
while
(
node
&
&
!
href
)
{
if
(
node
.
nodeType
=
=
content
.
Node
.
ELEMENT_NODE
&
&
(
node
.
localName
=
=
"
a
"
|
|
node
.
namespaceURI
=
=
"
http
:
/
/
www
.
w3
.
org
/
1998
/
Math
/
MathML
"
)
)
{
href
=
node
.
getAttributeNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xlink
"
"
href
"
)
;
if
(
href
)
{
baseURI
=
node
.
ownerDocument
.
baseURIObject
;
break
;
}
}
node
=
node
.
parentNode
;
}
return
[
href
?
BrowserUtils
.
makeURI
(
href
null
baseURI
)
.
spec
:
null
null
node
&
&
node
.
ownerDocument
.
nodePrincipal
]
;
}
}
;
ClickEventHandler
.
init
(
)
;
ContentLinkHandler
.
init
(
this
)
;
var
pluginContent
=
new
PluginContent
(
global
)
;
addEventListener
(
"
DOMWebNotificationClicked
"
function
(
event
)
{
sendAsyncMessage
(
"
DOMWebNotificationClicked
"
{
}
)
;
}
false
)
;
addEventListener
(
"
DOMServiceWorkerFocusClient
"
function
(
event
)
{
sendAsyncMessage
(
"
DOMServiceWorkerFocusClient
"
{
}
)
;
}
false
)
;
ContentWebRTC
.
init
(
)
;
addMessageListener
(
"
rtcpeer
:
Allow
"
ContentWebRTC
)
;
addMessageListener
(
"
rtcpeer
:
Deny
"
ContentWebRTC
)
;
addMessageListener
(
"
webrtc
:
Allow
"
ContentWebRTC
)
;
addMessageListener
(
"
webrtc
:
Deny
"
ContentWebRTC
)
;
addMessageListener
(
"
webrtc
:
StopSharing
"
ContentWebRTC
)
;
addMessageListener
(
"
webrtc
:
StartBrowserSharing
"
(
)
=
>
{
let
windowID
=
content
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
.
outerWindowID
;
sendAsyncMessage
(
"
webrtc
:
response
:
StartBrowserSharing
"
{
windowID
:
windowID
}
)
;
}
)
;
addEventListener
(
"
pageshow
"
function
(
event
)
{
if
(
event
.
target
=
=
content
.
document
)
{
sendAsyncMessage
(
"
PageVisibility
:
Show
"
{
persisted
:
event
.
persisted
}
)
;
}
}
)
;
var
PageMetadataMessenger
=
{
init
(
)
{
addMessageListener
(
"
PageMetadata
:
GetPageData
"
this
)
;
addMessageListener
(
"
PageMetadata
:
GetMicroformats
"
this
)
;
}
receiveMessage
(
message
)
{
switch
(
message
.
name
)
{
case
"
PageMetadata
:
GetPageData
"
:
{
let
target
=
message
.
objects
.
target
;
let
result
=
PageMetadata
.
getData
(
content
.
document
target
)
;
sendAsyncMessage
(
"
PageMetadata
:
PageDataResult
"
result
)
;
break
;
}
case
"
PageMetadata
:
GetMicroformats
"
:
{
let
target
=
message
.
objects
.
target
;
let
result
=
PageMetadata
.
getMicroformats
(
content
.
document
target
)
;
sendAsyncMessage
(
"
PageMetadata
:
MicroformatsResult
"
result
)
;
break
;
}
}
}
}
PageMetadataMessenger
.
init
(
)
;
addEventListener
(
"
ActivateSocialFeature
"
function
(
aEvent
)
{
let
document
=
content
.
document
;
if
(
PrivateBrowsingUtils
.
isContentWindowPrivate
(
content
)
)
{
Cu
.
reportError
(
"
cannot
use
social
providers
in
private
windows
"
)
;
return
;
}
let
dwu
=
content
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
if
(
!
dwu
.
isHandlingUserInput
)
{
Cu
.
reportError
(
"
attempt
to
activate
provider
without
user
input
from
"
+
document
.
nodePrincipal
.
origin
)
;
return
;
}
let
node
=
aEvent
.
target
;
let
ownerDocument
=
node
.
ownerDocument
;
let
data
=
node
.
getAttribute
(
"
data
-
service
"
)
;
if
(
data
)
{
try
{
data
=
JSON
.
parse
(
data
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
"
Social
Service
manifest
parse
error
:
"
+
e
)
;
return
;
}
}
else
{
Cu
.
reportError
(
"
Social
Service
manifest
not
available
"
)
;
return
;
}
sendAsyncMessage
(
"
Social
:
Activation
"
{
url
:
ownerDocument
.
location
.
href
origin
:
ownerDocument
.
nodePrincipal
.
origin
manifest
:
data
}
)
;
}
true
true
)
;
addMessageListener
(
"
ContextMenu
:
SaveVideoFrameAsImage
"
(
message
)
=
>
{
let
video
=
message
.
objects
.
target
;
let
canvas
=
content
.
document
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
"
canvas
"
)
;
canvas
.
width
=
video
.
videoWidth
;
canvas
.
height
=
video
.
videoHeight
;
let
ctxDraw
=
canvas
.
getContext
(
"
2d
"
)
;
ctxDraw
.
drawImage
(
video
0
0
)
;
sendAsyncMessage
(
"
ContextMenu
:
SaveVideoFrameAsImage
:
Result
"
{
dataURL
:
canvas
.
toDataURL
(
"
image
/
jpeg
"
"
"
)
}
)
;
}
)
;
addMessageListener
(
"
ContextMenu
:
MediaCommand
"
(
message
)
=
>
{
let
media
=
message
.
objects
.
element
;
switch
(
message
.
data
.
command
)
{
case
"
play
"
:
media
.
play
(
)
;
break
;
case
"
pause
"
:
media
.
pause
(
)
;
break
;
case
"
mute
"
:
media
.
muted
=
true
;
break
;
case
"
unmute
"
:
media
.
muted
=
false
;
break
;
case
"
playbackRate
"
:
media
.
playbackRate
=
message
.
data
.
data
;
break
;
case
"
hidecontrols
"
:
media
.
removeAttribute
(
"
controls
"
)
;
break
;
case
"
showcontrols
"
:
media
.
setAttribute
(
"
controls
"
"
true
"
)
;
break
;
case
"
hidestats
"
:
case
"
showstats
"
:
let
event
=
media
.
ownerDocument
.
createEvent
(
"
CustomEvent
"
)
;
event
.
initCustomEvent
(
"
media
-
showStatistics
"
false
true
message
.
data
.
command
=
=
"
showstats
"
)
;
media
.
dispatchEvent
(
event
)
;
break
;
case
"
fullscreen
"
:
if
(
content
.
document
.
fullscreenEnabled
)
media
.
requestFullscreen
(
)
;
break
;
}
}
)
;
addMessageListener
(
"
ContextMenu
:
Canvas
:
ToDataURL
"
(
message
)
=
>
{
let
dataURL
=
message
.
objects
.
target
.
toDataURL
(
)
;
sendAsyncMessage
(
"
ContextMenu
:
Canvas
:
ToDataURL
:
Result
"
{
dataURL
}
)
;
}
)
;
addMessageListener
(
"
ContextMenu
:
ReloadFrame
"
(
message
)
=
>
{
message
.
objects
.
target
.
ownerDocument
.
location
.
reload
(
)
;
}
)
;
addMessageListener
(
"
ContextMenu
:
ReloadImage
"
(
message
)
=
>
{
let
image
=
message
.
objects
.
target
;
if
(
image
instanceof
Ci
.
nsIImageLoadingContent
)
image
.
forceReload
(
)
;
}
)
;
addMessageListener
(
"
ContextMenu
:
BookmarkFrame
"
(
message
)
=
>
{
let
frame
=
message
.
objects
.
target
.
ownerDocument
;
sendAsyncMessage
(
"
ContextMenu
:
BookmarkFrame
:
Result
"
{
title
:
frame
.
title
description
:
PlacesUIUtils
.
getDescriptionFromDocument
(
frame
)
}
)
;
}
)
;
addMessageListener
(
"
ContextMenu
:
SearchFieldBookmarkData
"
(
message
)
=
>
{
let
node
=
message
.
objects
.
target
;
let
charset
=
node
.
ownerDocument
.
characterSet
;
let
formBaseURI
=
BrowserUtils
.
makeURI
(
node
.
form
.
baseURI
charset
)
;
let
formURI
=
BrowserUtils
.
makeURI
(
node
.
form
.
getAttribute
(
"
action
"
)
charset
formBaseURI
)
;
let
spec
=
formURI
.
spec
;
let
isURLEncoded
=
(
node
.
form
.
method
.
toUpperCase
(
)
=
=
"
POST
"
&
&
(
node
.
form
.
enctype
=
=
"
application
/
x
-
www
-
form
-
urlencoded
"
|
|
node
.
form
.
enctype
=
=
"
"
)
)
;
let
title
=
node
.
ownerDocument
.
title
;
let
description
=
PlacesUIUtils
.
getDescriptionFromDocument
(
node
.
ownerDocument
)
;
let
formData
=
[
]
;
function
escapeNameValuePair
(
aName
aValue
aIsFormUrlEncoded
)
{
if
(
aIsFormUrlEncoded
)
return
escape
(
aName
+
"
=
"
+
aValue
)
;
else
return
escape
(
aName
)
+
"
=
"
+
escape
(
aValue
)
;
}
for
(
let
el
of
node
.
form
.
elements
)
{
if
(
!
el
.
type
)
continue
;
if
(
el
=
=
node
)
{
formData
.
push
(
(
isURLEncoded
)
?
escapeNameValuePair
(
el
.
name
"
%
s
"
true
)
:
escapeNameValuePair
(
el
.
name
"
"
false
)
+
"
%
s
"
)
;
continue
;
}
let
type
=
el
.
type
.
toLowerCase
(
)
;
if
(
(
(
el
instanceof
content
.
HTMLInputElement
&
&
el
.
mozIsTextField
(
true
)
)
|
|
type
=
=
"
hidden
"
|
|
type
=
=
"
textarea
"
)
|
|
(
(
type
=
=
"
checkbox
"
|
|
type
=
=
"
radio
"
)
&
&
el
.
checked
)
)
{
formData
.
push
(
escapeNameValuePair
(
el
.
name
el
.
value
isURLEncoded
)
)
;
}
else
if
(
el
instanceof
content
.
HTMLSelectElement
&
&
el
.
selectedIndex
>
=
0
)
{
for
(
let
j
=
0
;
j
<
el
.
options
.
length
;
j
+
+
)
{
if
(
el
.
options
[
j
]
.
selected
)
formData
.
push
(
escapeNameValuePair
(
el
.
name
el
.
options
[
j
]
.
value
isURLEncoded
)
)
;
}
}
}
let
postData
;
if
(
isURLEncoded
)
postData
=
formData
.
join
(
"
&
"
)
;
else
{
let
separator
=
spec
.
includes
(
"
?
"
)
?
"
&
"
:
"
?
"
;
spec
+
=
separator
+
formData
.
join
(
"
&
"
)
;
}
sendAsyncMessage
(
"
ContextMenu
:
SearchFieldBookmarkData
:
Result
"
{
spec
title
description
postData
charset
}
)
;
}
)
;
addMessageListener
(
"
Bookmarks
:
GetPageDetails
"
(
message
)
=
>
{
let
doc
=
content
.
document
;
let
isErrorPage
=
/
^
about
:
(
neterror
|
certerror
|
blocked
)
/
.
test
(
doc
.
documentURI
)
;
sendAsyncMessage
(
"
Bookmarks
:
GetPageDetails
:
Result
"
{
isErrorPage
:
isErrorPage
description
:
PlacesUIUtils
.
getDescriptionFromDocument
(
doc
)
}
)
;
}
)
;
var
LightWeightThemeWebInstallListener
=
{
_previewWindow
:
null
init
:
function
(
)
{
addEventListener
(
"
InstallBrowserTheme
"
this
false
true
)
;
addEventListener
(
"
PreviewBrowserTheme
"
this
false
true
)
;
addEventListener
(
"
ResetBrowserThemePreview
"
this
false
true
)
;
}
handleEvent
:
function
(
event
)
{
switch
(
event
.
type
)
{
case
"
InstallBrowserTheme
"
:
{
sendAsyncMessage
(
"
LightWeightThemeWebInstaller
:
Install
"
{
baseURI
:
event
.
target
.
baseURI
themeData
:
event
.
target
.
getAttribute
(
"
data
-
browsertheme
"
)
}
)
;
break
;
}
case
"
PreviewBrowserTheme
"
:
{
sendAsyncMessage
(
"
LightWeightThemeWebInstaller
:
Preview
"
{
baseURI
:
event
.
target
.
baseURI
themeData
:
event
.
target
.
getAttribute
(
"
data
-
browsertheme
"
)
}
)
;
this
.
_previewWindow
=
event
.
target
.
ownerDocument
.
defaultView
;
this
.
_previewWindow
.
addEventListener
(
"
pagehide
"
this
true
)
;
break
;
}
case
"
pagehide
"
:
{
sendAsyncMessage
(
"
LightWeightThemeWebInstaller
:
ResetPreview
"
)
;
this
.
_resetPreviewWindow
(
)
;
break
;
}
case
"
ResetBrowserThemePreview
"
:
{
if
(
this
.
_previewWindow
)
{
sendAsyncMessage
(
"
LightWeightThemeWebInstaller
:
ResetPreview
"
{
baseURI
:
event
.
target
.
baseURI
}
)
;
this
.
_resetPreviewWindow
(
)
;
}
break
;
}
}
}
_resetPreviewWindow
:
function
(
)
{
this
.
_previewWindow
.
removeEventListener
(
"
pagehide
"
this
true
)
;
this
.
_previewWindow
=
null
;
}
}
;
LightWeightThemeWebInstallListener
.
init
(
)
;
function
disableSetDesktopBackground
(
aTarget
)
{
if
(
!
(
aTarget
instanceof
Ci
.
nsIImageLoadingContent
)
)
return
true
;
if
(
(
"
complete
"
in
aTarget
)
&
&
!
aTarget
.
complete
)
return
true
;
if
(
aTarget
.
currentURI
.
schemeIs
(
"
javascript
"
)
)
return
true
;
let
request
=
aTarget
.
QueryInterface
(
Ci
.
nsIImageLoadingContent
)
.
getRequest
(
Ci
.
nsIImageLoadingContent
.
CURRENT_REQUEST
)
;
if
(
!
request
)
return
true
;
return
false
;
}
addMessageListener
(
"
ContextMenu
:
SetAsDesktopBackground
"
(
message
)
=
>
{
let
target
=
message
.
objects
.
target
;
let
disable
=
disableSetDesktopBackground
(
target
)
;
if
(
!
disable
)
{
try
{
BrowserUtils
.
urlSecurityCheck
(
target
.
currentURI
.
spec
target
.
ownerDocument
.
nodePrincipal
)
;
let
canvas
=
content
.
document
.
createElement
(
"
canvas
"
)
;
canvas
.
width
=
target
.
naturalWidth
;
canvas
.
height
=
target
.
naturalHeight
;
let
ctx
=
canvas
.
getContext
(
"
2d
"
)
;
ctx
.
drawImage
(
target
0
0
)
;
let
dataUrl
=
canvas
.
toDataURL
(
)
;
sendAsyncMessage
(
"
ContextMenu
:
SetAsDesktopBackground
:
Result
"
{
dataUrl
}
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
disable
=
true
;
}
}
if
(
disable
)
sendAsyncMessage
(
"
ContextMenu
:
SetAsDesktopBackground
:
Result
"
{
disable
}
)
;
}
)
;
var
PageInfoListener
=
{
init
:
function
(
)
{
addMessageListener
(
"
PageInfo
:
getData
"
this
)
;
}
receiveMessage
:
function
(
message
)
{
let
strings
=
message
.
data
.
strings
;
let
window
;
let
document
;
let
frameOuterWindowID
=
message
.
data
.
frameOuterWindowID
;
if
(
frameOuterWindowID
)
{
window
=
Services
.
wm
.
getOuterWindowWithId
(
frameOuterWindowID
)
;
document
=
window
.
document
;
}
else
{
window
=
content
.
window
;
document
=
content
.
document
;
}
let
imageElement
=
message
.
objects
.
imageElement
;
let
pageInfoData
=
{
metaViewRows
:
this
.
getMetaInfo
(
document
)
docInfo
:
this
.
getDocumentInfo
(
document
)
feeds
:
this
.
getFeedsInfo
(
document
strings
)
windowInfo
:
this
.
getWindowInfo
(
window
)
imageInfo
:
this
.
getImageInfo
(
imageElement
)
}
;
sendAsyncMessage
(
"
PageInfo
:
data
"
pageInfoData
)
;
this
.
getMediaInfo
(
document
window
strings
)
;
}
getImageInfo
:
function
(
imageElement
)
{
let
imageInfo
=
null
;
if
(
imageElement
)
{
imageInfo
=
{
currentSrc
:
imageElement
.
currentSrc
width
:
imageElement
.
width
height
:
imageElement
.
height
imageText
:
imageElement
.
title
|
|
imageElement
.
alt
}
;
}
return
imageInfo
;
}
getMetaInfo
:
function
(
document
)
{
let
metaViewRows
=
[
]
;
let
metaNodes
=
document
.
getElementsByTagName
(
"
meta
"
)
;
for
(
let
metaNode
of
metaNodes
)
{
metaViewRows
.
push
(
[
metaNode
.
name
|
|
metaNode
.
httpEquiv
|
|
metaNode
.
getAttribute
(
"
property
"
)
metaNode
.
content
]
)
;
}
return
metaViewRows
;
}
getWindowInfo
:
function
(
window
)
{
let
windowInfo
=
{
}
;
windowInfo
.
isTopWindow
=
window
=
=
window
.
top
;
let
hostName
=
null
;
try
{
hostName
=
window
.
location
.
host
;
}
catch
(
exception
)
{
}
windowInfo
.
hostName
=
hostName
;
return
windowInfo
;
}
getDocumentInfo
:
function
(
document
)
{
let
docInfo
=
{
}
;
docInfo
.
title
=
document
.
title
;
docInfo
.
location
=
document
.
location
.
toString
(
)
;
docInfo
.
referrer
=
document
.
referrer
;
docInfo
.
compatMode
=
document
.
compatMode
;
docInfo
.
contentType
=
document
.
contentType
;
docInfo
.
characterSet
=
document
.
characterSet
;
docInfo
.
lastModified
=
document
.
lastModified
;
let
documentURIObject
=
{
}
;
documentURIObject
.
spec
=
document
.
documentURIObject
.
spec
;
documentURIObject
.
originCharset
=
document
.
documentURIObject
.
originCharset
;
docInfo
.
documentURIObject
=
documentURIObject
;
docInfo
.
isContentWindowPrivate
=
PrivateBrowsingUtils
.
isContentWindowPrivate
(
content
)
;
return
docInfo
;
}
getFeedsInfo
:
function
(
document
strings
)
{
let
feeds
=
[
]
;
let
linkNodes
=
document
.
getElementsByTagName
(
"
link
"
)
;
let
length
=
linkNodes
.
length
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
let
link
=
linkNodes
[
i
]
;
if
(
!
link
.
href
)
{
continue
;
}
let
rel
=
link
.
rel
&
&
link
.
rel
.
toLowerCase
(
)
;
let
rels
=
{
}
;
if
(
rel
)
{
for
(
let
relVal
of
rel
.
split
(
/
\
s
+
/
)
)
{
rels
[
relVal
]
=
true
;
}
}
if
(
rels
.
feed
|
|
(
link
.
type
&
&
rels
.
alternate
&
&
!
rels
.
stylesheet
)
)
{
let
type
=
Feeds
.
isValidFeed
(
link
document
.
nodePrincipal
"
feed
"
in
rels
)
;
if
(
type
)
{
type
=
strings
[
type
]
|
|
strings
[
"
application
/
rss
+
xml
"
]
;
feeds
.
push
(
[
link
.
title
type
link
.
href
]
)
;
}
}
}
return
feeds
;
}
getMediaInfo
:
function
(
document
window
strings
)
{
let
frameList
=
this
.
goThroughFrames
(
document
window
)
;
Task
.
spawn
(
(
)
=
>
this
.
processFrames
(
document
frameList
strings
)
)
;
}
goThroughFrames
:
function
(
document
window
)
{
let
frameList
=
[
document
]
;
if
(
window
&
&
window
.
frames
.
length
>
0
)
{
let
num
=
window
.
frames
.
length
;
for
(
let
i
=
0
;
i
<
num
;
i
+
+
)
{
frameList
.
concat
(
this
.
goThroughFrames
(
window
.
frames
[
i
]
.
document
window
.
frames
[
i
]
)
)
;
}
}
return
frameList
;
}
processFrames
:
function
*
(
document
frameList
strings
)
{
let
nodeCount
=
0
;
for
(
let
doc
of
frameList
)
{
let
iterator
=
doc
.
createTreeWalker
(
doc
content
.
NodeFilter
.
SHOW_ELEMENT
)
;
while
(
iterator
.
nextNode
(
)
)
{
let
mediaItems
=
this
.
getMediaItems
(
document
strings
iterator
.
currentNode
)
;
if
(
mediaItems
.
length
)
{
sendAsyncMessage
(
"
PageInfo
:
mediaData
"
{
mediaItems
isComplete
:
false
}
)
;
}
if
(
+
+
nodeCount
%
500
=
=
0
)
{
yield
new
Promise
(
resolve
=
>
setTimeout
(
resolve
10
)
)
;
}
}
}
sendAsyncMessage
(
"
PageInfo
:
mediaData
"
{
isComplete
:
true
}
)
;
}
getMediaItems
:
function
(
document
strings
elem
)
{
let
computedStyle
=
elem
.
ownerDocument
.
defaultView
.
getComputedStyle
(
elem
"
"
)
;
let
mediaItems
=
[
]
;
let
addImage
=
(
url
type
alt
elem
isBg
)
=
>
{
let
element
=
this
.
serializeElementInfo
(
document
url
type
alt
elem
isBg
)
;
mediaItems
.
push
(
[
url
type
alt
element
isBg
]
)
;
}
;
if
(
computedStyle
)
{
let
addImgFunc
=
(
label
val
)
=
>
{
if
(
val
.
primitiveType
=
=
content
.
CSSPrimitiveValue
.
CSS_URI
)
{
addImage
(
val
.
getStringValue
(
)
label
strings
.
notSet
elem
true
)
;
}
else
if
(
val
.
primitiveType
=
=
content
.
CSSPrimitiveValue
.
CSS_STRING
)
{
let
strVal
=
val
.
getStringValue
(
)
;
if
(
strVal
.
search
(
/
^
.
*
url
\
(
\
"
?
/
)
>
-
1
)
{
let
url
=
strVal
.
replace
(
/
^
.
*
url
\
(
\
"
?
/
"
"
)
.
replace
(
/
\
"
?
\
)
.
*
/
"
"
)
;
addImage
(
url
label
strings
.
notSet
elem
true
)
;
}
}
else
if
(
val
.
cssValueType
=
=
content
.
CSSValue
.
CSS_VALUE_LIST
)
{
for
(
let
i
=
0
;
i
<
val
.
length
;
i
+
+
)
{
addImgFunc
(
label
val
.
item
(
i
)
)
;
}
}
}
;
addImgFunc
(
strings
.
mediaBGImg
computedStyle
.
getPropertyCSSValue
(
"
background
-
image
"
)
)
;
addImgFunc
(
strings
.
mediaBorderImg
computedStyle
.
getPropertyCSSValue
(
"
border
-
image
-
source
"
)
)
;
addImgFunc
(
strings
.
mediaListImg
computedStyle
.
getPropertyCSSValue
(
"
list
-
style
-
image
"
)
)
;
addImgFunc
(
strings
.
mediaCursor
computedStyle
.
getPropertyCSSValue
(
"
cursor
"
)
)
;
}
if
(
elem
instanceof
content
.
HTMLImageElement
)
{
addImage
(
elem
.
src
strings
.
mediaImg
(
elem
.
hasAttribute
(
"
alt
"
)
)
?
elem
.
alt
:
strings
.
notSet
elem
false
)
;
}
else
if
(
elem
instanceof
content
.
SVGImageElement
)
{
try
{
let
href
=
makeURLAbsolute
(
elem
.
baseURI
elem
.
href
.
baseVal
)
;
addImage
(
href
strings
.
mediaImg
"
"
elem
false
)
;
}
catch
(
e
)
{
}
}
else
if
(
elem
instanceof
content
.
HTMLVideoElement
)
{
addImage
(
elem
.
currentSrc
strings
.
mediaVideo
"
"
elem
false
)
;
}
else
if
(
elem
instanceof
content
.
HTMLAudioElement
)
{
addImage
(
elem
.
currentSrc
strings
.
mediaAudio
"
"
elem
false
)
;
}
else
if
(
elem
instanceof
content
.
HTMLLinkElement
)
{
if
(
elem
.
rel
&
&
/
\
bicon
\
b
/
i
.
test
(
elem
.
rel
)
)
{
addImage
(
elem
.
href
strings
.
mediaLink
"
"
elem
false
)
;
}
}
else
if
(
elem
instanceof
content
.
HTMLInputElement
|
|
elem
instanceof
content
.
HTMLButtonElement
)
{
if
(
elem
.
type
.
toLowerCase
(
)
=
=
"
image
"
)
{
addImage
(
elem
.
src
strings
.
mediaInput
(
elem
.
hasAttribute
(
"
alt
"
)
)
?
elem
.
alt
:
strings
.
notSet
elem
false
)
;
}
}
else
if
(
elem
instanceof
content
.
HTMLObjectElement
)
{
addImage
(
elem
.
data
strings
.
mediaObject
this
.
getValueText
(
elem
)
elem
false
)
;
}
else
if
(
elem
instanceof
content
.
HTMLEmbedElement
)
{
addImage
(
elem
.
src
strings
.
mediaEmbed
"
"
elem
false
)
;
}
return
mediaItems
;
}
serializeElementInfo
:
function
(
document
url
type
alt
item
isBG
)
{
let
result
=
{
}
;
let
imageText
;
if
(
!
isBG
&
&
!
(
item
instanceof
content
.
SVGImageElement
)
&
&
!
(
document
instanceof
content
.
ImageDocument
)
)
{
imageText
=
item
.
title
|
|
item
.
alt
;
if
(
!
imageText
&
&
!
(
item
instanceof
content
.
HTMLImageElement
)
)
{
imageText
=
this
.
getValueText
(
item
)
;
}
}
result
.
imageText
=
imageText
;
result
.
longDesc
=
item
.
longDesc
;
result
.
numFrames
=
1
;
if
(
item
instanceof
content
.
HTMLObjectElement
|
|
item
instanceof
content
.
HTMLEmbedElement
|
|
item
instanceof
content
.
HTMLLinkElement
)
{
result
.
mimeType
=
item
.
type
;
}
if
(
!
result
.
mimeType
&
&
!
isBG
&
&
item
instanceof
Ci
.
nsIImageLoadingContent
)
{
let
imageRequest
=
item
.
getRequest
(
Ci
.
nsIImageLoadingContent
.
CURRENT_REQUEST
)
;
if
(
imageRequest
)
{
result
.
mimeType
=
imageRequest
.
mimeType
;
let
image
=
!
(
imageRequest
.
imageStatus
&
imageRequest
.
STATUS_ERROR
)
&
&
imageRequest
.
image
;
if
(
image
)
{
result
.
numFrames
=
image
.
numFrames
;
}
}
}
if
(
!
result
.
mimeType
&
&
url
.
startsWith
(
"
data
:
"
)
)
{
let
dataMimeType
=
/
^
data
:
(
image
\
/
[
^
;
]
+
)
/
i
.
exec
(
url
)
;
if
(
dataMimeType
)
result
.
mimeType
=
dataMimeType
[
1
]
.
toLowerCase
(
)
;
}
result
.
HTMLLinkElement
=
item
instanceof
content
.
HTMLLinkElement
;
result
.
HTMLInputElement
=
item
instanceof
content
.
HTMLInputElement
;
result
.
HTMLImageElement
=
item
instanceof
content
.
HTMLImageElement
;
result
.
HTMLObjectElement
=
item
instanceof
content
.
HTMLObjectElement
;
result
.
SVGImageElement
=
item
instanceof
content
.
SVGImageElement
;
result
.
HTMLVideoElement
=
item
instanceof
content
.
HTMLVideoElement
;
result
.
HTMLAudioElement
=
item
instanceof
content
.
HTMLAudioElement
;
if
(
isBG
)
{
let
img
=
content
.
document
.
createElement
(
"
img
"
)
;
img
.
src
=
url
;
result
.
naturalWidth
=
img
.
naturalWidth
;
result
.
naturalHeight
=
img
.
naturalHeight
;
}
else
{
result
.
width
=
item
.
width
;
result
.
height
=
item
.
height
;
}
if
(
item
instanceof
content
.
SVGImageElement
)
{
result
.
SVGImageElementWidth
=
item
.
width
.
baseVal
.
value
;
result
.
SVGImageElementHeight
=
item
.
height
.
baseVal
.
value
;
}
result
.
baseURI
=
item
.
baseURI
;
return
result
;
}
getValueText
:
function
(
node
)
{
let
valueText
=
"
"
;
if
(
node
instanceof
content
.
HTMLInputElement
|
|
node
instanceof
content
.
HTMLSelectElement
|
|
node
instanceof
content
.
HTMLTextAreaElement
)
{
return
valueText
;
}
let
length
=
node
.
childNodes
.
length
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
let
childNode
=
node
.
childNodes
[
i
]
;
let
nodeType
=
childNode
.
nodeType
;
if
(
nodeType
=
=
content
.
Node
.
TEXT_NODE
)
{
valueText
+
=
"
"
+
childNode
.
nodeValue
;
}
else
if
(
nodeType
=
=
content
.
Node
.
ELEMENT_NODE
)
{
if
(
childNode
instanceof
content
.
HTMLImageElement
)
{
valueText
+
=
"
"
+
this
.
getAltText
(
childNode
)
;
}
else
{
valueText
+
=
"
"
+
this
.
getValueText
(
childNode
)
;
}
}
}
return
this
.
stripWS
(
valueText
)
;
}
getAltText
:
function
(
node
)
{
let
altText
=
"
"
;
if
(
node
.
alt
)
{
return
node
.
alt
;
}
let
length
=
node
.
childNodes
.
length
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
if
(
(
altText
=
this
.
getAltText
(
node
.
childNodes
[
i
]
)
!
=
undefined
)
)
{
return
altText
;
}
}
return
"
"
;
}
stripWS
:
function
(
text
)
{
let
middleRE
=
/
\
s
+
/
g
;
let
endRE
=
/
(
^
\
s
+
)
|
(
\
s
+
)
/
g
;
text
=
text
.
replace
(
middleRE
"
"
)
;
return
text
.
replace
(
endRE
"
"
)
;
}
}
;
PageInfoListener
.
init
(
)
;
let
OfflineApps
=
{
_docId
:
0
_docIdMap
:
new
Map
(
)
_docManifestSet
:
new
Set
(
)
_observerAdded
:
false
registerWindow
(
aWindow
)
{
if
(
!
this
.
_observerAdded
)
{
this
.
_observerAdded
=
true
;
Services
.
obs
.
addObserver
(
this
"
offline
-
cache
-
update
-
completed
"
true
)
;
}
let
manifestURI
=
this
.
_getManifestURI
(
aWindow
)
;
this
.
_docManifestSet
.
add
(
manifestURI
.
spec
)
;
}
handleEvent
(
event
)
{
if
(
event
.
type
=
=
"
MozApplicationManifest
"
)
{
this
.
offlineAppRequested
(
event
.
originalTarget
.
defaultView
)
;
}
}
_getManifestURI
(
aWindow
)
{
if
(
!
aWindow
.
document
.
documentElement
)
return
null
;
var
attr
=
aWindow
.
document
.
documentElement
.
getAttribute
(
"
manifest
"
)
;
if
(
!
attr
)
return
null
;
try
{
var
contentURI
=
BrowserUtils
.
makeURI
(
aWindow
.
location
.
href
null
null
)
;
return
BrowserUtils
.
makeURI
(
attr
aWindow
.
document
.
characterSet
contentURI
)
;
}
catch
(
e
)
{
return
null
;
}
}
offlineAppRequested
(
aContentWindow
)
{
this
.
registerWindow
(
aContentWindow
)
;
if
(
!
Services
.
prefs
.
getBoolPref
(
"
browser
.
offline
-
apps
.
notify
"
)
)
{
return
;
}
let
currentURI
=
aContentWindow
.
document
.
documentURIObject
;
if
(
Services
.
perms
.
testExactPermission
(
currentURI
"
offline
-
app
"
)
!
=
Services
.
perms
.
UNKNOWN_ACTION
)
return
;
try
{
if
(
Services
.
prefs
.
getBoolPref
(
"
offline
-
apps
.
allow_by_default
"
)
)
{
return
;
}
}
catch
(
e
)
{
}
let
docId
=
+
+
this
.
_docId
;
this
.
_docIdMap
.
set
(
docId
Cu
.
getWeakReference
(
aContentWindow
.
document
)
)
;
sendAsyncMessage
(
"
OfflineApps
:
RequestPermission
"
{
uri
:
currentURI
.
spec
docId
}
)
;
}
_startFetching
(
aDocument
)
{
if
(
!
aDocument
.
documentElement
)
return
;
let
manifestURI
=
this
.
_getManifestURI
(
aDocument
.
defaultView
)
;
if
(
!
manifestURI
)
return
;
var
updateService
=
Cc
[
"
mozilla
.
org
/
offlinecacheupdate
-
service
;
1
"
]
.
getService
(
Ci
.
nsIOfflineCacheUpdateService
)
;
updateService
.
scheduleUpdate
(
manifestURI
aDocument
.
documentURIObject
aDocument
.
nodePrincipal
aDocument
.
defaultView
)
;
}
receiveMessage
(
aMessage
)
{
if
(
aMessage
.
name
=
=
"
OfflineApps
:
StartFetching
"
)
{
let
doc
=
this
.
_docIdMap
.
get
(
aMessage
.
data
.
docId
)
;
doc
=
doc
&
&
doc
.
get
(
)
;
if
(
doc
)
{
this
.
_startFetching
(
doc
)
;
}
this
.
_docIdMap
.
delete
(
aMessage
.
data
.
docId
)
;
}
}
observe
(
aSubject
aTopic
aState
)
{
if
(
aTopic
=
=
"
offline
-
cache
-
update
-
completed
"
)
{
let
cacheUpdate
=
aSubject
.
QueryInterface
(
Ci
.
nsIOfflineCacheUpdate
)
;
let
uri
=
cacheUpdate
.
manifestURI
;
if
(
uri
&
&
this
.
_docManifestSet
.
has
(
uri
.
spec
)
)
{
sendAsyncMessage
(
"
OfflineApps
:
CheckUsage
"
{
uri
:
uri
.
spec
}
)
;
}
}
}
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIObserver
Ci
.
nsISupportsWeakReference
]
)
}
;
addEventListener
(
"
MozApplicationManifest
"
OfflineApps
false
)
;
addMessageListener
(
"
OfflineApps
:
StartFetching
"
OfflineApps
)
;
