XPCOMUtils
.
defineLazyScriptGetter
(
this
[
"
PlacesToolbar
"
"
PlacesMenu
"
"
PlacesPanelview
"
"
PlacesPanelMenuView
"
]
"
chrome
:
/
/
browser
/
content
/
places
/
browserPlacesViews
.
js
"
)
;
var
StarUI
=
{
_itemGuids
:
null
_batching
:
false
_isNewBookmark
:
false
_isComposing
:
false
_autoCloseTimer
:
0
_autoCloseTimerEnabled
:
true
_removeBookmarksOnPopupHidden
:
false
_element
(
aID
)
{
return
document
.
getElementById
(
aID
)
;
}
get
panel
(
)
{
delete
this
.
panel
;
var
element
=
this
.
_element
(
"
editBookmarkPanel
"
)
;
element
.
hidden
=
false
;
element
.
addEventListener
(
"
keypress
"
this
{
mozSystemGroup
:
true
}
)
;
element
.
addEventListener
(
"
mousedown
"
this
)
;
element
.
addEventListener
(
"
mouseout
"
this
)
;
element
.
addEventListener
(
"
mousemove
"
this
)
;
element
.
addEventListener
(
"
compositionstart
"
this
)
;
element
.
addEventListener
(
"
compositionend
"
this
)
;
element
.
addEventListener
(
"
input
"
this
)
;
element
.
addEventListener
(
"
popuphidden
"
this
)
;
element
.
addEventListener
(
"
popupshown
"
this
)
;
return
this
.
panel
=
element
;
}
get
_blockedCommands
(
)
{
delete
this
.
_blockedCommands
;
return
this
.
_blockedCommands
=
[
"
cmd_close
"
"
cmd_closeWindow
"
]
.
map
(
id
=
>
this
.
_element
(
id
)
)
;
}
_blockCommands
:
function
SU__blockCommands
(
)
{
this
.
_blockedCommands
.
forEach
(
function
(
elt
)
{
if
(
elt
.
hasAttribute
(
"
wasDisabled
"
)
)
return
;
if
(
elt
.
getAttribute
(
"
disabled
"
)
=
=
"
true
"
)
{
elt
.
setAttribute
(
"
wasDisabled
"
"
true
"
)
;
}
else
{
elt
.
setAttribute
(
"
wasDisabled
"
"
false
"
)
;
elt
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
}
)
;
}
_restoreCommandsState
:
function
SU__restoreCommandsState
(
)
{
this
.
_blockedCommands
.
forEach
(
function
(
elt
)
{
if
(
elt
.
getAttribute
(
"
wasDisabled
"
)
!
=
"
true
"
)
elt
.
removeAttribute
(
"
disabled
"
)
;
elt
.
removeAttribute
(
"
wasDisabled
"
)
;
}
)
;
}
handleEvent
(
aEvent
)
{
switch
(
aEvent
.
type
)
{
case
"
mousemove
"
:
clearTimeout
(
this
.
_autoCloseTimer
)
;
break
;
case
"
popuphidden
"
:
{
clearTimeout
(
this
.
_autoCloseTimer
)
;
if
(
aEvent
.
originalTarget
=
=
this
.
panel
)
{
if
(
!
this
.
_element
(
"
editBookmarkPanelContent
"
)
.
hidden
)
this
.
quitEditMode
(
)
;
if
(
this
.
_anchorToolbarButton
)
{
this
.
_anchorToolbarButton
.
removeAttribute
(
"
open
"
)
;
this
.
_anchorToolbarButton
=
null
;
}
this
.
_restoreCommandsState
(
)
;
let
removeBookmarksOnPopupHidden
=
this
.
_removeBookmarksOnPopupHidden
;
this
.
_removeBookmarksOnPopupHidden
=
false
;
let
guidsForRemoval
=
this
.
_itemGuids
;
this
.
_itemGuids
=
null
;
if
(
this
.
_batching
)
{
this
.
endBatch
(
)
;
}
if
(
removeBookmarksOnPopupHidden
&
&
guidsForRemoval
)
{
if
(
this
.
_isNewBookmark
)
{
PlacesTransactions
.
undo
(
)
.
catch
(
Cu
.
reportError
)
;
break
;
}
PlacesTransactions
.
Remove
(
guidsForRemoval
)
.
transact
(
)
.
catch
(
Cu
.
reportError
)
;
}
else
if
(
this
.
_isNewBookmark
)
{
LibraryUI
.
triggerLibraryAnimation
(
"
bookmark
"
)
;
}
}
break
;
}
case
"
keypress
"
:
clearTimeout
(
this
.
_autoCloseTimer
)
;
this
.
_autoCloseTimerEnabled
=
false
;
if
(
aEvent
.
defaultPrevented
)
{
break
;
}
switch
(
aEvent
.
keyCode
)
{
case
KeyEvent
.
DOM_VK_ESCAPE
:
this
.
panel
.
hidePopup
(
)
;
break
;
case
KeyEvent
.
DOM_VK_RETURN
:
if
(
aEvent
.
target
.
classList
.
contains
(
"
expander
-
up
"
)
|
|
aEvent
.
target
.
classList
.
contains
(
"
expander
-
down
"
)
|
|
aEvent
.
target
.
id
=
=
"
editBMPanel_newFolderButton
"
|
|
aEvent
.
target
.
id
=
=
"
editBookmarkPanelRemoveButton
"
)
{
break
;
}
this
.
panel
.
hidePopup
(
)
;
break
;
case
0
:
let
accessKey
=
document
.
getElementById
(
"
key_close
"
)
;
if
(
eventMatchesKey
(
aEvent
accessKey
)
)
{
this
.
panel
.
hidePopup
(
)
;
}
break
;
}
break
;
case
"
compositionend
"
:
this
.
_isComposing
=
false
;
break
;
case
"
compositionstart
"
:
if
(
aEvent
.
defaultPrevented
)
{
break
;
}
this
.
_isComposing
=
true
;
case
"
input
"
:
case
"
mousedown
"
:
clearTimeout
(
this
.
_autoCloseTimer
)
;
this
.
_autoCloseTimerEnabled
=
false
;
break
;
case
"
mouseout
"
:
if
(
!
this
.
_autoCloseTimerEnabled
)
{
break
;
}
case
"
popupshown
"
:
if
(
aEvent
.
target
!
=
aEvent
.
currentTarget
)
{
break
;
}
if
(
this
.
_isNewBookmark
&
&
!
this
.
_isComposing
)
{
let
delay
=
3500
;
if
(
this
.
_closePanelQuickForTesting
)
{
delay
/
=
10
;
}
clearTimeout
(
this
.
_autoCloseTimer
)
;
this
.
_autoCloseTimer
=
setTimeout
(
(
)
=
>
{
if
(
!
this
.
panel
.
mozMatchesSelector
(
"
:
hover
"
)
)
{
this
.
panel
.
hidePopup
(
true
)
;
}
}
delay
)
;
this
.
_autoCloseTimerEnabled
=
true
;
}
break
;
}
}
_bookmarkPopupInitialized
:
false
async
showEditBookmarkPopup
(
aNode
aAnchorElement
aPosition
aIsNewBookmark
aUrl
)
{
if
(
this
.
panel
.
state
=
=
"
showing
"
|
|
this
.
panel
.
state
=
=
"
open
"
)
{
return
;
}
this
.
_isNewBookmark
=
aIsNewBookmark
;
this
.
_itemGuids
=
null
;
if
(
this
.
_bookmarkPopupInitialized
)
{
await
this
.
_doShowEditBookmarkPanel
(
aNode
aAnchorElement
aPosition
aUrl
)
;
return
;
}
this
.
_bookmarkPopupInitialized
=
true
;
let
header
=
this
.
_element
(
"
editBookmarkPanelHeader
"
)
;
let
rows
=
this
.
_element
(
"
editBookmarkPanelGrid
"
)
.
lastChild
;
rows
.
insertBefore
(
header
rows
.
firstChild
)
;
header
.
hidden
=
false
;
await
this
.
_doShowEditBookmarkPanel
(
aNode
aAnchorElement
aPosition
aUrl
)
;
}
async
_doShowEditBookmarkPanel
(
aNode
aAnchorElement
aPosition
aUrl
)
{
if
(
this
.
panel
.
state
!
=
"
closed
"
)
return
;
this
.
_blockCommands
(
)
;
this
.
_element
(
"
editBookmarkPanelTitle
"
)
.
value
=
this
.
_isNewBookmark
?
gNavigatorBundle
.
getString
(
"
editBookmarkPanel
.
pageBookmarkedTitle
"
)
:
gNavigatorBundle
.
getString
(
"
editBookmarkPanel
.
editBookmarkTitle
"
)
;
this
.
_element
(
"
editBookmarkPanelDescription
"
)
.
textContent
=
"
"
;
this
.
_element
(
"
editBookmarkPanelBottomButtons
"
)
.
hidden
=
false
;
this
.
_element
(
"
editBookmarkPanelContent
"
)
.
hidden
=
false
;
this
.
_itemGuids
=
[
]
;
await
PlacesUtils
.
bookmarks
.
fetch
(
{
url
:
aUrl
}
bookmark
=
>
this
.
_itemGuids
.
push
(
bookmark
.
guid
)
)
;
let
forms
=
gNavigatorBundle
.
getString
(
"
editBookmark
.
removeBookmarks
.
label
"
)
;
let
bookmarksCount
=
this
.
_itemGuids
.
length
;
let
label
=
PluralForm
.
get
(
bookmarksCount
forms
)
.
replace
(
"
#
1
"
bookmarksCount
)
;
this
.
_element
(
"
editBookmarkPanelRemoveButton
"
)
.
label
=
label
;
this
.
beginBatch
(
)
;
if
(
aAnchorElement
&
&
aAnchorElement
.
closest
(
"
#
urlbar
"
)
)
{
this
.
_anchorToolbarButton
=
aAnchorElement
;
aAnchorElement
.
setAttribute
(
"
open
"
"
true
"
)
;
}
else
{
this
.
_anchorToolbarButton
=
null
;
}
let
onPanelReady
=
fn
=
>
{
let
target
=
this
.
panel
;
if
(
target
.
parentNode
)
{
target
=
target
.
parentNode
;
}
target
.
addEventListener
(
"
popupshown
"
function
(
event
)
{
fn
(
)
;
}
{
"
capture
"
:
true
"
once
"
:
true
}
)
;
}
;
gEditItemOverlay
.
initPanel
(
{
node
:
aNode
onPanelReady
hiddenRows
:
[
"
description
"
"
location
"
"
loadInSidebar
"
"
keyword
"
]
focusedElement
:
"
preferred
"
}
)
;
this
.
panel
.
openPopup
(
aAnchorElement
aPosition
)
;
}
panelShown
:
function
SU_panelShown
(
aEvent
)
{
if
(
aEvent
.
target
=
=
this
.
panel
)
{
if
(
this
.
_element
(
"
editBookmarkPanelContent
"
)
.
hidden
)
{
this
.
panel
.
focus
(
)
;
}
}
}
quitEditMode
:
function
SU_quitEditMode
(
)
{
this
.
_element
(
"
editBookmarkPanelContent
"
)
.
hidden
=
true
;
this
.
_element
(
"
editBookmarkPanelBottomButtons
"
)
.
hidden
=
true
;
gEditItemOverlay
.
uninitPanel
(
true
)
;
}
removeBookmarkButtonCommand
:
function
SU_removeBookmarkButtonCommand
(
)
{
this
.
_removeBookmarksOnPopupHidden
=
true
;
this
.
panel
.
hidePopup
(
)
;
}
_batchBlockingDeferred
:
null
beginBatch
(
)
{
if
(
this
.
_batching
)
return
;
this
.
_batchBlockingDeferred
=
PromiseUtils
.
defer
(
)
;
PlacesTransactions
.
batch
(
async
(
)
=
>
{
await
this
.
_batchBlockingDeferred
.
promise
;
}
)
;
this
.
_batching
=
true
;
}
endBatch
(
)
{
if
(
!
this
.
_batching
)
return
;
this
.
_batchBlockingDeferred
.
resolve
(
)
;
this
.
_batchBlockingDeferred
=
null
;
this
.
_batching
=
false
;
}
}
;
var
PlacesCommandHook
=
{
async
bookmarkPage
(
aBrowser
aShowEditUI
aUrl
=
null
aTitle
=
null
)
{
let
url
=
aUrl
?
new
URL
(
aUrl
)
:
new
URL
(
aBrowser
.
currentURI
.
spec
)
;
let
info
=
await
PlacesUtils
.
bookmarks
.
fetch
(
{
url
}
)
;
let
isNewBookmark
=
!
info
;
if
(
!
info
)
{
let
parentGuid
=
PlacesUtils
.
bookmarks
.
unfiledGuid
;
info
=
{
url
parentGuid
}
;
let
description
=
null
;
let
charset
=
null
;
let
docInfo
=
aUrl
?
{
}
:
await
this
.
_getPageDetails
(
aBrowser
)
;
try
{
if
(
docInfo
.
isErrorPage
)
{
let
entry
=
await
PlacesUtils
.
history
.
fetch
(
aBrowser
.
currentURI
)
;
if
(
entry
)
{
info
.
title
=
entry
.
title
;
}
}
else
{
info
.
title
=
aTitle
|
|
aBrowser
.
contentTitle
;
}
info
.
title
=
info
.
title
|
|
url
.
href
;
description
=
docInfo
.
description
;
charset
=
aUrl
?
null
:
aBrowser
.
characterSet
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
if
(
aShowEditUI
&
&
isNewBookmark
)
{
StarUI
.
beginBatch
(
)
;
}
if
(
description
)
{
info
.
annotations
=
[
{
name
:
PlacesUIUtils
.
DESCRIPTION_ANNO
value
:
description
}
]
;
}
info
.
guid
=
await
PlacesTransactions
.
NewBookmark
(
info
)
.
transact
(
)
;
if
(
charset
&
&
!
PrivateBrowsingUtils
.
isBrowserPrivate
(
aBrowser
)
)
PlacesUtils
.
setCharsetForURI
(
makeURI
(
url
.
href
)
charset
)
;
}
gURLBar
.
handleRevert
(
)
;
if
(
!
aShowEditUI
)
return
;
let
node
=
await
PlacesUIUtils
.
promiseNodeLikeFromFetchInfo
(
info
)
;
let
anchor
=
BookmarkingUI
.
anchor
;
if
(
anchor
)
{
await
StarUI
.
showEditBookmarkPopup
(
node
anchor
"
bottomcenter
topright
"
isNewBookmark
url
)
;
return
;
}
await
StarUI
.
showEditBookmarkPopup
(
node
aBrowser
"
overlap
"
isNewBookmark
url
)
;
}
_getPageDetails
(
browser
)
{
return
new
Promise
(
resolve
=
>
{
let
mm
=
browser
.
messageManager
;
mm
.
addMessageListener
(
"
Bookmarks
:
GetPageDetails
:
Result
"
function
listener
(
msg
)
{
mm
.
removeMessageListener
(
"
Bookmarks
:
GetPageDetails
:
Result
"
listener
)
;
resolve
(
msg
.
data
)
;
}
)
;
mm
.
sendAsyncMessage
(
"
Bookmarks
:
GetPageDetails
"
{
}
)
;
}
)
;
}
async
bookmarkLink
(
parentId
url
title
description
=
"
"
)
{
let
bm
=
await
PlacesUtils
.
bookmarks
.
fetch
(
{
url
}
)
;
if
(
bm
)
{
let
node
=
await
PlacesUIUtils
.
promiseNodeLikeFromFetchInfo
(
bm
)
;
PlacesUIUtils
.
showBookmarkDialog
(
{
action
:
"
edit
"
node
}
window
.
top
)
;
return
;
}
let
parentGuid
=
parentId
=
=
PlacesUtils
.
bookmarksMenuFolderId
?
PlacesUtils
.
bookmarks
.
menuGuid
:
await
PlacesUtils
.
promiseItemGuid
(
parentId
)
;
let
defaultInsertionPoint
=
new
PlacesInsertionPoint
(
{
parentId
parentGuid
}
)
;
PlacesUIUtils
.
showBookmarkDialog
(
{
action
:
"
add
"
type
:
"
bookmark
"
uri
:
makeURI
(
url
)
title
description
defaultInsertionPoint
hiddenRows
:
[
"
description
"
"
location
"
"
loadInSidebar
"
"
keyword
"
]
}
window
.
top
)
;
}
get
uniqueCurrentPages
(
)
{
let
uniquePages
=
{
}
;
let
URIs
=
[
]
;
gBrowser
.
visibleTabs
.
forEach
(
tab
=
>
{
let
browser
=
tab
.
linkedBrowser
;
let
uri
=
browser
.
currentURI
;
let
title
=
browser
.
contentTitle
|
|
tab
.
label
;
let
spec
=
uri
.
spec
;
if
(
!
tab
.
pinned
&
&
!
(
spec
in
uniquePages
)
)
{
uniquePages
[
spec
]
=
null
;
URIs
.
push
(
{
uri
title
}
)
;
}
}
)
;
return
URIs
;
}
bookmarkCurrentPages
:
function
PCH_bookmarkCurrentPages
(
)
{
let
pages
=
this
.
uniqueCurrentPages
;
if
(
pages
.
length
>
1
)
{
PlacesUIUtils
.
showBookmarkDialog
(
{
action
:
"
add
"
type
:
"
folder
"
URIList
:
pages
hiddenRows
:
[
"
description
"
]
}
window
)
;
}
}
updateBookmarkAllTabsCommand
:
function
PCH_updateBookmarkAllTabsCommand
(
)
{
if
(
window
.
location
.
href
!
=
getBrowserURL
(
)
)
return
;
goSetCommandEnabled
(
"
Browser
:
BookmarkAllTabs
"
this
.
uniqueCurrentPages
.
length
>
=
2
)
;
}
async
addLiveBookmark
(
url
feedTitle
feedSubtitle
)
{
let
toolbarIP
=
new
PlacesInsertionPoint
(
{
parentId
:
PlacesUtils
.
toolbarFolderId
parentGuid
:
PlacesUtils
.
bookmarks
.
toolbarGuid
}
)
;
let
feedURI
=
makeURI
(
url
)
;
let
title
=
feedTitle
|
|
gBrowser
.
contentTitle
;
let
description
=
feedSubtitle
;
if
(
!
description
)
{
description
=
(
await
this
.
_getPageDetails
(
gBrowser
.
selectedBrowser
)
)
.
description
;
}
PlacesUIUtils
.
showBookmarkDialog
(
{
action
:
"
add
"
type
:
"
livemark
"
feedURI
siteURI
:
gBrowser
.
currentURI
title
description
defaultInsertionPoint
:
toolbarIP
hiddenRows
:
[
"
feedLocation
"
"
siteLocation
"
"
description
"
]
}
window
)
;
}
showPlacesOrganizer
(
item
)
{
var
organizer
=
Services
.
wm
.
getMostRecentWindow
(
"
Places
:
Organizer
"
)
;
if
(
!
organizer
|
|
organizer
.
closed
)
{
openDialog
(
"
chrome
:
/
/
browser
/
content
/
places
/
places
.
xul
"
"
"
"
chrome
toolbar
=
yes
dialog
=
no
resizable
"
item
)
;
}
else
{
organizer
.
PlacesOrganizer
.
selectLeftPaneContainerByHierarchy
(
item
)
;
organizer
.
focus
(
)
;
}
}
searchBookmarks
(
)
{
if
(
!
focusAndSelectUrlBar
(
)
)
{
return
;
}
for
(
let
char
of
[
"
*
"
"
"
]
)
{
let
code
=
char
.
charCodeAt
(
0
)
;
gURLBar
.
inputField
.
dispatchEvent
(
new
KeyboardEvent
(
"
keypress
"
{
keyCode
:
code
charCode
:
code
bubbles
:
true
}
)
)
;
}
}
}
;
ChromeUtils
.
defineModuleGetter
(
this
"
RecentlyClosedTabsAndWindowsMenuUtils
"
"
resource
:
/
/
/
modules
/
sessionstore
/
RecentlyClosedTabsAndWindowsMenuUtils
.
jsm
"
)
;
function
HistoryMenu
(
aPopupShowingEvent
)
{
this
.
__proto__
.
__proto__
=
PlacesMenu
.
prototype
;
PlacesMenu
.
call
(
this
aPopupShowingEvent
"
place
:
sort
=
4
&
maxResults
=
15
"
)
;
}
HistoryMenu
.
prototype
=
{
_getClosedTabCount
(
)
{
if
(
window
=
=
Services
.
appShell
.
hiddenDOMWindow
)
{
return
0
;
}
return
SessionStore
.
getClosedTabCount
(
window
)
;
}
toggleRecentlyClosedTabs
:
function
HM_toggleRecentlyClosedTabs
(
)
{
var
undoMenu
=
this
.
_rootElt
.
getElementsByClassName
(
"
recentlyClosedTabsMenu
"
)
[
0
]
;
if
(
this
.
_getClosedTabCount
(
)
=
=
0
)
undoMenu
.
setAttribute
(
"
disabled
"
true
)
;
else
undoMenu
.
removeAttribute
(
"
disabled
"
)
;
}
populateUndoSubmenu
:
function
PHM_populateUndoSubmenu
(
)
{
var
undoMenu
=
this
.
_rootElt
.
getElementsByClassName
(
"
recentlyClosedTabsMenu
"
)
[
0
]
;
var
undoPopup
=
undoMenu
.
firstChild
;
while
(
undoPopup
.
hasChildNodes
(
)
)
undoPopup
.
firstChild
.
remove
(
)
;
if
(
this
.
_getClosedTabCount
(
)
=
=
0
)
{
undoMenu
.
setAttribute
(
"
disabled
"
true
)
;
return
;
}
undoMenu
.
removeAttribute
(
"
disabled
"
)
;
let
tabsFragment
=
RecentlyClosedTabsAndWindowsMenuUtils
.
getTabsFragment
(
window
"
menuitem
"
)
;
undoPopup
.
appendChild
(
tabsFragment
)
;
}
toggleRecentlyClosedWindows
:
function
PHM_toggleRecentlyClosedWindows
(
)
{
var
undoMenu
=
this
.
_rootElt
.
getElementsByClassName
(
"
recentlyClosedWindowsMenu
"
)
[
0
]
;
if
(
SessionStore
.
getClosedWindowCount
(
)
=
=
0
)
undoMenu
.
setAttribute
(
"
disabled
"
true
)
;
else
undoMenu
.
removeAttribute
(
"
disabled
"
)
;
}
populateUndoWindowSubmenu
:
function
PHM_populateUndoWindowSubmenu
(
)
{
let
undoMenu
=
this
.
_rootElt
.
getElementsByClassName
(
"
recentlyClosedWindowsMenu
"
)
[
0
]
;
let
undoPopup
=
undoMenu
.
firstChild
;
while
(
undoPopup
.
hasChildNodes
(
)
)
undoPopup
.
firstChild
.
remove
(
)
;
if
(
SessionStore
.
getClosedWindowCount
(
)
=
=
0
)
{
undoMenu
.
setAttribute
(
"
disabled
"
true
)
;
return
;
}
undoMenu
.
removeAttribute
(
"
disabled
"
)
;
let
windowsFragment
=
RecentlyClosedTabsAndWindowsMenuUtils
.
getWindowsFragment
(
window
"
menuitem
"
)
;
undoPopup
.
appendChild
(
windowsFragment
)
;
}
toggleTabsFromOtherComputers
:
function
PHM_toggleTabsFromOtherComputers
(
)
{
let
menuitem
=
this
.
_rootElt
.
getElementsByClassName
(
"
syncTabsMenuItem
"
)
[
0
]
;
if
(
!
menuitem
)
return
;
if
(
!
PlacesUIUtils
.
shouldShowTabsFromOtherComputersMenuitem
(
)
)
{
menuitem
.
setAttribute
(
"
hidden
"
true
)
;
return
;
}
menuitem
.
setAttribute
(
"
hidden
"
false
)
;
}
_onPopupShowing
:
function
HM__onPopupShowing
(
aEvent
)
{
PlacesMenu
.
prototype
.
_onPopupShowing
.
apply
(
this
arguments
)
;
if
(
aEvent
.
target
!
=
aEvent
.
currentTarget
)
return
;
this
.
toggleRecentlyClosedTabs
(
)
;
this
.
toggleRecentlyClosedWindows
(
)
;
this
.
toggleTabsFromOtherComputers
(
)
;
}
_onCommand
:
function
HM__onCommand
(
aEvent
)
{
let
placesNode
=
aEvent
.
target
.
_placesNode
;
if
(
placesNode
)
{
if
(
!
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
PlacesUIUtils
.
markPageAsTyped
(
placesNode
.
uri
)
;
openUILink
(
placesNode
.
uri
aEvent
{
ignoreAlt
:
true
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
}
)
;
}
}
}
;
var
BookmarksEventHandler
=
{
onMouseUp
(
aEvent
)
{
if
(
aEvent
.
button
!
=
0
|
|
PlacesUIUtils
.
openInTabClosesMenu
)
return
;
let
target
=
aEvent
.
originalTarget
;
if
(
target
.
tagName
!
=
"
menuitem
"
)
return
;
let
modifKey
=
AppConstants
.
platform
=
=
=
"
macosx
"
?
aEvent
.
metaKey
:
aEvent
.
ctrlKey
;
if
(
modifKey
)
{
target
.
setAttribute
(
"
closemenu
"
"
none
"
)
;
}
}
onClick
:
function
BEH_onClick
(
aEvent
aView
)
{
let
modifKey
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
modifKey
=
aEvent
.
metaKey
|
|
aEvent
.
shiftKey
;
}
else
{
modifKey
=
aEvent
.
ctrlKey
|
|
aEvent
.
shiftKey
;
}
if
(
aEvent
.
button
=
=
2
|
|
(
aEvent
.
button
=
=
0
&
&
!
modifKey
)
)
return
;
var
target
=
aEvent
.
originalTarget
;
var
tag
=
target
.
tagName
;
if
(
PlacesUIUtils
.
openInTabClosesMenu
&
&
(
tag
=
=
"
menuitem
"
|
|
tag
=
=
"
menu
"
)
)
{
closeMenus
(
aEvent
.
target
)
;
}
if
(
aEvent
.
button
=
=
0
&
&
target
.
tagName
=
=
"
menuitem
"
&
&
target
.
getAttribute
(
"
closemenu
"
)
=
=
"
none
"
)
{
setTimeout
(
(
)
=
>
{
target
.
removeAttribute
(
"
closemenu
"
)
;
}
500
)
;
}
if
(
target
.
_placesNode
&
&
PlacesUtils
.
nodeIsContainer
(
target
.
_placesNode
)
)
{
if
(
target
.
localName
=
=
"
menu
"
|
|
target
.
localName
=
=
"
toolbarbutton
"
)
PlacesUIUtils
.
openContainerNodeInTabs
(
target
.
_placesNode
aEvent
aView
)
;
}
else
if
(
aEvent
.
button
=
=
1
)
{
this
.
onCommand
(
aEvent
)
;
}
}
onCommand
:
function
BEH_onCommand
(
aEvent
)
{
var
target
=
aEvent
.
originalTarget
;
if
(
target
.
_placesNode
)
PlacesUIUtils
.
openNodeWithEvent
(
target
.
_placesNode
aEvent
)
;
}
fillInBHTooltip
:
function
BEH_fillInBHTooltip
(
aDocument
aEvent
)
{
var
node
;
var
cropped
=
false
;
var
targetURI
;
if
(
aDocument
.
tooltipNode
.
localName
=
=
"
treechildren
"
)
{
var
tree
=
aDocument
.
tooltipNode
.
parentNode
;
var
tbo
=
tree
.
treeBoxObject
;
var
cell
=
tbo
.
getCellAt
(
aEvent
.
clientX
aEvent
.
clientY
)
;
if
(
cell
.
row
=
=
-
1
)
return
false
;
node
=
tree
.
view
.
nodeForTreeIndex
(
cell
.
row
)
;
cropped
=
tbo
.
isCellCropped
(
cell
.
row
cell
.
col
)
;
}
else
{
var
tooltipNode
=
aDocument
.
tooltipNode
;
if
(
tooltipNode
.
_placesNode
)
node
=
tooltipNode
.
_placesNode
;
else
{
targetURI
=
tooltipNode
.
getAttribute
(
"
targetURI
"
)
;
}
}
if
(
!
node
&
&
!
targetURI
)
return
false
;
var
title
=
node
?
node
.
title
:
tooltipNode
.
label
;
var
url
;
if
(
targetURI
|
|
PlacesUtils
.
nodeIsURI
(
node
)
)
url
=
targetURI
|
|
node
.
uri
;
if
(
!
cropped
&
&
!
url
)
return
false
;
var
tooltipTitle
=
aDocument
.
getElementById
(
"
bhtTitleText
"
)
;
tooltipTitle
.
hidden
=
(
!
title
|
|
(
title
=
=
url
)
)
;
if
(
!
tooltipTitle
.
hidden
)
tooltipTitle
.
textContent
=
title
;
var
tooltipUrl
=
aDocument
.
getElementById
(
"
bhtUrlText
"
)
;
tooltipUrl
.
hidden
=
!
url
;
if
(
!
tooltipUrl
.
hidden
)
tooltipUrl
.
value
=
url
;
return
true
;
}
}
;
var
PlacesMenuDNDHandler
=
{
_springLoadDelayMs
:
350
_closeDelayMs
:
500
_loadTimer
:
null
_closeTimer
:
null
_closingTimerNode
:
null
onDragEnter
:
function
PMDH_onDragEnter
(
event
)
{
if
(
!
this
.
_isStaticContainer
(
event
.
target
)
)
return
;
if
(
this
.
_closeTimer
&
&
this
.
_closingTimerNode
=
=
=
event
.
currentTarget
)
{
this
.
_closeTimer
.
cancel
(
)
;
this
.
_closingTimerNode
=
null
;
this
.
_closeTimer
=
null
;
}
PlacesControllerDragHelper
.
currentDropTarget
=
event
.
target
;
let
popup
=
event
.
target
.
lastChild
;
if
(
this
.
_loadTimer
|
|
popup
.
state
=
=
=
"
showing
"
|
|
popup
.
state
=
=
=
"
open
"
)
return
;
this
.
_loadTimer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
this
.
_loadTimer
.
initWithCallback
(
(
)
=
>
{
this
.
_loadTimer
=
null
;
popup
.
setAttribute
(
"
autoopened
"
"
true
"
)
;
popup
.
showPopup
(
popup
)
;
}
this
.
_springLoadDelayMs
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
}
onDragLeave
:
function
PMDH_onDragLeave
(
event
)
{
if
(
event
.
relatedTarget
=
=
=
event
.
currentTarget
|
|
(
event
.
relatedTarget
&
&
event
.
relatedTarget
.
parentNode
=
=
=
event
.
currentTarget
)
)
return
;
if
(
!
this
.
_isStaticContainer
(
event
.
target
)
)
return
;
PlacesControllerDragHelper
.
currentDropTarget
=
null
;
let
popup
=
event
.
target
.
lastChild
;
if
(
this
.
_loadTimer
)
{
this
.
_loadTimer
.
cancel
(
)
;
this
.
_loadTimer
=
null
;
}
this
.
_closeTimer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
this
.
_closingTimerNode
=
event
.
currentTarget
;
this
.
_closeTimer
.
initWithCallback
(
function
(
)
{
this
.
_closeTimer
=
null
;
this
.
_closingTimerNode
=
null
;
let
node
=
PlacesControllerDragHelper
.
currentDropTarget
;
let
inHierarchy
=
false
;
while
(
node
&
&
!
inHierarchy
)
{
inHierarchy
=
node
=
=
event
.
target
;
node
=
node
.
parentNode
;
}
if
(
!
inHierarchy
&
&
popup
&
&
popup
.
hasAttribute
(
"
autoopened
"
)
)
{
popup
.
removeAttribute
(
"
autoopened
"
)
;
popup
.
hidePopup
(
)
;
}
}
this
.
_closeDelayMs
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
_isStaticContainer
:
function
PMDH__isContainer
(
node
)
{
let
isMenu
=
node
.
localName
=
=
"
menu
"
|
|
(
node
.
localName
=
=
"
toolbarbutton
"
&
&
node
.
getAttribute
(
"
type
"
)
=
=
"
menu
"
)
;
let
isStatic
=
!
(
"
_placesNode
"
in
node
)
&
&
node
.
lastChild
&
&
node
.
lastChild
.
hasAttribute
(
"
placespopup
"
)
&
&
!
node
.
parentNode
.
hasAttribute
(
"
placespopup
"
)
;
return
isMenu
&
&
isStatic
;
}
onDragOver
:
function
PMDH_onDragOver
(
event
)
{
let
ip
=
new
PlacesInsertionPoint
(
{
parentId
:
PlacesUtils
.
bookmarksMenuFolderId
parentGuid
:
PlacesUtils
.
bookmarks
.
menuGuid
}
)
;
if
(
ip
&
&
PlacesControllerDragHelper
.
canDrop
(
ip
event
.
dataTransfer
)
)
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
}
onDrop
:
function
PMDH_onDrop
(
event
)
{
let
ip
=
new
PlacesInsertionPoint
(
{
parentId
:
PlacesUtils
.
bookmarksMenuFolderId
parentGuid
:
PlacesUtils
.
bookmarks
.
menuGuid
}
)
;
PlacesControllerDragHelper
.
onDrop
(
ip
event
.
dataTransfer
)
;
PlacesControllerDragHelper
.
currentDropTarget
=
null
;
event
.
stopPropagation
(
)
;
}
}
;
var
PlacesToolbarHelper
=
{
_place
:
"
place
:
folder
=
TOOLBAR
"
get
_viewElt
(
)
{
return
document
.
getElementById
(
"
PlacesToolbar
"
)
;
}
init
:
function
PTH_init
(
)
{
let
viewElt
=
this
.
_viewElt
;
if
(
!
viewElt
|
|
viewElt
.
_placesView
)
return
;
CustomizableUI
.
addListener
(
this
)
;
if
(
!
this
.
_isObservingToolbars
)
{
this
.
_isObservingToolbars
=
true
;
window
.
addEventListener
(
"
toolbarvisibilitychange
"
this
)
;
}
let
toolbar
=
this
.
_getParentToolbar
(
viewElt
)
;
if
(
!
toolbar
|
|
toolbar
.
collapsed
|
|
this
.
_isCustomizing
|
|
getComputedStyle
(
toolbar
"
"
)
.
display
=
=
"
none
"
)
{
return
;
}
new
PlacesToolbar
(
this
.
_place
)
;
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
toolbarvisibilitychange
"
:
if
(
event
.
target
=
=
this
.
_getParentToolbar
(
this
.
_viewElt
)
)
this
.
_resetView
(
)
;
break
;
}
}
uninit
:
function
PTH_uninit
(
)
{
if
(
this
.
_isObservingToolbars
)
{
delete
this
.
_isObservingToolbars
;
window
.
removeEventListener
(
"
toolbarvisibilitychange
"
this
)
;
}
CustomizableUI
.
removeListener
(
this
)
;
}
customizeStart
:
function
PTH_customizeStart
(
)
{
try
{
let
viewElt
=
this
.
_viewElt
;
if
(
viewElt
&
&
viewElt
.
_placesView
)
viewElt
.
_placesView
.
uninit
(
)
;
}
finally
{
this
.
_isCustomizing
=
true
;
}
}
customizeDone
:
function
PTH_customizeDone
(
)
{
this
.
_isCustomizing
=
false
;
this
.
init
(
)
;
}
onPlaceholderCommand
(
)
{
let
widgetGroup
=
CustomizableUI
.
getWidget
(
"
personal
-
bookmarks
"
)
;
let
widget
=
widgetGroup
.
forWindow
(
window
)
;
if
(
widget
.
overflowed
|
|
widgetGroup
.
areaType
=
=
CustomizableUI
.
TYPE_MENU_PANEL
)
{
PlacesCommandHook
.
showPlacesOrganizer
(
"
BookmarksToolbar
"
)
;
}
}
_getParentToolbar
(
element
)
{
while
(
element
)
{
if
(
element
.
localName
=
=
"
toolbar
"
)
{
return
element
;
}
element
=
element
.
parentNode
;
}
return
null
;
}
onWidgetUnderflow
(
aNode
aContainer
)
{
let
win
=
aNode
.
ownerGlobal
;
if
(
aNode
.
id
=
=
"
personal
-
bookmarks
"
&
&
win
=
=
window
)
{
this
.
_resetView
(
)
;
}
}
onWidgetAdded
(
aWidgetId
aArea
aPosition
)
{
if
(
aWidgetId
=
=
"
personal
-
bookmarks
"
&
&
!
this
.
_isCustomizing
)
{
this
.
_resetView
(
)
;
}
}
_resetView
(
)
{
if
(
this
.
_viewElt
)
{
if
(
this
.
_viewElt
.
_placesView
)
{
this
.
_viewElt
.
_placesView
.
uninit
(
)
;
}
this
.
init
(
)
;
}
}
}
;
var
LibraryUI
=
{
triggerLibraryAnimation
(
animation
)
{
if
(
!
this
.
hasOwnProperty
(
"
COSMETIC_ANIMATIONS_ENABLED
"
)
)
{
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
COSMETIC_ANIMATIONS_ENABLED
"
"
toolkit
.
cosmeticAnimations
.
enabled
"
true
)
;
}
let
libraryButton
=
document
.
getElementById
(
"
library
-
button
"
)
;
if
(
!
libraryButton
|
|
libraryButton
.
getAttribute
(
"
cui
-
areatype
"
)
=
=
"
menu
-
panel
"
|
|
libraryButton
.
getAttribute
(
"
overflowedItem
"
)
=
=
"
true
"
|
|
!
libraryButton
.
closest
(
"
#
nav
-
bar
"
)
|
|
!
window
.
toolbar
.
visible
|
|
!
this
.
COSMETIC_ANIMATIONS_ENABLED
)
{
return
;
}
let
animatableBox
=
document
.
getElementById
(
"
library
-
animatable
-
box
"
)
;
let
navBar
=
document
.
getElementById
(
"
nav
-
bar
"
)
;
let
libraryIcon
=
document
.
getAnonymousElementByAttribute
(
libraryButton
"
class
"
"
toolbarbutton
-
icon
"
)
;
let
dwu
=
window
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
let
iconBounds
=
dwu
.
getBoundsWithoutFlushing
(
libraryIcon
)
;
let
libraryBounds
=
dwu
.
getBoundsWithoutFlushing
(
libraryButton
)
;
let
toolboxBounds
=
dwu
.
getBoundsWithoutFlushing
(
gNavToolbox
)
;
animatableBox
.
style
.
setProperty
(
"
-
-
toolbox
-
y
"
toolboxBounds
.
y
+
"
px
"
)
;
animatableBox
.
style
.
setProperty
(
"
-
-
library
-
button
-
y
"
libraryBounds
.
y
+
"
px
"
)
;
animatableBox
.
style
.
setProperty
(
"
-
-
library
-
button
-
height
"
libraryBounds
.
height
+
"
px
"
)
;
animatableBox
.
style
.
setProperty
(
"
-
-
library
-
icon
-
x
"
iconBounds
.
x
+
"
px
"
)
;
if
(
navBar
.
hasAttribute
(
"
brighttext
"
)
)
{
animatableBox
.
setAttribute
(
"
brighttext
"
"
true
"
)
;
}
else
{
animatableBox
.
removeAttribute
(
"
brighttext
"
)
;
}
animatableBox
.
removeAttribute
(
"
fade
"
)
;
libraryButton
.
setAttribute
(
"
animate
"
animation
)
;
animatableBox
.
setAttribute
(
"
animate
"
animation
)
;
if
(
!
this
.
_libraryButtonAnimationEndListeners
[
animation
]
)
{
this
.
_libraryButtonAnimationEndListeners
[
animation
]
=
event
=
>
{
this
.
_libraryButtonAnimationEndListener
(
event
animation
)
;
}
;
}
animatableBox
.
addEventListener
(
"
animationend
"
this
.
_libraryButtonAnimationEndListeners
[
animation
]
)
;
window
.
addEventListener
(
"
resize
"
this
.
_onWindowResize
)
;
}
_libraryButtonAnimationEndListeners
:
{
}
_libraryButtonAnimationEndListener
(
aEvent
animation
)
{
let
animatableBox
=
document
.
getElementById
(
"
library
-
animatable
-
box
"
)
;
if
(
aEvent
.
animationName
.
startsWith
(
library
-
{
animation
}
-
animation
)
)
{
animatableBox
.
setAttribute
(
"
fade
"
"
true
"
)
;
}
else
if
(
aEvent
.
animationName
=
=
library
-
{
animation
}
-
fade
)
{
animatableBox
.
removeEventListener
(
"
animationend
"
LibraryUI
.
_libraryButtonAnimationEndListeners
[
animation
]
)
;
animatableBox
.
removeAttribute
(
"
animate
"
)
;
animatableBox
.
removeAttribute
(
"
fade
"
)
;
window
.
removeEventListener
(
"
resize
"
this
.
_onWindowResize
)
;
let
libraryButton
=
document
.
getElementById
(
"
library
-
button
"
)
;
libraryButton
.
removeAttribute
(
"
animate
"
)
;
}
}
_windowResizeRunning
:
false
_onWindowResize
(
aEvent
)
{
if
(
LibraryUI
.
_windowResizeRunning
)
{
return
;
}
LibraryUI
.
_windowResizeRunning
=
true
;
requestAnimationFrame
(
(
)
=
>
{
let
libraryButton
=
document
.
getElementById
(
"
library
-
button
"
)
;
if
(
!
libraryButton
|
|
libraryButton
.
getAttribute
(
"
cui
-
areatype
"
)
=
=
"
menu
-
panel
"
|
|
libraryButton
.
getAttribute
(
"
overflowedItem
"
)
=
=
"
true
"
|
|
!
libraryButton
.
closest
(
"
#
nav
-
bar
"
)
)
{
return
;
}
let
animatableBox
=
document
.
getElementById
(
"
library
-
animatable
-
box
"
)
;
let
libraryIcon
=
document
.
getAnonymousElementByAttribute
(
libraryButton
"
class
"
"
toolbarbutton
-
icon
"
)
;
let
dwu
=
window
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
let
iconBounds
=
dwu
.
getBoundsWithoutFlushing
(
libraryIcon
)
;
animatableBox
.
style
.
setProperty
(
"
-
-
library
-
icon
-
x
"
iconBounds
.
x
+
"
px
"
)
;
LibraryUI
.
_windowResizeRunning
=
false
;
}
)
;
}
}
;
var
BookmarkingUI
=
{
STAR_ID
:
"
star
-
button
"
STAR_BOX_ID
:
"
star
-
button
-
box
"
BOOKMARK_BUTTON_ID
:
"
bookmarks
-
menu
-
button
"
BOOKMARK_BUTTON_SHORTCUT
:
"
addBookmarkAsKb
"
get
button
(
)
{
delete
this
.
button
;
let
widgetGroup
=
CustomizableUI
.
getWidget
(
this
.
BOOKMARK_BUTTON_ID
)
;
return
this
.
button
=
widgetGroup
.
forWindow
(
window
)
.
node
;
}
get
star
(
)
{
delete
this
.
star
;
return
this
.
star
=
document
.
getElementById
(
this
.
STAR_ID
)
;
}
get
starBox
(
)
{
delete
this
.
starBox
;
return
this
.
starBox
=
document
.
getElementById
(
this
.
STAR_BOX_ID
)
;
}
get
anchor
(
)
{
let
action
=
PageActions
.
actionForID
(
PageActions
.
ACTION_ID_BOOKMARK
)
;
return
BrowserPageActions
.
panelAnchorNodeForAction
(
action
)
;
}
get
broadcaster
(
)
{
delete
this
.
broadcaster
;
let
broadcaster
=
document
.
getElementById
(
"
bookmarkThisPageBroadcaster
"
)
;
return
this
.
broadcaster
=
broadcaster
;
}
STATUS_UPDATING
:
-
1
STATUS_UNSTARRED
:
0
STATUS_STARRED
:
1
get
status
(
)
{
if
(
this
.
_pendingUpdate
)
return
this
.
STATUS_UPDATING
;
return
this
.
broadcaster
.
hasAttribute
(
"
starred
"
)
?
this
.
STATUS_STARRED
:
this
.
STATUS_UNSTARRED
;
}
get
_starredTooltip
(
)
{
delete
this
.
_starredTooltip
;
return
this
.
_starredTooltip
=
this
.
_getFormattedTooltip
(
"
starButtonOn
.
tooltip2
"
)
;
}
get
_unstarredTooltip
(
)
{
delete
this
.
_unstarredTooltip
;
return
this
.
_unstarredTooltip
=
this
.
_getFormattedTooltip
(
"
starButtonOff
.
tooltip2
"
)
;
}
_getFormattedTooltip
(
strId
)
{
let
args
=
[
]
;
let
shortcut
=
document
.
getElementById
(
this
.
BOOKMARK_BUTTON_SHORTCUT
)
;
if
(
shortcut
)
args
.
push
(
ShortcutUtils
.
prettifyShortcut
(
shortcut
)
)
;
return
gNavigatorBundle
.
getFormattedString
(
strId
args
)
;
}
onPopupShowing
:
function
BUI_onPopupShowing
(
event
)
{
if
(
event
.
target
!
=
event
.
currentTarget
)
return
;
if
(
this
.
button
.
getAttribute
(
"
cui
-
areatype
"
)
=
=
CustomizableUI
.
TYPE_MENU_PANEL
|
|
this
.
button
.
hasAttribute
(
"
overflowedItem
"
)
)
{
this
.
_showSubView
(
)
;
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
return
;
}
let
widget
=
CustomizableUI
.
getWidget
(
this
.
BOOKMARK_BUTTON_ID
)
.
forWindow
(
window
)
;
if
(
widget
.
overflowed
)
{
event
.
preventDefault
(
)
;
widget
.
node
.
removeAttribute
(
"
closemenu
"
)
;
PlacesCommandHook
.
showPlacesOrganizer
(
"
BookmarksMenu
"
)
;
return
;
}
this
.
_initMobileBookmarks
(
document
.
getElementById
(
"
BMB_mobileBookmarks
"
)
)
;
this
.
selectLabel
(
"
BMB_viewBookmarksSidebar
"
SidebarUI
.
currentID
=
=
"
viewBookmarksSidebar
"
)
;
this
.
selectLabel
(
"
BMB_viewBookmarksToolbar
"
!
document
.
getElementById
(
"
PersonalToolbar
"
)
.
collapsed
)
;
}
selectLabel
(
elementId
visible
)
{
let
element
=
document
.
getElementById
(
elementId
)
;
element
.
setAttribute
(
"
label
"
element
.
getAttribute
(
visible
?
"
label
-
hide
"
:
"
label
-
show
"
)
)
;
}
toggleBookmarksToolbar
(
)
{
CustomizableUI
.
setToolbarVisibility
(
"
PersonalToolbar
"
document
.
getElementById
(
"
PersonalToolbar
"
)
.
collapsed
)
;
}
attachPlacesView
(
event
node
)
{
if
(
node
.
parentNode
.
_placesView
)
return
;
new
PlacesMenu
(
event
"
place
:
folder
=
BOOKMARKS_MENU
"
{
extraClasses
:
{
entry
:
"
subviewbutton
"
footer
:
"
panel
-
subview
-
footer
"
}
insertionPoint
:
"
.
panel
-
subview
-
footer
"
}
)
;
}
MOBILE_BOOKMARKS_PREF
:
"
browser
.
bookmarks
.
showMobileBookmarks
"
_shouldShowMobileBookmarks
(
)
{
return
Services
.
prefs
.
getBoolPref
(
this
.
MOBILE_BOOKMARKS_PREF
false
)
;
}
_initMobileBookmarks
(
mobileMenuItem
)
{
mobileMenuItem
.
hidden
=
!
this
.
_shouldShowMobileBookmarks
(
)
;
}
_uninitView
:
function
BUI__uninitView
(
)
{
if
(
this
.
button
.
_placesView
)
this
.
button
.
_placesView
.
uninit
(
)
;
let
menubar
=
document
.
getElementById
(
"
bookmarksMenu
"
)
;
if
(
menubar
&
&
menubar
.
_placesView
)
menubar
.
_placesView
.
uninit
(
)
;
const
kSpecialViewNodeIDs
=
[
"
BMB_bookmarksToolbar
"
"
BMB_unsortedBookmarks
"
]
;
for
(
let
viewNodeID
of
kSpecialViewNodeIDs
)
{
let
elem
=
document
.
getElementById
(
viewNodeID
)
;
if
(
elem
&
&
elem
.
_placesView
)
{
elem
.
_placesView
.
uninit
(
)
;
}
}
}
onCustomizeStart
:
function
BUI_customizeStart
(
aWindow
)
{
if
(
aWindow
=
=
window
)
{
this
.
_uninitView
(
)
;
this
.
_isCustomizing
=
true
;
}
}
onWidgetAdded
:
function
BUI_widgetAdded
(
aWidgetId
)
{
if
(
aWidgetId
=
=
this
.
BOOKMARK_BUTTON_ID
)
{
this
.
_onWidgetWasMoved
(
)
;
}
}
onWidgetRemoved
:
function
BUI_widgetRemoved
(
aWidgetId
)
{
if
(
aWidgetId
=
=
this
.
BOOKMARK_BUTTON_ID
)
{
this
.
_onWidgetWasMoved
(
)
;
}
}
onWidgetReset
:
function
BUI_widgetReset
(
aNode
aContainer
)
{
if
(
aNode
=
=
this
.
button
)
{
this
.
_onWidgetWasMoved
(
)
;
}
}
onWidgetUndoMove
:
function
BUI_undoWidgetUndoMove
(
aNode
aContainer
)
{
if
(
aNode
=
=
this
.
button
)
{
this
.
_onWidgetWasMoved
(
)
;
}
}
_onWidgetWasMoved
:
function
BUI_widgetWasMoved
(
)
{
if
(
!
this
.
_isCustomizing
)
{
this
.
_uninitView
(
)
;
}
}
onCustomizeEnd
:
function
BUI_customizeEnd
(
aWindow
)
{
if
(
aWindow
=
=
window
)
{
this
.
_isCustomizing
=
false
;
}
}
init
(
)
{
CustomizableUI
.
addListener
(
this
)
;
if
(
Services
.
prefs
.
getBoolPref
(
"
toolkit
.
cosmeticAnimations
.
enabled
"
)
)
{
let
starButtonBox
=
document
.
getElementById
(
"
star
-
button
-
box
"
)
;
starButtonBox
.
setAttribute
(
"
animationsenabled
"
"
true
"
)
;
this
.
star
.
addEventListener
(
"
mouseover
"
this
{
once
:
true
}
)
;
}
}
_hasBookmarksObserver
:
false
_itemGuids
:
new
Set
(
)
uninit
:
function
BUI_uninit
(
)
{
this
.
updateBookmarkPageMenuItem
(
true
)
;
CustomizableUI
.
removeListener
(
this
)
;
this
.
star
.
removeEventListener
(
"
mouseover
"
this
)
;
this
.
_uninitView
(
)
;
if
(
this
.
_hasBookmarksObserver
)
{
PlacesUtils
.
bookmarks
.
removeObserver
(
this
)
;
}
if
(
this
.
_pendingUpdate
)
{
delete
this
.
_pendingUpdate
;
}
}
onLocationChange
:
function
BUI_onLocationChange
(
)
{
if
(
this
.
_uri
&
&
gBrowser
.
currentURI
.
equals
(
this
.
_uri
)
)
{
return
;
}
this
.
updateStarState
(
)
;
}
updateStarState
:
function
BUI_updateStarState
(
)
{
this
.
_uri
=
gBrowser
.
currentURI
;
this
.
_itemGuids
.
clear
(
)
;
let
guids
=
new
Set
(
)
;
let
pendingUpdate
=
this
.
_pendingUpdate
=
{
}
;
PlacesUtils
.
bookmarks
.
fetch
(
{
url
:
this
.
_uri
}
b
=
>
guids
.
add
(
b
.
guid
)
{
concurrent
:
true
}
)
.
catch
(
Cu
.
reportError
)
.
then
(
(
)
=
>
{
if
(
pendingUpdate
!
=
this
.
_pendingUpdate
)
{
return
;
}
if
(
this
.
_itemGuids
.
size
>
0
)
{
this
.
_itemGuids
=
new
Set
(
.
.
.
this
.
_itemGuids
.
.
.
guids
)
;
}
else
{
this
.
_itemGuids
=
guids
;
}
this
.
_updateStar
(
)
;
if
(
!
this
.
_hasBookmarksObserver
)
{
try
{
PlacesUtils
.
bookmarks
.
addObserver
(
this
)
;
this
.
_hasBookmarksObserver
=
true
;
}
catch
(
ex
)
{
Cu
.
reportError
(
"
BookmarkingUI
failed
adding
a
bookmarks
observer
:
"
+
ex
)
;
}
}
delete
this
.
_pendingUpdate
;
}
)
;
}
_updateStar
:
function
BUI__updateStar
(
)
{
if
(
this
.
_itemGuids
.
size
>
0
)
{
this
.
broadcaster
.
setAttribute
(
"
starred
"
"
true
"
)
;
this
.
broadcaster
.
setAttribute
(
"
buttontooltiptext
"
this
.
_starredTooltip
)
;
this
.
broadcaster
.
setAttribute
(
"
tooltiptext
"
this
.
_starredTooltip
)
;
}
else
{
this
.
star
.
removeAttribute
(
"
animate
"
)
;
this
.
broadcaster
.
removeAttribute
(
"
starred
"
)
;
this
.
broadcaster
.
setAttribute
(
"
buttontooltiptext
"
this
.
_unstarredTooltip
)
;
this
.
broadcaster
.
setAttribute
(
"
tooltiptext
"
this
.
_unstarredTooltip
)
;
}
}
updateBookmarkPageMenuItem
:
function
BUI_updateBookmarkPageMenuItem
(
forceReset
)
{
let
isStarred
=
!
forceReset
&
&
this
.
_itemGuids
.
size
>
0
;
let
label
=
isStarred
?
"
editlabel
"
:
"
bookmarklabel
"
;
if
(
this
.
broadcaster
)
{
this
.
broadcaster
.
setAttribute
(
"
label
"
this
.
broadcaster
.
getAttribute
(
label
)
)
;
}
}
onMainMenuPopupShowing
:
function
BUI_onMainMenuPopupShowing
(
event
)
{
if
(
event
.
target
!
=
event
.
currentTarget
)
return
;
this
.
updateBookmarkPageMenuItem
(
)
;
PlacesCommandHook
.
updateBookmarkAllTabsCommand
(
)
;
this
.
_initMobileBookmarks
(
document
.
getElementById
(
"
menu_mobileBookmarks
"
)
)
;
}
showSubView
(
anchor
)
{
this
.
_showSubView
(
null
anchor
)
;
}
_showSubView
(
event
anchor
=
document
.
getElementById
(
this
.
BOOKMARK_BUTTON_ID
)
)
{
let
view
=
document
.
getElementById
(
"
PanelUI
-
bookmarks
"
)
;
view
.
addEventListener
(
"
ViewShowing
"
this
)
;
view
.
addEventListener
(
"
ViewHiding
"
this
)
;
anchor
.
setAttribute
(
"
closemenu
"
"
none
"
)
;
PanelUI
.
showSubView
(
"
PanelUI
-
bookmarks
"
anchor
event
)
;
}
onCommand
:
function
BUI_onCommand
(
aEvent
)
{
if
(
aEvent
.
target
!
=
aEvent
.
currentTarget
)
{
return
;
}
if
(
this
.
button
.
getAttribute
(
"
cui
-
areatype
"
)
=
=
CustomizableUI
.
TYPE_MENU_PANEL
)
{
this
.
_showSubView
(
aEvent
)
;
return
;
}
let
widget
=
CustomizableUI
.
getWidget
(
this
.
BOOKMARK_BUTTON_ID
)
.
forWindow
(
window
)
;
if
(
widget
.
overflowed
)
{
widget
.
node
.
removeAttribute
(
"
closemenu
"
)
;
}
this
.
onStarCommand
(
aEvent
)
;
}
onStarCommand
(
aEvent
)
{
if
(
!
this
.
_pendingUpdate
&
&
(
aEvent
.
type
!
=
"
click
"
|
|
aEvent
.
button
=
=
0
)
)
{
let
isBookmarked
=
this
.
_itemGuids
.
size
>
0
;
if
(
!
isBookmarked
)
{
BrowserUtils
.
setToolbarButtonHeightProperty
(
this
.
star
)
;
this
.
star
.
setAttribute
(
"
animate
"
"
true
"
)
;
}
PlacesCommandHook
.
bookmarkPage
(
gBrowser
.
selectedBrowser
true
)
;
}
}
onCurrentPageContextPopupShowing
(
)
{
this
.
updateBookmarkPageMenuItem
(
)
;
}
handleEvent
:
function
BUI_handleEvent
(
aEvent
)
{
switch
(
aEvent
.
type
)
{
case
"
mouseover
"
:
this
.
star
.
setAttribute
(
"
preloadanimations
"
"
true
"
)
;
break
;
case
"
ViewShowing
"
:
this
.
onPanelMenuViewShowing
(
aEvent
)
;
break
;
case
"
ViewHiding
"
:
this
.
onPanelMenuViewHiding
(
aEvent
)
;
break
;
}
}
onPanelMenuViewShowing
:
function
BUI_onViewShowing
(
aEvent
)
{
let
panelview
=
aEvent
.
target
;
this
.
updateBookmarkPageMenuItem
(
)
;
let
viewToolbar
=
document
.
getElementById
(
"
panelMenu_viewBookmarksToolbar
"
)
;
if
(
viewToolbar
)
{
let
personalToolbar
=
document
.
getElementById
(
"
PersonalToolbar
"
)
;
if
(
personalToolbar
.
collapsed
)
viewToolbar
.
removeAttribute
(
"
checked
"
)
;
else
viewToolbar
.
setAttribute
(
"
checked
"
"
true
"
)
;
}
let
staticButtons
=
panelview
.
getElementsByTagName
(
"
toolbarbutton
"
)
;
for
(
let
i
=
0
l
=
staticButtons
.
length
;
i
<
l
;
+
+
i
)
CustomizableUI
.
addShortcut
(
staticButtons
[
i
]
)
;
let
query
=
"
place
:
queryType
=
"
+
Ci
.
nsINavHistoryQueryOptions
.
QUERY_TYPE_BOOKMARKS
+
"
&
sort
=
"
+
Ci
.
nsINavHistoryQueryOptions
.
SORT_BY_DATEADDED_DESCENDING
+
"
&
maxResults
=
42
&
excludeQueries
=
1
"
;
this
.
_panelMenuView
=
new
PlacesPanelview
(
document
.
getElementById
(
"
panelMenu_bookmarksMenu
"
)
panelview
query
)
;
panelview
.
removeEventListener
(
"
ViewShowing
"
this
)
;
}
onPanelMenuViewHiding
:
function
BUI_onViewHiding
(
aEvent
)
{
this
.
_panelMenuView
.
uninit
(
)
;
delete
this
.
_panelMenuView
;
aEvent
.
target
.
removeEventListener
(
"
ViewHiding
"
this
)
;
}
showBookmarkingTools
(
triggerNode
)
{
let
placement
=
CustomizableUI
.
getPlacementOfWidget
(
this
.
BOOKMARK_BUTTON_ID
)
;
this
.
selectLabel
(
"
panelMenu_toggleBookmarksMenu
"
placement
&
&
placement
.
area
=
=
CustomizableUI
.
AREA_NAVBAR
)
;
this
.
selectLabel
(
"
panelMenu_viewBookmarksSidebar
"
SidebarUI
.
currentID
=
=
"
viewBookmarksSidebar
"
)
;
this
.
selectLabel
(
"
panelMenu_viewBookmarksToolbar
"
!
document
.
getElementById
(
"
PersonalToolbar
"
)
.
collapsed
)
;
PanelUI
.
showSubView
(
"
PanelUI
-
bookmarkingTools
"
triggerNode
)
;
}
toggleMenuButtonInToolbar
(
triggerNode
)
{
let
placement
=
CustomizableUI
.
getPlacementOfWidget
(
this
.
BOOKMARK_BUTTON_ID
)
;
const
area
=
CustomizableUI
.
AREA_NAVBAR
;
if
(
!
placement
)
{
let
pos
;
let
widgetIDs
=
CustomizableUI
.
getWidgetIdsInArea
(
CustomizableUI
.
AREA_NAVBAR
)
;
let
lastSpringID
=
null
;
for
(
let
i
=
widgetIDs
.
length
-
1
;
i
>
=
0
;
-
-
i
)
{
let
id
=
widgetIDs
[
i
]
;
if
(
CustomizableUI
.
isSpecialWidget
(
id
)
&
&
/
spring
/
.
test
(
id
)
)
{
lastSpringID
=
id
;
break
;
}
}
if
(
lastSpringID
)
{
pos
=
CustomizableUI
.
getPlacementOfWidget
(
lastSpringID
)
.
position
+
1
;
}
else
{
const
searchWidgetID
=
"
search
-
container
"
;
if
(
widgetIDs
.
includes
(
searchWidgetID
)
)
{
pos
=
CustomizableUI
.
getPlacementOfWidget
(
searchWidgetID
)
.
position
+
1
;
}
else
{
pos
=
CustomizableUI
.
getPlacementOfWidget
(
"
urlbar
-
container
"
)
.
position
+
1
;
}
}
CustomizableUI
.
addWidgetToArea
(
this
.
BOOKMARK_BUTTON_ID
area
pos
)
;
}
else
{
CustomizableUI
.
removeWidgetFromArea
(
this
.
BOOKMARK_BUTTON_ID
)
;
}
triggerNode
.
setAttribute
(
"
checked
"
!
placement
)
;
updateToggleControlLabel
(
triggerNode
)
;
}
onItemAdded
(
aItemId
aParentId
aIndex
aItemType
aURI
aTitle
aDateAdded
aGuid
)
{
if
(
aURI
&
&
aURI
.
equals
(
this
.
_uri
)
)
{
if
(
!
this
.
_itemGuids
.
has
(
aGuid
)
)
{
this
.
_itemGuids
.
add
(
aGuid
)
;
if
(
this
.
_itemGuids
.
size
=
=
1
)
{
this
.
_updateStar
(
)
;
}
}
}
}
onItemRemoved
(
aItemId
aParentId
aIndex
aItemType
aURI
aGuid
)
{
if
(
this
.
_itemGuids
.
has
(
aGuid
)
)
{
this
.
_itemGuids
.
delete
(
aGuid
)
;
if
(
this
.
_itemGuids
.
size
=
=
0
)
{
this
.
_updateStar
(
)
;
}
}
}
onItemChanged
(
aItemId
aProperty
aIsAnnotationProperty
aNewValue
aLastModified
aItemType
aParentId
aGuid
)
{
if
(
aProperty
=
=
"
uri
"
)
{
if
(
this
.
_itemGuids
.
has
(
aGuid
)
&
&
aNewValue
!
=
this
.
_uri
.
spec
)
{
this
.
_itemGuids
.
delete
(
aGuid
)
;
if
(
this
.
_itemGuids
.
size
=
=
0
)
{
this
.
_updateStar
(
)
;
}
}
else
if
(
!
this
.
_itemGuids
.
has
(
aGuid
)
&
&
aNewValue
=
=
this
.
_uri
.
spec
)
{
this
.
_itemGuids
.
add
(
aGuid
)
;
if
(
this
.
_itemGuids
.
size
=
=
1
)
{
this
.
_updateStar
(
)
;
}
}
}
}
onBeginUpdateBatch
(
)
{
}
onEndUpdateBatch
(
)
{
}
onBeforeItemRemoved
(
)
{
}
onItemVisited
(
)
{
}
onItemMoved
(
)
{
}
onWidgetUnderflow
(
aNode
aContainer
)
{
let
win
=
aNode
.
ownerGlobal
;
if
(
aNode
.
id
!
=
this
.
BOOKMARK_BUTTON_ID
|
|
win
!
=
window
)
return
;
this
.
_uninitView
(
)
;
}
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsINavBookmarkObserver
]
)
}
;
var
AutoShowBookmarksToolbar
=
{
init
(
)
{
Services
.
obs
.
addObserver
(
this
"
autoshow
-
bookmarks
-
toolbar
"
)
;
}
uninit
(
)
{
Services
.
obs
.
removeObserver
(
this
"
autoshow
-
bookmarks
-
toolbar
"
)
;
}
observe
(
subject
topic
data
)
{
let
toolbar
=
document
.
getElementById
(
"
PersonalToolbar
"
)
;
if
(
!
toolbar
.
collapsed
)
return
;
let
placement
=
CustomizableUI
.
getPlacementOfWidget
(
"
personal
-
bookmarks
"
)
;
let
area
=
placement
&
&
placement
.
area
;
if
(
area
!
=
CustomizableUI
.
AREA_BOOKMARKS
)
return
;
setToolbarVisibility
(
toolbar
true
)
;
}
}
;
