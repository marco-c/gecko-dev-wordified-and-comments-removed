var
StarUI
=
{
_itemId
:
-
1
uri
:
null
_batching
:
false
_isNewBookmark
:
false
_isComposing
:
false
_autoCloseTimer
:
0
_autoCloseTimerEnabled
:
true
_element
(
aID
)
{
return
document
.
getElementById
(
aID
)
;
}
get
panel
(
)
{
delete
this
.
panel
;
var
element
=
this
.
_element
(
"
editBookmarkPanel
"
)
;
element
.
hidden
=
false
;
element
.
addEventListener
(
"
keypress
"
this
)
;
element
.
addEventListener
(
"
mousedown
"
this
)
;
element
.
addEventListener
(
"
mouseout
"
this
)
;
element
.
addEventListener
(
"
mousemove
"
this
)
;
element
.
addEventListener
(
"
compositionstart
"
this
)
;
element
.
addEventListener
(
"
compositionend
"
this
)
;
element
.
addEventListener
(
"
input
"
this
)
;
element
.
addEventListener
(
"
popuphidden
"
this
)
;
element
.
addEventListener
(
"
popupshown
"
this
)
;
return
this
.
panel
=
element
;
}
get
_blockedCommands
(
)
{
delete
this
.
_blockedCommands
;
return
this
.
_blockedCommands
=
[
"
cmd_close
"
"
cmd_closeWindow
"
]
.
map
(
id
=
>
this
.
_element
(
id
)
)
;
}
_blockCommands
:
function
SU__blockCommands
(
)
{
this
.
_blockedCommands
.
forEach
(
function
(
elt
)
{
if
(
elt
.
hasAttribute
(
"
wasDisabled
"
)
)
return
;
if
(
elt
.
getAttribute
(
"
disabled
"
)
=
=
"
true
"
)
{
elt
.
setAttribute
(
"
wasDisabled
"
"
true
"
)
;
}
else
{
elt
.
setAttribute
(
"
wasDisabled
"
"
false
"
)
;
elt
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
}
)
;
}
_restoreCommandsState
:
function
SU__restoreCommandsState
(
)
{
this
.
_blockedCommands
.
forEach
(
function
(
elt
)
{
if
(
elt
.
getAttribute
(
"
wasDisabled
"
)
!
=
"
true
"
)
elt
.
removeAttribute
(
"
disabled
"
)
;
elt
.
removeAttribute
(
"
wasDisabled
"
)
;
}
)
;
}
handleEvent
(
aEvent
)
{
switch
(
aEvent
.
type
)
{
case
"
mousemove
"
:
clearTimeout
(
this
.
_autoCloseTimer
)
;
break
;
case
"
popuphidden
"
:
clearTimeout
(
this
.
_autoCloseTimer
)
;
if
(
aEvent
.
originalTarget
=
=
this
.
panel
)
{
if
(
!
this
.
_element
(
"
editBookmarkPanelContent
"
)
.
hidden
)
this
.
quitEditMode
(
)
;
if
(
this
.
_anchorToolbarButton
)
{
this
.
_anchorToolbarButton
.
removeAttribute
(
"
open
"
)
;
this
.
_anchorToolbarButton
=
null
;
}
this
.
_restoreCommandsState
(
)
;
this
.
_itemId
=
-
1
;
if
(
this
.
_batching
)
this
.
endBatch
(
)
;
if
(
this
.
_uriForRemoval
)
{
if
(
this
.
_isNewBookmark
)
{
if
(
!
PlacesUIUtils
.
useAsyncTransactions
)
{
PlacesUtils
.
transactionManager
.
undoTransaction
(
)
;
break
;
}
PlacesTransactions
.
undo
(
)
.
catch
(
Cu
.
reportError
)
;
break
;
}
if
(
!
PlacesUIUtils
.
useAsyncTransactions
)
{
let
itemIds
=
PlacesUtils
.
getBookmarksForURI
(
this
.
_uriForRemoval
)
;
for
(
let
itemId
of
itemIds
)
{
let
txn
=
new
PlacesRemoveItemTransaction
(
itemId
)
;
PlacesUtils
.
transactionManager
.
doTransaction
(
txn
)
;
}
break
;
}
PlacesTransactions
.
RemoveBookmarksForUrls
(
[
this
.
_uriForRemoval
]
)
.
transact
(
)
.
catch
(
Cu
.
reportError
)
;
}
}
break
;
case
"
keypress
"
:
clearTimeout
(
this
.
_autoCloseTimer
)
;
this
.
_autoCloseTimerEnabled
=
false
;
if
(
aEvent
.
defaultPrevented
)
{
break
;
}
switch
(
aEvent
.
keyCode
)
{
case
KeyEvent
.
DOM_VK_ESCAPE
:
this
.
panel
.
hidePopup
(
)
;
break
;
case
KeyEvent
.
DOM_VK_RETURN
:
if
(
aEvent
.
target
.
classList
.
contains
(
"
expander
-
up
"
)
|
|
aEvent
.
target
.
classList
.
contains
(
"
expander
-
down
"
)
|
|
aEvent
.
target
.
id
=
=
"
editBMPanel_newFolderButton
"
|
|
aEvent
.
target
.
id
=
=
"
editBookmarkPanelRemoveButton
"
)
{
break
;
}
this
.
panel
.
hidePopup
(
)
;
break
;
case
0
:
let
accessKey
=
document
.
getElementById
(
"
key_close
"
)
;
if
(
eventMatchesKey
(
aEvent
accessKey
)
)
{
this
.
panel
.
hidePopup
(
)
;
}
break
;
}
break
;
case
"
compositionend
"
:
this
.
_isComposing
=
false
;
break
;
case
"
compositionstart
"
:
if
(
aEvent
.
defaultPrevented
)
{
break
;
}
this
.
_isComposing
=
true
;
case
"
input
"
:
case
"
mousedown
"
:
clearTimeout
(
this
.
_autoCloseTimer
)
;
this
.
_autoCloseTimerEnabled
=
false
;
break
;
case
"
mouseout
"
:
if
(
!
this
.
_autoCloseTimerEnabled
)
{
break
;
}
case
"
popupshown
"
:
if
(
aEvent
.
target
!
=
aEvent
.
currentTarget
)
{
break
;
}
if
(
this
.
_isNewBookmark
&
&
!
this
.
_isComposing
)
{
let
delay
=
3500
;
if
(
this
.
_closePanelQuickForTesting
)
{
delay
/
=
10
;
}
clearTimeout
(
this
.
_autoCloseTimer
)
;
this
.
_autoCloseTimer
=
setTimeout
(
(
)
=
>
{
if
(
!
this
.
panel
.
mozMatchesSelector
(
"
:
hover
"
)
)
{
this
.
panel
.
hidePopup
(
)
;
}
}
delay
)
;
this
.
_autoCloseTimerEnabled
=
true
;
}
break
;
}
}
_overlayLoaded
:
false
_overlayLoading
:
false
async
showEditBookmarkPopup
(
aNode
aAnchorElement
aPosition
aIsNewBookmark
)
{
if
(
this
.
panel
.
state
=
=
"
showing
"
|
|
this
.
panel
.
state
=
=
"
open
"
)
{
return
;
}
this
.
_isNewBookmark
=
aIsNewBookmark
;
this
.
_uriForRemoval
=
"
"
;
if
(
typeof
(
aNode
)
=
=
"
number
"
)
{
let
itemId
=
aNode
;
let
guid
=
await
PlacesUtils
.
promiseItemGuid
(
itemId
)
;
aNode
=
await
PlacesUIUtils
.
fetchNodeLike
(
guid
)
;
}
if
(
this
.
_overlayLoading
)
return
;
if
(
this
.
_overlayLoaded
)
{
this
.
_doShowEditBookmarkPanel
(
aNode
aAnchorElement
aPosition
)
;
return
;
}
this
.
_overlayLoading
=
true
;
document
.
loadOverlay
(
"
chrome
:
/
/
browser
/
content
/
places
/
editBookmarkOverlay
.
xul
"
(
aSubject
aTopic
aData
)
=
>
{
let
header
=
this
.
_element
(
"
editBookmarkPanelHeader
"
)
;
let
rows
=
this
.
_element
(
"
editBookmarkPanelGrid
"
)
.
lastChild
;
rows
.
insertBefore
(
header
rows
.
firstChild
)
;
header
.
hidden
=
false
;
this
.
_overlayLoading
=
false
;
this
.
_overlayLoaded
=
true
;
this
.
_doShowEditBookmarkPanel
(
aNode
aAnchorElement
aPosition
)
;
}
)
;
}
_doShowEditBookmarkPanel
(
aNode
aAnchorElement
aPosition
)
{
if
(
this
.
panel
.
state
!
=
"
closed
"
)
return
;
this
.
_blockCommands
(
)
;
this
.
_element
(
"
editBookmarkPanelTitle
"
)
.
value
=
this
.
_isNewBookmark
?
gNavigatorBundle
.
getString
(
"
editBookmarkPanel
.
pageBookmarkedTitle
"
)
:
gNavigatorBundle
.
getString
(
"
editBookmarkPanel
.
editBookmarkTitle
"
)
;
this
.
_element
(
"
editBookmarkPanelDescription
"
)
.
textContent
=
"
"
;
this
.
_element
(
"
editBookmarkPanelBottomButtons
"
)
.
hidden
=
false
;
this
.
_element
(
"
editBookmarkPanelContent
"
)
.
hidden
=
false
;
let
bookmarks
=
PlacesUtils
.
getBookmarksForURI
(
gBrowser
.
currentURI
)
;
let
forms
=
gNavigatorBundle
.
getString
(
"
editBookmark
.
removeBookmarks
.
label
"
)
;
let
label
=
PluralForm
.
get
(
bookmarks
.
length
forms
)
.
replace
(
"
#
1
"
bookmarks
.
length
)
;
this
.
_element
(
"
editBookmarkPanelRemoveButton
"
)
.
label
=
label
;
this
.
_element
(
"
editBookmarkPanelStarIcon
"
)
.
removeAttribute
(
"
unstarred
"
)
;
this
.
_itemId
=
aNode
.
itemId
;
this
.
beginBatch
(
)
;
if
(
aAnchorElement
)
{
let
parent
=
aAnchorElement
.
parentNode
;
while
(
parent
)
{
if
(
parent
.
localName
=
=
"
toolbarbutton
"
)
{
break
;
}
parent
=
parent
.
parentNode
;
}
if
(
parent
)
{
this
.
_anchorToolbarButton
=
parent
;
parent
.
setAttribute
(
"
open
"
"
true
"
)
;
}
}
let
onPanelReady
=
fn
=
>
{
let
target
=
this
.
panel
;
if
(
target
.
parentNode
)
{
target
=
target
.
parentNode
;
}
target
.
addEventListener
(
"
popupshown
"
function
(
event
)
{
fn
(
)
;
}
{
"
capture
"
:
true
"
once
"
:
true
}
)
;
}
;
gEditItemOverlay
.
initPanel
(
{
node
:
aNode
onPanelReady
hiddenRows
:
[
"
description
"
"
location
"
"
loadInSidebar
"
"
keyword
"
]
focusedElement
:
"
preferred
"
}
)
;
this
.
panel
.
openPopup
(
aAnchorElement
aPosition
)
;
}
panelShown
:
function
SU_panelShown
(
aEvent
)
{
if
(
aEvent
.
target
=
=
this
.
panel
)
{
if
(
this
.
_element
(
"
editBookmarkPanelContent
"
)
.
hidden
)
{
this
.
panel
.
focus
(
)
;
}
}
}
quitEditMode
:
function
SU_quitEditMode
(
)
{
this
.
_element
(
"
editBookmarkPanelContent
"
)
.
hidden
=
true
;
this
.
_element
(
"
editBookmarkPanelBottomButtons
"
)
.
hidden
=
true
;
gEditItemOverlay
.
uninitPanel
(
true
)
;
}
removeBookmarkButtonCommand
:
function
SU_removeBookmarkButtonCommand
(
)
{
this
.
_uriForRemoval
=
PlacesUtils
.
bookmarks
.
getBookmarkURI
(
this
.
_itemId
)
;
this
.
panel
.
hidePopup
(
)
;
}
_batchBlockingDeferred
:
null
beginBatch
(
)
{
if
(
this
.
_batching
)
return
;
if
(
PlacesUIUtils
.
useAsyncTransactions
)
{
this
.
_batchBlockingDeferred
=
PromiseUtils
.
defer
(
)
;
PlacesTransactions
.
batch
(
async
(
)
=
>
{
await
this
.
_batchBlockingDeferred
.
promise
;
}
)
;
}
else
{
PlacesUtils
.
transactionManager
.
beginBatch
(
null
)
;
}
this
.
_batching
=
true
;
}
endBatch
(
)
{
if
(
!
this
.
_batching
)
return
;
if
(
PlacesUIUtils
.
useAsyncTransactions
)
{
this
.
_batchBlockingDeferred
.
resolve
(
)
;
this
.
_batchBlockingDeferred
=
null
;
}
else
{
PlacesUtils
.
transactionManager
.
endBatch
(
false
)
;
}
this
.
_batching
=
false
;
}
}
;
function
isVisible
(
element
)
{
let
windowUtils
=
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
let
bounds
=
windowUtils
.
getBoundsWithoutFlushing
(
element
)
;
return
bounds
.
height
>
0
&
&
bounds
.
width
>
0
;
}
var
PlacesCommandHook
=
{
async
bookmarkPage
(
aBrowser
aParent
aShowEditUI
)
{
if
(
PlacesUIUtils
.
useAsyncTransactions
)
{
await
this
.
_bookmarkPagePT
(
aBrowser
aParent
aShowEditUI
)
;
return
;
}
var
uri
=
aBrowser
.
currentURI
;
var
itemId
=
PlacesUtils
.
getMostRecentBookmarkForURI
(
uri
)
;
let
isNewBookmark
=
itemId
=
=
-
1
;
if
(
isNewBookmark
)
{
var
title
;
var
description
;
var
charset
;
let
docInfo
=
await
this
.
_getPageDetails
(
aBrowser
)
;
try
{
title
=
docInfo
.
isErrorPage
?
PlacesUtils
.
history
.
getPageTitle
(
uri
)
:
aBrowser
.
contentTitle
;
title
=
title
|
|
uri
.
spec
;
description
=
docInfo
.
description
;
charset
=
aBrowser
.
characterSet
;
}
catch
(
e
)
{
}
if
(
aShowEditUI
)
{
StarUI
.
beginBatch
(
)
;
}
var
parent
=
aParent
!
=
=
undefined
?
aParent
:
PlacesUtils
.
unfiledBookmarksFolderId
;
var
descAnno
=
{
name
:
PlacesUIUtils
.
DESCRIPTION_ANNO
value
:
description
}
;
var
txn
=
new
PlacesCreateBookmarkTransaction
(
uri
parent
PlacesUtils
.
bookmarks
.
DEFAULT_INDEX
title
null
[
descAnno
]
)
;
PlacesUtils
.
transactionManager
.
doTransaction
(
txn
)
;
itemId
=
txn
.
item
.
id
;
if
(
charset
&
&
!
PrivateBrowsingUtils
.
isBrowserPrivate
(
aBrowser
)
)
PlacesUtils
.
setCharsetForURI
(
uri
charset
)
;
}
gURLBar
.
handleRevert
(
)
;
if
(
!
aShowEditUI
)
return
;
if
(
BookmarkingUI
.
anchor
&
&
isVisible
(
BookmarkingUI
.
anchor
)
)
{
await
StarUI
.
showEditBookmarkPopup
(
itemId
BookmarkingUI
.
anchor
"
bottomcenter
topright
"
isNewBookmark
)
;
return
;
}
let
identityIcon
=
document
.
getElementById
(
"
identity
-
icon
"
)
;
if
(
isVisible
(
identityIcon
)
)
{
await
StarUI
.
showEditBookmarkPopup
(
itemId
identityIcon
"
bottomcenter
topright
"
isNewBookmark
)
;
}
else
{
await
StarUI
.
showEditBookmarkPopup
(
itemId
aBrowser
"
overlap
"
isNewBookmark
)
;
}
}
async
_bookmarkPagePT
(
aBrowser
aParentId
aShowEditUI
)
{
let
url
=
new
URL
(
aBrowser
.
currentURI
.
spec
)
;
let
info
=
await
PlacesUtils
.
bookmarks
.
fetch
(
{
url
}
)
;
let
isNewBookmark
=
!
info
;
if
(
!
info
)
{
let
parentGuid
=
aParentId
!
=
=
undefined
?
await
PlacesUtils
.
promiseItemGuid
(
aParentId
)
:
PlacesUtils
.
bookmarks
.
unfiledGuid
;
info
=
{
url
parentGuid
}
;
let
description
=
null
;
let
charset
=
null
;
let
docInfo
=
await
this
.
_getPageDetails
(
aBrowser
)
;
try
{
if
(
docInfo
.
isErrorPage
)
{
let
entry
=
await
PlacesUtils
.
history
.
fetch
(
aBrowser
.
currentURI
)
;
if
(
entry
)
{
info
.
title
=
entry
.
title
;
}
}
else
{
info
.
title
=
aBrowser
.
contentTitle
;
}
info
.
title
=
info
.
title
|
|
url
.
href
;
description
=
docInfo
.
description
;
charset
=
aBrowser
.
characterSet
;
}
catch
(
e
)
{
Components
.
utils
.
reportError
(
e
)
;
}
if
(
aShowEditUI
&
&
isNewBookmark
)
{
StarUI
.
beginBatch
(
)
;
}
if
(
description
)
{
info
.
annotations
=
[
{
name
:
PlacesUIUtils
.
DESCRIPTION_ANNO
value
:
description
}
]
;
}
info
.
guid
=
await
PlacesTransactions
.
NewBookmark
(
info
)
.
transact
(
)
;
if
(
charset
&
&
!
PrivateBrowsingUtils
.
isBrowserPrivate
(
aBrowser
)
)
PlacesUtils
.
setCharsetForURI
(
makeURI
(
url
.
href
)
charset
)
;
}
gURLBar
.
handleRevert
(
)
;
if
(
!
aShowEditUI
)
return
;
let
node
=
await
PlacesUIUtils
.
promiseNodeLikeFromFetchInfo
(
info
)
;
if
(
BookmarkingUI
.
anchor
&
&
isVisible
(
BookmarkingUI
.
anchor
)
)
{
await
StarUI
.
showEditBookmarkPopup
(
node
BookmarkingUI
.
anchor
"
bottomcenter
topright
"
isNewBookmark
)
;
return
;
}
let
identityIcon
=
document
.
getElementById
(
"
identity
-
icon
"
)
;
if
(
isVisible
(
identityIcon
)
)
{
await
StarUI
.
showEditBookmarkPopup
(
node
identityIcon
"
bottomcenter
topright
"
isNewBookmark
)
;
}
else
{
await
StarUI
.
showEditBookmarkPopup
(
node
aBrowser
"
overlap
"
isNewBookmark
)
;
}
}
_getPageDetails
(
browser
)
{
return
new
Promise
(
resolve
=
>
{
let
mm
=
browser
.
messageManager
;
mm
.
addMessageListener
(
"
Bookmarks
:
GetPageDetails
:
Result
"
function
listener
(
msg
)
{
mm
.
removeMessageListener
(
"
Bookmarks
:
GetPageDetails
:
Result
"
listener
)
;
resolve
(
msg
.
data
)
;
}
)
;
mm
.
sendAsyncMessage
(
"
Bookmarks
:
GetPageDetails
"
{
}
)
}
)
;
}
bookmarkCurrentPage
:
function
PCH_bookmarkCurrentPage
(
aShowEditUI
aParent
)
{
this
.
bookmarkPage
(
gBrowser
.
selectedBrowser
aParent
aShowEditUI
)
.
catch
(
Components
.
utils
.
reportError
)
;
}
async
bookmarkLink
(
aParentId
aURL
aTitle
aDescription
=
"
"
)
{
let
node
=
await
PlacesUIUtils
.
fetchNodeLike
(
{
url
:
aURL
}
)
;
if
(
node
)
{
PlacesUIUtils
.
showBookmarkDialog
(
{
action
:
"
edit
"
node
}
window
.
top
)
;
return
;
}
let
ip
=
new
InsertionPoint
(
aParentId
PlacesUtils
.
bookmarks
.
DEFAULT_INDEX
Components
.
interfaces
.
nsITreeView
.
DROP_ON
)
;
PlacesUIUtils
.
showBookmarkDialog
(
{
action
:
"
add
"
type
:
"
bookmark
"
uri
:
makeURI
(
aURL
)
title
:
aTitle
description
:
aDescription
defaultInsertionPoint
:
ip
hiddenRows
:
[
"
description
"
"
location
"
"
loadInSidebar
"
"
keyword
"
]
}
window
.
top
)
;
}
get
uniqueCurrentPages
(
)
{
let
uniquePages
=
{
}
;
let
URIs
=
[
]
;
gBrowser
.
visibleTabs
.
forEach
(
tab
=
>
{
let
browser
=
tab
.
linkedBrowser
;
let
uri
=
browser
.
currentURI
;
let
title
=
browser
.
contentTitle
|
|
tab
.
label
;
let
spec
=
uri
.
spec
;
if
(
!
tab
.
pinned
&
&
!
(
spec
in
uniquePages
)
)
{
uniquePages
[
spec
]
=
null
;
URIs
.
push
(
{
uri
title
}
)
;
}
}
)
;
return
URIs
;
}
bookmarkCurrentPages
:
function
PCH_bookmarkCurrentPages
(
)
{
let
pages
=
this
.
uniqueCurrentPages
;
if
(
pages
.
length
>
1
)
{
PlacesUIUtils
.
showBookmarkDialog
(
{
action
:
"
add
"
type
:
"
folder
"
URIList
:
pages
hiddenRows
:
[
"
description
"
]
}
window
)
;
}
}
updateBookmarkAllTabsCommand
:
function
PCH_updateBookmarkAllTabsCommand
(
)
{
if
(
window
.
location
.
href
!
=
getBrowserURL
(
)
)
return
;
goSetCommandEnabled
(
"
Browser
:
BookmarkAllTabs
"
this
.
uniqueCurrentPages
.
length
>
=
2
)
;
}
async
addLiveBookmark
(
url
feedTitle
feedSubtitle
)
{
let
toolbarIP
=
new
InsertionPoint
(
PlacesUtils
.
toolbarFolderId
PlacesUtils
.
bookmarks
.
DEFAULT_INDEX
Components
.
interfaces
.
nsITreeView
.
DROP_ON
)
;
let
feedURI
=
makeURI
(
url
)
;
let
title
=
feedTitle
|
|
gBrowser
.
contentTitle
;
let
description
=
feedSubtitle
;
if
(
!
description
)
{
description
=
(
await
this
.
_getPageDetails
(
gBrowser
.
selectedBrowser
)
)
.
description
;
}
PlacesUIUtils
.
showBookmarkDialog
(
{
action
:
"
add
"
type
:
"
livemark
"
feedURI
siteURI
:
gBrowser
.
currentURI
title
description
defaultInsertionPoint
:
toolbarIP
hiddenRows
:
[
"
feedLocation
"
"
siteLocation
"
"
description
"
]
}
window
)
;
}
showPlacesOrganizer
:
function
PCH_showPlacesOrganizer
(
aLeftPaneRoot
)
{
var
organizer
=
Services
.
wm
.
getMostRecentWindow
(
"
Places
:
Organizer
"
)
;
if
(
!
organizer
|
|
organizer
.
closed
)
{
openDialog
(
"
chrome
:
/
/
browser
/
content
/
places
/
places
.
xul
"
"
"
"
chrome
toolbar
=
yes
dialog
=
no
resizable
"
aLeftPaneRoot
)
;
}
else
{
organizer
.
PlacesOrganizer
.
selectLeftPaneContainerByHierarchy
(
aLeftPaneRoot
)
;
organizer
.
focus
(
)
;
}
}
searchBookmarks
(
)
{
if
(
!
focusAndSelectUrlBar
(
)
)
{
return
;
}
for
(
let
char
of
[
"
*
"
"
"
]
)
{
let
code
=
char
.
charCodeAt
(
0
)
;
gURLBar
.
inputField
.
dispatchEvent
(
new
KeyboardEvent
(
"
keypress
"
{
keyCode
:
code
charCode
:
code
bubbles
:
true
}
)
)
;
}
}
}
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
RecentlyClosedTabsAndWindowsMenuUtils
"
"
resource
:
/
/
/
modules
/
sessionstore
/
RecentlyClosedTabsAndWindowsMenuUtils
.
jsm
"
)
;
function
HistoryMenu
(
aPopupShowingEvent
)
{
this
.
__proto__
.
__proto__
=
PlacesMenu
.
prototype
;
PlacesMenu
.
call
(
this
aPopupShowingEvent
"
place
:
sort
=
4
&
maxResults
=
15
"
)
;
}
HistoryMenu
.
prototype
=
{
_getClosedTabCount
(
)
{
if
(
window
=
=
Services
.
appShell
.
hiddenDOMWindow
)
{
return
0
;
}
return
SessionStore
.
getClosedTabCount
(
window
)
;
}
toggleRecentlyClosedTabs
:
function
HM_toggleRecentlyClosedTabs
(
)
{
var
undoMenu
=
this
.
_rootElt
.
getElementsByClassName
(
"
recentlyClosedTabsMenu
"
)
[
0
]
;
if
(
this
.
_getClosedTabCount
(
)
=
=
0
)
undoMenu
.
setAttribute
(
"
disabled
"
true
)
;
else
undoMenu
.
removeAttribute
(
"
disabled
"
)
;
}
populateUndoSubmenu
:
function
PHM_populateUndoSubmenu
(
)
{
var
undoMenu
=
this
.
_rootElt
.
getElementsByClassName
(
"
recentlyClosedTabsMenu
"
)
[
0
]
;
var
undoPopup
=
undoMenu
.
firstChild
;
while
(
undoPopup
.
hasChildNodes
(
)
)
undoPopup
.
firstChild
.
remove
(
)
;
if
(
this
.
_getClosedTabCount
(
)
=
=
0
)
{
undoMenu
.
setAttribute
(
"
disabled
"
true
)
;
return
;
}
undoMenu
.
removeAttribute
(
"
disabled
"
)
;
let
tabsFragment
=
RecentlyClosedTabsAndWindowsMenuUtils
.
getTabsFragment
(
window
"
menuitem
"
)
;
undoPopup
.
appendChild
(
tabsFragment
)
;
}
toggleRecentlyClosedWindows
:
function
PHM_toggleRecentlyClosedWindows
(
)
{
var
undoMenu
=
this
.
_rootElt
.
getElementsByClassName
(
"
recentlyClosedWindowsMenu
"
)
[
0
]
;
if
(
SessionStore
.
getClosedWindowCount
(
)
=
=
0
)
undoMenu
.
setAttribute
(
"
disabled
"
true
)
;
else
undoMenu
.
removeAttribute
(
"
disabled
"
)
;
}
populateUndoWindowSubmenu
:
function
PHM_populateUndoWindowSubmenu
(
)
{
let
undoMenu
=
this
.
_rootElt
.
getElementsByClassName
(
"
recentlyClosedWindowsMenu
"
)
[
0
]
;
let
undoPopup
=
undoMenu
.
firstChild
;
while
(
undoPopup
.
hasChildNodes
(
)
)
undoPopup
.
firstChild
.
remove
(
)
;
if
(
SessionStore
.
getClosedWindowCount
(
)
=
=
0
)
{
undoMenu
.
setAttribute
(
"
disabled
"
true
)
;
return
;
}
undoMenu
.
removeAttribute
(
"
disabled
"
)
;
let
windowsFragment
=
RecentlyClosedTabsAndWindowsMenuUtils
.
getWindowsFragment
(
window
"
menuitem
"
)
;
undoPopup
.
appendChild
(
windowsFragment
)
;
}
toggleTabsFromOtherComputers
:
function
PHM_toggleTabsFromOtherComputers
(
)
{
let
menuitem
=
this
.
_rootElt
.
getElementsByClassName
(
"
syncTabsMenuItem
"
)
[
0
]
;
if
(
!
menuitem
)
return
;
if
(
!
PlacesUIUtils
.
shouldShowTabsFromOtherComputersMenuitem
(
)
)
{
menuitem
.
setAttribute
(
"
hidden
"
true
)
;
return
;
}
menuitem
.
setAttribute
(
"
hidden
"
false
)
;
}
_onPopupShowing
:
function
HM__onPopupShowing
(
aEvent
)
{
PlacesMenu
.
prototype
.
_onPopupShowing
.
apply
(
this
arguments
)
;
if
(
aEvent
.
target
!
=
aEvent
.
currentTarget
)
return
;
this
.
toggleRecentlyClosedTabs
(
)
;
this
.
toggleRecentlyClosedWindows
(
)
;
this
.
toggleTabsFromOtherComputers
(
)
;
}
_onCommand
:
function
HM__onCommand
(
aEvent
)
{
let
placesNode
=
aEvent
.
target
.
_placesNode
;
if
(
placesNode
)
{
if
(
!
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
PlacesUIUtils
.
markPageAsTyped
(
placesNode
.
uri
)
;
openUILink
(
placesNode
.
uri
aEvent
{
ignoreAlt
:
true
}
)
;
}
}
}
;
var
BookmarksEventHandler
=
{
onClick
:
function
BEH_onClick
(
aEvent
aView
)
{
let
modifKey
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
modifKey
=
aEvent
.
metaKey
|
|
aEvent
.
shiftKey
;
}
else
{
modifKey
=
aEvent
.
ctrlKey
|
|
aEvent
.
shiftKey
;
}
if
(
aEvent
.
button
=
=
2
|
|
(
aEvent
.
button
=
=
0
&
&
!
modifKey
)
)
return
;
var
target
=
aEvent
.
originalTarget
;
if
(
target
.
localName
=
=
"
menu
"
|
|
target
.
localName
=
=
"
menuitem
"
)
{
for
(
let
node
=
target
.
parentNode
;
node
;
node
=
node
.
parentNode
)
{
if
(
node
.
localName
=
=
"
menupopup
"
)
node
.
hidePopup
(
)
;
else
if
(
node
.
localName
!
=
"
menu
"
&
&
node
.
localName
!
=
"
hbox
"
&
&
node
.
localName
!
=
"
vbox
"
)
break
;
}
}
if
(
target
.
_placesNode
&
&
PlacesUtils
.
nodeIsContainer
(
target
.
_placesNode
)
)
{
if
(
target
.
localName
=
=
"
menu
"
|
|
target
.
localName
=
=
"
toolbarbutton
"
)
PlacesUIUtils
.
openContainerNodeInTabs
(
target
.
_placesNode
aEvent
aView
)
;
}
else
if
(
aEvent
.
button
=
=
1
)
{
this
.
onCommand
(
aEvent
)
;
}
}
onCommand
:
function
BEH_onCommand
(
aEvent
)
{
var
target
=
aEvent
.
originalTarget
;
if
(
target
.
_placesNode
)
PlacesUIUtils
.
openNodeWithEvent
(
target
.
_placesNode
aEvent
)
;
}
fillInBHTooltip
:
function
BEH_fillInBHTooltip
(
aDocument
aEvent
)
{
var
node
;
var
cropped
=
false
;
var
targetURI
;
if
(
aDocument
.
tooltipNode
.
localName
=
=
"
treechildren
"
)
{
var
tree
=
aDocument
.
tooltipNode
.
parentNode
;
var
tbo
=
tree
.
treeBoxObject
;
var
cell
=
tbo
.
getCellAt
(
aEvent
.
clientX
aEvent
.
clientY
)
;
if
(
cell
.
row
=
=
-
1
)
return
false
;
node
=
tree
.
view
.
nodeForTreeIndex
(
cell
.
row
)
;
cropped
=
tbo
.
isCellCropped
(
cell
.
row
cell
.
col
)
;
}
else
{
var
tooltipNode
=
aDocument
.
tooltipNode
;
if
(
tooltipNode
.
_placesNode
)
node
=
tooltipNode
.
_placesNode
;
else
{
targetURI
=
tooltipNode
.
getAttribute
(
"
targetURI
"
)
;
}
}
if
(
!
node
&
&
!
targetURI
)
return
false
;
var
title
=
node
?
node
.
title
:
tooltipNode
.
label
;
var
url
;
if
(
targetURI
|
|
PlacesUtils
.
nodeIsURI
(
node
)
)
url
=
targetURI
|
|
node
.
uri
;
if
(
!
cropped
&
&
!
url
)
return
false
;
var
tooltipTitle
=
aDocument
.
getElementById
(
"
bhtTitleText
"
)
;
tooltipTitle
.
hidden
=
(
!
title
|
|
(
title
=
=
url
)
)
;
if
(
!
tooltipTitle
.
hidden
)
tooltipTitle
.
textContent
=
title
;
var
tooltipUrl
=
aDocument
.
getElementById
(
"
bhtUrlText
"
)
;
tooltipUrl
.
hidden
=
!
url
;
if
(
!
tooltipUrl
.
hidden
)
tooltipUrl
.
value
=
url
;
return
true
;
}
}
;
var
PlacesMenuDNDHandler
=
{
_springLoadDelayMs
:
350
_closeDelayMs
:
500
_loadTimer
:
null
_closeTimer
:
null
_closingTimerNode
:
null
onDragEnter
:
function
PMDH_onDragEnter
(
event
)
{
if
(
!
this
.
_isStaticContainer
(
event
.
target
)
)
return
;
if
(
this
.
_closeTimer
&
&
this
.
_closingTimerNode
=
=
=
event
.
currentTarget
)
{
this
.
_closeTimer
.
cancel
(
)
;
this
.
_closingTimerNode
=
null
;
this
.
_closeTimer
=
null
;
}
PlacesControllerDragHelper
.
currentDropTarget
=
event
.
target
;
let
popup
=
event
.
target
.
lastChild
;
if
(
this
.
_loadTimer
|
|
popup
.
state
=
=
=
"
showing
"
|
|
popup
.
state
=
=
=
"
open
"
)
return
;
this
.
_loadTimer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
this
.
_loadTimer
.
initWithCallback
(
(
)
=
>
{
this
.
_loadTimer
=
null
;
popup
.
setAttribute
(
"
autoopened
"
"
true
"
)
;
popup
.
showPopup
(
popup
)
;
}
this
.
_springLoadDelayMs
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
}
onDragLeave
:
function
PMDH_onDragLeave
(
event
)
{
if
(
event
.
relatedTarget
=
=
=
event
.
currentTarget
|
|
(
event
.
relatedTarget
&
&
event
.
relatedTarget
.
parentNode
=
=
=
event
.
currentTarget
)
)
return
;
if
(
!
this
.
_isStaticContainer
(
event
.
target
)
)
return
;
PlacesControllerDragHelper
.
currentDropTarget
=
null
;
let
popup
=
event
.
target
.
lastChild
;
if
(
this
.
_loadTimer
)
{
this
.
_loadTimer
.
cancel
(
)
;
this
.
_loadTimer
=
null
;
}
this
.
_closeTimer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
this
.
_closingTimerNode
=
event
.
currentTarget
;
this
.
_closeTimer
.
initWithCallback
(
function
(
)
{
this
.
_closeTimer
=
null
;
this
.
_closingTimerNode
=
null
;
let
node
=
PlacesControllerDragHelper
.
currentDropTarget
;
let
inHierarchy
=
false
;
while
(
node
&
&
!
inHierarchy
)
{
inHierarchy
=
node
=
=
event
.
target
;
node
=
node
.
parentNode
;
}
if
(
!
inHierarchy
&
&
popup
&
&
popup
.
hasAttribute
(
"
autoopened
"
)
)
{
popup
.
removeAttribute
(
"
autoopened
"
)
;
popup
.
hidePopup
(
)
;
}
}
this
.
_closeDelayMs
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
_isStaticContainer
:
function
PMDH__isContainer
(
node
)
{
let
isMenu
=
node
.
localName
=
=
"
menu
"
|
|
(
node
.
localName
=
=
"
toolbarbutton
"
&
&
(
node
.
getAttribute
(
"
type
"
)
=
=
"
menu
"
|
|
node
.
getAttribute
(
"
type
"
)
=
=
"
menu
-
button
"
)
)
;
let
isStatic
=
!
(
"
_placesNode
"
in
node
)
&
&
node
.
lastChild
&
&
node
.
lastChild
.
hasAttribute
(
"
placespopup
"
)
&
&
!
node
.
parentNode
.
hasAttribute
(
"
placespopup
"
)
;
return
isMenu
&
&
isStatic
;
}
onDragOver
:
function
PMDH_onDragOver
(
event
)
{
let
ip
=
new
InsertionPoint
(
PlacesUtils
.
bookmarksMenuFolderId
PlacesUtils
.
bookmarks
.
DEFAULT_INDEX
Components
.
interfaces
.
nsITreeView
.
DROP_ON
)
;
if
(
ip
&
&
PlacesControllerDragHelper
.
canDrop
(
ip
event
.
dataTransfer
)
)
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
}
onDrop
:
function
PMDH_onDrop
(
event
)
{
let
ip
=
new
InsertionPoint
(
PlacesUtils
.
bookmarksMenuFolderId
PlacesUtils
.
bookmarks
.
DEFAULT_INDEX
Components
.
interfaces
.
nsITreeView
.
DROP_ON
)
;
PlacesControllerDragHelper
.
onDrop
(
ip
event
.
dataTransfer
)
;
PlacesControllerDragHelper
.
currentDropTarget
=
null
;
event
.
stopPropagation
(
)
;
}
}
;
var
PlacesToolbarHelper
=
{
_place
:
"
place
:
folder
=
TOOLBAR
"
get
_viewElt
(
)
{
return
document
.
getElementById
(
"
PlacesToolbar
"
)
;
}
get
_placeholder
(
)
{
return
document
.
getElementById
(
"
bookmarks
-
toolbar
-
placeholder
"
)
;
}
init
:
function
PTH_init
(
forceToolbarOverflowCheck
)
{
let
viewElt
=
this
.
_viewElt
;
if
(
!
viewElt
|
|
viewElt
.
_placesView
)
return
;
CustomizableUI
.
addListener
(
this
)
;
let
toolbar
=
this
.
_getParentToolbar
(
viewElt
)
;
if
(
!
toolbar
|
|
toolbar
.
collapsed
|
|
this
.
_isCustomizing
|
|
getComputedStyle
(
toolbar
"
"
)
.
display
=
=
"
none
"
)
return
;
new
PlacesToolbar
(
this
.
_place
)
;
if
(
forceToolbarOverflowCheck
)
{
viewElt
.
_placesView
.
updateOverflowStatus
(
)
;
}
this
.
_shouldWrap
=
false
;
this
.
_setupPlaceholder
(
)
;
}
uninit
:
function
PTH_uninit
(
)
{
CustomizableUI
.
removeListener
(
this
)
;
}
customizeStart
:
function
PTH_customizeStart
(
)
{
try
{
let
viewElt
=
this
.
_viewElt
;
if
(
viewElt
&
&
viewElt
.
_placesView
)
viewElt
.
_placesView
.
uninit
(
)
;
}
finally
{
this
.
_isCustomizing
=
true
;
}
this
.
_shouldWrap
=
this
.
_getShouldWrap
(
)
;
}
customizeChange
:
function
PTH_customizeChange
(
)
{
this
.
_setupPlaceholder
(
)
;
}
_setupPlaceholder
:
function
PTH_setupPlaceholder
(
)
{
let
placeholder
=
this
.
_placeholder
;
if
(
!
placeholder
)
{
return
;
}
let
shouldWrapNow
=
this
.
_getShouldWrap
(
)
;
if
(
this
.
_shouldWrap
!
=
shouldWrapNow
)
{
if
(
shouldWrapNow
)
{
placeholder
.
setAttribute
(
"
wrap
"
"
true
"
)
;
}
else
{
placeholder
.
removeAttribute
(
"
wrap
"
)
;
}
this
.
_shouldWrap
=
shouldWrapNow
;
}
}
customizeDone
:
function
PTH_customizeDone
(
)
{
this
.
_isCustomizing
=
false
;
this
.
init
(
true
)
;
}
_getShouldWrap
:
function
PTH_getShouldWrap
(
)
{
let
placement
=
CustomizableUI
.
getPlacementOfWidget
(
"
personal
-
bookmarks
"
)
;
let
area
=
placement
&
&
placement
.
area
;
let
areaType
=
area
&
&
CustomizableUI
.
getAreaType
(
area
)
;
return
!
area
|
|
CustomizableUI
.
TYPE_MENU_PANEL
=
=
areaType
;
}
onPlaceholderCommand
(
)
{
let
widgetGroup
=
CustomizableUI
.
getWidget
(
"
personal
-
bookmarks
"
)
;
let
widget
=
widgetGroup
.
forWindow
(
window
)
;
if
(
widget
.
overflowed
|
|
widgetGroup
.
areaType
=
=
CustomizableUI
.
TYPE_MENU_PANEL
)
{
PlacesCommandHook
.
showPlacesOrganizer
(
"
BookmarksToolbar
"
)
;
}
}
_getParentToolbar
(
element
)
{
while
(
element
)
{
if
(
element
.
localName
=
=
"
toolbar
"
)
{
return
element
;
}
element
=
element
.
parentNode
;
}
return
null
;
}
onWidgetUnderflow
(
aNode
aContainer
)
{
let
win
=
aNode
.
ownerGlobal
;
if
(
aNode
.
id
=
=
"
personal
-
bookmarks
"
&
&
win
=
=
window
)
{
this
.
_resetView
(
)
;
}
}
onWidgetAdded
(
aWidgetId
aArea
aPosition
)
{
if
(
aWidgetId
=
=
"
personal
-
bookmarks
"
&
&
!
this
.
_isCustomizing
)
{
this
.
_resetView
(
)
;
}
}
_resetView
(
)
{
if
(
this
.
_viewElt
)
{
if
(
this
.
_viewElt
.
_placesView
)
{
this
.
_viewElt
.
_placesView
.
uninit
(
)
;
}
this
.
init
(
true
)
;
}
}
}
;
var
BookmarkingUI
=
{
STAR_ID
:
"
star
-
button
"
BOOKMARK_BUTTON_ID
:
"
bookmarks
-
menu
-
button
"
BOOKMARK_BUTTON_SHORTCUT
:
"
addBookmarkAsKb
"
get
button
(
)
{
delete
this
.
button
;
let
widgetGroup
=
CustomizableUI
.
getWidget
(
this
.
BOOKMARK_BUTTON_ID
)
;
return
this
.
button
=
widgetGroup
.
forWindow
(
window
)
.
node
;
}
get
star
(
)
{
if
(
AppConstants
.
MOZ_PHOTON_THEME
)
{
delete
this
.
star
;
return
this
.
star
=
document
.
getElementById
(
this
.
STAR_ID
)
;
}
return
document
.
getAnonymousElementByAttribute
(
this
.
button
"
anonid
"
"
button
"
)
;
}
get
anchor
(
)
{
if
(
AppConstants
.
MOZ_PHOTON_THEME
)
{
return
this
.
star
;
}
if
(
!
this
.
_shouldUpdateStarState
(
)
)
{
return
null
;
}
let
widget
=
CustomizableUI
.
getWidget
(
this
.
BOOKMARK_BUTTON_ID
)
.
forWindow
(
window
)
;
if
(
widget
.
overflowed
)
return
widget
.
anchor
;
let
star
=
this
.
star
;
return
star
?
document
.
getAnonymousElementByAttribute
(
star
"
class
"
"
toolbarbutton
-
icon
"
)
:
null
;
}
get
notifier
(
)
{
delete
this
.
notifier
;
return
this
.
notifier
=
document
.
getElementById
(
"
bookmarked
-
notification
-
anchor
"
)
;
}
get
dropmarkerNotifier
(
)
{
delete
this
.
dropmarkerNotifier
;
return
this
.
dropmarkerNotifier
=
document
.
getElementById
(
"
bookmarked
-
notification
-
dropmarker
-
anchor
"
)
;
}
get
broadcaster
(
)
{
delete
this
.
broadcaster
;
let
broadcaster
=
document
.
getElementById
(
"
bookmarkThisPageBroadcaster
"
)
;
return
this
.
broadcaster
=
broadcaster
;
}
STATUS_UPDATING
:
-
1
STATUS_UNSTARRED
:
0
STATUS_STARRED
:
1
get
status
(
)
{
if
(
!
this
.
_shouldUpdateStarState
(
)
)
{
return
this
.
STATUS_UNSTARRED
;
}
if
(
this
.
_pendingUpdate
)
return
this
.
STATUS_UPDATING
;
return
this
.
broadcaster
.
hasAttribute
(
"
starred
"
)
?
this
.
STATUS_STARRED
:
this
.
STATUS_UNSTARRED
;
}
get
_starredTooltip
(
)
{
delete
this
.
_starredTooltip
;
return
this
.
_starredTooltip
=
this
.
_getFormattedTooltip
(
"
starButtonOn
.
tooltip2
"
)
;
}
get
_unstarredTooltip
(
)
{
delete
this
.
_unstarredTooltip
;
return
this
.
_unstarredTooltip
=
this
.
_getFormattedTooltip
(
"
starButtonOff
.
tooltip2
"
)
;
}
_getFormattedTooltip
(
strId
)
{
let
args
=
[
]
;
let
shortcut
=
document
.
getElementById
(
this
.
BOOKMARK_BUTTON_SHORTCUT
)
;
if
(
shortcut
)
args
.
push
(
ShortcutUtils
.
prettifyShortcut
(
shortcut
)
)
;
return
gNavigatorBundle
.
getFormattedString
(
strId
args
)
;
}
_currentAreaType
:
null
_shouldUpdateStarState
(
)
{
return
AppConstants
.
MOZ_PHOTON_THEME
|
|
this
.
_currentAreaType
=
=
CustomizableUI
.
TYPE_TOOLBAR
;
}
_popupNeedsUpdate
:
true
onToolbarVisibilityChange
:
function
BUI_onToolbarVisibilityChange
(
)
{
this
.
_popupNeedsUpdate
=
true
;
}
onPopupShowing
:
function
BUI_onPopupShowing
(
event
)
{
if
(
event
.
target
!
=
event
.
currentTarget
)
return
;
if
(
this
.
button
.
getAttribute
(
"
cui
-
areatype
"
)
=
=
CustomizableUI
.
TYPE_MENU_PANEL
|
|
(
AppConstants
.
MOZ_PHOTON_THEME
&
&
this
.
button
.
hasAttribute
(
"
overflowedItem
"
)
)
)
{
this
.
_showSubView
(
)
;
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
return
;
}
let
widget
=
CustomizableUI
.
getWidget
(
this
.
BOOKMARK_BUTTON_ID
)
.
forWindow
(
window
)
;
if
(
widget
.
overflowed
)
{
event
.
preventDefault
(
)
;
widget
.
node
.
removeAttribute
(
"
closemenu
"
)
;
PlacesCommandHook
.
showPlacesOrganizer
(
"
BookmarksMenu
"
)
;
return
;
}
this
.
_initMobileBookmarks
(
document
.
getElementById
(
"
BMB_mobileBookmarks
"
)
)
;
this
.
_initRecentBookmarks
(
document
.
getElementById
(
"
BMB_recentBookmarks
"
)
"
subviewbutton
"
)
;
if
(
!
this
.
_popupNeedsUpdate
)
return
;
this
.
_popupNeedsUpdate
=
false
;
let
popup
=
event
.
target
;
let
getPlacesAnonymousElement
=
aAnonId
=
>
document
.
getAnonymousElementByAttribute
(
popup
.
parentNode
"
placesanonid
"
aAnonId
)
;
let
viewToolbarMenuitem
=
getPlacesAnonymousElement
(
"
view
-
toolbar
"
)
;
if
(
viewToolbarMenuitem
)
{
viewToolbarMenuitem
.
classList
.
add
(
"
subviewbutton
"
)
;
let
personalToolbar
=
document
.
getElementById
(
"
PersonalToolbar
"
)
;
viewToolbarMenuitem
.
setAttribute
(
"
checked
"
!
personalToolbar
.
collapsed
)
;
}
}
attachPlacesView
(
event
node
)
{
if
(
node
.
parentNode
.
_placesView
)
return
;
new
PlacesMenu
(
event
"
place
:
folder
=
BOOKMARKS_MENU
"
{
extraClasses
:
{
entry
:
"
subviewbutton
"
footer
:
"
panel
-
subview
-
footer
"
}
insertionPoint
:
"
.
panel
-
subview
-
footer
"
}
)
;
}
RECENTLY_BOOKMARKED_PREF
:
"
browser
.
bookmarks
.
showRecentlyBookmarked
"
MOBILE_BOOKMARKS_PREF
:
"
browser
.
bookmarks
.
showMobileBookmarks
"
_shouldShowMobileBookmarks
(
)
{
try
{
return
Services
.
prefs
.
getBoolPref
(
this
.
MOBILE_BOOKMARKS_PREF
)
;
}
catch
(
e
)
{
}
const
organizerQueryAnno
=
"
PlacesOrganizer
/
OrganizerQuery
"
;
const
mobileBookmarksAnno
=
"
MobileBookmarks
"
;
let
shouldShow
=
PlacesUtils
.
annotations
.
getItemsWithAnnotation
(
organizerQueryAnno
{
}
)
.
filter
(
id
=
>
PlacesUtils
.
annotations
.
getItemAnnotation
(
id
organizerQueryAnno
)
=
=
mobileBookmarksAnno
)
.
length
>
0
;
Services
.
prefs
.
setBoolPref
(
this
.
MOBILE_BOOKMARKS_PREF
shouldShow
)
;
return
shouldShow
;
}
_initMobileBookmarks
(
mobileMenuItem
)
{
mobileMenuItem
.
hidden
=
!
this
.
_shouldShowMobileBookmarks
(
)
;
}
_initRecentBookmarks
(
aHeaderItem
aExtraCSSClass
)
{
this
.
_populateRecentBookmarks
(
aHeaderItem
aExtraCSSClass
)
;
let
bookmarksMenu
=
aHeaderItem
.
parentNode
;
let
placesContextMenu
=
document
.
getElementById
(
"
placesContext
"
)
;
let
prefObserver
=
(
)
=
>
{
this
.
_populateRecentBookmarks
(
aHeaderItem
aExtraCSSClass
)
;
}
;
this
.
_recentlyBookmarkedObserver
=
{
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsINavBookmarkObserver
Ci
.
nsISupportsWeakReference
]
)
}
;
this
.
_recentlyBookmarkedObserver
.
onItemRemoved
=
(
)
=
>
{
this
.
_populateRecentBookmarks
(
aHeaderItem
aExtraCSSClass
)
;
}
;
let
updatePlacesContextMenu
=
(
shouldHidePrefUI
=
false
)
=
>
{
let
prefEnabled
=
!
shouldHidePrefUI
&
&
Services
.
prefs
.
getBoolPref
(
this
.
RECENTLY_BOOKMARKED_PREF
)
;
let
showItem
=
document
.
getElementById
(
"
placesContext_showRecentlyBookmarked
"
)
;
let
hideItem
=
document
.
getElementById
(
"
placesContext_hideRecentlyBookmarked
"
)
;
let
separator
=
document
.
getElementById
(
"
placesContext_recentlyBookmarkedSeparator
"
)
;
showItem
.
hidden
=
shouldHidePrefUI
|
|
prefEnabled
;
hideItem
.
hidden
=
shouldHidePrefUI
|
|
!
prefEnabled
;
separator
.
hidden
=
shouldHidePrefUI
;
if
(
!
shouldHidePrefUI
)
{
separator
.
parentNode
.
appendChild
(
separator
)
;
showItem
.
parentNode
.
appendChild
(
showItem
)
;
hideItem
.
parentNode
.
appendChild
(
hideItem
)
;
}
}
;
let
onPlacesContextMenuShowing
=
event
=
>
{
if
(
event
.
target
=
=
event
.
currentTarget
)
{
let
triggerPopup
=
event
.
target
.
triggerNode
;
while
(
triggerPopup
&
&
triggerPopup
.
localName
!
=
"
menupopup
"
)
{
triggerPopup
=
triggerPopup
.
parentNode
;
}
let
shouldHidePrefUI
=
triggerPopup
!
=
bookmarksMenu
;
updatePlacesContextMenu
(
shouldHidePrefUI
)
;
}
}
;
let
onBookmarksMenuHidden
=
event
=
>
{
if
(
event
.
target
=
=
event
.
currentTarget
)
{
updatePlacesContextMenu
(
true
)
;
Services
.
prefs
.
removeObserver
(
this
.
RECENTLY_BOOKMARKED_PREF
prefObserver
)
;
PlacesUtils
.
bookmarks
.
removeObserver
(
this
.
_recentlyBookmarkedObserver
)
;
this
.
_recentlyBookmarkedObserver
=
null
;
if
(
placesContextMenu
)
{
placesContextMenu
.
removeEventListener
(
"
popupshowing
"
onPlacesContextMenuShowing
)
;
}
bookmarksMenu
.
removeEventListener
(
"
popuphidden
"
onBookmarksMenuHidden
)
;
}
}
;
Services
.
prefs
.
addObserver
(
this
.
RECENTLY_BOOKMARKED_PREF
prefObserver
)
;
PlacesUtils
.
bookmarks
.
addObserver
(
this
.
_recentlyBookmarkedObserver
true
)
;
if
(
placesContextMenu
)
{
placesContextMenu
.
addEventListener
(
"
popupshowing
"
onPlacesContextMenuShowing
)
;
}
bookmarksMenu
.
addEventListener
(
"
popuphidden
"
onBookmarksMenuHidden
)
;
}
_populateRecentBookmarks
(
aHeaderItem
aExtraCSSClass
=
"
"
)
{
while
(
aHeaderItem
.
nextSibling
&
&
aHeaderItem
.
nextSibling
.
localName
=
=
"
menuitem
"
)
{
aHeaderItem
.
nextSibling
.
remove
(
)
;
}
let
shouldShow
=
Services
.
prefs
.
getBoolPref
(
this
.
RECENTLY_BOOKMARKED_PREF
)
;
let
separator
=
aHeaderItem
.
previousSibling
;
aHeaderItem
.
hidden
=
!
shouldShow
;
separator
.
hidden
=
!
shouldShow
;
if
(
!
shouldShow
)
{
return
;
}
const
kMaxResults
=
5
;
let
options
=
PlacesUtils
.
history
.
getNewQueryOptions
(
)
;
options
.
excludeQueries
=
true
;
options
.
queryType
=
options
.
QUERY_TYPE_BOOKMARKS
;
options
.
sortingMode
=
options
.
SORT_BY_DATEADDED_DESCENDING
;
options
.
maxResults
=
kMaxResults
;
let
query
=
PlacesUtils
.
history
.
getNewQuery
(
)
;
let
sh
=
Cc
[
"
mozilla
.
org
/
network
/
serialization
-
helper
;
1
"
]
.
getService
(
Ci
.
nsISerializationHelper
)
;
let
loadingPrincipal
=
sh
.
serializeToString
(
document
.
nodePrincipal
)
;
let
fragment
=
document
.
createDocumentFragment
(
)
;
let
root
=
PlacesUtils
.
history
.
executeQuery
(
query
options
)
.
root
;
root
.
containerOpen
=
true
;
for
(
let
i
=
0
;
i
<
root
.
childCount
;
i
+
+
)
{
let
node
=
root
.
getChild
(
i
)
;
let
uri
=
node
.
uri
;
let
title
=
node
.
title
;
let
icon
=
node
.
icon
;
let
item
=
document
.
createElementNS
(
"
http
:
/
/
www
.
mozilla
.
org
/
keymaster
/
gatekeeper
/
there
.
is
.
only
.
xul
"
"
menuitem
"
)
;
item
.
setAttribute
(
"
label
"
title
|
|
uri
)
;
item
.
setAttribute
(
"
targetURI
"
uri
)
;
item
.
setAttribute
(
"
simulated
-
places
-
node
"
true
)
;
item
.
setAttribute
(
"
class
"
"
menuitem
-
iconic
menuitem
-
with
-
favicon
bookmark
-
item
"
+
aExtraCSSClass
)
;
if
(
icon
)
{
item
.
setAttribute
(
"
image
"
icon
)
;
item
.
setAttribute
(
"
loadingprincipal
"
loadingPrincipal
)
;
}
item
.
_placesNode
=
node
;
fragment
.
appendChild
(
item
)
;
}
root
.
containerOpen
=
false
;
aHeaderItem
.
parentNode
.
insertBefore
(
fragment
aHeaderItem
.
nextSibling
)
;
}
showRecentlyBookmarked
(
)
{
Services
.
prefs
.
setBoolPref
(
this
.
RECENTLY_BOOKMARKED_PREF
true
)
;
}
hideRecentlyBookmarked
(
)
{
Services
.
prefs
.
setBoolPref
(
this
.
RECENTLY_BOOKMARKED_PREF
false
)
;
}
_updateCustomizationState
:
function
BUI__updateCustomizationState
(
)
{
let
placement
=
CustomizableUI
.
getPlacementOfWidget
(
this
.
BOOKMARK_BUTTON_ID
)
;
this
.
_currentAreaType
=
placement
&
&
CustomizableUI
.
getAreaType
(
placement
.
area
)
;
}
_uninitView
:
function
BUI__uninitView
(
)
{
if
(
this
.
button
.
_placesView
)
this
.
button
.
_placesView
.
uninit
(
)
;
let
menubar
=
document
.
getElementById
(
"
bookmarksMenu
"
)
;
if
(
menubar
&
&
menubar
.
_placesView
)
menubar
.
_placesView
.
uninit
(
)
;
const
kSpecialViewNodeIDs
=
[
"
BMB_bookmarksToolbar
"
"
BMB_unsortedBookmarks
"
]
;
for
(
let
viewNodeID
of
kSpecialViewNodeIDs
)
{
let
elem
=
document
.
getElementById
(
viewNodeID
)
;
if
(
elem
&
&
elem
.
_placesView
)
{
elem
.
_placesView
.
uninit
(
)
;
}
}
}
onCustomizeStart
:
function
BUI_customizeStart
(
aWindow
)
{
if
(
aWindow
=
=
window
)
{
this
.
_uninitView
(
)
;
this
.
_isCustomizing
=
true
;
}
}
onWidgetAdded
:
function
BUI_widgetAdded
(
aWidgetId
)
{
if
(
aWidgetId
=
=
this
.
BOOKMARK_BUTTON_ID
)
{
this
.
_onWidgetWasMoved
(
)
;
}
}
onWidgetRemoved
:
function
BUI_widgetRemoved
(
aWidgetId
)
{
if
(
aWidgetId
=
=
this
.
BOOKMARK_BUTTON_ID
)
{
this
.
_onWidgetWasMoved
(
)
;
}
}
onWidgetReset
:
function
BUI_widgetReset
(
aNode
aContainer
)
{
if
(
aNode
=
=
this
.
button
)
{
this
.
_onWidgetWasMoved
(
)
;
}
}
onWidgetUndoMove
:
function
BUI_undoWidgetUndoMove
(
aNode
aContainer
)
{
if
(
aNode
=
=
this
.
button
)
{
this
.
_onWidgetWasMoved
(
)
;
}
}
_onWidgetWasMoved
:
function
BUI_widgetWasMoved
(
)
{
let
usedToUpdateStarState
=
this
.
_shouldUpdateStarState
(
)
;
this
.
_updateCustomizationState
(
)
;
if
(
!
usedToUpdateStarState
&
&
this
.
_shouldUpdateStarState
(
)
)
{
this
.
updateStarState
(
)
;
}
else
if
(
usedToUpdateStarState
&
&
!
this
.
_shouldUpdateStarState
(
)
)
{
this
.
_updateStar
(
)
;
}
if
(
!
this
.
_isCustomizing
)
{
this
.
_uninitView
(
)
;
}
}
onCustomizeEnd
:
function
BUI_customizeEnd
(
aWindow
)
{
if
(
aWindow
=
=
window
)
{
this
.
_isCustomizing
=
false
;
this
.
onToolbarVisibilityChange
(
)
;
}
}
init
(
)
{
CustomizableUI
.
addListener
(
this
)
;
if
(
!
AppConstants
.
MOZ_PHOTON_THEME
)
{
this
.
_updateCustomizationState
(
)
;
}
}
_hasBookmarksObserver
:
false
_itemGuids
:
new
Set
(
)
uninit
:
function
BUI_uninit
(
)
{
this
.
updateBookmarkPageMenuItem
(
true
)
;
CustomizableUI
.
removeListener
(
this
)
;
this
.
_uninitView
(
)
;
if
(
this
.
_hasBookmarksObserver
)
{
PlacesUtils
.
bookmarks
.
removeObserver
(
this
)
;
}
if
(
this
.
_pendingUpdate
)
{
delete
this
.
_pendingUpdate
;
}
}
onLocationChange
:
function
BUI_onLocationChange
(
)
{
if
(
this
.
_uri
&
&
gBrowser
.
currentURI
.
equals
(
this
.
_uri
)
)
{
return
;
}
this
.
updateStarState
(
)
;
}
updateStarState
:
function
BUI_updateStarState
(
)
{
this
.
_uri
=
gBrowser
.
currentURI
;
this
.
_itemGuids
.
clear
(
)
;
let
guids
=
new
Set
(
)
;
let
pendingUpdate
=
this
.
_pendingUpdate
=
{
}
;
PlacesUtils
.
bookmarks
.
fetch
(
{
url
:
this
.
_uri
}
b
=
>
guids
.
add
(
b
.
guid
)
{
concurrent
:
true
}
)
.
catch
(
Components
.
utils
.
reportError
)
.
then
(
(
)
=
>
{
if
(
pendingUpdate
!
=
this
.
_pendingUpdate
)
{
return
;
}
if
(
this
.
_itemGuids
.
size
>
0
)
{
this
.
_itemGuids
=
new
Set
(
.
.
.
this
.
_itemGuids
.
.
.
guids
)
;
}
else
{
this
.
_itemGuids
=
guids
;
}
this
.
_updateStar
(
)
;
if
(
!
this
.
_hasBookmarksObserver
)
{
try
{
PlacesUtils
.
bookmarks
.
addObserver
(
this
)
;
this
.
_hasBookmarksObserver
=
true
;
}
catch
(
ex
)
{
Components
.
utils
.
reportError
(
"
BookmarkingUI
failed
adding
a
bookmarks
observer
:
"
+
ex
)
;
}
}
delete
this
.
_pendingUpdate
;
}
)
;
}
_updateStar
:
function
BUI__updateStar
(
)
{
if
(
!
this
.
_shouldUpdateStarState
(
)
)
{
if
(
this
.
broadcaster
.
hasAttribute
(
"
starred
"
)
)
{
this
.
broadcaster
.
removeAttribute
(
"
starred
"
)
;
this
.
broadcaster
.
removeAttribute
(
"
buttontooltiptext
"
)
;
this
.
broadcaster
.
removeAttribute
(
"
tooltiptext
"
)
;
}
return
;
}
if
(
this
.
_itemGuids
.
size
>
0
)
{
this
.
broadcaster
.
setAttribute
(
"
starred
"
"
true
"
)
;
this
.
broadcaster
.
setAttribute
(
"
buttontooltiptext
"
this
.
_starredTooltip
)
;
this
.
broadcaster
.
setAttribute
(
"
tooltiptext
"
this
.
_starredTooltip
)
;
if
(
!
AppConstants
.
MOZ_PHOTON_THEME
&
&
this
.
button
.
getAttribute
(
"
overflowedItem
"
)
=
=
"
true
"
)
{
this
.
button
.
setAttribute
(
"
label
"
this
.
_starButtonOverflowedStarredLabel
)
;
}
}
else
{
this
.
broadcaster
.
removeAttribute
(
"
starred
"
)
;
this
.
broadcaster
.
setAttribute
(
"
buttontooltiptext
"
this
.
_unstarredTooltip
)
;
this
.
broadcaster
.
setAttribute
(
"
tooltiptext
"
this
.
_unstarredTooltip
)
;
if
(
!
AppConstants
.
MOZ_PHOTON_THEME
&
&
this
.
button
.
getAttribute
(
"
overflowedItem
"
)
=
=
"
true
"
)
{
this
.
button
.
setAttribute
(
"
label
"
this
.
_starButtonOverflowedLabel
)
;
}
}
}
updateBookmarkPageMenuItem
:
function
BUI_updateBookmarkPageMenuItem
(
forceReset
)
{
let
isStarred
=
!
forceReset
&
&
this
.
_itemGuids
.
size
>
0
;
let
label
=
isStarred
?
"
editlabel
"
:
"
bookmarklabel
"
;
if
(
this
.
broadcaster
)
{
this
.
broadcaster
.
setAttribute
(
"
label
"
this
.
broadcaster
.
getAttribute
(
label
)
)
;
}
}
onMainMenuPopupShowing
:
function
BUI_onMainMenuPopupShowing
(
event
)
{
if
(
event
.
target
!
=
event
.
currentTarget
)
return
;
this
.
updateBookmarkPageMenuItem
(
)
;
PlacesCommandHook
.
updateBookmarkAllTabsCommand
(
)
;
this
.
_initMobileBookmarks
(
document
.
getElementById
(
"
menu_mobileBookmarks
"
)
)
;
this
.
_initRecentBookmarks
(
document
.
getElementById
(
"
menu_recentBookmarks
"
)
)
;
}
_showBookmarkedNotification
:
function
BUI_showBookmarkedNotification
(
)
{
function
getCenteringTransformForRects
(
rectToPosition
referenceRect
)
{
let
topDiff
=
referenceRect
.
top
-
rectToPosition
.
top
;
let
leftDiff
=
referenceRect
.
left
-
rectToPosition
.
left
;
let
heightDiff
=
referenceRect
.
height
-
rectToPosition
.
height
;
let
widthDiff
=
referenceRect
.
width
-
rectToPosition
.
width
;
return
[
(
leftDiff
+
.
5
*
widthDiff
)
+
"
px
"
(
topDiff
+
.
5
*
heightDiff
)
+
"
px
"
]
;
}
if
(
this
.
_notificationTimeout
)
{
clearTimeout
(
this
.
_notificationTimeout
)
;
}
if
(
this
.
notifier
.
style
.
transform
=
=
"
"
)
{
let
dropmarker
=
document
.
getAnonymousElementByAttribute
(
this
.
button
"
anonid
"
"
dropmarker
"
)
;
let
dropmarkerIcon
=
document
.
getAnonymousElementByAttribute
(
dropmarker
"
class
"
"
dropmarker
-
icon
"
)
;
let
dropmarkerStyle
=
getComputedStyle
(
dropmarkerIcon
)
;
let
isRTL
=
getComputedStyle
(
this
.
button
)
.
direction
=
=
"
rtl
"
;
let
buttonRect
=
this
.
button
.
getBoundingClientRect
(
)
;
let
notifierRect
=
this
.
notifier
.
getBoundingClientRect
(
)
;
let
dropmarkerRect
=
dropmarkerIcon
.
getBoundingClientRect
(
)
;
let
dropmarkerNotifierRect
=
this
.
dropmarkerNotifier
.
getBoundingClientRect
(
)
;
let
[
translateX
translateY
]
=
getCenteringTransformForRects
(
notifierRect
buttonRect
)
;
let
starIconTransform
=
"
translate
(
"
+
translateX
+
"
"
+
translateY
+
"
)
"
;
if
(
isRTL
)
{
starIconTransform
+
=
"
scaleX
(
-
1
)
"
;
}
[
translateX
translateY
]
=
getCenteringTransformForRects
(
dropmarkerNotifierRect
dropmarkerRect
)
;
let
dropmarkerTransform
=
"
translate
(
"
+
translateX
+
"
"
+
translateY
+
"
)
"
;
this
.
notifier
.
style
.
transform
=
starIconTransform
;
this
.
dropmarkerNotifier
.
style
.
transform
=
dropmarkerTransform
;
let
dropmarkerAnimationNode
=
this
.
dropmarkerNotifier
.
firstChild
;
dropmarkerAnimationNode
.
style
.
listStyleImage
=
dropmarkerStyle
.
listStyleImage
;
dropmarkerAnimationNode
.
style
.
fill
=
dropmarkerStyle
.
fill
;
}
let
isInOverflowPanel
=
this
.
button
.
getAttribute
(
"
overflowedItem
"
)
=
=
"
true
"
;
if
(
!
isInOverflowPanel
)
{
this
.
notifier
.
setAttribute
(
"
notification
"
"
finish
"
)
;
this
.
button
.
setAttribute
(
"
notification
"
"
finish
"
)
;
this
.
dropmarkerNotifier
.
setAttribute
(
"
notification
"
"
finish
"
)
;
}
this
.
_notificationTimeout
=
setTimeout
(
(
)
=
>
{
this
.
notifier
.
removeAttribute
(
"
notification
"
)
;
this
.
dropmarkerNotifier
.
removeAttribute
(
"
notification
"
)
;
this
.
button
.
removeAttribute
(
"
notification
"
)
;
this
.
dropmarkerNotifier
.
style
.
transform
=
"
"
;
this
.
notifier
.
style
.
transform
=
"
"
;
}
1000
)
;
}
showSubView
(
anchor
)
{
this
.
_showSubView
(
anchor
)
;
}
_showSubView
(
anchor
=
document
.
getElementById
(
this
.
BOOKMARK_BUTTON_ID
)
)
{
let
view
=
document
.
getElementById
(
"
PanelUI
-
bookmarks
"
)
;
view
.
addEventListener
(
"
ViewShowing
"
this
)
;
view
.
addEventListener
(
"
ViewHiding
"
this
)
;
anchor
.
setAttribute
(
"
closemenu
"
"
none
"
)
;
PanelUI
.
showSubView
(
"
PanelUI
-
bookmarks
"
anchor
CustomizableUI
.
AREA_PANEL
)
;
}
onCommand
:
function
BUI_onCommand
(
aEvent
)
{
if
(
aEvent
.
target
!
=
aEvent
.
currentTarget
)
{
return
;
}
if
(
this
.
button
.
getAttribute
(
"
cui
-
areatype
"
)
=
=
CustomizableUI
.
TYPE_MENU_PANEL
)
{
this
.
_showSubView
(
)
;
return
;
}
let
widget
=
CustomizableUI
.
getWidget
(
this
.
BOOKMARK_BUTTON_ID
)
.
forWindow
(
window
)
;
if
(
widget
.
overflowed
)
{
widget
.
node
.
removeAttribute
(
"
closemenu
"
)
;
}
this
.
onStarCommand
(
aEvent
)
;
}
onStarCommand
(
aEvent
)
{
if
(
!
this
.
_pendingUpdate
)
{
let
isBookmarked
=
this
.
_itemGuids
.
size
>
0
;
if
(
!
isBookmarked
&
&
!
AppConstants
.
MOZ_PHOTON_THEME
)
this
.
_showBookmarkedNotification
(
)
;
PlacesCommandHook
.
bookmarkCurrentPage
(
true
)
;
}
}
onCurrentPageContextPopupShowing
(
)
{
this
.
updateBookmarkPageMenuItem
(
)
;
}
handleEvent
:
function
BUI_handleEvent
(
aEvent
)
{
switch
(
aEvent
.
type
)
{
case
"
ViewShowing
"
:
this
.
onPanelMenuViewShowing
(
aEvent
)
;
break
;
case
"
ViewHiding
"
:
this
.
onPanelMenuViewHiding
(
aEvent
)
;
break
;
}
}
onPanelMenuViewShowing
:
function
BUI_onViewShowing
(
aEvent
)
{
let
panelview
=
aEvent
.
target
;
this
.
updateBookmarkPageMenuItem
(
)
;
let
viewToolbar
=
document
.
getElementById
(
"
panelMenu_viewBookmarksToolbar
"
)
;
if
(
viewToolbar
)
{
let
personalToolbar
=
document
.
getElementById
(
"
PersonalToolbar
"
)
;
if
(
personalToolbar
.
collapsed
)
viewToolbar
.
removeAttribute
(
"
checked
"
)
;
else
viewToolbar
.
setAttribute
(
"
checked
"
"
true
"
)
;
}
let
staticButtons
=
panelview
.
getElementsByTagName
(
"
toolbarbutton
"
)
;
for
(
let
i
=
0
l
=
staticButtons
.
length
;
i
<
l
;
+
+
i
)
CustomizableUI
.
addShortcut
(
staticButtons
[
i
]
)
;
if
(
gPhotonStructure
)
{
let
query
=
"
place
:
queryType
=
"
+
Ci
.
nsINavHistoryQueryOptions
.
QUERY_TYPE_BOOKMARKS
+
"
&
sort
=
"
+
Ci
.
nsINavHistoryQueryOptions
.
SORT_BY_DATEADDED_DESCENDING
+
"
&
maxResults
=
42
&
excludeQueries
=
1
"
;
this
.
_panelMenuView
=
new
PlacesPanelview
(
document
.
getElementById
(
"
panelMenu_bookmarksMenu
"
)
panelview
query
)
;
}
else
{
this
.
_panelMenuView
=
new
PlacesPanelMenuView
(
"
place
:
folder
=
BOOKMARKS_MENU
"
"
panelMenu_bookmarksMenu
"
"
panelMenu_bookmarksMenu
"
{
extraClasses
:
{
entry
:
"
subviewbutton
"
footer
:
"
panel
-
subview
-
footer
"
}
}
)
;
}
panelview
.
removeEventListener
(
"
ViewShowing
"
this
)
;
}
onPanelMenuViewHiding
:
function
BUI_onViewHiding
(
aEvent
)
{
this
.
_panelMenuView
.
uninit
(
)
;
delete
this
.
_panelMenuView
;
aEvent
.
target
.
removeEventListener
(
"
ViewHiding
"
this
)
;
}
onPanelMenuViewCommand
:
function
BUI_onPanelMenuViewCommand
(
aEvent
)
{
let
target
=
aEvent
.
originalTarget
;
if
(
!
target
.
_placesNode
)
return
;
if
(
PlacesUtils
.
nodeIsContainer
(
target
.
_placesNode
)
)
PlacesCommandHook
.
showPlacesOrganizer
(
[
"
BookmarksMenu
"
target
.
_placesNode
.
itemId
]
)
;
else
PlacesUIUtils
.
openNodeWithEvent
(
target
.
_placesNode
aEvent
)
;
PanelUI
.
hide
(
)
;
}
onItemAdded
(
aItemId
aParentId
aIndex
aItemType
aURI
aTitle
aDateAdded
aGuid
)
{
if
(
aURI
&
&
aURI
.
equals
(
this
.
_uri
)
)
{
if
(
!
this
.
_itemGuids
.
has
(
aGuid
)
)
{
this
.
_itemGuids
.
add
(
aGuid
)
;
if
(
this
.
_itemGuids
.
size
=
=
1
)
{
this
.
_updateStar
(
)
;
}
}
}
}
onItemRemoved
(
aItemId
aParentId
aIndex
aItemType
aURI
aGuid
)
{
if
(
this
.
_itemGuids
.
has
(
aGuid
)
)
{
this
.
_itemGuids
.
delete
(
aGuid
)
;
if
(
this
.
_itemGuids
.
size
=
=
0
)
{
this
.
_updateStar
(
)
;
}
}
}
onItemChanged
(
aItemId
aProperty
aIsAnnotationProperty
aNewValue
aLastModified
aItemType
aParentId
aGuid
)
{
if
(
aProperty
=
=
"
uri
"
)
{
if
(
this
.
_itemGuids
.
has
(
aGuid
)
&
&
aNewValue
!
=
this
.
_uri
.
spec
)
{
this
.
_itemGuids
.
delete
(
aGuid
)
;
if
(
this
.
_itemGuids
.
size
=
=
0
)
{
this
.
_updateStar
(
)
;
}
}
else
if
(
!
this
.
_itemGuids
.
has
(
aGuid
)
&
&
aNewValue
=
=
this
.
_uri
.
spec
)
{
this
.
_itemGuids
.
add
(
aGuid
)
;
if
(
this
.
_itemGuids
.
size
=
=
1
)
{
this
.
_updateStar
(
)
;
}
}
}
}
onBeginUpdateBatch
(
)
{
}
onEndUpdateBatch
(
)
{
}
onBeforeItemRemoved
(
)
{
}
onItemVisited
(
)
{
}
onItemMoved
(
)
{
}
_starButtonLabel
:
null
get
_starButtonOverflowedLabel
(
)
{
delete
this
.
_starButtonOverflowedLabel
;
return
this
.
_starButtonOverflowedLabel
=
gNavigatorBundle
.
getString
(
"
starButtonOverflowed
.
label
"
)
;
}
get
_starButtonOverflowedStarredLabel
(
)
{
delete
this
.
_starButtonOverflowedStarredLabel
;
return
this
.
_starButtonOverflowedStarredLabel
=
gNavigatorBundle
.
getString
(
"
starButtonOverflowedStarred
.
label
"
)
;
}
onWidgetOverflow
(
aNode
aContainer
)
{
let
win
=
aNode
.
ownerGlobal
;
if
(
AppConstants
.
MOZ_PHOTON_THEME
|
|
aNode
.
id
!
=
this
.
BOOKMARK_BUTTON_ID
|
|
win
!
=
window
)
return
;
let
currentLabel
=
aNode
.
getAttribute
(
"
label
"
)
;
if
(
!
this
.
_starButtonLabel
)
this
.
_starButtonLabel
=
currentLabel
;
if
(
currentLabel
=
=
this
.
_starButtonLabel
)
{
let
desiredLabel
=
this
.
_itemGuids
.
size
>
0
?
this
.
_starButtonOverflowedStarredLabel
:
this
.
_starButtonOverflowedLabel
;
aNode
.
setAttribute
(
"
label
"
desiredLabel
)
;
}
}
onWidgetUnderflow
(
aNode
aContainer
)
{
let
win
=
aNode
.
ownerGlobal
;
if
(
aNode
.
id
!
=
this
.
BOOKMARK_BUTTON_ID
|
|
win
!
=
window
)
return
;
this
.
_uninitView
(
)
;
if
(
AppConstants
.
MOZ_PHOTON_THEME
)
return
;
if
(
aNode
.
getAttribute
(
"
label
"
)
!
=
this
.
_starButtonLabel
)
aNode
.
setAttribute
(
"
label
"
this
.
_starButtonLabel
)
;
}
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsINavBookmarkObserver
]
)
}
;
var
AutoShowBookmarksToolbar
=
{
init
(
)
{
Services
.
obs
.
addObserver
(
this
"
autoshow
-
bookmarks
-
toolbar
"
)
;
}
uninit
(
)
{
Services
.
obs
.
removeObserver
(
this
"
autoshow
-
bookmarks
-
toolbar
"
)
;
}
observe
(
subject
topic
data
)
{
let
toolbar
=
document
.
getElementById
(
"
PersonalToolbar
"
)
;
if
(
!
toolbar
.
collapsed
)
return
;
let
placement
=
CustomizableUI
.
getPlacementOfWidget
(
"
personal
-
bookmarks
"
)
;
let
area
=
placement
&
&
placement
.
area
;
if
(
area
!
=
CustomizableUI
.
AREA_BOOKMARKS
)
return
;
setToolbarVisibility
(
toolbar
true
)
;
}
}
;
