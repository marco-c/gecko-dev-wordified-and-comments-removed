XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
NEWTAB_ENABLED
"
"
browser
.
newtabpage
.
enabled
"
false
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
SHOW_OTHER_BOOKMARKS
"
"
browser
.
toolbars
.
bookmarks
.
showOtherBookmarks
"
true
(
aPref
aPrevVal
aNewVal
)
=
>
{
BookmarkingUI
.
maybeShowOtherBookmarksFolder
(
)
.
then
(
(
)
=
>
{
document
.
getElementById
(
"
PlacesToolbar
"
)
?
.
_placesView
?
.
updateNodesVisibility
(
)
;
}
console
.
error
)
;
}
)
;
ChromeUtils
.
defineESModuleGetters
(
this
{
PanelMultiView
:
"
resource
:
/
/
/
modules
/
PanelMultiView
.
sys
.
mjs
"
RecentlyClosedTabsAndWindowsMenuUtils
:
"
resource
:
/
/
/
modules
/
sessionstore
/
RecentlyClosedTabsAndWindowsMenuUtils
.
sys
.
mjs
"
}
)
;
var
StarUI
=
{
userHasTags
:
undefined
_itemGuids
:
null
_isNewBookmark
:
false
_isComposing
:
false
_autoCloseTimer
:
0
_autoCloseTimerEnabled
:
true
_autoCloseTimeout
:
3500
_removeBookmarksOnPopupHidden
:
false
_element
(
aID
)
{
return
document
.
getElementById
(
aID
)
;
}
get
panel
(
)
{
delete
this
.
panel
;
this
.
_createPanelIfNeeded
(
)
;
var
element
=
this
.
_element
(
"
editBookmarkPanel
"
)
;
window
.
ensureCustomElements
(
"
moz
-
button
-
group
"
)
;
element
.
hidden
=
false
;
element
.
addEventListener
(
"
keypress
"
this
{
mozSystemGroup
:
true
}
)
;
element
.
addEventListener
(
"
mousedown
"
this
)
;
element
.
addEventListener
(
"
mouseout
"
this
)
;
element
.
addEventListener
(
"
mousemove
"
this
)
;
element
.
addEventListener
(
"
compositionstart
"
this
)
;
element
.
addEventListener
(
"
compositionend
"
this
)
;
element
.
addEventListener
(
"
input
"
this
)
;
element
.
addEventListener
(
"
popuphidden
"
this
)
;
element
.
addEventListener
(
"
popupshown
"
this
)
;
return
(
this
.
panel
=
element
)
;
}
handleEvent
(
aEvent
)
{
switch
(
aEvent
.
type
)
{
case
"
mousemove
"
:
clearTimeout
(
this
.
_autoCloseTimer
)
;
break
;
case
"
popuphidden
"
:
{
clearTimeout
(
this
.
_autoCloseTimer
)
;
if
(
aEvent
.
originalTarget
=
=
this
.
panel
)
{
this
.
_handlePopupHiddenEvent
(
)
.
catch
(
console
.
error
)
;
}
break
;
}
case
"
keypress
"
:
clearTimeout
(
this
.
_autoCloseTimer
)
;
this
.
_autoCloseTimerEnabled
=
false
;
if
(
aEvent
.
defaultPrevented
)
{
break
;
}
switch
(
aEvent
.
keyCode
)
{
case
KeyEvent
.
DOM_VK_ESCAPE
:
if
(
this
.
_isNewBookmark
)
{
this
.
_removeBookmarksOnPopupHidden
=
true
;
}
this
.
panel
.
hidePopup
(
)
;
break
;
case
KeyEvent
.
DOM_VK_RETURN
:
if
(
aEvent
.
target
.
classList
.
contains
(
"
expander
-
up
"
)
|
|
aEvent
.
target
.
classList
.
contains
(
"
expander
-
down
"
)
|
|
aEvent
.
target
.
id
=
=
"
editBMPanel_newFolderButton
"
|
|
aEvent
.
target
.
id
=
=
"
editBookmarkPanelRemoveButton
"
)
{
break
;
}
this
.
panel
.
hidePopup
(
)
;
break
;
case
0
:
let
accessKey
=
document
.
getElementById
(
"
key_close
"
)
;
if
(
eventMatchesKey
(
aEvent
accessKey
)
)
{
this
.
panel
.
hidePopup
(
)
;
}
break
;
}
break
;
case
"
compositionend
"
:
this
.
_isComposing
=
false
;
break
;
case
"
compositionstart
"
:
if
(
aEvent
.
defaultPrevented
)
{
break
;
}
this
.
_isComposing
=
true
;
case
"
input
"
:
case
"
mousedown
"
:
clearTimeout
(
this
.
_autoCloseTimer
)
;
this
.
_autoCloseTimerEnabled
=
false
;
break
;
case
"
mouseout
"
:
if
(
!
this
.
_autoCloseTimerEnabled
)
{
break
;
}
case
"
popupshown
"
:
if
(
aEvent
.
target
!
=
aEvent
.
currentTarget
)
{
break
;
}
if
(
this
.
_isNewBookmark
&
&
!
this
.
_isComposing
)
{
let
delay
=
this
.
_autoCloseTimeout
;
if
(
this
.
_closePanelQuickForTesting
)
{
delay
/
=
10
;
}
clearTimeout
(
this
.
_autoCloseTimer
)
;
this
.
_autoCloseTimer
=
setTimeout
(
(
)
=
>
{
if
(
!
this
.
panel
.
matches
(
"
:
hover
"
)
)
{
this
.
panel
.
hidePopup
(
true
)
;
}
}
delay
)
;
this
.
_autoCloseTimerEnabled
=
true
;
}
break
;
}
}
async
_handlePopupHiddenEvent
(
)
{
const
{
bookmarkState
didChangeFolder
selectedFolderGuid
}
=
gEditItemOverlay
;
gEditItemOverlay
.
uninitPanel
(
true
)
;
const
removeBookmarksOnPopupHidden
=
this
.
_removeBookmarksOnPopupHidden
;
this
.
_removeBookmarksOnPopupHidden
=
false
;
const
guidsForRemoval
=
this
.
_itemGuids
;
this
.
_itemGuids
=
null
;
if
(
removeBookmarksOnPopupHidden
&
&
guidsForRemoval
)
{
if
(
!
this
.
_isNewBookmark
)
{
await
PlacesTransactions
.
Remove
(
guidsForRemoval
)
.
transact
(
)
;
}
else
{
BookmarkingUI
.
star
.
removeAttribute
(
"
starred
"
)
;
}
return
;
}
await
this
.
_storeRecentlyUsedFolder
(
selectedFolderGuid
didChangeFolder
)
;
await
bookmarkState
.
save
(
)
;
if
(
this
.
_isNewBookmark
)
{
this
.
showConfirmation
(
)
;
}
}
async
showEditBookmarkPopup
(
aNode
aIsNewBookmark
aUrl
)
{
if
(
this
.
panel
.
state
!
=
"
closed
"
)
{
return
;
}
this
.
_isNewBookmark
=
aIsNewBookmark
;
this
.
_itemGuids
=
null
;
let
titleL10nID
=
this
.
_isNewBookmark
?
"
bookmarks
-
add
-
bookmark
"
:
"
bookmarks
-
edit
-
bookmark
"
;
document
.
l10n
.
setAttributes
(
this
.
_element
(
"
editBookmarkPanelTitle
"
)
titleL10nID
)
;
this
.
_element
(
"
editBookmarkPanel_showForNewBookmarks
"
)
.
checked
=
this
.
showForNewBookmarks
;
this
.
_itemGuids
=
[
]
;
await
PlacesUtils
.
bookmarks
.
fetch
(
{
url
:
aUrl
}
bookmark
=
>
this
.
_itemGuids
.
push
(
bookmark
.
guid
)
)
;
let
removeButton
=
this
.
_element
(
"
editBookmarkPanelRemoveButton
"
)
;
if
(
this
.
_isNewBookmark
)
{
document
.
l10n
.
setAttributes
(
removeButton
"
bookmark
-
panel
-
cancel
"
)
;
}
else
{
document
.
l10n
.
setAttributes
(
removeButton
"
bookmark
-
panel
-
remove
"
{
count
:
this
.
_itemGuids
.
length
}
)
;
}
let
onPanelReady
=
fn
=
>
{
let
target
=
this
.
panel
;
if
(
target
.
parentNode
)
{
target
=
target
.
parentNode
;
}
target
.
addEventListener
(
"
popupshown
"
function
(
event
)
{
fn
(
)
;
}
{
capture
:
true
once
:
true
}
)
;
}
;
let
hiddenRows
=
[
"
location
"
"
keyword
"
]
;
if
(
this
.
userHasTags
=
=
=
undefined
)
{
const
fetchedTags
=
await
PlacesUtils
.
bookmarks
.
fetchTags
(
)
;
this
.
userHasTags
=
!
!
fetchedTags
.
length
;
}
if
(
!
this
.
userHasTags
)
{
hiddenRows
.
push
(
"
tags
"
)
;
}
await
gEditItemOverlay
.
initPanel
(
{
node
:
aNode
onPanelReady
hiddenRows
focusedElement
:
"
preferred
"
isNewBookmark
:
this
.
_isNewBookmark
}
)
;
this
.
panel
.
openPopup
(
BookmarkingUI
.
anchor
"
bottomright
topright
"
)
;
}
_createPanelIfNeeded
(
)
{
if
(
!
this
.
_element
(
"
editBookmarkPanel
"
)
)
{
MozXULElement
.
insertFTLIfNeeded
(
"
browser
/
editBookmarkOverlay
.
ftl
"
)
;
let
template
=
this
.
_element
(
"
editBookmarkPanelTemplate
"
)
;
let
clone
=
template
.
content
.
cloneNode
(
true
)
;
template
.
replaceWith
(
clone
)
;
}
}
removeBookmarkButtonCommand
:
function
SU_removeBookmarkButtonCommand
(
)
{
this
.
_removeBookmarksOnPopupHidden
=
true
;
this
.
panel
.
hidePopup
(
)
;
}
async
_storeRecentlyUsedFolder
(
selectedFolderGuid
didChangeFolder
)
{
if
(
!
selectedFolderGuid
)
{
return
;
}
if
(
didChangeFolder
)
{
Services
.
prefs
.
setCharPref
(
"
browser
.
bookmarks
.
defaultLocation
"
selectedFolderGuid
)
;
}
if
(
PlacesUtils
.
bookmarks
.
userContentRoots
.
includes
(
selectedFolderGuid
)
)
{
return
;
}
let
lastUsedFolderGuids
=
await
PlacesUtils
.
metadata
.
get
(
PlacesUIUtils
.
LAST_USED_FOLDERS_META_KEY
[
]
)
;
let
index
=
lastUsedFolderGuids
.
indexOf
(
selectedFolderGuid
)
;
if
(
index
>
1
)
{
lastUsedFolderGuids
.
splice
(
index
1
)
;
lastUsedFolderGuids
.
unshift
(
selectedFolderGuid
)
;
}
else
if
(
index
=
=
-
1
)
{
lastUsedFolderGuids
.
unshift
(
selectedFolderGuid
)
;
}
while
(
lastUsedFolderGuids
.
length
>
PlacesUIUtils
.
maxRecentFolders
)
{
lastUsedFolderGuids
.
pop
(
)
;
}
await
PlacesUtils
.
metadata
.
set
(
PlacesUIUtils
.
LAST_USED_FOLDERS_META_KEY
lastUsedFolderGuids
)
;
}
onShowForNewBookmarksCheckboxCommand
(
)
{
Services
.
prefs
.
setBoolPref
(
"
browser
.
bookmarks
.
editDialog
.
showForNewBookmarks
"
this
.
_element
(
"
editBookmarkPanel_showForNewBookmarks
"
)
.
checked
)
;
}
showConfirmation
(
)
{
const
HINT_COUNT_PREF
=
"
browser
.
bookmarks
.
editDialog
.
confirmationHintShowCount
"
;
const
HINT_COUNT
=
Services
.
prefs
.
getIntPref
(
HINT_COUNT_PREF
0
)
;
if
(
HINT_COUNT
>
=
3
)
{
return
;
}
Services
.
prefs
.
setIntPref
(
HINT_COUNT_PREF
HINT_COUNT
+
1
)
;
let
anchor
;
if
(
window
.
toolbar
.
visible
)
{
for
(
let
id
of
[
"
library
-
button
"
"
bookmarks
-
menu
-
button
"
]
)
{
let
element
=
document
.
getElementById
(
id
)
;
if
(
element
&
&
element
.
getAttribute
(
"
cui
-
areatype
"
)
!
=
"
panel
"
&
&
element
.
getAttribute
(
"
overflowedItem
"
)
!
=
"
true
"
)
{
anchor
=
element
;
break
;
}
}
}
if
(
!
anchor
)
{
anchor
=
document
.
getElementById
(
"
PanelUI
-
menu
-
button
"
)
;
}
ConfirmationHint
.
show
(
anchor
"
confirmation
-
hint
-
page
-
bookmarked
"
)
;
}
}
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
StarUI
"
showForNewBookmarks
"
"
browser
.
bookmarks
.
editDialog
.
showForNewBookmarks
"
)
;
var
PlacesCommandHook
=
{
async
bookmarkPage
(
)
{
let
browser
=
gBrowser
.
selectedBrowser
;
let
url
=
URL
.
fromURI
(
browser
.
currentURI
)
;
let
info
=
await
PlacesUtils
.
bookmarks
.
fetch
(
{
url
}
)
;
let
isNewBookmark
=
!
info
;
let
showEditUI
=
!
isNewBookmark
|
|
StarUI
.
showForNewBookmarks
;
if
(
isNewBookmark
)
{
let
parentGuid
=
await
PlacesUIUtils
.
defaultParentGuid
;
info
=
{
url
parentGuid
}
;
let
charset
=
null
;
let
isErrorPage
=
false
;
if
(
browser
.
documentURI
)
{
isErrorPage
=
/
^
about
:
(
neterror
|
certerror
|
blocked
)
/
.
test
(
browser
.
documentURI
.
spec
)
;
}
try
{
if
(
isErrorPage
)
{
let
entry
=
await
PlacesUtils
.
history
.
fetch
(
browser
.
currentURI
)
;
if
(
entry
)
{
info
.
title
=
entry
.
title
;
}
}
else
{
info
.
title
=
browser
.
contentTitle
;
}
info
.
title
=
info
.
title
|
|
url
.
href
;
charset
=
browser
.
characterSet
;
}
catch
(
e
)
{
console
.
error
(
e
)
;
}
if
(
!
StarUI
.
showForNewBookmarks
)
{
info
.
guid
=
await
PlacesTransactions
.
NewBookmark
(
info
)
.
transact
(
)
;
}
else
{
info
.
guid
=
PlacesUtils
.
bookmarks
.
unsavedGuid
;
BookmarkingUI
.
star
.
setAttribute
(
"
starred
"
"
true
"
)
;
}
if
(
charset
)
{
PlacesUIUtils
.
setCharsetForPage
(
url
charset
window
)
.
catch
(
console
.
error
)
;
}
}
gURLBar
.
handleRevert
(
)
;
if
(
!
showEditUI
)
{
StarUI
.
showConfirmation
(
)
;
return
;
}
let
node
=
await
PlacesUIUtils
.
promiseNodeLikeFromFetchInfo
(
info
)
;
await
StarUI
.
showEditBookmarkPopup
(
node
isNewBookmark
url
)
;
}
async
bookmarkLink
(
url
title
)
{
let
bm
=
await
PlacesUtils
.
bookmarks
.
fetch
(
{
url
}
)
;
if
(
bm
)
{
let
node
=
await
PlacesUIUtils
.
promiseNodeLikeFromFetchInfo
(
bm
)
;
await
PlacesUIUtils
.
showBookmarkDialog
(
{
action
:
"
edit
"
node
}
window
.
top
)
;
return
;
}
let
parentGuid
=
await
PlacesUIUtils
.
defaultParentGuid
;
let
defaultInsertionPoint
=
new
PlacesInsertionPoint
(
{
parentGuid
}
)
;
await
PlacesUIUtils
.
showBookmarkDialog
(
{
action
:
"
add
"
type
:
"
bookmark
"
uri
:
Services
.
io
.
newURI
(
url
)
title
defaultInsertionPoint
hiddenRows
:
[
"
location
"
"
keyword
"
]
}
window
.
top
)
;
}
getUniquePages
(
tabs
)
{
let
uniquePages
=
{
}
;
let
URIs
=
[
]
;
tabs
.
forEach
(
tab
=
>
{
let
browser
=
tab
.
linkedBrowser
;
let
uri
=
browser
.
currentURI
;
let
title
=
browser
.
contentTitle
|
|
tab
.
label
;
let
spec
=
uri
.
spec
;
if
(
!
(
spec
in
uniquePages
)
)
{
uniquePages
[
spec
]
=
null
;
URIs
.
push
(
{
uri
title
}
)
;
}
}
)
;
return
URIs
;
}
get
uniqueCurrentPages
(
)
{
let
visibleUnpinnedTabs
=
gBrowser
.
visibleTabs
.
filter
(
tab
=
>
!
tab
.
pinned
)
;
return
this
.
getUniquePages
(
visibleUnpinnedTabs
)
;
}
get
uniqueSelectedPages
(
)
{
return
this
.
getUniquePages
(
gBrowser
.
selectedTabs
)
;
}
showPlacesOrganizer
(
item
)
{
var
organizer
=
Services
.
wm
.
getMostRecentWindow
(
"
Places
:
Organizer
"
)
;
if
(
!
organizer
|
|
organizer
.
closed
)
{
openDialog
(
"
chrome
:
/
/
browser
/
content
/
places
/
places
.
xhtml
"
"
"
"
chrome
toolbar
=
yes
dialog
=
no
resizable
"
item
)
;
}
else
{
organizer
.
PlacesOrganizer
.
selectLeftPaneContainerByHierarchy
(
item
)
;
organizer
.
focus
(
)
;
}
}
async
searchBookmarks
(
)
{
let
win
=
BrowserWindowTracker
.
getTopWindow
(
)
?
?
(
await
BrowserWindowTracker
.
promiseOpenWindow
(
)
)
;
win
.
gURLBar
.
search
(
UrlbarTokenizer
.
RESTRICT
.
BOOKMARK
{
searchModeEntry
:
"
bookmarkmenu
"
}
)
;
}
async
searchHistory
(
)
{
let
win
=
BrowserWindowTracker
.
getTopWindow
(
)
?
?
(
await
BrowserWindowTracker
.
promiseOpenWindow
(
)
)
;
win
.
gURLBar
.
search
(
UrlbarTokenizer
.
RESTRICT
.
HISTORY
{
searchModeEntry
:
"
historymenu
"
}
)
;
}
}
;
class
HistoryMenu
extends
PlacesMenu
{
constructor
(
aPopupShowingEvent
)
{
super
(
aPopupShowingEvent
"
place
:
sort
=
4
&
maxResults
=
15
"
)
;
}
_init
(
)
{
super
.
_init
(
)
;
let
elements
=
{
undoTabMenu
:
"
historyUndoMenu
"
hiddenTabsMenu
:
"
hiddenTabsMenu
"
undoWindowMenu
:
"
historyUndoWindowMenu
"
syncTabsMenuitem
:
"
sync
-
tabs
-
menuitem
"
}
;
for
(
let
[
key
elemId
]
of
Object
.
entries
(
elements
)
)
{
this
[
key
]
=
document
.
getElementById
(
elemId
)
;
}
}
toggleHiddenTabs
(
)
{
const
isShown
=
window
.
gBrowser
&
&
gBrowser
.
visibleTabs
.
length
<
gBrowser
.
tabs
.
length
;
this
.
hiddenTabsMenu
.
hidden
=
!
isShown
;
}
toggleRecentlyClosedTabs
(
)
{
if
(
SessionStore
.
getClosedTabCount
(
)
=
=
0
)
{
this
.
undoTabMenu
.
setAttribute
(
"
disabled
"
true
)
;
}
else
{
this
.
undoTabMenu
.
removeAttribute
(
"
disabled
"
)
;
}
}
populateUndoSubmenu
(
)
{
var
undoPopup
=
this
.
undoTabMenu
.
menupopup
;
while
(
undoPopup
.
hasChildNodes
(
)
)
{
undoPopup
.
firstChild
.
remove
(
)
;
}
if
(
SessionStore
.
getClosedTabCount
(
)
=
=
0
)
{
this
.
undoTabMenu
.
setAttribute
(
"
disabled
"
true
)
;
return
;
}
this
.
undoTabMenu
.
removeAttribute
(
"
disabled
"
)
;
let
tabsFragment
=
RecentlyClosedTabsAndWindowsMenuUtils
.
getTabsFragment
(
window
"
menuitem
"
false
)
;
undoPopup
.
appendChild
(
tabsFragment
)
;
}
toggleRecentlyClosedWindows
(
)
{
if
(
SessionStore
.
getClosedWindowCount
(
)
=
=
0
)
{
this
.
undoWindowMenu
.
setAttribute
(
"
disabled
"
true
)
;
}
else
{
this
.
undoWindowMenu
.
removeAttribute
(
"
disabled
"
)
;
}
}
populateUndoWindowSubmenu
(
)
{
let
undoPopup
=
this
.
undoWindowMenu
.
menupopup
;
while
(
undoPopup
.
hasChildNodes
(
)
)
{
undoPopup
.
firstChild
.
remove
(
)
;
}
if
(
SessionStore
.
getClosedWindowCount
(
)
=
=
0
)
{
this
.
undoWindowMenu
.
setAttribute
(
"
disabled
"
true
)
;
return
;
}
this
.
undoWindowMenu
.
removeAttribute
(
"
disabled
"
)
;
let
windowsFragment
=
RecentlyClosedTabsAndWindowsMenuUtils
.
getWindowsFragment
(
window
"
menuitem
"
false
)
;
undoPopup
.
appendChild
(
windowsFragment
)
;
}
toggleTabsFromOtherComputers
(
)
{
if
(
!
this
.
syncTabsMenuitem
)
{
return
;
}
if
(
!
PlacesUIUtils
.
shouldShowTabsFromOtherComputersMenuitem
(
)
)
{
this
.
syncTabsMenuitem
.
hidden
=
true
;
return
;
}
this
.
syncTabsMenuitem
.
hidden
=
false
;
}
_onPopupShowing
(
aEvent
)
{
super
.
_onPopupShowing
(
aEvent
)
;
if
(
aEvent
.
target
!
=
aEvent
.
currentTarget
)
{
return
;
}
this
.
toggleHiddenTabs
(
)
;
this
.
toggleRecentlyClosedTabs
(
)
;
this
.
toggleRecentlyClosedWindows
(
)
;
this
.
toggleTabsFromOtherComputers
(
)
;
}
_onCommand
(
aEvent
)
{
aEvent
=
getRootEvent
(
aEvent
)
;
let
placesNode
=
aEvent
.
target
.
_placesNode
;
if
(
placesNode
)
{
if
(
!
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
{
PlacesUIUtils
.
markPageAsTyped
(
placesNode
.
uri
)
;
}
openUILink
(
placesNode
.
uri
aEvent
{
ignoreAlt
:
true
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
}
)
;
}
}
}
var
BookmarksEventHandler
=
{
onMouseUp
(
aEvent
)
{
if
(
aEvent
.
button
=
=
2
|
|
PlacesUIUtils
.
openInTabClosesMenu
)
{
return
;
}
let
target
=
aEvent
.
originalTarget
;
if
(
target
.
tagName
!
=
"
menuitem
"
)
{
return
;
}
let
modifKey
=
AppConstants
.
platform
=
=
=
"
macosx
"
?
aEvent
.
metaKey
:
aEvent
.
ctrlKey
;
if
(
modifKey
|
|
aEvent
.
button
=
=
1
)
{
target
.
setAttribute
(
"
closemenu
"
"
none
"
)
;
var
menupopup
=
target
.
parentNode
;
menupopup
.
addEventListener
(
"
popuphidden
"
(
)
=
>
{
target
.
removeAttribute
(
"
closemenu
"
)
;
}
{
once
:
true
}
)
;
}
else
{
target
.
removeAttribute
(
"
closemenu
"
)
;
}
}
onClick
:
function
BEH_onClick
(
aEvent
aView
)
{
let
modifKey
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
modifKey
=
aEvent
.
metaKey
|
|
aEvent
.
shiftKey
;
}
else
{
modifKey
=
aEvent
.
ctrlKey
|
|
aEvent
.
shiftKey
;
}
if
(
aEvent
.
button
=
=
2
|
|
(
aEvent
.
button
=
=
0
&
&
!
modifKey
)
)
{
return
;
}
var
target
=
aEvent
.
originalTarget
;
var
tag
=
target
.
tagName
;
if
(
PlacesUIUtils
.
openInTabClosesMenu
&
&
(
tag
=
=
"
menuitem
"
|
|
tag
=
=
"
menu
"
)
)
{
closeMenus
(
aEvent
.
target
)
;
}
if
(
target
.
_placesNode
&
&
PlacesUtils
.
nodeIsContainer
(
target
.
_placesNode
)
)
{
if
(
target
.
localName
=
=
"
menu
"
|
|
target
.
localName
=
=
"
toolbarbutton
"
)
{
PlacesUIUtils
.
openMultipleLinksInTabs
(
target
.
_placesNode
aEvent
aView
)
;
}
}
else
if
(
aEvent
.
button
=
=
1
&
&
!
(
tag
=
=
"
menuitem
"
|
|
tag
=
=
"
menu
"
)
)
{
this
.
onCommand
(
aEvent
)
;
aEvent
.
preventDefault
(
)
;
aEvent
.
stopPropagation
(
)
;
}
}
onCommand
:
function
BEH_onCommand
(
aEvent
)
{
var
target
=
aEvent
.
originalTarget
;
if
(
target
.
_placesNode
)
{
PlacesUIUtils
.
openNodeWithEvent
(
target
.
_placesNode
aEvent
)
;
if
(
target
.
closest
(
"
#
PersonalToolbar
"
)
)
{
Services
.
telemetry
.
scalarAdd
(
"
browser
.
engagement
.
bookmarks_toolbar_bookmark_opened
"
1
)
;
}
}
}
fillInBHTooltip
:
function
BEH_fillInBHTooltip
(
aTooltip
aEvent
)
{
var
node
;
var
cropped
=
false
;
var
targetURI
;
if
(
aTooltip
.
triggerNode
.
localName
=
=
"
treechildren
"
)
{
var
tree
=
aTooltip
.
triggerNode
.
parentNode
;
var
cell
=
tree
.
getCellAt
(
aEvent
.
clientX
aEvent
.
clientY
)
;
if
(
cell
.
row
=
=
-
1
)
{
return
false
;
}
node
=
tree
.
view
.
nodeForTreeIndex
(
cell
.
row
)
;
cropped
=
tree
.
isCellCropped
(
cell
.
row
cell
.
col
)
;
}
else
{
var
tooltipNode
=
aTooltip
.
triggerNode
;
if
(
tooltipNode
.
_placesNode
)
{
node
=
tooltipNode
.
_placesNode
;
}
else
{
targetURI
=
tooltipNode
.
getAttribute
(
"
targetURI
"
)
;
}
}
if
(
!
node
&
&
!
targetURI
)
{
return
false
;
}
var
title
=
node
?
node
.
title
:
tooltipNode
.
label
;
var
url
;
if
(
targetURI
|
|
PlacesUtils
.
nodeIsURI
(
node
)
)
{
url
=
targetURI
|
|
node
.
uri
;
}
if
(
!
cropped
&
&
!
url
)
{
return
false
;
}
let
tooltipTitle
=
aEvent
.
target
.
querySelector
(
"
.
places
-
tooltip
-
title
"
)
;
tooltipTitle
.
hidden
=
!
title
|
|
title
=
=
url
;
if
(
!
tooltipTitle
.
hidden
)
{
tooltipTitle
.
textContent
=
title
;
}
let
tooltipUrl
=
aEvent
.
target
.
querySelector
(
"
.
places
-
tooltip
-
uri
"
)
;
tooltipUrl
.
hidden
=
!
url
;
if
(
!
tooltipUrl
.
hidden
)
{
tooltipUrl
.
value
=
url
;
}
return
true
;
}
}
;
var
PlacesMenuDNDHandler
=
{
_springLoadDelayMs
:
350
_closeDelayMs
:
500
_loadTimer
:
null
_closeTimer
:
null
_closingTimerNode
:
null
onDragEnter
:
function
PMDH_onDragEnter
(
event
)
{
if
(
!
this
.
_isStaticContainer
(
event
.
target
)
)
{
return
;
}
if
(
this
.
_closeTimer
&
&
this
.
_closingTimerNode
=
=
=
event
.
currentTarget
)
{
this
.
_closeTimer
.
cancel
(
)
;
this
.
_closingTimerNode
=
null
;
this
.
_closeTimer
=
null
;
}
PlacesControllerDragHelper
.
currentDropTarget
=
event
.
target
;
let
popup
=
event
.
target
.
menupopup
;
if
(
this
.
_loadTimer
|
|
popup
.
state
=
=
=
"
showing
"
|
|
popup
.
state
=
=
=
"
open
"
)
{
return
;
}
this
.
_loadTimer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
this
.
_loadTimer
.
initWithCallback
(
(
)
=
>
{
this
.
_loadTimer
=
null
;
popup
.
setAttribute
(
"
autoopened
"
"
true
"
)
;
popup
.
openPopup
(
)
;
}
this
.
_springLoadDelayMs
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
}
onDragLeave
:
function
PMDH_onDragLeave
(
event
)
{
if
(
event
.
relatedTarget
=
=
=
event
.
currentTarget
|
|
(
event
.
relatedTarget
&
&
event
.
relatedTarget
.
parentNode
=
=
=
event
.
currentTarget
)
)
{
return
;
}
if
(
!
this
.
_isStaticContainer
(
event
.
target
)
)
{
return
;
}
PlacesControllerDragHelper
.
currentDropTarget
=
null
;
let
popup
=
event
.
target
.
menupopup
;
if
(
this
.
_loadTimer
)
{
this
.
_loadTimer
.
cancel
(
)
;
this
.
_loadTimer
=
null
;
}
this
.
_closeTimer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
this
.
_closingTimerNode
=
event
.
currentTarget
;
this
.
_closeTimer
.
initWithCallback
(
function
(
)
{
this
.
_closeTimer
=
null
;
this
.
_closingTimerNode
=
null
;
let
node
=
PlacesControllerDragHelper
.
currentDropTarget
;
let
inHierarchy
=
false
;
while
(
node
&
&
!
inHierarchy
)
{
inHierarchy
=
node
=
=
event
.
target
;
node
=
node
.
parentNode
;
}
if
(
!
inHierarchy
&
&
popup
&
&
popup
.
hasAttribute
(
"
autoopened
"
)
)
{
popup
.
removeAttribute
(
"
autoopened
"
)
;
popup
.
hidePopup
(
)
;
}
}
this
.
_closeDelayMs
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
_isStaticContainer
:
function
PMDH__isContainer
(
node
)
{
let
isMenu
=
node
.
localName
=
=
"
menu
"
|
|
(
node
.
localName
=
=
"
toolbarbutton
"
&
&
node
.
getAttribute
(
"
type
"
)
=
=
"
menu
"
)
;
let
isStatic
=
!
(
"
_placesNode
"
in
node
)
&
&
node
.
menupopup
&
&
node
.
menupopup
.
hasAttribute
(
"
placespopup
"
)
&
&
!
node
.
parentNode
.
hasAttribute
(
"
placespopup
"
)
;
return
isMenu
&
&
isStatic
;
}
onDragOver
:
function
PMDH_onDragOver
(
event
)
{
PlacesControllerDragHelper
.
currentDropTarget
=
event
.
target
;
let
ip
=
new
PlacesInsertionPoint
(
{
parentGuid
:
PlacesUtils
.
bookmarks
.
menuGuid
}
)
;
if
(
ip
&
&
PlacesControllerDragHelper
.
canDrop
(
ip
event
.
dataTransfer
)
)
{
event
.
preventDefault
(
)
;
}
event
.
stopPropagation
(
)
;
}
onDrop
:
function
PMDH_onDrop
(
event
)
{
let
ip
=
new
PlacesInsertionPoint
(
{
parentGuid
:
PlacesUtils
.
bookmarks
.
menuGuid
}
)
;
PlacesControllerDragHelper
.
onDrop
(
ip
event
.
dataTransfer
)
;
PlacesControllerDragHelper
.
currentDropTarget
=
null
;
event
.
stopPropagation
(
)
;
}
}
;
var
PlacesToolbarHelper
=
{
get
_viewElt
(
)
{
return
document
.
getElementById
(
"
PlacesToolbar
"
)
;
}
async
init
(
)
{
await
PlacesUIUtils
.
canLoadToolbarContentPromise
;
this
.
_realInit
(
)
;
}
_realInit
(
)
{
let
viewElt
=
this
.
_viewElt
;
if
(
!
viewElt
|
|
viewElt
.
_placesView
|
|
window
.
closed
)
{
return
;
}
CustomizableUI
.
addListener
(
this
)
;
if
(
!
this
.
_isObservingToolbars
)
{
this
.
_isObservingToolbars
=
true
;
window
.
addEventListener
(
"
toolbarvisibilitychange
"
this
)
;
}
let
toolbar
=
this
.
_getParentToolbar
(
viewElt
)
;
if
(
!
toolbar
|
|
toolbar
.
collapsed
|
|
this
.
_isCustomizing
|
|
getComputedStyle
(
toolbar
"
"
)
.
display
=
=
"
none
"
)
{
return
;
}
new
PlacesToolbar
(
place
:
parent
=
{
PlacesUtils
.
bookmarks
.
toolbarGuid
}
document
.
getElementById
(
"
PlacesToolbarItems
"
)
viewElt
)
;
if
(
toolbar
.
id
=
=
"
PersonalToolbar
"
)
{
if
(
!
toolbar
.
hasAttribute
(
"
initialized
"
)
)
{
toolbar
.
setAttribute
(
"
initialized
"
"
true
"
)
;
}
BookmarkingUI
.
updateEmptyToolbarMessage
(
)
.
catch
(
console
.
error
)
;
}
}
async
getIsEmpty
(
)
{
if
(
!
this
.
_viewElt
.
_placesView
)
{
return
true
;
}
await
this
.
_viewElt
.
_placesView
.
promiseRebuilt
(
)
;
return
!
document
.
getElementById
(
"
PlacesToolbarItems
"
)
.
hasChildNodes
(
)
;
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
toolbarvisibilitychange
"
:
if
(
event
.
target
=
=
this
.
_getParentToolbar
(
this
.
_viewElt
)
)
{
this
.
_resetView
(
)
;
}
break
;
}
}
uninit
:
function
PTH_uninit
(
)
{
if
(
this
.
_isObservingToolbars
)
{
delete
this
.
_isObservingToolbars
;
window
.
removeEventListener
(
"
toolbarvisibilitychange
"
this
)
;
}
CustomizableUI
.
removeListener
(
this
)
;
}
customizeStart
:
function
PTH_customizeStart
(
)
{
try
{
let
viewElt
=
this
.
_viewElt
;
if
(
viewElt
&
&
viewElt
.
_placesView
)
{
viewElt
.
_placesView
.
uninit
(
)
;
}
}
finally
{
this
.
_isCustomizing
=
true
;
}
}
customizeDone
:
function
PTH_customizeDone
(
)
{
this
.
_isCustomizing
=
false
;
this
.
init
(
)
;
}
onPlaceholderCommand
(
)
{
let
widgetGroup
=
CustomizableUI
.
getWidget
(
"
personal
-
bookmarks
"
)
;
let
widget
=
widgetGroup
.
forWindow
(
window
)
;
if
(
widget
.
overflowed
|
|
widgetGroup
.
areaType
=
=
CustomizableUI
.
TYPE_PANEL
)
{
PlacesCommandHook
.
showPlacesOrganizer
(
"
BookmarksToolbar
"
)
;
}
}
_getParentToolbar
(
element
)
{
while
(
element
)
{
if
(
element
.
localName
=
=
"
toolbar
"
)
{
return
element
;
}
element
=
element
.
parentNode
;
}
return
null
;
}
onWidgetUnderflow
(
aNode
aContainer
)
{
let
win
=
aNode
.
ownerGlobal
;
if
(
aNode
.
id
=
=
"
personal
-
bookmarks
"
&
&
win
=
=
window
)
{
this
.
_resetView
(
)
;
}
}
onWidgetAdded
(
aWidgetId
aArea
aPosition
)
{
if
(
aWidgetId
=
=
"
personal
-
bookmarks
"
&
&
!
this
.
_isCustomizing
)
{
this
.
_resetView
(
)
;
}
}
_resetView
(
)
{
if
(
this
.
_viewElt
)
{
if
(
this
.
_viewElt
.
_placesView
)
{
this
.
_viewElt
.
_placesView
.
uninit
(
)
;
}
this
.
init
(
)
;
}
}
async
populateManagedBookmarks
(
popup
)
{
if
(
popup
.
hasChildNodes
(
)
)
{
return
;
}
popup
.
addEventListener
(
"
DOMMenuItemActive
"
function
(
event
)
{
XULBrowserWindow
.
setOverLink
(
event
.
target
.
link
)
;
}
)
;
popup
.
addEventListener
(
"
DOMMenuItemInactive
"
function
(
)
{
XULBrowserWindow
.
setOverLink
(
"
"
)
;
}
)
;
let
fragment
=
document
.
createDocumentFragment
(
)
;
await
this
.
addManagedBookmarks
(
fragment
Services
.
policies
.
getActivePolicies
(
)
.
ManagedBookmarks
)
;
popup
.
appendChild
(
fragment
)
;
}
async
addManagedBookmarks
(
menu
children
)
{
for
(
let
i
=
0
;
i
<
children
.
length
;
i
+
+
)
{
let
entry
=
children
[
i
]
;
if
(
entry
.
children
)
{
let
submenu
=
document
.
createXULElement
(
"
menu
"
)
;
if
(
entry
.
name
)
{
submenu
.
setAttribute
(
"
label
"
entry
.
name
)
;
}
else
{
document
.
l10n
.
setAttributes
(
submenu
"
managed
-
bookmarks
-
subfolder
"
)
;
}
submenu
.
setAttribute
(
"
container
"
"
true
"
)
;
submenu
.
classList
.
add
(
"
menu
-
iconic
"
"
bookmark
-
item
"
)
;
let
submenupopup
=
document
.
createXULElement
(
"
menupopup
"
)
;
submenu
.
appendChild
(
submenupopup
)
;
menu
.
appendChild
(
submenu
)
;
this
.
addManagedBookmarks
(
submenupopup
entry
.
children
)
;
}
else
if
(
entry
.
name
&
&
entry
.
url
)
{
let
{
preferredURI
}
=
Services
.
uriFixup
.
getFixupURIInfo
(
entry
.
url
)
;
let
menuitem
=
document
.
createXULElement
(
"
menuitem
"
)
;
menuitem
.
setAttribute
(
"
label
"
entry
.
name
)
;
menuitem
.
setAttribute
(
"
image
"
"
page
-
icon
:
"
+
preferredURI
.
spec
)
;
menuitem
.
classList
.
add
(
"
menuitem
-
iconic
"
"
menuitem
-
with
-
favicon
"
"
bookmark
-
item
"
)
;
menuitem
.
link
=
preferredURI
.
spec
;
menu
.
appendChild
(
menuitem
)
;
}
}
}
openManagedBookmark
(
event
)
{
openUILink
(
event
.
target
.
link
event
{
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
}
)
;
}
onDragStartManaged
(
event
)
{
if
(
!
event
.
target
.
link
)
{
return
;
}
let
dt
=
event
.
dataTransfer
;
let
node
=
{
}
;
node
.
type
=
0
;
node
.
title
=
event
.
target
.
label
;
node
.
uri
=
event
.
target
.
link
;
function
addData
(
type
index
)
{
let
wrapNode
=
PlacesUtils
.
wrapNode
(
node
type
)
;
dt
.
mozSetDataAt
(
type
wrapNode
index
)
;
}
addData
(
PlacesUtils
.
TYPE_X_MOZ_URL
0
)
;
addData
(
PlacesUtils
.
TYPE_PLAINTEXT
0
)
;
addData
(
PlacesUtils
.
TYPE_HTML
0
)
;
}
}
;
var
BookmarkingUI
=
{
STAR_ID
:
"
star
-
button
"
STAR_BOX_ID
:
"
star
-
button
-
box
"
BOOKMARK_BUTTON_ID
:
"
bookmarks
-
menu
-
button
"
BOOKMARK_BUTTON_SHORTCUT
:
"
addBookmarkAsKb
"
get
button
(
)
{
delete
this
.
button
;
let
widgetGroup
=
CustomizableUI
.
getWidget
(
this
.
BOOKMARK_BUTTON_ID
)
;
return
(
this
.
button
=
widgetGroup
.
forWindow
(
window
)
.
node
)
;
}
get
star
(
)
{
delete
this
.
star
;
return
(
this
.
star
=
document
.
getElementById
(
this
.
STAR_ID
)
)
;
}
get
starBox
(
)
{
delete
this
.
starBox
;
return
(
this
.
starBox
=
document
.
getElementById
(
this
.
STAR_BOX_ID
)
)
;
}
get
anchor
(
)
{
let
action
=
PageActions
.
actionForID
(
PageActions
.
ACTION_ID_BOOKMARK
)
;
return
BrowserPageActions
.
panelAnchorNodeForAction
(
action
)
;
}
get
stringbundleset
(
)
{
delete
this
.
stringbundleset
;
return
(
this
.
stringbundleset
=
document
.
getElementById
(
"
stringbundleset
"
)
)
;
}
get
toolbar
(
)
{
delete
this
.
toolbar
;
return
(
this
.
toolbar
=
document
.
getElementById
(
"
PersonalToolbar
"
)
)
;
}
STATUS_UPDATING
:
-
1
STATUS_UNSTARRED
:
0
STATUS_STARRED
:
1
get
status
(
)
{
if
(
this
.
_pendingUpdate
)
{
return
this
.
STATUS_UPDATING
;
}
return
this
.
star
.
hasAttribute
(
"
starred
"
)
?
this
.
STATUS_STARRED
:
this
.
STATUS_UNSTARRED
;
}
onPopupShowing
:
function
BUI_onPopupShowing
(
event
)
{
if
(
event
.
target
!
=
event
.
currentTarget
)
{
return
;
}
if
(
this
.
button
.
getAttribute
(
"
cui
-
areatype
"
)
=
=
CustomizableUI
.
TYPE_PANEL
|
|
this
.
button
.
hasAttribute
(
"
overflowedItem
"
)
)
{
this
.
_showSubView
(
)
;
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
return
;
}
let
widget
=
CustomizableUI
.
getWidget
(
this
.
BOOKMARK_BUTTON_ID
)
.
forWindow
(
window
)
;
if
(
widget
.
overflowed
)
{
event
.
preventDefault
(
)
;
widget
.
node
.
removeAttribute
(
"
closemenu
"
)
;
PlacesCommandHook
.
showPlacesOrganizer
(
"
BookmarksMenu
"
)
;
return
;
}
this
.
_initMobileBookmarks
(
document
.
getElementById
(
"
BMB_mobileBookmarks
"
)
)
;
this
.
updateLabel
(
"
BMB_viewBookmarksSidebar
"
SidebarUI
.
currentID
=
=
"
viewBookmarksSidebar
"
)
;
this
.
updateLabel
(
"
BMB_viewBookmarksToolbar
"
!
this
.
toolbar
.
collapsed
)
;
}
updateLabel
(
elementId
visible
)
{
let
element
=
PanelMultiView
.
getViewNode
(
document
elementId
)
;
let
l10nID
=
element
.
getAttribute
(
"
data
-
l10n
-
id
"
)
;
document
.
l10n
.
setAttributes
(
element
l10nID
{
isVisible
:
!
!
visible
}
)
;
}
toggleBookmarksToolbar
(
reason
)
{
let
newState
=
this
.
toolbar
.
collapsed
?
"
always
"
:
"
never
"
;
Services
.
prefs
.
setCharPref
(
"
browser
.
toolbars
.
bookmarks
.
visibility
"
newState
)
;
CustomizableUI
.
setToolbarVisibility
(
this
.
toolbar
.
id
newState
false
)
;
BrowserUsageTelemetry
.
recordToolbarVisibility
(
this
.
toolbar
.
id
newState
reason
)
;
}
isOnNewTabPage
(
uri
)
{
if
(
!
uri
)
{
return
false
;
}
let
newTabURL
=
Cu
.
isESModuleLoaded
(
"
resource
:
/
/
/
modules
/
AboutNewTab
.
sys
.
mjs
"
)
?
AboutNewTab
.
newTabURL
:
"
about
:
newtab
"
;
if
(
newTabURL
=
=
"
about
:
blank
"
)
{
newTabURL
=
"
about
:
newtab
"
;
}
let
newTabURLs
=
[
newTabURL
"
about
:
home
"
"
chrome
:
/
/
browser
/
content
/
blanktab
.
html
"
]
;
if
(
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
{
newTabURLs
.
push
(
"
about
:
privatebrowsing
"
)
;
}
return
newTabURLs
.
some
(
newTabUriString
=
>
this
.
_newTabURI
(
newTabUriString
)
?
.
equalsExceptRef
(
uri
)
)
;
}
_newTabURI
(
uriString
)
{
let
uri
=
this
.
_newTabURICache
.
get
(
uriString
)
;
if
(
uri
=
=
=
undefined
)
{
uri
=
Services
.
io
.
newURI
(
uriString
)
;
this
.
_newTabURICache
.
set
(
uriString
uri
)
;
}
return
uri
;
}
_newTabURICache
:
new
Map
(
)
buildBookmarksToolbarSubmenu
(
toolbar
)
{
let
alwaysShowMenuItem
=
document
.
createXULElement
(
"
menuitem
"
)
;
let
alwaysHideMenuItem
=
document
.
createXULElement
(
"
menuitem
"
)
;
let
showOnNewTabMenuItem
=
document
.
createXULElement
(
"
menuitem
"
)
;
let
menuPopup
=
document
.
createXULElement
(
"
menupopup
"
)
;
menuPopup
.
append
(
alwaysShowMenuItem
showOnNewTabMenuItem
alwaysHideMenuItem
)
;
let
menu
=
document
.
createXULElement
(
"
menu
"
)
;
menu
.
appendChild
(
menuPopup
)
;
menu
.
setAttribute
(
"
label
"
toolbar
.
getAttribute
(
"
toolbarname
"
)
)
;
menu
.
setAttribute
(
"
id
"
"
toggle_
"
+
toolbar
.
id
)
;
menu
.
setAttribute
(
"
accesskey
"
toolbar
.
getAttribute
(
"
accesskey
"
)
)
;
menu
.
setAttribute
(
"
toolbarId
"
toolbar
.
id
)
;
menu
.
setAttribute
(
"
selection
-
type
"
"
none
|
single
"
)
;
MozXULElement
.
insertFTLIfNeeded
(
"
browser
/
toolbarContextMenu
.
ftl
"
)
;
let
menuItems
=
[
[
showOnNewTabMenuItem
"
toolbar
-
context
-
menu
-
bookmarks
-
toolbar
-
on
-
new
-
tab
-
2
"
"
newtab
"
]
[
alwaysShowMenuItem
"
toolbar
-
context
-
menu
-
bookmarks
-
toolbar
-
always
-
show
-
2
"
"
always
"
]
[
alwaysHideMenuItem
"
toolbar
-
context
-
menu
-
bookmarks
-
toolbar
-
never
-
show
-
2
"
"
never
"
]
]
;
menuItems
.
map
(
(
[
menuItem
l10nId
visibilityEnum
]
)
=
>
{
document
.
l10n
.
setAttributes
(
menuItem
l10nId
)
;
menuItem
.
setAttribute
(
"
type
"
"
radio
"
)
;
menuItem
.
setAttribute
(
"
checked
"
gBookmarksToolbarVisibility
=
=
visibilityEnum
)
;
menuItem
.
dataset
.
bookmarksToolbarVisibility
=
true
;
menuItem
.
dataset
.
visibilityEnum
=
visibilityEnum
;
menuItem
.
addEventListener
(
"
command
"
onViewToolbarCommand
)
;
}
)
;
let
menuItemForNextStateFromKbShortcut
=
gBookmarksToolbarVisibility
=
=
"
never
"
?
alwaysShowMenuItem
:
alwaysHideMenuItem
;
menuItemForNextStateFromKbShortcut
.
setAttribute
(
"
key
"
"
viewBookmarksToolbarKb
"
)
;
return
menu
;
}
async
updateEmptyToolbarMessage
(
)
{
let
checkNumBookmarksOnToolbar
=
false
;
let
hasVisibleChildren
=
(
(
)
=
>
{
if
(
this
.
toolbar
.
querySelector
(
:
scope
>
toolbarpaletteitem
>
toolbarbutton
:
not
(
[
hidden
]
)
:
scope
>
toolbarpaletteitem
>
toolbaritem
:
not
(
[
hidden
]
#
personal
-
bookmarks
)
:
scope
>
toolbarbutton
:
not
(
[
hidden
]
)
:
scope
>
toolbaritem
:
not
(
[
hidden
]
#
personal
-
bookmarks
)
)
)
{
return
true
;
}
if
(
!
this
.
toolbar
.
hasAttribute
(
"
initialized
"
)
&
&
!
this
.
_isCustomizing
)
{
return
false
;
}
let
bookmarksToolbarItemsPlacement
=
CustomizableUI
.
getPlacementOfWidget
(
"
personal
-
bookmarks
"
)
;
let
bookmarksItemInToolbar
=
bookmarksToolbarItemsPlacement
?
.
area
=
=
CustomizableUI
.
AREA_BOOKMARKS
;
if
(
!
bookmarksItemInToolbar
)
{
return
false
;
}
if
(
this
.
_isCustomizing
)
{
return
true
;
}
if
(
this
.
toolbar
.
querySelector
(
#
PlacesToolbarItems
>
toolbarseparator
#
PlacesToolbarItems
>
toolbarbutton
)
)
{
return
true
;
}
checkNumBookmarksOnToolbar
=
true
;
return
false
;
}
)
(
)
;
if
(
checkNumBookmarksOnToolbar
)
{
hasVisibleChildren
=
!
(
await
PlacesToolbarHelper
.
getIsEmpty
(
)
)
;
}
let
emptyMsg
=
document
.
getElementById
(
"
personal
-
toolbar
-
empty
"
)
;
emptyMsg
.
hidden
=
hasVisibleChildren
;
emptyMsg
.
toggleAttribute
(
"
nowidth
"
!
hasVisibleChildren
)
;
}
openLibraryIfLinkClicked
(
event
)
{
if
(
(
(
event
.
type
=
=
"
click
"
&
&
event
.
button
=
=
0
)
|
|
(
event
.
type
=
=
"
keydown
"
&
&
event
.
keyCode
=
=
KeyEvent
.
DOM_VK_RETURN
)
)
&
&
event
.
target
.
localName
=
=
"
a
"
)
{
PlacesCommandHook
.
showPlacesOrganizer
(
"
BookmarksToolbar
"
)
;
}
}
MOBILE_BOOKMARKS_PREF
:
"
browser
.
bookmarks
.
showMobileBookmarks
"
_shouldShowMobileBookmarks
(
)
{
return
Services
.
prefs
.
getBoolPref
(
this
.
MOBILE_BOOKMARKS_PREF
false
)
;
}
_initMobileBookmarks
(
mobileMenuItem
)
{
mobileMenuItem
.
hidden
=
!
this
.
_shouldShowMobileBookmarks
(
)
;
}
_uninitView
:
function
BUI__uninitView
(
)
{
if
(
this
.
button
.
_placesView
)
{
this
.
button
.
_placesView
.
uninit
(
)
;
}
let
menubar
=
document
.
getElementById
(
"
bookmarksMenu
"
)
;
if
(
menubar
&
&
menubar
.
_placesView
)
{
menubar
.
_placesView
.
uninit
(
)
;
}
const
kSpecialViewNodeIDs
=
[
"
BMB_bookmarksToolbar
"
"
BMB_unsortedBookmarks
"
]
;
for
(
let
viewNodeID
of
kSpecialViewNodeIDs
)
{
let
elem
=
document
.
getElementById
(
viewNodeID
)
;
if
(
elem
&
&
elem
.
_placesView
)
{
elem
.
_placesView
.
uninit
(
)
;
}
}
}
onCustomizeStart
:
function
BUI_customizeStart
(
aWindow
)
{
if
(
aWindow
=
=
window
)
{
this
.
_uninitView
(
)
;
this
.
_isCustomizing
=
true
;
this
.
updateEmptyToolbarMessage
(
)
.
catch
(
console
.
error
)
;
let
isVisible
=
Services
.
prefs
.
getCharPref
(
"
browser
.
toolbars
.
bookmarks
.
visibility
"
"
newtab
"
)
!
=
"
never
"
;
setToolbarVisibility
(
this
.
toolbar
isVisible
false
)
;
}
}
onWidgetAdded
:
function
BUI_widgetAdded
(
aWidgetId
aArea
)
{
if
(
aWidgetId
=
=
this
.
BOOKMARK_BUTTON_ID
)
{
this
.
_onWidgetWasMoved
(
)
;
}
if
(
aArea
=
=
CustomizableUI
.
AREA_BOOKMARKS
)
{
this
.
updateEmptyToolbarMessage
(
)
.
catch
(
console
.
error
)
;
}
}
onWidgetRemoved
:
function
BUI_widgetRemoved
(
aWidgetId
aOldArea
)
{
if
(
aWidgetId
=
=
this
.
BOOKMARK_BUTTON_ID
)
{
this
.
_onWidgetWasMoved
(
)
;
}
if
(
aOldArea
=
=
CustomizableUI
.
AREA_BOOKMARKS
)
{
this
.
updateEmptyToolbarMessage
(
)
.
catch
(
console
.
error
)
;
}
}
onWidgetReset
:
function
BUI_widgetReset
(
aNode
aContainer
)
{
if
(
aNode
=
=
this
.
button
)
{
this
.
_onWidgetWasMoved
(
)
;
}
}
onWidgetUndoMove
:
function
BUI_undoWidgetUndoMove
(
aNode
aContainer
)
{
if
(
aNode
=
=
this
.
button
)
{
this
.
_onWidgetWasMoved
(
)
;
}
}
onWidgetBeforeDOMChange
:
function
BUI_onWidgetBeforeDOMChange
(
aNode
aNextNode
aContainer
aIsRemoval
)
{
if
(
aNode
.
id
=
=
"
import
-
button
"
)
{
this
.
_updateImportButton
(
aNode
aIsRemoval
?
null
:
aContainer
)
;
}
}
_updateImportButton
:
function
BUI_updateImportButton
(
aNode
aContainer
)
{
let
isBookmarkItem
=
aContainer
=
=
this
.
toolbar
;
aNode
.
classList
.
toggle
(
"
toolbarbutton
-
1
"
!
isBookmarkItem
)
;
aNode
.
classList
.
toggle
(
"
bookmark
-
item
"
isBookmarkItem
)
;
}
_onWidgetWasMoved
:
function
BUI_widgetWasMoved
(
)
{
if
(
!
this
.
_isCustomizing
)
{
this
.
_uninitView
(
)
;
}
}
onCustomizeEnd
:
function
BUI_customizeEnd
(
aWindow
)
{
if
(
aWindow
=
=
window
)
{
this
.
_isCustomizing
=
false
;
this
.
updateEmptyToolbarMessage
(
)
.
catch
(
console
.
error
)
;
}
}
init
(
)
{
CustomizableUI
.
addListener
(
this
)
;
let
importButton
=
document
.
getElementById
(
"
import
-
button
"
)
;
if
(
importButton
)
{
this
.
_updateImportButton
(
importButton
importButton
.
parentNode
)
;
}
this
.
updateEmptyToolbarMessage
(
)
.
catch
(
console
.
error
)
;
}
_hasBookmarksObserver
:
false
_itemGuids
:
new
Set
(
)
uninit
:
function
BUI_uninit
(
)
{
this
.
updateBookmarkPageMenuItem
(
true
)
;
CustomizableUI
.
removeListener
(
this
)
;
this
.
_uninitView
(
)
;
if
(
this
.
_hasBookmarksObserver
)
{
PlacesUtils
.
observers
.
removeListener
(
[
"
bookmark
-
added
"
"
bookmark
-
removed
"
"
bookmark
-
moved
"
"
bookmark
-
url
-
changed
"
]
this
.
handlePlacesEvents
)
;
}
if
(
this
.
_pendingUpdate
)
{
delete
this
.
_pendingUpdate
;
}
}
onLocationChange
:
function
BUI_onLocationChange
(
)
{
if
(
this
.
_uri
&
&
gBrowser
.
currentURI
.
equals
(
this
.
_uri
)
)
{
return
;
}
this
.
updateStarState
(
)
;
}
updateStarState
:
function
BUI_updateStarState
(
)
{
this
.
_uri
=
gBrowser
.
currentURI
;
this
.
_itemGuids
.
clear
(
)
;
let
guids
=
new
Set
(
)
;
let
pendingUpdate
=
(
this
.
_pendingUpdate
=
{
}
)
;
PlacesUtils
.
bookmarks
.
fetch
(
{
url
:
this
.
_uri
}
b
=
>
guids
.
add
(
b
.
guid
)
{
concurrent
:
true
}
)
.
catch
(
console
.
error
)
.
then
(
(
)
=
>
{
if
(
pendingUpdate
!
=
this
.
_pendingUpdate
)
{
return
;
}
if
(
this
.
_itemGuids
.
size
>
0
)
{
this
.
_itemGuids
=
new
Set
(
.
.
.
this
.
_itemGuids
.
.
.
guids
)
;
}
else
{
this
.
_itemGuids
=
guids
;
}
this
.
_updateStar
(
)
;
if
(
!
this
.
_hasBookmarksObserver
)
{
try
{
this
.
handlePlacesEvents
=
this
.
handlePlacesEvents
.
bind
(
this
)
;
PlacesUtils
.
observers
.
addListener
(
[
"
bookmark
-
added
"
"
bookmark
-
removed
"
"
bookmark
-
moved
"
"
bookmark
-
url
-
changed
"
]
this
.
handlePlacesEvents
)
;
this
.
_hasBookmarksObserver
=
true
;
}
catch
(
ex
)
{
console
.
error
(
"
BookmarkingUI
failed
adding
a
bookmarks
observer
:
"
ex
)
;
}
}
delete
this
.
_pendingUpdate
;
}
)
;
}
_updateStar
:
function
BUI__updateStar
(
)
{
let
starred
=
this
.
_itemGuids
.
size
>
0
;
for
(
let
element
of
[
this
.
star
document
.
getElementById
(
"
context
-
bookmarkpage
"
)
PanelMultiView
.
getViewNode
(
document
"
panelMenuBookmarkThisPage
"
)
document
.
getElementById
(
"
pageAction
-
panel
-
bookmark
"
)
]
)
{
if
(
!
element
)
{
continue
;
}
if
(
starred
)
{
element
.
setAttribute
(
"
starred
"
"
true
"
)
;
}
else
{
element
.
removeAttribute
(
"
starred
"
)
;
}
}
if
(
!
this
.
starBox
)
{
this
.
updateBookmarkPageMenuItem
(
true
)
;
return
;
}
let
shortcut
=
document
.
getElementById
(
this
.
BOOKMARK_BUTTON_SHORTCUT
)
;
let
l10nArgs
=
{
shortcut
:
ShortcutUtils
.
prettifyShortcut
(
shortcut
)
}
;
document
.
l10n
.
setAttributes
(
this
.
starBox
starred
?
"
urlbar
-
star
-
edit
-
bookmark
"
:
"
urlbar
-
star
-
add
-
bookmark
"
l10nArgs
)
;
this
.
updateBookmarkPageMenuItem
(
)
;
Services
.
obs
.
notifyObservers
(
null
"
bookmark
-
icon
-
updated
"
starred
?
"
starred
"
:
"
unstarred
"
)
;
}
updateBookmarkPageMenuItem
(
forceReset
=
false
)
{
let
isStarred
=
!
forceReset
&
&
this
.
_itemGuids
.
size
>
0
;
let
menuItemL10nId
=
isStarred
?
"
menu
-
edit
-
bookmark
"
:
"
menu
-
bookmark
-
tab
"
;
let
menuItem
=
document
.
getElementById
(
"
menu_bookmarkThisPage
"
)
;
if
(
menuItem
)
{
document
.
l10n
.
setAttributes
(
menuItem
menuItemL10nId
)
;
}
let
panelMenuItemL10nId
=
isStarred
?
"
bookmarks
-
subview
-
edit
-
bookmark
"
:
"
bookmarks
-
subview
-
bookmark
-
tab
"
;
let
panelMenuToolbarButton
=
PanelMultiView
.
getViewNode
(
document
"
panelMenuBookmarkThisPage
"
)
;
if
(
panelMenuToolbarButton
)
{
document
.
l10n
.
setAttributes
(
panelMenuToolbarButton
panelMenuItemL10nId
)
;
}
let
contextItem
=
document
.
getElementById
(
"
context
-
bookmarkpage
"
)
;
if
(
contextItem
)
{
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
let
contextItemL10nId
=
isStarred
?
"
main
-
context
-
menu
-
edit
-
bookmark
-
mac
"
:
"
main
-
context
-
menu
-
bookmark
-
page
-
mac
"
;
document
.
l10n
.
setAttributes
(
contextItem
contextItemL10nId
)
;
}
else
{
let
shortcutElem
=
document
.
getElementById
(
this
.
BOOKMARK_BUTTON_SHORTCUT
)
;
if
(
shortcutElem
)
{
let
shortcut
=
ShortcutUtils
.
prettifyShortcut
(
shortcutElem
)
;
let
contextItemL10nId
=
isStarred
?
"
main
-
context
-
menu
-
edit
-
bookmark
-
with
-
shortcut
"
:
"
main
-
context
-
menu
-
bookmark
-
page
-
with
-
shortcut
"
;
let
l10nArgs
=
{
shortcut
}
;
document
.
l10n
.
setAttributes
(
contextItem
contextItemL10nId
l10nArgs
)
;
}
else
{
let
contextItemL10nId
=
isStarred
?
"
main
-
context
-
menu
-
edit
-
bookmark
"
:
"
main
-
context
-
menu
-
bookmark
-
page
"
;
document
.
l10n
.
setAttributes
(
contextItem
contextItemL10nId
)
;
}
}
}
if
(
document
.
getElementById
(
"
page
-
action
-
buttons
"
)
)
{
this
.
_latestMenuItemL10nId
=
menuItemL10nId
;
document
.
l10n
.
formatMessages
(
[
{
id
:
menuItemL10nId
}
]
)
.
then
(
l10n
=
>
{
if
(
this
.
_latestMenuItemL10nId
!
=
menuItemL10nId
)
{
return
;
}
let
label
=
l10n
[
0
]
.
attributes
[
0
]
.
value
;
let
panelButton
=
BrowserPageActions
.
panelButtonNodeForActionID
(
PageActions
.
ACTION_ID_BOOKMARK
)
;
if
(
panelButton
)
{
panelButton
.
setAttribute
(
"
label
"
label
)
;
}
}
)
;
}
}
onMainMenuPopupShowing
:
function
BUI_onMainMenuPopupShowing
(
event
)
{
if
(
event
.
target
!
=
event
.
currentTarget
)
{
return
;
}
this
.
_initMobileBookmarks
(
document
.
getElementById
(
"
menu_mobileBookmarks
"
)
)
;
}
showSubView
(
anchor
)
{
this
.
_showSubView
(
null
anchor
)
;
}
_showSubView
(
event
anchor
=
document
.
getElementById
(
this
.
BOOKMARK_BUTTON_ID
)
)
{
let
view
=
PanelMultiView
.
getViewNode
(
document
"
PanelUI
-
bookmarks
"
)
;
view
.
addEventListener
(
"
ViewShowing
"
this
)
;
view
.
addEventListener
(
"
ViewHiding
"
this
)
;
anchor
.
setAttribute
(
"
closemenu
"
"
none
"
)
;
this
.
updateLabel
(
"
panelMenu_viewBookmarksToolbar
"
!
this
.
toolbar
.
collapsed
)
;
PanelUI
.
showSubView
(
"
PanelUI
-
bookmarks
"
anchor
event
)
;
}
onCommand
:
function
BUI_onCommand
(
aEvent
)
{
if
(
aEvent
.
target
!
=
aEvent
.
currentTarget
)
{
return
;
}
if
(
this
.
button
.
getAttribute
(
"
cui
-
areatype
"
)
=
=
CustomizableUI
.
TYPE_PANEL
)
{
this
.
_showSubView
(
aEvent
)
;
return
;
}
let
widget
=
CustomizableUI
.
getWidget
(
this
.
BOOKMARK_BUTTON_ID
)
.
forWindow
(
window
)
;
if
(
widget
.
overflowed
)
{
widget
.
node
.
removeAttribute
(
"
closemenu
"
)
;
}
this
.
onStarCommand
(
aEvent
)
;
}
onStarCommand
(
aEvent
)
{
if
(
!
this
.
_pendingUpdate
&
&
(
aEvent
.
type
!
=
"
click
"
|
|
aEvent
.
button
=
=
0
)
)
{
PlacesCommandHook
.
bookmarkPage
(
)
;
}
}
handleEvent
:
function
BUI_handleEvent
(
aEvent
)
{
switch
(
aEvent
.
type
)
{
case
"
ViewShowing
"
:
this
.
onPanelMenuViewShowing
(
aEvent
)
;
break
;
case
"
ViewHiding
"
:
this
.
onPanelMenuViewHiding
(
aEvent
)
;
break
;
}
}
onPanelMenuViewShowing
:
function
BUI_onViewShowing
(
aEvent
)
{
let
panelview
=
aEvent
.
target
;
let
staticButtons
=
panelview
.
getElementsByTagName
(
"
toolbarbutton
"
)
;
for
(
let
i
=
0
l
=
staticButtons
.
length
;
i
<
l
;
+
+
i
)
{
CustomizableUI
.
addShortcut
(
staticButtons
[
i
]
)
;
}
let
query
=
"
place
:
queryType
=
"
+
Ci
.
nsINavHistoryQueryOptions
.
QUERY_TYPE_BOOKMARKS
+
"
&
sort
=
"
+
Ci
.
nsINavHistoryQueryOptions
.
SORT_BY_DATEADDED_DESCENDING
+
"
&
maxResults
=
42
&
excludeQueries
=
1
"
;
this
.
_panelMenuView
=
new
PlacesPanelview
(
query
document
.
getElementById
(
"
panelMenu_bookmarksMenu
"
)
panelview
)
;
panelview
.
removeEventListener
(
"
ViewShowing
"
this
)
;
}
onPanelMenuViewHiding
:
function
BUI_onViewHiding
(
aEvent
)
{
this
.
_panelMenuView
.
uninit
(
)
;
delete
this
.
_panelMenuView
;
aEvent
.
target
.
removeEventListener
(
"
ViewHiding
"
this
)
;
}
handlePlacesEvents
(
aEvents
)
{
let
isStarUpdateNeeded
=
false
;
let
affectsOtherBookmarksFolder
=
false
;
let
affectsBookmarksToolbarFolder
=
false
;
for
(
let
ev
of
aEvents
)
{
switch
(
ev
.
type
)
{
case
"
bookmark
-
added
"
:
if
(
this
.
_itemGuids
.
size
=
=
0
)
{
if
(
ev
.
url
&
&
ev
.
url
=
=
this
.
_uri
.
spec
)
{
if
(
!
this
.
_itemGuids
.
has
(
ev
.
guid
)
)
{
this
.
_itemGuids
.
add
(
ev
.
guid
)
;
isStarUpdateNeeded
=
true
;
}
}
}
if
(
ev
.
parentGuid
=
=
=
PlacesUtils
.
bookmarks
.
toolbarGuid
)
{
Services
.
telemetry
.
scalarAdd
(
"
browser
.
engagement
.
bookmarks_toolbar_bookmark_added
"
1
)
;
}
if
(
ev
.
parentGuid
=
=
PlacesUtils
.
bookmarks
.
tagsGuid
)
{
StarUI
.
userHasTags
=
true
;
}
break
;
case
"
bookmark
-
removed
"
:
if
(
this
.
_itemGuids
.
has
(
ev
.
guid
)
)
{
this
.
_itemGuids
.
delete
(
ev
.
guid
)
;
if
(
this
.
_itemGuids
.
size
=
=
0
)
{
isStarUpdateNeeded
=
true
;
}
}
PlacesUIUtils
.
defaultParentGuid
.
then
(
parentGuid
=
>
{
if
(
ev
.
itemType
=
=
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
&
&
ev
.
guid
=
=
parentGuid
)
{
Services
.
prefs
.
setCharPref
(
"
browser
.
bookmarks
.
defaultLocation
"
PlacesUtils
.
bookmarks
.
toolbarGuid
)
;
}
}
)
;
break
;
case
"
bookmark
-
moved
"
:
if
(
ev
.
parentGuid
=
=
=
PlacesUtils
.
bookmarks
.
unfiledGuid
|
|
ev
.
oldParentGuid
=
=
=
PlacesUtils
.
bookmarks
.
unfiledGuid
)
{
affectsOtherBookmarksFolder
=
true
;
}
if
(
ev
.
parentGuid
=
=
PlacesUtils
.
bookmarks
.
toolbarGuid
|
|
ev
.
oldParentGuid
=
=
PlacesUtils
.
bookmarks
.
toolbarGuid
)
{
affectsBookmarksToolbarFolder
=
true
;
if
(
ev
.
oldParentGuid
!
=
PlacesUtils
.
bookmarks
.
toolbarGuid
)
{
Services
.
telemetry
.
scalarAdd
(
"
browser
.
engagement
.
bookmarks_toolbar_bookmark_added
"
1
)
;
}
}
break
;
case
"
bookmark
-
url
-
changed
"
:
if
(
this
.
_itemGuids
.
has
(
ev
.
guid
)
&
&
ev
.
url
!
=
this
.
_uri
.
spec
)
{
this
.
_itemGuids
.
delete
(
ev
.
guid
)
;
if
(
this
.
_itemGuids
.
size
=
=
0
)
{
this
.
_updateStar
(
)
;
}
}
else
if
(
!
this
.
_itemGuids
.
has
(
ev
.
guid
)
&
&
ev
.
url
=
=
this
.
_uri
.
spec
)
{
this
.
_itemGuids
.
add
(
ev
.
guid
)
;
if
(
this
.
_itemGuids
.
size
=
=
1
)
{
this
.
_updateStar
(
)
;
}
}
break
;
}
if
(
ev
.
parentGuid
=
=
PlacesUtils
.
bookmarks
.
unfiledGuid
)
{
affectsOtherBookmarksFolder
=
true
;
}
else
if
(
ev
.
parentGuid
=
=
PlacesUtils
.
bookmarks
.
toolbarGuid
)
{
affectsBookmarksToolbarFolder
=
true
;
}
}
if
(
isStarUpdateNeeded
)
{
this
.
_updateStar
(
)
;
}
Services
.
tm
.
dispatchToMainThread
(
(
)
=
>
{
if
(
affectsOtherBookmarksFolder
)
{
this
.
maybeShowOtherBookmarksFolder
(
)
.
catch
(
console
.
error
)
;
}
if
(
affectsBookmarksToolbarFolder
)
{
this
.
updateEmptyToolbarMessage
(
)
.
catch
(
console
.
error
)
;
}
}
)
;
}
onWidgetUnderflow
(
aNode
aContainer
)
{
let
win
=
aNode
.
ownerGlobal
;
if
(
aNode
.
id
!
=
this
.
BOOKMARK_BUTTON_ID
|
|
win
!
=
window
)
{
return
;
}
this
.
_uninitView
(
)
;
}
async
maybeShowOtherBookmarksFolder
(
)
{
let
toolbar
=
document
.
getElementById
(
"
PlacesToolbar
"
)
;
if
(
!
toolbar
?
.
_placesView
)
{
return
;
}
let
placement
=
CustomizableUI
.
getPlacementOfWidget
(
"
personal
-
bookmarks
"
)
;
let
otherBookmarks
=
document
.
getElementById
(
"
OtherBookmarks
"
)
;
if
(
!
SHOW_OTHER_BOOKMARKS
|
|
placement
?
.
area
!
=
CustomizableUI
.
AREA_BOOKMARKS
)
{
if
(
otherBookmarks
)
{
otherBookmarks
.
hidden
=
true
;
}
return
;
}
let
instance
=
(
this
.
_showOtherBookmarksInstance
=
{
}
)
;
let
unfiledGuid
=
PlacesUtils
.
bookmarks
.
unfiledGuid
;
let
numberOfBookmarks
=
(
await
PlacesUtils
.
bookmarks
.
fetch
(
unfiledGuid
)
)
.
childCount
;
if
(
instance
!
=
this
.
_showOtherBookmarksInstance
)
{
return
;
}
if
(
numberOfBookmarks
>
0
)
{
if
(
!
otherBookmarks
)
{
const
node
=
PlacesUtils
.
getFolderContents
(
unfiledGuid
)
.
root
;
otherBookmarks
=
this
.
buildOtherBookmarksFolder
(
node
)
;
}
otherBookmarks
.
hidden
=
false
;
}
else
if
(
otherBookmarks
)
{
otherBookmarks
.
hidden
=
true
;
}
}
buildShowOtherBookmarksMenuItem
(
)
{
let
menuItem
=
document
.
createXULElement
(
"
menuitem
"
)
;
menuItem
.
setAttribute
(
"
id
"
"
show
-
other
-
bookmarks_PersonalToolbar
"
)
;
menuItem
.
setAttribute
(
"
toolbarId
"
"
PersonalToolbar
"
)
;
menuItem
.
setAttribute
(
"
type
"
"
checkbox
"
)
;
menuItem
.
setAttribute
(
"
checked
"
SHOW_OTHER_BOOKMARKS
)
;
menuItem
.
setAttribute
(
"
selection
-
type
"
"
none
|
single
"
)
;
menuItem
.
setAttribute
(
"
start
-
disabled
"
"
true
"
)
;
MozXULElement
.
insertFTLIfNeeded
(
"
browser
/
toolbarContextMenu
.
ftl
"
)
;
document
.
l10n
.
setAttributes
(
menuItem
"
toolbar
-
context
-
menu
-
bookmarks
-
show
-
other
-
bookmarks
"
)
;
menuItem
.
addEventListener
(
"
command
"
(
)
=
>
{
Services
.
prefs
.
setBoolPref
(
"
browser
.
toolbars
.
bookmarks
.
showOtherBookmarks
"
!
SHOW_OTHER_BOOKMARKS
)
;
}
)
;
PlacesUtils
.
bookmarks
.
fetch
(
PlacesUtils
.
bookmarks
.
unfiledGuid
)
.
then
(
bm
=
>
{
if
(
bm
.
childCount
)
{
menuItem
.
disabled
=
false
;
}
}
)
;
return
menuItem
;
}
buildOtherBookmarksFolder
(
node
)
{
let
otherBookmarksButton
=
document
.
createXULElement
(
"
toolbarbutton
"
)
;
otherBookmarksButton
.
setAttribute
(
"
type
"
"
menu
"
)
;
otherBookmarksButton
.
setAttribute
(
"
container
"
"
true
"
)
;
otherBookmarksButton
.
setAttribute
(
"
onpopupshowing
"
"
document
.
getElementById
(
'
PlacesToolbar
'
)
.
_placesView
.
_onOtherBookmarksPopupShowing
(
event
)
;
"
)
;
otherBookmarksButton
.
id
=
"
OtherBookmarks
"
;
otherBookmarksButton
.
className
=
"
bookmark
-
item
"
;
otherBookmarksButton
.
hidden
=
"
true
"
;
MozXULElement
.
insertFTLIfNeeded
(
"
browser
/
places
.
ftl
"
)
;
document
.
l10n
.
setAttributes
(
otherBookmarksButton
"
other
-
bookmarks
-
folder
"
)
;
let
otherBookmarksPopup
=
document
.
createXULElement
(
"
menupopup
"
{
is
:
"
places
-
popup
"
}
)
;
otherBookmarksPopup
.
setAttribute
(
"
placespopup
"
"
true
"
)
;
otherBookmarksPopup
.
setAttribute
(
"
context
"
"
placesContext
"
)
;
otherBookmarksPopup
.
classList
.
add
(
"
toolbar
-
menupopup
"
)
;
otherBookmarksPopup
.
id
=
"
OtherBookmarksPopup
"
;
otherBookmarksPopup
.
_placesNode
=
PlacesUtils
.
asContainer
(
node
)
;
otherBookmarksButton
.
_placesNode
=
PlacesUtils
.
asContainer
(
node
)
;
otherBookmarksButton
.
appendChild
(
otherBookmarksPopup
)
;
let
chevronButton
=
document
.
getElementById
(
"
PlacesChevron
"
)
;
chevronButton
.
parentNode
.
append
(
otherBookmarksButton
)
;
let
placesToolbar
=
document
.
getElementById
(
"
PlacesToolbar
"
)
;
placesToolbar
.
_placesView
.
_otherBookmarks
=
otherBookmarksButton
;
placesToolbar
.
_placesView
.
_otherBookmarksPopup
=
otherBookmarksPopup
;
return
otherBookmarksButton
;
}
}
;
