const
formatter
=
new
Intl
.
DateTimeFormat
(
"
default
"
)
;
const
TLS_ERROR_REPORT_TELEMETRY_AUTO_CHECKED
=
2
;
const
TLS_ERROR_REPORT_TELEMETRY_AUTO_UNCHECKED
=
3
;
const
TLS_ERROR_REPORT_TELEMETRY_UI_SHOWN
=
0
;
let
searchParams
=
new
URLSearchParams
(
document
.
documentURI
.
split
(
"
?
"
)
[
1
]
)
;
let
gIsCertError
;
function
getErrorCode
(
)
{
return
searchParams
.
get
(
"
e
"
)
;
}
function
getCSSClass
(
)
{
return
searchParams
.
get
(
"
s
"
)
;
}
function
getDescription
(
)
{
return
searchParams
.
get
(
"
d
"
)
;
}
function
isCaptive
(
)
{
return
searchParams
.
get
(
"
captive
"
)
=
=
"
true
"
;
}
function
retryThis
(
buttonEl
)
{
RPMSendAsyncMessage
(
"
Browser
:
EnableOnlineMode
"
)
;
buttonEl
.
disabled
=
true
;
}
function
toggleDisplay
(
node
)
{
const
toggle
=
{
"
"
:
"
block
"
none
:
"
block
"
block
:
"
none
"
}
;
return
(
node
.
style
.
display
=
toggle
[
node
.
style
.
display
]
)
;
}
function
showCertificateErrorReporting
(
)
{
document
.
getElementById
(
"
certificateErrorReporting
"
)
.
style
.
display
=
"
block
"
;
}
function
showPrefChangeContainer
(
)
{
const
panel
=
document
.
getElementById
(
"
prefChangeContainer
"
)
;
panel
.
style
.
display
=
"
block
"
;
document
.
getElementById
(
"
netErrorButtonContainer
"
)
.
style
.
display
=
"
none
"
;
document
.
getElementById
(
"
prefResetButton
"
)
.
addEventListener
(
"
click
"
function
resetPreferences
(
)
{
RPMSendAsyncMessage
(
"
Browser
:
ResetSSLPreferences
"
)
;
}
)
;
addAutofocus
(
"
#
prefResetButton
"
"
beforeend
"
)
;
}
function
showTls10Container
(
)
{
const
panel
=
document
.
getElementById
(
"
enableTls10Container
"
)
;
panel
.
style
.
display
=
"
block
"
;
document
.
getElementById
(
"
netErrorButtonContainer
"
)
.
style
.
display
=
"
none
"
;
const
button
=
document
.
getElementById
(
"
enableTls10Button
"
)
;
button
.
addEventListener
(
"
click
"
function
enableTls10
(
e
)
{
RPMSetBoolPref
(
"
security
.
tls
.
version
.
enable
-
deprecated
"
true
)
;
retryThis
(
button
)
;
}
)
;
addAutofocus
(
"
#
enableTls10Button
"
"
beforeend
"
)
;
}
function
setupAdvancedButton
(
)
{
var
panel
=
document
.
getElementById
(
"
badCertAdvancedPanel
"
)
;
for
(
var
span
of
panel
.
querySelectorAll
(
"
span
.
hostname
"
)
)
{
span
.
textContent
=
document
.
location
.
hostname
;
}
document
.
getElementById
(
"
advancedButton
"
)
.
addEventListener
(
"
click
"
togglePanelVisibility
)
;
function
togglePanelVisibility
(
)
{
toggleDisplay
(
panel
)
;
if
(
gIsCertError
)
{
var
div
=
document
.
getElementById
(
"
certificateErrorDebugInformation
"
)
;
div
.
style
.
display
=
"
none
"
;
}
if
(
panel
.
style
.
display
=
=
"
block
"
)
{
var
event
=
new
CustomEvent
(
"
AboutNetErrorUIExpanded
"
{
bubbles
:
true
}
)
;
document
.
dispatchEvent
(
event
)
;
}
}
if
(
!
gIsCertError
)
{
return
;
}
if
(
getCSSClass
(
)
=
=
"
expertBadCert
"
)
{
toggleDisplay
(
document
.
getElementById
(
"
badCertAdvancedPanel
"
)
)
;
var
div
=
document
.
getElementById
(
"
certificateErrorDebugInformation
"
)
;
div
.
style
.
display
=
"
none
"
;
}
disallowCertOverridesIfNeeded
(
)
;
}
function
disallowCertOverridesIfNeeded
(
)
{
var
cssClass
=
getCSSClass
(
)
;
if
(
cssClass
=
=
"
badStsCert
"
|
|
window
!
=
top
)
{
document
.
getElementById
(
"
exceptionDialogButton
"
)
.
setAttribute
(
"
hidden
"
"
true
"
)
;
}
if
(
cssClass
=
=
"
badStsCert
"
)
{
document
.
getElementById
(
"
badStsCertExplanation
"
)
.
removeAttribute
(
"
hidden
"
)
;
let
stsReturnButtonText
=
document
.
getElementById
(
"
stsReturnButtonText
"
)
.
textContent
;
document
.
getElementById
(
"
returnButton
"
)
.
textContent
=
stsReturnButtonText
;
document
.
getElementById
(
"
advancedPanelReturnButton
"
)
.
textContent
=
stsReturnButtonText
;
let
stsMitmWhatCanYouDoAboutIt3
=
document
.
getElementById
(
"
stsMitmWhatCanYouDoAboutIt3
"
)
.
innerHTML
;
document
.
getElementById
(
"
mitmWhatCanYouDoAboutIt3
"
)
.
innerHTML
=
stsMitmWhatCanYouDoAboutIt3
;
}
}
async
function
setErrorPageStrings
(
err
)
{
let
title
=
err
+
"
-
title
"
;
let
isCertError
=
err
=
=
"
nssBadCert
"
;
let
className
=
getCSSClass
(
)
;
if
(
isCertError
&
&
(
window
!
=
=
window
.
top
|
|
className
=
=
"
badStsCert
"
)
)
{
title
=
err
+
"
-
sts
-
title
"
;
}
let
[
errorCodeTitle
]
=
await
document
.
l10n
.
formatValues
(
[
{
id
:
title
}
]
)
;
let
titleElement
=
document
.
querySelector
(
"
.
title
-
text
"
)
;
if
(
!
errorCodeTitle
)
{
console
.
error
(
"
No
strings
exist
for
this
error
type
"
)
;
document
.
l10n
.
setAttributes
(
titleElement
"
generic
-
title
"
)
;
return
;
}
document
.
l10n
.
setAttributes
(
titleElement
title
)
;
}
function
initPage
(
)
{
var
err
=
getErrorCode
(
)
;
let
illustratedErrors
=
[
"
malformedURI
"
"
dnsNotFound
"
"
connectionFailure
"
"
netInterrupt
"
"
netTimeout
"
"
netReset
"
"
netOffline
"
]
;
if
(
illustratedErrors
.
includes
(
err
)
)
{
document
.
body
.
classList
.
add
(
"
illustrated
"
err
)
;
}
if
(
err
=
=
"
blockedByPolicy
"
)
{
document
.
body
.
classList
.
add
(
"
blocked
"
)
;
}
gIsCertError
=
err
=
=
"
nssBadCert
"
;
let
showCaptivePortalUI
=
isCaptive
(
)
&
&
gIsCertError
;
if
(
showCaptivePortalUI
)
{
err
=
"
captivePortal
"
;
}
let
l10nErrId
=
err
;
let
className
=
getCSSClass
(
)
;
if
(
className
)
{
document
.
body
.
classList
.
add
(
className
)
;
}
if
(
gIsCertError
&
&
(
window
!
=
=
window
.
top
|
|
className
=
=
"
badStsCert
"
)
)
{
l10nErrId
+
=
"
_sts
"
;
}
let
pageTitle
=
document
.
getElementById
(
"
ept_
"
+
l10nErrId
)
;
if
(
pageTitle
)
{
document
.
title
=
pageTitle
.
textContent
;
}
var
errDesc
=
document
.
getElementById
(
"
ed_
"
+
l10nErrId
)
;
if
(
!
errDesc
)
{
errDesc
=
document
.
getElementById
(
"
ed_generic
"
)
;
}
setErrorPageStrings
(
err
)
;
var
sd
=
document
.
getElementById
(
"
errorShortDescText
"
)
;
if
(
sd
)
{
if
(
gIsCertError
)
{
sd
.
innerHTML
=
errDesc
.
innerHTML
;
}
else
{
sd
.
textContent
=
getDescription
(
)
;
}
}
if
(
gIsCertError
)
{
if
(
showCaptivePortalUI
)
{
initPageCaptivePortal
(
)
;
}
else
{
initPageCertError
(
)
;
updateContainerPosition
(
)
;
}
initCertErrorPageActions
(
)
;
setTechnicalDetailsOnCertError
(
)
;
return
;
}
addAutofocus
(
"
#
netErrorButtonContainer
>
.
try
-
again
"
)
;
document
.
body
.
classList
.
add
(
"
neterror
"
)
;
var
ld
=
document
.
getElementById
(
"
errorLongDesc
"
)
;
if
(
ld
)
{
ld
.
innerHTML
=
errDesc
.
innerHTML
;
}
if
(
err
=
=
"
sslv3Used
"
)
{
document
.
getElementById
(
"
learnMoreContainer
"
)
.
style
.
display
=
"
block
"
;
document
.
body
.
className
=
"
certerror
"
;
}
var
errContainer
=
document
.
getElementById
(
"
errorContainer
"
)
;
errContainer
.
remove
(
)
;
if
(
err
=
=
"
remoteXUL
"
)
{
document
.
getElementById
(
"
netErrorButtonContainer
"
)
.
style
.
display
=
"
none
"
;
}
if
(
err
=
=
"
cspBlocked
"
|
|
err
=
=
"
xfoBlocked
"
)
{
document
.
getElementById
(
"
netErrorButtonContainer
"
)
.
style
.
display
=
"
none
"
;
}
setNetErrorMessageFromCode
(
)
;
let
learnMoreLink
=
document
.
getElementById
(
"
learnMoreLink
"
)
;
let
baseURL
=
RPMGetFormatURLPref
(
"
app
.
support
.
baseURL
"
)
;
learnMoreLink
.
setAttribute
(
"
href
"
baseURL
+
"
connection
-
not
-
secure
"
)
;
if
(
err
=
=
"
nssFailure2
"
)
{
setupErrorUI
(
)
;
const
errorCode
=
document
.
getNetErrorInfo
(
)
.
errorCodeString
;
const
isTlsVersionError
=
errorCode
=
=
"
SSL_ERROR_UNSUPPORTED_VERSION
"
|
|
errorCode
=
=
"
SSL_ERROR_PROTOCOL_VERSION_ALERT
"
;
const
tls10OverrideEnabled
=
RPMGetBoolPref
(
"
security
.
tls
.
version
.
enable
-
deprecated
"
)
;
if
(
isTlsVersionError
&
&
!
tls10OverrideEnabled
&
&
!
RPMPrefIsLocked
(
"
security
.
tls
.
version
.
min
"
)
)
{
const
showOverride
=
RPMGetBoolPref
(
"
security
.
certerrors
.
tls
.
version
.
show
-
override
"
true
)
;
if
(
showOverride
)
{
showTls10Container
(
)
;
}
}
else
{
const
hasPrefStyleError
=
[
"
interrupted
"
"
SSL_ERROR_NO_CIPHERS_SUPPORTED
"
"
SSL_ERROR_NO_CYPHER_OVERLAP
"
"
SSL_ERROR_PROTOCOL_VERSION_ALERT
"
"
SSL_ERROR_SSL_DISABLED
"
"
SSL_ERROR_UNSUPPORTED_VERSION
"
]
.
some
(
substring
=
>
{
return
substring
=
=
errorCode
;
}
)
;
if
(
hasPrefStyleError
)
{
RPMAddMessageListener
(
"
HasChangedCertPrefs
"
msg
=
>
{
if
(
msg
.
data
.
hasChangedCertPrefs
)
{
showPrefChangeContainer
(
)
;
}
}
)
;
RPMSendAsyncMessage
(
"
GetChangedCertPrefs
"
)
;
}
}
}
if
(
err
=
=
"
sslv3Used
"
)
{
document
.
getElementById
(
"
advancedButton
"
)
.
style
.
display
=
"
none
"
;
}
if
(
err
=
=
"
inadequateSecurityError
"
|
|
err
=
=
"
blockedByPolicy
"
)
{
document
.
getElementById
(
"
netErrorButtonContainer
"
)
.
style
.
display
=
"
none
"
;
var
container
=
document
.
getElementById
(
"
errorLongDesc
"
)
;
for
(
var
span
of
container
.
querySelectorAll
(
"
span
.
hostname
"
)
)
{
span
.
textContent
=
document
.
location
.
hostname
;
}
}
}
function
setupErrorUI
(
)
{
document
.
getElementById
(
"
learnMoreContainer
"
)
.
style
.
display
=
"
block
"
;
let
checkbox
=
document
.
getElementById
(
"
automaticallyReportInFuture
"
)
;
checkbox
.
addEventListener
(
"
change
"
function
(
{
target
:
{
checked
}
}
)
{
onSetAutomatic
(
checked
)
;
}
)
;
let
errorReportingEnabled
=
RPMGetBoolPref
(
"
security
.
ssl
.
errorReporting
.
enabled
"
)
;
if
(
errorReportingEnabled
)
{
showCertificateErrorReporting
(
)
;
RPMAddToHistogram
(
"
TLS_ERROR_REPORT_UI
"
TLS_ERROR_REPORT_TELEMETRY_UI_SHOWN
)
;
let
errorReportingAutomatic
=
RPMGetBoolPref
(
"
security
.
ssl
.
errorReporting
.
automatic
"
)
;
checkbox
.
checked
=
!
!
errorReportingAutomatic
;
}
}
function
onSetAutomatic
(
checked
)
{
let
bin
=
TLS_ERROR_REPORT_TELEMETRY_AUTO_UNCHECKED
;
if
(
checked
)
{
bin
=
TLS_ERROR_REPORT_TELEMETRY_AUTO_CHECKED
;
}
RPMAddToHistogram
(
"
TLS_ERROR_REPORT_UI
"
bin
)
;
RPMSetBoolPref
(
"
security
.
ssl
.
errorReporting
.
automatic
"
checked
)
;
if
(
checked
)
{
RPMSendAsyncMessage
(
"
ReportTLSError
"
{
host
:
document
.
location
.
host
port
:
parseInt
(
document
.
location
.
port
)
|
|
-
1
}
)
;
}
}
async
function
setNetErrorMessageFromCode
(
)
{
let
hostString
=
document
.
location
.
hostname
;
let
port
=
document
.
location
.
port
;
if
(
port
&
&
port
!
=
443
)
{
hostString
+
=
"
:
"
+
port
;
}
let
securityInfo
;
try
{
securityInfo
=
document
.
getNetErrorInfo
(
)
;
}
catch
(
ex
)
{
return
;
}
let
desc
=
document
.
getElementById
(
"
errorShortDescText
"
)
;
let
errorCodeStr
=
securityInfo
.
errorCodeString
|
|
"
"
;
let
errorCodeMsg
=
"
"
;
if
(
errorCodeStr
)
{
[
errorCodeMsg
]
=
await
document
.
l10n
.
formatValues
(
[
{
id
:
errorCodeStr
.
split
(
"
_
"
)
.
join
(
"
-
"
)
.
toLowerCase
(
)
}
]
)
;
}
if
(
!
errorCodeMsg
)
{
console
.
warn
(
"
This
error
page
has
no
error
code
in
its
security
info
"
)
;
document
.
l10n
.
setAttributes
(
desc
"
ssl
-
connection
-
error
"
{
errorMessage
:
errorCodeStr
hostname
:
hostString
}
)
;
return
;
}
document
.
l10n
.
setAttributes
(
desc
"
ssl
-
connection
-
error
"
{
errorMessage
:
errorCodeMsg
hostname
:
hostString
}
)
;
let
desc2
=
document
.
getElementById
(
"
errorShortDescText2
"
)
;
document
.
l10n
.
setAttributes
(
desc2
"
cert
-
error
-
code
-
prefix
"
{
error
:
errorCodeStr
}
)
;
}
function
updateContainerPosition
(
)
{
let
textContainer
=
document
.
getElementById
(
"
text
-
container
"
)
;
if
(
window
.
parent
=
=
window
)
{
textContainer
.
style
.
marginTop
=
calc
(
50vh
-
{
textContainer
.
clientHeight
/
2
}
px
)
;
}
else
{
let
offset
=
document
.
documentElement
.
clientHeight
/
2
-
textContainer
.
clientHeight
/
2
;
if
(
offset
>
0
)
{
textContainer
.
style
.
marginTop
=
{
offset
}
px
;
}
}
}
function
initPageCaptivePortal
(
)
{
document
.
body
.
className
=
"
captiveportal
"
;
document
.
getElementById
(
"
openPortalLoginPageButton
"
)
.
addEventListener
(
"
click
"
(
)
=
>
{
RPMSendAsyncMessage
(
"
Browser
:
OpenCaptivePortalPage
"
)
;
}
)
;
addAutofocus
(
"
#
openPortalLoginPageButton
"
)
;
setupAdvancedButton
(
)
;
RPMAddMessageListener
(
"
AboutNetErrorCaptivePortalFreed
"
(
)
=
>
{
document
.
location
.
reload
(
)
;
}
)
;
}
function
initPageCertError
(
)
{
document
.
body
.
classList
.
add
(
"
certerror
"
)
;
for
(
let
host
of
document
.
querySelectorAll
(
"
.
hostname
"
)
)
{
host
.
textContent
=
document
.
location
.
hostname
;
}
addAutofocus
(
"
#
returnButton
"
)
;
setupAdvancedButton
(
)
;
setupErrorUI
(
)
;
let
hideAddExceptionButton
=
RPMGetBoolPref
(
"
security
.
certerror
.
hideAddException
"
false
)
;
if
(
hideAddExceptionButton
)
{
document
.
querySelector
(
"
.
exceptionDialogButtonContainer
"
)
.
hidden
=
true
;
}
setCertErrorDetails
(
)
;
}
function
initCertErrorPageActions
(
)
{
document
.
getElementById
(
"
returnButton
"
)
.
addEventListener
(
"
click
"
onReturnButtonClick
)
;
document
.
getElementById
(
"
advancedPanelReturnButton
"
)
.
addEventListener
(
"
click
"
onReturnButtonClick
)
;
document
.
getElementById
(
"
copyToClipboardTop
"
)
.
addEventListener
(
"
click
"
copyPEMToClipboard
)
;
document
.
getElementById
(
"
copyToClipboardBottom
"
)
.
addEventListener
(
"
click
"
copyPEMToClipboard
)
;
document
.
getElementById
(
"
exceptionDialogButton
"
)
.
addEventListener
(
"
click
"
addCertException
)
;
}
function
addCertException
(
)
{
const
isPermanent
=
!
RPMIsWindowPrivate
(
)
&
&
RPMGetBoolPref
(
"
security
.
certerrors
.
permanentOverride
"
)
;
document
.
addCertException
(
!
isPermanent
)
.
then
(
(
)
=
>
{
location
.
reload
(
)
;
}
err
=
>
{
}
)
;
}
function
onReturnButtonClick
(
e
)
{
RPMSendAsyncMessage
(
"
Browser
:
SSLErrorGoBack
"
)
;
}
async
function
copyPEMToClipboard
(
e
)
{
let
details
=
await
getFailedCertificatesAsPEMString
(
)
;
navigator
.
clipboard
.
writeText
(
details
)
;
}
async
function
getFailedCertificatesAsPEMString
(
)
{
let
location
=
document
.
location
.
href
;
let
failedCertInfo
=
document
.
getFailedCertSecurityInfo
(
)
;
let
errorMessage
=
failedCertInfo
.
errorMessage
;
let
hasHSTS
=
failedCertInfo
.
hasHSTS
.
toString
(
)
;
let
hasHPKP
=
failedCertInfo
.
hasHPKP
.
toString
(
)
;
let
[
hstsLabel
]
=
await
document
.
l10n
.
formatValues
(
[
{
id
:
"
cert
-
error
-
details
-
hsts
-
label
"
args
:
{
hasHSTS
}
}
]
)
;
let
[
hpkpLabel
]
=
await
document
.
l10n
.
formatValues
(
[
{
id
:
"
cert
-
error
-
details
-
key
-
pinning
-
label
"
args
:
{
hasHPKP
}
}
]
)
;
let
certStrings
=
failedCertInfo
.
certChainStrings
;
let
failedChainCertificates
=
"
"
;
for
(
let
der64
of
certStrings
)
{
let
wrapped
=
der64
.
replace
(
/
(
\
S
{
64
}
(
?
!
)
)
/
g
"
1
\
r
\
n
"
)
;
failedChainCertificates
+
=
"
-
-
-
-
-
BEGIN
CERTIFICATE
-
-
-
-
-
\
r
\
n
"
+
wrapped
+
"
\
r
\
n
-
-
-
-
-
END
CERTIFICATE
-
-
-
-
-
\
r
\
n
"
;
}
let
[
failedChainLabel
]
=
await
document
.
l10n
.
formatValues
(
[
{
id
:
"
cert
-
error
-
details
-
cert
-
chain
-
label
"
}
]
)
;
let
details
=
location
+
"
\
r
\
n
\
r
\
n
"
+
errorMessage
+
"
\
r
\
n
\
r
\
n
"
+
hstsLabel
+
"
\
r
\
n
"
+
hpkpLabel
+
"
\
r
\
n
\
r
\
n
"
+
failedChainLabel
+
"
\
r
\
n
\
r
\
n
"
+
failedChainCertificates
;
return
details
;
}
function
setCertErrorDetails
(
event
)
{
let
failedCertInfo
=
document
.
getFailedCertSecurityInfo
(
)
;
let
mitmPrimingEnabled
=
RPMGetBoolPref
(
"
security
.
certerrors
.
mitm
.
priming
.
enabled
"
)
;
if
(
mitmPrimingEnabled
&
&
failedCertInfo
.
errorCodeString
=
=
"
SEC_ERROR_UNKNOWN_ISSUER
"
&
&
window
.
parent
=
=
window
)
{
RPMSendAsyncMessage
(
"
Browser
:
PrimeMitm
"
)
;
}
let
learnMoreLink
=
document
.
getElementById
(
"
learnMoreLink
"
)
;
let
baseURL
=
RPMGetFormatURLPref
(
"
app
.
support
.
baseURL
"
)
;
learnMoreLink
.
setAttribute
(
"
href
"
baseURL
+
"
connection
-
not
-
secure
"
)
;
let
errWhatToDo
=
document
.
getElementById
(
"
es_nssBadCert_
"
+
failedCertInfo
.
errorCodeString
)
;
let
es
=
document
.
getElementById
(
"
errorWhatToDoText
"
)
;
let
errWhatToDoTitle
=
document
.
getElementById
(
"
edd_nssBadCert
"
)
;
let
est
=
document
.
getElementById
(
"
errorWhatToDoTitleText
"
)
;
let
error
=
getErrorCode
(
)
;
if
(
error
=
=
"
sslv3Used
"
)
{
learnMoreLink
.
setAttribute
(
"
href
"
baseURL
+
"
sslv3
-
error
-
messages
"
)
;
}
if
(
error
=
=
"
nssFailure2
"
)
{
let
shortDesc
=
document
.
getElementById
(
"
errorShortDescText
"
)
.
textContent
;
if
(
shortDesc
.
includes
(
"
MOZILLA_PKIX_ERROR_KEY_PINNING_FAILURE
"
)
)
{
learnMoreLink
.
setAttribute
(
"
href
"
baseURL
+
"
certificate
-
pinning
-
reports
"
)
;
}
}
let
clockSkew
=
false
;
document
.
body
.
setAttribute
(
"
code
"
failedCertInfo
.
errorCodeString
)
;
let
titleElement
=
document
.
querySelector
(
"
.
title
-
text
"
)
;
let
desc
;
switch
(
failedCertInfo
.
errorCodeString
)
{
case
"
SSL_ERROR_BAD_CERT_DOMAIN
"
:
case
"
SEC_ERROR_OCSP_INVALID_SIGNING_CERT
"
:
case
"
SEC_ERROR_UNKNOWN_ISSUER
"
:
if
(
es
)
{
es
.
innerHTML
=
errWhatToDo
.
innerHTML
;
}
if
(
est
)
{
est
.
innerHTML
=
errWhatToDoTitle
.
innerHTML
;
}
updateContainerPosition
(
)
;
break
;
case
"
MOZILLA_PKIX_ERROR_ADDITIONAL_POLICY_CONSTRAINT_FAILED
"
:
desc
=
document
.
getElementById
(
"
errorShortDescText2
"
)
;
let
hostname
=
document
.
location
.
hostname
;
document
.
l10n
.
setAttributes
(
desc
"
cert
-
error
-
symantec
-
distrust
-
description
"
{
hostname
}
)
;
let
adminDesc
=
document
.
createElement
(
"
p
"
)
;
document
.
l10n
.
setAttributes
(
adminDesc
"
cert
-
error
-
symantec
-
distrust
-
admin
"
)
;
learnMoreLink
.
href
=
baseURL
+
"
symantec
-
warning
"
;
updateContainerPosition
(
)
;
break
;
case
"
MOZILLA_PKIX_ERROR_MITM_DETECTED
"
:
let
autoEnabledEnterpriseRoots
=
RPMGetBoolPref
(
"
security
.
enterprise_roots
.
auto
-
enabled
"
false
)
;
if
(
mitmPrimingEnabled
&
&
autoEnabledEnterpriseRoots
)
{
RPMSendAsyncMessage
(
"
Browser
:
ResetEnterpriseRootsPref
"
)
;
}
let
names
=
document
.
querySelectorAll
(
"
.
mitm
-
name
"
)
;
for
(
let
span
of
names
)
{
span
.
textContent
=
failedCertInfo
.
issuerCommonName
;
}
learnMoreLink
.
href
=
baseURL
+
"
security
-
error
"
;
document
.
l10n
.
setAttributes
(
titleElement
"
certerror
-
mitm
-
title
"
)
;
desc
=
document
.
getElementById
(
"
ed_mitm
"
)
;
document
.
getElementById
(
"
errorShortDescText
"
)
.
innerHTML
=
desc
.
innerHTML
;
es
.
innerHTML
=
errWhatToDo
.
innerHTML
;
est
.
innerHTML
=
errWhatToDoTitle
.
innerHTML
;
updateContainerPosition
(
)
;
break
;
case
"
MOZILLA_PKIX_ERROR_SELF_SIGNED_CERT
"
:
learnMoreLink
.
href
=
baseURL
+
"
security
-
error
"
;
break
;
case
"
SEC_ERROR_EXPIRED_CERTIFICATE
"
:
case
"
SEC_ERROR_EXPIRED_ISSUER_CERTIFICATE
"
:
case
"
MOZILLA_PKIX_ERROR_NOT_YET_VALID_CERTIFICATE
"
:
case
"
MOZILLA_PKIX_ERROR_NOT_YET_VALID_ISSUER_CERTIFICATE
"
:
learnMoreLink
.
href
=
baseURL
+
"
time
-
errors
"
;
let
difference
=
RPMGetIntPref
(
"
services
.
settings
.
clock_skew_seconds
"
0
)
;
let
lastFetched
=
RPMGetIntPref
(
"
services
.
settings
.
last_update_seconds
"
0
)
*
1000
;
let
now
=
Date
.
now
(
)
;
let
certRange
=
{
notBefore
:
failedCertInfo
.
certValidityRangeNotBefore
notAfter
:
failedCertInfo
.
certValidityRangeNotAfter
}
;
let
approximateDate
=
now
-
difference
*
1000
;
if
(
Math
.
abs
(
difference
)
>
60
*
60
*
24
&
&
now
-
lastFetched
<
=
60
*
60
*
24
*
5
*
1000
&
&
certRange
.
notBefore
<
approximateDate
&
&
certRange
.
notAfter
>
approximateDate
)
{
clockSkew
=
true
;
}
else
{
let
appBuildID
=
RPMGetAppBuildID
(
)
;
let
year
=
parseInt
(
appBuildID
.
substr
(
0
4
)
10
)
;
let
month
=
parseInt
(
appBuildID
.
substr
(
4
2
)
10
)
-
1
;
let
day
=
parseInt
(
appBuildID
.
substr
(
6
2
)
10
)
;
let
buildDate
=
new
Date
(
year
month
day
)
;
let
systemDate
=
new
Date
(
)
;
if
(
buildDate
>
systemDate
&
&
new
Date
(
certRange
.
notAfter
)
>
buildDate
)
{
clockSkew
=
true
;
}
}
let
systemDate
=
formatter
.
format
(
new
Date
(
)
)
;
document
.
getElementById
(
"
wrongSystemTime_systemDate1
"
)
.
textContent
=
systemDate
;
if
(
clockSkew
)
{
document
.
body
.
classList
.
add
(
"
illustrated
"
"
clockSkewError
"
)
;
document
.
l10n
.
setAttributes
(
titleElement
"
clockSkewError
-
title
"
)
;
let
clockErrDesc
=
document
.
getElementById
(
"
ed_clockSkewError
"
)
;
desc
=
document
.
getElementById
(
"
errorShortDescText
"
)
;
document
.
getElementById
(
"
errorShortDesc
"
)
.
style
.
display
=
"
block
"
;
document
.
getElementById
(
"
certificateErrorReporting
"
)
.
style
.
display
=
"
none
"
;
if
(
desc
)
{
desc
.
innerHTML
=
clockErrDesc
.
innerHTML
;
}
let
errorPageContainer
=
document
.
getElementById
(
"
errorPageContainer
"
)
;
let
textContainer
=
document
.
getElementById
(
"
text
-
container
"
)
;
errorPageContainer
.
style
.
backgroundPosition
=
left
top
calc
(
50vh
-
{
textContainer
.
clientHeight
/
2
}
px
)
;
}
else
{
let
targetElems
=
document
.
querySelectorAll
(
"
#
wrongSystemTime_systemDate2
"
)
;
for
(
let
elem
of
targetElems
)
{
elem
.
textContent
=
systemDate
;
}
let
errDesc
=
document
.
getElementById
(
"
ed_nssBadCert_SEC_ERROR_EXPIRED_CERTIFICATE
"
)
;
let
sd
=
document
.
getElementById
(
"
errorShortDescText
"
)
;
sd
.
innerHTML
=
errDesc
.
innerHTML
;
let
span
=
sd
.
querySelector
(
"
.
hostname
"
)
;
span
.
textContent
=
document
.
location
.
hostname
;
if
(
failedCertInfo
.
errorCodeString
=
=
"
SEC_ERROR_EXPIRED_CERTIFICATE
"
)
{
let
cssClass
=
getCSSClass
(
)
;
let
stsSuffix
=
cssClass
=
=
"
badStsCert
"
?
"
_sts
"
:
"
"
;
let
errDesc2
=
document
.
getElementById
(
ed2_nssBadCert_SEC_ERROR_EXPIRED_CERTIFICATE
{
stsSuffix
}
)
;
let
sd2
=
document
.
getElementById
(
"
errorShortDescText2
"
)
;
sd2
.
innerHTML
=
errDesc2
.
innerHTML
;
if
(
Math
.
abs
(
difference
)
<
=
60
*
60
*
24
&
&
now
-
lastFetched
<
=
60
*
60
*
24
*
5
*
1000
)
{
errWhatToDo
=
document
.
getElementById
(
"
es_nssBadCert_SSL_ERROR_BAD_CERT_DOMAIN
"
)
;
}
}
if
(
es
)
{
es
.
innerHTML
=
errWhatToDo
.
innerHTML
;
}
if
(
est
)
{
est
.
textContent
=
errWhatToDoTitle
.
textContent
;
est
.
style
.
fontWeight
=
"
bold
"
;
}
updateContainerPosition
(
)
;
}
break
;
}
let
cssClass
=
getCSSClass
(
)
;
if
(
cssClass
!
=
"
badStsCert
"
&
&
window
.
parent
=
=
window
&
&
!
clockSkew
&
&
failedCertInfo
.
errorCodeString
!
=
"
MOZILLA_PKIX_ERROR_ADDITIONAL_POLICY_CONSTRAINT_FAILED
"
)
{
document
.
body
.
classList
.
add
(
"
caution
"
)
;
}
}
async
function
setTechnicalDetailsOnCertError
(
)
{
let
technicalInfo
=
document
.
getElementById
(
"
badCertTechnicalInfo
"
)
;
function
setL10NLabel
(
l10nId
args
=
{
}
attrs
=
{
}
rewrite
=
true
)
{
let
elem
=
document
.
createElement
(
"
label
"
)
;
if
(
rewrite
)
{
technicalInfo
.
textContent
=
"
"
;
}
technicalInfo
.
appendChild
(
elem
)
;
let
newLines
=
document
.
createTextNode
(
"
\
n
\
n
"
)
;
technicalInfo
.
appendChild
(
newLines
)
;
if
(
attrs
)
{
let
link
=
document
.
createElement
(
"
a
"
)
;
for
(
let
attr
of
Object
.
keys
(
attrs
)
)
{
link
.
setAttribute
(
attr
attrs
[
attr
]
)
;
}
elem
.
appendChild
(
link
)
;
}
if
(
args
)
{
document
.
l10n
.
setAttributes
(
elem
l10nId
args
)
;
}
else
{
document
.
l10n
.
setAttributes
(
elem
l10nId
)
;
}
}
let
cssClass
=
getCSSClass
(
)
;
let
error
=
getErrorCode
(
)
;
let
hostString
=
document
.
location
.
hostname
;
let
port
=
document
.
location
.
port
;
if
(
port
&
&
port
!
=
443
)
{
hostString
+
=
"
:
"
+
port
;
}
let
l10nId
;
let
args
=
{
hostname
:
hostString
}
;
let
failedCertInfo
=
document
.
getFailedCertSecurityInfo
(
)
;
if
(
failedCertInfo
.
isUntrusted
)
{
switch
(
failedCertInfo
.
errorCodeString
)
{
case
"
MOZILLA_PKIX_ERROR_MITM_DETECTED
"
:
setL10NLabel
(
"
cert
-
error
-
mitm
-
intro
"
)
;
setL10NLabel
(
"
cert
-
error
-
mitm
-
mozilla
"
{
}
{
}
false
)
;
setL10NLabel
(
"
cert
-
error
-
mitm
-
connection
"
{
}
{
}
false
)
;
break
;
case
"
SEC_ERROR_UNKNOWN_ISSUER
"
:
setL10NLabel
(
"
cert
-
error
-
trust
-
unknown
-
issuer
-
intro
"
)
;
setL10NLabel
(
"
cert
-
error
-
trust
-
unknown
-
issuer
"
args
{
}
false
)
;
break
;
case
"
SEC_ERROR_CA_CERT_INVALID
"
:
setL10NLabel
(
"
cert
-
error
-
intro
"
args
)
;
setL10NLabel
(
"
cert
-
error
-
trust
-
cert
-
invalid
"
{
}
{
}
false
)
;
break
;
case
"
SEC_ERROR_UNTRUSTED_ISSUER
"
:
setL10NLabel
(
"
cert
-
error
-
intro
"
args
)
;
setL10NLabel
(
"
cert
-
error
-
trust
-
untrusted
-
issuer
"
{
}
{
}
false
)
;
break
;
case
"
SEC_ERROR_CERT_SIGNATURE_ALGORITHM_DISABLED
"
:
setL10NLabel
(
"
cert
-
error
-
intro
"
args
)
;
setL10NLabel
(
"
cert
-
error
-
trust
-
signature
-
algorithm
-
disabled
"
{
}
{
}
false
)
;
break
;
case
"
SEC_ERROR_EXPIRED_ISSUER_CERTIFICATE
"
:
setL10NLabel
(
"
cert
-
error
-
intro
"
args
)
;
setL10NLabel
(
"
cert
-
error
-
trust
-
expired
-
issuer
"
{
}
{
}
false
)
;
break
;
case
"
MOZILLA_PKIX_ERROR_SELF_SIGNED_CERT
"
:
setL10NLabel
(
"
cert
-
error
-
intro
"
args
)
;
setL10NLabel
(
"
cert
-
error
-
trust
-
self
-
signed
"
{
}
{
}
false
)
;
break
;
case
"
MOZILLA_PKIX_ERROR_ADDITIONAL_POLICY_CONSTRAINT_FAILED
"
:
setL10NLabel
(
"
cert
-
error
-
intro
"
args
)
;
setL10NLabel
(
"
cert
-
error
-
trust
-
symantec
"
{
}
{
}
false
)
;
break
;
default
:
setL10NLabel
(
"
cert
-
error
-
intro
"
args
)
;
setL10NLabel
(
"
cert
-
error
-
untrusted
-
default
"
{
}
{
}
false
)
;
}
}
if
(
failedCertInfo
.
isDomainMismatch
)
{
let
subjectAltNames
=
failedCertInfo
.
subjectAltNames
.
split
(
"
"
)
;
subjectAltNames
=
subjectAltNames
.
filter
(
name
=
>
!
!
name
.
length
)
;
let
numSubjectAltNames
=
subjectAltNames
.
length
;
if
(
numSubjectAltNames
!
=
0
)
{
if
(
numSubjectAltNames
=
=
1
)
{
args
[
"
alt
-
name
"
]
=
subjectAltNames
[
0
]
;
let
okHost
=
failedCertInfo
.
subjectAltNames
;
let
href
=
"
"
;
let
thisHost
=
document
.
location
.
hostname
;
let
proto
=
document
.
location
.
protocol
+
"
/
/
"
;
okHost
=
okHost
.
replace
(
/
^
\
*
\
.
/
"
www
.
"
)
;
if
(
okHost
.
endsWith
(
"
.
"
+
thisHost
)
)
{
href
=
proto
+
okHost
;
}
if
(
thisHost
.
endsWith
(
"
.
"
+
okHost
)
)
{
href
=
proto
+
okHost
;
}
if
(
href
&
&
cssClass
!
=
"
expertBadCert
"
)
{
document
.
getElementById
(
"
badCertAdvancedPanel
"
)
.
style
.
display
=
"
block
"
;
if
(
error
=
=
"
nssBadCert
"
)
{
let
div
=
document
.
getElementById
(
"
certificateErrorDebugInformation
"
)
;
div
.
style
.
display
=
"
none
"
;
}
}
if
(
href
)
{
setL10NLabel
(
"
cert
-
error
-
domain
-
mismatch
-
single
"
args
{
href
"
data
-
l10n
-
name
"
:
"
domain
-
mismatch
-
link
"
id
:
"
cert_domain_link
"
}
)
;
}
else
{
setL10NLabel
(
"
cert
-
error
-
domain
-
mismatch
-
single
-
nolink
"
args
)
;
}
}
else
{
let
names
=
subjectAltNames
.
join
(
"
"
)
;
args
[
"
subject
-
alt
-
names
"
]
=
names
;
setL10NLabel
(
"
cert
-
error
-
domain
-
mismatch
-
multiple
"
args
)
;
}
}
else
{
setL10NLabel
(
"
cert
-
error
-
domain
-
mismatch
"
{
hostname
:
hostString
}
)
;
}
}
if
(
failedCertInfo
.
isNotValidAtThisTime
)
{
let
notBefore
=
failedCertInfo
.
validNotBefore
;
let
notAfter
=
failedCertInfo
.
validNotAfter
;
args
=
{
hostname
:
hostString
}
;
if
(
notBefore
&
&
Date
.
now
(
)
<
notAfter
)
{
let
notBeforeLocalTime
=
formatter
.
format
(
new
Date
(
notBefore
)
)
;
l10nId
=
"
cert
-
error
-
not
-
yet
-
valid
-
now
"
;
args
[
"
not
-
before
-
local
-
time
"
]
=
notBeforeLocalTime
;
}
else
{
let
notAfterLocalTime
=
formatter
.
format
(
new
Date
(
notAfter
)
)
;
l10nId
=
"
cert
-
error
-
expired
-
now
"
;
args
[
"
not
-
after
-
local
-
time
"
]
=
notAfterLocalTime
;
}
setL10NLabel
(
l10nId
args
)
;
}
setL10NLabel
(
"
cert
-
error
-
code
-
prefix
-
link
"
{
error
:
failedCertInfo
.
errorCodeString
}
{
title
:
failedCertInfo
.
errorCodeString
id
:
"
errorCode
"
"
data
-
l10n
-
name
"
:
"
error
-
code
-
link
"
}
false
)
;
let
errorCodeLink
=
document
.
getElementById
(
"
errorCode
"
)
;
if
(
errorCodeLink
)
{
technicalInfo
.
addEventListener
(
"
click
"
handleErrorCodeClick
)
;
}
let
div
=
document
.
getElementById
(
"
certificateErrorText
"
)
;
div
.
textContent
=
await
getFailedCertificatesAsPEMString
(
)
;
}
function
handleErrorCodeClick
(
event
)
{
if
(
event
.
target
.
id
!
=
=
"
errorCode
"
)
{
return
;
}
let
debugInfo
=
document
.
getElementById
(
"
certificateErrorDebugInformation
"
)
;
debugInfo
.
style
.
display
=
"
block
"
;
debugInfo
.
scrollIntoView
(
{
block
:
"
start
"
behavior
:
"
smooth
"
}
)
;
}
function
addAutofocus
(
selector
position
=
"
afterbegin
"
)
{
if
(
window
.
top
=
=
window
)
{
var
button
=
document
.
querySelector
(
selector
)
;
var
parent
=
button
.
parentNode
;
button
.
remove
(
)
;
button
.
setAttribute
(
"
autofocus
"
"
true
"
)
;
parent
.
insertAdjacentElement
(
position
button
)
;
}
}
for
(
let
button
of
document
.
querySelectorAll
(
"
.
try
-
again
"
)
)
{
button
.
addEventListener
(
"
click
"
function
(
)
{
retryThis
(
this
)
;
}
)
;
}
initPage
(
)
;
let
event
=
new
CustomEvent
(
"
AboutNetErrorLoad
"
{
bubbles
:
true
}
)
;
document
.
dispatchEvent
(
event
)
;
