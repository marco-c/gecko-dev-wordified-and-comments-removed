var
gPermissionPanel
=
{
_popupInitialized
:
false
_initializePopup
(
)
{
if
(
!
this
.
_popupInitialized
)
{
let
wrapper
=
document
.
getElementById
(
"
template
-
permission
-
popup
"
)
;
wrapper
.
replaceWith
(
wrapper
.
content
)
;
let
baseURL
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
;
document
.
getElementById
(
"
permission
-
popup
-
storage
-
access
-
permission
-
learn
-
more
"
)
.
href
=
baseURL
+
"
site
-
information
-
third
-
party
-
access
"
;
this
.
_popupInitialized
=
true
;
}
}
hidePopup
(
)
{
if
(
this
.
_popupInitialized
)
{
PanelMultiView
.
hidePopup
(
this
.
_permissionPopup
)
;
}
}
get
_identityPermissionBox
(
)
{
delete
this
.
_identityPermissionBox
;
return
(
this
.
_identityPermissionBox
=
document
.
getElementById
(
"
identity
-
permission
-
box
"
)
)
;
}
get
_permissionGrantedIcon
(
)
{
delete
this
.
_permissionGrantedIcon
;
return
(
this
.
_permissionGrantedIcon
=
document
.
getElementById
(
"
permissions
-
granted
-
icon
"
)
)
;
}
get
_permissionPopup
(
)
{
if
(
!
this
.
_popupInitialized
)
{
return
null
;
}
delete
this
.
_permissionPopup
;
return
(
this
.
_permissionPopup
=
document
.
getElementById
(
"
permission
-
popup
"
)
)
;
}
get
_permissionPopupMainView
(
)
{
delete
this
.
_permissionPopupPopupMainView
;
return
(
this
.
_permissionPopupPopupMainView
=
document
.
getElementById
(
"
permission
-
popup
-
mainView
"
)
)
;
}
get
_permissionPopupMainViewHeaderLabel
(
)
{
delete
this
.
_permissionPopupMainViewHeaderLabel
;
return
(
this
.
_permissionPopupMainViewHeaderLabel
=
document
.
getElementById
(
"
permission
-
popup
-
mainView
-
panel
-
header
-
span
"
)
)
;
}
get
_permissionList
(
)
{
delete
this
.
_permissionList
;
return
(
this
.
_permissionList
=
document
.
getElementById
(
"
permission
-
popup
-
permission
-
list
"
)
)
;
}
get
_defaultPermissionAnchor
(
)
{
delete
this
.
_defaultPermissionAnchor
;
return
(
this
.
_defaultPermissionAnchor
=
document
.
getElementById
(
"
permission
-
popup
-
permission
-
list
-
default
-
anchor
"
)
)
;
}
get
_permissionReloadHint
(
)
{
delete
this
.
_permissionReloadHint
;
return
(
this
.
_permissionReloadHint
=
document
.
getElementById
(
"
permission
-
popup
-
permission
-
reload
-
hint
"
)
)
;
}
get
_permissionAnchors
(
)
{
delete
this
.
_permissionAnchors
;
let
permissionAnchors
=
{
}
;
for
(
let
anchor
of
document
.
getElementById
(
"
blocked
-
permissions
-
container
"
)
.
children
)
{
permissionAnchors
[
anchor
.
getAttribute
(
"
data
-
permission
-
id
"
)
]
=
anchor
;
}
return
(
this
.
_permissionAnchors
=
permissionAnchors
)
;
}
get
_geoSharingIcon
(
)
{
delete
this
.
_geoSharingIcon
;
return
(
this
.
_geoSharingIcon
=
document
.
getElementById
(
"
geo
-
sharing
-
icon
"
)
)
;
}
get
_xrSharingIcon
(
)
{
delete
this
.
_xrSharingIcon
;
return
(
this
.
_xrSharingIcon
=
document
.
getElementById
(
"
xr
-
sharing
-
icon
"
)
)
;
}
get
_webRTCSharingIcon
(
)
{
delete
this
.
_webRTCSharingIcon
;
return
(
this
.
_webRTCSharingIcon
=
document
.
getElementById
(
"
webrtc
-
sharing
-
icon
"
)
)
;
}
_refreshPermissionPopup
(
)
{
let
host
=
gIdentityHandler
.
getHostForDisplay
(
)
;
this
.
_permissionPopupMainViewHeaderLabel
.
textContent
=
gNavigatorBundle
.
getFormattedString
(
"
permissions
.
header
"
[
host
]
)
;
this
.
updateSitePermissions
(
)
;
}
hidePermissionIcons
(
)
{
this
.
_identityPermissionBox
.
removeAttribute
(
"
hasPermissions
"
)
;
}
refreshPermissionIcons
(
)
{
let
permissionAnchors
=
this
.
_permissionAnchors
;
for
(
let
icon
of
Object
.
values
(
permissionAnchors
)
)
{
icon
.
removeAttribute
(
"
showing
"
)
;
}
let
hasPermissions
=
false
;
let
permissions
=
SitePermissions
.
getAllForBrowser
(
gBrowser
.
selectedBrowser
)
;
for
(
let
permission
of
permissions
)
{
if
(
permission
.
state
!
=
SitePermissions
.
UNKNOWN
)
{
hasPermissions
=
true
;
if
(
permission
.
state
=
=
SitePermissions
.
BLOCK
|
|
permission
.
state
=
=
SitePermissions
.
AUTOPLAY_BLOCKED_ALL
)
{
let
icon
=
permissionAnchors
[
permission
.
id
]
;
if
(
icon
)
{
icon
.
setAttribute
(
"
showing
"
"
true
"
)
;
}
}
}
}
if
(
gBrowser
.
selectedBrowser
.
popupBlocker
.
getBlockedPopupCount
(
)
)
{
let
icon
=
permissionAnchors
.
popup
;
icon
.
setAttribute
(
"
showing
"
"
true
"
)
;
hasPermissions
=
true
;
}
this
.
_identityPermissionBox
.
toggleAttribute
(
"
hasPermissions
"
hasPermissions
)
;
}
openPopup
(
event
)
{
if
(
document
.
fullscreen
)
{
this
.
_exitedEventReceived
=
false
;
this
.
_event
=
event
;
Services
.
obs
.
addObserver
(
this
"
fullscreen
-
painted
"
)
;
window
.
addEventListener
(
"
MozDOMFullscreen
:
Exited
"
(
)
=
>
{
this
.
_exitedEventReceived
=
true
;
}
{
once
:
true
}
)
;
document
.
exitFullscreen
(
)
;
return
;
}
this
.
_initializePopup
(
)
;
this
.
_permissionReloadHint
.
hidden
=
true
;
this
.
_refreshPermissionPopup
(
)
;
let
openPanels
=
Array
.
from
(
document
.
querySelectorAll
(
"
panel
[
openpanel
]
"
)
)
;
for
(
let
panel
of
openPanels
)
{
PanelMultiView
.
hidePopup
(
panel
)
;
}
PanelMultiView
.
openPopup
(
this
.
_permissionPopup
this
.
_identityPermissionBox
{
position
:
"
bottomcenter
topleft
"
triggerEvent
:
event
}
)
.
catch
(
Cu
.
reportError
)
;
}
updateSharingIndicator
(
)
{
let
tab
=
gBrowser
.
selectedTab
;
this
.
_sharingState
=
tab
.
_sharingState
;
this
.
_webRTCSharingIcon
.
removeAttribute
(
"
paused
"
)
;
this
.
_webRTCSharingIcon
.
removeAttribute
(
"
sharing
"
)
;
this
.
_geoSharingIcon
.
removeAttribute
(
"
sharing
"
)
;
this
.
_xrSharingIcon
.
removeAttribute
(
"
sharing
"
)
;
let
hasSharingIcon
=
false
;
if
(
this
.
_sharingState
)
{
if
(
this
.
_sharingState
.
webRTC
)
{
if
(
this
.
_sharingState
.
webRTC
.
sharing
)
{
this
.
_webRTCSharingIcon
.
setAttribute
(
"
sharing
"
this
.
_sharingState
.
webRTC
.
sharing
)
;
hasSharingIcon
=
true
;
if
(
this
.
_sharingState
.
webRTC
.
paused
)
{
this
.
_webRTCSharingIcon
.
setAttribute
(
"
paused
"
"
true
"
)
;
}
}
else
{
let
{
micGrace
camGrace
}
=
hasMicCamGracePeriodsSolely
(
gBrowser
.
selectedBrowser
)
;
if
(
micGrace
|
|
camGrace
)
{
this
.
_webRTCSharingIcon
.
setAttribute
(
"
sharing
"
camGrace
?
"
camera
"
:
"
microphone
"
)
;
hasSharingIcon
=
true
;
this
.
_webRTCSharingIcon
.
setAttribute
(
"
paused
"
"
true
"
)
;
}
}
}
if
(
this
.
_sharingState
.
geo
)
{
this
.
_geoSharingIcon
.
setAttribute
(
"
sharing
"
this
.
_sharingState
.
geo
)
;
hasSharingIcon
=
true
;
}
if
(
this
.
_sharingState
.
xr
)
{
this
.
_xrSharingIcon
.
setAttribute
(
"
sharing
"
this
.
_sharingState
.
xr
)
;
hasSharingIcon
=
true
;
}
}
this
.
_identityPermissionBox
.
toggleAttribute
(
"
hasSharingIcon
"
hasSharingIcon
)
;
if
(
this
.
_popupInitialized
&
&
this
.
_permissionPopup
.
state
!
=
"
closed
"
)
{
this
.
updateSitePermissions
(
)
;
}
}
handleIdentityButtonEvent
(
event
)
{
event
.
stopPropagation
(
)
;
if
(
(
event
.
type
=
=
"
click
"
&
&
event
.
button
!
=
0
)
|
|
(
event
.
type
=
=
"
keypress
"
&
&
event
.
charCode
!
=
KeyEvent
.
DOM_VK_SPACE
&
&
event
.
keyCode
!
=
KeyEvent
.
DOM_VK_RETURN
)
)
{
return
;
}
if
(
!
this
.
_sharingState
&
&
gURLBar
.
getAttribute
(
"
pageproxystate
"
)
!
=
"
valid
"
)
{
return
;
}
this
.
openPopup
(
event
)
;
}
onPopupShown
(
event
)
{
if
(
event
.
target
=
=
this
.
_permissionPopup
)
{
window
.
addEventListener
(
"
focus
"
this
true
)
;
}
}
onPopupHidden
(
event
)
{
if
(
event
.
target
=
=
this
.
_permissionPopup
)
{
window
.
removeEventListener
(
"
focus
"
this
true
)
;
}
}
handleEvent
(
event
)
{
let
elem
=
document
.
activeElement
;
let
position
=
elem
.
compareDocumentPosition
(
this
.
_permissionPopup
)
;
if
(
!
(
position
&
(
Node
.
DOCUMENT_POSITION_CONTAINS
|
Node
.
DOCUMENT_POSITION_CONTAINED_BY
)
)
&
&
!
this
.
_permissionPopup
.
hasAttribute
(
"
noautohide
"
)
)
{
PanelMultiView
.
hidePopup
(
this
.
_permissionPopup
)
;
}
}
observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
"
fullscreen
-
painted
"
:
{
if
(
subject
!
=
window
|
|
!
this
.
_exitedEventReceived
)
{
return
;
}
Services
.
obs
.
removeObserver
(
this
"
fullscreen
-
painted
"
)
;
this
.
openPopup
(
this
.
_event
)
;
delete
this
.
_event
;
break
;
}
}
}
onLocationChange
(
)
{
if
(
this
.
_popupInitialized
&
&
this
.
_permissionPopup
.
state
!
=
"
closed
"
)
{
this
.
_permissionReloadHint
.
hidden
=
true
;
}
}
updateSitePermissions
(
)
{
let
permissionItemSelector
=
[
"
.
permission
-
popup
-
permission
-
item
.
permission
-
popup
-
permission
-
item
-
container
"
]
;
this
.
_permissionList
.
querySelectorAll
(
permissionItemSelector
)
.
forEach
(
e
=
>
e
.
remove
(
)
)
;
this
.
_permissionLabelIndex
=
0
;
let
permissions
=
SitePermissions
.
getAllPermissionDetailsForBrowser
(
gBrowser
.
selectedBrowser
)
;
this
.
_sharingState
=
gBrowser
.
selectedTab
.
_sharingState
;
if
(
this
.
_sharingState
?
.
geo
)
{
let
geoPermission
=
permissions
.
find
(
perm
=
>
perm
.
id
=
=
=
"
geo
"
)
;
if
(
geoPermission
)
{
geoPermission
.
sharingState
=
true
;
}
else
{
permissions
.
push
(
{
id
:
"
geo
"
state
:
SitePermissions
.
ALLOW
scope
:
SitePermissions
.
SCOPE_REQUEST
sharingState
:
true
}
)
;
}
}
if
(
this
.
_sharingState
?
.
xr
)
{
let
xrPermission
=
permissions
.
find
(
perm
=
>
perm
.
id
=
=
=
"
xr
"
)
;
if
(
xrPermission
)
{
xrPermission
.
sharingState
=
true
;
}
else
{
permissions
.
push
(
{
id
:
"
xr
"
state
:
SitePermissions
.
ALLOW
scope
:
SitePermissions
.
SCOPE_REQUEST
sharingState
:
true
}
)
;
}
}
if
(
this
.
_sharingState
?
.
webRTC
)
{
let
webrtcState
=
this
.
_sharingState
.
webRTC
;
for
(
let
id
of
[
"
camera
"
"
microphone
"
"
screen
"
]
)
{
if
(
webrtcState
[
id
]
)
{
let
found
=
false
;
for
(
let
permission
of
permissions
)
{
let
[
permId
]
=
permission
.
id
.
split
(
SitePermissions
.
PERM_KEY_DELIMITER
)
;
if
(
permId
!
=
id
)
{
continue
;
}
found
=
true
;
permission
.
sharingState
=
webrtcState
[
id
]
;
}
if
(
!
found
)
{
permissions
.
push
(
{
id
state
:
SitePermissions
.
ALLOW
scope
:
SitePermissions
.
SCOPE_REQUEST
sharingState
:
webrtcState
[
id
]
}
)
;
}
}
}
}
let
totalBlockedPopups
=
gBrowser
.
selectedBrowser
.
popupBlocker
.
getBlockedPopupCount
(
)
;
let
hasBlockedPopupIndicator
=
false
;
for
(
let
permission
of
permissions
)
{
let
[
id
key
]
=
permission
.
id
.
split
(
SitePermissions
.
PERM_KEY_DELIMITER
)
;
if
(
id
=
=
"
storage
-
access
"
)
{
continue
;
}
let
item
;
let
anchor
=
this
.
_permissionList
.
querySelector
(
[
anchorfor
=
"
{
id
}
"
]
)
|
|
this
.
_defaultPermissionAnchor
;
if
(
id
=
=
"
open
-
protocol
-
handler
"
)
{
let
permContainer
=
this
.
_createProtocolHandlerPermissionItem
(
permission
key
)
;
if
(
permContainer
)
{
anchor
.
appendChild
(
permContainer
)
;
}
}
else
if
(
[
"
camera
"
"
screen
"
"
microphone
"
]
.
includes
(
id
)
)
{
item
=
this
.
_createWebRTCPermissionItem
(
permission
id
key
)
;
if
(
!
item
)
{
continue
;
}
anchor
.
appendChild
(
item
)
;
}
else
{
item
=
this
.
_createPermissionItem
(
{
permission
idNoSuffix
:
id
isContainer
:
id
=
=
"
geo
"
|
|
id
=
=
"
xr
"
nowrapLabel
:
id
=
=
"
3rdPartyStorage
"
}
)
;
if
(
!
item
)
{
continue
;
}
anchor
.
appendChild
(
item
)
;
}
if
(
id
=
=
"
popup
"
&
&
totalBlockedPopups
)
{
this
.
_createBlockedPopupIndicator
(
totalBlockedPopups
)
;
hasBlockedPopupIndicator
=
true
;
}
else
if
(
id
=
=
"
geo
"
&
&
permission
.
state
=
=
=
SitePermissions
.
ALLOW
)
{
this
.
_createGeoLocationLastAccessIndicator
(
)
;
}
}
if
(
totalBlockedPopups
&
&
!
hasBlockedPopupIndicator
)
{
let
permission
=
{
id
:
"
popup
"
state
:
SitePermissions
.
getDefault
(
"
popup
"
)
scope
:
SitePermissions
.
SCOPE_PERSISTENT
}
;
let
item
=
this
.
_createPermissionItem
(
{
permission
}
)
;
this
.
_defaultPermissionAnchor
.
appendChild
(
item
)
;
this
.
_createBlockedPopupIndicator
(
totalBlockedPopups
)
;
}
PanelView
.
forNode
(
this
.
_permissionPopupMainView
)
.
descriptionHeightWorkaround
(
)
;
}
_createPermissionItem
(
{
permission
isContainer
=
false
permClearButton
=
true
showStateLabel
=
true
idNoSuffix
=
permission
.
id
nowrapLabel
=
false
clearCallback
=
(
)
=
>
{
}
}
)
{
let
container
=
document
.
createXULElement
(
"
hbox
"
)
;
container
.
classList
.
add
(
"
permission
-
popup
-
permission
-
item
"
permission
-
popup
-
permission
-
item
-
{
idNoSuffix
}
)
;
container
.
setAttribute
(
"
align
"
"
center
"
)
;
container
.
setAttribute
(
"
role
"
"
group
"
)
;
let
img
=
document
.
createXULElement
(
"
image
"
)
;
img
.
classList
.
add
(
"
permission
-
popup
-
permission
-
icon
"
idNoSuffix
+
"
-
icon
"
)
;
if
(
permission
.
state
=
=
SitePermissions
.
BLOCK
|
|
permission
.
state
=
=
SitePermissions
.
AUTOPLAY_BLOCKED_ALL
)
{
img
.
classList
.
add
(
"
blocked
-
permission
-
icon
"
)
;
}
if
(
permission
.
sharingState
=
=
Ci
.
nsIMediaManagerService
.
STATE_CAPTURE_ENABLED
|
|
(
idNoSuffix
=
=
"
screen
"
&
&
permission
.
sharingState
&
&
!
permission
.
sharingState
.
includes
(
"
Paused
"
)
)
)
{
img
.
classList
.
add
(
"
in
-
use
"
)
;
}
let
nameLabel
=
document
.
createXULElement
(
"
label
"
)
;
nameLabel
.
setAttribute
(
"
flex
"
"
1
"
)
;
nameLabel
.
setAttribute
(
"
class
"
"
permission
-
popup
-
permission
-
label
"
)
;
let
label
=
SitePermissions
.
getPermissionLabel
(
permission
.
id
)
;
if
(
label
=
=
=
null
)
{
return
null
;
}
if
(
nowrapLabel
)
{
nameLabel
.
setAttribute
(
"
value
"
label
)
;
nameLabel
.
setAttribute
(
"
tooltiptext
"
label
)
;
nameLabel
.
setAttribute
(
"
crop
"
"
end
"
)
;
}
else
{
nameLabel
.
textContent
=
label
;
}
let
nameLabelId
=
permission
-
popup
-
permission
-
label
-
{
idNoSuffix
}
-
{
this
.
_permissionLabelIndex
+
+
}
;
nameLabel
.
setAttribute
(
"
id
"
nameLabelId
)
;
let
isPolicyPermission
=
[
SitePermissions
.
SCOPE_POLICY
SitePermissions
.
SCOPE_GLOBAL
]
.
includes
(
permission
.
scope
)
;
if
(
(
idNoSuffix
=
=
"
popup
"
&
&
!
isPolicyPermission
)
|
|
idNoSuffix
=
=
"
autoplay
-
media
"
)
{
let
menulist
=
document
.
createXULElement
(
"
menulist
"
)
;
let
menupopup
=
document
.
createXULElement
(
"
menupopup
"
)
;
let
block
=
document
.
createXULElement
(
"
vbox
"
)
;
block
.
setAttribute
(
"
id
"
"
permission
-
popup
-
container
"
)
;
block
.
setAttribute
(
"
class
"
"
permission
-
popup
-
permission
-
item
-
container
"
)
;
menulist
.
setAttribute
(
"
sizetopopup
"
"
none
"
)
;
menulist
.
setAttribute
(
"
id
"
"
permission
-
popup
-
menulist
"
)
;
for
(
let
state
of
SitePermissions
.
getAvailableStates
(
idNoSuffix
)
)
{
let
menuitem
=
document
.
createXULElement
(
"
menuitem
"
)
;
if
(
state
=
=
SitePermissions
.
getDefault
(
idNoSuffix
)
)
{
menuitem
.
setAttribute
(
"
value
"
"
0
"
)
;
}
else
{
menuitem
.
setAttribute
(
"
value
"
state
)
;
}
menuitem
.
setAttribute
(
"
label
"
SitePermissions
.
getMultichoiceStateLabel
(
idNoSuffix
state
)
)
;
menupopup
.
appendChild
(
menuitem
)
;
}
menulist
.
appendChild
(
menupopup
)
;
if
(
permission
.
state
=
=
SitePermissions
.
getDefault
(
idNoSuffix
)
)
{
menulist
.
value
=
"
0
"
;
}
else
{
menulist
.
value
=
permission
.
state
;
}
menulist
.
addEventListener
(
"
command
"
(
)
=
>
{
SitePermissions
.
setForPrincipal
(
gBrowser
.
contentPrincipal
permission
.
id
menulist
.
selectedItem
.
value
)
;
}
)
;
container
.
appendChild
(
img
)
;
container
.
appendChild
(
nameLabel
)
;
container
.
appendChild
(
menulist
)
;
container
.
setAttribute
(
"
aria
-
labelledby
"
nameLabelId
)
;
block
.
appendChild
(
container
)
;
return
block
;
}
container
.
appendChild
(
img
)
;
container
.
appendChild
(
nameLabel
)
;
let
labelledBy
=
nameLabelId
;
let
stateLabel
;
if
(
showStateLabel
)
{
stateLabel
=
this
.
_createStateLabel
(
permission
idNoSuffix
)
;
labelledBy
+
=
"
"
+
stateLabel
.
id
;
}
container
.
setAttribute
(
"
aria
-
labelledby
"
labelledBy
)
;
if
(
isPolicyPermission
)
{
if
(
stateLabel
)
{
container
.
appendChild
(
stateLabel
)
;
}
return
container
;
}
if
(
isContainer
)
{
let
block
=
document
.
createXULElement
(
"
vbox
"
)
;
block
.
setAttribute
(
"
id
"
"
permission
-
popup
-
"
+
idNoSuffix
+
"
-
container
"
)
;
block
.
setAttribute
(
"
class
"
"
permission
-
popup
-
permission
-
item
-
container
"
)
;
if
(
permClearButton
)
{
let
button
=
this
.
_createPermissionClearButton
(
{
permission
container
:
block
idNoSuffix
clearCallback
}
)
;
if
(
stateLabel
)
{
button
.
appendChild
(
stateLabel
)
;
}
container
.
appendChild
(
button
)
;
}
block
.
appendChild
(
container
)
;
return
block
;
}
if
(
permClearButton
)
{
let
button
=
this
.
_createPermissionClearButton
(
{
permission
container
idNoSuffix
clearCallback
}
)
;
if
(
stateLabel
)
{
button
.
appendChild
(
stateLabel
)
;
}
container
.
appendChild
(
button
)
;
}
return
container
;
}
_createStateLabel
(
aPermission
idNoSuffix
)
{
let
label
=
document
.
createXULElement
(
"
label
"
)
;
label
.
setAttribute
(
"
flex
"
"
1
"
)
;
label
.
setAttribute
(
"
class
"
"
permission
-
popup
-
permission
-
state
-
label
"
)
;
let
labelId
=
permission
-
popup
-
permission
-
state
-
label
-
{
idNoSuffix
}
-
{
this
.
_permissionLabelIndex
+
+
}
;
label
.
setAttribute
(
"
id
"
labelId
)
;
let
{
state
scope
}
=
aPermission
;
if
(
state
!
=
SitePermissions
.
ALLOW
&
&
aPermission
.
sharingState
)
{
state
=
SitePermissions
.
ALLOW
;
scope
=
SitePermissions
.
SCOPE_REQUEST
;
}
label
.
textContent
=
SitePermissions
.
getCurrentStateLabel
(
state
idNoSuffix
scope
)
;
return
label
;
}
_removePermPersistentAllow
(
principal
id
)
{
let
perm
=
SitePermissions
.
getForPrincipal
(
principal
id
)
;
if
(
perm
.
state
=
=
SitePermissions
.
ALLOW
&
&
perm
.
scope
=
=
SitePermissions
.
SCOPE_PERSISTENT
)
{
SitePermissions
.
removeFromPrincipal
(
principal
id
)
;
}
}
_createPermissionClearButton
(
{
permission
container
idNoSuffix
=
permission
.
id
clearCallback
=
(
)
=
>
{
}
}
)
{
let
button
=
document
.
createXULElement
(
"
button
"
)
;
button
.
setAttribute
(
"
class
"
"
permission
-
popup
-
permission
-
remove
-
button
"
)
;
let
tooltiptext
=
gNavigatorBundle
.
getString
(
"
permissions
.
remove
.
tooltip
"
)
;
button
.
setAttribute
(
"
tooltiptext
"
tooltiptext
)
;
button
.
addEventListener
(
"
command
"
(
)
=
>
{
let
browser
=
gBrowser
.
selectedBrowser
;
container
.
remove
(
)
;
if
(
permission
.
sharingState
&
&
idNoSuffix
=
=
=
"
xr
"
)
{
let
origins
=
browser
.
getDevicePermissionOrigins
(
idNoSuffix
)
;
for
(
let
origin
of
origins
)
{
let
principal
=
Services
.
scriptSecurityManager
.
createContentPrincipalFromOrigin
(
origin
)
;
this
.
_removePermPersistentAllow
(
principal
permission
.
id
)
;
}
origins
.
clear
(
)
;
}
SitePermissions
.
removeFromPrincipal
(
gBrowser
.
contentPrincipal
permission
.
id
browser
)
;
this
.
_permissionReloadHint
.
hidden
=
false
;
PanelView
.
forNode
(
this
.
_permissionPopupMainView
)
.
descriptionHeightWorkaround
(
)
;
if
(
idNoSuffix
=
=
=
"
geo
"
)
{
gBrowser
.
updateBrowserSharing
(
browser
{
geo
:
false
}
)
;
}
else
if
(
idNoSuffix
=
=
=
"
xr
"
)
{
gBrowser
.
updateBrowserSharing
(
browser
{
xr
:
false
}
)
;
}
clearCallback
(
)
;
}
)
;
return
button
;
}
_getGeoLocationLastAccess
(
)
{
return
new
Promise
(
resolve
=
>
{
let
lastAccess
=
null
;
ContentPrefService2
.
getByDomainAndName
(
gBrowser
.
currentURI
.
spec
"
permissions
.
geoLocation
.
lastAccess
"
gBrowser
.
selectedBrowser
.
loadContext
{
handleResult
(
pref
)
{
lastAccess
=
pref
.
value
;
}
handleCompletion
(
)
{
resolve
(
lastAccess
)
;
}
}
)
;
}
)
;
}
async
_createGeoLocationLastAccessIndicator
(
)
{
let
lastAccessStr
=
await
this
.
_getGeoLocationLastAccess
(
)
;
let
geoContainer
=
document
.
getElementById
(
"
permission
-
popup
-
geo
-
container
"
)
;
if
(
lastAccessStr
=
=
null
|
|
!
geoContainer
|
|
document
.
getElementById
(
"
geo
-
access
-
indicator
-
item
"
)
)
{
return
;
}
let
lastAccess
=
new
Date
(
lastAccessStr
)
;
if
(
isNaN
(
lastAccess
)
)
{
Cu
.
reportError
(
"
Invalid
timestamp
for
last
geolocation
access
"
)
;
return
;
}
let
indicator
=
document
.
createXULElement
(
"
hbox
"
)
;
indicator
.
setAttribute
(
"
class
"
"
permission
-
popup
-
permission
-
item
"
)
;
indicator
.
setAttribute
(
"
align
"
"
center
"
)
;
indicator
.
setAttribute
(
"
id
"
"
geo
-
access
-
indicator
-
item
"
)
;
let
timeFormat
=
new
Services
.
intl
.
RelativeTimeFormat
(
undefined
{
}
)
;
let
text
=
document
.
createXULElement
(
"
label
"
)
;
text
.
setAttribute
(
"
flex
"
"
1
"
)
;
text
.
setAttribute
(
"
class
"
"
permission
-
popup
-
permission
-
label
"
)
;
text
.
textContent
=
gNavigatorBundle
.
getFormattedString
(
"
geolocationLastAccessIndicatorText
"
[
timeFormat
.
formatBestUnit
(
lastAccess
)
]
)
;
indicator
.
appendChild
(
text
)
;
geoContainer
.
appendChild
(
indicator
)
;
}
_createWebRTCPermissionItem
(
permission
id
key
)
{
if
(
id
!
=
"
camera
"
&
&
id
!
=
"
microphone
"
&
&
id
!
=
"
screen
"
)
{
throw
new
Error
(
"
Invalid
permission
id
for
WebRTC
permission
item
.
"
)
;
}
if
(
key
&
&
permission
.
state
!
=
SitePermissions
.
ALLOW
)
{
return
null
;
}
let
item
=
document
.
querySelector
(
.
permission
-
popup
-
permission
-
item
-
{
id
}
)
;
if
(
key
)
{
if
(
item
)
{
return
null
;
}
}
else
if
(
item
)
{
item
.
remove
(
)
;
}
return
this
.
_createPermissionItem
(
{
permission
idNoSuffix
:
id
clearCallback
:
(
)
=
>
{
webrtcUI
.
clearPermissionsAndStopSharing
(
[
id
]
gBrowser
.
selectedTab
)
;
}
}
)
;
}
_createProtocolHandlerPermissionItem
(
permission
key
)
{
let
container
=
document
.
getElementById
(
"
permission
-
popup
-
open
-
protocol
-
handler
-
container
"
)
;
let
initialCall
;
if
(
!
container
)
{
container
=
this
.
_createPermissionItem
(
{
permission
isContainer
:
true
permClearButton
:
false
showStateLabel
:
false
idNoSuffix
:
"
open
-
protocol
-
handler
"
}
)
;
initialCall
=
true
;
}
let
item
=
document
.
createXULElement
(
"
hbox
"
)
;
item
.
setAttribute
(
"
class
"
"
permission
-
popup
-
permission
-
item
"
)
;
item
.
setAttribute
(
"
align
"
"
center
"
)
;
let
text
=
document
.
createXULElement
(
"
label
"
)
;
text
.
setAttribute
(
"
flex
"
"
1
"
)
;
text
.
setAttribute
(
"
class
"
"
permission
-
popup
-
permission
-
label
-
subitem
"
)
;
text
.
textContent
=
gNavigatorBundle
.
getFormattedString
(
"
openProtocolHandlerPermissionEntryLabel
"
[
key
]
)
;
let
stateLabel
=
this
.
_createStateLabel
(
permission
"
open
-
protocol
-
handler
"
)
;
item
.
appendChild
(
text
)
;
let
button
=
this
.
_createPermissionClearButton
(
{
permission
container
:
item
clearCallback
:
(
)
=
>
{
if
(
container
.
childElementCount
<
=
1
)
{
container
.
remove
(
)
;
}
}
}
)
;
button
.
appendChild
(
stateLabel
)
;
item
.
appendChild
(
button
)
;
container
.
appendChild
(
item
)
;
return
initialCall
&
&
container
;
}
_createBlockedPopupIndicator
(
aTotalBlockedPopups
)
{
let
indicator
=
document
.
createXULElement
(
"
hbox
"
)
;
indicator
.
setAttribute
(
"
class
"
"
permission
-
popup
-
permission
-
item
"
)
;
indicator
.
setAttribute
(
"
align
"
"
center
"
)
;
indicator
.
setAttribute
(
"
id
"
"
blocked
-
popup
-
indicator
-
item
"
)
;
MozXULElement
.
insertFTLIfNeeded
(
"
browser
/
sitePermissions
.
ftl
"
)
;
let
text
=
document
.
createXULElement
(
"
label
"
{
is
:
"
text
-
link
"
}
)
;
text
.
setAttribute
(
"
class
"
"
permission
-
popup
-
permission
-
label
"
)
;
text
.
setAttribute
(
"
data
-
l10n
-
id
"
"
site
-
permissions
-
open
-
blocked
-
popups
"
)
;
text
.
setAttribute
(
"
data
-
l10n
-
args
"
JSON
.
stringify
(
{
count
:
aTotalBlockedPopups
}
)
)
;
text
.
addEventListener
(
"
click
"
(
)
=
>
{
gBrowser
.
selectedBrowser
.
popupBlocker
.
unblockAllPopups
(
)
;
}
)
;
indicator
.
appendChild
(
text
)
;
document
.
getElementById
(
"
permission
-
popup
-
container
"
)
.
appendChild
(
indicator
)
;
}
}
;
function
hasMicCamGracePeriodsSolely
(
browser
)
{
let
perms
=
SitePermissions
.
getAllForBrowser
(
browser
)
;
let
micGrace
=
false
;
let
micGrant
=
false
;
let
camGrace
=
false
;
let
camGrant
=
false
;
for
(
const
perm
of
perms
)
{
if
(
perm
.
state
!
=
SitePermissions
.
ALLOW
)
{
continue
;
}
let
[
id
key
]
=
perm
.
id
.
split
(
SitePermissions
.
PERM_KEY_DELIMITER
)
;
let
temporary
=
!
!
key
&
&
perm
.
scope
=
=
SitePermissions
.
SCOPE_TEMPORARY
;
let
persistent
=
!
key
&
&
perm
.
scope
=
=
SitePermissions
.
SCOPE_PERSISTENT
;
if
(
id
=
=
"
microphone
"
)
{
if
(
temporary
)
{
micGrace
=
true
;
}
if
(
persistent
)
{
micGrant
=
true
;
}
continue
;
}
if
(
id
=
=
"
camera
"
)
{
if
(
temporary
)
{
camGrace
=
true
;
}
if
(
persistent
)
{
camGrant
=
true
;
}
}
}
return
{
micGrace
:
micGrace
&
&
!
micGrant
camGrace
:
camGrace
&
&
!
camGrant
}
;
}
