"
use
strict
"
;
var
kSkipCacheFlags
=
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_BYPASS_PROXY
|
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_BYPASS_CACHE
;
var
BrowserCommands
=
{
back
(
aEvent
)
{
const
where
=
BrowserUtils
.
whereToOpenLink
(
aEvent
false
true
)
;
if
(
where
=
=
"
current
"
)
{
try
{
gBrowser
.
goBack
(
)
;
}
catch
(
ex
)
{
}
}
else
{
duplicateTabIn
(
gBrowser
.
selectedTab
where
-
1
)
;
}
}
forward
(
aEvent
)
{
const
where
=
BrowserUtils
.
whereToOpenLink
(
aEvent
false
true
)
;
if
(
where
=
=
"
current
"
)
{
try
{
gBrowser
.
goForward
(
)
;
}
catch
(
ex
)
{
}
}
else
{
duplicateTabIn
(
gBrowser
.
selectedTab
where
1
)
;
}
}
handleBackspace
(
)
{
switch
(
Services
.
prefs
.
getIntPref
(
"
browser
.
backspace_action
"
)
)
{
case
0
:
this
.
back
(
)
;
break
;
case
1
:
goDoCommand
(
"
cmd_scrollPageUp
"
)
;
break
;
}
}
handleShiftBackspace
(
)
{
switch
(
Services
.
prefs
.
getIntPref
(
"
browser
.
backspace_action
"
)
)
{
case
0
:
this
.
forward
(
)
;
break
;
case
1
:
goDoCommand
(
"
cmd_scrollPageDown
"
)
;
break
;
}
}
gotoHistoryIndex
(
aEvent
)
{
aEvent
=
BrowserUtils
.
getRootEvent
(
aEvent
)
;
const
index
=
aEvent
.
target
.
getAttribute
(
"
index
"
)
;
if
(
!
index
)
{
return
false
;
}
const
where
=
BrowserUtils
.
whereToOpenLink
(
aEvent
)
;
if
(
where
=
=
"
current
"
)
{
try
{
gBrowser
.
gotoIndex
(
index
)
;
}
catch
(
ex
)
{
return
false
;
}
return
true
;
}
const
historyindex
=
aEvent
.
target
.
getAttribute
(
"
historyindex
"
)
;
duplicateTabIn
(
gBrowser
.
selectedTab
where
Number
(
historyindex
)
)
;
return
true
;
}
reloadOrDuplicate
(
aEvent
)
{
aEvent
=
BrowserUtils
.
getRootEvent
(
aEvent
)
;
const
accelKeyPressed
=
AppConstants
.
platform
=
=
"
macosx
"
?
aEvent
.
metaKey
:
aEvent
.
ctrlKey
;
const
backgroundTabModifier
=
aEvent
.
button
=
=
1
|
|
accelKeyPressed
;
if
(
aEvent
.
shiftKey
&
&
!
backgroundTabModifier
)
{
this
.
reloadSkipCache
(
)
;
return
;
}
const
where
=
BrowserUtils
.
whereToOpenLink
(
aEvent
false
true
)
;
if
(
where
=
=
"
current
"
)
{
this
.
reload
(
)
;
}
else
{
duplicateTabIn
(
gBrowser
.
selectedTab
where
)
;
}
}
reload
(
)
{
if
(
gBrowser
.
currentURI
.
schemeIs
(
"
view
-
source
"
)
)
{
this
.
reloadSkipCache
(
)
;
return
;
}
this
.
reloadWithFlags
(
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_NONE
)
;
}
reloadSkipCache
(
)
{
this
.
reloadWithFlags
(
kSkipCacheFlags
)
;
}
reloadWithFlags
(
reloadFlags
)
{
const
unchangedRemoteness
=
[
]
;
for
(
const
tab
of
gBrowser
.
selectedTabs
)
{
const
browser
=
tab
.
linkedBrowser
;
const
url
=
browser
.
currentURI
;
const
urlSpec
=
url
.
spec
;
const
principal
=
tab
.
linkedBrowser
.
contentPrincipal
;
if
(
gBrowser
.
updateBrowserRemotenessByURL
(
browser
urlSpec
)
)
{
if
(
tab
.
linkedPanel
)
{
loadBrowserURI
(
browser
url
principal
)
;
}
else
{
tab
.
addEventListener
(
"
SSTabRestoring
"
(
)
=
>
loadBrowserURI
(
browser
url
principal
)
{
once
:
true
}
)
;
gBrowser
.
_insertBrowser
(
tab
)
;
}
}
else
{
unchangedRemoteness
.
push
(
tab
)
;
}
}
if
(
!
unchangedRemoteness
.
length
)
{
return
;
}
for
(
const
tab
of
unchangedRemoteness
)
{
SitePermissions
.
clearTemporaryBlockPermissions
(
tab
.
linkedBrowser
)
;
delete
tab
.
linkedBrowser
.
authPromptAbuseCounter
;
}
gIdentityHandler
.
hidePopup
(
)
;
gPermissionPanel
.
hidePopup
(
)
;
const
handlingUserInput
=
document
.
hasValidTransientUserGestureActivation
;
for
(
const
tab
of
unchangedRemoteness
)
{
if
(
tab
.
linkedPanel
)
{
sendReloadMessage
(
tab
)
;
}
else
{
tab
.
addEventListener
(
"
SSTabRestoring
"
(
)
=
>
sendReloadMessage
(
tab
)
{
once
:
true
}
)
;
gBrowser
.
_insertBrowser
(
tab
)
;
}
}
function
loadBrowserURI
(
browser
url
principal
)
{
browser
.
loadURI
(
url
{
flags
:
reloadFlags
triggeringPrincipal
:
principal
}
)
;
}
function
sendReloadMessage
(
tab
)
{
tab
.
linkedBrowser
.
sendMessageToActor
(
"
Browser
:
Reload
"
{
flags
:
reloadFlags
handlingUserInput
}
"
BrowserTab
"
)
;
}
}
}
;
