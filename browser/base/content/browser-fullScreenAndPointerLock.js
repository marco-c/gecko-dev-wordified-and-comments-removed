var
PointerlockFsWarning
=
{
_element
:
null
_origin
:
null
Timeout
:
class
{
constructor
(
func
delay
)
{
this
.
_id
=
0
;
this
.
_func
=
func
;
this
.
_delay
=
delay
;
}
start
(
)
{
this
.
cancel
(
)
;
this
.
_id
=
setTimeout
(
(
)
=
>
this
.
_handle
(
)
this
.
_delay
)
;
}
cancel
(
)
{
if
(
this
.
_id
)
{
clearTimeout
(
this
.
_id
)
;
this
.
_id
=
0
;
}
}
_handle
(
)
{
this
.
_id
=
0
;
this
.
_func
(
)
;
}
get
delay
(
)
{
return
this
.
_delay
;
}
}
showPointerLock
(
aOrigin
)
{
if
(
!
document
.
fullscreen
)
{
let
timeout
=
Services
.
prefs
.
getIntPref
(
"
pointer
-
lock
-
api
.
warning
.
timeout
"
)
;
this
.
show
(
aOrigin
"
pointerlock
-
warning
"
timeout
0
)
;
}
}
showFullScreen
(
aOrigin
)
{
let
timeout
=
Services
.
prefs
.
getIntPref
(
"
full
-
screen
-
api
.
warning
.
timeout
"
)
;
let
delay
=
Services
.
prefs
.
getIntPref
(
"
full
-
screen
-
api
.
warning
.
delay
"
)
;
this
.
show
(
aOrigin
"
fullscreen
-
warning
"
timeout
delay
)
;
}
show
(
aOrigin
elementId
timeout
delay
)
{
if
(
!
this
.
_element
)
{
this
.
_element
=
document
.
getElementById
(
elementId
)
;
this
.
_element
.
addEventListener
(
"
transitionend
"
this
)
;
window
.
addEventListener
(
"
mousemove
"
this
true
)
;
this
.
_timeoutHide
=
new
this
.
Timeout
(
(
)
=
>
{
this
.
_state
=
"
hidden
"
;
}
timeout
)
;
this
.
_timeoutShow
=
new
this
.
Timeout
(
(
)
=
>
{
this
.
_state
=
"
ontop
"
;
this
.
_timeoutHide
.
start
(
)
;
}
delay
)
;
}
if
(
aOrigin
)
{
this
.
_origin
=
aOrigin
;
}
let
uri
=
Services
.
io
.
newURI
(
this
.
_origin
)
;
let
host
=
null
;
try
{
host
=
uri
.
host
;
}
catch
(
e
)
{
}
let
textElem
=
this
.
_element
.
querySelector
(
"
.
pointerlockfswarning
-
domain
-
text
"
)
;
if
(
!
host
)
{
textElem
.
setAttribute
(
"
hidden
"
true
)
;
}
else
{
textElem
.
removeAttribute
(
"
hidden
"
)
;
let
hostElem
=
this
.
_element
.
querySelector
(
"
.
pointerlockfswarning
-
domain
"
)
;
let
utils
=
{
}
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
DownloadUtils
.
jsm
"
utils
)
;
hostElem
.
textContent
=
utils
.
DownloadUtils
.
getURIHost
(
uri
.
spec
)
[
0
]
;
}
this
.
_element
.
dataset
.
identity
=
gIdentityHandler
.
pointerlockFsWarningClassName
;
if
(
this
.
_timeoutHide
.
delay
<
=
0
)
{
return
;
}
this
.
_state
=
"
onscreen
"
;
this
.
_lastState
=
"
hidden
"
;
this
.
_timeoutHide
.
start
(
)
;
}
close
(
)
{
if
(
!
this
.
_element
)
{
return
;
}
this
.
_timeoutHide
.
cancel
(
)
;
this
.
_timeoutShow
.
cancel
(
)
;
this
.
_state
=
"
hidden
"
;
this
.
_element
.
setAttribute
(
"
hidden
"
true
)
;
this
.
_element
.
removeEventListener
(
"
transitionend
"
this
)
;
window
.
removeEventListener
(
"
mousemove
"
this
true
)
;
this
.
_element
=
null
;
this
.
_timeoutHide
=
null
;
this
.
_timeoutShow
=
null
;
gBrowser
.
selectedBrowser
.
focus
(
)
;
}
_lastState
:
null
_STATES
:
[
"
hidden
"
"
ontop
"
"
onscreen
"
]
get
_state
(
)
{
for
(
let
state
of
this
.
_STATES
)
{
if
(
this
.
_element
.
hasAttribute
(
state
)
)
{
return
state
;
}
}
return
"
hiding
"
;
}
set
_state
(
newState
)
{
let
currentState
=
this
.
_state
;
if
(
currentState
=
=
newState
)
{
return
;
}
if
(
currentState
!
=
"
hiding
"
)
{
this
.
_lastState
=
currentState
;
this
.
_element
.
removeAttribute
(
currentState
)
;
}
if
(
newState
!
=
"
hidden
"
)
{
if
(
currentState
!
=
"
hidden
"
)
{
this
.
_element
.
setAttribute
(
newState
true
)
;
}
else
{
requestAnimationFrame
(
(
)
=
>
{
requestAnimationFrame
(
(
)
=
>
{
if
(
this
.
_element
)
{
this
.
_element
.
setAttribute
(
newState
true
)
;
}
}
)
;
}
)
;
}
}
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
mousemove
"
:
{
let
state
=
this
.
_state
;
if
(
state
=
=
"
hidden
"
)
{
if
(
event
.
clientY
!
=
0
)
{
this
.
_timeoutShow
.
cancel
(
)
;
}
else
if
(
this
.
_timeoutShow
.
delay
>
=
0
)
{
this
.
_timeoutShow
.
start
(
)
;
}
}
else
{
let
elemRect
=
this
.
_element
.
getBoundingClientRect
(
)
;
if
(
state
=
=
"
hiding
"
&
&
this
.
_lastState
!
=
"
hidden
"
)
{
if
(
event
.
clientY
<
=
elemRect
.
bottom
+
50
)
{
this
.
_state
=
this
.
_lastState
;
this
.
_timeoutHide
.
start
(
)
;
}
}
else
if
(
state
=
=
"
ontop
"
|
|
this
.
_lastState
!
=
"
hidden
"
)
{
if
(
event
.
clientY
>
elemRect
.
bottom
+
50
)
{
this
.
_state
=
"
hidden
"
;
this
.
_timeoutHide
.
cancel
(
)
;
}
}
}
break
;
}
case
"
transitionend
"
:
{
if
(
this
.
_state
=
=
"
hiding
"
)
{
this
.
_element
.
setAttribute
(
"
hidden
"
true
)
;
}
break
;
}
}
}
}
;
var
PointerLock
=
{
init
(
)
{
window
.
messageManager
.
addMessageListener
(
"
PointerLock
:
Entered
"
this
)
;
window
.
messageManager
.
addMessageListener
(
"
PointerLock
:
Exited
"
this
)
;
}
receiveMessage
(
aMessage
)
{
switch
(
aMessage
.
name
)
{
case
"
PointerLock
:
Entered
"
:
{
PointerlockFsWarning
.
showPointerLock
(
aMessage
.
data
.
originNoSuffix
)
;
break
;
}
case
"
PointerLock
:
Exited
"
:
{
PointerlockFsWarning
.
close
(
)
;
break
;
}
}
}
}
;
var
FullScreen
=
{
_MESSAGES
:
[
"
DOMFullscreen
:
Request
"
"
DOMFullscreen
:
NewOrigin
"
"
DOMFullscreen
:
Exit
"
"
DOMFullscreen
:
Painted
"
]
init
(
)
{
window
.
addEventListener
(
"
fullscreen
"
this
true
)
;
window
.
addEventListener
(
"
willenterfullscreen
"
this
true
)
;
window
.
addEventListener
(
"
willexitfullscreen
"
this
true
)
;
window
.
addEventListener
(
"
MozDOMFullscreen
:
Entered
"
this
true
false
)
;
window
.
addEventListener
(
"
MozDOMFullscreen
:
Exited
"
this
true
false
)
;
for
(
let
type
of
this
.
_MESSAGES
)
{
window
.
messageManager
.
addMessageListener
(
type
this
)
;
}
if
(
window
.
fullScreen
)
this
.
toggle
(
)
;
}
uninit
(
)
{
for
(
let
type
of
this
.
_MESSAGES
)
{
window
.
messageManager
.
removeMessageListener
(
type
this
)
;
}
this
.
cleanup
(
)
;
}
willToggle
(
aWillEnterFullscreen
)
{
if
(
aWillEnterFullscreen
)
{
document
.
documentElement
.
setAttribute
(
"
inFullscreen
"
true
)
;
}
else
{
document
.
documentElement
.
removeAttribute
(
"
inFullscreen
"
)
;
}
}
toggle
(
)
{
var
enterFS
=
window
.
fullScreen
;
let
fullscreenCommand
=
document
.
getElementById
(
"
View
:
FullScreen
"
)
;
if
(
enterFS
)
{
fullscreenCommand
.
setAttribute
(
"
checked
"
enterFS
)
;
}
else
{
fullscreenCommand
.
removeAttribute
(
"
checked
"
)
;
}
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
document
.
getElementById
(
"
enterFullScreenItem
"
)
.
hidden
=
enterFS
;
document
.
getElementById
(
"
exitFullScreenItem
"
)
.
hidden
=
!
enterFS
;
}
if
(
!
this
.
_fullScrToggler
)
{
this
.
_fullScrToggler
=
document
.
getElementById
(
"
fullscr
-
toggler
"
)
;
this
.
_fullScrToggler
.
addEventListener
(
"
mouseover
"
this
.
_expandCallback
)
;
this
.
_fullScrToggler
.
addEventListener
(
"
dragenter
"
this
.
_expandCallback
)
;
this
.
_fullScrToggler
.
addEventListener
(
"
touchmove
"
this
.
_expandCallback
{
passive
:
true
}
)
;
}
if
(
enterFS
)
{
gNavToolbox
.
setAttribute
(
"
inFullscreen
"
true
)
;
document
.
documentElement
.
setAttribute
(
"
inFullscreen
"
true
)
;
if
(
!
document
.
fullscreenElement
&
&
this
.
useLionFullScreen
)
document
.
documentElement
.
setAttribute
(
"
OSXLionFullscreen
"
true
)
;
}
else
{
gNavToolbox
.
removeAttribute
(
"
inFullscreen
"
)
;
document
.
documentElement
.
removeAttribute
(
"
inFullscreen
"
)
;
document
.
documentElement
.
removeAttribute
(
"
OSXLionFullscreen
"
)
;
}
if
(
!
document
.
fullscreenElement
)
this
.
_updateToolbars
(
enterFS
)
;
if
(
enterFS
)
{
document
.
addEventListener
(
"
keypress
"
this
.
_keyToggleCallback
)
;
document
.
addEventListener
(
"
popupshown
"
this
.
_setPopupOpen
)
;
document
.
addEventListener
(
"
popuphidden
"
this
.
_setPopupOpen
)
;
if
(
!
document
.
fullscreenElement
)
this
.
hideNavToolbox
(
true
)
;
}
else
{
this
.
showNavToolbox
(
false
)
;
this
.
_isPopupOpen
=
false
;
this
.
cleanup
(
)
;
TabsInTitlebar
.
update
(
)
;
}
if
(
enterFS
&
&
!
document
.
fullscreenElement
)
{
Services
.
telemetry
.
getHistogramById
(
"
FX_BROWSER_FULLSCREEN_USED
"
)
.
add
(
1
)
;
}
}
exitDomFullScreen
(
)
{
document
.
exitFullscreen
(
)
;
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
willenterfullscreen
"
:
this
.
willToggle
(
true
)
;
break
;
case
"
willexitfullscreen
"
:
this
.
willToggle
(
false
)
;
break
;
case
"
fullscreen
"
:
this
.
toggle
(
)
;
break
;
case
"
MozDOMFullscreen
:
Entered
"
:
{
let
browser
;
if
(
event
.
target
.
ownerGlobal
=
=
window
)
{
browser
=
event
.
target
;
}
else
{
let
topWin
=
event
.
target
.
ownerGlobal
.
top
;
browser
=
gBrowser
.
getBrowserForContentWindow
(
topWin
)
;
}
TelemetryStopwatch
.
start
(
"
FULLSCREEN_CHANGE_MS
"
)
;
this
.
enterDomFullscreen
(
browser
)
;
break
;
}
case
"
MozDOMFullscreen
:
Exited
"
:
TelemetryStopwatch
.
start
(
"
FULLSCREEN_CHANGE_MS
"
)
;
this
.
cleanupDomFullscreen
(
)
;
break
;
}
}
receiveMessage
(
aMessage
)
{
let
browser
=
aMessage
.
target
;
switch
(
aMessage
.
name
)
{
case
"
DOMFullscreen
:
Request
"
:
{
window
.
windowUtils
.
remoteFrameFullscreenChanged
(
browser
)
;
break
;
}
case
"
DOMFullscreen
:
NewOrigin
"
:
{
if
(
document
.
fullscreen
)
{
PointerlockFsWarning
.
showFullScreen
(
aMessage
.
data
.
originNoSuffix
)
;
}
break
;
}
case
"
DOMFullscreen
:
Exit
"
:
{
window
.
windowUtils
.
remoteFrameFullscreenReverted
(
)
;
break
;
}
case
"
DOMFullscreen
:
Painted
"
:
{
Services
.
obs
.
notifyObservers
(
window
"
fullscreen
-
painted
"
)
;
TelemetryStopwatch
.
finish
(
"
FULLSCREEN_CHANGE_MS
"
)
;
break
;
}
}
}
enterDomFullscreen
(
aBrowser
)
{
if
(
!
document
.
fullscreenElement
)
{
return
;
}
PointerlockFsWarning
.
close
(
)
;
if
(
this
.
_isRemoteBrowser
(
aBrowser
)
)
{
aBrowser
.
messageManager
.
sendAsyncMessage
(
"
DOMFullscreen
:
Entered
"
)
;
}
if
(
!
aBrowser
|
|
gBrowser
.
selectedBrowser
!
=
aBrowser
|
|
Services
.
focus
.
activeWindow
!
=
window
)
{
setTimeout
(
(
)
=
>
document
.
exitFullscreen
(
)
0
)
;
return
;
}
document
.
documentElement
.
setAttribute
(
"
inDOMFullscreen
"
true
)
;
if
(
gFindBarInitialized
)
{
gFindBar
.
close
(
true
)
;
}
gBrowser
.
tabContainer
.
addEventListener
(
"
TabSelect
"
this
.
exitDomFullScreen
)
;
window
.
addEventListener
(
"
activate
"
this
)
;
}
cleanup
(
)
{
if
(
!
window
.
fullScreen
)
{
MousePosTracker
.
removeListener
(
this
)
;
document
.
removeEventListener
(
"
keypress
"
this
.
_keyToggleCallback
)
;
document
.
removeEventListener
(
"
popupshown
"
this
.
_setPopupOpen
)
;
document
.
removeEventListener
(
"
popuphidden
"
this
.
_setPopupOpen
)
;
}
}
cleanupDomFullscreen
(
)
{
window
.
messageManager
.
broadcastAsyncMessage
(
"
DOMFullscreen
:
CleanUp
"
)
;
PointerlockFsWarning
.
close
(
)
;
gBrowser
.
tabContainer
.
removeEventListener
(
"
TabSelect
"
this
.
exitDomFullScreen
)
;
window
.
removeEventListener
(
"
activate
"
this
)
;
document
.
documentElement
.
removeAttribute
(
"
inDOMFullscreen
"
)
;
}
_isRemoteBrowser
(
aBrowser
)
{
return
gMultiProcessBrowser
&
&
aBrowser
.
getAttribute
(
"
remote
"
)
=
=
"
true
"
;
}
getMouseTargetRect
(
)
{
return
this
.
_mouseTargetRect
;
}
_expandCallback
(
)
{
FullScreen
.
showNavToolbox
(
)
;
}
onMouseEnter
(
)
{
FullScreen
.
hideNavToolbox
(
)
;
}
_keyToggleCallback
(
aEvent
)
{
if
(
aEvent
.
keyCode
=
=
aEvent
.
DOM_VK_ESCAPE
)
{
FullScreen
.
hideNavToolbox
(
)
;
}
else
if
(
aEvent
.
keyCode
=
=
aEvent
.
DOM_VK_F6
)
{
FullScreen
.
showNavToolbox
(
)
;
}
}
_isPopupOpen
:
false
_isChromeCollapsed
:
false
_safeToCollapse
(
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
"
browser
.
fullscreen
.
autohide
"
)
)
return
false
;
if
(
this
.
_isPopupOpen
)
return
false
;
if
(
this
.
useLionFullScreen
)
return
false
;
if
(
document
.
commandDispatcher
.
focusedElement
&
&
document
.
commandDispatcher
.
focusedElement
.
ownerDocument
=
=
document
&
&
document
.
commandDispatcher
.
focusedElement
.
localName
=
=
"
input
"
)
{
return
false
;
}
return
true
;
}
_setPopupOpen
(
aEvent
)
{
if
(
aEvent
.
type
=
=
"
popupshown
"
&
&
!
FullScreen
.
_isChromeCollapsed
&
&
aEvent
.
target
.
localName
!
=
"
tooltip
"
&
&
aEvent
.
target
.
localName
!
=
"
window
"
&
&
aEvent
.
target
.
getAttribute
(
"
nopreventnavboxhide
"
)
!
=
"
true
"
)
FullScreen
.
_isPopupOpen
=
true
;
else
if
(
aEvent
.
type
=
=
"
popuphidden
"
&
&
aEvent
.
target
.
localName
!
=
"
tooltip
"
&
&
aEvent
.
target
.
localName
!
=
"
window
"
)
{
FullScreen
.
_isPopupOpen
=
false
;
FullScreen
.
hideNavToolbox
(
true
)
;
}
}
get
navToolboxHidden
(
)
{
return
this
.
_isChromeCollapsed
;
}
getAutohide
(
aItem
)
{
aItem
.
setAttribute
(
"
checked
"
Services
.
prefs
.
getBoolPref
(
"
browser
.
fullscreen
.
autohide
"
)
)
;
}
setAutohide
(
)
{
Services
.
prefs
.
setBoolPref
(
"
browser
.
fullscreen
.
autohide
"
!
Services
.
prefs
.
getBoolPref
(
"
browser
.
fullscreen
.
autohide
"
)
)
;
FullScreen
.
hideNavToolbox
(
true
)
;
}
showNavToolbox
(
trackMouse
=
true
)
{
this
.
_fullScrToggler
.
hidden
=
true
;
gNavToolbox
.
removeAttribute
(
"
fullscreenShouldAnimate
"
)
;
gNavToolbox
.
style
.
marginTop
=
"
"
;
if
(
!
this
.
_isChromeCollapsed
)
{
return
;
}
if
(
trackMouse
&
&
!
this
.
useLionFullScreen
)
{
let
rect
=
gBrowser
.
tabpanels
.
getBoundingClientRect
(
)
;
this
.
_mouseTargetRect
=
{
top
:
rect
.
top
+
50
bottom
:
rect
.
bottom
left
:
rect
.
left
right
:
rect
.
right
}
;
MousePosTracker
.
addListener
(
this
)
;
}
this
.
_isChromeCollapsed
=
false
;
Services
.
obs
.
notifyObservers
(
null
"
fullscreen
-
nav
-
toolbox
"
"
shown
"
)
;
}
hideNavToolbox
(
aAnimate
=
false
)
{
if
(
this
.
_isChromeCollapsed
|
|
!
this
.
_safeToCollapse
(
)
)
return
;
this
.
_fullScrToggler
.
hidden
=
false
;
if
(
aAnimate
&
&
Services
.
prefs
.
getBoolPref
(
"
toolkit
.
cosmeticAnimations
.
enabled
"
)
)
{
gNavToolbox
.
setAttribute
(
"
fullscreenShouldAnimate
"
true
)
;
let
listener
=
(
)
=
>
{
gNavToolbox
.
removeEventListener
(
"
transitionend
"
listener
true
)
;
if
(
this
.
_isChromeCollapsed
)
this
.
_fullScrToggler
.
hidden
=
false
;
}
;
gNavToolbox
.
addEventListener
(
"
transitionend
"
listener
true
)
;
this
.
_fullScrToggler
.
hidden
=
true
;
}
gNavToolbox
.
style
.
marginTop
=
-
gNavToolbox
.
getBoundingClientRect
(
)
.
height
+
"
px
"
;
this
.
_isChromeCollapsed
=
true
;
Services
.
obs
.
notifyObservers
(
null
"
fullscreen
-
nav
-
toolbox
"
"
hidden
"
)
;
MousePosTracker
.
removeListener
(
this
)
;
}
_updateToolbars
(
aEnterFS
)
{
for
(
let
el
of
document
.
querySelectorAll
(
"
toolbar
[
fullscreentoolbar
=
true
]
"
)
)
{
if
(
aEnterFS
)
{
el
.
setAttribute
(
"
saved
-
context
"
el
.
getAttribute
(
"
context
"
)
)
;
if
(
el
.
id
=
=
"
nav
-
bar
"
|
|
el
.
id
=
=
"
TabsToolbar
"
)
el
.
setAttribute
(
"
context
"
"
autohide
-
context
"
)
;
else
el
.
removeAttribute
(
"
context
"
)
;
el
.
setAttribute
(
"
inFullscreen
"
true
)
;
}
else
{
if
(
el
.
hasAttribute
(
"
saved
-
context
"
)
)
{
el
.
setAttribute
(
"
context
"
el
.
getAttribute
(
"
saved
-
context
"
)
)
;
el
.
removeAttribute
(
"
saved
-
context
"
)
;
}
el
.
removeAttribute
(
"
inFullscreen
"
)
;
}
}
ToolbarIconColor
.
inferFromText
(
"
fullscreen
"
aEnterFS
)
;
if
(
this
.
useLionFullScreen
)
{
return
;
}
var
fullscreenctls
=
document
.
getElementById
(
"
window
-
controls
"
)
;
var
navbar
=
document
.
getElementById
(
"
nav
-
bar
"
)
;
var
ctlsOnTabbar
=
window
.
toolbar
.
visible
;
if
(
fullscreenctls
.
parentNode
=
=
navbar
&
&
ctlsOnTabbar
)
{
fullscreenctls
.
removeAttribute
(
"
flex
"
)
;
document
.
getElementById
(
"
TabsToolbar
"
)
.
appendChild
(
fullscreenctls
)
;
}
else
if
(
fullscreenctls
.
parentNode
.
id
=
=
"
TabsToolbar
"
&
&
!
ctlsOnTabbar
)
{
fullscreenctls
.
setAttribute
(
"
flex
"
"
1
"
)
;
navbar
.
appendChild
(
fullscreenctls
)
;
}
fullscreenctls
.
hidden
=
!
aEnterFS
;
}
}
;
XPCOMUtils
.
defineLazyGetter
(
FullScreen
"
useLionFullScreen
"
function
(
)
{
return
AppConstants
.
isPlatformAndVersionAtLeast
(
"
macosx
"
11
)
&
&
document
.
documentElement
.
getAttribute
(
"
fullscreenbutton
"
)
=
=
"
true
"
;
}
)
;
