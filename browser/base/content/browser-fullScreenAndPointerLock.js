var
PointerlockFsWarning
=
{
_element
:
null
_origin
:
null
Timeout
:
class
{
constructor
(
func
delay
)
{
this
.
_id
=
0
;
this
.
_func
=
func
;
this
.
_delay
=
delay
;
}
start
(
)
{
this
.
cancel
(
)
;
this
.
_id
=
setTimeout
(
(
)
=
>
this
.
_handle
(
)
this
.
_delay
)
;
}
cancel
(
)
{
if
(
this
.
_id
)
{
clearTimeout
(
this
.
_id
)
;
this
.
_id
=
0
;
}
}
_handle
(
)
{
this
.
_id
=
0
;
this
.
_func
(
)
;
}
get
delay
(
)
{
return
this
.
_delay
;
}
}
showPointerLock
(
aOrigin
)
{
if
(
!
document
.
fullscreen
)
{
let
timeout
=
Services
.
prefs
.
getIntPref
(
"
pointer
-
lock
-
api
.
warning
.
timeout
"
)
;
this
.
show
(
aOrigin
"
pointerlock
-
warning
"
timeout
0
)
;
}
}
showFullScreen
(
aOrigin
)
{
let
timeout
=
Services
.
prefs
.
getIntPref
(
"
full
-
screen
-
api
.
warning
.
timeout
"
)
;
let
delay
=
Services
.
prefs
.
getIntPref
(
"
full
-
screen
-
api
.
warning
.
delay
"
)
;
this
.
show
(
aOrigin
"
fullscreen
-
warning
"
timeout
delay
)
;
}
show
(
aOrigin
elementId
timeout
delay
)
{
if
(
!
this
.
_element
)
{
this
.
_element
=
document
.
getElementById
(
elementId
)
;
this
.
_element
.
addEventListener
(
"
transitionend
"
this
)
;
window
.
addEventListener
(
"
mousemove
"
this
true
)
;
this
.
_timeoutHide
=
new
this
.
Timeout
(
(
)
=
>
{
this
.
_state
=
"
hidden
"
;
}
timeout
)
;
this
.
_timeoutShow
=
new
this
.
Timeout
(
(
)
=
>
{
this
.
_state
=
"
ontop
"
;
this
.
_timeoutHide
.
start
(
)
;
}
delay
)
;
}
if
(
aOrigin
)
{
this
.
_origin
=
aOrigin
;
}
let
uri
=
Services
.
io
.
newURI
(
this
.
_origin
)
;
let
host
=
null
;
try
{
host
=
uri
.
host
;
}
catch
(
e
)
{
}
let
textElem
=
this
.
_element
.
querySelector
(
"
.
pointerlockfswarning
-
domain
-
text
"
)
;
if
(
!
host
)
{
textElem
.
setAttribute
(
"
hidden
"
true
)
;
}
else
{
textElem
.
removeAttribute
(
"
hidden
"
)
;
let
hostElem
=
this
.
_element
.
querySelector
(
"
.
pointerlockfswarning
-
domain
"
)
;
let
utils
=
{
}
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
DownloadUtils
.
jsm
"
utils
)
;
hostElem
.
textContent
=
utils
.
DownloadUtils
.
getURIHost
(
uri
.
spec
)
[
0
]
;
}
this
.
_element
.
dataset
.
identity
=
gIdentityHandler
.
pointerlockFsWarningClassName
;
if
(
this
.
_timeoutHide
.
delay
<
=
0
)
{
return
;
}
this
.
_state
=
"
onscreen
"
;
this
.
_lastState
=
"
hidden
"
;
this
.
_timeoutHide
.
start
(
)
;
}
close
(
)
{
if
(
!
this
.
_element
)
{
return
;
}
this
.
_timeoutHide
.
cancel
(
)
;
this
.
_timeoutShow
.
cancel
(
)
;
this
.
_state
=
"
hidden
"
;
this
.
_element
.
setAttribute
(
"
hidden
"
true
)
;
this
.
_element
.
removeEventListener
(
"
transitionend
"
this
)
;
window
.
removeEventListener
(
"
mousemove
"
this
true
)
;
this
.
_element
=
null
;
this
.
_timeoutHide
=
null
;
this
.
_timeoutShow
=
null
;
gBrowser
.
selectedBrowser
.
focus
(
)
;
}
_lastState
:
null
_STATES
:
[
"
hidden
"
"
ontop
"
"
onscreen
"
]
get
_state
(
)
{
for
(
let
state
of
this
.
_STATES
)
{
if
(
this
.
_element
.
hasAttribute
(
state
)
)
{
return
state
;
}
}
return
"
hiding
"
;
}
set
_state
(
newState
)
{
let
currentState
=
this
.
_state
;
if
(
currentState
=
=
newState
)
{
return
;
}
if
(
currentState
!
=
"
hiding
"
)
{
this
.
_lastState
=
currentState
;
this
.
_element
.
removeAttribute
(
currentState
)
;
}
if
(
newState
!
=
"
hidden
"
)
{
if
(
currentState
!
=
"
hidden
"
)
{
this
.
_element
.
setAttribute
(
newState
true
)
;
}
else
{
requestAnimationFrame
(
(
)
=
>
{
requestAnimationFrame
(
(
)
=
>
{
if
(
this
.
_element
)
{
this
.
_element
.
setAttribute
(
newState
true
)
;
}
}
)
;
}
)
;
}
}
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
mousemove
"
:
{
let
state
=
this
.
_state
;
if
(
state
=
=
"
hidden
"
)
{
if
(
event
.
clientY
!
=
0
)
{
this
.
_timeoutShow
.
cancel
(
)
;
}
else
if
(
this
.
_timeoutShow
.
delay
>
=
0
)
{
this
.
_timeoutShow
.
start
(
)
;
}
}
else
{
let
elemRect
=
this
.
_element
.
getBoundingClientRect
(
)
;
if
(
state
=
=
"
hiding
"
&
&
this
.
_lastState
!
=
"
hidden
"
)
{
if
(
event
.
clientY
<
=
elemRect
.
bottom
+
50
)
{
this
.
_state
=
this
.
_lastState
;
this
.
_timeoutHide
.
start
(
)
;
}
}
else
if
(
state
=
=
"
ontop
"
|
|
this
.
_lastState
!
=
"
hidden
"
)
{
if
(
event
.
clientY
>
elemRect
.
bottom
+
50
)
{
this
.
_state
=
"
hidden
"
;
this
.
_timeoutHide
.
cancel
(
)
;
}
}
}
break
;
}
case
"
transitionend
"
:
{
if
(
this
.
_state
=
=
"
hiding
"
)
{
this
.
_element
.
setAttribute
(
"
hidden
"
true
)
;
}
break
;
}
}
}
}
;
var
PointerLock
=
{
entered
(
originNoSuffix
)
{
PointerlockFsWarning
.
showPointerLock
(
originNoSuffix
)
;
}
exited
(
)
{
PointerlockFsWarning
.
close
(
)
;
}
}
;
var
FullScreen
=
{
init
(
)
{
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
permissionsFullScreenAllowed
"
"
permissions
.
fullscreen
.
allowed
"
)
;
addEventListener
(
"
fullscreen
"
this
true
)
;
addEventListener
(
"
willenterfullscreen
"
this
true
)
;
addEventListener
(
"
willexitfullscreen
"
this
true
)
;
if
(
window
.
fullScreen
)
{
this
.
toggle
(
)
;
}
}
uninit
(
)
{
this
.
cleanup
(
)
;
}
willToggle
(
aWillEnterFullscreen
)
{
if
(
aWillEnterFullscreen
)
{
document
.
documentElement
.
setAttribute
(
"
inFullscreen
"
true
)
;
}
else
{
document
.
documentElement
.
removeAttribute
(
"
inFullscreen
"
)
;
}
}
toggle
(
)
{
var
enterFS
=
window
.
fullScreen
;
let
fullscreenCommand
=
document
.
getElementById
(
"
View
:
FullScreen
"
)
;
if
(
enterFS
)
{
fullscreenCommand
.
setAttribute
(
"
checked
"
enterFS
)
;
}
else
{
fullscreenCommand
.
removeAttribute
(
"
checked
"
)
;
}
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
document
.
getElementById
(
"
enterFullScreenItem
"
)
.
hidden
=
enterFS
;
document
.
getElementById
(
"
exitFullScreenItem
"
)
.
hidden
=
!
enterFS
;
}
if
(
!
this
.
_fullScrToggler
)
{
this
.
_fullScrToggler
=
document
.
getElementById
(
"
fullscr
-
toggler
"
)
;
this
.
_fullScrToggler
.
addEventListener
(
"
mouseover
"
this
.
_expandCallback
)
;
this
.
_fullScrToggler
.
addEventListener
(
"
dragenter
"
this
.
_expandCallback
)
;
this
.
_fullScrToggler
.
addEventListener
(
"
touchmove
"
this
.
_expandCallback
{
passive
:
true
}
)
;
}
if
(
enterFS
)
{
gNavToolbox
.
setAttribute
(
"
inFullscreen
"
true
)
;
document
.
documentElement
.
setAttribute
(
"
inFullscreen
"
true
)
;
let
alwaysUsesNativeFullscreen
=
AppConstants
.
platform
=
=
"
macosx
"
&
&
Services
.
prefs
.
getBoolPref
(
"
full
-
screen
-
api
.
macos
-
native
-
full
-
screen
"
)
;
if
(
(
alwaysUsesNativeFullscreen
|
|
!
document
.
fullscreenElement
)
&
&
this
.
useLionFullScreen
)
{
document
.
documentElement
.
setAttribute
(
"
OSXLionFullscreen
"
true
)
;
}
}
else
{
gNavToolbox
.
removeAttribute
(
"
inFullscreen
"
)
;
document
.
documentElement
.
removeAttribute
(
"
inFullscreen
"
)
;
document
.
documentElement
.
removeAttribute
(
"
OSXLionFullscreen
"
)
;
}
if
(
!
document
.
fullscreenElement
)
{
this
.
_updateToolbars
(
enterFS
)
;
}
if
(
enterFS
)
{
document
.
addEventListener
(
"
keypress
"
this
.
_keyToggleCallback
)
;
document
.
addEventListener
(
"
popupshown
"
this
.
_setPopupOpen
)
;
document
.
addEventListener
(
"
popuphidden
"
this
.
_setPopupOpen
)
;
gURLBar
.
controller
.
addQueryListener
(
this
)
;
if
(
!
document
.
fullscreenElement
)
{
this
.
hideNavToolbox
(
true
)
;
}
}
else
{
this
.
showNavToolbox
(
false
)
;
this
.
_isPopupOpen
=
false
;
this
.
cleanup
(
)
;
}
if
(
enterFS
&
&
!
document
.
fullscreenElement
)
{
Services
.
telemetry
.
getHistogramById
(
"
FX_BROWSER_FULLSCREEN_USED
"
)
.
add
(
1
)
;
}
}
exitDomFullScreen
(
)
{
document
.
exitFullscreen
(
)
;
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
willenterfullscreen
"
:
this
.
willToggle
(
true
)
;
break
;
case
"
willexitfullscreen
"
:
this
.
willToggle
(
false
)
;
break
;
case
"
fullscreen
"
:
this
.
toggle
(
)
;
break
;
}
}
_logWarningPermissionPromptFS
(
actionStringKey
)
{
let
consoleMsg
=
Cc
[
"
mozilla
.
org
/
scripterror
;
1
"
]
.
createInstance
(
Ci
.
nsIScriptError
)
;
let
message
=
gBrowserBundle
.
GetStringFromName
(
permissions
.
fullscreen
.
{
actionStringKey
}
)
;
consoleMsg
.
initWithWindowID
(
message
gBrowser
.
currentURI
.
spec
null
0
0
Ci
.
nsIScriptError
.
warningFlag
"
FullScreen
"
gBrowser
.
selectedBrowser
.
innerWindowID
)
;
Services
.
console
.
logMessage
(
consoleMsg
)
;
}
_handlePermPromptShow
(
)
{
if
(
!
FullScreen
.
permissionsFullScreenAllowed
&
&
window
.
fullScreen
&
&
PopupNotifications
.
getNotification
(
this
.
_permissionNotificationIDs
)
.
filter
(
n
=
>
!
n
.
dismissed
)
.
length
)
{
this
.
exitDomFullScreen
(
)
;
this
.
_logWarningPermissionPromptFS
(
"
fullScreenCanceled
"
)
;
}
}
enterDomFullscreen
(
aBrowser
aActor
)
{
if
(
!
document
.
fullscreenElement
)
{
aActor
.
requestOrigin
=
null
;
return
;
}
PointerlockFsWarning
.
close
(
)
;
if
(
this
.
_isRemoteBrowser
(
aBrowser
)
)
{
if
(
!
this
.
_sendMessageToTheRightContent
(
aActor
"
DOMFullscreen
:
Entered
"
)
)
{
return
;
}
}
if
(
!
aBrowser
|
|
gBrowser
.
selectedBrowser
!
=
aBrowser
|
|
Services
.
focus
.
activeWindow
!
=
window
)
{
setTimeout
(
(
)
=
>
document
.
exitFullscreen
(
)
0
)
;
return
;
}
if
(
!
FullScreen
.
permissionsFullScreenAllowed
)
{
let
notifications
=
PopupNotifications
.
getNotification
(
this
.
_permissionNotificationIDs
)
.
filter
(
n
=
>
!
n
.
dismissed
)
;
PopupNotifications
.
remove
(
notifications
true
)
;
if
(
notifications
.
length
)
{
this
.
_logWarningPermissionPromptFS
(
"
promptCanceled
"
)
;
}
}
document
.
documentElement
.
setAttribute
(
"
inDOMFullscreen
"
true
)
;
if
(
gFindBarInitialized
)
{
gFindBar
.
close
(
true
)
;
}
gBrowser
.
tabContainer
.
addEventListener
(
"
TabSelect
"
this
.
exitDomFullScreen
)
;
if
(
gXPInstallObserver
.
removeAllNotifications
(
aBrowser
)
)
{
gXPInstallObserver
.
logWarningFullScreenInstallBlocked
(
)
;
}
PopupNotifications
.
panel
.
addEventListener
(
"
popupshowing
"
(
)
=
>
this
.
_handlePermPromptShow
(
)
true
)
;
}
cleanup
(
)
{
if
(
!
window
.
fullScreen
)
{
MousePosTracker
.
removeListener
(
this
)
;
document
.
removeEventListener
(
"
keypress
"
this
.
_keyToggleCallback
)
;
document
.
removeEventListener
(
"
popupshown
"
this
.
_setPopupOpen
)
;
document
.
removeEventListener
(
"
popuphidden
"
this
.
_setPopupOpen
)
;
gURLBar
.
controller
.
removeQueryListener
(
this
)
;
}
}
cleanupDomFullscreen
(
aActor
)
{
if
(
!
this
.
_sendMessageToTheRightContent
(
aActor
"
DOMFullscreen
:
CleanUp
"
)
)
{
return
;
}
PopupNotifications
.
panel
.
removeEventListener
(
"
popupshowing
"
(
)
=
>
this
.
_handlePermPromptShow
(
)
true
)
;
PointerlockFsWarning
.
close
(
)
;
gBrowser
.
tabContainer
.
removeEventListener
(
"
TabSelect
"
this
.
exitDomFullScreen
)
;
document
.
documentElement
.
removeAttribute
(
"
inDOMFullscreen
"
)
;
}
_sendMessageToTheRightContent
(
aActor
aMessage
)
{
if
(
aActor
.
hasBeenDestroyed
(
)
)
{
return
true
;
}
let
childBC
=
aActor
.
browsingContext
;
let
parentBC
=
childBC
.
parent
;
while
(
parentBC
)
{
let
childPid
=
childBC
.
currentWindowGlobal
.
osPid
;
let
parentPid
=
parentBC
.
currentWindowGlobal
.
osPid
;
if
(
childPid
=
=
parentPid
)
{
childBC
=
parentBC
;
parentBC
=
childBC
.
parent
;
}
else
{
break
;
}
}
if
(
parentBC
)
{
let
parentActor
=
parentBC
.
currentWindowGlobal
.
getActor
(
"
DOMFullscreen
"
)
;
parentActor
.
sendAsyncMessage
(
aMessage
{
remoteFrameBC
:
childBC
}
)
;
return
false
;
}
aActor
.
requestOrigin
.
sendAsyncMessage
(
aMessage
{
}
)
;
aActor
.
requestOrigin
=
null
;
return
true
;
}
_isRemoteBrowser
(
aBrowser
)
{
return
gMultiProcessBrowser
&
&
aBrowser
.
getAttribute
(
"
remote
"
)
=
=
"
true
"
;
}
getMouseTargetRect
(
)
{
return
this
.
_mouseTargetRect
;
}
_expandCallback
(
)
{
FullScreen
.
showNavToolbox
(
)
;
}
onMouseEnter
(
)
{
this
.
hideNavToolbox
(
)
;
}
_keyToggleCallback
(
aEvent
)
{
if
(
aEvent
.
keyCode
=
=
aEvent
.
DOM_VK_ESCAPE
)
{
FullScreen
.
hideNavToolbox
(
)
;
}
else
if
(
aEvent
.
keyCode
=
=
aEvent
.
DOM_VK_F6
)
{
FullScreen
.
showNavToolbox
(
)
;
}
}
_isPopupOpen
:
false
_isChromeCollapsed
:
false
_setPopupOpen
(
aEvent
)
{
let
target
=
aEvent
.
originalTarget
;
if
(
target
.
localName
=
=
"
tooltip
"
)
{
return
;
}
if
(
aEvent
.
type
=
=
"
popupshown
"
&
&
!
FullScreen
.
_isChromeCollapsed
&
&
target
.
getAttribute
(
"
nopreventnavboxhide
"
)
!
=
"
true
"
)
{
FullScreen
.
_isPopupOpen
=
true
;
}
else
if
(
aEvent
.
type
=
=
"
popuphidden
"
)
{
FullScreen
.
_isPopupOpen
=
false
;
FullScreen
.
hideNavToolbox
(
true
)
;
}
}
onViewOpen
(
)
{
if
(
!
this
.
_isChromeCollapsed
)
{
this
.
_isPopupOpen
=
true
;
}
}
onViewClose
(
)
{
this
.
_isPopupOpen
=
false
;
this
.
hideNavToolbox
(
true
)
;
}
get
navToolboxHidden
(
)
{
return
this
.
_isChromeCollapsed
;
}
getAutohide
(
aItem
)
{
aItem
.
setAttribute
(
"
checked
"
Services
.
prefs
.
getBoolPref
(
"
browser
.
fullscreen
.
autohide
"
)
)
;
}
setAutohide
(
)
{
Services
.
prefs
.
setBoolPref
(
"
browser
.
fullscreen
.
autohide
"
!
Services
.
prefs
.
getBoolPref
(
"
browser
.
fullscreen
.
autohide
"
)
)
;
FullScreen
.
hideNavToolbox
(
true
)
;
}
showNavToolbox
(
trackMouse
=
true
)
{
if
(
BrowserHandler
.
kiosk
)
{
return
;
}
this
.
_fullScrToggler
.
hidden
=
true
;
gNavToolbox
.
removeAttribute
(
"
fullscreenShouldAnimate
"
)
;
gNavToolbox
.
style
.
marginTop
=
"
"
;
if
(
!
this
.
_isChromeCollapsed
)
{
return
;
}
if
(
trackMouse
&
&
!
this
.
useLionFullScreen
)
{
let
rect
=
gBrowser
.
tabpanels
.
getBoundingClientRect
(
)
;
this
.
_mouseTargetRect
=
{
top
:
rect
.
top
+
50
bottom
:
rect
.
bottom
left
:
rect
.
left
right
:
rect
.
right
}
;
MousePosTracker
.
addListener
(
this
)
;
}
this
.
_isChromeCollapsed
=
false
;
Services
.
obs
.
notifyObservers
(
null
"
fullscreen
-
nav
-
toolbox
"
"
shown
"
)
;
}
hideNavToolbox
(
aAnimate
=
false
)
{
if
(
this
.
_isChromeCollapsed
)
{
return
;
}
if
(
!
Services
.
prefs
.
getBoolPref
(
"
browser
.
fullscreen
.
autohide
"
)
)
{
return
;
}
if
(
this
.
_isPopupOpen
)
{
return
;
}
if
(
this
.
useLionFullScreen
)
{
return
;
}
let
focused
=
document
.
commandDispatcher
.
focusedElement
;
if
(
focused
&
&
focused
.
ownerDocument
=
=
document
&
&
focused
.
localName
=
=
"
input
"
&
&
!
BrowserHandler
.
kiosk
)
{
let
retryHideNavToolbox
=
(
)
=
>
{
requestAnimationFrame
(
(
)
=
>
{
setTimeout
(
(
)
=
>
{
if
(
window
.
fullScreen
)
{
this
.
hideNavToolbox
(
aAnimate
)
;
}
}
0
)
;
}
)
;
window
.
removeEventListener
(
"
keydown
"
retryHideNavToolbox
)
;
window
.
removeEventListener
(
"
click
"
retryHideNavToolbox
)
;
}
;
window
.
addEventListener
(
"
keydown
"
retryHideNavToolbox
)
;
window
.
addEventListener
(
"
click
"
retryHideNavToolbox
)
;
return
;
}
this
.
_fullScrToggler
.
hidden
=
false
;
if
(
aAnimate
&
&
window
.
matchMedia
(
"
(
prefers
-
reduced
-
motion
:
no
-
preference
)
"
)
.
matches
&
&
!
BrowserHandler
.
kiosk
)
{
gNavToolbox
.
setAttribute
(
"
fullscreenShouldAnimate
"
true
)
;
let
listener
=
(
)
=
>
{
gNavToolbox
.
removeEventListener
(
"
transitionend
"
listener
true
)
;
if
(
this
.
_isChromeCollapsed
)
{
this
.
_fullScrToggler
.
hidden
=
false
;
}
}
;
gNavToolbox
.
addEventListener
(
"
transitionend
"
listener
true
)
;
this
.
_fullScrToggler
.
hidden
=
true
;
}
gNavToolbox
.
style
.
marginTop
=
-
gNavToolbox
.
getBoundingClientRect
(
)
.
height
+
"
px
"
;
this
.
_isChromeCollapsed
=
true
;
Services
.
obs
.
notifyObservers
(
null
"
fullscreen
-
nav
-
toolbox
"
"
hidden
"
)
;
MousePosTracker
.
removeListener
(
this
)
;
}
_updateToolbars
(
aEnterFS
)
{
for
(
let
el
of
document
.
querySelectorAll
(
"
toolbar
[
fullscreentoolbar
=
true
]
"
)
)
{
if
(
aEnterFS
)
{
el
.
setAttribute
(
"
saved
-
context
"
el
.
getAttribute
(
"
context
"
)
)
;
if
(
el
.
id
=
=
"
nav
-
bar
"
|
|
el
.
id
=
=
"
TabsToolbar
"
)
{
el
.
setAttribute
(
"
context
"
"
autohide
-
context
"
)
;
}
else
{
el
.
removeAttribute
(
"
context
"
)
;
}
el
.
setAttribute
(
"
inFullscreen
"
true
)
;
}
else
{
if
(
el
.
hasAttribute
(
"
saved
-
context
"
)
)
{
el
.
setAttribute
(
"
context
"
el
.
getAttribute
(
"
saved
-
context
"
)
)
;
el
.
removeAttribute
(
"
saved
-
context
"
)
;
}
el
.
removeAttribute
(
"
inFullscreen
"
)
;
}
}
ToolbarIconColor
.
inferFromText
(
"
fullscreen
"
aEnterFS
)
;
if
(
this
.
useLionFullScreen
)
{
return
;
}
var
fullscreenctls
=
document
.
getElementById
(
"
window
-
controls
"
)
;
var
navbar
=
document
.
getElementById
(
"
nav
-
bar
"
)
;
var
ctlsOnTabbar
=
window
.
toolbar
.
visible
;
if
(
fullscreenctls
.
parentNode
=
=
navbar
&
&
ctlsOnTabbar
)
{
fullscreenctls
.
removeAttribute
(
"
flex
"
)
;
document
.
getElementById
(
"
TabsToolbar
"
)
.
appendChild
(
fullscreenctls
)
;
}
else
if
(
fullscreenctls
.
parentNode
.
id
=
=
"
TabsToolbar
"
&
&
!
ctlsOnTabbar
)
{
fullscreenctls
.
setAttribute
(
"
flex
"
"
1
"
)
;
navbar
.
appendChild
(
fullscreenctls
)
;
}
fullscreenctls
.
hidden
=
!
aEnterFS
;
}
}
;
XPCOMUtils
.
defineLazyGetter
(
FullScreen
"
_permissionNotificationIDs
"
(
)
=
>
{
let
{
PermissionUI
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
/
modules
/
PermissionUI
.
jsm
"
{
}
)
;
return
(
Object
.
values
(
PermissionUI
)
.
filter
(
value
=
>
value
.
prototype
&
&
value
.
prototype
.
notificationID
)
.
map
(
value
=
>
value
.
prototype
.
notificationID
)
.
concat
(
[
"
webRTC
-
shareDevices
"
]
)
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
FullScreen
"
useLionFullScreen
"
(
)
=
>
{
return
(
AppConstants
.
isPlatformAndVersionAtLeast
(
"
macosx
"
11
)
&
&
document
.
documentElement
.
getAttribute
(
"
fullscreenbutton
"
)
=
=
"
true
"
)
;
}
)
;
