{
const
FAVICON_DEFAULTS
=
{
"
about
:
newtab
"
:
"
chrome
:
/
/
branding
/
content
/
icon32
.
png
"
"
about
:
home
"
:
"
chrome
:
/
/
branding
/
content
/
icon32
.
png
"
"
about
:
welcome
"
:
"
chrome
:
/
/
branding
/
content
/
icon32
.
png
"
"
about
:
privatebrowsing
"
:
"
chrome
:
/
/
browser
/
skin
/
privatebrowsing
/
favicon
.
svg
"
}
;
window
.
_gBrowser
=
{
init
(
)
{
ChromeUtils
.
defineModuleGetter
(
this
"
AsyncTabSwitcher
"
"
resource
:
/
/
/
modules
/
AsyncTabSwitcher
.
jsm
"
)
;
ChromeUtils
.
defineESModuleGetters
(
this
{
UrlbarProviderOpenTabs
:
"
resource
:
/
/
/
modules
/
UrlbarProviderOpenTabs
.
sys
.
mjs
"
}
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
E10SUtils
:
"
resource
:
/
/
gre
/
modules
/
E10SUtils
.
jsm
"
PictureInPicture
:
"
resource
:
/
/
gre
/
modules
/
PictureInPicture
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyServiceGetters
(
this
{
MacSharingService
:
[
"
mozilla
.
org
/
widget
/
macsharingservice
;
1
"
"
nsIMacSharingService
"
]
}
)
;
if
(
AppConstants
.
MOZ_CRASHREPORTER
)
{
ChromeUtils
.
defineModuleGetter
(
this
"
TabCrashHandler
"
"
resource
:
/
/
/
modules
/
ContentCrashHandlers
.
jsm
"
)
;
}
Services
.
obs
.
addObserver
(
this
"
contextual
-
identity
-
updated
"
)
;
Services
.
els
.
addSystemEventListener
(
document
"
keydown
"
this
false
)
;
Services
.
els
.
addSystemEventListener
(
document
"
keypress
"
this
false
)
;
document
.
addEventListener
(
"
visibilitychange
"
this
)
;
window
.
addEventListener
(
"
framefocusrequested
"
this
)
;
this
.
tabContainer
.
init
(
)
;
this
.
_setupInitialBrowserAndTab
(
)
;
if
(
Services
.
prefs
.
getIntPref
(
"
browser
.
display
.
document_color_use
"
)
=
=
2
)
{
this
.
tabpanels
.
style
.
backgroundColor
=
Services
.
prefs
.
getBoolPref
(
"
browser
.
display
.
use_system_colors
"
)
?
"
canvas
"
:
Services
.
prefs
.
getCharPref
(
"
browser
.
display
.
background_color
"
)
;
}
this
.
_setFindbarData
(
)
;
document
.
querySelector
(
"
title
"
)
.
removeAttribute
(
"
data
-
l10n
-
id
"
)
;
this
.
_setupEventListeners
(
)
;
this
.
_initialized
=
true
;
}
ownerGlobal
:
window
ownerDocument
:
document
closingTabsEnum
:
{
ALL
:
0
OTHER
:
1
TO_START
:
2
TO_END
:
3
MULTI_SELECTED
:
4
}
_visibleTabs
:
null
_tabs
:
null
_lastRelatedTabMap
:
new
WeakMap
(
)
mProgressListeners
:
[
]
mTabsProgressListeners
:
[
]
_tabListeners
:
new
Map
(
)
_tabFilters
:
new
Map
(
)
_isBusy
:
false
arrowKeysShouldWrap
:
AppConstants
=
=
"
macosx
"
_dateTimePicker
:
null
_previewMode
:
false
_lastFindValue
:
"
"
_contentWaitingCount
:
0
_tabLayerCache
:
[
]
tabAnimationsInProgress
:
0
_tabForBrowser
:
new
WeakMap
(
)
_browserBindingProperties
:
[
"
canGoBack
"
"
canGoForward
"
"
goBack
"
"
goForward
"
"
permitUnload
"
"
reload
"
"
reloadWithFlags
"
"
stop
"
"
loadURI
"
"
gotoIndex
"
"
currentURI
"
"
documentURI
"
"
remoteType
"
"
preferences
"
"
imageDocument
"
"
isRemoteBrowser
"
"
messageManager
"
"
getTabBrowser
"
"
finder
"
"
fastFind
"
"
sessionHistory
"
"
contentTitle
"
"
characterSet
"
"
fullZoom
"
"
textZoom
"
"
tabHasCustomZoom
"
"
webProgress
"
"
addProgressListener
"
"
removeProgressListener
"
"
audioPlaybackStarted
"
"
audioPlaybackStopped
"
"
resumeMedia
"
"
mute
"
"
unmute
"
"
blockedPopups
"
"
lastURI
"
"
purgeSessionHistory
"
"
stopScroll
"
"
startScroll
"
"
userTypedValue
"
"
userTypedClear
"
"
didStartLoadSinceLastUserTyping
"
"
audioMuted
"
]
_removingTabs
:
[
]
_multiSelectedTabsSet
:
new
WeakSet
(
)
_lastMultiSelectedTabRef
:
null
_clearMultiSelectionLocked
:
false
_clearMultiSelectionLockedOnce
:
false
_multiSelectChangeStarted
:
false
_multiSelectChangeAdditions
:
new
Set
(
)
_multiSelectChangeRemovals
:
new
Set
(
)
_multiSelectChangeSelected
:
false
_windowIsClosing
:
false
preloadedBrowser
:
null
browsers
:
new
Proxy
(
[
]
{
has
:
(
target
name
)
=
>
{
if
(
typeof
name
=
=
"
string
"
&
&
Number
.
isInteger
(
parseInt
(
name
)
)
)
{
return
name
in
gBrowser
.
tabs
;
}
return
false
;
}
get
:
(
target
name
)
=
>
{
if
(
name
=
=
"
length
"
)
{
return
gBrowser
.
tabs
.
length
;
}
if
(
typeof
name
=
=
"
string
"
&
&
Number
.
isInteger
(
parseInt
(
name
)
)
)
{
if
(
!
(
name
in
gBrowser
.
tabs
)
)
{
return
undefined
;
}
return
gBrowser
.
tabs
[
name
]
.
linkedBrowser
;
}
return
target
[
name
]
;
}
}
)
_printPreviewBrowsers
:
new
Set
(
)
_switcher
:
null
_soundPlayingAttrRemovalTimer
:
0
_hoverTabTimer
:
null
get
tabContainer
(
)
{
delete
this
.
tabContainer
;
return
(
this
.
tabContainer
=
document
.
getElementById
(
"
tabbrowser
-
tabs
"
)
)
;
}
get
tabs
(
)
{
if
(
!
this
.
_tabs
)
{
this
.
_tabs
=
this
.
tabContainer
.
allTabs
;
}
return
this
.
_tabs
;
}
get
tabbox
(
)
{
delete
this
.
tabbox
;
return
(
this
.
tabbox
=
document
.
getElementById
(
"
tabbrowser
-
tabbox
"
)
)
;
}
get
tabpanels
(
)
{
delete
this
.
tabpanels
;
return
(
this
.
tabpanels
=
document
.
getElementById
(
"
tabbrowser
-
tabpanels
"
)
)
;
}
addEventListener
(
.
.
.
args
)
{
this
.
tabpanels
.
addEventListener
(
.
.
.
args
)
;
}
removeEventListener
(
.
.
.
args
)
{
this
.
tabpanels
.
removeEventListener
(
.
.
.
args
)
;
}
dispatchEvent
(
.
.
.
args
)
{
return
this
.
tabpanels
.
dispatchEvent
(
.
.
.
args
)
;
}
get
visibleTabs
(
)
{
if
(
!
this
.
_visibleTabs
)
{
this
.
_visibleTabs
=
Array
.
prototype
.
filter
.
call
(
this
.
tabs
tab
=
>
!
tab
.
hidden
&
&
!
tab
.
closing
)
;
}
return
this
.
_visibleTabs
;
}
get
_numPinnedTabs
(
)
{
for
(
var
i
=
0
;
i
<
this
.
tabs
.
length
;
i
+
+
)
{
if
(
!
this
.
tabs
[
i
]
.
pinned
)
{
break
;
}
}
return
i
;
}
set
selectedTab
(
val
)
{
if
(
gSharedTabWarning
.
willShowSharedTabWarning
(
val
)
|
|
document
.
documentElement
.
hasAttribute
(
"
window
-
modal
-
open
"
)
|
|
(
gNavToolbox
.
collapsed
&
&
!
this
.
_allowTabChange
)
)
{
return
;
}
this
.
tabbox
.
selectedTab
=
val
;
}
get
selectedTab
(
)
{
return
this
.
_selectedTab
;
}
get
selectedBrowser
(
)
{
return
this
.
_selectedBrowser
;
}
_setupInitialBrowserAndTab
(
)
{
let
userContextId
=
window
.
arguments
&
&
window
.
arguments
[
5
]
;
let
openWindowInfo
=
window
.
docShell
.
treeOwner
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIAppWindow
)
.
initialOpenWindowInfo
;
if
(
!
openWindowInfo
&
&
window
.
arguments
&
&
window
.
arguments
[
11
]
)
{
openWindowInfo
=
window
.
arguments
[
11
]
;
}
let
tabArgument
=
gBrowserInit
.
getTabToAdopt
(
)
;
let
remoteType
;
let
initialBrowsingContextGroupId
;
if
(
tabArgument
&
&
tabArgument
.
hasAttribute
(
"
usercontextid
"
)
)
{
userContextId
=
parseInt
(
tabArgument
.
getAttribute
(
"
usercontextid
"
)
10
)
;
}
if
(
tabArgument
&
&
tabArgument
.
linkedBrowser
)
{
remoteType
=
tabArgument
.
linkedBrowser
.
remoteType
;
initialBrowsingContextGroupId
=
tabArgument
.
linkedBrowser
.
browsingContext
?
.
group
.
id
;
}
else
if
(
openWindowInfo
)
{
userContextId
=
openWindowInfo
.
originAttributes
.
userContextId
;
if
(
openWindowInfo
.
isRemote
)
{
remoteType
=
E10SUtils
.
DEFAULT_REMOTE_TYPE
;
}
else
{
remoteType
=
E10SUtils
.
NOT_REMOTE
;
}
}
else
{
let
uriToLoad
=
gBrowserInit
.
uriToLoadPromise
;
if
(
uriToLoad
&
&
Array
.
isArray
(
uriToLoad
)
)
{
uriToLoad
=
uriToLoad
[
0
]
;
}
if
(
uriToLoad
&
&
typeof
uriToLoad
=
=
"
string
"
)
{
let
oa
=
E10SUtils
.
predictOriginAttributes
(
{
window
userContextId
}
)
;
remoteType
=
E10SUtils
.
getRemoteTypeForURI
(
uriToLoad
gMultiProcessBrowser
gFissionBrowser
E10SUtils
.
DEFAULT_REMOTE_TYPE
null
oa
)
;
}
else
{
remoteType
=
E10SUtils
.
PRIVILEGEDABOUT_REMOTE_TYPE
;
}
}
let
createOptions
=
{
uriIsAboutBlank
:
false
userContextId
initialBrowsingContextGroupId
remoteType
openWindowInfo
}
;
let
browser
=
this
.
createBrowser
(
createOptions
)
;
browser
.
setAttribute
(
"
primary
"
"
true
"
)
;
if
(
gBrowserAllowScriptsToCloseInitialTabs
)
{
browser
.
setAttribute
(
"
allowscriptstoclose
"
"
true
"
)
;
}
browser
.
droppedLinkHandler
=
handleDroppedLink
;
browser
.
loadURI
=
_loadURI
.
bind
(
null
browser
)
;
let
uniqueId
=
this
.
_generateUniquePanelID
(
)
;
let
panel
=
this
.
getPanel
(
browser
)
;
panel
.
id
=
uniqueId
;
this
.
tabpanels
.
appendChild
(
panel
)
;
let
tab
=
this
.
tabs
[
0
]
;
tab
.
linkedPanel
=
uniqueId
;
this
.
_selectedTab
=
tab
;
this
.
_selectedBrowser
=
browser
;
tab
.
permanentKey
=
browser
.
permanentKey
;
tab
.
_tPos
=
0
;
tab
.
_fullyOpen
=
true
;
tab
.
linkedBrowser
=
browser
;
if
(
userContextId
)
{
tab
.
setAttribute
(
"
usercontextid
"
userContextId
)
;
ContextualIdentityService
.
setTabStyle
(
tab
)
;
}
this
.
_tabForBrowser
.
set
(
browser
tab
)
;
this
.
_appendStatusPanel
(
)
;
browser
.
docShellIsActive
=
this
.
shouldActivateDocShell
(
browser
)
;
let
tabListener
=
new
TabProgressListener
(
tab
browser
true
false
)
;
let
filter
=
Cc
[
"
mozilla
.
org
/
appshell
/
component
/
browser
-
status
-
filter
;
1
"
]
.
createInstance
(
Ci
.
nsIWebProgress
)
;
filter
.
addProgressListener
(
tabListener
Ci
.
nsIWebProgress
.
NOTIFY_ALL
)
;
this
.
_tabListeners
.
set
(
tab
tabListener
)
;
this
.
_tabFilters
.
set
(
tab
filter
)
;
browser
.
webProgress
.
addProgressListener
(
filter
Ci
.
nsIWebProgress
.
NOTIFY_ALL
)
;
}
get
canGoBack
(
)
{
return
this
.
selectedBrowser
.
canGoBack
;
}
get
canGoForward
(
)
{
return
this
.
selectedBrowser
.
canGoForward
;
}
goBack
(
requireUserInteraction
)
{
return
this
.
selectedBrowser
.
goBack
(
requireUserInteraction
)
;
}
goForward
(
requireUserInteraction
)
{
return
this
.
selectedBrowser
.
goForward
(
requireUserInteraction
)
;
}
reload
(
)
{
return
this
.
selectedBrowser
.
reload
(
)
;
}
reloadWithFlags
(
aFlags
)
{
return
this
.
selectedBrowser
.
reloadWithFlags
(
aFlags
)
;
}
stop
(
)
{
return
this
.
selectedBrowser
.
stop
(
)
;
}
loadURI
(
aURI
aParams
)
{
return
this
.
selectedBrowser
.
loadURI
(
aURI
aParams
)
;
}
gotoIndex
(
aIndex
)
{
return
this
.
selectedBrowser
.
gotoIndex
(
aIndex
)
;
}
get
currentURI
(
)
{
return
this
.
selectedBrowser
.
currentURI
;
}
get
finder
(
)
{
return
this
.
selectedBrowser
.
finder
;
}
get
docShell
(
)
{
return
this
.
selectedBrowser
.
docShell
;
}
get
webNavigation
(
)
{
return
this
.
selectedBrowser
.
webNavigation
;
}
get
webProgress
(
)
{
return
this
.
selectedBrowser
.
webProgress
;
}
get
contentWindow
(
)
{
return
this
.
selectedBrowser
.
contentWindow
;
}
get
sessionHistory
(
)
{
return
this
.
selectedBrowser
.
sessionHistory
;
}
get
markupDocumentViewer
(
)
{
return
this
.
selectedBrowser
.
markupDocumentViewer
;
}
get
contentDocument
(
)
{
return
this
.
selectedBrowser
.
contentDocument
;
}
get
contentTitle
(
)
{
return
this
.
selectedBrowser
.
contentTitle
;
}
get
contentPrincipal
(
)
{
return
this
.
selectedBrowser
.
contentPrincipal
;
}
get
securityUI
(
)
{
return
this
.
selectedBrowser
.
securityUI
;
}
set
fullZoom
(
val
)
{
this
.
selectedBrowser
.
fullZoom
=
val
;
}
get
fullZoom
(
)
{
return
this
.
selectedBrowser
.
fullZoom
;
}
set
textZoom
(
val
)
{
this
.
selectedBrowser
.
textZoom
=
val
;
}
get
textZoom
(
)
{
return
this
.
selectedBrowser
.
textZoom
;
}
get
isSyntheticDocument
(
)
{
return
this
.
selectedBrowser
.
isSyntheticDocument
;
}
set
userTypedValue
(
val
)
{
this
.
selectedBrowser
.
userTypedValue
=
val
;
}
get
userTypedValue
(
)
{
return
this
.
selectedBrowser
.
userTypedValue
;
}
_invalidateCachedTabs
(
)
{
this
.
_tabs
=
null
;
this
.
_visibleTabs
=
null
;
}
_setFindbarData
(
)
{
let
{
sharedData
}
=
Services
.
ppmm
;
if
(
!
sharedData
.
has
(
"
Findbar
:
Shortcut
"
)
)
{
let
keyEl
=
document
.
getElementById
(
"
key_find
"
)
;
let
mods
=
keyEl
.
getAttribute
(
"
modifiers
"
)
.
replace
(
/
accel
/
i
AppConstants
.
platform
=
=
"
macosx
"
?
"
meta
"
:
"
control
"
)
;
sharedData
.
set
(
"
Findbar
:
Shortcut
"
{
key
:
keyEl
.
getAttribute
(
"
key
"
)
shiftKey
:
mods
.
includes
(
"
shift
"
)
ctrlKey
:
mods
.
includes
(
"
control
"
)
altKey
:
mods
.
includes
(
"
alt
"
)
metaKey
:
mods
.
includes
(
"
meta
"
)
}
)
;
}
}
isFindBarInitialized
(
aTab
)
{
return
(
aTab
|
|
this
.
selectedTab
)
.
_findBar
!
=
undefined
;
}
getCachedFindBar
(
aTab
=
this
.
selectedTab
)
{
return
aTab
.
_findBar
;
}
async
getFindBar
(
aTab
=
this
.
selectedTab
)
{
let
findBar
=
this
.
getCachedFindBar
(
aTab
)
;
if
(
findBar
)
{
return
findBar
;
}
if
(
!
aTab
.
_pendingFindBar
)
{
aTab
.
_pendingFindBar
=
this
.
_createFindBar
(
aTab
)
;
}
return
aTab
.
_pendingFindBar
;
}
async
_createFindBar
(
aTab
)
{
let
findBar
=
document
.
createXULElement
(
"
findbar
"
)
;
let
browser
=
this
.
getBrowserForTab
(
aTab
)
;
let
insertAfterElement
=
browser
.
parentNode
;
if
(
insertAfterElement
.
nextElementSibling
=
=
StatusPanel
.
panel
)
{
insertAfterElement
=
StatusPanel
.
panel
;
}
insertAfterElement
.
insertAdjacentElement
(
"
afterend
"
findBar
)
;
await
new
Promise
(
r
=
>
requestAnimationFrame
(
r
)
)
;
delete
aTab
.
_pendingFindBar
;
if
(
window
.
closed
|
|
aTab
.
closing
)
{
return
null
;
}
findBar
.
browser
=
browser
;
findBar
.
_findField
.
value
=
this
.
_lastFindValue
;
aTab
.
_findBar
=
findBar
;
let
event
=
document
.
createEvent
(
"
Events
"
)
;
event
.
initEvent
(
"
TabFindInitialized
"
true
false
)
;
aTab
.
dispatchEvent
(
event
)
;
return
findBar
;
}
_appendStatusPanel
(
)
{
this
.
selectedBrowser
.
parentNode
.
insertAdjacentElement
(
"
afterend
"
StatusPanel
.
panel
)
;
}
_updateTabBarForPinnedTabs
(
)
{
this
.
tabContainer
.
_unlockTabSizing
(
)
;
this
.
tabContainer
.
_positionPinnedTabs
(
)
;
this
.
tabContainer
.
_setPositionalAttributes
(
)
;
this
.
tabContainer
.
_updateCloseButtons
(
)
;
}
_notifyPinnedStatus
(
aTab
)
{
aTab
.
linkedBrowser
.
sendMessageToActor
(
"
Browser
:
AppTab
"
{
isAppTab
:
aTab
.
pinned
}
"
BrowserTab
"
)
;
let
event
=
document
.
createEvent
(
"
Events
"
)
;
event
.
initEvent
(
aTab
.
pinned
?
"
TabPinned
"
:
"
TabUnpinned
"
true
false
)
;
aTab
.
dispatchEvent
(
event
)
;
}
pinTab
(
aTab
)
{
if
(
aTab
.
pinned
)
{
return
;
}
if
(
aTab
.
hidden
)
{
this
.
showTab
(
aTab
)
;
}
this
.
moveTabTo
(
aTab
this
.
_numPinnedTabs
)
;
aTab
.
setAttribute
(
"
pinned
"
"
true
"
)
;
this
.
_updateTabBarForPinnedTabs
(
)
;
this
.
_notifyPinnedStatus
(
aTab
)
;
}
unpinTab
(
aTab
)
{
if
(
!
aTab
.
pinned
)
{
return
;
}
this
.
moveTabTo
(
aTab
this
.
_numPinnedTabs
-
1
)
;
aTab
.
removeAttribute
(
"
pinned
"
)
;
aTab
.
style
.
marginInlineStart
=
"
"
;
aTab
.
_pinnedUnscrollable
=
false
;
this
.
_updateTabBarForPinnedTabs
(
)
;
this
.
_notifyPinnedStatus
(
aTab
)
;
}
previewTab
(
aTab
aCallback
)
{
let
currentTab
=
this
.
selectedTab
;
try
{
this
.
_previewMode
=
true
;
this
.
selectedTab
=
aTab
;
aCallback
(
)
;
}
finally
{
this
.
selectedTab
=
currentTab
;
this
.
_previewMode
=
false
;
}
}
_getAndMaybeCreateDateTimePickerPanel
(
)
{
if
(
!
this
.
_dateTimePicker
)
{
let
wrapper
=
document
.
getElementById
(
"
dateTimePickerTemplate
"
)
;
wrapper
.
replaceWith
(
wrapper
.
content
)
;
this
.
_dateTimePicker
=
document
.
getElementById
(
"
DateTimePickerPanel
"
)
;
}
return
this
.
_dateTimePicker
;
}
syncThrobberAnimations
(
aTab
)
{
aTab
.
ownerGlobal
.
promiseDocumentFlushed
(
(
)
=
>
{
if
(
!
aTab
.
container
)
{
return
;
}
const
animations
=
Array
.
from
(
aTab
.
container
.
getElementsByTagName
(
"
tab
"
)
)
.
map
(
tab
=
>
{
const
throbber
=
tab
.
throbber
;
return
throbber
?
throbber
.
getAnimations
(
{
subtree
:
true
}
)
:
[
]
;
}
)
.
reduce
(
(
a
b
)
=
>
a
.
concat
(
b
)
)
.
filter
(
anim
=
>
CSSAnimation
.
isInstance
(
anim
)
&
&
(
anim
.
animationName
=
=
=
"
tab
-
throbber
-
animation
"
|
|
anim
.
animationName
=
=
=
"
tab
-
throbber
-
animation
-
rtl
"
)
&
&
anim
.
playState
=
=
=
"
running
"
)
;
const
firstStartTime
=
Math
.
min
(
.
.
.
animations
.
map
(
anim
=
>
anim
.
startTime
=
=
=
null
?
Infinity
:
anim
.
startTime
)
)
;
if
(
firstStartTime
=
=
=
Infinity
)
{
return
;
}
requestAnimationFrame
(
(
)
=
>
{
for
(
let
animation
of
animations
)
{
if
(
animation
.
currentTime
!
=
=
null
)
{
animation
.
startTime
=
firstStartTime
;
}
}
}
)
;
}
)
;
}
getBrowserAtIndex
(
aIndex
)
{
return
this
.
browsers
[
aIndex
]
;
}
getBrowserForOuterWindowID
(
aID
)
{
for
(
let
b
of
this
.
browsers
)
{
if
(
b
.
outerWindowID
=
=
aID
)
{
return
b
;
}
}
return
null
;
}
getTabForBrowser
(
aBrowser
)
{
return
this
.
_tabForBrowser
.
get
(
aBrowser
)
;
}
getPanel
(
aBrowser
)
{
return
this
.
getBrowserContainer
(
aBrowser
)
.
parentNode
;
}
getBrowserContainer
(
aBrowser
)
{
return
(
aBrowser
|
|
this
.
selectedBrowser
)
.
parentNode
.
parentNode
;
}
getTabNotificationDeck
(
)
{
if
(
!
this
.
_tabNotificationDeck
)
{
let
template
=
document
.
getElementById
(
"
tab
-
notification
-
deck
-
template
"
)
;
template
.
replaceWith
(
template
.
content
)
;
this
.
_tabNotificationDeck
=
document
.
getElementById
(
"
tab
-
notification
-
deck
"
)
;
}
return
this
.
_tabNotificationDeck
;
}
_nextNotificationBoxId
:
0
getNotificationBox
(
aBrowser
)
{
let
browser
=
aBrowser
|
|
this
.
selectedBrowser
;
if
(
!
browser
.
_notificationBox
)
{
browser
.
_notificationBox
=
new
MozElements
.
NotificationBox
(
element
=
>
{
element
.
setAttribute
(
"
notificationside
"
"
top
"
)
;
element
.
setAttribute
(
"
name
"
tab
-
notification
-
box
-
{
this
.
_nextNotificationBoxId
+
+
}
)
;
this
.
getTabNotificationDeck
(
)
.
append
(
element
)
;
if
(
browser
=
=
this
.
selectedBrowser
)
{
this
.
_updateVisibleNotificationBox
(
browser
)
;
}
}
)
;
}
return
browser
.
_notificationBox
;
}
readNotificationBox
(
aBrowser
)
{
let
browser
=
aBrowser
|
|
this
.
selectedBrowser
;
return
browser
.
_notificationBox
|
|
null
;
}
_updateVisibleNotificationBox
(
aBrowser
)
{
if
(
!
this
.
_tabNotificationDeck
)
{
return
;
}
let
notificationBox
=
this
.
readNotificationBox
(
aBrowser
)
;
this
.
getTabNotificationDeck
(
)
.
selectedViewName
=
notificationBox
?
notificationBox
.
stack
.
getAttribute
(
"
name
"
)
:
"
"
;
}
getTabModalPromptBox
(
aBrowser
)
{
let
browser
=
aBrowser
|
|
this
.
selectedBrowser
;
if
(
!
browser
.
tabModalPromptBox
)
{
browser
.
tabModalPromptBox
=
new
TabModalPromptBox
(
browser
)
;
}
return
browser
.
tabModalPromptBox
;
}
getTabDialogBox
(
aBrowser
)
{
if
(
!
aBrowser
)
{
throw
new
Error
(
"
aBrowser
is
required
"
)
;
}
if
(
!
aBrowser
.
tabDialogBox
)
{
aBrowser
.
tabDialogBox
=
new
TabDialogBox
(
aBrowser
)
;
}
return
aBrowser
.
tabDialogBox
;
}
getTabFromAudioEvent
(
aEvent
)
{
if
(
!
aEvent
.
isTrusted
)
{
return
null
;
}
var
browser
=
aEvent
.
originalTarget
;
var
tab
=
this
.
getTabForBrowser
(
browser
)
;
return
tab
;
}
_callProgressListeners
(
aBrowser
aMethod
aArguments
aCallGlobalListeners
=
true
aCallTabsListeners
=
true
)
{
var
rv
=
true
;
function
callListeners
(
listeners
args
)
{
for
(
let
p
of
listeners
)
{
if
(
aMethod
in
p
)
{
try
{
if
(
!
p
[
aMethod
]
.
apply
(
p
args
)
)
{
rv
=
false
;
}
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
}
}
aBrowser
=
aBrowser
|
|
this
.
selectedBrowser
;
if
(
aCallGlobalListeners
&
&
aBrowser
=
=
this
.
selectedBrowser
)
{
callListeners
(
this
.
mProgressListeners
aArguments
)
;
}
if
(
aCallTabsListeners
)
{
aArguments
.
unshift
(
aBrowser
)
;
callListeners
(
this
.
mTabsProgressListeners
aArguments
)
;
}
return
rv
;
}
setDefaultIcon
(
aTab
aURI
)
{
if
(
aURI
&
&
aURI
.
spec
in
FAVICON_DEFAULTS
)
{
this
.
setIcon
(
aTab
FAVICON_DEFAULTS
[
aURI
.
spec
]
)
;
}
}
setIcon
(
aTab
aIconURL
=
"
"
aOriginalURL
=
aIconURL
aLoadingPrincipal
=
null
)
{
let
makeString
=
url
=
>
(
url
instanceof
Ci
.
nsIURI
?
url
.
spec
:
url
)
;
aIconURL
=
makeString
(
aIconURL
)
;
aOriginalURL
=
makeString
(
aOriginalURL
)
;
let
LOCAL_PROTOCOLS
=
[
"
chrome
:
"
"
about
:
"
"
resource
:
"
"
data
:
"
]
;
if
(
aIconURL
&
&
!
aLoadingPrincipal
&
&
!
LOCAL_PROTOCOLS
.
some
(
protocol
=
>
aIconURL
.
startsWith
(
protocol
)
)
)
{
console
.
error
(
Attempt
to
set
a
remote
URL
{
aIconURL
}
as
a
tab
icon
without
a
loading
principal
.
)
;
return
;
}
let
browser
=
this
.
getBrowserForTab
(
aTab
)
;
browser
.
mIconURL
=
aIconURL
;
if
(
aIconURL
!
=
aTab
.
getAttribute
(
"
image
"
)
)
{
if
(
aIconURL
)
{
if
(
aLoadingPrincipal
)
{
aTab
.
setAttribute
(
"
iconloadingprincipal
"
aLoadingPrincipal
)
;
}
else
{
aTab
.
removeAttribute
(
"
iconloadingprincipal
"
)
;
}
aTab
.
setAttribute
(
"
image
"
aIconURL
)
;
}
else
{
aTab
.
removeAttribute
(
"
image
"
)
;
aTab
.
removeAttribute
(
"
iconloadingprincipal
"
)
;
}
this
.
_tabAttrModified
(
aTab
[
"
image
"
]
)
;
}
this
.
_callProgressListeners
(
browser
"
onLinkIconAvailable
"
[
aIconURL
aOriginalURL
]
)
;
}
getIcon
(
aTab
)
{
let
browser
=
aTab
?
this
.
getBrowserForTab
(
aTab
)
:
this
.
selectedBrowser
;
return
browser
.
mIconURL
;
}
setPageInfo
(
aURL
aDescription
aPreviewImage
)
{
if
(
aURL
)
{
let
pageInfo
=
{
url
:
aURL
description
:
aDescription
previewImageURL
:
aPreviewImage
}
;
PlacesUtils
.
history
.
update
(
pageInfo
)
.
catch
(
Cu
.
reportError
)
;
}
}
getWindowTitleForBrowser
(
aBrowser
)
{
let
docElement
=
document
.
documentElement
;
let
title
=
"
"
;
try
{
if
(
docElement
.
getAttribute
(
"
chromehidden
"
)
.
includes
(
"
location
"
)
)
{
const
uri
=
Services
.
io
.
createExposableURI
(
aBrowser
.
currentURI
)
;
let
prefix
=
uri
.
prePath
;
if
(
uri
.
scheme
=
=
"
about
"
)
{
prefix
=
uri
.
spec
;
}
else
if
(
uri
.
scheme
=
=
"
moz
-
extension
"
)
{
const
ext
=
WebExtensionPolicy
.
getByHostname
(
uri
.
host
)
;
if
(
ext
&
&
ext
.
name
)
{
let
extensionLabel
=
document
.
getElementById
(
"
urlbar
-
label
-
extension
"
)
;
prefix
=
{
extensionLabel
.
value
}
(
{
ext
.
name
}
)
;
}
}
title
=
prefix
+
"
-
"
;
}
}
catch
(
e
)
{
}
if
(
docElement
.
hasAttribute
(
"
titlepreface
"
)
)
{
title
+
=
docElement
.
getAttribute
(
"
titlepreface
"
)
;
}
let
tab
=
this
.
getTabForBrowser
(
aBrowser
)
;
if
(
tab
.
_labelIsContentTitle
)
{
title
+
=
tab
.
getAttribute
(
"
label
"
)
.
replace
(
/
\
0
/
g
"
"
)
;
}
let
dataSuffix
=
docElement
.
getAttribute
(
"
privatebrowsingmode
"
)
=
=
"
temporary
"
?
"
Private
"
:
"
Default
"
;
if
(
title
)
{
return
docElement
.
dataset
[
"
contentTitle
"
+
dataSuffix
]
.
replace
(
"
CONTENTTITLE
"
(
)
=
>
title
)
;
}
return
docElement
.
dataset
[
"
title
"
+
dataSuffix
]
;
}
updateTitlebar
(
)
{
document
.
title
=
this
.
getWindowTitleForBrowser
(
this
.
selectedBrowser
)
;
}
updateCurrentBrowser
(
aForceUpdate
)
{
let
newBrowser
=
this
.
getBrowserAtIndex
(
this
.
tabContainer
.
selectedIndex
)
;
if
(
this
.
selectedBrowser
=
=
newBrowser
&
&
!
aForceUpdate
)
{
return
;
}
let
newTab
=
this
.
getTabForBrowser
(
newBrowser
)
;
if
(
!
aForceUpdate
)
{
TelemetryStopwatch
.
start
(
"
FX_TAB_SWITCH_UPDATE_MS
"
)
;
if
(
gMultiProcessBrowser
)
{
this
.
_getSwitcher
(
)
.
requestTab
(
newTab
)
;
}
document
.
commandDispatcher
.
lock
(
)
;
}
let
oldTab
=
this
.
selectedTab
;
if
(
!
this
.
_previewMode
&
&
!
oldTab
.
selected
)
{
oldTab
.
owner
=
null
;
}
let
lastRelatedTab
=
this
.
_lastRelatedTabMap
.
get
(
oldTab
)
;
if
(
lastRelatedTab
)
{
if
(
!
lastRelatedTab
.
selected
)
{
lastRelatedTab
.
owner
=
null
;
}
}
this
.
_lastRelatedTabMap
=
new
WeakMap
(
)
;
let
oldBrowser
=
this
.
selectedBrowser
;
if
(
!
gMultiProcessBrowser
)
{
oldBrowser
.
removeAttribute
(
"
primary
"
)
;
oldBrowser
.
docShellIsActive
=
false
;
newBrowser
.
setAttribute
(
"
primary
"
"
true
"
)
;
newBrowser
.
docShellIsActive
=
!
document
.
hidden
;
}
this
.
_selectedBrowser
=
newBrowser
;
this
.
_selectedTab
=
newTab
;
if
(
newTab
!
=
FirefoxViewHandler
.
tab
)
{
this
.
showTab
(
newTab
)
;
}
this
.
_appendStatusPanel
(
)
;
this
.
_updateVisibleNotificationBox
(
newBrowser
)
;
let
oldBrowserPopupsBlocked
=
oldBrowser
.
popupBlocker
.
getBlockedPopupCount
(
)
;
let
newBrowserPopupsBlocked
=
newBrowser
.
popupBlocker
.
getBlockedPopupCount
(
)
;
if
(
oldBrowserPopupsBlocked
!
=
newBrowserPopupsBlocked
)
{
newBrowser
.
popupBlocker
.
updateBlockedPopupsUI
(
)
;
}
let
webProgress
=
newBrowser
.
webProgress
;
this
.
_callProgressListeners
(
null
"
onLocationChange
"
[
webProgress
null
newBrowser
.
currentURI
0
true
]
true
false
)
;
let
securityUI
=
newBrowser
.
securityUI
;
if
(
securityUI
)
{
this
.
_callProgressListeners
(
null
"
onSecurityChange
"
[
webProgress
null
securityUI
.
state
]
true
false
)
;
this
.
_callProgressListeners
(
null
"
onContentBlockingEvent
"
[
webProgress
null
newBrowser
.
getContentBlockingEvents
(
)
true
]
true
false
)
;
}
let
listener
=
this
.
_tabListeners
.
get
(
newTab
)
;
if
(
listener
&
&
listener
.
mStateFlags
)
{
this
.
_callProgressListeners
(
null
"
onUpdateCurrentBrowser
"
[
listener
.
mStateFlags
listener
.
mStatus
listener
.
mMessage
listener
.
mTotalProgress
]
true
false
)
;
}
if
(
!
this
.
_previewMode
)
{
newTab
.
recordTimeFromUnloadToReload
(
)
;
newTab
.
updateLastAccessed
(
)
;
oldTab
.
updateLastAccessed
(
)
;
let
oldFindBar
=
oldTab
.
_findBar
;
if
(
oldFindBar
&
&
oldFindBar
.
findMode
=
=
oldFindBar
.
FIND_NORMAL
&
&
!
oldFindBar
.
hidden
)
{
this
.
_lastFindValue
=
oldFindBar
.
_findField
.
value
;
}
this
.
updateTitlebar
(
)
;
newTab
.
removeAttribute
(
"
titlechanged
"
)
;
newTab
.
attention
=
false
;
newTab
.
finishUnselectedTabHoverTimer
(
)
;
newBrowser
.
unselectedTabHover
(
false
)
;
}
if
(
newTab
.
hasAttribute
(
"
busy
"
)
&
&
!
this
.
_isBusy
)
{
this
.
_isBusy
=
true
;
this
.
_callProgressListeners
(
null
"
onStateChange
"
[
webProgress
null
Ci
.
nsIWebProgressListener
.
STATE_START
|
Ci
.
nsIWebProgressListener
.
STATE_IS_NETWORK
0
]
true
false
)
;
}
if
(
!
newTab
.
hasAttribute
(
"
busy
"
)
&
&
this
.
_isBusy
)
{
this
.
_isBusy
=
false
;
this
.
_callProgressListeners
(
null
"
onStateChange
"
[
webProgress
null
Ci
.
nsIWebProgressListener
.
STATE_STOP
|
Ci
.
nsIWebProgressListener
.
STATE_IS_NETWORK
0
]
true
false
)
;
}
if
(
!
this
.
_previewMode
)
{
let
event
=
new
CustomEvent
(
"
TabSelect
"
{
bubbles
:
true
cancelable
:
false
detail
:
{
previousTab
:
oldTab
}
}
)
;
newTab
.
dispatchEvent
(
event
)
;
this
.
_tabAttrModified
(
oldTab
[
"
selected
"
]
)
;
this
.
_tabAttrModified
(
newTab
[
"
selected
"
]
)
;
this
.
readNotificationBox
(
newBrowser
)
?
.
shown
(
)
;
this
.
_startMultiSelectChange
(
)
;
this
.
_multiSelectChangeSelected
=
true
;
this
.
clearMultiSelectedTabs
(
)
;
if
(
this
.
_multiSelectChangeAdditions
.
size
)
{
this
.
addToMultiSelectedTabs
(
oldTab
)
;
}
if
(
oldBrowser
!
=
newBrowser
&
&
oldBrowser
.
getInPermitUnload
)
{
oldBrowser
.
getInPermitUnload
(
inPermitUnload
=
>
{
if
(
!
inPermitUnload
)
{
return
;
}
let
promptBox
=
this
.
getTabModalPromptBox
(
oldBrowser
)
;
let
prompts
=
promptBox
.
listPrompts
(
)
;
if
(
prompts
.
length
)
{
prompts
[
prompts
.
length
-
1
]
.
abortPrompt
(
)
;
}
}
)
;
}
if
(
!
gMultiProcessBrowser
)
{
this
.
_adjustFocusBeforeTabSwitch
(
oldTab
newTab
)
;
this
.
_adjustFocusAfterTabSwitch
(
newTab
)
;
gURLBar
.
afterTabSwitchFocusChange
(
)
;
}
}
updateUserContextUIIndicator
(
)
;
gPermissionPanel
.
updateSharingIndicator
(
)
;
oldTab
.
removeAttribute
(
"
touchdownstartsdrag
"
)
;
newTab
.
setAttribute
(
"
touchdownstartsdrag
"
"
true
"
)
;
if
(
!
gMultiProcessBrowser
)
{
this
.
tabContainer
.
_setPositionalAttributes
(
)
;
document
.
commandDispatcher
.
unlock
(
)
;
let
event
=
new
CustomEvent
(
"
TabSwitchDone
"
{
bubbles
:
true
cancelable
:
true
}
)
;
this
.
dispatchEvent
(
event
)
;
}
if
(
!
aForceUpdate
)
{
TelemetryStopwatch
.
finish
(
"
FX_TAB_SWITCH_UPDATE_MS
"
)
;
}
}
_adjustFocusBeforeTabSwitch
(
oldTab
newTab
)
{
if
(
this
.
_previewMode
)
{
return
;
}
let
oldBrowser
=
oldTab
.
linkedBrowser
;
let
newBrowser
=
newTab
.
linkedBrowser
;
oldBrowser
.
_urlbarFocused
=
gURLBar
&
&
gURLBar
.
focused
;
if
(
this
.
isFindBarInitialized
(
oldTab
)
)
{
let
findBar
=
this
.
getCachedFindBar
(
oldTab
)
;
oldTab
.
_findBarFocused
=
!
findBar
.
hidden
&
&
findBar
.
_findField
.
getAttribute
(
"
focused
"
)
=
=
"
true
"
;
}
let
activeEl
=
document
.
activeElement
;
if
(
activeEl
=
=
oldTab
)
{
newTab
.
focus
(
)
;
}
else
if
(
gMultiProcessBrowser
&
&
activeEl
!
=
newBrowser
&
&
activeEl
!
=
newTab
)
{
let
keepFocusOnUrlBar
=
newBrowser
&
&
newBrowser
.
_urlbarFocused
&
&
gURLBar
&
&
gURLBar
.
focused
;
if
(
!
keepFocusOnUrlBar
)
{
document
.
activeElement
.
blur
(
)
;
}
}
}
_adjustFocusAfterTabSwitch
(
newTab
)
{
if
(
document
.
activeElement
=
=
newTab
)
{
return
;
}
let
newBrowser
=
this
.
getBrowserForTab
(
newTab
)
;
if
(
newBrowser
.
hasAttribute
(
"
tabDialogShowing
"
)
)
{
newBrowser
.
tabDialogBox
.
focus
(
)
;
return
;
}
if
(
newBrowser
.
hasAttribute
(
"
tabmodalPromptShowing
"
)
)
{
let
prompts
=
newBrowser
.
tabModalPromptBox
.
listPrompts
(
)
;
let
prompt
=
prompts
[
prompts
.
length
-
1
]
;
if
(
prompt
)
{
prompt
.
Dialog
.
setDefaultFocus
(
)
;
return
;
}
}
if
(
newBrowser
.
_urlbarFocused
&
&
gURLBar
)
{
if
(
gURLBar
.
focused
&
&
newBrowser
.
userTypedValue
)
{
return
;
}
if
(
!
window
.
fullScreen
|
|
newTab
.
isEmpty
)
{
gURLBar
.
select
(
)
;
return
;
}
}
if
(
gFindBarInitialized
&
&
!
gFindBar
.
hidden
&
&
this
.
selectedTab
.
_findBarFocused
)
{
gFindBar
.
_findField
.
focus
(
)
;
return
;
}
if
(
gMultiProcessBrowser
&
&
document
.
activeElement
!
=
document
.
body
)
{
return
;
}
let
fm
=
Services
.
focus
;
let
focusFlags
=
fm
.
FLAG_NOSCROLL
;
if
(
!
gMultiProcessBrowser
)
{
let
newFocusedElement
=
fm
.
getFocusedElementForWindow
(
window
.
content
true
{
}
)
;
if
(
newFocusedElement
&
&
(
HTMLAnchorElement
.
isInstance
(
newFocusedElement
)
|
|
newFocusedElement
.
getAttributeNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xlink
"
"
type
"
)
=
=
"
simple
"
)
)
{
focusFlags
|
=
fm
.
FLAG_SHOWRING
;
}
}
fm
.
setFocus
(
newBrowser
focusFlags
)
;
}
_tabAttrModified
(
aTab
aChanged
)
{
if
(
aTab
.
closing
)
{
return
;
}
let
event
=
new
CustomEvent
(
"
TabAttrModified
"
{
bubbles
:
true
cancelable
:
false
detail
:
{
changed
:
aChanged
}
}
)
;
aTab
.
dispatchEvent
(
event
)
;
}
resetBrowserSharing
(
aBrowser
)
{
let
tab
=
this
.
getTabForBrowser
(
aBrowser
)
;
if
(
!
tab
)
{
return
;
}
tab
.
_sharingState
=
tab
.
_sharingState
?
.
webRTC
?
{
webRTC
:
{
}
}
:
{
}
;
tab
.
removeAttribute
(
"
sharing
"
)
;
this
.
_tabAttrModified
(
tab
[
"
sharing
"
]
)
;
if
(
aBrowser
=
=
this
.
selectedBrowser
)
{
gPermissionPanel
.
updateSharingIndicator
(
)
;
}
}
updateBrowserSharing
(
aBrowser
aState
)
{
let
tab
=
this
.
getTabForBrowser
(
aBrowser
)
;
if
(
!
tab
)
{
return
;
}
if
(
tab
.
_sharingState
=
=
null
)
{
tab
.
_sharingState
=
{
}
;
}
tab
.
_sharingState
=
Object
.
assign
(
tab
.
_sharingState
aState
)
;
if
(
"
webRTC
"
in
aState
)
{
if
(
tab
.
_sharingState
.
webRTC
?
.
sharing
)
{
if
(
tab
.
_sharingState
.
webRTC
.
paused
)
{
tab
.
removeAttribute
(
"
sharing
"
)
;
}
else
{
tab
.
setAttribute
(
"
sharing
"
aState
.
webRTC
.
sharing
)
;
}
}
else
{
tab
.
removeAttribute
(
"
sharing
"
)
;
}
this
.
_tabAttrModified
(
tab
[
"
sharing
"
]
)
;
}
if
(
aBrowser
=
=
this
.
selectedBrowser
)
{
gPermissionPanel
.
updateSharingIndicator
(
)
;
}
}
getTabSharingState
(
aTab
)
{
let
state
=
Object
.
assign
(
{
}
aTab
.
_sharingState
&
&
aTab
.
_sharingState
.
webRTC
)
;
return
{
camera
:
!
!
state
.
camera
microphone
:
!
!
state
.
microphone
screen
:
state
.
screen
&
&
state
.
screen
.
replace
(
"
Paused
"
"
"
)
}
;
}
setInitialTabTitle
(
aTab
aTitle
aOptions
=
{
}
)
{
if
(
!
aOptions
.
isContentTitle
&
&
isBlankPageURL
(
aTitle
)
)
{
aTitle
=
this
.
tabContainer
.
emptyTabTitle
;
}
if
(
aTitle
)
{
if
(
!
aTab
.
getAttribute
(
"
label
"
)
)
{
aTab
.
_labelIsInitialTitle
=
true
;
}
this
.
_setTabLabel
(
aTab
aTitle
aOptions
)
;
}
}
setTabTitle
(
aTab
)
{
var
browser
=
this
.
getBrowserForTab
(
aTab
)
;
var
title
=
browser
.
contentTitle
;
if
(
aTab
.
hasAttribute
(
"
customizemode
"
)
)
{
let
brandBundle
=
document
.
getElementById
(
"
bundle_brand
"
)
;
let
brandShortName
=
brandBundle
.
getString
(
"
brandShortName
"
)
;
title
=
gNavigatorBundle
.
getFormattedString
(
"
customizeMode
.
tabTitle
"
[
brandShortName
]
)
;
}
if
(
aTab
.
_labelIsInitialTitle
)
{
if
(
!
title
)
{
return
false
;
}
delete
aTab
.
_labelIsInitialTitle
;
}
let
isContentTitle
=
!
!
title
;
if
(
!
title
)
{
if
(
browser
.
currentURI
.
displaySpec
)
{
try
{
title
=
Services
.
io
.
createExposableURI
(
browser
.
currentURI
)
.
displaySpec
;
}
catch
(
ex
)
{
title
=
browser
.
currentURI
.
displaySpec
;
}
}
if
(
title
&
&
!
isBlankPageURL
(
title
)
)
{
if
(
title
.
length
>
500
&
&
title
.
match
(
/
^
data
:
[
^
]
+
;
base64
/
)
)
{
title
=
title
.
substring
(
0
500
)
+
"
\
u2026
"
;
}
else
{
try
{
let
characterSet
=
browser
.
characterSet
;
title
=
Services
.
textToSubURI
.
unEscapeNonAsciiURI
(
characterSet
title
)
;
}
catch
(
ex
)
{
}
}
}
else
{
title
=
this
.
tabContainer
.
emptyTabTitle
;
}
}
return
this
.
_setTabLabel
(
aTab
title
{
isContentTitle
}
)
;
}
_setTabLabel
(
aTab
aLabel
{
beforeTabOpen
isContentTitle
}
=
{
}
)
{
if
(
!
aLabel
|
|
aLabel
.
includes
(
"
about
:
reader
?
"
)
)
{
return
false
;
}
aTab
.
_fullLabel
=
aLabel
;
if
(
!
isContentTitle
)
{
if
(
!
(
"
_regex_shortenURLForTabLabel
"
in
this
)
)
{
this
.
_regex_shortenURLForTabLabel
=
/
^
[
^
:
]
+
:
\
/
\
/
(
?
:
www
\
.
)
?
/
;
}
aLabel
=
aLabel
.
replace
(
this
.
_regex_shortenURLForTabLabel
"
"
)
;
}
aTab
.
_labelIsContentTitle
=
isContentTitle
;
if
(
aTab
.
getAttribute
(
"
label
"
)
=
=
aLabel
)
{
return
false
;
}
let
dwu
=
window
.
windowUtils
;
let
isRTL
=
dwu
.
getDirectionFromText
(
aLabel
)
=
=
Ci
.
nsIDOMWindowUtils
.
DIRECTION_RTL
;
aTab
.
setAttribute
(
"
label
"
aLabel
)
;
aTab
.
setAttribute
(
"
labeldirection
"
isRTL
?
"
rtl
"
:
"
ltr
"
)
;
aTab
.
toggleAttribute
(
"
labelendaligned
"
isRTL
!
=
(
document
.
dir
=
=
"
rtl
"
)
)
;
if
(
!
beforeTabOpen
)
{
this
.
_tabAttrModified
(
aTab
[
"
label
"
]
)
;
}
if
(
aTab
.
selected
)
{
this
.
updateTitlebar
(
)
;
}
return
true
;
}
loadOneTab
(
aURI
aReferrerInfoOrParams
aCharset
aPostData
aLoadInBackground
aAllowThirdPartyFixup
)
{
var
aTriggeringPrincipal
;
var
aReferrerInfo
;
var
aFromExternal
;
var
aRelatedToCurrent
;
var
aAllowInheritPrincipal
;
var
aSkipAnimation
;
var
aForceNotRemote
;
var
aPreferredRemoteType
;
var
aUserContextId
;
var
aInitialBrowsingContextGroupId
;
var
aOriginPrincipal
;
var
aOriginStoragePrincipal
;
var
aOpenWindowInfo
;
var
aOpenerBrowser
;
var
aCreateLazyBrowser
;
var
aFocusUrlBar
;
var
aName
;
var
aCsp
;
var
aSkipLoad
;
var
aGlobalHistoryOptions
;
if
(
arguments
.
length
=
=
2
&
&
typeof
arguments
[
1
]
=
=
"
object
"
&
&
!
(
arguments
[
1
]
instanceof
Ci
.
nsIURI
)
)
{
let
params
=
arguments
[
1
]
;
aTriggeringPrincipal
=
params
.
triggeringPrincipal
;
aReferrerInfo
=
params
.
referrerInfo
;
aCharset
=
params
.
charset
;
aPostData
=
params
.
postData
;
aLoadInBackground
=
params
.
inBackground
;
aAllowThirdPartyFixup
=
params
.
allowThirdPartyFixup
;
aFromExternal
=
params
.
fromExternal
;
aRelatedToCurrent
=
params
.
relatedToCurrent
;
aAllowInheritPrincipal
=
!
!
params
.
allowInheritPrincipal
;
aSkipAnimation
=
params
.
skipAnimation
;
aForceNotRemote
=
params
.
forceNotRemote
;
aPreferredRemoteType
=
params
.
preferredRemoteType
;
aUserContextId
=
params
.
userContextId
;
aInitialBrowsingContextGroupId
=
params
.
initialBrowsingContextGroupId
;
aOriginPrincipal
=
params
.
originPrincipal
;
aOriginStoragePrincipal
=
params
.
originStoragePrincipal
;
aOpenWindowInfo
=
params
.
openWindowInfo
;
aOpenerBrowser
=
params
.
openerBrowser
;
aCreateLazyBrowser
=
params
.
createLazyBrowser
;
aFocusUrlBar
=
params
.
focusUrlBar
;
aName
=
params
.
name
;
aCsp
=
params
.
csp
;
aSkipLoad
=
params
.
skipLoad
;
aGlobalHistoryOptions
=
params
.
globalHistoryOptions
;
}
if
(
!
aTriggeringPrincipal
)
{
throw
new
Error
(
"
Required
argument
triggeringPrincipal
missing
within
loadOneTab
"
)
;
}
var
bgLoad
=
aLoadInBackground
!
=
null
?
aLoadInBackground
:
Services
.
prefs
.
getBoolPref
(
"
browser
.
tabs
.
loadInBackground
"
)
;
var
owner
=
bgLoad
?
null
:
this
.
selectedTab
;
var
tab
=
this
.
addTab
(
aURI
{
triggeringPrincipal
:
aTriggeringPrincipal
referrerInfo
:
aReferrerInfo
charset
:
aCharset
postData
:
aPostData
ownerTab
:
owner
allowInheritPrincipal
:
aAllowInheritPrincipal
allowThirdPartyFixup
:
aAllowThirdPartyFixup
fromExternal
:
aFromExternal
relatedToCurrent
:
aRelatedToCurrent
skipAnimation
:
aSkipAnimation
forceNotRemote
:
aForceNotRemote
createLazyBrowser
:
aCreateLazyBrowser
preferredRemoteType
:
aPreferredRemoteType
userContextId
:
aUserContextId
originPrincipal
:
aOriginPrincipal
originStoragePrincipal
:
aOriginStoragePrincipal
initialBrowsingContextGroupId
:
aInitialBrowsingContextGroupId
openWindowInfo
:
aOpenWindowInfo
openerBrowser
:
aOpenerBrowser
focusUrlBar
:
aFocusUrlBar
name
:
aName
csp
:
aCsp
skipLoad
:
aSkipLoad
globalHistoryOptions
:
aGlobalHistoryOptions
}
)
;
if
(
!
bgLoad
)
{
this
.
selectedTab
=
tab
;
}
return
tab
;
}
loadTabs
(
aURIs
{
allowInheritPrincipal
allowThirdPartyFixup
inBackground
newIndex
postDatas
replace
targetTab
triggeringPrincipal
csp
userContextId
fromExternal
}
=
{
}
)
{
if
(
!
aURIs
.
length
)
{
return
;
}
var
multiple
=
aURIs
.
length
>
1
;
var
owner
=
multiple
|
|
inBackground
?
null
:
this
.
selectedTab
;
var
firstTabAdded
=
null
;
var
targetTabIndex
=
-
1
;
if
(
typeof
newIndex
!
=
"
number
"
)
{
newIndex
=
-
1
;
}
if
(
multiple
&
&
newIndex
<
0
&
&
Services
.
prefs
.
getBoolPref
(
"
browser
.
tabs
.
insertAfterCurrent
"
)
)
{
newIndex
=
this
.
selectedTab
.
_tPos
+
1
;
}
if
(
replace
)
{
let
browser
;
if
(
targetTab
)
{
browser
=
this
.
getBrowserForTab
(
targetTab
)
;
targetTabIndex
=
targetTab
.
_tPos
;
}
else
{
browser
=
this
.
selectedBrowser
;
targetTabIndex
=
this
.
tabContainer
.
selectedIndex
;
}
let
flags
=
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_NONE
;
if
(
allowThirdPartyFixup
)
{
flags
|
=
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP
|
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_FIXUP_SCHEME_TYPOS
;
}
if
(
!
allowInheritPrincipal
)
{
flags
|
=
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_DISALLOW_INHERIT_PRINCIPAL
;
}
if
(
fromExternal
)
{
flags
|
=
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_FROM_EXTERNAL
;
}
try
{
browser
.
loadURI
(
aURIs
[
0
]
{
flags
postData
:
postDatas
&
&
postDatas
[
0
]
triggeringPrincipal
csp
}
)
;
}
catch
(
e
)
{
}
}
else
{
let
params
=
{
allowInheritPrincipal
ownerTab
:
owner
skipAnimation
:
multiple
allowThirdPartyFixup
postData
:
postDatas
&
&
postDatas
[
0
]
userContextId
triggeringPrincipal
bulkOrderedOpen
:
multiple
csp
fromExternal
}
;
if
(
newIndex
>
-
1
)
{
params
.
index
=
newIndex
;
}
firstTabAdded
=
this
.
addTab
(
aURIs
[
0
]
params
)
;
if
(
newIndex
>
-
1
)
{
targetTabIndex
=
firstTabAdded
.
_tPos
;
}
}
let
tabNum
=
targetTabIndex
;
for
(
let
i
=
1
;
i
<
aURIs
.
length
;
+
+
i
)
{
let
params
=
{
allowInheritPrincipal
skipAnimation
:
true
allowThirdPartyFixup
postData
:
postDatas
&
&
postDatas
[
i
]
userContextId
triggeringPrincipal
bulkOrderedOpen
:
true
csp
fromExternal
}
;
if
(
targetTabIndex
>
-
1
)
{
params
.
index
=
+
+
tabNum
;
}
this
.
addTab
(
aURIs
[
i
]
params
)
;
}
if
(
firstTabAdded
&
&
!
inBackground
)
{
this
.
selectedTab
=
firstTabAdded
;
}
}
updateBrowserRemoteness
(
aBrowser
{
newFrameloader
remoteType
}
=
{
}
)
{
let
isRemote
=
aBrowser
.
getAttribute
(
"
remote
"
)
=
=
"
true
"
;
if
(
remoteType
=
=
=
undefined
)
{
throw
new
Error
(
"
Remote
type
must
be
set
!
"
)
;
}
let
shouldBeRemote
=
remoteType
!
=
=
E10SUtils
.
NOT_REMOTE
;
if
(
!
gMultiProcessBrowser
&
&
shouldBeRemote
)
{
throw
new
Error
(
"
Cannot
switch
to
remote
browser
in
a
window
"
+
"
without
the
remote
tabs
load
context
.
"
)
;
}
let
oldRemoteType
=
aBrowser
.
remoteType
;
if
(
isRemote
=
=
shouldBeRemote
&
&
!
newFrameloader
&
&
(
!
isRemote
|
|
oldRemoteType
=
=
remoteType
)
)
{
return
false
;
}
let
tab
=
this
.
getTabForBrowser
(
aBrowser
)
;
this
.
_insertBrowser
(
tab
)
;
let
evt
=
document
.
createEvent
(
"
Events
"
)
;
evt
.
initEvent
(
"
BeforeTabRemotenessChange
"
true
false
)
;
tab
.
dispatchEvent
(
evt
)
;
let
wasActive
=
document
.
activeElement
=
=
aBrowser
;
let
filter
=
this
.
_tabFilters
.
get
(
tab
)
;
let
listener
=
this
.
_tabListeners
.
get
(
tab
)
;
aBrowser
.
webProgress
.
removeProgressListener
(
filter
)
;
filter
.
removeProgressListener
(
listener
)
;
listener
.
destroy
(
)
;
let
oldDroppedLinkHandler
=
aBrowser
.
droppedLinkHandler
;
let
oldUserTypedValue
=
aBrowser
.
userTypedValue
;
let
hadStartedLoad
=
aBrowser
.
didStartLoadSinceLastUserTyping
(
)
;
aBrowser
.
destroy
(
)
;
if
(
shouldBeRemote
)
{
aBrowser
.
setAttribute
(
"
remote
"
"
true
"
)
;
aBrowser
.
setAttribute
(
"
remoteType
"
remoteType
)
;
}
else
{
aBrowser
.
setAttribute
(
"
remote
"
"
false
"
)
;
aBrowser
.
removeAttribute
(
"
remoteType
"
)
;
}
aBrowser
.
changeRemoteness
(
{
remoteType
}
)
;
aBrowser
.
construct
(
)
;
aBrowser
.
userTypedValue
=
oldUserTypedValue
;
if
(
hadStartedLoad
)
{
aBrowser
.
urlbarChangeTracker
.
startedLoad
(
)
;
}
aBrowser
.
droppedLinkHandler
=
oldDroppedLinkHandler
;
aBrowser
.
docShellIsActive
=
aBrowser
.
docShellIsActive
;
listener
=
new
TabProgressListener
(
tab
aBrowser
true
false
)
;
this
.
_tabListeners
.
set
(
tab
listener
)
;
filter
.
addProgressListener
(
listener
Ci
.
nsIWebProgress
.
NOTIFY_ALL
)
;
aBrowser
.
webProgress
.
addProgressListener
(
filter
Ci
.
nsIWebProgress
.
NOTIFY_ALL
)
;
let
securityUI
=
aBrowser
.
securityUI
;
let
state
=
securityUI
?
securityUI
.
state
:
Ci
.
nsIWebProgressListener
.
STATE_IS_INSECURE
;
this
.
_callProgressListeners
(
aBrowser
"
onSecurityChange
"
[
aBrowser
.
webProgress
null
state
]
true
false
)
;
let
event
=
aBrowser
.
getContentBlockingEvents
(
)
;
this
.
_callProgressListeners
(
aBrowser
"
onContentBlockingEvent
"
[
aBrowser
.
webProgress
null
event
true
]
true
false
)
;
if
(
shouldBeRemote
)
{
tab
.
removeAttribute
(
"
crashed
"
)
;
this
.
tabContainer
.
updateTabIndicatorAttr
(
tab
)
;
}
else
{
aBrowser
.
sendMessageToActor
(
"
Browser
:
AppTab
"
{
isAppTab
:
tab
.
pinned
}
"
BrowserTab
"
)
;
}
if
(
wasActive
)
{
aBrowser
.
focus
(
)
;
}
if
(
this
.
isFindBarInitialized
(
tab
)
)
{
this
.
getCachedFindBar
(
tab
)
.
browser
=
aBrowser
;
}
tab
.
linkedBrowser
.
sendMessageToActor
(
"
Browser
:
HasSiblings
"
this
.
tabs
.
length
>
1
"
BrowserTab
"
)
;
evt
=
document
.
createEvent
(
"
Events
"
)
;
evt
.
initEvent
(
"
TabRemotenessChange
"
true
false
)
;
tab
.
dispatchEvent
(
evt
)
;
return
true
;
}
updateBrowserRemotenessByURL
(
aBrowser
aURL
aOptions
=
{
}
)
{
if
(
!
gMultiProcessBrowser
)
{
return
this
.
updateBrowserRemoteness
(
aBrowser
{
remoteType
:
E10SUtils
.
NOT_REMOTE
}
)
;
}
let
oldRemoteType
=
aBrowser
.
remoteType
;
let
oa
=
E10SUtils
.
predictOriginAttributes
(
{
browser
:
aBrowser
}
)
;
aOptions
.
remoteType
=
E10SUtils
.
getRemoteTypeForURI
(
aURL
gMultiProcessBrowser
gFissionBrowser
oldRemoteType
aBrowser
.
currentURI
oa
)
;
if
(
oldRemoteType
!
=
aOptions
.
remoteType
|
|
aOptions
.
newFrameloader
)
{
return
this
.
updateBrowserRemoteness
(
aBrowser
aOptions
)
;
}
return
false
;
}
createBrowser
(
{
isPreloadBrowser
name
openWindowInfo
remoteType
initialBrowsingContextGroupId
uriIsAboutBlank
userContextId
skipLoad
initiallyActive
}
=
{
}
)
{
let
b
=
document
.
createXULElement
(
"
browser
"
)
;
b
.
permanentKey
=
new
(
Cu
.
getGlobalForObject
(
Services
)
.
Object
)
(
)
;
if
(
!
Services
.
appinfo
.
sessionHistoryInParent
)
{
b
.
prepareToChangeRemoteness
=
(
)
=
>
SessionStore
.
prepareToChangeRemoteness
(
b
)
;
b
.
afterChangeRemoteness
=
switchId
=
>
{
let
tab
=
this
.
getTabForBrowser
(
b
)
;
SessionStore
.
finishTabRemotenessChange
(
tab
switchId
)
;
return
true
;
}
;
}
const
defaultBrowserAttributes
=
{
contextmenu
:
"
contentAreaContextMenu
"
message
:
"
true
"
messagemanagergroup
:
"
browsers
"
tooltip
:
"
aHTMLTooltip
"
type
:
"
content
"
}
;
for
(
let
attribute
in
defaultBrowserAttributes
)
{
b
.
setAttribute
(
attribute
defaultBrowserAttributes
[
attribute
]
)
;
}
if
(
gMultiProcessBrowser
|
|
remoteType
)
{
b
.
setAttribute
(
"
maychangeremoteness
"
"
true
"
)
;
}
if
(
!
initiallyActive
)
{
b
.
setAttribute
(
"
initiallyactive
"
"
false
"
)
;
}
if
(
userContextId
)
{
b
.
setAttribute
(
"
usercontextid
"
userContextId
)
;
}
if
(
remoteType
)
{
b
.
setAttribute
(
"
remoteType
"
remoteType
)
;
b
.
setAttribute
(
"
remote
"
"
true
"
)
;
}
if
(
!
isPreloadBrowser
)
{
b
.
setAttribute
(
"
autocompletepopup
"
"
PopupAutoComplete
"
)
;
}
if
(
isPreloadBrowser
)
{
b
.
setAttribute
(
"
preloadedState
"
"
preloaded
"
)
;
}
if
(
initialBrowsingContextGroupId
)
{
b
.
setAttribute
(
"
initialBrowsingContextGroupId
"
initialBrowsingContextGroupId
)
;
}
if
(
openWindowInfo
)
{
b
.
openWindowInfo
=
openWindowInfo
;
}
if
(
name
)
{
b
.
setAttribute
(
"
name
"
name
)
;
}
let
notificationbox
=
document
.
createXULElement
(
"
notificationbox
"
)
;
notificationbox
.
setAttribute
(
"
notificationside
"
"
top
"
)
;
let
stack
=
document
.
createXULElement
(
"
stack
"
)
;
stack
.
className
=
"
browserStack
"
;
stack
.
appendChild
(
b
)
;
stack
.
setAttribute
(
"
flex
"
"
10000
"
)
;
let
browserContainer
=
document
.
createXULElement
(
"
vbox
"
)
;
browserContainer
.
className
=
"
browserContainer
"
;
browserContainer
.
appendChild
(
notificationbox
)
;
browserContainer
.
appendChild
(
stack
)
;
browserContainer
.
setAttribute
(
"
flex
"
"
10000
"
)
;
let
browserSidebarContainer
=
document
.
createXULElement
(
"
hbox
"
)
;
browserSidebarContainer
.
className
=
"
browserSidebarContainer
"
;
browserSidebarContainer
.
appendChild
(
browserContainer
)
;
if
(
!
uriIsAboutBlank
|
|
skipLoad
)
{
b
.
setAttribute
(
"
nodefaultsrc
"
"
true
"
)
;
}
return
b
;
}
_createLazyBrowser
(
aTab
)
{
let
browser
=
aTab
.
linkedBrowser
;
let
names
=
this
.
_browserBindingProperties
;
for
(
let
i
=
0
;
i
<
names
.
length
;
i
+
+
)
{
let
name
=
names
[
i
]
;
let
getter
;
let
setter
;
switch
(
name
)
{
case
"
audioMuted
"
:
getter
=
(
)
=
>
aTab
.
hasAttribute
(
"
muted
"
)
;
break
;
case
"
contentTitle
"
:
getter
=
(
)
=
>
SessionStore
.
getLazyTabValue
(
aTab
"
title
"
)
;
break
;
case
"
currentURI
"
:
getter
=
(
)
=
>
{
if
(
browser
.
_cachedCurrentURI
)
{
return
browser
.
_cachedCurrentURI
;
}
let
url
=
SessionStore
.
getLazyTabValue
(
aTab
"
url
"
)
|
|
"
about
:
blank
"
;
return
(
browser
.
_cachedCurrentURI
=
Services
.
io
.
newURI
(
url
)
)
;
}
;
break
;
case
"
didStartLoadSinceLastUserTyping
"
:
getter
=
(
)
=
>
(
)
=
>
false
;
break
;
case
"
fullZoom
"
:
case
"
textZoom
"
:
getter
=
(
)
=
>
1
;
break
;
case
"
tabHasCustomZoom
"
:
getter
=
(
)
=
>
false
;
break
;
case
"
getTabBrowser
"
:
getter
=
(
)
=
>
(
)
=
>
this
;
break
;
case
"
isRemoteBrowser
"
:
getter
=
(
)
=
>
browser
.
getAttribute
(
"
remote
"
)
=
=
"
true
"
;
break
;
case
"
permitUnload
"
:
getter
=
(
)
=
>
(
)
=
>
(
{
permitUnload
:
true
}
)
;
break
;
case
"
reload
"
:
case
"
reloadWithFlags
"
:
getter
=
(
)
=
>
params
=
>
{
aTab
.
addEventListener
(
"
SSTabRestoring
"
(
)
=
>
{
browser
[
name
]
(
params
)
;
}
{
once
:
true
}
)
;
gBrowser
.
_insertBrowser
(
aTab
)
;
}
;
break
;
case
"
remoteType
"
:
getter
=
(
)
=
>
{
let
url
=
SessionStore
.
getLazyTabValue
(
aTab
"
url
"
)
|
|
"
about
:
blank
"
;
let
uri
;
if
(
browser
.
_cachedCurrentURI
)
{
uri
=
browser
.
_cachedCurrentURI
;
}
else
{
uri
=
browser
.
_cachedCurrentURI
=
Services
.
io
.
newURI
(
url
)
;
}
let
oa
=
E10SUtils
.
predictOriginAttributes
(
{
browser
userContextId
:
aTab
.
getAttribute
(
"
usercontextid
"
)
}
)
;
return
E10SUtils
.
getRemoteTypeForURI
(
url
gMultiProcessBrowser
gFissionBrowser
undefined
uri
oa
)
;
}
;
break
;
case
"
userTypedValue
"
:
case
"
userTypedClear
"
:
getter
=
(
)
=
>
SessionStore
.
getLazyTabValue
(
aTab
name
)
;
break
;
default
:
getter
=
(
)
=
>
{
if
(
AppConstants
.
NIGHTLY_BUILD
)
{
let
message
=
[
bug
1345098
]
Lazy
browser
prematurely
inserted
via
'
{
name
}
'
property
access
:
\
n
;
Services
.
console
.
logStringMessage
(
message
+
new
Error
(
)
.
stack
)
;
}
this
.
_insertBrowser
(
aTab
)
;
return
browser
[
name
]
;
}
;
setter
=
value
=
>
{
if
(
AppConstants
.
NIGHTLY_BUILD
)
{
let
message
=
[
bug
1345098
]
Lazy
browser
prematurely
inserted
via
'
{
name
}
'
property
access
:
\
n
;
Services
.
console
.
logStringMessage
(
message
+
new
Error
(
)
.
stack
)
;
}
this
.
_insertBrowser
(
aTab
)
;
return
(
browser
[
name
]
=
value
)
;
}
;
}
Object
.
defineProperty
(
browser
name
{
get
:
getter
set
:
setter
configurable
:
true
enumerable
:
true
}
)
;
}
}
_insertBrowser
(
aTab
aInsertedOnTabCreation
)
{
"
use
strict
"
;
if
(
aTab
.
linkedPanel
|
|
window
.
closed
)
{
return
;
}
let
browser
=
aTab
.
linkedBrowser
;
if
(
this
.
_browserBindingProperties
[
0
]
in
browser
)
{
for
(
let
name
of
this
.
_browserBindingProperties
)
{
delete
browser
[
name
]
;
}
}
let
{
uriIsAboutBlank
usingPreloadedContent
}
=
aTab
.
_browserParams
;
delete
aTab
.
_browserParams
;
delete
browser
.
_cachedCurrentURI
;
let
panel
=
this
.
getPanel
(
browser
)
;
let
uniqueId
=
this
.
_generateUniquePanelID
(
)
;
panel
.
id
=
uniqueId
;
aTab
.
linkedPanel
=
uniqueId
;
if
(
!
panel
.
parentNode
)
{
this
.
tabpanels
.
appendChild
(
panel
)
;
}
let
tabListener
=
new
TabProgressListener
(
aTab
browser
uriIsAboutBlank
usingPreloadedContent
)
;
const
filter
=
Cc
[
"
mozilla
.
org
/
appshell
/
component
/
browser
-
status
-
filter
;
1
"
]
.
createInstance
(
Ci
.
nsIWebProgress
)
;
filter
.
addProgressListener
(
tabListener
Ci
.
nsIWebProgress
.
NOTIFY_ALL
)
;
browser
.
webProgress
.
addProgressListener
(
filter
Ci
.
nsIWebProgress
.
NOTIFY_ALL
)
;
this
.
_tabListeners
.
set
(
aTab
tabListener
)
;
this
.
_tabFilters
.
set
(
aTab
filter
)
;
browser
.
droppedLinkHandler
=
handleDroppedLink
;
browser
.
loadURI
=
_loadURI
.
bind
(
null
browser
)
;
if
(
!
usingPreloadedContent
)
{
browser
.
docShellIsActive
=
false
;
}
if
(
this
.
tabs
.
length
=
=
2
)
{
this
.
tabs
[
0
]
.
linkedBrowser
.
sendMessageToActor
(
"
Browser
:
HasSiblings
"
true
"
BrowserTab
"
)
;
this
.
tabs
[
1
]
.
linkedBrowser
.
sendMessageToActor
(
"
Browser
:
HasSiblings
"
true
"
BrowserTab
"
)
;
}
else
{
aTab
.
linkedBrowser
.
sendMessageToActor
(
"
Browser
:
HasSiblings
"
this
.
tabs
.
length
>
1
"
BrowserTab
"
)
;
}
if
(
aTab
.
isConnected
)
{
var
evt
=
new
CustomEvent
(
"
TabBrowserInserted
"
{
bubbles
:
true
detail
:
{
insertedOnTabCreation
:
aInsertedOnTabCreation
}
}
)
;
aTab
.
dispatchEvent
(
evt
)
;
}
}
_mayDiscardBrowser
(
aTab
aForceDiscard
)
{
let
browser
=
aTab
.
linkedBrowser
;
let
action
=
aForceDiscard
?
"
unload
"
:
"
dontUnload
"
;
if
(
!
aTab
|
|
aTab
.
selected
|
|
aTab
.
closing
|
|
this
.
_windowIsClosing
|
|
!
browser
.
isConnected
|
|
!
browser
.
isRemoteBrowser
|
|
!
browser
.
permitUnload
(
action
)
.
permitUnload
)
{
return
false
;
}
return
true
;
}
discardBrowser
(
aTab
aForceDiscard
)
{
"
use
strict
"
;
let
browser
=
aTab
.
linkedBrowser
;
if
(
!
this
.
_mayDiscardBrowser
(
aTab
aForceDiscard
)
)
{
return
false
;
}
if
(
aTab
.
_sharingState
)
{
this
.
resetBrowserSharing
(
browser
)
;
}
webrtcUI
.
forgetStreamsFromBrowserContext
(
browser
.
browsingContext
)
;
aTab
.
_browserParams
=
{
uriIsAboutBlank
:
browser
.
currentURI
.
spec
=
=
"
about
:
blank
"
remoteType
:
browser
.
remoteType
usingPreloadedContent
:
false
}
;
SessionStore
.
resetBrowserToLazyState
(
aTab
)
;
let
filter
=
this
.
_tabFilters
.
get
(
aTab
)
;
let
listener
=
this
.
_tabListeners
.
get
(
aTab
)
;
browser
.
webProgress
.
removeProgressListener
(
filter
)
;
filter
.
removeProgressListener
(
listener
)
;
listener
.
destroy
(
)
;
this
.
_tabListeners
.
delete
(
aTab
)
;
this
.
_tabFilters
.
delete
(
aTab
)
;
if
(
aTab
.
_findBar
)
{
aTab
.
_findBar
.
close
(
true
)
;
aTab
.
_findBar
.
remove
(
)
;
delete
aTab
.
_findBar
;
}
let
attributesToRemove
=
[
"
activemedia
-
blocked
"
"
busy
"
"
pendingicon
"
"
progress
"
"
soundplaying
"
]
;
let
removedAttributes
=
[
]
;
for
(
let
attr
of
attributesToRemove
)
{
if
(
aTab
.
hasAttribute
(
attr
)
)
{
removedAttributes
.
push
(
attr
)
;
aTab
.
removeAttribute
(
attr
)
;
}
}
if
(
removedAttributes
.
length
)
{
this
.
_tabAttrModified
(
aTab
removedAttributes
)
;
}
browser
.
destroy
(
)
;
this
.
getPanel
(
browser
)
.
remove
(
)
;
aTab
.
removeAttribute
(
"
linkedpanel
"
)
;
this
.
_createLazyBrowser
(
aTab
)
;
let
evt
=
new
CustomEvent
(
"
TabBrowserDiscarded
"
{
bubbles
:
true
}
)
;
aTab
.
dispatchEvent
(
evt
)
;
return
true
;
}
addWebTab
(
aURI
params
=
{
}
)
{
if
(
!
params
.
triggeringPrincipal
)
{
params
.
triggeringPrincipal
=
Services
.
scriptSecurityManager
.
createNullPrincipal
(
{
userContextId
:
params
.
userContextId
}
)
;
}
if
(
params
.
triggeringPrincipal
.
isSystemPrincipal
)
{
throw
new
Error
(
"
System
principal
should
never
be
passed
into
addWebTab
(
)
"
)
;
}
return
this
.
addTab
(
aURI
params
)
;
}
addAdjacentNewTab
(
tab
)
{
Services
.
obs
.
notifyObservers
(
{
wrappedJSObject
:
new
Promise
(
resolve
=
>
{
this
.
selectedTab
=
this
.
addTrustedTab
(
BROWSER_NEW_TAB_URL
{
index
:
tab
.
_tPos
+
1
userContextId
:
tab
.
userContextId
}
)
;
resolve
(
this
.
selectedBrowser
)
;
}
)
}
"
browser
-
open
-
newtab
-
start
"
)
;
}
addTrustedTab
(
aURI
params
=
{
}
)
{
params
.
triggeringPrincipal
=
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
;
return
this
.
addTab
(
aURI
params
)
;
}
addTab
(
aURI
{
allowInheritPrincipal
allowThirdPartyFixup
bulkOrderedOpen
charset
createLazyBrowser
disableTRR
eventDetail
focusUrlBar
forceNotRemote
fromExternal
index
lazyTabTitle
name
noInitialLabel
openWindowInfo
openerBrowser
originPrincipal
originStoragePrincipal
ownerTab
pinned
postData
preferredRemoteType
referrerInfo
relatedToCurrent
initialBrowsingContextGroupId
skipAnimation
skipBackgroundNotify
triggeringPrincipal
userContextId
csp
skipLoad
batchInsertingTabs
globalHistoryOptions
}
=
{
}
)
{
if
(
!
triggeringPrincipal
)
{
throw
new
Error
(
"
Required
argument
triggeringPrincipal
missing
within
addTab
"
)
;
}
if
(
!
UserInteraction
.
running
(
"
browser
.
tabs
.
opening
"
window
)
)
{
UserInteraction
.
start
(
"
browser
.
tabs
.
opening
"
"
initting
"
window
)
;
}
document
.
getElementById
(
"
History
:
UndoCloseTab
"
)
.
setAttribute
(
"
data
-
l10n
-
args
"
JSON
.
stringify
(
{
tabCount
:
1
}
)
)
;
if
(
this
.
selectedTab
.
owner
)
{
this
.
selectedTab
.
owner
=
null
;
}
if
(
relatedToCurrent
=
=
null
)
{
relatedToCurrent
=
!
!
(
referrerInfo
&
&
referrerInfo
.
originalReferrer
)
;
}
let
openerTab
=
(
openerBrowser
&
&
this
.
getTabForBrowser
(
openerBrowser
)
)
|
|
(
relatedToCurrent
&
&
this
.
selectedTab
)
;
var
t
=
document
.
createXULElement
(
"
tab
"
{
is
:
"
tabbrowser
-
tab
"
}
)
;
t
.
initializingTab
=
true
;
t
.
openerTab
=
openerTab
;
aURI
=
aURI
|
|
"
about
:
blank
"
;
let
aURIObject
=
null
;
try
{
aURIObject
=
Services
.
io
.
newURI
(
aURI
)
;
}
catch
(
ex
)
{
}
let
lazyBrowserURI
;
if
(
createLazyBrowser
&
&
aURI
!
=
"
about
:
blank
"
)
{
lazyBrowserURI
=
aURIObject
;
aURI
=
"
about
:
blank
"
;
}
var
uriIsAboutBlank
=
aURI
=
=
"
about
:
blank
"
;
let
animate
=
!
skipAnimation
&
&
!
pinned
&
&
this
.
tabContainer
.
getAttribute
(
"
overflow
"
)
!
=
"
true
"
&
&
!
gReduceMotion
;
if
(
userContextId
=
=
null
&
&
openerTab
)
{
userContextId
=
openerTab
.
getAttribute
(
"
usercontextid
"
)
|
|
0
;
}
if
(
!
noInitialLabel
)
{
if
(
isBlankPageURL
(
aURI
)
)
{
t
.
setAttribute
(
"
label
"
this
.
tabContainer
.
emptyTabTitle
)
;
}
else
{
this
.
setInitialTabTitle
(
t
aURI
{
beforeTabOpen
:
true
}
)
;
}
}
if
(
userContextId
)
{
t
.
setAttribute
(
"
usercontextid
"
userContextId
)
;
ContextualIdentityService
.
setTabStyle
(
t
)
;
}
if
(
skipBackgroundNotify
)
{
t
.
setAttribute
(
"
skipbackgroundnotify
"
true
)
;
}
if
(
pinned
)
{
t
.
setAttribute
(
"
pinned
"
"
true
"
)
;
}
t
.
classList
.
add
(
"
tabbrowser
-
tab
"
)
;
this
.
tabContainer
.
_unlockTabSizing
(
)
;
if
(
!
animate
)
{
UserInteraction
.
update
(
"
browser
.
tabs
.
opening
"
"
not
-
animated
"
window
)
;
t
.
setAttribute
(
"
fadein
"
"
true
"
)
;
setTimeout
(
function
(
tabContainer
)
{
tabContainer
.
_handleNewTab
(
t
)
;
}
0
this
.
tabContainer
)
;
}
else
{
UserInteraction
.
update
(
"
browser
.
tabs
.
opening
"
"
animated
"
window
)
;
}
let
usingPreloadedContent
=
false
;
let
b
;
try
{
if
(
!
batchInsertingTabs
)
{
this
.
_insertTabAtIndex
(
t
{
index
ownerTab
openerTab
pinned
bulkOrderedOpen
}
)
;
}
if
(
!
preferredRemoteType
&
&
openerBrowser
)
{
preferredRemoteType
=
openerBrowser
.
remoteType
;
}
var
oa
=
E10SUtils
.
predictOriginAttributes
(
{
window
userContextId
}
)
;
if
(
uriIsAboutBlank
&
&
!
preferredRemoteType
&
&
referrerInfo
&
&
referrerInfo
.
originalReferrer
)
{
preferredRemoteType
=
E10SUtils
.
getRemoteTypeForURI
(
referrerInfo
.
originalReferrer
.
spec
gMultiProcessBrowser
gFissionBrowser
E10SUtils
.
DEFAULT_REMOTE_TYPE
null
oa
)
;
}
let
remoteType
=
forceNotRemote
?
E10SUtils
.
NOT_REMOTE
:
E10SUtils
.
getRemoteTypeForURI
(
aURI
gMultiProcessBrowser
gFissionBrowser
preferredRemoteType
null
oa
)
;
if
(
aURI
=
=
BROWSER_NEW_TAB_URL
&
&
!
userContextId
)
{
b
=
NewTabPagePreloading
.
getPreloadedBrowser
(
window
)
;
if
(
b
)
{
usingPreloadedContent
=
true
;
}
}
if
(
!
b
)
{
b
=
this
.
createBrowser
(
{
remoteType
uriIsAboutBlank
userContextId
initialBrowsingContextGroupId
openWindowInfo
name
skipLoad
}
)
;
}
t
.
linkedBrowser
=
b
;
if
(
focusUrlBar
)
{
b
.
_urlbarFocused
=
true
;
}
this
.
_tabForBrowser
.
set
(
b
t
)
;
t
.
permanentKey
=
b
.
permanentKey
;
t
.
_browserParams
=
{
uriIsAboutBlank
remoteType
usingPreloadedContent
}
;
if
(
createLazyBrowser
)
{
this
.
_createLazyBrowser
(
t
)
;
if
(
lazyBrowserURI
)
{
this
.
UrlbarProviderOpenTabs
.
registerOpenTab
(
lazyBrowserURI
.
spec
userContextId
|
|
0
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
;
b
.
registeredOpenURI
=
lazyBrowserURI
;
}
SessionStore
.
setTabState
(
t
{
entries
:
[
{
url
:
lazyBrowserURI
?
lazyBrowserURI
.
spec
:
"
about
:
blank
"
title
:
lazyTabTitle
triggeringPrincipal_base64
:
E10SUtils
.
serializePrincipal
(
triggeringPrincipal
)
}
]
}
)
;
}
else
{
this
.
_insertBrowser
(
t
true
)
;
if
(
openerBrowser
&
&
!
openWindowInfo
)
{
b
.
browsingContext
.
setCrossGroupOpener
(
openerBrowser
.
browsingContext
)
;
}
}
}
catch
(
e
)
{
Cu
.
reportError
(
"
Failed
to
create
tab
"
)
;
Cu
.
reportError
(
e
)
;
t
.
remove
(
)
;
if
(
t
.
linkedBrowser
)
{
this
.
_tabFilters
.
delete
(
t
)
;
this
.
_tabListeners
.
delete
(
t
)
;
this
.
getPanel
(
t
.
linkedBrowser
)
.
remove
(
)
;
}
return
null
;
}
this
.
setDefaultIcon
(
t
aURIObject
)
;
if
(
!
batchInsertingTabs
)
{
this
.
_fireTabOpen
(
t
eventDetail
)
;
if
(
!
usingPreloadedContent
&
&
originPrincipal
&
&
originStoragePrincipal
&
&
aURI
)
{
let
{
URI_INHERITS_SECURITY_CONTEXT
}
=
Ci
.
nsIProtocolHandler
;
if
(
!
aURIObject
|
|
doGetProtocolFlags
(
aURIObject
)
&
URI_INHERITS_SECURITY_CONTEXT
)
{
b
.
createAboutBlankContentViewer
(
originPrincipal
originStoragePrincipal
)
;
}
}
if
(
!
usingPreloadedContent
&
&
(
!
uriIsAboutBlank
|
|
!
allowInheritPrincipal
)
&
&
!
skipLoad
)
{
if
(
aURI
&
&
!
gInitialPages
.
includes
(
aURI
)
)
{
b
.
userTypedValue
=
aURI
;
}
let
flags
=
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_NONE
;
if
(
allowThirdPartyFixup
)
{
flags
|
=
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP
;
flags
|
=
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_FIXUP_SCHEME_TYPOS
;
}
if
(
fromExternal
)
{
flags
|
=
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_FROM_EXTERNAL
;
}
else
if
(
!
triggeringPrincipal
.
isSystemPrincipal
)
{
flags
|
=
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_FIRST_LOAD
;
}
if
(
!
allowInheritPrincipal
)
{
flags
|
=
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_DISALLOW_INHERIT_PRINCIPAL
;
}
if
(
disableTRR
)
{
flags
|
=
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_DISABLE_TRR
;
}
try
{
b
.
loadURI
(
aURI
{
flags
triggeringPrincipal
referrerInfo
charset
postData
csp
globalHistoryOptions
}
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
}
}
this
.
tabAnimationsInProgress
+
+
;
if
(
animate
)
{
requestAnimationFrame
(
function
(
)
{
t
.
setAttribute
(
"
fadein
"
"
true
"
)
;
}
)
;
}
if
(
pinned
)
{
this
.
_notifyPinnedStatus
(
t
)
;
}
gSharedTabWarning
.
tabAdded
(
t
)
;
return
t
;
}
addMultipleTabs
(
restoreTabsLazily
selectTab
aPropertiesTabs
)
{
let
tabs
=
[
]
;
let
tabsFragment
=
document
.
createDocumentFragment
(
)
;
let
tabToSelect
=
null
;
let
hiddenTabs
=
new
Map
(
)
;
let
shouldUpdateForPinnedTabs
=
false
;
for
(
var
i
=
0
;
i
<
aPropertiesTabs
.
length
;
i
+
+
)
{
let
tabData
=
aPropertiesTabs
[
i
]
;
let
userContextId
=
tabData
.
userContextId
;
let
select
=
i
=
=
selectTab
-
1
;
let
tab
;
let
tabWasReused
=
false
;
if
(
select
&
&
this
.
selectedTab
.
userContextId
=
=
userContextId
&
&
!
SessionStore
.
isTabRestoring
(
this
.
selectedTab
)
)
{
tabWasReused
=
true
;
tab
=
this
.
selectedTab
;
if
(
!
tabData
.
pinned
)
{
this
.
unpinTab
(
tab
)
;
}
else
{
this
.
pinTab
(
tab
)
;
}
}
if
(
!
tab
)
{
let
createLazyBrowser
=
restoreTabsLazily
&
&
!
select
&
&
!
tabData
.
pinned
;
let
url
=
"
about
:
blank
"
;
if
(
tabData
.
entries
?
.
length
)
{
let
activeIndex
=
(
tabData
.
index
|
|
tabData
.
entries
.
length
)
-
1
;
activeIndex
=
Math
.
min
(
activeIndex
tabData
.
entries
.
length
-
1
)
;
activeIndex
=
Math
.
max
(
activeIndex
0
)
;
url
=
tabData
.
entries
[
activeIndex
]
.
url
;
}
let
preferredRemoteType
=
E10SUtils
.
getRemoteTypeForURI
(
url
gMultiProcessBrowser
gFissionBrowser
E10SUtils
.
DEFAULT_REMOTE_TYPE
null
E10SUtils
.
predictOriginAttributes
(
{
window
userContextId
}
)
)
;
tab
=
this
.
addTrustedTab
(
createLazyBrowser
?
url
:
"
about
:
blank
"
{
createLazyBrowser
skipAnimation
:
true
allowInheritPrincipal
:
true
noInitialLabel
:
true
userContextId
skipBackgroundNotify
:
true
bulkOrderedOpen
:
true
batchInsertingTabs
:
true
skipLoad
:
!
createLazyBrowser
preferredRemoteType
}
)
;
if
(
select
)
{
tabToSelect
=
tab
;
}
}
tabs
.
push
(
tab
)
;
if
(
tabData
.
pinned
)
{
if
(
!
tab
.
parentNode
)
{
tab
.
_tPos
=
this
.
_numPinnedTabs
;
this
.
tabContainer
.
insertBefore
(
tab
this
.
tabs
[
this
.
_numPinnedTabs
]
)
;
tab
.
setAttribute
(
"
pinned
"
"
true
"
)
;
this
.
_invalidateCachedTabs
(
)
;
this
.
_fireTabOpen
(
tab
{
}
)
;
this
.
_notifyPinnedStatus
(
tab
)
;
shouldUpdateForPinnedTabs
=
true
;
}
}
else
{
if
(
tab
.
hidden
)
{
tab
.
hidden
=
true
;
hiddenTabs
.
set
(
tab
tabData
.
extData
&
&
tabData
.
extData
.
hiddenBy
)
;
}
tabsFragment
.
appendChild
(
tab
)
;
if
(
tabWasReused
)
{
this
.
_invalidateCachedTabs
(
)
;
}
}
tab
.
initialize
(
)
;
}
this
.
tabContainer
.
appendChild
(
tabsFragment
)
;
for
(
let
[
tab
hiddenBy
]
of
hiddenTabs
)
{
let
event
=
document
.
createEvent
(
"
Events
"
)
;
event
.
initEvent
(
"
TabHide
"
true
false
)
;
tab
.
dispatchEvent
(
event
)
;
if
(
hiddenBy
)
{
SessionStore
.
setCustomTabValue
(
tab
"
hiddenBy
"
hiddenBy
)
;
}
}
this
.
_invalidateCachedTabs
(
)
;
if
(
shouldUpdateForPinnedTabs
)
{
this
.
_updateTabBarForPinnedTabs
(
)
;
}
if
(
tabToSelect
)
{
let
leftoverTab
=
this
.
selectedTab
;
this
.
selectedTab
=
tabToSelect
;
this
.
removeTab
(
leftoverTab
)
;
}
if
(
tabs
.
length
>
1
|
|
!
tabs
[
0
]
.
selected
)
{
this
.
_updateTabsAfterInsert
(
)
;
this
.
tabContainer
.
_setPositionalAttributes
(
)
;
TabBarVisibility
.
update
(
)
;
for
(
let
tab
of
tabs
)
{
if
(
tabToSelect
|
|
!
tab
.
selected
)
{
if
(
!
tab
.
pinned
)
{
this
.
_fireTabOpen
(
tab
{
}
)
;
}
if
(
tab
.
linkedPanel
)
{
var
evt
=
new
CustomEvent
(
"
TabBrowserInserted
"
{
bubbles
:
true
detail
:
{
insertedOnTabCreation
:
true
}
}
)
;
tab
.
dispatchEvent
(
evt
)
;
}
}
}
}
return
tabs
;
}
moveTabsToStart
(
contextTab
)
{
let
tabs
=
contextTab
.
multiselected
?
this
.
selectedTabs
:
[
contextTab
]
;
for
(
let
i
=
tabs
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
let
tab
=
tabs
[
i
]
;
if
(
tab
.
_tPos
>
0
)
{
this
.
moveTabTo
(
tab
0
)
;
}
}
}
moveTabsToEnd
(
contextTab
)
{
let
tabs
=
contextTab
.
multiselected
?
this
.
selectedTabs
:
[
contextTab
]
;
for
(
let
tab
of
tabs
)
{
if
(
tab
.
_tPos
<
this
.
tabs
.
length
-
1
)
{
this
.
moveTabTo
(
tab
this
.
tabs
.
length
-
1
)
;
}
}
}
warnAboutClosingTabs
(
tabsToClose
aCloseTabs
aSource
)
{
if
(
tabsToClose
<
=
1
)
{
return
true
;
}
const
pref
=
aCloseTabs
=
=
this
.
closingTabsEnum
.
ALL
?
"
browser
.
tabs
.
warnOnClose
"
:
"
browser
.
tabs
.
warnOnCloseOtherTabs
"
;
var
shouldPrompt
=
Services
.
prefs
.
getBoolPref
(
pref
)
;
if
(
!
shouldPrompt
)
{
return
true
;
}
const
maxTabsUndo
=
Services
.
prefs
.
getIntPref
(
"
browser
.
sessionstore
.
max_tabs_undo
"
)
;
if
(
aCloseTabs
!
=
this
.
closingTabsEnum
.
ALL
&
&
tabsToClose
<
=
maxTabsUndo
)
{
return
true
;
}
gDialogBox
.
replaceDialogIfOpen
(
)
;
var
ps
=
Services
.
prompt
;
var
warnOnClose
=
{
value
:
true
}
;
window
.
focus
(
)
;
let
warningTitle
=
gTabBrowserBundle
.
GetStringFromName
(
"
tabs
.
closeTabsTitle
"
)
;
warningTitle
=
PluralForm
.
get
(
tabsToClose
warningTitle
)
.
replace
(
"
#
1
"
tabsToClose
)
;
let
flags
=
ps
.
BUTTON_TITLE_IS_STRING
*
ps
.
BUTTON_POS_0
+
ps
.
BUTTON_TITLE_CANCEL
*
ps
.
BUTTON_POS_1
;
let
checkboxLabel
=
aCloseTabs
=
=
this
.
closingTabsEnum
.
ALL
?
gTabBrowserBundle
.
GetStringFromName
(
"
tabs
.
closeTabsConfirmCheckbox
"
)
:
null
;
var
buttonPressed
=
ps
.
confirmEx
(
window
warningTitle
null
flags
gTabBrowserBundle
.
GetStringFromName
(
"
tabs
.
closeButtonMultiple
"
)
null
null
checkboxLabel
warnOnClose
)
;
Services
.
telemetry
.
setEventRecordingEnabled
(
"
close_tab_warning
"
true
)
;
let
closeTabEnumKey
=
Object
.
entries
(
this
.
closingTabsEnum
)
.
find
(
(
[
k
v
]
)
=
>
v
=
=
aCloseTabs
)
?
.
[
0
]
?
.
toLowerCase
(
)
|
|
"
some
"
;
let
warnCheckbox
=
warnOnClose
.
value
?
"
checked
"
:
"
unchecked
"
;
if
(
!
checkboxLabel
)
{
warnCheckbox
=
"
not
-
present
"
;
}
let
sessionWillBeRestored
=
Services
.
prefs
.
getIntPref
(
"
browser
.
startup
.
page
"
)
=
=
3
|
|
Services
.
prefs
.
getBoolPref
(
"
browser
.
sessionstore
.
resume_session_once
"
)
;
let
closesWindow
=
aCloseTabs
=
=
this
.
closingTabsEnum
.
ALL
;
Services
.
telemetry
.
recordEvent
(
"
close_tab_warning
"
"
shown
"
closesWindow
?
"
window
"
:
"
tabs
"
null
{
source
:
aSource
|
|
close
-
{
closeTabEnumKey
}
-
tabs
button
:
buttonPressed
=
=
0
?
"
close
"
:
"
cancel
"
warn_checkbox
:
warnCheckbox
closing_tabs
:
"
"
+
tabsToClose
closing_wins
:
"
"
+
+
closesWindow
will_restore
:
sessionWillBeRestored
?
"
yes
"
:
"
no
"
}
)
;
var
reallyClose
=
buttonPressed
=
=
0
;
if
(
aCloseTabs
=
=
this
.
closingTabsEnum
.
ALL
&
&
reallyClose
&
&
!
warnOnClose
.
value
)
{
Services
.
prefs
.
setBoolPref
(
pref
false
)
;
}
return
reallyClose
;
}
_insertTabAtIndex
(
tab
{
index
ownerTab
openerTab
pinned
bulkOrderedOpen
}
=
{
}
)
{
if
(
ownerTab
)
{
tab
.
owner
=
ownerTab
;
}
if
(
typeof
index
!
=
"
number
"
)
{
if
(
!
bulkOrderedOpen
&
&
(
(
openerTab
&
&
Services
.
prefs
.
getBoolPref
(
"
browser
.
tabs
.
insertRelatedAfterCurrent
"
)
)
|
|
Services
.
prefs
.
getBoolPref
(
"
browser
.
tabs
.
insertAfterCurrent
"
)
)
)
{
let
lastRelatedTab
=
openerTab
&
&
this
.
_lastRelatedTabMap
.
get
(
openerTab
)
;
let
previousTab
=
lastRelatedTab
|
|
openerTab
|
|
this
.
selectedTab
;
if
(
previousTab
.
multiselected
)
{
index
=
this
.
selectedTabs
[
this
.
selectedTabs
.
length
-
1
]
.
_tPos
+
1
;
}
else
{
index
=
previousTab
.
_tPos
+
1
;
}
if
(
lastRelatedTab
)
{
lastRelatedTab
.
owner
=
null
;
}
else
if
(
openerTab
)
{
tab
.
owner
=
openerTab
;
}
if
(
openerTab
)
{
this
.
_lastRelatedTabMap
.
set
(
openerTab
tab
)
;
}
}
else
{
index
=
Infinity
;
}
}
if
(
pinned
)
{
index
=
Math
.
max
(
index
0
)
;
index
=
Math
.
min
(
index
this
.
_numPinnedTabs
)
;
}
else
{
index
=
Math
.
max
(
index
this
.
_numPinnedTabs
)
;
index
=
Math
.
min
(
index
this
.
tabs
.
length
)
;
}
let
tabAfter
=
this
.
tabs
[
index
]
|
|
null
;
this
.
_invalidateCachedTabs
(
)
;
tab
.
initialize
(
)
;
this
.
tabContainer
.
insertBefore
(
tab
tabAfter
)
;
if
(
tabAfter
)
{
this
.
_updateTabsAfterInsert
(
)
;
}
else
{
tab
.
_tPos
=
index
;
}
if
(
pinned
)
{
this
.
_updateTabBarForPinnedTabs
(
)
;
}
this
.
tabContainer
.
_setPositionalAttributes
(
)
;
TabBarVisibility
.
update
(
)
;
}
_fireTabOpen
(
tab
eventDetail
)
{
delete
tab
.
initializingTab
;
let
evt
=
new
CustomEvent
(
"
TabOpen
"
{
bubbles
:
true
detail
:
eventDetail
|
|
{
}
}
)
;
tab
.
dispatchEvent
(
evt
)
;
}
getTabsToTheStartFrom
(
aTab
)
{
let
tabsToStart
=
[
]
;
let
tabs
=
this
.
visibleTabs
;
for
(
let
i
=
0
;
i
<
tabs
.
length
;
+
+
i
)
{
if
(
tabs
[
i
]
=
=
aTab
)
{
break
;
}
if
(
tabs
[
i
]
.
pinned
)
{
continue
;
}
if
(
aTab
.
multiselected
&
&
tabs
[
i
]
.
multiselected
)
{
continue
;
}
tabsToStart
.
push
(
tabs
[
i
]
)
;
}
return
tabsToStart
;
}
getTabsToTheEndFrom
(
aTab
)
{
let
tabsToEnd
=
[
]
;
let
tabs
=
this
.
visibleTabs
;
for
(
let
i
=
tabs
.
length
-
1
;
i
>
=
0
;
-
-
i
)
{
if
(
tabs
[
i
]
=
=
aTab
)
{
break
;
}
if
(
tabs
[
i
]
.
pinned
)
{
continue
;
}
if
(
aTab
.
multiselected
&
&
tabs
[
i
]
.
multiselected
)
{
continue
;
}
tabsToEnd
.
push
(
tabs
[
i
]
)
;
}
return
tabsToEnd
;
}
removeTabsToTheStartFrom
(
aTab
)
{
let
tabs
=
this
.
getTabsToTheStartFrom
(
aTab
)
;
if
(
!
this
.
warnAboutClosingTabs
(
tabs
.
length
this
.
closingTabsEnum
.
TO_START
)
)
{
return
;
}
this
.
removeTabs
(
tabs
)
;
}
removeTabsToTheEndFrom
(
aTab
)
{
let
tabs
=
this
.
getTabsToTheEndFrom
(
aTab
)
;
if
(
!
this
.
warnAboutClosingTabs
(
tabs
.
length
this
.
closingTabsEnum
.
TO_END
)
)
{
return
;
}
this
.
removeTabs
(
tabs
)
;
}
removeAllTabsBut
(
aTab
aParams
)
{
let
tabsToRemove
=
[
]
;
if
(
aTab
&
&
aTab
.
multiselected
)
{
tabsToRemove
=
this
.
visibleTabs
.
filter
(
tab
=
>
!
tab
.
multiselected
&
&
!
tab
.
pinned
)
;
}
else
{
tabsToRemove
=
this
.
visibleTabs
.
filter
(
tab
=
>
tab
!
=
aTab
&
&
!
tab
.
pinned
)
;
}
if
(
!
this
.
warnAboutClosingTabs
(
tabsToRemove
.
length
this
.
closingTabsEnum
.
OTHER
)
)
{
return
;
}
this
.
removeTabs
(
tabsToRemove
aParams
)
;
}
removeMultiSelectedTabs
(
)
{
let
selectedTabs
=
this
.
selectedTabs
;
if
(
!
this
.
warnAboutClosingTabs
(
selectedTabs
.
length
this
.
closingTabsEnum
.
MULTI_SELECTED
)
)
{
return
;
}
this
.
removeTabs
(
selectedTabs
)
;
}
_startRemoveTabs
(
tabs
{
animate
suppressWarnAboutClosingWindow
skipPermitUnload
skipRemoves
}
)
{
let
tabsWithBeforeUnloadPrompt
=
[
]
;
let
tabsWithoutBeforeUnload
=
[
]
;
let
beforeUnloadPromises
=
[
]
;
let
lastToClose
;
for
(
let
tab
of
tabs
)
{
if
(
!
skipRemoves
)
{
tab
.
_closedInGroup
=
true
;
}
if
(
!
skipRemoves
&
&
tab
.
selected
)
{
lastToClose
=
tab
;
let
toBlurTo
=
this
.
_findTabToBlurTo
(
lastToClose
tabs
)
;
if
(
toBlurTo
)
{
this
.
_getSwitcher
(
)
.
warmupTab
(
toBlurTo
)
;
}
}
else
if
(
!
skipPermitUnload
&
&
this
.
_hasBeforeUnload
(
tab
)
)
{
TelemetryStopwatch
.
start
(
"
FX_TAB_CLOSE_PERMIT_UNLOAD_TIME_MS
"
tab
)
;
tab
.
_pendingPermitUnload
=
true
;
beforeUnloadPromises
.
push
(
tab
.
linkedBrowser
.
asyncPermitUnload
(
"
dontUnload
"
)
.
then
(
(
{
permitUnload
}
)
=
>
{
tab
.
_pendingPermitUnload
=
false
;
TelemetryStopwatch
.
finish
(
"
FX_TAB_CLOSE_PERMIT_UNLOAD_TIME_MS
"
tab
)
;
if
(
tab
.
closing
)
{
}
else
if
(
permitUnload
)
{
if
(
!
skipRemoves
)
{
this
.
removeTab
(
tab
{
animate
prewarmed
:
true
skipPermitUnload
:
true
}
)
;
}
}
else
{
tabsWithBeforeUnloadPrompt
.
push
(
tab
)
;
}
}
err
=
>
{
console
.
error
(
"
error
while
calling
asyncPermitUnload
"
err
)
;
tab
.
_pendingPermitUnload
=
false
;
TelemetryStopwatch
.
finish
(
"
FX_TAB_CLOSE_PERMIT_UNLOAD_TIME_MS
"
tab
)
;
}
)
)
;
}
else
{
tabsWithoutBeforeUnload
.
push
(
tab
)
;
}
}
if
(
!
skipRemoves
)
{
for
(
let
tab
of
tabsWithoutBeforeUnload
)
{
this
.
removeTab
(
tab
{
animate
prewarmed
:
true
skipPermitUnload
}
)
;
}
}
return
{
beforeUnloadComplete
:
Promise
.
all
(
beforeUnloadPromises
)
tabsWithBeforeUnloadPrompt
lastToClose
}
;
}
async
runBeforeUnloadForTabs
(
tabs
)
{
try
{
let
{
beforeUnloadComplete
tabsWithBeforeUnloadPrompt
}
=
this
.
_startRemoveTabs
(
tabs
{
animate
:
false
suppressWarnAboutClosingWindow
:
false
skipPermitUnload
:
false
skipRemoves
:
true
}
)
;
await
beforeUnloadComplete
;
for
(
let
tab
of
tabsWithBeforeUnloadPrompt
)
{
tab
.
_pendingPermitUnload
=
true
;
let
{
permitUnload
}
=
this
.
getBrowserForTab
(
tab
)
.
permitUnload
(
)
;
tab
.
_pendingPermitUnload
=
false
;
if
(
!
permitUnload
)
{
return
true
;
}
}
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
return
false
;
}
removeTabs
(
tabs
{
animate
=
true
suppressWarnAboutClosingWindow
=
false
skipPermitUnload
=
false
}
=
{
}
)
{
if
(
this
.
tabs
.
length
=
=
tabs
.
length
&
&
Services
.
prefs
.
getBoolPref
(
"
browser
.
tabs
.
closeWindowWithLastTab
"
)
)
{
window
.
closeWindow
(
true
suppressWarnAboutClosingWindow
?
null
:
window
.
warnAboutClosingWindow
"
close
-
last
-
tab
"
)
;
return
;
}
SessionStore
.
resetLastClosedTabCount
(
window
)
;
this
.
_clearMultiSelectionLocked
=
true
;
try
{
let
{
beforeUnloadComplete
tabsWithBeforeUnloadPrompt
lastToClose
}
=
this
.
_startRemoveTabs
(
tabs
{
animate
suppressWarnAboutClosingWindow
skipPermitUnload
skipRemoves
:
false
}
)
;
let
done
=
false
;
beforeUnloadComplete
.
then
(
(
)
=
>
{
done
=
true
;
}
)
;
Services
.
tm
.
spinEventLoopUntilOrQuit
(
"
tabbrowser
.
js
:
removeTabs
"
(
)
=
>
done
|
|
window
.
closed
)
;
if
(
!
done
)
{
return
;
}
let
aParams
=
{
animate
prewarmed
:
true
skipPermitUnload
}
;
for
(
let
tab
of
tabsWithBeforeUnloadPrompt
)
{
this
.
removeTab
(
tab
aParams
)
;
if
(
!
tab
.
closing
)
{
tab
.
_closedInGroup
=
false
;
}
}
if
(
lastToClose
)
{
this
.
removeTab
(
lastToClose
aParams
)
;
}
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
this
.
_clearMultiSelectionLocked
=
false
;
this
.
avoidSingleSelectedTab
(
)
;
document
.
getElementById
(
"
History
:
UndoCloseTab
"
)
.
setAttribute
(
"
data
-
l10n
-
args
"
JSON
.
stringify
(
{
tabCount
:
SessionStore
.
getLastClosedTabCount
(
window
)
}
)
)
;
}
removeCurrentTab
(
aParams
)
{
this
.
removeTab
(
this
.
selectedTab
aParams
)
;
}
removeTab
(
aTab
{
animate
byMouse
skipPermitUnload
closeWindowWithLastTab
prewarmed
}
=
{
}
)
{
if
(
UserInteraction
.
running
(
"
browser
.
tabs
.
opening
"
window
)
)
{
UserInteraction
.
finish
(
"
browser
.
tabs
.
opening
"
window
)
;
}
if
(
!
TelemetryStopwatch
.
running
(
"
FX_TAB_CLOSE_TIME_ANIM_MS
"
aTab
)
&
&
!
TelemetryStopwatch
.
running
(
"
FX_TAB_CLOSE_TIME_NO_ANIM_MS
"
aTab
)
)
{
TelemetryStopwatch
.
start
(
"
FX_TAB_CLOSE_TIME_ANIM_MS
"
aTab
)
;
TelemetryStopwatch
.
start
(
"
FX_TAB_CLOSE_TIME_NO_ANIM_MS
"
aTab
)
;
}
if
(
!
animate
&
&
aTab
.
closing
)
{
this
.
_endRemoveTab
(
aTab
)
;
return
;
}
let
isLastTab
=
!
aTab
.
hidden
&
&
this
.
visibleTabs
.
length
=
=
1
;
let
windowUtils
=
window
.
windowUtils
;
let
tabWidth
=
windowUtils
.
getBoundsWithoutFlushing
(
aTab
)
.
width
;
if
(
!
this
.
_beginRemoveTab
(
aTab
{
closeWindowFastpath
:
true
skipPermitUnload
closeWindowWithLastTab
prewarmed
}
)
)
{
TelemetryStopwatch
.
cancel
(
"
FX_TAB_CLOSE_TIME_ANIM_MS
"
aTab
)
;
TelemetryStopwatch
.
cancel
(
"
FX_TAB_CLOSE_TIME_NO_ANIM_MS
"
aTab
)
;
return
;
}
if
(
!
aTab
.
pinned
&
&
!
aTab
.
hidden
&
&
aTab
.
_fullyOpen
&
&
byMouse
)
{
this
.
tabContainer
.
_lockTabSizing
(
aTab
tabWidth
)
;
}
else
{
this
.
tabContainer
.
_unlockTabSizing
(
)
;
}
if
(
!
animate
|
|
gReduceMotion
|
|
isLastTab
|
|
aTab
.
pinned
|
|
aTab
.
hidden
|
|
this
.
_removingTabs
.
length
>
3
|
|
aTab
.
getAttribute
(
"
fadein
"
)
!
=
"
true
"
|
|
window
.
getComputedStyle
(
aTab
)
.
maxWidth
=
=
"
0
.
1px
"
)
{
TelemetryStopwatch
.
cancel
(
"
FX_TAB_CLOSE_TIME_ANIM_MS
"
aTab
)
;
this
.
_endRemoveTab
(
aTab
)
;
return
;
}
TelemetryStopwatch
.
cancel
(
"
FX_TAB_CLOSE_TIME_NO_ANIM_MS
"
aTab
)
;
aTab
.
style
.
maxWidth
=
"
"
;
aTab
.
removeAttribute
(
"
fadein
"
)
;
aTab
.
removeAttribute
(
"
bursting
"
)
;
setTimeout
(
function
(
tab
tabbrowser
)
{
if
(
tab
.
container
&
&
window
.
getComputedStyle
(
tab
)
.
maxWidth
=
=
"
0
.
1px
"
)
{
console
.
assert
(
false
"
Giving
up
waiting
for
the
tab
closing
animation
to
finish
(
bug
608589
)
"
)
;
tabbrowser
.
_endRemoveTab
(
tab
)
;
}
}
3000
aTab
this
)
;
}
_hasBeforeUnload
(
aTab
)
{
let
browser
=
aTab
.
linkedBrowser
;
if
(
browser
.
isRemoteBrowser
&
&
browser
.
frameLoader
)
{
return
browser
.
hasBeforeUnload
;
}
return
false
;
}
_beginRemoveTab
(
aTab
{
adoptedByTab
closeWindowWithLastTab
closeWindowFastpath
skipPermitUnload
prewarmed
}
=
{
}
)
{
if
(
aTab
.
closing
|
|
this
.
_windowIsClosing
)
{
return
false
;
}
var
browser
=
this
.
getBrowserForTab
(
aTab
)
;
if
(
!
skipPermitUnload
&
&
!
adoptedByTab
&
&
aTab
.
linkedPanel
&
&
!
aTab
.
_pendingPermitUnload
&
&
(
!
browser
.
isRemoteBrowser
|
|
this
.
_hasBeforeUnload
(
aTab
)
)
)
{
if
(
!
prewarmed
)
{
let
blurTab
=
this
.
_findTabToBlurTo
(
aTab
)
;
if
(
blurTab
)
{
this
.
warmupTab
(
blurTab
)
;
}
}
TelemetryStopwatch
.
start
(
"
FX_TAB_CLOSE_PERMIT_UNLOAD_TIME_MS
"
aTab
)
;
aTab
.
_pendingPermitUnload
=
true
;
let
{
permitUnload
}
=
browser
.
permitUnload
(
)
;
aTab
.
_pendingPermitUnload
=
false
;
TelemetryStopwatch
.
finish
(
"
FX_TAB_CLOSE_PERMIT_UNLOAD_TIME_MS
"
aTab
)
;
if
(
aTab
.
closing
|
|
!
permitUnload
)
{
return
false
;
}
}
let
tabCacheIndex
=
this
.
_tabLayerCache
.
indexOf
(
aTab
)
;
if
(
tabCacheIndex
!
=
-
1
)
{
this
.
_tabLayerCache
.
splice
(
tabCacheIndex
1
)
;
}
let
screenShareInActiveTab
=
aTab
=
=
this
.
selectedTab
&
&
aTab
.
_sharingState
?
.
webRTC
?
.
screen
;
if
(
!
screenShareInActiveTab
)
{
this
.
_blurTab
(
aTab
)
;
}
var
closeWindow
=
false
;
var
newTab
=
false
;
if
(
!
aTab
.
hidden
&
&
this
.
visibleTabs
.
length
=
=
1
)
{
closeWindow
=
closeWindowWithLastTab
!
=
null
?
closeWindowWithLastTab
:
!
window
.
toolbar
.
visible
|
|
Services
.
prefs
.
getBoolPref
(
"
browser
.
tabs
.
closeWindowWithLastTab
"
)
;
if
(
closeWindow
)
{
window
.
skipNextCanClose
=
true
;
}
if
(
closeWindow
&
&
closeWindowFastpath
&
&
!
this
.
_removingTabs
.
length
)
{
this
.
_windowIsClosing
=
window
.
closeWindow
(
true
window
.
warnAboutClosingWindow
"
close
-
last
-
tab
"
)
;
return
false
;
}
newTab
=
true
;
}
aTab
.
_endRemoveArgs
=
[
closeWindow
newTab
]
;
if
(
closeWindow
&
&
adoptedByTab
)
{
if
(
aTab
.
linkedPanel
)
{
const
filter
=
this
.
_tabFilters
.
get
(
aTab
)
;
browser
.
webProgress
.
removeProgressListener
(
filter
)
;
const
listener
=
this
.
_tabListeners
.
get
(
aTab
)
;
filter
.
removeProgressListener
(
listener
)
;
listener
.
destroy
(
)
;
this
.
_tabListeners
.
delete
(
aTab
)
;
this
.
_tabFilters
.
delete
(
aTab
)
;
}
return
true
;
}
if
(
!
aTab
.
_fullyOpen
)
{
this
.
tabAnimationsInProgress
-
-
;
}
this
.
tabAnimationsInProgress
+
+
;
if
(
!
adoptedByTab
&
&
aTab
.
hasAttribute
(
"
soundplaying
"
)
)
{
aTab
.
linkedBrowser
.
mute
(
true
)
;
}
aTab
.
closing
=
true
;
this
.
_removingTabs
.
push
(
aTab
)
;
this
.
_invalidateCachedTabs
(
)
;
if
(
this
.
tabContainer
.
_hoveredTab
=
=
aTab
)
{
aTab
.
_mouseleave
(
)
;
}
if
(
newTab
)
{
this
.
addTrustedTab
(
BROWSER_NEW_TAB_URL
{
skipAnimation
:
true
}
)
;
}
else
{
TabBarVisibility
.
update
(
)
;
}
this
.
replaceInSuccession
(
aTab
aTab
.
successor
)
;
this
.
setSuccessor
(
aTab
null
)
;
let
evt
=
new
CustomEvent
(
"
TabClose
"
{
bubbles
:
true
detail
:
{
adoptedBy
:
adoptedByTab
}
}
)
;
aTab
.
dispatchEvent
(
evt
)
;
if
(
this
.
tabs
.
length
=
=
2
)
{
this
.
tabs
[
0
]
.
linkedBrowser
.
sendMessageToActor
(
"
Browser
:
HasSiblings
"
false
"
BrowserTab
"
)
;
this
.
tabs
[
1
]
.
linkedBrowser
.
sendMessageToActor
(
"
Browser
:
HasSiblings
"
false
"
BrowserTab
"
)
;
}
let
notificationBox
=
this
.
readNotificationBox
(
browser
)
;
notificationBox
?
.
_stack
?
.
remove
(
)
;
if
(
aTab
.
linkedPanel
)
{
if
(
!
adoptedByTab
&
&
!
gMultiProcessBrowser
)
{
browser
.
contentWindow
.
windowUtils
.
disableDialogs
(
)
;
}
const
filter
=
this
.
_tabFilters
.
get
(
aTab
)
;
browser
.
webProgress
.
removeProgressListener
(
filter
)
;
const
listener
=
this
.
_tabListeners
.
get
(
aTab
)
;
filter
.
removeProgressListener
(
listener
)
;
listener
.
destroy
(
)
;
}
if
(
browser
.
registeredOpenURI
&
&
!
adoptedByTab
)
{
let
userContextId
=
browser
.
getAttribute
(
"
usercontextid
"
)
|
|
0
;
this
.
UrlbarProviderOpenTabs
.
unregisterOpenTab
(
browser
.
registeredOpenURI
.
spec
userContextId
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
;
delete
browser
.
registeredOpenURI
;
}
browser
.
removeAttribute
(
"
primary
"
)
;
for
(
let
tab
of
this
.
tabs
)
{
if
(
"
owner
"
in
tab
&
&
tab
.
owner
=
=
aTab
)
{
tab
.
owner
=
null
;
}
}
return
true
;
}
_endRemoveTab
(
aTab
)
{
if
(
!
aTab
|
|
!
aTab
.
_endRemoveArgs
)
{
return
;
}
var
[
aCloseWindow
aNewTab
]
=
aTab
.
_endRemoveArgs
;
aTab
.
_endRemoveArgs
=
null
;
if
(
this
.
_windowIsClosing
)
{
aCloseWindow
=
false
;
aNewTab
=
false
;
}
this
.
tabAnimationsInProgress
-
-
;
this
.
_lastRelatedTabMap
=
new
WeakMap
(
)
;
aTab
.
collapsed
=
true
;
this
.
_blurTab
(
aTab
)
;
this
.
_removingTabs
.
splice
(
this
.
_removingTabs
.
indexOf
(
aTab
)
1
)
;
if
(
aCloseWindow
)
{
this
.
_windowIsClosing
=
true
;
while
(
this
.
_removingTabs
.
length
)
{
this
.
_endRemoveTab
(
this
.
_removingTabs
[
0
]
)
;
}
}
else
if
(
!
this
.
_windowIsClosing
)
{
if
(
aNewTab
)
{
gURLBar
.
select
(
)
;
}
this
.
tabContainer
.
arrowScrollbox
.
_updateScrollButtonsDisabledState
(
)
;
}
this
.
_tabFilters
.
delete
(
aTab
)
;
this
.
_tabListeners
.
delete
(
aTab
)
;
var
browser
=
this
.
getBrowserForTab
(
aTab
)
;
if
(
aTab
.
linkedPanel
)
{
browser
.
destroy
(
)
;
}
var
wasPinned
=
aTab
.
pinned
;
aTab
.
remove
(
)
;
this
.
_invalidateCachedTabs
(
)
;
if
(
aTab
.
hidden
)
{
this
.
tabContainer
.
_updateHiddenTabsStatus
(
)
;
}
for
(
let
i
=
aTab
.
_tPos
;
i
<
this
.
tabs
.
length
;
i
+
+
)
{
this
.
tabs
[
i
]
.
_tPos
=
i
;
}
if
(
!
this
.
_windowIsClosing
)
{
if
(
wasPinned
)
{
this
.
tabContainer
.
_positionPinnedTabs
(
)
;
}
this
.
tabContainer
.
_updateCloseButtons
(
)
;
setTimeout
(
function
(
tabs
)
{
tabs
.
_lastTabClosedByMouse
=
false
;
}
0
this
.
tabContainer
)
;
}
this
.
selectedTab
.
_selected
=
true
;
this
.
tabContainer
.
_setPositionalAttributes
(
)
;
var
panel
=
this
.
getPanel
(
browser
)
;
if
(
this
.
_switcher
)
{
this
.
_switcher
.
onTabRemoved
(
aTab
)
;
}
browser
.
remove
(
)
;
this
.
_tabForBrowser
.
delete
(
aTab
.
linkedBrowser
)
;
aTab
.
linkedBrowser
=
null
;
panel
.
remove
(
)
;
TelemetryStopwatch
.
finish
(
"
FX_TAB_CLOSE_TIME_ANIM_MS
"
aTab
true
)
;
TelemetryStopwatch
.
finish
(
"
FX_TAB_CLOSE_TIME_NO_ANIM_MS
"
aTab
true
)
;
if
(
aCloseWindow
)
{
this
.
_windowIsClosing
=
closeWindow
(
true
window
.
warnAboutClosingWindow
"
close
-
last
-
tab
"
)
;
}
}
_findTabToBlurTo
(
aTab
aExcludeTabs
=
[
]
)
{
if
(
!
aTab
.
selected
)
{
return
null
;
}
let
excludeTabs
=
new
Set
(
aExcludeTabs
)
;
if
(
aTab
.
successor
&
&
!
excludeTabs
.
has
(
aTab
.
successor
)
)
{
return
aTab
.
successor
;
}
if
(
aTab
.
owner
&
&
!
aTab
.
owner
.
hidden
&
&
!
aTab
.
owner
.
closing
&
&
!
excludeTabs
.
has
(
aTab
.
owner
)
&
&
Services
.
prefs
.
getBoolPref
(
"
browser
.
tabs
.
selectOwnerOnClose
"
)
)
{
return
aTab
.
owner
;
}
let
remainingTabs
=
this
.
visibleTabs
;
let
numTabs
=
remainingTabs
.
length
;
if
(
numTabs
=
=
0
|
|
(
numTabs
=
=
1
&
&
remainingTabs
[
0
]
=
=
aTab
)
)
{
remainingTabs
=
Array
.
prototype
.
filter
.
call
(
this
.
tabs
tab
=
>
!
tab
.
closing
&
&
!
excludeTabs
.
has
(
tab
)
)
;
}
let
tab
=
this
.
tabContainer
.
findNextTab
(
aTab
{
direction
:
1
filter
:
_tab
=
>
remainingTabs
.
includes
(
_tab
)
}
)
;
if
(
!
tab
)
{
tab
=
this
.
tabContainer
.
findNextTab
(
aTab
{
direction
:
-
1
filter
:
_tab
=
>
remainingTabs
.
includes
(
_tab
)
}
)
;
}
return
tab
;
}
_blurTab
(
aTab
)
{
this
.
selectedTab
=
this
.
_findTabToBlurTo
(
aTab
)
;
}
swapBrowsersAndCloseOther
(
aOurTab
aOtherTab
)
{
if
(
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
!
=
PrivateBrowsingUtils
.
isWindowPrivate
(
aOtherTab
.
ownerGlobal
)
)
{
return
false
;
}
if
(
gFissionBrowser
!
=
aOtherTab
.
ownerGlobal
.
gFissionBrowser
)
{
return
false
;
}
let
ourBrowser
=
this
.
getBrowserForTab
(
aOurTab
)
;
let
otherBrowser
=
aOtherTab
.
linkedBrowser
;
if
(
ourBrowser
.
isRemoteBrowser
!
=
otherBrowser
.
isRemoteBrowser
)
{
return
false
;
}
if
(
otherBrowser
.
hasAttribute
(
"
usercontextid
"
)
)
{
ourBrowser
.
setAttribute
(
"
usercontextid
"
otherBrowser
.
getAttribute
(
"
usercontextid
"
)
)
;
}
var
remoteBrowser
=
aOtherTab
.
ownerGlobal
.
gBrowser
;
var
isPending
=
aOtherTab
.
hasAttribute
(
"
pending
"
)
;
let
otherTabListener
=
remoteBrowser
.
_tabListeners
.
get
(
aOtherTab
)
;
let
stateFlags
=
0
;
if
(
otherTabListener
)
{
stateFlags
=
otherTabListener
.
mStateFlags
;
}
if
(
aOtherTab
.
_soundPlayingAttrRemovalTimer
)
{
clearTimeout
(
aOtherTab
.
_soundPlayingAttrRemovalTimer
)
;
aOtherTab
.
_soundPlayingAttrRemovalTimer
=
0
;
aOtherTab
.
removeAttribute
(
"
soundplaying
"
)
;
remoteBrowser
.
_tabAttrModified
(
aOtherTab
[
"
soundplaying
"
]
)
;
}
if
(
!
remoteBrowser
.
_beginRemoveTab
(
aOtherTab
{
adoptedByTab
:
aOurTab
closeWindowWithLastTab
:
true
}
)
)
{
return
false
;
}
let
[
closeWindow
]
=
aOtherTab
.
_endRemoveArgs
;
if
(
closeWindow
)
{
let
win
=
aOtherTab
.
ownerGlobal
;
win
.
windowUtils
.
suppressAnimation
(
true
)
;
let
baseWin
=
win
.
docShell
.
treeOwner
.
QueryInterface
(
Ci
.
nsIBaseWindow
)
;
baseWin
.
visibility
=
false
;
}
let
modifiedAttrs
=
[
]
;
if
(
aOtherTab
.
hasAttribute
(
"
muted
"
)
)
{
aOurTab
.
setAttribute
(
"
muted
"
"
true
"
)
;
aOurTab
.
muteReason
=
aOtherTab
.
muteReason
;
if
(
aOurTab
.
linkedPanel
)
{
ourBrowser
.
mute
(
)
;
}
modifiedAttrs
.
push
(
"
muted
"
)
;
}
if
(
aOtherTab
.
hasAttribute
(
"
soundplaying
"
)
)
{
aOurTab
.
setAttribute
(
"
soundplaying
"
"
true
"
)
;
modifiedAttrs
.
push
(
"
soundplaying
"
)
;
}
if
(
aOtherTab
.
hasAttribute
(
"
usercontextid
"
)
)
{
aOurTab
.
setUserContextId
(
aOtherTab
.
getAttribute
(
"
usercontextid
"
)
)
;
modifiedAttrs
.
push
(
"
usercontextid
"
)
;
}
if
(
aOtherTab
.
hasAttribute
(
"
sharing
"
)
)
{
aOurTab
.
setAttribute
(
"
sharing
"
aOtherTab
.
getAttribute
(
"
sharing
"
)
)
;
modifiedAttrs
.
push
(
"
sharing
"
)
;
aOurTab
.
_sharingState
=
aOtherTab
.
_sharingState
;
webrtcUI
.
swapBrowserForNotification
(
otherBrowser
ourBrowser
)
;
}
if
(
aOtherTab
.
hasAttribute
(
"
pictureinpicture
"
)
)
{
aOurTab
.
setAttribute
(
"
pictureinpicture
"
true
)
;
modifiedAttrs
.
push
(
"
pictureinpicture
"
)
;
let
event
=
new
CustomEvent
(
"
TabSwapPictureInPicture
"
{
detail
:
aOurTab
}
)
;
aOtherTab
.
dispatchEvent
(
event
)
;
}
SitePermissions
.
copyTemporaryPermissions
(
otherBrowser
ourBrowser
)
;
if
(
isPending
)
{
aOurTab
.
initializingTab
=
true
;
delete
ourBrowser
.
_cachedCurrentURI
;
SessionStore
.
setTabState
(
aOurTab
SessionStore
.
getTabState
(
aOtherTab
)
)
;
delete
aOurTab
.
initializingTab
;
this
.
_swapRegisteredOpenURIs
(
ourBrowser
otherBrowser
)
;
}
else
{
if
(
!
ourBrowser
.
mIconURL
&
&
otherBrowser
.
mIconURL
)
{
this
.
setIcon
(
aOurTab
otherBrowser
.
mIconURL
)
;
}
var
isBusy
=
aOtherTab
.
hasAttribute
(
"
busy
"
)
;
if
(
isBusy
)
{
aOurTab
.
setAttribute
(
"
busy
"
"
true
"
)
;
modifiedAttrs
.
push
(
"
busy
"
)
;
if
(
aOurTab
.
selected
)
{
this
.
_isBusy
=
true
;
}
}
this
.
_swapBrowserDocShells
(
aOurTab
otherBrowser
stateFlags
)
;
}
if
(
otherBrowser
.
registeredOpenURI
)
{
let
userContextId
=
otherBrowser
.
getAttribute
(
"
usercontextid
"
)
|
|
0
;
this
.
UrlbarProviderOpenTabs
.
unregisterOpenTab
(
otherBrowser
.
registeredOpenURI
.
spec
userContextId
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
;
delete
otherBrowser
.
registeredOpenURI
;
}
let
otherFindBar
=
aOtherTab
.
_findBar
;
if
(
otherFindBar
&
&
otherFindBar
.
findMode
=
=
otherFindBar
.
FIND_NORMAL
)
{
let
oldValue
=
otherFindBar
.
_findField
.
value
;
let
wasHidden
=
otherFindBar
.
hidden
;
let
ourFindBarPromise
=
this
.
getFindBar
(
aOurTab
)
;
ourFindBarPromise
.
then
(
ourFindBar
=
>
{
if
(
!
ourFindBar
)
{
return
;
}
ourFindBar
.
_findField
.
value
=
oldValue
;
if
(
!
wasHidden
)
{
ourFindBar
.
onFindCommand
(
)
;
}
}
)
;
}
if
(
closeWindow
)
{
aOtherTab
.
ownerGlobal
.
close
(
)
;
}
else
{
remoteBrowser
.
_endRemoveTab
(
aOtherTab
)
;
}
this
.
setTabTitle
(
aOurTab
)
;
if
(
aOurTab
.
selected
)
{
this
.
updateCurrentBrowser
(
true
)
;
}
if
(
modifiedAttrs
.
length
)
{
this
.
_tabAttrModified
(
aOurTab
modifiedAttrs
)
;
}
return
true
;
}
swapBrowsers
(
aOurTab
aOtherTab
)
{
let
otherBrowser
=
aOtherTab
.
linkedBrowser
;
let
otherTabBrowser
=
otherBrowser
.
getTabBrowser
(
)
;
let
filter
=
otherTabBrowser
.
_tabFilters
.
get
(
aOtherTab
)
;
let
tabListener
=
otherTabBrowser
.
_tabListeners
.
get
(
aOtherTab
)
;
otherBrowser
.
webProgress
.
removeProgressListener
(
filter
)
;
filter
.
removeProgressListener
(
tabListener
)
;
this
.
_swapBrowserDocShells
(
aOurTab
otherBrowser
)
;
tabListener
=
new
otherTabBrowser
.
ownerGlobal
.
TabProgressListener
(
aOtherTab
otherBrowser
false
false
)
;
otherTabBrowser
.
_tabListeners
.
set
(
aOtherTab
tabListener
)
;
const
notifyAll
=
Ci
.
nsIWebProgress
.
NOTIFY_ALL
;
filter
.
addProgressListener
(
tabListener
notifyAll
)
;
otherBrowser
.
webProgress
.
addProgressListener
(
filter
notifyAll
)
;
}
_swapBrowserDocShells
(
aOurTab
aOtherBrowser
aStateFlags
)
{
this
.
_insertBrowser
(
aOurTab
)
;
const
filter
=
this
.
_tabFilters
.
get
(
aOurTab
)
;
let
tabListener
=
this
.
_tabListeners
.
get
(
aOurTab
)
;
let
ourBrowser
=
this
.
getBrowserForTab
(
aOurTab
)
;
ourBrowser
.
webProgress
.
removeProgressListener
(
filter
)
;
filter
.
removeProgressListener
(
tabListener
)
;
this
.
_swapRegisteredOpenURIs
(
ourBrowser
aOtherBrowser
)
;
let
remoteBrowser
=
aOtherBrowser
.
ownerGlobal
.
gBrowser
;
if
(
!
this
.
_switcher
)
{
aOtherBrowser
.
docShellIsActive
=
this
.
shouldActivateDocShell
(
ourBrowser
)
;
}
ourBrowser
.
swapDocShells
(
aOtherBrowser
)
;
let
ourPermanentKey
=
ourBrowser
.
permanentKey
;
ourBrowser
.
permanentKey
=
aOtherBrowser
.
permanentKey
;
aOtherBrowser
.
permanentKey
=
ourPermanentKey
;
aOurTab
.
permanentKey
=
ourBrowser
.
permanentKey
;
if
(
remoteBrowser
)
{
let
otherTab
=
remoteBrowser
.
getTabForBrowser
(
aOtherBrowser
)
;
if
(
otherTab
)
{
otherTab
.
permanentKey
=
aOtherBrowser
.
permanentKey
;
}
}
tabListener
=
new
TabProgressListener
(
aOurTab
ourBrowser
false
false
aStateFlags
)
;
this
.
_tabListeners
.
set
(
aOurTab
tabListener
)
;
const
notifyAll
=
Ci
.
nsIWebProgress
.
NOTIFY_ALL
;
filter
.
addProgressListener
(
tabListener
notifyAll
)
;
ourBrowser
.
webProgress
.
addProgressListener
(
filter
notifyAll
)
;
}
_swapRegisteredOpenURIs
(
aOurBrowser
aOtherBrowser
)
{
let
tmp
=
aOurBrowser
.
registeredOpenURI
;
delete
aOurBrowser
.
registeredOpenURI
;
if
(
aOtherBrowser
.
registeredOpenURI
)
{
aOurBrowser
.
registeredOpenURI
=
aOtherBrowser
.
registeredOpenURI
;
delete
aOtherBrowser
.
registeredOpenURI
;
}
if
(
tmp
)
{
aOtherBrowser
.
registeredOpenURI
=
tmp
;
}
}
announceWindowCreated
(
browser
userContextId
)
{
let
tab
=
this
.
getTabForBrowser
(
browser
)
;
if
(
tab
)
{
if
(
userContextId
)
{
ContextualIdentityService
.
telemetry
(
userContextId
)
;
tab
.
setUserContextId
(
userContextId
)
;
}
browser
.
sendMessageToActor
(
"
Browser
:
AppTab
"
{
isAppTab
:
tab
.
pinned
}
"
BrowserTab
"
)
;
}
if
(
browser
=
=
gBrowser
.
selectedBrowser
)
{
updateUserContextUIIndicator
(
)
;
}
}
reloadMultiSelectedTabs
(
)
{
this
.
reloadTabs
(
this
.
selectedTabs
)
;
}
reloadTabs
(
tabs
)
{
for
(
let
tab
of
tabs
)
{
try
{
this
.
getBrowserForTab
(
tab
)
.
reload
(
)
;
}
catch
(
e
)
{
}
}
}
reloadTab
(
aTab
)
{
let
browser
=
this
.
getBrowserForTab
(
aTab
)
;
SitePermissions
.
clearTemporaryBlockPermissions
(
browser
)
;
delete
browser
.
authPromptAbuseCounter
;
gIdentityHandler
.
hidePopup
(
)
;
gPermissionPanel
.
hidePopup
(
)
;
browser
.
reload
(
)
;
}
addProgressListener
(
aListener
)
{
if
(
arguments
.
length
!
=
1
)
{
Cu
.
reportError
(
"
gBrowser
.
addProgressListener
was
"
+
"
called
with
a
second
argument
"
+
"
which
is
not
supported
.
See
bug
"
+
"
608628
.
Call
stack
:
"
+
new
Error
(
)
.
stack
)
;
}
this
.
mProgressListeners
.
push
(
aListener
)
;
}
removeProgressListener
(
aListener
)
{
this
.
mProgressListeners
=
this
.
mProgressListeners
.
filter
(
l
=
>
l
!
=
aListener
)
;
}
addTabsProgressListener
(
aListener
)
{
this
.
mTabsProgressListeners
.
push
(
aListener
)
;
}
removeTabsProgressListener
(
aListener
)
{
this
.
mTabsProgressListeners
=
this
.
mTabsProgressListeners
.
filter
(
l
=
>
l
!
=
aListener
)
;
}
getBrowserForTab
(
aTab
)
{
return
aTab
.
linkedBrowser
;
}
showOnlyTheseTabs
(
aTabs
)
{
for
(
let
tab
of
this
.
tabs
)
{
if
(
!
aTabs
.
includes
(
tab
)
)
{
this
.
hideTab
(
tab
)
;
}
else
{
this
.
showTab
(
tab
)
;
}
}
this
.
tabContainer
.
_updateHiddenTabsStatus
(
)
;
this
.
tabContainer
.
_handleTabSelect
(
true
)
;
}
showTab
(
aTab
)
{
if
(
aTab
.
hidden
)
{
aTab
.
removeAttribute
(
"
hidden
"
)
;
this
.
_invalidateCachedTabs
(
)
;
this
.
tabContainer
.
_updateCloseButtons
(
)
;
this
.
tabContainer
.
_updateHiddenTabsStatus
(
)
;
this
.
tabContainer
.
_setPositionalAttributes
(
)
;
let
event
=
document
.
createEvent
(
"
Events
"
)
;
event
.
initEvent
(
"
TabShow
"
true
false
)
;
aTab
.
dispatchEvent
(
event
)
;
SessionStore
.
deleteCustomTabValue
(
aTab
"
hiddenBy
"
)
;
}
}
hideTab
(
aTab
aSource
)
{
if
(
aTab
.
hidden
|
|
aTab
.
pinned
|
|
aTab
.
selected
|
|
aTab
.
closing
|
|
aTab
.
_sharingState
?
.
webRTC
?
.
sharing
)
{
return
;
}
aTab
.
setAttribute
(
"
hidden
"
"
true
"
)
;
this
.
_invalidateCachedTabs
(
)
;
this
.
tabContainer
.
_updateCloseButtons
(
)
;
this
.
tabContainer
.
_updateHiddenTabsStatus
(
)
;
this
.
tabContainer
.
_setPositionalAttributes
(
)
;
this
.
replaceInSuccession
(
aTab
aTab
.
successor
)
;
this
.
setSuccessor
(
aTab
null
)
;
let
event
=
document
.
createEvent
(
"
Events
"
)
;
event
.
initEvent
(
"
TabHide
"
true
false
)
;
aTab
.
dispatchEvent
(
event
)
;
if
(
aSource
)
{
SessionStore
.
setCustomTabValue
(
aTab
"
hiddenBy
"
aSource
)
;
}
}
selectTabAtIndex
(
aIndex
aEvent
)
{
let
tabs
=
this
.
visibleTabs
;
if
(
aIndex
<
0
)
{
aIndex
+
=
tabs
.
length
;
if
(
aIndex
<
0
)
{
aIndex
=
0
;
}
}
else
if
(
aIndex
>
=
tabs
.
length
)
{
aIndex
=
tabs
.
length
-
1
;
}
this
.
selectedTab
=
tabs
[
aIndex
]
;
if
(
aEvent
)
{
aEvent
.
preventDefault
(
)
;
aEvent
.
stopPropagation
(
)
;
}
}
replaceTabWithWindow
(
aTab
aOptions
)
{
if
(
this
.
tabs
.
length
=
=
1
)
{
return
null
;
}
var
options
=
"
chrome
dialog
=
no
all
"
;
for
(
var
name
in
aOptions
)
{
options
+
=
"
"
+
name
+
"
=
"
+
aOptions
[
name
]
;
}
if
(
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
{
options
+
=
"
private
=
1
"
;
}
if
(
!
gReduceMotion
)
{
aTab
.
style
.
maxWidth
=
"
"
;
aTab
.
removeAttribute
(
"
fadein
"
)
;
}
return
window
.
openDialog
(
AppConstants
.
BROWSER_CHROME_URL
"
_blank
"
options
aTab
)
;
}
replaceTabsWithWindow
(
contextTab
aOptions
=
{
}
)
{
let
tabs
;
if
(
contextTab
.
multiselected
)
{
tabs
=
this
.
selectedTabs
;
}
else
{
tabs
=
[
contextTab
]
;
}
if
(
this
.
tabs
.
length
=
=
tabs
.
length
)
{
return
null
;
}
if
(
tabs
.
length
=
=
1
)
{
return
this
.
replaceTabWithWindow
(
tabs
[
0
]
aOptions
)
;
}
if
(
!
gReduceMotion
)
{
for
(
let
tab
of
tabs
)
{
tab
.
style
.
maxWidth
=
"
"
;
tab
.
removeAttribute
(
"
fadein
"
)
;
}
}
let
{
selectedTab
}
=
gBrowser
;
if
(
!
tabs
.
includes
(
selectedTab
)
)
{
selectedTab
=
tabs
[
0
]
;
}
let
win
=
this
.
replaceTabWithWindow
(
selectedTab
aOptions
)
;
win
.
addEventListener
(
"
before
-
initial
-
tab
-
adopted
"
(
)
=
>
{
let
index
=
0
;
for
(
let
tab
of
tabs
)
{
if
(
tab
!
=
=
selectedTab
)
{
const
newTab
=
win
.
gBrowser
.
adoptTab
(
tab
index
)
;
if
(
!
newTab
)
{
tab
.
setAttribute
(
"
fadein
"
"
true
"
)
;
continue
;
}
}
+
+
index
;
}
let
winVisibleTabs
=
win
.
gBrowser
.
visibleTabs
;
let
winTabLength
=
winVisibleTabs
.
length
;
win
.
gBrowser
.
addRangeToMultiSelectedTabs
(
winVisibleTabs
[
0
]
winVisibleTabs
[
winTabLength
-
1
]
)
;
win
.
gBrowser
.
lockClearMultiSelectionOnce
(
)
;
}
{
once
:
true
}
)
;
return
win
;
}
_updateTabsAfterInsert
(
)
{
for
(
let
i
=
0
;
i
<
this
.
tabs
.
length
;
i
+
+
)
{
this
.
tabs
[
i
]
.
_tPos
=
i
;
this
.
tabs
[
i
]
.
_selected
=
false
;
}
this
.
selectedTab
.
_selected
=
true
;
}
moveTabTo
(
aTab
aIndex
aKeepRelatedTabs
)
{
var
oldPosition
=
aTab
.
_tPos
;
if
(
oldPosition
=
=
aIndex
)
{
return
;
}
if
(
aTab
.
pinned
)
{
aIndex
=
Math
.
min
(
aIndex
this
.
_numPinnedTabs
-
1
)
;
}
else
{
aIndex
=
Math
.
max
(
aIndex
this
.
_numPinnedTabs
)
;
}
if
(
oldPosition
=
=
aIndex
)
{
return
;
}
if
(
!
aKeepRelatedTabs
)
{
this
.
_lastRelatedTabMap
=
new
WeakMap
(
)
;
}
let
wasFocused
=
document
.
activeElement
=
=
this
.
selectedTab
;
aIndex
=
aIndex
<
aTab
.
_tPos
?
aIndex
:
aIndex
+
1
;
let
neighbor
=
this
.
tabs
[
aIndex
]
|
|
null
;
this
.
_invalidateCachedTabs
(
)
;
this
.
tabContainer
.
insertBefore
(
aTab
neighbor
)
;
this
.
_updateTabsAfterInsert
(
)
;
if
(
wasFocused
)
{
this
.
selectedTab
.
focus
(
)
;
}
this
.
tabContainer
.
_handleTabSelect
(
true
)
;
if
(
aTab
.
pinned
)
{
this
.
tabContainer
.
_positionPinnedTabs
(
)
;
}
this
.
tabContainer
.
_setPositionalAttributes
(
)
;
var
evt
=
document
.
createEvent
(
"
UIEvents
"
)
;
evt
.
initUIEvent
(
"
TabMove
"
true
false
window
oldPosition
)
;
aTab
.
dispatchEvent
(
evt
)
;
}
moveTabForward
(
)
{
let
nextTab
=
this
.
tabContainer
.
findNextTab
(
this
.
selectedTab
{
direction
:
1
filter
:
tab
=
>
!
tab
.
hidden
}
)
;
if
(
nextTab
)
{
this
.
moveTabTo
(
this
.
selectedTab
nextTab
.
_tPos
)
;
}
else
if
(
this
.
arrowKeysShouldWrap
)
{
this
.
moveTabToStart
(
)
;
}
}
adoptTab
(
aTab
aIndex
aSelectTab
)
{
let
linkedBrowser
=
aTab
.
linkedBrowser
;
let
createLazyBrowser
=
!
aTab
.
linkedPanel
;
let
params
=
{
eventDetail
:
{
adoptedTab
:
aTab
}
preferredRemoteType
:
linkedBrowser
.
remoteType
initialBrowsingContextGroupId
:
linkedBrowser
.
browsingContext
?
.
group
.
id
skipAnimation
:
true
index
:
aIndex
createLazyBrowser
allowInheritPrincipal
:
createLazyBrowser
}
;
let
numPinned
=
this
.
_numPinnedTabs
;
if
(
aIndex
<
numPinned
|
|
(
aTab
.
pinned
&
&
aIndex
=
=
numPinned
)
)
{
params
.
pinned
=
true
;
}
if
(
aTab
.
hasAttribute
(
"
usercontextid
"
)
)
{
params
.
userContextId
=
aTab
.
getAttribute
(
"
usercontextid
"
)
;
}
let
newTab
=
this
.
addWebTab
(
"
about
:
blank
"
params
)
;
let
newBrowser
=
this
.
getBrowserForTab
(
newTab
)
;
aTab
.
container
.
_finishAnimateTabMove
(
)
;
if
(
!
createLazyBrowser
)
{
newBrowser
.
stop
(
)
;
newBrowser
.
docShell
;
}
if
(
!
this
.
swapBrowsersAndCloseOther
(
newTab
aTab
)
)
{
this
.
removeTab
(
newTab
)
;
return
null
;
}
if
(
aSelectTab
)
{
this
.
selectedTab
=
newTab
;
}
return
newTab
;
}
moveTabBackward
(
)
{
let
previousTab
=
this
.
tabContainer
.
findNextTab
(
this
.
selectedTab
{
direction
:
-
1
filter
:
tab
=
>
!
tab
.
hidden
}
)
;
if
(
previousTab
)
{
this
.
moveTabTo
(
this
.
selectedTab
previousTab
.
_tPos
)
;
}
else
if
(
this
.
arrowKeysShouldWrap
)
{
this
.
moveTabToEnd
(
)
;
}
}
moveTabToStart
(
)
{
let
tabPos
=
this
.
selectedTab
.
_tPos
;
if
(
tabPos
>
0
)
{
this
.
moveTabTo
(
this
.
selectedTab
0
)
;
}
}
moveTabToEnd
(
)
{
let
tabPos
=
this
.
selectedTab
.
_tPos
;
if
(
tabPos
<
this
.
browsers
.
length
-
1
)
{
this
.
moveTabTo
(
this
.
selectedTab
this
.
browsers
.
length
-
1
)
;
}
}
moveTabOver
(
aEvent
)
{
if
(
(
!
RTL_UI
&
&
aEvent
.
keyCode
=
=
KeyEvent
.
DOM_VK_RIGHT
)
|
|
(
RTL_UI
&
&
aEvent
.
keyCode
=
=
KeyEvent
.
DOM_VK_LEFT
)
)
{
this
.
moveTabForward
(
)
;
}
else
{
this
.
moveTabBackward
(
)
;
}
}
duplicateTab
(
aTab
aRestoreTabImmediately
aOptions
)
{
return
SessionStore
.
duplicateTab
(
window
aTab
0
aRestoreTabImmediately
aOptions
)
;
}
addToMultiSelectedTabs
(
aTab
)
{
if
(
aTab
.
multiselected
)
{
return
;
}
aTab
.
setAttribute
(
"
multiselected
"
"
true
"
)
;
aTab
.
setAttribute
(
"
aria
-
selected
"
"
true
"
)
;
this
.
_multiSelectedTabsSet
.
add
(
aTab
)
;
this
.
_startMultiSelectChange
(
)
;
if
(
this
.
_multiSelectChangeRemovals
.
has
(
aTab
)
)
{
this
.
_multiSelectChangeRemovals
.
delete
(
aTab
)
;
}
else
{
this
.
_multiSelectChangeAdditions
.
add
(
aTab
)
;
}
}
addRangeToMultiSelectedTabs
(
aTab1
aTab2
)
{
if
(
aTab1
=
=
aTab2
)
{
return
;
}
const
tabs
=
this
.
visibleTabs
;
const
indexOfTab1
=
tabs
.
indexOf
(
aTab1
)
;
const
indexOfTab2
=
tabs
.
indexOf
(
aTab2
)
;
const
[
lowerIndex
higherIndex
]
=
indexOfTab1
<
indexOfTab2
?
[
indexOfTab1
indexOfTab2
]
:
[
indexOfTab2
indexOfTab1
]
;
for
(
let
i
=
lowerIndex
;
i
<
=
higherIndex
;
i
+
+
)
{
this
.
addToMultiSelectedTabs
(
tabs
[
i
]
)
;
}
}
removeFromMultiSelectedTabs
(
aTab
)
{
if
(
!
aTab
.
multiselected
)
{
return
;
}
aTab
.
removeAttribute
(
"
multiselected
"
)
;
aTab
.
removeAttribute
(
"
aria
-
selected
"
)
;
this
.
_multiSelectedTabsSet
.
delete
(
aTab
)
;
this
.
_startMultiSelectChange
(
)
;
if
(
this
.
_multiSelectChangeAdditions
.
has
(
aTab
)
)
{
this
.
_multiSelectChangeAdditions
.
delete
(
aTab
)
;
}
else
{
this
.
_multiSelectChangeRemovals
.
add
(
aTab
)
;
}
}
clearMultiSelectedTabs
(
)
{
if
(
this
.
_clearMultiSelectionLocked
)
{
if
(
this
.
_clearMultiSelectionLockedOnce
)
{
this
.
_clearMultiSelectionLockedOnce
=
false
;
this
.
_clearMultiSelectionLocked
=
false
;
}
return
;
}
if
(
this
.
multiSelectedTabsCount
<
1
)
{
return
;
}
for
(
let
tab
of
this
.
selectedTabs
)
{
this
.
removeFromMultiSelectedTabs
(
tab
)
;
}
this
.
_lastMultiSelectedTabRef
=
null
;
}
selectAllTabs
(
)
{
let
visibleTabs
=
this
.
visibleTabs
;
gBrowser
.
addRangeToMultiSelectedTabs
(
visibleTabs
[
0
]
visibleTabs
[
visibleTabs
.
length
-
1
]
)
;
}
allTabsSelected
(
)
{
return
(
this
.
visibleTabs
.
length
=
=
1
|
|
this
.
visibleTabs
.
every
(
t
=
>
t
.
multiselected
)
)
;
}
lockClearMultiSelectionOnce
(
)
{
this
.
_clearMultiSelectionLockedOnce
=
true
;
this
.
_clearMultiSelectionLocked
=
true
;
}
unlockClearMultiSelection
(
)
{
this
.
_clearMultiSelectionLockedOnce
=
false
;
this
.
_clearMultiSelectionLocked
=
false
;
}
avoidSingleSelectedTab
(
)
{
if
(
this
.
multiSelectedTabsCount
=
=
1
)
{
this
.
clearMultiSelectedTabs
(
)
;
}
}
switchToNextMultiSelectedTab
(
)
{
this
.
_clearMultiSelectionLocked
=
true
;
try
{
let
lastMultiSelectedTab
=
gBrowser
.
lastMultiSelectedTab
;
if
(
lastMultiSelectedTab
!
=
gBrowser
.
selectedTab
)
{
gBrowser
.
selectedTab
=
lastMultiSelectedTab
;
}
else
{
let
selectedTabs
=
ChromeUtils
.
nondeterministicGetWeakSetKeys
(
this
.
_multiSelectedTabsSet
)
.
filter
(
tab
=
>
tab
.
isConnected
&
&
!
tab
.
closing
)
;
let
length
=
selectedTabs
.
length
;
gBrowser
.
selectedTab
=
selectedTabs
[
length
-
1
]
;
}
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
this
.
_clearMultiSelectionLocked
=
false
;
}
set
selectedTabs
(
tabs
)
{
this
.
clearMultiSelectedTabs
(
)
;
this
.
selectedTab
=
tabs
[
0
]
;
if
(
tabs
.
length
>
1
)
{
for
(
let
tab
of
tabs
)
{
this
.
addToMultiSelectedTabs
(
tab
)
;
}
}
}
get
selectedTabs
(
)
{
let
{
selectedTab
_multiSelectedTabsSet
}
=
this
;
let
tabs
=
ChromeUtils
.
nondeterministicGetWeakSetKeys
(
_multiSelectedTabsSet
)
.
filter
(
tab
=
>
tab
.
isConnected
&
&
!
tab
.
closing
)
;
if
(
!
_multiSelectedTabsSet
.
has
(
selectedTab
)
)
{
tabs
.
push
(
selectedTab
)
;
}
return
tabs
.
sort
(
(
a
b
)
=
>
a
.
_tPos
>
b
.
_tPos
)
;
}
get
multiSelectedTabsCount
(
)
{
return
ChromeUtils
.
nondeterministicGetWeakSetKeys
(
this
.
_multiSelectedTabsSet
)
.
filter
(
tab
=
>
tab
.
isConnected
&
&
!
tab
.
closing
)
.
length
;
}
get
lastMultiSelectedTab
(
)
{
let
tab
=
this
.
_lastMultiSelectedTabRef
?
this
.
_lastMultiSelectedTabRef
.
get
(
)
:
null
;
if
(
tab
&
&
tab
.
isConnected
&
&
this
.
_multiSelectedTabsSet
.
has
(
tab
)
)
{
return
tab
;
}
let
selectedTab
=
gBrowser
.
selectedTab
;
this
.
lastMultiSelectedTab
=
selectedTab
;
return
selectedTab
;
}
set
lastMultiSelectedTab
(
aTab
)
{
this
.
_lastMultiSelectedTabRef
=
Cu
.
getWeakReference
(
aTab
)
;
}
_startMultiSelectChange
(
)
{
if
(
!
this
.
_multiSelectChangeStarted
)
{
this
.
_multiSelectChangeStarted
=
true
;
Promise
.
resolve
(
)
.
then
(
(
)
=
>
this
.
_endMultiSelectChange
(
)
)
;
}
}
_endMultiSelectChange
(
)
{
let
noticeable
=
false
;
let
{
selectedTab
}
=
this
;
if
(
this
.
_multiSelectChangeAdditions
.
size
)
{
if
(
!
selectedTab
.
multiselected
)
{
this
.
addToMultiSelectedTabs
(
selectedTab
)
;
}
noticeable
=
true
;
}
if
(
this
.
_multiSelectChangeRemovals
.
size
)
{
if
(
this
.
_multiSelectChangeRemovals
.
has
(
selectedTab
)
)
{
this
.
switchToNextMultiSelectedTab
(
)
;
}
this
.
avoidSingleSelectedTab
(
)
;
noticeable
=
true
;
}
this
.
_multiSelectChangeStarted
=
false
;
if
(
noticeable
|
|
this
.
_multiSelectChangeSelected
)
{
this
.
_multiSelectChangeSelected
=
false
;
this
.
_multiSelectChangeAdditions
.
clear
(
)
;
this
.
_multiSelectChangeRemovals
.
clear
(
)
;
if
(
noticeable
)
{
this
.
tabContainer
.
_setPositionalAttributes
(
)
;
}
this
.
dispatchEvent
(
new
CustomEvent
(
"
TabMultiSelect
"
{
bubbles
:
true
}
)
)
;
}
}
toggleMuteAudioOnMultiSelectedTabs
(
aTab
)
{
let
tabMuted
=
aTab
.
linkedBrowser
.
audioMuted
;
let
tabsToToggle
=
this
.
selectedTabs
.
filter
(
tab
=
>
tab
.
linkedBrowser
.
audioMuted
=
=
tabMuted
)
;
for
(
let
tab
of
tabsToToggle
)
{
tab
.
toggleMuteAudio
(
)
;
}
}
resumeDelayedMediaOnMultiSelectedTabs
(
)
{
for
(
let
tab
of
this
.
selectedTabs
)
{
tab
.
resumeDelayedMedia
(
)
;
}
}
pinMultiSelectedTabs
(
)
{
for
(
let
tab
of
this
.
selectedTabs
)
{
this
.
pinTab
(
tab
)
;
}
}
unpinMultiSelectedTabs
(
)
{
let
selectedTabs
=
this
.
selectedTabs
;
for
(
let
i
=
selectedTabs
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
let
tab
=
selectedTabs
[
i
]
;
this
.
unpinTab
(
tab
)
;
}
}
activateBrowserForPrintPreview
(
aBrowser
)
{
this
.
_printPreviewBrowsers
.
add
(
aBrowser
)
;
if
(
this
.
_switcher
)
{
this
.
_switcher
.
activateBrowserForPrintPreview
(
aBrowser
)
;
}
aBrowser
.
docShellIsActive
=
true
;
}
deactivatePrintPreviewBrowsers
(
)
{
let
browsers
=
this
.
_printPreviewBrowsers
;
this
.
_printPreviewBrowsers
=
new
Set
(
)
;
for
(
let
browser
of
browsers
)
{
browser
.
docShellIsActive
=
this
.
shouldActivateDocShell
(
browser
)
;
}
}
shouldActivateDocShell
(
aBrowser
)
{
if
(
this
.
_switcher
)
{
return
this
.
_switcher
.
shouldActivateDocShell
(
aBrowser
)
;
}
return
(
(
aBrowser
=
=
this
.
selectedBrowser
&
&
!
document
.
hidden
)
|
|
this
.
_printPreviewBrowsers
.
has
(
aBrowser
)
|
|
this
.
PictureInPicture
.
isOriginatingBrowser
(
aBrowser
)
)
;
}
_getSwitcher
(
)
{
if
(
!
this
.
_switcher
)
{
this
.
_switcher
=
new
this
.
AsyncTabSwitcher
(
this
)
;
}
return
this
.
_switcher
;
}
warmupTab
(
aTab
)
{
if
(
gMultiProcessBrowser
)
{
this
.
_getSwitcher
(
)
.
warmupTab
(
aTab
)
;
}
}
_maybeRequestReplyFromRemoteContent
(
aEvent
)
{
if
(
aEvent
.
defaultPrevented
)
{
return
false
;
}
if
(
aEvent
.
isWaitingReplyFromRemoteContent
)
{
return
true
;
}
if
(
!
aEvent
.
isReplyEventFromRemoteContent
&
&
aEvent
.
target
?
.
isRemoteBrowser
=
=
=
true
)
{
aEvent
.
requestReplyFromRemoteContent
(
)
;
return
true
;
}
return
false
;
}
_handleKeyDownEvent
(
aEvent
)
{
if
(
!
aEvent
.
isTrusted
)
{
return
;
}
if
(
aEvent
.
defaultCancelled
)
{
return
;
}
if
(
aEvent
.
defaultPreventedByChrome
)
{
return
;
}
switch
(
ShortcutUtils
.
getSystemActionForEvent
(
aEvent
)
)
{
case
ShortcutUtils
.
TOGGLE_CARET_BROWSING
:
this
.
_maybeRequestReplyFromRemoteContent
(
aEvent
)
;
return
;
case
ShortcutUtils
.
MOVE_TAB_BACKWARD
:
this
.
moveTabBackward
(
)
;
aEvent
.
preventDefault
(
)
;
return
;
case
ShortcutUtils
.
MOVE_TAB_FORWARD
:
this
.
moveTabForward
(
)
;
aEvent
.
preventDefault
(
)
;
return
;
case
ShortcutUtils
.
CLOSE_TAB
:
if
(
gBrowser
.
multiSelectedTabsCount
)
{
gBrowser
.
removeMultiSelectedTabs
(
)
;
}
else
if
(
!
this
.
selectedTab
.
pinned
)
{
this
.
removeCurrentTab
(
{
animate
:
true
}
)
;
}
aEvent
.
preventDefault
(
)
;
}
}
toggleCaretBrowsing
(
)
{
const
kPrefShortcutEnabled
=
"
accessibility
.
browsewithcaret_shortcut
.
enabled
"
;
const
kPrefWarnOnEnable
=
"
accessibility
.
warn_on_browsewithcaret
"
;
const
kPrefCaretBrowsingOn
=
"
accessibility
.
browsewithcaret
"
;
var
isEnabled
=
Services
.
prefs
.
getBoolPref
(
kPrefShortcutEnabled
)
;
if
(
!
isEnabled
)
{
return
;
}
var
browseWithCaretOn
=
Services
.
prefs
.
getBoolPref
(
kPrefCaretBrowsingOn
false
)
;
var
warn
=
Services
.
prefs
.
getBoolPref
(
kPrefWarnOnEnable
true
)
;
if
(
warn
&
&
!
browseWithCaretOn
)
{
var
checkValue
=
{
value
:
false
}
;
var
promptService
=
Services
.
prompt
;
var
buttonPressed
=
promptService
.
confirmEx
(
window
gTabBrowserBundle
.
GetStringFromName
(
"
browsewithcaret
.
checkWindowTitle
"
)
gTabBrowserBundle
.
GetStringFromName
(
"
browsewithcaret
.
checkLabel
"
)
promptService
.
STD_YES_NO_BUTTONS
|
promptService
.
BUTTON_POS_1_DEFAULT
null
null
null
gTabBrowserBundle
.
GetStringFromName
(
"
browsewithcaret
.
checkMsg
"
)
checkValue
)
;
if
(
buttonPressed
!
=
0
)
{
if
(
checkValue
.
value
)
{
try
{
Services
.
prefs
.
setBoolPref
(
kPrefShortcutEnabled
false
)
;
}
catch
(
ex
)
{
}
}
return
;
}
if
(
checkValue
.
value
)
{
try
{
Services
.
prefs
.
setBoolPref
(
kPrefWarnOnEnable
false
)
;
}
catch
(
ex
)
{
}
}
}
try
{
Services
.
prefs
.
setBoolPref
(
kPrefCaretBrowsingOn
!
browseWithCaretOn
)
;
}
catch
(
ex
)
{
}
}
_handleKeyPressEvent
(
aEvent
)
{
if
(
!
aEvent
.
isTrusted
)
{
return
;
}
if
(
aEvent
.
defaultCancelled
)
{
return
;
}
if
(
aEvent
.
defaultPreventedByChrome
)
{
return
;
}
switch
(
ShortcutUtils
.
getSystemActionForEvent
(
aEvent
{
rtl
:
RTL_UI
}
)
)
{
case
ShortcutUtils
.
TOGGLE_CARET_BROWSING
:
if
(
aEvent
.
defaultPrevented
|
|
this
.
_maybeRequestReplyFromRemoteContent
(
aEvent
)
)
{
break
;
}
this
.
toggleCaretBrowsing
(
)
;
break
;
case
ShortcutUtils
.
NEXT_TAB
:
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
this
.
tabContainer
.
advanceSelectedTab
(
1
true
)
;
aEvent
.
preventDefault
(
)
;
}
break
;
case
ShortcutUtils
.
PREVIOUS_TAB
:
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
this
.
tabContainer
.
advanceSelectedTab
(
-
1
true
)
;
aEvent
.
preventDefault
(
)
;
}
break
;
}
}
getTabTooltip
(
tab
includeLabel
=
true
)
{
let
label
=
"
"
;
if
(
includeLabel
)
{
label
=
tab
.
_fullLabel
|
|
tab
.
getAttribute
(
"
label
"
)
;
}
if
(
Services
.
prefs
.
getBoolPref
(
"
browser
.
tabs
.
tooltipsShowPidAndActiveness
"
false
)
)
{
if
(
tab
.
linkedBrowser
)
{
let
[
contentPid
.
.
.
framePids
]
=
E10SUtils
.
getBrowserPids
(
tab
.
linkedBrowser
gFissionBrowser
)
;
if
(
contentPid
)
{
if
(
framePids
&
&
framePids
.
length
)
{
label
+
=
(
pids
{
contentPid
}
{
framePids
.
sort
(
)
.
join
(
"
"
)
}
)
;
}
else
{
label
+
=
(
pid
{
contentPid
}
)
;
}
}
if
(
tab
.
linkedBrowser
.
docShellIsActive
)
{
label
+
=
"
[
A
]
"
;
}
}
}
if
(
tab
.
userContextId
)
{
label
=
gTabBrowserBundle
.
formatStringFromName
(
"
tabs
.
containers
.
tooltip
"
[
label
ContextualIdentityService
.
getUserContextLabel
(
tab
.
userContextId
)
]
)
;
}
return
label
;
}
createTooltip
(
event
)
{
event
.
stopPropagation
(
)
;
let
tab
=
event
.
target
.
triggerNode
?
.
closest
(
"
tab
"
)
;
if
(
!
tab
)
{
event
.
preventDefault
(
)
;
return
;
}
let
stringWithShortcut
=
(
stringId
keyElemId
pluralCount
)
=
>
{
let
keyElem
=
document
.
getElementById
(
keyElemId
)
;
let
shortcut
=
ShortcutUtils
.
prettifyShortcut
(
keyElem
)
;
return
PluralForm
.
get
(
pluralCount
gTabBrowserBundle
.
GetStringFromName
(
stringId
)
)
.
replace
(
"
%
S
"
shortcut
)
.
replace
(
"
#
1
"
pluralCount
)
;
}
;
let
label
;
const
selectedTabs
=
this
.
selectedTabs
;
const
contextTabInSelection
=
selectedTabs
.
includes
(
tab
)
;
const
affectedTabsLength
=
contextTabInSelection
?
selectedTabs
.
length
:
1
;
if
(
tab
.
mOverCloseButton
)
{
label
=
tab
.
selected
?
stringWithShortcut
(
"
tabs
.
closeTabs
.
tooltip
"
"
key_close
"
affectedTabsLength
)
:
PluralForm
.
get
(
affectedTabsLength
gTabBrowserBundle
.
GetStringFromName
(
"
tabs
.
closeTabs
.
tooltip
"
)
)
.
replace
(
"
#
1
"
affectedTabsLength
)
;
}
else
if
(
tab
.
_overPlayingIcon
)
{
let
stringID
;
if
(
tab
.
selected
)
{
stringID
=
tab
.
linkedBrowser
.
audioMuted
?
"
tabs
.
unmuteAudio2
.
tooltip
"
:
"
tabs
.
muteAudio2
.
tooltip
"
;
label
=
stringWithShortcut
(
stringID
"
key_toggleMute
"
affectedTabsLength
)
;
}
else
{
if
(
tab
.
hasAttribute
(
"
activemedia
-
blocked
"
)
)
{
stringID
=
"
tabs
.
unblockAudio2
.
tooltip
"
;
}
else
{
stringID
=
tab
.
linkedBrowser
.
audioMuted
?
"
tabs
.
unmuteAudio2
.
background
.
tooltip
"
:
"
tabs
.
muteAudio2
.
background
.
tooltip
"
;
}
label
=
PluralForm
.
get
(
affectedTabsLength
gTabBrowserBundle
.
GetStringFromName
(
stringID
)
)
.
replace
(
"
#
1
"
affectedTabsLength
)
;
}
}
else
{
label
=
this
.
getTabTooltip
(
tab
)
;
}
event
.
target
.
setAttribute
(
"
label
"
label
)
;
}
handleEvent
(
aEvent
)
{
switch
(
aEvent
.
type
)
{
case
"
keydown
"
:
this
.
_handleKeyDownEvent
(
aEvent
)
;
break
;
case
"
keypress
"
:
this
.
_handleKeyPressEvent
(
aEvent
)
;
break
;
case
"
framefocusrequested
"
:
{
let
tab
=
this
.
getTabForBrowser
(
aEvent
.
target
)
;
if
(
!
tab
|
|
tab
=
=
this
.
selectedTab
)
{
break
;
}
this
.
selectedTab
=
tab
;
window
.
focus
(
)
;
aEvent
.
preventDefault
(
)
;
break
;
}
case
"
visibilitychange
"
:
const
inactive
=
document
.
hidden
;
if
(
!
this
.
_switcher
)
{
this
.
selectedBrowser
.
preserveLayers
(
inactive
)
;
this
.
selectedBrowser
.
docShellIsActive
=
!
inactive
;
}
break
;
}
}
observe
(
aSubject
aTopic
aData
)
{
switch
(
aTopic
)
{
case
"
contextual
-
identity
-
updated
"
:
{
let
identity
=
aSubject
.
wrappedJSObject
;
for
(
let
tab
of
this
.
tabs
)
{
if
(
tab
.
getAttribute
(
"
usercontextid
"
)
=
=
identity
.
userContextId
)
{
ContextualIdentityService
.
setTabStyle
(
tab
)
;
}
}
break
;
}
}
}
refreshBlocked
(
actor
browser
data
)
{
let
brandBundle
=
document
.
getElementById
(
"
bundle_brand
"
)
;
let
brandShortName
=
brandBundle
.
getString
(
"
brandShortName
"
)
;
let
message
=
gNavigatorBundle
.
getFormattedString
(
"
refreshBlocked
.
"
+
(
data
.
sameURI
?
"
refreshLabel
"
:
"
redirectLabel
"
)
[
brandShortName
]
)
;
let
notificationBox
=
this
.
getNotificationBox
(
browser
)
;
let
notification
=
notificationBox
.
getNotificationWithValue
(
"
refresh
-
blocked
"
)
;
if
(
notification
)
{
notification
.
label
=
message
;
}
else
{
let
refreshButtonText
=
gNavigatorBundle
.
getString
(
"
refreshBlocked
.
goButton
"
)
;
let
refreshButtonAccesskey
=
gNavigatorBundle
.
getString
(
"
refreshBlocked
.
goButton
.
accesskey
"
)
;
let
buttons
=
[
{
label
:
refreshButtonText
accessKey
:
refreshButtonAccesskey
callback
(
)
{
actor
.
sendAsyncMessage
(
"
RefreshBlocker
:
Refresh
"
data
)
;
}
}
]
;
notificationBox
.
appendNotification
(
"
refresh
-
blocked
"
{
label
:
message
image
:
"
chrome
:
/
/
browser
/
skin
/
notification
-
icons
/
popup
.
svg
"
priority
:
notificationBox
.
PRIORITY_INFO_MEDIUM
}
buttons
)
;
}
}
_generateUniquePanelID
(
)
{
if
(
!
this
.
_uniquePanelIDCounter
)
{
this
.
_uniquePanelIDCounter
=
0
;
}
let
outerID
=
window
.
docShell
.
outerWindowID
;
return
"
panel
-
"
+
outerID
+
"
-
"
+
+
+
this
.
_uniquePanelIDCounter
;
}
destroy
(
)
{
this
.
tabContainer
.
destroy
(
)
;
Services
.
obs
.
removeObserver
(
this
"
contextual
-
identity
-
updated
"
)
;
for
(
let
tab
of
this
.
tabs
)
{
let
browser
=
tab
.
linkedBrowser
;
if
(
browser
.
registeredOpenURI
)
{
let
userContextId
=
browser
.
getAttribute
(
"
usercontextid
"
)
|
|
0
;
this
.
UrlbarProviderOpenTabs
.
unregisterOpenTab
(
browser
.
registeredOpenURI
.
spec
userContextId
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
;
delete
browser
.
registeredOpenURI
;
}
let
filter
=
this
.
_tabFilters
.
get
(
tab
)
;
if
(
filter
)
{
browser
.
webProgress
.
removeProgressListener
(
filter
)
;
let
listener
=
this
.
_tabListeners
.
get
(
tab
)
;
if
(
listener
)
{
filter
.
removeProgressListener
(
listener
)
;
listener
.
destroy
(
)
;
}
this
.
_tabFilters
.
delete
(
tab
)
;
this
.
_tabListeners
.
delete
(
tab
)
;
}
}
Services
.
els
.
removeSystemEventListener
(
document
"
keydown
"
this
false
)
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
Services
.
els
.
removeSystemEventListener
(
document
"
keypress
"
this
false
)
;
}
document
.
removeEventListener
(
"
visibilitychange
"
this
)
;
window
.
removeEventListener
(
"
framefocusrequested
"
this
)
;
if
(
gMultiProcessBrowser
)
{
if
(
this
.
_switcher
)
{
this
.
_switcher
.
destroy
(
)
;
}
}
}
_setupEventListeners
(
)
{
this
.
tabpanels
.
addEventListener
(
"
select
"
event
=
>
{
if
(
event
.
target
=
=
this
.
tabpanels
)
{
this
.
updateCurrentBrowser
(
)
;
}
}
)
;
this
.
addEventListener
(
"
DOMWindowClose
"
event
=
>
{
let
browser
=
event
.
target
;
if
(
!
browser
.
isRemoteBrowser
)
{
if
(
!
event
.
isTrusted
)
{
return
;
}
browser
=
event
.
target
.
docShell
.
chromeEventHandler
;
}
if
(
this
.
tabs
.
length
=
=
1
)
{
window
.
skipNextCanClose
=
true
;
window
.
close
(
)
;
return
;
}
let
tab
=
this
.
getTabForBrowser
(
browser
)
;
if
(
tab
)
{
this
.
removeTab
(
tab
{
skipPermitUnload
:
true
}
)
;
event
.
preventDefault
(
)
;
}
}
)
;
this
.
addEventListener
(
"
pagetitlechanged
"
event
=
>
{
let
browser
=
event
.
target
;
let
tab
=
this
.
getTabForBrowser
(
browser
)
;
if
(
!
tab
|
|
tab
.
hasAttribute
(
"
pending
"
)
)
{
return
;
}
if
(
!
browser
.
contentTitle
&
&
browser
.
contentPrincipal
.
isSystemPrincipal
)
{
return
;
}
let
titleChanged
=
this
.
setTabTitle
(
tab
)
;
if
(
titleChanged
&
&
!
tab
.
selected
&
&
!
tab
.
hasAttribute
(
"
busy
"
)
)
{
tab
.
setAttribute
(
"
titlechanged
"
"
true
"
)
;
}
}
)
;
this
.
addEventListener
(
"
DOMWillOpenModalDialog
"
event
=
>
{
if
(
!
event
.
isTrusted
)
{
return
;
}
let
targetIsWindow
=
Window
.
isInstance
(
event
.
target
)
;
let
tabForEvent
=
targetIsWindow
?
this
.
getTabForBrowser
(
event
.
target
.
docShell
.
chromeEventHandler
)
:
this
.
getTabForBrowser
(
event
.
originalTarget
)
;
if
(
event
.
detail
&
&
event
.
detail
.
tabPrompt
&
&
event
.
detail
.
inPermitUnload
&
&
Services
.
focus
.
activeWindow
)
{
window
.
focus
(
)
;
}
if
(
!
tabForEvent
|
|
tabForEvent
.
selected
)
{
return
;
}
if
(
event
.
detail
&
&
event
.
detail
.
tabPrompt
&
&
!
event
.
detail
.
inPermitUnload
)
{
let
docPrincipal
=
targetIsWindow
?
event
.
target
.
document
.
nodePrincipal
:
null
;
let
promptPrincipal
=
event
.
detail
.
promptPrincipal
|
|
docPrincipal
|
|
tabForEvent
.
linkedBrowser
.
contentPrincipal
;
if
(
!
promptPrincipal
|
|
promptPrincipal
.
isNullPrincipal
)
{
tabForEvent
.
attention
=
true
;
return
;
}
if
(
promptPrincipal
.
URI
&
&
!
promptPrincipal
.
isSystemPrincipal
)
{
let
permission
=
Services
.
perms
.
testPermissionFromPrincipal
(
promptPrincipal
"
focus
-
tab
-
by
-
prompt
"
)
;
if
(
permission
!
=
Services
.
perms
.
ALLOW_ACTION
)
{
let
tabPrompt
=
Services
.
prefs
.
getBoolPref
(
"
prompts
.
contentPromptSubDialog
"
)
?
this
.
getTabDialogBox
(
tabForEvent
.
linkedBrowser
)
:
this
.
getTabModalPromptBox
(
tabForEvent
.
linkedBrowser
)
;
tabPrompt
.
onNextPromptShowAllowFocusCheckboxFor
(
promptPrincipal
)
;
tabForEvent
.
attention
=
true
;
return
;
}
}
}
this
.
selectedTab
=
tabForEvent
;
}
true
)
;
this
.
addEventListener
(
"
DOMModalDialogClosed
"
event
=
>
{
if
(
!
event
.
detail
?
.
wasPermitUnload
|
|
event
.
detail
.
areLeaving
|
|
event
.
target
.
nodeName
!
=
"
browser
"
)
{
return
;
}
event
.
target
.
userTypedValue
=
null
;
if
(
event
.
target
=
=
this
.
selectedBrowser
)
{
gURLBar
.
setURI
(
)
;
}
}
true
)
;
let
onTabCrashed
=
event
=
>
{
if
(
!
event
.
isTrusted
)
{
return
;
}
let
browser
=
event
.
originalTarget
;
if
(
!
event
.
isTopFrame
)
{
TabCrashHandler
.
onSubFrameCrash
(
browser
event
.
childID
)
;
return
;
}
if
(
browser
=
=
=
this
.
preloadedBrowser
)
{
NewTabPagePreloading
.
removePreloadedBrowser
(
window
)
;
return
;
}
let
isRestartRequiredCrash
=
event
.
type
=
=
"
oop
-
browser
-
buildid
-
mismatch
"
;
let
icon
=
browser
.
mIconURL
;
let
tab
=
this
.
getTabForBrowser
(
browser
)
;
if
(
this
.
selectedBrowser
=
=
browser
)
{
TabCrashHandler
.
onSelectedBrowserCrash
(
browser
isRestartRequiredCrash
)
;
}
else
{
TabCrashHandler
.
onBackgroundBrowserCrash
(
browser
isRestartRequiredCrash
)
;
}
tab
.
removeAttribute
(
"
soundplaying
"
)
;
this
.
setIcon
(
tab
icon
)
;
}
;
this
.
addEventListener
(
"
oop
-
browser
-
crashed
"
onTabCrashed
)
;
this
.
addEventListener
(
"
oop
-
browser
-
buildid
-
mismatch
"
onTabCrashed
)
;
this
.
addEventListener
(
"
DOMAudioPlaybackStarted
"
event
=
>
{
var
tab
=
this
.
getTabFromAudioEvent
(
event
)
;
if
(
!
tab
)
{
return
;
}
clearTimeout
(
tab
.
_soundPlayingAttrRemovalTimer
)
;
tab
.
_soundPlayingAttrRemovalTimer
=
0
;
let
modifiedAttrs
=
[
]
;
if
(
tab
.
hasAttribute
(
"
soundplaying
-
scheduledremoval
"
)
)
{
tab
.
removeAttribute
(
"
soundplaying
-
scheduledremoval
"
)
;
modifiedAttrs
.
push
(
"
soundplaying
-
scheduledremoval
"
)
;
}
if
(
!
tab
.
hasAttribute
(
"
soundplaying
"
)
)
{
tab
.
setAttribute
(
"
soundplaying
"
true
)
;
modifiedAttrs
.
push
(
"
soundplaying
"
)
;
}
if
(
modifiedAttrs
.
length
)
{
getComputedStyle
(
tab
)
.
opacity
;
}
this
.
_tabAttrModified
(
tab
modifiedAttrs
)
;
}
)
;
this
.
addEventListener
(
"
DOMAudioPlaybackStopped
"
event
=
>
{
var
tab
=
this
.
getTabFromAudioEvent
(
event
)
;
if
(
!
tab
)
{
return
;
}
if
(
tab
.
hasAttribute
(
"
soundplaying
"
)
)
{
let
removalDelay
=
Services
.
prefs
.
getIntPref
(
"
browser
.
tabs
.
delayHidingAudioPlayingIconMS
"
)
;
tab
.
style
.
setProperty
(
"
-
-
soundplaying
-
removal
-
delay
"
{
removalDelay
-
300
}
ms
)
;
tab
.
setAttribute
(
"
soundplaying
-
scheduledremoval
"
"
true
"
)
;
this
.
_tabAttrModified
(
tab
[
"
soundplaying
-
scheduledremoval
"
]
)
;
tab
.
_soundPlayingAttrRemovalTimer
=
setTimeout
(
(
)
=
>
{
tab
.
removeAttribute
(
"
soundplaying
-
scheduledremoval
"
)
;
tab
.
removeAttribute
(
"
soundplaying
"
)
;
this
.
_tabAttrModified
(
tab
[
"
soundplaying
"
"
soundplaying
-
scheduledremoval
"
]
)
;
}
removalDelay
)
;
}
}
)
;
this
.
addEventListener
(
"
DOMAudioPlaybackBlockStarted
"
event
=
>
{
var
tab
=
this
.
getTabFromAudioEvent
(
event
)
;
if
(
!
tab
)
{
return
;
}
if
(
!
tab
.
hasAttribute
(
"
activemedia
-
blocked
"
)
)
{
tab
.
setAttribute
(
"
activemedia
-
blocked
"
true
)
;
this
.
_tabAttrModified
(
tab
[
"
activemedia
-
blocked
"
]
)
;
}
}
)
;
this
.
addEventListener
(
"
DOMAudioPlaybackBlockStopped
"
event
=
>
{
var
tab
=
this
.
getTabFromAudioEvent
(
event
)
;
if
(
!
tab
)
{
return
;
}
if
(
tab
.
hasAttribute
(
"
activemedia
-
blocked
"
)
)
{
tab
.
removeAttribute
(
"
activemedia
-
blocked
"
)
;
this
.
_tabAttrModified
(
tab
[
"
activemedia
-
blocked
"
]
)
;
let
hist
=
Services
.
telemetry
.
getHistogramById
(
"
TAB_AUDIO_INDICATOR_USED
"
)
;
hist
.
add
(
2
)
;
}
}
)
;
this
.
addEventListener
(
"
GloballyAutoplayBlocked
"
event
=
>
{
let
browser
=
event
.
originalTarget
;
let
tab
=
this
.
getTabForBrowser
(
browser
)
;
if
(
!
tab
)
{
return
;
}
SitePermissions
.
setForPrincipal
(
browser
.
contentPrincipal
"
autoplay
-
media
"
SitePermissions
.
BLOCK
SitePermissions
.
SCOPE_GLOBAL
browser
)
;
}
)
;
let
tabContextFTLInserter
=
(
)
=
>
{
this
.
translateTabContextMenu
(
)
;
this
.
tabContainer
.
removeEventListener
(
"
contextmenu
"
tabContextFTLInserter
true
)
;
this
.
tabContainer
.
removeEventListener
(
"
mouseover
"
tabContextFTLInserter
)
;
this
.
tabContainer
.
removeEventListener
(
"
focus
"
tabContextFTLInserter
true
)
;
}
;
this
.
tabContainer
.
addEventListener
(
"
contextmenu
"
tabContextFTLInserter
true
)
;
this
.
tabContainer
.
addEventListener
(
"
mouseover
"
tabContextFTLInserter
)
;
this
.
tabContainer
.
addEventListener
(
"
focus
"
tabContextFTLInserter
true
)
;
this
.
addEventListener
(
"
WillChangeBrowserRemoteness
"
event
=
>
{
let
browser
=
event
.
originalTarget
;
let
tab
=
this
.
getTabForBrowser
(
browser
)
;
if
(
!
tab
)
{
return
;
}
let
evt
=
document
.
createEvent
(
"
Events
"
)
;
evt
.
initEvent
(
"
BeforeTabRemotenessChange
"
true
false
)
;
tab
.
dispatchEvent
(
evt
)
;
let
wasActive
=
document
.
activeElement
=
=
browser
;
let
filter
=
this
.
_tabFilters
.
get
(
tab
)
;
let
oldListener
=
this
.
_tabListeners
.
get
(
tab
)
;
browser
.
webProgress
.
removeProgressListener
(
filter
)
;
filter
.
removeProgressListener
(
oldListener
)
;
let
stateFlags
=
oldListener
.
mStateFlags
;
let
requestCount
=
oldListener
.
mRequestCount
;
oldListener
.
destroy
(
)
;
let
oldDroppedLinkHandler
=
browser
.
droppedLinkHandler
;
let
oldUserTypedValue
=
browser
.
userTypedValue
;
let
hadStartedLoad
=
browser
.
didStartLoadSinceLastUserTyping
(
)
;
let
didChange
=
didChangeEvent
=
>
{
browser
.
userTypedValue
=
oldUserTypedValue
;
if
(
hadStartedLoad
)
{
browser
.
urlbarChangeTracker
.
startedLoad
(
)
;
}
browser
.
droppedLinkHandler
=
oldDroppedLinkHandler
;
browser
.
docShellIsActive
=
browser
.
docShellIsActive
;
let
listener
=
new
TabProgressListener
(
tab
browser
false
false
stateFlags
requestCount
)
;
this
.
_tabListeners
.
set
(
tab
listener
)
;
filter
.
addProgressListener
(
listener
Ci
.
nsIWebProgress
.
NOTIFY_ALL
)
;
browser
.
webProgress
.
addProgressListener
(
filter
Ci
.
nsIWebProgress
.
NOTIFY_ALL
)
;
let
cbEvent
=
browser
.
getContentBlockingEvents
(
)
;
this
.
_callProgressListeners
(
browser
"
onContentBlockingEvent
"
[
browser
.
webProgress
null
cbEvent
true
]
true
false
)
;
if
(
browser
.
isRemoteBrowser
)
{
tab
.
removeAttribute
(
"
crashed
"
)
;
gBrowser
.
tabContainer
.
updateTabIndicatorAttr
(
tab
)
;
}
else
{
browser
.
sendMessageToActor
(
"
Browser
:
AppTab
"
{
isAppTab
:
tab
.
pinned
}
"
BrowserTab
"
)
;
}
if
(
wasActive
)
{
browser
.
focus
(
)
;
}
if
(
this
.
isFindBarInitialized
(
tab
)
)
{
this
.
getCachedFindBar
(
tab
)
.
browser
=
browser
;
}
browser
.
sendMessageToActor
(
"
Browser
:
HasSiblings
"
this
.
tabs
.
length
>
1
"
BrowserTab
"
)
;
evt
=
document
.
createEvent
(
"
Events
"
)
;
evt
.
initEvent
(
"
TabRemotenessChange
"
true
false
)
;
tab
.
dispatchEvent
(
evt
)
;
}
;
browser
.
addEventListener
(
"
DidChangeBrowserRemoteness
"
didChange
{
once
:
true
}
)
;
}
)
;
this
.
addEventListener
(
"
pageinfo
"
event
=
>
{
let
browser
=
event
.
originalTarget
;
let
tab
=
this
.
getTabForBrowser
(
browser
)
;
if
(
!
tab
)
{
return
;
}
const
{
url
description
previewImageURL
}
=
event
.
detail
;
this
.
setPageInfo
(
url
description
previewImageURL
)
;
}
)
;
}
translateTabContextMenu
(
)
{
if
(
this
.
_tabContextMenuTranslated
)
{
return
;
}
MozXULElement
.
insertFTLIfNeeded
(
"
browser
/
tabContextMenu
.
ftl
"
)
;
document
.
getElementById
(
"
tabContextMenu
"
)
.
querySelectorAll
(
"
[
data
-
lazy
-
l10n
-
id
]
"
)
.
forEach
(
el
=
>
{
el
.
setAttribute
(
"
data
-
l10n
-
id
"
el
.
getAttribute
(
"
data
-
lazy
-
l10n
-
id
"
)
)
;
el
.
removeAttribute
(
"
data
-
lazy
-
l10n
-
id
"
)
;
}
)
;
this
.
_tabContextMenuTranslated
=
true
;
}
setSuccessor
(
aTab
successorTab
)
{
if
(
aTab
.
ownerGlobal
!
=
window
)
{
throw
new
Error
(
"
Cannot
set
the
successor
of
another
window
'
s
tab
"
)
;
}
if
(
successorTab
=
=
aTab
)
{
successorTab
=
null
;
}
if
(
successorTab
&
&
successorTab
.
ownerGlobal
!
=
window
)
{
throw
new
Error
(
"
Cannot
set
the
successor
to
another
window
'
s
tab
"
)
;
}
if
(
aTab
.
successor
)
{
aTab
.
successor
.
predecessors
.
delete
(
aTab
)
;
}
aTab
.
successor
=
successorTab
;
if
(
successorTab
)
{
if
(
!
successorTab
.
predecessors
)
{
successorTab
.
predecessors
=
new
Set
(
)
;
}
successorTab
.
predecessors
.
add
(
aTab
)
;
}
}
replaceInSuccession
(
aTab
aOtherTab
)
{
if
(
aTab
.
predecessors
)
{
for
(
const
predecessor
of
Array
.
from
(
aTab
.
predecessors
)
)
{
this
.
setSuccessor
(
predecessor
aOtherTab
)
;
}
}
}
}
;
class
TabProgressListener
{
constructor
(
aTab
aBrowser
aStartsBlank
aWasPreloadedBrowser
aOrigStateFlags
aOrigRequestCount
)
{
let
stateFlags
=
aOrigStateFlags
|
|
0
;
if
(
aWasPreloadedBrowser
)
{
stateFlags
=
Ci
.
nsIWebProgressListener
.
STATE_STOP
|
Ci
.
nsIWebProgressListener
.
STATE_IS_REQUEST
;
}
this
.
mTab
=
aTab
;
this
.
mBrowser
=
aBrowser
;
this
.
mBlank
=
aStartsBlank
;
this
.
mStateFlags
=
stateFlags
;
this
.
mStatus
=
0
;
this
.
mMessage
=
"
"
;
this
.
mTotalProgress
=
0
;
this
.
mRequestCount
=
aOrigRequestCount
|
|
0
;
}
destroy
(
)
{
delete
this
.
mTab
;
delete
this
.
mBrowser
;
}
_callProgressListeners
(
.
.
.
args
)
{
args
.
unshift
(
this
.
mBrowser
)
;
return
gBrowser
.
_callProgressListeners
.
apply
(
gBrowser
args
)
;
}
_shouldShowProgress
(
aRequest
)
{
if
(
this
.
mBlank
)
{
return
false
;
}
if
(
aRequest
instanceof
Ci
.
nsIChannel
&
&
aRequest
.
originalURI
.
schemeIs
(
"
about
"
)
)
{
return
false
;
}
return
true
;
}
_isForInitialAboutBlank
(
aWebProgress
aStateFlags
aLocation
)
{
if
(
!
this
.
mBlank
|
|
!
aWebProgress
.
isTopLevel
)
{
return
false
;
}
if
(
aStateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_STOP
&
&
this
.
mRequestCount
=
=
0
&
&
!
aLocation
)
{
return
true
;
}
let
location
=
aLocation
?
aLocation
.
spec
:
"
"
;
return
location
=
=
"
about
:
blank
"
;
}
onProgressChange
(
aWebProgress
aRequest
aCurSelfProgress
aMaxSelfProgress
aCurTotalProgress
aMaxTotalProgress
)
{
this
.
mTotalProgress
=
aMaxTotalProgress
?
aCurTotalProgress
/
aMaxTotalProgress
:
0
;
if
(
!
this
.
_shouldShowProgress
(
aRequest
)
)
{
return
;
}
if
(
this
.
mTotalProgress
&
&
this
.
mTab
.
hasAttribute
(
"
busy
"
)
)
{
this
.
mTab
.
setAttribute
(
"
progress
"
"
true
"
)
;
gBrowser
.
_tabAttrModified
(
this
.
mTab
[
"
progress
"
]
)
;
}
this
.
_callProgressListeners
(
"
onProgressChange
"
[
aWebProgress
aRequest
aCurSelfProgress
aMaxSelfProgress
aCurTotalProgress
aMaxTotalProgress
]
)
;
}
onProgressChange64
(
aWebProgress
aRequest
aCurSelfProgress
aMaxSelfProgress
aCurTotalProgress
aMaxTotalProgress
)
{
return
this
.
onProgressChange
(
aWebProgress
aRequest
aCurSelfProgress
aMaxSelfProgress
aCurTotalProgress
aMaxTotalProgress
)
;
}
onStateChange
(
aWebProgress
aRequest
aStateFlags
aStatus
)
{
if
(
!
aRequest
)
{
return
;
}
let
location
originalLocation
;
try
{
aRequest
.
QueryInterface
(
Ci
.
nsIChannel
)
;
location
=
aRequest
.
URI
;
originalLocation
=
aRequest
.
originalURI
;
}
catch
(
ex
)
{
}
let
ignoreBlank
=
this
.
_isForInitialAboutBlank
(
aWebProgress
aStateFlags
location
)
;
const
{
STATE_START
STATE_STOP
STATE_IS_NETWORK
}
=
Ci
.
nsIWebProgressListener
;
if
(
(
ignoreBlank
&
&
aStateFlags
&
STATE_STOP
&
&
aStateFlags
&
STATE_IS_NETWORK
)
|
|
(
!
ignoreBlank
&
&
this
.
mBlank
)
)
{
this
.
mBlank
=
false
;
}
if
(
aStateFlags
&
STATE_START
&
&
aStateFlags
&
STATE_IS_NETWORK
)
{
this
.
mRequestCount
+
+
;
if
(
aWebProgress
.
isTopLevel
)
{
if
(
!
(
originalLocation
&
&
gInitialPages
.
includes
(
originalLocation
.
spec
)
&
&
originalLocation
!
=
"
about
:
blank
"
&
&
this
.
mBrowser
.
initialPageLoadedFromUserAction
!
=
originalLocation
.
spec
&
&
this
.
mBrowser
.
currentURI
&
&
this
.
mBrowser
.
currentURI
.
spec
=
=
"
about
:
blank
"
)
)
{
this
.
mBrowser
.
urlbarChangeTracker
.
startedLoad
(
)
;
}
delete
this
.
mBrowser
.
initialPageLoadedFromUserAction
;
this
.
mTab
.
removeAttribute
(
"
crashed
"
)
;
gBrowser
.
tabContainer
.
updateTabIndicatorAttr
(
this
.
mTab
)
;
}
if
(
this
.
_shouldShowProgress
(
aRequest
)
)
{
if
(
!
(
aStateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_RESTORING
)
&
&
aWebProgress
&
&
aWebProgress
.
isTopLevel
)
{
this
.
mTab
.
setAttribute
(
"
busy
"
"
true
"
)
;
gBrowser
.
_tabAttrModified
(
this
.
mTab
[
"
busy
"
]
)
;
this
.
mTab
.
_notselectedsinceload
=
!
this
.
mTab
.
selected
;
gBrowser
.
syncThrobberAnimations
(
this
.
mTab
)
;
}
if
(
this
.
mTab
.
selected
)
{
gBrowser
.
_isBusy
=
true
;
}
}
}
else
if
(
aStateFlags
&
STATE_STOP
&
&
aStateFlags
&
STATE_IS_NETWORK
)
{
this
.
mRequestCount
=
0
;
let
modifiedAttrs
=
[
]
;
if
(
this
.
mTab
.
hasAttribute
(
"
busy
"
)
)
{
this
.
mTab
.
removeAttribute
(
"
busy
"
)
;
modifiedAttrs
.
push
(
"
busy
"
)
;
if
(
aWebProgress
.
isTopLevel
&
&
!
aWebProgress
.
isLoadingDocument
&
&
Components
.
isSuccessCode
(
aStatus
)
&
&
!
gBrowser
.
tabAnimationsInProgress
&
&
!
gReduceMotion
)
{
if
(
this
.
mTab
.
_notselectedsinceload
)
{
this
.
mTab
.
setAttribute
(
"
notselectedsinceload
"
"
true
"
)
;
}
else
{
this
.
mTab
.
removeAttribute
(
"
notselectedsinceload
"
)
;
}
this
.
mTab
.
setAttribute
(
"
bursting
"
"
true
"
)
;
}
}
if
(
this
.
mTab
.
hasAttribute
(
"
progress
"
)
)
{
this
.
mTab
.
removeAttribute
(
"
progress
"
)
;
modifiedAttrs
.
push
(
"
progress
"
)
;
}
if
(
modifiedAttrs
.
length
)
{
gBrowser
.
_tabAttrModified
(
this
.
mTab
modifiedAttrs
)
;
}
if
(
aWebProgress
.
isTopLevel
)
{
let
isSuccessful
=
Components
.
isSuccessCode
(
aStatus
)
;
if
(
!
isSuccessful
&
&
!
this
.
mTab
.
isEmpty
)
{
this
.
mBrowser
.
userTypedValue
=
null
;
let
isNavigating
=
this
.
mBrowser
.
isNavigating
;
if
(
this
.
mTab
.
selected
&
&
aStatus
!
=
Cr
.
NS_BINDING_CANCELLED_OLD_LOAD
&
&
!
isNavigating
)
{
gURLBar
.
setURI
(
)
;
}
}
else
if
(
isSuccessful
)
{
this
.
mBrowser
.
urlbarChangeTracker
.
finishedLoad
(
)
;
}
}
if
(
!
this
.
mBrowser
.
mIconURL
&
&
!
ignoreBlank
&
&
!
(
originalLocation
.
spec
in
FAVICON_DEFAULTS
)
)
{
this
.
mTab
.
removeAttribute
(
"
image
"
)
;
}
if
(
location
.
scheme
=
=
"
keyword
"
)
{
this
.
mBrowser
.
userTypedValue
=
null
;
}
if
(
this
.
mTab
.
selected
)
{
gBrowser
.
_isBusy
=
false
;
}
}
if
(
ignoreBlank
)
{
this
.
_callProgressListeners
(
"
onUpdateCurrentBrowser
"
[
aStateFlags
aStatus
"
"
0
]
true
false
)
;
}
else
{
this
.
_callProgressListeners
(
"
onStateChange
"
[
aWebProgress
aRequest
aStateFlags
aStatus
]
true
false
)
;
}
this
.
_callProgressListeners
(
"
onStateChange
"
[
aWebProgress
aRequest
aStateFlags
aStatus
]
false
)
;
if
(
aStateFlags
&
(
STATE_START
|
STATE_STOP
)
)
{
this
.
mMessage
=
"
"
;
this
.
mTotalProgress
=
0
;
}
this
.
mStateFlags
=
aStateFlags
;
this
.
mStatus
=
aStatus
;
}
onLocationChange
(
aWebProgress
aRequest
aLocation
aFlags
)
{
let
topLevel
=
aWebProgress
.
isTopLevel
;
let
isSameDocument
=
!
!
(
aFlags
&
Ci
.
nsIWebProgressListener
.
LOCATION_CHANGE_SAME_DOCUMENT
)
;
if
(
topLevel
)
{
let
isReload
=
!
!
(
aFlags
&
Ci
.
nsIWebProgressListener
.
LOCATION_CHANGE_RELOAD
)
;
let
isErrorPage
=
!
!
(
aFlags
&
Ci
.
nsIWebProgressListener
.
LOCATION_CHANGE_ERROR_PAGE
)
;
if
(
this
.
mBrowser
.
didStartLoadSinceLastUserTyping
(
)
|
|
(
isErrorPage
&
&
aLocation
.
spec
!
=
"
about
:
blank
"
)
|
|
(
isSameDocument
&
&
this
.
mBrowser
.
isNavigating
)
|
|
(
isSameDocument
&
&
!
this
.
mBrowser
.
userTypedValue
)
)
{
this
.
mBrowser
.
userTypedValue
=
null
;
}
if
(
isErrorPage
&
&
this
.
mTab
.
hasAttribute
(
"
busy
"
)
)
{
this
.
mTab
.
removeAttribute
(
"
busy
"
)
;
gBrowser
.
_tabAttrModified
(
this
.
mTab
[
"
busy
"
]
)
;
}
if
(
!
isSameDocument
)
{
if
(
this
.
mTab
.
hasAttribute
(
"
soundplaying
"
)
)
{
clearTimeout
(
this
.
mTab
.
_soundPlayingAttrRemovalTimer
)
;
this
.
mTab
.
_soundPlayingAttrRemovalTimer
=
0
;
this
.
mTab
.
removeAttribute
(
"
soundplaying
"
)
;
gBrowser
.
_tabAttrModified
(
this
.
mTab
[
"
soundplaying
"
]
)
;
}
if
(
this
.
mTab
.
hasAttribute
(
"
muted
"
)
)
{
this
.
mTab
.
linkedBrowser
.
mute
(
)
;
}
if
(
gBrowser
.
isFindBarInitialized
(
this
.
mTab
)
)
{
let
findBar
=
gBrowser
.
getCachedFindBar
(
this
.
mTab
)
;
if
(
findBar
.
findMode
!
=
findBar
.
FIND_NORMAL
)
{
findBar
.
close
(
)
;
}
}
if
(
!
isReload
)
{
gBrowser
.
setTabTitle
(
this
.
mTab
)
;
}
if
(
!
this
.
mTab
.
hasAttribute
(
"
pending
"
)
&
&
!
this
.
mTab
.
hasAttribute
(
"
customizemode
"
)
&
&
aWebProgress
.
isLoadingDocument
)
{
this
.
mBrowser
.
mIconURL
=
null
;
}
}
let
userContextId
=
this
.
mBrowser
.
getAttribute
(
"
usercontextid
"
)
|
|
0
;
if
(
this
.
mBrowser
.
registeredOpenURI
)
{
let
uri
=
this
.
mBrowser
.
registeredOpenURI
;
gBrowser
.
UrlbarProviderOpenTabs
.
unregisterOpenTab
(
uri
.
spec
userContextId
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
;
delete
this
.
mBrowser
.
registeredOpenURI
;
}
if
(
!
isBlankPageURL
(
aLocation
.
spec
)
)
{
gBrowser
.
UrlbarProviderOpenTabs
.
registerOpenTab
(
aLocation
.
spec
userContextId
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
;
this
.
mBrowser
.
registeredOpenURI
=
aLocation
;
}
if
(
this
.
mTab
!
=
gBrowser
.
selectedTab
)
{
let
tabCacheIndex
=
gBrowser
.
_tabLayerCache
.
indexOf
(
this
.
mTab
)
;
if
(
tabCacheIndex
!
=
-
1
)
{
gBrowser
.
_tabLayerCache
.
splice
(
tabCacheIndex
1
)
;
gBrowser
.
_getSwitcher
(
)
.
cleanUpTabAfterEviction
(
this
.
mTab
)
;
}
}
}
if
(
!
this
.
mBlank
|
|
this
.
mBrowser
.
hasContentOpener
)
{
this
.
_callProgressListeners
(
"
onLocationChange
"
[
aWebProgress
aRequest
aLocation
aFlags
]
)
;
if
(
topLevel
&
&
!
isSameDocument
)
{
this
.
_callProgressListeners
(
"
onContentBlockingEvent
"
[
aWebProgress
null
0
true
]
)
;
}
}
if
(
topLevel
)
{
this
.
mBrowser
.
lastURI
=
aLocation
;
this
.
mBrowser
.
lastLocationChange
=
Date
.
now
(
)
;
}
}
onStatusChange
(
aWebProgress
aRequest
aStatus
aMessage
)
{
if
(
this
.
mBlank
)
{
return
;
}
this
.
_callProgressListeners
(
"
onStatusChange
"
[
aWebProgress
aRequest
aStatus
aMessage
]
)
;
this
.
mMessage
=
aMessage
;
}
onSecurityChange
(
aWebProgress
aRequest
aState
)
{
this
.
_callProgressListeners
(
"
onSecurityChange
"
[
aWebProgress
aRequest
aState
]
)
;
}
onContentBlockingEvent
(
aWebProgress
aRequest
aEvent
)
{
this
.
_callProgressListeners
(
"
onContentBlockingEvent
"
[
aWebProgress
aRequest
aEvent
]
)
;
}
onRefreshAttempted
(
aWebProgress
aURI
aDelay
aSameURI
)
{
return
this
.
_callProgressListeners
(
"
onRefreshAttempted
"
[
aWebProgress
aURI
aDelay
aSameURI
]
)
;
}
}
TabProgressListener
.
prototype
.
QueryInterface
=
ChromeUtils
.
generateQI
(
[
"
nsIWebProgressListener
"
"
nsIWebProgressListener2
"
"
nsISupportsWeakReference
"
]
)
;
}
var
StatusPanel
=
{
get
panel
(
)
{
delete
this
.
panel
;
return
(
this
.
panel
=
document
.
getElementById
(
"
statuspanel
"
)
)
;
}
get
isVisible
(
)
{
return
!
this
.
panel
.
hasAttribute
(
"
inactive
"
)
;
}
update
(
)
{
if
(
BrowserHandler
.
kiosk
)
{
return
;
}
let
text
;
let
type
;
let
types
=
[
"
overLink
"
]
;
if
(
XULBrowserWindow
.
busyUI
)
{
types
.
push
(
"
status
"
)
;
}
types
.
push
(
"
defaultStatus
"
)
;
for
(
type
of
types
)
{
if
(
(
text
=
XULBrowserWindow
[
type
]
)
)
{
break
;
}
}
let
textCropped
=
false
;
if
(
text
.
length
>
500
&
&
text
.
match
(
/
^
data
:
[
^
]
+
;
base64
/
)
)
{
text
=
text
.
substring
(
0
500
)
+
"
\
u2026
"
;
textCropped
=
true
;
}
if
(
this
.
_labelElement
.
value
!
=
text
|
|
(
text
&
&
!
this
.
isVisible
)
)
{
this
.
panel
.
setAttribute
(
"
previoustype
"
this
.
panel
.
getAttribute
(
"
type
"
)
)
;
this
.
panel
.
setAttribute
(
"
type
"
type
)
;
this
.
_label
=
text
;
this
.
_labelElement
.
setAttribute
(
"
crop
"
type
=
=
"
overLink
"
&
&
!
textCropped
?
"
center
"
:
"
end
"
)
;
}
}
get
_labelElement
(
)
{
delete
this
.
_labelElement
;
return
(
this
.
_labelElement
=
document
.
getElementById
(
"
statuspanel
-
label
"
)
)
;
}
set
_label
(
val
)
{
if
(
!
this
.
isVisible
)
{
this
.
panel
.
removeAttribute
(
"
mirror
"
)
;
this
.
panel
.
removeAttribute
(
"
sizelimit
"
)
;
}
if
(
this
.
panel
.
getAttribute
(
"
type
"
)
=
=
"
status
"
&
&
this
.
panel
.
getAttribute
(
"
previoustype
"
)
=
=
"
status
"
)
{
this
.
panel
.
style
.
minWidth
=
window
.
windowUtils
.
getBoundsWithoutFlushing
(
this
.
panel
)
.
width
+
"
px
"
;
}
else
{
this
.
panel
.
style
.
minWidth
=
"
"
;
}
if
(
val
)
{
this
.
_labelElement
.
value
=
val
;
this
.
panel
.
removeAttribute
(
"
inactive
"
)
;
MousePosTracker
.
addListener
(
this
)
;
}
else
{
this
.
panel
.
setAttribute
(
"
inactive
"
"
true
"
)
;
MousePosTracker
.
removeListener
(
this
)
;
}
}
getMouseTargetRect
(
)
{
let
container
=
this
.
panel
.
parentNode
;
let
panelRect
=
window
.
windowUtils
.
getBoundsWithoutFlushing
(
this
.
panel
)
;
let
containerRect
=
window
.
windowUtils
.
getBoundsWithoutFlushing
(
container
)
;
return
{
top
:
panelRect
.
top
bottom
:
panelRect
.
bottom
left
:
RTL_UI
?
containerRect
.
right
-
panelRect
.
width
:
containerRect
.
left
right
:
RTL_UI
?
containerRect
.
right
:
containerRect
.
left
+
panelRect
.
width
}
;
}
onMouseEnter
(
)
{
this
.
_mirror
(
)
;
}
onMouseLeave
(
)
{
this
.
_mirror
(
)
;
}
_mirror
(
)
{
if
(
this
.
panel
.
hasAttribute
(
"
mirror
"
)
)
{
this
.
panel
.
removeAttribute
(
"
mirror
"
)
;
}
else
{
this
.
panel
.
setAttribute
(
"
mirror
"
"
true
"
)
;
}
if
(
!
this
.
panel
.
hasAttribute
(
"
sizelimit
"
)
)
{
this
.
panel
.
setAttribute
(
"
sizelimit
"
"
true
"
)
;
}
}
}
;
var
TabBarVisibility
=
{
_initialUpdateDone
:
false
update
(
)
{
let
toolbar
=
document
.
getElementById
(
"
TabsToolbar
"
)
;
let
collapse
=
false
;
if
(
!
gBrowser
|
|
gBrowser
.
visibleTabs
.
length
=
=
1
)
{
collapse
=
!
window
.
toolbar
.
visible
;
}
if
(
collapse
=
=
toolbar
.
collapsed
&
&
this
.
_initialUpdateDone
)
{
return
;
}
this
.
_initialUpdateDone
=
true
;
toolbar
.
collapsed
=
collapse
;
let
navbar
=
document
.
getElementById
(
"
nav
-
bar
"
)
;
navbar
.
setAttribute
(
"
tabs
-
hidden
"
collapse
)
;
document
.
getElementById
(
"
menu_closeWindow
"
)
.
hidden
=
collapse
;
document
.
getElementById
(
"
menu_close
"
)
.
setAttribute
(
"
label
"
gTabBrowserBundle
.
GetStringFromName
(
collapse
?
"
tabs
.
close
"
:
"
tabs
.
closeTab
"
)
)
;
TabsInTitlebar
.
allowedBy
(
"
tabs
-
visible
"
!
collapse
)
;
}
}
;
var
TabContextMenu
=
{
contextTab
:
null
_updateToggleMuteMenuItems
(
aTab
aConditionFn
)
{
[
"
muted
"
"
soundplaying
"
]
.
forEach
(
attr
=
>
{
if
(
!
aConditionFn
|
|
aConditionFn
(
attr
)
)
{
if
(
aTab
.
hasAttribute
(
attr
)
)
{
aTab
.
toggleMuteMenuItem
.
setAttribute
(
attr
"
true
"
)
;
aTab
.
toggleMultiSelectMuteMenuItem
.
setAttribute
(
attr
"
true
"
)
;
}
else
{
aTab
.
toggleMuteMenuItem
.
removeAttribute
(
attr
)
;
aTab
.
toggleMultiSelectMuteMenuItem
.
removeAttribute
(
attr
)
;
}
}
}
)
;
}
updateContextMenu
(
aPopupMenu
)
{
let
tab
=
aPopupMenu
.
triggerNode
&
&
(
aPopupMenu
.
triggerNode
.
tab
|
|
aPopupMenu
.
triggerNode
.
closest
(
"
tab
"
)
)
;
this
.
contextTab
=
tab
|
|
gBrowser
.
selectedTab
;
let
disabled
=
gBrowser
.
tabs
.
length
=
=
1
;
let
multiselectionContext
=
this
.
contextTab
.
multiselected
;
let
tabCountInfo
=
JSON
.
stringify
(
{
tabCount
:
(
multiselectionContext
&
&
gBrowser
.
multiSelectedTabsCount
)
|
|
1
}
)
;
var
menuItems
=
aPopupMenu
.
getElementsByAttribute
(
"
tbattr
"
"
tabbrowser
-
multiple
"
)
;
for
(
let
menuItem
of
menuItems
)
{
menuItem
.
disabled
=
disabled
;
}
if
(
this
.
contextTab
.
hasAttribute
(
"
customizemode
"
)
)
{
document
.
getElementById
(
"
context_openTabInWindow
"
)
.
disabled
=
true
;
}
disabled
=
gBrowser
.
visibleTabs
.
length
=
=
1
;
menuItems
=
aPopupMenu
.
getElementsByAttribute
(
"
tbattr
"
"
tabbrowser
-
multiple
-
visible
"
)
;
for
(
let
menuItem
of
menuItems
)
{
menuItem
.
disabled
=
disabled
;
}
document
.
getElementById
(
"
context_undoCloseTab
"
)
.
disabled
=
SessionStore
.
getClosedTabCount
(
window
)
=
=
0
;
showFullScreenViewContextMenuItems
(
aPopupMenu
)
;
document
.
getElementById
(
"
context_reloadTab
"
)
.
hidden
=
multiselectionContext
;
document
.
getElementById
(
"
context_reloadSelectedTabs
"
)
.
hidden
=
!
multiselectionContext
;
document
.
getElementById
(
"
context_playTab
"
)
.
hidden
=
!
(
this
.
contextTab
.
activeMediaBlocked
&
&
!
multiselectionContext
)
;
document
.
getElementById
(
"
context_playSelectedTabs
"
)
.
hidden
=
!
(
this
.
contextTab
.
activeMediaBlocked
&
&
multiselectionContext
)
;
let
contextPinTab
=
document
.
getElementById
(
"
context_pinTab
"
)
;
contextPinTab
.
hidden
=
this
.
contextTab
.
pinned
|
|
multiselectionContext
;
let
contextUnpinTab
=
document
.
getElementById
(
"
context_unpinTab
"
)
;
contextUnpinTab
.
hidden
=
!
this
.
contextTab
.
pinned
|
|
multiselectionContext
;
let
contextPinSelectedTabs
=
document
.
getElementById
(
"
context_pinSelectedTabs
"
)
;
contextPinSelectedTabs
.
hidden
=
this
.
contextTab
.
pinned
|
|
!
multiselectionContext
;
let
contextUnpinSelectedTabs
=
document
.
getElementById
(
"
context_unpinSelectedTabs
"
)
;
contextUnpinSelectedTabs
.
hidden
=
!
this
.
contextTab
.
pinned
|
|
!
multiselectionContext
;
let
contextMoveTabOptions
=
document
.
getElementById
(
"
context_moveTabOptions
"
)
;
contextMoveTabOptions
.
setAttribute
(
"
data
-
l10n
-
args
"
tabCountInfo
)
;
contextMoveTabOptions
.
disabled
=
gBrowser
.
allTabsSelected
(
)
;
let
selectedTabs
=
gBrowser
.
selectedTabs
;
let
contextMoveTabToEnd
=
document
.
getElementById
(
"
context_moveToEnd
"
)
;
let
allSelectedTabsAdjacent
=
selectedTabs
.
every
(
(
element
index
array
)
=
>
{
return
array
.
length
>
index
+
1
?
element
.
_tPos
+
1
=
=
array
[
index
+
1
]
.
_tPos
:
true
;
}
)
;
let
contextTabIsSelected
=
this
.
contextTab
.
multiselected
;
let
visibleTabs
=
gBrowser
.
visibleTabs
;
let
lastVisibleTab
=
visibleTabs
[
visibleTabs
.
length
-
1
]
;
let
tabsToMove
=
contextTabIsSelected
?
selectedTabs
:
[
this
.
contextTab
]
;
let
lastTabToMove
=
tabsToMove
[
tabsToMove
.
length
-
1
]
;
let
isLastPinnedTab
=
false
;
if
(
lastTabToMove
.
pinned
)
{
let
sibling
=
gBrowser
.
tabContainer
.
findNextTab
(
lastTabToMove
)
;
isLastPinnedTab
=
!
sibling
|
|
!
sibling
.
pinned
;
}
contextMoveTabToEnd
.
disabled
=
(
lastTabToMove
=
=
lastVisibleTab
|
|
isLastPinnedTab
)
&
&
allSelectedTabsAdjacent
;
let
contextMoveTabToStart
=
document
.
getElementById
(
"
context_moveToStart
"
)
;
let
isFirstTab
=
tabsToMove
[
0
]
=
=
visibleTabs
[
0
]
|
|
tabsToMove
[
0
]
=
=
visibleTabs
[
gBrowser
.
_numPinnedTabs
]
;
contextMoveTabToStart
.
disabled
=
isFirstTab
&
&
allSelectedTabsAdjacent
;
document
.
getElementById
(
"
context_duplicateTab
"
)
.
hidden
=
multiselectionContext
;
document
.
getElementById
(
"
context_duplicateTabs
"
)
.
hidden
=
!
multiselectionContext
;
let
closeTabsToTheStartItem
=
document
.
getElementById
(
"
context_closeTabsToTheStart
"
)
;
let
noTabsToStart
=
!
gBrowser
.
getTabsToTheStartFrom
(
this
.
contextTab
)
.
length
;
closeTabsToTheStartItem
.
disabled
=
noTabsToStart
;
let
closeTabsToTheEndItem
=
document
.
getElementById
(
"
context_closeTabsToTheEnd
"
)
;
let
noTabsToEnd
=
!
gBrowser
.
getTabsToTheEndFrom
(
this
.
contextTab
)
.
length
;
closeTabsToTheEndItem
.
disabled
=
noTabsToEnd
;
let
unpinnedTabsToClose
=
multiselectionContext
?
gBrowser
.
visibleTabs
.
filter
(
t
=
>
!
t
.
multiselected
&
&
!
t
.
pinned
)
.
length
:
gBrowser
.
visibleTabs
.
filter
(
t
=
>
t
!
=
this
.
contextTab
&
&
!
t
.
pinned
)
.
length
;
let
closeOtherTabsItem
=
document
.
getElementById
(
"
context_closeOtherTabs
"
)
;
closeOtherTabsItem
.
disabled
=
unpinnedTabsToClose
<
1
;
document
.
getElementById
(
"
context_closeTab
"
)
.
setAttribute
(
"
data
-
l10n
-
args
"
tabCountInfo
)
;
document
.
getElementById
(
"
context_closeTabOptions
"
)
.
disabled
=
closeTabsToTheStartItem
.
disabled
&
&
closeTabsToTheEndItem
.
disabled
&
&
closeOtherTabsItem
.
disabled
;
let
bookmarkTab
=
document
.
getElementById
(
"
context_bookmarkTab
"
)
;
bookmarkTab
.
hidden
=
multiselectionContext
;
let
bookmarkMultiSelectedTabs
=
document
.
getElementById
(
"
context_bookmarkSelectedTabs
"
)
;
bookmarkMultiSelectedTabs
.
hidden
=
!
multiselectionContext
;
let
toggleMute
=
document
.
getElementById
(
"
context_toggleMuteTab
"
)
;
let
toggleMultiSelectMute
=
document
.
getElementById
(
"
context_toggleMuteSelectedTabs
"
)
;
toggleMute
.
hidden
=
multiselectionContext
;
toggleMultiSelectMute
.
hidden
=
!
multiselectionContext
;
if
(
this
.
contextTab
.
hasAttribute
(
"
muted
"
)
)
{
toggleMute
.
label
=
gNavigatorBundle
.
getString
(
"
unmuteTab
.
label
"
)
;
toggleMute
.
accessKey
=
gNavigatorBundle
.
getString
(
"
unmuteTab
.
accesskey
"
)
;
}
else
{
toggleMute
.
label
=
gNavigatorBundle
.
getString
(
"
muteTab
.
label
"
)
;
toggleMute
.
accessKey
=
gNavigatorBundle
.
getString
(
"
muteTab
.
accesskey
"
)
;
}
if
(
this
.
contextTab
.
hasAttribute
(
"
muted
"
)
)
{
toggleMultiSelectMute
.
label
=
gNavigatorBundle
.
getString
(
"
unmuteSelectedTabs2
.
label
"
)
;
toggleMultiSelectMute
.
accessKey
=
gNavigatorBundle
.
getString
(
"
unmuteSelectedTabs2
.
accesskey
"
)
;
}
else
{
toggleMultiSelectMute
.
label
=
gNavigatorBundle
.
getString
(
"
muteSelectedTabs2
.
label
"
)
;
toggleMultiSelectMute
.
accessKey
=
gNavigatorBundle
.
getString
(
"
muteSelectedTabs2
.
accesskey
"
)
;
}
this
.
contextTab
.
toggleMuteMenuItem
=
toggleMute
;
this
.
contextTab
.
toggleMultiSelectMuteMenuItem
=
toggleMultiSelectMute
;
this
.
_updateToggleMuteMenuItems
(
this
.
contextTab
)
;
let
selectAllTabs
=
document
.
getElementById
(
"
context_selectAllTabs
"
)
;
selectAllTabs
.
disabled
=
gBrowser
.
allTabsSelected
(
)
;
this
.
contextTab
.
addEventListener
(
"
TabAttrModified
"
this
)
;
aPopupMenu
.
addEventListener
(
"
popuphiding
"
this
)
;
gSync
.
updateTabContextMenu
(
aPopupMenu
this
.
contextTab
)
;
document
.
getElementById
(
"
context_reopenInContainer
"
)
.
hidden
=
!
Services
.
prefs
.
getBoolPref
(
"
privacy
.
userContext
.
enabled
"
false
)
|
|
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
;
gShareUtils
.
updateShareURLMenuItem
(
this
.
contextTab
.
linkedBrowser
document
.
getElementById
(
"
context_sendTabToDevice
"
)
)
;
}
handleEvent
(
aEvent
)
{
switch
(
aEvent
.
type
)
{
case
"
popuphiding
"
:
if
(
aEvent
.
target
.
id
=
=
"
tabContextMenu
"
)
{
this
.
contextTab
.
removeEventListener
(
"
TabAttrModified
"
this
)
;
}
break
;
case
"
TabAttrModified
"
:
let
tab
=
aEvent
.
target
;
this
.
_updateToggleMuteMenuItems
(
tab
attr
=
>
aEvent
.
detail
.
changed
.
includes
(
attr
)
)
;
break
;
}
}
createReopenInContainerMenu
(
event
)
{
createUserContextMenu
(
event
{
isContextMenu
:
true
excludeUserContextId
:
this
.
contextTab
.
getAttribute
(
"
usercontextid
"
)
}
)
;
}
duplicateSelectedTabs
(
)
{
let
tabsToDuplicate
=
gBrowser
.
selectedTabs
;
let
newIndex
=
tabsToDuplicate
[
tabsToDuplicate
.
length
-
1
]
.
_tPos
+
1
;
for
(
let
tab
of
tabsToDuplicate
)
{
let
newTab
=
SessionStore
.
duplicateTab
(
window
tab
)
;
gBrowser
.
moveTabTo
(
newTab
newIndex
+
+
)
;
}
}
reopenInContainer
(
event
)
{
let
userContextId
=
parseInt
(
event
.
target
.
getAttribute
(
"
data
-
usercontextid
"
)
)
;
let
reopenedTabs
=
this
.
contextTab
.
multiselected
?
gBrowser
.
selectedTabs
:
[
this
.
contextTab
]
;
for
(
let
tab
of
reopenedTabs
)
{
if
(
tab
.
getAttribute
(
"
usercontextid
"
)
=
=
userContextId
)
{
continue
;
}
let
triggeringPrincipal
;
if
(
tab
.
linkedPanel
)
{
triggeringPrincipal
=
tab
.
linkedBrowser
.
contentPrincipal
;
}
else
{
let
tabState
=
JSON
.
parse
(
SessionStore
.
getTabState
(
tab
)
)
;
try
{
triggeringPrincipal
=
E10SUtils
.
deserializePrincipal
(
tabState
.
triggeringPrincipal_base64
)
;
}
catch
(
ex
)
{
continue
;
}
}
if
(
!
triggeringPrincipal
|
|
triggeringPrincipal
.
isNullPrincipal
)
{
triggeringPrincipal
=
Services
.
scriptSecurityManager
.
createNullPrincipal
(
{
userContextId
}
)
;
}
else
if
(
triggeringPrincipal
.
isContentPrincipal
)
{
triggeringPrincipal
=
Services
.
scriptSecurityManager
.
principalWithOA
(
triggeringPrincipal
{
userContextId
}
)
;
}
let
newTab
=
gBrowser
.
addTab
(
tab
.
linkedBrowser
.
currentURI
.
spec
{
userContextId
pinned
:
tab
.
pinned
index
:
tab
.
_tPos
+
1
triggeringPrincipal
}
)
;
if
(
gBrowser
.
selectedTab
=
=
tab
)
{
gBrowser
.
selectedTab
=
newTab
;
}
if
(
tab
.
muted
&
&
!
newTab
.
muted
)
{
newTab
.
toggleMuteAudio
(
tab
.
muteReason
)
;
}
}
}
closeContextTabs
(
event
)
{
if
(
this
.
contextTab
.
multiselected
)
{
gBrowser
.
removeMultiSelectedTabs
(
)
;
}
else
{
gBrowser
.
removeTab
(
this
.
contextTab
{
animate
:
true
}
)
;
}
}
}
;
