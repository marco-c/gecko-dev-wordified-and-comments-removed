var
Ci
=
Components
.
interfaces
;
var
Cu
=
Components
.
utils
;
var
Cc
=
Components
.
classes
;
var
Cr
=
Components
.
results
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
NotificationDB
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
extensionNameFromURI
"
(
)
=
>
{
return
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionParent
.
jsm
"
{
}
)
.
extensionNameFromURI
;
}
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AboutHome
:
"
resource
:
/
/
/
modules
/
AboutHome
.
jsm
"
BrowserUITelemetry
:
"
resource
:
/
/
/
modules
/
BrowserUITelemetry
.
jsm
"
BrowserUsageTelemetry
:
"
resource
:
/
/
/
modules
/
BrowserUsageTelemetry
.
jsm
"
BrowserUtils
:
"
resource
:
/
/
gre
/
modules
/
BrowserUtils
.
jsm
"
CastingApps
:
"
resource
:
/
/
/
modules
/
CastingApps
.
jsm
"
CharsetMenu
:
"
resource
:
/
/
gre
/
modules
/
CharsetMenu
.
jsm
"
Color
:
"
resource
:
/
/
gre
/
modules
/
Color
.
jsm
"
ContentSearch
:
"
resource
:
/
/
/
modules
/
ContentSearch
.
jsm
"
ContextualIdentityService
:
"
resource
:
/
/
gre
/
modules
/
ContextualIdentityService
.
jsm
"
CustomizableUI
:
"
resource
:
/
/
/
modules
/
CustomizableUI
.
jsm
"
Deprecated
:
"
resource
:
/
/
gre
/
modules
/
Deprecated
.
jsm
"
DownloadsCommon
:
"
resource
:
/
/
/
modules
/
DownloadsCommon
.
jsm
"
E10SUtils
:
"
resource
:
/
/
/
modules
/
E10SUtils
.
jsm
"
ExtensionsUI
:
"
resource
:
/
/
/
modules
/
ExtensionsUI
.
jsm
"
FormValidationHandler
:
"
resource
:
/
/
/
modules
/
FormValidationHandler
.
jsm
"
LightweightThemeManager
:
"
resource
:
/
/
gre
/
modules
/
LightweightThemeManager
.
jsm
"
Log
:
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
LoginManagerParent
:
"
resource
:
/
/
gre
/
modules
/
LoginManagerParent
.
jsm
"
NewTabUtils
:
"
resource
:
/
/
gre
/
modules
/
NewTabUtils
.
jsm
"
PageActions
:
"
resource
:
/
/
/
modules
/
PageActions
.
jsm
"
PageThumbs
:
"
resource
:
/
/
gre
/
modules
/
PageThumbs
.
jsm
"
PluralForm
:
"
resource
:
/
/
gre
/
modules
/
PluralForm
.
jsm
"
PrivateBrowsingUtils
:
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
ProcessHangMonitor
:
"
resource
:
/
/
/
modules
/
ProcessHangMonitor
.
jsm
"
PromiseUtils
:
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
ReaderMode
:
"
resource
:
/
/
gre
/
modules
/
ReaderMode
.
jsm
"
ReaderParent
:
"
resource
:
/
/
/
modules
/
ReaderParent
.
jsm
"
RecentWindow
:
"
resource
:
/
/
/
modules
/
RecentWindow
.
jsm
"
SafeBrowsing
:
"
resource
:
/
/
gre
/
modules
/
SafeBrowsing
.
jsm
"
SessionStore
:
"
resource
:
/
/
/
modules
/
sessionstore
/
SessionStore
.
jsm
"
ShortcutUtils
:
"
resource
:
/
/
gre
/
modules
/
ShortcutUtils
.
jsm
"
SimpleServiceDiscovery
:
"
resource
:
/
/
gre
/
modules
/
SimpleServiceDiscovery
.
jsm
"
SitePermissions
:
"
resource
:
/
/
/
modules
/
SitePermissions
.
jsm
"
Social
:
"
resource
:
/
/
/
modules
/
Social
.
jsm
"
TabCrashHandler
:
"
resource
:
/
/
/
modules
/
ContentCrashHandlers
.
jsm
"
TelemetryStopwatch
:
"
resource
:
/
/
gre
/
modules
/
TelemetryStopwatch
.
jsm
"
Translation
:
"
resource
:
/
/
/
modules
/
translation
/
Translation
.
jsm
"
UITour
:
"
resource
:
/
/
/
modules
/
UITour
.
jsm
"
UpdateUtils
:
"
resource
:
/
/
gre
/
modules
/
UpdateUtils
.
jsm
"
Utils
:
"
resource
:
/
/
gre
/
modules
/
sessionstore
/
Utils
.
jsm
"
Weave
:
"
resource
:
/
/
services
-
sync
/
main
.
js
"
WebNavigationFrames
:
"
resource
:
/
/
gre
/
modules
/
WebNavigationFrames
.
jsm
"
fxAccounts
:
"
resource
:
/
/
gre
/
modules
/
FxAccounts
.
jsm
"
gDevTools
:
"
resource
:
/
/
devtools
/
client
/
framework
/
gDevTools
.
jsm
"
gDevToolsBrowser
:
"
resource
:
/
/
devtools
/
client
/
framework
/
gDevTools
.
jsm
"
webrtcUI
:
"
resource
:
/
/
/
modules
/
webrtcUI
.
jsm
"
ZoomUI
:
"
resource
:
/
/
/
modules
/
ZoomUI
.
jsm
"
}
)
;
if
(
AppConstants
.
MOZ_CRASHREPORTER
)
{
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PluginCrashReporter
"
"
resource
:
/
/
/
modules
/
ContentCrashHandlers
.
jsm
"
)
;
}
XPCOMUtils
.
defineLazyScriptGetter
(
this
"
PrintUtils
"
"
chrome
:
/
/
global
/
content
/
printUtils
.
js
"
)
;
XPCOMUtils
.
defineLazyScriptGetter
(
this
"
ZoomManager
"
"
chrome
:
/
/
global
/
content
/
viewZoomOverlay
.
js
"
)
;
XPCOMUtils
.
defineLazyScriptGetter
(
this
"
FullZoom
"
"
chrome
:
/
/
browser
/
content
/
browser
-
fullZoom
.
js
"
)
;
XPCOMUtils
.
defineLazyScriptGetter
(
this
"
PanelUI
"
"
chrome
:
/
/
browser
/
content
/
customizableui
/
panelUI
.
js
"
)
;
XPCOMUtils
.
defineLazyScriptGetter
(
this
"
gViewSourceUtils
"
"
chrome
:
/
/
global
/
content
/
viewSourceUtils
.
js
"
)
;
XPCOMUtils
.
defineLazyScriptGetter
(
this
[
"
LightWeightThemeWebInstaller
"
"
gExtensionsNotifications
"
"
gXPInstallObserver
"
]
"
chrome
:
/
/
browser
/
content
/
browser
-
addons
.
js
"
)
;
XPCOMUtils
.
defineLazyScriptGetter
(
this
"
ctrlTab
"
"
chrome
:
/
/
browser
/
content
/
browser
-
ctrlTab
.
js
"
)
;
XPCOMUtils
.
defineLazyScriptGetter
(
this
"
CustomizationHandler
"
"
chrome
:
/
/
browser
/
content
/
browser
-
customization
.
js
"
)
;
XPCOMUtils
.
defineLazyScriptGetter
(
this
[
"
PointerLock
"
"
FullScreen
"
]
"
chrome
:
/
/
browser
/
content
/
browser
-
fullScreenAndPointerLock
.
js
"
)
;
XPCOMUtils
.
defineLazyScriptGetter
(
this
[
"
gGestureSupport
"
"
gHistorySwipeAnimation
"
]
"
chrome
:
/
/
browser
/
content
/
browser
-
gestureSupport
.
js
"
)
;
XPCOMUtils
.
defineLazyScriptGetter
(
this
"
gSafeBrowsing
"
"
chrome
:
/
/
browser
/
content
/
browser
-
safebrowsing
.
js
"
)
;
XPCOMUtils
.
defineLazyScriptGetter
(
this
[
"
SocialUI
"
"
SocialShare
"
"
SocialActivationListener
"
]
"
chrome
:
/
/
browser
/
content
/
browser
-
social
.
js
"
)
;
XPCOMUtils
.
defineLazyScriptGetter
(
this
"
gSync
"
"
chrome
:
/
/
browser
/
content
/
browser
-
sync
.
js
"
)
;
XPCOMUtils
.
defineLazyScriptGetter
(
this
"
gBrowserThumbnails
"
"
chrome
:
/
/
browser
/
content
/
browser
-
thumbnails
.
js
"
)
;
XPCOMUtils
.
defineLazyScriptGetter
(
this
[
"
setContextMenuContentData
"
"
openContextMenu
"
"
nsContextMenu
"
]
"
chrome
:
/
/
browser
/
content
/
nsContextMenu
.
js
"
)
;
XPCOMUtils
.
defineLazyScriptGetter
(
this
[
"
DownloadsPanel
"
"
DownloadsOverlayLoader
"
"
DownloadsView
"
"
DownloadsViewUI
"
"
DownloadsViewController
"
"
DownloadsSummary
"
"
DownloadsFooter
"
"
DownloadsBlockedSubview
"
]
"
chrome
:
/
/
browser
/
content
/
downloads
/
downloads
.
js
"
)
;
XPCOMUtils
.
defineLazyScriptGetter
(
this
[
"
DownloadsButton
"
"
DownloadsIndicatorView
"
]
"
chrome
:
/
/
browser
/
content
/
downloads
/
indicator
.
js
"
)
;
XPCOMUtils
.
defineLazyScriptGetter
(
this
"
gEditItemOverlay
"
"
chrome
:
/
/
browser
/
content
/
places
/
editBookmarkOverlay
.
js
"
)
;
XPCOMUtils
.
defineLazyServiceGetters
(
this
{
Favicons
:
[
"
mozilla
.
org
/
browser
/
favicon
-
service
;
1
"
"
mozIAsyncFavicons
"
]
gAboutNewTabService
:
[
"
mozilla
.
org
/
browser
/
aboutnewtab
-
service
;
1
"
"
nsIAboutNewTabService
"
]
gDNSService
:
[
"
mozilla
.
org
/
network
/
dns
-
service
;
1
"
"
nsIDNSService
"
]
gSerializationHelper
:
[
"
mozilla
.
org
/
network
/
serialization
-
helper
;
1
"
"
nsISerializationHelper
"
]
Marionette
:
[
"
mozilla
.
org
/
remote
/
marionette
;
1
"
"
nsIMarionette
"
]
WindowsUIUtils
:
[
"
mozilla
.
org
/
windows
-
ui
-
utils
;
1
"
"
nsIWindowsUIUtils
"
]
}
)
;
if
(
AppConstants
.
MOZ_CRASHREPORTER
)
{
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
gCrashReporter
"
"
mozilla
.
org
/
xre
/
app
-
info
;
1
"
"
nsICrashReporter
"
)
;
}
XPCOMUtils
.
defineLazyGetter
(
this
"
BrowserToolboxProcess
"
function
(
)
{
let
tmp
=
{
}
;
Cu
.
import
(
"
resource
:
/
/
devtools
/
client
/
framework
/
ToolboxProcess
.
jsm
"
tmp
)
;
return
tmp
.
BrowserToolboxProcess
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gBrowserBundle
"
function
(
)
{
return
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
browser
/
locale
/
browser
.
properties
"
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gCustomizeMode
"
function
(
)
{
let
scope
=
{
}
;
Cu
.
import
(
"
resource
:
/
/
/
modules
/
CustomizeMode
.
jsm
"
scope
)
;
return
new
scope
.
CustomizeMode
(
window
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gPrefService
"
function
(
)
{
return
Services
.
prefs
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
InlineSpellCheckerUI
"
function
(
)
{
let
tmp
=
{
}
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
InlineSpellChecker
.
jsm
"
tmp
)
;
return
new
tmp
.
InlineSpellChecker
(
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
PageMenuParent
"
function
(
)
{
let
tmp
=
{
}
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
PageMenu
.
jsm
"
tmp
)
;
return
new
tmp
.
PageMenuParent
(
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
PopupNotifications
"
function
(
)
{
let
tmp
=
{
}
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
PopupNotifications
.
jsm
"
tmp
)
;
try
{
let
shouldSuppress
=
(
)
=
>
{
return
window
.
windowState
=
=
window
.
STATE_MINIMIZED
|
|
(
gURLBar
.
getAttribute
(
"
pageproxystate
"
)
!
=
"
valid
"
&
&
gURLBar
.
focused
)
;
}
;
return
new
tmp
.
PopupNotifications
(
gBrowser
document
.
getElementById
(
"
notification
-
popup
"
)
document
.
getElementById
(
"
notification
-
popup
-
box
"
)
{
shouldSuppress
}
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
return
null
;
}
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
Win7Features
"
function
(
)
{
if
(
AppConstants
.
platform
!
=
"
win
"
)
return
null
;
const
WINTASKBAR_CONTRACTID
=
"
mozilla
.
org
/
windows
-
taskbar
;
1
"
;
if
(
WINTASKBAR_CONTRACTID
in
Cc
&
&
Cc
[
WINTASKBAR_CONTRACTID
]
.
getService
(
Ci
.
nsIWinTaskbar
)
.
available
)
{
let
AeroPeek
=
Cu
.
import
(
"
resource
:
/
/
/
modules
/
WindowsPreviewPerTab
.
jsm
"
{
}
)
.
AeroPeek
;
return
{
onOpenWindow
(
)
{
AeroPeek
.
onOpenWindow
(
window
)
;
}
onCloseWindow
(
)
{
AeroPeek
.
onCloseWindow
(
window
)
;
}
}
;
}
return
null
;
}
)
;
const
nsIWebNavigation
=
Ci
.
nsIWebNavigation
;
var
gLastBrowserCharset
=
null
;
var
gLastValidURLStr
=
"
"
;
var
gInPrintPreviewMode
=
false
;
var
gContextMenu
=
null
;
var
gMultiProcessBrowser
=
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebNavigation
)
.
QueryInterface
(
Ci
.
nsILoadContext
)
.
useRemoteTabs
;
var
gAppInfo
=
Cc
[
"
mozilla
.
org
/
xre
/
app
-
info
;
1
"
]
.
getService
(
Ci
.
nsIXULAppInfo
)
.
QueryInterface
(
Ci
.
nsIXULRuntime
)
;
if
(
AppConstants
.
platform
!
=
"
macosx
"
)
{
var
gEditUIVisible
=
true
;
}
[
[
"
gBrowser
"
"
content
"
]
[
"
gNavToolbox
"
"
navigator
-
toolbox
"
]
[
"
gURLBar
"
"
urlbar
"
]
[
"
gNavigatorBundle
"
"
bundle_browser
"
]
]
.
forEach
(
function
(
elementGlobal
)
{
var
[
name
id
]
=
elementGlobal
;
Object
.
defineProperty
(
window
name
{
configurable
:
true
enumerable
:
true
get
(
)
{
var
element
=
document
.
getElementById
(
id
)
;
if
(
!
element
)
return
null
;
delete
window
[
name
]
;
return
window
[
name
]
=
element
;
}
set
(
val
)
{
delete
window
[
name
]
;
return
window
[
name
]
=
val
;
}
}
)
;
}
)
;
Object
.
defineProperty
(
this
"
gFindBar
"
{
configurable
:
true
enumerable
:
true
get
(
)
{
return
window
.
gBrowser
.
getFindBar
(
)
;
}
}
)
;
Object
.
defineProperty
(
this
"
gFindBarInitialized
"
{
configurable
:
true
enumerable
:
true
get
(
)
{
return
window
.
gBrowser
.
isFindBarInitialized
(
)
;
}
}
)
;
Object
.
defineProperty
(
this
"
AddonManager
"
{
configurable
:
true
enumerable
:
true
get
(
)
{
let
tmp
=
{
}
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
tmp
)
;
return
this
.
AddonManager
=
tmp
.
AddonManager
;
}
set
(
val
)
{
delete
this
.
AddonManager
;
return
this
.
AddonManager
=
val
;
}
}
)
;
var
gInitialPages
=
[
"
about
:
blank
"
"
about
:
newtab
"
"
about
:
home
"
"
about
:
privatebrowsing
"
"
about
:
welcomeback
"
"
about
:
sessionrestore
"
]
;
function
*
browserWindows
(
)
{
let
windows
=
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
;
while
(
windows
.
hasMoreElements
(
)
)
yield
windows
.
getNext
(
)
;
}
function
pageShowEventHandlers
(
persisted
)
{
XULBrowserWindow
.
asyncUpdateUI
(
)
;
}
function
UpdateBackForwardCommands
(
aWebNavigation
)
{
var
backBroadcaster
=
document
.
getElementById
(
"
Browser
:
Back
"
)
;
var
forwardBroadcaster
=
document
.
getElementById
(
"
Browser
:
Forward
"
)
;
var
backDisabled
=
backBroadcaster
.
hasAttribute
(
"
disabled
"
)
;
var
forwardDisabled
=
forwardBroadcaster
.
hasAttribute
(
"
disabled
"
)
;
if
(
backDisabled
=
=
aWebNavigation
.
canGoBack
)
{
if
(
backDisabled
)
backBroadcaster
.
removeAttribute
(
"
disabled
"
)
;
else
backBroadcaster
.
setAttribute
(
"
disabled
"
true
)
;
}
if
(
forwardDisabled
=
=
aWebNavigation
.
canGoForward
)
{
if
(
forwardDisabled
)
forwardBroadcaster
.
removeAttribute
(
"
disabled
"
)
;
else
forwardBroadcaster
.
setAttribute
(
"
disabled
"
true
)
;
}
}
function
SetClickAndHoldHandlers
(
)
{
let
popup
=
document
.
getElementById
(
"
backForwardMenu
"
)
.
cloneNode
(
true
)
;
popup
.
removeAttribute
(
"
id
"
)
;
popup
.
setAttribute
(
"
context
"
"
"
)
;
let
backButton
=
document
.
getElementById
(
"
back
-
button
"
)
;
backButton
.
setAttribute
(
"
type
"
"
menu
"
)
;
backButton
.
appendChild
(
popup
)
;
gClickAndHoldListenersOnElement
.
add
(
backButton
)
;
let
forwardButton
=
document
.
getElementById
(
"
forward
-
button
"
)
;
popup
=
popup
.
cloneNode
(
true
)
;
forwardButton
.
setAttribute
(
"
type
"
"
menu
"
)
;
forwardButton
.
appendChild
(
popup
)
;
gClickAndHoldListenersOnElement
.
add
(
forwardButton
)
;
}
const
gClickAndHoldListenersOnElement
=
{
_timers
:
new
Map
(
)
_mousedownHandler
(
aEvent
)
{
if
(
aEvent
.
button
!
=
0
|
|
aEvent
.
currentTarget
.
open
|
|
aEvent
.
currentTarget
.
disabled
)
return
;
aEvent
.
currentTarget
.
firstChild
.
hidden
=
true
;
aEvent
.
currentTarget
.
addEventListener
(
"
mouseout
"
this
)
;
aEvent
.
currentTarget
.
addEventListener
(
"
mouseup
"
this
)
;
this
.
_timers
.
set
(
aEvent
.
currentTarget
setTimeout
(
(
b
)
=
>
this
.
_openMenu
(
b
)
500
aEvent
.
currentTarget
)
)
;
}
_clickHandler
(
aEvent
)
{
if
(
aEvent
.
button
=
=
0
&
&
aEvent
.
target
=
=
aEvent
.
currentTarget
&
&
!
aEvent
.
currentTarget
.
open
&
&
!
aEvent
.
currentTarget
.
disabled
)
{
let
cmdEvent
=
document
.
createEvent
(
"
xulcommandevent
"
)
;
cmdEvent
.
initCommandEvent
(
"
command
"
true
true
window
0
aEvent
.
ctrlKey
aEvent
.
altKey
aEvent
.
shiftKey
aEvent
.
metaKey
null
aEvent
.
mozInputSource
)
;
aEvent
.
currentTarget
.
dispatchEvent
(
cmdEvent
)
;
aEvent
.
preventDefault
(
)
;
}
}
_openMenu
(
aButton
)
{
this
.
_cancelHold
(
aButton
)
;
aButton
.
firstChild
.
hidden
=
false
;
aButton
.
open
=
true
;
}
_mouseoutHandler
(
aEvent
)
{
let
buttonRect
=
aEvent
.
currentTarget
.
getBoundingClientRect
(
)
;
if
(
aEvent
.
clientX
>
=
buttonRect
.
left
&
&
aEvent
.
clientX
<
=
buttonRect
.
right
&
&
aEvent
.
clientY
>
=
buttonRect
.
bottom
)
this
.
_openMenu
(
aEvent
.
currentTarget
)
;
else
this
.
_cancelHold
(
aEvent
.
currentTarget
)
;
}
_mouseupHandler
(
aEvent
)
{
this
.
_cancelHold
(
aEvent
.
currentTarget
)
;
}
_cancelHold
(
aButton
)
{
clearTimeout
(
this
.
_timers
.
get
(
aButton
)
)
;
aButton
.
removeEventListener
(
"
mouseout
"
this
)
;
aButton
.
removeEventListener
(
"
mouseup
"
this
)
;
}
handleEvent
(
e
)
{
switch
(
e
.
type
)
{
case
"
mouseout
"
:
this
.
_mouseoutHandler
(
e
)
;
break
;
case
"
mousedown
"
:
this
.
_mousedownHandler
(
e
)
;
break
;
case
"
click
"
:
this
.
_clickHandler
(
e
)
;
break
;
case
"
mouseup
"
:
this
.
_mouseupHandler
(
e
)
;
break
;
}
}
remove
(
aButton
)
{
aButton
.
removeEventListener
(
"
mousedown
"
this
true
)
;
aButton
.
removeEventListener
(
"
click
"
this
true
)
;
}
add
(
aElm
)
{
this
.
_timers
.
delete
(
aElm
)
;
aElm
.
addEventListener
(
"
mousedown
"
this
true
)
;
aElm
.
addEventListener
(
"
click
"
this
true
)
;
}
}
;
const
gSessionHistoryObserver
=
{
observe
(
subject
topic
data
)
{
if
(
topic
!
=
"
browser
:
purge
-
session
-
history
"
)
return
;
var
backCommand
=
document
.
getElementById
(
"
Browser
:
Back
"
)
;
backCommand
.
setAttribute
(
"
disabled
"
"
true
"
)
;
var
fwdCommand
=
document
.
getElementById
(
"
Browser
:
Forward
"
)
;
fwdCommand
.
setAttribute
(
"
disabled
"
"
true
"
)
;
window
.
messageManager
.
broadcastAsyncMessage
(
"
Browser
:
HideSessionRestoreButton
"
)
;
gURLBar
.
editor
.
transactionManager
.
clear
(
)
}
}
;
const
gStoragePressureObserver
=
{
_lastNotificationTime
:
-
1
observe
(
subject
topic
data
)
{
if
(
topic
!
=
"
QuotaManager
:
:
StoragePressure
"
|
|
!
Services
.
prefs
.
getBoolPref
(
"
browser
.
storageManager
.
enabled
"
)
)
{
return
;
}
const
MIN_NOTIFICATION_INTERVAL_MS
=
Services
.
prefs
.
getIntPref
(
"
browser
.
storageManager
.
pressureNotification
.
minIntervalMS
"
)
;
let
duration
=
Date
.
now
(
)
-
this
.
_lastNotificationTime
;
if
(
duration
<
=
MIN_NOTIFICATION_INTERVAL_MS
)
{
return
;
}
this
.
_lastNotificationTime
=
Date
.
now
(
)
;
const
BYTES_IN_GIGABYTE
=
1073741824
;
const
USAGE_THRESHOLD_BYTES
=
BYTES_IN_GIGABYTE
*
Services
.
prefs
.
getIntPref
(
"
browser
.
storageManager
.
pressureNotification
.
usageThresholdGB
"
)
;
let
msg
=
"
"
;
let
buttons
=
[
]
;
let
usage
=
subject
.
QueryInterface
(
Ci
.
nsISupportsPRUint64
)
.
data
let
prefStrBundle
=
document
.
getElementById
(
"
bundle_preferences
"
)
;
let
brandShortName
=
document
.
getElementById
(
"
bundle_brand
"
)
.
getString
(
"
brandShortName
"
)
;
let
notificationBox
=
document
.
getElementById
(
"
high
-
priority
-
global
-
notificationbox
"
)
;
buttons
.
push
(
{
label
:
prefStrBundle
.
getString
(
"
spaceAlert
.
learnMoreButton
.
label
"
)
accessKey
:
prefStrBundle
.
getString
(
"
spaceAlert
.
learnMoreButton
.
accesskey
"
)
callback
(
notificationBar
button
)
{
let
learnMoreURL
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
+
"
storage
-
permissions
"
;
gBrowser
.
selectedTab
=
gBrowser
.
addTab
(
learnMoreURL
)
;
}
}
)
;
if
(
usage
<
USAGE_THRESHOLD_BYTES
)
{
msg
=
prefStrBundle
.
getFormattedString
(
"
spaceAlert
.
under5GB
.
message
"
[
brandShortName
]
)
;
buttons
.
push
(
{
label
:
prefStrBundle
.
getString
(
"
spaceAlert
.
under5GB
.
okButton
.
label
"
)
accessKey
:
prefStrBundle
.
getString
(
"
spaceAlert
.
under5GB
.
okButton
.
accesskey
"
)
callback
(
)
{
}
}
)
;
}
else
{
let
descriptionStringID
=
"
spaceAlert
.
over5GB
.
message
"
;
let
prefButtonLabelStringID
=
"
spaceAlert
.
over5GB
.
prefButton
.
label
"
;
let
prefButtonAccesskeyStringID
=
"
spaceAlert
.
over5GB
.
prefButton
.
accesskey
"
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
descriptionStringID
=
"
spaceAlert
.
over5GB
.
messageWin
"
;
prefButtonLabelStringID
=
"
spaceAlert
.
over5GB
.
prefButtonWin
.
label
"
;
prefButtonAccesskeyStringID
=
"
spaceAlert
.
over5GB
.
prefButtonWin
.
accesskey
"
;
}
msg
=
prefStrBundle
.
getFormattedString
(
descriptionStringID
[
brandShortName
]
)
;
buttons
.
push
(
{
label
:
prefStrBundle
.
getString
(
prefButtonLabelStringID
)
accessKey
:
prefStrBundle
.
getString
(
prefButtonAccesskeyStringID
)
callback
(
notificationBar
button
)
{
let
win
=
gBrowser
.
ownerGlobal
;
if
(
Services
.
prefs
.
getBoolPref
(
"
browser
.
preferences
.
useOldOrganization
"
)
)
{
win
.
openAdvancedPreferences
(
"
networkTab
"
{
origin
:
"
storagePressure
"
}
)
;
}
else
{
win
.
openPreferences
(
"
panePrivacy
"
{
origin
:
"
storagePressure
"
}
)
;
}
}
}
)
;
}
notificationBox
.
appendNotification
(
msg
"
storage
-
pressure
-
notification
"
null
notificationBox
.
PRIORITY_WARNING_HIGH
buttons
null
)
;
}
}
;
function
findChildShell
(
aDocument
aDocShell
aSoughtURI
)
{
aDocShell
.
QueryInterface
(
Components
.
interfaces
.
nsIWebNavigation
)
;
aDocShell
.
QueryInterface
(
Components
.
interfaces
.
nsIInterfaceRequestor
)
;
var
doc
=
aDocShell
.
getInterface
(
Components
.
interfaces
.
nsIDOMDocument
)
;
if
(
(
aDocument
&
&
doc
=
=
aDocument
)
|
|
(
aSoughtURI
&
&
aSoughtURI
.
spec
=
=
aDocShell
.
currentURI
.
spec
)
)
return
aDocShell
;
var
node
=
aDocShell
.
QueryInterface
(
Components
.
interfaces
.
nsIDocShellTreeItem
)
;
for
(
var
i
=
0
;
i
<
node
.
childCount
;
+
+
i
)
{
var
docShell
=
node
.
getChildAt
(
i
)
;
docShell
=
findChildShell
(
aDocument
docShell
aSoughtURI
)
;
if
(
docShell
)
return
docShell
;
}
return
null
;
}
var
gPopupBlockerObserver
=
{
_reportButton
:
null
onReportButtonMousedown
(
aEvent
)
{
if
(
aEvent
.
button
!
=
0
|
|
aEvent
.
target
!
=
this
.
_reportButton
|
|
this
.
isPopupHidingTick
)
return
;
this
.
_reportButton
.
addEventListener
(
"
click
"
event
=
>
{
document
.
getElementById
(
"
blockedPopupOptions
"
)
.
openPopup
(
event
.
target
"
after_end
"
0
2
false
false
event
)
;
}
{
once
:
true
}
)
;
}
handleEvent
(
aEvent
)
{
if
(
aEvent
.
originalTarget
!
=
gBrowser
.
selectedBrowser
)
return
;
if
(
!
this
.
_reportButton
)
this
.
_reportButton
=
document
.
getElementById
(
"
page
-
report
-
button
"
)
;
if
(
!
gBrowser
.
selectedBrowser
.
blockedPopups
|
|
!
gBrowser
.
selectedBrowser
.
blockedPopups
.
length
)
{
this
.
_reportButton
.
hidden
=
true
;
let
notificationBox
=
gBrowser
.
getNotificationBox
(
)
;
let
notification
=
notificationBox
.
getNotificationWithValue
(
"
popup
-
blocked
"
)
;
if
(
notification
)
{
notificationBox
.
removeNotification
(
notification
false
)
;
}
return
;
}
this
.
_reportButton
.
hidden
=
false
;
if
(
!
gBrowser
.
selectedBrowser
.
blockedPopups
.
reported
)
{
if
(
gPrefService
.
getBoolPref
(
"
privacy
.
popups
.
showBrowserMessage
"
)
)
{
var
brandBundle
=
document
.
getElementById
(
"
bundle_brand
"
)
;
var
brandShortName
=
brandBundle
.
getString
(
"
brandShortName
"
)
;
var
popupCount
=
gBrowser
.
selectedBrowser
.
blockedPopups
.
length
;
var
stringKey
=
AppConstants
.
platform
=
=
"
win
"
?
"
popupWarningButton
"
:
"
popupWarningButtonUnix
"
;
var
popupButtonText
=
gNavigatorBundle
.
getString
(
stringKey
)
;
var
popupButtonAccesskey
=
gNavigatorBundle
.
getString
(
stringKey
+
"
.
accesskey
"
)
;
var
messageBase
=
gNavigatorBundle
.
getString
(
"
popupWarning
.
message
"
)
;
var
message
=
PluralForm
.
get
(
popupCount
messageBase
)
.
replace
(
"
#
1
"
brandShortName
)
.
replace
(
"
#
2
"
popupCount
)
;
let
notificationBox
=
gBrowser
.
getNotificationBox
(
)
;
let
notification
=
notificationBox
.
getNotificationWithValue
(
"
popup
-
blocked
"
)
;
if
(
notification
)
{
notification
.
label
=
message
;
}
else
{
var
buttons
=
[
{
label
:
popupButtonText
accessKey
:
popupButtonAccesskey
popup
:
"
blockedPopupOptions
"
callback
:
null
}
]
;
const
priority
=
notificationBox
.
PRIORITY_WARNING_MEDIUM
;
notificationBox
.
appendNotification
(
message
"
popup
-
blocked
"
"
chrome
:
/
/
browser
/
skin
/
Info
.
png
"
priority
buttons
)
;
}
}
gBrowser
.
selectedBrowser
.
blockedPopups
.
reported
=
true
;
}
}
toggleAllowPopupsForSite
(
aEvent
)
{
var
pm
=
Services
.
perms
;
var
shouldBlock
=
aEvent
.
target
.
getAttribute
(
"
block
"
)
=
=
"
true
"
;
var
perm
=
shouldBlock
?
pm
.
DENY_ACTION
:
pm
.
ALLOW_ACTION
;
pm
.
addFromPrincipal
(
gBrowser
.
contentPrincipal
"
popup
"
perm
)
;
if
(
!
shouldBlock
)
this
.
showAllBlockedPopups
(
gBrowser
.
selectedBrowser
)
;
gBrowser
.
getNotificationBox
(
)
.
removeCurrentNotification
(
)
;
}
fillPopupList
(
aEvent
)
{
let
browser
=
gBrowser
.
selectedBrowser
;
var
uri
=
browser
.
contentPrincipal
.
URI
|
|
browser
.
currentURI
;
var
blockedPopupAllowSite
=
document
.
getElementById
(
"
blockedPopupAllowSite
"
)
;
try
{
blockedPopupAllowSite
.
removeAttribute
(
"
hidden
"
)
;
let
uriHost
=
uri
.
asciiHost
?
uri
.
host
:
uri
.
spec
;
var
pm
=
Services
.
perms
;
if
(
pm
.
testPermission
(
uri
"
popup
"
)
=
=
pm
.
ALLOW_ACTION
)
{
let
blockString
=
gNavigatorBundle
.
getFormattedString
(
"
popupBlock
"
[
uriHost
]
)
;
blockedPopupAllowSite
.
setAttribute
(
"
label
"
blockString
)
;
blockedPopupAllowSite
.
setAttribute
(
"
block
"
"
true
"
)
;
}
else
{
let
allowString
=
gNavigatorBundle
.
getFormattedString
(
"
popupAllow
"
[
uriHost
]
)
;
blockedPopupAllowSite
.
setAttribute
(
"
label
"
allowString
)
;
blockedPopupAllowSite
.
removeAttribute
(
"
block
"
)
;
}
}
catch
(
e
)
{
blockedPopupAllowSite
.
setAttribute
(
"
hidden
"
"
true
"
)
;
}
if
(
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
blockedPopupAllowSite
.
setAttribute
(
"
disabled
"
"
true
"
)
;
else
blockedPopupAllowSite
.
removeAttribute
(
"
disabled
"
)
;
let
blockedPopupDontShowMessage
=
document
.
getElementById
(
"
blockedPopupDontShowMessage
"
)
;
let
showMessage
=
gPrefService
.
getBoolPref
(
"
privacy
.
popups
.
showBrowserMessage
"
)
;
blockedPopupDontShowMessage
.
setAttribute
(
"
checked
"
!
showMessage
)
;
if
(
aEvent
.
target
.
anchorNode
.
id
=
=
"
page
-
report
-
button
"
)
{
aEvent
.
target
.
anchorNode
.
setAttribute
(
"
open
"
"
true
"
)
;
blockedPopupDontShowMessage
.
setAttribute
(
"
label
"
gNavigatorBundle
.
getString
(
"
popupWarningDontShowFromLocationbar
"
)
)
;
}
else
{
blockedPopupDontShowMessage
.
setAttribute
(
"
label
"
gNavigatorBundle
.
getString
(
"
popupWarningDontShowFromMessage
"
)
)
;
}
let
blockedPopupsSeparator
=
document
.
getElementById
(
"
blockedPopupsSeparator
"
)
;
blockedPopupsSeparator
.
setAttribute
(
"
hidden
"
true
)
;
gBrowser
.
selectedBrowser
.
retrieveListOfBlockedPopups
(
)
.
then
(
blockedPopups
=
>
{
let
foundUsablePopupURI
=
false
;
if
(
blockedPopups
)
{
for
(
let
i
=
0
;
i
<
blockedPopups
.
length
;
i
+
+
)
{
let
blockedPopup
=
blockedPopups
[
i
]
;
if
(
!
blockedPopup
.
popupWindowURIspec
)
continue
;
var
popupURIspec
=
blockedPopup
.
popupWindowURIspec
;
if
(
popupURIspec
=
=
"
"
|
|
popupURIspec
=
=
"
about
:
blank
"
|
|
popupURIspec
=
=
"
<
self
>
"
|
|
popupURIspec
=
=
uri
.
spec
)
continue
;
foundUsablePopupURI
=
true
;
var
menuitem
=
document
.
createElement
(
"
menuitem
"
)
;
var
label
=
gNavigatorBundle
.
getFormattedString
(
"
popupShowPopupPrefix
"
[
popupURIspec
]
)
;
menuitem
.
setAttribute
(
"
label
"
label
)
;
menuitem
.
setAttribute
(
"
oncommand
"
"
gPopupBlockerObserver
.
showBlockedPopup
(
event
)
;
"
)
;
menuitem
.
setAttribute
(
"
popupReportIndex
"
i
)
;
menuitem
.
popupReportBrowser
=
browser
;
aEvent
.
target
.
appendChild
(
menuitem
)
;
}
}
if
(
foundUsablePopupURI
)
blockedPopupsSeparator
.
removeAttribute
(
"
hidden
"
)
;
}
null
)
;
}
onPopupHiding
(
aEvent
)
{
if
(
aEvent
.
target
.
anchorNode
.
id
=
=
"
page
-
report
-
button
"
)
{
aEvent
.
target
.
anchorNode
.
removeAttribute
(
"
open
"
)
;
this
.
isPopupHidingTick
=
true
;
setTimeout
(
(
)
=
>
this
.
isPopupHidingTick
=
false
0
)
;
}
let
item
=
aEvent
.
target
.
lastChild
;
while
(
item
&
&
item
.
getAttribute
(
"
observes
"
)
!
=
"
blockedPopupsSeparator
"
)
{
let
next
=
item
.
previousSibling
;
item
.
remove
(
)
;
item
=
next
;
}
}
showBlockedPopup
(
aEvent
)
{
var
target
=
aEvent
.
target
;
var
popupReportIndex
=
target
.
getAttribute
(
"
popupReportIndex
"
)
;
let
browser
=
target
.
popupReportBrowser
;
browser
.
unblockPopup
(
popupReportIndex
)
;
}
showAllBlockedPopups
(
aBrowser
)
{
aBrowser
.
retrieveListOfBlockedPopups
(
)
.
then
(
popups
=
>
{
for
(
let
i
=
0
;
i
<
popups
.
length
;
i
+
+
)
{
if
(
popups
[
i
]
.
popupWindowURIspec
)
aBrowser
.
unblockPopup
(
i
)
;
}
}
null
)
;
}
editPopupSettings
(
)
{
let
prefillValue
=
"
"
;
try
{
let
principalURI
=
gBrowser
.
contentPrincipal
.
URI
|
|
gBrowser
.
currentURI
;
if
(
principalURI
)
{
if
(
principalURI
.
asciiHost
)
{
prefillValue
=
principalURI
.
prePath
;
}
else
{
prefillValue
=
principalURI
.
spec
;
}
}
}
catch
(
e
)
{
}
var
bundlePreferences
=
document
.
getElementById
(
"
bundle_preferences
"
)
;
var
params
=
{
blockVisible
:
false
sessionVisible
:
false
allowVisible
:
true
prefilledHost
:
prefillValue
permissionType
:
"
popup
"
windowTitle
:
bundlePreferences
.
getString
(
"
popuppermissionstitle2
"
)
introText
:
bundlePreferences
.
getString
(
"
popuppermissionstext
"
)
}
;
var
existingWindow
=
Services
.
wm
.
getMostRecentWindow
(
"
Browser
:
Permissions
"
)
;
if
(
existingWindow
)
{
existingWindow
.
initWithParams
(
params
)
;
existingWindow
.
focus
(
)
;
}
else
window
.
openDialog
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
permissions
.
xul
"
"
_blank
"
"
resizable
dialog
=
no
centerscreen
"
params
)
;
}
dontShowMessage
(
)
{
var
showMessage
=
gPrefService
.
getBoolPref
(
"
privacy
.
popups
.
showBrowserMessage
"
)
;
gPrefService
.
setBoolPref
(
"
privacy
.
popups
.
showBrowserMessage
"
!
showMessage
)
;
gBrowser
.
getNotificationBox
(
)
.
removeCurrentNotification
(
)
;
}
}
;
function
gKeywordURIFixup
(
{
target
:
browser
data
:
fixupInfo
}
)
{
let
deserializeURI
=
(
spec
)
=
>
spec
?
makeURI
(
spec
)
:
null
;
let
alternativeURI
=
deserializeURI
(
fixupInfo
.
fixedURI
)
;
if
(
!
fixupInfo
.
keywordProviderName
|
|
!
alternativeURI
|
|
!
alternativeURI
.
host
)
{
return
;
}
let
contentPrincipal
=
browser
.
contentPrincipal
;
let
previousURI
=
browser
.
currentURI
;
let
preferredURI
=
deserializeURI
(
fixupInfo
.
preferredURI
)
;
let
weakBrowser
=
Cu
.
getWeakReference
(
browser
)
;
browser
=
null
;
let
hostName
=
alternativeURI
.
displayHost
;
let
asciiHost
=
alternativeURI
.
asciiHost
;
if
(
asciiHost
.
indexOf
(
"
.
"
)
=
=
asciiHost
.
length
-
1
)
{
asciiHost
=
asciiHost
.
slice
(
0
-
1
)
;
}
let
isIPv4Address
=
host
=
>
{
let
parts
=
host
.
split
(
"
.
"
)
;
if
(
parts
.
length
!
=
4
)
{
return
false
;
}
return
parts
.
every
(
part
=
>
{
let
n
=
parseInt
(
part
10
)
;
return
n
>
=
0
&
&
n
<
=
255
;
}
)
;
}
;
if
(
isIPv4Address
(
asciiHost
)
|
|
/
^
(
?
:
\
d
+
|
0x
[
a
-
f0
-
9
]
+
)
/
i
.
test
(
asciiHost
)
)
return
;
let
onLookupComplete
=
(
request
record
status
)
=
>
{
let
browserRef
=
weakBrowser
.
get
(
)
;
if
(
!
Components
.
isSuccessCode
(
status
)
|
|
!
browserRef
)
return
;
let
currentURI
=
browserRef
.
currentURI
;
if
(
!
currentURI
.
equals
(
previousURI
)
&
&
!
currentURI
.
equals
(
preferredURI
)
)
{
return
;
}
let
notificationBox
=
gBrowser
.
getNotificationBox
(
browserRef
)
;
if
(
notificationBox
.
getNotificationWithValue
(
"
keyword
-
uri
-
fixup
"
)
)
return
;
let
message
=
gNavigatorBundle
.
getFormattedString
(
"
keywordURIFixup
.
message
"
[
hostName
]
)
;
let
yesMessage
=
gNavigatorBundle
.
getFormattedString
(
"
keywordURIFixup
.
goTo
"
[
hostName
]
)
let
buttons
=
[
{
label
:
yesMessage
accessKey
:
gNavigatorBundle
.
getString
(
"
keywordURIFixup
.
goTo
.
accesskey
"
)
callback
(
)
{
if
(
!
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
{
let
pref
=
"
browser
.
fixup
.
domainwhitelist
.
"
+
asciiHost
;
Services
.
prefs
.
setBoolPref
(
pref
true
)
;
}
openUILinkIn
(
alternativeURI
.
spec
"
current
"
)
;
}
}
{
label
:
gNavigatorBundle
.
getString
(
"
keywordURIFixup
.
dismiss
"
)
accessKey
:
gNavigatorBundle
.
getString
(
"
keywordURIFixup
.
dismiss
.
accesskey
"
)
callback
(
)
{
let
notification
=
notificationBox
.
getNotificationWithValue
(
"
keyword
-
uri
-
fixup
"
)
;
notificationBox
.
removeNotification
(
notification
true
)
;
}
}
]
;
let
notification
=
notificationBox
.
appendNotification
(
message
"
keyword
-
uri
-
fixup
"
null
notificationBox
.
PRIORITY_INFO_HIGH
buttons
)
;
notification
.
persistence
=
1
;
}
;
try
{
gDNSService
.
asyncResolve
(
hostName
0
onLookupComplete
Services
.
tm
.
mainThread
contentPrincipal
.
originAttributes
)
;
}
catch
(
ex
)
{
if
(
ex
.
result
!
=
Cr
.
NS_ERROR_UNKNOWN_HOST
)
{
Cu
.
reportError
(
ex
)
;
}
}
}
function
serializeInputStream
(
aStream
)
{
let
data
=
{
content
:
NetUtil
.
readInputStreamToString
(
aStream
aStream
.
available
(
)
)
}
;
if
(
aStream
instanceof
Ci
.
nsIMIMEInputStream
)
{
data
.
headers
=
new
Map
(
)
;
aStream
.
visitHeaders
(
(
name
value
)
=
>
{
data
.
headers
.
set
(
name
value
)
;
}
)
;
}
return
data
;
}
function
handleUriInChrome
(
aBrowser
aUri
)
{
if
(
aUri
.
scheme
=
=
"
file
"
)
{
try
{
let
mimeType
=
Cc
[
"
mozilla
.
org
/
mime
;
1
"
]
.
getService
(
Ci
.
nsIMIMEService
)
.
getTypeFromURI
(
aUri
)
;
if
(
mimeType
=
=
"
application
/
x
-
xpinstall
"
)
{
let
systemPrincipal
=
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
;
AddonManager
.
getInstallForURL
(
aUri
.
spec
install
=
>
{
AddonManager
.
installAddonFromWebpage
(
mimeType
aBrowser
systemPrincipal
install
)
;
}
mimeType
)
;
return
true
;
}
}
catch
(
e
)
{
return
false
;
}
}
return
false
;
}
function
_loadURIWithFlags
(
browser
uri
params
)
{
let
tab
=
gBrowser
.
getTabForBrowser
(
browser
)
;
if
(
tab
)
{
maybeRecordAbandonmentTelemetry
(
tab
"
newURI
"
)
;
}
if
(
!
uri
)
{
uri
=
"
about
:
blank
"
;
}
let
triggeringPrincipal
=
params
.
triggeringPrincipal
|
|
null
;
let
flags
=
params
.
flags
|
|
0
;
let
referrer
=
params
.
referrerURI
;
let
referrerPolicy
=
(
"
referrerPolicy
"
in
params
?
params
.
referrerPolicy
:
Ci
.
nsIHttpChannel
.
REFERRER_POLICY_UNSET
)
;
let
postData
=
params
.
postData
;
let
currentRemoteType
=
browser
.
remoteType
;
let
requiredRemoteType
;
try
{
let
fixupFlags
=
Ci
.
nsIURIFixup
.
FIXUP_FLAG_NONE
;
if
(
flags
&
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP
)
{
fixupFlags
|
=
Ci
.
nsIURIFixup
.
FIXUP_FLAG_ALLOW_KEYWORD_LOOKUP
;
}
if
(
flags
&
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_FIXUP_SCHEME_TYPOS
)
{
fixupFlags
|
=
Ci
.
nsIURIFixup
.
FIXUP_FLAG_FIX_SCHEME_TYPOS
;
}
let
uriObject
=
Services
.
uriFixup
.
createFixupURI
(
uri
fixupFlags
)
;
if
(
handleUriInChrome
(
browser
uriObject
)
)
{
return
;
}
requiredRemoteType
=
E10SUtils
.
getRemoteTypeForURIObject
(
uriObject
gMultiProcessBrowser
currentRemoteType
browser
.
currentURI
)
;
}
catch
(
e
)
{
requiredRemoteType
=
gMultiProcessBrowser
?
E10SUtils
.
DEFAULT_REMOTE_TYPE
:
E10SUtils
.
NOT_REMOTE
;
}
let
mustChangeProcess
=
requiredRemoteType
!
=
currentRemoteType
;
if
(
!
requiredRemoteType
)
{
browser
.
inLoadURI
=
true
;
}
try
{
if
(
!
mustChangeProcess
)
{
if
(
params
.
userContextId
)
{
browser
.
webNavigation
.
setOriginAttributesBeforeLoading
(
{
userContextId
:
params
.
userContextId
}
)
;
}
browser
.
webNavigation
.
loadURIWithOptions
(
uri
flags
referrer
referrerPolicy
postData
null
null
triggeringPrincipal
)
;
}
else
{
let
{
permitUnload
timedOut
}
=
browser
.
permitUnload
(
)
;
if
(
!
timedOut
&
&
!
permitUnload
)
{
return
;
}
if
(
postData
)
{
postData
=
serializeInputStream
(
postData
)
;
}
let
loadParams
=
{
uri
triggeringPrincipal
:
triggeringPrincipal
?
gSerializationHelper
.
serializeToString
(
triggeringPrincipal
)
:
null
flags
referrer
:
referrer
?
referrer
.
spec
:
null
referrerPolicy
remoteType
:
requiredRemoteType
postData
}
if
(
params
.
userContextId
)
{
loadParams
.
userContextId
=
params
.
userContextId
;
}
LoadInOtherProcess
(
browser
loadParams
)
;
}
}
catch
(
e
)
{
if
(
mustChangeProcess
)
{
Cu
.
reportError
(
e
)
;
gBrowser
.
updateBrowserRemotenessByURL
(
browser
uri
)
;
if
(
params
.
userContextId
)
{
browser
.
webNavigation
.
setOriginAttributesBeforeLoading
(
{
userContextId
:
params
.
userContextId
}
)
;
}
browser
.
webNavigation
.
loadURIWithOptions
(
uri
flags
referrer
referrerPolicy
postData
null
null
triggeringPrincipal
)
;
}
else
{
throw
e
;
}
}
finally
{
if
(
!
requiredRemoteType
)
{
browser
.
inLoadURI
=
false
;
}
}
}
function
LoadInOtherProcess
(
browser
loadOptions
historyIndex
=
-
1
)
{
let
tab
=
gBrowser
.
getTabForBrowser
(
browser
)
;
SessionStore
.
navigateAndRestore
(
tab
loadOptions
historyIndex
)
;
}
function
RedirectLoad
(
{
target
:
browser
data
}
)
{
if
(
data
.
loadOptions
.
reloadInFreshProcess
)
{
data
.
loadOptions
.
remoteType
=
E10SUtils
.
LARGE_ALLOCATION_REMOTE_TYPE
;
data
.
loadOptions
.
newFrameloader
=
true
;
}
else
if
(
browser
.
remoteType
=
=
E10SUtils
.
LARGE_ALLOCATION_REMOTE_TYPE
)
{
data
.
loadOptions
.
remoteType
=
E10SUtils
.
getRemoteTypeForURI
(
data
.
loadOptions
.
uri
gMultiProcessBrowser
)
;
}
if
(
gBrowserInit
.
delayedStartupFinished
)
{
LoadInOtherProcess
(
browser
data
.
loadOptions
data
.
historyIndex
)
;
}
else
{
let
delayedStartupFinished
=
(
subject
topic
)
=
>
{
if
(
topic
=
=
"
browser
-
delayed
-
startup
-
finished
"
&
&
subject
=
=
window
)
{
Services
.
obs
.
removeObserver
(
delayedStartupFinished
topic
)
;
LoadInOtherProcess
(
browser
data
.
loadOptions
data
.
historyIndex
)
;
}
}
;
Services
.
obs
.
addObserver
(
delayedStartupFinished
"
browser
-
delayed
-
startup
-
finished
"
)
;
}
}
if
(
document
.
documentElement
.
getAttribute
(
"
windowtype
"
)
=
=
"
navigator
:
browser
"
)
{
addEventListener
(
"
DOMContentLoaded
"
function
(
)
{
gBrowserInit
.
onDOMContentLoaded
(
)
;
}
{
once
:
true
}
)
;
}
let
_resolveDelayedStartup
;
var
delayedStartupPromise
=
new
Promise
(
resolve
=
>
{
_resolveDelayedStartup
=
resolve
;
}
)
;
var
gBrowserInit
=
{
delayedStartupFinished
:
false
onDOMContentLoaded
(
)
{
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
nsIWebNavigation
)
.
QueryInterface
(
Ci
.
nsIDocShellTreeItem
)
.
treeOwner
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIXULWindow
)
.
XULBrowserWindow
=
window
.
XULBrowserWindow
;
window
.
QueryInterface
(
Ci
.
nsIDOMChromeWindow
)
.
browserDOMWindow
=
new
nsBrowserAccess
(
)
;
let
initBrowser
=
document
.
getAnonymousElementByAttribute
(
gBrowser
"
anonid
"
"
initialBrowser
"
)
;
let
isRemote
=
gMultiProcessBrowser
;
let
remoteType
;
let
sameProcessAsFrameLoader
;
if
(
window
.
arguments
)
{
let
argToLoad
=
window
.
arguments
[
0
]
;
if
(
argToLoad
instanceof
XULElement
)
{
if
(
argToLoad
.
hasAttribute
(
"
usercontextid
"
)
)
{
initBrowser
.
setAttribute
(
"
usercontextid
"
argToLoad
.
getAttribute
(
"
usercontextid
"
)
)
;
}
let
linkedBrowser
=
argToLoad
.
linkedBrowser
;
if
(
linkedBrowser
)
{
remoteType
=
linkedBrowser
.
remoteType
;
isRemote
=
remoteType
!
=
E10SUtils
.
NOT_REMOTE
;
sameProcessAsFrameLoader
=
linkedBrowser
.
frameLoader
;
}
}
else
if
(
argToLoad
instanceof
String
)
{
remoteType
=
E10SUtils
.
getRemoteTypeForURI
(
argToLoad
gMultiProcessBrowser
)
;
isRemote
=
remoteType
!
=
E10SUtils
.
NOT_REMOTE
;
}
else
if
(
argToLoad
instanceof
Ci
.
nsIArray
)
{
let
urisstring
=
argToLoad
.
queryElementAt
(
0
Ci
.
nsISupportsString
)
;
remoteType
=
E10SUtils
.
getRemoteTypeForURI
(
urisstring
.
data
gMultiProcessBrowser
)
;
isRemote
=
remoteType
!
=
E10SUtils
.
NOT_REMOTE
;
}
}
gBrowser
.
updateBrowserRemoteness
(
initBrowser
isRemote
{
remoteType
sameProcessAsFrameLoader
}
)
;
}
onLoad
(
)
{
gBrowser
.
addEventListener
(
"
DOMUpdatePageReport
"
gPopupBlockerObserver
)
;
Services
.
obs
.
addObserver
(
gPluginHandler
.
NPAPIPluginCrashed
"
plugin
-
crashed
"
)
;
window
.
addEventListener
(
"
AppCommand
"
HandleAppCommandEvent
true
)
;
DOMLinkHandler
.
init
(
)
;
gPageStyleMenu
.
init
(
)
;
LanguageDetectionListener
.
init
(
)
;
BrowserOnClick
.
init
(
)
;
FeedHandler
.
init
(
)
;
CompactTheme
.
init
(
)
;
AboutPrivateBrowsingListener
.
init
(
)
;
TrackingProtection
.
init
(
)
;
CaptivePortalWatcher
.
init
(
)
;
ZoomUI
.
init
(
window
)
;
let
mm
=
window
.
getGroupMessageManager
(
"
browsers
"
)
;
mm
.
loadFrameScript
(
"
chrome
:
/
/
browser
/
content
/
tab
-
content
.
js
"
true
)
;
mm
.
loadFrameScript
(
"
chrome
:
/
/
browser
/
content
/
content
.
js
"
true
)
;
mm
.
loadFrameScript
(
"
chrome
:
/
/
browser
/
content
/
content
-
UITour
.
js
"
true
)
;
mm
.
loadFrameScript
(
"
chrome
:
/
/
global
/
content
/
manifestMessages
.
js
"
true
)
;
window
.
messageManager
.
addMessageListener
(
"
Browser
:
LoadURI
"
RedirectLoad
)
;
if
(
!
gMultiProcessBrowser
)
{
Cc
[
"
mozilla
.
org
/
eventlistenerservice
;
1
"
]
.
getService
(
Ci
.
nsIEventListenerService
)
.
addSystemEventListener
(
gBrowser
"
click
"
contentAreaClick
true
)
;
}
gBrowser
.
addProgressListener
(
window
.
XULBrowserWindow
)
;
gBrowser
.
addTabsProgressListener
(
window
.
TabsProgressListener
)
;
SidebarUI
.
init
(
)
;
Services
.
obs
.
notifyObservers
(
window
"
browser
-
window
-
before
-
show
"
)
;
gUIDensity
.
init
(
)
;
let
isResistFingerprintingEnabled
=
gPrefService
.
getBoolPref
(
"
privacy
.
resistFingerprinting
"
)
;
if
(
isResistFingerprintingEnabled
)
{
document
.
documentElement
.
setAttribute
(
"
sizemode
"
"
normal
"
)
;
}
else
if
(
!
document
.
documentElement
.
hasAttribute
(
"
width
"
)
)
{
const
TARGET_WIDTH
=
1280
;
const
TARGET_HEIGHT
=
1040
;
let
width
=
Math
.
min
(
screen
.
availWidth
*
.
9
TARGET_WIDTH
)
;
let
height
=
Math
.
min
(
screen
.
availHeight
*
.
9
TARGET_HEIGHT
)
;
document
.
documentElement
.
setAttribute
(
"
width
"
width
)
;
document
.
documentElement
.
setAttribute
(
"
height
"
height
)
;
if
(
width
<
TARGET_WIDTH
&
&
height
<
TARGET_HEIGHT
)
{
document
.
documentElement
.
setAttribute
(
"
sizemode
"
"
maximized
"
)
;
}
}
if
(
!
window
.
toolbar
.
visible
)
{
gURLBar
.
setAttribute
(
"
readonly
"
"
true
"
)
;
gURLBar
.
setAttribute
(
"
enablehistory
"
"
false
"
)
;
}
TabletModeUpdater
.
init
(
)
;
CombinedStopReload
.
init
(
)
;
gPrivateBrowsingUI
.
init
(
)
;
BrowserPageActions
.
init
(
)
;
if
(
window
.
matchMedia
(
"
(
-
moz
-
os
-
version
:
windows
-
win8
)
"
)
.
matches
&
&
window
.
matchMedia
(
"
(
-
moz
-
windows
-
default
-
theme
)
"
)
.
matches
)
{
let
windowFrameColor
=
new
Color
(
.
.
.
Cu
.
import
(
"
resource
:
/
/
/
modules
/
Windows8WindowFrameColor
.
jsm
"
{
}
)
.
Windows8WindowFrameColor
.
get
(
)
)
;
if
(
!
windowFrameColor
.
isContrastRatioAcceptable
(
new
Color
(
0
0
0
)
)
)
{
document
.
documentElement
.
setAttribute
(
"
darkwindowframe
"
"
true
"
)
;
}
}
ToolbarIconColor
.
init
(
)
;
gRemoteControl
.
updateVisualCue
(
Marionette
.
running
)
;
let
uriToLoad
=
this
.
_getUriToLoad
(
)
;
gIdentityHandler
.
initIdentityBlock
(
uriToLoad
)
;
this
.
_boundDelayedStartup
=
this
.
_delayedStartup
.
bind
(
this
uriToLoad
)
;
window
.
addEventListener
(
"
MozAfterPaint
"
this
.
_boundDelayedStartup
)
;
this
.
_loadHandled
=
true
;
}
_cancelDelayedStartup
(
)
{
window
.
removeEventListener
(
"
MozAfterPaint
"
this
.
_boundDelayedStartup
)
;
this
.
_boundDelayedStartup
=
null
;
}
_delayedStartup
(
uriToLoad
)
{
let
tmp
=
{
}
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryTimestamps
.
jsm
"
tmp
)
;
let
TelemetryTimestamps
=
tmp
.
TelemetryTimestamps
;
TelemetryTimestamps
.
add
(
"
delayedStartupStarted
"
)
;
this
.
_cancelDelayedStartup
(
)
;
OfflineApps
.
init
(
)
;
let
mm
=
window
.
messageManager
;
mm
.
addMessageListener
(
"
PageVisibility
:
Show
"
function
(
message
)
{
if
(
message
.
target
=
=
gBrowser
.
selectedBrowser
)
{
setTimeout
(
pageShowEventHandlers
0
message
.
data
.
persisted
)
;
}
}
)
;
gBrowser
.
addEventListener
(
"
AboutTabCrashedLoad
"
function
(
event
)
{
let
ownerDoc
=
event
.
originalTarget
;
if
(
!
ownerDoc
.
documentURI
.
startsWith
(
"
about
:
tabcrashed
"
)
)
{
return
;
}
let
browser
=
gBrowser
.
getBrowserForDocument
(
event
.
target
)
;
ZoomManager
.
setZoomForBrowser
(
browser
1
)
;
}
false
true
)
;
gBrowser
.
addEventListener
(
"
InsecureLoginFormsStateChange
"
function
(
)
{
gIdentityHandler
.
refreshForInsecureLoginForms
(
)
;
}
)
;
gBrowser
.
addEventListener
(
"
PermissionStateChange
"
function
(
)
{
gIdentityHandler
.
refreshIdentityBlock
(
)
;
}
)
;
gAboutNewTabService
.
QueryInterface
(
Ci
.
nsISupports
)
;
if
(
uriToLoad
&
&
uriToLoad
!
=
"
about
:
blank
"
)
{
if
(
uriToLoad
instanceof
Ci
.
nsIArray
)
{
let
count
=
uriToLoad
.
length
;
let
specs
=
[
]
;
for
(
let
i
=
0
;
i
<
count
;
i
+
+
)
{
let
urisstring
=
uriToLoad
.
queryElementAt
(
i
Ci
.
nsISupportsString
)
;
specs
.
push
(
urisstring
.
data
)
;
}
try
{
gBrowser
.
loadTabs
(
specs
{
inBackground
:
false
replace
:
true
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
}
)
;
}
catch
(
e
)
{
}
}
else
if
(
uriToLoad
instanceof
XULElement
)
{
let
tabToOpen
=
uriToLoad
;
if
(
window
.
arguments
[
0
]
=
=
tabToOpen
)
{
window
.
arguments
[
0
]
=
null
;
}
gBrowser
.
stop
(
)
;
gBrowser
.
docShell
;
if
(
tabToOpen
.
hasAttribute
(
"
usercontextid
"
)
)
{
let
usercontextid
=
tabToOpen
.
getAttribute
(
"
usercontextid
"
)
;
gBrowser
.
selectedBrowser
.
setAttribute
(
"
usercontextid
"
usercontextid
)
;
}
try
{
gBrowser
.
updateBrowserRemoteness
(
gBrowser
.
selectedBrowser
tabToOpen
.
linkedBrowser
.
isRemoteBrowser
{
remoteType
:
tabToOpen
.
linkedBrowser
.
remoteType
}
)
;
gBrowser
.
swapBrowsersAndCloseOther
(
gBrowser
.
selectedTab
tabToOpen
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
else
if
(
window
.
arguments
.
length
>
=
3
)
{
let
referrerURI
=
window
.
arguments
[
2
]
;
if
(
typeof
(
referrerURI
)
=
=
"
string
"
)
{
try
{
referrerURI
=
makeURI
(
referrerURI
)
;
}
catch
(
e
)
{
referrerURI
=
null
;
}
}
let
referrerPolicy
=
(
window
.
arguments
[
5
]
!
=
undefined
?
window
.
arguments
[
5
]
:
Ci
.
nsIHttpChannel
.
REFERRER_POLICY_UNSET
)
;
let
userContextId
=
(
window
.
arguments
[
6
]
!
=
undefined
?
window
.
arguments
[
6
]
:
Ci
.
nsIScriptSecurityManager
.
DEFAULT_USER_CONTEXT_ID
)
;
loadURI
(
uriToLoad
referrerURI
window
.
arguments
[
3
]
|
|
null
window
.
arguments
[
4
]
|
|
false
referrerPolicy
userContextId
window
.
arguments
[
7
]
!
!
window
.
arguments
[
7
]
window
.
arguments
[
8
]
)
;
window
.
focus
(
)
;
}
else
{
loadOneOrMoreURIs
(
uriToLoad
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
)
;
}
}
Services
.
obs
.
addObserver
(
gIdentityHandler
"
perm
-
changed
"
)
;
Services
.
obs
.
addObserver
(
gRemoteControl
"
remote
-
active
"
)
;
Services
.
obs
.
addObserver
(
gSessionHistoryObserver
"
browser
:
purge
-
session
-
history
"
)
;
Services
.
obs
.
addObserver
(
gStoragePressureObserver
"
QuotaManager
:
:
StoragePressure
"
)
;
Services
.
obs
.
addObserver
(
gXPInstallObserver
"
addon
-
install
-
disabled
"
)
;
Services
.
obs
.
addObserver
(
gXPInstallObserver
"
addon
-
install
-
started
"
)
;
Services
.
obs
.
addObserver
(
gXPInstallObserver
"
addon
-
install
-
blocked
"
)
;
Services
.
obs
.
addObserver
(
gXPInstallObserver
"
addon
-
install
-
origin
-
blocked
"
)
;
Services
.
obs
.
addObserver
(
gXPInstallObserver
"
addon
-
install
-
failed
"
)
;
Services
.
obs
.
addObserver
(
gXPInstallObserver
"
addon
-
install
-
confirmation
"
)
;
Services
.
obs
.
addObserver
(
gXPInstallObserver
"
addon
-
install
-
complete
"
)
;
window
.
messageManager
.
addMessageListener
(
"
Browser
:
URIFixup
"
gKeywordURIFixup
)
;
BrowserOffline
.
init
(
)
;
IndexedDBPromptHelper
.
init
(
)
;
if
(
AppConstants
.
E10S_TESTING_ONLY
)
gRemoteTabsUI
.
init
(
)
;
FullZoom
.
init
(
)
;
PanelUI
.
init
(
)
;
UpdateUrlbarSearchSplitterState
(
)
;
if
(
!
(
isBlankPageURL
(
uriToLoad
)
|
|
uriToLoad
=
=
"
about
:
privatebrowsing
"
)
|
|
!
focusAndSelectUrlBar
(
)
)
{
if
(
gBrowser
.
selectedBrowser
.
isRemoteBrowser
)
{
let
focusedElement
=
document
.
commandDispatcher
.
focusedElement
;
mm
.
addMessageListener
(
"
Browser
:
FirstPaint
"
function
onFirstPaint
(
)
{
mm
.
removeMessageListener
(
"
Browser
:
FirstPaint
"
onFirstPaint
)
;
if
(
document
.
commandDispatcher
.
focusedElement
=
=
focusedElement
)
{
gBrowser
.
selectedBrowser
.
focus
(
)
;
}
}
)
;
}
else
{
gBrowser
.
selectedBrowser
.
focus
(
)
;
}
}
gBrowser
.
tabContainer
.
updateVisibility
(
)
;
BookmarkingUI
.
init
(
)
;
AutoShowBookmarksToolbar
.
init
(
)
;
gPrefService
.
addObserver
(
gHomeButton
.
prefDomain
gHomeButton
)
;
var
homeButton
=
document
.
getElementById
(
"
home
-
button
"
)
;
gHomeButton
.
updateTooltip
(
homeButton
)
;
let
safeMode
=
document
.
getElementById
(
"
helpSafeMode
"
)
;
if
(
Services
.
appinfo
.
inSafeMode
)
{
safeMode
.
label
=
safeMode
.
getAttribute
(
"
stoplabel
"
)
;
safeMode
.
accesskey
=
safeMode
.
getAttribute
(
"
stopaccesskey
"
)
;
}
gBidiUI
=
isBidiEnabled
(
)
;
if
(
gBidiUI
)
{
document
.
getElementById
(
"
documentDirection
-
separator
"
)
.
hidden
=
false
;
document
.
getElementById
(
"
documentDirection
-
swap
"
)
.
hidden
=
false
;
document
.
getElementById
(
"
textfieldDirection
-
separator
"
)
.
hidden
=
false
;
document
.
getElementById
(
"
textfieldDirection
-
swap
"
)
.
hidden
=
false
;
}
if
(
!
getBoolPref
(
"
ui
.
click_hold_context_menus
"
false
)
)
SetClickAndHoldHandlers
(
)
;
Cu
.
import
(
"
resource
:
/
/
/
modules
/
UpdateTopLevelContentWindowIDHelper
.
jsm
"
{
}
)
.
trackBrowserWindow
(
window
)
;
PlacesToolbarHelper
.
init
(
)
;
ctrlTab
.
readPref
(
)
;
gPrefService
.
addObserver
(
ctrlTab
.
prefName
ctrlTab
)
;
DownloadsButton
.
initializeIndicator
(
)
;
if
(
AppConstants
.
platform
!
=
"
macosx
"
)
{
updateEditUIVisibility
(
)
;
let
placesContext
=
document
.
getElementById
(
"
placesContext
"
)
;
placesContext
.
addEventListener
(
"
popupshowing
"
updateEditUIVisibility
)
;
placesContext
.
addEventListener
(
"
popuphiding
"
updateEditUIVisibility
)
;
}
LightWeightThemeWebInstaller
.
init
(
)
;
if
(
Win7Features
)
Win7Features
.
onOpenWindow
(
)
;
FullScreen
.
init
(
)
;
PointerLock
.
init
(
)
;
if
(
AppConstants
.
isPlatformAndVersionAtLeast
(
"
win
"
"
10
"
)
)
{
MenuTouchModeObserver
.
init
(
)
;
}
if
(
AppConstants
.
MOZ_DATA_REPORTING
)
gDataNotificationInfoBar
.
init
(
)
;
if
(
!
AppConstants
.
MOZILLA_OFFICIAL
)
DevelopmentHelpers
.
init
(
)
;
gExtensionsNotifications
.
init
(
)
;
let
wasMinimized
=
window
.
windowState
=
=
window
.
STATE_MINIMIZED
;
window
.
addEventListener
(
"
sizemodechange
"
(
)
=
>
{
let
isMinimized
=
window
.
windowState
=
=
window
.
STATE_MINIMIZED
;
if
(
wasMinimized
!
=
isMinimized
)
{
wasMinimized
=
isMinimized
;
UpdatePopupNotificationsVisibility
(
)
;
}
}
)
;
window
.
addEventListener
(
"
mousemove
"
MousePosTracker
)
;
window
.
addEventListener
(
"
dragover
"
MousePosTracker
)
;
gNavToolbox
.
addEventListener
(
"
customizationstarting
"
CustomizationHandler
)
;
gNavToolbox
.
addEventListener
(
"
customizationending
"
CustomizationHandler
)
;
SessionStore
.
promiseInitialized
.
then
(
(
)
=
>
{
if
(
window
.
closed
)
{
return
;
}
RestoreLastSessionObserver
.
init
(
)
;
SidebarUI
.
startDelayedLoad
(
)
;
SocialUI
.
init
(
)
;
PanicButtonNotifier
.
init
(
)
;
}
)
;
gBrowser
.
tabContainer
.
addEventListener
(
"
TabSelect
"
function
(
)
{
for
(
let
panel
of
document
.
querySelectorAll
(
"
panel
[
tabspecific
=
'
true
'
]
"
)
)
{
if
(
panel
.
state
=
=
"
open
"
)
{
panel
.
hidePopup
(
)
;
}
}
}
)
;
this
.
delayedStartupFinished
=
true
;
_resolveDelayedStartup
(
)
;
SessionStore
.
promiseAllWindowsRestored
.
then
(
(
)
=
>
{
this
.
_schedulePerWindowIdleTasks
(
)
;
}
)
;
Services
.
obs
.
notifyObservers
(
window
"
browser
-
delayed
-
startup
-
finished
"
)
;
TelemetryTimestamps
.
add
(
"
delayedStartupFinished
"
)
;
}
_schedulePerWindowIdleTasks
(
)
{
if
(
window
.
closed
)
{
return
;
}
function
scheduleIdleTask
(
func
options
)
{
requestIdleCallback
(
function
idleTaskRunner
(
)
{
if
(
!
window
.
closed
)
{
func
(
)
;
}
}
options
)
;
}
scheduleIdleTask
(
(
)
=
>
{
gSync
.
init
(
)
;
}
)
;
scheduleIdleTask
(
(
)
=
>
{
CombinedStopReload
.
startAnimationPrefMonitoring
(
)
;
}
)
;
scheduleIdleTask
(
(
)
=
>
{
gGestureSupport
.
init
(
true
)
;
gHistorySwipeAnimation
.
init
(
)
;
}
)
;
scheduleIdleTask
(
(
)
=
>
{
gBrowserThumbnails
.
init
(
)
;
}
)
;
scheduleIdleTask
(
(
)
=
>
{
try
{
DownloadsCommon
.
initializeAllDataLinks
(
)
;
Cu
.
import
(
"
resource
:
/
/
/
modules
/
DownloadsTaskbar
.
jsm
"
{
}
)
.
DownloadsTaskbar
.
registerIndicator
(
window
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
}
{
timeout
:
10000
}
)
;
}
_getUriToLoad
(
)
{
if
(
!
window
.
arguments
|
|
!
window
.
arguments
[
0
]
)
return
null
;
let
uri
=
window
.
arguments
[
0
]
;
let
sessionStartup
=
Cc
[
"
mozilla
.
org
/
browser
/
sessionstartup
;
1
"
]
.
getService
(
Ci
.
nsISessionStartup
)
;
let
defaultArgs
=
Cc
[
"
mozilla
.
org
/
browser
/
clh
;
1
"
]
.
getService
(
Ci
.
nsIBrowserHandler
)
.
defaultArgs
;
if
(
uri
=
=
defaultArgs
&
&
sessionStartup
.
willOverrideHomepage
)
return
null
;
return
uri
;
}
onUnload
(
)
{
if
(
!
this
.
_loadHandled
)
return
;
CombinedStopReload
.
uninit
(
)
;
gGestureSupport
.
init
(
false
)
;
gHistorySwipeAnimation
.
uninit
(
)
;
FullScreen
.
uninit
(
)
;
gSync
.
uninit
(
)
;
gExtensionsNotifications
.
uninit
(
)
;
Services
.
obs
.
removeObserver
(
gPluginHandler
.
NPAPIPluginCrashed
"
plugin
-
crashed
"
)
;
gUIDensity
.
uninit
(
)
;
try
{
gBrowser
.
removeProgressListener
(
window
.
XULBrowserWindow
)
;
gBrowser
.
removeTabsProgressListener
(
window
.
TabsProgressListener
)
;
}
catch
(
ex
)
{
}
PlacesToolbarHelper
.
uninit
(
)
;
BookmarkingUI
.
uninit
(
)
;
TabsInTitlebar
.
uninit
(
)
;
ToolbarIconColor
.
uninit
(
)
;
TabletModeUpdater
.
uninit
(
)
;
gTabletModePageCounter
.
finish
(
)
;
BrowserOnClick
.
uninit
(
)
;
FeedHandler
.
uninit
(
)
;
CompactTheme
.
uninit
(
)
;
TrackingProtection
.
uninit
(
)
;
CaptivePortalWatcher
.
uninit
(
)
;
SidebarUI
.
uninit
(
)
;
if
(
this
.
_boundDelayedStartup
)
{
this
.
_cancelDelayedStartup
(
)
;
}
else
{
if
(
Win7Features
)
Win7Features
.
onCloseWindow
(
)
;
gPrefService
.
removeObserver
(
ctrlTab
.
prefName
ctrlTab
)
;
ctrlTab
.
uninit
(
)
;
SocialUI
.
uninit
(
)
;
gBrowserThumbnails
.
uninit
(
)
;
FullZoom
.
destroy
(
)
;
Services
.
obs
.
removeObserver
(
gIdentityHandler
"
perm
-
changed
"
)
;
Services
.
obs
.
removeObserver
(
gRemoteControl
"
remote
-
active
"
)
;
Services
.
obs
.
removeObserver
(
gSessionHistoryObserver
"
browser
:
purge
-
session
-
history
"
)
;
Services
.
obs
.
removeObserver
(
gStoragePressureObserver
"
QuotaManager
:
:
StoragePressure
"
)
;
Services
.
obs
.
removeObserver
(
gXPInstallObserver
"
addon
-
install
-
disabled
"
)
;
Services
.
obs
.
removeObserver
(
gXPInstallObserver
"
addon
-
install
-
started
"
)
;
Services
.
obs
.
removeObserver
(
gXPInstallObserver
"
addon
-
install
-
blocked
"
)
;
Services
.
obs
.
removeObserver
(
gXPInstallObserver
"
addon
-
install
-
origin
-
blocked
"
)
;
Services
.
obs
.
removeObserver
(
gXPInstallObserver
"
addon
-
install
-
failed
"
)
;
Services
.
obs
.
removeObserver
(
gXPInstallObserver
"
addon
-
install
-
confirmation
"
)
;
Services
.
obs
.
removeObserver
(
gXPInstallObserver
"
addon
-
install
-
complete
"
)
;
window
.
messageManager
.
removeMessageListener
(
"
Browser
:
URIFixup
"
gKeywordURIFixup
)
;
window
.
messageManager
.
removeMessageListener
(
"
Browser
:
LoadURI
"
RedirectLoad
)
;
try
{
gPrefService
.
removeObserver
(
gHomeButton
.
prefDomain
gHomeButton
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
if
(
AppConstants
.
isPlatformAndVersionAtLeast
(
"
win
"
"
10
"
)
)
{
MenuTouchModeObserver
.
uninit
(
)
;
}
BrowserOffline
.
uninit
(
)
;
IndexedDBPromptHelper
.
uninit
(
)
;
PanelUI
.
uninit
(
)
;
AutoShowBookmarksToolbar
.
uninit
(
)
;
}
window
.
XULBrowserWindow
=
null
;
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebNavigation
)
.
QueryInterface
(
Ci
.
nsIDocShellTreeItem
)
.
treeOwner
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIXULWindow
)
.
XULBrowserWindow
=
null
;
window
.
QueryInterface
(
Ci
.
nsIDOMChromeWindow
)
.
browserDOMWindow
=
null
;
}
}
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
gBrowserInit
.
nonBrowserWindowStartup
=
function
(
)
{
var
disabledItems
=
[
"
Browser
:
SavePage
"
"
Browser
:
SendLink
"
"
cmd_pageSetup
"
"
cmd_print
"
"
cmd_find
"
"
cmd_findAgain
"
"
viewToolbarsMenu
"
"
viewSidebarMenuMenu
"
"
Browser
:
Reload
"
"
viewFullZoomMenu
"
"
pageStyleMenu
"
"
charsetMenu
"
"
View
:
PageSource
"
"
View
:
FullScreen
"
"
viewHistorySidebar
"
"
Browser
:
AddBookmarkAs
"
"
Browser
:
BookmarkAllTabs
"
"
View
:
PageInfo
"
]
;
var
element
;
for
(
let
disabledItem
of
disabledItems
)
{
element
=
document
.
getElementById
(
disabledItem
)
;
if
(
element
)
element
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
if
(
window
.
location
.
href
=
=
"
chrome
:
/
/
browser
/
content
/
hiddenWindow
.
xul
"
)
{
var
hiddenWindowDisabledItems
=
[
"
cmd_close
"
"
minimizeWindow
"
"
zoomWindow
"
]
;
for
(
let
hiddenWindowDisabledItem
of
hiddenWindowDisabledItems
)
{
element
=
document
.
getElementById
(
hiddenWindowDisabledItem
)
;
if
(
element
)
element
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
element
=
document
.
getElementById
(
"
sep
-
window
-
list
"
)
;
element
.
setAttribute
(
"
hidden
"
"
true
"
)
;
let
dockMenuElement
=
document
.
getElementById
(
"
menu_mac_dockmenu
"
)
;
if
(
dockMenuElement
!
=
null
)
{
let
nativeMenu
=
Cc
[
"
mozilla
.
org
/
widget
/
standalonenativemenu
;
1
"
]
.
createInstance
(
Ci
.
nsIStandaloneNativeMenu
)
;
try
{
nativeMenu
.
init
(
dockMenuElement
)
;
let
dockSupport
=
Cc
[
"
mozilla
.
org
/
widget
/
macdocksupport
;
1
"
]
.
getService
(
Ci
.
nsIMacDockSupport
)
;
dockSupport
.
dockMenu
=
nativeMenu
;
}
catch
(
e
)
{
}
}
}
if
(
PrivateBrowsingUtils
.
permanentPrivateBrowsing
)
{
document
.
getElementById
(
"
macDockMenuNewWindow
"
)
.
hidden
=
true
;
}
this
.
_delayedStartupTimeoutId
=
setTimeout
(
this
.
nonBrowserWindowDelayedStartup
.
bind
(
this
)
0
)
;
}
;
gBrowserInit
.
nonBrowserWindowDelayedStartup
=
function
(
)
{
this
.
_delayedStartupTimeoutId
=
null
;
BrowserOffline
.
init
(
)
;
gPrivateBrowsingUI
.
init
(
)
;
requestIdleCallback
(
(
)
=
>
{
gSync
.
init
(
)
;
}
{
timeout
:
1000
*
5
}
)
;
if
(
AppConstants
.
E10S_TESTING_ONLY
)
{
gRemoteTabsUI
.
init
(
)
;
}
}
;
gBrowserInit
.
nonBrowserWindowShutdown
=
function
(
)
{
let
dockSupport
=
Cc
[
"
mozilla
.
org
/
widget
/
macdocksupport
;
1
"
]
.
getService
(
Ci
.
nsIMacDockSupport
)
;
dockSupport
.
dockMenu
=
null
;
if
(
this
.
_delayedStartupTimeoutId
)
{
clearTimeout
(
this
.
_delayedStartupTimeoutId
)
;
return
;
}
BrowserOffline
.
uninit
(
)
;
}
;
}
var
BrowserStartup
=
gBrowserInit
.
onLoad
.
bind
(
gBrowserInit
)
;
var
BrowserShutdown
=
gBrowserInit
.
onUnload
.
bind
(
gBrowserInit
)
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
var
nonBrowserWindowStartup
=
gBrowserInit
.
nonBrowserWindowStartup
.
bind
(
gBrowserInit
)
;
var
nonBrowserWindowDelayedStartup
=
gBrowserInit
.
nonBrowserWindowDelayedStartup
.
bind
(
gBrowserInit
)
;
var
nonBrowserWindowShutdown
=
gBrowserInit
.
nonBrowserWindowShutdown
.
bind
(
gBrowserInit
)
;
}
function
HandleAppCommandEvent
(
evt
)
{
switch
(
evt
.
command
)
{
case
"
Back
"
:
BrowserBack
(
)
;
break
;
case
"
Forward
"
:
BrowserForward
(
)
;
break
;
case
"
Reload
"
:
BrowserReloadSkipCache
(
)
;
break
;
case
"
Stop
"
:
if
(
XULBrowserWindow
.
stopCommand
.
getAttribute
(
"
disabled
"
)
!
=
"
true
"
)
BrowserStop
(
)
;
break
;
case
"
Search
"
:
BrowserSearch
.
webSearch
(
)
;
break
;
case
"
Bookmarks
"
:
SidebarUI
.
toggle
(
"
viewBookmarksSidebar
"
)
;
break
;
case
"
Home
"
:
BrowserHome
(
)
;
break
;
case
"
New
"
:
BrowserOpenTab
(
)
;
break
;
case
"
Close
"
:
BrowserCloseTabOrWindow
(
)
;
break
;
case
"
Find
"
:
gFindBar
.
onFindCommand
(
)
;
break
;
case
"
Help
"
:
openHelpLink
(
"
firefox
-
help
"
)
;
break
;
case
"
Open
"
:
BrowserOpenFileWindow
(
)
;
break
;
case
"
Print
"
:
PrintUtils
.
printWindow
(
gBrowser
.
selectedBrowser
.
outerWindowID
gBrowser
.
selectedBrowser
)
;
break
;
case
"
Save
"
:
saveBrowser
(
gBrowser
.
selectedBrowser
)
;
break
;
case
"
SendMail
"
:
MailIntegration
.
sendLinkForBrowser
(
gBrowser
.
selectedBrowser
)
;
break
;
default
:
return
;
}
evt
.
stopPropagation
(
)
;
evt
.
preventDefault
(
)
;
}
function
maybeRecordAbandonmentTelemetry
(
tab
type
)
{
if
(
!
tab
.
hasAttribute
(
"
busy
"
)
)
{
return
;
}
let
histogram
=
Services
.
telemetry
.
getHistogramById
(
"
BUSY_TAB_ABANDONED
"
)
;
histogram
.
add
(
type
)
;
}
function
gotoHistoryIndex
(
aEvent
)
{
let
index
=
aEvent
.
target
.
getAttribute
(
"
index
"
)
;
if
(
!
index
)
return
false
;
let
where
=
whereToOpenLink
(
aEvent
)
;
if
(
where
=
=
"
current
"
)
{
try
{
maybeRecordAbandonmentTelemetry
(
gBrowser
.
selectedTab
"
historyNavigation
"
)
;
gBrowser
.
gotoIndex
(
index
)
;
}
catch
(
ex
)
{
return
false
;
}
return
true
;
}
let
historyindex
=
aEvent
.
target
.
getAttribute
(
"
historyindex
"
)
;
duplicateTabIn
(
gBrowser
.
selectedTab
where
Number
(
historyindex
)
)
;
return
true
;
}
function
BrowserForward
(
aEvent
)
{
let
where
=
whereToOpenLink
(
aEvent
false
true
)
;
if
(
where
=
=
"
current
"
)
{
try
{
maybeRecordAbandonmentTelemetry
(
gBrowser
.
selectedTab
"
forward
"
)
;
gBrowser
.
goForward
(
)
;
}
catch
(
ex
)
{
}
}
else
{
duplicateTabIn
(
gBrowser
.
selectedTab
where
1
)
;
}
}
function
BrowserBack
(
aEvent
)
{
let
where
=
whereToOpenLink
(
aEvent
false
true
)
;
if
(
where
=
=
"
current
"
)
{
try
{
maybeRecordAbandonmentTelemetry
(
gBrowser
.
selectedTab
"
back
"
)
;
gBrowser
.
goBack
(
)
;
}
catch
(
ex
)
{
}
}
else
{
duplicateTabIn
(
gBrowser
.
selectedTab
where
-
1
)
;
}
}
function
BrowserHandleBackspace
(
)
{
switch
(
gPrefService
.
getIntPref
(
"
browser
.
backspace_action
"
)
)
{
case
0
:
BrowserBack
(
)
;
break
;
case
1
:
goDoCommand
(
"
cmd_scrollPageUp
"
)
;
break
;
}
}
function
BrowserHandleShiftBackspace
(
)
{
switch
(
gPrefService
.
getIntPref
(
"
browser
.
backspace_action
"
)
)
{
case
0
:
BrowserForward
(
)
;
break
;
case
1
:
goDoCommand
(
"
cmd_scrollPageDown
"
)
;
break
;
}
}
function
BrowserStop
(
)
{
const
stopFlags
=
nsIWebNavigation
.
STOP_ALL
;
maybeRecordAbandonmentTelemetry
(
gBrowser
.
selectedTab
"
stop
"
)
;
gBrowser
.
webNavigation
.
stop
(
stopFlags
)
;
}
function
BrowserReloadOrDuplicate
(
aEvent
)
{
let
metaKeyPressed
=
AppConstants
.
platform
=
=
"
macosx
"
?
aEvent
.
metaKey
:
aEvent
.
ctrlKey
;
var
backgroundTabModifier
=
aEvent
.
button
=
=
1
|
|
metaKeyPressed
;
if
(
aEvent
.
shiftKey
&
&
!
backgroundTabModifier
)
{
BrowserReloadSkipCache
(
)
;
return
;
}
let
where
=
whereToOpenLink
(
aEvent
false
true
)
;
if
(
where
=
=
"
current
"
)
BrowserReload
(
)
;
else
duplicateTabIn
(
gBrowser
.
selectedTab
where
)
;
}
function
BrowserReload
(
)
{
if
(
gBrowser
.
currentURI
.
schemeIs
(
"
view
-
source
"
)
)
{
return
BrowserReloadSkipCache
(
)
;
}
const
reloadFlags
=
nsIWebNavigation
.
LOAD_FLAGS_NONE
;
BrowserReloadWithFlags
(
reloadFlags
)
;
}
function
BrowserReloadSkipCache
(
)
{
const
reloadFlags
=
nsIWebNavigation
.
LOAD_FLAGS_BYPASS_PROXY
|
nsIWebNavigation
.
LOAD_FLAGS_BYPASS_CACHE
;
BrowserReloadWithFlags
(
reloadFlags
)
;
}
var
BrowserHome
=
BrowserGoHome
;
function
BrowserGoHome
(
aEvent
)
{
if
(
aEvent
&
&
"
button
"
in
aEvent
&
&
aEvent
.
button
=
=
2
)
return
;
var
homePage
=
gHomeButton
.
getHomePage
(
)
;
var
where
=
whereToOpenLink
(
aEvent
false
true
)
;
var
urls
;
if
(
where
=
=
"
current
"
&
&
gBrowser
&
&
gBrowser
.
selectedTab
.
pinned
)
where
=
"
tab
"
;
switch
(
where
)
{
case
"
current
"
:
loadOneOrMoreURIs
(
homePage
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
)
;
break
;
case
"
tabshifted
"
:
case
"
tab
"
:
urls
=
homePage
.
split
(
"
|
"
)
;
var
loadInBackground
=
getBoolPref
(
"
browser
.
tabs
.
loadBookmarksInBackground
"
false
)
;
gBrowser
.
loadTabs
(
urls
{
inBackground
:
loadInBackground
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
}
)
;
break
;
case
"
window
"
:
OpenBrowserWindow
(
)
;
break
;
}
}
function
loadOneOrMoreURIs
(
aURIString
aTriggeringPrincipal
)
{
if
(
window
.
location
.
href
!
=
getBrowserURL
(
)
)
{
window
.
openDialog
(
getBrowserURL
(
)
"
_blank
"
"
all
dialog
=
no
"
aURIString
)
;
return
;
}
try
{
gBrowser
.
loadTabs
(
aURIString
.
split
(
"
|
"
)
{
inBackground
:
false
replace
:
true
triggeringPrincipal
:
aTriggeringPrincipal
}
)
;
}
catch
(
e
)
{
}
}
function
focusAndSelectUrlBar
(
)
{
if
(
CustomizationHandler
.
isExitingCustomizeMode
)
{
gNavToolbox
.
addEventListener
(
"
aftercustomization
"
function
(
)
{
focusAndSelectUrlBar
(
)
;
}
{
once
:
true
}
)
;
return
true
;
}
if
(
gURLBar
)
{
if
(
window
.
fullScreen
)
FullScreen
.
showNavToolbox
(
)
;
gURLBar
.
select
(
)
;
if
(
document
.
activeElement
=
=
gURLBar
.
inputField
)
return
true
;
}
return
false
;
}
function
openLocation
(
)
{
if
(
focusAndSelectUrlBar
(
)
)
return
;
if
(
window
.
location
.
href
!
=
getBrowserURL
(
)
)
{
var
win
=
getTopWin
(
)
;
if
(
win
)
{
win
.
focus
(
)
win
.
openLocation
(
)
;
}
else
{
window
.
openDialog
(
"
chrome
:
/
/
browser
/
content
/
"
"
_blank
"
"
chrome
all
dialog
=
no
"
BROWSER_NEW_TAB_URL
)
;
}
}
}
function
BrowserOpenTab
(
event
)
{
Services
.
obs
.
notifyObservers
(
null
"
browser
-
open
-
newtab
-
start
"
)
;
let
where
=
"
tab
"
;
let
relatedToCurrent
=
false
;
if
(
event
)
{
where
=
whereToOpenLink
(
event
false
true
)
;
switch
(
where
)
{
case
"
tab
"
:
case
"
tabshifted
"
:
relatedToCurrent
=
true
;
break
;
case
"
current
"
:
where
=
"
tab
"
;
break
;
}
}
openUILinkIn
(
BROWSER_NEW_TAB_URL
where
{
relatedToCurrent
}
)
;
}
function
delayedOpenWindow
(
chrome
flags
href
postData
)
{
setTimeout
(
function
(
)
{
openDialog
(
chrome
"
_blank
"
flags
href
null
null
postData
)
;
}
10
)
;
}
function
delayedOpenTab
(
aUrl
aReferrer
aCharset
aPostData
aAllowThirdPartyFixup
)
{
gBrowser
.
loadOneTab
(
aUrl
{
referrerURI
:
aReferrer
charset
:
aCharset
postData
:
aPostData
inBackground
:
false
allowThirdPartyFixup
:
aAllowThirdPartyFixup
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
}
)
;
}
var
gLastOpenDirectory
=
{
_lastDir
:
null
get
path
(
)
{
if
(
!
this
.
_lastDir
|
|
!
this
.
_lastDir
.
exists
(
)
)
{
try
{
this
.
_lastDir
=
gPrefService
.
getComplexValue
(
"
browser
.
open
.
lastDir
"
Ci
.
nsIFile
)
;
if
(
!
this
.
_lastDir
.
exists
(
)
)
this
.
_lastDir
=
null
;
}
catch
(
e
)
{
}
}
return
this
.
_lastDir
;
}
set
path
(
val
)
{
try
{
if
(
!
val
|
|
!
val
.
isDirectory
(
)
)
return
;
}
catch
(
e
)
{
return
;
}
this
.
_lastDir
=
val
.
clone
(
)
;
if
(
!
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
gPrefService
.
setComplexValue
(
"
browser
.
open
.
lastDir
"
Ci
.
nsIFile
this
.
_lastDir
)
;
}
reset
(
)
{
this
.
_lastDir
=
null
;
}
}
;
function
BrowserOpenFileWindow
(
)
{
try
{
const
nsIFilePicker
=
Ci
.
nsIFilePicker
;
let
fp
=
Cc
[
"
mozilla
.
org
/
filepicker
;
1
"
]
.
createInstance
(
nsIFilePicker
)
;
let
fpCallback
=
function
fpCallback_done
(
aResult
)
{
if
(
aResult
=
=
nsIFilePicker
.
returnOK
)
{
try
{
if
(
fp
.
file
)
{
gLastOpenDirectory
.
path
=
fp
.
file
.
parent
.
QueryInterface
(
Ci
.
nsIFile
)
;
}
}
catch
(
ex
)
{
}
openUILinkIn
(
fp
.
fileURL
.
spec
"
current
"
)
;
}
}
;
fp
.
init
(
window
gNavigatorBundle
.
getString
(
"
openFile
"
)
nsIFilePicker
.
modeOpen
)
;
fp
.
appendFilters
(
nsIFilePicker
.
filterAll
|
nsIFilePicker
.
filterText
|
nsIFilePicker
.
filterImages
|
nsIFilePicker
.
filterXML
|
nsIFilePicker
.
filterHTML
)
;
fp
.
displayDirectory
=
gLastOpenDirectory
.
path
;
fp
.
open
(
fpCallback
)
;
}
catch
(
ex
)
{
}
}
function
BrowserCloseTabOrWindow
(
)
{
if
(
window
.
location
.
href
!
=
getBrowserURL
(
)
)
{
closeWindow
(
true
)
;
return
;
}
gBrowser
.
removeCurrentTab
(
{
animate
:
true
}
)
;
}
function
BrowserTryToCloseWindow
(
)
{
if
(
WindowIsClosing
(
)
)
window
.
close
(
)
;
}
function
loadURI
(
uri
referrer
postData
allowThirdPartyFixup
referrerPolicy
userContextId
originPrincipal
forceAboutBlankViewerInCurrent
triggeringPrincipal
)
{
try
{
openLinkIn
(
uri
"
current
"
{
referrerURI
:
referrer
referrerPolicy
postData
allowThirdPartyFixup
userContextId
originPrincipal
triggeringPrincipal
forceAboutBlankViewerInCurrent
}
)
;
}
catch
(
e
)
{
}
}
function
getShortcutOrURIAndPostData
(
url
callback
=
null
)
{
if
(
callback
)
{
Deprecated
.
warning
(
"
Please
use
the
Promise
returned
by
"
+
"
getShortcutOrURIAndPostData
(
)
instead
of
passing
a
"
+
"
callback
"
"
https
:
/
/
bugzilla
.
mozilla
.
org
/
show_bug
.
cgi
?
id
=
1100294
"
)
;
}
return
(
async
function
(
)
{
let
mayInheritPrincipal
=
false
;
let
postData
=
null
;
let
[
keyword
param
=
"
"
]
=
url
.
trim
(
)
.
split
(
/
\
s
(
.
+
)
/
2
)
;
if
(
!
keyword
)
{
return
{
url
postData
mayInheritPrincipal
}
;
}
let
engine
=
Services
.
search
.
getEngineByAlias
(
keyword
)
;
if
(
engine
)
{
let
submission
=
engine
.
getSubmission
(
param
null
"
keyword
"
)
;
return
{
url
:
submission
.
uri
.
spec
postData
:
submission
.
postData
mayInheritPrincipal
}
;
}
let
entry
=
null
;
try
{
entry
=
await
PlacesUtils
.
keywords
.
fetch
(
keyword
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
Unable
to
fetch
Places
keyword
"
{
keyword
}
"
:
{
ex
}
)
;
}
if
(
!
entry
|
|
!
entry
.
url
)
{
return
{
url
postData
mayInheritPrincipal
}
;
}
try
{
[
url
postData
]
=
await
BrowserUtils
.
parseUrlAndPostData
(
entry
.
url
.
href
entry
.
postData
param
)
;
if
(
postData
)
{
postData
=
getPostDataStream
(
postData
)
;
}
mayInheritPrincipal
=
true
;
}
catch
(
ex
)
{
}
return
{
url
postData
mayInheritPrincipal
}
;
}
)
(
)
.
then
(
data
=
>
{
if
(
callback
)
{
callback
(
data
)
;
}
return
data
;
}
)
;
}
function
getPostDataStream
(
aPostDataString
aType
=
"
application
/
x
-
www
-
form
-
urlencoded
"
)
{
let
dataStream
=
Cc
[
"
mozilla
.
org
/
io
/
string
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIStringInputStream
)
;
dataStream
.
data
=
aPostDataString
;
let
mimeStream
=
Cc
[
"
mozilla
.
org
/
network
/
mime
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIMIMEInputStream
)
;
mimeStream
.
addHeader
(
"
Content
-
Type
"
aType
)
;
mimeStream
.
addContentLength
=
true
;
mimeStream
.
setData
(
dataStream
)
;
return
mimeStream
.
QueryInterface
(
Ci
.
nsIInputStream
)
;
}
function
getLoadContext
(
)
{
return
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebNavigation
)
.
QueryInterface
(
Ci
.
nsILoadContext
)
;
}
function
readFromClipboard
(
)
{
var
url
;
try
{
var
trans
=
Components
.
classes
[
"
mozilla
.
org
/
widget
/
transferable
;
1
"
]
.
createInstance
(
Components
.
interfaces
.
nsITransferable
)
;
trans
.
init
(
getLoadContext
(
)
)
;
trans
.
addDataFlavor
(
"
text
/
unicode
"
)
;
if
(
Services
.
clipboard
.
supportsSelectionClipboard
(
)
)
Services
.
clipboard
.
getData
(
trans
Services
.
clipboard
.
kSelectionClipboard
)
;
else
Services
.
clipboard
.
getData
(
trans
Services
.
clipboard
.
kGlobalClipboard
)
;
var
data
=
{
}
;
var
dataLen
=
{
}
;
trans
.
getTransferData
(
"
text
/
unicode
"
data
dataLen
)
;
if
(
data
)
{
data
=
data
.
value
.
QueryInterface
(
Components
.
interfaces
.
nsISupportsString
)
;
url
=
data
.
data
.
substring
(
0
dataLen
.
value
/
2
)
;
}
}
catch
(
ex
)
{
}
return
url
;
}
function
BrowserViewSourceOfDocument
(
aArgsOrDocument
)
{
let
args
;
if
(
aArgsOrDocument
instanceof
Document
)
{
let
doc
=
aArgsOrDocument
;
if
(
Cu
.
isCrossProcessWrapper
(
doc
)
)
{
throw
new
Error
(
"
BrowserViewSourceOfDocument
cannot
accept
a
CPOW
"
+
"
as
a
document
.
"
)
;
}
let
requestor
=
doc
.
defaultView
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
;
let
browser
=
requestor
.
getInterface
(
Ci
.
nsIWebNavigation
)
.
QueryInterface
(
Ci
.
nsIDocShell
)
.
chromeEventHandler
;
let
outerWindowID
=
requestor
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
.
outerWindowID
;
let
URL
=
browser
.
currentURI
.
spec
;
args
=
{
browser
outerWindowID
URL
}
;
}
else
{
args
=
aArgsOrDocument
;
}
let
viewInternal
=
(
)
=
>
{
let
inTab
=
Services
.
prefs
.
getBoolPref
(
"
view_source
.
tab
"
)
;
if
(
inTab
)
{
let
tabBrowser
=
gBrowser
;
let
preferredRemoteType
;
if
(
args
.
browser
)
{
preferredRemoteType
=
args
.
browser
.
remoteType
;
}
else
{
if
(
!
tabBrowser
)
{
throw
new
Error
(
"
BrowserViewSourceOfDocument
should
be
passed
the
"
+
"
subject
browser
if
called
from
a
window
without
"
+
"
gBrowser
defined
.
"
)
;
}
preferredRemoteType
=
E10SUtils
.
getRemoteTypeForURI
(
args
.
URL
gMultiProcessBrowser
)
;
}
if
(
!
tabBrowser
|
|
!
window
.
toolbar
.
visible
)
{
let
browserWindow
=
RecentWindow
.
getMostRecentBrowserWindow
(
)
;
tabBrowser
=
browserWindow
.
gBrowser
;
}
let
tab
=
tabBrowser
.
loadOneTab
(
"
about
:
blank
"
{
relatedToCurrent
:
true
inBackground
:
false
preferredRemoteType
sameProcessAsFrameLoader
:
args
.
browser
?
args
.
browser
.
frameLoader
:
null
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
}
)
;
args
.
viewSourceBrowser
=
tabBrowser
.
getBrowserForTab
(
tab
)
;
top
.
gViewSourceUtils
.
viewSourceInBrowser
(
args
)
;
}
else
{
top
.
gViewSourceUtils
.
viewSource
(
args
)
;
}
}
if
(
Services
.
prefs
.
getBoolPref
(
"
view_source
.
editor
.
external
"
)
)
{
top
.
gViewSourceUtils
.
openInExternalEditor
(
args
null
null
null
result
=
>
{
if
(
!
result
)
{
viewInternal
(
)
;
}
}
)
;
}
else
{
viewInternal
(
)
;
}
}
function
BrowserViewSource
(
browser
)
{
BrowserViewSourceOfDocument
(
{
browser
outerWindowID
:
browser
.
outerWindowID
URL
:
browser
.
currentURI
.
spec
}
)
;
}
function
BrowserPageInfo
(
documentURL
initialTab
imageElement
frameOuterWindowID
browser
)
{
if
(
documentURL
instanceof
HTMLDocument
)
{
Deprecated
.
warning
(
"
Please
pass
the
location
URL
instead
of
the
document
"
+
"
to
BrowserPageInfo
(
)
as
the
first
argument
.
"
"
https
:
/
/
bugzilla
.
mozilla
.
org
/
show_bug
.
cgi
?
id
=
1238180
"
)
;
documentURL
=
documentURL
.
location
;
}
let
args
=
{
initialTab
imageElement
frameOuterWindowID
browser
}
;
var
windows
=
Services
.
wm
.
getEnumerator
(
"
Browser
:
page
-
info
"
)
;
documentURL
=
documentURL
|
|
window
.
gBrowser
.
selectedBrowser
.
currentURI
.
spec
;
while
(
windows
.
hasMoreElements
(
)
)
{
var
currentWindow
=
windows
.
getNext
(
)
;
if
(
currentWindow
.
closed
)
{
continue
;
}
if
(
currentWindow
.
document
.
documentElement
.
getAttribute
(
"
relatedUrl
"
)
=
=
documentURL
)
{
currentWindow
.
focus
(
)
;
currentWindow
.
resetPageInfo
(
args
)
;
return
currentWindow
;
}
}
return
openDialog
(
"
chrome
:
/
/
browser
/
content
/
pageinfo
/
pageInfo
.
xul
"
"
"
"
chrome
toolbar
dialog
=
no
resizable
"
args
)
;
}
function
URLBarSetURI
(
aURI
)
{
var
value
=
gBrowser
.
userTypedValue
;
var
valid
=
false
;
if
(
value
=
=
null
)
{
let
uri
=
aURI
|
|
gBrowser
.
currentURI
;
try
{
uri
=
Services
.
uriFixup
.
createExposableURI
(
uri
)
;
}
catch
(
e
)
{
}
if
(
gInitialPages
.
includes
(
uri
.
spec
)
&
&
checkEmptyPageOrigin
(
gBrowser
.
selectedBrowser
uri
)
)
{
value
=
"
"
;
}
else
{
try
{
value
=
losslessDecodeURI
(
uri
)
;
}
catch
(
ex
)
{
value
=
"
about
:
blank
"
;
}
}
valid
=
!
isBlankPageURL
(
uri
.
spec
)
;
}
let
isDifferentValidValue
=
valid
&
&
value
!
=
gURLBar
.
value
;
gURLBar
.
value
=
value
;
gURLBar
.
valueIsTyped
=
!
valid
;
if
(
isDifferentValidValue
)
{
gURLBar
.
selectionStart
=
gURLBar
.
selectionEnd
=
0
;
}
SetPageProxyState
(
valid
?
"
valid
"
:
"
invalid
"
)
;
}
function
losslessDecodeURI
(
aURI
)
{
let
scheme
=
aURI
.
scheme
;
if
(
scheme
=
=
"
moz
-
action
"
)
throw
new
Error
(
"
losslessDecodeURI
should
never
get
a
moz
-
action
URI
"
)
;
var
value
=
aURI
.
displaySpec
;
let
decodeASCIIOnly
=
!
[
"
https
"
"
http
"
"
file
"
"
ftp
"
]
.
includes
(
scheme
)
;
if
(
!
/
%
25
(
?
:
3B
|
2F
|
3F
|
3A
|
40
|
26
|
3D
|
2B
|
24
|
2C
|
23
)
/
i
.
test
(
value
)
)
{
if
(
decodeASCIIOnly
)
{
value
=
value
.
replace
(
/
%
(
2
[
0
-
4
]
|
2
[
6
-
9a
-
f
]
|
[
3
-
6
]
[
0
-
9a
-
f
]
|
7
[
0
-
9a
-
e
]
)
/
g
decodeURI
)
;
}
else
{
try
{
value
=
decodeURI
(
value
)
.
replace
(
/
%
(
?
!
3B
|
2F
|
3F
|
3A
|
40
|
26
|
3D
|
2B
|
24
|
2C
|
23
)
|
[
\
r
\
n
\
t
]
/
ig
encodeURIComponent
)
;
}
catch
(
e
)
{
}
}
}
value
=
value
.
replace
(
/
[
\
u0000
-
\
u001f
\
u007f
-
\
u00a0
\
u2028
\
u2029
\
ufffc
]
/
g
encodeURIComponent
)
;
value
=
value
.
replace
(
/
[
\
u00ad
\
u034f
\
u061c
\
u115f
-
\
u1160
\
u17b4
-
\
u17b5
\
u180b
-
\
u180d
\
u200b
\
u200e
-
\
u200f
\
u202a
-
\
u202e
\
u2060
-
\
u206f
\
u3164
\
ufe00
-
\
ufe0f
\
ufeff
\
uffa0
\
ufff0
-
\
ufff8
]
|
\
ud834
[
\
udd73
-
\
udd7a
]
|
[
\
udb40
-
\
udb43
]
[
\
udc00
-
\
udfff
]
/
g
encodeURIComponent
)
;
return
value
;
}
function
UpdateUrlbarSearchSplitterState
(
)
{
var
splitter
=
document
.
getElementById
(
"
urlbar
-
search
-
splitter
"
)
;
var
urlbar
=
document
.
getElementById
(
"
urlbar
-
container
"
)
;
var
searchbar
=
document
.
getElementById
(
"
search
-
container
"
)
;
if
(
document
.
documentElement
.
getAttribute
(
"
customizing
"
)
=
=
"
true
"
)
{
if
(
splitter
)
{
splitter
.
remove
(
)
;
}
return
;
}
if
(
splitter
&
&
(
(
splitter
.
nextSibling
=
=
searchbar
&
&
splitter
.
previousSibling
=
=
urlbar
)
|
|
(
splitter
.
nextSibling
=
=
urlbar
&
&
splitter
.
previousSibling
=
=
searchbar
)
)
)
{
return
;
}
var
ibefore
=
null
;
if
(
urlbar
&
&
searchbar
)
{
if
(
urlbar
.
nextSibling
=
=
searchbar
)
ibefore
=
searchbar
;
else
if
(
searchbar
.
nextSibling
=
=
urlbar
)
ibefore
=
urlbar
;
}
if
(
ibefore
)
{
if
(
!
splitter
)
{
splitter
=
document
.
createElement
(
"
splitter
"
)
;
splitter
.
id
=
"
urlbar
-
search
-
splitter
"
;
splitter
.
setAttribute
(
"
resizebefore
"
"
flex
"
)
;
splitter
.
setAttribute
(
"
resizeafter
"
"
flex
"
)
;
splitter
.
setAttribute
(
"
skipintoolbarset
"
"
true
"
)
;
splitter
.
setAttribute
(
"
overflows
"
"
false
"
)
;
splitter
.
className
=
"
chromeclass
-
toolbar
-
additional
"
;
}
urlbar
.
parentNode
.
insertBefore
(
splitter
ibefore
)
;
}
else
if
(
splitter
)
splitter
.
remove
(
)
;
}
function
UpdatePageProxyState
(
)
{
if
(
gURLBar
&
&
gURLBar
.
value
!
=
gLastValidURLStr
)
SetPageProxyState
(
"
invalid
"
)
;
}
function
SetPageProxyState
(
aState
)
{
if
(
!
gURLBar
)
return
;
let
oldPageProxyState
=
gURLBar
.
getAttribute
(
"
pageproxystate
"
)
;
gURLBar
.
setAttribute
(
"
pageproxystate
"
aState
)
;
if
(
aState
=
=
"
valid
"
)
{
gLastValidURLStr
=
gURLBar
.
value
;
gURLBar
.
addEventListener
(
"
input
"
UpdatePageProxyState
)
;
}
else
if
(
aState
=
=
"
invalid
"
)
{
gURLBar
.
removeEventListener
(
"
input
"
UpdatePageProxyState
)
;
}
if
(
oldPageProxyState
=
=
aState
)
{
return
;
}
UpdatePopupNotificationsVisibility
(
)
;
}
function
UpdatePopupNotificationsVisibility
(
)
{
if
(
Object
.
getOwnPropertyDescriptor
(
window
"
PopupNotifications
"
)
.
get
)
{
return
;
}
PopupNotifications
.
anchorVisibilityChange
(
)
;
}
function
PageProxyClickHandler
(
aEvent
)
{
if
(
aEvent
.
button
=
=
1
&
&
gPrefService
.
getBoolPref
(
"
middlemouse
.
paste
"
)
)
middleMousePaste
(
aEvent
)
;
}
const
TLS_ERROR_REPORT_TELEMETRY_AUTO_CHECKED
=
2
;
const
TLS_ERROR_REPORT_TELEMETRY_AUTO_UNCHECKED
=
3
;
const
TLS_ERROR_REPORT_TELEMETRY_MANUAL_SEND
=
4
;
const
TLS_ERROR_REPORT_TELEMETRY_AUTO_SEND
=
5
;
const
PREF_SSL_IMPACT_ROOTS
=
[
"
security
.
tls
.
version
.
"
"
security
.
ssl3
.
"
]
;
const
PREF_SSL_IMPACT
=
PREF_SSL_IMPACT_ROOTS
.
reduce
(
(
prefs
root
)
=
>
{
return
prefs
.
concat
(
Services
.
prefs
.
getChildList
(
root
)
)
;
}
[
]
)
;
var
BrowserOnClick
=
{
init
(
)
{
let
mm
=
window
.
messageManager
;
mm
.
addMessageListener
(
"
Browser
:
CertExceptionError
"
this
)
;
mm
.
addMessageListener
(
"
Browser
:
OpenCaptivePortalPage
"
this
)
;
mm
.
addMessageListener
(
"
Browser
:
SiteBlockedError
"
this
)
;
mm
.
addMessageListener
(
"
Browser
:
EnableOnlineMode
"
this
)
;
mm
.
addMessageListener
(
"
Browser
:
SendSSLErrorReport
"
this
)
;
mm
.
addMessageListener
(
"
Browser
:
SetSSLErrorReportAuto
"
this
)
;
mm
.
addMessageListener
(
"
Browser
:
ResetSSLPreferences
"
this
)
;
mm
.
addMessageListener
(
"
Browser
:
SSLErrorReportTelemetry
"
this
)
;
mm
.
addMessageListener
(
"
Browser
:
SSLErrorGoBack
"
this
)
;
Services
.
obs
.
addObserver
(
this
"
captive
-
portal
-
login
-
abort
"
)
;
Services
.
obs
.
addObserver
(
this
"
captive
-
portal
-
login
-
success
"
)
;
}
uninit
(
)
{
let
mm
=
window
.
messageManager
;
mm
.
removeMessageListener
(
"
Browser
:
CertExceptionError
"
this
)
;
mm
.
removeMessageListener
(
"
Browser
:
SiteBlockedError
"
this
)
;
mm
.
removeMessageListener
(
"
Browser
:
EnableOnlineMode
"
this
)
;
mm
.
removeMessageListener
(
"
Browser
:
SendSSLErrorReport
"
this
)
;
mm
.
removeMessageListener
(
"
Browser
:
SetSSLErrorReportAuto
"
this
)
;
mm
.
removeMessageListener
(
"
Browser
:
ResetSSLPreferences
"
this
)
;
mm
.
removeMessageListener
(
"
Browser
:
SSLErrorReportTelemetry
"
this
)
;
mm
.
removeMessageListener
(
"
Browser
:
SSLErrorGoBack
"
this
)
;
Services
.
obs
.
removeObserver
(
this
"
captive
-
portal
-
login
-
abort
"
)
;
Services
.
obs
.
removeObserver
(
this
"
captive
-
portal
-
login
-
success
"
)
;
}
observe
(
aSubject
aTopic
aData
)
{
switch
(
aTopic
)
{
case
"
captive
-
portal
-
login
-
abort
"
:
case
"
captive
-
portal
-
login
-
success
"
:
window
.
messageManager
.
broadcastAsyncMessage
(
"
Browser
:
CaptivePortalFreed
"
)
;
break
;
}
}
receiveMessage
(
msg
)
{
switch
(
msg
.
name
)
{
case
"
Browser
:
CertExceptionError
"
:
this
.
onCertError
(
msg
.
target
msg
.
data
.
elementId
msg
.
data
.
isTopFrame
msg
.
data
.
location
msg
.
data
.
securityInfoAsString
)
;
break
;
case
"
Browser
:
OpenCaptivePortalPage
"
:
CaptivePortalWatcher
.
ensureCaptivePortalTab
(
)
;
break
;
case
"
Browser
:
SiteBlockedError
"
:
this
.
onAboutBlocked
(
msg
.
data
.
elementId
msg
.
data
.
reason
msg
.
data
.
isTopFrame
msg
.
data
.
location
msg
.
data
.
blockedInfo
)
;
break
;
case
"
Browser
:
EnableOnlineMode
"
:
if
(
Services
.
io
.
offline
)
{
Services
.
io
.
offline
=
false
;
msg
.
target
.
reload
(
)
;
}
break
;
case
"
Browser
:
SendSSLErrorReport
"
:
this
.
onSSLErrorReport
(
msg
.
target
msg
.
data
.
uri
msg
.
data
.
securityInfo
)
;
break
;
case
"
Browser
:
ResetSSLPreferences
"
:
for
(
let
prefName
of
PREF_SSL_IMPACT
)
{
Services
.
prefs
.
clearUserPref
(
prefName
)
;
}
msg
.
target
.
reload
(
)
;
break
;
case
"
Browser
:
SetSSLErrorReportAuto
"
:
Services
.
prefs
.
setBoolPref
(
"
security
.
ssl
.
errorReporting
.
automatic
"
msg
.
json
.
automatic
)
;
let
bin
=
TLS_ERROR_REPORT_TELEMETRY_AUTO_UNCHECKED
;
if
(
msg
.
json
.
automatic
)
{
bin
=
TLS_ERROR_REPORT_TELEMETRY_AUTO_CHECKED
;
}
Services
.
telemetry
.
getHistogramById
(
"
TLS_ERROR_REPORT_UI
"
)
.
add
(
bin
)
;
break
;
case
"
Browser
:
SSLErrorReportTelemetry
"
:
let
reportStatus
=
msg
.
data
.
reportStatus
;
Services
.
telemetry
.
getHistogramById
(
"
TLS_ERROR_REPORT_UI
"
)
.
add
(
reportStatus
)
;
break
;
case
"
Browser
:
SSLErrorGoBack
"
:
goBackFromErrorPage
(
)
;
break
;
}
}
onSSLErrorReport
(
browser
uri
securityInfo
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
"
security
.
ssl
.
errorReporting
.
enabled
"
)
)
{
Cu
.
reportError
(
"
User
requested
certificate
error
report
sending
but
certificate
error
reporting
is
disabled
"
)
;
return
;
}
let
serhelper
=
Cc
[
"
mozilla
.
org
/
network
/
serialization
-
helper
;
1
"
]
.
getService
(
Ci
.
nsISerializationHelper
)
;
let
transportSecurityInfo
=
serhelper
.
deserializeObject
(
securityInfo
)
;
transportSecurityInfo
.
QueryInterface
(
Ci
.
nsITransportSecurityInfo
)
let
errorReporter
=
Cc
[
"
mozilla
.
org
/
securityreporter
;
1
"
]
.
getService
(
Ci
.
nsISecurityReporter
)
;
errorReporter
.
reportTLSError
(
transportSecurityInfo
uri
.
host
uri
.
port
)
;
}
onCertError
(
browser
elementId
isTopFrame
location
securityInfoAsString
)
{
let
secHistogram
=
Services
.
telemetry
.
getHistogramById
(
"
SECURITY_UI
"
)
;
let
securityInfo
;
switch
(
elementId
)
{
case
"
exceptionDialogButton
"
:
if
(
isTopFrame
)
{
secHistogram
.
add
(
Ci
.
nsISecurityUITelemetry
.
WARNING_BAD_CERT_TOP_CLICK_ADD_EXCEPTION
)
;
}
securityInfo
=
getSecurityInfo
(
securityInfoAsString
)
;
let
sslStatus
=
securityInfo
.
QueryInterface
(
Ci
.
nsISSLStatusProvider
)
.
SSLStatus
;
let
params
=
{
exceptionAdded
:
false
sslStatus
}
;
try
{
switch
(
Services
.
prefs
.
getIntPref
(
"
browser
.
ssl_override_behavior
"
)
)
{
case
2
:
params
.
prefetchCert
=
true
;
case
1
:
params
.
location
=
location
;
}
}
catch
(
e
)
{
Components
.
utils
.
reportError
(
"
Couldn
'
t
get
ssl_override
pref
:
"
+
e
)
;
}
window
.
openDialog
(
"
chrome
:
/
/
pippki
/
content
/
exceptionDialog
.
xul
"
"
"
"
chrome
centerscreen
modal
"
params
)
;
if
(
params
.
exceptionAdded
)
{
browser
.
reload
(
)
;
}
break
;
case
"
returnButton
"
:
if
(
isTopFrame
)
{
secHistogram
.
add
(
Ci
.
nsISecurityUITelemetry
.
WARNING_BAD_CERT_TOP_GET_ME_OUT_OF_HERE
)
;
}
goBackFromErrorPage
(
)
;
break
;
case
"
advancedButton
"
:
if
(
isTopFrame
)
{
secHistogram
.
add
(
Ci
.
nsISecurityUITelemetry
.
WARNING_BAD_CERT_TOP_UNDERSTAND_RISKS
)
;
}
securityInfo
=
getSecurityInfo
(
securityInfoAsString
)
;
let
errorInfo
=
getDetailedCertErrorInfo
(
location
securityInfo
)
;
browser
.
messageManager
.
sendAsyncMessage
(
"
CertErrorDetails
"
{
code
:
securityInfo
.
errorCode
info
:
errorInfo
}
)
;
break
;
case
"
copyToClipboard
"
:
const
gClipboardHelper
=
Cc
[
"
mozilla
.
org
/
widget
/
clipboardhelper
;
1
"
]
.
getService
(
Ci
.
nsIClipboardHelper
)
;
securityInfo
=
getSecurityInfo
(
securityInfoAsString
)
;
let
detailedInfo
=
getDetailedCertErrorInfo
(
location
securityInfo
)
;
gClipboardHelper
.
copyString
(
detailedInfo
)
;
break
;
}
}
onAboutBlocked
(
elementId
reason
isTopFrame
location
blockedInfo
)
{
let
bucketName
=
"
"
;
let
sendTelemetry
=
false
;
if
(
reason
=
=
=
"
malware
"
)
{
sendTelemetry
=
true
;
bucketName
=
"
WARNING_MALWARE_PAGE_
"
;
}
else
if
(
reason
=
=
=
"
phishing
"
)
{
sendTelemetry
=
true
;
bucketName
=
"
WARNING_PHISHING_PAGE_
"
;
}
else
if
(
reason
=
=
=
"
unwanted
"
)
{
sendTelemetry
=
true
;
bucketName
=
"
WARNING_UNWANTED_PAGE_
"
;
}
else
if
(
reason
=
=
=
"
harmful
"
)
{
sendTelemetry
=
true
;
bucketName
=
"
WARNING_HARMFUL_PAGE_
"
;
}
let
secHistogram
=
Services
.
telemetry
.
getHistogramById
(
"
URLCLASSIFIER_UI_EVENTS
"
)
;
let
nsISecTel
=
Ci
.
IUrlClassifierUITelemetry
;
bucketName
+
=
isTopFrame
?
"
TOP_
"
:
"
FRAME_
"
;
switch
(
elementId
)
{
case
"
getMeOutButton
"
:
if
(
sendTelemetry
)
{
secHistogram
.
add
(
nsISecTel
[
bucketName
+
"
GET_ME_OUT_OF_HERE
"
]
)
;
}
getMeOutOfHere
(
)
;
break
;
case
"
reportButton
"
:
if
(
sendTelemetry
)
{
secHistogram
.
add
(
nsISecTel
[
bucketName
+
"
WHY_BLOCKED
"
]
)
;
}
openHelpLink
(
"
phishing
-
malware
"
false
"
current
"
)
;
break
;
case
"
ignoreWarningButton
"
:
if
(
gPrefService
.
getBoolPref
(
"
browser
.
safebrowsing
.
allowOverride
"
)
)
{
if
(
sendTelemetry
)
{
secHistogram
.
add
(
nsISecTel
[
bucketName
+
"
IGNORE_WARNING
"
]
)
;
}
this
.
ignoreWarningButton
(
reason
blockedInfo
)
;
}
break
;
}
}
ignoreWarningButton
(
reason
blockedInfo
)
{
gBrowser
.
loadURIWithFlags
(
gBrowser
.
currentURI
.
spec
nsIWebNavigation
.
LOAD_FLAGS_BYPASS_CLASSIFIER
null
null
null
)
;
Services
.
perms
.
add
(
gBrowser
.
currentURI
"
safe
-
browsing
"
Ci
.
nsIPermissionManager
.
ALLOW_ACTION
Ci
.
nsIPermissionManager
.
EXPIRE_SESSION
)
;
let
buttons
=
[
{
label
:
gNavigatorBundle
.
getString
(
"
safebrowsing
.
getMeOutOfHereButton
.
label
"
)
accessKey
:
gNavigatorBundle
.
getString
(
"
safebrowsing
.
getMeOutOfHereButton
.
accessKey
"
)
callback
(
)
{
getMeOutOfHere
(
)
;
}
}
]
;
let
title
;
if
(
reason
=
=
=
"
malware
"
)
{
let
reportUrl
=
gSafeBrowsing
.
getReportURL
(
"
MalwareMistake
"
blockedInfo
)
;
title
=
gNavigatorBundle
.
getString
(
"
safebrowsing
.
reportedAttackSite
"
)
;
if
(
reportUrl
)
{
buttons
[
1
]
=
{
label
:
gNavigatorBundle
.
getString
(
"
safebrowsing
.
notAnAttackButton
.
label
"
)
accessKey
:
gNavigatorBundle
.
getString
(
"
safebrowsing
.
notAnAttackButton
.
accessKey
"
)
callback
(
)
{
openUILinkIn
(
reportUrl
"
tab
"
)
;
}
}
;
}
}
else
if
(
reason
=
=
=
"
phishing
"
)
{
let
reportUrl
=
gSafeBrowsing
.
getReportURL
(
"
PhishMistake
"
blockedInfo
)
;
title
=
gNavigatorBundle
.
getString
(
"
safebrowsing
.
deceptiveSite
"
)
;
if
(
reportUrl
)
{
buttons
[
1
]
=
{
label
:
gNavigatorBundle
.
getString
(
"
safebrowsing
.
notADeceptiveSiteButton
.
label
"
)
accessKey
:
gNavigatorBundle
.
getString
(
"
safebrowsing
.
notADeceptiveSiteButton
.
accessKey
"
)
callback
(
)
{
openUILinkIn
(
reportUrl
"
tab
"
)
;
}
}
;
}
}
else
if
(
reason
=
=
=
"
unwanted
"
)
{
title
=
gNavigatorBundle
.
getString
(
"
safebrowsing
.
reportedUnwantedSite
"
)
;
}
else
if
(
reason
=
=
=
"
harmful
"
)
{
title
=
gNavigatorBundle
.
getString
(
"
safebrowsing
.
reportedHarmfulSite
"
)
;
}
let
notificationBox
=
gBrowser
.
getNotificationBox
(
)
;
let
value
=
"
blocked
-
badware
-
page
"
;
let
previousNotification
=
notificationBox
.
getNotificationWithValue
(
value
)
;
if
(
previousNotification
)
{
notificationBox
.
removeNotification
(
previousNotification
)
;
}
let
notification
=
notificationBox
.
appendNotification
(
title
value
"
chrome
:
/
/
global
/
skin
/
icons
/
blacklist_favicon
.
png
"
notificationBox
.
PRIORITY_CRITICAL_HIGH
buttons
)
;
notification
.
persistence
=
-
1
;
}
}
;
function
getMeOutOfHere
(
)
{
gBrowser
.
loadURI
(
getDefaultHomePage
(
)
)
;
}
function
goBackFromErrorPage
(
)
{
const
ss
=
Cc
[
"
mozilla
.
org
/
browser
/
sessionstore
;
1
"
]
.
getService
(
Ci
.
nsISessionStore
)
;
let
state
=
JSON
.
parse
(
ss
.
getTabState
(
gBrowser
.
selectedTab
)
)
;
if
(
state
.
index
=
=
1
)
{
gBrowser
.
loadURI
(
getDefaultHomePage
(
)
)
;
}
else
{
BrowserBack
(
)
;
}
}
function
getDefaultHomePage
(
)
{
var
prefs
=
Services
.
prefs
.
getDefaultBranch
(
null
)
;
var
url
=
BROWSER_NEW_TAB_URL
;
try
{
url
=
prefs
.
getComplexValue
(
"
browser
.
startup
.
homepage
"
Ci
.
nsIPrefLocalizedString
)
.
data
;
if
(
url
.
includes
(
"
|
"
)
)
url
=
url
.
split
(
"
|
"
)
[
0
]
;
}
catch
(
e
)
{
Components
.
utils
.
reportError
(
"
Couldn
'
t
get
homepage
pref
:
"
+
e
)
;
}
return
url
;
}
function
BrowserFullScreen
(
)
{
window
.
fullScreen
=
!
window
.
fullScreen
;
}
function
mirrorShow
(
popup
)
{
let
services
=
[
]
;
if
(
Services
.
prefs
.
getBoolPref
(
"
browser
.
casting
.
enabled
"
)
)
{
services
=
CastingApps
.
getServicesForMirroring
(
)
;
}
popup
.
ownerDocument
.
getElementById
(
"
menu_mirrorTabCmd
"
)
.
hidden
=
!
services
.
length
;
}
function
mirrorMenuItemClicked
(
event
)
{
gBrowser
.
selectedBrowser
.
messageManager
.
sendAsyncMessage
(
"
SecondScreen
:
tab
-
mirror
"
{
service
:
event
.
originalTarget
.
_service
}
)
;
}
function
populateMirrorTabMenu
(
popup
)
{
popup
.
innerHTML
=
null
;
if
(
!
Services
.
prefs
.
getBoolPref
(
"
browser
.
casting
.
enabled
"
)
)
{
return
;
}
let
doc
=
popup
.
ownerDocument
;
let
services
=
CastingApps
.
getServicesForMirroring
(
)
;
services
.
forEach
(
service
=
>
{
let
item
=
doc
.
createElement
(
"
menuitem
"
)
;
item
.
setAttribute
(
"
label
"
service
.
friendlyName
)
;
item
.
_service
=
service
;
item
.
addEventListener
(
"
command
"
mirrorMenuItemClicked
)
;
popup
.
appendChild
(
item
)
;
}
)
;
}
function
getWebNavigation
(
)
{
return
gBrowser
.
webNavigation
;
}
function
BrowserReloadWithFlags
(
reloadFlags
)
{
let
url
=
gBrowser
.
currentURI
.
spec
;
if
(
gBrowser
.
updateBrowserRemotenessByURL
(
gBrowser
.
selectedBrowser
url
)
)
{
gBrowser
.
loadURIWithFlags
(
url
reloadFlags
)
;
return
;
}
maybeRecordAbandonmentTelemetry
(
gBrowser
.
selectedTab
"
reload
"
)
;
SitePermissions
.
clearTemporaryPermissions
(
gBrowser
.
selectedBrowser
)
;
let
windowUtils
=
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
gBrowser
.
selectedBrowser
.
messageManager
.
sendAsyncMessage
(
"
Browser
:
Reload
"
{
flags
:
reloadFlags
handlingUserInput
:
windowUtils
.
isHandlingUserInput
}
)
;
}
function
getSecurityInfo
(
securityInfoAsString
)
{
if
(
!
securityInfoAsString
)
return
null
;
const
serhelper
=
Cc
[
"
mozilla
.
org
/
network
/
serialization
-
helper
;
1
"
]
.
getService
(
Ci
.
nsISerializationHelper
)
;
let
securityInfo
=
serhelper
.
deserializeObject
(
securityInfoAsString
)
;
securityInfo
.
QueryInterface
(
Ci
.
nsITransportSecurityInfo
)
;
return
securityInfo
;
}
function
getDetailedCertErrorInfo
(
location
securityInfo
)
{
if
(
!
securityInfo
)
return
"
"
;
let
certErrorDetails
=
location
;
let
code
=
securityInfo
.
errorCode
;
let
errors
=
Cc
[
"
mozilla
.
org
/
nss_errors_service
;
1
"
]
.
getService
(
Ci
.
nsINSSErrorsService
)
;
certErrorDetails
+
=
"
\
r
\
n
\
r
\
n
"
+
errors
.
getErrorMessage
(
errors
.
getXPCOMFromNSSError
(
code
)
)
;
const
sss
=
Cc
[
"
mozilla
.
org
/
ssservice
;
1
"
]
.
getService
(
Ci
.
nsISiteSecurityService
)
;
let
flags
=
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
?
Ci
.
nsISocketProvider
.
NO_PERMANENT_STORAGE
:
0
;
let
uri
=
Services
.
io
.
newURI
(
location
)
;
let
hasHSTS
=
sss
.
isSecureURI
(
sss
.
HEADER_HSTS
uri
flags
)
;
let
hasHPKP
=
sss
.
isSecureURI
(
sss
.
HEADER_HPKP
uri
flags
)
;
certErrorDetails
+
=
"
\
r
\
n
\
r
\
n
"
+
gNavigatorBundle
.
getFormattedString
(
"
certErrorDetailsHSTS
.
label
"
[
hasHSTS
]
)
;
certErrorDetails
+
=
"
\
r
\
n
"
+
gNavigatorBundle
.
getFormattedString
(
"
certErrorDetailsKeyPinning
.
label
"
[
hasHPKP
]
)
;
let
certChain
=
"
"
;
if
(
securityInfo
.
failedCertChain
)
{
let
certs
=
securityInfo
.
failedCertChain
.
getEnumerator
(
)
;
while
(
certs
.
hasMoreElements
(
)
)
{
let
cert
=
certs
.
getNext
(
)
;
cert
.
QueryInterface
(
Ci
.
nsIX509Cert
)
;
certChain
+
=
getPEMString
(
cert
)
;
}
}
certErrorDetails
+
=
"
\
r
\
n
\
r
\
n
"
+
gNavigatorBundle
.
getString
(
"
certErrorDetailsCertChain
.
label
"
)
+
"
\
r
\
n
\
r
\
n
"
+
certChain
;
return
certErrorDetails
;
}
function
getDERString
(
cert
)
{
var
length
=
{
}
;
var
derArray
=
cert
.
getRawDER
(
length
)
;
var
derString
=
"
"
;
for
(
var
i
=
0
;
i
<
derArray
.
length
;
i
+
+
)
{
derString
+
=
String
.
fromCharCode
(
derArray
[
i
]
)
;
}
return
derString
;
}
function
getPEMString
(
cert
)
{
var
derb64
=
btoa
(
getDERString
(
cert
)
)
;
var
wrapped
=
derb64
.
replace
(
/
(
\
S
{
64
}
(
?
!
)
)
/
g
"
1
\
r
\
n
"
)
;
return
"
-
-
-
-
-
BEGIN
CERTIFICATE
-
-
-
-
-
\
r
\
n
"
+
wrapped
+
"
\
r
\
n
-
-
-
-
-
END
CERTIFICATE
-
-
-
-
-
\
r
\
n
"
;
}
var
PrintPreviewListener
=
{
_printPreviewTab
:
null
_simplifiedPrintPreviewTab
:
null
_tabBeforePrintPreview
:
null
_simplifyPageTab
:
null
_lastRequestedPrintPreviewTab
:
null
_createPPBrowser
(
)
{
let
browser
=
this
.
getSourceBrowser
(
)
;
let
preferredRemoteType
=
browser
.
remoteType
;
return
gBrowser
.
loadOneTab
(
"
about
:
printpreview
"
{
inBackground
:
true
preferredRemoteType
sameProcessAsFrameLoader
:
browser
.
frameLoader
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
}
)
;
}
getPrintPreviewBrowser
(
)
{
if
(
!
this
.
_printPreviewTab
)
{
this
.
_printPreviewTab
=
this
.
_createPPBrowser
(
)
;
}
gBrowser
.
_allowTabChange
=
true
;
this
.
_lastRequestedPrintPreviewTab
=
gBrowser
.
selectedTab
=
this
.
_printPreviewTab
;
gBrowser
.
_allowTabChange
=
false
;
return
gBrowser
.
getBrowserForTab
(
this
.
_printPreviewTab
)
;
}
getSimplifiedPrintPreviewBrowser
(
)
{
if
(
!
this
.
_simplifiedPrintPreviewTab
)
{
this
.
_simplifiedPrintPreviewTab
=
this
.
_createPPBrowser
(
)
;
}
gBrowser
.
_allowTabChange
=
true
;
this
.
_lastRequestedPrintPreviewTab
=
gBrowser
.
selectedTab
=
this
.
_simplifiedPrintPreviewTab
;
gBrowser
.
_allowTabChange
=
false
;
return
gBrowser
.
getBrowserForTab
(
this
.
_simplifiedPrintPreviewTab
)
;
}
createSimplifiedBrowser
(
)
{
let
browser
=
this
.
getSourceBrowser
(
)
;
this
.
_simplifyPageTab
=
gBrowser
.
loadOneTab
(
"
about
:
printpreview
"
{
inBackground
:
true
sameProcessAsFrameLoader
:
browser
.
frameLoader
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
}
)
;
return
this
.
getSimplifiedSourceBrowser
(
)
;
}
getSourceBrowser
(
)
{
if
(
!
this
.
_tabBeforePrintPreview
)
{
this
.
_tabBeforePrintPreview
=
gBrowser
.
selectedTab
;
}
return
this
.
_tabBeforePrintPreview
.
linkedBrowser
;
}
getSimplifiedSourceBrowser
(
)
{
return
this
.
_simplifyPageTab
?
gBrowser
.
getBrowserForTab
(
this
.
_simplifyPageTab
)
:
null
;
}
getNavToolbox
(
)
{
return
gNavToolbox
;
}
onEnter
(
)
{
if
(
gBrowser
.
selectedTab
!
=
this
.
_lastRequestedPrintPreviewTab
)
{
gBrowser
.
selectedTab
=
this
.
_lastRequestedPrintPreviewTab
;
}
gInPrintPreviewMode
=
true
;
this
.
_toggleAffectedChrome
(
)
;
}
onExit
(
)
{
gBrowser
.
_allowTabChange
=
true
;
gBrowser
.
selectedTab
=
this
.
_tabBeforePrintPreview
;
gBrowser
.
_allowTabChange
=
false
;
this
.
_tabBeforePrintPreview
=
null
;
gInPrintPreviewMode
=
false
;
this
.
_toggleAffectedChrome
(
)
;
let
tabsToRemove
=
[
"
_simplifyPageTab
"
"
_printPreviewTab
"
"
_simplifiedPrintPreviewTab
"
]
;
for
(
let
tabProp
of
tabsToRemove
)
{
if
(
this
[
tabProp
]
)
{
gBrowser
.
removeTab
(
this
[
tabProp
]
)
;
this
[
tabProp
]
=
null
;
}
}
gBrowser
.
deactivatePrintPreviewBrowsers
(
)
;
this
.
_lastRequestedPrintPreviewTab
=
null
;
}
_toggleAffectedChrome
(
)
{
gNavToolbox
.
collapsed
=
gInPrintPreviewMode
;
if
(
gInPrintPreviewMode
)
this
.
_hideChrome
(
)
;
else
this
.
_showChrome
(
)
;
TabsInTitlebar
.
allowedBy
(
"
print
-
preview
"
!
gInPrintPreviewMode
)
;
}
_hideChrome
(
)
{
this
.
_chromeState
=
{
}
;
this
.
_chromeState
.
sidebarOpen
=
SidebarUI
.
isOpen
;
this
.
_sidebarCommand
=
SidebarUI
.
currentID
;
SidebarUI
.
hide
(
)
;
var
notificationBox
=
gBrowser
.
getNotificationBox
(
)
;
this
.
_chromeState
.
notificationsOpen
=
!
notificationBox
.
notificationsHidden
;
notificationBox
.
notificationsHidden
=
true
;
this
.
_chromeState
.
findOpen
=
gFindBarInitialized
&
&
!
gFindBar
.
hidden
;
if
(
gFindBarInitialized
)
gFindBar
.
close
(
)
;
var
globalNotificationBox
=
document
.
getElementById
(
"
global
-
notificationbox
"
)
;
this
.
_chromeState
.
globalNotificationsOpen
=
!
globalNotificationBox
.
notificationsHidden
;
globalNotificationBox
.
notificationsHidden
=
true
;
this
.
_chromeState
.
syncNotificationsOpen
=
false
;
var
syncNotifications
=
document
.
getElementById
(
"
sync
-
notifications
"
)
;
if
(
syncNotifications
)
{
this
.
_chromeState
.
syncNotificationsOpen
=
!
syncNotifications
.
notificationsHidden
;
syncNotifications
.
notificationsHidden
=
true
;
}
}
_showChrome
(
)
{
if
(
this
.
_chromeState
.
notificationsOpen
)
gBrowser
.
getNotificationBox
(
)
.
notificationsHidden
=
false
;
if
(
this
.
_chromeState
.
findOpen
)
gFindBar
.
open
(
)
;
if
(
this
.
_chromeState
.
globalNotificationsOpen
)
document
.
getElementById
(
"
global
-
notificationbox
"
)
.
notificationsHidden
=
false
;
if
(
this
.
_chromeState
.
syncNotificationsOpen
)
document
.
getElementById
(
"
sync
-
notifications
"
)
.
notificationsHidden
=
false
;
if
(
this
.
_chromeState
.
sidebarOpen
)
SidebarUI
.
show
(
this
.
_sidebarCommand
)
;
}
activateBrowser
(
browser
)
{
gBrowser
.
activateBrowserForPrintPreview
(
browser
)
;
}
}
function
getMarkupDocumentViewer
(
)
{
return
gBrowser
.
markupDocumentViewer
;
}
function
FillInHTMLTooltip
(
tipElement
)
{
document
.
getElementById
(
"
aHTMLTooltip
"
)
.
fillInPageTooltip
(
tipElement
)
;
}
var
browserDragAndDrop
=
{
canDropLink
:
aEvent
=
>
Services
.
droppedLinkHandler
.
canDropLink
(
aEvent
true
)
dragOver
(
aEvent
)
{
if
(
this
.
canDropLink
(
aEvent
)
)
{
aEvent
.
preventDefault
(
)
;
}
}
getTriggeringPrincipal
(
aEvent
)
{
return
Services
.
droppedLinkHandler
.
getTriggeringPrincipal
(
aEvent
)
;
}
dropLinks
(
aEvent
aDisallowInherit
)
{
return
Services
.
droppedLinkHandler
.
dropLinks
(
aEvent
aDisallowInherit
)
;
}
}
;
var
homeButtonObserver
=
{
onDrop
(
aEvent
)
{
let
links
=
browserDragAndDrop
.
dropLinks
(
aEvent
true
)
;
if
(
links
.
length
)
{
setTimeout
(
openHomeDialog
0
links
.
map
(
link
=
>
link
.
url
)
.
join
(
"
|
"
)
)
;
}
}
onDragOver
(
aEvent
)
{
if
(
gPrefService
.
prefIsLocked
(
"
browser
.
startup
.
homepage
"
)
)
{
return
;
}
browserDragAndDrop
.
dragOver
(
aEvent
)
;
aEvent
.
dropEffect
=
"
link
"
;
}
onDragExit
(
aEvent
)
{
}
}
function
openHomeDialog
(
aURL
)
{
var
promptTitle
=
gNavigatorBundle
.
getString
(
"
droponhometitle
"
)
;
var
promptMsg
;
if
(
aURL
.
includes
(
"
|
"
)
)
{
promptMsg
=
gNavigatorBundle
.
getString
(
"
droponhomemsgMultiple
"
)
;
}
else
{
promptMsg
=
gNavigatorBundle
.
getString
(
"
droponhomemsg
"
)
;
}
var
pressedVal
=
Services
.
prompt
.
confirmEx
(
window
promptTitle
promptMsg
Services
.
prompt
.
STD_YES_NO_BUTTONS
null
null
null
null
{
value
:
0
}
)
;
if
(
pressedVal
=
=
0
)
{
try
{
gPrefService
.
setStringPref
(
"
browser
.
startup
.
homepage
"
aURL
)
;
}
catch
(
ex
)
{
dump
(
"
Failed
to
set
the
home
page
.
\
n
"
+
ex
+
"
\
n
"
)
;
}
}
}
var
newTabButtonObserver
=
{
onDragOver
(
aEvent
)
{
browserDragAndDrop
.
dragOver
(
aEvent
)
;
}
onDragExit
(
aEvent
)
{
}
async
onDrop
(
aEvent
)
{
let
links
=
browserDragAndDrop
.
dropLinks
(
aEvent
)
;
for
(
let
link
of
links
)
{
if
(
link
.
url
)
{
let
data
=
await
getShortcutOrURIAndPostData
(
link
.
url
)
;
openNewTabWith
(
data
.
url
null
data
.
postData
aEvent
true
)
;
}
}
}
}
var
newWindowButtonObserver
=
{
onDragOver
(
aEvent
)
{
browserDragAndDrop
.
dragOver
(
aEvent
)
;
}
onDragExit
(
aEvent
)
{
}
async
onDrop
(
aEvent
)
{
let
links
=
browserDragAndDrop
.
dropLinks
(
aEvent
)
;
for
(
let
link
of
links
)
{
if
(
link
.
url
)
{
let
data
=
await
getShortcutOrURIAndPostData
(
link
.
url
)
;
openNewWindowWith
(
data
.
url
null
data
.
postData
true
)
;
}
}
}
}
const
DOMLinkHandler
=
{
init
(
)
{
let
mm
=
window
.
messageManager
;
mm
.
addMessageListener
(
"
Link
:
AddFeed
"
this
)
;
mm
.
addMessageListener
(
"
Link
:
SetIcon
"
this
)
;
mm
.
addMessageListener
(
"
Link
:
AddSearch
"
this
)
;
}
receiveMessage
(
aMsg
)
{
switch
(
aMsg
.
name
)
{
case
"
Link
:
AddFeed
"
:
let
link
=
{
type
:
aMsg
.
data
.
type
href
:
aMsg
.
data
.
href
title
:
aMsg
.
data
.
title
}
;
FeedHandler
.
addFeed
(
link
aMsg
.
target
)
;
break
;
case
"
Link
:
SetIcon
"
:
this
.
setIcon
(
aMsg
.
target
aMsg
.
data
.
url
aMsg
.
data
.
loadingPrincipal
)
;
break
;
case
"
Link
:
AddSearch
"
:
this
.
addSearch
(
aMsg
.
target
aMsg
.
data
.
engine
aMsg
.
data
.
url
)
;
break
;
}
}
setIcon
(
aBrowser
aURL
aLoadingPrincipal
)
{
if
(
gBrowser
.
isFailedIcon
(
aURL
)
)
return
false
;
let
tab
=
gBrowser
.
getTabForBrowser
(
aBrowser
)
;
if
(
!
tab
)
return
false
;
gBrowser
.
setIcon
(
tab
aURL
aLoadingPrincipal
)
;
return
true
;
}
addSearch
(
aBrowser
aEngine
aURL
)
{
let
tab
=
gBrowser
.
getTabForBrowser
(
aBrowser
)
;
if
(
!
tab
)
return
;
BrowserSearch
.
addEngine
(
aBrowser
aEngine
makeURI
(
aURL
)
)
;
}
}
const
BrowserSearch
=
{
addEngine
(
browser
engine
uri
)
{
if
(
browser
.
engines
)
{
if
(
browser
.
engines
.
some
(
e
=
>
e
.
title
=
=
engine
.
title
)
)
return
;
}
var
hidden
=
false
;
if
(
Services
.
search
.
getEngineByName
(
engine
.
title
)
)
hidden
=
true
;
var
engines
=
(
hidden
?
browser
.
hiddenEngines
:
browser
.
engines
)
|
|
[
]
;
engines
.
push
(
{
uri
:
engine
.
href
title
:
engine
.
title
get
icon
(
)
{
return
browser
.
mIconURL
;
}
}
)
;
if
(
hidden
)
browser
.
hiddenEngines
=
engines
;
else
{
browser
.
engines
=
engines
;
if
(
browser
=
=
gBrowser
.
selectedBrowser
)
this
.
updateOpenSearchBadge
(
)
;
}
}
updateOpenSearchBadge
(
)
{
var
searchBar
=
this
.
searchBar
;
if
(
!
searchBar
)
return
;
var
engines
=
gBrowser
.
selectedBrowser
.
engines
;
if
(
engines
&
&
engines
.
length
>
0
)
searchBar
.
setAttribute
(
"
addengines
"
"
true
"
)
;
else
searchBar
.
removeAttribute
(
"
addengines
"
)
;
}
webSearch
:
function
BrowserSearch_webSearch
(
)
{
if
(
window
.
location
.
href
!
=
getBrowserURL
(
)
)
{
var
win
=
getTopWin
(
)
;
if
(
win
)
{
win
.
focus
(
)
;
win
.
BrowserSearch
.
webSearch
(
)
;
}
else
{
var
observer
=
function
(
subject
topic
data
)
{
if
(
subject
=
=
win
)
{
BrowserSearch
.
webSearch
(
)
;
Services
.
obs
.
removeObserver
(
observer
"
browser
-
delayed
-
startup
-
finished
"
)
;
}
}
win
=
window
.
openDialog
(
getBrowserURL
(
)
"
_blank
"
"
chrome
all
dialog
=
no
"
"
about
:
blank
"
)
;
Services
.
obs
.
addObserver
(
observer
"
browser
-
delayed
-
startup
-
finished
"
)
;
}
return
;
}
let
focusUrlBarIfSearchFieldIsNotActive
=
function
(
aSearchBar
)
{
if
(
!
aSearchBar
|
|
document
.
activeElement
!
=
aSearchBar
.
textbox
.
inputField
)
{
focusAndSelectUrlBar
(
)
;
}
}
;
let
searchBar
=
this
.
searchBar
;
let
placement
=
CustomizableUI
.
getPlacementOfWidget
(
"
search
-
container
"
)
;
let
focusSearchBar
=
(
)
=
>
{
searchBar
=
this
.
searchBar
;
searchBar
.
select
(
)
;
focusUrlBarIfSearchFieldIsNotActive
(
searchBar
)
;
}
;
if
(
placement
&
&
placement
.
area
=
=
CustomizableUI
.
AREA_PANEL
)
{
PanelUI
.
show
(
)
.
then
(
focusSearchBar
)
;
return
;
}
if
(
placement
&
&
searchBar
&
&
(
(
searchBar
.
parentNode
.
getAttribute
(
"
overflowedItem
"
)
=
=
"
true
"
&
&
placement
.
area
=
=
CustomizableUI
.
AREA_NAVBAR
)
|
|
placement
.
area
=
=
CustomizableUI
.
AREA_FIXED_OVERFLOW_PANEL
)
)
{
let
navBar
=
document
.
getElementById
(
CustomizableUI
.
AREA_NAVBAR
)
;
navBar
.
overflowable
.
show
(
)
.
then
(
focusSearchBar
)
;
return
;
}
if
(
searchBar
)
{
if
(
window
.
fullScreen
)
FullScreen
.
showNavToolbox
(
)
;
searchBar
.
select
(
)
;
}
focusUrlBarIfSearchFieldIsNotActive
(
searchBar
)
;
}
_loadSearch
(
searchText
useNewTab
purpose
)
{
let
engine
;
if
(
isElementVisible
(
this
.
searchBar
)
)
engine
=
Services
.
search
.
currentEngine
;
else
engine
=
Services
.
search
.
defaultEngine
;
let
submission
=
engine
.
getSubmission
(
searchText
null
purpose
)
;
if
(
!
submission
)
{
return
null
;
}
let
inBackground
=
Services
.
prefs
.
getBoolPref
(
"
browser
.
search
.
context
.
loadInBackground
"
)
;
openLinkIn
(
submission
.
uri
.
spec
useNewTab
?
"
tab
"
:
"
current
"
{
postData
:
submission
.
postData
inBackground
relatedToCurrent
:
true
}
)
;
return
engine
;
}
loadSearch
:
function
BrowserSearch_search
(
searchText
useNewTab
purpose
)
{
let
engine
=
BrowserSearch
.
_loadSearch
(
searchText
useNewTab
purpose
)
;
if
(
!
engine
)
{
return
null
;
}
return
engine
.
name
;
}
loadSearchFromContext
(
terms
)
{
let
engine
=
BrowserSearch
.
_loadSearch
(
terms
true
"
contextmenu
"
)
;
if
(
engine
)
{
BrowserSearch
.
recordSearchInTelemetry
(
engine
"
contextmenu
"
)
;
}
}
pasteAndSearch
(
event
)
{
BrowserSearch
.
searchBar
.
select
(
)
;
goDoCommand
(
"
cmd_paste
"
)
;
BrowserSearch
.
searchBar
.
handleSearchCommand
(
event
)
;
}
get
searchBar
(
)
{
return
document
.
getElementById
(
"
searchbar
"
)
;
}
get
searchEnginesURL
(
)
{
return
formatURL
(
"
browser
.
search
.
searchEnginesURL
"
true
)
;
}
loadAddEngines
:
function
BrowserSearch_loadAddEngines
(
)
{
var
newWindowPref
=
gPrefService
.
getIntPref
(
"
browser
.
link
.
open_newwindow
"
)
;
var
where
=
newWindowPref
=
=
3
?
"
tab
"
:
"
window
"
;
openUILinkIn
(
this
.
searchEnginesURL
where
)
;
}
_getSearchEngineId
(
engine
)
{
if
(
engine
&
&
engine
.
identifier
)
{
return
engine
.
identifier
;
}
if
(
!
engine
|
|
(
engine
.
name
=
=
=
undefined
)
|
|
!
Services
.
prefs
.
getBoolPref
(
"
toolkit
.
telemetry
.
enabled
"
)
)
return
"
other
"
;
return
"
other
-
"
+
engine
.
name
;
}
recordSearchInTelemetry
(
engine
source
details
=
{
}
)
{
BrowserUITelemetry
.
countSearchEvent
(
source
null
details
.
selection
)
;
try
{
BrowserUsageTelemetry
.
recordSearch
(
engine
source
details
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
}
recordOneoffSearchInTelemetry
(
engine
source
type
where
)
{
let
id
=
this
.
_getSearchEngineId
(
engine
)
+
"
.
"
+
source
;
BrowserUITelemetry
.
countOneoffSearchEvent
(
id
type
where
)
;
try
{
const
details
=
{
type
isOneOff
:
true
}
;
BrowserUsageTelemetry
.
recordSearch
(
engine
source
details
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
}
}
;
XPCOMUtils
.
defineConstant
(
this
"
BrowserSearch
"
BrowserSearch
)
;
function
FillHistoryMenu
(
aParent
)
{
if
(
!
aParent
.
hasStatusListener
)
{
aParent
.
addEventListener
(
"
DOMMenuItemActive
"
function
(
aEvent
)
{
if
(
!
aEvent
.
target
.
hasAttribute
(
"
checked
"
)
)
XULBrowserWindow
.
setOverLink
(
aEvent
.
target
.
getAttribute
(
"
uri
"
)
)
;
}
)
;
aParent
.
addEventListener
(
"
DOMMenuItemInactive
"
function
(
)
{
XULBrowserWindow
.
setOverLink
(
"
"
)
;
}
)
;
aParent
.
hasStatusListener
=
true
;
}
let
children
=
aParent
.
childNodes
;
for
(
var
i
=
children
.
length
-
1
;
i
>
=
0
;
-
-
i
)
{
if
(
children
[
i
]
.
hasAttribute
(
"
index
"
)
)
aParent
.
removeChild
(
children
[
i
]
)
;
}
const
MAX_HISTORY_MENU_ITEMS
=
15
;
const
tooltipBack
=
gNavigatorBundle
.
getString
(
"
tabHistory
.
goBack
"
)
;
const
tooltipCurrent
=
gNavigatorBundle
.
getString
(
"
tabHistory
.
current
"
)
;
const
tooltipForward
=
gNavigatorBundle
.
getString
(
"
tabHistory
.
goForward
"
)
;
function
updateSessionHistory
(
sessionHistory
initial
)
{
let
count
=
sessionHistory
.
entries
.
length
;
if
(
!
initial
)
{
if
(
count
<
=
1
)
{
aParent
.
hidePopup
(
)
;
return
;
}
else
if
(
aParent
.
id
!
=
"
backForwardMenu
"
&
&
!
aParent
.
parentNode
.
open
)
{
aParent
.
parentNode
.
open
=
true
;
return
;
}
}
let
index
=
sessionHistory
.
index
;
let
half_length
=
Math
.
floor
(
MAX_HISTORY_MENU_ITEMS
/
2
)
;
let
start
=
Math
.
max
(
index
-
half_length
0
)
;
let
end
=
Math
.
min
(
start
=
=
0
?
MAX_HISTORY_MENU_ITEMS
:
index
+
half_length
+
1
count
)
;
if
(
end
=
=
count
)
{
start
=
Math
.
max
(
count
-
MAX_HISTORY_MENU_ITEMS
0
)
;
}
let
existingIndex
=
0
;
for
(
let
j
=
end
-
1
;
j
>
=
start
;
j
-
-
)
{
let
entry
=
sessionHistory
.
entries
[
j
]
;
let
uri
=
entry
.
url
;
let
item
=
existingIndex
<
children
.
length
?
children
[
existingIndex
]
:
document
.
createElement
(
"
menuitem
"
)
;
item
.
setAttribute
(
"
uri
"
uri
)
;
item
.
setAttribute
(
"
label
"
entry
.
title
|
|
uri
)
;
item
.
setAttribute
(
"
index
"
j
)
;
item
.
setAttribute
(
"
historyindex
"
j
-
index
)
;
if
(
j
!
=
index
)
{
item
.
style
.
listStyleImage
=
"
url
(
"
+
PlacesUtils
.
urlWithSizeRef
(
window
"
page
-
icon
:
"
+
uri
16
)
+
"
)
"
;
}
if
(
j
<
index
)
{
item
.
className
=
"
unified
-
nav
-
back
menuitem
-
iconic
menuitem
-
with
-
favicon
"
;
item
.
setAttribute
(
"
tooltiptext
"
tooltipBack
)
;
}
else
if
(
j
=
=
index
)
{
item
.
setAttribute
(
"
type
"
"
radio
"
)
;
item
.
setAttribute
(
"
checked
"
"
true
"
)
;
item
.
className
=
"
unified
-
nav
-
current
"
;
item
.
setAttribute
(
"
tooltiptext
"
tooltipCurrent
)
;
}
else
{
item
.
className
=
"
unified
-
nav
-
forward
menuitem
-
iconic
menuitem
-
with
-
favicon
"
;
item
.
setAttribute
(
"
tooltiptext
"
tooltipForward
)
;
}
if
(
!
item
.
parentNode
)
{
aParent
.
appendChild
(
item
)
;
}
existingIndex
+
+
;
}
if
(
!
initial
)
{
let
existingLength
=
children
.
length
;
while
(
existingIndex
<
existingLength
)
{
aParent
.
removeChild
(
aParent
.
lastChild
)
;
existingIndex
+
+
;
}
}
}
let
sessionHistory
=
SessionStore
.
getSessionHistory
(
gBrowser
.
selectedTab
updateSessionHistory
)
;
if
(
!
sessionHistory
)
return
false
;
if
(
sessionHistory
.
entries
.
length
<
=
1
)
return
false
;
updateSessionHistory
(
sessionHistory
true
)
;
return
true
;
}
function
addToUrlbarHistory
(
aUrlToAdd
)
{
if
(
!
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
&
&
aUrlToAdd
&
&
!
aUrlToAdd
.
includes
(
"
"
)
&
&
!
/
[
\
x00
-
\
x1F
]
/
.
test
(
aUrlToAdd
)
)
PlacesUIUtils
.
markPageAsTyped
(
aUrlToAdd
)
;
}
function
BrowserDownloadsUI
(
)
{
if
(
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
{
openUILinkIn
(
"
about
:
downloads
"
"
tab
"
)
;
}
else
{
PlacesCommandHook
.
showPlacesOrganizer
(
"
Downloads
"
)
;
}
}
function
toOpenWindowByType
(
inType
uri
features
)
{
var
topWindow
=
Services
.
wm
.
getMostRecentWindow
(
inType
)
;
if
(
topWindow
)
topWindow
.
focus
(
)
;
else
if
(
features
)
window
.
open
(
uri
"
_blank
"
features
)
;
else
window
.
open
(
uri
"
_blank
"
"
chrome
extrachrome
menubar
resizable
scrollbars
status
toolbar
"
)
;
}
function
OpenBrowserWindow
(
options
)
{
var
telemetryObj
=
{
}
;
TelemetryStopwatch
.
start
(
"
FX_NEW_WINDOW_MS
"
telemetryObj
)
;
function
newDocumentShown
(
doc
topic
data
)
{
if
(
topic
=
=
"
document
-
shown
"
&
&
doc
!
=
document
&
&
doc
.
defaultView
=
=
win
)
{
Services
.
obs
.
removeObserver
(
newDocumentShown
"
document
-
shown
"
)
;
Services
.
obs
.
removeObserver
(
windowClosed
"
domwindowclosed
"
)
;
TelemetryStopwatch
.
finish
(
"
FX_NEW_WINDOW_MS
"
telemetryObj
)
;
}
}
function
windowClosed
(
subject
)
{
if
(
subject
=
=
win
)
{
Services
.
obs
.
removeObserver
(
newDocumentShown
"
document
-
shown
"
)
;
Services
.
obs
.
removeObserver
(
windowClosed
"
domwindowclosed
"
)
;
}
}
Services
.
obs
.
addObserver
(
newDocumentShown
"
document
-
shown
"
)
;
Services
.
obs
.
addObserver
(
windowClosed
"
domwindowclosed
"
)
;
var
handler
=
Components
.
classes
[
"
mozilla
.
org
/
browser
/
clh
;
1
"
]
.
getService
(
Components
.
interfaces
.
nsIBrowserHandler
)
;
var
defaultArgs
=
handler
.
defaultArgs
;
var
wintype
=
document
.
documentElement
.
getAttribute
(
"
windowtype
"
)
;
var
extraFeatures
=
"
"
;
if
(
options
&
&
options
.
private
)
{
extraFeatures
=
"
private
"
;
if
(
!
PrivateBrowsingUtils
.
permanentPrivateBrowsing
)
{
defaultArgs
=
"
about
:
privatebrowsing
"
;
}
}
else
{
extraFeatures
=
"
non
-
private
"
;
}
if
(
options
&
&
options
.
remote
)
{
extraFeatures
+
=
"
remote
"
;
}
else
if
(
options
&
&
options
.
remote
=
=
=
false
)
{
extraFeatures
+
=
"
non
-
remote
"
;
}
if
(
window
.
windowState
=
=
window
.
STATE_MAXIMIZED
)
{
extraFeatures
+
=
"
suppressanimation
"
;
}
var
win
;
if
(
window
&
&
(
wintype
=
=
"
navigator
:
browser
"
)
&
&
window
.
content
&
&
window
.
content
.
document
)
{
var
DocCharset
=
window
.
content
.
document
.
characterSet
;
let
charsetArg
=
"
charset
=
"
+
DocCharset
;
win
=
window
.
openDialog
(
"
chrome
:
/
/
browser
/
content
/
"
"
_blank
"
"
chrome
all
dialog
=
no
"
+
extraFeatures
defaultArgs
charsetArg
)
;
}
else
{
win
=
window
.
openDialog
(
"
chrome
:
/
/
browser
/
content
/
"
"
_blank
"
"
chrome
all
dialog
=
no
"
+
extraFeatures
defaultArgs
)
;
}
return
win
;
}
function
updateEditUIVisibility
(
)
{
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
return
;
let
editMenuPopupState
=
document
.
getElementById
(
"
menu_EditPopup
"
)
.
state
;
let
contextMenuPopupState
=
document
.
getElementById
(
"
contentAreaContextMenu
"
)
.
state
;
let
placesContextMenuPopupState
=
document
.
getElementById
(
"
placesContext
"
)
.
state
;
let
oldVisible
=
gEditUIVisible
;
gEditUIVisible
=
editMenuPopupState
=
=
"
showing
"
|
|
editMenuPopupState
=
=
"
open
"
|
|
contextMenuPopupState
=
=
"
showing
"
|
|
contextMenuPopupState
=
=
"
open
"
|
|
placesContextMenuPopupState
=
=
"
showing
"
|
|
placesContextMenuPopupState
=
=
"
open
"
;
const
kOpenPopupStates
=
[
"
showing
"
"
open
"
]
;
if
(
!
gEditUIVisible
)
{
let
placement
=
CustomizableUI
.
getPlacementOfWidget
(
"
edit
-
controls
"
)
;
let
areaType
=
placement
?
CustomizableUI
.
getAreaType
(
placement
.
area
)
:
"
"
;
if
(
areaType
=
=
CustomizableUI
.
TYPE_MENU_PANEL
)
{
let
customizablePanel
=
PanelUI
.
overflowPanel
;
gEditUIVisible
=
kOpenPopupStates
.
includes
(
customizablePanel
.
state
)
;
}
else
if
(
areaType
=
=
CustomizableUI
.
TYPE_TOOLBAR
&
&
window
.
toolbar
.
visible
)
{
if
(
placement
.
area
=
=
"
nav
-
bar
"
)
{
let
editControls
=
document
.
getElementById
(
"
edit
-
controls
"
)
;
gEditUIVisible
=
!
editControls
.
hasAttribute
(
"
overflowedItem
"
)
|
|
kOpenPopupStates
.
includes
(
document
.
getElementById
(
"
widget
-
overflow
"
)
.
state
)
;
}
else
{
gEditUIVisible
=
true
;
}
}
}
if
(
!
gEditUIVisible
)
{
gEditUIVisible
=
kOpenPopupStates
.
includes
(
PanelUI
.
panel
.
state
)
;
}
if
(
gEditUIVisible
=
=
oldVisible
)
{
return
;
}
if
(
gEditUIVisible
)
{
goUpdateGlobalEditMenuItems
(
)
;
}
else
{
goSetCommandEnabled
(
"
cmd_undo
"
true
)
;
goSetCommandEnabled
(
"
cmd_redo
"
true
)
;
goSetCommandEnabled
(
"
cmd_cut
"
true
)
;
goSetCommandEnabled
(
"
cmd_copy
"
true
)
;
goSetCommandEnabled
(
"
cmd_paste
"
true
)
;
goSetCommandEnabled
(
"
cmd_selectAll
"
true
)
;
goSetCommandEnabled
(
"
cmd_delete
"
true
)
;
goSetCommandEnabled
(
"
cmd_switchTextDirection
"
true
)
;
}
}
function
openNewUserContextTab
(
event
)
{
openUILinkIn
(
BROWSER_NEW_TAB_URL
"
tab
"
{
userContextId
:
parseInt
(
event
.
target
.
getAttribute
(
"
data
-
usercontextid
"
)
)
}
)
;
}
function
updateUserContextUIVisibility
(
)
{
let
menu
=
document
.
getElementById
(
"
menu_newUserContext
"
)
;
menu
.
hidden
=
!
Services
.
prefs
.
getBoolPref
(
"
privacy
.
userContext
.
enabled
"
)
;
if
(
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
{
menu
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
}
function
updateUserContextUIIndicator
(
)
{
let
hbox
=
document
.
getElementById
(
"
userContext
-
icons
"
)
;
let
userContextId
=
gBrowser
.
selectedBrowser
.
getAttribute
(
"
usercontextid
"
)
;
if
(
!
userContextId
)
{
hbox
.
setAttribute
(
"
data
-
identity
-
color
"
"
"
)
;
hbox
.
hidden
=
true
;
return
;
}
let
identity
=
ContextualIdentityService
.
getPublicIdentityFromId
(
userContextId
)
;
if
(
!
identity
)
{
hbox
.
setAttribute
(
"
data
-
identity
-
color
"
"
"
)
;
hbox
.
hidden
=
true
;
return
;
}
hbox
.
setAttribute
(
"
data
-
identity
-
color
"
identity
.
color
)
;
let
label
=
document
.
getElementById
(
"
userContext
-
label
"
)
;
label
.
setAttribute
(
"
value
"
ContextualIdentityService
.
getUserContextLabel
(
userContextId
)
)
;
let
indicator
=
document
.
getElementById
(
"
userContext
-
indicator
"
)
;
indicator
.
setAttribute
(
"
data
-
identity
-
icon
"
identity
.
icon
)
;
hbox
.
hidden
=
false
;
}
function
updateCharacterEncodingMenuState
(
)
{
let
charsetMenu
=
document
.
getElementById
(
"
charsetMenu
"
)
;
if
(
gBrowser
&
&
gBrowser
.
selectedBrowser
.
mayEnableCharacterEncodingMenu
)
{
if
(
charsetMenu
)
{
charsetMenu
.
removeAttribute
(
"
disabled
"
)
;
}
}
else
if
(
charsetMenu
)
{
charsetMenu
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
}
var
XULBrowserWindow
=
{
status
:
"
"
defaultStatus
:
"
"
overLink
:
"
"
startTime
:
0
statusText
:
"
"
isBusy
:
false
inContentWhitelist
:
[
]
QueryInterface
(
aIID
)
{
if
(
aIID
.
equals
(
Ci
.
nsIWebProgressListener
)
|
|
aIID
.
equals
(
Ci
.
nsIWebProgressListener2
)
|
|
aIID
.
equals
(
Ci
.
nsISupportsWeakReference
)
|
|
aIID
.
equals
(
Ci
.
nsIXULBrowserWindow
)
|
|
aIID
.
equals
(
Ci
.
nsISupports
)
)
return
this
;
throw
Cr
.
NS_NOINTERFACE
;
}
get
stopCommand
(
)
{
delete
this
.
stopCommand
;
return
this
.
stopCommand
=
document
.
getElementById
(
"
Browser
:
Stop
"
)
;
}
get
reloadCommand
(
)
{
delete
this
.
reloadCommand
;
return
this
.
reloadCommand
=
document
.
getElementById
(
"
Browser
:
Reload
"
)
;
}
get
statusTextField
(
)
{
return
gBrowser
.
getStatusPanel
(
)
;
}
get
isImage
(
)
{
delete
this
.
isImage
;
return
this
.
isImage
=
document
.
getElementById
(
"
isImage
"
)
;
}
get
canViewSource
(
)
{
delete
this
.
canViewSource
;
return
this
.
canViewSource
=
document
.
getElementById
(
"
canViewSource
"
)
;
}
setJSStatus
(
)
{
}
forceInitialBrowserRemote
(
aRemoteType
)
{
let
initBrowser
=
document
.
getAnonymousElementByAttribute
(
gBrowser
"
anonid
"
"
initialBrowser
"
)
;
gBrowser
.
updateBrowserRemoteness
(
initBrowser
true
{
remoteType
:
aRemoteType
}
)
;
}
forceInitialBrowserNonRemote
(
aOpener
)
{
let
initBrowser
=
document
.
getAnonymousElementByAttribute
(
gBrowser
"
anonid
"
"
initialBrowser
"
)
;
gBrowser
.
updateBrowserRemoteness
(
initBrowser
false
{
opener
:
aOpener
}
)
;
}
setDefaultStatus
(
status
)
{
this
.
defaultStatus
=
status
;
this
.
updateStatusField
(
)
;
}
setOverLink
(
url
anchorElt
)
{
const
textToSubURI
=
Cc
[
"
mozilla
.
org
/
intl
/
texttosuburi
;
1
"
]
.
getService
(
Ci
.
nsITextToSubURI
)
;
url
=
textToSubURI
.
unEscapeURIForUI
(
"
UTF
-
8
"
url
)
;
url
=
url
.
replace
(
/
[
\
u200e
\
u200f
\
u202a
\
u202b
\
u202c
\
u202d
\
u202e
]
/
g
encodeURIComponent
)
;
if
(
gURLBar
&
&
gURLBar
.
_mayTrimURLs
)
url
=
trimURL
(
url
)
;
this
.
overLink
=
url
;
LinkTargetDisplay
.
update
(
)
;
}
showTooltip
(
x
y
tooltip
direction
browser
)
{
if
(
Cc
[
"
mozilla
.
org
/
widget
/
dragservice
;
1
"
]
.
getService
(
Ci
.
nsIDragService
)
.
getCurrentSession
(
)
)
{
return
;
}
let
elt
=
document
.
getElementById
(
"
remoteBrowserTooltip
"
)
;
elt
.
label
=
tooltip
;
elt
.
style
.
direction
=
direction
;
elt
.
openPopupAtScreen
(
browser
.
boxObject
.
screenX
+
x
browser
.
boxObject
.
screenY
+
y
false
null
)
;
}
hideTooltip
(
)
{
let
elt
=
document
.
getElementById
(
"
remoteBrowserTooltip
"
)
;
elt
.
hidePopup
(
)
;
}
getTabCount
(
)
{
return
gBrowser
.
tabs
.
length
;
}
updateStatusField
(
)
{
var
text
type
types
=
[
"
overLink
"
]
;
if
(
this
.
_busyUI
)
types
.
push
(
"
status
"
)
;
types
.
push
(
"
defaultStatus
"
)
;
for
(
type
of
types
)
{
text
=
this
[
type
]
;
if
(
text
)
break
;
}
if
(
this
.
statusText
!
=
text
)
{
let
field
=
this
.
statusTextField
;
field
.
setAttribute
(
"
previoustype
"
field
.
getAttribute
(
"
type
"
)
)
;
field
.
setAttribute
(
"
type
"
type
)
;
field
.
label
=
text
;
field
.
setAttribute
(
"
crop
"
type
=
=
"
overLink
"
?
"
center
"
:
"
end
"
)
;
this
.
statusText
=
text
;
}
}
onBeforeLinkTraversal
(
originalTarget
linkURI
linkNode
isAppTab
)
{
let
target
=
BrowserUtils
.
onBeforeLinkTraversal
(
originalTarget
linkURI
linkNode
isAppTab
)
;
SocialUI
.
closeSocialPanelForLinkTraversal
(
target
linkNode
)
;
return
target
;
}
shouldLoadURI
(
aDocShell
aURI
aReferrer
aHasPostData
aTriggeringPrincipal
)
{
if
(
!
gMultiProcessBrowser
)
return
true
;
let
browser
=
aDocShell
.
QueryInterface
(
Ci
.
nsIDocShellTreeItem
)
.
sameTypeRootTreeItem
.
QueryInterface
(
Ci
.
nsIDocShell
)
.
chromeEventHandler
;
if
(
browser
.
localName
!
=
"
browser
"
|
|
!
browser
.
getTabBrowser
|
|
browser
.
getTabBrowser
(
)
!
=
gBrowser
)
return
true
;
if
(
!
E10SUtils
.
shouldLoadURI
(
aDocShell
aURI
aReferrer
aHasPostData
)
)
{
E10SUtils
.
redirectLoad
(
aDocShell
aURI
aReferrer
aTriggeringPrincipal
false
)
;
return
false
;
}
return
true
;
}
onProgressChange
(
aWebProgress
aRequest
aCurSelfProgress
aMaxSelfProgress
aCurTotalProgress
aMaxTotalProgress
)
{
}
onProgressChange64
(
aWebProgress
aRequest
aCurSelfProgress
aMaxSelfProgress
aCurTotalProgress
aMaxTotalProgress
)
{
return
this
.
onProgressChange
(
aWebProgress
aRequest
aCurSelfProgress
aMaxSelfProgress
aCurTotalProgress
aMaxTotalProgress
)
;
}
onStateChange
(
aWebProgress
aRequest
aStateFlags
aStatus
)
{
const
nsIWebProgressListener
=
Ci
.
nsIWebProgressListener
;
const
nsIChannel
=
Ci
.
nsIChannel
;
let
browser
=
gBrowser
.
selectedBrowser
;
if
(
aStateFlags
&
nsIWebProgressListener
.
STATE_START
&
&
aStateFlags
&
nsIWebProgressListener
.
STATE_IS_NETWORK
)
{
if
(
aRequest
&
&
aWebProgress
.
isTopLevel
)
{
browser
.
feeds
=
null
;
browser
.
engines
=
null
;
}
this
.
isBusy
=
true
;
if
(
!
(
aStateFlags
&
nsIWebProgressListener
.
STATE_RESTORING
)
)
{
this
.
_busyUI
=
true
;
this
.
stopCommand
.
removeAttribute
(
"
disabled
"
)
;
CombinedStopReload
.
switchToStop
(
aRequest
aWebProgress
)
;
}
}
else
if
(
aStateFlags
&
nsIWebProgressListener
.
STATE_STOP
)
{
if
(
aRequest
)
{
let
msg
=
"
"
;
let
location
;
let
canViewSource
=
true
;
if
(
aRequest
instanceof
nsIChannel
|
|
"
URI
"
in
aRequest
)
{
location
=
aRequest
.
URI
;
if
(
location
.
scheme
=
=
"
keyword
"
&
&
aWebProgress
.
isTopLevel
)
gBrowser
.
userTypedValue
=
null
;
canViewSource
=
!
Services
.
prefs
.
getBoolPref
(
"
view_source
.
tab
"
)
|
|
location
.
scheme
!
=
"
view
-
source
"
;
if
(
location
.
spec
!
=
"
about
:
blank
"
)
{
switch
(
aStatus
)
{
case
Components
.
results
.
NS_ERROR_NET_TIMEOUT
:
msg
=
gNavigatorBundle
.
getString
(
"
nv_timeout
"
)
;
break
;
}
}
}
this
.
status
=
"
"
;
this
.
setDefaultStatus
(
msg
)
;
if
(
browser
.
documentContentType
&
&
BrowserUtils
.
mimeTypeIsTextBased
(
browser
.
documentContentType
)
)
{
this
.
isImage
.
removeAttribute
(
"
disabled
"
)
;
}
else
{
canViewSource
=
false
;
this
.
isImage
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
if
(
canViewSource
)
{
this
.
canViewSource
.
removeAttribute
(
"
disabled
"
)
;
}
else
{
this
.
canViewSource
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
}
this
.
isBusy
=
false
;
if
(
this
.
_busyUI
)
{
this
.
_busyUI
=
false
;
this
.
stopCommand
.
setAttribute
(
"
disabled
"
"
true
"
)
;
CombinedStopReload
.
switchToReload
(
aRequest
aWebProgress
)
;
}
}
}
onLocationChange
(
aWebProgress
aRequest
aLocationURI
aFlags
)
{
var
location
=
aLocationURI
?
aLocationURI
.
spec
:
"
"
;
FormValidationHandler
.
hidePopup
(
)
;
let
pageTooltip
=
document
.
getElementById
(
"
aHTMLTooltip
"
)
;
let
tooltipNode
=
pageTooltip
.
triggerNode
;
if
(
tooltipNode
)
{
if
(
aWebProgress
.
isTopLevel
)
{
pageTooltip
.
hidePopup
(
)
;
}
else
{
for
(
let
tooltipWindow
=
tooltipNode
.
ownerGlobal
;
tooltipWindow
!
=
tooltipWindow
.
parent
;
tooltipWindow
=
tooltipWindow
.
parent
)
{
if
(
tooltipWindow
=
=
aWebProgress
.
DOMWindow
)
{
pageTooltip
.
hidePopup
(
)
;
break
;
}
}
}
}
let
browser
=
gBrowser
.
selectedBrowser
;
if
(
browser
.
documentContentType
&
&
BrowserUtils
.
mimeTypeIsTextBased
(
browser
.
documentContentType
)
)
this
.
isImage
.
removeAttribute
(
"
disabled
"
)
;
else
this
.
isImage
.
setAttribute
(
"
disabled
"
"
true
"
)
;
this
.
hideOverLinkImmediately
=
true
;
this
.
setOverLink
(
"
"
null
)
;
this
.
hideOverLinkImmediately
=
false
;
if
(
aWebProgress
.
isTopLevel
)
{
if
(
(
location
=
=
"
about
:
blank
"
&
&
checkEmptyPageOrigin
(
)
)
|
|
location
=
=
"
"
)
{
this
.
reloadCommand
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
else
{
this
.
reloadCommand
.
removeAttribute
(
"
disabled
"
)
;
}
URLBarSetURI
(
aLocationURI
)
;
BookmarkingUI
.
onLocationChange
(
)
;
gIdentityHandler
.
onLocationChange
(
)
;
SocialUI
.
updateState
(
)
;
gTabletModePageCounter
.
inc
(
)
;
var
shouldDisableFind
=
function
(
aDocument
)
{
let
docElt
=
aDocument
.
documentElement
;
return
docElt
&
&
docElt
.
getAttribute
(
"
disablefastfind
"
)
=
=
"
true
"
;
}
var
disableFindCommands
=
function
(
aDisable
)
{
let
findCommands
=
[
document
.
getElementById
(
"
cmd_find
"
)
document
.
getElementById
(
"
cmd_findAgain
"
)
document
.
getElementById
(
"
cmd_findPrevious
"
)
]
;
for
(
let
elt
of
findCommands
)
{
if
(
aDisable
)
elt
.
setAttribute
(
"
disabled
"
"
true
"
)
;
else
elt
.
removeAttribute
(
"
disabled
"
)
;
}
}
var
onContentRSChange
=
function
(
e
)
{
if
(
e
.
target
.
readyState
!
=
"
interactive
"
&
&
e
.
target
.
readyState
!
=
"
complete
"
)
return
;
e
.
target
.
removeEventListener
(
"
readystatechange
"
onContentRSChange
)
;
disableFindCommands
(
shouldDisableFind
(
e
.
target
)
)
;
}
if
(
!
gMultiProcessBrowser
&
&
aLocationURI
&
&
(
aLocationURI
.
schemeIs
(
"
about
"
)
|
|
aLocationURI
.
schemeIs
(
"
chrome
"
)
)
)
{
if
(
!
(
aFlags
&
Ci
.
nsIWebProgressListener
.
LOCATION_CHANGE_SAME_DOCUMENT
)
)
{
if
(
window
.
content
.
document
.
readyState
=
=
"
interactive
"
|
|
window
.
content
.
document
.
readyState
=
=
"
complete
"
)
disableFindCommands
(
shouldDisableFind
(
window
.
content
.
document
)
)
;
else
{
window
.
content
.
document
.
addEventListener
(
"
readystatechange
"
onContentRSChange
)
;
}
}
}
else
disableFindCommands
(
false
)
;
if
(
location
=
=
"
about
:
blank
"
&
&
gBrowser
.
selectedTab
.
hasAttribute
(
"
customizemode
"
)
)
{
gCustomizeMode
.
enter
(
)
;
}
else
if
(
CustomizationHandler
.
isEnteringCustomizeMode
|
|
CustomizationHandler
.
isCustomizing
(
)
)
{
gCustomizeMode
.
exit
(
)
;
}
}
UpdateBackForwardCommands
(
gBrowser
.
webNavigation
)
;
ReaderParent
.
updateReaderButton
(
gBrowser
.
selectedBrowser
)
;
if
(
!
gMultiProcessBrowser
)
gGestureSupport
.
restoreRotationState
(
)
;
if
(
aRequest
)
setTimeout
(
function
(
)
{
XULBrowserWindow
.
asyncUpdateUI
(
)
;
}
0
)
;
else
this
.
asyncUpdateUI
(
)
;
if
(
AppConstants
.
MOZ_CRASHREPORTER
&
&
aLocationURI
)
{
let
uri
=
aLocationURI
.
clone
(
)
;
try
{
uri
.
userPass
=
"
"
;
}
catch
(
ex
)
{
}
try
{
gCrashReporter
.
annotateCrashReport
(
"
URL
"
uri
.
spec
)
;
}
catch
(
ex
)
{
if
(
ex
.
result
!
=
Components
.
results
.
NS_ERROR_NOT_INITIALIZED
)
{
throw
ex
;
}
}
}
}
asyncUpdateUI
(
)
{
FeedHandler
.
updateFeeds
(
)
;
BrowserSearch
.
updateOpenSearchBadge
(
)
;
}
hideChromeForLocation
(
)
{
}
onStatusChange
(
aWebProgress
aRequest
aStatus
aMessage
)
{
this
.
status
=
aMessage
;
this
.
updateStatusField
(
)
;
}
_state
:
null
_lastLocation
:
null
onSecurityChange
(
aWebProgress
aRequest
aState
aIsSimulated
)
{
let
uri
=
gBrowser
.
currentURI
;
let
spec
=
uri
.
spec
;
if
(
this
.
_state
=
=
aState
&
&
this
.
_lastLocation
=
=
spec
)
{
gIdentityHandler
.
refreshIdentityBlock
(
)
;
return
;
}
this
.
_state
=
aState
;
this
.
_lastLocation
=
spec
;
if
(
typeof
(
aIsSimulated
)
!
=
"
boolean
"
&
&
typeof
(
aIsSimulated
)
!
=
"
undefined
"
)
{
throw
"
onSecurityChange
:
aIsSimulated
receieved
an
unexpected
type
"
;
}
gURLBar
.
formatValue
(
)
;
try
{
uri
=
Services
.
uriFixup
.
createExposableURI
(
uri
)
;
}
catch
(
e
)
{
}
gIdentityHandler
.
updateIdentity
(
this
.
_state
uri
)
;
TrackingProtection
.
onSecurityChange
(
this
.
_state
aIsSimulated
)
;
}
onUpdateCurrentBrowser
:
function
XWB_onUpdateCurrentBrowser
(
aStateFlags
aStatus
aMessage
aTotalProgress
)
{
if
(
FullZoom
.
updateBackgroundTabs
)
FullZoom
.
onLocationChange
(
gBrowser
.
currentURI
true
)
;
CombinedStopReload
.
onTabSwitch
(
)
;
var
nsIWebProgressListener
=
Components
.
interfaces
.
nsIWebProgressListener
;
var
loadingDone
=
aStateFlags
&
nsIWebProgressListener
.
STATE_STOP
;
this
.
onStateChange
(
gBrowser
.
webProgress
{
URI
:
gBrowser
.
currentURI
}
loadingDone
?
nsIWebProgressListener
.
STATE_STOP
:
nsIWebProgressListener
.
STATE_START
aStatus
)
;
if
(
loadingDone
)
return
;
this
.
onStatusChange
(
gBrowser
.
webProgress
null
0
aMessage
)
;
}
navigateAndRestoreByIndex
:
function
XWB_navigateAndRestoreByIndex
(
aBrowser
aIndex
)
{
let
tab
=
gBrowser
.
getTabForBrowser
(
aBrowser
)
;
if
(
tab
)
{
SessionStore
.
navigateAndRestore
(
tab
{
}
aIndex
)
;
return
;
}
throw
new
Error
(
"
Trying
to
navigateAndRestore
a
browser
which
was
"
+
"
not
attached
to
this
tabbrowser
is
unsupported
"
)
;
}
}
;
var
LinkTargetDisplay
=
{
get
DELAY_SHOW
(
)
{
delete
this
.
DELAY_SHOW
;
return
this
.
DELAY_SHOW
=
Services
.
prefs
.
getIntPref
(
"
browser
.
overlink
-
delay
"
)
;
}
DELAY_HIDE
:
250
_timer
:
0
get
_isVisible
(
)
{
return
XULBrowserWindow
.
statusTextField
.
label
!
=
"
"
;
}
update
(
)
{
clearTimeout
(
this
.
_timer
)
;
window
.
removeEventListener
(
"
mousemove
"
this
true
)
;
if
(
!
XULBrowserWindow
.
overLink
)
{
if
(
XULBrowserWindow
.
hideOverLinkImmediately
)
this
.
_hide
(
)
;
else
this
.
_timer
=
setTimeout
(
this
.
_hide
.
bind
(
this
)
this
.
DELAY_HIDE
)
;
return
;
}
if
(
this
.
_isVisible
)
{
XULBrowserWindow
.
updateStatusField
(
)
;
}
else
{
this
.
_showDelayed
(
)
;
window
.
addEventListener
(
"
mousemove
"
this
true
)
;
}
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
mousemove
"
:
clearTimeout
(
this
.
_timer
)
;
this
.
_showDelayed
(
)
;
break
;
}
}
_showDelayed
(
)
{
this
.
_timer
=
setTimeout
(
function
(
self
)
{
XULBrowserWindow
.
updateStatusField
(
)
;
window
.
removeEventListener
(
"
mousemove
"
self
true
)
;
}
this
.
DELAY_SHOW
this
)
;
}
_hide
(
)
{
clearTimeout
(
this
.
_timer
)
;
XULBrowserWindow
.
updateStatusField
(
)
;
}
}
;
var
CombinedStopReload
=
{
init
(
)
{
if
(
this
.
_initialized
)
return
;
let
reload
=
document
.
getElementById
(
"
reload
-
button
"
)
;
let
stop
=
document
.
getElementById
(
"
stop
-
button
"
)
;
if
(
!
stop
|
|
!
reload
|
|
reload
.
nextSibling
!
=
stop
)
return
;
this
.
_initialized
=
true
;
if
(
XULBrowserWindow
.
stopCommand
.
getAttribute
(
"
disabled
"
)
!
=
"
true
"
)
reload
.
setAttribute
(
"
displaystop
"
"
true
"
)
;
stop
.
addEventListener
(
"
click
"
this
)
;
this
.
reload
=
reload
;
this
.
stop
=
stop
;
this
.
stopReloadContainer
=
this
.
reload
.
parentNode
;
this
.
timeWhenSwitchedToStop
=
0
;
}
uninit
(
)
{
if
(
!
this
.
_initialized
)
return
;
Services
.
prefs
.
removeObserver
(
"
toolkit
.
cosmeticAnimations
.
enabled
"
this
)
;
this
.
_cancelTransition
(
)
;
this
.
_initialized
=
false
;
this
.
stop
.
removeEventListener
(
"
click
"
this
)
;
this
.
stopReloadContainer
.
removeEventListener
(
"
animationend
"
this
)
;
this
.
stopReloadContainer
=
null
;
this
.
reload
=
null
;
this
.
stop
=
null
;
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
click
"
:
if
(
event
.
button
=
=
0
&
&
!
this
.
stop
.
disabled
)
{
this
.
_stopClicked
=
true
;
}
case
"
animationend
"
:
{
if
(
event
.
target
.
classList
.
contains
(
"
toolbarbutton
-
animatable
-
image
"
)
&
&
(
event
.
animationName
=
=
"
reload
-
to
-
stop
"
|
|
event
.
animationName
=
=
"
stop
-
to
-
reload
"
|
|
event
.
animationName
=
=
"
reload
-
to
-
stop
-
rtl
"
|
|
event
.
animationName
=
=
"
stop
-
to
-
reload
-
rtl
"
)
)
{
this
.
stopReloadContainer
.
removeAttribute
(
"
animate
"
)
;
}
}
}
}
observe
(
subject
topic
data
)
{
if
(
topic
=
=
"
nsPref
:
changed
"
)
{
this
.
animate
=
Services
.
prefs
.
getBoolPref
(
"
toolkit
.
cosmeticAnimations
.
enabled
"
)
;
}
}
startAnimationPrefMonitoring
(
)
{
if
(
!
this
.
_initialized
)
return
;
this
.
animate
=
Services
.
prefs
.
getBoolPref
(
"
toolkit
.
cosmeticAnimations
.
enabled
"
)
&
&
Services
.
prefs
.
getBoolPref
(
"
browser
.
stopReloadAnimation
.
enabled
"
)
;
Services
.
prefs
.
addObserver
(
"
toolkit
.
cosmeticAnimations
.
enabled
"
this
)
;
this
.
stopReloadContainer
.
addEventListener
(
"
animationend
"
this
)
;
}
onTabSwitch
(
)
{
this
.
timeWhenSwitchedToStop
=
0
;
}
switchToStop
(
aRequest
aWebProgress
)
{
if
(
!
this
.
_initialized
|
|
!
this
.
_shouldSwitch
(
aRequest
aWebProgress
)
)
{
return
;
}
if
(
aRequest
)
{
this
.
timeWhenSwitchedToStop
=
window
.
performance
.
now
(
)
;
}
let
shouldAnimate
=
aRequest
&
&
aWebProgress
.
isTopLevel
&
&
aWebProgress
.
isLoadingDocument
&
&
!
gBrowser
.
tabAnimationsInProgress
&
&
this
.
stopReloadContainer
.
closest
(
"
#
nav
-
bar
-
customization
-
target
"
)
&
&
this
.
animate
;
this
.
_cancelTransition
(
)
;
if
(
shouldAnimate
)
{
BrowserUtils
.
setToolbarButtonHeightProperty
(
this
.
stopReloadContainer
)
;
this
.
stopReloadContainer
.
setAttribute
(
"
animate
"
"
true
"
)
;
}
else
{
this
.
stopReloadContainer
.
removeAttribute
(
"
animate
"
)
;
}
this
.
reload
.
setAttribute
(
"
displaystop
"
"
true
"
)
;
}
switchToReload
(
aRequest
aWebProgress
)
{
if
(
!
this
.
_initialized
|
|
!
this
.
_shouldSwitch
(
aRequest
aWebProgress
)
|
|
!
this
.
reload
.
hasAttribute
(
"
displaystop
"
)
)
{
return
;
}
let
shouldAnimate
=
aRequest
&
&
aWebProgress
.
isTopLevel
&
&
!
aWebProgress
.
isLoadingDocument
&
&
!
gBrowser
.
tabAnimationsInProgress
&
&
this
.
_loadTimeExceedsMinimumForAnimation
(
)
&
&
this
.
stopReloadContainer
.
closest
(
"
#
nav
-
bar
-
customization
-
target
"
)
&
&
this
.
animate
;
if
(
shouldAnimate
)
{
BrowserUtils
.
setToolbarButtonHeightProperty
(
this
.
stopReloadContainer
)
;
this
.
stopReloadContainer
.
setAttribute
(
"
animate
"
"
true
"
)
;
}
else
{
this
.
stopReloadContainer
.
removeAttribute
(
"
animate
"
)
;
}
this
.
reload
.
removeAttribute
(
"
displaystop
"
)
;
if
(
!
shouldAnimate
|
|
this
.
_stopClicked
)
{
this
.
_stopClicked
=
false
;
this
.
_cancelTransition
(
)
;
this
.
reload
.
disabled
=
XULBrowserWindow
.
reloadCommand
.
getAttribute
(
"
disabled
"
)
=
=
"
true
"
;
return
;
}
if
(
this
.
_timer
)
return
;
this
.
reload
.
disabled
=
true
;
this
.
_timer
=
setTimeout
(
function
(
self
)
{
self
.
_timer
=
0
;
self
.
reload
.
disabled
=
XULBrowserWindow
.
reloadCommand
.
getAttribute
(
"
disabled
"
)
=
=
"
true
"
;
}
650
this
)
;
}
_loadTimeExceedsMinimumForAnimation
(
)
{
return
!
this
.
timeWhenSwitchedToStop
|
|
window
.
performance
.
now
(
)
-
this
.
timeWhenSwitchedToStop
>
150
;
}
_shouldSwitch
(
aRequest
aWebProgress
)
{
if
(
aRequest
&
&
aRequest
.
originalURI
&
&
(
aRequest
.
originalURI
.
schemeIs
(
"
chrome
"
)
|
|
(
aRequest
.
originalURI
.
schemeIs
(
"
about
"
)
&
&
aWebProgress
.
isTopLevel
&
&
!
aRequest
.
originalURI
.
spec
.
startsWith
(
"
about
:
reader
"
)
)
)
)
{
return
false
;
}
return
true
;
}
_cancelTransition
(
)
{
if
(
this
.
_timer
)
{
clearTimeout
(
this
.
_timer
)
;
this
.
_timer
=
0
;
}
}
}
;
var
TabsProgressListener
=
{
onStateChange
(
aBrowser
aWebProgress
aRequest
aStateFlags
aStatus
)
{
if
(
aWebProgress
.
isTopLevel
&
&
(
!
aRequest
.
originalURI
|
|
aRequest
.
originalURI
.
spec
.
scheme
!
=
"
about
"
)
)
{
let
stopwatchRunning
=
TelemetryStopwatch
.
running
(
"
FX_PAGE_LOAD_MS
"
aBrowser
)
;
if
(
aStateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_IS_WINDOW
)
{
if
(
aStateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_START
)
{
if
(
stopwatchRunning
)
{
TelemetryStopwatch
.
cancel
(
"
FX_PAGE_LOAD_MS
"
aBrowser
)
;
}
TelemetryStopwatch
.
start
(
"
FX_PAGE_LOAD_MS
"
aBrowser
)
;
Services
.
telemetry
.
getHistogramById
(
"
FX_TOTAL_TOP_VISITS
"
)
.
add
(
true
)
;
}
else
if
(
aStateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_STOP
&
&
stopwatchRunning
)
{
TelemetryStopwatch
.
finish
(
"
FX_PAGE_LOAD_MS
"
aBrowser
)
;
}
}
else
if
(
aStateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_STOP
&
&
aStatus
=
=
Cr
.
NS_BINDING_ABORTED
&
&
stopwatchRunning
)
{
TelemetryStopwatch
.
cancel
(
"
FX_PAGE_LOAD_MS
"
aBrowser
)
;
}
}
let
isRemoteBrowser
=
aBrowser
.
isRemoteBrowser
;
let
doc
=
isRemoteBrowser
?
null
:
aWebProgress
.
DOMWindow
.
document
;
if
(
!
isRemoteBrowser
&
&
aStateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_STOP
&
&
Components
.
isSuccessCode
(
aStatus
)
&
&
doc
.
documentURI
.
startsWith
(
"
about
:
"
)
&
&
!
doc
.
documentURI
.
toLowerCase
(
)
.
startsWith
(
"
about
:
blank
"
)
&
&
!
doc
.
documentURI
.
toLowerCase
(
)
.
startsWith
(
"
about
:
home
"
)
&
&
!
doc
.
documentElement
.
hasAttribute
(
"
hasBrowserHandlers
"
)
)
{
doc
.
documentElement
.
setAttribute
(
"
hasBrowserHandlers
"
"
true
"
)
;
aBrowser
.
addEventListener
(
"
pagehide
"
function
onPageHide
(
event
)
{
if
(
event
.
target
.
defaultView
.
frameElement
)
return
;
aBrowser
.
removeEventListener
(
"
pagehide
"
onPageHide
true
)
;
if
(
event
.
target
.
documentElement
)
event
.
target
.
documentElement
.
removeAttribute
(
"
hasBrowserHandlers
"
)
;
}
true
)
;
}
}
onLocationChange
(
aBrowser
aWebProgress
aRequest
aLocationURI
aFlags
)
{
if
(
aFlags
&
Ci
.
nsIWebProgressListener
.
LOCATION_CHANGE_SAME_DOCUMENT
)
{
let
mm
=
gBrowser
.
selectedBrowser
.
messageManager
;
mm
.
sendAsyncMessage
(
"
Reader
:
PushState
"
{
isArticle
:
gBrowser
.
selectedBrowser
.
isArticle
}
)
;
return
;
}
if
(
!
aWebProgress
.
isTopLevel
)
return
;
if
(
!
Object
.
getOwnPropertyDescriptor
(
window
"
PopupNotifications
"
)
.
get
)
PopupNotifications
.
locationChange
(
aBrowser
)
;
let
tab
=
gBrowser
.
getTabForBrowser
(
aBrowser
)
;
if
(
tab
&
&
tab
.
_sharingState
)
{
gBrowser
.
setBrowserSharing
(
aBrowser
{
}
)
;
}
webrtcUI
.
forgetStreamsFromBrowser
(
aBrowser
)
;
gBrowser
.
getNotificationBox
(
aBrowser
)
.
removeTransientNotifications
(
)
;
FullZoom
.
onLocationChange
(
aLocationURI
false
aBrowser
)
;
}
}
function
nsBrowserAccess
(
)
{
}
nsBrowserAccess
.
prototype
=
{
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIBrowserDOMWindow
Ci
.
nsISupports
]
)
_openURIInNewTab
(
aURI
aReferrer
aReferrerPolicy
aIsPrivate
aIsExternal
aForceNotRemote
=
false
aUserContextId
=
Ci
.
nsIScriptSecurityManager
.
DEFAULT_USER_CONTEXT_ID
aOpener
=
null
aTriggeringPrincipal
=
null
aNextTabParentId
=
0
aName
=
"
"
)
{
let
win
needToFocusWin
;
if
(
window
.
toolbar
.
visible
)
win
=
window
;
else
{
win
=
RecentWindow
.
getMostRecentBrowserWindow
(
{
private
:
aIsPrivate
}
)
;
needToFocusWin
=
true
;
}
if
(
!
win
)
{
return
null
;
}
if
(
aIsExternal
&
&
(
!
aURI
|
|
aURI
.
spec
=
=
"
about
:
blank
"
)
)
{
win
.
BrowserOpenTab
(
)
;
win
.
focus
(
)
;
return
win
.
gBrowser
.
selectedBrowser
;
}
let
loadInBackground
=
gPrefService
.
getBoolPref
(
"
browser
.
tabs
.
loadDivertedInBackground
"
)
;
let
tab
=
win
.
gBrowser
.
loadOneTab
(
aURI
?
aURI
.
spec
:
"
about
:
blank
"
{
triggeringPrincipal
:
aTriggeringPrincipal
referrerURI
:
aReferrer
referrerPolicy
:
aReferrerPolicy
userContextId
:
aUserContextId
fromExternal
:
aIsExternal
inBackground
:
loadInBackground
forceNotRemote
:
aForceNotRemote
opener
:
aOpener
nextTabParentId
:
aNextTabParentId
name
:
aName
}
)
;
let
browser
=
win
.
gBrowser
.
getBrowserForTab
(
tab
)
;
if
(
needToFocusWin
|
|
(
!
loadInBackground
&
&
aIsExternal
)
)
win
.
focus
(
)
;
return
browser
;
}
createContentWindow
(
aURI
aOpener
aWhere
aFlags
aTriggeringPrincipal
)
{
return
this
.
getContentWindowOrOpenURI
(
null
aOpener
aWhere
aFlags
aTriggeringPrincipal
)
;
}
openURI
(
aURI
aOpener
aWhere
aFlags
aTriggeringPrincipal
)
{
if
(
!
aURI
)
{
Cu
.
reportError
(
"
openURI
should
only
be
called
with
a
valid
URI
"
)
;
throw
Cr
.
NS_ERROR_FAILURE
;
}
return
this
.
getContentWindowOrOpenURI
(
aURI
aOpener
aWhere
aFlags
aTriggeringPrincipal
)
;
}
getContentWindowOrOpenURI
(
aURI
aOpener
aWhere
aFlags
aTriggeringPrincipal
)
{
if
(
aOpener
&
&
Cu
.
isCrossProcessWrapper
(
aOpener
)
)
{
Cu
.
reportError
(
"
nsBrowserAccess
.
openURI
was
passed
a
CPOW
for
aOpener
.
"
+
"
openURI
should
only
ever
be
called
from
non
-
remote
browsers
.
"
)
;
throw
Cr
.
NS_ERROR_FAILURE
;
}
var
newWindow
=
null
;
var
isExternal
=
!
!
(
aFlags
&
Ci
.
nsIBrowserDOMWindow
.
OPEN_EXTERNAL
)
;
if
(
aOpener
&
&
isExternal
)
{
Cu
.
reportError
(
"
nsBrowserAccess
.
openURI
did
not
expect
an
opener
to
be
"
+
"
passed
if
the
context
is
OPEN_EXTERNAL
.
"
)
;
throw
Cr
.
NS_ERROR_FAILURE
;
}
if
(
isExternal
&
&
aURI
&
&
aURI
.
schemeIs
(
"
chrome
"
)
)
{
dump
(
"
use
-
-
chrome
command
-
line
option
to
load
external
chrome
urls
\
n
"
)
;
return
null
;
}
if
(
aWhere
=
=
Ci
.
nsIBrowserDOMWindow
.
OPEN_DEFAULTWINDOW
)
{
if
(
isExternal
&
&
gPrefService
.
prefHasUserValue
(
"
browser
.
link
.
open_newwindow
.
override
.
external
"
)
)
aWhere
=
gPrefService
.
getIntPref
(
"
browser
.
link
.
open_newwindow
.
override
.
external
"
)
;
else
aWhere
=
gPrefService
.
getIntPref
(
"
browser
.
link
.
open_newwindow
"
)
;
}
let
referrer
=
aOpener
?
makeURI
(
aOpener
.
location
.
href
)
:
null
;
let
referrerPolicy
=
Ci
.
nsIHttpChannel
.
REFERRER_POLICY_UNSET
;
if
(
aOpener
&
&
aOpener
.
document
)
{
referrerPolicy
=
aOpener
.
document
.
referrerPolicy
;
}
let
isPrivate
=
aOpener
?
PrivateBrowsingUtils
.
isContentWindowPrivate
(
aOpener
)
:
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
;
switch
(
aWhere
)
{
case
Ci
.
nsIBrowserDOMWindow
.
OPEN_NEWWINDOW
:
var
url
=
aURI
?
aURI
.
spec
:
"
about
:
blank
"
;
let
features
=
"
all
dialog
=
no
"
;
if
(
isPrivate
)
{
features
+
=
"
private
"
;
}
newWindow
=
openDialog
(
getBrowserURL
(
)
"
_blank
"
features
url
null
null
null
)
;
break
;
case
Ci
.
nsIBrowserDOMWindow
.
OPEN_NEWTAB
:
let
forceNotRemote
=
!
!
aOpener
;
let
userContextId
=
aOpener
&
&
aOpener
.
document
?
aOpener
.
document
.
nodePrincipal
.
originAttributes
.
userContextId
:
Ci
.
nsIScriptSecurityManager
.
DEFAULT_USER_CONTEXT_ID
;
let
openerWindow
=
(
aFlags
&
Ci
.
nsIBrowserDOMWindow
.
OPEN_NO_OPENER
)
?
null
:
aOpener
;
let
browser
=
this
.
_openURIInNewTab
(
aURI
referrer
referrerPolicy
isPrivate
isExternal
forceNotRemote
userContextId
openerWindow
aTriggeringPrincipal
)
;
if
(
browser
)
newWindow
=
browser
.
contentWindow
;
break
;
default
:
newWindow
=
window
.
content
;
if
(
aURI
)
{
let
loadflags
=
isExternal
?
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_FROM_EXTERNAL
:
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_NONE
;
gBrowser
.
loadURIWithFlags
(
aURI
.
spec
{
aTriggeringPrincipal
flags
:
loadflags
referrerURI
:
referrer
referrerPolicy
}
)
;
}
if
(
!
gPrefService
.
getBoolPref
(
"
browser
.
tabs
.
loadDivertedInBackground
"
)
)
window
.
focus
(
)
;
}
return
newWindow
;
}
openURIInFrame
:
function
browser_openURIInFrame
(
aURI
aParams
aWhere
aFlags
aNextTabParentId
aName
)
{
if
(
aWhere
!
=
Ci
.
nsIBrowserDOMWindow
.
OPEN_NEWTAB
)
{
dump
(
"
Error
:
openURIInFrame
can
only
open
in
new
tabs
"
)
;
return
null
;
}
var
isExternal
=
!
!
(
aFlags
&
Ci
.
nsIBrowserDOMWindow
.
OPEN_EXTERNAL
)
;
var
userContextId
=
aParams
.
openerOriginAttributes
&
&
(
"
userContextId
"
in
aParams
.
openerOriginAttributes
)
?
aParams
.
openerOriginAttributes
.
userContextId
:
Ci
.
nsIScriptSecurityManager
.
DEFAULT_USER_CONTEXT_ID
let
referrer
=
aParams
.
referrer
?
makeURI
(
aParams
.
referrer
)
:
null
;
let
browser
=
this
.
_openURIInNewTab
(
aURI
referrer
aParams
.
referrerPolicy
aParams
.
isPrivate
isExternal
false
userContextId
null
aParams
.
triggeringPrincipal
aNextTabParentId
aName
)
;
if
(
browser
)
return
browser
.
QueryInterface
(
Ci
.
nsIFrameLoaderOwner
)
;
return
null
;
}
isTabContentWindow
(
aWindow
)
{
return
gBrowser
.
browsers
.
some
(
browser
=
>
browser
.
contentWindow
=
=
aWindow
)
;
}
canClose
(
)
{
return
CanCloseWindow
(
)
;
}
}
function
getTogglableToolbars
(
)
{
let
toolbarNodes
=
Array
.
slice
(
gNavToolbox
.
childNodes
)
;
toolbarNodes
=
toolbarNodes
.
concat
(
gNavToolbox
.
externalToolbars
)
;
toolbarNodes
=
toolbarNodes
.
filter
(
node
=
>
node
.
getAttribute
(
"
toolbarname
"
)
)
;
return
toolbarNodes
;
}
function
onViewToolbarsPopupShowing
(
aEvent
aInsertPoint
)
{
var
popup
=
aEvent
.
target
;
if
(
popup
!
=
aEvent
.
currentTarget
)
return
;
for
(
var
i
=
popup
.
childNodes
.
length
-
1
;
i
>
=
0
;
-
-
i
)
{
var
deadItem
=
popup
.
childNodes
[
i
]
;
if
(
deadItem
.
hasAttribute
(
"
toolbarId
"
)
)
popup
.
removeChild
(
deadItem
)
;
}
var
firstMenuItem
=
aInsertPoint
|
|
popup
.
firstChild
;
let
toolbarNodes
=
getTogglableToolbars
(
)
;
for
(
let
toolbar
of
toolbarNodes
)
{
let
menuItem
=
document
.
createElement
(
"
menuitem
"
)
;
let
hidingAttribute
=
toolbar
.
getAttribute
(
"
type
"
)
=
=
"
menubar
"
?
"
autohide
"
:
"
collapsed
"
;
menuItem
.
setAttribute
(
"
id
"
"
toggle_
"
+
toolbar
.
id
)
;
menuItem
.
setAttribute
(
"
toolbarId
"
toolbar
.
id
)
;
menuItem
.
setAttribute
(
"
type
"
"
checkbox
"
)
;
menuItem
.
setAttribute
(
"
label
"
toolbar
.
getAttribute
(
"
toolbarname
"
)
)
;
menuItem
.
setAttribute
(
"
checked
"
toolbar
.
getAttribute
(
hidingAttribute
)
!
=
"
true
"
)
;
menuItem
.
setAttribute
(
"
accesskey
"
toolbar
.
getAttribute
(
"
accesskey
"
)
)
;
if
(
popup
.
id
!
=
"
toolbar
-
context
-
menu
"
)
menuItem
.
setAttribute
(
"
key
"
toolbar
.
getAttribute
(
"
key
"
)
)
;
popup
.
insertBefore
(
menuItem
firstMenuItem
)
;
menuItem
.
addEventListener
(
"
command
"
onViewToolbarCommand
)
;
}
let
moveToPanel
=
popup
.
querySelector
(
"
.
customize
-
context
-
moveToPanel
"
)
;
let
removeFromToolbar
=
popup
.
querySelector
(
"
.
customize
-
context
-
removeFromToolbar
"
)
;
if
(
!
moveToPanel
|
|
!
removeFromToolbar
)
{
return
;
}
let
toolbarItem
=
popup
.
triggerNode
;
if
(
toolbarItem
&
&
toolbarItem
.
localName
=
=
"
toolbarpaletteitem
"
)
{
toolbarItem
=
toolbarItem
.
firstChild
;
}
else
if
(
toolbarItem
&
&
toolbarItem
.
localName
!
=
"
toolbar
"
)
{
while
(
toolbarItem
&
&
toolbarItem
.
parentNode
)
{
let
parent
=
toolbarItem
.
parentNode
;
if
(
(
parent
.
classList
&
&
parent
.
classList
.
contains
(
"
customization
-
target
"
)
)
|
|
parent
.
getAttribute
(
"
overflowfortoolbar
"
)
|
|
parent
.
localName
=
=
"
toolbarpaletteitem
"
|
|
parent
.
localName
=
=
"
toolbar
"
)
break
;
toolbarItem
=
parent
;
}
}
else
{
toolbarItem
=
null
;
}
let
showTabStripItems
=
toolbarItem
&
&
toolbarItem
.
id
=
=
"
tabbrowser
-
tabs
"
;
for
(
let
node
of
popup
.
querySelectorAll
(
'
menuitem
[
contexttype
=
"
toolbaritem
"
]
'
)
)
{
node
.
hidden
=
showTabStripItems
;
}
for
(
let
node
of
popup
.
querySelectorAll
(
'
menuitem
[
contexttype
=
"
tabbar
"
]
'
)
)
{
node
.
hidden
=
!
showTabStripItems
;
}
if
(
showTabStripItems
)
{
PlacesCommandHook
.
updateBookmarkAllTabsCommand
(
)
;
let
haveMultipleTabs
=
gBrowser
.
visibleTabs
.
length
>
1
;
document
.
getElementById
(
"
toolbar
-
context
-
reloadAllTabs
"
)
.
disabled
=
!
haveMultipleTabs
;
document
.
getElementById
(
"
toolbar
-
context
-
undoCloseTab
"
)
.
disabled
=
SessionStore
.
getClosedTabCount
(
window
)
=
=
0
;
return
;
}
let
movable
=
toolbarItem
&
&
toolbarItem
.
parentNode
&
&
CustomizableUI
.
isWidgetRemovable
(
toolbarItem
)
;
let
isSpecial
=
toolbarItem
&
&
CustomizableUI
.
isSpecialWidget
(
toolbarItem
.
id
)
;
if
(
movable
)
{
if
(
isSpecial
)
{
moveToPanel
.
setAttribute
(
"
disabled
"
true
)
;
}
else
{
moveToPanel
.
removeAttribute
(
"
disabled
"
)
;
}
removeFromToolbar
.
removeAttribute
(
"
disabled
"
)
;
}
else
{
moveToPanel
.
setAttribute
(
"
disabled
"
true
)
;
removeFromToolbar
.
setAttribute
(
"
disabled
"
true
)
;
}
}
function
onViewToolbarCommand
(
aEvent
)
{
let
node
=
aEvent
.
originalTarget
;
let
toolbarId
=
node
.
getAttribute
(
"
toolbarId
"
)
;
let
isVisible
=
node
.
getAttribute
(
"
checked
"
)
=
=
"
true
"
;
CustomizableUI
.
setToolbarVisibility
(
toolbarId
isVisible
)
;
updateToggleControlLabel
(
node
)
;
}
function
setToolbarVisibility
(
toolbar
isVisible
persist
=
true
)
{
let
hidingAttribute
;
if
(
toolbar
.
getAttribute
(
"
type
"
)
=
=
"
menubar
"
)
{
hidingAttribute
=
"
autohide
"
;
if
(
AppConstants
.
platform
=
=
"
linux
"
)
{
Services
.
prefs
.
setBoolPref
(
"
ui
.
key
.
menuAccessKeyFocuses
"
!
isVisible
)
;
}
}
else
{
hidingAttribute
=
"
collapsed
"
;
}
toolbar
.
setAttribute
(
hidingAttribute
!
isVisible
)
;
if
(
persist
)
{
document
.
persist
(
toolbar
.
id
hidingAttribute
)
;
}
let
eventParams
=
{
detail
:
{
visible
:
isVisible
}
bubbles
:
true
}
;
let
event
=
new
CustomEvent
(
"
toolbarvisibilitychange
"
eventParams
)
;
toolbar
.
dispatchEvent
(
event
)
;
PlacesToolbarHelper
.
init
(
)
;
BookmarkingUI
.
onToolbarVisibilityChange
(
)
;
}
function
updateToggleControlLabel
(
control
)
{
if
(
!
control
.
hasAttribute
(
"
label
-
checked
"
)
)
{
return
;
}
if
(
!
control
.
hasAttribute
(
"
label
-
unchecked
"
)
)
{
control
.
setAttribute
(
"
label
-
unchecked
"
control
.
getAttribute
(
"
label
"
)
)
;
}
let
prefix
=
(
control
.
getAttribute
(
"
checked
"
)
=
=
"
true
"
)
?
"
"
:
"
un
"
;
control
.
setAttribute
(
"
label
"
control
.
getAttribute
(
label
-
{
prefix
}
checked
)
)
;
}
var
TabletModeUpdater
=
{
init
(
)
{
if
(
AppConstants
.
isPlatformAndVersionAtLeast
(
"
win
"
"
10
"
)
)
{
this
.
update
(
WindowsUIUtils
.
inTabletMode
)
;
Services
.
obs
.
addObserver
(
this
"
tablet
-
mode
-
change
"
)
;
}
}
uninit
(
)
{
if
(
AppConstants
.
isPlatformAndVersionAtLeast
(
"
win
"
"
10
"
)
)
{
Services
.
obs
.
removeObserver
(
this
"
tablet
-
mode
-
change
"
)
;
}
}
observe
(
subject
topic
data
)
{
this
.
update
(
data
=
=
"
tablet
-
mode
"
)
;
}
update
(
isInTabletMode
)
{
let
wasInTabletMode
=
document
.
documentElement
.
hasAttribute
(
"
tabletmode
"
)
;
if
(
isInTabletMode
)
{
document
.
documentElement
.
setAttribute
(
"
tabletmode
"
"
true
"
)
;
}
else
{
document
.
documentElement
.
removeAttribute
(
"
tabletmode
"
)
;
}
if
(
wasInTabletMode
!
=
isInTabletMode
)
{
gUIDensity
.
update
(
)
;
}
}
}
;
var
gTabletModePageCounter
=
{
enabled
:
false
inc
(
)
{
this
.
enabled
=
AppConstants
.
isPlatformAndVersionAtLeast
(
"
win
"
"
10
.
0
"
)
;
if
(
!
this
.
enabled
)
{
this
.
inc
=
(
)
=
>
{
}
;
return
;
}
this
.
inc
=
this
.
_realInc
;
this
.
inc
(
)
;
}
_desktopCount
:
0
_tabletCount
:
0
_realInc
(
)
{
let
inTabletMode
=
document
.
documentElement
.
hasAttribute
(
"
tabletmode
"
)
;
this
[
inTabletMode
?
"
_tabletCount
"
:
"
_desktopCount
"
]
+
+
;
}
finish
(
)
{
if
(
this
.
enabled
)
{
let
histogram
=
Services
.
telemetry
.
getKeyedHistogramById
(
"
FX_TABLETMODE_PAGE_LOAD
"
)
;
histogram
.
add
(
"
tablet
"
this
.
_tabletCount
)
;
histogram
.
add
(
"
desktop
"
this
.
_desktopCount
)
;
}
}
}
;
function
displaySecurityInfo
(
)
{
BrowserPageInfo
(
null
"
securityTab
"
)
;
}
var
gUIDensity
=
{
MODE_NORMAL
:
0
MODE_COMPACT
:
1
MODE_TOUCH
:
2
uiDensityPref
:
"
browser
.
uidensity
"
autoTouchModePref
:
"
browser
.
touchmode
.
auto
"
init
(
)
{
this
.
update
(
)
;
gPrefService
.
addObserver
(
this
.
uiDensityPref
this
)
;
gPrefService
.
addObserver
(
this
.
autoTouchModePref
this
)
;
}
uninit
(
)
{
gPrefService
.
removeObserver
(
this
.
uiDensityPref
this
)
;
gPrefService
.
removeObserver
(
this
.
autoTouchModePref
this
)
;
}
observe
(
aSubject
aTopic
aPrefName
)
{
if
(
aTopic
!
=
"
nsPref
:
changed
"
|
|
(
aPrefName
!
=
this
.
uiDensityPref
&
&
aPrefName
!
=
this
.
autoTouchModePref
)
)
{
return
;
}
this
.
update
(
)
;
}
getCurrentDensity
(
)
{
if
(
AppConstants
.
isPlatformAndVersionAtLeast
(
"
win
"
"
10
"
)
&
&
WindowsUIUtils
.
inTabletMode
&
&
gPrefService
.
getBoolPref
(
this
.
autoTouchModePref
)
)
{
return
{
mode
:
this
.
MODE_TOUCH
overridden
:
true
}
;
}
return
{
mode
:
gPrefService
.
getIntPref
(
this
.
uiDensityPref
)
overridden
:
false
}
;
}
setCurrentMode
(
mode
)
{
gPrefService
.
setIntPref
(
this
.
uiDensityPref
mode
)
;
}
update
(
mode
)
{
if
(
mode
=
=
null
)
{
mode
=
this
.
getCurrentDensity
(
)
.
mode
;
}
let
doc
=
document
.
documentElement
;
switch
(
mode
)
{
case
this
.
MODE_COMPACT
:
doc
.
setAttribute
(
"
uidensity
"
"
compact
"
)
;
break
;
case
this
.
MODE_TOUCH
:
doc
.
setAttribute
(
"
uidensity
"
"
touch
"
)
;
break
;
default
:
doc
.
removeAttribute
(
"
uidensity
"
)
;
break
;
}
TabsInTitlebar
.
updateAppearance
(
true
)
;
}
}
;
var
gHomeButton
=
{
prefDomain
:
"
browser
.
startup
.
homepage
"
observe
(
aSubject
aTopic
aPrefName
)
{
if
(
aTopic
!
=
"
nsPref
:
changed
"
|
|
aPrefName
!
=
this
.
prefDomain
)
return
;
this
.
updateTooltip
(
)
;
}
updateTooltip
(
homeButton
)
{
if
(
!
homeButton
)
homeButton
=
document
.
getElementById
(
"
home
-
button
"
)
;
if
(
homeButton
)
{
var
homePage
=
this
.
getHomePage
(
)
;
homePage
=
homePage
.
replace
(
/
\
|
/
g
"
"
)
;
if
(
[
"
about
:
home
"
"
about
:
newtab
"
]
.
includes
(
homePage
.
toLowerCase
(
)
)
)
homeButton
.
setAttribute
(
"
tooltiptext
"
homeButton
.
getAttribute
(
"
aboutHomeOverrideTooltip
"
)
)
;
else
homeButton
.
setAttribute
(
"
tooltiptext
"
homePage
)
;
}
}
getHomePage
(
)
{
var
url
;
try
{
url
=
gPrefService
.
getComplexValue
(
this
.
prefDomain
Components
.
interfaces
.
nsIPrefLocalizedString
)
.
data
;
}
catch
(
e
)
{
}
if
(
!
url
)
{
var
configBundle
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
branding
/
locale
/
browserconfig
.
properties
"
)
;
url
=
configBundle
.
GetStringFromName
(
this
.
prefDomain
)
;
}
return
url
;
}
}
;
const
nodeToTooltipMap
=
{
"
bookmarks
-
menu
-
button
"
:
"
bookmarksMenuButton
.
tooltip
"
"
context
-
reload
"
:
"
reloadButton
.
tooltip
"
"
context
-
stop
"
:
"
stopButton
.
tooltip
"
"
downloads
-
button
"
:
"
downloads
.
tooltip
"
"
fullscreen
-
button
"
:
"
fullscreenButton
.
tooltip
"
"
appMenu
-
fullscreen
-
button
"
:
"
fullscreenButton
.
tooltip
"
"
new
-
window
-
button
"
:
"
newWindowButton
.
tooltip
"
"
new
-
tab
-
button
"
:
"
newTabButton
.
tooltip
"
"
tabs
-
newtab
-
button
"
:
"
newTabButton
.
tooltip
"
"
reload
-
button
"
:
"
reloadButton
.
tooltip
"
"
stop
-
button
"
:
"
stopButton
.
tooltip
"
"
urlbar
-
zoom
-
button
"
:
"
urlbar
-
zoom
-
button
.
tooltip
"
"
appMenu
-
cut
-
button
"
:
"
cut
-
button
.
tooltip
"
"
appMenu
-
copy
-
button
"
:
"
copy
-
button
.
tooltip
"
"
appMenu
-
paste
-
button
"
:
"
paste
-
button
.
tooltip
"
"
appMenu
-
zoomEnlarge
-
button
"
:
"
zoomEnlarge
-
button
.
tooltip
"
"
appMenu
-
zoomReset
-
button
"
:
"
zoomReset
-
button
.
tooltip
"
"
appMenu
-
zoomReduce
-
button
"
:
"
zoomReduce
-
button
.
tooltip
"
}
;
const
nodeToShortcutMap
=
{
"
bookmarks
-
menu
-
button
"
:
"
manBookmarkKb
"
"
context
-
reload
"
:
"
key_reload
"
"
context
-
stop
"
:
"
key_stop
"
"
downloads
-
button
"
:
"
key_openDownloads
"
"
fullscreen
-
button
"
:
"
key_fullScreen
"
"
appMenu
-
fullscreen
-
button
"
:
"
key_fullScreen
"
"
new
-
window
-
button
"
:
"
key_newNavigator
"
"
new
-
tab
-
button
"
:
"
key_newNavigatorTab
"
"
tabs
-
newtab
-
button
"
:
"
key_newNavigatorTab
"
"
reload
-
button
"
:
"
key_reload
"
"
stop
-
button
"
:
"
key_stop
"
"
urlbar
-
zoom
-
button
"
:
"
key_fullZoomReset
"
"
appMenu
-
cut
-
button
"
:
"
key_cut
"
"
appMenu
-
copy
-
button
"
:
"
key_copy
"
"
appMenu
-
paste
-
button
"
:
"
key_paste
"
"
appMenu
-
zoomEnlarge
-
button
"
:
"
key_fullZoomEnlarge
"
"
appMenu
-
zoomReset
-
button
"
:
"
key_fullZoomReset
"
"
appMenu
-
zoomReduce
-
button
"
:
"
key_fullZoomReduce
"
}
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
nodeToTooltipMap
[
"
print
-
button
"
]
=
"
printButton
.
tooltip
"
;
nodeToShortcutMap
[
"
print
-
button
"
]
=
"
printKb
"
;
}
const
gDynamicTooltipCache
=
new
Map
(
)
;
function
UpdateDynamicShortcutTooltipText
(
aTooltip
)
{
let
nodeId
=
aTooltip
.
triggerNode
.
id
|
|
aTooltip
.
triggerNode
.
getAttribute
(
"
anonid
"
)
;
if
(
!
gDynamicTooltipCache
.
has
(
nodeId
)
&
&
nodeId
in
nodeToTooltipMap
)
{
let
strId
=
nodeToTooltipMap
[
nodeId
]
;
let
args
=
[
]
;
if
(
nodeId
in
nodeToShortcutMap
)
{
let
shortcutId
=
nodeToShortcutMap
[
nodeId
]
;
let
shortcut
=
document
.
getElementById
(
shortcutId
)
;
if
(
shortcut
)
{
args
.
push
(
ShortcutUtils
.
prettifyShortcut
(
shortcut
)
)
;
}
}
gDynamicTooltipCache
.
set
(
nodeId
gNavigatorBundle
.
getFormattedString
(
strId
args
)
)
;
}
aTooltip
.
setAttribute
(
"
label
"
gDynamicTooltipCache
.
get
(
nodeId
)
)
;
}
var
gWebPanelURI
;
function
openWebPanel
(
title
uri
)
{
SidebarUI
.
show
(
"
viewWebPanelsSidebar
"
)
;
SidebarUI
.
title
=
title
;
if
(
SidebarUI
.
browser
.
docShell
&
&
SidebarUI
.
browser
.
contentDocument
&
&
SidebarUI
.
browser
.
contentDocument
.
getElementById
(
"
web
-
panels
-
browser
"
)
)
{
SidebarUI
.
browser
.
contentWindow
.
loadWebPanel
(
uri
)
;
if
(
gWebPanelURI
)
{
gWebPanelURI
=
"
"
;
SidebarUI
.
browser
.
removeEventListener
(
"
load
"
asyncOpenWebPanel
true
)
;
}
}
else
{
if
(
!
gWebPanelURI
)
{
SidebarUI
.
browser
.
addEventListener
(
"
load
"
asyncOpenWebPanel
true
)
;
}
gWebPanelURI
=
uri
;
}
}
function
asyncOpenWebPanel
(
event
)
{
if
(
gWebPanelURI
&
&
SidebarUI
.
browser
.
contentDocument
&
&
SidebarUI
.
browser
.
contentDocument
.
getElementById
(
"
web
-
panels
-
browser
"
)
)
{
SidebarUI
.
browser
.
contentWindow
.
loadWebPanel
(
gWebPanelURI
)
;
}
gWebPanelURI
=
"
"
;
SidebarUI
.
browser
.
removeEventListener
(
"
load
"
asyncOpenWebPanel
true
)
;
}
function
hrefAndLinkNodeForClickEvent
(
event
)
{
function
isHTMLLink
(
aNode
)
{
return
(
(
aNode
instanceof
HTMLAnchorElement
&
&
aNode
.
href
)
|
|
(
aNode
instanceof
HTMLAreaElement
&
&
aNode
.
href
)
|
|
aNode
instanceof
HTMLLinkElement
)
;
}
let
node
=
event
.
target
;
while
(
node
&
&
!
isHTMLLink
(
node
)
)
{
node
=
node
.
parentNode
;
}
if
(
node
)
return
[
node
.
href
node
]
;
let
href
baseURI
;
node
=
event
.
target
;
while
(
node
&
&
!
href
)
{
if
(
node
.
nodeType
=
=
Node
.
ELEMENT_NODE
&
&
(
node
.
localName
=
=
"
a
"
|
|
node
.
namespaceURI
=
=
"
http
:
/
/
www
.
w3
.
org
/
1998
/
Math
/
MathML
"
)
)
{
href
=
node
.
getAttribute
(
"
href
"
)
|
|
node
.
getAttributeNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xlink
"
"
href
"
)
;
if
(
href
)
{
baseURI
=
node
.
baseURI
;
break
;
}
}
node
=
node
.
parentNode
;
}
return
[
href
?
makeURLAbsolute
(
baseURI
href
)
:
null
null
]
;
}
function
contentAreaClick
(
event
isPanelClick
)
{
if
(
!
event
.
isTrusted
|
|
event
.
defaultPrevented
|
|
event
.
button
=
=
2
)
return
;
let
[
href
linkNode
]
=
hrefAndLinkNodeForClickEvent
(
event
)
;
if
(
!
href
)
{
if
(
event
.
button
=
=
1
&
&
gPrefService
.
getBoolPref
(
"
middlemouse
.
contentLoadURL
"
)
&
&
!
gPrefService
.
getBoolPref
(
"
general
.
autoScroll
"
)
)
{
middleMousePaste
(
event
)
;
event
.
preventDefault
(
)
;
}
return
;
}
if
(
linkNode
&
&
event
.
button
=
=
0
&
&
!
event
.
ctrlKey
&
&
!
event
.
shiftKey
&
&
!
event
.
altKey
&
&
!
event
.
metaKey
)
{
let
target
=
linkNode
.
target
;
let
mainTarget
=
!
target
|
|
target
=
=
"
_content
"
|
|
target
=
=
"
_main
"
;
if
(
isPanelClick
&
&
mainTarget
)
{
if
(
linkNode
.
getAttribute
(
"
onclick
"
)
|
|
href
.
startsWith
(
"
javascript
:
"
)
|
|
href
.
startsWith
(
"
data
:
"
)
)
return
;
try
{
urlSecurityCheck
(
href
linkNode
.
ownerDocument
.
nodePrincipal
)
;
}
catch
(
ex
)
{
event
.
preventDefault
(
)
;
return
;
}
loadURI
(
href
null
null
false
)
;
event
.
preventDefault
(
)
;
return
;
}
if
(
linkNode
.
getAttribute
(
"
rel
"
)
=
=
"
sidebar
"
)
{
PlacesUIUtils
.
showBookmarkDialog
(
{
action
:
"
add
"
type
:
"
bookmark
"
uri
:
makeURI
(
href
)
title
:
linkNode
.
getAttribute
(
"
title
"
)
loadBookmarkInSidebar
:
true
hiddenRows
:
[
"
description
"
"
location
"
"
keyword
"
]
}
window
)
;
event
.
preventDefault
(
)
;
return
;
}
}
handleLinkClick
(
event
href
linkNode
)
;
try
{
if
(
!
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
PlacesUIUtils
.
markPageAsFollowedLink
(
href
)
;
}
catch
(
ex
)
{
}
}
function
handleLinkClick
(
event
href
linkNode
)
{
if
(
event
.
button
=
=
2
)
return
false
;
var
where
=
whereToOpenLink
(
event
)
;
if
(
where
=
=
"
current
"
)
return
false
;
var
doc
=
event
.
target
.
ownerDocument
;
if
(
where
=
=
"
save
"
)
{
saveURL
(
href
linkNode
?
gatherTextUnder
(
linkNode
)
:
"
"
null
true
true
doc
.
documentURIObject
doc
)
;
event
.
preventDefault
(
)
;
return
true
;
}
var
referrerURI
=
doc
.
documentURIObject
;
var
persistAllowMixedContentInChildTab
=
false
;
if
(
where
=
=
"
tab
"
&
&
gBrowser
.
docShell
.
mixedContentChannel
)
{
const
sm
=
Services
.
scriptSecurityManager
;
try
{
var
targetURI
=
makeURI
(
href
)
;
sm
.
checkSameOriginURI
(
referrerURI
targetURI
false
)
;
persistAllowMixedContentInChildTab
=
true
;
}
catch
(
e
)
{
}
}
let
referrerPolicy
=
doc
.
referrerPolicy
;
if
(
linkNode
)
{
let
referrerAttrValue
=
Services
.
netUtils
.
parseAttributePolicyString
(
linkNode
.
getAttribute
(
"
referrerpolicy
"
)
)
;
if
(
referrerAttrValue
!
=
Ci
.
nsIHttpChannel
.
REFERRER_POLICY_UNSET
)
{
referrerPolicy
=
referrerAttrValue
;
}
}
let
frameOuterWindowID
=
WebNavigationFrames
.
getFrameId
(
doc
.
defaultView
)
;
urlSecurityCheck
(
href
doc
.
nodePrincipal
)
;
let
params
=
{
charset
:
doc
.
characterSet
allowMixedContent
:
persistAllowMixedContentInChildTab
referrerURI
referrerPolicy
noReferrer
:
BrowserUtils
.
linkHasNoReferrer
(
linkNode
)
originPrincipal
:
doc
.
nodePrincipal
triggeringPrincipal
:
doc
.
nodePrincipal
frameOuterWindowID
}
;
if
(
doc
.
nodePrincipal
.
originAttributes
.
userContextId
)
{
params
.
userContextId
=
doc
.
nodePrincipal
.
originAttributes
.
userContextId
;
}
openLinkIn
(
href
where
params
)
;
event
.
preventDefault
(
)
;
return
true
;
}
function
middleMousePaste
(
event
)
{
let
clipboard
=
readFromClipboard
(
)
;
if
(
!
clipboard
)
return
;
clipboard
=
clipboard
.
replace
(
/
\
s
*
\
n
\
s
*
/
g
"
"
)
;
clipboard
=
stripUnsafeProtocolOnPaste
(
clipboard
)
;
let
where
=
whereToOpenLink
(
event
true
false
)
;
let
lastLocationChange
;
if
(
where
=
=
"
current
"
)
{
lastLocationChange
=
gBrowser
.
selectedBrowser
.
lastLocationChange
;
}
getShortcutOrURIAndPostData
(
clipboard
)
.
then
(
data
=
>
{
try
{
makeURI
(
data
.
url
)
;
}
catch
(
ex
)
{
return
;
}
try
{
addToUrlbarHistory
(
data
.
url
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
if
(
where
!
=
"
current
"
|
|
lastLocationChange
=
=
gBrowser
.
selectedBrowser
.
lastLocationChange
)
{
openUILink
(
data
.
url
event
{
ignoreButton
:
true
disallowInheritPrincipal
:
!
data
.
mayInheritPrincipal
}
)
;
}
}
)
;
event
.
stopPropagation
(
)
;
}
function
stripUnsafeProtocolOnPaste
(
pasteData
)
{
let
changed
=
false
;
let
pasteDataNoJS
=
pasteData
.
replace
(
/
\
r
?
\
n
/
g
"
"
)
.
replace
(
/
^
(
?
:
\
s
*
javascript
:
)
+
/
i
(
)
=
>
{
changed
=
true
;
return
"
"
;
}
)
;
return
changed
?
pasteDataNoJS
:
pasteData
;
}
function
handleDroppedLink
(
event
urlOrLinks
nameOrTriggeringPrincipal
triggeringPrincipal
)
{
let
links
;
if
(
Array
.
isArray
(
urlOrLinks
)
)
{
links
=
urlOrLinks
;
triggeringPrincipal
=
nameOrTriggeringPrincipal
;
}
else
{
links
=
[
{
url
:
urlOrLinks
nameOrTriggeringPrincipal
type
:
"
"
}
]
;
}
let
lastLocationChange
=
gBrowser
.
selectedBrowser
.
lastLocationChange
;
let
userContextId
=
gBrowser
.
selectedBrowser
.
getAttribute
(
"
usercontextid
"
)
;
let
inBackground
=
false
;
if
(
event
)
{
inBackground
=
Services
.
prefs
.
getBoolPref
(
"
browser
.
tabs
.
loadInBackground
"
)
;
if
(
event
.
shiftKey
)
inBackground
=
!
inBackground
;
}
(
async
function
(
)
{
let
urls
=
[
]
;
let
postDatas
=
[
]
;
for
(
let
link
of
links
)
{
let
data
=
await
getShortcutOrURIAndPostData
(
link
.
url
)
;
urls
.
push
(
data
.
url
)
;
postDatas
.
push
(
data
.
postData
)
;
}
if
(
lastLocationChange
=
=
gBrowser
.
selectedBrowser
.
lastLocationChange
)
{
gBrowser
.
loadTabs
(
urls
{
inBackground
replace
:
true
allowThirdPartyFixup
:
false
postDatas
userContextId
triggeringPrincipal
}
)
;
}
}
)
(
)
;
if
(
event
)
{
event
.
preventDefault
(
)
;
}
}
function
BrowserSetForcedCharacterSet
(
aCharset
)
{
if
(
aCharset
)
{
gBrowser
.
selectedBrowser
.
characterSet
=
aCharset
;
if
(
!
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
PlacesUtils
.
setCharsetForURI
(
getWebNavigation
(
)
.
currentURI
aCharset
)
;
}
BrowserCharsetReload
(
)
;
}
function
BrowserCharsetReload
(
)
{
BrowserReloadWithFlags
(
nsIWebNavigation
.
LOAD_FLAGS_CHARSET_CHANGE
)
;
}
function
UpdateCurrentCharset
(
target
)
{
let
selectedCharset
=
CharsetMenu
.
foldCharset
(
gBrowser
.
selectedBrowser
.
characterSet
)
;
for
(
let
menuItem
of
target
.
getElementsByTagName
(
"
menuitem
"
)
)
{
let
isSelected
=
menuItem
.
getAttribute
(
"
charset
"
)
=
=
=
selectedCharset
;
menuItem
.
setAttribute
(
"
checked
"
isSelected
)
;
}
}
var
gPageStyleMenu
=
{
_pageStyleSheets
:
new
WeakMap
(
)
init
(
)
{
let
mm
=
window
.
messageManager
;
mm
.
addMessageListener
(
"
PageStyle
:
StyleSheets
"
(
msg
)
=
>
{
this
.
_pageStyleSheets
.
set
(
msg
.
target
.
permanentKey
msg
.
data
)
;
}
)
;
}
getBrowserStyleSheets
(
browser
)
{
if
(
!
browser
)
{
browser
=
gBrowser
.
selectedBrowser
;
}
let
data
=
this
.
_pageStyleSheets
.
get
(
browser
.
permanentKey
)
;
if
(
!
data
)
{
return
[
]
;
}
return
data
.
filteredStyleSheets
;
}
_getStyleSheetInfo
(
browser
)
{
let
data
=
this
.
_pageStyleSheets
.
get
(
browser
.
permanentKey
)
;
if
(
!
data
)
{
return
{
filteredStyleSheets
:
[
]
authorStyleDisabled
:
false
preferredStyleSheetSet
:
true
}
;
}
return
data
;
}
fillPopup
(
menuPopup
)
{
let
styleSheetInfo
=
this
.
_getStyleSheetInfo
(
gBrowser
.
selectedBrowser
)
;
var
noStyle
=
menuPopup
.
firstChild
;
var
persistentOnly
=
noStyle
.
nextSibling
;
var
sep
=
persistentOnly
.
nextSibling
;
while
(
sep
.
nextSibling
)
menuPopup
.
removeChild
(
sep
.
nextSibling
)
;
let
styleSheets
=
styleSheetInfo
.
filteredStyleSheets
;
var
currentStyleSheets
=
{
}
;
var
styleDisabled
=
styleSheetInfo
.
authorStyleDisabled
;
var
haveAltSheets
=
false
;
var
altStyleSelected
=
false
;
for
(
let
currentStyleSheet
of
styleSheets
)
{
if
(
!
currentStyleSheet
.
disabled
)
altStyleSelected
=
true
;
haveAltSheets
=
true
;
let
lastWithSameTitle
=
null
;
if
(
currentStyleSheet
.
title
in
currentStyleSheets
)
lastWithSameTitle
=
currentStyleSheets
[
currentStyleSheet
.
title
]
;
if
(
!
lastWithSameTitle
)
{
let
menuItem
=
document
.
createElement
(
"
menuitem
"
)
;
menuItem
.
setAttribute
(
"
type
"
"
radio
"
)
;
menuItem
.
setAttribute
(
"
label
"
currentStyleSheet
.
title
)
;
menuItem
.
setAttribute
(
"
data
"
currentStyleSheet
.
title
)
;
menuItem
.
setAttribute
(
"
checked
"
!
currentStyleSheet
.
disabled
&
&
!
styleDisabled
)
;
menuItem
.
setAttribute
(
"
oncommand
"
"
gPageStyleMenu
.
switchStyleSheet
(
this
.
getAttribute
(
'
data
'
)
)
;
"
)
;
menuPopup
.
appendChild
(
menuItem
)
;
currentStyleSheets
[
currentStyleSheet
.
title
]
=
menuItem
;
}
else
if
(
currentStyleSheet
.
disabled
)
{
lastWithSameTitle
.
removeAttribute
(
"
checked
"
)
;
}
}
noStyle
.
setAttribute
(
"
checked
"
styleDisabled
)
;
persistentOnly
.
setAttribute
(
"
checked
"
!
altStyleSelected
&
&
!
styleDisabled
)
;
persistentOnly
.
hidden
=
styleSheetInfo
.
preferredStyleSheetSet
?
haveAltSheets
:
false
;
sep
.
hidden
=
(
noStyle
.
hidden
&
&
persistentOnly
.
hidden
)
|
|
!
haveAltSheets
;
}
switchStyleSheet
(
title
)
{
let
mm
=
gBrowser
.
selectedBrowser
.
messageManager
;
mm
.
sendAsyncMessage
(
"
PageStyle
:
Switch
"
{
title
}
)
;
}
disableStyle
(
)
{
let
mm
=
gBrowser
.
selectedBrowser
.
messageManager
;
mm
.
sendAsyncMessage
(
"
PageStyle
:
Disable
"
)
;
}
}
;
var
stylesheetFillPopup
=
gPageStyleMenu
.
fillPopup
.
bind
(
gPageStyleMenu
)
;
function
stylesheetSwitchAll
(
contentWindow
title
)
{
gPageStyleMenu
.
switchStyleSheet
(
title
)
;
}
function
setStyleDisabled
(
disabled
)
{
if
(
disabled
)
gPageStyleMenu
.
disableStyle
(
)
;
}
var
LanguageDetectionListener
=
{
init
(
)
{
window
.
messageManager
.
addMessageListener
(
"
Translation
:
DocumentState
"
msg
=
>
{
Translation
.
documentStateReceived
(
msg
.
target
msg
.
data
)
;
}
)
;
}
}
;
var
BrowserOffline
=
{
_inited
:
false
init
(
)
{
if
(
!
this
.
_uiElement
)
this
.
_uiElement
=
document
.
getElementById
(
"
workOfflineMenuitemState
"
)
;
Services
.
obs
.
addObserver
(
this
"
network
:
offline
-
status
-
changed
"
)
;
this
.
_updateOfflineUI
(
Services
.
io
.
offline
)
;
this
.
_inited
=
true
;
}
uninit
(
)
{
if
(
this
.
_inited
)
{
Services
.
obs
.
removeObserver
(
this
"
network
:
offline
-
status
-
changed
"
)
;
}
}
toggleOfflineStatus
(
)
{
var
ioService
=
Services
.
io
;
if
(
!
ioService
.
offline
&
&
!
this
.
_canGoOffline
(
)
)
{
this
.
_updateOfflineUI
(
false
)
;
return
;
}
ioService
.
offline
=
!
ioService
.
offline
;
}
observe
(
aSubject
aTopic
aState
)
{
if
(
aTopic
!
=
"
network
:
offline
-
status
-
changed
"
)
return
;
this
.
_updateOfflineUI
(
Services
.
io
.
offline
)
;
}
_canGoOffline
(
)
{
try
{
var
cancelGoOffline
=
Cc
[
"
mozilla
.
org
/
supports
-
PRBool
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsPRBool
)
;
Services
.
obs
.
notifyObservers
(
cancelGoOffline
"
offline
-
requested
"
)
;
if
(
cancelGoOffline
.
data
)
return
false
;
}
catch
(
ex
)
{
}
return
true
;
}
_uiElement
:
null
_updateOfflineUI
(
aOffline
)
{
var
offlineLocked
=
gPrefService
.
prefIsLocked
(
"
network
.
online
"
)
;
if
(
offlineLocked
)
this
.
_uiElement
.
setAttribute
(
"
disabled
"
"
true
"
)
;
this
.
_uiElement
.
setAttribute
(
"
checked
"
aOffline
)
;
}
}
;
var
OfflineApps
=
{
warnUsage
(
browser
uri
)
{
if
(
!
browser
)
return
;
let
mainAction
=
{
label
:
gNavigatorBundle
.
getString
(
"
offlineApps
.
manageUsage
"
)
accessKey
:
gNavigatorBundle
.
getString
(
"
offlineApps
.
manageUsageAccessKey
"
)
callback
:
this
.
manage
}
;
let
warnQuotaKB
=
Services
.
prefs
.
getIntPref
(
"
offline
-
apps
.
quota
.
warn
"
)
;
let
message
=
gNavigatorBundle
.
getFormattedString
(
"
offlineApps
.
usage
"
[
uri
.
host
warnQuotaKB
/
1024
]
)
;
let
anchorID
=
"
indexedDB
-
notification
-
icon
"
;
let
options
=
{
persistent
:
true
hideClose
:
true
}
;
PopupNotifications
.
show
(
browser
"
offline
-
app
-
usage
"
message
anchorID
mainAction
null
options
)
;
Services
.
perms
.
add
(
uri
"
offline
-
app
"
Ci
.
nsIOfflineCacheUpdateService
.
ALLOW_NO_WARN
)
;
}
_getOfflineAppUsage
(
host
groups
)
{
let
cacheService
=
Cc
[
"
mozilla
.
org
/
network
/
application
-
cache
-
service
;
1
"
]
.
getService
(
Ci
.
nsIApplicationCacheService
)
;
if
(
!
groups
)
{
try
{
groups
=
cacheService
.
getGroups
(
)
;
}
catch
(
ex
)
{
return
0
;
}
}
let
usage
=
0
;
for
(
let
group
of
groups
)
{
let
uri
=
Services
.
io
.
newURI
(
group
)
;
if
(
uri
.
asciiHost
=
=
host
)
{
let
cache
=
cacheService
.
getActiveCache
(
group
)
;
usage
+
=
cache
.
usage
;
}
}
return
usage
;
}
_usedMoreThanWarnQuota
(
uri
)
{
if
(
Services
.
perms
.
testExactPermission
(
uri
"
offline
-
app
"
)
!
=
Ci
.
nsIOfflineCacheUpdateService
.
ALLOW_NO_WARN
)
{
let
usageBytes
=
this
.
_getOfflineAppUsage
(
uri
.
asciiHost
)
;
let
warnQuotaKB
=
Services
.
prefs
.
getIntPref
(
"
offline
-
apps
.
quota
.
warn
"
)
;
if
(
usageBytes
>
=
warnQuotaKB
*
1024
)
{
return
true
;
}
}
return
false
;
}
requestPermission
(
browser
docId
uri
)
{
let
host
=
uri
.
asciiHost
;
let
notificationID
=
"
offline
-
app
-
requested
-
"
+
host
;
let
notification
=
PopupNotifications
.
getNotification
(
notificationID
browser
)
;
if
(
notification
)
{
notification
.
options
.
controlledItems
.
push
(
[
Cu
.
getWeakReference
(
browser
)
docId
uri
]
)
;
}
else
{
let
mainAction
=
{
label
:
gNavigatorBundle
.
getString
(
"
offlineApps
.
allowStoring
.
label
"
)
accessKey
:
gNavigatorBundle
.
getString
(
"
offlineApps
.
allowStoring
.
accesskey
"
)
callback
(
)
{
for
(
let
[
ciBrowser
ciDocId
ciUri
]
of
notification
.
options
.
controlledItems
)
{
OfflineApps
.
allowSite
(
ciBrowser
ciDocId
ciUri
)
;
}
}
}
;
let
secondaryActions
=
[
{
label
:
gNavigatorBundle
.
getString
(
"
offlineApps
.
dontAllow
.
label
"
)
accessKey
:
gNavigatorBundle
.
getString
(
"
offlineApps
.
dontAllow
.
accesskey
"
)
callback
(
)
{
for
(
let
[
ciUri
]
of
notification
.
options
.
controlledItems
)
{
OfflineApps
.
disallowSite
(
ciUri
)
;
}
}
}
]
;
let
message
=
gNavigatorBundle
.
getFormattedString
(
"
offlineApps
.
available2
"
[
host
]
)
;
let
anchorID
=
"
indexedDB
-
notification
-
icon
"
;
let
options
=
{
persistent
:
true
hideClose
:
true
controlledItems
:
[
[
Cu
.
getWeakReference
(
browser
)
docId
uri
]
]
}
;
notification
=
PopupNotifications
.
show
(
browser
notificationID
message
anchorID
mainAction
secondaryActions
options
)
;
}
}
disallowSite
(
uri
)
{
Services
.
perms
.
add
(
uri
"
offline
-
app
"
Services
.
perms
.
DENY_ACTION
)
;
}
allowSite
(
browserRef
docId
uri
)
{
Services
.
perms
.
add
(
uri
"
offline
-
app
"
Services
.
perms
.
ALLOW_ACTION
)
;
let
browser
=
browserRef
.
get
(
)
;
if
(
browser
&
&
browser
.
messageManager
)
{
browser
.
messageManager
.
sendAsyncMessage
(
"
OfflineApps
:
StartFetching
"
{
docId
}
)
;
}
}
manage
(
)
{
if
(
Services
.
prefs
.
getBoolPref
(
"
browser
.
preferences
.
useOldOrganization
"
)
)
{
openAdvancedPreferences
(
"
networkTab
"
{
origin
:
"
offlineApps
"
}
)
;
}
else
{
openPreferences
(
"
panePrivacy
"
{
origin
:
"
offlineApps
"
}
)
;
}
}
receiveMessage
(
msg
)
{
switch
(
msg
.
name
)
{
case
"
OfflineApps
:
CheckUsage
"
:
let
uri
=
makeURI
(
msg
.
data
.
uri
)
;
if
(
this
.
_usedMoreThanWarnQuota
(
uri
)
)
{
this
.
warnUsage
(
msg
.
target
uri
)
;
}
break
;
case
"
OfflineApps
:
RequestPermission
"
:
this
.
requestPermission
(
msg
.
target
msg
.
data
.
docId
makeURI
(
msg
.
data
.
uri
)
)
;
break
;
}
}
init
(
)
{
let
mm
=
window
.
messageManager
;
mm
.
addMessageListener
(
"
OfflineApps
:
CheckUsage
"
this
)
;
mm
.
addMessageListener
(
"
OfflineApps
:
RequestPermission
"
this
)
;
}
}
;
var
IndexedDBPromptHelper
=
{
_permissionsPrompt
:
"
indexedDB
-
permissions
-
prompt
"
_permissionsResponse
:
"
indexedDB
-
permissions
-
response
"
_notificationIcon
:
"
indexedDB
-
notification
-
icon
"
init
:
function
IndexedDBPromptHelper_init
(
)
{
Services
.
obs
.
addObserver
(
this
this
.
_permissionsPrompt
)
;
}
uninit
:
function
IndexedDBPromptHelper_uninit
(
)
{
Services
.
obs
.
removeObserver
(
this
this
.
_permissionsPrompt
)
;
}
observe
:
function
IndexedDBPromptHelper_observe
(
subject
topic
data
)
{
if
(
topic
!
=
this
.
_permissionsPrompt
)
{
throw
new
Error
(
"
Unexpected
topic
!
"
)
;
}
var
requestor
=
subject
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
;
var
browser
=
requestor
.
getInterface
(
Ci
.
nsIDOMNode
)
;
if
(
browser
.
ownerGlobal
!
=
window
)
{
return
;
}
var
host
=
browser
.
currentURI
.
asciiHost
|
|
browser
.
currentURI
.
pathQueryRef
;
var
message
;
var
responseTopic
;
if
(
topic
=
=
this
.
_permissionsPrompt
)
{
message
=
gNavigatorBundle
.
getFormattedString
(
"
offlineApps
.
available2
"
[
host
]
)
;
responseTopic
=
this
.
_permissionsResponse
;
}
var
observer
=
requestor
.
getInterface
(
Ci
.
nsIObserver
)
;
var
mainAction
=
{
label
:
gNavigatorBundle
.
getString
(
"
offlineApps
.
allowStoring
.
label
"
)
accessKey
:
gNavigatorBundle
.
getString
(
"
offlineApps
.
allowStoring
.
accesskey
"
)
callback
(
)
{
observer
.
observe
(
null
responseTopic
Ci
.
nsIPermissionManager
.
ALLOW_ACTION
)
;
}
}
;
var
secondaryActions
=
[
{
label
:
gNavigatorBundle
.
getString
(
"
offlineApps
.
dontAllow
.
label
"
)
accessKey
:
gNavigatorBundle
.
getString
(
"
offlineApps
.
dontAllow
.
accesskey
"
)
callback
(
)
{
observer
.
observe
(
null
responseTopic
Ci
.
nsIPermissionManager
.
DENY_ACTION
)
;
}
}
]
;
PopupNotifications
.
show
(
browser
topic
message
this
.
_notificationIcon
mainAction
secondaryActions
{
persistent
:
true
hideClose
:
!
Services
.
prefs
.
getBoolPref
(
"
privacy
.
permissionPrompts
.
showCloseButton
"
)
}
)
;
}
}
;
function
CanCloseWindow
(
)
{
if
(
Services
.
startup
.
shuttingDown
|
|
window
.
skipNextCanClose
)
{
return
true
;
}
let
timedOutProcesses
=
new
WeakSet
(
)
;
for
(
let
browser
of
gBrowser
.
browsers
)
{
if
(
!
browser
.
isConnected
)
{
continue
;
}
let
pmm
=
browser
.
messageManager
.
processMessageManager
;
if
(
timedOutProcesses
.
has
(
pmm
)
)
{
continue
;
}
let
{
permitUnload
timedOut
}
=
browser
.
permitUnload
(
)
;
if
(
timedOut
)
{
timedOutProcesses
.
add
(
pmm
)
;
continue
;
}
if
(
!
permitUnload
)
{
return
false
;
}
}
return
true
;
}
function
WindowIsClosing
(
)
{
if
(
!
closeWindow
(
false
warnAboutClosingWindow
)
)
return
false
;
if
(
CanCloseWindow
(
)
)
{
window
.
skipNextCanClose
=
true
;
return
true
;
}
return
false
;
}
function
warnAboutClosingWindow
(
)
{
let
isPBWindow
=
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
&
&
!
PrivateBrowsingUtils
.
permanentPrivateBrowsing
;
if
(
!
isPBWindow
&
&
!
toolbar
.
visible
)
return
gBrowser
.
warnAboutClosingTabs
(
gBrowser
.
closingTabsEnum
.
ALL
)
;
let
otherPBWindowExists
=
false
;
let
nonPopupPresent
=
false
;
for
(
let
win
of
browserWindows
(
)
)
{
if
(
!
win
.
closed
&
&
win
!
=
window
)
{
if
(
isPBWindow
&
&
PrivateBrowsingUtils
.
isWindowPrivate
(
win
)
)
otherPBWindowExists
=
true
;
if
(
win
.
toolbar
.
visible
)
nonPopupPresent
=
true
;
if
(
(
!
isPBWindow
|
|
otherPBWindowExists
)
&
&
nonPopupPresent
)
break
;
}
}
if
(
isPBWindow
&
&
!
otherPBWindowExists
)
{
let
exitingCanceled
=
Cc
[
"
mozilla
.
org
/
supports
-
PRBool
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsPRBool
)
;
exitingCanceled
.
data
=
false
;
Services
.
obs
.
notifyObservers
(
exitingCanceled
"
last
-
pb
-
context
-
exiting
"
)
;
if
(
exitingCanceled
.
data
)
return
false
;
}
if
(
nonPopupPresent
)
{
return
isPBWindow
|
|
gBrowser
.
warnAboutClosingTabs
(
gBrowser
.
closingTabsEnum
.
ALL
)
;
}
let
os
=
Services
.
obs
;
let
closingCanceled
=
Cc
[
"
mozilla
.
org
/
supports
-
PRBool
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsPRBool
)
;
os
.
notifyObservers
(
closingCanceled
"
browser
-
lastwindow
-
close
-
requested
"
)
;
if
(
closingCanceled
.
data
)
return
false
;
os
.
notifyObservers
(
null
"
browser
-
lastwindow
-
close
-
granted
"
)
;
return
AppConstants
.
platform
!
=
"
macosx
"
|
|
(
isPBWindow
|
|
gBrowser
.
warnAboutClosingTabs
(
gBrowser
.
closingTabsEnum
.
ALL
)
)
;
}
var
MailIntegration
=
{
sendLinkForBrowser
(
aBrowser
)
{
this
.
sendMessage
(
aBrowser
.
currentURI
.
displaySpec
aBrowser
.
contentTitle
)
;
}
sendMessage
(
aBody
aSubject
)
{
var
mailtoUrl
=
"
mailto
:
"
;
if
(
aBody
)
{
mailtoUrl
+
=
"
?
body
=
"
+
encodeURIComponent
(
aBody
)
;
mailtoUrl
+
=
"
&
subject
=
"
+
encodeURIComponent
(
aSubject
)
;
}
var
uri
=
makeURI
(
mailtoUrl
)
;
this
.
_launchExternalUrl
(
uri
)
;
}
_launchExternalUrl
(
aURL
)
{
var
extProtocolSvc
=
Cc
[
"
mozilla
.
org
/
uriloader
/
external
-
protocol
-
service
;
1
"
]
.
getService
(
Ci
.
nsIExternalProtocolService
)
;
if
(
extProtocolSvc
)
extProtocolSvc
.
loadURI
(
aURL
)
;
}
}
;
function
BrowserOpenAddonsMgr
(
aView
)
{
return
new
Promise
(
resolve
=
>
{
let
emWindow
;
let
browserWindow
;
var
receivePong
=
function
(
aSubject
aTopic
aData
)
{
let
browserWin
=
aSubject
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebNavigation
)
.
QueryInterface
(
Ci
.
nsIDocShellTreeItem
)
.
rootTreeItem
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindow
)
;
if
(
!
emWindow
|
|
browserWin
=
=
window
)
{
emWindow
=
aSubject
;
browserWindow
=
browserWin
;
}
}
Services
.
obs
.
addObserver
(
receivePong
"
EM
-
pong
"
)
;
Services
.
obs
.
notifyObservers
(
null
"
EM
-
ping
"
)
;
Services
.
obs
.
removeObserver
(
receivePong
"
EM
-
pong
"
)
;
if
(
emWindow
)
{
if
(
aView
)
{
emWindow
.
loadView
(
aView
)
;
}
browserWindow
.
gBrowser
.
selectedTab
=
browserWindow
.
gBrowser
.
_getTabForContentWindow
(
emWindow
)
;
emWindow
.
focus
(
)
;
resolve
(
emWindow
)
;
return
;
}
let
whereToOpen
=
(
window
.
gBrowser
&
&
isTabEmpty
(
gBrowser
.
selectedTab
)
)
?
"
current
"
:
"
tab
"
;
openUILinkIn
(
"
about
:
addons
"
whereToOpen
)
;
Services
.
obs
.
addObserver
(
function
observer
(
aSubject
aTopic
aData
)
{
Services
.
obs
.
removeObserver
(
observer
aTopic
)
;
if
(
aView
)
{
aSubject
.
loadView
(
aView
)
;
}
aSubject
.
QueryInterface
(
Ci
.
nsIDOMWindow
)
;
aSubject
.
focus
(
)
;
resolve
(
aSubject
)
;
}
"
EM
-
loaded
"
)
;
}
)
;
}
function
AddKeywordForSearchField
(
)
{
let
mm
=
gBrowser
.
selectedBrowser
.
messageManager
;
let
onMessage
=
(
message
)
=
>
{
mm
.
removeMessageListener
(
"
ContextMenu
:
SearchFieldBookmarkData
:
Result
"
onMessage
)
;
let
bookmarkData
=
message
.
data
;
let
title
=
gNavigatorBundle
.
getFormattedString
(
"
addKeywordTitleAutoFill
"
[
bookmarkData
.
title
]
)
;
PlacesUIUtils
.
showBookmarkDialog
(
{
action
:
"
add
"
type
:
"
bookmark
"
uri
:
makeURI
(
bookmarkData
.
spec
)
title
description
:
bookmarkData
.
description
keyword
:
"
"
postData
:
bookmarkData
.
postData
charSet
:
bookmarkData
.
charset
hiddenRows
:
[
"
location
"
"
description
"
"
tags
"
"
loadInSidebar
"
]
}
window
)
;
}
mm
.
addMessageListener
(
"
ContextMenu
:
SearchFieldBookmarkData
:
Result
"
onMessage
)
;
mm
.
sendAsyncMessage
(
"
ContextMenu
:
SearchFieldBookmarkData
"
{
}
{
target
:
gContextMenu
.
target
}
)
;
}
function
undoCloseTab
(
aIndex
)
{
var
blankTabToRemove
=
null
;
if
(
gBrowser
.
tabs
.
length
=
=
1
&
&
isTabEmpty
(
gBrowser
.
selectedTab
)
)
blankTabToRemove
=
gBrowser
.
selectedTab
;
var
tab
=
null
;
if
(
SessionStore
.
getClosedTabCount
(
window
)
>
(
aIndex
|
|
0
)
)
{
tab
=
SessionStore
.
undoCloseTab
(
window
aIndex
|
|
0
)
;
if
(
blankTabToRemove
)
gBrowser
.
removeTab
(
blankTabToRemove
)
;
}
return
tab
;
}
function
undoCloseWindow
(
aIndex
)
{
let
window
=
null
;
if
(
SessionStore
.
getClosedWindowCount
(
)
>
(
aIndex
|
|
0
)
)
window
=
SessionStore
.
undoCloseWindow
(
aIndex
|
|
0
)
;
return
window
;
}
function
isTabEmpty
(
aTab
)
{
if
(
aTab
.
hasAttribute
(
"
busy
"
)
)
return
false
;
if
(
aTab
.
hasAttribute
(
"
customizemode
"
)
)
return
false
;
let
browser
=
aTab
.
linkedBrowser
;
if
(
!
isBlankPageURL
(
browser
.
currentURI
.
spec
)
)
return
false
;
if
(
!
checkEmptyPageOrigin
(
browser
)
)
return
false
;
if
(
browser
.
canGoForward
|
|
browser
.
canGoBack
)
return
false
;
return
true
;
}
function
checkEmptyPageOrigin
(
browser
=
gBrowser
.
selectedBrowser
uri
=
browser
.
currentURI
)
{
if
(
browser
.
hasContentOpener
)
{
return
false
;
}
let
contentPrincipal
=
browser
.
contentPrincipal
;
if
(
contentPrincipal
.
URI
)
{
let
uriToCheck
=
browser
.
documentURI
|
|
uri
;
if
(
(
uriToCheck
.
spec
=
=
"
about
:
blank
"
&
&
contentPrincipal
.
isNullPrincipal
)
|
|
contentPrincipal
.
URI
.
spec
=
=
"
about
:
blank
"
)
{
return
true
;
}
return
contentPrincipal
.
URI
.
equals
(
uri
)
;
}
let
ssm
=
Services
.
scriptSecurityManager
;
return
ssm
.
isSystemPrincipal
(
contentPrincipal
)
;
}
function
BrowserOpenSyncTabs
(
)
{
gSync
.
openSyncedTabsPanel
(
)
;
}
function
ReportFalseDeceptiveSite
(
)
{
let
docURI
=
gBrowser
.
selectedBrowser
.
documentURI
;
let
isPhishingPage
=
docURI
&
&
docURI
.
spec
.
startsWith
(
"
about
:
blocked
?
e
=
deceptiveBlocked
"
)
;
if
(
isPhishingPage
)
{
let
mm
=
gBrowser
.
selectedBrowser
.
messageManager
;
let
onMessage
=
(
message
)
=
>
{
mm
.
removeMessageListener
(
"
DeceptiveBlockedDetails
:
Result
"
onMessage
)
;
let
reportUrl
=
gSafeBrowsing
.
getReportURL
(
"
PhishMistake
"
message
.
data
.
blockedInfo
)
;
if
(
reportUrl
)
{
openUILinkIn
(
reportUrl
"
tab
"
)
;
}
else
{
let
promptService
=
Cc
[
"
mozilla
.
org
/
embedcomp
/
prompt
-
service
;
1
"
]
.
getService
(
Ci
.
nsIPromptService
)
;
let
bundle
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
browser
/
locale
/
safebrowsing
/
safebrowsing
.
properties
"
)
;
promptService
.
alert
(
window
bundle
.
GetStringFromName
(
"
errorReportFalseDeceptiveTitle
"
)
bundle
.
formatStringFromName
(
"
errorReportFalseDeceptiveMessage
"
[
message
.
data
.
blockedInfo
.
provider
]
1
)
)
;
}
}
mm
.
addMessageListener
(
"
DeceptiveBlockedDetails
:
Result
"
onMessage
)
;
mm
.
sendAsyncMessage
(
"
DeceptiveBlockedDetails
"
)
;
}
}
function
formatURL
(
aFormat
aIsPref
)
{
var
formatter
=
Cc
[
"
mozilla
.
org
/
toolkit
/
URLFormatterService
;
1
"
]
.
getService
(
Ci
.
nsIURLFormatter
)
;
return
aIsPref
?
formatter
.
formatURLPref
(
aFormat
)
:
formatter
.
formatURL
(
aFormat
)
;
}
var
gIdentityHandler
=
{
_uri
:
null
_uriHasHost
:
false
_isExtensionPage
:
false
_isSecureInternalUI
:
false
_sslStatus
:
null
_state
:
0
_popupTriggeredByKeyboard
:
false
_secureInternalUIWhitelist
:
/
^
(
?
:
accounts
|
addons
|
cache
|
config
|
crashes
|
customizing
|
downloads
|
healthreport
|
home
|
license
|
newaddon
|
permissions
|
preferences
|
privatebrowsing
|
rights
|
searchreset
|
sessionrestore
|
support
|
welcomeback
)
(
?
:
[
?
#
]
|
)
/
i
get
_isBroken
(
)
{
return
this
.
_state
&
Ci
.
nsIWebProgressListener
.
STATE_IS_BROKEN
;
}
get
_isSecure
(
)
{
return
!
this
.
_isURILoadedFromFile
&
&
this
.
_state
&
Ci
.
nsIWebProgressListener
.
STATE_IS_SECURE
;
}
get
_isEV
(
)
{
return
!
this
.
_isURILoadedFromFile
&
&
this
.
_state
&
Ci
.
nsIWebProgressListener
.
STATE_IDENTITY_EV_TOPLEVEL
;
}
get
_isMixedActiveContentLoaded
(
)
{
return
this
.
_state
&
Ci
.
nsIWebProgressListener
.
STATE_LOADED_MIXED_ACTIVE_CONTENT
;
}
get
_isMixedActiveContentBlocked
(
)
{
return
this
.
_state
&
Ci
.
nsIWebProgressListener
.
STATE_BLOCKED_MIXED_ACTIVE_CONTENT
;
}
get
_isMixedPassiveContentLoaded
(
)
{
return
this
.
_state
&
Ci
.
nsIWebProgressListener
.
STATE_LOADED_MIXED_DISPLAY_CONTENT
;
}
get
_isCertUserOverridden
(
)
{
return
this
.
_state
&
Ci
.
nsIWebProgressListener
.
STATE_CERT_USER_OVERRIDDEN
;
}
get
_hasInsecureLoginForms
(
)
{
return
LoginManagerParent
.
hasInsecureLoginForms
(
gBrowser
.
selectedBrowser
)
&
&
Services
.
prefs
.
getBoolPref
(
"
security
.
insecure_password
.
ui
.
enabled
"
)
;
}
get
_identityPopup
(
)
{
delete
this
.
_identityPopup
;
return
this
.
_identityPopup
=
document
.
getElementById
(
"
identity
-
popup
"
)
;
}
get
_identityBox
(
)
{
delete
this
.
_identityBox
;
return
this
.
_identityBox
=
document
.
getElementById
(
"
identity
-
box
"
)
;
}
get
_identityPopupMultiView
(
)
{
delete
this
.
_identityPopupMultiView
;
return
this
.
_identityPopupMultiView
=
document
.
getElementById
(
"
identity
-
popup
-
multiView
"
)
;
}
get
_identityPopupContentHosts
(
)
{
delete
this
.
_identityPopupContentHosts
;
let
selector
=
"
.
identity
-
popup
-
host
"
;
return
this
.
_identityPopupContentHosts
=
[
.
.
.
this
.
_identityPopupMultiView
.
_mainView
.
querySelectorAll
(
selector
)
.
.
.
document
.
querySelectorAll
(
selector
)
]
;
}
get
_identityPopupContentHostless
(
)
{
delete
this
.
_identityPopupContentHostless
;
let
selector
=
"
.
identity
-
popup
-
hostless
"
;
return
this
.
_identityPopupContentHostless
=
[
.
.
.
this
.
_identityPopupMultiView
.
_mainView
.
querySelectorAll
(
selector
)
.
.
.
document
.
querySelectorAll
(
selector
)
]
;
}
get
_identityPopupContentOwner
(
)
{
delete
this
.
_identityPopupContentOwner
;
return
this
.
_identityPopupContentOwner
=
document
.
getElementById
(
"
identity
-
popup
-
content
-
owner
"
)
;
}
get
_identityPopupContentSupp
(
)
{
delete
this
.
_identityPopupContentSupp
;
return
this
.
_identityPopupContentSupp
=
document
.
getElementById
(
"
identity
-
popup
-
content
-
supplemental
"
)
;
}
get
_identityPopupContentVerif
(
)
{
delete
this
.
_identityPopupContentVerif
;
return
this
.
_identityPopupContentVerif
=
document
.
getElementById
(
"
identity
-
popup
-
content
-
verifier
"
)
;
}
get
_identityPopupMixedContentLearnMore
(
)
{
delete
this
.
_identityPopupMixedContentLearnMore
;
return
this
.
_identityPopupMixedContentLearnMore
=
document
.
getElementById
(
"
identity
-
popup
-
mcb
-
learn
-
more
"
)
;
}
get
_identityPopupInsecureLoginFormsLearnMore
(
)
{
delete
this
.
_identityPopupInsecureLoginFormsLearnMore
;
return
this
.
_identityPopupInsecureLoginFormsLearnMore
=
document
.
getElementById
(
"
identity
-
popup
-
insecure
-
login
-
forms
-
learn
-
more
"
)
;
}
get
_identityIconLabels
(
)
{
delete
this
.
_identityIconLabels
;
return
this
.
_identityIconLabels
=
document
.
getElementById
(
"
identity
-
icon
-
labels
"
)
;
}
get
_identityIconLabel
(
)
{
delete
this
.
_identityIconLabel
;
return
this
.
_identityIconLabel
=
document
.
getElementById
(
"
identity
-
icon
-
label
"
)
;
}
get
_connectionIcon
(
)
{
delete
this
.
_connectionIcon
;
return
this
.
_connectionIcon
=
document
.
getElementById
(
"
connection
-
icon
"
)
;
}
get
_extensionIcon
(
)
{
delete
this
.
_extensionIcon
;
return
this
.
_extensionIcon
=
document
.
getElementById
(
"
extension
-
icon
"
)
;
}
get
_overrideService
(
)
{
delete
this
.
_overrideService
;
return
this
.
_overrideService
=
Cc
[
"
mozilla
.
org
/
security
/
certoverride
;
1
"
]
.
getService
(
Ci
.
nsICertOverrideService
)
;
}
get
_identityIconCountryLabel
(
)
{
delete
this
.
_identityIconCountryLabel
;
return
this
.
_identityIconCountryLabel
=
document
.
getElementById
(
"
identity
-
icon
-
country
-
label
"
)
;
}
get
_identityIcon
(
)
{
delete
this
.
_identityIcon
;
return
this
.
_identityIcon
=
document
.
getElementById
(
"
identity
-
icon
"
)
;
}
get
_permissionList
(
)
{
delete
this
.
_permissionList
;
return
this
.
_permissionList
=
document
.
getElementById
(
"
identity
-
popup
-
permission
-
list
"
)
;
}
get
_permissionEmptyHint
(
)
{
delete
this
.
_permissionEmptyHint
;
return
this
.
_permissionEmptyHint
=
document
.
getElementById
(
"
identity
-
popup
-
permission
-
empty
-
hint
"
)
;
}
get
_permissionReloadHint
(
)
{
delete
this
.
_permissionReloadHint
;
return
this
.
_permissionReloadHint
=
document
.
getElementById
(
"
identity
-
popup
-
permission
-
reload
-
hint
"
)
;
}
get
_popupExpander
(
)
{
delete
this
.
_popupExpander
;
return
this
.
_popupExpander
=
document
.
getElementById
(
"
identity
-
popup
-
security
-
expander
"
)
;
}
get
_permissionAnchors
(
)
{
delete
this
.
_permissionAnchors
;
let
permissionAnchors
=
{
}
;
for
(
let
anchor
of
document
.
getElementById
(
"
blocked
-
permissions
-
container
"
)
.
children
)
{
permissionAnchors
[
anchor
.
getAttribute
(
"
data
-
permission
-
id
"
)
]
=
anchor
;
}
return
this
.
_permissionAnchors
=
permissionAnchors
;
}
handleMoreInfoClick
(
event
)
{
displaySecurityInfo
(
)
;
event
.
stopPropagation
(
)
;
this
.
_identityPopup
.
hidePopup
(
)
;
}
toggleSubView
(
name
anchor
)
{
let
view
=
this
.
_identityPopupMultiView
;
let
id
=
identity
-
popup
-
{
name
}
View
;
let
subView
=
document
.
getElementById
(
id
)
;
subView
.
addEventListener
(
"
ViewShowing
"
this
)
;
subView
.
addEventListener
(
"
ViewHiding
"
this
)
;
if
(
view
.
showingSubView
)
{
view
.
showMainView
(
)
;
}
else
{
view
.
showSubView
(
id
anchor
)
;
}
if
(
Services
.
focus
.
focusedElement
!
=
anchor
)
{
Services
.
focus
.
clearFocus
(
window
)
;
}
}
disableMixedContentProtection
(
)
{
const
kMIXED_CONTENT_UNBLOCK_EVENT
=
2
;
let
histogram
=
Services
.
telemetry
.
getHistogramById
(
"
MIXED_CONTENT_UNBLOCK_COUNTER
"
)
;
histogram
.
add
(
kMIXED_CONTENT_UNBLOCK_EVENT
)
;
BrowserReloadWithFlags
(
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_ALLOW_MIXED_CONTENT
)
;
this
.
_identityPopup
.
hidePopup
(
)
;
}
enableMixedContentProtection
(
)
{
gBrowser
.
selectedBrowser
.
messageManager
.
sendAsyncMessage
(
"
MixedContent
:
ReenableProtection
"
{
}
)
;
BrowserReload
(
)
;
this
.
_identityPopup
.
hidePopup
(
)
;
}
removeCertException
(
)
{
if
(
!
this
.
_uriHasHost
)
{
Cu
.
reportError
(
"
Trying
to
revoke
a
cert
exception
on
a
URI
without
a
host
?
"
)
;
return
;
}
let
host
=
this
.
_uri
.
host
;
let
port
=
this
.
_uri
.
port
>
0
?
this
.
_uri
.
port
:
443
;
this
.
_overrideService
.
clearValidityOverride
(
host
port
)
;
BrowserReloadSkipCache
(
)
;
this
.
_identityPopup
.
hidePopup
(
)
;
}
getIdentityData
(
)
{
var
result
=
{
}
;
var
cert
=
this
.
_sslStatus
.
serverCert
;
result
.
subjectOrg
=
cert
.
organization
;
if
(
cert
.
subjectName
)
{
result
.
subjectNameFields
=
{
}
;
cert
.
subjectName
.
split
(
"
"
)
.
forEach
(
function
(
v
)
{
var
field
=
v
.
split
(
"
=
"
)
;
this
[
field
[
0
]
]
=
field
[
1
]
;
}
result
.
subjectNameFields
)
;
result
.
city
=
result
.
subjectNameFields
.
L
;
result
.
state
=
result
.
subjectNameFields
.
ST
;
result
.
country
=
result
.
subjectNameFields
.
C
;
}
result
.
caOrg
=
cert
.
issuerOrganization
|
|
cert
.
issuerCommonName
;
result
.
cert
=
cert
;
return
result
;
}
updateIdentity
(
state
uri
)
{
let
shouldHidePopup
=
this
.
_uri
&
&
(
this
.
_uri
.
spec
!
=
uri
.
spec
)
;
this
.
_state
=
state
;
this
.
setURI
(
uri
)
;
this
.
_sslStatus
=
gBrowser
.
securityUI
.
QueryInterface
(
Ci
.
nsISSLStatusProvider
)
.
SSLStatus
;
if
(
this
.
_sslStatus
)
{
this
.
_sslStatus
.
QueryInterface
(
Ci
.
nsISSLStatus
)
;
}
this
.
refreshIdentityBlock
(
)
;
if
(
shouldHidePopup
)
{
this
.
_identityPopup
.
hidePopup
(
)
;
}
}
refreshForInsecureLoginForms
(
)
{
if
(
!
this
.
_uri
)
{
return
;
}
this
.
refreshIdentityBlock
(
)
;
}
updateSharingIndicator
(
)
{
let
tab
=
gBrowser
.
selectedTab
;
let
sharing
=
tab
.
getAttribute
(
"
sharing
"
)
;
if
(
sharing
)
this
.
_identityBox
.
setAttribute
(
"
sharing
"
sharing
)
;
else
this
.
_identityBox
.
removeAttribute
(
"
sharing
"
)
;
this
.
_sharingState
=
tab
.
_sharingState
;
if
(
this
.
_identityPopup
.
state
=
=
"
open
"
)
{
this
.
updateSitePermissions
(
)
;
this
.
_identityPopupMultiView
.
descriptionHeightWorkaround
(
)
;
}
}
getEffectiveHost
(
)
{
if
(
!
this
.
_IDNService
)
this
.
_IDNService
=
Cc
[
"
mozilla
.
org
/
network
/
idn
-
service
;
1
"
]
.
getService
(
Ci
.
nsIIDNService
)
;
try
{
return
this
.
_IDNService
.
convertToDisplayIDN
(
this
.
_uri
.
host
{
}
)
;
}
catch
(
e
)
{
return
this
.
_uri
.
host
;
}
}
get
pointerlockFsWarningClassName
(
)
{
if
(
this
.
_uriHasHost
&
&
this
.
_isEV
)
{
return
"
verifiedIdentity
"
;
}
if
(
this
.
_uriHasHost
&
&
this
.
_isSecure
)
{
return
"
verifiedDomain
"
;
}
return
"
unknownIdentity
"
;
}
refreshIdentityBlock
(
)
{
if
(
!
this
.
_identityBox
)
{
return
;
}
let
icon_label
=
"
"
;
let
tooltip
=
"
"
;
let
icon_country_label
=
"
"
;
let
icon_labels_dir
=
"
ltr
"
;
if
(
this
.
_isSecureInternalUI
)
{
this
.
_identityBox
.
className
=
"
chromeUI
"
;
let
brandBundle
=
document
.
getElementById
(
"
bundle_brand
"
)
;
icon_label
=
brandBundle
.
getString
(
"
brandShorterName
"
)
;
}
else
if
(
this
.
_uriHasHost
&
&
this
.
_isEV
)
{
this
.
_identityBox
.
className
=
"
verifiedIdentity
"
;
if
(
this
.
_isMixedActiveContentBlocked
)
{
this
.
_identityBox
.
classList
.
add
(
"
mixedActiveBlocked
"
)
;
}
if
(
!
this
.
_isCertUserOverridden
)
{
let
iData
=
this
.
getIdentityData
(
)
;
tooltip
=
gNavigatorBundle
.
getFormattedString
(
"
identity
.
identified
.
verifier
"
[
iData
.
caOrg
]
)
;
icon_label
=
iData
.
subjectOrg
;
if
(
iData
.
country
)
icon_country_label
=
"
(
"
+
iData
.
country
+
"
)
"
;
icon_labels_dir
=
/
^
[
\
u0590
-
\
u08ff
\
ufb1d
-
\
ufdff
\
ufe70
-
\
ufefc
]
/
.
test
(
icon_label
)
?
"
rtl
"
:
"
ltr
"
;
}
}
else
if
(
this
.
_isExtensionPage
)
{
this
.
_identityBox
.
className
=
"
extensionPage
"
;
let
extensionName
=
extensionNameFromURI
(
this
.
_uri
)
;
icon_label
=
gNavigatorBundle
.
getFormattedString
(
"
identity
.
extension
.
label
"
[
extensionName
]
)
;
}
else
if
(
this
.
_uriHasHost
&
&
this
.
_isSecure
)
{
this
.
_identityBox
.
className
=
"
verifiedDomain
"
;
if
(
this
.
_isMixedActiveContentBlocked
)
{
this
.
_identityBox
.
classList
.
add
(
"
mixedActiveBlocked
"
)
;
}
if
(
!
this
.
_isCertUserOverridden
)
{
tooltip
=
gNavigatorBundle
.
getFormattedString
(
"
identity
.
identified
.
verifier
"
[
this
.
getIdentityData
(
)
.
caOrg
]
)
;
}
}
else
{
this
.
_identityBox
.
className
=
"
unknownIdentity
"
;
if
(
this
.
_isBroken
)
{
if
(
this
.
_isMixedActiveContentLoaded
)
{
this
.
_identityBox
.
classList
.
add
(
"
mixedActiveContent
"
)
;
}
else
if
(
this
.
_isMixedActiveContentBlocked
)
{
this
.
_identityBox
.
classList
.
add
(
"
mixedDisplayContentLoadedActiveBlocked
"
)
;
}
else
if
(
this
.
_isMixedPassiveContentLoaded
)
{
this
.
_identityBox
.
classList
.
add
(
"
mixedDisplayContent
"
)
;
}
else
{
this
.
_identityBox
.
classList
.
add
(
"
weakCipher
"
)
;
}
}
if
(
this
.
_hasInsecureLoginForms
)
{
this
.
_identityBox
.
classList
.
add
(
"
insecureLoginForms
"
)
;
}
}
if
(
this
.
_isCertUserOverridden
)
{
this
.
_identityBox
.
classList
.
add
(
"
certUserOverridden
"
)
;
tooltip
=
gNavigatorBundle
.
getString
(
"
identity
.
identified
.
verified_by_you
"
)
;
}
let
permissionAnchors
=
this
.
_permissionAnchors
;
for
(
let
icon
of
Object
.
values
(
permissionAnchors
)
)
{
icon
.
removeAttribute
(
"
showing
"
)
;
}
let
hasGrantedPermissions
=
false
;
let
permissions
=
SitePermissions
.
getAllForBrowser
(
gBrowser
.
selectedBrowser
)
;
for
(
let
permission
of
permissions
)
{
if
(
permission
.
state
=
=
SitePermissions
.
BLOCK
)
{
let
icon
=
permissionAnchors
[
permission
.
id
]
;
if
(
icon
)
{
icon
.
setAttribute
(
"
showing
"
"
true
"
)
;
}
}
else
if
(
permission
.
state
!
=
SitePermissions
.
UNKNOWN
)
{
hasGrantedPermissions
=
true
;
}
}
if
(
hasGrantedPermissions
)
{
this
.
_identityBox
.
classList
.
add
(
"
grantedPermissions
"
)
;
}
this
.
_connectionIcon
.
tooltipText
=
tooltip
;
if
(
this
.
_isExtensionPage
)
{
let
extensionName
=
extensionNameFromURI
(
this
.
_uri
)
;
this
.
_extensionIcon
.
tooltipText
=
gNavigatorBundle
.
getFormattedString
(
"
identity
.
extension
.
tooltip
"
[
extensionName
]
)
;
}
this
.
_identityIconLabels
.
tooltipText
=
tooltip
;
this
.
_identityIcon
.
tooltipText
=
gNavigatorBundle
.
getString
(
"
identity
.
icon
.
tooltip
"
)
;
this
.
_identityIconLabel
.
value
=
icon_label
;
this
.
_identityIconCountryLabel
.
value
=
icon_country_label
;
this
.
_identityIconLabel
.
crop
=
icon_country_label
?
"
end
"
:
"
center
"
;
this
.
_identityIconLabel
.
parentNode
.
style
.
direction
=
icon_labels_dir
;
this
.
_identityIconLabel
.
parentNode
.
collapsed
=
!
icon_label
;
}
refreshIdentityPopup
(
)
{
let
baseURL
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
;
this
.
_identityPopupMixedContentLearnMore
.
setAttribute
(
"
href
"
baseURL
+
"
mixed
-
content
"
)
;
this
.
_identityPopupInsecureLoginFormsLearnMore
.
setAttribute
(
"
href
"
baseURL
+
"
insecure
-
password
"
)
;
this
.
_popupExpander
.
tooltipText
=
gNavigatorBundle
.
getString
(
"
identity
.
showDetails
.
tooltip
"
)
;
let
connection
=
"
not
-
secure
"
;
if
(
this
.
_isSecureInternalUI
)
{
connection
=
"
chrome
"
;
}
else
if
(
this
.
_isExtensionPage
)
{
connection
=
"
extension
"
;
}
else
if
(
this
.
_isURILoadedFromFile
)
{
connection
=
"
file
"
;
}
else
if
(
this
.
_isEV
)
{
connection
=
"
secure
-
ev
"
;
}
else
if
(
this
.
_isCertUserOverridden
)
{
connection
=
"
secure
-
cert
-
user
-
overridden
"
;
}
else
if
(
this
.
_isSecure
)
{
connection
=
"
secure
"
;
}
let
loginforms
=
"
secure
"
;
if
(
this
.
_hasInsecureLoginForms
)
{
loginforms
=
"
insecure
"
;
}
let
mixedcontent
=
[
]
;
if
(
this
.
_isMixedPassiveContentLoaded
)
{
mixedcontent
.
push
(
"
passive
-
loaded
"
)
;
}
if
(
this
.
_isMixedActiveContentLoaded
)
{
mixedcontent
.
push
(
"
active
-
loaded
"
)
;
}
else
if
(
this
.
_isMixedActiveContentBlocked
)
{
mixedcontent
.
push
(
"
active
-
blocked
"
)
;
}
mixedcontent
=
mixedcontent
.
join
(
"
"
)
;
let
ciphers
=
"
"
;
if
(
this
.
_isBroken
&
&
!
this
.
_isMixedActiveContentLoaded
&
&
!
this
.
_isMixedPassiveContentLoaded
)
{
ciphers
=
"
weak
"
;
}
let
elementIDs
=
[
"
identity
-
popup
"
"
identity
-
popup
-
securityView
-
body
"
]
;
function
updateAttribute
(
elem
attr
value
)
{
if
(
value
)
{
elem
.
setAttribute
(
attr
value
)
;
}
else
{
elem
.
removeAttribute
(
attr
)
;
}
}
for
(
let
id
of
elementIDs
)
{
let
element
=
document
.
getElementById
(
id
)
;
updateAttribute
(
element
"
connection
"
connection
)
;
updateAttribute
(
element
"
loginforms
"
loginforms
)
;
updateAttribute
(
element
"
ciphers
"
ciphers
)
;
updateAttribute
(
element
"
mixedcontent
"
mixedcontent
)
;
updateAttribute
(
element
"
isbroken
"
this
.
_isBroken
)
;
}
let
supplemental
=
"
"
;
let
verifier
=
"
"
;
let
host
=
"
"
;
let
owner
=
"
"
;
let
hostless
=
false
;
try
{
host
=
this
.
getEffectiveHost
(
)
;
}
catch
(
e
)
{
}
if
(
!
host
)
{
host
=
this
.
_uri
.
specIgnoringRef
;
hostless
=
true
;
}
if
(
this
.
_isExtensionPage
)
{
host
=
extensionNameFromURI
(
this
.
_uri
)
;
}
if
(
this
.
_isSecure
|
|
this
.
_isCertUserOverridden
)
{
verifier
=
this
.
_identityIconLabels
.
tooltipText
;
}
if
(
this
.
_isEV
)
{
let
iData
=
this
.
getIdentityData
(
)
;
host
=
owner
=
iData
.
subjectOrg
;
verifier
=
this
.
_identityIconLabels
.
tooltipText
;
if
(
iData
.
city
)
supplemental
+
=
iData
.
city
+
"
\
n
"
;
if
(
iData
.
state
&
&
iData
.
country
)
supplemental
+
=
gNavigatorBundle
.
getFormattedString
(
"
identity
.
identified
.
state_and_country
"
[
iData
.
state
iData
.
country
]
)
;
else
if
(
iData
.
state
)
supplemental
+
=
iData
.
state
;
else
if
(
iData
.
country
)
supplemental
+
=
iData
.
country
;
}
this
.
_identityPopupContentHosts
.
forEach
(
(
el
)
=
>
{
el
.
textContent
=
host
;
el
.
hidden
=
hostless
;
}
)
;
this
.
_identityPopupContentHostless
.
forEach
(
(
el
)
=
>
{
el
.
setAttribute
(
"
value
"
host
)
;
el
.
hidden
=
!
hostless
;
}
)
;
this
.
_identityPopupContentOwner
.
textContent
=
owner
;
this
.
_identityPopupContentSupp
.
textContent
=
supplemental
;
this
.
_identityPopupContentVerif
.
textContent
=
verifier
;
this
.
updateSitePermissions
(
)
;
}
setURI
(
uri
)
{
if
(
this
.
_ignoreAboutBlankUntilFirstLoad
)
{
if
(
uri
.
spec
=
=
"
about
:
blank
"
)
return
;
this
.
_ignoreAboutBlankUntilFirstLoad
=
false
;
}
this
.
_uri
=
uri
;
try
{
this
.
_uri
.
host
;
this
.
_uriHasHost
=
true
;
}
catch
(
ex
)
{
this
.
_uriHasHost
=
false
;
}
this
.
_isSecureInternalUI
=
uri
.
schemeIs
(
"
about
"
)
&
&
this
.
_secureInternalUIWhitelist
.
test
(
uri
.
pathQueryRef
)
;
this
.
_isExtensionPage
=
uri
.
schemeIs
(
"
moz
-
extension
"
)
;
this
.
_isURILoadedFromFile
=
false
;
let
chanOptions
=
{
uri
:
this
.
_uri
loadUsingSystemPrincipal
:
true
}
;
let
resolvedURI
;
try
{
resolvedURI
=
NetUtil
.
newChannel
(
chanOptions
)
.
URI
;
if
(
resolvedURI
.
schemeIs
(
"
jar
"
)
)
{
resolvedURI
=
NetUtil
.
newURI
(
resolvedURI
.
pathQueryRef
)
;
}
this
.
_isURILoadedFromFile
=
resolvedURI
.
schemeIs
(
"
file
"
)
;
}
catch
(
ex
)
{
}
}
initIdentityBlock
(
initialURI
)
{
if
(
(
typeof
initialURI
!
=
"
string
"
)
|
|
!
initialURI
.
startsWith
(
"
about
:
"
)
)
return
;
let
uri
=
Services
.
io
.
newURI
(
initialURI
)
;
if
(
this
.
_secureInternalUIWhitelist
.
test
(
uri
.
pathQueryRef
)
)
{
this
.
_isSecureInternalUI
=
true
;
this
.
_ignoreAboutBlankUntilFirstLoad
=
true
;
this
.
refreshIdentityBlock
(
)
;
gURLBar
.
setAttribute
(
"
pageproxystate
"
"
valid
"
)
;
}
}
handleIdentityButtonEvent
(
event
)
{
event
.
stopPropagation
(
)
;
if
(
(
event
.
type
=
=
"
click
"
&
&
event
.
button
!
=
0
)
|
|
(
event
.
type
=
=
"
keypress
"
&
&
event
.
charCode
!
=
KeyEvent
.
DOM_VK_SPACE
&
&
event
.
keyCode
!
=
KeyEvent
.
DOM_VK_RETURN
)
)
{
return
;
}
if
(
!
this
.
_sharingState
&
&
gURLBar
.
getAttribute
(
"
pageproxystate
"
)
!
=
"
valid
"
)
{
return
;
}
this
.
_popupTriggeredByKeyboard
=
event
.
type
=
=
"
keypress
"
;
this
.
_identityPopup
.
hidden
=
false
;
this
.
_permissionReloadHint
.
setAttribute
(
"
hidden
"
"
true
"
)
;
this
.
refreshIdentityPopup
(
)
;
this
.
_identityBox
.
setAttribute
(
"
open
"
"
true
"
)
;
this
.
_identityPopup
.
openPopup
(
this
.
_identityIcon
"
bottomcenter
topleft
"
)
;
}
onPopupShown
(
event
)
{
if
(
event
.
target
=
=
this
.
_identityPopup
)
{
if
(
this
.
_popupTriggeredByKeyboard
)
{
document
.
commandDispatcher
.
advanceFocusIntoSubtree
(
this
.
_identityPopup
)
;
}
window
.
addEventListener
(
"
focus
"
this
true
)
;
}
}
onPopupHidden
(
event
)
{
if
(
event
.
target
=
=
this
.
_identityPopup
)
{
window
.
removeEventListener
(
"
focus
"
this
true
)
;
this
.
_identityBox
.
removeAttribute
(
"
open
"
)
;
}
}
handleEvent
(
event
)
{
if
(
event
.
type
=
=
"
ViewShowing
"
)
{
this
.
_popupExpander
.
tooltipText
=
gNavigatorBundle
.
getString
(
"
identity
.
hideDetails
.
tooltip
"
)
;
return
;
}
if
(
event
.
type
=
=
"
ViewHiding
"
)
{
this
.
_popupExpander
.
tooltipText
=
gNavigatorBundle
.
getString
(
"
identity
.
showDetails
.
tooltip
"
)
;
return
;
}
let
elem
=
document
.
activeElement
;
let
position
=
elem
.
compareDocumentPosition
(
this
.
_identityPopup
)
;
if
(
!
(
position
&
(
Node
.
DOCUMENT_POSITION_CONTAINS
|
Node
.
DOCUMENT_POSITION_CONTAINED_BY
)
)
&
&
!
this
.
_identityPopup
.
hasAttribute
(
"
noautohide
"
)
)
{
this
.
_identityPopup
.
hidePopup
(
)
;
}
}
observe
(
subject
topic
data
)
{
if
(
topic
=
=
"
perm
-
changed
"
)
{
this
.
refreshIdentityBlock
(
)
;
}
}
onDragStart
(
event
)
{
if
(
gURLBar
.
getAttribute
(
"
pageproxystate
"
)
!
=
"
valid
"
)
return
;
let
value
=
gBrowser
.
currentURI
.
displaySpec
;
let
urlString
=
value
+
"
\
n
"
+
gBrowser
.
contentTitle
;
let
htmlString
=
"
<
a
href
=
\
"
"
+
value
+
"
\
"
>
"
+
value
+
"
<
/
a
>
"
;
let
dt
=
event
.
dataTransfer
;
dt
.
setData
(
"
text
/
x
-
moz
-
url
"
urlString
)
;
dt
.
setData
(
"
text
/
uri
-
list
"
value
)
;
dt
.
setData
(
"
text
/
plain
"
value
)
;
dt
.
setData
(
"
text
/
html
"
htmlString
)
;
dt
.
setDragImage
(
this
.
_identityIcon
16
16
)
;
}
onLocationChange
(
)
{
this
.
_permissionReloadHint
.
setAttribute
(
"
hidden
"
"
true
"
)
;
if
(
!
this
.
_permissionList
.
hasChildNodes
(
)
)
{
this
.
_permissionEmptyHint
.
removeAttribute
(
"
hidden
"
)
;
}
}
updateSitePermissions
(
)
{
while
(
this
.
_permissionList
.
hasChildNodes
(
)
)
this
.
_permissionList
.
removeChild
(
this
.
_permissionList
.
lastChild
)
;
let
permissions
=
SitePermissions
.
getAllPermissionDetailsForBrowser
(
gBrowser
.
selectedBrowser
)
;
if
(
this
.
_sharingState
)
{
for
(
let
id
of
[
"
camera
"
"
microphone
"
"
screen
"
]
)
{
if
(
this
.
_sharingState
[
id
]
)
{
let
found
=
false
;
for
(
let
permission
of
permissions
)
{
if
(
permission
.
id
!
=
id
)
continue
;
found
=
true
;
permission
.
inUse
=
true
;
break
;
}
if
(
!
found
)
{
permissions
.
push
(
{
id
state
:
SitePermissions
.
ALLOW
scope
:
SitePermissions
.
SCOPE_REQUEST
inUse
:
true
}
)
;
}
}
}
}
for
(
let
permission
of
permissions
)
{
let
item
=
this
.
_createPermissionItem
(
permission
)
;
this
.
_permissionList
.
appendChild
(
item
)
;
}
if
(
!
this
.
_permissionList
.
hasChildNodes
(
)
&
&
this
.
_permissionReloadHint
.
hasAttribute
(
"
hidden
"
)
)
{
this
.
_permissionEmptyHint
.
removeAttribute
(
"
hidden
"
)
;
}
else
{
this
.
_permissionEmptyHint
.
setAttribute
(
"
hidden
"
"
true
"
)
;
}
}
_createPermissionItem
(
aPermission
)
{
let
container
=
document
.
createElement
(
"
hbox
"
)
;
container
.
setAttribute
(
"
class
"
"
identity
-
popup
-
permission
-
item
"
)
;
container
.
setAttribute
(
"
align
"
"
center
"
)
;
let
img
=
document
.
createElement
(
"
image
"
)
;
let
classes
=
"
identity
-
popup
-
permission
-
icon
"
+
aPermission
.
id
+
"
-
icon
"
;
if
(
aPermission
.
state
=
=
SitePermissions
.
BLOCK
)
classes
+
=
"
blocked
-
permission
-
icon
"
;
if
(
aPermission
.
inUse
)
classes
+
=
"
in
-
use
"
;
img
.
setAttribute
(
"
class
"
classes
)
;
let
nameLabel
=
document
.
createElement
(
"
label
"
)
;
nameLabel
.
setAttribute
(
"
flex
"
"
1
"
)
;
nameLabel
.
setAttribute
(
"
class
"
"
identity
-
popup
-
permission
-
label
"
)
;
nameLabel
.
textContent
=
SitePermissions
.
getPermissionLabel
(
aPermission
.
id
)
;
let
stateLabel
=
document
.
createElement
(
"
label
"
)
;
stateLabel
.
setAttribute
(
"
flex
"
"
1
"
)
;
stateLabel
.
setAttribute
(
"
class
"
"
identity
-
popup
-
permission
-
state
-
label
"
)
;
let
{
state
scope
}
=
aPermission
;
if
(
state
!
=
SitePermissions
.
ALLOW
&
&
aPermission
.
inUse
)
{
state
=
SitePermissions
.
ALLOW
;
scope
=
SitePermissions
.
SCOPE_REQUEST
;
}
stateLabel
.
textContent
=
SitePermissions
.
getCurrentStateLabel
(
state
scope
)
;
let
button
=
document
.
createElement
(
"
button
"
)
;
button
.
setAttribute
(
"
class
"
"
identity
-
popup
-
permission
-
remove
-
button
"
)
;
let
tooltiptext
=
gNavigatorBundle
.
getString
(
"
permissions
.
remove
.
tooltip
"
)
;
button
.
setAttribute
(
"
tooltiptext
"
tooltiptext
)
;
button
.
addEventListener
(
"
command
"
(
)
=
>
{
let
browser
=
gBrowser
.
selectedBrowser
;
this
.
_permissionList
.
removeChild
(
container
)
;
if
(
aPermission
.
inUse
&
&
[
"
camera
"
"
microphone
"
"
screen
"
]
.
includes
(
aPermission
.
id
)
)
{
let
windowId
=
this
.
_sharingState
.
windowId
;
if
(
aPermission
.
id
=
=
"
screen
"
)
{
windowId
=
"
screen
:
"
+
windowId
;
}
else
{
let
uris
=
browser
.
_devicePermissionURIs
|
|
[
]
;
for
(
let
uri
of
uris
)
{
for
(
let
id
of
[
"
camera
"
"
microphone
"
]
)
{
if
(
this
.
_sharingState
[
id
]
)
{
let
perm
=
SitePermissions
.
get
(
uri
id
)
;
if
(
perm
.
state
=
=
SitePermissions
.
ALLOW
&
&
perm
.
scope
=
=
SitePermissions
.
SCOPE_PERSISTENT
)
{
SitePermissions
.
remove
(
uri
id
)
;
}
}
}
}
}
browser
.
messageManager
.
sendAsyncMessage
(
"
webrtc
:
StopSharing
"
windowId
)
;
webrtcUI
.
forgetActivePermissionsFromBrowser
(
gBrowser
.
selectedBrowser
)
;
}
SitePermissions
.
remove
(
gBrowser
.
currentURI
aPermission
.
id
browser
)
;
this
.
_permissionReloadHint
.
removeAttribute
(
"
hidden
"
)
;
this
.
_identityPopupMultiView
.
descriptionHeightWorkaround
(
)
;
let
histogram
=
Services
.
telemetry
.
getKeyedHistogramById
(
"
WEB_PERMISSION_CLEARED
"
)
;
let
permissionType
=
0
;
if
(
aPermission
.
state
=
=
SitePermissions
.
ALLOW
&
&
aPermission
.
scope
=
=
SitePermissions
.
SCOPE_PERSISTENT
)
{
permissionType
=
1
;
}
else
if
(
aPermission
.
state
=
=
SitePermissions
.
BLOCK
&
&
aPermission
.
scope
=
=
SitePermissions
.
SCOPE_PERSISTENT
)
{
permissionType
=
2
;
}
else
if
(
aPermission
.
state
=
=
SitePermissions
.
ALLOW
)
{
permissionType
=
3
;
}
else
if
(
aPermission
.
state
=
=
SitePermissions
.
BLOCK
)
{
permissionType
=
4
;
}
histogram
.
add
(
"
(
all
)
"
permissionType
)
;
histogram
.
add
(
aPermission
.
id
permissionType
)
;
}
)
;
container
.
appendChild
(
img
)
;
container
.
appendChild
(
nameLabel
)
;
container
.
appendChild
(
stateLabel
)
;
container
.
appendChild
(
button
)
;
return
container
;
}
}
;
const
gRemoteControl
=
{
observe
(
subject
topic
data
)
{
gRemoteControl
.
updateVisualCue
(
data
)
;
}
updateVisualCue
(
enabled
)
{
const
mainWindow
=
document
.
documentElement
;
if
(
enabled
)
{
mainWindow
.
setAttribute
(
"
remotecontrol
"
"
true
"
)
;
}
else
{
mainWindow
.
removeAttribute
(
"
remotecontrol
"
)
;
}
}
}
;
function
getNotificationBox
(
aWindow
)
{
var
foundBrowser
=
gBrowser
.
getBrowserForDocument
(
aWindow
.
document
)
;
if
(
foundBrowser
)
return
gBrowser
.
getNotificationBox
(
foundBrowser
)
return
null
;
}
function
getTabModalPromptBox
(
aWindow
)
{
var
foundBrowser
=
gBrowser
.
getBrowserForDocument
(
aWindow
.
document
)
;
if
(
foundBrowser
)
return
gBrowser
.
getTabModalPromptBox
(
foundBrowser
)
;
return
null
;
}
function
getBrowser
(
)
{
return
gBrowser
;
}
var
gPrivateBrowsingUI
=
{
init
:
function
PBUI_init
(
)
{
if
(
!
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
{
return
;
}
document
.
getElementById
(
"
Tools
:
Sanitize
"
)
.
setAttribute
(
"
disabled
"
"
true
"
)
;
if
(
window
.
location
.
href
=
=
getBrowserURL
(
)
)
{
let
docElement
=
document
.
documentElement
;
if
(
!
PrivateBrowsingUtils
.
permanentPrivateBrowsing
)
{
docElement
.
setAttribute
(
"
title
"
docElement
.
getAttribute
(
"
title_privatebrowsing
"
)
)
;
docElement
.
setAttribute
(
"
titlemodifier
"
docElement
.
getAttribute
(
"
titlemodifier_privatebrowsing
"
)
)
;
}
docElement
.
setAttribute
(
"
privatebrowsingmode
"
PrivateBrowsingUtils
.
permanentPrivateBrowsing
?
"
permanent
"
:
"
temporary
"
)
;
gBrowser
.
updateTitlebar
(
)
;
if
(
PrivateBrowsingUtils
.
permanentPrivateBrowsing
)
{
[
{
normal
:
"
menu_newNavigator
"
private
:
"
menu_newPrivateWindow
"
}
]
.
forEach
(
function
(
menu
)
{
let
newWindow
=
document
.
getElementById
(
menu
.
normal
)
;
let
newPrivateWindow
=
document
.
getElementById
(
menu
.
private
)
;
if
(
newWindow
&
&
newPrivateWindow
)
{
newPrivateWindow
.
hidden
=
true
;
newWindow
.
label
=
newPrivateWindow
.
label
;
newWindow
.
accessKey
=
newPrivateWindow
.
accessKey
;
newWindow
.
command
=
newPrivateWindow
.
command
;
}
}
)
;
}
}
let
urlBarSearchParam
=
gURLBar
.
getAttribute
(
"
autocompletesearchparam
"
)
|
|
"
"
;
if
(
!
PrivateBrowsingUtils
.
permanentPrivateBrowsing
&
&
!
urlBarSearchParam
.
includes
(
"
disable
-
private
-
actions
"
)
)
{
urlBarSearchParam
+
=
"
disable
-
private
-
actions
"
;
}
if
(
!
urlBarSearchParam
.
includes
(
"
private
-
window
"
)
)
{
urlBarSearchParam
+
=
"
private
-
window
"
;
}
gURLBar
.
setAttribute
(
"
autocompletesearchparam
"
urlBarSearchParam
)
;
}
}
;
var
gRemoteTabsUI
=
{
init
(
)
{
if
(
window
.
location
.
href
!
=
getBrowserURL
(
)
&
&
window
.
location
.
href
!
=
"
chrome
:
/
/
browser
/
content
/
hiddenWindow
.
xul
"
)
{
return
;
}
if
(
AppConstants
.
platform
=
=
"
macosx
"
&
&
Services
.
prefs
.
getBoolPref
(
"
layers
.
acceleration
.
disabled
"
)
)
{
return
;
}
let
newNonRemoteWindow
=
document
.
getElementById
(
"
menu_newNonRemoteWindow
"
)
;
let
autostart
=
Services
.
appinfo
.
browserTabsRemoteAutostart
;
newNonRemoteWindow
.
hidden
=
!
autostart
;
}
}
;
function
switchToTabHavingURI
(
aURI
aOpenNew
aOpenParams
=
{
}
)
{
const
kPrivateBrowsingWhitelist
=
new
Set
(
[
"
about
:
addons
"
]
)
;
let
ignoreFragment
=
aOpenParams
.
ignoreFragment
;
let
ignoreQueryString
=
aOpenParams
.
ignoreQueryString
;
let
replaceQueryString
=
aOpenParams
.
replaceQueryString
;
delete
aOpenParams
.
ignoreFragment
;
delete
aOpenParams
.
ignoreQueryString
;
delete
aOpenParams
.
replaceQueryString
;
function
switchIfURIInWindow
(
aWindow
)
{
if
(
!
kPrivateBrowsingWhitelist
.
has
(
aURI
.
spec
)
&
&
(
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
|
|
PrivateBrowsingUtils
.
isWindowPrivate
(
aWindow
)
)
&
&
!
PrivateBrowsingUtils
.
permanentPrivateBrowsing
)
{
return
false
;
}
function
cleanURL
(
url
removeQuery
removeFragment
)
{
let
ret
=
url
;
if
(
removeFragment
)
{
ret
=
ret
.
split
(
"
#
"
)
[
0
]
;
if
(
removeQuery
)
{
ret
=
ret
.
split
(
"
?
"
)
[
0
]
;
}
}
else
if
(
removeQuery
)
{
let
fragment
=
ret
.
split
(
"
#
"
)
[
1
]
;
ret
=
ret
.
split
(
"
?
"
)
[
0
]
.
concat
(
(
fragment
!
=
undefined
)
?
"
#
"
.
concat
(
fragment
)
:
"
"
)
;
}
return
ret
;
}
let
ignoreFragmentWhenComparing
=
typeof
ignoreFragment
=
=
"
string
"
&
&
ignoreFragment
.
startsWith
(
"
whenComparing
"
)
;
let
requestedCompare
=
cleanURL
(
aURI
.
displaySpec
ignoreQueryString
|
|
replaceQueryString
ignoreFragmentWhenComparing
)
;
let
browsers
=
aWindow
.
gBrowser
.
browsers
;
for
(
let
i
=
0
;
i
<
browsers
.
length
;
i
+
+
)
{
let
browser
=
browsers
[
i
]
;
let
browserCompare
=
cleanURL
(
browser
.
currentURI
.
displaySpec
ignoreQueryString
|
|
replaceQueryString
ignoreFragmentWhenComparing
)
;
if
(
requestedCompare
=
=
browserCompare
)
{
aWindow
.
focus
(
)
;
if
(
ignoreFragment
=
=
"
whenComparingAndReplace
"
|
|
replaceQueryString
)
{
browser
.
loadURI
(
aURI
.
spec
)
;
}
aWindow
.
gBrowser
.
tabContainer
.
selectedIndex
=
i
;
return
true
;
}
}
return
false
;
}
if
(
!
(
aURI
instanceof
Ci
.
nsIURI
)
)
aURI
=
Services
.
io
.
newURI
(
aURI
)
;
let
isBrowserWindow
=
!
!
window
.
gBrowser
;
if
(
isBrowserWindow
&
&
switchIfURIInWindow
(
window
)
)
return
true
;
for
(
let
browserWin
of
browserWindows
(
)
)
{
if
(
browserWin
.
closed
|
|
browserWin
=
=
window
)
continue
;
if
(
switchIfURIInWindow
(
browserWin
)
)
return
true
;
}
if
(
aOpenNew
)
{
if
(
isBrowserWindow
&
&
isTabEmpty
(
gBrowser
.
selectedTab
)
)
openUILinkIn
(
aURI
.
spec
"
current
"
aOpenParams
)
;
else
openUILinkIn
(
aURI
.
spec
"
tab
"
aOpenParams
)
;
}
return
false
;
}
var
RestoreLastSessionObserver
=
{
init
(
)
{
if
(
SessionStore
.
canRestoreLastSession
&
&
!
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
{
if
(
Services
.
prefs
.
getBoolPref
(
"
browser
.
tabs
.
restorebutton
"
)
)
{
let
{
restoreTabsButton
restoreTabsButtonWrapperWidth
}
=
gBrowser
.
tabContainer
;
let
restoreTabsButtonWrapper
=
restoreTabsButton
.
parentNode
;
restoreTabsButtonWrapper
.
setAttribute
(
"
session
-
exists
"
"
true
"
)
;
gBrowser
.
tabContainer
.
updateSessionRestoreVisibility
(
)
;
restoreTabsButton
.
style
.
maxWidth
=
{
restoreTabsButtonWrapperWidth
}
px
;
gBrowser
.
tabContainer
.
addEventListener
(
"
TabOpen
"
this
)
;
}
Services
.
obs
.
addObserver
(
this
"
sessionstore
-
last
-
session
-
cleared
"
true
)
;
goSetCommandEnabled
(
"
Browser
:
RestoreLastSession
"
true
)
;
}
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
TabOpen
"
:
this
.
removeRestoreButton
(
)
;
break
;
}
}
removeRestoreButton
(
)
{
let
{
restoreTabsButton
}
=
gBrowser
.
tabContainer
;
let
restoreTabsButtonWrapper
=
restoreTabsButton
.
parentNode
;
gBrowser
.
tabContainer
.
addEventListener
(
"
transitionend
"
function
maxWidthTransitionHandler
(
e
)
{
if
(
e
.
target
=
=
gBrowser
.
tabContainer
&
&
e
.
propertyName
=
=
"
max
-
width
"
)
{
gBrowser
.
tabContainer
.
updateSessionRestoreVisibility
(
)
;
gBrowser
.
tabContainer
.
removeEventListener
(
"
transitionend
"
maxWidthTransitionHandler
)
;
}
}
)
;
restoreTabsButtonWrapper
.
removeAttribute
(
"
session
-
exists
"
)
;
restoreTabsButton
.
style
.
maxWidth
=
0
;
gBrowser
.
tabContainer
.
removeEventListener
(
"
TabOpen
"
this
)
;
}
observe
(
)
{
Services
.
obs
.
removeObserver
(
this
"
sessionstore
-
last
-
session
-
cleared
"
)
;
goSetCommandEnabled
(
"
Browser
:
RestoreLastSession
"
false
)
;
this
.
removeRestoreButton
(
)
;
}
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIObserver
Ci
.
nsISupportsWeakReference
]
)
}
;
function
restoreLastSession
(
)
{
SessionStore
.
restoreLastSession
(
)
;
}
var
MenuTouchModeObserver
=
{
init
(
)
{
window
.
addEventListener
(
"
popupshowing
"
this
true
)
;
}
handleEvent
(
event
)
{
let
target
=
event
.
originalTarget
;
if
(
event
.
mozInputSource
=
=
MouseEvent
.
MOZ_SOURCE_TOUCH
)
{
target
.
setAttribute
(
"
touchmode
"
"
true
"
)
;
}
else
{
target
.
removeAttribute
(
"
touchmode
"
)
;
}
}
uninit
(
)
{
window
.
removeEventListener
(
"
popupshowing
"
this
true
)
;
}
}
;
var
TabContextMenu
=
{
contextTab
:
null
_updateToggleMuteMenuItem
(
aTab
aConditionFn
)
{
[
"
muted
"
"
soundplaying
"
]
.
forEach
(
attr
=
>
{
if
(
!
aConditionFn
|
|
aConditionFn
(
attr
)
)
{
if
(
aTab
.
hasAttribute
(
attr
)
)
{
aTab
.
toggleMuteMenuItem
.
setAttribute
(
attr
"
true
"
)
;
}
else
{
aTab
.
toggleMuteMenuItem
.
removeAttribute
(
attr
)
;
}
}
}
)
;
}
updateContextMenu
:
function
updateContextMenu
(
aPopupMenu
)
{
this
.
contextTab
=
aPopupMenu
.
triggerNode
.
localName
=
=
"
tab
"
?
aPopupMenu
.
triggerNode
:
gBrowser
.
selectedTab
;
let
disabled
=
gBrowser
.
tabs
.
length
=
=
1
;
var
menuItems
=
aPopupMenu
.
getElementsByAttribute
(
"
tbattr
"
"
tabbrowser
-
multiple
"
)
;
for
(
let
menuItem
of
menuItems
)
menuItem
.
disabled
=
disabled
;
if
(
this
.
contextTab
.
hasAttribute
(
"
customizemode
"
)
)
document
.
getElementById
(
"
context_openTabInWindow
"
)
.
disabled
=
true
;
if
(
AppConstants
.
E10S_TESTING_ONLY
)
{
menuItems
=
aPopupMenu
.
getElementsByAttribute
(
"
tbattr
"
"
tabbrowser
-
remote
"
)
;
for
(
let
menuItem
of
menuItems
)
{
menuItem
.
hidden
=
!
gMultiProcessBrowser
;
if
(
menuItem
.
id
=
=
"
context_openNonRemoteWindow
"
)
{
menuItem
.
disabled
=
!
!
parseInt
(
this
.
contextTab
.
getAttribute
(
"
usercontextid
"
)
)
;
}
}
}
disabled
=
gBrowser
.
visibleTabs
.
length
=
=
1
;
menuItems
=
aPopupMenu
.
getElementsByAttribute
(
"
tbattr
"
"
tabbrowser
-
multiple
-
visible
"
)
;
for
(
let
menuItem
of
menuItems
)
menuItem
.
disabled
=
disabled
;
document
.
getElementById
(
"
context_undoCloseTab
"
)
.
disabled
=
SessionStore
.
getClosedTabCount
(
window
)
=
=
0
;
document
.
getElementById
(
"
context_pinTab
"
)
.
hidden
=
this
.
contextTab
.
pinned
;
document
.
getElementById
(
"
context_unpinTab
"
)
.
hidden
=
!
this
.
contextTab
.
pinned
;
document
.
getElementById
(
"
context_closeTabsToTheEnd
"
)
.
disabled
=
gBrowser
.
getTabsToTheEndFrom
(
this
.
contextTab
)
.
length
=
=
0
;
document
.
getElementById
(
"
context_closeTabsToTheEnd
"
)
.
hidden
=
this
.
contextTab
.
pinned
;
let
unpinnedTabs
=
gBrowser
.
visibleTabs
.
length
-
gBrowser
.
_numPinnedTabs
;
document
.
getElementById
(
"
context_closeOtherTabs
"
)
.
disabled
=
unpinnedTabs
<
=
1
;
document
.
getElementById
(
"
context_closeOtherTabs
"
)
.
hidden
=
this
.
contextTab
.
pinned
;
let
bookmarkAllTabs
=
document
.
getElementById
(
"
context_bookmarkAllTabs
"
)
;
bookmarkAllTabs
.
hidden
=
this
.
contextTab
.
pinned
;
if
(
!
bookmarkAllTabs
.
hidden
)
PlacesCommandHook
.
updateBookmarkAllTabsCommand
(
)
;
let
toggleMute
=
document
.
getElementById
(
"
context_toggleMuteTab
"
)
;
if
(
this
.
contextTab
.
hasAttribute
(
"
activemedia
-
blocked
"
)
)
{
toggleMute
.
label
=
gNavigatorBundle
.
getString
(
"
playTab
.
label
"
)
;
toggleMute
.
accessKey
=
gNavigatorBundle
.
getString
(
"
playTab
.
accesskey
"
)
;
}
else
if
(
this
.
contextTab
.
hasAttribute
(
"
muted
"
)
)
{
toggleMute
.
label
=
gNavigatorBundle
.
getString
(
"
unmuteTab
.
label
"
)
;
toggleMute
.
accessKey
=
gNavigatorBundle
.
getString
(
"
unmuteTab
.
accesskey
"
)
;
}
else
{
toggleMute
.
label
=
gNavigatorBundle
.
getString
(
"
muteTab
.
label
"
)
;
toggleMute
.
accessKey
=
gNavigatorBundle
.
getString
(
"
muteTab
.
accesskey
"
)
;
}
this
.
contextTab
.
toggleMuteMenuItem
=
toggleMute
;
this
.
_updateToggleMuteMenuItem
(
this
.
contextTab
)
;
this
.
contextTab
.
addEventListener
(
"
TabAttrModified
"
this
)
;
aPopupMenu
.
addEventListener
(
"
popuphiding
"
this
)
;
gSync
.
updateTabContextMenu
(
aPopupMenu
this
.
contextTab
)
;
}
handleEvent
(
aEvent
)
{
switch
(
aEvent
.
type
)
{
case
"
popuphiding
"
:
gBrowser
.
removeEventListener
(
"
TabAttrModified
"
this
)
;
aEvent
.
target
.
removeEventListener
(
"
popuphiding
"
this
)
;
break
;
case
"
TabAttrModified
"
:
let
tab
=
aEvent
.
target
;
this
.
_updateToggleMuteMenuItem
(
tab
attr
=
>
aEvent
.
detail
.
changed
.
indexOf
(
attr
)
>
=
0
)
;
break
;
}
}
}
;
Object
.
defineProperty
(
this
"
HUDService
"
{
get
:
function
HUDService_getter
(
)
{
let
devtools
=
Cu
.
import
(
"
resource
:
/
/
devtools
/
shared
/
Loader
.
jsm
"
{
}
)
.
devtools
;
return
devtools
.
require
(
"
devtools
/
client
/
webconsole
/
hudservice
"
)
.
HUDService
;
}
configurable
:
true
enumerable
:
true
}
)
;
function
safeModeRestart
(
)
{
if
(
Services
.
appinfo
.
inSafeMode
)
{
let
cancelQuit
=
Cc
[
"
mozilla
.
org
/
supports
-
PRBool
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsPRBool
)
;
Services
.
obs
.
notifyObservers
(
cancelQuit
"
quit
-
application
-
requested
"
"
restart
"
)
;
if
(
cancelQuit
.
data
)
return
;
Services
.
startup
.
quit
(
Ci
.
nsIAppStartup
.
eRestart
|
Ci
.
nsIAppStartup
.
eAttemptQuit
)
;
return
;
}
Services
.
obs
.
notifyObservers
(
null
"
restart
-
in
-
safe
-
mode
"
)
;
}
function
duplicateTabIn
(
aTab
where
delta
)
{
switch
(
where
)
{
case
"
window
"
:
let
otherWin
=
OpenBrowserWindow
(
)
;
let
delayedStartupFinished
=
(
subject
topic
)
=
>
{
if
(
topic
=
=
"
browser
-
delayed
-
startup
-
finished
"
&
&
subject
=
=
otherWin
)
{
Services
.
obs
.
removeObserver
(
delayedStartupFinished
topic
)
;
let
otherGBrowser
=
otherWin
.
gBrowser
;
let
otherTab
=
otherGBrowser
.
selectedTab
;
SessionStore
.
duplicateTab
(
otherWin
aTab
delta
)
;
otherGBrowser
.
removeTab
(
otherTab
{
animate
:
false
}
)
;
}
}
;
Services
.
obs
.
addObserver
(
delayedStartupFinished
"
browser
-
delayed
-
startup
-
finished
"
)
;
break
;
case
"
tabshifted
"
:
SessionStore
.
duplicateTab
(
window
aTab
delta
)
;
break
;
case
"
tab
"
:
let
newTab
=
SessionStore
.
duplicateTab
(
window
aTab
delta
)
;
gBrowser
.
selectedTab
=
newTab
;
break
;
}
}
var
Scratchpad
=
{
openScratchpad
:
function
SP_openScratchpad
(
)
{
return
this
.
ScratchpadManager
.
openScratchpad
(
)
;
}
}
;
XPCOMUtils
.
defineLazyGetter
(
Scratchpad
"
ScratchpadManager
"
function
(
)
{
let
tmp
=
{
}
;
Cu
.
import
(
"
resource
:
/
/
devtools
/
client
/
scratchpad
/
scratchpad
-
manager
.
jsm
"
tmp
)
;
return
tmp
.
ScratchpadManager
;
}
)
;
var
ResponsiveUI
=
{
toggle
:
function
RUI_toggle
(
)
{
this
.
ResponsiveUIManager
.
toggle
(
window
gBrowser
.
selectedTab
)
;
}
}
;
XPCOMUtils
.
defineLazyGetter
(
ResponsiveUI
"
ResponsiveUIManager
"
function
(
)
{
let
tmp
=
{
}
;
Cu
.
import
(
"
resource
:
/
/
devtools
/
client
/
responsivedesign
/
responsivedesign
.
jsm
"
tmp
)
;
return
tmp
.
ResponsiveUIManager
;
}
)
;
var
MousePosTracker
=
{
_listeners
:
new
Set
(
)
_x
:
0
_y
:
0
get
_windowUtils
(
)
{
delete
this
.
_windowUtils
;
return
this
.
_windowUtils
=
window
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
}
addListener
(
listener
)
{
if
(
this
.
_listeners
.
has
(
listener
)
)
return
;
listener
.
_hover
=
false
;
this
.
_listeners
.
add
(
listener
)
;
this
.
_callListener
(
listener
)
;
}
removeListener
(
listener
)
{
this
.
_listeners
.
delete
(
listener
)
;
}
handleEvent
(
event
)
{
var
fullZoom
=
this
.
_windowUtils
.
fullZoom
;
this
.
_x
=
event
.
screenX
/
fullZoom
-
window
.
mozInnerScreenX
;
this
.
_y
=
event
.
screenY
/
fullZoom
-
window
.
mozInnerScreenY
;
this
.
_listeners
.
forEach
(
function
(
listener
)
{
try
{
this
.
_callListener
(
listener
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
this
)
;
}
_callListener
(
listener
)
{
let
rect
=
listener
.
getMouseTargetRect
(
)
;
let
hover
=
this
.
_x
>
=
rect
.
left
&
&
this
.
_x
<
=
rect
.
right
&
&
this
.
_y
>
=
rect
.
top
&
&
this
.
_y
<
=
rect
.
bottom
;
if
(
hover
=
=
listener
.
_hover
)
return
;
listener
.
_hover
=
hover
;
if
(
hover
)
{
if
(
listener
.
onMouseEnter
)
listener
.
onMouseEnter
(
)
;
}
else
if
(
listener
.
onMouseLeave
)
{
listener
.
onMouseLeave
(
)
;
}
}
}
;
var
ToolbarIconColor
=
{
_windowState
:
{
"
active
"
:
false
"
fullscreen
"
:
false
"
tabsintitlebar
"
:
false
}
init
(
)
{
this
.
_initialized
=
true
;
window
.
addEventListener
(
"
activate
"
this
)
;
window
.
addEventListener
(
"
deactivate
"
this
)
;
window
.
addEventListener
(
"
toolbarvisibilitychange
"
this
)
;
Services
.
obs
.
addObserver
(
this
"
lightweight
-
theme
-
styling
-
update
"
)
;
if
(
Services
.
focus
.
activeWindow
=
=
window
)
{
this
.
inferFromText
(
"
activate
"
)
;
}
}
uninit
(
)
{
this
.
_initialized
=
false
;
window
.
removeEventListener
(
"
activate
"
this
)
;
window
.
removeEventListener
(
"
deactivate
"
this
)
;
window
.
removeEventListener
(
"
toolbarvisibilitychange
"
this
)
;
Services
.
obs
.
removeObserver
(
this
"
lightweight
-
theme
-
styling
-
update
"
)
;
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
activate
"
:
case
"
deactivate
"
:
this
.
inferFromText
(
event
.
type
)
;
break
;
case
"
toolbarvisibilitychange
"
:
this
.
inferFromText
(
event
.
type
event
.
visible
)
;
break
;
}
}
observe
(
aSubject
aTopic
aData
)
{
switch
(
aTopic
)
{
case
"
lightweight
-
theme
-
styling
-
update
"
:
setTimeout
(
(
)
=
>
{
this
.
inferFromText
(
aTopic
)
;
}
0
)
;
break
;
}
}
_toolbarLuminanceCache
:
new
Map
(
)
inferFromText
(
reason
reasonValue
)
{
if
(
!
this
.
_initialized
)
return
;
function
parseRGB
(
aColorString
)
{
let
rgb
=
aColorString
.
match
(
/
^
rgba
?
\
(
(
\
d
+
)
(
\
d
+
)
(
\
d
+
)
/
)
;
rgb
.
shift
(
)
;
return
rgb
.
map
(
x
=
>
parseInt
(
x
)
)
;
}
switch
(
reason
)
{
case
"
activate
"
:
case
"
deactivate
"
:
this
.
_windowState
.
active
=
(
reason
=
=
=
"
activate
"
)
;
break
;
case
"
fullscreen
"
:
this
.
_windowState
.
fullscreen
=
reasonValue
;
break
;
case
"
lightweight
-
theme
-
styling
-
update
"
:
this
.
_toolbarLuminanceCache
.
clear
(
)
;
break
;
case
"
toolbarvisibilitychange
"
:
break
;
case
"
tabsintitlebar
"
:
this
.
_windowState
.
tabsintitlebar
=
reasonValue
;
break
;
}
let
toolbarSelector
=
"
#
navigator
-
toolbox
>
toolbar
:
not
(
[
collapsed
=
true
]
)
"
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
toolbarSelector
+
=
"
:
not
(
[
type
=
menubar
]
)
"
;
let
cachedLuminances
=
this
.
_toolbarLuminanceCache
;
let
luminances
=
new
Map
(
)
;
for
(
let
toolbar
of
document
.
querySelectorAll
(
toolbarSelector
)
)
{
let
cacheKey
=
toolbar
.
id
&
&
toolbar
.
id
+
JSON
.
stringify
(
this
.
_windowState
)
;
let
luminance
=
cacheKey
&
&
cachedLuminances
.
get
(
cacheKey
)
;
if
(
isNaN
(
luminance
)
)
{
let
[
r
g
b
]
=
parseRGB
(
getComputedStyle
(
toolbar
)
.
color
)
;
luminance
=
0
.
2125
*
r
+
0
.
7154
*
g
+
0
.
0721
*
b
;
if
(
cacheKey
)
{
cachedLuminances
.
set
(
cacheKey
luminance
)
;
}
}
luminances
.
set
(
toolbar
luminance
)
;
}
for
(
let
[
toolbar
luminance
]
of
luminances
)
{
if
(
luminance
<
=
110
)
toolbar
.
removeAttribute
(
"
brighttext
"
)
;
else
toolbar
.
setAttribute
(
"
brighttext
"
"
true
"
)
;
}
}
}
var
PanicButtonNotifier
=
{
init
(
)
{
this
.
_initialized
=
true
;
if
(
window
.
PanicButtonNotifierShouldNotify
)
{
delete
window
.
PanicButtonNotifierShouldNotify
;
this
.
notify
(
)
;
}
}
notify
(
)
{
if
(
!
this
.
_initialized
)
{
window
.
PanicButtonNotifierShouldNotify
=
true
;
return
;
}
try
{
let
popup
=
document
.
getElementById
(
"
panic
-
button
-
success
-
notification
"
)
;
popup
.
hidden
=
false
;
let
onTimeout
=
(
)
=
>
{
PanicButtonNotifier
.
close
(
)
;
removeListeners
(
)
;
}
;
popup
.
addEventListener
(
"
popupshown
"
function
(
)
{
PanicButtonNotifier
.
timer
=
setTimeout
(
onTimeout
3000
)
;
}
)
;
let
onUserInteractsWithPopup
=
(
)
=
>
{
clearTimeout
(
PanicButtonNotifier
.
timer
)
;
removeListeners
(
)
;
}
;
popup
.
addEventListener
(
"
mouseover
"
onUserInteractsWithPopup
)
;
window
.
addEventListener
(
"
keydown
"
onUserInteractsWithPopup
)
;
let
removeListeners
=
(
)
=
>
{
popup
.
removeEventListener
(
"
mouseover
"
onUserInteractsWithPopup
)
;
window
.
removeEventListener
(
"
keydown
"
onUserInteractsWithPopup
)
;
popup
.
removeEventListener
(
"
popuphidden
"
removeListeners
)
;
}
;
popup
.
addEventListener
(
"
popuphidden
"
removeListeners
)
;
let
widget
=
CustomizableUI
.
getWidget
(
"
panic
-
button
"
)
.
forWindow
(
window
)
;
let
anchor
=
widget
.
anchor
;
anchor
=
document
.
getAnonymousElementByAttribute
(
anchor
"
class
"
"
toolbarbutton
-
icon
"
)
;
popup
.
openPopup
(
anchor
popup
.
getAttribute
(
"
position
"
)
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
}
close
(
)
{
let
popup
=
document
.
getElementById
(
"
panic
-
button
-
success
-
notification
"
)
;
popup
.
hidePopup
(
)
;
}
}
;
var
AboutPrivateBrowsingListener
=
{
init
(
)
{
window
.
messageManager
.
addMessageListener
(
"
AboutPrivateBrowsing
:
OpenPrivateWindow
"
msg
=
>
{
OpenBrowserWindow
(
{
private
:
true
}
)
;
}
)
;
window
.
messageManager
.
addMessageListener
(
"
AboutPrivateBrowsing
:
ToggleTrackingProtection
"
msg
=
>
{
const
PREF
=
"
privacy
.
trackingprotection
.
pbmode
.
enabled
"
;
Services
.
prefs
.
setBoolPref
(
PREF
!
Services
.
prefs
.
getBoolPref
(
PREF
)
)
;
}
)
;
window
.
messageManager
.
addMessageListener
(
"
AboutPrivateBrowsing
:
DontShowIntroPanelAgain
"
msg
=
>
{
TrackingProtection
.
dontShowIntroPanelAgain
(
)
;
}
)
;
}
}
;
function
TabModalPromptBox
(
browser
)
{
this
.
_weakBrowserRef
=
Cu
.
getWeakReference
(
browser
)
;
}
TabModalPromptBox
.
prototype
=
{
_promptCloseCallback
(
onCloseCallback
principalToAllowFocusFor
allowFocusCheckbox
.
.
.
args
)
{
if
(
principalToAllowFocusFor
&
&
allowFocusCheckbox
&
&
allowFocusCheckbox
.
checked
)
{
Services
.
perms
.
addFromPrincipal
(
principalToAllowFocusFor
"
focus
-
tab
-
by
-
prompt
"
Services
.
perms
.
ALLOW_ACTION
)
;
}
onCloseCallback
.
apply
(
this
args
)
;
}
appendPrompt
(
args
onCloseCallback
)
{
const
XUL_NS
=
"
http
:
/
/
www
.
mozilla
.
org
/
keymaster
/
gatekeeper
/
there
.
is
.
only
.
xul
"
;
let
newPrompt
=
document
.
createElementNS
(
XUL_NS
"
tabmodalprompt
"
)
;
let
browser
=
this
.
browser
;
browser
.
parentNode
.
insertBefore
(
newPrompt
browser
.
nextSibling
)
;
browser
.
setAttribute
(
"
tabmodalPromptShowing
"
true
)
;
newPrompt
.
clientTop
;
let
prompts
=
this
.
listPrompts
(
)
;
if
(
prompts
.
length
>
1
)
{
newPrompt
.
hidden
=
true
;
}
let
principalToAllowFocusFor
=
this
.
_allowTabFocusByPromptPrincipal
;
delete
this
.
_allowTabFocusByPromptPrincipal
;
let
allowFocusCheckbox
;
let
hostForAllowFocusCheckbox
=
"
"
;
try
{
hostForAllowFocusCheckbox
=
principalToAllowFocusFor
.
URI
.
host
;
}
catch
(
ex
)
{
}
if
(
hostForAllowFocusCheckbox
)
{
let
allowFocusRow
=
document
.
createElementNS
(
XUL_NS
"
row
"
)
;
allowFocusCheckbox
=
document
.
createElementNS
(
XUL_NS
"
checkbox
"
)
;
let
spacer
=
document
.
createElementNS
(
XUL_NS
"
spacer
"
)
;
allowFocusRow
.
appendChild
(
spacer
)
;
let
label
=
gBrowser
.
mStringBundle
.
getFormattedString
(
"
tabs
.
allowTabFocusByPromptForSite
"
[
hostForAllowFocusCheckbox
]
)
;
allowFocusCheckbox
.
setAttribute
(
"
label
"
label
)
;
allowFocusRow
.
appendChild
(
allowFocusCheckbox
)
;
newPrompt
.
appendChild
(
allowFocusRow
)
;
}
let
tab
=
gBrowser
.
getTabForBrowser
(
browser
)
;
let
closeCB
=
this
.
_promptCloseCallback
.
bind
(
null
onCloseCallback
principalToAllowFocusFor
allowFocusCheckbox
)
;
newPrompt
.
init
(
args
tab
closeCB
)
;
return
newPrompt
;
}
removePrompt
(
aPrompt
)
{
let
browser
=
this
.
browser
;
browser
.
parentNode
.
removeChild
(
aPrompt
)
;
let
prompts
=
this
.
listPrompts
(
)
;
if
(
prompts
.
length
)
{
let
prompt
=
prompts
[
prompts
.
length
-
1
]
;
prompt
.
hidden
=
false
;
prompt
.
Dialog
.
setDefaultFocus
(
)
;
}
else
{
browser
.
removeAttribute
(
"
tabmodalPromptShowing
"
)
;
browser
.
focus
(
)
;
}
}
listPrompts
(
aPrompt
)
{
const
XUL_NS
=
"
http
:
/
/
www
.
mozilla
.
org
/
keymaster
/
gatekeeper
/
there
.
is
.
only
.
xul
"
;
let
els
=
this
.
browser
.
parentNode
.
getElementsByTagNameNS
(
XUL_NS
"
tabmodalprompt
"
)
;
return
Array
.
from
(
els
)
;
}
onNextPromptShowAllowFocusCheckboxFor
(
principal
)
{
this
.
_allowTabFocusByPromptPrincipal
=
principal
;
}
get
browser
(
)
{
let
browser
=
this
.
_weakBrowserRef
.
get
(
)
;
if
(
!
browser
)
{
throw
"
Stale
promptbox
!
The
associated
browser
is
gone
.
"
;
}
return
browser
;
}
}
;
