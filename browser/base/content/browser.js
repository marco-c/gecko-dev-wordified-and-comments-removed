var
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
var
{
AppConstants
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
sys
.
mjs
"
)
;
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
MemoryNotificationDB
.
sys
.
mjs
"
)
;
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
NotificationDB
.
sys
.
mjs
"
)
;
ChromeUtils
.
defineESModuleGetters
(
this
{
AMTelemetry
:
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
sys
.
mjs
"
AboutNewTab
:
"
resource
:
/
/
/
modules
/
AboutNewTab
.
sys
.
mjs
"
AboutReaderParent
:
"
resource
:
/
/
/
actors
/
AboutReaderParent
.
sys
.
mjs
"
AddonManager
:
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
sys
.
mjs
"
BrowserSearchTelemetry
:
"
resource
:
/
/
/
modules
/
BrowserSearchTelemetry
.
sys
.
mjs
"
BrowserTelemetryUtils
:
"
resource
:
/
/
gre
/
modules
/
BrowserTelemetryUtils
.
sys
.
mjs
"
BrowserUIUtils
:
"
resource
:
/
/
/
modules
/
BrowserUIUtils
.
sys
.
mjs
"
BrowserUsageTelemetry
:
"
resource
:
/
/
/
modules
/
BrowserUsageTelemetry
.
sys
.
mjs
"
BrowserWindowTracker
:
"
resource
:
/
/
/
modules
/
BrowserWindowTracker
.
sys
.
mjs
"
CFRPageActions
:
"
resource
:
/
/
/
modules
/
asrouter
/
CFRPageActions
.
sys
.
mjs
"
Color
:
"
resource
:
/
/
gre
/
modules
/
Color
.
sys
.
mjs
"
ContentAnalysis
:
"
resource
:
/
/
/
modules
/
ContentAnalysis
.
sys
.
mjs
"
ContextualIdentityService
:
"
resource
:
/
/
gre
/
modules
/
ContextualIdentityService
.
sys
.
mjs
"
CustomizableUI
:
"
resource
:
/
/
/
modules
/
CustomizableUI
.
sys
.
mjs
"
DevToolsSocketStatus
:
"
resource
:
/
/
devtools
/
shared
/
security
/
DevToolsSocketStatus
.
sys
.
mjs
"
DownloadUtils
:
"
resource
:
/
/
gre
/
modules
/
DownloadUtils
.
sys
.
mjs
"
DownloadsCommon
:
"
resource
:
/
/
/
modules
/
DownloadsCommon
.
sys
.
mjs
"
E10SUtils
:
"
resource
:
/
/
gre
/
modules
/
E10SUtils
.
sys
.
mjs
"
ExtensionsUI
:
"
resource
:
/
/
/
modules
/
ExtensionsUI
.
sys
.
mjs
"
HomePage
:
"
resource
:
/
/
/
modules
/
HomePage
.
sys
.
mjs
"
isProductURL
:
"
chrome
:
/
/
global
/
content
/
shopping
/
ShoppingProduct
.
mjs
"
LightweightThemeConsumer
:
"
resource
:
/
/
gre
/
modules
/
LightweightThemeConsumer
.
sys
.
mjs
"
LoginHelper
:
"
resource
:
/
/
gre
/
modules
/
LoginHelper
.
sys
.
mjs
"
LoginManagerParent
:
"
resource
:
/
/
gre
/
modules
/
LoginManagerParent
.
sys
.
mjs
"
MigrationUtils
:
"
resource
:
/
/
/
modules
/
MigrationUtils
.
sys
.
mjs
"
NetUtil
:
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
sys
.
mjs
"
NewTabPagePreloading
:
"
resource
:
/
/
/
modules
/
NewTabPagePreloading
.
sys
.
mjs
"
NewTabUtils
:
"
resource
:
/
/
gre
/
modules
/
NewTabUtils
.
sys
.
mjs
"
NimbusFeatures
:
"
resource
:
/
/
nimbus
/
ExperimentAPI
.
sys
.
mjs
"
nsContextMenu
:
"
chrome
:
/
/
browser
/
content
/
nsContextMenu
.
sys
.
mjs
"
OpenInTabsUtils
:
"
resource
:
/
/
/
modules
/
OpenInTabsUtils
.
sys
.
mjs
"
PageActions
:
"
resource
:
/
/
/
modules
/
PageActions
.
sys
.
mjs
"
PageThumbs
:
"
resource
:
/
/
gre
/
modules
/
PageThumbs
.
sys
.
mjs
"
PanelMultiView
:
"
resource
:
/
/
/
modules
/
PanelMultiView
.
sys
.
mjs
"
PanelView
:
"
resource
:
/
/
/
modules
/
PanelMultiView
.
sys
.
mjs
"
PBMExitStatus
:
"
resource
:
/
/
/
modules
/
PBMExitStatus
.
sys
.
mjs
"
PictureInPicture
:
"
resource
:
/
/
gre
/
modules
/
PictureInPicture
.
sys
.
mjs
"
PlacesTransactions
:
"
resource
:
/
/
gre
/
modules
/
PlacesTransactions
.
sys
.
mjs
"
PlacesUIUtils
:
"
resource
:
/
/
/
modules
/
PlacesUIUtils
.
sys
.
mjs
"
PlacesUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
sys
.
mjs
"
Pocket
:
"
chrome
:
/
/
pocket
/
content
/
Pocket
.
sys
.
mjs
"
PopupBlockerObserver
:
"
resource
:
/
/
/
modules
/
PopupBlockerObserver
.
sys
.
mjs
"
PrivateBrowsingUtils
:
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
sys
.
mjs
"
ProcessHangMonitor
:
"
resource
:
/
/
/
modules
/
ProcessHangMonitor
.
sys
.
mjs
"
PromptUtils
:
"
resource
:
/
/
gre
/
modules
/
PromptUtils
.
sys
.
mjs
"
ReaderMode
:
"
resource
:
/
/
gre
/
modules
/
ReaderMode
.
sys
.
mjs
"
ResetPBMPanel
:
"
resource
:
/
/
/
modules
/
ResetPBMPanel
.
sys
.
mjs
"
SafeBrowsing
:
"
resource
:
/
/
gre
/
modules
/
SafeBrowsing
.
sys
.
mjs
"
Sanitizer
:
"
resource
:
/
/
/
modules
/
Sanitizer
.
sys
.
mjs
"
SaveToPocket
:
"
chrome
:
/
/
pocket
/
content
/
SaveToPocket
.
sys
.
mjs
"
ScreenshotsUtils
:
"
resource
:
/
/
/
modules
/
ScreenshotsUtils
.
sys
.
mjs
"
SearchUIUtils
:
"
resource
:
/
/
/
modules
/
SearchUIUtils
.
sys
.
mjs
"
SessionStartup
:
"
resource
:
/
/
/
modules
/
sessionstore
/
SessionStartup
.
sys
.
mjs
"
SessionStore
:
"
resource
:
/
/
/
modules
/
sessionstore
/
SessionStore
.
sys
.
mjs
"
ShoppingSidebarParent
:
"
resource
:
/
/
/
actors
/
ShoppingSidebarParent
.
sys
.
mjs
"
ShoppingSidebarManager
:
"
resource
:
/
/
/
actors
/
ShoppingSidebarParent
.
sys
.
mjs
"
ShortcutUtils
:
"
resource
:
/
/
gre
/
modules
/
ShortcutUtils
.
sys
.
mjs
"
SiteDataManager
:
"
resource
:
/
/
/
modules
/
SiteDataManager
.
sys
.
mjs
"
SitePermissions
:
"
resource
:
/
/
/
modules
/
SitePermissions
.
sys
.
mjs
"
SubDialog
:
"
resource
:
/
/
gre
/
modules
/
SubDialog
.
sys
.
mjs
"
SubDialogManager
:
"
resource
:
/
/
gre
/
modules
/
SubDialog
.
sys
.
mjs
"
TabCrashHandler
:
"
resource
:
/
/
/
modules
/
ContentCrashHandlers
.
sys
.
mjs
"
TabsSetupFlowManager
:
"
resource
:
/
/
/
modules
/
firefox
-
view
-
tabs
-
setup
-
manager
.
sys
.
mjs
"
TelemetryEnvironment
:
"
resource
:
/
/
gre
/
modules
/
TelemetryEnvironment
.
sys
.
mjs
"
ToolbarContextMenu
:
"
resource
:
/
/
/
modules
/
ToolbarContextMenu
.
sys
.
mjs
"
TranslationsParent
:
"
resource
:
/
/
gre
/
actors
/
TranslationsParent
.
sys
.
mjs
"
UITour
:
"
resource
:
/
/
/
modules
/
UITour
.
sys
.
mjs
"
UpdateUtils
:
"
resource
:
/
/
gre
/
modules
/
UpdateUtils
.
sys
.
mjs
"
URILoadingHelper
:
"
resource
:
/
/
/
modules
/
URILoadingHelper
.
sys
.
mjs
"
UrlbarInput
:
"
resource
:
/
/
/
modules
/
UrlbarInput
.
sys
.
mjs
"
UrlbarPrefs
:
"
resource
:
/
/
/
modules
/
UrlbarPrefs
.
sys
.
mjs
"
UrlbarProviderSearchTips
:
"
resource
:
/
/
/
modules
/
UrlbarProviderSearchTips
.
sys
.
mjs
"
UrlbarTokenizer
:
"
resource
:
/
/
/
modules
/
UrlbarTokenizer
.
sys
.
mjs
"
UrlbarUtils
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
sys
.
mjs
"
UrlbarValueFormatter
:
"
resource
:
/
/
/
modules
/
UrlbarValueFormatter
.
sys
.
mjs
"
Weave
:
"
resource
:
/
/
services
-
sync
/
main
.
sys
.
mjs
"
WebNavigationFrames
:
"
resource
:
/
/
gre
/
modules
/
WebNavigationFrames
.
sys
.
mjs
"
webrtcUI
:
"
resource
:
/
/
/
modules
/
webrtcUI
.
sys
.
mjs
"
WebsiteFilter
:
"
resource
:
/
/
/
modules
/
policies
/
WebsiteFilter
.
sys
.
mjs
"
ZoomUI
:
"
resource
:
/
/
/
modules
/
ZoomUI
.
sys
.
mjs
"
}
)
;
ChromeUtils
.
defineLazyGetter
(
this
"
SelectableProfileService
"
(
)
=
>
{
if
(
!
AppConstants
.
MOZ_SELECTABLE_PROFILES
)
{
return
null
;
}
return
ChromeUtils
.
importESModule
(
"
resource
:
/
/
/
modules
/
profiles
/
SelectableProfileService
.
sys
.
mjs
"
)
.
SelectableProfileService
;
}
)
;
ChromeUtils
.
defineLazyGetter
(
this
"
fxAccounts
"
(
)
=
>
{
return
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
FxAccounts
.
sys
.
mjs
"
)
.
getFxAccountsSingleton
(
)
;
}
)
;
XPCOMUtils
.
defineLazyScriptGetter
(
this
[
"
BrowserCommands
"
"
kSkipCacheFlags
"
]
"
chrome
:
/
/
browser
/
content
/
browser
-
commands
.
js
"
)
;
XPCOMUtils
.
defineLazyScriptGetter
(
this
"
PlacesTreeView
"
"
chrome
:
/
/
browser
/
content
/
places
/
treeView
.
js
"
)
;
XPCOMUtils
.
defineLazyScriptGetter
(
this
[
"
PlacesInsertionPoint
"
"
PlacesController
"
"
PlacesControllerDragHelper
"
]
"
chrome
:
/
/
browser
/
content
/
places
/
controller
.
js
"
)
;
XPCOMUtils
.
defineLazyScriptGetter
(
this
"
PrintUtils
"
"
chrome
:
/
/
global
/
content
/
printUtils
.
js
"
)
;
XPCOMUtils
.
defineLazyScriptGetter
(
this
"
ZoomManager
"
"
chrome
:
/
/
global
/
content
/
viewZoomOverlay
.
js
"
)
;
XPCOMUtils
.
defineLazyScriptGetter
(
this
"
FullZoom
"
"
chrome
:
/
/
browser
/
content
/
tabbrowser
/
browser
-
fullZoom
.
js
"
)
;
XPCOMUtils
.
defineLazyScriptGetter
(
this
"
PanelUI
"
"
chrome
:
/
/
browser
/
content
/
customizableui
/
panelUI
.
js
"
)
;
XPCOMUtils
.
defineLazyScriptGetter
(
this
"
gViewSourceUtils
"
"
chrome
:
/
/
global
/
content
/
viewSourceUtils
.
js
"
)
;
XPCOMUtils
.
defineLazyScriptGetter
(
this
"
gTabsPanel
"
"
chrome
:
/
/
browser
/
content
/
tabbrowser
/
browser
-
allTabsMenu
.
js
"
)
;
XPCOMUtils
.
defineLazyScriptGetter
(
this
[
"
BrowserAddonUI
"
"
gExtensionsNotifications
"
"
gUnifiedExtensions
"
"
gXPInstallObserver
"
]
"
chrome
:
/
/
browser
/
content
/
browser
-
addons
.
js
"
)
;
XPCOMUtils
.
defineLazyScriptGetter
(
this
"
ctrlTab
"
"
chrome
:
/
/
browser
/
content
/
tabbrowser
/
browser
-
ctrlTab
.
js
"
)
;
XPCOMUtils
.
defineLazyScriptGetter
(
this
[
"
CustomizationHandler
"
"
AutoHideMenubar
"
]
"
chrome
:
/
/
browser
/
content
/
browser
-
customization
.
js
"
)
;
XPCOMUtils
.
defineLazyScriptGetter
(
this
[
"
PointerLock
"
"
FullScreen
"
]
"
chrome
:
/
/
browser
/
content
/
browser
-
fullScreenAndPointerLock
.
js
"
)
;
XPCOMUtils
.
defineLazyScriptGetter
(
this
"
gIdentityHandler
"
"
chrome
:
/
/
browser
/
content
/
browser
-
siteIdentity
.
js
"
)
;
XPCOMUtils
.
defineLazyScriptGetter
(
this
"
gPermissionPanel
"
"
chrome
:
/
/
browser
/
content
/
browser
-
sitePermissionPanel
.
js
"
)
;
XPCOMUtils
.
defineLazyScriptGetter
(
this
"
SelectTranslationsPanel
"
"
chrome
:
/
/
browser
/
content
/
translations
/
selectTranslationsPanel
.
js
"
)
;
XPCOMUtils
.
defineLazyScriptGetter
(
this
"
FullPageTranslationsPanel
"
"
chrome
:
/
/
browser
/
content
/
translations
/
fullPageTranslationsPanel
.
js
"
)
;
XPCOMUtils
.
defineLazyScriptGetter
(
this
"
gProtectionsHandler
"
"
chrome
:
/
/
browser
/
content
/
browser
-
siteProtections
.
js
"
)
;
XPCOMUtils
.
defineLazyScriptGetter
(
this
[
"
gGestureSupport
"
"
gHistorySwipeAnimation
"
]
"
chrome
:
/
/
browser
/
content
/
browser
-
gestureSupport
.
js
"
)
;
XPCOMUtils
.
defineLazyScriptGetter
(
this
"
gSafeBrowsing
"
"
chrome
:
/
/
browser
/
content
/
browser
-
safebrowsing
.
js
"
)
;
XPCOMUtils
.
defineLazyScriptGetter
(
this
"
gSync
"
"
chrome
:
/
/
browser
/
content
/
browser
-
sync
.
js
"
)
;
XPCOMUtils
.
defineLazyScriptGetter
(
this
"
gBrowserThumbnails
"
"
chrome
:
/
/
browser
/
content
/
browser
-
thumbnails
.
js
"
)
;
XPCOMUtils
.
defineLazyScriptGetter
(
this
[
"
DownloadsPanel
"
"
DownloadsOverlayLoader
"
"
DownloadsView
"
"
DownloadsViewUI
"
"
DownloadsViewController
"
"
DownloadsSummary
"
"
DownloadsFooter
"
"
DownloadsBlockedSubview
"
]
"
chrome
:
/
/
browser
/
content
/
downloads
/
downloads
.
js
"
)
;
XPCOMUtils
.
defineLazyScriptGetter
(
this
[
"
DownloadsButton
"
"
DownloadsIndicatorView
"
]
"
chrome
:
/
/
browser
/
content
/
downloads
/
indicator
.
js
"
)
;
XPCOMUtils
.
defineLazyScriptGetter
(
this
"
gEditItemOverlay
"
"
chrome
:
/
/
browser
/
content
/
places
/
editBookmark
.
js
"
)
;
XPCOMUtils
.
defineLazyScriptGetter
(
this
"
gGfxUtils
"
"
chrome
:
/
/
browser
/
content
/
browser
-
graphics
-
utils
.
js
"
)
;
XPCOMUtils
.
defineLazyScriptGetter
(
this
"
pktUI
"
"
chrome
:
/
/
pocket
/
content
/
pktUI
.
js
"
)
;
XPCOMUtils
.
defineLazyScriptGetter
(
this
"
ToolbarKeyboardNavigator
"
"
chrome
:
/
/
browser
/
content
/
browser
-
toolbarKeyNav
.
js
"
)
;
XPCOMUtils
.
defineLazyScriptGetter
(
this
"
A11yUtils
"
"
chrome
:
/
/
browser
/
content
/
browser
-
a11yUtils
.
js
"
)
;
XPCOMUtils
.
defineLazyScriptGetter
(
this
"
gSharedTabWarning
"
"
chrome
:
/
/
browser
/
content
/
browser
-
webrtc
.
js
"
)
;
XPCOMUtils
.
defineLazyScriptGetter
(
this
"
gPageStyleMenu
"
"
chrome
:
/
/
browser
/
content
/
browser
-
pagestyle
.
js
"
)
;
XPCOMUtils
.
defineLazyScriptGetter
(
this
"
gProfiles
"
"
chrome
:
/
/
browser
/
content
/
browser
-
profiles
.
js
"
)
;
XPCOMUtils
.
defineLazyServiceGetters
(
this
{
ContentPrefService2
:
[
"
mozilla
.
org
/
content
-
pref
/
service
;
1
"
"
nsIContentPrefService2
"
]
classifierService
:
[
"
mozilla
.
org
/
url
-
classifier
/
dbservice
;
1
"
"
nsIURIClassifier
"
]
Favicons
:
[
"
mozilla
.
org
/
browser
/
favicon
-
service
;
1
"
"
nsIFaviconService
"
]
WindowsUIUtils
:
[
"
mozilla
.
org
/
windows
-
ui
-
utils
;
1
"
"
nsIWindowsUIUtils
"
]
BrowserHandler
:
[
"
mozilla
.
org
/
browser
/
clh
;
1
"
"
nsIBrowserHandler
"
]
}
)
;
if
(
AppConstants
.
ENABLE_WEBDRIVER
)
{
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
Marionette
"
"
mozilla
.
org
/
remote
/
marionette
;
1
"
"
nsIMarionette
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
RemoteAgent
"
"
mozilla
.
org
/
remote
/
agent
;
1
"
"
nsIRemoteAgent
"
)
;
}
else
{
this
.
Marionette
=
{
running
:
false
}
;
this
.
RemoteAgent
=
{
running
:
false
}
;
}
ChromeUtils
.
defineLazyGetter
(
this
"
RTL_UI
"
(
)
=
>
{
return
Services
.
locale
.
isAppLocaleRTL
;
}
)
;
ChromeUtils
.
defineLazyGetter
(
this
"
gBrandBundle
"
(
)
=
>
{
return
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
branding
/
locale
/
brand
.
properties
"
)
;
}
)
;
ChromeUtils
.
defineLazyGetter
(
this
"
gBrowserBundle
"
(
)
=
>
{
return
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
browser
/
locale
/
browser
.
properties
"
)
;
}
)
;
ChromeUtils
.
defineLazyGetter
(
this
"
gCustomizeMode
"
(
)
=
>
{
let
{
CustomizeMode
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
/
modules
/
CustomizeMode
.
sys
.
mjs
"
)
;
return
new
CustomizeMode
(
window
)
;
}
)
;
ChromeUtils
.
defineLazyGetter
(
this
"
gNavToolbox
"
(
)
=
>
{
return
document
.
getElementById
(
"
navigator
-
toolbox
"
)
;
}
)
;
ChromeUtils
.
defineLazyGetter
(
this
"
gURLBar
"
(
)
=
>
{
let
urlbar
=
new
UrlbarInput
(
{
textbox
:
document
.
getElementById
(
"
urlbar
"
)
eventTelemetryCategory
:
"
urlbar
"
}
)
;
let
beforeFocusOrSelect
=
event
=
>
{
if
(
CustomizationHandler
.
isCustomizing
(
)
|
|
CustomizationHandler
.
isExitingCustomizeMode
)
{
gNavToolbox
.
addEventListener
(
"
aftercustomization
"
(
)
=
>
{
if
(
event
.
type
=
=
"
beforeselect
"
)
{
gURLBar
.
select
(
)
;
}
else
{
gURLBar
.
focus
(
)
;
}
}
{
once
:
true
}
)
;
event
.
preventDefault
(
)
;
return
;
}
if
(
window
.
fullScreen
)
{
FullScreen
.
showNavToolbox
(
)
;
}
}
;
urlbar
.
addEventListener
(
"
beforefocus
"
beforeFocusOrSelect
)
;
urlbar
.
addEventListener
(
"
beforeselect
"
beforeFocusOrSelect
)
;
return
urlbar
;
}
)
;
ChromeUtils
.
defineLazyGetter
(
this
"
ReferrerInfo
"
(
)
=
>
Components
.
Constructor
(
"
mozilla
.
org
/
referrer
-
info
;
1
"
"
nsIReferrerInfo
"
"
init
"
)
)
;
ChromeUtils
.
defineLazyGetter
(
this
"
gNotificationBox
"
(
)
=
>
{
return
new
MozElements
.
NotificationBox
(
element
=
>
{
element
.
classList
.
add
(
"
global
-
notificationbox
"
)
;
element
.
setAttribute
(
"
notificationside
"
"
top
"
)
;
element
.
setAttribute
(
"
prepend
-
notifications
"
true
)
;
const
tabNotifications
=
document
.
getElementById
(
"
tab
-
notification
-
deck
"
)
;
gNavToolbox
.
insertBefore
(
element
tabNotifications
)
;
}
)
;
}
)
;
ChromeUtils
.
defineLazyGetter
(
this
"
InlineSpellCheckerUI
"
(
)
=
>
{
let
{
InlineSpellChecker
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
InlineSpellChecker
.
sys
.
mjs
"
)
;
return
new
InlineSpellChecker
(
)
;
}
)
;
ChromeUtils
.
defineLazyGetter
(
this
"
PopupNotifications
"
(
)
=
>
{
let
{
PopupNotifications
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
PopupNotifications
.
sys
.
mjs
"
)
;
try
{
let
shouldSuppress
=
(
)
=
>
{
const
urlBarEdited
=
isBlankPageURL
(
gBrowser
.
currentURI
.
spec
)
?
gURLBar
.
hasAttribute
(
"
usertyping
"
)
:
gURLBar
.
getAttribute
(
"
pageproxystate
"
)
!
=
"
valid
"
;
return
(
(
urlBarEdited
&
&
gURLBar
.
focused
)
|
|
(
gURLBar
.
getAttribute
(
"
pageproxystate
"
)
!
=
"
valid
"
&
&
gBrowser
.
selectedBrowser
.
_awaitingSetURI
)
|
|
shouldSuppressPopupNotifications
(
)
)
;
}
;
const
getVisibleAnchorElement
=
anchorElement
=
>
{
gURLBar
.
maybeHandleRevertFromPopup
(
anchorElement
)
;
if
(
anchorElement
?
.
checkVisibility
(
)
)
{
return
anchorElement
;
}
let
fallback
=
[
document
.
getElementById
(
"
identity
-
icon
"
)
gURLBar
.
querySelector
(
"
.
urlbar
-
search
-
button
"
)
]
;
return
fallback
.
find
(
element
=
>
element
?
.
checkVisibility
(
)
)
?
?
null
;
}
;
return
new
PopupNotifications
(
gBrowser
document
.
getElementById
(
"
notification
-
popup
"
)
document
.
getElementById
(
"
notification
-
popup
-
box
"
)
{
shouldSuppress
getVisibleAnchorElement
}
)
;
}
catch
(
ex
)
{
console
.
error
(
ex
)
;
return
null
;
}
}
)
;
ChromeUtils
.
defineLazyGetter
(
this
"
MacUserActivityUpdater
"
(
)
=
>
{
if
(
AppConstants
.
platform
!
=
"
macosx
"
)
{
return
null
;
}
return
Cc
[
"
mozilla
.
org
/
widget
/
macuseractivityupdater
;
1
"
]
.
getService
(
Ci
.
nsIMacUserActivityUpdater
)
;
}
)
;
ChromeUtils
.
defineLazyGetter
(
this
"
Win7Features
"
(
)
=
>
{
if
(
AppConstants
.
platform
!
=
"
win
"
)
{
return
null
;
}
const
WINTASKBAR_CONTRACTID
=
"
mozilla
.
org
/
windows
-
taskbar
;
1
"
;
if
(
WINTASKBAR_CONTRACTID
in
Cc
&
&
Cc
[
WINTASKBAR_CONTRACTID
]
.
getService
(
Ci
.
nsIWinTaskbar
)
.
available
)
{
let
{
AeroPeek
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
/
modules
/
WindowsPreviewPerTab
.
sys
.
mjs
"
)
;
return
{
onOpenWindow
(
)
{
AeroPeek
.
onOpenWindow
(
window
)
;
this
.
handledOpening
=
true
;
}
onCloseWindow
(
)
{
if
(
this
.
handledOpening
)
{
AeroPeek
.
onCloseWindow
(
window
)
;
}
}
handledOpening
:
false
}
;
}
return
null
;
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
gToolbarKeyNavEnabled
"
"
browser
.
toolbars
.
keyboard_navigation
"
false
(
aPref
aOldVal
aNewVal
)
=
>
{
if
(
window
.
closed
)
{
return
;
}
if
(
aNewVal
)
{
ToolbarKeyboardNavigator
.
init
(
)
;
}
else
{
ToolbarKeyboardNavigator
.
uninit
(
)
;
}
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
gBookmarksToolbarVisibility
"
"
browser
.
toolbars
.
bookmarks
.
visibility
"
"
newtab
"
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
gFxaToolbarEnabled
"
"
identity
.
fxaccounts
.
toolbar
.
enabled
"
false
(
aPref
aOldVal
aNewVal
)
=
>
{
updateFxaToolbarMenu
(
aNewVal
)
;
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
gFxaToolbarAccessed
"
"
identity
.
fxaccounts
.
toolbar
.
accessed
"
false
(
)
=
>
{
updateFxaToolbarMenu
(
gFxaToolbarEnabled
)
;
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
gAddonAbuseReportEnabled
"
"
extensions
.
abuseReport
.
enabled
"
false
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
gMiddleClickNewTabUsesPasteboard
"
"
browser
.
tabs
.
searchclipboardfor
.
middleclick
"
true
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
gScreenshotsDisabled
"
"
extensions
.
screenshots
.
disabled
"
false
(
)
=
>
{
Services
.
obs
.
notifyObservers
(
window
"
toggle
-
screenshot
-
disable
"
gScreenshots
.
shouldScreenshotsButtonBeDisabled
(
)
)
;
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
gPrintEnabled
"
"
print
.
enabled
"
false
(
aPref
aOldVal
aNewVal
)
=
>
{
updatePrintCommands
(
aNewVal
)
;
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
gScreenshotsComponentEnabled
"
"
screenshots
.
browser
.
component
.
enabled
"
false
(
)
=
>
{
Services
.
obs
.
notifyObservers
(
window
"
toggle
-
screenshot
-
disable
"
gScreenshots
.
shouldScreenshotsButtonBeDisabled
(
)
)
;
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
gTranslationsEnabled
"
"
browser
.
translations
.
enable
"
false
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
gUseFeltPrivacyUI
"
"
browser
.
privatebrowsing
.
felt
-
privacy
-
v1
"
false
)
;
customElements
.
setElementCreationCallback
(
"
screenshots
-
buttons
"
(
)
=
>
{
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
browser
/
content
/
screenshots
/
screenshots
-
buttons
.
js
"
window
)
;
}
)
;
var
gBrowser
;
var
gContextMenu
=
null
;
var
gMultiProcessBrowser
=
window
.
docShell
.
QueryInterface
(
Ci
.
nsILoadContext
)
.
useRemoteTabs
;
var
gFissionBrowser
=
window
.
docShell
.
QueryInterface
(
Ci
.
nsILoadContext
)
.
useRemoteSubframes
;
var
gBrowserAllowScriptsToCloseInitialTabs
=
false
;
if
(
AppConstants
.
platform
!
=
"
macosx
"
)
{
var
gEditUIVisible
=
true
;
}
Object
.
defineProperty
(
this
"
gReduceMotion
"
{
enumerable
:
true
get
(
)
{
return
typeof
gReduceMotionOverride
=
=
"
boolean
"
?
gReduceMotionOverride
:
gReduceMotionSetting
;
}
}
)
;
let
gReduceMotionSetting
=
true
;
var
gReduceMotionOverride
;
Object
.
defineProperty
(
this
"
gFindBar
"
{
enumerable
:
true
get
(
)
{
return
gBrowser
.
getCachedFindBar
(
)
;
}
}
)
;
Object
.
defineProperty
(
this
"
gFindBarInitialized
"
{
enumerable
:
true
get
(
)
{
return
gBrowser
.
isFindBarInitialized
(
)
;
}
}
)
;
Object
.
defineProperty
(
this
"
gFindBarPromise
"
{
enumerable
:
true
get
(
)
{
return
gBrowser
.
getFindBar
(
)
;
}
}
)
;
function
shouldSuppressPopupNotifications
(
)
{
return
(
window
.
windowState
=
=
window
.
STATE_MINIMIZED
|
|
gBrowser
?
.
selectedBrowser
.
hasAttribute
(
"
tabDialogShowing
"
)
|
|
gDialogBox
?
.
isOpen
)
;
}
async
function
gLazyFindCommand
(
cmd
.
.
.
args
)
{
let
fb
=
await
gFindBarPromise
;
if
(
fb
&
&
fb
[
cmd
]
)
{
fb
[
cmd
]
.
apply
(
fb
args
)
;
}
}
var
gPageIcons
=
{
"
about
:
home
"
:
"
chrome
:
/
/
branding
/
content
/
icon32
.
png
"
"
about
:
newtab
"
:
"
chrome
:
/
/
branding
/
content
/
icon32
.
png
"
"
about
:
welcome
"
:
"
chrome
:
/
/
branding
/
content
/
icon32
.
png
"
"
about
:
privatebrowsing
"
:
"
chrome
:
/
/
browser
/
skin
/
privatebrowsing
/
favicon
.
svg
"
}
;
var
gInitialPages
=
[
"
about
:
blank
"
"
about
:
home
"
"
about
:
firefoxview
"
"
about
:
newtab
"
"
about
:
privatebrowsing
"
"
about
:
sessionrestore
"
"
about
:
welcome
"
"
about
:
welcomeback
"
"
chrome
:
/
/
browser
/
content
/
blanktab
.
html
"
]
;
if
(
Services
.
prefs
.
getBoolPref
(
"
browser
.
profiles
.
enabled
"
)
)
{
gInitialPages
.
push
(
"
about
:
profilemanager
"
)
;
}
function
isInitialPage
(
url
)
{
if
(
!
(
url
instanceof
Ci
.
nsIURI
)
)
{
try
{
url
=
Services
.
io
.
newURI
(
url
)
;
}
catch
(
ex
)
{
return
false
;
}
}
let
nonQuery
=
url
.
prePath
+
url
.
filePath
;
return
gInitialPages
.
includes
(
nonQuery
)
|
|
nonQuery
=
=
BROWSER_NEW_TAB_URL
;
}
function
browserWindows
(
)
{
return
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
;
}
function
updateBookmarkToolbarVisibility
(
)
{
BookmarkingUI
.
updateEmptyToolbarMessage
(
)
;
setToolbarVisibility
(
BookmarkingUI
.
toolbar
gBookmarksToolbarVisibility
false
false
)
;
}
var
gNavigatorBundle
=
{
getString
(
key
)
{
return
gBrowserBundle
.
GetStringFromName
(
key
)
;
}
getFormattedString
(
key
array
)
{
return
gBrowserBundle
.
formatStringFromName
(
key
array
)
;
}
}
;
var
gScreenshots
=
{
shouldScreenshotsButtonBeDisabled
(
)
{
let
uri
=
gBrowser
.
selectedBrowser
.
currentURI
;
let
shouldBeDisabled
=
gScreenshotsDisabled
|
|
(
!
gScreenshotsComponentEnabled
&
&
uri
.
scheme
=
=
=
"
about
"
&
&
!
uri
.
spec
.
startsWith
(
"
about
:
reader
"
)
)
;
return
shouldBeDisabled
;
}
}
;
function
updateFxaToolbarMenu
(
enable
isInitialUpdate
=
false
)
{
const
syncEnabled
=
Services
.
prefs
.
getBoolPref
(
"
identity
.
fxaccounts
.
enabled
"
false
)
;
const
mainWindowEl
=
document
.
documentElement
;
const
fxaPanelEl
=
PanelMultiView
.
getViewNode
(
document
"
PanelUI
-
fxa
"
)
;
const
statusGuess
=
!
!
Services
.
prefs
.
getStringPref
(
"
identity
.
fxaccounts
.
account
.
device
.
name
"
"
"
)
;
mainWindowEl
.
setAttribute
(
"
fxastatus
"
statusGuess
?
"
signed_in
"
:
"
not_configured
"
)
;
fxaPanelEl
.
addEventListener
(
"
ViewShowing
"
gSync
.
updateSendToDeviceTitle
)
;
Services
.
telemetry
.
setEventRecordingEnabled
(
"
fxa_app_menu
"
true
)
;
if
(
enable
&
&
syncEnabled
)
{
mainWindowEl
.
setAttribute
(
"
fxatoolbarmenu
"
"
visible
"
)
;
if
(
!
isInitialUpdate
)
{
gSync
.
maybeUpdateUIState
(
)
;
}
Services
.
telemetry
.
setEventRecordingEnabled
(
"
fxa_avatar_menu
"
true
)
;
}
else
{
mainWindowEl
.
removeAttribute
(
"
fxatoolbarmenu
"
)
;
}
}
function
UpdateBackForwardCommands
(
aWebNavigation
)
{
var
backCommand
=
document
.
getElementById
(
"
Browser
:
Back
"
)
;
var
forwardCommand
=
document
.
getElementById
(
"
Browser
:
Forward
"
)
;
var
backDisabled
=
backCommand
.
hasAttribute
(
"
disabled
"
)
;
var
forwardDisabled
=
forwardCommand
.
hasAttribute
(
"
disabled
"
)
;
if
(
backDisabled
=
=
aWebNavigation
.
canGoBack
)
{
if
(
backDisabled
)
{
backCommand
.
removeAttribute
(
"
disabled
"
)
;
}
else
{
backCommand
.
setAttribute
(
"
disabled
"
true
)
;
}
}
if
(
forwardDisabled
=
=
aWebNavigation
.
canGoForward
)
{
if
(
forwardDisabled
)
{
forwardCommand
.
removeAttribute
(
"
disabled
"
)
;
}
else
{
forwardCommand
.
setAttribute
(
"
disabled
"
true
)
;
}
}
}
function
updatePrintCommands
(
enabled
)
{
var
printCommand
=
document
.
getElementById
(
"
cmd_print
"
)
;
var
printPreviewCommand
=
document
.
getElementById
(
"
cmd_printPreviewToggle
"
)
;
if
(
enabled
)
{
printCommand
.
removeAttribute
(
"
disabled
"
)
;
printPreviewCommand
.
removeAttribute
(
"
disabled
"
)
;
}
else
{
printCommand
.
setAttribute
(
"
disabled
"
"
true
"
)
;
printPreviewCommand
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
}
function
SetClickAndHoldHandlers
(
)
{
let
popup
=
document
.
getElementById
(
"
backForwardMenu
"
)
.
cloneNode
(
true
)
;
popup
.
removeAttribute
(
"
id
"
)
;
popup
.
setAttribute
(
"
context
"
"
"
)
;
function
backForwardMenuCommand
(
event
)
{
BrowserCommands
.
gotoHistoryIndex
(
event
)
;
event
.
stopPropagation
(
)
;
}
let
backButton
=
document
.
getElementById
(
"
back
-
button
"
)
;
backButton
.
setAttribute
(
"
type
"
"
menu
"
)
;
popup
.
addEventListener
(
"
command
"
backForwardMenuCommand
)
;
popup
.
addEventListener
(
"
popupshowing
"
FillHistoryMenu
)
;
backButton
.
prepend
(
popup
)
;
gClickAndHoldListenersOnElement
.
add
(
backButton
)
;
let
forwardButton
=
document
.
getElementById
(
"
forward
-
button
"
)
;
popup
=
popup
.
cloneNode
(
true
)
;
forwardButton
.
setAttribute
(
"
type
"
"
menu
"
)
;
popup
.
addEventListener
(
"
command
"
backForwardMenuCommand
)
;
popup
.
addEventListener
(
"
popupshowing
"
FillHistoryMenu
)
;
forwardButton
.
prepend
(
popup
)
;
gClickAndHoldListenersOnElement
.
add
(
forwardButton
)
;
}
const
gClickAndHoldListenersOnElement
=
{
_timers
:
new
Map
(
)
_mousedownHandler
(
aEvent
)
{
if
(
aEvent
.
button
!
=
0
|
|
aEvent
.
currentTarget
.
open
|
|
aEvent
.
currentTarget
.
disabled
)
{
return
;
}
aEvent
.
currentTarget
.
menupopup
.
hidden
=
true
;
aEvent
.
currentTarget
.
addEventListener
(
"
mouseout
"
this
)
;
aEvent
.
currentTarget
.
addEventListener
(
"
mouseup
"
this
)
;
this
.
_timers
.
set
(
aEvent
.
currentTarget
setTimeout
(
b
=
>
this
.
_openMenu
(
b
)
500
aEvent
.
currentTarget
)
)
;
}
_clickHandler
(
aEvent
)
{
if
(
aEvent
.
button
=
=
0
&
&
aEvent
.
target
=
=
aEvent
.
currentTarget
&
&
!
aEvent
.
currentTarget
.
open
&
&
!
aEvent
.
currentTarget
.
disabled
&
&
aEvent
.
currentTarget
.
menupopup
.
hidden
)
{
let
cmdEvent
=
document
.
createEvent
(
"
xulcommandevent
"
)
;
cmdEvent
.
initCommandEvent
(
"
command
"
true
true
window
0
aEvent
.
ctrlKey
aEvent
.
altKey
aEvent
.
shiftKey
aEvent
.
metaKey
0
null
aEvent
.
inputSource
)
;
aEvent
.
currentTarget
.
dispatchEvent
(
cmdEvent
)
;
aEvent
.
preventDefault
(
)
;
}
}
_openMenu
(
aButton
)
{
this
.
_cancelHold
(
aButton
)
;
aButton
.
firstElementChild
.
hidden
=
false
;
aButton
.
open
=
true
;
}
_mouseoutHandler
(
aEvent
)
{
let
buttonRect
=
aEvent
.
currentTarget
.
getBoundingClientRect
(
)
;
if
(
aEvent
.
clientX
>
=
buttonRect
.
left
&
&
aEvent
.
clientX
<
=
buttonRect
.
right
&
&
aEvent
.
clientY
>
=
buttonRect
.
bottom
)
{
this
.
_openMenu
(
aEvent
.
currentTarget
)
;
}
else
{
this
.
_cancelHold
(
aEvent
.
currentTarget
)
;
}
}
_mouseupHandler
(
aEvent
)
{
this
.
_cancelHold
(
aEvent
.
currentTarget
)
;
}
_cancelHold
(
aButton
)
{
clearTimeout
(
this
.
_timers
.
get
(
aButton
)
)
;
aButton
.
removeEventListener
(
"
mouseout
"
this
)
;
aButton
.
removeEventListener
(
"
mouseup
"
this
)
;
}
_keypressHandler
(
aEvent
)
{
if
(
aEvent
.
key
=
=
"
"
|
|
aEvent
.
key
=
=
"
Enter
"
)
{
aEvent
.
target
.
click
(
)
;
}
}
handleEvent
(
e
)
{
switch
(
e
.
type
)
{
case
"
mouseout
"
:
this
.
_mouseoutHandler
(
e
)
;
break
;
case
"
mousedown
"
:
this
.
_mousedownHandler
(
e
)
;
break
;
case
"
click
"
:
this
.
_clickHandler
(
e
)
;
break
;
case
"
mouseup
"
:
this
.
_mouseupHandler
(
e
)
;
break
;
case
"
keypress
"
:
this
.
_keypressHandler
(
e
)
;
break
;
}
}
remove
(
aButton
)
{
aButton
.
removeEventListener
(
"
mousedown
"
this
true
)
;
aButton
.
removeEventListener
(
"
click
"
this
true
)
;
aButton
.
removeEventListener
(
"
keypress
"
this
true
)
;
}
add
(
aElm
)
{
this
.
_timers
.
delete
(
aElm
)
;
aElm
.
addEventListener
(
"
mousedown
"
this
true
)
;
aElm
.
addEventListener
(
"
click
"
this
true
)
;
aElm
.
addEventListener
(
"
keypress
"
this
true
)
;
}
}
;
const
gSessionHistoryObserver
=
{
observe
(
subject
topic
)
{
if
(
topic
!
=
"
browser
:
purge
-
session
-
history
"
)
{
return
;
}
var
backCommand
=
document
.
getElementById
(
"
Browser
:
Back
"
)
;
backCommand
.
setAttribute
(
"
disabled
"
"
true
"
)
;
var
fwdCommand
=
document
.
getElementById
(
"
Browser
:
Forward
"
)
;
fwdCommand
.
setAttribute
(
"
disabled
"
"
true
"
)
;
gURLBar
.
editor
.
clearUndoRedo
(
)
;
}
}
;
const
gStoragePressureObserver
=
{
_lastNotificationTime
:
-
1
async
observe
(
subject
topic
)
{
if
(
topic
!
=
"
QuotaManager
:
:
StoragePressure
"
)
{
return
;
}
const
NOTIFICATION_VALUE
=
"
storage
-
pressure
-
notification
"
;
if
(
gNotificationBox
.
getNotificationWithValue
(
NOTIFICATION_VALUE
)
)
{
return
;
}
const
MIN_NOTIFICATION_INTERVAL_MS
=
Services
.
prefs
.
getIntPref
(
"
browser
.
storageManager
.
pressureNotification
.
minIntervalMS
"
)
;
let
duration
=
Date
.
now
(
)
-
this
.
_lastNotificationTime
;
if
(
duration
<
=
MIN_NOTIFICATION_INTERVAL_MS
)
{
return
;
}
this
.
_lastNotificationTime
=
Date
.
now
(
)
;
MozXULElement
.
insertFTLIfNeeded
(
"
branding
/
brand
.
ftl
"
)
;
MozXULElement
.
insertFTLIfNeeded
(
"
browser
/
preferences
/
preferences
.
ftl
"
)
;
const
BYTES_IN_GIGABYTE
=
1073741824
;
const
USAGE_THRESHOLD_BYTES
=
BYTES_IN_GIGABYTE
*
Services
.
prefs
.
getIntPref
(
"
browser
.
storageManager
.
pressureNotification
.
usageThresholdGB
"
)
;
let
messageFragment
=
document
.
createDocumentFragment
(
)
;
let
message
=
document
.
createElement
(
"
span
"
)
;
let
buttons
=
[
{
supportPage
:
"
storage
-
permissions
"
}
]
;
let
usage
=
subject
.
QueryInterface
(
Ci
.
nsISupportsPRUint64
)
.
data
;
if
(
usage
<
USAGE_THRESHOLD_BYTES
)
{
document
.
l10n
.
setAttributes
(
message
"
space
-
alert
-
under
-
5gb
-
message2
"
)
;
}
else
{
document
.
l10n
.
setAttributes
(
message
"
space
-
alert
-
over
-
5gb
-
message2
"
)
;
buttons
.
push
(
{
"
l10n
-
id
"
:
"
space
-
alert
-
over
-
5gb
-
settings
-
button
"
callback
(
)
{
openPreferences
(
"
privacy
-
sitedata
"
)
;
}
}
)
;
}
messageFragment
.
appendChild
(
message
)
;
await
gNotificationBox
.
appendNotification
(
NOTIFICATION_VALUE
{
label
:
messageFragment
priority
:
gNotificationBox
.
PRIORITY_WARNING_HIGH
}
buttons
)
;
document
.
l10n
.
translateFragment
(
gNotificationBox
.
currentNotification
)
;
}
}
;
var
gKeywordURIFixup
=
{
check
(
browser
{
fixedURI
keywordProviderName
preferredURI
}
)
{
if
(
!
keywordProviderName
|
|
!
fixedURI
|
|
!
fixedURI
.
host
|
|
UrlbarPrefs
.
get
(
"
browser
.
fixup
.
dns_first_for_single_words
"
)
|
|
UrlbarPrefs
.
get
(
"
dnsResolveSingleWordsAfterSearch
"
)
=
=
0
)
{
return
;
}
let
contentPrincipal
=
browser
.
contentPrincipal
;
let
previousURI
=
browser
.
currentURI
;
let
weakBrowser
=
Cu
.
getWeakReference
(
browser
)
;
browser
=
null
;
let
hostName
=
fixedURI
.
displayHost
;
let
asciiHost
=
fixedURI
.
asciiHost
;
let
onLookupCompleteListener
=
{
async
onLookupComplete
(
request
record
status
)
{
let
browserRef
=
weakBrowser
.
get
(
)
;
if
(
!
Components
.
isSuccessCode
(
status
)
|
|
!
browserRef
)
{
return
;
}
let
currentURI
=
browserRef
.
currentURI
;
if
(
!
currentURI
.
equals
(
previousURI
)
&
&
!
currentURI
.
equals
(
preferredURI
)
)
{
return
;
}
let
notificationBox
=
gBrowser
.
getNotificationBox
(
browserRef
)
;
if
(
notificationBox
.
getNotificationWithValue
(
"
keyword
-
uri
-
fixup
"
)
)
{
return
;
}
let
displayHostName
=
"
http
:
/
/
"
+
hostName
+
"
/
"
;
let
message
=
gNavigatorBundle
.
getFormattedString
(
"
keywordURIFixup
.
message
"
[
displayHostName
]
)
;
let
yesMessage
=
gNavigatorBundle
.
getFormattedString
(
"
keywordURIFixup
.
goTo
"
[
displayHostName
]
)
;
let
buttons
=
[
{
label
:
yesMessage
accessKey
:
gNavigatorBundle
.
getString
(
"
keywordURIFixup
.
goTo
.
accesskey
"
)
callback
(
)
{
if
(
!
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
{
let
prefHost
=
asciiHost
;
if
(
prefHost
.
indexOf
(
"
.
"
)
=
=
prefHost
.
length
-
1
)
{
prefHost
=
prefHost
.
slice
(
0
-
1
)
;
}
let
pref
=
"
browser
.
fixup
.
domainwhitelist
.
"
+
prefHost
;
Services
.
prefs
.
setBoolPref
(
pref
true
)
;
}
openTrustedLinkIn
(
fixedURI
.
spec
"
current
"
)
;
}
}
]
;
let
notification
=
await
notificationBox
.
appendNotification
(
"
keyword
-
uri
-
fixup
"
{
label
:
message
priority
:
notificationBox
.
PRIORITY_INFO_HIGH
}
buttons
)
;
notification
.
persistence
=
1
;
}
}
;
Services
.
uriFixup
.
checkHost
(
fixedURI
onLookupCompleteListener
contentPrincipal
.
originAttributes
)
;
}
observe
(
fixupInfo
)
{
fixupInfo
.
QueryInterface
(
Ci
.
nsIURIFixupInfo
)
;
let
browser
=
fixupInfo
.
consumer
?
.
top
?
.
embedderElement
;
if
(
!
browser
|
|
browser
.
ownerGlobal
!
=
window
)
{
return
;
}
this
.
check
(
browser
fixupInfo
)
;
}
}
;
function
_createNullPrincipalFromTabUserContextId
(
tab
=
gBrowser
.
selectedTab
)
{
let
userContextId
;
if
(
tab
.
hasAttribute
(
"
usercontextid
"
)
)
{
userContextId
=
tab
.
getAttribute
(
"
usercontextid
"
)
;
}
return
Services
.
scriptSecurityManager
.
createNullPrincipal
(
{
userContextId
}
)
;
}
function
HandleAppCommandEvent
(
evt
)
{
switch
(
evt
.
command
)
{
case
"
Back
"
:
BrowserCommands
.
back
(
)
;
break
;
case
"
Forward
"
:
BrowserCommands
.
forward
(
)
;
break
;
case
"
Reload
"
:
BrowserCommands
.
reloadSkipCache
(
)
;
break
;
case
"
Stop
"
:
if
(
XULBrowserWindow
.
stopCommand
.
getAttribute
(
"
disabled
"
)
!
=
"
true
"
)
{
BrowserCommands
.
stop
(
)
;
}
break
;
case
"
Search
"
:
BrowserSearch
.
webSearch
(
)
;
break
;
case
"
Bookmarks
"
:
SidebarController
.
toggle
(
"
viewBookmarksSidebar
"
)
;
break
;
case
"
Home
"
:
BrowserCommands
.
home
(
)
;
break
;
case
"
New
"
:
BrowserCommands
.
openTab
(
)
;
break
;
case
"
Close
"
:
BrowserCommands
.
closeTabOrWindow
(
)
;
break
;
case
"
Find
"
:
gLazyFindCommand
(
"
onFindCommand
"
)
;
break
;
case
"
Help
"
:
openHelpLink
(
"
firefox
-
help
"
)
;
break
;
case
"
Open
"
:
BrowserCommands
.
openFileWindow
(
)
;
break
;
case
"
Print
"
:
PrintUtils
.
startPrintWindow
(
gBrowser
.
selectedBrowser
.
browsingContext
)
;
break
;
case
"
Save
"
:
saveBrowser
(
gBrowser
.
selectedBrowser
)
;
break
;
case
"
SendMail
"
:
MailIntegration
.
sendLinkForBrowser
(
gBrowser
.
selectedBrowser
)
;
break
;
default
:
return
;
}
evt
.
stopPropagation
(
)
;
evt
.
preventDefault
(
)
;
}
function
loadOneOrMoreURIs
(
aURIString
aTriggeringPrincipal
aCsp
)
{
if
(
window
.
location
.
href
!
=
AppConstants
.
BROWSER_CHROME_URL
)
{
window
.
openDialog
(
AppConstants
.
BROWSER_CHROME_URL
"
_blank
"
"
all
dialog
=
no
"
aURIString
)
;
return
;
}
try
{
gBrowser
.
loadTabs
(
aURIString
.
split
(
"
|
"
)
{
inBackground
:
false
replace
:
true
triggeringPrincipal
:
aTriggeringPrincipal
csp
:
aCsp
}
)
;
}
catch
(
e
)
{
}
}
function
openLocation
(
event
)
{
if
(
window
.
location
.
href
=
=
AppConstants
.
BROWSER_CHROME_URL
)
{
gURLBar
.
select
(
)
;
gURLBar
.
view
.
autoOpen
(
{
event
}
)
;
return
;
}
let
win
=
URILoadingHelper
.
getTargetWindow
(
window
)
;
if
(
win
)
{
win
.
focus
(
)
;
win
.
openLocation
(
)
;
return
;
}
window
.
openDialog
(
AppConstants
.
BROWSER_CHROME_URL
"
_blank
"
"
chrome
all
dialog
=
no
"
BROWSER_NEW_TAB_URL
)
;
}
var
gLastOpenDirectory
=
{
_lastDir
:
null
get
path
(
)
{
if
(
!
this
.
_lastDir
|
|
!
this
.
_lastDir
.
exists
(
)
)
{
try
{
this
.
_lastDir
=
Services
.
prefs
.
getComplexValue
(
"
browser
.
open
.
lastDir
"
Ci
.
nsIFile
)
;
if
(
!
this
.
_lastDir
.
exists
(
)
)
{
this
.
_lastDir
=
null
;
}
}
catch
(
e
)
{
}
}
return
this
.
_lastDir
;
}
set
path
(
val
)
{
try
{
if
(
!
val
|
|
!
val
.
isDirectory
(
)
)
{
return
;
}
}
catch
(
e
)
{
return
;
}
this
.
_lastDir
=
val
.
clone
(
)
;
if
(
!
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
{
Services
.
prefs
.
setComplexValue
(
"
browser
.
open
.
lastDir
"
Ci
.
nsIFile
this
.
_lastDir
)
;
}
}
reset
(
)
{
this
.
_lastDir
=
null
;
}
}
;
function
getLoadContext
(
)
{
return
window
.
docShell
.
QueryInterface
(
Ci
.
nsILoadContext
)
;
}
function
readFromClipboard
(
)
{
var
url
;
try
{
var
trans
=
Cc
[
"
mozilla
.
org
/
widget
/
transferable
;
1
"
]
.
createInstance
(
Ci
.
nsITransferable
)
;
trans
.
init
(
getLoadContext
(
)
)
;
trans
.
addDataFlavor
(
"
text
/
plain
"
)
;
let
clipboard
=
Services
.
clipboard
;
if
(
clipboard
.
isClipboardTypeSupported
(
clipboard
.
kSelectionClipboard
)
)
{
clipboard
.
getData
(
trans
clipboard
.
kSelectionClipboard
)
;
}
else
{
clipboard
.
getData
(
trans
clipboard
.
kGlobalClipboard
)
;
}
var
data
=
{
}
;
trans
.
getTransferData
(
"
text
/
plain
"
data
)
;
if
(
data
)
{
data
=
data
.
value
.
QueryInterface
(
Ci
.
nsISupportsString
)
;
url
=
data
.
data
;
}
}
catch
(
ex
)
{
}
return
url
;
}
function
UpdateUrlbarSearchSplitterState
(
)
{
var
splitter
=
document
.
getElementById
(
"
urlbar
-
search
-
splitter
"
)
;
var
urlbar
=
document
.
getElementById
(
"
urlbar
-
container
"
)
;
var
searchbar
=
document
.
getElementById
(
"
search
-
container
"
)
;
if
(
document
.
documentElement
.
hasAttribute
(
"
customizing
"
)
)
{
if
(
splitter
)
{
splitter
.
remove
(
)
;
}
return
;
}
if
(
splitter
&
&
(
(
splitter
.
nextElementSibling
=
=
searchbar
&
&
splitter
.
previousElementSibling
=
=
urlbar
)
|
|
(
splitter
.
nextElementSibling
=
=
urlbar
&
&
splitter
.
previousElementSibling
=
=
searchbar
)
)
)
{
return
;
}
let
ibefore
=
null
;
let
resizebefore
=
"
none
"
;
let
resizeafter
=
"
none
"
;
if
(
urlbar
&
&
searchbar
)
{
if
(
urlbar
.
nextElementSibling
=
=
searchbar
)
{
resizeafter
=
"
sibling
"
;
ibefore
=
searchbar
;
}
else
if
(
searchbar
.
nextElementSibling
=
=
urlbar
)
{
resizebefore
=
"
sibling
"
;
ibefore
=
urlbar
;
}
}
if
(
ibefore
)
{
if
(
!
splitter
)
{
splitter
=
document
.
createXULElement
(
"
splitter
"
)
;
splitter
.
id
=
"
urlbar
-
search
-
splitter
"
;
splitter
.
setAttribute
(
"
resizebefore
"
resizebefore
)
;
splitter
.
setAttribute
(
"
resizeafter
"
resizeafter
)
;
splitter
.
setAttribute
(
"
skipintoolbarset
"
"
true
"
)
;
splitter
.
setAttribute
(
"
overflows
"
"
false
"
)
;
splitter
.
className
=
"
chromeclass
-
toolbar
-
additional
"
;
}
urlbar
.
parentNode
.
insertBefore
(
splitter
ibefore
)
;
}
else
if
(
splitter
)
{
splitter
.
remove
(
)
;
}
}
function
UpdatePopupNotificationsVisibility
(
)
{
if
(
!
Object
.
getOwnPropertyDescriptor
(
window
"
PopupNotifications
"
)
.
get
)
{
PopupNotifications
.
anchorVisibilityChange
(
)
;
}
PanelUI
?
.
updateNotifications
(
)
;
}
function
PageProxyClickHandler
(
aEvent
)
{
if
(
aEvent
.
button
=
=
1
&
&
Services
.
prefs
.
getBoolPref
(
"
middlemouse
.
paste
"
)
)
{
middleMousePaste
(
aEvent
)
;
}
}
var
BrowserOnClick
=
{
async
ignoreWarningLink
(
reason
blockedInfo
browsingContext
)
{
let
principal
=
Services
.
scriptSecurityManager
.
createContentPrincipal
(
Services
.
io
.
newURI
(
blockedInfo
.
uri
)
browsingContext
.
currentWindowGlobal
.
documentPrincipal
.
originAttributes
)
;
Services
.
perms
.
addFromPrincipal
(
principal
"
safe
-
browsing
"
Ci
.
nsIPermissionManager
.
ALLOW_ACTION
Ci
.
nsIPermissionManager
.
EXPIRE_SESSION
)
;
let
buttons
=
[
{
label
:
gNavigatorBundle
.
getString
(
"
safebrowsing
.
getMeOutOfHereButton
.
label
"
)
accessKey
:
gNavigatorBundle
.
getString
(
"
safebrowsing
.
getMeOutOfHereButton
.
accessKey
"
)
callback
(
)
{
getMeOutOfHere
(
browsingContext
)
;
}
}
]
;
let
title
;
if
(
reason
=
=
=
"
malware
"
)
{
let
reportUrl
=
gSafeBrowsing
.
getReportURL
(
"
MalwareMistake
"
blockedInfo
)
;
title
=
gNavigatorBundle
.
getString
(
"
safebrowsing
.
reportedAttackSite
"
)
;
if
(
reportUrl
)
{
buttons
[
1
]
=
{
label
:
gNavigatorBundle
.
getString
(
"
safebrowsing
.
notAnAttackButton
.
label
"
)
accessKey
:
gNavigatorBundle
.
getString
(
"
safebrowsing
.
notAnAttackButton
.
accessKey
"
)
callback
(
)
{
openTrustedLinkIn
(
reportUrl
"
tab
"
)
;
}
}
;
}
}
else
if
(
reason
=
=
=
"
phishing
"
)
{
let
reportUrl
=
gSafeBrowsing
.
getReportURL
(
"
PhishMistake
"
blockedInfo
)
;
title
=
gNavigatorBundle
.
getString
(
"
safebrowsing
.
deceptiveSite
"
)
;
if
(
reportUrl
)
{
buttons
[
1
]
=
{
label
:
gNavigatorBundle
.
getString
(
"
safebrowsing
.
notADeceptiveSiteButton
.
label
"
)
accessKey
:
gNavigatorBundle
.
getString
(
"
safebrowsing
.
notADeceptiveSiteButton
.
accessKey
"
)
callback
(
)
{
openTrustedLinkIn
(
reportUrl
"
tab
"
)
;
}
}
;
}
}
else
if
(
reason
=
=
=
"
unwanted
"
)
{
title
=
gNavigatorBundle
.
getString
(
"
safebrowsing
.
reportedUnwantedSite
"
)
;
}
else
if
(
reason
=
=
=
"
harmful
"
)
{
title
=
gNavigatorBundle
.
getString
(
"
safebrowsing
.
reportedHarmfulSite
"
)
;
}
await
SafeBrowsingNotificationBox
.
show
(
title
buttons
)
;
let
triggeringPrincipal
=
blockedInfo
.
triggeringPrincipal
|
|
_createNullPrincipalFromTabUserContextId
(
)
;
browsingContext
.
fixupAndLoadURIString
(
blockedInfo
.
uri
{
triggeringPrincipal
loadFlags
:
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_BYPASS_CLASSIFIER
}
)
;
}
}
;
function
getMeOutOfHere
(
browsingContext
)
{
browsingContext
.
top
.
fixupAndLoadURIString
(
getDefaultHomePage
(
)
{
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
}
)
;
}
function
getDefaultHomePage
(
)
{
let
url
=
BROWSER_NEW_TAB_URL
;
if
(
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
{
return
url
;
}
url
=
HomePage
.
getDefault
(
)
;
if
(
url
.
includes
(
"
|
"
)
)
{
url
=
url
.
split
(
"
|
"
)
[
0
]
;
}
return
url
;
}
function
getPEMString
(
cert
)
{
var
derb64
=
cert
.
getBase64DERString
(
)
;
var
wrapped
=
derb64
.
replace
(
/
(
\
S
{
64
}
(
?
!
)
)
/
g
"
1
\
r
\
n
"
)
;
return
(
"
-
-
-
-
-
BEGIN
CERTIFICATE
-
-
-
-
-
\
r
\
n
"
+
wrapped
+
"
\
r
\
n
-
-
-
-
-
END
CERTIFICATE
-
-
-
-
-
\
r
\
n
"
)
;
}
var
browserDragAndDrop
=
{
canDropLink
:
aEvent
=
>
Services
.
droppedLinkHandler
.
canDropLink
(
aEvent
true
)
dragOver
(
aEvent
)
{
if
(
this
.
canDropLink
(
aEvent
)
)
{
aEvent
.
preventDefault
(
)
;
}
}
getTriggeringPrincipal
(
aEvent
)
{
return
Services
.
droppedLinkHandler
.
getTriggeringPrincipal
(
aEvent
)
;
}
getCsp
(
aEvent
)
{
return
Services
.
droppedLinkHandler
.
getCsp
(
aEvent
)
;
}
validateURIsForDrop
(
aEvent
aURIs
)
{
return
Services
.
droppedLinkHandler
.
validateURIsForDrop
(
aEvent
aURIs
)
;
}
dropLinks
(
aEvent
aDisallowInherit
)
{
return
Services
.
droppedLinkHandler
.
dropLinks
(
aEvent
aDisallowInherit
)
;
}
}
;
var
homeButtonObserver
=
{
onDrop
(
aEvent
)
{
let
links
=
browserDragAndDrop
.
dropLinks
(
aEvent
true
)
;
if
(
links
.
length
)
{
let
urls
=
[
]
;
for
(
let
link
of
links
)
{
if
(
link
.
url
.
includes
(
"
|
"
)
)
{
urls
.
push
(
.
.
.
link
.
url
.
split
(
"
|
"
)
)
;
}
else
{
urls
.
push
(
link
.
url
)
;
}
}
try
{
browserDragAndDrop
.
validateURIsForDrop
(
aEvent
urls
)
;
}
catch
(
e
)
{
return
;
}
setTimeout
(
openHomeDialog
0
urls
.
join
(
"
|
"
)
)
;
}
}
onDragOver
(
aEvent
)
{
if
(
HomePage
.
locked
)
{
return
;
}
browserDragAndDrop
.
dragOver
(
aEvent
)
;
aEvent
.
dropEffect
=
"
link
"
;
}
}
;
function
openHomeDialog
(
aURL
)
{
var
promptTitle
=
gNavigatorBundle
.
getString
(
"
droponhometitle
"
)
;
var
promptMsg
;
if
(
aURL
.
includes
(
"
|
"
)
)
{
promptMsg
=
gNavigatorBundle
.
getString
(
"
droponhomemsgMultiple
"
)
;
}
else
{
promptMsg
=
gNavigatorBundle
.
getString
(
"
droponhomemsg
"
)
;
}
var
pressedVal
=
Services
.
prompt
.
confirmEx
(
window
promptTitle
promptMsg
Services
.
prompt
.
STD_YES_NO_BUTTONS
null
null
null
null
{
value
:
0
}
)
;
if
(
pressedVal
=
=
0
)
{
HomePage
.
set
(
aURL
)
.
catch
(
console
.
error
)
;
}
}
var
newTabButtonObserver
=
{
onDragOver
(
aEvent
)
{
browserDragAndDrop
.
dragOver
(
aEvent
)
;
}
async
onDrop
(
aEvent
)
{
let
links
=
browserDragAndDrop
.
dropLinks
(
aEvent
)
;
if
(
links
.
length
>
=
Services
.
prefs
.
getIntPref
(
"
browser
.
tabs
.
maxOpenBeforeWarn
"
)
)
{
let
answer
=
await
OpenInTabsUtils
.
promiseConfirmOpenInTabs
(
links
.
length
window
)
;
if
(
!
answer
)
{
return
;
}
}
let
where
=
aEvent
.
shiftKey
?
"
tabshifted
"
:
"
tab
"
;
let
triggeringPrincipal
=
browserDragAndDrop
.
getTriggeringPrincipal
(
aEvent
)
;
let
csp
=
browserDragAndDrop
.
getCsp
(
aEvent
)
;
for
(
let
link
of
links
)
{
if
(
link
.
url
)
{
let
data
=
await
UrlbarUtils
.
getShortcutOrURIAndPostData
(
link
.
url
)
;
openLinkIn
(
data
.
url
where
{
postData
:
data
.
postData
allowThirdPartyFixup
:
true
triggeringPrincipal
csp
}
)
;
}
}
}
}
;
var
newWindowButtonObserver
=
{
onDragOver
(
aEvent
)
{
browserDragAndDrop
.
dragOver
(
aEvent
)
;
}
async
onDrop
(
aEvent
)
{
let
links
=
browserDragAndDrop
.
dropLinks
(
aEvent
)
;
if
(
links
.
length
>
=
Services
.
prefs
.
getIntPref
(
"
browser
.
tabs
.
maxOpenBeforeWarn
"
)
)
{
let
answer
=
await
OpenInTabsUtils
.
promiseConfirmOpenInTabs
(
links
.
length
window
)
;
if
(
!
answer
)
{
return
;
}
}
let
triggeringPrincipal
=
browserDragAndDrop
.
getTriggeringPrincipal
(
aEvent
)
;
let
csp
=
browserDragAndDrop
.
getCsp
(
aEvent
)
;
for
(
let
link
of
links
)
{
if
(
link
.
url
)
{
let
data
=
await
UrlbarUtils
.
getShortcutOrURIAndPostData
(
link
.
url
)
;
openLinkIn
(
data
.
url
"
window
"
{
allowInheritPrincipal
:
true
postData
:
data
.
postData
allowThirdPartyFixup
:
true
triggeringPrincipal
csp
}
)
;
}
}
}
}
;
const
BrowserSearch
=
{
_searchInitComplete
:
false
init
(
)
{
Services
.
obs
.
addObserver
(
this
"
browser
-
search
-
engine
-
modified
"
)
;
}
delayedStartupInit
(
)
{
this
.
_updateURLBarPlaceholderFromDefaultEngine
(
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
true
)
.
then
(
(
)
=
>
{
this
.
_searchInitComplete
=
true
;
}
)
;
}
uninit
(
)
{
Services
.
obs
.
removeObserver
(
this
"
browser
-
search
-
engine
-
modified
"
)
;
}
observe
(
engine
topic
data
)
{
let
engineName
=
engine
.
wrappedJSObject
.
name
;
switch
(
data
)
{
case
"
engine
-
removed
"
:
this
.
_addMaybeOfferedEngine
(
engineName
)
;
break
;
case
"
engine
-
added
"
:
this
.
_removeMaybeOfferedEngine
(
engineName
)
;
break
;
case
"
engine
-
default
"
:
if
(
this
.
_searchInitComplete
&
&
!
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
{
this
.
_updateURLBarPlaceholder
(
engineName
false
)
;
}
break
;
case
"
engine
-
default
-
private
"
:
if
(
this
.
_searchInitComplete
&
&
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
{
this
.
_updateURLBarPlaceholder
(
engineName
true
)
;
}
break
;
}
}
_addMaybeOfferedEngine
(
engineName
)
{
let
selectedBrowserOffersEngine
=
false
;
for
(
let
browser
of
gBrowser
.
browsers
)
{
for
(
let
i
=
0
;
i
<
(
browser
.
hiddenEngines
|
|
[
]
)
.
length
;
i
+
+
)
{
if
(
browser
.
hiddenEngines
[
i
]
.
title
=
=
engineName
)
{
if
(
!
browser
.
engines
)
{
browser
.
engines
=
[
]
;
}
browser
.
engines
.
push
(
browser
.
hiddenEngines
[
i
]
)
;
browser
.
hiddenEngines
.
splice
(
i
1
)
;
if
(
browser
=
=
gBrowser
.
selectedBrowser
)
{
selectedBrowserOffersEngine
=
true
;
}
break
;
}
}
}
if
(
selectedBrowserOffersEngine
)
{
this
.
updateOpenSearchBadge
(
)
;
}
}
_removeMaybeOfferedEngine
(
engineName
)
{
let
selectedBrowserOffersEngine
=
false
;
for
(
let
browser
of
gBrowser
.
browsers
)
{
for
(
let
i
=
0
;
i
<
(
browser
.
engines
|
|
[
]
)
.
length
;
i
+
+
)
{
if
(
browser
.
engines
[
i
]
.
title
=
=
engineName
)
{
if
(
!
browser
.
hiddenEngines
)
{
browser
.
hiddenEngines
=
[
]
;
}
browser
.
hiddenEngines
.
push
(
browser
.
engines
[
i
]
)
;
browser
.
engines
.
splice
(
i
1
)
;
if
(
browser
=
=
gBrowser
.
selectedBrowser
)
{
selectedBrowserOffersEngine
=
true
;
}
break
;
}
}
}
if
(
selectedBrowserOffersEngine
)
{
this
.
updateOpenSearchBadge
(
)
;
}
}
initPlaceHolder
(
force
=
false
)
{
const
prefName
=
"
browser
.
urlbar
.
placeholderName
"
+
(
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
?
"
.
private
"
:
"
"
)
;
let
engineName
=
Services
.
prefs
.
getStringPref
(
prefName
"
"
)
;
if
(
engineName
|
|
force
)
{
this
.
_setURLBarPlaceholder
(
engineName
)
;
}
}
async
_updateURLBarPlaceholderFromDefaultEngine
(
isPrivate
delayUpdate
=
false
)
{
const
getDefault
=
isPrivate
?
Services
.
search
.
getDefaultPrivate
:
Services
.
search
.
getDefault
;
let
defaultEngine
=
await
getDefault
(
)
;
if
(
!
this
.
_searchInitComplete
)
{
SearchUIUtils
.
updatePlaceholderNamePreference
(
defaultEngine
isPrivate
)
;
}
this
.
_updateURLBarPlaceholder
(
defaultEngine
.
name
isPrivate
delayUpdate
)
;
}
_updateURLBarPlaceholder
(
engineName
isPrivate
delayUpdate
=
false
)
{
if
(
!
engineName
)
{
throw
new
Error
(
"
Expected
an
engineName
to
be
specified
"
)
;
}
const
engine
=
Services
.
search
.
getEngineByName
(
engineName
)
;
if
(
!
engine
.
isAppProvided
)
{
engineName
=
"
"
;
}
if
(
delayUpdate
&
&
!
gURLBar
.
value
)
{
let
placeholderUpdateListener
=
(
)
=
>
{
if
(
gURLBar
.
value
&
&
!
gURLBar
.
searchMode
)
{
this
.
_updateURLBarPlaceholderFromDefaultEngine
(
isPrivate
false
)
;
gURLBar
.
removeEventListener
(
"
input
"
placeholderUpdateListener
)
;
gBrowser
.
tabContainer
.
removeEventListener
(
"
TabSelect
"
placeholderUpdateListener
)
;
}
}
;
gURLBar
.
addEventListener
(
"
input
"
placeholderUpdateListener
)
;
gBrowser
.
tabContainer
.
addEventListener
(
"
TabSelect
"
placeholderUpdateListener
)
;
}
else
if
(
!
gURLBar
.
searchMode
)
{
this
.
_setURLBarPlaceholder
(
engineName
)
;
}
}
_setURLBarPlaceholder
(
name
)
{
document
.
l10n
.
setAttributes
(
gURLBar
.
inputField
name
?
"
urlbar
-
placeholder
-
with
-
name
"
:
"
urlbar
-
placeholder
"
name
?
{
name
}
:
undefined
)
;
}
addEngine
(
browser
engine
)
{
if
(
!
this
.
_searchInitComplete
)
{
return
;
}
if
(
browser
.
engines
)
{
if
(
browser
.
engines
.
some
(
e
=
>
e
.
title
=
=
engine
.
title
)
)
{
return
;
}
}
var
hidden
=
false
;
if
(
Services
.
search
.
getEngineByName
(
engine
.
title
)
)
{
hidden
=
true
;
}
var
engines
=
(
hidden
?
browser
.
hiddenEngines
:
browser
.
engines
)
|
|
[
]
;
engines
.
push
(
{
uri
:
engine
.
href
title
:
engine
.
title
get
icon
(
)
{
return
browser
.
mIconURL
;
}
}
)
;
if
(
hidden
)
{
browser
.
hiddenEngines
=
engines
;
}
else
{
browser
.
engines
=
engines
;
if
(
browser
=
=
gBrowser
.
selectedBrowser
)
{
this
.
updateOpenSearchBadge
(
)
;
}
}
}
updateOpenSearchBadge
(
)
{
gURLBar
.
addSearchEngineHelper
.
setEnginesFromBrowser
(
gBrowser
.
selectedBrowser
)
;
var
searchBar
=
this
.
searchBar
;
if
(
!
searchBar
)
{
return
;
}
var
engines
=
gBrowser
.
selectedBrowser
.
engines
;
if
(
engines
&
&
engines
.
length
)
{
searchBar
.
setAttribute
(
"
addengines
"
"
true
"
)
;
}
else
{
searchBar
.
removeAttribute
(
"
addengines
"
)
;
}
}
webSearch
:
function
BrowserSearch_webSearch
(
)
{
if
(
window
.
location
.
href
!
=
AppConstants
.
BROWSER_CHROME_URL
|
|
gURLBar
.
readOnly
)
{
let
win
=
URILoadingHelper
.
getTopWin
(
window
{
skipPopups
:
true
}
)
;
if
(
win
)
{
win
.
focus
(
)
;
win
.
BrowserSearch
.
webSearch
(
)
;
}
else
{
var
observer
=
function
(
subject
)
{
if
(
subject
=
=
win
)
{
BrowserSearch
.
webSearch
(
)
;
Services
.
obs
.
removeObserver
(
observer
"
browser
-
delayed
-
startup
-
finished
"
)
;
}
}
;
win
=
window
.
openDialog
(
AppConstants
.
BROWSER_CHROME_URL
"
_blank
"
"
chrome
all
dialog
=
no
"
"
about
:
blank
"
)
;
Services
.
obs
.
addObserver
(
observer
"
browser
-
delayed
-
startup
-
finished
"
)
;
}
return
;
}
let
focusUrlBarIfSearchFieldIsNotActive
=
function
(
aSearchBar
)
{
if
(
!
aSearchBar
|
|
document
.
activeElement
!
=
aSearchBar
.
textbox
)
{
gURLBar
.
searchModeShortcut
(
)
;
}
}
;
let
searchBar
=
this
.
searchBar
;
let
placement
=
CustomizableUI
.
getPlacementOfWidget
(
"
search
-
container
"
)
;
let
focusSearchBar
=
(
)
=
>
{
searchBar
=
this
.
searchBar
;
searchBar
.
select
(
)
;
focusUrlBarIfSearchFieldIsNotActive
(
searchBar
)
;
}
;
if
(
placement
&
&
searchBar
&
&
(
(
searchBar
.
parentNode
.
getAttribute
(
"
overflowedItem
"
)
=
=
"
true
"
&
&
placement
.
area
=
=
CustomizableUI
.
AREA_NAVBAR
)
|
|
placement
.
area
=
=
CustomizableUI
.
AREA_FIXED_OVERFLOW_PANEL
)
)
{
let
navBar
=
document
.
getElementById
(
CustomizableUI
.
AREA_NAVBAR
)
;
navBar
.
overflowable
.
show
(
)
.
then
(
focusSearchBar
)
;
return
;
}
if
(
searchBar
)
{
if
(
window
.
fullScreen
)
{
FullScreen
.
showNavToolbox
(
)
;
}
searchBar
.
select
(
)
;
}
focusUrlBarIfSearchFieldIsNotActive
(
searchBar
)
;
}
async
_loadSearch
(
searchText
where
usePrivate
purpose
triggeringPrincipal
csp
inBackground
=
false
engine
=
null
tab
=
null
)
{
if
(
!
triggeringPrincipal
)
{
throw
new
Error
(
"
Required
argument
triggeringPrincipal
missing
within
_loadSearch
"
)
;
}
if
(
!
engine
)
{
engine
=
usePrivate
?
await
Services
.
search
.
getDefaultPrivate
(
)
:
await
Services
.
search
.
getDefault
(
)
;
}
let
submission
=
engine
.
getSubmission
(
searchText
null
purpose
)
;
if
(
!
submission
)
{
return
null
;
}
openLinkIn
(
submission
.
uri
.
spec
where
|
|
"
current
"
{
private
:
usePrivate
&
&
!
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
postData
:
submission
.
postData
inBackground
relatedToCurrent
:
true
triggeringPrincipal
csp
targetBrowser
:
tab
?
.
linkedBrowser
globalHistoryOptions
:
{
triggeringSearchEngine
:
engine
.
name
}
}
)
;
return
{
engine
url
:
submission
.
uri
}
;
}
async
loadSearchFromContext
(
terms
usePrivate
triggeringPrincipal
csp
event
)
{
event
=
BrowserUtils
.
getRootEvent
(
event
)
;
let
where
=
BrowserUtils
.
whereToOpenLink
(
event
)
;
if
(
where
=
=
"
current
"
)
{
where
=
"
tab
"
;
}
if
(
usePrivate
&
&
!
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
{
where
=
"
window
"
;
}
let
inBackground
=
Services
.
prefs
.
getBoolPref
(
"
browser
.
search
.
context
.
loadInBackground
"
)
;
if
(
event
.
button
=
=
1
|
|
event
.
ctrlKey
)
{
inBackground
=
!
inBackground
;
}
let
{
engine
}
=
await
BrowserSearch
.
_loadSearch
(
terms
where
usePrivate
"
contextmenu
"
Services
.
scriptSecurityManager
.
createNullPrincipal
(
triggeringPrincipal
.
originAttributes
)
csp
inBackground
)
;
if
(
engine
)
{
BrowserSearchTelemetry
.
recordSearch
(
gBrowser
.
selectedBrowser
engine
"
contextmenu
"
)
;
}
}
async
loadSearchFromCommandLine
(
terms
usePrivate
triggeringPrincipal
csp
)
{
let
{
engine
}
=
await
BrowserSearch
.
_loadSearch
(
terms
"
current
"
usePrivate
"
system
"
triggeringPrincipal
csp
)
;
if
(
engine
)
{
BrowserSearchTelemetry
.
recordSearch
(
gBrowser
.
selectedBrowser
engine
"
system
"
)
;
}
}
async
loadSearchFromExtension
(
{
query
engine
where
tab
triggeringPrincipal
}
)
{
const
result
=
await
BrowserSearch
.
_loadSearch
(
query
where
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
"
webextension
"
triggeringPrincipal
null
false
engine
tab
)
;
BrowserSearchTelemetry
.
recordSearch
(
gBrowser
.
selectedBrowser
result
.
engine
"
webextension
"
)
;
}
get
searchBar
(
)
{
return
document
.
getElementById
(
"
searchbar
"
)
;
}
async
removalOfSearchEngineNotificationBox
(
oldEngine
newEngine
)
{
let
buttons
=
[
{
"
l10n
-
id
"
:
"
remove
-
search
-
engine
-
button
"
primary
:
true
callback
(
)
{
const
notificationBox
=
gNotificationBox
.
getNotificationWithValue
(
"
search
-
engine
-
removal
"
)
;
gNotificationBox
.
removeNotification
(
notificationBox
)
;
}
}
{
supportPage
:
"
search
-
engine
-
removal
"
}
]
;
await
gNotificationBox
.
appendNotification
(
"
search
-
engine
-
removal
"
{
label
:
{
"
l10n
-
id
"
:
"
removed
-
search
-
engine
-
message2
"
"
l10n
-
args
"
:
{
oldEngine
newEngine
}
}
priority
:
gNotificationBox
.
PRIORITY_SYSTEM
}
buttons
)
;
this
.
_updateURLBarPlaceholderFromDefaultEngine
(
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
false
)
.
catch
(
console
.
error
)
;
}
}
;
XPCOMUtils
.
defineConstant
(
this
"
BrowserSearch
"
BrowserSearch
)
;
function
CreateContainerTabMenu
(
event
)
{
if
(
event
.
target
.
triggerNode
?
.
closest
(
"
menupopup
"
)
)
{
event
.
preventDefault
(
)
;
return
;
}
createUserContextMenu
(
event
{
useAccessKeys
:
false
showDefaultTab
:
true
}
)
;
}
function
FillHistoryMenu
(
event
)
{
let
parent
=
event
.
target
;
if
(
!
parent
.
hasStatusListener
)
{
parent
.
addEventListener
(
"
DOMMenuItemActive
"
function
(
aEvent
)
{
if
(
!
aEvent
.
target
.
hasAttribute
(
"
checked
"
)
)
{
XULBrowserWindow
.
setOverLink
(
aEvent
.
target
.
getAttribute
(
"
uri
"
)
)
;
}
}
)
;
parent
.
addEventListener
(
"
DOMMenuItemInactive
"
function
(
)
{
XULBrowserWindow
.
setOverLink
(
"
"
)
;
}
)
;
parent
.
hasStatusListener
=
true
;
}
let
children
=
parent
.
children
;
for
(
var
i
=
children
.
length
-
1
;
i
>
=
0
;
-
-
i
)
{
if
(
children
[
i
]
.
hasAttribute
(
"
index
"
)
)
{
parent
.
removeChild
(
children
[
i
]
)
;
}
}
const
MAX_HISTORY_MENU_ITEMS
=
15
;
const
tooltipBack
=
gNavigatorBundle
.
getString
(
"
tabHistory
.
goBack
"
)
;
const
tooltipCurrent
=
gNavigatorBundle
.
getString
(
"
tabHistory
.
reloadCurrent
"
)
;
const
tooltipForward
=
gNavigatorBundle
.
getString
(
"
tabHistory
.
goForward
"
)
;
function
updateSessionHistory
(
sessionHistory
initial
ssInParent
)
{
let
count
=
ssInParent
?
sessionHistory
.
count
:
sessionHistory
.
entries
.
length
;
if
(
!
initial
)
{
if
(
count
<
=
1
)
{
parent
.
hidePopup
(
)
;
return
;
}
else
if
(
parent
.
id
!
=
"
backForwardMenu
"
&
&
!
parent
.
parentNode
.
open
)
{
parent
.
parentNode
.
open
=
true
;
return
;
}
}
let
index
=
sessionHistory
.
index
;
let
half_length
=
Math
.
floor
(
MAX_HISTORY_MENU_ITEMS
/
2
)
;
let
start
=
Math
.
max
(
index
-
half_length
0
)
;
let
end
=
Math
.
min
(
start
=
=
0
?
MAX_HISTORY_MENU_ITEMS
:
index
+
half_length
+
1
count
)
;
if
(
end
=
=
count
)
{
start
=
Math
.
max
(
count
-
MAX_HISTORY_MENU_ITEMS
0
)
;
}
let
existingIndex
=
0
;
for
(
let
j
=
end
-
1
;
j
>
=
start
;
j
-
-
)
{
let
entry
=
ssInParent
?
sessionHistory
.
getEntryAtIndex
(
j
)
:
sessionHistory
.
entries
[
j
]
;
if
(
BrowserUtils
.
navigationRequireUserInteraction
&
&
entry
.
hasUserInteraction
=
=
=
false
&
&
j
!
=
end
-
1
&
&
j
!
=
start
&
&
j
!
=
index
)
{
continue
;
}
let
uri
=
ssInParent
?
entry
.
URI
.
spec
:
entry
.
url
;
let
item
=
existingIndex
<
children
.
length
?
children
[
existingIndex
]
:
document
.
createXULElement
(
"
menuitem
"
)
;
item
.
setAttribute
(
"
uri
"
uri
)
;
item
.
setAttribute
(
"
label
"
entry
.
title
|
|
uri
)
;
item
.
setAttribute
(
"
index
"
j
)
;
item
.
setAttribute
(
"
historyindex
"
j
-
index
)
;
if
(
j
!
=
index
)
{
item
.
style
.
listStyleImage
=
url
(
page
-
icon
:
{
uri
}
)
;
}
if
(
j
<
index
)
{
item
.
className
=
"
unified
-
nav
-
back
menuitem
-
iconic
menuitem
-
with
-
favicon
"
;
item
.
setAttribute
(
"
tooltiptext
"
tooltipBack
)
;
}
else
if
(
j
=
=
index
)
{
item
.
setAttribute
(
"
type
"
"
radio
"
)
;
item
.
setAttribute
(
"
checked
"
"
true
"
)
;
item
.
className
=
"
unified
-
nav
-
current
"
;
item
.
setAttribute
(
"
tooltiptext
"
tooltipCurrent
)
;
}
else
{
item
.
className
=
"
unified
-
nav
-
forward
menuitem
-
iconic
menuitem
-
with
-
favicon
"
;
item
.
setAttribute
(
"
tooltiptext
"
tooltipForward
)
;
}
if
(
!
item
.
parentNode
)
{
parent
.
appendChild
(
item
)
;
}
existingIndex
+
+
;
}
if
(
!
initial
)
{
let
existingLength
=
children
.
length
;
while
(
existingIndex
<
existingLength
)
{
parent
.
removeChild
(
parent
.
lastElementChild
)
;
existingIndex
+
+
;
}
}
}
let
sessionHistory
=
gBrowser
.
selectedBrowser
.
browsingContext
.
sessionHistory
;
if
(
sessionHistory
?
.
count
)
{
if
(
sessionHistory
.
count
<
=
1
)
{
event
.
preventDefault
(
)
;
return
;
}
updateSessionHistory
(
sessionHistory
true
true
)
;
}
else
{
sessionHistory
=
SessionStore
.
getSessionHistory
(
gBrowser
.
selectedTab
updateSessionHistory
)
;
updateSessionHistory
(
sessionHistory
true
false
)
;
}
}
function
toOpenWindowByType
(
inType
uri
features
)
{
var
topWindow
=
Services
.
wm
.
getMostRecentWindow
(
inType
)
;
if
(
topWindow
)
{
topWindow
.
focus
(
)
;
}
else
if
(
features
)
{
window
.
open
(
uri
"
_blank
"
features
)
;
}
else
{
window
.
open
(
uri
"
_blank
"
"
chrome
extrachrome
menubar
resizable
scrollbars
status
toolbar
"
)
;
}
}
function
OpenBrowserWindow
(
options
=
{
}
)
{
let
telemetryObj
=
{
}
;
TelemetryStopwatch
.
start
(
"
FX_NEW_WINDOW_MS
"
telemetryObj
)
;
let
win
=
BrowserWindowTracker
.
openWindow
(
{
openerWindow
:
window
.
.
.
options
}
)
;
win
.
addEventListener
(
"
MozAfterPaint
"
(
)
=
>
{
TelemetryStopwatch
.
finish
(
"
FX_NEW_WINDOW_MS
"
telemetryObj
)
;
}
{
once
:
true
}
)
;
return
win
;
}
function
updateEditUIVisibility
(
)
{
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
return
;
}
let
editMenuPopupState
=
document
.
getElementById
(
"
menu_EditPopup
"
)
.
state
;
let
contextMenuPopupState
=
document
.
getElementById
(
"
contentAreaContextMenu
"
)
.
state
;
let
placesContextMenuPopupState
=
document
.
getElementById
(
"
placesContext
"
)
.
state
;
let
oldVisible
=
gEditUIVisible
;
gEditUIVisible
=
editMenuPopupState
=
=
"
showing
"
|
|
editMenuPopupState
=
=
"
open
"
|
|
contextMenuPopupState
=
=
"
showing
"
|
|
contextMenuPopupState
=
=
"
open
"
|
|
placesContextMenuPopupState
=
=
"
showing
"
|
|
placesContextMenuPopupState
=
=
"
open
"
;
const
kOpenPopupStates
=
[
"
showing
"
"
open
"
]
;
if
(
!
gEditUIVisible
)
{
let
placement
=
CustomizableUI
.
getPlacementOfWidget
(
"
edit
-
controls
"
)
;
let
areaType
=
placement
?
CustomizableUI
.
getAreaType
(
placement
.
area
)
:
"
"
;
if
(
areaType
=
=
CustomizableUI
.
TYPE_PANEL
)
{
let
customizablePanel
=
PanelUI
.
overflowPanel
;
gEditUIVisible
=
kOpenPopupStates
.
includes
(
customizablePanel
.
state
)
;
}
else
if
(
areaType
=
=
CustomizableUI
.
TYPE_TOOLBAR
&
&
window
.
toolbar
.
visible
)
{
if
(
placement
.
area
=
=
"
nav
-
bar
"
)
{
let
editControls
=
document
.
getElementById
(
"
edit
-
controls
"
)
;
gEditUIVisible
=
!
editControls
.
hasAttribute
(
"
overflowedItem
"
)
|
|
kOpenPopupStates
.
includes
(
document
.
getElementById
(
"
widget
-
overflow
"
)
.
state
)
;
}
else
{
gEditUIVisible
=
true
;
}
}
}
if
(
!
gEditUIVisible
)
{
gEditUIVisible
=
kOpenPopupStates
.
includes
(
PanelUI
.
panel
.
state
)
;
}
if
(
gEditUIVisible
=
=
oldVisible
)
{
return
;
}
if
(
gEditUIVisible
)
{
goUpdateGlobalEditMenuItems
(
)
;
}
else
{
goSetCommandEnabled
(
"
cmd_undo
"
true
)
;
goSetCommandEnabled
(
"
cmd_redo
"
true
)
;
goSetCommandEnabled
(
"
cmd_cut
"
true
)
;
goSetCommandEnabled
(
"
cmd_copy
"
true
)
;
goSetCommandEnabled
(
"
cmd_paste
"
true
)
;
goSetCommandEnabled
(
"
cmd_selectAll
"
true
)
;
goSetCommandEnabled
(
"
cmd_delete
"
true
)
;
goSetCommandEnabled
(
"
cmd_switchTextDirection
"
true
)
;
}
}
let
gFileMenu
=
{
updateUserContextUIVisibility
(
)
{
let
menu
=
document
.
getElementById
(
"
menu_newUserContext
"
)
;
menu
.
hidden
=
!
Services
.
prefs
.
getBoolPref
(
"
privacy
.
userContext
.
enabled
"
false
)
;
if
(
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
{
menu
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
}
updateImportCommandEnabledState
(
)
{
if
(
!
Services
.
policies
.
isAllowed
(
"
profileImport
"
)
)
{
document
.
getElementById
(
"
cmd_file_importFromAnotherBrowser
"
)
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
}
updateTabCloseCountState
(
)
{
document
.
l10n
.
setAttributes
(
document
.
getElementById
(
"
menu_close
"
)
"
menu
-
file
-
close
-
tab
"
{
tabCount
:
gBrowser
.
selectedTabs
.
length
}
)
;
}
onPopupShowing
(
event
)
{
if
(
event
.
target
.
id
!
=
"
menu_FilePopup
"
)
{
return
;
}
this
.
updateUserContextUIVisibility
(
)
;
this
.
updateImportCommandEnabledState
(
)
;
this
.
updateTabCloseCountState
(
)
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
gShareUtils
.
updateShareURLMenuItem
(
gBrowser
.
selectedBrowser
document
.
getElementById
(
"
menu_savePage
"
)
)
;
}
PrintUtils
.
updatePrintSetupMenuHiddenState
(
)
;
}
}
;
let
gShareUtils
=
{
updateShareURLMenuItem
(
browser
insertAfterEl
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
"
browser
.
menu
.
share_url
.
allow
"
true
)
)
{
return
;
}
if
(
AppConstants
.
platform
!
=
"
macosx
"
&
&
AppConstants
.
platform
!
=
"
win
"
)
{
return
;
}
let
shareURL
=
insertAfterEl
.
nextElementSibling
;
if
(
!
shareURL
?
.
matches
(
"
.
share
-
tab
-
url
-
item
"
)
)
{
shareURL
=
this
.
_createShareURLMenuItem
(
insertAfterEl
)
;
}
shareURL
.
browserToShare
=
Cu
.
getWeakReference
(
browser
)
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
shareURL
.
hidden
=
!
BrowserUtils
.
getShareableURL
(
browser
.
currentURI
)
;
}
}
_createShareURLMenuItem
(
insertAfterEl
)
{
let
menu
=
insertAfterEl
.
parentNode
;
let
shareURL
=
null
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
shareURL
=
this
.
_buildShareURLItem
(
menu
.
id
)
;
}
else
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
shareURL
=
this
.
_buildShareURLMenu
(
menu
.
id
)
;
}
shareURL
.
className
=
"
share
-
tab
-
url
-
item
"
;
let
l10nID
=
menu
.
id
=
=
"
tabContextMenu
"
?
"
tab
-
context
-
share
-
url
"
:
"
menu
-
file
-
share
-
url
"
;
document
.
l10n
.
setAttributes
(
shareURL
l10nID
)
;
menu
.
insertBefore
(
shareURL
insertAfterEl
.
nextSibling
)
;
return
shareURL
;
}
_buildShareURLItem
(
)
{
let
shareURLMenuItem
=
document
.
createXULElement
(
"
menuitem
"
)
;
shareURLMenuItem
.
addEventListener
(
"
command
"
this
)
;
return
shareURLMenuItem
;
}
_buildShareURLMenu
(
)
{
let
menu
=
document
.
createXULElement
(
"
menu
"
)
;
let
menuPopup
=
document
.
createXULElement
(
"
menupopup
"
)
;
menuPopup
.
addEventListener
(
"
popupshowing
"
this
)
;
menu
.
appendChild
(
menuPopup
)
;
return
menu
;
}
getDataToShare
(
node
)
{
let
browser
=
node
.
browserToShare
?
.
get
(
)
;
let
urlToShare
=
null
;
let
titleToShare
=
null
;
if
(
browser
)
{
let
maybeToShare
=
BrowserUtils
.
getShareableURL
(
browser
.
currentURI
)
;
if
(
maybeToShare
)
{
urlToShare
=
maybeToShare
;
titleToShare
=
browser
.
contentTitle
;
}
}
return
{
urlToShare
titleToShare
}
;
}
initializeShareURLPopup
(
menuPopup
)
{
if
(
AppConstants
.
platform
!
=
"
macosx
"
)
{
return
;
}
while
(
menuPopup
.
firstChild
)
{
menuPopup
.
firstChild
.
remove
(
)
;
}
let
{
urlToShare
}
=
this
.
getDataToShare
(
menuPopup
.
parentNode
)
;
let
shouldEnable
=
!
!
urlToShare
;
if
(
!
urlToShare
)
{
urlToShare
=
makeURI
(
"
https
:
/
/
mozilla
.
org
/
"
)
;
}
let
sharingService
=
gBrowser
.
MacSharingService
;
let
currentURI
=
gURLBar
.
makeURIReadable
(
urlToShare
)
.
displaySpec
;
let
services
=
sharingService
.
getSharingProviders
(
currentURI
)
;
services
.
forEach
(
share
=
>
{
let
item
=
document
.
createXULElement
(
"
menuitem
"
)
;
item
.
classList
.
add
(
"
menuitem
-
iconic
"
)
;
item
.
setAttribute
(
"
label
"
share
.
menuItemTitle
)
;
item
.
setAttribute
(
"
share
-
name
"
share
.
name
)
;
item
.
setAttribute
(
"
image
"
share
.
image
)
;
if
(
!
shouldEnable
)
{
item
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
menuPopup
.
appendChild
(
item
)
;
}
)
;
menuPopup
.
appendChild
(
document
.
createXULElement
(
"
menuseparator
"
)
)
;
let
moreItem
=
document
.
createXULElement
(
"
menuitem
"
)
;
document
.
l10n
.
setAttributes
(
moreItem
"
menu
-
share
-
more
"
)
;
moreItem
.
classList
.
add
(
"
menuitem
-
iconic
"
"
share
-
more
-
button
"
)
;
menuPopup
.
appendChild
(
moreItem
)
;
menuPopup
.
addEventListener
(
"
command
"
this
)
;
menuPopup
.
parentNode
.
closest
(
"
menupopup
"
)
.
addEventListener
(
"
popuphiding
"
this
)
;
menuPopup
.
setAttribute
(
"
data
-
initialized
"
true
)
;
}
onShareURLCommand
(
event
)
{
let
target
=
event
.
target
.
closest
(
"
.
share
-
tab
-
url
-
item
"
)
;
if
(
!
target
)
{
return
;
}
if
(
event
.
target
.
classList
.
contains
(
"
share
-
more
-
button
"
)
)
{
gBrowser
.
MacSharingService
.
openSharingPreferences
(
)
;
return
;
}
let
{
urlToShare
titleToShare
}
=
this
.
getDataToShare
(
target
)
;
let
currentURI
=
gURLBar
.
makeURIReadable
(
urlToShare
)
.
displaySpec
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
WindowsUIUtils
.
shareUrl
(
currentURI
titleToShare
)
;
return
;
}
let
shareName
=
event
.
target
.
getAttribute
(
"
share
-
name
"
)
;
if
(
shareName
)
{
gBrowser
.
MacSharingService
.
shareUrl
(
shareName
currentURI
titleToShare
)
;
}
}
onPopupHiding
(
event
)
{
if
(
event
.
target
.
parentNode
.
closest
(
"
menupopup
"
)
)
{
return
;
}
let
menupopup
=
event
.
target
.
querySelector
(
"
.
share
-
tab
-
url
-
item
"
)
?
.
menupopup
;
menupopup
?
.
removeAttribute
(
"
data
-
initialized
"
)
;
event
.
target
.
removeEventListener
(
"
popuphiding
"
this
)
;
}
onPopupShowing
(
event
)
{
if
(
!
event
.
target
.
hasAttribute
(
"
data
-
initialized
"
)
)
{
this
.
initializeShareURLPopup
(
event
.
target
)
;
}
}
handleEvent
(
aEvent
)
{
switch
(
aEvent
.
type
)
{
case
"
command
"
:
this
.
onShareURLCommand
(
aEvent
)
;
break
;
case
"
popuphiding
"
:
this
.
onPopupHiding
(
aEvent
)
;
break
;
case
"
popupshowing
"
:
this
.
onPopupShowing
(
aEvent
)
;
break
;
}
}
}
;
function
openNewUserContextTab
(
event
)
{
openTrustedLinkIn
(
BROWSER_NEW_TAB_URL
"
tab
"
{
userContextId
:
parseInt
(
event
.
target
.
getAttribute
(
"
data
-
usercontextid
"
)
)
}
)
;
}
var
XULBrowserWindow
=
{
status
:
"
"
defaultStatus
:
"
"
overLink
:
"
"
startTime
:
0
isBusy
:
false
busyUI
:
false
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIWebProgressListener
"
"
nsIWebProgressListener2
"
"
nsISupportsWeakReference
"
"
nsIXULBrowserWindow
"
]
)
get
stopCommand
(
)
{
delete
this
.
stopCommand
;
return
(
this
.
stopCommand
=
document
.
getElementById
(
"
Browser
:
Stop
"
)
)
;
}
get
reloadCommand
(
)
{
delete
this
.
reloadCommand
;
return
(
this
.
reloadCommand
=
document
.
getElementById
(
"
Browser
:
Reload
"
)
)
;
}
get
_elementsForTextBasedTypes
(
)
{
delete
this
.
_elementsForTextBasedTypes
;
return
(
this
.
_elementsForTextBasedTypes
=
[
document
.
getElementById
(
"
pageStyleMenu
"
)
document
.
getElementById
(
"
context
-
viewpartialsource
-
selection
"
)
document
.
getElementById
(
"
context
-
print
-
selection
"
)
]
)
;
}
get
_elementsForFind
(
)
{
delete
this
.
_elementsForFind
;
return
(
this
.
_elementsForFind
=
[
document
.
getElementById
(
"
cmd_find
"
)
document
.
getElementById
(
"
cmd_findAgain
"
)
document
.
getElementById
(
"
cmd_findPrevious
"
)
]
)
;
}
get
_elementsForViewSource
(
)
{
delete
this
.
_elementsForViewSource
;
return
(
this
.
_elementsForViewSource
=
[
document
.
getElementById
(
"
context
-
viewsource
"
)
document
.
getElementById
(
"
View
:
PageSource
"
)
]
)
;
}
get
_menuItemForRepairTextEncoding
(
)
{
delete
this
.
_menuItemForRepairTextEncoding
;
return
(
this
.
_menuItemForRepairTextEncoding
=
document
.
getElementById
(
"
repair
-
text
-
encoding
"
)
)
;
}
get
_menuItemForTranslations
(
)
{
delete
this
.
_menuItemForTranslations
;
return
(
this
.
_menuItemForTranslations
=
document
.
getElementById
(
"
cmd_translate
"
)
)
;
}
setDefaultStatus
(
status
)
{
this
.
defaultStatus
=
status
;
StatusPanel
.
update
(
)
;
}
setOverLink
(
url
options
=
undefined
)
{
if
(
url
)
{
url
=
Services
.
textToSubURI
.
unEscapeURIForUI
(
url
)
;
url
=
url
.
replace
(
/
[
\
u200e
\
u200f
\
u202a
\
u202b
\
u202c
\
u202d
\
u202e
]
/
g
encodeURIComponent
)
;
if
(
UrlbarPrefs
.
get
(
"
trimURLs
"
)
)
{
url
=
BrowserUIUtils
.
trimURL
(
url
)
;
}
}
this
.
overLink
=
url
;
LinkTargetDisplay
.
update
(
options
)
;
}
onEnterDOMFullscreen
(
)
{
this
.
status
=
"
"
;
this
.
setDefaultStatus
(
"
"
)
;
this
.
setOverLink
(
"
"
{
hideStatusPanelImmediately
:
true
}
)
;
}
showTooltip
(
xDevPix
yDevPix
tooltip
direction
_browser
)
{
if
(
Cc
[
"
mozilla
.
org
/
widget
/
dragservice
;
1
"
]
.
getService
(
Ci
.
nsIDragService
)
.
getCurrentSession
(
)
)
{
return
;
}
if
(
!
document
.
hasFocus
(
)
)
{
return
;
}
let
elt
=
document
.
getElementById
(
"
remoteBrowserTooltip
"
)
;
elt
.
label
=
tooltip
;
elt
.
style
.
direction
=
direction
;
elt
.
openPopupAtScreen
(
xDevPix
/
window
.
devicePixelRatio
yDevPix
/
window
.
devicePixelRatio
false
null
)
;
}
hideTooltip
(
)
{
let
elt
=
document
.
getElementById
(
"
remoteBrowserTooltip
"
)
;
elt
.
hidePopup
(
)
;
}
getTabCount
(
)
{
return
gBrowser
.
tabs
.
length
;
}
onProgressChange
(
)
{
}
onProgressChange64
(
aWebProgress
aRequest
aCurSelfProgress
aMaxSelfProgress
aCurTotalProgress
aMaxTotalProgress
)
{
return
this
.
onProgressChange
(
aWebProgress
aRequest
aCurSelfProgress
aMaxSelfProgress
aCurTotalProgress
aMaxTotalProgress
)
;
}
onStateChange
(
aWebProgress
aRequest
aStateFlags
aStatus
)
{
const
nsIWebProgressListener
=
Ci
.
nsIWebProgressListener
;
let
browser
=
gBrowser
.
selectedBrowser
;
gProtectionsHandler
.
onStateChange
(
aWebProgress
aStateFlags
)
;
if
(
aStateFlags
&
nsIWebProgressListener
.
STATE_START
&
&
aStateFlags
&
nsIWebProgressListener
.
STATE_IS_NETWORK
)
{
if
(
aRequest
&
&
aWebProgress
.
isTopLevel
)
{
browser
.
engines
=
null
;
}
this
.
isBusy
=
true
;
if
(
!
(
aStateFlags
&
nsIWebProgressListener
.
STATE_RESTORING
)
&
&
aWebProgress
.
isTopLevel
)
{
this
.
busyUI
=
true
;
if
(
this
.
spinCursorWhileBusy
)
{
window
.
setCursor
(
"
progress
"
)
;
}
this
.
stopCommand
.
removeAttribute
(
"
disabled
"
)
;
CombinedStopReload
.
switchToStop
(
aRequest
aWebProgress
)
;
}
}
else
if
(
aStateFlags
&
nsIWebProgressListener
.
STATE_STOP
)
{
if
(
aRequest
)
{
let
msg
=
"
"
;
let
location
;
let
canViewSource
=
true
;
if
(
aRequest
instanceof
Ci
.
nsIChannel
|
|
"
URI
"
in
aRequest
)
{
location
=
aRequest
.
URI
;
if
(
location
.
scheme
=
=
"
keyword
"
&
&
aWebProgress
.
isTopLevel
)
{
gBrowser
.
userTypedValue
=
null
;
}
canViewSource
=
location
.
scheme
!
=
"
view
-
source
"
;
if
(
location
.
spec
!
=
"
about
:
blank
"
)
{
switch
(
aStatus
)
{
case
Cr
.
NS_ERROR_NET_TIMEOUT
:
msg
=
gNavigatorBundle
.
getString
(
"
nv_timeout
"
)
;
break
;
}
}
}
this
.
status
=
"
"
;
this
.
setDefaultStatus
(
msg
)
;
let
isText
=
browser
.
documentContentType
&
&
BrowserUtils
.
mimeTypeIsTextBased
(
browser
.
documentContentType
)
;
for
(
let
element
of
this
.
_elementsForViewSource
)
{
if
(
canViewSource
&
&
isText
)
{
element
.
removeAttribute
(
"
disabled
"
)
;
}
else
{
element
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
}
this
.
_updateElementsForContentType
(
)
;
let
button
=
document
.
getElementById
(
"
characterencoding
-
button
"
)
;
if
(
browser
.
mayEnableCharacterEncodingMenu
)
{
this
.
_menuItemForRepairTextEncoding
.
removeAttribute
(
"
disabled
"
)
;
button
?
.
removeAttribute
(
"
disabled
"
)
;
}
else
{
this
.
_menuItemForRepairTextEncoding
.
setAttribute
(
"
disabled
"
"
true
"
)
;
button
?
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
}
this
.
isBusy
=
false
;
if
(
this
.
busyUI
&
&
aWebProgress
.
isTopLevel
)
{
this
.
busyUI
=
false
;
if
(
this
.
spinCursorWhileBusy
)
{
window
.
setCursor
(
"
auto
"
)
;
}
this
.
stopCommand
.
setAttribute
(
"
disabled
"
"
true
"
)
;
CombinedStopReload
.
switchToReload
(
aRequest
aWebProgress
)
;
}
}
}
onLocationChange
(
aWebProgress
aRequest
aLocationURI
aFlags
aIsSimulated
)
{
var
location
=
aLocationURI
?
aLocationURI
.
spec
:
"
"
;
UpdateBackForwardCommands
(
gBrowser
.
webNavigation
)
;
Services
.
obs
.
notifyObservers
(
aWebProgress
"
touchbar
-
location
-
change
"
location
)
;
if
(
!
aWebProgress
.
isTopLevel
)
{
return
;
}
this
.
setOverLink
(
"
"
{
hideStatusPanelImmediately
:
true
}
)
;
let
isSameDocument
=
aFlags
&
Ci
.
nsIWebProgressListener
.
LOCATION_CHANGE_SAME_DOCUMENT
;
if
(
(
location
=
=
"
about
:
blank
"
&
&
BrowserUIUtils
.
checkEmptyPageOrigin
(
gBrowser
.
selectedBrowser
)
)
|
|
location
=
=
"
"
)
{
this
.
reloadCommand
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
else
{
this
.
reloadCommand
.
removeAttribute
(
"
disabled
"
)
;
}
let
isSessionRestore
=
!
!
(
aFlags
&
Ci
.
nsIWebProgressListener
.
LOCATION_CHANGE_SESSION_STORE
)
;
gURLBar
.
setURI
(
aLocationURI
aIsSimulated
isSessionRestore
false
isSameDocument
)
;
BookmarkingUI
.
onLocationChange
(
)
;
if
(
!
isSameDocument
)
{
updateBookmarkToolbarVisibility
(
)
;
}
let
closeOpenPanels
=
selector
=
>
{
for
(
let
panel
of
document
.
querySelectorAll
(
selector
)
)
{
if
(
panel
.
state
!
=
"
closed
"
)
{
panel
.
hidePopup
(
)
;
}
}
}
;
if
(
aIsSimulated
)
{
closeOpenPanels
(
"
:
is
(
panel
menupopup
)
[
tabspecific
=
'
true
'
]
"
)
;
}
if
(
!
isSameDocument
)
{
closeOpenPanels
(
"
panel
[
locationspecific
=
'
true
'
]
"
)
;
}
let
screenshotsButtonsDisabled
=
gScreenshots
.
shouldScreenshotsButtonBeDisabled
(
)
;
Services
.
obs
.
notifyObservers
(
window
"
toggle
-
screenshot
-
disable
"
screenshotsButtonsDisabled
)
;
gPermissionPanel
.
onLocationChange
(
)
;
gProtectionsHandler
.
onLocationChange
(
)
;
BrowserPageActions
.
onLocationChange
(
)
;
SafeBrowsingNotificationBox
.
onLocationChange
(
aLocationURI
)
;
SaveToPocket
.
onLocationChange
(
window
)
;
UrlbarProviderSearchTips
.
onLocationChange
(
window
aLocationURI
aWebProgress
aFlags
)
;
this
.
_updateElementsForContentType
(
)
;
this
.
_updateMacUserActivity
(
window
aLocationURI
aWebProgress
)
;
let
button
=
document
.
getElementById
(
"
characterencoding
-
button
"
)
;
this
.
_menuItemForRepairTextEncoding
.
setAttribute
(
"
disabled
"
"
true
"
)
;
button
?
.
setAttribute
(
"
disabled
"
"
true
"
)
;
if
(
location
=
=
"
about
:
blank
"
&
&
gBrowser
.
selectedTab
.
hasAttribute
(
"
customizemode
"
)
)
{
gCustomizeMode
.
enter
(
)
;
}
else
if
(
CustomizationHandler
.
isEnteringCustomizeMode
|
|
CustomizationHandler
.
isCustomizing
(
)
)
{
gCustomizeMode
.
exit
(
)
;
}
CFRPageActions
.
updatePageActions
(
gBrowser
.
selectedBrowser
)
;
AboutReaderParent
.
updateReaderButton
(
gBrowser
.
selectedBrowser
)
;
TranslationsParent
.
onLocationChange
(
gBrowser
.
selectedBrowser
)
;
PictureInPicture
.
updateUrlbarToggle
(
gBrowser
.
selectedBrowser
)
;
if
(
!
gMultiProcessBrowser
)
{
gGestureSupport
.
restoreRotationState
(
)
;
}
if
(
aRequest
)
{
setTimeout
(
function
(
)
{
XULBrowserWindow
.
asyncUpdateUI
(
)
;
}
0
)
;
}
else
{
this
.
asyncUpdateUI
(
)
;
}
if
(
AppConstants
.
MOZ_CRASHREPORTER
&
&
aLocationURI
)
{
let
uri
=
aLocationURI
;
try
{
uri
=
aLocationURI
.
mutate
(
)
.
setUserPass
(
"
"
)
.
finalize
(
)
;
}
catch
(
ex
)
{
}
try
{
Services
.
appinfo
.
annotateCrashReport
(
"
URL
"
uri
.
spec
)
;
}
catch
(
ex
)
{
if
(
ex
.
result
!
=
Cr
.
NS_ERROR_NOT_INITIALIZED
)
{
throw
ex
;
}
}
}
}
_updateElementsForContentType
(
)
{
let
browser
=
gBrowser
.
selectedBrowser
;
let
isText
=
browser
.
documentContentType
&
&
BrowserUtils
.
mimeTypeIsTextBased
(
browser
.
documentContentType
)
;
for
(
let
element
of
this
.
_elementsForTextBasedTypes
)
{
if
(
isText
)
{
element
.
removeAttribute
(
"
disabled
"
)
;
}
else
{
element
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
}
let
enableFind
=
browser
.
contentPrincipal
?
.
spec
=
=
"
resource
:
/
/
pdf
.
js
/
web
/
viewer
.
html
"
|
|
(
isText
&
&
BrowserUtils
.
canFindInPage
(
gBrowser
.
currentURI
.
spec
)
)
;
for
(
let
element
of
this
.
_elementsForFind
)
{
if
(
enableFind
)
{
element
.
removeAttribute
(
"
disabled
"
)
;
}
else
{
element
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
}
if
(
TranslationsParent
.
isFullPageTranslationsRestrictedForPage
(
gBrowser
)
)
{
this
.
_menuItemForTranslations
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
else
{
this
.
_menuItemForTranslations
.
removeAttribute
(
"
disabled
"
)
;
}
if
(
gTranslationsEnabled
)
{
if
(
TranslationsParent
.
getIsTranslationsEngineSupported
(
)
)
{
this
.
_menuItemForTranslations
.
removeAttribute
(
"
hidden
"
)
;
}
else
{
this
.
_menuItemForTranslations
.
setAttribute
(
"
hidden
"
"
true
"
)
;
}
}
else
{
this
.
_menuItemForTranslations
.
setAttribute
(
"
hidden
"
"
true
"
)
;
}
}
_updateMacUserActivity
(
win
uri
webProgress
)
{
if
(
!
webProgress
.
isTopLevel
|
|
AppConstants
.
platform
!
=
"
macosx
"
)
{
return
;
}
let
url
=
uri
.
spec
;
if
(
PrivateBrowsingUtils
.
isWindowPrivate
(
win
)
)
{
url
=
"
"
;
}
let
baseWin
=
win
.
docShell
.
treeOwner
.
QueryInterface
(
Ci
.
nsIBaseWindow
)
;
MacUserActivityUpdater
.
updateLocation
(
url
win
.
gBrowser
.
contentTitle
baseWin
)
;
}
_securityURIOverride
(
browser
)
{
let
uri
=
browser
.
currentURI
;
if
(
!
uri
)
{
return
null
;
}
let
{
URI_INHERITS_SECURITY_CONTEXT
}
=
Ci
.
nsIProtocolHandler
;
if
(
!
(
doGetProtocolFlags
(
uri
)
&
URI_INHERITS_SECURITY_CONTEXT
)
&
&
!
(
uri
.
scheme
=
=
"
about
"
&
&
uri
.
filePath
=
=
"
srcdoc
"
)
&
&
!
(
uri
.
scheme
=
=
"
about
"
&
&
uri
.
filePath
=
=
"
blank
"
)
)
{
return
null
;
}
let
principal
=
browser
.
contentPrincipal
;
if
(
principal
.
isNullPrincipal
)
{
principal
=
principal
.
precursorPrincipal
;
}
if
(
!
principal
)
{
return
null
;
}
if
(
principal
.
originNoSuffix
=
=
"
resource
:
/
/
pdf
.
js
"
)
{
return
null
;
}
return
principal
.
URI
;
}
asyncUpdateUI
(
)
{
BrowserSearch
.
updateOpenSearchBadge
(
)
;
}
onStatusChange
(
aWebProgress
aRequest
aStatus
aMessage
)
{
this
.
status
=
aMessage
;
StatusPanel
.
update
(
)
;
}
_state
:
null
_lastLocation
:
null
_event
:
null
_lastLocationForEvent
:
null
_isSecureContext
:
null
onContentBlockingEvent
(
aWebProgress
aRequest
aEvent
aIsSimulated
)
{
let
uri
=
gBrowser
.
currentURI
;
let
spec
=
uri
.
spec
;
if
(
this
.
_event
=
=
aEvent
&
&
this
.
_lastLocationForEvent
=
=
spec
)
{
return
;
}
this
.
_lastLocationForEvent
=
spec
;
if
(
typeof
aIsSimulated
!
=
"
boolean
"
&
&
typeof
aIsSimulated
!
=
"
undefined
"
)
{
throw
new
Error
(
"
onContentBlockingEvent
:
aIsSimulated
receieved
an
unexpected
type
"
)
;
}
gProtectionsHandler
.
onContentBlockingEvent
(
aEvent
aWebProgress
aIsSimulated
this
.
_event
)
;
this
.
_event
=
aEvent
;
}
onSecurityChange
(
aWebProgress
aRequest
aState
_aIsSimulated
)
{
let
uri
=
gBrowser
.
currentURI
;
let
spec
=
uri
.
spec
;
let
isSecureContext
=
gBrowser
.
securityUI
.
isSecureContext
;
if
(
this
.
_state
=
=
aState
&
&
this
.
_lastLocation
=
=
spec
&
&
this
.
_isSecureContext
=
=
=
isSecureContext
)
{
gIdentityHandler
.
refreshIdentityBlock
(
)
;
return
;
}
this
.
_state
=
aState
;
this
.
_lastLocation
=
spec
;
this
.
_isSecureContext
=
isSecureContext
;
gURLBar
.
formatValue
(
)
;
let
uriOverride
=
this
.
_securityURIOverride
(
gBrowser
.
selectedBrowser
)
;
if
(
uriOverride
)
{
uri
=
uriOverride
;
this
.
_state
|
=
Ci
.
nsIWebProgressListener
.
STATE_IDENTITY_ASSOCIATED
;
}
try
{
uri
=
Services
.
io
.
createExposableURI
(
uri
)
;
}
catch
(
e
)
{
}
gIdentityHandler
.
updateIdentity
(
this
.
_state
uri
)
;
}
onUpdateCurrentBrowser
:
function
XWB_onUpdateCurrentBrowser
(
aStateFlags
aStatus
aMessage
_aTotalProgress
)
{
if
(
FullZoom
.
updateBackgroundTabs
)
{
FullZoom
.
onLocationChange
(
gBrowser
.
currentURI
true
)
;
}
CombinedStopReload
.
onTabSwitch
(
)
;
this
.
hideTooltip
(
)
;
document
.
getElementById
(
"
aHTMLTooltip
"
)
.
hidePopup
(
)
;
var
nsIWebProgressListener
=
Ci
.
nsIWebProgressListener
;
var
loadingDone
=
aStateFlags
&
nsIWebProgressListener
.
STATE_STOP
;
this
.
onStateChange
(
gBrowser
.
webProgress
{
URI
:
gBrowser
.
currentURI
}
loadingDone
?
nsIWebProgressListener
.
STATE_STOP
:
nsIWebProgressListener
.
STATE_START
aStatus
)
;
if
(
loadingDone
)
{
return
;
}
this
.
onStatusChange
(
gBrowser
.
webProgress
null
0
aMessage
)
;
}
}
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
XULBrowserWindow
"
spinCursorWhileBusy
"
"
browser
.
spin_cursor_while_busy
"
)
;
var
LinkTargetDisplay
=
{
get
DELAY_SHOW
(
)
{
delete
this
.
DELAY_SHOW
;
return
(
this
.
DELAY_SHOW
=
Services
.
prefs
.
getIntPref
(
"
browser
.
overlink
-
delay
"
)
)
;
}
DELAY_HIDE
:
250
_timer
:
0
get
_contextMenu
(
)
{
delete
this
.
_contextMenu
;
return
(
this
.
_contextMenu
=
document
.
getElementById
(
"
contentAreaContextMenu
"
)
)
;
}
update
(
{
hideStatusPanelImmediately
=
false
}
=
{
}
)
{
if
(
this
.
_contextMenu
.
state
=
=
"
open
"
|
|
this
.
_contextMenu
.
state
=
=
"
showing
"
)
{
this
.
_contextMenu
.
addEventListener
(
"
popuphidden
"
(
)
=
>
this
.
update
(
)
{
once
:
true
}
)
;
return
;
}
clearTimeout
(
this
.
_timer
)
;
window
.
removeEventListener
(
"
mousemove
"
this
true
)
;
if
(
!
XULBrowserWindow
.
overLink
)
{
if
(
hideStatusPanelImmediately
)
{
this
.
_hide
(
)
;
}
else
{
this
.
_timer
=
setTimeout
(
this
.
_hide
.
bind
(
this
)
this
.
DELAY_HIDE
)
;
}
return
;
}
if
(
StatusPanel
.
isVisible
)
{
StatusPanel
.
update
(
)
;
}
else
{
this
.
_showDelayed
(
)
;
window
.
addEventListener
(
"
mousemove
"
this
true
)
;
}
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
mousemove
"
:
clearTimeout
(
this
.
_timer
)
;
this
.
_showDelayed
(
)
;
break
;
}
}
_showDelayed
(
)
{
this
.
_timer
=
setTimeout
(
function
(
self
)
{
StatusPanel
.
update
(
)
;
window
.
removeEventListener
(
"
mousemove
"
self
true
)
;
}
this
.
DELAY_SHOW
this
)
;
}
_hide
(
)
{
clearTimeout
(
this
.
_timer
)
;
StatusPanel
.
update
(
)
;
}
}
;
var
CombinedStopReload
=
{
ensureInitialized
(
)
{
if
(
this
.
_initialized
)
{
return
true
;
}
if
(
this
.
_destroyed
)
{
return
false
;
}
let
reload
=
document
.
getElementById
(
"
reload
-
button
"
)
;
let
stop
=
document
.
getElementById
(
"
stop
-
button
"
)
;
if
(
!
stop
|
|
!
reload
)
{
return
false
;
}
this
.
_initialized
=
true
;
if
(
XULBrowserWindow
.
stopCommand
.
getAttribute
(
"
disabled
"
)
!
=
"
true
"
)
{
reload
.
setAttribute
(
"
displaystop
"
"
true
"
)
;
}
stop
.
addEventListener
(
"
click
"
this
)
;
for
(
let
button
of
[
stop
reload
]
)
{
if
(
button
.
hasAttribute
(
"
disabled
"
)
)
{
let
command
=
document
.
getElementById
(
button
.
getAttribute
(
"
command
"
)
)
;
if
(
!
command
.
hasAttribute
(
"
disabled
"
)
)
{
button
.
removeAttribute
(
"
disabled
"
)
;
}
}
}
this
.
reload
=
reload
;
this
.
stop
=
stop
;
this
.
stopReloadContainer
=
this
.
reload
.
parentNode
;
this
.
timeWhenSwitchedToStop
=
0
;
this
.
stopReloadContainer
.
addEventListener
(
"
animationend
"
this
)
;
this
.
stopReloadContainer
.
addEventListener
(
"
animationcancel
"
this
)
;
return
true
;
}
uninit
(
)
{
this
.
_destroyed
=
true
;
if
(
!
this
.
_initialized
)
{
return
;
}
this
.
_cancelTransition
(
)
;
this
.
stop
.
removeEventListener
(
"
click
"
this
)
;
this
.
stopReloadContainer
.
removeEventListener
(
"
animationend
"
this
)
;
this
.
stopReloadContainer
.
removeEventListener
(
"
animationcancel
"
this
)
;
this
.
stopReloadContainer
=
null
;
this
.
reload
=
null
;
this
.
stop
=
null
;
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
click
"
:
if
(
event
.
button
=
=
0
&
&
!
this
.
stop
.
disabled
)
{
this
.
_stopClicked
=
true
;
}
break
;
case
"
animationcancel
"
:
case
"
animationend
"
:
{
if
(
event
.
target
.
classList
.
contains
(
"
toolbarbutton
-
animatable
-
image
"
)
&
&
(
event
.
animationName
=
=
"
reload
-
to
-
stop
"
|
|
event
.
animationName
=
=
"
stop
-
to
-
reload
"
)
)
{
this
.
stopReloadContainer
.
removeAttribute
(
"
animate
"
)
;
}
}
}
}
onTabSwitch
(
)
{
this
.
timeWhenSwitchedToStop
=
window
.
performance
.
now
(
)
;
}
switchToStop
(
aRequest
aWebProgress
)
{
if
(
!
this
.
ensureInitialized
(
)
|
|
!
this
.
_shouldSwitch
(
aRequest
aWebProgress
)
)
{
return
;
}
if
(
aRequest
instanceof
Ci
.
nsIRequest
)
{
this
.
timeWhenSwitchedToStop
=
window
.
performance
.
now
(
)
;
}
let
shouldAnimate
=
aRequest
instanceof
Ci
.
nsIRequest
&
&
aWebProgress
.
isTopLevel
&
&
aWebProgress
.
isLoadingDocument
&
&
!
gBrowser
.
tabAnimationsInProgress
&
&
!
gReduceMotion
&
&
this
.
stopReloadContainer
.
closest
(
"
#
nav
-
bar
-
customization
-
target
"
)
;
this
.
_cancelTransition
(
)
;
if
(
shouldAnimate
)
{
this
.
stopReloadContainer
.
setAttribute
(
"
animate
"
"
true
"
)
;
}
else
{
this
.
stopReloadContainer
.
removeAttribute
(
"
animate
"
)
;
}
this
.
reload
.
setAttribute
(
"
displaystop
"
"
true
"
)
;
}
switchToReload
(
aRequest
aWebProgress
)
{
if
(
!
this
.
ensureInitialized
(
)
|
|
!
this
.
reload
.
hasAttribute
(
"
displaystop
"
)
)
{
return
;
}
let
shouldAnimate
=
aRequest
instanceof
Ci
.
nsIRequest
&
&
aWebProgress
.
isTopLevel
&
&
!
aWebProgress
.
isLoadingDocument
&
&
!
gBrowser
.
tabAnimationsInProgress
&
&
!
gReduceMotion
&
&
this
.
_loadTimeExceedsMinimumForAnimation
(
)
&
&
this
.
stopReloadContainer
.
closest
(
"
#
nav
-
bar
-
customization
-
target
"
)
;
if
(
shouldAnimate
)
{
this
.
stopReloadContainer
.
setAttribute
(
"
animate
"
"
true
"
)
;
}
else
{
this
.
stopReloadContainer
.
removeAttribute
(
"
animate
"
)
;
}
this
.
reload
.
removeAttribute
(
"
displaystop
"
)
;
if
(
!
shouldAnimate
|
|
this
.
_stopClicked
)
{
this
.
_stopClicked
=
false
;
this
.
_cancelTransition
(
)
;
this
.
reload
.
disabled
=
XULBrowserWindow
.
reloadCommand
.
getAttribute
(
"
disabled
"
)
=
=
"
true
"
;
return
;
}
if
(
this
.
_timer
)
{
return
;
}
this
.
reload
.
disabled
=
true
;
this
.
_timer
=
setTimeout
(
function
(
self
)
{
self
.
_timer
=
0
;
self
.
reload
.
disabled
=
XULBrowserWindow
.
reloadCommand
.
getAttribute
(
"
disabled
"
)
=
=
"
true
"
;
}
650
this
)
;
}
_loadTimeExceedsMinimumForAnimation
(
)
{
return
(
this
.
timeWhenSwitchedToStop
&
&
window
.
performance
.
now
(
)
-
this
.
timeWhenSwitchedToStop
>
150
)
;
}
_shouldSwitch
(
aRequest
aWebProgress
)
{
if
(
aRequest
&
&
aRequest
.
originalURI
&
&
(
aRequest
.
originalURI
.
schemeIs
(
"
chrome
"
)
|
|
(
aRequest
.
originalURI
.
schemeIs
(
"
about
"
)
&
&
aWebProgress
.
isTopLevel
&
&
!
aRequest
.
originalURI
.
spec
.
startsWith
(
"
about
:
reader
"
)
)
)
)
{
return
false
;
}
return
true
;
}
_cancelTransition
(
)
{
if
(
this
.
_timer
)
{
clearTimeout
(
this
.
_timer
)
;
this
.
_timer
=
0
;
}
}
}
;
var
TabsProgressListener
=
{
onStateChange
(
aBrowser
aWebProgress
aRequest
aStateFlags
aStatus
)
{
if
(
aWebProgress
.
isTopLevel
&
&
(
!
aRequest
.
originalURI
|
|
aRequest
.
originalURI
.
scheme
!
=
"
about
"
)
)
{
let
histogram
=
"
FX_PAGE_LOAD_MS_2
"
;
let
recordLoadTelemetry
=
true
;
if
(
aWebProgress
.
loadType
&
Ci
.
nsIDocShell
.
LOAD_CMD_RELOAD
)
{
if
(
aWebProgress
.
loadType
&
(
kSkipCacheFlags
<
<
16
)
)
{
histogram
=
"
FX_PAGE_RELOAD_SKIP_CACHE_MS
"
;
}
else
if
(
aWebProgress
.
loadType
=
=
Ci
.
nsIDocShell
.
LOAD_CMD_RELOAD
)
{
histogram
=
"
FX_PAGE_RELOAD_NORMAL_MS
"
;
}
else
{
recordLoadTelemetry
=
false
;
}
}
let
stopwatchRunning
=
TelemetryStopwatch
.
running
(
histogram
aBrowser
)
;
if
(
aStateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_IS_WINDOW
)
{
if
(
aStateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_START
)
{
if
(
stopwatchRunning
)
{
if
(
recordLoadTelemetry
)
{
TelemetryStopwatch
.
cancel
(
histogram
aBrowser
)
;
}
}
if
(
recordLoadTelemetry
)
{
TelemetryStopwatch
.
start
(
histogram
aBrowser
)
;
}
Services
.
telemetry
.
getHistogramById
(
"
FX_TOTAL_TOP_VISITS
"
)
.
add
(
true
)
;
}
else
if
(
aStateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_STOP
&
&
stopwatchRunning
)
{
if
(
recordLoadTelemetry
)
{
TelemetryStopwatch
.
finish
(
histogram
aBrowser
)
;
BrowserTelemetryUtils
.
recordSiteOriginTelemetry
(
browserWindows
(
)
)
;
}
}
}
else
if
(
aStateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_STOP
&
&
aStatus
=
=
Cr
.
NS_BINDING_ABORTED
&
&
stopwatchRunning
)
{
if
(
recordLoadTelemetry
)
{
TelemetryStopwatch
.
cancel
(
histogram
aBrowser
)
;
}
}
}
}
onLocationChange
(
aBrowser
aWebProgress
aRequest
aLocationURI
aFlags
)
{
if
(
!
aWebProgress
.
isTopLevel
)
{
return
;
}
ShoppingSidebarManager
.
onLocationChange
(
aBrowser
aLocationURI
aFlags
)
;
if
(
aFlags
&
Ci
.
nsIWebProgressListener
.
LOCATION_CHANGE_SAME_DOCUMENT
)
{
aBrowser
.
sendMessageToActor
(
"
Reader
:
PushState
"
{
isArticle
:
aBrowser
.
isArticle
}
"
AboutReader
"
)
;
return
;
}
if
(
!
Object
.
getOwnPropertyDescriptor
(
window
"
PopupNotifications
"
)
.
get
)
{
PopupNotifications
.
locationChange
(
aBrowser
)
;
}
let
tab
=
gBrowser
.
getTabForBrowser
(
aBrowser
)
;
if
(
tab
&
&
tab
.
_sharingState
)
{
gBrowser
.
resetBrowserSharing
(
aBrowser
)
;
}
gBrowser
.
readNotificationBox
(
aBrowser
)
?
.
removeTransientNotifications
(
)
;
Services
.
obs
.
notifyObservers
(
aBrowser
"
mailto
:
:
onLocationChange
"
aFlags
)
;
FullZoom
.
onLocationChange
(
aLocationURI
false
aBrowser
)
;
CaptivePortalWatcher
.
onLocationChange
(
aBrowser
)
;
}
onLinkIconAvailable
(
browser
dataURI
iconURI
)
{
if
(
!
iconURI
)
{
return
;
}
if
(
browser
=
=
gBrowser
.
selectedBrowser
)
{
BrowserSearch
.
updateOpenSearchBadge
(
)
;
}
}
}
;
function
nsBrowserAccess
(
)
{
}
nsBrowserAccess
.
prototype
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIBrowserDOMWindow
"
]
)
_openURIInNewTab
(
aURI
aReferrerInfo
aIsPrivate
aIsExternal
aForceNotRemote
=
false
aUserContextId
=
Ci
.
nsIScriptSecurityManager
.
DEFAULT_USER_CONTEXT_ID
aOpenWindowInfo
=
null
aOpenerBrowser
=
null
aTriggeringPrincipal
=
null
aName
=
"
"
aCsp
=
null
aSkipLoad
=
false
aWhere
=
undefined
)
{
let
win
needToFocusWin
;
if
(
window
.
toolbar
.
visible
)
{
win
=
window
;
}
else
{
win
=
BrowserWindowTracker
.
getTopWindow
(
{
private
:
aIsPrivate
}
)
;
needToFocusWin
=
true
;
}
if
(
!
win
)
{
return
null
;
}
if
(
aIsExternal
&
&
(
!
aURI
|
|
aURI
.
spec
=
=
"
about
:
blank
"
)
)
{
win
.
BrowserCommands
.
openTab
(
)
;
win
.
focus
(
)
;
return
win
.
gBrowser
.
selectedBrowser
;
}
let
loadInBackground
;
if
(
aWhere
=
=
=
Ci
.
nsIBrowserDOMWindow
.
OPEN_NEWTAB_BACKGROUND
)
{
loadInBackground
=
true
;
}
else
if
(
aWhere
=
=
=
Ci
.
nsIBrowserDOMWindow
.
OPEN_NEWTAB_FOREGROUND
)
{
loadInBackground
=
false
;
}
else
{
loadInBackground
=
Services
.
prefs
.
getBoolPref
(
"
browser
.
tabs
.
loadDivertedInBackground
"
)
;
}
let
tab
=
win
.
gBrowser
.
addTab
(
aURI
?
aURI
.
spec
:
"
about
:
blank
"
{
triggeringPrincipal
:
aTriggeringPrincipal
referrerInfo
:
aReferrerInfo
userContextId
:
aUserContextId
fromExternal
:
aIsExternal
inBackground
:
loadInBackground
forceNotRemote
:
aForceNotRemote
openWindowInfo
:
aOpenWindowInfo
openerBrowser
:
aOpenerBrowser
name
:
aName
csp
:
aCsp
skipLoad
:
aSkipLoad
}
)
;
let
browser
=
win
.
gBrowser
.
getBrowserForTab
(
tab
)
;
if
(
needToFocusWin
|
|
(
!
loadInBackground
&
&
aIsExternal
)
)
{
win
.
focus
(
)
;
}
return
browser
;
}
createContentWindow
(
aURI
aOpenWindowInfo
aWhere
aFlags
aTriggeringPrincipal
aCsp
)
{
return
this
.
getContentWindowOrOpenURI
(
null
aOpenWindowInfo
aWhere
aFlags
aTriggeringPrincipal
aCsp
true
)
;
}
openURI
(
aURI
aOpenWindowInfo
aWhere
aFlags
aTriggeringPrincipal
aCsp
)
{
if
(
!
aURI
)
{
console
.
error
(
"
openURI
should
only
be
called
with
a
valid
URI
"
)
;
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_FAILURE
)
;
}
return
this
.
getContentWindowOrOpenURI
(
aURI
aOpenWindowInfo
aWhere
aFlags
aTriggeringPrincipal
aCsp
false
)
;
}
getContentWindowOrOpenURI
(
aURI
aOpenWindowInfo
aWhere
aFlags
aTriggeringPrincipal
aCsp
aSkipLoad
)
{
var
browsingContext
=
null
;
var
isExternal
=
!
!
(
aFlags
&
Ci
.
nsIBrowserDOMWindow
.
OPEN_EXTERNAL
)
;
var
guessUserContextIdEnabled
=
isExternal
&
&
!
Services
.
prefs
.
getBoolPref
(
"
browser
.
link
.
force_default_user_context_id_for_external_opens
"
false
)
;
var
openingUserContextId
=
(
guessUserContextIdEnabled
&
&
URILoadingHelper
.
guessUserContextId
(
aURI
)
)
|
|
Ci
.
nsIScriptSecurityManager
.
DEFAULT_USER_CONTEXT_ID
;
if
(
aOpenWindowInfo
&
&
isExternal
)
{
console
.
error
(
"
nsBrowserAccess
.
openURI
did
not
expect
aOpenWindowInfo
to
be
"
+
"
passed
if
the
context
is
OPEN_EXTERNAL
.
"
)
;
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_FAILURE
)
;
}
if
(
isExternal
&
&
aURI
&
&
aURI
.
schemeIs
(
"
chrome
"
)
)
{
dump
(
"
use
-
-
chrome
command
-
line
option
to
load
external
chrome
urls
\
n
"
)
;
return
null
;
}
if
(
aWhere
=
=
Ci
.
nsIBrowserDOMWindow
.
OPEN_DEFAULTWINDOW
)
{
if
(
isExternal
&
&
Services
.
prefs
.
prefHasUserValue
(
"
browser
.
link
.
open_newwindow
.
override
.
external
"
)
)
{
aWhere
=
Services
.
prefs
.
getIntPref
(
"
browser
.
link
.
open_newwindow
.
override
.
external
"
)
;
}
else
{
aWhere
=
Services
.
prefs
.
getIntPref
(
"
browser
.
link
.
open_newwindow
"
)
;
}
}
let
referrerInfo
;
if
(
aFlags
&
Ci
.
nsIBrowserDOMWindow
.
OPEN_NO_REFERRER
)
{
referrerInfo
=
new
ReferrerInfo
(
Ci
.
nsIReferrerInfo
.
EMPTY
false
null
)
;
}
else
if
(
aOpenWindowInfo
&
&
aOpenWindowInfo
.
parent
&
&
aOpenWindowInfo
.
parent
.
window
)
{
referrerInfo
=
new
ReferrerInfo
(
aOpenWindowInfo
.
parent
.
window
.
document
.
referrerInfo
.
referrerPolicy
true
makeURI
(
aOpenWindowInfo
.
parent
.
window
.
location
.
href
)
)
;
}
else
{
referrerInfo
=
new
ReferrerInfo
(
Ci
.
nsIReferrerInfo
.
EMPTY
true
null
)
;
}
let
isPrivate
=
aOpenWindowInfo
?
aOpenWindowInfo
.
originAttributes
.
privateBrowsingId
!
=
0
:
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
;
switch
(
aWhere
)
{
case
Ci
.
nsIBrowserDOMWindow
.
OPEN_NEWWINDOW
:
{
var
url
=
aURI
&
&
aURI
.
spec
;
let
features
=
"
all
dialog
=
no
"
;
if
(
isPrivate
)
{
features
+
=
"
private
"
;
}
try
{
let
extraOptions
=
Cc
[
"
mozilla
.
org
/
hash
-
property
-
bag
;
1
"
]
.
createInstance
(
Ci
.
nsIWritablePropertyBag2
)
;
extraOptions
.
setPropertyAsBool
(
"
fromExternal
"
isExternal
)
;
openDialog
(
AppConstants
.
BROWSER_CHROME_URL
"
_blank
"
features
url
extraOptions
null
null
null
null
null
null
aTriggeringPrincipal
null
aCsp
aOpenWindowInfo
)
;
browsingContext
=
null
;
}
catch
(
ex
)
{
console
.
error
(
ex
)
;
}
break
;
}
case
Ci
.
nsIBrowserDOMWindow
.
OPEN_NEWTAB
:
case
Ci
.
nsIBrowserDOMWindow
.
OPEN_NEWTAB_BACKGROUND
:
case
Ci
.
nsIBrowserDOMWindow
.
OPEN_NEWTAB_FOREGROUND
:
{
let
forceNotRemote
=
aOpenWindowInfo
&
&
!
aOpenWindowInfo
.
isRemote
;
let
userContextId
=
aOpenWindowInfo
?
aOpenWindowInfo
.
originAttributes
.
userContextId
:
openingUserContextId
;
let
browser
=
this
.
_openURIInNewTab
(
aURI
referrerInfo
isPrivate
isExternal
forceNotRemote
userContextId
aOpenWindowInfo
aOpenWindowInfo
?
.
parent
?
.
top
.
embedderElement
aTriggeringPrincipal
"
"
aCsp
aSkipLoad
aWhere
)
;
if
(
browser
)
{
browsingContext
=
browser
.
browsingContext
;
}
break
;
}
case
Ci
.
nsIBrowserDOMWindow
.
OPEN_PRINT_BROWSER
:
{
let
browser
=
PrintUtils
.
handleStaticCloneCreatedForPrint
(
aOpenWindowInfo
)
;
if
(
browser
)
{
browsingContext
=
browser
.
browsingContext
;
}
break
;
}
default
:
browsingContext
=
window
.
gBrowser
.
selectedBrowser
.
browsingContext
;
if
(
aURI
)
{
let
loadFlags
=
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_NONE
;
if
(
isExternal
)
{
loadFlags
|
=
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_FROM_EXTERNAL
;
}
else
if
(
!
aTriggeringPrincipal
.
isSystemPrincipal
)
{
loadFlags
|
=
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_FIRST_LOAD
;
}
gBrowser
.
fixupAndLoadURIString
(
aURI
.
spec
{
triggeringPrincipal
:
aTriggeringPrincipal
csp
:
aCsp
loadFlags
referrerInfo
}
)
;
}
if
(
!
Services
.
prefs
.
getBoolPref
(
"
browser
.
tabs
.
loadDivertedInBackground
"
)
)
{
window
.
focus
(
)
;
}
}
return
browsingContext
;
}
createContentWindowInFrame
:
function
browser_createContentWindowInFrame
(
aURI
aParams
aWhere
aFlags
aName
)
{
return
this
.
getContentWindowOrOpenURIInFrame
(
null
aParams
aWhere
aFlags
aName
true
)
;
}
openURIInFrame
:
function
browser_openURIInFrame
(
aURI
aParams
aWhere
aFlags
aName
)
{
return
this
.
getContentWindowOrOpenURIInFrame
(
aURI
aParams
aWhere
aFlags
aName
false
)
;
}
getContentWindowOrOpenURIInFrame
:
function
browser_getContentWindowOrOpenURIInFrame
(
aURI
aParams
aWhere
aFlags
aName
aSkipLoad
)
{
if
(
aWhere
=
=
Ci
.
nsIBrowserDOMWindow
.
OPEN_PRINT_BROWSER
)
{
return
PrintUtils
.
handleStaticCloneCreatedForPrint
(
aParams
.
openWindowInfo
)
;
}
if
(
aWhere
!
=
Ci
.
nsIBrowserDOMWindow
.
OPEN_NEWTAB
&
&
aWhere
!
=
Ci
.
nsIBrowserDOMWindow
.
OPEN_NEWTAB_BACKGROUND
&
&
aWhere
!
=
Ci
.
nsIBrowserDOMWindow
.
OPEN_NEWTAB_FOREGROUND
)
{
dump
(
"
Error
:
openURIInFrame
can
only
open
in
new
tabs
or
print
"
)
;
return
null
;
}
var
isExternal
=
!
!
(
aFlags
&
Ci
.
nsIBrowserDOMWindow
.
OPEN_EXTERNAL
)
;
var
userContextId
=
aParams
.
openerOriginAttributes
&
&
"
userContextId
"
in
aParams
.
openerOriginAttributes
?
aParams
.
openerOriginAttributes
.
userContextId
:
Ci
.
nsIScriptSecurityManager
.
DEFAULT_USER_CONTEXT_ID
;
return
this
.
_openURIInNewTab
(
aURI
aParams
.
referrerInfo
aParams
.
isPrivate
isExternal
false
userContextId
aParams
.
openWindowInfo
aParams
.
openerBrowser
aParams
.
triggeringPrincipal
aName
aParams
.
csp
aSkipLoad
aWhere
)
;
}
canClose
(
)
{
return
CanCloseWindow
(
)
;
}
get
tabCount
(
)
{
return
gBrowser
.
tabs
.
length
;
}
}
;
function
showFullScreenViewContextMenuItems
(
popup
)
{
for
(
let
node
of
popup
.
querySelectorAll
(
'
[
contexttype
=
"
fullscreen
"
]
'
)
)
{
node
.
hidden
=
!
window
.
fullScreen
;
}
let
autoHide
=
popup
.
querySelector
(
"
.
fullscreen
-
context
-
autohide
"
)
;
if
(
autoHide
)
{
FullScreen
.
updateAutohideMenuitem
(
autoHide
)
;
}
}
function
onViewToolbarCommand
(
aEvent
)
{
let
node
=
aEvent
.
originalTarget
;
let
menuId
;
let
toolbarId
;
let
isVisible
;
if
(
node
.
dataset
.
bookmarksToolbarVisibility
)
{
isVisible
=
node
.
dataset
.
visibilityEnum
;
toolbarId
=
"
PersonalToolbar
"
;
menuId
=
node
.
parentNode
.
parentNode
.
parentNode
.
id
;
Services
.
prefs
.
setCharPref
(
"
browser
.
toolbars
.
bookmarks
.
visibility
"
isVisible
)
;
}
else
{
menuId
=
node
.
parentNode
.
id
;
toolbarId
=
node
.
getAttribute
(
"
toolbarId
"
)
;
isVisible
=
node
.
getAttribute
(
"
checked
"
)
=
=
"
true
"
;
}
CustomizableUI
.
setToolbarVisibility
(
toolbarId
isVisible
)
;
BrowserUsageTelemetry
.
recordToolbarVisibility
(
toolbarId
isVisible
menuId
)
;
}
function
setToolbarVisibility
(
toolbar
isVisible
persist
=
true
animated
=
true
)
{
let
hidingAttribute
;
if
(
toolbar
.
getAttribute
(
"
type
"
)
=
=
"
menubar
"
)
{
hidingAttribute
=
"
autohide
"
;
if
(
AppConstants
.
platform
=
=
"
linux
"
)
{
Services
.
prefs
.
setBoolPref
(
"
ui
.
key
.
menuAccessKeyFocuses
"
!
isVisible
)
;
}
}
else
{
hidingAttribute
=
"
collapsed
"
;
}
if
(
toolbar
=
=
BookmarkingUI
.
toolbar
)
{
if
(
persist
)
{
let
prefValue
;
if
(
typeof
isVisible
=
=
"
string
"
)
{
prefValue
=
isVisible
;
}
else
{
prefValue
=
isVisible
?
"
always
"
:
"
never
"
;
}
Services
.
prefs
.
setCharPref
(
"
browser
.
toolbars
.
bookmarks
.
visibility
"
prefValue
)
;
}
const
overlapAttr
=
"
BookmarksToolbarOverlapsBrowser
"
;
switch
(
isVisible
)
{
case
true
:
case
"
always
"
:
isVisible
=
true
;
document
.
documentElement
.
toggleAttribute
(
overlapAttr
false
)
;
break
;
case
false
:
case
"
never
"
:
isVisible
=
false
;
document
.
documentElement
.
toggleAttribute
(
overlapAttr
false
)
;
break
;
case
"
newtab
"
:
default
:
{
let
currentURI
=
gBrowser
?
.
currentURI
;
if
(
!
gBrowserInit
.
domContentLoaded
)
{
let
uriToLoad
=
gBrowserInit
.
uriToLoadPromise
;
if
(
uriToLoad
)
{
if
(
Array
.
isArray
(
uriToLoad
)
)
{
uriToLoad
=
uriToLoad
[
0
]
;
}
try
{
currentURI
=
Services
.
io
.
newURI
(
uriToLoad
)
;
}
catch
(
ex
)
{
}
}
}
isVisible
=
BookmarkingUI
.
isOnNewTabPage
(
currentURI
)
;
document
.
documentElement
.
toggleAttribute
(
overlapAttr
isVisible
)
;
break
;
}
}
}
if
(
toolbar
.
getAttribute
(
hidingAttribute
)
=
=
(
!
isVisible
)
.
toString
(
)
)
{
return
;
}
toolbar
.
classList
.
toggle
(
"
instant
"
!
animated
)
;
toolbar
.
setAttribute
(
hidingAttribute
!
isVisible
)
;
if
(
persist
&
&
toolbar
.
id
!
=
"
PersonalToolbar
"
)
{
Services
.
xulStore
.
persist
(
toolbar
hidingAttribute
)
;
}
let
eventParams
=
{
detail
:
{
visible
:
isVisible
}
bubbles
:
true
}
;
let
event
=
new
CustomEvent
(
"
toolbarvisibilitychange
"
eventParams
)
;
toolbar
.
dispatchEvent
(
event
)
;
}
function
updateToggleControlLabel
(
control
)
{
if
(
!
control
.
hasAttribute
(
"
label
-
checked
"
)
)
{
return
;
}
if
(
!
control
.
hasAttribute
(
"
label
-
unchecked
"
)
)
{
control
.
setAttribute
(
"
label
-
unchecked
"
control
.
getAttribute
(
"
label
"
)
)
;
}
let
prefix
=
control
.
getAttribute
(
"
checked
"
)
=
=
"
true
"
?
"
"
:
"
un
"
;
control
.
setAttribute
(
"
label
"
control
.
getAttribute
(
label
-
{
prefix
}
checked
)
)
;
}
var
TabletModeUpdater
=
{
init
(
)
{
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
this
.
update
(
WindowsUIUtils
.
inTabletMode
)
;
Services
.
obs
.
addObserver
(
this
"
tablet
-
mode
-
change
"
)
;
}
}
uninit
(
)
{
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
Services
.
obs
.
removeObserver
(
this
"
tablet
-
mode
-
change
"
)
;
}
}
observe
(
subject
topic
data
)
{
this
.
update
(
data
=
=
"
tablet
-
mode
"
)
;
}
update
(
isInTabletMode
)
{
let
wasInTabletMode
=
document
.
documentElement
.
hasAttribute
(
"
tabletmode
"
)
;
if
(
isInTabletMode
)
{
document
.
documentElement
.
setAttribute
(
"
tabletmode
"
"
true
"
)
;
}
else
{
document
.
documentElement
.
removeAttribute
(
"
tabletmode
"
)
;
}
if
(
wasInTabletMode
!
=
isInTabletMode
)
{
gUIDensity
.
update
(
)
;
}
}
}
;
function
displaySecurityInfo
(
)
{
BrowserCommands
.
pageInfo
(
null
"
securityTab
"
)
;
}
var
gUIDensity
=
{
MODE_NORMAL
:
0
MODE_COMPACT
:
1
MODE_TOUCH
:
2
uiDensityPref
:
"
browser
.
uidensity
"
autoTouchModePref
:
"
browser
.
touchmode
.
auto
"
init
(
)
{
this
.
update
(
)
;
Services
.
prefs
.
addObserver
(
this
.
uiDensityPref
this
)
;
Services
.
prefs
.
addObserver
(
this
.
autoTouchModePref
this
)
;
}
uninit
(
)
{
Services
.
prefs
.
removeObserver
(
this
.
uiDensityPref
this
)
;
Services
.
prefs
.
removeObserver
(
this
.
autoTouchModePref
this
)
;
}
observe
(
aSubject
aTopic
aPrefName
)
{
if
(
aTopic
!
=
"
nsPref
:
changed
"
|
|
(
aPrefName
!
=
this
.
uiDensityPref
&
&
aPrefName
!
=
this
.
autoTouchModePref
)
)
{
return
;
}
this
.
update
(
)
;
}
getCurrentDensity
(
)
{
if
(
AppConstants
.
platform
=
=
"
win
"
&
&
WindowsUIUtils
.
inTabletMode
&
&
Services
.
prefs
.
getBoolPref
(
this
.
autoTouchModePref
)
)
{
return
{
mode
:
this
.
MODE_TOUCH
overridden
:
true
}
;
}
return
{
mode
:
Services
.
prefs
.
getIntPref
(
this
.
uiDensityPref
)
overridden
:
false
}
;
}
update
(
mode
)
{
if
(
mode
=
=
null
)
{
mode
=
this
.
getCurrentDensity
(
)
.
mode
;
}
let
docs
=
[
document
.
documentElement
]
;
let
shouldUpdateSidebar
=
SidebarController
.
initialized
&
&
SidebarController
.
isOpen
;
if
(
shouldUpdateSidebar
)
{
docs
.
push
(
SidebarController
.
browser
.
contentDocument
.
documentElement
)
;
}
for
(
let
doc
of
docs
)
{
switch
(
mode
)
{
case
this
.
MODE_COMPACT
:
doc
.
setAttribute
(
"
uidensity
"
"
compact
"
)
;
break
;
case
this
.
MODE_TOUCH
:
doc
.
setAttribute
(
"
uidensity
"
"
touch
"
)
;
break
;
default
:
doc
.
removeAttribute
(
"
uidensity
"
)
;
break
;
}
}
if
(
shouldUpdateSidebar
)
{
let
tree
=
SidebarController
.
browser
.
contentDocument
.
querySelector
(
"
.
sidebar
-
placesTree
"
)
;
if
(
tree
)
{
tree
.
style
.
border
=
"
1px
"
;
tree
.
style
.
border
=
"
"
;
}
}
gBrowser
.
tabContainer
.
uiDensityChanged
(
)
;
gURLBar
.
updateLayoutBreakout
(
)
;
}
}
;
const
nodeToTooltipMap
=
{
"
bookmarks
-
menu
-
button
"
:
"
bookmarksMenuButton
.
tooltip
"
"
context
-
reload
"
:
"
reloadButton
.
tooltip
"
"
context
-
stop
"
:
"
stopButton
.
tooltip
"
"
downloads
-
button
"
:
"
downloads
.
tooltip
"
"
fullscreen
-
button
"
:
"
fullscreenButton
.
tooltip
"
"
appMenu
-
fullscreen
-
button2
"
:
"
fullscreenButton
.
tooltip
"
"
new
-
window
-
button
"
:
"
newWindowButton
.
tooltip
"
"
new
-
tab
-
button
"
:
"
newTabButton
.
tooltip
"
"
tabs
-
newtab
-
button
"
:
"
newTabButton
.
tooltip
"
"
reload
-
button
"
:
"
reloadButton
.
tooltip
"
"
stop
-
button
"
:
"
stopButton
.
tooltip
"
"
urlbar
-
zoom
-
button
"
:
"
urlbar
-
zoom
-
button
.
tooltip
"
"
appMenu
-
zoomEnlarge
-
button2
"
:
"
zoomEnlarge
-
button
.
tooltip
"
"
appMenu
-
zoomReset
-
button2
"
:
"
zoomReset
-
button
.
tooltip
"
"
appMenu
-
zoomReduce
-
button2
"
:
"
zoomReduce
-
button
.
tooltip
"
"
reader
-
mode
-
button
"
:
"
reader
-
mode
-
button
.
tooltip
"
"
reader
-
mode
-
button
-
icon
"
:
"
reader
-
mode
-
button
.
tooltip
"
"
vertical
-
tabs
-
newtab
-
button
"
:
"
newTabButton
.
tooltip
"
}
;
const
nodeToShortcutMap
=
{
"
bookmarks
-
menu
-
button
"
:
"
manBookmarkKb
"
"
context
-
reload
"
:
"
key_reload
"
"
context
-
stop
"
:
"
key_stop
"
"
downloads
-
button
"
:
"
key_openDownloads
"
"
fullscreen
-
button
"
:
"
key_enterFullScreen
"
"
appMenu
-
fullscreen
-
button2
"
:
"
key_enterFullScreen
"
"
new
-
window
-
button
"
:
"
key_newNavigator
"
"
new
-
tab
-
button
"
:
"
key_newNavigatorTab
"
"
tabs
-
newtab
-
button
"
:
"
key_newNavigatorTab
"
"
reload
-
button
"
:
"
key_reload
"
"
stop
-
button
"
:
"
key_stop
"
"
urlbar
-
zoom
-
button
"
:
"
key_fullZoomReset
"
"
appMenu
-
zoomEnlarge
-
button2
"
:
"
key_fullZoomEnlarge
"
"
appMenu
-
zoomReset
-
button2
"
:
"
key_fullZoomReset
"
"
appMenu
-
zoomReduce
-
button2
"
:
"
key_fullZoomReduce
"
"
reader
-
mode
-
button
"
:
"
key_toggleReaderMode
"
"
reader
-
mode
-
button
-
icon
"
:
"
key_toggleReaderMode
"
"
vertical
-
tabs
-
newtab
-
button
"
:
"
key_newNavigatorTab
"
}
;
const
gDynamicTooltipCache
=
new
Map
(
)
;
function
GetDynamicShortcutTooltipText
(
nodeId
)
{
if
(
!
gDynamicTooltipCache
.
has
(
nodeId
)
&
&
nodeId
in
nodeToTooltipMap
)
{
let
strId
=
nodeToTooltipMap
[
nodeId
]
;
let
args
=
[
]
;
if
(
nodeId
in
nodeToShortcutMap
)
{
let
shortcutId
=
nodeToShortcutMap
[
nodeId
]
;
let
shortcut
=
document
.
getElementById
(
shortcutId
)
;
if
(
shortcut
)
{
args
.
push
(
ShortcutUtils
.
prettifyShortcut
(
shortcut
)
)
;
}
}
gDynamicTooltipCache
.
set
(
nodeId
gNavigatorBundle
.
getFormattedString
(
strId
args
)
)
;
}
return
gDynamicTooltipCache
.
get
(
nodeId
)
;
}
function
UpdateDynamicShortcutTooltipText
(
aTooltip
)
{
let
nodeId
=
aTooltip
.
triggerNode
.
id
|
|
aTooltip
.
triggerNode
.
getAttribute
(
"
anonid
"
)
;
aTooltip
.
setAttribute
(
"
label
"
GetDynamicShortcutTooltipText
(
nodeId
)
)
;
}
function
hrefAndLinkNodeForClickEvent
(
event
)
{
function
isHTMLLink
(
aNode
)
{
return
(
(
HTMLAnchorElement
.
isInstance
(
aNode
)
&
&
aNode
.
href
)
|
|
(
HTMLAreaElement
.
isInstance
(
aNode
)
&
&
aNode
.
href
)
|
|
HTMLLinkElement
.
isInstance
(
aNode
)
)
;
}
let
node
=
event
.
composedTarget
;
while
(
node
&
&
!
isHTMLLink
(
node
)
)
{
node
=
node
.
flattenedTreeParentNode
;
}
if
(
node
)
{
return
[
node
.
href
node
]
;
}
let
href
baseURI
;
node
=
event
.
composedTarget
;
while
(
node
&
&
!
href
)
{
if
(
node
.
nodeType
=
=
Node
.
ELEMENT_NODE
&
&
(
node
.
localName
=
=
"
a
"
|
|
node
.
namespaceURI
=
=
"
http
:
/
/
www
.
w3
.
org
/
1998
/
Math
/
MathML
"
)
)
{
href
=
node
.
getAttribute
(
"
href
"
)
|
|
node
.
getAttributeNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xlink
"
"
href
"
)
;
if
(
href
)
{
baseURI
=
node
.
baseURI
;
break
;
}
}
node
=
node
.
flattenedTreeParentNode
;
}
return
[
href
?
makeURLAbsolute
(
baseURI
href
)
:
null
null
]
;
}
function
contentAreaClick
(
event
isPanelClick
)
{
if
(
!
event
.
isTrusted
|
|
event
.
defaultPrevented
|
|
event
.
button
!
=
0
)
{
return
;
}
let
[
href
linkNode
]
=
hrefAndLinkNodeForClickEvent
(
event
)
;
if
(
!
href
)
{
if
(
event
.
button
=
=
1
&
&
Services
.
prefs
.
getBoolPref
(
"
middlemouse
.
contentLoadURL
"
)
&
&
!
Services
.
prefs
.
getBoolPref
(
"
general
.
autoScroll
"
)
)
{
middleMousePaste
(
event
)
;
event
.
preventDefault
(
)
;
}
return
;
}
if
(
linkNode
&
&
event
.
button
=
=
0
&
&
!
event
.
ctrlKey
&
&
!
event
.
shiftKey
&
&
!
event
.
altKey
&
&
!
event
.
metaKey
)
{
let
target
=
linkNode
.
target
;
let
mainTarget
=
!
target
|
|
target
=
=
"
_content
"
|
|
target
=
=
"
_main
"
;
if
(
isPanelClick
&
&
mainTarget
)
{
if
(
linkNode
.
getAttribute
(
"
onclick
"
)
|
|
href
.
startsWith
(
"
javascript
:
"
)
|
|
href
.
startsWith
(
"
data
:
"
)
)
{
return
;
}
try
{
urlSecurityCheck
(
href
linkNode
.
ownerDocument
.
nodePrincipal
)
;
}
catch
(
ex
)
{
event
.
preventDefault
(
)
;
return
;
}
openLinkIn
(
href
"
current
"
{
allowThirdPartyFixup
:
false
}
)
;
event
.
preventDefault
(
)
;
return
;
}
}
handleLinkClick
(
event
href
linkNode
)
;
try
{
if
(
!
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
{
PlacesUIUtils
.
markPageAsFollowedLink
(
href
)
;
}
}
catch
(
ex
)
{
}
}
function
handleLinkClick
(
event
href
linkNode
)
{
if
(
event
.
button
=
=
2
)
{
return
false
;
}
var
where
=
BrowserUtils
.
whereToOpenLink
(
event
)
;
if
(
where
=
=
"
current
"
)
{
return
false
;
}
var
doc
=
event
.
target
.
ownerDocument
;
let
referrerInfo
=
Cc
[
"
mozilla
.
org
/
referrer
-
info
;
1
"
]
.
createInstance
(
Ci
.
nsIReferrerInfo
)
;
if
(
linkNode
)
{
referrerInfo
.
initWithElement
(
linkNode
)
;
}
else
{
referrerInfo
.
initWithDocument
(
doc
)
;
}
if
(
where
=
=
"
save
"
)
{
saveURL
(
href
null
linkNode
?
gatherTextUnder
(
linkNode
)
:
"
"
null
true
true
referrerInfo
doc
.
cookieJarSettings
doc
)
;
event
.
preventDefault
(
)
;
return
true
;
}
let
frameID
=
WebNavigationFrames
.
getFrameId
(
doc
.
defaultView
)
;
urlSecurityCheck
(
href
doc
.
nodePrincipal
)
;
let
params
=
{
charset
:
doc
.
characterSet
referrerInfo
originPrincipal
:
doc
.
nodePrincipal
originStoragePrincipal
:
doc
.
effectiveStoragePrincipal
triggeringPrincipal
:
doc
.
nodePrincipal
csp
:
doc
.
csp
frameID
}
;
if
(
doc
.
nodePrincipal
.
originAttributes
.
userContextId
)
{
params
.
userContextId
=
doc
.
nodePrincipal
.
originAttributes
.
userContextId
;
}
openLinkIn
(
href
where
params
)
;
event
.
preventDefault
(
)
;
return
true
;
}
function
middleMousePaste
(
event
)
{
let
clipboard
=
readFromClipboard
(
)
;
if
(
!
clipboard
)
{
return
;
}
clipboard
=
clipboard
.
replace
(
/
\
s
*
\
n
\
s
*
/
g
"
"
)
;
clipboard
=
UrlbarUtils
.
stripUnsafeProtocolOnPaste
(
clipboard
)
;
let
where
=
BrowserUtils
.
whereToOpenLink
(
event
true
false
)
;
let
lastLocationChange
;
if
(
where
=
=
"
current
"
)
{
lastLocationChange
=
gBrowser
.
selectedBrowser
.
lastLocationChange
;
}
UrlbarUtils
.
getShortcutOrURIAndPostData
(
clipboard
)
.
then
(
data
=
>
{
try
{
makeURI
(
data
.
url
)
;
}
catch
(
ex
)
{
return
;
}
try
{
UrlbarUtils
.
addToUrlbarHistory
(
data
.
url
window
)
;
}
catch
(
ex
)
{
console
.
error
(
ex
)
;
}
if
(
where
!
=
"
current
"
|
|
lastLocationChange
=
=
gBrowser
.
selectedBrowser
.
lastLocationChange
)
{
openUILink
(
data
.
url
event
{
ignoreButton
:
true
allowInheritPrincipal
:
data
.
mayInheritPrincipal
triggeringPrincipal
:
gBrowser
.
selectedBrowser
.
contentPrincipal
csp
:
gBrowser
.
selectedBrowser
.
csp
}
)
;
}
}
)
;
if
(
Event
.
isInstance
(
event
)
)
{
event
.
stopPropagation
(
)
;
}
}
function
handleDroppedLink
(
event
urlOrLinks
nameOrTriggeringPrincipal
triggeringPrincipal
)
{
let
links
;
if
(
Array
.
isArray
(
urlOrLinks
)
)
{
links
=
urlOrLinks
;
triggeringPrincipal
=
nameOrTriggeringPrincipal
;
}
else
{
links
=
[
{
url
:
urlOrLinks
nameOrTriggeringPrincipal
type
:
"
"
}
]
;
}
let
lastLocationChange
=
gBrowser
.
selectedBrowser
.
lastLocationChange
;
let
userContextId
=
gBrowser
.
selectedBrowser
.
getAttribute
(
"
usercontextid
"
)
;
let
inBackground
=
false
;
if
(
event
)
{
inBackground
=
Services
.
prefs
.
getBoolPref
(
"
browser
.
tabs
.
loadInBackground
"
)
;
if
(
event
.
shiftKey
)
{
inBackground
=
!
inBackground
;
}
}
(
async
function
(
)
{
if
(
links
.
length
>
=
Services
.
prefs
.
getIntPref
(
"
browser
.
tabs
.
maxOpenBeforeWarn
"
)
)
{
let
answer
=
await
OpenInTabsUtils
.
promiseConfirmOpenInTabs
(
links
.
length
window
)
;
if
(
!
answer
)
{
return
;
}
}
let
urls
=
[
]
;
let
postDatas
=
[
]
;
for
(
let
link
of
links
)
{
let
data
=
await
UrlbarUtils
.
getShortcutOrURIAndPostData
(
link
.
url
)
;
urls
.
push
(
data
.
url
)
;
postDatas
.
push
(
data
.
postData
)
;
}
if
(
lastLocationChange
=
=
gBrowser
.
selectedBrowser
.
lastLocationChange
)
{
gBrowser
.
loadTabs
(
urls
{
inBackground
replace
:
true
allowThirdPartyFixup
:
false
postDatas
userContextId
triggeringPrincipal
}
)
;
}
}
)
(
)
;
if
(
event
)
{
event
.
preventDefault
(
)
;
}
}
var
BrowserOffline
=
{
_inited
:
false
init
(
)
{
if
(
!
this
.
_uiElement
)
{
this
.
_uiElement
=
document
.
getElementById
(
"
cmd_toggleOfflineStatus
"
)
;
}
Services
.
obs
.
addObserver
(
this
"
network
:
offline
-
status
-
changed
"
)
;
this
.
_updateOfflineUI
(
Services
.
io
.
offline
)
;
this
.
_inited
=
true
;
}
uninit
(
)
{
if
(
this
.
_inited
)
{
Services
.
obs
.
removeObserver
(
this
"
network
:
offline
-
status
-
changed
"
)
;
}
}
toggleOfflineStatus
(
)
{
var
ioService
=
Services
.
io
;
if
(
!
ioService
.
offline
&
&
!
this
.
_canGoOffline
(
)
)
{
this
.
_updateOfflineUI
(
false
)
;
return
;
}
ioService
.
offline
=
!
ioService
.
offline
;
}
observe
(
aSubject
aTopic
)
{
if
(
aTopic
!
=
"
network
:
offline
-
status
-
changed
"
)
{
return
;
}
this
.
_updateOfflineUI
(
Services
.
io
.
offline
)
;
}
_canGoOffline
(
)
{
try
{
var
cancelGoOffline
=
Cc
[
"
mozilla
.
org
/
supports
-
PRBool
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsPRBool
)
;
Services
.
obs
.
notifyObservers
(
cancelGoOffline
"
offline
-
requested
"
)
;
if
(
cancelGoOffline
.
data
)
{
return
false
;
}
}
catch
(
ex
)
{
}
return
true
;
}
_uiElement
:
null
_updateOfflineUI
(
aOffline
)
{
var
offlineLocked
=
Services
.
prefs
.
prefIsLocked
(
"
network
.
online
"
)
;
if
(
offlineLocked
)
{
this
.
_uiElement
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
this
.
_uiElement
.
setAttribute
(
"
checked
"
aOffline
)
;
}
}
;
var
CanvasPermissionPromptHelper
=
{
_permissionsPrompt
:
"
canvas
-
permissions
-
prompt
"
_permissionsPromptHideDoorHanger
:
"
canvas
-
permissions
-
prompt
-
hide
-
doorhanger
"
_notificationIcon
:
"
canvas
-
notification
-
icon
"
init
(
)
{
Services
.
obs
.
addObserver
(
this
this
.
_permissionsPrompt
)
;
Services
.
obs
.
addObserver
(
this
this
.
_permissionsPromptHideDoorHanger
)
;
}
uninit
(
)
{
Services
.
obs
.
removeObserver
(
this
this
.
_permissionsPrompt
)
;
Services
.
obs
.
removeObserver
(
this
this
.
_permissionsPromptHideDoorHanger
)
;
}
observe
(
aSubject
aTopic
aData
)
{
if
(
aTopic
!
=
this
.
_permissionsPrompt
&
&
aTopic
!
=
this
.
_permissionsPromptHideDoorHanger
)
{
return
;
}
let
browser
;
if
(
aSubject
instanceof
Ci
.
nsIDOMWindow
)
{
browser
=
aSubject
.
docShell
.
chromeEventHandler
;
}
else
{
browser
=
aSubject
;
}
if
(
gBrowser
.
selectedBrowser
!
=
=
browser
)
{
return
;
}
let
message
=
gNavigatorBundle
.
getFormattedString
(
"
canvas
.
siteprompt2
"
[
"
<
>
"
]
1
)
;
let
principal
=
Services
.
scriptSecurityManager
.
createContentPrincipalFromOrigin
(
aData
)
;
function
setCanvasPermission
(
aPerm
aPersistent
)
{
Services
.
perms
.
addFromPrincipal
(
principal
"
canvas
"
aPerm
aPersistent
?
Ci
.
nsIPermissionManager
.
EXPIRE_NEVER
:
Ci
.
nsIPermissionManager
.
EXPIRE_SESSION
)
;
}
let
mainAction
=
{
label
:
gNavigatorBundle
.
getString
(
"
canvas
.
allow2
"
)
accessKey
:
gNavigatorBundle
.
getString
(
"
canvas
.
allow2
.
accesskey
"
)
callback
(
state
)
{
setCanvasPermission
(
Ci
.
nsIPermissionManager
.
ALLOW_ACTION
state
&
&
state
.
checkboxChecked
)
;
}
}
;
let
secondaryActions
=
[
{
label
:
gNavigatorBundle
.
getString
(
"
canvas
.
block
"
)
accessKey
:
gNavigatorBundle
.
getString
(
"
canvas
.
block
.
accesskey
"
)
callback
(
state
)
{
setCanvasPermission
(
Ci
.
nsIPermissionManager
.
DENY_ACTION
state
&
&
state
.
checkboxChecked
)
;
}
}
]
;
let
checkbox
=
{
show
:
!
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
}
;
if
(
checkbox
.
show
)
{
checkbox
.
checked
=
true
;
checkbox
.
label
=
gBrowserBundle
.
GetStringFromName
(
"
canvas
.
remember2
"
)
;
}
let
options
=
{
checkbox
name
:
principal
.
host
learnMoreURL
:
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
+
"
fingerprint
-
permission
"
dismissed
:
aTopic
=
=
this
.
_permissionsPromptHideDoorHanger
eventCallback
(
e
)
{
if
(
e
=
=
"
showing
"
)
{
this
.
browser
.
ownerDocument
.
getElementById
(
"
canvas
-
permissions
-
prompt
-
warning
"
)
.
textContent
=
gBrowserBundle
.
GetStringFromName
(
"
canvas
.
siteprompt2
.
warning
"
)
;
}
}
}
;
PopupNotifications
.
show
(
browser
this
.
_permissionsPrompt
message
this
.
_notificationIcon
mainAction
secondaryActions
options
)
;
}
}
;
var
WebAuthnPromptHelper
=
{
_icon
:
"
webauthn
-
notification
-
icon
"
_topic
:
"
webauthn
-
prompt
"
_current
:
null
_tid
:
0
_l10n
:
null
init
(
)
{
this
.
_l10n
=
new
Localization
(
[
"
browser
/
webauthnDialog
.
ftl
"
]
true
)
;
Services
.
obs
.
addObserver
(
this
this
.
_topic
)
;
}
uninit
(
)
{
Services
.
obs
.
removeObserver
(
this
this
.
_topic
)
;
}
observe
(
aSubject
aTopic
aData
)
{
switch
(
aTopic
)
{
case
"
fullscreen
-
nav
-
toolbox
"
:
if
(
aData
=
=
"
hidden
"
&
&
this
.
_tid
!
=
0
)
{
FullScreen
.
showNavToolbox
(
)
;
}
return
;
case
"
fullscreen
-
painted
"
:
if
(
this
.
_tid
!
=
0
)
{
FullScreen
.
exitDomFullScreen
(
)
;
}
return
;
case
this
.
_topic
:
break
;
default
:
return
;
}
let
data
=
JSON
.
parse
(
aData
)
;
if
(
data
.
prompt
.
type
=
=
"
cancel
"
)
{
this
.
cancel
(
data
)
;
return
;
}
if
(
data
.
browsingContextId
!
=
=
gBrowser
.
selectedBrowser
.
browsingContext
.
id
)
{
return
;
}
let
mgr
=
Cc
[
"
mozilla
.
org
/
webauthn
/
service
;
1
"
]
.
getService
(
Ci
.
nsIWebAuthnService
)
;
if
(
data
.
prompt
.
type
=
=
"
presence
"
)
{
this
.
presence_required
(
mgr
data
)
;
}
else
if
(
data
.
prompt
.
type
=
=
"
attestation
-
consent
"
)
{
this
.
attestation_consent
(
mgr
data
)
;
}
else
if
(
data
.
prompt
.
type
=
=
"
pin
-
required
"
)
{
this
.
pin_required
(
mgr
false
data
)
;
}
else
if
(
data
.
prompt
.
type
=
=
"
pin
-
invalid
"
)
{
this
.
pin_required
(
mgr
true
data
)
;
}
else
if
(
data
.
prompt
.
type
=
=
"
select
-
sign
-
result
"
)
{
this
.
select_sign_result
(
mgr
data
)
;
}
else
if
(
data
.
prompt
.
type
=
=
"
already
-
registered
"
)
{
this
.
show_info
(
mgr
data
.
origin
data
.
tid
"
alreadyRegistered
"
"
webauthn
.
alreadyRegisteredPrompt
"
)
;
}
else
if
(
data
.
prompt
.
type
=
=
"
select
-
device
"
)
{
this
.
show_info
(
mgr
data
.
origin
data
.
tid
"
selectDevice
"
"
webauthn
.
selectDevicePrompt
"
)
;
}
else
if
(
data
.
prompt
.
type
=
=
"
pin
-
auth
-
blocked
"
)
{
this
.
show_info
(
mgr
data
.
origin
data
.
tid
"
pinAuthBlocked
"
"
webauthn
.
pinAuthBlockedPrompt
"
)
;
}
else
if
(
data
.
prompt
.
type
=
=
"
uv
-
blocked
"
)
{
this
.
show_info
(
mgr
data
.
origin
data
.
tid
"
uvBlocked
"
"
webauthn
.
uvBlockedPrompt
"
)
;
}
else
if
(
data
.
prompt
.
type
=
=
"
uv
-
invalid
"
)
{
let
retriesLeft
=
data
.
prompt
.
retries
;
let
dialogText
;
if
(
retriesLeft
=
=
0
)
{
return
;
}
else
if
(
retriesLeft
<
0
)
{
dialogText
=
this
.
_l10n
.
formatValueSync
(
"
webauthn
-
uv
-
invalid
-
short
-
prompt
"
)
;
}
else
{
dialogText
=
this
.
_l10n
.
formatValueSync
(
"
webauthn
-
uv
-
invalid
-
long
-
prompt
"
{
retriesLeft
}
)
;
}
let
mainAction
=
this
.
buildCancelAction
(
mgr
data
.
tid
)
;
this
.
show_formatted_msg
(
data
.
tid
"
uvInvalid
"
dialogText
mainAction
)
;
}
else
if
(
data
.
prompt
.
type
=
=
"
device
-
blocked
"
)
{
this
.
show_info
(
mgr
data
.
origin
data
.
tid
"
deviceBlocked
"
"
webauthn
.
deviceBlockedPrompt
"
)
;
}
else
if
(
data
.
prompt
.
type
=
=
"
pin
-
not
-
set
"
)
{
this
.
show_info
(
mgr
data
.
origin
data
.
tid
"
pinNotSet
"
"
webauthn
.
pinNotSetPrompt
"
)
;
}
}
prompt_for_password
(
origin
wasInvalid
retriesLeft
aPassword
)
{
this
.
reset
(
)
;
let
dialogText
;
if
(
!
wasInvalid
)
{
dialogText
=
this
.
_l10n
.
formatValueSync
(
"
webauthn
-
pin
-
required
-
prompt
"
)
;
}
else
if
(
retriesLeft
<
0
|
|
retriesLeft
>
3
)
{
dialogText
=
this
.
_l10n
.
formatValueSync
(
"
webauthn
-
pin
-
invalid
-
short
-
prompt
"
)
;
}
else
{
dialogText
=
this
.
_l10n
.
formatValueSync
(
"
webauthn
-
pin
-
invalid
-
long
-
prompt
"
{
retriesLeft
}
)
;
}
let
res
=
Services
.
prompt
.
promptPasswordBC
(
gBrowser
.
selectedBrowser
.
browsingContext
Services
.
prompt
.
MODAL_TYPE_TAB
origin
dialogText
aPassword
)
;
return
res
;
}
select_sign_result
(
mgr
{
origin
tid
prompt
:
{
entities
}
}
)
{
let
unknownAccount
=
this
.
_l10n
.
formatValueSync
(
"
webauthn
-
select
-
sign
-
result
-
unknown
-
account
"
)
;
let
secondaryActions
=
[
]
;
for
(
let
i
=
0
;
i
<
entities
.
length
;
i
+
+
)
{
let
label
=
entities
[
i
]
.
name
?
?
unknownAccount
;
secondaryActions
.
push
(
{
label
accessKey
:
i
.
toString
(
)
callback
(
)
{
mgr
.
selectionCallback
(
tid
i
)
;
}
}
)
;
}
let
mainAction
=
this
.
buildCancelAction
(
mgr
tid
)
;
let
options
=
{
escAction
:
"
buttoncommand
"
}
;
this
.
show
(
tid
"
select
-
sign
-
result
"
"
webauthn
.
selectSignResultPrompt
"
origin
mainAction
secondaryActions
options
)
;
}
pin_required
(
mgr
wasInvalid
{
origin
tid
prompt
:
{
retries
}
}
)
{
let
aPassword
=
Object
.
create
(
null
)
;
let
res
=
this
.
prompt_for_password
(
origin
wasInvalid
retries
aPassword
)
;
if
(
res
)
{
mgr
.
pinCallback
(
tid
aPassword
.
value
)
;
}
else
{
mgr
.
cancel
(
tid
)
;
}
}
presence_required
(
mgr
{
origin
tid
}
)
{
let
mainAction
=
this
.
buildCancelAction
(
mgr
tid
)
;
let
options
=
{
escAction
:
"
buttoncommand
"
}
;
let
secondaryActions
=
[
]
;
let
message
=
"
webauthn
.
userPresencePrompt
"
;
this
.
show
(
tid
"
presence
"
message
origin
mainAction
secondaryActions
options
)
;
}
attestation_consent
(
mgr
{
origin
tid
}
)
{
let
mainAction
=
{
label
:
gNavigatorBundle
.
getString
(
"
webauthn
.
allow
"
)
accessKey
:
gNavigatorBundle
.
getString
(
"
webauthn
.
allow
.
accesskey
"
)
callback
(
_state
)
{
mgr
.
setHasAttestationConsent
(
tid
true
)
;
}
}
;
let
secondaryActions
=
[
{
label
:
gNavigatorBundle
.
getString
(
"
webauthn
.
block
"
)
accessKey
:
gNavigatorBundle
.
getString
(
"
webauthn
.
block
.
accesskey
"
)
callback
(
_state
)
{
mgr
.
setHasAttestationConsent
(
tid
false
)
;
}
}
]
;
let
learnMoreURL
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
+
"
webauthn
-
direct
-
attestation
"
;
let
options
=
{
learnMoreURL
hintText
:
"
webauthn
.
registerDirectPromptHint
"
}
;
this
.
show
(
tid
"
register
-
direct
"
"
webauthn
.
registerDirectPrompt3
"
origin
mainAction
secondaryActions
options
)
;
}
show_info
(
mgr
origin
tid
id
stringId
)
{
let
mainAction
=
this
.
buildCancelAction
(
mgr
tid
)
;
this
.
show
(
tid
id
stringId
origin
mainAction
)
;
}
show
(
tid
id
stringId
origin
mainAction
secondaryActions
=
[
]
options
=
{
}
)
{
let
brandShortName
=
document
.
getElementById
(
"
bundle_brand
"
)
.
getString
(
"
brandShortName
"
)
;
let
message
=
gNavigatorBundle
.
getFormattedString
(
stringId
[
"
<
>
"
brandShortName
]
)
;
try
{
origin
=
Services
.
io
.
newURI
(
origin
)
.
asciiHost
;
}
catch
(
e
)
{
}
options
.
name
=
origin
;
this
.
show_formatted_msg
(
tid
id
message
mainAction
secondaryActions
options
)
;
}
show_formatted_msg
(
tid
id
message
mainAction
secondaryActions
=
[
]
options
=
{
}
)
{
this
.
reset
(
)
;
this
.
_tid
=
tid
;
Services
.
obs
.
addObserver
(
this
"
fullscreen
-
painted
"
)
;
Services
.
obs
.
addObserver
(
this
"
fullscreen
-
nav
-
toolbox
"
)
;
FullScreen
.
exitDomFullScreen
(
)
;
if
(
window
.
fullScreen
)
{
FullScreen
.
showNavToolbox
(
)
;
}
let
brandShortName
=
document
.
getElementById
(
"
bundle_brand
"
)
.
getString
(
"
brandShortName
"
)
;
if
(
options
.
hintText
)
{
options
.
hintText
=
gNavigatorBundle
.
getFormattedString
(
options
.
hintText
[
brandShortName
]
)
;
}
options
.
hideClose
=
true
;
options
.
persistent
=
true
;
options
.
eventCallback
=
event
=
>
{
if
(
event
=
=
"
removed
"
)
{
Services
.
obs
.
removeObserver
(
this
"
fullscreen
-
painted
"
)
;
Services
.
obs
.
removeObserver
(
this
"
fullscreen
-
nav
-
toolbox
"
)
;
this
.
_current
=
null
;
this
.
_tid
=
0
;
}
}
;
this
.
_current
=
PopupNotifications
.
show
(
gBrowser
.
selectedBrowser
webauthn
-
prompt
-
{
id
}
message
this
.
_icon
mainAction
secondaryActions
options
)
;
}
cancel
(
{
tid
}
)
{
if
(
this
.
_tid
=
=
tid
)
{
this
.
reset
(
)
;
}
}
reset
(
)
{
if
(
this
.
_current
)
{
this
.
_current
.
remove
(
)
;
}
}
buildCancelAction
(
mgr
tid
)
{
return
{
label
:
gNavigatorBundle
.
getString
(
"
webauthn
.
cancel
"
)
accessKey
:
gNavigatorBundle
.
getString
(
"
webauthn
.
cancel
.
accesskey
"
)
callback
(
)
{
mgr
.
cancel
(
tid
)
;
}
}
;
}
}
;
function
CanCloseWindow
(
)
{
if
(
Services
.
startup
.
shuttingDown
|
|
window
.
skipNextCanClose
)
{
return
true
;
}
for
(
let
browser
of
gBrowser
.
browsers
)
{
if
(
!
browser
.
isConnected
)
{
continue
;
}
let
{
permitUnload
}
=
browser
.
permitUnload
(
)
;
if
(
!
permitUnload
)
{
return
false
;
}
}
return
true
;
}
function
WindowIsClosing
(
event
)
{
let
source
;
if
(
event
)
{
let
target
=
event
.
sourceEvent
?
.
target
;
if
(
target
?
.
id
?
.
startsWith
(
"
menu_
"
)
)
{
source
=
"
menuitem
"
;
}
else
if
(
target
?
.
nodeName
=
=
"
toolbarbutton
"
)
{
source
=
"
close
-
button
"
;
}
else
{
let
key
=
AppConstants
.
platform
=
=
"
macosx
"
?
"
metaKey
"
:
"
ctrlKey
"
;
source
=
event
[
key
]
?
"
shortcut
"
:
"
OS
"
;
}
}
if
(
!
closeWindow
(
false
warnAboutClosingWindow
source
)
)
{
return
false
;
}
if
(
CanCloseWindow
(
)
)
{
window
.
skipNextCanClose
=
true
;
return
true
;
}
return
false
;
}
function
warnAboutClosingWindow
(
source
)
{
let
isPBWindow
=
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
&
&
!
PrivateBrowsingUtils
.
permanentPrivateBrowsing
;
if
(
!
isPBWindow
&
&
!
toolbar
.
visible
)
{
return
gBrowser
.
warnAboutClosingTabs
(
gBrowser
.
visibleTabs
.
length
gBrowser
.
closingTabsEnum
.
ALL
source
)
;
}
let
otherPBWindowExists
=
false
;
let
otherWindowExists
=
false
;
for
(
let
win
of
browserWindows
(
)
)
{
if
(
!
win
.
closed
&
&
win
!
=
window
)
{
otherWindowExists
=
true
;
if
(
isPBWindow
&
&
PrivateBrowsingUtils
.
isWindowPrivate
(
win
)
)
{
otherPBWindowExists
=
true
;
}
if
(
!
isPBWindow
|
|
otherPBWindowExists
)
{
break
;
}
}
}
if
(
isPBWindow
&
&
!
otherPBWindowExists
)
{
let
exitingCanceled
=
Cc
[
"
mozilla
.
org
/
supports
-
PRBool
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsPRBool
)
;
exitingCanceled
.
data
=
false
;
Services
.
obs
.
notifyObservers
(
exitingCanceled
"
last
-
pb
-
context
-
exiting
"
)
;
if
(
exitingCanceled
.
data
)
{
return
false
;
}
Services
.
obs
.
notifyObservers
(
null
"
last
-
pb
-
context
-
exiting
-
granted
"
)
;
}
if
(
otherWindowExists
)
{
return
(
isPBWindow
|
|
gBrowser
.
warnAboutClosingTabs
(
gBrowser
.
visibleTabs
.
length
gBrowser
.
closingTabsEnum
.
ALL
source
)
)
;
}
let
os
=
Services
.
obs
;
let
closingCanceled
=
Cc
[
"
mozilla
.
org
/
supports
-
PRBool
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsPRBool
)
;
os
.
notifyObservers
(
closingCanceled
"
browser
-
lastwindow
-
close
-
requested
"
)
;
if
(
closingCanceled
.
data
)
{
return
false
;
}
os
.
notifyObservers
(
null
"
browser
-
lastwindow
-
close
-
granted
"
)
;
return
(
AppConstants
.
platform
!
=
"
macosx
"
|
|
isPBWindow
|
|
gBrowser
.
warnAboutClosingTabs
(
gBrowser
.
visibleTabs
.
length
gBrowser
.
closingTabsEnum
.
ALL
source
)
)
;
}
var
MailIntegration
=
{
sendLinkForBrowser
(
aBrowser
)
{
this
.
sendMessage
(
gURLBar
.
makeURIReadable
(
aBrowser
.
currentURI
)
.
displaySpec
aBrowser
.
contentTitle
)
;
}
sendMessage
(
aBody
aSubject
)
{
var
mailtoUrl
=
"
mailto
:
"
;
if
(
aBody
)
{
mailtoUrl
+
=
"
?
body
=
"
+
encodeURIComponent
(
aBody
)
;
mailtoUrl
+
=
"
&
subject
=
"
+
encodeURIComponent
(
aSubject
)
;
}
var
uri
=
makeURI
(
mailtoUrl
)
;
this
.
_launchExternalUrl
(
uri
)
;
}
_launchExternalUrl
(
aURL
)
{
var
extProtocolSvc
=
Cc
[
"
mozilla
.
org
/
uriloader
/
external
-
protocol
-
service
;
1
"
]
.
getService
(
Ci
.
nsIExternalProtocolService
)
;
if
(
extProtocolSvc
)
{
extProtocolSvc
.
loadURI
(
aURL
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
)
;
}
}
}
;
function
AddKeywordForSearchField
(
)
{
if
(
!
gContextMenu
)
{
throw
new
Error
(
"
Context
menu
doesn
'
t
seem
to
be
open
.
"
)
;
}
gContextMenu
.
addKeywordForSearchField
(
)
;
}
function
restoreLastClosedTabOrWindowOrSession
(
)
{
let
lastActionTaken
=
SessionStore
.
popLastClosedAction
(
)
;
if
(
lastActionTaken
)
{
switch
(
lastActionTaken
.
type
)
{
case
SessionStore
.
LAST_ACTION_CLOSED_TAB
:
{
undoCloseTab
(
)
;
break
;
}
case
SessionStore
.
LAST_ACTION_CLOSED_WINDOW
:
{
undoCloseWindow
(
)
;
break
;
}
}
}
else
{
let
closedTabCount
=
SessionStore
.
getLastClosedTabCount
(
window
)
;
if
(
SessionStore
.
canRestoreLastSession
)
{
SessionStore
.
restoreLastSession
(
)
;
}
else
if
(
closedTabCount
)
{
undoCloseTab
(
)
;
}
}
}
function
undoCloseTab
(
aIndex
sourceWindowSSId
)
{
let
targetWindow
=
window
;
let
sourceWindow
;
if
(
sourceWindowSSId
)
{
sourceWindow
=
SessionStore
.
getWindowById
(
sourceWindowSSId
)
;
if
(
!
sourceWindow
)
{
throw
new
Error
(
"
sourceWindowSSId
argument
to
undoCloseTab
didn
'
t
resolve
to
a
window
"
)
;
}
}
else
{
sourceWindow
=
window
;
}
let
blankTabToRemove
=
null
;
if
(
targetWindow
.
gBrowser
.
visibleTabs
.
length
=
=
1
&
&
targetWindow
.
gBrowser
.
selectedTab
.
isEmpty
)
{
blankTabToRemove
=
targetWindow
.
gBrowser
.
selectedTab
;
}
let
lastClosedTabCount
=
SessionStore
.
getLastClosedTabCount
(
sourceWindow
)
;
let
tab
=
null
;
let
tabsToRemove
=
aIndex
!
=
=
undefined
?
[
aIndex
]
:
new
Array
(
lastClosedTabCount
)
.
fill
(
0
)
;
let
tabsRemoved
=
false
;
for
(
let
index
of
tabsToRemove
)
{
if
(
SessionStore
.
getClosedTabCountForWindow
(
sourceWindow
)
>
index
)
{
tab
=
SessionStore
.
undoCloseTab
(
sourceWindow
index
targetWindow
)
;
tabsRemoved
=
true
;
}
}
if
(
tabsRemoved
&
&
blankTabToRemove
)
{
targetWindow
.
gBrowser
.
removeTab
(
blankTabToRemove
)
;
}
return
tab
;
}
function
undoCloseWindow
(
aIndex
)
{
let
window
=
null
;
if
(
SessionStore
.
getClosedWindowCount
(
)
>
(
aIndex
|
|
0
)
)
{
window
=
SessionStore
.
undoCloseWindow
(
aIndex
|
|
0
)
;
}
return
window
;
}
function
ReportFalseDeceptiveSite
(
)
{
let
contextsToVisit
=
[
gBrowser
.
selectedBrowser
.
browsingContext
]
;
while
(
contextsToVisit
.
length
)
{
let
currentContext
=
contextsToVisit
.
pop
(
)
;
let
global
=
currentContext
.
currentWindowGlobal
;
if
(
!
global
)
{
continue
;
}
let
docURI
=
global
.
documentURI
;
if
(
docURI
&
&
docURI
.
spec
.
startsWith
(
"
about
:
blocked
?
e
=
deceptiveBlocked
"
)
)
{
let
actor
=
global
.
getActor
(
"
BlockedSite
"
)
;
actor
.
sendQuery
(
"
DeceptiveBlockedDetails
"
)
.
then
(
data
=
>
{
let
reportUrl
=
gSafeBrowsing
.
getReportURL
(
"
PhishMistake
"
data
.
blockedInfo
)
;
if
(
reportUrl
)
{
openTrustedLinkIn
(
reportUrl
"
tab
"
)
;
}
else
{
let
bundle
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
browser
/
locale
/
safebrowsing
/
safebrowsing
.
properties
"
)
;
Services
.
prompt
.
alert
(
window
bundle
.
GetStringFromName
(
"
errorReportFalseDeceptiveTitle
"
)
bundle
.
formatStringFromName
(
"
errorReportFalseDeceptiveMessage
"
[
data
.
blockedInfo
.
provider
]
)
)
;
}
}
)
;
}
contextsToVisit
.
push
(
.
.
.
currentContext
.
children
)
;
}
}
function
ReportSiteIssue
(
)
{
let
subject
=
{
wrappedJSObject
:
gBrowser
.
selectedTab
}
;
Services
.
obs
.
notifyObservers
(
subject
"
report
-
site
-
issue
"
)
;
}
const
gRemoteControl
=
{
observe
(
)
{
gRemoteControl
.
updateVisualCue
(
)
;
}
updateVisualCue
(
)
{
const
disableRemoteControlCue
=
Services
.
prefs
.
getBoolPref
(
"
browser
.
chrome
.
disableRemoteControlCueForTests
"
false
)
;
if
(
disableRemoteControlCue
&
&
Cu
.
isInAutomation
)
{
return
;
}
const
mainWindow
=
document
.
documentElement
;
const
remoteControlComponent
=
this
.
getRemoteControlComponent
(
)
;
if
(
remoteControlComponent
)
{
mainWindow
.
setAttribute
(
"
remotecontrol
"
"
true
"
)
;
const
remoteControlIcon
=
document
.
getElementById
(
"
remote
-
control
-
icon
"
)
;
document
.
l10n
.
setAttributes
(
remoteControlIcon
"
urlbar
-
remote
-
control
-
notification
-
anchor2
"
{
component
:
remoteControlComponent
}
)
;
}
else
{
mainWindow
.
removeAttribute
(
"
remotecontrol
"
)
;
}
}
getRemoteControlComponent
(
)
{
if
(
DevToolsSocketStatus
.
hasSocketOpened
(
{
excludeBrowserToolboxSockets
:
true
}
)
)
{
return
"
DevTools
"
;
}
if
(
Marionette
.
running
)
{
return
"
Marionette
"
;
}
if
(
RemoteAgent
.
running
)
{
return
"
RemoteAgent
"
;
}
return
null
;
}
}
;
var
gPrivateBrowsingUI
=
{
init
:
function
PBUI_init
(
)
{
if
(
!
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
{
return
;
}
PBMExitStatus
.
init
(
)
;
document
.
getElementById
(
"
Tools
:
Sanitize
"
)
.
setAttribute
(
"
disabled
"
"
true
"
)
;
if
(
window
.
location
.
href
!
=
AppConstants
.
BROWSER_CHROME_URL
)
{
return
;
}
let
docElement
=
document
.
documentElement
;
docElement
.
setAttribute
(
"
privatebrowsingmode
"
PrivateBrowsingUtils
.
permanentPrivateBrowsing
?
"
permanent
"
:
"
temporary
"
)
;
gBrowser
.
updateTitlebar
(
)
;
if
(
gUseFeltPrivacyUI
)
{
const
saveToPocketButton
=
document
.
getElementById
(
"
save
-
to
-
pocket
-
button
"
)
;
if
(
saveToPocketButton
)
{
saveToPocketButton
.
remove
(
)
;
document
.
documentElement
.
setAttribute
(
"
pocketdisabled
"
"
true
"
)
;
}
}
if
(
PrivateBrowsingUtils
.
permanentPrivateBrowsing
)
{
let
newWindow
=
document
.
getElementById
(
"
menu_newNavigator
"
)
;
let
newPrivateWindow
=
document
.
getElementById
(
"
menu_newPrivateWindow
"
)
;
if
(
newWindow
&
&
newPrivateWindow
)
{
newPrivateWindow
.
hidden
=
true
;
newWindow
.
label
=
newPrivateWindow
.
label
;
newWindow
.
accessKey
=
newPrivateWindow
.
accessKey
;
newWindow
.
command
=
newPrivateWindow
.
command
;
}
}
}
}
;
function
switchToTabHavingURI
(
aURI
aOpenNew
aOpenParams
=
{
}
aUserContextId
=
null
)
{
const
kPrivateBrowsingWhitelist
=
new
Set
(
[
"
about
:
addons
"
]
)
;
let
ignoreFragment
=
aOpenParams
.
ignoreFragment
;
let
ignoreQueryString
=
aOpenParams
.
ignoreQueryString
;
let
replaceQueryString
=
aOpenParams
.
replaceQueryString
;
let
adoptIntoActiveWindow
=
aOpenParams
.
adoptIntoActiveWindow
;
delete
aOpenParams
.
ignoreFragment
;
delete
aOpenParams
.
ignoreQueryString
;
delete
aOpenParams
.
replaceQueryString
;
delete
aOpenParams
.
adoptIntoActiveWindow
;
let
isBrowserWindow
=
!
!
window
.
gBrowser
;
function
switchIfURIInWindow
(
aWindow
)
{
if
(
!
kPrivateBrowsingWhitelist
.
has
(
aURI
.
spec
)
&
&
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
!
=
=
PrivateBrowsingUtils
.
isWindowPrivate
(
aWindow
)
)
{
return
false
;
}
function
cleanURL
(
url
removeQuery
removeFragment
)
{
let
ret
=
url
;
if
(
removeFragment
)
{
ret
=
ret
.
split
(
"
#
"
)
[
0
]
;
if
(
removeQuery
)
{
ret
=
ret
.
split
(
"
?
"
)
[
0
]
;
}
}
else
if
(
removeQuery
)
{
let
fragment
=
ret
.
split
(
"
#
"
)
[
1
]
;
ret
=
ret
.
split
(
"
?
"
)
[
0
]
.
concat
(
fragment
!
=
undefined
?
"
#
"
.
concat
(
fragment
)
:
"
"
)
;
}
return
ret
;
}
let
ignoreFragmentWhenComparing
=
typeof
ignoreFragment
=
=
"
string
"
&
&
ignoreFragment
.
startsWith
(
"
whenComparing
"
)
;
let
requestedCompare
=
cleanURL
(
aURI
.
displaySpec
ignoreQueryString
|
|
replaceQueryString
ignoreFragmentWhenComparing
)
;
let
browsers
=
aWindow
.
gBrowser
.
browsers
;
for
(
let
i
=
0
;
i
<
browsers
.
length
;
i
+
+
)
{
let
browser
=
browsers
[
i
]
;
let
browserCompare
=
cleanURL
(
browser
.
currentURI
.
displaySpec
ignoreQueryString
|
|
replaceQueryString
ignoreFragmentWhenComparing
)
;
let
browserUserContextId
=
browser
.
getAttribute
(
"
usercontextid
"
)
|
|
"
"
;
if
(
aUserContextId
!
=
null
&
&
aUserContextId
!
=
browserUserContextId
)
{
continue
;
}
if
(
requestedCompare
=
=
browserCompare
)
{
let
doAdopt
=
adoptIntoActiveWindow
&
&
isBrowserWindow
&
&
aWindow
!
=
window
;
if
(
doAdopt
)
{
const
newTab
=
window
.
gBrowser
.
adoptTab
(
aWindow
.
gBrowser
.
getTabForBrowser
(
browser
)
window
.
gBrowser
.
tabContainer
.
selectedIndex
+
1
true
)
;
if
(
!
newTab
)
{
doAdopt
=
false
;
}
}
if
(
!
doAdopt
)
{
aWindow
.
focus
(
)
;
}
if
(
ignoreFragment
=
=
"
whenComparingAndReplace
"
|
|
replaceQueryString
)
{
browser
.
loadURI
(
aURI
{
triggeringPrincipal
:
aOpenParams
.
triggeringPrincipal
|
|
_createNullPrincipalFromTabUserContextId
(
)
}
)
;
}
if
(
!
doAdopt
)
{
aWindow
.
gBrowser
.
tabContainer
.
selectedIndex
=
i
;
}
return
true
;
}
}
return
false
;
}
if
(
!
(
aURI
instanceof
Ci
.
nsIURI
)
)
{
aURI
=
Services
.
io
.
newURI
(
aURI
)
;
}
if
(
isBrowserWindow
&
&
switchIfURIInWindow
(
window
)
)
{
return
true
;
}
for
(
let
browserWin
of
browserWindows
(
)
)
{
if
(
browserWin
.
closed
|
|
browserWin
=
=
window
)
{
continue
;
}
if
(
switchIfURIInWindow
(
browserWin
)
)
{
return
true
;
}
}
if
(
aOpenNew
)
{
if
(
UrlbarPrefs
.
get
(
"
switchTabs
.
searchAllContainers
"
)
&
&
aUserContextId
!
=
null
)
{
aOpenParams
.
userContextId
=
aUserContextId
;
}
if
(
isBrowserWindow
&
&
gBrowser
.
selectedTab
.
isEmpty
)
{
openTrustedLinkIn
(
aURI
.
spec
"
current
"
aOpenParams
)
;
}
else
{
openTrustedLinkIn
(
aURI
.
spec
"
tab
"
aOpenParams
)
;
}
}
return
false
;
}
var
RestoreLastSessionObserver
=
{
init
(
)
{
if
(
SessionStore
.
canRestoreLastSession
&
&
!
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
{
Services
.
obs
.
addObserver
(
this
"
sessionstore
-
last
-
session
-
cleared
"
true
)
;
goSetCommandEnabled
(
"
Browser
:
RestoreLastSession
"
true
)
;
}
else
if
(
SessionStore
.
willAutoRestore
)
{
document
.
getElementById
(
"
Browser
:
RestoreLastSession
"
)
.
hidden
=
true
;
}
}
observe
(
)
{
Services
.
obs
.
removeObserver
(
this
"
sessionstore
-
last
-
session
-
cleared
"
)
;
goSetCommandEnabled
(
"
Browser
:
RestoreLastSession
"
false
)
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIObserver
"
"
nsISupportsWeakReference
"
]
)
}
;
var
MenuTouchModeObserver
=
{
init
(
)
{
window
.
addEventListener
(
"
popupshowing
"
this
true
)
;
}
handleEvent
(
event
)
{
let
target
=
event
.
originalTarget
;
if
(
event
.
inputSource
=
=
MouseEvent
.
MOZ_SOURCE_TOUCH
)
{
target
.
setAttribute
(
"
touchmode
"
"
true
"
)
;
}
else
{
target
.
removeAttribute
(
"
touchmode
"
)
;
}
}
uninit
(
)
{
window
.
removeEventListener
(
"
popupshowing
"
this
true
)
;
}
}
;
function
safeModeRestart
(
)
{
if
(
Services
.
appinfo
.
inSafeMode
)
{
let
cancelQuit
=
Cc
[
"
mozilla
.
org
/
supports
-
PRBool
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsPRBool
)
;
Services
.
obs
.
notifyObservers
(
cancelQuit
"
quit
-
application
-
requested
"
"
restart
"
)
;
if
(
cancelQuit
.
data
)
{
return
;
}
Services
.
startup
.
quit
(
Ci
.
nsIAppStartup
.
eRestart
|
Ci
.
nsIAppStartup
.
eAttemptQuit
)
;
return
;
}
Services
.
obs
.
notifyObservers
(
window
"
restart
-
in
-
safe
-
mode
"
)
;
}
function
duplicateTabIn
(
aTab
where
delta
)
{
switch
(
where
)
{
case
"
window
"
:
{
let
otherWin
=
OpenBrowserWindow
(
{
private
:
PrivateBrowsingUtils
.
isBrowserPrivate
(
aTab
.
linkedBrowser
)
}
)
;
let
delayedStartupFinished
=
(
subject
topic
)
=
>
{
if
(
topic
=
=
"
browser
-
delayed
-
startup
-
finished
"
&
&
subject
=
=
otherWin
)
{
Services
.
obs
.
removeObserver
(
delayedStartupFinished
topic
)
;
let
otherGBrowser
=
otherWin
.
gBrowser
;
let
otherTab
=
otherGBrowser
.
selectedTab
;
SessionStore
.
duplicateTab
(
otherWin
aTab
delta
)
;
otherGBrowser
.
removeTab
(
otherTab
{
animate
:
false
}
)
;
}
}
;
Services
.
obs
.
addObserver
(
delayedStartupFinished
"
browser
-
delayed
-
startup
-
finished
"
)
;
break
;
}
case
"
tabshifted
"
:
SessionStore
.
duplicateTab
(
window
aTab
delta
)
;
break
;
case
"
tab
"
:
SessionStore
.
duplicateTab
(
window
aTab
delta
true
{
inBackground
:
false
}
)
;
break
;
}
}
var
MousePosTracker
=
{
_listeners
:
new
Set
(
)
_x
:
0
_y
:
0
addListener
(
listener
)
{
if
(
this
.
_listeners
.
has
(
listener
)
)
{
return
;
}
listener
.
_hover
=
false
;
this
.
_listeners
.
add
(
listener
)
;
this
.
_callListener
(
listener
)
;
}
removeListener
(
listener
)
{
this
.
_listeners
.
delete
(
listener
)
;
}
handleEvent
(
event
)
{
this
.
_x
=
event
.
screenX
-
window
.
mozInnerScreenX
;
this
.
_y
=
event
.
screenY
-
window
.
mozInnerScreenY
;
this
.
_listeners
.
forEach
(
listener
=
>
{
try
{
this
.
_callListener
(
listener
)
;
}
catch
(
e
)
{
console
.
error
(
e
)
;
}
}
)
;
}
_callListener
(
listener
)
{
let
rect
=
listener
.
getMouseTargetRect
(
)
;
let
hover
=
this
.
_x
>
=
rect
.
left
&
&
this
.
_x
<
=
rect
.
right
&
&
this
.
_y
>
=
rect
.
top
&
&
this
.
_y
<
=
rect
.
bottom
;
if
(
hover
=
=
listener
.
_hover
)
{
return
;
}
listener
.
_hover
=
hover
;
if
(
hover
)
{
if
(
listener
.
onMouseEnter
)
{
listener
.
onMouseEnter
(
)
;
}
}
else
if
(
listener
.
onMouseLeave
)
{
listener
.
onMouseLeave
(
)
;
}
}
}
;
var
ToolbarIconColor
=
{
_windowState
:
{
active
:
false
fullscreen
:
false
tabsintitlebar
:
false
}
init
(
)
{
this
.
_initialized
=
true
;
window
.
addEventListener
(
"
nativethemechange
"
this
)
;
window
.
addEventListener
(
"
activate
"
this
)
;
window
.
addEventListener
(
"
deactivate
"
this
)
;
window
.
addEventListener
(
"
toolbarvisibilitychange
"
this
)
;
window
.
addEventListener
(
"
windowlwthemeupdate
"
this
)
;
if
(
Services
.
focus
.
activeWindow
=
=
window
)
{
this
.
inferFromText
(
"
activate
"
)
;
}
}
uninit
(
)
{
this
.
_initialized
=
false
;
window
.
removeEventListener
(
"
nativethemechange
"
this
)
;
window
.
removeEventListener
(
"
activate
"
this
)
;
window
.
removeEventListener
(
"
deactivate
"
this
)
;
window
.
removeEventListener
(
"
toolbarvisibilitychange
"
this
)
;
window
.
removeEventListener
(
"
windowlwthemeupdate
"
this
)
;
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
activate
"
:
case
"
deactivate
"
:
case
"
nativethemechange
"
:
case
"
windowlwthemeupdate
"
:
this
.
inferFromText
(
event
.
type
)
;
break
;
case
"
toolbarvisibilitychange
"
:
this
.
inferFromText
(
event
.
type
event
.
visible
)
;
break
;
}
}
_toolbarLuminanceCache
:
new
Map
(
)
inferFromText
(
reason
reasonValue
)
{
if
(
!
this
.
_initialized
)
{
return
;
}
switch
(
reason
)
{
case
"
activate
"
:
case
"
deactivate
"
:
this
.
_windowState
.
active
=
reason
=
=
=
"
activate
"
;
break
;
case
"
fullscreen
"
:
this
.
_windowState
.
fullscreen
=
reasonValue
;
break
;
case
"
nativethemechange
"
:
case
"
windowlwthemeupdate
"
:
this
.
_toolbarLuminanceCache
.
clear
(
)
;
break
;
case
"
toolbarvisibilitychange
"
:
break
;
case
"
tabsintitlebar
"
:
this
.
_windowState
.
tabsintitlebar
=
reasonValue
;
break
;
}
let
toolbarSelector
=
"
.
browser
-
toolbar
:
not
(
[
collapsed
=
true
]
)
"
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
toolbarSelector
+
=
"
:
not
(
[
type
=
menubar
]
)
"
;
}
let
cachedLuminances
=
this
.
_toolbarLuminanceCache
;
let
luminances
=
new
Map
(
)
;
for
(
let
toolbar
of
document
.
querySelectorAll
(
toolbarSelector
)
)
{
let
cacheKey
=
toolbar
.
id
&
&
toolbar
.
id
+
JSON
.
stringify
(
this
.
_windowState
)
;
let
luminance
=
cacheKey
&
&
cachedLuminances
.
get
(
cacheKey
)
;
if
(
isNaN
(
luminance
)
)
{
let
{
r
g
b
}
=
InspectorUtils
.
colorToRGBA
(
getComputedStyle
(
toolbar
)
.
color
)
;
luminance
=
0
.
2125
*
r
+
0
.
7154
*
g
+
0
.
0721
*
b
;
if
(
cacheKey
)
{
cachedLuminances
.
set
(
cacheKey
luminance
)
;
}
}
luminances
.
set
(
toolbar
luminance
)
;
}
const
luminanceThreshold
=
127
;
for
(
let
[
toolbar
luminance
]
of
luminances
)
{
if
(
luminance
<
=
luminanceThreshold
)
{
toolbar
.
removeAttribute
(
"
brighttext
"
)
;
}
else
{
toolbar
.
setAttribute
(
"
brighttext
"
"
true
"
)
;
}
}
}
}
;
var
PanicButtonNotifier
=
{
init
(
)
{
this
.
_initialized
=
true
;
if
(
window
.
PanicButtonNotifierShouldNotify
)
{
delete
window
.
PanicButtonNotifierShouldNotify
;
this
.
notify
(
)
;
}
}
createPanelIfNeeded
(
)
{
if
(
!
document
.
getElementById
(
"
panic
-
button
-
success
-
notification
"
)
)
{
let
template
=
document
.
getElementById
(
"
panicButtonNotificationTemplate
"
)
;
template
.
replaceWith
(
template
.
content
)
;
}
}
notify
(
)
{
if
(
!
this
.
_initialized
)
{
window
.
PanicButtonNotifierShouldNotify
=
true
;
return
;
}
try
{
this
.
createPanelIfNeeded
(
)
;
let
popup
=
document
.
getElementById
(
"
panic
-
button
-
success
-
notification
"
)
;
popup
.
hidden
=
false
;
let
onTimeout
=
(
)
=
>
{
PanicButtonNotifier
.
close
(
)
;
removeListeners
(
)
;
}
;
popup
.
addEventListener
(
"
popupshown
"
function
(
)
{
PanicButtonNotifier
.
timer
=
setTimeout
(
onTimeout
3000
)
;
}
)
;
let
onUserInteractsWithPopup
=
(
)
=
>
{
clearTimeout
(
PanicButtonNotifier
.
timer
)
;
removeListeners
(
)
;
}
;
popup
.
addEventListener
(
"
mouseover
"
onUserInteractsWithPopup
)
;
window
.
addEventListener
(
"
keydown
"
onUserInteractsWithPopup
)
;
let
removeListeners
=
(
)
=
>
{
popup
.
removeEventListener
(
"
mouseover
"
onUserInteractsWithPopup
)
;
window
.
removeEventListener
(
"
keydown
"
onUserInteractsWithPopup
)
;
popup
.
removeEventListener
(
"
popuphidden
"
removeListeners
)
;
}
;
popup
.
addEventListener
(
"
popuphidden
"
removeListeners
)
;
let
widget
=
CustomizableUI
.
getWidget
(
"
panic
-
button
"
)
.
forWindow
(
window
)
;
let
anchor
=
widget
.
anchor
.
icon
;
popup
.
openPopup
(
anchor
popup
.
getAttribute
(
"
position
"
)
)
;
}
catch
(
ex
)
{
console
.
error
(
ex
)
;
}
}
close
(
)
{
let
popup
=
document
.
getElementById
(
"
panic
-
button
-
success
-
notification
"
)
;
popup
.
hidePopup
(
)
;
}
}
;
const
SafeBrowsingNotificationBox
=
{
_currentURIBaseDomain
:
null
async
show
(
title
buttons
)
{
let
uri
=
gBrowser
.
currentURI
;
try
{
this
.
_currentURIBaseDomain
=
Services
.
eTLD
.
getBaseDomain
(
uri
)
;
}
catch
(
e
)
{
this
.
_currentURIBaseDomain
=
uri
.
asciiHost
|
|
uri
.
asciiSpec
;
}
let
notificationBox
=
gBrowser
.
getNotificationBox
(
)
;
let
value
=
"
blocked
-
badware
-
page
"
;
let
previousNotification
=
notificationBox
.
getNotificationWithValue
(
value
)
;
if
(
previousNotification
)
{
notificationBox
.
removeNotification
(
previousNotification
)
;
}
let
notification
=
await
notificationBox
.
appendNotification
(
value
{
label
:
title
image
:
"
chrome
:
/
/
global
/
skin
/
icons
/
blocked
.
svg
"
priority
:
notificationBox
.
PRIORITY_CRITICAL_HIGH
}
buttons
)
;
notification
.
persistence
=
-
1
;
}
onLocationChange
(
aLocationURI
)
{
if
(
!
this
.
_currentURIBaseDomain
)
{
return
;
}
let
newURIBaseDomain
=
Services
.
eTLD
.
getBaseDomain
(
aLocationURI
)
;
if
(
newURIBaseDomain
!
=
=
this
.
_currentURIBaseDomain
)
{
let
notificationBox
=
gBrowser
.
getNotificationBox
(
)
;
let
notification
=
notificationBox
.
getNotificationWithValue
(
"
blocked
-
badware
-
page
"
)
;
if
(
notification
)
{
notificationBox
.
removeNotification
(
notification
false
)
;
}
this
.
_currentURIBaseDomain
=
null
;
}
}
}
;
class
TabDialogBox
{
static
_containerFor
(
browser
)
{
return
browser
.
closest
(
"
.
browserStack
.
webextension
-
popup
-
stack
"
)
;
}
constructor
(
browser
)
{
this
.
_weakBrowserRef
=
Cu
.
getWeakReference
(
browser
)
;
let
template
=
document
.
getElementById
(
"
dialogStackTemplate
"
)
;
let
dialogStack
=
template
.
content
.
cloneNode
(
true
)
.
firstElementChild
;
dialogStack
.
classList
.
add
(
"
tab
-
prompt
-
dialog
"
)
;
TabDialogBox
.
_containerFor
(
browser
)
.
appendChild
(
dialogStack
)
;
let
dialogTemplate
=
dialogStack
.
firstElementChild
;
this
.
_tabDialogManager
=
new
SubDialogManager
(
{
dialogStack
dialogTemplate
orderType
:
SubDialogManager
.
ORDER_QUEUE
allowDuplicateDialogs
:
true
dialogOptions
:
{
consumeOutsideClicks
:
false
}
}
)
;
}
open
(
aURL
{
features
=
null
allowDuplicateDialogs
=
true
sizeTo
keepOpenSameOriginNav
modalType
=
null
allowFocusCheckbox
=
false
hideContent
=
false
}
=
{
}
.
.
.
aParams
)
{
let
resolveClosed
;
let
closedPromise
=
new
Promise
(
resolve
=
>
(
resolveClosed
=
resolve
)
)
;
let
dialogManager
=
modalType
=
=
=
Ci
.
nsIPrompt
.
MODAL_TYPE_CONTENT
?
this
.
getContentDialogManager
(
)
:
this
.
_tabDialogManager
;
let
hasDialogs
=
(
)
=
>
this
.
_tabDialogManager
.
hasDialogs
|
|
this
.
_contentDialogManager
?
.
hasDialogs
;
if
(
!
hasDialogs
(
)
)
{
this
.
_onFirstDialogOpen
(
)
;
}
let
closingCallback
=
event
=
>
{
if
(
!
hasDialogs
(
)
)
{
this
.
_onLastDialogClose
(
)
;
}
if
(
allowFocusCheckbox
&
&
!
event
.
detail
?
.
abort
)
{
this
.
maybeSetAllowTabSwitchPermission
(
event
.
target
)
;
}
}
;
if
(
modalType
=
=
Ci
.
nsIPrompt
.
MODAL_TYPE_CONTENT
)
{
sizeTo
=
"
limitheight
"
;
}
let
dialog
=
dialogManager
.
open
(
aURL
{
features
allowDuplicateDialogs
sizeTo
closingCallback
closedCallback
:
resolveClosed
hideContent
}
.
.
.
aParams
)
;
if
(
dialog
)
{
dialog
.
_keepOpenSameOriginNav
=
keepOpenSameOriginNav
;
}
return
{
closedPromise
dialog
}
;
}
_onFirstDialogOpen
(
)
{
this
.
browser
.
setAttribute
(
"
tabDialogShowing
"
true
)
;
UpdatePopupNotificationsVisibility
(
)
;
this
.
_lastPrincipal
=
this
.
browser
.
contentPrincipal
;
this
.
browser
.
addProgressListener
(
this
Ci
.
nsIWebProgress
.
NOTIFY_LOCATION
)
;
this
.
tab
?
.
addEventListener
(
"
TabClose
"
this
)
;
}
_onLastDialogClose
(
)
{
this
.
browser
.
removeAttribute
(
"
tabDialogShowing
"
)
;
UpdatePopupNotificationsVisibility
(
)
;
this
.
browser
.
removeProgressListener
(
this
)
;
this
.
_lastPrincipal
=
null
;
this
.
tab
?
.
removeEventListener
(
"
TabClose
"
this
)
;
}
_buildContentPromptDialog
(
)
{
let
template
=
document
.
getElementById
(
"
dialogStackTemplate
"
)
;
let
contentDialogStack
=
template
.
content
.
cloneNode
(
true
)
.
firstElementChild
;
contentDialogStack
.
classList
.
add
(
"
content
-
prompt
-
dialog
"
)
;
let
browserContainer
=
TabDialogBox
.
_containerFor
(
this
.
browser
)
;
let
tabPromptDialog
=
browserContainer
.
querySelector
(
"
.
tab
-
prompt
-
dialog
"
)
;
browserContainer
.
insertBefore
(
contentDialogStack
tabPromptDialog
)
;
let
contentDialogTemplate
=
contentDialogStack
.
firstElementChild
;
this
.
_contentDialogManager
=
new
SubDialogManager
(
{
dialogStack
:
contentDialogStack
dialogTemplate
:
contentDialogTemplate
orderType
:
SubDialogManager
.
ORDER_QUEUE
allowDuplicateDialogs
:
true
dialogOptions
:
{
consumeOutsideClicks
:
false
}
}
)
;
}
handleEvent
(
event
)
{
if
(
event
.
type
!
=
=
"
TabClose
"
)
{
return
;
}
this
.
abortAllDialogs
(
)
;
}
abortAllDialogs
(
)
{
this
.
_tabDialogManager
.
abortDialogs
(
)
;
this
.
_contentDialogManager
?
.
abortDialogs
(
)
;
}
focus
(
)
{
if
(
this
.
_tabDialogManager
.
_dialogs
.
length
)
{
this
.
_tabDialogManager
.
focusTopDialog
(
)
;
return
;
}
this
.
_contentDialogManager
?
.
focusTopDialog
(
)
;
}
onLocationChange
(
aWebProgress
aRequest
aLocation
aFlags
)
{
if
(
!
aWebProgress
.
isTopLevel
|
|
aFlags
&
Ci
.
nsIWebProgressListener
.
LOCATION_CHANGE_SAME_DOCUMENT
)
{
return
;
}
let
filterFn
;
if
(
this
.
_lastPrincipal
?
.
isSameOrigin
(
aLocation
this
.
browser
.
browsingContext
.
usePrivateBrowsing
)
)
{
filterFn
=
dialog
=
>
!
dialog
.
_keepOpenSameOriginNav
;
}
this
.
_lastPrincipal
=
this
.
browser
.
contentPrincipal
;
this
.
_tabDialogManager
.
abortDialogs
(
filterFn
)
;
this
.
_contentDialogManager
?
.
abortDialogs
(
filterFn
)
;
}
get
tab
(
)
{
return
gBrowser
.
getTabForBrowser
(
this
.
browser
)
;
}
get
browser
(
)
{
let
browser
=
this
.
_weakBrowserRef
.
get
(
)
;
if
(
!
browser
)
{
throw
new
Error
(
"
Stale
dialog
box
!
The
associated
browser
is
gone
.
"
)
;
}
return
browser
;
}
getTabDialogManager
(
)
{
return
this
.
_tabDialogManager
;
}
getContentDialogManager
(
)
{
if
(
!
this
.
_contentDialogManager
)
{
this
.
_buildContentPromptDialog
(
)
;
}
return
this
.
_contentDialogManager
;
}
onNextPromptShowAllowFocusCheckboxFor
(
principal
)
{
this
.
_allowTabFocusByPromptPrincipal
=
principal
;
}
maybeSetAllowTabSwitchPermission
(
dialog
)
{
let
checkbox
=
dialog
.
querySelector
(
"
checkbox
"
)
;
if
(
checkbox
.
checked
)
{
Services
.
perms
.
addFromPrincipal
(
this
.
_allowTabFocusByPromptPrincipal
"
focus
-
tab
-
by
-
prompt
"
Services
.
perms
.
ALLOW_ACTION
)
;
}
this
.
_allowTabFocusByPromptPrincipal
=
null
;
}
}
TabDialogBox
.
prototype
.
QueryInterface
=
ChromeUtils
.
generateQI
(
[
"
nsIWebProgressListener
"
"
nsISupportsWeakReference
"
]
)
;
var
gDialogBox
=
{
_dialog
:
null
_nextOpenJumpsQueue
:
false
_queued
:
[
]
_didCloseHTMLDialog
:
null
_didOpenHTMLDialog
:
false
get
dialog
(
)
{
return
this
.
_dialog
;
}
get
isOpen
(
)
{
return
!
!
this
.
_dialog
;
}
replaceDialogIfOpen
(
)
{
this
.
_dialog
?
.
close
(
)
;
this
.
_nextOpenJumpsQueue
=
true
;
}
async
open
(
uri
args
)
{
const
queueMethod
=
this
.
_nextOpenJumpsQueue
?
"
unshift
"
:
"
push
"
;
this
.
_nextOpenJumpsQueue
=
false
;
if
(
this
.
isOpen
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
this
.
_queued
[
queueMethod
]
(
{
resolve
reject
uri
args
}
)
;
}
)
;
}
if
(
window
.
windowUtils
.
isInModalState
(
)
&
&
!
args
.
getProperty
(
"
async
"
)
)
{
throw
Components
.
Exception
(
"
Prompt
could
not
be
shown
.
"
Cr
.
NS_ERROR_NOT_AVAILABLE
)
;
}
this
.
_didOpenHTMLDialog
=
false
;
let
haveClosedPromise
=
new
Promise
(
resolve
=
>
{
this
.
_didCloseHTMLDialog
=
resolve
;
}
)
;
window
.
focus
(
)
;
try
{
await
this
.
_open
(
uri
args
)
;
}
catch
(
ex
)
{
console
.
error
(
ex
)
;
}
finally
{
let
dialog
=
document
.
getElementById
(
"
window
-
modal
-
dialog
"
)
;
if
(
dialog
.
open
)
{
dialog
.
close
(
)
;
}
if
(
this
.
_didOpenHTMLDialog
)
{
await
haveClosedPromise
;
}
dialog
.
style
.
visibility
=
"
hidden
"
;
dialog
.
style
.
height
=
"
0
"
;
dialog
.
style
.
width
=
"
0
"
;
document
.
documentElement
.
removeAttribute
(
"
window
-
modal
-
open
"
)
;
dialog
.
removeEventListener
(
"
dialogopen
"
this
)
;
dialog
.
removeEventListener
(
"
close
"
this
)
;
this
.
_updateMenuAndCommandState
(
true
)
;
this
.
_dialog
=
null
;
UpdatePopupNotificationsVisibility
(
)
;
}
if
(
this
.
_queued
.
length
)
{
setTimeout
(
(
)
=
>
this
.
_openNextDialog
(
)
0
)
;
}
return
args
;
}
_openNextDialog
(
)
{
if
(
!
this
.
isOpen
)
{
let
{
resolve
reject
uri
args
}
=
this
.
_queued
.
shift
(
)
;
this
.
open
(
uri
args
)
.
then
(
resolve
reject
)
;
}
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
dialogopen
"
:
this
.
_dialog
.
focus
(
true
)
;
break
;
case
"
close
"
:
this
.
_didCloseHTMLDialog
(
)
;
this
.
_dialog
.
close
(
)
;
break
;
}
}
_open
(
uri
args
)
{
let
offset
=
window
.
windowUtils
.
getBoundsWithoutFlushing
(
gBrowser
.
selectedBrowser
)
.
top
;
let
parentElement
=
document
.
getElementById
(
"
window
-
modal
-
dialog
"
)
;
parentElement
.
style
.
setProperty
(
"
-
-
chrome
-
offset
"
offset
+
"
px
"
)
;
parentElement
.
style
.
removeProperty
(
"
visibility
"
)
;
parentElement
.
style
.
removeProperty
(
"
width
"
)
;
parentElement
.
style
.
removeProperty
(
"
height
"
)
;
document
.
documentElement
.
setAttribute
(
"
window
-
modal
-
open
"
true
)
;
parentElement
.
showModal
(
)
;
this
.
_didOpenHTMLDialog
=
true
;
this
.
_updateMenuAndCommandState
(
false
)
;
let
template
=
document
.
getElementById
(
"
window
-
modal
-
dialog
-
template
"
)
.
content
.
firstElementChild
;
parentElement
.
addEventListener
(
"
dialogopen
"
this
)
;
parentElement
.
addEventListener
(
"
close
"
this
)
;
this
.
_dialog
=
new
SubDialog
(
{
template
parentElement
id
:
"
window
-
modal
-
dialog
-
subdialog
"
options
:
{
consumeOutsideClicks
:
false
}
}
)
;
let
closedPromise
=
new
Promise
(
resolve
=
>
{
this
.
_closedCallback
=
function
(
)
{
PromptUtils
.
fireDialogEvent
(
window
"
DOMModalDialogClosed
"
)
;
resolve
(
)
;
}
;
}
)
;
this
.
_dialog
.
open
(
uri
{
features
:
"
resizable
=
no
"
modalType
:
Ci
.
nsIPrompt
.
MODAL_TYPE_INTERNAL_WINDOW
closedCallback
:
(
)
=
>
{
this
.
_closedCallback
(
)
;
}
}
args
)
;
UpdatePopupNotificationsVisibility
(
)
;
return
closedPromise
;
}
_nonUpdatableElements
:
new
Set
(
[
"
key_browserConsole
"
"
key_browserToolbox
"
"
key_undo
"
"
key_redo
"
"
key_cut
"
"
key_copy
"
"
key_paste
"
"
key_delete
"
"
key_selectAll
"
]
)
_updateMenuAndCommandState
(
shouldBeEnabled
)
{
let
editorCommands
=
document
.
getElementById
(
"
editMenuCommands
"
)
;
for
(
let
element
of
document
.
querySelectorAll
(
"
menubar
>
menu
command
key
:
not
(
[
command
]
)
"
)
)
{
if
(
editorCommands
?
.
contains
(
element
)
|
|
(
element
.
id
&
&
this
.
_nonUpdatableElements
.
has
(
element
.
id
)
)
)
{
continue
;
}
if
(
element
.
nodeName
=
=
"
key
"
&
&
element
.
command
)
{
continue
;
}
if
(
!
shouldBeEnabled
)
{
if
(
element
.
getAttribute
(
"
disabled
"
)
!
=
"
true
"
)
{
element
.
setAttribute
(
"
disabled
"
true
)
;
}
else
{
element
.
setAttribute
(
"
wasdisabled
"
true
)
;
}
}
else
if
(
element
.
getAttribute
(
"
wasdisabled
"
)
!
=
"
true
"
)
{
element
.
removeAttribute
(
"
disabled
"
)
;
}
else
{
element
.
removeAttribute
(
"
wasdisabled
"
)
;
}
}
}
}
;
if
(
window
.
location
.
href
!
=
AppConstants
.
BROWSER_CHROME_URL
)
{
gDialogBox
=
null
;
}
var
ConfirmationHint
=
{
_timerID
:
null
show
(
anchor
messageId
options
=
{
}
)
{
this
.
_reset
(
)
;
MozXULElement
.
insertFTLIfNeeded
(
"
toolkit
/
branding
/
brandings
.
ftl
"
)
;
MozXULElement
.
insertFTLIfNeeded
(
"
browser
/
confirmationHints
.
ftl
"
)
;
document
.
l10n
.
setAttributes
(
this
.
_message
messageId
options
.
l10nArgs
)
;
if
(
options
.
descriptionId
)
{
document
.
l10n
.
setAttributes
(
this
.
_description
options
.
descriptionId
)
;
this
.
_description
.
hidden
=
false
;
this
.
_panel
.
classList
.
add
(
"
with
-
description
"
)
;
}
else
{
this
.
_description
.
hidden
=
true
;
this
.
_panel
.
classList
.
remove
(
"
with
-
description
"
)
;
}
this
.
_panel
.
setAttribute
(
"
data
-
message
-
id
"
messageId
)
;
const
DURATION
=
options
.
showDescription
?
6000
:
3000
;
this
.
_panel
.
addEventListener
(
"
popupshown
"
(
)
=
>
{
this
.
_animationBox
.
setAttribute
(
"
animate
"
"
true
"
)
;
this
.
_timerID
=
setTimeout
(
(
)
=
>
{
this
.
_panel
.
hidePopup
(
true
)
;
}
DURATION
+
120
)
;
}
{
once
:
true
}
)
;
this
.
_panel
.
addEventListener
(
"
popuphidden
"
(
)
=
>
{
this
.
_reset
(
)
;
}
{
once
:
true
}
)
;
this
.
_panel
.
openPopup
(
anchor
{
position
:
options
.
position
?
?
"
bottomleft
topleft
"
triggerEvent
:
options
.
event
}
)
;
}
_reset
(
)
{
if
(
this
.
_timerID
)
{
clearTimeout
(
this
.
_timerID
)
;
this
.
_timerID
=
null
;
}
if
(
this
.
__panel
)
{
this
.
_animationBox
.
removeAttribute
(
"
animate
"
)
;
this
.
_panel
.
removeAttribute
(
"
data
-
message
-
id
"
)
;
}
}
get
_panel
(
)
{
this
.
_ensurePanel
(
)
;
return
this
.
__panel
;
}
get
_animationBox
(
)
{
this
.
_ensurePanel
(
)
;
delete
this
.
_animationBox
;
return
(
this
.
_animationBox
=
document
.
getElementById
(
"
confirmation
-
hint
-
checkmark
-
animation
-
container
"
)
)
;
}
get
_message
(
)
{
this
.
_ensurePanel
(
)
;
delete
this
.
_message
;
return
(
this
.
_message
=
document
.
getElementById
(
"
confirmation
-
hint
-
message
"
)
)
;
}
get
_description
(
)
{
this
.
_ensurePanel
(
)
;
delete
this
.
_description
;
return
(
this
.
_description
=
document
.
getElementById
(
"
confirmation
-
hint
-
description
"
)
)
;
}
_ensurePanel
(
)
{
if
(
!
this
.
__panel
)
{
let
wrapper
=
document
.
getElementById
(
"
confirmation
-
hint
-
wrapper
"
)
;
wrapper
.
replaceWith
(
wrapper
.
content
)
;
this
.
__panel
=
document
.
getElementById
(
"
confirmation
-
hint
"
)
;
}
}
}
;
var
FirefoxViewHandler
=
{
tab
:
null
BUTTON_ID
:
"
firefox
-
view
-
button
"
get
button
(
)
{
return
document
.
getElementById
(
this
.
BUTTON_ID
)
;
}
init
(
)
{
CustomizableUI
.
addListener
(
this
)
;
ChromeUtils
.
defineESModuleGetters
(
this
{
SyncedTabs
:
"
resource
:
/
/
services
-
sync
/
SyncedTabs
.
sys
.
mjs
"
}
)
;
}
uninit
(
)
{
CustomizableUI
.
removeListener
(
this
)
;
}
onWidgetRemoved
(
aWidgetId
)
{
if
(
aWidgetId
=
=
this
.
BUTTON_ID
&
&
this
.
tab
)
{
gBrowser
.
removeTab
(
this
.
tab
)
;
}
}
onWidgetAdded
(
aWidgetId
)
{
if
(
aWidgetId
=
=
=
this
.
BUTTON_ID
)
{
this
.
button
.
removeAttribute
(
"
open
"
)
;
}
}
openTab
(
section
)
{
if
(
!
CustomizableUI
.
getPlacementOfWidget
(
this
.
BUTTON_ID
)
)
{
CustomizableUI
.
addWidgetToArea
(
this
.
BUTTON_ID
CustomizableUI
.
AREA_TABSTRIP
CustomizableUI
.
getPlacementOfWidget
(
"
tabbrowser
-
tabs
"
)
.
position
)
;
}
let
viewURL
=
"
about
:
firefoxview
"
;
if
(
section
)
{
viewURL
=
{
viewURL
}
#
{
section
}
;
}
if
(
this
.
tab
&
&
this
.
tab
.
linkedBrowser
.
currentURI
.
spec
.
split
(
"
#
"
)
[
0
]
!
=
viewURL
)
{
gBrowser
.
removeTab
(
this
.
tab
)
;
this
.
tab
=
null
;
}
if
(
!
this
.
tab
)
{
this
.
tab
=
gBrowser
.
addTrustedTab
(
viewURL
)
;
this
.
tab
.
addEventListener
(
"
TabClose
"
this
{
once
:
true
}
)
;
gBrowser
.
tabContainer
.
addEventListener
(
"
TabSelect
"
this
)
;
window
.
addEventListener
(
"
activate
"
this
)
;
gBrowser
.
hideTab
(
this
.
tab
)
;
this
.
button
.
setAttribute
(
"
aria
-
controls
"
this
.
tab
.
linkedPanel
)
;
}
this
.
_closeDeviceConnectedTab
(
)
;
gBrowser
.
selectedTab
=
this
.
tab
;
}
openToolbarMouseEvent
(
event
section
)
{
if
(
event
?
.
type
=
=
"
mousedown
"
&
&
event
?
.
button
!
=
0
)
{
return
;
}
this
.
openTab
(
section
)
;
}
handleEvent
(
e
)
{
switch
(
e
.
type
)
{
case
"
TabSelect
"
:
{
const
selected
=
e
.
target
=
=
this
.
tab
;
this
.
button
?
.
toggleAttribute
(
"
open
"
selected
)
;
this
.
button
?
.
setAttribute
(
"
aria
-
pressed
"
selected
)
;
this
.
_recordViewIfTabSelected
(
)
;
this
.
_onTabForegrounded
(
)
;
gBrowser
.
visibleTabs
[
0
]
.
style
.
MozUserFocus
=
e
.
target
=
=
this
.
tab
?
"
normal
"
:
"
"
;
break
;
}
case
"
TabClose
"
:
this
.
tab
=
null
;
gBrowser
.
tabContainer
.
removeEventListener
(
"
TabSelect
"
this
)
;
this
.
button
?
.
removeAttribute
(
"
aria
-
controls
"
)
;
break
;
case
"
activate
"
:
this
.
_onTabForegrounded
(
)
;
break
;
}
}
_closeDeviceConnectedTab
(
)
{
if
(
!
TabsSetupFlowManager
.
didFxaTabOpen
)
{
return
;
}
const
fxaRoot
=
Services
.
prefs
.
getCharPref
(
"
identity
.
fxaccounts
.
remote
.
root
"
)
;
const
fxDeviceConnectedTab
=
gBrowser
.
tabs
.
find
(
tab
=
>
tab
.
linkedBrowser
.
currentURI
.
displaySpec
.
startsWith
(
{
fxaRoot
}
pair
/
auth
/
complete
)
)
;
if
(
!
fxDeviceConnectedTab
)
{
return
;
}
if
(
gBrowser
.
tabs
.
length
<
=
2
)
{
gBrowser
.
addTrustedTab
(
"
about
:
newtab
"
)
;
}
gBrowser
.
removeTab
(
fxDeviceConnectedTab
)
;
TabsSetupFlowManager
.
didFxaTabOpen
=
false
;
}
_onTabForegrounded
(
)
{
if
(
this
.
tab
?
.
selected
)
{
this
.
SyncedTabs
.
syncTabs
(
)
;
}
}
_recordViewIfTabSelected
(
)
{
if
(
this
.
tab
?
.
selected
)
{
const
PREF_NAME
=
"
browser
.
firefox
-
view
.
view
-
count
"
;
const
MAX_VIEW_COUNT
=
10
;
let
viewCount
=
Services
.
prefs
.
getIntPref
(
PREF_NAME
0
)
;
Services
.
telemetry
.
setEventRecordingEnabled
(
"
firefoxview_next
"
true
)
;
Services
.
telemetry
.
recordEvent
(
"
firefoxview_next
"
"
tab_selected
"
"
toolbarbutton
"
null
{
}
)
;
if
(
viewCount
<
MAX_VIEW_COUNT
)
{
Services
.
prefs
.
setIntPref
(
PREF_NAME
viewCount
+
1
)
;
}
}
}
}
;
