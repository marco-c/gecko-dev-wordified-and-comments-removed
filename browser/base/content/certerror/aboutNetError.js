import
"
chrome
:
/
/
global
/
content
/
certviewer
/
pvutils_bundle
.
jsm
"
;
import
"
chrome
:
/
/
global
/
content
/
certviewer
/
asn1js_bundle
.
jsm
"
;
import
"
chrome
:
/
/
global
/
content
/
certviewer
/
pkijs_bundle
.
jsm
"
;
import
"
chrome
:
/
/
global
/
content
/
certviewer
/
certDecoder
.
jsm
"
;
const
{
Integer
fromBER
}
=
globalThis
.
asn1js
.
asn1js
;
const
{
Certificate
}
=
globalThis
.
pkijs
.
pkijs
;
const
{
fromBase64
stringToArrayBuffer
}
=
globalThis
.
pvutils
.
pvutils
;
const
{
parse
pemToDER
}
=
globalThis
.
certDecoderInitializer
(
Integer
fromBER
Certificate
fromBase64
stringToArrayBuffer
crypto
)
;
const
formatter
=
new
Intl
.
DateTimeFormat
(
)
;
const
HOST_NAME
=
new
URL
(
RPMGetInnerMostURI
(
document
.
location
.
href
)
)
.
hostname
;
const
KNOWN_ERROR_TITLE_IDS
=
new
Set
(
[
"
connectionFailure
-
title
"
"
deniedPortAccess
-
title
"
"
dnsNotFound
-
title
"
"
fileNotFound
-
title
"
"
fileAccessDenied
-
title
"
"
generic
-
title
"
"
captivePortal
-
title
"
"
malformedURI
-
title
"
"
netInterrupt
-
title
"
"
notCached
-
title
"
"
netOffline
-
title
"
"
contentEncodingError
-
title
"
"
unsafeContentType
-
title
"
"
netReset
-
title
"
"
netTimeout
-
title
"
"
unknownProtocolFound
-
title
"
"
proxyConnectFailure
-
title
"
"
proxyResolveFailure
-
title
"
"
redirectLoop
-
title
"
"
unknownSocketType
-
title
"
"
nssFailure2
-
title
"
"
csp
-
xfo
-
error
-
title
"
"
corruptedContentError
-
title
"
"
sslv3Used
-
title
"
"
inadequateSecurityError
-
title
"
"
blockedByPolicy
-
title
"
"
clockSkewError
-
title
"
"
networkProtocolError
-
title
"
"
nssBadCert
-
title
"
"
nssBadCert
-
sts
-
title
"
"
certerror
-
mitm
-
title
"
]
)
;
let
searchParams
=
new
URLSearchParams
(
document
.
documentURI
.
split
(
"
?
"
)
[
1
]
)
;
let
gErrorCode
=
searchParams
.
get
(
"
e
"
)
;
let
gIsCertError
=
gErrorCode
=
=
"
nssBadCert
"
;
let
gHasSts
=
gIsCertError
&
&
getCSSClass
(
)
=
=
=
"
badStsCert
"
;
document
.
getElementById
(
"
favicon
"
)
.
href
=
gIsCertError
|
|
gErrorCode
=
=
"
nssFailure2
"
?
"
chrome
:
/
/
global
/
skin
/
icons
/
warning
.
svg
"
:
"
chrome
:
/
/
global
/
skin
/
icons
/
info
.
svg
"
;
function
getCSSClass
(
)
{
return
searchParams
.
get
(
"
s
"
)
;
}
function
getDescription
(
)
{
return
searchParams
.
get
(
"
d
"
)
;
}
function
isCaptive
(
)
{
return
searchParams
.
get
(
"
captive
"
)
=
=
"
true
"
;
}
function
getMitmName
(
failedCertInfo
)
{
return
failedCertInfo
.
issuerCommonName
;
}
function
retryThis
(
buttonEl
)
{
RPMSendAsyncMessage
(
"
Browser
:
EnableOnlineMode
"
)
;
buttonEl
.
disabled
=
true
;
}
function
showPrefChangeContainer
(
)
{
const
panel
=
document
.
getElementById
(
"
prefChangeContainer
"
)
;
panel
.
style
.
display
=
"
block
"
;
document
.
getElementById
(
"
netErrorButtonContainer
"
)
.
style
.
display
=
"
none
"
;
document
.
getElementById
(
"
prefResetButton
"
)
.
addEventListener
(
"
click
"
function
resetPreferences
(
)
{
RPMSendAsyncMessage
(
"
Browser
:
ResetSSLPreferences
"
)
;
}
)
;
setFocus
(
"
#
prefResetButton
"
"
beforeend
"
)
;
}
function
toggleCertErrorDebugInfoVisibility
(
shouldShow
)
{
let
debugInfo
=
document
.
getElementById
(
"
certificateErrorDebugInformation
"
)
;
let
copyButton
=
document
.
getElementById
(
"
copyToClipboardTop
"
)
;
if
(
shouldShow
=
=
=
undefined
)
{
shouldShow
=
debugInfo
.
hidden
;
}
debugInfo
.
hidden
=
!
shouldShow
;
if
(
shouldShow
)
{
copyButton
.
scrollIntoView
(
{
block
:
"
start
"
behavior
:
"
smooth
"
}
)
;
copyButton
.
focus
(
)
;
}
}
function
setupAdvancedButton
(
)
{
var
panel
=
document
.
getElementById
(
"
badCertAdvancedPanel
"
)
;
document
.
getElementById
(
"
advancedButton
"
)
.
addEventListener
(
"
click
"
togglePanelVisibility
)
;
function
togglePanelVisibility
(
)
{
panel
.
hidden
=
!
panel
.
hidden
;
toggleCertErrorDebugInfoVisibility
(
false
)
;
if
(
panel
.
style
.
display
=
=
"
block
"
)
{
var
event
=
new
CustomEvent
(
"
AboutNetErrorUIExpanded
"
{
bubbles
:
true
}
)
;
document
.
dispatchEvent
(
event
)
;
}
}
if
(
getCSSClass
(
)
=
=
"
expertBadCert
"
)
{
panel
.
hidden
=
false
;
}
}
function
disallowCertOverridesIfNeeded
(
)
{
if
(
gHasSts
|
|
window
!
=
top
)
{
document
.
getElementById
(
"
exceptionDialogButton
"
)
.
hidden
=
true
;
}
if
(
gHasSts
)
{
const
stsExplanation
=
document
.
getElementById
(
"
badStsCertExplanation
"
)
;
document
.
l10n
.
setAttributes
(
stsExplanation
"
certerror
-
what
-
should
-
i
-
do
-
bad
-
sts
-
cert
-
explanation
"
{
hostname
:
HOST_NAME
}
)
;
stsExplanation
.
removeAttribute
(
"
hidden
"
)
;
document
.
l10n
.
setAttributes
(
document
.
getElementById
(
"
returnButton
"
)
"
neterror
-
return
-
to
-
previous
-
page
-
button
"
)
;
document
.
l10n
.
setAttributes
(
document
.
getElementById
(
"
advancedPanelReturnButton
"
)
"
neterror
-
return
-
to
-
previous
-
page
-
button
"
)
;
}
}
function
initPage
(
)
{
let
baseURL
=
RPMGetFormatURLPref
(
"
app
.
support
.
baseURL
"
)
;
let
location
=
document
.
location
.
href
;
if
(
location
.
startsWith
(
baseURL
)
)
{
let
supportPageSlug
=
document
.
location
.
pathname
.
split
(
"
/
"
)
.
pop
(
)
;
RPMSendAsyncMessage
(
"
DisplayOfflineSupportPage
"
{
supportPageSlug
}
)
;
}
const
className
=
getCSSClass
(
)
;
if
(
className
)
{
document
.
body
.
classList
.
add
(
className
)
;
}
const
docTitle
=
document
.
querySelector
(
"
title
"
)
;
const
bodyTitle
=
document
.
querySelector
(
"
.
title
-
text
"
)
;
const
shortDesc
=
document
.
getElementById
(
"
errorShortDescText
"
)
;
if
(
gIsCertError
)
{
const
isStsError
=
window
!
=
=
window
.
top
|
|
gHasSts
;
const
errArgs
=
{
hostname
:
HOST_NAME
}
;
if
(
isCaptive
(
)
)
{
document
.
l10n
.
setAttributes
(
docTitle
"
neterror
-
captive
-
portal
-
page
-
title
"
)
;
document
.
l10n
.
setAttributes
(
bodyTitle
"
captivePortal
-
title
"
)
;
document
.
l10n
.
setAttributes
(
shortDesc
"
neterror
-
captive
-
portal
"
errArgs
)
;
initPageCaptivePortal
(
)
;
}
else
{
if
(
isStsError
)
{
document
.
l10n
.
setAttributes
(
docTitle
"
certerror
-
sts
-
page
-
title
"
)
;
document
.
l10n
.
setAttributes
(
bodyTitle
"
nssBadCert
-
sts
-
title
"
)
;
document
.
l10n
.
setAttributes
(
shortDesc
"
certerror
-
sts
-
intro
"
errArgs
)
;
}
else
{
document
.
l10n
.
setAttributes
(
docTitle
"
certerror
-
page
-
title
"
)
;
document
.
l10n
.
setAttributes
(
bodyTitle
"
nssBadCert
-
title
"
)
;
document
.
l10n
.
setAttributes
(
shortDesc
"
certerror
-
intro
"
errArgs
)
;
}
initPageCertError
(
)
;
}
initCertErrorPageActions
(
)
;
setTechnicalDetailsOnCertError
(
)
;
return
;
}
document
.
body
.
classList
.
add
(
"
neterror
"
)
;
let
longDesc
=
document
.
getElementById
(
"
errorLongDesc
"
)
;
const
netErrorButton
=
document
.
getElementById
(
"
netErrorButtonContainer
"
)
;
const
learnMore
=
document
.
getElementById
(
"
learnMoreContainer
"
)
;
const
learnMoreLink
=
document
.
getElementById
(
"
learnMoreLink
"
)
;
learnMoreLink
.
setAttribute
(
"
href
"
baseURL
+
"
connection
-
not
-
secure
"
)
;
let
pageTitleId
=
"
neterror
-
page
-
title
"
;
let
bodyTitleId
=
gErrorCode
+
"
-
title
"
;
switch
(
gErrorCode
)
{
case
"
blockedByPolicy
"
:
pageTitleId
=
"
neterror
-
blocked
-
by
-
policy
-
page
-
title
"
;
document
.
body
.
classList
.
add
(
"
blocked
"
)
;
netErrorButton
.
style
.
display
=
"
none
"
;
break
;
case
"
cspBlocked
"
:
case
"
xfoBlocked
"
:
{
bodyTitleId
=
"
csp
-
xfo
-
error
-
title
"
;
netErrorButton
.
style
.
display
=
"
none
"
;
document
.
getElementById
(
"
errorShortDesc
"
)
.
style
.
display
=
"
none
"
;
document
.
l10n
.
setAttributes
(
longDesc
"
csp
-
xfo
-
blocked
-
long
-
desc
"
{
hostname
:
document
.
location
.
hostname
}
)
;
longDesc
=
null
;
document
.
getElementById
(
"
openInNewWindowContainer
"
)
.
style
.
display
=
"
block
"
;
const
openInNewWindowButton
=
document
.
getElementById
(
"
openInNewWindowButton
"
)
;
openInNewWindowButton
.
href
=
document
.
location
.
href
;
learnMore
.
style
.
display
=
"
block
"
;
learnMoreLink
.
setAttribute
(
"
href
"
baseURL
+
"
xframe
-
neterror
-
page
"
)
;
setupBlockingReportingUI
(
)
;
break
;
}
case
"
dnsNotFound
"
:
pageTitleId
=
"
neterror
-
dns
-
not
-
found
-
title
"
;
RPMCheckAlternateHostAvailable
(
)
;
break
;
case
"
inadequateSecurityError
"
:
netErrorButton
.
style
.
display
=
"
none
"
;
break
;
case
"
malformedURI
"
:
pageTitleId
=
"
neterror
-
malformed
-
uri
-
page
-
title
"
;
break
;
case
"
nssFailure2
"
:
{
learnMore
.
style
.
display
=
"
block
"
;
const
errorCode
=
document
.
getNetErrorInfo
(
)
.
errorCodeString
;
switch
(
errorCode
)
{
case
"
SSL_ERROR_UNSUPPORTED_VERSION
"
:
case
"
SSL_ERROR_PROTOCOL_VERSION_ALERT
"
:
{
const
tlsNotice
=
document
.
getElementById
(
"
tlsVersionNotice
"
)
;
tlsNotice
.
hidden
=
false
;
document
.
l10n
.
setAttributes
(
tlsNotice
"
cert
-
error
-
old
-
tls
-
version
"
)
;
}
case
"
interrupted
"
:
case
"
SSL_ERROR_NO_CIPHERS_SUPPORTED
"
:
case
"
SSL_ERROR_NO_CYPHER_OVERLAP
"
:
case
"
SSL_ERROR_SSL_DISABLED
"
:
RPMAddMessageListener
(
"
HasChangedCertPrefs
"
msg
=
>
{
if
(
msg
.
data
.
hasChangedCertPrefs
)
{
showPrefChangeContainer
(
)
;
}
}
)
;
RPMSendAsyncMessage
(
"
GetChangedCertPrefs
"
)
;
}
break
;
}
case
"
sslv3Used
"
:
learnMore
.
style
.
display
=
"
block
"
;
document
.
body
.
className
=
"
certerror
"
;
document
.
getElementById
(
"
advancedButton
"
)
.
style
.
display
=
"
none
"
;
break
;
}
document
.
l10n
.
setAttributes
(
docTitle
pageTitleId
)
;
if
(
!
KNOWN_ERROR_TITLE_IDS
.
has
(
bodyTitleId
)
)
{
console
.
error
(
"
No
strings
exist
for
error
:
"
bodyTitleId
)
;
bodyTitleId
=
"
generic
-
title
"
;
}
document
.
l10n
.
setAttributes
(
bodyTitle
bodyTitleId
)
;
shortDesc
.
textContent
=
getDescription
(
)
;
setFocus
(
"
#
netErrorButtonContainer
>
.
try
-
again
"
)
;
if
(
longDesc
)
{
const
parts
=
getNetErrorDescParts
(
)
;
setNetErrorMessageFromParts
(
longDesc
parts
)
;
}
setNetErrorMessageFromCode
(
)
;
}
function
setNetErrorMessageFromParts
(
parent
parts
)
{
let
list
=
null
;
for
(
let
[
tag
l10nId
l10nArgs
]
of
parts
)
{
const
elem
=
document
.
createElement
(
tag
)
;
elem
.
dataset
.
l10nId
=
l10nId
;
if
(
l10nArgs
)
{
elem
.
dataset
.
l10nArgs
=
JSON
.
stringify
(
l10nArgs
)
;
}
if
(
tag
=
=
=
"
li
"
)
{
if
(
!
list
)
{
list
=
document
.
createElement
(
"
ul
"
)
;
parent
.
appendChild
(
list
)
;
}
list
.
appendChild
(
elem
)
;
}
else
{
if
(
list
)
{
list
=
null
;
}
parent
.
appendChild
(
elem
)
;
}
}
}
function
getNetErrorDescParts
(
)
{
switch
(
gErrorCode
)
{
case
"
connectionFailure
"
:
case
"
netInterrupt
"
:
case
"
netReset
"
:
case
"
netTimeout
"
:
return
[
[
"
li
"
"
neterror
-
load
-
error
-
try
-
again
"
]
[
"
li
"
"
neterror
-
load
-
error
-
connection
"
]
[
"
li
"
"
neterror
-
load
-
error
-
firewall
"
]
]
;
case
"
blockedByPolicy
"
:
case
"
deniedPortAccess
"
:
case
"
malformedURI
"
:
return
[
]
;
case
"
captivePortal
"
:
return
[
[
"
p
"
"
"
]
]
;
case
"
contentEncodingError
"
:
return
[
[
"
li
"
"
neterror
-
content
-
encoding
-
error
"
]
]
;
case
"
corruptedContentErrorv2
"
:
return
[
[
"
p
"
"
neterror
-
corrupted
-
content
-
intro
"
]
[
"
li
"
"
neterror
-
corrupted
-
content
-
contact
-
website
"
]
]
;
case
"
dnsNotFound
"
:
return
[
[
"
span
"
"
neterror
-
dns
-
not
-
found
-
hint
-
header
"
]
[
"
li
"
"
neterror
-
dns
-
not
-
found
-
hint
-
try
-
again
"
]
[
"
li
"
"
neterror
-
dns
-
not
-
found
-
hint
-
check
-
network
"
]
[
"
li
"
"
neterror
-
dns
-
not
-
found
-
hint
-
firewall
"
]
]
;
case
"
fileAccessDenied
"
:
return
[
[
"
li
"
"
neterror
-
access
-
denied
"
]
]
;
case
"
fileNotFound
"
:
return
[
[
"
li
"
"
neterror
-
file
-
not
-
found
-
filename
"
]
[
"
li
"
"
neterror
-
file
-
not
-
found
-
moved
"
]
]
;
case
"
inadequateSecurityError
"
:
return
[
[
"
p
"
"
neterror
-
inadequate
-
security
-
intro
"
{
hostname
:
HOST_NAME
}
]
[
"
p
"
"
neterror
-
inadequate
-
security
-
code
"
]
]
;
case
"
mitm
"
:
{
const
failedCertInfo
=
document
.
getFailedCertSecurityInfo
(
)
;
const
errArgs
=
{
hostname
:
HOST_NAME
mitm
:
getMitmName
(
failedCertInfo
)
}
;
return
[
[
"
span
"
"
certerror
-
mitm
"
errArgs
]
]
;
}
case
"
netOffline
"
:
return
[
[
"
li
"
"
neterror
-
net
-
offline
"
]
]
;
case
"
networkProtocolError
"
:
return
[
[
"
p
"
"
neterror
-
network
-
protocol
-
error
-
intro
"
]
[
"
li
"
"
neterror
-
network
-
protocol
-
error
-
contact
-
website
"
]
]
;
case
"
notCached
"
:
return
[
[
"
p
"
"
neterror
-
not
-
cached
-
intro
"
]
[
"
li
"
"
neterror
-
not
-
cached
-
sensitive
"
]
[
"
li
"
"
neterror
-
not
-
cached
-
try
-
again
"
]
]
;
case
"
nssFailure2
"
:
return
[
[
"
li
"
"
neterror
-
nss
-
failure
-
not
-
verified
"
]
[
"
li
"
"
neterror
-
nss
-
failure
-
contact
-
website
"
]
]
;
case
"
proxyConnectFailure
"
:
return
[
[
"
li
"
"
neterror
-
proxy
-
connect
-
failure
-
settings
"
]
[
"
li
"
"
neterror
-
proxy
-
connect
-
failure
-
contact
-
admin
"
]
]
;
case
"
proxyResolveFailure
"
:
return
[
[
"
li
"
"
neterror
-
proxy
-
resolve
-
failure
-
settings
"
]
[
"
li
"
"
neterror
-
proxy
-
resolve
-
failure
-
connection
"
]
[
"
li
"
"
neterror
-
proxy
-
resolve
-
failure
-
firewall
"
]
]
;
case
"
redirectLoop
"
:
return
[
[
"
li
"
"
neterror
-
redirect
-
loop
"
]
]
;
case
"
sslv3Used
"
:
return
[
[
"
span
"
"
neterror
-
sslv3
-
used
"
]
]
;
case
"
unknownProtocolFound
"
:
return
[
[
"
li
"
"
neterror
-
unknown
-
protocol
"
]
]
;
case
"
unknownSocketType
"
:
return
[
[
"
li
"
"
neterror
-
unknown
-
socket
-
type
-
psm
-
installed
"
]
[
"
li
"
"
neterror
-
unknown
-
socket
-
type
-
server
-
config
"
]
]
;
case
"
unsafeContentType
"
:
return
[
[
"
li
"
"
neterror
-
unsafe
-
content
-
type
"
]
]
;
default
:
return
[
[
"
p
"
"
neterror
-
generic
-
error
"
]
]
;
}
}
function
setupBlockingReportingUI
(
)
{
let
checkbox
=
document
.
getElementById
(
"
automaticallyReportBlockingInFuture
"
)
;
let
reportingAutomatic
=
RPMGetBoolPref
(
"
security
.
xfocsp
.
errorReporting
.
automatic
"
)
;
checkbox
.
checked
=
!
!
reportingAutomatic
;
checkbox
.
addEventListener
(
"
change
"
function
(
{
target
:
{
checked
}
}
)
{
RPMSetBoolPref
(
"
security
.
xfocsp
.
errorReporting
.
automatic
"
checked
)
;
if
(
checked
)
{
reportBlockingError
(
)
;
}
}
)
;
let
reportingEnabled
=
RPMGetBoolPref
(
"
security
.
xfocsp
.
errorReporting
.
enabled
"
)
;
if
(
reportingEnabled
)
{
document
.
getElementById
(
"
blockingErrorReporting
"
)
.
hidden
=
false
;
if
(
reportingAutomatic
)
{
reportBlockingError
(
)
;
}
}
}
function
reportBlockingError
(
)
{
if
(
window
=
=
=
window
.
top
)
{
return
;
}
let
err
=
gErrorCode
;
if
(
!
[
"
xfoBlocked
"
"
cspBlocked
"
]
.
includes
(
err
)
)
{
return
;
}
let
xfo_header
=
RPMGetHttpResponseHeader
(
"
X
-
Frame
-
Options
"
)
;
let
csp_header
=
RPMGetHttpResponseHeader
(
"
Content
-
Security
-
Policy
"
)
;
let
reg
=
/
(
?
:
^
|
\
s
)
frame
-
ancestors
\
s
(
[
^
;
]
*
)
[
]
*
/
i
;
let
match
=
reg
.
exec
(
csp_header
)
;
csp_header
=
match
?
match
[
1
]
:
"
"
;
if
(
err
=
=
=
"
cspBlocked
"
&
&
!
csp_header
)
{
return
;
}
let
xfoAndCspInfo
=
{
error_type
:
err
=
=
=
"
xfoBlocked
"
?
"
xfo
"
:
"
csp
"
xfo_header
csp_header
}
;
let
scheme
=
document
.
location
.
protocol
.
slice
(
0
-
1
)
;
RPMSendAsyncMessage
(
"
ReportBlockingError
"
{
scheme
host
:
document
.
location
.
host
port
:
parseInt
(
document
.
location
.
port
)
|
|
-
1
path
:
document
.
location
.
pathname
xfoAndCspInfo
}
)
;
}
async
function
setNetErrorMessageFromCode
(
)
{
let
hostname
=
HOST_NAME
;
let
port
=
document
.
location
.
port
;
if
(
port
&
&
port
!
=
443
)
{
hostname
+
=
"
:
"
+
port
;
}
let
securityInfo
;
try
{
securityInfo
=
document
.
getNetErrorInfo
(
)
;
}
catch
(
ex
)
{
return
;
}
const
errorCodeStr
=
securityInfo
.
errorCodeString
|
|
"
"
;
const
errorCodeStrId
=
errorCodeStr
.
split
(
"
_
"
)
.
join
(
"
-
"
)
.
toLowerCase
(
)
;
let
errorMessage
=
"
"
;
if
(
KNOWN_ERROR_MESSAGE_IDS
.
has
(
errorCodeStrId
)
)
{
errorMessage
=
await
document
.
l10n
.
formatValue
(
errorCodeStrId
)
;
}
const
shortDesc
=
document
.
getElementById
(
"
errorShortDescText
"
)
;
if
(
errorMessage
)
{
document
.
l10n
.
setAttributes
(
shortDesc
"
ssl
-
connection
-
error
"
{
errorMessage
hostname
}
)
;
const
shortDesc2
=
document
.
getElementById
(
"
errorShortDescText2
"
)
;
document
.
l10n
.
setAttributes
(
shortDesc2
"
cert
-
error
-
code
-
prefix
"
{
error
:
errorCodeStr
}
)
;
}
else
{
console
.
warn
(
"
This
error
page
has
no
error
code
in
its
security
info
"
)
;
document
.
l10n
.
setAttributes
(
shortDesc
"
ssl
-
connection
-
error
"
{
errorMessage
:
errorCodeStr
hostname
}
)
;
}
}
function
initPageCaptivePortal
(
)
{
document
.
body
.
className
=
"
captiveportal
"
;
document
.
getElementById
(
"
openPortalLoginPageButton
"
)
.
addEventListener
(
"
click
"
(
)
=
>
{
RPMSendAsyncMessage
(
"
Browser
:
OpenCaptivePortalPage
"
)
;
}
)
;
setFocus
(
"
#
openPortalLoginPageButton
"
)
;
setupAdvancedButton
(
)
;
disallowCertOverridesIfNeeded
(
)
;
RPMAddMessageListener
(
"
AboutNetErrorCaptivePortalFreed
"
(
)
=
>
{
document
.
location
.
reload
(
)
;
}
)
;
}
function
initPageCertError
(
)
{
document
.
body
.
classList
.
add
(
"
certerror
"
)
;
setFocus
(
"
#
returnButton
"
)
;
setupAdvancedButton
(
)
;
disallowCertOverridesIfNeeded
(
)
;
const
hideAddExceptionButton
=
RPMGetBoolPref
(
"
security
.
certerror
.
hideAddException
"
false
)
;
if
(
hideAddExceptionButton
)
{
document
.
querySelector
(
"
.
exceptionDialogButtonContainer
"
)
.
hidden
=
true
;
}
const
els
=
document
.
querySelectorAll
(
"
[
data
-
telemetry
-
id
]
"
)
;
for
(
let
el
of
els
)
{
el
.
addEventListener
(
"
click
"
recordClickTelemetry
)
;
}
const
failedCertInfo
=
document
.
getFailedCertSecurityInfo
(
)
;
const
errorCode
=
failedCertInfo
.
errorCodeString
.
substring
(
0
40
)
;
RPMRecordTelemetryEvent
(
"
security
.
ui
.
certerror
"
"
load
"
"
aboutcerterror
"
errorCode
{
has_sts
:
gHasSts
.
toString
(
)
is_frame
:
(
window
.
parent
!
=
window
)
.
toString
(
)
}
)
;
setCertErrorDetails
(
)
;
}
function
recordClickTelemetry
(
e
)
{
let
target
=
e
.
originalTarget
;
let
telemetryId
=
target
.
dataset
.
telemetryId
;
let
failedCertInfo
=
document
.
getFailedCertSecurityInfo
(
)
;
let
errorCode
=
failedCertInfo
.
errorCodeString
.
substring
(
0
40
)
;
RPMRecordTelemetryEvent
(
"
security
.
ui
.
certerror
"
"
click
"
telemetryId
errorCode
{
has_sts
:
gHasSts
.
toString
(
)
is_frame
:
(
window
.
parent
!
=
window
)
.
toString
(
)
}
)
;
}
function
initCertErrorPageActions
(
)
{
document
.
getElementById
(
"
returnButton
"
)
.
addEventListener
(
"
click
"
onReturnButtonClick
)
;
document
.
getElementById
(
"
advancedPanelReturnButton
"
)
.
addEventListener
(
"
click
"
onReturnButtonClick
)
;
document
.
getElementById
(
"
copyToClipboardTop
"
)
.
addEventListener
(
"
click
"
copyPEMToClipboard
)
;
document
.
getElementById
(
"
copyToClipboardBottom
"
)
.
addEventListener
(
"
click
"
copyPEMToClipboard
)
;
document
.
getElementById
(
"
exceptionDialogButton
"
)
.
addEventListener
(
"
click
"
addCertException
)
;
}
function
addCertException
(
)
{
const
isPermanent
=
!
RPMIsWindowPrivate
(
)
&
&
RPMGetBoolPref
(
"
security
.
certerrors
.
permanentOverride
"
)
;
document
.
addCertException
(
!
isPermanent
)
.
then
(
(
)
=
>
{
location
.
reload
(
)
;
}
err
=
>
{
}
)
;
}
function
onReturnButtonClick
(
e
)
{
RPMSendAsyncMessage
(
"
Browser
:
SSLErrorGoBack
"
)
;
}
async
function
copyPEMToClipboard
(
e
)
{
let
details
=
await
getFailedCertificatesAsPEMString
(
)
;
navigator
.
clipboard
.
writeText
(
details
)
;
}
async
function
getFailedCertificatesAsPEMString
(
)
{
let
location
=
document
.
location
.
href
;
let
failedCertInfo
=
document
.
getFailedCertSecurityInfo
(
)
;
let
errorMessage
=
failedCertInfo
.
errorMessage
;
let
hasHSTS
=
failedCertInfo
.
hasHSTS
.
toString
(
)
;
let
hasHPKP
=
failedCertInfo
.
hasHPKP
.
toString
(
)
;
let
[
hstsLabel
hpkpLabel
failedChainLabel
]
=
await
document
.
l10n
.
formatValues
(
[
{
id
:
"
cert
-
error
-
details
-
hsts
-
label
"
args
:
{
hasHSTS
}
}
{
id
:
"
cert
-
error
-
details
-
key
-
pinning
-
label
"
args
:
{
hasHPKP
}
}
{
id
:
"
cert
-
error
-
details
-
cert
-
chain
-
label
"
}
]
)
;
let
certStrings
=
failedCertInfo
.
certChainStrings
;
let
failedChainCertificates
=
"
"
;
for
(
let
der64
of
certStrings
)
{
let
wrapped
=
der64
.
replace
(
/
(
\
S
{
64
}
(
?
!
)
)
/
g
"
1
\
r
\
n
"
)
;
failedChainCertificates
+
=
"
-
-
-
-
-
BEGIN
CERTIFICATE
-
-
-
-
-
\
r
\
n
"
+
wrapped
+
"
\
r
\
n
-
-
-
-
-
END
CERTIFICATE
-
-
-
-
-
\
r
\
n
"
;
}
let
details
=
location
+
"
\
r
\
n
\
r
\
n
"
+
errorMessage
+
"
\
r
\
n
\
r
\
n
"
+
hstsLabel
+
"
\
r
\
n
"
+
hpkpLabel
+
"
\
r
\
n
\
r
\
n
"
+
failedChainLabel
+
"
\
r
\
n
\
r
\
n
"
+
failedChainCertificates
;
return
details
;
}
function
setCertErrorDetails
(
)
{
const
failedCertInfo
=
document
.
getFailedCertSecurityInfo
(
)
;
const
mitmPrimingEnabled
=
RPMGetBoolPref
(
"
security
.
certerrors
.
mitm
.
priming
.
enabled
"
)
;
if
(
mitmPrimingEnabled
&
&
failedCertInfo
.
errorCodeString
=
=
"
SEC_ERROR_UNKNOWN_ISSUER
"
&
&
window
.
parent
=
=
window
)
{
RPMSendAsyncMessage
(
"
Browser
:
PrimeMitm
"
)
;
}
document
.
body
.
setAttribute
(
"
code
"
failedCertInfo
.
errorCodeString
)
;
document
.
getElementById
(
"
learnMoreContainer
"
)
.
style
.
display
=
"
block
"
;
const
learnMoreLink
=
document
.
getElementById
(
"
learnMoreLink
"
)
;
const
baseURL
=
RPMGetFormatURLPref
(
"
app
.
support
.
baseURL
"
)
;
learnMoreLink
.
href
=
baseURL
+
"
connection
-
not
-
secure
"
;
const
bodyTitle
=
document
.
querySelector
(
"
.
title
-
text
"
)
;
const
shortDesc
=
document
.
getElementById
(
"
errorShortDescText
"
)
;
const
shortDesc2
=
document
.
getElementById
(
"
errorShortDescText2
"
)
;
const
whatToDo
=
document
.
getElementById
(
"
errorWhatToDoText
"
)
;
const
whatToDoTitle
=
document
.
getElementById
(
"
errorWhatToDoTitleText
"
)
;
let
whatToDoParts
=
null
;
switch
(
failedCertInfo
.
errorCodeString
)
{
case
"
SSL_ERROR_BAD_CERT_DOMAIN
"
:
whatToDoParts
=
[
[
"
p
"
"
certerror
-
bad
-
cert
-
domain
-
what
-
can
-
you
-
do
-
about
-
it
"
]
]
;
break
;
case
"
SEC_ERROR_OCSP_INVALID_SIGNING_CERT
"
:
break
;
case
"
SEC_ERROR_UNKNOWN_ISSUER
"
:
whatToDoParts
=
[
[
"
p
"
"
certerror
-
unknown
-
issuer
-
what
-
can
-
you
-
do
-
about
-
it
-
website
"
]
[
"
p
"
"
certerror
-
unknown
-
issuer
-
what
-
can
-
you
-
do
-
about
-
it
-
contact
-
admin
"
]
]
;
break
;
case
"
MOZILLA_PKIX_ERROR_ADDITIONAL_POLICY_CONSTRAINT_FAILED
"
:
{
document
.
l10n
.
setAttributes
(
shortDesc2
"
cert
-
error
-
symantec
-
distrust
-
description
"
{
hostname
:
HOST_NAME
}
)
;
const
adminDesc
=
document
.
createElement
(
"
p
"
)
;
document
.
l10n
.
setAttributes
(
adminDesc
"
cert
-
error
-
symantec
-
distrust
-
admin
"
)
;
learnMoreLink
.
href
=
baseURL
+
"
symantec
-
warning
"
;
break
;
}
case
"
MOZILLA_PKIX_ERROR_MITM_DETECTED
"
:
{
const
autoEnabledEnterpriseRoots
=
RPMGetBoolPref
(
"
security
.
enterprise_roots
.
auto
-
enabled
"
false
)
;
if
(
mitmPrimingEnabled
&
&
autoEnabledEnterpriseRoots
)
{
RPMSendAsyncMessage
(
"
Browser
:
ResetEnterpriseRootsPref
"
)
;
}
learnMoreLink
.
href
=
baseURL
+
"
security
-
error
"
;
document
.
l10n
.
setAttributes
(
bodyTitle
"
certerror
-
mitm
-
title
"
)
;
document
.
l10n
.
setAttributes
(
shortDesc
"
certerror
-
mitm
"
{
hostname
:
HOST_NAME
mitm
:
getMitmName
(
failedCertInfo
)
}
)
;
const
id3
=
gHasSts
?
"
certerror
-
mitm
-
what
-
can
-
you
-
do
-
about
-
it
-
attack
-
sts
"
:
"
certerror
-
mitm
-
what
-
can
-
you
-
do
-
about
-
it
-
attack
"
;
whatToDoParts
=
[
[
"
li
"
"
certerror
-
mitm
-
what
-
can
-
you
-
do
-
about
-
it
-
antivirus
"
]
[
"
li
"
"
certerror
-
mitm
-
what
-
can
-
you
-
do
-
about
-
it
-
corporate
"
]
[
"
li
"
id3
{
mitm
:
getMitmName
(
failedCertInfo
)
}
]
]
;
break
;
}
case
"
MOZILLA_PKIX_ERROR_SELF_SIGNED_CERT
"
:
learnMoreLink
.
href
=
baseURL
+
"
security
-
error
"
;
break
;
case
"
SEC_ERROR_EXPIRED_CERTIFICATE
"
:
case
"
SEC_ERROR_EXPIRED_ISSUER_CERTIFICATE
"
:
case
"
MOZILLA_PKIX_ERROR_NOT_YET_VALID_CERTIFICATE
"
:
case
"
MOZILLA_PKIX_ERROR_NOT_YET_VALID_ISSUER_CERTIFICATE
"
:
{
learnMoreLink
.
href
=
baseURL
+
"
time
-
errors
"
;
const
difference
=
RPMGetIntPref
(
"
services
.
settings
.
clock_skew_seconds
"
0
)
;
const
lastFetched
=
RPMGetIntPref
(
"
services
.
settings
.
last_update_seconds
"
0
)
*
1000
;
let
clockSkew
=
false
;
const
now
=
Date
.
now
(
)
;
const
certRange
=
{
notBefore
:
failedCertInfo
.
certValidityRangeNotBefore
notAfter
:
failedCertInfo
.
certValidityRangeNotAfter
}
;
const
approximateDate
=
now
-
difference
*
1000
;
if
(
Math
.
abs
(
difference
)
>
60
*
60
*
24
&
&
now
-
lastFetched
<
=
60
*
60
*
24
*
5
*
1000
&
&
certRange
.
notBefore
<
approximateDate
&
&
certRange
.
notAfter
>
approximateDate
)
{
clockSkew
=
true
;
}
else
{
const
appBuildID
=
RPMGetAppBuildID
(
)
;
const
year
=
parseInt
(
appBuildID
.
substr
(
0
4
)
10
)
;
const
month
=
parseInt
(
appBuildID
.
substr
(
4
2
)
10
)
-
1
;
const
day
=
parseInt
(
appBuildID
.
substr
(
6
2
)
10
)
;
const
buildDate
=
new
Date
(
year
month
day
)
;
if
(
buildDate
>
now
&
&
new
Date
(
certRange
.
notAfter
)
>
buildDate
)
{
clockSkew
=
true
;
}
}
if
(
clockSkew
)
{
document
.
body
.
classList
.
add
(
"
clockSkewError
"
)
;
document
.
l10n
.
setAttributes
(
bodyTitle
"
clockSkewError
-
title
"
)
;
document
.
l10n
.
setAttributes
(
shortDesc
"
neterror
-
clock
-
skew
-
error
"
{
hostname
:
HOST_NAME
now
}
)
;
break
;
}
document
.
l10n
.
setAttributes
(
shortDesc
"
certerror
-
expired
-
cert
-
intro
"
{
hostname
:
HOST_NAME
}
)
;
if
(
failedCertInfo
.
errorCodeString
=
=
"
SEC_ERROR_EXPIRED_CERTIFICATE
"
)
{
const
sd2Id
=
gHasSts
?
"
certerror
-
expired
-
cert
-
sts
-
second
-
para
"
:
"
certerror
-
expired
-
cert
-
second
-
para
"
;
document
.
l10n
.
setAttributes
(
shortDesc2
sd2Id
)
;
if
(
Math
.
abs
(
difference
)
<
=
60
*
60
*
24
&
&
now
-
lastFetched
<
=
60
*
60
*
24
*
5
*
1000
)
{
whatToDoParts
=
[
[
"
p
"
"
certerror
-
bad
-
cert
-
domain
-
what
-
can
-
you
-
do
-
about
-
it
"
]
]
;
}
}
whatToDoTitle
.
className
=
"
bold
"
;
whatToDoParts
?
?
=
[
[
"
p
"
"
certerror
-
expired
-
cert
-
what
-
can
-
you
-
do
-
about
-
it
-
clock
"
{
hostname
:
HOST_NAME
now
}
]
[
"
p
"
"
certerror
-
expired
-
cert
-
what
-
can
-
you
-
do
-
about
-
it
-
contact
-
website
"
]
]
;
break
;
}
}
if
(
whatToDoParts
)
{
document
.
l10n
.
setAttributes
(
whatToDoTitle
"
certerror
-
what
-
can
-
you
-
do
-
about
-
it
-
title
"
)
;
setNetErrorMessageFromParts
(
whatToDo
whatToDoParts
)
;
}
}
async
function
setTechnicalDetailsOnCertError
(
failedCertInfo
=
document
.
getFailedCertSecurityInfo
(
)
)
{
let
technicalInfo
=
document
.
getElementById
(
"
badCertTechnicalInfo
"
)
;
function
setL10NLabel
(
l10nId
args
=
{
}
attrs
=
{
}
rewrite
=
true
)
{
let
elem
=
document
.
createElement
(
"
label
"
)
;
if
(
rewrite
)
{
technicalInfo
.
textContent
=
"
"
;
}
technicalInfo
.
appendChild
(
elem
)
;
let
newLines
=
document
.
createTextNode
(
"
\
n
\
n
"
)
;
technicalInfo
.
appendChild
(
newLines
)
;
if
(
attrs
)
{
let
link
=
document
.
createElement
(
"
a
"
)
;
for
(
let
attr
of
Object
.
keys
(
attrs
)
)
{
link
.
setAttribute
(
attr
attrs
[
attr
]
)
;
}
elem
.
appendChild
(
link
)
;
}
if
(
args
)
{
document
.
l10n
.
setAttributes
(
elem
l10nId
args
)
;
}
else
{
document
.
l10n
.
setAttributes
(
elem
l10nId
)
;
}
}
let
cssClass
=
getCSSClass
(
)
;
let
error
=
gErrorCode
;
let
hostString
=
HOST_NAME
;
let
port
=
document
.
location
.
port
;
if
(
port
&
&
port
!
=
443
)
{
hostString
+
=
"
:
"
+
port
;
}
let
l10nId
;
let
args
=
{
hostname
:
hostString
}
;
if
(
failedCertInfo
.
overridableErrorCategory
=
=
"
trust
-
error
"
)
{
switch
(
failedCertInfo
.
errorCodeString
)
{
case
"
MOZILLA_PKIX_ERROR_MITM_DETECTED
"
:
setL10NLabel
(
"
cert
-
error
-
mitm
-
intro
"
)
;
setL10NLabel
(
"
cert
-
error
-
mitm
-
mozilla
"
{
}
{
}
false
)
;
setL10NLabel
(
"
cert
-
error
-
mitm
-
connection
"
{
}
{
}
false
)
;
break
;
case
"
SEC_ERROR_UNKNOWN_ISSUER
"
:
setL10NLabel
(
"
cert
-
error
-
trust
-
unknown
-
issuer
-
intro
"
)
;
setL10NLabel
(
"
cert
-
error
-
trust
-
unknown
-
issuer
"
args
{
}
false
)
;
break
;
case
"
SEC_ERROR_CA_CERT_INVALID
"
:
setL10NLabel
(
"
cert
-
error
-
intro
"
args
)
;
setL10NLabel
(
"
cert
-
error
-
trust
-
cert
-
invalid
"
{
}
{
}
false
)
;
break
;
case
"
SEC_ERROR_UNTRUSTED_ISSUER
"
:
setL10NLabel
(
"
cert
-
error
-
intro
"
args
)
;
setL10NLabel
(
"
cert
-
error
-
trust
-
untrusted
-
issuer
"
{
}
{
}
false
)
;
break
;
case
"
SEC_ERROR_CERT_SIGNATURE_ALGORITHM_DISABLED
"
:
setL10NLabel
(
"
cert
-
error
-
intro
"
args
)
;
setL10NLabel
(
"
cert
-
error
-
trust
-
signature
-
algorithm
-
disabled
"
{
}
{
}
false
)
;
break
;
case
"
SEC_ERROR_EXPIRED_ISSUER_CERTIFICATE
"
:
setL10NLabel
(
"
cert
-
error
-
intro
"
args
)
;
setL10NLabel
(
"
cert
-
error
-
trust
-
expired
-
issuer
"
{
}
{
}
false
)
;
break
;
case
"
MOZILLA_PKIX_ERROR_SELF_SIGNED_CERT
"
:
setL10NLabel
(
"
cert
-
error
-
intro
"
args
)
;
setL10NLabel
(
"
cert
-
error
-
trust
-
self
-
signed
"
{
}
{
}
false
)
;
break
;
case
"
MOZILLA_PKIX_ERROR_ADDITIONAL_POLICY_CONSTRAINT_FAILED
"
:
setL10NLabel
(
"
cert
-
error
-
intro
"
args
)
;
setL10NLabel
(
"
cert
-
error
-
trust
-
symantec
"
{
}
{
}
false
)
;
break
;
default
:
setL10NLabel
(
"
cert
-
error
-
intro
"
args
)
;
setL10NLabel
(
"
cert
-
error
-
untrusted
-
default
"
{
}
{
}
false
)
;
}
}
else
if
(
failedCertInfo
.
overridableErrorCategory
=
=
"
domain
-
mismatch
"
)
{
let
serverCertBase64
=
failedCertInfo
.
certChainStrings
[
0
]
;
let
parsed
=
await
parse
(
pemToDER
(
serverCertBase64
)
)
;
let
subjectAltNamesExtension
=
parsed
.
ext
.
san
;
let
subjectAltNames
=
[
]
;
if
(
subjectAltNamesExtension
)
{
for
(
let
name
of
subjectAltNamesExtension
.
altNames
)
{
if
(
name
[
0
]
=
=
"
DNS
Name
"
&
&
name
[
1
]
.
length
)
{
subjectAltNames
.
push
(
name
[
1
]
)
;
}
}
}
let
numSubjectAltNames
=
subjectAltNames
.
length
;
if
(
numSubjectAltNames
!
=
0
)
{
if
(
numSubjectAltNames
=
=
1
)
{
args
[
"
alt
-
name
"
]
=
subjectAltNames
[
0
]
;
let
okHost
=
subjectAltNames
[
0
]
;
let
href
=
"
"
;
let
thisHost
=
HOST_NAME
;
let
proto
=
document
.
location
.
protocol
+
"
/
/
"
;
okHost
=
okHost
.
replace
(
/
^
\
*
\
.
/
"
www
.
"
)
;
if
(
okHost
.
endsWith
(
"
.
"
+
thisHost
)
)
{
href
=
proto
+
okHost
;
}
if
(
thisHost
.
endsWith
(
"
.
"
+
okHost
)
)
{
href
=
proto
+
okHost
;
}
if
(
href
&
&
cssClass
!
=
"
expertBadCert
"
)
{
document
.
getElementById
(
"
badCertAdvancedPanel
"
)
.
style
.
display
=
"
block
"
;
if
(
error
=
=
"
nssBadCert
"
)
{
toggleCertErrorDebugInfoVisibility
(
false
)
;
}
}
if
(
href
)
{
setL10NLabel
(
"
cert
-
error
-
domain
-
mismatch
-
single
"
args
{
href
"
data
-
l10n
-
name
"
:
"
domain
-
mismatch
-
link
"
id
:
"
cert_domain_link
"
}
)
;
}
else
{
setL10NLabel
(
"
cert
-
error
-
domain
-
mismatch
-
single
-
nolink
"
args
)
;
}
}
else
{
let
names
=
subjectAltNames
.
join
(
"
"
)
;
args
[
"
subject
-
alt
-
names
"
]
=
names
;
setL10NLabel
(
"
cert
-
error
-
domain
-
mismatch
-
multiple
"
args
)
;
}
}
else
{
setL10NLabel
(
"
cert
-
error
-
domain
-
mismatch
"
{
hostname
:
hostString
}
)
;
}
}
else
if
(
failedCertInfo
.
overridableErrorCategory
=
=
"
expired
-
or
-
not
-
yet
-
valid
"
)
{
let
notBefore
=
failedCertInfo
.
validNotBefore
;
let
notAfter
=
failedCertInfo
.
validNotAfter
;
args
=
{
hostname
:
hostString
}
;
if
(
notBefore
&
&
Date
.
now
(
)
<
notAfter
)
{
let
notBeforeLocalTime
=
formatter
.
format
(
new
Date
(
notBefore
)
)
;
l10nId
=
"
cert
-
error
-
not
-
yet
-
valid
-
now
"
;
args
[
"
not
-
before
-
local
-
time
"
]
=
notBeforeLocalTime
;
}
else
{
let
notAfterLocalTime
=
formatter
.
format
(
new
Date
(
notAfter
)
)
;
l10nId
=
"
cert
-
error
-
expired
-
now
"
;
args
[
"
not
-
after
-
local
-
time
"
]
=
notAfterLocalTime
;
}
setL10NLabel
(
l10nId
args
)
;
}
setL10NLabel
(
"
cert
-
error
-
code
-
prefix
-
link
"
{
error
:
failedCertInfo
.
errorCodeString
}
{
title
:
failedCertInfo
.
errorCodeString
id
:
"
errorCode
"
"
data
-
l10n
-
name
"
:
"
error
-
code
-
link
"
"
data
-
telemetry
-
id
"
:
"
error_code_link
"
href
:
"
#
certificateErrorDebugInformation
"
}
false
)
;
let
errorCodeLink
=
document
.
getElementById
(
"
errorCode
"
)
;
if
(
errorCodeLink
)
{
technicalInfo
.
addEventListener
(
"
click
"
handleErrorCodeClick
)
;
}
let
div
=
document
.
getElementById
(
"
certificateErrorText
"
)
;
div
.
textContent
=
await
getFailedCertificatesAsPEMString
(
)
;
}
function
handleErrorCodeClick
(
event
)
{
if
(
event
.
target
.
id
!
=
=
"
errorCode
"
)
{
return
;
}
event
.
preventDefault
(
)
;
toggleCertErrorDebugInfoVisibility
(
)
;
recordClickTelemetry
(
event
)
;
}
function
setFocus
(
selector
position
=
"
afterbegin
"
)
{
if
(
window
.
top
=
=
window
)
{
var
button
=
document
.
querySelector
(
selector
)
;
var
parent
=
button
.
parentNode
;
parent
.
insertAdjacentElement
(
position
button
)
;
requestAnimationFrame
(
(
)
=
>
{
button
.
focus
(
{
focusVisible
:
false
}
)
;
}
)
;
}
}
for
(
let
button
of
document
.
querySelectorAll
(
"
.
try
-
again
"
)
)
{
button
.
addEventListener
(
"
click
"
function
(
)
{
retryThis
(
this
)
;
}
)
;
}
window
.
addEventListener
(
"
DOMContentLoaded
"
(
)
=
>
{
window
.
setTechnicalDetailsOnCertError
=
setTechnicalDetailsOnCertError
;
initPage
(
)
;
let
event
=
new
CustomEvent
(
"
AboutNetErrorLoad
"
{
bubbles
:
true
}
)
;
document
.
dispatchEvent
(
event
)
;
}
)
;
