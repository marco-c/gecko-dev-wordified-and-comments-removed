import
"
chrome
:
/
/
global
/
content
/
certviewer
/
pvutils_bundle
.
jsm
"
;
import
"
chrome
:
/
/
global
/
content
/
certviewer
/
asn1js_bundle
.
jsm
"
;
import
"
chrome
:
/
/
global
/
content
/
certviewer
/
pkijs_bundle
.
jsm
"
;
import
"
chrome
:
/
/
global
/
content
/
certviewer
/
certDecoder
.
jsm
"
;
const
{
Integer
fromBER
}
=
globalThis
.
asn1js
.
asn1js
;
const
{
Certificate
}
=
globalThis
.
pkijs
.
pkijs
;
const
{
fromBase64
stringToArrayBuffer
}
=
globalThis
.
pvutils
.
pvutils
;
const
{
parse
pemToDER
}
=
globalThis
.
certDecoderInitializer
(
Integer
fromBER
Certificate
fromBase64
stringToArrayBuffer
crypto
)
;
const
formatter
=
new
Intl
.
DateTimeFormat
(
"
default
"
)
;
const
HOST_NAME
=
new
URL
(
RPMGetInnerMostURI
(
document
.
location
.
href
)
)
.
hostname
;
const
KNOWN_ERROR_TITLE_IDS
=
new
Set
(
[
"
connectionFailure
-
title
"
"
deniedPortAccess
-
title
"
"
dnsNotFound
-
title
"
"
fileNotFound
-
title
"
"
fileAccessDenied
-
title
"
"
generic
-
title
"
"
captivePortal
-
title
"
"
malformedURI
-
title
"
"
netInterrupt
-
title
"
"
notCached
-
title
"
"
netOffline
-
title
"
"
contentEncodingError
-
title
"
"
unsafeContentType
-
title
"
"
netReset
-
title
"
"
netTimeout
-
title
"
"
unknownProtocolFound
-
title
"
"
proxyConnectFailure
-
title
"
"
proxyResolveFailure
-
title
"
"
redirectLoop
-
title
"
"
unknownSocketType
-
title
"
"
nssFailure2
-
title
"
"
csp
-
xfo
-
error
-
title
"
"
corruptedContentError
-
title
"
"
sslv3Used
-
title
"
"
inadequateSecurityError
-
title
"
"
blockedByPolicy
-
title
"
"
clockSkewError
-
title
"
"
networkProtocolError
-
title
"
"
nssBadCert
-
title
"
"
nssBadCert
-
sts
-
title
"
"
certerror
-
mitm
-
title
"
]
)
;
let
searchParams
=
new
URLSearchParams
(
document
.
documentURI
.
split
(
"
?
"
)
[
1
]
)
;
let
gErrorCode
=
searchParams
.
get
(
"
e
"
)
;
let
gIsCertError
=
gErrorCode
=
=
"
nssBadCert
"
;
document
.
getElementById
(
"
favicon
"
)
.
href
=
gIsCertError
|
|
gErrorCode
=
=
"
nssFailure2
"
?
"
chrome
:
/
/
global
/
skin
/
icons
/
warning
.
svg
"
:
"
chrome
:
/
/
global
/
skin
/
icons
/
info
.
svg
"
;
function
getCSSClass
(
)
{
return
searchParams
.
get
(
"
s
"
)
;
}
function
getDescription
(
)
{
return
searchParams
.
get
(
"
d
"
)
;
}
function
isCaptive
(
)
{
return
searchParams
.
get
(
"
captive
"
)
=
=
"
true
"
;
}
function
retryThis
(
buttonEl
)
{
RPMSendAsyncMessage
(
"
Browser
:
EnableOnlineMode
"
)
;
buttonEl
.
disabled
=
true
;
}
function
showBlockingErrorReporting
(
)
{
document
.
getElementById
(
"
blockingErrorReporting
"
)
.
hidden
=
false
;
}
function
showPrefChangeContainer
(
)
{
const
panel
=
document
.
getElementById
(
"
prefChangeContainer
"
)
;
panel
.
style
.
display
=
"
block
"
;
document
.
getElementById
(
"
netErrorButtonContainer
"
)
.
style
.
display
=
"
none
"
;
document
.
getElementById
(
"
prefResetButton
"
)
.
addEventListener
(
"
click
"
function
resetPreferences
(
)
{
RPMSendAsyncMessage
(
"
Browser
:
ResetSSLPreferences
"
)
;
}
)
;
setFocus
(
"
#
prefResetButton
"
"
beforeend
"
)
;
}
function
toggleCertErrorDebugInfoVisibility
(
shouldShow
)
{
let
debugInfo
=
document
.
getElementById
(
"
certificateErrorDebugInformation
"
)
;
let
copyButton
=
document
.
getElementById
(
"
copyToClipboardTop
"
)
;
if
(
shouldShow
=
=
=
undefined
)
{
shouldShow
=
debugInfo
.
hidden
;
}
debugInfo
.
hidden
=
!
shouldShow
;
if
(
shouldShow
)
{
copyButton
.
scrollIntoView
(
{
block
:
"
start
"
behavior
:
"
smooth
"
}
)
;
copyButton
.
focus
(
)
;
}
}
function
setupAdvancedButton
(
)
{
var
panel
=
document
.
getElementById
(
"
badCertAdvancedPanel
"
)
;
for
(
var
span
of
panel
.
querySelectorAll
(
"
span
.
hostname
"
)
)
{
span
.
textContent
=
HOST_NAME
;
}
document
.
getElementById
(
"
advancedButton
"
)
.
addEventListener
(
"
click
"
togglePanelVisibility
)
;
function
togglePanelVisibility
(
)
{
panel
.
hidden
=
!
panel
.
hidden
;
if
(
gIsCertError
)
{
toggleCertErrorDebugInfoVisibility
(
false
)
;
}
if
(
panel
.
style
.
display
=
=
"
block
"
)
{
var
event
=
new
CustomEvent
(
"
AboutNetErrorUIExpanded
"
{
bubbles
:
true
}
)
;
document
.
dispatchEvent
(
event
)
;
}
}
if
(
!
gIsCertError
)
{
return
;
}
if
(
getCSSClass
(
)
=
=
"
expertBadCert
"
)
{
panel
.
hidden
=
false
;
}
disallowCertOverridesIfNeeded
(
)
;
}
function
disallowCertOverridesIfNeeded
(
)
{
var
cssClass
=
getCSSClass
(
)
;
if
(
cssClass
=
=
"
badStsCert
"
|
|
window
!
=
top
)
{
document
.
getElementById
(
"
exceptionDialogButton
"
)
.
hidden
=
true
;
}
if
(
cssClass
=
=
"
badStsCert
"
)
{
document
.
getElementById
(
"
badStsCertExplanation
"
)
.
removeAttribute
(
"
hidden
"
)
;
let
stsReturnButtonText
=
document
.
getElementById
(
"
stsReturnButtonText
"
)
.
textContent
;
document
.
getElementById
(
"
returnButton
"
)
.
textContent
=
stsReturnButtonText
;
document
.
getElementById
(
"
advancedPanelReturnButton
"
)
.
textContent
=
stsReturnButtonText
;
let
stsMitmWhatCanYouDoAboutIt3
=
document
.
getElementById
(
"
stsMitmWhatCanYouDoAboutIt3
"
)
.
innerHTML
;
document
.
getElementById
(
"
mitmWhatCanYouDoAboutIt3
"
)
.
innerHTML
=
stsMitmWhatCanYouDoAboutIt3
;
}
}
function
setErrorPageStrings
(
err
)
{
let
title
=
err
+
"
-
title
"
;
let
isCertError
=
err
=
=
"
nssBadCert
"
;
let
className
=
getCSSClass
(
)
;
if
(
isCertError
&
&
(
window
!
=
=
window
.
top
|
|
className
=
=
"
badStsCert
"
)
)
{
title
=
err
+
"
-
sts
-
title
"
;
}
let
cspXfoError
=
err
=
=
=
"
cspBlocked
"
|
|
err
=
=
=
"
xfoBlocked
"
;
if
(
cspXfoError
)
{
title
=
"
csp
-
xfo
-
error
-
title
"
;
}
let
titleElement
=
document
.
querySelector
(
"
.
title
-
text
"
)
;
if
(
!
KNOWN_ERROR_TITLE_IDS
.
has
(
title
)
)
{
console
.
error
(
"
No
strings
exist
for
error
:
"
title
)
;
title
=
"
generic
-
title
"
;
}
document
.
l10n
.
setAttributes
(
titleElement
title
)
;
}
function
initPage
(
)
{
let
baseURL
=
RPMGetFormatURLPref
(
"
app
.
support
.
baseURL
"
)
;
let
location
=
document
.
location
.
href
;
if
(
location
.
startsWith
(
baseURL
)
)
{
let
supportPageSlug
=
document
.
location
.
pathname
.
split
(
"
/
"
)
.
pop
(
)
;
RPMSendAsyncMessage
(
"
DisplayOfflineSupportPage
"
{
supportPageSlug
}
)
;
}
var
err
=
gErrorCode
;
if
(
err
=
=
"
blockedByPolicy
"
)
{
document
.
body
.
classList
.
add
(
"
blocked
"
)
;
}
let
showCaptivePortalUI
=
isCaptive
(
)
&
&
gIsCertError
;
if
(
showCaptivePortalUI
)
{
err
=
"
captivePortal
"
;
}
let
l10nErrId
=
err
;
let
className
=
getCSSClass
(
)
;
if
(
className
)
{
document
.
body
.
classList
.
add
(
className
)
;
}
if
(
gIsCertError
&
&
(
window
!
=
=
window
.
top
|
|
className
=
=
"
badStsCert
"
)
)
{
l10nErrId
+
=
"
_sts
"
;
}
let
pageTitle
=
document
.
getElementById
(
"
ept_
"
+
l10nErrId
)
;
if
(
pageTitle
)
{
document
.
title
=
pageTitle
.
textContent
;
}
var
errDesc
=
document
.
getElementById
(
"
ed_
"
+
l10nErrId
)
;
if
(
!
errDesc
)
{
errDesc
=
document
.
getElementById
(
"
ed_generic
"
)
;
}
setErrorPageStrings
(
err
)
;
var
sd
=
document
.
getElementById
(
"
errorShortDescText
"
)
;
if
(
sd
)
{
if
(
gIsCertError
)
{
sd
.
innerHTML
=
errDesc
.
innerHTML
;
}
else
{
sd
.
textContent
=
getDescription
(
)
;
}
}
if
(
gIsCertError
)
{
if
(
showCaptivePortalUI
)
{
initPageCaptivePortal
(
)
;
}
else
{
initPageCertError
(
)
;
}
initCertErrorPageActions
(
)
;
setTechnicalDetailsOnCertError
(
)
;
return
;
}
setFocus
(
"
#
netErrorButtonContainer
>
.
try
-
again
"
)
;
document
.
body
.
classList
.
add
(
"
neterror
"
)
;
var
ld
=
document
.
getElementById
(
"
errorLongDesc
"
)
;
if
(
ld
)
{
ld
.
innerHTML
=
errDesc
.
innerHTML
;
}
if
(
err
=
=
"
dnsNotFound
"
)
{
RPMCheckAlternateHostAvailable
(
)
;
}
if
(
err
=
=
"
sslv3Used
"
)
{
document
.
getElementById
(
"
learnMoreContainer
"
)
.
style
.
display
=
"
block
"
;
document
.
body
.
className
=
"
certerror
"
;
}
var
errContainer
=
document
.
getElementById
(
"
errorContainer
"
)
;
errContainer
.
remove
(
)
;
let
learnMoreLink
=
document
.
getElementById
(
"
learnMoreLink
"
)
;
learnMoreLink
.
setAttribute
(
"
href
"
baseURL
+
"
connection
-
not
-
secure
"
)
;
if
(
err
=
=
"
cspBlocked
"
|
|
err
=
=
"
xfoBlocked
"
)
{
document
.
getElementById
(
"
netErrorButtonContainer
"
)
.
style
.
display
=
"
none
"
;
document
.
getElementById
(
"
errorShortDesc
"
)
.
style
.
display
=
"
none
"
;
let
hostString
=
document
.
location
.
hostname
;
let
longDescription
=
document
.
getElementById
(
"
errorLongDesc
"
)
;
document
.
l10n
.
setAttributes
(
longDescription
"
csp
-
xfo
-
blocked
-
long
-
desc
"
{
hostname
:
hostString
}
)
;
document
.
getElementById
(
"
openInNewWindowContainer
"
)
.
style
.
display
=
"
block
"
;
let
openInNewWindowButton
=
document
.
getElementById
(
"
openInNewWindowButton
"
)
;
openInNewWindowButton
.
href
=
document
.
location
.
href
;
document
.
getElementById
(
"
learnMoreContainer
"
)
.
style
.
display
=
"
block
"
;
learnMoreLink
.
setAttribute
(
"
href
"
baseURL
+
"
xframe
-
neterror
-
page
"
)
;
setupBlockingReportingUI
(
)
;
}
setNetErrorMessageFromCode
(
)
;
if
(
err
=
=
"
nssFailure2
"
)
{
document
.
getElementById
(
"
learnMoreContainer
"
)
.
style
.
display
=
"
block
"
;
const
errorCode
=
document
.
getNetErrorInfo
(
)
.
errorCodeString
;
if
(
errorCode
=
=
"
SSL_ERROR_UNSUPPORTED_VERSION
"
|
|
errorCode
=
=
"
SSL_ERROR_PROTOCOL_VERSION_ALERT
"
)
{
document
.
getElementById
(
"
tlsVersionNotice
"
)
.
hidden
=
false
;
}
const
hasPrefStyleError
=
[
"
interrupted
"
"
SSL_ERROR_NO_CIPHERS_SUPPORTED
"
"
SSL_ERROR_NO_CYPHER_OVERLAP
"
"
SSL_ERROR_PROTOCOL_VERSION_ALERT
"
"
SSL_ERROR_SSL_DISABLED
"
"
SSL_ERROR_UNSUPPORTED_VERSION
"
]
.
some
(
substring
=
>
{
return
substring
=
=
errorCode
;
}
)
;
if
(
hasPrefStyleError
)
{
RPMAddMessageListener
(
"
HasChangedCertPrefs
"
msg
=
>
{
if
(
msg
.
data
.
hasChangedCertPrefs
)
{
showPrefChangeContainer
(
)
;
}
}
)
;
RPMSendAsyncMessage
(
"
GetChangedCertPrefs
"
)
;
}
}
if
(
err
=
=
"
sslv3Used
"
)
{
document
.
getElementById
(
"
advancedButton
"
)
.
style
.
display
=
"
none
"
;
}
if
(
err
=
=
"
inadequateSecurityError
"
|
|
err
=
=
"
blockedByPolicy
"
)
{
document
.
getElementById
(
"
netErrorButtonContainer
"
)
.
style
.
display
=
"
none
"
;
var
container
=
document
.
getElementById
(
"
errorLongDesc
"
)
;
for
(
var
span
of
container
.
querySelectorAll
(
"
span
.
hostname
"
)
)
{
span
.
textContent
=
HOST_NAME
;
}
}
}
function
setupBlockingReportingUI
(
)
{
let
checkbox
=
document
.
getElementById
(
"
automaticallyReportBlockingInFuture
"
)
;
let
reportingAutomatic
=
RPMGetBoolPref
(
"
security
.
xfocsp
.
errorReporting
.
automatic
"
)
;
checkbox
.
checked
=
!
!
reportingAutomatic
;
checkbox
.
addEventListener
(
"
change
"
function
(
{
target
:
{
checked
}
}
)
{
onSetBlockingReportAutomatic
(
checked
)
;
}
)
;
let
reportingEnabled
=
RPMGetBoolPref
(
"
security
.
xfocsp
.
errorReporting
.
enabled
"
)
;
if
(
!
reportingEnabled
)
{
return
;
}
showBlockingErrorReporting
(
)
;
if
(
reportingAutomatic
)
{
reportBlockingError
(
)
;
}
}
function
reportBlockingError
(
)
{
if
(
window
=
=
=
window
.
top
)
{
return
;
}
let
err
=
gErrorCode
;
if
(
!
[
"
xfoBlocked
"
"
cspBlocked
"
]
.
includes
(
err
)
)
{
return
;
}
let
xfo_header
=
RPMGetHttpResponseHeader
(
"
X
-
Frame
-
Options
"
)
;
let
csp_header
=
RPMGetHttpResponseHeader
(
"
Content
-
Security
-
Policy
"
)
;
let
reg
=
/
(
?
:
^
|
\
s
)
frame
-
ancestors
\
s
(
[
^
;
]
*
)
[
]
*
/
i
;
let
match
=
reg
.
exec
(
csp_header
)
;
csp_header
=
match
?
match
[
1
]
:
"
"
;
if
(
err
=
=
=
"
cspBlocked
"
&
&
!
csp_header
)
{
return
;
}
let
xfoAndCspInfo
=
{
error_type
:
err
=
=
=
"
xfoBlocked
"
?
"
xfo
"
:
"
csp
"
xfo_header
csp_header
}
;
let
scheme
=
document
.
location
.
protocol
.
slice
(
0
-
1
)
;
RPMSendAsyncMessage
(
"
ReportBlockingError
"
{
scheme
host
:
document
.
location
.
host
port
:
parseInt
(
document
.
location
.
port
)
|
|
-
1
path
:
document
.
location
.
pathname
xfoAndCspInfo
}
)
;
}
function
onSetBlockingReportAutomatic
(
checked
)
{
RPMSetBoolPref
(
"
security
.
xfocsp
.
errorReporting
.
automatic
"
checked
)
;
if
(
checked
)
{
reportBlockingError
(
)
;
}
}
async
function
setNetErrorMessageFromCode
(
)
{
let
hostString
=
HOST_NAME
;
let
port
=
document
.
location
.
port
;
if
(
port
&
&
port
!
=
443
)
{
hostString
+
=
"
:
"
+
port
;
}
let
securityInfo
;
try
{
securityInfo
=
document
.
getNetErrorInfo
(
)
;
}
catch
(
ex
)
{
return
;
}
let
desc
=
document
.
getElementById
(
"
errorShortDescText
"
)
;
let
errorCodeStr
=
securityInfo
.
errorCodeString
|
|
"
"
;
let
errorCodeStrId
=
errorCodeStr
.
split
(
"
_
"
)
.
join
(
"
-
"
)
.
toLowerCase
(
)
;
let
errorCodeMsg
=
"
"
;
if
(
KNOWN_ERROR_MESSAGE_IDS
.
has
(
errorCodeStrId
)
)
{
[
errorCodeMsg
]
=
await
document
.
l10n
.
formatValues
(
[
errorCodeStrId
]
)
;
}
if
(
!
errorCodeMsg
)
{
console
.
warn
(
"
This
error
page
has
no
error
code
in
its
security
info
"
)
;
document
.
l10n
.
setAttributes
(
desc
"
ssl
-
connection
-
error
"
{
errorMessage
:
errorCodeStr
hostname
:
hostString
}
)
;
return
;
}
document
.
l10n
.
setAttributes
(
desc
"
ssl
-
connection
-
error
"
{
errorMessage
:
errorCodeMsg
hostname
:
hostString
}
)
;
let
desc2
=
document
.
getElementById
(
"
errorShortDescText2
"
)
;
document
.
l10n
.
setAttributes
(
desc2
"
cert
-
error
-
code
-
prefix
"
{
error
:
errorCodeStr
}
)
;
}
function
initPageCaptivePortal
(
)
{
document
.
body
.
className
=
"
captiveportal
"
;
document
.
getElementById
(
"
openPortalLoginPageButton
"
)
.
addEventListener
(
"
click
"
(
)
=
>
{
RPMSendAsyncMessage
(
"
Browser
:
OpenCaptivePortalPage
"
)
;
}
)
;
setFocus
(
"
#
openPortalLoginPageButton
"
)
;
setupAdvancedButton
(
)
;
RPMAddMessageListener
(
"
AboutNetErrorCaptivePortalFreed
"
(
)
=
>
{
document
.
location
.
reload
(
)
;
}
)
;
}
function
initPageCertError
(
)
{
document
.
body
.
classList
.
add
(
"
certerror
"
)
;
for
(
let
host
of
document
.
querySelectorAll
(
"
.
hostname
"
)
)
{
host
.
textContent
=
HOST_NAME
;
}
setFocus
(
"
#
returnButton
"
)
;
setupAdvancedButton
(
)
;
document
.
getElementById
(
"
learnMoreContainer
"
)
.
style
.
display
=
"
block
"
;
let
hideAddExceptionButton
=
RPMGetBoolPref
(
"
security
.
certerror
.
hideAddException
"
false
)
;
if
(
hideAddExceptionButton
)
{
document
.
querySelector
(
"
.
exceptionDialogButtonContainer
"
)
.
hidden
=
true
;
}
let
els
=
document
.
querySelectorAll
(
"
[
data
-
telemetry
-
id
]
"
)
;
for
(
let
el
of
els
)
{
el
.
addEventListener
(
"
click
"
recordClickTelemetry
)
;
}
let
failedCertInfo
=
document
.
getFailedCertSecurityInfo
(
)
;
let
errorCode
=
failedCertInfo
.
errorCodeString
.
substring
(
0
40
)
;
RPMRecordTelemetryEvent
(
"
security
.
ui
.
certerror
"
"
load
"
"
aboutcerterror
"
errorCode
{
has_sts
:
(
getCSSClass
(
)
=
=
"
badStsCert
"
)
.
toString
(
)
is_frame
:
(
window
.
parent
!
=
window
)
.
toString
(
)
}
)
;
setCertErrorDetails
(
)
;
}
function
recordClickTelemetry
(
e
)
{
let
target
=
e
.
originalTarget
;
let
telemetryId
=
target
.
dataset
.
telemetryId
;
let
failedCertInfo
=
document
.
getFailedCertSecurityInfo
(
)
;
let
errorCode
=
failedCertInfo
.
errorCodeString
.
substring
(
0
40
)
;
RPMRecordTelemetryEvent
(
"
security
.
ui
.
certerror
"
"
click
"
telemetryId
errorCode
{
has_sts
:
(
getCSSClass
(
)
=
=
"
badStsCert
"
)
.
toString
(
)
is_frame
:
(
window
.
parent
!
=
window
)
.
toString
(
)
}
)
;
}
function
initCertErrorPageActions
(
)
{
document
.
getElementById
(
"
returnButton
"
)
.
addEventListener
(
"
click
"
onReturnButtonClick
)
;
document
.
getElementById
(
"
advancedPanelReturnButton
"
)
.
addEventListener
(
"
click
"
onReturnButtonClick
)
;
document
.
getElementById
(
"
copyToClipboardTop
"
)
.
addEventListener
(
"
click
"
copyPEMToClipboard
)
;
document
.
getElementById
(
"
copyToClipboardBottom
"
)
.
addEventListener
(
"
click
"
copyPEMToClipboard
)
;
document
.
getElementById
(
"
exceptionDialogButton
"
)
.
addEventListener
(
"
click
"
addCertException
)
;
}
function
addCertException
(
)
{
const
isPermanent
=
!
RPMIsWindowPrivate
(
)
&
&
RPMGetBoolPref
(
"
security
.
certerrors
.
permanentOverride
"
)
;
document
.
addCertException
(
!
isPermanent
)
.
then
(
(
)
=
>
{
location
.
reload
(
)
;
}
err
=
>
{
}
)
;
}
function
onReturnButtonClick
(
e
)
{
RPMSendAsyncMessage
(
"
Browser
:
SSLErrorGoBack
"
)
;
}
async
function
copyPEMToClipboard
(
e
)
{
let
details
=
await
getFailedCertificatesAsPEMString
(
)
;
navigator
.
clipboard
.
writeText
(
details
)
;
}
async
function
getFailedCertificatesAsPEMString
(
)
{
let
location
=
document
.
location
.
href
;
let
failedCertInfo
=
document
.
getFailedCertSecurityInfo
(
)
;
let
errorMessage
=
failedCertInfo
.
errorMessage
;
let
hasHSTS
=
failedCertInfo
.
hasHSTS
.
toString
(
)
;
let
hasHPKP
=
failedCertInfo
.
hasHPKP
.
toString
(
)
;
let
[
hstsLabel
hpkpLabel
failedChainLabel
]
=
await
document
.
l10n
.
formatValues
(
[
{
id
:
"
cert
-
error
-
details
-
hsts
-
label
"
args
:
{
hasHSTS
}
}
{
id
:
"
cert
-
error
-
details
-
key
-
pinning
-
label
"
args
:
{
hasHPKP
}
}
{
id
:
"
cert
-
error
-
details
-
cert
-
chain
-
label
"
}
]
)
;
let
certStrings
=
failedCertInfo
.
certChainStrings
;
let
failedChainCertificates
=
"
"
;
for
(
let
der64
of
certStrings
)
{
let
wrapped
=
der64
.
replace
(
/
(
\
S
{
64
}
(
?
!
)
)
/
g
"
1
\
r
\
n
"
)
;
failedChainCertificates
+
=
"
-
-
-
-
-
BEGIN
CERTIFICATE
-
-
-
-
-
\
r
\
n
"
+
wrapped
+
"
\
r
\
n
-
-
-
-
-
END
CERTIFICATE
-
-
-
-
-
\
r
\
n
"
;
}
let
details
=
location
+
"
\
r
\
n
\
r
\
n
"
+
errorMessage
+
"
\
r
\
n
\
r
\
n
"
+
hstsLabel
+
"
\
r
\
n
"
+
hpkpLabel
+
"
\
r
\
n
\
r
\
n
"
+
failedChainLabel
+
"
\
r
\
n
\
r
\
n
"
+
failedChainCertificates
;
return
details
;
}
function
setCertErrorDetails
(
event
)
{
let
failedCertInfo
=
document
.
getFailedCertSecurityInfo
(
)
;
let
mitmPrimingEnabled
=
RPMGetBoolPref
(
"
security
.
certerrors
.
mitm
.
priming
.
enabled
"
)
;
if
(
mitmPrimingEnabled
&
&
failedCertInfo
.
errorCodeString
=
=
"
SEC_ERROR_UNKNOWN_ISSUER
"
&
&
window
.
parent
=
=
window
)
{
RPMSendAsyncMessage
(
"
Browser
:
PrimeMitm
"
)
;
}
let
learnMoreLink
=
document
.
getElementById
(
"
learnMoreLink
"
)
;
let
baseURL
=
RPMGetFormatURLPref
(
"
app
.
support
.
baseURL
"
)
;
learnMoreLink
.
setAttribute
(
"
href
"
baseURL
+
"
connection
-
not
-
secure
"
)
;
let
errWhatToDo
=
document
.
getElementById
(
"
es_nssBadCert_
"
+
failedCertInfo
.
errorCodeString
)
;
let
es
=
document
.
getElementById
(
"
errorWhatToDoText
"
)
;
let
errWhatToDoTitle
=
document
.
getElementById
(
"
edd_nssBadCert
"
)
;
let
est
=
document
.
getElementById
(
"
errorWhatToDoTitleText
"
)
;
let
error
=
gErrorCode
;
if
(
error
=
=
"
sslv3Used
"
)
{
learnMoreLink
.
setAttribute
(
"
href
"
baseURL
+
"
sslv3
-
error
-
messages
"
)
;
}
if
(
error
=
=
"
nssFailure2
"
)
{
let
shortDesc
=
document
.
getElementById
(
"
errorShortDescText
"
)
.
textContent
;
if
(
shortDesc
.
includes
(
"
MOZILLA_PKIX_ERROR_KEY_PINNING_FAILURE
"
)
)
{
learnMoreLink
.
setAttribute
(
"
href
"
baseURL
+
"
certificate
-
pinning
-
reports
"
)
;
}
}
let
clockSkew
=
false
;
document
.
body
.
setAttribute
(
"
code
"
failedCertInfo
.
errorCodeString
)
;
let
titleElement
=
document
.
querySelector
(
"
.
title
-
text
"
)
;
let
desc
;
switch
(
failedCertInfo
.
errorCodeString
)
{
case
"
SSL_ERROR_BAD_CERT_DOMAIN
"
:
case
"
SEC_ERROR_OCSP_INVALID_SIGNING_CERT
"
:
case
"
SEC_ERROR_UNKNOWN_ISSUER
"
:
if
(
es
)
{
es
.
innerHTML
=
errWhatToDo
.
innerHTML
;
}
if
(
est
)
{
est
.
innerHTML
=
errWhatToDoTitle
.
innerHTML
;
}
break
;
case
"
MOZILLA_PKIX_ERROR_ADDITIONAL_POLICY_CONSTRAINT_FAILED
"
:
desc
=
document
.
getElementById
(
"
errorShortDescText2
"
)
;
document
.
l10n
.
setAttributes
(
desc
"
cert
-
error
-
symantec
-
distrust
-
description
"
{
hostname
:
HOST_NAME
}
)
;
let
adminDesc
=
document
.
createElement
(
"
p
"
)
;
document
.
l10n
.
setAttributes
(
adminDesc
"
cert
-
error
-
symantec
-
distrust
-
admin
"
)
;
learnMoreLink
.
href
=
baseURL
+
"
symantec
-
warning
"
;
break
;
case
"
MOZILLA_PKIX_ERROR_MITM_DETECTED
"
:
let
autoEnabledEnterpriseRoots
=
RPMGetBoolPref
(
"
security
.
enterprise_roots
.
auto
-
enabled
"
false
)
;
if
(
mitmPrimingEnabled
&
&
autoEnabledEnterpriseRoots
)
{
RPMSendAsyncMessage
(
"
Browser
:
ResetEnterpriseRootsPref
"
)
;
}
let
names
=
document
.
querySelectorAll
(
"
.
mitm
-
name
"
)
;
for
(
let
span
of
names
)
{
span
.
textContent
=
failedCertInfo
.
issuerCommonName
;
}
learnMoreLink
.
href
=
baseURL
+
"
security
-
error
"
;
document
.
l10n
.
setAttributes
(
titleElement
"
certerror
-
mitm
-
title
"
)
;
desc
=
document
.
getElementById
(
"
ed_mitm
"
)
;
document
.
getElementById
(
"
errorShortDescText
"
)
.
innerHTML
=
desc
.
innerHTML
;
es
.
innerHTML
=
errWhatToDo
.
innerHTML
;
est
.
innerHTML
=
errWhatToDoTitle
.
innerHTML
;
break
;
case
"
MOZILLA_PKIX_ERROR_SELF_SIGNED_CERT
"
:
learnMoreLink
.
href
=
baseURL
+
"
security
-
error
"
;
break
;
case
"
SEC_ERROR_EXPIRED_CERTIFICATE
"
:
case
"
SEC_ERROR_EXPIRED_ISSUER_CERTIFICATE
"
:
case
"
MOZILLA_PKIX_ERROR_NOT_YET_VALID_CERTIFICATE
"
:
case
"
MOZILLA_PKIX_ERROR_NOT_YET_VALID_ISSUER_CERTIFICATE
"
:
learnMoreLink
.
href
=
baseURL
+
"
time
-
errors
"
;
let
difference
=
RPMGetIntPref
(
"
services
.
settings
.
clock_skew_seconds
"
0
)
;
let
lastFetched
=
RPMGetIntPref
(
"
services
.
settings
.
last_update_seconds
"
0
)
*
1000
;
let
now
=
Date
.
now
(
)
;
let
certRange
=
{
notBefore
:
failedCertInfo
.
certValidityRangeNotBefore
notAfter
:
failedCertInfo
.
certValidityRangeNotAfter
}
;
let
approximateDate
=
now
-
difference
*
1000
;
if
(
Math
.
abs
(
difference
)
>
60
*
60
*
24
&
&
now
-
lastFetched
<
=
60
*
60
*
24
*
5
*
1000
&
&
certRange
.
notBefore
<
approximateDate
&
&
certRange
.
notAfter
>
approximateDate
)
{
clockSkew
=
true
;
}
else
{
let
appBuildID
=
RPMGetAppBuildID
(
)
;
let
year
=
parseInt
(
appBuildID
.
substr
(
0
4
)
10
)
;
let
month
=
parseInt
(
appBuildID
.
substr
(
4
2
)
10
)
-
1
;
let
day
=
parseInt
(
appBuildID
.
substr
(
6
2
)
10
)
;
let
buildDate
=
new
Date
(
year
month
day
)
;
let
systemDate
=
new
Date
(
)
;
if
(
buildDate
>
systemDate
&
&
new
Date
(
certRange
.
notAfter
)
>
buildDate
)
{
clockSkew
=
true
;
}
}
let
systemDate
=
formatter
.
format
(
new
Date
(
)
)
;
document
.
getElementById
(
"
wrongSystemTime_systemDate1
"
)
.
textContent
=
systemDate
;
if
(
clockSkew
)
{
document
.
body
.
classList
.
add
(
"
clockSkewError
"
)
;
document
.
l10n
.
setAttributes
(
titleElement
"
clockSkewError
-
title
"
)
;
let
clockErrDesc
=
document
.
getElementById
(
"
ed_clockSkewError
"
)
;
desc
=
document
.
getElementById
(
"
errorShortDescText
"
)
;
document
.
getElementById
(
"
errorShortDesc
"
)
.
style
.
display
=
"
block
"
;
if
(
desc
)
{
desc
.
innerHTML
=
clockErrDesc
.
innerHTML
;
}
}
else
{
let
targetElems
=
document
.
querySelectorAll
(
"
#
wrongSystemTime_systemDate2
"
)
;
for
(
let
elem
of
targetElems
)
{
elem
.
textContent
=
systemDate
;
}
let
errDesc
=
document
.
getElementById
(
"
ed_nssBadCert_SEC_ERROR_EXPIRED_CERTIFICATE
"
)
;
let
sd
=
document
.
getElementById
(
"
errorShortDescText
"
)
;
sd
.
innerHTML
=
errDesc
.
innerHTML
;
let
span
=
sd
.
querySelector
(
"
.
hostname
"
)
;
span
.
textContent
=
HOST_NAME
;
if
(
failedCertInfo
.
errorCodeString
=
=
"
SEC_ERROR_EXPIRED_CERTIFICATE
"
)
{
let
cssClass
=
getCSSClass
(
)
;
let
stsSuffix
=
cssClass
=
=
"
badStsCert
"
?
"
_sts
"
:
"
"
;
let
errDesc2
=
document
.
getElementById
(
ed2_nssBadCert_SEC_ERROR_EXPIRED_CERTIFICATE
{
stsSuffix
}
)
;
let
sd2
=
document
.
getElementById
(
"
errorShortDescText2
"
)
;
sd2
.
innerHTML
=
errDesc2
.
innerHTML
;
if
(
Math
.
abs
(
difference
)
<
=
60
*
60
*
24
&
&
now
-
lastFetched
<
=
60
*
60
*
24
*
5
*
1000
)
{
errWhatToDo
=
document
.
getElementById
(
"
es_nssBadCert_SSL_ERROR_BAD_CERT_DOMAIN
"
)
;
}
}
if
(
es
)
{
es
.
innerHTML
=
errWhatToDo
.
innerHTML
;
}
if
(
est
)
{
est
.
textContent
=
errWhatToDoTitle
.
textContent
;
est
.
style
.
fontWeight
=
"
bold
"
;
}
}
break
;
}
}
async
function
setTechnicalDetailsOnCertError
(
failedCertInfo
=
document
.
getFailedCertSecurityInfo
(
)
)
{
let
technicalInfo
=
document
.
getElementById
(
"
badCertTechnicalInfo
"
)
;
function
setL10NLabel
(
l10nId
args
=
{
}
attrs
=
{
}
rewrite
=
true
)
{
let
elem
=
document
.
createElement
(
"
label
"
)
;
if
(
rewrite
)
{
technicalInfo
.
textContent
=
"
"
;
}
technicalInfo
.
appendChild
(
elem
)
;
let
newLines
=
document
.
createTextNode
(
"
\
n
\
n
"
)
;
technicalInfo
.
appendChild
(
newLines
)
;
if
(
attrs
)
{
let
link
=
document
.
createElement
(
"
a
"
)
;
for
(
let
attr
of
Object
.
keys
(
attrs
)
)
{
link
.
setAttribute
(
attr
attrs
[
attr
]
)
;
}
elem
.
appendChild
(
link
)
;
}
if
(
args
)
{
document
.
l10n
.
setAttributes
(
elem
l10nId
args
)
;
}
else
{
document
.
l10n
.
setAttributes
(
elem
l10nId
)
;
}
}
let
cssClass
=
getCSSClass
(
)
;
let
error
=
gErrorCode
;
let
hostString
=
HOST_NAME
;
let
port
=
document
.
location
.
port
;
if
(
port
&
&
port
!
=
443
)
{
hostString
+
=
"
:
"
+
port
;
}
let
l10nId
;
let
args
=
{
hostname
:
hostString
}
;
if
(
failedCertInfo
.
overridableErrorCategory
=
=
"
trust
-
error
"
)
{
switch
(
failedCertInfo
.
errorCodeString
)
{
case
"
MOZILLA_PKIX_ERROR_MITM_DETECTED
"
:
setL10NLabel
(
"
cert
-
error
-
mitm
-
intro
"
)
;
setL10NLabel
(
"
cert
-
error
-
mitm
-
mozilla
"
{
}
{
}
false
)
;
setL10NLabel
(
"
cert
-
error
-
mitm
-
connection
"
{
}
{
}
false
)
;
break
;
case
"
SEC_ERROR_UNKNOWN_ISSUER
"
:
setL10NLabel
(
"
cert
-
error
-
trust
-
unknown
-
issuer
-
intro
"
)
;
setL10NLabel
(
"
cert
-
error
-
trust
-
unknown
-
issuer
"
args
{
}
false
)
;
break
;
case
"
SEC_ERROR_CA_CERT_INVALID
"
:
setL10NLabel
(
"
cert
-
error
-
intro
"
args
)
;
setL10NLabel
(
"
cert
-
error
-
trust
-
cert
-
invalid
"
{
}
{
}
false
)
;
break
;
case
"
SEC_ERROR_UNTRUSTED_ISSUER
"
:
setL10NLabel
(
"
cert
-
error
-
intro
"
args
)
;
setL10NLabel
(
"
cert
-
error
-
trust
-
untrusted
-
issuer
"
{
}
{
}
false
)
;
break
;
case
"
SEC_ERROR_CERT_SIGNATURE_ALGORITHM_DISABLED
"
:
setL10NLabel
(
"
cert
-
error
-
intro
"
args
)
;
setL10NLabel
(
"
cert
-
error
-
trust
-
signature
-
algorithm
-
disabled
"
{
}
{
}
false
)
;
break
;
case
"
SEC_ERROR_EXPIRED_ISSUER_CERTIFICATE
"
:
setL10NLabel
(
"
cert
-
error
-
intro
"
args
)
;
setL10NLabel
(
"
cert
-
error
-
trust
-
expired
-
issuer
"
{
}
{
}
false
)
;
break
;
case
"
MOZILLA_PKIX_ERROR_SELF_SIGNED_CERT
"
:
setL10NLabel
(
"
cert
-
error
-
intro
"
args
)
;
setL10NLabel
(
"
cert
-
error
-
trust
-
self
-
signed
"
{
}
{
}
false
)
;
break
;
case
"
MOZILLA_PKIX_ERROR_ADDITIONAL_POLICY_CONSTRAINT_FAILED
"
:
setL10NLabel
(
"
cert
-
error
-
intro
"
args
)
;
setL10NLabel
(
"
cert
-
error
-
trust
-
symantec
"
{
}
{
}
false
)
;
break
;
default
:
setL10NLabel
(
"
cert
-
error
-
intro
"
args
)
;
setL10NLabel
(
"
cert
-
error
-
untrusted
-
default
"
{
}
{
}
false
)
;
}
}
else
if
(
failedCertInfo
.
overridableErrorCategory
=
=
"
domain
-
mismatch
"
)
{
let
serverCertBase64
=
failedCertInfo
.
certChainStrings
[
0
]
;
let
parsed
=
await
parse
(
pemToDER
(
serverCertBase64
)
)
;
let
subjectAltNamesExtension
=
parsed
.
ext
.
san
;
let
subjectAltNames
=
[
]
;
if
(
subjectAltNamesExtension
)
{
for
(
let
name
of
subjectAltNamesExtension
.
altNames
)
{
if
(
name
[
0
]
=
=
"
DNS
Name
"
&
&
name
[
1
]
.
length
)
{
subjectAltNames
.
push
(
name
[
1
]
)
;
}
}
}
let
numSubjectAltNames
=
subjectAltNames
.
length
;
if
(
numSubjectAltNames
!
=
0
)
{
if
(
numSubjectAltNames
=
=
1
)
{
args
[
"
alt
-
name
"
]
=
subjectAltNames
[
0
]
;
let
okHost
=
subjectAltNames
[
0
]
;
let
href
=
"
"
;
let
thisHost
=
HOST_NAME
;
let
proto
=
document
.
location
.
protocol
+
"
/
/
"
;
okHost
=
okHost
.
replace
(
/
^
\
*
\
.
/
"
www
.
"
)
;
if
(
okHost
.
endsWith
(
"
.
"
+
thisHost
)
)
{
href
=
proto
+
okHost
;
}
if
(
thisHost
.
endsWith
(
"
.
"
+
okHost
)
)
{
href
=
proto
+
okHost
;
}
if
(
href
&
&
cssClass
!
=
"
expertBadCert
"
)
{
document
.
getElementById
(
"
badCertAdvancedPanel
"
)
.
style
.
display
=
"
block
"
;
if
(
error
=
=
"
nssBadCert
"
)
{
toggleCertErrorDebugInfoVisibility
(
false
)
;
}
}
if
(
href
)
{
setL10NLabel
(
"
cert
-
error
-
domain
-
mismatch
-
single
"
args
{
href
"
data
-
l10n
-
name
"
:
"
domain
-
mismatch
-
link
"
id
:
"
cert_domain_link
"
}
)
;
}
else
{
setL10NLabel
(
"
cert
-
error
-
domain
-
mismatch
-
single
-
nolink
"
args
)
;
}
}
else
{
let
names
=
subjectAltNames
.
join
(
"
"
)
;
args
[
"
subject
-
alt
-
names
"
]
=
names
;
setL10NLabel
(
"
cert
-
error
-
domain
-
mismatch
-
multiple
"
args
)
;
}
}
else
{
setL10NLabel
(
"
cert
-
error
-
domain
-
mismatch
"
{
hostname
:
hostString
}
)
;
}
}
else
if
(
failedCertInfo
.
overridableErrorCategory
=
=
"
expired
-
or
-
not
-
yet
-
valid
"
)
{
let
notBefore
=
failedCertInfo
.
validNotBefore
;
let
notAfter
=
failedCertInfo
.
validNotAfter
;
args
=
{
hostname
:
hostString
}
;
if
(
notBefore
&
&
Date
.
now
(
)
<
notAfter
)
{
let
notBeforeLocalTime
=
formatter
.
format
(
new
Date
(
notBefore
)
)
;
l10nId
=
"
cert
-
error
-
not
-
yet
-
valid
-
now
"
;
args
[
"
not
-
before
-
local
-
time
"
]
=
notBeforeLocalTime
;
}
else
{
let
notAfterLocalTime
=
formatter
.
format
(
new
Date
(
notAfter
)
)
;
l10nId
=
"
cert
-
error
-
expired
-
now
"
;
args
[
"
not
-
after
-
local
-
time
"
]
=
notAfterLocalTime
;
}
setL10NLabel
(
l10nId
args
)
;
}
setL10NLabel
(
"
cert
-
error
-
code
-
prefix
-
link
"
{
error
:
failedCertInfo
.
errorCodeString
}
{
title
:
failedCertInfo
.
errorCodeString
id
:
"
errorCode
"
"
data
-
l10n
-
name
"
:
"
error
-
code
-
link
"
"
data
-
telemetry
-
id
"
:
"
error_code_link
"
href
:
"
#
certificateErrorDebugInformation
"
}
false
)
;
let
errorCodeLink
=
document
.
getElementById
(
"
errorCode
"
)
;
if
(
errorCodeLink
)
{
technicalInfo
.
addEventListener
(
"
click
"
handleErrorCodeClick
)
;
}
let
div
=
document
.
getElementById
(
"
certificateErrorText
"
)
;
div
.
textContent
=
await
getFailedCertificatesAsPEMString
(
)
;
}
function
handleErrorCodeClick
(
event
)
{
if
(
event
.
target
.
id
!
=
=
"
errorCode
"
)
{
return
;
}
event
.
preventDefault
(
)
;
toggleCertErrorDebugInfoVisibility
(
)
;
recordClickTelemetry
(
event
)
;
}
function
setFocus
(
selector
position
=
"
afterbegin
"
)
{
if
(
window
.
top
=
=
window
)
{
var
button
=
document
.
querySelector
(
selector
)
;
var
parent
=
button
.
parentNode
;
parent
.
insertAdjacentElement
(
position
button
)
;
requestAnimationFrame
(
(
)
=
>
{
button
.
focus
(
{
focusVisible
:
false
}
)
;
}
)
;
}
}
for
(
let
button
of
document
.
querySelectorAll
(
"
.
try
-
again
"
)
)
{
button
.
addEventListener
(
"
click
"
function
(
)
{
retryThis
(
this
)
;
}
)
;
}
window
.
addEventListener
(
"
DOMContentLoaded
"
(
)
=
>
{
window
.
setTechnicalDetailsOnCertError
=
setTechnicalDetailsOnCertError
;
initPage
(
)
;
let
event
=
new
CustomEvent
(
"
AboutNetErrorLoad
"
{
bubbles
:
true
}
)
;
document
.
dispatchEvent
(
event
)
;
}
)
;
