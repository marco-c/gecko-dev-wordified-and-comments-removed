var
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineESModuleGetters
(
lazy
{
AMBrowserExtensionsImport
:
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
sys
.
mjs
"
AbuseReporter
:
"
resource
:
/
/
gre
/
modules
/
AbuseReporter
.
sys
.
mjs
"
ExtensionParent
:
"
resource
:
/
/
gre
/
modules
/
ExtensionParent
.
sys
.
mjs
"
ExtensionPermissions
:
"
resource
:
/
/
gre
/
modules
/
ExtensionPermissions
.
sys
.
mjs
"
OriginControls
:
"
resource
:
/
/
gre
/
modules
/
ExtensionPermissions
.
sys
.
mjs
"
SITEPERMS_ADDON_TYPE
:
"
resource
:
/
/
gre
/
modules
/
addons
/
siteperms
-
addon
-
utils
.
sys
.
mjs
"
}
)
;
ChromeUtils
.
defineLazyGetter
(
lazy
"
l10n
"
function
(
)
{
return
new
Localization
(
[
"
browser
/
addonNotifications
.
ftl
"
"
branding
/
brand
.
ftl
"
]
true
)
;
}
)
;
const
ERROR_L10N_IDS
=
new
Map
(
[
[
-
1
[
"
addon
-
install
-
error
-
network
-
failure
"
"
addon
-
local
-
install
-
error
-
network
-
failure
"
]
]
[
-
2
[
"
addon
-
install
-
error
-
incorrect
-
hash
"
"
addon
-
local
-
install
-
error
-
incorrect
-
hash
"
]
]
[
-
3
[
"
addon
-
install
-
error
-
corrupt
-
file
"
"
addon
-
local
-
install
-
error
-
corrupt
-
file
"
]
]
[
-
4
[
"
addon
-
install
-
error
-
file
-
access
"
"
addon
-
local
-
install
-
error
-
file
-
access
"
]
]
[
-
5
[
"
addon
-
install
-
error
-
not
-
signed
"
"
addon
-
local
-
install
-
error
-
not
-
signed
"
]
]
[
-
8
[
"
addon
-
install
-
error
-
invalid
-
domain
"
]
]
[
-
10
[
"
addon
-
install
-
error
-
blocklisted
"
"
addon
-
install
-
error
-
blocklisted
"
]
]
[
-
11
[
"
addon
-
install
-
error
-
incompatible
"
"
addon
-
install
-
error
-
incompatible
"
]
]
[
-
13
[
"
addon
-
install
-
error
-
admin
-
install
-
only
"
"
addon
-
install
-
error
-
admin
-
install
-
only
"
]
]
]
)
;
customElements
.
define
(
"
addon
-
webext
-
permissions
-
notification
"
class
MozAddonPermissionsNotification
extends
customElements
.
get
(
"
popupnotification
"
)
{
show
(
)
{
super
.
show
(
)
;
if
(
!
this
.
notification
)
{
return
;
}
if
(
!
this
.
notification
.
options
?
.
customElementOptions
)
{
throw
new
Error
(
"
Mandatory
customElementOptions
property
missing
from
notification
options
"
)
;
}
this
.
textEl
=
this
.
querySelector
(
"
#
addon
-
webext
-
perm
-
text
"
)
;
this
.
introEl
=
this
.
querySelector
(
"
#
addon
-
webext
-
perm
-
intro
"
)
;
this
.
permsSingleEl
=
this
.
querySelector
(
"
#
addon
-
webext
-
perm
-
single
-
entry
"
)
;
this
.
permsListEl
=
this
.
querySelector
(
"
#
addon
-
webext
-
perm
-
list
"
)
;
this
.
render
(
)
;
}
get
hasNoPermissions
(
)
{
const
{
strings
showIncognitoCheckbox
}
=
this
.
notification
.
options
.
customElementOptions
;
return
!
(
showIncognitoCheckbox
|
|
strings
.
msgs
.
length
)
;
}
get
hasMultiplePermissionsEntries
(
)
{
const
{
strings
showIncognitoCheckbox
}
=
this
.
notification
.
options
.
customElementOptions
;
return
(
strings
.
msgs
.
length
>
1
|
|
(
strings
.
msgs
.
length
=
=
=
1
&
&
showIncognitoCheckbox
)
)
;
}
render
(
)
{
const
{
strings
showIncognitoCheckbox
}
=
this
.
notification
.
options
.
customElementOptions
;
const
{
textEl
introEl
permsSingleEl
permsListEl
}
=
this
;
const
HTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
const
doc
=
this
.
ownerDocument
;
this
.
#
clearChildElements
(
)
;
if
(
strings
.
text
)
{
textEl
.
textContent
=
strings
.
text
;
if
(
strings
.
text
.
includes
(
"
\
n
\
n
"
)
)
{
textEl
.
classList
.
add
(
"
addon
-
webext
-
perm
-
text
-
multiline
"
)
;
}
textEl
.
hidden
=
false
;
}
if
(
strings
.
listIntro
)
{
introEl
.
textContent
=
strings
.
listIntro
;
introEl
.
hidden
=
false
;
}
if
(
this
.
hasNoPermissions
)
{
return
;
}
if
(
this
.
hasMultiplePermissionsEntries
)
{
for
(
let
msg
of
strings
.
msgs
)
{
let
item
=
doc
.
createElementNS
(
HTML_NS
"
li
"
)
;
item
.
classList
.
add
(
"
webext
-
perm
-
granted
"
)
;
item
.
textContent
=
msg
;
permsListEl
.
appendChild
(
item
)
;
}
if
(
showIncognitoCheckbox
)
{
let
item
=
doc
.
createElementNS
(
HTML_NS
"
li
"
)
;
item
.
classList
.
add
(
"
webext
-
perm
-
optional
"
"
webext
-
perm
-
privatebrowsing
"
)
;
item
.
appendChild
(
this
.
#
createPrivateBrowsingCheckbox
(
)
)
;
permsListEl
.
appendChild
(
item
)
;
}
permsListEl
.
hidden
=
false
;
return
;
}
if
(
showIncognitoCheckbox
)
{
permsSingleEl
.
appendChild
(
this
.
#
createPrivateBrowsingCheckbox
(
)
)
;
permsSingleEl
.
hidden
=
false
;
permsSingleEl
.
classList
.
add
(
"
webext
-
perm
-
optional
"
"
webext
-
perm
-
privatebrowsing
"
)
;
return
;
}
permsSingleEl
.
textContent
=
strings
.
msgs
[
0
]
;
permsSingleEl
.
hidden
=
false
;
}
#
clearChildElements
(
)
{
const
{
textEl
introEl
permsSingleEl
permsListEl
}
=
this
;
textEl
.
textContent
=
"
"
;
textEl
.
hidden
=
true
;
textEl
.
classList
.
remove
(
"
addon
-
webext
-
perm
-
text
-
multiline
"
)
;
introEl
.
textContent
=
"
"
;
introEl
.
hidden
=
true
;
permsSingleEl
.
textContent
=
"
"
;
permsSingleEl
.
hidden
=
true
;
permsSingleEl
.
classList
.
remove
(
"
webext
-
perm
-
optional
"
"
webext
-
perm
-
privatebrowsing
"
)
;
permsListEl
.
textContent
=
"
"
;
permsListEl
.
hidden
=
true
;
}
#
createPrivateBrowsingCheckbox
(
)
{
const
{
onPrivateBrowsingAllowedChanged
grantPrivateBrowsingAllowed
}
=
this
.
notification
.
options
.
customElementOptions
;
const
doc
=
this
.
ownerDocument
;
let
checkboxEl
=
doc
.
createXULElement
(
"
checkbox
"
)
;
checkboxEl
.
checked
=
grantPrivateBrowsingAllowed
;
checkboxEl
.
addEventListener
(
"
CheckboxStateChange
"
(
)
=
>
{
onPrivateBrowsingAllowedChanged
?
.
(
checkboxEl
.
checked
)
;
}
)
;
doc
.
l10n
.
setAttributes
(
checkboxEl
"
popup
-
notification
-
addon
-
privatebrowsing
-
checkbox
"
)
;
return
checkboxEl
;
}
}
)
;
customElements
.
define
(
"
addon
-
progress
-
notification
"
class
MozAddonProgressNotification
extends
customElements
.
get
(
"
popupnotification
"
)
{
show
(
)
{
super
.
show
(
)
;
this
.
progressmeter
=
document
.
getElementById
(
"
addon
-
progress
-
notification
-
progressmeter
"
)
;
this
.
progresstext
=
document
.
getElementById
(
"
addon
-
progress
-
notification
-
progresstext
"
)
;
if
(
!
this
.
notification
)
{
return
;
}
this
.
notification
.
options
.
installs
.
forEach
(
function
(
aInstall
)
{
aInstall
.
addListener
(
this
)
;
}
this
)
;
this
.
setProgress
(
0
-
1
)
;
this
.
_updateProgressTimeout
=
setTimeout
(
this
.
updateProgress
.
bind
(
this
)
0
)
;
}
disconnectedCallback
(
)
{
this
.
destroy
(
)
;
}
destroy
(
)
{
if
(
!
this
.
notification
)
{
return
;
}
this
.
notification
.
options
.
installs
.
forEach
(
function
(
aInstall
)
{
aInstall
.
removeListener
(
this
)
;
}
this
)
;
clearTimeout
(
this
.
_updateProgressTimeout
)
;
}
setProgress
(
aProgress
aMaxProgress
)
{
if
(
aMaxProgress
=
=
-
1
)
{
this
.
progressmeter
.
removeAttribute
(
"
value
"
)
;
}
else
{
this
.
progressmeter
.
setAttribute
(
"
value
"
(
aProgress
*
100
)
/
aMaxProgress
)
;
}
let
now
=
Date
.
now
(
)
;
if
(
!
this
.
notification
.
lastUpdate
)
{
this
.
notification
.
lastUpdate
=
now
;
this
.
notification
.
lastProgress
=
aProgress
;
return
;
}
let
delta
=
now
-
this
.
notification
.
lastUpdate
;
if
(
delta
<
400
&
&
aProgress
<
aMaxProgress
)
{
return
;
}
delta
=
Math
.
max
(
delta
400
)
;
delta
/
=
1000
;
let
speed
=
(
aProgress
-
this
.
notification
.
lastProgress
)
/
delta
;
if
(
this
.
notification
.
speed
)
{
speed
=
speed
*
0
.
9
+
this
.
notification
.
speed
*
0
.
1
;
}
this
.
notification
.
lastUpdate
=
now
;
this
.
notification
.
lastProgress
=
aProgress
;
this
.
notification
.
speed
=
speed
;
let
status
=
null
;
[
status
this
.
notification
.
last
]
=
DownloadUtils
.
getDownloadStatus
(
aProgress
aMaxProgress
speed
this
.
notification
.
last
)
;
this
.
progresstext
.
setAttribute
(
"
value
"
status
)
;
this
.
progresstext
.
setAttribute
(
"
tooltiptext
"
status
)
;
}
cancel
(
)
{
let
installs
=
this
.
notification
.
options
.
installs
;
installs
.
forEach
(
function
(
aInstall
)
{
try
{
aInstall
.
cancel
(
)
;
}
catch
(
e
)
{
}
}
this
)
;
PopupNotifications
.
remove
(
this
.
notification
)
;
}
updateProgress
(
)
{
if
(
!
this
.
notification
)
{
return
;
}
let
downloadingCount
=
0
;
let
progress
=
0
;
let
maxProgress
=
0
;
this
.
notification
.
options
.
installs
.
forEach
(
function
(
aInstall
)
{
if
(
aInstall
.
maxProgress
=
=
-
1
)
{
maxProgress
=
-
1
;
}
progress
+
=
aInstall
.
progress
;
if
(
maxProgress
>
=
0
)
{
maxProgress
+
=
aInstall
.
maxProgress
;
}
if
(
aInstall
.
state
<
AddonManager
.
STATE_DOWNLOADED
)
{
downloadingCount
+
+
;
}
}
)
;
if
(
downloadingCount
=
=
0
)
{
this
.
destroy
(
)
;
this
.
progressmeter
.
removeAttribute
(
"
value
"
)
;
const
status
=
lazy
.
l10n
.
formatValueSync
(
"
addon
-
download
-
verifying
"
)
;
this
.
progresstext
.
setAttribute
(
"
value
"
status
)
;
this
.
progresstext
.
setAttribute
(
"
tooltiptext
"
status
)
;
}
else
{
this
.
setProgress
(
progress
maxProgress
)
;
}
}
onDownloadProgress
(
)
{
this
.
updateProgress
(
)
;
}
onDownloadFailed
(
)
{
this
.
updateProgress
(
)
;
}
onDownloadCancelled
(
)
{
this
.
updateProgress
(
)
;
}
onDownloadEnded
(
)
{
this
.
updateProgress
(
)
;
}
}
)
;
function
removeNotificationOnEnd
(
notification
installs
)
{
let
count
=
installs
.
length
;
function
maybeRemove
(
install
)
{
install
.
removeListener
(
this
)
;
if
(
-
-
count
=
=
0
)
{
let
current
=
PopupNotifications
.
getNotification
(
notification
.
id
notification
.
browser
)
;
if
(
current
=
=
=
notification
)
{
notification
.
remove
(
)
;
}
}
}
for
(
let
install
of
installs
)
{
install
.
addListener
(
{
onDownloadCancelled
:
maybeRemove
onDownloadFailed
:
maybeRemove
onInstallFailed
:
maybeRemove
onInstallEnded
:
maybeRemove
}
)
;
}
}
function
buildNotificationAction
(
msg
callback
)
{
let
label
=
"
"
;
let
accessKey
=
"
"
;
for
(
let
{
name
value
}
of
msg
.
attributes
)
{
switch
(
name
)
{
case
"
label
"
:
label
=
value
;
break
;
case
"
accesskey
"
:
accessKey
=
value
;
break
;
}
}
return
{
label
accessKey
callback
}
;
}
var
gXPInstallObserver
=
{
pendingInstalls
:
new
WeakMap
(
)
showInstallConfirmation
(
browser
installInfo
height
=
undefined
)
{
if
(
PopupNotifications
.
getNotification
(
"
addon
-
install
-
confirmation
"
browser
)
)
{
let
pending
=
this
.
pendingInstalls
.
get
(
browser
)
;
if
(
pending
)
{
pending
.
push
(
installInfo
)
;
}
else
{
this
.
pendingInstalls
.
set
(
browser
[
installInfo
]
)
;
}
return
;
}
let
showNextConfirmation
=
(
)
=
>
{
if
(
!
gBrowser
.
browsers
.
includes
(
browser
)
)
{
return
;
}
let
pending
=
this
.
pendingInstalls
.
get
(
browser
)
;
if
(
pending
&
&
pending
.
length
)
{
this
.
showInstallConfirmation
(
browser
pending
.
shift
(
)
)
;
}
}
;
if
(
installInfo
.
installs
.
every
(
i
=
>
i
.
state
!
=
AddonManager
.
STATE_DOWNLOADED
)
)
{
showNextConfirmation
(
)
;
return
;
}
var
options
=
{
displayURI
:
installInfo
.
originatingURI
persistent
:
true
hideClose
:
true
popupOptions
:
{
position
:
"
bottomright
topright
"
}
}
;
let
acceptInstallation
=
(
)
=
>
{
for
(
let
install
of
installInfo
.
installs
)
{
install
.
install
(
)
;
}
installInfo
=
null
;
Services
.
telemetry
.
getHistogramById
(
"
SECURITY_UI
"
)
.
add
(
Ci
.
nsISecurityUITelemetry
.
WARNING_CONFIRM_ADDON_INSTALL_CLICK_THROUGH
)
;
}
;
let
cancelInstallation
=
(
)
=
>
{
if
(
installInfo
)
{
for
(
let
install
of
installInfo
.
installs
)
{
if
(
install
.
state
!
=
AddonManager
.
STATE_CANCELLED
)
{
install
.
cancel
(
)
;
}
}
}
showNextConfirmation
(
)
;
}
;
let
unsigned
=
installInfo
.
installs
.
filter
(
i
=
>
i
.
addon
.
signedState
<
=
AddonManager
.
SIGNEDSTATE_MISSING
)
;
let
someUnsigned
=
!
!
unsigned
.
length
&
&
unsigned
.
length
<
installInfo
.
installs
.
length
;
options
.
eventCallback
=
aEvent
=
>
{
switch
(
aEvent
)
{
case
"
removed
"
:
cancelInstallation
(
)
;
break
;
case
"
shown
"
:
let
addonList
=
document
.
getElementById
(
"
addon
-
install
-
confirmation
-
content
"
)
;
while
(
addonList
.
firstChild
)
{
addonList
.
firstChild
.
remove
(
)
;
}
for
(
let
install
of
installInfo
.
installs
)
{
let
container
=
document
.
createXULElement
(
"
hbox
"
)
;
let
name
=
document
.
createXULElement
(
"
label
"
)
;
name
.
setAttribute
(
"
value
"
install
.
addon
.
name
)
;
name
.
setAttribute
(
"
class
"
"
addon
-
install
-
confirmation
-
name
"
)
;
container
.
appendChild
(
name
)
;
if
(
someUnsigned
&
&
install
.
addon
.
signedState
<
=
AddonManager
.
SIGNEDSTATE_MISSING
)
{
let
unsignedLabel
=
document
.
createXULElement
(
"
label
"
)
;
document
.
l10n
.
setAttributes
(
unsignedLabel
"
popup
-
notification
-
addon
-
install
-
unsigned
"
)
;
unsignedLabel
.
setAttribute
(
"
class
"
"
addon
-
install
-
confirmation
-
unsigned
"
)
;
container
.
appendChild
(
unsignedLabel
)
;
}
addonList
.
appendChild
(
container
)
;
}
break
;
}
}
;
options
.
learnMoreURL
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
;
let
msgId
;
let
notification
=
document
.
getElementById
(
"
addon
-
install
-
confirmation
-
notification
"
)
;
if
(
unsigned
.
length
=
=
installInfo
.
installs
.
length
)
{
msgId
=
"
addon
-
confirm
-
install
-
unsigned
-
message
"
;
notification
.
setAttribute
(
"
warning
"
"
true
"
)
;
options
.
learnMoreURL
+
=
"
unsigned
-
addons
"
;
}
else
if
(
!
unsigned
.
length
)
{
msgId
=
"
addon
-
confirm
-
install
-
message
"
;
notification
.
removeAttribute
(
"
warning
"
)
;
options
.
learnMoreURL
+
=
"
find
-
and
-
install
-
add
-
ons
"
;
}
else
{
msgId
=
"
addon
-
confirm
-
install
-
some
-
unsigned
-
message
"
;
notification
.
setAttribute
(
"
warning
"
"
true
"
)
;
options
.
learnMoreURL
+
=
"
unsigned
-
addons
"
;
}
const
addonCount
=
installInfo
.
installs
.
length
;
const
messageString
=
lazy
.
l10n
.
formatValueSync
(
msgId
{
addonCount
}
)
;
const
[
acceptMsg
cancelMsg
]
=
lazy
.
l10n
.
formatMessagesSync
(
[
"
addon
-
install
-
accept
-
button
"
"
addon
-
install
-
cancel
-
button
"
]
)
;
const
action
=
buildNotificationAction
(
acceptMsg
acceptInstallation
)
;
const
secondaryAction
=
buildNotificationAction
(
cancelMsg
(
)
=
>
{
}
)
;
if
(
height
)
{
notification
.
style
.
minHeight
=
height
+
"
px
"
;
}
let
tab
=
gBrowser
.
getTabForBrowser
(
browser
)
;
if
(
tab
)
{
gBrowser
.
selectedTab
=
tab
;
}
let
popup
=
PopupNotifications
.
show
(
browser
"
addon
-
install
-
confirmation
"
messageString
gUnifiedExtensions
.
getPopupAnchorID
(
browser
window
)
action
[
secondaryAction
]
options
)
;
removeNotificationOnEnd
(
popup
installInfo
.
installs
)
;
Services
.
telemetry
.
getHistogramById
(
"
SECURITY_UI
"
)
.
add
(
Ci
.
nsISecurityUITelemetry
.
WARNING_CONFIRM_ADDON_INSTALL
)
;
}
NOTIFICATION_IDS
:
[
"
addon
-
install
-
blocked
"
"
addon
-
install
-
confirmation
"
"
addon
-
install
-
failed
"
"
addon
-
install
-
origin
-
blocked
"
"
addon
-
install
-
webapi
-
blocked
"
"
addon
-
install
-
policy
-
blocked
"
"
addon
-
progress
"
"
addon
-
webext
-
permissions
"
"
xpinstall
-
disabled
"
]
removeAllNotifications
(
browser
)
{
let
notifications
=
this
.
NOTIFICATION_IDS
.
map
(
id
=
>
PopupNotifications
.
getNotification
(
id
browser
)
)
.
filter
(
notification
=
>
notification
!
=
null
)
;
PopupNotifications
.
remove
(
notifications
true
)
;
return
!
!
notifications
.
length
;
}
logWarningFullScreenInstallBlocked
(
)
{
let
consoleMsg
=
Cc
[
"
mozilla
.
org
/
scripterror
;
1
"
]
.
createInstance
(
Ci
.
nsIScriptError
)
;
const
message
=
lazy
.
l10n
.
formatValueSync
(
"
addon
-
install
-
full
-
screen
-
blocked
"
)
;
consoleMsg
.
initWithWindowID
(
message
gBrowser
.
currentURI
.
spec
0
0
Ci
.
nsIScriptError
.
warningFlag
"
FullScreen
"
gBrowser
.
selectedBrowser
.
innerWindowID
)
;
Services
.
console
.
logMessage
(
consoleMsg
)
;
}
async
observe
(
aSubject
aTopic
)
{
var
installInfo
=
aSubject
.
wrappedJSObject
;
var
browser
=
installInfo
.
browser
;
if
(
!
browser
|
|
!
gBrowser
.
browsers
.
includes
(
browser
)
)
{
return
;
}
var
options
=
{
displayURI
:
installInfo
.
originatingURI
persistent
:
true
hideClose
:
true
timeout
:
Date
.
now
(
)
+
30000
popupOptions
:
{
position
:
"
bottomright
topright
"
}
}
;
switch
(
aTopic
)
{
case
"
addon
-
install
-
disabled
"
:
{
let
msgId
action
secondaryActions
;
if
(
Services
.
prefs
.
prefIsLocked
(
"
xpinstall
.
enabled
"
)
)
{
msgId
=
"
xpinstall
-
disabled
-
by
-
policy
"
;
action
=
null
;
secondaryActions
=
null
;
}
else
{
msgId
=
"
xpinstall
-
disabled
"
;
const
[
disabledMsg
cancelMsg
]
=
await
lazy
.
l10n
.
formatMessages
(
[
"
xpinstall
-
disabled
-
button
"
"
addon
-
install
-
cancel
-
button
"
]
)
;
action
=
buildNotificationAction
(
disabledMsg
(
)
=
>
{
Services
.
prefs
.
setBoolPref
(
"
xpinstall
.
enabled
"
true
)
;
}
)
;
secondaryActions
=
[
buildNotificationAction
(
cancelMsg
(
)
=
>
{
}
)
]
;
}
PopupNotifications
.
show
(
browser
"
xpinstall
-
disabled
"
await
lazy
.
l10n
.
formatValue
(
msgId
)
gUnifiedExtensions
.
getPopupAnchorID
(
browser
window
)
action
secondaryActions
options
)
;
break
;
}
case
"
addon
-
install
-
fullscreen
-
blocked
"
:
{
this
.
logWarningFullScreenInstallBlocked
(
)
;
break
;
}
case
"
addon
-
install
-
webapi
-
blocked
"
:
case
"
addon
-
install
-
policy
-
blocked
"
:
case
"
addon
-
install
-
origin
-
blocked
"
:
{
const
msgId
=
aTopic
=
=
"
addon
-
install
-
policy
-
blocked
"
?
"
addon
-
install
-
domain
-
blocked
-
by
-
policy
"
:
"
xpinstall
-
prompt
"
;
let
messageString
=
await
lazy
.
l10n
.
formatValue
(
msgId
)
;
if
(
Services
.
policies
)
{
let
extensionSettings
=
Services
.
policies
.
getExtensionSettings
(
"
*
"
)
;
if
(
extensionSettings
&
&
"
blocked_install_message
"
in
extensionSettings
)
{
messageString
+
=
"
"
+
extensionSettings
.
blocked_install_message
;
}
}
options
.
removeOnDismissal
=
true
;
options
.
persistent
=
false
;
let
secHistogram
=
Services
.
telemetry
.
getHistogramById
(
"
SECURITY_UI
"
)
;
secHistogram
.
add
(
Ci
.
nsISecurityUITelemetry
.
WARNING_ADDON_ASKING_PREVENTED
)
;
let
popup
=
PopupNotifications
.
show
(
browser
aTopic
messageString
gUnifiedExtensions
.
getPopupAnchorID
(
browser
window
)
null
null
options
)
;
removeNotificationOnEnd
(
popup
installInfo
.
installs
)
;
break
;
}
case
"
addon
-
install
-
blocked
"
:
{
let
progressNotification
=
PopupNotifications
.
getNotification
(
"
addon
-
progress
"
browser
)
;
if
(
progressNotification
)
{
progressNotification
.
remove
(
)
;
}
let
isSitePermissionAddon
=
installInfo
.
installs
.
every
(
(
{
addon
}
)
=
>
addon
?
.
type
=
=
=
lazy
.
SITEPERMS_ADDON_TYPE
)
;
let
hasHost
=
false
;
let
headerId
msgId
;
if
(
isSitePermissionAddon
)
{
headerId
=
"
site
-
permission
-
install
-
first
-
prompt
-
midi
-
header
"
;
msgId
=
"
site
-
permission
-
install
-
first
-
prompt
-
midi
-
message
"
;
}
else
if
(
options
.
displayURI
)
{
headerId
=
{
id
:
"
xpinstall
-
prompt
-
header
"
args
:
{
host
:
"
<
>
"
}
}
;
msgId
=
{
id
:
"
xpinstall
-
prompt
-
message
"
args
:
{
host
:
"
%
1
S
"
}
}
;
options
.
name
=
options
.
displayURI
.
displayHost
;
hasHost
=
true
;
}
else
{
headerId
=
"
xpinstall
-
prompt
-
header
-
unknown
"
;
msgId
=
"
xpinstall
-
prompt
-
message
-
unknown
"
;
}
const
[
headerString
msgString
]
=
await
lazy
.
l10n
.
formatValues
(
[
headerId
msgId
]
)
;
let
displayURI
=
options
.
displayURI
;
options
.
displayURI
=
undefined
;
options
.
eventCallback
=
topic
=
>
{
if
(
topic
!
=
=
"
showing
"
)
{
return
;
}
let
doc
=
browser
.
ownerDocument
;
let
message
=
doc
.
getElementById
(
"
addon
-
install
-
blocked
-
message
"
)
;
while
(
message
.
firstChild
)
{
message
.
firstChild
.
remove
(
)
;
}
if
(
!
hasHost
)
{
message
.
textContent
=
msgString
;
}
else
{
let
b
=
doc
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
"
b
"
)
;
b
.
textContent
=
options
.
name
;
let
fragment
=
BrowserUIUtils
.
getLocalizedFragment
(
doc
msgString
b
)
;
message
.
appendChild
(
fragment
)
;
}
let
article
=
isSitePermissionAddon
?
"
site
-
permission
-
addons
"
:
"
unlisted
-
extensions
-
risks
"
;
let
learnMore
=
doc
.
getElementById
(
"
addon
-
install
-
blocked
-
info
"
)
;
learnMore
.
setAttribute
(
"
support
-
page
"
article
)
;
}
;
let
secHistogram
=
Services
.
telemetry
.
getHistogramById
(
"
SECURITY_UI
"
)
;
secHistogram
.
add
(
Ci
.
nsISecurityUITelemetry
.
WARNING_ADDON_ASKING_PREVENTED
)
;
const
[
installMsg
dontAllowMsg
neverAllowMsg
neverAllowAndReportMsg
]
=
await
lazy
.
l10n
.
formatMessages
(
[
"
xpinstall
-
prompt
-
install
"
"
xpinstall
-
prompt
-
dont
-
allow
"
"
xpinstall
-
prompt
-
never
-
allow
"
"
xpinstall
-
prompt
-
never
-
allow
-
and
-
report
"
]
)
;
const
action
=
buildNotificationAction
(
installMsg
(
)
=
>
{
secHistogram
.
add
(
Ci
.
nsISecurityUITelemetry
.
WARNING_ADDON_ASKING_PREVENTED_CLICK_THROUGH
)
;
installInfo
.
install
(
)
;
}
)
;
const
neverAllowCallback
=
(
)
=
>
{
SitePermissions
.
setForPrincipal
(
browser
.
contentPrincipal
"
install
"
SitePermissions
.
BLOCK
)
;
for
(
let
install
of
installInfo
.
installs
)
{
if
(
install
.
state
!
=
AddonManager
.
STATE_CANCELLED
)
{
install
.
cancel
(
)
;
}
}
if
(
installInfo
.
cancel
)
{
installInfo
.
cancel
(
)
;
}
}
;
const
declineActions
=
[
buildNotificationAction
(
dontAllowMsg
(
)
=
>
{
for
(
let
install
of
installInfo
.
installs
)
{
if
(
install
.
state
!
=
AddonManager
.
STATE_CANCELLED
)
{
install
.
cancel
(
)
;
}
}
if
(
installInfo
.
cancel
)
{
installInfo
.
cancel
(
)
;
}
}
)
buildNotificationAction
(
neverAllowMsg
neverAllowCallback
)
]
;
if
(
isSitePermissionAddon
)
{
declineActions
.
push
(
buildNotificationAction
(
neverAllowAndReportMsg
(
)
=
>
{
AMTelemetry
.
recordSuspiciousSiteEvent
(
{
displayURI
}
)
;
neverAllowCallback
(
)
;
}
)
)
;
}
let
popup
=
PopupNotifications
.
show
(
browser
aTopic
headerString
gUnifiedExtensions
.
getPopupAnchorID
(
browser
window
)
action
declineActions
options
)
;
removeNotificationOnEnd
(
popup
installInfo
.
installs
)
;
break
;
}
case
"
addon
-
install
-
started
"
:
{
if
(
installInfo
.
installs
.
every
(
aInstall
=
>
aInstall
.
state
=
=
AddonManager
.
STATE_DOWNLOADED
)
)
{
return
;
}
const
messageString
=
lazy
.
l10n
.
formatValueSync
(
"
addon
-
downloading
-
and
-
verifying
"
{
addonCount
:
installInfo
.
installs
.
length
}
)
;
options
.
installs
=
installInfo
.
installs
;
options
.
contentWindow
=
browser
.
contentWindow
;
options
.
sourceURI
=
browser
.
currentURI
;
options
.
eventCallback
=
function
(
aEvent
)
{
switch
(
aEvent
)
{
case
"
removed
"
:
options
.
contentWindow
=
null
;
options
.
sourceURI
=
null
;
break
;
}
}
;
const
[
acceptMsg
cancelMsg
]
=
lazy
.
l10n
.
formatMessagesSync
(
[
"
addon
-
install
-
accept
-
button
"
"
addon
-
install
-
cancel
-
button
"
]
)
;
const
action
=
buildNotificationAction
(
acceptMsg
(
)
=
>
{
}
)
;
action
.
disabled
=
true
;
const
secondaryAction
=
buildNotificationAction
(
cancelMsg
(
)
=
>
{
for
(
let
install
of
installInfo
.
installs
)
{
if
(
install
.
state
!
=
AddonManager
.
STATE_CANCELLED
)
{
install
.
cancel
(
)
;
}
}
}
)
;
let
notification
=
PopupNotifications
.
show
(
browser
"
addon
-
progress
"
messageString
gUnifiedExtensions
.
getPopupAnchorID
(
browser
window
)
action
[
secondaryAction
]
options
)
;
notification
.
_startTime
=
Date
.
now
(
)
;
break
;
}
case
"
addon
-
install
-
failed
"
:
{
options
.
removeOnDismissal
=
true
;
options
.
persistent
=
false
;
for
(
let
install
of
installInfo
.
installs
)
{
let
host
;
try
{
host
=
options
.
displayURI
.
host
;
}
catch
(
e
)
{
}
if
(
!
host
)
{
host
=
install
.
sourceURI
instanceof
Ci
.
nsIStandardURL
&
&
install
.
sourceURI
.
host
;
}
let
messageString
;
if
(
install
.
addon
&
&
!
Services
.
policies
.
mayInstallAddon
(
install
.
addon
)
)
{
messageString
=
lazy
.
l10n
.
formatValueSync
(
"
addon
-
installation
-
blocked
-
by
-
policy
"
{
addonName
:
install
.
name
addonId
:
install
.
addon
.
id
}
)
;
let
extensionSettings
=
Services
.
policies
.
getExtensionSettings
(
install
.
addon
.
id
)
;
if
(
extensionSettings
&
&
"
blocked_install_message
"
in
extensionSettings
)
{
messageString
+
=
"
"
+
extensionSettings
.
blocked_install_message
;
}
}
else
{
const
isLocal
=
!
host
;
let
errorId
=
ERROR_L10N_IDS
.
get
(
install
.
error
)
?
.
[
isLocal
?
1
:
0
]
;
const
args
=
{
addonName
:
install
.
name
appVersion
:
Services
.
appinfo
.
version
}
;
if
(
!
errorId
)
{
errorId
=
"
addon
-
install
-
error
-
incompatible
"
;
}
messageString
=
lazy
.
l10n
.
formatValueSync
(
errorId
args
)
;
}
if
(
install
.
error
=
=
AddonManager
.
ERROR_SIGNEDSTATE_REQUIRED
)
{
options
.
learnMoreURL
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
+
"
unsigned
-
addons
"
;
}
PopupNotifications
.
show
(
browser
aTopic
messageString
gUnifiedExtensions
.
getPopupAnchorID
(
browser
window
)
null
null
options
)
;
break
;
}
this
.
_removeProgressNotification
(
browser
)
;
break
;
}
case
"
addon
-
install
-
confirmation
"
:
{
let
showNotification
=
(
)
=
>
{
let
height
=
undefined
;
if
(
PopupNotifications
.
isPanelOpen
)
{
let
rect
=
window
.
windowUtils
.
getBoundsWithoutFlushing
(
document
.
getElementById
(
"
addon
-
progress
-
notification
"
)
)
;
height
=
rect
.
height
;
}
this
.
_removeProgressNotification
(
browser
)
;
this
.
showInstallConfirmation
(
browser
installInfo
height
)
;
}
;
let
progressNotification
=
PopupNotifications
.
getNotification
(
"
addon
-
progress
"
browser
)
;
if
(
progressNotification
)
{
let
downloadDuration
=
Date
.
now
(
)
-
progressNotification
.
_startTime
;
let
securityDelay
=
Services
.
prefs
.
getIntPref
(
"
security
.
dialog_enable_delay
"
)
-
downloadDuration
;
if
(
securityDelay
>
0
)
{
setTimeout
(
(
)
=
>
{
if
(
PopupNotifications
.
getNotification
(
"
addon
-
progress
"
browser
)
)
{
showNotification
(
)
;
}
}
securityDelay
)
;
break
;
}
}
showNotification
(
)
;
break
;
}
}
}
_removeProgressNotification
(
aBrowser
)
{
let
notification
=
PopupNotifications
.
getNotification
(
"
addon
-
progress
"
aBrowser
)
;
if
(
notification
)
{
notification
.
remove
(
)
;
}
}
}
;
var
gExtensionsNotifications
=
{
initialized
:
false
init
(
)
{
this
.
updateAlerts
(
)
;
this
.
boundUpdate
=
this
.
updateAlerts
.
bind
(
this
)
;
ExtensionsUI
.
on
(
"
change
"
this
.
boundUpdate
)
;
this
.
initialized
=
true
;
}
uninit
(
)
{
if
(
!
this
.
initialized
)
{
return
;
}
ExtensionsUI
.
off
(
"
change
"
this
.
boundUpdate
)
;
}
_createAddonButton
(
l10nId
addon
callback
)
{
let
text
=
addon
?
lazy
.
l10n
.
formatValueSync
(
l10nId
{
addonName
:
addon
.
name
}
)
:
lazy
.
l10n
.
formatValueSync
(
l10nId
)
;
let
button
=
document
.
createXULElement
(
"
toolbarbutton
"
)
;
button
.
setAttribute
(
"
id
"
l10nId
)
;
button
.
setAttribute
(
"
wrap
"
"
true
"
)
;
button
.
setAttribute
(
"
label
"
text
)
;
button
.
setAttribute
(
"
tooltiptext
"
text
)
;
const
DEFAULT_EXTENSION_ICON
=
"
chrome
:
/
/
mozapps
/
skin
/
extensions
/
extensionGeneric
.
svg
"
;
button
.
setAttribute
(
"
image
"
addon
?
.
iconURL
|
|
DEFAULT_EXTENSION_ICON
)
;
button
.
className
=
"
addon
-
banner
-
item
subviewbutton
"
;
button
.
addEventListener
(
"
command
"
callback
)
;
PanelUI
.
addonNotificationContainer
.
appendChild
(
button
)
;
}
updateAlerts
(
)
{
let
sideloaded
=
ExtensionsUI
.
sideloaded
;
let
updates
=
ExtensionsUI
.
updates
;
let
container
=
PanelUI
.
addonNotificationContainer
;
while
(
container
.
firstChild
)
{
container
.
firstChild
.
remove
(
)
;
}
let
items
=
0
;
if
(
lazy
.
AMBrowserExtensionsImport
.
canCompleteOrCancelInstalls
)
{
this
.
_createAddonButton
(
"
webext
-
imported
-
addons
"
null
(
)
=
>
{
lazy
.
AMBrowserExtensionsImport
.
completeInstalls
(
)
;
}
)
;
items
+
+
;
}
for
(
let
update
of
updates
)
{
if
(
+
+
items
>
4
)
{
break
;
}
this
.
_createAddonButton
(
"
webext
-
perms
-
update
-
menu
-
item
"
update
.
addon
(
)
=
>
{
ExtensionsUI
.
showUpdate
(
gBrowser
update
)
;
}
)
;
}
for
(
let
addon
of
sideloaded
)
{
if
(
+
+
items
>
4
)
{
break
;
}
this
.
_createAddonButton
(
"
webext
-
perms
-
sideload
-
menu
-
item
"
addon
(
)
=
>
{
PanelUI
.
hide
(
)
;
ExtensionsUI
.
showSideloaded
(
gBrowser
addon
)
;
}
)
;
}
}
}
;
var
BrowserAddonUI
=
{
async
promptRemoveExtension
(
addon
)
{
let
{
name
}
=
addon
;
let
[
title
btnTitle
]
=
await
lazy
.
l10n
.
formatValues
(
[
{
id
:
"
addon
-
removal
-
title
"
args
:
{
name
}
}
{
id
:
"
addon
-
removal
-
button
"
}
]
)
;
let
{
BUTTON_TITLE_IS_STRING
:
titleString
BUTTON_TITLE_CANCEL
:
titleCancel
BUTTON_POS_0
BUTTON_POS_1
confirmEx
}
=
Services
.
prompt
;
let
btnFlags
=
BUTTON_POS_0
*
titleString
+
BUTTON_POS_1
*
titleCancel
;
let
checkboxMessage
=
null
;
if
(
gAddonAbuseReportEnabled
&
&
[
"
extension
"
"
theme
"
]
.
includes
(
addon
.
type
)
)
{
checkboxMessage
=
await
lazy
.
l10n
.
formatValue
(
"
addon
-
removal
-
abuse
-
report
-
checkbox
"
)
;
}
let
checkboxState
=
{
value
:
false
}
;
let
result
=
confirmEx
(
window
title
null
btnFlags
btnTitle
null
null
checkboxMessage
checkboxState
)
;
return
{
remove
:
result
=
=
=
0
report
:
checkboxState
.
value
}
;
}
async
reportAddon
(
addonId
_reportEntryPoint
)
{
let
addon
=
addonId
&
&
(
await
AddonManager
.
getAddonByID
(
addonId
)
)
;
if
(
!
addon
)
{
return
;
}
const
amoUrl
=
lazy
.
AbuseReporter
.
getAMOFormURL
(
{
addonId
}
)
;
window
.
openTrustedLinkIn
(
amoUrl
"
tab
"
{
forceForeground
:
true
}
)
;
}
async
removeAddon
(
addonId
)
{
let
addon
=
addonId
&
&
(
await
AddonManager
.
getAddonByID
(
addonId
)
)
;
if
(
!
addon
|
|
!
(
addon
.
permissions
&
AddonManager
.
PERM_CAN_UNINSTALL
)
)
{
return
;
}
let
{
remove
report
}
=
await
this
.
promptRemoveExtension
(
addon
)
;
if
(
remove
)
{
await
addon
.
uninstall
(
report
)
;
if
(
report
)
{
await
this
.
reportAddon
(
addon
.
id
"
uninstall
"
)
;
}
}
}
async
manageAddon
(
addonId
)
{
let
addon
=
addonId
&
&
(
await
AddonManager
.
getAddonByID
(
addonId
)
)
;
if
(
!
addon
)
{
return
;
}
this
.
openAddonsMgr
(
"
addons
:
/
/
detail
/
"
+
encodeURIComponent
(
addon
.
id
)
)
;
}
openAddonsMgr
(
aView
{
selectTabByViewId
=
false
}
=
{
}
)
{
return
new
Promise
(
resolve
=
>
{
let
emWindow
;
let
browserWindow
;
const
receivePong
=
function
(
aSubject
)
{
const
browserWin
=
aSubject
.
browsingContext
.
topChromeWindow
;
if
(
!
emWindow
|
|
browserWin
=
=
window
)
{
if
(
selectTabByViewId
&
&
aSubject
.
gViewController
.
currentViewId
!
=
=
aView
)
{
return
;
}
emWindow
=
aSubject
;
browserWindow
=
browserWin
;
}
}
;
Services
.
obs
.
addObserver
(
receivePong
"
EM
-
pong
"
)
;
Services
.
obs
.
notifyObservers
(
null
"
EM
-
ping
"
)
;
Services
.
obs
.
removeObserver
(
receivePong
"
EM
-
pong
"
)
;
if
(
emWindow
)
{
if
(
aView
&
&
!
selectTabByViewId
)
{
emWindow
.
loadView
(
aView
)
;
}
let
tab
=
browserWindow
.
gBrowser
.
getTabForBrowser
(
emWindow
.
docShell
.
chromeEventHandler
)
;
browserWindow
.
gBrowser
.
selectedTab
=
tab
;
emWindow
.
focus
(
)
;
resolve
(
emWindow
)
;
return
;
}
if
(
selectTabByViewId
)
{
const
target
=
isBlankPageURL
(
gBrowser
.
currentURI
.
spec
)
?
"
current
"
:
"
tab
"
;
openTrustedLinkIn
(
"
about
:
addons
"
target
)
;
}
else
{
switchToTabHavingURI
(
"
about
:
addons
"
true
)
;
}
Services
.
obs
.
addObserver
(
function
observer
(
aSubject
aTopic
)
{
Services
.
obs
.
removeObserver
(
observer
aTopic
)
;
if
(
aView
)
{
aSubject
.
loadView
(
aView
)
;
}
aSubject
.
focus
(
)
;
resolve
(
aSubject
)
;
}
"
EM
-
loaded
"
)
;
}
)
;
}
}
;
var
gUnifiedExtensions
=
{
_initialized
:
false
MESSAGE_DECK_INDEX_DEFAULT
:
0
MESSAGE_DECK_INDEX_HOVER
:
1
MESSAGE_DECK_INDEX_MENU_HOVER
:
2
init
(
)
{
if
(
this
.
_initialized
)
{
return
;
}
this
.
_button
=
document
.
getElementById
(
"
unified
-
extensions
-
button
"
)
;
this
.
_button
.
hidden
=
false
;
document
.
getElementById
(
"
nav
-
bar
"
)
.
setAttribute
(
"
unifiedextensionsbuttonshown
"
true
)
;
gBrowser
.
addTabsProgressListener
(
this
)
;
window
.
addEventListener
(
"
TabSelect
"
(
)
=
>
this
.
updateAttention
(
)
)
;
window
.
addEventListener
(
"
toolbarvisibilitychange
"
this
)
;
this
.
permListener
=
(
)
=
>
this
.
updateAttention
(
)
;
lazy
.
ExtensionPermissions
.
addListener
(
this
.
permListener
)
;
gNavToolbox
.
addEventListener
(
"
customizationstarting
"
this
)
;
CustomizableUI
.
addListener
(
this
)
;
this
.
_initialized
=
true
;
}
uninit
(
)
{
if
(
!
this
.
_initialized
)
{
return
;
}
window
.
removeEventListener
(
"
toolbarvisibilitychange
"
this
)
;
lazy
.
ExtensionPermissions
.
removeListener
(
this
.
permListener
)
;
this
.
permListener
=
null
;
gNavToolbox
.
removeEventListener
(
"
customizationstarting
"
this
)
;
CustomizableUI
.
removeListener
(
this
)
;
}
onLocationChange
(
browser
webProgress
_request
_uri
flags
)
{
if
(
webProgress
.
isTopLevel
&
&
browser
=
=
=
gBrowser
.
selectedBrowser
&
&
!
(
flags
&
Ci
.
nsIWebProgressListener
.
LOCATION_CHANGE_SAME_DOCUMENT
)
)
{
this
.
updateAttention
(
)
;
}
}
updateAttention
(
)
{
let
attention
=
false
;
for
(
let
policy
of
this
.
getActivePolicies
(
)
)
{
let
widget
=
this
.
browserActionFor
(
policy
)
?
.
widget
;
if
(
!
widget
|
|
widget
.
areaType
!
=
=
CustomizableUI
.
TYPE_TOOLBAR
)
{
if
(
lazy
.
OriginControls
.
getAttentionState
(
policy
window
)
.
attention
)
{
attention
=
true
;
break
;
}
}
}
const
quarantined
=
this
.
_shouldShowQuarantinedNotification
(
)
;
this
.
button
.
toggleAttribute
(
"
attention
"
quarantined
|
|
attention
)
;
let
msgId
=
attention
?
"
unified
-
extensions
-
button
-
permissions
-
needed
"
:
"
unified
-
extensions
-
button
"
;
if
(
quarantined
)
{
msgId
=
"
unified
-
extensions
-
button
-
quarantined
"
;
}
this
.
button
.
ownerDocument
.
l10n
.
setAttributes
(
this
.
button
msgId
)
;
}
getPopupAnchorID
(
aBrowser
aWindow
)
{
const
anchorID
=
"
unified
-
extensions
-
button
"
;
const
attr
=
anchorID
+
"
popupnotificationanchor
"
;
if
(
!
aBrowser
[
attr
]
)
{
aBrowser
[
attr
]
=
aWindow
.
document
.
getElementById
(
anchorID
)
.
firstElementChild
;
}
return
anchorID
;
}
get
button
(
)
{
return
this
.
_button
;
}
getActivePolicies
(
all
=
true
)
{
let
policies
=
WebExtensionPolicy
.
getActiveExtensions
(
)
;
policies
=
policies
.
filter
(
policy
=
>
{
let
{
extension
}
=
policy
;
if
(
!
policy
.
active
|
|
extension
?
.
type
!
=
=
"
extension
"
)
{
return
false
;
}
if
(
extension
.
isHidden
|
|
!
policy
.
canAccessWindow
(
window
)
)
{
return
false
;
}
return
all
|
|
!
extension
.
hasBrowserActionUI
;
}
)
;
policies
.
sort
(
(
a
b
)
=
>
a
.
name
.
localeCompare
(
b
.
name
)
)
;
return
policies
;
}
hasExtensionsInPanel
(
)
{
const
policies
=
this
.
getActivePolicies
(
)
;
return
!
!
policies
.
map
(
policy
=
>
this
.
browserActionFor
(
policy
)
?
.
widget
)
.
filter
(
widget
=
>
{
return
(
!
widget
|
|
widget
?
.
areaType
!
=
=
CustomizableUI
.
TYPE_TOOLBAR
|
|
widget
?
.
forWindow
(
window
)
.
overflowed
)
;
}
)
.
length
;
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
ViewShowing
"
:
this
.
onPanelViewShowing
(
event
.
target
)
;
break
;
case
"
ViewHiding
"
:
this
.
onPanelViewHiding
(
event
.
target
)
;
break
;
case
"
customizationstarting
"
:
this
.
panel
.
hidePopup
(
)
;
break
;
case
"
toolbarvisibilitychange
"
:
this
.
onToolbarVisibilityChange
(
event
.
target
.
id
event
.
detail
.
visible
)
;
break
;
}
}
onPanelViewShowing
(
panelview
)
{
const
list
=
panelview
.
querySelector
(
"
.
unified
-
extensions
-
list
"
)
;
for
(
const
policy
of
this
.
getActivePolicies
(
false
)
)
{
const
item
=
document
.
createElement
(
"
unified
-
extensions
-
item
"
)
;
item
.
setExtension
(
policy
.
extension
)
;
list
.
appendChild
(
item
)
;
}
const
container
=
panelview
.
querySelector
(
"
#
unified
-
extensions
-
messages
-
container
"
)
;
const
shouldShowQuarantinedNotification
=
this
.
_shouldShowQuarantinedNotification
(
)
;
if
(
shouldShowQuarantinedNotification
)
{
if
(
!
this
.
_messageBarQuarantinedDomain
)
{
this
.
_messageBarQuarantinedDomain
=
this
.
_makeMessageBar
(
{
messageBarFluentId
:
"
unified
-
extensions
-
mb
-
quarantined
-
domain
-
message
-
3
"
supportPage
:
"
quarantined
-
domains
"
dismissable
:
false
}
)
;
this
.
_messageBarQuarantinedDomain
.
querySelector
(
"
a
"
)
.
addEventListener
(
"
click
"
(
)
=
>
{
this
.
togglePanel
(
)
;
}
)
;
}
container
.
appendChild
(
this
.
_messageBarQuarantinedDomain
)
;
}
else
if
(
!
shouldShowQuarantinedNotification
&
&
this
.
_messageBarQuarantinedDomain
&
&
container
.
contains
(
this
.
_messageBarQuarantinedDomain
)
)
{
container
.
removeChild
(
this
.
_messageBarQuarantinedDomain
)
;
}
}
onPanelViewHiding
(
panelview
)
{
if
(
window
.
closed
)
{
return
;
}
const
list
=
panelview
.
querySelector
(
"
.
unified
-
extensions
-
list
"
)
;
while
(
list
.
lastChild
)
{
list
.
lastChild
.
remove
(
)
;
}
requestAnimationFrame
(
(
)
=
>
this
.
updateAttention
(
)
)
;
}
onToolbarVisibilityChange
(
toolbarId
isVisible
)
{
let
widgetIDs
;
try
{
widgetIDs
=
CustomizableUI
.
getWidgetIdsInArea
(
toolbarId
)
.
filter
(
CustomizableUI
.
isWebExtensionWidget
)
;
}
catch
{
return
;
}
const
overflowedExtensionsList
=
this
.
panel
.
querySelector
(
"
#
overflowed
-
extensions
-
list
"
)
;
for
(
const
widgetID
of
widgetIDs
)
{
const
widget
=
CustomizableUI
.
getWidget
(
widgetID
)
;
if
(
!
widget
)
{
continue
;
}
if
(
isVisible
)
{
this
.
_maybeMoveWidgetNodeBack
(
widget
.
id
)
;
}
else
{
const
{
node
}
=
widget
.
forWindow
(
window
)
;
node
.
setAttribute
(
"
overflowedItem
"
true
)
;
node
.
setAttribute
(
"
artificallyOverflowed
"
true
)
;
node
.
setAttribute
(
"
cui
-
anchorid
"
"
unified
-
extensions
-
button
"
)
;
overflowedExtensionsList
.
appendChild
(
node
)
;
this
.
_updateWidgetClassName
(
widgetID
true
)
;
}
}
}
_maybeMoveWidgetNodeBack
(
widgetID
)
{
const
widget
=
CustomizableUI
.
getWidget
(
widgetID
)
;
if
(
!
widget
)
{
return
;
}
const
{
node
}
=
widget
.
forWindow
(
window
)
;
if
(
!
node
.
hasAttribute
(
"
artificallyOverflowed
"
)
)
{
return
;
}
const
{
area
position
}
=
CustomizableUI
.
getPlacementOfWidget
(
widgetID
)
;
const
container
=
document
.
getElementById
(
area
)
;
let
moved
=
false
;
let
currentPosition
=
0
;
for
(
const
child
of
container
.
childNodes
)
{
const
isSkipToolbarset
=
child
.
getAttribute
(
"
skipintoolbarset
"
)
=
=
"
true
"
;
if
(
isSkipToolbarset
&
&
child
!
=
=
container
.
lastChild
)
{
continue
;
}
if
(
currentPosition
=
=
=
position
)
{
child
.
before
(
node
)
;
moved
=
true
;
break
;
}
if
(
child
=
=
=
container
.
lastChild
)
{
child
.
after
(
node
)
;
moved
=
true
;
break
;
}
currentPosition
+
+
;
}
if
(
moved
)
{
node
.
removeAttribute
(
"
overflowedItem
"
)
;
node
.
removeAttribute
(
"
artificallyOverflowed
"
)
;
node
.
removeAttribute
(
"
cui
-
anchorid
"
)
;
this
.
_updateWidgetClassName
(
widgetID
false
)
;
}
}
_panel
:
null
get
panel
(
)
{
if
(
!
this
.
_panel
)
{
let
template
=
document
.
getElementById
(
"
unified
-
extensions
-
panel
-
template
"
)
;
template
.
replaceWith
(
template
.
content
)
;
this
.
_panel
=
document
.
getElementById
(
"
unified
-
extensions
-
panel
"
)
;
let
customizationArea
=
this
.
_panel
.
querySelector
(
"
#
unified
-
extensions
-
area
"
)
;
CustomizableUI
.
registerPanelNode
(
customizationArea
CustomizableUI
.
AREA_ADDONS
)
;
CustomizableUI
.
addPanelCloseListeners
(
this
.
_panel
)
;
document
.
getElementById
(
"
unified
-
extensions
-
context
-
menu
"
)
.
querySelectorAll
(
"
[
data
-
lazy
-
l10n
-
id
]
"
)
.
forEach
(
el
=
>
{
el
.
setAttribute
(
"
data
-
l10n
-
id
"
el
.
getAttribute
(
"
data
-
lazy
-
l10n
-
id
"
)
)
;
el
.
removeAttribute
(
"
data
-
lazy
-
l10n
-
id
"
)
;
}
)
;
}
return
this
.
_panel
;
}
async
togglePanel
(
aEvent
)
{
if
(
!
CustomizationHandler
.
isCustomizing
(
)
)
{
if
(
aEvent
)
{
if
(
(
aEvent
.
type
=
=
"
mousedown
"
&
&
(
aEvent
.
button
!
=
=
0
|
|
(
AppConstants
.
platform
=
=
=
"
macosx
"
&
&
aEvent
.
ctrlKey
)
)
)
|
|
(
aEvent
.
type
=
=
=
"
keypress
"
&
&
aEvent
.
charCode
!
=
=
KeyEvent
.
DOM_VK_SPACE
&
&
aEvent
.
keyCode
!
=
=
KeyEvent
.
DOM_VK_RETURN
)
)
{
return
;
}
if
(
!
this
.
hasExtensionsInPanel
(
)
)
{
let
viewID
;
if
(
Services
.
prefs
.
getBoolPref
(
"
extensions
.
getAddons
.
showPane
"
true
)
)
{
viewID
=
"
addons
:
/
/
discover
/
"
;
}
else
{
viewID
=
"
addons
:
/
/
list
/
extension
"
;
}
await
BrowserAddonUI
.
openAddonsMgr
(
viewID
)
;
return
;
}
}
let
panel
=
this
.
panel
;
if
(
!
this
.
_listView
)
{
this
.
_listView
=
PanelMultiView
.
getViewNode
(
document
"
unified
-
extensions
-
view
"
)
;
this
.
_listView
.
addEventListener
(
"
ViewShowing
"
this
)
;
this
.
_listView
.
addEventListener
(
"
ViewHiding
"
this
)
;
}
if
(
this
.
_button
.
open
)
{
PanelMultiView
.
hidePopup
(
panel
)
;
this
.
_button
.
open
=
false
;
}
else
{
for
(
const
toolbarId
of
CustomizableUI
.
getCollapsedToolbarIds
(
window
)
)
{
this
.
onToolbarVisibilityChange
(
toolbarId
false
)
;
}
panel
.
hidden
=
false
;
PanelMultiView
.
openPopup
(
panel
this
.
_button
{
position
:
"
bottomright
topright
"
triggerEvent
:
aEvent
}
)
;
}
}
window
.
dispatchEvent
(
new
CustomEvent
(
"
UnifiedExtensionsTogglePanel
"
)
)
;
}
updateContextMenu
(
menu
event
)
{
if
(
event
.
target
.
id
!
=
=
"
unified
-
extensions
-
context
-
menu
"
)
{
return
;
}
const
id
=
this
.
_getExtensionId
(
menu
)
;
const
widgetId
=
this
.
_getWidgetId
(
menu
)
;
const
forBrowserAction
=
!
!
widgetId
;
const
pinButton
=
menu
.
querySelector
(
"
.
unified
-
extensions
-
context
-
menu
-
pin
-
to
-
toolbar
"
)
;
const
removeButton
=
menu
.
querySelector
(
"
.
unified
-
extensions
-
context
-
menu
-
remove
-
extension
"
)
;
const
reportButton
=
menu
.
querySelector
(
"
.
unified
-
extensions
-
context
-
menu
-
report
-
extension
"
)
;
const
menuSeparator
=
menu
.
querySelector
(
"
.
unified
-
extensions
-
context
-
menu
-
management
-
separator
"
)
;
const
moveUp
=
menu
.
querySelector
(
"
.
unified
-
extensions
-
context
-
menu
-
move
-
widget
-
up
"
)
;
const
moveDown
=
menu
.
querySelector
(
"
.
unified
-
extensions
-
context
-
menu
-
move
-
widget
-
down
"
)
;
for
(
const
element
of
[
menuSeparator
pinButton
moveUp
moveDown
]
)
{
element
.
hidden
=
!
forBrowserAction
;
}
reportButton
.
hidden
=
!
gAddonAbuseReportEnabled
;
AddonManager
.
getAddonByID
(
id
)
.
then
(
addon
=
>
{
removeButton
.
disabled
=
!
(
addon
.
permissions
&
AddonManager
.
PERM_CAN_UNINSTALL
)
;
}
)
;
if
(
forBrowserAction
)
{
let
area
=
CustomizableUI
.
getPlacementOfWidget
(
widgetId
)
.
area
;
let
inToolbar
=
area
!
=
CustomizableUI
.
AREA_ADDONS
;
pinButton
.
setAttribute
(
"
checked
"
inToolbar
)
;
const
placement
=
CustomizableUI
.
getPlacementOfWidget
(
widgetId
)
;
const
notInPanel
=
placement
?
.
area
!
=
=
CustomizableUI
.
AREA_ADDONS
;
if
(
notInPanel
|
|
document
.
querySelector
(
"
#
unified
-
extensions
-
area
>
:
first
-
child
"
)
?
.
id
=
=
=
widgetId
)
{
moveUp
.
hidden
=
true
;
}
if
(
notInPanel
|
|
document
.
querySelector
(
"
#
unified
-
extensions
-
area
>
:
last
-
child
"
)
?
.
id
=
=
=
widgetId
)
{
moveDown
.
hidden
=
true
;
}
}
ExtensionsUI
.
originControlsMenu
(
menu
id
)
;
const
browserAction
=
this
.
browserActionFor
(
WebExtensionPolicy
.
getByID
(
id
)
)
;
if
(
browserAction
)
{
browserAction
.
updateContextMenu
(
menu
)
;
}
}
onContextMenuCommand
(
menu
event
)
{
const
{
classList
}
=
event
.
target
;
if
(
classList
.
contains
(
"
unified
-
extensions
-
context
-
menu
-
move
-
widget
-
up
"
)
|
|
classList
.
contains
(
"
unified
-
extensions
-
context
-
menu
-
move
-
widget
-
down
"
)
)
{
return
;
}
this
.
togglePanel
(
)
;
}
browserActionFor
(
policy
)
{
let
method
=
lazy
.
ExtensionParent
.
apiManager
.
global
.
browserActionFor
;
return
method
?
.
(
policy
?
.
extension
)
;
}
async
manageExtension
(
menu
)
{
const
id
=
this
.
_getExtensionId
(
menu
)
;
await
BrowserAddonUI
.
manageAddon
(
id
"
unifiedExtensions
"
)
;
}
async
removeExtension
(
menu
)
{
const
id
=
this
.
_getExtensionId
(
menu
)
;
await
BrowserAddonUI
.
removeAddon
(
id
"
unifiedExtensions
"
)
;
}
async
reportExtension
(
menu
)
{
const
id
=
this
.
_getExtensionId
(
menu
)
;
await
BrowserAddonUI
.
reportAddon
(
id
"
unified_context_menu
"
)
;
}
_getExtensionId
(
menu
)
{
const
{
triggerNode
}
=
menu
;
return
triggerNode
.
dataset
.
extensionid
;
}
_getWidgetId
(
menu
)
{
const
{
triggerNode
}
=
menu
;
return
triggerNode
.
closest
(
"
.
unified
-
extensions
-
item
"
)
?
.
id
;
}
async
onPinToToolbarChange
(
menu
event
)
{
let
shouldPinToToolbar
=
event
.
target
.
getAttribute
(
"
checked
"
)
=
=
"
true
"
;
event
.
target
.
setAttribute
(
"
checked
"
!
shouldPinToToolbar
)
;
let
widgetId
=
this
.
_getWidgetId
(
menu
)
;
if
(
!
widgetId
)
{
return
;
}
if
(
shouldPinToToolbar
)
{
this
.
_maybeMoveWidgetNodeBack
(
widgetId
)
;
}
this
.
pinToToolbar
(
widgetId
shouldPinToToolbar
)
;
}
pinToToolbar
(
widgetId
shouldPinToToolbar
)
{
let
newArea
=
shouldPinToToolbar
?
CustomizableUI
.
AREA_NAVBAR
:
CustomizableUI
.
AREA_ADDONS
;
let
newPosition
=
shouldPinToToolbar
?
undefined
:
0
;
CustomizableUI
.
addWidgetToArea
(
widgetId
newArea
newPosition
)
;
this
.
updateAttention
(
)
;
}
async
moveWidget
(
menu
direction
)
{
const
node
=
menu
.
triggerNode
.
closest
(
"
.
unified
-
extensions
-
item
"
)
;
let
element
;
if
(
direction
=
=
=
"
up
"
&
&
node
.
previousElementSibling
)
{
element
=
node
.
previousElementSibling
;
}
else
if
(
direction
=
=
=
"
down
"
&
&
node
.
nextElementSibling
)
{
element
=
node
.
nextElementSibling
;
}
const
placement
=
CustomizableUI
.
getPlacementOfWidget
(
element
?
.
id
)
;
if
(
placement
)
{
let
newPosition
=
placement
.
position
;
if
(
direction
=
=
=
"
down
"
)
{
newPosition
+
=
1
;
}
CustomizableUI
.
moveWidgetWithinArea
(
node
.
id
newPosition
)
;
}
}
onWidgetAdded
(
aWidgetId
aArea
)
{
if
(
CustomizableUI
.
getWidget
(
aWidgetId
)
?
.
forWindow
(
window
)
?
.
overflowed
)
{
return
;
}
const
inPanel
=
CustomizableUI
.
getAreaType
(
aArea
)
!
=
=
CustomizableUI
.
TYPE_TOOLBAR
;
this
.
_updateWidgetClassName
(
aWidgetId
inPanel
)
;
}
onWidgetOverflow
(
aNode
)
{
if
(
window
!
=
=
aNode
.
ownerGlobal
)
{
return
;
}
this
.
_updateWidgetClassName
(
aNode
.
getAttribute
(
"
widget
-
id
"
)
true
)
;
}
onWidgetUnderflow
(
aNode
)
{
if
(
window
!
=
=
aNode
.
ownerGlobal
)
{
return
;
}
this
.
_updateWidgetClassName
(
aNode
.
getAttribute
(
"
widget
-
id
"
)
false
)
;
}
onAreaNodeRegistered
(
aArea
aContainer
)
{
if
(
window
!
=
=
aContainer
.
ownerGlobal
)
{
return
;
}
const
inPanel
=
CustomizableUI
.
getAreaType
(
aArea
)
!
=
=
CustomizableUI
.
TYPE_TOOLBAR
;
for
(
const
widgetId
of
CustomizableUI
.
getWidgetIdsInArea
(
aArea
)
)
{
this
.
_updateWidgetClassName
(
widgetId
inPanel
)
;
}
}
_updateWidgetClassName
(
aWidgetId
inPanel
)
{
if
(
!
CustomizableUI
.
isWebExtensionWidget
(
aWidgetId
)
)
{
return
;
}
const
node
=
CustomizableUI
.
getWidget
(
aWidgetId
)
?
.
forWindow
(
window
)
?
.
node
;
const
actionButton
=
node
?
.
querySelector
(
"
.
unified
-
extensions
-
item
-
action
-
button
"
)
;
if
(
actionButton
)
{
actionButton
.
classList
.
toggle
(
"
subviewbutton
"
inPanel
)
;
actionButton
.
classList
.
toggle
(
"
subviewbutton
-
iconic
"
inPanel
)
;
actionButton
.
classList
.
toggle
(
"
toolbarbutton
-
1
"
!
inPanel
)
;
}
const
menuButton
=
node
?
.
querySelector
(
"
.
unified
-
extensions
-
item
-
menu
-
button
"
)
;
if
(
menuButton
)
{
menuButton
.
classList
.
toggle
(
"
subviewbutton
"
inPanel
)
;
menuButton
.
classList
.
toggle
(
"
subviewbutton
-
iconic
"
inPanel
)
;
menuButton
.
classList
.
toggle
(
"
toolbarbutton
-
1
"
!
inPanel
)
;
}
}
_makeMessageBar
(
{
messageBarFluentId
supportPage
=
null
type
=
"
warning
"
}
)
{
const
messageBar
=
document
.
createElement
(
"
moz
-
message
-
bar
"
)
;
messageBar
.
setAttribute
(
"
type
"
type
)
;
messageBar
.
classList
.
add
(
"
unified
-
extensions
-
message
-
bar
"
)
;
document
.
l10n
.
setAttributes
(
messageBar
messageBarFluentId
)
;
messageBar
.
setAttribute
(
"
data
-
l10n
-
attrs
"
"
heading
message
"
)
;
if
(
supportPage
)
{
const
supportUrl
=
document
.
createElement
(
"
a
"
{
is
:
"
moz
-
support
-
link
"
}
)
;
supportUrl
.
setAttribute
(
"
support
-
page
"
supportPage
)
;
document
.
l10n
.
setAttributes
(
supportUrl
"
unified
-
extensions
-
mb
-
quarantined
-
domain
-
learn
-
more
"
)
;
supportUrl
.
setAttribute
(
"
data
-
l10n
-
attrs
"
"
aria
-
label
"
)
;
supportUrl
.
setAttribute
(
"
slot
"
"
support
-
link
"
)
;
messageBar
.
append
(
supportUrl
)
;
}
return
messageBar
;
}
_shouldShowQuarantinedNotification
(
)
{
const
{
currentURI
selectedTab
}
=
window
.
gBrowser
;
return
(
WebExtensionPolicy
.
isQuarantinedURI
(
currentURI
)
&
&
this
.
hasExtensionsInPanel
(
)
&
&
this
.
getActivePolicies
(
)
.
some
(
policy
=
>
lazy
.
OriginControls
.
getState
(
policy
selectedTab
)
.
quarantined
)
)
;
}
}
;
