const
lazy
=
{
}
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
ExtensionParent
"
"
resource
:
/
/
gre
/
modules
/
ExtensionParent
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
OriginControls
"
"
resource
:
/
/
gre
/
modules
/
ExtensionPermissions
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
ExtensionPermissions
"
"
resource
:
/
/
gre
/
modules
/
ExtensionPermissions
.
jsm
"
)
;
ChromeUtils
.
defineESModuleGetters
(
lazy
{
SITEPERMS_ADDON_TYPE
:
"
resource
:
/
/
gre
/
modules
/
addons
/
siteperms
-
addon
-
utils
.
sys
.
mjs
"
}
)
;
customElements
.
define
(
"
addon
-
progress
-
notification
"
class
MozAddonProgressNotification
extends
customElements
.
get
(
"
popupnotification
"
)
{
show
(
)
{
super
.
show
(
)
;
this
.
progressmeter
=
document
.
getElementById
(
"
addon
-
progress
-
notification
-
progressmeter
"
)
;
this
.
progresstext
=
document
.
getElementById
(
"
addon
-
progress
-
notification
-
progresstext
"
)
;
if
(
!
this
.
notification
)
{
return
;
}
this
.
notification
.
options
.
installs
.
forEach
(
function
(
aInstall
)
{
aInstall
.
addListener
(
this
)
;
}
this
)
;
this
.
setProgress
(
0
-
1
)
;
this
.
_updateProgressTimeout
=
setTimeout
(
this
.
updateProgress
.
bind
(
this
)
0
)
;
}
disconnectedCallback
(
)
{
this
.
destroy
(
)
;
}
destroy
(
)
{
if
(
!
this
.
notification
)
{
return
;
}
this
.
notification
.
options
.
installs
.
forEach
(
function
(
aInstall
)
{
aInstall
.
removeListener
(
this
)
;
}
this
)
;
clearTimeout
(
this
.
_updateProgressTimeout
)
;
}
setProgress
(
aProgress
aMaxProgress
)
{
if
(
aMaxProgress
=
=
-
1
)
{
this
.
progressmeter
.
removeAttribute
(
"
value
"
)
;
}
else
{
this
.
progressmeter
.
setAttribute
(
"
value
"
(
aProgress
*
100
)
/
aMaxProgress
)
;
}
let
now
=
Date
.
now
(
)
;
if
(
!
this
.
notification
.
lastUpdate
)
{
this
.
notification
.
lastUpdate
=
now
;
this
.
notification
.
lastProgress
=
aProgress
;
return
;
}
let
delta
=
now
-
this
.
notification
.
lastUpdate
;
if
(
delta
<
400
&
&
aProgress
<
aMaxProgress
)
{
return
;
}
delta
=
Math
.
max
(
delta
400
)
;
delta
/
=
1000
;
let
speed
=
(
aProgress
-
this
.
notification
.
lastProgress
)
/
delta
;
if
(
this
.
notification
.
speed
)
{
speed
=
speed
*
0
.
9
+
this
.
notification
.
speed
*
0
.
1
;
}
this
.
notification
.
lastUpdate
=
now
;
this
.
notification
.
lastProgress
=
aProgress
;
this
.
notification
.
speed
=
speed
;
let
status
=
null
;
[
status
this
.
notification
.
last
]
=
DownloadUtils
.
getDownloadStatus
(
aProgress
aMaxProgress
speed
this
.
notification
.
last
)
;
this
.
progresstext
.
setAttribute
(
"
value
"
status
)
;
this
.
progresstext
.
setAttribute
(
"
tooltiptext
"
status
)
;
}
cancel
(
)
{
let
installs
=
this
.
notification
.
options
.
installs
;
installs
.
forEach
(
function
(
aInstall
)
{
try
{
aInstall
.
cancel
(
)
;
}
catch
(
e
)
{
}
}
this
)
;
PopupNotifications
.
remove
(
this
.
notification
)
;
}
updateProgress
(
)
{
if
(
!
this
.
notification
)
{
return
;
}
let
downloadingCount
=
0
;
let
progress
=
0
;
let
maxProgress
=
0
;
this
.
notification
.
options
.
installs
.
forEach
(
function
(
aInstall
)
{
if
(
aInstall
.
maxProgress
=
=
-
1
)
{
maxProgress
=
-
1
;
}
progress
+
=
aInstall
.
progress
;
if
(
maxProgress
>
=
0
)
{
maxProgress
+
=
aInstall
.
maxProgress
;
}
if
(
aInstall
.
state
<
AddonManager
.
STATE_DOWNLOADED
)
{
downloadingCount
+
+
;
}
}
)
;
if
(
downloadingCount
=
=
0
)
{
this
.
destroy
(
)
;
this
.
progressmeter
.
removeAttribute
(
"
value
"
)
;
let
status
=
gNavigatorBundle
.
getString
(
"
addonDownloadVerifying
"
)
;
this
.
progresstext
.
setAttribute
(
"
value
"
status
)
;
this
.
progresstext
.
setAttribute
(
"
tooltiptext
"
status
)
;
}
else
{
this
.
setProgress
(
progress
maxProgress
)
;
}
}
onDownloadProgress
(
)
{
this
.
updateProgress
(
)
;
}
onDownloadFailed
(
)
{
this
.
updateProgress
(
)
;
}
onDownloadCancelled
(
)
{
this
.
updateProgress
(
)
;
}
onDownloadEnded
(
)
{
this
.
updateProgress
(
)
;
}
}
)
;
function
removeNotificationOnEnd
(
notification
installs
)
{
let
count
=
installs
.
length
;
function
maybeRemove
(
install
)
{
install
.
removeListener
(
this
)
;
if
(
-
-
count
=
=
0
)
{
let
current
=
PopupNotifications
.
getNotification
(
notification
.
id
notification
.
browser
)
;
if
(
current
=
=
=
notification
)
{
notification
.
remove
(
)
;
}
}
}
for
(
let
install
of
installs
)
{
install
.
addListener
(
{
onDownloadCancelled
:
maybeRemove
onDownloadFailed
:
maybeRemove
onInstallFailed
:
maybeRemove
onInstallEnded
:
maybeRemove
}
)
;
}
}
var
gXPInstallObserver
=
{
_findChildShell
(
aDocShell
aSoughtShell
)
{
if
(
aDocShell
=
=
aSoughtShell
)
{
return
aDocShell
;
}
var
node
=
aDocShell
.
QueryInterface
(
Ci
.
nsIDocShellTreeItem
)
;
for
(
var
i
=
0
;
i
<
node
.
childCount
;
+
+
i
)
{
var
docShell
=
node
.
getChildAt
(
i
)
;
docShell
=
this
.
_findChildShell
(
docShell
aSoughtShell
)
;
if
(
docShell
=
=
aSoughtShell
)
{
return
docShell
;
}
}
return
null
;
}
_getBrowser
(
aDocShell
)
{
for
(
let
browser
of
gBrowser
.
browsers
)
{
if
(
this
.
_findChildShell
(
browser
.
docShell
aDocShell
)
)
{
return
browser
;
}
}
return
null
;
}
pendingInstalls
:
new
WeakMap
(
)
showInstallConfirmation
(
browser
installInfo
height
=
undefined
)
{
if
(
PopupNotifications
.
getNotification
(
"
addon
-
install
-
confirmation
"
browser
)
)
{
let
pending
=
this
.
pendingInstalls
.
get
(
browser
)
;
if
(
pending
)
{
pending
.
push
(
installInfo
)
;
}
else
{
this
.
pendingInstalls
.
set
(
browser
[
installInfo
]
)
;
}
return
;
}
let
showNextConfirmation
=
(
)
=
>
{
if
(
!
gBrowser
.
browsers
.
includes
(
browser
)
)
{
return
;
}
let
pending
=
this
.
pendingInstalls
.
get
(
browser
)
;
if
(
pending
&
&
pending
.
length
)
{
this
.
showInstallConfirmation
(
browser
pending
.
shift
(
)
)
;
}
}
;
if
(
installInfo
.
installs
.
every
(
i
=
>
i
.
state
!
=
AddonManager
.
STATE_DOWNLOADED
)
)
{
showNextConfirmation
(
)
;
return
;
}
var
options
=
{
displayURI
:
installInfo
.
originatingURI
persistent
:
true
hideClose
:
true
popupOptions
:
{
position
:
"
bottomright
topright
"
}
}
;
let
acceptInstallation
=
(
)
=
>
{
for
(
let
install
of
installInfo
.
installs
)
{
install
.
install
(
)
;
}
installInfo
=
null
;
Services
.
telemetry
.
getHistogramById
(
"
SECURITY_UI
"
)
.
add
(
Ci
.
nsISecurityUITelemetry
.
WARNING_CONFIRM_ADDON_INSTALL_CLICK_THROUGH
)
;
}
;
let
cancelInstallation
=
(
)
=
>
{
if
(
installInfo
)
{
for
(
let
install
of
installInfo
.
installs
)
{
if
(
install
.
state
!
=
AddonManager
.
STATE_CANCELLED
)
{
install
.
cancel
(
)
;
}
}
}
showNextConfirmation
(
)
;
}
;
let
unsigned
=
installInfo
.
installs
.
filter
(
i
=
>
i
.
addon
.
signedState
<
=
AddonManager
.
SIGNEDSTATE_MISSING
)
;
let
someUnsigned
=
!
!
unsigned
.
length
&
&
unsigned
.
length
<
installInfo
.
installs
.
length
;
options
.
eventCallback
=
aEvent
=
>
{
switch
(
aEvent
)
{
case
"
removed
"
:
cancelInstallation
(
)
;
break
;
case
"
shown
"
:
let
addonList
=
document
.
getElementById
(
"
addon
-
install
-
confirmation
-
content
"
)
;
while
(
addonList
.
firstChild
)
{
addonList
.
firstChild
.
remove
(
)
;
}
for
(
let
install
of
installInfo
.
installs
)
{
let
container
=
document
.
createXULElement
(
"
hbox
"
)
;
let
name
=
document
.
createXULElement
(
"
label
"
)
;
name
.
setAttribute
(
"
value
"
install
.
addon
.
name
)
;
name
.
setAttribute
(
"
class
"
"
addon
-
install
-
confirmation
-
name
"
)
;
container
.
appendChild
(
name
)
;
if
(
someUnsigned
&
&
install
.
addon
.
signedState
<
=
AddonManager
.
SIGNEDSTATE_MISSING
)
{
let
unsignedLabel
=
document
.
createXULElement
(
"
label
"
)
;
unsignedLabel
.
setAttribute
(
"
value
"
gNavigatorBundle
.
getString
(
"
addonInstall
.
unsigned
"
)
)
;
unsignedLabel
.
setAttribute
(
"
class
"
"
addon
-
install
-
confirmation
-
unsigned
"
)
;
container
.
appendChild
(
unsignedLabel
)
;
}
addonList
.
appendChild
(
container
)
;
}
break
;
}
}
;
options
.
learnMoreURL
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
;
let
messageString
;
let
notification
=
document
.
getElementById
(
"
addon
-
install
-
confirmation
-
notification
"
)
;
if
(
unsigned
.
length
=
=
installInfo
.
installs
.
length
)
{
messageString
=
gNavigatorBundle
.
getString
(
"
addonConfirmInstallUnsigned
.
message
"
)
;
notification
.
setAttribute
(
"
warning
"
"
true
"
)
;
options
.
learnMoreURL
+
=
"
unsigned
-
addons
"
;
}
else
if
(
!
unsigned
.
length
)
{
messageString
=
gNavigatorBundle
.
getString
(
"
addonConfirmInstall
.
message
"
)
;
notification
.
removeAttribute
(
"
warning
"
)
;
options
.
learnMoreURL
+
=
"
find
-
and
-
install
-
add
-
ons
"
;
}
else
{
messageString
=
gNavigatorBundle
.
getString
(
"
addonConfirmInstallSomeUnsigned
.
message
"
)
;
notification
.
setAttribute
(
"
warning
"
"
true
"
)
;
options
.
learnMoreURL
+
=
"
unsigned
-
addons
"
;
}
let
brandBundle
=
document
.
getElementById
(
"
bundle_brand
"
)
;
let
brandShortName
=
brandBundle
.
getString
(
"
brandShortName
"
)
;
messageString
=
PluralForm
.
get
(
installInfo
.
installs
.
length
messageString
)
;
messageString
=
messageString
.
replace
(
"
#
1
"
brandShortName
)
;
messageString
=
messageString
.
replace
(
"
#
2
"
installInfo
.
installs
.
length
)
;
let
action
=
{
label
:
gNavigatorBundle
.
getString
(
"
addonInstall
.
acceptButton2
.
label
"
)
accessKey
:
gNavigatorBundle
.
getString
(
"
addonInstall
.
acceptButton2
.
accesskey
"
)
callback
:
acceptInstallation
}
;
let
secondaryAction
=
{
label
:
gNavigatorBundle
.
getString
(
"
addonInstall
.
cancelButton
.
label
"
)
accessKey
:
gNavigatorBundle
.
getString
(
"
addonInstall
.
cancelButton
.
accesskey
"
)
callback
:
(
)
=
>
{
}
}
;
if
(
height
)
{
notification
.
style
.
minHeight
=
height
+
"
px
"
;
}
let
tab
=
gBrowser
.
getTabForBrowser
(
browser
)
;
if
(
tab
)
{
gBrowser
.
selectedTab
=
tab
;
}
let
popup
=
PopupNotifications
.
show
(
browser
"
addon
-
install
-
confirmation
"
messageString
gUnifiedExtensions
.
getPopupAnchorID
(
browser
window
)
action
[
secondaryAction
]
options
)
;
removeNotificationOnEnd
(
popup
installInfo
.
installs
)
;
Services
.
telemetry
.
getHistogramById
(
"
SECURITY_UI
"
)
.
add
(
Ci
.
nsISecurityUITelemetry
.
WARNING_CONFIRM_ADDON_INSTALL
)
;
}
NOTIFICATION_IDS
:
[
"
addon
-
install
-
blocked
"
"
addon
-
install
-
confirmation
"
"
addon
-
install
-
failed
"
"
addon
-
install
-
origin
-
blocked
"
"
addon
-
install
-
webapi
-
blocked
"
"
addon
-
install
-
policy
-
blocked
"
"
addon
-
progress
"
"
addon
-
webext
-
permissions
"
"
xpinstall
-
disabled
"
]
removeAllNotifications
(
browser
)
{
let
notifications
=
this
.
NOTIFICATION_IDS
.
map
(
id
=
>
PopupNotifications
.
getNotification
(
id
browser
)
)
.
filter
(
notification
=
>
notification
!
=
null
)
;
PopupNotifications
.
remove
(
notifications
true
)
;
return
!
!
notifications
.
length
;
}
logWarningFullScreenInstallBlocked
(
)
{
let
consoleMsg
=
Cc
[
"
mozilla
.
org
/
scripterror
;
1
"
]
.
createInstance
(
Ci
.
nsIScriptError
)
;
let
message
=
gBrowserBundle
.
GetStringFromName
(
"
addonInstallFullScreenBlocked
"
)
;
consoleMsg
.
initWithWindowID
(
message
gBrowser
.
currentURI
.
spec
null
0
0
Ci
.
nsIScriptError
.
warningFlag
"
FullScreen
"
gBrowser
.
selectedBrowser
.
innerWindowID
)
;
Services
.
console
.
logMessage
(
consoleMsg
)
;
}
async
observe
(
aSubject
aTopic
aData
)
{
var
brandBundle
=
document
.
getElementById
(
"
bundle_brand
"
)
;
var
installInfo
=
aSubject
.
wrappedJSObject
;
var
browser
=
installInfo
.
browser
;
if
(
!
browser
|
|
!
gBrowser
.
browsers
.
includes
(
browser
)
)
{
return
;
}
var
messageString
action
;
var
brandShortName
=
brandBundle
.
getString
(
"
brandShortName
"
)
;
var
notificationID
=
aTopic
;
var
options
=
{
displayURI
:
installInfo
.
originatingURI
persistent
:
true
hideClose
:
true
timeout
:
Date
.
now
(
)
+
30000
popupOptions
:
{
position
:
"
bottomright
topright
"
}
}
;
switch
(
aTopic
)
{
case
"
addon
-
install
-
disabled
"
:
{
notificationID
=
"
xpinstall
-
disabled
"
;
let
secondaryActions
=
null
;
if
(
Services
.
prefs
.
prefIsLocked
(
"
xpinstall
.
enabled
"
)
)
{
messageString
=
gNavigatorBundle
.
getString
(
"
xpinstallDisabledMessageLocked
"
)
;
}
else
{
messageString
=
gNavigatorBundle
.
getString
(
"
xpinstallDisabledMessage
"
)
;
action
=
{
label
:
gNavigatorBundle
.
getString
(
"
xpinstallDisabledButton
"
)
accessKey
:
gNavigatorBundle
.
getString
(
"
xpinstallDisabledButton
.
accesskey
"
)
callback
:
function
editPrefs
(
)
{
Services
.
prefs
.
setBoolPref
(
"
xpinstall
.
enabled
"
true
)
;
}
}
;
secondaryActions
=
[
{
label
:
gNavigatorBundle
.
getString
(
"
addonInstall
.
cancelButton
.
label
"
)
accessKey
:
gNavigatorBundle
.
getString
(
"
addonInstall
.
cancelButton
.
accesskey
"
)
callback
:
(
)
=
>
{
}
}
]
;
}
PopupNotifications
.
show
(
browser
notificationID
messageString
gUnifiedExtensions
.
getPopupAnchorID
(
browser
window
)
action
secondaryActions
options
)
;
break
;
}
case
"
addon
-
install
-
fullscreen
-
blocked
"
:
{
this
.
logWarningFullScreenInstallBlocked
(
)
;
break
;
}
case
"
addon
-
install
-
webapi
-
blocked
"
:
case
"
addon
-
install
-
policy
-
blocked
"
:
case
"
addon
-
install
-
origin
-
blocked
"
:
{
if
(
aTopic
=
=
"
addon
-
install
-
policy
-
blocked
"
)
{
messageString
=
gNavigatorBundle
.
getString
(
"
addonDomainBlockedByPolicy
"
)
;
}
else
{
messageString
=
gNavigatorBundle
.
getFormattedString
(
"
xpinstallPromptMessage
"
[
brandShortName
]
)
;
}
if
(
Services
.
policies
)
{
let
extensionSettings
=
Services
.
policies
.
getExtensionSettings
(
"
*
"
)
;
if
(
extensionSettings
&
&
"
blocked_install_message
"
in
extensionSettings
)
{
messageString
+
=
"
"
+
extensionSettings
.
blocked_install_message
;
}
}
options
.
removeOnDismissal
=
true
;
options
.
persistent
=
false
;
let
secHistogram
=
Services
.
telemetry
.
getHistogramById
(
"
SECURITY_UI
"
)
;
secHistogram
.
add
(
Ci
.
nsISecurityUITelemetry
.
WARNING_ADDON_ASKING_PREVENTED
)
;
let
popup
=
PopupNotifications
.
show
(
browser
notificationID
messageString
gUnifiedExtensions
.
getPopupAnchorID
(
browser
window
)
null
null
options
)
;
removeNotificationOnEnd
(
popup
installInfo
.
installs
)
;
break
;
}
case
"
addon
-
install
-
blocked
"
:
{
await
window
.
ensureCustomElements
(
"
moz
-
support
-
link
"
)
;
let
progressNotification
=
PopupNotifications
.
getNotification
(
"
addon
-
progress
"
browser
)
;
if
(
progressNotification
)
{
progressNotification
.
remove
(
)
;
}
let
isSitePermissionAddon
=
installInfo
.
installs
.
every
(
(
{
addon
}
)
=
>
addon
?
.
type
=
=
=
lazy
.
SITEPERMS_ADDON_TYPE
)
;
let
hasHost
=
!
!
options
.
displayURI
;
if
(
isSitePermissionAddon
)
{
messageString
=
gNavigatorBundle
.
getString
(
"
sitePermissionInstallFirstPrompt
.
midi
.
header
"
)
;
}
else
if
(
hasHost
)
{
messageString
=
gNavigatorBundle
.
getFormattedString
(
"
xpinstallPromptMessage
.
header
"
[
"
<
>
"
]
)
;
options
.
name
=
options
.
displayURI
.
displayHost
;
}
else
{
messageString
=
gNavigatorBundle
.
getString
(
"
xpinstallPromptMessage
.
header
.
unknown
"
)
;
}
let
displayURI
=
options
.
displayURI
;
options
.
displayURI
=
undefined
;
options
.
eventCallback
=
topic
=
>
{
if
(
topic
!
=
=
"
showing
"
)
{
return
;
}
let
doc
=
browser
.
ownerDocument
;
let
message
=
doc
.
getElementById
(
"
addon
-
install
-
blocked
-
message
"
)
;
while
(
message
.
firstChild
)
{
message
.
firstChild
.
remove
(
)
;
}
if
(
isSitePermissionAddon
)
{
message
.
textContent
=
gNavigatorBundle
.
getString
(
"
sitePermissionInstallFirstPrompt
.
midi
.
message
"
)
;
}
else
if
(
hasHost
)
{
let
text
=
gNavigatorBundle
.
getString
(
"
xpinstallPromptMessage
.
message
"
)
;
let
b
=
doc
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
"
b
"
)
;
b
.
textContent
=
options
.
name
;
let
fragment
=
BrowserUIUtils
.
getLocalizedFragment
(
doc
text
b
)
;
message
.
appendChild
(
fragment
)
;
}
else
{
message
.
textContent
=
gNavigatorBundle
.
getString
(
"
xpinstallPromptMessage
.
message
.
unknown
"
)
;
}
let
article
=
isSitePermissionAddon
?
"
site
-
permission
-
addons
"
:
"
unlisted
-
extensions
-
risks
"
;
let
learnMore
=
doc
.
getElementById
(
"
addon
-
install
-
blocked
-
info
"
)
;
learnMore
.
setAttribute
(
"
support
-
page
"
article
)
;
}
;
let
secHistogram
=
Services
.
telemetry
.
getHistogramById
(
"
SECURITY_UI
"
)
;
action
=
{
label
:
gNavigatorBundle
.
getString
(
"
xpinstallPromptMessage
.
install
"
)
accessKey
:
gNavigatorBundle
.
getString
(
"
xpinstallPromptMessage
.
install
.
accesskey
"
)
callback
(
)
{
secHistogram
.
add
(
Ci
.
nsISecurityUITelemetry
.
WARNING_ADDON_ASKING_PREVENTED_CLICK_THROUGH
)
;
installInfo
.
install
(
)
;
}
}
;
let
dontAllowAction
=
{
label
:
gNavigatorBundle
.
getString
(
"
xpinstallPromptMessage
.
dontAllow
"
)
accessKey
:
gNavigatorBundle
.
getString
(
"
xpinstallPromptMessage
.
dontAllow
.
accesskey
"
)
callback
:
(
)
=
>
{
for
(
let
install
of
installInfo
.
installs
)
{
if
(
install
.
state
!
=
AddonManager
.
STATE_CANCELLED
)
{
install
.
cancel
(
)
;
}
}
if
(
installInfo
.
cancel
)
{
installInfo
.
cancel
(
)
;
}
}
}
;
let
neverAllowCallback
=
(
)
=
>
{
SitePermissions
.
setForPrincipal
(
browser
.
contentPrincipal
"
install
"
SitePermissions
.
BLOCK
)
;
for
(
let
install
of
installInfo
.
installs
)
{
if
(
install
.
state
!
=
AddonManager
.
STATE_CANCELLED
)
{
install
.
cancel
(
)
;
}
}
if
(
installInfo
.
cancel
)
{
installInfo
.
cancel
(
)
;
}
}
;
let
neverAllowAction
=
{
label
:
gNavigatorBundle
.
getString
(
"
xpinstallPromptMessage
.
neverAllow
"
)
accessKey
:
gNavigatorBundle
.
getString
(
"
xpinstallPromptMessage
.
neverAllow
.
accesskey
"
)
callback
:
neverAllowCallback
}
;
let
neverAllowAndReportAction
=
{
label
:
gNavigatorBundle
.
getString
(
"
xpinstallPromptMessage
.
neverAllowAndReport
"
)
accessKey
:
gNavigatorBundle
.
getString
(
"
xpinstallPromptMessage
.
neverAllowAndReport
.
accesskey
"
)
callback
:
(
)
=
>
{
AMTelemetry
.
recordEvent
(
{
method
:
"
reportSuspiciousSite
"
object
:
"
suspiciousSite
"
value
:
displayURI
?
.
displayHost
?
?
"
(
unknown
)
"
extra
:
{
}
}
)
;
neverAllowCallback
(
)
;
}
}
;
secHistogram
.
add
(
Ci
.
nsISecurityUITelemetry
.
WARNING_ADDON_ASKING_PREVENTED
)
;
let
declineActions
=
[
dontAllowAction
neverAllowAction
]
;
if
(
isSitePermissionAddon
)
{
declineActions
.
push
(
neverAllowAndReportAction
)
;
}
let
popup
=
PopupNotifications
.
show
(
browser
notificationID
messageString
gUnifiedExtensions
.
getPopupAnchorID
(
browser
window
)
action
declineActions
options
)
;
removeNotificationOnEnd
(
popup
installInfo
.
installs
)
;
break
;
}
case
"
addon
-
install
-
started
"
:
{
let
needsDownload
=
function
needsDownload
(
aInstall
)
{
return
aInstall
.
state
!
=
AddonManager
.
STATE_DOWNLOADED
;
}
;
if
(
!
installInfo
.
installs
.
some
(
needsDownload
)
)
{
return
;
}
notificationID
=
"
addon
-
progress
"
;
messageString
=
gNavigatorBundle
.
getString
(
"
addonDownloadingAndVerifying
"
)
;
messageString
=
PluralForm
.
get
(
installInfo
.
installs
.
length
messageString
)
;
messageString
=
messageString
.
replace
(
"
#
1
"
installInfo
.
installs
.
length
)
;
options
.
installs
=
installInfo
.
installs
;
options
.
contentWindow
=
browser
.
contentWindow
;
options
.
sourceURI
=
browser
.
currentURI
;
options
.
eventCallback
=
function
(
aEvent
)
{
switch
(
aEvent
)
{
case
"
removed
"
:
options
.
contentWindow
=
null
;
options
.
sourceURI
=
null
;
break
;
}
}
;
action
=
{
label
:
gNavigatorBundle
.
getString
(
"
addonInstall
.
acceptButton2
.
label
"
)
accessKey
:
gNavigatorBundle
.
getString
(
"
addonInstall
.
acceptButton2
.
accesskey
"
)
disabled
:
true
callback
:
(
)
=
>
{
}
}
;
let
secondaryAction
=
{
label
:
gNavigatorBundle
.
getString
(
"
addonInstall
.
cancelButton
.
label
"
)
accessKey
:
gNavigatorBundle
.
getString
(
"
addonInstall
.
cancelButton
.
accesskey
"
)
callback
:
(
)
=
>
{
for
(
let
install
of
installInfo
.
installs
)
{
if
(
install
.
state
!
=
AddonManager
.
STATE_CANCELLED
)
{
install
.
cancel
(
)
;
}
}
}
}
;
let
notification
=
PopupNotifications
.
show
(
browser
notificationID
messageString
gUnifiedExtensions
.
getPopupAnchorID
(
browser
window
)
action
[
secondaryAction
]
options
)
;
notification
.
_startTime
=
Date
.
now
(
)
;
break
;
}
case
"
addon
-
install
-
failed
"
:
{
options
.
removeOnDismissal
=
true
;
options
.
persistent
=
false
;
for
(
let
install
of
installInfo
.
installs
)
{
let
host
;
try
{
host
=
options
.
displayURI
.
host
;
}
catch
(
e
)
{
}
if
(
!
host
)
{
host
=
install
.
sourceURI
instanceof
Ci
.
nsIStandardURL
&
&
install
.
sourceURI
.
host
;
}
let
error
=
host
|
|
install
.
error
=
=
0
?
"
addonInstallError
"
:
"
addonLocalInstallError
"
;
let
args
;
if
(
install
.
error
<
0
)
{
error
+
=
install
.
error
;
args
=
[
brandShortName
install
.
name
]
;
}
else
if
(
install
.
addon
.
blocklistState
=
=
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
)
{
error
+
=
"
Blocklisted
"
;
args
=
[
install
.
name
]
;
}
else
{
error
+
=
"
Incompatible
"
;
args
=
[
brandShortName
Services
.
appinfo
.
version
install
.
name
]
;
}
if
(
install
.
addon
&
&
!
Services
.
policies
.
mayInstallAddon
(
install
.
addon
)
)
{
error
=
"
addonInstallBlockedByPolicy
"
;
let
extensionSettings
=
Services
.
policies
.
getExtensionSettings
(
install
.
addon
.
id
)
;
let
message
=
"
"
;
if
(
extensionSettings
&
&
"
blocked_install_message
"
in
extensionSettings
)
{
message
=
"
"
+
extensionSettings
.
blocked_install_message
;
}
args
=
[
install
.
name
install
.
addon
.
id
message
]
;
}
if
(
install
.
error
=
=
AddonManager
.
ERROR_SIGNEDSTATE_REQUIRED
)
{
options
.
learnMoreURL
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
+
"
unsigned
-
addons
"
;
}
messageString
=
gNavigatorBundle
.
getFormattedString
(
error
args
)
;
PopupNotifications
.
show
(
browser
notificationID
messageString
gUnifiedExtensions
.
getPopupAnchorID
(
browser
window
)
action
null
options
)
;
break
;
}
this
.
_removeProgressNotification
(
browser
)
;
break
;
}
case
"
addon
-
install
-
confirmation
"
:
{
let
showNotification
=
(
)
=
>
{
let
height
=
undefined
;
if
(
PopupNotifications
.
isPanelOpen
)
{
let
rect
=
document
.
getElementById
(
"
addon
-
progress
-
notification
"
)
.
getBoundingClientRect
(
)
;
height
=
rect
.
height
;
}
this
.
_removeProgressNotification
(
browser
)
;
this
.
showInstallConfirmation
(
browser
installInfo
height
)
;
}
;
let
progressNotification
=
PopupNotifications
.
getNotification
(
"
addon
-
progress
"
browser
)
;
if
(
progressNotification
)
{
let
downloadDuration
=
Date
.
now
(
)
-
progressNotification
.
_startTime
;
let
securityDelay
=
Services
.
prefs
.
getIntPref
(
"
security
.
dialog_enable_delay
"
)
-
downloadDuration
;
if
(
securityDelay
>
0
)
{
setTimeout
(
(
)
=
>
{
if
(
PopupNotifications
.
getNotification
(
"
addon
-
progress
"
browser
)
)
{
showNotification
(
)
;
}
}
securityDelay
)
;
break
;
}
}
showNotification
(
)
;
break
;
}
}
}
_removeProgressNotification
(
aBrowser
)
{
let
notification
=
PopupNotifications
.
getNotification
(
"
addon
-
progress
"
aBrowser
)
;
if
(
notification
)
{
notification
.
remove
(
)
;
}
}
}
;
var
gExtensionsNotifications
=
{
initialized
:
false
init
(
)
{
this
.
updateAlerts
(
)
;
this
.
boundUpdate
=
this
.
updateAlerts
.
bind
(
this
)
;
ExtensionsUI
.
on
(
"
change
"
this
.
boundUpdate
)
;
this
.
initialized
=
true
;
}
uninit
(
)
{
if
(
!
this
.
initialized
)
{
return
;
}
ExtensionsUI
.
off
(
"
change
"
this
.
boundUpdate
)
;
}
_createAddonButton
(
text
icon
callback
)
{
let
button
=
document
.
createXULElement
(
"
toolbarbutton
"
)
;
button
.
setAttribute
(
"
wrap
"
"
true
"
)
;
button
.
setAttribute
(
"
label
"
text
)
;
button
.
setAttribute
(
"
tooltiptext
"
text
)
;
const
DEFAULT_EXTENSION_ICON
=
"
chrome
:
/
/
mozapps
/
skin
/
extensions
/
extensionGeneric
.
svg
"
;
button
.
setAttribute
(
"
image
"
icon
|
|
DEFAULT_EXTENSION_ICON
)
;
button
.
className
=
"
addon
-
banner
-
item
subviewbutton
"
;
button
.
addEventListener
(
"
command
"
callback
)
;
PanelUI
.
addonNotificationContainer
.
appendChild
(
button
)
;
}
updateAlerts
(
)
{
let
sideloaded
=
ExtensionsUI
.
sideloaded
;
let
updates
=
ExtensionsUI
.
updates
;
let
container
=
PanelUI
.
addonNotificationContainer
;
while
(
container
.
firstChild
)
{
container
.
firstChild
.
remove
(
)
;
}
let
items
=
0
;
for
(
let
update
of
updates
)
{
if
(
+
+
items
>
4
)
{
break
;
}
let
text
=
gNavigatorBundle
.
getFormattedString
(
"
webextPerms
.
updateMenuItem
"
[
update
.
addon
.
name
]
)
;
this
.
_createAddonButton
(
text
update
.
addon
.
iconURL
evt
=
>
{
ExtensionsUI
.
showUpdate
(
gBrowser
update
)
;
}
)
;
}
let
appName
;
for
(
let
addon
of
sideloaded
)
{
if
(
+
+
items
>
4
)
{
break
;
}
if
(
!
appName
)
{
let
brandBundle
=
document
.
getElementById
(
"
bundle_brand
"
)
;
appName
=
brandBundle
.
getString
(
"
brandShortName
"
)
;
}
let
text
=
gNavigatorBundle
.
getFormattedString
(
"
webextPerms
.
sideloadMenuItem
"
[
addon
.
name
appName
]
)
;
this
.
_createAddonButton
(
text
addon
.
iconURL
evt
=
>
{
PanelUI
.
hide
(
)
;
ExtensionsUI
.
showSideloaded
(
gBrowser
addon
)
;
}
)
;
}
}
}
;
var
BrowserAddonUI
=
{
async
promptRemoveExtension
(
addon
)
{
let
{
name
}
=
addon
;
let
title
=
await
document
.
l10n
.
formatValue
(
"
addon
-
removal
-
title
"
{
name
}
)
;
let
{
getFormattedString
getString
}
=
gNavigatorBundle
;
let
btnTitle
=
getString
(
"
webext
.
remove
.
confirmation
.
button
"
)
;
let
{
BUTTON_TITLE_IS_STRING
:
titleString
BUTTON_TITLE_CANCEL
:
titleCancel
BUTTON_POS_0
BUTTON_POS_1
confirmEx
}
=
Services
.
prompt
;
let
btnFlags
=
BUTTON_POS_0
*
titleString
+
BUTTON_POS_1
*
titleCancel
;
let
checkboxState
=
{
value
:
false
}
;
let
checkboxMessage
=
null
;
if
(
gAddonAbuseReportEnabled
&
&
[
"
extension
"
"
theme
"
]
.
includes
(
addon
.
type
)
)
{
checkboxMessage
=
await
document
.
l10n
.
formatValue
(
"
addon
-
removal
-
abuse
-
report
-
checkbox
"
)
;
}
let
message
=
null
;
if
(
!
Services
.
prefs
.
getBoolPref
(
"
prompts
.
windowPromptSubDialog
"
false
)
)
{
message
=
getFormattedString
(
"
webext
.
remove
.
confirmation
.
message
"
[
name
document
.
getElementById
(
"
bundle_brand
"
)
.
getString
(
"
brandShorterName
"
)
]
)
;
}
let
result
=
confirmEx
(
window
title
message
btnFlags
btnTitle
null
null
checkboxMessage
checkboxState
)
;
return
{
remove
:
result
=
=
=
0
report
:
checkboxState
.
value
}
;
}
async
reportAddon
(
addonId
reportEntryPoint
)
{
let
addon
=
addonId
&
&
(
await
AddonManager
.
getAddonByID
(
addonId
)
)
;
if
(
!
addon
)
{
return
;
}
const
win
=
await
BrowserOpenAddonsMgr
(
"
addons
:
/
/
list
/
extension
"
)
;
win
.
openAbuseReport
(
{
addonId
reportEntryPoint
}
)
;
}
async
removeAddon
(
addonId
eventObject
)
{
let
addon
=
addonId
&
&
(
await
AddonManager
.
getAddonByID
(
addonId
)
)
;
if
(
!
addon
|
|
!
(
addon
.
permissions
&
AddonManager
.
PERM_CAN_UNINSTALL
)
)
{
return
;
}
let
{
remove
report
}
=
await
this
.
promptRemoveExtension
(
addon
)
;
if
(
remove
)
{
await
addon
.
uninstall
(
report
)
;
if
(
report
)
{
await
this
.
reportAddon
(
addon
.
id
"
uninstall
"
)
;
}
}
}
async
manageAddon
(
addonId
eventObject
)
{
let
addon
=
addonId
&
&
(
await
AddonManager
.
getAddonByID
(
addonId
)
)
;
if
(
!
addon
)
{
return
;
}
BrowserOpenAddonsMgr
(
"
addons
:
/
/
detail
/
"
+
encodeURIComponent
(
addon
.
id
)
)
;
}
}
;
var
gUnifiedExtensions
=
{
_initialized
:
false
MESSAGE_DECK_INDEX_DEFAULT
:
0
MESSAGE_DECK_INDEX_HOVER
:
1
MESSAGE_DECK_INDEX_MENU_HOVER
:
2
init
(
)
{
if
(
this
.
_initialized
)
{
return
;
}
this
.
_button
=
document
.
getElementById
(
"
unified
-
extensions
-
button
"
)
;
this
.
_button
.
hidden
=
false
;
document
.
getElementById
(
"
nav
-
bar
"
)
.
setAttribute
(
"
unifiedextensionsbuttonshown
"
true
)
;
gBrowser
.
addTabsProgressListener
(
this
)
;
window
.
addEventListener
(
"
TabSelect
"
(
)
=
>
this
.
updateAttention
(
)
)
;
window
.
addEventListener
(
"
toolbarvisibilitychange
"
this
)
;
this
.
permListener
=
(
)
=
>
this
.
updateAttention
(
)
;
lazy
.
ExtensionPermissions
.
addListener
(
this
.
permListener
)
;
gNavToolbox
.
addEventListener
(
"
customizationstarting
"
this
)
;
CustomizableUI
.
addListener
(
this
)
;
this
.
_initialized
=
true
;
}
uninit
(
)
{
if
(
!
this
.
_initialized
)
{
return
;
}
window
.
removeEventListener
(
"
toolbarvisibilitychange
"
this
)
;
lazy
.
ExtensionPermissions
.
removeListener
(
this
.
permListener
)
;
this
.
permListener
=
null
;
gNavToolbox
.
removeEventListener
(
"
customizationstarting
"
this
)
;
CustomizableUI
.
removeListener
(
this
)
;
}
onLocationChange
(
browser
webProgress
_request
_uri
flags
)
{
if
(
webProgress
.
isTopLevel
&
&
browser
=
=
=
gBrowser
.
selectedBrowser
&
&
!
(
flags
&
Ci
.
nsIWebProgressListener
.
LOCATION_CHANGE_SAME_DOCUMENT
)
)
{
this
.
updateAttention
(
)
;
}
}
updateAttention
(
)
{
let
attention
=
false
;
for
(
let
policy
of
this
.
getActivePolicies
(
)
)
{
let
widget
=
this
.
browserActionFor
(
policy
)
?
.
widget
;
if
(
!
widget
|
|
widget
.
areaType
!
=
=
CustomizableUI
.
TYPE_TOOLBAR
)
{
if
(
lazy
.
OriginControls
.
getAttention
(
policy
window
)
)
{
attention
=
true
;
break
;
}
}
}
this
.
button
.
toggleAttribute
(
"
attention
"
attention
)
;
this
.
button
.
ownerDocument
.
l10n
.
setAttributes
(
this
.
button
attention
?
"
unified
-
extensions
-
button
-
permissions
-
needed
"
:
"
unified
-
extensions
-
button
"
)
;
}
getPopupAnchorID
(
aBrowser
aWindow
)
{
const
anchorID
=
"
unified
-
extensions
-
button
"
;
const
attr
=
anchorID
+
"
popupnotificationanchor
"
;
if
(
!
aBrowser
[
attr
]
)
{
aBrowser
[
attr
]
=
aWindow
.
document
.
getElementById
(
anchorID
)
.
firstElementChild
;
}
return
anchorID
;
}
get
button
(
)
{
return
this
.
_button
;
}
getActivePolicies
(
all
=
true
)
{
let
policies
=
WebExtensionPolicy
.
getActiveExtensions
(
)
;
policies
=
policies
.
filter
(
policy
=
>
{
let
{
extension
}
=
policy
;
if
(
!
policy
.
active
|
|
extension
?
.
type
!
=
=
"
extension
"
)
{
return
false
;
}
if
(
extension
.
isHidden
|
|
!
policy
.
canAccessWindow
(
window
)
)
{
return
false
;
}
return
all
|
|
!
extension
.
hasBrowserActionUI
;
}
)
;
policies
.
sort
(
(
a
b
)
=
>
a
.
name
.
localeCompare
(
b
.
name
)
)
;
return
policies
;
}
hasExtensionsInPanel
(
)
{
const
policies
=
this
.
getActivePolicies
(
)
;
return
!
!
policies
.
map
(
policy
=
>
this
.
browserActionFor
(
policy
)
?
.
widget
)
.
filter
(
widget
=
>
{
return
(
!
widget
|
|
widget
?
.
areaType
!
=
=
CustomizableUI
.
TYPE_TOOLBAR
|
|
widget
?
.
forWindow
(
window
)
.
overflowed
)
;
}
)
.
length
;
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
ViewShowing
"
:
this
.
onPanelViewShowing
(
event
.
target
)
;
break
;
case
"
ViewHiding
"
:
this
.
onPanelViewHiding
(
event
.
target
)
;
break
;
case
"
customizationstarting
"
:
this
.
panel
.
hidePopup
(
)
;
break
;
case
"
toolbarvisibilitychange
"
:
this
.
onToolbarVisibilityChange
(
event
.
target
.
id
event
.
detail
.
visible
)
;
break
;
}
}
onPanelViewShowing
(
panelview
)
{
const
list
=
panelview
.
querySelector
(
"
.
unified
-
extensions
-
list
"
)
;
const
policies
=
this
.
getActivePolicies
(
false
)
;
for
(
const
policy
of
policies
)
{
const
item
=
document
.
createElement
(
"
unified
-
extensions
-
item
"
)
;
item
.
setExtension
(
policy
.
extension
)
;
list
.
appendChild
(
item
)
;
}
}
onPanelViewHiding
(
panelview
)
{
if
(
window
.
closed
)
{
return
;
}
const
list
=
panelview
.
querySelector
(
"
.
unified
-
extensions
-
list
"
)
;
while
(
list
.
lastChild
)
{
list
.
lastChild
.
remove
(
)
;
}
requestAnimationFrame
(
(
)
=
>
this
.
updateAttention
(
)
)
;
}
onToolbarVisibilityChange
(
toolbarId
isVisible
)
{
let
widgetIDs
;
try
{
widgetIDs
=
CustomizableUI
.
getWidgetIdsInArea
(
toolbarId
)
.
filter
(
CustomizableUI
.
isWebExtensionWidget
)
;
}
catch
{
return
;
}
const
overflowedExtensionsList
=
this
.
panel
.
querySelector
(
"
#
overflowed
-
extensions
-
list
"
)
;
for
(
const
widgetID
of
widgetIDs
)
{
const
widget
=
CustomizableUI
.
getWidget
(
widgetID
)
;
if
(
!
widget
)
{
continue
;
}
if
(
isVisible
)
{
this
.
_maybeMoveWidgetNodeBack
(
widget
.
id
)
;
}
else
{
const
{
node
}
=
widget
.
forWindow
(
window
)
;
node
.
setAttribute
(
"
overflowedItem
"
true
)
;
node
.
setAttribute
(
"
artificallyOverflowed
"
true
)
;
node
.
setAttribute
(
"
cui
-
anchorid
"
"
unified
-
extensions
-
button
"
)
;
overflowedExtensionsList
.
appendChild
(
node
)
;
this
.
_updateWidgetClassName
(
widgetID
true
)
;
}
}
}
_maybeMoveWidgetNodeBack
(
widgetID
)
{
const
widget
=
CustomizableUI
.
getWidget
(
widgetID
)
;
if
(
!
widget
)
{
return
;
}
const
{
node
}
=
widget
.
forWindow
(
window
)
;
if
(
!
node
.
hasAttribute
(
"
artificallyOverflowed
"
)
)
{
return
;
}
const
{
area
position
}
=
CustomizableUI
.
getPlacementOfWidget
(
widgetID
)
;
const
container
=
document
.
getElementById
(
area
)
;
let
moved
=
false
;
let
currentPosition
=
0
;
for
(
const
child
of
container
.
childNodes
)
{
const
isSkipToolbarset
=
child
.
getAttribute
(
"
skipintoolbarset
"
)
=
=
"
true
"
;
if
(
isSkipToolbarset
&
&
child
!
=
=
container
.
lastChild
)
{
continue
;
}
if
(
currentPosition
=
=
=
position
)
{
child
.
before
(
node
)
;
moved
=
true
;
break
;
}
if
(
child
=
=
=
container
.
lastChild
)
{
child
.
after
(
node
)
;
moved
=
true
;
break
;
}
currentPosition
+
+
;
}
if
(
moved
)
{
node
.
removeAttribute
(
"
overflowedItem
"
)
;
node
.
removeAttribute
(
"
artificallyOverflowed
"
)
;
node
.
removeAttribute
(
"
cui
-
anchorid
"
)
;
this
.
_updateWidgetClassName
(
widgetID
false
)
;
}
}
_panel
:
null
get
panel
(
)
{
if
(
!
this
.
_panel
)
{
let
template
=
document
.
getElementById
(
"
unified
-
extensions
-
panel
-
template
"
)
;
template
.
replaceWith
(
template
.
content
)
;
this
.
_panel
=
document
.
getElementById
(
"
unified
-
extensions
-
panel
"
)
;
let
customizationArea
=
this
.
_panel
.
querySelector
(
"
#
unified
-
extensions
-
area
"
)
;
CustomizableUI
.
registerPanelNode
(
customizationArea
CustomizableUI
.
AREA_ADDONS
)
;
CustomizableUI
.
addPanelCloseListeners
(
this
.
_panel
)
;
document
.
getElementById
(
"
unified
-
extensions
-
context
-
menu
"
)
.
querySelectorAll
(
"
[
data
-
lazy
-
l10n
-
id
]
"
)
.
forEach
(
el
=
>
{
el
.
setAttribute
(
"
data
-
l10n
-
id
"
el
.
getAttribute
(
"
data
-
lazy
-
l10n
-
id
"
)
)
;
el
.
removeAttribute
(
"
data
-
lazy
-
l10n
-
id
"
)
;
}
)
;
}
return
this
.
_panel
;
}
async
togglePanel
(
aEvent
)
{
if
(
!
CustomizationHandler
.
isCustomizing
(
)
)
{
if
(
aEvent
)
{
if
(
(
aEvent
.
type
=
=
"
mousedown
"
&
&
(
aEvent
.
button
!
=
=
0
|
|
(
AppConstants
.
platform
=
=
=
"
macosx
"
&
&
aEvent
.
ctrlKey
)
)
)
|
|
(
aEvent
.
type
=
=
=
"
keypress
"
&
&
aEvent
.
charCode
!
=
=
KeyEvent
.
DOM_VK_SPACE
&
&
aEvent
.
keyCode
!
=
=
KeyEvent
.
DOM_VK_RETURN
)
)
{
return
;
}
if
(
!
this
.
hasExtensionsInPanel
(
)
)
{
let
viewID
;
if
(
Services
.
prefs
.
getBoolPref
(
"
extensions
.
getAddons
.
showPane
"
true
)
)
{
viewID
=
"
addons
:
/
/
discover
/
"
;
}
else
{
viewID
=
"
addons
:
/
/
list
/
extension
"
;
}
await
BrowserOpenAddonsMgr
(
viewID
)
;
return
;
}
}
let
panel
=
this
.
panel
;
if
(
!
this
.
_listView
)
{
this
.
_listView
=
PanelMultiView
.
getViewNode
(
document
"
unified
-
extensions
-
view
"
)
;
this
.
_listView
.
addEventListener
(
"
ViewShowing
"
this
)
;
this
.
_listView
.
addEventListener
(
"
ViewHiding
"
this
)
;
}
if
(
this
.
_button
.
open
)
{
PanelMultiView
.
hidePopup
(
panel
)
;
this
.
_button
.
open
=
false
;
}
else
{
for
(
const
toolbarId
of
CustomizableUI
.
getCollapsedToolbarIds
(
window
)
)
{
this
.
onToolbarVisibilityChange
(
toolbarId
false
)
;
}
panel
.
hidden
=
false
;
PanelMultiView
.
openPopup
(
panel
this
.
_button
{
position
:
"
bottomright
topright
"
triggerEvent
:
aEvent
}
)
;
}
}
window
.
dispatchEvent
(
new
CustomEvent
(
"
UnifiedExtensionsTogglePanel
"
)
)
;
}
updateContextMenu
(
menu
event
)
{
if
(
event
.
target
.
id
!
=
=
"
unified
-
extensions
-
context
-
menu
"
)
{
return
;
}
const
id
=
this
.
_getExtensionId
(
menu
)
;
const
widgetId
=
this
.
_getWidgetId
(
menu
)
;
const
forBrowserAction
=
!
!
widgetId
;
const
pinButton
=
menu
.
querySelector
(
"
.
unified
-
extensions
-
context
-
menu
-
pin
-
to
-
toolbar
"
)
;
const
removeButton
=
menu
.
querySelector
(
"
.
unified
-
extensions
-
context
-
menu
-
remove
-
extension
"
)
;
const
reportButton
=
menu
.
querySelector
(
"
.
unified
-
extensions
-
context
-
menu
-
report
-
extension
"
)
;
const
menuSeparator
=
menu
.
querySelector
(
"
.
unified
-
extensions
-
context
-
menu
-
management
-
separator
"
)
;
const
moveUp
=
menu
.
querySelector
(
"
.
unified
-
extensions
-
context
-
menu
-
move
-
widget
-
up
"
)
;
const
moveDown
=
menu
.
querySelector
(
"
.
unified
-
extensions
-
context
-
menu
-
move
-
widget
-
down
"
)
;
for
(
const
element
of
[
menuSeparator
pinButton
moveUp
moveDown
]
)
{
element
.
hidden
=
!
forBrowserAction
;
}
reportButton
.
hidden
=
!
gAddonAbuseReportEnabled
;
AddonManager
.
getAddonByID
(
id
)
.
then
(
addon
=
>
{
removeButton
.
disabled
=
!
(
addon
.
permissions
&
AddonManager
.
PERM_CAN_UNINSTALL
)
;
}
)
;
if
(
forBrowserAction
)
{
let
area
=
CustomizableUI
.
getPlacementOfWidget
(
widgetId
)
.
area
;
let
inToolbar
=
area
!
=
CustomizableUI
.
AREA_ADDONS
;
pinButton
.
setAttribute
(
"
checked
"
inToolbar
)
;
const
placement
=
CustomizableUI
.
getPlacementOfWidget
(
widgetId
)
;
const
notInPanel
=
placement
?
.
area
!
=
=
CustomizableUI
.
AREA_ADDONS
;
if
(
notInPanel
|
|
document
.
querySelector
(
"
#
unified
-
extensions
-
area
>
:
first
-
child
"
)
?
.
id
=
=
=
widgetId
)
{
moveUp
.
hidden
=
true
;
}
if
(
notInPanel
|
|
document
.
querySelector
(
"
#
unified
-
extensions
-
area
>
:
last
-
child
"
)
?
.
id
=
=
=
widgetId
)
{
moveDown
.
hidden
=
true
;
}
}
ExtensionsUI
.
originControlsMenu
(
menu
id
)
;
const
browserAction
=
this
.
browserActionFor
(
WebExtensionPolicy
.
getByID
(
id
)
)
;
if
(
browserAction
)
{
browserAction
.
updateContextMenu
(
menu
)
;
}
}
onContextMenuCommand
(
menu
event
)
{
const
{
classList
}
=
event
.
target
;
if
(
classList
.
contains
(
"
unified
-
extensions
-
context
-
menu
-
move
-
widget
-
up
"
)
|
|
classList
.
contains
(
"
unified
-
extensions
-
context
-
menu
-
move
-
widget
-
down
"
)
)
{
return
;
}
this
.
togglePanel
(
)
;
}
browserActionFor
(
policy
)
{
let
method
=
lazy
.
ExtensionParent
.
apiManager
.
global
.
browserActionFor
;
return
method
?
.
(
policy
?
.
extension
)
;
}
async
manageExtension
(
menu
)
{
const
id
=
this
.
_getExtensionId
(
menu
)
;
await
BrowserAddonUI
.
manageAddon
(
id
"
unifiedExtensions
"
)
;
}
async
removeExtension
(
menu
)
{
const
id
=
this
.
_getExtensionId
(
menu
)
;
await
BrowserAddonUI
.
removeAddon
(
id
"
unifiedExtensions
"
)
;
}
async
reportExtension
(
menu
)
{
const
id
=
this
.
_getExtensionId
(
menu
)
;
await
BrowserAddonUI
.
reportAddon
(
id
"
unified_context_menu
"
)
;
}
_getExtensionId
(
menu
)
{
const
{
triggerNode
}
=
menu
;
return
triggerNode
.
dataset
.
extensionid
;
}
_getWidgetId
(
menu
)
{
const
{
triggerNode
}
=
menu
;
return
triggerNode
.
closest
(
"
.
unified
-
extensions
-
item
"
)
?
.
id
;
}
async
onPinToToolbarChange
(
menu
event
)
{
let
shouldPinToToolbar
=
event
.
target
.
getAttribute
(
"
checked
"
)
=
=
"
true
"
;
event
.
target
.
setAttribute
(
"
checked
"
!
shouldPinToToolbar
)
;
let
widgetId
=
this
.
_getWidgetId
(
menu
)
;
if
(
!
widgetId
)
{
return
;
}
if
(
shouldPinToToolbar
)
{
this
.
_maybeMoveWidgetNodeBack
(
widgetId
)
;
}
this
.
pinToToolbar
(
widgetId
shouldPinToToolbar
)
;
}
pinToToolbar
(
widgetId
shouldPinToToolbar
)
{
let
newArea
=
shouldPinToToolbar
?
CustomizableUI
.
AREA_NAVBAR
:
CustomizableUI
.
AREA_ADDONS
;
let
newPosition
=
shouldPinToToolbar
?
undefined
:
0
;
CustomizableUI
.
addWidgetToArea
(
widgetId
newArea
newPosition
)
;
this
.
updateAttention
(
)
;
}
async
moveWidget
(
menu
direction
)
{
const
node
=
menu
.
triggerNode
.
closest
(
"
.
unified
-
extensions
-
item
"
)
;
let
element
;
if
(
direction
=
=
=
"
up
"
&
&
node
.
previousElementSibling
)
{
element
=
node
.
previousElementSibling
;
}
else
if
(
direction
=
=
=
"
down
"
&
&
node
.
nextElementSibling
)
{
element
=
node
.
nextElementSibling
;
}
const
placement
=
CustomizableUI
.
getPlacementOfWidget
(
element
?
.
id
)
;
if
(
placement
)
{
let
newPosition
=
placement
.
position
;
if
(
direction
=
=
=
"
down
"
)
{
newPosition
+
=
1
;
}
CustomizableUI
.
moveWidgetWithinArea
(
node
.
id
newPosition
)
;
}
}
onWidgetAdded
(
aWidgetId
aArea
aPosition
)
{
if
(
CustomizableUI
.
getWidget
(
aWidgetId
)
?
.
forWindow
(
window
)
?
.
overflowed
)
{
return
;
}
const
inPanel
=
CustomizableUI
.
getAreaType
(
aArea
)
!
=
=
CustomizableUI
.
TYPE_TOOLBAR
;
this
.
_updateWidgetClassName
(
aWidgetId
inPanel
)
;
}
onWidgetOverflow
(
aNode
aContainer
)
{
if
(
window
!
=
=
aNode
.
ownerGlobal
)
{
return
;
}
this
.
_updateWidgetClassName
(
aNode
.
getAttribute
(
"
widget
-
id
"
)
true
)
;
}
onWidgetUnderflow
(
aNode
aContainer
)
{
if
(
window
!
=
=
aNode
.
ownerGlobal
)
{
return
;
}
this
.
_updateWidgetClassName
(
aNode
.
getAttribute
(
"
widget
-
id
"
)
false
)
;
}
onAreaNodeRegistered
(
aArea
aContainer
)
{
if
(
window
!
=
=
aContainer
.
ownerGlobal
)
{
return
;
}
const
inPanel
=
CustomizableUI
.
getAreaType
(
aArea
)
!
=
=
CustomizableUI
.
TYPE_TOOLBAR
;
for
(
const
widgetId
of
CustomizableUI
.
getWidgetIdsInArea
(
aArea
)
)
{
this
.
_updateWidgetClassName
(
widgetId
inPanel
)
;
}
}
_updateWidgetClassName
(
aWidgetId
inPanel
)
{
if
(
!
CustomizableUI
.
isWebExtensionWidget
(
aWidgetId
)
)
{
return
;
}
const
node
=
CustomizableUI
.
getWidget
(
aWidgetId
)
?
.
forWindow
(
window
)
?
.
node
;
const
actionButton
=
node
?
.
querySelector
(
"
.
unified
-
extensions
-
item
-
action
-
button
"
)
;
if
(
actionButton
)
{
actionButton
.
classList
.
toggle
(
"
subviewbutton
"
inPanel
)
;
actionButton
.
classList
.
toggle
(
"
subviewbutton
-
iconic
"
inPanel
)
;
actionButton
.
classList
.
toggle
(
"
toolbarbutton
-
1
"
!
inPanel
)
;
}
const
menuButton
=
node
?
.
querySelector
(
"
.
unified
-
extensions
-
item
-
menu
-
button
"
)
;
if
(
menuButton
)
{
menuButton
.
classList
.
toggle
(
"
subviewbutton
"
inPanel
)
;
menuButton
.
classList
.
toggle
(
"
subviewbutton
-
iconic
"
inPanel
)
;
menuButton
.
classList
.
toggle
(
"
toolbarbutton
-
1
"
!
inPanel
)
;
}
}
}
;
