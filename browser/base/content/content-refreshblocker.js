ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
var
RefreshBlocker
=
{
PREF
:
"
accessibility
.
blockautorefresh
"
blockedWindows
:
new
WeakMap
(
)
init
(
)
{
if
(
Services
.
prefs
.
getBoolPref
(
this
.
PREF
)
)
{
this
.
enable
(
)
;
}
Services
.
prefs
.
addObserver
(
this
.
PREF
this
)
;
}
uninit
(
)
{
if
(
Services
.
prefs
.
getBoolPref
(
this
.
PREF
)
)
{
this
.
disable
(
)
;
}
Services
.
prefs
.
removeObserver
(
this
.
PREF
this
)
;
}
observe
(
subject
topic
data
)
{
if
(
topic
=
=
"
nsPref
:
changed
"
&
&
data
=
=
this
.
PREF
)
{
if
(
Services
.
prefs
.
getBoolPref
(
this
.
PREF
)
)
{
this
.
enable
(
)
;
}
else
{
this
.
disable
(
)
;
}
}
}
enable
(
)
{
this
.
_filter
=
Cc
[
"
mozilla
.
org
/
appshell
/
component
/
browser
-
status
-
filter
;
1
"
]
.
createInstance
(
Ci
.
nsIWebProgress
)
;
this
.
_filter
.
addProgressListener
(
this
Ci
.
nsIWebProgress
.
NOTIFY_ALL
)
;
this
.
_filter
.
target
=
tabEventTarget
;
let
webProgress
=
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebProgress
)
;
webProgress
.
addProgressListener
(
this
.
_filter
Ci
.
nsIWebProgress
.
NOTIFY_ALL
)
;
addMessageListener
(
"
RefreshBlocker
:
Refresh
"
this
)
;
}
disable
(
)
{
let
webProgress
=
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebProgress
)
;
webProgress
.
removeProgressListener
(
this
.
_filter
)
;
this
.
_filter
.
removeProgressListener
(
this
)
;
this
.
_filter
=
null
;
removeMessageListener
(
"
RefreshBlocker
:
Refresh
"
this
)
;
}
send
(
data
)
{
sendAsyncMessage
(
"
RefreshBlocker
:
Blocked
"
data
)
;
}
onStateChange
(
aWebProgress
aRequest
aStateFlags
aStatus
)
{
if
(
aStateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_IS_WINDOW
&
&
aStateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_STOP
)
{
this
.
blockedWindows
.
delete
(
aWebProgress
.
DOMWindow
)
;
}
}
onLocationChange
(
aWebProgress
aRequest
aLocation
aFlags
)
{
let
win
=
aWebProgress
.
DOMWindow
;
if
(
this
.
blockedWindows
.
has
(
win
)
)
{
let
data
=
this
.
blockedWindows
.
get
(
win
)
;
if
(
data
)
{
this
.
send
(
data
)
;
}
}
else
{
this
.
blockedWindows
.
set
(
win
null
)
;
}
}
onRefreshAttempted
(
aWebProgress
aURI
aDelay
aSameURI
)
{
let
win
=
aWebProgress
.
DOMWindow
;
let
outerWindowID
=
win
.
windowUtils
.
outerWindowID
;
let
data
=
{
URI
:
aURI
.
spec
delay
:
aDelay
sameURI
:
aSameURI
outerWindowID
}
;
if
(
this
.
blockedWindows
.
has
(
win
)
)
{
this
.
send
(
data
)
;
}
else
{
this
.
blockedWindows
.
set
(
win
data
)
;
}
return
false
;
}
receiveMessage
(
message
)
{
let
data
=
message
.
data
;
if
(
message
.
name
=
=
"
RefreshBlocker
:
Refresh
"
)
{
let
win
=
Services
.
wm
.
getOuterWindowWithId
(
data
.
outerWindowID
)
;
let
refreshURI
=
win
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDocShell
)
.
QueryInterface
(
Ci
.
nsIRefreshURI
)
;
let
URI
=
Services
.
io
.
newURI
(
data
.
URI
)
;
refreshURI
.
forceRefreshURI
(
URI
null
data
.
delay
true
)
;
}
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIWebProgressListener2
Ci
.
nsIWebProgressListener
Ci
.
nsISupportsWeakReference
]
)
}
;
RefreshBlocker
.
init
(
)
;
addEventListener
(
"
unload
"
(
)
=
>
{
RefreshBlocker
.
uninit
(
)
;
}
)
;
