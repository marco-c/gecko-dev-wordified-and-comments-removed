var
SidebarUI
=
{
get
browser
(
)
{
if
(
this
.
_browser
)
return
this
.
_browser
;
return
this
.
_browser
=
document
.
getElementById
(
"
sidebar
"
)
;
}
POSITION_START_PREF
:
"
sidebar
.
position_start
"
DEFAULT_SIDEBAR_ID
:
"
viewBookmarksSidebar
"
lastOpenedId
:
null
_box
:
null
get
_title
(
)
{
if
(
this
.
__title
)
return
this
.
__title
;
return
this
.
__title
=
document
.
getElementById
(
"
sidebar
-
title
"
)
;
}
_splitter
:
null
_icon
:
null
_reversePositionButton
:
null
_switcherPanel
:
null
_switcherTarget
:
null
_switcherArrow
:
null
_inited
:
false
get
initialized
(
)
{
return
this
.
_inited
;
}
init
(
)
{
this
.
_box
=
document
.
getElementById
(
"
sidebar
-
box
"
)
;
this
.
_splitter
=
document
.
getElementById
(
"
sidebar
-
splitter
"
)
;
this
.
_icon
=
document
.
getElementById
(
"
sidebar
-
icon
"
)
;
this
.
_reversePositionButton
=
document
.
getElementById
(
"
sidebar
-
reverse
-
position
"
)
;
this
.
_switcherPanel
=
document
.
getElementById
(
"
sidebarMenu
-
popup
"
)
;
this
.
_switcherTarget
=
document
.
getElementById
(
"
sidebar
-
switcher
-
target
"
)
;
this
.
_switcherArrow
=
document
.
getElementById
(
"
sidebar
-
switcher
-
arrow
"
)
;
this
.
_switcherTarget
.
addEventListener
(
"
command
"
(
)
=
>
{
this
.
toggleSwitcherPanel
(
)
;
}
)
;
this
.
_inited
=
true
;
}
uninit
(
)
{
let
enumerator
=
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
;
if
(
!
enumerator
.
hasMoreElements
(
)
)
{
document
.
persist
(
"
sidebar
-
box
"
"
sidebarcommand
"
)
;
let
xulStore
=
Services
.
xulStore
;
if
(
this
.
_box
.
hasAttribute
(
"
positionend
"
)
)
{
document
.
persist
(
"
sidebar
-
box
"
"
positionend
"
)
;
}
else
{
xulStore
.
removeValue
(
document
.
documentURI
"
sidebar
-
box
"
"
positionend
"
)
;
}
if
(
this
.
_box
.
hasAttribute
(
"
checked
"
)
)
{
document
.
persist
(
"
sidebar
-
box
"
"
checked
"
)
;
}
else
{
xulStore
.
removeValue
(
document
.
documentURI
"
sidebar
-
box
"
"
checked
"
)
;
}
document
.
persist
(
"
sidebar
-
box
"
"
width
"
)
;
document
.
persist
(
"
sidebar
-
title
"
"
value
"
)
;
}
}
toggleSwitcherPanel
(
)
{
if
(
this
.
_switcherPanel
.
state
=
=
"
open
"
|
|
this
.
_switcherPanel
.
state
=
=
"
showing
"
)
{
this
.
hideSwitcherPanel
(
)
;
}
else
if
(
this
.
_switcherPanel
.
state
=
=
"
closed
"
)
{
this
.
showSwitcherPanel
(
)
;
}
}
hideSwitcherPanel
(
)
{
this
.
_switcherPanel
.
hidePopup
(
)
;
}
showSwitcherPanel
(
)
{
this
.
_ensureShortcutsShown
(
)
;
this
.
_switcherPanel
.
addEventListener
(
"
popuphiding
"
(
)
=
>
{
this
.
_switcherTarget
.
classList
.
remove
(
"
active
"
)
;
}
{
once
:
true
}
)
;
let
label
=
this
.
_positionStart
=
=
this
.
isRTL
?
gNavigatorBundle
.
getString
(
"
sidebar
.
moveToLeft
"
)
:
gNavigatorBundle
.
getString
(
"
sidebar
.
moveToRight
"
)
;
this
.
_reversePositionButton
.
setAttribute
(
"
label
"
label
)
;
this
.
_switcherPanel
.
hidden
=
false
;
this
.
_switcherPanel
.
openPopup
(
this
.
_icon
)
;
this
.
_switcherTarget
.
classList
.
add
(
"
active
"
)
;
}
updateShortcut
(
{
button
key
}
)
{
if
(
!
this
.
_addedShortcuts
)
{
return
;
}
if
(
key
)
{
let
keyId
=
key
.
getAttribute
(
"
id
"
)
;
button
=
this
.
_switcherPanel
.
querySelector
(
[
key
=
"
{
keyId
}
"
]
)
;
}
else
if
(
button
)
{
let
keyId
=
button
.
getAttribute
(
"
key
"
)
;
key
=
document
.
getElementById
(
keyId
)
;
}
if
(
!
button
|
|
!
key
)
{
return
;
}
button
.
setAttribute
(
"
shortcut
"
ShortcutUtils
.
prettifyShortcut
(
key
)
)
;
}
_addedShortcuts
:
false
_ensureShortcutsShown
(
)
{
if
(
this
.
_addedShortcuts
)
{
return
;
}
this
.
_addedShortcuts
=
true
;
for
(
let
button
of
this
.
_switcherPanel
.
querySelectorAll
(
"
toolbarbutton
[
key
]
"
)
)
{
this
.
updateShortcut
(
{
button
}
)
;
}
}
reversePosition
(
)
{
Services
.
prefs
.
setBoolPref
(
this
.
POSITION_START_PREF
!
this
.
_positionStart
)
;
}
setPosition
(
)
{
let
browser
=
document
.
getElementById
(
"
browser
"
)
;
[
.
.
.
browser
.
childNodes
]
.
forEach
(
(
node
i
)
=
>
{
node
.
ordinal
=
i
+
1
;
}
)
;
if
(
!
this
.
_positionStart
)
{
let
appcontent
=
document
.
getElementById
(
"
appcontent
"
)
;
let
boxOrdinal
=
this
.
_box
.
ordinal
;
this
.
_box
.
ordinal
=
appcontent
.
ordinal
;
appcontent
.
ordinal
=
boxOrdinal
;
this
.
_box
.
setAttribute
(
"
positionend
"
true
)
;
}
else
{
this
.
_box
.
removeAttribute
(
"
positionend
"
)
;
}
this
.
hideSwitcherPanel
(
)
;
let
content
=
SidebarUI
.
browser
.
contentWindow
;
if
(
content
&
&
content
.
updatePosition
)
{
content
.
updatePosition
(
)
;
}
}
adoptFromWindow
(
sourceWindow
)
{
let
sourceUI
=
sourceWindow
.
SidebarUI
;
if
(
!
sourceUI
|
|
!
sourceUI
.
_box
)
{
return
false
;
}
let
commandID
=
sourceUI
.
_box
.
getAttribute
(
"
sidebarcommand
"
)
;
if
(
commandID
)
{
this
.
_box
.
setAttribute
(
"
sidebarcommand
"
commandID
)
;
}
if
(
sourceUI
.
_box
.
hidden
)
{
return
true
;
}
if
(
!
document
.
getElementById
(
commandID
)
)
{
return
true
;
}
this
.
_box
.
setAttribute
(
"
width
"
sourceUI
.
_box
.
boxObject
.
width
)
;
this
.
showInitially
(
commandID
)
;
return
true
;
}
windowPrivacyMatches
(
w1
w2
)
{
return
PrivateBrowsingUtils
.
isWindowPrivate
(
w1
)
=
=
=
PrivateBrowsingUtils
.
isWindowPrivate
(
w2
)
;
}
startDelayedLoad
(
)
{
let
sourceWindow
=
window
.
opener
;
if
(
sourceWindow
)
{
if
(
sourceWindow
.
closed
|
|
sourceWindow
.
location
.
protocol
!
=
"
chrome
:
"
|
|
!
this
.
windowPrivacyMatches
(
sourceWindow
window
)
)
{
return
;
}
if
(
this
.
adoptFromWindow
(
sourceWindow
)
)
{
return
;
}
}
let
wasOpen
=
this
.
_box
.
getAttribute
(
"
checked
"
)
;
if
(
!
wasOpen
)
{
return
;
}
let
commandID
=
this
.
_box
.
getAttribute
(
"
sidebarcommand
"
)
;
if
(
commandID
&
&
document
.
getElementById
(
commandID
)
)
{
this
.
showInitially
(
commandID
)
;
}
else
{
this
.
_box
.
removeAttribute
(
"
checked
"
)
;
this
.
_box
.
setAttribute
(
"
sidebarcommand
"
"
"
)
;
this
.
lastOpenedId
=
commandID
;
}
}
_fireShowEvent
(
)
{
let
event
=
new
CustomEvent
(
"
SidebarShown
"
{
bubbles
:
true
}
)
;
this
.
_switcherTarget
.
dispatchEvent
(
event
)
;
}
_fireFocusedEvent
(
)
{
let
event
=
new
CustomEvent
(
"
SidebarFocused
"
{
bubbles
:
true
}
)
;
this
.
browser
.
contentWindow
.
dispatchEvent
(
event
)
;
}
get
isOpen
(
)
{
return
!
this
.
_box
.
hidden
;
}
get
currentID
(
)
{
return
this
.
isOpen
?
this
.
_box
.
getAttribute
(
"
sidebarcommand
"
)
:
"
"
;
}
get
title
(
)
{
return
this
.
_title
.
value
;
}
set
title
(
value
)
{
this
.
_title
.
value
=
value
;
}
getBroadcasterById
(
id
)
{
let
sidebarBroadcaster
=
document
.
getElementById
(
id
)
;
if
(
sidebarBroadcaster
&
&
sidebarBroadcaster
.
localName
=
=
"
broadcaster
"
)
{
return
sidebarBroadcaster
;
}
return
null
;
}
toggle
(
commandID
=
this
.
lastOpenedId
triggerNode
)
{
if
(
!
commandID
)
{
commandID
=
this
.
_box
.
getAttribute
(
"
sidebarcommand
"
)
;
}
if
(
!
commandID
|
|
!
this
.
getBroadcasterById
(
commandID
)
)
{
commandID
=
this
.
DEFAULT_SIDEBAR_ID
;
}
if
(
this
.
isOpen
&
&
commandID
=
=
this
.
currentID
)
{
this
.
hide
(
triggerNode
)
;
return
Promise
.
resolve
(
)
;
}
return
this
.
show
(
commandID
triggerNode
)
;
}
_loadSidebarExtension
(
sidebarBroadcaster
)
{
let
extensionId
=
sidebarBroadcaster
.
getAttribute
(
"
extensionId
"
)
;
if
(
extensionId
)
{
let
extensionUrl
=
sidebarBroadcaster
.
getAttribute
(
"
panel
"
)
;
let
browserStyle
=
sidebarBroadcaster
.
getAttribute
(
"
browserStyle
"
)
;
SidebarUI
.
browser
.
contentWindow
.
loadPanel
(
extensionId
extensionUrl
browserStyle
)
;
}
}
show
(
commandID
triggerNode
)
{
return
this
.
_show
(
commandID
)
.
then
(
(
sidebarBroadcaster
)
=
>
{
this
.
_loadSidebarExtension
(
sidebarBroadcaster
)
;
if
(
triggerNode
)
{
updateToggleControlLabel
(
triggerNode
)
;
}
this
.
_fireFocusedEvent
(
)
;
}
)
;
}
showInitially
(
commandID
)
{
return
this
.
_show
(
commandID
)
.
then
(
(
sidebarBroadcaster
)
=
>
{
this
.
_loadSidebarExtension
(
sidebarBroadcaster
)
;
}
)
;
}
_show
(
commandID
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
sidebarBroadcaster
=
this
.
getBroadcasterById
(
commandID
)
;
if
(
!
sidebarBroadcaster
)
{
reject
(
new
Error
(
"
Invalid
sidebar
broadcaster
specified
:
"
+
commandID
)
)
;
return
;
}
let
broadcasters
=
document
.
querySelectorAll
(
"
broadcaster
[
group
=
sidebar
]
"
)
;
for
(
let
broadcaster
of
broadcasters
)
{
if
(
broadcaster
!
=
sidebarBroadcaster
)
{
broadcaster
.
removeAttribute
(
"
checked
"
)
;
}
else
{
sidebarBroadcaster
.
setAttribute
(
"
checked
"
"
true
"
)
;
}
}
this
.
_box
.
hidden
=
this
.
_splitter
.
hidden
=
false
;
this
.
setPosition
(
)
;
this
.
hideSwitcherPanel
(
)
;
this
.
_box
.
setAttribute
(
"
checked
"
"
true
"
)
;
this
.
_box
.
setAttribute
(
"
sidebarcommand
"
sidebarBroadcaster
.
id
)
;
this
.
lastOpenedId
=
sidebarBroadcaster
.
id
;
let
title
=
sidebarBroadcaster
.
getAttribute
(
"
sidebartitle
"
)
|
|
sidebarBroadcaster
.
getAttribute
(
"
label
"
)
;
if
(
title
)
{
this
.
title
=
title
;
}
let
url
=
sidebarBroadcaster
.
getAttribute
(
"
sidebarurl
"
)
;
this
.
browser
.
setAttribute
(
"
src
"
url
)
;
if
(
this
.
browser
.
contentDocument
.
location
.
href
!
=
url
)
{
this
.
browser
.
addEventListener
(
"
load
"
event
=
>
{
setTimeout
(
(
)
=
>
{
resolve
(
sidebarBroadcaster
)
;
this
.
_fireShowEvent
(
)
;
}
0
)
;
}
{
capture
:
true
once
:
true
}
)
;
}
else
{
resolve
(
sidebarBroadcaster
)
;
this
.
_fireShowEvent
(
)
;
}
let
selBrowser
=
gBrowser
.
selectedBrowser
;
selBrowser
.
messageManager
.
sendAsyncMessage
(
"
Sidebar
:
VisibilityChange
"
{
commandID
isOpen
:
true
}
)
;
}
)
;
}
hide
(
triggerNode
)
{
if
(
!
this
.
isOpen
)
{
return
;
}
this
.
hideSwitcherPanel
(
)
;
let
commandID
=
this
.
_box
.
getAttribute
(
"
sidebarcommand
"
)
;
let
sidebarBroadcaster
=
document
.
getElementById
(
commandID
)
;
if
(
sidebarBroadcaster
.
getAttribute
(
"
checked
"
)
!
=
"
true
"
)
{
return
;
}
this
.
browser
.
setAttribute
(
"
src
"
"
about
:
blank
"
)
;
this
.
browser
.
docShell
.
createAboutBlankContentViewer
(
null
)
;
sidebarBroadcaster
.
removeAttribute
(
"
checked
"
)
;
this
.
_box
.
removeAttribute
(
"
checked
"
)
;
this
.
_box
.
hidden
=
this
.
_splitter
.
hidden
=
true
;
let
selBrowser
=
gBrowser
.
selectedBrowser
;
selBrowser
.
focus
(
)
;
selBrowser
.
messageManager
.
sendAsyncMessage
(
"
Sidebar
:
VisibilityChange
"
{
commandID
isOpen
:
false
}
)
;
if
(
triggerNode
)
{
updateToggleControlLabel
(
triggerNode
)
;
}
}
}
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
SidebarUI
"
_positionStart
"
SidebarUI
.
POSITION_START_PREF
true
SidebarUI
.
setPosition
.
bind
(
SidebarUI
)
)
;
XPCOMUtils
.
defineLazyGetter
(
SidebarUI
"
isRTL
"
(
)
=
>
{
return
getComputedStyle
(
document
.
documentElement
)
.
direction
=
=
"
rtl
"
;
}
)
;
