ToolbarKeyboardNavigator
=
{
kToolbars
:
[
CustomizableUI
.
AREA_NAVBAR
CustomizableUI
.
AREA_BOOKMARKS
]
_isButton
(
aElem
)
{
return
aElem
.
tagName
=
=
"
toolbarbutton
"
|
|
aElem
.
getAttribute
(
"
role
"
)
=
=
"
button
"
;
}
_getWalker
(
aRoot
)
{
if
(
aRoot
.
_toolbarKeyNavWalker
)
{
return
aRoot
.
_toolbarKeyNavWalker
;
}
let
filter
=
(
aNode
)
=
>
{
if
(
aNode
.
tagName
=
=
"
toolbartabstop
"
)
{
return
NodeFilter
.
FILTER_ACCEPT
;
}
if
(
aNode
.
id
=
=
"
identity
-
box
"
&
&
document
.
getElementById
(
"
urlbar
"
)
.
getAttribute
(
"
pageproxystate
"
)
=
=
"
invalid
"
)
{
return
NodeFilter
.
FILTER_REJECT
;
}
if
(
aNode
.
hidden
|
|
aNode
.
disabled
|
|
aNode
.
style
[
"
visibility
"
]
=
=
"
hidden
"
)
{
return
NodeFilter
.
FILTER_REJECT
;
}
let
bounds
=
window
.
windowUtils
.
getBoundsWithoutFlushing
(
aNode
)
;
if
(
bounds
.
width
=
=
0
)
{
return
NodeFilter
.
FILTER_REJECT
;
}
if
(
this
.
_isButton
(
aNode
)
)
{
return
NodeFilter
.
FILTER_ACCEPT
;
}
return
NodeFilter
.
FILTER_SKIP
;
}
;
aRoot
.
_toolbarKeyNavWalker
=
document
.
createTreeWalker
(
aRoot
NodeFilter
.
SHOW_ELEMENT
filter
)
;
return
aRoot
.
_toolbarKeyNavWalker
;
}
init
(
)
{
for
(
let
id
of
this
.
kToolbars
)
{
let
toolbar
=
document
.
getElementById
(
id
)
;
toolbar
.
setAttribute
(
"
keyNav
"
"
true
"
)
;
for
(
let
stop
of
toolbar
.
getElementsByTagName
(
"
toolbartabstop
"
)
)
{
stop
.
setAttribute
(
"
aria
-
hidden
"
"
true
"
)
;
stop
.
addEventListener
(
"
focus
"
this
)
;
}
toolbar
.
addEventListener
(
"
keydown
"
this
)
;
toolbar
.
addEventListener
(
"
keypress
"
this
)
;
}
}
uninit
(
)
{
for
(
let
id
of
this
.
kToolbars
)
{
let
toolbar
=
document
.
getElementById
(
id
)
;
for
(
let
stop
of
toolbar
.
getElementsByTagName
(
"
toolbartabstop
"
)
)
{
stop
.
removeEventListener
(
"
focus
"
this
)
;
}
toolbar
.
removeEventListener
(
"
keydown
"
this
)
;
toolbar
.
removeEventListener
(
"
keypress
"
this
)
;
toolbar
.
removeAttribute
(
"
keyNav
"
)
;
}
}
_focusButton
(
aButton
)
{
aButton
.
setAttribute
(
"
tabindex
"
"
-
1
"
)
;
aButton
.
focus
(
)
;
aButton
.
addEventListener
(
"
blur
"
this
)
;
}
_onButtonBlur
(
aEvent
)
{
if
(
document
.
activeElement
=
=
aEvent
.
target
)
{
return
;
}
aEvent
.
target
.
removeEventListener
(
"
blur
"
this
)
;
aEvent
.
target
.
removeAttribute
(
"
tabindex
"
)
;
}
_onTabStopFocus
(
aEvent
)
{
let
toolbar
=
aEvent
.
target
.
closest
(
"
toolbar
"
)
;
let
walker
=
this
.
_getWalker
(
toolbar
)
;
let
oldFocus
=
aEvent
.
relatedTarget
;
if
(
oldFocus
)
{
this
.
_isFocusMovingBackward
=
oldFocus
.
compareDocumentPosition
(
aEvent
.
target
)
&
Node
.
DOCUMENT_POSITION_PRECEDING
;
if
(
this
.
_isFocusMovingBackward
&
&
oldFocus
&
&
this
.
_isButton
(
oldFocus
)
)
{
document
.
commandDispatcher
.
rewindFocus
(
)
;
return
;
}
}
walker
.
currentNode
=
aEvent
.
target
;
let
button
=
walker
.
nextNode
(
)
;
if
(
!
button
|
|
!
this
.
_isButton
(
button
)
)
{
if
(
this
.
_isFocusMovingBackward
)
{
document
.
commandDispatcher
.
rewindFocus
(
)
;
}
else
{
document
.
commandDispatcher
.
advanceFocus
(
)
;
}
return
;
}
this
.
_focusButton
(
button
)
;
}
navigateButtons
(
aToolbar
aPrevious
)
{
let
oldFocus
=
document
.
activeElement
;
let
walker
=
this
.
_getWalker
(
aToolbar
)
;
walker
.
currentNode
=
oldFocus
;
let
newFocus
;
if
(
aPrevious
)
{
newFocus
=
walker
.
previousNode
(
)
;
}
else
{
newFocus
=
walker
.
nextNode
(
)
;
}
if
(
!
newFocus
|
|
newFocus
.
tagName
=
=
"
toolbartabstop
"
)
{
return
;
}
this
.
_focusButton
(
newFocus
)
;
}
_onKeyDown
(
aEvent
)
{
let
focus
=
document
.
activeElement
;
if
(
aEvent
.
altKey
|
|
aEvent
.
controlKey
|
|
aEvent
.
metaKey
|
|
aEvent
.
shiftKey
|
|
!
this
.
_isButton
(
focus
)
)
{
return
;
}
switch
(
aEvent
.
key
)
{
case
"
ArrowLeft
"
:
this
.
navigateButtons
(
aEvent
.
currentTarget
!
window
.
RTL_UI
)
;
break
;
case
"
ArrowRight
"
:
this
.
navigateButtons
(
aEvent
.
currentTarget
window
.
RTL_UI
)
;
break
;
default
:
return
;
}
aEvent
.
preventDefault
(
)
;
}
_onKeyPress
(
aEvent
)
{
let
focus
=
document
.
activeElement
;
if
(
(
aEvent
.
key
!
=
"
Enter
"
&
&
aEvent
.
key
!
=
"
"
)
|
|
!
this
.
_isButton
(
focus
)
)
{
return
;
}
if
(
focus
.
getAttribute
(
"
type
"
)
=
=
"
menu
"
)
{
focus
.
open
=
true
;
}
else
{
focus
.
dispatchEvent
(
new
MouseEvent
(
"
click
"
{
bubbles
:
true
ctrlKey
:
aEvent
.
ctrlKey
altKey
:
aEvent
.
altKey
shiftKey
:
aEvent
.
shiftKey
metaKey
:
aEvent
.
metaKey
}
)
)
;
}
aEvent
.
stopPropagation
(
)
;
}
handleEvent
(
aEvent
)
{
switch
(
aEvent
.
type
)
{
case
"
focus
"
:
this
.
_onTabStopFocus
(
aEvent
)
;
break
;
case
"
keydown
"
:
this
.
_onKeyDown
(
aEvent
)
;
break
;
case
"
keypress
"
:
this
.
_onKeyPress
(
aEvent
)
;
break
;
case
"
blur
"
:
this
.
_onButtonBlur
(
aEvent
)
;
break
;
}
}
}
;
