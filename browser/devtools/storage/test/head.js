"
use
strict
"
;
let
{
console
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
devtools
/
Console
.
jsm
"
{
}
)
;
let
{
require
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
devtools
/
Loader
.
jsm
"
{
}
)
;
let
{
TargetFactory
}
=
require
(
"
devtools
/
framework
/
target
"
)
;
let
promise
=
require
(
"
promise
"
)
;
let
DevToolsUtils
=
require
(
"
devtools
/
toolkit
/
DevToolsUtils
"
)
;
const
SPLIT_CONSOLE_PREF
=
"
devtools
.
toolbox
.
splitconsoleEnabled
"
;
const
STORAGE_PREF
=
"
devtools
.
storage
.
enabled
"
;
const
DUMPEMIT_PREF
=
"
devtools
.
dump
.
emit
"
;
const
DEBUGGERLOG_PREF
=
"
devtools
.
debugger
.
log
"
;
const
PATH
=
"
browser
/
browser
/
devtools
/
storage
/
test
/
"
;
const
MAIN_DOMAIN
=
"
http
:
/
/
test1
.
example
.
org
/
"
+
PATH
;
const
ALT_DOMAIN
=
"
http
:
/
/
sectest1
.
example
.
org
/
"
+
PATH
;
const
ALT_DOMAIN_SECURED
=
"
https
:
/
/
sectest1
.
example
.
org
:
443
/
"
+
PATH
;
waitForExplicitFinish
(
)
;
let
gToolbox
gPanelWindow
gWindow
gUI
;
Services
.
prefs
.
setBoolPref
(
STORAGE_PREF
true
)
;
DevToolsUtils
.
testing
=
true
;
registerCleanupFunction
(
(
)
=
>
{
gToolbox
=
gPanelWindow
=
gWindow
=
gUI
=
null
;
Services
.
prefs
.
clearUserPref
(
STORAGE_PREF
)
;
Services
.
prefs
.
clearUserPref
(
SPLIT_CONSOLE_PREF
)
;
Services
.
prefs
.
clearUserPref
(
DUMPEMIT_PREF
)
;
Services
.
prefs
.
clearUserPref
(
DEBUGGERLOG_PREF
)
;
DevToolsUtils
.
testing
=
false
;
while
(
gBrowser
.
tabs
.
length
>
1
)
{
gBrowser
.
removeCurrentTab
(
)
;
}
}
)
;
function
addTab
(
url
)
{
info
(
"
Adding
a
new
tab
with
URL
:
'
"
+
url
+
"
'
"
)
;
let
def
=
promise
.
defer
(
)
;
window
.
focus
(
)
;
let
tab
=
window
.
gBrowser
.
selectedTab
=
window
.
gBrowser
.
addTab
(
url
)
;
let
linkedBrowser
=
tab
.
linkedBrowser
;
linkedBrowser
.
addEventListener
(
"
load
"
function
onload
(
event
)
{
if
(
event
.
originalTarget
.
location
.
href
!
=
url
)
{
return
;
}
linkedBrowser
.
removeEventListener
(
"
load
"
onload
true
)
;
info
(
"
URL
'
"
+
url
+
"
'
loading
complete
"
)
;
def
.
resolve
(
tab
.
linkedBrowser
.
contentWindow
)
;
}
true
)
;
return
def
.
promise
;
}
function
*
openTabAndSetupStorage
(
url
)
{
let
setupIDBInFrames
=
(
w
i
c
)
=
>
{
if
(
w
[
i
]
&
&
w
[
i
]
.
idbGenerator
)
{
w
[
i
]
.
setupIDB
=
w
[
i
]
.
idbGenerator
(
(
)
=
>
setupIDBInFrames
(
w
i
+
1
c
)
)
;
w
[
i
]
.
setupIDB
.
next
(
)
;
}
else
if
(
w
[
i
]
&
&
w
[
i
+
1
]
)
{
setupIDBInFrames
(
w
i
+
1
c
)
;
}
else
{
c
(
)
;
}
}
;
let
content
=
yield
addTab
(
url
)
;
let
def
=
promise
.
defer
(
)
;
gWindow
=
content
.
wrappedJSObject
;
if
(
gWindow
.
idbGenerator
)
{
gWindow
.
setupIDB
=
gWindow
.
idbGenerator
(
(
)
=
>
{
setupIDBInFrames
(
gWindow
0
(
)
=
>
{
def
.
resolve
(
)
;
}
)
;
}
)
;
gWindow
.
setupIDB
.
next
(
)
;
yield
def
.
promise
;
}
return
yield
openStoragePanel
(
)
;
}
let
openStoragePanel
=
Task
.
async
(
function
*
(
cb
)
{
info
(
"
Opening
the
storage
inspector
"
)
;
let
target
=
TargetFactory
.
forTab
(
gBrowser
.
selectedTab
)
;
let
storage
toolbox
;
toolbox
=
gDevTools
.
getToolbox
(
target
)
;
if
(
toolbox
)
{
storage
=
toolbox
.
getPanel
(
"
storage
"
)
;
if
(
storage
)
{
gPanelWindow
=
storage
.
panelWindow
;
gUI
=
storage
.
UI
;
gToolbox
=
toolbox
;
info
(
"
Toolbox
and
storage
already
open
"
)
;
if
(
cb
)
{
return
cb
(
storage
toolbox
)
;
}
return
{
toolbox
:
toolbox
storage
:
storage
}
;
}
}
info
(
"
Opening
the
toolbox
"
)
;
toolbox
=
yield
gDevTools
.
showToolbox
(
target
"
storage
"
)
;
storage
=
toolbox
.
getPanel
(
"
storage
"
)
;
gPanelWindow
=
storage
.
panelWindow
;
gUI
=
storage
.
UI
;
gToolbox
=
toolbox
;
info
(
"
Waiting
for
the
stores
to
update
"
)
;
yield
gUI
.
once
(
"
store
-
objects
-
updated
"
)
;
yield
waitForToolboxFrameFocus
(
toolbox
)
;
if
(
cb
)
{
return
cb
(
storage
toolbox
)
;
}
return
{
toolbox
:
toolbox
storage
:
storage
}
;
}
)
;
function
waitForToolboxFrameFocus
(
toolbox
)
{
info
(
"
Making
sure
that
the
toolbox
'
s
frame
is
focused
"
)
;
let
def
=
promise
.
defer
(
)
;
let
win
=
toolbox
.
frame
.
contentWindow
;
waitForFocus
(
def
.
resolve
win
)
;
return
def
.
promise
;
}
function
forceCollections
(
)
{
Cu
.
forceGC
(
)
;
Cu
.
forceCC
(
)
;
Cu
.
forceShrinkingGC
(
)
;
}
function
getAllWindows
(
baseWindow
=
gWindow
)
{
let
windows
=
new
Set
(
)
;
let
_getAllWindows
=
function
(
win
)
{
windows
.
add
(
win
)
;
for
(
let
i
=
0
;
i
<
win
.
length
;
i
+
+
)
{
_getAllWindows
(
win
[
i
]
)
;
}
}
;
_getAllWindows
(
baseWindow
)
;
return
windows
;
}
function
*
finishTests
(
)
{
for
(
let
win
of
getAllWindows
(
)
)
{
if
(
win
.
clear
)
{
console
.
log
(
"
Clearing
cookies
localStorage
and
indexedDBs
from
"
+
win
.
document
.
location
)
;
yield
win
.
clear
(
)
;
}
}
forceCollections
(
)
;
finish
(
)
;
}
function
*
click
(
node
)
{
let
def
=
promise
.
defer
(
)
;
node
.
scrollIntoView
(
)
;
setTimeout
(
(
)
=
>
{
node
.
click
(
)
;
def
.
resolve
(
)
;
}
200
)
;
return
def
;
}
function
variablesViewExpandTo
(
aOptions
)
{
let
root
=
aOptions
.
rootVariable
;
let
expandTo
=
aOptions
.
expandTo
.
split
(
"
.
"
)
;
let
lastDeferred
=
promise
.
defer
(
)
;
function
getNext
(
aProp
)
{
let
name
=
expandTo
.
shift
(
)
;
let
newProp
=
aProp
.
get
(
name
)
;
if
(
expandTo
.
length
>
0
)
{
ok
(
newProp
"
found
property
"
+
name
)
;
if
(
newProp
&
&
newProp
.
expand
)
{
newProp
.
expand
(
)
;
getNext
(
newProp
)
;
}
else
{
lastDeferred
.
reject
(
aProp
)
;
}
}
else
if
(
newProp
)
{
lastDeferred
.
resolve
(
newProp
)
;
}
else
{
lastDeferred
.
reject
(
aProp
)
;
}
}
function
fetchError
(
aProp
)
{
lastDeferred
.
reject
(
aProp
)
;
}
if
(
root
&
&
root
.
expand
)
{
root
.
expand
(
)
;
getNext
(
root
)
;
}
else
{
lastDeferred
.
resolve
(
root
)
;
}
return
lastDeferred
.
promise
;
}
function
findVariableViewProperties
(
aRules
aParsed
)
{
function
init
(
)
{
if
(
aParsed
)
{
aRules
=
aRules
.
map
(
(
{
name
value
dontMatch
}
)
=
>
{
return
{
name
:
"
.
"
+
name
value
dontMatch
}
;
}
)
;
}
let
expandRules
=
[
]
;
let
rules
=
aRules
.
filter
(
(
aRule
)
=
>
{
if
(
typeof
aRule
.
name
=
=
"
string
"
&
&
aRule
.
name
.
indexOf
(
"
.
"
)
>
-
1
)
{
expandRules
.
push
(
aRule
)
;
return
false
;
}
return
true
;
}
)
;
let
outstanding
=
[
]
;
finder
(
rules
gUI
.
view
outstanding
)
;
let
lastStep
=
processExpandRules
.
bind
(
null
expandRules
)
;
let
returnResults
=
onAllRulesMatched
.
bind
(
null
aRules
)
;
return
promise
.
all
(
outstanding
)
.
then
(
lastStep
)
.
then
(
returnResults
)
;
}
function
onMatch
(
aProp
aRule
aMatched
)
{
if
(
aMatched
&
&
!
aRule
.
matchedProp
)
{
aRule
.
matchedProp
=
aProp
;
}
}
function
finder
(
rules
aView
aPromises
)
{
for
(
let
scope
of
aView
)
{
for
(
let
[
prop
]
of
scope
)
{
for
(
let
rule
of
rules
)
{
let
matcher
=
matchVariablesViewProperty
(
prop
rule
)
;
aPromises
.
push
(
matcher
.
then
(
onMatch
.
bind
(
null
prop
rule
)
)
)
;
}
}
}
}
function
processExpandRules
(
rules
)
{
let
rule
=
rules
.
shift
(
)
;
if
(
!
rule
)
{
return
promise
.
resolve
(
null
)
;
}
let
deferred
=
promise
.
defer
(
)
;
let
expandOptions
=
{
rootVariable
:
gUI
.
view
.
getScopeAtIndex
(
aParsed
?
1
:
0
)
expandTo
:
rule
.
name
}
;
variablesViewExpandTo
(
expandOptions
)
.
then
(
function
onSuccess
(
aProp
)
{
let
name
=
rule
.
name
;
let
lastName
=
name
.
split
(
"
.
"
)
.
pop
(
)
;
rule
.
name
=
lastName
;
let
matched
=
matchVariablesViewProperty
(
aProp
rule
)
;
return
matched
.
then
(
onMatch
.
bind
(
null
aProp
rule
)
)
.
then
(
function
(
)
{
rule
.
name
=
name
;
}
)
;
}
function
onFailure
(
)
{
return
promise
.
resolve
(
null
)
;
}
)
.
then
(
processExpandRules
.
bind
(
null
rules
)
)
.
then
(
function
(
)
{
deferred
.
resolve
(
null
)
;
}
)
;
return
deferred
.
promise
;
}
function
onAllRulesMatched
(
rules
)
{
for
(
let
rule
of
rules
)
{
let
matched
=
rule
.
matchedProp
;
if
(
matched
&
&
!
rule
.
dontMatch
)
{
ok
(
true
"
rule
"
+
rule
.
name
+
"
matched
for
property
"
+
matched
.
name
)
;
}
else
if
(
matched
&
&
rule
.
dontMatch
)
{
ok
(
false
"
rule
"
+
rule
.
name
+
"
should
not
match
property
"
+
matched
.
name
)
;
}
else
{
ok
(
rule
.
dontMatch
"
rule
"
+
rule
.
name
+
"
did
not
match
any
property
"
)
;
}
}
return
rules
;
}
return
init
(
)
;
}
function
matchVariablesViewProperty
(
aProp
aRule
)
{
function
resolve
(
aResult
)
{
return
promise
.
resolve
(
aResult
)
;
}
if
(
!
aProp
)
{
return
resolve
(
false
)
;
}
if
(
aRule
.
name
)
{
let
match
=
aRule
.
name
instanceof
RegExp
?
aRule
.
name
.
test
(
aProp
.
name
)
:
aProp
.
name
=
=
aRule
.
name
;
if
(
!
match
)
{
return
resolve
(
false
)
;
}
}
if
(
"
value
"
in
aRule
)
{
let
displayValue
=
aProp
.
displayValue
;
if
(
aProp
.
displayValueClassName
=
=
"
token
-
string
"
)
{
displayValue
=
displayValue
.
substring
(
1
displayValue
.
length
-
1
)
;
}
let
match
=
aRule
.
value
instanceof
RegExp
?
aRule
.
value
.
test
(
displayValue
)
:
displayValue
=
=
aRule
.
value
;
if
(
!
match
)
{
info
(
"
rule
"
+
aRule
.
name
+
"
did
not
match
value
expected
'
"
+
aRule
.
value
+
"
'
found
'
"
+
displayValue
+
"
'
"
)
;
return
resolve
(
false
)
;
}
}
return
resolve
(
true
)
;
}
function
*
selectTreeItem
(
ids
)
{
gUI
.
tree
.
expandAll
(
)
;
let
selector
=
"
[
data
-
id
=
'
"
+
JSON
.
stringify
(
ids
)
+
"
'
]
>
.
tree
-
widget
-
item
"
;
let
target
=
gPanelWindow
.
document
.
querySelector
(
selector
)
;
let
updated
=
gUI
.
once
(
"
store
-
objects
-
updated
"
)
;
yield
click
(
target
)
;
yield
updated
;
}
function
*
selectTableItem
(
id
)
{
let
selector
=
"
.
table
-
widget
-
cell
[
data
-
id
=
'
"
+
id
+
"
'
]
"
;
let
target
=
gPanelWindow
.
document
.
querySelector
(
selector
)
;
yield
click
(
target
)
;
yield
gUI
.
once
(
"
sidebar
-
updated
"
)
;
}
function
once
(
target
eventName
useCapture
=
false
)
{
info
(
"
Waiting
for
event
:
'
"
+
eventName
+
"
'
on
"
+
target
+
"
.
"
)
;
let
deferred
=
promise
.
defer
(
)
;
for
(
let
[
add
remove
]
of
[
[
"
addEventListener
"
"
removeEventListener
"
]
[
"
addListener
"
"
removeListener
"
]
[
"
on
"
"
off
"
]
]
)
{
if
(
(
add
in
target
)
&
&
(
remove
in
target
)
)
{
target
[
add
]
(
eventName
function
onEvent
(
.
.
.
aArgs
)
{
target
[
remove
]
(
eventName
onEvent
useCapture
)
;
deferred
.
resolve
.
apply
(
deferred
aArgs
)
;
}
useCapture
)
;
break
;
}
}
return
deferred
.
promise
;
}
