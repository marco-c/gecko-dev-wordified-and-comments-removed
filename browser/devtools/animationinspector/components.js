"
use
strict
"
;
const
{
Cu
}
=
require
(
"
chrome
"
)
;
Cu
.
import
(
"
resource
:
/
/
/
modules
/
devtools
/
ViewHelpers
.
jsm
"
)
;
const
{
Task
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
{
}
)
;
const
{
createNode
drawGraphElementBackground
findOptimalTimeInterval
}
=
require
(
"
devtools
/
animationinspector
/
utils
"
)
;
const
STRINGS_URI
=
"
chrome
:
/
/
browser
/
locale
/
devtools
/
animationinspector
.
properties
"
;
const
L10N
=
new
ViewHelpers
.
L10N
(
STRINGS_URI
)
;
const
MILLIS_TIME_FORMAT_MAX_DURATION
=
4000
;
const
TIME_GRADUATION_MIN_SPACING
=
40
;
function
AnimationTargetNode
(
inspector
options
=
{
}
)
{
this
.
inspector
=
inspector
;
this
.
options
=
options
;
this
.
onPreviewMouseOver
=
this
.
onPreviewMouseOver
.
bind
(
this
)
;
this
.
onPreviewMouseOut
=
this
.
onPreviewMouseOut
.
bind
(
this
)
;
this
.
onSelectNodeClick
=
this
.
onSelectNodeClick
.
bind
(
this
)
;
this
.
onMarkupMutations
=
this
.
onMarkupMutations
.
bind
(
this
)
;
EventEmitter
.
decorate
(
this
)
;
}
exports
.
AnimationTargetNode
=
AnimationTargetNode
;
AnimationTargetNode
.
prototype
=
{
init
:
function
(
containerEl
)
{
let
document
=
containerEl
.
ownerDocument
;
this
.
el
=
createNode
(
{
parent
:
containerEl
attributes
:
{
"
class
"
:
"
animation
-
target
"
}
}
)
;
this
.
selectNodeEl
=
createNode
(
{
parent
:
this
.
el
nodeType
:
"
span
"
attributes
:
{
"
class
"
:
"
node
-
selector
"
}
}
)
;
this
.
previewEl
=
createNode
(
{
parent
:
this
.
el
nodeType
:
"
span
"
}
)
;
if
(
!
this
.
options
.
compact
)
{
this
.
previewEl
.
appendChild
(
document
.
createTextNode
(
"
<
"
)
)
;
}
this
.
tagNameEl
=
createNode
(
{
parent
:
this
.
previewEl
nodeType
:
"
span
"
attributes
:
{
"
class
"
:
"
tag
-
name
theme
-
fg
-
color3
"
}
}
)
;
this
.
idEl
=
createNode
(
{
parent
:
this
.
previewEl
nodeType
:
"
span
"
}
)
;
if
(
!
this
.
options
.
compact
)
{
createNode
(
{
parent
:
this
.
idEl
nodeType
:
"
span
"
attributes
:
{
"
class
"
:
"
attribute
-
name
theme
-
fg
-
color2
"
}
textContent
:
"
id
"
}
)
;
this
.
idEl
.
appendChild
(
document
.
createTextNode
(
"
=
\
"
"
)
)
;
}
else
{
createNode
(
{
parent
:
this
.
idEl
nodeType
:
"
span
"
attributes
:
{
"
class
"
:
"
theme
-
fg
-
color2
"
}
textContent
:
"
#
"
}
)
;
}
createNode
(
{
parent
:
this
.
idEl
nodeType
:
"
span
"
attributes
:
{
"
class
"
:
"
attribute
-
value
theme
-
fg
-
color6
"
}
}
)
;
if
(
!
this
.
options
.
compact
)
{
this
.
idEl
.
appendChild
(
document
.
createTextNode
(
"
\
"
"
)
)
;
}
this
.
classEl
=
createNode
(
{
parent
:
this
.
previewEl
nodeType
:
"
span
"
}
)
;
if
(
!
this
.
options
.
compact
)
{
createNode
(
{
parent
:
this
.
classEl
nodeType
:
"
span
"
attributes
:
{
"
class
"
:
"
attribute
-
name
theme
-
fg
-
color2
"
}
textContent
:
"
class
"
}
)
;
this
.
classEl
.
appendChild
(
document
.
createTextNode
(
"
=
\
"
"
)
)
;
}
else
{
createNode
(
{
parent
:
this
.
classEl
nodeType
:
"
span
"
attributes
:
{
"
class
"
:
"
theme
-
fg
-
color6
"
}
textContent
:
"
.
"
}
)
;
}
createNode
(
{
parent
:
this
.
classEl
nodeType
:
"
span
"
attributes
:
{
"
class
"
:
"
attribute
-
value
theme
-
fg
-
color6
"
}
}
)
;
if
(
!
this
.
options
.
compact
)
{
this
.
classEl
.
appendChild
(
document
.
createTextNode
(
"
\
"
"
)
)
;
this
.
previewEl
.
appendChild
(
document
.
createTextNode
(
"
>
"
)
)
;
}
this
.
previewEl
.
addEventListener
(
"
mouseover
"
this
.
onPreviewMouseOver
)
;
this
.
previewEl
.
addEventListener
(
"
mouseout
"
this
.
onPreviewMouseOut
)
;
this
.
selectNodeEl
.
addEventListener
(
"
click
"
this
.
onSelectNodeClick
)
;
this
.
inspector
.
on
(
"
markupmutation
"
this
.
onMarkupMutations
)
;
}
destroy
:
function
(
)
{
this
.
inspector
.
off
(
"
markupmutation
"
this
.
onMarkupMutations
)
;
this
.
previewEl
.
removeEventListener
(
"
mouseover
"
this
.
onPreviewMouseOver
)
;
this
.
previewEl
.
removeEventListener
(
"
mouseout
"
this
.
onPreviewMouseOut
)
;
this
.
selectNodeEl
.
removeEventListener
(
"
click
"
this
.
onSelectNodeClick
)
;
this
.
el
.
remove
(
)
;
this
.
el
=
this
.
tagNameEl
=
this
.
idEl
=
this
.
classEl
=
null
;
this
.
selectNodeEl
=
this
.
previewEl
=
null
;
this
.
nodeFront
=
this
.
inspector
=
this
.
playerFront
=
null
;
}
onPreviewMouseOver
:
function
(
)
{
if
(
!
this
.
nodeFront
)
{
return
;
}
this
.
inspector
.
toolbox
.
highlighterUtils
.
highlightNodeFront
(
this
.
nodeFront
)
;
}
onPreviewMouseOut
:
function
(
)
{
this
.
inspector
.
toolbox
.
highlighterUtils
.
unhighlight
(
)
;
}
onSelectNodeClick
:
function
(
)
{
if
(
!
this
.
nodeFront
)
{
return
;
}
this
.
inspector
.
selection
.
setNodeFront
(
this
.
nodeFront
"
animationinspector
"
)
;
}
onMarkupMutations
:
function
(
e
mutations
)
{
if
(
!
this
.
nodeFront
|
|
!
this
.
playerFront
)
{
return
;
}
for
(
let
{
target
}
of
mutations
)
{
if
(
target
=
=
=
this
.
nodeFront
)
{
this
.
render
(
this
.
playerFront
)
;
break
;
}
}
}
render
:
Task
.
async
(
function
*
(
playerFront
)
{
this
.
playerFront
=
playerFront
;
this
.
nodeFront
=
undefined
;
try
{
this
.
nodeFront
=
yield
this
.
inspector
.
walker
.
getNodeFromActor
(
playerFront
.
actorID
[
"
node
"
]
)
;
}
catch
(
e
)
{
if
(
!
this
.
el
)
{
console
.
warn
(
"
Cound
'
t
retrieve
the
animation
target
node
widget
"
+
"
destroyed
"
)
;
}
console
.
error
(
e
)
;
return
;
}
if
(
!
this
.
nodeFront
|
|
!
this
.
el
)
{
return
;
}
let
{
tagName
attributes
}
=
this
.
nodeFront
;
this
.
tagNameEl
.
textContent
=
tagName
.
toLowerCase
(
)
;
let
idIndex
=
attributes
.
findIndex
(
(
{
name
}
)
=
>
name
=
=
=
"
id
"
)
;
if
(
idIndex
>
-
1
&
&
attributes
[
idIndex
]
.
value
)
{
this
.
idEl
.
querySelector
(
"
.
attribute
-
value
"
)
.
textContent
=
attributes
[
idIndex
]
.
value
;
this
.
idEl
.
style
.
display
=
"
inline
"
;
}
else
{
this
.
idEl
.
style
.
display
=
"
none
"
;
}
let
classIndex
=
attributes
.
findIndex
(
(
{
name
}
)
=
>
name
=
=
=
"
class
"
)
;
if
(
classIndex
>
-
1
&
&
attributes
[
classIndex
]
.
value
)
{
let
value
=
attributes
[
classIndex
]
.
value
;
if
(
this
.
options
.
compact
)
{
value
=
value
.
split
(
"
"
)
.
join
(
"
.
"
)
;
}
this
.
classEl
.
querySelector
(
"
.
attribute
-
value
"
)
.
textContent
=
value
;
this
.
classEl
.
style
.
display
=
"
inline
"
;
}
else
{
this
.
classEl
.
style
.
display
=
"
none
"
;
}
this
.
emit
(
"
target
-
retrieved
"
)
;
}
)
}
;
var
TimeScale
=
{
minStartTime
:
Infinity
maxEndTime
:
0
addAnimation
:
function
(
state
)
{
let
{
previousStartTime
delay
duration
iterationCount
playbackRate
}
=
state
;
let
relevantDelay
=
delay
<
0
?
delay
/
playbackRate
:
0
;
previousStartTime
=
previousStartTime
|
|
0
;
this
.
minStartTime
=
Math
.
min
(
this
.
minStartTime
previousStartTime
+
relevantDelay
)
;
let
length
=
(
delay
/
playbackRate
)
+
(
(
duration
/
playbackRate
)
*
(
!
iterationCount
?
1
:
iterationCount
)
)
;
this
.
maxEndTime
=
Math
.
max
(
this
.
maxEndTime
previousStartTime
+
length
)
;
}
reset
:
function
(
)
{
this
.
minStartTime
=
Infinity
;
this
.
maxEndTime
=
0
;
}
startTimeToDistance
:
function
(
time
containerWidth
)
{
time
-
=
this
.
minStartTime
;
return
this
.
durationToDistance
(
time
containerWidth
)
;
}
durationToDistance
:
function
(
duration
containerWidth
)
{
return
containerWidth
*
duration
/
(
this
.
maxEndTime
-
this
.
minStartTime
)
;
}
distanceToTime
:
function
(
distance
containerWidth
)
{
return
this
.
minStartTime
+
(
(
this
.
maxEndTime
-
this
.
minStartTime
)
*
distance
/
containerWidth
)
;
}
distanceToRelativeTime
:
function
(
distance
containerWidth
)
{
let
time
=
this
.
distanceToTime
(
distance
containerWidth
)
;
return
time
-
this
.
minStartTime
;
}
formatTime
:
function
(
time
)
{
let
duration
=
this
.
maxEndTime
-
this
.
minStartTime
;
if
(
duration
<
=
MILLIS_TIME_FORMAT_MAX_DURATION
)
{
return
L10N
.
getFormatStr
(
"
timeline
.
timeGraduationLabel
"
time
.
toFixed
(
0
)
)
;
}
return
L10N
.
getFormatStr
(
"
player
.
timeLabel
"
(
time
/
1000
)
.
toFixed
(
1
)
)
;
}
}
;
exports
.
TimeScale
=
TimeScale
;
function
AnimationsTimeline
(
inspector
)
{
this
.
animations
=
[
]
;
this
.
targetNodes
=
[
]
;
this
.
inspector
=
inspector
;
this
.
onAnimationStateChanged
=
this
.
onAnimationStateChanged
.
bind
(
this
)
;
this
.
onTimeHeaderMouseDown
=
this
.
onTimeHeaderMouseDown
.
bind
(
this
)
;
this
.
onTimeHeaderMouseUp
=
this
.
onTimeHeaderMouseUp
.
bind
(
this
)
;
this
.
onTimeHeaderMouseOut
=
this
.
onTimeHeaderMouseOut
.
bind
(
this
)
;
this
.
onTimeHeaderMouseMove
=
this
.
onTimeHeaderMouseMove
.
bind
(
this
)
;
EventEmitter
.
decorate
(
this
)
;
}
exports
.
AnimationsTimeline
=
AnimationsTimeline
;
AnimationsTimeline
.
prototype
=
{
init
:
function
(
containerEl
)
{
this
.
win
=
containerEl
.
ownerDocument
.
defaultView
;
this
.
rootWrapperEl
=
createNode
(
{
parent
:
containerEl
attributes
:
{
"
class
"
:
"
animation
-
timeline
"
}
}
)
;
this
.
scrubberEl
=
createNode
(
{
parent
:
this
.
rootWrapperEl
attributes
:
{
"
class
"
:
"
scrubber
"
}
}
)
;
this
.
timeHeaderEl
=
createNode
(
{
parent
:
this
.
rootWrapperEl
attributes
:
{
"
class
"
:
"
time
-
header
"
}
}
)
;
this
.
timeHeaderEl
.
addEventListener
(
"
mousedown
"
this
.
onTimeHeaderMouseDown
)
;
this
.
animationsEl
=
createNode
(
{
parent
:
this
.
rootWrapperEl
nodeType
:
"
ul
"
attributes
:
{
"
class
"
:
"
animations
"
}
}
)
;
}
destroy
:
function
(
)
{
this
.
stopAnimatingScrubber
(
)
;
this
.
unrender
(
)
;
this
.
timeHeaderEl
.
removeEventListener
(
"
mousedown
"
this
.
onTimeHeaderMouseDown
)
;
this
.
rootWrapperEl
.
remove
(
)
;
this
.
animations
=
[
]
;
this
.
rootWrapperEl
=
null
;
this
.
timeHeaderEl
=
null
;
this
.
animationsEl
=
null
;
this
.
scrubberEl
=
null
;
this
.
win
=
null
;
this
.
inspector
=
null
;
}
destroyTargetNodes
:
function
(
)
{
for
(
let
targetNode
of
this
.
targetNodes
)
{
targetNode
.
destroy
(
)
;
}
this
.
targetNodes
=
[
]
;
}
unrender
:
function
(
)
{
for
(
let
animation
of
this
.
animations
)
{
animation
.
off
(
"
changed
"
this
.
onAnimationStateChanged
)
;
}
TimeScale
.
reset
(
)
;
this
.
destroyTargetNodes
(
)
;
this
.
animationsEl
.
innerHTML
=
"
"
;
}
onTimeHeaderMouseDown
:
function
(
e
)
{
this
.
moveScrubberTo
(
e
.
pageX
)
;
this
.
win
.
addEventListener
(
"
mouseup
"
this
.
onTimeHeaderMouseUp
)
;
this
.
win
.
addEventListener
(
"
mouseout
"
this
.
onTimeHeaderMouseOut
)
;
this
.
win
.
addEventListener
(
"
mousemove
"
this
.
onTimeHeaderMouseMove
)
;
}
onTimeHeaderMouseUp
:
function
(
)
{
this
.
cancelTimeHeaderDragging
(
)
;
}
onTimeHeaderMouseOut
:
function
(
e
)
{
if
(
!
this
.
win
.
document
.
contains
(
e
.
relatedTarget
)
)
{
this
.
cancelTimeHeaderDragging
(
)
;
}
}
cancelTimeHeaderDragging
:
function
(
)
{
this
.
win
.
removeEventListener
(
"
mouseup
"
this
.
onTimeHeaderMouseUp
)
;
this
.
win
.
removeEventListener
(
"
mouseout
"
this
.
onTimeHeaderMouseOut
)
;
this
.
win
.
removeEventListener
(
"
mousemove
"
this
.
onTimeHeaderMouseMove
)
;
}
onTimeHeaderMouseMove
:
function
(
e
)
{
this
.
moveScrubberTo
(
e
.
pageX
)
;
}
moveScrubberTo
:
function
(
pageX
)
{
this
.
stopAnimatingScrubber
(
)
;
let
offset
=
pageX
-
this
.
scrubberEl
.
offsetWidth
;
if
(
offset
<
0
)
{
offset
=
0
;
}
this
.
scrubberEl
.
style
.
left
=
offset
+
"
px
"
;
let
time
=
TimeScale
.
distanceToRelativeTime
(
offset
this
.
timeHeaderEl
.
offsetWidth
)
;
this
.
emit
(
"
timeline
-
data
-
changed
"
{
isPaused
:
true
isMoving
:
false
time
:
time
}
)
;
}
render
:
function
(
animations
documentCurrentTime
)
{
this
.
unrender
(
)
;
this
.
animations
=
animations
;
if
(
!
this
.
animations
.
length
)
{
return
;
}
for
(
let
{
state
}
of
animations
)
{
TimeScale
.
addAnimation
(
state
)
;
}
this
.
drawHeaderAndBackground
(
)
;
for
(
let
animation
of
this
.
animations
)
{
animation
.
on
(
"
changed
"
this
.
onAnimationStateChanged
)
;
let
animationEl
=
createNode
(
{
parent
:
this
.
animationsEl
nodeType
:
"
li
"
attributes
:
{
"
class
"
:
"
animation
"
}
}
)
;
let
animatedNodeEl
=
createNode
(
{
parent
:
animationEl
attributes
:
{
"
class
"
:
"
target
"
}
}
)
;
let
timeBlockEl
=
createNode
(
{
parent
:
animationEl
attributes
:
{
"
class
"
:
"
time
-
block
"
}
}
)
;
this
.
drawTimeBlock
(
animation
timeBlockEl
)
;
let
targetNode
=
new
AnimationTargetNode
(
this
.
inspector
{
compact
:
true
}
)
;
targetNode
.
init
(
animatedNodeEl
)
;
targetNode
.
render
(
animation
)
;
this
.
targetNodes
.
push
(
targetNode
)
;
}
if
(
!
documentCurrentTime
)
{
this
.
scrubberEl
.
style
.
display
=
"
none
"
;
}
else
{
this
.
scrubberEl
.
style
.
display
=
"
block
"
;
this
.
startAnimatingScrubber
(
documentCurrentTime
)
;
}
}
isAtLeastOneAnimationPlaying
:
function
(
)
{
return
this
.
animations
.
some
(
(
{
state
}
)
=
>
state
.
playState
=
=
=
"
running
"
)
;
}
startAnimatingScrubber
:
function
(
time
)
{
let
x
=
TimeScale
.
startTimeToDistance
(
time
this
.
timeHeaderEl
.
offsetWidth
)
;
this
.
scrubberEl
.
style
.
left
=
x
+
"
px
"
;
if
(
time
<
TimeScale
.
minStartTime
|
|
time
>
TimeScale
.
maxEndTime
|
|
!
this
.
isAtLeastOneAnimationPlaying
(
)
)
{
this
.
stopAnimatingScrubber
(
)
;
this
.
emit
(
"
timeline
-
data
-
changed
"
{
isPaused
:
false
isMoving
:
false
time
:
TimeScale
.
distanceToRelativeTime
(
x
this
.
timeHeaderEl
.
offsetWidth
)
}
)
;
return
;
}
this
.
emit
(
"
timeline
-
data
-
changed
"
{
isPaused
:
false
isMoving
:
true
time
:
TimeScale
.
distanceToRelativeTime
(
x
this
.
timeHeaderEl
.
offsetWidth
)
}
)
;
let
now
=
this
.
win
.
performance
.
now
(
)
;
this
.
rafID
=
this
.
win
.
requestAnimationFrame
(
(
)
=
>
{
if
(
!
this
.
rafID
)
{
return
;
}
this
.
startAnimatingScrubber
(
time
+
this
.
win
.
performance
.
now
(
)
-
now
)
;
}
)
;
}
stopAnimatingScrubber
:
function
(
)
{
if
(
this
.
rafID
)
{
this
.
win
.
cancelAnimationFrame
(
this
.
rafID
)
;
this
.
rafID
=
null
;
}
}
onAnimationStateChanged
:
function
(
)
{
this
.
render
(
this
.
animations
)
;
}
drawHeaderAndBackground
:
function
(
)
{
let
width
=
this
.
timeHeaderEl
.
offsetWidth
;
let
scale
=
width
/
(
TimeScale
.
maxEndTime
-
TimeScale
.
minStartTime
)
;
drawGraphElementBackground
(
this
.
win
.
document
"
time
-
graduations
"
width
scale
)
;
this
.
timeHeaderEl
.
innerHTML
=
"
"
;
let
interval
=
findOptimalTimeInterval
(
scale
TIME_GRADUATION_MIN_SPACING
)
;
for
(
let
i
=
0
;
i
<
width
;
i
+
=
interval
)
{
createNode
(
{
parent
:
this
.
timeHeaderEl
nodeType
:
"
span
"
attributes
:
{
"
class
"
:
"
time
-
tick
"
"
style
"
:
left
:
{
i
}
px
}
textContent
:
TimeScale
.
formatTime
(
TimeScale
.
distanceToRelativeTime
(
i
width
)
)
}
)
;
}
}
getAnimationTooltipText
:
function
(
state
)
{
let
getTime
=
time
=
>
L10N
.
getFormatStr
(
"
player
.
timeLabel
"
L10N
.
numberWithDecimals
(
time
/
1000
2
)
)
;
let
title
=
L10N
.
getFormatStr
(
"
timeline
.
"
+
state
.
type
+
"
.
nameLabel
"
state
.
name
)
;
let
delay
=
L10N
.
getStr
(
"
player
.
animationDelayLabel
"
)
+
"
"
+
getTime
(
state
.
delay
)
;
let
duration
=
L10N
.
getStr
(
"
player
.
animationDurationLabel
"
)
+
"
"
+
getTime
(
state
.
duration
)
;
let
iterations
=
L10N
.
getStr
(
"
player
.
animationIterationCountLabel
"
)
+
"
"
+
(
state
.
iterationCount
|
|
L10N
.
getStr
(
"
player
.
infiniteIterationCountText
"
)
)
;
return
[
title
duration
iterations
delay
]
.
join
(
"
\
n
"
)
;
}
drawTimeBlock
:
function
(
{
state
}
el
)
{
let
width
=
el
.
offsetWidth
;
let
start
=
state
.
previousStartTime
|
|
0
;
let
duration
=
state
.
duration
;
let
rate
=
state
.
playbackRate
;
let
count
=
state
.
iterationCount
;
let
delay
=
state
.
delay
|
|
0
;
let
x
=
TimeScale
.
startTimeToDistance
(
start
+
(
delay
/
rate
)
width
)
;
let
w
=
TimeScale
.
durationToDistance
(
duration
/
rate
width
)
;
let
iterations
=
createNode
(
{
parent
:
el
attributes
:
{
"
class
"
:
state
.
type
+
"
iterations
"
+
(
count
?
"
"
:
"
infinite
"
)
"
style
"
:
left
:
{
x
}
px
;
width
:
{
w
*
(
count
|
|
1
)
}
px
;
background
-
size
:
{
Math
.
max
(
w
2
)
}
px
100
%
;
}
}
)
;
createNode
(
{
parent
:
iterations
attributes
:
{
"
class
"
:
"
name
"
"
title
"
:
this
.
getAnimationTooltipText
(
state
)
"
style
"
:
delay
<
0
?
"
margin
-
left
:
"
+
TimeScale
.
durationToDistance
(
Math
.
abs
(
delay
)
width
)
+
"
px
"
:
"
"
}
textContent
:
state
.
name
}
)
;
if
(
delay
)
{
let
x
=
TimeScale
.
durationToDistance
(
(
delay
<
0
?
0
:
delay
)
/
rate
width
)
;
let
w
=
TimeScale
.
durationToDistance
(
Math
.
abs
(
delay
)
/
rate
width
)
;
createNode
(
{
parent
:
iterations
attributes
:
{
"
class
"
:
"
delay
"
+
(
delay
<
0
?
"
negative
"
:
"
"
)
"
style
"
:
left
:
-
{
x
}
px
;
width
:
{
w
}
px
;
}
}
)
;
}
}
}
;
