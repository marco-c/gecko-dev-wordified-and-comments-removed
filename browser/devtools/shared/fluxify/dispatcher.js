"
use
strict
"
;
const
{
entries
compose
}
=
require
(
"
devtools
/
toolkit
/
DevToolsUtils
"
)
;
function
applyMiddleware
(
.
.
.
middlewares
)
{
return
next
=
>
stores
=
>
{
const
dispatcher
=
next
(
stores
)
;
let
dispatch
=
dispatcher
.
dispatch
;
const
api
=
{
getState
:
dispatcher
.
getState
dispatch
:
action
=
>
dispatch
(
action
)
}
;
const
chain
=
middlewares
.
map
(
middleware
=
>
middleware
(
api
)
)
;
dispatch
=
compose
(
.
.
.
chain
)
(
dispatcher
.
dispatch
)
;
return
Object
.
assign
(
{
}
dispatcher
{
dispatch
:
dispatch
}
)
;
}
}
function
createDispatcher
(
stores
)
{
const
state
=
{
}
;
const
listeners
=
{
}
;
let
enqueuedChanges
=
[
]
;
let
isDispatching
=
false
;
entries
(
stores
)
.
forEach
(
(
[
name
store
]
)
=
>
{
if
(
!
store
|
|
typeof
store
.
update
!
=
=
"
function
"
)
{
throw
new
Error
(
"
Error
creating
dispatcher
:
store
\
"
"
+
name
+
"
\
"
does
not
have
an
update
function
"
)
;
}
state
[
name
]
=
store
.
update
(
undefined
{
}
)
;
}
)
;
function
getState
(
)
{
return
state
;
}
function
emitChange
(
storeName
dataName
payload
)
{
enqueuedChanges
.
push
(
[
storeName
dataName
payload
]
)
;
}
function
onChange
(
paths
view
)
{
entries
(
paths
)
.
forEach
(
(
[
storeName
data
]
)
=
>
{
if
(
!
stores
[
storeName
]
)
{
throw
new
Error
(
"
Error
adding
onChange
handler
to
store
:
store
"
+
"
\
"
"
+
storeName
+
"
\
"
does
not
exist
"
)
;
}
if
(
!
listeners
[
storeName
]
)
{
listeners
[
storeName
]
=
[
]
;
}
if
(
typeof
data
=
=
'
function
'
)
{
listeners
[
storeName
]
.
push
(
data
.
bind
(
view
)
)
;
}
else
{
entries
(
data
)
.
forEach
(
(
[
watchedName
handler
]
)
=
>
{
listeners
[
storeName
]
.
push
(
(
payload
dataName
storeName
)
=
>
{
if
(
dataName
=
=
=
watchedName
)
{
handler
.
call
(
view
payload
dataName
storeName
)
;
}
}
)
;
}
)
;
}
}
)
;
}
function
flushChanges
(
)
{
enqueuedChanges
.
forEach
(
(
[
storeName
dataName
payload
]
)
=
>
{
if
(
listeners
[
storeName
]
)
{
listeners
[
storeName
]
.
forEach
(
listener
=
>
{
listener
(
payload
dataName
storeName
)
;
}
)
;
}
}
)
;
enqueuedChanges
=
[
]
;
}
function
dispatch
(
action
)
{
if
(
isDispatching
)
{
throw
new
Error
(
'
Cannot
dispatch
in
the
middle
of
a
dispatch
'
)
;
}
if
(
!
action
.
type
)
{
throw
new
Error
(
'
action
type
is
null
'
+
'
did
you
make
a
typo
when
publishing
this
action
?
'
+
JSON
.
stringify
(
action
null
2
)
)
;
}
isDispatching
=
true
;
try
{
entries
(
stores
)
.
forEach
(
(
[
name
store
]
)
=
>
{
state
[
name
]
=
store
.
update
(
state
[
name
]
action
emitChange
.
bind
(
null
name
)
)
;
}
)
;
}
finally
{
isDispatching
=
false
;
}
flushChanges
(
)
;
}
return
{
getState
dispatch
onChange
}
;
}
module
.
exports
=
{
createDispatcher
:
createDispatcher
applyMiddleware
:
applyMiddleware
}
;
