"
use
strict
"
;
const
{
Cu
Ci
}
=
require
(
"
chrome
"
)
;
loader
.
lazyRequireGetter
(
this
"
L10N
"
"
devtools
/
performance
/
global
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
PREFS
"
"
devtools
/
performance
/
global
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
TIMELINE_BLUEPRINT
"
"
devtools
/
performance
/
markers
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
WebConsoleUtils
"
"
devtools
/
toolkit
/
webconsole
/
utils
"
)
;
const
GECKO_SYMBOL
=
"
(
Gecko
)
"
;
function
isMarkerValid
(
marker
filter
)
{
if
(
!
filter
|
|
filter
.
length
=
=
=
0
)
{
return
true
;
}
let
isUnknown
=
!
(
marker
.
name
in
TIMELINE_BLUEPRINT
)
;
if
(
isUnknown
)
{
return
filter
.
indexOf
(
"
UNKNOWN
"
)
=
=
=
-
1
;
}
return
filter
.
indexOf
(
marker
.
name
)
=
=
=
-
1
;
}
function
getMarkerLabel
(
marker
)
{
let
blueprint
=
getBlueprintFor
(
marker
)
;
return
typeof
blueprint
.
label
=
=
=
"
function
"
?
blueprint
.
label
(
marker
)
:
blueprint
.
label
;
}
function
getMarkerClassName
(
type
)
{
let
blueprint
=
getBlueprintFor
(
{
name
:
type
}
)
;
let
className
=
typeof
blueprint
.
label
=
=
=
"
function
"
?
blueprint
.
label
(
)
:
blueprint
.
label
;
if
(
!
className
)
{
let
message
=
Could
not
find
marker
class
name
for
"
{
type
}
"
.
;
if
(
typeof
blueprint
.
label
=
=
=
"
function
"
)
{
message
+
=
The
following
function
must
return
a
class
name
string
when
no
marker
passed
:
{
blueprint
.
label
}
;
}
else
{
message
+
=
{
type
}
.
label
must
be
defined
in
the
marker
blueprint
.
;
}
throw
new
Error
(
message
)
;
}
return
className
;
}
function
getMarkerFields
(
marker
)
{
let
blueprint
=
getBlueprintFor
(
marker
)
;
if
(
typeof
blueprint
.
fields
=
=
=
"
function
"
)
{
let
fields
=
blueprint
.
fields
(
marker
)
;
return
Object
.
keys
(
fields
|
|
[
]
)
.
map
(
label
=
>
{
return
{
label
value
:
fields
[
label
]
}
;
}
)
;
}
return
(
blueprint
.
fields
|
|
[
]
)
.
reduce
(
(
fields
field
)
=
>
{
if
(
field
.
property
in
marker
)
{
let
label
=
field
.
label
;
let
value
=
marker
[
field
.
property
]
;
fields
.
push
(
{
label
value
}
)
;
}
return
fields
;
}
[
]
)
;
}
const
DOM
=
{
buildFields
:
function
(
doc
marker
)
{
let
blueprint
=
getBlueprintFor
(
marker
)
;
let
fields
=
getMarkerFields
(
marker
)
;
return
fields
.
map
(
(
{
label
value
}
)
=
>
DOM
.
buildNameValueLabel
(
doc
label
value
)
)
;
}
buildTitle
:
function
(
doc
marker
)
{
let
blueprint
=
getBlueprintFor
(
marker
)
;
let
hbox
=
doc
.
createElement
(
"
hbox
"
)
;
hbox
.
setAttribute
(
"
align
"
"
center
"
)
;
let
bullet
=
doc
.
createElement
(
"
hbox
"
)
;
bullet
.
className
=
marker
-
details
-
bullet
marker
-
color
-
{
blueprint
.
colorName
}
;
let
title
=
getMarkerLabel
(
marker
)
;
let
label
=
doc
.
createElement
(
"
label
"
)
;
label
.
className
=
"
marker
-
details
-
type
"
;
label
.
setAttribute
(
"
value
"
title
)
;
hbox
.
appendChild
(
bullet
)
;
hbox
.
appendChild
(
label
)
;
return
hbox
;
}
buildDuration
:
function
(
doc
marker
)
{
let
label
=
L10N
.
getStr
(
"
marker
.
field
.
duration
"
)
;
let
start
=
L10N
.
getFormatStrWithNumbers
(
"
timeline
.
tick
"
marker
.
start
)
;
let
end
=
L10N
.
getFormatStrWithNumbers
(
"
timeline
.
tick
"
marker
.
end
)
;
let
duration
=
L10N
.
getFormatStrWithNumbers
(
"
timeline
.
tick
"
marker
.
end
-
marker
.
start
)
;
let
el
=
DOM
.
buildNameValueLabel
(
doc
label
duration
)
;
el
.
classList
.
add
(
"
marker
-
details
-
duration
"
)
;
el
.
setAttribute
(
"
tooltiptext
"
{
start
}
{
end
}
)
;
return
el
;
}
buildNameValueLabel
:
function
(
doc
field
value
)
{
let
hbox
=
doc
.
createElement
(
"
hbox
"
)
;
hbox
.
className
=
"
marker
-
details
-
labelcontainer
"
;
let
labelName
=
doc
.
createElement
(
"
label
"
)
;
let
labelValue
=
doc
.
createElement
(
"
label
"
)
;
labelName
.
className
=
"
plain
marker
-
details
-
labelname
"
;
labelValue
.
className
=
"
plain
marker
-
details
-
labelvalue
"
;
labelName
.
setAttribute
(
"
value
"
field
)
;
labelValue
.
setAttribute
(
"
value
"
value
)
;
hbox
.
appendChild
(
labelName
)
;
hbox
.
appendChild
(
labelValue
)
;
return
hbox
;
}
buildStackTrace
:
function
(
doc
{
type
frameIndex
frames
}
)
{
let
container
=
doc
.
createElement
(
"
vbox
"
)
;
let
labelName
=
doc
.
createElement
(
"
label
"
)
;
labelName
.
className
=
"
plain
marker
-
details
-
labelname
"
;
labelName
.
setAttribute
(
"
value
"
L10N
.
getStr
(
marker
.
field
.
{
type
}
)
)
;
container
.
setAttribute
(
"
type
"
type
)
;
container
.
className
=
"
marker
-
details
-
stack
"
;
container
.
appendChild
(
labelName
)
;
let
wasAsyncParent
=
false
;
while
(
frameIndex
>
0
)
{
let
frame
=
frames
[
frameIndex
]
;
let
url
=
frame
.
source
;
let
displayName
=
frame
.
functionDisplayName
;
let
line
=
frame
.
line
;
if
(
wasAsyncParent
)
{
let
asyncBox
=
doc
.
createElement
(
"
hbox
"
)
;
let
asyncLabel
=
doc
.
createElement
(
"
label
"
)
;
asyncLabel
.
className
=
"
devtools
-
monospace
"
;
asyncLabel
.
setAttribute
(
"
value
"
L10N
.
getFormatStr
(
"
marker
.
field
.
asyncStack
"
frame
.
asyncCause
)
)
;
asyncBox
.
appendChild
(
asyncLabel
)
;
container
.
appendChild
(
asyncBox
)
;
wasAsyncParent
=
false
;
}
let
hbox
=
doc
.
createElement
(
"
hbox
"
)
;
if
(
displayName
)
{
let
functionLabel
=
doc
.
createElement
(
"
label
"
)
;
functionLabel
.
className
=
"
devtools
-
monospace
"
;
functionLabel
.
setAttribute
(
"
value
"
displayName
)
;
hbox
.
appendChild
(
functionLabel
)
;
}
if
(
url
)
{
let
aNode
=
doc
.
createElement
(
"
a
"
)
;
aNode
.
className
=
"
waterfall
-
marker
-
location
devtools
-
source
-
link
"
;
aNode
.
href
=
url
;
aNode
.
draggable
=
false
;
aNode
.
setAttribute
(
"
title
"
url
)
;
let
urlNode
=
doc
.
createElement
(
"
label
"
)
;
urlNode
.
className
=
"
filename
"
;
urlNode
.
setAttribute
(
"
value
"
WebConsoleUtils
.
Utils
.
abbreviateSourceURL
(
url
)
)
;
let
lineNode
=
doc
.
createElement
(
"
label
"
)
;
lineNode
.
className
=
"
line
-
number
"
;
lineNode
.
setAttribute
(
"
value
"
:
{
line
}
)
;
aNode
.
appendChild
(
urlNode
)
;
aNode
.
appendChild
(
lineNode
)
;
hbox
.
appendChild
(
aNode
)
;
aNode
.
setAttribute
(
"
data
-
action
"
JSON
.
stringify
(
{
url
line
action
:
"
view
-
source
"
}
)
)
;
}
if
(
!
displayName
&
&
!
url
)
{
let
label
=
doc
.
createElement
(
"
label
"
)
;
label
.
setAttribute
(
"
value
"
L10N
.
getStr
(
"
marker
.
value
.
unknownFrame
"
)
)
;
hbox
.
appendChild
(
label
)
;
}
container
.
appendChild
(
hbox
)
;
if
(
frame
.
asyncParent
)
{
frameIndex
=
frame
.
asyncParent
;
wasAsyncParent
=
true
;
}
else
{
frameIndex
=
frame
.
parent
;
}
}
return
container
;
}
}
;
const
JS_MARKER_MAP
=
{
"
<
script
>
element
"
:
L10N
.
getStr
(
"
marker
.
label
.
javascript
.
scriptElement
"
)
"
promise
callback
"
:
L10N
.
getStr
(
"
marker
.
label
.
javascript
.
promiseCallback
"
)
"
promise
initializer
"
:
L10N
.
getStr
(
"
marker
.
label
.
javascript
.
promiseInit
"
)
"
Worker
runnable
"
:
L10N
.
getStr
(
"
marker
.
label
.
javascript
.
workerRunnable
"
)
"
javascript
:
URI
"
:
L10N
.
getStr
(
"
marker
.
label
.
javascript
.
jsURI
"
)
"
EventHandlerNonNull
"
:
L10N
.
getStr
(
"
marker
.
label
.
javascript
.
eventHandler
"
)
"
EventListener
.
handleEvent
"
:
L10N
.
getStr
(
"
marker
.
label
.
javascript
.
eventHandler
"
)
"
setInterval
handler
"
:
"
setInterval
"
"
setTimeout
handler
"
:
"
setTimeout
"
"
FrameRequestCallback
"
:
"
requestAnimationFrame
"
}
;
const
Formatters
=
{
UnknownLabel
:
function
(
marker
=
{
}
)
{
return
marker
.
name
|
|
L10N
.
getStr
(
"
marker
.
label
.
unknown
"
)
;
}
GCLabel
:
function
(
marker
=
{
}
)
{
if
(
"
nonincrementalReason
"
in
marker
)
{
return
L10N
.
getStr
(
"
marker
.
label
.
garbageCollection
.
nonIncremental
"
)
;
}
return
L10N
.
getStr
(
"
marker
.
label
.
garbageCollection
"
)
;
}
JSLabel
:
function
(
marker
=
{
}
)
{
let
generic
=
L10N
.
getStr
(
"
marker
.
label
.
javascript
"
)
;
if
(
"
causeName
"
in
marker
)
{
return
JS_MARKER_MAP
[
marker
.
causeName
]
|
|
generic
;
}
return
generic
;
}
DOMJSLabel
:
function
(
marker
=
{
}
)
{
return
Event
(
{
marker
.
type
}
)
;
}
JSFields
:
function
(
marker
)
{
if
(
"
causeName
"
in
marker
&
&
!
JS_MARKER_MAP
[
marker
.
causeName
]
)
{
let
cause
=
PREFS
[
"
show
-
platform
-
data
"
]
?
marker
.
causeName
:
GECKO_SYMBOL
;
return
{
[
L10N
.
getStr
(
"
marker
.
field
.
causeName
"
)
]
:
cause
}
;
}
}
GCFields
:
function
(
marker
)
{
let
fields
=
Object
.
create
(
null
)
;
let
cause
=
marker
.
cause
;
let
label
=
L10N
.
getStr
(
marker
.
gcreason
.
label
.
{
cause
}
)
|
|
cause
;
fields
[
L10N
.
getStr
(
"
marker
.
field
.
causeName
"
)
]
=
label
;
if
(
"
nonincrementalReason
"
in
marker
)
{
fields
[
L10N
.
getStr
(
"
marker
.
field
.
nonIncrementalCause
"
)
]
=
marker
.
nonincrementalReason
;
}
return
fields
;
}
DOMEventFields
:
function
(
marker
)
{
let
fields
=
Object
.
create
(
null
)
;
if
(
"
type
"
in
marker
)
{
fields
[
L10N
.
getStr
(
"
marker
.
field
.
DOMEventType
"
)
]
=
marker
.
type
;
}
if
(
"
eventPhase
"
in
marker
)
{
let
phase
;
if
(
marker
.
eventPhase
=
=
=
Ci
.
nsIDOMEvent
.
AT_TARGET
)
{
phase
=
L10N
.
getStr
(
"
marker
.
value
.
DOMEventTargetPhase
"
)
;
}
else
if
(
marker
.
eventPhase
=
=
=
Ci
.
nsIDOMEvent
.
CAPTURING_PHASE
)
{
phase
=
L10N
.
getStr
(
"
marker
.
value
.
DOMEventCapturingPhase
"
)
;
}
else
if
(
marker
.
eventPhase
=
=
=
Ci
.
nsIDOMEvent
.
BUBBLING_PHASE
)
{
phase
=
L10N
.
getStr
(
"
marker
.
value
.
DOMEventBubblingPhase
"
)
;
}
fields
[
L10N
.
getStr
(
"
marker
.
field
.
DOMEventPhase
"
)
]
=
phase
;
}
return
fields
;
}
StylesFields
:
function
(
marker
)
{
if
(
"
restyleHint
"
in
marker
)
{
return
{
[
L10N
.
getStr
(
"
marker
.
field
.
restyleHint
"
)
]
:
marker
.
restyleHint
.
replace
(
/
eRestyle_
/
g
"
"
)
}
;
}
}
CycleCollectionFields
:
function
(
marker
)
{
return
{
[
L10N
.
getStr
(
"
marker
.
field
.
type
"
)
]
:
marker
.
name
.
replace
(
/
nsCycleCollector
:
:
/
g
"
"
)
}
;
}
}
;
function
getBlueprintFor
(
marker
)
{
return
TIMELINE_BLUEPRINT
[
marker
.
name
]
|
|
TIMELINE_BLUEPRINT
.
UNKNOWN
;
}
exports
.
isMarkerValid
=
isMarkerValid
;
exports
.
getMarkerLabel
=
getMarkerLabel
;
exports
.
getMarkerClassName
=
getMarkerClassName
;
exports
.
getMarkerFields
=
getMarkerFields
;
exports
.
DOM
=
DOM
;
exports
.
Formatters
=
Formatters
;
exports
.
getBlueprintFor
=
getBlueprintFor
;
