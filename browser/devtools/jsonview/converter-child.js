"
use
strict
"
;
const
Cu
=
Components
.
utils
;
const
Ci
=
Components
.
interfaces
;
const
Cc
=
Components
.
classes
;
const
{
devtools
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
devtools
/
Loader
.
jsm
"
{
}
)
;
const
{
Services
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
{
}
)
;
let
require
=
devtools
.
require
;
const
{
Class
}
=
require
(
"
sdk
/
core
/
heritage
"
)
;
const
{
Unknown
}
=
require
(
"
sdk
/
platform
/
xpcom
"
)
;
const
xpcom
=
require
(
"
sdk
/
platform
/
xpcom
"
)
;
const
Events
=
require
(
"
sdk
/
dom
/
events
"
)
;
const
Clipboard
=
require
(
"
sdk
/
clipboard
"
)
;
const
NetworkHelper
=
require
(
"
devtools
/
toolkit
/
webconsole
/
network
-
helper
"
)
;
const
JsonViewUtils
=
require
(
"
devtools
/
jsonview
/
utils
"
)
;
let
childProcessMessageManager
=
Cc
[
"
mozilla
.
org
/
childprocessmessagemanager
;
1
"
]
.
getService
(
Ci
.
nsISyncMessageSender
)
;
const
SEGMENT_SIZE
=
Math
.
pow
(
2
17
)
;
var
jsonViewStrings
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
browser
/
locale
/
devtools
/
jsonview
.
properties
"
)
;
var
Converter
=
Class
(
{
extends
:
Unknown
interfaces
:
[
"
nsIStreamConverter
"
"
nsIStreamListener
"
"
nsIRequestObserver
"
]
get
wrappedJSObject
(
)
this
convert
:
function
(
aFromStream
aFromType
aToType
aCtxt
)
{
return
aFromStream
;
}
asyncConvertData
:
function
(
aFromType
aToType
aListener
aCtxt
)
{
this
.
listener
=
aListener
;
}
onDataAvailable
:
function
(
aRequest
aContext
aInputStream
aOffset
aCount
)
{
var
is
=
Cc
[
"
mozilla
.
org
/
intl
/
converter
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIConverterInputStream
)
;
is
.
init
(
aInputStream
this
.
charset
-
1
Ci
.
nsIConverterInputStream
.
DEFAULT_REPLACEMENT_CHARACTER
)
;
var
bytesRead
=
1
;
while
(
aCount
)
{
var
str
=
{
}
;
var
bytesRead
=
is
.
readString
(
aCount
str
)
;
if
(
!
bytesRead
)
{
throw
new
Error
(
"
Stream
converter
failed
to
read
the
input
stream
!
"
)
;
}
aCount
-
=
bytesRead
;
this
.
data
+
=
str
.
value
;
}
}
onStartRequest
:
function
(
aRequest
aContext
)
{
this
.
data
=
"
"
;
this
.
uri
=
aRequest
.
QueryInterface
(
Ci
.
nsIChannel
)
.
URI
.
spec
;
this
.
charset
=
aRequest
.
QueryInterface
(
Ci
.
nsIChannel
)
.
contentCharset
|
|
'
UTF
-
8
'
;
this
.
channel
=
aRequest
;
this
.
channel
.
contentType
=
"
text
/
html
"
;
this
.
channel
.
contentCharset
=
"
UTF
-
8
"
;
this
.
listener
.
onStartRequest
(
this
.
channel
aContext
)
;
}
onStopRequest
:
function
(
aRequest
aContext
aStatusCode
)
{
let
headers
=
{
response
:
[
]
request
:
[
]
}
if
(
!
(
aRequest
instanceof
Ci
.
nsIHttpChannel
)
)
{
return
;
}
let
win
=
NetworkHelper
.
getWindowForRequest
(
aRequest
)
;
let
Locale
=
{
STR
:
key
=
>
{
try
{
return
jsonViewStrings
.
GetStringFromName
(
key
)
;
}
catch
(
err
)
{
Cu
.
reportError
(
err
)
;
}
}
}
;
JsonViewUtils
.
exportIntoContentScope
(
win
Locale
"
Locale
"
)
;
Events
.
once
(
win
"
DOMContentLoaded
"
event
=
>
{
Cu
.
exportFunction
(
this
.
postChromeMessage
.
bind
(
this
)
win
{
defineAs
:
"
postChromeMessage
"
}
)
;
}
)
aRequest
.
visitResponseHeaders
(
{
visitHeader
:
function
(
name
value
)
{
headers
.
response
.
push
(
{
name
:
name
value
:
value
}
)
;
}
}
)
;
aRequest
.
visitRequestHeaders
(
{
visitHeader
:
function
(
name
value
)
{
headers
.
request
.
push
(
{
name
:
name
value
:
value
}
)
;
}
}
)
;
let
outputDoc
=
"
"
;
try
{
headers
=
JSON
.
stringify
(
headers
)
;
outputDoc
=
this
.
toHTML
(
this
.
data
headers
this
.
uri
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
"
JSON
Viewer
ERROR
"
+
e
)
;
outputDoc
=
this
.
toErrorPage
(
e
this
.
data
this
.
uri
)
;
}
var
storage
=
Cc
[
"
mozilla
.
org
/
storagestream
;
1
"
]
.
createInstance
(
Ci
.
nsIStorageStream
)
;
storage
.
init
(
SEGMENT_SIZE
0xffffffff
null
)
;
var
out
=
storage
.
getOutputStream
(
0
)
;
var
binout
=
Cc
[
"
mozilla
.
org
/
binaryoutputstream
;
1
"
]
.
createInstance
(
Ci
.
nsIBinaryOutputStream
)
;
binout
.
setOutputStream
(
out
)
;
binout
.
writeUtf8Z
(
outputDoc
)
;
binout
.
close
(
)
;
var
trunc
=
4
;
var
instream
=
storage
.
newInputStream
(
trunc
)
;
this
.
listener
.
onDataAvailable
(
this
.
channel
aContext
instream
0
instream
.
available
(
)
)
;
this
.
listener
.
onStopRequest
(
this
.
channel
aContext
aStatusCode
)
;
this
.
listener
=
null
;
}
htmlEncode
:
function
(
t
)
{
return
t
!
=
=
null
?
t
.
toString
(
)
.
replace
(
/
&
/
g
"
&
amp
;
"
)
.
replace
(
/
"
/
g
"
&
quot
;
"
)
.
replace
(
/
<
/
g
"
&
lt
;
"
)
.
replace
(
/
>
/
g
"
&
gt
;
"
)
:
'
'
;
}
toHTML
:
function
(
json
headers
title
)
{
var
themeClassName
=
"
theme
-
"
+
JsonViewUtils
.
getCurrentTheme
(
)
;
var
baseUrl
=
"
resource
:
/
/
/
modules
/
devtools
/
jsonview
/
"
;
var
theme
=
(
themeClassName
=
=
"
theme
-
light
"
)
?
"
light
"
:
"
dark
"
;
var
themeUrl
=
'
<
link
rel
=
"
stylesheet
"
type
=
"
text
/
css
"
'
+
'
href
=
"
chrome
:
/
/
browser
/
skin
/
devtools
/
'
+
theme
+
'
-
theme
.
css
"
>
'
;
return
'
<
!
DOCTYPE
html
>
\
n
'
+
'
<
html
>
<
head
>
<
title
>
'
+
this
.
htmlEncode
(
title
)
+
'
<
/
title
>
'
+
'
<
base
href
=
"
'
+
this
.
htmlEncode
(
baseUrl
)
+
'
"
>
'
+
'
<
link
rel
=
"
stylesheet
"
type
=
"
text
/
css
"
href
=
"
css
/
main
.
css
"
>
'
+
themeUrl
+
'
<
script
data
-
main
=
"
viewer
-
config
"
src
=
"
lib
/
require
.
js
"
>
<
/
script
>
'
+
'
<
/
head
>
<
body
class
=
"
'
+
themeClassName
+
'
"
>
'
+
'
<
div
id
=
"
content
"
>
<
/
div
>
'
+
'
<
div
id
=
"
json
"
>
'
+
this
.
htmlEncode
(
json
)
+
'
<
/
div
>
'
+
'
<
div
id
=
"
headers
"
>
'
+
this
.
htmlEncode
(
headers
)
+
'
<
/
div
>
'
+
'
<
/
body
>
<
/
html
>
'
;
}
toErrorPage
:
function
(
error
data
uri
)
{
data
=
data
.
replace
(
"
\
u0000
"
"
\
uFFFD
"
)
;
var
errorInfo
=
error
+
"
"
;
var
output
=
'
<
div
id
=
"
error
"
>
'
+
_
(
'
errorParsing
'
)
if
(
errorInfo
.
message
)
{
output
+
=
'
<
div
class
=
"
errormessage
"
>
'
+
errorInfo
.
message
+
'
<
/
div
>
'
;
}
output
+
=
'
<
/
div
>
<
div
id
=
"
json
"
>
'
+
this
.
highlightError
(
data
errorInfo
.
line
errorInfo
.
column
)
+
'
<
/
div
>
'
;
return
'
<
!
DOCTYPE
html
>
\
n
'
+
'
<
html
>
<
head
>
<
title
>
'
+
this
.
htmlEncode
(
uri
+
'
-
Error
'
)
+
'
<
/
title
>
'
+
'
<
base
href
=
"
'
+
this
.
htmlEncode
(
self
.
data
.
url
(
)
)
+
'
"
>
'
+
'
<
/
head
>
<
body
>
'
+
output
+
'
<
/
body
>
<
/
html
>
'
;
}
postChromeMessage
:
function
(
type
args
objects
)
{
var
value
=
args
;
switch
(
type
)
{
case
"
copy
"
:
Clipboard
.
set
(
value
"
text
"
)
;
break
;
case
"
copy
-
headers
"
:
this
.
copyHeaders
(
value
)
;
break
;
case
"
save
"
:
childProcessMessageManager
.
sendAsyncMessage
(
"
devtools
:
jsonview
:
save
"
value
)
;
}
}
copyHeaders
:
function
(
headers
)
{
var
value
=
"
"
;
var
eol
=
(
Services
.
appinfo
.
OS
!
=
=
"
WINNT
"
)
?
"
\
n
"
:
"
\
r
\
n
"
;
var
responseHeaders
=
headers
.
response
;
for
(
var
i
=
0
;
i
<
responseHeaders
.
length
;
i
+
+
)
{
var
header
=
responseHeaders
[
i
]
;
value
+
=
header
.
name
+
"
:
"
+
header
.
value
+
eol
;
}
value
+
=
eol
;
var
requestHeaders
=
headers
.
request
;
for
(
var
i
=
0
;
i
<
requestHeaders
.
length
;
i
+
+
)
{
var
header
=
requestHeaders
[
i
]
;
value
+
=
header
.
name
+
"
:
"
+
header
.
value
+
eol
;
}
Clipboard
.
set
(
value
"
text
"
)
;
}
}
)
;
const
JSON_TYPE
=
"
application
/
json
"
;
const
CONTRACT_ID
=
"
mozilla
.
org
/
streamconv
;
1
?
from
=
"
+
JSON_TYPE
+
"
&
to
=
*
/
*
"
;
const
CLASS_ID
=
"
{
d8c9acee
-
dec5
-
11e4
-
8c75
-
1681e6b88ec1
}
"
;
const
GECKO_VIEWER
=
"
Gecko
-
Content
-
Viewers
"
;
var
service
=
xpcom
.
Service
(
{
id
:
Components
.
ID
(
CLASS_ID
)
contract
:
CONTRACT_ID
Component
:
Converter
register
:
false
unregister
:
false
}
)
;
if
(
!
xpcom
.
isRegistered
(
service
)
)
{
xpcom
.
register
(
service
)
;
}
var
categoryManager
=
Cc
[
"
mozilla
.
org
/
categorymanager
;
1
"
]
.
getService
(
Ci
.
nsICategoryManager
)
;
categoryManager
.
deleteCategoryEntry
(
GECKO_VIEWER
JSON_TYPE
false
)
;
categoryManager
.
addCategoryEntry
(
"
ext
-
to
-
type
-
mapping
"
"
json
"
JSON_TYPE
false
true
)
;
