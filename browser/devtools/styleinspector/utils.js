"
use
strict
"
;
const
{
Cc
Ci
Cu
}
=
require
(
"
chrome
"
)
;
const
{
setTimeout
clearTimeout
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
{
}
)
;
const
{
parseDeclarations
}
=
require
(
"
devtools
/
styleinspector
/
css
-
parsing
-
utils
"
)
;
const
promise
=
require
(
"
promise
"
)
;
loader
.
lazyServiceGetter
(
this
"
domUtils
"
"
mozilla
.
org
/
inspector
/
dom
-
utils
;
1
"
"
inIDOMUtils
"
)
;
const
HTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
function
createChild
(
parent
tagName
attributes
=
{
}
)
{
let
elt
=
parent
.
ownerDocument
.
createElementNS
(
HTML_NS
tagName
)
;
for
(
let
attr
in
attributes
)
{
if
(
attributes
.
hasOwnProperty
(
attr
)
)
{
if
(
attr
=
=
=
"
textContent
"
)
{
elt
.
textContent
=
attributes
[
attr
]
;
}
else
if
(
attr
=
=
=
"
child
"
)
{
elt
.
appendChild
(
attributes
[
attr
]
)
;
}
else
{
elt
.
setAttribute
(
attr
attributes
[
attr
]
)
;
}
}
}
parent
.
appendChild
(
elt
)
;
return
elt
;
}
exports
.
createChild
=
createChild
;
function
appendText
(
parent
text
)
{
parent
.
appendChild
(
parent
.
ownerDocument
.
createTextNode
(
text
)
)
;
}
exports
.
appendText
=
appendText
;
function
advanceValidate
(
keyCode
value
insertionPoint
)
{
if
(
keyCode
!
=
=
Ci
.
nsIDOMKeyEvent
.
DOM_VK_SEMICOLON
)
{
return
false
;
}
value
=
value
.
slice
(
0
insertionPoint
)
+
"
;
"
+
value
.
slice
(
insertionPoint
)
;
let
lexer
=
domUtils
.
getCSSLexer
(
value
)
;
while
(
true
)
{
let
token
=
lexer
.
nextToken
(
)
;
if
(
token
.
endOffset
>
insertionPoint
)
{
if
(
token
.
tokenType
=
=
=
"
symbol
"
&
&
token
.
text
=
=
=
"
;
"
)
{
return
true
;
}
break
;
}
}
return
false
;
}
exports
.
advanceValidate
=
advanceValidate
;
function
throttle
(
func
wait
scope
)
{
let
timer
=
null
;
return
function
(
)
{
if
(
timer
)
{
clearTimeout
(
timer
)
;
}
let
args
=
arguments
;
timer
=
setTimeout
(
function
(
)
{
timer
=
null
;
func
.
apply
(
scope
args
)
;
}
wait
)
;
}
;
}
exports
.
throttle
=
throttle
;
function
blurOnMultipleProperties
(
e
)
{
setTimeout
(
(
)
=
>
{
let
props
=
parseDeclarations
(
e
.
target
.
value
)
;
if
(
props
.
length
>
1
)
{
e
.
target
.
blur
(
)
;
}
}
0
)
;
}
exports
.
blurOnMultipleProperties
=
blurOnMultipleProperties
;
function
promiseWarn
(
error
)
{
console
.
error
(
error
)
;
return
promise
.
reject
(
error
)
;
}
exports
.
promiseWarn
=
promiseWarn
;
