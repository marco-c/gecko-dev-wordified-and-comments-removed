"
use
strict
"
;
const
{
Cc
Ci
Cu
}
=
require
(
"
chrome
"
)
;
const
promise
=
require
(
"
promise
"
)
;
const
{
setTimeout
clearTimeout
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
{
}
)
;
const
{
CssLogic
}
=
require
(
"
devtools
/
styleinspector
/
css
-
logic
"
)
;
const
{
InplaceEditor
editableField
editableItem
}
=
require
(
"
devtools
/
shared
/
inplace
-
editor
"
)
;
const
{
ELEMENT_STYLE
PSEUDO_ELEMENTS
}
=
require
(
"
devtools
/
server
/
actors
/
styles
"
)
;
const
{
OutputParser
}
=
require
(
"
devtools
/
output
-
parser
"
)
;
const
{
PrefObserver
PREF_ORIG_SOURCES
}
=
require
(
"
devtools
/
styleeditor
/
utils
"
)
;
const
{
createChild
appendText
advanceValidate
blurOnMultipleProperties
promiseWarn
throttle
}
=
require
(
"
devtools
/
styleinspector
/
utils
"
)
;
const
{
parseDeclarations
parseSingleValue
parsePseudoClassesAndAttributes
SELECTOR_ATTRIBUTE
SELECTOR_ELEMENT
SELECTOR_PSEUDO_CLASS
}
=
require
(
"
devtools
/
styleinspector
/
css
-
parsing
-
utils
"
)
;
loader
.
lazyRequireGetter
(
this
"
overlays
"
"
devtools
/
styleinspector
/
style
-
inspector
-
overlays
"
)
;
loader
.
lazyRequireGetter
(
this
"
EventEmitter
"
"
devtools
/
toolkit
/
event
-
emitter
"
)
;
loader
.
lazyRequireGetter
(
this
"
StyleInspectorMenu
"
"
devtools
/
styleinspector
/
style
-
inspector
-
menu
"
)
;
loader
.
lazyImporter
(
this
"
Services
"
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
HTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
const
XUL_NS
=
"
http
:
/
/
www
.
mozilla
.
org
/
keymaster
/
gatekeeper
/
there
.
is
.
only
.
xul
"
;
const
PREF_UA_STYLES
=
"
devtools
.
inspector
.
showUserAgentStyles
"
;
const
PREF_DEFAULT_COLOR_UNIT
=
"
devtools
.
defaultColorUnit
"
;
const
PREF_ENABLE_MDN_DOCS_TOOLTIP
=
"
devtools
.
inspector
.
mdnDocsTooltip
.
enabled
"
;
const
PROPERTY_NAME_CLASS
=
"
ruleview
-
propertyname
"
;
const
FILTER_CHANGED_TIMEOUT
=
150
;
const
FILTER_PROP_RE
=
/
\
s
*
(
[
^
:
\
s
]
*
)
\
s
*
:
\
s
*
(
.
*
?
)
\
s
*
;
?
/
;
const
FILTER_STRICT_RE
=
/
\
s
*
(
.
*
?
)
\
s
*
/
;
const
IOService
=
Cc
[
"
mozilla
.
org
/
network
/
io
-
service
;
1
"
]
.
getService
(
Ci
.
nsIIOService
)
;
let
gDummyPromise
;
function
createDummyDocument
(
)
{
if
(
gDummyPromise
)
{
return
gDummyPromise
;
}
const
{
getDocShell
create
:
makeFrame
}
=
require
(
"
sdk
/
frame
/
utils
"
)
;
let
frame
=
makeFrame
(
Services
.
appShell
.
hiddenDOMWindow
.
document
{
nodeName
:
"
iframe
"
namespaceURI
:
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
allowJavascript
:
false
allowPlugins
:
false
allowAuth
:
false
}
)
;
let
docShell
=
getDocShell
(
frame
)
;
let
eventTarget
=
docShell
.
chromeEventHandler
;
docShell
.
createAboutBlankContentViewer
(
Cc
[
"
mozilla
.
org
/
nullprincipal
;
1
"
]
.
createInstance
(
Ci
.
nsIPrincipal
)
)
;
let
window
=
docShell
.
contentViewer
.
DOMDocument
.
defaultView
;
window
.
location
=
"
data
:
text
/
html
<
html
>
<
/
html
>
"
;
let
deferred
=
promise
.
defer
(
)
;
eventTarget
.
addEventListener
(
"
DOMContentLoaded
"
function
handler
(
)
{
eventTarget
.
removeEventListener
(
"
DOMContentLoaded
"
handler
false
)
;
deferred
.
resolve
(
window
.
document
)
;
frame
.
remove
(
)
;
}
false
)
;
gDummyPromise
=
deferred
.
promise
;
return
gDummyPromise
;
}
function
ElementStyle
(
element
store
pageStyle
showUserAgentStyles
)
{
this
.
element
=
element
;
this
.
store
=
store
|
|
{
}
;
this
.
pageStyle
=
pageStyle
;
this
.
showUserAgentStyles
=
showUserAgentStyles
;
this
.
rules
=
[
]
;
if
(
!
(
"
userProperties
"
in
this
.
store
)
)
{
this
.
store
.
userProperties
=
new
UserProperties
(
)
;
}
if
(
!
(
"
disabled
"
in
this
.
store
)
)
{
this
.
store
.
disabled
=
new
WeakMap
(
)
;
}
}
exports
.
_ElementStyle
=
ElementStyle
;
ElementStyle
.
prototype
=
{
element
:
null
dummyElement
:
null
init
:
function
(
)
{
this
.
dummyElementPromise
=
createDummyDocument
(
)
.
then
(
document
=
>
{
let
namespaceURI
=
this
.
element
.
namespaceURI
|
|
document
.
documentElement
.
namespaceURI
;
this
.
dummyElement
=
document
.
createElementNS
(
namespaceURI
this
.
element
.
tagName
)
;
document
.
documentElement
.
appendChild
(
this
.
dummyElement
)
;
return
this
.
dummyElement
;
}
)
.
then
(
null
promiseWarn
)
;
return
this
.
dummyElementPromise
;
}
destroy
:
function
(
)
{
if
(
this
.
destroyed
)
{
return
;
}
this
.
destroyed
=
true
;
this
.
dummyElement
=
null
;
this
.
dummyElementPromise
.
then
(
dummyElement
=
>
{
dummyElement
.
remove
(
)
;
this
.
dummyElementPromise
=
null
;
}
console
.
error
)
;
}
_changed
:
function
(
)
{
if
(
this
.
onChanged
)
{
this
.
onChanged
(
)
;
}
}
populate
:
function
(
)
{
let
populated
=
this
.
pageStyle
.
getApplied
(
this
.
element
{
inherited
:
true
matchedSelectors
:
true
filter
:
this
.
showUserAgentStyles
?
"
ua
"
:
undefined
}
)
.
then
(
entries
=
>
{
if
(
this
.
destroyed
)
{
return
promise
.
resolve
(
undefined
)
;
}
return
this
.
dummyElementPromise
.
then
(
(
)
=
>
{
if
(
this
.
populated
!
=
=
populated
)
{
return
;
}
this
.
_refreshRules
=
this
.
rules
;
this
.
rules
=
[
]
;
for
(
let
entry
of
entries
)
{
this
.
_maybeAddRule
(
entry
)
;
}
this
.
markOverriddenAll
(
)
;
this
.
_sortRulesForPseudoElement
(
)
;
delete
this
.
_refreshRules
;
}
)
;
}
)
.
then
(
null
e
=
>
{
if
(
this
.
destroyed
)
{
return
promise
.
resolve
(
undefined
)
;
}
return
promiseWarn
(
e
)
;
}
)
;
this
.
populated
=
populated
;
return
this
.
populated
;
}
_sortRulesForPseudoElement
:
function
(
)
{
this
.
rules
=
this
.
rules
.
sort
(
(
a
b
)
=
>
{
return
(
a
.
pseudoElement
|
|
"
z
"
)
>
(
b
.
pseudoElement
|
|
"
z
"
)
;
}
)
;
}
_maybeAddRule
:
function
(
options
)
{
if
(
options
.
rule
&
&
this
.
rules
.
some
(
rule
=
>
rule
.
domRule
=
=
=
options
.
rule
)
)
{
return
false
;
}
if
(
options
.
system
)
{
return
false
;
}
let
rule
=
null
;
if
(
this
.
_refreshRules
)
{
for
(
let
r
of
this
.
_refreshRules
)
{
if
(
r
.
matches
(
options
)
)
{
rule
=
r
;
rule
.
refresh
(
options
)
;
break
;
}
}
}
if
(
!
rule
)
{
rule
=
new
Rule
(
this
options
)
;
}
if
(
options
.
inherited
&
&
rule
.
textProps
.
length
=
=
=
0
)
{
return
false
;
}
this
.
rules
.
push
(
rule
)
;
return
true
;
}
markOverriddenAll
:
function
(
)
{
this
.
markOverridden
(
)
;
for
(
let
pseudo
of
PSEUDO_ELEMENTS
)
{
this
.
markOverridden
(
pseudo
)
;
}
}
markOverridden
:
function
(
pseudo
=
"
"
)
{
let
textProps
=
[
]
;
for
(
let
rule
of
this
.
rules
)
{
if
(
rule
.
pseudoElement
=
=
=
pseudo
&
&
!
rule
.
keyframes
)
{
for
(
let
textProp
of
rule
.
textProps
.
slice
(
0
)
.
reverse
(
)
)
{
if
(
textProp
.
enabled
)
{
textProps
.
push
(
textProp
)
;
}
}
}
}
let
computedProps
=
[
]
;
for
(
let
textProp
of
textProps
)
{
computedProps
=
computedProps
.
concat
(
textProp
.
computed
)
;
}
let
taken
=
{
}
;
for
(
let
computedProp
of
computedProps
)
{
let
earlier
=
taken
[
computedProp
.
name
]
;
let
overridden
;
if
(
earlier
&
&
computedProp
.
priority
=
=
=
"
important
"
&
&
earlier
.
priority
!
=
=
"
important
"
)
{
earlier
.
_overriddenDirty
=
!
earlier
.
_overriddenDirty
;
earlier
.
overridden
=
true
;
overridden
=
false
;
}
else
{
overridden
=
!
!
earlier
;
}
computedProp
.
_overriddenDirty
=
(
!
!
computedProp
.
overridden
!
=
=
overridden
)
;
computedProp
.
overridden
=
overridden
;
if
(
!
computedProp
.
overridden
&
&
computedProp
.
textProp
.
enabled
)
{
taken
[
computedProp
.
name
]
=
computedProp
;
}
}
for
(
let
textProp
of
textProps
)
{
if
(
this
.
_updatePropertyOverridden
(
textProp
)
)
{
textProp
.
updateEditor
(
)
;
}
}
}
_updatePropertyOverridden
:
function
(
prop
)
{
let
overridden
=
true
;
let
dirty
=
false
;
for
(
let
computedProp
of
prop
.
computed
)
{
if
(
!
computedProp
.
overridden
)
{
overridden
=
false
;
}
dirty
=
computedProp
.
_overriddenDirty
|
|
dirty
;
delete
computedProp
.
_overriddenDirty
;
}
dirty
=
(
!
!
prop
.
overridden
!
=
=
overridden
)
|
|
dirty
;
prop
.
overridden
=
overridden
;
return
dirty
;
}
}
;
function
Rule
(
elementStyle
options
)
{
this
.
elementStyle
=
elementStyle
;
this
.
domRule
=
options
.
rule
|
|
null
;
this
.
style
=
options
.
rule
;
this
.
matchedSelectors
=
options
.
matchedSelectors
|
|
[
]
;
this
.
pseudoElement
=
options
.
pseudoElement
|
|
"
"
;
this
.
isSystem
=
options
.
isSystem
;
this
.
inherited
=
options
.
inherited
|
|
null
;
this
.
keyframes
=
options
.
keyframes
|
|
null
;
this
.
_modificationDepth
=
0
;
if
(
this
.
domRule
&
&
this
.
domRule
.
mediaText
)
{
this
.
mediaText
=
this
.
domRule
.
mediaText
;
}
this
.
textProps
=
this
.
_getTextProperties
(
)
;
this
.
textProps
=
this
.
textProps
.
concat
(
this
.
_getDisabledProperties
(
)
)
;
}
Rule
.
prototype
=
{
mediaText
:
"
"
get
title
(
)
{
if
(
this
.
_title
)
{
return
this
.
_title
;
}
this
.
_title
=
CssLogic
.
shortSource
(
this
.
sheet
)
;
if
(
this
.
domRule
.
type
!
=
=
ELEMENT_STYLE
&
&
this
.
ruleLine
>
0
)
{
this
.
_title
+
=
"
:
"
+
this
.
ruleLine
;
}
this
.
_title
=
this
.
_title
+
(
this
.
mediaText
?
"
media
"
+
this
.
mediaText
:
"
"
)
;
return
this
.
_title
;
}
get
inheritedSource
(
)
{
if
(
this
.
_inheritedSource
)
{
return
this
.
_inheritedSource
;
}
this
.
_inheritedSource
=
"
"
;
if
(
this
.
inherited
)
{
let
eltText
=
this
.
inherited
.
tagName
.
toLowerCase
(
)
;
if
(
this
.
inherited
.
id
)
{
eltText
+
=
"
#
"
+
this
.
inherited
.
id
;
}
this
.
_inheritedSource
=
CssLogic
.
_strings
.
formatStringFromName
(
"
rule
.
inheritedFrom
"
[
eltText
]
1
)
;
}
return
this
.
_inheritedSource
;
}
get
keyframesName
(
)
{
if
(
this
.
_keyframesName
)
{
return
this
.
_keyframesName
;
}
this
.
_keyframesName
=
"
"
;
if
(
this
.
keyframes
)
{
this
.
_keyframesName
=
CssLogic
.
_strings
.
formatStringFromName
(
"
rule
.
keyframe
"
[
this
.
keyframes
.
name
]
1
)
;
}
return
this
.
_keyframesName
;
}
get
selectorText
(
)
{
return
this
.
domRule
.
selectors
?
this
.
domRule
.
selectors
.
join
(
"
"
)
:
CssLogic
.
l10n
(
"
rule
.
sourceElement
"
)
;
}
get
sheet
(
)
{
return
this
.
domRule
?
this
.
domRule
.
parentStyleSheet
:
null
;
}
get
ruleLine
(
)
{
return
this
.
domRule
?
this
.
domRule
.
line
:
"
"
;
}
get
ruleColumn
(
)
{
return
this
.
domRule
?
this
.
domRule
.
column
:
null
;
}
getOriginalSourceStrings
:
function
(
)
{
if
(
this
.
_originalSourceStrings
)
{
return
promise
.
resolve
(
this
.
_originalSourceStrings
)
;
}
return
this
.
domRule
.
getOriginalLocation
(
)
.
then
(
(
{
href
line
mediaText
}
)
=
>
{
let
mediaString
=
mediaText
?
"
"
+
mediaText
:
"
"
;
let
sourceStrings
=
{
full
:
(
href
|
|
CssLogic
.
l10n
(
"
rule
.
sourceInline
"
)
)
+
"
:
"
+
line
+
mediaString
short
:
CssLogic
.
shortSource
(
{
href
:
href
}
)
+
"
:
"
+
line
+
mediaString
}
;
this
.
_originalSourceStrings
=
sourceStrings
;
return
sourceStrings
;
}
)
;
}
matches
:
function
(
options
)
{
return
this
.
style
=
=
=
options
.
rule
;
}
createProperty
:
function
(
name
value
priority
siblingProp
)
{
let
prop
=
new
TextProperty
(
this
name
value
priority
)
;
if
(
siblingProp
)
{
let
ind
=
this
.
textProps
.
indexOf
(
siblingProp
)
;
this
.
textProps
.
splice
(
ind
+
1
0
prop
)
;
}
else
{
this
.
textProps
.
push
(
prop
)
;
}
this
.
applyProperties
(
)
;
return
prop
;
}
applyProperties
:
function
(
modifications
)
{
this
.
elementStyle
.
markOverriddenAll
(
)
;
if
(
!
modifications
)
{
modifications
=
this
.
style
.
startModifyingProperties
(
)
;
}
let
disabledProps
=
[
]
;
for
(
let
prop
of
this
.
textProps
)
{
if
(
!
prop
.
enabled
)
{
disabledProps
.
push
(
{
name
:
prop
.
name
value
:
prop
.
value
priority
:
prop
.
priority
}
)
;
continue
;
}
if
(
prop
.
value
.
trim
(
)
=
=
=
"
"
)
{
continue
;
}
modifications
.
setProperty
(
prop
.
name
prop
.
value
prop
.
priority
)
;
prop
.
updateComputed
(
)
;
}
let
disabled
=
this
.
elementStyle
.
store
.
disabled
;
if
(
disabledProps
.
length
>
0
)
{
disabled
.
set
(
this
.
style
disabledProps
)
;
}
else
{
disabled
.
delete
(
this
.
style
)
;
}
let
modificationsPromise
=
modifications
.
apply
(
)
.
then
(
(
)
=
>
{
let
cssProps
=
{
}
;
for
(
let
cssProp
of
parseDeclarations
(
this
.
style
.
cssText
)
)
{
cssProps
[
cssProp
.
name
]
=
cssProp
;
}
for
(
let
textProp
of
this
.
textProps
)
{
if
(
!
textProp
.
enabled
)
{
continue
;
}
let
cssProp
=
cssProps
[
textProp
.
name
]
;
if
(
!
cssProp
)
{
cssProp
=
{
name
:
textProp
.
name
value
:
"
"
priority
:
"
"
}
;
}
textProp
.
priority
=
cssProp
.
priority
;
}
this
.
elementStyle
.
markOverriddenAll
(
)
;
if
(
modificationsPromise
=
=
=
this
.
_applyingModifications
)
{
this
.
_applyingModifications
=
null
;
}
this
.
elementStyle
.
_changed
(
)
;
}
)
.
then
(
null
promiseWarn
)
;
this
.
_applyingModifications
=
modificationsPromise
;
return
modificationsPromise
;
}
setPropertyName
:
function
(
property
name
)
{
if
(
name
=
=
=
property
.
name
)
{
return
;
}
let
modifications
=
this
.
style
.
startModifyingProperties
(
)
;
modifications
.
removeProperty
(
property
.
name
)
;
property
.
name
=
name
;
this
.
applyProperties
(
modifications
name
)
;
}
setPropertyValue
:
function
(
property
value
priority
)
{
if
(
value
=
=
=
property
.
value
&
&
priority
=
=
=
property
.
priority
)
{
return
;
}
property
.
value
=
value
;
property
.
priority
=
priority
;
this
.
applyProperties
(
null
property
.
name
)
;
}
previewPropertyValue
:
function
(
property
value
priority
)
{
let
modifications
=
this
.
style
.
startModifyingProperties
(
)
;
modifications
.
setProperty
(
property
.
name
value
priority
)
;
modifications
.
apply
(
)
.
then
(
(
)
=
>
{
this
.
elementStyle
.
_changed
(
)
;
}
)
;
}
setPropertyEnabled
:
function
(
property
value
)
{
property
.
enabled
=
!
!
value
;
let
modifications
=
this
.
style
.
startModifyingProperties
(
)
;
if
(
!
property
.
enabled
)
{
modifications
.
removeProperty
(
property
.
name
)
;
}
this
.
applyProperties
(
modifications
)
;
}
removeProperty
:
function
(
property
)
{
this
.
textProps
=
this
.
textProps
.
filter
(
prop
=
>
prop
!
=
=
property
)
;
let
modifications
=
this
.
style
.
startModifyingProperties
(
)
;
modifications
.
removeProperty
(
property
.
name
)
;
this
.
applyProperties
(
modifications
)
;
}
_getTextProperties
:
function
(
)
{
let
textProps
=
[
]
;
let
store
=
this
.
elementStyle
.
store
;
let
props
=
parseDeclarations
(
this
.
style
.
cssText
)
;
for
(
let
prop
of
props
)
{
let
name
=
prop
.
name
;
if
(
this
.
inherited
&
&
!
domUtils
.
isInheritedProperty
(
name
)
)
{
continue
;
}
let
value
=
store
.
userProperties
.
getProperty
(
this
.
style
name
prop
.
value
)
;
let
textProp
=
new
TextProperty
(
this
name
value
prop
.
priority
)
;
textProps
.
push
(
textProp
)
;
}
return
textProps
;
}
_getDisabledProperties
:
function
(
)
{
let
store
=
this
.
elementStyle
.
store
;
let
disabledProps
=
store
.
disabled
.
get
(
this
.
style
)
;
if
(
!
disabledProps
)
{
return
[
]
;
}
let
textProps
=
[
]
;
for
(
let
prop
of
disabledProps
)
{
let
value
=
store
.
userProperties
.
getProperty
(
this
.
style
prop
.
name
prop
.
value
)
;
let
textProp
=
new
TextProperty
(
this
prop
.
name
value
prop
.
priority
)
;
textProp
.
enabled
=
false
;
textProps
.
push
(
textProp
)
;
}
return
textProps
;
}
refresh
:
function
(
options
)
{
this
.
matchedSelectors
=
options
.
matchedSelectors
|
|
[
]
;
let
newTextProps
=
this
.
_getTextProperties
(
)
;
let
brandNewProps
=
[
]
;
for
(
let
newProp
of
newTextProps
)
{
if
(
!
this
.
_updateTextProperty
(
newProp
)
)
{
brandNewProps
.
push
(
newProp
)
;
}
}
for
(
let
prop
of
this
.
textProps
)
{
if
(
!
prop
.
_visited
)
{
prop
.
enabled
=
false
;
prop
.
updateEditor
(
)
;
}
else
{
delete
prop
.
_visited
;
}
}
this
.
textProps
=
this
.
textProps
.
concat
(
brandNewProps
)
;
if
(
this
.
editor
)
{
this
.
editor
.
populate
(
)
;
}
}
_updateTextProperty
:
function
(
newProp
)
{
let
match
=
{
rank
:
0
prop
:
null
}
;
for
(
let
prop
of
this
.
textProps
)
{
if
(
prop
.
name
!
=
=
newProp
.
name
)
{
continue
;
}
prop
.
_visited
=
true
;
let
rank
=
1
;
if
(
prop
.
value
=
=
=
newProp
.
value
)
{
rank
+
=
2
;
if
(
prop
.
priority
=
=
=
newProp
.
priority
)
{
rank
+
=
2
;
}
}
if
(
prop
.
enabled
)
{
rank
+
=
1
;
}
if
(
rank
>
match
.
rank
)
{
if
(
match
.
prop
)
{
match
.
prop
.
enabled
=
false
;
match
.
prop
.
updateEditor
(
)
;
}
match
.
rank
=
rank
;
match
.
prop
=
prop
;
}
else
if
(
rank
)
{
prop
.
enabled
=
false
;
prop
.
updateEditor
(
)
;
}
}
if
(
match
.
prop
)
{
match
.
prop
.
set
(
newProp
)
;
return
true
;
}
return
false
;
}
editClosestTextProperty
:
function
(
textProperty
direction
)
{
let
index
=
this
.
textProps
.
indexOf
(
textProperty
)
;
if
(
direction
=
=
=
Ci
.
nsIFocusManager
.
MOVEFOCUS_FORWARD
)
{
if
(
index
=
=
=
this
.
textProps
.
length
-
1
)
{
textProperty
.
rule
.
editor
.
closeBrace
.
click
(
)
;
}
else
{
let
nextProp
=
this
.
textProps
[
index
+
1
]
;
nextProp
.
editor
.
nameSpan
.
click
(
)
;
}
}
else
if
(
direction
=
=
=
Ci
.
nsIFocusManager
.
MOVEFOCUS_BACKWARD
)
{
if
(
index
=
=
=
0
)
{
textProperty
.
editor
.
ruleEditor
.
selectorText
.
click
(
)
;
}
else
{
let
prevProp
=
this
.
textProps
[
index
-
1
]
;
prevProp
.
editor
.
valueSpan
.
click
(
)
;
}
}
}
stringifyRule
:
function
(
)
{
let
selectorText
=
this
.
selectorText
;
let
cssText
=
"
"
;
let
terminator
=
osString
=
=
=
"
WINNT
"
?
"
\
r
\
n
"
:
"
\
n
"
;
for
(
let
textProp
of
this
.
textProps
)
{
cssText
+
=
"
\
t
"
+
textProp
.
stringifyProperty
(
)
+
terminator
;
}
return
selectorText
+
"
{
"
+
terminator
+
cssText
+
"
}
"
;
}
}
;
function
TextProperty
(
rule
name
value
priority
)
{
this
.
rule
=
rule
;
this
.
name
=
name
;
this
.
value
=
value
;
this
.
priority
=
priority
;
this
.
enabled
=
true
;
this
.
updateComputed
(
)
;
}
TextProperty
.
prototype
=
{
updateEditor
:
function
(
)
{
if
(
this
.
editor
)
{
this
.
editor
.
update
(
)
;
}
}
updateComputed
:
function
(
)
{
if
(
!
this
.
name
)
{
return
;
}
let
dummyElement
=
this
.
rule
.
elementStyle
.
dummyElement
;
let
dummyStyle
=
dummyElement
.
style
;
dummyStyle
.
cssText
=
"
"
;
dummyStyle
.
setProperty
(
this
.
name
this
.
value
this
.
priority
)
;
this
.
computed
=
[
]
;
try
{
let
subProps
=
domUtils
.
getSubpropertiesForCSSProperty
(
this
.
name
)
;
for
(
let
prop
of
subProps
)
{
this
.
computed
.
push
(
{
textProp
:
this
name
:
prop
value
:
dummyStyle
.
getPropertyValue
(
prop
)
priority
:
dummyStyle
.
getPropertyPriority
(
prop
)
}
)
;
}
}
catch
(
e
)
{
}
}
set
:
function
(
prop
)
{
let
changed
=
false
;
for
(
let
item
of
[
"
name
"
"
value
"
"
priority
"
"
enabled
"
]
)
{
if
(
this
[
item
]
!
=
=
prop
[
item
]
)
{
this
[
item
]
=
prop
[
item
]
;
changed
=
true
;
}
}
if
(
changed
)
{
this
.
updateEditor
(
)
;
}
}
setValue
:
function
(
value
priority
force
=
false
)
{
let
store
=
this
.
rule
.
elementStyle
.
store
;
if
(
this
.
editor
&
&
value
!
=
=
this
.
editor
.
committed
.
value
|
|
force
)
{
store
.
userProperties
.
setProperty
(
this
.
rule
.
style
this
.
name
value
)
;
}
this
.
rule
.
setPropertyValue
(
this
value
priority
)
;
this
.
updateEditor
(
)
;
}
setName
:
function
(
name
)
{
let
store
=
this
.
rule
.
elementStyle
.
store
;
if
(
name
!
=
=
this
.
name
)
{
store
.
userProperties
.
setProperty
(
this
.
rule
.
style
name
this
.
editor
.
committed
.
value
)
;
}
this
.
rule
.
setPropertyName
(
this
name
)
;
this
.
updateEditor
(
)
;
}
setEnabled
:
function
(
value
)
{
this
.
rule
.
setPropertyEnabled
(
this
value
)
;
this
.
updateEditor
(
)
;
}
remove
:
function
(
)
{
this
.
rule
.
removeProperty
(
this
)
;
}
stringifyProperty
:
function
(
)
{
let
declaration
=
this
.
name
+
"
:
"
+
this
.
editor
.
valueSpan
.
textContent
+
"
;
"
;
if
(
!
this
.
enabled
)
{
declaration
=
"
/
*
"
+
declaration
+
"
*
/
"
;
}
return
declaration
;
}
}
;
function
CssRuleView
(
inspector
document
store
pageStyle
)
{
this
.
inspector
=
inspector
;
this
.
styleDocument
=
document
;
this
.
styleWindow
=
this
.
styleDocument
.
defaultView
;
this
.
store
=
store
|
|
{
}
;
this
.
pageStyle
=
pageStyle
;
this
.
_outputParser
=
new
OutputParser
(
document
)
;
this
.
_onKeypress
=
this
.
_onKeypress
.
bind
(
this
)
;
this
.
_onAddRule
=
this
.
_onAddRule
.
bind
(
this
)
;
this
.
_onContextMenu
=
this
.
_onContextMenu
.
bind
(
this
)
;
this
.
_onCopy
=
this
.
_onCopy
.
bind
(
this
)
;
this
.
_onFilterStyles
=
this
.
_onFilterStyles
.
bind
(
this
)
;
this
.
_onFilterKeyPress
=
this
.
_onFilterKeyPress
.
bind
(
this
)
;
this
.
_onClearSearch
=
this
.
_onClearSearch
.
bind
(
this
)
;
this
.
_onFilterTextboxContextMenu
=
this
.
_onFilterTextboxContextMenu
.
bind
(
this
)
;
this
.
_onTogglePseudoClassPanel
=
this
.
_onTogglePseudoClassPanel
.
bind
(
this
)
;
this
.
_onTogglePseudoClass
=
this
.
_onTogglePseudoClass
.
bind
(
this
)
;
let
doc
=
this
.
styleDocument
;
this
.
element
=
doc
.
getElementById
(
"
ruleview
-
container
"
)
;
this
.
addRuleButton
=
doc
.
getElementById
(
"
ruleview
-
add
-
rule
-
button
"
)
;
this
.
searchField
=
doc
.
getElementById
(
"
ruleview
-
searchbox
"
)
;
this
.
searchClearButton
=
doc
.
getElementById
(
"
ruleview
-
searchinput
-
clear
"
)
;
this
.
pseudoClassPanel
=
doc
.
getElementById
(
"
pseudo
-
class
-
panel
"
)
;
this
.
pseudoClassToggle
=
doc
.
getElementById
(
"
pseudo
-
class
-
panel
-
toggle
"
)
;
this
.
hoverCheckbox
=
doc
.
getElementById
(
"
pseudo
-
hover
-
toggle
"
)
;
this
.
activeCheckbox
=
doc
.
getElementById
(
"
pseudo
-
active
-
toggle
"
)
;
this
.
focusCheckbox
=
doc
.
getElementById
(
"
pseudo
-
focus
-
toggle
"
)
;
this
.
searchClearButton
.
hidden
=
true
;
this
.
styleDocument
.
addEventListener
(
"
keypress
"
this
.
_onKeypress
)
;
this
.
element
.
addEventListener
(
"
copy
"
this
.
_onCopy
)
;
this
.
element
.
addEventListener
(
"
contextmenu
"
this
.
_onContextMenu
)
;
this
.
addRuleButton
.
addEventListener
(
"
click
"
this
.
_onAddRule
)
;
this
.
searchField
.
addEventListener
(
"
input
"
this
.
_onFilterStyles
)
;
this
.
searchField
.
addEventListener
(
"
keypress
"
this
.
_onFilterKeyPress
)
;
this
.
searchField
.
addEventListener
(
"
contextmenu
"
this
.
_onFilterTextboxContextMenu
)
;
this
.
searchClearButton
.
addEventListener
(
"
click
"
this
.
_onClearSearch
)
;
this
.
pseudoClassToggle
.
addEventListener
(
"
click
"
this
.
_onTogglePseudoClassPanel
)
;
this
.
hoverCheckbox
.
addEventListener
(
"
click
"
this
.
_onTogglePseudoClass
)
;
this
.
activeCheckbox
.
addEventListener
(
"
click
"
this
.
_onTogglePseudoClass
)
;
this
.
focusCheckbox
.
addEventListener
(
"
click
"
this
.
_onTogglePseudoClass
)
;
this
.
_handlePrefChange
=
this
.
_handlePrefChange
.
bind
(
this
)
;
this
.
_onSourcePrefChanged
=
this
.
_onSourcePrefChanged
.
bind
(
this
)
;
this
.
_prefObserver
=
new
PrefObserver
(
"
devtools
.
"
)
;
this
.
_prefObserver
.
on
(
PREF_ORIG_SOURCES
this
.
_onSourcePrefChanged
)
;
this
.
_prefObserver
.
on
(
PREF_UA_STYLES
this
.
_handlePrefChange
)
;
this
.
_prefObserver
.
on
(
PREF_DEFAULT_COLOR_UNIT
this
.
_handlePrefChange
)
;
this
.
_prefObserver
.
on
(
PREF_ENABLE_MDN_DOCS_TOOLTIP
this
.
_handlePrefChange
)
;
this
.
showUserAgentStyles
=
Services
.
prefs
.
getBoolPref
(
PREF_UA_STYLES
)
;
this
.
enableMdnDocsTooltip
=
Services
.
prefs
.
getBoolPref
(
PREF_ENABLE_MDN_DOCS_TOOLTIP
)
;
let
options
=
{
autoSelect
:
true
theme
:
"
auto
"
}
;
this
.
popup
=
new
AutocompletePopup
(
this
.
styleWindow
.
parent
.
document
options
)
;
this
.
_showEmpty
(
)
;
this
.
_contextmenu
=
new
StyleInspectorMenu
(
this
{
isRuleView
:
true
}
)
;
this
.
tooltips
=
new
overlays
.
TooltipsOverlay
(
this
)
;
this
.
tooltips
.
addToView
(
)
;
this
.
highlighters
=
new
overlays
.
HighlightersOverlay
(
this
)
;
this
.
highlighters
.
addToView
(
)
;
EventEmitter
.
decorate
(
this
)
;
}
exports
.
CssRuleView
=
CssRuleView
;
CssRuleView
.
prototype
=
{
_viewedElement
:
null
_filterChangedTimeout
:
null
get
searchValue
(
)
{
return
this
.
searchField
.
value
.
toLowerCase
(
)
;
}
getSelectorHighlighter
:
Task
.
async
(
function
*
(
)
{
let
utils
=
this
.
inspector
.
toolbox
.
highlighterUtils
;
if
(
!
utils
.
supportsCustomHighlighters
(
)
)
{
return
null
;
}
if
(
this
.
selectorHighlighter
)
{
return
this
.
selectorHighlighter
;
}
try
{
let
h
=
yield
utils
.
getHighlighterByType
(
"
SelectorHighlighter
"
)
;
this
.
selectorHighlighter
=
h
;
return
h
;
}
catch
(
e
)
{
return
null
;
}
}
)
toggleSelectorHighlighter
:
function
(
selectorIcon
selector
)
{
if
(
this
.
lastSelectorIcon
)
{
this
.
lastSelectorIcon
.
classList
.
remove
(
"
highlighted
"
)
;
}
selectorIcon
.
classList
.
remove
(
"
highlighted
"
)
;
this
.
unhighlightSelector
(
)
.
then
(
(
)
=
>
{
if
(
selector
!
=
=
this
.
highlightedSelector
)
{
this
.
highlightedSelector
=
selector
;
selectorIcon
.
classList
.
add
(
"
highlighted
"
)
;
this
.
lastSelectorIcon
=
selectorIcon
;
this
.
highlightSelector
(
selector
)
.
then
(
(
)
=
>
{
this
.
emit
(
"
ruleview
-
selectorhighlighter
-
toggled
"
true
)
;
}
Cu
.
reportError
)
;
}
else
{
this
.
highlightedSelector
=
null
;
this
.
emit
(
"
ruleview
-
selectorhighlighter
-
toggled
"
false
)
;
}
}
Cu
.
reportError
)
;
}
highlightSelector
:
Task
.
async
(
function
*
(
selector
)
{
let
node
=
this
.
inspector
.
selection
.
nodeFront
;
let
highlighter
=
yield
this
.
getSelectorHighlighter
(
)
;
if
(
!
highlighter
)
{
return
;
}
yield
highlighter
.
show
(
node
{
hideInfoBar
:
true
hideGuides
:
true
selector
}
)
;
}
)
unhighlightSelector
:
Task
.
async
(
function
*
(
)
{
let
highlighter
=
yield
this
.
getSelectorHighlighter
(
)
;
if
(
!
highlighter
)
{
return
;
}
yield
highlighter
.
hide
(
)
;
}
)
getNodeInfo
:
function
(
node
)
{
if
(
!
node
)
{
return
null
;
}
let
type
value
;
let
classes
=
node
.
classList
;
let
prop
=
getParentTextProperty
(
node
)
;
if
(
classes
.
contains
(
PROPERTY_NAME_CLASS
)
&
&
prop
)
{
type
=
overlays
.
VIEW_NODE_PROPERTY_TYPE
;
value
=
{
property
:
node
.
textContent
value
:
getPropertyNameAndValue
(
node
)
.
value
enabled
:
prop
.
enabled
overridden
:
prop
.
overridden
pseudoElement
:
prop
.
rule
.
pseudoElement
sheetHref
:
prop
.
rule
.
domRule
.
href
textProperty
:
prop
}
;
}
else
if
(
classes
.
contains
(
"
ruleview
-
propertyvalue
"
)
&
&
prop
)
{
type
=
overlays
.
VIEW_NODE_VALUE_TYPE
;
value
=
{
property
:
getPropertyNameAndValue
(
node
)
.
name
value
:
node
.
textContent
enabled
:
prop
.
enabled
overridden
:
prop
.
overridden
pseudoElement
:
prop
.
rule
.
pseudoElement
sheetHref
:
prop
.
rule
.
domRule
.
href
textProperty
:
prop
}
;
}
else
if
(
classes
.
contains
(
"
theme
-
link
"
)
&
&
!
classes
.
contains
(
"
ruleview
-
rule
-
source
"
)
&
&
prop
)
{
type
=
overlays
.
VIEW_NODE_IMAGE_URL_TYPE
;
value
=
{
property
:
getPropertyNameAndValue
(
node
)
.
name
value
:
node
.
parentNode
.
textContent
url
:
node
.
href
enabled
:
prop
.
enabled
overridden
:
prop
.
overridden
pseudoElement
:
prop
.
rule
.
pseudoElement
sheetHref
:
prop
.
rule
.
domRule
.
href
textProperty
:
prop
}
;
}
else
if
(
classes
.
contains
(
"
ruleview
-
selector
-
unmatched
"
)
|
|
classes
.
contains
(
"
ruleview
-
selector
-
matched
"
)
|
|
classes
.
contains
(
"
ruleview
-
selectorcontainer
"
)
|
|
classes
.
contains
(
"
ruleview
-
selector
"
)
|
|
classes
.
contains
(
"
ruleview
-
selector
-
attribute
"
)
|
|
classes
.
contains
(
"
ruleview
-
selector
-
pseudo
-
class
"
)
|
|
classes
.
contains
(
"
ruleview
-
selector
-
pseudo
-
class
-
lock
"
)
)
{
type
=
overlays
.
VIEW_NODE_SELECTOR_TYPE
;
value
=
this
.
_getRuleEditorForNode
(
node
)
.
selectorText
.
textContent
;
}
else
if
(
classes
.
contains
(
"
ruleview
-
rule
-
source
"
)
|
|
classes
.
contains
(
"
ruleview
-
rule
-
source
-
label
"
)
)
{
type
=
overlays
.
VIEW_NODE_LOCATION_TYPE
;
let
rule
=
this
.
_getRuleEditorForNode
(
node
)
.
rule
;
value
=
(
rule
.
sheet
&
&
rule
.
sheet
.
href
)
?
rule
.
sheet
.
href
:
rule
.
title
;
}
else
{
return
null
;
}
return
{
type
value
}
;
}
_getRuleEditorForNode
:
function
(
node
)
{
if
(
!
node
.
offsetParent
)
{
node
=
node
.
parentNode
;
}
return
node
.
offsetParent
.
_ruleEditor
;
}
_onContextMenu
:
function
(
event
)
{
this
.
_contextmenu
.
show
(
event
)
;
}
_onCopy
:
function
(
event
)
{
if
(
event
)
{
this
.
copySelection
(
event
.
target
)
;
event
.
preventDefault
(
)
;
}
}
copySelection
:
function
(
target
)
{
try
{
let
text
=
"
"
;
if
(
target
&
&
target
.
nodeName
=
=
=
"
input
"
)
{
let
start
=
Math
.
min
(
target
.
selectionStart
target
.
selectionEnd
)
;
let
end
=
Math
.
max
(
target
.
selectionStart
target
.
selectionEnd
)
;
let
count
=
end
-
start
;
text
=
target
.
value
.
substr
(
start
count
)
;
}
else
{
text
=
this
.
styleWindow
.
getSelection
(
)
.
toString
(
)
;
text
=
text
.
replace
(
/
(
\
r
?
\
n
)
\
r
?
\
n
/
g
"
1
"
)
;
let
inline
=
_strings
.
GetStringFromName
(
"
rule
.
sourceInline
"
)
;
let
rx
=
new
RegExp
(
"
^
"
+
inline
+
"
\
\
r
?
\
\
n
?
"
"
g
"
)
;
text
=
text
.
replace
(
rx
"
"
)
;
}
clipboardHelper
.
copyString
(
text
)
;
}
catch
(
e
)
{
console
.
error
(
e
)
;
}
}
_onAddRule
:
function
(
)
{
let
elementStyle
=
this
.
_elementStyle
;
let
element
=
elementStyle
.
element
;
let
rules
=
elementStyle
.
rules
;
let
client
=
this
.
inspector
.
toolbox
.
_target
.
client
;
let
pseudoClasses
=
element
.
pseudoClassLocks
;
if
(
!
client
.
traits
.
addNewRule
)
{
return
;
}
this
.
pageStyle
.
addNewRule
(
element
pseudoClasses
)
.
then
(
options
=
>
{
let
newRule
=
new
Rule
(
elementStyle
options
)
;
rules
.
push
(
newRule
)
;
let
editor
=
new
RuleEditor
(
this
newRule
)
;
newRule
.
editor
=
editor
;
if
(
rules
.
length
<
=
1
)
{
this
.
element
.
appendChild
(
editor
.
element
)
;
}
else
{
for
(
let
rule
of
rules
)
{
if
(
rule
.
domRule
.
type
=
=
=
ELEMENT_STYLE
)
{
let
referenceElement
=
rule
.
editor
.
element
.
nextSibling
;
this
.
element
.
insertBefore
(
editor
.
element
referenceElement
)
;
break
;
}
}
}
editor
.
selectorText
.
click
(
)
;
elementStyle
.
_changed
(
)
;
}
)
;
}
refreshAddRuleButtonState
:
function
(
)
{
let
shouldBeDisabled
=
!
this
.
_viewedElement
|
|
!
this
.
inspector
.
selection
.
isElementNode
(
)
|
|
this
.
inspector
.
selection
.
isAnonymousNode
(
)
;
this
.
addRuleButton
.
disabled
=
shouldBeDisabled
;
}
setPageStyle
:
function
(
pageStyle
)
{
this
.
pageStyle
=
pageStyle
;
}
get
isEditing
(
)
{
return
this
.
tooltips
.
isEditing
|
|
this
.
element
.
querySelectorAll
(
"
.
styleinspector
-
propertyeditor
"
)
.
length
>
0
;
}
_handlePrefChange
:
function
(
pref
)
{
if
(
pref
=
=
=
PREF_UA_STYLES
)
{
this
.
showUserAgentStyles
=
Services
.
prefs
.
getBoolPref
(
pref
)
;
}
let
refreshOnPrefs
=
[
PREF_UA_STYLES
PREF_DEFAULT_COLOR_UNIT
]
;
if
(
refreshOnPrefs
.
indexOf
(
pref
)
>
-
1
)
{
let
element
=
this
.
_viewedElement
;
this
.
_viewedElement
=
null
;
this
.
selectElement
(
element
)
;
}
}
_onSourcePrefChanged
:
function
(
)
{
if
(
this
.
_elementStyle
&
&
this
.
_elementStyle
.
rules
)
{
for
(
let
rule
of
this
.
_elementStyle
.
rules
)
{
if
(
rule
.
editor
)
{
rule
.
editor
.
updateSourceLink
(
)
;
}
}
this
.
inspector
.
emit
(
"
rule
-
view
-
sourcelinks
-
updated
"
)
;
}
}
setFilterStyles
:
function
(
value
=
"
"
)
{
this
.
searchField
.
value
=
value
;
this
.
searchField
.
focus
(
)
;
this
.
_onFilterStyles
(
)
;
}
_onFilterStyles
:
function
(
)
{
if
(
this
.
_filterChangedTimeout
)
{
clearTimeout
(
this
.
_filterChangedTimeout
)
;
}
let
filterTimeout
=
(
this
.
searchValue
.
length
>
0
)
?
FILTER_CHANGED_TIMEOUT
:
0
;
this
.
searchClearButton
.
hidden
=
this
.
searchValue
.
length
=
=
=
0
;
this
.
_filterChangedTimeout
=
setTimeout
(
(
)
=
>
{
if
(
this
.
searchField
.
value
.
length
>
0
)
{
this
.
searchField
.
setAttribute
(
"
filled
"
true
)
;
}
else
{
this
.
searchField
.
removeAttribute
(
"
filled
"
)
;
}
this
.
searchData
=
{
searchPropertyMatch
:
FILTER_PROP_RE
.
exec
(
this
.
searchValue
)
searchPropertyName
:
this
.
searchValue
searchPropertyValue
:
this
.
searchValue
strictSearchValue
:
"
"
strictSearchPropertyName
:
false
strictSearchPropertyValue
:
false
strictSearchAllValues
:
false
}
;
if
(
this
.
searchData
.
searchPropertyMatch
)
{
if
(
FILTER_STRICT_RE
.
test
(
this
.
searchData
.
searchPropertyMatch
[
1
]
)
)
{
this
.
searchData
.
strictSearchPropertyName
=
true
;
this
.
searchData
.
searchPropertyName
=
FILTER_STRICT_RE
.
exec
(
this
.
searchData
.
searchPropertyMatch
[
1
]
)
[
1
]
;
}
else
{
this
.
searchData
.
searchPropertyName
=
this
.
searchData
.
searchPropertyMatch
[
1
]
;
}
if
(
FILTER_STRICT_RE
.
test
(
this
.
searchData
.
searchPropertyMatch
[
2
]
)
)
{
this
.
searchData
.
strictSearchPropertyValue
=
true
;
this
.
searchData
.
searchPropertyValue
=
FILTER_STRICT_RE
.
exec
(
this
.
searchData
.
searchPropertyMatch
[
2
]
)
[
1
]
;
}
else
{
this
.
searchData
.
searchPropertyValue
=
this
.
searchData
.
searchPropertyMatch
[
2
]
;
}
if
(
FILTER_STRICT_RE
.
test
(
this
.
searchValue
)
)
{
this
.
searchData
.
strictSearchValue
=
FILTER_STRICT_RE
.
exec
(
this
.
searchValue
)
[
1
]
;
}
}
else
if
(
FILTER_STRICT_RE
.
test
(
this
.
searchValue
)
)
{
let
searchValue
=
FILTER_STRICT_RE
.
exec
(
this
.
searchValue
)
[
1
]
;
this
.
searchData
.
strictSearchAllValues
=
true
;
this
.
searchData
.
searchPropertyName
=
searchValue
;
this
.
searchData
.
searchPropertyValue
=
searchValue
;
this
.
searchData
.
strictSearchValue
=
searchValue
;
}
this
.
_clearHighlight
(
this
.
element
)
;
this
.
_clearRules
(
)
;
this
.
_createEditors
(
)
;
this
.
inspector
.
emit
(
"
ruleview
-
filtered
"
)
;
this
.
_filterChangeTimeout
=
null
;
}
filterTimeout
)
;
}
_onFilterKeyPress
:
function
(
event
)
{
if
(
event
.
keyCode
=
=
=
Ci
.
nsIDOMKeyEvent
.
DOM_VK_ESCAPE
&
&
this
.
_onClearSearch
(
)
)
{
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
}
}
_onFilterTextboxContextMenu
:
function
(
event
)
{
try
{
this
.
styleWindow
.
focus
(
)
;
let
contextmenu
=
this
.
inspector
.
toolbox
.
textboxContextMenuPopup
;
contextmenu
.
openPopupAtScreen
(
event
.
screenX
event
.
screenY
true
)
;
}
catch
(
e
)
{
console
.
error
(
e
)
;
}
}
_onClearSearch
:
function
(
)
{
if
(
this
.
searchField
.
value
)
{
this
.
setFilterStyles
(
"
"
)
;
return
true
;
}
return
false
;
}
destroy
:
function
(
)
{
this
.
isDestroyed
=
true
;
this
.
clear
(
)
;
gDummyPromise
=
null
;
this
.
_prefObserver
.
off
(
PREF_ORIG_SOURCES
this
.
_onSourcePrefChanged
)
;
this
.
_prefObserver
.
off
(
PREF_UA_STYLES
this
.
_handlePrefChange
)
;
this
.
_prefObserver
.
off
(
PREF_DEFAULT_COLOR_UNIT
this
.
_handlePrefChange
)
;
this
.
_prefObserver
.
destroy
(
)
;
this
.
_outputParser
=
null
;
if
(
this
.
_contextmenu
)
{
this
.
_contextmenu
.
destroy
(
)
;
this
.
_contextmenu
=
null
;
}
this
.
tooltips
.
destroy
(
)
;
this
.
highlighters
.
destroy
(
)
;
this
.
element
.
removeEventListener
(
"
copy
"
this
.
_onCopy
)
;
this
.
element
.
removeEventListener
(
"
contextmenu
"
this
.
_onContextMenu
)
;
this
.
addRuleButton
.
removeEventListener
(
"
click
"
this
.
_onAddRule
)
;
this
.
searchField
.
removeEventListener
(
"
input
"
this
.
_onFilterStyles
)
;
this
.
searchField
.
removeEventListener
(
"
keypress
"
this
.
_onFilterKeyPress
)
;
this
.
searchField
.
removeEventListener
(
"
contextmenu
"
this
.
_onFilterTextboxContextMenu
)
;
this
.
searchClearButton
.
removeEventListener
(
"
click
"
this
.
_onClearSearch
)
;
this
.
pseudoClassToggle
.
removeEventListener
(
"
click
"
this
.
_onTogglePseudoClassPanel
)
;
this
.
hoverCheckbox
.
removeEventListener
(
"
click
"
this
.
_onTogglePseudoClass
)
;
this
.
activeCheckbox
.
removeEventListener
(
"
click
"
this
.
_onTogglePseudoClass
)
;
this
.
focusCheckbox
.
removeEventListener
(
"
click
"
this
.
_onTogglePseudoClass
)
;
this
.
searchField
=
null
;
this
.
searchClearButton
=
null
;
this
.
pseudoClassPanel
=
null
;
this
.
pseudoClassToggle
=
null
;
this
.
hoverCheckbox
=
null
;
this
.
activeCheckbox
=
null
;
this
.
focusCheckbox
=
null
;
this
.
inspector
=
null
;
this
.
styleDocument
=
null
;
this
.
styleWindow
=
null
;
if
(
this
.
element
.
parentNode
)
{
this
.
element
.
parentNode
.
removeChild
(
this
.
element
)
;
}
if
(
this
.
_elementStyle
)
{
this
.
_elementStyle
.
destroy
(
)
;
}
this
.
popup
.
destroy
(
)
;
}
selectElement
:
function
(
element
)
{
if
(
this
.
_viewedElement
=
=
=
element
)
{
return
promise
.
resolve
(
undefined
)
;
}
if
(
this
.
popup
.
isOpen
)
{
this
.
popup
.
hidePopup
(
)
;
}
this
.
clear
(
)
;
this
.
clearPseudoClassPanel
(
)
;
this
.
_viewedElement
=
element
;
this
.
refreshAddRuleButtonState
(
)
;
if
(
!
this
.
_viewedElement
)
{
this
.
_showEmpty
(
)
;
this
.
refreshPseudoClassPanel
(
)
;
return
promise
.
resolve
(
undefined
)
;
}
this
.
_elementStyle
=
new
ElementStyle
(
element
this
.
store
this
.
pageStyle
this
.
showUserAgentStyles
)
;
return
this
.
_elementStyle
.
init
(
)
.
then
(
(
)
=
>
{
if
(
this
.
_viewedElement
=
=
=
element
)
{
return
this
.
_populate
(
)
;
}
}
)
.
then
(
(
)
=
>
{
if
(
this
.
_viewedElement
=
=
=
element
)
{
this
.
_elementStyle
.
onChanged
=
(
)
=
>
{
this
.
_changed
(
)
;
}
;
}
}
)
.
then
(
null
console
.
error
)
;
}
refreshPanel
:
function
(
)
{
if
(
this
.
isEditing
|
|
!
this
.
_elementStyle
)
{
return
promise
.
resolve
(
undefined
)
;
}
let
promises
=
[
]
;
for
(
let
rule
of
this
.
_elementStyle
.
rules
)
{
if
(
rule
.
_applyingModifications
)
{
promises
.
push
(
rule
.
_applyingModifications
)
;
}
}
return
promise
.
all
(
promises
)
.
then
(
(
)
=
>
{
return
this
.
_populate
(
true
)
;
}
)
;
}
clearPseudoClassPanel
:
function
(
)
{
this
.
hoverCheckbox
.
checked
=
this
.
hoverCheckbox
.
disabled
=
false
;
this
.
activeCheckbox
.
checked
=
this
.
activeCheckbox
.
disabled
=
false
;
this
.
focusCheckbox
.
checked
=
this
.
focusCheckbox
.
disabled
=
false
;
}
refreshPseudoClassPanel
:
function
(
)
{
if
(
!
this
.
_elementStyle
|
|
!
this
.
inspector
.
selection
.
isElementNode
(
)
)
{
this
.
hoverCheckbox
.
disabled
=
true
;
this
.
activeCheckbox
.
disabled
=
true
;
this
.
focusCheckbox
.
disabled
=
true
;
return
;
}
for
(
let
pseudoClassLock
of
this
.
_elementStyle
.
element
.
pseudoClassLocks
)
{
switch
(
pseudoClassLock
)
{
case
"
:
hover
"
:
{
this
.
hoverCheckbox
.
checked
=
true
;
break
;
}
case
"
:
active
"
:
{
this
.
activeCheckbox
.
checked
=
true
;
break
;
}
case
"
:
focus
"
:
{
this
.
focusCheckbox
.
checked
=
true
;
break
;
}
}
}
}
_populate
:
function
(
clearRules
=
false
)
{
let
elementStyle
=
this
.
_elementStyle
;
return
this
.
_elementStyle
.
populate
(
)
.
then
(
(
)
=
>
{
if
(
this
.
_elementStyle
!
=
=
elementStyle
|
|
this
.
isDestroyed
)
{
return
;
}
if
(
clearRules
)
{
this
.
_clearRules
(
)
;
}
this
.
_createEditors
(
)
;
this
.
refreshPseudoClassPanel
(
)
;
this
.
emit
(
"
ruleview
-
refreshed
"
)
;
}
)
.
then
(
null
promiseWarn
)
;
}
_showEmpty
:
function
(
)
{
if
(
this
.
styleDocument
.
getElementById
(
"
noResults
"
)
>
0
)
{
return
;
}
createChild
(
this
.
element
"
div
"
{
id
:
"
noResults
"
textContent
:
CssLogic
.
l10n
(
"
rule
.
empty
"
)
}
)
;
}
_clearRules
:
function
(
)
{
while
(
this
.
element
.
hasChildNodes
(
)
)
{
this
.
element
.
removeChild
(
this
.
element
.
lastChild
)
;
}
}
clear
:
function
(
)
{
this
.
lastSelectorIcon
=
null
;
this
.
_clearRules
(
)
;
this
.
_viewedElement
=
null
;
if
(
this
.
_elementStyle
)
{
this
.
_elementStyle
.
destroy
(
)
;
this
.
_elementStyle
=
null
;
}
}
_changed
:
function
(
)
{
this
.
emit
(
"
ruleview
-
changed
"
)
;
}
get
selectedElementLabel
(
)
{
if
(
this
.
_selectedElementLabel
)
{
return
this
.
_selectedElementLabel
;
}
this
.
_selectedElementLabel
=
CssLogic
.
l10n
(
"
rule
.
selectedElement
"
)
;
return
this
.
_selectedElementLabel
;
}
get
pseudoElementLabel
(
)
{
if
(
this
.
_pseudoElementLabel
)
{
return
this
.
_pseudoElementLabel
;
}
this
.
_pseudoElementLabel
=
CssLogic
.
l10n
(
"
rule
.
pseudoElement
"
)
;
return
this
.
_pseudoElementLabel
;
}
get
showPseudoElements
(
)
{
if
(
this
.
_showPseudoElements
=
=
=
undefined
)
{
this
.
_showPseudoElements
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
inspector
.
show_pseudo_elements
"
)
;
}
return
this
.
_showPseudoElements
;
}
createExpandableContainer
:
function
(
label
isPseudo
=
false
)
{
let
header
=
this
.
styleDocument
.
createElementNS
(
HTML_NS
"
div
"
)
;
header
.
className
=
this
.
_getRuleViewHeaderClassName
(
true
)
;
header
.
classList
.
add
(
"
show
-
expandable
-
container
"
)
;
header
.
textContent
=
label
;
let
twisty
=
this
.
styleDocument
.
createElementNS
(
HTML_NS
"
span
"
)
;
twisty
.
className
=
"
ruleview
-
expander
theme
-
twisty
"
;
twisty
.
setAttribute
(
"
open
"
"
true
"
)
;
header
.
insertBefore
(
twisty
header
.
firstChild
)
;
this
.
element
.
appendChild
(
header
)
;
let
container
=
this
.
styleDocument
.
createElementNS
(
HTML_NS
"
div
"
)
;
container
.
classList
.
add
(
"
ruleview
-
expandable
-
container
"
)
;
this
.
element
.
appendChild
(
container
)
;
header
.
addEventListener
(
"
dblclick
"
(
)
=
>
{
this
.
_toggleContainerVisibility
(
twisty
header
isPseudo
!
this
.
showPseudoElements
)
;
}
false
)
;
twisty
.
addEventListener
(
"
click
"
(
)
=
>
{
this
.
_toggleContainerVisibility
(
twisty
header
isPseudo
!
this
.
showPseudoElements
)
;
}
false
)
;
if
(
isPseudo
)
{
this
.
_toggleContainerVisibility
(
twisty
header
isPseudo
this
.
showPseudoElements
)
;
}
return
container
;
}
_toggleContainerVisibility
:
function
(
twisty
header
isPseudo
showPseudo
)
{
let
isOpen
=
twisty
.
getAttribute
(
"
open
"
)
;
if
(
isPseudo
)
{
this
.
_showPseudoElements
=
!
!
showPseudo
;
Services
.
prefs
.
setBoolPref
(
"
devtools
.
inspector
.
show_pseudo_elements
"
this
.
showPseudoElements
)
;
header
.
classList
.
toggle
(
"
show
-
expandable
-
container
"
this
.
showPseudoElements
)
;
isOpen
=
!
this
.
showPseudoElements
;
}
else
{
header
.
classList
.
toggle
(
"
show
-
expandable
-
container
"
)
;
}
if
(
isOpen
)
{
twisty
.
removeAttribute
(
"
open
"
)
;
}
else
{
twisty
.
setAttribute
(
"
open
"
"
true
"
)
;
}
}
_getRuleViewHeaderClassName
:
function
(
isPseudo
)
{
let
baseClassName
=
"
theme
-
gutter
ruleview
-
header
"
;
return
isPseudo
?
baseClassName
+
"
ruleview
-
expandable
-
header
"
:
baseClassName
;
}
_createEditors
:
function
(
)
{
let
lastInheritedSource
=
"
"
;
let
lastKeyframes
=
null
;
let
seenPseudoElement
=
false
;
let
seenNormalElement
=
false
;
let
seenSearchTerm
=
false
;
let
container
=
null
;
if
(
!
this
.
_elementStyle
.
rules
)
{
return
;
}
for
(
let
rule
of
this
.
_elementStyle
.
rules
)
{
if
(
rule
.
domRule
.
system
)
{
continue
;
}
if
(
!
rule
.
editor
)
{
rule
.
editor
=
new
RuleEditor
(
this
rule
)
;
}
if
(
this
.
searchValue
&
&
this
.
searchData
)
{
if
(
this
.
highlightRule
(
rule
)
)
{
seenSearchTerm
=
true
;
}
else
if
(
rule
.
domRule
.
type
!
=
=
ELEMENT_STYLE
)
{
continue
;
}
}
if
(
seenPseudoElement
&
&
!
seenNormalElement
&
&
!
rule
.
pseudoElement
)
{
seenNormalElement
=
true
;
let
div
=
this
.
styleDocument
.
createElementNS
(
HTML_NS
"
div
"
)
;
div
.
className
=
this
.
_getRuleViewHeaderClassName
(
)
;
div
.
textContent
=
this
.
selectedElementLabel
;
this
.
element
.
appendChild
(
div
)
;
}
let
inheritedSource
=
rule
.
inheritedSource
;
if
(
inheritedSource
&
&
inheritedSource
!
=
=
lastInheritedSource
)
{
let
div
=
this
.
styleDocument
.
createElementNS
(
HTML_NS
"
div
"
)
;
div
.
className
=
this
.
_getRuleViewHeaderClassName
(
)
;
div
.
textContent
=
inheritedSource
;
lastInheritedSource
=
inheritedSource
;
this
.
element
.
appendChild
(
div
)
;
}
if
(
!
seenPseudoElement
&
&
rule
.
pseudoElement
)
{
seenPseudoElement
=
true
;
container
=
this
.
createExpandableContainer
(
this
.
pseudoElementLabel
true
)
;
}
let
keyframes
=
rule
.
keyframes
;
if
(
keyframes
&
&
keyframes
!
=
=
lastKeyframes
)
{
lastKeyframes
=
keyframes
;
container
=
this
.
createExpandableContainer
(
rule
.
keyframesName
)
;
}
if
(
container
&
&
(
rule
.
pseudoElement
|
|
keyframes
)
)
{
container
.
appendChild
(
rule
.
editor
.
element
)
;
}
else
{
this
.
element
.
appendChild
(
rule
.
editor
.
element
)
;
}
}
if
(
this
.
searchValue
&
&
!
seenSearchTerm
)
{
this
.
searchField
.
classList
.
add
(
"
devtools
-
style
-
searchbox
-
no
-
match
"
)
;
}
else
{
this
.
searchField
.
classList
.
remove
(
"
devtools
-
style
-
searchbox
-
no
-
match
"
)
;
}
}
highlightRule
:
function
(
rule
)
{
let
isRuleSelectorHighlighted
=
this
.
_highlightRuleSelector
(
rule
)
;
let
isStyleSheetHighlighted
=
this
.
_highlightStyleSheet
(
rule
)
;
let
isHighlighted
=
isRuleSelectorHighlighted
|
|
isStyleSheetHighlighted
;
for
(
let
textProp
of
rule
.
textProps
)
{
if
(
this
.
_highlightProperty
(
textProp
.
editor
)
)
{
isHighlighted
=
true
;
}
}
return
isHighlighted
;
}
_highlightRuleSelector
:
function
(
rule
)
{
let
isSelectorHighlighted
=
false
;
let
selectorNodes
=
[
.
.
.
rule
.
editor
.
selectorText
.
childNodes
]
;
if
(
rule
.
domRule
.
type
=
=
=
Ci
.
nsIDOMCSSRule
.
KEYFRAME_RULE
)
{
selectorNodes
=
[
rule
.
editor
.
selectorText
]
;
}
else
if
(
rule
.
domRule
.
type
=
=
=
ELEMENT_STYLE
)
{
selectorNodes
=
[
]
;
}
for
(
let
selectorNode
of
selectorNodes
)
{
let
selector
=
selectorNode
.
textContent
.
toLowerCase
(
)
;
if
(
(
this
.
searchData
.
strictSearchAllValues
&
&
selector
=
=
=
this
.
searchData
.
strictSearchValue
)
|
|
(
!
this
.
searchData
.
strictSearchAllValues
&
&
selector
.
includes
(
this
.
searchValue
)
)
)
{
selectorNode
.
classList
.
add
(
"
ruleview
-
highlight
"
)
;
isSelectorHighlighted
=
true
;
}
}
return
isSelectorHighlighted
;
}
_highlightStyleSheet
:
function
(
rule
)
{
let
styleSheetSource
=
rule
.
title
.
toLowerCase
(
)
;
let
isStyleSheetHighlighted
=
this
.
searchData
.
strictSearchValue
?
styleSheetSource
=
=
=
this
.
searchData
.
strictSearchValue
:
styleSheetSource
.
includes
(
this
.
searchValue
)
;
if
(
isStyleSheetHighlighted
)
{
rule
.
editor
.
source
.
classList
.
add
(
"
ruleview
-
highlight
"
)
;
}
return
isStyleSheetHighlighted
;
}
_highlightProperty
:
function
(
editor
)
{
let
isPropertyHighlighted
=
this
.
_highlightRuleProperty
(
editor
)
;
let
isComputedHighlighted
=
this
.
_highlightComputedProperty
(
editor
)
;
if
(
!
isPropertyHighlighted
&
&
isComputedHighlighted
&
&
!
editor
.
computed
.
hasAttribute
(
"
user
-
open
"
)
)
{
editor
.
expandForFilter
(
)
;
}
return
isPropertyHighlighted
|
|
isComputedHighlighted
;
}
_updatePropertyHighlight
:
function
(
editor
)
{
if
(
!
this
.
searchValue
|
|
!
this
.
searchData
)
{
return
;
}
this
.
_clearHighlight
(
editor
.
element
)
;
if
(
this
.
_highlightProperty
(
editor
)
)
{
this
.
searchField
.
classList
.
remove
(
"
devtools
-
style
-
searchbox
-
no
-
match
"
)
;
}
}
_highlightRuleProperty
:
function
(
editor
)
{
let
propertyName
=
editor
.
prop
.
name
.
toLowerCase
(
)
;
let
propertyValue
=
editor
.
valueSpan
.
textContent
.
toLowerCase
(
)
;
return
this
.
_highlightMatches
(
editor
.
container
propertyName
propertyValue
)
;
}
_highlightComputedProperty
:
function
(
editor
)
{
let
isComputedHighlighted
=
false
;
editor
.
_populateComputed
(
)
;
for
(
let
computed
of
editor
.
prop
.
computed
)
{
if
(
computed
.
element
)
{
let
computedName
=
computed
.
name
.
toLowerCase
(
)
;
let
computedValue
=
computed
.
parsedValue
.
toLowerCase
(
)
;
isComputedHighlighted
=
this
.
_highlightMatches
(
computed
.
element
computedName
computedValue
)
?
true
:
isComputedHighlighted
;
}
}
return
isComputedHighlighted
;
}
_highlightMatches
:
function
(
element
propertyName
propertyValue
)
{
let
{
searchPropertyName
searchPropertyValue
searchPropertyMatch
strictSearchPropertyName
strictSearchPropertyValue
strictSearchAllValues
}
=
this
.
searchData
;
let
matches
=
false
;
let
hasNameAndValue
=
searchPropertyMatch
&
&
searchPropertyName
&
&
searchPropertyValue
;
let
isMatch
=
(
value
query
isStrict
)
=
>
{
return
isStrict
?
value
=
=
=
query
:
query
&
&
value
.
includes
(
query
)
;
}
;
if
(
hasNameAndValue
)
{
matches
=
isMatch
(
propertyName
searchPropertyName
strictSearchPropertyName
)
&
&
isMatch
(
propertyValue
searchPropertyValue
strictSearchPropertyValue
)
;
}
else
{
matches
=
isMatch
(
propertyName
searchPropertyName
strictSearchPropertyName
|
|
strictSearchAllValues
)
|
|
isMatch
(
propertyValue
searchPropertyValue
strictSearchPropertyValue
|
|
strictSearchAllValues
)
;
}
if
(
matches
)
{
element
.
classList
.
add
(
"
ruleview
-
highlight
"
)
;
}
return
matches
;
}
_clearHighlight
:
function
(
element
)
{
for
(
let
el
of
element
.
querySelectorAll
(
"
.
ruleview
-
highlight
"
)
)
{
el
.
classList
.
remove
(
"
ruleview
-
highlight
"
)
;
}
for
(
let
computed
of
element
.
querySelectorAll
(
"
.
ruleview
-
computedlist
[
filter
-
open
]
"
)
)
{
computed
.
parentNode
.
_textPropertyEditor
.
collapseForFilter
(
)
;
}
}
_onTogglePseudoClassPanel
:
function
(
)
{
if
(
this
.
pseudoClassPanel
.
hidden
)
{
this
.
pseudoClassToggle
.
setAttribute
(
"
checked
"
"
true
"
)
;
this
.
hoverCheckbox
.
setAttribute
(
"
tabindex
"
"
0
"
)
;
this
.
activeCheckbox
.
setAttribute
(
"
tabindex
"
"
0
"
)
;
this
.
focusCheckbox
.
setAttribute
(
"
tabindex
"
"
0
"
)
;
}
else
{
this
.
pseudoClassToggle
.
removeAttribute
(
"
checked
"
)
;
this
.
hoverCheckbox
.
setAttribute
(
"
tabindex
"
"
-
1
"
)
;
this
.
activeCheckbox
.
setAttribute
(
"
tabindex
"
"
-
1
"
)
;
this
.
focusCheckbox
.
setAttribute
(
"
tabindex
"
"
-
1
"
)
;
}
this
.
pseudoClassPanel
.
hidden
=
!
this
.
pseudoClassPanel
.
hidden
;
}
_onTogglePseudoClass
:
function
(
event
)
{
let
target
=
event
.
currentTarget
;
this
.
inspector
.
togglePseudoClass
(
target
.
value
)
;
}
_onKeypress
:
function
(
event
)
{
let
isOSX
=
Services
.
appinfo
.
OS
=
=
=
"
Darwin
"
;
if
(
(
(
isOSX
&
&
event
.
metaKey
&
&
!
event
.
ctrlKey
&
&
!
event
.
altKey
)
|
|
(
!
isOSX
&
&
event
.
ctrlKey
&
&
!
event
.
metaKey
&
&
!
event
.
altKey
)
)
&
&
event
.
code
=
=
=
"
KeyF
"
)
{
this
.
searchField
.
focus
(
)
;
event
.
preventDefault
(
)
;
}
}
}
;
function
RuleEditor
(
aRuleView
aRule
)
{
this
.
ruleView
=
aRuleView
;
this
.
doc
=
this
.
ruleView
.
styleDocument
;
this
.
rule
=
aRule
;
this
.
isEditable
=
!
aRule
.
isSystem
;
this
.
isEditing
=
false
;
this
.
_onNewProperty
=
this
.
_onNewProperty
.
bind
(
this
)
;
this
.
_newPropertyDestroy
=
this
.
_newPropertyDestroy
.
bind
(
this
)
;
this
.
_onSelectorDone
=
this
.
_onSelectorDone
.
bind
(
this
)
;
this
.
_create
(
)
;
}
RuleEditor
.
prototype
=
{
get
isSelectorEditable
(
)
{
let
toolbox
=
this
.
ruleView
.
inspector
.
toolbox
;
let
trait
=
this
.
isEditable
&
&
toolbox
.
target
.
client
.
traits
.
selectorEditable
&
&
this
.
rule
.
domRule
.
type
!
=
=
ELEMENT_STYLE
&
&
this
.
rule
.
domRule
.
type
!
=
=
Ci
.
nsIDOMCSSRule
.
KEYFRAME_RULE
;
return
trait
&
&
!
this
.
rule
.
elementStyle
.
element
.
isAnonymous
;
}
_create
:
function
(
)
{
this
.
element
=
this
.
doc
.
createElementNS
(
HTML_NS
"
div
"
)
;
this
.
element
.
className
=
"
ruleview
-
rule
theme
-
separator
"
;
this
.
element
.
setAttribute
(
"
uneditable
"
!
this
.
isEditable
)
;
this
.
element
.
_ruleEditor
=
this
;
this
.
element
.
style
.
position
=
"
relative
"
;
this
.
source
=
createChild
(
this
.
element
"
div
"
{
class
:
"
ruleview
-
rule
-
source
theme
-
link
"
}
)
;
this
.
source
.
addEventListener
(
"
click
"
function
(
)
{
if
(
this
.
source
.
hasAttribute
(
"
unselectable
"
)
)
{
return
;
}
let
rule
=
this
.
rule
.
domRule
;
this
.
ruleView
.
emit
(
"
ruleview
-
linked
-
clicked
"
rule
)
;
}
.
bind
(
this
)
)
;
let
sourceLabel
=
this
.
doc
.
createElementNS
(
XUL_NS
"
label
"
)
;
sourceLabel
.
setAttribute
(
"
crop
"
"
center
"
)
;
sourceLabel
.
classList
.
add
(
"
ruleview
-
rule
-
source
-
label
"
)
;
this
.
source
.
appendChild
(
sourceLabel
)
;
this
.
updateSourceLink
(
)
;
let
code
=
createChild
(
this
.
element
"
div
"
{
class
:
"
ruleview
-
code
"
}
)
;
let
header
=
createChild
(
code
"
div
"
{
}
)
;
this
.
selectorText
=
createChild
(
header
"
span
"
{
class
:
"
ruleview
-
selectorcontainer
theme
-
fg
-
color3
"
tabindex
:
this
.
isSelectorEditable
?
"
0
"
:
"
-
1
"
}
)
;
if
(
this
.
isSelectorEditable
)
{
this
.
selectorText
.
addEventListener
(
"
click
"
aEvent
=
>
{
aEvent
.
stopPropagation
(
)
;
}
false
)
;
editableField
(
{
element
:
this
.
selectorText
done
:
this
.
_onSelectorDone
}
)
;
}
if
(
this
.
rule
.
domRule
.
type
!
=
=
Ci
.
nsIDOMCSSRule
.
KEYFRAME_RULE
&
&
this
.
rule
.
domRule
.
selectors
)
{
let
selector
=
this
.
rule
.
domRule
.
selectors
.
join
(
"
"
)
;
let
selectorHighlighter
=
createChild
(
header
"
span
"
{
class
:
"
ruleview
-
selectorhighlighter
"
+
(
this
.
ruleView
.
highlightedSelector
=
=
=
selector
?
"
highlighted
"
:
"
"
)
title
:
CssLogic
.
l10n
(
"
rule
.
selectorHighlighter
.
tooltip
"
)
}
)
;
selectorHighlighter
.
addEventListener
(
"
click
"
(
)
=
>
{
this
.
ruleView
.
toggleSelectorHighlighter
(
selectorHighlighter
selector
)
;
}
)
;
}
this
.
openBrace
=
createChild
(
header
"
span
"
{
class
:
"
ruleview
-
ruleopen
"
textContent
:
"
{
"
}
)
;
this
.
propertyList
=
createChild
(
code
"
ul
"
{
class
:
"
ruleview
-
propertylist
"
}
)
;
this
.
populate
(
)
;
this
.
closeBrace
=
createChild
(
code
"
div
"
{
class
:
"
ruleview
-
ruleclose
"
tabindex
:
this
.
isEditable
?
"
0
"
:
"
-
1
"
textContent
:
"
}
"
}
)
;
if
(
this
.
isEditable
)
{
code
.
addEventListener
(
"
click
"
(
)
=
>
{
let
selection
=
this
.
doc
.
defaultView
.
getSelection
(
)
;
if
(
selection
.
isCollapsed
)
{
this
.
newProperty
(
)
;
}
}
false
)
;
this
.
element
.
addEventListener
(
"
mousedown
"
(
)
=
>
{
this
.
doc
.
defaultView
.
focus
(
)
;
}
false
)
;
editableItem
(
{
element
:
this
.
closeBrace
}
(
)
=
>
{
this
.
newProperty
(
)
;
}
)
;
}
}
updateSourceLink
:
function
(
)
{
let
sourceLabel
=
this
.
element
.
querySelector
(
"
.
ruleview
-
rule
-
source
-
label
"
)
;
let
sourceHref
=
(
this
.
rule
.
sheet
&
&
this
.
rule
.
sheet
.
href
)
?
this
.
rule
.
sheet
.
href
:
this
.
rule
.
title
;
let
sourceLine
=
this
.
rule
.
ruleLine
>
0
?
"
:
"
+
this
.
rule
.
ruleLine
:
"
"
;
sourceLabel
.
setAttribute
(
"
tooltiptext
"
sourceHref
+
sourceLine
)
;
if
(
this
.
rule
.
isSystem
)
{
let
uaLabel
=
_strings
.
GetStringFromName
(
"
rule
.
userAgentStyles
"
)
;
sourceLabel
.
setAttribute
(
"
value
"
uaLabel
+
"
"
+
this
.
rule
.
title
)
;
if
(
sourceHref
=
=
=
"
about
:
PreferenceStyleSheet
"
)
{
sourceLabel
.
parentNode
.
setAttribute
(
"
unselectable
"
"
true
"
)
;
sourceLabel
.
setAttribute
(
"
value
"
uaLabel
)
;
sourceLabel
.
removeAttribute
(
"
tooltiptext
"
)
;
}
}
else
{
sourceLabel
.
setAttribute
(
"
value
"
this
.
rule
.
title
)
;
if
(
this
.
rule
.
ruleLine
=
=
=
-
1
&
&
this
.
rule
.
domRule
.
parentStyleSheet
)
{
sourceLabel
.
parentNode
.
setAttribute
(
"
unselectable
"
"
true
"
)
;
}
}
let
showOrig
=
Services
.
prefs
.
getBoolPref
(
PREF_ORIG_SOURCES
)
;
if
(
showOrig
&
&
!
this
.
rule
.
isSystem
&
&
this
.
rule
.
domRule
.
type
!
=
=
ELEMENT_STYLE
)
{
this
.
rule
.
getOriginalSourceStrings
(
)
.
then
(
(
strings
)
=
>
{
sourceLabel
.
setAttribute
(
"
value
"
strings
.
short
)
;
sourceLabel
.
setAttribute
(
"
tooltiptext
"
strings
.
full
)
;
}
console
.
error
)
;
}
}
populate
:
function
(
)
{
while
(
this
.
selectorText
.
hasChildNodes
(
)
)
{
this
.
selectorText
.
removeChild
(
this
.
selectorText
.
lastChild
)
;
}
if
(
this
.
rule
.
domRule
.
type
=
=
=
ELEMENT_STYLE
)
{
this
.
selectorText
.
textContent
=
this
.
rule
.
selectorText
;
}
else
if
(
this
.
rule
.
domRule
.
type
=
=
=
Ci
.
nsIDOMCSSRule
.
KEYFRAME_RULE
)
{
this
.
selectorText
.
textContent
=
this
.
rule
.
domRule
.
keyText
;
}
else
{
this
.
rule
.
domRule
.
selectors
.
forEach
(
(
selector
i
)
=
>
{
if
(
i
!
=
=
0
)
{
createChild
(
this
.
selectorText
"
span
"
{
class
:
"
ruleview
-
selector
-
separator
"
textContent
:
"
"
}
)
;
}
let
containerClass
=
(
this
.
rule
.
matchedSelectors
.
indexOf
(
selector
)
>
-
1
)
?
"
ruleview
-
selector
-
matched
"
:
"
ruleview
-
selector
-
unmatched
"
;
let
selectorContainer
=
createChild
(
this
.
selectorText
"
span
"
{
class
:
containerClass
}
)
;
let
parsedSelector
=
parsePseudoClassesAndAttributes
(
selector
)
;
for
(
let
selectorText
of
parsedSelector
)
{
let
selectorClass
=
"
"
;
switch
(
selectorText
.
type
)
{
case
SELECTOR_ATTRIBUTE
:
selectorClass
=
"
ruleview
-
selector
-
attribute
"
;
break
;
case
SELECTOR_ELEMENT
:
selectorClass
=
"
ruleview
-
selector
"
;
break
;
case
SELECTOR_PSEUDO_CLASS
:
selectorClass
=
[
"
:
active
"
"
:
focus
"
"
:
hover
"
]
.
some
(
pseudo
=
>
selectorText
.
value
=
=
=
pseudo
)
?
"
ruleview
-
selector
-
pseudo
-
class
-
lock
"
:
"
ruleview
-
selector
-
pseudo
-
class
"
;
break
;
default
:
break
;
}
createChild
(
selectorContainer
"
span
"
{
textContent
:
selectorText
.
value
class
:
selectorClass
}
)
;
}
}
)
;
}
for
(
let
prop
of
this
.
rule
.
textProps
)
{
if
(
!
prop
.
editor
)
{
let
editor
=
new
TextPropertyEditor
(
this
prop
)
;
this
.
propertyList
.
appendChild
(
editor
.
element
)
;
}
}
}
addProperty
:
function
(
name
value
priority
siblingProp
)
{
let
prop
=
this
.
rule
.
createProperty
(
name
value
priority
siblingProp
)
;
let
index
=
this
.
rule
.
textProps
.
indexOf
(
prop
)
;
let
editor
=
new
TextPropertyEditor
(
this
prop
)
;
this
.
propertyList
.
insertBefore
(
editor
.
element
this
.
propertyList
.
children
[
index
]
)
;
return
prop
;
}
addProperties
:
function
(
aProperties
aSiblingProp
)
{
if
(
!
aProperties
|
|
!
aProperties
.
length
)
{
return
;
}
let
lastProp
=
aSiblingProp
;
for
(
let
p
of
aProperties
)
{
lastProp
=
this
.
addProperty
(
p
.
name
p
.
value
p
.
priority
lastProp
)
;
}
if
(
lastProp
&
&
lastProp
.
value
.
trim
(
)
=
=
=
"
"
)
{
lastProp
.
editor
.
valueSpan
.
click
(
)
;
}
else
{
this
.
newProperty
(
)
;
}
}
newProperty
:
function
(
)
{
if
(
!
this
.
closeBrace
.
hasAttribute
(
"
tabindex
"
)
)
{
return
;
}
this
.
closeBrace
.
removeAttribute
(
"
tabindex
"
)
;
this
.
newPropItem
=
createChild
(
this
.
propertyList
"
li
"
{
class
:
"
ruleview
-
property
ruleview
-
newproperty
"
}
)
;
this
.
newPropSpan
=
createChild
(
this
.
newPropItem
"
span
"
{
class
:
PROPERTY_NAME_CLASS
tabindex
:
"
0
"
}
)
;
this
.
multipleAddedProperties
=
null
;
this
.
editor
=
new
InplaceEditor
(
{
element
:
this
.
newPropSpan
done
:
this
.
_onNewProperty
destroy
:
this
.
_newPropertyDestroy
advanceChars
:
"
:
"
contentType
:
InplaceEditor
.
CONTENT_TYPES
.
CSS_PROPERTY
popup
:
this
.
ruleView
.
popup
}
)
;
this
.
editor
.
input
.
addEventListener
(
"
paste
"
blurOnMultipleProperties
false
)
;
}
_onNewProperty
:
function
(
aValue
aCommit
)
{
if
(
!
aValue
|
|
!
aCommit
)
{
return
;
}
this
.
multipleAddedProperties
=
parseDeclarations
(
aValue
)
.
filter
(
d
=
>
d
.
name
)
;
this
.
editor
.
input
.
blur
(
)
;
}
_newPropertyDestroy
:
function
(
)
{
this
.
closeBrace
.
setAttribute
(
"
tabindex
"
"
0
"
)
;
this
.
propertyList
.
removeChild
(
this
.
newPropItem
)
;
delete
this
.
newPropItem
;
delete
this
.
newPropSpan
;
if
(
this
.
multipleAddedProperties
&
&
this
.
multipleAddedProperties
.
length
)
{
this
.
addProperties
(
this
.
multipleAddedProperties
)
;
}
}
_onSelectorDone
:
function
(
value
commit
direction
)
{
if
(
!
commit
|
|
this
.
isEditing
|
|
value
=
=
=
"
"
|
|
value
=
=
=
this
.
rule
.
selectorText
)
{
return
;
}
let
ruleView
=
this
.
ruleView
;
let
elementStyle
=
ruleView
.
_elementStyle
;
let
element
=
elementStyle
.
element
;
let
supportsUnmatchedRules
=
this
.
rule
.
domRule
.
supportsModifySelectorUnmatched
;
this
.
isEditing
=
true
;
this
.
rule
.
domRule
.
modifySelector
(
element
value
)
.
then
(
response
=
>
{
this
.
isEditing
=
false
;
if
(
!
supportsUnmatchedRules
)
{
if
(
response
)
{
this
.
ruleView
.
refreshPanel
(
)
;
}
return
;
}
let
{
ruleProps
isMatching
}
=
response
;
if
(
!
ruleProps
)
{
ruleView
.
emit
(
"
ruleview
-
invalid
-
selector
"
)
;
return
;
}
let
newRule
=
new
Rule
(
elementStyle
ruleProps
)
;
let
editor
=
new
RuleEditor
(
ruleView
newRule
)
;
let
rules
=
elementStyle
.
rules
;
rules
.
splice
(
rules
.
indexOf
(
this
.
rule
)
1
)
;
rules
.
push
(
newRule
)
;
elementStyle
.
_changed
(
)
;
editor
.
element
.
setAttribute
(
"
unmatched
"
!
isMatching
)
;
this
.
element
.
parentNode
.
replaceChild
(
editor
.
element
this
.
element
)
;
if
(
ruleView
.
highlightedSelector
&
&
ruleView
.
highlightedSelector
=
=
=
this
.
rule
.
selectorText
)
{
ruleView
.
toggleSelectorHighlighter
(
ruleView
.
lastSelectorIcon
ruleView
.
highlightedSelector
)
;
}
editor
.
_moveSelectorFocus
(
direction
)
;
}
)
.
then
(
null
err
=
>
{
this
.
isEditing
=
false
;
promiseWarn
(
err
)
;
}
)
;
}
_moveSelectorFocus
:
function
(
direction
)
{
if
(
!
direction
|
|
direction
=
=
=
Ci
.
nsIFocusManager
.
MOVEFOCUS_BACKWARD
)
{
return
;
}
if
(
this
.
rule
.
textProps
.
length
>
0
)
{
this
.
rule
.
textProps
[
0
]
.
editor
.
nameSpan
.
click
(
)
;
}
else
{
this
.
propertyList
.
click
(
)
;
}
}
}
;
function
TextPropertyEditor
(
ruleEditor
property
)
{
this
.
ruleEditor
=
ruleEditor
;
this
.
ruleView
=
this
.
ruleEditor
.
ruleView
;
this
.
doc
=
this
.
ruleEditor
.
doc
;
this
.
popup
=
this
.
ruleView
.
popup
;
this
.
prop
=
property
;
this
.
prop
.
editor
=
this
;
this
.
browserWindow
=
this
.
doc
.
defaultView
.
top
;
this
.
_populatedComputed
=
false
;
this
.
_onEnableClicked
=
this
.
_onEnableClicked
.
bind
(
this
)
;
this
.
_onExpandClicked
=
this
.
_onExpandClicked
.
bind
(
this
)
;
this
.
_onStartEditing
=
this
.
_onStartEditing
.
bind
(
this
)
;
this
.
_onNameDone
=
this
.
_onNameDone
.
bind
(
this
)
;
this
.
_onValueDone
=
this
.
_onValueDone
.
bind
(
this
)
;
this
.
_onSwatchCommit
=
this
.
_onSwatchCommit
.
bind
(
this
)
;
this
.
_onSwatchPreview
=
this
.
_onSwatchPreview
.
bind
(
this
)
;
this
.
_onSwatchRevert
=
this
.
_onSwatchRevert
.
bind
(
this
)
;
this
.
_onValidate
=
throttle
(
this
.
_previewValue
10
this
)
;
this
.
update
=
this
.
update
.
bind
(
this
)
;
this
.
_create
(
)
;
this
.
update
(
)
;
}
TextPropertyEditor
.
prototype
=
{
get
editing
(
)
{
return
!
!
(
this
.
nameSpan
.
inplaceEditor
|
|
this
.
valueSpan
.
inplaceEditor
|
|
this
.
ruleView
.
tooltips
.
isEditing
)
|
|
this
.
popup
.
isOpen
;
}
get
rule
(
)
{
return
this
.
prop
.
rule
;
}
_create
:
function
(
)
{
this
.
element
=
this
.
doc
.
createElementNS
(
HTML_NS
"
li
"
)
;
this
.
element
.
classList
.
add
(
"
ruleview
-
property
"
)
;
this
.
element
.
_textPropertyEditor
=
this
;
this
.
container
=
createChild
(
this
.
element
"
div
"
{
class
:
"
ruleview
-
propertycontainer
"
}
)
;
this
.
enable
=
createChild
(
this
.
container
"
div
"
{
class
:
"
ruleview
-
enableproperty
theme
-
checkbox
"
tabindex
:
"
-
1
"
}
)
;
this
.
expander
=
createChild
(
this
.
container
"
span
"
{
class
:
"
ruleview
-
expander
theme
-
twisty
"
}
)
;
this
.
expander
.
addEventListener
(
"
click
"
this
.
_onExpandClicked
true
)
;
this
.
nameContainer
=
createChild
(
this
.
container
"
span
"
{
class
:
"
ruleview
-
namecontainer
"
}
)
;
this
.
nameSpan
=
createChild
(
this
.
nameContainer
"
span
"
{
class
:
"
ruleview
-
propertyname
theme
-
fg
-
color5
"
tabindex
:
this
.
ruleEditor
.
isEditable
?
"
0
"
:
"
-
1
"
}
)
;
appendText
(
this
.
nameContainer
"
:
"
)
;
let
propertyContainer
=
createChild
(
this
.
container
"
span
"
{
class
:
"
ruleview
-
propertyvaluecontainer
"
}
)
;
this
.
valueSpan
=
createChild
(
propertyContainer
"
span
"
{
class
:
"
ruleview
-
propertyvalue
theme
-
fg
-
color1
"
tabindex
:
this
.
ruleEditor
.
isEditable
?
"
0
"
:
"
-
1
"
}
)
;
this
.
valueSpan
.
textProperty
=
this
.
prop
;
this
.
nameSpan
.
textProperty
=
this
.
prop
;
let
outputParser
=
this
.
ruleView
.
_outputParser
;
let
frag
=
outputParser
.
parseCssProperty
(
this
.
prop
.
name
this
.
prop
.
value
)
;
let
parsedValue
=
frag
.
textContent
;
this
.
committed
=
{
name
:
this
.
prop
.
name
value
:
parsedValue
priority
:
this
.
prop
.
priority
}
;
appendText
(
propertyContainer
"
;
"
)
;
this
.
warning
=
createChild
(
this
.
container
"
div
"
{
class
:
"
ruleview
-
warning
"
hidden
:
"
"
title
:
CssLogic
.
l10n
(
"
rule
.
warning
.
title
"
)
}
)
;
this
.
filterProperty
=
createChild
(
this
.
container
"
div
"
{
class
:
"
ruleview
-
overridden
-
rule
-
filter
"
hidden
:
"
"
title
:
CssLogic
.
l10n
(
"
rule
.
filterProperty
.
title
"
)
}
)
;
this
.
filterProperty
.
addEventListener
(
"
click
"
event
=
>
{
this
.
ruleEditor
.
ruleView
.
setFilterStyles
(
"
"
+
this
.
prop
.
name
+
"
"
)
;
event
.
stopPropagation
(
)
;
}
false
)
;
this
.
computed
=
createChild
(
this
.
element
"
ul
"
{
class
:
"
ruleview
-
computedlist
"
}
)
;
if
(
this
.
ruleEditor
.
isEditable
)
{
this
.
enable
.
addEventListener
(
"
click
"
this
.
_onEnableClicked
true
)
;
this
.
nameContainer
.
addEventListener
(
"
click
"
(
event
)
=
>
{
event
.
stopPropagation
(
)
;
if
(
event
.
target
=
=
=
propertyContainer
)
{
this
.
nameSpan
.
click
(
)
;
}
}
false
)
;
editableField
(
{
start
:
this
.
_onStartEditing
element
:
this
.
nameSpan
done
:
this
.
_onNameDone
destroy
:
this
.
update
advanceChars
:
"
:
"
contentType
:
InplaceEditor
.
CONTENT_TYPES
.
CSS_PROPERTY
popup
:
this
.
popup
}
)
;
this
.
nameContainer
.
addEventListener
(
"
paste
"
blurOnMultipleProperties
false
)
;
propertyContainer
.
addEventListener
(
"
click
"
(
event
)
=
>
{
event
.
stopPropagation
(
)
;
if
(
event
.
target
=
=
=
propertyContainer
)
{
this
.
valueSpan
.
click
(
)
;
}
}
false
)
;
this
.
valueSpan
.
addEventListener
(
"
click
"
(
event
)
=
>
{
let
target
=
event
.
target
;
if
(
target
.
nodeName
=
=
=
"
a
"
)
{
event
.
stopPropagation
(
)
;
event
.
preventDefault
(
)
;
this
.
browserWindow
.
openUILinkIn
(
target
.
href
"
tab
"
)
;
}
}
false
)
;
editableField
(
{
start
:
this
.
_onStartEditing
element
:
this
.
valueSpan
done
:
this
.
_onValueDone
destroy
:
this
.
update
validate
:
this
.
_onValidate
advanceChars
:
advanceValidate
contentType
:
InplaceEditor
.
CONTENT_TYPES
.
CSS_VALUE
property
:
this
.
prop
popup
:
this
.
popup
}
)
;
}
}
get
sheetHref
(
)
{
let
domRule
=
this
.
rule
.
domRule
;
if
(
domRule
)
{
return
domRule
.
href
|
|
domRule
.
nodeHref
;
}
}
get
sheetURI
(
)
{
if
(
this
.
_sheetURI
=
=
=
undefined
)
{
if
(
this
.
sheetHref
)
{
this
.
_sheetURI
=
IOService
.
newURI
(
this
.
sheetHref
null
null
)
;
}
else
{
this
.
_sheetURI
=
null
;
}
}
return
this
.
_sheetURI
;
}
resolveURI
:
function
(
relativePath
)
{
if
(
this
.
sheetURI
)
{
relativePath
=
this
.
sheetURI
.
resolve
(
relativePath
)
;
}
return
relativePath
;
}
update
:
function
(
)
{
if
(
this
.
ruleView
.
isDestroyed
)
{
return
;
}
if
(
this
.
prop
.
enabled
)
{
this
.
enable
.
style
.
removeProperty
(
"
visibility
"
)
;
this
.
enable
.
setAttribute
(
"
checked
"
"
"
)
;
}
else
{
this
.
enable
.
style
.
visibility
=
"
visible
"
;
this
.
enable
.
removeAttribute
(
"
checked
"
)
;
}
this
.
warning
.
hidden
=
this
.
editing
|
|
this
.
isValid
(
)
;
this
.
filterProperty
.
hidden
=
this
.
editing
|
|
!
this
.
isValid
(
)
|
|
!
this
.
prop
.
overridden
;
if
(
this
.
prop
.
overridden
|
|
!
this
.
prop
.
enabled
)
{
this
.
element
.
classList
.
add
(
"
ruleview
-
overridden
"
)
;
}
else
{
this
.
element
.
classList
.
remove
(
"
ruleview
-
overridden
"
)
;
}
let
name
=
this
.
prop
.
name
;
this
.
nameSpan
.
textContent
=
name
;
let
store
=
this
.
rule
.
elementStyle
.
store
;
let
val
=
store
.
userProperties
.
getProperty
(
this
.
rule
.
style
name
this
.
prop
.
value
)
;
if
(
this
.
prop
.
priority
)
{
val
+
=
"
!
"
+
this
.
prop
.
priority
;
}
let
propDirty
=
store
.
userProperties
.
contains
(
this
.
rule
.
style
name
)
;
if
(
propDirty
)
{
this
.
element
.
setAttribute
(
"
dirty
"
"
"
)
;
}
else
{
this
.
element
.
removeAttribute
(
"
dirty
"
)
;
}
const
sharedSwatchClass
=
"
ruleview
-
swatch
"
;
const
colorSwatchClass
=
"
ruleview
-
colorswatch
"
;
const
bezierSwatchClass
=
"
ruleview
-
bezierswatch
"
;
const
filterSwatchClass
=
"
ruleview
-
filterswatch
"
;
let
outputParser
=
this
.
ruleView
.
_outputParser
;
let
parserOptions
=
{
colorSwatchClass
:
sharedSwatchClass
+
colorSwatchClass
colorClass
:
"
ruleview
-
color
"
bezierSwatchClass
:
sharedSwatchClass
+
bezierSwatchClass
bezierClass
:
"
ruleview
-
bezier
"
filterSwatchClass
:
sharedSwatchClass
+
filterSwatchClass
filterClass
:
"
ruleview
-
filter
"
defaultColorType
:
!
propDirty
urlClass
:
"
theme
-
link
"
baseURI
:
this
.
sheetURI
}
;
let
frag
=
outputParser
.
parseCssProperty
(
name
val
parserOptions
)
;
this
.
valueSpan
.
innerHTML
=
"
"
;
this
.
valueSpan
.
appendChild
(
frag
)
;
this
.
_colorSwatchSpans
=
this
.
valueSpan
.
querySelectorAll
(
"
.
"
+
colorSwatchClass
)
;
if
(
this
.
ruleEditor
.
isEditable
)
{
for
(
let
span
of
this
.
_colorSwatchSpans
)
{
this
.
ruleView
.
tooltips
.
colorPicker
.
addSwatch
(
span
{
onShow
:
this
.
_onStartEditing
onPreview
:
this
.
_onSwatchPreview
onCommit
:
this
.
_onSwatchCommit
onRevert
:
this
.
_onSwatchRevert
}
)
;
}
}
this
.
_bezierSwatchSpans
=
this
.
valueSpan
.
querySelectorAll
(
"
.
"
+
bezierSwatchClass
)
;
if
(
this
.
ruleEditor
.
isEditable
)
{
for
(
let
span
of
this
.
_bezierSwatchSpans
)
{
this
.
ruleView
.
tooltips
.
cubicBezier
.
addSwatch
(
span
{
onShow
:
this
.
_onStartEditing
onPreview
:
this
.
_onSwatchPreview
onCommit
:
this
.
_onSwatchCommit
onRevert
:
this
.
_onSwatchRevert
}
)
;
}
}
let
span
=
this
.
valueSpan
.
querySelector
(
"
.
"
+
filterSwatchClass
)
;
if
(
this
.
ruleEditor
.
isEditable
)
{
if
(
span
)
{
parserOptions
.
filterSwatch
=
true
;
this
.
ruleView
.
tooltips
.
filterEditor
.
addSwatch
(
span
{
onShow
:
this
.
_onStartEditing
onPreview
:
this
.
_onSwatchPreview
onCommit
:
this
.
_onSwatchCommit
onRevert
:
this
.
_onSwatchRevert
}
outputParser
parserOptions
)
;
}
}
this
.
_updateComputed
(
)
;
this
.
ruleView
.
_updatePropertyHighlight
(
this
)
;
}
_onStartEditing
:
function
(
)
{
this
.
element
.
classList
.
remove
(
"
ruleview
-
overridden
"
)
;
this
.
enable
.
style
.
visibility
=
"
hidden
"
;
}
_updateComputed
:
function
(
)
{
this
.
computed
.
innerHTML
=
"
"
;
let
showExpander
=
this
.
prop
.
computed
.
some
(
c
=
>
c
.
name
!
=
=
this
.
prop
.
name
)
;
this
.
expander
.
style
.
visibility
=
showExpander
?
"
visible
"
:
"
hidden
"
;
this
.
_populatedComputed
=
false
;
if
(
this
.
expander
.
hasAttribute
(
"
open
"
)
)
{
this
.
_populateComputed
(
)
;
}
}
_populateComputed
:
function
(
)
{
if
(
this
.
_populatedComputed
)
{
return
;
}
this
.
_populatedComputed
=
true
;
for
(
let
computed
of
this
.
prop
.
computed
)
{
if
(
computed
.
name
=
=
=
this
.
prop
.
name
)
{
continue
;
}
let
li
=
createChild
(
this
.
computed
"
li
"
{
class
:
"
ruleview
-
computed
"
}
)
;
if
(
computed
.
overridden
)
{
li
.
classList
.
add
(
"
ruleview
-
overridden
"
)
;
}
createChild
(
li
"
span
"
{
class
:
"
ruleview
-
propertyname
theme
-
fg
-
color5
"
textContent
:
computed
.
name
}
)
;
appendText
(
li
"
:
"
)
;
let
outputParser
=
this
.
ruleView
.
_outputParser
;
let
frag
=
outputParser
.
parseCssProperty
(
computed
.
name
computed
.
value
{
colorSwatchClass
:
"
ruleview
-
swatch
ruleview
-
colorswatch
"
urlClass
:
"
theme
-
link
"
baseURI
:
this
.
sheetURI
}
)
;
computed
.
parsedValue
=
frag
.
textContent
;
createChild
(
li
"
span
"
{
class
:
"
ruleview
-
propertyvalue
theme
-
fg
-
color1
"
child
:
frag
}
)
;
appendText
(
li
"
;
"
)
;
computed
.
element
=
li
;
}
}
_onEnableClicked
:
function
(
event
)
{
let
checked
=
this
.
enable
.
hasAttribute
(
"
checked
"
)
;
if
(
checked
)
{
this
.
enable
.
removeAttribute
(
"
checked
"
)
;
}
else
{
this
.
enable
.
setAttribute
(
"
checked
"
"
"
)
;
}
this
.
prop
.
setEnabled
(
!
checked
)
;
event
.
stopPropagation
(
)
;
}
_onExpandClicked
:
function
(
event
)
{
if
(
this
.
computed
.
hasAttribute
(
"
filter
-
open
"
)
|
|
this
.
computed
.
hasAttribute
(
"
user
-
open
"
)
)
{
this
.
expander
.
removeAttribute
(
"
open
"
)
;
this
.
computed
.
removeAttribute
(
"
filter
-
open
"
)
;
this
.
computed
.
removeAttribute
(
"
user
-
open
"
)
;
}
else
{
this
.
expander
.
setAttribute
(
"
open
"
"
true
"
)
;
this
.
computed
.
setAttribute
(
"
user
-
open
"
"
"
)
;
this
.
_populateComputed
(
)
;
}
event
.
stopPropagation
(
)
;
}
expandForFilter
:
function
(
)
{
if
(
!
this
.
computed
.
hasAttribute
(
"
user
-
open
"
)
)
{
this
.
expander
.
setAttribute
(
"
open
"
"
true
"
)
;
this
.
computed
.
setAttribute
(
"
filter
-
open
"
"
"
)
;
this
.
_populateComputed
(
)
;
}
}
collapseForFilter
:
function
(
)
{
this
.
computed
.
removeAttribute
(
"
filter
-
open
"
)
;
if
(
!
this
.
computed
.
hasAttribute
(
"
user
-
open
"
)
)
{
this
.
expander
.
removeAttribute
(
"
open
"
)
;
}
}
_onNameDone
:
function
(
value
commit
direction
)
{
let
isNameUnchanged
=
(
!
commit
&
&
!
this
.
ruleEditor
.
isEditing
)
|
|
this
.
committed
.
name
=
=
=
value
;
if
(
this
.
prop
.
value
&
&
isNameUnchanged
)
{
return
;
}
if
(
!
value
.
trim
(
)
)
{
this
.
remove
(
direction
)
;
return
;
}
if
(
!
this
.
prop
.
value
&
&
direction
!
=
=
Ci
.
nsIFocusManager
.
MOVEFOCUS_FORWARD
)
{
this
.
remove
(
direction
)
;
return
;
}
let
properties
=
parseDeclarations
(
value
)
;
if
(
properties
.
length
)
{
this
.
prop
.
setName
(
properties
[
0
]
.
name
)
;
this
.
committed
.
name
=
this
.
prop
.
name
;
if
(
!
this
.
prop
.
enabled
)
{
this
.
prop
.
setEnabled
(
true
)
;
}
if
(
properties
.
length
>
1
)
{
this
.
prop
.
setValue
(
properties
[
0
]
.
value
properties
[
0
]
.
priority
)
;
this
.
ruleEditor
.
addProperties
(
properties
.
slice
(
1
)
this
.
prop
)
;
}
}
}
remove
:
function
(
direction
)
{
if
(
this
.
_colorSwatchSpans
&
&
this
.
_colorSwatchSpans
.
length
)
{
for
(
let
span
of
this
.
_colorSwatchSpans
)
{
this
.
ruleView
.
tooltips
.
colorPicker
.
removeSwatch
(
span
)
;
}
}
this
.
element
.
parentNode
.
removeChild
(
this
.
element
)
;
this
.
ruleEditor
.
rule
.
editClosestTextProperty
(
this
.
prop
direction
)
;
this
.
nameSpan
.
textProperty
=
null
;
this
.
valueSpan
.
textProperty
=
null
;
this
.
prop
.
remove
(
)
;
}
_onValueDone
:
function
(
value
=
"
"
commit
direction
)
{
let
parsedProperties
=
this
.
_getValueAndExtraProperties
(
value
)
;
let
val
=
parseSingleValue
(
parsedProperties
.
firstValue
)
;
let
isValueUnchanged
=
(
!
commit
&
&
!
this
.
ruleEditor
.
isEditing
)
|
|
!
parsedProperties
.
propertiesToAdd
.
length
&
&
this
.
committed
.
value
=
=
=
val
.
value
&
&
this
.
committed
.
priority
=
=
=
val
.
priority
;
if
(
value
.
trim
(
)
&
&
isValueUnchanged
)
{
this
.
rule
.
setPropertyEnabled
(
this
.
prop
this
.
prop
.
enabled
)
;
return
;
}
this
.
prop
.
setValue
(
val
.
value
val
.
priority
)
;
if
(
!
this
.
prop
.
enabled
)
{
this
.
prop
.
setEnabled
(
true
)
;
}
this
.
committed
.
value
=
this
.
prop
.
value
;
this
.
committed
.
priority
=
this
.
prop
.
priority
;
this
.
ruleEditor
.
addProperties
(
parsedProperties
.
propertiesToAdd
this
.
prop
)
;
if
(
!
value
.
trim
(
)
&
&
direction
!
=
=
Ci
.
nsIFocusManager
.
MOVEFOCUS_BACKWARD
)
{
setTimeout
(
(
)
=
>
{
if
(
!
this
.
editing
)
{
this
.
remove
(
direction
)
;
}
}
0
)
;
}
}
_onSwatchCommit
:
function
(
)
{
this
.
_onValueDone
(
this
.
valueSpan
.
textContent
true
)
;
this
.
update
(
)
;
}
_onSwatchPreview
:
function
(
)
{
this
.
_previewValue
(
this
.
valueSpan
.
textContent
)
;
}
_onSwatchRevert
:
function
(
)
{
this
.
rule
.
setPropertyEnabled
(
this
.
prop
this
.
prop
.
enabled
)
;
this
.
update
(
)
;
}
_getValueAndExtraProperties
:
function
(
value
)
{
let
firstValue
=
value
;
let
propertiesToAdd
=
[
]
;
let
properties
=
parseDeclarations
(
value
)
;
if
(
properties
.
length
)
{
if
(
!
properties
[
0
]
.
name
&
&
properties
[
0
]
.
value
)
{
firstValue
=
properties
[
0
]
.
value
;
propertiesToAdd
=
properties
.
slice
(
1
)
;
}
else
if
(
properties
[
0
]
.
name
&
&
properties
[
0
]
.
value
)
{
firstValue
=
properties
[
0
]
.
name
+
"
:
"
+
properties
[
0
]
.
value
;
propertiesToAdd
=
properties
.
slice
(
1
)
;
}
}
return
{
propertiesToAdd
:
propertiesToAdd
firstValue
:
firstValue
}
;
}
_previewValue
:
function
(
value
)
{
if
(
!
this
.
editing
|
|
this
.
ruleEditor
.
isEditing
)
{
return
;
}
let
val
=
parseSingleValue
(
value
)
;
this
.
ruleEditor
.
rule
.
previewPropertyValue
(
this
.
prop
val
.
value
val
.
priority
)
;
}
isValid
:
function
(
)
{
return
domUtils
.
cssPropertyIsValid
(
this
.
prop
.
name
this
.
prop
.
value
)
;
}
}
;
function
UserProperties
(
)
{
this
.
map
=
new
Map
(
)
;
}
UserProperties
.
prototype
=
{
getProperty
:
function
(
style
name
value
)
{
let
key
=
this
.
getKey
(
style
)
;
let
entry
=
this
.
map
.
get
(
key
null
)
;
if
(
entry
&
&
name
in
entry
)
{
return
entry
[
name
]
;
}
return
value
;
}
setProperty
:
function
(
style
bame
userValue
)
{
let
key
=
this
.
getKey
(
style
bame
)
;
let
entry
=
this
.
map
.
get
(
key
null
)
;
if
(
entry
)
{
entry
[
bame
]
=
userValue
;
}
else
{
let
props
=
{
}
;
props
[
bame
]
=
userValue
;
this
.
map
.
set
(
key
props
)
;
}
}
contains
:
function
(
style
name
)
{
let
key
=
this
.
getKey
(
style
name
)
;
let
entry
=
this
.
map
.
get
(
key
null
)
;
return
!
!
entry
&
&
name
in
entry
;
}
getKey
:
function
(
style
name
)
{
return
style
.
actorID
+
"
:
"
+
name
;
}
clear
:
function
(
)
{
this
.
map
.
clear
(
)
;
}
}
;
function
getParentTextPropertyHolder
(
node
)
{
while
(
true
)
{
if
(
!
node
|
|
!
node
.
classList
)
{
return
null
;
}
if
(
node
.
classList
.
contains
(
"
ruleview
-
property
"
)
)
{
return
node
;
}
node
=
node
.
parentNode
;
}
}
function
getParentTextProperty
(
node
)
{
let
parent
=
getParentTextPropertyHolder
(
node
)
;
if
(
!
parent
)
{
return
null
;
}
let
propValue
=
parent
.
querySelector
(
"
.
ruleview
-
propertyvalue
"
)
;
if
(
!
propValue
)
{
return
null
;
}
return
propValue
.
textProperty
;
}
function
getPropertyNameAndValue
(
node
)
{
while
(
true
)
{
if
(
!
node
|
|
!
node
.
classList
)
{
return
null
;
}
if
(
node
.
classList
.
contains
(
"
ruleview
-
computed
"
)
|
|
node
.
classList
.
contains
(
"
ruleview
-
property
"
)
)
{
return
{
name
:
node
.
querySelector
(
"
.
ruleview
-
propertyname
"
)
.
textContent
value
:
node
.
querySelector
(
"
.
ruleview
-
propertyvalue
"
)
.
textContent
}
;
}
node
=
node
.
parentNode
;
}
}
XPCOMUtils
.
defineLazyGetter
(
this
"
clipboardHelper
"
function
(
)
{
return
Cc
[
"
mozilla
.
org
/
widget
/
clipboardhelper
;
1
"
]
.
getService
(
Ci
.
nsIClipboardHelper
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
osString
"
function
(
)
{
return
Cc
[
"
mozilla
.
org
/
xre
/
app
-
info
;
1
"
]
.
getService
(
Ci
.
nsIXULRuntime
)
.
OS
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
_strings
"
function
(
)
{
return
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
global
/
locale
/
devtools
/
styleinspector
.
properties
"
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
domUtils
"
function
(
)
{
return
Cc
[
"
mozilla
.
org
/
inspector
/
dom
-
utils
;
1
"
]
.
getService
(
Ci
.
inIDOMUtils
)
;
}
)
;
loader
.
lazyGetter
(
this
"
AutocompletePopup
"
function
(
)
{
return
require
(
"
devtools
/
shared
/
autocomplete
-
popup
"
)
.
AutocompletePopup
;
}
)
;
