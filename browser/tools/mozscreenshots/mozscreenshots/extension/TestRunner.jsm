"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
TestRunner
"
]
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
const
env
=
Cc
[
"
mozilla
.
org
/
process
/
environment
;
1
"
]
.
getService
(
Ci
.
nsIEnvironment
)
;
const
APPLY_CONFIG_TIMEOUT_MS
=
60
*
1000
;
const
HOME_PAGE
=
"
chrome
:
/
/
mozscreenshots
/
content
/
lib
/
mozscreenshots
.
html
"
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Geometry
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
BrowserTestUtils
"
"
resource
:
/
/
testing
-
common
/
BrowserTestUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Screenshot
"
"
chrome
:
/
/
mozscreenshots
/
content
/
Screenshot
.
jsm
"
)
;
const
PREF_LOG_LEVEL
=
"
extensions
.
mozscreenshots
mozilla
.
org
.
loglevel
"
;
XPCOMUtils
.
defineLazyGetter
(
this
"
log
"
(
)
=
>
{
let
ConsoleAPI
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Console
.
jsm
"
{
}
)
.
ConsoleAPI
;
let
consoleOptions
=
{
maxLogLevel
:
"
info
"
maxLogLevelPref
:
PREF_LOG_LEVEL
prefix
:
"
mozscreenshots
"
}
;
return
new
ConsoleAPI
(
consoleOptions
)
;
}
)
;
this
.
TestRunner
=
{
combos
:
null
completedCombos
:
0
currentComboIndex
:
0
_lastCombo
:
null
_libDir
:
null
croppingPadding
:
10
init
(
extensionPath
)
{
log
.
debug
(
"
init
"
)
;
this
.
_extensionPath
=
extensionPath
;
}
async
start
(
setNames
jobName
=
null
)
{
let
subDirs
=
[
"
mozscreenshots
"
(
new
Date
(
)
)
.
toISOString
(
)
.
replace
(
/
:
/
g
"
-
"
)
+
"
_
"
+
Services
.
appinfo
.
OS
]
;
let
screenshotPath
=
FileUtils
.
getFile
(
"
TmpD
"
subDirs
)
.
path
;
const
MOZ_UPLOAD_DIR
=
env
.
get
(
"
MOZ_UPLOAD_DIR
"
)
;
if
(
MOZ_UPLOAD_DIR
)
{
screenshotPath
=
MOZ_UPLOAD_DIR
;
}
log
.
info
(
"
Saving
screenshots
to
:
"
screenshotPath
)
;
let
screenshotPrefix
=
Services
.
appinfo
.
appBuildID
;
if
(
jobName
)
{
screenshotPrefix
+
=
"
-
"
+
jobName
;
}
screenshotPrefix
+
=
"
_
"
;
Screenshot
.
init
(
screenshotPath
this
.
_extensionPath
screenshotPrefix
)
;
this
.
_libDir
=
this
.
_extensionPath
.
QueryInterface
(
Ci
.
nsIFileURL
)
.
file
.
clone
(
)
;
this
.
_libDir
.
append
(
"
chrome
"
)
;
this
.
_libDir
.
append
(
"
mozscreenshots
"
)
;
this
.
_libDir
.
append
(
"
lib
"
)
;
let
sets
=
this
.
loadSets
(
setNames
)
;
log
.
info
(
sets
.
length
+
"
sets
:
"
setNames
)
;
this
.
combos
=
new
LazyProduct
(
sets
)
;
log
.
info
(
this
.
combos
.
length
+
"
combinations
"
)
;
this
.
currentComboIndex
=
this
.
completedCombos
=
0
;
this
.
_lastCombo
=
null
;
Services
.
prefs
.
setCharPref
(
"
browser
.
aboutHomeSnippets
.
updateUrl
"
"
data
:
text
/
html
;
charset
=
utf
-
8
Generated
by
mozscreenshots
"
)
;
Services
.
prefs
.
setCharPref
(
"
extensions
.
ui
.
lastCategory
"
"
addons
:
/
/
list
/
extension
"
)
;
Services
.
prefs
.
setIntPref
(
"
ui
.
caretBlinkTime
"
-
1
)
;
Services
.
prefs
.
setBoolPref
(
"
toolkit
.
cosmeticAnimations
.
enabled
"
false
)
;
let
browserWindow
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
browserWindow
.
document
.
getElementById
(
"
main
-
window
"
)
.
removeAttribute
(
"
remotecontrol
"
)
;
let
selectedBrowser
=
browserWindow
.
gBrowser
.
selectedBrowser
;
await
BrowserTestUtils
.
loadURI
(
selectedBrowser
HOME_PAGE
)
;
await
BrowserTestUtils
.
browserLoaded
(
selectedBrowser
)
;
for
(
let
i
=
0
;
i
<
this
.
combos
.
length
;
i
+
+
)
{
this
.
currentComboIndex
=
i
;
await
this
.
_performCombo
(
this
.
combos
.
item
(
this
.
currentComboIndex
)
)
;
}
log
.
info
(
"
Done
:
Completed
"
+
this
.
completedCombos
+
"
out
of
"
+
this
.
combos
.
length
+
"
configurations
.
"
)
;
this
.
cleanup
(
)
;
}
filterRestrictions
(
setName
)
{
let
match
=
/
\
[
(
[
^
\
]
]
+
)
\
]
/
.
exec
(
setName
)
;
if
(
!
match
)
{
throw
new
Error
(
Invalid
restrictions
in
{
setName
}
)
;
}
setName
=
setName
.
slice
(
0
match
.
index
)
;
let
restrictions
=
match
[
1
]
.
split
(
"
"
)
.
reduce
(
(
set
name
)
=
>
set
.
add
(
name
.
trim
(
)
)
new
Set
(
)
)
;
return
{
trimmedSetName
:
setName
restrictions
}
;
}
loadSets
(
setNames
)
{
let
sets
=
[
]
;
for
(
let
setName
of
setNames
)
{
let
restrictions
=
null
;
if
(
setName
.
includes
(
"
[
"
)
)
{
let
filteredData
=
this
.
filterRestrictions
(
setName
)
;
setName
=
filteredData
.
trimmedSetName
;
restrictions
=
filteredData
.
restrictions
;
}
try
{
let
imported
=
{
}
;
Cu
.
import
(
"
chrome
:
/
/
mozscreenshots
/
content
/
configurations
/
"
+
setName
+
"
.
jsm
"
imported
)
;
imported
[
setName
]
.
init
(
this
.
_libDir
)
;
let
configurationNames
=
Object
.
keys
(
imported
[
setName
]
.
configurations
)
;
if
(
!
configurationNames
.
length
)
{
throw
new
Error
(
setName
+
"
has
no
configurations
for
this
environment
"
)
;
}
if
(
restrictions
)
{
let
incorrectConfigs
=
[
.
.
.
restrictions
]
.
filter
(
r
=
>
!
configurationNames
.
includes
(
r
)
)
;
if
(
incorrectConfigs
.
length
)
{
throw
new
Error
(
"
non
existent
configurations
:
"
+
incorrectConfigs
)
;
}
}
let
configurations
=
{
}
;
for
(
let
config
of
configurationNames
)
{
imported
[
setName
]
.
configurations
[
config
]
.
name
=
config
;
if
(
!
restrictions
|
|
restrictions
.
has
(
config
)
)
{
configurations
[
config
]
=
imported
[
setName
]
.
configurations
[
config
]
;
}
}
sets
.
push
(
configurations
)
;
}
catch
(
ex
)
{
log
.
error
(
"
Error
loading
set
:
"
+
setName
)
;
log
.
error
(
ex
)
;
throw
ex
;
}
}
return
sets
;
}
cleanup
(
)
{
let
browserWindow
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
let
gBrowser
=
browserWindow
.
gBrowser
;
while
(
gBrowser
.
tabs
.
length
>
1
)
{
gBrowser
.
removeTab
(
gBrowser
.
selectedTab
{
animate
:
false
}
)
;
}
gBrowser
.
unpinTab
(
gBrowser
.
selectedTab
)
;
gBrowser
.
selectedBrowser
.
loadURI
(
"
data
:
text
/
html
;
charset
=
utf
-
8
<
h1
>
Done
!
"
)
;
browserWindow
.
restore
(
)
;
Services
.
prefs
.
clearUserPref
(
"
toolkit
.
cosmeticAnimations
.
enabled
"
)
;
}
_findBoundingBox
(
selectors
windowType
)
{
if
(
!
selectors
.
length
)
{
log
.
info
(
"
_findBoundingBox
:
selectors
argument
is
empty
"
)
;
return
null
;
}
windowType
=
windowType
|
|
"
navigator
:
browser
"
;
let
browserWindow
=
Services
.
wm
.
getMostRecentWindow
(
windowType
)
;
const
scale
=
browserWindow
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDocShell
)
.
QueryInterface
(
Ci
.
nsIBaseWindow
)
.
devicePixelsPerDesktopPixel
;
let
finalRect
=
undefined
;
for
(
let
selector
of
selectors
)
{
let
element
;
if
(
typeof
(
selector
)
=
=
"
function
"
)
{
element
=
selector
(
)
;
}
else
{
element
=
browserWindow
.
document
.
querySelector
(
selector
)
;
}
if
(
!
element
)
{
log
.
info
(
"
_findBoundingBox
:
selector
not
found
"
)
;
return
null
;
}
let
box
=
element
.
ownerDocument
.
getBoxObjectFor
(
element
)
;
let
newRect
=
new
Rect
(
box
.
screenX
*
scale
box
.
screenY
*
scale
box
.
width
*
scale
box
.
height
*
scale
)
;
if
(
!
finalRect
)
{
finalRect
=
newRect
;
}
else
{
finalRect
=
finalRect
.
union
(
newRect
)
;
}
}
finalRect
=
finalRect
.
inflateFixed
(
this
.
croppingPadding
*
scale
)
;
let
windowLeft
=
browserWindow
.
screenX
*
scale
;
let
windowTop
=
browserWindow
.
screenY
*
scale
;
let
windowWidth
=
browserWindow
.
outerWidth
*
scale
;
let
windowHeight
=
browserWindow
.
outerHeight
*
scale
;
finalRect
.
left
=
Math
.
max
(
finalRect
.
left
windowLeft
)
;
finalRect
.
top
=
Math
.
max
(
finalRect
.
top
windowTop
)
;
finalRect
.
right
=
Math
.
min
(
finalRect
.
right
windowLeft
+
windowWidth
)
;
finalRect
.
bottom
=
Math
.
min
(
finalRect
.
bottom
windowTop
+
windowHeight
)
;
return
finalRect
;
}
async
_performCombo
(
combo
)
{
let
paddedComboIndex
=
padLeft
(
this
.
currentComboIndex
+
1
String
(
this
.
combos
.
length
)
.
length
)
;
log
.
info
(
"
Combination
"
+
paddedComboIndex
+
"
/
"
+
this
.
combos
.
length
+
"
:
"
+
this
.
_comboName
(
combo
)
.
substring
(
1
)
)
;
function
changeConfig
(
config
)
{
log
.
debug
(
"
calling
"
+
config
.
name
)
;
let
applyPromise
=
Promise
.
resolve
(
config
.
applyConfig
(
)
)
;
let
timeoutPromise
=
new
Promise
(
(
resolve
reject
)
=
>
{
setTimeout
(
reject
APPLY_CONFIG_TIMEOUT_MS
"
Timed
out
"
)
;
}
)
;
log
.
debug
(
"
called
"
+
config
.
name
)
;
return
Promise
.
race
(
[
applyPromise
timeoutPromise
]
)
.
then
(
(
)
=
>
{
return
new
Promise
(
(
resolve
)
=
>
{
setTimeout
(
resolve
500
)
;
}
)
;
}
)
;
}
try
{
for
(
let
i
=
0
;
i
<
combo
.
length
;
i
+
+
)
{
let
config
=
combo
[
i
]
;
if
(
!
this
.
_lastCombo
|
|
config
!
=
=
this
.
_lastCombo
[
i
]
)
{
log
.
debug
(
"
promising
"
config
.
name
)
;
await
changeConfig
(
config
)
;
}
}
log
.
debug
(
"
fulfilled
all
applyConfig
so
setting
lastCombo
.
"
)
;
this
.
_lastCombo
=
combo
;
for
(
let
i
=
0
;
i
<
combo
.
length
;
i
+
+
)
{
let
config
=
combo
[
i
]
;
if
(
config
.
verifyConfig
)
{
log
.
debug
(
"
checking
if
the
combo
is
valid
with
"
config
.
name
)
;
await
config
.
verifyConfig
(
)
;
}
}
}
catch
(
ex
)
{
log
.
warn
(
"
\
tskipped
configuration
:
"
+
ex
)
;
return
;
}
let
windowType
;
const
finalSelectors
=
[
]
;
for
(
const
obj
of
combo
)
{
if
(
!
windowType
)
{
windowType
=
obj
.
windowType
;
}
else
if
(
windowType
!
=
=
obj
.
windowType
)
{
log
.
warn
(
"
\
tConfigurations
with
multiple
window
types
are
not
allowed
"
)
;
return
;
}
for
(
const
selector
of
obj
.
selectors
)
{
finalSelectors
.
push
(
selector
)
;
}
}
const
rect
=
this
.
_findBoundingBox
(
finalSelectors
windowType
)
;
await
this
.
_onConfigurationReady
(
combo
rect
)
;
}
async
_onConfigurationReady
(
combo
rect
)
{
let
filename
=
padLeft
(
this
.
currentComboIndex
+
1
String
(
this
.
combos
.
length
)
.
length
)
+
this
.
_comboName
(
combo
)
;
const
imagePath
=
await
Screenshot
.
captureExternal
(
filename
)
;
let
browserWindow
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
await
this
.
_cropImage
(
browserWindow
OS
.
Path
.
toFileURI
(
imagePath
)
rect
imagePath
)
;
this
.
completedCombos
+
+
;
log
.
debug
(
"
_onConfigurationReady
"
)
;
}
_comboName
(
combo
)
{
return
combo
.
reduce
(
function
(
a
b
)
{
return
a
+
"
_
"
+
b
.
name
;
}
"
"
)
;
}
async
_cropImage
(
window
srcPath
rect
targetPath
)
{
const
{
document
Image
}
=
window
;
const
promise
=
new
Promise
(
(
resolve
reject
)
=
>
{
const
img
=
new
Image
(
)
;
img
.
onload
=
function
(
)
{
if
(
rect
.
x
<
0
|
|
rect
.
y
<
0
|
|
rect
.
width
<
0
|
|
rect
.
height
<
0
|
|
img
.
naturalWidth
<
rect
.
x
+
rect
.
width
|
|
img
.
naturalHeight
<
rect
.
y
+
rect
.
height
)
{
reject
(
"
Invalid
cropping
region
"
)
;
return
;
}
const
canvas
=
document
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
"
canvas
"
)
;
canvas
.
width
=
rect
.
width
;
canvas
.
height
=
rect
.
height
;
const
ctx
=
canvas
.
getContext
(
"
2d
"
)
;
ctx
.
drawImage
(
img
-
rect
.
x
-
rect
.
y
)
;
canvas
.
toBlob
(
(
blob
)
=
>
{
const
fr
=
new
FileReader
(
)
;
fr
.
onload
=
function
(
e
)
{
const
buffer
=
new
Uint8Array
(
e
.
target
.
result
)
;
OS
.
File
.
writeAtomic
(
targetPath
buffer
{
}
)
.
then
(
resolve
)
;
}
;
fr
.
readAsArrayBuffer
(
blob
)
;
}
)
;
}
;
img
.
onerror
=
function
(
)
{
reject
(
error
loading
image
{
srcPath
}
)
;
}
;
img
.
src
=
srcPath
;
}
)
;
return
promise
;
}
findComma
(
envVar
)
{
let
nestingDepth
=
0
;
for
(
let
i
=
0
;
i
<
envVar
.
length
;
i
+
+
)
{
if
(
envVar
[
i
]
=
=
=
"
[
"
)
{
nestingDepth
+
=
1
;
}
else
if
(
envVar
[
i
]
=
=
=
"
]
"
)
{
nestingDepth
-
=
1
;
}
else
if
(
envVar
[
i
]
=
=
=
"
"
&
&
nestingDepth
=
=
=
0
)
{
return
i
;
}
}
return
-
1
;
}
splitEnv
(
envVar
)
{
let
result
=
[
]
;
let
commaIndex
=
this
.
findComma
(
envVar
)
;
while
(
commaIndex
!
=
-
1
)
{
result
.
push
(
envVar
.
slice
(
0
commaIndex
)
.
trim
(
)
)
;
envVar
=
envVar
.
slice
(
commaIndex
+
1
)
;
commaIndex
=
this
.
findComma
(
envVar
)
;
}
result
.
push
(
envVar
.
trim
(
)
)
;
return
result
;
}
}
;
function
LazyProduct
(
sets
)
{
this
.
sets
=
sets
;
this
.
lookupTable
=
[
]
;
let
combinations
=
1
;
for
(
let
i
=
this
.
sets
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
let
set
=
this
.
sets
[
i
]
;
let
setLength
=
Object
.
keys
(
set
)
.
length
;
this
.
lookupTable
[
i
]
=
[
combinations
setLength
]
;
combinations
*
=
setLength
;
}
}
LazyProduct
.
prototype
=
{
get
length
(
)
{
let
last
=
this
.
lookupTable
[
0
]
;
if
(
!
last
)
return
0
;
return
last
[
0
]
*
last
[
1
]
;
}
item
(
n
)
{
let
result
=
[
]
;
for
(
let
i
=
this
.
sets
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
let
priorCombinations
=
this
.
lookupTable
[
i
]
[
0
]
;
let
setLength
=
this
.
lookupTable
[
i
]
[
1
]
;
let
keyIndex
=
Math
.
floor
(
n
/
priorCombinations
)
%
setLength
;
let
keys
=
Object
.
keys
(
this
.
sets
[
i
]
)
;
result
[
i
]
=
this
.
sets
[
i
]
[
keys
[
keyIndex
]
]
;
}
return
result
;
}
}
;
function
padLeft
(
number
width
padding
=
"
0
"
)
{
return
padding
.
repeat
(
Math
.
max
(
0
width
-
String
(
number
)
.
length
)
)
+
number
;
}
