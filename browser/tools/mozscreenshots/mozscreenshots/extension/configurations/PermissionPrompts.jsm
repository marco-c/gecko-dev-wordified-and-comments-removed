"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
PermissionPrompts
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
E10SUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
E10SUtils
.
jsm
"
)
;
const
{
ContentTask
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
ContentTask
.
jsm
"
)
;
const
{
BrowserTestUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
BrowserTestUtils
.
jsm
"
)
;
const
URL
=
"
https
:
/
/
test1
.
example
.
com
/
browser
/
browser
/
tools
/
mozscreenshots
/
mozscreenshots
/
extension
/
mozscreenshots
/
browser
/
resources
/
lib
/
permissionPrompts
.
html
"
;
let
lastTab
=
null
;
var
PermissionPrompts
=
{
init
(
libDir
)
{
Services
.
prefs
.
setBoolPref
(
"
media
.
navigator
.
permission
.
fake
"
true
)
;
Services
.
prefs
.
setBoolPref
(
"
extensions
.
install
.
requireBuiltInCerts
"
false
)
;
Services
.
prefs
.
setBoolPref
(
"
signon
.
rememberSignons
"
true
)
;
}
configurations
:
{
shareDevices
:
{
selectors
:
[
"
#
notification
-
popup
"
"
#
identity
-
box
"
]
async
applyConfig
(
)
{
await
closeLastTab
(
)
;
await
clickOn
(
"
#
webRTC
-
shareDevices
"
)
;
}
}
shareMicrophone
:
{
selectors
:
[
"
#
notification
-
popup
"
"
#
identity
-
box
"
]
async
applyConfig
(
)
{
await
closeLastTab
(
)
;
await
clickOn
(
"
#
webRTC
-
shareMicrophone
"
)
;
}
}
shareVideoAndMicrophone
:
{
selectors
:
[
"
#
notification
-
popup
"
"
#
identity
-
box
"
]
async
applyConfig
(
)
{
await
closeLastTab
(
)
;
await
clickOn
(
"
#
webRTC
-
shareDevices2
"
)
;
}
}
shareScreen
:
{
selectors
:
[
"
#
notification
-
popup
"
"
#
identity
-
box
"
]
async
applyConfig
(
)
{
await
closeLastTab
(
)
;
await
clickOn
(
"
#
webRTC
-
shareScreen
"
)
;
}
}
geo
:
{
selectors
:
[
"
#
notification
-
popup
"
"
#
identity
-
box
"
]
async
applyConfig
(
)
{
await
closeLastTab
(
)
;
await
clickOn
(
"
#
geo
"
)
;
}
}
persistentStorage
:
{
selectors
:
[
"
#
notification
-
popup
"
"
#
identity
-
box
"
]
async
applyConfig
(
)
{
await
closeLastTab
(
)
;
await
clickOn
(
"
#
persistent
-
storage
"
)
;
}
}
loginCapture
:
{
selectors
:
[
"
#
notification
-
popup
"
"
#
identity
-
box
"
]
async
applyConfig
(
)
{
await
closeLastTab
(
)
;
await
clickOn
(
"
#
login
-
capture
"
)
;
}
}
notifications
:
{
selectors
:
[
"
#
notification
-
popup
"
"
#
identity
-
box
"
]
async
applyConfig
(
)
{
await
closeLastTab
(
)
;
await
clickOn
(
"
#
web
-
notifications
"
)
;
}
}
addons
:
{
selectors
:
[
"
#
notification
-
popup
"
"
#
identity
-
box
"
]
async
applyConfig
(
)
{
Services
.
prefs
.
setBoolPref
(
"
xpinstall
.
whitelist
.
required
"
true
)
;
await
closeLastTab
(
)
;
await
clickOn
(
"
#
addons
"
)
;
}
}
addonsNoWhitelist
:
{
selectors
:
[
"
#
notification
-
popup
"
"
#
identity
-
box
"
]
async
applyConfig
(
)
{
Services
.
prefs
.
setBoolPref
(
"
xpinstall
.
whitelist
.
required
"
false
)
;
let
browserWindow
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
let
notification
=
browserWindow
.
document
.
getElementById
(
"
addon
-
install
-
confirmation
-
notification
"
)
;
await
closeLastTab
(
)
;
await
clickOn
(
"
#
addons
"
)
;
return
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
!
notification
.
hasAttribute
(
"
hidden
"
)
"
addon
install
confirmation
did
not
show
"
200
)
.
catch
(
(
msg
)
=
>
{
return
Promise
.
resolve
(
{
todo
:
msg
}
)
;
}
)
;
}
}
}
}
;
async
function
closeLastTab
(
)
{
if
(
!
lastTab
)
{
return
;
}
BrowserTestUtils
.
removeTab
(
lastTab
)
;
lastTab
=
null
;
}
async
function
clickOn
(
selector
)
{
let
browserWindow
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
lastTab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
browserWindow
.
gBrowser
URL
)
;
await
ContentTask
.
spawn
(
lastTab
.
linkedBrowser
selector
async
function
(
arg
)
{
E10SUtils
.
wrapHandlingUserInput
(
content
true
function
(
)
{
let
element
=
content
.
document
.
querySelector
(
arg
)
;
element
.
click
(
)
;
}
)
;
}
)
;
await
BrowserTestUtils
.
waitForEvent
(
browserWindow
.
PopupNotifications
.
panel
"
popupshown
"
)
;
}
