"
use
strict
"
;
const
paymentSrv
=
Cc
[
"
mozilla
.
org
/
dom
/
payments
/
payment
-
request
-
service
;
1
"
]
.
getService
(
Ci
.
nsIPaymentRequestService
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
MasterPassword
"
"
resource
:
/
/
formautofill
/
MasterPassword
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PrivateBrowsingUtils
"
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
formAutofillStorage
"
(
)
=
>
{
let
storage
;
try
{
storage
=
ChromeUtils
.
import
(
"
resource
:
/
/
formautofill
/
FormAutofillStorage
.
jsm
"
{
}
)
.
formAutofillStorage
;
storage
.
initialize
(
)
;
}
catch
(
ex
)
{
storage
=
null
;
Cu
.
reportError
(
ex
)
;
}
return
storage
;
}
)
;
class
TempCollection
{
constructor
(
type
data
=
{
}
)
{
this
.
_type
=
type
;
this
.
_data
=
data
;
}
get
_formAutofillCollection
(
)
{
Object
.
defineProperty
(
this
"
_formAutofillCollection
"
{
value
:
formAutofillStorage
[
this
.
_type
]
writable
:
false
configurable
:
true
}
)
;
return
this
.
_formAutofillCollection
;
}
get
(
guid
)
{
return
this
.
_data
[
guid
]
;
}
async
update
(
guid
record
preserveOldProperties
)
{
let
recordToSave
=
Object
.
assign
(
preserveOldProperties
?
this
.
_data
[
guid
]
:
{
}
record
)
;
await
this
.
_formAutofillCollection
.
computeFields
(
recordToSave
)
;
return
(
this
.
_data
[
guid
]
=
recordToSave
)
;
}
async
add
(
record
)
{
let
guid
=
"
temp
-
"
+
Math
.
abs
(
Math
.
random
(
)
*
0xffffffff
|
0
)
;
let
recordToSave
=
Object
.
assign
(
{
guid
}
record
)
;
await
this
.
_formAutofillCollection
.
computeFields
(
recordToSave
)
;
this
.
_data
[
guid
]
=
recordToSave
;
return
guid
;
}
getAll
(
)
{
return
this
.
_data
;
}
}
var
paymentDialogWrapper
=
{
componentsLoaded
:
new
Map
(
)
frame
:
null
mm
:
null
request
:
null
temporaryStore
:
null
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIObserver
Ci
.
nsISupportsWeakReference
]
)
async
_convertProfileAddressToPayerData
(
guid
)
{
let
addressData
=
this
.
temporaryStore
.
addresses
.
get
(
guid
)
|
|
await
formAutofillStorage
.
addresses
.
get
(
guid
)
;
if
(
!
addressData
)
{
throw
new
Error
(
Payer
address
not
found
:
{
guid
}
)
;
}
let
{
requestPayerName
requestPayerEmail
requestPayerPhone
}
=
this
.
request
.
paymentOptions
;
let
payerData
=
{
payerName
:
requestPayerName
?
addressData
.
name
:
"
"
payerEmail
:
requestPayerEmail
?
addressData
.
email
:
"
"
payerPhone
:
requestPayerPhone
?
addressData
.
tel
:
"
"
}
;
return
payerData
;
}
async
_convertProfileAddressToPaymentAddress
(
guid
)
{
let
addressData
=
this
.
temporaryStore
.
addresses
.
get
(
guid
)
|
|
await
formAutofillStorage
.
addresses
.
get
(
guid
)
;
if
(
!
addressData
)
{
throw
new
Error
(
Shipping
address
not
found
:
{
guid
}
)
;
}
let
address
=
this
.
createPaymentAddress
(
{
country
:
addressData
.
country
addressLines
:
addressData
[
"
street
-
address
"
]
.
split
(
"
\
n
"
)
region
:
addressData
[
"
address
-
level1
"
]
city
:
addressData
[
"
address
-
level2
"
]
dependentLocality
:
addressData
[
"
address
-
level3
"
]
postalCode
:
addressData
[
"
postal
-
code
"
]
organization
:
addressData
.
organization
recipient
:
addressData
.
name
phone
:
addressData
.
tel
}
)
;
return
address
;
}
async
_convertProfileBasicCardToPaymentMethodData
(
guid
cardSecurityCode
)
{
let
cardData
=
this
.
temporaryStore
.
creditCards
.
get
(
guid
)
|
|
await
formAutofillStorage
.
creditCards
.
get
(
guid
)
;
if
(
!
cardData
)
{
throw
new
Error
(
Basic
card
not
found
in
storage
:
{
guid
}
)
;
}
let
cardNumber
;
try
{
cardNumber
=
await
MasterPassword
.
decrypt
(
cardData
[
"
cc
-
number
-
encrypted
"
]
true
)
;
}
catch
(
ex
)
{
if
(
ex
.
result
!
=
Cr
.
NS_ERROR_ABORT
)
{
throw
ex
;
}
return
null
;
}
let
billingAddressGUID
=
cardData
.
billingAddressGUID
;
let
billingAddress
;
try
{
billingAddress
=
await
this
.
_convertProfileAddressToPaymentAddress
(
billingAddressGUID
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
let
methodData
=
this
.
createBasicCardResponseData
(
{
cardholderName
:
cardData
[
"
cc
-
name
"
]
cardNumber
expiryMonth
:
cardData
[
"
cc
-
exp
-
month
"
]
.
toString
(
)
.
padStart
(
2
"
0
"
)
expiryYear
:
cardData
[
"
cc
-
exp
-
year
"
]
.
toString
(
)
cardSecurityCode
billingAddress
}
)
;
return
methodData
;
}
init
(
requestId
frame
)
{
if
(
!
requestId
|
|
typeof
(
requestId
)
!
=
"
string
"
)
{
throw
new
Error
(
"
Invalid
PaymentRequest
ID
"
)
;
}
window
.
addEventListener
(
"
unload
"
this
)
;
this
.
request
=
paymentSrv
.
getPaymentRequestById
(
requestId
)
;
if
(
!
this
.
request
)
{
throw
new
Error
(
PaymentRequest
not
found
:
{
requestId
}
)
;
}
this
.
frame
=
frame
;
this
.
mm
=
frame
.
frameLoader
.
messageManager
;
this
.
mm
.
addMessageListener
(
"
paymentContentToChrome
"
this
)
;
this
.
mm
.
loadFrameScript
(
"
chrome
:
/
/
payments
/
content
/
paymentDialogFrameScript
.
js
"
true
)
;
this
.
mm
.
loadFrameScript
(
"
chrome
:
/
/
formautofill
/
content
/
l10n
.
js
"
true
)
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
this
.
frame
.
setAttribute
(
"
selectmenulist
"
"
ContentSelectDropdown
-
windows
"
)
;
}
this
.
frame
.
loadURI
(
"
resource
:
/
/
payments
/
paymentRequest
.
xhtml
"
)
;
this
.
temporaryStore
=
{
addresses
:
new
TempCollection
(
"
addresses
"
)
creditCards
:
new
TempCollection
(
"
creditCards
"
)
}
;
}
createShowResponse
(
{
acceptStatus
methodName
=
"
"
methodData
=
null
payerName
=
"
"
payerEmail
=
"
"
payerPhone
=
"
"
}
)
{
let
showResponse
=
this
.
createComponentInstance
(
Ci
.
nsIPaymentShowActionResponse
)
;
showResponse
.
init
(
this
.
request
.
requestId
acceptStatus
methodName
methodData
payerName
payerEmail
payerPhone
)
;
return
showResponse
;
}
createBasicCardResponseData
(
{
cardholderName
=
"
"
cardNumber
expiryMonth
=
"
"
expiryYear
=
"
"
cardSecurityCode
=
"
"
billingAddress
=
null
}
)
{
const
basicCardResponseData
=
Cc
[
"
mozilla
.
org
/
dom
/
payments
/
basiccard
-
response
-
data
;
1
"
]
.
createInstance
(
Ci
.
nsIBasicCardResponseData
)
;
basicCardResponseData
.
initData
(
cardholderName
cardNumber
expiryMonth
expiryYear
cardSecurityCode
billingAddress
)
;
return
basicCardResponseData
;
}
createPaymentAddress
(
{
country
=
"
"
addressLines
=
[
]
region
=
"
"
city
=
"
"
dependentLocality
=
"
"
postalCode
=
"
"
sortingCode
=
"
"
organization
=
"
"
recipient
=
"
"
phone
=
"
"
}
)
{
const
paymentAddress
=
Cc
[
"
mozilla
.
org
/
dom
/
payments
/
payment
-
address
;
1
"
]
.
createInstance
(
Ci
.
nsIPaymentAddress
)
;
const
addressLine
=
Cc
[
"
mozilla
.
org
/
array
;
1
"
]
.
createInstance
(
Ci
.
nsIMutableArray
)
;
for
(
let
line
of
addressLines
)
{
const
address
=
Cc
[
"
mozilla
.
org
/
supports
-
string
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsString
)
;
address
.
data
=
line
;
addressLine
.
appendElement
(
address
)
;
}
paymentAddress
.
init
(
country
addressLine
region
city
dependentLocality
postalCode
sortingCode
organization
recipient
phone
)
;
return
paymentAddress
;
}
createComponentInstance
(
componentInterface
)
{
let
componentName
;
switch
(
componentInterface
)
{
case
Ci
.
nsIPaymentShowActionResponse
:
{
componentName
=
"
mozilla
.
org
/
dom
/
payments
/
payment
-
show
-
action
-
response
;
1
"
;
break
;
}
case
Ci
.
nsIGeneralResponseData
:
{
componentName
=
"
mozilla
.
org
/
dom
/
payments
/
general
-
response
-
data
;
1
"
;
break
;
}
}
let
component
=
this
.
componentsLoaded
.
get
(
componentName
)
;
if
(
!
component
)
{
component
=
Cc
[
componentName
]
;
this
.
componentsLoaded
.
set
(
componentName
component
)
;
}
return
component
.
createInstance
(
componentInterface
)
;
}
async
fetchSavedAddresses
(
)
{
let
savedAddresses
=
{
}
;
for
(
let
address
of
await
formAutofillStorage
.
addresses
.
getAll
(
)
)
{
savedAddresses
[
address
.
guid
]
=
address
;
}
return
savedAddresses
;
}
async
fetchSavedPaymentCards
(
)
{
let
savedBasicCards
=
{
}
;
for
(
let
card
of
await
formAutofillStorage
.
creditCards
.
getAll
(
)
)
{
savedBasicCards
[
card
.
guid
]
=
card
;
delete
card
[
"
cc
-
number
-
encrypted
"
]
;
if
(
!
card
.
methodName
)
{
card
.
methodName
=
"
basic
-
card
"
;
}
}
return
savedBasicCards
;
}
async
onAutofillStorageChange
(
)
{
let
[
savedAddresses
savedBasicCards
]
=
await
Promise
.
all
(
[
this
.
fetchSavedAddresses
(
)
this
.
fetchSavedPaymentCards
(
)
]
)
;
this
.
sendMessageToContent
(
"
updateState
"
{
savedAddresses
savedBasicCards
}
)
;
}
sendMessageToContent
(
messageType
data
=
{
}
)
{
this
.
mm
.
sendAsyncMessage
(
"
paymentChromeToContent
"
{
data
messageType
}
)
;
}
updateRequest
(
)
{
let
requestSerialized
=
this
.
_serializeRequest
(
this
.
request
)
;
this
.
sendMessageToContent
(
"
updateState
"
{
request
:
requestSerialized
}
)
;
}
_serializeRequest
(
value
name
=
null
)
{
let
type
=
typeof
value
;
if
(
value
=
=
=
null
|
|
type
=
=
"
string
"
|
|
type
=
=
"
number
"
|
|
type
=
=
"
boolean
"
)
{
return
value
;
}
if
(
name
=
=
"
topLevelPrincipal
"
)
{
let
displayHost
=
value
.
URI
.
displayHost
;
return
{
URI
:
{
displayHost
}
}
;
}
if
(
type
=
=
"
function
"
|
|
type
=
=
"
undefined
"
)
{
return
undefined
;
}
if
(
value
instanceof
Ci
.
nsIArray
)
{
let
iface
;
let
items
=
[
]
;
switch
(
name
)
{
case
"
displayItems
"
:
case
"
additionalDisplayItems
"
:
iface
=
Ci
.
nsIPaymentItem
;
break
;
case
"
shippingOptions
"
:
iface
=
Ci
.
nsIPaymentShippingOption
;
break
;
case
"
paymentMethods
"
:
iface
=
Ci
.
nsIPaymentMethodData
;
break
;
case
"
modifiers
"
:
iface
=
Ci
.
nsIPaymentDetailsModifier
;
break
;
}
if
(
!
iface
)
{
throw
new
Error
(
No
interface
associated
with
the
members
of
the
{
name
}
nsIArray
)
;
}
for
(
let
i
=
0
;
i
<
value
.
length
;
i
+
+
)
{
let
item
=
value
.
queryElementAt
(
i
iface
)
;
let
result
=
this
.
_serializeRequest
(
item
i
)
;
if
(
result
!
=
=
undefined
)
{
items
.
push
(
result
)
;
}
}
return
items
;
}
if
(
Array
.
isArray
(
value
)
)
{
let
items
=
value
.
map
(
item
=
>
this
.
_serializeRequest
(
item
)
)
.
filter
(
item
=
>
item
!
=
=
undefined
)
;
return
items
;
}
let
obj
=
{
}
;
for
(
let
[
key
item
]
of
Object
.
entries
(
value
)
)
{
let
result
=
this
.
_serializeRequest
(
item
key
)
;
if
(
result
!
=
=
undefined
)
{
obj
[
key
]
=
result
;
}
}
return
obj
;
}
async
initializeFrame
(
)
{
Services
.
obs
.
addObserver
(
this
"
formautofill
-
storage
-
changed
"
true
)
;
let
requestSerialized
=
this
.
_serializeRequest
(
this
.
request
)
;
let
chromeWindow
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
let
isPrivate
=
PrivateBrowsingUtils
.
isWindowPrivate
(
chromeWindow
)
;
let
[
savedAddresses
savedBasicCards
]
=
await
Promise
.
all
(
[
this
.
fetchSavedAddresses
(
)
this
.
fetchSavedPaymentCards
(
)
]
)
;
this
.
sendMessageToContent
(
"
showPaymentRequest
"
{
request
:
requestSerialized
savedAddresses
tempAddresses
:
this
.
temporaryStore
.
addresses
.
getAll
(
)
savedBasicCards
tempBasicCards
:
this
.
temporaryStore
.
creditCards
.
getAll
(
)
isPrivate
}
)
;
}
debugFrame
(
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
"
devtools
.
chrome
.
enabled
"
false
)
)
{
Cu
.
reportError
(
"
devtools
.
chrome
.
enabled
must
be
enabled
to
debug
the
frame
"
)
;
return
;
}
let
chromeWindow
=
Services
.
wm
.
getMostRecentWindow
(
null
)
;
let
{
gDevToolsBrowser
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
client
/
framework
/
gDevTools
.
jsm
"
{
}
)
;
gDevToolsBrowser
.
openContentProcessToolbox
(
{
selectedBrowser
:
chromeWindow
.
document
.
getElementById
(
"
paymentRequestFrame
"
)
.
frameLoader
}
)
;
}
onPaymentCancel
(
)
{
const
showResponse
=
this
.
createShowResponse
(
{
acceptStatus
:
Ci
.
nsIPaymentActionResponse
.
PAYMENT_REJECTED
}
)
;
paymentSrv
.
respondPayment
(
showResponse
)
;
window
.
close
(
)
;
}
async
onPay
(
{
selectedPayerAddressGUID
:
payerGUID
selectedPaymentCardGUID
:
paymentCardGUID
selectedPaymentCardSecurityCode
:
cardSecurityCode
}
)
{
let
methodData
=
await
this
.
_convertProfileBasicCardToPaymentMethodData
(
paymentCardGUID
cardSecurityCode
)
;
if
(
!
methodData
)
{
Cu
.
reportError
(
"
Bug
1429265
/
Bug
1429205
:
User
canceled
master
password
entry
"
)
;
return
;
}
let
{
payerName
payerEmail
payerPhone
}
=
await
this
.
_convertProfileAddressToPayerData
(
payerGUID
)
;
this
.
pay
(
{
methodName
:
"
basic
-
card
"
methodData
payerName
payerEmail
payerPhone
}
)
;
}
pay
(
{
payerName
payerEmail
payerPhone
methodName
methodData
}
)
{
const
showResponse
=
this
.
createShowResponse
(
{
acceptStatus
:
Ci
.
nsIPaymentActionResponse
.
PAYMENT_ACCEPTED
payerName
payerEmail
payerPhone
methodName
methodData
}
)
;
paymentSrv
.
respondPayment
(
showResponse
)
;
this
.
sendMessageToContent
(
"
responseSent
"
)
;
}
async
onChangeShippingAddress
(
{
shippingAddressGUID
}
)
{
if
(
shippingAddressGUID
)
{
let
address
=
await
this
.
_convertProfileAddressToPaymentAddress
(
shippingAddressGUID
)
;
paymentSrv
.
changeShippingAddress
(
this
.
request
.
requestId
address
)
;
}
}
onChangeShippingOption
(
{
optionID
}
)
{
paymentSrv
.
changeShippingOption
(
this
.
request
.
requestId
optionID
)
;
}
onCloseDialogMessage
(
)
{
window
.
close
(
)
;
}
async
onUpdateAutofillRecord
(
collectionName
record
guid
messageID
)
{
let
responseMessage
=
{
guid
messageID
stateChange
:
{
}
}
;
try
{
let
isTemporary
=
record
.
isTemporary
;
let
collection
=
isTemporary
?
this
.
temporaryStore
[
collectionName
]
:
formAutofillStorage
[
collectionName
]
;
if
(
guid
)
{
let
preserveOldProperties
=
true
;
await
collection
.
update
(
guid
record
preserveOldProperties
)
;
}
else
{
responseMessage
.
guid
=
await
collection
.
add
(
record
)
;
}
if
(
isTemporary
&
&
collectionName
=
=
"
addresses
"
)
{
Object
.
assign
(
responseMessage
.
stateChange
{
tempAddresses
:
this
.
temporaryStore
.
addresses
.
getAll
(
)
}
)
;
}
if
(
isTemporary
&
&
collectionName
=
=
"
creditCards
"
)
{
Object
.
assign
(
responseMessage
.
stateChange
{
tempBasicCards
:
this
.
temporaryStore
.
creditCards
.
getAll
(
)
}
)
;
}
}
catch
(
ex
)
{
responseMessage
.
error
=
true
;
}
finally
{
this
.
sendMessageToContent
(
"
updateAutofillRecord
:
Response
"
responseMessage
)
;
}
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
unload
"
:
{
Services
.
obs
.
removeObserver
(
this
"
formautofill
-
storage
-
changed
"
)
;
break
;
}
default
:
{
throw
new
Error
(
"
Unexpected
event
handled
"
)
;
}
}
}
observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
"
formautofill
-
storage
-
changed
"
:
{
if
(
data
=
=
"
notifyUsed
"
)
{
break
;
}
this
.
onAutofillStorageChange
(
)
;
break
;
}
}
}
receiveMessage
(
{
data
}
)
{
let
{
messageType
}
=
data
;
switch
(
messageType
)
{
case
"
debugFrame
"
:
{
this
.
debugFrame
(
)
;
break
;
}
case
"
initializeRequest
"
:
{
this
.
initializeFrame
(
)
;
break
;
}
case
"
changeShippingAddress
"
:
{
this
.
onChangeShippingAddress
(
data
)
;
break
;
}
case
"
changeShippingOption
"
:
{
this
.
onChangeShippingOption
(
data
)
;
break
;
}
case
"
closeDialog
"
:
{
this
.
onCloseDialogMessage
(
)
;
break
;
}
case
"
paymentCancel
"
:
{
this
.
onPaymentCancel
(
)
;
break
;
}
case
"
pay
"
:
{
this
.
onPay
(
data
)
;
break
;
}
case
"
updateAutofillRecord
"
:
{
this
.
onUpdateAutofillRecord
(
data
.
collectionName
data
.
record
data
.
guid
data
.
messageID
)
;
break
;
}
}
}
}
;
if
(
"
document
"
in
this
)
{
let
frame
=
document
.
getElementById
(
"
paymentRequestFrame
"
)
;
let
requestId
=
(
new
URLSearchParams
(
window
.
location
.
search
)
)
.
get
(
"
requestId
"
)
;
paymentDialogWrapper
.
init
(
requestId
frame
)
;
}
