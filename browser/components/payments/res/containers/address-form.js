import
LabelledCheckbox
from
"
.
.
/
components
/
labelled
-
checkbox
.
js
"
;
import
PaymentRequestPage
from
"
.
.
/
components
/
payment
-
request
-
page
.
js
"
;
import
PaymentStateSubscriberMixin
from
"
.
.
/
mixins
/
PaymentStateSubscriberMixin
.
js
"
;
import
paymentRequest
from
"
.
.
/
paymentRequest
.
js
"
;
import
HandleEventMixin
from
"
.
.
/
mixins
/
HandleEventMixin
.
js
"
;
export
default
class
AddressForm
extends
HandleEventMixin
(
PaymentStateSubscriberMixin
(
PaymentRequestPage
)
)
{
constructor
(
)
{
super
(
)
;
this
.
genericErrorText
=
document
.
createElement
(
"
div
"
)
;
this
.
genericErrorText
.
setAttribute
(
"
aria
-
live
"
"
polite
"
)
;
this
.
genericErrorText
.
classList
.
add
(
"
page
-
error
"
)
;
this
.
cancelButton
=
document
.
createElement
(
"
button
"
)
;
this
.
cancelButton
.
className
=
"
cancel
-
button
"
;
this
.
cancelButton
.
addEventListener
(
"
click
"
this
)
;
this
.
backButton
=
document
.
createElement
(
"
button
"
)
;
this
.
backButton
.
className
=
"
back
-
button
"
;
this
.
backButton
.
addEventListener
(
"
click
"
this
)
;
this
.
saveButton
=
document
.
createElement
(
"
button
"
)
;
this
.
saveButton
.
className
=
"
save
-
button
primary
"
;
this
.
saveButton
.
addEventListener
(
"
click
"
this
)
;
this
.
persistCheckbox
=
new
LabelledCheckbox
(
)
;
this
.
persistCheckbox
.
className
=
"
persist
-
checkbox
"
;
this
.
_errorFieldMap
=
{
addressLine
:
"
#
street
-
address
"
city
:
"
#
address
-
level2
"
country
:
"
#
country
"
dependentLocality
:
"
#
address
-
level3
"
email
:
"
#
email
"
name
:
"
#
family
-
name
"
organization
:
"
#
organization
"
phone
:
"
#
tel
"
postalCode
:
"
#
postal
-
code
"
recipient
:
"
#
given
-
name
"
region
:
"
#
address
-
level1
"
regionCode
:
"
#
address
-
level1
"
}
;
let
url
=
"
formautofill
/
editAddress
.
xhtml
"
;
this
.
promiseReady
=
this
.
_fetchMarkup
(
url
)
.
then
(
doc
=
>
{
this
.
form
=
doc
.
getElementById
(
"
form
"
)
;
return
this
.
form
;
}
)
;
}
_fetchMarkup
(
url
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
xhr
=
new
XMLHttpRequest
(
)
;
xhr
.
responseType
=
"
document
"
;
xhr
.
addEventListener
(
"
error
"
reject
)
;
xhr
.
addEventListener
(
"
load
"
evt
=
>
{
resolve
(
xhr
.
response
)
;
}
)
;
xhr
.
open
(
"
GET
"
url
)
;
xhr
.
send
(
)
;
}
)
;
}
connectedCallback
(
)
{
this
.
promiseReady
.
then
(
form
=
>
{
this
.
body
.
appendChild
(
form
)
;
let
record
=
undefined
;
this
.
formHandler
=
new
EditAddress
(
{
form
}
record
{
DEFAULT_REGION
:
PaymentDialogUtils
.
DEFAULT_REGION
getFormFormat
:
PaymentDialogUtils
.
getFormFormat
findAddressSelectOption
:
PaymentDialogUtils
.
findAddressSelectOption
countries
:
PaymentDialogUtils
.
countries
}
)
;
this
.
form
.
addEventListener
(
"
input
"
this
)
;
this
.
form
.
addEventListener
(
"
invalid
"
this
)
;
this
.
form
.
addEventListener
(
"
change
"
this
)
;
for
(
let
field
of
this
.
form
.
elements
)
{
field
.
addEventListener
(
"
invalid
"
this
)
;
}
this
.
body
.
appendChild
(
this
.
persistCheckbox
)
;
this
.
body
.
appendChild
(
this
.
genericErrorText
)
;
this
.
footer
.
appendChild
(
this
.
cancelButton
)
;
this
.
footer
.
appendChild
(
this
.
backButton
)
;
this
.
footer
.
appendChild
(
this
.
saveButton
)
;
super
.
connectedCallback
(
)
;
}
)
;
}
render
(
state
)
{
if
(
!
this
.
id
)
{
throw
new
Error
(
"
AddressForm
without
an
id
"
)
;
}
let
record
;
let
{
page
[
this
.
id
]
:
addressPage
}
=
state
;
if
(
this
.
id
&
&
page
&
&
page
.
id
!
=
=
this
.
id
)
{
log
.
debug
(
{
this
.
id
}
:
no
need
to
further
render
inactive
page
)
;
return
;
}
let
editing
=
!
!
addressPage
.
guid
;
this
.
cancelButton
.
textContent
=
this
.
dataset
.
cancelButtonLabel
;
this
.
backButton
.
textContent
=
this
.
dataset
.
backButtonLabel
;
if
(
editing
)
{
this
.
saveButton
.
textContent
=
this
.
dataset
.
updateButtonLabel
;
}
else
{
this
.
saveButton
.
textContent
=
this
.
dataset
.
nextButtonLabel
;
}
this
.
persistCheckbox
.
label
=
this
.
dataset
.
persistCheckboxLabel
;
this
.
persistCheckbox
.
infoTooltip
=
this
.
dataset
.
persistCheckboxInfoTooltip
;
this
.
backButton
.
hidden
=
page
.
onboardingWizard
;
this
.
cancelButton
.
hidden
=
!
page
.
onboardingWizard
;
this
.
pageTitleHeading
.
textContent
=
editing
?
this
.
dataset
.
titleEdit
:
this
.
dataset
.
titleAdd
;
this
.
genericErrorText
.
textContent
=
page
.
error
;
let
addresses
=
paymentRequest
.
getAddresses
(
state
)
;
if
(
editing
)
{
record
=
addresses
[
addressPage
.
guid
]
;
if
(
!
record
)
{
throw
new
Error
(
"
Trying
to
edit
a
non
-
existing
address
:
"
+
addressPage
.
guid
)
;
}
this
.
persistCheckbox
.
hidden
=
true
;
}
else
{
let
{
saveAddressDefaultChecked
}
=
PaymentDialogUtils
.
getDefaultPreferences
(
)
;
if
(
typeof
saveAddressDefaultChecked
!
=
"
boolean
"
)
{
throw
new
Error
(
Unexpected
non
-
boolean
value
for
saveAddressDefaultChecked
from
PaymentDialogUtils
.
getDefaultPreferences
(
)
:
{
typeof
saveAddressDefaultChecked
}
)
;
}
this
.
persistCheckbox
.
hidden
=
false
;
this
.
persistCheckbox
.
checked
=
state
.
isPrivate
?
false
:
saveAddressDefaultChecked
;
}
let
selectedStateKey
=
this
.
getAttribute
(
"
selected
-
state
-
key
"
)
.
split
(
"
|
"
)
;
log
.
debug
(
{
this
.
id
}
#
render
got
selectedStateKey
:
{
selectedStateKey
}
)
;
if
(
addressPage
.
addressFields
)
{
this
.
form
.
dataset
.
addressFields
=
addressPage
.
addressFields
;
}
else
{
this
.
form
.
dataset
.
addressFields
=
"
mailing
-
address
tel
"
;
}
this
.
formHandler
.
loadRecord
(
record
)
;
this
.
updateRequiredState
(
)
;
let
merchantFieldErrors
=
AddressForm
.
merchantFieldErrorsForForm
(
state
selectedStateKey
)
;
for
(
let
[
errorName
errorSelector
]
of
Object
.
entries
(
this
.
_errorFieldMap
)
)
{
let
errorText
=
"
"
;
if
(
editing
&
&
merchantFieldErrors
)
{
if
(
errorName
=
=
"
region
"
|
|
errorName
=
=
"
regionCode
"
)
{
errorText
=
merchantFieldErrors
.
regionCode
|
|
merchantFieldErrors
.
region
|
|
"
"
;
}
else
{
errorText
=
merchantFieldErrors
[
errorName
]
|
|
"
"
;
}
}
let
container
=
this
.
form
.
querySelector
(
errorSelector
+
"
-
container
"
)
;
let
field
=
this
.
form
.
querySelector
(
errorSelector
)
;
field
.
setCustomValidity
(
errorText
)
;
let
span
=
paymentRequest
.
maybeCreateFieldErrorElement
(
container
)
;
span
.
textContent
=
errorText
;
}
this
.
updateSaveButtonState
(
)
;
}
onChange
(
event
)
{
if
(
event
.
target
.
id
=
=
"
country
"
)
{
this
.
updateRequiredState
(
)
;
}
this
.
updateSaveButtonState
(
)
;
}
onInvalid
(
event
)
{
if
(
event
.
target
instanceof
HTMLFormElement
)
{
this
.
onInvalidForm
(
event
)
;
}
else
{
this
.
onInvalidField
(
event
)
;
}
}
onClick
(
evt
)
{
switch
(
evt
.
target
)
{
case
this
.
cancelButton
:
{
paymentRequest
.
cancel
(
)
;
break
;
}
case
this
.
backButton
:
{
let
currentState
=
this
.
requestStore
.
getState
(
)
;
const
previousId
=
currentState
.
page
.
previousId
;
let
state
=
{
page
:
{
id
:
previousId
|
|
"
payment
-
summary
"
}
}
;
if
(
previousId
)
{
state
[
previousId
]
=
Object
.
assign
(
{
}
currentState
[
previousId
]
{
preserveFieldValues
:
true
}
)
;
}
this
.
requestStore
.
setState
(
state
)
;
break
;
}
case
this
.
saveButton
:
{
if
(
this
.
form
.
checkValidity
(
)
)
{
this
.
saveRecord
(
)
;
}
break
;
}
default
:
{
throw
new
Error
(
"
Unexpected
click
target
"
)
;
}
}
}
onInput
(
event
)
{
event
.
target
.
setCustomValidity
(
"
"
)
;
this
.
updateSaveButtonState
(
)
;
}
onInvalidField
(
event
)
{
let
field
=
event
.
target
;
let
container
=
field
.
closest
(
#
{
field
.
id
}
-
container
)
;
let
errorTextSpan
=
paymentRequest
.
maybeCreateFieldErrorElement
(
container
)
;
errorTextSpan
.
textContent
=
field
.
validationMessage
;
}
onInvalidForm
(
)
{
this
.
saveButton
.
disabled
=
true
;
}
updateRequiredState
(
)
{
for
(
let
field
of
this
.
form
.
elements
)
{
let
container
=
field
.
closest
(
#
{
field
.
id
}
-
container
)
;
if
(
field
.
localName
=
=
"
button
"
|
|
!
container
)
{
continue
;
}
let
span
=
container
.
querySelector
(
"
.
label
-
text
"
)
;
span
.
setAttribute
(
"
fieldRequiredSymbol
"
this
.
dataset
.
fieldRequiredSymbol
)
;
container
.
toggleAttribute
(
"
required
"
field
.
required
&
&
!
field
.
disabled
)
;
}
}
updateSaveButtonState
(
)
{
this
.
saveButton
.
disabled
=
!
this
.
form
.
checkValidity
(
)
;
}
async
saveRecord
(
)
{
let
record
=
this
.
formHandler
.
buildFormObject
(
)
;
let
currentState
=
this
.
requestStore
.
getState
(
)
;
let
{
page
tempAddresses
savedBasicCards
[
this
.
id
]
:
addressPage
}
=
currentState
;
let
editing
=
!
!
addressPage
.
guid
;
if
(
editing
?
addressPage
.
guid
in
tempAddresses
:
!
this
.
persistCheckbox
.
checked
)
{
record
.
isTemporary
=
true
;
}
let
successStateChange
;
const
previousId
=
page
.
previousId
;
if
(
page
.
onboardingWizard
&
&
!
Object
.
keys
(
savedBasicCards
)
.
length
)
{
successStateChange
=
{
"
basic
-
card
-
page
"
:
{
selectedStateKey
:
"
selectedPaymentCard
"
preserveFieldValues
:
true
}
page
:
{
id
:
"
basic
-
card
-
page
"
previousId
:
this
.
id
onboardingWizard
:
page
.
onboardingWizard
}
}
;
}
else
{
successStateChange
=
{
page
:
{
id
:
previousId
|
|
"
payment
-
summary
"
onboardingWizard
:
page
.
onboardingWizard
}
}
;
}
if
(
previousId
)
{
successStateChange
[
previousId
]
=
Object
.
assign
(
{
}
currentState
[
previousId
]
)
;
successStateChange
[
previousId
]
.
preserveFieldValues
=
true
;
}
try
{
let
{
guid
}
=
await
paymentRequest
.
updateAutofillRecord
(
"
addresses
"
record
addressPage
.
guid
)
;
let
selectedStateKey
=
this
.
getAttribute
(
"
selected
-
state
-
key
"
)
.
split
(
"
|
"
)
;
if
(
selectedStateKey
.
length
=
=
1
)
{
Object
.
assign
(
successStateChange
{
[
selectedStateKey
[
0
]
]
:
guid
}
)
;
}
else
if
(
selectedStateKey
.
length
=
=
2
)
{
let
subObj
=
Object
.
assign
(
{
}
successStateChange
[
selectedStateKey
[
0
]
]
)
;
subObj
[
selectedStateKey
[
1
]
]
=
guid
;
Object
.
assign
(
successStateChange
{
[
selectedStateKey
[
0
]
]
:
subObj
}
)
;
}
else
{
throw
new
Error
(
selectedStateKey
not
supported
:
'
{
selectedStateKey
}
'
)
;
}
this
.
requestStore
.
setState
(
successStateChange
)
;
}
catch
(
ex
)
{
log
.
warn
(
"
saveRecord
:
error
:
"
ex
)
;
this
.
requestStore
.
setState
(
{
page
:
{
id
:
this
.
id
onboardingWizard
:
page
.
onboardingWizard
error
:
this
.
dataset
.
errorGenericSave
}
}
)
;
}
}
static
merchantFieldErrorsForForm
(
state
stateKey
)
{
let
{
paymentDetails
}
=
state
.
request
;
switch
(
stateKey
.
join
(
"
|
"
)
)
{
case
"
selectedShippingAddress
"
:
{
return
paymentDetails
.
shippingAddressErrors
;
}
case
"
selectedPayerAddress
"
:
{
return
paymentDetails
.
payerErrors
;
}
case
"
basic
-
card
-
page
|
billingAddressGUID
"
:
{
return
(
(
paymentDetails
.
paymentMethodErrors
&
&
paymentDetails
.
paymentMethodErrors
.
billingAddress
)
|
|
{
}
)
;
}
default
:
{
throw
new
Error
(
"
Unknown
selectedStateKey
"
)
;
}
}
}
}
customElements
.
define
(
"
address
-
form
"
AddressForm
)
;
