import
AcceptedCards
from
"
.
.
/
components
/
accepted
-
cards
.
js
"
;
import
BillingAddressPicker
from
"
.
/
billing
-
address
-
picker
.
js
"
;
import
CscInput
from
"
.
.
/
components
/
csc
-
input
.
js
"
;
import
LabelledCheckbox
from
"
.
.
/
components
/
labelled
-
checkbox
.
js
"
;
import
PaymentRequestPage
from
"
.
.
/
components
/
payment
-
request
-
page
.
js
"
;
import
PaymentStateSubscriberMixin
from
"
.
.
/
mixins
/
PaymentStateSubscriberMixin
.
js
"
;
import
paymentRequest
from
"
.
.
/
paymentRequest
.
js
"
;
import
HandleEventMixin
from
"
.
.
/
mixins
/
HandleEventMixin
.
js
"
;
export
default
class
BasicCardForm
extends
HandleEventMixin
(
PaymentStateSubscriberMixin
(
PaymentRequestPage
)
)
{
constructor
(
)
{
super
(
)
;
this
.
genericErrorText
=
document
.
createElement
(
"
div
"
)
;
this
.
genericErrorText
.
setAttribute
(
"
aria
-
live
"
"
polite
"
)
;
this
.
genericErrorText
.
classList
.
add
(
"
page
-
error
"
)
;
this
.
cscInput
=
new
CscInput
(
{
useAlwaysVisiblePlaceholder
:
true
inputId
:
"
cc
-
csc
"
}
)
;
this
.
persistCheckbox
=
new
LabelledCheckbox
(
)
;
this
.
persistCheckbox
.
form
=
"
"
;
this
.
persistCheckbox
.
className
=
"
persist
-
checkbox
"
;
this
.
acceptedCardsList
=
new
AcceptedCards
(
)
;
this
.
cancelButton
=
document
.
createElement
(
"
button
"
)
;
this
.
cancelButton
.
className
=
"
cancel
-
button
"
;
this
.
cancelButton
.
addEventListener
(
"
click
"
this
)
;
this
.
backButton
=
document
.
createElement
(
"
button
"
)
;
this
.
backButton
.
className
=
"
back
-
button
"
;
this
.
backButton
.
addEventListener
(
"
click
"
this
)
;
this
.
saveButton
=
document
.
createElement
(
"
button
"
)
;
this
.
saveButton
.
className
=
"
save
-
button
primary
"
;
this
.
saveButton
.
addEventListener
(
"
click
"
this
)
;
this
.
footer
.
append
(
this
.
cancelButton
this
.
backButton
this
.
saveButton
)
;
let
url
=
"
formautofill
/
editCreditCard
.
xhtml
"
;
this
.
promiseReady
=
this
.
_fetchMarkup
(
url
)
.
then
(
doc
=
>
{
this
.
form
=
doc
.
getElementById
(
"
form
"
)
;
return
this
.
form
;
}
)
;
}
_fetchMarkup
(
url
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
xhr
=
new
XMLHttpRequest
(
)
;
xhr
.
responseType
=
"
document
"
;
xhr
.
addEventListener
(
"
error
"
reject
)
;
xhr
.
addEventListener
(
"
load
"
evt
=
>
{
resolve
(
xhr
.
response
)
;
}
)
;
xhr
.
open
(
"
GET
"
url
)
;
xhr
.
send
(
)
;
}
)
;
}
_upgradeBillingAddressPicker
(
)
{
let
addressRow
=
this
.
form
.
querySelector
(
"
.
billingAddressRow
"
)
;
let
addressPicker
=
(
this
.
billingAddressPicker
=
new
BillingAddressPicker
(
)
)
;
if
(
addressPicker
.
dropdown
.
popupBox
)
{
addressPicker
.
dropdown
.
popupBox
.
remove
(
)
;
}
addressPicker
.
dropdown
.
popupBox
=
this
.
form
.
querySelector
(
"
#
billingAddressGUID
"
)
;
addressRow
.
querySelector
(
"
.
label
-
text
"
)
.
hidden
=
true
;
addressPicker
.
dataset
.
addLinkLabel
=
this
.
dataset
.
addressAddLinkLabel
;
addressPicker
.
dataset
.
editLinkLabel
=
this
.
dataset
.
addressEditLinkLabel
;
addressPicker
.
dataset
.
fieldSeparator
=
this
.
dataset
.
addressFieldSeparator
;
addressPicker
.
dataset
.
addAddressTitle
=
this
.
dataset
.
billingAddressTitleAdd
;
addressPicker
.
dataset
.
editAddressTitle
=
this
.
dataset
.
billingAddressTitleEdit
;
addressPicker
.
dataset
.
invalidLabel
=
this
.
dataset
.
invalidAddressLabel
;
addressPicker
.
setAttribute
(
"
selected
-
state
-
key
"
"
basic
-
card
-
page
|
billingAddressGUID
"
)
;
addressPicker
.
addLink
.
addEventListener
(
"
click
"
this
)
;
addressPicker
.
editLink
.
addEventListener
(
"
click
"
this
)
;
addressRow
.
appendChild
(
addressPicker
)
;
}
connectedCallback
(
)
{
this
.
promiseReady
.
then
(
form
=
>
{
this
.
body
.
appendChild
(
form
)
;
let
record
=
{
}
;
let
addresses
=
[
]
;
this
.
formHandler
=
new
EditCreditCard
(
{
form
}
record
addresses
{
isCCNumber
:
PaymentDialogUtils
.
isCCNumber
getAddressLabel
:
PaymentDialogUtils
.
getAddressLabel
getSupportedNetworks
:
PaymentDialogUtils
.
getCreditCardNetworks
}
)
;
form
.
addEventListener
(
"
change
"
this
)
;
form
.
addEventListener
(
"
input
"
this
)
;
form
.
addEventListener
(
"
invalid
"
this
)
;
this
.
_upgradeBillingAddressPicker
(
)
;
for
(
let
field
of
this
.
form
.
elements
)
{
field
.
addEventListener
(
"
invalid
"
this
)
;
}
let
cscContainer
=
this
.
form
.
querySelector
(
"
#
cc
-
csc
-
container
"
)
;
cscContainer
.
textContent
=
"
"
;
cscContainer
.
appendChild
(
this
.
cscInput
)
;
let
billingAddressRow
=
this
.
form
.
querySelector
(
"
.
billingAddressRow
"
)
;
form
.
insertBefore
(
this
.
persistCheckbox
billingAddressRow
)
;
form
.
insertBefore
(
this
.
acceptedCardsList
billingAddressRow
)
;
this
.
body
.
appendChild
(
this
.
genericErrorText
)
;
super
.
connectedCallback
(
)
;
}
)
;
}
render
(
state
)
{
let
{
page
selectedShippingAddress
"
basic
-
card
-
page
"
:
basicCardPage
}
=
state
;
if
(
this
.
id
&
&
page
&
&
page
.
id
!
=
=
this
.
id
)
{
log
.
debug
(
BasicCardForm
:
no
need
to
further
render
inactive
page
:
{
page
.
id
}
)
;
return
;
}
if
(
!
basicCardPage
.
selectedStateKey
)
{
throw
new
Error
(
"
A
selectedStateKey
is
required
"
)
;
}
let
editing
=
!
!
basicCardPage
.
guid
;
this
.
cancelButton
.
textContent
=
this
.
dataset
.
cancelButtonLabel
;
this
.
backButton
.
textContent
=
this
.
dataset
.
backButtonLabel
;
if
(
editing
)
{
this
.
saveButton
.
textContent
=
this
.
dataset
.
updateButtonLabel
;
}
else
{
this
.
saveButton
.
textContent
=
this
.
dataset
.
nextButtonLabel
;
}
this
.
cscInput
.
placeholder
=
this
.
dataset
.
cscPlaceholder
;
this
.
cscInput
.
frontTooltip
=
this
.
dataset
.
cscFrontInfoTooltip
;
this
.
cscInput
.
backTooltip
=
this
.
dataset
.
cscBackInfoTooltip
;
let
labelText
=
this
.
form
.
querySelector
(
"
.
billingAddressRow
.
label
-
text
"
)
.
textContent
;
this
.
billingAddressPicker
.
setAttribute
(
"
label
"
labelText
)
;
this
.
persistCheckbox
.
label
=
this
.
dataset
.
persistCheckboxLabel
;
this
.
persistCheckbox
.
infoTooltip
=
this
.
dataset
.
persistCheckboxInfoTooltip
;
this
.
acceptedCardsList
.
label
=
this
.
dataset
.
acceptedCardsLabel
;
this
.
backButton
.
hidden
=
!
page
.
previousId
&
&
page
.
onboardingWizard
;
this
.
cancelButton
.
hidden
=
!
page
.
onboardingWizard
;
let
record
=
{
}
;
let
basicCards
=
paymentRequest
.
getBasicCards
(
state
)
;
let
addresses
=
paymentRequest
.
getAddresses
(
state
)
;
this
.
genericErrorText
.
textContent
=
page
.
error
;
this
.
form
.
querySelector
(
"
#
cc
-
number
"
)
.
disabled
=
editing
;
this
.
form
.
querySelector
(
"
#
cc
-
csc
-
container
"
)
.
hidden
=
editing
;
this
.
cscInput
.
disabled
=
editing
;
if
(
editing
)
{
this
.
pageTitleHeading
.
textContent
=
this
.
dataset
.
editBasicCardTitle
;
record
=
basicCards
[
basicCardPage
.
guid
]
;
if
(
!
record
)
{
throw
new
Error
(
"
Trying
to
edit
a
non
-
existing
card
:
"
+
basicCardPage
.
guid
)
;
}
this
.
persistCheckbox
.
hidden
=
true
;
}
else
{
this
.
pageTitleHeading
.
textContent
=
this
.
dataset
.
addBasicCardTitle
;
record
.
billingAddressGUID
=
basicCardPage
.
billingAddressGUID
;
if
(
!
record
.
billingAddressGUID
&
&
selectedShippingAddress
)
{
record
.
billingAddressGUID
=
selectedShippingAddress
;
}
let
{
saveCreditCardDefaultChecked
}
=
PaymentDialogUtils
.
getDefaultPreferences
(
)
;
if
(
typeof
saveCreditCardDefaultChecked
!
=
"
boolean
"
)
{
throw
new
Error
(
Unexpected
non
-
boolean
value
for
saveCreditCardDefaultChecked
from
PaymentDialogUtils
.
getDefaultPreferences
(
)
:
{
typeof
saveCreditCardDefaultChecked
}
)
;
}
this
.
persistCheckbox
.
hidden
=
false
;
if
(
basicCardPage
.
hasOwnProperty
(
"
persistCheckboxValue
"
)
)
{
this
.
persistCheckbox
.
checked
=
basicCardPage
.
persistCheckboxValue
;
}
else
{
this
.
persistCheckbox
.
checked
=
state
.
isPrivate
?
false
:
saveCreditCardDefaultChecked
;
}
}
this
.
formHandler
.
loadRecord
(
record
addresses
basicCardPage
.
preserveFieldValues
)
;
this
.
form
.
querySelector
(
"
.
billingAddressRow
"
)
.
hidden
=
false
;
let
billingAddressSelect
=
this
.
billingAddressPicker
.
dropdown
;
if
(
basicCardPage
.
billingAddressGUID
)
{
billingAddressSelect
.
value
=
basicCardPage
.
billingAddressGUID
;
}
else
if
(
!
editing
)
{
if
(
paymentRequest
.
getAddresses
(
state
)
[
selectedShippingAddress
]
)
{
billingAddressSelect
.
value
=
selectedShippingAddress
;
}
else
{
let
firstAddressGUID
=
Object
.
keys
(
addresses
)
[
0
]
;
if
(
firstAddressGUID
)
{
billingAddressSelect
.
value
=
firstAddressGUID
;
}
}
}
this
.
formHandler
.
updatePopulatedState
(
billingAddressSelect
.
popupBox
)
;
this
.
updateRequiredState
(
)
;
this
.
updateSaveButtonState
(
)
;
}
onChange
(
evt
)
{
let
ccType
=
this
.
form
.
querySelector
(
"
#
cc
-
type
"
)
;
this
.
cscInput
.
setAttribute
(
"
card
-
type
"
ccType
.
value
)
;
this
.
updateSaveButtonState
(
)
;
}
onClick
(
evt
)
{
switch
(
evt
.
target
)
{
case
this
.
cancelButton
:
{
paymentRequest
.
cancel
(
)
;
break
;
}
case
this
.
billingAddressPicker
.
addLink
:
case
this
.
billingAddressPicker
.
editLink
:
{
let
{
"
basic
-
card
-
page
"
:
basicCardPage
page
}
=
this
.
requestStore
.
getState
(
)
;
let
nextState
=
{
page
:
Object
.
assign
(
{
}
page
{
previousId
:
"
basic
-
card
-
page
"
}
)
"
basic
-
card
-
page
"
:
{
preserveFieldValues
:
true
guid
:
basicCardPage
.
guid
persistCheckboxValue
:
this
.
persistCheckbox
.
checked
selectedStateKey
:
basicCardPage
.
selectedStateKey
}
}
;
this
.
requestStore
.
setState
(
nextState
)
;
break
;
}
case
this
.
backButton
:
{
let
currentState
=
this
.
requestStore
.
getState
(
)
;
let
{
page
request
"
shipping
-
address
-
page
"
:
shippingAddressPage
"
billing
-
address
-
page
"
:
billingAddressPage
"
basic
-
card
-
page
"
:
basicCardPage
selectedShippingAddress
}
=
currentState
;
let
nextState
=
{
page
:
{
id
:
page
.
previousId
|
|
"
payment
-
summary
"
onboardingWizard
:
page
.
onboardingWizard
}
}
;
if
(
page
.
onboardingWizard
)
{
if
(
request
.
paymentOptions
.
requestShipping
)
{
shippingAddressPage
=
Object
.
assign
(
{
}
shippingAddressPage
{
guid
:
selectedShippingAddress
}
)
;
Object
.
assign
(
nextState
{
"
shipping
-
address
-
page
"
:
shippingAddressPage
}
)
;
}
else
{
billingAddressPage
=
Object
.
assign
(
{
}
billingAddressPage
{
guid
:
basicCardPage
.
billingAddressGUID
}
)
;
Object
.
assign
(
nextState
{
"
billing
-
address
-
page
"
:
billingAddressPage
}
)
;
}
let
basicCardPageState
=
Object
.
assign
(
{
}
basicCardPage
{
preserveFieldValues
:
true
}
)
;
delete
basicCardPageState
.
persistCheckboxValue
;
Object
.
assign
(
nextState
{
"
basic
-
card
-
page
"
:
basicCardPageState
}
)
;
}
this
.
requestStore
.
setState
(
nextState
)
;
break
;
}
case
this
.
saveButton
:
{
if
(
this
.
form
.
checkValidity
(
)
)
{
this
.
saveRecord
(
)
;
}
break
;
}
default
:
{
throw
new
Error
(
"
Unexpected
click
target
"
)
;
}
}
}
onInput
(
event
)
{
event
.
target
.
setCustomValidity
(
"
"
)
;
this
.
updateSaveButtonState
(
)
;
}
onInvalid
(
event
)
{
if
(
event
.
target
instanceof
HTMLFormElement
)
{
this
.
onInvalidForm
(
event
)
;
}
else
{
this
.
onInvalidField
(
event
)
;
}
}
onInvalidField
(
event
)
{
let
field
=
event
.
target
;
let
container
=
field
.
closest
(
#
{
field
.
id
}
-
container
)
;
let
errorTextSpan
=
paymentRequest
.
maybeCreateFieldErrorElement
(
container
)
;
errorTextSpan
.
textContent
=
field
.
validationMessage
;
}
onInvalidForm
(
)
{
this
.
saveButton
.
disabled
=
true
;
}
updateSaveButtonState
(
)
{
const
INVALID_CLASS_NAME
=
"
invalid
-
selected
-
option
"
;
let
isValid
=
this
.
form
.
checkValidity
(
)
&
&
!
this
.
billingAddressPicker
.
classList
.
contains
(
INVALID_CLASS_NAME
)
;
this
.
saveButton
.
disabled
=
!
isValid
;
}
updateRequiredState
(
)
{
for
(
let
field
of
this
.
form
.
elements
)
{
let
container
=
field
.
closest
(
"
.
container
"
)
;
let
span
=
container
.
querySelector
(
"
.
label
-
text
"
)
;
if
(
!
span
)
{
continue
;
}
span
.
setAttribute
(
"
fieldRequiredSymbol
"
this
.
dataset
.
fieldRequiredSymbol
)
;
container
.
toggleAttribute
(
"
required
"
field
.
required
&
&
!
field
.
disabled
)
;
}
}
async
saveRecord
(
)
{
let
record
=
this
.
formHandler
.
buildFormObject
(
)
;
let
currentState
=
this
.
requestStore
.
getState
(
)
;
let
{
tempBasicCards
"
basic
-
card
-
page
"
:
basicCardPage
}
=
currentState
;
let
editing
=
!
!
basicCardPage
.
guid
;
if
(
editing
?
basicCardPage
.
guid
in
tempBasicCards
:
!
this
.
persistCheckbox
.
checked
)
{
record
.
isTemporary
=
true
;
}
for
(
let
editableFieldName
of
[
"
cc
-
name
"
"
cc
-
exp
-
month
"
"
cc
-
exp
-
year
"
"
cc
-
type
"
]
)
{
record
[
editableFieldName
]
=
record
[
editableFieldName
]
|
|
"
"
;
}
if
(
!
editing
)
{
record
[
"
cc
-
number
"
]
=
record
[
"
cc
-
number
"
]
|
|
"
"
;
}
delete
record
[
"
cc
-
csc
"
]
;
try
{
let
{
guid
}
=
await
paymentRequest
.
updateAutofillRecord
(
"
creditCards
"
record
basicCardPage
.
guid
)
;
let
{
selectedStateKey
}
=
currentState
[
"
basic
-
card
-
page
"
]
;
if
(
!
selectedStateKey
)
{
throw
new
Error
(
state
[
"
basic
-
card
-
page
"
]
.
selectedStateKey
is
required
)
;
}
this
.
requestStore
.
setState
(
{
page
:
{
id
:
"
payment
-
summary
"
}
[
selectedStateKey
]
:
guid
[
selectedStateKey
+
"
SecurityCode
"
]
:
this
.
cscInput
.
value
}
)
;
}
catch
(
ex
)
{
log
.
warn
(
"
saveRecord
:
error
:
"
ex
)
;
this
.
requestStore
.
setState
(
{
page
:
{
id
:
"
basic
-
card
-
page
"
error
:
this
.
dataset
.
errorGenericSave
}
}
)
;
}
}
}
customElements
.
define
(
"
basic
-
card
-
form
"
BasicCardForm
)
;
