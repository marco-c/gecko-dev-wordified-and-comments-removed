import
LabelledCheckbox
from
"
.
.
/
components
/
labelled
-
checkbox
.
js
"
;
import
PaymentStateSubscriberMixin
from
"
.
.
/
mixins
/
PaymentStateSubscriberMixin
.
js
"
;
import
paymentRequest
from
"
.
.
/
paymentRequest
.
js
"
;
export
default
class
BasicCardForm
extends
PaymentStateSubscriberMixin
(
HTMLElement
)
{
constructor
(
)
{
super
(
)
;
this
.
pageTitle
=
document
.
createElement
(
"
h1
"
)
;
this
.
genericErrorText
=
document
.
createElement
(
"
div
"
)
;
this
.
cancelButton
=
document
.
createElement
(
"
button
"
)
;
this
.
cancelButton
.
className
=
"
cancel
-
button
"
;
this
.
cancelButton
.
addEventListener
(
"
click
"
this
)
;
this
.
backButton
=
document
.
createElement
(
"
button
"
)
;
this
.
backButton
.
className
=
"
back
-
button
"
;
this
.
backButton
.
addEventListener
(
"
click
"
this
)
;
this
.
saveButton
=
document
.
createElement
(
"
button
"
)
;
this
.
saveButton
.
className
=
"
save
-
button
"
;
this
.
saveButton
.
addEventListener
(
"
click
"
this
)
;
this
.
persistCheckbox
=
new
LabelledCheckbox
(
)
;
let
url
=
"
formautofill
/
editCreditCard
.
xhtml
"
;
this
.
promiseReady
=
this
.
_fetchMarkup
(
url
)
.
then
(
doc
=
>
{
this
.
form
=
doc
.
getElementById
(
"
form
"
)
;
return
this
.
form
;
}
)
;
}
_fetchMarkup
(
url
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
xhr
=
new
XMLHttpRequest
(
)
;
xhr
.
responseType
=
"
document
"
;
xhr
.
addEventListener
(
"
error
"
reject
)
;
xhr
.
addEventListener
(
"
load
"
evt
=
>
{
resolve
(
xhr
.
response
)
;
}
)
;
xhr
.
open
(
"
GET
"
url
)
;
xhr
.
send
(
)
;
}
)
;
}
connectedCallback
(
)
{
this
.
promiseReady
.
then
(
form
=
>
{
this
.
appendChild
(
this
.
pageTitle
)
;
this
.
appendChild
(
form
)
;
let
record
=
{
}
;
let
addresses
=
[
]
;
this
.
formHandler
=
new
EditCreditCard
(
{
form
}
record
addresses
{
isCCNumber
:
PaymentDialogUtils
.
isCCNumber
getAddressLabel
:
PaymentDialogUtils
.
getAddressLabel
}
)
;
this
.
appendChild
(
this
.
persistCheckbox
)
;
this
.
appendChild
(
this
.
genericErrorText
)
;
this
.
appendChild
(
this
.
cancelButton
)
;
this
.
appendChild
(
this
.
backButton
)
;
this
.
appendChild
(
this
.
saveButton
)
;
super
.
connectedCallback
(
)
;
}
)
;
}
render
(
state
)
{
let
{
page
savedAddresses
selectedShippingAddress
}
=
state
;
this
.
cancelButton
.
textContent
=
this
.
dataset
.
cancelButtonLabel
;
this
.
backButton
.
textContent
=
this
.
dataset
.
backButtonLabel
;
this
.
saveButton
.
textContent
=
this
.
dataset
.
saveButtonLabel
;
this
.
persistCheckbox
.
label
=
this
.
dataset
.
persistCheckboxLabel
;
this
.
backButton
.
hidden
=
!
!
page
.
onboardingWizard
;
this
.
cancelButton
.
hidden
=
!
page
.
onboardingWizard
;
let
record
=
{
}
;
let
basicCards
=
paymentRequest
.
getBasicCards
(
state
)
;
this
.
genericErrorText
.
textContent
=
page
.
error
;
let
editing
=
!
!
page
.
guid
;
this
.
form
.
querySelector
(
"
#
cc
-
number
"
)
.
disabled
=
editing
;
if
(
editing
)
{
this
.
pageTitle
.
textContent
=
this
.
dataset
.
editBasicCardTitle
;
record
=
basicCards
[
page
.
guid
]
;
if
(
!
record
)
{
throw
new
Error
(
"
Trying
to
edit
a
non
-
existing
card
:
"
+
page
.
guid
)
;
}
this
.
persistCheckbox
.
hidden
=
true
;
}
else
{
this
.
pageTitle
.
textContent
=
this
.
dataset
.
addBasicCardTitle
;
if
(
selectedShippingAddress
)
{
record
.
billingAddressGUID
=
selectedShippingAddress
;
}
this
.
persistCheckbox
.
hidden
=
false
;
this
.
persistCheckbox
.
checked
=
!
state
.
isPrivate
;
}
this
.
formHandler
.
loadRecord
(
record
savedAddresses
)
;
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
click
"
:
{
this
.
onClick
(
event
)
;
break
;
}
}
}
onClick
(
evt
)
{
switch
(
evt
.
target
)
{
case
this
.
cancelButton
:
{
paymentRequest
.
cancel
(
)
;
break
;
}
case
this
.
backButton
:
{
this
.
requestStore
.
setState
(
{
page
:
{
id
:
"
payment
-
summary
"
}
}
)
;
break
;
}
case
this
.
saveButton
:
{
this
.
saveRecord
(
)
;
break
;
}
default
:
{
throw
new
Error
(
"
Unexpected
click
target
"
)
;
}
}
}
saveRecord
(
)
{
let
record
=
this
.
formHandler
.
buildFormObject
(
)
;
let
{
page
tempBasicCards
}
=
this
.
requestStore
.
getState
(
)
;
let
editing
=
!
!
page
.
guid
;
let
tempRecord
=
editing
&
&
tempBasicCards
[
page
.
guid
]
;
for
(
let
editableFieldName
of
[
"
cc
-
name
"
"
cc
-
exp
-
month
"
"
cc
-
exp
-
year
"
]
)
{
record
[
editableFieldName
]
=
record
[
editableFieldName
]
|
|
"
"
;
}
if
(
!
editing
)
{
record
[
"
cc
-
number
"
]
=
record
[
"
cc
-
number
"
]
|
|
"
"
;
}
if
(
!
tempRecord
&
&
this
.
persistCheckbox
.
checked
)
{
log
.
debug
(
BasicCardForm
:
persisting
creditCard
record
:
{
page
.
guid
|
|
"
(
new
)
"
}
)
;
paymentRequest
.
updateAutofillRecord
(
"
creditCards
"
record
page
.
guid
{
errorStateChange
:
{
page
:
{
id
:
"
basic
-
card
-
page
"
error
:
this
.
dataset
.
errorGenericSave
}
}
preserveOldProperties
:
true
selectedStateKey
:
"
selectedPaymentCard
"
successStateChange
:
{
page
:
{
id
:
"
payment
-
summary
"
}
}
}
)
;
}
else
{
record
.
guid
=
page
.
guid
|
|
"
temp
-
"
+
Math
.
abs
(
Math
.
random
(
)
*
0xffffffff
|
0
)
;
log
.
debug
(
BasicCardForm
:
saving
temporary
record
:
{
record
.
guid
}
)
;
this
.
requestStore
.
setState
(
{
page
:
{
id
:
"
payment
-
summary
"
}
selectedPaymentCard
:
record
.
guid
tempBasicCards
:
Object
.
assign
(
{
}
tempBasicCards
{
[
record
.
guid
]
:
Object
.
assign
(
{
}
tempRecord
record
)
}
)
}
)
;
}
}
}
customElements
.
define
(
"
basic
-
card
-
form
"
BasicCardForm
)
;
