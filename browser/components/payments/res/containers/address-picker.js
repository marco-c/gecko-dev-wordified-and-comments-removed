import
AddressOption
from
"
.
.
/
components
/
address
-
option
.
js
"
;
import
PaymentStateSubscriberMixin
from
"
.
.
/
mixins
/
PaymentStateSubscriberMixin
.
js
"
;
import
RichSelect
from
"
.
.
/
components
/
rich
-
select
.
js
"
;
export
default
class
AddressPicker
extends
PaymentStateSubscriberMixin
(
HTMLElement
)
{
static
get
observedAttributes
(
)
{
return
[
"
address
-
fields
"
]
;
}
constructor
(
)
{
super
(
)
;
this
.
dropdown
=
new
RichSelect
(
)
;
this
.
dropdown
.
addEventListener
(
"
change
"
this
)
;
}
connectedCallback
(
)
{
this
.
appendChild
(
this
.
dropdown
)
;
super
.
connectedCallback
(
)
;
}
attributeChangedCallback
(
name
oldValue
newValue
)
{
if
(
oldValue
!
=
=
newValue
)
{
this
.
render
(
this
.
requestStore
.
getState
(
)
)
;
}
}
filterAddresses
(
addresses
fieldNames
=
[
"
address
-
level1
"
"
address
-
level2
"
"
country
"
"
name
"
"
postal
-
code
"
"
street
-
address
"
]
)
{
let
uniques
=
new
Set
(
)
;
let
result
=
{
}
;
for
(
let
[
guid
address
]
of
Object
.
entries
(
addresses
)
)
{
let
addressCopy
=
{
}
;
let
isMatch
=
false
;
for
(
let
name
of
fieldNames
)
{
if
(
address
[
name
]
)
{
isMatch
=
true
;
addressCopy
[
name
]
=
address
[
name
]
;
}
}
if
(
isMatch
)
{
let
key
=
JSON
.
stringify
(
addressCopy
)
;
if
(
!
uniques
.
has
(
key
)
)
{
uniques
.
add
(
key
)
;
result
[
guid
]
=
address
;
}
}
}
return
result
;
}
render
(
state
)
{
let
{
savedAddresses
}
=
state
;
let
desiredOptions
=
[
]
;
let
fieldNames
;
if
(
this
.
hasAttribute
(
"
address
-
fields
"
)
)
{
let
names
=
this
.
getAttribute
(
"
address
-
fields
"
)
.
split
(
/
\
s
+
/
)
;
if
(
names
.
length
)
{
fieldNames
=
names
;
}
}
let
filteredAddresses
=
this
.
filterAddresses
(
savedAddresses
fieldNames
)
;
for
(
let
[
guid
address
]
of
Object
.
entries
(
filteredAddresses
)
)
{
let
optionEl
=
this
.
dropdown
.
getOptionByValue
(
guid
)
;
if
(
!
optionEl
)
{
optionEl
=
new
AddressOption
(
)
;
optionEl
.
value
=
guid
;
}
for
(
let
key
of
AddressOption
.
recordAttributes
)
{
let
val
=
address
[
key
]
;
if
(
val
)
{
optionEl
.
setAttribute
(
key
val
)
;
}
else
{
optionEl
.
removeAttribute
(
key
)
;
}
}
desiredOptions
.
push
(
optionEl
)
;
}
let
el
=
null
;
while
(
(
el
=
this
.
dropdown
.
popupBox
.
querySelector
(
"
:
scope
>
address
-
option
"
)
)
)
{
el
.
remove
(
)
;
}
for
(
let
option
of
desiredOptions
)
{
this
.
dropdown
.
popupBox
.
appendChild
(
option
)
;
}
let
selectedAddressGUID
=
state
[
this
.
selectedStateKey
]
;
let
optionWithGUID
=
this
.
dropdown
.
getOptionByValue
(
selectedAddressGUID
)
;
this
.
dropdown
.
selectedOption
=
optionWithGUID
;
if
(
selectedAddressGUID
&
&
!
optionWithGUID
)
{
throw
new
Error
(
{
this
.
selectedStateKey
}
option
{
selectedAddressGUID
}
+
does
not
exist
in
options
)
;
}
}
get
selectedStateKey
(
)
{
return
this
.
getAttribute
(
"
selected
-
state
-
key
"
)
;
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
change
"
:
{
this
.
onChange
(
event
)
;
break
;
}
}
}
onChange
(
event
)
{
let
select
=
event
.
target
;
let
selectedKey
=
this
.
selectedStateKey
;
if
(
selectedKey
)
{
this
.
requestStore
.
setState
(
{
[
selectedKey
]
:
select
.
selectedOption
&
&
select
.
selectedOption
.
guid
}
)
;
}
}
}
customElements
.
define
(
"
address
-
picker
"
AddressPicker
)
;
