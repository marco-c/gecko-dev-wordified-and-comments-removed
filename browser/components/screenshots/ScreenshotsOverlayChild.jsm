var
EXPORTED_SYMBOLS
=
[
"
ScreenshotsOverlayChild
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
overlayLocalization
"
(
)
=
>
{
return
new
Localization
(
[
"
browser
/
screenshotsOverlay
.
ftl
"
]
true
)
;
}
)
;
const
STYLESHEET_URL
=
"
chrome
:
/
/
browser
/
content
/
screenshots
/
overlay
/
overlay
.
css
"
;
const
HTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
class
AnonymousContentOverlay
{
constructor
(
contentDocument
screenshotsChild
)
{
this
.
listeners
=
new
Map
(
)
;
this
.
elements
=
new
Map
(
)
;
this
.
screenshotsChild
=
screenshotsChild
;
this
.
contentDocument
=
contentDocument
;
this
.
pageListenerTarget
=
contentDocument
.
ownerGlobal
;
this
.
overlayFragment
=
null
;
this
.
overlayId
=
"
screenshots
-
overlay
-
container
"
;
this
.
_initialized
=
false
;
}
get
content
(
)
{
if
(
!
this
.
_content
|
|
Cu
.
isDeadWrapper
(
this
.
_content
)
)
{
return
null
;
}
return
this
.
_content
;
}
async
initialize
(
)
{
if
(
this
.
_initialized
)
{
return
;
}
let
document
=
this
.
contentDocument
;
let
window
=
document
.
ownerGlobal
;
if
(
!
this
.
overlayFragment
)
{
try
{
window
.
windowUtils
.
loadSheetUsingURIString
(
STYLESHEET_URL
window
.
windowUtils
.
AGENT_SHEET
)
;
}
catch
{
}
}
this
.
overlayFragment
=
this
.
overlayFragment
?
this
.
overlayFragment
:
this
.
buildOverlay
(
)
;
this
.
_content
=
document
.
insertAnonymousContent
(
this
.
overlayFragment
.
children
[
0
]
)
;
this
.
addEventListenerForElement
(
"
screenshots
-
cancel
-
button
"
"
click
"
(
event
targetId
)
=
>
{
this
.
screenshotsChild
.
requestCancelScreenshot
(
)
;
}
)
;
this
.
_initialized
=
true
;
}
tearDown
(
)
{
if
(
this
.
_content
)
{
this
.
_removeAllListeners
(
)
;
try
{
this
.
contentDocument
.
removeAnonymousContent
(
this
.
_content
)
;
}
catch
(
e
)
{
}
}
this
.
_initialized
=
false
;
}
createElem
(
elemName
props
=
{
}
className
=
"
"
)
{
let
elem
=
this
.
contentDocument
.
createElementNS
(
HTML_NS
elemName
)
;
if
(
props
)
{
for
(
let
[
name
value
]
of
Object
.
entries
(
props
)
)
{
elem
[
name
]
=
value
;
}
}
if
(
className
)
{
elem
.
className
=
className
;
}
if
(
elem
.
id
)
{
this
.
elements
.
set
(
elem
.
id
elem
)
;
}
return
elem
;
}
buildOverlay
(
)
{
let
[
cancel
instrustions
]
=
overlayLocalization
.
formatMessagesSync
(
[
{
id
:
"
screenshots
-
overlay
-
cancel
-
button
"
}
{
id
:
"
screenshots
-
overlay
-
instructions
"
}
]
)
;
const
htmlString
=
<
div
id
=
"
{
this
.
overlayId
}
"
>
<
div
class
=
"
fixed
-
container
"
>
<
div
class
=
"
face
-
container
"
>
<
div
class
=
"
eye
left
"
>
<
div
class
=
"
eyeball
"
>
<
/
div
>
<
/
div
>
<
div
class
=
"
eye
right
"
>
<
div
class
=
"
eyeball
"
>
<
/
div
>
<
/
div
>
<
div
class
=
"
face
"
>
<
/
div
>
<
/
div
>
<
div
class
=
"
preview
-
instructions
"
data
-
l10n
-
id
=
"
screenshots
-
instructions
"
>
{
instrustions
.
value
}
<
/
div
>
<
div
class
=
"
cancel
-
shot
"
id
=
"
screenshots
-
cancel
-
button
"
data
-
l10n
-
id
=
"
screenshots
-
overlay
-
cancel
-
button
"
>
{
cancel
.
value
}
<
/
div
>
<
/
div
>
<
/
div
;
const
parser
=
new
this
.
contentDocument
.
ownerGlobal
.
DOMParser
(
)
;
const
tmpDoc
=
parser
.
parseFromString
(
htmlString
"
text
/
html
"
)
;
const
fragment
=
this
.
contentDocument
.
createDocumentFragment
(
)
;
fragment
.
appendChild
(
tmpDoc
.
body
.
children
[
0
]
)
;
return
fragment
;
}
addEventListenerForElement
(
id
type
handler
)
{
if
(
typeof
id
!
=
=
"
string
"
)
{
throw
new
Error
(
"
Expected
a
string
ID
in
addEventListenerForElement
but
got
:
"
+
id
)
;
}
if
(
!
this
.
listeners
.
has
(
type
)
)
{
const
target
=
this
.
pageListenerTarget
;
target
.
addEventListener
(
type
this
true
)
;
this
.
listeners
.
set
(
type
new
Map
(
)
)
;
}
const
listeners
=
this
.
listeners
.
get
(
type
)
;
listeners
.
set
(
id
handler
)
;
}
removeEventListenerForElement
(
id
type
)
{
const
listeners
=
this
.
listeners
.
get
(
type
)
;
if
(
!
listeners
)
{
return
;
}
listeners
.
delete
(
id
)
;
if
(
!
listeners
.
size
)
{
const
target
=
this
.
pageListenerTarget
;
target
.
removeEventListener
(
type
this
true
)
;
}
}
handleEvent
(
event
)
{
const
listeners
=
this
.
listeners
.
get
(
event
.
type
)
;
if
(
!
listeners
)
{
return
;
}
let
isPropagationStopped
=
false
;
const
eventProxy
=
new
Proxy
(
event
{
get
:
(
obj
name
)
=
>
{
if
(
name
=
=
=
"
originalTarget
"
)
{
return
null
;
}
else
if
(
name
=
=
=
"
stopPropagation
"
)
{
return
(
)
=
>
{
isPropagationStopped
=
true
;
}
;
}
return
obj
[
name
]
;
}
}
)
;
let
node
=
event
.
originalTarget
;
while
(
node
)
{
let
nodeId
=
node
.
id
;
if
(
nodeId
)
{
const
handler
=
listeners
.
get
(
node
.
id
)
;
if
(
handler
)
{
handler
(
eventProxy
nodeId
)
;
if
(
isPropagationStopped
)
{
break
;
}
}
if
(
nodeId
=
=
this
.
overlayId
)
{
break
;
}
}
node
=
node
.
parentNode
;
}
}
_removeAllListeners
(
)
{
if
(
this
.
pageListenerTarget
)
{
const
target
=
this
.
pageListenerTarget
;
for
(
const
[
type
]
of
this
.
listeners
)
{
target
.
removeEventListener
(
type
this
true
)
;
}
}
this
.
listeners
.
clear
(
)
;
}
}
var
ScreenshotsOverlayChild
=
{
AnonymousContentOverlay
}
;
