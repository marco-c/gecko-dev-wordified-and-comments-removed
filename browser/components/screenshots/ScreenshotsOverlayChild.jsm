var
EXPORTED_SYMBOLS
=
[
"
ScreenshotsOverlayChild
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
overlayLocalization
"
(
)
=
>
{
return
new
Localization
(
[
"
browser
/
screenshotsOverlay
.
ftl
"
]
true
)
;
}
)
;
const
STYLESHEET_URL
=
"
chrome
:
/
/
browser
/
content
/
screenshots
/
overlay
/
overlay
.
css
"
;
class
AnonymousContentOverlay
{
constructor
(
contentDocument
screenshotsChild
)
{
this
.
listeners
=
new
Map
(
)
;
this
.
elements
=
new
Map
(
)
;
this
.
screenshotsChild
=
screenshotsChild
;
this
.
contentDocument
=
contentDocument
;
this
.
pageListenerTarget
=
contentDocument
.
ownerGlobal
;
this
.
overlayFragment
=
null
;
this
.
overlayId
=
"
screenshots
-
overlay
-
container
"
;
this
.
previewId
=
"
preview
-
container
"
;
this
.
selectionId
=
"
selection
-
container
"
;
this
.
_initialized
=
false
;
this
.
moverIds
=
[
"
mover
-
left
"
"
mover
-
top
"
"
mover
-
right
"
"
mover
-
bottom
"
"
mover
-
topLeft
"
"
mover
-
topRight
"
"
mover
-
bottomLeft
"
"
mover
-
bottomRight
"
]
;
}
get
content
(
)
{
if
(
!
this
.
_content
|
|
Cu
.
isDeadWrapper
(
this
.
_content
)
)
{
return
null
;
}
return
this
.
_content
;
}
async
initialize
(
)
{
if
(
this
.
_initialized
)
{
return
;
}
let
document
=
this
.
contentDocument
;
let
window
=
document
.
ownerGlobal
;
if
(
!
this
.
overlayFragment
)
{
try
{
window
.
windowUtils
.
loadSheetUsingURIString
(
STYLESHEET_URL
window
.
windowUtils
.
AGENT_SHEET
)
;
}
catch
{
}
this
.
overlayFragment
=
this
.
buildOverlay
(
)
;
}
this
.
_content
=
document
.
insertAnonymousContent
(
this
.
overlayFragment
.
children
[
0
]
)
;
this
.
addEventListeners
(
)
;
this
.
previewLayer
=
new
PreviewLayer
(
this
.
previewId
this
.
content
)
;
this
.
selectionLayer
=
new
SelectionLayer
(
this
.
selectionId
this
.
content
)
;
this
.
screenshotsContainer
=
new
ScreenshotsContainerLayer
(
this
.
overlayId
this
.
content
this
.
previewLayer
this
.
selectionLayer
)
;
this
.
stateHandler
=
new
StateHandler
(
this
.
screenshotsContainer
)
;
this
.
screenshotsContainer
.
updateSize
(
window
)
;
this
.
stateHandler
.
setState
(
"
crosshairs
"
)
;
this
.
_initialized
=
true
;
}
updateScreenshotsSize
(
eventType
)
{
this
.
stateHandler
.
updateScreenshotsContainerSize
(
this
.
contentDocument
.
ownerGlobal
eventType
)
;
}
addEventListeners
(
)
{
this
.
addEventListenerForElement
(
"
screenshots
-
cancel
-
button
"
"
click
"
(
event
targetId
)
=
>
{
this
.
screenshotsChild
.
requestCancelScreenshot
(
)
;
}
)
;
this
.
addEventListenerForElement
(
"
cancel
"
"
click
"
(
event
targetId
)
=
>
{
this
.
screenshotsChild
.
requestCancelScreenshot
(
)
;
}
)
;
this
.
addEventListenerForElement
(
"
copy
"
"
click
"
(
event
targetId
)
=
>
{
this
.
screenshotsChild
.
requestCopyScreenshot
(
this
.
screenshotsContainer
.
getSelectionLayerBoxDimensions
(
)
)
;
}
)
;
this
.
addEventListenerForElement
(
"
download
"
"
click
"
(
event
targetId
)
=
>
{
this
.
screenshotsChild
.
requestDownloadScreenshot
(
this
.
screenshotsContainer
.
getSelectionLayerBoxDimensions
(
)
)
;
}
)
;
this
.
addEventListenerForElement
(
"
cancel
"
"
pointerdown
"
(
event
targetId
)
=
>
{
event
.
stopPropagation
(
)
;
}
)
;
this
.
addEventListenerForElement
(
"
copy
"
"
pointerdown
"
(
event
targetId
)
=
>
{
event
.
stopPropagation
(
)
;
}
)
;
this
.
addEventListenerForElement
(
"
download
"
"
pointerdown
"
(
event
targetId
)
=
>
{
event
.
stopPropagation
(
)
;
}
)
;
this
.
addEventListenerForElement
(
this
.
overlayId
"
pointerdown
"
(
event
targetId
)
=
>
{
this
.
dragStart
(
event
targetId
)
;
}
)
;
this
.
addEventListenerForElement
(
this
.
overlayId
"
pointerup
"
(
event
targetId
)
=
>
{
this
.
dragEnd
(
event
targetId
)
;
}
)
;
this
.
addEventListenerForElement
(
this
.
overlayId
"
pointermove
"
(
event
targetId
)
=
>
{
this
.
drag
(
event
targetId
)
;
}
)
;
for
(
let
id
of
this
.
moverIds
.
concat
(
[
"
highlight
"
]
)
)
{
this
.
addEventListenerForElement
(
id
"
pointerdown
"
(
event
targetId
)
=
>
{
this
.
dragStart
(
event
targetId
)
;
}
)
;
this
.
addEventListenerForElement
(
id
"
pointerup
"
(
event
targetId
)
=
>
{
this
.
dragEnd
(
event
targetId
)
;
}
)
;
this
.
addEventListenerForElement
(
id
"
pointermove
"
(
event
targetId
)
=
>
{
this
.
drag
(
event
targetId
)
;
}
)
;
}
}
tearDown
(
)
{
if
(
this
.
_content
)
{
this
.
_removeAllListeners
(
)
;
try
{
this
.
contentDocument
.
removeAnonymousContent
(
this
.
_content
)
;
}
catch
(
e
)
{
}
}
this
.
_initialized
=
false
;
}
buildOverlay
(
)
{
let
[
cancel
instrustions
download
copy
]
=
lazy
.
overlayLocalization
.
formatMessagesSync
(
[
{
id
:
"
screenshots
-
overlay
-
cancel
-
button
"
}
{
id
:
"
screenshots
-
overlay
-
instructions
"
}
{
id
:
"
screenshots
-
overlay
-
download
-
button
"
}
{
id
:
"
screenshots
-
overlay
-
copy
-
button
"
}
]
)
;
const
htmlString
=
<
div
id
=
"
screenshots
-
component
"
>
<
div
id
=
"
{
this
.
overlayId
}
"
>
<
div
id
=
"
{
this
.
previewId
}
"
>
<
div
class
=
"
fixed
-
container
"
>
<
div
class
=
"
face
-
container
"
>
<
div
class
=
"
eye
left
"
>
<
div
id
=
"
left
-
eye
"
class
=
"
eyeball
"
>
<
/
div
>
<
/
div
>
<
div
class
=
"
eye
right
"
>
<
div
id
=
"
right
-
eye
"
class
=
"
eyeball
"
>
<
/
div
>
<
/
div
>
<
div
class
=
"
face
"
>
<
/
div
>
<
/
div
>
<
div
class
=
"
preview
-
instructions
"
data
-
l10n
-
id
=
"
screenshots
-
instructions
"
>
{
instrustions
.
value
}
<
/
div
>
<
div
class
=
"
cancel
-
shot
"
id
=
"
screenshots
-
cancel
-
button
"
data
-
l10n
-
id
=
"
screenshots
-
overlay
-
cancel
-
button
"
>
{
cancel
.
value
}
<
/
div
>
<
/
div
>
<
/
div
>
<
div
id
=
"
{
this
.
selectionId
}
"
style
=
"
display
:
none
;
"
>
<
div
id
=
"
bgTop
"
class
=
"
bghighlight
"
style
=
"
display
:
none
;
"
>
<
/
div
>
<
div
id
=
"
bgBottom
"
class
=
"
bghighlight
"
style
=
"
display
:
none
;
"
>
<
/
div
>
<
div
id
=
"
bgLeft
"
class
=
"
bghighlight
"
style
=
"
display
:
none
;
"
>
<
/
div
>
<
div
id
=
"
bgRight
"
class
=
"
bghighlight
"
style
=
"
display
:
none
;
"
>
<
/
div
>
<
div
id
=
"
highlight
"
class
=
"
highlight
"
style
=
"
display
:
none
;
"
>
<
div
id
=
"
mover
-
topLeft
"
class
=
"
mover
-
target
direction
-
topLeft
"
>
<
div
class
=
"
mover
"
>
<
/
div
>
<
/
div
>
<
div
id
=
"
mover
-
top
"
class
=
"
mover
-
target
direction
-
top
"
>
<
div
class
=
"
mover
"
>
<
/
div
>
<
/
div
>
<
div
id
=
"
mover
-
topRight
"
class
=
"
mover
-
target
direction
-
topRight
"
>
<
div
class
=
"
mover
"
>
<
/
div
>
<
/
div
>
<
div
id
=
"
mover
-
left
"
class
=
"
mover
-
target
direction
-
left
"
>
<
div
class
=
"
mover
"
>
<
/
div
>
<
/
div
>
<
div
id
=
"
mover
-
right
"
class
=
"
mover
-
target
direction
-
right
"
>
<
div
class
=
"
mover
"
>
<
/
div
>
<
/
div
>
<
div
id
=
"
mover
-
bottomLeft
"
class
=
"
mover
-
target
direction
-
bottomLeft
"
>
<
div
class
=
"
mover
"
>
<
/
div
>
<
/
div
>
<
div
id
=
"
mover
-
bottom
"
class
=
"
mover
-
target
direction
-
bottom
"
>
<
div
class
=
"
mover
"
>
<
/
div
>
<
/
div
>
<
div
id
=
"
mover
-
bottomRight
"
class
=
"
mover
-
target
direction
-
bottomRight
"
>
<
div
class
=
"
mover
"
>
<
/
div
>
<
/
div
>
<
/
div
>
<
div
id
=
"
buttons
"
style
=
"
display
:
none
;
"
>
<
button
id
=
"
cancel
"
class
=
"
screenshots
-
button
"
title
=
"
{
cancel
.
value
}
"
aria
-
label
=
"
{
cancel
.
value
}
"
>
<
img
/
>
<
/
button
>
<
button
id
=
"
copy
"
class
=
"
screenshots
-
button
"
title
=
"
{
copy
.
value
}
"
aria
-
label
=
"
{
copy
.
value
}
"
>
<
img
/
>
{
copy
.
value
}
<
/
button
>
<
button
id
=
"
download
"
class
=
"
screenshots
-
button
"
title
=
"
{
download
.
value
}
"
aria
-
label
=
"
{
download
.
value
}
"
>
<
img
/
>
{
download
.
value
}
<
/
button
>
<
/
div
>
<
/
div
>
<
/
div
>
<
/
div
>
;
const
parser
=
new
this
.
contentDocument
.
ownerGlobal
.
DOMParser
(
)
;
const
tmpDoc
=
parser
.
parseFromString
(
htmlString
"
text
/
html
"
)
;
const
fragment
=
this
.
contentDocument
.
createDocumentFragment
(
)
;
fragment
.
appendChild
(
tmpDoc
.
body
.
children
[
0
]
)
;
return
fragment
;
}
addEventListenerForElement
(
id
type
handler
)
{
if
(
typeof
id
!
=
=
"
string
"
)
{
throw
new
Error
(
"
Expected
a
string
ID
in
addEventListenerForElement
but
got
:
"
+
id
)
;
}
if
(
!
this
.
listeners
.
has
(
type
)
)
{
const
target
=
this
.
pageListenerTarget
;
target
.
addEventListener
(
type
this
true
)
;
this
.
listeners
.
set
(
type
new
Map
(
)
)
;
}
const
listeners
=
this
.
listeners
.
get
(
type
)
;
listeners
.
set
(
id
handler
)
;
}
removeEventListenerForElement
(
id
type
)
{
const
listeners
=
this
.
listeners
.
get
(
type
)
;
if
(
!
listeners
)
{
return
;
}
listeners
.
delete
(
id
)
;
if
(
!
listeners
.
size
)
{
const
target
=
this
.
pageListenerTarget
;
target
.
removeEventListener
(
type
this
true
)
;
}
}
handleEvent
(
event
)
{
const
listeners
=
this
.
listeners
.
get
(
event
.
type
)
;
if
(
!
listeners
)
{
return
;
}
let
isPropagationStopped
=
false
;
const
eventProxy
=
new
Proxy
(
event
{
get
:
(
obj
name
)
=
>
{
if
(
name
=
=
=
"
originalTarget
"
)
{
return
null
;
}
else
if
(
name
=
=
=
"
stopPropagation
"
)
{
return
(
)
=
>
{
isPropagationStopped
=
true
;
}
;
}
return
obj
[
name
]
;
}
}
)
;
let
node
=
event
.
originalTarget
;
while
(
node
)
{
let
nodeId
=
node
.
id
;
if
(
nodeId
)
{
const
handler
=
listeners
.
get
(
node
.
id
)
;
if
(
handler
)
{
handler
(
eventProxy
nodeId
)
;
if
(
isPropagationStopped
)
{
break
;
}
}
if
(
nodeId
=
=
this
.
overlayId
)
{
break
;
}
}
node
=
node
.
parentNode
;
}
}
_removeAllListeners
(
)
{
if
(
this
.
pageListenerTarget
)
{
const
target
=
this
.
pageListenerTarget
;
for
(
const
[
type
]
of
this
.
listeners
)
{
target
.
removeEventListener
(
type
this
true
)
;
}
}
this
.
listeners
.
clear
(
)
;
}
dragStart
(
event
targetId
)
{
this
.
stateHandler
.
dragStart
(
event
targetId
)
;
}
drag
(
event
targetId
)
{
this
.
stateHandler
.
drag
(
event
)
;
}
dragEnd
(
event
targetId
)
{
this
.
stateHandler
.
dragEnd
(
event
)
;
}
}
var
ScreenshotsOverlayChild
=
{
AnonymousContentOverlay
}
;
class
StateHandler
{
#
state
;
#
lastBox
;
#
moverId
;
#
lastX
;
#
lastY
;
#
screenshotsContainer
;
constructor
(
screenshotsContainer
)
{
this
.
#
state
=
"
crosshairs
"
;
this
.
#
lastBox
=
{
}
;
this
.
#
screenshotsContainer
=
screenshotsContainer
;
}
setState
(
newState
)
{
this
.
#
state
=
newState
;
this
.
start
(
)
;
}
getState
(
)
{
return
this
.
#
state
;
}
start
(
)
{
switch
(
this
.
#
state
)
{
case
"
crosshairs
"
:
{
this
.
crosshairsStart
(
)
;
break
;
}
case
"
dragging
"
:
{
this
.
draggingStart
(
)
;
break
;
}
case
"
selected
"
:
{
this
.
selectedStart
(
)
;
break
;
}
case
"
resizing
"
:
{
this
.
resizingStart
(
)
;
break
;
}
}
}
getCoordinates
(
event
)
{
let
clientX
=
event
.
pageX
;
let
clientY
=
event
.
pageY
;
return
{
clientX
clientY
}
;
}
dragStart
(
event
targetId
)
{
let
{
clientX
clientY
}
=
this
.
getCoordinates
(
event
)
;
switch
(
this
.
#
state
)
{
case
"
crosshairs
"
:
{
this
.
crosshairsDragStart
(
clientX
clientY
)
;
break
;
}
case
"
selected
"
:
{
this
.
selectedDragStart
(
clientX
clientY
targetId
)
;
break
;
}
}
}
drag
(
event
targetId
)
{
let
{
clientX
clientY
}
=
this
.
getCoordinates
(
event
)
;
switch
(
this
.
#
state
)
{
case
"
crosshairs
"
:
{
this
.
crosshairsMove
(
clientX
clientY
)
;
break
;
}
case
"
draggingReady
"
:
{
this
.
draggingReadyDrag
(
clientX
clientY
)
;
break
;
}
case
"
dragging
"
:
{
this
.
draggingDrag
(
clientX
clientY
)
;
break
;
}
case
"
resizing
"
:
{
this
.
resizingDrag
(
clientX
clientY
)
;
break
;
}
}
}
dragEnd
(
event
targetId
)
{
let
{
clientX
clientY
}
=
this
.
getCoordinates
(
event
)
;
switch
(
this
.
#
state
)
{
case
"
draggingReady
"
:
{
this
.
draggingReadyDragEnd
(
)
;
break
;
}
case
"
dragging
"
:
{
this
.
draggingDragEnd
(
clientX
clientY
targetId
)
;
break
;
}
case
"
resizing
"
:
{
this
.
resizingDragEnd
(
clientX
clientY
targetId
)
;
break
;
}
}
}
crosshairsStart
(
)
{
this
.
#
screenshotsContainer
.
hideSelectionLayer
(
)
;
this
.
#
screenshotsContainer
.
showPreviewLayer
(
)
;
}
draggingStart
(
)
{
this
.
#
screenshotsContainer
.
hidePreviewLayer
(
)
;
this
.
#
screenshotsContainer
.
hideButtonsLayer
(
)
;
this
.
#
screenshotsContainer
.
drawSelectionBox
(
)
;
}
selectedStart
(
)
{
this
.
#
screenshotsContainer
.
drawButtonsLayer
(
)
;
}
resizingStart
(
)
{
this
.
#
screenshotsContainer
.
hideButtonsLayer
(
)
;
let
{
width
height
}
=
this
.
#
screenshotsContainer
.
getSelectionLayerBoxDimensions
(
)
;
this
.
#
lastBox
=
{
width
height
}
;
}
crosshairsDragStart
(
clientX
clientY
)
{
this
.
#
screenshotsContainer
.
setSelectionBoxDimensions
(
{
left
:
clientX
top
:
clientY
right
:
clientX
bottom
:
clientY
}
)
;
this
.
setState
(
"
draggingReady
"
)
;
}
selectedDragStart
(
clientX
clientY
targetId
)
{
if
(
targetId
=
=
=
this
.
#
screenshotsContainer
.
id
)
{
this
.
setState
(
"
crosshairs
"
)
;
return
;
}
this
.
#
moverId
=
targetId
;
this
.
#
lastX
=
clientX
;
this
.
#
lastY
=
clientY
;
this
.
setState
(
"
resizing
"
)
;
}
crosshairsMove
(
clientX
clientY
)
{
this
.
#
screenshotsContainer
.
drawPreviewEyes
(
clientX
clientY
)
;
}
draggingDrag
(
clientX
clientY
)
{
this
.
#
screenshotsContainer
.
setSelectionBoxDimensions
(
{
right
:
clientX
bottom
:
clientY
}
)
;
this
.
#
screenshotsContainer
.
drawSelectionBox
(
)
;
}
draggingReadyDrag
(
clientX
clientY
)
{
this
.
#
screenshotsContainer
.
setSelectionBoxDimensions
(
{
right
:
clientX
bottom
:
clientY
}
)
;
if
(
this
.
#
screenshotsContainer
.
selectionBoxDistance
(
)
>
40
)
{
this
.
setState
(
"
dragging
"
)
;
}
}
resizingDrag
(
clientX
clientY
)
{
switch
(
this
.
#
moverId
)
{
case
"
mover
-
topLeft
"
:
{
this
.
#
screenshotsContainer
.
setSelectionBoxDimensions
(
{
left
:
clientX
top
:
clientY
}
)
;
break
;
}
case
"
mover
-
top
"
:
{
this
.
#
screenshotsContainer
.
setSelectionBoxDimensions
(
{
top
:
clientY
}
)
;
break
;
}
case
"
mover
-
topRight
"
:
{
this
.
#
screenshotsContainer
.
setSelectionBoxDimensions
(
{
top
:
clientY
right
:
clientX
}
)
;
break
;
}
case
"
mover
-
right
"
:
{
this
.
#
screenshotsContainer
.
setSelectionBoxDimensions
(
{
right
:
clientX
}
)
;
break
;
}
case
"
mover
-
bottomRight
"
:
{
this
.
#
screenshotsContainer
.
setSelectionBoxDimensions
(
{
right
:
clientX
bottom
:
clientY
}
)
;
break
;
}
case
"
mover
-
bottom
"
:
{
this
.
#
screenshotsContainer
.
setSelectionBoxDimensions
(
{
bottom
:
clientY
}
)
;
break
;
}
case
"
mover
-
bottomLeft
"
:
{
this
.
#
screenshotsContainer
.
setSelectionBoxDimensions
(
{
left
:
clientX
bottom
:
clientY
}
)
;
break
;
}
case
"
mover
-
left
"
:
{
this
.
#
screenshotsContainer
.
setSelectionBoxDimensions
(
{
left
:
clientX
}
)
;
break
;
}
case
"
highlight
"
:
{
let
lastBox
=
this
.
#
lastBox
;
let
diffX
=
this
.
#
lastX
-
clientX
;
let
diffY
=
this
.
#
lastY
-
clientY
;
let
newLeft
;
let
newRight
;
let
newTop
;
let
newBottom
;
/
/
Unpack
SelectionBox
dimensions
to
use
here
let
{
boxLeft
boxTop
boxRight
boxBottom
boxWidth
boxHeight
scrollWidth
scrollHeight
}
=
this
.
#
screenshotsContainer
.
getSelectionLayerDimensions
(
)
;
/
/
wait
until
all
4
if
elses
have
completed
before
setting
box
dimensions
if
(
boxWidth
<
=
lastBox
.
width
&
&
boxLeft
=
=
=
0
)
{
newLeft
=
boxRight
-
lastBox
.
width
;
}
else
{
newLeft
=
boxLeft
;
}
if
(
boxWidth
<
=
lastBox
.
width
&
&
boxRight
=
=
=
scrollWidth
)
{
newRight
=
boxLeft
+
lastBox
.
width
;
}
else
{
newRight
=
boxRight
;
}
if
(
boxHeight
<
=
lastBox
.
height
&
&
boxTop
=
=
=
0
)
{
newTop
=
boxBottom
-
lastBox
.
height
;
}
else
{
newTop
=
boxTop
;
}
if
(
boxHeight
<
=
lastBox
.
height
&
&
boxBottom
=
=
=
scrollHeight
)
{
newBottom
=
boxTop
+
lastBox
.
height
;
}
else
{
newBottom
=
boxBottom
;
}
this
.
#
screenshotsContainer
.
setSelectionBoxDimensions
(
{
left
:
newLeft
-
diffX
top
:
newTop
-
diffY
right
:
newRight
-
diffX
bottom
:
newBottom
-
diffY
}
)
;
this
.
#
lastX
=
clientX
;
this
.
#
lastY
=
clientY
;
break
;
}
}
this
.
#
screenshotsContainer
.
drawSelectionBox
(
)
;
}
/
*
*
*
Set
the
state
to
"
crosshairs
"
*
/
draggingReadyDragEnd
(
)
{
this
.
setState
(
"
crosshairs
"
)
;
}
/
*
*
*
Draw
the
box
one
last
time
and
set
the
state
to
"
selected
"
*
param
clientX
x
coordinate
*
param
clientY
y
coordinate
*
/
draggingDragEnd
(
clientX
clientY
)
{
this
.
#
screenshotsContainer
.
setSelectionBoxDimensions
(
{
right
:
clientX
bottom
:
clientY
}
)
;
this
.
#
screenshotsContainer
.
sortSelectionLayerBoxCoords
(
)
;
this
.
setState
(
"
selected
"
)
;
}
/
*
*
*
Draw
the
box
one
last
time
and
set
the
state
to
"
selected
"
*
param
clientX
x
coordinate
*
param
clientY
y
coordinate
*
/
resizingDragEnd
(
clientX
clientY
targetId
)
{
this
.
resizingDrag
(
clientX
clientY
targetId
)
;
this
.
#
screenshotsContainer
.
sortSelectionLayerBoxCoords
(
)
;
this
.
setState
(
"
selected
"
)
;
}
/
*
*
*
The
page
was
resized
or
scrolled
.
We
need
to
update
the
*
ScreenshotsContainer
size
so
we
don
'
t
draw
outside
the
window
bounds
*
If
the
current
state
is
"
selected
"
and
this
was
called
from
a
resize
event
*
then
we
need
to
maybe
shift
the
SelectionBox
*
param
win
The
window
object
of
the
page
*
param
eventType
If
this
was
called
from
a
resize
event
*
/
updateScreenshotsContainerSize
(
win
eventType
)
{
this
.
#
screenshotsContainer
.
updateSize
(
win
)
;
if
(
this
.
#
state
=
=
=
"
selected
"
&
&
eventType
=
=
=
"
resize
"
)
{
this
.
#
screenshotsContainer
.
shiftSelectionLayerBox
(
)
;
}
else
if
(
this
.
#
state
&
&
eventType
=
=
=
"
scroll
"
)
{
this
.
#
screenshotsContainer
.
drawButtonsLayer
(
)
;
}
}
}
class
AnonLayer
{
id
;
content
;
constructor
(
id
content
)
{
this
.
id
=
id
;
this
.
content
=
content
;
}
show
(
)
{
this
.
content
.
removeAttributeForElement
(
this
.
id
"
style
"
)
;
}
hide
(
)
{
this
.
content
.
setAttributeForElement
(
this
.
id
"
style
"
"
display
:
none
;
"
)
;
}
}
class
SelectionLayer
extends
AnonLayer
{
#
selectionBox
;
#
buttons
;
#
hidden
;
#
documentDimensions
;
constructor
(
id
content
)
{
super
(
id
content
)
;
this
.
#
selectionBox
=
new
SelectionBox
(
content
this
)
;
this
.
#
buttons
=
new
ButtonsLayer
(
"
buttons
"
content
this
)
;
this
.
#
hidden
=
true
;
this
.
#
documentDimensions
=
{
}
;
}
hideButtons
(
)
{
this
.
#
buttons
.
hide
(
)
;
}
drawButtonsLayer
(
)
{
this
.
#
buttons
.
show
(
)
;
}
hide
(
)
{
super
.
hide
(
)
;
this
.
#
hidden
=
true
;
}
drawSelectionBox
(
)
{
if
(
this
.
#
hidden
)
{
this
.
show
(
)
;
this
.
#
hidden
=
false
;
}
this
.
#
selectionBox
.
show
(
)
;
}
sortSelectionBoxCoords
(
)
{
this
.
#
selectionBox
.
sortCoords
(
)
;
}
setSelectionBoxDimensions
(
dims
)
{
if
(
dims
.
left
)
{
this
.
#
selectionBox
.
left
=
dims
.
left
;
}
if
(
dims
.
top
)
{
this
.
#
selectionBox
.
top
=
dims
.
top
;
}
if
(
dims
.
right
)
{
this
.
#
selectionBox
.
right
=
dims
.
right
;
}
if
(
dims
.
bottom
)
{
this
.
#
selectionBox
.
bottom
=
dims
.
bottom
;
}
}
getSelectionBoxDimensions
(
)
{
return
this
.
#
selectionBox
.
getDimensions
(
)
;
}
getDimensions
(
)
{
return
{
boxLeft
:
this
.
#
selectionBox
.
left
boxTop
:
this
.
#
selectionBox
.
top
boxRight
:
this
.
#
selectionBox
.
right
boxBottom
:
this
.
#
selectionBox
.
bottom
boxWidth
:
this
.
#
selectionBox
.
width
boxHeight
:
this
.
#
selectionBox
.
height
.
.
.
this
.
#
documentDimensions
}
;
}
getSelectionBoxDistance
(
)
{
return
this
.
#
selectionBox
.
distance
;
}
shiftSelectionBox
(
)
{
this
.
#
selectionBox
.
shiftBox
(
)
;
}
get
scrollWidth
(
)
{
return
this
.
#
documentDimensions
.
scrollWidth
;
}
set
scrollWidth
(
val
)
{
this
.
#
documentDimensions
.
scrollWidth
=
val
;
}
get
scrollHeight
(
)
{
return
this
.
#
documentDimensions
.
scrollHeight
;
}
set
scrollHeight
(
val
)
{
this
.
#
documentDimensions
.
scrollHeight
=
val
;
}
get
scrollX
(
)
{
return
this
.
#
documentDimensions
.
scrollX
;
}
set
scrollX
(
val
)
{
this
.
#
documentDimensions
.
scrollX
=
val
;
}
get
scrollY
(
)
{
return
this
.
#
documentDimensions
.
scrollY
;
}
set
scrollY
(
val
)
{
this
.
#
documentDimensions
.
scrollY
=
val
;
}
get
innerWidth
(
)
{
return
this
.
#
documentDimensions
.
innerWidth
;
}
set
innerWidth
(
val
)
{
this
.
#
documentDimensions
.
innerWidth
=
val
;
}
get
innerHeight
(
)
{
return
this
.
#
documentDimensions
.
innerHeight
;
}
set
innerHeight
(
val
)
{
this
.
#
documentDimensions
.
innerHeight
=
val
;
}
}
class
SelectionBox
extends
AnonLayer
{
#
x1
;
#
x2
;
#
y1
;
#
y2
;
#
xOffset
;
#
yOffset
;
#
selectionLayer
;
constructor
(
content
selectionLayer
)
{
super
(
"
"
content
)
;
this
.
#
selectionLayer
=
selectionLayer
;
this
.
#
x1
=
0
;
this
.
#
x2
=
0
;
this
.
#
y1
=
0
;
this
.
#
y2
=
0
;
this
.
#
xOffset
=
0
;
this
.
#
yOffset
=
0
;
}
show
(
)
{
this
.
content
.
setAttributeForElement
(
"
highlight
"
"
style
"
top
:
{
this
.
top
}
px
;
left
:
{
this
.
left
}
px
;
height
:
{
this
.
height
}
px
;
width
:
{
this
.
width
}
px
;
)
;
this
.
content
.
setAttributeForElement
(
"
bgTop
"
"
style
"
top
:
0px
;
height
:
{
this
.
top
}
px
;
left
:
0px
;
width
:
100
%
;
)
;
this
.
content
.
setAttributeForElement
(
"
bgBottom
"
"
style
"
top
:
{
this
.
bottom
}
px
;
height
:
calc
(
100
%
-
{
this
.
bottom
}
px
)
;
left
:
0px
;
width
:
100
%
;
)
;
this
.
content
.
setAttributeForElement
(
"
bgLeft
"
"
style
"
top
:
{
this
.
top
}
px
;
height
:
{
this
.
height
}
px
;
left
:
0px
;
width
:
{
this
.
left
}
px
;
)
;
this
.
content
.
setAttributeForElement
(
"
bgRight
"
"
style
"
top
:
{
this
.
top
}
px
;
height
:
{
this
.
height
}
px
;
left
:
{
this
.
right
}
px
;
width
:
calc
(
100
%
-
{
this
.
right
}
px
)
;
)
;
}
hide
(
)
{
this
.
content
.
setAttributeForElement
(
"
highlight
"
"
style
"
"
display
:
none
;
"
)
;
this
.
content
.
setAttributeForElement
(
"
bgTop
"
"
style
"
"
display
:
none
;
"
)
;
this
.
content
.
setAttributeForElement
(
"
bgBottom
"
"
style
"
"
display
:
none
;
"
)
;
this
.
content
.
setAttributeForElement
(
"
bgLeft
"
"
style
"
"
display
:
none
;
"
)
;
this
.
content
.
setAttributeForElement
(
"
bgRight
"
"
style
"
"
display
:
none
;
"
)
;
}
shiftBox
(
)
{
let
didShift
=
false
;
let
xDiff
=
this
.
right
-
this
.
#
selectionLayer
.
scrollWidth
;
if
(
xDiff
>
0
)
{
this
.
right
-
=
xDiff
;
this
.
left
-
=
xDiff
;
didShift
=
true
;
}
let
yDiff
=
this
.
bottom
-
this
.
#
selectionLayer
.
scrollHeight
;
if
(
yDiff
>
0
)
{
let
curWidth
=
this
.
width
;
this
.
bottom
-
=
yDiff
;
this
.
top
=
this
.
bottom
-
curWidth
;
didShift
=
true
;
}
if
(
didShift
)
{
this
.
show
(
)
;
this
.
#
selectionLayer
.
drawButtonsLayer
(
)
;
}
}
sortCoords
(
)
{
if
(
this
.
#
x1
>
this
.
#
x2
)
{
[
this
.
#
x1
this
.
#
x2
]
=
[
this
.
#
x2
this
.
#
x1
]
;
}
if
(
this
.
#
y1
>
this
.
#
y2
)
{
[
this
.
#
y1
this
.
#
y2
]
=
[
this
.
#
y2
this
.
#
y1
]
;
}
}
getDimensions
(
)
{
return
{
x1
:
this
.
left
y1
:
this
.
top
width
:
this
.
width
height
:
this
.
height
}
;
}
get
distance
(
)
{
return
Math
.
sqrt
(
Math
.
pow
(
this
.
width
2
)
+
Math
.
pow
(
this
.
height
2
)
)
;
}
get
xOffset
(
)
{
return
this
.
#
xOffset
;
}
set
xOffset
(
val
)
{
this
.
#
xOffset
=
val
;
}
get
yOffset
(
)
{
return
this
.
#
yOffset
;
}
set
yOffset
(
val
)
{
this
.
#
yOffset
=
val
;
}
get
top
(
)
{
return
Math
.
min
(
this
.
#
y1
this
.
#
y2
)
;
}
set
top
(
val
)
{
this
.
#
y1
=
val
>
0
?
val
:
0
;
}
get
left
(
)
{
return
Math
.
min
(
this
.
#
x1
this
.
#
x2
)
;
}
set
left
(
val
)
{
this
.
#
x1
=
val
>
0
?
val
:
0
;
}
get
right
(
)
{
return
Math
.
max
(
this
.
#
x1
this
.
#
x2
)
;
}
set
right
(
val
)
{
this
.
#
x2
=
val
>
this
.
#
selectionLayer
.
scrollWidth
?
this
.
#
selectionLayer
.
scrollWidth
:
val
;
}
get
bottom
(
)
{
return
Math
.
max
(
this
.
#
y1
this
.
#
y2
)
;
}
set
bottom
(
val
)
{
this
.
#
y2
=
val
>
this
.
#
selectionLayer
.
scrollHeight
?
this
.
#
selectionLayer
.
scrollHeight
:
val
;
}
get
width
(
)
{
return
Math
.
abs
(
this
.
#
x2
-
this
.
#
x1
)
;
}
get
height
(
)
{
return
Math
.
abs
(
this
.
#
y2
-
this
.
#
y1
)
;
}
}
class
ButtonsLayer
extends
AnonLayer
{
#
selectionLayer
;
constructor
(
id
content
selectionLayer
)
{
super
(
id
content
)
;
this
.
#
selectionLayer
=
selectionLayer
;
}
show
(
)
{
let
{
boxLeft
boxTop
boxRight
boxBottom
scrollX
scrollY
innerWidth
innerHeight
}
=
this
.
#
selectionLayer
.
getDimensions
(
)
;
if
(
boxTop
>
scrollY
+
innerHeight
|
|
boxBottom
<
scrollY
|
|
boxLeft
>
scrollX
+
innerWidth
|
|
boxRight
<
scrollX
)
{
return
;
}
let
top
=
boxBottom
;
let
leftOrRight
=
right
:
calc
(
100
%
-
{
boxRight
}
px
)
;
;
if
(
scrollY
+
innerHeight
-
boxBottom
<
70
)
{
if
(
boxBottom
<
scrollY
+
innerHeight
)
{
top
=
boxBottom
-
60
;
}
else
if
(
scrollY
+
innerHeight
-
boxTop
<
70
)
{
top
=
boxTop
-
60
;
}
else
{
top
=
scrollY
+
innerHeight
-
60
;
}
}
if
(
boxRight
<
265
)
{
leftOrRight
=
left
:
{
boxLeft
}
px
;
;
}
this
.
content
.
setAttributeForElement
(
"
buttons
"
"
style
"
top
:
{
top
}
px
;
{
leftOrRight
}
)
;
}
}
class
PreviewLayer
extends
AnonLayer
{
constructor
(
id
content
)
{
super
(
id
content
)
;
}
drawEyes
(
clientX
clientY
width
height
)
{
const
xpos
=
Math
.
floor
(
(
10
*
(
clientX
-
width
/
2
)
)
/
width
)
;
const
ypos
=
Math
.
floor
(
(
10
*
(
clientY
-
height
/
2
)
)
/
height
)
;
const
move
=
transform
:
translate
(
{
xpos
}
px
{
ypos
}
px
)
;
;
this
.
content
.
setAttributeForElement
(
"
left
-
eye
"
"
style
"
move
)
;
this
.
content
.
setAttributeForElement
(
"
right
-
eye
"
"
style
"
move
)
;
}
}
class
ScreenshotsContainerLayer
extends
AnonLayer
{
#
width
;
#
height
;
#
previewLayer
;
#
selectionLayer
;
constructor
(
id
content
previewLayer
selectionLayer
)
{
super
(
id
content
)
;
this
.
#
previewLayer
=
previewLayer
;
this
.
#
selectionLayer
=
selectionLayer
;
}
hideSelectionLayer
(
)
{
this
.
#
selectionLayer
.
hide
(
)
;
}
showPreviewLayer
(
)
{
this
.
#
previewLayer
.
show
(
)
;
}
hidePreviewLayer
(
)
{
this
.
#
previewLayer
.
hide
(
)
;
}
drawButtonsLayer
(
)
{
this
.
#
selectionLayer
.
drawButtonsLayer
(
)
;
}
hideButtonsLayer
(
)
{
this
.
#
selectionLayer
.
hideButtons
(
)
;
}
drawSelectionBox
(
)
{
this
.
#
selectionLayer
.
drawSelectionBox
(
)
;
}
drawPreviewEyes
(
clientX
clientY
)
{
this
.
#
previewLayer
.
drawEyes
(
clientX
-
this
.
#
selectionLayer
.
scrollX
clientY
-
this
.
#
selectionLayer
.
scrollY
this
.
#
selectionLayer
.
innerWidth
this
.
#
selectionLayer
.
innerHeight
)
;
}
selectionBoxDistance
(
)
{
return
this
.
#
selectionLayer
.
getSelectionBoxDistance
(
)
;
}
sortSelectionLayerBoxCoords
(
)
{
this
.
#
selectionLayer
.
sortSelectionBoxCoords
(
)
;
}
getSelectionLayerBoxDimensions
(
)
{
return
this
.
#
selectionLayer
.
getSelectionBoxDimensions
(
)
;
}
getSelectionLayerDimensions
(
)
{
return
this
.
#
selectionLayer
.
getDimensions
(
)
;
}
shiftSelectionLayerBox
(
)
{
this
.
#
selectionLayer
.
shiftSelectionBox
(
)
;
}
setSelectionBoxDimensions
(
boxDimensionObject
)
{
this
.
#
selectionLayer
.
setSelectionBoxDimensions
(
boxDimensionObject
)
;
}
updateSize
(
win
)
{
let
{
innerWidth
innerHeight
scrollX
scrollY
}
=
win
;
this
.
#
selectionLayer
.
innerWidth
=
innerWidth
;
this
.
#
selectionLayer
.
innerHeight
=
innerHeight
;
this
.
#
selectionLayer
.
scrollX
=
scrollX
;
this
.
#
selectionLayer
.
scrollY
=
scrollY
;
const
doc
=
win
.
document
.
documentElement
;
let
width
=
Math
.
max
.
apply
(
null
Array
.
from
(
doc
.
children
x
=
>
x
.
scrollWidth
)
)
;
let
height
=
Math
.
max
.
apply
(
null
Array
.
from
(
doc
.
children
x
=
>
x
.
scrollHeight
)
)
;
if
(
width
<
1
)
{
width
=
doc
.
scrollWidth
;
}
else
if
(
width
<
innerWidth
)
{
width
=
innerWidth
;
}
if
(
height
<
1
)
{
height
=
doc
.
scrollHeight
;
}
else
if
(
height
<
innerHeight
)
{
height
=
innerHeight
;
}
this
.
#
selectionLayer
.
scrollWidth
=
width
;
this
.
#
selectionLayer
.
scrollHeight
=
height
;
this
.
#
width
=
width
;
this
.
#
height
=
height
;
this
.
drawScreenshotsContainer
(
)
;
}
getDimension
(
)
{
return
{
width
:
this
.
#
width
height
:
this
.
#
height
}
;
}
drawScreenshotsContainer
(
)
{
this
.
content
.
setAttributeForElement
(
this
.
id
"
style
"
top
:
0
;
left
:
0
;
width
:
{
this
.
#
width
}
px
;
height
:
{
this
.
#
height
}
px
;
)
;
}
}
