"
use
strict
"
;
const
{
TelemetryTestUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
TelemetryTestUtils
.
sys
.
mjs
"
)
;
const
{
UrlbarTestUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
UrlbarTestUtils
.
sys
.
mjs
"
)
;
const
TEST_ROOT
=
getRootDirectory
(
gTestPath
)
.
replace
(
"
chrome
:
/
/
mochitests
/
content
"
"
https
:
/
/
example
.
com
"
)
;
const
TEST_PAGE
=
TEST_ROOT
+
"
test
-
page
.
html
"
;
const
SHORT_TEST_PAGE
=
TEST_ROOT
+
"
short
-
test
-
page
.
html
"
;
const
LARGE_TEST_PAGE
=
TEST_ROOT
+
"
large
-
test
-
page
.
html
"
;
const
{
MAX_CAPTURE_DIMENSION
MAX_CAPTURE_AREA
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
/
modules
/
ScreenshotsUtils
.
sys
.
mjs
"
)
;
const
gScreenshotUISelectors
=
{
panel
:
"
#
screenshotsPagePanel
"
fullPageButton
:
"
button
.
full
-
page
"
visiblePageButton
:
"
button
.
visible
-
page
"
copyButton
:
"
button
.
#
copy
"
}
;
const
MouseEvents
=
{
mouse
:
new
Proxy
(
{
}
{
get
:
(
target
name
)
=
>
async
function
(
x
y
options
=
{
}
)
{
if
(
name
=
=
=
"
click
"
)
{
this
.
down
(
x
y
options
)
;
this
.
up
(
x
y
options
)
;
}
else
{
await
safeSynthesizeMouseEventInContentPage
(
"
:
root
"
x
y
{
type
:
"
mouse
"
+
name
.
.
.
options
}
)
;
}
}
}
)
}
;
const
{
mouse
}
=
MouseEvents
;
class
ScreenshotsHelper
{
constructor
(
browser
)
{
this
.
browser
=
browser
;
this
.
selector
=
gScreenshotUISelectors
;
}
get
toolbarButton
(
)
{
return
this
.
browser
.
ownerDocument
.
getElementById
(
"
screenshot
-
button
"
)
;
}
get
panel
(
)
{
return
this
.
browser
.
ownerDocument
.
querySelector
(
this
.
selector
.
panel
)
;
}
triggerUIFromToolbar
(
)
{
let
button
=
this
.
toolbarButton
;
ok
(
BrowserTestUtils
.
isVisible
(
button
)
"
The
screenshot
toolbar
button
is
visible
"
)
;
button
.
click
(
)
;
}
async
getPanelButton
(
selector
)
{
let
panel
=
await
this
.
waitForPanel
(
)
;
let
screenshotsButtons
=
panel
.
querySelector
(
"
screenshots
-
buttons
"
)
;
ok
(
screenshotsButtons
"
Found
the
screenshots
-
buttons
"
)
;
let
button
=
screenshotsButtons
.
shadowRoot
.
querySelector
(
selector
)
;
ok
(
button
Found
{
selector
}
button
)
;
return
button
;
}
async
waitForPanel
(
)
{
let
panel
=
this
.
panel
;
await
BrowserTestUtils
.
waitForCondition
(
async
(
)
=
>
{
if
(
!
panel
)
{
panel
=
this
.
panel
;
}
return
panel
&
&
BrowserTestUtils
.
isVisible
(
panel
)
;
}
)
;
return
panel
;
}
async
waitForOverlay
(
)
{
const
panel
=
await
this
.
waitForPanel
(
)
;
ok
(
BrowserTestUtils
.
isVisible
(
panel
)
"
Panel
buttons
are
visible
"
)
;
await
BrowserTestUtils
.
waitForCondition
(
async
(
)
=
>
{
let
init
=
await
this
.
isOverlayInitialized
(
)
;
return
init
;
}
)
;
info
(
"
Overlay
is
visible
"
)
;
}
async
waitForPanelClosed
(
)
{
let
panel
=
this
.
panel
;
if
(
!
panel
)
{
info
(
"
waitForPanelClosed
:
Panel
doesnt
exist
"
)
;
return
;
}
if
(
panel
.
hidden
)
{
info
(
"
waitForPanelClosed
:
panel
is
already
hidden
"
)
;
return
;
}
info
(
"
waitForPanelClosed
:
waiting
for
the
panel
to
become
hidden
"
)
;
await
BrowserTestUtils
.
waitForMutationCondition
(
panel
{
attributes
:
true
}
(
)
=
>
{
return
BrowserTestUtils
.
isHidden
(
panel
)
;
}
)
;
ok
(
BrowserTestUtils
.
isHidden
(
panel
)
"
Panel
buttons
are
hidden
"
)
;
info
(
"
waitForPanelClosed
panel
is
hidden
:
"
+
panel
.
hidden
)
;
}
async
waitForOverlayClosed
(
)
{
await
this
.
waitForPanelClosed
(
)
;
await
BrowserTestUtils
.
waitForCondition
(
async
(
)
=
>
{
let
init
=
!
(
await
this
.
isOverlayInitialized
(
)
)
;
info
(
"
Is
overlay
initialized
:
"
+
!
init
)
;
return
init
;
}
)
;
info
(
"
Overlay
is
not
visible
"
)
;
}
async
isOverlayInitialized
(
)
{
return
SpecialPowers
.
spawn
(
this
.
browser
[
]
(
)
=
>
{
let
screenshotsChild
=
content
.
windowGlobalChild
.
getActor
(
"
ScreenshotsComponent
"
)
;
return
screenshotsChild
?
.
overlay
?
.
initialized
;
}
)
;
}
async
getOverlayState
(
)
{
return
ContentTask
.
spawn
(
this
.
browser
null
async
(
)
=
>
{
let
screenshotsChild
=
content
.
windowGlobalChild
.
getActor
(
"
ScreenshotsComponent
"
)
;
return
screenshotsChild
.
overlay
.
state
;
}
)
;
}
async
waitForStateChange
(
newState
)
{
return
BrowserTestUtils
.
waitForCondition
(
async
(
)
=
>
{
let
state
=
await
this
.
getOverlayState
(
)
;
return
state
=
=
=
newState
?
state
:
"
"
;
}
Waiting
for
state
change
to
{
newState
}
)
;
}
async
assertStateChange
(
newState
)
{
let
currentState
=
await
this
.
waitForStateChange
(
newState
)
;
is
(
currentState
newState
The
current
state
is
{
currentState
}
expected
{
newState
}
)
;
}
getHoverElementRect
(
)
{
return
ContentTask
.
spawn
(
this
.
browser
null
async
(
)
=
>
{
let
screenshotsChild
=
content
.
windowGlobalChild
.
getActor
(
"
ScreenshotsComponent
"
)
;
return
screenshotsChild
.
overlay
.
hoverElementRegion
.
dimensions
;
}
)
;
}
isHoverElementRegionValid
(
)
{
return
ContentTask
.
spawn
(
this
.
browser
null
async
(
)
=
>
{
let
screenshotsChild
=
content
.
windowGlobalChild
.
getActor
(
"
ScreenshotsComponent
"
)
;
return
screenshotsChild
.
overlay
.
hoverElementRegion
.
isRegionValid
;
}
)
;
}
async
waitForHoverElementRect
(
)
{
return
TestUtils
.
waitForCondition
(
async
(
)
=
>
{
let
rect
=
await
this
.
getHoverElementRect
(
)
;
return
rect
;
}
)
;
}
async
waitForSelectionRegionSizeChange
(
currentWidth
)
{
await
ContentTask
.
spawn
(
this
.
browser
[
currentWidth
]
async
(
[
currWidth
]
)
=
>
{
let
screenshotsChild
=
content
.
windowGlobalChild
.
getActor
(
"
ScreenshotsComponent
"
)
;
let
dimensions
=
screenshotsChild
.
overlay
.
selectionRegion
.
dimensions
;
await
ContentTaskUtils
.
waitForCondition
(
(
)
=
>
{
dimensions
=
screenshotsChild
.
overlay
.
selectionRegion
.
dimensions
;
return
dimensions
.
width
!
=
=
currWidth
;
}
"
Wait
for
selection
box
width
change
"
)
;
}
)
;
}
async
dragOverlay
(
startX
startY
endX
endY
expectedStartingState
=
"
crosshairs
"
)
{
await
this
.
assertStateChange
(
expectedStartingState
)
;
mouse
.
down
(
startX
startY
)
;
await
Promise
.
any
(
[
this
.
waitForStateChange
(
"
draggingReady
"
)
this
.
waitForStateChange
(
"
resizing
"
)
]
)
;
Assert
.
ok
(
true
"
The
overlay
is
in
the
draggingReady
or
resizing
state
"
)
;
mouse
.
move
(
endX
endY
)
;
await
Promise
.
any
(
[
this
.
waitForStateChange
(
"
dragging
"
)
this
.
waitForStateChange
(
"
resizing
"
)
]
)
;
Assert
.
ok
(
true
"
The
overlay
is
in
the
dragging
or
resizing
state
"
)
;
mouse
.
up
(
endX
endY
)
;
await
this
.
assertStateChange
(
"
selected
"
)
;
this
.
endX
=
endX
;
this
.
endY
=
endY
;
}
async
scrollContentWindow
(
x
y
)
{
let
promise
=
BrowserTestUtils
.
waitForContentEvent
(
this
.
browser
"
scroll
"
)
;
await
ContentTask
.
spawn
(
this
.
browser
[
x
y
]
async
(
[
xPos
yPos
]
)
=
>
{
content
.
window
.
scroll
(
xPos
yPos
)
;
await
ContentTaskUtils
.
waitForCondition
(
(
)
=
>
{
return
(
content
.
window
.
scrollX
=
=
=
xPos
&
&
content
.
window
.
scrollY
=
=
=
yPos
)
;
}
Waiting
for
window
to
scroll
to
{
xPos
}
{
yPos
}
)
;
}
)
;
await
promise
;
}
async
waitForScrollTo
(
x
y
)
{
await
ContentTask
.
spawn
(
this
.
browser
[
x
y
]
async
(
[
xPos
yPos
]
)
=
>
{
await
ContentTaskUtils
.
waitForCondition
(
(
)
=
>
{
info
(
Got
scrollX
:
{
content
.
window
.
scrollX
}
.
scrollY
:
{
content
.
window
.
scrollY
}
)
;
return
(
content
.
window
.
scrollX
=
=
=
xPos
&
&
content
.
window
.
scrollY
=
=
=
yPos
)
;
}
Waiting
for
window
to
scroll
to
{
xPos
}
{
yPos
}
)
;
}
)
;
}
async
clickDownloadButton
(
)
{
let
{
centerX
:
x
centerY
:
y
}
=
await
ContentTask
.
spawn
(
this
.
browser
null
async
(
)
=
>
{
let
screenshotsChild
=
content
.
windowGlobalChild
.
getActor
(
"
ScreenshotsComponent
"
)
;
let
{
left
top
width
height
}
=
screenshotsChild
.
overlay
.
downloadButton
.
getBoundingClientRect
(
)
;
let
centerX
=
left
+
width
/
2
;
let
centerY
=
top
+
height
/
2
;
return
{
centerX
centerY
}
;
}
)
;
info
(
clicking
download
button
at
{
x
}
{
y
}
)
;
mouse
.
click
(
x
y
)
;
}
async
clickCopyButton
(
)
{
let
{
centerX
:
x
centerY
:
y
}
=
await
ContentTask
.
spawn
(
this
.
browser
null
async
(
)
=
>
{
let
screenshotsChild
=
content
.
windowGlobalChild
.
getActor
(
"
ScreenshotsComponent
"
)
;
let
{
left
top
width
height
}
=
screenshotsChild
.
overlay
.
copyButton
.
getBoundingClientRect
(
)
;
let
centerX
=
left
+
width
/
2
;
let
centerY
=
top
+
height
/
2
;
return
{
centerX
centerY
}
;
}
)
;
info
(
clicking
copy
button
at
{
x
}
{
y
}
)
;
mouse
.
click
(
x
y
)
;
}
async
clickCancelButton
(
)
{
let
{
centerX
:
x
centerY
:
y
}
=
await
ContentTask
.
spawn
(
this
.
browser
null
async
(
)
=
>
{
let
screenshotsChild
=
content
.
windowGlobalChild
.
getActor
(
"
ScreenshotsComponent
"
)
;
let
{
left
top
width
height
}
=
screenshotsChild
.
overlay
.
cancelButton
.
getBoundingClientRect
(
)
;
let
centerX
=
left
+
width
/
2
;
let
centerY
=
top
+
height
/
2
;
return
{
centerX
centerY
}
;
}
)
;
info
(
clicking
cancel
button
at
{
x
}
{
y
}
)
;
mouse
.
click
(
x
y
)
;
}
async
clickPreviewCancelButton
(
)
{
let
{
centerX
:
x
centerY
:
y
}
=
await
ContentTask
.
spawn
(
this
.
browser
null
async
(
)
=
>
{
let
screenshotsChild
=
content
.
windowGlobalChild
.
getActor
(
"
ScreenshotsComponent
"
)
;
let
{
left
top
width
height
}
=
screenshotsChild
.
overlay
.
previewCancelButton
.
getBoundingClientRect
(
)
;
let
centerX
=
left
+
width
/
2
;
let
centerY
=
top
+
height
/
2
;
return
{
centerX
centerY
}
;
}
)
;
info
(
clicking
cancel
button
at
{
x
}
{
y
}
)
;
mouse
.
click
(
x
y
)
;
}
getTestPageElementRect
(
)
{
return
ContentTask
.
spawn
(
this
.
browser
[
]
async
(
)
=
>
{
let
ele
=
content
.
document
.
getElementById
(
"
testPageElement
"
)
;
return
ele
.
getBoundingClientRect
(
)
;
}
)
;
}
async
clickTestPageElement
(
)
{
let
rect
=
await
this
.
getTestPageElementRect
(
)
;
let
x
=
Math
.
floor
(
rect
.
x
+
rect
.
width
/
2
)
;
let
y
=
Math
.
floor
(
rect
.
y
+
rect
.
height
/
2
)
;
mouse
.
move
(
x
y
)
;
await
this
.
waitForHoverElementRect
(
)
;
mouse
.
down
(
x
y
)
;
await
this
.
assertStateChange
(
"
draggingReady
"
)
;
mouse
.
up
(
x
y
)
;
await
this
.
assertStateChange
(
"
selected
"
)
;
}
async
zoomBrowser
(
zoom
)
{
await
SpecialPowers
.
spawn
(
this
.
browser
[
zoom
]
zoomLevel
=
>
{
const
{
Layout
}
=
ChromeUtils
.
importESModule
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
accessible
/
tests
/
browser
/
Layout
.
sys
.
mjs
"
)
;
Layout
.
zoomDocument
(
content
.
document
zoomLevel
)
;
}
)
;
}
getDialog
(
)
{
let
currDialogBox
=
this
.
browser
.
tabDialogBox
;
let
manager
=
currDialogBox
.
getTabDialogManager
(
)
;
let
dialogs
=
manager
.
hasDialogs
&
&
manager
.
dialogs
;
return
dialogs
[
0
]
;
}
assertPanelVisible
(
)
{
info
(
"
assertPanelVisible
panel
.
hidden
:
"
+
this
.
panel
?
.
hidden
)
;
Assert
.
ok
(
BrowserTestUtils
.
isVisible
(
this
.
panel
)
"
Screenshots
panel
is
visible
"
)
;
}
assertPanelNotVisible
(
)
{
info
(
"
assertPanelNotVisible
panel
.
hidden
:
"
+
this
.
panel
?
.
hidden
)
;
Assert
.
ok
(
!
this
.
panel
|
|
BrowserTestUtils
.
isHidden
(
this
.
panel
)
"
Screenshots
panel
is
not
visible
"
)
;
}
waitForRawClipboardChange
(
epectedWidth
expectedHeight
)
{
const
initialClipboardData
=
Date
.
now
(
)
.
toString
(
)
;
SpecialPowers
.
clipboardCopyString
(
initialClipboardData
)
;
return
TestUtils
.
waitForCondition
(
async
(
)
=
>
{
let
data
;
try
{
data
=
await
this
.
getImageSizeAndColorFromClipboard
(
)
;
}
catch
(
e
)
{
console
.
log
(
"
Failed
to
get
image
/
png
clipboard
data
:
"
e
)
;
return
false
;
}
if
(
data
&
&
initialClipboardData
!
=
=
data
&
&
data
.
height
=
=
=
expectedHeight
&
&
data
.
width
=
=
=
epectedWidth
)
{
return
data
;
}
return
false
;
}
"
Waiting
for
screenshot
to
copy
to
clipboard
"
200
)
;
}
getContentDimensions
(
)
{
return
SpecialPowers
.
spawn
(
this
.
browser
[
]
async
function
(
)
{
let
{
innerWidth
innerHeight
scrollMaxX
scrollMaxY
scrollX
scrollY
}
=
content
.
window
;
let
width
=
innerWidth
+
scrollMaxX
;
let
height
=
innerHeight
+
scrollMaxY
;
const
scrollbarHeight
=
{
}
;
const
scrollbarWidth
=
{
}
;
content
.
window
.
windowUtils
.
getScrollbarSize
(
false
scrollbarWidth
scrollbarHeight
)
;
width
-
=
scrollbarWidth
.
value
;
height
-
=
scrollbarHeight
.
value
;
innerWidth
-
=
scrollbarWidth
.
value
;
innerHeight
-
=
scrollbarHeight
.
value
;
return
{
clientHeight
:
innerHeight
clientWidth
:
innerWidth
scrollHeight
:
height
scrollWidth
:
width
scrollX
scrollY
}
;
}
)
;
}
getScreenshotsOverlayDimensions
(
)
{
return
ContentTask
.
spawn
(
this
.
browser
null
async
(
)
=
>
{
let
screenshotsChild
=
content
.
windowGlobalChild
.
getActor
(
"
ScreenshotsComponent
"
)
;
Assert
.
ok
(
screenshotsChild
.
overlay
.
initialized
"
The
overlay
exists
"
)
;
return
{
scrollWidth
:
screenshotsChild
.
overlay
.
screenshotsContainer
.
scrollWidth
scrollHeight
:
screenshotsChild
.
overlay
.
screenshotsContainer
.
scrollHeight
}
;
}
)
;
}
async
waitForSelectionLayerDimensionChange
(
oldWidth
oldHeight
)
{
await
ContentTask
.
spawn
(
this
.
browser
[
oldWidth
oldHeight
]
async
(
[
prevWidth
prevHeight
]
)
=
>
{
let
screenshotsChild
=
content
.
windowGlobalChild
.
getActor
(
"
ScreenshotsComponent
"
)
;
await
ContentTaskUtils
.
waitForCondition
(
(
)
=
>
{
let
screenshotsContainer
=
screenshotsChild
.
overlay
.
screenshotsContainer
;
info
(
old
height
:
{
prevHeight
}
.
new
height
:
{
screenshotsContainer
.
scrollHeight
}
.
\
nold
width
:
{
prevWidth
}
.
new
width
:
{
screenshotsContainer
.
scrollWidth
}
)
;
return
(
screenshotsContainer
.
scrollHeight
!
=
=
prevHeight
&
&
screenshotsContainer
.
scrollWidth
!
=
=
prevWidth
)
;
}
"
Wait
for
selection
box
width
change
"
)
;
}
)
;
}
getSelectionRegionDimensions
(
)
{
return
ContentTask
.
spawn
(
this
.
browser
null
async
(
)
=
>
{
let
screenshotsChild
=
content
.
windowGlobalChild
.
getActor
(
"
ScreenshotsComponent
"
)
;
Assert
.
ok
(
screenshotsChild
.
overlay
.
initialized
"
The
overlay
exists
"
)
;
return
screenshotsChild
.
overlay
.
selectionRegion
.
dimensions
;
}
)
;
}
async
getImageSizeAndColorFromClipboard
(
)
{
let
flavor
=
"
image
/
png
"
;
let
image
=
getRawClipboardData
(
flavor
)
;
if
(
!
image
)
{
return
false
;
}
if
(
image
instanceof
Ci
.
imgIContainer
)
{
image
=
Cc
[
"
mozilla
.
org
/
image
/
tools
;
1
"
]
.
getService
(
Ci
.
imgITools
)
.
encodeImage
(
image
flavor
)
;
}
if
(
!
(
image
instanceof
Ci
.
nsIInputStream
)
)
{
throw
new
Error
(
"
Unable
to
read
image
data
"
)
;
}
const
binaryStream
=
Cc
[
"
mozilla
.
org
/
binaryinputstream
;
1
"
]
.
createInstance
(
Ci
.
nsIBinaryInputStream
)
;
binaryStream
.
setInputStream
(
image
)
;
const
available
=
binaryStream
.
available
(
)
;
const
buffer
=
new
ArrayBuffer
(
available
)
;
info
(
{
binaryStream
.
readArrayBuffer
(
available
buffer
)
}
read
{
available
}
available
)
;
return
SpecialPowers
.
spawn
(
this
.
browser
[
buffer
]
async
function
(
_buffer
)
{
const
img
=
content
.
document
.
createElement
(
"
img
"
)
;
const
loaded
=
new
Promise
(
r
=
>
{
img
.
addEventListener
(
"
load
"
r
{
once
:
true
}
)
;
}
)
;
const
url
=
content
.
URL
.
createObjectURL
(
new
Blob
(
[
_buffer
]
{
type
:
"
image
/
png
"
}
)
)
;
img
.
src
=
url
;
content
.
document
.
documentElement
.
appendChild
(
img
)
;
info
(
"
Waiting
for
the
clipboard
image
to
load
in
the
content
page
"
)
;
await
loaded
;
let
canvas
=
content
.
document
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
"
html
:
canvas
"
)
;
let
context
=
canvas
.
getContext
(
"
2d
"
)
;
canvas
.
width
=
img
.
width
;
canvas
.
height
=
img
.
height
;
context
.
drawImage
(
img
0
0
)
;
let
topLeft
=
context
.
getImageData
(
0
0
1
1
)
;
let
topRight
=
context
.
getImageData
(
img
.
width
-
1
0
1
1
)
;
let
bottomLeft
=
context
.
getImageData
(
0
img
.
height
-
1
1
1
)
;
let
bottomRight
=
context
.
getImageData
(
img
.
width
-
1
img
.
height
-
1
1
1
)
;
img
.
remove
(
)
;
content
.
URL
.
revokeObjectURL
(
url
)
;
return
{
width
:
img
.
width
height
:
img
.
height
color
:
{
topLeft
:
topLeft
.
data
topRight
:
topRight
.
data
bottomLeft
:
bottomLeft
.
data
bottomRight
:
bottomRight
.
data
}
}
;
}
)
;
}
}
function
getRawClipboardData
(
flavor
)
{
const
whichClipboard
=
Services
.
clipboard
.
kGlobalClipboard
;
const
xferable
=
Cc
[
"
mozilla
.
org
/
widget
/
transferable
;
1
"
]
.
createInstance
(
Ci
.
nsITransferable
)
;
xferable
.
init
(
null
)
;
xferable
.
addDataFlavor
(
flavor
)
;
Services
.
clipboard
.
getData
(
xferable
whichClipboard
)
;
let
data
=
{
}
;
try
{
xferable
.
getAnyTransferData
(
{
}
data
)
;
info
(
JSON
.
stringify
(
data
null
2
)
)
;
}
catch
(
e
)
{
info
(
e
)
;
}
data
=
data
.
value
|
|
null
;
return
data
;
}
async
function
safeSynthesizeMouseEventInContentPage
(
selector
x
y
options
=
{
}
)
{
let
context
=
gBrowser
.
selectedBrowser
.
browsingContext
;
BrowserTestUtils
.
synthesizeMouse
(
selector
x
y
options
context
)
;
}
add_setup
(
async
(
)
=
>
{
CustomizableUI
.
addWidgetToArea
(
"
screenshot
-
button
"
CustomizableUI
.
AREA_NAVBAR
)
;
let
screenshotBtn
=
document
.
getElementById
(
"
screenshot
-
button
"
)
;
Assert
.
ok
(
screenshotBtn
"
The
screenshots
button
was
added
to
the
nav
bar
"
)
;
}
)
;
function
getContentDevicePixelRatio
(
browser
)
{
return
SpecialPowers
.
spawn
(
browser
[
]
async
function
(
)
{
return
content
.
window
.
devicePixelRatio
;
}
)
;
}
async
function
clearAllTelemetryEvents
(
)
{
info
(
"
Clearing
all
telemetry
events
"
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
{
Services
.
telemetry
.
clearEvents
(
)
;
let
events
=
Services
.
telemetry
.
snapshotEvents
(
Ci
.
nsITelemetry
.
DATASET_PRERELEASE_CHANNELS
true
)
;
let
content
=
events
.
content
;
let
parent
=
events
.
parent
;
return
(
!
content
&
&
!
parent
)
|
|
(
!
content
.
length
&
&
!
parent
.
length
)
;
}
)
;
}
async
function
waitForScreenshotsEventCount
(
count
process
=
"
parent
"
)
{
await
TestUtils
.
waitForCondition
(
(
)
=
>
{
let
events
=
TelemetryTestUtils
.
getEvents
(
{
category
:
"
screenshots
"
}
{
process
}
)
;
info
(
Got
{
events
?
.
length
}
event
(
s
)
)
;
info
(
Actual
events
:
{
JSON
.
stringify
(
events
null
2
)
}
)
;
return
events
.
length
=
=
=
count
?
events
:
null
;
}
Waiting
for
{
count
}
{
process
}
event
(
s
)
.
200
100
)
;
}
async
function
assertScreenshotsEvents
(
expectedEvents
process
=
"
parent
"
clearEvents
=
true
)
{
info
(
Expected
events
:
{
JSON
.
stringify
(
expectedEvents
null
2
)
}
)
;
await
waitForScreenshotsEventCount
(
expectedEvents
.
length
process
)
;
TelemetryTestUtils
.
assertEvents
(
expectedEvents
{
category
:
"
screenshots
"
}
{
clear
:
clearEvents
process
}
)
;
}
