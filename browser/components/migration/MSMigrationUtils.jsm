"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
MSMigrationUtils
"
]
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
/
modules
/
MigrationUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
LoginHelper
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PlacesUtils
"
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
WindowsRegistry
"
"
resource
:
/
/
gre
/
modules
/
WindowsRegistry
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
ctypes
"
"
resource
:
/
/
gre
/
modules
/
ctypes
.
jsm
"
)
;
const
EDGE_COOKIE_PATH_OPTIONS
=
[
"
"
"
#
!
001
\
\
"
"
#
!
002
\
\
"
]
;
const
EDGE_COOKIES_SUFFIX
=
"
MicrosoftEdge
\
\
Cookies
"
;
const
EDGE_FAVORITES
=
"
AC
\
\
MicrosoftEdge
\
\
User
\
\
Default
\
\
Favorites
"
;
const
EDGE_READINGLIST
=
"
AC
\
\
MicrosoftEdge
\
\
User
\
\
Default
\
\
DataStore
\
\
Data
\
\
"
;
const
FREE_CLOSE_FAILED
=
0
;
const
INTERNET_EXPLORER_EDGE_GUID
=
[
0x3CCD5499
0x4B1087A8
0x886015A2
0x553BDD88
]
;
const
RESULT_SUCCESS
=
0
;
const
VAULT_ENUMERATE_ALL_ITEMS
=
512
;
const
WEB_CREDENTIALS_VAULT_ID
=
[
0x4BF4C442
0x41A09B8A
0x4ADD80B3
0x28DB4D70
]
;
Cu
.
importGlobalProperties
(
[
"
File
"
]
)
;
const
wintypes
=
{
BOOL
:
ctypes
.
int
DWORD
:
ctypes
.
uint32_t
DWORDLONG
:
ctypes
.
uint64_t
CHAR
:
ctypes
.
char
PCHAR
:
ctypes
.
char
.
ptr
LPCWSTR
:
ctypes
.
char16_t
.
ptr
PDWORD
:
ctypes
.
uint32_t
.
ptr
VOIDP
:
ctypes
.
voidptr_t
WORD
:
ctypes
.
uint16_t
}
function
CtypesKernelHelpers
(
)
{
this
.
_structs
=
{
}
;
this
.
_functions
=
{
}
;
this
.
_libs
=
{
}
;
this
.
_structs
.
SYSTEMTIME
=
new
ctypes
.
StructType
(
"
SYSTEMTIME
"
[
{
wYear
:
wintypes
.
WORD
}
{
wMonth
:
wintypes
.
WORD
}
{
wDayOfWeek
:
wintypes
.
WORD
}
{
wDay
:
wintypes
.
WORD
}
{
wHour
:
wintypes
.
WORD
}
{
wMinute
:
wintypes
.
WORD
}
{
wSecond
:
wintypes
.
WORD
}
{
wMilliseconds
:
wintypes
.
WORD
}
]
)
;
this
.
_structs
.
FILETIME
=
new
ctypes
.
StructType
(
"
FILETIME
"
[
{
dwLowDateTime
:
wintypes
.
DWORD
}
{
dwHighDateTime
:
wintypes
.
DWORD
}
]
)
;
try
{
this
.
_libs
.
kernel32
=
ctypes
.
open
(
"
Kernel32
"
)
;
this
.
_functions
.
FileTimeToSystemTime
=
this
.
_libs
.
kernel32
.
declare
(
"
FileTimeToSystemTime
"
ctypes
.
default_abi
wintypes
.
BOOL
this
.
_structs
.
FILETIME
.
ptr
this
.
_structs
.
SYSTEMTIME
.
ptr
)
;
}
catch
(
ex
)
{
this
.
finalize
(
)
;
}
}
CtypesKernelHelpers
.
prototype
=
{
finalize
(
)
{
this
.
_structs
=
{
}
;
this
.
_functions
=
{
}
;
for
each
(
let
lib
in
this
.
_libs
)
{
try
{
lib
.
close
(
)
;
}
catch
(
ex
)
{
}
}
this
.
_libs
=
{
}
;
}
fileTimeToSecondsSinceEpoch
(
aTimeHi
aTimeLo
)
{
let
fileTime
=
this
.
_structs
.
FILETIME
(
)
;
fileTime
.
dwLowDateTime
=
aTimeLo
;
fileTime
.
dwHighDateTime
=
aTimeHi
;
let
systemTime
=
this
.
_structs
.
SYSTEMTIME
(
)
;
let
result
=
this
.
_functions
.
FileTimeToSystemTime
(
fileTime
.
address
(
)
systemTime
.
address
(
)
)
;
if
(
result
=
=
0
)
throw
new
Error
(
ctypes
.
winLastError
)
;
return
Math
.
floor
(
Date
.
UTC
(
systemTime
.
wYear
systemTime
.
wMonth
-
1
systemTime
.
wDay
systemTime
.
wHour
systemTime
.
wMinute
systemTime
.
wSecond
systemTime
.
wMilliseconds
)
/
1000
)
;
}
}
;
function
CtypesVaultHelpers
(
)
{
this
.
_structs
=
{
}
;
this
.
_functions
=
{
}
;
if
(
wintypes
.
VOIDP
.
size
=
=
4
)
{
this
.
_vaultHandleType
=
wintypes
.
DWORD
;
}
else
{
this
.
_vaultHandleType
=
wintypes
.
DWORDLONG
;
}
this
.
_structs
.
GUID
=
new
ctypes
.
StructType
(
"
GUID
"
[
{
id
:
wintypes
.
DWORD
.
array
(
4
)
}
]
)
;
this
.
_structs
.
VAULT_ITEM_ELEMENT
=
new
ctypes
.
StructType
(
"
VAULT_ITEM_ELEMENT
"
[
{
schemaElementId
:
wintypes
.
DWORD
}
{
unknown1
:
wintypes
.
DWORD
}
{
type
:
wintypes
.
DWORD
}
{
unknown2
:
wintypes
.
DWORD
}
{
itemValue
:
wintypes
.
LPCWSTR
}
{
unknown3
:
wintypes
.
CHAR
.
array
(
12
)
}
]
)
;
this
.
_structs
.
VAULT_ELEMENT
=
new
ctypes
.
StructType
(
"
VAULT_ELEMENT
"
[
{
schemaId
:
this
.
_structs
.
GUID
}
{
pszCredentialFriendlyName
:
wintypes
.
LPCWSTR
}
{
pResourceElement
:
this
.
_structs
.
VAULT_ITEM_ELEMENT
.
ptr
}
{
pIdentityElement
:
this
.
_structs
.
VAULT_ITEM_ELEMENT
.
ptr
}
{
pAuthenticatorElement
:
this
.
_structs
.
VAULT_ITEM_ELEMENT
.
ptr
}
{
pPackageSid
:
this
.
_structs
.
VAULT_ITEM_ELEMENT
.
ptr
}
{
lowLastModified
:
wintypes
.
DWORD
}
{
highLastModified
:
wintypes
.
DWORD
}
{
flags
:
wintypes
.
DWORD
}
{
dwPropertiesCount
:
wintypes
.
DWORD
}
{
pPropertyElements
:
this
.
_structs
.
VAULT_ITEM_ELEMENT
.
ptr
}
]
)
;
try
{
this
.
_vaultcliLib
=
ctypes
.
open
(
"
vaultcli
.
dll
"
)
;
this
.
_functions
.
VaultOpenVault
=
this
.
_vaultcliLib
.
declare
(
"
VaultOpenVault
"
ctypes
.
winapi_abi
wintypes
.
DWORD
this
.
_structs
.
GUID
.
ptr
wintypes
.
DWORD
this
.
_vaultHandleType
.
ptr
)
;
this
.
_functions
.
VaultEnumerateItems
=
this
.
_vaultcliLib
.
declare
(
"
VaultEnumerateItems
"
ctypes
.
winapi_abi
wintypes
.
DWORD
this
.
_vaultHandleType
wintypes
.
DWORD
wintypes
.
PDWORD
ctypes
.
voidptr_t
)
;
this
.
_functions
.
VaultCloseVault
=
this
.
_vaultcliLib
.
declare
(
"
VaultCloseVault
"
ctypes
.
winapi_abi
wintypes
.
DWORD
this
.
_vaultHandleType
)
;
this
.
_functions
.
VaultGetItem
=
this
.
_vaultcliLib
.
declare
(
"
VaultGetItem
"
ctypes
.
winapi_abi
wintypes
.
DWORD
this
.
_vaultHandleType
this
.
_structs
.
GUID
.
ptr
this
.
_structs
.
VAULT_ITEM_ELEMENT
.
ptr
this
.
_structs
.
VAULT_ITEM_ELEMENT
.
ptr
this
.
_structs
.
VAULT_ITEM_ELEMENT
.
ptr
wintypes
.
DWORD
wintypes
.
DWORD
this
.
_structs
.
VAULT_ELEMENT
.
ptr
.
ptr
)
;
this
.
_functions
.
VaultFree
=
this
.
_vaultcliLib
.
declare
(
"
VaultFree
"
ctypes
.
winapi_abi
wintypes
.
DWORD
this
.
_structs
.
VAULT_ELEMENT
.
ptr
)
;
}
catch
(
ex
)
{
this
.
finalize
(
)
;
}
}
CtypesVaultHelpers
.
prototype
=
{
finalize
(
)
{
this
.
_structs
=
{
}
;
this
.
_functions
=
{
}
;
try
{
this
.
_vaultcliLib
.
close
(
)
;
}
catch
(
ex
)
{
}
this
.
_vaultcliLib
=
null
;
}
}
function
hostIsIPAddress
(
aHost
)
{
try
{
Services
.
eTLD
.
getBaseDomainFromHost
(
aHost
)
;
}
catch
(
e
if
e
.
result
=
=
Cr
.
NS_ERROR_HOST_IS_IP_ADDRESS
)
{
return
true
;
}
catch
(
e
)
{
}
return
false
;
}
var
gEdgeDir
;
function
getEdgeLocalDataFolder
(
)
{
if
(
gEdgeDir
)
{
return
gEdgeDir
.
clone
(
)
;
}
let
packages
=
Services
.
dirsvc
.
get
(
"
LocalAppData
"
Ci
.
nsIFile
)
;
packages
.
append
(
"
Packages
"
)
;
let
edgeDir
=
packages
.
clone
(
)
;
edgeDir
.
append
(
"
Microsoft
.
MicrosoftEdge_8wekyb3d8bbwe
"
)
;
try
{
if
(
edgeDir
.
exists
(
)
&
&
edgeDir
.
isReadable
(
)
&
&
edgeDir
.
isDirectory
(
)
)
{
gEdgeDir
=
edgeDir
;
return
edgeDir
.
clone
(
)
;
}
let
dirEntries
=
packages
.
directoryEntries
;
while
(
dirEntries
.
hasMoreElements
(
)
)
{
let
subDir
=
dirEntries
.
getNext
(
)
;
subDir
.
QueryInterface
(
Ci
.
nsIFile
)
;
if
(
subDir
.
leafName
.
startsWith
(
"
Microsoft
.
MicrosoftEdge
"
)
&
&
subDir
.
isReadable
(
)
&
&
subDir
.
isDirectory
(
)
)
{
gEdgeDir
=
subDir
;
return
subDir
.
clone
(
)
;
}
}
}
catch
(
ex
)
{
Cu
.
reportError
(
"
Exception
trying
to
find
the
Edge
favorites
directory
:
"
+
ex
)
;
}
return
null
;
}
;
function
Bookmarks
(
migrationType
)
{
this
.
_migrationType
=
migrationType
;
}
Bookmarks
.
prototype
=
{
type
:
MigrationUtils
.
resourceTypes
.
BOOKMARKS
get
exists
(
)
!
!
this
.
_favoritesFolder
get
importedAppLabel
(
)
this
.
_migrationType
=
=
MSMigrationUtils
.
MIGRATION_TYPE_IE
?
"
IE
"
:
"
Edge
"
__favoritesFolder
:
null
get
_favoritesFolder
(
)
{
if
(
!
this
.
__favoritesFolder
)
{
if
(
this
.
_migrationType
=
=
MSMigrationUtils
.
MIGRATION_TYPE_IE
)
{
let
favoritesFolder
=
Services
.
dirsvc
.
get
(
"
Favs
"
Ci
.
nsIFile
)
;
if
(
favoritesFolder
.
exists
(
)
&
&
favoritesFolder
.
isReadable
(
)
)
return
this
.
__favoritesFolder
=
favoritesFolder
;
}
if
(
this
.
_migrationType
=
=
MSMigrationUtils
.
MIGRATION_TYPE_EDGE
)
{
let
edgeDir
=
getEdgeLocalDataFolder
(
)
;
if
(
edgeDir
)
{
edgeDir
.
appendRelativePath
(
EDGE_FAVORITES
)
;
if
(
edgeDir
.
exists
(
)
&
&
edgeDir
.
isReadable
(
)
&
&
edgeDir
.
isDirectory
(
)
)
{
return
this
.
__favoritesFolder
=
edgeDir
;
}
}
}
}
return
this
.
__favoritesFolder
;
}
__toolbarFolderName
:
null
get
_toolbarFolderName
(
)
{
if
(
!
this
.
__toolbarFolderName
)
{
if
(
this
.
_migrationType
=
=
MSMigrationUtils
.
MIGRATION_TYPE_IE
)
{
let
folderName
=
WindowsRegistry
.
readRegKey
(
Ci
.
nsIWindowsRegKey
.
ROOT_KEY_CURRENT_USER
"
Software
\
\
Microsoft
\
\
Internet
Explorer
\
\
Toolbar
"
"
LinksFolderName
"
)
;
this
.
__toolbarFolderName
=
folderName
|
|
"
Links
"
;
}
else
{
this
.
__toolbarFolderName
=
"
Links
"
;
}
}
return
this
.
__toolbarFolderName
;
}
migrate
:
function
B_migrate
(
aCallback
)
{
return
Task
.
spawn
(
function
*
(
)
{
let
folderGuid
=
PlacesUtils
.
bookmarks
.
menuGuid
;
if
(
!
MigrationUtils
.
isStartupMigration
)
{
folderGuid
=
yield
MigrationUtils
.
createImportedBookmarksFolder
(
this
.
importedAppLabel
folderGuid
)
;
}
yield
this
.
_migrateFolder
(
this
.
_favoritesFolder
folderGuid
)
;
if
(
this
.
_migrationType
=
=
MSMigrationUtils
.
MIGRATION_TYPE_EDGE
)
{
yield
this
.
_migrateEdgeReadingList
(
PlacesUtils
.
bookmarks
.
menuGuid
)
;
}
}
.
bind
(
this
)
)
.
then
(
(
)
=
>
aCallback
(
true
)
e
=
>
{
Cu
.
reportError
(
e
)
;
aCallback
(
false
)
}
)
;
}
_migrateFolder
:
Task
.
async
(
function
*
(
aSourceFolder
aDestFolderGuid
)
{
let
entries
=
aSourceFolder
.
directoryEntries
;
while
(
entries
.
hasMoreElements
(
)
)
{
let
entry
=
entries
.
getNext
(
)
.
QueryInterface
(
Ci
.
nsIFile
)
;
try
{
if
(
entry
.
path
=
=
entry
.
target
&
&
entry
.
isDirectory
(
)
)
{
let
folderGuid
;
if
(
entry
.
leafName
=
=
this
.
_toolbarFolderName
&
&
entry
.
parent
.
equals
(
this
.
_favoritesFolder
)
)
{
folderGuid
=
PlacesUtils
.
bookmarks
.
toolbarGuid
;
if
(
!
MigrationUtils
.
isStartupMigration
)
{
folderGuid
=
yield
MigrationUtils
.
createImportedBookmarksFolder
(
this
.
importedAppLabel
folderGuid
)
;
}
}
else
{
folderGuid
=
(
yield
PlacesUtils
.
bookmarks
.
insert
(
{
type
:
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
parentGuid
:
aDestFolderGuid
title
:
entry
.
leafName
}
)
)
.
guid
;
}
if
(
entry
.
isReadable
(
)
)
{
yield
this
.
_migrateFolder
(
entry
folderGuid
)
;
}
}
else
{
let
matches
=
entry
.
leafName
.
match
(
/
(
.
+
)
\
.
url
/
i
)
;
if
(
matches
)
{
let
fileHandler
=
Cc
[
"
mozilla
.
org
/
network
/
protocol
;
1
?
name
=
file
"
]
.
getService
(
Ci
.
nsIFileProtocolHandler
)
;
let
uri
=
fileHandler
.
readURLFile
(
entry
)
;
let
title
=
matches
[
1
]
;
yield
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
aDestFolderGuid
url
:
uri
title
}
)
;
}
}
}
catch
(
ex
)
{
Components
.
utils
.
reportError
(
"
Unable
to
import
"
+
this
.
importedAppLabel
+
"
favorite
(
"
+
entry
.
leafName
+
"
)
:
"
+
ex
)
;
}
}
}
)
_migrateEdgeReadingList
:
Task
.
async
(
function
*
(
parentGuid
)
{
let
edgeDir
=
getEdgeLocalDataFolder
(
)
;
if
(
!
edgeDir
)
{
return
;
}
this
.
_readingListExtractor
=
Cc
[
"
mozilla
.
org
/
profile
/
migrator
/
edgereadinglistextractor
;
1
"
]
.
createInstance
(
Ci
.
nsIEdgeReadingListExtractor
)
;
edgeDir
.
appendRelativePath
(
EDGE_READINGLIST
)
;
if
(
edgeDir
.
exists
(
)
&
&
edgeDir
.
isReadable
(
)
&
&
edgeDir
.
isDirectory
(
)
)
{
let
expectedDir
=
edgeDir
.
clone
(
)
;
expectedDir
.
appendRelativePath
(
"
nouser1
\
\
120712
-
0049
"
)
;
if
(
expectedDir
.
exists
(
)
&
&
expectedDir
.
isReadable
(
)
&
&
expectedDir
.
isDirectory
(
)
)
{
yield
this
.
_migrateEdgeReadingListDB
(
expectedDir
parentGuid
)
;
}
else
{
let
getSubdirs
=
someDir
=
>
{
let
subdirs
=
someDir
.
directoryEntries
;
let
rv
=
[
]
;
while
(
subdirs
.
hasMoreElements
(
)
)
{
let
subdir
=
subdirs
.
getNext
(
)
.
QueryInterface
(
Ci
.
nsIFile
)
;
if
(
subdir
.
isDirectory
(
)
&
&
subdir
.
isReadable
(
)
)
{
rv
.
push
(
subdir
)
;
}
}
return
rv
;
}
;
let
dirs
=
getSubdirs
(
edgeDir
)
.
map
(
getSubdirs
)
;
for
(
let
dir
of
dirs
)
{
yield
this
.
_migrateEdgeReadingListDB
(
dir
parentGuid
)
;
}
}
}
}
)
_migrateEdgeReadingListDB
:
Task
.
async
(
function
*
(
dbFile
parentGuid
)
{
dbFile
.
appendRelativePath
(
"
DBStore
\
\
spartan
.
edb
"
)
;
if
(
!
dbFile
.
exists
(
)
|
|
!
dbFile
.
isReadable
(
)
|
|
!
dbFile
.
isFile
(
)
)
{
return
;
}
let
readingListItems
;
try
{
readingListItems
=
this
.
_readingListExtractor
.
extract
(
dbFile
.
path
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
"
Failed
to
extract
Edge
reading
list
information
from
"
+
"
the
database
at
"
+
dbPath
+
"
due
to
the
following
error
:
"
+
ex
)
;
return
;
}
if
(
!
readingListItems
.
length
)
{
return
;
}
let
destFolderGuid
=
yield
this
.
_ensureEdgeReadingListFolder
(
parentGuid
)
;
for
(
let
i
=
0
;
i
<
readingListItems
.
length
;
i
+
+
)
{
let
readingListItem
=
readingListItems
.
queryElementAt
(
i
Ci
.
nsIPropertyBag2
)
;
let
url
=
readingListItem
.
get
(
"
uri
"
)
;
let
title
=
readingListItem
.
get
(
"
title
"
)
;
let
time
=
readingListItem
.
get
(
"
time
"
)
;
let
dateAdded
=
time
?
new
Date
(
time
/
1000
)
:
new
Date
(
)
;
yield
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
destFolderGuid
url
:
url
title
dateAdded
}
)
;
}
}
)
_ensureEdgeReadingListFolder
:
Task
.
async
(
function
*
(
parentGuid
)
{
if
(
!
this
.
__edgeReadingListFolderGuid
)
{
let
folderTitle
=
MigrationUtils
.
getLocalizedString
(
"
importedEdgeReadingList
"
)
;
let
folderSpec
=
{
type
:
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
parentGuid
title
:
folderTitle
}
;
this
.
__edgeReadingListFolderGuid
=
(
yield
PlacesUtils
.
bookmarks
.
insert
(
folderSpec
)
)
.
guid
;
}
return
this
.
__edgeReadingListFolderGuid
;
}
)
}
;
function
Cookies
(
migrationType
)
{
this
.
_migrationType
=
migrationType
;
}
Cookies
.
prototype
=
{
type
:
MigrationUtils
.
resourceTypes
.
COOKIES
get
exists
(
)
{
if
(
this
.
_migrationType
=
=
MSMigrationUtils
.
MIGRATION_TYPE_IE
)
{
return
!
!
this
.
_cookiesFolder
;
}
return
!
!
this
.
_cookiesFolders
;
}
__cookiesFolder
:
null
get
_cookiesFolder
(
)
{
if
(
this
.
_migrationType
!
=
MSMigrationUtils
.
MIGRATION_TYPE_IE
)
{
throw
new
Error
(
"
Shouldn
'
t
be
looking
for
a
single
cookie
folder
unless
we
'
re
migrating
IE
"
)
;
}
if
(
!
this
.
__cookiesFolder
)
{
let
cookiesFolder
=
Services
.
dirsvc
.
get
(
"
CookD
"
Ci
.
nsIFile
)
;
if
(
cookiesFolder
.
exists
(
)
&
&
cookiesFolder
.
isReadable
(
)
)
{
if
(
Services
.
appinfo
.
QueryInterface
(
Ci
.
nsIWinAppHelper
)
.
userCanElevate
)
{
cookiesFolder
.
append
(
"
Low
"
)
;
}
this
.
__cookiesFolder
=
cookiesFolder
;
}
}
return
this
.
__cookiesFolder
;
}
__cookiesFolders
:
null
get
_cookiesFolders
(
)
{
if
(
this
.
_migrationType
!
=
MSMigrationUtils
.
MIGRATION_TYPE_EDGE
)
{
throw
new
Error
(
"
Shouldn
'
t
be
looking
for
multiple
cookie
folders
unless
we
'
re
migrating
Edge
"
)
;
}
let
folders
=
[
]
;
let
edgeDir
=
getEdgeLocalDataFolder
(
)
;
if
(
edgeDir
)
{
edgeDir
.
append
(
"
AC
"
)
;
for
(
let
path
of
EDGE_COOKIE_PATH_OPTIONS
)
{
let
folder
=
edgeDir
.
clone
(
)
;
let
fullPath
=
path
+
EDGE_COOKIES_SUFFIX
;
folder
.
appendRelativePath
(
fullPath
)
;
if
(
folder
.
exists
(
)
&
&
folder
.
isReadable
(
)
&
&
folder
.
isDirectory
(
)
)
{
folders
.
push
(
folder
)
;
}
}
}
return
this
.
__cookiesFolders
=
folders
.
length
?
folders
:
null
;
}
migrate
(
aCallback
)
{
this
.
ctypesKernelHelpers
=
new
CtypesKernelHelpers
(
)
;
let
cookiesGenerator
=
(
function
genCookie
(
)
{
let
success
=
false
;
let
folders
=
this
.
_migrationType
=
=
MSMigrationUtils
.
MIGRATION_TYPE_EDGE
?
this
.
__cookiesFolders
:
[
this
.
__cookiesFolder
]
;
for
(
let
folder
of
folders
)
{
let
entries
=
folder
.
directoryEntries
;
while
(
entries
.
hasMoreElements
(
)
)
{
let
entry
=
entries
.
getNext
(
)
.
QueryInterface
(
Ci
.
nsIFile
)
;
if
(
!
entry
.
isFile
(
)
|
|
!
/
\
.
txt
/
.
test
(
entry
.
leafName
)
)
continue
;
this
.
_readCookieFile
(
entry
function
(
aSuccess
)
{
if
(
aSuccess
)
success
=
true
;
try
{
cookiesGenerator
.
next
(
)
;
}
catch
(
ex
)
{
}
}
)
;
yield
undefined
;
}
}
this
.
ctypesKernelHelpers
.
finalize
(
)
;
aCallback
(
success
)
;
}
)
.
apply
(
this
)
;
cookiesGenerator
.
next
(
)
;
}
_readCookieFile
(
aFile
aCallback
)
{
let
fileReader
=
Cc
[
"
mozilla
.
org
/
files
/
filereader
;
1
"
]
.
createInstance
(
Ci
.
nsIDOMFileReader
)
;
let
onLoadEnd
=
(
)
=
>
{
fileReader
.
removeEventListener
(
"
loadend
"
onLoadEnd
false
)
;
if
(
fileReader
.
readyState
!
=
fileReader
.
DONE
)
{
Cu
.
reportError
(
"
Could
not
read
cookie
contents
:
"
+
fileReader
.
error
)
;
aCallback
(
false
)
;
return
;
}
let
success
=
true
;
try
{
this
.
_parseCookieBuffer
(
fileReader
.
result
)
;
}
catch
(
ex
)
{
Components
.
utils
.
reportError
(
"
Unable
to
migrate
cookie
:
"
+
ex
)
;
success
=
false
;
}
finally
{
aCallback
(
success
)
;
}
}
;
fileReader
.
addEventListener
(
"
loadend
"
onLoadEnd
false
)
;
fileReader
.
readAsText
(
new
File
(
aFile
)
)
;
}
_parseCookieBuffer
(
aTextBuffer
)
{
let
records
=
[
r
for
each
(
r
in
aTextBuffer
.
split
(
"
*
\
n
"
)
)
if
(
r
)
]
;
for
(
let
record
of
records
)
{
let
[
name
value
hostpath
flags
expireTimeLo
expireTimeHi
]
=
record
.
split
(
"
\
n
"
)
;
if
(
value
.
length
=
=
0
)
continue
;
let
hostLen
=
hostpath
.
indexOf
(
"
/
"
)
;
let
host
=
hostpath
.
substr
(
0
hostLen
)
;
let
path
=
hostpath
.
substr
(
hostLen
)
;
if
(
host
.
length
>
0
)
{
Services
.
cookies
.
remove
(
host
name
path
false
)
;
if
(
host
[
0
]
!
=
"
.
"
&
&
!
hostIsIPAddress
(
host
)
)
host
=
"
.
"
+
host
;
}
let
expireTime
=
(
Date
.
now
(
)
+
3600
*
1000
)
*
1000
;
try
{
expireTime
=
this
.
ctypesKernelHelpers
.
fileTimeToSecondsSinceEpoch
(
Number
(
expireTimeHi
)
Number
(
expireTimeLo
)
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
"
Failed
to
get
expiry
time
for
cookie
for
"
+
host
)
;
}
Services
.
cookies
.
add
(
host
path
name
value
Number
(
flags
)
&
0x1
false
false
expireTime
)
;
}
}
}
;
function
getTypedURLs
(
registryKeyPath
)
{
let
typedURLs
=
new
Map
(
)
;
let
typedURLKey
=
Cc
[
"
mozilla
.
org
/
windows
-
registry
-
key
;
1
"
]
.
createInstance
(
Ci
.
nsIWindowsRegKey
)
;
let
typedURLTimeKey
=
Cc
[
"
mozilla
.
org
/
windows
-
registry
-
key
;
1
"
]
.
createInstance
(
Ci
.
nsIWindowsRegKey
)
;
let
cTypes
=
new
CtypesKernelHelpers
(
)
;
try
{
typedURLKey
.
open
(
Ci
.
nsIWindowsRegKey
.
ROOT_KEY_CURRENT_USER
registryKeyPath
+
"
\
\
TypedURLs
"
Ci
.
nsIWindowsRegKey
.
ACCESS_READ
)
;
try
{
typedURLTimeKey
.
open
(
Ci
.
nsIWindowsRegKey
.
ROOT_KEY_CURRENT_USER
registryKeyPath
+
"
\
\
TypedURLsTime
"
Ci
.
nsIWindowsRegKey
.
ACCESS_READ
)
;
}
catch
(
ex
)
{
typedURLTimeKey
=
null
;
}
let
entryName
;
for
(
let
entry
=
1
;
typedURLKey
.
hasValue
(
(
entryName
=
"
url
"
+
entry
)
)
;
entry
+
+
)
{
let
url
=
typedURLKey
.
readStringValue
(
entryName
)
;
let
timeTyped
=
0
;
if
(
typedURLTimeKey
&
&
typedURLTimeKey
.
hasValue
(
entryName
)
)
{
let
urlTime
=
"
"
;
try
{
urlTime
=
typedURLTimeKey
.
readBinaryValue
(
entryName
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
"
Couldn
'
t
read
url
time
for
"
+
entryName
)
;
}
if
(
urlTime
.
length
=
=
8
)
{
let
urlTimeHex
=
[
]
;
for
(
let
i
=
0
;
i
<
8
;
i
+
+
)
{
let
c
=
urlTime
.
charCodeAt
(
i
)
.
toString
(
16
)
;
if
(
c
.
length
=
=
1
)
c
=
"
0
"
+
c
;
urlTimeHex
.
unshift
(
c
)
;
}
try
{
let
hi
=
parseInt
(
urlTimeHex
.
slice
(
0
4
)
.
join
(
'
'
)
16
)
;
let
lo
=
parseInt
(
urlTimeHex
.
slice
(
4
8
)
.
join
(
'
'
)
16
)
;
timeTyped
=
cTypes
.
fileTimeToSecondsSinceEpoch
(
hi
lo
)
;
timeTyped
*
=
1000
*
1000
;
}
catch
(
ex
)
{
}
}
}
typedURLs
.
set
(
url
timeTyped
)
;
}
}
catch
(
ex
)
{
Cu
.
reportError
(
"
Error
reading
typed
URL
history
:
"
+
ex
)
;
}
finally
{
typedURLKey
.
close
(
)
;
typedURLTimeKey
.
close
(
)
;
cTypes
.
finalize
(
)
;
}
return
typedURLs
;
}
function
WindowsVaultFormPasswords
(
)
{
}
WindowsVaultFormPasswords
.
prototype
=
{
type
:
MigrationUtils
.
resourceTypes
.
PASSWORDS
get
exists
(
)
{
if
(
AppConstants
.
isPlatformAndVersionAtLeast
(
"
win
"
"
6
.
2
"
)
)
{
return
this
.
migrate
(
(
)
=
>
{
}
true
)
;
}
return
false
;
}
migrate
(
aCallback
aOnlyCheckExists
=
false
)
{
function
_isIEOrEdgePassword
(
id
)
{
return
id
[
0
]
=
=
INTERNET_EXPLORER_EDGE_GUID
[
0
]
&
&
id
[
1
]
=
=
INTERNET_EXPLORER_EDGE_GUID
[
1
]
&
&
id
[
2
]
=
=
INTERNET_EXPLORER_EDGE_GUID
[
2
]
&
&
id
[
3
]
=
=
INTERNET_EXPLORER_EDGE_GUID
[
3
]
;
}
let
ctypesVaultHelpers
=
new
CtypesVaultHelpers
(
)
;
let
ctypesKernelHelpers
=
new
CtypesKernelHelpers
(
)
;
let
migrationSucceeded
=
true
;
let
successfulVaultOpen
=
false
;
let
error
vault
;
try
{
let
vaultGuid
=
new
ctypesVaultHelpers
.
_structs
.
GUID
(
WEB_CREDENTIALS_VAULT_ID
)
;
let
vaultCount
=
new
wintypes
.
DWORD
;
error
=
new
wintypes
.
DWORD
;
vault
=
new
ctypesVaultHelpers
.
_vaultHandleType
;
error
=
ctypesVaultHelpers
.
_functions
.
VaultOpenVault
(
vaultGuid
.
address
(
)
0
vault
.
address
(
)
)
;
if
(
error
!
=
RESULT_SUCCESS
)
{
throw
new
Error
(
"
Unable
to
open
Vault
:
"
+
error
)
;
}
successfulVaultOpen
=
true
;
let
item
=
new
ctypesVaultHelpers
.
_structs
.
VAULT_ELEMENT
.
ptr
;
let
itemCount
=
new
wintypes
.
DWORD
;
error
=
ctypesVaultHelpers
.
_functions
.
VaultEnumerateItems
(
vault
VAULT_ENUMERATE_ALL_ITEMS
itemCount
.
address
(
)
item
.
address
(
)
)
;
if
(
error
!
=
RESULT_SUCCESS
)
{
throw
new
Error
(
"
Unable
to
enumerate
Vault
items
:
"
+
error
)
;
}
for
(
let
j
=
0
;
j
<
itemCount
.
value
;
j
+
+
)
{
try
{
if
(
!
_isIEOrEdgePassword
(
item
.
contents
.
schemaId
.
id
)
)
{
continue
;
}
if
(
aOnlyCheckExists
)
{
return
true
;
}
let
url
=
item
.
contents
.
pResourceElement
.
contents
.
itemValue
.
readString
(
)
;
let
username
=
item
.
contents
.
pIdentityElement
.
contents
.
itemValue
.
readString
(
)
;
let
credential
=
new
ctypesVaultHelpers
.
_structs
.
VAULT_ELEMENT
.
ptr
;
error
=
ctypesVaultHelpers
.
_functions
.
VaultGetItem
(
vault
item
.
contents
.
schemaId
.
address
(
)
item
.
contents
.
pResourceElement
item
.
contents
.
pIdentityElement
null
0
0
credential
.
address
(
)
)
;
if
(
error
!
=
RESULT_SUCCESS
)
{
throw
new
Error
(
"
Unable
to
get
item
:
"
+
error
)
;
}
let
password
=
credential
.
contents
.
pAuthenticatorElement
.
contents
.
itemValue
.
readString
(
)
;
let
creation
=
ctypesKernelHelpers
.
fileTimeToSecondsSinceEpoch
(
item
.
contents
.
highLastModified
item
.
contents
.
lowLastModified
)
*
1000
;
let
login
=
{
username
password
hostname
:
NetUtil
.
newURI
(
url
)
.
prePath
timeCreated
:
creation
}
;
LoginHelper
.
maybeImportLogin
(
login
)
;
error
=
ctypesVaultHelpers
.
_functions
.
VaultFree
(
credential
)
;
if
(
error
=
=
FREE_CLOSE_FAILED
)
{
throw
new
Error
(
"
Unable
to
free
item
:
"
+
error
)
;
}
}
catch
(
e
)
{
migrationSucceeded
=
false
;
Cu
.
reportError
(
e
)
;
}
finally
{
item
=
item
.
increment
(
)
;
}
}
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
migrationSucceeded
=
false
;
}
finally
{
if
(
successfulVaultOpen
)
{
error
=
ctypesVaultHelpers
.
_functions
.
VaultCloseVault
(
vault
)
;
if
(
error
=
=
FREE_CLOSE_FAILED
)
{
Cu
.
reportError
(
"
Unable
to
close
vault
:
"
+
error
)
;
}
}
ctypesKernelHelpers
.
finalize
(
)
;
ctypesVaultHelpers
.
finalize
(
)
;
aCallback
(
migrationSucceeded
)
;
}
if
(
aOnlyCheckExists
)
{
return
false
;
}
}
}
;
var
MSMigrationUtils
=
{
MIGRATION_TYPE_IE
:
1
MIGRATION_TYPE_EDGE
:
2
CtypesKernelHelpers
:
CtypesKernelHelpers
getBookmarksMigrator
(
migrationType
=
this
.
MIGRATION_TYPE_IE
)
{
return
new
Bookmarks
(
migrationType
)
;
}
getCookiesMigrator
(
migrationType
=
this
.
MIGRATION_TYPE_IE
)
{
return
new
Cookies
(
migrationType
)
;
}
getWindowsVaultFormPasswordsMigrator
(
)
{
return
new
WindowsVaultFormPasswords
(
)
;
}
getTypedURLs
}
;
