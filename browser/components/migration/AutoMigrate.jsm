"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
AutoMigrate
"
]
;
const
{
classes
:
Cc
interfaces
:
Ci
results
:
Cr
utils
:
Cu
}
=
Components
;
const
kAutoMigrateStartedPref
=
"
browser
.
migrate
.
automigrate
-
started
"
;
const
kAutoMigrateFinishedPref
=
"
browser
.
migrate
.
automigrate
-
finished
"
;
Cu
.
import
(
"
resource
:
/
/
/
modules
/
MigrationUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
AutoMigrate
=
{
get
resourceTypesToUse
(
)
{
let
{
BOOKMARKS
HISTORY
PASSWORDS
}
=
Ci
.
nsIBrowserProfileMigrator
;
return
BOOKMARKS
|
HISTORY
|
PASSWORDS
;
}
migrate
(
profileStartup
migratorKey
profileToMigrate
)
{
let
histogram
=
Services
.
telemetry
.
getKeyedHistogramById
(
"
FX_STARTUP_MIGRATION_AUTOMATED_IMPORT_SUCCEEDED
"
)
;
histogram
.
add
(
"
initialized
"
)
;
let
migrator
=
this
.
pickMigrator
(
migratorKey
)
;
histogram
.
add
(
"
got
-
browser
"
)
;
profileToMigrate
=
this
.
pickProfile
(
migrator
profileToMigrate
)
;
histogram
.
add
(
"
got
-
profile
"
)
;
let
resourceTypes
=
migrator
.
getMigrateData
(
profileToMigrate
profileStartup
)
;
if
(
!
(
resourceTypes
&
this
.
resourceTypesToUse
)
)
{
throw
new
Error
(
"
No
usable
resources
were
found
for
the
selected
browser
!
"
)
;
}
histogram
.
add
(
"
got
-
data
"
)
;
let
sawErrors
=
false
;
let
migrationObserver
=
function
(
subject
topic
data
)
{
if
(
topic
=
=
"
Migration
:
ItemError
"
)
{
sawErrors
=
true
;
}
else
if
(
topic
=
=
"
Migration
:
Ended
"
)
{
histogram
.
add
(
sawErrors
?
"
finished
-
with
-
errors
"
:
"
finished
"
)
;
Services
.
obs
.
removeObserver
(
migrationObserver
"
Migration
:
Ended
"
)
;
Services
.
obs
.
removeObserver
(
migrationObserver
"
Migration
:
ItemError
"
)
;
Services
.
prefs
.
setCharPref
(
kAutoMigrateFinishedPref
Date
.
now
(
)
.
toString
(
)
)
;
}
}
;
Services
.
obs
.
addObserver
(
migrationObserver
"
Migration
:
Ended
"
false
)
;
Services
.
obs
.
addObserver
(
migrationObserver
"
Migration
:
ItemError
"
false
)
;
Services
.
prefs
.
setCharPref
(
kAutoMigrateStartedPref
Date
.
now
(
)
.
toString
(
)
)
;
migrator
.
migrate
(
this
.
resourceTypesToUse
profileStartup
profileToMigrate
)
;
histogram
.
add
(
"
migrate
-
called
-
without
-
exceptions
"
)
;
}
pickMigrator
(
migratorKey
)
{
if
(
!
migratorKey
)
{
let
defaultKey
=
MigrationUtils
.
getMigratorKeyForDefaultBrowser
(
)
;
if
(
!
defaultKey
)
{
throw
new
Error
(
"
Could
not
determine
default
browser
key
to
migrate
from
"
)
;
}
migratorKey
=
defaultKey
;
}
if
(
migratorKey
=
=
"
firefox
"
)
{
throw
new
Error
(
"
Can
'
t
automatically
migrate
from
Firefox
.
"
)
;
}
let
migrator
=
MigrationUtils
.
getMigrator
(
migratorKey
)
;
if
(
!
migrator
)
{
throw
new
Error
(
"
Migrator
specified
or
a
default
was
found
but
the
migrator
object
is
not
available
.
"
)
;
}
return
migrator
;
}
pickProfile
(
migrator
suggestedId
)
{
let
profiles
=
migrator
.
sourceProfiles
;
if
(
profiles
&
&
!
profiles
.
length
)
{
throw
new
Error
(
"
No
profile
data
found
to
migrate
.
"
)
;
}
if
(
suggestedId
)
{
if
(
!
profiles
)
{
throw
new
Error
(
"
Profile
specified
but
only
a
default
profile
found
.
"
)
;
}
let
suggestedProfile
=
profiles
.
find
(
profile
=
>
profile
.
id
=
=
suggestedId
)
;
if
(
!
suggestedProfile
)
{
throw
new
Error
(
"
Profile
specified
was
not
found
.
"
)
;
}
return
suggestedProfile
.
id
;
}
if
(
profiles
&
&
profiles
.
length
>
1
)
{
throw
new
Error
(
"
Don
'
t
know
how
to
pick
a
profile
when
more
than
1
profile
is
present
.
"
)
;
}
return
profiles
?
profiles
[
0
]
.
id
:
null
;
}
getUndoRange
(
)
{
let
start
finish
;
try
{
start
=
parseInt
(
Services
.
prefs
.
getCharPref
(
kAutoMigrateStartedPref
)
10
)
;
finish
=
parseInt
(
Services
.
prefs
.
getCharPref
(
kAutoMigrateFinishedPref
)
10
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
if
(
!
finish
|
|
!
start
)
{
return
null
;
}
return
[
new
Date
(
start
)
new
Date
(
finish
)
]
;
}
canUndo
(
)
{
if
(
!
this
.
getUndoRange
(
)
)
{
return
Promise
.
resolve
(
false
)
;
}
let
{
fxAccounts
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
FxAccounts
.
jsm
"
{
}
)
;
return
fxAccounts
.
getSignedInUser
(
)
.
then
(
user
=
>
!
user
(
)
=
>
Promise
.
resolve
(
true
)
)
;
}
undo
:
Task
.
async
(
function
*
(
)
{
if
(
!
(
yield
this
.
canUndo
(
)
)
)
{
throw
new
Error
(
"
Can
'
t
undo
!
"
)
;
}
yield
PlacesUtils
.
bookmarks
.
eraseEverything
(
)
;
let
range
=
this
.
getUndoRange
(
)
;
yield
PlacesUtils
.
history
.
removeVisitsByFilter
(
{
beginDate
:
new
Date
(
0
)
endDate
:
range
[
1
]
}
)
;
try
{
Services
.
logins
.
removeAllLogins
(
)
;
}
catch
(
ex
)
{
}
Services
.
prefs
.
clearUserPref
(
"
browser
.
migrate
.
automigrate
-
started
"
)
;
Services
.
prefs
.
clearUserPref
(
"
browser
.
migrate
.
automigrate
-
finished
"
)
;
}
)
}
;
