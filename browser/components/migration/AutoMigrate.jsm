"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
AutoMigrate
"
]
;
const
kAutoMigrateEnabledPref
=
"
browser
.
migrate
.
automigrate
.
enabled
"
;
const
kUndoUIEnabledPref
=
"
browser
.
migrate
.
automigrate
.
ui
.
enabled
"
;
const
kInPageUIEnabledPref
=
"
browser
.
migrate
.
automigrate
.
inpage
.
ui
.
enabled
"
;
const
kAutoMigrateBrowserPref
=
"
browser
.
migrate
.
automigrate
.
browser
"
;
const
kAutoMigrateImportedItemIds
=
"
browser
.
migrate
.
automigrate
.
imported
-
items
"
;
const
kAutoMigrateLastUndoPromptDateMsPref
=
"
browser
.
migrate
.
automigrate
.
lastUndoPromptDateMs
"
;
const
kAutoMigrateDaysToOfferUndoPref
=
"
browser
.
migrate
.
automigrate
.
daysToOfferUndo
"
;
const
kAutoMigrateUndoSurveyPref
=
"
browser
.
migrate
.
automigrate
.
undo
-
survey
"
;
const
kAutoMigrateUndoSurveyLocalePref
=
"
browser
.
migrate
.
automigrate
.
undo
-
survey
-
locales
"
;
const
kNotificationId
=
"
automigration
-
undo
"
;
ChromeUtils
.
import
(
"
resource
:
/
/
/
modules
/
MigrationUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
AsyncShutdown
"
"
resource
:
/
/
gre
/
modules
/
AsyncShutdown
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
LoginHelper
"
"
resource
:
/
/
gre
/
modules
/
LoginHelper
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
NewTabUtils
"
"
resource
:
/
/
gre
/
modules
/
NewTabUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
OS
"
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PlacesUtils
"
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
TelemetryStopwatch
"
"
resource
:
/
/
gre
/
modules
/
TelemetryStopwatch
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gBrandBundle
"
function
(
)
{
const
kBrandBundle
=
"
chrome
:
/
/
branding
/
locale
/
brand
.
properties
"
;
return
Services
.
strings
.
createBundle
(
kBrandBundle
)
;
}
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
URL
"
]
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
kUndoStateFullPath
"
function
(
)
{
return
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
"
initialMigrationMetadata
.
jsonlz4
"
)
;
}
)
;
const
AutoMigrate
=
{
get
resourceTypesToUse
(
)
{
let
{
BOOKMARKS
HISTORY
PASSWORDS
}
=
Ci
.
nsIBrowserProfileMigrator
;
return
BOOKMARKS
|
HISTORY
|
PASSWORDS
;
}
_checkIfEnabled
(
)
{
let
pref
=
Preferences
.
get
(
kAutoMigrateEnabledPref
false
)
;
if
(
Services
.
prefs
.
prefHasUserValue
(
kAutoMigrateEnabledPref
)
)
{
return
pref
;
}
try
{
let
distributionFile
=
Services
.
dirsvc
.
get
(
"
XREAppDist
"
Ci
.
nsIFile
)
;
distributionFile
.
append
(
"
distribution
.
ini
"
)
;
let
parser
=
Cc
[
"
mozilla
.
org
/
xpcom
/
ini
-
parser
-
factory
;
1
"
]
.
getService
(
Ci
.
nsIINIParserFactory
)
.
createINIParser
(
distributionFile
)
;
return
JSON
.
parse
(
parser
.
getString
(
"
Preferences
"
kAutoMigrateEnabledPref
)
)
;
}
catch
(
ex
)
{
}
return
pref
;
}
init
(
)
{
this
.
enabled
=
this
.
_checkIfEnabled
(
)
;
}
async
migrate
(
profileStartup
migratorKey
profileToMigrate
)
{
let
histogram
=
Services
.
telemetry
.
getHistogramById
(
"
FX_STARTUP_MIGRATION_AUTOMATED_IMPORT_PROCESS_SUCCESS
"
)
;
histogram
.
add
(
0
)
;
let
{
migrator
pickedKey
}
=
await
this
.
pickMigrator
(
migratorKey
)
;
histogram
.
add
(
5
)
;
profileToMigrate
=
await
this
.
pickProfile
(
migrator
profileToMigrate
)
;
histogram
.
add
(
10
)
;
let
resourceTypes
=
await
migrator
.
getMigrateData
(
profileToMigrate
profileStartup
)
;
if
(
!
(
resourceTypes
&
this
.
resourceTypesToUse
)
)
{
throw
new
Error
(
"
No
usable
resources
were
found
for
the
selected
browser
!
"
)
;
}
histogram
.
add
(
15
)
;
let
sawErrors
=
false
;
let
migrationObserver
=
(
subject
topic
)
=
>
{
if
(
topic
=
=
"
Migration
:
ItemError
"
)
{
sawErrors
=
true
;
}
else
if
(
topic
=
=
"
Migration
:
Ended
"
)
{
histogram
.
add
(
25
)
;
if
(
sawErrors
)
{
histogram
.
add
(
26
)
;
}
Services
.
obs
.
removeObserver
(
migrationObserver
"
Migration
:
Ended
"
)
;
Services
.
obs
.
removeObserver
(
migrationObserver
"
Migration
:
ItemError
"
)
;
Services
.
prefs
.
setCharPref
(
kAutoMigrateBrowserPref
pickedKey
)
;
AsyncShutdown
.
profileBeforeChange
.
addBlocker
(
"
AutoMigrate
Undo
saving
"
this
.
saveUndoState
(
)
(
)
=
>
{
return
{
state
:
this
.
_saveUndoStateTrackerForShutdown
}
;
}
)
;
}
}
;
MigrationUtils
.
initializeUndoData
(
)
;
Services
.
obs
.
addObserver
(
migrationObserver
"
Migration
:
Ended
"
)
;
Services
.
obs
.
addObserver
(
migrationObserver
"
Migration
:
ItemError
"
)
;
await
migrator
.
migrate
(
this
.
resourceTypesToUse
profileStartup
profileToMigrate
)
;
histogram
.
add
(
20
)
;
}
async
pickMigrator
(
migratorKey
)
{
if
(
!
migratorKey
)
{
let
defaultKey
=
MigrationUtils
.
getMigratorKeyForDefaultBrowser
(
)
;
if
(
!
defaultKey
)
{
throw
new
Error
(
"
Could
not
determine
default
browser
key
to
migrate
from
"
)
;
}
migratorKey
=
defaultKey
;
}
if
(
migratorKey
=
=
"
firefox
"
)
{
throw
new
Error
(
"
Can
'
t
automatically
migrate
from
Firefox
.
"
)
;
}
let
migrator
=
await
MigrationUtils
.
getMigrator
(
migratorKey
)
;
if
(
!
migrator
)
{
throw
new
Error
(
"
Migrator
specified
or
a
default
was
found
but
the
migrator
object
is
not
available
(
or
has
no
data
)
.
"
)
;
}
return
{
migrator
pickedKey
:
migratorKey
}
;
}
async
pickProfile
(
migrator
suggestedId
)
{
let
profiles
=
await
migrator
.
getSourceProfiles
(
)
;
if
(
profiles
&
&
!
profiles
.
length
)
{
throw
new
Error
(
"
No
profile
data
found
to
migrate
.
"
)
;
}
if
(
suggestedId
)
{
if
(
!
profiles
)
{
throw
new
Error
(
"
Profile
specified
but
only
a
default
profile
found
.
"
)
;
}
let
suggestedProfile
=
profiles
.
find
(
profile
=
>
profile
.
id
=
=
suggestedId
)
;
if
(
!
suggestedProfile
)
{
throw
new
Error
(
"
Profile
specified
was
not
found
.
"
)
;
}
return
suggestedProfile
;
}
if
(
profiles
&
&
profiles
.
length
>
1
)
{
throw
new
Error
(
"
Don
'
t
know
how
to
pick
a
profile
when
more
than
1
profile
is
present
.
"
)
;
}
return
profiles
?
profiles
[
0
]
:
null
;
}
_pendingUndoTasks
:
false
async
canUndo
(
)
{
if
(
this
.
_savingPromise
)
{
await
this
.
_savingPromise
;
}
if
(
this
.
_pendingUndoTasks
)
{
return
false
;
}
let
fileExists
=
false
;
try
{
fileExists
=
await
OS
.
File
.
exists
(
kUndoStateFullPath
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
return
fileExists
;
}
async
undo
(
)
{
let
browserId
=
Preferences
.
get
(
kAutoMigrateBrowserPref
"
unknown
"
)
;
TelemetryStopwatch
.
startKeyed
(
"
FX_STARTUP_MIGRATION_UNDO_TOTAL_MS
"
browserId
)
;
let
histogram
=
Services
.
telemetry
.
getHistogramById
(
"
FX_STARTUP_MIGRATION_AUTOMATED_IMPORT_UNDO
"
)
;
histogram
.
add
(
0
)
;
if
(
!
(
await
this
.
canUndo
(
)
)
)
{
histogram
.
add
(
5
)
;
throw
new
Error
(
"
Can
'
t
undo
!
"
)
;
}
this
.
_pendingUndoTasks
=
true
;
this
.
_removeNotificationBars
(
)
;
histogram
.
add
(
10
)
;
let
readPromise
=
OS
.
File
.
read
(
kUndoStateFullPath
{
encoding
:
"
utf
-
8
"
compression
:
"
lz4
"
}
)
;
let
stateData
=
this
.
_dejsonifyUndoState
(
await
readPromise
)
;
histogram
.
add
(
12
)
;
this
.
_errorMap
=
{
bookmarks
:
0
visits
:
0
logins
:
0
}
;
let
reportErrorTelemetry
=
(
type
)
=
>
{
let
histogramId
=
FX_STARTUP_MIGRATION_UNDO_
{
type
.
toUpperCase
(
)
}
_ERRORCOUNT
;
Services
.
telemetry
.
getKeyedHistogramById
(
histogramId
)
.
add
(
browserId
this
.
_errorMap
[
type
]
)
;
}
;
let
startTelemetryStopwatch
=
resourceType
=
>
{
let
histogramId
=
FX_STARTUP_MIGRATION_UNDO_
{
resourceType
.
toUpperCase
(
)
}
_MS
;
TelemetryStopwatch
.
startKeyed
(
histogramId
browserId
)
;
}
;
let
stopTelemetryStopwatch
=
resourceType
=
>
{
let
histogramId
=
FX_STARTUP_MIGRATION_UNDO_
{
resourceType
.
toUpperCase
(
)
}
_MS
;
TelemetryStopwatch
.
finishKeyed
(
histogramId
browserId
)
;
}
;
startTelemetryStopwatch
(
"
bookmarks
"
)
;
await
this
.
_removeUnchangedBookmarks
(
stateData
.
get
(
"
bookmarks
"
)
)
.
catch
(
ex
=
>
{
Cu
.
reportError
(
"
Uncaught
exception
when
removing
unchanged
bookmarks
!
"
)
;
Cu
.
reportError
(
ex
)
;
}
)
;
stopTelemetryStopwatch
(
"
bookmarks
"
)
;
reportErrorTelemetry
(
"
bookmarks
"
)
;
histogram
.
add
(
15
)
;
startTelemetryStopwatch
(
"
visits
"
)
;
await
this
.
_removeSomeVisits
(
stateData
.
get
(
"
visits
"
)
)
.
catch
(
ex
=
>
{
Cu
.
reportError
(
"
Uncaught
exception
when
removing
history
visits
!
"
)
;
Cu
.
reportError
(
ex
)
;
}
)
;
stopTelemetryStopwatch
(
"
visits
"
)
;
reportErrorTelemetry
(
"
visits
"
)
;
histogram
.
add
(
20
)
;
startTelemetryStopwatch
(
"
logins
"
)
;
await
this
.
_removeUnchangedLogins
(
stateData
.
get
(
"
logins
"
)
)
.
catch
(
ex
=
>
{
Cu
.
reportError
(
"
Uncaught
exception
when
removing
unchanged
logins
!
"
)
;
Cu
.
reportError
(
ex
)
;
}
)
;
stopTelemetryStopwatch
(
"
logins
"
)
;
reportErrorTelemetry
(
"
logins
"
)
;
histogram
.
add
(
25
)
;
NewTabUtils
.
links
.
populateCache
(
(
)
=
>
{
NewTabUtils
.
allPages
.
update
(
)
;
}
true
)
;
this
.
_purgeUndoState
(
this
.
UNDO_REMOVED_REASON_UNDO_USED
)
;
histogram
.
add
(
30
)
;
TelemetryStopwatch
.
finishKeyed
(
"
FX_STARTUP_MIGRATION_UNDO_TOTAL_MS
"
browserId
)
;
}
_removeNotificationBars
(
)
{
let
browserWindows
=
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
;
while
(
browserWindows
.
hasMoreElements
(
)
)
{
let
win
=
browserWindows
.
getNext
(
)
;
if
(
!
win
.
closed
)
{
for
(
let
browser
of
win
.
gBrowser
.
browsers
)
{
let
nb
=
win
.
gBrowser
.
getNotificationBox
(
browser
)
;
let
notification
=
nb
.
getNotificationWithValue
(
kNotificationId
)
;
if
(
notification
)
{
nb
.
removeNotification
(
notification
)
;
}
}
}
}
}
_purgeUndoState
(
reason
)
{
OS
.
File
.
remove
(
kUndoStateFullPath
{
ignoreAbsent
:
true
}
)
.
then
(
(
)
=
>
{
this
.
_pendingUndoTasks
=
false
;
}
)
;
let
migrationBrowser
=
Preferences
.
get
(
kAutoMigrateBrowserPref
"
unknown
"
)
;
Services
.
prefs
.
clearUserPref
(
kAutoMigrateBrowserPref
)
;
let
histogram
=
Services
.
telemetry
.
getKeyedHistogramById
(
"
FX_STARTUP_MIGRATION_UNDO_REASON
"
)
;
histogram
.
add
(
migrationBrowser
reason
)
;
}
getBrowserUsedForMigration
(
)
{
let
browserId
=
Services
.
prefs
.
getCharPref
(
kAutoMigrateBrowserPref
)
;
if
(
browserId
)
{
return
MigrationUtils
.
getBrowserName
(
browserId
)
;
}
return
null
;
}
async
shouldShowMigratePrompt
(
target
)
{
if
(
!
(
await
this
.
canUndo
(
)
)
)
{
return
false
;
}
let
canUndoFromThisPage
=
[
"
about
:
home
"
"
about
:
newtab
"
]
.
includes
(
target
.
currentURI
.
spec
)
;
if
(
!
canUndoFromThisPage
|
|
!
Preferences
.
get
(
kUndoUIEnabledPref
false
)
)
{
return
false
;
}
if
(
this
.
isMigratePromptExpired
(
)
)
{
this
.
_purgeUndoState
(
this
.
UNDO_REMOVED_REASON_OFFER_EXPIRED
)
;
this
.
_removeNotificationBars
(
)
;
return
false
;
}
let
remainingDays
=
Preferences
.
get
(
kAutoMigrateDaysToOfferUndoPref
0
)
;
Services
.
telemetry
.
getHistogramById
(
"
FX_STARTUP_MIGRATION_UNDO_OFFERED
"
)
.
add
(
4
-
remainingDays
)
;
return
true
;
}
getUndoMigrationMessage
(
)
{
let
browserName
=
this
.
getBrowserUsedForMigration
(
)
;
if
(
!
browserName
)
{
browserName
=
MigrationUtils
.
getLocalizedString
(
"
automigration
.
undo
.
unknownbrowser
"
)
;
}
const
kMessageId
=
"
automigration
.
undo
.
message2
.
"
+
Preferences
.
get
(
kAutoMigrateImportedItemIds
"
all
"
)
;
const
kBrandShortName
=
gBrandBundle
.
GetStringFromName
(
"
brandShortName
"
)
;
return
MigrationUtils
.
getLocalizedString
(
kMessageId
[
kBrandShortName
browserName
]
)
;
}
showUndoNotificationBar
(
target
)
{
let
isInPage
=
Preferences
.
get
(
kInPageUIEnabledPref
false
)
;
let
win
=
target
.
ownerGlobal
;
let
notificationBox
=
win
.
gBrowser
.
getNotificationBox
(
target
)
;
if
(
isInPage
|
|
!
notificationBox
|
|
notificationBox
.
getNotificationWithValue
(
kNotificationId
)
)
{
return
;
}
let
message
=
this
.
getUndoMigrationMessage
(
)
;
let
buttons
=
[
{
label
:
MigrationUtils
.
getLocalizedString
(
"
automigration
.
undo
.
keep2
.
label
"
)
accessKey
:
MigrationUtils
.
getLocalizedString
(
"
automigration
.
undo
.
keep2
.
accesskey
"
)
callback
:
(
)
=
>
{
this
.
keepAutoMigration
(
)
;
this
.
_removeNotificationBars
(
)
;
}
}
{
label
:
MigrationUtils
.
getLocalizedString
(
"
automigration
.
undo
.
dontkeep2
.
label
"
)
accessKey
:
MigrationUtils
.
getLocalizedString
(
"
automigration
.
undo
.
dontkeep2
.
accesskey
"
)
callback
:
(
)
=
>
{
this
.
undoAutoMigration
(
win
)
;
}
}
]
;
notificationBox
.
appendNotification
(
message
kNotificationId
null
notificationBox
.
PRIORITY_INFO_HIGH
buttons
)
;
}
isMigratePromptExpired
(
)
{
let
today
=
new
Date
(
)
;
today
=
new
Date
(
today
.
getFullYear
(
)
today
.
getMonth
(
)
today
.
getDate
(
)
)
;
let
previousPromptDateMsStr
=
Preferences
.
get
(
kAutoMigrateLastUndoPromptDateMsPref
"
0
"
)
;
let
previousPromptDate
=
new
Date
(
parseInt
(
previousPromptDateMsStr
10
)
)
;
if
(
previousPromptDate
<
today
)
{
let
remainingDays
=
Preferences
.
get
(
kAutoMigrateDaysToOfferUndoPref
4
)
-
1
;
Preferences
.
set
(
kAutoMigrateDaysToOfferUndoPref
remainingDays
)
;
Preferences
.
set
(
kAutoMigrateLastUndoPromptDateMsPref
today
.
valueOf
(
)
.
toString
(
)
)
;
if
(
remainingDays
<
=
0
)
{
return
true
;
}
}
return
false
;
}
UNDO_REMOVED_REASON_UNDO_USED
:
0
UNDO_REMOVED_REASON_SYNC_SIGNIN
:
1
UNDO_REMOVED_REASON_PASSWORD_CHANGE
:
2
UNDO_REMOVED_REASON_BOOKMARK_CHANGE
:
3
UNDO_REMOVED_REASON_OFFER_EXPIRED
:
4
UNDO_REMOVED_REASON_OFFER_REJECTED
:
5
_jsonifyUndoState
(
state
)
{
if
(
!
state
)
{
return
"
null
"
;
}
let
bookmarks
=
state
.
get
(
"
bookmarks
"
)
;
for
(
let
bm
of
bookmarks
)
{
bm
.
lastModified
=
bm
.
lastModified
.
getTime
(
)
;
}
let
serializableState
=
{
bookmarks
logins
:
state
.
get
(
"
logins
"
)
visits
:
state
.
get
(
"
visits
"
)
}
;
return
JSON
.
stringify
(
serializableState
)
;
}
_dejsonifyUndoState
(
state
)
{
state
=
JSON
.
parse
(
state
)
;
if
(
!
state
)
{
return
new
Map
(
)
;
}
for
(
let
bm
of
state
.
bookmarks
)
{
bm
.
lastModified
=
new
Date
(
bm
.
lastModified
)
;
}
return
new
Map
(
[
[
"
bookmarks
"
state
.
bookmarks
]
[
"
logins
"
state
.
logins
]
[
"
visits
"
state
.
visits
]
]
)
;
}
_setImportedItemPrefFromState
(
state
)
{
let
itemsWithData
=
[
]
;
if
(
state
)
{
for
(
let
itemType
of
state
.
keys
(
)
)
{
if
(
state
.
get
(
itemType
)
.
length
)
{
itemsWithData
.
push
(
itemType
)
;
}
}
}
if
(
itemsWithData
.
length
=
=
3
)
{
itemsWithData
=
"
all
"
;
}
else
{
itemsWithData
=
itemsWithData
.
sort
(
)
.
join
(
"
.
"
)
;
}
if
(
itemsWithData
)
{
Preferences
.
set
(
kAutoMigrateImportedItemIds
itemsWithData
)
;
}
}
_saveUndoStateTrackerForShutdown
:
"
not
running
"
async
saveUndoState
(
)
{
let
resolveSavingPromise
;
this
.
_saveUndoStateTrackerForShutdown
=
"
processing
undo
history
"
;
this
.
_savingPromise
=
new
Promise
(
resolve
=
>
{
resolveSavingPromise
=
resolve
;
}
)
;
let
state
=
await
MigrationUtils
.
stopAndRetrieveUndoData
(
)
;
if
(
!
state
|
|
!
[
.
.
.
state
.
values
(
)
]
.
some
(
ary
=
>
ary
.
length
>
0
)
)
{
resolveSavingPromise
(
)
;
return
Promise
.
resolve
(
)
;
}
this
.
_saveUndoStateTrackerForShutdown
=
"
saving
imported
item
list
"
;
this
.
_setImportedItemPrefFromState
(
state
)
;
this
.
_saveUndoStateTrackerForShutdown
=
"
writing
undo
history
"
;
this
.
_undoSavePromise
=
OS
.
File
.
writeAtomic
(
kUndoStateFullPath
this
.
_jsonifyUndoState
(
state
)
{
encoding
:
"
utf
-
8
"
compression
:
"
lz4
"
tmpPath
:
kUndoStateFullPath
+
"
.
tmp
"
}
)
;
this
.
_undoSavePromise
.
then
(
rv
=
>
{
resolveSavingPromise
(
rv
)
;
delete
this
.
_savingPromise
;
}
e
=
>
{
Cu
.
reportError
(
"
Could
not
write
undo
state
for
automatic
migration
.
"
)
;
throw
e
;
}
)
;
return
this
.
_undoSavePromise
;
}
async
_removeUnchangedBookmarks
(
bookmarks
)
{
if
(
!
bookmarks
.
length
)
{
return
;
}
let
guidToLMMap
=
new
Map
(
bookmarks
.
map
(
b
=
>
[
b
.
guid
b
.
lastModified
]
)
)
;
let
bookmarksFromDB
=
[
]
;
let
bmPromises
=
Array
.
from
(
guidToLMMap
.
keys
(
)
)
.
map
(
guid
=
>
{
try
{
return
PlacesUtils
.
bookmarks
.
fetch
(
guid
)
.
then
(
bm
=
>
bm
&
&
bookmarksFromDB
.
push
(
bm
)
(
)
=
>
{
}
)
;
}
catch
(
ex
)
{
}
return
Promise
.
resolve
(
)
;
}
)
;
await
Promise
.
all
(
bmPromises
)
;
let
unchangedBookmarks
=
bookmarksFromDB
.
filter
(
bm
=
>
{
return
bm
.
lastModified
.
getTime
(
)
=
=
guidToLMMap
.
get
(
bm
.
guid
)
.
getTime
(
)
;
}
)
;
function
determineAncestorCount
(
bm
)
{
if
(
bm
.
_ancestorCount
)
{
return
bm
.
_ancestorCount
;
}
let
myCount
=
0
;
let
parentBM
=
unchangedBookmarks
.
find
(
item
=
>
item
.
guid
=
=
bm
.
parentGuid
)
;
if
(
parentBM
)
{
myCount
=
determineAncestorCount
(
parentBM
)
+
1
;
}
bm
.
_ancestorCount
=
myCount
;
return
myCount
;
}
unchangedBookmarks
.
forEach
(
determineAncestorCount
)
;
unchangedBookmarks
.
sort
(
(
a
b
)
=
>
b
.
_ancestorCount
-
a
.
_ancestorCount
)
;
for
(
let
{
guid
}
of
unchangedBookmarks
)
{
try
{
await
PlacesUtils
.
bookmarks
.
remove
(
guid
{
preventRemovalOfNonEmptyFolders
:
true
}
)
;
}
catch
(
err
)
{
if
(
err
&
&
err
.
message
!
=
"
Cannot
remove
a
non
-
empty
folder
.
"
)
{
this
.
_errorMap
.
bookmarks
+
+
;
Cu
.
reportError
(
err
)
;
}
}
}
}
async
_removeUnchangedLogins
(
logins
)
{
for
(
let
login
of
logins
)
{
let
foundLogins
=
LoginHelper
.
searchLoginsWithObject
(
{
guid
:
login
.
guid
}
)
;
if
(
foundLogins
.
length
)
{
let
foundLogin
=
foundLogins
[
0
]
;
foundLogin
.
QueryInterface
(
Ci
.
nsILoginMetaInfo
)
;
if
(
foundLogin
.
timePasswordChanged
=
=
login
.
timePasswordChanged
)
{
try
{
Services
.
logins
.
removeLogin
(
foundLogin
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
"
Failed
to
remove
a
login
for
"
+
foundLogins
.
hostname
)
;
Cu
.
reportError
(
ex
)
;
this
.
_errorMap
.
logins
+
+
;
}
}
}
}
}
async
_removeSomeVisits
(
visits
)
{
for
(
let
urlVisits
of
visits
)
{
let
urlObj
;
try
{
urlObj
=
new
URL
(
urlVisits
.
url
)
;
}
catch
(
ex
)
{
continue
;
}
let
visitData
=
{
url
:
urlObj
beginDate
:
new
Date
(
urlVisits
.
first
)
endDate
:
new
Date
(
urlVisits
.
last
)
limit
:
urlVisits
.
visitCount
}
;
try
{
await
PlacesUtils
.
history
.
removeVisitsByFilter
(
visitData
)
;
}
catch
(
ex
)
{
this
.
_errorMap
.
visits
+
+
;
try
{
visitData
.
url
=
visitData
.
url
.
href
;
}
catch
(
ignoredEx
)
{
}
Cu
.
reportError
(
"
Failed
to
remove
a
visit
:
"
+
JSON
.
stringify
(
visitData
)
)
;
Cu
.
reportError
(
ex
)
;
}
}
}
_maybeOpenUndoSurveyTab
(
chromeWindow
)
{
let
canDoSurveyInLocale
=
false
;
try
{
let
surveyLocales
=
Preferences
.
get
(
kAutoMigrateUndoSurveyLocalePref
"
"
)
;
surveyLocales
=
surveyLocales
.
split
(
"
"
)
.
map
(
str
=
>
str
.
trim
(
)
)
;
surveyLocales
=
new
Set
(
surveyLocales
.
filter
(
str
=
>
!
!
str
)
)
;
canDoSurveyInLocale
=
surveyLocales
.
has
(
Services
.
locale
.
getAppLocaleAsLangTag
(
)
)
;
}
catch
(
ex
)
{
}
let
migrationBrowser
=
this
.
getBrowserUsedForMigration
(
)
;
let
rawURL
=
Preferences
.
get
(
kAutoMigrateUndoSurveyPref
"
"
)
;
if
(
!
canDoSurveyInLocale
|
|
!
migrationBrowser
|
|
!
rawURL
)
{
return
;
}
let
url
=
Services
.
urlFormatter
.
formatURL
(
rawURL
)
;
url
=
url
.
replace
(
"
%
IMPORTEDBROWSER
%
"
encodeURIComponent
(
migrationBrowser
)
)
;
chromeWindow
.
openTrustedLinkIn
(
url
"
tab
"
)
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIObserver
Ci
.
nsINavBookmarkObserver
Ci
.
nsISupportsWeakReference
]
)
undoAutoMigration
(
chromeWindow
)
{
this
.
_maybeOpenUndoSurveyTab
(
chromeWindow
)
;
this
.
undo
(
)
;
}
keepAutoMigration
(
)
{
this
.
_purgeUndoState
(
this
.
UNDO_REMOVED_REASON_OFFER_REJECTED
)
;
}
}
;
AutoMigrate
.
init
(
)
;
