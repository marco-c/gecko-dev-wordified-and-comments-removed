"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
AutoMigrate
"
]
;
const
{
classes
:
Cc
interfaces
:
Ci
results
:
Cr
utils
:
Cu
}
=
Components
;
const
kAutoMigrateEnabledPref
=
"
browser
.
migrate
.
automigrate
.
enabled
"
;
const
kUndoUIEnabledPref
=
"
browser
.
migrate
.
automigrate
.
ui
.
enabled
"
;
const
kAutoMigrateStartedPref
=
"
browser
.
migrate
.
automigrate
.
started
"
;
const
kAutoMigrateFinishedPref
=
"
browser
.
migrate
.
automigrate
.
finished
"
;
const
kAutoMigrateBrowserPref
=
"
browser
.
migrate
.
automigrate
.
browser
"
;
const
kAutoMigrateLastUndoPromptDateMsPref
=
"
browser
.
migrate
.
automigrate
.
lastUndoPromptDateMs
"
;
const
kAutoMigrateDaysToOfferUndoPref
=
"
browser
.
migrate
.
automigrate
.
daysToOfferUndo
"
;
const
kPasswordManagerTopic
=
"
passwordmgr
-
storage
-
changed
"
;
const
kPasswordManagerTopicTypes
=
new
Set
(
[
"
addLogin
"
"
modifyLogin
"
]
)
;
const
kSyncTopic
=
"
fxaccounts
:
onlogin
"
;
const
kNotificationId
=
"
abouthome
-
automigration
-
undo
"
;
Cu
.
import
(
"
resource
:
/
/
/
modules
/
MigrationUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
AutoMigrate
=
{
get
resourceTypesToUse
(
)
{
let
{
BOOKMARKS
HISTORY
PASSWORDS
}
=
Ci
.
nsIBrowserProfileMigrator
;
return
BOOKMARKS
|
HISTORY
|
PASSWORDS
;
}
_checkIfEnabled
(
)
{
let
pref
=
Preferences
.
get
(
kAutoMigrateEnabledPref
false
)
;
if
(
Services
.
prefs
.
prefHasUserValue
(
kAutoMigrateEnabledPref
)
)
{
return
pref
;
}
try
{
let
distributionFile
=
Services
.
dirsvc
.
get
(
"
XREAppDist
"
Ci
.
nsIFile
)
;
distributionFile
.
append
(
"
distribution
.
ini
"
)
;
let
parser
=
Cc
[
"
mozilla
.
org
/
xpcom
/
ini
-
parser
-
factory
;
1
"
]
.
getService
(
Ci
.
nsIINIParserFactory
)
.
createINIParser
(
distributionFile
)
;
return
JSON
.
parse
(
parser
.
getString
(
"
Preferences
"
kAutoMigrateEnabledPref
)
)
;
}
catch
(
ex
)
{
}
return
pref
;
}
init
(
)
{
this
.
enabled
=
this
.
_checkIfEnabled
(
)
;
if
(
this
.
enabled
)
{
this
.
maybeInitUndoObserver
(
)
;
}
}
maybeInitUndoObserver
(
)
{
if
(
!
this
.
canUndo
(
)
)
{
return
;
}
this
.
onItemAdded
=
this
.
onItemMoved
=
this
.
onItemChanged
=
this
.
removeUndoOption
.
bind
(
this
this
.
UNDO_REMOVED_REASON_BOOKMARK_CHANGE
)
;
PlacesUtils
.
addLazyBookmarkObserver
(
this
true
)
;
for
(
let
topic
of
[
kSyncTopic
kPasswordManagerTopic
]
)
{
Services
.
obs
.
addObserver
(
this
topic
true
)
;
}
}
observe
(
subject
topic
data
)
{
if
(
topic
=
=
kPasswordManagerTopic
)
{
if
(
kPasswordManagerTopicTypes
.
has
(
data
)
)
{
let
loginInfo
=
subject
.
QueryInterface
(
Ci
.
nsILoginInfo
)
;
if
(
!
loginInfo
.
hostname
|
|
!
loginInfo
.
hostname
.
startsWith
(
"
chrome
:
/
/
"
)
)
{
this
.
removeUndoOption
(
this
.
UNDO_REMOVED_REASON_PASSWORD_CHANGE
)
;
}
}
}
else
if
(
topic
=
=
kSyncTopic
)
{
this
.
removeUndoOption
(
this
.
UNDO_REMOVED_REASON_SYNC_SIGNIN
)
;
}
}
migrate
(
profileStartup
migratorKey
profileToMigrate
)
{
let
histogram
=
Services
.
telemetry
.
getHistogramById
(
"
FX_STARTUP_MIGRATION_AUTOMATED_IMPORT_PROCESS_SUCCESS
"
)
;
histogram
.
add
(
0
)
;
let
{
migrator
pickedKey
}
=
this
.
pickMigrator
(
migratorKey
)
;
histogram
.
add
(
5
)
;
profileToMigrate
=
this
.
pickProfile
(
migrator
profileToMigrate
)
;
histogram
.
add
(
10
)
;
let
resourceTypes
=
migrator
.
getMigrateData
(
profileToMigrate
profileStartup
)
;
if
(
!
(
resourceTypes
&
this
.
resourceTypesToUse
)
)
{
throw
new
Error
(
"
No
usable
resources
were
found
for
the
selected
browser
!
"
)
;
}
histogram
.
add
(
15
)
;
let
sawErrors
=
false
;
let
migrationObserver
=
(
subject
topic
data
)
=
>
{
if
(
topic
=
=
"
Migration
:
ItemError
"
)
{
sawErrors
=
true
;
}
else
if
(
topic
=
=
"
Migration
:
Ended
"
)
{
histogram
.
add
(
25
)
;
if
(
sawErrors
)
{
histogram
.
add
(
26
)
;
}
Services
.
obs
.
removeObserver
(
migrationObserver
"
Migration
:
Ended
"
)
;
Services
.
obs
.
removeObserver
(
migrationObserver
"
Migration
:
ItemError
"
)
;
Services
.
prefs
.
setCharPref
(
kAutoMigrateStartedPref
startTime
.
toString
(
)
)
;
Services
.
prefs
.
setCharPref
(
kAutoMigrateFinishedPref
Date
.
now
(
)
.
toString
(
)
)
;
Services
.
prefs
.
setCharPref
(
kAutoMigrateBrowserPref
pickedKey
)
;
this
.
maybeInitUndoObserver
(
)
;
}
}
;
Services
.
obs
.
addObserver
(
migrationObserver
"
Migration
:
Ended
"
false
)
;
Services
.
obs
.
addObserver
(
migrationObserver
"
Migration
:
ItemError
"
false
)
;
let
startTime
=
Date
.
now
(
)
;
migrator
.
migrate
(
this
.
resourceTypesToUse
profileStartup
profileToMigrate
)
;
histogram
.
add
(
20
)
;
}
pickMigrator
(
migratorKey
)
{
if
(
!
migratorKey
)
{
let
defaultKey
=
MigrationUtils
.
getMigratorKeyForDefaultBrowser
(
)
;
if
(
!
defaultKey
)
{
throw
new
Error
(
"
Could
not
determine
default
browser
key
to
migrate
from
"
)
;
}
migratorKey
=
defaultKey
;
}
if
(
migratorKey
=
=
"
firefox
"
)
{
throw
new
Error
(
"
Can
'
t
automatically
migrate
from
Firefox
.
"
)
;
}
let
migrator
=
MigrationUtils
.
getMigrator
(
migratorKey
)
;
if
(
!
migrator
)
{
throw
new
Error
(
"
Migrator
specified
or
a
default
was
found
but
the
migrator
object
is
not
available
.
"
)
;
}
return
{
migrator
pickedKey
:
migratorKey
}
;
}
pickProfile
(
migrator
suggestedId
)
{
let
profiles
=
migrator
.
sourceProfiles
;
if
(
profiles
&
&
!
profiles
.
length
)
{
throw
new
Error
(
"
No
profile
data
found
to
migrate
.
"
)
;
}
if
(
suggestedId
)
{
if
(
!
profiles
)
{
throw
new
Error
(
"
Profile
specified
but
only
a
default
profile
found
.
"
)
;
}
let
suggestedProfile
=
profiles
.
find
(
profile
=
>
profile
.
id
=
=
suggestedId
)
;
if
(
!
suggestedProfile
)
{
throw
new
Error
(
"
Profile
specified
was
not
found
.
"
)
;
}
return
suggestedProfile
;
}
if
(
profiles
&
&
profiles
.
length
>
1
)
{
throw
new
Error
(
"
Don
'
t
know
how
to
pick
a
profile
when
more
than
1
profile
is
present
.
"
)
;
}
return
profiles
?
profiles
[
0
]
:
null
;
}
getUndoRange
(
)
{
let
start
finish
;
try
{
start
=
parseInt
(
Preferences
.
get
(
kAutoMigrateStartedPref
"
0
"
)
10
)
;
finish
=
parseInt
(
Preferences
.
get
(
kAutoMigrateFinishedPref
"
0
"
)
10
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
if
(
!
finish
|
|
!
start
)
{
return
null
;
}
return
[
new
Date
(
start
)
new
Date
(
finish
)
]
;
}
canUndo
(
)
{
return
!
!
this
.
getUndoRange
(
)
;
}
undo
:
Task
.
async
(
function
*
(
)
{
let
histogram
=
Services
.
telemetry
.
getHistogramById
(
"
FX_STARTUP_MIGRATION_AUTOMATED_IMPORT_UNDO
"
)
;
histogram
.
add
(
0
)
;
if
(
!
this
.
canUndo
(
)
)
{
histogram
.
add
(
5
)
;
throw
new
Error
(
"
Can
'
t
undo
!
"
)
;
}
histogram
.
add
(
10
)
;
yield
PlacesUtils
.
bookmarks
.
eraseEverything
(
)
;
histogram
.
add
(
15
)
;
let
range
=
this
.
getUndoRange
(
)
;
yield
PlacesUtils
.
history
.
removeVisitsByFilter
(
{
beginDate
:
new
Date
(
0
)
endDate
:
range
[
1
]
}
)
;
histogram
.
add
(
20
)
;
try
{
Services
.
logins
.
removeAllLogins
(
)
;
}
catch
(
ex
)
{
}
histogram
.
add
(
25
)
;
this
.
removeUndoOption
(
this
.
UNDO_REMOVED_REASON_UNDO_USED
)
;
histogram
.
add
(
30
)
;
}
)
removeUndoOption
(
reason
)
{
for
(
let
topic
of
[
kSyncTopic
kPasswordManagerTopic
]
)
{
try
{
Services
.
obs
.
removeObserver
(
this
topic
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
"
Error
removing
observer
for
"
+
topic
+
"
:
"
+
ex
)
;
}
}
try
{
PlacesUtils
.
removeLazyBookmarkObserver
(
this
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
"
Error
removing
lazy
bookmark
observer
:
"
+
ex
)
;
}
let
migrationBrowser
=
Preferences
.
get
(
kAutoMigrateBrowserPref
"
unknown
"
)
;
Services
.
prefs
.
clearUserPref
(
kAutoMigrateStartedPref
)
;
Services
.
prefs
.
clearUserPref
(
kAutoMigrateFinishedPref
)
;
Services
.
prefs
.
clearUserPref
(
kAutoMigrateBrowserPref
)
;
let
browserWindows
=
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
;
while
(
browserWindows
.
hasMoreElements
(
)
)
{
let
win
=
browserWindows
.
getNext
(
)
;
if
(
!
win
.
closed
)
{
for
(
let
browser
of
win
.
gBrowser
.
browsers
)
{
let
nb
=
win
.
gBrowser
.
getNotificationBox
(
browser
)
;
let
notification
=
nb
.
getNotificationWithValue
(
kNotificationId
)
;
if
(
notification
)
{
nb
.
removeNotification
(
notification
)
;
}
}
}
}
let
histogram
=
Services
.
telemetry
.
getKeyedHistogramById
(
"
FX_STARTUP_MIGRATION_UNDO_REASON
"
)
;
histogram
.
add
(
migrationBrowser
reason
)
;
}
getBrowserUsedForMigration
(
)
{
let
browserId
=
Services
.
prefs
.
getCharPref
(
kAutoMigrateBrowserPref
)
;
if
(
browserId
)
{
return
MigrationUtils
.
getBrowserName
(
browserId
)
;
}
return
null
;
}
maybeShowUndoNotification
(
target
)
{
if
(
!
this
.
canUndo
(
)
|
|
target
.
currentURI
.
spec
!
=
"
about
:
home
"
|
|
!
Preferences
.
get
(
kUndoUIEnabledPref
false
)
)
{
return
;
}
let
win
=
target
.
ownerGlobal
;
let
notificationBox
=
win
.
gBrowser
.
getNotificationBox
(
target
)
;
if
(
!
notificationBox
|
|
notificationBox
.
getNotificationWithValue
(
"
abouthome
-
automigration
-
undo
"
)
)
{
return
;
}
if
(
!
this
.
shouldStillShowUndoPrompt
(
)
)
{
this
.
removeUndoOption
(
this
.
UNDO_REMOVED_REASON_OFFER_EXPIRED
)
;
return
;
}
let
browserName
=
this
.
getBrowserUsedForMigration
(
)
;
let
message
;
if
(
browserName
)
{
message
=
MigrationUtils
.
getLocalizedString
(
"
automigration
.
undo
.
message
"
[
browserName
]
)
;
}
else
{
message
=
MigrationUtils
.
getLocalizedString
(
"
automigration
.
undo
.
unknownBrowserMessage
"
)
;
}
let
buttons
=
[
{
label
:
MigrationUtils
.
getLocalizedString
(
"
automigration
.
undo
.
keep
.
label
"
)
accessKey
:
MigrationUtils
.
getLocalizedString
(
"
automigration
.
undo
.
keep
.
accesskey
"
)
callback
:
(
)
=
>
{
this
.
removeUndoOption
(
this
.
UNDO_REMOVED_REASON_OFFER_REJECTED
)
;
}
}
{
label
:
MigrationUtils
.
getLocalizedString
(
"
automigration
.
undo
.
dontkeep
.
label
"
)
accessKey
:
MigrationUtils
.
getLocalizedString
(
"
automigration
.
undo
.
dontkeep
.
accesskey
"
)
callback
:
(
)
=
>
{
this
.
undo
(
)
;
}
}
]
;
notificationBox
.
appendNotification
(
message
kNotificationId
null
notificationBox
.
PRIORITY_INFO_HIGH
buttons
)
;
}
shouldStillShowUndoPrompt
(
)
{
let
today
=
new
Date
(
)
;
today
=
new
Date
(
today
.
getFullYear
(
)
today
.
getMonth
(
)
today
.
getDate
(
)
)
;
let
previousPromptDateMsStr
=
Preferences
.
get
(
kAutoMigrateLastUndoPromptDateMsPref
"
0
"
)
;
let
previousPromptDate
=
new
Date
(
parseInt
(
previousPromptDateMsStr
10
)
)
;
if
(
previousPromptDate
<
today
)
{
let
remainingDays
=
Preferences
.
get
(
kAutoMigrateDaysToOfferUndoPref
4
)
-
1
;
Preferences
.
set
(
kAutoMigrateDaysToOfferUndoPref
remainingDays
)
;
Preferences
.
set
(
kAutoMigrateLastUndoPromptDateMsPref
today
.
valueOf
(
)
.
toString
(
)
)
;
if
(
remainingDays
<
=
0
)
{
return
false
;
}
}
return
true
;
}
UNDO_REMOVED_REASON_UNDO_USED
:
0
UNDO_REMOVED_REASON_SYNC_SIGNIN
:
1
UNDO_REMOVED_REASON_PASSWORD_CHANGE
:
2
UNDO_REMOVED_REASON_BOOKMARK_CHANGE
:
3
UNDO_REMOVED_REASON_OFFER_EXPIRED
:
4
UNDO_REMOVED_REASON_OFFER_REJECTED
:
5
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIObserver
Ci
.
nsINavBookmarkObserver
Ci
.
nsISupportsWeakReference
]
)
}
;
AutoMigrate
.
init
(
)
;
