"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
ChromeMigrationUtils
"
]
;
const
{
classes
:
Cc
interfaces
:
Ci
results
:
Cr
utils
:
Cu
}
=
Components
;
const
FILE_INPUT_STREAM_CID
=
"
mozilla
.
org
/
network
/
file
-
input
-
stream
;
1
"
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
this
.
ChromeMigrationUtils
=
{
_chromeUserDataPath
:
null
_extensionVersionDirectoryNames
:
{
}
_extensionLocaleStrings
:
{
}
async
getExtensionList
(
profileId
=
this
.
getLastUsedProfileId
(
)
)
{
let
path
=
this
.
getExtensionPath
(
profileId
)
;
let
iterator
=
new
OS
.
File
.
DirectoryIterator
(
path
)
;
let
extensionList
=
[
]
;
await
iterator
.
forEach
(
async
entry
=
>
{
if
(
entry
.
isDir
)
{
let
extensionInformation
=
await
this
.
getExtensionInformation
(
entry
.
name
profileId
)
;
if
(
extensionInformation
)
{
extensionList
.
push
(
extensionInformation
)
;
}
}
}
)
.
catch
(
ex
=
>
Cu
.
reportError
(
ex
)
)
;
return
extensionList
;
}
async
getExtensionInformation
(
extensionId
profileId
=
this
.
getLastUsedProfileId
(
)
)
{
let
extensionInformation
=
null
;
try
{
let
manifestPath
=
this
.
getExtensionPath
(
profileId
)
;
manifestPath
=
OS
.
Path
.
join
(
manifestPath
extensionId
)
;
let
directories
=
await
this
.
_getSortedByVersionSubDirectoryNames
(
manifestPath
)
;
if
(
!
directories
[
0
]
)
{
return
null
;
}
manifestPath
=
OS
.
Path
.
join
(
manifestPath
directories
[
0
]
"
manifest
.
json
"
)
;
let
manifest
=
await
OS
.
File
.
read
(
manifestPath
{
encoding
:
"
utf
-
8
"
}
)
;
manifest
=
JSON
.
parse
(
manifest
)
;
if
(
!
manifest
.
app
)
{
const
DEFAULT_LOCALE
=
manifest
.
default_locale
;
let
name
=
await
this
.
_getLocaleString
(
manifest
.
name
DEFAULT_LOCALE
extensionId
profileId
)
;
let
description
=
await
this
.
_getLocaleString
(
manifest
.
description
DEFAULT_LOCALE
extensionId
profileId
)
;
if
(
name
)
{
extensionInformation
=
{
id
:
extensionId
name
description
}
;
}
else
{
throw
new
Error
(
"
Cannot
read
the
Chrome
extension
'
s
name
property
.
"
)
;
}
}
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
return
extensionInformation
;
}
async
_getLocaleString
(
key
locale
extensionId
profileId
)
{
if
(
!
key
.
startsWith
(
"
__MSG_
"
)
|
|
!
key
.
endsWith
(
"
__
"
)
)
{
return
key
;
}
let
localeString
=
null
;
try
{
let
localeFile
;
if
(
this
.
_extensionLocaleStrings
[
profileId
]
&
&
this
.
_extensionLocaleStrings
[
profileId
]
[
extensionId
]
)
{
localeFile
=
this
.
_extensionLocaleStrings
[
profileId
]
[
extensionId
]
;
}
else
{
if
(
!
this
.
_extensionLocaleStrings
[
profileId
]
)
{
this
.
_extensionLocaleStrings
[
profileId
]
=
{
}
;
}
let
localeFilePath
=
this
.
getExtensionPath
(
profileId
)
;
localeFilePath
=
OS
.
Path
.
join
(
localeFilePath
extensionId
)
;
let
directories
=
await
this
.
_getSortedByVersionSubDirectoryNames
(
localeFilePath
)
;
localeFilePath
=
OS
.
Path
.
join
(
localeFilePath
directories
[
0
]
"
_locales
"
locale
"
messages
.
json
"
)
;
localeFile
=
await
OS
.
File
.
read
(
localeFilePath
{
encoding
:
"
utf
-
8
"
}
)
;
localeFile
=
JSON
.
parse
(
localeFile
)
;
this
.
_extensionLocaleStrings
[
profileId
]
[
extensionId
]
=
localeFile
;
}
const
PREFIX_LENGTH
=
6
;
const
SUFFIX_LENGTH
=
2
;
key
=
key
.
substring
(
PREFIX_LENGTH
key
.
length
-
SUFFIX_LENGTH
)
;
if
(
localeFile
[
key
]
&
&
localeFile
[
key
]
.
message
)
{
localeString
=
localeFile
[
key
]
.
message
;
}
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
return
localeString
;
}
async
isExtensionInstalled
(
extensionId
profileId
=
this
.
getLastUsedProfileId
(
)
)
{
let
extensionPath
=
this
.
getExtensionPath
(
profileId
)
;
let
isInstalled
=
await
OS
.
File
.
exists
(
OS
.
Path
.
join
(
extensionPath
extensionId
)
)
;
return
isInstalled
;
}
getLastUsedProfileId
(
)
{
let
localState
=
this
.
getLocalState
(
)
;
return
localState
?
localState
.
profile
.
last_used
:
"
Default
"
;
}
getLocalState
(
)
{
let
localStateFile
=
new
FileUtils
.
File
(
this
.
getChromeUserDataPath
(
)
)
;
localStateFile
.
append
(
"
Local
State
"
)
;
if
(
!
localStateFile
.
exists
(
)
)
throw
new
Error
(
"
Chrome
'
s
'
Local
State
'
file
does
not
exist
.
"
)
;
if
(
!
localStateFile
.
isReadable
(
)
)
throw
new
Error
(
"
Chrome
'
s
'
Local
State
'
file
could
not
be
read
.
"
)
;
let
localState
=
null
;
try
{
let
fstream
=
Cc
[
FILE_INPUT_STREAM_CID
]
.
createInstance
(
Ci
.
nsIFileInputStream
)
;
fstream
.
init
(
localStateFile
-
1
0
0
)
;
let
inputStream
=
NetUtil
.
readInputStreamToString
(
fstream
fstream
.
available
(
)
{
charset
:
"
UTF
-
8
"
}
)
;
localState
=
JSON
.
parse
(
inputStream
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
throw
ex
;
}
return
localState
;
}
getExtensionPath
(
profileId
)
{
return
OS
.
Path
.
join
(
this
.
getChromeUserDataPath
(
)
profileId
"
Extensions
"
)
;
}
getChromeUserDataPath
(
)
{
if
(
!
this
.
_chromeUserDataPath
)
{
this
.
_chromeUserDataPath
=
this
.
getDataPath
(
"
Chrome
"
)
;
}
return
this
.
_chromeUserDataPath
;
}
getDataPath
(
chromeProjectName
)
{
const
SUB_DIRECTORIES
=
{
win
:
{
Chrome
:
[
"
Google
"
"
Chrome
"
]
Chromium
:
[
"
Chromium
"
]
Canary
:
[
"
Google
"
"
Chrome
SxS
"
]
}
macosx
:
{
Chrome
:
[
"
Google
"
"
Chrome
"
]
Chromium
:
[
"
Chromium
"
]
Canary
:
[
"
Google
"
"
Chrome
Canary
"
]
}
linux
:
{
Chrome
:
[
"
google
-
chrome
"
]
Chromium
:
[
"
chromium
"
]
}
}
;
let
dirKey
subfolders
;
subfolders
=
SUB_DIRECTORIES
[
AppConstants
.
platform
]
[
chromeProjectName
]
;
if
(
!
subfolders
)
{
return
null
;
}
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
dirKey
=
"
winLocalAppDataDir
"
;
subfolders
=
subfolders
.
concat
(
[
"
User
Data
"
]
)
;
}
else
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
dirKey
=
"
macUserLibDir
"
;
subfolders
=
[
"
Application
Support
"
]
.
concat
(
subfolders
)
;
}
else
{
dirKey
=
"
homeDir
"
;
subfolders
=
[
"
.
config
"
]
.
concat
(
subfolders
)
;
}
subfolders
.
unshift
(
OS
.
Constants
.
Path
[
dirKey
]
)
;
return
OS
.
Path
.
join
(
.
.
.
subfolders
)
;
}
async
_getSortedByVersionSubDirectoryNames
(
path
)
{
if
(
this
.
_extensionVersionDirectoryNames
[
path
]
)
{
return
this
.
_extensionVersionDirectoryNames
[
path
]
;
}
let
iterator
=
new
OS
.
File
.
DirectoryIterator
(
path
)
;
let
entries
=
[
]
;
await
iterator
.
forEach
(
async
entry
=
>
{
if
(
entry
.
isDir
)
{
entries
.
push
(
entry
.
name
)
;
}
}
)
.
catch
(
ex
=
>
{
Cu
.
reportError
(
ex
)
;
entries
=
[
]
;
}
)
;
entries
.
sort
(
(
a
b
)
=
>
Services
.
vc
.
compare
(
b
a
)
)
;
this
.
_extensionVersionDirectoryNames
[
path
]
=
entries
;
return
entries
;
}
}
;
