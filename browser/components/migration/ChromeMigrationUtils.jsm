"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
ChromeMigrationUtils
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AppConstants
:
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
LoginHelper
:
"
resource
:
/
/
gre
/
modules
/
LoginHelper
.
jsm
"
MigrationUtils
:
"
resource
:
/
/
/
modules
/
MigrationUtils
.
jsm
"
OS
:
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
}
)
;
const
S100NS_FROM1601TO1970
=
0x19db1ded53e8000
;
const
S100NS_PER_MS
=
10
;
var
ChromeMigrationUtils
=
{
CONTEXTUAL_LOGIN_IMPORT_BROWSERS
:
[
"
chrome
"
"
chromium
-
edge
"
"
chromium
"
]
_extensionVersionDirectoryNames
:
{
}
_extensionLocaleStrings
:
{
}
get
supportsLoginsForPlatform
(
)
{
return
[
"
macosx
"
"
win
"
]
.
includes
(
AppConstants
.
platform
)
;
}
async
getExtensionList
(
profileId
)
{
if
(
profileId
=
=
=
undefined
)
{
profileId
=
await
this
.
getLastUsedProfileId
(
)
;
}
let
path
=
this
.
getExtensionPath
(
profileId
)
;
let
iterator
=
new
OS
.
File
.
DirectoryIterator
(
path
)
;
let
extensionList
=
[
]
;
await
iterator
.
forEach
(
async
entry
=
>
{
if
(
entry
.
isDir
)
{
let
extensionInformation
=
await
this
.
getExtensionInformation
(
entry
.
name
profileId
)
;
if
(
extensionInformation
)
{
extensionList
.
push
(
extensionInformation
)
;
}
}
}
)
.
catch
(
ex
=
>
Cu
.
reportError
(
ex
)
)
;
return
extensionList
;
}
async
getExtensionInformation
(
extensionId
profileId
)
{
if
(
profileId
=
=
=
undefined
)
{
profileId
=
await
this
.
getLastUsedProfileId
(
)
;
}
let
extensionInformation
=
null
;
try
{
let
manifestPath
=
this
.
getExtensionPath
(
profileId
)
;
manifestPath
=
OS
.
Path
.
join
(
manifestPath
extensionId
)
;
let
directories
=
await
this
.
_getSortedByVersionSubDirectoryNames
(
manifestPath
)
;
if
(
!
directories
[
0
]
)
{
return
null
;
}
manifestPath
=
OS
.
Path
.
join
(
manifestPath
directories
[
0
]
"
manifest
.
json
"
)
;
let
manifest
=
await
OS
.
File
.
read
(
manifestPath
{
encoding
:
"
utf
-
8
"
}
)
;
manifest
=
JSON
.
parse
(
manifest
)
;
if
(
!
manifest
.
app
)
{
const
DEFAULT_LOCALE
=
manifest
.
default_locale
;
let
name
=
await
this
.
_getLocaleString
(
manifest
.
name
DEFAULT_LOCALE
extensionId
profileId
)
;
let
description
=
await
this
.
_getLocaleString
(
manifest
.
description
DEFAULT_LOCALE
extensionId
profileId
)
;
if
(
name
)
{
extensionInformation
=
{
id
:
extensionId
name
description
}
;
}
else
{
throw
new
Error
(
"
Cannot
read
the
Chrome
extension
'
s
name
property
.
"
)
;
}
}
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
return
extensionInformation
;
}
async
_getLocaleString
(
key
locale
extensionId
profileId
)
{
if
(
!
key
.
startsWith
(
"
__MSG_
"
)
|
|
!
key
.
endsWith
(
"
__
"
)
)
{
return
key
;
}
let
localeString
=
null
;
try
{
let
localeFile
;
if
(
this
.
_extensionLocaleStrings
[
profileId
]
&
&
this
.
_extensionLocaleStrings
[
profileId
]
[
extensionId
]
)
{
localeFile
=
this
.
_extensionLocaleStrings
[
profileId
]
[
extensionId
]
;
}
else
{
if
(
!
this
.
_extensionLocaleStrings
[
profileId
]
)
{
this
.
_extensionLocaleStrings
[
profileId
]
=
{
}
;
}
let
localeFilePath
=
this
.
getExtensionPath
(
profileId
)
;
localeFilePath
=
OS
.
Path
.
join
(
localeFilePath
extensionId
)
;
let
directories
=
await
this
.
_getSortedByVersionSubDirectoryNames
(
localeFilePath
)
;
localeFilePath
=
OS
.
Path
.
join
(
localeFilePath
directories
[
0
]
"
_locales
"
locale
"
messages
.
json
"
)
;
localeFile
=
await
OS
.
File
.
read
(
localeFilePath
{
encoding
:
"
utf
-
8
"
}
)
;
localeFile
=
JSON
.
parse
(
localeFile
)
;
this
.
_extensionLocaleStrings
[
profileId
]
[
extensionId
]
=
localeFile
;
}
const
PREFIX_LENGTH
=
6
;
const
SUFFIX_LENGTH
=
2
;
key
=
key
.
substring
(
PREFIX_LENGTH
key
.
length
-
SUFFIX_LENGTH
)
;
if
(
localeFile
[
key
]
&
&
localeFile
[
key
]
.
message
)
{
localeString
=
localeFile
[
key
]
.
message
;
}
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
return
localeString
;
}
async
isExtensionInstalled
(
extensionId
profileId
)
{
if
(
profileId
=
=
=
undefined
)
{
profileId
=
await
this
.
getLastUsedProfileId
(
)
;
}
let
extensionPath
=
this
.
getExtensionPath
(
profileId
)
;
let
isInstalled
=
await
OS
.
File
.
exists
(
OS
.
Path
.
join
(
extensionPath
extensionId
)
)
;
return
isInstalled
;
}
async
getLastUsedProfileId
(
)
{
let
localState
=
await
this
.
getLocalState
(
)
;
return
localState
?
localState
.
profile
.
last_used
:
"
Default
"
;
}
async
getLocalState
(
dataPath
=
"
Chrome
"
)
{
let
localState
=
null
;
try
{
let
localStatePath
=
OS
.
Path
.
join
(
this
.
getDataPath
(
dataPath
)
"
Local
State
"
)
;
let
localStateJson
=
await
OS
.
File
.
read
(
localStatePath
{
encoding
:
"
utf
-
8
"
}
)
;
localState
=
JSON
.
parse
(
localStateJson
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
throw
ex
;
}
return
localState
;
}
getExtensionPath
(
profileId
)
{
return
OS
.
Path
.
join
(
this
.
getDataPath
(
)
profileId
"
Extensions
"
)
;
}
getDataPath
(
chromeProjectName
=
"
Chrome
"
)
{
const
SUB_DIRECTORIES
=
{
win
:
{
Chrome
:
[
"
Google
"
"
Chrome
"
]
"
Chrome
Beta
"
:
[
"
Google
"
"
Chrome
Beta
"
]
Chromium
:
[
"
Chromium
"
]
Canary
:
[
"
Google
"
"
Chrome
SxS
"
]
Edge
:
[
"
Microsoft
"
"
Edge
"
]
"
Edge
Beta
"
:
[
"
Microsoft
"
"
Edge
Beta
"
]
}
macosx
:
{
Chrome
:
[
"
Google
"
"
Chrome
"
]
Chromium
:
[
"
Chromium
"
]
Canary
:
[
"
Google
"
"
Chrome
Canary
"
]
Edge
:
[
"
Microsoft
Edge
"
]
"
Edge
Beta
"
:
[
"
Microsoft
Edge
Beta
"
]
}
linux
:
{
Chrome
:
[
"
google
-
chrome
"
]
"
Chrome
Beta
"
:
[
"
google
-
chrome
-
beta
"
]
"
Chrome
Dev
"
:
[
"
google
-
chrome
-
unstable
"
]
Chromium
:
[
"
chromium
"
]
}
}
;
let
dirKey
subfolders
;
subfolders
=
SUB_DIRECTORIES
[
AppConstants
.
platform
]
[
chromeProjectName
]
;
if
(
!
subfolders
)
{
return
null
;
}
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
dirKey
=
"
winLocalAppDataDir
"
;
subfolders
=
subfolders
.
concat
(
[
"
User
Data
"
]
)
;
}
else
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
dirKey
=
"
macUserLibDir
"
;
subfolders
=
[
"
Application
Support
"
]
.
concat
(
subfolders
)
;
}
else
{
dirKey
=
"
homeDir
"
;
subfolders
=
[
"
.
config
"
]
.
concat
(
subfolders
)
;
}
subfolders
.
unshift
(
OS
.
Constants
.
Path
[
dirKey
]
)
;
return
OS
.
Path
.
join
(
.
.
.
subfolders
)
;
}
async
_getSortedByVersionSubDirectoryNames
(
path
)
{
if
(
this
.
_extensionVersionDirectoryNames
[
path
]
)
{
return
this
.
_extensionVersionDirectoryNames
[
path
]
;
}
let
iterator
=
new
OS
.
File
.
DirectoryIterator
(
path
)
;
let
entries
=
[
]
;
await
iterator
.
forEach
(
async
entry
=
>
{
if
(
entry
.
isDir
)
{
entries
.
push
(
entry
.
name
)
;
}
}
)
.
catch
(
ex
=
>
{
Cu
.
reportError
(
ex
)
;
entries
=
[
]
;
}
)
;
entries
.
sort
(
(
a
b
)
=
>
Services
.
vc
.
compare
(
b
a
)
)
;
this
.
_extensionVersionDirectoryNames
[
path
]
=
entries
;
return
entries
;
}
chromeTimeToDate
(
aTime
aFallbackValue
)
{
if
(
!
aTime
)
{
return
new
Date
(
aFallbackValue
)
;
}
return
new
Date
(
(
aTime
*
S100NS_PER_MS
-
S100NS_FROM1601TO1970
)
/
10000
)
;
}
dateToChromeTime
(
aDate
)
{
return
(
aDate
*
10000
+
S100NS_FROM1601TO1970
)
/
S100NS_PER_MS
;
}
_importableLoginsCache
:
null
async
getImportableLogins
(
formOrigin
)
{
if
(
!
this
.
supportsLoginsForPlatform
)
{
return
undefined
;
}
if
(
!
this
.
_importableLoginsCache
)
{
this
.
_importableLoginsCache
=
new
Map
(
)
;
for
(
const
browserId
of
this
.
CONTEXTUAL_LOGIN_IMPORT_BROWSERS
)
{
const
migrator
=
await
MigrationUtils
.
getMigrator
(
browserId
)
;
if
(
!
migrator
)
{
continue
;
}
const
dataPath
=
await
migrator
.
wrappedJSObject
.
_getChromeUserDataPathIfExists
(
)
;
for
(
const
profile
of
await
migrator
.
getSourceProfiles
(
)
)
{
const
path
=
OS
.
Path
.
join
(
dataPath
profile
.
id
"
Login
Data
"
)
;
if
(
!
(
await
OS
.
File
.
exists
(
path
)
)
)
{
Cu
.
reportError
(
Missing
file
at
{
path
}
)
;
continue
;
}
try
{
for
(
const
row
of
await
MigrationUtils
.
getRowsFromDBWithoutLocks
(
path
Importable
{
browserId
}
logins
SELECT
origin_url
FROM
logins
WHERE
blacklisted_by_user
=
0
)
)
{
const
url
=
row
.
getString
(
0
)
;
try
{
const
origin
=
LoginHelper
.
getLoginOrigin
(
url
)
;
const
entries
=
this
.
_importableLoginsCache
.
get
(
origin
)
|
|
[
]
;
if
(
!
entries
.
length
)
{
this
.
_importableLoginsCache
.
set
(
origin
entries
)
;
}
if
(
!
entries
.
includes
(
browserId
)
)
{
entries
.
push
(
browserId
)
;
}
}
catch
(
ex
)
{
Cu
.
reportError
(
Failed
to
process
importable
url
{
url
}
from
{
browserId
}
{
ex
}
)
;
}
}
}
catch
(
ex
)
{
Cu
.
reportError
(
Failed
to
get
importable
logins
from
{
browserId
}
{
ex
}
)
;
}
}
}
}
return
this
.
_importableLoginsCache
.
get
(
formOrigin
)
;
}
}
;
