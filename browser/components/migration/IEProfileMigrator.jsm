"
use
strict
"
;
const
kLoginsKey
=
"
Software
\
\
Microsoft
\
\
Internet
Explorer
\
\
IntelliForms
\
\
Storage2
"
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
const
{
OS
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
MigrationUtils
MigratorPrototype
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
/
modules
/
MigrationUtils
.
jsm
"
)
;
const
{
MSMigrationUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
/
modules
/
MSMigrationUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ctypes
"
"
resource
:
/
/
gre
/
modules
/
ctypes
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PlacesUtils
"
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
OSCrypto
"
"
resource
:
/
/
gre
/
modules
/
OSCrypto
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
URL
"
]
)
;
function
History
(
)
{
}
History
.
prototype
=
{
type
:
MigrationUtils
.
resourceTypes
.
HISTORY
get
exists
(
)
{
return
true
;
}
migrate
:
function
H_migrate
(
aCallback
)
{
let
pageInfos
=
[
]
;
let
typedURLs
=
MSMigrationUtils
.
getTypedURLs
(
"
Software
\
\
Microsoft
\
\
Internet
Explorer
"
)
;
for
(
let
entry
of
Cc
[
"
mozilla
.
org
/
profile
/
migrator
/
iehistoryenumerator
;
1
"
]
.
createInstance
(
Ci
.
nsISimpleEnumerator
)
)
{
let
url
=
entry
.
get
(
"
uri
"
)
.
QueryInterface
(
Ci
.
nsIURI
)
;
if
(
!
[
"
http
"
"
https
"
"
ftp
"
"
file
"
]
.
includes
(
url
.
scheme
)
)
{
continue
;
}
let
title
=
entry
.
get
(
"
title
"
)
;
if
(
title
.
length
=
=
0
)
{
continue
;
}
let
transition
=
typedURLs
.
has
(
url
.
spec
)
?
PlacesUtils
.
history
.
TRANSITIONS
.
LINK
:
PlacesUtils
.
history
.
TRANSITIONS
.
TYPED
;
let
time
=
entry
.
get
(
"
time
"
)
;
pageInfos
.
push
(
{
url
title
visits
:
[
{
transition
date
:
time
?
PlacesUtils
.
toDate
(
entry
.
get
(
"
time
"
)
)
:
new
Date
(
)
}
]
}
)
;
}
if
(
pageInfos
.
length
=
=
0
)
{
aCallback
(
true
)
;
return
;
}
MigrationUtils
.
insertVisitsWrapper
(
pageInfos
)
.
then
(
(
)
=
>
aCallback
(
true
)
(
)
=
>
aCallback
(
false
)
)
;
}
}
;
function
IE7FormPasswords
(
)
{
this
.
name
=
"
IE7FormPasswords
"
;
}
IE7FormPasswords
.
prototype
=
{
type
:
MigrationUtils
.
resourceTypes
.
PASSWORDS
get
exists
(
)
{
if
(
AppConstants
.
isPlatformAndVersionAtLeast
(
"
win
"
"
6
.
2
"
)
)
{
return
false
;
}
try
{
let
nsIWindowsRegKey
=
Ci
.
nsIWindowsRegKey
;
let
key
=
Cc
[
"
mozilla
.
org
/
windows
-
registry
-
key
;
1
"
]
.
createInstance
(
nsIWindowsRegKey
)
;
key
.
open
(
nsIWindowsRegKey
.
ROOT_KEY_CURRENT_USER
kLoginsKey
nsIWindowsRegKey
.
ACCESS_READ
)
;
let
count
=
key
.
valueCount
;
key
.
close
(
)
;
return
count
>
0
;
}
catch
(
e
)
{
return
false
;
}
}
async
migrate
(
aCallback
)
{
let
uris
=
[
]
;
for
(
let
entry
of
Cc
[
"
mozilla
.
org
/
profile
/
migrator
/
iehistoryenumerator
;
1
"
]
.
createInstance
(
Ci
.
nsISimpleEnumerator
)
)
{
let
uri
=
entry
.
get
(
"
uri
"
)
.
QueryInterface
(
Ci
.
nsIURI
)
;
if
(
!
[
"
http
"
"
https
"
"
ftp
"
]
.
includes
(
uri
.
scheme
)
)
{
continue
;
}
uris
.
push
(
uri
)
;
}
await
this
.
_migrateURIs
(
uris
)
;
aCallback
(
true
)
;
}
async
_migrateURIs
(
uris
)
{
this
.
ctypesKernelHelpers
=
new
MSMigrationUtils
.
CtypesKernelHelpers
(
)
;
this
.
_crypto
=
new
OSCrypto
(
)
;
let
nsIWindowsRegKey
=
Ci
.
nsIWindowsRegKey
;
let
key
=
Cc
[
"
mozilla
.
org
/
windows
-
registry
-
key
;
1
"
]
.
createInstance
(
nsIWindowsRegKey
)
;
key
.
open
(
nsIWindowsRegKey
.
ROOT_KEY_CURRENT_USER
kLoginsKey
nsIWindowsRegKey
.
ACCESS_READ
)
;
let
urlsSet
=
new
Set
(
)
;
let
successfullyDecryptedValues
=
0
;
let
logins
=
[
]
;
for
(
let
uri
of
uris
)
{
try
{
let
urlObject
=
new
URL
(
uri
.
spec
)
;
let
url
=
urlObject
.
origin
+
urlObject
.
pathname
;
if
(
urlsSet
.
has
(
url
)
)
{
continue
;
}
urlsSet
.
add
(
url
)
;
let
hashStr
=
this
.
_crypto
.
getIELoginHash
(
url
)
;
if
(
!
key
.
hasValue
(
hashStr
)
)
{
continue
;
}
let
value
=
key
.
readBinaryValue
(
hashStr
)
;
if
(
value
=
=
null
)
{
continue
;
}
let
data
;
try
{
data
=
this
.
_crypto
.
decryptData
(
value
url
true
)
;
}
catch
(
e
)
{
continue
;
}
let
ieLogins
=
this
.
_extractDetails
(
data
uri
)
;
if
(
ieLogins
.
length
)
{
successfullyDecryptedValues
+
+
;
}
for
(
let
ieLogin
of
ieLogins
)
{
logins
.
push
(
{
username
:
ieLogin
.
username
password
:
ieLogin
.
password
hostname
:
ieLogin
.
url
timeCreated
:
ieLogin
.
creation
}
)
;
}
}
catch
(
e
)
{
Cu
.
reportError
(
"
Error
while
importing
logins
for
"
+
uri
.
spec
+
"
:
"
+
e
)
;
}
}
if
(
logins
.
length
>
0
)
{
await
MigrationUtils
.
insertLoginsWrapper
(
logins
)
;
}
if
(
successfullyDecryptedValues
<
key
.
valueCount
)
{
Cu
.
reportError
(
"
We
failed
to
decrypt
and
import
some
logins
.
"
+
"
This
is
likely
because
we
didn
'
t
find
the
URLs
where
these
"
+
"
passwords
were
submitted
in
the
IE
history
and
which
are
needed
to
be
used
"
+
"
as
keys
in
the
decryption
.
"
)
;
}
key
.
close
(
)
;
this
.
_crypto
.
finalize
(
)
;
this
.
ctypesKernelHelpers
.
finalize
(
)
;
}
_crypto
:
null
_extractDetails
(
data
uri
)
{
let
loginData
=
new
ctypes
.
StructType
(
"
loginData
"
[
{
"
unknown1
"
:
ctypes
.
uint32_t
}
{
"
headerSize
"
:
ctypes
.
uint32_t
}
{
"
dataSize
"
:
ctypes
.
uint32_t
}
{
"
unknown2
"
:
ctypes
.
uint32_t
}
{
"
unknown3
"
:
ctypes
.
uint32_t
}
{
"
dataMax
"
:
ctypes
.
uint32_t
}
{
"
unknown4
"
:
ctypes
.
uint32_t
}
{
"
unknown5
"
:
ctypes
.
uint32_t
}
{
"
unknown6
"
:
ctypes
.
uint32_t
}
]
)
;
let
loginItem
=
new
ctypes
.
StructType
(
"
loginItem
"
[
{
"
usernameOffset
"
:
ctypes
.
uint32_t
}
{
"
loDateTime
"
:
ctypes
.
uint32_t
}
{
"
hiDateTime
"
:
ctypes
.
uint32_t
}
{
"
foo
"
:
ctypes
.
uint32_t
}
{
"
passwordOffset
"
:
ctypes
.
uint32_t
}
{
"
unknown1
"
:
ctypes
.
uint32_t
}
{
"
unknown2
"
:
ctypes
.
uint32_t
}
{
"
unknown3
"
:
ctypes
.
uint32_t
}
]
)
;
let
url
=
uri
.
prePath
;
let
results
=
[
]
;
let
arr
=
this
.
_crypto
.
stringToArray
(
data
)
;
let
cdata
=
ctypes
.
unsigned_char
.
array
(
arr
.
length
)
(
arr
)
;
let
currentLoginData
=
ctypes
.
cast
(
cdata
loginData
)
;
let
headerSize
=
currentLoginData
.
headerSize
;
let
currentInfoIndex
=
loginData
.
size
;
let
currentLoginItemPointer
=
ctypes
.
cast
(
cdata
.
addressOfElement
(
currentInfoIndex
)
loginItem
.
ptr
)
;
let
numLogins
=
currentLoginData
.
dataMax
/
2
;
for
(
let
n
=
0
;
n
<
numLogins
;
n
+
+
)
{
let
currentLoginItem
=
currentLoginItemPointer
.
contents
;
let
creation
=
this
.
ctypesKernelHelpers
.
fileTimeToSecondsSinceEpoch
(
currentLoginItem
.
hiDateTime
currentLoginItem
.
loDateTime
)
*
1000
;
let
currentResult
=
{
creation
url
}
;
currentResult
.
username
=
ctypes
.
cast
(
cdata
.
addressOfElement
(
headerSize
+
12
+
currentLoginItem
.
usernameOffset
)
ctypes
.
char16_t
.
ptr
)
.
readString
(
)
;
currentResult
.
password
=
ctypes
.
cast
(
cdata
.
addressOfElement
(
headerSize
+
12
+
currentLoginItem
.
passwordOffset
)
ctypes
.
char16_t
.
ptr
)
.
readString
(
)
;
results
.
push
(
currentResult
)
;
currentLoginItemPointer
=
currentLoginItemPointer
.
increment
(
)
;
}
return
results
;
}
}
;
function
IEProfileMigrator
(
)
{
this
.
wrappedJSObject
=
this
;
}
IEProfileMigrator
.
prototype
=
Object
.
create
(
MigratorPrototype
)
;
IEProfileMigrator
.
prototype
.
getResources
=
function
IE_getResources
(
)
{
let
resources
=
[
MSMigrationUtils
.
getBookmarksMigrator
(
)
new
History
(
)
MSMigrationUtils
.
getCookiesMigrator
(
)
]
;
if
(
AppConstants
.
isPlatformAndVersionAtMost
(
"
win
"
"
6
.
1
"
)
)
{
resources
.
push
(
new
IE7FormPasswords
(
)
)
;
}
let
windowsVaultFormPasswordsMigrator
=
MSMigrationUtils
.
getWindowsVaultFormPasswordsMigrator
(
)
;
windowsVaultFormPasswordsMigrator
.
name
=
"
IEVaultFormPasswords
"
;
resources
.
push
(
windowsVaultFormPasswordsMigrator
)
;
return
resources
.
filter
(
r
=
>
r
.
exists
)
;
}
;
IEProfileMigrator
.
prototype
.
getLastUsedDate
=
function
IE_getLastUsedDate
(
)
{
let
datePromises
=
[
"
Favs
"
"
CookD
"
]
.
map
(
dirId
=
>
{
let
{
path
}
=
Services
.
dirsvc
.
get
(
dirId
Ci
.
nsIFile
)
;
return
OS
.
File
.
stat
(
path
)
.
catch
(
(
)
=
>
null
)
.
then
(
info
=
>
{
return
info
?
info
.
lastModificationDate
:
0
;
}
)
;
}
)
;
datePromises
.
push
(
new
Promise
(
resolve
=
>
{
let
typedURLs
=
new
Map
(
)
;
try
{
typedURLs
=
MSMigrationUtils
.
getTypedURLs
(
"
Software
\
\
Microsoft
\
\
Internet
Explorer
"
)
;
}
catch
(
ex
)
{
}
let
dates
=
[
0
.
.
.
typedURLs
.
values
(
)
]
;
resolve
(
Math
.
max
.
apply
(
Math
dates
)
/
1000
)
;
}
)
)
;
return
Promise
.
all
(
datePromises
)
.
then
(
dates
=
>
{
return
new
Date
(
Math
.
max
.
apply
(
Math
dates
)
)
;
}
)
;
}
;
IEProfileMigrator
.
prototype
.
classDescription
=
"
IE
Profile
Migrator
"
;
IEProfileMigrator
.
prototype
.
contractID
=
"
mozilla
.
org
/
profile
/
migrator
;
1
?
app
=
browser
&
type
=
ie
"
;
IEProfileMigrator
.
prototype
.
classID
=
Components
.
ID
(
"
{
3d2532e3
-
4932
-
4774
-
b7ba
-
968f5899d3a4
}
"
)
;
var
EXPORTED_SYMBOLS
=
[
"
IEProfileMigrator
"
]
;
