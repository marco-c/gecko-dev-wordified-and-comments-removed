"
use
strict
"
;
var
{
MigrationUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
/
modules
/
MigrationUtils
.
sys
.
mjs
"
)
;
var
{
LoginHelper
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
LoginHelper
.
sys
.
mjs
"
)
;
var
{
NetUtil
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
sys
.
mjs
"
)
;
var
{
PlacesUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
sys
.
mjs
"
)
;
var
{
Preferences
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
Preferences
.
sys
.
mjs
"
)
;
var
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
var
{
TestUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
TestUtils
.
sys
.
mjs
"
)
;
var
{
PlacesTestUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
PlacesTestUtils
.
sys
.
mjs
"
)
;
const
{
AppConstants
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
sys
.
mjs
"
)
;
ChromeUtils
.
defineESModuleGetters
(
this
{
FileUtils
:
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
sys
.
mjs
"
Sqlite
:
"
resource
:
/
/
gre
/
modules
/
Sqlite
.
sys
.
mjs
"
}
)
;
var
gProfD
=
do_get_profile
(
)
;
var
{
getAppInfo
newAppInfo
updateAppInfo
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
AppInfo
.
sys
.
mjs
"
)
;
updateAppInfo
(
)
;
async
function
promiseMigration
(
migrator
resourceType
aProfile
=
null
succeeds
=
null
)
{
let
availableSources
=
await
migrator
.
getMigrateData
(
aProfile
)
;
Assert
.
greater
(
availableSources
&
resourceType
0
"
Resource
supported
by
migrator
"
)
;
let
promises
=
[
TestUtils
.
topicObserved
(
"
Migration
:
Ended
"
)
]
;
if
(
succeeds
!
=
=
null
)
{
promises
.
push
(
TestUtils
.
topicObserved
(
succeeds
?
"
Migration
:
ItemAfterMigrate
"
:
"
Migration
:
ItemError
"
(
_
data
)
=
>
data
=
=
resourceType
)
)
;
}
migrator
.
migrate
(
resourceType
null
aProfile
)
;
return
Promise
.
all
(
promises
)
;
}
async
function
assertFavicons
(
pageURIs
)
{
for
(
let
uri
of
pageURIs
)
{
let
favicon
=
await
PlacesUtils
.
favicons
.
getFaviconForPage
(
uri
)
;
Assert
.
ok
(
favicon
Got
favicon
for
{
favicon
.
uri
.
spec
}
)
;
}
}
async
function
assertFavicon
(
pageURI
expectedImageData
expectedMimeType
)
{
let
result
=
await
PlacesUtils
.
favicons
.
getFaviconForPage
(
Services
.
io
.
newURI
(
pageURI
)
)
;
Assert
.
ok
(
!
!
result
Got
favicon
for
{
pageURI
}
)
;
Assert
.
equal
(
result
.
rawData
.
join
(
"
"
)
expectedImageData
.
join
(
"
"
)
"
Image
data
is
correct
"
)
;
Assert
.
equal
(
result
.
mimeType
expectedMimeType
"
Mime
type
is
correct
"
)
;
}
function
registerFakePath
(
key
file
)
{
let
dirsvc
=
Services
.
dirsvc
.
QueryInterface
(
Ci
.
nsIProperties
)
;
let
originalFile
;
try
{
originalFile
=
dirsvc
.
get
(
key
Ci
.
nsIFile
)
;
dirsvc
.
undefine
(
key
)
;
}
catch
(
e
)
{
originalFile
=
undefined
;
}
dirsvc
.
set
(
key
file
)
;
registerCleanupFunction
(
(
)
=
>
{
dirsvc
.
undefine
(
key
)
;
if
(
originalFile
)
{
dirsvc
.
set
(
key
originalFile
)
;
}
}
)
;
}
function
getRootPath
(
)
{
let
dirKey
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
dirKey
=
"
LocalAppData
"
;
}
else
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
dirKey
=
"
ULibDir
"
;
}
else
{
dirKey
=
"
Home
"
;
}
return
Services
.
dirsvc
.
get
(
dirKey
Ci
.
nsIFile
)
.
path
;
}
function
PRTimeDaysAgo
(
daysAgo
)
{
return
PlacesUtils
.
toPRTime
(
Date
.
now
(
)
-
daysAgo
*
24
*
60
*
60
*
1000
)
;
}
function
dateDaysAgo
(
daysAgo
)
{
return
new
Date
(
Date
.
now
(
)
-
daysAgo
*
24
*
60
*
60
*
1000
)
;
}
function
createChromeBookmarkStructure
(
totalBookmarks
=
100
)
{
let
bookmarksData
=
{
roots
:
{
bookmark_bar
:
{
children
:
[
]
}
other
:
{
children
:
[
]
}
synced
:
{
children
:
[
]
}
}
}
;
const
MAX_BMS
=
totalBookmarks
;
let
barKids
=
bookmarksData
.
roots
.
bookmark_bar
.
children
;
let
menuKids
=
bookmarksData
.
roots
.
other
.
children
;
let
syncedKids
=
bookmarksData
.
roots
.
synced
.
children
;
let
currentMenuKids
=
menuKids
;
let
currentBarKids
=
barKids
;
let
currentSyncedKids
=
syncedKids
;
for
(
let
i
=
0
;
i
<
MAX_BMS
;
i
+
+
)
{
currentBarKids
.
push
(
{
url
:
"
https
:
/
/
www
.
chrome
-
bookmark
-
bar
-
bookmark
"
+
i
+
"
.
com
"
name
:
"
bookmark
"
+
i
type
:
"
url
"
}
)
;
currentMenuKids
.
push
(
{
url
:
"
https
:
/
/
www
.
chrome
-
menu
-
bookmark
"
+
i
+
"
.
com
"
name
:
"
bookmark
for
menu
"
+
i
type
:
"
url
"
}
)
;
currentSyncedKids
.
push
(
{
url
:
"
https
:
/
/
www
.
chrome
-
synced
-
bookmark
"
+
i
+
"
.
com
"
name
:
"
bookmark
for
synced
"
+
i
type
:
"
url
"
}
)
;
if
(
i
%
20
=
=
19
)
{
let
nextFolder
=
{
name
:
"
toolbar
folder
"
+
Math
.
ceil
(
i
/
20
)
type
:
"
folder
"
children
:
[
]
}
;
currentBarKids
.
push
(
nextFolder
)
;
currentBarKids
=
nextFolder
.
children
;
nextFolder
=
{
name
:
"
menu
folder
"
+
Math
.
ceil
(
i
/
20
)
type
:
"
folder
"
children
:
[
]
}
;
currentMenuKids
.
push
(
nextFolder
)
;
currentMenuKids
=
nextFolder
.
children
;
nextFolder
=
{
name
:
"
synced
folder
"
+
Math
.
ceil
(
i
/
20
)
type
:
"
folder
"
children
:
[
]
}
;
currentSyncedKids
.
push
(
nextFolder
)
;
currentSyncedKids
=
nextFolder
.
children
;
}
}
return
bookmarksData
;
}
