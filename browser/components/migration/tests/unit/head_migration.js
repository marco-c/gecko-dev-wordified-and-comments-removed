"
use
strict
"
;
var
{
MigrationUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
/
modules
/
MigrationUtils
.
sys
.
mjs
"
)
;
var
{
LoginHelper
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
LoginHelper
.
jsm
"
)
;
var
{
NetUtil
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
var
{
PlacesUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
sys
.
mjs
"
)
;
var
{
Preferences
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
Preferences
.
sys
.
mjs
"
)
;
var
{
PromiseUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
sys
.
mjs
"
)
;
var
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
var
{
TestUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
TestUtils
.
sys
.
mjs
"
)
;
var
{
PlacesTestUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
PlacesTestUtils
.
sys
.
mjs
"
)
;
const
{
AppConstants
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
sys
.
mjs
"
)
;
ChromeUtils
.
defineESModuleGetters
(
this
{
FileUtils
:
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
sys
.
mjs
"
Sqlite
:
"
resource
:
/
/
gre
/
modules
/
Sqlite
.
sys
.
mjs
"
}
)
;
var
gProfD
=
do_get_profile
(
)
;
var
{
getAppInfo
newAppInfo
updateAppInfo
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
AppInfo
.
sys
.
mjs
"
)
;
updateAppInfo
(
)
;
async
function
promiseMigration
(
migrator
resourceType
aProfile
=
null
succeeds
=
null
)
{
let
availableSources
=
await
migrator
.
getMigrateData
(
aProfile
)
;
Assert
.
ok
(
(
availableSources
&
resourceType
)
>
0
"
Resource
supported
by
migrator
"
)
;
let
promises
=
[
TestUtils
.
topicObserved
(
"
Migration
:
Ended
"
)
]
;
if
(
succeeds
!
=
=
null
)
{
promises
.
push
(
TestUtils
.
topicObserved
(
succeeds
?
"
Migration
:
ItemAfterMigrate
"
:
"
Migration
:
ItemError
"
(
_
data
)
=
>
data
=
=
resourceType
)
)
;
}
migrator
.
migrate
(
resourceType
null
aProfile
)
;
return
Promise
.
all
(
promises
)
;
}
async
function
getFaviconForPageURI
(
uri
)
{
let
faviconURI
=
await
new
Promise
(
resolve
=
>
{
PlacesUtils
.
favicons
.
getFaviconDataForPage
(
uri
favURI
=
>
{
resolve
(
favURI
)
;
}
)
;
}
)
;
return
faviconURI
;
}
async
function
assertFavicons
(
pageURIs
)
{
for
(
let
uri
of
pageURIs
)
{
let
faviconURI
=
await
getFaviconForPageURI
(
uri
)
;
Assert
.
ok
(
faviconURI
Got
favicon
for
{
uri
.
spec
}
)
;
}
}
function
registerFakePath
(
key
file
)
{
let
dirsvc
=
Services
.
dirsvc
.
QueryInterface
(
Ci
.
nsIProperties
)
;
let
originalFile
;
try
{
originalFile
=
dirsvc
.
get
(
key
Ci
.
nsIFile
)
;
dirsvc
.
undefine
(
key
)
;
}
catch
(
e
)
{
originalFile
=
undefined
;
}
dirsvc
.
set
(
key
file
)
;
registerCleanupFunction
(
(
)
=
>
{
dirsvc
.
undefine
(
key
)
;
if
(
originalFile
)
{
dirsvc
.
set
(
key
originalFile
)
;
}
}
)
;
}
function
getRootPath
(
)
{
let
dirKey
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
dirKey
=
"
LocalAppData
"
;
}
else
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
dirKey
=
"
ULibDir
"
;
}
else
{
dirKey
=
"
Home
"
;
}
return
Services
.
dirsvc
.
get
(
dirKey
Ci
.
nsIFile
)
.
path
;
}
function
PRTimeDaysAgo
(
daysAgo
)
{
return
PlacesUtils
.
toPRTime
(
Date
.
now
(
)
-
daysAgo
*
24
*
60
*
60
*
1000
)
;
}
function
dateDaysAgo
(
daysAgo
)
{
return
new
Date
(
Date
.
now
(
)
-
daysAgo
*
24
*
60
*
60
*
1000
)
;
}
