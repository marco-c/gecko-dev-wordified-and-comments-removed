"
use
strict
"
;
const
{
FileMigratorBase
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
/
modules
/
FileMigrators
.
sys
.
mjs
"
)
;
const
DUMMY_FILEMIGRATOR_KEY
=
"
dummy
-
file
-
migrator
"
;
const
DUMMY_FILEPICKER_TITLE
=
"
Some
dummy
file
picker
title
"
;
const
DUMMY_FILTER_TITLE
=
"
Some
file
type
"
;
const
DUMMY_EXTENSION_PATTERN
=
"
*
.
test
"
;
const
TEST_FILE_PATH
=
getTestFilePath
(
"
dummy_file
.
csv
"
)
;
class
DummyFileMigrator
extends
FileMigratorBase
{
static
get
key
(
)
{
return
DUMMY_FILEMIGRATOR_KEY
;
}
static
get
displayNameL10nID
(
)
{
return
"
migration
-
wizard
-
migrator
-
display
-
name
-
file
-
password
-
csv
"
;
}
static
get
brandImage
(
)
{
return
"
chrome
:
/
/
branding
/
content
/
document
.
ico
"
;
}
get
enabled
(
)
{
return
true
;
}
get
progressHeaderL10nID
(
)
{
return
"
migration
-
passwords
-
from
-
file
-
progress
-
header
"
;
}
get
successHeaderL10nID
(
)
{
return
"
migration
-
passwords
-
from
-
file
-
success
-
header
"
;
}
async
getFilePickerConfig
(
)
{
return
Promise
.
resolve
(
{
title
:
DUMMY_FILEPICKER_TITLE
filters
:
[
{
title
:
DUMMY_FILTER_TITLE
extensionPattern
:
DUMMY_EXTENSION_PATTERN
}
]
}
)
;
}
get
displayedResourceTypes
(
)
{
return
[
MigrationWizardConstants
.
DISPLAYED_RESOURCE_TYPES
.
PASSWORDS
]
;
}
}
const
{
MockFilePicker
}
=
SpecialPowers
;
add_setup
(
async
(
)
=
>
{
MockFilePicker
.
init
(
window
)
;
registerCleanupFunction
(
(
)
=
>
{
MockFilePicker
.
cleanup
(
)
;
}
)
;
}
)
;
add_task
(
async
function
test_file_migration
(
)
{
let
migrator
=
new
DummyFileMigrator
(
)
;
let
sandbox
=
sinon
.
createSandbox
(
)
;
registerCleanupFunction
(
(
)
=
>
{
sandbox
.
restore
(
)
;
}
)
;
sandbox
.
stub
(
MigrationUtils
"
getFileMigrator
"
)
.
callsFake
(
(
)
=
>
{
return
migrator
;
}
)
;
sandbox
.
stub
(
MigrationUtils
"
availableFileMigrators
"
)
.
get
(
(
)
=
>
{
return
[
migrator
]
;
}
)
;
const
SUCCESS_STATE
=
{
[
MigrationWizardConstants
.
DISPLAYED_FILE_RESOURCE_TYPES
.
PASSWORDS_NEW
]
:
"
2
added
"
[
MigrationWizardConstants
.
DISPLAYED_FILE_RESOURCE_TYPES
.
PASSWORDS_UPDATED
]
:
"
1
updated
"
}
;
let
migrateStub
=
sandbox
.
stub
(
migrator
"
migrate
"
)
.
callsFake
(
filePath
=
>
{
Assert
.
equal
(
filePath
TEST_FILE_PATH
)
;
return
SUCCESS_STATE
;
}
)
;
let
dummyFile
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsIFile
)
;
dummyFile
.
initWithPath
(
TEST_FILE_PATH
)
;
let
filePickerShownPromise
=
new
Promise
(
resolve
=
>
{
MockFilePicker
.
showCallback
=
(
)
=
>
{
Assert
.
ok
(
true
"
Filepicker
shown
.
"
)
;
MockFilePicker
.
setFiles
(
[
dummyFile
]
)
;
resolve
(
)
;
}
;
}
)
;
MockFilePicker
.
returnValue
=
MockFilePicker
.
returnOK
;
await
withMigrationWizardDialog
(
async
prefsWin
=
>
{
let
dialogBody
=
prefsWin
.
document
.
body
;
let
wizard
=
dialogBody
.
querySelector
(
"
migration
-
wizard
"
)
;
let
shadow
=
wizard
.
openOrClosedShadowRoot
;
let
wizardDone
=
BrowserTestUtils
.
waitForEvent
(
wizard
"
MigrationWizard
:
DoneMigration
"
)
;
let
selector
=
shadow
.
querySelector
(
"
#
browser
-
profile
-
selector
"
)
;
selector
.
click
(
)
;
info
(
"
Waiting
for
panel
-
list
shown
"
)
;
await
new
Promise
(
resolve
=
>
{
shadow
.
querySelector
(
"
panel
-
list
"
)
.
addEventListener
(
"
shown
"
resolve
{
once
:
true
}
)
;
}
)
;
info
(
"
Panel
list
shown
.
Clicking
on
panel
-
item
"
)
;
let
panelItem
=
shadow
.
querySelector
(
panel
-
item
[
key
=
"
{
DUMMY_FILEMIGRATOR_KEY
}
"
]
)
;
panelItem
.
click
(
)
;
info
(
"
Waiting
for
file
picker
"
)
;
await
filePickerShownPromise
;
await
wizardDone
;
Assert
.
ok
(
migrateStub
.
called
"
Migrate
on
DummyFileMigrator
was
called
.
"
)
;
let
deck
=
shadow
.
querySelector
(
"
#
wizard
-
deck
"
)
;
Assert
.
equal
(
deck
.
selectedViewName
page
-
{
MigrationWizardConstants
.
PAGES
.
FILE_IMPORT_PROGRESS
}
)
;
let
progressGroups
=
shadow
.
querySelectorAll
(
"
div
[
name
=
'
page
-
file
-
import
-
progress
'
]
.
resource
-
progress
-
group
"
)
;
for
(
let
progressGroup
of
progressGroups
)
{
let
expectedMessageText
=
SUCCESS_STATE
[
progressGroup
.
dataset
.
resourceType
]
;
if
(
expectedMessageText
)
{
let
progressIcon
=
progressGroup
.
querySelector
(
"
.
progress
-
icon
"
)
;
Assert
.
stringMatches
(
progressIcon
.
getAttribute
(
"
state
"
)
"
success
"
"
Should
be
showing
completed
state
.
"
)
;
let
messageText
=
progressGroup
.
querySelector
(
"
.
message
-
text
"
)
.
textContent
;
Assert
.
equal
(
messageText
expectedMessageText
)
;
}
else
{
Assert
.
ok
(
BrowserTestUtils
.
is_hidden
(
progressGroup
)
Resource
progress
group
for
{
progressGroup
.
dataset
.
resourceType
}
+
should
be
hidden
.
)
;
}
}
}
)
;
sandbox
.
restore
(
)
;
}
)
;
add_task
(
async
function
test_file_migration_error
(
)
{
let
migrator
=
new
DummyFileMigrator
(
)
;
let
sandbox
=
sinon
.
createSandbox
(
)
;
registerCleanupFunction
(
(
)
=
>
{
sandbox
.
restore
(
)
;
}
)
;
sandbox
.
stub
(
MigrationUtils
"
getFileMigrator
"
)
.
callsFake
(
(
)
=
>
{
return
migrator
;
}
)
;
sandbox
.
stub
(
MigrationUtils
"
availableFileMigrators
"
)
.
get
(
(
)
=
>
{
return
[
migrator
]
;
}
)
;
const
ERROR_MESSAGE
=
"
This
is
my
error
message
"
;
let
migrateStub
=
sandbox
.
stub
(
migrator
"
migrate
"
)
.
callsFake
(
(
)
=
>
{
throw
new
Error
(
ERROR_MESSAGE
)
;
}
)
;
let
dummyFile
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsIFile
)
;
dummyFile
.
initWithPath
(
TEST_FILE_PATH
)
;
let
filePickerShownPromise
=
new
Promise
(
resolve
=
>
{
MockFilePicker
.
showCallback
=
(
)
=
>
{
Assert
.
ok
(
true
"
Filepicker
shown
.
"
)
;
MockFilePicker
.
setFiles
(
[
dummyFile
]
)
;
resolve
(
)
;
}
;
}
)
;
MockFilePicker
.
returnValue
=
MockFilePicker
.
returnOK
;
await
withMigrationWizardDialog
(
async
prefsWin
=
>
{
let
dialogBody
=
prefsWin
.
document
.
body
;
let
wizard
=
dialogBody
.
querySelector
(
"
migration
-
wizard
"
)
;
let
shadow
=
wizard
.
openOrClosedShadowRoot
;
let
wizardDone
=
BrowserTestUtils
.
waitForEvent
(
wizard
"
MigrationWizard
:
DoneMigration
"
)
;
let
selector
=
shadow
.
querySelector
(
"
#
browser
-
profile
-
selector
"
)
;
selector
.
click
(
)
;
info
(
"
Waiting
for
panel
-
list
shown
"
)
;
await
new
Promise
(
resolve
=
>
{
shadow
.
querySelector
(
"
panel
-
list
"
)
.
addEventListener
(
"
shown
"
resolve
{
once
:
true
}
)
;
}
)
;
info
(
"
Panel
list
shown
.
Clicking
on
panel
-
item
"
)
;
let
panelItem
=
shadow
.
querySelector
(
panel
-
item
[
key
=
"
{
DUMMY_FILEMIGRATOR_KEY
}
"
]
)
;
panelItem
.
click
(
)
;
info
(
"
Waiting
for
file
picker
"
)
;
await
filePickerShownPromise
;
await
wizardDone
;
Assert
.
ok
(
migrateStub
.
called
"
Migrate
on
DummyFileMigrator
was
called
.
"
)
;
let
deck
=
shadow
.
querySelector
(
"
#
wizard
-
deck
"
)
;
await
BrowserTestUtils
.
waitForMutationCondition
(
deck
{
attributeFilter
:
[
"
selected
-
view
"
]
}
(
)
=
>
{
return
(
deck
.
getAttribute
(
"
selected
-
view
"
)
=
=
"
page
-
"
+
MigrationWizardConstants
.
PAGES
.
SELECTION
)
;
}
)
;
Assert
.
equal
(
selector
.
selectedPanelItem
.
getAttribute
(
"
key
"
)
DUMMY_FILEMIGRATOR_KEY
"
Should
have
the
file
migrator
selected
.
"
)
;
let
errorMessageContainer
=
shadow
.
querySelector
(
"
.
file
-
import
-
error
"
)
;
Assert
.
ok
(
BrowserTestUtils
.
is_visible
(
errorMessageContainer
)
"
Should
be
showing
the
error
message
container
"
)
;
let
fileImportErrorMessage
=
shadow
.
querySelector
(
"
#
file
-
import
-
error
-
message
"
)
.
textContent
;
Assert
.
equal
(
fileImportErrorMessage
ERROR_MESSAGE
)
;
}
)
;
sandbox
.
restore
(
)
;
}
)
;
