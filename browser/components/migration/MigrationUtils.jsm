"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
MigrationUtils
"
"
MigratorPrototype
"
]
;
const
TOPIC_WILL_IMPORT_BOOKMARKS
=
"
initial
-
migration
-
will
-
import
-
default
-
bookmarks
"
;
const
TOPIC_DID_IMPORT_BOOKMARKS
=
"
initial
-
migration
-
did
-
import
-
default
-
bookmarks
"
;
const
TOPIC_PLACES_DEFAULTS_FINISHED
=
"
places
-
browser
-
init
-
complete
"
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
importGlobalProperties
(
[
"
URL
"
]
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
AutoMigrate
"
"
resource
:
/
/
/
modules
/
AutoMigrate
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
BookmarkHTMLUtils
"
"
resource
:
/
/
gre
/
modules
/
BookmarkHTMLUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
LoginHelper
"
"
resource
:
/
/
gre
/
modules
/
LoginHelper
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PlacesUtils
"
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PromiseUtils
"
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ResponsivenessMonitor
"
"
resource
:
/
/
gre
/
modules
/
ResponsivenessMonitor
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Sqlite
"
"
resource
:
/
/
gre
/
modules
/
Sqlite
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
TelemetryStopwatch
"
"
resource
:
/
/
gre
/
modules
/
TelemetryStopwatch
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
WindowsRegistry
"
"
resource
:
/
/
gre
/
modules
/
WindowsRegistry
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
setTimeout
"
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
var
gMigrators
=
null
;
var
gProfileStartup
=
null
;
var
gMigrationBundle
=
null
;
var
gPreviousDefaultBrowserKey
=
"
"
;
let
gForceExitSpinResolve
=
false
;
let
gKeepUndoData
=
false
;
let
gUndoData
=
null
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gAvailableMigratorKeys
"
function
(
)
{
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
return
[
"
firefox
"
"
edge
"
"
ie
"
"
chrome
"
"
chromium
"
"
360se
"
"
canary
"
]
;
}
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
return
[
"
firefox
"
"
safari
"
"
chrome
"
"
chromium
"
"
canary
"
]
;
}
if
(
AppConstants
.
XP_UNIX
)
{
return
[
"
firefox
"
"
chrome
"
"
chromium
"
]
;
}
return
[
]
;
}
)
;
function
getMigrationBundle
(
)
{
if
(
!
gMigrationBundle
)
{
gMigrationBundle
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
browser
/
locale
/
migration
/
migration
.
properties
"
)
;
}
return
gMigrationBundle
;
}
this
.
MigratorPrototype
=
{
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIBrowserProfileMigrator
]
)
getSourceProfiles
(
)
{
return
null
;
}
getResources
:
function
MP_getResources
(
)
{
throw
new
Error
(
"
getResources
must
be
overridden
"
)
;
}
getLastUsedDate
(
)
{
return
Promise
.
resolve
(
new
Date
(
0
)
)
;
}
get
startupOnlyMigrator
(
)
{
return
false
;
}
get
sourceLocked
(
)
{
return
false
;
}
getMigrateData
:
async
function
MP_getMigrateData
(
aProfile
)
{
let
resources
=
await
this
.
_getMaybeCachedResources
(
aProfile
)
;
if
(
!
resources
)
{
return
[
]
;
}
let
types
=
resources
.
map
(
r
=
>
r
.
type
)
;
return
types
.
reduce
(
(
a
b
)
=
>
{
a
|
=
b
;
return
a
;
}
0
)
;
}
getBrowserKey
:
function
MP_getBrowserKey
(
)
{
return
this
.
contractID
.
match
(
/
\
=
(
[
^
\
=
]
+
)
/
)
[
1
]
;
}
migrate
:
async
function
MP_migrate
(
aItems
aStartup
aProfile
)
{
let
resources
=
await
this
.
_getMaybeCachedResources
(
aProfile
)
;
if
(
resources
.
length
=
=
0
)
throw
new
Error
(
"
migrate
called
for
a
non
-
existent
source
"
)
;
if
(
aItems
!
=
Ci
.
nsIBrowserProfileMigrator
.
ALL
)
resources
=
resources
.
filter
(
r
=
>
aItems
&
r
.
type
)
;
let
unblockMainThread
=
function
(
)
{
return
new
Promise
(
resolve
=
>
{
Services
.
tm
.
dispatchToMainThread
(
resolve
)
;
}
)
;
}
;
let
getHistogramIdForResourceType
=
(
resourceType
template
)
=
>
{
if
(
resourceType
=
=
MigrationUtils
.
resourceTypes
.
HISTORY
)
{
return
template
.
replace
(
"
*
"
"
HISTORY
"
)
;
}
if
(
resourceType
=
=
MigrationUtils
.
resourceTypes
.
BOOKMARKS
)
{
return
template
.
replace
(
"
*
"
"
BOOKMARKS
"
)
;
}
if
(
resourceType
=
=
MigrationUtils
.
resourceTypes
.
PASSWORDS
)
{
return
template
.
replace
(
"
*
"
"
LOGINS
"
)
;
}
return
null
;
}
;
let
browserKey
=
this
.
getBrowserKey
(
)
;
let
maybeStartTelemetryStopwatch
=
resourceType
=
>
{
let
histogramId
=
getHistogramIdForResourceType
(
resourceType
"
FX_MIGRATION_
*
_IMPORT_MS
"
)
;
if
(
histogramId
)
{
TelemetryStopwatch
.
startKeyed
(
histogramId
browserKey
)
;
}
return
histogramId
;
}
;
let
maybeStartResponsivenessMonitor
=
resourceType
=
>
{
let
responsivenessMonitor
;
let
responsivenessHistogramId
=
getHistogramIdForResourceType
(
resourceType
"
FX_MIGRATION_
*
_JANK_MS
"
)
;
if
(
responsivenessHistogramId
)
{
responsivenessMonitor
=
new
ResponsivenessMonitor
(
)
;
}
return
{
responsivenessMonitor
responsivenessHistogramId
}
;
}
;
let
maybeFinishResponsivenessMonitor
=
(
responsivenessMonitor
histogramId
)
=
>
{
if
(
responsivenessMonitor
)
{
let
accumulatedDelay
=
responsivenessMonitor
.
finish
(
)
;
if
(
histogramId
)
{
try
{
Services
.
telemetry
.
getKeyedHistogramById
(
histogramId
)
.
add
(
browserKey
accumulatedDelay
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
histogramId
+
"
:
"
+
ex
)
;
}
}
}
}
;
let
collectQuantityTelemetry
=
(
)
=
>
{
for
(
let
resourceType
of
Object
.
keys
(
MigrationUtils
.
_importQuantities
)
)
{
let
histogramId
=
"
FX_MIGRATION_
"
+
resourceType
.
toUpperCase
(
)
+
"
_QUANTITY
"
;
try
{
Services
.
telemetry
.
getKeyedHistogramById
(
histogramId
)
.
add
(
browserKey
MigrationUtils
.
_importQuantities
[
resourceType
]
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
histogramId
+
"
:
"
+
ex
)
;
}
}
}
;
let
doMigrate
=
async
function
(
)
{
let
resourcesGroupedByItems
=
new
Map
(
)
;
resources
.
forEach
(
function
(
resource
)
{
if
(
!
resourcesGroupedByItems
.
has
(
resource
.
type
)
)
{
resourcesGroupedByItems
.
set
(
resource
.
type
new
Set
(
)
)
;
}
resourcesGroupedByItems
.
get
(
resource
.
type
)
.
add
(
resource
)
;
}
)
;
if
(
resourcesGroupedByItems
.
size
=
=
0
)
throw
new
Error
(
"
No
items
to
import
"
)
;
let
notify
=
function
(
aMsg
aItemType
)
{
Services
.
obs
.
notifyObservers
(
null
aMsg
aItemType
)
;
}
;
for
(
let
resourceType
of
Object
.
keys
(
MigrationUtils
.
_importQuantities
)
)
{
MigrationUtils
.
_importQuantities
[
resourceType
]
=
0
;
}
notify
(
"
Migration
:
Started
"
)
;
for
(
let
[
migrationType
itemResources
]
of
resourcesGroupedByItems
)
{
notify
(
"
Migration
:
ItemBeforeMigrate
"
migrationType
)
;
let
stopwatchHistogramId
=
maybeStartTelemetryStopwatch
(
migrationType
)
;
let
{
responsivenessMonitor
responsivenessHistogramId
}
=
maybeStartResponsivenessMonitor
(
migrationType
)
;
let
itemSuccess
=
false
;
for
(
let
res
of
itemResources
)
{
let
completeDeferred
=
PromiseUtils
.
defer
(
)
;
let
resourceDone
=
function
(
aSuccess
)
{
itemResources
.
delete
(
res
)
;
itemSuccess
|
=
aSuccess
;
if
(
itemResources
.
size
=
=
0
)
{
notify
(
itemSuccess
?
"
Migration
:
ItemAfterMigrate
"
:
"
Migration
:
ItemError
"
migrationType
)
;
resourcesGroupedByItems
.
delete
(
migrationType
)
;
if
(
stopwatchHistogramId
)
{
TelemetryStopwatch
.
finishKeyed
(
stopwatchHistogramId
browserKey
)
;
}
maybeFinishResponsivenessMonitor
(
responsivenessMonitor
responsivenessHistogramId
)
;
if
(
resourcesGroupedByItems
.
size
=
=
0
)
{
collectQuantityTelemetry
(
)
;
notify
(
"
Migration
:
Ended
"
)
;
}
}
completeDeferred
.
resolve
(
)
;
}
;
try
{
res
.
migrate
(
resourceDone
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
resourceDone
(
false
)
;
}
await
completeDeferred
.
promise
;
await
unblockMainThread
(
)
;
}
}
}
;
if
(
MigrationUtils
.
isStartupMigration
&
&
!
this
.
startupOnlyMigrator
)
{
MigrationUtils
.
profileStartup
.
doStartup
(
)
;
(
async
function
(
)
{
let
browserGlue
=
Cc
[
"
mozilla
.
org
/
browser
/
browserglue
;
1
"
]
.
getService
(
Ci
.
nsIObserver
)
;
browserGlue
.
observe
(
null
TOPIC_WILL_IMPORT_BOOKMARKS
"
"
)
;
await
BookmarkHTMLUtils
.
importFromURL
(
"
chrome
:
/
/
browser
/
locale
/
bookmarks
.
html
"
true
)
.
catch
(
r
=
>
r
)
;
let
placesInitedPromise
=
new
Promise
(
resolve
=
>
{
let
onPlacesInited
=
function
(
)
{
Services
.
obs
.
removeObserver
(
onPlacesInited
TOPIC_PLACES_DEFAULTS_FINISHED
)
;
resolve
(
)
;
}
;
Services
.
obs
.
addObserver
(
onPlacesInited
TOPIC_PLACES_DEFAULTS_FINISHED
)
;
}
)
;
browserGlue
.
observe
(
null
TOPIC_DID_IMPORT_BOOKMARKS
"
"
)
;
await
placesInitedPromise
;
doMigrate
(
)
;
}
)
(
)
;
return
;
}
doMigrate
(
)
;
}
async
isSourceAvailable
(
)
{
if
(
this
.
startupOnlyMigrator
&
&
!
MigrationUtils
.
isStartupMigration
)
return
false
;
let
exists
=
false
;
try
{
let
profiles
=
await
this
.
getSourceProfiles
(
)
;
if
(
!
profiles
)
{
let
resources
=
await
this
.
_getMaybeCachedResources
(
"
"
)
;
if
(
resources
&
&
resources
.
length
>
0
)
exists
=
true
;
}
else
{
exists
=
profiles
.
length
>
0
;
}
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
return
exists
;
}
_getMaybeCachedResources
:
async
function
PMB__getMaybeCachedResources
(
aProfile
)
{
let
profileKey
=
aProfile
?
aProfile
.
id
:
"
"
;
if
(
this
.
_resourcesByProfile
)
{
if
(
profileKey
in
this
.
_resourcesByProfile
)
return
this
.
_resourcesByProfile
[
profileKey
]
;
}
else
{
this
.
_resourcesByProfile
=
{
}
;
}
this
.
_resourcesByProfile
[
profileKey
]
=
await
this
.
getResources
(
aProfile
)
;
return
this
.
_resourcesByProfile
[
profileKey
]
;
}
}
;
this
.
MigrationUtils
=
Object
.
freeze
(
{
resourceTypes
:
{
SETTINGS
:
Ci
.
nsIBrowserProfileMigrator
.
SETTINGS
COOKIES
:
Ci
.
nsIBrowserProfileMigrator
.
COOKIES
HISTORY
:
Ci
.
nsIBrowserProfileMigrator
.
HISTORY
FORMDATA
:
Ci
.
nsIBrowserProfileMigrator
.
FORMDATA
PASSWORDS
:
Ci
.
nsIBrowserProfileMigrator
.
PASSWORDS
BOOKMARKS
:
Ci
.
nsIBrowserProfileMigrator
.
BOOKMARKS
OTHERDATA
:
Ci
.
nsIBrowserProfileMigrator
.
OTHERDATA
SESSION
:
Ci
.
nsIBrowserProfileMigrator
.
SESSION
}
wrapMigrateFunction
:
function
MU_wrapMigrateFunction
(
aFunction
aCallback
)
{
return
function
(
)
{
let
success
=
false
;
try
{
aFunction
.
apply
(
null
arguments
)
;
success
=
true
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
aCallback
(
success
)
;
}
;
}
getLocalizedString
:
function
MU_getLocalizedString
(
aKey
aReplacements
)
{
aKey
=
aKey
.
replace
(
/
_
(
canary
|
chromium
)
/
"
_chrome
"
)
;
const
OVERRIDES
=
{
"
4_firefox
"
:
"
4_firefox_history_and_bookmarks
"
"
64_firefox
"
:
"
64_firefox_other
"
}
;
aKey
=
OVERRIDES
[
aKey
]
|
|
aKey
;
if
(
aReplacements
=
=
=
undefined
)
return
getMigrationBundle
(
)
.
GetStringFromName
(
aKey
)
;
return
getMigrationBundle
(
)
.
formatStringFromName
(
aKey
aReplacements
aReplacements
.
length
)
;
}
_getLocalePropertyForBrowser
(
browserId
)
{
switch
(
browserId
)
{
case
"
edge
"
:
return
"
sourceNameEdge
"
;
case
"
ie
"
:
return
"
sourceNameIE
"
;
case
"
safari
"
:
return
"
sourceNameSafari
"
;
case
"
canary
"
:
return
"
sourceNameCanary
"
;
case
"
chrome
"
:
return
"
sourceNameChrome
"
;
case
"
chromium
"
:
return
"
sourceNameChromium
"
;
case
"
firefox
"
:
return
"
sourceNameFirefox
"
;
case
"
360se
"
:
return
"
sourceName360se
"
;
}
return
null
;
}
getBrowserName
(
browserId
)
{
let
prop
=
this
.
_getLocalePropertyForBrowser
(
browserId
)
;
if
(
prop
)
{
return
this
.
getLocalizedString
(
prop
)
;
}
return
null
;
}
async
createImportedBookmarksFolder
(
sourceNameStr
parentGuid
)
{
let
source
=
this
.
getLocalizedString
(
"
sourceName
"
+
sourceNameStr
)
;
let
title
=
this
.
getLocalizedString
(
"
importedBookmarksFolder
"
[
source
]
)
;
return
(
await
PlacesUtils
.
bookmarks
.
insert
(
{
type
:
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
parentGuid
title
}
)
)
.
guid
;
}
getRowsFromDBWithoutLocks
(
path
description
selectQuery
)
{
let
dbOptions
=
{
readOnly
:
true
ignoreLockingMode
:
true
path
}
;
const
RETRYLIMIT
=
10
;
const
RETRYINTERVAL
=
100
;
return
(
async
function
innerGetRows
(
)
{
let
rows
=
null
;
for
(
let
retryCount
=
RETRYLIMIT
;
retryCount
&
&
!
rows
;
retryCount
-
-
)
{
let
db
;
let
didOpen
=
false
;
let
exceptionSeen
;
try
{
db
=
await
Sqlite
.
openConnection
(
dbOptions
)
;
didOpen
=
true
;
rows
=
await
db
.
execute
(
selectQuery
)
;
}
catch
(
ex
)
{
if
(
!
exceptionSeen
)
{
Cu
.
reportError
(
ex
)
;
}
exceptionSeen
=
ex
;
}
finally
{
try
{
if
(
didOpen
)
{
await
db
.
close
(
)
;
}
}
catch
(
ex
)
{
}
}
if
(
exceptionSeen
)
{
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
RETRYINTERVAL
)
)
;
}
}
if
(
!
rows
)
{
throw
new
Error
(
"
Couldn
'
t
get
rows
from
the
"
+
description
+
"
database
.
"
)
;
}
return
rows
;
}
)
(
)
;
}
get
_migrators
(
)
{
if
(
!
gMigrators
)
{
gMigrators
=
new
Map
(
)
;
}
return
gMigrators
;
}
forceExitSpinResolve
:
function
MU_forceExitSpinResolve
(
)
{
gForceExitSpinResolve
=
true
;
}
spinResolve
:
function
MU_spinResolve
(
promise
)
{
if
(
!
(
promise
instanceof
Promise
)
)
{
return
promise
;
}
let
done
=
false
;
let
result
=
null
;
let
error
=
null
;
gForceExitSpinResolve
=
false
;
promise
.
catch
(
e
=
>
{
error
=
e
;
}
)
.
then
(
r
=
>
{
result
=
r
;
done
=
true
;
}
)
;
Services
.
tm
.
spinEventLoopUntil
(
(
)
=
>
done
|
|
gForceExitSpinResolve
)
;
if
(
!
done
)
{
throw
new
Error
(
"
Forcefully
exited
event
loop
.
"
)
;
}
else
if
(
error
)
{
throw
error
;
}
else
{
return
result
;
}
}
getMigrator
:
async
function
MU_getMigrator
(
aKey
)
{
let
migrator
=
null
;
if
(
this
.
_migrators
.
has
(
aKey
)
)
{
migrator
=
this
.
_migrators
.
get
(
aKey
)
;
}
else
{
try
{
migrator
=
Cc
[
"
mozilla
.
org
/
profile
/
migrator
;
1
?
app
=
browser
&
type
=
"
+
aKey
]
.
createInstance
(
Ci
.
nsIBrowserProfileMigrator
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
this
.
_migrators
.
set
(
aKey
migrator
)
;
}
try
{
return
migrator
&
&
(
await
migrator
.
isSourceAvailable
(
)
)
?
migrator
:
null
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
return
null
;
}
}
getMigratorKeyForDefaultBrowser
(
)
{
const
APP_DESC_TO_KEY
=
{
"
Internet
Explorer
"
:
"
ie
"
"
Microsoft
Edge
"
:
"
edge
"
"
Safari
"
:
"
safari
"
"
Firefox
"
:
"
firefox
"
"
Nightly
"
:
"
firefox
"
"
Google
Chrome
"
:
"
chrome
"
"
Chrome
"
:
"
chrome
"
"
Chromium
"
:
"
chromium
"
"
Chromium
Web
Browser
"
:
"
chromium
"
"
360
\
u5b89
\
u5168
\
u6d4f
\
u89c8
\
u5668
"
:
"
360se
"
}
;
let
key
=
"
"
;
try
{
let
browserDesc
=
Cc
[
"
mozilla
.
org
/
uriloader
/
external
-
protocol
-
service
;
1
"
]
.
getService
(
Ci
.
nsIExternalProtocolService
)
.
getApplicationDescription
(
"
http
"
)
;
key
=
APP_DESC_TO_KEY
[
browserDesc
]
|
|
"
"
;
if
(
!
key
&
&
browserDesc
.
startsWith
(
"
Firefox
"
)
)
{
key
=
"
firefox
"
;
}
}
catch
(
ex
)
{
Cu
.
reportError
(
"
Could
not
detect
default
browser
:
"
+
ex
)
;
}
if
(
key
=
=
"
firefox
"
&
&
AppConstants
.
isPlatformAndVersionAtMost
(
"
win
"
"
6
.
2
"
)
)
{
if
(
gPreviousDefaultBrowserKey
)
{
key
=
gPreviousDefaultBrowserKey
;
}
else
{
const
kRegPath
=
"
Software
\
\
Mozilla
\
\
Firefox
"
;
let
oldDefault
=
WindowsRegistry
.
readRegKey
(
Ci
.
nsIWindowsRegKey
.
ROOT_KEY_CURRENT_USER
kRegPath
"
OldDefaultBrowserCommand
"
)
;
if
(
oldDefault
)
{
WindowsRegistry
.
removeRegKey
(
Ci
.
nsIWindowsRegKey
.
ROOT_KEY_CURRENT_USER
kRegPath
"
OldDefaultBrowserCommand
"
)
;
try
{
let
file
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsILocalFileWin
)
;
file
.
initWithCommandLine
(
oldDefault
)
;
key
=
APP_DESC_TO_KEY
[
file
.
getVersionInfoField
(
"
FileDescription
"
)
]
|
|
key
;
gPreviousDefaultBrowserKey
=
key
;
}
catch
(
ex
)
{
Cu
.
reportError
(
"
Could
not
convert
old
default
browser
value
to
description
.
"
)
;
}
}
}
}
return
key
;
}
get
isStartupMigration
(
)
{
return
gProfileStartup
!
=
null
;
}
get
profileStartup
(
)
{
return
gProfileStartup
;
}
showMigrationWizard
:
function
MU_showMigrationWizard
(
aOpener
aParams
)
{
let
features
=
"
chrome
dialog
modal
centerscreen
titlebar
resizable
=
no
"
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
&
&
!
this
.
isStartupMigration
)
{
let
win
=
Services
.
wm
.
getMostRecentWindow
(
"
Browser
:
MigrationWizard
"
)
;
if
(
win
)
{
win
.
focus
(
)
;
return
;
}
features
=
"
centerscreen
chrome
resizable
=
no
"
;
}
let
params
;
if
(
Array
.
isArray
(
aParams
)
)
{
params
=
Cc
[
"
mozilla
.
org
/
array
;
1
"
]
.
createInstance
(
Ci
.
nsIMutableArray
)
;
for
(
let
item
of
aParams
)
{
let
comtaminatedVal
;
if
(
item
&
&
item
instanceof
Ci
.
nsISupports
)
{
comtaminatedVal
=
item
;
}
else
{
switch
(
typeof
item
)
{
case
"
boolean
"
:
comtaminatedVal
=
Cc
[
"
mozilla
.
org
/
supports
-
PRBool
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsPRBool
)
;
comtaminatedVal
.
data
=
item
;
break
;
case
"
number
"
:
comtaminatedVal
=
Cc
[
"
mozilla
.
org
/
supports
-
PRUint32
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsPRUint32
)
;
comtaminatedVal
.
data
=
item
;
break
;
case
"
string
"
:
comtaminatedVal
=
Cc
[
"
mozilla
.
org
/
supports
-
cstring
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsCString
)
;
comtaminatedVal
.
data
=
item
;
break
;
case
"
undefined
"
:
case
"
object
"
:
if
(
!
item
)
{
comtaminatedVal
=
null
;
break
;
}
default
:
throw
new
Error
(
"
Unexpected
parameter
type
"
+
(
typeof
item
)
+
"
:
"
+
item
)
;
}
}
params
.
appendElement
(
comtaminatedVal
)
;
}
}
else
{
params
=
aParams
;
}
Services
.
ww
.
openWindow
(
aOpener
"
chrome
:
/
/
browser
/
content
/
migration
/
migration
.
xul
"
"
_blank
"
features
params
)
;
}
startupMigration
:
function
MU_startupMigrator
(
aProfileStartup
aMigratorKey
aProfileToMigrate
)
{
if
(
Services
.
prefs
.
getBoolPref
(
"
browser
.
migrate
.
automigrate
.
enabled
"
false
)
)
{
this
.
asyncStartupMigration
(
aProfileStartup
aMigratorKey
aProfileToMigrate
)
;
}
else
{
this
.
spinResolve
(
this
.
asyncStartupMigration
(
aProfileStartup
aMigratorKey
aProfileToMigrate
)
)
;
}
}
asyncStartupMigration
:
async
function
MU_asyncStartupMigrator
(
aProfileStartup
aMigratorKey
aProfileToMigrate
)
{
if
(
!
aProfileStartup
)
{
throw
new
Error
(
"
an
profile
-
startup
instance
is
required
for
startup
-
migration
"
)
;
}
gProfileStartup
=
aProfileStartup
;
let
skipSourcePage
=
false
migrator
=
null
migratorKey
=
"
"
;
if
(
aMigratorKey
)
{
migrator
=
await
this
.
getMigrator
(
aMigratorKey
)
;
if
(
!
migrator
)
{
this
.
finishMigration
(
)
;
throw
new
Error
(
"
startMigration
was
asked
to
open
auto
-
migrate
from
"
+
"
a
non
-
existent
source
:
"
+
aMigratorKey
)
;
}
migratorKey
=
aMigratorKey
;
skipSourcePage
=
true
;
}
else
{
let
defaultBrowserKey
=
this
.
getMigratorKeyForDefaultBrowser
(
)
;
if
(
defaultBrowserKey
)
{
migrator
=
await
this
.
getMigrator
(
defaultBrowserKey
)
;
if
(
migrator
)
migratorKey
=
defaultBrowserKey
;
}
}
if
(
!
migrator
)
{
let
migrators
=
await
Promise
.
all
(
gAvailableMigratorKeys
.
map
(
key
=
>
this
.
getMigrator
(
key
)
)
)
;
if
(
!
migrators
.
some
(
m
=
>
m
)
)
{
this
.
finishMigration
(
)
;
return
;
}
}
let
isRefresh
=
migrator
&
&
skipSourcePage
&
&
migratorKey
=
=
AppConstants
.
MOZ_APP_NAME
;
if
(
!
isRefresh
&
&
AutoMigrate
.
enabled
)
{
try
{
await
AutoMigrate
.
migrate
(
aProfileStartup
migratorKey
aProfileToMigrate
)
;
return
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
}
let
migrationEntryPoint
=
this
.
MIGRATION_ENTRYPOINT_FIRSTRUN
;
if
(
isRefresh
)
{
migrationEntryPoint
=
this
.
MIGRATION_ENTRYPOINT_FXREFRESH
;
}
let
params
=
[
migrationEntryPoint
migratorKey
migrator
aProfileStartup
skipSourcePage
aProfileToMigrate
]
;
this
.
showMigrationWizard
(
null
params
)
;
}
_importQuantities
:
{
bookmarks
:
0
logins
:
0
history
:
0
}
insertBookmarkWrapper
(
bookmark
)
{
this
.
_importQuantities
.
bookmarks
+
+
;
let
insertionPromise
=
PlacesUtils
.
bookmarks
.
insert
(
bookmark
)
;
if
(
!
gKeepUndoData
)
{
return
insertionPromise
;
}
let
{
parentGuid
}
=
bookmark
;
return
insertionPromise
.
then
(
bm
=
>
{
let
{
guid
lastModified
type
}
=
bm
;
gUndoData
.
get
(
"
bookmarks
"
)
.
push
(
{
parentGuid
guid
lastModified
type
}
)
;
return
bm
;
}
)
;
}
insertManyBookmarksWrapper
(
bookmarks
parent
)
{
let
insertionPromise
=
PlacesUtils
.
bookmarks
.
insertTree
(
{
guid
:
parent
children
:
bookmarks
}
)
;
return
insertionPromise
.
then
(
insertedItems
=
>
{
this
.
_importQuantities
.
bookmarks
+
=
insertedItems
.
length
;
if
(
gKeepUndoData
)
{
let
bmData
=
gUndoData
.
get
(
"
bookmarks
"
)
;
for
(
let
bm
of
insertedItems
)
{
let
{
parentGuid
guid
lastModified
type
}
=
bm
;
bmData
.
push
(
{
parentGuid
guid
lastModified
type
}
)
;
}
}
}
ex
=
>
Cu
.
reportError
(
ex
)
)
;
}
insertVisitsWrapper
(
places
options
)
{
this
.
_importQuantities
.
history
+
=
places
.
length
;
if
(
gKeepUndoData
)
{
this
.
_updateHistoryUndo
(
places
)
;
}
return
PlacesUtils
.
asyncHistory
.
updatePlaces
(
places
options
true
)
;
}
insertLoginWrapper
(
login
)
{
this
.
_importQuantities
.
logins
+
+
;
let
insertedLogin
=
LoginHelper
.
maybeImportLogin
(
login
)
;
if
(
insertedLogin
&
&
gKeepUndoData
)
{
let
{
guid
timePasswordChanged
}
=
insertedLogin
;
gUndoData
.
get
(
"
logins
"
)
.
push
(
{
guid
timePasswordChanged
}
)
;
}
}
async
insertLoginsWrapper
(
logins
)
{
this
.
_importQuantities
.
logins
+
=
logins
.
length
;
let
inserted
=
await
LoginHelper
.
maybeImportLogins
(
logins
)
;
if
(
gKeepUndoData
)
{
for
(
let
{
guid
timePasswordChanged
}
of
inserted
)
{
gUndoData
.
get
(
"
logins
"
)
.
push
(
{
guid
timePasswordChanged
}
)
;
}
}
}
initializeUndoData
(
)
{
gKeepUndoData
=
true
;
gUndoData
=
new
Map
(
[
[
"
bookmarks
"
[
]
]
[
"
visits
"
[
]
]
[
"
logins
"
[
]
]
]
)
;
}
async
_postProcessUndoData
(
state
)
{
if
(
!
state
)
{
return
state
;
}
let
bookmarkFolders
=
state
.
get
(
"
bookmarks
"
)
.
filter
(
b
=
>
b
.
type
=
=
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
)
;
let
bookmarkFolderData
=
[
]
;
let
bmPromises
=
bookmarkFolders
.
map
(
(
{
guid
}
)
=
>
{
return
PlacesUtils
.
bookmarks
.
fetch
(
guid
)
.
then
(
bm
=
>
bm
&
&
bookmarkFolderData
.
push
(
bm
)
(
)
=
>
{
}
)
;
}
)
;
await
Promise
.
all
(
bmPromises
)
;
let
folderLMMap
=
new
Map
(
bookmarkFolderData
.
map
(
b
=
>
[
b
.
guid
b
.
lastModified
]
)
)
;
for
(
let
bookmark
of
bookmarkFolders
)
{
let
lastModified
=
folderLMMap
.
get
(
bookmark
.
guid
)
;
if
(
lastModified
)
{
bookmark
.
lastModified
=
lastModified
;
}
}
return
state
;
}
stopAndRetrieveUndoData
(
)
{
let
undoData
=
gUndoData
;
gUndoData
=
null
;
gKeepUndoData
=
false
;
return
this
.
_postProcessUndoData
(
undoData
)
;
}
_updateHistoryUndo
(
places
)
{
let
visits
=
gUndoData
.
get
(
"
visits
"
)
;
let
visitMap
=
new
Map
(
visits
.
map
(
v
=
>
[
v
.
url
v
]
)
)
;
for
(
let
place
of
places
)
{
let
visitCount
=
place
.
visits
.
length
;
let
first
last
;
if
(
visitCount
>
1
)
{
let
visitDates
=
place
.
visits
.
map
(
v
=
>
v
.
visitDate
)
;
first
=
Math
.
min
.
apply
(
Math
visitDates
)
;
last
=
Math
.
max
.
apply
(
Math
visitDates
)
;
}
else
{
first
=
last
=
place
.
visits
[
0
]
.
visitDate
;
}
let
url
=
place
.
uri
.
spec
;
try
{
new
URL
(
url
)
;
}
catch
(
ex
)
{
continue
;
}
if
(
!
visitMap
.
has
(
url
)
)
{
visitMap
.
set
(
url
{
url
visitCount
first
last
}
)
;
}
else
{
let
currentData
=
visitMap
.
get
(
url
)
;
currentData
.
visitCount
+
=
visitCount
;
currentData
.
first
=
Math
.
min
(
currentData
.
first
first
)
;
currentData
.
last
=
Math
.
max
(
currentData
.
last
last
)
;
}
}
gUndoData
.
set
(
"
visits
"
Array
.
from
(
visitMap
.
values
(
)
)
)
;
}
finishMigration
:
function
MU_finishMigration
(
)
{
gMigrators
=
null
;
gProfileStartup
=
null
;
gMigrationBundle
=
null
;
}
gAvailableMigratorKeys
MIGRATION_ENTRYPOINT_UNKNOWN
:
0
MIGRATION_ENTRYPOINT_FIRSTRUN
:
1
MIGRATION_ENTRYPOINT_FXREFRESH
:
2
MIGRATION_ENTRYPOINT_PLACES
:
3
MIGRATION_ENTRYPOINT_PASSWORDS
:
4
MIGRATION_ENTRYPOINT_NEWTAB
:
5
_sourceNameToIdMapping
:
{
"
nothing
"
:
1
"
firefox
"
:
2
"
edge
"
:
3
"
ie
"
:
4
"
chrome
"
:
5
"
chromium
"
:
6
"
canary
"
:
7
"
safari
"
:
8
"
360se
"
:
9
}
getSourceIdForTelemetry
(
sourceName
)
{
return
this
.
_sourceNameToIdMapping
[
sourceName
]
|
|
0
;
}
}
)
;
