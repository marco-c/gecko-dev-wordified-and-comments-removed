"
use
strict
"
;
const
Cc
=
Components
.
classes
;
const
Ci
=
Components
.
interfaces
;
const
Cu
=
Components
.
utils
;
const
Cr
=
Components
.
results
;
const
kLoginsKey
=
"
Software
\
\
Microsoft
\
\
Internet
Explorer
\
\
IntelliForms
\
\
Storage2
"
;
const
kMainKey
=
"
Software
\
\
Microsoft
\
\
Internet
Explorer
\
\
Main
"
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
/
modules
/
MigrationUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
/
modules
/
MSMigrationUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
LoginHelper
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
ctypes
"
"
resource
:
/
/
gre
/
modules
/
ctypes
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PlacesUtils
"
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
OSCrypto
"
"
resource
:
/
/
gre
/
modules
/
OSCrypto
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
WindowsRegistry
"
"
resource
:
/
/
gre
/
modules
/
WindowsRegistry
.
jsm
"
)
;
Cu
.
importGlobalProperties
(
[
"
URL
"
]
)
;
var
CtypesKernelHelpers
=
MSMigrationUtils
.
CtypesKernelHelpers
;
function
History
(
)
{
}
History
.
prototype
=
{
type
:
MigrationUtils
.
resourceTypes
.
HISTORY
get
exists
(
)
{
return
true
;
}
migrate
:
function
H_migrate
(
aCallback
)
{
let
places
=
[
]
;
let
typedURLs
=
MSMigrationUtils
.
getTypedURLs
(
"
Software
\
\
Microsoft
\
\
Internet
Explorer
"
)
;
let
historyEnumerator
=
Cc
[
"
mozilla
.
org
/
profile
/
migrator
/
iehistoryenumerator
;
1
"
]
.
createInstance
(
Ci
.
nsISimpleEnumerator
)
;
while
(
historyEnumerator
.
hasMoreElements
(
)
)
{
let
entry
=
historyEnumerator
.
getNext
(
)
.
QueryInterface
(
Ci
.
nsIPropertyBag2
)
;
let
uri
=
entry
.
get
(
"
uri
"
)
.
QueryInterface
(
Ci
.
nsIURI
)
;
if
(
[
"
http
"
"
https
"
"
ftp
"
"
file
"
]
.
indexOf
(
uri
.
scheme
)
=
=
-
1
)
{
continue
;
}
let
title
=
entry
.
get
(
"
title
"
)
;
if
(
title
.
length
=
=
0
)
{
continue
;
}
let
transitionType
=
typedURLs
.
has
(
uri
.
spec
)
?
Ci
.
nsINavHistoryService
.
TRANSITION_TYPED
:
Ci
.
nsINavHistoryService
.
TRANSITION_LINK
;
let
lastVisitTime
=
entry
.
get
(
"
time
"
)
|
|
(
Date
.
now
(
)
*
1000
)
;
places
.
push
(
{
uri
:
uri
title
:
title
visits
:
[
{
transitionType
:
transitionType
visitDate
:
lastVisitTime
}
]
}
)
;
}
if
(
places
.
length
=
=
0
)
{
aCallback
(
true
)
;
return
;
}
PlacesUtils
.
asyncHistory
.
updatePlaces
(
places
{
_success
:
false
handleResult
:
function
(
)
{
this
.
_success
=
true
;
}
handleError
:
function
(
)
{
}
handleCompletion
:
function
(
)
{
aCallback
(
this
.
_success
)
;
}
}
)
;
}
}
;
function
IE7FormPasswords
(
)
{
this
.
name
=
"
IE7FormPasswords
"
;
}
IE7FormPasswords
.
prototype
=
{
type
:
MigrationUtils
.
resourceTypes
.
PASSWORDS
get
exists
(
)
{
if
(
AppConstants
.
isPlatformAndVersionAtLeast
(
"
win
"
"
6
.
2
"
)
)
{
return
false
;
}
try
{
let
nsIWindowsRegKey
=
Ci
.
nsIWindowsRegKey
;
let
key
=
Cc
[
"
mozilla
.
org
/
windows
-
registry
-
key
;
1
"
]
.
createInstance
(
nsIWindowsRegKey
)
;
key
.
open
(
nsIWindowsRegKey
.
ROOT_KEY_CURRENT_USER
kLoginsKey
nsIWindowsRegKey
.
ACCESS_READ
)
;
let
count
=
key
.
valueCount
;
key
.
close
(
)
;
return
count
>
0
;
}
catch
(
e
)
{
return
false
;
}
}
migrate
(
aCallback
)
{
let
historyEnumerator
=
Cc
[
"
mozilla
.
org
/
profile
/
migrator
/
iehistoryenumerator
;
1
"
]
.
createInstance
(
Ci
.
nsISimpleEnumerator
)
;
let
uris
=
[
]
;
while
(
historyEnumerator
.
hasMoreElements
(
)
)
{
let
entry
=
historyEnumerator
.
getNext
(
)
.
QueryInterface
(
Ci
.
nsIPropertyBag2
)
;
let
uri
=
entry
.
get
(
"
uri
"
)
.
QueryInterface
(
Ci
.
nsIURI
)
;
if
(
[
"
http
"
"
https
"
"
ftp
"
]
.
indexOf
(
uri
.
scheme
)
=
=
-
1
)
{
continue
;
}
uris
.
push
(
uri
)
;
}
this
.
_migrateURIs
(
uris
)
;
aCallback
(
true
)
;
}
_migrateURIs
(
uris
)
{
this
.
ctypesKernelHelpers
=
new
MSMigrationUtils
.
CtypesKernelHelpers
(
)
;
this
.
_crypto
=
new
OSCrypto
(
)
;
let
nsIWindowsRegKey
=
Ci
.
nsIWindowsRegKey
;
let
key
=
Cc
[
"
mozilla
.
org
/
windows
-
registry
-
key
;
1
"
]
.
createInstance
(
nsIWindowsRegKey
)
;
key
.
open
(
nsIWindowsRegKey
.
ROOT_KEY_CURRENT_USER
kLoginsKey
nsIWindowsRegKey
.
ACCESS_READ
)
;
let
urlsSet
=
new
Set
(
)
;
let
successfullyDecryptedValues
=
0
;
for
(
let
uri
of
uris
)
{
try
{
let
urlObject
=
new
URL
(
uri
.
spec
)
;
let
url
=
urlObject
.
origin
+
urlObject
.
pathname
;
if
(
urlsSet
.
has
(
url
)
)
{
continue
;
}
urlsSet
.
add
(
url
)
;
let
hashStr
=
this
.
_crypto
.
getIELoginHash
(
url
)
;
if
(
!
key
.
hasValue
(
hashStr
)
)
{
continue
;
}
let
value
=
key
.
readBinaryValue
(
hashStr
)
;
if
(
value
=
=
null
)
{
continue
;
}
let
data
;
try
{
data
=
this
.
_crypto
.
decryptData
(
value
url
true
)
;
}
catch
(
e
)
{
continue
;
}
let
ieLogins
=
this
.
_extractDetails
(
data
uri
)
;
if
(
ieLogins
.
length
)
{
successfullyDecryptedValues
+
+
;
}
this
.
_addLogins
(
ieLogins
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
"
Error
while
importing
logins
for
"
+
uri
.
spec
+
"
:
"
+
e
)
;
}
}
if
(
successfullyDecryptedValues
<
key
.
valueCount
)
{
Cu
.
reportError
(
"
We
failed
to
decrypt
and
import
some
logins
.
"
+
"
This
is
likely
because
we
didn
'
t
find
the
URLs
where
these
"
+
"
passwords
were
submitted
in
the
IE
history
and
which
are
needed
to
be
used
"
+
"
as
keys
in
the
decryption
.
"
)
;
}
key
.
close
(
)
;
this
.
_crypto
.
finalize
(
)
;
this
.
ctypesKernelHelpers
.
finalize
(
)
;
}
_crypto
:
null
_addLogins
(
ieLogins
)
{
for
(
let
ieLogin
of
ieLogins
)
{
try
{
let
login
=
{
username
:
ieLogin
.
username
password
:
ieLogin
.
password
hostname
:
ieLogin
.
url
timeCreated
:
ieLogin
.
creation
}
;
LoginHelper
.
maybeImportLogin
(
login
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
}
_extractDetails
(
data
uri
)
{
let
loginData
=
new
ctypes
.
StructType
(
"
loginData
"
[
{
"
unknown1
"
:
ctypes
.
uint32_t
}
{
"
headerSize
"
:
ctypes
.
uint32_t
}
{
"
dataSize
"
:
ctypes
.
uint32_t
}
{
"
unknown2
"
:
ctypes
.
uint32_t
}
{
"
unknown3
"
:
ctypes
.
uint32_t
}
{
"
dataMax
"
:
ctypes
.
uint32_t
}
{
"
unknown4
"
:
ctypes
.
uint32_t
}
{
"
unknown5
"
:
ctypes
.
uint32_t
}
{
"
unknown6
"
:
ctypes
.
uint32_t
}
]
)
;
let
loginItem
=
new
ctypes
.
StructType
(
"
loginItem
"
[
{
"
usernameOffset
"
:
ctypes
.
uint32_t
}
{
"
loDateTime
"
:
ctypes
.
uint32_t
}
{
"
hiDateTime
"
:
ctypes
.
uint32_t
}
{
"
foo
"
:
ctypes
.
uint32_t
}
{
"
passwordOffset
"
:
ctypes
.
uint32_t
}
{
"
unknown1
"
:
ctypes
.
uint32_t
}
{
"
unknown2
"
:
ctypes
.
uint32_t
}
{
"
unknown3
"
:
ctypes
.
uint32_t
}
]
)
;
let
url
=
uri
.
prePath
;
let
results
=
[
]
;
let
arr
=
this
.
_crypto
.
stringToArray
(
data
)
;
let
cdata
=
ctypes
.
unsigned_char
.
array
(
arr
.
length
)
(
arr
)
;
let
currentLoginData
=
ctypes
.
cast
(
cdata
loginData
)
;
let
headerSize
=
currentLoginData
.
headerSize
;
let
currentInfoIndex
=
loginData
.
size
;
let
currentLoginItemPointer
=
ctypes
.
cast
(
cdata
.
addressOfElement
(
currentInfoIndex
)
loginItem
.
ptr
)
;
let
numLogins
=
currentLoginData
.
dataMax
/
2
;
for
(
let
n
=
0
;
n
<
numLogins
;
n
+
+
)
{
let
currentLoginItem
=
currentLoginItemPointer
.
contents
;
let
creation
=
this
.
ctypesKernelHelpers
.
fileTimeToSecondsSinceEpoch
(
currentLoginItem
.
hiDateTime
currentLoginItem
.
loDateTime
)
*
1000
;
let
currentResult
=
{
creation
:
creation
url
:
url
}
;
currentResult
.
username
=
ctypes
.
cast
(
cdata
.
addressOfElement
(
headerSize
+
12
+
currentLoginItem
.
usernameOffset
)
ctypes
.
char16_t
.
ptr
)
.
readString
(
)
;
currentResult
.
password
=
ctypes
.
cast
(
cdata
.
addressOfElement
(
headerSize
+
12
+
currentLoginItem
.
passwordOffset
)
ctypes
.
char16_t
.
ptr
)
.
readString
(
)
;
results
.
push
(
currentResult
)
;
currentLoginItemPointer
=
currentLoginItemPointer
.
increment
(
)
;
}
return
results
;
}
}
;
function
Settings
(
)
{
}
Settings
.
prototype
=
{
type
:
MigrationUtils
.
resourceTypes
.
SETTINGS
get
exists
(
)
{
return
true
;
}
migrate
:
function
S_migrate
(
aCallback
)
{
let
yesNoToBoolean
=
v
=
>
v
=
=
"
yes
"
;
function
parseAcceptLanguageList
(
v
)
{
return
v
.
match
(
/
(
[
a
-
z
]
{
1
8
}
(
-
[
a
-
z
]
{
1
8
}
)
?
)
\
s
*
(
;
\
s
*
q
\
s
*
=
\
s
*
(
1
|
0
\
.
[
0
-
9
]
+
)
)
?
/
gi
)
.
sort
(
function
(
a
b
)
{
let
qA
=
parseFloat
(
a
.
split
(
"
;
q
=
"
)
[
1
]
)
|
|
1
.
0
;
let
qB
=
parseFloat
(
b
.
split
(
"
;
q
=
"
)
[
1
]
)
|
|
1
.
0
;
return
qB
-
qA
;
}
)
.
map
(
a
=
>
a
.
split
(
"
;
"
)
[
0
]
)
;
}
this
.
_set
(
"
Software
\
\
Microsoft
\
\
Internet
Explorer
\
\
International
"
"
AcceptLanguage
"
"
intl
.
accept_languages
"
parseAcceptLanguageList
)
;
this
.
_set
(
"
Software
\
\
Microsoft
\
\
Internet
Explorer
\
\
International
\
\
Scripts
\
\
3
"
"
IEFixedFontName
"
"
font
.
name
.
monospace
.
x
-
western
"
)
;
this
.
_set
(
kMainKey
"
Use
FormSuggest
"
"
browser
.
formfill
.
enable
"
yesNoToBoolean
)
;
this
.
_set
(
kMainKey
"
FormSuggest
Passwords
"
"
signon
.
rememberSignons
"
yesNoToBoolean
)
;
this
.
_set
(
kMainKey
"
Anchor
Underline
"
"
browser
.
underline_anchors
"
yesNoToBoolean
)
;
this
.
_set
(
kMainKey
"
Display
Inline
Images
"
"
permissions
.
default
.
image
"
v
=
>
yesNoToBoolean
(
v
)
?
1
:
2
)
;
this
.
_set
(
kMainKey
"
Move
System
Caret
"
"
accessibility
.
browsewithcaret
"
yesNoToBoolean
)
;
this
.
_set
(
"
Software
\
\
Microsoft
\
\
Internet
Explorer
\
\
Settings
"
"
Always
Use
My
Colors
"
"
browser
.
display
.
document_color_use
"
v
=
>
!
Boolean
(
v
)
?
0
:
2
)
;
this
.
_set
(
"
Software
\
\
Microsoft
\
\
Internet
Explorer
\
\
Settings
"
"
Always
Use
My
Font
Face
"
"
browser
.
display
.
use_document_fonts
"
v
=
>
!
Boolean
(
v
)
)
;
this
.
_set
(
kMainKey
"
SmoothScroll
"
"
general
.
smoothScroll
"
Boolean
)
;
this
.
_set
(
"
Software
\
\
Microsoft
\
\
Internet
Explorer
\
\
TabbedBrowsing
\
\
"
"
WarnOnClose
"
"
browser
.
tabs
.
warnOnClose
"
Boolean
)
;
this
.
_set
(
"
Software
\
\
Microsoft
\
\
Internet
Explorer
\
\
TabbedBrowsing
\
\
"
"
OpenInForeground
"
"
browser
.
tabs
.
loadInBackground
"
v
=
>
!
Boolean
(
v
)
)
;
aCallback
(
true
)
;
}
_set
:
function
S__set
(
aPath
aKey
aPref
aTransformFn
)
{
let
value
=
WindowsRegistry
.
readRegKey
(
Ci
.
nsIWindowsRegKey
.
ROOT_KEY_CURRENT_USER
aPath
aKey
)
;
if
(
value
=
=
=
undefined
)
return
;
if
(
aTransformFn
)
value
=
aTransformFn
(
value
)
;
switch
(
typeof
(
value
)
)
{
case
"
string
"
:
Services
.
prefs
.
setCharPref
(
aPref
value
)
;
break
;
case
"
number
"
:
Services
.
prefs
.
setIntPref
(
aPref
value
)
;
break
;
case
"
boolean
"
:
Services
.
prefs
.
setBoolPref
(
aPref
value
)
;
break
;
default
:
throw
new
Error
(
"
Unexpected
value
type
:
"
+
typeof
(
value
)
)
;
}
}
}
;
function
IEProfileMigrator
(
)
{
this
.
wrappedJSObject
=
this
;
}
IEProfileMigrator
.
prototype
=
Object
.
create
(
MigratorPrototype
)
;
IEProfileMigrator
.
prototype
.
getResources
=
function
IE_getResources
(
)
{
let
resources
=
[
MSMigrationUtils
.
getBookmarksMigrator
(
)
new
History
(
)
MSMigrationUtils
.
getCookiesMigrator
(
)
new
Settings
(
)
]
;
if
(
AppConstants
.
isPlatformAndVersionAtMost
(
"
win
"
"
6
.
1
"
)
)
{
resources
.
push
(
new
IE7FormPasswords
(
)
)
;
}
let
windowsVaultFormPasswordsMigrator
=
MSMigrationUtils
.
getWindowsVaultFormPasswordsMigrator
(
)
;
windowsVaultFormPasswordsMigrator
.
name
=
"
IEVaultFormPasswords
"
;
resources
.
push
(
windowsVaultFormPasswordsMigrator
)
;
return
resources
.
filter
(
r
=
>
r
.
exists
)
;
}
;
Object
.
defineProperty
(
IEProfileMigrator
.
prototype
"
sourceHomePageURL
"
{
get
:
function
IE_get_sourceHomePageURL
(
)
{
let
defaultStartPage
=
WindowsRegistry
.
readRegKey
(
Ci
.
nsIWindowsRegKey
.
ROOT_KEY_LOCAL_MACHINE
kMainKey
"
Default_Page_URL
"
)
;
let
startPage
=
WindowsRegistry
.
readRegKey
(
Ci
.
nsIWindowsRegKey
.
ROOT_KEY_CURRENT_USER
kMainKey
"
Start
Page
"
)
;
let
homepage
=
startPage
!
=
defaultStartPage
?
startPage
:
"
"
;
let
secondaryPages
=
WindowsRegistry
.
readRegKey
(
Ci
.
nsIWindowsRegKey
.
ROOT_KEY_CURRENT_USER
kMainKey
"
Secondary
Start
Pages
"
)
;
if
(
secondaryPages
)
{
if
(
homepage
)
secondaryPages
.
unshift
(
homepage
)
;
homepage
=
secondaryPages
.
join
(
"
|
"
)
;
}
return
homepage
;
}
}
)
;
IEProfileMigrator
.
prototype
.
classDescription
=
"
IE
Profile
Migrator
"
;
IEProfileMigrator
.
prototype
.
contractID
=
"
mozilla
.
org
/
profile
/
migrator
;
1
?
app
=
browser
&
type
=
ie
"
;
IEProfileMigrator
.
prototype
.
classID
=
Components
.
ID
(
"
{
3d2532e3
-
4932
-
4774
-
b7ba
-
968f5899d3a4
}
"
)
;
this
.
NSGetFactory
=
XPCOMUtils
.
generateNSGetFactory
(
[
IEProfileMigrator
]
)
;
