#
include
"
nsKeychainMigrationUtils
.
h
"
#
include
<
Security
/
Security
.
h
>
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
nsCocoaUtils
.
h
"
#
include
"
nsString
.
h
"
using
namespace
mozilla
;
LazyLogModule
gKeychainUtilsLog
(
"
keychainmigrationutils
"
)
;
NS_IMPL_ISUPPORTS
(
nsKeychainMigrationUtils
nsIKeychainMigrationUtils
)
NS_IMETHODIMP
nsKeychainMigrationUtils
:
:
GetGenericPassword
(
const
nsACString
&
aServiceName
const
nsACString
&
aAccountName
nsACString
&
aKey
)
{
NSDictionary
*
searchDictionary
=
{
(
__bridge
NSString
*
)
kSecClass
:
(
__bridge
NSString
*
)
kSecClassGenericPassword
(
__bridge
NSString
*
)
kSecAttrService
:
nsCocoaUtils
:
:
ToNSString
(
aServiceName
)
(
__bridge
NSString
*
)
kSecAttrAccount
:
nsCocoaUtils
:
:
ToNSString
(
aAccountName
)
(
__bridge
NSString
*
)
kSecMatchLimit
:
(
__bridge
NSString
*
)
kSecMatchLimitOne
(
__bridge
NSString
*
)
kSecReturnAttributes
:
YES
(
__bridge
NSString
*
)
kSecReturnData
:
YES
}
;
CFTypeRef
item
;
OSStatus
rv
=
SecItemCopyMatching
(
(
__bridge
CFDictionaryRef
)
searchDictionary
&
item
)
;
if
(
rv
!
=
errSecSuccess
)
{
MOZ_LOG
(
gKeychainUtilsLog
LogLevel
:
:
Debug
(
"
SecItemCopyMatching
failed
:
%
d
"
rv
)
)
;
return
NS_ERROR_FAILURE
;
}
NSDictionary
*
resultDict
=
[
(
__bridge
NSDictionary
*
)
item
autorelease
]
;
NSData
*
secret
=
[
resultDict
objectForKey
:
(
__bridge
NSString
*
)
kSecValueData
]
;
if
(
!
secret
)
{
MOZ_LOG
(
gKeychainUtilsLog
LogLevel
:
:
Debug
(
"
objectForKey
failed
"
)
)
;
return
NS_ERROR_FAILURE
;
}
if
(
[
secret
length
]
!
=
0
)
{
aKey
.
Assign
(
reinterpret_cast
<
const
char
*
>
(
[
secret
bytes
]
)
[
secret
length
]
)
;
}
return
NS_OK
;
}
