"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
SessionHistoryListener
"
]
;
ChromeUtils
.
defineModuleGetter
(
this
"
SessionHistory
"
"
resource
:
/
/
gre
/
modules
/
sessionstore
/
SessionHistory
.
jsm
"
)
;
const
kNoIndex
=
Number
.
MAX_SAFE_INTEGER
;
const
kLastIndex
=
Number
.
MAX_SAFE_INTEGER
-
1
;
class
StateChangeNotifier
{
constructor
(
store
)
{
this
.
store
=
store
;
this
.
_observers
=
new
Set
(
)
;
let
webProgress
=
this
.
mm
.
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebProgress
)
;
webProgress
.
addProgressListener
(
this
Ci
.
nsIWebProgress
.
NOTIFY_STATE_DOCUMENT
)
;
}
get
mm
(
)
{
return
this
.
store
.
mm
;
}
addObserver
(
obs
)
{
this
.
_observers
.
add
(
obs
)
;
}
notifyObservers
(
method
)
{
for
(
let
obs
of
this
.
_observers
)
{
if
(
typeof
obs
[
method
]
=
=
"
function
"
)
{
obs
[
method
]
(
)
;
}
}
}
onStateChange
(
webProgress
request
stateFlags
status
)
{
if
(
!
webProgress
.
isTopLevel
|
|
webProgress
.
DOMWindow
!
=
this
.
mm
.
content
)
{
return
;
}
if
(
!
this
.
mm
.
docShell
.
hasLoadedNonBlankURI
)
{
return
;
}
if
(
stateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_START
)
{
this
.
notifyObservers
(
"
onPageLoadStarted
"
)
;
}
else
if
(
stateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_STOP
)
{
this
.
notifyObservers
(
"
onPageLoadCompleted
"
)
;
}
}
}
StateChangeNotifier
.
prototype
.
QueryInterface
=
ChromeUtils
.
generateQI
(
[
Ci
.
nsIWebProgressListener
Ci
.
nsISupportsWeakReference
]
)
;
class
SessionHistoryListener
{
constructor
(
store
)
{
this
.
store
=
store
;
this
.
_fromIdx
=
kNoIndex
;
this
.
stateChangeNotifier
=
new
StateChangeNotifier
(
this
)
;
this
.
stateChangeNotifier
.
addObserver
(
this
)
;
this
.
mm
.
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
.
sessionHistory
.
legacySHistory
.
addSHistoryListener
(
this
)
;
if
(
!
SessionHistory
.
isEmpty
(
this
.
mm
.
docShell
)
)
{
this
.
collect
(
)
;
this
.
store
.
messageQueue
.
send
(
)
;
}
this
.
mm
.
addEventListener
(
"
DOMTitleChanged
"
this
)
;
}
get
mm
(
)
{
return
this
.
store
.
mm
;
}
uninit
(
)
{
let
sessionHistory
=
this
.
mm
.
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
.
sessionHistory
;
if
(
sessionHistory
)
{
sessionHistory
.
legacySHistory
.
removeSHistoryListener
(
this
)
;
}
}
collect
(
)
{
if
(
this
.
mm
.
docShell
)
{
this
.
collectFrom
(
-
1
)
;
}
}
collectFrom
(
idx
)
{
if
(
this
.
_fromIdx
<
=
idx
)
{
return
;
}
this
.
_fromIdx
=
idx
;
this
.
store
.
messageQueue
.
push
(
"
historychange
"
(
)
=
>
{
if
(
this
.
_fromIdx
=
=
=
kNoIndex
)
{
return
null
;
}
let
history
=
SessionHistory
.
collect
(
this
.
mm
.
docShell
this
.
_fromIdx
)
;
this
.
_fromIdx
=
kNoIndex
;
return
history
;
}
)
;
}
handleEvent
(
event
)
{
this
.
collect
(
)
;
}
onPageLoadCompleted
(
)
{
this
.
collect
(
)
;
}
onPageLoadStarted
(
)
{
this
.
collect
(
)
;
}
OnHistoryNewEntry
(
newURI
oldIndex
)
{
this
.
collectFrom
(
oldIndex
)
;
}
OnHistoryGotoIndex
(
)
{
this
.
collectFrom
(
kLastIndex
)
;
}
OnHistoryPurge
(
)
{
this
.
collect
(
)
;
}
OnHistoryReload
(
)
{
this
.
collect
(
)
;
return
true
;
}
OnHistoryReplaceEntry
(
)
{
this
.
collect
(
)
;
}
}
SessionHistoryListener
.
prototype
.
QueryInterface
=
ChromeUtils
.
generateQI
(
[
Ci
.
nsISHistoryListener
Ci
.
nsISupportsWeakReference
]
)
;
