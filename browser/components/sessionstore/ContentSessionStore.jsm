"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
ContentSessionStore
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
this
)
;
function
debug
(
msg
)
{
Services
.
console
.
logStringMessage
(
"
SessionStoreContent
:
"
+
msg
)
;
}
ChromeUtils
.
defineModuleGetter
(
this
"
ContentRestore
"
"
resource
:
/
/
/
modules
/
sessionstore
/
ContentRestore
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
SessionHistory
"
"
resource
:
/
/
gre
/
modules
/
sessionstore
/
SessionHistory
.
jsm
"
)
;
const
TIMEOUT_DISABLED_PREF
=
"
browser
.
sessionstore
.
debug
.
no_auto_updates
"
;
const
PREF_INTERVAL
=
"
browser
.
sessionstore
.
interval
"
;
const
kNoIndex
=
Number
.
MAX_SAFE_INTEGER
;
const
kLastIndex
=
Number
.
MAX_SAFE_INTEGER
-
1
;
class
Handler
{
constructor
(
store
)
{
this
.
store
=
store
;
}
get
contentRestore
(
)
{
return
this
.
store
.
contentRestore
;
}
get
contentRestoreInitialized
(
)
{
return
this
.
store
.
contentRestoreInitialized
;
}
get
mm
(
)
{
return
this
.
store
.
mm
;
}
get
messageQueue
(
)
{
return
this
.
store
.
messageQueue
;
}
}
class
EventListener
extends
Handler
{
constructor
(
store
)
{
super
(
store
)
;
SessionStoreUtils
.
addDynamicFrameFilteredListener
(
this
.
mm
"
load
"
this
true
)
;
}
handleEvent
(
event
)
{
let
{
content
}
=
this
.
mm
;
if
(
event
.
target
!
=
content
.
document
)
{
return
;
}
if
(
content
.
document
.
documentURI
.
startsWith
(
"
about
:
reader
"
)
)
{
if
(
event
.
type
=
=
"
load
"
&
&
!
content
.
document
.
body
.
classList
.
contains
(
"
loaded
"
)
)
{
content
.
addEventListener
(
"
AboutReaderContentReady
"
this
)
;
return
;
}
content
.
removeEventListener
(
"
AboutReaderContentReady
"
this
)
;
}
if
(
this
.
contentRestoreInitialized
)
{
this
.
contentRestore
.
restoreDocument
(
)
;
}
}
}
class
SessionHistoryListener
extends
Handler
{
constructor
(
store
)
{
super
(
store
)
;
this
.
_fromIdx
=
kNoIndex
;
this
.
mm
.
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
.
sessionHistory
.
legacySHistory
.
addSHistoryListener
(
this
)
;
let
webProgress
=
this
.
mm
.
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebProgress
)
;
webProgress
.
addProgressListener
(
this
Ci
.
nsIWebProgress
.
NOTIFY_STATE_DOCUMENT
)
;
if
(
!
SessionHistory
.
isEmpty
(
this
.
mm
.
docShell
)
)
{
this
.
collect
(
)
;
this
.
store
.
messageQueue
.
send
(
)
;
}
this
.
mm
.
addEventListener
(
"
DOMTitleChanged
"
this
)
;
}
get
mm
(
)
{
return
this
.
store
.
mm
;
}
uninit
(
)
{
let
sessionHistory
=
this
.
mm
.
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
.
sessionHistory
;
if
(
sessionHistory
)
{
sessionHistory
.
legacySHistory
.
removeSHistoryListener
(
this
)
;
}
}
collect
(
)
{
if
(
this
.
mm
.
docShell
)
{
this
.
collectFrom
(
-
1
)
;
}
}
collectFrom
(
idx
)
{
if
(
this
.
_fromIdx
<
=
idx
)
{
return
;
}
this
.
_fromIdx
=
idx
;
this
.
store
.
messageQueue
.
push
(
"
historychange
"
(
)
=
>
{
if
(
this
.
_fromIdx
=
=
=
kNoIndex
)
{
return
null
;
}
let
history
=
SessionHistory
.
collect
(
this
.
mm
.
docShell
this
.
_fromIdx
)
;
this
.
_fromIdx
=
kNoIndex
;
return
history
;
}
)
;
}
handleEvent
(
event
)
{
this
.
collect
(
)
;
}
OnHistoryNewEntry
(
newURI
oldIndex
)
{
this
.
collectFrom
(
oldIndex
)
;
}
OnHistoryGotoIndex
(
)
{
this
.
collectFrom
(
kLastIndex
)
;
}
OnHistoryPurge
(
)
{
this
.
collect
(
)
;
}
OnHistoryReload
(
)
{
this
.
collect
(
)
;
return
true
;
}
OnHistoryReplaceEntry
(
)
{
this
.
collect
(
)
;
}
onStateChange
(
webProgress
request
stateFlags
status
)
{
if
(
!
webProgress
.
isTopLevel
|
|
webProgress
.
DOMWindow
!
=
this
.
mm
.
content
)
{
return
;
}
if
(
!
this
.
mm
.
docShell
.
hasLoadedNonBlankURI
)
{
return
;
}
if
(
stateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_START
)
{
this
.
collect
(
)
;
}
else
if
(
stateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_STOP
)
{
this
.
collect
(
)
;
}
}
}
SessionHistoryListener
.
prototype
.
QueryInterface
=
ChromeUtils
.
generateQI
(
[
Ci
.
nsIWebProgressListener
Ci
.
nsISHistoryListener
Ci
.
nsISupportsWeakReference
]
)
;
class
MessageQueue
extends
Handler
{
constructor
(
store
)
{
super
(
store
)
;
this
.
_data
=
new
Map
(
)
;
this
.
BATCH_DELAY_MS
=
1000
;
this
.
NEEDED_IDLE_PERIOD_MS
=
5
;
this
.
_timeoutWaitIdlePeriodMs
=
null
;
this
.
_timeout
=
null
;
this
.
_timeoutDisabled
=
false
;
this
.
_idleScheduled
=
false
;
this
.
timeoutDisabled
=
Services
.
prefs
.
getBoolPref
(
TIMEOUT_DISABLED_PREF
)
;
this
.
_timeoutWaitIdlePeriodMs
=
Services
.
prefs
.
getIntPref
(
PREF_INTERVAL
)
;
Services
.
prefs
.
addObserver
(
TIMEOUT_DISABLED_PREF
this
)
;
Services
.
prefs
.
addObserver
(
PREF_INTERVAL
this
)
;
}
get
timeoutDisabled
(
)
{
return
this
.
_timeoutDisabled
;
}
set
timeoutDisabled
(
val
)
{
this
.
_timeoutDisabled
=
val
;
if
(
val
&
&
this
.
_timeout
)
{
clearTimeout
(
this
.
_timeout
)
;
this
.
_timeout
=
null
;
}
return
val
;
}
uninit
(
)
{
Services
.
prefs
.
removeObserver
(
TIMEOUT_DISABLED_PREF
this
)
;
Services
.
prefs
.
removeObserver
(
PREF_INTERVAL
this
)
;
this
.
cleanupTimers
(
)
;
}
cleanupTimers
(
)
{
this
.
_idleScheduled
=
false
;
if
(
this
.
_timeout
)
{
clearTimeout
(
this
.
_timeout
)
;
this
.
_timeout
=
null
;
}
}
observe
(
subject
topic
data
)
{
if
(
topic
=
=
"
nsPref
:
changed
"
)
{
switch
(
data
)
{
case
TIMEOUT_DISABLED_PREF
:
this
.
timeoutDisabled
=
Services
.
prefs
.
getBoolPref
(
TIMEOUT_DISABLED_PREF
)
;
break
;
case
PREF_INTERVAL
:
this
.
_timeoutWaitIdlePeriodMs
=
Services
.
prefs
.
getIntPref
(
PREF_INTERVAL
)
;
break
;
default
:
debug
(
"
received
unknown
message
'
"
+
data
+
"
'
"
)
;
break
;
}
}
}
push
(
key
fn
)
{
this
.
_data
.
set
(
key
fn
)
;
if
(
!
this
.
_timeout
&
&
!
this
.
_timeoutDisabled
)
{
this
.
_timeout
=
setTimeoutWithTarget
(
(
)
=
>
this
.
sendWhenIdle
(
)
this
.
BATCH_DELAY_MS
this
.
mm
.
tabEventTarget
)
;
}
}
sendWhenIdle
(
deadline
)
{
if
(
!
this
.
mm
.
content
)
{
return
;
}
if
(
deadline
)
{
if
(
deadline
.
didTimeout
|
|
deadline
.
timeRemaining
(
)
>
this
.
NEEDED_IDLE_PERIOD_MS
)
{
this
.
send
(
)
;
return
;
}
}
else
if
(
this
.
_idleScheduled
)
{
return
;
}
ChromeUtils
.
idleDispatch
(
deadline_
=
>
this
.
sendWhenIdle
(
deadline_
)
{
timeout
:
this
.
_timeoutWaitIdlePeriodMs
}
)
;
this
.
_idleScheduled
=
true
;
}
send
(
options
=
{
}
)
{
if
(
!
this
.
mm
.
docShell
)
{
return
;
}
this
.
cleanupTimers
(
)
;
let
flushID
=
(
options
&
&
options
.
flushID
)
|
|
0
;
let
histID
=
"
FX_SESSION_RESTORE_CONTENT_COLLECT_DATA_MS
"
;
let
data
=
{
}
;
for
(
let
[
key
func
]
of
this
.
_data
)
{
if
(
key
!
=
"
isPrivate
"
)
{
TelemetryStopwatch
.
startKeyed
(
histID
key
)
;
}
let
value
=
func
(
)
;
if
(
key
!
=
"
isPrivate
"
)
{
TelemetryStopwatch
.
finishKeyed
(
histID
key
)
;
}
if
(
value
|
|
(
key
!
=
"
storagechange
"
&
&
key
!
=
"
historychange
"
)
)
{
data
[
key
]
=
value
;
}
}
this
.
_data
.
clear
(
)
;
try
{
this
.
mm
.
sendAsyncMessage
(
"
SessionStore
:
update
"
{
data
flushID
isFinal
:
options
.
isFinal
|
|
false
epoch
:
this
.
store
.
epoch
}
)
;
}
catch
(
ex
)
{
if
(
ex
&
&
ex
.
result
=
=
Cr
.
NS_ERROR_OUT_OF_MEMORY
)
{
Services
.
telemetry
.
getHistogramById
(
"
FX_SESSION_RESTORE_SEND_UPDATE_CAUSED_OOM
"
)
.
add
(
1
)
;
this
.
mm
.
sendAsyncMessage
(
"
SessionStore
:
error
"
)
;
}
}
}
}
const
MESSAGES
=
[
"
SessionStore
:
restoreHistory
"
"
SessionStore
:
finishRestoreHistory
"
"
SessionStore
:
OnHistoryReload
"
"
SessionStore
:
OnHistoryNewEntry
"
"
SessionStore
:
restoreTabContent
"
"
SessionStore
:
resetRestore
"
"
SessionStore
:
flush
"
"
SessionStore
:
becomeActiveProcess
"
"
SessionStore
:
prepareForProcessChange
"
]
;
class
ContentSessionStore
{
constructor
(
mm
)
{
this
.
mm
=
mm
;
this
.
messageQueue
=
new
MessageQueue
(
this
)
;
this
.
epoch
=
0
;
this
.
contentRestoreInitialized
=
false
;
this
.
waitRestoreSHistoryInParent
=
false
;
this
.
restoreTabContentData
=
null
;
XPCOMUtils
.
defineLazyGetter
(
this
"
contentRestore
"
(
)
=
>
{
this
.
contentRestoreInitialized
=
true
;
return
new
ContentRestore
(
mm
)
;
}
)
;
this
.
handlers
=
[
new
EventListener
(
this
)
this
.
messageQueue
]
;
this
.
_shistoryInParent
=
Services
.
prefs
.
getBoolPref
(
"
fission
.
sessionHistoryInParent
"
false
)
;
if
(
this
.
_shistoryInParent
)
{
this
.
mm
.
sendAsyncMessage
(
"
SessionStore
:
addSHistoryListener
"
)
;
}
else
{
this
.
handlers
.
push
(
new
SessionHistoryListener
(
this
)
)
;
}
MESSAGES
.
forEach
(
m
=
>
mm
.
addMessageListener
(
m
this
)
)
;
mm
.
addEventListener
(
"
pagehide
"
this
)
;
mm
.
addEventListener
(
"
unload
"
this
)
;
}
receiveMessage
(
{
name
data
}
)
{
if
(
!
this
.
mm
.
docShell
)
{
return
;
}
if
(
data
&
&
data
.
epoch
&
&
data
.
epoch
!
=
this
.
epoch
)
{
this
.
epoch
=
data
.
epoch
;
}
switch
(
name
)
{
case
"
SessionStore
:
restoreHistory
"
:
this
.
restoreHistory
(
data
)
;
break
;
case
"
SessionStore
:
finishRestoreHistory
"
:
this
.
finishRestoreHistory
(
)
;
break
;
case
"
SessionStore
:
OnHistoryNewEntry
"
:
this
.
contentRestore
.
restoreOnNewEntry
(
data
.
uri
)
;
break
;
case
"
SessionStore
:
OnHistoryReload
"
:
this
.
contentRestore
.
restoreTabContent
(
null
false
(
)
=
>
{
this
.
mm
.
sendAsyncMessage
(
"
SessionStore
:
restoreTabContentComplete
"
{
epoch
:
this
.
epoch
}
)
;
}
(
)
=
>
{
this
.
mm
.
sendAsyncMessage
(
"
SessionStore
:
removeRestoreListener
"
{
epoch
:
this
.
epoch
}
)
;
}
(
)
=
>
{
this
.
mm
.
sendAsyncMessage
(
"
SessionStore
:
reloadCurrentEntry
"
{
epoch
:
this
.
epoch
}
)
;
}
)
;
break
;
case
"
SessionStore
:
restoreTabContent
"
:
if
(
this
.
waitRestoreSHistoryInParent
)
{
this
.
restoreTabContentData
=
data
;
}
else
{
this
.
restoreTabContent
(
data
)
;
}
break
;
case
"
SessionStore
:
resetRestore
"
:
this
.
contentRestore
.
resetRestore
(
)
;
break
;
case
"
SessionStore
:
flush
"
:
this
.
flush
(
data
)
;
break
;
case
"
SessionStore
:
becomeActiveProcess
"
:
if
(
!
this
.
_shistoryInParent
)
{
SessionHistoryListener
.
collect
(
)
;
}
break
;
case
"
SessionStore
:
prepareForProcessChange
"
:
this
.
mm
.
docShell
.
persistLayoutHistoryState
(
)
;
break
;
default
:
debug
(
"
received
unknown
message
'
"
+
name
+
"
'
"
)
;
break
;
}
}
restoreHistory
(
{
epoch
tabData
loadArguments
isRemotenessUpdate
}
)
{
this
.
contentRestore
.
restoreHistory
(
tabData
loadArguments
{
onLoadStarted
:
(
)
=
>
{
this
.
mm
.
sendAsyncMessage
(
"
SessionStore
:
restoreTabContentStarted
"
{
epoch
}
)
;
}
onLoadFinished
:
(
)
=
>
{
this
.
mm
.
sendAsyncMessage
(
"
SessionStore
:
restoreTabContentComplete
"
{
epoch
}
)
;
}
removeRestoreListener
:
(
)
=
>
{
if
(
!
this
.
_shistoryInParent
)
{
return
;
}
this
.
mm
.
sendAsyncMessage
(
"
SessionStore
:
removeRestoreListener
"
{
epoch
}
)
;
}
requestRestoreSHistory
:
(
)
=
>
{
if
(
!
this
.
_shistoryInParent
)
{
return
;
}
this
.
waitRestoreSHistoryInParent
=
true
;
this
.
mm
.
sendAsyncMessage
(
"
SessionStore
:
restoreSHistoryInParent
"
{
epoch
}
)
;
}
}
this
.
_shistoryInParent
)
;
if
(
Services
.
appinfo
.
processType
=
=
Services
.
appinfo
.
PROCESS_TYPE_DEFAULT
)
{
this
.
mm
.
sendSyncMessage
(
"
SessionStore
:
restoreHistoryComplete
"
{
epoch
isRemotenessUpdate
}
)
;
}
else
if
(
!
this
.
_shistoryInParent
)
{
this
.
mm
.
sendAsyncMessage
(
"
SessionStore
:
restoreHistoryComplete
"
{
epoch
isRemotenessUpdate
}
)
;
}
}
finishRestoreHistory
(
)
{
this
.
contentRestore
.
finishRestoreHistory
(
{
onLoadStarted
:
(
)
=
>
{
this
.
mm
.
sendAsyncMessage
(
"
SessionStore
:
restoreTabContentStarted
"
{
epoch
:
this
.
epoch
}
)
;
}
onLoadFinished
:
(
)
=
>
{
this
.
mm
.
sendAsyncMessage
(
"
SessionStore
:
restoreTabContentComplete
"
{
epoch
:
this
.
epoch
}
)
;
}
removeRestoreListener
:
(
)
=
>
{
if
(
!
this
.
_shistoryInParent
)
{
return
;
}
this
.
mm
.
sendAsyncMessage
(
"
SessionStore
:
removeRestoreListener
"
{
epoch
:
this
.
epoch
}
)
;
}
}
)
;
this
.
mm
.
sendAsyncMessage
(
"
SessionStore
:
restoreHistoryComplete
"
{
epoch
:
this
.
epoch
}
)
;
if
(
this
.
restoreTabContentData
)
{
this
.
restoreTabContent
(
this
.
restoreTabContentData
)
;
this
.
restoreTabContentData
=
null
;
}
this
.
waitRestoreSHistoryInParent
=
false
;
}
restoreTabContent
(
{
loadArguments
isRemotenessUpdate
reason
}
)
{
let
epoch
=
this
.
epoch
;
let
didStartLoad
=
this
.
contentRestore
.
restoreTabContent
(
loadArguments
isRemotenessUpdate
(
)
=
>
{
this
.
mm
.
sendAsyncMessage
(
"
SessionStore
:
restoreTabContentComplete
"
{
epoch
isRemotenessUpdate
}
)
;
}
(
)
=
>
{
this
.
mm
.
sendAsyncMessage
(
"
SessionStore
:
removeRestoreListener
"
{
epoch
}
)
;
}
(
)
=
>
{
this
.
mm
.
sendAsyncMessage
(
"
SessionStore
:
reloadCurrentEntry
"
{
epoch
}
)
;
}
)
;
this
.
mm
.
sendAsyncMessage
(
"
SessionStore
:
restoreTabContentStarted
"
{
epoch
isRemotenessUpdate
reason
}
)
;
if
(
!
didStartLoad
)
{
this
.
mm
.
sendAsyncMessage
(
"
SessionStore
:
restoreTabContentComplete
"
{
epoch
isRemotenessUpdate
}
)
;
}
}
flush
(
{
id
}
)
{
this
.
messageQueue
.
send
(
{
flushID
:
id
}
)
;
}
handleEvent
(
event
)
{
if
(
event
.
type
=
=
"
pagehide
"
)
{
this
.
handleRevivedTab
(
)
;
}
else
if
(
event
.
type
=
=
"
unload
"
)
{
this
.
onUnload
(
)
;
}
}
onUnload
(
)
{
this
.
messageQueue
.
send
(
{
isFinal
:
true
}
)
;
this
.
handleRevivedTab
(
)
;
for
(
let
handler
of
this
.
handlers
)
{
if
(
handler
.
uninit
)
{
handler
.
uninit
(
)
;
}
}
if
(
this
.
contentRestoreInitialized
)
{
this
.
contentRestore
.
resetRestore
(
)
;
}
}
handleRevivedTab
(
)
{
let
{
content
}
=
this
.
mm
;
if
(
!
content
)
{
this
.
mm
.
removeEventListener
(
"
pagehide
"
this
)
;
return
;
}
if
(
content
.
document
.
documentURI
.
startsWith
(
"
about
:
tabcrashed
"
)
)
{
if
(
Services
.
appinfo
.
processType
!
=
Services
.
appinfo
.
PROCESS_TYPE_DEFAULT
)
{
throw
new
Error
(
"
We
seem
to
be
navigating
away
from
about
:
tabcrashed
in
"
+
"
a
non
-
remote
browser
.
This
should
really
never
happen
.
"
)
;
}
this
.
mm
.
removeEventListener
(
"
pagehide
"
this
)
;
this
.
mm
.
sendAsyncMessage
(
"
SessionStore
:
crashedTabRevived
"
)
;
}
}
}
