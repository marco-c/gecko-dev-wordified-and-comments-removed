"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
ContentSessionStore
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
clearTimeout
setTimeoutWithTarget
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
function
debug
(
msg
)
{
Services
.
console
.
logStringMessage
(
"
SessionStoreContent
:
"
+
msg
)
;
}
const
lazy
=
{
}
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
ContentRestore
"
"
resource
:
/
/
/
modules
/
sessionstore
/
ContentRestore
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
SessionHistory
"
"
resource
:
/
/
gre
/
modules
/
sessionstore
/
SessionHistory
.
jsm
"
)
;
const
TIMEOUT_DISABLED_PREF
=
"
browser
.
sessionstore
.
debug
.
no_auto_updates
"
;
const
PREF_INTERVAL
=
"
browser
.
sessionstore
.
interval
"
;
const
kNoIndex
=
Number
.
MAX_SAFE_INTEGER
;
const
kLastIndex
=
Number
.
MAX_SAFE_INTEGER
-
1
;
class
Handler
{
constructor
(
store
)
{
this
.
store
=
store
;
}
get
contentRestore
(
)
{
return
this
.
store
.
contentRestore
;
}
get
contentRestoreInitialized
(
)
{
return
this
.
store
.
contentRestoreInitialized
;
}
get
mm
(
)
{
return
this
.
store
.
mm
;
}
get
messageQueue
(
)
{
return
this
.
store
.
messageQueue
;
}
}
class
EventListener
extends
Handler
{
constructor
(
store
)
{
super
(
store
)
;
SessionStoreUtils
.
addDynamicFrameFilteredListener
(
this
.
mm
"
load
"
this
true
)
;
}
handleEvent
(
event
)
{
let
{
content
}
=
this
.
mm
;
if
(
event
.
target
!
=
content
.
document
)
{
return
;
}
if
(
content
.
document
.
documentURI
.
startsWith
(
"
about
:
reader
"
)
)
{
if
(
event
.
type
=
=
"
load
"
&
&
!
content
.
document
.
body
.
classList
.
contains
(
"
loaded
"
)
)
{
content
.
addEventListener
(
"
AboutReaderContentReady
"
this
)
;
return
;
}
content
.
removeEventListener
(
"
AboutReaderContentReady
"
this
)
;
}
if
(
this
.
contentRestoreInitialized
)
{
this
.
contentRestore
.
restoreDocument
(
)
;
}
}
}
class
SessionHistoryListener
extends
Handler
{
constructor
(
store
)
{
super
(
store
)
;
this
.
_fromIdx
=
kNoIndex
;
this
.
mm
.
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
.
sessionHistory
.
legacySHistory
.
addSHistoryListener
(
this
)
;
let
webProgress
=
this
.
mm
.
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebProgress
)
;
webProgress
.
addProgressListener
(
this
Ci
.
nsIWebProgress
.
NOTIFY_STATE_DOCUMENT
)
;
if
(
!
lazy
.
SessionHistory
.
isEmpty
(
this
.
mm
.
docShell
)
)
{
this
.
collect
(
)
;
this
.
store
.
messageQueue
.
send
(
)
;
}
this
.
mm
.
addEventListener
(
"
DOMTitleChanged
"
this
)
;
}
get
mm
(
)
{
return
this
.
store
.
mm
;
}
uninit
(
)
{
let
sessionHistory
=
this
.
mm
.
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
.
sessionHistory
;
if
(
sessionHistory
)
{
sessionHistory
.
legacySHistory
.
removeSHistoryListener
(
this
)
;
}
}
collect
(
)
{
if
(
this
.
mm
.
docShell
)
{
this
.
collectFrom
(
-
1
)
;
}
}
collectFrom
(
idx
)
{
if
(
this
.
_fromIdx
<
=
idx
)
{
return
;
}
this
.
_fromIdx
=
idx
;
this
.
store
.
messageQueue
.
push
(
"
historychange
"
(
)
=
>
{
if
(
this
.
_fromIdx
=
=
=
kNoIndex
)
{
return
null
;
}
let
history
=
lazy
.
SessionHistory
.
collect
(
this
.
mm
.
docShell
this
.
_fromIdx
)
;
this
.
_fromIdx
=
kNoIndex
;
return
history
;
}
)
;
}
handleEvent
(
event
)
{
this
.
collect
(
)
;
}
OnHistoryNewEntry
(
newURI
oldIndex
)
{
this
.
collectFrom
(
oldIndex
=
=
-
1
?
oldIndex
:
oldIndex
-
1
)
;
}
OnHistoryGotoIndex
(
)
{
this
.
collectFrom
(
kLastIndex
)
;
}
OnHistoryPurge
(
)
{
this
.
collect
(
)
;
}
OnHistoryReload
(
)
{
this
.
collect
(
)
;
return
true
;
}
OnHistoryReplaceEntry
(
)
{
this
.
collect
(
)
;
}
onStateChange
(
webProgress
request
stateFlags
status
)
{
if
(
!
webProgress
.
isTopLevel
|
|
webProgress
.
DOMWindow
!
=
this
.
mm
.
content
)
{
return
;
}
if
(
!
this
.
mm
.
docShell
.
hasLoadedNonBlankURI
)
{
return
;
}
if
(
stateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_START
)
{
this
.
collect
(
)
;
}
else
if
(
stateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_STOP
)
{
this
.
collect
(
)
;
}
}
}
SessionHistoryListener
.
prototype
.
QueryInterface
=
ChromeUtils
.
generateQI
(
[
"
nsIWebProgressListener
"
"
nsISHistoryListener
"
"
nsISupportsWeakReference
"
]
)
;
class
MessageQueue
extends
Handler
{
constructor
(
store
)
{
super
(
store
)
;
this
.
_data
=
new
Map
(
)
;
this
.
BATCH_DELAY_MS
=
1000
;
this
.
NEEDED_IDLE_PERIOD_MS
=
5
;
this
.
_timeoutWaitIdlePeriodMs
=
null
;
this
.
_timeout
=
null
;
this
.
_timeoutDisabled
=
false
;
this
.
_idleScheduled
=
false
;
this
.
timeoutDisabled
=
Services
.
prefs
.
getBoolPref
(
TIMEOUT_DISABLED_PREF
)
;
this
.
_timeoutWaitIdlePeriodMs
=
Services
.
prefs
.
getIntPref
(
PREF_INTERVAL
)
;
Services
.
prefs
.
addObserver
(
TIMEOUT_DISABLED_PREF
this
)
;
Services
.
prefs
.
addObserver
(
PREF_INTERVAL
this
)
;
}
get
timeoutDisabled
(
)
{
return
this
.
_timeoutDisabled
;
}
set
timeoutDisabled
(
val
)
{
this
.
_timeoutDisabled
=
val
;
if
(
val
&
&
this
.
_timeout
)
{
clearTimeout
(
this
.
_timeout
)
;
this
.
_timeout
=
null
;
}
}
uninit
(
)
{
Services
.
prefs
.
removeObserver
(
TIMEOUT_DISABLED_PREF
this
)
;
Services
.
prefs
.
removeObserver
(
PREF_INTERVAL
this
)
;
this
.
cleanupTimers
(
)
;
}
cleanupTimers
(
)
{
this
.
_idleScheduled
=
false
;
if
(
this
.
_timeout
)
{
clearTimeout
(
this
.
_timeout
)
;
this
.
_timeout
=
null
;
}
}
observe
(
subject
topic
data
)
{
if
(
topic
=
=
"
nsPref
:
changed
"
)
{
switch
(
data
)
{
case
TIMEOUT_DISABLED_PREF
:
this
.
timeoutDisabled
=
Services
.
prefs
.
getBoolPref
(
TIMEOUT_DISABLED_PREF
)
;
break
;
case
PREF_INTERVAL
:
this
.
_timeoutWaitIdlePeriodMs
=
Services
.
prefs
.
getIntPref
(
PREF_INTERVAL
)
;
break
;
default
:
debug
(
"
received
unknown
message
'
"
+
data
+
"
'
"
)
;
break
;
}
}
}
push
(
key
fn
)
{
this
.
_data
.
set
(
key
fn
)
;
if
(
!
this
.
_timeout
&
&
!
this
.
_timeoutDisabled
)
{
this
.
_timeout
=
setTimeoutWithTarget
(
(
)
=
>
this
.
sendWhenIdle
(
)
this
.
BATCH_DELAY_MS
this
.
mm
.
tabEventTarget
)
;
}
}
sendWhenIdle
(
deadline
)
{
if
(
!
this
.
mm
.
content
)
{
return
;
}
if
(
deadline
)
{
if
(
deadline
.
didTimeout
|
|
deadline
.
timeRemaining
(
)
>
this
.
NEEDED_IDLE_PERIOD_MS
)
{
this
.
send
(
)
;
return
;
}
}
else
if
(
this
.
_idleScheduled
)
{
return
;
}
ChromeUtils
.
idleDispatch
(
deadline_
=
>
this
.
sendWhenIdle
(
deadline_
)
{
timeout
:
this
.
_timeoutWaitIdlePeriodMs
}
)
;
this
.
_idleScheduled
=
true
;
}
send
(
options
=
{
}
)
{
if
(
!
this
.
mm
.
docShell
)
{
return
;
}
this
.
cleanupTimers
(
)
;
let
flushID
=
(
options
&
&
options
.
flushID
)
|
|
0
;
let
histID
=
"
FX_SESSION_RESTORE_CONTENT_COLLECT_DATA_MS
"
;
let
data
=
{
}
;
for
(
let
[
key
func
]
of
this
.
_data
)
{
if
(
key
!
=
"
isPrivate
"
)
{
TelemetryStopwatch
.
startKeyed
(
histID
key
)
;
}
let
value
=
func
(
)
;
if
(
key
!
=
"
isPrivate
"
)
{
TelemetryStopwatch
.
finishKeyed
(
histID
key
)
;
}
if
(
value
|
|
(
key
!
=
"
storagechange
"
&
&
key
!
=
"
historychange
"
)
)
{
data
[
key
]
=
value
;
}
}
this
.
_data
.
clear
(
)
;
try
{
this
.
mm
.
sendAsyncMessage
(
"
SessionStore
:
update
"
{
data
flushID
isFinal
:
options
.
isFinal
|
|
false
epoch
:
this
.
store
.
epoch
}
)
;
}
catch
(
ex
)
{
if
(
ex
&
&
ex
.
result
=
=
Cr
.
NS_ERROR_OUT_OF_MEMORY
)
{
Services
.
telemetry
.
getHistogramById
(
"
FX_SESSION_RESTORE_SEND_UPDATE_CAUSED_OOM
"
)
.
add
(
1
)
;
this
.
mm
.
sendAsyncMessage
(
"
SessionStore
:
error
"
)
;
}
}
}
}
const
MESSAGES
=
[
"
SessionStore
:
restoreHistory
"
"
SessionStore
:
restoreTabContent
"
"
SessionStore
:
resetRestore
"
"
SessionStore
:
flush
"
"
SessionStore
:
prepareForProcessChange
"
]
;
class
ContentSessionStore
{
constructor
(
mm
)
{
if
(
Services
.
appinfo
.
sessionHistoryInParent
)
{
throw
new
Error
(
"
This
frame
script
should
not
be
loaded
for
SHIP
"
)
;
}
this
.
mm
=
mm
;
this
.
messageQueue
=
new
MessageQueue
(
this
)
;
this
.
epoch
=
0
;
this
.
contentRestoreInitialized
=
false
;
this
.
handlers
=
[
this
.
messageQueue
new
EventListener
(
this
)
new
SessionHistoryListener
(
this
)
]
;
XPCOMUtils
.
defineLazyGetter
(
this
"
contentRestore
"
(
)
=
>
{
this
.
contentRestoreInitialized
=
true
;
return
new
lazy
.
ContentRestore
(
mm
)
;
}
)
;
MESSAGES
.
forEach
(
m
=
>
mm
.
addMessageListener
(
m
this
)
)
;
mm
.
addEventListener
(
"
unload
"
this
)
;
}
receiveMessage
(
{
name
data
}
)
{
if
(
!
this
.
mm
.
docShell
)
{
return
;
}
if
(
data
&
&
data
.
epoch
&
&
data
.
epoch
!
=
this
.
epoch
)
{
this
.
epoch
=
data
.
epoch
;
}
switch
(
name
)
{
case
"
SessionStore
:
restoreHistory
"
:
this
.
restoreHistory
(
data
)
;
break
;
case
"
SessionStore
:
restoreTabContent
"
:
this
.
restoreTabContent
(
data
)
;
break
;
case
"
SessionStore
:
resetRestore
"
:
this
.
contentRestore
.
resetRestore
(
)
;
break
;
case
"
SessionStore
:
flush
"
:
this
.
flush
(
data
)
;
break
;
case
"
SessionStore
:
prepareForProcessChange
"
:
this
.
mm
.
docShell
.
persistLayoutHistoryState
(
)
;
break
;
default
:
debug
(
"
received
unknown
message
'
"
+
name
+
"
'
"
)
;
break
;
}
}
restoreHistory
(
data
)
{
let
{
epoch
tabData
loadArguments
isRemotenessUpdate
}
=
data
;
this
.
contentRestore
.
restoreHistory
(
tabData
loadArguments
{
onLoadStarted
:
(
)
=
>
{
this
.
mm
.
sendAsyncMessage
(
"
SessionStore
:
restoreTabContentStarted
"
{
epoch
}
)
;
}
onLoadFinished
:
(
)
=
>
{
this
.
mm
.
sendAsyncMessage
(
"
SessionStore
:
restoreTabContentComplete
"
{
epoch
}
)
;
}
}
)
;
if
(
Services
.
appinfo
.
processType
=
=
Services
.
appinfo
.
PROCESS_TYPE_DEFAULT
)
{
this
.
mm
.
sendSyncMessage
(
"
SessionStore
:
restoreHistoryComplete
"
{
epoch
isRemotenessUpdate
}
)
;
}
else
{
this
.
mm
.
sendAsyncMessage
(
"
SessionStore
:
restoreHistoryComplete
"
{
epoch
isRemotenessUpdate
}
)
;
}
}
restoreTabContent
(
{
loadArguments
isRemotenessUpdate
reason
}
)
{
let
epoch
=
this
.
epoch
;
let
didStartLoad
=
this
.
contentRestore
.
restoreTabContent
(
loadArguments
isRemotenessUpdate
(
)
=
>
{
this
.
mm
.
sendAsyncMessage
(
"
SessionStore
:
restoreTabContentComplete
"
{
epoch
isRemotenessUpdate
}
)
;
}
)
;
this
.
mm
.
sendAsyncMessage
(
"
SessionStore
:
restoreTabContentStarted
"
{
epoch
isRemotenessUpdate
reason
}
)
;
if
(
!
didStartLoad
)
{
this
.
mm
.
sendAsyncMessage
(
"
SessionStore
:
restoreTabContentComplete
"
{
epoch
isRemotenessUpdate
}
)
;
}
}
flush
(
{
id
}
)
{
this
.
messageQueue
.
send
(
{
flushID
:
id
}
)
;
}
handleEvent
(
event
)
{
if
(
event
.
type
=
=
"
unload
"
)
{
this
.
onUnload
(
)
;
}
}
onUnload
(
)
{
this
.
messageQueue
.
send
(
{
isFinal
:
true
}
)
;
for
(
let
handler
of
this
.
handlers
)
{
if
(
handler
.
uninit
)
{
handler
.
uninit
(
)
;
}
}
if
(
this
.
contentRestoreInitialized
)
{
this
.
contentRestore
.
resetRestore
(
)
;
}
}
}
