"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
ContentSessionStore
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
this
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
TelemetryStopwatch
"
"
resource
:
/
/
gre
/
modules
/
TelemetryStopwatch
.
jsm
"
)
;
function
debug
(
msg
)
{
Services
.
console
.
logStringMessage
(
"
SessionStoreContent
:
"
+
msg
)
;
}
ChromeUtils
.
defineModuleGetter
(
this
"
FormData
"
"
resource
:
/
/
gre
/
modules
/
FormData
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ContentRestore
"
"
resource
:
/
/
/
modules
/
sessionstore
/
ContentRestore
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
SessionHistory
"
"
resource
:
/
/
gre
/
modules
/
sessionstore
/
SessionHistory
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
SessionStorage
"
"
resource
:
/
/
/
modules
/
sessionstore
/
SessionStorage
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Utils
"
"
resource
:
/
/
gre
/
modules
/
sessionstore
/
Utils
.
jsm
"
)
;
const
ssu
=
Cc
[
"
mozilla
.
org
/
browser
/
sessionstore
/
utils
;
1
"
]
.
getService
(
Ci
.
nsISessionStoreUtils
)
;
const
DOM_STORAGE_LIMIT_PREF
=
"
browser
.
sessionstore
.
dom_storage_limit
"
;
const
TIMEOUT_DISABLED_PREF
=
"
browser
.
sessionstore
.
debug
.
no_auto_updates
"
;
const
PREF_INTERVAL
=
"
browser
.
sessionstore
.
interval
"
;
const
kNoIndex
=
Number
.
MAX_SAFE_INTEGER
;
const
kLastIndex
=
Number
.
MAX_SAFE_INTEGER
-
1
;
function
mapFrameTree
(
mm
callback
)
{
let
[
data
]
=
Utils
.
mapFrameTree
(
mm
.
content
callback
)
;
return
data
;
}
class
Handler
{
constructor
(
store
)
{
this
.
store
=
store
;
}
get
contentRestore
(
)
{
return
this
.
store
.
contentRestore
;
}
get
contentRestoreInitialized
(
)
{
return
this
.
store
.
contentRestoreInitialized
;
}
get
mm
(
)
{
return
this
.
store
.
mm
;
}
get
messageQueue
(
)
{
return
this
.
store
.
messageQueue
;
}
get
stateChangeNotifier
(
)
{
return
this
.
store
.
stateChangeNotifier
;
}
}
class
StateChangeNotifier
extends
Handler
{
constructor
(
store
)
{
super
(
store
)
;
this
.
_observers
=
new
Set
(
)
;
let
ifreq
=
this
.
mm
.
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
;
let
webProgress
=
ifreq
.
getInterface
(
Ci
.
nsIWebProgress
)
;
webProgress
.
addProgressListener
(
this
Ci
.
nsIWebProgress
.
NOTIFY_STATE_DOCUMENT
)
;
}
addObserver
(
obs
)
{
this
.
_observers
.
add
(
obs
)
;
}
notifyObservers
(
method
)
{
for
(
let
obs
of
this
.
_observers
)
{
if
(
typeof
obs
[
method
]
=
=
"
function
"
)
{
obs
[
method
]
(
)
;
}
}
}
onStateChange
(
webProgress
request
stateFlags
status
)
{
if
(
!
webProgress
.
isTopLevel
|
|
webProgress
.
DOMWindow
!
=
this
.
mm
.
content
)
{
return
;
}
if
(
!
this
.
mm
.
docShell
.
hasLoadedNonBlankURI
)
{
return
;
}
if
(
stateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_START
)
{
this
.
notifyObservers
(
"
onPageLoadStarted
"
)
;
}
else
if
(
stateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_STOP
)
{
this
.
notifyObservers
(
"
onPageLoadCompleted
"
)
;
}
}
}
StateChangeNotifier
.
prototype
.
QueryInterface
=
ChromeUtils
.
generateQI
(
[
Ci
.
nsIWebProgressListener
Ci
.
nsISupportsWeakReference
]
)
;
class
EventListener
extends
Handler
{
constructor
(
store
)
{
super
(
store
)
;
ssu
.
addDynamicFrameFilteredListener
(
this
.
mm
"
load
"
this
true
)
;
}
handleEvent
(
event
)
{
let
{
content
}
=
this
.
mm
;
if
(
event
.
target
!
=
content
.
document
)
{
return
;
}
if
(
content
.
document
.
documentURI
.
startsWith
(
"
about
:
reader
"
)
)
{
if
(
event
.
type
=
=
"
load
"
&
&
!
content
.
document
.
body
.
classList
.
contains
(
"
loaded
"
)
)
{
content
.
addEventListener
(
"
AboutReaderContentReady
"
this
)
;
return
;
}
content
.
removeEventListener
(
"
AboutReaderContentReady
"
this
)
;
}
if
(
this
.
contentRestoreInitialized
)
{
this
.
contentRestore
.
restoreDocument
(
)
;
}
}
}
class
SessionHistoryListener
extends
Handler
{
constructor
(
store
)
{
super
(
store
)
;
this
.
_fromIdx
=
kNoIndex
;
this
.
stateChangeNotifier
.
addObserver
(
this
)
;
this
.
mm
.
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
.
sessionHistory
.
legacySHistory
.
addSHistoryListener
(
this
)
;
if
(
!
SessionHistory
.
isEmpty
(
this
.
mm
.
docShell
)
)
{
this
.
collect
(
)
;
this
.
messageQueue
.
send
(
)
;
}
this
.
mm
.
addEventListener
(
"
DOMTitleChanged
"
this
)
;
}
uninit
(
)
{
let
sessionHistory
=
this
.
mm
.
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
.
sessionHistory
;
if
(
sessionHistory
)
{
sessionHistory
.
legacySHistory
.
removeSHistoryListener
(
this
)
;
}
}
collect
(
)
{
if
(
this
.
mm
.
docShell
)
{
this
.
collectFrom
(
-
1
)
;
}
}
collectFrom
(
idx
)
{
if
(
this
.
_fromIdx
<
=
idx
)
{
return
;
}
this
.
_fromIdx
=
idx
;
this
.
messageQueue
.
push
(
"
historychange
"
(
)
=
>
{
if
(
this
.
_fromIdx
=
=
=
kNoIndex
)
{
return
null
;
}
let
history
=
SessionHistory
.
collect
(
this
.
mm
.
docShell
this
.
_fromIdx
)
;
this
.
_fromIdx
=
kNoIndex
;
return
history
;
}
)
;
}
handleEvent
(
event
)
{
this
.
collect
(
)
;
}
onPageLoadCompleted
(
)
{
this
.
collect
(
)
;
}
onPageLoadStarted
(
)
{
this
.
collect
(
)
;
}
OnHistoryNewEntry
(
newURI
oldIndex
)
{
this
.
collectFrom
(
oldIndex
)
;
}
OnHistoryGotoIndex
(
index
gotoURI
)
{
this
.
collectFrom
(
kLastIndex
)
;
}
OnHistoryPurge
(
numEntries
)
{
this
.
collect
(
)
;
}
OnHistoryReload
(
reloadURI
reloadFlags
)
{
this
.
collect
(
)
;
return
true
;
}
OnHistoryReplaceEntry
(
index
)
{
this
.
collect
(
)
;
}
}
SessionHistoryListener
.
prototype
.
QueryInterface
=
ChromeUtils
.
generateQI
(
[
Ci
.
nsISHistoryListener
Ci
.
nsISupportsWeakReference
]
)
;
class
ScrollPositionListener
extends
Handler
{
constructor
(
store
)
{
super
(
store
)
;
ssu
.
addDynamicFrameFilteredListener
(
this
.
mm
"
scroll
"
this
false
)
;
this
.
stateChangeNotifier
.
addObserver
(
this
)
;
}
handleEvent
(
)
{
this
.
messageQueue
.
push
(
"
scroll
"
(
)
=
>
this
.
collect
(
)
)
;
}
onPageLoadCompleted
(
)
{
this
.
messageQueue
.
push
(
"
scroll
"
(
)
=
>
this
.
collect
(
)
)
;
}
onPageLoadStarted
(
)
{
this
.
messageQueue
.
push
(
"
scroll
"
(
)
=
>
null
)
;
}
collect
(
)
{
return
mapFrameTree
(
this
.
mm
ssu
.
collectScrollPosition
.
bind
(
ssu
)
)
;
}
}
class
FormDataListener
extends
Handler
{
constructor
(
store
)
{
super
(
store
)
;
ssu
.
addDynamicFrameFilteredListener
(
this
.
mm
"
input
"
this
true
)
;
this
.
stateChangeNotifier
.
addObserver
(
this
)
;
}
handleEvent
(
)
{
this
.
messageQueue
.
push
(
"
formdata
"
(
)
=
>
this
.
collect
(
)
)
;
}
onPageLoadStarted
(
)
{
this
.
messageQueue
.
push
(
"
formdata
"
(
)
=
>
null
)
;
}
collect
(
)
{
return
mapFrameTree
(
this
.
mm
FormData
.
collect
)
;
}
}
class
DocShellCapabilitiesListener
extends
Handler
{
constructor
(
store
)
{
super
(
store
)
;
this
.
_latestCapabilities
=
"
"
;
this
.
stateChangeNotifier
.
addObserver
(
this
)
;
}
onPageLoadStarted
(
)
{
let
caps
=
ssu
.
collectDocShellCapabilities
(
this
.
mm
.
docShell
)
;
if
(
caps
!
=
this
.
_latestCapabilities
)
{
this
.
_latestCapabilities
=
caps
;
this
.
messageQueue
.
push
(
"
disallow
"
(
)
=
>
caps
|
|
null
)
;
}
}
}
class
SessionStorageListener
extends
Handler
{
constructor
(
store
)
{
super
(
store
)
;
this
.
_changes
=
undefined
;
this
.
_listener
=
null
;
Services
.
obs
.
addObserver
(
this
"
browser
:
purge
-
domain
-
data
"
)
;
this
.
stateChangeNotifier
.
addObserver
(
this
)
;
this
.
resetEventListener
(
)
;
}
uninit
(
)
{
Services
.
obs
.
removeObserver
(
this
"
browser
:
purge
-
domain
-
data
"
)
;
}
observe
(
)
{
setTimeoutWithTarget
(
(
)
=
>
this
.
collect
(
)
0
this
.
mm
.
tabEventTarget
)
;
}
resetChanges
(
)
{
this
.
_changes
=
undefined
;
}
resetEventListener
(
)
{
if
(
!
this
.
_listener
)
{
this
.
_listener
=
ssu
.
addDynamicFrameFilteredListener
(
this
.
mm
"
MozSessionStorageChanged
"
this
true
)
;
}
}
removeEventListener
(
)
{
ssu
.
removeDynamicFrameFilteredListener
(
this
.
mm
"
MozSessionStorageChanged
"
this
.
_listener
true
)
;
this
.
_listener
=
null
;
}
handleEvent
(
event
)
{
if
(
!
this
.
mm
.
docShell
)
{
return
;
}
let
{
content
}
=
this
.
mm
;
let
usage
=
content
.
windowUtils
.
getStorageUsage
(
event
.
storageArea
)
;
if
(
usage
>
Services
.
prefs
.
getIntPref
(
DOM_STORAGE_LIMIT_PREF
)
)
{
this
.
messageQueue
.
push
(
"
storage
"
(
)
=
>
null
)
;
this
.
removeEventListener
(
)
;
this
.
resetChanges
(
)
;
return
;
}
let
{
url
key
newValue
}
=
event
;
let
uri
=
Services
.
io
.
newURI
(
url
)
;
let
domain
=
uri
.
prePath
;
if
(
!
this
.
_changes
)
{
this
.
_changes
=
{
}
;
}
if
(
!
this
.
_changes
[
domain
]
)
{
this
.
_changes
[
domain
]
=
{
}
;
}
if
(
!
key
)
{
this
.
_changes
[
domain
]
=
null
;
}
else
{
this
.
_changes
[
domain
]
[
key
]
=
newValue
;
}
this
.
messageQueue
.
push
(
"
storagechange
"
(
)
=
>
{
let
tmp
=
this
.
_changes
;
this
.
resetChanges
(
)
;
return
tmp
;
}
)
;
}
collect
(
)
{
if
(
!
this
.
mm
.
docShell
)
{
return
;
}
let
{
content
}
=
this
.
mm
;
this
.
resetChanges
(
)
;
this
.
messageQueue
.
push
(
"
storage
"
(
)
=
>
SessionStorage
.
collect
(
content
)
)
;
}
onPageLoadCompleted
(
)
{
this
.
collect
(
)
;
}
onPageLoadStarted
(
)
{
this
.
resetEventListener
(
)
;
this
.
collect
(
)
;
}
}
class
PrivacyListener
extends
Handler
{
constructor
(
store
)
{
super
(
store
)
;
this
.
mm
.
docShell
.
addWeakPrivacyTransitionObserver
(
this
)
;
if
(
this
.
mm
.
docShell
.
QueryInterface
(
Ci
.
nsILoadContext
)
.
usePrivateBrowsing
)
{
this
.
messageQueue
.
push
(
"
isPrivate
"
(
)
=
>
true
)
;
}
}
privateModeChanged
(
enabled
)
{
this
.
messageQueue
.
push
(
"
isPrivate
"
(
)
=
>
enabled
|
|
null
)
;
}
}
PrivacyListener
.
prototype
.
QueryInterface
=
ChromeUtils
.
generateQI
(
[
Ci
.
nsIPrivacyTransitionObserver
Ci
.
nsISupportsWeakReference
]
)
;
class
MessageQueue
extends
Handler
{
constructor
(
store
)
{
super
(
store
)
;
this
.
_data
=
new
Map
(
)
;
this
.
BATCH_DELAY_MS
=
1000
;
this
.
NEEDED_IDLE_PERIOD_MS
=
5
;
this
.
_timeoutWaitIdlePeriodMs
=
null
;
this
.
_timeout
=
null
;
this
.
_timeoutDisabled
=
false
;
this
.
_idleScheduled
=
false
;
this
.
timeoutDisabled
=
Services
.
prefs
.
getBoolPref
(
TIMEOUT_DISABLED_PREF
)
;
this
.
_timeoutWaitIdlePeriodMs
=
Services
.
prefs
.
getIntPref
(
PREF_INTERVAL
)
;
Services
.
prefs
.
addObserver
(
TIMEOUT_DISABLED_PREF
this
)
;
Services
.
prefs
.
addObserver
(
PREF_INTERVAL
this
)
;
}
get
timeoutDisabled
(
)
{
return
this
.
_timeoutDisabled
;
}
set
timeoutDisabled
(
val
)
{
this
.
_timeoutDisabled
=
val
;
if
(
val
&
&
this
.
_timeout
)
{
clearTimeout
(
this
.
_timeout
)
;
this
.
_timeout
=
null
;
}
return
val
;
}
uninit
(
)
{
Services
.
prefs
.
removeObserver
(
TIMEOUT_DISABLED_PREF
this
)
;
Services
.
prefs
.
removeObserver
(
PREF_INTERVAL
this
)
;
this
.
cleanupTimers
(
)
;
}
cleanupTimers
(
)
{
this
.
_idleScheduled
=
false
;
if
(
this
.
_timeout
)
{
clearTimeout
(
this
.
_timeout
)
;
this
.
_timeout
=
null
;
}
}
observe
(
subject
topic
data
)
{
if
(
topic
=
=
"
nsPref
:
changed
"
)
{
switch
(
data
)
{
case
TIMEOUT_DISABLED_PREF
:
this
.
timeoutDisabled
=
Services
.
prefs
.
getBoolPref
(
TIMEOUT_DISABLED_PREF
)
;
break
;
case
PREF_INTERVAL
:
this
.
_timeoutWaitIdlePeriodMs
=
Services
.
prefs
.
getIntPref
(
PREF_INTERVAL
)
;
break
;
default
:
debug
(
"
received
unknown
message
'
"
+
data
+
"
'
"
)
;
break
;
}
}
}
push
(
key
fn
)
{
this
.
_data
.
set
(
key
fn
)
;
if
(
!
this
.
_timeout
&
&
!
this
.
_timeoutDisabled
)
{
this
.
_timeout
=
setTimeoutWithTarget
(
(
)
=
>
this
.
sendWhenIdle
(
)
this
.
BATCH_DELAY_MS
this
.
mm
.
tabEventTarget
)
;
}
}
sendWhenIdle
(
deadline
)
{
if
(
!
this
.
mm
.
content
)
{
return
;
}
if
(
deadline
)
{
if
(
deadline
.
didTimeout
|
|
deadline
.
timeRemaining
(
)
>
this
.
NEEDED_IDLE_PERIOD_MS
)
{
this
.
send
(
)
;
return
;
}
}
else
if
(
this
.
_idleScheduled
)
{
return
;
}
ChromeUtils
.
idleDispatch
(
(
deadline_
)
=
>
this
.
sendWhenIdle
(
deadline_
)
{
timeout
:
this
.
_timeoutWaitIdlePeriodMs
}
)
;
this
.
_idleScheduled
=
true
;
}
send
(
options
=
{
}
)
{
if
(
!
this
.
mm
.
docShell
)
{
return
;
}
this
.
cleanupTimers
(
)
;
let
flushID
=
(
options
&
&
options
.
flushID
)
|
|
0
;
let
histID
=
"
FX_SESSION_RESTORE_CONTENT_COLLECT_DATA_MS
"
;
let
data
=
{
}
;
for
(
let
[
key
func
]
of
this
.
_data
)
{
if
(
key
!
=
"
isPrivate
"
)
{
TelemetryStopwatch
.
startKeyed
(
histID
key
)
;
}
let
value
=
func
(
)
;
if
(
key
!
=
"
isPrivate
"
)
{
TelemetryStopwatch
.
finishKeyed
(
histID
key
)
;
}
if
(
value
|
|
(
key
!
=
"
storagechange
"
&
&
key
!
=
"
historychange
"
)
)
{
data
[
key
]
=
value
;
}
}
this
.
_data
.
clear
(
)
;
try
{
this
.
mm
.
sendAsyncMessage
(
"
SessionStore
:
update
"
{
data
flushID
isFinal
:
options
.
isFinal
|
|
false
epoch
:
this
.
store
.
epoch
}
)
;
}
catch
(
ex
)
{
if
(
ex
&
&
ex
.
result
=
=
Cr
.
NS_ERROR_OUT_OF_MEMORY
)
{
Services
.
telemetry
.
getHistogramById
(
"
FX_SESSION_RESTORE_SEND_UPDATE_CAUSED_OOM
"
)
.
add
(
1
)
;
this
.
mm
.
sendAsyncMessage
(
"
SessionStore
:
error
"
)
;
}
}
}
}
const
MESSAGES
=
[
"
SessionStore
:
restoreHistory
"
"
SessionStore
:
restoreTabContent
"
"
SessionStore
:
resetRestore
"
"
SessionStore
:
flush
"
"
SessionStore
:
becomeActiveProcess
"
]
;
class
ContentSessionStore
{
constructor
(
mm
)
{
this
.
mm
=
mm
;
this
.
messageQueue
=
new
MessageQueue
(
this
)
;
this
.
stateChangeNotifier
=
new
StateChangeNotifier
(
this
)
;
this
.
epoch
=
0
;
this
.
contentRestoreInitialized
=
false
;
XPCOMUtils
.
defineLazyGetter
(
this
"
contentRestore
"
(
)
=
>
{
this
.
contentRestoreInitialized
=
true
;
return
new
ContentRestore
(
mm
)
;
}
)
;
this
.
handlers
=
[
new
EventListener
(
this
)
new
FormDataListener
(
this
)
new
SessionHistoryListener
(
this
)
new
SessionStorageListener
(
this
)
new
ScrollPositionListener
(
this
)
new
DocShellCapabilitiesListener
(
this
)
new
PrivacyListener
(
this
)
this
.
stateChangeNotifier
this
.
messageQueue
]
;
MESSAGES
.
forEach
(
m
=
>
mm
.
addMessageListener
(
m
this
)
)
;
mm
.
addEventListener
(
"
pagehide
"
this
)
;
mm
.
addEventListener
(
"
unload
"
this
)
;
}
receiveMessage
(
{
name
data
}
)
{
if
(
!
this
.
mm
.
docShell
)
{
return
;
}
if
(
data
.
epoch
&
&
data
.
epoch
!
=
this
.
epoch
)
{
this
.
epoch
=
data
.
epoch
;
}
switch
(
name
)
{
case
"
SessionStore
:
restoreHistory
"
:
this
.
restoreHistory
(
data
)
;
break
;
case
"
SessionStore
:
restoreTabContent
"
:
if
(
data
.
isRemotenessUpdate
)
{
let
histogram
=
Services
.
telemetry
.
getKeyedHistogramById
(
"
FX_TAB_REMOTE_NAVIGATION_DELAY_MS
"
)
;
histogram
.
add
(
"
SessionStore
:
restoreTabContent
"
Services
.
telemetry
.
msSystemNow
(
)
-
data
.
requestTime
)
;
}
this
.
restoreTabContent
(
data
)
;
break
;
case
"
SessionStore
:
resetRestore
"
:
this
.
contentRestore
.
resetRestore
(
)
;
break
;
case
"
SessionStore
:
flush
"
:
this
.
flush
(
data
)
;
break
;
case
"
SessionStore
:
becomeActiveProcess
"
:
SessionHistoryListener
.
collect
(
)
;
break
;
default
:
debug
(
"
received
unknown
message
'
"
+
name
+
"
'
"
)
;
break
;
}
}
restoreHistory
(
{
epoch
tabData
loadArguments
isRemotenessUpdate
}
)
{
this
.
contentRestore
.
restoreHistory
(
tabData
loadArguments
{
onLoadStarted
:
(
)
=
>
{
this
.
mm
.
sendAsyncMessage
(
"
SessionStore
:
restoreTabContentStarted
"
{
epoch
}
)
;
}
onLoadFinished
:
(
)
=
>
{
this
.
mm
.
sendAsyncMessage
(
"
SessionStore
:
restoreTabContentComplete
"
{
epoch
}
)
;
}
}
)
;
if
(
Services
.
appinfo
.
processType
=
=
Services
.
appinfo
.
PROCESS_TYPE_DEFAULT
)
{
this
.
mm
.
sendSyncMessage
(
"
SessionStore
:
restoreHistoryComplete
"
{
epoch
isRemotenessUpdate
}
)
;
}
else
{
this
.
mm
.
sendAsyncMessage
(
"
SessionStore
:
restoreHistoryComplete
"
{
epoch
isRemotenessUpdate
}
)
;
}
}
restoreTabContent
(
{
loadArguments
isRemotenessUpdate
reason
}
)
{
let
epoch
=
this
.
epoch
;
let
didStartLoad
=
this
.
contentRestore
.
restoreTabContent
(
loadArguments
isRemotenessUpdate
(
)
=
>
{
this
.
mm
.
sendAsyncMessage
(
"
SessionStore
:
restoreTabContentComplete
"
{
epoch
isRemotenessUpdate
}
)
;
}
)
;
this
.
mm
.
sendAsyncMessage
(
"
SessionStore
:
restoreTabContentStarted
"
{
epoch
isRemotenessUpdate
reason
}
)
;
if
(
!
didStartLoad
)
{
this
.
mm
.
sendAsyncMessage
(
"
SessionStore
:
restoreTabContentComplete
"
{
epoch
isRemotenessUpdate
}
)
;
}
}
flush
(
{
id
}
)
{
this
.
messageQueue
.
send
(
{
flushID
:
id
}
)
;
}
handleEvent
(
event
)
{
if
(
event
.
type
=
=
"
pagehide
"
)
{
this
.
handleRevivedTab
(
)
;
}
else
if
(
event
.
type
=
=
"
unload
"
)
{
this
.
onUnload
(
)
;
}
}
onUnload
(
)
{
this
.
messageQueue
.
send
(
{
isFinal
:
true
}
)
;
this
.
handleRevivedTab
(
)
;
for
(
let
handler
of
this
.
handlers
)
{
if
(
handler
.
uninit
)
{
handler
.
uninit
(
)
;
}
}
if
(
this
.
contentRestoreInitialized
)
{
this
.
contentRestore
.
resetRestore
(
)
;
}
}
handleRevivedTab
(
)
{
let
{
content
}
=
this
.
mm
;
if
(
!
content
)
{
this
.
mm
.
removeEventListener
(
"
pagehide
"
this
)
;
return
;
}
if
(
content
.
document
.
documentURI
.
startsWith
(
"
about
:
tabcrashed
"
)
)
{
if
(
Services
.
appinfo
.
processType
!
=
Services
.
appinfo
.
PROCESS_TYPE_DEFAULT
)
{
throw
new
Error
(
"
We
seem
to
be
navigating
away
from
about
:
tabcrashed
in
"
+
"
a
non
-
remote
browser
.
This
should
really
never
happen
.
"
)
;
}
this
.
mm
.
removeEventListener
(
"
pagehide
"
this
)
;
this
.
mm
.
sendAsyncMessage
(
"
SessionStore
:
crashedTabRevived
"
)
;
}
}
}
