"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
SessionSaver
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
this
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AppConstants
:
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
PrivacyFilter
:
"
resource
:
/
/
gre
/
modules
/
sessionstore
/
PrivacyFilter
.
jsm
"
RunState
:
"
resource
:
/
/
/
modules
/
sessionstore
/
RunState
.
jsm
"
SessionStore
:
"
resource
:
/
/
/
modules
/
sessionstore
/
SessionStore
.
jsm
"
SessionFile
:
"
resource
:
/
/
/
modules
/
sessionstore
/
SessionFile
.
jsm
"
PrivateBrowsingUtils
:
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
}
)
;
const
PREF_INTERVAL_ACTIVE
=
"
browser
.
sessionstore
.
interval
"
;
const
PREF_INTERVAL_IDLE
=
"
browser
.
sessionstore
.
interval
.
idle
"
;
const
PREF_IDLE_DELAY
=
"
browser
.
sessionstore
.
idleDelay
"
;
function
notify
(
subject
topic
)
{
Services
.
obs
.
notifyObservers
(
subject
topic
)
;
}
function
stopWatch
(
method
)
{
return
function
(
.
.
.
histograms
)
{
for
(
let
hist
of
histograms
)
{
TelemetryStopwatch
[
method
]
(
"
FX_SESSION_RESTORE_
"
+
hist
)
;
}
}
;
}
var
stopWatchStart
=
stopWatch
(
"
start
"
)
;
var
stopWatchFinish
=
stopWatch
(
"
finish
"
)
;
var
SessionSaver
=
Object
.
freeze
(
{
run
(
)
{
return
SessionSaverInternal
.
run
(
)
;
}
runDelayed
(
)
{
SessionSaverInternal
.
runDelayed
(
)
;
}
updateLastSaveTime
(
)
{
SessionSaverInternal
.
updateLastSaveTime
(
)
;
}
cancel
(
)
{
SessionSaverInternal
.
cancel
(
)
;
}
}
)
;
var
SessionSaverInternal
=
{
_timeoutID
:
null
_idleCallbackID
:
null
_lastSaveTime
:
0
_isIdle
:
false
_wasIdle
:
false
_intervalWhileActive
:
null
_intervalWhileIdle
:
null
_idleDelay
:
null
run
(
)
{
return
this
.
_saveState
(
true
)
;
}
runDelayed
(
delay
=
2000
)
{
if
(
this
.
_timeoutID
)
{
return
;
}
let
interval
=
this
.
_isIdle
?
this
.
_intervalWhileIdle
:
this
.
_intervalWhileActive
;
delay
=
Math
.
max
(
this
.
_lastSaveTime
+
interval
-
Date
.
now
(
)
delay
0
)
;
this
.
_wasIdle
=
this
.
_isIdle
;
this
.
_timeoutID
=
setTimeout
(
(
)
=
>
{
let
saveStateAsyncWhenIdle
=
deadline
=
>
{
if
(
deadline
.
timeRemaining
(
)
<
5
)
{
this
.
_idleCallbackID
=
requestIdleCallback
(
saveStateAsyncWhenIdle
)
;
return
;
}
this
.
_saveStateAsync
(
)
;
}
;
this
.
_idleCallbackID
=
requestIdleCallback
(
saveStateAsyncWhenIdle
)
;
}
delay
)
;
}
updateLastSaveTime
(
)
{
this
.
_lastSaveTime
=
Date
.
now
(
)
;
}
cancel
(
)
{
clearTimeout
(
this
.
_timeoutID
)
;
this
.
_timeoutID
=
null
;
cancelIdleCallback
(
this
.
_idleCallbackID
)
;
this
.
_idleCallbackID
=
null
;
}
observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
"
idle
"
:
this
.
_isIdle
=
true
;
break
;
case
"
active
"
:
this
.
_isIdle
=
false
;
if
(
this
.
_timeoutID
&
&
this
.
_wasIdle
)
{
clearTimeout
(
this
.
_timeoutID
)
;
this
.
_timeoutID
=
null
;
this
.
runDelayed
(
)
;
}
break
;
default
:
throw
new
Error
(
Unexpected
change
value
{
topic
}
)
;
}
}
_saveState
(
forceUpdateAllWindows
=
false
)
{
this
.
cancel
(
)
;
if
(
PrivateBrowsingUtils
.
permanentPrivateBrowsing
)
{
this
.
updateLastSaveTime
(
)
;
return
Promise
.
resolve
(
)
;
}
stopWatchStart
(
"
COLLECT_DATA_MS
"
)
;
let
state
=
SessionStore
.
getCurrentState
(
forceUpdateAllWindows
)
;
PrivacyFilter
.
filterPrivateWindowsAndTabs
(
state
)
;
SessionStore
.
keepOnlyWorthSavingTabs
(
state
)
;
if
(
state
.
deferredInitialState
)
{
state
.
windows
=
state
.
deferredInitialState
.
windows
|
|
[
]
;
delete
state
.
deferredInitialState
;
}
if
(
AppConstants
.
platform
!
=
"
macosx
"
)
{
while
(
state
.
_closedWindows
.
length
)
{
let
i
=
state
.
_closedWindows
.
length
-
1
;
if
(
!
state
.
_closedWindows
[
i
]
.
_shouldRestore
)
{
break
;
}
delete
state
.
_closedWindows
[
i
]
.
_shouldRestore
;
state
.
windows
.
unshift
(
state
.
_closedWindows
.
pop
(
)
)
;
}
}
this
.
_maybeClearCookiesAndStorage
(
state
)
;
stopWatchFinish
(
"
COLLECT_DATA_MS
"
)
;
return
this
.
_writeState
(
state
)
;
}
_maybeClearCookiesAndStorage
(
state
)
{
if
(
!
RunState
.
isClosing
)
{
return
;
}
if
(
Services
.
prefs
.
getBoolPref
(
"
browser
.
sessionstore
.
resume_session_once
"
)
)
{
return
;
}
let
expireCookies
=
Services
.
prefs
.
getIntPref
(
"
network
.
cookie
.
lifetimePolicy
"
)
=
=
Services
.
cookies
.
QueryInterface
(
Ci
.
nsICookieService
)
.
ACCEPT_SESSION
;
let
sanitizeCookies
=
Services
.
prefs
.
getBoolPref
(
"
privacy
.
sanitize
.
sanitizeOnShutdown
"
)
&
&
Services
.
prefs
.
getBoolPref
(
"
privacy
.
clearOnShutdown
.
cookies
"
)
;
if
(
expireCookies
|
|
sanitizeCookies
)
{
delete
state
.
cookies
;
for
(
let
window
of
state
.
windows
)
{
for
(
let
tab
of
window
.
tabs
)
{
delete
tab
.
storage
;
}
}
}
}
_saveStateAsync
(
)
{
this
.
_timeoutID
=
null
;
this
.
_saveState
(
)
;
}
_writeState
(
state
)
{
this
.
updateLastSaveTime
(
)
;
return
SessionFile
.
write
(
state
)
.
then
(
(
)
=
>
{
this
.
updateLastSaveTime
(
)
;
notify
(
null
"
sessionstore
-
state
-
write
-
complete
"
)
;
}
console
.
error
)
;
}
}
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
SessionSaverInternal
"
_intervalWhileActive
"
PREF_INTERVAL_ACTIVE
15000
(
)
=
>
{
SessionSaverInternal
.
cancel
(
)
;
SessionSaverInternal
.
runDelayed
(
0
)
;
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
SessionSaverInternal
"
_intervalWhileIdle
"
PREF_INTERVAL_IDLE
3600000
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
SessionSaverInternal
"
_idleDelay
"
PREF_IDLE_DELAY
180000
(
key
previous
latest
)
=
>
{
var
idleService
=
Cc
[
"
mozilla
.
org
/
widget
/
idleservice
;
1
"
]
.
getService
(
Ci
.
nsIIdleService
)
;
if
(
previous
!
=
undefined
)
{
idleService
.
removeIdleObserver
(
SessionSaverInternal
previous
)
;
}
if
(
latest
!
=
undefined
)
{
idleService
.
addIdleObserver
(
SessionSaverInternal
latest
)
;
}
}
)
;
var
idleService
=
Cc
[
"
mozilla
.
org
/
widget
/
idleservice
;
1
"
]
.
getService
(
Ci
.
nsIIdleService
)
;
idleService
.
addIdleObserver
(
SessionSaverInternal
SessionSaverInternal
.
_idleDelay
)
;
