"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
StartupPerformance
"
]
;
const
{
utils
:
Cu
classes
:
Cc
interfaces
:
Ci
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
this
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Services
"
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
console
"
"
resource
:
/
/
gre
/
modules
/
Console
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
setTimeout
"
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
clearTimeout
"
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Promise
"
"
resource
:
/
/
gre
/
modules
/
Promise
.
jsm
"
)
;
const
COLLECT_RESULTS_AFTER_MS
=
10000
;
const
TOPICS
=
[
"
sessionstore
-
restoring
-
on
-
startup
"
"
sessionstore
-
initiating
-
manual
-
restore
"
]
;
this
.
StartupPerformance
=
{
_startTimeStamp
:
null
_latestRestoredTimeStamp
:
null
_promiseFinished
:
null
_resolveFinished
:
null
_deadlineTimer
:
null
_hasFired
:
false
init
:
function
(
)
{
for
(
let
topic
of
TOPICS
)
{
Services
.
obs
.
addObserver
(
this
topic
false
)
;
}
}
_onRestorationStarts
:
function
(
isAutoRestore
)
{
this
.
_startTimeStamp
=
Date
.
now
(
)
;
for
(
let
topic
of
TOPICS
)
{
Services
.
obs
.
removeObserver
(
this
topic
)
;
}
Services
.
obs
.
addObserver
(
this
"
sessionstore
-
single
-
window
-
restored
"
false
)
;
this
.
_promiseFinished
=
new
Promise
(
resolve
=
>
{
this
.
_resolveFinished
=
resolve
;
}
)
;
this
.
_promiseFinished
.
then
(
(
)
=
>
{
try
{
if
(
!
this
.
_latestRestoredTimeStamp
)
{
return
;
}
let
histogramName
=
isAutoRestore
?
"
FX_SESSION_RESTORE_AUTO_RESTORE_DURATION_UNTIL_EAGER_TABS_RESTORED_MS
"
:
"
FX_SESSION_RESTORE_MANUAL_RESTORE_DURATION_UNTIL_EAGER_TABS_RESTORED_MS
"
;
let
histogram
=
Services
.
telemetry
.
getHistogramById
(
histogramName
)
;
let
delta
=
this
.
_latestRestoredTimeStamp
-
this
.
_startTimeStamp
;
histogram
.
add
(
delta
)
;
this
.
_startTimeStamp
=
null
;
}
catch
(
ex
)
{
console
.
error
(
"
StartupPerformance
:
error
after
resolving
promise
"
ex
)
;
}
}
)
;
}
_startTimer
:
function
(
)
{
if
(
this
.
_hasFired
)
{
return
;
}
if
(
this
.
_deadlineTimer
)
{
clearTimeout
(
this
.
_deadlineTimer
)
;
}
this
.
_deadlineTimer
=
setTimeout
(
(
)
=
>
{
try
{
this
.
_resolveFinished
(
)
;
}
catch
(
ex
)
{
console
.
error
(
"
StartupPerformance
:
Error
in
timeout
handler
"
ex
)
;
}
finally
{
this
.
_deadlineTimer
=
null
;
this
.
_hasFired
=
true
;
this
.
_resolveFinished
=
null
;
Services
.
obs
.
removeObserver
(
this
"
sessionstore
-
single
-
window
-
restored
"
)
;
}
}
COLLECT_RESULTS_AFTER_MS
)
;
}
observe
:
function
(
subject
topic
details
)
{
try
{
switch
(
topic
)
{
case
"
sessionstore
-
restoring
-
on
-
startup
"
:
this
.
_onRestorationStarts
(
true
)
;
break
;
case
"
sessionstore
-
initiating
-
manual
-
restore
"
:
this
.
_onRestorationStarts
(
false
)
;
break
;
case
"
sessionstore
-
single
-
window
-
restored
"
:
{
this
.
_startTimer
(
)
;
let
win
=
subject
;
let
observer
=
(
)
=
>
{
this
.
_latestRestoredTimeStamp
=
Date
.
now
(
)
;
}
;
win
.
gBrowser
.
tabContainer
.
addEventListener
(
"
SSTabRestored
"
observer
)
;
this
.
_promiseFinished
.
then
(
(
)
=
>
{
if
(
!
win
.
gBrowser
.
tabContainer
)
{
return
;
}
win
.
gBrowser
.
tabContainer
.
removeEventListener
(
"
SSTabRestored
"
observer
)
;
}
)
;
}
break
;
default
:
throw
new
Error
(
Unexpected
topic
{
topic
}
)
;
}
}
catch
(
ex
)
{
console
.
error
(
"
StartupPerformance
error
"
ex
ex
.
stack
)
;
throw
ex
;
}
}
}
;
