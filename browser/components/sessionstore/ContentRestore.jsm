"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
ContentRestore
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
this
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
SessionHistory
"
"
resource
:
/
/
gre
/
modules
/
sessionstore
/
SessionHistory
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Utils
"
"
resource
:
/
/
gre
/
modules
/
sessionstore
/
Utils
.
jsm
"
)
;
function
ContentRestore
(
chromeGlobal
)
{
let
internal
=
new
ContentRestoreInternal
(
chromeGlobal
)
;
let
external
=
{
}
;
let
EXPORTED_METHODS
=
[
"
restoreHistory
"
"
finishRestoreHistory
"
"
restoreOnNewEntry
"
"
restoreTabContent
"
"
restoreDocument
"
"
resetRestore
"
]
;
for
(
let
method
of
EXPORTED_METHODS
)
{
external
[
method
]
=
internal
[
method
]
.
bind
(
internal
)
;
}
return
Object
.
freeze
(
external
)
;
}
function
ContentRestoreInternal
(
chromeGlobal
)
{
this
.
chromeGlobal
=
chromeGlobal
;
this
.
_tabData
=
null
;
this
.
_tabDataForFinishRestoreHistory
=
null
;
this
.
_restoringDocument
=
null
;
this
.
_historyListener
=
null
;
this
.
_progressListener
=
null
;
this
.
_shistoryInParent
=
false
;
}
function
kickOffNewLoadFromBlankPage
(
webNavigation
newURI
)
{
webNavigation
.
setCurrentURI
(
Services
.
io
.
newURI
(
"
about
:
blank
"
)
)
;
let
loadFlags
=
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP
;
let
loadURIOptions
=
{
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
loadFlags
}
;
webNavigation
.
loadURI
(
newURI
loadURIOptions
)
;
}
ContentRestoreInternal
.
prototype
=
{
get
docShell
(
)
{
return
this
.
chromeGlobal
.
docShell
;
}
restoreHistory
(
tabData
loadArguments
callbacks
shistoryInParent
)
{
this
.
_tabData
=
tabData
;
let
webNavigation
=
this
.
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
;
webNavigation
.
stop
(
Ci
.
nsIWebNavigation
.
STOP_ALL
)
;
let
activeIndex
=
tabData
.
index
-
1
;
let
activePageData
=
tabData
.
entries
[
activeIndex
]
|
|
{
}
;
let
uri
=
activePageData
.
url
|
|
null
;
if
(
uri
&
&
!
loadArguments
)
{
webNavigation
.
setCurrentURI
(
Services
.
io
.
newURI
(
uri
)
)
;
}
this
.
_shistoryInParent
=
shistoryInParent
;
this
.
_tabDataForFinishRestoreHistory
=
tabData
;
if
(
this
.
_shistoryInParent
)
{
callbacks
.
requestRestoreSHistory
(
)
;
}
else
{
SessionHistory
.
restore
(
this
.
docShell
tabData
)
;
let
listener
=
new
HistoryListener
(
this
.
docShell
(
)
=
>
{
this
.
restoreTabContent
(
null
false
callbacks
.
onLoadFinished
null
null
)
;
}
)
;
webNavigation
.
sessionHistory
.
legacySHistory
.
addSHistoryListener
(
listener
)
;
this
.
_historyListener
=
listener
;
this
.
finishRestoreHistory
(
callbacks
)
;
}
}
finishRestoreHistory
(
callbacks
)
{
let
tabData
=
this
.
_tabDataForFinishRestoreHistory
;
this
.
_tabDataForFinishRestoreHistory
=
null
;
SessionStoreUtils
.
restoreDocShellCapabilities
(
this
.
docShell
tabData
.
disallow
)
;
if
(
tabData
.
storage
&
&
this
.
docShell
instanceof
Ci
.
nsIDocShell
)
{
SessionStoreUtils
.
restoreSessionStorage
(
this
.
docShell
tabData
.
storage
)
;
delete
tabData
.
storage
;
}
this
.
_progressListener
=
new
ProgressListener
(
this
.
docShell
{
onStartRequest
:
(
)
=
>
{
this
.
_tabData
=
null
;
this
.
restoreTabContentStarted
(
callbacks
.
onLoadFinished
callbacks
.
removeRestoreListener
)
;
callbacks
.
onLoadStarted
(
)
;
}
}
)
;
}
restoreOnNewEntry
(
newURI
)
{
let
webNavigation
=
this
.
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
;
kickOffNewLoadFromBlankPage
(
webNavigation
newURI
)
;
}
restoreTabContent
(
loadArguments
isRemotenessUpdate
finishCallback
removeListenerCallback
reloadSHistoryCallback
)
{
let
tabData
=
this
.
_tabData
;
this
.
_tabData
=
null
;
let
webNavigation
=
this
.
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
;
this
.
restoreTabContentStarted
(
finishCallback
removeListenerCallback
)
;
if
(
!
isRemotenessUpdate
)
{
webNavigation
.
setCurrentURI
(
Services
.
io
.
newURI
(
"
about
:
blank
"
)
)
;
}
try
{
if
(
loadArguments
)
{
webNavigation
.
resumeRedirectedLoad
(
loadArguments
.
redirectLoadSwitchId
loadArguments
.
redirectHistoryIndex
)
;
}
else
if
(
tabData
.
userTypedValue
&
&
tabData
.
userTypedClear
)
{
let
loadURIOptions
=
{
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
loadFlags
:
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP
}
;
webNavigation
.
loadURI
(
tabData
.
userTypedValue
loadURIOptions
)
;
}
else
if
(
tabData
.
entries
.
length
)
{
let
activeIndex
=
tabData
.
index
-
1
;
this
.
_restoringDocument
=
{
entry
:
tabData
.
entries
[
activeIndex
]
|
|
{
}
formdata
:
tabData
.
formdata
|
|
{
}
scrollPositions
:
tabData
.
scroll
|
|
{
}
}
;
if
(
this
.
_shistoryInParent
)
{
reloadSHistoryCallback
(
)
;
}
else
{
let
history
=
webNavigation
.
sessionHistory
.
legacySHistory
;
history
.
reloadCurrentEntry
(
)
;
}
}
else
{
let
loadURIOptions
=
{
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
loadFlags
:
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_BYPASS_HISTORY
}
;
webNavigation
.
loadURI
(
"
about
:
blank
"
loadURIOptions
)
;
}
return
true
;
}
catch
(
ex
)
{
if
(
ex
instanceof
Ci
.
nsIException
)
{
return
false
;
}
}
return
null
;
}
restoreTabContentStarted
(
finishCallback
removeListenerCallback
)
{
if
(
this
.
_shistoryInParent
)
{
removeListenerCallback
(
)
;
}
else
if
(
this
.
_historyListener
)
{
this
.
_historyListener
.
uninstall
(
)
;
this
.
_historyListener
=
null
;
}
this
.
_progressListener
.
uninstall
(
)
;
this
.
_progressListener
=
new
ProgressListener
(
this
.
docShell
{
onStopRequest
:
(
)
=
>
{
this
.
resetRestore
(
)
;
finishCallback
(
)
;
}
}
)
;
}
restoreDocument
(
)
{
if
(
!
this
.
_restoringDocument
)
{
return
;
}
let
{
formdata
scrollPositions
}
=
this
.
_restoringDocument
;
this
.
_restoringDocument
=
null
;
let
window
=
this
.
docShell
.
domWindow
;
Utils
.
restoreFrameTreeData
(
window
formdata
(
frame
data
)
=
>
{
return
SessionStoreUtils
.
restoreFormData
(
frame
.
document
data
)
;
}
)
;
Utils
.
restoreFrameTreeData
(
window
scrollPositions
(
frame
data
)
=
>
{
if
(
data
.
scroll
)
{
SessionStoreUtils
.
restoreScrollPosition
(
frame
data
)
;
}
}
)
;
}
resetRestore
(
)
{
this
.
_tabData
=
null
;
if
(
this
.
_historyListener
)
{
this
.
_historyListener
.
uninstall
(
)
;
}
this
.
_historyListener
=
null
;
if
(
this
.
_progressListener
)
{
this
.
_progressListener
.
uninstall
(
)
;
}
this
.
_progressListener
=
null
;
}
}
;
function
HistoryListener
(
docShell
callback
)
{
let
webNavigation
=
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
;
webNavigation
.
sessionHistory
.
legacySHistory
.
addSHistoryListener
(
this
)
;
this
.
webNavigation
=
webNavigation
;
this
.
callback
=
callback
;
}
HistoryListener
.
prototype
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsISHistoryListener
"
"
nsISupportsWeakReference
"
]
)
uninstall
(
)
{
let
shistory
=
this
.
webNavigation
.
sessionHistory
.
legacySHistory
;
if
(
shistory
)
{
shistory
.
removeSHistoryListener
(
this
)
;
}
}
OnHistoryGotoIndex
(
)
{
}
OnHistoryPurge
(
)
{
}
OnHistoryReplaceEntry
(
)
{
}
OnHistoryNewEntry
(
newURI
)
{
let
currentURI
=
this
.
webNavigation
.
currentURI
;
if
(
currentURI
&
&
currentURI
.
spec
=
=
newURI
.
spec
)
{
return
;
}
kickOffNewLoadFromBlankPage
(
this
.
webNavigation
newURI
)
;
}
OnHistoryReload
(
)
{
this
.
callback
(
)
;
return
false
;
}
}
;
function
ProgressListener
(
docShell
callbacks
)
{
let
webProgress
=
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebProgress
)
;
webProgress
.
addProgressListener
(
this
Ci
.
nsIWebProgress
.
NOTIFY_STATE_WINDOW
)
;
this
.
webProgress
=
webProgress
;
this
.
callbacks
=
callbacks
;
}
ProgressListener
.
prototype
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIWebProgressListener
"
"
nsISupportsWeakReference
"
]
)
uninstall
(
)
{
this
.
webProgress
.
removeProgressListener
(
this
)
;
}
onStateChange
(
webProgress
request
stateFlags
status
)
{
let
{
STATE_IS_WINDOW
STATE_STOP
STATE_START
}
=
Ci
.
nsIWebProgressListener
;
if
(
!
webProgress
.
isTopLevel
|
|
!
(
stateFlags
&
STATE_IS_WINDOW
)
)
{
return
;
}
if
(
stateFlags
&
STATE_START
&
&
this
.
callbacks
.
onStartRequest
)
{
this
.
callbacks
.
onStartRequest
(
)
;
}
if
(
stateFlags
&
STATE_STOP
&
&
this
.
callbacks
.
onStopRequest
)
{
this
.
callbacks
.
onStopRequest
(
)
;
}
}
}
;
