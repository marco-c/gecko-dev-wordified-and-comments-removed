"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
ContentRestore
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
this
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
DocShellCapabilities
"
"
resource
:
/
/
/
modules
/
sessionstore
/
DocShellCapabilities
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
FormData
"
"
resource
:
/
/
gre
/
modules
/
FormData
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ScrollPosition
"
"
resource
:
/
/
gre
/
modules
/
ScrollPosition
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
SessionHistory
"
"
resource
:
/
/
gre
/
modules
/
sessionstore
/
SessionHistory
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
SessionStorage
"
"
resource
:
/
/
/
modules
/
sessionstore
/
SessionStorage
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Utils
"
"
resource
:
/
/
gre
/
modules
/
sessionstore
/
Utils
.
jsm
"
)
;
const
ssu
=
Cc
[
"
mozilla
.
org
/
browser
/
sessionstore
/
utils
;
1
"
]
.
getService
(
Ci
.
nsISessionStoreUtils
)
;
function
restoreFrameTreeData
(
frame
data
cb
)
{
if
(
cb
(
frame
data
)
=
=
=
false
)
{
return
;
}
if
(
!
data
.
hasOwnProperty
(
"
children
"
)
)
{
return
;
}
ssu
.
forEachNonDynamicChildFrame
(
frame
(
subframe
index
)
=
>
{
if
(
data
.
children
[
index
]
)
{
restoreFrameTreeData
(
subframe
data
.
children
[
index
]
cb
)
;
}
}
)
;
}
function
ContentRestore
(
chromeGlobal
)
{
let
internal
=
new
ContentRestoreInternal
(
chromeGlobal
)
;
let
external
=
{
}
;
let
EXPORTED_METHODS
=
[
"
restoreHistory
"
"
restoreTabContent
"
"
restoreDocument
"
"
resetRestore
"
]
;
for
(
let
method
of
EXPORTED_METHODS
)
{
external
[
method
]
=
internal
[
method
]
.
bind
(
internal
)
;
}
return
Object
.
freeze
(
external
)
;
}
function
ContentRestoreInternal
(
chromeGlobal
)
{
this
.
chromeGlobal
=
chromeGlobal
;
this
.
_tabData
=
null
;
this
.
_restoringDocument
=
null
;
this
.
_historyListener
=
null
;
this
.
_progressListener
=
null
;
}
ContentRestoreInternal
.
prototype
=
{
get
docShell
(
)
{
return
this
.
chromeGlobal
.
docShell
;
}
restoreHistory
(
tabData
loadArguments
callbacks
)
{
this
.
_tabData
=
tabData
;
let
webNavigation
=
this
.
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
;
webNavigation
.
stop
(
Ci
.
nsIWebNavigation
.
STOP_ALL
)
;
let
activeIndex
=
tabData
.
index
-
1
;
let
activePageData
=
tabData
.
entries
[
activeIndex
]
|
|
{
}
;
let
uri
=
activePageData
.
url
|
|
null
;
if
(
uri
&
&
!
loadArguments
)
{
webNavigation
.
setCurrentURI
(
Utils
.
makeURI
(
uri
)
)
;
}
SessionHistory
.
restore
(
this
.
docShell
tabData
)
;
let
listener
=
new
HistoryListener
(
this
.
docShell
(
)
=
>
{
this
.
restoreTabContent
(
null
false
callbacks
.
onLoadFinished
)
;
}
)
;
webNavigation
.
sessionHistory
.
legacySHistory
.
addSHistoryListener
(
listener
)
;
this
.
_historyListener
=
listener
;
let
disallow
=
new
Set
(
tabData
.
disallow
&
&
tabData
.
disallow
.
split
(
"
"
)
)
;
DocShellCapabilities
.
restore
(
this
.
docShell
disallow
)
;
if
(
tabData
.
storage
&
&
this
.
docShell
instanceof
Ci
.
nsIDocShell
)
{
SessionStorage
.
restore
(
this
.
docShell
tabData
.
storage
)
;
delete
tabData
.
storage
;
}
this
.
_progressListener
=
new
ProgressListener
(
this
.
docShell
{
onStartRequest
:
(
)
=
>
{
this
.
_tabData
=
null
;
this
.
restoreTabContentStarted
(
callbacks
.
onLoadFinished
)
;
callbacks
.
onLoadStarted
(
)
;
}
}
)
;
}
restoreTabContent
(
loadArguments
isRemotenessUpdate
finishCallback
)
{
let
tabData
=
this
.
_tabData
;
this
.
_tabData
=
null
;
let
webNavigation
=
this
.
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
;
let
history
=
webNavigation
.
sessionHistory
.
legacySHistory
;
this
.
restoreTabContentStarted
(
finishCallback
)
;
if
(
!
isRemotenessUpdate
)
{
webNavigation
.
setCurrentURI
(
Utils
.
makeURI
(
"
about
:
blank
"
)
)
;
}
try
{
if
(
loadArguments
)
{
let
referrer
=
loadArguments
.
referrer
?
Utils
.
makeURI
(
loadArguments
.
referrer
)
:
null
;
let
referrerPolicy
=
(
"
referrerPolicy
"
in
loadArguments
?
loadArguments
.
referrerPolicy
:
Ci
.
nsIHttpChannel
.
REFERRER_POLICY_UNSET
)
;
let
postData
=
loadArguments
.
postData
?
Utils
.
makeInputStream
(
loadArguments
.
postData
)
:
null
;
let
triggeringPrincipal
=
loadArguments
.
triggeringPrincipal
?
Utils
.
deserializePrincipal
(
loadArguments
.
triggeringPrincipal
)
:
null
;
if
(
loadArguments
.
userContextId
)
{
webNavigation
.
setOriginAttributesBeforeLoading
(
{
userContextId
:
loadArguments
.
userContextId
}
)
;
}
webNavigation
.
loadURIWithOptions
(
loadArguments
.
uri
loadArguments
.
flags
referrer
referrerPolicy
postData
null
null
triggeringPrincipal
)
;
}
else
if
(
tabData
.
userTypedValue
&
&
tabData
.
userTypedClear
)
{
webNavigation
.
loadURI
(
tabData
.
userTypedValue
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP
null
null
null
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
)
;
}
else
if
(
tabData
.
entries
.
length
)
{
let
activeIndex
=
tabData
.
index
-
1
;
this
.
_restoringDocument
=
{
entry
:
tabData
.
entries
[
activeIndex
]
|
|
{
}
formdata
:
tabData
.
formdata
|
|
{
}
scrollPositions
:
tabData
.
scroll
|
|
{
}
}
;
history
.
reloadCurrentEntry
(
)
;
}
else
{
webNavigation
.
loadURI
(
"
about
:
blank
"
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_BYPASS_HISTORY
null
null
null
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
)
;
}
return
true
;
}
catch
(
ex
)
{
if
(
ex
instanceof
Ci
.
nsIException
)
{
return
false
;
}
}
return
null
;
}
restoreTabContentStarted
(
finishCallback
)
{
this
.
_historyListener
.
uninstall
(
)
;
this
.
_historyListener
=
null
;
this
.
_progressListener
.
uninstall
(
)
;
this
.
_progressListener
=
new
ProgressListener
(
this
.
docShell
{
onStopRequest
:
(
)
=
>
{
this
.
resetRestore
(
)
;
finishCallback
(
)
;
}
}
)
;
}
restoreDocument
(
)
{
if
(
!
this
.
_restoringDocument
)
{
return
;
}
let
{
formdata
scrollPositions
}
=
this
.
_restoringDocument
;
this
.
_restoringDocument
=
null
;
let
window
=
this
.
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindow
)
;
restoreFrameTreeData
(
window
formdata
(
frame
data
)
=
>
{
return
FormData
.
restore
(
frame
data
)
;
}
)
;
restoreFrameTreeData
(
window
scrollPositions
(
frame
data
)
=
>
{
if
(
data
.
scroll
)
{
ScrollPosition
.
restore
(
frame
data
.
scroll
)
;
}
}
)
;
}
resetRestore
(
)
{
this
.
_tabData
=
null
;
if
(
this
.
_historyListener
)
{
this
.
_historyListener
.
uninstall
(
)
;
}
this
.
_historyListener
=
null
;
if
(
this
.
_progressListener
)
{
this
.
_progressListener
.
uninstall
(
)
;
}
this
.
_progressListener
=
null
;
}
}
;
function
HistoryListener
(
docShell
callback
)
{
let
webNavigation
=
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
;
webNavigation
.
sessionHistory
.
legacySHistory
.
addSHistoryListener
(
this
)
;
this
.
webNavigation
=
webNavigation
;
this
.
callback
=
callback
;
}
HistoryListener
.
prototype
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsISHistoryListener
Ci
.
nsISupportsWeakReference
]
)
uninstall
(
)
{
let
shistory
=
this
.
webNavigation
.
sessionHistory
.
legacySHistory
;
if
(
shistory
)
{
shistory
.
removeSHistoryListener
(
this
)
;
}
}
OnHistoryGoBack
(
backURI
)
{
return
true
;
}
OnHistoryGoForward
(
forwardURI
)
{
return
true
;
}
OnHistoryGotoIndex
(
index
gotoURI
)
{
return
true
;
}
OnHistoryPurge
(
numEntries
)
{
return
true
;
}
OnHistoryReplaceEntry
(
index
)
{
}
OnHistoryNewEntry
(
newURI
)
{
let
currentURI
=
this
.
webNavigation
.
currentURI
;
if
(
currentURI
&
&
(
currentURI
.
spec
=
=
newURI
.
spec
)
)
{
return
;
}
this
.
webNavigation
.
setCurrentURI
(
Utils
.
makeURI
(
"
about
:
blank
"
)
)
;
let
flags
=
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP
;
this
.
webNavigation
.
loadURI
(
newURI
.
spec
flags
null
null
null
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
)
;
}
OnHistoryReload
(
reloadURI
reloadFlags
)
{
this
.
callback
(
)
;
return
false
;
}
OnLengthChanged
(
aCount
)
{
}
OnIndexChanged
(
aIndex
)
{
}
}
;
function
ProgressListener
(
docShell
callbacks
)
{
let
webProgress
=
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebProgress
)
;
webProgress
.
addProgressListener
(
this
Ci
.
nsIWebProgress
.
NOTIFY_STATE_WINDOW
)
;
this
.
webProgress
=
webProgress
;
this
.
callbacks
=
callbacks
;
}
ProgressListener
.
prototype
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIWebProgressListener
Ci
.
nsISupportsWeakReference
]
)
uninstall
(
)
{
this
.
webProgress
.
removeProgressListener
(
this
)
;
}
onStateChange
(
webProgress
request
stateFlags
status
)
{
let
{
STATE_IS_WINDOW
STATE_STOP
STATE_START
}
=
Ci
.
nsIWebProgressListener
;
if
(
!
webProgress
.
isTopLevel
|
|
!
(
stateFlags
&
STATE_IS_WINDOW
)
)
{
return
;
}
if
(
stateFlags
&
STATE_START
&
&
this
.
callbacks
.
onStartRequest
)
{
this
.
callbacks
.
onStartRequest
(
)
;
}
if
(
stateFlags
&
STATE_STOP
&
&
this
.
callbacks
.
onStopRequest
)
{
this
.
callbacks
.
onStopRequest
(
)
;
}
}
}
;
