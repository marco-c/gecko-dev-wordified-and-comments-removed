"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
TabStateFlusher
"
]
;
ChromeUtils
.
defineModuleGetter
(
this
"
SessionStore
"
"
resource
:
/
/
/
modules
/
sessionstore
/
SessionStore
.
jsm
"
)
;
var
TabStateFlusher
=
Object
.
freeze
(
{
flush
(
browser
)
{
return
TabStateFlusherInternal
.
flush
(
browser
)
;
}
flushWindow
(
window
)
{
return
TabStateFlusherInternal
.
flushWindow
(
window
)
;
}
resolve
(
browser
flushID
success
=
true
message
=
"
"
)
{
TabStateFlusherInternal
.
resolve
(
browser
flushID
success
message
)
;
}
resolveAll
(
browser
success
=
true
message
=
"
"
)
{
TabStateFlusherInternal
.
resolveAll
(
browser
success
message
)
;
}
}
)
;
var
TabStateFlusherInternal
=
{
_lastRequestID
:
0
_requests
:
new
WeakMap
(
)
_requestsToNativeListener
:
new
WeakMap
(
)
flush
(
browser
)
{
let
id
=
+
+
this
.
_lastRequestID
;
let
requestNativeListener
=
false
;
if
(
browser
&
&
browser
.
frameLoader
)
{
requestNativeListener
=
browser
.
frameLoader
.
requestTabStateFlush
(
id
)
;
}
SessionStore
.
ensureInitialized
(
browser
.
ownerGlobal
)
;
let
mm
=
browser
.
messageManager
;
mm
.
sendAsyncMessage
(
"
SessionStore
:
flush
"
{
id
}
)
;
let
permanentKey
=
browser
.
permanentKey
;
let
perBrowserRequests
=
this
.
_requests
.
get
(
permanentKey
)
|
|
new
Map
(
)
;
let
perBrowserRequestsToNative
=
this
.
_requestsToNativeListener
.
get
(
permanentKey
)
|
|
new
Map
(
)
;
return
new
Promise
(
resolve
=
>
{
perBrowserRequests
.
set
(
id
resolve
)
;
perBrowserRequestsToNative
.
set
(
id
requestNativeListener
)
;
this
.
_requests
.
set
(
permanentKey
perBrowserRequests
)
;
this
.
_requestsToNativeListener
.
set
(
permanentKey
perBrowserRequestsToNative
)
;
}
)
;
}
flushWindow
(
window
)
{
let
promises
=
[
]
;
for
(
let
browser
of
window
.
gBrowser
.
browsers
)
{
if
(
window
.
gBrowser
.
getTabForBrowser
(
browser
)
.
linkedPanel
)
{
promises
.
push
(
this
.
flush
(
browser
)
)
;
}
}
return
Promise
.
all
(
promises
)
;
}
resolve
(
browser
flushID
success
=
true
message
=
"
"
)
{
if
(
!
this
.
_requests
.
has
(
browser
.
permanentKey
)
)
{
return
;
}
let
perBrowserRequestsForNativeListener
=
this
.
_requestsToNativeListener
.
get
(
browser
.
permanentKey
)
;
if
(
!
perBrowserRequestsForNativeListener
.
has
(
flushID
)
)
{
return
;
}
let
waitForNextResolve
=
perBrowserRequestsForNativeListener
.
get
(
flushID
)
;
if
(
waitForNextResolve
)
{
perBrowserRequestsForNativeListener
.
set
(
flushID
false
)
;
this
.
_requestsToNativeListener
.
set
(
browser
.
permanentKey
perBrowserRequestsForNativeListener
)
;
return
;
}
let
perBrowserRequests
=
this
.
_requests
.
get
(
browser
.
permanentKey
)
;
if
(
!
perBrowserRequests
.
has
(
flushID
)
)
{
return
;
}
if
(
!
success
)
{
Cu
.
reportError
(
"
Failed
to
flush
browser
:
"
+
message
)
;
}
let
resolve
=
perBrowserRequests
.
get
(
flushID
)
;
perBrowserRequests
.
delete
(
flushID
)
;
resolve
(
success
)
;
}
resolveAll
(
browser
success
=
true
message
=
"
"
)
{
if
(
!
this
.
_requests
.
has
(
browser
.
permanentKey
)
)
{
return
;
}
let
perBrowserRequests
=
this
.
_requests
.
get
(
browser
.
permanentKey
)
;
if
(
!
success
)
{
Cu
.
reportError
(
"
Failed
to
flush
browser
:
"
+
message
)
;
}
for
(
let
resolve
of
perBrowserRequests
.
values
(
)
)
{
resolve
(
success
)
;
}
perBrowserRequests
.
clear
(
)
;
}
}
;
