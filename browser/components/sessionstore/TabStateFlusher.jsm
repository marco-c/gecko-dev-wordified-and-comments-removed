"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
TabStateFlusher
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
SessionStore
"
"
resource
:
/
/
/
modules
/
sessionstore
/
SessionStore
.
jsm
"
)
;
var
TabStateFlusher
=
Object
.
freeze
(
{
flush
(
browser
)
{
return
TabStateFlusherInternal
.
flush
(
browser
)
;
}
flushWindow
(
window
)
{
return
TabStateFlusherInternal
.
flushWindow
(
window
)
;
}
resolve
(
browser
flushID
success
=
true
message
=
"
"
)
{
TabStateFlusherInternal
.
resolve
(
browser
flushID
success
message
)
;
}
resolveAll
(
browser
success
=
true
message
=
"
"
)
{
TabStateFlusherInternal
.
resolveAll
(
browser
success
message
)
;
}
}
)
;
var
TabStateFlusherInternal
=
{
_lastRequestID
:
0
_requests
:
new
WeakMap
(
)
initEntry
(
entry
)
{
entry
.
perBrowserRequests
=
new
Map
(
)
;
entry
.
cancelPromise
=
new
Promise
(
resolve
=
>
{
entry
.
cancel
=
resolve
;
}
)
.
then
(
result
=
>
{
TabStateFlusherInternal
.
initEntry
(
entry
)
;
return
result
;
}
)
;
return
entry
;
}
flush
(
browser
)
{
let
id
=
+
+
this
.
_lastRequestID
;
let
nativePromise
=
Promise
.
resolve
(
)
;
if
(
browser
&
&
browser
.
frameLoader
)
{
nativePromise
=
browser
.
frameLoader
.
requestTabStateFlush
(
)
;
}
if
(
!
Services
.
appinfo
.
sessionHistoryInParent
)
{
lazy
.
SessionStore
.
ensureInitialized
(
browser
.
ownerGlobal
)
;
let
mm
=
browser
.
messageManager
;
mm
.
sendAsyncMessage
(
"
SessionStore
:
flush
"
{
id
epoch
:
lazy
.
SessionStore
.
getCurrentEpoch
(
browser
)
}
)
;
}
let
permanentKey
=
browser
.
permanentKey
;
let
request
=
this
.
_requests
.
get
(
permanentKey
)
;
if
(
!
request
)
{
request
=
this
.
initEntry
(
{
}
)
;
this
.
_requests
.
set
(
permanentKey
request
)
;
}
let
requestPromise
=
Promise
.
resolve
(
)
;
if
(
!
Services
.
appinfo
.
sessionHistoryInParent
)
{
requestPromise
=
new
Promise
(
resolve
=
>
{
request
.
perBrowserRequests
.
set
(
id
resolve
)
;
}
)
;
}
return
Promise
.
race
(
[
nativePromise
.
then
(
_
=
>
requestPromise
)
request
.
cancelPromise
]
)
;
}
flushWindow
(
window
)
{
let
promises
=
[
]
;
for
(
let
browser
of
window
.
gBrowser
.
browsers
)
{
if
(
window
.
gBrowser
.
getTabForBrowser
(
browser
)
.
linkedPanel
)
{
promises
.
push
(
this
.
flush
(
browser
)
)
;
}
}
return
Promise
.
all
(
promises
)
;
}
resolve
(
browser
flushID
success
=
true
message
=
"
"
)
{
if
(
!
this
.
_requests
.
has
(
browser
.
permanentKey
)
)
{
return
;
}
let
{
perBrowserRequests
}
=
this
.
_requests
.
get
(
browser
.
permanentKey
)
;
if
(
!
perBrowserRequests
.
has
(
flushID
)
)
{
return
;
}
if
(
!
success
)
{
Cu
.
reportError
(
"
Failed
to
flush
browser
:
"
+
message
)
;
}
let
resolve
=
perBrowserRequests
.
get
(
flushID
)
;
perBrowserRequests
.
delete
(
flushID
)
;
resolve
(
success
)
;
}
resolveAll
(
browser
success
=
true
message
=
"
"
)
{
if
(
!
this
.
_requests
.
has
(
browser
.
permanentKey
)
)
{
return
;
}
let
{
cancel
}
=
this
.
_requests
.
get
(
browser
.
permanentKey
)
;
if
(
!
success
)
{
Cu
.
reportError
(
"
Failed
to
flush
browser
:
"
+
message
)
;
}
cancel
(
success
)
;
}
}
;
