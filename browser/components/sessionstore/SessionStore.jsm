"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
SessionStore
"
"
_LastSession
"
]
;
const
FORMAT_VERSION
=
1
;
const
TAB_CUSTOM_VALUES
=
new
WeakMap
(
)
;
const
TAB_LAZY_STATES
=
new
WeakMap
(
)
;
const
TAB_STATE_NEEDS_RESTORE
=
1
;
const
TAB_STATE_RESTORING
=
2
;
const
TAB_STATE_FOR_BROWSER
=
new
WeakMap
(
)
;
const
WINDOW_RESTORE_IDS
=
new
WeakMap
(
)
;
const
WINDOW_RESTORE_ZINDICES
=
new
WeakMap
(
)
;
const
WINDOW_SHOWING_PROMISES
=
new
Map
(
)
;
const
WINDOW_FLUSHING_PROMISES
=
new
Map
(
)
;
const
NOTIFY_SINGLE_WINDOW_RESTORED
=
"
sessionstore
-
single
-
window
-
restored
"
;
const
NOTIFY_WINDOWS_RESTORED
=
"
sessionstore
-
windows
-
restored
"
;
const
NOTIFY_BROWSER_STATE_RESTORED
=
"
sessionstore
-
browser
-
state
-
restored
"
;
const
NOTIFY_LAST_SESSION_CLEARED
=
"
sessionstore
-
last
-
session
-
cleared
"
;
const
NOTIFY_RESTORING_ON_STARTUP
=
"
sessionstore
-
restoring
-
on
-
startup
"
;
const
NOTIFY_INITIATING_MANUAL_RESTORE
=
"
sessionstore
-
initiating
-
manual
-
restore
"
;
const
NOTIFY_CLOSED_OBJECTS_CHANGED
=
"
sessionstore
-
closed
-
objects
-
changed
"
;
const
NOTIFY_TAB_RESTORED
=
"
sessionstore
-
debug
-
tab
-
restored
"
;
const
NOTIFY_DOMWINDOWCLOSED_HANDLED
=
"
sessionstore
-
debug
-
domwindowclosed
-
handled
"
;
const
NOTIFY_BROWSER_SHUTDOWN_FLUSH
=
"
sessionstore
-
browser
-
shutdown
-
flush
"
;
const
MAX_CONCURRENT_TAB_RESTORES
=
3
;
const
SCREEN_EDGE_SLOP
=
8
;
const
OBSERVING
=
[
"
browser
-
window
-
before
-
show
"
"
domwindowclosed
"
"
quit
-
application
-
granted
"
"
browser
-
lastwindow
-
close
-
granted
"
"
quit
-
application
"
"
browser
:
purge
-
session
-
history
"
"
browser
:
purge
-
session
-
history
-
for
-
domain
"
"
idle
-
daily
"
"
clear
-
origin
-
attributes
-
data
"
"
browsing
-
context
-
did
-
set
-
embedder
"
"
browsing
-
context
-
discarded
"
"
browser
-
shutdown
-
tabstate
-
updated
"
]
;
const
WINDOW_ATTRIBUTES
=
[
"
width
"
"
height
"
"
screenX
"
"
screenY
"
"
sizemode
"
]
;
const
CHROME_FLAGS_MAP
=
[
[
Ci
.
nsIWebBrowserChrome
.
CHROME_TITLEBAR
"
titlebar
"
]
[
Ci
.
nsIWebBrowserChrome
.
CHROME_WINDOW_CLOSE
"
close
"
]
[
Ci
.
nsIWebBrowserChrome
.
CHROME_TOOLBAR
"
toolbar
"
]
[
Ci
.
nsIWebBrowserChrome
.
CHROME_LOCATIONBAR
"
location
"
]
[
Ci
.
nsIWebBrowserChrome
.
CHROME_PERSONAL_TOOLBAR
"
personalbar
"
]
[
Ci
.
nsIWebBrowserChrome
.
CHROME_STATUSBAR
"
status
"
]
[
Ci
.
nsIWebBrowserChrome
.
CHROME_MENUBAR
"
menubar
"
]
[
Ci
.
nsIWebBrowserChrome
.
CHROME_WINDOW_RESIZE
"
resizable
"
]
[
Ci
.
nsIWebBrowserChrome
.
CHROME_WINDOW_MIN
"
minimizable
"
]
[
Ci
.
nsIWebBrowserChrome
.
CHROME_SCROLLBARS
"
"
"
scrollbars
=
0
"
]
[
Ci
.
nsIWebBrowserChrome
.
CHROME_PRIVATE_WINDOW
"
private
"
]
[
Ci
.
nsIWebBrowserChrome
.
CHROME_NON_PRIVATE_WINDOW
"
non
-
private
"
]
[
Ci
.
nsIWebBrowserChrome
.
CHROME_WINDOW_POPUP
"
popup
"
]
[
Ci
.
nsIWebBrowserChrome
.
CHROME_WINDOW_POPUP
|
Ci
.
nsIWebBrowserChrome
.
CHROME_TITLEBAR
"
"
"
titlebar
=
0
"
]
[
Ci
.
nsIWebBrowserChrome
.
CHROME_WINDOW_POPUP
|
Ci
.
nsIWebBrowserChrome
.
CHROME_WINDOW_CLOSE
"
"
"
close
=
0
"
]
[
Ci
.
nsIWebBrowserChrome
.
CHROME_WINDOW_LOWERED
"
alwayslowered
"
]
[
Ci
.
nsIWebBrowserChrome
.
CHROME_WINDOW_RAISED
"
alwaysraised
"
]
[
Ci
.
nsIWebBrowserChrome
.
CHROME_ALWAYS_ON_TOP
"
alwaysontop
"
]
[
Ci
.
nsIWebBrowserChrome
.
CHROME_EXTRA
"
extrachrome
"
]
[
Ci
.
nsIWebBrowserChrome
.
CHROME_CENTER_SCREEN
"
centerscreen
"
]
[
Ci
.
nsIWebBrowserChrome
.
CHROME_DEPENDENT
"
dependent
"
]
[
Ci
.
nsIWebBrowserChrome
.
CHROME_MODAL
"
modal
"
]
[
Ci
.
nsIWebBrowserChrome
.
CHROME_OPENAS_DIALOG
"
dialog
"
"
dialog
=
0
"
]
]
;
const
WINDOW_HIDEABLE_FEATURES
=
[
"
menubar
"
"
toolbar
"
"
locationbar
"
"
personalbar
"
"
statusbar
"
"
scrollbars
"
]
;
const
WINDOW_OPEN_FEATURES_MAP
=
{
locationbar
:
"
location
"
statusbar
:
"
status
"
}
;
const
MESSAGES
=
[
"
SessionStore
:
update
"
"
SessionStore
:
restoreHistoryComplete
"
"
SessionStore
:
restoreTabContentStarted
"
"
SessionStore
:
restoreTabContentComplete
"
"
SessionStore
:
error
"
]
;
const
NOTAB_MESSAGES
=
new
Set
(
[
"
SessionStore
:
update
"
"
SessionStore
:
error
"
]
)
;
const
NOEPOCH_MESSAGES
=
new
Set
(
[
"
SessionStore
:
error
"
]
)
;
const
CLOSED_MESSAGES
=
new
Set
(
[
"
SessionStore
:
update
"
"
SessionStore
:
error
"
]
)
;
const
TAB_EVENTS
=
[
"
TabOpen
"
"
TabBrowserInserted
"
"
TabClose
"
"
TabSelect
"
"
TabShow
"
"
TabHide
"
"
TabPinned
"
"
TabUnpinned
"
]
;
const
XUL_NS
=
"
http
:
/
/
www
.
mozilla
.
org
/
keymaster
/
gatekeeper
/
there
.
is
.
only
.
xul
"
;
const
RESTORE_TAB_CONTENT_REASON
=
{
SET_STATE
:
0
NAVIGATE_AND_RESTORE
:
1
}
;
const
BROWSER_STARTUP_RESUME_SESSION
=
3
;
const
kNoIndex
=
Number
.
MAX_SAFE_INTEGER
;
const
kLastIndex
=
Number
.
MAX_SAFE_INTEGER
-
1
;
const
{
PrivateBrowsingUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
sys
.
mjs
"
)
;
const
{
TelemetryTimestamps
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryTimestamps
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
{
AppConstants
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
sys
.
mjs
"
)
;
const
{
GlobalState
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
/
modules
/
sessionstore
/
GlobalState
.
jsm
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyServiceGetters
(
lazy
{
gScreenManager
:
[
"
mozilla
.
org
/
gfx
/
screenmanager
;
1
"
"
nsIScreenManager
"
]
}
)
;
ChromeUtils
.
defineESModuleGetters
(
lazy
{
DevToolsShim
:
"
chrome
:
/
/
devtools
-
startup
/
content
/
DevToolsShim
.
sys
.
mjs
"
E10SUtils
:
"
resource
:
/
/
gre
/
modules
/
E10SUtils
.
sys
.
mjs
"
PrivacyFilter
:
"
resource
:
/
/
gre
/
modules
/
sessionstore
/
PrivacyFilter
.
sys
.
mjs
"
PromiseUtils
:
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
sys
.
mjs
"
SessionHistory
:
"
resource
:
/
/
gre
/
modules
/
sessionstore
/
SessionHistory
.
sys
.
mjs
"
setTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
sys
.
mjs
"
}
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
AsyncShutdown
:
"
resource
:
/
/
gre
/
modules
/
AsyncShutdown
.
jsm
"
BrowserWindowTracker
:
"
resource
:
/
/
/
modules
/
BrowserWindowTracker
.
jsm
"
HomePage
:
"
resource
:
/
/
/
modules
/
HomePage
.
jsm
"
RunState
:
"
resource
:
/
/
/
modules
/
sessionstore
/
RunState
.
jsm
"
SessionCookies
:
"
resource
:
/
/
/
modules
/
sessionstore
/
SessionCookies
.
jsm
"
SessionFile
:
"
resource
:
/
/
/
modules
/
sessionstore
/
SessionFile
.
jsm
"
SessionSaver
:
"
resource
:
/
/
/
modules
/
sessionstore
/
SessionSaver
.
jsm
"
SessionStartup
:
"
resource
:
/
/
/
modules
/
sessionstore
/
SessionStartup
.
jsm
"
TabAttributes
:
"
resource
:
/
/
/
modules
/
sessionstore
/
TabAttributes
.
jsm
"
TabCrashHandler
:
"
resource
:
/
/
/
modules
/
ContentCrashHandlers
.
jsm
"
TabState
:
"
resource
:
/
/
/
modules
/
sessionstore
/
TabState
.
jsm
"
TabStateCache
:
"
resource
:
/
/
/
modules
/
sessionstore
/
TabStateCache
.
jsm
"
TabStateFlusher
:
"
resource
:
/
/
/
modules
/
sessionstore
/
TabStateFlusher
.
jsm
"
}
)
;
var
gDebuggingEnabled
=
false
;
var
gResistFingerprintingEnabled
=
false
;
var
SessionStore
=
{
get
promiseInitialized
(
)
{
return
SessionStoreInternal
.
promiseInitialized
;
}
get
promiseAllWindowsRestored
(
)
{
return
SessionStoreInternal
.
promiseAllWindowsRestored
;
}
get
canRestoreLastSession
(
)
{
return
SessionStoreInternal
.
canRestoreLastSession
;
}
set
canRestoreLastSession
(
val
)
{
SessionStoreInternal
.
canRestoreLastSession
=
val
;
}
get
lastClosedObjectType
(
)
{
return
SessionStoreInternal
.
lastClosedObjectType
;
}
get
willAutoRestore
(
)
{
return
SessionStoreInternal
.
willAutoRestore
;
}
init
:
function
ss_init
(
)
{
SessionStoreInternal
.
init
(
)
;
}
getBrowserState
:
function
ss_getBrowserState
(
)
{
return
SessionStoreInternal
.
getBrowserState
(
)
;
}
setBrowserState
:
function
ss_setBrowserState
(
aState
)
{
SessionStoreInternal
.
setBrowserState
(
aState
)
;
}
getWindowState
:
function
ss_getWindowState
(
aWindow
)
{
return
SessionStoreInternal
.
getWindowState
(
aWindow
)
;
}
setWindowState
:
function
ss_setWindowState
(
aWindow
aState
aOverwrite
)
{
SessionStoreInternal
.
setWindowState
(
aWindow
aState
aOverwrite
)
;
}
getTabState
:
function
ss_getTabState
(
aTab
)
{
return
SessionStoreInternal
.
getTabState
(
aTab
)
;
}
setTabState
:
function
ss_setTabState
(
aTab
aState
)
{
SessionStoreInternal
.
setTabState
(
aTab
aState
)
;
}
isTabRestoring
(
aTab
)
{
return
TAB_STATE_FOR_BROWSER
.
has
(
aTab
.
linkedBrowser
)
;
}
getInternalObjectState
(
obj
)
{
return
SessionStoreInternal
.
getInternalObjectState
(
obj
)
;
}
duplicateTab
:
function
ss_duplicateTab
(
aWindow
aTab
aDelta
=
0
aRestoreImmediately
=
true
aOptions
=
{
}
)
{
return
SessionStoreInternal
.
duplicateTab
(
aWindow
aTab
aDelta
aRestoreImmediately
aOptions
)
;
}
getLastClosedTabCount
(
aWindow
)
{
return
SessionStoreInternal
.
getLastClosedTabCount
(
aWindow
)
;
}
resetLastClosedTabCount
(
aWindow
)
{
SessionStoreInternal
.
resetLastClosedTabCount
(
aWindow
)
;
}
getClosedTabCount
:
function
ss_getClosedTabCount
(
aWindow
)
{
return
SessionStoreInternal
.
getClosedTabCount
(
aWindow
)
;
}
getClosedTabData
:
function
ss_getClosedTabData
(
aWindow
)
{
return
SessionStoreInternal
.
getClosedTabData
(
aWindow
)
;
}
undoCloseTab
:
function
ss_undoCloseTab
(
aWindow
aIndex
)
{
return
SessionStoreInternal
.
undoCloseTab
(
aWindow
aIndex
)
;
}
forgetClosedTab
:
function
ss_forgetClosedTab
(
aWindow
aIndex
)
{
return
SessionStoreInternal
.
forgetClosedTab
(
aWindow
aIndex
)
;
}
getClosedWindowCount
:
function
ss_getClosedWindowCount
(
)
{
return
SessionStoreInternal
.
getClosedWindowCount
(
)
;
}
getClosedWindowData
:
function
ss_getClosedWindowData
(
)
{
return
SessionStoreInternal
.
getClosedWindowData
(
)
;
}
maybeDontRestoreTabs
(
aWindow
)
{
SessionStoreInternal
.
maybeDontRestoreTabs
(
aWindow
)
;
}
undoCloseWindow
:
function
ss_undoCloseWindow
(
aIndex
)
{
return
SessionStoreInternal
.
undoCloseWindow
(
aIndex
)
;
}
forgetClosedWindow
:
function
ss_forgetClosedWindow
(
aIndex
)
{
return
SessionStoreInternal
.
forgetClosedWindow
(
aIndex
)
;
}
getCustomWindowValue
(
aWindow
aKey
)
{
return
SessionStoreInternal
.
getCustomWindowValue
(
aWindow
aKey
)
;
}
setCustomWindowValue
(
aWindow
aKey
aStringValue
)
{
SessionStoreInternal
.
setCustomWindowValue
(
aWindow
aKey
aStringValue
)
;
}
deleteCustomWindowValue
(
aWindow
aKey
)
{
SessionStoreInternal
.
deleteCustomWindowValue
(
aWindow
aKey
)
;
}
getCustomTabValue
(
aTab
aKey
)
{
return
SessionStoreInternal
.
getCustomTabValue
(
aTab
aKey
)
;
}
setCustomTabValue
(
aTab
aKey
aStringValue
)
{
SessionStoreInternal
.
setCustomTabValue
(
aTab
aKey
aStringValue
)
;
}
deleteCustomTabValue
(
aTab
aKey
)
{
SessionStoreInternal
.
deleteCustomTabValue
(
aTab
aKey
)
;
}
getLazyTabValue
(
aTab
aKey
)
{
return
SessionStoreInternal
.
getLazyTabValue
(
aTab
aKey
)
;
}
getCustomGlobalValue
(
aKey
)
{
return
SessionStoreInternal
.
getCustomGlobalValue
(
aKey
)
;
}
setCustomGlobalValue
(
aKey
aStringValue
)
{
SessionStoreInternal
.
setCustomGlobalValue
(
aKey
aStringValue
)
;
}
deleteCustomGlobalValue
(
aKey
)
{
SessionStoreInternal
.
deleteCustomGlobalValue
(
aKey
)
;
}
persistTabAttribute
:
function
ss_persistTabAttribute
(
aName
)
{
SessionStoreInternal
.
persistTabAttribute
(
aName
)
;
}
restoreLastSession
:
function
ss_restoreLastSession
(
)
{
SessionStoreInternal
.
restoreLastSession
(
)
;
}
speculativeConnectOnTabHover
(
tab
)
{
SessionStoreInternal
.
speculativeConnectOnTabHover
(
tab
)
;
}
getCurrentState
(
aUpdateAll
)
{
return
SessionStoreInternal
.
getCurrentState
(
aUpdateAll
)
;
}
reviveCrashedTab
(
aTab
)
{
return
SessionStoreInternal
.
reviveCrashedTab
(
aTab
)
;
}
reviveAllCrashedTabs
(
)
{
return
SessionStoreInternal
.
reviveAllCrashedTabs
(
)
;
}
updateSessionStoreFromTablistener
(
aBrowser
aBrowsingContext
aPermanentKey
aData
)
{
return
SessionStoreInternal
.
updateSessionStoreFromTablistener
(
aBrowser
aBrowsingContext
aPermanentKey
aData
)
;
}
getSessionHistory
(
tab
updatedCallback
)
{
return
SessionStoreInternal
.
getSessionHistory
(
tab
updatedCallback
)
;
}
undoCloseById
(
aClosedId
aIncludePrivate
)
{
return
SessionStoreInternal
.
undoCloseById
(
aClosedId
aIncludePrivate
)
;
}
resetBrowserToLazyState
(
tab
)
{
return
SessionStoreInternal
.
resetBrowserToLazyState
(
tab
)
;
}
maybeExitCrashedState
(
browser
)
{
SessionStoreInternal
.
maybeExitCrashedState
(
browser
)
;
}
isBrowserInCrashedSet
(
browser
)
{
return
SessionStoreInternal
.
isBrowserInCrashedSet
(
browser
)
;
}
resetNextClosedId
(
)
{
SessionStoreInternal
.
_nextClosedId
=
0
;
}
ensureInitialized
(
window
)
{
if
(
SessionStoreInternal
.
_sessionInitialized
&
&
!
window
.
__SSi
)
{
SessionStoreInternal
.
onLoad
(
window
)
;
}
}
getCurrentEpoch
(
browser
)
{
return
SessionStoreInternal
.
getCurrentEpoch
(
browser
.
permanentKey
)
;
}
isFormatVersionCompatible
(
version
)
{
if
(
!
version
)
{
return
false
;
}
if
(
!
Array
.
isArray
(
version
)
)
{
return
false
;
}
if
(
version
[
0
]
!
=
"
sessionrestore
"
)
{
return
false
;
}
let
number
=
Number
.
parseFloat
(
version
[
1
]
)
;
if
(
Number
.
isNaN
(
number
)
)
{
return
false
;
}
return
number
<
=
FORMAT_VERSION
;
}
keepOnlyWorthSavingTabs
(
aState
)
{
let
closedWindowShouldRestore
=
null
;
for
(
let
i
=
aState
.
windows
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
let
win
=
aState
.
windows
[
i
]
;
for
(
let
j
=
win
.
tabs
.
length
-
1
;
j
>
=
0
;
j
-
-
)
{
let
tab
=
win
.
tabs
[
j
]
;
if
(
!
SessionStoreInternal
.
_shouldSaveTab
(
tab
)
)
{
win
.
tabs
.
splice
(
j
1
)
;
if
(
win
.
selected
>
j
)
{
win
.
selected
-
-
;
}
}
}
if
(
!
win
.
tabs
.
length
&
&
(
aState
.
windows
.
length
>
1
|
|
closedWindowShouldRestore
|
|
(
closedWindowShouldRestore
=
=
null
&
&
(
closedWindowShouldRestore
=
aState
.
_closedWindows
.
some
(
w
=
>
w
.
_shouldRestore
)
)
)
)
)
{
aState
.
windows
.
splice
(
i
1
)
;
if
(
aState
.
selectedWindow
>
i
)
{
aState
.
selectedWindow
-
-
;
}
}
}
}
async
prepareToChangeRemoteness
(
aTab
)
{
await
SessionStoreInternal
.
prepareToChangeRemoteness
(
aTab
)
;
}
finishTabRemotenessChange
(
aTab
aSwitchId
)
{
SessionStoreInternal
.
finishTabRemotenessChange
(
aTab
aSwitchId
)
;
}
}
;
Object
.
freeze
(
SessionStore
)
;
var
SessionStoreInternal
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIObserver
"
"
nsISupportsWeakReference
"
]
)
_globalState
:
new
GlobalState
(
)
_nextClosedId
:
0
_restoreCount
:
-
1
_browserSHistoryListener
:
new
WeakMap
(
)
_restoreListeners
:
new
WeakMap
(
)
_tabStateRestorePromises
:
new
WeakMap
(
)
_tabStateToRestore
:
new
WeakMap
(
)
_browserEpochs
:
new
WeakMap
(
)
_crashedBrowsers
:
new
WeakSet
(
)
_lastKnownFrameLoader
:
new
WeakMap
(
)
_closedTabs
:
new
WeakMap
(
)
_closedWindowTabs
:
new
WeakMap
(
)
_saveableClosedWindowData
:
new
WeakSet
(
)
_browserSetState
:
false
_sessionStartTime
:
Date
.
now
(
)
_windows
:
{
}
_nextWindowID
:
0
_closedWindows
:
[
]
_statesToRestore
:
{
}
_recentCrashes
:
0
_restoreLastWindow
:
false
_tabsRestoringCount
:
0
_log
:
null
_deferredInitialState
:
null
_closedObjectsChanged
:
false
_deferredInitialized
:
(
function
(
)
{
let
deferred
=
{
}
;
deferred
.
promise
=
new
Promise
(
(
resolve
reject
)
=
>
{
deferred
.
resolve
=
resolve
;
deferred
.
reject
=
reject
;
}
)
;
return
deferred
;
}
)
(
)
_sessionInitialized
:
false
_deferredAllWindowsRestored
:
(
function
(
)
{
let
deferred
=
{
}
;
deferred
.
promise
=
new
Promise
(
(
resolve
reject
)
=
>
{
deferred
.
resolve
=
resolve
;
deferred
.
reject
=
reject
;
}
)
;
return
deferred
;
}
)
(
)
get
promiseAllWindowsRestored
(
)
{
return
this
.
_deferredAllWindowsRestored
.
promise
;
}
_promiseReadyForInitialization
:
null
_windowBusyStates
:
new
WeakMap
(
)
get
promiseInitialized
(
)
{
return
this
.
_deferredInitialized
.
promise
;
}
get
canRestoreLastSession
(
)
{
return
LastSession
.
canRestore
;
}
set
canRestoreLastSession
(
val
)
{
if
(
!
val
)
{
LastSession
.
clear
(
)
;
}
}
get
lastClosedObjectType
(
)
{
if
(
this
.
_closedWindows
.
length
)
{
let
tabTimestamps
=
[
]
;
for
(
let
window
of
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
)
{
let
windowState
=
this
.
_windows
[
window
.
__SSi
]
;
if
(
windowState
&
&
windowState
.
_closedTabs
[
0
]
)
{
tabTimestamps
.
push
(
windowState
.
_closedTabs
[
0
]
.
closedAt
)
;
}
}
if
(
!
tabTimestamps
.
length
|
|
tabTimestamps
.
sort
(
(
a
b
)
=
>
b
-
a
)
[
0
]
<
this
.
_closedWindows
[
0
]
.
closedAt
)
{
return
"
window
"
;
}
}
return
"
tab
"
;
}
get
willAutoRestore
(
)
{
return
(
!
PrivateBrowsingUtils
.
permanentPrivateBrowsing
&
&
(
Services
.
prefs
.
getBoolPref
(
"
browser
.
sessionstore
.
resume_session_once
"
)
|
|
Services
.
prefs
.
getIntPref
(
"
browser
.
startup
.
page
"
)
=
=
BROWSER_STARTUP_RESUME_SESSION
)
)
;
}
init
(
)
{
if
(
this
.
_initialized
)
{
throw
new
Error
(
"
SessionStore
.
init
(
)
must
only
be
called
once
!
"
)
;
}
TelemetryTimestamps
.
add
(
"
sessionRestoreInitialized
"
)
;
OBSERVING
.
forEach
(
function
(
aTopic
)
{
Services
.
obs
.
addObserver
(
this
aTopic
true
)
;
}
this
)
;
this
.
_initPrefs
(
)
;
this
.
_initialized
=
true
;
Services
.
telemetry
.
getHistogramById
(
"
FX_SESSION_RESTORE_PRIVACY_LEVEL
"
)
.
add
(
Services
.
prefs
.
getIntPref
(
"
browser
.
sessionstore
.
privacy_level
"
)
)
;
}
initSession
(
)
{
TelemetryStopwatch
.
start
(
"
FX_SESSION_RESTORE_STARTUP_INIT_SESSION_MS
"
)
;
let
state
;
let
ss
=
lazy
.
SessionStartup
;
if
(
ss
.
willRestore
(
)
|
|
ss
.
sessionType
=
=
ss
.
DEFER_SESSION
)
{
state
=
ss
.
state
;
}
if
(
state
)
{
try
{
if
(
ss
.
sessionType
=
=
ss
.
DEFER_SESSION
)
{
let
[
iniState
remainingState
]
=
this
.
_prepDataForDeferredRestore
(
state
)
;
if
(
iniState
.
windows
.
length
)
{
iniState
.
cookies
=
remainingState
.
cookies
;
delete
remainingState
.
cookies
;
state
=
iniState
;
}
else
{
state
=
null
;
}
if
(
remainingState
.
windows
.
length
)
{
LastSession
.
setState
(
remainingState
)
;
}
Services
.
telemetry
.
keyedScalarAdd
(
"
browser
.
engagement
.
sessionrestore_interstitial
"
"
deferred_restore
"
1
)
;
}
else
{
LastSession
.
setState
(
state
.
lastSessionState
)
;
let
restoreAsCrashed
=
ss
.
willRestoreAsCrashed
(
)
;
if
(
restoreAsCrashed
)
{
this
.
_recentCrashes
=
(
(
state
.
session
&
&
state
.
session
.
recentCrashes
)
|
|
0
)
+
1
;
if
(
this
.
_needsRestorePage
(
state
this
.
_recentCrashes
)
)
{
let
url
=
"
about
:
sessionrestore
"
;
let
formdata
=
{
id
:
{
sessionData
:
state
}
url
}
;
let
entry
=
{
url
triggeringPrincipal_base64
:
lazy
.
E10SUtils
.
SERIALIZED_SYSTEMPRINCIPAL
}
;
state
=
{
windows
:
[
{
tabs
:
[
{
entries
:
[
entry
]
formdata
}
]
}
]
}
;
}
else
if
(
this
.
_hasSingleTabWithURL
(
state
.
windows
"
about
:
welcomeback
"
)
)
{
Services
.
telemetry
.
keyedScalarAdd
(
"
browser
.
engagement
.
sessionrestore_interstitial
"
"
shown_only_about_welcomeback
"
1
)
;
state
.
windows
[
0
]
.
tabs
[
0
]
.
entries
[
0
]
.
url
=
"
about
:
sessionrestore
"
;
state
.
windows
[
0
]
.
tabs
[
0
]
.
entries
[
0
]
.
triggeringPrincipal_base64
=
lazy
.
E10SUtils
.
SERIALIZED_SYSTEMPRINCIPAL
;
}
else
{
restoreAsCrashed
=
false
;
}
}
if
(
!
restoreAsCrashed
)
{
Services
.
telemetry
.
keyedScalarAdd
(
"
browser
.
engagement
.
sessionrestore_interstitial
"
"
autorestore
"
1
)
;
this
.
_removeExplicitlyClosedTabs
(
state
)
;
}
this
.
_updateSessionStartTime
(
state
)
;
delete
state
.
windows
[
0
]
.
hidden
;
delete
state
.
windows
[
0
]
.
isPopup
;
if
(
state
.
windows
[
0
]
.
sizemode
=
=
"
minimized
"
)
{
state
.
windows
[
0
]
.
sizemode
=
"
normal
"
;
}
state
.
windows
.
forEach
(
function
(
aWindow
)
{
delete
aWindow
.
__lastSessionWindowID
;
}
)
;
}
state
?
.
windows
?
.
forEach
(
win
=
>
delete
win
.
_maybeDontRestoreTabs
)
;
state
?
.
_closedWindows
?
.
forEach
(
win
=
>
delete
win
.
_maybeDontRestoreTabs
)
;
}
catch
(
ex
)
{
this
.
_log
.
error
(
"
The
session
file
is
invalid
:
"
+
ex
)
;
}
}
if
(
!
lazy
.
RunState
.
isQuitting
&
&
this
.
_prefBranch
.
getBoolPref
(
"
sessionstore
.
resume_session_once
"
)
)
{
this
.
_prefBranch
.
setBoolPref
(
"
sessionstore
.
resume_session_once
"
false
)
;
}
TelemetryStopwatch
.
finish
(
"
FX_SESSION_RESTORE_STARTUP_INIT_SESSION_MS
"
)
;
return
state
;
}
_removeExplicitlyClosedTabs
(
state
)
{
for
(
let
i
=
0
;
i
<
state
.
windows
.
length
;
)
{
const
winData
=
state
.
windows
[
i
]
;
if
(
winData
.
_maybeDontRestoreTabs
)
{
if
(
state
.
windows
.
length
=
=
1
)
{
let
j
=
0
;
winData
.
_lastClosedTabGroupCount
=
-
1
;
while
(
winData
.
tabs
.
length
)
{
const
tabState
=
winData
.
tabs
.
pop
(
)
;
let
activeIndex
=
(
tabState
.
index
|
|
tabState
.
entries
.
length
)
-
1
;
activeIndex
=
Math
.
min
(
activeIndex
tabState
.
entries
.
length
-
1
)
;
activeIndex
=
Math
.
max
(
activeIndex
0
)
;
let
title
=
"
"
;
if
(
activeIndex
in
tabState
.
entries
)
{
title
=
tabState
.
entries
[
activeIndex
]
.
title
|
|
tabState
.
entries
[
activeIndex
]
.
url
;
}
const
tabData
=
{
state
:
tabState
title
image
:
tabState
.
image
pos
:
j
+
+
closedAt
:
Date
.
now
(
)
closedInGroup
:
true
}
;
if
(
this
.
_shouldSaveTabState
(
tabState
)
)
{
this
.
saveClosedTabData
(
winData
winData
.
_closedTabs
tabData
)
;
}
}
}
else
{
if
(
winData
.
tabs
.
some
(
this
.
_shouldSaveTabState
)
)
{
winData
.
closedAt
=
Date
.
now
(
)
;
state
.
_closedWindows
.
unshift
(
winData
)
;
}
state
.
windows
.
splice
(
i
1
)
;
continue
;
}
}
i
+
+
;
}
}
_initPrefs
(
)
{
this
.
_prefBranch
=
Services
.
prefs
.
getBranch
(
"
browser
.
"
)
;
gDebuggingEnabled
=
this
.
_prefBranch
.
getBoolPref
(
"
sessionstore
.
debug
"
)
;
Services
.
prefs
.
addObserver
(
"
browser
.
sessionstore
.
debug
"
(
)
=
>
{
gDebuggingEnabled
=
this
.
_prefBranch
.
getBoolPref
(
"
sessionstore
.
debug
"
)
;
}
)
;
this
.
_log
=
console
.
createInstance
(
{
prefix
:
"
SessionStore
"
maxLogLevel
:
gDebuggingEnabled
?
"
Debug
"
:
"
Warn
"
}
)
;
this
.
_max_tabs_undo
=
this
.
_prefBranch
.
getIntPref
(
"
sessionstore
.
max_tabs_undo
"
)
;
this
.
_prefBranch
.
addObserver
(
"
sessionstore
.
max_tabs_undo
"
this
true
)
;
this
.
_max_windows_undo
=
this
.
_prefBranch
.
getIntPref
(
"
sessionstore
.
max_windows_undo
"
)
;
this
.
_prefBranch
.
addObserver
(
"
sessionstore
.
max_windows_undo
"
this
true
)
;
this
.
_restore_on_demand
=
this
.
_prefBranch
.
getBoolPref
(
"
sessionstore
.
restore_on_demand
"
)
;
this
.
_prefBranch
.
addObserver
(
"
sessionstore
.
restore_on_demand
"
this
true
)
;
gResistFingerprintingEnabled
=
Services
.
prefs
.
getBoolPref
(
"
privacy
.
resistFingerprinting
"
)
;
Services
.
prefs
.
addObserver
(
"
privacy
.
resistFingerprinting
"
this
)
;
this
.
_shistoryInParent
=
Services
.
appinfo
.
sessionHistoryInParent
;
}
_uninit
:
function
ssi_uninit
(
)
{
if
(
!
this
.
_initialized
)
{
throw
new
Error
(
"
SessionStore
is
not
initialized
.
"
)
;
}
lazy
.
RunState
.
setClosing
(
)
;
if
(
this
.
_sessionInitialized
)
{
lazy
.
SessionSaver
.
run
(
)
;
}
TabRestoreQueue
.
reset
(
)
;
lazy
.
SessionSaver
.
cancel
(
)
;
}
observe
:
function
ssi_observe
(
aSubject
aTopic
aData
)
{
switch
(
aTopic
)
{
case
"
browser
-
window
-
before
-
show
"
:
this
.
onBeforeBrowserWindowShown
(
aSubject
)
;
break
;
case
"
domwindowclosed
"
:
this
.
onClose
(
aSubject
)
.
then
(
(
)
=
>
{
this
.
_notifyOfClosedObjectsChange
(
)
;
}
)
;
if
(
gDebuggingEnabled
)
{
Services
.
obs
.
notifyObservers
(
null
NOTIFY_DOMWINDOWCLOSED_HANDLED
)
;
}
break
;
case
"
quit
-
application
-
granted
"
:
let
syncShutdown
=
aData
=
=
"
syncShutdown
"
;
this
.
onQuitApplicationGranted
(
syncShutdown
)
;
break
;
case
"
browser
-
lastwindow
-
close
-
granted
"
:
this
.
onLastWindowCloseGranted
(
)
;
break
;
case
"
quit
-
application
"
:
this
.
onQuitApplication
(
aData
)
;
break
;
case
"
browser
:
purge
-
session
-
history
"
:
this
.
onPurgeSessionHistory
(
)
;
this
.
_notifyOfClosedObjectsChange
(
)
;
break
;
case
"
browser
:
purge
-
session
-
history
-
for
-
domain
"
:
this
.
onPurgeDomainData
(
aData
)
;
this
.
_notifyOfClosedObjectsChange
(
)
;
break
;
case
"
nsPref
:
changed
"
:
this
.
onPrefChange
(
aData
)
;
this
.
_notifyOfClosedObjectsChange
(
)
;
break
;
case
"
idle
-
daily
"
:
this
.
onIdleDaily
(
)
;
this
.
_notifyOfClosedObjectsChange
(
)
;
break
;
case
"
clear
-
origin
-
attributes
-
data
"
:
let
userContextId
=
0
;
try
{
userContextId
=
JSON
.
parse
(
aData
)
.
userContextId
;
}
catch
(
e
)
{
}
if
(
userContextId
)
{
this
.
_forgetTabsWithUserContextId
(
userContextId
)
;
}
break
;
case
"
browsing
-
context
-
did
-
set
-
embedder
"
:
if
(
Services
.
appinfo
.
sessionHistoryInParent
)
{
if
(
aSubject
&
&
aSubject
=
=
=
aSubject
.
top
&
&
aSubject
.
isContent
&
&
aSubject
.
embedderElement
&
&
aSubject
.
embedderElement
.
permanentKey
)
{
let
permanentKey
=
aSubject
.
embedderElement
.
permanentKey
;
this
.
_browserSHistoryListener
.
get
(
permanentKey
)
?
.
unregister
(
)
;
this
.
getOrCreateSHistoryListener
(
permanentKey
aSubject
true
)
;
}
}
break
;
case
"
browsing
-
context
-
discarded
"
:
if
(
Services
.
appinfo
.
sessionHistoryInParent
)
{
let
permanentKey
=
aSubject
?
.
embedderElement
?
.
permanentKey
;
if
(
permanentKey
)
{
this
.
_browserSHistoryListener
.
get
(
permanentKey
)
?
.
unregister
(
)
;
}
}
break
;
case
"
browser
-
shutdown
-
tabstate
-
updated
"
:
if
(
Services
.
appinfo
.
sessionHistoryInParent
)
{
this
.
onFinalTabStateUpdateComplete
(
aSubject
)
;
}
this
.
_notifyOfClosedObjectsChange
(
)
;
break
;
}
}
getOrCreateSHistoryListener
(
permanentKey
browsingContext
collectImmediately
=
false
)
{
class
SHistoryListener
{
constructor
(
)
{
this
.
QueryInterface
=
ChromeUtils
.
generateQI
(
[
"
nsISHistoryListener
"
"
nsISupportsWeakReference
"
]
)
;
this
.
_browserId
=
browsingContext
.
browserId
;
this
.
_fromIndex
=
kNoIndex
;
}
unregister
(
)
{
let
bc
=
BrowsingContext
.
getCurrentTopByBrowserId
(
this
.
_browserId
)
;
bc
?
.
sessionHistory
?
.
removeSHistoryListener
(
this
)
;
SessionStoreInternal
.
_browserSHistoryListener
.
delete
(
permanentKey
)
;
}
collect
(
permanentKey
browsingContext
{
collectFull
=
true
writeToCache
=
false
}
)
{
if
(
!
collectFull
&
&
this
.
_fromIndex
=
=
=
kNoIndex
)
{
return
null
;
}
let
fromIndex
=
collectFull
?
-
1
:
this
.
_fromIndex
;
this
.
_fromIndex
=
kNoIndex
;
let
historychange
=
lazy
.
SessionHistory
.
collectFromParent
(
browsingContext
.
currentURI
?
.
spec
true
browsingContext
.
sessionHistory
fromIndex
)
;
if
(
writeToCache
)
{
let
win
=
browsingContext
.
embedderElement
?
.
ownerGlobal
|
|
browsingContext
.
currentWindowGlobal
?
.
browsingContext
?
.
window
;
SessionStoreInternal
.
onTabStateUpdate
(
permanentKey
win
{
data
:
{
historychange
}
}
)
;
}
return
historychange
;
}
collectFrom
(
index
)
{
if
(
this
.
_fromIndex
<
=
index
)
{
return
;
}
let
bc
=
BrowsingContext
.
getCurrentTopByBrowserId
(
this
.
_browserId
)
;
if
(
bc
?
.
embedderElement
?
.
frameLoader
)
{
this
.
_fromIndex
=
index
;
bc
.
embedderElement
.
frameLoader
.
requestSHistoryUpdate
(
)
;
}
}
OnHistoryNewEntry
(
newURI
oldIndex
)
{
this
.
collectFrom
(
oldIndex
=
=
-
1
?
oldIndex
:
oldIndex
-
1
)
;
}
OnHistoryGotoIndex
(
)
{
this
.
collectFrom
(
kLastIndex
)
;
}
OnHistoryPurge
(
)
{
this
.
collectFrom
(
-
1
)
;
}
OnHistoryReload
(
)
{
this
.
collectFrom
(
-
1
)
;
return
true
;
}
OnHistoryReplaceEntry
(
)
{
this
.
collectFrom
(
-
1
)
;
}
}
if
(
!
Services
.
appinfo
.
sessionHistoryInParent
)
{
throw
new
Error
(
"
This
function
should
only
be
used
with
SHIP
"
)
;
}
if
(
!
permanentKey
|
|
browsingContext
!
=
=
browsingContext
.
top
)
{
return
null
;
}
let
sessionHistory
=
browsingContext
.
sessionHistory
;
if
(
!
sessionHistory
)
{
return
null
;
}
let
listener
=
this
.
_browserSHistoryListener
.
get
(
permanentKey
)
;
if
(
listener
)
{
return
listener
;
}
listener
=
new
SHistoryListener
(
)
;
sessionHistory
.
addSHistoryListener
(
listener
)
;
this
.
_browserSHistoryListener
.
set
(
permanentKey
listener
)
;
let
isAboutBlank
=
browsingContext
.
currentURI
?
.
spec
=
=
=
"
about
:
blank
"
;
if
(
collectImmediately
&
&
(
!
isAboutBlank
|
|
sessionHistory
.
count
!
=
=
0
)
)
{
listener
.
collect
(
permanentKey
browsingContext
{
writeToCache
:
true
}
)
;
}
return
listener
;
}
onTabStateUpdate
(
permanentKey
win
update
)
{
if
(
this
.
_crashedBrowsers
.
has
(
permanentKey
)
)
{
return
;
}
lazy
.
TabState
.
update
(
permanentKey
update
)
;
this
.
saveStateDelayed
(
win
)
;
let
closedTab
=
this
.
_closedTabs
.
get
(
permanentKey
)
;
if
(
closedTab
)
{
lazy
.
TabState
.
copyFromCache
(
permanentKey
closedTab
.
tabData
.
state
)
;
}
}
onFinalTabStateUpdateComplete
(
browser
)
{
let
permanentKey
=
browser
.
permanentKey
;
if
(
this
.
_closedTabs
.
has
(
permanentKey
)
&
&
!
this
.
_crashedBrowsers
.
has
(
permanentKey
)
)
{
let
{
winData
closedTabs
tabData
}
=
this
.
_closedTabs
.
get
(
permanentKey
)
;
this
.
_closedTabs
.
delete
(
permanentKey
)
;
delete
tabData
.
permanentKey
;
let
shouldSave
=
this
.
_shouldSaveTabState
(
tabData
.
state
)
;
let
index
=
closedTabs
.
indexOf
(
tabData
)
;
if
(
shouldSave
&
&
index
=
=
-
1
)
{
this
.
saveClosedTabData
(
winData
closedTabs
tabData
)
;
}
else
if
(
!
shouldSave
&
&
index
>
-
1
)
{
this
.
removeClosedTabData
(
winData
closedTabs
index
)
;
}
}
lazy
.
TabStateFlusher
.
resolveAll
(
browser
)
;
this
.
_browserSHistoryListener
.
get
(
permanentKey
)
?
.
unregister
(
)
;
this
.
_restoreListeners
.
get
(
permanentKey
)
?
.
unregister
(
)
;
Services
.
obs
.
notifyObservers
(
browser
NOTIFY_BROWSER_SHUTDOWN_FLUSH
)
;
}
updateSessionStoreFromTablistener
(
browser
browsingContext
permanentKey
update
)
{
permanentKey
=
browser
?
.
permanentKey
?
?
permanentKey
;
if
(
!
permanentKey
)
{
return
;
}
if
(
!
this
.
isCurrentEpoch
(
permanentKey
update
.
epoch
)
)
{
return
;
}
if
(
browsingContext
.
isReplaced
)
{
return
;
}
if
(
Services
.
appinfo
.
sessionHistoryInParent
)
{
let
listener
=
this
.
getOrCreateSHistoryListener
(
permanentKey
browsingContext
)
;
if
(
listener
)
{
let
historychange
=
listener
.
collect
(
permanentKey
browsingContext
{
collectFull
:
!
!
update
.
sHistoryNeeded
writeToCache
:
false
}
)
;
if
(
historychange
)
{
update
.
data
.
historychange
=
historychange
;
}
}
}
let
win
=
browser
?
.
ownerGlobal
?
?
browsingContext
.
currentWindowGlobal
?
.
browsingContext
?
.
window
;
this
.
onTabStateUpdate
(
permanentKey
win
update
)
;
}
receiveMessage
(
aMessage
)
{
var
browser
=
aMessage
.
target
;
let
win
=
browser
.
ownerGlobal
;
let
tab
=
win
?
win
.
gBrowser
.
getTabForBrowser
(
browser
)
:
null
;
if
(
!
tab
&
&
!
NOTAB_MESSAGES
.
has
(
aMessage
.
name
)
)
{
throw
new
Error
(
received
unexpected
message
'
{
aMessage
.
name
}
'
+
from
a
browser
that
has
no
tab
or
window
)
;
}
let
data
=
aMessage
.
data
|
|
{
}
;
let
hasEpoch
=
data
.
hasOwnProperty
(
"
epoch
"
)
;
if
(
!
hasEpoch
&
&
!
NOEPOCH_MESSAGES
.
has
(
aMessage
.
name
)
)
{
throw
new
Error
(
received
message
'
{
aMessage
.
name
}
'
without
an
epoch
)
;
}
if
(
hasEpoch
&
&
!
this
.
isCurrentEpoch
(
browser
.
permanentKey
data
.
epoch
)
)
{
return
;
}
switch
(
aMessage
.
name
)
{
case
"
SessionStore
:
update
"
:
let
frameLoader
=
browser
.
frameLoader
|
|
this
.
_lastKnownFrameLoader
.
get
(
browser
.
permanentKey
)
;
if
(
frameLoader
!
=
aMessage
.
targetFrameLoader
)
{
return
;
}
this
.
onTabStateUpdate
(
browser
.
permanentKey
browser
.
ownerGlobal
data
)
;
if
(
data
.
isFinal
)
{
if
(
!
Services
.
appinfo
.
sessionHistoryInParent
)
{
this
.
onFinalTabStateUpdateComplete
(
browser
)
;
}
}
else
if
(
data
.
flushID
)
{
lazy
.
TabStateFlusher
.
resolve
(
browser
data
.
flushID
)
;
}
break
;
case
"
SessionStore
:
restoreHistoryComplete
"
:
this
.
_restoreHistoryComplete
(
browser
data
)
;
break
;
case
"
SessionStore
:
restoreTabContentStarted
"
:
this
.
_restoreTabContentStarted
(
browser
data
)
;
break
;
case
"
SessionStore
:
restoreTabContentComplete
"
:
this
.
_restoreTabContentComplete
(
browser
data
)
;
break
;
case
"
SessionStore
:
error
"
:
lazy
.
TabStateFlusher
.
resolveAll
(
browser
false
"
Received
error
from
the
content
process
"
)
;
break
;
default
:
throw
new
Error
(
received
unknown
message
'
{
aMessage
.
name
}
'
)
;
}
}
handleEvent
:
function
ssi_handleEvent
(
aEvent
)
{
let
win
=
aEvent
.
currentTarget
.
ownerGlobal
;
let
target
=
aEvent
.
originalTarget
;
switch
(
aEvent
.
type
)
{
case
"
TabOpen
"
:
this
.
onTabAdd
(
win
)
;
break
;
case
"
TabBrowserInserted
"
:
this
.
onTabBrowserInserted
(
win
target
)
;
break
;
case
"
TabClose
"
:
if
(
aEvent
.
detail
.
adoptedBy
)
{
this
.
onMoveToNewWindow
(
target
.
linkedBrowser
aEvent
.
detail
.
adoptedBy
.
linkedBrowser
)
;
}
else
{
this
.
onTabClose
(
win
target
)
;
}
this
.
onTabRemove
(
win
target
)
;
this
.
_notifyOfClosedObjectsChange
(
)
;
break
;
case
"
TabSelect
"
:
this
.
onTabSelect
(
win
)
;
break
;
case
"
TabShow
"
:
this
.
onTabShow
(
win
target
)
;
break
;
case
"
TabHide
"
:
this
.
onTabHide
(
win
target
)
;
break
;
case
"
TabPinned
"
:
case
"
TabUnpinned
"
:
case
"
SwapDocShells
"
:
this
.
saveStateDelayed
(
win
)
;
break
;
case
"
oop
-
browser
-
crashed
"
:
case
"
oop
-
browser
-
buildid
-
mismatch
"
:
if
(
aEvent
.
isTopFrame
)
{
this
.
onBrowserCrashed
(
target
)
;
}
break
;
case
"
XULFrameLoaderCreated
"
:
if
(
target
.
namespaceURI
=
=
XUL_NS
&
&
target
.
localName
=
=
"
browser
"
&
&
target
.
frameLoader
&
&
target
.
permanentKey
)
{
this
.
_lastKnownFrameLoader
.
set
(
target
.
permanentKey
target
.
frameLoader
)
;
this
.
resetEpoch
(
target
.
permanentKey
target
.
frameLoader
)
;
}
break
;
default
:
throw
new
Error
(
unhandled
event
{
aEvent
.
type
}
?
)
;
}
this
.
_clearRestoringWindows
(
)
;
}
_generateWindowID
:
function
ssi_generateWindowID
(
)
{
return
"
window
"
+
this
.
_nextWindowID
+
+
;
}
onLoad
(
aWindow
)
{
if
(
aWindow
&
&
aWindow
.
__SSi
&
&
this
.
_windows
[
aWindow
.
__SSi
]
)
{
return
;
}
if
(
lazy
.
RunState
.
isQuitting
)
{
return
;
}
aWindow
.
__SSi
=
this
.
_generateWindowID
(
)
;
let
mm
=
aWindow
.
getGroupMessageManager
(
"
browsers
"
)
;
MESSAGES
.
forEach
(
msg
=
>
{
let
listenWhenClosed
=
CLOSED_MESSAGES
.
has
(
msg
)
;
mm
.
addMessageListener
(
msg
this
listenWhenClosed
)
;
}
)
;
if
(
!
Services
.
appinfo
.
sessionHistoryInParent
)
{
mm
.
loadFrameScript
(
"
chrome
:
/
/
browser
/
content
/
content
-
sessionStore
.
js
"
true
true
)
;
}
this
.
_windows
[
aWindow
.
__SSi
]
=
{
tabs
:
[
]
selected
:
0
_closedTabs
:
[
]
_lastClosedTabGroupCount
:
-
1
busy
:
false
chromeFlags
:
aWindow
.
docShell
.
treeOwner
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIAppWindow
)
.
chromeFlags
}
;
if
(
PrivateBrowsingUtils
.
isWindowPrivate
(
aWindow
)
)
{
this
.
_windows
[
aWindow
.
__SSi
]
.
isPrivate
=
true
;
}
if
(
!
this
.
_isWindowLoaded
(
aWindow
)
)
{
this
.
_windows
[
aWindow
.
__SSi
]
.
_restoring
=
true
;
}
if
(
!
aWindow
.
toolbar
.
visible
)
{
this
.
_windows
[
aWindow
.
__SSi
]
.
isPopup
=
true
;
}
let
tabbrowser
=
aWindow
.
gBrowser
;
for
(
let
i
=
0
;
i
<
tabbrowser
.
tabs
.
length
;
i
+
+
)
{
this
.
onTabBrowserInserted
(
aWindow
tabbrowser
.
tabs
[
i
]
)
;
}
TAB_EVENTS
.
forEach
(
function
(
aEvent
)
{
tabbrowser
.
tabContainer
.
addEventListener
(
aEvent
this
true
)
;
}
this
)
;
aWindow
.
gBrowser
.
addEventListener
(
"
XULFrameLoaderCreated
"
this
)
;
}
initializeWindow
(
aWindow
aInitialState
=
null
)
{
let
isPrivateWindow
=
PrivateBrowsingUtils
.
isWindowPrivate
(
aWindow
)
;
if
(
lazy
.
RunState
.
isStopped
)
{
lazy
.
RunState
.
setRunning
(
)
;
if
(
aInitialState
)
{
lazy
.
SessionSaver
.
updateLastSaveTime
(
)
;
if
(
isPrivateWindow
)
{
this
.
_deferredInitialState
=
lazy
.
SessionStartup
.
state
;
Services
.
obs
.
notifyObservers
(
null
NOTIFY_WINDOWS_RESTORED
)
;
Services
.
obs
.
notifyObservers
(
null
"
sessionstore
-
one
-
or
-
no
-
tab
-
restored
"
)
;
this
.
_deferredAllWindowsRestored
.
resolve
(
)
;
}
else
{
TelemetryTimestamps
.
add
(
"
sessionRestoreRestoring
"
)
;
this
.
_restoreCount
=
aInitialState
.
windows
?
aInitialState
.
windows
.
length
:
0
;
this
.
_globalState
.
setFromState
(
aInitialState
)
;
lazy
.
SessionCookies
.
restore
(
aInitialState
.
cookies
|
|
[
]
)
;
let
overwrite
=
this
.
_isCmdLineEmpty
(
aWindow
aInitialState
)
;
let
options
=
{
firstWindow
:
true
overwriteTabs
:
overwrite
}
;
this
.
restoreWindows
(
aWindow
aInitialState
options
)
;
}
}
else
{
Services
.
obs
.
notifyObservers
(
null
NOTIFY_WINDOWS_RESTORED
)
;
Services
.
obs
.
notifyObservers
(
null
"
sessionstore
-
one
-
or
-
no
-
tab
-
restored
"
)
;
this
.
_deferredAllWindowsRestored
.
resolve
(
)
;
}
}
else
if
(
!
this
.
_isWindowLoaded
(
aWindow
)
)
{
return
;
}
else
if
(
this
.
_deferredInitialState
&
&
!
isPrivateWindow
&
&
aWindow
.
toolbar
.
visible
)
{
this
.
_globalState
.
setFromState
(
this
.
_deferredInitialState
)
;
this
.
_restoreCount
=
this
.
_deferredInitialState
.
windows
?
this
.
_deferredInitialState
.
windows
.
length
:
0
;
this
.
restoreWindows
(
aWindow
this
.
_deferredInitialState
{
firstWindow
:
true
}
)
;
this
.
_deferredInitialState
=
null
;
}
else
if
(
this
.
_restoreLastWindow
&
&
aWindow
.
toolbar
.
visible
&
&
this
.
_closedWindows
.
length
&
&
!
isPrivateWindow
)
{
let
closedWindowState
=
null
;
let
closedWindowIndex
;
for
(
let
i
=
0
;
i
<
this
.
_closedWindows
.
length
;
i
+
+
)
{
if
(
!
this
.
_closedWindows
[
i
]
.
isPopup
)
{
closedWindowState
=
this
.
_closedWindows
[
i
]
;
closedWindowIndex
=
i
;
break
;
}
}
if
(
closedWindowState
)
{
let
newWindowState
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
|
|
!
lazy
.
SessionStartup
.
willRestore
(
)
)
{
let
[
appTabsState
normalTabsState
]
=
this
.
_prepDataForDeferredRestore
(
{
windows
:
[
closedWindowState
]
}
)
;
if
(
appTabsState
.
windows
.
length
)
{
newWindowState
=
appTabsState
.
windows
[
0
]
;
delete
newWindowState
.
__lastSessionWindowID
;
}
if
(
!
normalTabsState
.
windows
.
length
)
{
this
.
_removeClosedWindow
(
closedWindowIndex
)
;
}
else
{
delete
normalTabsState
.
windows
[
0
]
.
__lastSessionWindowID
;
this
.
_closedWindows
[
closedWindowIndex
]
=
normalTabsState
.
windows
[
0
]
;
}
}
else
{
this
.
_removeClosedWindow
(
closedWindowIndex
)
;
newWindowState
=
closedWindowState
;
delete
newWindowState
.
hidden
;
}
if
(
newWindowState
)
{
this
.
_restoreCount
=
1
;
let
state
=
{
windows
:
[
newWindowState
]
}
;
let
options
=
{
overwriteTabs
:
this
.
_isCmdLineEmpty
(
aWindow
state
)
}
;
this
.
restoreWindow
(
aWindow
newWindowState
options
)
;
}
}
this
.
_prefBranch
.
setBoolPref
(
"
sessionstore
.
resume_session_once
"
false
)
;
}
if
(
this
.
_restoreLastWindow
&
&
aWindow
.
toolbar
.
visible
)
{
this
.
_restoreLastWindow
=
false
;
}
}
onBeforeBrowserWindowShown
(
aWindow
)
{
this
.
onLoad
(
aWindow
)
;
let
deferred
=
WINDOW_SHOWING_PROMISES
.
get
(
aWindow
)
;
if
(
deferred
)
{
deferred
.
resolve
(
aWindow
)
;
WINDOW_SHOWING_PROMISES
.
delete
(
aWindow
)
;
}
if
(
this
.
_sessionInitialized
)
{
this
.
initializeWindow
(
aWindow
)
;
return
;
}
if
(
!
this
.
_promiseReadyForInitialization
)
{
let
promise
=
new
Promise
(
resolve
=
>
{
Services
.
obs
.
addObserver
(
function
obs
(
subject
topic
)
{
if
(
aWindow
=
=
subject
)
{
Services
.
obs
.
removeObserver
(
obs
topic
)
;
resolve
(
)
;
}
}
"
browser
-
delayed
-
startup
-
finished
"
)
;
}
)
;
this
.
_promiseReadyForInitialization
=
Promise
.
all
(
[
promise
lazy
.
SessionStartup
.
onceInitialized
]
)
;
}
this
.
_promiseReadyForInitialization
.
then
(
(
)
=
>
{
if
(
aWindow
.
closed
)
{
return
;
}
if
(
this
.
_sessionInitialized
)
{
this
.
initializeWindow
(
aWindow
)
;
}
else
{
let
initialState
=
this
.
initSession
(
)
;
this
.
_sessionInitialized
=
true
;
if
(
initialState
)
{
Services
.
obs
.
notifyObservers
(
null
NOTIFY_RESTORING_ON_STARTUP
)
;
}
TelemetryStopwatch
.
start
(
"
FX_SESSION_RESTORE_STARTUP_ONLOAD_INITIAL_WINDOW_MS
"
)
;
this
.
initializeWindow
(
aWindow
initialState
)
;
TelemetryStopwatch
.
finish
(
"
FX_SESSION_RESTORE_STARTUP_ONLOAD_INITIAL_WINDOW_MS
"
)
;
this
.
_deferredInitialized
.
resolve
(
)
;
}
}
)
.
catch
(
console
.
error
)
;
}
onClose
:
function
ssi_onClose
(
aWindow
)
{
let
completionPromise
=
Promise
.
resolve
(
)
;
let
isFullyLoaded
=
this
.
_isWindowLoaded
(
aWindow
)
;
if
(
!
isFullyLoaded
)
{
if
(
!
aWindow
.
__SSi
)
{
aWindow
.
__SSi
=
this
.
_generateWindowID
(
)
;
}
let
restoreID
=
WINDOW_RESTORE_IDS
.
get
(
aWindow
)
;
this
.
_windows
[
aWindow
.
__SSi
]
=
this
.
_statesToRestore
[
restoreID
]
.
windows
[
0
]
;
delete
this
.
_statesToRestore
[
restoreID
]
;
WINDOW_RESTORE_IDS
.
delete
(
aWindow
)
;
}
if
(
!
aWindow
.
__SSi
|
|
!
this
.
_windows
[
aWindow
.
__SSi
]
)
{
return
completionPromise
;
}
let
event
=
aWindow
.
document
.
createEvent
(
"
Events
"
)
;
event
.
initEvent
(
"
SSWindowClosing
"
true
false
)
;
aWindow
.
dispatchEvent
(
event
)
;
if
(
this
.
windowToFocus
&
&
this
.
windowToFocus
=
=
aWindow
)
{
delete
this
.
windowToFocus
;
}
var
tabbrowser
=
aWindow
.
gBrowser
;
let
browsers
=
Array
.
from
(
tabbrowser
.
browsers
)
;
TAB_EVENTS
.
forEach
(
function
(
aEvent
)
{
tabbrowser
.
tabContainer
.
removeEventListener
(
aEvent
this
true
)
;
}
this
)
;
aWindow
.
gBrowser
.
removeEventListener
(
"
XULFrameLoaderCreated
"
this
)
;
let
winData
=
this
.
_windows
[
aWindow
.
__SSi
]
;
if
(
lazy
.
RunState
.
isRunning
)
{
let
tabMap
=
this
.
_collectWindowData
(
aWindow
)
;
for
(
let
[
tab
tabData
]
of
tabMap
)
{
let
permanentKey
=
tab
.
linkedBrowser
.
permanentKey
;
this
.
_closedWindowTabs
.
set
(
permanentKey
tabData
)
;
}
if
(
isFullyLoaded
)
{
winData
.
title
=
tabbrowser
.
selectedBrowser
.
contentTitle
|
|
tabbrowser
.
selectedTab
.
label
;
}
if
(
AppConstants
.
platform
!
=
"
macosx
"
)
{
winData
.
_shouldRestore
=
true
;
}
winData
.
closedAt
=
Date
.
now
(
)
;
delete
winData
.
busy
;
let
isLastWindow
=
this
.
isLastRestorableWindow
(
)
;
delete
this
.
_windows
[
aWindow
.
__SSi
]
;
this
.
_saveableClosedWindowData
.
add
(
winData
)
;
if
(
!
winData
.
isPrivate
)
{
lazy
.
PrivacyFilter
.
filterPrivateTabs
(
winData
)
;
this
.
maybeSaveClosedWindow
(
winData
isLastWindow
)
;
}
completionPromise
=
lazy
.
TabStateFlusher
.
flushWindow
(
aWindow
)
.
then
(
(
)
=
>
{
WINDOW_FLUSHING_PROMISES
.
delete
(
aWindow
)
;
for
(
let
browser
of
browsers
)
{
if
(
this
.
_closedWindowTabs
.
has
(
browser
.
permanentKey
)
)
{
let
tabData
=
this
.
_closedWindowTabs
.
get
(
browser
.
permanentKey
)
;
lazy
.
TabState
.
copyFromCache
(
browser
.
permanentKey
tabData
)
;
this
.
_closedWindowTabs
.
delete
(
browser
.
permanentKey
)
;
}
}
if
(
!
winData
.
isPrivate
)
{
lazy
.
PrivacyFilter
.
filterPrivateTabs
(
winData
)
;
this
.
maybeSaveClosedWindow
(
winData
isLastWindow
)
;
}
this
.
cleanUpWindow
(
aWindow
winData
browsers
)
;
this
.
saveStateDelayed
(
)
;
}
)
;
WINDOW_FLUSHING_PROMISES
.
set
(
aWindow
completionPromise
)
;
}
else
{
this
.
cleanUpWindow
(
aWindow
winData
browsers
)
;
}
for
(
let
i
=
0
;
i
<
tabbrowser
.
tabs
.
length
;
i
+
+
)
{
this
.
onTabRemove
(
aWindow
tabbrowser
.
tabs
[
i
]
true
)
;
}
return
completionPromise
;
}
cleanUpWindow
(
aWindow
winData
browsers
)
{
for
(
let
browser
of
browsers
)
{
lazy
.
TabStateFlusher
.
resolveAll
(
browser
)
;
}
DyingWindowCache
.
set
(
aWindow
winData
)
;
let
mm
=
aWindow
.
getGroupMessageManager
(
"
browsers
"
)
;
MESSAGES
.
forEach
(
msg
=
>
mm
.
removeMessageListener
(
msg
this
)
)
;
this
.
_saveableClosedWindowData
.
delete
(
winData
)
;
delete
aWindow
.
__SSi
;
}
maybeSaveClosedWindow
(
winData
isLastWindow
)
{
if
(
lazy
.
RunState
.
isRunning
&
&
this
.
_saveableClosedWindowData
.
has
(
winData
)
)
{
let
hasSaveableTabs
=
winData
.
tabs
.
some
(
this
.
_shouldSaveTabState
)
;
let
winIndex
=
this
.
_closedWindows
.
indexOf
(
winData
)
;
let
alreadyStored
=
winIndex
!
=
-
1
;
let
shouldStore
=
hasSaveableTabs
|
|
isLastWindow
;
if
(
shouldStore
&
&
!
alreadyStored
)
{
let
index
=
this
.
_closedWindows
.
findIndex
(
win
=
>
{
return
win
.
closedAt
<
winData
.
closedAt
;
}
)
;
if
(
index
=
=
-
1
)
{
index
=
this
.
_closedWindows
.
length
;
}
winData
.
closedId
=
this
.
_nextClosedId
+
+
;
this
.
_closedWindows
.
splice
(
index
0
winData
)
;
this
.
_capClosedWindows
(
)
;
this
.
_closedObjectsChanged
=
true
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
&
&
this
.
_closedWindows
.
length
=
=
1
)
{
let
window
=
Services
.
appShell
.
hiddenDOMWindow
;
let
historyMenu
=
window
.
document
.
getElementById
(
"
history
-
menu
"
)
;
let
evt
=
new
window
.
CustomEvent
(
"
popupshowing
"
{
bubbles
:
true
}
)
;
historyMenu
.
menupopup
.
dispatchEvent
(
evt
)
;
}
}
else
if
(
!
shouldStore
&
&
alreadyStored
)
{
this
.
_removeClosedWindow
(
winIndex
)
;
}
}
}
onQuitApplicationGranted
:
function
ssi_onQuitApplicationGranted
(
syncShutdown
=
false
)
{
let
index
=
0
;
for
(
let
window
of
this
.
_orderedBrowserWindows
)
{
this
.
_collectWindowData
(
window
)
;
this
.
_windows
[
window
.
__SSi
]
.
zIndex
=
+
+
index
;
}
let
progress
=
{
total
:
-
1
current
:
-
1
}
;
lazy
.
RunState
.
setQuitting
(
)
;
if
(
!
syncShutdown
)
{
lazy
.
AsyncShutdown
.
quitApplicationGranted
.
addBlocker
(
"
SessionStore
:
flushing
all
windows
"
(
)
=
>
{
let
promises
=
[
this
.
flushAllWindowsAsync
(
progress
)
]
;
const
observeTopic
=
topic
=
>
{
let
deferred
=
lazy
.
PromiseUtils
.
defer
(
)
;
const
observer
=
subject
=
>
{
subject
.
QueryInterface
(
Ci
.
nsIPropertyBag2
)
;
if
(
!
(
topic
=
=
"
ipc
:
content
-
shutdown
"
&
&
!
subject
.
get
(
"
abnormal
"
)
)
)
{
deferred
.
resolve
(
)
;
}
}
;
const
cleanup
=
(
)
=
>
{
try
{
Services
.
obs
.
removeObserver
(
observer
topic
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
"
SessionStore
:
exception
whilst
flushing
all
windows
:
"
+
ex
)
;
}
}
;
Services
.
obs
.
addObserver
(
observer
topic
)
;
deferred
.
promise
.
then
(
cleanup
cleanup
)
;
return
deferred
;
}
;
let
waitTimeMaxMs
=
Math
.
max
(
0
lazy
.
AsyncShutdown
.
DELAY_CRASH_MS
-
10000
)
;
let
defers
=
[
this
.
looseTimer
(
waitTimeMaxMs
)
observeTopic
(
"
oop
-
frameloader
-
crashed
"
)
observeTopic
(
"
ipc
:
content
-
shutdown
"
)
]
;
promises
.
push
(
.
.
.
defers
.
map
(
deferred
=
>
deferred
.
promise
)
)
;
return
Promise
.
race
(
promises
)
.
then
(
(
)
=
>
{
defers
.
forEach
(
deferred
=
>
deferred
.
reject
(
)
)
;
}
)
;
}
(
)
=
>
progress
)
;
}
else
{
}
}
async
flushAllWindowsAsync
(
progress
=
{
}
)
{
let
windowPromises
=
new
Map
(
WINDOW_FLUSHING_PROMISES
)
;
WINDOW_FLUSHING_PROMISES
.
clear
(
)
;
for
(
let
window
of
this
.
_browserWindows
)
{
windowPromises
.
set
(
window
lazy
.
TabStateFlusher
.
flushWindow
(
window
)
)
;
let
baseWin
=
window
.
docShell
.
treeOwner
.
QueryInterface
(
Ci
.
nsIBaseWindow
)
;
baseWin
.
visibility
=
false
;
}
progress
.
total
=
windowPromises
.
size
;
progress
.
current
=
0
;
for
(
let
[
win
promise
]
of
windowPromises
)
{
await
promise
;
if
(
win
.
__SSi
&
&
this
.
_windows
[
win
.
__SSi
]
)
{
this
.
_collectWindowData
(
win
)
;
}
progress
.
current
+
+
;
}
var
activeWindow
=
this
.
_getTopWindow
(
)
;
if
(
activeWindow
)
{
this
.
activeWindowSSiCache
=
activeWindow
.
__SSi
|
|
"
"
;
}
DirtyWindows
.
clear
(
)
;
}
onLastWindowCloseGranted
:
function
ssi_onLastWindowCloseGranted
(
)
{
this
.
_restoreLastWindow
=
true
;
}
onQuitApplication
:
function
ssi_onQuitApplication
(
aData
)
{
if
(
aData
=
=
"
restart
"
|
|
aData
=
=
"
os
-
restart
"
)
{
if
(
!
PrivateBrowsingUtils
.
permanentPrivateBrowsing
)
{
if
(
aData
=
=
"
os
-
restart
"
&
&
!
this
.
_prefBranch
.
getBoolPref
(
"
sessionstore
.
resume_session_once
"
)
)
{
this
.
_prefBranch
.
setBoolPref
(
"
sessionstore
.
resuming_after_os_restart
"
true
)
;
}
this
.
_prefBranch
.
setBoolPref
(
"
sessionstore
.
resume_session_once
"
true
)
;
}
Services
.
obs
.
removeObserver
(
this
"
browser
:
purge
-
session
-
history
"
)
;
}
if
(
aData
!
=
"
restart
"
)
{
LastSession
.
clear
(
true
)
;
}
this
.
_uninit
(
)
;
}
onPurgeSessionHistory
:
function
ssi_onPurgeSessionHistory
(
)
{
lazy
.
SessionFile
.
wipe
(
)
;
if
(
lazy
.
RunState
.
isQuitting
)
{
return
;
}
LastSession
.
clear
(
)
;
let
openWindows
=
{
}
;
for
(
let
window
of
this
.
_browserWindows
)
{
openWindows
[
window
.
__SSi
]
=
true
;
}
for
(
let
ix
in
this
.
_windows
)
{
if
(
ix
in
openWindows
)
{
if
(
this
.
_windows
[
ix
]
.
_closedTabs
.
length
)
{
this
.
_windows
[
ix
]
.
_closedTabs
=
[
]
;
this
.
_closedObjectsChanged
=
true
;
}
}
else
{
delete
this
.
_windows
[
ix
]
;
}
}
if
(
this
.
_closedWindows
.
length
)
{
this
.
_closedWindows
=
[
]
;
this
.
_closedObjectsChanged
=
true
;
}
var
win
=
this
.
_getTopWindow
(
)
;
if
(
win
)
{
win
.
setTimeout
(
(
)
=
>
lazy
.
SessionSaver
.
run
(
)
0
)
;
}
else
if
(
lazy
.
RunState
.
isRunning
)
{
lazy
.
SessionSaver
.
run
(
)
;
}
this
.
_clearRestoringWindows
(
)
;
this
.
_saveableClosedWindowData
=
new
WeakSet
(
)
;
}
onPurgeDomainData
:
function
ssi_onPurgeDomainData
(
aDomain
)
{
function
containsDomain
(
aEntry
)
{
let
host
;
try
{
host
=
Services
.
io
.
newURI
(
aEntry
.
url
)
.
host
;
}
catch
(
e
)
{
}
if
(
host
&
&
Services
.
eTLD
.
hasRootDomain
(
host
aDomain
)
)
{
return
true
;
}
return
aEntry
.
children
&
&
aEntry
.
children
.
some
(
containsDomain
this
)
;
}
for
(
let
ix
in
this
.
_windows
)
{
let
closedTabs
=
this
.
_windows
[
ix
]
.
_closedTabs
;
for
(
let
i
=
closedTabs
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
if
(
closedTabs
[
i
]
.
state
.
entries
.
some
(
containsDomain
this
)
)
{
closedTabs
.
splice
(
i
1
)
;
this
.
_closedObjectsChanged
=
true
;
}
}
}
for
(
let
ix
=
this
.
_closedWindows
.
length
-
1
;
ix
>
=
0
;
ix
-
-
)
{
let
closedTabs
=
this
.
_closedWindows
[
ix
]
.
_closedTabs
;
let
openTabs
=
this
.
_closedWindows
[
ix
]
.
tabs
;
let
openTabCount
=
openTabs
.
length
;
for
(
let
i
=
closedTabs
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
if
(
closedTabs
[
i
]
.
state
.
entries
.
some
(
containsDomain
this
)
)
{
closedTabs
.
splice
(
i
1
)
;
}
}
for
(
let
j
=
openTabs
.
length
-
1
;
j
>
=
0
;
j
-
-
)
{
if
(
openTabs
[
j
]
.
entries
.
some
(
containsDomain
this
)
)
{
openTabs
.
splice
(
j
1
)
;
if
(
this
.
_closedWindows
[
ix
]
.
selected
>
j
)
{
this
.
_closedWindows
[
ix
]
.
selected
-
-
;
}
}
}
if
(
!
openTabs
.
length
)
{
this
.
_closedWindows
.
splice
(
ix
1
)
;
}
else
if
(
openTabs
.
length
!
=
openTabCount
)
{
let
selectedTab
=
openTabs
[
this
.
_closedWindows
[
ix
]
.
selected
-
1
]
;
let
activeIndex
=
(
selectedTab
.
index
|
|
selectedTab
.
entries
.
length
)
-
1
;
if
(
activeIndex
>
=
selectedTab
.
entries
.
length
)
{
activeIndex
=
selectedTab
.
entries
.
length
-
1
;
}
this
.
_closedWindows
[
ix
]
.
title
=
selectedTab
.
entries
[
activeIndex
]
.
title
;
}
}
if
(
lazy
.
RunState
.
isRunning
)
{
lazy
.
SessionSaver
.
run
(
)
;
}
this
.
_clearRestoringWindows
(
)
;
}
onPrefChange
:
function
ssi_onPrefChange
(
aData
)
{
switch
(
aData
)
{
case
"
sessionstore
.
max_tabs_undo
"
:
this
.
_max_tabs_undo
=
this
.
_prefBranch
.
getIntPref
(
"
sessionstore
.
max_tabs_undo
"
)
;
for
(
let
ix
in
this
.
_windows
)
{
if
(
this
.
_windows
[
ix
]
.
_closedTabs
.
length
>
this
.
_max_tabs_undo
)
{
this
.
_windows
[
ix
]
.
_closedTabs
.
splice
(
this
.
_max_tabs_undo
this
.
_windows
[
ix
]
.
_closedTabs
.
length
)
;
this
.
_closedObjectsChanged
=
true
;
}
}
break
;
case
"
sessionstore
.
max_windows_undo
"
:
this
.
_max_windows_undo
=
this
.
_prefBranch
.
getIntPref
(
"
sessionstore
.
max_windows_undo
"
)
;
this
.
_capClosedWindows
(
)
;
break
;
case
"
privacy
.
resistFingerprinting
"
:
gResistFingerprintingEnabled
=
Services
.
prefs
.
getBoolPref
(
"
privacy
.
resistFingerprinting
"
)
;
break
;
case
"
sessionstore
.
restore_on_demand
"
:
this
.
_restore_on_demand
=
this
.
_prefBranch
.
getBoolPref
(
"
sessionstore
.
restore_on_demand
"
)
;
break
;
}
}
onTabAdd
:
function
ssi_onTabAdd
(
aWindow
)
{
this
.
saveStateDelayed
(
aWindow
)
;
}
onTabBrowserInserted
:
function
ssi_onTabBrowserInserted
(
aWindow
aTab
)
{
let
browser
=
aTab
.
linkedBrowser
;
browser
.
addEventListener
(
"
SwapDocShells
"
this
)
;
browser
.
addEventListener
(
"
oop
-
browser
-
crashed
"
this
)
;
browser
.
addEventListener
(
"
oop
-
browser
-
buildid
-
mismatch
"
this
)
;
if
(
browser
.
frameLoader
)
{
this
.
_lastKnownFrameLoader
.
set
(
browser
.
permanentKey
browser
.
frameLoader
)
;
}
if
(
TAB_LAZY_STATES
.
has
(
aTab
)
&
&
!
TAB_STATE_FOR_BROWSER
.
has
(
browser
)
&
&
lazy
.
TabStateCache
.
get
(
browser
.
permanentKey
)
)
{
let
tabState
=
lazy
.
TabState
.
clone
(
aTab
TAB_CUSTOM_VALUES
.
get
(
aTab
)
)
;
this
.
restoreTab
(
aTab
tabState
)
;
}
TAB_LAZY_STATES
.
delete
(
aTab
)
;
}
onTabRemove
:
function
ssi_onTabRemove
(
aWindow
aTab
aNoNotification
)
{
this
.
cleanUpRemovedBrowser
(
aTab
)
;
if
(
!
aNoNotification
)
{
this
.
saveStateDelayed
(
aWindow
)
;
}
}
onTabClose
:
function
ssi_onTabClose
(
aWindow
aTab
)
{
var
event
=
aWindow
.
document
.
createEvent
(
"
Events
"
)
;
event
.
initEvent
(
"
SSTabClosing
"
true
false
)
;
aTab
.
dispatchEvent
(
event
)
;
if
(
this
.
_max_tabs_undo
=
=
0
)
{
return
;
}
let
tabState
=
lazy
.
TabState
.
collect
(
aTab
TAB_CUSTOM_VALUES
.
get
(
aTab
)
)
;
this
.
maybeSaveClosedTab
(
aWindow
aTab
tabState
)
;
}
onMoveToNewWindow
(
aFromBrowser
aToBrowser
)
{
lazy
.
TabStateFlusher
.
flush
(
aFromBrowser
)
.
then
(
(
)
=
>
{
let
tabState
=
lazy
.
TabStateCache
.
get
(
aFromBrowser
.
permanentKey
)
;
lazy
.
TabStateCache
.
update
(
aToBrowser
.
permanentKey
tabState
)
;
}
)
;
}
maybeSaveClosedTab
(
aWindow
aTab
tabState
)
{
let
isPrivateWindow
=
PrivateBrowsingUtils
.
isWindowPrivate
(
aWindow
)
;
if
(
!
isPrivateWindow
&
&
tabState
.
isPrivate
)
{
return
;
}
if
(
aTab
=
=
aWindow
.
FirefoxViewHandler
.
tab
)
{
return
;
}
let
permanentKey
=
aTab
.
linkedBrowser
.
permanentKey
;
let
tabData
=
{
permanentKey
state
:
tabState
title
:
aTab
.
label
image
:
aWindow
.
gBrowser
.
getIcon
(
aTab
)
pos
:
aTab
.
_tPos
closedAt
:
Date
.
now
(
)
closedInGroup
:
aTab
.
_closedInGroup
}
;
let
winData
=
this
.
_windows
[
aWindow
.
__SSi
]
;
let
closedTabs
=
winData
.
_closedTabs
;
if
(
this
.
_shouldSaveTabState
(
tabState
)
)
{
this
.
saveClosedTabData
(
winData
closedTabs
tabData
)
;
}
this
.
_closedTabs
.
set
(
permanentKey
{
winData
closedTabs
tabData
}
)
;
}
resetBrowserToLazyState
(
aTab
)
{
const
gBrowser
=
aTab
.
ownerGlobal
.
gBrowser
;
let
browser
=
aTab
.
linkedBrowser
;
if
(
!
browser
.
isConnected
)
{
return
;
}
this
.
cleanUpRemovedBrowser
(
aTab
)
;
aTab
.
setAttribute
(
"
pending
"
"
true
"
)
;
this
.
_lastKnownFrameLoader
.
delete
(
browser
.
permanentKey
)
;
this
.
_crashedBrowsers
.
delete
(
browser
.
permanentKey
)
;
aTab
.
removeAttribute
(
"
crashed
"
)
;
gBrowser
.
tabContainer
.
updateTabIndicatorAttr
(
aTab
)
;
let
{
userTypedValue
=
null
userTypedClear
=
0
}
=
browser
;
let
hasStartedLoad
=
browser
.
didStartLoadSinceLastUserTyping
(
)
;
let
cacheState
=
lazy
.
TabStateCache
.
get
(
browser
.
permanentKey
)
;
let
shouldUpdateCacheState
=
userTypedValue
&
&
(
!
cacheState
|
|
(
hasStartedLoad
&
&
!
cacheState
.
userTypedValue
)
)
;
if
(
shouldUpdateCacheState
)
{
lazy
.
TabStateCache
.
update
(
browser
.
permanentKey
{
userTypedValue
userTypedClear
:
1
}
)
;
}
TAB_LAZY_STATES
.
set
(
aTab
{
url
:
browser
.
currentURI
.
spec
title
:
aTab
.
label
userTypedValue
userTypedClear
}
)
;
}
maybeExitCrashedState
(
aBrowser
)
{
let
uri
=
aBrowser
.
documentURI
;
if
(
uri
?
.
spec
?
.
startsWith
(
"
about
:
tabcrashed
"
)
)
{
this
.
_crashedBrowsers
.
delete
(
aBrowser
.
permanentKey
)
;
}
}
isBrowserInCrashedSet
(
aBrowser
)
{
if
(
gDebuggingEnabled
)
{
return
this
.
_crashedBrowsers
.
has
(
aBrowser
.
permanentKey
)
;
}
throw
new
Error
(
"
SessionStore
.
isBrowserInCrashedSet
(
)
should
only
be
called
in
debug
mode
!
"
)
;
}
cleanUpRemovedBrowser
(
aTab
)
{
let
browser
=
aTab
.
linkedBrowser
;
browser
.
removeEventListener
(
"
SwapDocShells
"
this
)
;
browser
.
removeEventListener
(
"
oop
-
browser
-
crashed
"
this
)
;
browser
.
removeEventListener
(
"
oop
-
browser
-
buildid
-
mismatch
"
this
)
;
let
previousState
=
TAB_STATE_FOR_BROWSER
.
get
(
browser
)
;
if
(
previousState
)
{
this
.
_resetTabRestoringState
(
aTab
)
;
if
(
previousState
=
=
TAB_STATE_RESTORING
)
{
this
.
restoreNextTab
(
)
;
}
}
}
saveClosedTabData
(
winData
closedTabs
tabData
)
{
let
index
=
closedTabs
.
findIndex
(
tab
=
>
{
return
tab
.
closedAt
<
tabData
.
closedAt
;
}
)
;
if
(
index
=
=
-
1
)
{
index
=
closedTabs
.
length
;
}
tabData
.
closedId
=
this
.
_nextClosedId
+
+
;
closedTabs
.
splice
(
index
0
tabData
)
;
this
.
_closedObjectsChanged
=
true
;
if
(
tabData
.
closedInGroup
)
{
if
(
winData
.
_lastClosedTabGroupCount
<
this
.
_max_tabs_undo
)
{
if
(
winData
.
_lastClosedTabGroupCount
<
0
)
{
winData
.
_lastClosedTabGroupCount
=
1
;
}
else
{
winData
.
_lastClosedTabGroupCount
+
+
;
}
}
}
else
{
winData
.
_lastClosedTabGroupCount
=
-
1
;
}
if
(
closedTabs
.
length
>
this
.
_max_tabs_undo
)
{
closedTabs
.
splice
(
this
.
_max_tabs_undo
closedTabs
.
length
)
;
}
}
removeClosedTabData
(
winData
closedTabs
index
)
{
let
[
closedTab
]
=
closedTabs
.
splice
(
index
1
)
;
this
.
_closedObjectsChanged
=
true
;
if
(
index
<
winData
.
_lastClosedTabGroupCount
)
{
winData
.
_lastClosedTabGroupCount
-
-
;
}
if
(
closedTab
.
permanentKey
)
{
this
.
_closedTabs
.
delete
(
closedTab
.
permanentKey
)
;
this
.
_closedWindowTabs
.
delete
(
closedTab
.
permanentKey
)
;
delete
closedTab
.
permanentKey
;
}
return
closedTab
;
}
onTabSelect
:
function
ssi_onTabSelect
(
aWindow
)
{
if
(
lazy
.
RunState
.
isRunning
)
{
this
.
_windows
[
aWindow
.
__SSi
]
.
selected
=
aWindow
.
gBrowser
.
tabContainer
.
selectedIndex
;
let
tab
=
aWindow
.
gBrowser
.
selectedTab
;
let
browser
=
tab
.
linkedBrowser
;
if
(
TAB_STATE_FOR_BROWSER
.
get
(
browser
)
=
=
TAB_STATE_NEEDS_RESTORE
)
{
if
(
lazy
.
TabCrashHandler
.
willShowCrashedTab
(
browser
)
)
{
this
.
enterCrashedState
(
browser
)
;
}
else
{
this
.
restoreTabContent
(
tab
)
;
}
}
}
}
onTabShow
:
function
ssi_onTabShow
(
aWindow
aTab
)
{
if
(
TAB_STATE_FOR_BROWSER
.
get
(
aTab
.
linkedBrowser
)
=
=
TAB_STATE_NEEDS_RESTORE
)
{
TabRestoreQueue
.
hiddenToVisible
(
aTab
)
;
this
.
restoreNextTab
(
)
;
}
this
.
saveStateDelayed
(
aWindow
)
;
}
onTabHide
:
function
ssi_onTabHide
(
aWindow
aTab
)
{
if
(
TAB_STATE_FOR_BROWSER
.
get
(
aTab
.
linkedBrowser
)
=
=
TAB_STATE_NEEDS_RESTORE
)
{
TabRestoreQueue
.
visibleToHidden
(
aTab
)
;
}
this
.
saveStateDelayed
(
aWindow
)
;
}
onBrowserCrashed
(
aBrowser
)
{
this
.
enterCrashedState
(
aBrowser
)
;
lazy
.
TabStateFlusher
.
resolveAll
(
aBrowser
)
;
}
enterCrashedState
(
browser
)
{
this
.
_crashedBrowsers
.
add
(
browser
.
permanentKey
)
;
let
win
=
browser
.
ownerGlobal
;
if
(
TAB_STATE_FOR_BROWSER
.
has
(
browser
)
)
{
let
tab
=
win
.
gBrowser
.
getTabForBrowser
(
browser
)
;
if
(
tab
)
{
this
.
_resetLocalTabRestoringState
(
tab
)
;
}
}
}
onIdleDaily
(
)
{
this
.
_cleanupOldData
(
[
this
.
_closedWindows
]
)
;
this
.
_cleanupOldData
(
this
.
_closedWindows
.
map
(
winData
=
>
winData
.
_closedTabs
)
)
;
this
.
_cleanupOldData
(
Object
.
keys
(
this
.
_windows
)
.
map
(
key
=
>
this
.
_windows
[
key
]
.
_closedTabs
)
)
;
this
.
_notifyOfClosedObjectsChange
(
)
;
}
_cleanupOldData
(
targets
)
{
const
TIME_TO_LIVE
=
this
.
_prefBranch
.
getIntPref
(
"
sessionstore
.
cleanup
.
forget_closed_after
"
)
;
const
now
=
Date
.
now
(
)
;
for
(
let
array
of
targets
)
{
for
(
let
i
=
array
.
length
-
1
;
i
>
=
0
;
-
-
i
)
{
let
data
=
array
[
i
]
;
data
.
closedAt
=
data
.
closedAt
|
|
now
;
if
(
now
-
data
.
closedAt
>
TIME_TO_LIVE
)
{
array
.
splice
(
i
1
)
;
this
.
_closedObjectsChanged
=
true
;
}
}
}
}
getBrowserState
:
function
ssi_getBrowserState
(
)
{
let
state
=
this
.
getCurrentState
(
)
;
delete
state
.
lastSessionState
;
delete
state
.
deferredInitialState
;
return
JSON
.
stringify
(
state
)
;
}
setBrowserState
:
function
ssi_setBrowserState
(
aState
)
{
this
.
_handleClosedWindows
(
)
;
try
{
var
state
=
JSON
.
parse
(
aState
)
;
}
catch
(
ex
)
{
}
if
(
!
state
)
{
throw
Components
.
Exception
(
"
Invalid
state
string
:
not
JSON
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
if
(
!
state
.
windows
)
{
throw
Components
.
Exception
(
"
No
windows
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
this
.
_browserSetState
=
true
;
this
.
_resetRestoringState
(
)
;
var
window
=
this
.
_getTopWindow
(
)
;
if
(
!
window
)
{
this
.
_restoreCount
=
1
;
this
.
_openWindowWithState
(
state
)
;
return
;
}
for
(
let
otherWin
of
this
.
_browserWindows
)
{
if
(
otherWin
!
=
window
)
{
otherWin
.
close
(
)
;
this
.
onClose
(
otherWin
)
;
}
}
if
(
this
.
_closedWindows
.
length
)
{
this
.
_closedWindows
=
[
]
;
this
.
_closedObjectsChanged
=
true
;
}
this
.
_restoreCount
=
state
.
windows
?
state
.
windows
.
length
:
0
;
this
.
_globalState
.
setFromState
(
state
)
;
lazy
.
SessionCookies
.
restore
(
state
.
cookies
|
|
[
]
)
;
this
.
restoreWindows
(
window
state
{
overwriteTabs
:
true
}
)
;
this
.
_notifyOfClosedObjectsChange
(
)
;
}
getWindowState
:
function
ssi_getWindowState
(
aWindow
)
{
if
(
"
__SSi
"
in
aWindow
)
{
return
Cu
.
cloneInto
(
this
.
_getWindowState
(
aWindow
)
{
}
)
;
}
if
(
DyingWindowCache
.
has
(
aWindow
)
)
{
let
data
=
DyingWindowCache
.
get
(
aWindow
)
;
return
Cu
.
cloneInto
(
{
windows
:
[
data
]
}
{
}
)
;
}
throw
Components
.
Exception
(
"
Window
is
not
tracked
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
setWindowState
:
function
ssi_setWindowState
(
aWindow
aState
aOverwrite
)
{
if
(
!
aWindow
.
__SSi
)
{
throw
Components
.
Exception
(
"
Window
is
not
tracked
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
this
.
restoreWindows
(
aWindow
aState
{
overwriteTabs
:
aOverwrite
}
)
;
this
.
_notifyOfClosedObjectsChange
(
)
;
}
getTabState
:
function
ssi_getTabState
(
aTab
)
{
if
(
!
aTab
|
|
!
aTab
.
ownerGlobal
)
{
throw
Components
.
Exception
(
"
Need
a
valid
tab
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
if
(
!
aTab
.
ownerGlobal
.
__SSi
)
{
throw
Components
.
Exception
(
"
Default
view
is
not
tracked
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
let
tabState
=
lazy
.
TabState
.
collect
(
aTab
TAB_CUSTOM_VALUES
.
get
(
aTab
)
)
;
return
JSON
.
stringify
(
tabState
)
;
}
setTabState
(
aTab
aState
)
{
let
tabState
=
aState
;
if
(
typeof
tabState
=
=
"
string
"
)
{
tabState
=
JSON
.
parse
(
aState
)
;
}
if
(
!
tabState
)
{
throw
Components
.
Exception
(
"
Invalid
state
string
:
not
JSON
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
if
(
typeof
tabState
!
=
"
object
"
)
{
throw
Components
.
Exception
(
"
Not
an
object
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
if
(
!
(
"
entries
"
in
tabState
)
)
{
throw
Components
.
Exception
(
"
Invalid
state
object
:
no
entries
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
let
window
=
aTab
.
ownerGlobal
;
if
(
!
window
|
|
!
(
"
__SSi
"
in
window
)
)
{
throw
Components
.
Exception
(
"
Window
is
not
tracked
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
if
(
TAB_STATE_FOR_BROWSER
.
has
(
aTab
.
linkedBrowser
)
)
{
this
.
_resetTabRestoringState
(
aTab
)
;
}
this
.
restoreTab
(
aTab
tabState
)
;
this
.
_notifyOfClosedObjectsChange
(
)
;
}
getInternalObjectState
(
obj
)
{
if
(
obj
.
__SSi
)
{
return
this
.
_windows
[
obj
.
__SSi
]
;
}
return
obj
.
loadURI
?
TAB_STATE_FOR_BROWSER
.
get
(
obj
)
:
TAB_CUSTOM_VALUES
.
get
(
obj
)
;
}
duplicateTab
:
function
ssi_duplicateTab
(
aWindow
aTab
aDelta
=
0
aRestoreImmediately
=
true
{
inBackground
index
}
=
{
}
)
{
if
(
!
aTab
|
|
!
aTab
.
ownerGlobal
)
{
throw
Components
.
Exception
(
"
Need
a
valid
tab
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
if
(
!
aTab
.
ownerGlobal
.
__SSi
)
{
throw
Components
.
Exception
(
"
Default
view
is
not
tracked
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
if
(
!
aWindow
.
gBrowser
)
{
throw
Components
.
Exception
(
"
Invalid
window
object
:
no
gBrowser
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
let
userContextId
=
aTab
.
getAttribute
(
"
usercontextid
"
)
;
let
tabOptions
=
{
userContextId
index
.
.
.
(
aTab
=
=
aWindow
.
gBrowser
.
selectedTab
?
{
relatedToCurrent
:
true
ownerTab
:
aTab
}
:
{
}
)
skipLoad
:
true
preferredRemoteType
:
aTab
.
linkedBrowser
.
remoteType
}
;
let
newTab
=
aWindow
.
gBrowser
.
addTrustedTab
(
null
tabOptions
)
;
let
uriObj
=
aTab
.
linkedBrowser
.
currentURI
;
if
(
!
uriObj
|
|
(
uriObj
&
&
!
uriObj
.
schemeIs
(
"
about
"
)
)
)
{
newTab
.
setAttribute
(
"
busy
"
"
true
"
)
;
}
aWindow
.
gBrowser
.
setDefaultIcon
(
newTab
uriObj
)
;
let
tabState
=
lazy
.
TabState
.
collect
(
aTab
TAB_CUSTOM_VALUES
.
get
(
aTab
)
)
;
let
browser
=
aTab
.
linkedBrowser
;
lazy
.
TabStateFlusher
.
flush
(
browser
)
.
then
(
(
)
=
>
{
if
(
newTab
.
closing
|
|
!
newTab
.
linkedBrowser
)
{
return
;
}
let
window
=
newTab
.
ownerGlobal
;
if
(
!
window
|
|
!
window
.
__SSi
)
{
return
;
}
let
options
=
{
includePrivateData
:
true
}
;
lazy
.
TabState
.
copyFromCache
(
browser
.
permanentKey
tabState
options
)
;
tabState
.
index
+
=
aDelta
;
tabState
.
index
=
Math
.
max
(
1
Math
.
min
(
tabState
.
index
tabState
.
entries
.
length
)
)
;
tabState
.
pinned
=
false
;
if
(
inBackground
=
=
=
false
)
{
aWindow
.
gBrowser
.
selectedTab
=
newTab
;
}
this
.
restoreTab
(
newTab
tabState
{
restoreImmediately
:
aRestoreImmediately
}
)
;
}
)
;
return
newTab
;
}
getLastClosedTabCount
(
aWindow
)
{
if
(
"
__SSi
"
in
aWindow
)
{
return
Math
.
min
(
Math
.
max
(
this
.
_windows
[
aWindow
.
__SSi
]
.
_lastClosedTabGroupCount
1
)
this
.
getClosedTabCount
(
aWindow
)
)
;
}
throw
(
Components
.
returnCode
=
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
resetLastClosedTabCount
(
aWindow
)
{
if
(
"
__SSi
"
in
aWindow
)
{
this
.
_windows
[
aWindow
.
__SSi
]
.
_lastClosedTabGroupCount
=
-
1
;
}
else
{
throw
(
Components
.
returnCode
=
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
}
getClosedTabCount
:
function
ssi_getClosedTabCount
(
aWindow
)
{
if
(
"
__SSi
"
in
aWindow
)
{
return
this
.
_windows
[
aWindow
.
__SSi
]
.
_closedTabs
.
length
;
}
if
(
!
DyingWindowCache
.
has
(
aWindow
)
)
{
throw
Components
.
Exception
(
"
Window
is
not
tracked
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
return
DyingWindowCache
.
get
(
aWindow
)
.
_closedTabs
.
length
;
}
getClosedTabData
:
function
ssi_getClosedTabData
(
aWindow
)
{
if
(
"
__SSi
"
in
aWindow
)
{
return
Cu
.
cloneInto
(
this
.
_windows
[
aWindow
.
__SSi
]
.
_closedTabs
{
}
)
;
}
if
(
!
DyingWindowCache
.
has
(
aWindow
)
)
{
throw
Components
.
Exception
(
"
Window
is
not
tracked
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
let
data
=
DyingWindowCache
.
get
(
aWindow
)
;
return
Cu
.
cloneInto
(
data
.
_closedTabs
{
}
)
;
}
undoCloseTab
:
function
ssi_undoCloseTab
(
aWindow
aIndex
)
{
if
(
!
aWindow
.
__SSi
)
{
throw
Components
.
Exception
(
"
Window
is
not
tracked
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
let
winData
=
this
.
_windows
[
aWindow
.
__SSi
]
;
aIndex
=
aIndex
|
|
0
;
if
(
!
(
aIndex
in
winData
.
_closedTabs
)
)
{
throw
Components
.
Exception
(
"
Invalid
index
:
not
in
the
closed
tabs
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
let
{
state
pos
}
=
this
.
removeClosedTabData
(
winData
winData
.
_closedTabs
aIndex
)
;
let
preferredRemoteType
=
lazy
.
E10SUtils
.
DEFAULT_REMOTE_TYPE
;
if
(
state
.
entries
?
.
length
)
{
let
activeIndex
=
(
state
.
index
|
|
state
.
entries
.
length
)
-
1
;
activeIndex
=
Math
.
min
(
activeIndex
state
.
entries
.
length
-
1
)
;
activeIndex
=
Math
.
max
(
activeIndex
0
)
;
preferredRemoteType
=
lazy
.
E10SUtils
.
getRemoteTypeForURI
(
state
.
entries
[
activeIndex
]
.
url
aWindow
.
gMultiProcessBrowser
aWindow
.
gFissionBrowser
lazy
.
E10SUtils
.
DEFAULT_REMOTE_TYPE
null
lazy
.
E10SUtils
.
predictOriginAttributes
(
{
window
:
aWindow
userContextId
:
state
.
userContextId
}
)
)
;
}
let
tabbrowser
=
aWindow
.
gBrowser
;
let
tab
=
(
tabbrowser
.
selectedTab
=
tabbrowser
.
addTrustedTab
(
null
{
index
:
pos
pinned
:
state
.
pinned
userContextId
:
state
.
userContextId
skipLoad
:
true
preferredRemoteType
}
)
)
;
this
.
restoreTab
(
tab
state
)
;
this
.
_notifyOfClosedObjectsChange
(
)
;
return
tab
;
}
forgetClosedTab
:
function
ssi_forgetClosedTab
(
aWindow
aIndex
)
{
if
(
!
aWindow
.
__SSi
)
{
throw
Components
.
Exception
(
"
Window
is
not
tracked
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
let
winData
=
this
.
_windows
[
aWindow
.
__SSi
]
;
aIndex
=
aIndex
|
|
0
;
if
(
!
(
aIndex
in
winData
.
_closedTabs
)
)
{
throw
Components
.
Exception
(
"
Invalid
index
:
not
in
the
closed
tabs
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
this
.
removeClosedTabData
(
winData
winData
.
_closedTabs
aIndex
)
;
this
.
_notifyOfClosedObjectsChange
(
)
;
}
getClosedWindowCount
:
function
ssi_getClosedWindowCount
(
)
{
return
this
.
_closedWindows
.
length
;
}
getClosedWindowData
:
function
ssi_getClosedWindowData
(
)
{
return
Cu
.
cloneInto
(
this
.
_closedWindows
{
}
)
;
}
maybeDontRestoreTabs
(
aWindow
)
{
this
.
_windows
[
aWindow
.
__SSi
]
.
_maybeDontRestoreTabs
=
true
;
}
isLastRestorableWindow
(
)
{
return
(
Object
.
values
(
this
.
_windows
)
.
filter
(
winData
=
>
!
winData
.
isPrivate
)
.
length
=
=
1
&
&
!
this
.
_closedWindows
.
some
(
win
=
>
win
.
_shouldRestore
|
|
false
)
)
;
}
undoCloseWindow
:
function
ssi_undoCloseWindow
(
aIndex
)
{
if
(
!
(
aIndex
in
this
.
_closedWindows
)
)
{
throw
Components
.
Exception
(
"
Invalid
index
:
not
in
the
closed
windows
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
let
state
=
{
windows
:
this
.
_removeClosedWindow
(
aIndex
)
}
;
delete
state
.
windows
[
0
]
.
closedAt
;
let
window
=
this
.
_openWindowWithState
(
state
)
;
this
.
windowToFocus
=
window
;
WINDOW_SHOWING_PROMISES
.
get
(
window
)
.
promise
.
then
(
win
=
>
this
.
restoreWindows
(
win
state
{
overwriteTabs
:
true
}
)
)
;
this
.
_notifyOfClosedObjectsChange
(
)
;
return
window
;
}
forgetClosedWindow
:
function
ssi_forgetClosedWindow
(
aIndex
)
{
aIndex
=
aIndex
|
|
0
;
if
(
!
(
aIndex
in
this
.
_closedWindows
)
)
{
throw
Components
.
Exception
(
"
Invalid
index
:
not
in
the
closed
windows
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
let
winData
=
this
.
_closedWindows
[
aIndex
]
;
this
.
_removeClosedWindow
(
aIndex
)
;
this
.
_saveableClosedWindowData
.
delete
(
winData
)
;
this
.
_notifyOfClosedObjectsChange
(
)
;
}
getCustomWindowValue
(
aWindow
aKey
)
{
if
(
"
__SSi
"
in
aWindow
)
{
let
data
=
this
.
_windows
[
aWindow
.
__SSi
]
.
extData
|
|
{
}
;
return
data
[
aKey
]
|
|
"
"
;
}
if
(
DyingWindowCache
.
has
(
aWindow
)
)
{
let
data
=
DyingWindowCache
.
get
(
aWindow
)
.
extData
|
|
{
}
;
return
data
[
aKey
]
|
|
"
"
;
}
throw
Components
.
Exception
(
"
Window
is
not
tracked
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
setCustomWindowValue
(
aWindow
aKey
aStringValue
)
{
if
(
typeof
aStringValue
!
=
"
string
"
)
{
throw
new
TypeError
(
"
setCustomWindowValue
only
accepts
string
values
"
)
;
}
if
(
!
(
"
__SSi
"
in
aWindow
)
)
{
throw
Components
.
Exception
(
"
Window
is
not
tracked
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
if
(
!
this
.
_windows
[
aWindow
.
__SSi
]
.
extData
)
{
this
.
_windows
[
aWindow
.
__SSi
]
.
extData
=
{
}
;
}
this
.
_windows
[
aWindow
.
__SSi
]
.
extData
[
aKey
]
=
aStringValue
;
this
.
saveStateDelayed
(
aWindow
)
;
}
deleteCustomWindowValue
(
aWindow
aKey
)
{
if
(
aWindow
.
__SSi
&
&
this
.
_windows
[
aWindow
.
__SSi
]
.
extData
&
&
this
.
_windows
[
aWindow
.
__SSi
]
.
extData
[
aKey
]
)
{
delete
this
.
_windows
[
aWindow
.
__SSi
]
.
extData
[
aKey
]
;
}
this
.
saveStateDelayed
(
aWindow
)
;
}
getCustomTabValue
(
aTab
aKey
)
{
return
(
TAB_CUSTOM_VALUES
.
get
(
aTab
)
|
|
{
}
)
[
aKey
]
|
|
"
"
;
}
setCustomTabValue
(
aTab
aKey
aStringValue
)
{
if
(
typeof
aStringValue
!
=
"
string
"
)
{
throw
new
TypeError
(
"
setCustomTabValue
only
accepts
string
values
"
)
;
}
if
(
!
TAB_CUSTOM_VALUES
.
has
(
aTab
)
)
{
TAB_CUSTOM_VALUES
.
set
(
aTab
{
}
)
;
}
TAB_CUSTOM_VALUES
.
get
(
aTab
)
[
aKey
]
=
aStringValue
;
this
.
saveStateDelayed
(
aTab
.
ownerGlobal
)
;
}
deleteCustomTabValue
(
aTab
aKey
)
{
let
state
=
TAB_CUSTOM_VALUES
.
get
(
aTab
)
;
if
(
state
&
&
aKey
in
state
)
{
delete
state
[
aKey
]
;
this
.
saveStateDelayed
(
aTab
.
ownerGlobal
)
;
}
}
getLazyTabValue
(
aTab
aKey
)
{
return
(
TAB_LAZY_STATES
.
get
(
aTab
)
|
|
{
}
)
[
aKey
]
;
}
getCustomGlobalValue
(
aKey
)
{
return
this
.
_globalState
.
get
(
aKey
)
;
}
setCustomGlobalValue
(
aKey
aStringValue
)
{
if
(
typeof
aStringValue
!
=
"
string
"
)
{
throw
new
TypeError
(
"
setCustomGlobalValue
only
accepts
string
values
"
)
;
}
this
.
_globalState
.
set
(
aKey
aStringValue
)
;
this
.
saveStateDelayed
(
)
;
}
deleteCustomGlobalValue
(
aKey
)
{
this
.
_globalState
.
delete
(
aKey
)
;
this
.
saveStateDelayed
(
)
;
}
persistTabAttribute
:
function
ssi_persistTabAttribute
(
aName
)
{
if
(
lazy
.
TabAttributes
.
persist
(
aName
)
)
{
this
.
saveStateDelayed
(
)
;
}
}
undoCloseById
(
aClosedId
aIncludePrivate
=
true
)
{
for
(
let
i
=
0
l
=
this
.
_closedWindows
.
length
;
i
<
l
;
i
+
+
)
{
if
(
this
.
_closedWindows
[
i
]
.
closedId
=
=
aClosedId
)
{
return
this
.
undoCloseWindow
(
i
)
;
}
}
for
(
let
window
of
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
)
{
if
(
!
aIncludePrivate
&
&
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
{
continue
;
}
let
windowState
=
this
.
_windows
[
window
.
__SSi
]
;
if
(
windowState
)
{
for
(
let
j
=
0
l
=
windowState
.
_closedTabs
.
length
;
j
<
l
;
j
+
+
)
{
if
(
windowState
.
_closedTabs
[
j
]
.
closedId
=
=
aClosedId
)
{
return
this
.
undoCloseTab
(
window
j
)
;
}
}
}
}
return
undefined
;
}
updateTabLabelAndIcon
(
tab
tabData
=
null
)
{
if
(
tab
.
hasAttribute
(
"
customizemode
"
)
)
{
return
;
}
let
browser
=
tab
.
linkedBrowser
;
let
win
=
browser
.
ownerGlobal
;
if
(
!
tabData
)
{
tabData
=
lazy
.
TabState
.
collect
(
tab
TAB_CUSTOM_VALUES
.
get
(
tab
)
)
;
if
(
!
tabData
)
{
throw
new
Error
(
"
tabData
not
found
for
given
tab
"
)
;
}
}
let
activePageData
=
tabData
.
entries
[
tabData
.
index
-
1
]
|
|
null
;
if
(
activePageData
)
{
if
(
activePageData
.
title
&
&
activePageData
.
title
!
=
activePageData
.
url
)
{
win
.
gBrowser
.
setInitialTabTitle
(
tab
activePageData
.
title
{
isContentTitle
:
true
}
)
;
}
else
{
win
.
gBrowser
.
setInitialTabTitle
(
tab
activePageData
.
url
)
;
}
}
if
(
"
image
"
in
tabData
)
{
if
(
!
activePageData
|
|
(
activePageData
&
&
activePageData
.
url
!
=
"
about
:
blank
"
)
)
{
win
.
gBrowser
.
setIcon
(
tab
tabData
.
image
undefined
tabData
.
iconLoadingPrincipal
)
;
}
lazy
.
TabStateCache
.
update
(
browser
.
permanentKey
{
image
:
null
iconLoadingPrincipal
:
null
}
)
;
}
}
_forgetTabsWithUserContextId
(
userContextId
)
{
for
(
let
window
of
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
)
{
let
windowState
=
this
.
_windows
[
window
.
__SSi
]
;
if
(
windowState
)
{
let
indexes
=
[
]
;
windowState
.
_closedTabs
.
forEach
(
(
closedTab
index
)
=
>
{
if
(
closedTab
.
state
.
userContextId
=
=
userContextId
)
{
indexes
.
push
(
index
)
;
}
}
)
;
for
(
let
index
of
indexes
.
reverse
(
)
)
{
this
.
removeClosedTabData
(
windowState
windowState
.
_closedTabs
index
)
;
}
}
}
this
.
_notifyOfClosedObjectsChange
(
)
;
}
restoreLastSession
:
function
ssi_restoreLastSession
(
)
{
if
(
!
this
.
canRestoreLastSession
)
{
throw
Components
.
Exception
(
"
Last
session
can
not
be
restored
"
)
;
}
Services
.
obs
.
notifyObservers
(
null
NOTIFY_INITIATING_MANUAL_RESTORE
)
;
let
windows
=
{
}
;
for
(
let
window
of
this
.
_browserWindows
)
{
if
(
window
.
__SS_lastSessionWindowID
)
{
windows
[
window
.
__SS_lastSessionWindowID
]
=
window
;
}
}
let
lastSessionState
=
LastSession
.
getState
(
)
;
if
(
!
lastSessionState
.
windows
.
length
)
{
throw
Components
.
Exception
(
"
lastSessionState
has
no
windows
"
Cr
.
NS_ERROR_UNEXPECTED
)
;
}
this
.
_restoreCount
=
lastSessionState
.
windows
.
length
;
this
.
_browserSetState
=
true
;
let
lastWindow
=
this
.
_getTopWindow
(
)
;
let
canUseLastWindow
=
lastWindow
&
&
!
lastWindow
.
__SS_lastSessionWindowID
;
this
.
_globalState
.
setFromState
(
lastSessionState
)
;
let
openWindows
=
[
]
;
let
windowsToOpen
=
[
]
;
lazy
.
SessionCookies
.
restore
(
lastSessionState
.
cookies
|
|
[
]
)
;
for
(
let
i
=
0
;
i
<
lastSessionState
.
windows
.
length
;
i
+
+
)
{
let
winState
=
lastSessionState
.
windows
[
i
]
;
let
lastSessionWindowID
=
winState
.
__lastSessionWindowID
;
delete
winState
.
__lastSessionWindowID
;
let
windowToUse
=
windows
[
lastSessionWindowID
]
;
if
(
!
windowToUse
&
&
canUseLastWindow
)
{
windowToUse
=
lastWindow
;
canUseLastWindow
=
false
;
}
let
[
canUseWindow
canOverwriteTabs
]
=
this
.
_prepWindowToRestoreInto
(
windowToUse
)
;
if
(
canUseWindow
)
{
if
(
winState
.
_closedTabs
&
&
winState
.
_closedTabs
.
length
)
{
let
curWinState
=
this
.
_windows
[
windowToUse
.
__SSi
]
;
curWinState
.
_closedTabs
=
curWinState
.
_closedTabs
.
concat
(
winState
.
_closedTabs
)
;
curWinState
.
_closedTabs
.
splice
(
this
.
_max_tabs_undo
curWinState
.
_closedTabs
.
length
)
;
}
this
.
_updateWindowRestoreState
(
windowToUse
{
windows
:
[
winState
]
options
:
{
overwriteTabs
:
canOverwriteTabs
}
}
)
;
openWindows
.
push
(
windowToUse
)
;
}
else
{
windowsToOpen
.
push
(
winState
)
;
}
}
this
.
_openWindows
(
{
windows
:
windowsToOpen
}
)
.
then
(
openedWindows
=
>
this
.
_restoreWindowsInReversedZOrder
(
openWindows
.
concat
(
openedWindows
)
)
)
;
if
(
lastSessionState
.
_closedWindows
)
{
this
.
_closedWindows
=
this
.
_closedWindows
.
concat
(
lastSessionState
.
_closedWindows
)
;
this
.
_capClosedWindows
(
)
;
this
.
_closedObjectsChanged
=
true
;
}
lazy
.
DevToolsShim
.
restoreDevToolsSession
(
lastSessionState
)
;
this
.
_recentCrashes
=
(
lastSessionState
.
session
&
&
lastSessionState
.
session
.
recentCrashes
)
|
|
0
;
this
.
_updateSessionStartTime
(
lastSessionState
)
;
LastSession
.
clear
(
)
;
this
.
_notifyOfClosedObjectsChange
(
)
;
}
reviveCrashedTab
(
aTab
)
{
if
(
!
aTab
)
{
throw
new
Error
(
"
SessionStore
.
reviveCrashedTab
expected
a
tab
but
got
null
.
"
)
;
}
const
gBrowser
=
aTab
.
ownerGlobal
.
gBrowser
;
let
browser
=
aTab
.
linkedBrowser
;
if
(
!
this
.
_crashedBrowsers
.
has
(
browser
.
permanentKey
)
)
{
return
;
}
if
(
browser
.
isRemoteBrowser
)
{
throw
new
Error
(
"
SessionStore
.
reviveCrashedTab
:
"
+
"
Somehow
a
crashed
browser
is
still
remote
.
"
)
;
}
aTab
.
removeAttribute
(
"
crashed
"
)
;
gBrowser
.
tabContainer
.
updateTabIndicatorAttr
(
aTab
)
;
browser
.
loadURI
(
"
about
:
blank
"
{
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
createNullPrincipal
(
{
userContextId
:
aTab
.
userContextId
}
)
remoteTypeOverride
:
lazy
.
E10SUtils
.
NOT_REMOTE
}
)
;
let
data
=
lazy
.
TabState
.
collect
(
aTab
TAB_CUSTOM_VALUES
.
get
(
aTab
)
)
;
this
.
restoreTab
(
aTab
data
{
forceOnDemand
:
true
}
)
;
}
reviveAllCrashedTabs
(
)
{
for
(
let
window
of
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
)
{
for
(
let
tab
of
window
.
gBrowser
.
tabs
)
{
this
.
reviveCrashedTab
(
tab
)
;
}
}
}
getSessionHistory
(
tab
updatedCallback
)
{
if
(
updatedCallback
)
{
lazy
.
TabStateFlusher
.
flush
(
tab
.
linkedBrowser
)
.
then
(
(
)
=
>
{
let
sessionHistory
=
this
.
getSessionHistory
(
tab
)
;
if
(
sessionHistory
)
{
updatedCallback
(
sessionHistory
)
;
}
}
)
;
}
if
(
tab
.
linkedBrowser
)
{
let
tabState
=
lazy
.
TabState
.
collect
(
tab
TAB_CUSTOM_VALUES
.
get
(
tab
)
)
;
return
{
index
:
tabState
.
index
-
1
entries
:
tabState
.
entries
}
;
}
return
null
;
}
_prepWindowToRestoreInto
:
function
ssi_prepWindowToRestoreInto
(
aWindow
)
{
if
(
!
aWindow
)
{
return
[
false
false
]
;
}
let
canOverwriteTabs
=
false
;
let
homePages
=
[
"
about
:
blank
"
]
;
let
removableTabs
=
[
]
;
let
tabbrowser
=
aWindow
.
gBrowser
;
let
startupPref
=
this
.
_prefBranch
.
getIntPref
(
"
startup
.
page
"
)
;
if
(
startupPref
=
=
1
)
{
homePages
=
homePages
.
concat
(
lazy
.
HomePage
.
get
(
aWindow
)
.
split
(
"
|
"
)
)
;
}
for
(
let
i
=
tabbrowser
.
_numPinnedTabs
;
i
<
tabbrowser
.
tabs
.
length
;
i
+
+
)
{
let
tab
=
tabbrowser
.
tabs
[
i
]
;
if
(
homePages
.
includes
(
tab
.
linkedBrowser
.
currentURI
.
spec
)
)
{
removableTabs
.
push
(
tab
)
;
}
}
if
(
tabbrowser
.
tabs
.
length
>
tabbrowser
.
visibleTabs
.
length
&
&
tabbrowser
.
visibleTabs
.
length
=
=
=
removableTabs
.
length
)
{
removableTabs
.
shift
(
)
;
}
if
(
tabbrowser
.
tabs
.
length
=
=
removableTabs
.
length
)
{
canOverwriteTabs
=
true
;
}
else
{
for
(
let
i
=
removableTabs
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
tabbrowser
.
removeTab
(
removableTabs
.
pop
(
)
{
animate
:
false
}
)
;
}
}
return
[
true
canOverwriteTabs
]
;
}
_updateWindowFeatures
:
function
ssi_updateWindowFeatures
(
aWindow
)
{
var
winData
=
this
.
_windows
[
aWindow
.
__SSi
]
;
WINDOW_ATTRIBUTES
.
forEach
(
function
(
aAttr
)
{
winData
[
aAttr
]
=
this
.
_getWindowDimension
(
aWindow
aAttr
)
;
}
this
)
;
if
(
winData
.
sizemode
!
=
"
minimized
"
)
{
winData
.
sizemodeBeforeMinimized
=
winData
.
sizemode
;
}
var
hidden
=
WINDOW_HIDEABLE_FEATURES
.
filter
(
function
(
aItem
)
{
return
aWindow
[
aItem
]
&
&
!
aWindow
[
aItem
]
.
visible
;
}
)
;
if
(
hidden
.
length
)
{
winData
.
hidden
=
hidden
.
join
(
"
"
)
;
}
else
if
(
winData
.
hidden
)
{
delete
winData
.
hidden
;
}
let
sidebarBox
=
aWindow
.
document
.
getElementById
(
"
sidebar
-
box
"
)
;
let
sidebar
=
sidebarBox
.
getAttribute
(
"
sidebarcommand
"
)
;
if
(
sidebar
&
&
sidebarBox
.
getAttribute
(
"
checked
"
)
=
=
"
true
"
)
{
winData
.
sidebar
=
sidebar
;
}
else
if
(
winData
.
sidebar
)
{
delete
winData
.
sidebar
;
}
let
workspaceID
=
aWindow
.
getWorkspaceID
(
)
;
if
(
workspaceID
)
{
winData
.
workspaceID
=
workspaceID
;
}
}
getCurrentState
(
aUpdateAll
)
{
this
.
_handleClosedWindows
(
)
.
then
(
(
)
=
>
{
this
.
_notifyOfClosedObjectsChange
(
)
;
}
)
;
var
activeWindow
=
this
.
_getTopWindow
(
)
;
TelemetryStopwatch
.
start
(
"
FX_SESSION_RESTORE_COLLECT_ALL_WINDOWS_DATA_MS
"
)
;
if
(
lazy
.
RunState
.
isRunning
)
{
let
index
=
0
;
for
(
let
window
of
this
.
_orderedBrowserWindows
)
{
if
(
!
this
.
_isWindowLoaded
(
window
)
)
{
continue
;
}
if
(
aUpdateAll
|
|
DirtyWindows
.
has
(
window
)
|
|
window
=
=
activeWindow
)
{
this
.
_collectWindowData
(
window
)
;
}
else
{
this
.
_updateWindowFeatures
(
window
)
;
}
this
.
_windows
[
window
.
__SSi
]
.
zIndex
=
+
+
index
;
}
DirtyWindows
.
clear
(
)
;
}
TelemetryStopwatch
.
finish
(
"
FX_SESSION_RESTORE_COLLECT_ALL_WINDOWS_DATA_MS
"
)
;
var
total
=
[
]
;
var
ids
=
[
]
;
var
nonPopupCount
=
0
;
var
ix
;
for
(
ix
in
this
.
_windows
)
{
if
(
this
.
_windows
[
ix
]
.
_restoring
)
{
continue
;
}
total
.
push
(
this
.
_windows
[
ix
]
)
;
ids
.
push
(
ix
)
;
if
(
!
this
.
_windows
[
ix
]
.
isPopup
)
{
nonPopupCount
+
+
;
}
}
for
(
ix
in
this
.
_statesToRestore
)
{
for
(
let
winData
of
this
.
_statesToRestore
[
ix
]
.
windows
)
{
total
.
push
(
winData
)
;
if
(
!
winData
.
isPopup
)
{
nonPopupCount
+
+
;
}
}
}
let
lastClosedWindowsCopy
=
this
.
_closedWindows
.
slice
(
)
;
if
(
AppConstants
.
platform
!
=
"
macosx
"
)
{
if
(
nonPopupCount
=
=
0
&
&
!
!
lastClosedWindowsCopy
.
length
&
&
lazy
.
RunState
.
isQuitting
)
{
do
{
total
.
unshift
(
lastClosedWindowsCopy
.
shift
(
)
)
;
}
while
(
total
[
0
]
.
isPopup
&
&
lastClosedWindowsCopy
.
length
)
;
}
}
if
(
activeWindow
)
{
this
.
activeWindowSSiCache
=
activeWindow
.
__SSi
|
|
"
"
;
}
ix
=
ids
.
indexOf
(
this
.
activeWindowSSiCache
)
;
if
(
ix
!
=
-
1
&
&
total
[
ix
]
&
&
total
[
ix
]
.
sizemode
=
=
"
minimized
"
)
{
ix
=
-
1
;
}
let
session
=
{
lastUpdate
:
Date
.
now
(
)
startTime
:
this
.
_sessionStartTime
recentCrashes
:
this
.
_recentCrashes
}
;
let
state
=
{
version
:
[
"
sessionrestore
"
FORMAT_VERSION
]
windows
:
total
selectedWindow
:
ix
+
1
_closedWindows
:
lastClosedWindowsCopy
session
global
:
this
.
_globalState
.
getState
(
)
}
;
state
.
cookies
=
lazy
.
SessionCookies
.
collect
(
)
;
lazy
.
DevToolsShim
.
saveDevToolsSession
(
state
)
;
if
(
LastSession
.
canRestore
)
{
state
.
lastSessionState
=
LastSession
.
getState
(
)
;
}
if
(
this
.
_deferredInitialState
)
{
state
.
deferredInitialState
=
this
.
_deferredInitialState
;
}
return
state
;
}
_getWindowState
:
function
ssi_getWindowState
(
aWindow
)
{
if
(
!
this
.
_isWindowLoaded
(
aWindow
)
)
{
return
this
.
_statesToRestore
[
WINDOW_RESTORE_IDS
.
get
(
aWindow
)
]
;
}
if
(
lazy
.
RunState
.
isRunning
)
{
this
.
_collectWindowData
(
aWindow
)
;
}
return
{
windows
:
[
this
.
_windows
[
aWindow
.
__SSi
]
]
}
;
}
_collectWindowData
:
function
ssi_collectWindowData
(
aWindow
)
{
let
tabMap
=
new
Map
(
)
;
if
(
!
this
.
_isWindowLoaded
(
aWindow
)
)
{
return
tabMap
;
}
let
tabbrowser
=
aWindow
.
gBrowser
;
let
tabs
=
tabbrowser
.
tabs
;
let
winData
=
this
.
_windows
[
aWindow
.
__SSi
]
;
let
tabsData
=
(
winData
.
tabs
=
[
]
)
;
for
(
let
tab
of
tabs
)
{
if
(
tab
=
=
aWindow
.
FirefoxViewHandler
.
tab
)
{
continue
;
}
let
tabData
=
lazy
.
TabState
.
collect
(
tab
TAB_CUSTOM_VALUES
.
get
(
tab
)
)
;
tabMap
.
set
(
tab
tabData
)
;
tabsData
.
push
(
tabData
)
;
}
let
selectedIndex
=
tabbrowser
.
tabbox
.
selectedIndex
+
1
;
if
(
aWindow
.
FirefoxViewHandler
.
tab
&
&
!
aWindow
.
FirefoxViewHandler
.
tab
.
selected
)
{
selectedIndex
-
=
1
;
}
winData
.
selected
=
selectedIndex
;
this
.
_updateWindowFeatures
(
aWindow
)
;
if
(
aWindow
.
__SS_lastSessionWindowID
)
{
this
.
_windows
[
aWindow
.
__SSi
]
.
__lastSessionWindowID
=
aWindow
.
__SS_lastSessionWindowID
;
}
DirtyWindows
.
remove
(
aWindow
)
;
return
tabMap
;
}
_openWindows
(
root
)
{
let
windowsOpened
=
[
]
;
for
(
let
winData
of
root
.
windows
)
{
if
(
!
winData
|
|
!
winData
.
tabs
|
|
!
winData
.
tabs
[
0
]
)
{
continue
;
}
windowsOpened
.
push
(
this
.
_openWindowWithState
(
{
windows
:
[
winData
]
}
)
)
;
}
let
windowOpenedPromises
=
[
]
;
for
(
const
openedWindow
of
windowsOpened
)
{
let
deferred
=
WINDOW_SHOWING_PROMISES
.
get
(
openedWindow
)
;
windowOpenedPromises
.
push
(
deferred
.
promise
)
;
}
return
Promise
.
all
(
windowOpenedPromises
)
;
}
_resetClosedIds
(
tabData
)
{
for
(
let
entry
of
tabData
)
{
entry
.
closedId
=
this
.
_nextClosedId
+
+
;
}
return
tabData
;
}
restoreWindow
:
function
ssi_restoreWindow
(
aWindow
winData
aOptions
=
{
}
)
{
let
overwriteTabs
=
aOptions
&
&
aOptions
.
overwriteTabs
;
let
firstWindow
=
aOptions
&
&
aOptions
.
firstWindow
;
if
(
aWindow
&
&
(
!
aWindow
.
__SSi
|
|
!
this
.
_windows
[
aWindow
.
__SSi
]
)
)
{
this
.
onLoad
(
aWindow
)
;
}
TelemetryStopwatch
.
start
(
"
FX_SESSION_RESTORE_RESTORE_WINDOW_MS
"
)
;
this
.
_sendWindowRestoringNotification
(
aWindow
)
;
this
.
_setWindowStateBusy
(
aWindow
)
;
if
(
winData
.
workspaceID
)
{
aWindow
.
moveToWorkspace
(
winData
.
workspaceID
)
;
}
if
(
!
winData
.
tabs
)
{
winData
.
tabs
=
[
]
;
}
else
if
(
firstWindow
&
&
!
overwriteTabs
&
&
winData
.
tabs
.
length
=
=
1
&
&
(
!
winData
.
tabs
[
0
]
.
entries
|
|
!
winData
.
tabs
[
0
]
.
entries
.
length
)
)
{
winData
.
tabs
=
[
]
;
}
let
selectTab
=
0
;
if
(
overwriteTabs
)
{
selectTab
=
parseInt
(
winData
.
selected
|
|
1
10
)
;
selectTab
=
Math
.
max
(
selectTab
1
)
;
selectTab
=
Math
.
min
(
selectTab
winData
.
tabs
.
length
)
;
}
let
tabbrowser
=
aWindow
.
gBrowser
;
let
arrowScrollbox
=
tabbrowser
.
tabContainer
.
arrowScrollbox
;
let
smoothScroll
=
arrowScrollbox
.
smoothScroll
;
arrowScrollbox
.
smoothScroll
=
false
;
let
initialTabs
;
if
(
!
overwriteTabs
&
&
firstWindow
)
{
initialTabs
=
Array
.
from
(
tabbrowser
.
tabs
)
;
}
if
(
overwriteTabs
)
{
for
(
let
i
=
tabbrowser
.
browsers
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
if
(
!
tabbrowser
.
tabs
[
i
]
.
selected
)
{
tabbrowser
.
removeTab
(
tabbrowser
.
tabs
[
i
]
)
;
}
}
}
let
restoreTabsLazily
=
this
.
_prefBranch
.
getBoolPref
(
"
sessionstore
.
restore_tabs_lazily
"
)
&
&
this
.
_restore_on_demand
;
if
(
winData
.
tabs
.
length
)
{
var
tabs
=
tabbrowser
.
addMultipleTabs
(
restoreTabsLazily
selectTab
winData
.
tabs
)
;
}
if
(
initialTabs
)
{
let
endPosition
=
tabbrowser
.
tabs
.
length
-
1
;
for
(
let
i
=
0
;
i
<
initialTabs
.
length
;
i
+
+
)
{
tabbrowser
.
unpinTab
(
initialTabs
[
i
]
)
;
tabbrowser
.
moveTabTo
(
initialTabs
[
i
]
endPosition
)
;
}
}
delete
aWindow
.
__SS_lastSessionWindowID
;
if
(
winData
.
__lastSessionWindowID
)
{
aWindow
.
__SS_lastSessionWindowID
=
winData
.
__lastSessionWindowID
;
}
if
(
overwriteTabs
)
{
delete
this
.
_windows
[
aWindow
.
__SSi
]
.
extData
;
}
lazy
.
SessionCookies
.
restore
(
winData
.
cookies
|
|
[
]
)
;
if
(
winData
.
extData
)
{
if
(
!
this
.
_windows
[
aWindow
.
__SSi
]
.
extData
)
{
this
.
_windows
[
aWindow
.
__SSi
]
.
extData
=
{
}
;
}
for
(
var
key
in
winData
.
extData
)
{
this
.
_windows
[
aWindow
.
__SSi
]
.
extData
[
key
]
=
winData
.
extData
[
key
]
;
}
}
let
newClosedTabsData
=
winData
.
_closedTabs
|
|
[
]
;
newClosedTabsData
=
this
.
_resetClosedIds
(
newClosedTabsData
)
;
let
newLastClosedTabGroupCount
=
winData
.
_lastClosedTabGroupCount
|
|
-
1
;
if
(
overwriteTabs
|
|
firstWindow
)
{
this
.
_windows
[
aWindow
.
__SSi
]
.
_closedTabs
=
newClosedTabsData
;
}
else
if
(
this
.
_max_tabs_undo
>
0
)
{
newClosedTabsData
=
newClosedTabsData
.
concat
(
this
.
_windows
[
aWindow
.
__SSi
]
.
_closedTabs
)
;
this
.
_windows
[
aWindow
.
__SSi
]
.
_closedTabs
=
newClosedTabsData
.
slice
(
0
this
.
_max_tabs_undo
)
;
}
this
.
_windows
[
aWindow
.
__SSi
]
.
_lastClosedTabGroupCount
=
newLastClosedTabGroupCount
;
if
(
!
this
.
_isWindowLoaded
(
aWindow
)
)
{
delete
this
.
_statesToRestore
[
WINDOW_RESTORE_IDS
.
get
(
aWindow
)
]
;
WINDOW_RESTORE_IDS
.
delete
(
aWindow
)
;
delete
this
.
_windows
[
aWindow
.
__SSi
]
.
_restoring
;
}
if
(
winData
.
tabs
.
length
)
{
this
.
restoreTabs
(
aWindow
tabs
winData
.
tabs
selectTab
)
;
}
arrowScrollbox
.
smoothScroll
=
smoothScroll
;
TelemetryStopwatch
.
finish
(
"
FX_SESSION_RESTORE_RESTORE_WINDOW_MS
"
)
;
this
.
_setWindowStateReady
(
aWindow
)
;
this
.
_sendWindowRestoredNotification
(
aWindow
)
;
Services
.
obs
.
notifyObservers
(
aWindow
NOTIFY_SINGLE_WINDOW_RESTORED
)
;
this
.
_sendRestoreCompletedNotifications
(
)
;
}
prepareConnectionToHost
(
tab
url
)
{
if
(
url
&
&
!
url
.
startsWith
(
"
about
:
"
)
)
{
let
principal
=
Services
.
scriptSecurityManager
.
createNullPrincipal
(
{
userContextId
:
tab
.
userContextId
}
)
;
let
sc
=
Services
.
io
.
QueryInterface
(
Ci
.
nsISpeculativeConnect
)
;
let
uri
=
Services
.
io
.
newURI
(
url
)
;
try
{
sc
.
speculativeConnect
(
uri
principal
null
)
;
return
true
;
}
catch
(
error
)
{
Cu
.
reportError
(
error
)
;
return
false
;
}
}
return
false
;
}
speculativeConnectOnTabHover
(
tab
)
{
let
tabState
=
TAB_LAZY_STATES
.
get
(
tab
)
;
if
(
tabState
&
&
!
tabState
.
connectionPrepared
)
{
let
url
=
this
.
getLazyTabValue
(
tab
"
url
"
)
;
let
prepared
=
this
.
prepareConnectionToHost
(
tab
url
)
;
if
(
gDebuggingEnabled
)
{
tab
.
__test_connection_prepared
=
prepared
;
tab
.
__test_connection_url
=
url
;
}
tabState
.
connectionPrepared
=
true
;
}
}
_restoreWindowsFeaturesAndTabs
(
windows
)
{
for
(
let
window
of
windows
)
{
let
state
=
this
.
_statesToRestore
[
WINDOW_RESTORE_IDS
.
get
(
window
)
]
;
this
.
restoreWindowFeatures
(
window
state
.
windows
[
0
]
)
;
}
for
(
let
window
of
windows
)
{
let
state
=
this
.
_statesToRestore
[
WINDOW_RESTORE_IDS
.
get
(
window
)
]
;
this
.
restoreWindow
(
window
state
.
windows
[
0
]
state
.
options
|
|
{
overwriteTabs
:
true
}
)
;
WINDOW_RESTORE_ZINDICES
.
delete
(
window
)
;
}
}
_restoreWindowsInReversedZOrder
(
windows
)
{
windows
.
sort
(
(
a
b
)
=
>
(
WINDOW_RESTORE_ZINDICES
.
get
(
a
)
|
|
0
)
-
(
WINDOW_RESTORE_ZINDICES
.
get
(
b
)
|
|
0
)
)
;
this
.
windowToFocus
=
windows
[
0
]
;
this
.
_restoreWindowsFeaturesAndTabs
(
windows
)
;
}
restoreWindows
:
function
ssi_restoreWindows
(
aWindow
aState
aOptions
=
{
}
)
{
if
(
aWindow
&
&
(
!
aWindow
.
__SSi
|
|
!
this
.
_windows
[
aWindow
.
__SSi
]
)
)
{
this
.
onLoad
(
aWindow
)
;
}
let
root
;
try
{
root
=
typeof
aState
=
=
"
string
"
?
JSON
.
parse
(
aState
)
:
aState
;
}
catch
(
ex
)
{
this
.
_log
.
error
(
ex
)
;
this
.
_sendRestoreCompletedNotifications
(
)
;
return
;
}
if
(
root
.
_closedWindows
)
{
this
.
_closedWindows
=
root
.
_closedWindows
;
this
.
_closedObjectsChanged
=
true
;
}
if
(
!
root
.
windows
|
|
!
root
.
windows
.
length
)
{
this
.
_sendRestoreCompletedNotifications
(
)
;
return
;
}
let
firstWindowData
=
root
.
windows
.
splice
(
0
1
)
;
this
.
_updateWindowRestoreState
(
aWindow
{
windows
:
firstWindowData
options
:
aOptions
}
)
;
this
.
_openWindows
(
root
)
.
then
(
windows
=
>
{
windows
.
unshift
(
aWindow
)
;
this
.
_restoreWindowsInReversedZOrder
(
windows
)
;
}
)
;
lazy
.
DevToolsShim
.
restoreDevToolsSession
(
aState
)
;
}
restoreTabs
(
aWindow
aTabs
aTabData
aSelectTab
)
{
var
tabbrowser
=
aWindow
.
gBrowser
;
let
numTabsToRestore
=
aTabs
.
length
;
let
numTabsInWindow
=
tabbrowser
.
tabs
.
length
;
let
tabsDataArray
=
this
.
_windows
[
aWindow
.
__SSi
]
.
tabs
;
if
(
numTabsInWindow
=
=
numTabsToRestore
)
{
tabsDataArray
.
length
=
0
;
}
else
{
tabsDataArray
.
splice
(
numTabsInWindow
-
numTabsToRestore
)
;
}
tabsDataArray
.
length
=
numTabsInWindow
;
if
(
aSelectTab
>
0
&
&
aSelectTab
<
=
aTabs
.
length
)
{
this
.
_windows
[
aWindow
.
__SSi
]
.
selected
=
aSelectTab
;
}
let
selectedIndex
=
aTabs
.
indexOf
(
tabbrowser
.
selectedTab
)
;
if
(
selectedIndex
>
-
1
)
{
this
.
restoreTab
(
tabbrowser
.
selectedTab
aTabData
[
selectedIndex
]
)
;
}
for
(
let
t
=
0
;
t
<
aTabs
.
length
;
t
+
+
)
{
if
(
t
!
=
selectedIndex
)
{
this
.
restoreTab
(
aTabs
[
t
]
aTabData
[
t
]
)
;
}
}
}
restoreTab
(
tab
tabData
options
=
{
}
)
{
let
browser
=
tab
.
linkedBrowser
;
if
(
TAB_STATE_FOR_BROWSER
.
has
(
browser
)
)
{
Cu
.
reportError
(
"
Must
reset
tab
before
calling
restoreTab
.
"
)
;
return
;
}
let
loadArguments
=
options
.
loadArguments
;
let
window
=
tab
.
ownerGlobal
;
let
tabbrowser
=
window
.
gBrowser
;
let
forceOnDemand
=
options
.
forceOnDemand
;
let
isRemotenessUpdate
=
options
.
isRemotenessUpdate
;
let
willRestoreImmediately
=
options
.
restoreImmediately
|
|
tabbrowser
.
selectedBrowser
=
=
browser
;
let
isBrowserInserted
=
browser
.
isConnected
;
this
.
_setWindowStateBusy
(
window
)
;
DirtyWindows
.
add
(
window
)
;
for
(
let
otherTab
of
Array
.
prototype
.
slice
.
call
(
tabbrowser
.
tabs
0
tab
.
_tPos
)
)
{
let
emptyState
=
{
entries
:
[
]
lastAccessed
:
otherTab
.
lastAccessed
}
;
this
.
_windows
[
window
.
__SSi
]
.
tabs
.
push
(
emptyState
)
;
}
this
.
_windows
[
window
.
__SSi
]
.
tabs
[
tab
.
_tPos
]
=
tabData
;
if
(
tabData
.
lastAccessed
)
{
tab
.
updateLastAccessed
(
tabData
.
lastAccessed
)
;
}
if
(
"
attributes
"
in
tabData
)
{
Object
.
keys
(
tabData
.
attributes
)
.
forEach
(
a
=
>
lazy
.
TabAttributes
.
persist
(
a
)
)
;
}
if
(
!
tabData
.
entries
)
{
tabData
.
entries
=
[
]
;
}
if
(
tabData
.
extData
)
{
TAB_CUSTOM_VALUES
.
set
(
tab
Cu
.
cloneInto
(
tabData
.
extData
{
}
)
)
;
}
else
{
TAB_CUSTOM_VALUES
.
delete
(
tab
)
;
}
delete
tabData
.
closedAt
;
let
activeIndex
=
(
tabData
.
index
|
|
tabData
.
entries
.
length
)
-
1
;
activeIndex
=
Math
.
min
(
activeIndex
tabData
.
entries
.
length
-
1
)
;
activeIndex
=
Math
.
max
(
activeIndex
0
)
;
tabData
.
index
=
activeIndex
+
1
;
tab
.
setAttribute
(
"
pending
"
"
true
"
)
;
this
.
_crashedBrowsers
.
delete
(
browser
.
permanentKey
)
;
if
(
options
.
restoreContentReason
=
=
RESTORE_TAB_CONTENT_REASON
.
NAVIGATE_AND_RESTORE
)
{
delete
tabData
.
userTypedValue
;
delete
tabData
.
userTypedClear
;
}
lazy
.
TabStateCache
.
update
(
browser
.
permanentKey
{
history
:
{
entries
:
[
.
.
.
tabData
.
entries
]
index
:
tabData
.
index
}
scroll
:
tabData
.
scroll
|
|
null
storage
:
tabData
.
storage
|
|
null
formdata
:
tabData
.
formdata
|
|
null
disallow
:
tabData
.
disallow
|
|
null
userContextId
:
tabData
.
userContextId
|
|
0
image
:
tabData
.
image
|
|
"
"
iconLoadingPrincipal
:
tabData
.
iconLoadingPrincipal
|
|
null
searchMode
:
tabData
.
searchMode
|
|
null
userTypedValue
:
tabData
.
userTypedValue
|
|
"
"
userTypedClear
:
tabData
.
userTypedClear
|
|
0
}
)
;
if
(
"
attributes
"
in
tabData
)
{
lazy
.
TabAttributes
.
set
(
tab
tabData
.
attributes
)
;
}
if
(
isBrowserInserted
)
{
let
epoch
=
this
.
startNextEpoch
(
browser
.
permanentKey
)
;
TAB_STATE_FOR_BROWSER
.
set
(
browser
TAB_STATE_NEEDS_RESTORE
)
;
this
.
_sendRestoreHistory
(
browser
{
tabData
epoch
loadArguments
isRemotenessUpdate
}
)
;
if
(
willRestoreImmediately
)
{
this
.
restoreTabContent
(
tab
options
)
;
}
else
if
(
!
forceOnDemand
)
{
TabRestoreQueue
.
add
(
tab
)
;
if
(
TabRestoreQueue
.
willRestoreSoon
(
tab
)
)
{
if
(
activeIndex
in
tabData
.
entries
)
{
let
url
=
tabData
.
entries
[
activeIndex
]
.
url
;
let
prepared
=
this
.
prepareConnectionToHost
(
tab
url
)
;
if
(
gDebuggingEnabled
)
{
tab
.
__test_connection_prepared
=
prepared
;
tab
.
__test_connection_url
=
url
;
}
}
}
this
.
restoreNextTab
(
)
;
}
}
else
{
let
url
=
"
about
:
blank
"
;
let
title
=
"
"
;
if
(
activeIndex
in
tabData
.
entries
)
{
url
=
tabData
.
entries
[
activeIndex
]
.
url
;
title
=
tabData
.
entries
[
activeIndex
]
.
title
|
|
url
;
}
TAB_LAZY_STATES
.
set
(
tab
{
url
title
userTypedValue
:
tabData
.
userTypedValue
|
|
"
"
userTypedClear
:
tabData
.
userTypedClear
|
|
0
}
)
;
}
if
(
tabData
.
pinned
)
{
tabbrowser
.
pinTab
(
tab
)
;
}
else
{
tabbrowser
.
unpinTab
(
tab
)
;
}
if
(
tabData
.
hidden
)
{
tabbrowser
.
hideTab
(
tab
)
;
}
else
{
tabbrowser
.
showTab
(
tab
)
;
}
if
(
!
!
tabData
.
muted
!
=
browser
.
audioMuted
)
{
tab
.
toggleMuteAudio
(
tabData
.
muteReason
)
;
}
if
(
tab
.
hasAttribute
(
"
customizemode
"
)
)
{
window
.
gCustomizeMode
.
setTab
(
tab
)
;
}
this
.
updateTabLabelAndIcon
(
tab
tabData
)
;
this
.
_setWindowStateReady
(
window
)
;
}
restoreTabContent
(
aTab
aOptions
=
{
}
)
{
let
loadArguments
=
aOptions
.
loadArguments
;
if
(
aTab
.
hasAttribute
(
"
customizemode
"
)
&
&
!
loadArguments
)
{
return
;
}
let
browser
=
aTab
.
linkedBrowser
;
let
window
=
aTab
.
ownerGlobal
;
let
tabbrowser
=
window
.
gBrowser
;
let
tabData
=
lazy
.
TabState
.
clone
(
aTab
TAB_CUSTOM_VALUES
.
get
(
aTab
)
)
;
let
activeIndex
=
tabData
.
index
-
1
;
let
activePageData
=
tabData
.
entries
[
activeIndex
]
|
|
null
;
let
uri
=
activePageData
?
activePageData
.
url
|
|
null
:
null
;
this
.
markTabAsRestoring
(
aTab
)
;
let
isRemotenessUpdate
=
aOptions
.
isRemotenessUpdate
;
let
explicitlyUpdateRemoteness
=
!
Services
.
appinfo
.
sessionHistoryInParent
;
if
(
explicitlyUpdateRemoteness
&
&
!
isRemotenessUpdate
)
{
isRemotenessUpdate
=
tabbrowser
.
updateBrowserRemotenessByURL
(
browser
uri
)
;
if
(
isRemotenessUpdate
)
{
let
epoch
=
this
.
startNextEpoch
(
browser
.
permanentKey
)
;
this
.
_sendRestoreHistory
(
browser
{
tabData
epoch
loadArguments
isRemotenessUpdate
}
)
;
}
}
this
.
_sendRestoreTabContent
(
browser
{
loadArguments
isRemotenessUpdate
reason
:
aOptions
.
restoreContentReason
|
|
RESTORE_TAB_CONTENT_REASON
.
SET_STATE
}
)
;
if
(
aTab
.
selected
&
&
!
window
.
isBlankPageURL
(
uri
)
&
&
!
aOptions
.
isRemotenessUpdate
)
{
browser
.
focus
(
)
;
}
}
markTabAsRestoring
(
aTab
)
{
let
browser
=
aTab
.
linkedBrowser
;
if
(
TAB_STATE_FOR_BROWSER
.
get
(
browser
)
!
=
TAB_STATE_NEEDS_RESTORE
)
{
throw
new
Error
(
"
Given
tab
is
not
pending
.
"
)
;
}
TabRestoreQueue
.
remove
(
aTab
)
;
this
.
_tabsRestoringCount
+
+
;
TAB_STATE_FOR_BROWSER
.
set
(
browser
TAB_STATE_RESTORING
)
;
aTab
.
removeAttribute
(
"
pending
"
)
;
}
restoreNextTab
:
function
ssi_restoreNextTab
(
)
{
if
(
lazy
.
RunState
.
isQuitting
)
{
return
;
}
if
(
this
.
_tabsRestoringCount
>
=
MAX_CONCURRENT_TAB_RESTORES
)
{
return
;
}
let
tab
=
TabRestoreQueue
.
shift
(
)
;
if
(
tab
)
{
this
.
restoreTabContent
(
tab
)
;
}
}
restoreWindowFeatures
:
function
ssi_restoreWindowFeatures
(
aWindow
aWinData
)
{
var
hidden
=
aWinData
.
hidden
?
aWinData
.
hidden
.
split
(
"
"
)
:
[
]
;
WINDOW_HIDEABLE_FEATURES
.
forEach
(
function
(
aItem
)
{
aWindow
[
aItem
]
.
visible
=
!
hidden
.
includes
(
aItem
)
;
}
)
;
if
(
aWinData
.
isPopup
)
{
this
.
_windows
[
aWindow
.
__SSi
]
.
isPopup
=
true
;
if
(
aWindow
.
gURLBar
)
{
aWindow
.
gURLBar
.
readOnly
=
true
;
}
}
else
{
delete
this
.
_windows
[
aWindow
.
__SSi
]
.
isPopup
;
if
(
aWindow
.
gURLBar
)
{
aWindow
.
gURLBar
.
readOnly
=
false
;
}
}
aWindow
.
setTimeout
(
(
)
=
>
{
this
.
restoreDimensions
(
aWindow
+
(
aWinData
.
width
|
|
0
)
+
(
aWinData
.
height
|
|
0
)
"
screenX
"
in
aWinData
?
+
aWinData
.
screenX
:
NaN
"
screenY
"
in
aWinData
?
+
aWinData
.
screenY
:
NaN
aWinData
.
sizemode
|
|
"
"
aWinData
.
sizemodeBeforeMinimized
|
|
"
"
aWinData
.
sidebar
|
|
"
"
)
;
}
0
)
;
}
restoreDimensions
:
function
ssi_restoreDimensions
(
aWindow
aWidth
aHeight
aLeft
aTop
aSizeMode
aSizeModeBeforeMinimized
aSidebar
)
{
var
win
=
aWindow
;
var
_this
=
this
;
function
win_
(
aName
)
{
return
_this
.
_getWindowDimension
(
win
aName
)
;
}
const
dwu
=
win
.
windowUtils
;
let
screen
=
lazy
.
gScreenManager
.
screenForRect
(
aLeft
aTop
aWidth
aHeight
)
;
if
(
screen
)
{
let
screenLeft
=
{
}
screenTop
=
{
}
screenWidth
=
{
}
screenHeight
=
{
}
;
screen
.
GetAvailRectDisplayPix
(
screenLeft
screenTop
screenWidth
screenHeight
)
;
screenLeft
=
screenLeft
.
value
;
screenTop
=
screenTop
.
value
;
screenWidth
=
screenWidth
.
value
;
screenHeight
=
screenHeight
.
value
;
let
screenBottom
=
screenTop
+
screenHeight
;
let
screenRight
=
screenLeft
+
screenWidth
;
let
cssToDesktopScale
=
screen
.
defaultCSSScaleFactor
/
screen
.
contentsScaleFactor
;
let
slop
=
SCREEN_EDGE_SLOP
*
cssToDesktopScale
;
if
(
aLeft
<
screenLeft
-
slop
)
{
aLeft
=
screenLeft
;
}
let
right
=
aLeft
+
aWidth
*
cssToDesktopScale
;
if
(
right
>
screenRight
+
slop
)
{
right
=
screenRight
;
if
(
aLeft
>
screenLeft
)
{
aLeft
=
Math
.
max
(
right
-
aWidth
*
cssToDesktopScale
screenLeft
)
;
}
}
aWidth
=
(
right
-
aLeft
)
/
cssToDesktopScale
;
if
(
aTop
<
screenTop
-
slop
)
{
aTop
=
screenTop
;
}
let
bottom
=
aTop
+
aHeight
*
cssToDesktopScale
;
if
(
bottom
>
screenBottom
+
slop
)
{
bottom
=
screenBottom
;
if
(
aTop
>
screenTop
)
{
aTop
=
Math
.
max
(
bottom
-
aHeight
*
cssToDesktopScale
screenTop
)
;
}
}
aHeight
=
(
bottom
-
aTop
)
/
cssToDesktopScale
;
}
dwu
.
suppressAnimation
(
true
)
;
try
{
if
(
!
isNaN
(
aLeft
)
&
&
!
isNaN
(
aTop
)
&
&
(
aLeft
!
=
win_
(
"
screenX
"
)
|
|
aTop
!
=
win_
(
"
screenY
"
)
)
)
{
let
desktopToCssScale
=
aWindow
.
desktopToDeviceScale
/
aWindow
.
devicePixelRatio
;
aWindow
.
moveTo
(
aLeft
*
desktopToCssScale
aTop
*
desktopToCssScale
)
;
}
if
(
aWidth
&
&
aHeight
&
&
(
aWidth
!
=
win_
(
"
width
"
)
|
|
aHeight
!
=
win_
(
"
height
"
)
)
&
&
!
gResistFingerprintingEnabled
)
{
if
(
aSizeMode
!
=
"
maximized
"
|
|
win_
(
"
sizemode
"
)
!
=
"
maximized
"
)
{
aWindow
.
resizeTo
(
aWidth
aHeight
)
;
}
}
this
.
_windows
[
aWindow
.
__SSi
]
.
sizemodeBeforeMinimized
=
aSizeModeBeforeMinimized
;
if
(
aSizeMode
&
&
win_
(
"
sizemode
"
)
!
=
aSizeMode
&
&
!
gResistFingerprintingEnabled
)
{
switch
(
aSizeMode
)
{
case
"
maximized
"
:
aWindow
.
maximize
(
)
;
break
;
case
"
minimized
"
:
if
(
aSizeModeBeforeMinimized
=
=
"
maximized
"
)
{
aWindow
.
maximize
(
)
;
}
aWindow
.
minimize
(
)
;
break
;
case
"
normal
"
:
aWindow
.
restore
(
)
;
break
;
}
}
let
sidebarBox
=
aWindow
.
document
.
getElementById
(
"
sidebar
-
box
"
)
;
if
(
aSidebar
&
&
(
sidebarBox
.
getAttribute
(
"
sidebarcommand
"
)
!
=
aSidebar
|
|
!
sidebarBox
.
getAttribute
(
"
checked
"
)
)
)
{
aWindow
.
SidebarUI
.
showInitially
(
aSidebar
)
;
}
if
(
this
.
windowToFocus
)
{
this
.
windowToFocus
.
focus
(
)
;
}
}
finally
{
dwu
.
suppressAnimation
(
false
)
;
}
}
saveStateDelayed
(
aWindow
=
null
)
{
if
(
aWindow
)
{
DirtyWindows
.
add
(
aWindow
)
;
}
lazy
.
SessionSaver
.
runDelayed
(
)
;
}
_removeClosedWindow
(
index
)
{
let
windows
=
this
.
_closedWindows
.
splice
(
index
1
)
;
this
.
_closedObjectsChanged
=
true
;
return
windows
;
}
_notifyOfClosedObjectsChange
(
)
{
if
(
!
this
.
_closedObjectsChanged
)
{
return
;
}
this
.
_closedObjectsChanged
=
false
;
lazy
.
setTimeout
(
(
)
=
>
{
Services
.
obs
.
notifyObservers
(
null
NOTIFY_CLOSED_OBJECTS_CHANGED
)
;
}
0
)
;
}
_updateSessionStartTime
:
function
ssi_updateSessionStartTime
(
state
)
{
if
(
state
.
session
&
&
state
.
session
.
startTime
)
{
this
.
_sessionStartTime
=
state
.
session
.
startTime
;
}
}
_browserWindows
:
{
*
[
Symbol
.
iterator
]
(
)
{
for
(
let
window
of
lazy
.
BrowserWindowTracker
.
orderedWindows
)
{
if
(
window
.
__SSi
&
&
!
window
.
closed
)
{
yield
window
;
}
}
}
}
_orderedBrowserWindows
:
{
*
[
Symbol
.
iterator
]
(
)
{
let
windows
=
lazy
.
BrowserWindowTracker
.
orderedWindows
;
windows
.
sort
(
(
a
b
)
=
>
{
if
(
a
.
windowState
=
=
a
.
STATE_MINIMIZED
&
&
b
.
windowState
!
=
b
.
STATE_MINIMIZED
)
{
return
1
;
}
if
(
a
.
windowState
!
=
a
.
STATE_MINIMIZED
&
&
b
.
windowState
=
=
b
.
STATE_MINIMIZED
)
{
return
-
1
;
}
return
0
;
}
)
;
for
(
let
window
of
windows
)
{
if
(
window
.
__SSi
&
&
!
window
.
closed
)
{
yield
window
;
}
}
}
}
_getTopWindow
:
function
ssi_getTopWindow
(
)
{
return
lazy
.
BrowserWindowTracker
.
getTopWindow
(
{
allowPopups
:
true
}
)
;
}
_handleClosedWindows
:
function
ssi_handleClosedWindows
(
)
{
let
promises
=
[
]
;
for
(
let
window
of
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
)
{
if
(
window
.
closed
)
{
promises
.
push
(
this
.
onClose
(
window
)
)
;
}
}
return
Promise
.
all
(
promises
)
;
}
_updateWindowRestoreState
(
window
state
)
{
if
(
"
zIndex
"
in
state
.
windows
[
0
]
)
{
WINDOW_RESTORE_ZINDICES
.
set
(
window
state
.
windows
[
0
]
.
zIndex
)
;
}
do
{
var
ID
=
"
window
"
+
Math
.
random
(
)
;
}
while
(
ID
in
this
.
_statesToRestore
)
;
WINDOW_RESTORE_IDS
.
set
(
window
ID
)
;
this
.
_statesToRestore
[
ID
]
=
state
;
}
_openWindowWithState
:
function
ssi_openWindowWithState
(
aState
)
{
var
argString
=
Cc
[
"
mozilla
.
org
/
supports
-
string
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsString
)
;
argString
.
data
=
"
"
;
let
features
;
let
winState
=
aState
.
windows
[
0
]
;
if
(
winState
.
chromeFlags
)
{
features
=
[
"
chrome
"
"
suppressanimation
"
]
;
let
chromeFlags
=
winState
.
chromeFlags
;
const
allFlags
=
Ci
.
nsIWebBrowserChrome
.
CHROME_ALL
;
const
hasAll
=
(
chromeFlags
&
allFlags
)
=
=
allFlags
;
if
(
hasAll
)
{
features
.
push
(
"
all
"
)
;
}
for
(
let
[
flag
onValue
offValue
]
of
CHROME_FLAGS_MAP
)
{
if
(
hasAll
&
&
allFlags
&
flag
)
{
continue
;
}
let
value
=
chromeFlags
&
flag
?
onValue
:
offValue
;
if
(
value
)
{
features
.
push
(
value
)
;
}
}
}
else
{
features
=
[
"
chrome
"
"
dialog
=
no
"
"
suppressanimation
"
]
;
let
hidden
=
winState
.
hidden
?
.
split
(
"
"
)
|
|
[
]
;
if
(
!
hidden
.
length
)
{
features
.
push
(
"
all
"
)
;
}
else
{
features
.
push
(
"
resizable
"
)
;
WINDOW_HIDEABLE_FEATURES
.
forEach
(
aFeature
=
>
{
if
(
!
hidden
.
includes
(
aFeature
)
)
{
features
.
push
(
WINDOW_OPEN_FEATURES_MAP
[
aFeature
]
|
|
aFeature
)
;
}
}
)
;
}
}
WINDOW_ATTRIBUTES
.
forEach
(
aFeature
=
>
{
if
(
aFeature
in
winState
&
&
!
isNaN
(
winState
[
aFeature
]
)
)
{
features
.
push
(
aFeature
+
"
=
"
+
winState
[
aFeature
]
)
;
}
}
)
;
if
(
winState
.
isPrivate
)
{
features
.
push
(
"
private
"
)
;
}
var
window
=
Services
.
ww
.
openWindow
(
null
AppConstants
.
BROWSER_CHROME_URL
"
_blank
"
features
.
join
(
"
"
)
argString
)
;
this
.
_updateWindowRestoreState
(
window
aState
)
;
WINDOW_SHOWING_PROMISES
.
set
(
window
lazy
.
PromiseUtils
.
defer
(
)
)
;
return
window
;
}
_isCmdLineEmpty
:
function
ssi_isCmdLineEmpty
(
aWindow
aState
)
{
var
pinnedOnly
=
aState
.
windows
&
&
aState
.
windows
.
every
(
win
=
>
win
.
tabs
.
every
(
tab
=
>
tab
.
pinned
)
)
;
let
hasFirstArgument
=
aWindow
.
arguments
&
&
aWindow
.
arguments
[
0
]
;
if
(
!
pinnedOnly
)
{
let
defaultArgs
=
Cc
[
"
mozilla
.
org
/
browser
/
clh
;
1
"
]
.
getService
(
Ci
.
nsIBrowserHandler
)
.
defaultArgs
;
if
(
aWindow
.
arguments
&
&
aWindow
.
arguments
[
0
]
&
&
aWindow
.
arguments
[
0
]
=
=
defaultArgs
)
{
hasFirstArgument
=
false
;
}
}
return
!
hasFirstArgument
;
}
_getWindowDimension
:
function
ssi_getWindowDimension
(
aWindow
aAttribute
)
{
if
(
aAttribute
=
=
"
sizemode
"
)
{
switch
(
aWindow
.
windowState
)
{
case
aWindow
.
STATE_FULLSCREEN
:
case
aWindow
.
STATE_MAXIMIZED
:
return
"
maximized
"
;
case
aWindow
.
STATE_MINIMIZED
:
return
"
minimized
"
;
default
:
return
"
normal
"
;
}
}
if
(
aWindow
.
windowState
!
=
aWindow
.
STATE_NORMAL
)
{
let
docElem
=
aWindow
.
document
.
documentElement
;
let
attr
=
parseInt
(
docElem
.
getAttribute
(
aAttribute
)
10
)
;
if
(
attr
)
{
if
(
aAttribute
!
=
"
width
"
&
&
aAttribute
!
=
"
height
"
)
{
return
attr
;
}
let
appWin
=
aWindow
.
docShell
.
treeOwner
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIAppWindow
)
;
let
diff
=
aAttribute
=
=
"
width
"
?
appWin
.
outerToInnerWidthDifferenceInCSSPixels
:
appWin
.
outerToInnerHeightDifferenceInCSSPixels
;
return
attr
+
diff
;
}
}
switch
(
aAttribute
)
{
case
"
width
"
:
return
aWindow
.
outerWidth
;
case
"
height
"
:
return
aWindow
.
outerHeight
;
case
"
screenX
"
:
case
"
screenY
"
:
return
(
(
aWindow
[
aAttribute
]
*
aWindow
.
devicePixelRatio
)
/
aWindow
.
desktopToDeviceScale
)
;
default
:
return
aAttribute
in
aWindow
?
aWindow
[
aAttribute
]
:
"
"
;
}
}
_needsRestorePage
:
function
ssi_needsRestorePage
(
aState
aRecentCrashes
)
{
const
SIX_HOURS_IN_MS
=
6
*
60
*
60
*
1000
;
let
winData
=
aState
.
windows
|
|
null
;
if
(
!
winData
|
|
!
winData
.
length
)
{
return
false
;
}
if
(
this
.
_hasSingleTabWithURL
(
winData
"
about
:
sessionrestore
"
)
|
|
this
.
_hasSingleTabWithURL
(
winData
"
about
:
welcomeback
"
)
)
{
return
false
;
}
if
(
Services
.
appinfo
.
inSafeMode
)
{
return
true
;
}
let
max_resumed_crashes
=
this
.
_prefBranch
.
getIntPref
(
"
sessionstore
.
max_resumed_crashes
"
)
;
let
sessionAge
=
aState
.
session
&
&
aState
.
session
.
lastUpdate
&
&
Date
.
now
(
)
-
aState
.
session
.
lastUpdate
;
let
decision
=
max_resumed_crashes
!
=
-
1
&
&
(
aRecentCrashes
>
max_resumed_crashes
|
|
(
sessionAge
&
&
sessionAge
>
=
SIX_HOURS_IN_MS
)
)
;
if
(
decision
)
{
let
key
;
if
(
aRecentCrashes
>
max_resumed_crashes
)
{
if
(
sessionAge
&
&
sessionAge
>
=
SIX_HOURS_IN_MS
)
{
key
=
"
shown_many_crashes_old_session
"
;
}
else
{
key
=
"
shown_many_crashes
"
;
}
}
else
{
key
=
"
shown_old_session
"
;
}
Services
.
telemetry
.
keyedScalarAdd
(
"
browser
.
engagement
.
sessionrestore_interstitial
"
key
1
)
;
}
return
decision
;
}
_hasSingleTabWithURL
(
aWinData
aURL
)
{
if
(
aWinData
&
&
aWinData
.
length
=
=
1
&
&
aWinData
[
0
]
.
tabs
&
&
aWinData
[
0
]
.
tabs
.
length
=
=
1
&
&
aWinData
[
0
]
.
tabs
[
0
]
.
entries
&
&
aWinData
[
0
]
.
tabs
[
0
]
.
entries
.
length
=
=
1
)
{
return
aURL
=
=
aWinData
[
0
]
.
tabs
[
0
]
.
entries
[
0
]
.
url
;
}
return
false
;
}
_shouldSaveTabState
:
function
ssi_shouldSaveTabState
(
aTabState
)
{
return
(
aTabState
.
entries
.
length
&
&
!
(
aTabState
.
entries
.
length
=
=
1
&
&
(
aTabState
.
entries
[
0
]
.
url
=
=
"
about
:
blank
"
|
|
aTabState
.
entries
[
0
]
.
url
=
=
"
about
:
newtab
"
|
|
aTabState
.
entries
[
0
]
.
url
=
=
"
about
:
privatebrowsing
"
)
&
&
!
aTabState
.
userTypedValue
)
)
;
}
_shouldSaveTab
:
function
ssi_shouldSaveTab
(
aTabState
)
{
return
(
aTabState
.
userTypedValue
|
|
(
aTabState
.
attributes
&
&
aTabState
.
attributes
.
customizemode
=
=
"
true
"
)
|
|
(
aTabState
.
entries
.
length
&
&
aTabState
.
entries
[
0
]
.
url
!
=
"
about
:
privatebrowsing
"
)
)
;
}
_prepDataForDeferredRestore
:
function
ssi_prepDataForDeferredRestore
(
state
)
{
state
=
Cu
.
cloneInto
(
state
{
}
)
;
let
defaultState
=
{
windows
:
[
]
selectedWindow
:
1
}
;
state
.
selectedWindow
=
state
.
selectedWindow
|
|
1
;
for
(
let
wIndex
=
0
;
wIndex
<
state
.
windows
.
length
;
)
{
let
window
=
state
.
windows
[
wIndex
]
;
window
.
selected
=
window
.
selected
|
|
1
;
let
pinnedWindowState
=
{
tabs
:
[
]
}
;
for
(
let
tIndex
=
0
;
tIndex
<
window
.
tabs
.
length
;
)
{
if
(
window
.
tabs
[
tIndex
]
.
pinned
)
{
if
(
tIndex
+
1
<
window
.
selected
)
{
window
.
selected
-
=
1
;
}
else
if
(
tIndex
+
1
=
=
window
.
selected
)
{
pinnedWindowState
.
selected
=
pinnedWindowState
.
tabs
.
length
+
1
;
}
pinnedWindowState
.
tabs
=
pinnedWindowState
.
tabs
.
concat
(
window
.
tabs
.
splice
(
tIndex
1
)
)
;
continue
;
}
tIndex
+
+
;
}
if
(
pinnedWindowState
.
tabs
.
length
)
{
WINDOW_ATTRIBUTES
.
forEach
(
function
(
attr
)
{
if
(
attr
in
window
)
{
pinnedWindowState
[
attr
]
=
window
[
attr
]
;
delete
window
[
attr
]
;
}
}
)
;
window
.
__lastSessionWindowID
=
pinnedWindowState
.
__lastSessionWindowID
=
"
"
+
Date
.
now
(
)
+
Math
.
random
(
)
;
defaultState
.
windows
.
push
(
pinnedWindowState
)
;
if
(
!
window
.
tabs
.
length
)
{
if
(
wIndex
+
1
<
=
state
.
selectedWindow
)
{
state
.
selectedWindow
-
=
1
;
}
else
if
(
wIndex
+
1
=
=
state
.
selectedWindow
)
{
defaultState
.
selectedIndex
=
defaultState
.
windows
.
length
+
1
;
}
state
.
windows
.
splice
(
wIndex
1
)
;
continue
;
}
}
wIndex
+
+
;
}
return
[
defaultState
state
]
;
}
_sendRestoreCompletedNotifications
:
function
ssi_sendRestoreCompletedNotifications
(
)
{
if
(
this
.
_restoreCount
>
1
)
{
this
.
_restoreCount
-
-
;
return
;
}
if
(
this
.
_restoreCount
=
=
-
1
)
{
return
;
}
if
(
!
this
.
_browserSetState
)
{
Services
.
obs
.
notifyObservers
(
null
NOTIFY_WINDOWS_RESTORED
)
;
this
.
_deferredAllWindowsRestored
.
resolve
(
)
;
}
else
{
Services
.
obs
.
notifyObservers
(
null
NOTIFY_BROWSER_STATE_RESTORED
)
;
}
this
.
_browserSetState
=
false
;
this
.
_restoreCount
=
-
1
;
}
_setWindowStateBusyValue
:
function
ssi_changeWindowStateBusyValue
(
aWindow
aValue
)
{
this
.
_windows
[
aWindow
.
__SSi
]
.
busy
=
aValue
;
if
(
!
this
.
_isWindowLoaded
(
aWindow
)
)
{
let
stateToRestore
=
this
.
_statesToRestore
[
WINDOW_RESTORE_IDS
.
get
(
aWindow
)
]
.
windows
[
0
]
;
stateToRestore
.
busy
=
aValue
;
}
}
_setWindowStateReady
:
function
ssi_setWindowStateReady
(
aWindow
)
{
let
newCount
=
(
this
.
_windowBusyStates
.
get
(
aWindow
)
|
|
0
)
-
1
;
if
(
newCount
<
0
)
{
throw
new
Error
(
"
Invalid
window
busy
state
(
less
than
zero
)
.
"
)
;
}
this
.
_windowBusyStates
.
set
(
aWindow
newCount
)
;
if
(
newCount
=
=
0
)
{
this
.
_setWindowStateBusyValue
(
aWindow
false
)
;
this
.
_sendWindowStateReadyEvent
(
aWindow
)
;
}
}
_setWindowStateBusy
:
function
ssi_setWindowStateBusy
(
aWindow
)
{
let
newCount
=
(
this
.
_windowBusyStates
.
get
(
aWindow
)
|
|
0
)
+
1
;
this
.
_windowBusyStates
.
set
(
aWindow
newCount
)
;
if
(
newCount
=
=
1
)
{
this
.
_setWindowStateBusyValue
(
aWindow
true
)
;
this
.
_sendWindowStateBusyEvent
(
aWindow
)
;
}
}
_sendWindowStateReadyEvent
:
function
ssi_sendWindowStateReadyEvent
(
aWindow
)
{
let
event
=
aWindow
.
document
.
createEvent
(
"
Events
"
)
;
event
.
initEvent
(
"
SSWindowStateReady
"
true
false
)
;
aWindow
.
dispatchEvent
(
event
)
;
}
_sendWindowStateBusyEvent
:
function
ssi_sendWindowStateBusyEvent
(
aWindow
)
{
let
event
=
aWindow
.
document
.
createEvent
(
"
Events
"
)
;
event
.
initEvent
(
"
SSWindowStateBusy
"
true
false
)
;
aWindow
.
dispatchEvent
(
event
)
;
}
_sendWindowRestoringNotification
(
aWindow
)
{
let
event
=
aWindow
.
document
.
createEvent
(
"
Events
"
)
;
event
.
initEvent
(
"
SSWindowRestoring
"
true
false
)
;
aWindow
.
dispatchEvent
(
event
)
;
}
_sendWindowRestoredNotification
(
aWindow
)
{
let
event
=
aWindow
.
document
.
createEvent
(
"
Events
"
)
;
event
.
initEvent
(
"
SSWindowRestored
"
true
false
)
;
aWindow
.
dispatchEvent
(
event
)
;
}
_sendTabRestoredNotification
(
aTab
aIsRemotenessUpdate
)
{
let
event
=
aTab
.
ownerDocument
.
createEvent
(
"
CustomEvent
"
)
;
event
.
initCustomEvent
(
"
SSTabRestored
"
true
false
{
isRemotenessUpdate
:
aIsRemotenessUpdate
}
)
;
aTab
.
dispatchEvent
(
event
)
;
}
_isWindowLoaded
:
function
ssi_isWindowLoaded
(
aWindow
)
{
return
!
WINDOW_RESTORE_IDS
.
has
(
aWindow
)
;
}
_capClosedWindows
:
function
ssi_capClosedWindows
(
)
{
if
(
this
.
_closedWindows
.
length
<
=
this
.
_max_windows_undo
)
{
return
;
}
let
spliceTo
=
this
.
_max_windows_undo
;
if
(
AppConstants
.
platform
!
=
"
macosx
"
)
{
let
normalWindowIndex
=
0
;
while
(
normalWindowIndex
<
this
.
_closedWindows
.
length
&
&
!
!
this
.
_closedWindows
[
normalWindowIndex
]
.
isPopup
)
{
normalWindowIndex
+
+
;
}
if
(
normalWindowIndex
>
=
this
.
_max_windows_undo
)
{
spliceTo
=
normalWindowIndex
+
1
;
}
}
if
(
spliceTo
<
this
.
_closedWindows
.
length
)
{
this
.
_closedWindows
.
splice
(
spliceTo
this
.
_closedWindows
.
length
)
;
this
.
_closedObjectsChanged
=
true
;
}
}
_clearRestoringWindows
:
function
ssi_clearRestoringWindows
(
)
{
for
(
let
i
=
0
;
i
<
this
.
_closedWindows
.
length
;
i
+
+
)
{
delete
this
.
_closedWindows
[
i
]
.
_shouldRestore
;
}
}
_resetRestoringState
:
function
ssi_initRestoringState
(
)
{
TabRestoreQueue
.
reset
(
)
;
this
.
_tabsRestoringCount
=
0
;
}
_resetLocalTabRestoringState
(
aTab
)
{
let
browser
=
aTab
.
linkedBrowser
;
let
previousState
=
TAB_STATE_FOR_BROWSER
.
get
(
browser
)
;
if
(
!
previousState
)
{
Cu
.
reportError
(
"
Given
tab
is
not
restoring
.
"
)
;
return
;
}
TAB_STATE_FOR_BROWSER
.
delete
(
browser
)
;
if
(
Services
.
appinfo
.
sessionHistoryInParent
)
{
this
.
_restoreListeners
.
get
(
browser
.
permanentKey
)
?
.
unregister
(
)
;
browser
.
browsingContext
.
clearRestoreState
(
)
;
}
aTab
.
removeAttribute
(
"
pending
"
)
;
if
(
previousState
=
=
TAB_STATE_RESTORING
)
{
if
(
this
.
_tabsRestoringCount
)
{
this
.
_tabsRestoringCount
-
-
;
}
}
else
if
(
previousState
=
=
TAB_STATE_NEEDS_RESTORE
)
{
TabRestoreQueue
.
remove
(
aTab
)
;
}
}
_resetTabRestoringState
(
tab
)
{
let
browser
=
tab
.
linkedBrowser
;
if
(
!
TAB_STATE_FOR_BROWSER
.
has
(
browser
)
)
{
Cu
.
reportError
(
"
Given
tab
is
not
restoring
.
"
)
;
return
;
}
if
(
!
Services
.
appinfo
.
sessionHistoryInParent
)
{
browser
.
messageManager
.
sendAsyncMessage
(
"
SessionStore
:
resetRestore
"
{
}
)
;
}
this
.
_resetLocalTabRestoringState
(
tab
)
;
}
startNextEpoch
(
permanentKey
)
{
let
next
=
this
.
getCurrentEpoch
(
permanentKey
)
+
1
;
this
.
_browserEpochs
.
set
(
permanentKey
next
)
;
return
next
;
}
getCurrentEpoch
(
permanentKey
)
{
return
this
.
_browserEpochs
.
get
(
permanentKey
)
|
|
0
;
}
isCurrentEpoch
(
permanentKey
epoch
)
{
return
this
.
getCurrentEpoch
(
permanentKey
)
=
=
epoch
;
}
resetEpoch
(
permanentKey
frameLoader
=
null
)
{
this
.
_browserEpochs
.
delete
(
permanentKey
)
;
if
(
frameLoader
)
{
frameLoader
.
requestEpochUpdate
(
0
)
;
}
}
looseTimer
(
delay
)
{
let
DELAY_BEAT
=
1000
;
let
timer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
let
beats
=
Math
.
ceil
(
delay
/
DELAY_BEAT
)
;
let
deferred
=
lazy
.
PromiseUtils
.
defer
(
)
;
timer
.
initWithCallback
(
function
(
)
{
if
(
beats
<
=
0
)
{
deferred
.
resolve
(
)
;
}
-
-
beats
;
}
DELAY_BEAT
Ci
.
nsITimer
.
TYPE_REPEATING_PRECISE_CAN_SKIP
)
;
deferred
.
promise
.
then
(
(
)
=
>
timer
.
cancel
(
)
(
)
=
>
timer
.
cancel
(
)
)
;
return
deferred
;
}
buildRestoreData
(
formdata
scroll
)
{
function
addFormEntries
(
root
fields
isXpath
)
{
for
(
let
[
key
value
]
of
Object
.
entries
(
fields
)
)
{
switch
(
typeof
value
)
{
case
"
string
"
:
root
.
addTextField
(
isXpath
key
value
)
;
break
;
case
"
boolean
"
:
root
.
addCheckbox
(
isXpath
key
value
)
;
break
;
case
"
object
"
:
{
if
(
value
=
=
=
null
)
{
break
;
}
if
(
value
.
hasOwnProperty
(
"
type
"
)
&
&
value
.
hasOwnProperty
(
"
fileList
"
)
)
{
root
.
addFileList
(
isXpath
key
value
.
type
value
.
fileList
)
;
break
;
}
if
(
value
.
hasOwnProperty
(
"
selectedIndex
"
)
&
&
value
.
hasOwnProperty
(
"
value
"
)
)
{
root
.
addSingleSelect
(
isXpath
key
value
.
selectedIndex
value
.
value
)
;
break
;
}
if
(
key
=
=
=
"
sessionData
"
&
&
[
"
about
:
sessionrestore
"
"
about
:
welcomeback
"
]
.
includes
(
formdata
.
url
)
)
{
root
.
addTextField
(
isXpath
key
JSON
.
stringify
(
value
)
)
;
break
;
}
if
(
Array
.
isArray
(
value
)
)
{
root
.
addMultipleSelect
(
isXpath
key
value
)
;
break
;
}
}
}
}
}
let
root
=
SessionStoreUtils
.
constructSessionStoreRestoreData
(
)
;
if
(
scroll
?
.
hasOwnProperty
(
"
scroll
"
)
)
{
root
.
scroll
=
scroll
.
scroll
;
}
if
(
formdata
?
.
hasOwnProperty
(
"
url
"
)
)
{
root
.
url
=
formdata
.
url
;
if
(
formdata
.
hasOwnProperty
(
"
innerHTML
"
)
)
{
root
.
innerHTML
=
formdata
.
innerHTML
;
}
if
(
formdata
.
hasOwnProperty
(
"
xpath
"
)
)
{
addFormEntries
(
root
formdata
.
xpath
true
)
;
}
if
(
formdata
.
hasOwnProperty
(
"
id
"
)
)
{
addFormEntries
(
root
formdata
.
id
false
)
;
}
}
let
childrenLength
=
Math
.
max
(
scroll
?
.
children
?
.
length
|
|
0
formdata
?
.
children
?
.
length
|
|
0
)
;
for
(
let
i
=
0
;
i
<
childrenLength
;
i
+
+
)
{
root
.
addChild
(
this
.
buildRestoreData
(
formdata
?
.
children
?
.
[
i
]
scroll
?
.
children
?
.
[
i
]
)
i
)
;
}
return
root
;
}
_waitForStateStop
(
browser
expectedURL
=
null
)
{
const
deferred
=
lazy
.
PromiseUtils
.
defer
(
)
;
const
listener
=
{
unregister
(
reject
=
true
)
{
if
(
reject
)
{
deferred
.
reject
(
)
;
}
SessionStoreInternal
.
_restoreListeners
.
delete
(
browser
.
permanentKey
)
;
try
{
browser
.
removeProgressListener
(
this
Ci
.
nsIWebProgress
.
NOTIFY_STATE_WINDOW
)
;
}
catch
{
}
}
onStateChange
(
webProgress
request
stateFlags
status
)
{
if
(
webProgress
.
isTopLevel
&
&
stateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_IS_WINDOW
&
&
stateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_STOP
)
{
let
aboutBlankOK
=
!
expectedURL
|
|
expectedURL
=
=
=
"
about
:
blank
"
;
let
url
=
request
.
QueryInterface
(
Ci
.
nsIChannel
)
.
originalURI
.
spec
;
if
(
url
!
=
=
"
about
:
blank
"
|
|
aboutBlankOK
)
{
this
.
unregister
(
false
)
;
deferred
.
resolve
(
)
;
}
}
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIWebProgressListener
"
"
nsISupportsWeakReference
"
]
)
}
;
this
.
_restoreListeners
.
get
(
browser
.
permanentKey
)
?
.
unregister
(
)
;
this
.
_restoreListeners
.
set
(
browser
.
permanentKey
listener
)
;
browser
.
addProgressListener
(
listener
Ci
.
nsIWebProgress
.
NOTIFY_STATE_WINDOW
)
;
return
deferred
.
promise
;
}
_listenForNavigations
(
browser
callbacks
)
{
const
listener
=
{
unregister
(
)
{
browser
.
browsingContext
?
.
sessionHistory
?
.
removeSHistoryListener
(
this
)
;
try
{
browser
.
removeProgressListener
(
this
Ci
.
nsIWebProgress
.
NOTIFY_STATE_WINDOW
)
;
}
catch
{
}
SessionStoreInternal
.
_restoreListeners
.
delete
(
browser
.
permanentKey
)
;
}
OnHistoryReload
(
)
{
this
.
unregister
(
)
;
return
callbacks
.
onHistoryReload
(
)
;
}
OnHistoryNewEntry
(
)
{
}
OnHistoryGotoIndex
(
)
{
}
OnHistoryPurge
(
)
{
}
OnHistoryReplaceEntry
(
)
{
}
onStateChange
(
webProgress
request
stateFlags
status
)
{
if
(
webProgress
.
isTopLevel
&
&
stateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_IS_WINDOW
&
&
stateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_START
)
{
this
.
unregister
(
)
;
callbacks
.
onStartRequest
(
)
;
}
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsISHistoryListener
"
"
nsIWebProgressListener
"
"
nsISupportsWeakReference
"
]
)
}
;
this
.
_restoreListeners
.
get
(
browser
.
permanentKey
)
?
.
unregister
(
)
;
this
.
_restoreListeners
.
set
(
browser
.
permanentKey
listener
)
;
browser
.
browsingContext
?
.
sessionHistory
?
.
addSHistoryListener
(
listener
)
;
browser
.
addProgressListener
(
listener
Ci
.
nsIWebProgress
.
NOTIFY_STATE_WINDOW
)
;
}
_restoreHistory
(
browser
data
)
{
if
(
!
Services
.
appinfo
.
sessionHistoryInParent
)
{
throw
new
Error
(
"
This
function
should
only
be
used
with
SHIP
"
)
;
}
this
.
_tabStateToRestore
.
set
(
browser
.
permanentKey
data
)
;
browser
.
stop
(
)
;
lazy
.
SessionHistory
.
restoreFromParent
(
browser
.
browsingContext
.
sessionHistory
data
.
tabData
)
;
let
url
=
data
.
tabData
?
.
entries
[
data
.
tabData
.
index
-
1
]
?
.
url
;
let
disallow
=
data
.
tabData
?
.
disallow
;
let
promise
=
SessionStoreUtils
.
restoreDocShellState
(
browser
.
browsingContext
url
disallow
)
;
this
.
_tabStateRestorePromises
.
set
(
browser
.
permanentKey
promise
)
;
const
onResolve
=
(
)
=
>
{
if
(
TAB_STATE_FOR_BROWSER
.
get
(
browser
)
!
=
=
TAB_STATE_RESTORING
)
{
this
.
_listenForNavigations
(
browser
{
onHistoryReload
:
(
)
=
>
{
this
.
_restoreTabContent
(
browser
)
;
return
false
;
}
onStartRequest
:
(
)
=
>
{
this
.
_tabStateToRestore
.
delete
(
browser
.
permanentKey
)
;
this
.
_restoreTabContent
(
browser
)
;
}
}
)
;
}
this
.
_tabStateRestorePromises
.
delete
(
browser
.
permanentKey
)
;
this
.
_restoreHistoryComplete
(
browser
data
)
;
}
;
promise
.
then
(
onResolve
)
.
catch
(
(
)
=
>
{
}
)
;
}
_restoreTabEntry
(
browser
tabData
)
{
let
url
=
"
about
:
blank
"
;
let
loadFlags
=
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_BYPASS_HISTORY
;
if
(
tabData
.
userTypedValue
&
&
tabData
.
userTypedClear
)
{
url
=
tabData
.
userTypedValue
;
loadFlags
=
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP
;
}
else
if
(
tabData
.
entries
.
length
)
{
return
SessionStoreUtils
.
initializeRestore
(
browser
.
browsingContext
this
.
buildRestoreData
(
tabData
.
formdata
tabData
.
scroll
)
)
;
}
let
loadPromise
=
this
.
_waitForStateStop
(
browser
url
)
;
browser
.
browsingContext
.
loadURI
(
url
{
loadFlags
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
}
)
;
return
loadPromise
;
}
_restoreTabContent
(
browser
options
=
{
}
)
{
if
(
!
Services
.
appinfo
.
sessionHistoryInParent
)
{
throw
new
Error
(
"
This
function
should
only
be
used
with
SHIP
"
)
;
}
this
.
_restoreListeners
.
get
(
browser
.
permanentKey
)
?
.
unregister
(
)
;
this
.
_restoreTabContentStarted
(
browser
options
)
;
let
state
=
this
.
_tabStateToRestore
.
get
(
browser
.
permanentKey
)
;
this
.
_tabStateToRestore
.
delete
(
browser
.
permanentKey
)
;
let
promises
=
[
this
.
_tabStateRestorePromises
.
get
(
browser
.
permanentKey
)
]
;
if
(
state
)
{
promises
.
push
(
this
.
_restoreTabEntry
(
browser
state
.
tabData
)
)
;
}
else
{
promises
.
push
(
this
.
_waitForStateStop
(
browser
)
)
;
}
Promise
.
allSettled
(
promises
)
.
then
(
(
)
=
>
{
this
.
_restoreTabContentComplete
(
browser
options
)
;
}
)
;
}
_sendRestoreTabContent
(
browser
options
)
{
if
(
Services
.
appinfo
.
sessionHistoryInParent
)
{
this
.
_restoreTabContent
(
browser
options
)
;
}
else
{
browser
.
messageManager
.
sendAsyncMessage
(
"
SessionStore
:
restoreTabContent
"
options
)
;
}
}
_restoreHistoryComplete
(
browser
data
)
{
let
win
=
browser
.
ownerGlobal
;
let
tab
=
win
?
.
gBrowser
.
getTabForBrowser
(
browser
)
;
if
(
!
tab
)
{
return
;
}
let
tabData
=
lazy
.
TabState
.
collect
(
tab
TAB_CUSTOM_VALUES
.
get
(
tab
)
)
;
this
.
updateTabLabelAndIcon
(
tab
tabData
)
;
let
event
=
win
.
document
.
createEvent
(
"
Events
"
)
;
event
.
initEvent
(
"
SSTabRestoring
"
true
false
)
;
tab
.
dispatchEvent
(
event
)
;
}
_restoreTabContentStarted
(
browser
data
)
{
let
win
=
browser
.
ownerGlobal
;
let
tab
=
win
?
.
gBrowser
.
getTabForBrowser
(
browser
)
;
if
(
!
tab
)
{
return
;
}
let
initiatedBySessionStore
=
TAB_STATE_FOR_BROWSER
.
get
(
browser
)
!
=
TAB_STATE_NEEDS_RESTORE
;
let
isNavigateAndRestore
=
data
.
reason
=
=
RESTORE_TAB_CONTENT_REASON
.
NAVIGATE_AND_RESTORE
;
let
cacheState
=
lazy
.
TabStateCache
.
get
(
browser
.
permanentKey
)
;
if
(
cacheState
.
searchMode
)
{
if
(
!
initiatedBySessionStore
|
|
isNavigateAndRestore
)
{
lazy
.
TabStateCache
.
update
(
browser
.
permanentKey
{
searchMode
:
null
userTypedValue
:
null
}
)
;
}
return
;
}
if
(
!
initiatedBySessionStore
)
{
this
.
markTabAsRestoring
(
tab
)
;
}
else
if
(
!
isNavigateAndRestore
)
{
let
tabData
=
lazy
.
TabState
.
collect
(
tab
TAB_CUSTOM_VALUES
.
get
(
tab
)
)
;
if
(
tabData
.
userTypedValue
&
&
!
tabData
.
userTypedClear
&
&
!
browser
.
userTypedValue
)
{
browser
.
userTypedValue
=
tabData
.
userTypedValue
;
if
(
tab
.
selected
)
{
win
.
gURLBar
.
setURI
(
)
;
}
}
lazy
.
TabStateCache
.
update
(
browser
.
permanentKey
{
userTypedValue
:
null
userTypedClear
:
null
}
)
;
}
}
_restoreTabContentComplete
(
browser
data
)
{
let
win
=
browser
.
ownerGlobal
;
let
tab
=
browser
.
ownerGlobal
?
.
gBrowser
.
getTabForBrowser
(
browser
)
;
if
(
!
tab
)
{
return
;
}
let
cacheState
=
lazy
.
TabStateCache
.
get
(
browser
.
permanentKey
)
;
if
(
cacheState
.
searchMode
)
{
win
.
gURLBar
.
setSearchMode
(
cacheState
.
searchMode
browser
)
;
browser
.
userTypedValue
=
cacheState
.
userTypedValue
;
if
(
tab
.
selected
)
{
win
.
gURLBar
.
setURI
(
)
;
}
lazy
.
TabStateCache
.
update
(
browser
.
permanentKey
{
searchMode
:
null
userTypedValue
:
null
}
)
;
}
if
(
gDebuggingEnabled
)
{
Services
.
obs
.
notifyObservers
(
browser
NOTIFY_TAB_RESTORED
)
;
}
SessionStoreInternal
.
_resetLocalTabRestoringState
(
tab
)
;
SessionStoreInternal
.
restoreNextTab
(
)
;
this
.
_sendTabRestoredNotification
(
tab
data
.
isRemotenessUpdate
)
;
Services
.
obs
.
notifyObservers
(
null
"
sessionstore
-
one
-
or
-
no
-
tab
-
restored
"
)
;
}
_sendRestoreHistory
(
browser
options
)
{
if
(
options
.
tabData
.
storage
)
{
SessionStoreUtils
.
restoreSessionStorageFromParent
(
browser
.
browsingContext
options
.
tabData
.
storage
)
;
delete
options
.
tabData
.
storage
;
}
if
(
Services
.
appinfo
.
sessionHistoryInParent
)
{
this
.
_restoreHistory
(
browser
options
)
;
}
else
{
browser
.
messageManager
.
sendAsyncMessage
(
"
SessionStore
:
restoreHistory
"
options
)
;
}
if
(
browser
&
&
browser
.
frameLoader
)
{
browser
.
frameLoader
.
requestEpochUpdate
(
options
.
epoch
)
;
}
}
async
prepareToChangeRemoteness
(
aBrowser
)
{
aBrowser
.
messageManager
.
sendAsyncMessage
(
"
SessionStore
:
prepareForProcessChange
"
)
;
await
lazy
.
TabStateFlusher
.
flush
(
aBrowser
)
;
}
finishTabRemotenessChange
(
aTab
aSwitchId
)
{
let
window
=
aTab
.
ownerGlobal
;
if
(
!
window
|
|
!
window
.
__SSi
|
|
window
.
closed
)
{
return
;
}
let
tabState
=
lazy
.
TabState
.
clone
(
aTab
TAB_CUSTOM_VALUES
.
get
(
aTab
)
)
;
let
options
=
{
restoreImmediately
:
true
restoreContentReason
:
RESTORE_TAB_CONTENT_REASON
.
NAVIGATE_AND_RESTORE
isRemotenessUpdate
:
true
loadArguments
:
{
redirectLoadSwitchId
:
aSwitchId
redirectHistoryIndex
:
tabState
.
requestedIndex
-
1
}
}
;
if
(
TAB_STATE_FOR_BROWSER
.
has
(
aTab
.
linkedBrowser
)
)
{
this
.
_resetLocalTabRestoringState
(
aTab
)
;
}
this
.
restoreTab
(
aTab
tabState
options
)
;
}
}
;
var
TabRestoreQueue
=
{
tabs
:
{
priority
:
[
]
visible
:
[
]
hidden
:
[
]
}
prefs
:
{
get
restoreOnDemand
(
)
{
let
updateValue
=
(
)
=
>
{
let
value
=
Services
.
prefs
.
getBoolPref
(
PREF
)
;
let
definition
=
{
value
configurable
:
true
}
;
Object
.
defineProperty
(
this
"
restoreOnDemand
"
definition
)
;
return
value
;
}
;
const
PREF
=
"
browser
.
sessionstore
.
restore_on_demand
"
;
Services
.
prefs
.
addObserver
(
PREF
updateValue
)
;
return
updateValue
(
)
;
}
get
restorePinnedTabsOnDemand
(
)
{
let
updateValue
=
(
)
=
>
{
let
value
=
Services
.
prefs
.
getBoolPref
(
PREF
)
;
let
definition
=
{
value
configurable
:
true
}
;
Object
.
defineProperty
(
this
"
restorePinnedTabsOnDemand
"
definition
)
;
return
value
;
}
;
const
PREF
=
"
browser
.
sessionstore
.
restore_pinned_tabs_on_demand
"
;
Services
.
prefs
.
addObserver
(
PREF
updateValue
)
;
return
updateValue
(
)
;
}
get
restoreHiddenTabs
(
)
{
let
updateValue
=
(
)
=
>
{
let
value
=
Services
.
prefs
.
getBoolPref
(
PREF
)
;
let
definition
=
{
value
configurable
:
true
}
;
Object
.
defineProperty
(
this
"
restoreHiddenTabs
"
definition
)
;
return
value
;
}
;
const
PREF
=
"
browser
.
sessionstore
.
restore_hidden_tabs
"
;
Services
.
prefs
.
addObserver
(
PREF
updateValue
)
;
return
updateValue
(
)
;
}
}
reset
(
)
{
this
.
tabs
=
{
priority
:
[
]
visible
:
[
]
hidden
:
[
]
}
;
}
add
(
tab
)
{
let
{
priority
hidden
visible
}
=
this
.
tabs
;
if
(
tab
.
pinned
)
{
priority
.
push
(
tab
)
;
}
else
if
(
tab
.
hidden
)
{
hidden
.
push
(
tab
)
;
}
else
{
visible
.
push
(
tab
)
;
}
}
remove
(
tab
)
{
let
{
priority
hidden
visible
}
=
this
.
tabs
;
let
set
=
priority
;
let
index
=
set
.
indexOf
(
tab
)
;
if
(
index
=
=
-
1
)
{
set
=
tab
.
hidden
?
hidden
:
visible
;
index
=
set
.
indexOf
(
tab
)
;
}
if
(
index
>
-
1
)
{
set
.
splice
(
index
1
)
;
}
}
shift
(
)
{
let
set
;
let
{
priority
hidden
visible
}
=
this
.
tabs
;
let
{
restoreOnDemand
restorePinnedTabsOnDemand
}
=
this
.
prefs
;
let
restorePinned
=
!
(
restoreOnDemand
&
&
restorePinnedTabsOnDemand
)
;
if
(
restorePinned
&
&
priority
.
length
)
{
set
=
priority
;
}
else
if
(
!
restoreOnDemand
)
{
if
(
visible
.
length
)
{
set
=
visible
;
}
else
if
(
this
.
prefs
.
restoreHiddenTabs
&
&
hidden
.
length
)
{
set
=
hidden
;
}
}
return
set
&
&
set
.
shift
(
)
;
}
hiddenToVisible
(
tab
)
{
let
{
hidden
visible
}
=
this
.
tabs
;
let
index
=
hidden
.
indexOf
(
tab
)
;
if
(
index
>
-
1
)
{
hidden
.
splice
(
index
1
)
;
visible
.
push
(
tab
)
;
}
}
visibleToHidden
(
tab
)
{
let
{
visible
hidden
}
=
this
.
tabs
;
let
index
=
visible
.
indexOf
(
tab
)
;
if
(
index
>
-
1
)
{
visible
.
splice
(
index
1
)
;
hidden
.
push
(
tab
)
;
}
}
willRestoreSoon
(
tab
)
{
let
{
priority
hidden
visible
}
=
this
.
tabs
;
let
{
restoreOnDemand
restorePinnedTabsOnDemand
restoreHiddenTabs
}
=
this
.
prefs
;
let
restorePinned
=
!
(
restoreOnDemand
&
&
restorePinnedTabsOnDemand
)
;
let
candidateSet
=
[
]
;
if
(
restorePinned
&
&
priority
.
length
)
{
candidateSet
.
push
(
.
.
.
priority
)
;
}
if
(
!
restoreOnDemand
)
{
if
(
visible
.
length
)
{
candidateSet
.
push
(
.
.
.
visible
)
;
}
if
(
restoreHiddenTabs
&
&
hidden
.
length
)
{
candidateSet
.
push
(
.
.
.
hidden
)
;
}
}
return
candidateSet
.
indexOf
(
tab
)
>
-
1
;
}
}
;
var
DyingWindowCache
=
{
_data
:
new
WeakMap
(
)
has
(
window
)
{
return
this
.
_data
.
has
(
window
)
;
}
get
(
window
)
{
return
this
.
_data
.
get
(
window
)
;
}
set
(
window
data
)
{
this
.
_data
.
set
(
window
data
)
;
}
remove
(
window
)
{
this
.
_data
.
delete
(
window
)
;
}
}
;
var
DirtyWindows
=
{
_data
:
new
WeakMap
(
)
has
(
window
)
{
return
this
.
_data
.
has
(
window
)
;
}
add
(
window
)
{
return
this
.
_data
.
set
(
window
true
)
;
}
remove
(
window
)
{
this
.
_data
.
delete
(
window
)
;
}
clear
(
window
)
{
this
.
_data
=
new
WeakMap
(
)
;
}
}
;
var
LastSession
=
{
_state
:
null
get
canRestore
(
)
{
return
!
!
this
.
_state
;
}
getState
(
)
{
return
this
.
_state
;
}
setState
(
state
)
{
this
.
_state
=
state
;
}
clear
(
silent
=
false
)
{
if
(
this
.
_state
)
{
this
.
_state
=
null
;
if
(
!
silent
)
{
Services
.
obs
.
notifyObservers
(
null
NOTIFY_LAST_SESSION_CLEARED
)
;
}
}
}
}
;
const
_LastSession
=
LastSession
;
