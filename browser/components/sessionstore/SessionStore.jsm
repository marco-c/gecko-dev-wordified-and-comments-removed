"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
SessionStore
"
]
;
const
FORMAT_VERSION
=
1
;
const
TAB_CUSTOM_VALUES
=
new
WeakMap
(
)
;
const
TAB_LAZY_STATES
=
new
WeakMap
(
)
;
const
TAB_STATE_NEEDS_RESTORE
=
1
;
const
TAB_STATE_RESTORING
=
2
;
const
TAB_STATE_WILL_RESTORE
=
3
;
const
TAB_STATE_FOR_BROWSER
=
new
WeakMap
(
)
;
const
WINDOW_RESTORE_IDS
=
new
WeakMap
(
)
;
const
WINDOW_RESTORE_ZINDICES
=
new
WeakMap
(
)
;
const
WINDOW_SHOWING_PROMISES
=
new
Map
(
)
;
const
NOTIFY_SINGLE_WINDOW_RESTORED
=
"
sessionstore
-
single
-
window
-
restored
"
;
const
NOTIFY_WINDOWS_RESTORED
=
"
sessionstore
-
windows
-
restored
"
;
const
NOTIFY_BROWSER_STATE_RESTORED
=
"
sessionstore
-
browser
-
state
-
restored
"
;
const
NOTIFY_LAST_SESSION_CLEARED
=
"
sessionstore
-
last
-
session
-
cleared
"
;
const
NOTIFY_RESTORING_ON_STARTUP
=
"
sessionstore
-
restoring
-
on
-
startup
"
;
const
NOTIFY_INITIATING_MANUAL_RESTORE
=
"
sessionstore
-
initiating
-
manual
-
restore
"
;
const
NOTIFY_CLOSED_OBJECTS_CHANGED
=
"
sessionstore
-
closed
-
objects
-
changed
"
;
const
NOTIFY_TAB_RESTORED
=
"
sessionstore
-
debug
-
tab
-
restored
"
;
const
NOTIFY_DOMWINDOWCLOSED_HANDLED
=
"
sessionstore
-
debug
-
domwindowclosed
-
handled
"
;
const
MAX_CONCURRENT_TAB_RESTORES
=
3
;
const
SCREEN_EDGE_SLOP
=
8
;
const
OBSERVING
=
[
"
browser
-
window
-
before
-
show
"
"
domwindowclosed
"
"
quit
-
application
-
granted
"
"
browser
-
lastwindow
-
close
-
granted
"
"
quit
-
application
"
"
browser
:
purge
-
session
-
history
"
"
browser
:
purge
-
session
-
history
-
for
-
domain
"
"
idle
-
daily
"
"
clear
-
origin
-
attributes
-
data
"
"
http
-
on
-
examine
-
response
"
"
http
-
on
-
examine
-
merged
-
response
"
"
http
-
on
-
examine
-
cached
-
response
"
]
;
const
WINDOW_ATTRIBUTES
=
[
"
width
"
"
height
"
"
screenX
"
"
screenY
"
"
sizemode
"
]
;
const
WINDOW_HIDEABLE_FEATURES
=
[
"
menubar
"
"
toolbar
"
"
locationbar
"
"
personalbar
"
"
statusbar
"
"
scrollbars
"
]
;
const
MESSAGES
=
[
"
SessionStore
:
update
"
"
SessionStore
:
restoreHistoryComplete
"
"
SessionStore
:
restoreTabContentStarted
"
"
SessionStore
:
restoreTabContentComplete
"
"
SessionStore
:
crashedTabRevived
"
"
SessionStore
:
error
"
]
;
const
NOTAB_MESSAGES
=
new
Set
(
[
"
SessionStore
:
crashedTabRevived
"
"
SessionStore
:
update
"
"
SessionStore
:
error
"
]
)
;
const
NOEPOCH_MESSAGES
=
new
Set
(
[
"
SessionStore
:
crashedTabRevived
"
"
SessionStore
:
error
"
]
)
;
const
CLOSED_MESSAGES
=
new
Set
(
[
"
SessionStore
:
crashedTabRevived
"
"
SessionStore
:
update
"
"
SessionStore
:
error
"
]
)
;
const
TAB_EVENTS
=
[
"
TabOpen
"
"
TabBrowserInserted
"
"
TabClose
"
"
TabSelect
"
"
TabShow
"
"
TabHide
"
"
TabPinned
"
"
TabUnpinned
"
]
;
const
NS_XUL
=
"
http
:
/
/
www
.
mozilla
.
org
/
keymaster
/
gatekeeper
/
there
.
is
.
only
.
xul
"
;
const
RESTORE_TAB_CONTENT_REASON
=
{
SET_STATE
:
0
NAVIGATE_AND_RESTORE
:
1
}
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryTimestamps
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
this
)
;
XPCOMUtils
.
defineLazyServiceGetters
(
this
{
gScreenManager
:
[
"
mozilla
.
org
/
gfx
/
screenmanager
;
1
"
"
nsIScreenManager
"
]
Telemetry
:
[
"
mozilla
.
org
/
base
/
telemetry
;
1
"
"
nsITelemetry
"
]
}
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AppConstants
:
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
AsyncShutdown
:
"
resource
:
/
/
gre
/
modules
/
AsyncShutdown
.
jsm
"
BrowserWindowTracker
:
"
resource
:
/
/
/
modules
/
BrowserWindowTracker
.
jsm
"
DevToolsShim
:
"
chrome
:
/
/
devtools
-
startup
/
content
/
DevToolsShim
.
jsm
"
E10SUtils
:
"
resource
:
/
/
gre
/
modules
/
E10SUtils
.
jsm
"
GlobalState
:
"
resource
:
/
/
/
modules
/
sessionstore
/
GlobalState
.
jsm
"
HomePage
:
"
resource
:
/
/
/
modules
/
HomePage
.
jsm
"
PrivacyFilter
:
"
resource
:
/
/
gre
/
modules
/
sessionstore
/
PrivacyFilter
.
jsm
"
PromiseUtils
:
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
RunState
:
"
resource
:
/
/
/
modules
/
sessionstore
/
RunState
.
jsm
"
SessionCookies
:
"
resource
:
/
/
/
modules
/
sessionstore
/
SessionCookies
.
jsm
"
SessionFile
:
"
resource
:
/
/
/
modules
/
sessionstore
/
SessionFile
.
jsm
"
SessionSaver
:
"
resource
:
/
/
/
modules
/
sessionstore
/
SessionSaver
.
jsm
"
SessionStartup
:
"
resource
:
/
/
/
modules
/
sessionstore
/
SessionStartup
.
jsm
"
TabAttributes
:
"
resource
:
/
/
/
modules
/
sessionstore
/
TabAttributes
.
jsm
"
TabCrashHandler
:
"
resource
:
/
/
/
modules
/
ContentCrashHandlers
.
jsm
"
TabState
:
"
resource
:
/
/
/
modules
/
sessionstore
/
TabState
.
jsm
"
TabStateCache
:
"
resource
:
/
/
/
modules
/
sessionstore
/
TabStateCache
.
jsm
"
TabStateFlusher
:
"
resource
:
/
/
/
modules
/
sessionstore
/
TabStateFlusher
.
jsm
"
Utils
:
"
resource
:
/
/
gre
/
modules
/
sessionstore
/
Utils
.
jsm
"
ViewSourceBrowser
:
"
resource
:
/
/
gre
/
modules
/
ViewSourceBrowser
.
jsm
"
setTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
}
)
;
var
gDebuggingEnabled
=
false
;
function
debug
(
aMsg
)
{
if
(
gDebuggingEnabled
)
{
aMsg
=
(
"
SessionStore
:
"
+
aMsg
)
.
replace
(
/
\
S
{
80
}
/
g
"
&
\
n
"
)
;
Services
.
console
.
logStringMessage
(
aMsg
)
;
}
}
var
gResistFingerprintingEnabled
=
false
;
var
SessionStore
=
{
get
promiseInitialized
(
)
{
return
SessionStoreInternal
.
promiseInitialized
;
}
get
promiseAllWindowsRestored
(
)
{
return
SessionStoreInternal
.
promiseAllWindowsRestored
;
}
get
canRestoreLastSession
(
)
{
return
SessionStoreInternal
.
canRestoreLastSession
;
}
set
canRestoreLastSession
(
val
)
{
SessionStoreInternal
.
canRestoreLastSession
=
val
;
}
get
lastClosedObjectType
(
)
{
return
SessionStoreInternal
.
lastClosedObjectType
;
}
init
:
function
ss_init
(
)
{
SessionStoreInternal
.
init
(
)
;
}
getBrowserState
:
function
ss_getBrowserState
(
)
{
return
SessionStoreInternal
.
getBrowserState
(
)
;
}
setBrowserState
:
function
ss_setBrowserState
(
aState
)
{
SessionStoreInternal
.
setBrowserState
(
aState
)
;
}
getWindowState
:
function
ss_getWindowState
(
aWindow
)
{
return
SessionStoreInternal
.
getWindowState
(
aWindow
)
;
}
setWindowState
:
function
ss_setWindowState
(
aWindow
aState
aOverwrite
)
{
SessionStoreInternal
.
setWindowState
(
aWindow
aState
aOverwrite
)
;
}
getTabState
:
function
ss_getTabState
(
aTab
)
{
return
SessionStoreInternal
.
getTabState
(
aTab
)
;
}
setTabState
:
function
ss_setTabState
(
aTab
aState
)
{
SessionStoreInternal
.
setTabState
(
aTab
aState
)
;
}
getInternalObjectState
(
obj
)
{
return
SessionStoreInternal
.
getInternalObjectState
(
obj
)
;
}
duplicateTab
:
function
ss_duplicateTab
(
aWindow
aTab
aDelta
=
0
aRestoreImmediately
=
true
)
{
return
SessionStoreInternal
.
duplicateTab
(
aWindow
aTab
aDelta
aRestoreImmediately
)
;
}
getClosedTabCount
:
function
ss_getClosedTabCount
(
aWindow
)
{
return
SessionStoreInternal
.
getClosedTabCount
(
aWindow
)
;
}
getClosedTabData
:
function
ss_getClosedTabData
(
aWindow
aAsString
=
true
)
{
return
SessionStoreInternal
.
getClosedTabData
(
aWindow
aAsString
)
;
}
undoCloseTab
:
function
ss_undoCloseTab
(
aWindow
aIndex
)
{
return
SessionStoreInternal
.
undoCloseTab
(
aWindow
aIndex
)
;
}
forgetClosedTab
:
function
ss_forgetClosedTab
(
aWindow
aIndex
)
{
return
SessionStoreInternal
.
forgetClosedTab
(
aWindow
aIndex
)
;
}
getClosedWindowCount
:
function
ss_getClosedWindowCount
(
)
{
return
SessionStoreInternal
.
getClosedWindowCount
(
)
;
}
getClosedWindowData
:
function
ss_getClosedWindowData
(
aAsString
=
true
)
{
return
SessionStoreInternal
.
getClosedWindowData
(
aAsString
)
;
}
undoCloseWindow
:
function
ss_undoCloseWindow
(
aIndex
)
{
return
SessionStoreInternal
.
undoCloseWindow
(
aIndex
)
;
}
forgetClosedWindow
:
function
ss_forgetClosedWindow
(
aIndex
)
{
return
SessionStoreInternal
.
forgetClosedWindow
(
aIndex
)
;
}
getCustomWindowValue
(
aWindow
aKey
)
{
return
SessionStoreInternal
.
getCustomWindowValue
(
aWindow
aKey
)
;
}
setCustomWindowValue
(
aWindow
aKey
aStringValue
)
{
SessionStoreInternal
.
setCustomWindowValue
(
aWindow
aKey
aStringValue
)
;
}
deleteCustomWindowValue
(
aWindow
aKey
)
{
SessionStoreInternal
.
deleteCustomWindowValue
(
aWindow
aKey
)
;
}
getCustomTabValue
(
aTab
aKey
)
{
return
SessionStoreInternal
.
getCustomTabValue
(
aTab
aKey
)
;
}
setCustomTabValue
(
aTab
aKey
aStringValue
)
{
SessionStoreInternal
.
setCustomTabValue
(
aTab
aKey
aStringValue
)
;
}
deleteCustomTabValue
(
aTab
aKey
)
{
SessionStoreInternal
.
deleteCustomTabValue
(
aTab
aKey
)
;
}
getLazyTabValue
(
aTab
aKey
)
{
return
SessionStoreInternal
.
getLazyTabValue
(
aTab
aKey
)
;
}
getCustomGlobalValue
(
aKey
)
{
return
SessionStoreInternal
.
getCustomGlobalValue
(
aKey
)
;
}
setCustomGlobalValue
(
aKey
aStringValue
)
{
SessionStoreInternal
.
setCustomGlobalValue
(
aKey
aStringValue
)
;
}
deleteCustomGlobalValue
(
aKey
)
{
SessionStoreInternal
.
deleteCustomGlobalValue
(
aKey
)
;
}
persistTabAttribute
:
function
ss_persistTabAttribute
(
aName
)
{
SessionStoreInternal
.
persistTabAttribute
(
aName
)
;
}
restoreLastSession
:
function
ss_restoreLastSession
(
)
{
SessionStoreInternal
.
restoreLastSession
(
)
;
}
speculativeConnectOnTabHover
(
tab
)
{
SessionStoreInternal
.
speculativeConnectOnTabHover
(
tab
)
;
}
getCurrentState
(
aUpdateAll
)
{
return
SessionStoreInternal
.
getCurrentState
(
aUpdateAll
)
;
}
reviveCrashedTab
(
aTab
)
{
return
SessionStoreInternal
.
reviveCrashedTab
(
aTab
)
;
}
reviveAllCrashedTabs
(
)
{
return
SessionStoreInternal
.
reviveAllCrashedTabs
(
)
;
}
navigateAndRestore
(
tab
loadArguments
historyIndex
)
{
return
SessionStoreInternal
.
navigateAndRestore
(
tab
loadArguments
historyIndex
)
;
}
getSessionHistory
(
tab
updatedCallback
)
{
return
SessionStoreInternal
.
getSessionHistory
(
tab
updatedCallback
)
;
}
undoCloseById
(
aClosedId
aIncludePrivate
)
{
return
SessionStoreInternal
.
undoCloseById
(
aClosedId
aIncludePrivate
)
;
}
resetBrowserToLazyState
(
tab
)
{
return
SessionStoreInternal
.
resetBrowserToLazyState
(
tab
)
;
}
isFormatVersionCompatible
(
version
)
{
if
(
!
version
)
{
return
false
;
}
if
(
!
Array
.
isArray
(
version
)
)
{
return
false
;
}
if
(
version
[
0
]
!
=
"
sessionrestore
"
)
{
return
false
;
}
let
number
=
Number
.
parseFloat
(
version
[
1
]
)
;
if
(
Number
.
isNaN
(
number
)
)
{
return
false
;
}
return
number
<
=
FORMAT_VERSION
;
}
keepOnlyWorthSavingTabs
(
aState
)
{
for
(
let
i
=
aState
.
windows
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
let
win
=
aState
.
windows
[
i
]
;
for
(
let
j
=
win
.
tabs
.
length
-
1
;
j
>
=
0
;
j
-
-
)
{
let
tab
=
win
.
tabs
[
j
]
;
if
(
!
SessionStoreInternal
.
_shouldSaveTab
(
tab
)
)
{
win
.
tabs
.
splice
(
j
1
)
;
if
(
win
.
selected
>
j
)
{
win
.
selected
-
-
;
}
}
}
if
(
!
win
.
tabs
.
length
)
{
aState
.
windows
.
splice
(
i
1
)
;
if
(
aState
.
selectedWindow
>
i
)
{
aState
.
selectedWindow
-
-
;
}
}
}
}
}
;
Object
.
freeze
(
SessionStore
)
;
var
SessionStoreInternal
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIObserver
Ci
.
nsISupportsWeakReference
]
)
_globalState
:
new
GlobalState
(
)
_nextClosedId
:
0
_switchIdMonotonic
:
0
_restoreCount
:
-
1
_browserEpochs
:
new
WeakMap
(
)
_crashedBrowsers
:
new
WeakSet
(
)
_lastKnownFrameLoader
:
new
WeakMap
(
)
_closedTabs
:
new
WeakMap
(
)
_closedWindowTabs
:
new
WeakMap
(
)
_saveableClosedWindowData
:
new
WeakSet
(
)
_remotenessChangingBrowsers
:
new
WeakMap
(
)
_browserSetState
:
false
_sessionStartTime
:
Date
.
now
(
)
_windows
:
{
}
_nextWindowID
:
0
_closedWindows
:
[
]
_statesToRestore
:
{
}
_recentCrashes
:
0
_restoreLastWindow
:
false
_tabsRestoringCount
:
0
_deferredInitialState
:
null
_closedObjectsChanged
:
false
_deferredInitialized
:
(
function
(
)
{
let
deferred
=
{
}
;
deferred
.
promise
=
new
Promise
(
(
resolve
reject
)
=
>
{
deferred
.
resolve
=
resolve
;
deferred
.
reject
=
reject
;
}
)
;
return
deferred
;
}
)
(
)
_sessionInitialized
:
false
_deferredAllWindowsRestored
:
(
function
(
)
{
let
deferred
=
{
}
;
deferred
.
promise
=
new
Promise
(
(
resolve
reject
)
=
>
{
deferred
.
resolve
=
resolve
;
deferred
.
reject
=
reject
;
}
)
;
return
deferred
;
}
)
(
)
get
promiseAllWindowsRestored
(
)
{
return
this
.
_deferredAllWindowsRestored
.
promise
;
}
_promiseReadyForInitialization
:
null
_windowBusyStates
:
new
WeakMap
(
)
get
promiseInitialized
(
)
{
return
this
.
_deferredInitialized
.
promise
;
}
get
canRestoreLastSession
(
)
{
return
LastSession
.
canRestore
;
}
set
canRestoreLastSession
(
val
)
{
if
(
!
val
)
{
LastSession
.
clear
(
)
;
}
}
get
lastClosedObjectType
(
)
{
if
(
this
.
_closedWindows
.
length
)
{
let
tabTimestamps
=
[
]
;
for
(
let
window
of
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
)
{
let
windowState
=
this
.
_windows
[
window
.
__SSi
]
;
if
(
windowState
&
&
windowState
.
_closedTabs
[
0
]
)
{
tabTimestamps
.
push
(
windowState
.
_closedTabs
[
0
]
.
closedAt
)
;
}
}
if
(
!
tabTimestamps
.
length
|
|
(
tabTimestamps
.
sort
(
(
a
b
)
=
>
b
-
a
)
[
0
]
<
this
.
_closedWindows
[
0
]
.
closedAt
)
)
{
return
"
window
"
;
}
}
return
"
tab
"
;
}
init
(
)
{
if
(
this
.
_initialized
)
{
throw
new
Error
(
"
SessionStore
.
init
(
)
must
only
be
called
once
!
"
)
;
}
TelemetryTimestamps
.
add
(
"
sessionRestoreInitialized
"
)
;
OBSERVING
.
forEach
(
function
(
aTopic
)
{
Services
.
obs
.
addObserver
(
this
aTopic
true
)
;
}
this
)
;
this
.
_initPrefs
(
)
;
this
.
_initialized
=
true
;
Telemetry
.
getHistogramById
(
"
FX_SESSION_RESTORE_PRIVACY_LEVEL
"
)
.
add
(
Services
.
prefs
.
getIntPref
(
"
browser
.
sessionstore
.
privacy_level
"
)
)
;
}
initSession
(
)
{
TelemetryStopwatch
.
start
(
"
FX_SESSION_RESTORE_STARTUP_INIT_SESSION_MS
"
)
;
let
state
;
let
ss
=
SessionStartup
;
if
(
ss
.
doRestore
(
)
|
|
ss
.
sessionType
=
=
ss
.
DEFER_SESSION
)
{
state
=
ss
.
state
;
}
if
(
state
)
{
try
{
if
(
ss
.
sessionType
=
=
ss
.
DEFER_SESSION
)
{
let
[
iniState
remainingState
]
=
this
.
_prepDataForDeferredRestore
(
state
)
;
if
(
iniState
.
windows
.
length
)
{
iniState
.
cookies
=
remainingState
.
cookies
;
delete
remainingState
.
cookies
;
state
=
iniState
;
}
else
{
state
=
null
;
}
if
(
remainingState
.
windows
.
length
)
{
LastSession
.
setState
(
remainingState
)
;
}
}
else
{
LastSession
.
setState
(
state
.
lastSessionState
)
;
if
(
ss
.
previousSessionCrashed
)
{
this
.
_recentCrashes
=
(
state
.
session
&
&
state
.
session
.
recentCrashes
|
|
0
)
+
1
;
if
(
this
.
_needsRestorePage
(
state
this
.
_recentCrashes
)
)
{
let
url
=
"
about
:
sessionrestore
"
;
let
formdata
=
{
id
:
{
sessionData
:
state
}
url
}
;
let
entry
=
{
url
triggeringPrincipal_base64
:
Utils
.
SERIALIZED_SYSTEMPRINCIPAL
}
;
state
=
{
windows
:
[
{
tabs
:
[
{
entries
:
[
entry
]
formdata
}
]
}
]
}
;
}
else
if
(
this
.
_hasSingleTabWithURL
(
state
.
windows
"
about
:
welcomeback
"
)
)
{
state
.
windows
[
0
]
.
tabs
[
0
]
.
entries
[
0
]
.
url
=
"
about
:
sessionrestore
"
;
state
.
windows
[
0
]
.
tabs
[
0
]
.
entries
[
0
]
.
triggeringPrincipal_base64
=
Utils
.
SERIALIZED_SYSTEMPRINCIPAL
;
}
}
this
.
_updateSessionStartTime
(
state
)
;
state
.
windows
.
forEach
(
function
(
aWindow
)
{
delete
aWindow
.
__lastSessionWindowID
;
}
)
;
}
}
catch
(
ex
)
{
debug
(
"
The
session
file
is
invalid
:
"
+
ex
)
;
}
}
if
(
!
RunState
.
isQuitting
&
&
this
.
_prefBranch
.
getBoolPref
(
"
sessionstore
.
resume_session_once
"
)
)
this
.
_prefBranch
.
setBoolPref
(
"
sessionstore
.
resume_session_once
"
false
)
;
TelemetryStopwatch
.
finish
(
"
FX_SESSION_RESTORE_STARTUP_INIT_SESSION_MS
"
)
;
return
state
;
}
_initPrefs
(
)
{
this
.
_prefBranch
=
Services
.
prefs
.
getBranch
(
"
browser
.
"
)
;
gDebuggingEnabled
=
this
.
_prefBranch
.
getBoolPref
(
"
sessionstore
.
debug
"
)
;
Services
.
prefs
.
addObserver
(
"
browser
.
sessionstore
.
debug
"
(
)
=
>
{
gDebuggingEnabled
=
this
.
_prefBranch
.
getBoolPref
(
"
sessionstore
.
debug
"
)
;
}
)
;
this
.
_max_tabs_undo
=
this
.
_prefBranch
.
getIntPref
(
"
sessionstore
.
max_tabs_undo
"
)
;
this
.
_prefBranch
.
addObserver
(
"
sessionstore
.
max_tabs_undo
"
this
true
)
;
this
.
_max_windows_undo
=
this
.
_prefBranch
.
getIntPref
(
"
sessionstore
.
max_windows_undo
"
)
;
this
.
_prefBranch
.
addObserver
(
"
sessionstore
.
max_windows_undo
"
this
true
)
;
this
.
_restore_on_demand
=
this
.
_prefBranch
.
getBoolPref
(
"
sessionstore
.
restore_on_demand
"
)
;
this
.
_prefBranch
.
addObserver
(
"
sessionstore
.
restore_on_demand
"
this
true
)
;
gResistFingerprintingEnabled
=
Services
.
prefs
.
getBoolPref
(
"
privacy
.
resistFingerprinting
"
)
;
Services
.
prefs
.
addObserver
(
"
privacy
.
resistFingerprinting
"
this
)
;
}
_uninit
:
function
ssi_uninit
(
)
{
if
(
!
this
.
_initialized
)
{
throw
new
Error
(
"
SessionStore
is
not
initialized
.
"
)
;
}
RunState
.
setClosing
(
)
;
if
(
this
.
_sessionInitialized
)
{
SessionSaver
.
run
(
)
;
}
TabRestoreQueue
.
reset
(
)
;
SessionSaver
.
cancel
(
)
;
}
observe
:
function
ssi_observe
(
aSubject
aTopic
aData
)
{
switch
(
aTopic
)
{
case
"
browser
-
window
-
before
-
show
"
:
this
.
onBeforeBrowserWindowShown
(
aSubject
)
;
break
;
case
"
domwindowclosed
"
:
this
.
onClose
(
aSubject
)
.
then
(
(
)
=
>
{
this
.
_notifyOfClosedObjectsChange
(
)
;
}
)
;
if
(
gDebuggingEnabled
)
{
Services
.
obs
.
notifyObservers
(
null
NOTIFY_DOMWINDOWCLOSED_HANDLED
)
;
}
break
;
case
"
quit
-
application
-
granted
"
:
let
syncShutdown
=
aData
=
=
"
syncShutdown
"
;
this
.
onQuitApplicationGranted
(
syncShutdown
)
;
break
;
case
"
browser
-
lastwindow
-
close
-
granted
"
:
this
.
onLastWindowCloseGranted
(
)
;
break
;
case
"
quit
-
application
"
:
this
.
onQuitApplication
(
aData
)
;
break
;
case
"
browser
:
purge
-
session
-
history
"
:
this
.
onPurgeSessionHistory
(
)
;
this
.
_notifyOfClosedObjectsChange
(
)
;
break
;
case
"
browser
:
purge
-
session
-
history
-
for
-
domain
"
:
this
.
onPurgeDomainData
(
aData
)
;
this
.
_notifyOfClosedObjectsChange
(
)
;
break
;
case
"
nsPref
:
changed
"
:
this
.
onPrefChange
(
aData
)
;
this
.
_notifyOfClosedObjectsChange
(
)
;
break
;
case
"
idle
-
daily
"
:
this
.
onIdleDaily
(
)
;
this
.
_notifyOfClosedObjectsChange
(
)
;
break
;
case
"
clear
-
origin
-
attributes
-
data
"
:
let
userContextId
=
0
;
try
{
userContextId
=
JSON
.
parse
(
aData
)
.
userContextId
;
}
catch
(
e
)
{
}
if
(
userContextId
)
{
this
.
_forgetTabsWithUserContextId
(
userContextId
)
;
}
break
;
case
"
http
-
on
-
examine
-
response
"
:
case
"
http
-
on
-
examine
-
cached
-
response
"
:
case
"
http
-
on
-
examine
-
merged
-
response
"
:
this
.
onExamineResponse
(
aSubject
)
;
break
;
}
}
receiveMessage
(
aMessage
)
{
var
browser
=
aMessage
.
target
;
let
win
=
browser
.
ownerGlobal
;
let
tab
=
win
?
win
.
gBrowser
.
getTabForBrowser
(
browser
)
:
null
;
if
(
!
tab
&
&
!
NOTAB_MESSAGES
.
has
(
aMessage
.
name
)
)
{
throw
new
Error
(
received
unexpected
message
'
{
aMessage
.
name
}
'
+
from
a
browser
that
has
no
tab
or
window
)
;
}
let
data
=
aMessage
.
data
|
|
{
}
;
let
hasEpoch
=
data
.
hasOwnProperty
(
"
epoch
"
)
;
if
(
!
hasEpoch
&
&
!
NOEPOCH_MESSAGES
.
has
(
aMessage
.
name
)
)
{
throw
new
Error
(
received
message
'
{
aMessage
.
name
}
'
without
an
epoch
)
;
}
if
(
hasEpoch
&
&
!
this
.
isCurrentEpoch
(
browser
data
.
epoch
)
)
{
return
;
}
switch
(
aMessage
.
name
)
{
case
"
SessionStore
:
update
"
:
let
frameLoader
=
browser
.
frameLoader
|
|
this
.
_lastKnownFrameLoader
.
get
(
browser
.
permanentKey
)
;
if
(
frameLoader
!
=
aMessage
.
targetFrameLoader
)
{
return
;
}
if
(
aMessage
.
data
.
isFinal
)
{
TabStateFlusher
.
resolveAll
(
browser
)
;
}
else
if
(
aMessage
.
data
.
flushID
)
{
TabStateFlusher
.
resolve
(
browser
aMessage
.
data
.
flushID
)
;
}
if
(
this
.
_crashedBrowsers
.
has
(
browser
.
permanentKey
)
)
{
return
;
}
TabState
.
update
(
browser
aMessage
.
data
)
;
this
.
saveStateDelayed
(
win
)
;
if
(
this
.
_closedTabs
.
has
(
browser
.
permanentKey
)
)
{
let
{
closedTabs
tabData
}
=
this
.
_closedTabs
.
get
(
browser
.
permanentKey
)
;
TabState
.
copyFromCache
(
browser
tabData
.
state
)
;
if
(
aMessage
.
data
.
isFinal
)
{
this
.
_closedTabs
.
delete
(
browser
.
permanentKey
)
;
delete
tabData
.
permanentKey
;
let
shouldSave
=
this
.
_shouldSaveTabState
(
tabData
.
state
)
;
let
index
=
closedTabs
.
indexOf
(
tabData
)
;
if
(
shouldSave
&
&
index
=
=
-
1
)
{
this
.
saveClosedTabData
(
closedTabs
tabData
)
;
}
else
if
(
!
shouldSave
&
&
index
>
-
1
)
{
this
.
removeClosedTabData
(
closedTabs
index
)
;
}
}
}
break
;
case
"
SessionStore
:
restoreHistoryComplete
"
:
{
let
tabData
=
TabState
.
collect
(
tab
TAB_CUSTOM_VALUES
.
get
(
tab
)
)
;
let
activePageData
=
tabData
.
entries
[
tabData
.
index
-
1
]
|
|
null
;
let
uri
=
activePageData
?
activePageData
.
url
|
|
null
:
null
;
if
(
!
browser
.
userTypedValue
&
&
uri
&
&
!
data
.
isRemotenessUpdate
&
&
!
win
.
gInitialPages
.
includes
(
uri
)
)
{
browser
.
userTypedValue
=
uri
;
}
this
.
updateTabLabelAndIcon
(
tab
tabData
)
;
let
event
=
win
.
document
.
createEvent
(
"
Events
"
)
;
event
.
initEvent
(
"
SSTabRestoring
"
true
false
)
;
tab
.
dispatchEvent
(
event
)
;
break
;
}
case
"
SessionStore
:
restoreTabContentStarted
"
:
if
(
TAB_STATE_FOR_BROWSER
.
get
(
browser
)
=
=
TAB_STATE_NEEDS_RESTORE
)
{
this
.
markTabAsRestoring
(
tab
)
;
}
else
if
(
data
.
reason
!
=
RESTORE_TAB_CONTENT_REASON
.
NAVIGATE_AND_RESTORE
)
{
let
tabData
=
TabState
.
collect
(
tab
TAB_CUSTOM_VALUES
.
get
(
tab
)
)
;
if
(
tabData
.
userTypedValue
&
&
!
tabData
.
userTypedClear
&
&
!
browser
.
userTypedValue
)
{
browser
.
userTypedValue
=
tabData
.
userTypedValue
;
win
.
URLBarSetURI
(
)
;
}
TabStateCache
.
update
(
browser
{
userTypedValue
:
null
userTypedClear
:
null
}
)
;
}
break
;
case
"
SessionStore
:
restoreTabContentComplete
"
:
if
(
gDebuggingEnabled
)
{
Services
.
obs
.
notifyObservers
(
browser
NOTIFY_TAB_RESTORED
)
;
}
SessionStoreInternal
.
_resetLocalTabRestoringState
(
tab
)
;
SessionStoreInternal
.
restoreNextTab
(
)
;
this
.
_sendTabRestoredNotification
(
tab
data
.
isRemotenessUpdate
)
;
Services
.
obs
.
notifyObservers
(
null
"
sessionstore
-
one
-
or
-
no
-
tab
-
restored
"
)
;
break
;
case
"
SessionStore
:
crashedTabRevived
"
:
this
.
_crashedBrowsers
.
delete
(
browser
.
permanentKey
)
;
break
;
case
"
SessionStore
:
error
"
:
TabStateFlusher
.
resolveAll
(
browser
false
"
Received
error
from
the
content
process
"
)
;
break
;
default
:
throw
new
Error
(
received
unknown
message
'
{
aMessage
.
name
}
'
)
;
}
}
handleEvent
:
function
ssi_handleEvent
(
aEvent
)
{
let
win
=
aEvent
.
currentTarget
.
ownerGlobal
;
let
target
=
aEvent
.
originalTarget
;
switch
(
aEvent
.
type
)
{
case
"
TabOpen
"
:
this
.
onTabAdd
(
win
)
;
break
;
case
"
TabBrowserInserted
"
:
this
.
onTabBrowserInserted
(
win
target
)
;
break
;
case
"
TabClose
"
:
if
(
!
aEvent
.
detail
.
adoptedBy
)
this
.
onTabClose
(
win
target
)
;
this
.
onTabRemove
(
win
target
)
;
this
.
_notifyOfClosedObjectsChange
(
)
;
break
;
case
"
TabSelect
"
:
this
.
onTabSelect
(
win
)
;
break
;
case
"
TabShow
"
:
this
.
onTabShow
(
win
target
)
;
break
;
case
"
TabHide
"
:
this
.
onTabHide
(
win
target
)
;
break
;
case
"
TabPinned
"
:
case
"
TabUnpinned
"
:
case
"
SwapDocShells
"
:
this
.
saveStateDelayed
(
win
)
;
break
;
case
"
oop
-
browser
-
crashed
"
:
this
.
onBrowserCrashed
(
target
)
;
break
;
case
"
XULFrameLoaderCreated
"
:
if
(
target
.
namespaceURI
=
=
NS_XUL
&
&
target
.
localName
=
=
"
browser
"
&
&
target
.
frameLoader
&
&
target
.
permanentKey
)
{
this
.
_lastKnownFrameLoader
.
set
(
target
.
permanentKey
target
.
frameLoader
)
;
this
.
resetEpoch
(
target
)
;
}
break
;
case
"
BrowserChangedProcess
"
:
let
newEpoch
=
1
+
Math
.
max
(
this
.
getCurrentEpoch
(
target
)
this
.
getCurrentEpoch
(
aEvent
.
otherBrowser
)
)
;
this
.
setCurrentEpoch
(
target
newEpoch
)
;
target
.
messageManager
.
sendAsyncMessage
(
"
SessionStore
:
becomeActiveProcess
"
{
epoch
:
newEpoch
}
)
;
break
;
default
:
throw
new
Error
(
unhandled
event
{
aEvent
.
type
}
?
)
;
}
this
.
_clearRestoringWindows
(
)
;
}
_generateWindowID
:
function
ssi_generateWindowID
(
)
{
return
"
window
"
+
(
this
.
_nextWindowID
+
+
)
;
}
onLoad
(
aWindow
)
{
if
(
aWindow
&
&
aWindow
.
__SSi
&
&
this
.
_windows
[
aWindow
.
__SSi
]
)
return
;
if
(
RunState
.
isQuitting
)
return
;
aWindow
.
__SSi
=
this
.
_generateWindowID
(
)
;
let
mm
=
aWindow
.
getGroupMessageManager
(
"
browsers
"
)
;
MESSAGES
.
forEach
(
msg
=
>
{
let
listenWhenClosed
=
CLOSED_MESSAGES
.
has
(
msg
)
;
mm
.
addMessageListener
(
msg
this
listenWhenClosed
)
;
}
)
;
mm
.
loadFrameScript
(
"
chrome
:
/
/
browser
/
content
/
content
-
sessionStore
.
js
"
true
true
)
;
this
.
_windows
[
aWindow
.
__SSi
]
=
{
tabs
:
[
]
selected
:
0
_closedTabs
:
[
]
busy
:
false
}
;
if
(
PrivateBrowsingUtils
.
isWindowPrivate
(
aWindow
)
)
this
.
_windows
[
aWindow
.
__SSi
]
.
isPrivate
=
true
;
if
(
!
this
.
_isWindowLoaded
(
aWindow
)
)
this
.
_windows
[
aWindow
.
__SSi
]
.
_restoring
=
true
;
if
(
!
aWindow
.
toolbar
.
visible
)
this
.
_windows
[
aWindow
.
__SSi
]
.
isPopup
=
true
;
let
tabbrowser
=
aWindow
.
gBrowser
;
for
(
let
i
=
0
;
i
<
tabbrowser
.
tabs
.
length
;
i
+
+
)
{
this
.
onTabBrowserInserted
(
aWindow
tabbrowser
.
tabs
[
i
]
)
;
}
TAB_EVENTS
.
forEach
(
function
(
aEvent
)
{
tabbrowser
.
tabContainer
.
addEventListener
(
aEvent
this
true
)
;
}
this
)
;
aWindow
.
gBrowser
.
addEventListener
(
"
XULFrameLoaderCreated
"
this
)
;
aWindow
.
gBrowser
.
addEventListener
(
"
BrowserChangedProcess
"
this
)
;
}
initializeWindow
(
aWindow
aInitialState
=
null
)
{
let
isPrivateWindow
=
PrivateBrowsingUtils
.
isWindowPrivate
(
aWindow
)
;
if
(
RunState
.
isStopped
)
{
RunState
.
setRunning
(
)
;
if
(
aInitialState
)
{
SessionSaver
.
updateLastSaveTime
(
)
;
if
(
isPrivateWindow
)
{
this
.
_deferredInitialState
=
SessionStartup
.
state
;
Services
.
obs
.
notifyObservers
(
null
NOTIFY_WINDOWS_RESTORED
)
;
Services
.
obs
.
notifyObservers
(
null
"
sessionstore
-
one
-
or
-
no
-
tab
-
restored
"
)
;
this
.
_deferredAllWindowsRestored
.
resolve
(
)
;
}
else
{
TelemetryTimestamps
.
add
(
"
sessionRestoreRestoring
"
)
;
this
.
_restoreCount
=
aInitialState
.
windows
?
aInitialState
.
windows
.
length
:
0
;
this
.
_globalState
.
setFromState
(
aInitialState
)
;
SessionCookies
.
restore
(
aInitialState
.
cookies
|
|
[
]
)
;
let
overwrite
=
this
.
_isCmdLineEmpty
(
aWindow
aInitialState
)
;
let
options
=
{
firstWindow
:
true
overwriteTabs
:
overwrite
}
;
this
.
restoreWindows
(
aWindow
aInitialState
options
)
;
}
}
else
{
Services
.
obs
.
notifyObservers
(
null
NOTIFY_WINDOWS_RESTORED
)
;
Services
.
obs
.
notifyObservers
(
null
"
sessionstore
-
one
-
or
-
no
-
tab
-
restored
"
)
;
this
.
_deferredAllWindowsRestored
.
resolve
(
)
;
}
}
else
if
(
!
this
.
_isWindowLoaded
(
aWindow
)
)
{
return
;
}
else
if
(
this
.
_deferredInitialState
&
&
!
isPrivateWindow
&
&
aWindow
.
toolbar
.
visible
)
{
this
.
_globalState
.
setFromState
(
this
.
_deferredInitialState
)
;
this
.
_restoreCount
=
this
.
_deferredInitialState
.
windows
?
this
.
_deferredInitialState
.
windows
.
length
:
0
;
this
.
restoreWindows
(
aWindow
this
.
_deferredInitialState
{
firstWindow
:
true
}
)
;
this
.
_deferredInitialState
=
null
;
}
else
if
(
this
.
_restoreLastWindow
&
&
aWindow
.
toolbar
.
visible
&
&
this
.
_closedWindows
.
length
&
&
!
isPrivateWindow
)
{
let
closedWindowState
=
null
;
let
closedWindowIndex
;
for
(
let
i
=
0
;
i
<
this
.
_closedWindows
.
length
;
i
+
+
)
{
if
(
!
this
.
_closedWindows
[
i
]
.
isPopup
)
{
closedWindowState
=
this
.
_closedWindows
[
i
]
;
closedWindowIndex
=
i
;
break
;
}
}
if
(
closedWindowState
)
{
let
newWindowState
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
|
|
!
this
.
_doResumeSession
(
)
)
{
let
[
appTabsState
normalTabsState
]
=
this
.
_prepDataForDeferredRestore
(
{
windows
:
[
closedWindowState
]
}
)
;
if
(
appTabsState
.
windows
.
length
)
{
newWindowState
=
appTabsState
.
windows
[
0
]
;
delete
newWindowState
.
__lastSessionWindowID
;
}
if
(
!
normalTabsState
.
windows
.
length
)
{
this
.
_removeClosedWindow
(
closedWindowIndex
)
;
}
else
{
delete
normalTabsState
.
windows
[
0
]
.
__lastSessionWindowID
;
this
.
_closedWindows
[
closedWindowIndex
]
=
normalTabsState
.
windows
[
0
]
;
}
}
else
{
this
.
_removeClosedWindow
(
closedWindowIndex
)
;
newWindowState
=
closedWindowState
;
delete
newWindowState
.
hidden
;
}
if
(
newWindowState
)
{
this
.
_restoreCount
=
1
;
let
state
=
{
windows
:
[
newWindowState
]
}
;
let
options
=
{
overwriteTabs
:
this
.
_isCmdLineEmpty
(
aWindow
state
)
}
;
this
.
restoreWindow
(
aWindow
newWindowState
options
)
;
}
}
this
.
_prefBranch
.
setBoolPref
(
"
sessionstore
.
resume_session_once
"
false
)
;
}
if
(
this
.
_restoreLastWindow
&
&
aWindow
.
toolbar
.
visible
)
{
this
.
_restoreLastWindow
=
false
;
}
}
onBeforeBrowserWindowShown
(
aWindow
)
{
this
.
onLoad
(
aWindow
)
;
let
deferred
=
WINDOW_SHOWING_PROMISES
.
get
(
aWindow
)
;
if
(
deferred
)
{
deferred
.
resolve
(
aWindow
)
;
WINDOW_SHOWING_PROMISES
.
delete
(
aWindow
)
;
}
if
(
this
.
_sessionInitialized
)
{
this
.
initializeWindow
(
aWindow
)
;
return
;
}
if
(
!
this
.
_promiseReadyForInitialization
)
{
let
promise
=
new
Promise
(
resolve
=
>
{
Services
.
obs
.
addObserver
(
function
obs
(
subject
topic
)
{
if
(
aWindow
=
=
subject
)
{
Services
.
obs
.
removeObserver
(
obs
topic
)
;
resolve
(
)
;
}
}
"
browser
-
delayed
-
startup
-
finished
"
)
;
}
)
;
this
.
_promiseReadyForInitialization
=
Promise
.
all
(
[
promise
SessionStartup
.
onceInitialized
]
)
;
}
this
.
_promiseReadyForInitialization
.
then
(
(
)
=
>
{
if
(
aWindow
.
closed
)
{
return
;
}
if
(
this
.
_sessionInitialized
)
{
this
.
initializeWindow
(
aWindow
)
;
}
else
{
let
initialState
=
this
.
initSession
(
)
;
this
.
_sessionInitialized
=
true
;
if
(
initialState
)
{
Services
.
obs
.
notifyObservers
(
null
NOTIFY_RESTORING_ON_STARTUP
)
;
}
TelemetryStopwatch
.
start
(
"
FX_SESSION_RESTORE_STARTUP_ONLOAD_INITIAL_WINDOW_MS
"
)
;
this
.
initializeWindow
(
aWindow
initialState
)
;
TelemetryStopwatch
.
finish
(
"
FX_SESSION_RESTORE_STARTUP_ONLOAD_INITIAL_WINDOW_MS
"
)
;
this
.
_deferredInitialized
.
resolve
(
)
;
}
}
)
.
catch
(
console
.
error
)
;
}
onClose
:
function
ssi_onClose
(
aWindow
)
{
let
completionPromise
=
Promise
.
resolve
(
)
;
let
isFullyLoaded
=
this
.
_isWindowLoaded
(
aWindow
)
;
if
(
!
isFullyLoaded
)
{
if
(
!
aWindow
.
__SSi
)
{
aWindow
.
__SSi
=
this
.
_generateWindowID
(
)
;
}
let
restoreID
=
WINDOW_RESTORE_IDS
.
get
(
aWindow
)
;
this
.
_windows
[
aWindow
.
__SSi
]
=
this
.
_statesToRestore
[
restoreID
]
.
windows
[
0
]
;
delete
this
.
_statesToRestore
[
restoreID
]
;
WINDOW_RESTORE_IDS
.
delete
(
aWindow
)
;
}
if
(
!
aWindow
.
__SSi
|
|
!
this
.
_windows
[
aWindow
.
__SSi
]
)
{
return
completionPromise
;
}
let
event
=
aWindow
.
document
.
createEvent
(
"
Events
"
)
;
event
.
initEvent
(
"
SSWindowClosing
"
true
false
)
;
aWindow
.
dispatchEvent
(
event
)
;
if
(
this
.
windowToFocus
&
&
this
.
windowToFocus
=
=
aWindow
)
{
delete
this
.
windowToFocus
;
}
var
tabbrowser
=
aWindow
.
gBrowser
;
let
browsers
=
Array
.
from
(
tabbrowser
.
browsers
)
;
TAB_EVENTS
.
forEach
(
function
(
aEvent
)
{
tabbrowser
.
tabContainer
.
removeEventListener
(
aEvent
this
true
)
;
}
this
)
;
aWindow
.
gBrowser
.
removeEventListener
(
"
XULFrameLoaderCreated
"
this
)
;
aWindow
.
gBrowser
.
removeEventListener
(
"
BrowserChangedProcess
"
this
)
;
let
winData
=
this
.
_windows
[
aWindow
.
__SSi
]
;
if
(
RunState
.
isRunning
)
{
let
tabMap
=
this
.
_collectWindowData
(
aWindow
)
;
for
(
let
[
tab
tabData
]
of
tabMap
)
{
let
permanentKey
=
tab
.
linkedBrowser
.
permanentKey
;
this
.
_closedWindowTabs
.
set
(
permanentKey
tabData
)
;
}
if
(
isFullyLoaded
)
{
winData
.
title
=
tabbrowser
.
selectedBrowser
.
contentTitle
|
|
tabbrowser
.
selectedTab
.
label
;
}
if
(
AppConstants
.
platform
!
=
"
macosx
"
)
{
winData
.
_shouldRestore
=
true
;
}
winData
.
closedAt
=
Date
.
now
(
)
;
delete
winData
.
busy
;
let
isLastWindow
=
Object
.
keys
(
this
.
_windows
)
.
length
=
=
1
&
&
!
this
.
_closedWindows
.
some
(
win
=
>
win
.
_shouldRestore
|
|
false
)
;
delete
this
.
_windows
[
aWindow
.
__SSi
]
;
this
.
_saveableClosedWindowData
.
add
(
winData
)
;
if
(
!
winData
.
isPrivate
)
{
PrivacyFilter
.
filterPrivateTabs
(
winData
)
;
this
.
maybeSaveClosedWindow
(
winData
isLastWindow
)
;
}
completionPromise
=
TabStateFlusher
.
flushWindow
(
aWindow
)
.
then
(
(
)
=
>
{
for
(
let
browser
of
browsers
)
{
if
(
this
.
_closedWindowTabs
.
has
(
browser
.
permanentKey
)
)
{
let
tabData
=
this
.
_closedWindowTabs
.
get
(
browser
.
permanentKey
)
;
TabState
.
copyFromCache
(
browser
tabData
)
;
this
.
_closedWindowTabs
.
delete
(
browser
.
permanentKey
)
;
}
}
if
(
!
winData
.
isPrivate
)
{
PrivacyFilter
.
filterPrivateTabs
(
winData
)
;
this
.
maybeSaveClosedWindow
(
winData
isLastWindow
)
;
}
this
.
cleanUpWindow
(
aWindow
winData
browsers
)
;
this
.
saveStateDelayed
(
)
;
}
)
;
}
else
{
this
.
cleanUpWindow
(
aWindow
winData
browsers
)
;
}
for
(
let
i
=
0
;
i
<
tabbrowser
.
tabs
.
length
;
i
+
+
)
{
this
.
onTabRemove
(
aWindow
tabbrowser
.
tabs
[
i
]
true
)
;
}
return
completionPromise
;
}
cleanUpWindow
(
aWindow
winData
browsers
)
{
for
(
let
browser
of
browsers
)
{
TabStateFlusher
.
resolveAll
(
browser
)
;
}
DyingWindowCache
.
set
(
aWindow
winData
)
;
let
mm
=
aWindow
.
getGroupMessageManager
(
"
browsers
"
)
;
MESSAGES
.
forEach
(
msg
=
>
mm
.
removeMessageListener
(
msg
this
)
)
;
this
.
_saveableClosedWindowData
.
delete
(
winData
)
;
delete
aWindow
.
__SSi
;
}
maybeSaveClosedWindow
(
winData
isLastWindow
)
{
if
(
RunState
.
isRunning
&
&
this
.
_saveableClosedWindowData
.
has
(
winData
)
)
{
let
hasSaveableTabs
=
winData
.
tabs
.
some
(
this
.
_shouldSaveTabState
)
;
let
winIndex
=
this
.
_closedWindows
.
indexOf
(
winData
)
;
let
alreadyStored
=
(
winIndex
!
=
-
1
)
;
let
shouldStore
=
(
hasSaveableTabs
|
|
isLastWindow
)
;
if
(
shouldStore
&
&
!
alreadyStored
)
{
let
index
=
this
.
_closedWindows
.
findIndex
(
win
=
>
{
return
win
.
closedAt
<
winData
.
closedAt
;
}
)
;
if
(
index
=
=
-
1
)
{
index
=
this
.
_closedWindows
.
length
;
}
winData
.
closedId
=
this
.
_nextClosedId
+
+
;
this
.
_closedWindows
.
splice
(
index
0
winData
)
;
this
.
_capClosedWindows
(
)
;
this
.
_closedObjectsChanged
=
true
;
}
else
if
(
!
shouldStore
&
&
alreadyStored
)
{
this
.
_removeClosedWindow
(
winIndex
)
;
}
}
}
onQuitApplicationGranted
:
function
ssi_onQuitApplicationGranted
(
syncShutdown
=
false
)
{
let
index
=
0
;
for
(
let
window
of
this
.
_browserWindows
)
{
this
.
_collectWindowData
(
window
)
;
this
.
_windows
[
window
.
__SSi
]
.
zIndex
=
+
+
index
;
}
let
progress
=
{
total
:
-
1
current
:
-
1
}
;
RunState
.
setQuitting
(
)
;
if
(
!
syncShutdown
)
{
AsyncShutdown
.
quitApplicationGranted
.
addBlocker
(
"
SessionStore
:
flushing
all
windows
"
(
)
=
>
{
let
promises
=
[
this
.
flushAllWindowsAsync
(
progress
)
]
;
const
observeTopic
=
topic
=
>
{
let
deferred
=
PromiseUtils
.
defer
(
)
;
const
cleanup
=
(
)
=
>
{
try
{
Services
.
obs
.
removeObserver
(
deferred
.
resolve
topic
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
"
SessionStore
:
exception
whilst
flushing
all
windows
:
"
+
ex
)
;
}
}
;
Services
.
obs
.
addObserver
(
subject
=
>
{
subject
.
QueryInterface
(
Ci
.
nsIPropertyBag2
)
;
if
(
!
(
topic
=
=
"
ipc
:
content
-
shutdown
"
&
&
!
subject
.
get
(
"
abnormal
"
)
)
)
{
deferred
.
resolve
(
)
;
}
}
topic
)
;
deferred
.
promise
.
then
(
cleanup
cleanup
)
;
return
deferred
;
}
;
let
waitTimeMaxMs
=
Math
.
max
(
0
AsyncShutdown
.
DELAY_CRASH_MS
-
10000
)
;
let
defers
=
[
this
.
looseTimer
(
waitTimeMaxMs
)
observeTopic
(
"
oop
-
frameloader
-
crashed
"
)
observeTopic
(
"
ipc
:
content
-
shutdown
"
)
]
;
promises
.
push
(
.
.
.
defers
.
map
(
deferred
=
>
deferred
.
promise
)
)
;
return
Promise
.
race
(
promises
)
.
then
(
(
)
=
>
{
defers
.
forEach
(
deferred
=
>
deferred
.
reject
(
)
)
;
}
)
;
}
(
)
=
>
progress
)
;
}
else
{
}
}
async
flushAllWindowsAsync
(
progress
=
{
}
)
{
let
windowPromises
=
new
Map
(
)
;
for
(
let
window
of
this
.
_browserWindows
)
{
windowPromises
.
set
(
window
TabStateFlusher
.
flushWindow
(
window
)
)
;
let
baseWin
=
window
.
docShell
.
treeOwner
.
QueryInterface
(
Ci
.
nsIBaseWindow
)
;
baseWin
.
visibility
=
false
;
}
progress
.
total
=
windowPromises
.
size
;
progress
.
current
=
0
;
for
(
let
[
win
promise
]
of
windowPromises
)
{
await
promise
;
this
.
_collectWindowData
(
win
)
;
progress
.
current
+
+
;
}
var
activeWindow
=
this
.
_getTopWindow
(
)
;
if
(
activeWindow
)
this
.
activeWindowSSiCache
=
activeWindow
.
__SSi
|
|
"
"
;
DirtyWindows
.
clear
(
)
;
}
onLastWindowCloseGranted
:
function
ssi_onLastWindowCloseGranted
(
)
{
this
.
_restoreLastWindow
=
true
;
}
onQuitApplication
:
function
ssi_onQuitApplication
(
aData
)
{
if
(
aData
=
=
"
restart
"
|
|
aData
=
=
"
os
-
restart
"
)
{
if
(
!
PrivateBrowsingUtils
.
permanentPrivateBrowsing
)
{
if
(
aData
=
=
"
os
-
restart
"
&
&
!
this
.
_prefBranch
.
getBoolPref
(
"
sessionstore
.
resume_session_once
"
)
)
{
this
.
_prefBranch
.
setBoolPref
(
"
sessionstore
.
resuming_after_os_restart
"
true
)
;
}
this
.
_prefBranch
.
setBoolPref
(
"
sessionstore
.
resume_session_once
"
true
)
;
}
Services
.
obs
.
removeObserver
(
this
"
browser
:
purge
-
session
-
history
"
)
;
}
if
(
aData
!
=
"
restart
"
)
{
LastSession
.
clear
(
true
)
;
}
this
.
_uninit
(
)
;
}
onPurgeSessionHistory
:
function
ssi_onPurgeSessionHistory
(
)
{
SessionFile
.
wipe
(
)
;
if
(
RunState
.
isQuitting
)
return
;
LastSession
.
clear
(
)
;
let
openWindows
=
{
}
;
for
(
let
window
of
this
.
_browserWindows
)
{
openWindows
[
window
.
__SSi
]
=
true
;
}
for
(
let
ix
in
this
.
_windows
)
{
if
(
ix
in
openWindows
)
{
if
(
this
.
_windows
[
ix
]
.
_closedTabs
.
length
)
{
this
.
_windows
[
ix
]
.
_closedTabs
=
[
]
;
this
.
_closedObjectsChanged
=
true
;
}
}
else
{
delete
this
.
_windows
[
ix
]
;
}
}
if
(
this
.
_closedWindows
.
length
)
{
this
.
_closedWindows
=
[
]
;
this
.
_closedObjectsChanged
=
true
;
}
var
win
=
this
.
_getTopWindow
(
)
;
if
(
win
)
{
win
.
setTimeout
(
(
)
=
>
SessionSaver
.
run
(
)
0
)
;
}
else
if
(
RunState
.
isRunning
)
{
SessionSaver
.
run
(
)
;
}
this
.
_clearRestoringWindows
(
)
;
this
.
_saveableClosedWindowData
=
new
WeakSet
(
)
;
}
onPurgeDomainData
:
function
ssi_onPurgeDomainData
(
aData
)
{
function
containsDomain
(
aEntry
)
{
if
(
Utils
.
hasRootDomain
(
aEntry
.
url
aData
)
)
{
return
true
;
}
return
aEntry
.
children
&
&
aEntry
.
children
.
some
(
containsDomain
this
)
;
}
for
(
let
ix
in
this
.
_windows
)
{
let
closedTabs
=
this
.
_windows
[
ix
]
.
_closedTabs
;
for
(
let
i
=
closedTabs
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
if
(
closedTabs
[
i
]
.
state
.
entries
.
some
(
containsDomain
this
)
)
{
closedTabs
.
splice
(
i
1
)
;
this
.
_closedObjectsChanged
=
true
;
}
}
}
for
(
let
ix
=
this
.
_closedWindows
.
length
-
1
;
ix
>
=
0
;
ix
-
-
)
{
let
closedTabs
=
this
.
_closedWindows
[
ix
]
.
_closedTabs
;
let
openTabs
=
this
.
_closedWindows
[
ix
]
.
tabs
;
let
openTabCount
=
openTabs
.
length
;
for
(
let
i
=
closedTabs
.
length
-
1
;
i
>
=
0
;
i
-
-
)
if
(
closedTabs
[
i
]
.
state
.
entries
.
some
(
containsDomain
this
)
)
closedTabs
.
splice
(
i
1
)
;
for
(
let
j
=
openTabs
.
length
-
1
;
j
>
=
0
;
j
-
-
)
{
if
(
openTabs
[
j
]
.
entries
.
some
(
containsDomain
this
)
)
{
openTabs
.
splice
(
j
1
)
;
if
(
this
.
_closedWindows
[
ix
]
.
selected
>
j
)
this
.
_closedWindows
[
ix
]
.
selected
-
-
;
}
}
if
(
openTabs
.
length
=
=
0
)
{
this
.
_closedWindows
.
splice
(
ix
1
)
;
}
else
if
(
openTabs
.
length
!
=
openTabCount
)
{
let
selectedTab
=
openTabs
[
this
.
_closedWindows
[
ix
]
.
selected
-
1
]
;
let
activeIndex
=
(
selectedTab
.
index
|
|
selectedTab
.
entries
.
length
)
-
1
;
if
(
activeIndex
>
=
selectedTab
.
entries
.
length
)
activeIndex
=
selectedTab
.
entries
.
length
-
1
;
this
.
_closedWindows
[
ix
]
.
title
=
selectedTab
.
entries
[
activeIndex
]
.
title
;
}
}
if
(
RunState
.
isRunning
)
{
SessionSaver
.
run
(
)
;
}
this
.
_clearRestoringWindows
(
)
;
}
onPrefChange
:
function
ssi_onPrefChange
(
aData
)
{
switch
(
aData
)
{
case
"
sessionstore
.
max_tabs_undo
"
:
this
.
_max_tabs_undo
=
this
.
_prefBranch
.
getIntPref
(
"
sessionstore
.
max_tabs_undo
"
)
;
for
(
let
ix
in
this
.
_windows
)
{
if
(
this
.
_windows
[
ix
]
.
_closedTabs
.
length
>
this
.
_max_tabs_undo
)
{
this
.
_windows
[
ix
]
.
_closedTabs
.
splice
(
this
.
_max_tabs_undo
this
.
_windows
[
ix
]
.
_closedTabs
.
length
)
;
this
.
_closedObjectsChanged
=
true
;
}
}
break
;
case
"
sessionstore
.
max_windows_undo
"
:
this
.
_max_windows_undo
=
this
.
_prefBranch
.
getIntPref
(
"
sessionstore
.
max_windows_undo
"
)
;
this
.
_capClosedWindows
(
)
;
break
;
case
"
privacy
.
resistFingerprinting
"
:
gResistFingerprintingEnabled
=
Services
.
prefs
.
getBoolPref
(
"
privacy
.
resistFingerprinting
"
)
;
break
;
case
"
sessionstore
.
restore_on_demand
"
:
this
.
_restore_on_demand
=
this
.
_prefBranch
.
getBoolPref
(
"
sessionstore
.
restore_on_demand
"
)
;
break
;
}
}
onTabAdd
:
function
ssi_onTabAdd
(
aWindow
)
{
this
.
saveStateDelayed
(
aWindow
)
;
}
onTabBrowserInserted
:
function
ssi_onTabBrowserInserted
(
aWindow
aTab
)
{
let
browser
=
aTab
.
linkedBrowser
;
browser
.
addEventListener
(
"
SwapDocShells
"
this
)
;
browser
.
addEventListener
(
"
oop
-
browser
-
crashed
"
this
)
;
if
(
browser
.
frameLoader
)
{
this
.
_lastKnownFrameLoader
.
set
(
browser
.
permanentKey
browser
.
frameLoader
)
;
}
if
(
TAB_LAZY_STATES
.
has
(
aTab
)
&
&
!
TAB_STATE_FOR_BROWSER
.
has
(
browser
)
&
&
TabStateCache
.
get
(
browser
)
)
{
let
tabState
=
TabState
.
clone
(
aTab
TAB_CUSTOM_VALUES
.
get
(
aTab
)
)
;
this
.
restoreTab
(
aTab
tabState
)
;
}
TAB_LAZY_STATES
.
delete
(
aTab
)
;
}
onTabRemove
:
function
ssi_onTabRemove
(
aWindow
aTab
aNoNotification
)
{
this
.
cleanUpRemovedBrowser
(
aTab
)
;
if
(
!
aNoNotification
)
{
this
.
saveStateDelayed
(
aWindow
)
;
}
}
onTabClose
:
function
ssi_onTabClose
(
aWindow
aTab
)
{
var
event
=
aWindow
.
document
.
createEvent
(
"
Events
"
)
;
event
.
initEvent
(
"
SSTabClosing
"
true
false
)
;
aTab
.
dispatchEvent
(
event
)
;
if
(
this
.
_max_tabs_undo
=
=
0
)
{
return
;
}
let
tabState
=
TabState
.
collect
(
aTab
TAB_CUSTOM_VALUES
.
get
(
aTab
)
)
;
let
isPrivateWindow
=
PrivateBrowsingUtils
.
isWindowPrivate
(
aWindow
)
;
if
(
!
isPrivateWindow
&
&
tabState
.
isPrivate
)
{
return
;
}
let
tabbrowser
=
aWindow
.
gBrowser
;
let
tabTitle
=
aTab
.
label
;
let
{
permanentKey
}
=
aTab
.
linkedBrowser
;
let
tabData
=
{
permanentKey
state
:
tabState
title
:
tabTitle
image
:
tabbrowser
.
getIcon
(
aTab
)
pos
:
aTab
.
_tPos
closedAt
:
Date
.
now
(
)
}
;
let
closedTabs
=
this
.
_windows
[
aWindow
.
__SSi
]
.
_closedTabs
;
if
(
this
.
_shouldSaveTabState
(
tabState
)
)
{
this
.
saveClosedTabData
(
closedTabs
tabData
)
;
}
this
.
_closedTabs
.
set
(
permanentKey
{
closedTabs
tabData
}
)
;
}
resetBrowserToLazyState
(
aTab
)
{
let
browser
=
aTab
.
linkedBrowser
;
if
(
!
browser
.
isConnected
)
{
return
;
}
this
.
cleanUpRemovedBrowser
(
aTab
)
;
aTab
.
setAttribute
(
"
pending
"
"
true
"
)
;
this
.
_lastKnownFrameLoader
.
delete
(
browser
.
permanentKey
)
;
this
.
_crashedBrowsers
.
delete
(
browser
.
permanentKey
)
;
aTab
.
removeAttribute
(
"
crashed
"
)
;
let
{
userTypedValue
=
"
"
userTypedClear
=
0
}
=
browser
;
let
cacheState
=
TabStateCache
.
get
(
browser
)
;
if
(
cacheState
=
=
=
undefined
&
&
userTypedValue
)
{
TabStateCache
.
update
(
browser
{
userTypedValue
userTypedClear
:
1
}
)
;
}
TAB_LAZY_STATES
.
set
(
aTab
{
url
:
browser
.
currentURI
.
spec
title
:
aTab
.
label
userTypedValue
userTypedClear
}
)
;
}
cleanUpRemovedBrowser
(
aTab
)
{
let
browser
=
aTab
.
linkedBrowser
;
browser
.
removeEventListener
(
"
SwapDocShells
"
this
)
;
browser
.
removeEventListener
(
"
oop
-
browser
-
crashed
"
this
)
;
let
previousState
=
TAB_STATE_FOR_BROWSER
.
get
(
browser
)
;
if
(
previousState
)
{
this
.
_resetTabRestoringState
(
aTab
)
;
if
(
previousState
=
=
TAB_STATE_RESTORING
)
this
.
restoreNextTab
(
)
;
}
}
saveClosedTabData
(
closedTabs
tabData
)
{
let
index
=
closedTabs
.
findIndex
(
tab
=
>
{
return
tab
.
closedAt
<
tabData
.
closedAt
;
}
)
;
if
(
index
=
=
-
1
)
{
index
=
closedTabs
.
length
;
}
tabData
.
closedId
=
this
.
_nextClosedId
+
+
;
closedTabs
.
splice
(
index
0
tabData
)
;
this
.
_closedObjectsChanged
=
true
;
if
(
closedTabs
.
length
>
this
.
_max_tabs_undo
)
{
closedTabs
.
splice
(
this
.
_max_tabs_undo
closedTabs
.
length
)
;
}
}
removeClosedTabData
(
closedTabs
index
)
{
let
[
closedTab
]
=
closedTabs
.
splice
(
index
1
)
;
this
.
_closedObjectsChanged
=
true
;
if
(
closedTab
.
permanentKey
)
{
this
.
_closedTabs
.
delete
(
closedTab
.
permanentKey
)
;
this
.
_closedWindowTabs
.
delete
(
closedTab
.
permanentKey
)
;
delete
closedTab
.
permanentKey
;
}
return
closedTab
;
}
onTabSelect
:
function
ssi_onTabSelect
(
aWindow
)
{
if
(
RunState
.
isRunning
)
{
this
.
_windows
[
aWindow
.
__SSi
]
.
selected
=
aWindow
.
gBrowser
.
tabContainer
.
selectedIndex
;
let
tab
=
aWindow
.
gBrowser
.
selectedTab
;
let
browser
=
tab
.
linkedBrowser
;
if
(
TAB_STATE_FOR_BROWSER
.
get
(
browser
)
=
=
TAB_STATE_NEEDS_RESTORE
)
{
if
(
TabCrashHandler
.
willShowCrashedTab
(
browser
)
)
{
this
.
enterCrashedState
(
browser
)
;
}
else
{
this
.
restoreTabContent
(
tab
)
;
}
}
}
}
onTabShow
:
function
ssi_onTabShow
(
aWindow
aTab
)
{
if
(
TAB_STATE_FOR_BROWSER
.
get
(
aTab
.
linkedBrowser
)
=
=
TAB_STATE_NEEDS_RESTORE
)
{
TabRestoreQueue
.
hiddenToVisible
(
aTab
)
;
this
.
restoreNextTab
(
)
;
}
this
.
saveStateDelayed
(
aWindow
)
;
}
onTabHide
:
function
ssi_onTabHide
(
aWindow
aTab
)
{
if
(
TAB_STATE_FOR_BROWSER
.
get
(
aTab
.
linkedBrowser
)
=
=
TAB_STATE_NEEDS_RESTORE
)
{
TabRestoreQueue
.
visibleToHidden
(
aTab
)
;
}
this
.
saveStateDelayed
(
aWindow
)
;
}
onBrowserCrashed
(
aBrowser
)
{
this
.
enterCrashedState
(
aBrowser
)
;
TabStateFlusher
.
resolveAll
(
aBrowser
)
;
}
enterCrashedState
(
browser
)
{
this
.
_crashedBrowsers
.
add
(
browser
.
permanentKey
)
;
let
win
=
browser
.
ownerGlobal
;
if
(
TAB_STATE_FOR_BROWSER
.
has
(
browser
)
)
{
let
tab
=
win
.
gBrowser
.
getTabForBrowser
(
browser
)
;
this
.
_resetLocalTabRestoringState
(
tab
)
;
}
}
onIdleDaily
(
)
{
this
.
_cleanupOldData
(
[
this
.
_closedWindows
]
)
;
this
.
_cleanupOldData
(
this
.
_closedWindows
.
map
(
(
winData
)
=
>
winData
.
_closedTabs
)
)
;
this
.
_cleanupOldData
(
Object
.
keys
(
this
.
_windows
)
.
map
(
(
key
)
=
>
this
.
_windows
[
key
]
.
_closedTabs
)
)
;
this
.
_notifyOfClosedObjectsChange
(
)
;
}
_cleanupOldData
(
targets
)
{
const
TIME_TO_LIVE
=
this
.
_prefBranch
.
getIntPref
(
"
sessionstore
.
cleanup
.
forget_closed_after
"
)
;
const
now
=
Date
.
now
(
)
;
for
(
let
array
of
targets
)
{
for
(
let
i
=
array
.
length
-
1
;
i
>
=
0
;
-
-
i
)
{
let
data
=
array
[
i
]
;
data
.
closedAt
=
data
.
closedAt
|
|
now
;
if
(
now
-
data
.
closedAt
>
TIME_TO_LIVE
)
{
array
.
splice
(
i
1
)
;
this
.
_closedObjectsChanged
=
true
;
}
}
}
}
async
_doProcessSwitch
(
aBrowser
aRemoteType
aChannel
aSwitchId
)
{
await
aBrowser
.
ownerGlobal
.
delayedStartupPromise
;
let
tab
=
aBrowser
.
ownerGlobal
.
gBrowser
.
getTabForBrowser
(
aBrowser
)
;
let
loadArguments
=
{
newFrameloader
:
true
remoteType
:
aRemoteType
redirectLoadSwitchId
:
aSwitchId
}
;
await
SessionStore
.
navigateAndRestore
(
tab
loadArguments
-
1
)
;
if
(
aBrowser
.
remoteType
!
=
aRemoteType
|
|
!
aBrowser
.
frameLoader
|
|
!
aBrowser
.
frameLoader
.
tabParent
)
{
throw
Cr
.
NS_ERROR_FAILURE
;
}
return
aBrowser
.
frameLoader
.
tabParent
;
}
onExamineResponse
(
aChannel
)
{
if
(
!
E10SUtils
.
useHttpResponseProcessSelection
(
)
)
{
return
;
}
if
(
!
aChannel
.
isDocument
|
|
!
aChannel
.
loadInfo
)
{
return
;
}
let
cpType
=
aChannel
.
loadInfo
.
externalContentPolicyType
;
let
toplevel
=
cpType
=
=
Ci
.
nsIContentPolicy
.
TYPE_DOCUMENT
;
if
(
!
toplevel
)
{
return
;
}
let
browsingContext
=
toplevel
?
aChannel
.
loadInfo
.
browsingContext
:
aChannel
.
loadInfo
.
frameBrowsingContext
;
if
(
!
browsingContext
)
{
return
;
}
let
currentPrincipal
=
null
;
if
(
browsingContext
.
currentWindowGlobal
)
{
currentPrincipal
=
browsingContext
.
currentWindowGlobal
.
documentPrincipal
;
}
let
parentChannel
=
aChannel
.
notificationCallbacks
.
getInterface
(
Ci
.
nsIParentChannel
)
;
if
(
!
parentChannel
)
{
return
;
}
let
tabParent
=
parentChannel
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsITabParent
)
;
if
(
!
tabParent
|
|
!
tabParent
.
ownerElement
)
{
console
.
warn
(
"
warning
:
Missing
tabParent
"
)
;
return
;
}
let
browser
=
tabParent
.
ownerElement
;
if
(
browser
.
tagName
!
=
=
"
browser
"
)
{
console
.
warn
(
"
warning
:
Not
a
xul
:
browser
element
:
"
browser
.
tagName
)
;
return
;
}
let
resultPrincipal
=
Services
.
scriptSecurityManager
.
getChannelResultPrincipal
(
aChannel
)
;
let
useRemoteTabs
=
browser
.
ownerGlobal
.
gMultiProcessBrowser
;
let
remoteType
=
E10SUtils
.
getRemoteTypeForPrincipal
(
resultPrincipal
useRemoteTabs
browser
.
remoteType
currentPrincipal
)
;
if
(
browser
.
remoteType
=
=
remoteType
)
{
return
;
}
let
identifier
=
+
+
this
.
_switchIdMonotonic
;
let
tabPromise
=
this
.
_doProcessSwitch
(
browser
remoteType
aChannel
identifier
)
;
aChannel
.
switchProcessTo
(
tabPromise
identifier
)
;
}
getBrowserState
:
function
ssi_getBrowserState
(
)
{
let
state
=
this
.
getCurrentState
(
)
;
delete
state
.
lastSessionState
;
delete
state
.
deferredInitialState
;
return
JSON
.
stringify
(
state
)
;
}
setBrowserState
:
function
ssi_setBrowserState
(
aState
)
{
this
.
_handleClosedWindows
(
)
;
try
{
var
state
=
JSON
.
parse
(
aState
)
;
}
catch
(
ex
)
{
}
if
(
!
state
)
{
throw
Components
.
Exception
(
"
Invalid
state
string
:
not
JSON
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
if
(
!
state
.
windows
)
{
throw
Components
.
Exception
(
"
No
windows
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
this
.
_browserSetState
=
true
;
this
.
_resetRestoringState
(
)
;
var
window
=
this
.
_getTopWindow
(
)
;
if
(
!
window
)
{
this
.
_restoreCount
=
1
;
this
.
_openWindowWithState
(
state
)
;
return
;
}
for
(
let
otherWin
of
this
.
_browserWindows
)
{
if
(
otherWin
!
=
window
)
{
otherWin
.
close
(
)
;
this
.
onClose
(
otherWin
)
;
}
}
if
(
this
.
_closedWindows
.
length
)
{
this
.
_closedWindows
=
[
]
;
this
.
_closedObjectsChanged
=
true
;
}
this
.
_restoreCount
=
state
.
windows
?
state
.
windows
.
length
:
0
;
this
.
_globalState
.
setFromState
(
state
)
;
SessionCookies
.
restore
(
state
.
cookies
|
|
[
]
)
;
this
.
restoreWindows
(
window
state
{
overwriteTabs
:
true
}
)
;
this
.
_notifyOfClosedObjectsChange
(
)
;
}
getWindowState
:
function
ssi_getWindowState
(
aWindow
)
{
if
(
"
__SSi
"
in
aWindow
)
{
return
JSON
.
stringify
(
this
.
_getWindowState
(
aWindow
)
)
;
}
if
(
DyingWindowCache
.
has
(
aWindow
)
)
{
let
data
=
DyingWindowCache
.
get
(
aWindow
)
;
return
JSON
.
stringify
(
{
windows
:
[
data
]
}
)
;
}
throw
Components
.
Exception
(
"
Window
is
not
tracked
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
setWindowState
:
function
ssi_setWindowState
(
aWindow
aState
aOverwrite
)
{
if
(
!
aWindow
.
__SSi
)
{
throw
Components
.
Exception
(
"
Window
is
not
tracked
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
this
.
restoreWindows
(
aWindow
aState
{
overwriteTabs
:
aOverwrite
}
)
;
this
.
_notifyOfClosedObjectsChange
(
)
;
}
getTabState
:
function
ssi_getTabState
(
aTab
)
{
if
(
!
aTab
|
|
!
aTab
.
ownerGlobal
)
{
throw
Components
.
Exception
(
"
Need
a
valid
tab
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
if
(
!
aTab
.
ownerGlobal
.
__SSi
)
{
throw
Components
.
Exception
(
"
Default
view
is
not
tracked
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
let
tabState
=
TabState
.
collect
(
aTab
TAB_CUSTOM_VALUES
.
get
(
aTab
)
)
;
return
JSON
.
stringify
(
tabState
)
;
}
setTabState
(
aTab
aState
)
{
let
tabState
=
aState
;
if
(
typeof
tabState
=
=
"
string
"
)
{
tabState
=
JSON
.
parse
(
aState
)
;
}
if
(
!
tabState
)
{
throw
Components
.
Exception
(
"
Invalid
state
string
:
not
JSON
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
if
(
typeof
tabState
!
=
"
object
"
)
{
throw
Components
.
Exception
(
"
Not
an
object
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
if
(
!
(
"
entries
"
in
tabState
)
)
{
throw
Components
.
Exception
(
"
Invalid
state
object
:
no
entries
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
let
window
=
aTab
.
ownerGlobal
;
if
(
!
window
|
|
!
(
"
__SSi
"
in
window
)
)
{
throw
Components
.
Exception
(
"
Window
is
not
tracked
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
if
(
TAB_STATE_FOR_BROWSER
.
has
(
aTab
.
linkedBrowser
)
)
{
this
.
_resetTabRestoringState
(
aTab
)
;
}
this
.
restoreTab
(
aTab
tabState
)
;
this
.
_notifyOfClosedObjectsChange
(
)
;
}
getInternalObjectState
(
obj
)
{
if
(
obj
.
__SSi
)
{
return
this
.
_windows
[
obj
.
__SSi
]
;
}
return
obj
.
loadURI
?
TAB_STATE_FOR_BROWSER
.
get
(
obj
)
:
TAB_CUSTOM_VALUES
.
get
(
obj
)
;
}
duplicateTab
:
function
ssi_duplicateTab
(
aWindow
aTab
aDelta
=
0
aRestoreImmediately
=
true
)
{
if
(
!
aTab
|
|
!
aTab
.
ownerGlobal
)
{
throw
Components
.
Exception
(
"
Need
a
valid
tab
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
if
(
!
aTab
.
ownerGlobal
.
__SSi
)
{
throw
Components
.
Exception
(
"
Default
view
is
not
tracked
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
if
(
!
aWindow
.
gBrowser
)
{
throw
Components
.
Exception
(
"
Invalid
window
object
:
no
gBrowser
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
let
userContextId
=
aTab
.
getAttribute
(
"
usercontextid
"
)
;
let
tabOptions
=
{
userContextId
.
.
.
(
aTab
=
=
aWindow
.
gBrowser
.
selectedTab
?
{
relatedToCurrent
:
true
ownerTab
:
aTab
}
:
{
}
)
}
;
let
newTab
=
aWindow
.
gBrowser
.
addTrustedTab
(
null
tabOptions
)
;
let
uriObj
=
aTab
.
linkedBrowser
.
currentURI
;
if
(
!
uriObj
|
|
(
uriObj
&
&
!
aWindow
.
gBrowser
.
isLocalAboutURI
(
uriObj
)
)
)
{
newTab
.
setAttribute
(
"
busy
"
"
true
"
)
;
}
aWindow
.
gBrowser
.
setDefaultIcon
(
newTab
uriObj
)
;
let
tabState
=
TabState
.
collect
(
aTab
TAB_CUSTOM_VALUES
.
get
(
aTab
)
)
;
let
browser
=
aTab
.
linkedBrowser
;
TabStateFlusher
.
flush
(
browser
)
.
then
(
(
)
=
>
{
if
(
newTab
.
closing
|
|
!
newTab
.
linkedBrowser
)
{
return
;
}
let
window
=
newTab
.
ownerGlobal
;
if
(
!
window
|
|
!
window
.
__SSi
)
{
return
;
}
let
options
=
{
includePrivateData
:
true
}
;
TabState
.
copyFromCache
(
browser
tabState
options
)
;
tabState
.
index
+
=
aDelta
;
tabState
.
index
=
Math
.
max
(
1
Math
.
min
(
tabState
.
index
tabState
.
entries
.
length
)
)
;
tabState
.
pinned
=
false
;
this
.
restoreTab
(
newTab
tabState
{
restoreImmediately
:
aRestoreImmediately
}
)
;
}
)
;
return
newTab
;
}
getClosedTabCount
:
function
ssi_getClosedTabCount
(
aWindow
)
{
if
(
"
__SSi
"
in
aWindow
)
{
return
this
.
_windows
[
aWindow
.
__SSi
]
.
_closedTabs
.
length
;
}
if
(
!
DyingWindowCache
.
has
(
aWindow
)
)
{
throw
Components
.
Exception
(
"
Window
is
not
tracked
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
return
DyingWindowCache
.
get
(
aWindow
)
.
_closedTabs
.
length
;
}
getClosedTabData
:
function
ssi_getClosedTabData
(
aWindow
aAsString
=
true
)
{
if
(
"
__SSi
"
in
aWindow
)
{
return
aAsString
?
JSON
.
stringify
(
this
.
_windows
[
aWindow
.
__SSi
]
.
_closedTabs
)
:
Cu
.
cloneInto
(
this
.
_windows
[
aWindow
.
__SSi
]
.
_closedTabs
{
}
)
;
}
if
(
!
DyingWindowCache
.
has
(
aWindow
)
)
{
throw
Components
.
Exception
(
"
Window
is
not
tracked
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
let
data
=
DyingWindowCache
.
get
(
aWindow
)
;
return
aAsString
?
JSON
.
stringify
(
data
.
_closedTabs
)
:
Cu
.
cloneInto
(
data
.
_closedTabs
{
}
)
;
}
undoCloseTab
:
function
ssi_undoCloseTab
(
aWindow
aIndex
)
{
if
(
!
aWindow
.
__SSi
)
{
throw
Components
.
Exception
(
"
Window
is
not
tracked
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
var
closedTabs
=
this
.
_windows
[
aWindow
.
__SSi
]
.
_closedTabs
;
aIndex
=
aIndex
|
|
0
;
if
(
!
(
aIndex
in
closedTabs
)
)
{
throw
Components
.
Exception
(
"
Invalid
index
:
not
in
the
closed
tabs
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
let
{
state
pos
}
=
this
.
removeClosedTabData
(
closedTabs
aIndex
)
;
let
tabbrowser
=
aWindow
.
gBrowser
;
let
tab
=
tabbrowser
.
selectedTab
=
tabbrowser
.
addTrustedTab
(
null
{
index
:
pos
pinned
:
state
.
pinned
userContextId
:
state
.
userContextId
}
)
;
this
.
restoreTab
(
tab
state
)
;
this
.
_notifyOfClosedObjectsChange
(
)
;
return
tab
;
}
forgetClosedTab
:
function
ssi_forgetClosedTab
(
aWindow
aIndex
)
{
if
(
!
aWindow
.
__SSi
)
{
throw
Components
.
Exception
(
"
Window
is
not
tracked
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
var
closedTabs
=
this
.
_windows
[
aWindow
.
__SSi
]
.
_closedTabs
;
aIndex
=
aIndex
|
|
0
;
if
(
!
(
aIndex
in
closedTabs
)
)
{
throw
Components
.
Exception
(
"
Invalid
index
:
not
in
the
closed
tabs
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
this
.
removeClosedTabData
(
closedTabs
aIndex
)
;
this
.
_notifyOfClosedObjectsChange
(
)
;
}
getClosedWindowCount
:
function
ssi_getClosedWindowCount
(
)
{
return
this
.
_closedWindows
.
length
;
}
getClosedWindowData
:
function
ssi_getClosedWindowData
(
aAsString
=
true
)
{
return
aAsString
?
JSON
.
stringify
(
this
.
_closedWindows
)
:
Cu
.
cloneInto
(
this
.
_closedWindows
{
}
)
;
}
undoCloseWindow
:
function
ssi_undoCloseWindow
(
aIndex
)
{
if
(
!
(
aIndex
in
this
.
_closedWindows
)
)
{
throw
Components
.
Exception
(
"
Invalid
index
:
not
in
the
closed
windows
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
let
state
=
{
windows
:
this
.
_removeClosedWindow
(
aIndex
)
}
;
delete
state
.
windows
[
0
]
.
closedAt
;
let
window
=
this
.
_openWindowWithState
(
state
)
;
this
.
windowToFocus
=
window
;
WINDOW_SHOWING_PROMISES
.
get
(
window
)
.
promise
.
then
(
win
=
>
this
.
restoreWindows
(
win
state
{
overwriteTabs
:
true
}
)
)
;
this
.
_notifyOfClosedObjectsChange
(
)
;
return
window
;
}
forgetClosedWindow
:
function
ssi_forgetClosedWindow
(
aIndex
)
{
aIndex
=
aIndex
|
|
0
;
if
(
!
(
aIndex
in
this
.
_closedWindows
)
)
{
throw
Components
.
Exception
(
"
Invalid
index
:
not
in
the
closed
windows
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
let
winData
=
this
.
_closedWindows
[
aIndex
]
;
this
.
_removeClosedWindow
(
aIndex
)
;
this
.
_saveableClosedWindowData
.
delete
(
winData
)
;
this
.
_notifyOfClosedObjectsChange
(
)
;
}
getCustomWindowValue
(
aWindow
aKey
)
{
if
(
"
__SSi
"
in
aWindow
)
{
let
data
=
this
.
_windows
[
aWindow
.
__SSi
]
.
extData
|
|
{
}
;
return
data
[
aKey
]
|
|
"
"
;
}
if
(
DyingWindowCache
.
has
(
aWindow
)
)
{
let
data
=
DyingWindowCache
.
get
(
aWindow
)
.
extData
|
|
{
}
;
return
data
[
aKey
]
|
|
"
"
;
}
throw
Components
.
Exception
(
"
Window
is
not
tracked
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
setCustomWindowValue
(
aWindow
aKey
aStringValue
)
{
if
(
typeof
aStringValue
!
=
"
string
"
)
{
throw
new
TypeError
(
"
setCustomWindowValue
only
accepts
string
values
"
)
;
}
if
(
!
(
"
__SSi
"
in
aWindow
)
)
{
throw
Components
.
Exception
(
"
Window
is
not
tracked
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
if
(
!
this
.
_windows
[
aWindow
.
__SSi
]
.
extData
)
{
this
.
_windows
[
aWindow
.
__SSi
]
.
extData
=
{
}
;
}
this
.
_windows
[
aWindow
.
__SSi
]
.
extData
[
aKey
]
=
aStringValue
;
this
.
saveStateDelayed
(
aWindow
)
;
}
deleteCustomWindowValue
(
aWindow
aKey
)
{
if
(
aWindow
.
__SSi
&
&
this
.
_windows
[
aWindow
.
__SSi
]
.
extData
&
&
this
.
_windows
[
aWindow
.
__SSi
]
.
extData
[
aKey
]
)
delete
this
.
_windows
[
aWindow
.
__SSi
]
.
extData
[
aKey
]
;
this
.
saveStateDelayed
(
aWindow
)
;
}
getCustomTabValue
(
aTab
aKey
)
{
return
(
TAB_CUSTOM_VALUES
.
get
(
aTab
)
|
|
{
}
)
[
aKey
]
|
|
"
"
;
}
setCustomTabValue
(
aTab
aKey
aStringValue
)
{
if
(
typeof
aStringValue
!
=
"
string
"
)
{
throw
new
TypeError
(
"
setCustomTabValue
only
accepts
string
values
"
)
;
}
if
(
!
TAB_CUSTOM_VALUES
.
has
(
aTab
)
)
{
TAB_CUSTOM_VALUES
.
set
(
aTab
{
}
)
;
}
TAB_CUSTOM_VALUES
.
get
(
aTab
)
[
aKey
]
=
aStringValue
;
this
.
saveStateDelayed
(
aTab
.
ownerGlobal
)
;
}
deleteCustomTabValue
(
aTab
aKey
)
{
let
state
=
TAB_CUSTOM_VALUES
.
get
(
aTab
)
;
if
(
state
&
&
aKey
in
state
)
{
delete
state
[
aKey
]
;
this
.
saveStateDelayed
(
aTab
.
ownerGlobal
)
;
}
}
getLazyTabValue
(
aTab
aKey
)
{
return
(
TAB_LAZY_STATES
.
get
(
aTab
)
|
|
{
}
)
[
aKey
]
;
}
getCustomGlobalValue
(
aKey
)
{
return
this
.
_globalState
.
get
(
aKey
)
;
}
setCustomGlobalValue
(
aKey
aStringValue
)
{
if
(
typeof
aStringValue
!
=
"
string
"
)
{
throw
new
TypeError
(
"
setCustomGlobalValue
only
accepts
string
values
"
)
;
}
this
.
_globalState
.
set
(
aKey
aStringValue
)
;
this
.
saveStateDelayed
(
)
;
}
deleteCustomGlobalValue
(
aKey
)
{
this
.
_globalState
.
delete
(
aKey
)
;
this
.
saveStateDelayed
(
)
;
}
persistTabAttribute
:
function
ssi_persistTabAttribute
(
aName
)
{
if
(
TabAttributes
.
persist
(
aName
)
)
{
this
.
saveStateDelayed
(
)
;
}
}
undoCloseById
(
aClosedId
aIncludePrivate
=
true
)
{
for
(
let
i
=
0
l
=
this
.
_closedWindows
.
length
;
i
<
l
;
i
+
+
)
{
if
(
this
.
_closedWindows
[
i
]
.
closedId
=
=
aClosedId
)
{
return
this
.
undoCloseWindow
(
i
)
;
}
}
for
(
let
window
of
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
)
{
if
(
!
aIncludePrivate
&
&
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
{
continue
;
}
let
windowState
=
this
.
_windows
[
window
.
__SSi
]
;
if
(
windowState
)
{
for
(
let
j
=
0
l
=
windowState
.
_closedTabs
.
length
;
j
<
l
;
j
+
+
)
{
if
(
windowState
.
_closedTabs
[
j
]
.
closedId
=
=
aClosedId
)
{
return
this
.
undoCloseTab
(
window
j
)
;
}
}
}
}
return
undefined
;
}
updateTabLabelAndIcon
(
tab
tabData
=
null
)
{
if
(
tab
.
hasAttribute
(
"
customizemode
"
)
)
{
return
;
}
let
browser
=
tab
.
linkedBrowser
;
let
win
=
browser
.
ownerGlobal
;
if
(
!
tabData
)
{
tabData
=
TabState
.
collect
(
tab
TAB_CUSTOM_VALUES
.
get
(
tab
)
)
;
if
(
!
tabData
)
{
throw
new
Error
(
"
tabData
not
found
for
given
tab
"
)
;
}
}
let
activePageData
=
tabData
.
entries
[
tabData
.
index
-
1
]
|
|
null
;
if
(
activePageData
)
{
if
(
activePageData
.
title
&
&
activePageData
.
title
!
=
activePageData
.
url
)
{
win
.
gBrowser
.
setInitialTabTitle
(
tab
activePageData
.
title
{
isContentTitle
:
true
}
)
;
}
else
{
win
.
gBrowser
.
setInitialTabTitle
(
tab
activePageData
.
url
)
;
}
}
if
(
"
image
"
in
tabData
)
{
if
(
!
activePageData
|
|
(
activePageData
&
&
activePageData
.
url
!
=
"
about
:
blank
"
)
)
{
win
.
gBrowser
.
setIcon
(
tab
tabData
.
image
undefined
tabData
.
iconLoadingPrincipal
)
;
}
TabStateCache
.
update
(
browser
{
image
:
null
iconLoadingPrincipal
:
null
}
)
;
}
}
_forgetTabsWithUserContextId
(
userContextId
)
{
for
(
let
window
of
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
)
{
let
windowState
=
this
.
_windows
[
window
.
__SSi
]
;
if
(
windowState
)
{
let
indexes
=
[
]
;
windowState
.
_closedTabs
.
forEach
(
(
closedTab
index
)
=
>
{
if
(
closedTab
.
state
.
userContextId
=
=
userContextId
)
{
indexes
.
push
(
index
)
;
}
}
)
;
for
(
let
index
of
indexes
.
reverse
(
)
)
{
this
.
removeClosedTabData
(
windowState
.
_closedTabs
index
)
;
}
}
}
this
.
_notifyOfClosedObjectsChange
(
)
;
}
restoreLastSession
:
function
ssi_restoreLastSession
(
)
{
if
(
!
this
.
canRestoreLastSession
)
{
throw
Components
.
Exception
(
"
Last
session
can
not
be
restored
"
)
;
}
Services
.
obs
.
notifyObservers
(
null
NOTIFY_INITIATING_MANUAL_RESTORE
)
;
let
windows
=
{
}
;
for
(
let
window
of
this
.
_browserWindows
)
{
if
(
window
.
__SS_lastSessionWindowID
)
windows
[
window
.
__SS_lastSessionWindowID
]
=
window
;
}
let
lastSessionState
=
LastSession
.
getState
(
)
;
if
(
!
lastSessionState
.
windows
.
length
)
{
throw
Components
.
Exception
(
"
lastSessionState
has
no
windows
"
Cr
.
NS_ERROR_UNEXPECTED
)
;
}
this
.
_restoreCount
=
lastSessionState
.
windows
.
length
;
this
.
_browserSetState
=
true
;
let
lastWindow
=
this
.
_getTopWindow
(
)
;
let
canUseLastWindow
=
lastWindow
&
&
!
lastWindow
.
__SS_lastSessionWindowID
;
this
.
_globalState
.
setFromState
(
lastSessionState
)
;
let
openWindows
=
[
]
;
let
windowsToOpen
=
[
]
;
SessionCookies
.
restore
(
lastSessionState
.
cookies
|
|
[
]
)
;
for
(
let
i
=
0
;
i
<
lastSessionState
.
windows
.
length
;
i
+
+
)
{
let
winState
=
lastSessionState
.
windows
[
i
]
;
let
lastSessionWindowID
=
winState
.
__lastSessionWindowID
;
delete
winState
.
__lastSessionWindowID
;
let
windowToUse
=
windows
[
lastSessionWindowID
]
;
if
(
!
windowToUse
&
&
canUseLastWindow
)
{
windowToUse
=
lastWindow
;
canUseLastWindow
=
false
;
}
let
[
canUseWindow
canOverwriteTabs
]
=
this
.
_prepWindowToRestoreInto
(
windowToUse
)
;
if
(
canUseWindow
)
{
if
(
winState
.
_closedTabs
&
&
winState
.
_closedTabs
.
length
)
{
let
curWinState
=
this
.
_windows
[
windowToUse
.
__SSi
]
;
curWinState
.
_closedTabs
=
curWinState
.
_closedTabs
.
concat
(
winState
.
_closedTabs
)
;
curWinState
.
_closedTabs
.
splice
(
this
.
_max_tabs_undo
curWinState
.
_closedTabs
.
length
)
;
}
this
.
_updateWindowRestoreState
(
windowToUse
{
windows
:
[
winState
]
options
:
{
overwriteTabs
:
canOverwriteTabs
}
}
)
;
openWindows
.
push
(
windowToUse
)
;
}
else
{
windowsToOpen
.
push
(
winState
)
;
}
}
this
.
_openWindows
(
{
windows
:
windowsToOpen
}
)
.
then
(
openedWindows
=
>
this
.
_restoreWindowsInReversedZOrder
(
openWindows
.
concat
(
openedWindows
)
)
)
;
if
(
lastSessionState
.
_closedWindows
)
{
this
.
_closedWindows
=
this
.
_closedWindows
.
concat
(
lastSessionState
.
_closedWindows
)
;
this
.
_capClosedWindows
(
)
;
this
.
_closedObjectsChanged
=
true
;
}
DevToolsShim
.
restoreDevToolsSession
(
lastSessionState
)
;
this
.
_recentCrashes
=
lastSessionState
.
session
&
&
lastSessionState
.
session
.
recentCrashes
|
|
0
;
this
.
_updateSessionStartTime
(
lastSessionState
)
;
LastSession
.
clear
(
)
;
this
.
_notifyOfClosedObjectsChange
(
)
;
}
reviveCrashedTab
(
aTab
)
{
if
(
!
aTab
)
{
throw
new
Error
(
"
SessionStore
.
reviveCrashedTab
expected
a
tab
but
got
null
.
"
)
;
}
let
browser
=
aTab
.
linkedBrowser
;
if
(
!
this
.
_crashedBrowsers
.
has
(
browser
.
permanentKey
)
)
{
return
;
}
if
(
browser
.
isRemoteBrowser
)
{
throw
new
Error
(
"
SessionStore
.
reviveCrashedTab
:
"
+
"
Somehow
a
crashed
browser
is
still
remote
.
"
)
;
}
aTab
.
removeAttribute
(
"
crashed
"
)
;
browser
.
loadURI
(
"
about
:
blank
"
{
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
createNullPrincipal
(
{
userContextId
:
aTab
.
userContextId
}
)
}
)
;
let
data
=
TabState
.
collect
(
aTab
TAB_CUSTOM_VALUES
.
get
(
aTab
)
)
;
this
.
restoreTab
(
aTab
data
{
forceOnDemand
:
true
}
)
;
}
reviveAllCrashedTabs
(
)
{
for
(
let
window
of
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
)
{
for
(
let
tab
of
window
.
gBrowser
.
tabs
)
{
this
.
reviveCrashedTab
(
tab
)
;
}
}
}
navigateAndRestore
(
tab
loadArguments
historyIndex
)
{
let
window
=
tab
.
ownerGlobal
;
if
(
!
window
.
__SSi
)
{
Cu
.
reportError
(
"
Tab
'
s
window
must
be
tracked
.
"
)
;
return
Promise
.
reject
(
)
;
}
let
browser
=
tab
.
linkedBrowser
;
if
(
this
.
_remotenessChangingBrowsers
.
has
(
browser
.
permanentKey
)
)
{
let
opts
=
this
.
_remotenessChangingBrowsers
.
get
(
browser
.
permanentKey
)
;
opts
.
loadArguments
=
loadArguments
;
return
opts
.
promise
;
}
let
promise
=
this
.
_asyncNavigateAndRestore
(
tab
)
;
this
.
_remotenessChangingBrowsers
.
set
(
browser
.
permanentKey
{
loadArguments
historyIndex
promise
}
)
;
let
uriObj
;
try
{
uriObj
=
Services
.
io
.
newURI
(
loadArguments
.
uri
)
;
}
catch
(
e
)
{
}
if
(
!
uriObj
|
|
(
uriObj
&
&
!
window
.
gBrowser
.
isLocalAboutURI
(
uriObj
)
)
)
{
tab
.
setAttribute
(
"
busy
"
"
true
"
)
;
}
window
.
gBrowser
.
setDefaultIcon
(
tab
uriObj
)
;
TAB_STATE_FOR_BROWSER
.
set
(
tab
.
linkedBrowser
TAB_STATE_WILL_RESTORE
)
;
this
.
_notifyOfClosedObjectsChange
(
)
;
return
promise
;
}
async
_asyncNavigateAndRestore
(
tab
)
{
let
permanentKey
=
tab
.
linkedBrowser
.
permanentKey
;
await
TabStateFlusher
.
flush
(
tab
.
linkedBrowser
)
;
let
{
loadArguments
historyIndex
}
=
this
.
_remotenessChangingBrowsers
.
get
(
permanentKey
)
;
this
.
_remotenessChangingBrowsers
.
delete
(
permanentKey
)
;
if
(
tab
.
closing
|
|
!
tab
.
linkedBrowser
)
{
return
;
}
let
window
=
tab
.
ownerGlobal
;
if
(
!
window
|
|
!
window
.
__SSi
|
|
window
.
closed
)
{
return
;
}
let
tabState
=
TabState
.
clone
(
tab
TAB_CUSTOM_VALUES
.
get
(
tab
)
)
;
let
options
=
{
restoreImmediately
:
true
newFrameloader
:
loadArguments
.
newFrameloader
remoteType
:
loadArguments
.
remoteType
restoreContentReason
:
RESTORE_TAB_CONTENT_REASON
.
NAVIGATE_AND_RESTORE
}
;
if
(
historyIndex
>
=
0
)
{
tabState
.
index
=
historyIndex
+
1
;
tabState
.
index
=
Math
.
max
(
1
Math
.
min
(
tabState
.
index
tabState
.
entries
.
length
)
)
;
}
else
{
options
.
loadArguments
=
loadArguments
;
if
(
loadArguments
.
redirectLoadSwitchId
)
{
loadArguments
.
redirectHistoryIndex
=
tabState
.
requestedIndex
-
1
;
}
}
if
(
TAB_STATE_FOR_BROWSER
.
has
(
tab
.
linkedBrowser
)
)
{
this
.
_resetLocalTabRestoringState
(
tab
)
;
}
this
.
restoreTab
(
tab
tabState
options
)
;
}
getSessionHistory
(
tab
updatedCallback
)
{
if
(
updatedCallback
)
{
TabStateFlusher
.
flush
(
tab
.
linkedBrowser
)
.
then
(
(
)
=
>
{
let
sessionHistory
=
this
.
getSessionHistory
(
tab
)
;
if
(
sessionHistory
)
{
updatedCallback
(
sessionHistory
)
;
}
}
)
;
}
if
(
tab
.
linkedBrowser
)
{
let
tabState
=
TabState
.
collect
(
tab
TAB_CUSTOM_VALUES
.
get
(
tab
)
)
;
return
{
index
:
tabState
.
index
-
1
entries
:
tabState
.
entries
}
;
}
return
null
;
}
_prepWindowToRestoreInto
:
function
ssi_prepWindowToRestoreInto
(
aWindow
)
{
if
(
!
aWindow
)
return
[
false
false
]
;
let
canOverwriteTabs
=
false
;
let
homePages
=
[
"
about
:
blank
"
]
;
let
removableTabs
=
[
]
;
let
tabbrowser
=
aWindow
.
gBrowser
;
let
startupPref
=
this
.
_prefBranch
.
getIntPref
(
"
startup
.
page
"
)
;
if
(
startupPref
=
=
1
)
homePages
=
homePages
.
concat
(
HomePage
.
get
(
)
.
split
(
"
|
"
)
)
;
for
(
let
i
=
tabbrowser
.
_numPinnedTabs
;
i
<
tabbrowser
.
tabs
.
length
;
i
+
+
)
{
let
tab
=
tabbrowser
.
tabs
[
i
]
;
if
(
homePages
.
includes
(
tab
.
linkedBrowser
.
currentURI
.
spec
)
)
{
removableTabs
.
push
(
tab
)
;
}
}
if
(
tabbrowser
.
tabs
.
length
=
=
removableTabs
.
length
)
{
canOverwriteTabs
=
true
;
}
else
{
for
(
let
i
=
removableTabs
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
tabbrowser
.
removeTab
(
removableTabs
.
pop
(
)
{
animate
:
false
}
)
;
}
}
return
[
true
canOverwriteTabs
]
;
}
_updateWindowFeatures
:
function
ssi_updateWindowFeatures
(
aWindow
)
{
var
winData
=
this
.
_windows
[
aWindow
.
__SSi
]
;
WINDOW_ATTRIBUTES
.
forEach
(
function
(
aAttr
)
{
winData
[
aAttr
]
=
this
.
_getWindowDimension
(
aWindow
aAttr
)
;
}
this
)
;
var
hidden
=
WINDOW_HIDEABLE_FEATURES
.
filter
(
function
(
aItem
)
{
return
aWindow
[
aItem
]
&
&
!
aWindow
[
aItem
]
.
visible
;
}
)
;
if
(
hidden
.
length
!
=
0
)
winData
.
hidden
=
hidden
.
join
(
"
"
)
;
else
if
(
winData
.
hidden
)
delete
winData
.
hidden
;
let
sidebarBox
=
aWindow
.
document
.
getElementById
(
"
sidebar
-
box
"
)
;
let
sidebar
=
sidebarBox
.
getAttribute
(
"
sidebarcommand
"
)
;
if
(
sidebar
&
&
sidebarBox
.
getAttribute
(
"
checked
"
)
=
=
"
true
"
)
winData
.
sidebar
=
sidebar
;
else
if
(
winData
.
sidebar
)
delete
winData
.
sidebar
;
}
getCurrentState
(
aUpdateAll
)
{
this
.
_handleClosedWindows
(
)
.
then
(
(
)
=
>
{
this
.
_notifyOfClosedObjectsChange
(
)
;
}
)
;
var
activeWindow
=
this
.
_getTopWindow
(
)
;
TelemetryStopwatch
.
start
(
"
FX_SESSION_RESTORE_COLLECT_ALL_WINDOWS_DATA_MS
"
)
;
if
(
RunState
.
isRunning
)
{
let
index
=
0
;
for
(
let
window
of
this
.
_browserWindows
)
{
if
(
!
this
.
_isWindowLoaded
(
window
)
)
continue
;
if
(
aUpdateAll
|
|
DirtyWindows
.
has
(
window
)
|
|
window
=
=
activeWindow
)
{
this
.
_collectWindowData
(
window
)
;
}
else
{
this
.
_updateWindowFeatures
(
window
)
;
}
this
.
_windows
[
window
.
__SSi
]
.
zIndex
=
+
+
index
;
}
DirtyWindows
.
clear
(
)
;
}
TelemetryStopwatch
.
finish
(
"
FX_SESSION_RESTORE_COLLECT_ALL_WINDOWS_DATA_MS
"
)
;
var
total
=
[
]
;
var
ids
=
[
]
;
var
nonPopupCount
=
0
;
var
ix
;
for
(
ix
in
this
.
_windows
)
{
if
(
this
.
_windows
[
ix
]
.
_restoring
)
continue
;
total
.
push
(
this
.
_windows
[
ix
]
)
;
ids
.
push
(
ix
)
;
if
(
!
this
.
_windows
[
ix
]
.
isPopup
)
nonPopupCount
+
+
;
}
for
(
ix
in
this
.
_statesToRestore
)
{
for
(
let
winData
of
this
.
_statesToRestore
[
ix
]
.
windows
)
{
total
.
push
(
winData
)
;
if
(
!
winData
.
isPopup
)
nonPopupCount
+
+
;
}
}
let
lastClosedWindowsCopy
=
this
.
_closedWindows
.
slice
(
)
;
if
(
AppConstants
.
platform
!
=
"
macosx
"
)
{
if
(
nonPopupCount
=
=
0
&
&
lastClosedWindowsCopy
.
length
>
0
&
&
RunState
.
isQuitting
)
{
do
{
total
.
unshift
(
lastClosedWindowsCopy
.
shift
(
)
)
;
}
while
(
total
[
0
]
.
isPopup
&
&
lastClosedWindowsCopy
.
length
>
0
)
;
}
}
if
(
activeWindow
)
{
this
.
activeWindowSSiCache
=
activeWindow
.
__SSi
|
|
"
"
;
}
ix
=
ids
.
indexOf
(
this
.
activeWindowSSiCache
)
;
if
(
ix
!
=
-
1
&
&
total
[
ix
]
&
&
total
[
ix
]
.
sizemode
=
=
"
minimized
"
)
ix
=
-
1
;
let
session
=
{
lastUpdate
:
Date
.
now
(
)
startTime
:
this
.
_sessionStartTime
recentCrashes
:
this
.
_recentCrashes
}
;
let
state
=
{
version
:
[
"
sessionrestore
"
FORMAT_VERSION
]
windows
:
total
selectedWindow
:
ix
+
1
_closedWindows
:
lastClosedWindowsCopy
session
global
:
this
.
_globalState
.
getState
(
)
}
;
state
.
cookies
=
SessionCookies
.
collect
(
)
;
DevToolsShim
.
saveDevToolsSession
(
state
)
;
if
(
LastSession
.
canRestore
)
{
state
.
lastSessionState
=
LastSession
.
getState
(
)
;
}
if
(
this
.
_deferredInitialState
)
{
state
.
deferredInitialState
=
this
.
_deferredInitialState
;
}
return
state
;
}
_getWindowState
:
function
ssi_getWindowState
(
aWindow
)
{
if
(
!
this
.
_isWindowLoaded
(
aWindow
)
)
return
this
.
_statesToRestore
[
WINDOW_RESTORE_IDS
.
get
(
aWindow
)
]
;
if
(
RunState
.
isRunning
)
{
this
.
_collectWindowData
(
aWindow
)
;
}
return
{
windows
:
[
this
.
_windows
[
aWindow
.
__SSi
]
]
}
;
}
_collectWindowData
:
function
ssi_collectWindowData
(
aWindow
)
{
let
tabMap
=
new
Map
(
)
;
if
(
!
this
.
_isWindowLoaded
(
aWindow
)
)
return
tabMap
;
let
tabbrowser
=
aWindow
.
gBrowser
;
let
tabs
=
tabbrowser
.
tabs
;
let
winData
=
this
.
_windows
[
aWindow
.
__SSi
]
;
let
tabsData
=
winData
.
tabs
=
[
]
;
for
(
let
tab
of
tabs
)
{
let
tabData
=
TabState
.
collect
(
tab
TAB_CUSTOM_VALUES
.
get
(
tab
)
)
;
tabMap
.
set
(
tab
tabData
)
;
tabsData
.
push
(
tabData
)
;
}
winData
.
selected
=
tabbrowser
.
tabbox
.
selectedIndex
+
1
;
this
.
_updateWindowFeatures
(
aWindow
)
;
if
(
aWindow
.
__SS_lastSessionWindowID
)
this
.
_windows
[
aWindow
.
__SSi
]
.
__lastSessionWindowID
=
aWindow
.
__SS_lastSessionWindowID
;
DirtyWindows
.
remove
(
aWindow
)
;
return
tabMap
;
}
_openWindows
(
root
)
{
for
(
let
winData
of
root
.
windows
)
{
if
(
!
winData
|
|
!
winData
.
tabs
|
|
!
winData
.
tabs
[
0
]
)
continue
;
this
.
_openWindowWithState
(
{
windows
:
[
winData
]
}
)
;
}
return
Promise
.
all
(
[
.
.
.
WINDOW_SHOWING_PROMISES
.
values
(
)
]
.
map
(
deferred
=
>
deferred
.
promise
)
)
;
}
restoreWindow
:
function
ssi_restoreWindow
(
aWindow
winData
aOptions
=
{
}
)
{
let
overwriteTabs
=
aOptions
&
&
aOptions
.
overwriteTabs
;
let
firstWindow
=
aOptions
&
&
aOptions
.
firstWindow
;
if
(
aWindow
&
&
(
!
aWindow
.
__SSi
|
|
!
this
.
_windows
[
aWindow
.
__SSi
]
)
)
this
.
onLoad
(
aWindow
)
;
TelemetryStopwatch
.
start
(
"
FX_SESSION_RESTORE_RESTORE_WINDOW_MS
"
)
;
this
.
_setWindowStateBusy
(
aWindow
)
;
if
(
!
winData
.
tabs
)
{
winData
.
tabs
=
[
]
;
}
else
if
(
firstWindow
&
&
!
overwriteTabs
&
&
winData
.
tabs
.
length
=
=
1
&
&
(
!
winData
.
tabs
[
0
]
.
entries
|
|
winData
.
tabs
[
0
]
.
entries
.
length
=
=
0
)
)
{
winData
.
tabs
=
[
]
;
}
let
selectTab
=
0
;
if
(
overwriteTabs
)
{
selectTab
=
parseInt
(
winData
.
selected
|
|
1
10
)
;
selectTab
=
Math
.
max
(
selectTab
1
)
;
selectTab
=
Math
.
min
(
selectTab
winData
.
tabs
.
length
)
;
}
let
tabbrowser
=
aWindow
.
gBrowser
;
let
newTabCount
=
winData
.
tabs
.
length
;
var
tabs
=
[
]
;
let
arrowScrollbox
=
tabbrowser
.
tabContainer
.
arrowScrollbox
;
let
smoothScroll
=
arrowScrollbox
.
smoothScroll
;
arrowScrollbox
.
smoothScroll
=
false
;
let
initialTabs
;
if
(
!
overwriteTabs
&
&
firstWindow
)
{
initialTabs
=
Array
.
slice
(
tabbrowser
.
tabs
)
;
}
if
(
overwriteTabs
)
{
for
(
let
i
=
tabbrowser
.
browsers
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
if
(
!
tabbrowser
.
tabs
[
i
]
.
selected
)
{
tabbrowser
.
removeTab
(
tabbrowser
.
tabs
[
i
]
)
;
}
}
}
let
restoreTabsLazily
=
this
.
_prefBranch
.
getBoolPref
(
"
sessionstore
.
restore_tabs_lazily
"
)
&
&
this
.
_restore_on_demand
;
for
(
var
t
=
0
;
t
<
newTabCount
;
t
+
+
)
{
let
tabData
=
winData
.
tabs
[
t
]
;
let
userContextId
=
tabData
.
userContextId
;
let
select
=
t
=
=
selectTab
-
1
;
let
tab
;
if
(
select
&
&
tabbrowser
.
selectedTab
.
userContextId
=
=
userContextId
)
{
tab
=
tabbrowser
.
selectedTab
;
if
(
!
tabData
.
pinned
)
{
tabbrowser
.
unpinTab
(
tab
)
;
}
tabbrowser
.
moveTabToEnd
(
)
;
if
(
aWindow
.
gMultiProcessBrowser
&
&
!
tab
.
linkedBrowser
.
isRemoteBrowser
)
{
tabbrowser
.
updateBrowserRemoteness
(
tab
.
linkedBrowser
true
)
;
}
}
if
(
!
tab
)
{
let
createLazyBrowser
=
restoreTabsLazily
&
&
!
select
&
&
!
tabData
.
pinned
;
let
url
=
"
about
:
blank
"
;
if
(
createLazyBrowser
&
&
tabData
.
entries
&
&
tabData
.
entries
.
length
)
{
let
activeIndex
=
(
tabData
.
index
|
|
tabData
.
entries
.
length
)
-
1
;
activeIndex
=
Math
.
min
(
activeIndex
tabData
.
entries
.
length
-
1
)
;
activeIndex
=
Math
.
max
(
activeIndex
0
)
;
url
=
tabData
.
entries
[
activeIndex
]
.
url
;
}
tab
=
tabbrowser
.
addTrustedTab
(
url
{
createLazyBrowser
skipAnimation
:
true
allowInheritPrincipal
:
true
noInitialLabel
:
true
userContextId
skipBackgroundNotify
:
true
bulkOrderedOpen
:
true
}
)
;
if
(
select
)
{
let
leftoverTab
=
tabbrowser
.
selectedTab
;
tabbrowser
.
selectedTab
=
tab
;
tabbrowser
.
removeTab
(
leftoverTab
)
;
}
}
tabs
.
push
(
tab
)
;
if
(
tabData
.
hidden
)
{
tabbrowser
.
hideTab
(
tab
tabData
.
extData
&
&
tabData
.
extData
.
hiddenBy
)
;
}
if
(
tabData
.
pinned
)
{
tabbrowser
.
pinTab
(
tab
)
;
}
}
if
(
initialTabs
)
{
let
endPosition
=
tabbrowser
.
tabs
.
length
-
1
;
for
(
let
i
=
0
;
i
<
initialTabs
.
length
;
i
+
+
)
{
tabbrowser
.
unpinTab
(
initialTabs
[
i
]
)
;
tabbrowser
.
moveTabTo
(
initialTabs
[
i
]
endPosition
)
;
}
}
delete
aWindow
.
__SS_lastSessionWindowID
;
if
(
winData
.
__lastSessionWindowID
)
aWindow
.
__SS_lastSessionWindowID
=
winData
.
__lastSessionWindowID
;
if
(
overwriteTabs
)
{
delete
this
.
_windows
[
aWindow
.
__SSi
]
.
extData
;
}
SessionCookies
.
restore
(
winData
.
cookies
|
|
[
]
)
;
if
(
winData
.
extData
)
{
if
(
!
this
.
_windows
[
aWindow
.
__SSi
]
.
extData
)
{
this
.
_windows
[
aWindow
.
__SSi
]
.
extData
=
{
}
;
}
for
(
var
key
in
winData
.
extData
)
{
this
.
_windows
[
aWindow
.
__SSi
]
.
extData
[
key
]
=
winData
.
extData
[
key
]
;
}
}
let
newClosedTabsData
=
winData
.
_closedTabs
|
|
[
]
;
if
(
overwriteTabs
|
|
firstWindow
)
{
this
.
_windows
[
aWindow
.
__SSi
]
.
_closedTabs
=
newClosedTabsData
;
}
else
if
(
this
.
_max_tabs_undo
>
0
)
{
newClosedTabsData
=
newClosedTabsData
.
concat
(
this
.
_windows
[
aWindow
.
__SSi
]
.
_closedTabs
)
;
this
.
_windows
[
aWindow
.
__SSi
]
.
_closedTabs
=
newClosedTabsData
.
slice
(
0
this
.
_max_tabs_undo
)
;
}
if
(
winData
.
tabs
.
length
)
{
this
.
restoreTabs
(
aWindow
tabs
winData
.
tabs
selectTab
)
;
}
arrowScrollbox
.
smoothScroll
=
smoothScroll
;
TelemetryStopwatch
.
finish
(
"
FX_SESSION_RESTORE_RESTORE_WINDOW_MS
"
)
;
this
.
_setWindowStateReady
(
aWindow
)
;
this
.
_sendWindowRestoredNotification
(
aWindow
)
;
Services
.
obs
.
notifyObservers
(
aWindow
NOTIFY_SINGLE_WINDOW_RESTORED
)
;
this
.
_sendRestoreCompletedNotifications
(
)
;
}
prepareConnectionToHost
(
tab
url
)
{
if
(
!
url
.
startsWith
(
"
about
:
"
)
)
{
let
principal
=
Services
.
scriptSecurityManager
.
createNullPrincipal
(
{
userContextId
:
tab
.
userContextId
}
)
;
let
sc
=
Services
.
io
.
QueryInterface
(
Ci
.
nsISpeculativeConnect
)
;
let
uri
=
Services
.
io
.
newURI
(
url
)
;
sc
.
speculativeConnect2
(
uri
principal
null
)
;
return
true
;
}
return
false
;
}
speculativeConnectOnTabHover
(
tab
)
{
let
tabState
=
TAB_LAZY_STATES
.
get
(
tab
)
;
if
(
tabState
&
&
!
tabState
.
connectionPrepared
)
{
let
url
=
this
.
getLazyTabValue
(
tab
"
url
"
)
;
let
prepared
=
this
.
prepareConnectionToHost
(
tab
url
)
;
if
(
gDebuggingEnabled
)
{
tab
.
__test_connection_prepared
=
prepared
;
tab
.
__test_connection_url
=
url
;
}
tabState
.
connectionPrepared
=
true
;
}
}
_restoreWindowsFeaturesAndTabs
(
windows
)
{
for
(
let
window
of
windows
)
{
let
state
=
this
.
_statesToRestore
[
WINDOW_RESTORE_IDS
.
get
(
window
)
]
;
this
.
restoreWindowFeatures
(
window
state
.
windows
[
0
]
)
;
}
for
(
let
window
of
windows
)
{
let
state
=
this
.
_statesToRestore
[
WINDOW_RESTORE_IDS
.
get
(
window
)
]
;
this
.
restoreWindow
(
window
state
.
windows
[
0
]
state
.
options
|
|
{
overwriteTabs
:
true
}
)
;
WINDOW_RESTORE_ZINDICES
.
delete
(
window
)
;
}
}
_restoreWindowsInReversedZOrder
(
windows
)
{
windows
.
sort
(
(
a
b
)
=
>
(
WINDOW_RESTORE_ZINDICES
.
get
(
a
)
|
|
0
)
-
(
WINDOW_RESTORE_ZINDICES
.
get
(
b
)
|
|
0
)
)
;
this
.
windowToFocus
=
windows
[
0
]
;
this
.
_restoreWindowsFeaturesAndTabs
(
windows
)
;
}
restoreWindows
:
function
ssi_restoreWindows
(
aWindow
aState
aOptions
=
{
}
)
{
if
(
aWindow
&
&
(
!
aWindow
.
__SSi
|
|
!
this
.
_windows
[
aWindow
.
__SSi
]
)
)
this
.
onLoad
(
aWindow
)
;
let
root
;
try
{
root
=
(
typeof
aState
=
=
"
string
"
)
?
JSON
.
parse
(
aState
)
:
aState
;
}
catch
(
ex
)
{
debug
(
ex
)
;
this
.
_sendRestoreCompletedNotifications
(
)
;
return
;
}
if
(
root
.
_closedWindows
)
{
this
.
_closedWindows
=
root
.
_closedWindows
;
this
.
_closedObjectsChanged
=
true
;
}
if
(
!
root
.
windows
|
|
!
root
.
windows
.
length
)
{
this
.
_sendRestoreCompletedNotifications
(
)
;
return
;
}
let
firstWindowData
=
root
.
windows
.
splice
(
0
1
)
;
this
.
_updateWindowRestoreState
(
aWindow
{
windows
:
firstWindowData
options
:
aOptions
}
)
;
this
.
_openWindows
(
root
)
.
then
(
windows
=
>
{
windows
.
unshift
(
aWindow
)
;
this
.
_restoreWindowsInReversedZOrder
(
windows
)
;
}
)
;
DevToolsShim
.
restoreDevToolsSession
(
aState
)
;
}
restoreTabs
(
aWindow
aTabs
aTabData
aSelectTab
)
{
var
tabbrowser
=
aWindow
.
gBrowser
;
if
(
!
this
.
_isWindowLoaded
(
aWindow
)
)
{
delete
this
.
_statesToRestore
[
WINDOW_RESTORE_IDS
.
get
(
aWindow
)
]
;
WINDOW_RESTORE_IDS
.
delete
(
aWindow
)
;
delete
this
.
_windows
[
aWindow
.
__SSi
]
.
_restoring
;
}
let
numTabsToRestore
=
aTabs
.
length
;
let
numTabsInWindow
=
tabbrowser
.
tabs
.
length
;
let
tabsDataArray
=
this
.
_windows
[
aWindow
.
__SSi
]
.
tabs
;
if
(
numTabsInWindow
=
=
numTabsToRestore
)
{
tabsDataArray
.
length
=
0
;
}
else
{
tabsDataArray
.
splice
(
numTabsInWindow
-
numTabsToRestore
)
;
}
tabsDataArray
.
length
=
numTabsInWindow
;
if
(
aSelectTab
>
0
&
&
aSelectTab
<
=
aTabs
.
length
)
{
this
.
_windows
[
aWindow
.
__SSi
]
.
selected
=
aSelectTab
;
}
let
selectedIndex
=
aTabs
.
indexOf
(
tabbrowser
.
selectedTab
)
;
if
(
selectedIndex
>
-
1
)
{
this
.
restoreTab
(
tabbrowser
.
selectedTab
aTabData
[
selectedIndex
]
)
;
}
for
(
let
t
=
0
;
t
<
aTabs
.
length
;
t
+
+
)
{
if
(
t
!
=
selectedIndex
)
{
this
.
restoreTab
(
aTabs
[
t
]
aTabData
[
t
]
)
;
}
}
}
restoreTab
(
tab
tabData
options
=
{
}
)
{
let
browser
=
tab
.
linkedBrowser
;
if
(
TAB_STATE_FOR_BROWSER
.
has
(
browser
)
)
{
Cu
.
reportError
(
"
Must
reset
tab
before
calling
restoreTab
.
"
)
;
return
;
}
let
loadArguments
=
options
.
loadArguments
;
let
window
=
tab
.
ownerGlobal
;
let
tabbrowser
=
window
.
gBrowser
;
let
forceOnDemand
=
options
.
forceOnDemand
;
let
willRestoreImmediately
=
options
.
restoreImmediately
|
|
tabbrowser
.
selectedBrowser
=
=
browser
;
let
isBrowserInserted
=
browser
.
isConnected
;
this
.
_setWindowStateBusy
(
window
)
;
DirtyWindows
.
add
(
window
)
;
for
(
let
otherTab
of
Array
.
slice
(
tabbrowser
.
tabs
0
tab
.
_tPos
)
)
{
let
emptyState
=
{
entries
:
[
]
lastAccessed
:
otherTab
.
lastAccessed
}
;
this
.
_windows
[
window
.
__SSi
]
.
tabs
.
push
(
emptyState
)
;
}
this
.
_windows
[
window
.
__SSi
]
.
tabs
[
tab
.
_tPos
]
=
tabData
;
if
(
tabData
.
pinned
)
{
tabbrowser
.
pinTab
(
tab
)
;
}
else
{
tabbrowser
.
unpinTab
(
tab
)
;
}
if
(
tabData
.
hidden
)
{
tabbrowser
.
hideTab
(
tab
)
;
}
else
{
tabbrowser
.
showTab
(
tab
)
;
}
if
(
!
!
tabData
.
muted
!
=
browser
.
audioMuted
)
{
tab
.
toggleMuteAudio
(
tabData
.
muteReason
)
;
}
if
(
tabData
.
lastAccessed
)
{
tab
.
updateLastAccessed
(
tabData
.
lastAccessed
)
;
}
if
(
"
attributes
"
in
tabData
)
{
Object
.
keys
(
tabData
.
attributes
)
.
forEach
(
a
=
>
TabAttributes
.
persist
(
a
)
)
;
}
if
(
!
tabData
.
entries
)
{
tabData
.
entries
=
[
]
;
}
if
(
tabData
.
extData
)
{
TAB_CUSTOM_VALUES
.
set
(
tab
Cu
.
cloneInto
(
tabData
.
extData
{
}
)
)
;
}
else
{
TAB_CUSTOM_VALUES
.
delete
(
tab
)
;
}
delete
tabData
.
closedAt
;
let
activeIndex
=
(
tabData
.
index
|
|
tabData
.
entries
.
length
)
-
1
;
activeIndex
=
Math
.
min
(
activeIndex
tabData
.
entries
.
length
-
1
)
;
activeIndex
=
Math
.
max
(
activeIndex
0
)
;
tabData
.
index
=
activeIndex
+
1
;
tab
.
setAttribute
(
"
pending
"
"
true
"
)
;
this
.
_crashedBrowsers
.
delete
(
browser
.
permanentKey
)
;
TabStateCache
.
update
(
browser
{
history
:
{
entries
:
[
.
.
.
tabData
.
entries
]
index
:
tabData
.
index
}
scroll
:
tabData
.
scroll
|
|
null
storage
:
tabData
.
storage
|
|
null
formdata
:
tabData
.
formdata
|
|
null
disallow
:
tabData
.
disallow
|
|
null
userContextId
:
tabData
.
userContextId
|
|
0
image
:
tabData
.
image
|
|
"
"
iconLoadingPrincipal
:
tabData
.
iconLoadingPrincipal
|
|
null
userTypedValue
:
tabData
.
userTypedValue
|
|
"
"
userTypedClear
:
tabData
.
userTypedClear
|
|
0
}
)
;
if
(
"
attributes
"
in
tabData
)
{
TabAttributes
.
set
(
tab
tabData
.
attributes
)
;
}
if
(
isBrowserInserted
)
{
let
epoch
=
this
.
startNextEpoch
(
browser
)
;
TAB_STATE_FOR_BROWSER
.
set
(
browser
TAB_STATE_NEEDS_RESTORE
)
;
this
.
_sendRestoreHistory
(
browser
{
tabData
epoch
loadArguments
}
)
;
if
(
willRestoreImmediately
)
{
this
.
restoreTabContent
(
tab
options
)
;
}
else
if
(
!
forceOnDemand
)
{
TabRestoreQueue
.
add
(
tab
)
;
if
(
TabRestoreQueue
.
willRestoreSoon
(
tab
)
)
{
if
(
activeIndex
in
tabData
.
entries
)
{
let
url
=
tabData
.
entries
[
activeIndex
]
.
url
;
let
prepared
=
this
.
prepareConnectionToHost
(
tab
url
)
;
if
(
gDebuggingEnabled
)
{
tab
.
__test_connection_prepared
=
prepared
;
tab
.
__test_connection_url
=
url
;
}
}
}
this
.
restoreNextTab
(
)
;
}
}
else
{
let
url
=
"
about
:
blank
"
;
let
title
=
"
"
;
if
(
activeIndex
in
tabData
.
entries
)
{
url
=
tabData
.
entries
[
activeIndex
]
.
url
;
title
=
tabData
.
entries
[
activeIndex
]
.
title
|
|
url
;
}
TAB_LAZY_STATES
.
set
(
tab
{
url
title
userTypedValue
:
tabData
.
userTypedValue
|
|
"
"
userTypedClear
:
tabData
.
userTypedClear
|
|
0
}
)
;
}
if
(
tab
.
hasAttribute
(
"
customizemode
"
)
)
{
window
.
gCustomizeMode
.
setTab
(
tab
)
;
}
this
.
updateTabLabelAndIcon
(
tab
tabData
)
;
this
.
_setWindowStateReady
(
window
)
;
}
restoreTabContent
(
aTab
aOptions
=
{
}
)
{
let
loadArguments
=
aOptions
.
loadArguments
;
if
(
aTab
.
hasAttribute
(
"
customizemode
"
)
&
&
!
loadArguments
)
{
return
;
}
let
browser
=
aTab
.
linkedBrowser
;
let
window
=
aTab
.
ownerGlobal
;
let
tabbrowser
=
window
.
gBrowser
;
let
tabData
=
TabState
.
clone
(
aTab
TAB_CUSTOM_VALUES
.
get
(
aTab
)
)
;
let
activeIndex
=
tabData
.
index
-
1
;
let
activePageData
=
tabData
.
entries
[
activeIndex
]
|
|
null
;
let
uri
=
activePageData
?
activePageData
.
url
|
|
null
:
null
;
if
(
loadArguments
)
{
uri
=
loadArguments
.
uri
;
if
(
loadArguments
.
userContextId
)
{
browser
.
setAttribute
(
"
usercontextid
"
loadArguments
.
userContextId
)
;
}
}
this
.
markTabAsRestoring
(
aTab
)
;
let
newFrameloader
=
aOptions
.
newFrameloader
;
let
isRemotenessUpdate
;
if
(
aOptions
.
remoteType
!
=
=
undefined
)
{
isRemotenessUpdate
=
tabbrowser
.
updateBrowserRemoteness
(
browser
!
!
aOptions
.
remoteType
{
remoteType
:
aOptions
.
remoteType
newFrameloader
}
)
;
}
else
{
isRemotenessUpdate
=
tabbrowser
.
updateBrowserRemotenessByURL
(
browser
uri
{
newFrameloader
}
)
;
}
if
(
isRemotenessUpdate
)
{
let
epoch
=
this
.
startNextEpoch
(
browser
)
;
this
.
_sendRestoreHistory
(
browser
{
tabData
epoch
loadArguments
isRemotenessUpdate
}
)
;
}
if
(
uri
&
&
ViewSourceBrowser
.
isViewSource
(
uri
)
)
{
new
ViewSourceBrowser
(
browser
)
;
}
browser
.
messageManager
.
sendAsyncMessage
(
"
SessionStore
:
restoreTabContent
"
{
loadArguments
isRemotenessUpdate
reason
:
aOptions
.
restoreContentReason
|
|
RESTORE_TAB_CONTENT_REASON
.
SET_STATE
requestTime
:
Services
.
telemetry
.
msSystemNow
(
)
}
)
;
if
(
aTab
.
selected
&
&
!
window
.
isBlankPageURL
(
uri
)
)
{
browser
.
focus
(
)
;
}
}
markTabAsRestoring
(
aTab
)
{
let
browser
=
aTab
.
linkedBrowser
;
if
(
TAB_STATE_FOR_BROWSER
.
get
(
browser
)
!
=
TAB_STATE_NEEDS_RESTORE
)
{
throw
new
Error
(
"
Given
tab
is
not
pending
.
"
)
;
}
TabRestoreQueue
.
remove
(
aTab
)
;
this
.
_tabsRestoringCount
+
+
;
TAB_STATE_FOR_BROWSER
.
set
(
browser
TAB_STATE_RESTORING
)
;
aTab
.
removeAttribute
(
"
pending
"
)
;
}
restoreNextTab
:
function
ssi_restoreNextTab
(
)
{
if
(
RunState
.
isQuitting
)
return
;
if
(
this
.
_tabsRestoringCount
>
=
MAX_CONCURRENT_TAB_RESTORES
)
return
;
let
tab
=
TabRestoreQueue
.
shift
(
)
;
if
(
tab
)
{
this
.
restoreTabContent
(
tab
)
;
}
}
restoreWindowFeatures
:
function
ssi_restoreWindowFeatures
(
aWindow
aWinData
)
{
var
hidden
=
(
aWinData
.
hidden
)
?
aWinData
.
hidden
.
split
(
"
"
)
:
[
]
;
WINDOW_HIDEABLE_FEATURES
.
forEach
(
function
(
aItem
)
{
aWindow
[
aItem
]
.
visible
=
!
hidden
.
includes
(
aItem
)
;
}
)
;
if
(
aWinData
.
isPopup
)
{
this
.
_windows
[
aWindow
.
__SSi
]
.
isPopup
=
true
;
if
(
aWindow
.
gURLBar
)
{
aWindow
.
gURLBar
.
readOnly
=
true
;
}
}
else
{
delete
this
.
_windows
[
aWindow
.
__SSi
]
.
isPopup
;
if
(
aWindow
.
gURLBar
)
{
aWindow
.
gURLBar
.
readOnly
=
false
;
}
}
aWindow
.
setTimeout
(
(
)
=
>
{
this
.
restoreDimensions
(
aWindow
+
(
aWinData
.
width
|
|
0
)
+
(
aWinData
.
height
|
|
0
)
"
screenX
"
in
aWinData
?
+
aWinData
.
screenX
:
NaN
"
screenY
"
in
aWinData
?
+
aWinData
.
screenY
:
NaN
aWinData
.
sizemode
|
|
"
"
aWinData
.
sidebar
|
|
"
"
)
;
}
0
)
;
}
restoreDimensions
:
function
ssi_restoreDimensions
(
aWindow
aWidth
aHeight
aLeft
aTop
aSizeMode
aSidebar
)
{
var
win
=
aWindow
;
var
_this
=
this
;
function
win_
(
aName
)
{
return
_this
.
_getWindowDimension
(
win
aName
)
;
}
const
dwu
=
win
.
windowUtils
;
let
screen
=
gScreenManager
.
screenForRect
(
aLeft
aTop
aWidth
aHeight
)
;
if
(
screen
)
{
let
screenLeft
=
{
}
screenTop
=
{
}
screenWidth
=
{
}
screenHeight
=
{
}
;
screen
.
GetAvailRectDisplayPix
(
screenLeft
screenTop
screenWidth
screenHeight
)
;
let
screenLeftCss
=
screenLeft
.
value
;
let
screenTopCss
=
screenTop
.
value
;
screen
.
GetAvailRect
(
screenLeft
screenTop
screenWidth
screenHeight
)
;
let
cssToDevScale
=
screen
.
defaultCSSScaleFactor
;
let
screenRightCss
=
screenLeftCss
+
screenWidth
.
value
/
cssToDevScale
;
let
screenBottomCss
=
screenTopCss
+
screenHeight
.
value
/
cssToDevScale
;
if
(
aLeft
<
screenLeftCss
-
SCREEN_EDGE_SLOP
)
{
aLeft
=
screenLeftCss
;
}
let
right
=
aLeft
+
aWidth
;
if
(
right
>
screenRightCss
+
SCREEN_EDGE_SLOP
)
{
right
=
screenRightCss
;
if
(
aLeft
>
screenLeftCss
)
{
aLeft
=
Math
.
max
(
right
-
aWidth
screenLeftCss
)
;
}
}
aWidth
=
right
-
aLeft
;
if
(
aTop
<
screenTopCss
-
SCREEN_EDGE_SLOP
)
{
aTop
=
screenTopCss
;
}
let
bottom
=
aTop
+
aHeight
;
if
(
bottom
>
screenBottomCss
+
SCREEN_EDGE_SLOP
)
{
bottom
=
screenBottomCss
;
if
(
aTop
>
screenTopCss
)
{
aTop
=
Math
.
max
(
bottom
-
aHeight
screenTopCss
)
;
}
}
aHeight
=
bottom
-
aTop
;
}
dwu
.
suppressAnimation
(
true
)
;
try
{
if
(
!
isNaN
(
aLeft
)
&
&
!
isNaN
(
aTop
)
&
&
(
aLeft
!
=
win_
(
"
screenX
"
)
|
|
aTop
!
=
win_
(
"
screenY
"
)
)
)
{
aWindow
.
moveTo
(
aLeft
aTop
)
;
}
if
(
aWidth
&
&
aHeight
&
&
(
aWidth
!
=
win_
(
"
width
"
)
|
|
aHeight
!
=
win_
(
"
height
"
)
)
&
&
!
gResistFingerprintingEnabled
)
{
if
(
aSizeMode
!
=
"
maximized
"
|
|
win_
(
"
sizemode
"
)
!
=
"
maximized
"
)
{
aWindow
.
resizeTo
(
aWidth
aHeight
)
;
}
}
if
(
aSizeMode
&
&
win_
(
"
sizemode
"
)
!
=
aSizeMode
&
&
!
gResistFingerprintingEnabled
)
{
switch
(
aSizeMode
)
{
case
"
maximized
"
:
aWindow
.
maximize
(
)
;
break
;
case
"
minimized
"
:
aWindow
.
minimize
(
)
;
break
;
case
"
normal
"
:
aWindow
.
restore
(
)
;
break
;
}
}
let
sidebarBox
=
aWindow
.
document
.
getElementById
(
"
sidebar
-
box
"
)
;
if
(
aSidebar
&
&
(
sidebarBox
.
getAttribute
(
"
sidebarcommand
"
)
!
=
aSidebar
|
|
!
sidebarBox
.
getAttribute
(
"
checked
"
)
)
)
{
aWindow
.
SidebarUI
.
showInitially
(
aSidebar
)
;
}
if
(
this
.
windowToFocus
)
{
this
.
windowToFocus
.
focus
(
)
;
}
}
finally
{
dwu
.
suppressAnimation
(
false
)
;
}
}
saveStateDelayed
(
aWindow
=
null
)
{
if
(
aWindow
)
{
DirtyWindows
.
add
(
aWindow
)
;
}
SessionSaver
.
runDelayed
(
)
;
}
_removeClosedWindow
(
index
)
{
let
windows
=
this
.
_closedWindows
.
splice
(
index
1
)
;
this
.
_closedObjectsChanged
=
true
;
return
windows
;
}
_notifyOfClosedObjectsChange
(
)
{
if
(
!
this
.
_closedObjectsChanged
)
{
return
;
}
this
.
_closedObjectsChanged
=
false
;
setTimeout
(
(
)
=
>
{
Services
.
obs
.
notifyObservers
(
null
NOTIFY_CLOSED_OBJECTS_CHANGED
)
;
}
0
)
;
}
_updateSessionStartTime
:
function
ssi_updateSessionStartTime
(
state
)
{
if
(
state
.
session
&
&
state
.
session
.
startTime
)
{
this
.
_sessionStartTime
=
state
.
session
.
startTime
;
}
}
_browserWindows
:
{
*
[
Symbol
.
iterator
]
(
)
{
for
(
let
window
of
BrowserWindowTracker
.
orderedWindows
)
{
if
(
window
.
__SSi
&
&
!
window
.
closed
)
yield
window
;
}
}
}
_getTopWindow
:
function
ssi_getTopWindow
(
)
{
return
BrowserWindowTracker
.
getTopWindow
(
{
allowPopups
:
true
}
)
;
}
_handleClosedWindows
:
function
ssi_handleClosedWindows
(
)
{
let
promises
=
[
]
;
for
(
let
window
of
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
)
{
if
(
window
.
closed
)
{
promises
.
push
(
this
.
onClose
(
window
)
)
;
}
}
return
Promise
.
all
(
promises
)
;
}
_updateWindowRestoreState
(
window
state
)
{
if
(
"
zIndex
"
in
state
.
windows
[
0
]
)
{
WINDOW_RESTORE_ZINDICES
.
set
(
window
state
.
windows
[
0
]
.
zIndex
)
;
}
do
{
var
ID
=
"
window
"
+
Math
.
random
(
)
;
}
while
(
ID
in
this
.
_statesToRestore
)
;
WINDOW_RESTORE_IDS
.
set
(
window
ID
)
;
this
.
_statesToRestore
[
ID
]
=
state
;
}
_openWindowWithState
:
function
ssi_openWindowWithState
(
aState
)
{
var
argString
=
Cc
[
"
mozilla
.
org
/
supports
-
string
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsString
)
;
argString
.
data
=
"
"
;
let
features
=
"
chrome
dialog
=
no
suppressanimation
all
"
;
let
winState
=
aState
.
windows
[
0
]
;
WINDOW_ATTRIBUTES
.
forEach
(
function
(
aFeature
)
{
if
(
aFeature
in
winState
&
&
!
isNaN
(
winState
[
aFeature
]
)
)
features
+
=
"
"
+
aFeature
+
"
=
"
+
winState
[
aFeature
]
;
}
)
;
if
(
winState
.
isPrivate
)
{
features
+
=
"
private
"
;
}
var
window
=
Services
.
ww
.
openWindow
(
null
AppConstants
.
BROWSER_CHROME_URL
"
_blank
"
features
argString
)
;
this
.
_updateWindowRestoreState
(
window
aState
)
;
WINDOW_SHOWING_PROMISES
.
set
(
window
PromiseUtils
.
defer
(
)
)
;
return
window
;
}
_doResumeSession
:
function
ssi_doResumeSession
(
)
{
return
this
.
_prefBranch
.
getIntPref
(
"
startup
.
page
"
)
=
=
3
|
|
this
.
_prefBranch
.
getBoolPref
(
"
sessionstore
.
resume_session_once
"
)
;
}
_isCmdLineEmpty
:
function
ssi_isCmdLineEmpty
(
aWindow
aState
)
{
var
pinnedOnly
=
aState
.
windows
&
&
aState
.
windows
.
every
(
win
=
>
win
.
tabs
.
every
(
tab
=
>
tab
.
pinned
)
)
;
let
hasFirstArgument
=
aWindow
.
arguments
&
&
aWindow
.
arguments
[
0
]
;
if
(
!
pinnedOnly
)
{
let
defaultArgs
=
Cc
[
"
mozilla
.
org
/
browser
/
clh
;
1
"
]
.
getService
(
Ci
.
nsIBrowserHandler
)
.
defaultArgs
;
if
(
aWindow
.
arguments
&
&
aWindow
.
arguments
[
0
]
&
&
aWindow
.
arguments
[
0
]
=
=
defaultArgs
)
hasFirstArgument
=
false
;
}
return
!
hasFirstArgument
;
}
_getWindowDimension
:
function
ssi_getWindowDimension
(
aWindow
aAttribute
)
{
if
(
aAttribute
=
=
"
sizemode
"
)
{
switch
(
aWindow
.
windowState
)
{
case
aWindow
.
STATE_FULLSCREEN
:
case
aWindow
.
STATE_MAXIMIZED
:
return
"
maximized
"
;
case
aWindow
.
STATE_MINIMIZED
:
return
"
minimized
"
;
default
:
return
"
normal
"
;
}
}
if
(
aWindow
.
windowState
!
=
aWindow
.
STATE_NORMAL
)
{
let
docElem
=
aWindow
.
document
.
documentElement
;
let
attr
=
parseInt
(
docElem
.
getAttribute
(
aAttribute
)
10
)
;
if
(
attr
)
{
if
(
aAttribute
!
=
"
width
"
&
&
aAttribute
!
=
"
height
"
)
{
return
attr
;
}
let
xulWin
=
aWindow
.
docShell
.
treeOwner
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIXULWindow
)
;
let
diff
=
aAttribute
=
=
"
width
"
?
xulWin
.
outerToInnerWidthDifferenceInCSSPixels
:
xulWin
.
outerToInnerHeightDifferenceInCSSPixels
;
return
attr
+
diff
;
}
}
switch
(
aAttribute
)
{
case
"
width
"
:
return
aWindow
.
outerWidth
;
case
"
height
"
:
return
aWindow
.
outerHeight
;
default
:
return
aAttribute
in
aWindow
?
aWindow
[
aAttribute
]
:
"
"
;
}
}
_needsRestorePage
:
function
ssi_needsRestorePage
(
aState
aRecentCrashes
)
{
const
SIX_HOURS_IN_MS
=
6
*
60
*
60
*
1000
;
let
winData
=
aState
.
windows
|
|
null
;
if
(
!
winData
|
|
winData
.
length
=
=
0
)
return
false
;
if
(
this
.
_hasSingleTabWithURL
(
winData
"
about
:
sessionrestore
"
)
|
|
this
.
_hasSingleTabWithURL
(
winData
"
about
:
welcomeback
"
)
)
{
return
false
;
}
if
(
Services
.
appinfo
.
inSafeMode
)
return
true
;
let
max_resumed_crashes
=
this
.
_prefBranch
.
getIntPref
(
"
sessionstore
.
max_resumed_crashes
"
)
;
let
sessionAge
=
aState
.
session
&
&
aState
.
session
.
lastUpdate
&
&
(
Date
.
now
(
)
-
aState
.
session
.
lastUpdate
)
;
return
max_resumed_crashes
!
=
-
1
&
&
(
aRecentCrashes
>
max_resumed_crashes
|
|
sessionAge
&
&
sessionAge
>
=
SIX_HOURS_IN_MS
)
;
}
_hasSingleTabWithURL
(
aWinData
aURL
)
{
if
(
aWinData
&
&
aWinData
.
length
=
=
1
&
&
aWinData
[
0
]
.
tabs
&
&
aWinData
[
0
]
.
tabs
.
length
=
=
1
&
&
aWinData
[
0
]
.
tabs
[
0
]
.
entries
&
&
aWinData
[
0
]
.
tabs
[
0
]
.
entries
.
length
=
=
1
)
{
return
aURL
=
=
aWinData
[
0
]
.
tabs
[
0
]
.
entries
[
0
]
.
url
;
}
return
false
;
}
_shouldSaveTabState
:
function
ssi_shouldSaveTabState
(
aTabState
)
{
return
aTabState
.
entries
.
length
&
&
!
(
aTabState
.
entries
.
length
=
=
1
&
&
(
aTabState
.
entries
[
0
]
.
url
=
=
"
about
:
blank
"
|
|
aTabState
.
entries
[
0
]
.
url
=
=
"
about
:
newtab
"
|
|
aTabState
.
entries
[
0
]
.
url
=
=
"
about
:
printpreview
"
|
|
aTabState
.
entries
[
0
]
.
url
=
=
"
about
:
privatebrowsing
"
)
&
&
!
aTabState
.
userTypedValue
)
;
}
_shouldSaveTab
:
function
ssi_shouldSaveTab
(
aTabState
)
{
return
aTabState
.
userTypedValue
|
|
(
aTabState
.
attributes
&
&
aTabState
.
attributes
.
customizemode
=
=
"
true
"
)
|
|
(
aTabState
.
entries
.
length
&
&
!
(
aTabState
.
entries
[
0
]
.
url
=
=
"
about
:
printpreview
"
|
|
aTabState
.
entries
[
0
]
.
url
=
=
"
about
:
privatebrowsing
"
)
)
;
}
_prepDataForDeferredRestore
:
function
ssi_prepDataForDeferredRestore
(
state
)
{
state
=
Cu
.
cloneInto
(
state
{
}
)
;
let
defaultState
=
{
windows
:
[
]
selectedWindow
:
1
}
;
state
.
selectedWindow
=
state
.
selectedWindow
|
|
1
;
for
(
let
wIndex
=
0
;
wIndex
<
state
.
windows
.
length
;
)
{
let
window
=
state
.
windows
[
wIndex
]
;
window
.
selected
=
window
.
selected
|
|
1
;
let
pinnedWindowState
=
{
tabs
:
[
]
}
;
for
(
let
tIndex
=
0
;
tIndex
<
window
.
tabs
.
length
;
)
{
if
(
window
.
tabs
[
tIndex
]
.
pinned
)
{
if
(
tIndex
+
1
<
window
.
selected
)
window
.
selected
-
=
1
;
else
if
(
tIndex
+
1
=
=
window
.
selected
)
pinnedWindowState
.
selected
=
pinnedWindowState
.
tabs
.
length
+
1
;
pinnedWindowState
.
tabs
=
pinnedWindowState
.
tabs
.
concat
(
window
.
tabs
.
splice
(
tIndex
1
)
)
;
continue
;
}
tIndex
+
+
;
}
if
(
pinnedWindowState
.
tabs
.
length
)
{
WINDOW_ATTRIBUTES
.
forEach
(
function
(
attr
)
{
if
(
attr
in
window
)
{
pinnedWindowState
[
attr
]
=
window
[
attr
]
;
delete
window
[
attr
]
;
}
}
)
;
window
.
__lastSessionWindowID
=
pinnedWindowState
.
__lastSessionWindowID
=
"
"
+
Date
.
now
(
)
+
Math
.
random
(
)
;
defaultState
.
windows
.
push
(
pinnedWindowState
)
;
if
(
!
window
.
tabs
.
length
)
{
if
(
wIndex
+
1
<
=
state
.
selectedWindow
)
state
.
selectedWindow
-
=
1
;
else
if
(
wIndex
+
1
=
=
state
.
selectedWindow
)
defaultState
.
selectedIndex
=
defaultState
.
windows
.
length
+
1
;
state
.
windows
.
splice
(
wIndex
1
)
;
continue
;
}
}
wIndex
+
+
;
}
return
[
defaultState
state
]
;
}
_sendRestoreCompletedNotifications
:
function
ssi_sendRestoreCompletedNotifications
(
)
{
if
(
this
.
_restoreCount
>
1
)
{
this
.
_restoreCount
-
-
;
return
;
}
if
(
this
.
_restoreCount
=
=
-
1
)
return
;
if
(
!
this
.
_browserSetState
)
{
Services
.
obs
.
notifyObservers
(
null
NOTIFY_WINDOWS_RESTORED
)
;
this
.
_deferredAllWindowsRestored
.
resolve
(
)
;
}
else
{
Services
.
obs
.
notifyObservers
(
null
NOTIFY_BROWSER_STATE_RESTORED
)
;
}
this
.
_browserSetState
=
false
;
this
.
_restoreCount
=
-
1
;
}
_setWindowStateBusyValue
:
function
ssi_changeWindowStateBusyValue
(
aWindow
aValue
)
{
this
.
_windows
[
aWindow
.
__SSi
]
.
busy
=
aValue
;
if
(
!
this
.
_isWindowLoaded
(
aWindow
)
)
{
let
stateToRestore
=
this
.
_statesToRestore
[
WINDOW_RESTORE_IDS
.
get
(
aWindow
)
]
.
windows
[
0
]
;
stateToRestore
.
busy
=
aValue
;
}
}
_setWindowStateReady
:
function
ssi_setWindowStateReady
(
aWindow
)
{
let
newCount
=
(
this
.
_windowBusyStates
.
get
(
aWindow
)
|
|
0
)
-
1
;
if
(
newCount
<
0
)
{
throw
new
Error
(
"
Invalid
window
busy
state
(
less
than
zero
)
.
"
)
;
}
this
.
_windowBusyStates
.
set
(
aWindow
newCount
)
;
if
(
newCount
=
=
0
)
{
this
.
_setWindowStateBusyValue
(
aWindow
false
)
;
this
.
_sendWindowStateEvent
(
aWindow
"
Ready
"
)
;
}
}
_setWindowStateBusy
:
function
ssi_setWindowStateBusy
(
aWindow
)
{
let
newCount
=
(
this
.
_windowBusyStates
.
get
(
aWindow
)
|
|
0
)
+
1
;
this
.
_windowBusyStates
.
set
(
aWindow
newCount
)
;
if
(
newCount
=
=
1
)
{
this
.
_setWindowStateBusyValue
(
aWindow
true
)
;
this
.
_sendWindowStateEvent
(
aWindow
"
Busy
"
)
;
}
}
_sendWindowStateEvent
:
function
ssi_sendWindowStateEvent
(
aWindow
aType
)
{
let
event
=
aWindow
.
document
.
createEvent
(
"
Events
"
)
;
event
.
initEvent
(
"
SSWindowState
"
+
aType
true
false
)
;
aWindow
.
dispatchEvent
(
event
)
;
}
_sendWindowRestoredNotification
(
aWindow
)
{
let
event
=
aWindow
.
document
.
createEvent
(
"
Events
"
)
;
event
.
initEvent
(
"
SSWindowRestored
"
true
false
)
;
aWindow
.
dispatchEvent
(
event
)
;
}
_sendTabRestoredNotification
(
aTab
aIsRemotenessUpdate
)
{
let
event
=
aTab
.
ownerDocument
.
createEvent
(
"
CustomEvent
"
)
;
event
.
initCustomEvent
(
"
SSTabRestored
"
true
false
{
isRemotenessUpdate
:
aIsRemotenessUpdate
}
)
;
aTab
.
dispatchEvent
(
event
)
;
}
_isWindowLoaded
:
function
ssi_isWindowLoaded
(
aWindow
)
{
return
!
WINDOW_RESTORE_IDS
.
has
(
aWindow
)
;
}
_capClosedWindows
:
function
ssi_capClosedWindows
(
)
{
if
(
this
.
_closedWindows
.
length
<
=
this
.
_max_windows_undo
)
return
;
let
spliceTo
=
this
.
_max_windows_undo
;
if
(
AppConstants
.
platform
!
=
"
macosx
"
)
{
let
normalWindowIndex
=
0
;
while
(
normalWindowIndex
<
this
.
_closedWindows
.
length
&
&
!
!
this
.
_closedWindows
[
normalWindowIndex
]
.
isPopup
)
normalWindowIndex
+
+
;
if
(
normalWindowIndex
>
=
this
.
_max_windows_undo
)
spliceTo
=
normalWindowIndex
+
1
;
}
if
(
spliceTo
<
this
.
_closedWindows
.
length
)
{
this
.
_closedWindows
.
splice
(
spliceTo
this
.
_closedWindows
.
length
)
;
this
.
_closedObjectsChanged
=
true
;
}
}
_clearRestoringWindows
:
function
ssi_clearRestoringWindows
(
)
{
for
(
let
i
=
0
;
i
<
this
.
_closedWindows
.
length
;
i
+
+
)
{
delete
this
.
_closedWindows
[
i
]
.
_shouldRestore
;
}
}
_resetRestoringState
:
function
ssi_initRestoringState
(
)
{
TabRestoreQueue
.
reset
(
)
;
this
.
_tabsRestoringCount
=
0
;
}
_resetLocalTabRestoringState
(
aTab
)
{
let
browser
=
aTab
.
linkedBrowser
;
let
previousState
=
TAB_STATE_FOR_BROWSER
.
get
(
browser
)
;
if
(
!
previousState
)
{
Cu
.
reportError
(
"
Given
tab
is
not
restoring
.
"
)
;
return
;
}
TAB_STATE_FOR_BROWSER
.
delete
(
browser
)
;
aTab
.
removeAttribute
(
"
pending
"
)
;
if
(
previousState
=
=
TAB_STATE_RESTORING
)
{
if
(
this
.
_tabsRestoringCount
)
this
.
_tabsRestoringCount
-
-
;
}
else
if
(
previousState
=
=
TAB_STATE_NEEDS_RESTORE
)
{
TabRestoreQueue
.
remove
(
aTab
)
;
}
}
_resetTabRestoringState
(
tab
)
{
let
browser
=
tab
.
linkedBrowser
;
if
(
!
TAB_STATE_FOR_BROWSER
.
has
(
browser
)
)
{
Cu
.
reportError
(
"
Given
tab
is
not
restoring
.
"
)
;
return
;
}
browser
.
messageManager
.
sendAsyncMessage
(
"
SessionStore
:
resetRestore
"
{
}
)
;
this
.
_resetLocalTabRestoringState
(
tab
)
;
}
startNextEpoch
(
browser
)
{
let
next
=
this
.
getCurrentEpoch
(
browser
)
+
1
;
this
.
_browserEpochs
.
set
(
browser
.
permanentKey
next
)
;
return
next
;
}
setCurrentEpoch
(
aBrowser
aEpoch
)
{
this
.
_browserEpochs
.
set
(
aBrowser
.
permanentKey
aEpoch
)
;
return
aEpoch
;
}
getCurrentEpoch
(
browser
)
{
return
this
.
_browserEpochs
.
get
(
browser
.
permanentKey
)
|
|
0
;
}
isCurrentEpoch
(
browser
epoch
)
{
return
this
.
getCurrentEpoch
(
browser
)
=
=
epoch
;
}
resetEpoch
(
browser
)
{
this
.
_browserEpochs
.
delete
(
browser
.
permanentKey
)
;
}
looseTimer
(
delay
)
{
let
DELAY_BEAT
=
1000
;
let
timer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
let
beats
=
Math
.
ceil
(
delay
/
DELAY_BEAT
)
;
let
deferred
=
PromiseUtils
.
defer
(
)
;
timer
.
initWithCallback
(
function
(
)
{
if
(
beats
<
=
0
)
{
deferred
.
resolve
(
)
;
}
-
-
beats
;
}
DELAY_BEAT
Ci
.
nsITimer
.
TYPE_REPEATING_PRECISE_CAN_SKIP
)
;
deferred
.
promise
.
then
(
(
)
=
>
timer
.
cancel
(
)
(
)
=
>
timer
.
cancel
(
)
)
;
return
deferred
;
}
_sendRestoreHistory
(
browser
options
)
{
if
(
options
.
tabData
.
storage
)
{
for
(
let
origin
of
Object
.
getOwnPropertyNames
(
options
.
tabData
.
storage
)
)
{
try
{
let
{
frameLoader
}
=
browser
;
if
(
frameLoader
.
tabParent
)
{
let
attrs
=
browser
.
contentPrincipal
.
originAttributes
;
let
dataPrincipal
=
Services
.
scriptSecurityManager
.
createCodebasePrincipalFromOrigin
(
origin
)
;
let
principal
=
Services
.
scriptSecurityManager
.
createCodebasePrincipal
(
dataPrincipal
.
URI
attrs
)
;
frameLoader
.
tabParent
.
transmitPermissionsForPrincipal
(
principal
)
;
}
}
catch
(
e
)
{
console
.
error
(
e
)
;
}
}
}
browser
.
messageManager
.
sendAsyncMessage
(
"
SessionStore
:
restoreHistory
"
options
)
;
}
}
;
var
TabRestoreQueue
=
{
tabs
:
{
priority
:
[
]
visible
:
[
]
hidden
:
[
]
}
prefs
:
{
get
restoreOnDemand
(
)
{
let
updateValue
=
(
)
=
>
{
let
value
=
Services
.
prefs
.
getBoolPref
(
PREF
)
;
let
definition
=
{
value
configurable
:
true
}
;
Object
.
defineProperty
(
this
"
restoreOnDemand
"
definition
)
;
return
value
;
}
;
const
PREF
=
"
browser
.
sessionstore
.
restore_on_demand
"
;
Services
.
prefs
.
addObserver
(
PREF
updateValue
)
;
return
updateValue
(
)
;
}
get
restorePinnedTabsOnDemand
(
)
{
let
updateValue
=
(
)
=
>
{
let
value
=
Services
.
prefs
.
getBoolPref
(
PREF
)
;
let
definition
=
{
value
configurable
:
true
}
;
Object
.
defineProperty
(
this
"
restorePinnedTabsOnDemand
"
definition
)
;
return
value
;
}
;
const
PREF
=
"
browser
.
sessionstore
.
restore_pinned_tabs_on_demand
"
;
Services
.
prefs
.
addObserver
(
PREF
updateValue
)
;
return
updateValue
(
)
;
}
get
restoreHiddenTabs
(
)
{
let
updateValue
=
(
)
=
>
{
let
value
=
Services
.
prefs
.
getBoolPref
(
PREF
)
;
let
definition
=
{
value
configurable
:
true
}
;
Object
.
defineProperty
(
this
"
restoreHiddenTabs
"
definition
)
;
return
value
;
}
;
const
PREF
=
"
browser
.
sessionstore
.
restore_hidden_tabs
"
;
Services
.
prefs
.
addObserver
(
PREF
updateValue
)
;
return
updateValue
(
)
;
}
}
reset
(
)
{
this
.
tabs
=
{
priority
:
[
]
visible
:
[
]
hidden
:
[
]
}
;
}
add
(
tab
)
{
let
{
priority
hidden
visible
}
=
this
.
tabs
;
if
(
tab
.
pinned
)
{
priority
.
push
(
tab
)
;
}
else
if
(
tab
.
hidden
)
{
hidden
.
push
(
tab
)
;
}
else
{
visible
.
push
(
tab
)
;
}
}
remove
(
tab
)
{
let
{
priority
hidden
visible
}
=
this
.
tabs
;
let
set
=
priority
;
let
index
=
set
.
indexOf
(
tab
)
;
if
(
index
=
=
-
1
)
{
set
=
tab
.
hidden
?
hidden
:
visible
;
index
=
set
.
indexOf
(
tab
)
;
}
if
(
index
>
-
1
)
{
set
.
splice
(
index
1
)
;
}
}
shift
(
)
{
let
set
;
let
{
priority
hidden
visible
}
=
this
.
tabs
;
let
{
restoreOnDemand
restorePinnedTabsOnDemand
}
=
this
.
prefs
;
let
restorePinned
=
!
(
restoreOnDemand
&
&
restorePinnedTabsOnDemand
)
;
if
(
restorePinned
&
&
priority
.
length
)
{
set
=
priority
;
}
else
if
(
!
restoreOnDemand
)
{
if
(
visible
.
length
)
{
set
=
visible
;
}
else
if
(
this
.
prefs
.
restoreHiddenTabs
&
&
hidden
.
length
)
{
set
=
hidden
;
}
}
return
set
&
&
set
.
shift
(
)
;
}
hiddenToVisible
(
tab
)
{
let
{
hidden
visible
}
=
this
.
tabs
;
let
index
=
hidden
.
indexOf
(
tab
)
;
if
(
index
>
-
1
)
{
hidden
.
splice
(
index
1
)
;
visible
.
push
(
tab
)
;
}
}
visibleToHidden
(
tab
)
{
let
{
visible
hidden
}
=
this
.
tabs
;
let
index
=
visible
.
indexOf
(
tab
)
;
if
(
index
>
-
1
)
{
visible
.
splice
(
index
1
)
;
hidden
.
push
(
tab
)
;
}
}
willRestoreSoon
(
tab
)
{
let
{
priority
hidden
visible
}
=
this
.
tabs
;
let
{
restoreOnDemand
restorePinnedTabsOnDemand
restoreHiddenTabs
}
=
this
.
prefs
;
let
restorePinned
=
!
(
restoreOnDemand
&
&
restorePinnedTabsOnDemand
)
;
let
candidateSet
=
[
]
;
if
(
restorePinned
&
&
priority
.
length
)
candidateSet
.
push
(
.
.
.
priority
)
;
if
(
!
restoreOnDemand
)
{
if
(
visible
.
length
)
candidateSet
.
push
(
.
.
.
visible
)
;
if
(
restoreHiddenTabs
&
&
hidden
.
length
)
candidateSet
.
push
(
.
.
.
hidden
)
;
}
return
candidateSet
.
indexOf
(
tab
)
>
-
1
;
}
}
;
var
DyingWindowCache
=
{
_data
:
new
WeakMap
(
)
has
(
window
)
{
return
this
.
_data
.
has
(
window
)
;
}
get
(
window
)
{
return
this
.
_data
.
get
(
window
)
;
}
set
(
window
data
)
{
this
.
_data
.
set
(
window
data
)
;
}
remove
(
window
)
{
this
.
_data
.
delete
(
window
)
;
}
}
;
var
DirtyWindows
=
{
_data
:
new
WeakMap
(
)
has
(
window
)
{
return
this
.
_data
.
has
(
window
)
;
}
add
(
window
)
{
return
this
.
_data
.
set
(
window
true
)
;
}
remove
(
window
)
{
this
.
_data
.
delete
(
window
)
;
}
clear
(
window
)
{
this
.
_data
=
new
WeakMap
(
)
;
}
}
;
var
LastSession
=
{
_state
:
null
get
canRestore
(
)
{
return
!
!
this
.
_state
;
}
getState
(
)
{
return
this
.
_state
;
}
setState
(
state
)
{
this
.
_state
=
state
;
}
clear
(
silent
=
false
)
{
if
(
this
.
_state
)
{
this
.
_state
=
null
;
if
(
!
silent
)
Services
.
obs
.
notifyObservers
(
null
NOTIFY_LAST_SESSION_CLEARED
)
;
}
}
}
;
