"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
SessionStartup
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
SessionFile
"
"
resource
:
/
/
/
modules
/
sessionstore
/
SessionFile
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
StartupPerformance
"
"
resource
:
/
/
/
modules
/
sessionstore
/
StartupPerformance
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
CrashMonitor
"
"
resource
:
/
/
gre
/
modules
/
CrashMonitor
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PrivateBrowsingUtils
"
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
const
STATE_RUNNING_STR
=
"
running
"
;
const
TYPE_NO_SESSION
=
0
;
const
TYPE_RECOVER_SESSION
=
1
;
const
TYPE_RESUME_SESSION
=
2
;
const
TYPE_DEFER_SESSION
=
3
;
const
BROWSER_STARTUP_RESUME_SESSION
=
3
;
function
warning
(
aMsg
aException
)
{
let
consoleMsg
=
Cc
[
"
mozilla
.
org
/
scripterror
;
1
"
]
.
createInstance
(
Ci
.
nsIScriptError
)
;
consoleMsg
.
init
(
aMsg
aException
.
fileName
null
aException
.
lineNumber
0
Ci
.
nsIScriptError
.
warningFlag
"
component
javascript
"
)
;
Services
.
console
.
logMessage
(
consoleMsg
)
;
}
var
gOnceInitializedDeferred
=
(
function
(
)
{
let
deferred
=
{
}
;
deferred
.
promise
=
new
Promise
(
(
resolve
reject
)
=
>
{
deferred
.
resolve
=
resolve
;
deferred
.
reject
=
reject
;
}
)
;
return
deferred
;
}
)
(
)
;
var
SessionStartup
=
{
NO_SESSION
:
TYPE_NO_SESSION
RECOVER_SESSION
:
TYPE_RECOVER_SESSION
RESUME_SESSION
:
TYPE_RESUME_SESSION
DEFER_SESSION
:
TYPE_DEFER_SESSION
_initialState
:
null
_sessionType
:
TYPE_NO_SESSION
_initialized
:
false
_previousSessionCrashed
:
null
_resumeSessionEnabled
:
null
init
:
function
sss_init
(
)
{
Services
.
obs
.
notifyObservers
(
null
"
sessionstore
-
init
-
started
"
)
;
StartupPerformance
.
init
(
)
;
if
(
PrivateBrowsingUtils
.
permanentPrivateBrowsing
)
{
this
.
_initialized
=
true
;
gOnceInitializedDeferred
.
resolve
(
)
;
return
;
}
if
(
Services
.
prefs
.
getBoolPref
(
"
browser
.
sessionstore
.
resuming_after_os_restart
"
)
)
{
if
(
!
Services
.
appinfo
.
restartedByOS
)
{
Services
.
prefs
.
setBoolPref
(
"
browser
.
sessionstore
.
resume_session_once
"
false
)
;
}
Services
.
prefs
.
setBoolPref
(
"
browser
.
sessionstore
.
resuming_after_os_restart
"
false
)
;
}
this
.
_resumeSessionEnabled
=
Services
.
prefs
.
getBoolPref
(
"
browser
.
sessionstore
.
resume_session_once
"
)
|
|
Services
.
prefs
.
getIntPref
(
"
browser
.
startup
.
page
"
)
=
=
BROWSER_STARTUP_RESUME_SESSION
;
SessionFile
.
read
(
)
.
then
(
this
.
_onSessionFileRead
.
bind
(
this
)
console
.
error
)
;
}
_createSupportsString
:
function
ssfi_createSupportsString
(
aData
)
{
let
string
=
Cc
[
"
mozilla
.
org
/
supports
-
string
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsString
)
;
string
.
data
=
aData
;
return
string
;
}
_onSessionFileRead
(
{
source
parsed
noFilesFound
}
)
{
this
.
_initialized
=
true
;
let
supportsStateString
=
this
.
_createSupportsString
(
source
)
;
Services
.
obs
.
notifyObservers
(
supportsStateString
"
sessionstore
-
state
-
read
"
)
;
let
stateString
=
supportsStateString
.
data
;
if
(
stateString
!
=
source
)
{
try
{
this
.
_initialState
=
JSON
.
parse
(
stateString
)
;
}
catch
(
ex
)
{
warning
(
"
Observer
rewrote
the
state
to
something
that
won
'
t
parse
"
ex
)
;
}
}
else
{
this
.
_initialState
=
parsed
;
}
if
(
this
.
_initialState
=
=
null
)
{
this
.
_sessionType
=
this
.
NO_SESSION
;
Services
.
obs
.
notifyObservers
(
null
"
sessionstore
-
state
-
finalized
"
)
;
gOnceInitializedDeferred
.
resolve
(
)
;
return
;
}
let
initialState
=
this
.
_initialState
;
Services
.
tm
.
idleDispatchToMainThread
(
(
)
=
>
{
let
pinnedTabCount
=
initialState
.
windows
.
reduce
(
(
winAcc
win
)
=
>
{
return
winAcc
+
win
.
tabs
.
reduce
(
(
tabAcc
tab
)
=
>
{
return
tabAcc
+
(
tab
.
pinned
?
1
:
0
)
;
}
0
)
;
}
0
)
;
Services
.
telemetry
.
scalarSet
(
"
browser
.
engagement
.
restored_pinned_tabs_count
"
pinnedTabCount
)
;
}
60000
)
;
if
(
!
this
.
_resumeSessionEnabled
&
&
this
.
_initialState
)
{
delete
this
.
_initialState
.
lastSessionState
;
}
let
resumeFromCrash
=
Services
.
prefs
.
getBoolPref
(
"
browser
.
sessionstore
.
resume_from_crash
"
)
;
CrashMonitor
.
previousCheckpoints
.
then
(
checkpoints
=
>
{
if
(
checkpoints
)
{
this
.
_previousSessionCrashed
=
!
checkpoints
[
"
sessionstore
-
final
-
state
-
write
-
complete
"
]
;
}
else
if
(
noFilesFound
)
{
this
.
_previousSessionCrashed
=
false
;
}
else
{
let
stateFlagPresent
=
(
this
.
_initialState
.
session
&
&
this
.
_initialState
.
session
.
state
)
;
this
.
_previousSessionCrashed
=
!
stateFlagPresent
|
|
(
this
.
_initialState
.
session
.
state
=
=
STATE_RUNNING_STR
)
;
}
Services
.
telemetry
.
getHistogramById
(
"
SHUTDOWN_OK
"
)
.
add
(
!
this
.
_previousSessionCrashed
)
;
if
(
this
.
_previousSessionCrashed
&
&
resumeFromCrash
)
this
.
_sessionType
=
this
.
RECOVER_SESSION
;
else
if
(
!
this
.
_previousSessionCrashed
&
&
this
.
_resumeSessionEnabled
)
this
.
_sessionType
=
this
.
RESUME_SESSION
;
else
if
(
this
.
_initialState
)
this
.
_sessionType
=
this
.
DEFER_SESSION
;
else
this
.
_initialState
=
null
;
Services
.
obs
.
addObserver
(
this
"
sessionstore
-
windows
-
restored
"
true
)
;
if
(
this
.
_sessionType
!
=
this
.
NO_SESSION
)
Services
.
obs
.
addObserver
(
this
"
browser
:
purge
-
session
-
history
"
true
)
;
Services
.
obs
.
notifyObservers
(
null
"
sessionstore
-
state
-
finalized
"
)
;
gOnceInitializedDeferred
.
resolve
(
)
;
}
)
;
}
observe
:
function
sss_observe
(
aSubject
aTopic
aData
)
{
switch
(
aTopic
)
{
case
"
sessionstore
-
windows
-
restored
"
:
Services
.
obs
.
removeObserver
(
this
"
sessionstore
-
windows
-
restored
"
)
;
this
.
_initialState
=
null
;
this
.
_didRestore
=
true
;
break
;
case
"
browser
:
purge
-
session
-
history
"
:
Services
.
obs
.
removeObserver
(
this
"
browser
:
purge
-
session
-
history
"
)
;
this
.
_sessionType
=
this
.
NO_SESSION
;
break
;
}
}
get
onceInitialized
(
)
{
return
gOnceInitializedDeferred
.
promise
;
}
get
state
(
)
{
return
this
.
_initialState
;
}
doRestore
:
function
sss_doRestore
(
)
{
return
this
.
_willRestore
(
)
;
}
isAutomaticRestoreEnabled
(
)
{
if
(
PrivateBrowsingUtils
.
permanentPrivateBrowsing
)
{
return
false
;
}
return
Services
.
prefs
.
getBoolPref
(
"
browser
.
sessionstore
.
resume_session_once
"
)
|
|
Services
.
prefs
.
getIntPref
(
"
browser
.
startup
.
page
"
)
=
=
BROWSER_STARTUP_RESUME_SESSION
;
}
_willRestore
(
)
{
return
this
.
_sessionType
=
=
this
.
RECOVER_SESSION
|
|
this
.
_sessionType
=
=
this
.
RESUME_SESSION
;
}
get
willOverrideHomepage
(
)
{
if
(
!
this
.
_initialState
&
&
!
this
.
_resumeSessionEnabled
)
{
return
false
;
}
if
(
this
.
_didRestore
)
{
return
false
;
}
return
new
Promise
(
resolve
=
>
{
this
.
onceInitialized
.
then
(
(
)
=
>
{
resolve
(
this
.
_willRestore
(
)
&
&
this
.
_initialState
&
&
this
.
_initialState
.
windows
&
&
this
.
_initialState
.
windows
.
some
(
w
=
>
w
.
tabs
.
some
(
t
=
>
!
t
.
pinned
)
)
)
;
}
)
;
}
)
;
}
get
sessionType
(
)
{
return
this
.
_sessionType
;
}
get
previousSessionCrashed
(
)
{
return
this
.
_previousSessionCrashed
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIObserver
Ci
.
nsISupportsWeakReference
]
)
}
;
