"
use
strict
"
;
importScripts
(
"
resource
:
/
/
gre
/
modules
/
workers
/
require
.
js
"
)
;
var
PromiseWorker
=
require
(
"
resource
:
/
/
gre
/
modules
/
workers
/
PromiseWorker
.
js
"
)
;
var
Encoder
=
new
TextEncoder
(
)
;
var
Decoder
=
new
TextDecoder
(
)
;
var
worker
=
new
PromiseWorker
.
AbstractWorker
(
)
;
worker
.
dispatch
=
function
(
method
args
=
[
]
)
{
return
Agent
[
method
]
(
.
.
.
args
)
;
}
;
worker
.
postMessage
=
function
(
result
.
.
.
transfers
)
{
self
.
postMessage
(
result
.
.
.
transfers
)
;
}
;
worker
.
close
=
function
(
)
{
self
.
close
(
)
;
}
;
self
.
addEventListener
(
"
message
"
msg
=
>
worker
.
handleMessage
(
msg
)
)
;
const
STATE_CLEAN
=
"
clean
"
;
const
STATE_RECOVERY
=
"
recovery
"
;
const
STATE_RECOVERY_BACKUP
=
"
recoveryBackup
"
;
const
STATE_UPGRADE_BACKUP
=
"
upgradeBackup
"
;
const
STATE_EMPTY
=
"
empty
"
;
var
Agent
=
{
Paths
:
null
state
:
null
useOldExtension
:
false
maxUpgradeBackups
:
null
init
(
origin
useOldExtension
paths
prefs
=
{
}
)
{
if
(
!
(
origin
in
paths
|
|
origin
=
=
STATE_EMPTY
)
)
{
throw
new
TypeError
(
"
Invalid
origin
:
"
+
origin
)
;
}
for
(
let
pref
of
[
"
maxUpgradeBackups
"
"
maxSerializeBack
"
"
maxSerializeForward
"
]
)
{
if
(
!
prefs
.
hasOwnProperty
(
pref
)
)
{
throw
new
TypeError
(
Missing
preference
value
for
{
pref
}
)
;
}
}
this
.
useOldExtension
=
useOldExtension
;
this
.
state
=
origin
;
this
.
Paths
=
paths
;
this
.
maxUpgradeBackups
=
prefs
.
maxUpgradeBackups
;
this
.
maxSerializeBack
=
prefs
.
maxSerializeBack
;
this
.
maxSerializeForward
=
prefs
.
maxSerializeForward
;
this
.
upgradeBackupNeeded
=
paths
.
nextUpgradeBackup
!
=
paths
.
upgradeBackup
;
return
{
result
:
true
}
;
}
async
write
(
state
options
=
{
}
)
{
let
exn
;
let
telemetry
=
{
}
;
if
(
options
.
isFinalWrite
)
{
for
(
let
window
of
state
.
windows
)
{
for
(
let
tab
of
window
.
tabs
)
{
let
lower
=
0
;
let
upper
=
tab
.
entries
.
length
;
if
(
this
.
maxSerializeBack
>
-
1
)
{
lower
=
Math
.
max
(
lower
tab
.
index
-
this
.
maxSerializeBack
-
1
)
;
}
if
(
this
.
maxSerializeForward
>
-
1
)
{
upper
=
Math
.
min
(
upper
tab
.
index
+
this
.
maxSerializeForward
)
;
}
tab
.
entries
=
tab
.
entries
.
slice
(
lower
upper
)
;
tab
.
index
-
=
lower
;
}
}
}
let
stateString
=
JSON
.
stringify
(
state
)
;
let
data
=
Encoder
.
encode
(
stateString
)
;
try
{
if
(
this
.
state
=
=
STATE_CLEAN
|
|
this
.
state
=
=
STATE_EMPTY
)
{
await
IOUtils
.
makeDirectory
(
this
.
Paths
.
backups
)
;
}
if
(
this
.
state
=
=
STATE_CLEAN
)
{
if
(
!
this
.
useOldExtension
)
{
await
IOUtils
.
move
(
this
.
Paths
.
clean
this
.
Paths
.
cleanBackup
)
;
}
else
{
let
oldCleanPath
=
this
.
Paths
.
clean
.
replace
(
"
jsonlz4
"
"
js
"
)
;
let
d
=
await
IOUtils
.
read
(
oldCleanPath
)
;
await
IOUtils
.
write
(
this
.
Paths
.
cleanBackup
d
{
compress
:
true
}
)
;
}
}
let
startWriteMs
=
Date
.
now
(
)
;
let
fileStat
;
if
(
options
.
isFinalWrite
)
{
await
IOUtils
.
write
(
this
.
Paths
.
clean
data
{
tmpPath
:
this
.
Paths
.
clean
+
"
.
tmp
"
compress
:
true
}
)
;
fileStat
=
await
IOUtils
.
stat
(
this
.
Paths
.
clean
)
;
}
else
if
(
this
.
state
=
=
STATE_RECOVERY
)
{
await
IOUtils
.
write
(
this
.
Paths
.
recovery
data
{
tmpPath
:
this
.
Paths
.
recovery
+
"
.
tmp
"
backupFile
:
this
.
Paths
.
recoveryBackup
compress
:
true
}
)
;
fileStat
=
await
IOUtils
.
stat
(
this
.
Paths
.
recovery
)
;
}
else
{
await
IOUtils
.
write
(
this
.
Paths
.
recovery
data
{
tmpPath
:
this
.
Paths
.
recovery
+
"
.
tmp
"
compress
:
true
}
)
;
fileStat
=
await
IOUtils
.
stat
(
this
.
Paths
.
recovery
)
;
}
telemetry
.
FX_SESSION_RESTORE_WRITE_FILE_MS
=
Date
.
now
(
)
-
startWriteMs
;
telemetry
.
FX_SESSION_RESTORE_FILE_SIZE_BYTES
=
fileStat
.
size
;
}
catch
(
ex
)
{
exn
=
exn
|
|
ex
;
}
let
upgradeBackupComplete
=
false
;
if
(
this
.
upgradeBackupNeeded
&
&
(
this
.
state
=
=
STATE_CLEAN
|
|
this
.
state
=
=
STATE_UPGRADE_BACKUP
)
)
{
try
{
let
path
=
this
.
state
=
=
STATE_CLEAN
?
this
.
Paths
.
cleanBackup
:
this
.
Paths
.
upgradeBackup
;
await
IOUtils
.
copy
(
path
this
.
Paths
.
nextUpgradeBackup
)
;
this
.
upgradeBackupNeeded
=
false
;
upgradeBackupComplete
=
true
;
}
catch
(
ex
)
{
exn
=
exn
|
|
ex
;
}
let
backups
=
[
]
;
let
upgradeBackupPrefix
=
this
.
Paths
.
upgradeBackupPrefix
;
try
{
let
children
=
await
IOUtils
.
getChildren
(
this
.
Paths
.
backups
)
;
backups
=
children
.
filter
(
path
=
>
path
.
startsWith
(
upgradeBackupPrefix
)
)
;
}
catch
(
ex
)
{
exn
=
exn
|
|
ex
;
}
if
(
backups
.
length
>
this
.
maxUpgradeBackups
)
{
backups
.
sort
(
)
;
for
(
let
i
=
0
;
i
<
backups
.
length
-
this
.
maxUpgradeBackups
;
i
+
+
)
{
try
{
await
IOUtils
.
remove
(
backups
[
i
]
)
;
}
catch
(
ex
)
{
exn
=
exn
|
|
ex
;
}
}
}
}
if
(
options
.
performShutdownCleanup
&
&
!
exn
)
{
await
IOUtils
.
remove
(
this
.
Paths
.
recoveryBackup
)
;
await
IOUtils
.
remove
(
this
.
Paths
.
recovery
)
;
}
this
.
state
=
STATE_RECOVERY
;
if
(
exn
)
{
throw
exn
;
}
return
{
result
:
{
upgradeBackup
:
upgradeBackupComplete
}
telemetry
}
;
}
async
wipe
(
)
{
let
exn
=
null
;
try
{
await
IOUtils
.
remove
(
this
.
Paths
.
clean
)
;
await
IOUtils
.
remove
(
this
.
Paths
.
oldClean
)
;
}
catch
(
ex
)
{
exn
=
exn
|
|
ex
;
}
try
{
await
this
.
_wipeFromDir
(
this
.
Paths
.
backups
null
)
;
}
catch
(
ex
)
{
exn
=
exn
|
|
ex
;
}
try
{
await
IOUtils
.
remove
(
this
.
Paths
.
backups
)
;
}
catch
(
ex
)
{
exn
=
exn
|
|
ex
;
}
try
{
await
this
.
_wipeFromDir
(
this
.
Paths
.
profileDir
"
sessionstore
.
bak
"
)
;
}
catch
(
ex
)
{
exn
=
exn
|
|
ex
;
}
this
.
state
=
STATE_EMPTY
;
if
(
exn
)
{
throw
exn
;
}
return
{
result
:
true
}
;
}
async
_wipeFromDir
(
path
prefix
)
{
if
(
typeof
prefix
=
=
"
undefined
"
|
|
prefix
=
=
"
"
)
{
throw
new
TypeError
(
)
;
}
let
exn
=
null
;
try
{
let
children
=
await
IOUtils
.
getChildren
(
path
)
;
for
(
const
entry
of
children
)
{
if
(
!
prefix
|
|
PathUtils
.
filename
(
entry
)
.
startsWith
(
prefix
)
)
{
try
{
let
stat
=
await
IOUtils
.
stat
(
entry
)
;
if
(
stat
.
type
=
=
"
directory
"
)
{
continue
;
}
await
IOUtils
.
remove
(
entry
)
;
}
catch
(
ex
)
{
exn
=
exn
|
|
ex
;
}
}
}
}
catch
(
ex
)
{
if
(
ex
.
name
=
=
"
NotFoundError
"
)
{
return
;
}
throw
ex
;
}
if
(
exn
)
{
throw
exn
;
}
}
}
;
function
getByteLength
(
str
)
{
return
Encoder
.
encode
(
JSON
.
stringify
(
str
)
)
.
byteLength
;
}
