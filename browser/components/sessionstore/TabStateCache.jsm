"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
TabStateCache
"
]
;
var
TabStateCache
=
Object
.
freeze
(
{
get
(
browserOrTab
)
{
return
TabStateCacheInternal
.
get
(
browserOrTab
)
;
}
update
(
browserOrTab
newData
)
{
TabStateCacheInternal
.
update
(
browserOrTab
newData
)
;
}
}
)
;
var
TabStateCacheInternal
=
{
_data
:
new
WeakMap
(
)
get
(
browserOrTab
)
{
return
this
.
_data
.
get
(
browserOrTab
.
permanentKey
)
;
}
updatePartialStorageChange
(
data
change
)
{
if
(
!
data
.
storage
)
{
data
.
storage
=
{
}
;
}
let
storage
=
data
.
storage
;
for
(
let
domain
of
Object
.
keys
(
change
)
)
{
if
(
!
change
[
domain
]
)
{
delete
storage
[
domain
]
;
}
else
{
for
(
let
key
of
Object
.
keys
(
change
[
domain
]
)
)
{
let
value
=
change
[
domain
]
[
key
]
;
if
(
value
=
=
=
null
)
{
if
(
storage
[
domain
]
&
&
storage
[
domain
]
[
key
]
)
{
delete
storage
[
domain
]
[
key
]
;
}
}
else
{
if
(
!
storage
[
domain
]
)
{
storage
[
domain
]
=
{
}
;
}
storage
[
domain
]
[
key
]
=
value
;
}
}
}
}
}
updatePartialHistoryChange
(
data
change
)
{
const
kLastIndex
=
Number
.
MAX_SAFE_INTEGER
-
1
;
if
(
!
data
.
history
)
{
data
.
history
=
{
entries
:
[
]
}
;
}
let
history
=
data
.
history
;
let
toIdx
=
history
.
entries
.
length
;
if
(
"
toIdx
"
in
change
)
{
toIdx
=
Math
.
min
(
toIdx
change
.
toIdx
+
1
)
;
}
for
(
let
key
of
Object
.
keys
(
change
)
)
{
if
(
key
=
=
"
entries
"
)
{
if
(
change
.
fromIdx
!
=
kLastIndex
)
{
let
start
=
change
.
fromIdx
+
1
;
history
.
entries
.
splice
.
apply
(
history
.
entries
[
start
toIdx
-
start
]
.
concat
(
change
.
entries
)
)
;
}
}
else
if
(
key
!
=
"
fromIdx
"
&
&
key
!
=
"
toIdx
"
)
{
history
[
key
]
=
change
[
key
]
;
}
}
}
update
(
browserOrTab
newData
)
{
let
data
=
this
.
_data
.
get
(
browserOrTab
.
permanentKey
)
|
|
{
}
;
for
(
let
key
of
Object
.
keys
(
newData
)
)
{
if
(
key
=
=
"
storagechange
"
)
{
this
.
updatePartialStorageChange
(
data
newData
.
storagechange
)
;
continue
;
}
if
(
key
=
=
"
historychange
"
)
{
this
.
updatePartialHistoryChange
(
data
newData
.
historychange
)
;
continue
;
}
let
value
=
newData
[
key
]
;
if
(
value
=
=
=
null
)
{
delete
data
[
key
]
;
}
else
{
data
[
key
]
=
value
;
}
}
this
.
_data
.
set
(
browserOrTab
.
permanentKey
data
)
;
}
}
;
