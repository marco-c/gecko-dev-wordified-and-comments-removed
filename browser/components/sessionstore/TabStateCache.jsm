"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
TabStateCache
"
]
;
var
TabStateCache
=
Object
.
freeze
(
{
get
(
browserOrTab
)
{
return
TabStateCacheInternal
.
get
(
browserOrTab
)
;
}
update
(
browserOrTab
newData
)
{
TabStateCacheInternal
.
update
(
browserOrTab
newData
)
;
}
}
)
;
var
TabStateCacheInternal
=
{
_data
:
new
WeakMap
(
)
get
(
browserOrTab
)
{
return
this
.
_data
.
get
(
browserOrTab
.
permanentKey
)
;
}
updatePartialStorageChange
(
data
change
)
{
if
(
!
data
.
storage
)
{
data
.
storage
=
{
}
;
}
let
storage
=
data
.
storage
;
for
(
let
domain
of
Object
.
keys
(
change
)
)
{
if
(
!
change
[
domain
]
)
{
delete
storage
[
domain
]
;
}
else
{
for
(
let
key
of
Object
.
keys
(
change
[
domain
]
)
)
{
let
value
=
change
[
domain
]
[
key
]
;
if
(
value
=
=
=
null
)
{
if
(
storage
[
domain
]
&
&
storage
[
domain
]
[
key
]
)
{
delete
storage
[
domain
]
[
key
]
;
}
}
else
{
if
(
!
storage
[
domain
]
)
{
storage
[
domain
]
=
{
}
;
}
storage
[
domain
]
[
key
]
=
value
;
}
}
}
}
}
updatePartialHistoryChange
(
data
change
)
{
const
kLastIndex
=
Number
.
MAX_SAFE_INTEGER
-
1
;
if
(
!
data
.
history
)
{
data
.
history
=
{
entries
:
[
]
}
;
}
let
history
=
data
.
history
;
let
toIdx
=
history
.
entries
.
length
;
if
(
"
toIdx
"
in
change
)
{
toIdx
=
Math
.
min
(
toIdx
change
.
toIdx
+
1
)
;
}
for
(
let
key
of
Object
.
keys
(
change
)
)
{
if
(
key
=
=
"
entries
"
)
{
if
(
change
.
fromIdx
!
=
kLastIndex
)
{
let
start
=
change
.
fromIdx
+
1
;
history
.
entries
.
splice
.
apply
(
history
.
entries
[
start
toIdx
-
start
]
.
concat
(
change
.
entries
)
)
;
}
}
else
if
(
key
!
=
"
fromIdx
"
&
&
key
!
=
"
toIdx
"
)
{
history
[
key
]
=
change
[
key
]
;
}
}
}
updatePartialWindowStateChange
(
data
path
includeChildren
change
)
{
if
(
!
path
.
length
)
{
for
(
let
key
of
Object
.
keys
(
change
)
)
{
let
children
=
includeChildren
?
data
[
key
]
?
.
children
:
null
;
if
(
!
Object
.
keys
(
change
[
key
]
)
.
length
)
{
data
[
key
]
=
null
;
}
else
{
data
[
key
]
=
change
[
key
]
;
}
if
(
children
)
{
data
[
key
]
=
{
.
.
.
data
[
key
]
children
}
;
}
}
return
data
;
}
let
index
=
path
.
pop
(
)
;
let
scroll
=
data
?
.
scroll
?
.
children
?
.
[
index
]
;
let
formdata
=
data
?
.
formdata
?
.
children
?
.
[
index
]
;
change
=
this
.
updatePartialWindowStateChange
(
{
scroll
formdata
}
path
includeChildren
change
)
;
for
(
let
key
of
Object
.
keys
(
change
)
)
{
let
value
=
change
[
key
]
;
let
children
=
data
[
key
]
?
.
children
;
if
(
children
)
{
if
(
value
)
{
children
[
index
]
=
value
;
}
else
{
delete
children
[
index
]
;
}
if
(
!
children
.
some
(
e
=
>
e
)
)
{
data
[
key
]
=
null
;
}
}
else
if
(
value
)
{
children
=
new
Array
(
index
+
1
)
;
children
[
index
]
=
value
;
data
[
key
]
=
{
.
.
.
data
[
key
]
children
}
;
}
}
return
data
;
}
update
(
browserOrTab
newData
)
{
let
data
=
this
.
_data
.
get
(
browserOrTab
.
permanentKey
)
|
|
{
}
;
for
(
let
key
of
Object
.
keys
(
newData
)
)
{
if
(
key
=
=
"
storagechange
"
)
{
this
.
updatePartialStorageChange
(
data
newData
.
storagechange
)
;
continue
;
}
if
(
key
=
=
"
historychange
"
)
{
this
.
updatePartialHistoryChange
(
data
newData
.
historychange
)
;
continue
;
}
if
(
key
=
=
"
windowstatechange
"
)
{
let
{
path
hasChildren
.
.
.
change
}
=
newData
.
windowstatechange
;
this
.
updatePartialWindowStateChange
(
data
path
hasChildren
change
)
;
for
(
key
of
Object
.
keys
(
change
)
)
{
let
value
=
data
[
key
]
;
if
(
value
=
=
=
null
)
{
delete
data
[
key
]
;
}
else
{
data
[
key
]
=
value
;
}
}
continue
;
}
let
value
=
newData
[
key
]
;
if
(
value
=
=
=
null
)
{
delete
data
[
key
]
;
}
else
{
data
[
key
]
=
value
;
}
}
this
.
_data
.
set
(
browserOrTab
.
permanentKey
data
)
;
}
}
;
