ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
PromiseTestUtils
.
jsm
"
this
)
;
PromiseTestUtils
.
whitelistRejectionsGlobally
(
/
getTopWindow
/
)
;
const
TEST_URLS
=
[
"
about
:
mozilla
"
"
about
:
buildconfig
"
]
;
const
NOTIFICATIONS_EXPECTED
=
6
;
const
POPUP_FEATURES
=
"
toolbar
=
no
resizable
=
no
status
=
no
"
;
const
CHROME_FEATURES
=
"
chrome
all
dialog
=
no
"
;
const
IS_MAC
=
navigator
.
platform
.
match
(
/
Mac
/
)
;
function
getBrowserWindowsCount
(
)
{
let
open
=
0
;
let
e
=
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
;
while
(
e
.
hasMoreElements
(
)
)
{
if
(
!
e
.
getNext
(
)
.
closed
)
+
+
open
;
}
let
winstates
=
JSON
.
parse
(
ss
.
getBrowserState
(
)
)
.
windows
.
length
;
return
{
open
winstates
}
;
}
add_task
(
async
function
setup
(
)
{
let
{
open
winstates
}
=
getBrowserWindowsCount
(
)
;
is
(
open
1
"
Should
only
be
one
open
window
"
)
;
is
(
winstates
1
"
Should
only
be
one
window
state
in
SessionStore
"
)
;
requestLongerTimeout
(
3
)
;
let
oldWinType
=
document
.
documentElement
.
getAttribute
(
"
windowtype
"
)
;
document
.
documentElement
.
setAttribute
(
"
windowtype
"
"
navigator
:
testrunner
"
)
;
registerCleanupFunction
(
(
)
=
>
{
document
.
documentElement
.
setAttribute
(
"
windowtype
"
oldWinType
)
;
}
)
;
}
)
;
let
setupTest
=
async
function
(
options
testFunction
)
{
await
pushPrefs
(
[
"
browser
.
startup
.
page
"
3
]
[
"
browser
.
tabs
.
warnOnClose
"
false
]
)
;
let
observing
=
{
"
browser
-
lastwindow
-
close
-
requested
"
:
0
"
browser
-
lastwindow
-
close
-
granted
"
:
0
}
;
let
hitCount
=
0
;
function
observer
(
aCancel
aTopic
aData
)
{
observing
[
aTopic
]
+
+
;
if
(
options
.
denyFirst
&
&
+
+
hitCount
=
=
1
)
{
aCancel
.
QueryInterface
(
Ci
.
nsISupportsPRBool
)
.
data
=
true
;
}
}
for
(
let
o
in
observing
)
{
Services
.
obs
.
addObserver
(
observer
o
)
;
}
let
private
=
options
.
private
|
|
false
;
let
newWin
=
await
promiseNewWindowLoaded
(
{
private
}
)
;
await
injectTestTabs
(
newWin
)
;
await
testFunction
(
newWin
observing
)
;
let
count
=
getBrowserWindowsCount
(
)
;
is
(
count
.
open
0
"
Got
right
number
of
open
windows
"
)
;
is
(
count
.
winstates
1
"
Got
right
number
of
stored
window
states
"
)
;
for
(
let
o
in
observing
)
{
Services
.
obs
.
removeObserver
(
observer
o
)
;
}
await
popPrefs
(
)
;
}
;
function
injectTestTabs
(
win
)
{
let
promises
=
TEST_URLS
.
map
(
url
=
>
win
.
gBrowser
.
addTab
(
url
)
)
.
map
(
tab
=
>
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
)
)
;
return
Promise
.
all
(
promises
)
;
}
function
closeWindowForRestoration
(
win
)
{
return
new
Promise
(
(
resolve
)
=
>
{
let
closePromise
=
BrowserTestUtils
.
windowClosed
(
win
)
;
win
.
BrowserTryToCloseWindow
(
)
;
if
(
!
win
.
closed
)
{
resolve
(
false
)
;
return
;
}
closePromise
.
then
(
(
)
=
>
{
resolve
(
true
)
;
}
)
;
}
)
;
}
add_task
(
async
function
test_open_close_normal
(
)
{
if
(
IS_MAC
)
{
return
;
}
await
setupTest
(
{
denyFirst
:
true
}
async
function
(
newWin
obs
)
{
let
closed
=
await
closeWindowForRestoration
(
newWin
)
;
ok
(
!
closed
"
First
close
request
should
have
been
denied
"
)
;
closed
=
await
closeWindowForRestoration
(
newWin
)
;
ok
(
closed
"
Second
close
request
should
be
accepted
"
)
;
newWin
=
await
promiseNewWindowLoaded
(
)
;
is
(
newWin
.
gBrowser
.
browsers
.
length
TEST_URLS
.
length
+
2
"
Restored
window
in
-
session
with
otherpopup
windows
around
"
)
;
await
BrowserTestUtils
.
closeWindow
(
newWin
)
;
is
(
obs
[
"
browser
-
lastwindow
-
close
-
requested
"
]
2
"
Got
expected
browser
-
lastwindow
-
close
-
requested
notifications
"
)
;
is
(
obs
[
"
browser
-
lastwindow
-
close
-
granted
"
]
1
"
Got
expected
browser
-
lastwindow
-
close
-
granted
notifications
"
)
;
}
)
;
}
)
;
add_task
(
async
function
test_open_close_private_browsing
(
)
{
if
(
IS_MAC
)
{
return
;
}
await
setupTest
(
{
}
async
function
(
newWin
obs
)
{
let
closed
=
await
closeWindowForRestoration
(
newWin
)
;
ok
(
closed
"
Should
be
able
to
close
the
window
"
)
;
newWin
=
await
promiseNewWindowLoaded
(
{
private
:
true
}
)
;
is
(
newWin
.
gBrowser
.
browsers
.
length
1
"
Did
not
restore
in
private
browing
mode
"
)
;
closed
=
await
closeWindowForRestoration
(
newWin
)
;
ok
(
closed
"
Should
be
able
to
close
the
window
"
)
;
newWin
=
await
promiseNewWindowLoaded
(
)
;
is
(
newWin
.
gBrowser
.
browsers
.
length
TEST_URLS
.
length
+
2
"
Restored
tabs
in
a
new
non
-
private
window
"
)
;
await
BrowserTestUtils
.
closeWindow
(
newWin
)
;
is
(
obs
[
"
browser
-
lastwindow
-
close
-
requested
"
]
2
"
Got
expected
browser
-
lastwindow
-
close
-
requested
notifications
"
)
;
is
(
obs
[
"
browser
-
lastwindow
-
close
-
granted
"
]
2
"
Got
expected
browser
-
lastwindow
-
close
-
granted
notifications
"
)
;
}
)
;
}
)
;
add_task
(
async
function
test_open_close_window_and_popup
(
)
{
if
(
IS_MAC
)
{
return
;
}
await
setupTest
(
{
}
async
function
(
newWin
obs
)
{
let
popupPromise
=
BrowserTestUtils
.
waitForNewWindow
(
)
;
openDialog
(
location
"
popup
"
POPUP_FEATURES
TEST_URLS
[
0
]
)
;
let
popup
=
await
popupPromise
;
let
popup2Promise
=
BrowserTestUtils
.
waitForNewWindow
(
)
;
openDialog
(
location
"
popup2
"
POPUP_FEATURES
TEST_URLS
[
1
]
)
;
let
popup2
=
await
popup2Promise
;
popup2
.
gBrowser
.
addTab
(
TEST_URLS
[
0
]
)
;
let
closed
=
await
closeWindowForRestoration
(
newWin
)
;
ok
(
closed
"
Should
be
able
to
close
the
window
"
)
;
await
BrowserTestUtils
.
closeWindow
(
popup2
)
;
newWin
=
await
promiseNewWindowLoaded
(
)
;
is
(
newWin
.
gBrowser
.
browsers
.
length
TEST_URLS
.
length
+
2
"
Restored
window
and
associated
tabs
in
session
"
)
;
await
BrowserTestUtils
.
closeWindow
(
popup
)
;
await
BrowserTestUtils
.
closeWindow
(
newWin
)
;
is
(
obs
[
"
browser
-
lastwindow
-
close
-
requested
"
]
1
"
Got
expected
browser
-
lastwindow
-
close
-
requested
notifications
"
)
;
is
(
obs
[
"
browser
-
lastwindow
-
close
-
granted
"
]
1
"
Got
expected
browser
-
lastwindow
-
close
-
granted
notifications
"
)
;
}
)
;
}
)
;
add_task
(
async
function
test_open_close_only_popup
(
)
{
if
(
IS_MAC
)
{
return
;
}
await
setupTest
(
{
}
async
function
(
newWin
obs
)
{
await
BrowserTestUtils
.
closeWindow
(
newWin
)
;
let
popupPromise
=
BrowserTestUtils
.
waitForNewWindow
(
)
;
openDialog
(
location
"
popup
"
POPUP_FEATURES
TEST_URLS
[
1
]
)
;
let
popup
=
await
popupPromise
;
is
(
popup
.
gBrowser
.
browsers
.
length
1
"
Did
not
restore
the
popup
window
(
1
)
"
)
;
let
closed
=
await
closeWindowForRestoration
(
popup
)
;
ok
(
closed
"
Should
be
able
to
close
the
window
"
)
;
popupPromise
=
BrowserTestUtils
.
waitForNewWindow
(
)
;
openDialog
(
location
"
popup
"
POPUP_FEATURES
TEST_URLS
[
1
]
)
;
popup
=
await
popupPromise
;
popup
.
gBrowser
.
addTab
(
TEST_URLS
[
0
]
)
;
is
(
popup
.
gBrowser
.
browsers
.
length
2
"
Did
not
restore
to
the
popup
window
(
2
)
"
)
;
await
BrowserTestUtils
.
closeWindow
(
popup
)
;
newWin
=
await
promiseNewWindowLoaded
(
)
;
isnot
(
newWin
.
gBrowser
.
browsers
.
length
2
"
Did
not
restore
the
popup
window
"
)
;
is
(
TEST_URLS
.
indexOf
(
newWin
.
gBrowser
.
browsers
[
0
]
.
currentURI
.
spec
)
-
1
"
Did
not
restore
the
popup
window
(
2
)
"
)
;
await
BrowserTestUtils
.
closeWindow
(
newWin
)
;
is
(
obs
[
"
browser
-
lastwindow
-
close
-
requested
"
]
0
"
Got
expected
browser
-
lastwindow
-
close
-
requested
notifications
"
)
;
is
(
obs
[
"
browser
-
lastwindow
-
close
-
granted
"
]
0
"
Got
expected
browser
-
lastwindow
-
close
-
granted
notifications
"
)
;
}
)
;
}
)
;
add_task
(
async
function
test_open_close_restore_from_popup
(
)
{
if
(
IS_MAC
)
{
return
;
}
await
setupTest
(
{
}
async
function
(
newWin
obs
)
{
let
newWin2
=
await
promiseNewWindowLoaded
(
)
;
await
injectTestTabs
(
newWin2
)
;
let
closed
=
await
closeWindowForRestoration
(
newWin
)
;
ok
(
closed
"
Should
be
able
to
close
the
window
"
)
;
closed
=
await
closeWindowForRestoration
(
newWin2
)
;
ok
(
closed
"
Should
be
able
to
close
the
window
"
)
;
let
counts
=
getBrowserWindowsCount
(
)
;
is
(
counts
.
open
0
"
Got
right
number
of
open
windows
"
)
;
is
(
counts
.
winstates
1
"
Got
right
number
of
window
states
"
)
;
newWin
=
undoCloseWindow
(
0
)
;
await
BrowserTestUtils
.
waitForEvent
(
newWin
"
load
"
)
;
await
BrowserTestUtils
.
waitForEvent
(
newWin
.
gBrowser
.
tabContainer
"
SSTabRestored
"
)
;
newWin2
=
await
promiseNewWindowLoaded
(
)
;
is
(
newWin2
.
gBrowser
.
browsers
.
length
1
"
Did
not
restore
as
undoCloseWindow
(
)
was
last
called
"
)
;
is
(
TEST_URLS
.
indexOf
(
newWin2
.
gBrowser
.
browsers
[
0
]
.
currentURI
.
spec
)
-
1
"
Did
not
restore
as
undoCloseWindow
(
)
was
last
called
(
2
)
"
)
;
counts
=
getBrowserWindowsCount
(
)
;
is
(
counts
.
open
2
"
Got
right
number
of
open
windows
"
)
;
is
(
counts
.
winstates
3
"
Got
right
number
of
window
states
"
)
;
await
BrowserTestUtils
.
closeWindow
(
newWin
)
;
await
BrowserTestUtils
.
closeWindow
(
newWin2
)
;
counts
=
getBrowserWindowsCount
(
)
;
is
(
counts
.
open
0
"
Got
right
number
of
open
windows
"
)
;
is
(
counts
.
winstates
1
"
Got
right
number
of
window
states
"
)
;
}
)
;
}
)
;
add_task
(
async
function
test_mac_notifications
(
)
{
if
(
!
IS_MAC
)
{
return
;
}
await
setupTest
(
{
denyFirst
:
true
}
async
function
(
newWin
obs
)
{
let
closed
=
await
closeWindowForRestoration
(
newWin
)
;
ok
(
!
closed
"
First
close
attempt
should
be
denied
"
)
;
closed
=
await
closeWindowForRestoration
(
newWin
)
;
ok
(
closed
"
Second
close
attempt
should
be
granted
"
)
;
is
(
obs
[
"
browser
-
lastwindow
-
close
-
requested
"
]
2
"
Got
expected
browser
-
lastwindow
-
close
-
requested
notifications
"
)
;
is
(
obs
[
"
browser
-
lastwindow
-
close
-
granted
"
]
1
"
Got
expected
browser
-
lastwindow
-
close
-
granted
notifications
"
)
;
}
)
;
}
)
;
