"
use
strict
"
;
var
stateBackup
=
ss
.
getBrowserState
(
)
;
add_task
(
async
function
(
)
{
ignoreAllUncaughtExceptions
(
)
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
sessionstore
.
restore_on_demand
"
true
)
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
sessionstore
.
restore_tabs_lazily
"
false
)
;
let
state
=
{
windows
:
[
{
tabs
:
[
{
entries
:
[
{
url
:
"
http
:
/
/
example
.
org
#
1
"
triggeringPrincipal_base64
}
]
extData
:
{
uniq
:
r
(
)
}
}
{
entries
:
[
{
url
:
"
http
:
/
/
example
.
org
#
2
"
triggeringPrincipal_base64
}
]
extData
:
{
uniq
:
r
(
)
}
}
{
entries
:
[
{
url
:
"
http
:
/
/
example
.
org
#
3
"
triggeringPrincipal_base64
}
]
extData
:
{
uniq
:
r
(
)
}
}
{
entries
:
[
{
url
:
"
http
:
/
/
example
.
org
#
4
"
triggeringPrincipal_base64
}
]
extData
:
{
uniq
:
r
(
)
}
}
{
entries
:
[
{
url
:
"
http
:
/
/
example
.
org
#
5
"
triggeringPrincipal_base64
}
]
extData
:
{
uniq
:
r
(
)
}
}
{
entries
:
[
{
url
:
"
http
:
/
/
example
.
org
#
6
"
triggeringPrincipal_base64
}
]
}
]
selected
:
1
}
]
}
;
async
function
progressCallback
(
)
{
let
curState
=
JSON
.
parse
(
ss
.
getBrowserState
(
)
)
;
for
(
let
i
=
0
;
i
<
curState
.
windows
[
0
]
.
tabs
.
length
;
i
+
+
)
{
let
tabState
=
state
.
windows
[
0
]
.
tabs
[
i
]
;
let
tabCurState
=
curState
.
windows
[
0
]
.
tabs
[
i
]
;
if
(
tabState
.
extData
)
{
is
(
tabCurState
.
extData
.
uniq
tabState
.
extData
.
uniq
"
sanity
check
that
tab
has
correct
extData
"
)
;
}
else
{
ok
(
!
(
"
extData
"
in
tabCurState
)
|
|
!
(
"
uniq
"
in
tabCurState
.
extData
)
"
sanity
check
that
tab
doesn
'
t
have
extData
or
extData
doesn
'
t
have
'
uniq
'
"
)
;
}
}
let
newUniq
=
r
(
)
;
ss
.
setCustomTabValue
(
gBrowser
.
tabs
[
1
]
"
uniq
"
newUniq
)
;
let
tabState
=
JSON
.
parse
(
ss
.
getTabState
(
gBrowser
.
tabs
[
1
]
)
)
;
is
(
tabState
.
extData
.
uniq
newUniq
"
(
overwriting
)
new
data
is
stored
in
extData
"
)
;
gBrowser
.
hideTab
(
gBrowser
.
tabs
[
2
]
)
;
tabState
=
JSON
.
parse
(
ss
.
getTabState
(
gBrowser
.
tabs
[
2
]
)
)
;
ok
(
tabState
.
hidden
"
(
hiding
)
tab
data
has
hidden
=
=
true
"
)
;
let
stillUniq
=
r
(
)
;
ss
.
setCustomTabValue
(
gBrowser
.
tabs
[
3
]
"
stillUniq
"
stillUniq
)
;
tabState
=
JSON
.
parse
(
ss
.
getTabState
(
gBrowser
.
tabs
[
3
]
)
)
;
is
(
tabState
.
extData
.
stillUniq
stillUniq
"
(
adding
)
new
data
is
stored
in
extData
"
)
;
ss
.
deleteCustomTabValue
(
gBrowser
.
tabs
[
4
]
"
uniq
"
)
;
tabState
=
JSON
.
parse
(
ss
.
getTabState
(
gBrowser
.
tabs
[
4
]
)
)
;
if
(
"
extData
"
in
tabState
)
{
ok
(
!
(
"
uniq
"
in
tabState
.
extData
)
"
(
deleting
)
uniq
not
in
existing
extData
"
)
;
}
else
{
ok
(
true
"
(
deleting
)
no
data
is
stored
in
extData
"
)
;
}
let
newUniq2
=
r
(
)
;
ss
.
setCustomTabValue
(
gBrowser
.
tabs
[
5
]
"
uniq
"
newUniq2
)
;
tabState
=
JSON
.
parse
(
ss
.
getTabState
(
gBrowser
.
tabs
[
5
]
)
)
;
is
(
tabState
.
extData
.
uniq
newUniq2
"
(
creating
)
new
data
is
stored
in
extData
where
there
was
none
"
)
;
while
(
gBrowser
.
tabs
.
length
>
1
)
{
BrowserTestUtils
.
removeTab
(
gBrowser
.
tabs
[
1
]
)
;
}
}
await
setBrowserState
(
state
)
;
await
Promise
.
all
(
Array
.
from
(
gBrowser
.
tabs
tab
=
>
{
return
tab
=
=
gBrowser
.
selectedTab
?
promiseTabRestored
(
tab
)
:
promiseTabRestoring
(
tab
)
;
}
)
)
;
await
progressCallback
(
)
;
Services
.
prefs
.
clearUserPref
(
"
browser
.
sessionstore
.
restore_on_demand
"
)
;
Services
.
prefs
.
clearUserPref
(
"
browser
.
sessionstore
.
restore_tabs_lazily
"
)
;
await
promiseBrowserState
(
stateBackup
)
;
}
)
;
