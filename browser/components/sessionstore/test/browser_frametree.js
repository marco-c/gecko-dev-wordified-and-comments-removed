"
use
strict
"
;
const
URL
=
HTTPROOT
+
"
browser_frametree_sample
.
html
"
;
const
URL_FRAMESET
=
HTTPROOT
+
"
browser_frametree_sample_frameset
.
html
"
;
const
URL_IFRAMES
=
HTTPROOT
+
"
browser_frametree_sample_iframes
.
html
"
;
add_task
(
async
function
test_frametree
(
)
{
let
tab
=
BrowserTestUtils
.
addTab
(
gBrowser
URL
)
;
let
browser
=
tab
.
linkedBrowser
;
await
promiseBrowserLoaded
(
browser
)
;
is
(
await
countNonDynamicFrames
(
browser
)
0
"
no
child
frames
"
)
;
browser
.
loadURI
(
URL_FRAMESET
)
;
await
promiseBrowserLoaded
(
browser
)
;
is
(
await
countNonDynamicFrames
(
browser
)
2
"
two
non
-
dynamic
child
frames
"
)
;
let
pageShowPromise
=
ContentTask
.
spawn
(
browser
null
async
(
)
=
>
{
return
ContentTaskUtils
.
waitForEvent
(
this
"
pageshow
"
true
)
;
}
)
;
browser
.
goBack
(
)
;
await
pageShowPromise
;
is
(
await
countNonDynamicFrames
(
browser
)
0
"
no
child
frames
"
)
;
await
ContentTask
.
spawn
(
browser
URL
async
(
[
url
]
)
=
>
{
let
frame
=
content
.
document
.
createElement
(
"
iframe
"
)
;
frame
.
setAttribute
(
"
src
"
url
)
;
content
.
document
.
body
.
appendChild
(
frame
)
;
return
ContentTaskUtils
.
waitForEvent
(
frame
"
load
"
)
;
}
)
;
is
(
await
countNonDynamicFrames
(
browser
)
0
"
we
still
have
a
single
root
frame
"
)
;
await
promiseRemoveTab
(
tab
)
;
}
)
;
add_task
(
async
function
test_frametree_dynamic
(
)
{
let
tab
=
BrowserTestUtils
.
addTab
(
gBrowser
URL_IFRAMES
)
;
let
browser
=
tab
.
linkedBrowser
;
await
promiseBrowserLoaded
(
browser
)
;
is
(
await
countNonDynamicFrames
(
browser
)
2
"
two
non
-
dynamic
child
frames
"
)
;
is
(
await
enumerateIndexes
(
browser
)
"
0
1
"
"
correct
indexes
0
and
1
"
)
;
await
ContentTask
.
spawn
(
browser
URL
async
(
[
url
]
)
=
>
{
let
frame
=
content
.
document
.
createElement
(
"
iframe
"
)
;
frame
.
setAttribute
(
"
src
"
url
)
;
content
.
document
.
body
.
insertBefore
(
frame
content
.
document
.
getElementsByTagName
(
"
iframe
"
)
[
1
]
)
;
return
ContentTaskUtils
.
waitForEvent
(
frame
"
load
"
)
;
}
)
;
is
(
await
countNonDynamicFrames
(
browser
)
2
"
two
non
-
dynamic
child
frames
"
)
;
is
(
await
enumerateIndexes
(
browser
)
"
0
1
"
"
correct
indexes
0
and
1
"
)
;
await
ContentTask
.
spawn
(
browser
URL
async
(
[
url
]
)
=
>
{
let
frame
=
content
.
document
.
createElement
(
"
iframe
"
)
;
frame
.
setAttribute
(
"
src
"
url
)
;
content
.
document
.
body
.
appendChild
(
frame
)
;
return
ContentTaskUtils
.
waitForEvent
(
frame
"
load
"
)
;
}
)
;
is
(
await
countNonDynamicFrames
(
browser
)
2
"
two
non
-
dynamic
child
frames
"
)
;
is
(
await
enumerateIndexes
(
browser
)
"
0
1
"
"
correct
indexes
0
and
1
"
)
;
await
ContentTask
.
spawn
(
browser
URL
async
(
[
url
]
)
=
>
{
content
.
document
.
body
.
removeChild
(
content
.
document
.
getElementsByTagName
(
"
iframe
"
)
[
0
]
)
;
}
)
;
is
(
await
countNonDynamicFrames
(
browser
)
1
"
one
non
-
dynamic
child
frame
"
)
;
is
(
await
enumerateIndexes
(
browser
)
"
1
"
"
correct
index
1
"
)
;
await
promiseRemoveTab
(
tab
)
;
}
)
;
async
function
countNonDynamicFrames
(
browser
)
{
return
ContentTask
.
spawn
(
browser
null
async
(
)
=
>
{
const
ssu
=
Cc
[
"
mozilla
.
org
/
browser
/
sessionstore
/
utils
;
1
"
]
.
getService
(
Ci
.
nsISessionStoreUtils
)
;
let
count
=
0
;
ssu
.
forEachNonDynamicChildFrame
(
content
(
)
=
>
count
+
+
)
;
return
count
;
}
)
;
}
async
function
enumerateIndexes
(
browser
)
{
return
ContentTask
.
spawn
(
browser
null
async
(
)
=
>
{
const
ssu
=
Cc
[
"
mozilla
.
org
/
browser
/
sessionstore
/
utils
;
1
"
]
.
getService
(
Ci
.
nsISessionStoreUtils
)
;
let
indexes
=
[
]
;
ssu
.
forEachNonDynamicChildFrame
(
content
(
frame
i
)
=
>
indexes
.
push
(
i
)
)
;
return
indexes
.
join
(
"
"
)
;
}
)
;
}
