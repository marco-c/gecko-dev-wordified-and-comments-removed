"
use
strict
"
;
requestLongerTimeout
(
10
)
;
const
PAGE_1
=
"
data
:
text
/
html
<
html
>
<
body
>
A
%
20regular
%
20everyday
%
20normal
%
20page
.
"
;
const
PAGE_2
=
"
data
:
text
/
html
<
html
>
<
body
>
Another
%
20regular
%
20everyday
%
20normal
%
20page
.
"
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
tabs
.
animate
"
false
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
"
browser
.
tabs
.
animate
"
)
;
}
)
;
Services
.
prefs
.
clearUserPref
(
"
browser
.
sessionstore
.
restore_on_demand
"
)
;
function
clickButton
(
browser
id
)
{
info
(
"
Clicking
"
+
id
)
;
let
frame_script
=
(
id
)
=
>
{
let
button
=
content
.
document
.
getElementById
(
id
)
;
button
.
click
(
)
;
}
;
let
mm
=
browser
.
messageManager
;
mm
.
loadFrameScript
(
"
data
:
(
"
+
frame_script
.
toString
(
)
+
"
)
(
'
"
+
id
+
"
'
)
;
"
false
)
;
}
function
promiseContentDocumentURIEquals
(
browser
URI
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
frame_script
=
(
)
=
>
{
sendAsyncMessage
(
"
test
:
documenturi
"
{
uri
:
content
.
document
.
documentURI
}
)
;
}
;
let
mm
=
browser
.
messageManager
;
mm
.
addMessageListener
(
"
test
:
documenturi
"
function
onMessage
(
message
)
{
mm
.
removeMessageListener
(
"
test
:
documenturi
"
onMessage
)
;
let
contentURI
=
message
.
data
.
uri
;
if
(
contentURI
=
=
URI
)
{
resolve
(
)
;
}
else
{
reject
(
Content
has
URI
{
contentURI
}
which
does
not
match
{
URI
}
)
;
}
}
)
;
mm
.
loadFrameScript
(
"
data
:
(
"
+
frame_script
.
toString
(
)
+
"
)
(
)
;
"
false
)
;
}
)
;
}
function
promiseHistoryLength
(
browser
length
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
frame_script
=
(
)
=
>
{
sendAsyncMessage
(
"
test
:
historylength
"
{
length
:
content
.
history
.
length
}
)
;
}
;
let
mm
=
browser
.
messageManager
;
mm
.
addMessageListener
(
"
test
:
historylength
"
function
onMessage
(
message
)
{
mm
.
removeMessageListener
(
"
test
:
historylength
"
onMessage
)
;
let
contentLength
=
message
.
data
.
length
;
if
(
contentLength
=
=
length
)
{
resolve
(
)
;
}
else
{
reject
(
Content
has
window
.
history
.
length
{
contentLength
}
which
does
+
not
equal
expected
{
length
}
)
;
}
}
)
;
mm
.
loadFrameScript
(
"
data
:
(
"
+
frame_script
.
toString
(
)
+
"
)
(
)
;
"
false
)
;
}
)
;
}
function
promiseTabCrashedReady
(
browser
)
{
return
new
Promise
(
(
resolve
)
=
>
{
browser
.
addEventListener
(
"
AboutTabCrashedReady
"
function
ready
(
e
)
{
browser
.
removeEventListener
(
"
AboutTabCrashedReady
"
ready
false
true
)
;
resolve
(
)
;
}
false
true
)
;
}
)
;
}
add_task
(
function
test_crash_page_not_in_history
(
)
{
let
newTab
=
gBrowser
.
addTab
(
)
;
gBrowser
.
selectedTab
=
newTab
;
let
browser
=
newTab
.
linkedBrowser
;
ok
(
browser
.
isRemoteBrowser
"
Should
be
a
remote
browser
"
)
;
yield
promiseBrowserLoaded
(
browser
)
;
browser
.
loadURI
(
PAGE_1
)
;
yield
promiseBrowserLoaded
(
browser
)
;
yield
TabStateFlusher
.
flush
(
browser
)
;
yield
BrowserTestUtils
.
crashBrowser
(
browser
)
;
let
{
entries
}
=
JSON
.
parse
(
ss
.
getTabState
(
newTab
)
)
;
is
(
entries
.
length
1
"
Should
have
a
single
history
entry
"
)
;
is
(
entries
[
0
]
.
url
PAGE_1
"
Single
entry
should
be
the
page
we
visited
before
crashing
"
)
;
gBrowser
.
removeTab
(
newTab
)
;
}
)
;
add_task
(
function
test_revived_history_from_remote
(
)
{
let
newTab
=
gBrowser
.
addTab
(
)
;
gBrowser
.
selectedTab
=
newTab
;
let
browser
=
newTab
.
linkedBrowser
;
ok
(
browser
.
isRemoteBrowser
"
Should
be
a
remote
browser
"
)
;
yield
promiseBrowserLoaded
(
browser
)
;
browser
.
loadURI
(
PAGE_1
)
;
yield
promiseBrowserLoaded
(
browser
)
;
yield
TabStateFlusher
.
flush
(
browser
)
;
yield
BrowserTestUtils
.
crashBrowser
(
browser
)
;
browser
.
loadURI
(
PAGE_2
)
;
yield
promiseTabRestored
(
newTab
)
;
ok
(
!
newTab
.
hasAttribute
(
"
crashed
"
)
"
Tab
shouldn
'
t
be
marked
as
crashed
anymore
.
"
)
;
ok
(
browser
.
isRemoteBrowser
"
Should
be
a
remote
browser
"
)
;
yield
TabStateFlusher
.
flush
(
browser
)
;
let
{
entries
}
=
JSON
.
parse
(
ss
.
getTabState
(
newTab
)
)
;
is
(
entries
.
length
2
"
Should
have
two
history
entries
"
)
;
is
(
entries
[
0
]
.
url
PAGE_1
"
First
entry
should
be
the
page
we
visited
before
crashing
"
)
;
is
(
entries
[
1
]
.
url
PAGE_2
"
Second
entry
should
be
the
page
we
visited
after
crashing
"
)
;
gBrowser
.
removeTab
(
newTab
)
;
}
)
;
add_task
(
function
test_revived_history_from_non_remote
(
)
{
let
newTab
=
gBrowser
.
addTab
(
)
;
gBrowser
.
selectedTab
=
newTab
;
let
browser
=
newTab
.
linkedBrowser
;
ok
(
browser
.
isRemoteBrowser
"
Should
be
a
remote
browser
"
)
;
yield
promiseBrowserLoaded
(
browser
)
;
browser
.
loadURI
(
PAGE_1
)
;
yield
promiseBrowserLoaded
(
browser
)
;
yield
TabStateFlusher
.
flush
(
browser
)
;
yield
BrowserTestUtils
.
crashBrowser
(
browser
)
;
browser
.
loadURI
(
"
about
:
mozilla
"
)
;
yield
promiseBrowserLoaded
(
browser
)
;
ok
(
!
newTab
.
hasAttribute
(
"
crashed
"
)
"
Tab
shouldn
'
t
be
marked
as
crashed
anymore
.
"
)
;
ok
(
!
browser
.
isRemoteBrowser
"
Should
not
be
a
remote
browser
"
)
;
yield
TabStateFlusher
.
flush
(
browser
)
;
let
{
entries
}
=
JSON
.
parse
(
ss
.
getTabState
(
newTab
)
)
;
is
(
entries
.
length
2
"
Should
have
two
history
entries
"
)
;
is
(
entries
[
0
]
.
url
PAGE_1
"
First
entry
should
be
the
page
we
visited
before
crashing
"
)
;
is
(
entries
[
1
]
.
url
"
about
:
mozilla
"
"
Second
entry
should
be
the
page
we
visited
after
crashing
"
)
;
gBrowser
.
removeTab
(
newTab
)
;
}
)
;
add_task
(
function
test_revive_tab_from_session_store
(
)
{
let
newTab
=
gBrowser
.
addTab
(
)
;
gBrowser
.
selectedTab
=
newTab
;
let
browser
=
newTab
.
linkedBrowser
;
ok
(
browser
.
isRemoteBrowser
"
Should
be
a
remote
browser
"
)
;
yield
promiseBrowserLoaded
(
browser
)
;
browser
.
loadURI
(
PAGE_1
)
;
yield
promiseBrowserLoaded
(
browser
)
;
let
newTab2
=
gBrowser
.
addTab
(
)
;
let
browser2
=
newTab2
.
linkedBrowser
;
ok
(
browser2
.
isRemoteBrowser
"
Should
be
a
remote
browser
"
)
;
yield
promiseBrowserLoaded
(
browser2
)
;
browser
.
loadURI
(
PAGE_1
)
;
yield
promiseBrowserLoaded
(
browser
)
;
browser
.
loadURI
(
PAGE_2
)
;
yield
promiseBrowserLoaded
(
browser
)
;
yield
TabStateFlusher
.
flush
(
browser
)
;
yield
BrowserTestUtils
.
crashBrowser
(
browser
)
;
ok
(
!
newTab2
.
hasAttribute
(
"
crashed
"
)
"
Second
tab
should
not
be
crashed
.
"
)
;
ok
(
newTab2
.
hasAttribute
(
"
pending
"
)
"
Second
tab
should
be
pending
.
"
)
;
clickButton
(
browser
"
restoreTab
"
)
;
yield
promiseTabRestored
(
newTab
)
;
ok
(
!
newTab
.
hasAttribute
(
"
crashed
"
)
"
Tab
shouldn
'
t
be
marked
as
crashed
anymore
.
"
)
;
ok
(
newTab2
.
hasAttribute
(
"
pending
"
)
"
Second
tab
should
still
be
pending
.
"
)
;
yield
promiseContentDocumentURIEquals
(
browser
PAGE_2
)
;
yield
promiseHistoryLength
(
browser
2
)
;
gBrowser
.
removeTab
(
newTab
)
;
gBrowser
.
removeTab
(
newTab2
)
;
}
)
;
add_task
(
function
test_revive_all_tabs_from_session_store
(
)
{
let
newTab
=
gBrowser
.
addTab
(
)
;
gBrowser
.
selectedTab
=
newTab
;
let
browser
=
newTab
.
linkedBrowser
;
ok
(
browser
.
isRemoteBrowser
"
Should
be
a
remote
browser
"
)
;
yield
promiseBrowserLoaded
(
browser
)
;
browser
.
loadURI
(
PAGE_1
)
;
yield
promiseBrowserLoaded
(
browser
)
;
let
win2
=
yield
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
let
newTab2
=
win2
.
gBrowser
.
addTab
(
PAGE_1
)
;
win2
.
gBrowser
.
selectedTab
=
newTab2
;
let
browser2
=
newTab2
.
linkedBrowser
;
ok
(
browser2
.
isRemoteBrowser
"
Should
be
a
remote
browser
"
)
;
yield
promiseBrowserLoaded
(
browser2
)
;
browser
.
loadURI
(
PAGE_1
)
;
yield
promiseBrowserLoaded
(
browser
)
;
browser
.
loadURI
(
PAGE_2
)
;
yield
promiseBrowserLoaded
(
browser
)
;
yield
TabStateFlusher
.
flush
(
browser
)
;
yield
TabStateFlusher
.
flush
(
browser2
)
;
yield
BrowserTestUtils
.
crashBrowser
(
browser
)
;
is
(
newTab
.
getAttribute
(
"
crashed
"
)
"
true
"
"
First
tab
should
be
crashed
"
)
;
is
(
newTab2
.
getAttribute
(
"
crashed
"
)
"
true
"
"
Second
window
tab
should
be
crashed
"
)
;
clickButton
(
browser
"
restoreAll
"
)
;
yield
promiseTabRestored
(
newTab
)
;
ok
(
!
newTab
.
hasAttribute
(
"
crashed
"
)
"
Tab
shouldn
'
t
be
marked
as
crashed
anymore
.
"
)
;
ok
(
!
newTab
.
hasAttribute
(
"
pending
"
)
"
Tab
shouldn
'
t
be
pending
.
"
)
;
ok
(
!
newTab2
.
hasAttribute
(
"
crashed
"
)
"
Second
tab
shouldn
'
t
be
marked
as
crashed
anymore
.
"
)
;
ok
(
!
newTab2
.
hasAttribute
(
"
pending
"
)
"
Second
tab
shouldn
'
t
be
pending
.
"
)
;
yield
promiseContentDocumentURIEquals
(
browser
PAGE_2
)
;
yield
promiseContentDocumentURIEquals
(
browser2
PAGE_1
)
;
yield
promiseHistoryLength
(
browser
2
)
;
yield
BrowserTestUtils
.
closeWindow
(
win2
)
;
gBrowser
.
removeTab
(
newTab
)
;
}
)
;
add_task
(
function
test_close_tab_after_crash
(
)
{
let
newTab
=
gBrowser
.
addTab
(
)
;
gBrowser
.
selectedTab
=
newTab
;
let
browser
=
newTab
.
linkedBrowser
;
ok
(
browser
.
isRemoteBrowser
"
Should
be
a
remote
browser
"
)
;
yield
promiseBrowserLoaded
(
browser
)
;
browser
.
loadURI
(
PAGE_1
)
;
yield
promiseBrowserLoaded
(
browser
)
;
yield
TabStateFlusher
.
flush
(
browser
)
;
yield
BrowserTestUtils
.
crashBrowser
(
browser
)
;
let
promise
=
promiseEvent
(
gBrowser
.
tabContainer
"
TabClose
"
)
;
clickButton
(
browser
"
closeTab
"
)
;
yield
promise
;
is
(
gBrowser
.
tabs
.
length
1
"
Should
have
closed
the
tab
"
)
;
}
)
;
add_task
(
function
*
test_hide_restore_all_button
(
)
{
let
newTab
=
gBrowser
.
addTab
(
)
;
gBrowser
.
selectedTab
=
newTab
;
let
browser
=
newTab
.
linkedBrowser
;
ok
(
browser
.
isRemoteBrowser
"
Should
be
a
remote
browser
"
)
;
yield
promiseBrowserLoaded
(
browser
)
;
browser
.
loadURI
(
PAGE_1
)
;
yield
promiseBrowserLoaded
(
browser
)
;
yield
TabStateFlusher
.
flush
(
browser
)
;
yield
BrowserTestUtils
.
crashBrowser
(
browser
)
;
let
doc
=
browser
.
contentDocument
;
let
restoreAllButton
=
doc
.
getElementById
(
"
restoreAll
"
)
;
let
restoreOneButton
=
doc
.
getElementById
(
"
restoreTab
"
)
;
is
(
restoreAllButton
.
getAttribute
(
"
hidden
"
)
"
true
"
"
Restore
All
button
should
be
hidden
"
)
;
ok
(
restoreOneButton
.
classList
.
contains
(
"
primary
"
)
"
Restore
Tab
button
should
have
the
primary
class
"
)
;
let
newTab2
=
gBrowser
.
addTab
(
)
;
gBrowser
.
selectedTab
=
newTab
;
browser
.
loadURI
(
PAGE_2
)
;
yield
promiseBrowserLoaded
(
browser
)
;
let
win2
=
yield
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
let
newTab3
=
win2
.
gBrowser
.
addTab
(
PAGE_2
)
;
win2
.
gBrowser
.
selectedTab
=
newTab3
;
let
otherWinBrowser
=
newTab3
.
linkedBrowser
;
yield
promiseBrowserLoaded
(
otherWinBrowser
)
;
let
otherBrowserReady
=
promiseTabCrashedReady
(
otherWinBrowser
)
;
yield
BrowserTestUtils
.
crashBrowser
(
browser
)
;
yield
otherBrowserReady
;
doc
=
browser
.
contentDocument
;
restoreAllButton
=
doc
.
getElementById
(
"
restoreAll
"
)
;
restoreOneButton
=
doc
.
getElementById
(
"
restoreTab
"
)
;
ok
(
!
restoreAllButton
.
hasAttribute
(
"
hidden
"
)
"
Restore
All
button
should
not
be
hidden
"
)
;
ok
(
!
(
restoreOneButton
.
classList
.
contains
(
"
primary
"
)
)
"
Restore
Tab
button
should
not
have
the
primary
class
"
)
;
yield
BrowserTestUtils
.
closeWindow
(
win2
)
;
gBrowser
.
removeTab
(
newTab
)
;
gBrowser
.
removeTab
(
newTab2
)
;
}
)
;
add_task
(
function
*
test_aboutcrashedtabzoom
(
)
{
let
newTab
=
gBrowser
.
addTab
(
)
;
gBrowser
.
selectedTab
=
newTab
;
let
browser
=
newTab
.
linkedBrowser
;
ok
(
browser
.
isRemoteBrowser
"
Should
be
a
remote
browser
"
)
;
yield
promiseBrowserLoaded
(
browser
)
;
browser
.
loadURI
(
PAGE_1
)
;
yield
promiseBrowserLoaded
(
browser
)
;
FullZoom
.
enlarge
(
)
;
let
zoomLevel
=
ZoomManager
.
getZoomForBrowser
(
browser
)
;
ok
(
zoomLevel
!
=
=
1
"
should
have
enlarged
"
)
;
yield
TabStateFlusher
.
flush
(
browser
)
;
yield
BrowserTestUtils
.
crashBrowser
(
browser
)
;
ok
(
ZoomManager
.
getZoomForBrowser
(
browser
)
=
=
=
1
"
zoom
should
have
reset
on
crash
"
)
;
clickButton
(
browser
"
restoreTab
"
)
;
yield
promiseTabRestored
(
newTab
)
;
ok
(
ZoomManager
.
getZoomForBrowser
(
browser
)
=
=
=
zoomLevel
"
zoom
should
have
gone
back
to
enlarged
"
)
;
FullZoom
.
reset
(
)
;
gBrowser
.
removeTab
(
newTab
)
;
}
)
;
