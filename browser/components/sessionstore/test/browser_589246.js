const
WINDOW_ATTRIBUTES
=
[
"
width
"
"
height
"
"
screenX
"
"
screenY
"
"
sizemode
"
]
;
var
stateBackup
=
ss
.
getBrowserState
(
)
;
var
originalWarnOnClose
=
Services
.
prefs
.
getBoolPref
(
"
browser
.
tabs
.
warnOnClose
"
)
;
var
originalStartupPage
=
Services
.
prefs
.
getIntPref
(
"
browser
.
startup
.
page
"
)
;
var
originalWindowType
=
document
.
documentElement
.
getAttribute
(
"
windowtype
"
)
;
var
gotLastWindowClosedTopic
=
false
;
var
shouldPinTab
=
false
;
var
shouldOpenTabs
=
false
;
var
shouldCloseTab
=
false
;
var
testNum
=
0
;
var
afterTestCallback
;
var
testState
=
{
windows
:
[
{
tabs
:
[
{
entries
:
[
{
url
:
"
http
:
/
/
example
.
org
"
}
]
}
]
}
]
_closedWindows
:
[
]
}
;
var
tests
=
[
]
;
function
checkOSX34Generator
(
num
)
{
return
function
(
aPreviousState
aCurState
)
{
let
expectedState
=
JSON
.
parse
(
aPreviousState
)
;
expectedState
[
0
]
.
tabs
.
shift
(
)
;
WINDOW_ATTRIBUTES
.
forEach
(
attr
=
>
delete
expectedState
[
0
]
[
attr
]
)
;
is
(
aCurState
JSON
.
stringify
(
expectedState
)
"
test
#
"
+
num
+
"
:
closedWindowState
is
as
expected
"
)
;
}
;
}
function
checkNoWindowsGenerator
(
num
)
{
return
function
(
aPreviousState
aCurState
)
{
is
(
aCurState
"
[
]
"
"
test
#
"
+
num
+
"
:
there
should
be
no
closedWindowsLeft
"
)
;
}
;
}
tests
.
push
(
{
pinned
:
false
extra
:
false
close
:
false
checkWinLin
:
checkNoWindowsGenerator
(
1
)
checkOSX
(
aPreviousState
aCurState
)
{
is
(
aCurState
aPreviousState
"
test
#
1
:
closed
window
state
is
unchanged
"
)
;
}
}
)
;
tests
.
push
(
{
pinned
:
true
extra
:
false
close
:
false
checkWinLin
:
checkNoWindowsGenerator
(
2
)
checkOSX
:
checkNoWindowsGenerator
(
2
)
}
)
;
tests
.
push
(
{
pinned
:
true
extra
:
true
close
:
false
checkWinLin
:
checkNoWindowsGenerator
(
3
)
checkOSX
:
checkOSX34Generator
(
3
)
}
)
;
tests
.
push
(
{
pinned
:
true
extra
:
true
close
:
"
one
"
checkWinLin
:
checkNoWindowsGenerator
(
4
)
checkOSX
:
checkOSX34Generator
(
4
)
}
)
;
tests
.
push
(
{
pinned
:
true
extra
:
true
close
:
"
both
"
checkWinLin
:
checkNoWindowsGenerator
(
5
)
checkOSX
:
checkNoWindowsGenerator
(
5
)
}
)
;
function
test
(
)
{
waitForExplicitFinish
(
)
;
requestLongerTimeout
(
2
)
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
tabs
.
warnOnClose
"
false
)
;
Services
.
prefs
.
setIntPref
(
"
browser
.
startup
.
page
"
3
)
;
runNextTestOrFinish
(
)
;
}
function
runNextTestOrFinish
(
)
{
if
(
tests
.
length
)
{
setupForTest
(
tests
.
shift
(
)
)
;
}
else
{
[
"
browser
.
tabs
.
warnOnClose
"
"
browser
.
startup
.
page
"
]
.
forEach
(
function
(
p
)
{
if
(
Services
.
prefs
.
prefHasUserValue
(
p
)
)
{
Services
.
prefs
.
clearUserPref
(
p
)
;
}
}
)
;
ss
.
setBrowserState
(
stateBackup
)
;
executeSoon
(
finish
)
;
}
}
function
setupForTest
(
aConditions
)
{
gotLastWindowClosedTopic
=
false
;
shouldPinTab
=
aConditions
.
pinned
;
shouldOpenTabs
=
aConditions
.
extra
;
shouldCloseTab
=
aConditions
.
close
;
testNum
+
+
;
afterTestCallback
=
/
Mac
/
.
test
(
navigator
.
platform
)
?
aConditions
.
checkOSX
:
aConditions
.
checkWinLin
;
Services
.
obs
.
addObserver
(
onLastWindowClosed
"
browser
-
lastwindow
-
close
-
granted
"
)
;
Services
.
obs
.
addObserver
(
onStateRestored
"
sessionstore
-
browser
-
state
-
restored
"
)
;
ss
.
setBrowserState
(
JSON
.
stringify
(
testState
)
)
;
}
function
onStateRestored
(
aSubject
aTopic
aData
)
{
info
(
"
test
#
"
+
testNum
+
"
:
onStateRestored
"
)
;
Services
.
obs
.
removeObserver
(
onStateRestored
"
sessionstore
-
browser
-
state
-
restored
"
)
;
document
.
documentElement
.
setAttribute
(
"
windowtype
"
"
navigator
:
testrunner
"
)
;
let
newWin
=
openDialog
(
location
"
_blank
"
"
chrome
all
dialog
=
no
"
"
http
:
/
/
example
.
com
"
)
;
newWin
.
addEventListener
(
"
load
"
function
(
aEvent
)
{
promiseBrowserLoaded
(
newWin
.
gBrowser
.
selectedBrowser
)
.
then
(
(
)
=
>
{
if
(
shouldPinTab
)
{
newWin
.
gBrowser
.
pinTab
(
newWin
.
gBrowser
.
selectedTab
)
;
}
newWin
.
addEventListener
(
"
unload
"
function
(
)
{
onWindowUnloaded
(
)
;
}
{
once
:
true
}
)
;
if
(
shouldOpenTabs
)
{
let
newTab
=
BrowserTestUtils
.
addTab
(
newWin
.
gBrowser
"
about
:
config
"
)
;
let
newTab2
=
BrowserTestUtils
.
addTab
(
newWin
.
gBrowser
"
about
:
buildconfig
"
)
;
newTab
.
linkedBrowser
.
addEventListener
(
"
load
"
function
(
)
{
if
(
shouldCloseTab
=
=
"
one
"
)
{
newWin
.
gBrowser
.
removeTab
(
newTab2
)
;
}
else
if
(
shouldCloseTab
=
=
"
both
"
)
{
newWin
.
gBrowser
.
removeTab
(
newTab
)
;
newWin
.
gBrowser
.
removeTab
(
newTab2
)
;
}
newWin
.
BrowserTryToCloseWindow
(
)
;
}
{
capture
:
true
once
:
true
}
)
;
}
else
{
newWin
.
BrowserTryToCloseWindow
(
)
;
}
}
)
;
}
{
once
:
true
}
)
;
}
function
onLastWindowClosed
(
aSubject
aTopic
aData
)
{
info
(
"
test
#
"
+
testNum
+
"
:
onLastWindowClosed
"
)
;
Services
.
obs
.
removeObserver
(
onLastWindowClosed
"
browser
-
lastwindow
-
close
-
granted
"
)
;
gotLastWindowClosedTopic
=
true
;
}
function
onWindowUnloaded
(
)
{
info
(
"
test
#
"
+
testNum
+
"
:
onWindowClosed
"
)
;
ok
(
gotLastWindowClosedTopic
"
test
#
"
+
testNum
+
"
:
browser
-
lastwindow
-
close
-
granted
was
notified
prior
"
)
;
let
previousClosedWindowData
=
ss
.
getClosedWindowData
(
)
;
let
newWin
=
openDialog
(
location
"
_blank
"
"
chrome
all
dialog
=
no
"
"
about
:
mozilla
"
)
;
newWin
.
addEventListener
(
"
load
"
function
(
aEvent
)
{
newWin
.
gBrowser
.
selectedBrowser
.
addEventListener
(
"
load
"
function
(
)
{
afterTestCallback
(
previousClosedWindowData
ss
.
getClosedWindowData
(
)
)
;
afterTestCleanup
(
newWin
)
;
}
{
capture
:
true
once
:
true
}
)
;
}
{
once
:
true
}
)
;
}
function
afterTestCleanup
(
aNewWin
)
{
executeSoon
(
function
(
)
{
BrowserTestUtils
.
closeWindow
(
aNewWin
)
.
then
(
(
)
=
>
{
document
.
documentElement
.
setAttribute
(
"
windowtype
"
originalWindowType
)
;
runNextTestOrFinish
(
)
;
}
)
;
}
)
;
}
