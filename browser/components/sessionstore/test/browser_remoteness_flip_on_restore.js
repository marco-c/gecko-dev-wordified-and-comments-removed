"
use
strict
"
;
function
prepareState
(
state
selected
)
{
let
copy
=
{
}
;
Object
.
assign
(
copy
state
)
;
copy
.
selected
=
selected
;
return
{
windows
:
[
copy
]
}
;
}
const
SIMPLE_STATE
=
{
tabs
:
[
{
entries
:
[
{
url
:
"
http
:
/
/
example
.
com
/
"
triggeringPrincipal_base64
title
:
"
title
"
}
]
}
{
entries
:
[
{
url
:
"
http
:
/
/
example
.
com
/
"
triggeringPrincipal_base64
title
:
"
title
"
}
]
}
{
entries
:
[
{
url
:
"
http
:
/
/
example
.
com
/
"
triggeringPrincipal_base64
title
:
"
title
"
}
]
}
]
title
:
"
"
_closedTabs
:
[
]
}
;
const
PINNED_STATE
=
{
tabs
:
[
{
entries
:
[
{
url
:
"
http
:
/
/
example
.
com
/
"
triggeringPrincipal_base64
title
:
"
title
"
}
]
pinned
:
true
}
{
entries
:
[
{
url
:
"
http
:
/
/
example
.
com
/
"
triggeringPrincipal_base64
title
:
"
title
"
}
]
pinned
:
true
}
{
entries
:
[
{
url
:
"
http
:
/
/
example
.
com
/
"
triggeringPrincipal_base64
title
:
"
title
"
}
]
}
]
title
:
"
"
_closedTabs
:
[
]
}
;
async
function
runScenarios
(
scenarios
)
{
for
(
let
[
scenarioIndex
scenario
]
of
scenarios
.
entries
(
)
)
{
info
(
"
Running
scenario
"
+
scenarioIndex
)
;
Assert
.
ok
(
scenario
.
initialSelectedTab
>
0
"
You
must
define
an
initially
selected
tab
"
)
;
let
win
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
let
tabbrowser
=
win
.
gBrowser
;
Assert
.
ok
(
tabbrowser
.
selectedBrowser
.
isRemoteBrowser
"
The
initial
browser
should
be
remote
.
"
)
;
for
(
let
i
=
0
;
i
<
scenario
.
initialRemoteness
.
length
;
+
+
i
)
{
let
tab
;
if
(
i
>
0
)
{
info
(
"
Opening
a
new
tab
"
)
;
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
tabbrowser
)
;
}
else
{
info
(
"
Using
the
selected
tab
"
)
;
tab
=
tabbrowser
.
selectedTab
;
}
let
browser
=
tab
.
linkedBrowser
;
let
remotenessState
=
scenario
.
initialRemoteness
[
i
]
;
tabbrowser
.
updateBrowserRemoteness
(
browser
remotenessState
)
;
}
let
tabToSelect
=
tabbrowser
.
tabs
[
scenario
.
initialSelectedTab
-
1
]
;
if
(
tabbrowser
.
selectedTab
!
=
tabToSelect
)
{
await
BrowserTestUtils
.
switchTab
(
tabbrowser
tabToSelect
)
;
}
let
state
=
prepareState
(
scenario
.
stateToRestore
scenario
.
selectedTab
)
;
await
setWindowState
(
win
state
true
)
;
for
(
let
i
=
0
;
i
<
scenario
.
expectedRemoteness
.
length
;
+
+
i
)
{
let
expectedRemoteness
=
scenario
.
expectedRemoteness
[
i
]
;
let
tab
=
tabbrowser
.
tabs
[
i
]
;
Assert
.
equal
(
tab
.
linkedBrowser
.
isRemoteBrowser
expectedRemoteness
"
Should
have
gotten
the
expected
remoteness
"
+
for
the
tab
at
index
{
i
}
)
;
}
await
BrowserTestUtils
.
closeWindow
(
win
)
;
}
}
add_task
(
async
function
(
)
{
requestLongerTimeout
(
5
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
"
set
"
:
[
[
"
browser
.
sessionstore
.
restore_on_demand
"
true
]
]
}
)
;
const
TEST_SCENARIOS
=
[
{
initialRemoteness
:
[
true
]
initialSelectedTab
:
1
stateToRestore
:
SIMPLE_STATE
selectedTab
:
3
expectedRemoteness
:
[
true
true
true
]
}
{
initialRemoteness
:
[
true
]
initialSelectedTab
:
1
stateToRestore
:
SIMPLE_STATE
selectedTab
:
1
expectedRemoteness
:
[
true
true
true
]
}
{
initialRemoteness
:
[
true
]
initialSelectedTab
:
1
stateToRestore
:
SIMPLE_STATE
selectedTab
:
0
expectedRemoteness
:
[
true
true
true
]
}
{
initialRemoteness
:
[
true
]
initialSelectedTab
:
1
stateToRestore
:
PINNED_STATE
selectedTab
:
3
expectedRemoteness
:
[
true
true
true
]
}
{
initialRemoteness
:
[
false
]
initialSelectedTab
:
1
stateToRestore
:
SIMPLE_STATE
selectedTab
:
2
expectedRemoteness
:
[
true
true
true
]
}
{
initialRemoteness
:
[
true
false
true
]
initialSelectedTab
:
1
stateToRestore
:
SIMPLE_STATE
selectedTab
:
3
expectedRemoteness
:
[
true
true
true
]
}
{
initialRemoteness
:
[
false
]
initialSelectedTab
:
1
stateToRestore
:
PINNED_STATE
selectedTab
:
3
expectedRemoteness
:
[
true
true
true
]
}
]
;
await
runScenarios
(
TEST_SCENARIOS
)
;
}
)
;
