"
use
strict
"
;
function
prepareState
(
state
selected
)
{
let
copy
=
{
}
;
Object
.
assign
(
copy
state
)
;
copy
.
selected
=
selected
;
return
{
windows
:
[
copy
]
}
;
}
const
SIMPLE_STATE
=
{
tabs
:
[
{
entries
:
[
{
url
:
"
http
:
/
/
example
.
com
/
"
title
:
"
title
"
}
]
}
{
entries
:
[
{
url
:
"
http
:
/
/
example
.
com
/
"
title
:
"
title
"
}
]
}
{
entries
:
[
{
url
:
"
http
:
/
/
example
.
com
/
"
title
:
"
title
"
}
]
}
]
title
:
"
"
_closedTabs
:
[
]
}
;
const
PINNED_STATE
=
{
tabs
:
[
{
entries
:
[
{
url
:
"
http
:
/
/
example
.
com
/
"
title
:
"
title
"
}
]
pinned
:
true
}
{
entries
:
[
{
url
:
"
http
:
/
/
example
.
com
/
"
title
:
"
title
"
}
]
pinned
:
true
}
{
entries
:
[
{
url
:
"
http
:
/
/
example
.
com
/
"
title
:
"
title
"
}
]
}
]
title
:
"
"
_closedTabs
:
[
]
}
;
function
*
runScenarios
(
scenarios
)
{
for
(
let
scenario
of
scenarios
)
{
Assert
.
equal
(
scenario
.
expectedFlips
.
length
scenario
.
expectedRemoteness
.
length
"
All
expected
flips
and
remoteness
needs
to
be
supplied
"
)
;
Assert
.
ok
(
scenario
.
initialSelectedTab
>
0
"
You
must
define
an
initially
selected
tab
"
)
;
let
win
=
yield
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
let
tabbrowser
=
win
.
gBrowser
;
Assert
.
ok
(
tabbrowser
.
selectedBrowser
.
isRemoteBrowser
"
The
initial
browser
should
be
remote
.
"
)
;
for
(
let
i
=
0
;
i
<
scenario
.
initialRemoteness
.
length
;
+
+
i
)
{
let
tab
;
if
(
i
>
0
)
{
info
(
"
Opening
a
new
tab
"
)
;
tab
=
yield
BrowserTestUtils
.
openNewForegroundTab
(
tabbrowser
)
}
else
{
info
(
"
Using
the
selected
tab
"
)
;
tab
=
tabbrowser
.
selectedTab
;
}
let
browser
=
tab
.
linkedBrowser
;
let
remotenessState
=
scenario
.
initialRemoteness
[
i
]
;
tabbrowser
.
updateBrowserRemoteness
(
browser
remotenessState
)
;
}
let
tabToSelect
=
tabbrowser
.
tabs
[
scenario
.
initialSelectedTab
-
1
]
;
if
(
tabbrowser
.
selectedTab
!
=
tabToSelect
)
{
yield
BrowserTestUtils
.
switchTab
(
tabbrowser
tabToSelect
)
;
}
let
flipListener
=
{
seenBeforeTabs
:
new
Set
(
)
seenAfterTabs
:
new
Set
(
)
handleEvent
(
e
)
{
let
index
=
Array
.
from
(
tabbrowser
.
tabs
)
.
indexOf
(
e
.
target
)
;
switch
(
e
.
type
)
{
case
"
BeforeTabRemotenessChange
"
:
info
(
Saw
tab
at
index
{
index
}
before
remoteness
flip
)
;
if
(
this
.
seenBeforeTabs
.
has
(
e
.
target
)
)
{
Assert
.
ok
(
false
"
Saw
tab
before
remoteness
flip
more
than
once
"
)
;
}
this
.
seenBeforeTabs
.
add
(
e
.
target
)
;
break
;
case
"
TabRemotenessChange
"
:
info
(
Saw
tab
at
index
{
index
}
after
remoteness
flip
)
;
if
(
this
.
seenAfterTabs
.
has
(
e
.
target
)
)
{
Assert
.
ok
(
false
"
Saw
tab
after
remoteness
flip
more
than
once
"
)
;
}
this
.
seenAfterTabs
.
add
(
e
.
target
)
;
break
;
}
}
}
;
win
.
addEventListener
(
"
BeforeTabRemotenessChange
"
flipListener
)
;
win
.
addEventListener
(
"
TabRemotenessChange
"
flipListener
)
;
let
state
=
prepareState
(
scenario
.
stateToRestore
scenario
.
selectedTab
)
;
SessionStore
.
setWindowState
(
win
state
true
)
;
win
.
removeEventListener
(
"
BeforeTabRemotenessChange
"
flipListener
)
;
win
.
removeEventListener
(
"
TabRemotenessChange
"
flipListener
)
;
for
(
let
i
=
0
;
i
<
scenario
.
expectedFlips
.
length
;
+
+
i
)
{
let
expectedToFlip
=
scenario
.
expectedFlips
[
i
]
;
let
expectedRemoteness
=
scenario
.
expectedRemoteness
[
i
]
;
let
tab
=
tabbrowser
.
tabs
[
i
]
;
if
(
expectedToFlip
)
{
Assert
.
ok
(
flipListener
.
seenBeforeTabs
.
has
(
tab
)
We
should
have
seen
tab
at
index
{
i
}
before
remoteness
flip
)
;
Assert
.
ok
(
flipListener
.
seenAfterTabs
.
has
(
tab
)
We
should
have
seen
tab
at
index
{
i
}
after
remoteness
flip
)
;
}
else
{
Assert
.
ok
(
!
flipListener
.
seenBeforeTabs
.
has
(
tab
)
We
should
not
have
seen
tab
at
index
{
i
}
before
remoteness
flip
)
;
Assert
.
ok
(
!
flipListener
.
seenAfterTabs
.
has
(
tab
)
We
should
not
have
seen
tab
at
index
{
i
}
after
remoteness
flip
)
;
}
Assert
.
equal
(
tab
.
linkedBrowser
.
isRemoteBrowser
expectedRemoteness
"
Should
have
gotten
the
expected
remoteness
"
+
for
the
tab
at
index
{
i
}
)
;
}
yield
BrowserTestUtils
.
closeWindow
(
win
)
;
}
}
add_task
(
function
*
(
)
{
requestLongerTimeout
(
5
)
;
yield
SpecialPowers
.
pushPrefEnv
(
{
"
set
"
:
[
[
"
browser
.
sessionstore
.
restore_on_demand
"
true
]
]
}
)
;
const
TEST_SCENARIOS
=
[
{
initialRemoteness
:
[
true
]
initialSelectedTab
:
1
stateToRestore
:
SIMPLE_STATE
selectedTab
:
3
expectedFlips
:
[
true
false
true
]
expectedRemoteness
:
[
false
false
true
]
}
{
initialRemoteness
:
[
true
]
initialSelectedTab
:
1
stateToRestore
:
SIMPLE_STATE
selectedTab
:
1
expectedFlips
:
[
false
false
false
]
expectedRemoteness
:
[
true
false
false
]
}
{
initialRemoteness
:
[
true
]
initialSelectedTab
:
1
stateToRestore
:
SIMPLE_STATE
selectedTab
:
0
expectedFlips
:
[
false
false
false
]
expectedRemoteness
:
[
true
false
false
]
}
{
initialRemoteness
:
[
true
]
initialSelectedTab
:
1
stateToRestore
:
PINNED_STATE
selectedTab
:
3
expectedFlips
:
[
false
false
true
]
expectedRemoteness
:
[
true
true
true
]
}
{
initialRemoteness
:
[
false
]
initialSelectedTab
:
1
stateToRestore
:
SIMPLE_STATE
selectedTab
:
2
expectedFlips
:
[
false
true
false
]
expectedRemoteness
:
[
false
true
false
]
}
{
initialRemoteness
:
[
true
false
true
]
initialSelectedTab
:
1
stateToRestore
:
SIMPLE_STATE
selectedTab
:
3
expectedFlips
:
[
true
false
false
]
expectedRemoteness
:
[
false
false
true
]
}
{
initialRemoteness
:
[
false
]
initialSelectedTab
:
1
stateToRestore
:
PINNED_STATE
selectedTab
:
3
expectedFlips
:
[
true
false
true
]
expectedRemoteness
:
[
true
true
true
]
}
]
;
yield
*
runScenarios
(
TEST_SCENARIOS
)
;
}
)
;
