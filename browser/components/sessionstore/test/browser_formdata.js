"
use
strict
"
;
requestLongerTimeout
(
2
)
;
add_task
(
async
function
test_formdata
(
)
{
const
URL
=
"
http
:
/
/
mochi
.
test
:
8888
/
browser
/
browser
/
components
/
"
+
"
sessionstore
/
test
/
browser_formdata_sample
.
html
"
;
const
OUTER_VALUE
=
"
browser_formdata_
"
+
Math
.
random
(
)
;
const
INNER_VALUE
=
"
browser_formdata_
"
+
Math
.
random
(
)
;
async
function
createAndRemoveTab
(
)
{
let
tab
=
BrowserTestUtils
.
addTab
(
gBrowser
URL
)
;
let
browser
=
tab
.
linkedBrowser
;
await
promiseBrowserLoaded
(
browser
)
;
await
setPropertyOfFormField
(
browser
"
#
txt
"
"
value
"
OUTER_VALUE
)
;
await
setPropertyOfFormField
(
browser
.
browsingContext
.
children
[
0
]
"
#
txt
"
"
value
"
INNER_VALUE
)
;
await
promiseRemoveTabAndSessionState
(
tab
)
;
}
await
createAndRemoveTab
(
)
;
let
[
{
state
:
{
formdata
}
}
]
=
ss
.
getClosedTabData
(
window
)
;
is
(
formdata
.
id
.
txt
OUTER_VALUE
"
outer
value
is
correct
"
)
;
is
(
formdata
.
children
[
0
]
.
id
.
txt
INNER_VALUE
"
inner
value
is
correct
"
)
;
Services
.
prefs
.
setIntPref
(
"
browser
.
sessionstore
.
privacy_level
"
1
)
;
await
createAndRemoveTab
(
)
;
[
{
state
:
{
formdata
}
}
]
=
ss
.
getClosedTabData
(
window
)
;
is
(
formdata
.
id
.
txt
OUTER_VALUE
"
outer
value
is
correct
"
)
;
ok
(
!
formdata
.
children
"
inner
value
was
*
not
*
stored
"
)
;
Services
.
prefs
.
setIntPref
(
"
browser
.
sessionstore
.
privacy_level
"
2
)
;
await
createAndRemoveTab
(
)
;
[
{
state
:
{
formdata
}
}
]
=
ss
.
getClosedTabData
(
window
)
;
ok
(
!
formdata
"
form
data
has
*
not
*
been
stored
"
)
;
Services
.
prefs
.
clearUserPref
(
"
browser
.
sessionstore
.
privacy_level
"
)
;
}
)
;
add_task
(
async
function
test_url_check
(
)
{
const
URL
=
"
data
:
text
/
html
;
charset
=
utf
-
8
<
input
id
=
input
>
"
;
const
VALUE
=
"
value
-
"
+
Math
.
random
(
)
;
let
tab
=
BrowserTestUtils
.
addTab
(
gBrowser
URL
)
;
let
browser
=
tab
.
linkedBrowser
;
await
promiseBrowserLoaded
(
browser
)
;
async
function
restoreStateWithURL
(
url
)
{
let
state
=
{
entries
:
[
{
url
:
URL
triggeringPrincipal_base64
}
]
formdata
:
{
id
:
{
input
:
VALUE
}
}
}
;
if
(
url
)
{
state
.
formdata
.
url
=
url
;
}
await
promiseTabState
(
tab
state
)
;
return
getPropertyOfFormField
(
browser
"
#
input
"
"
value
"
)
;
}
is
(
await
restoreStateWithURL
(
URL
)
VALUE
"
form
data
restored
"
)
;
is
(
await
restoreStateWithURL
(
URL
+
"
?
"
)
"
"
"
form
data
not
restored
"
)
;
is
(
await
restoreStateWithURL
(
)
"
"
"
form
data
not
restored
"
)
;
gBrowser
.
removeTab
(
tab
)
;
}
)
;
add_task
(
async
function
test_nested
(
)
{
const
URL
=
"
data
:
text
/
html
;
charset
=
utf
-
8
"
+
"
<
iframe
src
=
'
data
:
text
/
html
;
charset
=
utf
-
8
<
input
/
>
'
/
>
"
;
const
FORM_DATA
=
{
children
:
[
{
url
:
"
data
:
text
/
html
;
charset
=
utf
-
8
<
input
/
>
"
xpath
:
{
"
/
xhtml
:
html
/
xhtml
:
body
/
xhtml
:
input
"
:
"
m
"
}
}
]
}
;
let
tab
=
(
gBrowser
.
selectedTab
=
BrowserTestUtils
.
addTab
(
gBrowser
URL
)
)
;
let
browser
=
tab
.
linkedBrowser
;
await
promiseBrowserLoaded
(
browser
false
)
;
const
iframe
=
await
SpecialPowers
.
spawn
(
browser
[
]
(
)
=
>
{
return
content
.
document
.
querySelector
(
"
iframe
"
)
.
browsingContext
;
}
)
;
await
SpecialPowers
.
spawn
(
iframe
[
]
async
(
)
=
>
{
const
input
=
content
.
document
.
querySelector
(
"
input
"
)
;
const
focusPromise
=
new
Promise
(
resolve
=
>
{
input
.
addEventListener
(
"
focus
"
resolve
{
once
:
true
}
)
;
}
)
;
input
.
focus
(
)
;
await
focusPromise
;
}
)
;
await
BrowserTestUtils
.
synthesizeKey
(
"
m
"
{
}
browser
)
;
await
promiseRemoveTabAndSessionState
(
tab
)
;
let
[
{
state
:
{
formdata
}
}
]
=
ss
.
getClosedTabData
(
window
)
;
is
(
JSON
.
stringify
(
formdata
)
JSON
.
stringify
(
FORM_DATA
)
"
formdata
for
iframe
stored
correctly
"
)
;
tab
=
ss
.
undoCloseTab
(
window
0
)
;
browser
=
tab
.
linkedBrowser
;
await
promiseTabRestored
(
tab
)
;
await
TabStateFlusher
.
flush
(
browser
)
;
(
{
formdata
}
=
JSON
.
parse
(
ss
.
getTabState
(
tab
)
)
)
;
is
(
JSON
.
stringify
(
formdata
)
JSON
.
stringify
(
FORM_DATA
)
"
formdata
for
iframe
restored
correctly
"
)
;
gBrowser
.
removeTab
(
tab
)
;
}
)
;
add_task
(
async
function
test_design_mode
(
)
{
const
URL
=
"
data
:
text
/
html
;
charset
=
utf
-
8
<
h1
>
mozilla
<
/
h1
>
"
+
"
<
script
>
document
.
designMode
=
'
on
'
<
/
script
>
"
;
let
tab
=
(
gBrowser
.
selectedTab
=
BrowserTestUtils
.
addTab
(
gBrowser
URL
)
)
;
let
browser
=
tab
.
linkedBrowser
;
await
promiseBrowserLoaded
(
browser
)
;
await
BrowserTestUtils
.
synthesizeKey
(
"
m
"
{
}
browser
)
;
await
promiseRemoveTabAndSessionState
(
tab
)
;
tab
=
ss
.
undoCloseTab
(
window
0
)
;
browser
=
tab
.
linkedBrowser
;
await
promiseTabRestored
(
tab
)
;
let
html
=
await
getPropertyOfFormField
(
browser
"
body
"
"
innerHTML
"
)
;
let
expected
=
"
<
h1
>
mmozilla
<
/
h1
>
<
script
>
document
.
designMode
=
'
on
'
<
/
script
>
"
;
is
(
html
expected
"
editable
document
has
been
restored
correctly
"
)
;
await
promiseRemoveTabAndSessionState
(
tab
)
;
tab
=
ss
.
undoCloseTab
(
window
0
)
;
browser
=
tab
.
linkedBrowser
;
await
promiseTabRestored
(
tab
)
;
html
=
await
getPropertyOfFormField
(
browser
"
body
"
"
innerHTML
"
)
;
expected
=
"
<
h1
>
mmozilla
<
/
h1
>
<
script
>
document
.
designMode
=
'
on
'
<
/
script
>
"
;
is
(
html
expected
"
editable
document
has
been
restored
correctly
"
)
;
gBrowser
.
removeTab
(
tab
)
;
}
)
;
