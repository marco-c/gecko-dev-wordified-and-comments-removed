"
use
strict
"
;
const
TAB_STATE
=
{
entries
:
[
{
url
:
"
about
:
mozilla
"
triggeringPrincipal_base64
}
{
url
:
"
about
:
robots
"
triggeringPrincipal_base64
}
]
index
:
1
}
;
function
checkTabContents
(
browser
)
{
return
SpecialPowers
.
spawn
(
browser
[
]
async
function
(
)
{
let
webNavigation
=
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
;
let
history
=
webNavigation
.
sessionHistory
;
Assert
.
ok
(
history
&
&
history
.
count
=
=
1
&
&
content
.
document
.
documentURI
=
=
"
about
:
mozilla
"
"
expected
tab
contents
found
"
)
;
}
)
;
}
add_task
(
async
function
(
)
{
let
tab
=
BrowserTestUtils
.
addTab
(
gBrowser
"
about
:
blank
"
)
;
let
browser
=
tab
.
linkedBrowser
;
await
BrowserTestUtils
.
browserLoaded
(
browser
{
wantLoad
:
"
about
:
blank
"
}
)
;
await
promiseTabState
(
tab
TAB_STATE
)
;
let
tab2
=
BrowserTestUtils
.
addTab
(
gBrowser
"
about
:
blank
"
)
;
let
browser2
=
tab2
.
linkedBrowser
;
await
BrowserTestUtils
.
browserLoaded
(
browser2
{
wantLoad
:
"
about
:
blank
"
}
)
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
sessionstore
.
restore_on_demand
"
true
)
;
let
promise
=
promiseTabRestoring
(
tab2
)
;
ss
.
setTabState
(
tab2
JSON
.
stringify
(
TAB_STATE
)
)
;
ok
(
tab2
.
hasAttribute
(
"
pending
"
)
"
tab
is
pending
"
)
;
await
promise
;
Services
.
obs
.
notifyObservers
(
null
"
browser
:
purge
-
session
-
history
"
)
;
await
checkTabContents
(
browser
)
;
ok
(
tab2
.
hasAttribute
(
"
pending
"
)
"
tab
is
still
pending
"
)
;
gBrowser
.
selectedTab
=
tab2
;
await
promiseTabRestored
(
tab2
)
;
await
checkTabContents
(
browser2
)
;
ok
(
!
tab2
.
hasAttribute
(
"
pending
"
)
"
tab
is
not
pending
anymore
"
)
;
gBrowser
.
removeTab
(
tab2
)
;
gBrowser
.
removeTab
(
tab
)
;
}
)
;
