const
{
Services
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
{
}
)
;
const
HISTOGRAM_NAME
=
"
FX_SESSION_RESTORE_SEND_UPDATE_CAUSED_OOM
"
;
add_task
(
function
*
init
(
)
{
Services
.
telemetry
.
canRecordExtended
=
true
;
}
)
;
function
frameScript
(
)
{
let
mm
=
docShell
.
sameTypeRootTreeItem
.
QueryInterface
(
Ci
.
nsIDocShell
)
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIContentFrameMessageManager
)
;
let
wrap
=
function
(
original
)
{
return
function
(
name
.
.
.
args
)
{
if
(
name
!
=
"
SessionStore
:
update
"
)
{
return
original
(
name
.
.
.
args
)
;
}
throw
new
Components
.
Exception
(
"
Simulated
OOM
"
Cr
.
NS_ERROR_OUT_OF_MEMORY
)
;
}
}
mm
.
sendAsyncMessage
=
wrap
(
mm
.
sendAsyncMessage
)
;
mm
.
sendSyncMessage
=
wrap
(
mm
.
sendSyncMessage
)
;
}
add_task
(
function
*
(
)
{
let
snapshot
=
Services
.
telemetry
.
getHistogramById
(
HISTOGRAM_NAME
)
.
snapshot
(
)
;
let
newTab
=
gBrowser
.
addTab
(
"
about
:
robots
"
)
;
let
browser
=
newTab
.
linkedBrowser
;
yield
ContentTask
.
spawn
(
browser
null
frameScript
)
;
let
promiseReported
=
new
Promise
(
resolve
=
>
{
browser
.
messageManager
.
addMessageListener
(
"
SessionStore
:
error
"
resolve
)
;
}
)
;
let
promiseFlushed
=
TabStateFlusher
.
flush
(
browser
)
;
promiseFlushed
.
then
(
(
)
=
>
{
throw
new
Error
(
"
Flush
should
have
failed
"
)
}
)
;
yield
promiseReported
;
yield
new
Promise
(
resolve
=
>
setTimeout
(
resolve
10
)
)
;
let
snapshot2
=
Services
.
telemetry
.
getHistogramById
(
HISTOGRAM_NAME
)
.
snapshot
(
)
;
gBrowser
.
removeTab
(
newTab
)
;
Assert
.
ok
(
snapshot2
.
sum
>
snapshot
.
sum
)
;
}
)
;
add_task
(
function
*
cleanup
(
)
{
Services
.
telemetry
.
canRecordExtended
=
false
;
}
)
;
