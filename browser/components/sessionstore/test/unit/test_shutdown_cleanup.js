"
use
strict
"
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
SessionWorker
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
/
modules
/
sessionstore
/
SessionWorker
.
jsm
"
)
;
const
profd
=
do_get_profile
(
)
;
const
{
SessionFile
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
/
modules
/
sessionstore
/
SessionFile
.
jsm
"
)
;
const
{
Paths
}
=
SessionFile
;
const
{
File
}
=
OS
;
const
MAX_ENTRIES
=
9
;
const
URL
=
"
http
:
/
/
example
.
com
/
#
"
;
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
AppInfo
.
jsm
"
this
)
;
updateAppInfo
(
{
name
:
"
SessionRestoreTest
"
ID
:
"
{
230de50e
-
4cd1
-
11dc
-
8314
-
0800200c9a66
}
"
version
:
"
1
"
platformVersion
:
"
"
}
)
;
var
gSourceHandle
;
async
function
prepareWithLimit
(
back
fwd
)
{
await
SessionFile
.
wipe
(
)
;
if
(
!
gSourceHandle
)
{
gSourceHandle
=
do_get_file
(
"
data
/
sessionstore_valid
.
js
"
)
;
}
gSourceHandle
.
copyTo
(
profd
"
sessionstore
.
js
"
)
;
await
writeCompressedFile
(
Paths
.
clean
.
replace
(
"
jsonlz4
"
"
js
"
)
Paths
.
clean
)
;
Services
.
prefs
.
setIntPref
(
"
browser
.
sessionstore
.
max_serialize_back
"
back
)
;
Services
.
prefs
.
setIntPref
(
"
browser
.
sessionstore
.
max_serialize_forward
"
fwd
)
;
await
SessionFile
.
read
(
)
;
}
add_task
(
async
function
setup
(
)
{
await
SessionFile
.
read
(
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
"
browser
.
sessionstore
.
max_serialize_back
"
)
;
Services
.
prefs
.
clearUserPref
(
"
browser
.
sessionstore
.
max_serialize_forward
"
)
;
}
)
;
}
)
;
function
createSessionState
(
index
)
{
let
tabState
=
{
entries
:
[
]
index
}
;
for
(
let
i
=
0
;
i
<
MAX_ENTRIES
;
i
+
+
)
{
tabState
.
entries
.
push
(
{
url
:
URL
+
i
}
)
;
}
return
{
windows
:
[
{
tabs
:
[
tabState
]
}
]
}
;
}
async
function
writeAndParse
(
state
path
options
=
{
}
)
{
await
SessionWorker
.
post
(
"
write
"
[
state
options
]
)
;
return
JSON
.
parse
(
await
File
.
read
(
path
{
encoding
:
"
utf
-
8
"
compression
:
"
lz4
"
}
)
)
;
}
add_task
(
async
function
test_shistory_cap_none
(
)
{
let
state
=
createSessionState
(
5
)
;
await
prepareWithLimit
(
-
1
-
1
)
;
let
diskState
=
await
writeAndParse
(
state
Paths
.
clean
{
isFinalWrite
:
true
}
)
;
Assert
.
deepEqual
(
state
diskState
"
no
cap
applied
"
)
;
}
)
;
add_task
(
async
function
test_shistory_cap_middle
(
)
{
let
state
=
createSessionState
(
5
)
;
await
prepareWithLimit
(
2
3
)
;
let
diskState
=
await
writeAndParse
(
state
Paths
.
recovery
)
;
Assert
.
deepEqual
(
state
diskState
"
no
cap
applied
"
)
;
diskState
=
await
writeAndParse
(
state
Paths
.
clean
{
isFinalWrite
:
true
}
)
;
let
tabState
=
state
.
windows
[
0
]
.
tabs
[
0
]
;
tabState
.
entries
=
tabState
.
entries
.
slice
(
2
8
)
;
tabState
.
index
=
3
;
Assert
.
deepEqual
(
state
diskState
"
cap
applied
"
)
;
}
)
;
add_task
(
async
function
test_shistory_cap_lower_bound
(
)
{
let
state
=
createSessionState
(
1
)
;
await
prepareWithLimit
(
5
5
)
;
let
diskState
=
await
writeAndParse
(
state
Paths
.
recovery
)
;
Assert
.
deepEqual
(
state
diskState
"
no
cap
applied
"
)
;
diskState
=
await
writeAndParse
(
state
Paths
.
clean
{
isFinalWrite
:
true
}
)
;
let
tabState
=
state
.
windows
[
0
]
.
tabs
[
0
]
;
tabState
.
entries
=
tabState
.
entries
.
slice
(
0
6
)
;
Assert
.
deepEqual
(
state
diskState
"
cap
applied
"
)
;
}
)
;
add_task
(
async
function
test_shistory_cap_upper_bound
(
)
{
let
state
=
createSessionState
(
MAX_ENTRIES
)
;
await
prepareWithLimit
(
5
5
)
;
let
diskState
=
await
writeAndParse
(
state
Paths
.
recovery
)
;
Assert
.
deepEqual
(
state
diskState
"
no
cap
applied
"
)
;
diskState
=
await
writeAndParse
(
state
Paths
.
clean
{
isFinalWrite
:
true
}
)
;
let
tabState
=
state
.
windows
[
0
]
.
tabs
[
0
]
;
tabState
.
entries
=
tabState
.
entries
.
slice
(
3
)
;
tabState
.
index
=
6
;
Assert
.
deepEqual
(
state
diskState
"
cap
applied
"
)
;
}
)
;
add_task
(
async
function
cleanup
(
)
{
await
SessionFile
.
wipe
(
)
;
await
SessionFile
.
read
(
)
;
}
)
;
