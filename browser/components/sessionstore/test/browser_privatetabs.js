add_task
(
function
cleanup
(
)
{
info
(
"
Forgetting
closed
tabs
"
)
;
while
(
ss
.
getClosedTabCount
(
window
)
)
{
ss
.
forgetClosedTab
(
window
0
)
;
}
}
)
;
add_task
(
async
function
(
)
{
let
URL_PUBLIC
=
"
http
:
/
/
example
.
com
/
public
/
"
+
Math
.
random
(
)
;
let
URL_PRIVATE
=
"
http
:
/
/
example
.
com
/
private
/
"
+
Math
.
random
(
)
;
let
tab1
tab2
;
try
{
info
(
"
Setting
up
public
tab
"
)
;
tab1
=
BrowserTestUtils
.
addTab
(
gBrowser
URL_PUBLIC
)
;
await
promiseBrowserLoaded
(
tab1
.
linkedBrowser
)
;
info
(
"
Setting
up
private
tab
"
)
;
tab2
=
BrowserTestUtils
.
addTab
(
gBrowser
)
;
await
promiseBrowserLoaded
(
tab2
.
linkedBrowser
)
;
await
setUsePrivateBrowsing
(
tab2
.
linkedBrowser
true
)
;
BrowserTestUtils
.
loadURI
(
tab2
.
linkedBrowser
URL_PRIVATE
)
;
await
promiseBrowserLoaded
(
tab2
.
linkedBrowser
)
;
info
(
"
Flush
to
make
sure
chrome
received
all
data
.
"
)
;
await
TabStateFlusher
.
flush
(
tab1
.
linkedBrowser
)
;
await
TabStateFlusher
.
flush
(
tab2
.
linkedBrowser
)
;
info
(
"
Checking
out
state
"
)
;
let
state
=
await
promiseRecoveryFileContents
(
)
;
info
(
"
State
:
"
+
state
)
;
ok
(
state
.
includes
(
URL_PUBLIC
)
"
State
contains
public
tab
"
)
;
ok
(
!
state
.
includes
(
URL_PRIVATE
)
"
State
does
not
contain
private
tab
"
)
;
gBrowser
.
removeTab
(
tab2
)
;
tab2
=
null
;
gBrowser
.
removeTab
(
tab1
)
;
tab1
=
null
;
tab1
=
ss
.
undoCloseTab
(
window
0
)
;
ok
(
true
"
Public
tab
supports
undo
close
"
)
;
is
(
ss
.
getClosedTabCount
(
window
)
0
"
Private
tab
does
not
support
undo
close
"
)
;
}
finally
{
if
(
tab1
)
{
gBrowser
.
removeTab
(
tab1
)
;
}
if
(
tab2
)
{
gBrowser
.
removeTab
(
tab2
)
;
}
}
}
)
;
add_task
(
async
function
(
)
{
const
FRAME_SCRIPT
=
"
data
:
"
+
"
docShell
.
QueryInterface
%
28Components
.
interfaces
.
nsILoadContext
%
29
.
usePrivateBrowsing
%
3Dtrue
"
;
forgetClosedWindows
(
)
;
let
win
=
await
promiseNewWindowLoaded
(
)
;
let
mm
=
win
.
getGroupMessageManager
(
"
browsers
"
)
;
mm
.
loadFrameScript
(
FRAME_SCRIPT
true
)
;
let
tab
=
BrowserTestUtils
.
addTab
(
win
.
gBrowser
"
about
:
mozilla
"
)
;
let
browser
=
tab
.
linkedBrowser
;
await
promiseBrowserLoaded
(
browser
)
;
await
TabStateFlusher
.
flush
(
browser
)
;
let
state
=
JSON
.
parse
(
ss
.
getTabState
(
tab
)
)
;
ok
(
state
.
isPrivate
"
tab
considered
private
"
)
;
win
.
gBrowser
.
removeTab
(
tab
)
;
is
(
ss
.
getClosedTabCount
(
win
)
0
"
no
tabs
to
restore
"
)
;
tab
=
BrowserTestUtils
.
addTab
(
win
.
gBrowser
"
about
:
mozilla
"
)
;
browser
=
tab
.
linkedBrowser
;
await
promiseBrowserLoaded
(
browser
)
;
await
TabStateFlusher
.
flush
(
browser
)
;
state
=
JSON
.
parse
(
ss
.
getTabState
(
tab
)
)
;
ok
(
state
.
isPrivate
"
tab
considered
private
"
)
;
await
BrowserTestUtils
.
closeWindow
(
win
)
;
is
(
ss
.
getClosedWindowCount
(
)
0
"
no
windows
to
restore
"
)
;
}
)
;
add_task
(
async
function
(
)
{
forgetClosedWindows
(
)
;
let
win
=
await
promiseNewWindowLoaded
(
{
private
:
true
}
)
;
let
tab
=
BrowserTestUtils
.
addTab
(
win
.
gBrowser
"
about
:
mozilla
"
)
;
let
browser
=
tab
.
linkedBrowser
;
await
promiseBrowserLoaded
(
browser
)
;
await
TabStateFlusher
.
flush
(
browser
)
;
let
state
=
JSON
.
parse
(
ss
.
getTabState
(
tab
)
)
;
ok
(
state
.
isPrivate
"
tab
considered
private
"
)
;
win
.
gBrowser
.
removeTab
(
tab
)
;
is
(
ss
.
getClosedTabCount
(
win
)
1
"
there
is
a
single
tab
to
restore
"
)
;
await
BrowserTestUtils
.
closeWindow
(
win
)
;
is
(
ss
.
getClosedWindowCount
(
)
0
"
no
windows
to
restore
"
)
;
}
)
;
function
setUsePrivateBrowsing
(
browser
val
)
{
return
sendMessage
(
browser
"
ss
-
test
:
setUsePrivateBrowsing
"
val
)
;
}
