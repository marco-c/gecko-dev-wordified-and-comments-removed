"
use
strict
"
;
ChromeUtils
.
defineModuleGetter
(
this
"
TelemetryTestUtils
"
"
resource
:
/
/
testing
-
common
/
TelemetryTestUtils
.
jsm
"
)
;
const
TABUI_PRESENTED_KEY
=
"
dom
.
contentprocess
.
crash_tab_ui_presented
"
;
async
function
setupBackgroundTabs
(
testFn
)
{
const
REMOTE_PAGE
=
"
http
:
/
/
www
.
example
.
com
"
;
const
NON_REMOTE_PAGE
=
"
about
:
robots
"
;
let
initialTab
=
gBrowser
.
selectedTab
;
let
initialBrowser
=
initialTab
.
linkedBrowser
;
BrowserTestUtils
.
loadURI
(
initialBrowser
NON_REMOTE_PAGE
)
;
await
BrowserTestUtils
.
browserLoaded
(
initialBrowser
)
;
let
tab1
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
REMOTE_PAGE
)
;
let
remoteBrowser1
=
tab1
.
linkedBrowser
;
await
TabStateFlusher
.
flush
(
remoteBrowser1
)
;
let
tab2
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
REMOTE_PAGE
)
;
let
remoteBrowser2
=
tab2
.
linkedBrowser
;
await
TabStateFlusher
.
flush
(
remoteBrowser2
)
;
Assert
.
ok
(
remoteBrowser1
.
isRemoteBrowser
"
Browser
should
be
remote
in
order
to
crash
.
"
)
;
Assert
.
ok
(
remoteBrowser2
.
isRemoteBrowser
"
Browser
should
be
remote
in
order
to
crash
.
"
)
;
Assert
.
equal
(
remoteBrowser1
.
frameLoader
.
childID
remoteBrowser2
.
frameLoader
.
childID
"
Both
remote
browsers
should
share
the
same
content
process
.
"
)
;
await
BrowserTestUtils
.
switchTab
(
gBrowser
initialTab
)
;
await
testFn
(
[
tab1
tab2
]
)
;
BrowserTestUtils
.
removeTab
(
tab1
)
;
BrowserTestUtils
.
removeTab
(
tab2
)
;
}
async
function
crashBackgroundTabs
(
tabs
)
{
Assert
.
ok
(
!
!
tabs
.
length
"
Need
to
crash
at
least
one
tab
.
"
)
;
for
(
let
tab
of
tabs
)
{
Assert
.
ok
(
tab
.
linkedBrowser
.
isRemoteBrowser
"
tab
is
remote
"
)
;
}
let
remotenessChangePromises
=
tabs
.
map
(
t
=
>
{
return
BrowserTestUtils
.
waitForEvent
(
t
"
TabRemotenessChange
"
)
;
}
)
;
let
tabsRevived
=
tabs
.
map
(
t
=
>
{
return
promiseTabRestoring
(
t
)
;
}
)
;
await
BrowserTestUtils
.
crashFrame
(
tabs
[
0
]
.
linkedBrowser
false
)
;
await
Promise
.
all
(
remotenessChangePromises
)
;
await
Promise
.
all
(
tabsRevived
)
;
for
(
let
tab
of
tabs
)
{
Assert
.
ok
(
!
tab
.
linkedBrowser
.
isRemoteBrowser
"
tab
is
not
remote
"
)
;
Assert
.
ok
(
!
tab
.
linkedBrowser
.
hasAttribute
(
"
crashed
"
)
"
tab
is
not
crashed
"
)
;
Assert
.
ok
(
tab
.
hasAttribute
(
"
pending
"
)
"
tab
is
pending
"
)
;
}
}
function
checkTelemetry
(
expectedCount
desc
)
{
const
scalars
=
TelemetryTestUtils
.
getProcessScalars
(
"
parent
"
)
;
if
(
expectedCount
=
=
=
0
)
{
TelemetryTestUtils
.
assertScalarUnset
(
scalars
TABUI_PRESENTED_KEY
)
;
return
;
}
TelemetryTestUtils
.
assertScalar
(
scalars
TABUI_PRESENTED_KEY
expectedCount
desc
+
"
telemetry
"
)
;
}
add_task
(
async
function
setup
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
dom
.
ipc
.
processCount
"
1
]
[
"
dom
.
ipc
.
processCount
.
webIsolated
"
1
]
]
}
)
;
requestLongerTimeout
(
5
)
;
}
)
;
add_task
(
async
function
test_background_crash_simple
(
)
{
Services
.
telemetry
.
clearScalars
(
)
;
await
setupBackgroundTabs
(
async
function
(
[
tab1
tab2
]
)
{
await
crashBackgroundTabs
(
[
tab1
tab2
]
)
;
checkTelemetry
(
0
"
simple
crash
initial
value
"
)
;
let
tabCrashedPagePromise
=
BrowserTestUtils
.
waitForContentEvent
(
tab1
.
linkedBrowser
"
AboutTabCrashedReady
"
false
null
true
)
;
await
BrowserTestUtils
.
switchTab
(
gBrowser
tab1
)
;
await
tabCrashedPagePromise
;
checkTelemetry
(
1
"
simple
crash
after
tab
switch
"
)
;
let
tabRestored
=
promiseTabRestored
(
tab2
)
;
await
BrowserTestUtils
.
switchTab
(
gBrowser
tab2
)
;
await
tabRestored
;
checkTelemetry
(
1
"
simple
crash
after
tab
switch
"
)
;
}
)
;
}
)
;
add_task
(
async
function
test_background_crash_autosubmit_backlogged
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
crashReports
.
unsubmittedCheck
.
autoSubmit2
"
true
]
]
}
)
;
Services
.
telemetry
.
clearScalars
(
)
;
await
setupBackgroundTabs
(
async
function
(
[
tab1
tab2
]
)
{
await
crashBackgroundTabs
(
[
tab1
tab2
]
)
;
let
tabRestored
=
promiseTabRestored
(
tab1
)
;
await
BrowserTestUtils
.
switchTab
(
gBrowser
tab1
)
;
await
tabRestored
;
tabRestored
=
promiseTabRestored
(
tab2
)
;
await
BrowserTestUtils
.
switchTab
(
gBrowser
tab2
)
;
await
tabRestored
;
}
)
;
checkTelemetry
(
0
"
crash
with
autosubmit
"
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
)
;
add_task
(
async
function
test_background_crash_multiple
(
)
{
Services
.
telemetry
.
clearScalars
(
)
;
let
initialTab
=
gBrowser
.
selectedTab
;
await
setupBackgroundTabs
(
async
function
(
[
tab1
tab2
]
)
{
await
crashBackgroundTabs
(
[
tab1
tab2
]
)
;
let
tabCrashedPagePromise
=
BrowserTestUtils
.
waitForContentEvent
(
tab1
.
linkedBrowser
"
AboutTabCrashedReady
"
false
null
true
)
;
await
BrowserTestUtils
.
switchTab
(
gBrowser
tab1
)
;
await
tabCrashedPagePromise
;
checkTelemetry
(
1
"
multiple
crash
after
first
tab
select
"
)
;
await
BrowserTestUtils
.
switchTab
(
gBrowser
initialTab
)
;
checkTelemetry
(
1
"
multiple
crash
after
original
tab
select
"
)
;
await
setupBackgroundTabs
(
async
function
(
[
tab3
tab4
]
)
{
await
crashBackgroundTabs
(
[
tab3
tab4
]
)
;
checkTelemetry
(
1
"
multiple
crash
after
second
crash
"
)
;
let
tabRestored
=
promiseTabRestored
(
tab2
)
;
await
BrowserTestUtils
.
switchTab
(
gBrowser
tab2
)
;
await
tabRestored
;
checkTelemetry
(
1
"
multiple
crash
after
second
crash
and
tab
select
"
)
;
tabCrashedPagePromise
=
BrowserTestUtils
.
waitForContentEvent
(
tab4
.
linkedBrowser
"
AboutTabCrashedReady
"
false
null
true
)
;
await
BrowserTestUtils
.
switchTab
(
gBrowser
tab4
)
;
await
tabCrashedPagePromise
;
checkTelemetry
(
2
"
multiple
crash
after
second
crash
and
third
tab
select
"
)
;
tabRestored
=
promiseTabRestored
(
tab3
)
;
await
BrowserTestUtils
.
switchTab
(
gBrowser
tab3
)
;
await
tabRestored
;
checkTelemetry
(
2
"
multiple
crash
after
second
crash
and
fourth
tab
select
"
)
;
}
)
;
}
)
;
}
)
;
add_task
(
async
function
test_preload_crash
(
)
{
Services
.
telemetry
.
clearScalars
(
)
;
if
(
!
Services
.
prefs
.
getBoolPref
(
"
browser
.
newtab
.
preload
"
)
)
{
return
;
}
NewTabPagePreloading
.
removePreloadedBrowser
(
window
)
;
checkTelemetry
(
0
"
preloaded
close
"
)
;
await
BrowserTestUtils
.
maybeCreatePreloadedBrowser
(
gBrowser
)
;
await
BrowserTestUtils
.
crashFrame
(
gBrowser
.
preloadedBrowser
false
)
;
checkTelemetry
(
0
"
preloaded
close
after
crash
"
)
;
Assert
.
ok
(
!
gBrowser
.
preloadedBrowser
)
;
}
)
;
