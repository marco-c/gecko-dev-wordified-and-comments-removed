ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
this
)
;
const
Paths
=
SessionFile
.
Paths
;
const
PREF_UPGRADE
=
"
browser
.
sessionstore
.
upgradeBackup
.
latestBuildID
"
;
const
PREF_MAX_UPGRADE_BACKUPS
=
"
browser
.
sessionstore
.
upgradeBackup
.
maxUpgradeBackups
"
;
function
prepareTest
(
)
{
let
result
=
{
}
;
result
.
buildID
=
Services
.
appinfo
.
platformBuildID
;
Services
.
prefs
.
setCharPref
(
PREF_UPGRADE
"
"
)
;
result
.
contents
=
JSON
.
stringify
(
{
"
browser_upgrade_backup
.
js
"
:
Math
.
random
(
)
}
)
;
return
result
;
}
async
function
getUpgradeBackups
(
)
{
let
iterator
;
let
backups
=
[
]
;
try
{
iterator
=
new
OS
.
File
.
DirectoryIterator
(
Paths
.
backups
)
;
await
iterator
.
forEach
(
function
(
file
)
{
if
(
file
.
path
.
startsWith
(
Paths
.
upgradeBackupPrefix
)
)
{
backups
.
push
(
file
.
path
)
;
}
}
this
)
;
}
finally
{
if
(
iterator
)
{
iterator
.
close
(
)
;
}
}
return
backups
;
}
add_task
(
async
function
init
(
)
{
await
SessionStore
.
promiseInitialized
;
}
)
;
add_task
(
async
function
test_upgrade_backup
(
)
{
let
test
=
prepareTest
(
)
;
info
(
"
Let
'
s
check
if
we
create
an
upgrade
backup
"
)
;
await
SessionFile
.
wipe
(
)
;
await
OS
.
File
.
writeAtomic
(
Paths
.
clean
test
.
contents
{
encoding
:
"
utf
-
8
"
compression
:
"
lz4
"
}
)
;
await
SessionFile
.
read
(
)
;
await
SessionFile
.
write
(
"
"
)
;
is
(
Services
.
prefs
.
getCharPref
(
PREF_UPGRADE
)
test
.
buildID
"
upgrade
backup
should
be
set
"
)
;
is
(
await
OS
.
File
.
exists
(
Paths
.
upgradeBackup
)
true
"
upgrade
backup
file
has
been
created
"
)
;
let
data
=
await
OS
.
File
.
read
(
Paths
.
upgradeBackup
{
compression
:
"
lz4
"
}
)
;
is
(
test
.
contents
new
TextDecoder
(
)
.
decode
(
data
)
"
upgrade
backup
contains
the
expected
contents
"
)
;
info
(
"
Let
'
s
check
that
we
don
'
t
overwrite
this
upgrade
backup
"
)
;
let
newContents
=
JSON
.
stringify
(
{
"
something
else
entirely
"
:
Math
.
random
(
)
}
)
;
await
OS
.
File
.
writeAtomic
(
Paths
.
clean
newContents
{
encoding
:
"
utf
-
8
"
compression
:
"
lz4
"
}
)
;
await
SessionFile
.
read
(
)
;
await
SessionFile
.
write
(
"
"
)
;
data
=
await
OS
.
File
.
read
(
Paths
.
upgradeBackup
{
compression
:
"
lz4
"
}
)
;
is
(
test
.
contents
new
TextDecoder
(
)
.
decode
(
data
)
"
upgrade
backup
hasn
'
t
changed
"
)
;
}
)
;
add_task
(
async
function
test_upgrade_backup_removal
(
)
{
let
test
=
prepareTest
(
)
;
let
maxUpgradeBackups
=
Preferences
.
get
(
PREF_MAX_UPGRADE_BACKUPS
3
)
;
info
(
"
Let
'
s
see
if
we
remove
backups
if
there
are
too
many
"
)
;
await
SessionFile
.
wipe
(
)
;
await
OS
.
File
.
makeDir
(
Paths
.
backups
)
;
await
OS
.
File
.
writeAtomic
(
Paths
.
clean
test
.
contents
{
encoding
:
"
utf
-
8
"
compression
:
"
lz4
"
}
)
;
if
(
OS
.
File
.
exists
(
Paths
.
nextUpgradeBackup
)
)
{
await
OS
.
File
.
remove
(
Paths
.
nextUpgradeBackup
)
;
}
await
OS
.
File
.
writeAtomic
(
Paths
.
upgradeBackupPrefix
+
"
20080101010101
"
"
"
{
encoding
:
"
utf
-
8
"
compression
:
"
lz4
"
}
)
;
await
OS
.
File
.
writeAtomic
(
Paths
.
upgradeBackupPrefix
+
"
20090101010101
"
"
"
{
encoding
:
"
utf
-
8
"
compression
:
"
lz4
"
}
)
;
await
OS
.
File
.
writeAtomic
(
Paths
.
upgradeBackupPrefix
+
"
20100101010101
"
"
"
{
encoding
:
"
utf
-
8
"
compression
:
"
lz4
"
}
)
;
await
OS
.
File
.
writeAtomic
(
Paths
.
upgradeBackupPrefix
+
"
20110101010101
"
"
"
{
encoding
:
"
utf
-
8
"
compression
:
"
lz4
"
}
)
;
await
OS
.
File
.
writeAtomic
(
Paths
.
upgradeBackupPrefix
+
"
20120101010101
"
"
"
{
encoding
:
"
utf
-
8
"
compression
:
"
lz4
"
}
)
;
await
OS
.
File
.
writeAtomic
(
Paths
.
upgradeBackupPrefix
+
"
20130101010101
"
"
"
{
encoding
:
"
utf
-
8
"
compression
:
"
lz4
"
}
)
;
let
backups
=
await
getUpgradeBackups
(
)
;
await
SessionFile
.
read
(
)
;
await
SessionFile
.
write
(
"
"
)
;
is
(
Services
.
prefs
.
getCharPref
(
PREF_UPGRADE
)
test
.
buildID
"
upgrade
backup
should
be
set
"
)
;
is
(
await
OS
.
File
.
exists
(
Paths
.
upgradeBackup
)
true
"
upgrade
backup
file
has
been
created
"
)
;
let
newBackups
=
await
getUpgradeBackups
(
)
;
is
(
newBackups
.
length
maxUpgradeBackups
"
expected
number
of
backups
are
present
after
removing
old
backups
"
)
;
newBackups
=
newBackups
.
filter
(
function
(
backup
)
{
return
!
backups
.
includes
(
backup
)
;
}
)
;
is
(
newBackups
.
length
1
"
one
new
backup
was
created
that
was
not
removed
"
)
;
await
SessionFile
.
write
(
"
"
)
;
backups
=
await
getUpgradeBackups
(
)
;
is
(
backups
.
length
maxUpgradeBackups
"
second
call
to
SessionFile
.
write
(
)
didn
'
t
create
or
remove
more
backups
"
)
;
}
)
;
