"
use
strict
"
;
const
BASE
=
"
http
:
/
/
example
.
com
/
browser
/
browser
/
components
/
sessionstore
/
test
/
"
;
const
READER_MODE_URL
=
"
about
:
reader
?
url
=
"
+
encodeURIComponent
(
BASE
+
"
browser_scrollPositions_readerModeArticle
.
html
"
)
;
const
SCROLL_READER_MODE_Y
=
Math
.
round
(
400
*
(
1
+
Math
.
random
(
)
)
)
;
const
SCROLL_READER_MODE_STR
=
"
0
"
+
SCROLL_READER_MODE_Y
;
requestLongerTimeout
(
2
)
;
add_task
(
async
function
test_scroll_background_about_reader_tabs
(
)
{
pushPrefs
(
[
"
browser
.
sessionstore
.
restore_on_demand
"
true
]
)
;
let
newWin
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
let
tab
=
newWin
.
gBrowser
.
addTab
(
READER_MODE_URL
)
;
let
browser
=
tab
.
linkedBrowser
;
await
Promise
.
all
(
[
BrowserTestUtils
.
browserLoaded
(
browser
)
BrowserTestUtils
.
waitForContentEvent
(
browser
"
AboutReaderContentReady
"
)
]
)
;
await
sendMessage
(
browser
"
ss
-
test
:
setScrollPosition
"
{
x
:
0
y
:
SCROLL_READER_MODE_Y
}
)
;
await
checkScroll
(
tab
{
scroll
:
SCROLL_READER_MODE_STR
}
"
scroll
is
fine
"
)
;
await
BrowserTestUtils
.
closeWindow
(
newWin
)
;
await
forceSaveState
(
)
;
newWin
=
ss
.
undoCloseWindow
(
0
)
;
await
BrowserTestUtils
.
waitForEvent
(
newWin
"
SSWindowStateReady
"
)
;
is
(
newWin
.
gBrowser
.
tabs
.
length
2
"
There
should
be
two
tabs
"
)
;
tab
=
newWin
.
gBrowser
.
tabs
[
1
]
;
ok
(
tab
.
hasAttribute
(
"
pending
"
)
"
Tab
should
be
pending
"
)
;
browser
=
tab
.
linkedBrowser
;
await
TabStateFlusher
.
flush
(
browser
)
;
newWin
.
gBrowser
.
selectedTab
=
tab
;
await
Promise
.
all
(
[
promiseTabRestored
(
tab
)
BrowserTestUtils
.
waitForContentEvent
(
tab
.
linkedBrowser
"
AboutReaderContentReady
"
)
]
)
;
await
checkScroll
(
tab
{
scroll
:
SCROLL_READER_MODE_STR
}
"
scroll
is
still
fine
"
)
;
await
BrowserTestUtils
.
closeWindow
(
newWin
)
;
}
)
;
