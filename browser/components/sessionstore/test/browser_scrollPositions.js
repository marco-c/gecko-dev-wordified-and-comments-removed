"
use
strict
"
;
const
BASE
=
"
http
:
/
/
example
.
com
/
browser
/
browser
/
components
/
sessionstore
/
test
/
"
;
const
URL2
=
BASE
+
"
browser_scrollPositions_sample2
.
html
"
;
const
URL_FRAMESET
=
BASE
+
"
browser_scrollPositions_sample_frameset
.
html
"
;
const
SCROLL_X
=
Math
.
round
(
100
*
(
1
+
Math
.
random
(
)
)
)
;
const
SCROLL_Y
=
Math
.
round
(
200
*
(
1
+
Math
.
random
(
)
)
)
;
const
SCROLL_STR
=
SCROLL_X
+
"
"
+
SCROLL_Y
;
const
SCROLL2_X
=
Math
.
round
(
300
*
(
1
+
Math
.
random
(
)
)
)
;
const
SCROLL2_Y
=
Math
.
round
(
400
*
(
1
+
Math
.
random
(
)
)
)
;
const
SCROLL2_STR
=
SCROLL2_X
+
"
"
+
SCROLL2_Y
;
requestLongerTimeout
(
10
)
;
add_task
(
test_scroll_nested
)
;
if
(
gFissionBrowser
)
{
addCoopTask
(
"
browser_scrollPositions_sample
.
html
"
test_scroll
HTTPSROOT
)
;
}
addNonCoopTask
(
"
browser_scrollPositions_sample
.
html
"
test_scroll
HTTPROOT
)
;
addNonCoopTask
(
"
browser_scrollPositions_sample
.
html
"
test_scroll
HTTPSROOT
)
;
addCoopTask
(
"
browser_scrollPositions_sample
.
html
"
test_scroll_background_tabs
HTTPSROOT
)
;
addNonCoopTask
(
"
browser_scrollPositions_sample
.
html
"
test_scroll_background_tabs
HTTPROOT
)
;
function
getScrollPosition
(
bc
)
{
return
SpecialPowers
.
spawn
(
bc
[
]
(
)
=
>
{
let
x
=
{
}
y
=
{
}
;
content
.
windowUtils
.
getVisualViewportOffset
(
x
y
)
;
return
{
x
:
x
.
value
y
:
y
.
value
}
;
}
)
;
}
async
function
test_scroll
(
aURL
)
{
await
pushPrefs
(
[
"
dom
.
visualviewport
.
enabled
"
true
]
)
;
let
tab
=
BrowserTestUtils
.
addTab
(
gBrowser
aURL
)
;
let
browser
=
tab
.
linkedBrowser
;
await
promiseBrowserLoaded
(
browser
)
;
await
setScrollPosition
(
browser
SCROLL_X
SCROLL_Y
)
;
await
checkScroll
(
tab
{
scroll
:
SCROLL_STR
}
"
scroll
is
fine
"
)
;
let
tab2
=
ss
.
duplicateTab
(
window
tab
)
;
let
browser2
=
tab2
.
linkedBrowser
;
await
promiseTabRestored
(
tab2
)
;
let
scroll
=
await
getScrollPosition
(
browser2
)
;
is
(
JSON
.
stringify
(
scroll
)
JSON
.
stringify
(
{
x
:
SCROLL_X
y
:
SCROLL_Y
}
)
"
scroll
position
has
been
duplicated
correctly
"
)
;
browser2
.
reload
(
)
;
await
promiseBrowserLoaded
(
browser2
)
;
await
checkScroll
(
tab2
{
scroll
:
SCROLL_STR
}
"
reloading
retains
scroll
positions
"
)
;
browser2
.
reloadWithFlags
(
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_BYPASS_CACHE
)
;
await
promiseBrowserLoaded
(
browser2
)
;
await
checkScroll
(
tab2
null
"
force
-
reload
resets
scroll
positions
"
)
;
await
setScrollPosition
(
browser
0
0
)
;
await
checkScroll
(
tab
null
"
no
scroll
stored
"
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
BrowserTestUtils
.
removeTab
(
tab2
)
;
}
async
function
test_scroll_nested
(
)
{
await
pushPrefs
(
[
"
dom
.
visualviewport
.
enabled
"
true
]
)
;
let
tab
=
BrowserTestUtils
.
addTab
(
gBrowser
URL_FRAMESET
)
;
let
browser
=
tab
.
linkedBrowser
;
await
promiseBrowserLoaded
(
browser
)
;
await
setScrollPosition
(
browser
.
browsingContext
.
children
[
0
]
SCROLL_X
SCROLL_Y
)
;
await
checkScroll
(
tab
{
children
:
[
{
scroll
:
SCROLL_STR
}
]
}
"
scroll
is
fine
"
)
;
await
setScrollPosition
(
browser
.
browsingContext
.
children
[
1
]
SCROLL2_X
SCROLL2_Y
)
;
await
checkScroll
(
tab
{
children
:
[
{
scroll
:
SCROLL_STR
}
{
scroll
:
SCROLL2_STR
}
]
}
"
scroll
is
fine
"
)
;
let
tab2
=
ss
.
duplicateTab
(
window
tab
)
;
let
browser2
=
tab2
.
linkedBrowser
;
await
promiseTabRestored
(
tab2
)
;
let
scroll
=
await
getScrollPosition
(
browser2
.
browsingContext
.
children
[
0
]
)
;
is
(
JSON
.
stringify
(
scroll
)
JSON
.
stringify
(
{
x
:
SCROLL_X
y
:
SCROLL_Y
}
)
"
scroll
position
#
1
has
been
duplicated
correctly
"
)
;
scroll
=
await
getScrollPosition
(
browser2
.
browsingContext
.
children
[
1
]
)
;
is
(
JSON
.
stringify
(
scroll
)
JSON
.
stringify
(
{
x
:
SCROLL2_X
y
:
SCROLL2_Y
}
)
"
scroll
position
#
2
has
been
duplicated
correctly
"
)
;
await
setScrollPosition
(
browser
.
browsingContext
.
children
[
0
]
0
0
)
;
await
checkScroll
(
tab
{
children
:
[
null
{
scroll
:
SCROLL2_STR
}
]
}
"
scroll
is
fine
"
)
;
await
setScrollPosition
(
browser
.
browsingContext
.
children
[
1
]
0
0
)
;
await
checkScroll
(
tab
null
"
no
scroll
stored
"
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
BrowserTestUtils
.
removeTab
(
tab2
)
;
}
async
function
test_scroll_background_tabs
(
aURL
)
{
await
pushPrefs
(
[
"
browser
.
sessionstore
.
restore_on_demand
"
true
]
[
"
dom
.
visualviewport
.
enabled
"
true
]
)
;
let
newWin
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
let
tab
=
BrowserTestUtils
.
addTab
(
newWin
.
gBrowser
aURL
)
;
let
browser
=
tab
.
linkedBrowser
;
await
BrowserTestUtils
.
browserLoaded
(
browser
)
;
await
setScrollPosition
(
browser
SCROLL_X
SCROLL_Y
)
;
await
checkScroll
(
tab
{
scroll
:
SCROLL_STR
}
"
scroll
on
first
page
is
fine
"
)
;
BrowserTestUtils
.
loadURI
(
browser
URL2
)
;
await
BrowserTestUtils
.
browserLoaded
(
browser
)
;
await
setScrollPosition
(
browser
SCROLL2_X
SCROLL2_Y
)
;
await
checkScroll
(
tab
{
scroll
:
SCROLL2_STR
}
"
scroll
on
second
page
is
fine
"
)
;
await
BrowserTestUtils
.
closeWindow
(
newWin
)
;
await
forceSaveState
(
)
;
newWin
=
ss
.
undoCloseWindow
(
0
)
;
await
BrowserTestUtils
.
waitForEvent
(
newWin
"
SSWindowStateReady
"
)
;
is
(
newWin
.
gBrowser
.
tabs
.
length
2
"
There
should
be
two
tabs
"
)
;
tab
=
newWin
.
gBrowser
.
tabs
[
1
]
;
ok
(
tab
.
hasAttribute
(
"
pending
"
)
"
Tab
should
be
pending
"
)
;
browser
=
tab
.
linkedBrowser
;
await
TabStateFlusher
.
flush
(
browser
)
;
newWin
.
gBrowser
.
selectedTab
=
tab
;
await
promiseTabRestored
(
tab
)
;
await
checkScroll
(
tab
{
scroll
:
SCROLL2_STR
}
"
scroll
is
still
fine
"
)
;
is
(
browser
.
canGoBack
true
"
can
go
back
"
)
;
browser
.
goBack
(
)
;
await
BrowserTestUtils
.
browserLoaded
(
browser
)
;
await
TabStateFlusher
.
flush
(
browser
)
;
await
checkScroll
(
tab
{
scroll
:
SCROLL_STR
}
"
scroll
is
still
fine
after
navigating
back
"
)
;
await
BrowserTestUtils
.
closeWindow
(
newWin
)
;
}
