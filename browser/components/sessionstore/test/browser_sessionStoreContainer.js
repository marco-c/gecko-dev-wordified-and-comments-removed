"
use
strict
"
;
add_task
(
function
*
(
)
{
for
(
let
i
=
0
;
i
<
3
;
+
+
i
)
{
let
tab
=
gBrowser
.
addTab
(
"
http
:
/
/
example
.
com
/
"
{
userContextId
:
i
}
)
;
let
browser
=
tab
.
linkedBrowser
;
yield
promiseBrowserLoaded
(
browser
)
;
let
tab2
=
gBrowser
.
duplicateTab
(
tab
)
;
Assert
.
equal
(
tab2
.
getAttribute
(
"
usercontextid
"
)
i
)
;
let
browser2
=
tab2
.
linkedBrowser
;
yield
promiseTabRestored
(
tab2
)
yield
ContentTask
.
spawn
(
browser2
{
expectedId
:
i
}
function
*
(
args
)
{
let
loadContext
=
docShell
.
QueryInterface
(
Ci
.
nsILoadContext
)
;
Assert
.
equal
(
loadContext
.
originAttributes
.
userContextId
args
.
expectedId
"
The
docShell
has
the
correct
userContextId
"
)
;
}
)
;
yield
promiseRemoveTab
(
tab
)
;
yield
promiseRemoveTab
(
tab2
)
;
}
}
)
;
add_task
(
function
*
(
)
{
let
tab
=
gBrowser
.
addTab
(
"
http
:
/
/
example
.
com
/
"
{
userContextId
:
1
}
)
;
let
browser
=
tab
.
linkedBrowser
;
yield
promiseBrowserLoaded
(
browser
)
;
gBrowser
.
selectedTab
=
tab
;
let
tab2
=
gBrowser
.
duplicateTab
(
tab
)
;
let
browser2
=
tab2
.
linkedBrowser
;
yield
promiseTabRestored
(
tab2
)
yield
ContentTask
.
spawn
(
browser2
{
expectedId
:
1
}
function
*
(
args
)
{
Assert
.
equal
(
docShell
.
getOriginAttributes
(
)
.
userContextId
args
.
expectedId
"
The
docShell
has
the
correct
userContextId
"
)
;
}
)
;
yield
promiseRemoveTab
(
tab
)
;
yield
promiseRemoveTab
(
tab2
)
;
}
)
;
add_task
(
function
*
(
)
{
let
tab
=
gBrowser
.
addTab
(
"
http
:
/
/
example
.
com
/
"
{
userContextId
:
1
}
)
;
let
browser
=
tab
.
linkedBrowser
;
yield
promiseBrowserLoaded
(
browser
)
;
gBrowser
.
removeTab
(
tab
)
;
let
tab2
=
ss
.
undoCloseTab
(
window
0
)
;
Assert
.
equal
(
tab2
.
getAttribute
(
"
usercontextid
"
)
1
)
;
yield
promiseTabRestored
(
tab2
)
;
yield
ContentTask
.
spawn
(
tab2
.
linkedBrowser
{
expectedId
:
1
}
function
*
(
args
)
{
Assert
.
equal
(
docShell
.
getOriginAttributes
(
)
.
userContextId
args
.
expectedId
"
The
docShell
has
the
correct
userContextId
"
)
;
}
)
;
yield
promiseRemoveTab
(
tab2
)
;
}
)
;
function
*
openTabInUserContext
(
userContextId
)
{
let
tab
=
gBrowser
.
addTab
(
"
http
:
/
/
example
.
com
"
{
userContextId
}
)
;
gBrowser
.
selectedTab
=
tab
;
tab
.
ownerGlobal
.
focus
(
)
;
let
browser
=
gBrowser
.
getBrowserForTab
(
tab
)
;
yield
BrowserTestUtils
.
browserLoaded
(
browser
)
;
return
{
tab
browser
}
;
}
function
waitForNewCookie
(
)
{
return
new
Promise
(
resolve
=
>
{
Services
.
obs
.
addObserver
(
function
observer
(
subj
topic
data
)
{
let
cookie
=
subj
.
QueryInterface
(
Ci
.
nsICookie2
)
;
if
(
data
=
=
"
added
"
)
{
Services
.
obs
.
removeObserver
(
observer
topic
)
;
resolve
(
)
;
}
}
"
cookie
-
changed
"
false
)
;
}
)
;
}
add_task
(
function
*
test
(
)
{
const
USER_CONTEXTS
=
[
"
default
"
"
personal
"
"
work
"
]
;
const
ss
=
Cc
[
"
mozilla
.
org
/
browser
/
sessionstore
;
1
"
]
.
getService
(
Ci
.
nsISessionStore
)
;
const
{
TabStateFlusher
}
=
Cu
.
import
(
"
resource
:
/
/
/
modules
/
sessionstore
/
TabStateFlusher
.
jsm
"
{
}
)
;
yield
SpecialPowers
.
pushPrefEnv
(
{
"
set
"
:
[
[
"
privacy
.
userContext
.
enabled
"
true
]
]
}
)
;
let
lastSessionRestore
;
for
(
let
userContextId
of
Object
.
keys
(
USER_CONTEXTS
)
)
{
let
cookie
=
USER_CONTEXTS
[
userContextId
]
;
let
{
tab
browser
}
=
yield
*
openTabInUserContext
(
userContextId
)
;
yield
Promise
.
all
(
[
waitForNewCookie
(
)
ContentTask
.
spawn
(
browser
cookie
cookie
=
>
content
.
document
.
cookie
=
cookie
)
]
)
;
yield
TabStateFlusher
.
flush
(
browser
)
;
lastSessionRestore
=
ss
.
getWindowState
(
window
)
;
gBrowser
.
removeTab
(
tab
)
;
}
let
state
=
JSON
.
parse
(
lastSessionRestore
)
;
is
(
state
.
windows
[
0
]
.
cookies
.
length
USER_CONTEXTS
.
length
"
session
restore
should
have
each
container
'
s
cookie
"
)
;
}
)
;
