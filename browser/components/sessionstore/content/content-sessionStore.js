"
use
strict
"
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
this
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
TelemetryStopwatch
"
"
resource
:
/
/
gre
/
modules
/
TelemetryStopwatch
.
jsm
"
)
;
function
debug
(
msg
)
{
Services
.
console
.
logStringMessage
(
"
SessionStoreContent
:
"
+
msg
)
;
}
ChromeUtils
.
defineModuleGetter
(
this
"
FormData
"
"
resource
:
/
/
gre
/
modules
/
FormData
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ContentRestore
"
"
resource
:
/
/
/
modules
/
sessionstore
/
ContentRestore
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
DocShellCapabilities
"
"
resource
:
/
/
/
modules
/
sessionstore
/
DocShellCapabilities
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ScrollPosition
"
"
resource
:
/
/
gre
/
modules
/
ScrollPosition
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
SessionHistory
"
"
resource
:
/
/
gre
/
modules
/
sessionstore
/
SessionHistory
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
SessionStorage
"
"
resource
:
/
/
/
modules
/
sessionstore
/
SessionStorage
.
jsm
"
)
;
var
contentRestoreInitialized
=
false
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gContentRestore
"
(
)
=
>
{
contentRestoreInitialized
=
true
;
return
new
ContentRestore
(
this
)
;
}
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Utils
"
"
resource
:
/
/
gre
/
modules
/
sessionstore
/
Utils
.
jsm
"
)
;
const
ssu
=
Cc
[
"
mozilla
.
org
/
browser
/
sessionstore
/
utils
;
1
"
]
.
getService
(
Ci
.
nsISessionStoreUtils
)
;
var
gCurrentEpoch
=
0
;
const
DOM_STORAGE_LIMIT_PREF
=
"
browser
.
sessionstore
.
dom_storage_limit
"
;
const
TIMEOUT_DISABLED_PREF
=
"
browser
.
sessionstore
.
debug
.
no_auto_updates
"
;
const
PREF_INTERVAL
=
"
browser
.
sessionstore
.
interval
"
;
const
kNoIndex
=
Number
.
MAX_SAFE_INTEGER
;
const
kLastIndex
=
Number
.
MAX_SAFE_INTEGER
-
1
;
const
global
=
this
;
function
mapFrameTree
(
callback
)
{
let
[
data
]
=
Utils
.
mapFrameTree
(
content
callback
)
;
return
data
;
}
var
StateChangeNotifier
=
{
init
(
)
{
this
.
_observers
=
new
Set
(
)
;
let
ifreq
=
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
;
let
webProgress
=
ifreq
.
getInterface
(
Ci
.
nsIWebProgress
)
;
webProgress
.
addProgressListener
(
this
Ci
.
nsIWebProgress
.
NOTIFY_STATE_DOCUMENT
)
;
}
addObserver
(
obs
)
{
this
.
_observers
.
add
(
obs
)
;
}
notifyObservers
(
method
)
{
for
(
let
obs
of
this
.
_observers
)
{
if
(
obs
.
hasOwnProperty
(
method
)
)
{
obs
[
method
]
(
)
;
}
}
}
onStateChange
(
webProgress
request
stateFlags
status
)
{
if
(
!
webProgress
.
isTopLevel
|
|
webProgress
.
DOMWindow
!
=
content
)
{
return
;
}
if
(
!
docShell
.
hasLoadedNonBlankURI
)
{
return
;
}
if
(
stateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_START
)
{
this
.
notifyObservers
(
"
onPageLoadStarted
"
)
;
}
else
if
(
stateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_STOP
)
{
this
.
notifyObservers
(
"
onPageLoadCompleted
"
)
;
}
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIWebProgressListener
Ci
.
nsISupportsWeakReference
]
)
}
;
var
EventListener
=
{
init
(
)
{
ssu
.
addDynamicFrameFilteredListener
(
global
"
load
"
this
true
)
;
}
handleEvent
(
event
)
{
if
(
event
.
target
!
=
content
.
document
)
{
return
;
}
if
(
content
.
document
.
documentURI
.
startsWith
(
"
about
:
reader
"
)
)
{
if
(
event
.
type
=
=
"
load
"
&
&
!
content
.
document
.
body
.
classList
.
contains
(
"
loaded
"
)
)
{
content
.
addEventListener
(
"
AboutReaderContentReady
"
this
)
;
return
;
}
content
.
removeEventListener
(
"
AboutReaderContentReady
"
this
)
;
}
if
(
contentRestoreInitialized
)
{
gContentRestore
.
restoreDocument
(
)
;
}
}
}
;
var
MessageListener
=
{
MESSAGES
:
[
"
SessionStore
:
restoreHistory
"
"
SessionStore
:
restoreTabContent
"
"
SessionStore
:
resetRestore
"
"
SessionStore
:
flush
"
"
SessionStore
:
becomeActiveProcess
"
]
init
(
)
{
this
.
MESSAGES
.
forEach
(
m
=
>
addMessageListener
(
m
this
)
)
;
}
receiveMessage
(
{
name
data
}
)
{
if
(
!
docShell
)
{
return
;
}
if
(
data
.
epoch
&
&
data
.
epoch
!
=
gCurrentEpoch
)
{
gCurrentEpoch
=
data
.
epoch
;
}
switch
(
name
)
{
case
"
SessionStore
:
restoreHistory
"
:
this
.
restoreHistory
(
data
)
;
break
;
case
"
SessionStore
:
restoreTabContent
"
:
if
(
data
.
isRemotenessUpdate
)
{
let
histogram
=
Services
.
telemetry
.
getKeyedHistogramById
(
"
FX_TAB_REMOTE_NAVIGATION_DELAY_MS
"
)
;
histogram
.
add
(
"
SessionStore
:
restoreTabContent
"
Services
.
telemetry
.
msSystemNow
(
)
-
data
.
requestTime
)
;
}
this
.
restoreTabContent
(
data
)
;
break
;
case
"
SessionStore
:
resetRestore
"
:
gContentRestore
.
resetRestore
(
)
;
break
;
case
"
SessionStore
:
flush
"
:
this
.
flush
(
data
)
;
break
;
case
"
SessionStore
:
becomeActiveProcess
"
:
SessionHistoryListener
.
collect
(
)
;
break
;
default
:
debug
(
"
received
unknown
message
'
"
+
name
+
"
'
"
)
;
break
;
}
}
restoreHistory
(
{
epoch
tabData
loadArguments
isRemotenessUpdate
}
)
{
gContentRestore
.
restoreHistory
(
tabData
loadArguments
{
onLoadStarted
(
)
{
sendAsyncMessage
(
"
SessionStore
:
restoreTabContentStarted
"
{
epoch
}
)
;
}
onLoadFinished
(
)
{
sendAsyncMessage
(
"
SessionStore
:
restoreTabContentComplete
"
{
epoch
}
)
;
}
}
)
;
if
(
Services
.
appinfo
.
processType
=
=
Services
.
appinfo
.
PROCESS_TYPE_DEFAULT
)
{
sendSyncMessage
(
"
SessionStore
:
restoreHistoryComplete
"
{
epoch
isRemotenessUpdate
}
)
;
}
else
{
sendAsyncMessage
(
"
SessionStore
:
restoreHistoryComplete
"
{
epoch
isRemotenessUpdate
}
)
;
}
}
restoreTabContent
(
{
loadArguments
isRemotenessUpdate
reason
}
)
{
let
epoch
=
gCurrentEpoch
;
let
didStartLoad
=
gContentRestore
.
restoreTabContent
(
loadArguments
isRemotenessUpdate
(
)
=
>
{
sendAsyncMessage
(
"
SessionStore
:
restoreTabContentComplete
"
{
epoch
isRemotenessUpdate
}
)
;
}
)
;
sendAsyncMessage
(
"
SessionStore
:
restoreTabContentStarted
"
{
epoch
isRemotenessUpdate
reason
}
)
;
if
(
!
didStartLoad
)
{
sendAsyncMessage
(
"
SessionStore
:
restoreTabContentComplete
"
{
epoch
isRemotenessUpdate
}
)
;
}
}
flush
(
{
id
}
)
{
MessageQueue
.
send
(
{
flushID
:
id
}
)
;
}
}
;
var
SessionHistoryListener
=
{
init
(
)
{
StateChangeNotifier
.
addObserver
(
this
)
;
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
.
sessionHistory
.
legacySHistory
.
addSHistoryListener
(
this
)
;
if
(
!
SessionHistory
.
isEmpty
(
docShell
)
)
{
this
.
collect
(
)
;
MessageQueue
.
send
(
)
;
}
addEventListener
(
"
DOMTitleChanged
"
this
)
;
}
uninit
(
)
{
let
sessionHistory
=
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
.
sessionHistory
;
if
(
sessionHistory
)
{
sessionHistory
.
legacySHistory
.
removeSHistoryListener
(
this
)
;
}
}
collect
(
)
{
if
(
docShell
)
{
this
.
collectFrom
(
-
1
)
;
}
}
_fromIdx
:
kNoIndex
collectFrom
(
idx
)
{
if
(
this
.
_fromIdx
<
=
idx
)
{
return
;
}
this
.
_fromIdx
=
idx
;
MessageQueue
.
push
(
"
historychange
"
(
)
=
>
{
if
(
this
.
_fromIdx
=
=
=
kNoIndex
)
{
return
null
;
}
let
history
=
SessionHistory
.
collect
(
docShell
this
.
_fromIdx
)
;
this
.
_fromIdx
=
kNoIndex
;
return
history
;
}
)
;
}
handleEvent
(
event
)
{
this
.
collect
(
)
;
}
onPageLoadCompleted
(
)
{
this
.
collect
(
)
;
}
onPageLoadStarted
(
)
{
this
.
collect
(
)
;
}
OnHistoryNewEntry
(
newURI
oldIndex
)
{
this
.
collectFrom
(
oldIndex
)
;
}
OnHistoryGoBack
(
backURI
)
{
this
.
collectFrom
(
kLastIndex
)
;
return
true
;
}
OnHistoryGoForward
(
forwardURI
)
{
this
.
collectFrom
(
kLastIndex
)
;
return
true
;
}
OnHistoryGotoIndex
(
index
gotoURI
)
{
this
.
collectFrom
(
kLastIndex
)
;
return
true
;
}
OnHistoryPurge
(
numEntries
)
{
this
.
collect
(
)
;
return
true
;
}
OnHistoryReload
(
reloadURI
reloadFlags
)
{
this
.
collect
(
)
;
return
true
;
}
OnHistoryReplaceEntry
(
index
)
{
this
.
collect
(
)
;
}
OnLengthChanged
(
aCount
)
{
}
OnIndexChanged
(
aIndex
)
{
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsISHistoryListener
Ci
.
nsISupportsWeakReference
]
)
}
;
var
ScrollPositionListener
=
{
init
(
)
{
ssu
.
addDynamicFrameFilteredListener
(
global
"
scroll
"
this
false
)
;
StateChangeNotifier
.
addObserver
(
this
)
;
}
handleEvent
(
)
{
MessageQueue
.
push
(
"
scroll
"
(
)
=
>
this
.
collect
(
)
)
;
}
onPageLoadCompleted
(
)
{
MessageQueue
.
push
(
"
scroll
"
(
)
=
>
this
.
collect
(
)
)
;
}
onPageLoadStarted
(
)
{
MessageQueue
.
push
(
"
scroll
"
(
)
=
>
null
)
;
}
collect
(
)
{
return
mapFrameTree
(
ScrollPosition
.
collect
)
;
}
}
;
var
FormDataListener
=
{
init
(
)
{
ssu
.
addDynamicFrameFilteredListener
(
global
"
input
"
this
true
)
;
StateChangeNotifier
.
addObserver
(
this
)
;
}
handleEvent
(
)
{
MessageQueue
.
push
(
"
formdata
"
(
)
=
>
this
.
collect
(
)
)
;
}
onPageLoadStarted
(
)
{
MessageQueue
.
push
(
"
formdata
"
(
)
=
>
null
)
;
}
collect
(
)
{
return
mapFrameTree
(
FormData
.
collect
)
;
}
}
;
var
DocShellCapabilitiesListener
=
{
_latestCapabilities
:
"
"
init
(
)
{
StateChangeNotifier
.
addObserver
(
this
)
;
}
onPageLoadStarted
(
)
{
let
caps
=
DocShellCapabilities
.
collect
(
docShell
)
.
join
(
"
"
)
;
if
(
caps
!
=
this
.
_latestCapabilities
)
{
this
.
_latestCapabilities
=
caps
;
MessageQueue
.
push
(
"
disallow
"
(
)
=
>
caps
|
|
null
)
;
}
}
}
;
var
SessionStorageListener
=
{
init
(
)
{
Services
.
obs
.
addObserver
(
this
"
browser
:
purge
-
domain
-
data
"
)
;
StateChangeNotifier
.
addObserver
(
this
)
;
this
.
resetEventListener
(
)
;
}
uninit
(
)
{
Services
.
obs
.
removeObserver
(
this
"
browser
:
purge
-
domain
-
data
"
)
;
}
observe
(
)
{
setTimeoutWithTarget
(
(
)
=
>
this
.
collect
(
)
0
tabEventTarget
)
;
}
_changes
:
undefined
resetChanges
(
)
{
this
.
_changes
=
undefined
;
}
_listener
:
null
resetEventListener
(
)
{
if
(
!
this
.
_listener
)
{
this
.
_listener
=
ssu
.
addDynamicFrameFilteredListener
(
global
"
MozSessionStorageChanged
"
this
true
)
;
}
}
removeEventListener
(
)
{
ssu
.
removeDynamicFrameFilteredListener
(
global
"
MozSessionStorageChanged
"
this
.
_listener
true
)
;
this
.
_listener
=
null
;
}
handleEvent
(
event
)
{
if
(
!
docShell
)
{
return
;
}
let
usage
=
content
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
.
getStorageUsage
(
event
.
storageArea
)
;
if
(
usage
>
Services
.
prefs
.
getIntPref
(
DOM_STORAGE_LIMIT_PREF
)
)
{
MessageQueue
.
push
(
"
storage
"
(
)
=
>
null
)
;
this
.
removeEventListener
(
)
;
this
.
resetChanges
(
)
;
return
;
}
let
{
url
key
newValue
}
=
event
;
let
uri
=
Services
.
io
.
newURI
(
url
)
;
let
domain
=
uri
.
prePath
;
if
(
!
this
.
_changes
)
{
this
.
_changes
=
{
}
;
}
if
(
!
this
.
_changes
[
domain
]
)
{
this
.
_changes
[
domain
]
=
{
}
;
}
this
.
_changes
[
domain
]
[
key
]
=
newValue
;
MessageQueue
.
push
(
"
storagechange
"
(
)
=
>
{
let
tmp
=
this
.
_changes
;
this
.
resetChanges
(
)
;
return
tmp
;
}
)
;
}
collect
(
)
{
if
(
!
docShell
)
{
return
;
}
this
.
resetChanges
(
)
;
MessageQueue
.
push
(
"
storage
"
(
)
=
>
SessionStorage
.
collect
(
content
)
)
;
}
onPageLoadCompleted
(
)
{
this
.
collect
(
)
;
}
onPageLoadStarted
(
)
{
this
.
resetEventListener
(
)
;
this
.
collect
(
)
;
}
}
;
var
PrivacyListener
=
{
init
(
)
{
docShell
.
addWeakPrivacyTransitionObserver
(
this
)
;
if
(
docShell
.
QueryInterface
(
Ci
.
nsILoadContext
)
.
usePrivateBrowsing
)
{
MessageQueue
.
push
(
"
isPrivate
"
(
)
=
>
true
)
;
}
}
privateModeChanged
(
enabled
)
{
MessageQueue
.
push
(
"
isPrivate
"
(
)
=
>
enabled
|
|
null
)
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIPrivacyTransitionObserver
Ci
.
nsISupportsWeakReference
]
)
}
;
var
MessageQueue
=
{
_data
:
new
Map
(
)
BATCH_DELAY_MS
:
1000
NEEDED_IDLE_PERIOD_MS
:
5
_timeoutWaitIdlePeriodMs
:
null
_timeout
:
null
_timeoutDisabled
:
false
_idleScheduled
:
false
get
timeoutDisabled
(
)
{
return
this
.
_timeoutDisabled
;
}
set
timeoutDisabled
(
val
)
{
this
.
_timeoutDisabled
=
val
;
if
(
val
&
&
this
.
_timeout
)
{
clearTimeout
(
this
.
_timeout
)
;
this
.
_timeout
=
null
;
}
return
val
;
}
init
(
)
{
this
.
timeoutDisabled
=
Services
.
prefs
.
getBoolPref
(
TIMEOUT_DISABLED_PREF
)
;
this
.
_timeoutWaitIdlePeriodMs
=
Services
.
prefs
.
getIntPref
(
PREF_INTERVAL
)
;
Services
.
prefs
.
addObserver
(
TIMEOUT_DISABLED_PREF
this
)
;
Services
.
prefs
.
addObserver
(
PREF_INTERVAL
this
)
;
}
uninit
(
)
{
Services
.
prefs
.
removeObserver
(
TIMEOUT_DISABLED_PREF
this
)
;
Services
.
prefs
.
removeObserver
(
PREF_INTERVAL
this
)
;
this
.
cleanupTimers
(
)
;
}
cleanupTimers
(
)
{
this
.
_idleScheduled
=
false
;
if
(
this
.
_timeout
)
{
clearTimeout
(
this
.
_timeout
)
;
this
.
_timeout
=
null
;
}
}
observe
(
subject
topic
data
)
{
if
(
topic
=
=
"
nsPref
:
changed
"
)
{
switch
(
data
)
{
case
TIMEOUT_DISABLED_PREF
:
this
.
timeoutDisabled
=
Services
.
prefs
.
getBoolPref
(
TIMEOUT_DISABLED_PREF
)
;
break
;
case
PREF_INTERVAL
:
this
.
_timeoutWaitIdlePeriodMs
=
Services
.
prefs
.
getIntPref
(
PREF_INTERVAL
)
;
break
;
default
:
debug
(
"
received
unknown
message
'
"
+
data
+
"
'
"
)
;
break
;
}
}
}
push
(
key
fn
)
{
this
.
_data
.
set
(
key
fn
)
;
if
(
!
this
.
_timeout
&
&
!
this
.
_timeoutDisabled
)
{
this
.
_timeout
=
setTimeoutWithTarget
(
(
)
=
>
this
.
sendWhenIdle
(
)
this
.
BATCH_DELAY_MS
tabEventTarget
)
;
}
}
sendWhenIdle
(
deadline
)
{
if
(
!
content
)
{
return
;
}
if
(
deadline
)
{
if
(
deadline
.
didTimeout
|
|
deadline
.
timeRemaining
(
)
>
MessageQueue
.
NEEDED_IDLE_PERIOD_MS
)
{
MessageQueue
.
send
(
)
;
return
;
}
}
else
if
(
MessageQueue
.
_idleScheduled
)
{
return
;
}
ChromeUtils
.
idleDispatch
(
MessageQueue
.
sendWhenIdle
{
timeout
:
MessageQueue
.
_timeoutWaitIdlePeriodMs
}
)
;
MessageQueue
.
_idleScheduled
=
true
;
}
send
(
options
=
{
}
)
{
if
(
!
docShell
)
{
return
;
}
this
.
cleanupTimers
(
)
;
let
flushID
=
(
options
&
&
options
.
flushID
)
|
|
0
;
let
histID
=
"
FX_SESSION_RESTORE_CONTENT_COLLECT_DATA_MS
"
;
let
data
=
{
}
;
for
(
let
[
key
func
]
of
this
.
_data
)
{
if
(
key
!
=
"
isPrivate
"
)
{
TelemetryStopwatch
.
startKeyed
(
histID
key
)
;
}
let
value
=
func
(
)
;
if
(
key
!
=
"
isPrivate
"
)
{
TelemetryStopwatch
.
finishKeyed
(
histID
key
)
;
}
if
(
value
|
|
(
key
!
=
"
storagechange
"
&
&
key
!
=
"
historychange
"
)
)
{
data
[
key
]
=
value
;
}
}
this
.
_data
.
clear
(
)
;
try
{
sendAsyncMessage
(
"
SessionStore
:
update
"
{
data
flushID
isFinal
:
options
.
isFinal
|
|
false
epoch
:
gCurrentEpoch
}
)
;
}
catch
(
ex
)
{
if
(
ex
&
&
ex
.
result
=
=
Cr
.
NS_ERROR_OUT_OF_MEMORY
)
{
Services
.
telemetry
.
getHistogramById
(
"
FX_SESSION_RESTORE_SEND_UPDATE_CAUSED_OOM
"
)
.
add
(
1
)
;
sendAsyncMessage
(
"
SessionStore
:
error
"
)
;
}
}
}
}
;
StateChangeNotifier
.
init
(
)
;
EventListener
.
init
(
)
;
MessageListener
.
init
(
)
;
FormDataListener
.
init
(
)
;
SessionHistoryListener
.
init
(
)
;
SessionStorageListener
.
init
(
)
;
ScrollPositionListener
.
init
(
)
;
DocShellCapabilitiesListener
.
init
(
)
;
PrivacyListener
.
init
(
)
;
MessageQueue
.
init
(
)
;
function
handleRevivedTab
(
)
{
if
(
!
content
)
{
removeEventListener
(
"
pagehide
"
handleRevivedTab
)
;
return
;
}
if
(
content
.
document
.
documentURI
.
startsWith
(
"
about
:
tabcrashed
"
)
)
{
if
(
Services
.
appinfo
.
processType
!
=
Services
.
appinfo
.
PROCESS_TYPE_DEFAULT
)
{
throw
new
Error
(
"
We
seem
to
be
navigating
away
from
about
:
tabcrashed
in
"
+
"
a
non
-
remote
browser
.
This
should
really
never
happen
.
"
)
;
}
removeEventListener
(
"
pagehide
"
handleRevivedTab
)
;
sendAsyncMessage
(
"
SessionStore
:
crashedTabRevived
"
)
;
}
}
addEventListener
(
"
pagehide
"
handleRevivedTab
)
;
addEventListener
(
"
unload
"
(
)
=
>
{
MessageQueue
.
send
(
{
isFinal
:
true
}
)
;
handleRevivedTab
(
)
;
SessionStorageListener
.
uninit
(
)
;
SessionHistoryListener
.
uninit
(
)
;
MessageQueue
.
uninit
(
)
;
if
(
contentRestoreInitialized
)
{
gContentRestore
.
resetRestore
(
)
;
}
}
)
;
