"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
TabState
"
]
;
const
Cu
=
Components
.
utils
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
this
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PrivacyFilter
"
"
resource
:
/
/
/
modules
/
sessionstore
/
PrivacyFilter
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
TabStateCache
"
"
resource
:
/
/
/
modules
/
sessionstore
/
TabStateCache
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
TabAttributes
"
"
resource
:
/
/
/
modules
/
sessionstore
/
TabAttributes
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Utils
"
"
resource
:
/
/
/
modules
/
sessionstore
/
Utils
.
jsm
"
)
;
this
.
TabState
=
Object
.
freeze
(
{
update
:
function
(
browser
data
)
{
TabStateInternal
.
update
(
browser
data
)
;
}
collect
:
function
(
tab
)
{
return
TabStateInternal
.
collect
(
tab
)
;
}
clone
:
function
(
tab
)
{
return
TabStateInternal
.
clone
(
tab
)
;
}
copyFromCache
(
browser
tabData
options
)
{
TabStateInternal
.
copyFromCache
(
browser
tabData
options
)
;
}
}
)
;
var
TabStateInternal
=
{
update
:
function
(
browser
{
data
}
)
{
TabStateCache
.
update
(
browser
data
)
;
}
collect
:
function
(
tab
)
{
return
this
.
_collectBaseTabData
(
tab
)
;
}
clone
:
function
(
tab
)
{
return
this
.
_collectBaseTabData
(
tab
{
includePrivateData
:
true
}
)
;
}
_collectBaseTabData
:
function
(
tab
options
)
{
let
tabData
=
{
entries
:
[
]
lastAccessed
:
tab
.
lastAccessed
}
;
let
browser
=
tab
.
linkedBrowser
;
if
(
tab
.
pinned
)
{
tabData
.
pinned
=
true
;
}
tabData
.
hidden
=
tab
.
hidden
;
if
(
browser
.
audioMuted
)
{
tabData
.
muted
=
true
;
tabData
.
muteReason
=
tab
.
muteReason
;
}
tabData
.
attributes
=
TabAttributes
.
get
(
tab
)
;
if
(
tab
.
__SS_extdata
)
{
tabData
.
extData
=
tab
.
__SS_extdata
;
}
this
.
copyFromCache
(
browser
tabData
options
)
;
if
(
!
(
"
image
"
in
tabData
)
)
{
let
tabbrowser
=
tab
.
ownerGlobal
.
gBrowser
;
tabData
.
image
=
tabbrowser
.
getIcon
(
tab
)
;
}
if
(
!
(
"
iconLoadingPrincipal
"
in
tabData
)
)
{
tabData
.
iconLoadingPrincipal
=
Utils
.
serializePrincipal
(
browser
.
contentPrincipal
)
;
}
if
(
!
(
"
userTypedValue
"
in
tabData
)
&
&
browser
.
userTypedValue
)
{
tabData
.
userTypedValue
=
browser
.
userTypedValue
;
tabData
.
userTypedClear
=
browser
.
didStartLoadSinceLastUserTyping
(
)
?
1
:
0
;
}
return
tabData
;
}
copyFromCache
(
browser
tabData
options
=
{
}
)
{
let
data
=
TabStateCache
.
get
(
browser
)
;
if
(
!
data
)
{
return
;
}
let
includePrivateData
=
options
&
&
options
.
includePrivateData
;
let
isPinned
=
!
!
tabData
.
pinned
;
for
(
let
key
of
Object
.
keys
(
data
)
)
{
let
value
=
data
[
key
]
;
if
(
!
includePrivateData
)
{
if
(
key
=
=
=
"
storage
"
)
{
value
=
PrivacyFilter
.
filterSessionStorageData
(
value
)
;
}
else
if
(
key
=
=
=
"
formdata
"
)
{
value
=
PrivacyFilter
.
filterFormData
(
value
)
;
}
}
if
(
key
=
=
=
"
history
"
)
{
tabData
.
entries
=
value
.
entries
;
if
(
value
.
hasOwnProperty
(
"
userContextId
"
)
)
{
tabData
.
userContextId
=
value
.
userContextId
;
}
if
(
value
.
hasOwnProperty
(
"
index
"
)
)
{
tabData
.
index
=
value
.
index
;
}
}
else
{
tabData
[
key
]
=
value
;
}
}
}
}
;
