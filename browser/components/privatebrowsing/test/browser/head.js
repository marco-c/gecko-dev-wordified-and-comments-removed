var
{
PromiseUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
)
;
var
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PlacesUtils
"
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PlacesTestUtils
"
"
resource
:
/
/
testing
-
common
/
PlacesTestUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
TestUtils
"
"
resource
:
/
/
testing
-
common
/
TestUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
FileUtils
"
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
ASRouter
:
"
resource
:
/
/
activity
-
stream
/
lib
/
ASRouter
.
jsm
"
ExperimentAPI
:
"
resource
:
/
/
nimbus
/
ExperimentAPI
.
jsm
"
ExperimentFakes
:
"
resource
:
/
/
testing
-
common
/
NimbusTestUtils
.
jsm
"
PanelTestProvider
:
"
resource
:
/
/
activity
-
stream
/
lib
/
PanelTestProvider
.
jsm
"
TelemetryTestUtils
:
"
resource
:
/
/
testing
-
common
/
TelemetryTestUtils
.
jsm
"
}
)
;
function
whenNewWindowLoaded
(
aOptions
aCallback
)
{
let
win
=
OpenBrowserWindow
(
aOptions
)
;
let
focused
=
SimpleTest
.
promiseFocus
(
win
)
;
let
startupFinished
=
TestUtils
.
topicObserved
(
"
browser
-
delayed
-
startup
-
finished
"
subject
=
>
subject
=
=
win
)
.
then
(
(
)
=
>
win
)
;
Promise
.
all
(
[
focused
startupFinished
]
)
.
then
(
results
=
>
executeSoon
(
(
)
=
>
aCallback
(
results
[
1
]
)
)
)
;
return
win
;
}
function
openWindow
(
aParent
aOptions
)
{
let
win
=
aParent
.
OpenBrowserWindow
(
aOptions
)
;
return
TestUtils
.
topicObserved
(
"
browser
-
delayed
-
startup
-
finished
"
subject
=
>
subject
=
=
win
)
.
then
(
(
)
=
>
win
)
;
}
async
function
openAboutPrivateBrowsing
(
)
{
let
win
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
{
private
:
true
waitForTabURL
:
"
about
:
privatebrowsing
"
}
)
;
let
tab
=
win
.
gBrowser
.
selectedBrowser
;
return
{
win
tab
}
;
}
async
function
openTabAndWaitForRender
(
)
{
let
{
win
tab
}
=
await
openAboutPrivateBrowsing
(
)
;
await
SpecialPowers
.
spawn
(
tab
[
]
async
function
(
)
{
await
ContentTaskUtils
.
waitForCondition
(
(
)
=
>
content
.
document
.
documentElement
.
hasAttribute
(
"
PrivateBrowsingRenderComplete
"
)
)
;
}
)
;
return
{
win
tab
}
;
}
function
newDirectory
(
)
{
let
tmpDir
=
FileUtils
.
getDir
(
"
TmpD
"
[
]
true
)
;
let
dir
=
tmpDir
.
clone
(
)
;
dir
.
append
(
"
testdir
"
)
;
dir
.
createUnique
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
FileUtils
.
PERMS_DIRECTORY
)
;
return
dir
;
}
function
newFileInDirectory
(
aDir
)
{
let
file
=
aDir
.
clone
(
)
;
file
.
append
(
"
testfile
"
)
;
file
.
createUnique
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
FileUtils
.
PERMS_FILE
)
;
return
file
;
}
function
clearHistory
(
)
{
Services
.
obs
.
notifyObservers
(
null
"
browser
:
purge
-
session
-
history
"
)
;
}
function
_initTest
(
)
{
Services
.
prefs
.
setIntPref
(
"
browser
.
startup
.
page
"
0
)
;
registerCleanupFunction
(
(
)
=
>
Services
.
prefs
.
clearUserPref
(
"
browser
.
startup
.
page
"
)
)
;
}
async
function
waitForTelemetryEvent
(
category
value
)
{
info
(
"
waiting
for
telemetry
event
"
)
;
return
TestUtils
.
waitForCondition
(
(
)
=
>
{
let
events
=
Services
.
telemetry
.
snapshotEvents
(
Ci
.
nsITelemetry
.
DATASET_PRERELEASE_CHANNELS
false
)
.
content
;
if
(
!
events
)
{
return
null
;
}
events
=
events
.
filter
(
e
=
>
e
[
1
]
=
=
category
)
;
info
(
JSON
.
stringify
(
events
)
)
;
if
(
value
)
{
events
=
events
.
filter
(
e
=
>
e
[
4
]
.
includes
(
value
)
)
;
}
if
(
events
.
length
)
{
return
events
[
0
]
;
}
return
null
;
}
"
wait
and
retrieve
telemetry
event
"
)
;
}
async
function
setupMSExperimentWithMessage
(
message
)
{
Services
.
telemetry
.
clearEvents
(
)
;
Services
.
telemetry
.
snapshotEvents
(
Ci
.
nsITelemetry
.
DATASET_PRERELEASE_CHANNELS
true
)
;
let
doExperimentCleanup
=
await
ExperimentFakes
.
enrollWithFeatureConfig
(
{
featureId
:
"
pbNewtab
"
enabled
:
true
value
:
message
}
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
newtabpage
.
activity
-
stream
.
asrouter
.
providers
.
messaging
-
experiments
"
'
{
"
id
"
:
"
messaging
-
experiments
"
"
enabled
"
:
true
"
type
"
:
"
remote
-
experiments
"
"
messageGroups
"
:
[
"
pbNewtab
"
]
"
updateCycleInMs
"
:
0
}
'
]
]
}
)
;
await
ASRouter
.
_updateMessageProviders
(
)
;
await
ASRouter
.
loadMessagesFromAllProviders
(
)
;
registerCleanupFunction
(
async
(
)
=
>
{
Services
.
telemetry
.
clearEvents
(
)
;
ASRouter
.
unblockAll
(
)
;
SpecialPowers
.
popPrefEnv
(
)
;
await
ASRouter
.
_updateMessageProviders
(
)
;
await
ASRouter
.
loadMessagesFromAllProviders
(
)
;
}
)
;
Assert
.
ok
(
ASRouter
.
state
.
messages
.
find
(
m
=
>
m
.
id
.
includes
(
message
.
id
)
)
"
Experiment
message
found
in
ASRouter
state
"
)
;
return
doExperimentCleanup
;
}
_initTest
(
)
;
