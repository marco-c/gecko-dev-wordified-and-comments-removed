"
use
strict
"
;
const
PREF_ID_ALWAYS_ASK
=
"
browser
.
privatebrowsing
.
resetPBM
.
showConfirmationDialog
"
;
const
SELECTOR_TOOLBAR_BUTTON
=
"
#
reset
-
pbm
-
toolbar
-
button
"
;
const
SELECTOR_PANELVIEW
=
"
panel
#
reset
-
pbm
-
panel
"
;
const
SELECTOR_PANEL_HEADING
=
"
#
reset
-
pbm
-
panel
-
header
>
description
"
;
const
SELECTOR_PANEL_DESCRIPTION
=
"
#
reset
-
pbm
-
panel
-
description
"
;
const
SELECTOR_PANEL_CHECKBOX
=
"
#
reset
-
pbm
-
panel
-
checkbox
"
;
const
SELECTOR_PANEL_CONFIRM_BTN
=
"
#
reset
-
pbm
-
panel
-
confirm
-
button
"
;
const
SELECTOR_PANEL_CANCEL_BTN
=
"
#
reset
-
pbm
-
panel
-
cancel
-
button
"
;
const
SELECTOR_PANEL_COMPLETION_TOAST
=
"
#
confirmation
-
hint
"
;
async
function
waitForConfirmPanelShow
(
win
)
{
let
panelview
=
win
.
document
.
querySelector
(
SELECTOR_PANELVIEW
)
;
if
(
!
panelview
)
{
let
navToolbox
=
win
.
document
.
getElementById
(
"
navigator
-
toolbox
"
)
;
await
BrowserTestUtils
.
waitForMutationCondition
(
navToolbox
{
childList
:
true
subtree
:
true
}
(
)
=
>
{
panelview
=
win
.
document
.
querySelector
(
SELECTOR_PANELVIEW
)
;
return
!
!
panelview
;
}
)
;
}
if
(
BrowserTestUtils
.
is_visible
(
panelview
)
)
{
return
;
}
await
BrowserTestUtils
.
waitForEvent
(
panelview
.
closest
(
"
panel
"
)
"
popupshown
"
)
;
}
async
function
hideCompletionToast
(
win
)
{
let
promiseHidden
=
BrowserTestUtils
.
waitForEvent
(
win
.
ConfirmationHint
.
_panel
"
popuphidden
"
)
;
win
.
ConfirmationHint
.
_panel
.
hidePopup
(
)
;
await
promiseHidden
;
}
async
function
triggerResetBtn
(
win
expectPanelOpen
=
true
)
{
Assert
.
ok
(
PrivateBrowsingUtils
.
isWindowPrivate
(
win
)
"
Window
to
open
panel
is
in
PBM
.
"
)
;
let
shownPromise
;
if
(
expectPanelOpen
)
{
shownPromise
=
waitForConfirmPanelShow
(
win
)
;
}
await
BrowserTestUtils
.
synthesizeMouseAtCenter
(
SELECTOR_TOOLBAR_BUTTON
{
}
win
.
browsingContext
)
;
await
shownPromise
;
}
function
waitForConfirmPanelHidden
(
win
)
{
return
BrowserTestUtils
.
waitForEvent
(
win
.
document
.
querySelector
(
SELECTOR_PANELVIEW
)
.
closest
(
"
panel
"
)
"
popuphidden
"
)
;
}
function
waitForCompletionToastShown
(
win
)
{
win
.
ConfirmationHint
.
_ensurePanel
(
)
;
return
BrowserTestUtils
.
waitForEvent
(
win
.
document
.
querySelector
(
SELECTOR_PANEL_COMPLETION_TOAST
)
"
popupshown
"
)
;
}
function
waitForPBMDataClear
(
)
{
return
TestUtils
.
topicObserved
(
"
last
-
pb
-
context
-
exited
"
)
;
}
function
assertPanelVisibility
(
win
selector
expectVisible
)
{
let
panelview
=
win
.
document
.
querySelector
(
selector
)
;
if
(
expectVisible
)
{
Assert
.
ok
(
panelview
Panelview
element
{
selector
}
should
exist
.
)
;
Assert
.
ok
(
BrowserTestUtils
.
is_visible
(
panelview
)
Panelview
{
selector
}
should
be
visible
.
)
;
return
;
}
Assert
.
ok
(
!
panelview
|
|
!
BrowserTestUtils
.
is_visible
(
panelview
)
Panelview
{
selector
}
should
be
invisible
or
non
-
existent
.
)
;
}
add_task
(
async
function
test_toolbar_button_visibility
(
)
{
for
(
let
isEnabled
of
[
false
true
]
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
privatebrowsing
.
resetPBM
.
enabled
"
isEnabled
]
]
}
)
;
info
(
"
Test
that
the
toolbar
button
is
never
visible
in
a
normal
browsing
window
.
"
)
;
let
toolbarButtonNormalBrowsing
=
document
.
querySelector
(
SELECTOR_TOOLBAR_BUTTON
)
;
Assert
.
equal
(
!
!
toolbarButtonNormalBrowsing
isEnabled
"
Normal
browsing
toolbar
button
element
exists
depending
on
enabled
pref
state
.
"
)
;
if
(
toolbarButtonNormalBrowsing
)
{
Assert
.
ok
(
!
BrowserTestUtils
.
is_visible
(
toolbarButtonNormalBrowsing
)
"
Toolbar
button
is
not
visible
in
normal
browsing
"
)
;
}
info
(
"
Test
that
the
toolbar
button
is
visible
in
a
private
browsing
window
depending
on
enabled
pref
state
.
"
)
;
let
privateWindow
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
{
private
:
true
}
)
;
let
toolbarButtonPrivateBrowsing
=
privateWindow
.
document
.
querySelector
(
SELECTOR_TOOLBAR_BUTTON
)
;
Assert
.
equal
(
!
!
toolbarButtonPrivateBrowsing
isEnabled
"
Private
browsing
toolbar
button
element
exists
depending
on
enabled
pref
state
.
"
)
;
if
(
toolbarButtonPrivateBrowsing
)
{
Assert
.
equal
(
BrowserTestUtils
.
is_visible
(
toolbarButtonPrivateBrowsing
)
isEnabled
"
Toolbar
button
is
visible
in
private
browsing
if
enabled
.
"
)
;
}
await
BrowserTestUtils
.
closeWindow
(
privateWindow
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
}
)
;
add_task
(
async
function
test_panel
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
privatebrowsing
.
resetPBM
.
enabled
"
true
]
]
}
)
;
let
privateWin
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
{
private
:
true
}
)
;
assertPanelVisibility
(
privateWin
SELECTOR_PANELVIEW
false
)
;
assertPanelVisibility
(
privateWin
SELECTOR_PANEL_COMPLETION_TOAST
false
)
;
info
(
"
Open
the
panel
.
"
)
;
await
triggerResetBtn
(
privateWin
)
;
info
(
"
Check
that
all
expected
elements
are
present
and
visible
.
"
)
;
[
SELECTOR_PANEL_HEADING
SELECTOR_PANEL_DESCRIPTION
SELECTOR_PANEL_CHECKBOX
SELECTOR_PANEL_CONFIRM_BTN
SELECTOR_PANEL_CANCEL_BTN
]
.
forEach
(
elSelector
=
>
{
let
el
=
privateWin
.
document
.
querySelector
(
elSelector
)
;
Assert
.
ok
(
el
Panel
element
{
elSelector
}
exists
.
)
;
if
(
el
)
{
Assert
.
ok
(
BrowserTestUtils
.
is_visible
(
el
)
Panel
element
{
elSelector
}
is
visible
.
)
;
}
}
)
;
info
(
"
Inspect
checkbox
and
pref
state
.
"
)
;
let
checkbox
=
privateWin
.
document
.
querySelector
(
SELECTOR_PANEL_CHECKBOX
)
;
Assert
.
ok
(
checkbox
.
checked
"
The
'
always
ask
'
checkbox
should
be
checked
initially
.
"
)
;
Assert
.
ok
(
Services
.
prefs
.
getBoolPref
(
"
browser
.
privatebrowsing
.
resetPBM
.
showConfirmationDialog
"
)
"
The
always
ask
pref
should
be
true
.
"
)
;
info
(
"
Click
the
checkbox
to
uncheck
it
.
"
)
;
await
BrowserTestUtils
.
synthesizeMouseAtCenter
(
SELECTOR_PANEL_CHECKBOX
{
}
privateWin
.
browsingContext
)
;
Assert
.
ok
(
!
checkbox
.
checked
"
The
'
always
ask
'
checkbox
should
no
longer
be
checked
.
"
)
;
info
(
"
The
pref
shouldn
'
t
update
after
clicking
the
checkbox
.
It
only
updates
on
panel
confirm
.
"
)
;
Assert
.
ok
(
Services
.
prefs
.
getBoolPref
(
"
browser
.
privatebrowsing
.
resetPBM
.
showConfirmationDialog
"
)
"
The
always
ask
pref
should
still
be
true
.
"
)
;
info
(
"
Close
the
panel
via
cancel
.
"
)
;
let
promisePanelHidden
=
waitForConfirmPanelHidden
(
privateWin
)
;
await
BrowserTestUtils
.
synthesizeMouseAtCenter
(
SELECTOR_PANEL_CANCEL_BTN
{
}
privateWin
.
browsingContext
)
;
await
promisePanelHidden
;
assertPanelVisibility
(
privateWin
SELECTOR_PANELVIEW
false
)
;
assertPanelVisibility
(
privateWin
SELECTOR_PANEL_COMPLETION_TOAST
false
)
;
info
(
"
Reopen
the
panel
.
"
)
;
await
triggerResetBtn
(
privateWin
)
;
assertPanelVisibility
(
privateWin
SELECTOR_PANELVIEW
true
)
;
assertPanelVisibility
(
privateWin
SELECTOR_PANEL_COMPLETION_TOAST
false
)
;
Assert
.
ok
(
checkbox
.
checked
"
The
'
always
ask
'
checkbox
should
be
checked
again
.
"
)
;
Assert
.
ok
(
Services
.
prefs
.
getBoolPref
(
PREF_ID_ALWAYS_ASK
)
"
The
always
ask
pref
should
be
true
.
"
)
;
info
(
"
Test
the
checkbox
on
confirm
.
"
)
;
await
BrowserTestUtils
.
synthesizeMouseAtCenter
(
SELECTOR_PANEL_CHECKBOX
{
}
privateWin
.
browsingContext
)
;
Assert
.
ok
(
!
checkbox
.
checked
"
The
'
always
ask
'
checkbox
should
no
longer
be
checked
.
"
)
;
info
(
"
Close
the
panel
via
confirm
.
"
)
;
let
promiseDataCleared
=
waitForPBMDataClear
(
)
;
promisePanelHidden
=
waitForConfirmPanelHidden
(
privateWin
)
;
let
promiseCompletionToastShown
=
waitForCompletionToastShown
(
privateWin
)
;
await
BrowserTestUtils
.
synthesizeMouseAtCenter
(
SELECTOR_PANEL_CONFIRM_BTN
{
}
privateWin
.
browsingContext
)
;
await
promisePanelHidden
;
await
promiseCompletionToastShown
;
assertPanelVisibility
(
privateWin
SELECTOR_PANELVIEW
false
)
;
assertPanelVisibility
(
privateWin
SELECTOR_PANEL_COMPLETION_TOAST
true
)
;
await
promiseDataCleared
;
Assert
.
ok
(
!
Services
.
prefs
.
getBoolPref
(
PREF_ID_ALWAYS_ASK
)
"
The
always
ask
pref
should
now
be
false
.
"
)
;
info
(
"
Hide
the
completion
toast
.
"
)
;
await
hideCompletionToast
(
privateWin
)
;
info
(
"
Simulate
a
click
on
the
toolbar
button
.
This
time
the
panel
should
not
open
-
we
have
unchecked
'
always
ask
'
.
"
)
;
promiseDataCleared
=
waitForPBMDataClear
(
)
;
promiseCompletionToastShown
=
waitForCompletionToastShown
(
privateWin
)
;
await
triggerResetBtn
(
privateWin
false
)
;
info
(
"
Waiting
for
PBM
session
to
end
.
"
)
;
await
promiseDataCleared
;
info
(
"
Data
has
been
cleared
.
"
)
;
assertPanelVisibility
(
privateWin
SELECTOR_PANELVIEW
false
)
;
info
(
"
Waiting
for
the
completion
toast
to
show
.
"
)
;
await
promiseCompletionToastShown
;
assertPanelVisibility
(
privateWin
SELECTOR_PANELVIEW
false
)
;
assertPanelVisibility
(
privateWin
SELECTOR_PANEL_COMPLETION_TOAST
true
)
;
await
BrowserTestUtils
.
closeWindow
(
privateWin
)
;
Services
.
prefs
.
clearUserPref
(
PREF_ID_ALWAYS_ASK
)
;
}
)
;
add_task
(
async
function
test_reset_action
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
privatebrowsing
.
resetPBM
.
enabled
"
true
]
]
}
)
;
info
(
"
Open
a
few
private
browsing
windows
.
"
)
;
let
privateBrowsingWindows
=
[
]
;
for
(
let
i
=
0
;
i
<
3
;
i
+
=
1
)
{
privateBrowsingWindows
.
push
(
await
BrowserTestUtils
.
openNewBrowserWindow
(
{
private
:
true
}
)
)
;
}
info
(
"
Open
an
additional
normal
browsing
window
.
It
should
remain
open
on
reset
PBM
action
.
"
)
;
let
additionalNormalWindow
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
{
private
:
false
}
)
;
info
(
"
Use
one
of
the
PBM
windows
to
trigger
the
PBM
restart
action
.
"
)
;
let
[
win
]
=
privateBrowsingWindows
;
win
.
focus
(
)
;
Assert
.
ok
(
PrivateBrowsingUtils
.
isWindowPrivate
(
win
)
"
Window
for
PBM
reset
trigger
is
private
window
.
"
)
;
info
(
"
Load
a
bunch
of
tabs
in
the
private
window
.
"
)
;
let
loadPromises
=
[
"
https
:
/
/
example
.
com
"
"
https
:
/
/
example
.
org
"
"
https
:
/
/
example
.
net
"
]
.
map
(
async
url
=
>
{
let
tab
=
BrowserTestUtils
.
addTab
(
win
.
gBrowser
url
)
;
await
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
)
;
}
)
;
await
Promise
.
all
(
loadPromises
)
;
info
(
"
Switch
to
the
last
tab
.
"
)
;
win
.
gBrowser
.
selectedTab
=
win
.
gBrowser
.
tabs
[
win
.
gBrowser
.
tabs
.
length
-
1
]
;
Assert
.
ok
(
win
.
gBrowser
.
selectedBrowser
.
currentURI
.
spec
!
=
"
about
:
privatebrowsing
"
"
The
selected
tab
should
not
show
about
:
privatebrowsing
.
"
)
;
let
windowClosePromises
=
[
.
.
.
privateBrowsingWindows
.
filter
(
w
=
>
win
!
=
w
)
]
.
map
(
w
=
>
BrowserTestUtils
.
windowClosed
(
w
)
)
;
let
promisesTabsClosed
=
win
.
gBrowser
.
tabs
.
map
(
tab
=
>
BrowserTestUtils
.
waitForTabClosing
(
tab
)
)
;
info
(
"
Trigger
the
restart
PBM
action
"
)
;
let
promiseDataClear
=
waitForPBMDataClear
(
)
;
await
ResetPBMPanel
.
_restartPBM
(
win
)
;
info
(
"
Wait
for
all
the
windows
but
the
default
normal
window
and
the
private
window
which
triggered
the
reset
action
to
be
closed
.
"
)
;
await
Promise
.
all
(
windowClosePromises
)
;
info
(
"
Wait
for
tabs
in
the
trigger
private
window
to
close
.
"
)
;
await
Promise
.
all
(
promisesTabsClosed
)
;
info
(
"
Wait
for
data
to
be
cleared
.
"
)
;
await
promiseDataClear
;
Assert
.
equal
(
win
.
gBrowser
.
tabs
.
length
1
"
Should
only
have
1
tab
remaining
.
"
)
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
win
.
gBrowser
.
selectedBrowser
.
currentURI
.
spec
=
=
"
about
:
privatebrowsing
"
)
;
Assert
.
equal
(
win
.
gBrowser
.
selectedBrowser
.
currentURI
.
spec
"
about
:
privatebrowsing
"
"
The
remaining
tab
should
point
to
about
:
privatebrowsing
.
"
)
;
await
BrowserTestUtils
.
closeWindow
(
win
)
;
await
BrowserTestUtils
.
closeWindow
(
additionalNormalWindow
)
;
}
)
;
