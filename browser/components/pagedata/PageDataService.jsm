"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
PageDataService
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
BrowserWindowTracker
:
"
resource
:
/
/
/
modules
/
BrowserWindowTracker
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
E10SUtils
:
"
resource
:
/
/
gre
/
modules
/
E10SUtils
.
jsm
"
EventEmitter
:
"
resource
:
/
/
gre
/
modules
/
EventEmitter
.
jsm
"
HiddenFrame
:
"
resource
:
/
/
gre
/
modules
/
HiddenFrame
.
jsm
"
PromiseUtils
:
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
logConsole
"
function
(
)
{
return
console
.
createInstance
(
{
prefix
:
"
PageData
"
maxLogLevel
:
Services
.
prefs
.
getBoolPref
(
"
browser
.
pagedata
.
log
"
false
)
?
"
Debug
"
:
"
Warn
"
}
)
;
}
)
;
XPCOMUtils
.
defineLazyServiceGetters
(
this
{
idleService
:
[
"
mozilla
.
org
/
widget
/
useridleservice
;
1
"
"
nsIUserIdleService
"
]
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
fetchIdleTime
"
"
browser
.
pagedata
.
fetchIdleTime
"
300
)
;
const
ALLOWED_SCHEMES
=
[
"
http
"
"
https
"
"
data
"
"
blob
"
]
;
const
BACKGROUND_WIDTH
=
1024
;
const
BACKGROUND_HEIGHT
=
768
;
function
shift
(
set
)
{
let
iter
=
set
.
values
(
)
;
let
{
value
done
}
=
iter
.
next
(
)
;
if
(
done
)
{
return
undefined
;
}
set
.
delete
(
value
)
;
return
value
;
}
class
HiddenBrowserManager
{
#
frame
=
null
;
#
browsers
=
0
;
async
#
acquireBrowser
(
)
{
this
.
#
browsers
+
+
;
if
(
!
this
.
#
frame
)
{
this
.
#
frame
=
new
HiddenFrame
(
)
;
}
let
frame
=
await
this
.
#
frame
.
get
(
)
;
let
doc
=
frame
.
document
;
let
browser
=
doc
.
createXULElement
(
"
browser
"
)
;
browser
.
setAttribute
(
"
remote
"
"
true
"
)
;
browser
.
setAttribute
(
"
type
"
"
content
"
)
;
browser
.
setAttribute
(
"
style
"
width
:
{
BACKGROUND_WIDTH
}
px
;
min
-
width
:
{
BACKGROUND_WIDTH
}
px
;
height
:
{
BACKGROUND_HEIGHT
}
px
;
min
-
height
:
{
BACKGROUND_HEIGHT
}
px
;
)
;
browser
.
setAttribute
(
"
maychangeremoteness
"
"
true
"
)
;
doc
.
documentElement
.
appendChild
(
browser
)
;
return
browser
;
}
#
releaseBrowser
(
browser
)
{
browser
.
remove
(
)
;
this
.
#
browsers
-
-
;
if
(
this
.
#
browsers
=
=
0
)
{
this
.
#
frame
.
destroy
(
)
;
this
.
#
frame
=
null
;
}
}
async
withHiddenBrowser
(
callback
)
{
let
browser
=
await
this
.
#
acquireBrowser
(
)
;
try
{
return
await
callback
(
browser
)
;
}
finally
{
this
.
#
releaseBrowser
(
browser
)
;
}
}
}
class
PageDataCache
{
#
cache
=
new
Map
(
)
;
set
(
url
pageData
)
{
let
entry
=
this
.
#
cache
.
get
(
url
)
;
if
(
entry
)
{
entry
.
pageData
=
pageData
;
}
}
get
(
url
)
{
let
entry
=
this
.
#
cache
.
get
(
url
)
;
return
entry
?
.
pageData
?
?
null
;
}
lockData
(
actor
url
)
{
let
entry
=
this
.
#
cache
.
get
(
url
)
;
if
(
entry
)
{
entry
.
actors
.
add
(
actor
)
;
}
else
{
this
.
#
cache
.
set
(
url
{
pageData
:
undefined
actors
:
new
Set
(
[
actor
]
)
}
)
;
}
}
unlockData
(
actor
url
)
{
let
entries
=
[
]
;
if
(
url
)
{
let
entry
=
this
.
#
cache
.
get
(
url
)
;
if
(
!
entry
)
{
return
;
}
entries
.
push
(
[
url
entry
]
)
;
}
else
{
entries
=
[
.
.
.
this
.
#
cache
]
;
}
for
(
let
[
entryUrl
entry
]
of
entries
)
{
if
(
entry
.
actors
.
delete
(
actor
)
)
{
if
(
entry
.
actors
.
size
=
=
0
)
{
this
.
#
cache
.
delete
(
entryUrl
)
;
}
}
}
}
}
const
PageDataService
=
new
(
class
PageDataService
extends
EventEmitter
{
#
pageDataCache
=
new
PageDataCache
(
)
;
#
backgroundFetches
=
0
;
#
backgroundQueue
=
new
Set
(
)
;
#
userIsIdle
=
false
;
#
browserManager
=
new
HiddenBrowserManager
(
)
;
#
backgroundBrowsers
=
new
WeakMap
(
)
;
#
trackedWindows
=
new
Map
(
)
;
constructor
(
)
{
super
(
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
MAX_BACKGROUND_FETCHES
"
"
browser
.
pagedata
.
maxBackgroundFetches
"
5
(
)
=
>
this
.
#
startBackgroundWorkers
(
)
)
;
}
init
(
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
"
browser
.
pagedata
.
enabled
"
false
)
)
{
return
;
}
ChromeUtils
.
registerWindowActor
(
"
PageData
"
{
parent
:
{
moduleURI
:
"
resource
:
/
/
/
actors
/
PageDataParent
.
jsm
"
}
child
:
{
moduleURI
:
"
resource
:
/
/
/
actors
/
PageDataChild
.
jsm
"
events
:
{
DOMContentLoaded
:
{
}
pageshow
:
{
}
}
}
}
)
;
logConsole
.
debug
(
"
Service
started
"
)
;
for
(
let
win
of
BrowserWindowTracker
.
orderedWindows
)
{
if
(
!
win
.
closed
)
{
for
(
let
tab
of
win
.
gBrowser
.
tabs
)
{
let
parent
=
tab
.
linkedBrowser
.
browsingContext
?
.
currentWindowGlobal
.
getActor
(
"
PageData
"
)
;
parent
.
sendAsyncMessage
(
"
PageData
:
CheckLoaded
"
)
;
}
}
}
idleService
.
addIdleObserver
(
this
fetchIdleTime
)
;
}
uninit
(
)
{
logConsole
.
debug
(
"
Service
stopped
"
)
;
}
#
trackBrowser
(
browser
)
{
let
window
=
browser
.
ownerGlobal
;
let
browsers
=
this
.
#
trackedWindows
.
get
(
window
)
;
if
(
browsers
)
{
browsers
.
add
(
browser
)
;
return
;
}
browsers
=
new
Set
(
[
browser
]
)
;
this
.
#
trackedWindows
.
set
(
window
browsers
)
;
window
.
addEventListener
(
"
unload
"
(
)
=
>
{
for
(
let
closedBrowser
of
browsers
)
{
this
.
unlockEntry
(
closedBrowser
)
;
}
this
.
#
trackedWindows
.
delete
(
window
)
;
}
)
;
window
.
addEventListener
(
"
TabClose
"
(
{
target
:
tab
}
)
=
>
{
let
closedBrowser
=
tab
.
linkedBrowser
;
this
.
unlockEntry
(
closedBrowser
)
;
browsers
.
delete
(
closedBrowser
)
;
}
)
;
}
lockEntry
(
actor
url
)
{
this
.
#
pageDataCache
.
lockData
(
actor
url
)
;
}
unlockEntry
(
actor
url
)
{
this
.
#
pageDataCache
.
unlockData
(
actor
url
)
;
}
async
pageLoaded
(
actor
url
)
{
let
uri
=
Services
.
io
.
newURI
(
url
)
;
if
(
!
ALLOWED_SCHEMES
.
includes
(
uri
.
scheme
)
)
{
return
;
}
let
browser
=
actor
.
browsingContext
?
.
embedderElement
;
if
(
!
browser
)
{
return
;
}
let
backgroundResolve
=
this
.
#
backgroundBrowsers
.
get
(
browser
)
;
if
(
backgroundResolve
)
{
backgroundResolve
(
actor
)
;
return
;
}
if
(
!
this
.
#
isATabBrowser
(
browser
)
)
{
return
;
}
try
{
let
data
=
await
actor
.
collectPageData
(
)
;
if
(
data
)
{
this
.
#
trackBrowser
(
browser
)
;
this
.
lockEntry
(
browser
data
.
url
)
;
this
.
pageDataDiscovered
(
data
)
;
}
}
catch
(
e
)
{
logConsole
.
error
(
e
)
;
}
}
pageDataDiscovered
(
pageData
)
{
logConsole
.
debug
(
"
Discovered
page
data
"
pageData
)
;
this
.
#
pageDataCache
.
set
(
pageData
.
url
{
.
.
.
pageData
data
:
pageData
.
data
?
?
{
}
}
)
;
this
.
emit
(
"
page
-
data
"
pageData
)
;
}
getCached
(
url
)
{
return
this
.
#
pageDataCache
.
get
(
url
)
;
}
async
fetchPageData
(
url
)
{
return
this
.
#
browserManager
.
withHiddenBrowser
(
async
browser
=
>
{
try
{
let
{
promise
resolve
}
=
PromiseUtils
.
defer
(
)
;
this
.
#
backgroundBrowsers
.
set
(
browser
resolve
)
;
let
principal
=
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
;
let
oa
=
E10SUtils
.
predictOriginAttributes
(
{
browser
}
)
;
let
loadURIOptions
=
{
triggeringPrincipal
:
principal
remoteType
:
E10SUtils
.
getRemoteTypeForURI
(
url
true
false
E10SUtils
.
DEFAULT_REMOTE_TYPE
null
oa
)
}
;
browser
.
loadURI
(
url
loadURIOptions
)
;
let
actor
=
await
promise
;
return
await
actor
.
collectPageData
(
)
;
}
finally
{
this
.
#
backgroundBrowsers
.
delete
(
browser
)
;
}
}
)
;
}
observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
"
idle
"
:
logConsole
.
debug
(
"
User
went
idle
"
)
;
this
.
#
userIsIdle
=
true
;
this
.
#
startBackgroundWorkers
(
)
;
break
;
case
"
active
"
:
logConsole
.
debug
(
"
User
became
active
"
)
;
this
.
#
userIsIdle
=
false
;
break
;
}
}
#
startBackgroundWorkers
(
)
{
if
(
!
this
.
#
userIsIdle
)
{
return
;
}
let
toStart
;
if
(
this
.
MAX_BACKGROUND_FETCHES
)
{
toStart
=
this
.
MAX_BACKGROUND_FETCHES
-
this
.
#
backgroundFetches
;
}
else
{
toStart
=
this
.
#
backgroundQueue
.
size
;
}
for
(
let
i
=
0
;
i
<
toStart
;
i
+
+
)
{
this
.
#
backgroundFetch
(
)
;
}
}
async
#
backgroundFetch
(
)
{
this
.
#
backgroundFetches
+
+
;
let
url
=
shift
(
this
.
#
backgroundQueue
)
;
while
(
url
)
{
try
{
let
pageData
=
await
this
.
fetchPageData
(
url
)
;
if
(
pageData
)
{
this
.
#
pageDataCache
.
set
(
url
pageData
)
;
this
.
emit
(
"
page
-
data
"
pageData
)
;
}
}
catch
(
e
)
{
logConsole
.
error
(
e
)
;
}
if
(
!
this
.
#
userIsIdle
|
|
(
this
.
MAX_BACKGROUND_FETCHES
>
0
&
&
this
.
#
backgroundFetches
>
this
.
MAX_BACKGROUND_FETCHES
)
)
{
break
;
}
url
=
shift
(
this
.
#
backgroundQueue
)
;
}
this
.
#
backgroundFetches
-
-
;
}
queueFetch
(
url
)
{
this
.
#
backgroundQueue
.
add
(
url
)
;
this
.
#
startBackgroundWorkers
(
)
;
}
#
isATabBrowser
(
browser
)
{
return
browser
.
ownerGlobal
.
gBrowser
?
.
getTabForBrowser
(
browser
)
;
}
}
)
(
)
;
