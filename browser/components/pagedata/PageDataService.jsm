"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
PageDataService
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
BrowserWindowTracker
:
"
resource
:
/
/
/
modules
/
BrowserWindowTracker
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
EventEmitter
:
"
resource
:
/
/
gre
/
modules
/
EventEmitter
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
logConsole
"
function
(
)
{
return
console
.
createInstance
(
{
prefix
:
"
PageData
"
maxLogLevel
:
Services
.
prefs
.
getBoolPref
(
"
browser
.
pagedata
.
log
"
false
)
?
"
Debug
"
:
"
Warn
"
}
)
;
}
)
;
const
ALLOWED_SCHEMES
=
[
"
http
"
"
https
"
"
data
"
"
blob
"
]
;
const
PageDataService
=
new
(
class
PageDataService
extends
EventEmitter
{
#
pageDataCache
=
new
Map
(
)
;
init
(
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
"
browser
.
pagedata
.
enabled
"
false
)
)
{
return
;
}
ChromeUtils
.
registerWindowActor
(
"
PageData
"
{
parent
:
{
moduleURI
:
"
resource
:
/
/
/
actors
/
PageDataParent
.
jsm
"
}
child
:
{
moduleURI
:
"
resource
:
/
/
/
actors
/
PageDataChild
.
jsm
"
events
:
{
DOMContentLoaded
:
{
}
pageshow
:
{
}
}
}
}
)
;
logConsole
.
debug
(
"
Service
started
"
)
;
for
(
let
win
of
BrowserWindowTracker
.
orderedWindows
)
{
if
(
!
win
.
closed
)
{
for
(
let
tab
of
win
.
gBrowser
.
tabs
)
{
let
parent
=
tab
.
linkedBrowser
.
browsingContext
.
currentWindowGlobal
.
getActor
(
"
PageData
"
)
;
parent
.
sendAsyncMessage
(
"
PageData
:
CheckLoaded
"
)
;
}
}
}
}
uninit
(
)
{
logConsole
.
debug
(
"
Service
stopped
"
)
;
}
async
pageLoaded
(
actor
url
)
{
let
uri
=
Services
.
io
.
newURI
(
url
)
;
if
(
!
ALLOWED_SCHEMES
.
includes
(
uri
.
scheme
)
)
{
return
;
}
let
browser
=
actor
.
browsingContext
?
.
embedderElement
;
if
(
!
browser
|
|
!
this
.
#
isATabBrowser
(
browser
)
)
{
return
;
}
let
data
=
await
actor
.
collectPageData
(
)
;
this
.
pageDataDiscovered
(
url
data
)
;
}
pageDataDiscovered
(
url
data
)
{
logConsole
.
debug
(
"
Discovered
page
data
"
url
data
)
;
let
pageData
=
{
url
date
:
Date
.
now
(
)
data
}
;
this
.
#
pageDataCache
.
set
(
url
pageData
)
;
this
.
emit
(
data
.
length
?
"
page
-
data
"
:
"
no
-
page
-
data
"
pageData
)
;
}
getCached
(
url
)
{
return
this
.
#
pageDataCache
.
get
(
url
)
?
?
null
;
}
async
queueFetch
(
url
)
{
let
pageData
=
{
url
date
:
Date
.
now
(
)
data
:
[
]
}
;
this
.
#
pageDataCache
.
set
(
url
pageData
)
;
this
.
emit
(
pageData
.
data
.
length
?
"
page
-
data
"
:
"
no
-
page
-
data
"
pageData
)
;
}
#
isATabBrowser
(
browser
)
{
return
browser
.
ownerGlobal
.
gBrowser
?
.
getTabForBrowser
(
browser
)
;
}
}
)
(
)
;
