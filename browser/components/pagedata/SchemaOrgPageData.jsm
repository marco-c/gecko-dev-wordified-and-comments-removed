"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
SchemaOrgPageData
"
]
;
const
{
PageDataSchema
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
/
modules
/
pagedata
/
PageDataSchema
.
jsm
"
)
;
function
getProp
(
element
prop
)
{
const
parseUrl
=
(
urlElement
attr
)
=
>
{
if
(
!
urlElement
.
hasAttribute
(
attr
)
)
{
return
"
"
;
}
try
{
let
url
=
new
URL
(
urlElement
.
getAttribute
(
attr
)
urlElement
.
ownerDocument
.
documentURI
)
;
return
url
.
toString
(
)
;
}
catch
(
e
)
{
return
"
"
;
}
}
;
return
Array
.
from
(
element
.
querySelectorAll
(
[
itemprop
~
=
'
{
prop
}
'
]
:
not
(
[
itemscope
]
)
)
propElement
=
>
{
switch
(
propElement
.
localName
)
{
case
"
meta
"
:
return
propElement
.
getAttribute
(
"
content
"
)
?
?
"
"
;
case
"
audio
"
:
case
"
embed
"
:
case
"
iframe
"
:
case
"
img
"
:
case
"
source
"
:
case
"
track
"
:
case
"
video
"
:
return
parseUrl
(
propElement
"
src
"
)
;
case
"
object
"
:
return
parseUrl
(
propElement
"
data
"
)
;
case
"
a
"
:
case
"
area
"
:
case
"
link
"
:
return
parseUrl
(
propElement
"
href
"
)
;
case
"
data
"
:
case
"
meter
"
:
return
propElement
.
getAttribute
(
"
value
"
)
;
case
"
time
"
:
if
(
propElement
.
hasAtribute
(
"
datetime
"
)
)
{
return
propElement
.
getAttribute
(
"
datetime
"
)
;
}
return
propElement
.
textContent
;
default
:
if
(
propElement
.
hasAttribute
(
"
content
"
)
)
{
return
propElement
.
getAttribute
(
"
content
"
)
;
}
return
propElement
.
textContent
;
}
}
)
;
}
function
collectProduct
(
pageData
element
)
{
let
images
=
getProp
(
element
"
image
"
)
;
if
(
images
.
length
)
{
pageData
.
image
=
images
[
0
]
;
}
let
descriptions
=
getProp
(
element
"
description
"
)
;
if
(
descriptions
.
length
)
{
pageData
.
description
=
descriptions
[
0
]
;
}
pageData
.
data
[
PageDataSchema
.
DATA_TYPE
.
PRODUCT
]
=
{
name
:
getProp
(
element
"
name
"
)
[
0
]
}
;
let
prices
=
getProp
(
element
"
price
"
)
;
if
(
prices
.
length
)
{
let
price
=
parseFloat
(
prices
[
0
]
)
;
if
(
!
isNaN
(
price
)
)
{
pageData
.
data
[
PageDataSchema
.
DATA_TYPE
.
PRODUCT
]
.
price
=
{
value
:
price
currency
:
getProp
(
element
"
priceCurrency
"
)
[
0
]
}
;
}
}
}
const
SchemaOrgPageData
=
{
collect
(
document
)
{
let
pageData
=
{
data
:
{
}
}
;
let
scopes
=
document
.
querySelectorAll
(
"
[
itemscope
]
[
itemtype
^
=
'
https
:
/
/
schema
.
org
/
'
]
[
itemscope
]
[
itemtype
^
=
'
http
:
/
/
schema
.
org
/
'
]
"
)
;
for
(
let
scope
of
scopes
)
{
let
itemType
=
scope
.
getAttribute
(
"
itemtype
"
)
;
if
(
itemType
.
startsWith
(
"
https
:
/
/
"
)
)
{
itemType
=
itemType
.
substring
(
8
)
;
}
else
{
itemType
=
itemType
.
substring
(
7
)
;
}
switch
(
itemType
)
{
case
"
schema
.
org
/
Product
"
:
if
(
!
(
PageDataSchema
.
DATA_TYPE
.
PRODUCT
in
pageData
.
data
)
)
{
collectProduct
(
pageData
scope
)
;
}
break
;
case
"
schema
.
org
/
Organization
"
:
pageData
.
siteName
=
getProp
(
scope
"
name
"
)
[
0
]
;
break
;
}
}
return
pageData
;
}
}
;
