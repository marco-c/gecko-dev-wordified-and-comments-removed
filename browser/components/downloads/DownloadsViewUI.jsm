"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
DownloadsViewUI
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
BrowserWindowTracker
:
"
resource
:
/
/
/
modules
/
BrowserWindowTracker
.
jsm
"
Downloads
:
"
resource
:
/
/
gre
/
modules
/
Downloads
.
jsm
"
DownloadUtils
:
"
resource
:
/
/
gre
/
modules
/
DownloadUtils
.
jsm
"
DownloadsCommon
:
"
resource
:
/
/
/
modules
/
DownloadsCommon
.
jsm
"
FileUtils
:
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
OS
:
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
}
)
;
const
HTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
var
gDownloadElementButtons
=
{
cancel
:
{
commandName
:
"
downloadsCmd_cancel
"
l10nId
:
"
download
-
cancel
"
descriptionL10nId
:
"
download
-
cancel
-
description
"
iconClass
:
"
downloadIconCancel
"
}
retry
:
{
commandName
:
"
downloadsCmd_retry
"
l10nId
:
"
download
-
retry
"
descriptionL10nId
:
"
download
-
retry
-
description
"
iconClass
:
"
downloadIconRetry
"
}
show
:
{
commandName
:
"
downloadsCmd_show
"
l10nId
:
"
download
-
show
"
descriptionL10nId
:
"
download
-
show
-
description
"
iconClass
:
"
downloadIconShow
"
}
subviewOpenOrRemoveFile
:
{
commandName
:
"
downloadsCmd_showBlockedInfo
"
l10nId
:
"
download
-
open
-
or
-
remove
-
file
"
descriptionL10nId
:
"
download
-
show
-
more
-
information
-
description
"
iconClass
:
"
downloadIconSubviewArrow
"
}
askOpenOrRemoveFile
:
{
commandName
:
"
downloadsCmd_chooseOpen
"
l10nId
:
"
download
-
open
-
or
-
remove
-
file
"
iconClass
:
"
downloadIconShow
"
}
askRemoveFileOrAllow
:
{
commandName
:
"
downloadsCmd_chooseUnblock
"
l10nId
:
"
download
-
remove
-
file
-
or
-
allow
"
iconClass
:
"
downloadIconShow
"
}
removeFile
:
{
commandName
:
"
downloadsCmd_confirmBlock
"
l10nId
:
"
download
-
remove
-
file
"
iconClass
:
"
downloadIconCancel
"
}
}
;
var
gDownloadListItemFragments
=
new
WeakMap
(
)
;
var
DownloadsViewUI
=
{
isCommandName
(
name
)
{
return
name
.
startsWith
(
"
cmd_
"
)
|
|
name
.
startsWith
(
"
downloadsCmd_
"
)
;
}
getDisplayName
(
download
)
{
return
download
.
target
.
path
?
OS
.
Path
.
basename
(
download
.
target
.
path
)
:
download
.
source
.
url
;
}
getSizeWithUnits
(
download
)
{
if
(
download
.
target
.
size
=
=
=
undefined
)
{
return
"
"
;
}
let
[
size
unit
]
=
DownloadUtils
.
convertByteUnits
(
download
.
target
.
size
)
;
return
DownloadsCommon
.
strings
.
sizeWithUnits
(
size
unit
)
;
}
}
;
this
.
DownloadsViewUI
.
BaseView
=
class
{
canClearDownloads
(
nodeContainer
)
{
for
(
let
elt
=
nodeContainer
.
lastChild
;
elt
;
elt
=
elt
.
previousSibling
)
{
let
download
=
elt
.
_shell
.
download
;
if
(
download
.
stopped
&
&
!
(
download
.
canceled
&
&
download
.
hasPartialData
)
)
{
return
true
;
}
}
return
false
;
}
}
;
this
.
DownloadsViewUI
.
DownloadElementShell
=
function
(
)
{
}
;
this
.
DownloadsViewUI
.
DownloadElementShell
.
prototype
=
{
element
:
null
ensureActive
(
)
{
if
(
!
this
.
_active
)
{
this
.
_active
=
true
;
this
.
connect
(
)
;
this
.
onChanged
(
)
;
}
}
get
active
(
)
{
return
!
!
this
.
_active
;
}
connect
(
)
{
let
document
=
this
.
element
.
ownerDocument
;
let
downloadListItemFragment
=
gDownloadListItemFragments
.
get
(
document
)
;
if
(
!
downloadListItemFragment
)
{
let
MozXULElement
=
document
.
defaultView
.
MozXULElement
;
downloadListItemFragment
=
MozXULElement
.
parseXULToFragment
(
<
hbox
class
=
"
downloadMainArea
"
flex
=
"
1
"
align
=
"
center
"
>
<
stack
>
<
image
class
=
"
downloadTypeIcon
"
validate
=
"
always
"
/
>
<
image
class
=
"
downloadBlockedBadge
"
/
>
<
/
stack
>
<
vbox
class
=
"
downloadContainer
"
flex
=
"
1
"
pack
=
"
center
"
>
<
description
class
=
"
downloadTarget
"
crop
=
"
center
"
/
>
<
description
class
=
"
downloadDetails
downloadDetailsNormal
"
crop
=
"
end
"
/
>
<
description
class
=
"
downloadDetails
downloadDetailsHover
"
crop
=
"
end
"
/
>
<
description
class
=
"
downloadDetails
downloadDetailsButtonHover
"
crop
=
"
end
"
/
>
<
/
vbox
>
<
/
hbox
>
<
toolbarseparator
/
>
<
button
class
=
"
downloadButton
"
oncommand
=
"
DownloadsView
.
onDownloadButton
(
event
)
;
"
/
>
)
;
gDownloadListItemFragments
.
set
(
document
downloadListItemFragment
)
;
}
this
.
element
.
setAttribute
(
"
active
"
true
)
;
this
.
element
.
setAttribute
(
"
orient
"
"
horizontal
"
)
;
this
.
element
.
setAttribute
(
"
onclick
"
"
DownloadsView
.
onDownloadClick
(
event
)
;
"
)
;
this
.
element
.
appendChild
(
document
.
importNode
(
downloadListItemFragment
true
)
)
;
for
(
let
[
propertyName
selector
]
of
[
[
"
_downloadTypeIcon
"
"
.
downloadTypeIcon
"
]
[
"
_downloadTarget
"
"
.
downloadTarget
"
]
[
"
_downloadDetailsNormal
"
"
.
downloadDetailsNormal
"
]
[
"
_downloadDetailsHover
"
"
.
downloadDetailsHover
"
]
[
"
_downloadDetailsButtonHover
"
"
.
downloadDetailsButtonHover
"
]
[
"
_downloadButton
"
"
.
downloadButton
"
]
]
)
{
this
[
propertyName
]
=
this
.
element
.
querySelector
(
selector
)
;
}
let
progress
=
this
.
_downloadProgress
=
document
.
createElementNS
(
HTML_NS
"
progress
"
)
;
progress
.
className
=
"
downloadProgress
"
;
progress
.
setAttribute
(
"
max
"
"
100
"
)
;
this
.
_downloadTarget
.
insertAdjacentElement
(
"
afterend
"
progress
)
;
}
string
(
l10nId
)
{
return
this
.
element
.
ownerDocument
.
getElementById
(
"
downloadsStrings
"
)
.
getAttribute
(
"
string
-
"
+
l10nId
)
;
}
get
image
(
)
{
if
(
!
this
.
download
.
target
.
path
)
{
return
"
moz
-
icon
:
/
/
.
unknown
?
size
=
32
"
;
}
return
"
moz
-
icon
:
/
/
"
+
this
.
download
.
target
.
path
+
"
?
size
=
32
"
+
(
this
.
download
.
succeeded
?
"
&
state
=
normal
"
:
"
"
)
;
}
get
browserWindow
(
)
{
return
BrowserWindowTracker
.
getTopWindow
(
)
;
}
showDisplayNameAndIcon
(
displayName
icon
)
{
this
.
_downloadTarget
.
setAttribute
(
"
value
"
displayName
)
;
this
.
_downloadTarget
.
setAttribute
(
"
tooltiptext
"
displayName
)
;
this
.
_downloadTypeIcon
.
setAttribute
(
"
src
"
icon
)
;
}
showProgress
(
mode
value
paused
)
{
if
(
mode
=
=
"
undetermined
"
)
{
this
.
_downloadProgress
.
removeAttribute
(
"
value
"
)
;
}
else
{
this
.
_downloadProgress
.
setAttribute
(
"
value
"
value
)
;
}
this
.
_downloadProgress
.
toggleAttribute
(
"
paused
"
!
!
paused
)
;
}
showStatus
(
status
hoverStatus
=
status
)
{
this
.
_downloadDetailsNormal
.
setAttribute
(
"
value
"
status
)
;
this
.
_downloadDetailsNormal
.
setAttribute
(
"
tooltiptext
"
status
)
;
this
.
_downloadDetailsHover
.
setAttribute
(
"
value
"
hoverStatus
)
;
}
showStatusWithDetails
(
stateLabel
hoverStatus
)
{
let
[
displayHost
]
=
DownloadUtils
.
getURIHost
(
this
.
download
.
source
.
referrer
|
|
this
.
download
.
source
.
url
)
;
let
[
displayDate
]
=
DownloadUtils
.
getReadableDates
(
new
Date
(
this
.
download
.
endTime
)
)
;
let
firstPart
=
DownloadsCommon
.
strings
.
statusSeparator
(
stateLabel
displayHost
)
;
let
fullStatus
=
DownloadsCommon
.
strings
.
statusSeparator
(
firstPart
displayDate
)
;
if
(
!
this
.
isPanel
)
{
this
.
showStatus
(
fullStatus
)
;
}
else
{
this
.
showStatus
(
stateLabel
hoverStatus
|
|
fullStatus
)
;
}
}
showButton
(
type
)
{
let
{
commandName
l10nId
descriptionL10nId
iconClass
}
=
gDownloadElementButtons
[
type
]
;
this
.
buttonCommandName
=
commandName
;
let
labelAttribute
=
this
.
isPanel
?
"
aria
-
label
"
:
"
tooltiptext
"
;
this
.
_downloadButton
.
setAttribute
(
labelAttribute
this
.
string
(
l10nId
)
)
;
if
(
this
.
isPanel
&
&
descriptionL10nId
)
{
this
.
_downloadDetailsButtonHover
.
setAttribute
(
"
value
"
this
.
string
(
descriptionL10nId
)
)
;
}
this
.
_downloadButton
.
setAttribute
(
"
class
"
"
downloadButton
"
+
iconClass
)
;
this
.
_downloadButton
.
removeAttribute
(
"
hidden
"
)
;
}
hideButton
(
)
{
this
.
_downloadButton
.
setAttribute
(
"
hidden
"
"
true
"
)
;
}
lastEstimatedSecondsLeft
:
Infinity
_updateState
(
)
{
this
.
showDisplayNameAndIcon
(
DownloadsViewUI
.
getDisplayName
(
this
.
download
)
this
.
image
)
;
this
.
element
.
setAttribute
(
"
state
"
DownloadsCommon
.
stateOfDownload
(
this
.
download
)
)
;
if
(
!
this
.
download
.
stopped
)
{
this
.
showButton
(
"
cancel
"
)
;
}
this
.
lastEstimatedSecondsLeft
=
Infinity
;
this
.
_updateStateInner
(
)
;
}
_updateStateInner
(
)
{
let
progressPaused
=
false
;
if
(
!
this
.
download
.
stopped
)
{
let
totalBytes
=
this
.
download
.
hasProgress
?
this
.
download
.
totalBytes
:
-
1
;
let
[
status
newEstimatedSecondsLeft
]
=
DownloadUtils
.
getDownloadStatus
(
this
.
download
.
currentBytes
totalBytes
this
.
download
.
speed
this
.
lastEstimatedSecondsLeft
)
;
this
.
lastEstimatedSecondsLeft
=
newEstimatedSecondsLeft
;
this
.
showStatus
(
status
)
;
}
else
{
let
verdict
=
"
"
;
if
(
this
.
download
.
succeeded
)
{
if
(
this
.
download
.
target
.
exists
)
{
this
.
element
.
setAttribute
(
"
exists
"
"
true
"
)
;
let
sizeWithUnits
=
DownloadsViewUI
.
getSizeWithUnits
(
this
.
download
)
;
if
(
this
.
isPanel
)
{
let
status
=
DownloadsCommon
.
strings
.
stateCompleted
;
if
(
sizeWithUnits
)
{
status
=
DownloadsCommon
.
strings
.
statusSeparator
(
status
sizeWithUnits
)
;
}
this
.
showStatus
(
status
this
.
string
(
"
download
-
open
-
file
-
description
"
)
)
;
}
else
{
this
.
showStatusWithDetails
(
sizeWithUnits
|
|
DownloadsCommon
.
strings
.
sizeUnknown
)
;
}
this
.
showButton
(
"
show
"
)
;
}
else
{
this
.
element
.
removeAttribute
(
"
exists
"
)
;
let
label
=
DownloadsCommon
.
strings
.
fileMovedOrMissing
;
this
.
showStatusWithDetails
(
label
label
)
;
this
.
hideButton
(
)
;
}
}
else
if
(
this
.
download
.
error
)
{
if
(
this
.
download
.
error
.
becauseBlockedByParentalControls
)
{
this
.
showStatusWithDetails
(
DownloadsCommon
.
strings
.
stateBlockedParentalControls
)
;
this
.
hideButton
(
)
;
}
else
if
(
this
.
download
.
error
.
becauseBlockedByReputationCheck
)
{
verdict
=
this
.
download
.
error
.
reputationCheckVerdict
;
let
hover
=
"
"
;
if
(
!
this
.
download
.
hasBlockedData
)
{
this
.
hideButton
(
)
;
}
else
if
(
this
.
isPanel
)
{
this
.
showButton
(
"
subviewOpenOrRemoveFile
"
)
;
hover
=
this
.
string
(
"
download
-
show
-
more
-
information
-
description
"
)
;
}
else
{
switch
(
verdict
)
{
case
Downloads
.
Error
.
BLOCK_VERDICT_UNCOMMON
:
this
.
showButton
(
"
askOpenOrRemoveFile
"
)
;
break
;
case
Downloads
.
Error
.
BLOCK_VERDICT_POTENTIALLY_UNWANTED
:
this
.
showButton
(
"
askRemoveFileOrAllow
"
)
;
break
;
default
:
this
.
showButton
(
"
removeFile
"
)
;
break
;
}
}
this
.
showStatusWithDetails
(
this
.
rawBlockedTitleAndDetails
[
0
]
hover
)
;
}
else
{
this
.
showStatusWithDetails
(
DownloadsCommon
.
strings
.
stateFailed
)
;
this
.
showButton
(
"
retry
"
)
;
}
}
else
if
(
this
.
download
.
canceled
)
{
if
(
this
.
download
.
hasPartialData
)
{
let
totalBytes
=
this
.
download
.
hasProgress
?
this
.
download
.
totalBytes
:
-
1
;
let
transfer
=
DownloadUtils
.
getTransferTotal
(
this
.
download
.
currentBytes
totalBytes
)
;
this
.
showStatus
(
DownloadsCommon
.
strings
.
statusSeparatorBeforeNumber
(
DownloadsCommon
.
strings
.
statePaused
transfer
)
)
;
this
.
showButton
(
"
cancel
"
)
;
progressPaused
=
true
;
}
else
{
this
.
showStatusWithDetails
(
DownloadsCommon
.
strings
.
stateCanceled
)
;
this
.
showButton
(
"
retry
"
)
;
}
}
else
{
this
.
showStatus
(
DownloadsCommon
.
strings
.
stateStarting
)
;
this
.
showButton
(
"
cancel
"
)
;
}
if
(
verdict
)
{
this
.
element
.
setAttribute
(
"
verdict
"
verdict
)
;
}
else
{
this
.
element
.
removeAttribute
(
"
verdict
"
)
;
}
this
.
element
.
classList
.
toggle
(
"
temporary
-
block
"
!
!
this
.
download
.
hasBlockedData
)
;
}
if
(
this
.
download
.
hasProgress
)
{
this
.
showProgress
(
"
normal
"
this
.
download
.
progress
progressPaused
)
;
}
else
{
this
.
showProgress
(
"
undetermined
"
100
progressPaused
)
;
}
}
get
rawBlockedTitleAndDetails
(
)
{
let
s
=
DownloadsCommon
.
strings
;
if
(
!
this
.
download
.
error
|
|
!
this
.
download
.
error
.
becauseBlockedByReputationCheck
)
{
return
[
null
null
]
;
}
switch
(
this
.
download
.
error
.
reputationCheckVerdict
)
{
case
Downloads
.
Error
.
BLOCK_VERDICT_UNCOMMON
:
return
[
s
.
blockedUncommon2
[
s
.
unblockTypeUncommon2
s
.
unblockTip2
]
]
;
case
Downloads
.
Error
.
BLOCK_VERDICT_POTENTIALLY_UNWANTED
:
return
[
s
.
blockedPotentiallyUnwanted
[
s
.
unblockTypePotentiallyUnwanted2
s
.
unblockTip2
]
]
;
case
Downloads
.
Error
.
BLOCK_VERDICT_MALWARE
:
return
[
s
.
blockedMalware
[
s
.
unblockTypeMalware
s
.
unblockTip2
]
]
;
}
throw
new
Error
(
"
Unexpected
reputationCheckVerdict
:
"
+
this
.
download
.
error
.
reputationCheckVerdict
)
;
}
confirmUnblock
(
window
dialogType
)
{
DownloadsCommon
.
confirmUnblockDownload
(
{
verdict
:
this
.
download
.
error
.
reputationCheckVerdict
window
dialogType
}
)
.
then
(
action
=
>
{
if
(
action
=
=
"
open
"
)
{
return
this
.
unblockAndOpenDownload
(
)
;
}
else
if
(
action
=
=
"
unblock
"
)
{
return
this
.
download
.
unblock
(
)
;
}
else
if
(
action
=
=
"
confirmBlock
"
)
{
return
this
.
download
.
confirmBlock
(
)
;
}
return
Promise
.
resolve
(
)
;
}
)
.
catch
(
Cu
.
reportError
)
;
}
unblockAndOpenDownload
(
)
{
return
this
.
download
.
unblock
(
)
.
then
(
(
)
=
>
this
.
downloadsCmd_open
(
)
)
;
}
get
currentDefaultCommandName
(
)
{
switch
(
DownloadsCommon
.
stateOfDownload
(
this
.
download
)
)
{
case
DownloadsCommon
.
DOWNLOAD_NOTSTARTED
:
return
"
downloadsCmd_cancel
"
;
case
DownloadsCommon
.
DOWNLOAD_FAILED
:
case
DownloadsCommon
.
DOWNLOAD_CANCELED
:
return
"
downloadsCmd_retry
"
;
case
DownloadsCommon
.
DOWNLOAD_PAUSED
:
return
"
downloadsCmd_pauseResume
"
;
case
DownloadsCommon
.
DOWNLOAD_FINISHED
:
return
"
downloadsCmd_open
"
;
case
DownloadsCommon
.
DOWNLOAD_BLOCKED_PARENTAL
:
return
"
downloadsCmd_openReferrer
"
;
case
DownloadsCommon
.
DOWNLOAD_DIRTY
:
return
"
downloadsCmd_showBlockedInfo
"
;
}
return
"
"
;
}
isCommandEnabled
(
aCommand
)
{
switch
(
aCommand
)
{
case
"
downloadsCmd_retry
"
:
return
this
.
download
.
canceled
|
|
this
.
download
.
error
;
case
"
downloadsCmd_pauseResume
"
:
return
this
.
download
.
hasPartialData
&
&
!
this
.
download
.
error
;
case
"
downloadsCmd_openReferrer
"
:
return
!
!
this
.
download
.
source
.
referrer
;
case
"
downloadsCmd_confirmBlock
"
:
case
"
downloadsCmd_chooseUnblock
"
:
case
"
downloadsCmd_chooseOpen
"
:
case
"
downloadsCmd_unblock
"
:
case
"
downloadsCmd_unblockAndOpen
"
:
return
this
.
download
.
hasBlockedData
;
case
"
downloadsCmd_cancel
"
:
return
this
.
download
.
hasPartialData
|
|
!
this
.
download
.
stopped
;
case
"
downloadsCmd_open
"
:
return
this
.
download
.
target
.
exists
;
case
"
downloadsCmd_show
"
:
if
(
this
.
download
.
target
.
partFilePath
)
{
let
partFile
=
new
FileUtils
.
File
(
this
.
download
.
target
.
partFilePath
)
;
if
(
partFile
.
exists
(
)
)
{
return
true
;
}
}
return
this
.
download
.
target
.
exists
;
case
"
downloadsCmd_delete
"
:
case
"
cmd_delete
"
:
return
this
.
download
.
stopped
;
}
return
DownloadsViewUI
.
isCommandName
(
aCommand
)
&
&
!
!
this
[
aCommand
]
;
}
doCommand
(
aCommand
)
{
if
(
DownloadsViewUI
.
isCommandName
(
aCommand
)
)
{
this
[
aCommand
]
(
)
;
}
}
onButton
(
)
{
this
.
doCommand
(
this
.
buttonCommandName
)
;
}
downloadsCmd_cancel
(
)
{
this
.
download
.
cancel
(
)
.
catch
(
(
)
=
>
{
}
)
;
this
.
download
.
removePartialData
(
)
.
catch
(
Cu
.
reportError
)
;
}
downloadsCmd_confirmBlock
(
)
{
this
.
download
.
confirmBlock
(
)
.
catch
(
Cu
.
reportError
)
;
}
downloadsCmd_open
(
)
{
let
file
=
new
FileUtils
.
File
(
this
.
download
.
target
.
path
)
;
DownloadsCommon
.
openDownloadedFile
(
file
null
this
.
element
.
ownerGlobal
)
;
}
downloadsCmd_openReferrer
(
)
{
this
.
element
.
ownerGlobal
.
openURL
(
this
.
download
.
source
.
referrer
)
;
}
downloadsCmd_pauseResume
(
)
{
if
(
this
.
download
.
stopped
)
{
this
.
download
.
start
(
)
;
}
else
{
this
.
download
.
cancel
(
)
;
}
}
downloadsCmd_show
(
)
{
let
file
=
new
FileUtils
.
File
(
this
.
download
.
target
.
path
)
;
DownloadsCommon
.
showDownloadedFile
(
file
)
;
}
downloadsCmd_retry
(
)
{
if
(
this
.
download
.
start
)
{
this
.
download
.
start
(
)
.
catch
(
(
)
=
>
{
}
)
;
return
;
}
let
window
=
this
.
browserWindow
|
|
this
.
element
.
ownerGlobal
;
let
document
=
window
.
document
;
let
targetPath
=
this
.
download
.
target
.
path
?
OS
.
Path
.
basename
(
this
.
download
.
target
.
path
)
:
null
;
window
.
DownloadURL
(
this
.
download
.
source
.
url
targetPath
document
)
;
}
downloadsCmd_delete
(
)
{
this
.
cmd_delete
(
)
;
}
cmd_delete
(
)
{
DownloadsCommon
.
deleteDownload
(
this
.
download
)
.
catch
(
Cu
.
reportError
)
;
}
}
;
