"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
DownloadsViewUI
"
]
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Downloads
"
"
resource
:
/
/
gre
/
modules
/
Downloads
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
DownloadUtils
"
"
resource
:
/
/
gre
/
modules
/
DownloadUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
DownloadsCommon
"
"
resource
:
/
/
/
modules
/
DownloadsCommon
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
FileUtils
"
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
OS
"
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PlacesUtils
"
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
RecentWindow
"
"
resource
:
/
/
/
modules
/
RecentWindow
.
jsm
"
)
;
this
.
DownloadsViewUI
=
{
isCommandName
(
name
)
{
return
name
.
startsWith
(
"
cmd_
"
)
|
|
name
.
startsWith
(
"
downloadsCmd_
"
)
;
}
}
;
this
.
DownloadsViewUI
.
BaseView
=
class
{
canClearDownloads
(
nodeContainer
)
{
for
(
let
elt
=
nodeContainer
.
lastChild
;
elt
;
elt
=
elt
.
previousSibling
)
{
let
download
=
elt
.
_shell
.
download
;
if
(
download
.
stopped
&
&
!
(
download
.
canceled
&
&
download
.
hasPartialData
)
)
{
return
true
;
}
}
return
false
;
}
}
;
this
.
DownloadsViewUI
.
DownloadElementShell
=
function
(
)
{
}
;
this
.
DownloadsViewUI
.
DownloadElementShell
.
prototype
=
{
element
:
null
get
image
(
)
{
if
(
!
this
.
download
.
target
.
path
)
{
return
"
moz
-
icon
:
/
/
.
unknown
?
size
=
32
"
;
}
return
"
moz
-
icon
:
/
/
"
+
this
.
download
.
target
.
path
+
"
?
size
=
32
"
+
(
this
.
download
.
succeeded
?
"
&
state
=
normal
"
:
"
"
)
;
}
get
displayName
(
)
{
if
(
!
this
.
download
.
target
.
path
)
{
return
this
.
download
.
source
.
url
;
}
return
OS
.
Path
.
basename
(
this
.
download
.
target
.
path
)
;
}
get
browserWindow
(
)
{
return
RecentWindow
.
getMostRecentBrowserWindow
(
)
;
}
get
_progressElement
(
)
{
if
(
!
this
.
__progressElement
)
{
this
.
__progressElement
=
this
.
element
.
ownerDocument
.
getAnonymousElementByAttribute
(
this
.
element
"
anonid
"
"
progressmeter
"
)
;
}
return
this
.
__progressElement
;
}
_updateState
(
)
{
this
.
element
.
setAttribute
(
"
displayName
"
this
.
displayName
)
;
this
.
element
.
setAttribute
(
"
image
"
this
.
image
)
;
this
.
element
.
setAttribute
(
"
state
"
DownloadsCommon
.
stateOfDownload
(
this
.
download
)
)
;
if
(
!
this
.
download
.
succeeded
&
&
this
.
download
.
error
&
&
this
.
download
.
error
.
becauseBlockedByReputationCheck
)
{
this
.
element
.
setAttribute
(
"
verdict
"
this
.
download
.
error
.
reputationCheckVerdict
)
;
}
else
{
this
.
element
.
removeAttribute
(
"
verdict
"
)
;
}
this
.
lastEstimatedSecondsLeft
=
Infinity
;
this
.
_updateProgress
(
)
;
}
_updateProgress
(
)
{
if
(
this
.
download
.
succeeded
)
{
if
(
this
.
download
.
target
.
exists
)
{
this
.
element
.
setAttribute
(
"
exists
"
"
true
"
)
;
}
else
{
this
.
element
.
removeAttribute
(
"
exists
"
)
;
}
}
this
.
element
.
classList
.
toggle
(
"
temporary
-
block
"
!
!
this
.
download
.
hasBlockedData
)
;
if
(
this
.
download
.
hasProgress
)
{
this
.
element
.
setAttribute
(
"
progressmode
"
"
normal
"
)
;
this
.
element
.
setAttribute
(
"
progress
"
this
.
download
.
progress
)
;
}
else
{
this
.
element
.
setAttribute
(
"
progressmode
"
"
undetermined
"
)
;
}
if
(
this
.
download
.
stopped
&
&
this
.
download
.
canceled
&
&
this
.
download
.
hasPartialData
)
{
this
.
element
.
setAttribute
(
"
progresspaused
"
"
true
"
)
;
}
else
{
this
.
element
.
removeAttribute
(
"
progresspaused
"
)
;
}
if
(
this
.
_progressElement
)
{
let
event
=
this
.
element
.
ownerDocument
.
createEvent
(
"
Events
"
)
;
event
.
initEvent
(
"
ValueChange
"
true
true
)
;
this
.
_progressElement
.
dispatchEvent
(
event
)
;
}
let
labels
=
this
.
statusLabels
;
this
.
element
.
setAttribute
(
"
status
"
labels
.
status
)
;
this
.
element
.
setAttribute
(
"
hoverStatus
"
labels
.
hoverStatus
)
;
this
.
element
.
setAttribute
(
"
fullStatus
"
labels
.
fullStatus
)
;
}
lastEstimatedSecondsLeft
:
Infinity
get
statusLabels
(
)
{
let
s
=
DownloadsCommon
.
strings
;
let
status
=
"
"
;
let
hoverStatus
=
"
"
;
let
fullStatus
=
"
"
;
if
(
!
this
.
download
.
stopped
)
{
let
totalBytes
=
this
.
download
.
hasProgress
?
this
.
download
.
totalBytes
:
-
1
;
let
newEstimatedSecondsLeft
;
[
status
newEstimatedSecondsLeft
]
=
DownloadUtils
.
getDownloadStatus
(
this
.
download
.
currentBytes
totalBytes
this
.
download
.
speed
this
.
lastEstimatedSecondsLeft
)
;
this
.
lastEstimatedSecondsLeft
=
newEstimatedSecondsLeft
;
hoverStatus
=
status
;
}
else
if
(
this
.
download
.
canceled
&
&
this
.
download
.
hasPartialData
)
{
let
totalBytes
=
this
.
download
.
hasProgress
?
this
.
download
.
totalBytes
:
-
1
;
let
transfer
=
DownloadUtils
.
getTransferTotal
(
this
.
download
.
currentBytes
totalBytes
)
;
status
=
s
.
statusSeparatorBeforeNumber
(
s
.
statePaused
transfer
)
;
hoverStatus
=
status
;
}
else
if
(
!
this
.
download
.
succeeded
&
&
!
this
.
download
.
canceled
&
&
!
this
.
download
.
error
)
{
status
=
s
.
stateStarting
;
hoverStatus
=
status
;
}
else
{
let
stateLabel
;
if
(
this
.
download
.
succeeded
&
&
!
this
.
download
.
target
.
exists
)
{
stateLabel
=
s
.
fileMovedOrMissing
;
hoverStatus
=
stateLabel
;
}
else
if
(
this
.
download
.
succeeded
)
{
if
(
this
.
download
.
target
.
size
!
=
=
undefined
)
{
let
[
size
unit
]
=
DownloadUtils
.
convertByteUnits
(
this
.
download
.
target
.
size
)
;
stateLabel
=
s
.
sizeWithUnits
(
size
unit
)
;
status
=
s
.
statusSeparator
(
s
.
stateCompleted
stateLabel
)
;
}
else
{
stateLabel
=
s
.
sizeUnknown
;
status
=
s
.
stateCompleted
;
}
hoverStatus
=
status
;
}
else
if
(
this
.
download
.
canceled
)
{
stateLabel
=
s
.
stateCanceled
;
}
else
if
(
this
.
download
.
error
.
becauseBlockedByParentalControls
)
{
stateLabel
=
s
.
stateBlockedParentalControls
;
}
else
if
(
this
.
download
.
error
.
becauseBlockedByReputationCheck
)
{
stateLabel
=
this
.
rawBlockedTitleAndDetails
[
0
]
;
}
else
{
stateLabel
=
s
.
stateFailed
;
}
let
referrer
=
this
.
download
.
source
.
referrer
|
|
this
.
download
.
source
.
url
;
let
[
displayHost
]
=
DownloadUtils
.
getURIHost
(
referrer
)
;
let
date
=
new
Date
(
this
.
download
.
endTime
)
;
let
[
displayDate
]
=
DownloadUtils
.
getReadableDates
(
date
)
;
let
firstPart
=
s
.
statusSeparator
(
stateLabel
displayHost
)
;
fullStatus
=
s
.
statusSeparator
(
firstPart
displayDate
)
;
status
=
status
|
|
stateLabel
;
}
return
{
status
hoverStatus
:
hoverStatus
|
|
fullStatus
fullStatus
:
fullStatus
|
|
status
}
;
}
get
rawBlockedTitleAndDetails
(
)
{
let
s
=
DownloadsCommon
.
strings
;
if
(
!
this
.
download
.
error
|
|
!
this
.
download
.
error
.
becauseBlockedByReputationCheck
)
{
return
[
null
null
]
;
}
switch
(
this
.
download
.
error
.
reputationCheckVerdict
)
{
case
Downloads
.
Error
.
BLOCK_VERDICT_UNCOMMON
:
return
[
s
.
blockedUncommon2
[
s
.
unblockTypeUncommon2
s
.
unblockTip2
]
]
;
case
Downloads
.
Error
.
BLOCK_VERDICT_POTENTIALLY_UNWANTED
:
return
[
s
.
blockedPotentiallyUnwanted
[
s
.
unblockTypePotentiallyUnwanted2
s
.
unblockTip2
]
]
;
case
Downloads
.
Error
.
BLOCK_VERDICT_MALWARE
:
return
[
s
.
blockedMalware
[
s
.
unblockTypeMalware
s
.
unblockTip2
]
]
;
}
throw
new
Error
(
"
Unexpected
reputationCheckVerdict
:
"
+
this
.
download
.
error
.
reputationCheckVerdict
)
;
}
confirmUnblock
(
window
dialogType
)
{
DownloadsCommon
.
confirmUnblockDownload
(
{
verdict
:
this
.
download
.
error
.
reputationCheckVerdict
window
dialogType
}
)
.
then
(
action
=
>
{
if
(
action
=
=
"
open
"
)
{
return
this
.
unblockAndOpenDownload
(
)
;
}
else
if
(
action
=
=
"
unblock
"
)
{
return
this
.
download
.
unblock
(
)
;
}
else
if
(
action
=
=
"
confirmBlock
"
)
{
return
this
.
download
.
confirmBlock
(
)
;
}
return
Promise
.
resolve
(
)
;
}
)
.
catch
(
Cu
.
reportError
)
;
}
unblockAndOpenDownload
(
)
{
return
this
.
download
.
unblock
(
)
.
then
(
(
)
=
>
this
.
downloadsCmd_open
(
)
)
;
}
get
currentDefaultCommandName
(
)
{
switch
(
DownloadsCommon
.
stateOfDownload
(
this
.
download
)
)
{
case
DownloadsCommon
.
DOWNLOAD_NOTSTARTED
:
return
"
downloadsCmd_cancel
"
;
case
DownloadsCommon
.
DOWNLOAD_FAILED
:
case
DownloadsCommon
.
DOWNLOAD_CANCELED
:
return
"
downloadsCmd_retry
"
;
case
DownloadsCommon
.
DOWNLOAD_PAUSED
:
return
"
downloadsCmd_pauseResume
"
;
case
DownloadsCommon
.
DOWNLOAD_FINISHED
:
return
"
downloadsCmd_open
"
;
case
DownloadsCommon
.
DOWNLOAD_BLOCKED_PARENTAL
:
return
"
downloadsCmd_openReferrer
"
;
case
DownloadsCommon
.
DOWNLOAD_DIRTY
:
return
"
downloadsCmd_showBlockedInfo
"
;
}
return
"
"
;
}
isCommandEnabled
(
aCommand
)
{
switch
(
aCommand
)
{
case
"
downloadsCmd_retry
"
:
return
this
.
download
.
canceled
|
|
this
.
download
.
error
;
case
"
downloadsCmd_pauseResume
"
:
return
this
.
download
.
hasPartialData
&
&
!
this
.
download
.
error
;
case
"
downloadsCmd_openReferrer
"
:
return
!
!
this
.
download
.
source
.
referrer
;
case
"
downloadsCmd_confirmBlock
"
:
case
"
downloadsCmd_chooseUnblock
"
:
case
"
downloadsCmd_chooseOpen
"
:
case
"
downloadsCmd_unblock
"
:
case
"
downloadsCmd_unblockAndOpen
"
:
return
this
.
download
.
hasBlockedData
;
case
"
downloadsCmd_cancel
"
:
return
this
.
download
.
hasPartialData
|
|
!
this
.
download
.
stopped
;
case
"
downloadsCmd_open
"
:
return
this
.
download
.
target
.
exists
;
case
"
downloadsCmd_show
"
:
if
(
this
.
download
.
target
.
partFilePath
)
{
let
partFile
=
new
FileUtils
.
File
(
this
.
download
.
target
.
partFilePath
)
;
if
(
partFile
.
exists
(
)
)
{
return
true
;
}
}
return
this
.
download
.
target
.
exists
;
case
"
downloadsCmd_delete
"
:
case
"
cmd_delete
"
:
return
this
.
download
.
stopped
;
}
return
DownloadsViewUI
.
isCommandName
(
aCommand
)
&
&
!
!
this
[
aCommand
]
;
}
doCommand
(
aCommand
)
{
if
(
DownloadsViewUI
.
isCommandName
(
aCommand
)
)
{
this
[
aCommand
]
(
)
;
}
}
downloadsCmd_cancel
(
)
{
this
.
download
.
cancel
(
)
.
catch
(
(
)
=
>
{
}
)
;
this
.
download
.
removePartialData
(
)
.
catch
(
Cu
.
reportError
)
;
}
downloadsCmd_confirmBlock
(
)
{
this
.
download
.
confirmBlock
(
)
.
catch
(
Cu
.
reportError
)
;
}
downloadsCmd_open
(
)
{
let
file
=
new
FileUtils
.
File
(
this
.
download
.
target
.
path
)
;
DownloadsCommon
.
openDownloadedFile
(
file
null
this
.
element
.
ownerGlobal
)
;
}
downloadsCmd_openReferrer
(
)
{
this
.
element
.
ownerGlobal
.
openURL
(
this
.
download
.
source
.
referrer
)
;
}
downloadsCmd_pauseResume
(
)
{
if
(
this
.
download
.
stopped
)
{
this
.
download
.
start
(
)
;
}
else
{
this
.
download
.
cancel
(
)
;
}
}
downloadsCmd_show
(
)
{
let
file
=
new
FileUtils
.
File
(
this
.
download
.
target
.
path
)
;
DownloadsCommon
.
showDownloadedFile
(
file
)
;
}
downloadsCmd_retry
(
)
{
if
(
this
.
download
.
start
)
{
this
.
download
.
start
(
)
.
catch
(
(
)
=
>
{
}
)
;
return
;
}
let
window
=
this
.
browserWindow
|
|
this
.
element
.
ownerGlobal
;
let
document
=
window
.
document
;
let
targetPath
=
this
.
download
.
target
.
path
?
OS
.
Path
.
basename
(
this
.
download
.
target
.
path
)
:
null
;
window
.
DownloadURL
(
this
.
download
.
source
.
url
targetPath
document
)
;
}
downloadsCmd_delete
(
)
{
this
.
cmd_delete
(
)
;
}
cmd_delete
(
)
{
(
async
(
)
=
>
{
try
{
await
PlacesUtils
.
history
.
remove
(
this
.
download
.
source
.
url
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
let
list
=
await
Downloads
.
getList
(
Downloads
.
ALL
)
;
await
list
.
remove
(
this
.
download
)
;
await
this
.
download
.
finalize
(
true
)
;
}
)
(
)
.
catch
(
Cu
.
reportError
)
;
}
}
;
