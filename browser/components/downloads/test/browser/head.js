XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Downloads
"
"
resource
:
/
/
gre
/
modules
/
Downloads
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
DownloadsCommon
"
"
resource
:
/
/
/
modules
/
DownloadsCommon
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
FileUtils
"
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PlacesUtils
"
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
HttpServer
"
"
resource
:
/
/
testing
-
common
/
httpd
.
js
"
)
;
var
gTestTargetFile
=
FileUtils
.
getFile
(
"
TmpD
"
[
"
dm
-
ui
-
test
.
file
"
]
)
;
gTestTargetFile
.
createUnique
(
Ci
.
nsIFile
.
NORMAL_FILE_TYPE
FileUtils
.
PERMS_FILE
)
;
registerCleanupFunction
(
(
)
=
>
OS
.
File
.
remove
(
gTestTargetFile
.
path
{
ignoreAbsent
:
true
}
)
)
;
function
promiseFocus
(
)
{
return
new
Promise
(
resolve
=
>
{
waitForFocus
(
resolve
)
;
}
)
;
}
function
promisePanelOpened
(
)
{
if
(
DownloadsPanel
.
panel
&
&
DownloadsPanel
.
panel
.
state
=
=
"
open
"
)
{
return
Promise
.
resolve
(
)
;
}
return
new
Promise
(
resolve
=
>
{
let
originalOnPopupShown
=
DownloadsPanel
.
onPopupShown
;
DownloadsPanel
.
onPopupShown
=
function
(
)
{
DownloadsPanel
.
onPopupShown
=
originalOnPopupShown
;
originalOnPopupShown
.
apply
(
this
arguments
)
;
setTimeout
(
resolve
0
)
;
}
;
}
)
;
}
async
function
task_resetState
(
)
{
let
publicList
=
await
Downloads
.
getList
(
Downloads
.
PUBLIC
)
;
let
downloads
=
await
publicList
.
getAll
(
)
;
for
(
let
download
of
downloads
)
{
publicList
.
remove
(
download
)
;
await
download
.
finalize
(
true
)
;
}
DownloadsPanel
.
hidePanel
(
)
;
await
promiseFocus
(
)
;
}
async
function
task_addDownloads
(
aItems
)
{
let
startTimeMs
=
Date
.
now
(
)
;
let
publicList
=
await
Downloads
.
getList
(
Downloads
.
PUBLIC
)
;
for
(
let
item
of
aItems
)
{
let
download
=
{
source
:
{
url
:
"
http
:
/
/
www
.
example
.
com
/
test
-
download
.
txt
"
}
target
:
{
path
:
gTestTargetFile
.
path
}
succeeded
:
item
.
state
=
=
DownloadsCommon
.
DOWNLOAD_FINISHED
canceled
:
item
.
state
=
=
DownloadsCommon
.
DOWNLOAD_CANCELED
|
|
item
.
state
=
=
DownloadsCommon
.
DOWNLOAD_PAUSED
error
:
item
.
state
=
=
DownloadsCommon
.
DOWNLOAD_FAILED
?
new
Error
(
"
Failed
.
"
)
:
null
hasPartialData
:
item
.
state
=
=
DownloadsCommon
.
DOWNLOAD_PAUSED
hasBlockedData
:
item
.
hasBlockedData
|
|
false
startTime
:
new
Date
(
startTimeMs
+
+
)
}
;
if
(
item
.
errorObj
)
{
download
.
errorObj
=
item
.
errorObj
;
}
await
publicList
.
add
(
await
Downloads
.
createDownload
(
download
)
)
;
}
}
async
function
task_openPanel
(
)
{
await
promiseFocus
(
)
;
let
promise
=
promisePanelOpened
(
)
;
DownloadsPanel
.
showPanel
(
)
;
await
promise
;
}
async
function
setDownloadDir
(
)
{
let
tmpDir
=
Services
.
dirsvc
.
get
(
"
TmpD
"
Ci
.
nsIFile
)
;
tmpDir
.
append
(
"
testsavedir
"
)
;
if
(
!
tmpDir
.
exists
(
)
)
{
tmpDir
.
create
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
0o755
)
;
registerCleanupFunction
(
function
(
)
{
try
{
tmpDir
.
remove
(
true
)
;
}
catch
(
e
)
{
}
}
)
;
}
await
SpecialPowers
.
pushPrefEnv
(
{
"
set
"
:
[
[
"
browser
.
download
.
folderList
"
2
]
[
"
browser
.
download
.
dir
"
tmpDir
Ci
.
nsIFile
]
]
}
)
;
}
let
gHttpServer
=
null
;
function
startServer
(
)
{
gHttpServer
=
new
HttpServer
(
)
;
gHttpServer
.
start
(
-
1
)
;
registerCleanupFunction
(
async
function
(
)
{
await
new
Promise
(
function
(
resolve
)
{
gHttpServer
.
stop
(
resolve
)
;
}
)
;
}
)
;
gHttpServer
.
registerPathHandler
(
"
/
file1
.
txt
"
(
request
response
)
=
>
{
response
.
setStatusLine
(
null
200
"
OK
"
)
;
response
.
write
(
"
file1
"
)
;
response
.
processAsync
(
)
;
response
.
finish
(
)
;
}
)
;
gHttpServer
.
registerPathHandler
(
"
/
file2
.
txt
"
(
request
response
)
=
>
{
response
.
setStatusLine
(
null
200
"
OK
"
)
;
response
.
write
(
"
file2
"
)
;
response
.
processAsync
(
)
;
response
.
finish
(
)
;
}
)
;
gHttpServer
.
registerPathHandler
(
"
/
file3
.
txt
"
(
request
response
)
=
>
{
response
.
setStatusLine
(
null
200
"
OK
"
)
;
response
.
write
(
"
file3
"
)
;
response
.
processAsync
(
)
;
response
.
finish
(
)
;
}
)
;
}
function
httpUrl
(
aFileName
)
{
return
"
http
:
/
/
localhost
:
"
+
gHttpServer
.
identity
.
primaryPort
+
"
/
"
+
aFileName
;
}
function
openLibrary
(
aLeftPaneRoot
)
{
let
library
=
window
.
openDialog
(
"
chrome
:
/
/
browser
/
content
/
places
/
places
.
xul
"
"
"
"
chrome
toolbar
=
yes
dialog
=
no
resizable
"
aLeftPaneRoot
)
;
return
new
Promise
(
resolve
=
>
{
waitForFocus
(
resolve
library
)
;
}
)
;
}
function
promiseAlertDialogOpen
(
buttonAction
)
{
return
new
Promise
(
resolve
=
>
{
Services
.
ww
.
registerNotification
(
function
onOpen
(
subj
topic
data
)
{
if
(
topic
=
=
"
domwindowopened
"
&
&
subj
instanceof
Ci
.
nsIDOMWindow
)
{
subj
.
addEventListener
(
"
load
"
function
(
)
{
if
(
subj
.
document
.
documentURI
=
=
"
chrome
:
/
/
global
/
content
/
commonDialog
.
xul
"
)
{
Services
.
ww
.
unregisterNotification
(
onOpen
)
;
let
dialog
=
subj
.
document
.
getElementById
(
"
commonDialog
"
)
;
ok
(
dialog
.
classList
.
contains
(
"
alert
-
dialog
"
)
"
The
dialog
element
should
contain
an
alert
class
.
"
)
;
let
doc
=
subj
.
document
.
documentElement
;
doc
.
getButton
(
buttonAction
)
.
click
(
)
;
resolve
(
)
;
}
}
{
once
:
true
}
)
;
}
}
)
;
}
)
;
}
function
promiseButtonShown
(
id
)
{
let
dwu
=
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
return
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
{
let
target
=
document
.
getElementById
(
id
)
;
let
bounds
=
dwu
.
getBoundsWithoutFlushing
(
target
)
;
return
bounds
.
width
>
0
&
&
bounds
.
height
>
0
;
}
Waiting
for
button
{
id
}
to
have
non
-
0
size
)
;
}
