ChromeUtils
.
defineModuleGetter
(
this
"
Downloads
"
"
resource
:
/
/
gre
/
modules
/
Downloads
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
DownloadsCommon
"
"
resource
:
/
/
/
modules
/
DownloadsCommon
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
FileUtils
"
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PlacesUtils
"
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
HttpServer
"
"
resource
:
/
/
testing
-
common
/
httpd
.
js
"
)
;
var
gTestTargetFile
=
FileUtils
.
getFile
(
"
TmpD
"
[
"
dm
-
ui
-
test
.
file
"
]
)
;
gTestTargetFile
.
createUnique
(
Ci
.
nsIFile
.
NORMAL_FILE_TYPE
FileUtils
.
PERMS_FILE
)
;
registerCleanupFunction
(
(
)
=
>
OS
.
File
.
remove
(
gTestTargetFile
.
path
{
ignoreAbsent
:
true
}
)
)
;
const
DATA_PDF
=
atob
(
"
JVBERi0xLjANCjEgMCBvYmo8PC9UeXBlL0NhdGFsb2cvUGFnZXMgMiAwIFI
+
PmVuZG9iaiAyIDAgb2JqPDwvVHlwZS9QYWdlcy9LaWRzWzMgMCBSXS9Db3VudCAxPj5lbmRvYmogMyAwIG9iajw8L1R5cGUvUGFnZS9NZWRpYUJveFswIDAgMyAzXT4
+
ZW5kb2JqDQp4cmVmDQowIDQNCjAwMDAwMDAwMDAgNjU1MzUgZg0KMDAwMDAwMDAxMCAwMDAwMCBuDQowMDAwMDAwMDUzIDAwMDAwIG4NCjAwMDAwMDAxMDIgMDAwMDAgbg0KdHJhaWxlcjw8L1NpemUgNC9Sb290IDEgMCBSPj4NCnN0YXJ0eHJlZg0KMTQ5DQolRU9G
"
)
;
async
function
createDownloadedFile
(
pathname
contents
)
{
let
encoder
=
new
TextEncoder
(
)
;
let
file
=
new
FileUtils
.
File
(
pathname
)
;
if
(
file
.
exists
(
)
)
{
info
(
File
at
{
pathname
}
already
exists
)
;
}
await
OS
.
File
.
writeAtomic
(
pathname
encoder
.
encode
(
contents
)
)
;
ok
(
file
.
exists
(
)
Created
{
pathname
}
)
;
return
file
;
}
async
function
openContextMenu
(
itemElement
win
=
window
)
{
let
popupShownPromise
=
BrowserTestUtils
.
waitForEvent
(
itemElement
.
ownerDocument
"
popupshown
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
itemElement
{
type
:
"
contextmenu
"
button
:
2
}
win
)
;
let
{
target
}
=
await
popupShownPromise
;
return
target
;
}
function
promiseFocus
(
)
{
return
new
Promise
(
resolve
=
>
{
waitForFocus
(
resolve
)
;
}
)
;
}
function
promisePanelOpened
(
)
{
if
(
DownloadsPanel
.
panel
&
&
DownloadsPanel
.
panel
.
state
=
=
"
open
"
)
{
return
Promise
.
resolve
(
)
;
}
return
new
Promise
(
resolve
=
>
{
let
originalOnPopupShown
=
DownloadsPanel
.
onPopupShown
;
DownloadsPanel
.
onPopupShown
=
function
(
)
{
DownloadsPanel
.
onPopupShown
=
originalOnPopupShown
;
originalOnPopupShown
.
apply
(
this
arguments
)
;
setTimeout
(
resolve
0
)
;
}
;
}
)
;
}
async
function
task_resetState
(
)
{
let
publicList
=
await
Downloads
.
getList
(
Downloads
.
PUBLIC
)
;
let
downloads
=
await
publicList
.
getAll
(
)
;
for
(
let
download
of
downloads
)
{
publicList
.
remove
(
download
)
;
await
download
.
finalize
(
true
)
;
}
DownloadsPanel
.
hidePanel
(
)
;
await
promiseFocus
(
)
;
}
async
function
task_addDownloads
(
aItems
)
{
let
startTimeMs
=
Date
.
now
(
)
;
let
publicList
=
await
Downloads
.
getList
(
Downloads
.
PUBLIC
)
;
for
(
let
item
of
aItems
)
{
let
source
=
{
url
:
"
http
:
/
/
www
.
example
.
com
/
test
-
download
.
txt
"
.
.
.
item
.
source
}
;
let
target
=
item
.
target
instanceof
Ci
.
nsIFile
?
item
.
target
:
{
path
:
gTestTargetFile
.
path
.
.
.
item
.
target
}
;
let
download
=
{
source
target
succeeded
:
item
.
state
=
=
DownloadsCommon
.
DOWNLOAD_FINISHED
canceled
:
item
.
state
=
=
DownloadsCommon
.
DOWNLOAD_CANCELED
|
|
item
.
state
=
=
DownloadsCommon
.
DOWNLOAD_PAUSED
error
:
item
.
state
=
=
DownloadsCommon
.
DOWNLOAD_FAILED
?
new
Error
(
"
Failed
.
"
)
:
null
hasPartialData
:
item
.
state
=
=
DownloadsCommon
.
DOWNLOAD_PAUSED
hasBlockedData
:
item
.
hasBlockedData
|
|
false
contentType
:
item
.
contentType
startTime
:
new
Date
(
startTimeMs
+
+
)
}
;
if
(
item
.
errorObj
)
{
download
.
errorObj
=
item
.
errorObj
;
}
download
=
await
Downloads
.
createDownload
(
download
)
;
await
publicList
.
add
(
download
)
;
await
download
.
refresh
(
)
;
}
}
async
function
task_openPanel
(
)
{
await
promiseFocus
(
)
;
let
promise
=
promisePanelOpened
(
)
;
DownloadsPanel
.
showPanel
(
)
;
await
promise
;
}
async
function
setDownloadDir
(
)
{
let
tmpDir
=
Services
.
dirsvc
.
get
(
"
TmpD
"
Ci
.
nsIFile
)
;
tmpDir
.
append
(
"
testsavedir
"
)
;
if
(
!
tmpDir
.
exists
(
)
)
{
tmpDir
.
create
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
0o755
)
;
registerCleanupFunction
(
function
(
)
{
try
{
tmpDir
.
remove
(
true
)
;
}
catch
(
e
)
{
}
}
)
;
}
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
download
.
folderList
"
2
]
[
"
browser
.
download
.
dir
"
tmpDir
.
path
]
]
}
)
;
return
tmpDir
.
path
;
}
let
gHttpServer
=
null
;
function
startServer
(
)
{
gHttpServer
=
new
HttpServer
(
)
;
gHttpServer
.
start
(
-
1
)
;
registerCleanupFunction
(
async
function
(
)
{
await
new
Promise
(
function
(
resolve
)
{
gHttpServer
.
stop
(
resolve
)
;
}
)
;
}
)
;
gHttpServer
.
registerPathHandler
(
"
/
file1
.
txt
"
(
request
response
)
=
>
{
response
.
setStatusLine
(
null
200
"
OK
"
)
;
response
.
write
(
"
file1
"
)
;
response
.
processAsync
(
)
;
response
.
finish
(
)
;
}
)
;
gHttpServer
.
registerPathHandler
(
"
/
file2
.
txt
"
(
request
response
)
=
>
{
response
.
setStatusLine
(
null
200
"
OK
"
)
;
response
.
write
(
"
file2
"
)
;
response
.
processAsync
(
)
;
response
.
finish
(
)
;
}
)
;
gHttpServer
.
registerPathHandler
(
"
/
file3
.
txt
"
(
request
response
)
=
>
{
response
.
setStatusLine
(
null
200
"
OK
"
)
;
response
.
write
(
"
file3
"
)
;
response
.
processAsync
(
)
;
response
.
finish
(
)
;
}
)
;
}
function
httpUrl
(
aFileName
)
{
return
(
"
http
:
/
/
localhost
:
"
+
gHttpServer
.
identity
.
primaryPort
+
"
/
"
+
aFileName
)
;
}
function
openLibrary
(
aLeftPaneRoot
)
{
let
library
=
window
.
openDialog
(
"
chrome
:
/
/
browser
/
content
/
places
/
places
.
xhtml
"
"
"
"
chrome
toolbar
=
yes
dialog
=
no
resizable
"
aLeftPaneRoot
)
;
return
new
Promise
(
resolve
=
>
{
waitForFocus
(
resolve
library
)
;
}
)
;
}
function
promiseButtonShown
(
id
)
{
let
dwu
=
window
.
windowUtils
;
return
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
{
let
target
=
document
.
getElementById
(
id
)
;
let
bounds
=
dwu
.
getBoundsWithoutFlushing
(
target
)
;
return
bounds
.
width
>
0
&
&
bounds
.
height
>
0
;
}
Waiting
for
button
{
id
}
to
have
non
-
0
size
)
;
}
async
function
simulateDropAndCheck
(
win
dropTarget
urls
)
{
let
dragData
=
[
[
{
type
:
"
text
/
plain
"
data
:
urls
.
join
(
"
\
n
"
)
}
]
]
;
let
list
=
await
Downloads
.
getList
(
Downloads
.
ALL
)
;
let
added
=
new
Set
(
)
;
let
succeeded
=
new
Set
(
)
;
await
new
Promise
(
resolve
=
>
{
let
view
=
{
onDownloadAdded
(
download
)
{
added
.
add
(
download
.
source
.
url
)
;
}
onDownloadChanged
(
download
)
{
if
(
!
added
.
has
(
download
.
source
.
url
)
)
{
return
;
}
if
(
!
download
.
succeeded
)
{
return
;
}
succeeded
.
add
(
download
.
source
.
url
)
;
if
(
succeeded
.
size
=
=
urls
.
length
)
{
list
.
removeView
(
view
)
.
then
(
resolve
)
;
}
}
}
;
list
.
addView
(
view
)
.
then
(
function
(
)
{
EventUtils
.
synthesizeDrop
(
dropTarget
dropTarget
dragData
"
link
"
win
)
;
}
)
;
}
)
;
for
(
let
url
of
urls
)
{
ok
(
added
.
has
(
url
)
url
+
"
is
added
to
download
"
)
;
}
}
