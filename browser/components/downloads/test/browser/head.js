XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Downloads
"
"
resource
:
/
/
gre
/
modules
/
Downloads
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
DownloadsCommon
"
"
resource
:
/
/
/
modules
/
DownloadsCommon
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
FileUtils
"
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Promise
"
"
resource
:
/
/
gre
/
modules
/
Promise
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PlacesUtils
"
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
HttpServer
"
"
resource
:
/
/
testing
-
common
/
httpd
.
js
"
)
;
var
gTestTargetFile
=
FileUtils
.
getFile
(
"
TmpD
"
[
"
dm
-
ui
-
test
.
file
"
]
)
;
gTestTargetFile
.
createUnique
(
Ci
.
nsIFile
.
NORMAL_FILE_TYPE
FileUtils
.
PERMS_FILE
)
;
Services
.
scriptloader
.
loadSubScript
(
"
resource
:
/
/
testing
-
common
/
sinon
-
1
.
16
.
1
.
js
"
)
;
registerCleanupFunction
(
function
(
)
{
gTestTargetFile
.
remove
(
false
)
;
delete
window
.
sinon
;
delete
window
.
setImmediate
;
delete
window
.
clearImmediate
;
}
)
;
function
promiseOpenAndLoadWindow
(
aOptions
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
win
=
OpenBrowserWindow
(
aOptions
)
;
win
.
addEventListener
(
"
load
"
function
(
)
{
resolve
(
win
)
;
}
{
once
:
true
}
)
;
}
)
;
}
function
promiseTabLoadEvent
(
tab
url
eventType
=
"
load
"
)
{
return
new
Promise
(
resolve
=
>
{
info
(
"
Wait
tab
event
:
"
+
eventType
)
;
function
handle
(
event
)
{
if
(
event
.
originalTarget
!
=
tab
.
linkedBrowser
.
contentDocument
|
|
event
.
target
.
location
.
href
=
=
"
about
:
blank
"
|
|
(
url
&
&
event
.
target
.
location
.
href
!
=
url
)
)
{
info
(
"
Skipping
spurious
'
"
+
eventType
+
"
'
'
event
"
+
"
for
"
+
event
.
target
.
location
.
href
)
;
return
;
}
realCleanup
=
(
)
=
>
{
}
;
tab
.
linkedBrowser
.
removeEventListener
(
eventType
handle
true
)
;
info
(
"
Tab
event
received
:
"
+
eventType
)
;
resolve
(
event
)
;
}
let
realCleanup
=
(
)
=
>
tab
.
linkedBrowser
.
removeEventListener
(
eventType
handle
true
)
;
registerCleanupFunction
(
(
)
=
>
realCleanup
(
)
)
;
tab
.
linkedBrowser
.
addEventListener
(
eventType
handle
true
true
)
;
if
(
url
)
tab
.
linkedBrowser
.
loadURI
(
url
)
;
}
)
;
}
function
promiseWindowClosed
(
win
)
{
let
promise
=
new
Promise
(
(
resolve
reject
)
=
>
{
Services
.
obs
.
addObserver
(
function
obs
(
subject
topic
)
{
if
(
subject
=
=
win
)
{
Services
.
obs
.
removeObserver
(
obs
topic
)
;
resolve
(
)
;
}
}
"
domwindowclosed
"
)
;
}
)
;
win
.
close
(
)
;
return
promise
;
}
function
promiseFocus
(
)
{
return
new
Promise
(
resolve
=
>
{
waitForFocus
(
resolve
)
;
}
)
;
}
function
promisePanelOpened
(
)
{
if
(
DownloadsPanel
.
panel
&
&
DownloadsPanel
.
panel
.
state
=
=
"
open
"
)
{
return
Promise
.
resolve
(
)
;
}
return
new
Promise
(
resolve
=
>
{
let
originalOnPopupShown
=
DownloadsPanel
.
onPopupShown
;
DownloadsPanel
.
onPopupShown
=
function
(
)
{
DownloadsPanel
.
onPopupShown
=
originalOnPopupShown
;
originalOnPopupShown
.
apply
(
this
arguments
)
;
setTimeout
(
resolve
0
)
;
}
;
}
)
;
}
async
function
task_resetState
(
)
{
let
publicList
=
await
Downloads
.
getList
(
Downloads
.
PUBLIC
)
;
let
downloads
=
await
publicList
.
getAll
(
)
;
for
(
let
download
of
downloads
)
{
publicList
.
remove
(
download
)
;
await
download
.
finalize
(
true
)
;
}
DownloadsPanel
.
hidePanel
(
)
;
await
promiseFocus
(
)
;
}
async
function
task_addDownloads
(
aItems
)
{
let
startTimeMs
=
Date
.
now
(
)
;
let
publicList
=
await
Downloads
.
getList
(
Downloads
.
PUBLIC
)
;
for
(
let
item
of
aItems
)
{
let
download
=
{
source
:
{
url
:
"
http
:
/
/
www
.
example
.
com
/
test
-
download
.
txt
"
}
target
:
{
path
:
gTestTargetFile
.
path
}
succeeded
:
item
.
state
=
=
DownloadsCommon
.
DOWNLOAD_FINISHED
canceled
:
item
.
state
=
=
DownloadsCommon
.
DOWNLOAD_CANCELED
|
|
item
.
state
=
=
DownloadsCommon
.
DOWNLOAD_PAUSED
error
:
item
.
state
=
=
DownloadsCommon
.
DOWNLOAD_FAILED
?
new
Error
(
"
Failed
.
"
)
:
null
hasPartialData
:
item
.
state
=
=
DownloadsCommon
.
DOWNLOAD_PAUSED
hasBlockedData
:
item
.
hasBlockedData
|
|
false
startTime
:
new
Date
(
startTimeMs
+
+
)
}
;
if
(
item
.
errorObj
)
{
download
.
errorObj
=
item
.
errorObj
;
}
await
publicList
.
add
(
await
Downloads
.
createDownload
(
download
)
)
;
}
}
async
function
task_openPanel
(
)
{
await
promiseFocus
(
)
;
let
promise
=
promisePanelOpened
(
)
;
DownloadsPanel
.
showPanel
(
)
;
await
promise
;
}
async
function
setDownloadDir
(
)
{
let
tmpDir
=
Services
.
dirsvc
.
get
(
"
TmpD
"
Ci
.
nsIFile
)
;
tmpDir
.
append
(
"
testsavedir
"
)
;
if
(
!
tmpDir
.
exists
(
)
)
{
tmpDir
.
create
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
0o755
)
;
registerCleanupFunction
(
function
(
)
{
try
{
tmpDir
.
remove
(
true
)
;
}
catch
(
e
)
{
}
}
)
;
}
await
SpecialPowers
.
pushPrefEnv
(
{
"
set
"
:
[
[
"
browser
.
download
.
folderList
"
2
]
[
"
browser
.
download
.
dir
"
tmpDir
Ci
.
nsIFile
]
]
}
)
;
}
let
gHttpServer
=
null
;
function
startServer
(
)
{
gHttpServer
=
new
HttpServer
(
)
;
gHttpServer
.
start
(
-
1
)
;
registerCleanupFunction
(
async
function
(
)
{
await
new
Promise
(
function
(
resolve
)
{
gHttpServer
.
stop
(
resolve
)
;
}
)
;
}
)
;
gHttpServer
.
registerPathHandler
(
"
/
file1
.
txt
"
(
request
response
)
=
>
{
response
.
setStatusLine
(
null
200
"
OK
"
)
;
response
.
write
(
"
file1
"
)
;
response
.
processAsync
(
)
;
response
.
finish
(
)
;
}
)
;
gHttpServer
.
registerPathHandler
(
"
/
file2
.
txt
"
(
request
response
)
=
>
{
response
.
setStatusLine
(
null
200
"
OK
"
)
;
response
.
write
(
"
file2
"
)
;
response
.
processAsync
(
)
;
response
.
finish
(
)
;
}
)
;
gHttpServer
.
registerPathHandler
(
"
/
file3
.
txt
"
(
request
response
)
=
>
{
response
.
setStatusLine
(
null
200
"
OK
"
)
;
response
.
write
(
"
file3
"
)
;
response
.
processAsync
(
)
;
response
.
finish
(
)
;
}
)
;
}
function
httpUrl
(
aFileName
)
{
return
"
http
:
/
/
localhost
:
"
+
gHttpServer
.
identity
.
primaryPort
+
"
/
"
+
aFileName
;
}
function
task_clearHistory
(
)
{
return
new
Promise
(
function
(
resolve
)
{
Services
.
obs
.
addObserver
(
function
observeCH
(
aSubject
aTopic
aData
)
{
Services
.
obs
.
removeObserver
(
observeCH
PlacesUtils
.
TOPIC_EXPIRATION_FINISHED
)
;
resolve
(
)
;
}
PlacesUtils
.
TOPIC_EXPIRATION_FINISHED
)
;
PlacesUtils
.
history
.
clear
(
)
;
}
)
;
}
function
openLibrary
(
aLeftPaneRoot
)
{
let
library
=
window
.
openDialog
(
"
chrome
:
/
/
browser
/
content
/
places
/
places
.
xul
"
"
"
"
chrome
toolbar
=
yes
dialog
=
no
resizable
"
aLeftPaneRoot
)
;
return
new
Promise
(
resolve
=
>
{
waitForFocus
(
resolve
library
)
;
}
)
;
}
function
promiseAlertDialogOpen
(
buttonAction
)
{
return
new
Promise
(
resolve
=
>
{
Services
.
ww
.
registerNotification
(
function
onOpen
(
subj
topic
data
)
{
if
(
topic
=
=
"
domwindowopened
"
&
&
subj
instanceof
Ci
.
nsIDOMWindow
)
{
subj
.
addEventListener
(
"
load
"
function
(
)
{
if
(
subj
.
document
.
documentURI
=
=
"
chrome
:
/
/
global
/
content
/
commonDialog
.
xul
"
)
{
Services
.
ww
.
unregisterNotification
(
onOpen
)
;
let
dialog
=
subj
.
document
.
getElementById
(
"
commonDialog
"
)
;
ok
(
dialog
.
classList
.
contains
(
"
alert
-
dialog
"
)
"
The
dialog
element
should
contain
an
alert
class
.
"
)
;
let
doc
=
subj
.
document
.
documentElement
;
doc
.
getButton
(
buttonAction
)
.
click
(
)
;
resolve
(
)
;
}
}
{
once
:
true
}
)
;
}
}
)
;
}
)
;
}
