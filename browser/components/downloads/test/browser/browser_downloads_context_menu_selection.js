"
use
strict
"
;
async
function
createDownloadFiles
(
)
{
let
dir
=
await
setDownloadDir
(
)
;
let
downloads
=
[
]
;
downloads
.
push
(
{
state
:
DownloadsCommon
.
DOWNLOAD_FAILED
contentType
:
"
text
/
plain
"
target
:
new
FileUtils
.
File
(
PathUtils
.
join
(
dir
"
does
-
not
-
exist
.
txt
"
)
)
}
)
;
downloads
.
push
(
{
state
:
DownloadsCommon
.
DOWNLOAD_FINISHED
contentType
:
"
text
/
plain
"
target
:
await
createDownloadedFile
(
PathUtils
.
join
(
dir
"
file
.
txt
"
)
"
file
"
)
}
)
;
return
downloads
;
}
add_setup
(
async
function
setup
(
)
{
await
PlacesUtils
.
history
.
clear
(
)
;
await
startServer
(
)
;
registerCleanupFunction
(
async
function
(
)
{
await
task_resetState
(
)
;
await
PlacesUtils
.
history
.
clear
(
)
;
}
)
;
}
)
;
add_task
(
async
function
test
(
)
{
let
downloadList
=
await
Downloads
.
getList
(
Downloads
.
ALL
)
;
let
downloadCount
=
(
await
downloadList
.
getAll
(
)
)
.
length
;
Assert
.
equal
(
downloadCount
0
"
There
should
be
0
downloads
"
)
;
await
task_resetState
(
)
;
let
downloads
=
await
createDownloadFiles
(
)
;
await
task_addDownloads
(
downloads
)
;
await
task_openPanel
(
)
;
let
downloadsListBox
=
document
.
getElementById
(
"
downloadsListBox
"
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
{
downloadsListBox
.
removeAttribute
(
"
disabled
"
)
;
return
downloadsListBox
.
childElementCount
=
=
downloads
.
length
;
}
)
;
let
first
=
downloadsListBox
.
querySelector
(
"
richlistitem
"
)
;
let
second
=
downloadsListBox
.
querySelector
(
"
richlistitem
:
nth
-
child
(
2
)
"
)
;
info
(
"
Check
first
item
"
)
;
let
firstDownload
=
DownloadsView
.
itemForElement
(
first
)
.
download
;
is
(
DownloadsCommon
.
stateOfDownload
(
firstDownload
)
DownloadsCommon
.
DOWNLOAD_FINISHED
"
Download
states
match
up
"
)
;
EventUtils
.
synthesizeMouse
(
second
-
5
-
5
{
type
:
"
mousemove
"
}
)
;
await
checkCommandsWithContextMenu
(
first
{
downloadsCmd_show
:
true
cmd_delete
:
true
}
)
;
info
(
"
Check
second
item
"
)
;
let
secondDownload
=
DownloadsView
.
itemForElement
(
second
)
.
download
;
is
(
DownloadsCommon
.
stateOfDownload
(
secondDownload
)
DownloadsCommon
.
DOWNLOAD_FAILED
"
Download
states
match
up
"
)
;
EventUtils
.
synthesizeMouse
(
first
-
5
-
5
{
type
:
"
mousemove
"
}
)
;
await
checkCommandsWithContextMenu
(
second
{
downloadsCmd_show
:
false
cmd_delete
:
true
}
)
;
info
(
"
Check
we
don
'
t
open
a
context
menu
between
items
.
"
)
;
function
listener
(
)
{
Assert
.
ok
(
false
"
Should
not
open
a
context
menu
"
)
;
}
document
.
addEventListener
(
"
popupshown
"
listener
)
;
let
listRect
=
downloadsListBox
.
getBoundingClientRect
(
)
;
let
firstRect
=
first
.
getBoundingClientRect
(
)
;
let
secondRect
=
second
.
getBoundingClientRect
(
)
;
let
x
=
parseInt
(
firstRect
.
width
/
2
)
;
Assert
.
greater
(
secondRect
.
y
-
firstRect
.
y
-
firstRect
.
height
1
"
There
should
be
a
gap
of
at
least
1
px
for
this
test
"
)
;
let
y
=
parseInt
(
firstRect
.
y
-
listRect
.
y
+
firstRect
.
height
+
1
)
;
info
(
Right
click
at
(
{
x
}
{
y
}
)
)
;
EventUtils
.
synthesizeMouse
(
downloadsListBox
x
y
{
type
:
"
contextmenu
"
button
:
2
}
)
;
await
new
Promise
(
r
=
>
setTimeout
(
r
100
)
)
;
document
.
removeEventListener
(
"
popupshown
"
listener
)
;
let
hiddenPromise
=
BrowserTestUtils
.
waitForEvent
(
DownloadsPanel
.
panel
"
popuphidden
"
)
;
DownloadsPanel
.
hidePanel
(
)
;
await
hiddenPromise
;
}
)
;
async
function
checkCommandsWithContextMenu
(
element
commands
)
{
let
contextMenu
=
await
openContextMenu
(
element
)
;
for
(
let
command
in
commands
)
{
let
enabled
=
commands
[
command
]
;
let
commandStatus
=
enabled
?
"
enabled
"
:
"
disabled
"
;
info
(
Checking
command
{
command
}
is
{
commandStatus
}
)
;
let
commandElt
=
contextMenu
.
querySelector
(
[
command
=
"
{
command
}
"
]
)
;
Assert
.
equal
(
!
BrowserTestUtils
.
isHidden
(
commandElt
)
enabled
{
command
}
should
be
{
enabled
?
"
visible
"
:
"
hidden
"
}
)
;
Assert
.
strictEqual
(
DownloadsView
.
richListBox
.
selectedItem
.
_shell
.
isCommandEnabled
(
command
)
enabled
{
command
}
should
be
{
commandStatus
}
)
;
}
contextMenu
.
hidePopup
(
)
;
}
