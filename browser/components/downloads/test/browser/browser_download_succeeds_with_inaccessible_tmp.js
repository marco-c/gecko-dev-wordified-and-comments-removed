"
use
strict
"
;
let
gDownloadDir
;
add_setup
(
async
function
(
)
{
startServer
(
)
;
registerCleanupFunction
(
task_resetState
)
;
gDownloadDir
=
new
FileUtils
.
File
(
await
setDownloadDir
(
)
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
download
.
start_downloads_in_tmp_dir
"
false
]
]
}
)
;
const
originalTmp
=
Services
.
dirsvc
.
get
(
"
TmpD
"
Ci
.
nsIFile
)
;
const
path
=
PathUtils
.
join
(
PathUtils
.
profileDir
"
rotemp
"
)
;
await
IOUtils
.
makeDirectory
(
path
)
;
await
IOUtils
.
setPermissions
(
path
0o444
)
;
registerCleanupFunction
(
async
(
)
=
>
{
Services
.
dirsvc
.
undefine
(
"
TmpD
"
)
;
Services
.
dirsvc
.
set
(
"
TmpD
"
originalTmp
)
;
await
IOUtils
.
setPermissions
(
path
0o777
)
;
await
IOUtils
.
remove
(
path
{
recursive
:
true
}
)
;
}
)
;
Services
.
dirsvc
.
undefine
(
"
TmpD
"
)
;
Services
.
dirsvc
.
set
(
"
TmpD
"
await
IOUtils
.
getFile
(
path
)
)
;
}
)
;
add_task
(
async
function
test
(
)
{
let
list
=
await
Downloads
.
getList
(
Downloads
.
PUBLIC
)
;
let
downloadStarted
=
new
Promise
(
resolve
=
>
{
let
view
=
{
onDownloadAdded
(
download
)
{
info
(
"
onDownloadAdded
"
)
;
list
.
removeView
(
view
)
;
resolve
(
download
)
;
}
}
;
list
.
addView
(
view
)
;
}
)
;
serveInterruptibleAsDownload
(
)
;
mustInterruptResponses
(
)
;
await
BrowserTestUtils
.
withNewTab
(
{
gBrowser
url
:
httpUrl
(
"
interruptible
.
txt
"
)
waitForLoad
:
false
waitForStop
:
true
}
async
function
(
)
{
let
download
=
await
downloadStarted
;
Assert
.
equal
(
PathUtils
.
parent
(
download
.
target
.
path
)
gDownloadDir
.
path
"
Should
have
put
final
file
in
the
downloads
dir
.
"
)
;
continueResponses
(
)
;
await
download
.
whenSucceeded
(
)
;
Assert
.
ok
(
download
.
succeeded
"
The
download
succeeded
"
)
;
Assert
.
ok
(
!
download
.
error
"
The
download
has
no
error
"
)
;
await
IOUtils
.
remove
(
download
.
target
.
path
)
;
}
)
;
await
list
.
removeFinished
(
)
;
}
)
;
