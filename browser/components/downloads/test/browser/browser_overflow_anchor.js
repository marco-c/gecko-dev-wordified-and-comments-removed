const
kForceOverflowWidthPx
=
200
;
registerCleanupFunction
(
async
function
(
)
{
await
task_resetState
(
)
;
}
)
;
add_task
(
async
function
test_overflow_anchor
(
)
{
await
task_resetState
(
)
;
let
oldWidth
=
window
.
outerWidth
;
let
button
=
CustomizableUI
.
getWidget
(
"
downloads
-
button
"
)
.
forWindow
(
window
)
;
ok
(
!
button
.
overflowed
"
Downloads
button
should
not
be
overflowed
.
"
)
;
const
kFlexyItems
=
[
"
urlbar
-
container
"
]
;
registerCleanupFunction
(
(
)
=
>
unlockWidth
(
kFlexyItems
)
)
;
lockWidth
(
kFlexyItems
)
;
window
.
resizeTo
(
kForceOverflowWidthPx
window
.
outerHeight
)
;
await
waitForOverflowed
(
button
true
)
;
let
promise
=
promisePanelOpened
(
)
;
button
.
node
.
dispatchEvent
(
new
Event
(
"
mousedown
"
)
)
;
await
promise
;
let
panel
=
DownloadsPanel
.
panel
;
let
chevron
=
document
.
getElementById
(
"
nav
-
bar
-
overflow
-
button
"
)
;
is
(
panel
.
anchorNode
chevron
"
Panel
should
be
anchored
to
the
chevron
.
"
)
;
DownloadsPanel
.
hidePanel
(
)
;
unlockWidth
(
kFlexyItems
)
;
window
.
resizeTo
(
oldWidth
window
.
outerHeight
)
;
await
waitForOverflowed
(
button
false
)
;
promise
=
promisePanelOpened
(
)
;
button
.
node
.
dispatchEvent
(
new
Event
(
"
mousedown
"
)
)
;
await
promise
;
is
(
panel
.
anchorNode
.
id
"
downloads
-
indicator
-
anchor
"
)
;
DownloadsPanel
.
hidePanel
(
)
;
}
)
;
function
lockWidth
(
aItemIDs
)
{
for
(
let
itemID
of
aItemIDs
)
{
let
item
=
document
.
getElementById
(
itemID
)
;
let
curWidth
=
item
.
getBoundingClientRect
(
)
.
width
+
"
px
"
;
item
.
style
.
minWidth
=
curWidth
;
}
}
function
unlockWidth
(
aItemIDs
)
{
for
(
let
itemID
of
aItemIDs
)
{
let
item
=
document
.
getElementById
(
itemID
)
;
item
.
style
.
minWidth
=
"
"
;
}
}
function
waitForOverflowed
(
aItem
aIsOverflowed
)
{
if
(
aItem
.
overflowed
=
=
aIsOverflowed
)
{
return
Promise
.
resolve
(
)
;
}
return
new
Promise
(
resolve
=
>
{
let
observer
=
new
MutationObserver
(
function
(
aMutations
)
{
if
(
aItem
.
overflowed
=
=
aIsOverflowed
)
{
observer
.
disconnect
(
)
;
resolve
(
)
;
}
}
)
;
observer
.
observe
(
aItem
.
node
{
attributes
:
true
}
)
;
}
)
;
}
