"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
DownloadsSubview
"
]
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
AppConstants
"
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Downloads
"
"
resource
:
/
/
gre
/
modules
/
Downloads
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
DownloadsCommon
"
"
resource
:
/
/
/
modules
/
DownloadsCommon
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
DownloadsViewUI
"
"
resource
:
/
/
/
modules
/
DownloadsViewUI
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
FileUtils
"
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
)
;
let
gPanelViewInstances
=
new
WeakMap
(
)
;
const
kEvents
=
[
"
ViewShowing
"
"
ViewHiding
"
"
click
"
"
command
"
]
;
const
kRefreshBatchSize
=
10
;
const
kMaxWaitForIdleMs
=
200
;
XPCOMUtils
.
defineLazyGetter
(
this
"
kButtonLabels
"
(
)
=
>
{
return
{
show
:
DownloadsCommon
.
strings
[
AppConstants
.
platform
=
=
"
macosx
"
?
"
showMacLabel
"
:
"
showLabel
"
]
open
:
DownloadsCommon
.
strings
.
openFileLabel
retry
:
DownloadsCommon
.
strings
.
retryLabel
}
;
}
)
;
class
DownloadsSubview
extends
DownloadsViewUI
.
BaseView
{
constructor
(
panelview
)
{
super
(
)
;
this
.
document
=
panelview
.
ownerDocument
;
this
.
window
=
panelview
.
ownerGlobal
;
this
.
context
=
"
panelDownloadsContextMenu
"
;
this
.
panelview
=
panelview
;
this
.
container
=
this
.
document
.
getElementById
(
"
panelMenu_downloadsMenu
"
)
;
while
(
this
.
container
.
lastChild
)
{
this
.
container
.
lastChild
.
remove
(
)
;
}
this
.
panelview
.
addEventListener
(
"
click
"
DownloadsSubview
.
onClick
)
;
this
.
panelview
.
addEventListener
(
"
ViewHiding
"
DownloadsSubview
.
onViewHiding
)
;
this
.
_viewItemsForDownloads
=
new
WeakMap
(
)
;
let
contextMenu
=
this
.
document
.
getElementById
(
this
.
context
)
;
if
(
!
contextMenu
)
{
contextMenu
=
this
.
document
.
getElementById
(
"
downloadsContextMenu
"
)
.
cloneNode
(
true
)
;
contextMenu
.
setAttribute
(
"
closemenu
"
"
none
"
)
;
contextMenu
.
setAttribute
(
"
id
"
this
.
context
)
;
contextMenu
.
removeAttribute
(
"
onpopupshown
"
)
;
contextMenu
.
setAttribute
(
"
onpopupshowing
"
"
DownloadsSubview
.
updateContextMenu
(
document
.
popupNode
this
)
;
"
)
;
contextMenu
.
setAttribute
(
"
onpopuphidden
"
"
DownloadsSubview
.
onContextMenuHidden
(
this
)
;
"
)
let
clearButton
=
contextMenu
.
querySelector
(
"
menuitem
[
command
=
'
downloadsCmd_clearDownloads
'
]
"
)
;
clearButton
.
hidden
=
false
;
clearButton
.
previousSibling
.
hidden
=
true
;
contextMenu
.
querySelector
(
"
menuitem
[
command
=
'
cmd_delete
'
]
"
)
.
setAttribute
(
"
command
"
"
downloadsCmd_delete
"
)
;
}
this
.
panelview
.
appendChild
(
contextMenu
)
;
this
.
container
.
setAttribute
(
"
context
"
this
.
context
)
;
this
.
_downloadsData
=
DownloadsCommon
.
getData
(
this
.
window
true
true
true
)
;
this
.
_downloadsData
.
addView
(
this
)
;
}
destructor
(
event
)
{
this
.
panelview
.
removeEventListener
(
"
click
"
DownloadsSubview
.
onClick
)
;
this
.
panelview
.
removeEventListener
(
"
ViewHiding
"
DownloadsSubview
.
onViewHiding
)
;
this
.
_downloadsData
.
removeView
(
this
)
;
gPanelViewInstances
.
delete
(
this
)
;
this
.
destroyed
=
true
;
}
onDownloadBatchStarting
(
)
{
this
.
batchFragment
=
this
.
document
.
createDocumentFragment
(
)
;
this
.
window
.
clearTimeout
(
this
.
_batchTimeout
)
;
}
onDownloadBatchEnded
(
)
{
let
{
window
}
=
this
;
window
.
clearTimeout
(
this
.
_batchTimeout
)
;
let
waitForMs
=
200
;
if
(
this
.
batchFragment
.
childElementCount
)
{
this
.
container
.
insertBefore
(
this
.
batchFragment
this
.
container
.
firstChild
|
|
null
)
;
waitForMs
=
0
;
}
this
.
_batchTimeout
=
window
.
setTimeout
(
(
)
=
>
{
this
.
_updateStatsFromDisk
(
)
;
this
.
panelview
.
dispatchEvent
(
new
window
.
CustomEvent
(
"
DownloadsLoaded
"
)
)
;
}
waitForMs
)
;
this
.
batchFragment
=
null
;
}
onDownloadAdded
(
download
{
insertBefore
}
=
{
}
)
{
let
shell
=
new
DownloadsSubview
.
Button
(
download
this
.
document
)
;
this
.
_viewItemsForDownloads
.
set
(
download
shell
)
;
shell
.
onChanged
(
)
;
if
(
insertBefore
)
{
this
.
_viewItemsForDownloads
.
get
(
insertBefore
)
.
element
.
insertAdjacentElement
(
"
afterend
"
shell
.
element
)
;
}
else
{
(
this
.
batchFragment
|
|
this
.
container
)
.
prepend
(
shell
.
element
)
;
}
}
onDownloadChanged
(
download
)
{
this
.
_viewItemsForDownloads
.
get
(
download
)
.
onChanged
(
)
;
}
onDownloadRemoved
(
download
)
{
this
.
_viewItemsForDownloads
.
get
(
download
)
.
element
.
remove
(
)
;
}
async
_updateStatsFromDisk
(
)
{
if
(
this
.
_updatingStats
)
return
;
this
.
_updatingStats
=
true
;
try
{
let
idleOptions
=
{
timeout
:
kMaxWaitForIdleMs
}
;
await
new
Promise
(
resolve
=
>
this
.
window
.
requestIdleCallback
(
resolve
)
idleOptions
)
;
if
(
this
.
destroyed
)
return
;
let
count
=
0
;
for
(
let
button
of
this
.
container
.
childNodes
)
{
if
(
this
.
destroyed
)
return
;
if
(
!
button
.
_shell
)
continue
;
await
button
.
_shell
.
refresh
(
)
;
if
(
+
+
count
%
kRefreshBatchSize
=
=
=
0
)
{
await
new
Promise
(
resolve
=
>
this
.
window
.
requestIdleCallback
(
resolve
idleOptions
)
)
;
}
}
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
finally
{
this
.
_updatingStats
=
false
;
}
}
static
init
(
window
)
{
return
new
Promise
(
resolve
=
>
window
.
DownloadsOverlayLoader
.
ensureOverlayLoaded
(
window
.
DownloadsPanel
.
kDownloadsOverlay
resolve
)
)
;
}
static
async
show
(
anchor
)
{
let
document
=
anchor
.
ownerDocument
;
let
window
=
anchor
.
ownerGlobal
;
await
DownloadsSubview
.
init
(
window
)
;
let
panelview
=
document
.
getElementById
(
"
PanelUI
-
downloads
"
)
;
anchor
.
setAttribute
(
"
closemenu
"
"
none
"
)
;
gPanelViewInstances
.
set
(
panelview
new
DownloadsSubview
(
panelview
)
)
;
panelview
.
addEventListener
(
"
ViewShowing
"
event
=
>
{
event
.
detail
.
addBlocker
(
new
Promise
(
resolve
=
>
{
panelview
.
addEventListener
(
"
DownloadsLoaded
"
resolve
{
once
:
true
}
)
;
}
)
)
;
}
{
once
:
true
}
)
;
window
.
PanelUI
.
showSubView
(
"
PanelUI
-
downloads
"
anchor
)
;
}
static
async
onShowDownloads
(
)
{
let
preferredDir
=
await
Downloads
.
getPreferredDownloadsDirectory
(
)
;
DownloadsCommon
.
showDirectory
(
new
FileUtils
.
File
(
preferredDir
)
)
;
}
static
onClearDownloads
(
button
)
{
let
instance
=
gPanelViewInstances
.
get
(
button
.
closest
(
"
panelview
"
)
)
;
if
(
!
instance
)
return
;
instance
.
_downloadsData
.
removeFinished
(
)
;
Cc
[
"
mozilla
.
org
/
browser
/
download
-
history
;
1
"
]
.
getService
(
Ci
.
nsIDownloadHistory
)
.
removeAllDownloads
(
)
;
}
static
updateContextMenu
(
button
menu
)
{
while
(
!
button
.
_shell
)
{
button
=
button
.
parentNode
;
}
menu
.
setAttribute
(
"
state
"
button
.
getAttribute
(
"
state
"
)
)
;
if
(
button
.
hasAttribute
(
"
exists
"
)
)
menu
.
setAttribute
(
"
exists
"
button
.
getAttribute
(
"
exists
"
)
)
;
else
menu
.
removeAttribute
(
"
exists
"
)
;
menu
.
classList
.
toggle
(
"
temporary
-
block
"
button
.
classList
.
contains
(
"
temporary
-
block
"
)
)
;
for
(
let
menuitem
of
menu
.
getElementsByTagName
(
"
menuitem
"
)
)
{
let
command
=
menuitem
.
getAttribute
(
"
command
"
)
;
if
(
!
command
)
continue
;
if
(
command
=
=
"
downloadsCmd_clearDownloads
"
)
{
menuitem
.
disabled
=
!
DownloadsSubview
.
canClearDownloads
(
button
)
;
}
else
{
menuitem
.
disabled
=
!
button
.
_shell
.
isCommandEnabled
(
command
)
;
}
}
menu
.
_anchorNode
=
button
;
}
static
onContextMenuHidden
(
menu
)
{
delete
menu
.
_anchorNode
;
}
static
canClearDownloads
(
button
)
{
let
instance
=
gPanelViewInstances
.
get
(
button
.
closest
(
"
panelview
"
)
)
;
if
(
!
instance
)
return
false
;
return
instance
.
canClearDownloads
(
instance
.
container
)
;
}
static
onViewHiding
(
event
)
{
let
instance
=
gPanelViewInstances
.
get
(
event
.
target
)
;
if
(
!
instance
)
return
;
instance
.
destructor
(
event
)
;
}
static
onClick
(
event
)
{
if
(
event
.
button
>
1
)
return
;
let
button
=
event
.
originalTarget
;
if
(
!
button
.
hasAttribute
|
|
button
.
classList
.
contains
(
"
subviewbutton
-
back
"
)
)
return
;
let
command
=
"
downloadsCmd_open
"
;
if
(
button
.
classList
.
contains
(
"
action
-
button
"
)
)
{
button
=
button
.
parentNode
;
command
=
button
.
hasAttribute
(
"
showLabel
"
)
?
"
downloadsCmd_show
"
:
"
downloadsCmd_retry
"
;
}
else
if
(
button
.
localName
=
=
"
menuitem
"
)
{
command
=
button
.
getAttribute
(
"
command
"
)
;
button
=
button
.
parentNode
.
_anchorNode
;
}
while
(
button
&
&
!
button
.
_shell
&
&
button
!
=
this
.
panelview
&
&
(
!
button
.
hasAttribute
|
|
!
button
.
hasAttribute
(
"
oncommand
"
)
)
)
{
button
=
button
.
parentNode
;
}
if
(
!
button
|
|
button
=
=
this
.
panelview
|
|
button
.
hasAttribute
(
"
oncommand
"
)
)
return
;
if
(
command
=
=
"
downloadsCmd_clearDownloads
"
)
{
DownloadsSubview
.
onClearDownloads
(
button
)
;
}
else
if
(
button
.
_shell
.
isCommandEnabled
(
command
)
)
{
button
.
_shell
[
command
]
(
)
;
}
}
}
DownloadsSubview
.
Button
=
class
extends
DownloadsViewUI
.
DownloadElementShell
{
constructor
(
download
document
)
{
super
(
)
;
this
.
download
=
download
;
this
.
element
=
document
.
createElement
(
"
toolbarbutton
"
)
;
this
.
element
.
_shell
=
this
;
this
.
element
.
classList
.
add
(
"
subviewbutton
"
"
subviewbutton
-
iconic
"
"
download
"
"
download
-
state
"
)
;
}
get
browserWindow
(
)
{
return
this
.
element
.
ownerGlobal
;
}
async
refresh
(
)
{
if
(
this
.
_targetFileChecked
)
return
;
try
{
await
this
.
download
.
refresh
(
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
finally
{
this
.
_targetFileChecked
=
true
;
}
}
onStateChanged
(
)
{
this
.
_targetFileChecked
=
false
;
this
.
_updateState
(
)
;
}
onChanged
(
)
{
let
newState
=
DownloadsCommon
.
stateOfDownload
(
this
.
download
)
;
if
(
this
.
_downloadState
!
=
=
newState
)
{
this
.
_downloadState
=
newState
;
this
.
onStateChanged
(
)
;
}
else
{
this
.
_updateState
(
)
;
}
this
.
element
.
classList
.
toggle
(
"
temporary
-
block
"
!
!
this
.
download
.
hasBlockedData
)
;
}
_updateState
(
)
{
super
.
_updateState
(
)
;
this
.
element
.
setAttribute
(
"
label
"
this
.
element
.
getAttribute
(
"
displayName
"
)
)
;
this
.
element
.
setAttribute
(
"
tooltiptext
"
this
.
element
.
getAttribute
(
"
fullStatus
"
)
)
;
if
(
this
.
isCommandEnabled
(
"
downloadsCmd_show
"
)
)
{
this
.
element
.
setAttribute
(
"
openLabel
"
kButtonLabels
.
open
)
;
this
.
element
.
setAttribute
(
"
showLabel
"
kButtonLabels
.
show
)
;
this
.
element
.
removeAttribute
(
"
retryLabel
"
)
;
}
else
if
(
this
.
isCommandEnabled
(
"
downloadsCmd_retry
"
)
)
{
this
.
element
.
setAttribute
(
"
retryLabel
"
kButtonLabels
.
retry
)
;
this
.
element
.
removeAttribute
(
"
openLabel
"
)
;
this
.
element
.
removeAttribute
(
"
showLabel
"
)
;
}
else
{
this
.
element
.
removeAttribute
(
"
openLabel
"
)
;
this
.
element
.
removeAttribute
(
"
retryLabel
"
)
;
this
.
element
.
removeAttribute
(
"
showLabel
"
)
;
}
this
.
_updateVisibility
(
)
;
}
_updateVisibility
(
)
{
let
state
=
this
.
element
.
getAttribute
(
"
state
"
)
;
this
.
element
.
hidden
=
!
(
state
=
=
DownloadsCommon
.
DOWNLOAD_FINISHED
|
|
state
=
=
DownloadsCommon
.
DOWNLOAD_FAILED
)
;
}
downloadsCmd_copyLocation
(
)
{
let
clipboard
=
Cc
[
"
mozilla
.
org
/
widget
/
clipboardhelper
;
1
"
]
.
getService
(
Ci
.
nsIClipboardHelper
)
;
clipboard
.
copyString
(
this
.
download
.
source
.
url
)
;
}
}
;
