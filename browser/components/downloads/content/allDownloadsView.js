ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
BrowserWindowTracker
:
"
resource
:
/
/
/
modules
/
BrowserWindowTracker
.
jsm
"
Downloads
:
"
resource
:
/
/
gre
/
modules
/
Downloads
.
jsm
"
DownloadsCommon
:
"
resource
:
/
/
/
modules
/
DownloadsCommon
.
jsm
"
DownloadsViewUI
:
"
resource
:
/
/
/
modules
/
DownloadsViewUI
.
jsm
"
FileUtils
:
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
NetUtil
:
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
OS
:
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
PlacesUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
}
)
;
function
HistoryDownloadElementShell
(
download
)
{
this
.
_download
=
download
;
this
.
element
=
document
.
createElement
(
"
richlistitem
"
)
;
this
.
element
.
_shell
=
this
;
this
.
element
.
classList
.
add
(
"
download
"
)
;
this
.
element
.
classList
.
add
(
"
download
-
state
"
)
;
}
HistoryDownloadElementShell
.
prototype
=
{
__proto__
:
DownloadsViewUI
.
DownloadElementShell
.
prototype
ensureActive
(
)
{
if
(
!
this
.
_active
)
{
this
.
_active
=
true
;
this
.
element
.
setAttribute
(
"
active
"
true
)
;
this
.
onChanged
(
)
;
}
}
get
active
(
)
{
return
!
!
this
.
_active
;
}
get
download
(
)
{
return
this
.
_download
;
}
onStateChanged
(
)
{
this
.
_targetFileChecked
=
false
;
this
.
_updateState
(
)
;
if
(
this
.
element
.
selected
)
{
goUpdateDownloadCommands
(
)
;
}
else
{
goUpdateCommand
(
"
downloadsCmd_clearDownloads
"
)
;
}
}
onChanged
(
)
{
if
(
!
this
.
active
)
{
return
;
}
let
newState
=
DownloadsCommon
.
stateOfDownload
(
this
.
download
)
;
if
(
this
.
_downloadState
!
=
=
newState
)
{
this
.
_downloadState
=
newState
;
this
.
onStateChanged
(
)
;
}
this
.
element
.
classList
.
toggle
(
"
temporary
-
block
"
!
!
this
.
download
.
hasBlockedData
)
;
this
.
_updateProgress
(
)
;
}
_downloadState
:
null
isCommandEnabled
(
aCommand
)
{
if
(
!
this
.
active
&
&
aCommand
!
=
"
cmd_delete
"
)
{
return
false
;
}
return
DownloadsViewUI
.
DownloadElementShell
.
prototype
.
isCommandEnabled
.
call
(
this
aCommand
)
;
}
downloadsCmd_unblock
(
)
{
this
.
confirmUnblock
(
window
"
unblock
"
)
;
}
downloadsCmd_chooseUnblock
(
)
{
this
.
confirmUnblock
(
window
"
chooseUnblock
"
)
;
}
downloadsCmd_chooseOpen
(
)
{
this
.
confirmUnblock
(
window
"
chooseOpen
"
)
;
}
matchesSearchTerm
(
aTerm
)
{
if
(
!
aTerm
)
{
return
true
;
}
aTerm
=
aTerm
.
toLowerCase
(
)
;
return
this
.
displayName
.
toLowerCase
(
)
.
includes
(
aTerm
)
|
|
this
.
download
.
source
.
url
.
toLowerCase
(
)
.
includes
(
aTerm
)
;
}
doDefaultCommand
(
)
{
let
command
=
this
.
currentDefaultCommandName
;
if
(
command
&
&
this
.
isCommandEnabled
(
command
)
)
{
this
.
doCommand
(
command
)
;
}
}
onSelect
(
)
{
if
(
!
this
.
active
)
{
return
;
}
if
(
!
this
.
download
.
target
.
path
)
{
return
;
}
if
(
!
this
.
_targetFileChecked
)
{
this
.
download
.
refresh
(
)
.
catch
(
Cu
.
reportError
)
.
then
(
(
)
=
>
{
this
.
_targetFileChecked
=
true
;
}
)
;
}
}
}
;
const
DownloadsView
=
{
onDownloadCommand
(
event
command
)
{
goDoCommand
(
command
)
;
}
onDownloadClick
(
)
{
}
}
;
function
DownloadsPlacesView
(
aRichListBox
aActive
=
true
)
{
this
.
_richlistbox
=
aRichListBox
;
this
.
_richlistbox
.
_placesView
=
this
;
window
.
controllers
.
insertControllerAt
(
0
this
)
;
this
.
_viewItemsForDownloads
=
new
WeakMap
(
)
;
this
.
_searchTerm
=
"
"
;
this
.
_active
=
aActive
;
this
.
_initiallySelectedElement
=
null
;
this
.
_downloadsData
=
DownloadsCommon
.
getData
(
window
.
opener
|
|
window
true
)
;
this
.
_downloadsData
.
addView
(
this
)
;
DownloadsCommon
.
getIndicatorData
(
window
)
.
attention
=
DownloadsCommon
.
ATTENTION_NONE
;
window
.
addEventListener
(
"
unload
"
(
)
=
>
{
window
.
controllers
.
removeController
(
this
)
;
this
.
_downloadsData
.
removeView
(
this
)
;
this
.
result
=
null
;
}
true
)
;
window
.
addEventListener
(
"
resize
"
(
)
=
>
{
this
.
_ensureVisibleElementsAreActive
(
)
;
}
true
)
;
}
DownloadsPlacesView
.
prototype
=
{
__proto__
:
DownloadsViewUI
.
BaseView
.
prototype
get
associatedElement
(
)
{
return
this
.
_richlistbox
;
}
get
active
(
)
{
return
this
.
_active
;
}
set
active
(
val
)
{
this
.
_active
=
val
;
if
(
this
.
_active
)
this
.
_ensureVisibleElementsAreActive
(
)
;
return
this
.
_active
;
}
_ensureVisibleElementsAreActive
(
)
{
if
(
!
this
.
active
|
|
this
.
_ensureVisibleTimer
|
|
!
this
.
_richlistbox
.
firstChild
)
{
return
;
}
this
.
_ensureVisibleTimer
=
setTimeout
(
(
)
=
>
{
delete
this
.
_ensureVisibleTimer
;
if
(
!
this
.
_richlistbox
.
firstChild
)
{
return
;
}
let
rlbRect
=
this
.
_richlistbox
.
getBoundingClientRect
(
)
;
let
winUtils
=
window
.
windowUtils
;
let
nodes
=
winUtils
.
nodesFromRect
(
rlbRect
.
left
rlbRect
.
top
0
rlbRect
.
width
rlbRect
.
height
0
true
false
)
;
let
firstVisibleNode
lastVisibleNode
;
for
(
let
node
of
nodes
)
{
if
(
node
.
localName
=
=
=
"
richlistitem
"
&
&
node
.
_shell
)
{
node
.
_shell
.
ensureActive
(
)
;
firstVisibleNode
=
node
;
if
(
!
lastVisibleNode
)
{
lastVisibleNode
=
node
;
}
}
}
let
nodeBelowVisibleArea
=
lastVisibleNode
&
&
lastVisibleNode
.
nextSibling
;
if
(
nodeBelowVisibleArea
&
&
nodeBelowVisibleArea
.
_shell
)
{
nodeBelowVisibleArea
.
_shell
.
ensureActive
(
)
;
}
let
nodeAboveVisibleArea
=
firstVisibleNode
&
&
firstVisibleNode
.
previousSibling
;
if
(
nodeAboveVisibleArea
&
&
nodeAboveVisibleArea
.
_shell
)
{
nodeAboveVisibleArea
.
_shell
.
ensureActive
(
)
;
}
}
10
)
;
}
_place
:
"
"
get
place
(
)
{
return
this
.
_place
;
}
set
place
(
val
)
{
if
(
this
.
_place
=
=
val
)
{
this
.
searchTerm
=
"
"
;
}
else
{
this
.
_place
=
val
;
}
}
get
selectedNodes
(
)
{
return
Array
.
filter
(
this
.
_richlistbox
.
selectedItems
element
=
>
element
.
_shell
.
download
.
placesNode
)
;
}
get
selectedNode
(
)
{
let
selectedNodes
=
this
.
selectedNodes
;
return
selectedNodes
.
length
=
=
1
?
selectedNodes
[
0
]
:
null
;
}
get
hasSelection
(
)
{
return
this
.
selectedNodes
.
length
>
0
;
}
get
controller
(
)
{
return
this
.
_richlistbox
.
controller
;
}
get
searchTerm
(
)
{
return
this
.
_searchTerm
;
}
set
searchTerm
(
aValue
)
{
if
(
this
.
_searchTerm
!
=
aValue
)
{
for
(
let
element
of
this
.
_richlistbox
.
childNodes
)
{
element
.
hidden
=
!
element
.
_shell
.
matchesSearchTerm
(
aValue
)
;
}
this
.
_ensureVisibleElementsAreActive
(
)
;
}
return
this
.
_searchTerm
=
aValue
;
}
_ensureInitialSelection
(
)
{
if
(
this
.
_richlistbox
.
selectedItem
=
=
this
.
_initiallySelectedElement
)
{
let
firstDownloadElement
=
this
.
_richlistbox
.
firstChild
;
if
(
firstDownloadElement
!
=
this
.
_initiallySelectedElement
)
{
firstDownloadElement
.
_shell
.
ensureActive
(
)
;
Services
.
tm
.
dispatchToMainThread
(
(
)
=
>
{
this
.
_richlistbox
.
selectedItem
=
firstDownloadElement
;
this
.
_richlistbox
.
currentItem
=
firstDownloadElement
;
this
.
_initiallySelectedElement
=
firstDownloadElement
;
}
)
;
}
}
}
batchFragment
:
null
onDownloadBatchStarting
(
)
{
this
.
batchFragment
=
document
.
createDocumentFragment
(
)
;
this
.
oldSuppressOnSelect
=
this
.
_richlistbox
.
suppressOnSelect
;
this
.
_richlistbox
.
suppressOnSelect
=
true
;
}
onDownloadBatchEnded
(
)
{
this
.
_richlistbox
.
suppressOnSelect
=
this
.
oldSuppressOnSelect
;
delete
this
.
oldSuppressOnSelect
;
if
(
this
.
batchFragment
.
childElementCount
)
{
this
.
_prependBatchFragment
(
)
;
}
this
.
batchFragment
=
null
;
this
.
_ensureInitialSelection
(
)
;
this
.
_ensureVisibleElementsAreActive
(
)
;
goUpdateDownloadCommands
(
)
;
}
_prependBatchFragment
(
)
{
let
xblFields
=
new
Map
(
)
;
for
(
let
key
of
Object
.
getOwnPropertyNames
(
this
.
_richlistbox
)
)
{
let
value
=
this
.
_richlistbox
[
key
]
;
xblFields
.
set
(
key
value
)
;
}
let
oldActiveElement
=
document
.
activeElement
;
let
parentNode
=
this
.
_richlistbox
.
parentNode
;
let
nextSibling
=
this
.
_richlistbox
.
nextSibling
;
parentNode
.
removeChild
(
this
.
_richlistbox
)
;
this
.
_richlistbox
.
prepend
(
this
.
batchFragment
)
;
parentNode
.
insertBefore
(
this
.
_richlistbox
nextSibling
)
;
if
(
oldActiveElement
&
&
oldActiveElement
!
=
document
.
activeElement
)
{
oldActiveElement
.
focus
(
)
;
}
for
(
let
[
key
value
]
of
xblFields
)
{
this
.
_richlistbox
[
key
]
=
value
;
}
}
onDownloadAdded
(
download
{
insertBefore
}
=
{
}
)
{
let
shell
=
new
HistoryDownloadElementShell
(
download
)
;
this
.
_viewItemsForDownloads
.
set
(
download
shell
)
;
if
(
insertBefore
)
{
this
.
_viewItemsForDownloads
.
get
(
insertBefore
)
.
element
.
insertAdjacentElement
(
"
afterend
"
shell
.
element
)
;
}
else
{
(
this
.
batchFragment
|
|
this
.
_richlistbox
)
.
prepend
(
shell
.
element
)
;
}
if
(
this
.
searchTerm
)
{
shell
.
element
.
hidden
=
!
shell
.
matchesSearchTerm
(
this
.
searchTerm
)
;
}
if
(
!
this
.
batchFragment
)
{
this
.
_ensureVisibleElementsAreActive
(
)
;
goUpdateCommand
(
"
downloadsCmd_clearDownloads
"
)
;
}
}
onDownloadChanged
(
download
)
{
this
.
_viewItemsForDownloads
.
get
(
download
)
.
onChanged
(
)
;
}
onDownloadRemoved
(
download
)
{
let
element
=
this
.
_viewItemsForDownloads
.
get
(
download
)
.
element
;
if
(
(
element
.
nextSibling
|
|
element
.
previousSibling
)
&
&
this
.
_richlistbox
.
selectedItems
&
&
this
.
_richlistbox
.
selectedItems
.
length
=
=
1
&
&
this
.
_richlistbox
.
selectedItems
[
0
]
=
=
element
)
{
this
.
_richlistbox
.
selectItem
(
element
.
nextSibling
|
|
element
.
previousSibling
)
;
}
this
.
_richlistbox
.
removeItemFromSelection
(
element
)
;
element
.
remove
(
)
;
if
(
!
this
.
batchFragment
)
{
this
.
_ensureVisibleElementsAreActive
(
)
;
goUpdateCommand
(
"
downloadsCmd_clearDownloads
"
)
;
}
}
supportsCommand
(
aCommand
)
{
if
(
!
DownloadsViewUI
.
isCommandName
(
aCommand
)
)
{
return
false
;
}
if
(
!
(
aCommand
in
this
)
&
&
!
(
aCommand
in
HistoryDownloadElementShell
.
prototype
)
)
{
return
false
;
}
return
aCommand
=
=
"
downloadsCmd_clearDownloads
"
|
|
document
.
activeElement
=
=
this
.
_richlistbox
;
}
isCommandEnabled
(
aCommand
)
{
switch
(
aCommand
)
{
case
"
cmd_copy
"
:
case
"
downloadsCmd_openReferrer
"
:
case
"
downloadShowMenuItem
"
:
return
this
.
_richlistbox
.
selectedItems
.
length
=
=
1
;
case
"
cmd_selectAll
"
:
return
true
;
case
"
cmd_paste
"
:
return
this
.
_canDownloadClipboardURL
(
)
;
case
"
downloadsCmd_clearDownloads
"
:
return
this
.
canClearDownloads
(
this
.
_richlistbox
)
;
default
:
return
Array
.
every
(
this
.
_richlistbox
.
selectedItems
element
=
>
element
.
_shell
.
isCommandEnabled
(
aCommand
)
)
;
}
}
_copySelectedDownloadsToClipboard
(
)
{
let
urls
=
Array
.
map
(
this
.
_richlistbox
.
selectedItems
element
=
>
element
.
_shell
.
download
.
source
.
url
)
;
Cc
[
"
mozilla
.
org
/
widget
/
clipboardhelper
;
1
"
]
.
getService
(
Ci
.
nsIClipboardHelper
)
.
copyString
(
urls
.
join
(
"
\
n
"
)
)
;
}
_getURLFromClipboardData
(
)
{
let
trans
=
Cc
[
"
mozilla
.
org
/
widget
/
transferable
;
1
"
]
.
createInstance
(
Ci
.
nsITransferable
)
;
trans
.
init
(
null
)
;
let
flavors
=
[
"
text
/
x
-
moz
-
url
"
"
text
/
unicode
"
]
;
flavors
.
forEach
(
trans
.
addDataFlavor
)
;
Services
.
clipboard
.
getData
(
trans
Services
.
clipboard
.
kGlobalClipboard
)
;
try
{
let
data
=
{
}
;
trans
.
getAnyTransferData
(
{
}
data
{
}
)
;
let
[
url
name
]
=
data
.
value
.
QueryInterface
(
Ci
.
nsISupportsString
)
.
data
.
split
(
"
\
n
"
)
;
if
(
url
)
{
return
[
NetUtil
.
newURI
(
url
)
.
spec
name
]
;
}
}
catch
(
ex
)
{
}
return
[
"
"
"
"
]
;
}
_canDownloadClipboardURL
(
)
{
let
[
url
]
=
this
.
_getURLFromClipboardData
(
)
;
return
url
!
=
"
"
;
}
_downloadURLFromClipboard
(
)
{
let
[
url
name
]
=
this
.
_getURLFromClipboardData
(
)
;
let
browserWin
=
BrowserWindowTracker
.
getTopWindow
(
)
;
let
initiatingDoc
=
browserWin
?
browserWin
.
document
:
document
;
DownloadURL
(
url
name
initiatingDoc
)
;
}
doCommand
(
aCommand
)
{
if
(
!
this
.
isCommandEnabled
(
aCommand
)
)
{
return
;
}
if
(
aCommand
in
this
)
{
this
[
aCommand
]
(
)
;
return
;
}
let
selectedElements
=
[
.
.
.
this
.
_richlistbox
.
selectedItems
]
;
for
(
let
element
of
selectedElements
)
{
element
.
_shell
.
doCommand
(
aCommand
)
;
}
}
onEvent
(
)
{
}
cmd_copy
(
)
{
this
.
_copySelectedDownloadsToClipboard
(
)
;
}
cmd_selectAll
(
)
{
this
.
_richlistbox
.
selectAll
(
)
;
}
cmd_paste
(
)
{
this
.
_downloadURLFromClipboard
(
)
;
}
downloadsCmd_clearDownloads
(
)
{
this
.
_downloadsData
.
removeFinished
(
)
;
if
(
this
.
_place
)
{
PlacesUtils
.
history
.
removeVisitsByFilter
(
{
transition
:
PlacesUtils
.
history
.
TRANSITIONS
.
DOWNLOAD
}
)
.
catch
(
Cu
.
reportError
)
;
}
goUpdateCommand
(
"
downloadsCmd_clearDownloads
"
)
;
}
onContextMenu
(
aEvent
)
{
let
element
=
this
.
_richlistbox
.
selectedItem
;
if
(
!
element
|
|
!
element
.
_shell
)
{
return
false
;
}
let
contextMenu
=
document
.
getElementById
(
"
downloadsContextMenu
"
)
;
let
download
=
element
.
_shell
.
download
;
contextMenu
.
setAttribute
(
"
state
"
DownloadsCommon
.
stateOfDownload
(
download
)
)
;
contextMenu
.
setAttribute
(
"
exists
"
"
true
"
)
;
contextMenu
.
classList
.
toggle
(
"
temporary
-
block
"
!
!
download
.
hasBlockedData
)
;
if
(
!
download
.
stopped
)
{
goUpdateCommand
(
"
downloadsCmd_pauseResume
"
)
;
}
return
true
;
}
onKeyPress
(
aEvent
)
{
let
selectedElements
=
this
.
_richlistbox
.
selectedItems
;
if
(
aEvent
.
keyCode
=
=
KeyEvent
.
DOM_VK_RETURN
)
{
if
(
selectedElements
.
length
=
=
1
)
{
let
element
=
selectedElements
[
0
]
;
if
(
element
.
_shell
)
{
element
.
_shell
.
doDefaultCommand
(
)
;
}
}
}
else
if
(
aEvent
.
charCode
=
=
"
"
.
charCodeAt
(
0
)
)
{
for
(
let
element
of
selectedElements
)
{
if
(
element
.
_shell
.
isCommandEnabled
(
"
downloadsCmd_pauseResume
"
)
)
{
element
.
_shell
.
doCommand
(
"
downloadsCmd_pauseResume
"
)
;
}
}
}
}
onDoubleClick
(
aEvent
)
{
if
(
aEvent
.
button
!
=
0
)
{
return
;
}
let
selectedElements
=
this
.
_richlistbox
.
selectedItems
;
if
(
selectedElements
.
length
!
=
1
)
{
return
;
}
let
element
=
selectedElements
[
0
]
;
if
(
element
.
_shell
)
{
element
.
_shell
.
doDefaultCommand
(
)
;
}
}
onScroll
(
)
{
this
.
_ensureVisibleElementsAreActive
(
)
;
}
onSelect
(
)
{
goUpdateDownloadCommands
(
)
;
let
selectedElements
=
this
.
_richlistbox
.
selectedItems
;
for
(
let
elt
of
selectedElements
)
{
if
(
elt
.
_shell
)
{
elt
.
_shell
.
onSelect
(
)
;
}
}
}
onDragStart
(
aEvent
)
{
let
selectedItem
=
this
.
_richlistbox
.
selectedItem
;
if
(
!
selectedItem
)
{
return
;
}
let
targetPath
=
selectedItem
.
_shell
.
download
.
target
.
path
;
if
(
!
targetPath
)
{
return
;
}
let
file
=
new
FileUtils
.
File
(
targetPath
)
;
if
(
!
file
.
exists
(
)
)
{
return
;
}
let
dt
=
aEvent
.
dataTransfer
;
dt
.
mozSetDataAt
(
"
application
/
x
-
moz
-
file
"
file
0
)
;
let
url
=
Services
.
io
.
newFileURI
(
file
)
.
spec
;
dt
.
setData
(
"
text
/
uri
-
list
"
url
)
;
dt
.
setData
(
"
text
/
plain
"
url
)
;
dt
.
effectAllowed
=
"
copyMove
"
;
dt
.
addElement
(
selectedItem
)
;
}
onDragOver
(
aEvent
)
{
let
types
=
aEvent
.
dataTransfer
.
types
;
if
(
types
.
includes
(
"
text
/
uri
-
list
"
)
|
|
types
.
includes
(
"
text
/
x
-
moz
-
url
"
)
|
|
types
.
includes
(
"
text
/
plain
"
)
)
{
aEvent
.
preventDefault
(
)
;
}
}
onDrop
(
aEvent
)
{
let
dt
=
aEvent
.
dataTransfer
;
if
(
dt
.
mozGetDataAt
(
"
application
/
x
-
moz
-
file
"
0
)
)
{
return
;
}
let
links
=
Services
.
droppedLinkHandler
.
dropLinks
(
aEvent
)
;
if
(
!
links
.
length
)
return
;
let
browserWin
=
BrowserWindowTracker
.
getTopWindow
(
)
;
let
initiatingDoc
=
browserWin
?
browserWin
.
document
:
document
;
for
(
let
link
of
links
)
{
if
(
link
.
url
.
startsWith
(
"
about
:
"
)
)
continue
;
DownloadURL
(
link
.
url
link
.
name
initiatingDoc
)
;
}
}
}
;
for
(
let
methodName
of
[
"
load
"
"
applyFilter
"
"
selectNode
"
"
selectItems
"
]
)
{
DownloadsPlacesView
.
prototype
[
methodName
]
=
function
(
)
{
throw
new
Error
(
"
|
"
+
methodName
+
"
|
is
not
implemented
by
the
downloads
view
.
"
)
;
}
;
}
function
goUpdateDownloadCommands
(
)
{
function
updateCommandsForObject
(
object
)
{
for
(
let
name
in
object
)
{
if
(
DownloadsViewUI
.
isCommandName
(
name
)
)
{
goUpdateCommand
(
name
)
;
}
}
}
updateCommandsForObject
(
DownloadsPlacesView
.
prototype
)
;
updateCommandsForObject
(
HistoryDownloadElementShell
.
prototype
)
;
}
