"
use
strict
"
;
var
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
}
=
Components
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
DownloadsViewUI
"
"
resource
:
/
/
/
modules
/
DownloadsViewUI
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
DownloadsSubview
"
"
resource
:
/
/
/
modules
/
DownloadsSubview
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
FileUtils
"
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
NetUtil
"
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PlacesUtils
"
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Services
"
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
var
DownloadsPanel
=
{
_state
:
0
get
kStateUninitialized
(
)
{
return
0
;
}
get
kStateHidden
(
)
{
return
1
;
}
get
kStateWaitingData
(
)
{
return
2
;
}
get
kStateWaitingAnchor
(
)
{
return
3
;
}
get
kStateShown
(
)
{
return
4
;
}
get
kDownloadsOverlay
(
)
{
return
"
chrome
:
/
/
browser
/
content
/
downloads
/
downloadsOverlay
.
xul
"
;
}
initialize
(
aCallback
)
{
DownloadsCommon
.
log
(
"
Attempting
to
initialize
DownloadsPanel
for
a
window
.
"
)
;
if
(
this
.
_state
!
=
this
.
kStateUninitialized
)
{
DownloadsCommon
.
log
(
"
DownloadsPanel
is
already
initialized
.
"
)
;
DownloadsOverlayLoader
.
ensureOverlayLoaded
(
this
.
kDownloadsOverlay
aCallback
)
;
return
;
}
this
.
_state
=
this
.
kStateHidden
;
window
.
addEventListener
(
"
unload
"
this
.
onWindowUnload
)
;
DownloadsCommon
.
initializeAllDataLinks
(
)
;
DownloadsCommon
.
log
(
"
Ensuring
DownloadsPanel
overlay
loaded
.
"
)
;
DownloadsOverlayLoader
.
ensureOverlayLoaded
(
this
.
kDownloadsOverlay
(
)
=
>
{
DownloadsViewController
.
initialize
(
)
;
DownloadsCommon
.
log
(
"
Attaching
DownloadsView
.
.
.
"
)
;
DownloadsCommon
.
getData
(
window
)
.
addView
(
DownloadsView
)
;
DownloadsCommon
.
getSummary
(
window
DownloadsView
.
kItemCountLimit
)
.
addView
(
DownloadsSummary
)
;
DownloadsCommon
.
log
(
"
DownloadsView
attached
-
the
panel
for
this
window
"
"
should
now
see
download
items
come
in
.
"
)
;
DownloadsPanel
.
_attachEventListeners
(
)
;
DownloadsCommon
.
log
(
"
DownloadsPanel
initialized
.
"
)
;
aCallback
(
)
;
}
)
;
}
terminate
(
)
{
DownloadsCommon
.
log
(
"
Attempting
to
terminate
DownloadsPanel
for
a
window
.
"
)
;
if
(
this
.
_state
=
=
this
.
kStateUninitialized
)
{
DownloadsCommon
.
log
(
"
DownloadsPanel
was
never
initialized
.
Nothing
to
do
.
"
)
;
return
;
}
window
.
removeEventListener
(
"
unload
"
this
.
onWindowUnload
)
;
this
.
hidePanel
(
)
;
DownloadsViewController
.
terminate
(
)
;
DownloadsCommon
.
getData
(
window
)
.
removeView
(
DownloadsView
)
;
DownloadsCommon
.
getSummary
(
window
DownloadsView
.
kItemCountLimit
)
.
removeView
(
DownloadsSummary
)
;
this
.
_unattachEventListeners
(
)
;
this
.
_state
=
this
.
kStateUninitialized
;
DownloadsSummary
.
active
=
false
;
DownloadsCommon
.
log
(
"
DownloadsPanel
terminated
.
"
)
;
}
get
panel
(
)
{
let
downloadsPanel
=
document
.
getElementById
(
"
downloadsPanel
"
)
;
if
(
!
downloadsPanel
)
return
null
;
delete
this
.
panel
;
return
this
.
panel
=
downloadsPanel
;
}
showPanel
(
)
{
DownloadsCommon
.
log
(
"
Opening
the
downloads
panel
.
"
)
;
if
(
this
.
isPanelShowing
)
{
DownloadsCommon
.
log
(
"
Panel
is
already
showing
-
focusing
instead
.
"
)
;
this
.
_focusPanel
(
)
;
return
;
}
DownloadsButton
.
unhide
(
)
;
this
.
initialize
(
(
)
=
>
{
setTimeout
(
(
)
=
>
this
.
_openPopupIfDataReady
(
)
0
)
;
}
)
;
DownloadsCommon
.
log
(
"
Waiting
for
the
downloads
panel
to
appear
.
"
)
;
this
.
_state
=
this
.
kStateWaitingData
;
}
hidePanel
(
)
{
DownloadsCommon
.
log
(
"
Closing
the
downloads
panel
.
"
)
;
if
(
!
this
.
isPanelShowing
)
{
DownloadsCommon
.
log
(
"
Downloads
panel
is
not
showing
-
nothing
to
do
.
"
)
;
return
;
}
this
.
panel
.
hidePopup
(
)
;
this
.
_state
=
this
.
kStateHidden
;
DownloadsCommon
.
log
(
"
Downloads
panel
is
now
closed
.
"
)
;
}
get
isPanelShowing
(
)
{
return
this
.
_state
=
=
this
.
kStateWaitingData
|
|
this
.
_state
=
=
this
.
kStateWaitingAnchor
|
|
this
.
_state
=
=
this
.
kStateShown
;
}
get
keyFocusing
(
)
{
return
this
.
panel
.
hasAttribute
(
"
keyfocus
"
)
;
}
set
keyFocusing
(
aValue
)
{
if
(
aValue
)
{
this
.
panel
.
setAttribute
(
"
keyfocus
"
"
true
"
)
;
this
.
panel
.
addEventListener
(
"
mousemove
"
this
)
;
}
else
{
this
.
panel
.
removeAttribute
(
"
keyfocus
"
)
;
this
.
panel
.
removeEventListener
(
"
mousemove
"
this
)
;
}
return
aValue
;
}
handleEvent
(
aEvent
)
{
switch
(
aEvent
.
type
)
{
case
"
mousemove
"
:
this
.
keyFocusing
=
false
;
break
;
case
"
keydown
"
:
this
.
_onKeyDown
(
aEvent
)
;
break
;
case
"
keypress
"
:
this
.
_onKeyPress
(
aEvent
)
;
break
;
}
}
onViewLoadCompleted
(
)
{
this
.
_openPopupIfDataReady
(
)
;
}
onWindowUnload
(
)
{
DownloadsPanel
.
terminate
(
)
;
}
onPopupShown
(
aEvent
)
{
if
(
aEvent
.
target
!
=
aEvent
.
currentTarget
)
{
return
;
}
DownloadsCommon
.
log
(
"
Downloads
panel
has
shown
.
"
)
;
this
.
_state
=
this
.
kStateShown
;
DownloadsCommon
.
getIndicatorData
(
window
)
.
attentionSuppressed
=
true
;
if
(
DownloadsView
.
richListBox
.
itemCount
>
0
&
&
DownloadsView
.
richListBox
.
selectedIndex
=
=
-
1
)
{
DownloadsView
.
richListBox
.
selectedIndex
=
0
;
}
this
.
_focusPanel
(
)
;
}
onPopupHidden
(
aEvent
)
{
if
(
aEvent
.
target
!
=
aEvent
.
currentTarget
)
{
return
;
}
DownloadsCommon
.
log
(
"
Downloads
panel
has
hidden
.
"
)
;
this
.
keyFocusing
=
false
;
DownloadsCommon
.
getIndicatorData
(
window
)
.
attentionSuppressed
=
false
;
DownloadsButton
.
releaseAnchor
(
)
;
this
.
_state
=
this
.
kStateHidden
;
}
showDownloadsHistory
(
)
{
DownloadsCommon
.
log
(
"
Showing
download
history
.
"
)
;
this
.
hidePanel
(
)
;
BrowserDownloadsUI
(
)
;
}
_attachEventListeners
(
)
{
this
.
panel
.
addEventListener
(
"
keydown
"
this
)
;
this
.
panel
.
addEventListener
(
"
keypress
"
this
)
;
}
_unattachEventListeners
(
)
{
this
.
panel
.
removeEventListener
(
"
keydown
"
this
)
;
this
.
panel
.
removeEventListener
(
"
keypress
"
this
)
;
}
_onKeyPress
(
aEvent
)
{
if
(
aEvent
.
altKey
|
|
aEvent
.
ctrlKey
|
|
aEvent
.
shiftKey
|
|
aEvent
.
metaKey
)
{
return
;
}
let
richListBox
=
DownloadsView
.
richListBox
;
if
(
(
aEvent
.
keyCode
=
=
Ci
.
nsIDOMKeyEvent
.
DOM_VK_TAB
|
|
aEvent
.
keyCode
=
=
Ci
.
nsIDOMKeyEvent
.
DOM_VK_UP
|
|
aEvent
.
keyCode
=
=
Ci
.
nsIDOMKeyEvent
.
DOM_VK_DOWN
)
&
&
!
this
.
keyFocusing
)
{
this
.
keyFocusing
=
true
;
if
(
DownloadsView
.
richListBox
.
selectedIndex
=
=
-
1
)
{
DownloadsView
.
richListBox
.
selectedIndex
=
0
;
}
aEvent
.
preventDefault
(
)
;
return
;
}
if
(
aEvent
.
keyCode
=
=
Ci
.
nsIDOMKeyEvent
.
DOM_VK_DOWN
)
{
if
(
richListBox
.
selectedItem
=
=
=
richListBox
.
lastChild
|
|
document
.
activeElement
.
parentNode
.
id
=
=
=
"
downloadsFooter
"
)
{
DownloadsFooter
.
focus
(
)
;
aEvent
.
preventDefault
(
)
;
return
;
}
}
if
(
document
.
activeElement
=
=
=
richListBox
)
{
DownloadsView
.
onDownloadKeyPress
(
aEvent
)
;
}
}
_onKeyDown
(
aEvent
)
{
if
(
aEvent
.
keyCode
=
=
Ci
.
nsIDOMKeyEvent
.
DOM_VK_UP
&
&
document
.
activeElement
.
parentNode
.
id
=
=
=
"
downloadsFooter
"
&
&
DownloadsView
.
richListBox
.
firstChild
)
{
DownloadsView
.
richListBox
.
focus
(
)
;
DownloadsView
.
richListBox
.
selectedItem
=
DownloadsView
.
richListBox
.
lastChild
;
aEvent
.
preventDefault
(
)
;
return
;
}
let
pasting
=
aEvent
.
keyCode
=
=
Ci
.
nsIDOMKeyEvent
.
DOM_VK_V
&
&
aEvent
.
getModifierState
(
"
Accel
"
)
;
if
(
!
pasting
)
{
return
;
}
DownloadsCommon
.
log
(
"
Received
a
paste
event
.
"
)
;
let
trans
=
Cc
[
"
mozilla
.
org
/
widget
/
transferable
;
1
"
]
.
createInstance
(
Ci
.
nsITransferable
)
;
trans
.
init
(
null
)
;
let
flavors
=
[
"
text
/
x
-
moz
-
url
"
"
text
/
unicode
"
]
;
flavors
.
forEach
(
trans
.
addDataFlavor
)
;
Services
.
clipboard
.
getData
(
trans
Services
.
clipboard
.
kGlobalClipboard
)
;
try
{
let
data
=
{
}
;
trans
.
getAnyTransferData
(
{
}
data
{
}
)
;
let
[
url
name
]
=
data
.
value
.
QueryInterface
(
Ci
.
nsISupportsString
)
.
data
.
split
(
"
\
n
"
)
;
if
(
!
url
)
{
return
;
}
let
uri
=
NetUtil
.
newURI
(
url
)
;
DownloadsCommon
.
log
(
"
Pasted
URL
seems
valid
.
Starting
download
.
"
)
;
DownloadURL
(
uri
.
spec
name
document
)
;
}
catch
(
ex
)
{
}
}
_focusPanel
(
)
{
if
(
this
.
_state
!
=
this
.
kStateShown
)
{
return
;
}
let
element
=
document
.
commandDispatcher
.
focusedElement
;
while
(
element
&
&
element
!
=
this
.
panel
)
{
element
=
element
.
parentNode
;
}
if
(
!
element
)
{
if
(
DownloadsView
.
richListBox
.
itemCount
>
0
)
{
DownloadsView
.
richListBox
.
focus
(
)
;
}
else
{
DownloadsFooter
.
focus
(
)
;
}
}
}
_openPopupIfDataReady
(
)
{
if
(
this
.
_state
!
=
this
.
kStateWaitingData
|
|
DownloadsView
.
loading
)
{
return
;
}
this
.
_state
=
this
.
kStateWaitingAnchor
;
DownloadsButton
.
getAnchor
(
anchor
=
>
{
if
(
this
.
_state
!
=
this
.
kStateWaitingAnchor
)
{
return
;
}
if
(
window
.
windowState
=
=
window
.
STATE_MINIMIZED
)
{
DownloadsButton
.
releaseAnchor
(
)
;
this
.
_state
=
this
.
kStateHidden
;
return
;
}
if
(
!
anchor
)
{
DownloadsCommon
.
error
(
"
Downloads
button
cannot
be
found
.
"
)
;
return
;
}
let
onBookmarksToolbar
=
!
!
anchor
.
closest
(
"
#
PersonalToolbar
"
)
;
this
.
panel
.
classList
.
toggle
(
"
bookmarks
-
toolbar
"
onBookmarksToolbar
)
;
for
(
let
viewItem
of
DownloadsView
.
_visibleViewItems
.
values
(
)
)
{
viewItem
.
download
.
refresh
(
)
.
catch
(
Cu
.
reportError
)
;
}
DownloadsCommon
.
log
(
"
Opening
downloads
panel
popup
.
"
)
;
this
.
panel
.
openPopup
(
anchor
"
bottomcenter
topright
"
0
0
false
null
)
;
}
)
;
}
}
;
XPCOMUtils
.
defineConstant
(
this
"
DownloadsPanel
"
DownloadsPanel
)
;
var
DownloadsOverlayLoader
=
{
_loadRequests
:
[
]
_overlayLoading
:
false
_loadedOverlays
:
{
}
ensureOverlayLoaded
(
aOverlay
aCallback
)
{
if
(
aOverlay
in
this
.
_loadedOverlays
)
{
aCallback
(
)
;
return
;
}
this
.
_loadRequests
.
push
(
{
overlay
:
aOverlay
callback
:
aCallback
}
)
;
if
(
this
.
_overlayLoading
)
{
return
;
}
this
.
_overlayLoading
=
true
;
DownloadsCommon
.
log
(
"
Loading
overlay
"
aOverlay
)
;
document
.
loadOverlay
(
aOverlay
(
)
=
>
{
this
.
_overlayLoading
=
false
;
this
.
_loadedOverlays
[
aOverlay
]
=
true
;
this
.
processPendingRequests
(
)
;
}
)
;
}
processPendingRequests
(
)
{
let
currentLength
=
this
.
_loadRequests
.
length
;
for
(
let
i
=
0
;
i
<
currentLength
;
i
+
+
)
{
let
request
=
this
.
_loadRequests
.
shift
(
)
;
this
.
ensureOverlayLoaded
(
request
.
overlay
request
.
callback
)
;
}
}
}
;
XPCOMUtils
.
defineConstant
(
this
"
DownloadsOverlayLoader
"
DownloadsOverlayLoader
)
;
var
DownloadsView
=
{
kItemCountLimit
:
5
contextMenuOpen
:
false
subViewOpen
:
false
loading
:
false
_downloads
:
[
]
_visibleViewItems
:
new
Map
(
)
_itemCountChanged
(
)
{
DownloadsCommon
.
log
(
"
The
downloads
item
count
has
changed
-
we
are
tracking
"
this
.
_downloads
.
length
"
downloads
in
total
.
"
)
;
let
count
=
this
.
_downloads
.
length
;
let
hiddenCount
=
count
-
this
.
kItemCountLimit
;
if
(
count
>
0
)
{
DownloadsCommon
.
log
(
"
Setting
the
panel
'
s
hasdownloads
attribute
to
true
.
"
)
;
DownloadsPanel
.
panel
.
setAttribute
(
"
hasdownloads
"
"
true
"
)
;
}
else
{
DownloadsCommon
.
log
(
"
Removing
the
panel
'
s
hasdownloads
attribute
.
"
)
;
DownloadsPanel
.
panel
.
removeAttribute
(
"
hasdownloads
"
)
;
}
DownloadsSummary
.
active
=
hiddenCount
>
0
;
}
get
richListBox
(
)
{
delete
this
.
richListBox
;
return
this
.
richListBox
=
document
.
getElementById
(
"
downloadsListBox
"
)
;
}
get
downloadsHistory
(
)
{
delete
this
.
downloadsHistory
;
return
this
.
downloadsHistory
=
document
.
getElementById
(
"
downloadsHistory
"
)
;
}
onDownloadBatchStarting
(
)
{
DownloadsCommon
.
log
(
"
onDownloadBatchStarting
called
for
DownloadsView
.
"
)
;
this
.
loading
=
true
;
}
onDownloadBatchEnded
(
)
{
DownloadsCommon
.
log
(
"
onDownloadBatchEnded
called
for
DownloadsView
.
"
)
;
this
.
loading
=
false
;
this
.
_itemCountChanged
(
)
;
DownloadsPanel
.
onViewLoadCompleted
(
)
;
}
onDownloadAdded
(
download
)
{
DownloadsCommon
.
log
(
"
A
new
download
data
item
was
added
"
)
;
this
.
_downloads
.
unshift
(
download
)
;
this
.
_addViewItem
(
download
true
)
;
if
(
this
.
_downloads
.
length
>
this
.
kItemCountLimit
)
{
this
.
_removeViewItem
(
this
.
_downloads
[
this
.
kItemCountLimit
]
)
;
}
if
(
!
this
.
loading
)
{
this
.
_itemCountChanged
(
)
;
}
}
onDownloadChanged
(
download
)
{
let
viewItem
=
this
.
_visibleViewItems
.
get
(
download
)
;
if
(
viewItem
)
{
viewItem
.
onChanged
(
)
;
}
}
onDownloadRemoved
(
download
)
{
DownloadsCommon
.
log
(
"
A
download
data
item
was
removed
.
"
)
;
let
itemIndex
=
this
.
_downloads
.
indexOf
(
download
)
;
this
.
_downloads
.
splice
(
itemIndex
1
)
;
if
(
itemIndex
<
this
.
kItemCountLimit
)
{
this
.
_removeViewItem
(
download
)
;
if
(
this
.
_downloads
.
length
>
=
this
.
kItemCountLimit
)
{
this
.
_addViewItem
(
this
.
_downloads
[
this
.
kItemCountLimit
-
1
]
false
)
;
}
}
this
.
_itemCountChanged
(
)
;
}
_itemsForElements
:
new
Map
(
)
itemForElement
(
element
)
{
return
this
.
_itemsForElements
.
get
(
element
)
;
}
_addViewItem
(
download
aNewest
)
{
DownloadsCommon
.
log
(
"
Adding
a
new
DownloadsViewItem
to
the
downloads
list
.
"
"
aNewest
=
"
aNewest
)
;
let
element
=
document
.
createElement
(
"
richlistitem
"
)
;
let
viewItem
=
new
DownloadsViewItem
(
download
element
)
;
this
.
_visibleViewItems
.
set
(
download
viewItem
)
;
this
.
_itemsForElements
.
set
(
element
viewItem
)
;
if
(
aNewest
)
{
this
.
richListBox
.
insertBefore
(
element
this
.
richListBox
.
firstChild
)
;
}
else
{
this
.
richListBox
.
appendChild
(
element
)
;
}
}
_removeViewItem
(
download
)
{
DownloadsCommon
.
log
(
"
Removing
a
DownloadsViewItem
from
the
downloads
list
.
"
)
;
let
element
=
this
.
_visibleViewItems
.
get
(
download
)
.
element
;
let
previousSelectedIndex
=
this
.
richListBox
.
selectedIndex
;
this
.
richListBox
.
removeChild
(
element
)
;
if
(
previousSelectedIndex
!
=
-
1
)
{
this
.
richListBox
.
selectedIndex
=
Math
.
min
(
previousSelectedIndex
this
.
richListBox
.
itemCount
-
1
)
;
}
this
.
_visibleViewItems
.
delete
(
download
)
;
this
.
_itemsForElements
.
delete
(
element
)
;
}
onDownloadCommand
(
aEvent
aCommand
)
{
let
target
=
aEvent
.
target
;
while
(
target
.
nodeName
!
=
"
richlistitem
"
)
{
target
=
target
.
parentNode
;
}
DownloadsView
.
itemForElement
(
target
)
.
doCommand
(
aCommand
)
;
}
onDownloadClick
(
aEvent
)
{
if
(
aEvent
.
button
=
=
0
&
&
!
aEvent
.
originalTarget
.
hasAttribute
(
"
oncommand
"
)
)
{
let
target
=
aEvent
.
target
;
while
(
target
.
nodeName
!
=
"
richlistitem
"
)
{
target
=
target
.
parentNode
;
}
let
download
=
DownloadsView
.
itemForElement
(
target
)
.
download
;
if
(
download
.
hasBlockedData
)
{
goDoCommand
(
"
downloadsCmd_showBlockedInfo
"
)
;
}
else
{
goDoCommand
(
"
downloadsCmd_open
"
)
;
}
}
}
onDownloadKeyPress
(
aEvent
)
{
if
(
aEvent
.
originalTarget
.
hasAttribute
(
"
command
"
)
|
|
aEvent
.
originalTarget
.
hasAttribute
(
"
oncommand
"
)
)
{
return
;
}
if
(
aEvent
.
charCode
=
=
"
"
.
charCodeAt
(
0
)
)
{
goDoCommand
(
"
downloadsCmd_pauseResume
"
)
;
return
;
}
if
(
aEvent
.
keyCode
=
=
KeyEvent
.
DOM_VK_RETURN
)
{
goDoCommand
(
"
downloadsCmd_doDefault
"
)
;
}
}
onContextPopupShown
(
aEvent
)
{
if
(
aEvent
.
target
!
=
aEvent
.
currentTarget
)
{
return
;
}
DownloadsCommon
.
log
(
"
Context
menu
has
shown
.
"
)
;
this
.
contextMenuOpen
=
true
;
}
onContextPopupHidden
(
aEvent
)
{
if
(
aEvent
.
target
!
=
aEvent
.
currentTarget
)
{
return
;
}
DownloadsCommon
.
log
(
"
Context
menu
has
hidden
.
"
)
;
this
.
contextMenuOpen
=
false
;
}
onDownloadMouseOver
(
aEvent
)
{
if
(
aEvent
.
originalTarget
.
classList
.
contains
(
"
downloadButton
"
)
)
{
aEvent
.
target
.
classList
.
add
(
"
downloadHoveringButton
"
)
;
let
button
=
aEvent
.
originalTarget
;
let
tooltip
=
button
.
getAttribute
(
"
tooltiptext
"
)
;
if
(
tooltip
)
{
button
.
setAttribute
(
"
aria
-
label
"
tooltip
)
;
button
.
removeAttribute
(
"
tooltiptext
"
)
;
}
}
if
(
!
(
this
.
contextMenuOpen
|
|
this
.
subViewOpen
)
&
&
aEvent
.
target
.
parentNode
=
=
this
.
richListBox
)
{
this
.
richListBox
.
selectedItem
=
aEvent
.
target
;
}
}
onDownloadMouseOut
(
aEvent
)
{
if
(
aEvent
.
originalTarget
.
classList
.
contains
(
"
downloadButton
"
)
)
{
aEvent
.
target
.
classList
.
remove
(
"
downloadHoveringButton
"
)
;
}
if
(
!
(
this
.
contextMenuOpen
|
|
this
.
subViewOpen
)
&
&
aEvent
.
target
.
parentNode
=
=
this
.
richListBox
)
{
let
element
=
aEvent
.
relatedTarget
;
while
(
element
&
&
element
!
=
aEvent
.
target
)
{
element
=
element
.
parentNode
;
}
if
(
!
element
)
{
this
.
richListBox
.
selectedIndex
=
-
1
;
}
}
}
onDownloadContextMenu
(
aEvent
)
{
let
element
=
this
.
richListBox
.
selectedItem
;
if
(
!
element
)
{
return
;
}
DownloadsViewController
.
updateCommands
(
)
;
let
contextMenu
=
document
.
getElementById
(
"
downloadsContextMenu
"
)
;
contextMenu
.
setAttribute
(
"
state
"
element
.
getAttribute
(
"
state
"
)
)
;
if
(
element
.
hasAttribute
(
"
exists
"
)
)
{
contextMenu
.
setAttribute
(
"
exists
"
"
true
"
)
;
}
else
{
contextMenu
.
removeAttribute
(
"
exists
"
)
;
}
contextMenu
.
classList
.
toggle
(
"
temporary
-
block
"
element
.
classList
.
contains
(
"
temporary
-
block
"
)
)
;
}
onDownloadDragStart
(
aEvent
)
{
let
element
=
this
.
richListBox
.
selectedItem
;
if
(
!
element
)
{
return
;
}
let
file
=
new
FileUtils
.
File
(
DownloadsView
.
itemForElement
(
element
)
.
download
.
target
.
path
)
;
if
(
!
file
.
exists
(
)
)
{
return
;
}
let
dataTransfer
=
aEvent
.
dataTransfer
;
dataTransfer
.
mozSetDataAt
(
"
application
/
x
-
moz
-
file
"
file
0
)
;
dataTransfer
.
effectAllowed
=
"
copyMove
"
;
let
spec
=
NetUtil
.
newURI
(
file
)
.
spec
;
dataTransfer
.
setData
(
"
text
/
uri
-
list
"
spec
)
;
dataTransfer
.
setData
(
"
text
/
plain
"
spec
)
;
dataTransfer
.
addElement
(
element
)
;
aEvent
.
stopPropagation
(
)
;
}
}
;
XPCOMUtils
.
defineConstant
(
this
"
DownloadsView
"
DownloadsView
)
;
function
DownloadsViewItem
(
download
aElement
)
{
this
.
download
=
download
;
this
.
downloadState
=
DownloadsCommon
.
stateOfDownload
(
download
)
;
this
.
element
=
aElement
;
this
.
element
.
_shell
=
this
;
this
.
element
.
setAttribute
(
"
type
"
"
download
"
)
;
this
.
element
.
classList
.
add
(
"
download
-
state
"
)
;
this
.
_updateState
(
)
;
}
DownloadsViewItem
.
prototype
=
{
__proto__
:
DownloadsViewUI
.
DownloadElementShell
.
prototype
_element
:
null
onChanged
(
)
{
let
newState
=
DownloadsCommon
.
stateOfDownload
(
this
.
download
)
;
if
(
this
.
downloadState
!
=
newState
)
{
this
.
downloadState
=
newState
;
this
.
_updateState
(
)
;
}
this
.
_updateProgress
(
)
;
}
isCommandEnabled
(
aCommand
)
{
switch
(
aCommand
)
{
case
"
downloadsCmd_open
"
:
{
if
(
!
this
.
download
.
succeeded
)
{
return
false
;
}
let
file
=
new
FileUtils
.
File
(
this
.
download
.
target
.
path
)
;
return
file
.
exists
(
)
;
}
case
"
downloadsCmd_show
"
:
{
let
file
=
new
FileUtils
.
File
(
this
.
download
.
target
.
path
)
;
if
(
file
.
exists
(
)
)
{
return
true
;
}
if
(
!
this
.
download
.
target
.
partFilePath
)
{
return
false
;
}
let
partFile
=
new
FileUtils
.
File
(
this
.
download
.
target
.
partFilePath
)
;
return
partFile
.
exists
(
)
;
}
case
"
cmd_delete
"
:
case
"
downloadsCmd_copyLocation
"
:
case
"
downloadsCmd_doDefault
"
:
return
true
;
case
"
downloadsCmd_showBlockedInfo
"
:
return
this
.
download
.
hasBlockedData
;
}
return
DownloadsViewUI
.
DownloadElementShell
.
prototype
.
isCommandEnabled
.
call
(
this
aCommand
)
;
}
doCommand
(
aCommand
)
{
if
(
this
.
isCommandEnabled
(
aCommand
)
)
{
this
[
aCommand
]
(
)
;
}
}
downloadsCmd_unblock
(
)
{
DownloadsPanel
.
hidePanel
(
)
;
this
.
confirmUnblock
(
window
"
unblock
"
)
;
}
downloadsCmd_chooseUnblock
(
)
{
DownloadsPanel
.
hidePanel
(
)
;
this
.
confirmUnblock
(
window
"
chooseUnblock
"
)
;
}
downloadsCmd_unblockAndOpen
(
)
{
DownloadsPanel
.
hidePanel
(
)
;
this
.
unblockAndOpenDownload
(
)
.
catch
(
Cu
.
reportError
)
;
}
downloadsCmd_open
(
)
{
this
.
download
.
launch
(
)
.
catch
(
Cu
.
reportError
)
;
DownloadsPanel
.
hidePanel
(
)
;
}
downloadsCmd_show
(
)
{
let
file
=
new
FileUtils
.
File
(
this
.
download
.
target
.
path
)
;
DownloadsCommon
.
showDownloadedFile
(
file
)
;
DownloadsPanel
.
hidePanel
(
)
;
}
downloadsCmd_showBlockedInfo
(
)
{
DownloadsBlockedSubview
.
toggle
(
this
.
element
.
.
.
this
.
rawBlockedTitleAndDetails
)
;
}
downloadsCmd_openReferrer
(
)
{
openURL
(
this
.
download
.
source
.
referrer
)
;
}
downloadsCmd_copyLocation
(
)
{
let
clipboard
=
Cc
[
"
mozilla
.
org
/
widget
/
clipboardhelper
;
1
"
]
.
getService
(
Ci
.
nsIClipboardHelper
)
;
clipboard
.
copyString
(
this
.
download
.
source
.
url
)
;
}
downloadsCmd_doDefault
(
)
{
let
defaultCommand
=
this
.
currentDefaultCommandName
;
if
(
defaultCommand
&
&
this
.
isCommandEnabled
(
defaultCommand
)
)
{
this
.
doCommand
(
defaultCommand
)
;
}
}
}
;
var
DownloadsViewController
=
{
initialize
(
)
{
window
.
controllers
.
insertControllerAt
(
0
this
)
;
}
terminate
(
)
{
window
.
controllers
.
removeController
(
this
)
;
}
supportsCommand
(
aCommand
)
{
if
(
aCommand
=
=
=
"
downloadsCmd_clearList
"
)
{
return
true
;
}
if
(
!
DownloadsViewUI
.
isCommandName
(
aCommand
)
)
{
return
false
;
}
if
(
!
(
aCommand
in
this
)
&
&
!
(
aCommand
in
DownloadsViewItem
.
prototype
)
)
{
return
false
;
}
if
(
DownloadsBlockedSubview
.
view
.
showingSubView
)
{
let
blockedSubviewCmds
=
[
"
downloadsCmd_unblockAndOpen
"
"
cmd_delete
"
]
;
return
blockedSubviewCmds
.
indexOf
(
aCommand
)
>
=
0
;
}
let
element
=
document
.
commandDispatcher
.
focusedElement
;
while
(
element
&
&
element
!
=
DownloadsView
.
richListBox
)
{
element
=
element
.
parentNode
;
}
return
!
!
element
;
}
isCommandEnabled
(
aCommand
)
{
if
(
aCommand
=
=
"
downloadsCmd_clearList
"
)
{
return
DownloadsCommon
.
getData
(
window
)
.
canRemoveFinished
;
}
let
element
=
DownloadsView
.
richListBox
.
selectedItem
;
return
element
&
&
DownloadsView
.
itemForElement
(
element
)
.
isCommandEnabled
(
aCommand
)
;
}
doCommand
(
aCommand
)
{
if
(
aCommand
in
this
)
{
this
[
aCommand
]
(
)
;
return
;
}
let
element
=
DownloadsView
.
richListBox
.
selectedItem
;
if
(
element
)
{
DownloadsView
.
itemForElement
(
element
)
.
doCommand
(
aCommand
)
;
}
}
onEvent
(
)
{
}
updateCommands
(
)
{
function
updateCommandsForObject
(
object
)
{
for
(
let
name
in
object
)
{
if
(
DownloadsViewUI
.
isCommandName
(
name
)
)
{
goUpdateCommand
(
name
)
;
}
}
}
updateCommandsForObject
(
this
)
;
updateCommandsForObject
(
DownloadsViewItem
.
prototype
)
;
}
downloadsCmd_clearList
(
)
{
DownloadsCommon
.
getData
(
window
)
.
removeFinished
(
)
;
}
}
;
XPCOMUtils
.
defineConstant
(
this
"
DownloadsViewController
"
DownloadsViewController
)
;
var
DownloadsSummary
=
{
set
active
(
aActive
)
{
if
(
aActive
=
=
this
.
_active
|
|
!
this
.
_summaryNode
)
{
return
this
.
_active
;
}
if
(
aActive
)
{
DownloadsCommon
.
getSummary
(
window
DownloadsView
.
kItemCountLimit
)
.
refreshView
(
this
)
;
}
else
{
DownloadsFooter
.
showingSummary
=
false
;
}
return
this
.
_active
=
aActive
;
}
get
active
(
)
{
return
this
.
_active
;
}
_active
:
false
set
showingProgress
(
aShowingProgress
)
{
if
(
aShowingProgress
)
{
this
.
_summaryNode
.
setAttribute
(
"
inprogress
"
"
true
"
)
;
}
else
{
this
.
_summaryNode
.
removeAttribute
(
"
inprogress
"
)
;
}
return
DownloadsFooter
.
showingSummary
=
aShowingProgress
;
}
set
percentComplete
(
aValue
)
{
if
(
this
.
_progressNode
)
{
this
.
_progressNode
.
setAttribute
(
"
value
"
aValue
)
;
}
return
aValue
;
}
set
description
(
aValue
)
{
if
(
this
.
_descriptionNode
)
{
this
.
_descriptionNode
.
setAttribute
(
"
value
"
aValue
)
;
this
.
_descriptionNode
.
setAttribute
(
"
tooltiptext
"
aValue
)
;
}
return
aValue
;
}
set
details
(
aValue
)
{
if
(
this
.
_detailsNode
)
{
this
.
_detailsNode
.
setAttribute
(
"
value
"
aValue
)
;
this
.
_detailsNode
.
setAttribute
(
"
tooltiptext
"
aValue
)
;
}
return
aValue
;
}
focus
(
)
{
if
(
this
.
_summaryNode
)
{
this
.
_summaryNode
.
focus
(
)
;
}
}
onKeyDown
(
aEvent
)
{
if
(
aEvent
.
charCode
=
=
"
"
.
charCodeAt
(
0
)
|
|
aEvent
.
keyCode
=
=
KeyEvent
.
DOM_VK_RETURN
)
{
DownloadsPanel
.
showDownloadsHistory
(
)
;
}
}
onClick
(
aEvent
)
{
DownloadsPanel
.
showDownloadsHistory
(
)
;
}
get
_summaryNode
(
)
{
let
node
=
document
.
getElementById
(
"
downloadsSummary
"
)
;
if
(
!
node
)
{
return
null
;
}
delete
this
.
_summaryNode
;
return
this
.
_summaryNode
=
node
;
}
get
_progressNode
(
)
{
let
node
=
document
.
getElementById
(
"
downloadsSummaryProgress
"
)
;
if
(
!
node
)
{
return
null
;
}
delete
this
.
_progressNode
;
return
this
.
_progressNode
=
node
;
}
get
_descriptionNode
(
)
{
let
node
=
document
.
getElementById
(
"
downloadsSummaryDescription
"
)
;
if
(
!
node
)
{
return
null
;
}
delete
this
.
_descriptionNode
;
return
this
.
_descriptionNode
=
node
;
}
get
_detailsNode
(
)
{
let
node
=
document
.
getElementById
(
"
downloadsSummaryDetails
"
)
;
if
(
!
node
)
{
return
null
;
}
delete
this
.
_detailsNode
;
return
this
.
_detailsNode
=
node
;
}
}
;
XPCOMUtils
.
defineConstant
(
this
"
DownloadsSummary
"
DownloadsSummary
)
;
var
DownloadsFooter
=
{
focus
(
)
{
if
(
this
.
_showingSummary
)
{
DownloadsSummary
.
focus
(
)
;
}
else
{
DownloadsView
.
downloadsHistory
.
focus
(
)
;
}
}
_showingSummary
:
false
set
showingSummary
(
aValue
)
{
if
(
this
.
_footerNode
)
{
if
(
aValue
)
{
this
.
_footerNode
.
setAttribute
(
"
showingsummary
"
"
true
"
)
;
}
else
{
this
.
_footerNode
.
removeAttribute
(
"
showingsummary
"
)
;
}
this
.
_showingSummary
=
aValue
;
}
return
aValue
;
}
get
_footerNode
(
)
{
let
node
=
document
.
getElementById
(
"
downloadsFooter
"
)
;
if
(
!
node
)
{
return
null
;
}
delete
this
.
_footerNode
;
return
this
.
_footerNode
=
node
;
}
}
;
XPCOMUtils
.
defineConstant
(
this
"
DownloadsFooter
"
DownloadsFooter
)
;
var
DownloadsBlockedSubview
=
{
get
subview
(
)
{
let
subview
=
document
.
getElementById
(
"
downloadsPanel
-
blockedSubview
"
)
;
delete
this
.
subview
;
return
this
.
subview
=
subview
;
}
get
elements
(
)
{
let
idSuffixes
=
[
"
title
"
"
details1
"
"
details2
"
"
openButton
"
"
deleteButton
"
]
;
let
elements
=
idSuffixes
.
reduce
(
(
memo
s
)
=
>
{
memo
[
s
]
=
document
.
getElementById
(
"
downloadsPanel
-
blockedSubview
-
"
+
s
)
;
return
memo
;
}
{
}
)
;
delete
this
.
elements
;
return
this
.
elements
=
elements
;
}
get
view
(
)
{
let
view
=
document
.
getElementById
(
"
downloadsPanel
-
multiView
"
)
;
delete
this
.
view
;
return
this
.
view
=
view
;
}
element
:
undefined
toggle
(
element
title
details
)
{
DownloadsView
.
subViewOpen
=
true
;
DownloadsViewController
.
updateCommands
(
)
;
let
e
=
this
.
elements
;
let
s
=
DownloadsCommon
.
strings
;
e
.
title
.
textContent
=
title
;
e
.
details1
.
textContent
=
details
[
0
]
;
e
.
details2
.
textContent
=
details
[
1
]
;
e
.
openButton
.
label
=
s
.
unblockButtonOpen
;
e
.
deleteButton
.
label
=
s
.
unblockButtonConfirmBlock
;
let
verdict
=
element
.
getAttribute
(
"
verdict
"
)
;
this
.
subview
.
setAttribute
(
"
verdict
"
verdict
)
;
this
.
subview
.
addEventListener
(
"
ViewHiding
"
this
)
;
this
.
view
.
showSubView
(
this
.
subview
.
id
)
;
document
.
getElementById
(
"
downloadsPanel
-
mainView
"
)
.
style
.
minWidth
=
window
.
getComputedStyle
(
this
.
subview
)
.
width
;
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
ViewHiding
"
:
this
.
subview
.
removeEventListener
(
event
.
type
this
)
;
DownloadsView
.
subViewOpen
=
false
;
if
(
this
.
view
.
current
!
=
=
this
.
subview
)
{
DownloadsPanel
.
showPanel
(
)
;
}
break
;
default
:
DownloadsCommon
.
log
(
"
Unhandled
DownloadsBlockedSubview
event
:
"
+
event
.
type
)
;
break
;
}
}
confirmBlock
(
)
{
goDoCommand
(
"
cmd_delete
"
)
;
DownloadsPanel
.
hidePanel
(
)
;
}
}
;
XPCOMUtils
.
defineConstant
(
this
"
DownloadsBlockedSubview
"
DownloadsBlockedSubview
)
;
