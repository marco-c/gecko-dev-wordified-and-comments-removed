"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
DownloadsCommon
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineESModuleGetters
(
lazy
{
PlacesUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
sys
.
mjs
"
}
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
NetUtil
:
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
BrowserWindowTracker
:
"
resource
:
/
/
/
modules
/
BrowserWindowTracker
.
jsm
"
DownloadHistory
:
"
resource
:
/
/
gre
/
modules
/
DownloadHistory
.
jsm
"
Downloads
:
"
resource
:
/
/
gre
/
modules
/
Downloads
.
jsm
"
DownloadUtils
:
"
resource
:
/
/
gre
/
modules
/
DownloadUtils
.
jsm
"
PrivateBrowsingUtils
:
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyServiceGetters
(
lazy
{
gClipboardHelper
:
[
"
mozilla
.
org
/
widget
/
clipboardhelper
;
1
"
"
nsIClipboardHelper
"
]
gMIMEService
:
[
"
mozilla
.
org
/
mime
;
1
"
"
nsIMIMEService
"
]
}
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
DownloadsLogger
"
(
)
=
>
{
let
{
ConsoleAPI
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Console
.
jsm
"
)
;
let
consoleOptions
=
{
maxLogLevelPref
:
"
browser
.
download
.
loglevel
"
prefix
:
"
Downloads
"
}
;
return
new
ConsoleAPI
(
consoleOptions
)
;
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
lazy
"
gAlwaysOpenPanel
"
"
browser
.
download
.
alwaysOpenPanel
"
true
)
;
const
kDownloadsStringBundleUrl
=
"
chrome
:
/
/
browser
/
locale
/
downloads
/
downloads
.
properties
"
;
const
kDownloadsFluentStrings
=
new
Localization
(
[
"
browser
/
downloads
.
ftl
"
]
true
)
;
const
kDownloadsStringsRequiringFormatting
=
{
sizeWithUnits
:
true
statusSeparator
:
true
statusSeparatorBeforeNumber
:
true
}
;
const
kMaxHistoryResultsForLimitedView
=
42
;
const
kPrefBranch
=
Services
.
prefs
.
getBranch
(
"
browser
.
download
.
"
)
;
const
kGenericContentTypes
=
[
"
application
/
octet
-
stream
"
"
binary
/
octet
-
stream
"
"
application
/
unknown
"
]
;
var
PrefObserver
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIObserver
"
"
nsISupportsWeakReference
"
]
)
getPref
(
name
)
{
try
{
switch
(
typeof
this
.
prefs
[
name
]
)
{
case
"
boolean
"
:
return
kPrefBranch
.
getBoolPref
(
name
)
;
}
}
catch
(
ex
)
{
}
return
this
.
prefs
[
name
]
;
}
observe
(
aSubject
aTopic
aData
)
{
if
(
this
.
prefs
.
hasOwnProperty
(
aData
)
)
{
delete
this
[
aData
]
;
this
[
aData
]
=
this
.
getPref
(
aData
)
;
}
}
register
(
prefs
)
{
this
.
prefs
=
prefs
;
kPrefBranch
.
addObserver
(
"
"
this
true
)
;
for
(
let
key
in
prefs
)
{
let
name
=
key
;
XPCOMUtils
.
defineLazyGetter
(
this
name
function
(
)
{
return
PrefObserver
.
getPref
(
name
)
;
}
)
;
}
}
}
;
PrefObserver
.
register
(
{
animateNotifications
:
true
openInSystemViewerContextMenuItem
:
true
alwaysOpenInSystemViewerContextMenuItem
:
true
}
)
;
var
DownloadsCommon
=
{
DOWNLOAD_NOTSTARTED
:
-
1
DOWNLOAD_DOWNLOADING
:
0
DOWNLOAD_FINISHED
:
1
DOWNLOAD_FAILED
:
2
DOWNLOAD_CANCELED
:
3
DOWNLOAD_PAUSED
:
4
DOWNLOAD_BLOCKED_PARENTAL
:
6
DOWNLOAD_DIRTY
:
8
DOWNLOAD_BLOCKED_POLICY
:
9
ATTENTION_NONE
:
"
"
ATTENTION_SUCCESS
:
"
success
"
ATTENTION_INFO
:
"
info
"
ATTENTION_WARNING
:
"
warning
"
ATTENTION_SEVERE
:
"
severe
"
SUPPRESS_NONE
:
0
SUPPRESS_PANEL_OPEN
:
1
SUPPRESS_ALL_DOWNLOADS_OPEN
:
2
SUPPRESS_CONTENT_AREA_DOWNLOADS_OPEN
:
4
get
strings
(
)
{
let
strings
=
{
}
;
let
sb
=
Services
.
strings
.
createBundle
(
kDownloadsStringBundleUrl
)
;
for
(
let
string
of
sb
.
getSimpleEnumeration
(
)
)
{
let
stringName
=
string
.
key
;
if
(
stringName
in
kDownloadsStringsRequiringFormatting
)
{
strings
[
stringName
]
=
function
(
)
{
return
sb
.
formatStringFromName
(
stringName
Array
.
from
(
arguments
)
)
;
}
;
}
else
{
strings
[
stringName
]
=
string
.
value
;
}
}
delete
this
.
strings
;
return
(
this
.
strings
=
strings
)
;
}
get
animateNotifications
(
)
{
return
PrefObserver
.
animateNotifications
;
}
get
openInSystemViewerItemEnabled
(
)
{
return
PrefObserver
.
openInSystemViewerContextMenuItem
;
}
get
alwaysOpenInSystemViewerItemEnabled
(
)
{
return
PrefObserver
.
alwaysOpenInSystemViewerContextMenuItem
;
}
getData
(
window
history
=
false
privateAll
=
false
limited
=
false
)
{
let
isPrivate
=
window
&
&
lazy
.
PrivateBrowsingUtils
.
isContentWindowPrivate
(
window
)
;
if
(
isPrivate
&
&
!
privateAll
)
{
return
lazy
.
PrivateDownloadsData
;
}
if
(
history
)
{
if
(
isPrivate
&
&
privateAll
)
{
return
lazy
.
LimitedPrivateHistoryDownloadData
;
}
return
limited
?
lazy
.
LimitedHistoryDownloadsData
:
lazy
.
HistoryDownloadsData
;
}
return
lazy
.
DownloadsData
;
}
initializeAllDataLinks
(
)
{
lazy
.
DownloadsData
.
initializeDataLink
(
)
;
lazy
.
PrivateDownloadsData
.
initializeDataLink
(
)
;
}
getIndicatorData
(
aWindow
)
{
if
(
lazy
.
PrivateBrowsingUtils
.
isContentWindowPrivate
(
aWindow
)
)
{
return
lazy
.
PrivateDownloadsIndicatorData
;
}
return
lazy
.
DownloadsIndicatorData
;
}
getSummary
(
aWindow
aNumToExclude
)
{
if
(
lazy
.
PrivateBrowsingUtils
.
isContentWindowPrivate
(
aWindow
)
)
{
if
(
this
.
_privateSummary
)
{
return
this
.
_privateSummary
;
}
return
(
this
.
_privateSummary
=
new
DownloadsSummaryData
(
true
aNumToExclude
)
)
;
}
if
(
this
.
_summary
)
{
return
this
.
_summary
;
}
return
(
this
.
_summary
=
new
DownloadsSummaryData
(
false
aNumToExclude
)
)
;
}
_summary
:
null
_privateSummary
:
null
stateOfDownload
(
download
)
{
if
(
!
download
.
stopped
)
{
return
DownloadsCommon
.
DOWNLOAD_DOWNLOADING
;
}
if
(
download
.
succeeded
)
{
return
DownloadsCommon
.
DOWNLOAD_FINISHED
;
}
if
(
download
.
error
)
{
if
(
download
.
error
.
becauseBlockedByParentalControls
)
{
return
DownloadsCommon
.
DOWNLOAD_BLOCKED_PARENTAL
;
}
if
(
download
.
error
.
becauseBlockedByReputationCheck
)
{
return
DownloadsCommon
.
DOWNLOAD_DIRTY
;
}
return
DownloadsCommon
.
DOWNLOAD_FAILED
;
}
if
(
download
.
canceled
)
{
if
(
download
.
hasPartialData
)
{
return
DownloadsCommon
.
DOWNLOAD_PAUSED
;
}
return
DownloadsCommon
.
DOWNLOAD_CANCELED
;
}
return
DownloadsCommon
.
DOWNLOAD_NOTSTARTED
;
}
async
deleteDownload
(
download
)
{
if
(
download
.
error
?
.
becauseBlockedByReputationCheck
&
&
download
.
hasBlockedData
)
{
Services
.
telemetry
.
getKeyedHistogramById
(
"
DOWNLOADS_USER_ACTION_ON_BLOCKED_DOWNLOAD
"
)
.
add
(
download
.
error
.
reputationCheckVerdict
1
)
;
}
try
{
await
lazy
.
PlacesUtils
.
history
.
remove
(
download
.
source
.
url
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
let
list
=
await
lazy
.
Downloads
.
getList
(
lazy
.
Downloads
.
ALL
)
;
await
list
.
remove
(
download
)
;
await
download
.
finalize
(
true
)
;
}
async
deleteDownloadFiles
(
download
clearHistory
=
0
)
{
if
(
clearHistory
>
1
)
{
try
{
await
lazy
.
PlacesUtils
.
history
.
remove
(
download
.
source
.
url
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
}
if
(
clearHistory
>
0
)
{
let
list
=
await
lazy
.
Downloads
.
getList
(
lazy
.
Downloads
.
ALL
)
;
await
list
.
remove
(
download
)
;
}
await
download
.
manuallyRemoveData
(
)
;
if
(
clearHistory
<
2
)
{
lazy
.
DownloadHistory
.
updateMetaData
(
download
)
.
catch
(
Cu
.
reportError
)
;
}
}
getMimeInfo
(
download
)
{
if
(
!
download
.
succeeded
)
{
return
null
;
}
let
contentType
=
download
.
contentType
;
let
url
=
Cc
[
"
mozilla
.
org
/
network
/
standard
-
url
-
mutator
;
1
"
]
.
createInstance
(
Ci
.
nsIURIMutator
)
.
setSpec
(
"
http
:
/
/
example
.
com
"
)
.
setFilePath
(
download
.
target
.
path
)
.
finalize
(
)
.
QueryInterface
(
Ci
.
nsIURL
)
;
let
fileExtension
=
url
.
fileExtension
;
if
(
!
contentType
|
|
kGenericContentTypes
.
includes
(
contentType
)
)
{
try
{
contentType
=
lazy
.
gMIMEService
.
getTypeFromExtension
(
fileExtension
)
;
}
catch
(
ex
)
{
DownloadsCommon
.
log
(
"
Cant
get
mimeType
from
file
extension
:
"
fileExtension
)
;
}
}
if
(
!
(
contentType
|
|
fileExtension
)
)
{
return
null
;
}
let
mimeInfo
=
null
;
try
{
mimeInfo
=
lazy
.
gMIMEService
.
getFromTypeAndExtension
(
contentType
|
|
"
"
fileExtension
|
|
"
"
)
;
}
catch
(
ex
)
{
DownloadsCommon
.
log
(
"
Can
'
t
get
nsIMIMEInfo
for
contentType
:
"
contentType
"
and
fileExtension
:
"
fileExtension
)
;
}
return
mimeInfo
;
}
isFileOfType
(
download
mimeType
)
{
if
(
!
(
download
.
succeeded
&
&
download
.
target
?
.
exists
)
)
{
DownloadsCommon
.
log
(
isFileOfType
returning
false
for
mimeType
:
{
mimeType
}
succeeded
:
{
download
.
succeeded
}
exists
:
{
download
.
target
?
.
exists
}
)
;
return
false
;
}
let
mimeInfo
=
DownloadsCommon
.
getMimeInfo
(
download
)
;
return
mimeInfo
?
.
type
=
=
=
mimeType
.
toLowerCase
(
)
;
}
copyDownloadLink
(
download
)
{
lazy
.
gClipboardHelper
.
copyString
(
download
.
source
.
originalUrl
|
|
download
.
source
.
url
)
;
}
summarizeDownloads
(
downloads
)
{
let
summary
=
{
numActive
:
0
numPaused
:
0
numDownloading
:
0
totalSize
:
0
totalTransferred
:
0
slowestSpeed
:
Infinity
rawTimeLeft
:
-
1
percentComplete
:
-
1
}
;
for
(
let
download
of
downloads
)
{
summary
.
numActive
+
+
;
if
(
!
download
.
stopped
)
{
summary
.
numDownloading
+
+
;
if
(
download
.
hasProgress
&
&
download
.
speed
>
0
)
{
let
sizeLeft
=
download
.
totalBytes
-
download
.
currentBytes
;
summary
.
rawTimeLeft
=
Math
.
max
(
summary
.
rawTimeLeft
sizeLeft
/
download
.
speed
)
;
summary
.
slowestSpeed
=
Math
.
min
(
summary
.
slowestSpeed
download
.
speed
)
;
}
}
else
if
(
download
.
canceled
&
&
download
.
hasPartialData
)
{
summary
.
numPaused
+
+
;
}
if
(
download
.
succeeded
)
{
summary
.
totalSize
+
=
download
.
target
.
size
;
summary
.
totalTransferred
+
=
download
.
target
.
size
;
}
else
if
(
download
.
hasProgress
)
{
summary
.
totalSize
+
=
download
.
totalBytes
;
summary
.
totalTransferred
+
=
download
.
currentBytes
;
}
}
if
(
summary
.
totalSize
!
=
0
)
{
summary
.
percentComplete
=
Math
.
floor
(
(
summary
.
totalTransferred
/
summary
.
totalSize
)
*
100
)
;
}
if
(
summary
.
slowestSpeed
=
=
Infinity
)
{
summary
.
slowestSpeed
=
0
;
}
return
summary
;
}
smoothSeconds
(
aSeconds
aLastSeconds
)
{
let
shouldApplySmoothing
=
aLastSeconds
>
=
0
&
&
aSeconds
>
aLastSeconds
/
2
;
if
(
shouldApplySmoothing
)
{
let
diff
=
aSeconds
-
aLastSeconds
;
aSeconds
=
aLastSeconds
+
(
diff
<
0
?
0
.
3
:
0
.
1
)
*
diff
;
diff
=
aSeconds
-
aLastSeconds
;
let
diffPercent
=
(
diff
/
aLastSeconds
)
*
100
;
if
(
Math
.
abs
(
diff
)
<
5
|
|
Math
.
abs
(
diffPercent
)
<
5
)
{
aSeconds
=
aLastSeconds
-
(
diff
<
0
?
0
.
4
:
0
.
2
)
;
}
}
return
(
aLastSeconds
=
Math
.
max
(
aSeconds
1
)
)
;
}
async
openDownload
(
download
options
)
{
if
(
typeof
download
.
launch
!
=
=
"
function
"
)
{
download
=
await
lazy
.
Downloads
.
createDownload
(
download
)
;
}
return
download
.
launch
(
options
)
.
catch
(
ex
=
>
Cu
.
reportError
(
ex
)
)
;
}
showDownloadedFile
(
aFile
)
{
if
(
!
(
aFile
instanceof
Ci
.
nsIFile
)
)
{
throw
new
Error
(
"
aFile
must
be
a
nsIFile
object
"
)
;
}
try
{
aFile
.
reveal
(
)
;
}
catch
(
ex
)
{
let
parent
=
aFile
.
parent
;
if
(
parent
)
{
this
.
showDirectory
(
parent
)
;
}
}
}
showDirectory
(
aDirectory
)
{
if
(
!
(
aDirectory
instanceof
Ci
.
nsIFile
)
)
{
throw
new
Error
(
"
aDirectory
must
be
a
nsIFile
object
"
)
;
}
try
{
aDirectory
.
launch
(
)
;
}
catch
(
ex
)
{
Cc
[
"
mozilla
.
org
/
uriloader
/
external
-
protocol
-
service
;
1
"
]
.
getService
(
Ci
.
nsIExternalProtocolService
)
.
loadURI
(
lazy
.
NetUtil
.
newURI
(
aDirectory
)
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
)
;
}
}
async
confirmUnblockDownload
(
{
verdict
window
dialogType
}
)
{
let
s
=
DownloadsCommon
.
strings
;
let
title
=
s
.
unblockHeaderUnblock
;
let
firstButtonText
=
s
.
unblockButtonUnblock
;
let
firstButtonAction
=
"
unblock
"
;
let
buttonFlags
=
Ci
.
nsIPrompt
.
BUTTON_TITLE_IS_STRING
*
Ci
.
nsIPrompt
.
BUTTON_POS_0
+
Ci
.
nsIPrompt
.
BUTTON_TITLE_CANCEL
*
Ci
.
nsIPrompt
.
BUTTON_POS_1
;
switch
(
dialogType
)
{
case
"
unblock
"
:
buttonFlags
+
=
Ci
.
nsIPrompt
.
BUTTON_POS_1_DEFAULT
;
break
;
case
"
chooseUnblock
"
:
buttonFlags
+
=
Ci
.
nsIPrompt
.
BUTTON_TITLE_IS_STRING
*
Ci
.
nsIPrompt
.
BUTTON_POS_2
+
Ci
.
nsIPrompt
.
BUTTON_POS_2_DEFAULT
;
break
;
case
"
chooseOpen
"
:
title
=
s
.
unblockHeaderOpen
;
firstButtonText
=
s
.
unblockButtonOpen
;
firstButtonAction
=
"
open
"
;
buttonFlags
+
=
Ci
.
nsIPrompt
.
BUTTON_TITLE_IS_STRING
*
Ci
.
nsIPrompt
.
BUTTON_POS_2
+
Ci
.
nsIPrompt
.
BUTTON_POS_0_DEFAULT
;
break
;
default
:
Cu
.
reportError
(
"
Unexpected
dialog
type
:
"
+
dialogType
)
;
return
"
cancel
"
;
}
let
message
;
switch
(
verdict
)
{
case
lazy
.
Downloads
.
Error
.
BLOCK_VERDICT_UNCOMMON
:
message
=
s
.
unblockTypeUncommon2
;
break
;
case
lazy
.
Downloads
.
Error
.
BLOCK_VERDICT_POTENTIALLY_UNWANTED
:
message
=
s
.
unblockTypePotentiallyUnwanted2
;
break
;
case
lazy
.
Downloads
.
Error
.
BLOCK_VERDICT_INSECURE
:
message
=
s
.
unblockInsecure
;
break
;
default
:
message
=
s
.
unblockTypeMalware
;
break
;
}
message
+
=
"
\
n
\
n
"
+
s
.
unblockTip2
;
Services
.
ww
.
registerNotification
(
function
onOpen
(
subj
topic
)
{
if
(
topic
=
=
"
domwindowopened
"
&
&
subj
instanceof
Ci
.
nsIDOMWindow
)
{
subj
.
addEventListener
(
"
DOMContentLoaded
"
function
(
)
{
if
(
subj
.
document
.
documentURI
=
=
"
chrome
:
/
/
global
/
content
/
commonDialog
.
xhtml
"
)
{
Services
.
ww
.
unregisterNotification
(
onOpen
)
;
let
dialog
=
subj
.
document
.
getElementById
(
"
commonDialog
"
)
;
if
(
dialog
)
{
dialog
.
classList
.
add
(
"
alert
-
dialog
"
)
;
}
}
}
{
once
:
true
}
)
;
}
}
)
;
let
rv
=
Services
.
prompt
.
confirmEx
(
window
title
message
buttonFlags
firstButtonText
null
s
.
unblockButtonConfirmBlock
null
{
}
)
;
return
[
firstButtonAction
"
cancel
"
"
confirmBlock
"
]
[
rv
]
;
}
}
;
XPCOMUtils
.
defineLazyGetter
(
DownloadsCommon
"
log
"
(
)
=
>
{
return
lazy
.
DownloadsLogger
.
log
.
bind
(
lazy
.
DownloadsLogger
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
DownloadsCommon
"
error
"
(
)
=
>
{
return
lazy
.
DownloadsLogger
.
error
.
bind
(
lazy
.
DownloadsLogger
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
DownloadsCommon
"
isWinVistaOrHigher
"
function
(
)
{
let
os
=
Services
.
appinfo
.
OS
;
if
(
os
!
=
"
WINNT
"
)
{
return
false
;
}
return
parseFloat
(
Services
.
sysinfo
.
getProperty
(
"
version
"
)
)
>
=
6
;
}
)
;
function
DownloadsDataCtor
(
{
isPrivate
isHistory
maxHistoryResults
}
=
{
}
)
{
this
.
_isPrivate
=
!
!
isPrivate
;
this
.
_oldDownloadStates
=
new
WeakMap
(
)
;
if
(
isHistory
)
{
if
(
isPrivate
)
{
lazy
.
PrivateDownloadsData
.
initializeDataLink
(
)
;
}
lazy
.
DownloadsData
.
initializeDataLink
(
)
;
this
.
_promiseList
=
lazy
.
DownloadsData
.
_promiseList
.
then
(
(
)
=
>
{
return
lazy
.
DownloadHistory
.
getList
(
{
type
:
isPrivate
?
lazy
.
Downloads
.
ALL
:
lazy
.
Downloads
.
PUBLIC
maxHistoryResults
}
)
;
}
)
;
return
;
}
this
.
_promiseList
=
(
async
(
)
=
>
{
await
new
Promise
(
resolve
=
>
(
this
.
initializeDataLink
=
resolve
)
)
;
let
list
=
await
lazy
.
Downloads
.
getList
(
isPrivate
?
lazy
.
Downloads
.
PRIVATE
:
lazy
.
Downloads
.
PUBLIC
)
;
await
list
.
addView
(
this
)
;
return
list
;
}
)
(
)
;
}
DownloadsDataCtor
.
prototype
=
{
initializeDataLink
(
)
{
}
_promiseList
:
null
get
_downloads
(
)
{
return
ChromeUtils
.
nondeterministicGetWeakMapKeys
(
this
.
_oldDownloadStates
)
;
}
get
canRemoveFinished
(
)
{
for
(
let
download
of
this
.
_downloads
)
{
if
(
download
.
stopped
&
&
!
(
download
.
canceled
&
&
download
.
hasPartialData
)
)
{
return
true
;
}
}
return
false
;
}
removeFinished
(
)
{
lazy
.
Downloads
.
getList
(
this
.
_isPrivate
?
lazy
.
Downloads
.
PRIVATE
:
lazy
.
Downloads
.
PUBLIC
)
.
then
(
list
=
>
list
.
removeFinished
(
)
)
.
catch
(
Cu
.
reportError
)
;
}
onDownloadAdded
(
download
)
{
download
.
endTime
=
Date
.
now
(
)
;
this
.
_oldDownloadStates
.
set
(
download
DownloadsCommon
.
stateOfDownload
(
download
)
)
;
if
(
download
.
error
?
.
becauseBlockedByReputationCheck
)
{
this
.
_notifyDownloadEvent
(
"
error
"
)
;
}
}
onDownloadChanged
(
download
)
{
let
oldState
=
this
.
_oldDownloadStates
.
get
(
download
)
;
let
newState
=
DownloadsCommon
.
stateOfDownload
(
download
)
;
this
.
_oldDownloadStates
.
set
(
download
newState
)
;
if
(
oldState
!
=
newState
)
{
if
(
download
.
succeeded
|
|
(
download
.
canceled
&
&
!
download
.
hasPartialData
)
|
|
download
.
error
)
{
download
.
endTime
=
Date
.
now
(
)
;
lazy
.
DownloadHistory
.
updateMetaData
(
download
)
.
catch
(
Cu
.
reportError
)
;
}
if
(
download
.
succeeded
|
|
(
download
.
error
&
&
download
.
error
.
becauseBlocked
)
)
{
this
.
_notifyDownloadEvent
(
"
finish
"
)
;
}
}
if
(
!
download
.
newDownloadNotified
)
{
download
.
newDownloadNotified
=
true
;
this
.
_notifyDownloadEvent
(
"
start
"
{
openDownloadsListOnStart
:
download
.
openDownloadsListOnStart
}
)
;
}
}
onDownloadRemoved
(
download
)
{
this
.
_oldDownloadStates
.
delete
(
download
)
;
}
addView
(
aView
)
{
this
.
_promiseList
.
then
(
list
=
>
list
.
addView
(
aView
)
)
.
catch
(
Cu
.
reportError
)
;
}
removeView
(
aView
)
{
this
.
_promiseList
.
then
(
list
=
>
list
.
removeView
(
aView
)
)
.
catch
(
Cu
.
reportError
)
;
}
get
panelHasShownBefore
(
)
{
try
{
return
Services
.
prefs
.
getBoolPref
(
"
browser
.
download
.
panel
.
shown
"
)
;
}
catch
(
ex
)
{
}
return
false
;
}
set
panelHasShownBefore
(
aValue
)
{
Services
.
prefs
.
setBoolPref
(
"
browser
.
download
.
panel
.
shown
"
aValue
)
;
}
_notifyDownloadEvent
(
aType
{
openDownloadsListOnStart
=
true
}
=
{
}
)
{
DownloadsCommon
.
log
(
"
Attempting
to
notify
that
a
new
download
has
started
or
finished
.
"
)
;
let
browserWin
=
lazy
.
BrowserWindowTracker
.
getTopWindow
(
{
private
:
this
.
_isPrivate
}
)
;
if
(
!
browserWin
)
{
return
;
}
let
shouldOpenDownloadsPanel
=
aType
=
=
"
start
"
&
&
Services
.
prefs
.
getBoolPref
(
"
browser
.
download
.
improvements_to_download_panel
"
)
&
&
DownloadsCommon
.
summarizeDownloads
(
this
.
_downloads
)
.
numDownloading
<
=
1
&
&
lazy
.
gAlwaysOpenPanel
;
if
(
aType
!
=
"
error
"
&
&
(
(
this
.
panelHasShownBefore
&
&
!
shouldOpenDownloadsPanel
)
|
|
!
openDownloadsListOnStart
|
|
browserWin
!
=
Services
.
focus
.
activeWindow
)
)
{
DownloadsCommon
.
log
(
"
Showing
new
download
notification
.
"
)
;
browserWin
.
DownloadsIndicatorView
.
showEventNotification
(
aType
)
;
return
;
}
this
.
panelHasShownBefore
=
true
;
browserWin
.
DownloadsPanel
.
showPanel
(
)
;
}
}
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
HistoryDownloadsData
"
function
(
)
{
return
new
DownloadsDataCtor
(
{
isHistory
:
true
}
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
LimitedHistoryDownloadsData
"
function
(
)
{
return
new
DownloadsDataCtor
(
{
isHistory
:
true
maxHistoryResults
:
kMaxHistoryResultsForLimitedView
}
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
LimitedPrivateHistoryDownloadData
"
function
(
)
{
return
new
DownloadsDataCtor
(
{
isPrivate
:
true
isHistory
:
true
maxHistoryResults
:
kMaxHistoryResultsForLimitedView
}
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
PrivateDownloadsData
"
function
(
)
{
return
new
DownloadsDataCtor
(
{
isPrivate
:
true
}
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
DownloadsData
"
function
(
)
{
return
new
DownloadsDataCtor
(
)
;
}
)
;
const
DownloadsViewPrototype
=
{
_oldDownloadStates
:
null
_views
:
null
_isPrivate
:
false
addView
(
aView
)
{
if
(
!
this
.
_views
.
length
)
{
if
(
this
.
_isPrivate
)
{
lazy
.
PrivateDownloadsData
.
addView
(
this
)
;
}
else
{
lazy
.
DownloadsData
.
addView
(
this
)
;
}
}
this
.
_views
.
push
(
aView
)
;
this
.
refreshView
(
aView
)
;
}
refreshView
(
aView
)
{
this
.
_refreshProperties
(
)
;
this
.
_updateView
(
aView
)
;
}
removeView
(
aView
)
{
let
index
=
this
.
_views
.
indexOf
(
aView
)
;
if
(
index
!
=
-
1
)
{
this
.
_views
.
splice
(
index
1
)
;
}
if
(
!
this
.
_views
.
length
)
{
if
(
this
.
_isPrivate
)
{
lazy
.
PrivateDownloadsData
.
removeView
(
this
)
;
}
else
{
lazy
.
DownloadsData
.
removeView
(
this
)
;
}
}
}
_loading
:
false
onDownloadBatchStarting
(
)
{
this
.
_loading
=
true
;
}
onDownloadBatchEnded
(
)
{
this
.
_loading
=
false
;
this
.
_updateViews
(
)
;
}
onDownloadAdded
(
download
)
{
this
.
_oldDownloadStates
.
set
(
download
DownloadsCommon
.
stateOfDownload
(
download
)
)
;
}
onDownloadStateChanged
(
download
)
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_NOT_IMPLEMENTED
)
;
}
onDownloadChanged
(
download
)
{
let
oldState
=
this
.
_oldDownloadStates
.
get
(
download
)
;
let
newState
=
DownloadsCommon
.
stateOfDownload
(
download
)
;
this
.
_oldDownloadStates
.
set
(
download
newState
)
;
if
(
oldState
!
=
newState
)
{
this
.
onDownloadStateChanged
(
download
)
;
}
}
onDownloadRemoved
(
download
)
{
this
.
_oldDownloadStates
.
delete
(
download
)
;
}
_refreshProperties
(
)
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_NOT_IMPLEMENTED
)
;
}
_updateView
(
)
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_NOT_IMPLEMENTED
)
;
}
_updateViews
(
)
{
if
(
this
.
_loading
)
{
return
;
}
this
.
_refreshProperties
(
)
;
this
.
_views
.
forEach
(
this
.
_updateView
this
)
;
}
}
;
function
DownloadsIndicatorDataCtor
(
aPrivate
)
{
this
.
_oldDownloadStates
=
new
WeakMap
(
)
;
this
.
_isPrivate
=
aPrivate
;
this
.
_views
=
[
]
;
}
DownloadsIndicatorDataCtor
.
prototype
=
{
__proto__
:
DownloadsViewPrototype
_attentionPriority
:
new
Map
(
[
[
DownloadsCommon
.
ATTENTION_NONE
0
]
[
DownloadsCommon
.
ATTENTION_SUCCESS
1
]
[
DownloadsCommon
.
ATTENTION_INFO
2
]
[
DownloadsCommon
.
ATTENTION_WARNING
3
]
[
DownloadsCommon
.
ATTENTION_SEVERE
4
]
]
)
get
_downloads
(
)
{
return
ChromeUtils
.
nondeterministicGetWeakMapKeys
(
this
.
_oldDownloadStates
)
;
}
removeView
(
aView
)
{
DownloadsViewPrototype
.
removeView
.
call
(
this
aView
)
;
if
(
!
this
.
_views
.
length
)
{
this
.
_itemCount
=
0
;
}
}
onDownloadAdded
(
download
)
{
DownloadsViewPrototype
.
onDownloadAdded
.
call
(
this
download
)
;
this
.
_itemCount
+
+
;
this
.
_updateViews
(
)
;
}
onDownloadStateChanged
(
download
)
{
if
(
this
.
_attentionSuppressed
!
=
=
DownloadsCommon
.
SUPPRESS_NONE
)
{
return
;
}
let
attention
;
if
(
!
download
.
succeeded
&
&
download
.
error
&
&
download
.
error
.
reputationCheckVerdict
)
{
switch
(
download
.
error
.
reputationCheckVerdict
)
{
case
lazy
.
Downloads
.
Error
.
BLOCK_VERDICT_UNCOMMON
:
attention
=
DownloadsCommon
.
ATTENTION_INFO
;
break
;
case
lazy
.
Downloads
.
Error
.
BLOCK_VERDICT_POTENTIALLY_UNWANTED
:
case
lazy
.
Downloads
.
Error
.
BLOCK_VERDICT_INSECURE
:
case
lazy
.
Downloads
.
Error
.
BLOCK_VERDICT_DOWNLOAD_SPAM
:
attention
=
DownloadsCommon
.
ATTENTION_WARNING
;
break
;
case
lazy
.
Downloads
.
Error
.
BLOCK_VERDICT_MALWARE
:
attention
=
DownloadsCommon
.
ATTENTION_SEVERE
;
break
;
default
:
attention
=
DownloadsCommon
.
ATTENTION_SEVERE
;
Cu
.
reportError
(
"
Unknown
reputation
verdict
:
"
+
download
.
error
.
reputationCheckVerdict
)
;
}
}
else
if
(
download
.
succeeded
)
{
attention
=
DownloadsCommon
.
ATTENTION_SUCCESS
;
}
else
if
(
download
.
error
)
{
attention
=
DownloadsCommon
.
ATTENTION_WARNING
;
}
download
.
attention
=
attention
;
this
.
updateAttention
(
)
;
}
onDownloadChanged
(
download
)
{
DownloadsViewPrototype
.
onDownloadChanged
.
call
(
this
download
)
;
this
.
_updateViews
(
)
;
}
onDownloadRemoved
(
download
)
{
DownloadsViewPrototype
.
onDownloadRemoved
.
call
(
this
download
)
;
this
.
_itemCount
-
-
;
this
.
updateAttention
(
)
;
this
.
_updateViews
(
)
;
}
_hasDownloads
:
false
_percentComplete
:
-
1
set
attention
(
aValue
)
{
this
.
_attention
=
aValue
;
this
.
_updateViews
(
)
;
}
_attention
:
DownloadsCommon
.
ATTENTION_NONE
set
attentionSuppressed
(
aFlags
)
{
this
.
_attentionSuppressed
=
aFlags
;
if
(
aFlags
!
=
=
DownloadsCommon
.
SUPPRESS_NONE
)
{
for
(
let
download
of
this
.
_downloads
)
{
download
.
attention
=
DownloadsCommon
.
ATTENTION_NONE
;
}
this
.
attention
=
DownloadsCommon
.
ATTENTION_NONE
;
}
}
get
attentionSuppressed
(
)
{
return
this
.
_attentionSuppressed
;
}
_attentionSuppressed
:
DownloadsCommon
.
SUPPRESS_NONE
updateAttention
(
)
{
let
currentAttention
=
DownloadsCommon
.
ATTENTION_NONE
;
let
currentPriority
=
0
;
for
(
let
download
of
this
.
_downloads
)
{
let
{
attention
}
=
download
;
let
priority
=
this
.
_attentionPriority
.
get
(
attention
)
;
if
(
priority
>
currentPriority
)
{
currentPriority
=
priority
;
currentAttention
=
attention
;
}
}
this
.
attention
=
currentAttention
;
}
_updateView
(
aView
)
{
aView
.
hasDownloads
=
this
.
_hasDownloads
;
aView
.
percentComplete
=
this
.
_percentComplete
;
aView
.
attention
=
this
.
attentionSuppressed
!
=
=
DownloadsCommon
.
SUPPRESS_NONE
?
DownloadsCommon
.
ATTENTION_NONE
:
this
.
_attention
;
}
_itemCount
:
0
*
_activeDownloads
(
)
{
let
downloads
=
this
.
_isPrivate
?
lazy
.
PrivateDownloadsData
.
_downloads
:
lazy
.
DownloadsData
.
_downloads
;
for
(
let
download
of
downloads
)
{
if
(
!
download
.
stopped
|
|
(
download
.
canceled
&
&
download
.
hasPartialData
)
)
{
yield
download
;
}
}
}
_refreshProperties
(
)
{
let
summary
=
DownloadsCommon
.
summarizeDownloads
(
this
.
_activeDownloads
(
)
)
;
this
.
_hasDownloads
=
this
.
_itemCount
>
0
;
if
(
summary
.
percentComplete
>
=
0
)
{
this
.
_percentComplete
=
summary
.
percentComplete
;
}
else
if
(
summary
.
numDownloading
>
0
)
{
this
.
_percentComplete
=
0
;
}
else
{
this
.
_percentComplete
=
-
1
;
}
}
}
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
PrivateDownloadsIndicatorData
"
function
(
)
{
return
new
DownloadsIndicatorDataCtor
(
true
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
DownloadsIndicatorData
"
function
(
)
{
return
new
DownloadsIndicatorDataCtor
(
false
)
;
}
)
;
function
DownloadsSummaryData
(
aIsPrivate
aNumToExclude
)
{
this
.
_numToExclude
=
aNumToExclude
;
this
.
_loading
=
false
;
this
.
_downloads
=
[
]
;
this
.
_lastRawTimeLeft
=
-
1
;
this
.
_lastTimeLeft
=
-
1
;
this
.
_showingProgress
=
false
;
this
.
_details
=
"
"
;
this
.
_description
=
"
"
;
this
.
_numActive
=
0
;
this
.
_percentComplete
=
-
1
;
this
.
_oldDownloadStates
=
new
WeakMap
(
)
;
this
.
_isPrivate
=
aIsPrivate
;
this
.
_views
=
[
]
;
}
DownloadsSummaryData
.
prototype
=
{
__proto__
:
DownloadsViewPrototype
removeView
(
aView
)
{
DownloadsViewPrototype
.
removeView
.
call
(
this
aView
)
;
if
(
!
this
.
_views
.
length
)
{
this
.
_downloads
=
[
]
;
}
}
onDownloadAdded
(
download
)
{
DownloadsViewPrototype
.
onDownloadAdded
.
call
(
this
download
)
;
this
.
_downloads
.
unshift
(
download
)
;
this
.
_updateViews
(
)
;
}
onDownloadStateChanged
(
)
{
this
.
_lastRawTimeLeft
=
-
1
;
this
.
_lastTimeLeft
=
-
1
;
}
onDownloadChanged
(
download
)
{
DownloadsViewPrototype
.
onDownloadChanged
.
call
(
this
download
)
;
this
.
_updateViews
(
)
;
}
onDownloadRemoved
(
download
)
{
DownloadsViewPrototype
.
onDownloadRemoved
.
call
(
this
download
)
;
let
itemIndex
=
this
.
_downloads
.
indexOf
(
download
)
;
this
.
_downloads
.
splice
(
itemIndex
1
)
;
this
.
_updateViews
(
)
;
}
_updateView
(
aView
)
{
aView
.
showingProgress
=
this
.
_showingProgress
;
aView
.
percentComplete
=
this
.
_percentComplete
;
aView
.
description
=
this
.
_description
;
aView
.
details
=
this
.
_details
;
}
*
_downloadsForSummary
(
)
{
if
(
this
.
_downloads
.
length
)
{
for
(
let
i
=
this
.
_numToExclude
;
i
<
this
.
_downloads
.
length
;
+
+
i
)
{
yield
this
.
_downloads
[
i
]
;
}
}
}
_refreshProperties
(
)
{
let
summary
=
DownloadsCommon
.
summarizeDownloads
(
this
.
_downloadsForSummary
(
)
)
;
this
.
_description
=
kDownloadsFluentStrings
.
formatValueSync
(
"
downloads
-
more
-
downloading
"
{
count
:
summary
.
numDownloading
}
)
;
this
.
_percentComplete
=
summary
.
percentComplete
;
this
.
_showingProgress
=
summary
.
numDownloading
>
0
;
if
(
summary
.
rawTimeLeft
=
=
-
1
)
{
this
.
_lastRawTimeLeft
=
-
1
;
this
.
_lastTimeLeft
=
-
1
;
this
.
_details
=
"
"
;
}
else
{
if
(
this
.
_lastRawTimeLeft
!
=
summary
.
rawTimeLeft
)
{
this
.
_lastRawTimeLeft
=
summary
.
rawTimeLeft
;
this
.
_lastTimeLeft
=
DownloadsCommon
.
smoothSeconds
(
summary
.
rawTimeLeft
this
.
_lastTimeLeft
)
;
}
[
this
.
_details
]
=
lazy
.
DownloadUtils
.
getDownloadStatusNoRate
(
summary
.
totalTransferred
summary
.
totalSize
summary
.
slowestSpeed
this
.
_lastTimeLeft
)
;
}
}
}
;
