"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
DownloadSpamProtection
"
]
;
const
{
Download
DownloadError
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
DownloadCore
.
jsm
"
)
;
var
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
BrowserWindowTracker
:
"
resource
:
/
/
/
modules
/
BrowserWindowTracker
.
jsm
"
Downloads
:
"
resource
:
/
/
gre
/
modules
/
Downloads
.
jsm
"
DownloadsCommon
:
"
resource
:
/
/
/
modules
/
DownloadsCommon
.
jsm
"
DownloadList
:
"
resource
:
/
/
gre
/
modules
/
DownloadList
.
jsm
"
}
)
;
class
DownloadSpamProtection
{
constructor
(
)
{
this
.
_blockedURLToDownloadSpam
=
new
Map
(
)
;
this
.
_browserWin
=
BrowserWindowTracker
.
getTopWindow
(
)
;
this
.
_indicator
=
DownloadsCommon
.
getIndicatorData
(
this
.
_browserWin
)
;
this
.
list
=
new
DownloadList
(
)
;
}
get
spamList
(
)
{
return
this
.
list
;
}
update
(
url
)
{
if
(
this
.
_blockedURLToDownloadSpam
.
has
(
url
)
)
{
let
downloadSpam
=
this
.
_blockedURLToDownloadSpam
.
get
(
url
)
;
this
.
spamList
.
remove
(
downloadSpam
)
;
downloadSpam
.
blockedDownloadsCount
+
=
1
;
this
.
spamList
.
add
(
downloadSpam
)
;
this
.
_indicator
.
onDownloadStateChanged
(
downloadSpam
)
;
return
;
}
let
downloadSpam
=
new
DownloadSpam
(
url
)
;
this
.
spamList
.
add
(
downloadSpam
)
;
this
.
_blockedURLToDownloadSpam
.
set
(
url
downloadSpam
)
;
let
hasActiveDownloads
=
DownloadsCommon
.
summarizeDownloads
(
this
.
_indicator
.
_activeDownloads
(
)
)
.
numDownloading
;
if
(
!
hasActiveDownloads
)
{
this
.
_browserWin
.
DownloadsPanel
.
showPanel
(
)
;
}
this
.
_indicator
.
onDownloadAdded
(
downloadSpam
)
;
}
clearDownloadSpam
(
URL
)
{
if
(
this
.
_blockedURLToDownloadSpam
.
has
(
URL
)
)
{
let
downloadSpam
=
this
.
_blockedURLToDownloadSpam
.
get
(
URL
)
;
this
.
spamList
.
remove
(
downloadSpam
)
;
this
.
_indicator
.
onDownloadRemoved
(
downloadSpam
)
;
this
.
_blockedURLToDownloadSpam
.
delete
(
URL
)
;
}
}
}
class
DownloadSpam
extends
Download
{
constructor
(
url
)
{
super
(
)
;
this
.
hasBlockedData
=
true
;
this
.
stopped
=
true
;
this
.
error
=
new
DownloadError
(
{
becauseBlockedByReputationCheck
:
true
reputationCheckVerdict
:
Downloads
.
Error
.
BLOCK_VERDICT_DOWNLOAD_SPAM
}
)
;
this
.
target
=
{
path
:
"
"
}
;
this
.
source
=
{
url
}
;
this
.
blockedDownloadsCount
=
1
;
}
}
