"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
PromptCollection
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
class
PromptCollection
{
confirmRepost
(
browsingContext
)
{
let
brandName
;
try
{
brandName
=
this
.
stringBundles
.
brand
.
GetStringFromName
(
"
brandShortName
"
)
;
}
catch
(
exception
)
{
}
let
message
;
let
resendLabel
;
try
{
if
(
brandName
)
{
message
=
this
.
stringBundles
.
app
.
formatStringFromName
(
"
confirmRepostPrompt
"
[
brandName
]
)
;
}
else
{
message
=
this
.
stringBundles
.
app
.
GetStringFromName
(
"
confirmRepostPrompt
"
)
;
}
resendLabel
=
this
.
stringBundles
.
app
.
GetStringFromName
(
"
resendButton
.
label
"
)
;
}
catch
(
exception
)
{
Cu
.
reportError
(
"
Failed
to
get
strings
from
appstrings
.
properties
"
)
;
return
false
;
}
let
contentViewer
=
browsingContext
?
.
docShell
?
.
contentViewer
;
let
modalType
=
contentViewer
?
.
isTabModalPromptAllowed
?
Ci
.
nsIPromptService
.
MODAL_TYPE_CONTENT
:
Ci
.
nsIPromptService
.
MODAL_TYPE_WINDOW
;
let
buttonFlags
=
(
Ci
.
nsIPromptService
.
BUTTON_TITLE_IS_STRING
*
Ci
.
nsIPromptService
.
BUTTON_POS_0
)
|
(
Ci
.
nsIPromptService
.
BUTTON_TITLE_CANCEL
*
Ci
.
nsIPromptService
.
BUTTON_POS_1
)
;
let
buttonPressed
=
Services
.
prompt
.
confirmExBC
(
browsingContext
modalType
null
message
buttonFlags
resendLabel
null
null
null
{
}
)
;
return
buttonPressed
=
=
=
0
;
}
asyncBeforeUnloadCheck
(
browsingContext
)
{
let
title
;
let
message
;
let
leaveLabel
;
let
stayLabel
;
try
{
title
=
this
.
stringBundles
.
dom
.
GetStringFromName
(
"
OnBeforeUnloadTitle
"
)
;
message
=
this
.
stringBundles
.
dom
.
GetStringFromName
(
"
OnBeforeUnloadMessage
"
)
;
leaveLabel
=
this
.
stringBundles
.
dom
.
GetStringFromName
(
"
OnBeforeUnloadLeaveButton
"
)
;
stayLabel
=
this
.
stringBundles
.
dom
.
GetStringFromName
(
"
OnBeforeUnloadStayButton
"
)
;
}
catch
(
exception
)
{
Cu
.
reportError
(
"
Failed
to
get
strings
from
dom
.
properties
"
)
;
return
false
;
}
let
contentViewer
=
browsingContext
?
.
docShell
?
.
contentViewer
;
let
modalAllowed
=
contentViewer
?
contentViewer
.
isTabModalPromptAllowed
:
browsingContext
.
ancestorsAreCurrent
;
let
modalType
=
Ci
.
nsIPromptService
[
modalAllowed
?
"
MODAL_TYPE_CONTENT
"
:
"
MODAL_TYPE_WINDOW
"
]
;
let
buttonFlags
=
Ci
.
nsIPromptService
.
BUTTON_POS_0_DEFAULT
|
(
Ci
.
nsIPromptService
.
BUTTON_TITLE_IS_STRING
*
Ci
.
nsIPromptService
.
BUTTON_POS_0
)
|
(
Ci
.
nsIPromptService
.
BUTTON_TITLE_IS_STRING
*
Ci
.
nsIPromptService
.
BUTTON_POS_1
)
;
return
Services
.
prompt
.
asyncConfirmEx
(
browsingContext
modalType
title
message
buttonFlags
leaveLabel
stayLabel
null
null
false
{
inPermitUnload
:
true
}
)
.
then
(
result
=
>
result
.
QueryInterface
(
Ci
.
nsIPropertyBag2
)
.
get
(
"
buttonNumClicked
"
)
=
=
0
)
;
}
}
const
BUNDLES
=
{
dom
:
"
chrome
:
/
/
global
/
locale
/
dom
/
dom
.
properties
"
app
:
"
chrome
:
/
/
global
/
locale
/
appstrings
.
properties
"
brand
:
"
chrome
:
/
/
branding
/
locale
/
brand
.
properties
"
}
;
PromptCollection
.
prototype
.
stringBundles
=
{
}
;
for
(
const
[
bundleName
bundleUrl
]
of
Object
.
entries
(
BUNDLES
)
)
{
XPCOMUtils
.
defineLazyGetter
(
PromptCollection
.
prototype
.
stringBundles
bundleName
function
(
)
{
let
bundle
=
Services
.
strings
.
createBundle
(
bundleUrl
)
;
if
(
!
bundle
)
{
throw
new
Error
(
"
String
bundle
for
dom
not
present
!
"
)
;
}
return
bundle
;
}
)
;
}
PromptCollection
.
prototype
.
QueryInterface
=
ChromeUtils
.
generateQI
(
[
"
nsIPromptCollection
"
]
)
;
