const
EXPORTED_SYMBOLS
=
[
"
DomainGroupBuilder
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
CommonNames
:
"
resource
:
/
/
/
modules
/
CommonNames
.
jsm
"
SnapshotGroups
:
"
resource
:
/
/
/
modules
/
SnapshotGroups
.
jsm
"
}
)
;
const
DomainGroupBuilder
=
new
(
class
DomainGroupBuilder
{
#
currentGroups
=
null
;
name
=
"
domain
"
;
skipMinimumSize
=
false
;
async
rebuild
(
snapshots
)
{
this
.
#
currentGroups
=
null
;
await
this
.
#
maybeLoadGroups
(
)
;
let
untouchedDomains
=
new
Set
(
this
.
#
currentGroups
.
keys
(
)
)
;
let
changedDomains
=
new
Set
(
)
;
for
(
let
snapshot
of
snapshots
)
{
let
domain
=
this
.
#
getDomain
(
snapshot
.
url
)
;
if
(
!
domain
)
{
continue
;
}
untouchedDomains
.
delete
(
domain
)
;
let
group
=
this
.
#
currentGroups
.
get
(
domain
)
;
if
(
!
group
)
{
this
.
#
currentGroups
.
set
(
domain
this
.
#
generateDomainData
(
domain
snapshot
.
url
)
)
;
changedDomains
.
add
(
domain
)
;
}
else
if
(
!
group
.
urls
.
has
(
snapshot
.
url
)
)
{
group
.
urls
.
add
(
snapshot
.
url
)
;
changedDomains
.
add
(
domain
)
;
}
}
for
(
let
domain
of
[
.
.
.
untouchedDomains
.
values
(
)
]
)
{
let
group
=
this
.
#
currentGroups
.
get
(
domain
)
;
await
SnapshotGroups
.
delete
(
group
.
id
)
;
this
.
#
currentGroups
.
delete
(
domain
)
;
}
for
(
let
domain
of
[
.
.
.
changedDomains
.
values
(
)
]
)
{
await
this
.
#
checkDomain
(
domain
)
;
}
}
async
update
(
{
addedItems
removedUrls
}
)
{
await
this
.
#
maybeLoadGroups
(
)
;
let
changedDomains
=
new
Set
(
)
;
for
(
let
{
url
}
of
addedItems
.
values
(
)
)
{
let
domain
=
this
.
#
getDomain
(
url
)
;
if
(
!
domain
)
{
continue
;
}
let
group
=
this
.
#
currentGroups
.
get
(
domain
)
;
if
(
!
group
)
{
this
.
#
currentGroups
.
set
(
domain
this
.
#
generateDomainData
(
domain
url
)
)
;
changedDomains
.
add
(
domain
)
;
}
else
if
(
!
group
.
urls
.
has
(
url
)
)
{
group
.
urls
.
add
(
url
)
;
changedDomains
.
add
(
domain
)
;
}
}
for
(
let
url
of
removedUrls
.
values
(
)
)
{
let
domain
=
this
.
#
getDomain
(
url
)
;
if
(
!
domain
)
{
continue
;
}
let
group
=
this
.
#
currentGroups
.
get
(
domain
)
;
if
(
group
?
.
urls
.
has
(
url
)
)
{
group
.
urls
.
delete
(
url
)
;
changedDomains
.
add
(
domain
)
;
}
}
for
(
let
domain
of
changedDomains
.
values
(
)
)
{
await
this
.
#
checkDomain
(
domain
)
;
}
}
async
#
checkDomain
(
domain
urls
)
{
let
group
=
this
.
#
currentGroups
.
get
(
domain
)
;
if
(
group
.
urls
.
size
>
0
)
{
if
(
group
.
id
)
{
await
SnapshotGroups
.
updateUrls
(
group
.
id
[
.
.
.
group
.
urls
.
values
(
)
]
)
;
}
else
{
let
id
=
await
SnapshotGroups
.
add
(
group
[
.
.
.
group
.
urls
.
values
(
)
]
)
;
group
.
id
=
id
;
}
}
else
{
await
SnapshotGroups
.
delete
(
group
.
id
)
;
this
.
#
currentGroups
.
delete
(
domain
)
;
}
}
async
#
maybeLoadGroups
(
)
{
if
(
this
.
#
currentGroups
)
{
return
;
}
this
.
#
currentGroups
=
new
Map
(
)
;
let
groups
=
await
SnapshotGroups
.
query
(
{
builder
:
this
.
name
limit
:
-
1
skipMinimum
:
true
}
)
;
for
(
let
group
of
groups
)
{
this
.
#
currentGroups
.
set
(
group
.
builderMetadata
.
domain
group
)
;
group
.
urls
=
new
Set
(
await
SnapshotGroups
.
getUrls
(
{
id
:
group
.
id
hidden
:
true
}
)
)
;
}
}
#
generateDomainData
(
domain
url
)
{
return
{
title
:
CommonNames
.
getURLName
(
new
URL
(
url
)
)
builder
:
this
.
name
builderMetadata
:
{
domain
}
urls
:
new
Set
(
[
url
]
)
}
;
}
#
getDomain
(
url
)
{
try
{
return
new
URL
(
url
)
.
hostname
;
}
catch
(
ex
)
{
return
null
;
}
}
}
)
(
)
;
