const
EXPORTED_SYMBOLS
=
[
"
SnapshotScorer
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
Snapshots
:
"
resource
:
/
/
/
modules
/
Snapshots
.
jsm
"
FilterAdult
:
"
resource
:
/
/
activity
-
stream
/
lib
/
FilterAdult
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
logConsole
"
function
(
)
{
return
console
.
createInstance
(
{
prefix
:
"
SnapshotSelector
"
maxLogLevel
:
Services
.
prefs
.
getBoolPref
(
"
browser
.
snapshots
.
scorer
.
log
"
false
)
?
"
Debug
"
:
"
Warn
"
}
)
;
}
)
;
const
SnapshotScorer
=
new
(
class
SnapshotScorer
{
#
RELEVANCY_POINTS
=
new
Map
(
)
;
#
dateOverride
=
null
;
constructor
(
)
{
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
snapshotThreshold
"
"
browser
.
places
.
snapshots
.
threshold
"
4
)
;
let
branch
=
Services
.
prefs
.
getBranch
(
"
browser
.
snapshots
.
score
.
"
)
;
for
(
let
name
of
branch
.
getChildList
(
"
"
)
)
{
this
.
#
RELEVANCY_POINTS
.
set
(
name
branch
.
getIntPref
(
name
0
)
)
;
}
}
combineAndScore
(
selectionContext
.
.
.
recommendationGroups
)
{
let
combined
=
new
Map
(
)
;
let
currentDate
=
this
.
#
dateOverride
?
?
Date
.
now
(
)
;
let
currentSessionUrls
=
selectionContext
.
getCurrentSessionUrls
(
)
;
for
(
let
{
recommendations
weight
}
of
recommendationGroups
)
{
for
(
let
{
snapshot
score
}
of
recommendations
)
{
if
(
selectionContext
.
filterAdult
&
&
FilterAdult
.
isAdultUrl
(
snapshot
.
url
)
)
{
continue
;
}
let
currentScore
=
combined
.
get
(
snapshot
.
url
)
;
if
(
currentScore
)
{
currentScore
.
sourceScore
+
=
score
*
weight
;
}
else
{
currentScore
=
{
snapshot
snapshotScore
:
this
.
#
score
(
snapshot
currentDate
currentSessionUrls
)
sourceScore
:
score
*
weight
}
;
combined
.
set
(
snapshot
.
url
currentScore
)
;
}
}
}
let
recommendations
=
[
]
;
for
(
let
currentScore
of
combined
.
values
(
)
)
{
let
recommendation
=
{
snapshot
:
currentScore
.
snapshot
score
:
currentScore
.
snapshotScore
+
currentScore
.
sourceScore
}
;
logConsole
.
debug
(
Scored
{
recommendation
.
score
}
for
{
recommendation
.
snapshot
.
url
}
)
;
if
(
recommendation
.
score
>
=
this
.
snapshotThreshold
)
{
recommendations
.
push
(
recommendation
)
;
}
}
return
recommendations
.
sort
(
(
a
b
)
=
>
b
.
score
-
a
.
score
)
;
}
overrideCurrentTimeForTests
(
date
)
{
this
.
#
dateOverride
=
date
;
}
#
score
(
snapshot
currentDate
currentSessionUrls
)
{
let
points
=
0
;
for
(
let
[
item
value
]
of
this
.
#
RELEVANCY_POINTS
.
entries
(
)
)
{
let
fnName
=
_score
{
item
}
;
if
(
!
(
fnName
in
this
)
)
{
console
.
error
(
"
Could
not
find
function
"
fnName
"
in
SnapshotScorer
"
)
;
continue
;
}
points
+
=
this
[
fnName
]
(
snapshot
currentSessionUrls
)
*
value
;
}
let
timeAgo
=
currentDate
-
snapshot
.
lastInteractionAt
;
timeAgo
=
timeAgo
/
(
24
*
60
*
60
*
1000
)
;
return
points
*
Math
.
exp
(
timeAgo
/
-
7
)
;
}
_scoreVisit
(
snapshot
)
{
if
(
snapshot
.
visitCount
=
=
0
)
{
return
0
;
}
return
2
-
1
/
snapshot
.
visitCount
;
}
_scoreCurrentSession
(
snapshot
currentSessionUrls
)
{
return
currentSessionUrls
.
has
(
snapshot
.
url
)
?
1
:
0
;
}
_scoreIsUserPersisted
(
snapshot
)
{
return
snapshot
.
userPersisted
!
=
Snapshots
.
USER_PERSISTED
.
NO
?
1
:
0
;
}
_scoreIsUsedRemoved
(
snapshot
)
{
return
snapshot
.
removedAt
?
1
:
0
;
}
}
)
(
)
;
