const
EXPORTED_SYMBOLS
=
[
"
SnapshotScorer
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
Snapshots
:
"
resource
:
/
/
/
modules
/
Snapshots
.
jsm
"
FilterAdult
:
"
resource
:
/
/
activity
-
stream
/
lib
/
FilterAdult
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
logConsole
"
function
(
)
{
return
console
.
createInstance
(
{
prefix
:
"
SnapshotSelector
"
maxLogLevel
:
Services
.
prefs
.
getBoolPref
(
"
browser
.
snapshots
.
scorer
.
log
"
false
)
?
"
Debug
"
:
"
Warn
"
}
)
;
}
)
;
const
SnapshotScorer
=
new
(
class
SnapshotScorer
{
#
RELEVANCY_POINTS
=
new
Map
(
)
;
#
dateOverride
=
null
;
constructor
(
)
{
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
snapshotThreshold
"
"
browser
.
places
.
snapshots
.
threshold
"
4
)
;
let
branch
=
Services
.
prefs
.
getBranch
(
"
browser
.
snapshots
.
score
.
"
)
;
for
(
let
name
of
branch
.
getChildList
(
"
"
)
)
{
this
.
#
RELEVANCY_POINTS
.
set
(
name
branch
.
getIntPref
(
name
0
)
)
;
}
}
combineAndScore
(
selectionContext
.
.
.
recommendationGroups
)
{
let
combined
=
new
Map
(
)
;
let
currentDate
=
this
.
#
dateOverride
?
?
Date
.
now
(
)
;
let
currentSessionUrls
=
selectionContext
.
getCurrentSessionUrls
(
)
;
for
(
let
{
source
recommendations
weight
}
of
recommendationGroups
)
{
for
(
let
{
snapshot
score
}
of
recommendations
)
{
if
(
selectionContext
.
filterAdult
&
&
lazy
.
FilterAdult
.
isAdultUrl
(
snapshot
.
url
)
)
{
continue
;
}
let
currentScore
=
combined
.
get
(
snapshot
.
url
)
;
if
(
currentScore
)
{
currentScore
.
sourceScore
.
set
(
source
score
*
weight
)
;
}
else
{
currentScore
=
{
snapshot
snapshotScore
:
this
.
#
score
(
snapshot
currentDate
currentSessionUrls
)
sourceScore
:
new
Map
(
[
[
source
score
*
weight
]
]
)
}
;
combined
.
set
(
snapshot
.
url
currentScore
)
;
}
}
}
let
recommendations
=
[
]
;
for
(
let
currentScore
of
combined
.
values
(
)
)
{
let
recommendation
=
{
snapshot
:
currentScore
.
snapshot
score
:
currentScore
.
snapshotScore
source
:
undefined
}
;
let
maxScore
=
null
;
let
source
=
null
;
for
(
let
[
id
score
]
of
currentScore
.
sourceScore
)
{
recommendation
.
score
+
=
score
;
if
(
maxScore
=
=
=
null
|
|
maxScore
<
score
)
{
maxScore
=
score
;
source
=
id
;
}
}
recommendation
.
source
=
source
;
lazy
.
logConsole
.
debug
(
Scored
{
recommendation
.
score
}
for
{
recommendation
.
snapshot
.
url
}
from
source
{
recommendation
.
source
}
)
;
if
(
recommendation
.
score
>
=
this
.
snapshotThreshold
)
{
recommendations
.
push
(
recommendation
)
;
}
}
return
this
.
dedupeSnapshots
(
recommendations
)
.
sort
(
(
a
b
)
=
>
b
.
score
-
a
.
score
)
;
}
dedupeSnapshots
(
recommendations
)
{
let
matchingMap
=
new
Map
(
)
;
let
result
=
[
]
;
for
(
let
recommendation
of
recommendations
)
{
let
url
;
try
{
url
=
new
URL
(
recommendation
.
snapshot
.
url
)
;
}
catch
(
ex
)
{
result
.
push
(
recommendation
)
;
continue
;
}
let
newRecommendation
=
{
.
.
.
recommendation
hasSearch
:
!
!
url
.
search
}
;
url
.
search
=
recommendation
.
snapshot
.
title
;
let
key
=
url
.
href
;
let
existing
=
matchingMap
.
get
(
key
)
;
if
(
existing
)
{
if
(
!
newRecommendation
.
hasSearch
)
{
matchingMap
.
set
(
key
newRecommendation
)
;
continue
;
}
if
(
!
existing
.
hasSearch
)
{
continue
;
}
if
(
"
score
"
in
newRecommendation
)
{
if
(
newRecommendation
.
score
>
existing
.
score
)
{
matchingMap
.
set
(
key
newRecommendation
)
;
}
continue
;
}
if
(
newRecommendation
.
snapshot
.
lastInteractionAt
.
getTime
(
)
>
existing
.
snapshot
.
lastInteractionAt
.
getTime
(
)
)
{
matchingMap
.
set
(
key
newRecommendation
)
;
}
}
else
{
matchingMap
.
set
(
key
newRecommendation
)
;
}
}
return
[
.
.
.
result
.
.
.
matchingMap
.
values
(
)
]
;
}
overrideCurrentTimeForTests
(
date
)
{
this
.
#
dateOverride
=
date
;
}
#
score
(
snapshot
currentDate
currentSessionUrls
)
{
let
points
=
0
;
for
(
let
[
item
value
]
of
this
.
#
RELEVANCY_POINTS
.
entries
(
)
)
{
let
fnName
=
_score
{
item
}
;
if
(
!
(
fnName
in
this
)
)
{
console
.
error
(
"
Could
not
find
function
"
fnName
"
in
SnapshotScorer
"
)
;
continue
;
}
points
+
=
this
[
fnName
]
(
snapshot
currentSessionUrls
)
*
value
;
}
let
timeAgo
=
currentDate
-
snapshot
.
lastInteractionAt
;
timeAgo
=
timeAgo
/
(
24
*
60
*
60
*
1000
)
;
return
points
*
Math
.
exp
(
timeAgo
/
-
7
)
;
}
_scoreVisit
(
snapshot
)
{
if
(
snapshot
.
visitCount
=
=
0
)
{
return
0
;
}
return
2
-
1
/
snapshot
.
visitCount
;
}
_scoreCurrentSession
(
snapshot
currentSessionUrls
)
{
return
currentSessionUrls
.
has
(
snapshot
.
url
)
?
1
:
0
;
}
_scoreIsUserPersisted
(
snapshot
)
{
return
snapshot
.
userPersisted
!
=
lazy
.
Snapshots
.
USER_PERSISTED
.
NO
?
1
:
0
;
}
_scoreIsUsedRemoved
(
snapshot
)
{
return
snapshot
.
removedAt
?
1
:
0
;
}
}
)
(
)
;
