const
EXPORTED_SYMBOLS
=
[
"
SnapshotScorer
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Services
"
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
Snapshots
:
"
resource
:
/
/
/
modules
/
Snapshots
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
logConsole
"
function
(
)
{
return
console
.
createInstance
(
{
prefix
:
"
SnapshotSelector
"
maxLogLevel
:
Services
.
prefs
.
getBoolPref
(
"
browser
.
snapshots
.
scorer
.
log
"
false
)
?
"
Debug
"
:
"
Warn
"
}
)
;
}
)
;
const
SnapshotScorer
=
new
(
class
SnapshotScorer
{
#
RELEVANCY_POINTS
=
new
Map
(
)
;
#
dateOverride
=
null
;
constructor
(
)
{
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
snapshotThreshold
"
"
browser
.
places
.
snapshots
.
threshold
"
4
)
;
let
branch
=
Services
.
prefs
.
getBranch
(
"
browser
.
snapshots
.
score
.
"
)
;
for
(
let
name
of
branch
.
getChildList
(
"
"
)
)
{
this
.
#
RELEVANCY_POINTS
.
set
(
name
branch
.
getIntPref
(
name
0
)
)
;
}
}
combineAndScore
(
currentSessionUrls
.
.
.
snapshotGroups
)
{
let
combined
=
new
Map
(
)
;
let
currentDate
=
this
.
#
dateOverride
?
?
Date
.
now
(
)
;
for
(
let
group
of
snapshotGroups
)
{
for
(
let
snapshot
of
group
)
{
let
existing
=
combined
.
get
(
snapshot
.
url
)
;
let
score
=
this
.
#
score
(
snapshot
currentDate
currentSessionUrls
)
;
logConsole
.
debug
(
"
Scored
"
score
"
for
"
snapshot
.
url
)
;
if
(
existing
)
{
if
(
score
>
existing
.
relevancyScore
)
{
snapshot
.
relevancyScore
=
score
;
combined
.
set
(
snapshot
.
url
snapshot
)
;
}
}
else
if
(
score
>
=
this
.
snapshotThreshold
)
{
snapshot
.
relevancyScore
=
score
;
combined
.
set
(
snapshot
.
url
snapshot
)
;
}
}
}
return
[
.
.
.
combined
.
values
(
)
]
.
sort
(
(
a
b
)
=
>
b
.
relevancyScore
-
a
.
relevancyScore
)
;
}
overrideCurrentTimeForTests
(
date
)
{
this
.
#
dateOverride
=
date
;
}
#
score
(
snapshot
currentDate
currentSessionUrls
)
{
let
points
=
0
;
for
(
let
[
item
value
]
of
this
.
#
RELEVANCY_POINTS
.
entries
(
)
)
{
let
fnName
=
_score
{
item
}
;
if
(
!
(
fnName
in
this
)
)
{
console
.
error
(
"
Could
not
find
function
"
fnName
"
in
SnapshotScorer
"
)
;
continue
;
}
points
+
=
this
[
fnName
]
(
snapshot
currentSessionUrls
)
*
value
;
}
let
timeAgo
=
currentDate
-
snapshot
.
lastInteractionAt
;
timeAgo
=
timeAgo
/
(
24
*
60
*
60
*
1000
)
;
return
points
*
Math
.
exp
(
timeAgo
/
-
7
)
;
}
_scoreVisit
(
snapshot
)
{
if
(
snapshot
.
visitCount
=
=
0
)
{
return
0
;
}
return
2
-
1
/
snapshot
.
visitCount
;
}
_scoreCurrentSession
(
snapshot
currentSessionUrls
)
{
return
currentSessionUrls
.
has
(
snapshot
.
url
)
?
1
:
0
;
}
_scoreInNavigation
(
snapshot
)
{
return
0
;
}
_scoreIsOverlappingVisit
(
snapshot
)
{
return
snapshot
.
overlappingVisitScore
?
?
0
;
}
_scoreIsUserPersisted
(
snapshot
)
{
return
snapshot
.
userPersisted
!
=
Snapshots
.
USER_PERSISTED
.
NO
?
1
:
0
;
}
_scoreIsUsedRemoved
(
snapshot
)
{
return
snapshot
.
removedAt
?
1
:
0
;
}
}
)
(
)
;
