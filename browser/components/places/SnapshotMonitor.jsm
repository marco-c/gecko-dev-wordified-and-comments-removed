const
EXPORTED_SYMBOLS
=
[
"
SnapshotMonitor
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
clearTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
DomainGroupBuilder
:
"
resource
:
/
/
/
modules
/
DomainGroupBuilder
.
jsm
"
PinnedGroupBuilder
:
"
resource
:
/
/
/
modules
/
PinnedGroupBuilder
.
jsm
"
setTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
Snapshots
:
"
resource
:
/
/
/
modules
/
Snapshots
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
SNAPSHOT_ADDED_TIMER_DELAY
"
"
browser
.
places
.
snapshots
.
monitorDelayAdded
"
5000
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
SNAPSHOT_REMOVED_TIMER_DELAY
"
"
browser
.
places
.
snapshots
.
monitorDelayRemoved
"
1000
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
SNAPSHOT_EXPIRE_DAYS
"
"
browser
.
places
.
snapshots
.
expiration
.
days
"
210
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
SNAPSHOT_USERMANAGED_EXPIRE_DAYS
"
"
browser
.
places
.
snapshots
.
expiration
.
userManaged
.
days
"
420
)
;
const
EXPIRE_EVERY_MIN_MS
=
60
*
60000
;
const
EXPIRE_EVERY_MAX_MS
=
120
*
60000
;
const
EXPIRE_CHUNK_SIZE
=
10
;
const
SnapshotMonitor
=
new
(
class
SnapshotMonitor
{
#
addedTimerDelay
=
SNAPSHOT_ADDED_TIMER_DELAY
;
#
removedTimerDelay
=
SNAPSHOT_REMOVED_TIMER_DELAY
;
#
addedItems
=
new
Set
(
)
;
#
removedUrls
=
new
Set
(
)
;
#
timer
=
null
;
#
currentTargetTime
=
null
;
testGroupBuilders
=
null
;
#
lastExpirationTime
=
0
;
#
expirationChunkSize
=
EXPIRE_CHUNK_SIZE
;
get
#
groupBuilders
(
)
{
if
(
this
.
testGroupBuilders
)
{
return
this
.
testGroupBuilders
;
}
return
[
DomainGroupBuilder
PinnedGroupBuilder
]
;
}
get
skipMinimumSizeBuilders
(
)
{
let
names
=
[
]
;
for
(
let
builder
of
this
.
#
groupBuilders
)
{
let
name
=
builder
.
skipMinimumSize
;
if
(
name
)
{
names
.
push
(
builder
.
name
)
;
}
}
return
names
;
}
init
(
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
"
browser
.
places
.
interactions
.
enabled
"
false
)
)
{
return
;
}
Services
.
obs
.
addObserver
(
this
"
places
-
snapshots
-
added
"
)
;
Services
.
obs
.
addObserver
(
this
"
places
-
snapshots
-
deleted
"
)
;
Services
.
obs
.
addObserver
(
this
"
idle
-
daily
"
)
;
}
setTimerDelaysForTests
(
{
added
=
SNAPSHOT_ADDED_TIMER_DELAY
removed
=
SNAPSHOT_REMOVED_TIMER_DELAY
}
=
{
}
)
{
this
.
#
addedTimerDelay
=
added
;
this
.
#
removedTimerDelay
=
removed
;
}
async
#
triggerBuilders
(
rebuild
=
false
)
{
if
(
this
.
#
timer
)
{
clearTimeout
(
this
.
#
timer
)
;
}
this
.
#
timer
=
null
;
this
.
#
currentTargetTime
=
null
;
if
(
rebuild
)
{
let
snapshots
=
await
Snapshots
.
query
(
{
limit
:
-
1
}
)
;
for
(
let
builder
of
this
.
#
groupBuilders
)
{
await
builder
.
rebuild
(
snapshots
)
;
}
}
else
{
for
(
let
builder
of
this
.
#
groupBuilders
)
{
await
builder
.
update
(
{
addedItems
:
this
.
#
addedItems
removedUrls
:
this
.
#
removedUrls
}
)
;
}
}
this
.
#
addedItems
.
clear
(
)
;
this
.
#
removedUrls
.
clear
(
)
;
}
async
#
expireSnapshotsChunk
(
onIdle
=
false
)
{
let
now
=
Date
.
now
(
)
;
if
(
now
-
this
.
#
lastExpirationTime
<
EXPIRE_EVERY_MIN_MS
)
{
return
;
}
let
instance
=
(
this
.
_expireInstance
=
{
}
)
;
let
skip
=
false
;
if
(
!
onIdle
)
{
skip
=
await
new
Promise
(
resolve
=
>
ChromeUtils
.
idleDispatch
(
deadLine
=
>
{
resolve
(
deadLine
.
didTimeout
&
&
now
-
this
.
#
lastExpirationTime
<
EXPIRE_EVERY_MAX_MS
)
;
}
)
)
;
}
if
(
skip
|
|
instance
!
=
this
.
_expireInstance
)
{
return
;
}
this
.
#
lastExpirationTime
=
now
;
let
urls
=
(
await
Snapshots
.
query
(
{
includeUserPersisted
:
false
includeTombstones
:
false
includeSnapshotsInUserManagedGroups
:
false
lastInteractionBefore
:
now
-
SNAPSHOT_EXPIRE_DAYS
*
86400000
limit
:
this
.
#
expirationChunkSize
}
)
)
.
map
(
s
=
>
s
.
url
)
;
if
(
instance
!
=
this
.
_expireInstance
)
{
return
;
}
if
(
urls
.
length
<
this
.
#
expirationChunkSize
)
{
urls
.
push
(
.
.
.
(
await
Snapshots
.
query
(
{
includeUserPersisted
:
true
includeTombstones
:
false
lastInteractionBefore
:
now
-
SNAPSHOT_USERMANAGED_EXPIRE_DAYS
*
86400000
limit
:
this
.
#
expirationChunkSize
-
urls
.
length
}
)
)
.
map
(
s
=
>
s
.
url
)
)
;
}
if
(
instance
!
=
this
.
_expireInstance
)
{
return
;
}
await
Snapshots
.
delete
(
[
.
.
.
new
Set
(
urls
)
]
Snapshots
.
REMOVED_REASON
.
EXPIRED
)
;
}
#
setTimer
(
timeout
)
{
let
targetTime
=
Date
.
now
(
)
+
timeout
;
if
(
this
.
#
currentTargetTime
&
&
targetTime
>
=
this
.
#
currentTargetTime
)
{
return
;
}
if
(
this
.
#
timer
)
{
clearTimeout
(
this
.
#
timer
)
;
}
this
.
#
currentTargetTime
=
targetTime
;
this
.
#
timer
=
setTimeout
(
(
)
=
>
{
this
.
#
expireSnapshotsChunk
(
)
.
catch
(
console
.
error
)
;
this
.
#
triggerBuilders
(
)
.
catch
(
console
.
error
)
;
}
timeout
)
;
}
async
observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
"
places
-
snapshots
-
added
"
:
this
.
#
onSnapshotAdded
(
JSON
.
parse
(
data
)
)
;
break
;
case
"
places
-
snapshots
-
deleted
"
:
this
.
#
onSnapshotRemoved
(
JSON
.
parse
(
data
)
)
;
break
;
case
"
idle
-
daily
"
:
await
this
.
#
expireSnapshotsChunk
(
true
)
;
await
this
.
#
triggerBuilders
(
true
)
;
break
;
case
"
test
-
trigger
-
builders
"
:
await
this
.
#
triggerBuilders
(
true
)
;
break
;
case
"
test
-
expiration
"
:
this
.
#
lastExpirationTime
=
subject
.
lastExpirationTime
|
|
this
.
#
lastExpirationTime
;
this
.
#
expirationChunkSize
=
subject
.
expirationChunkSize
|
|
this
.
#
expirationChunkSize
;
await
this
.
#
expireSnapshotsChunk
(
subject
.
onIdle
)
;
break
;
}
}
#
onSnapshotAdded
(
items
)
{
for
(
let
item
of
items
)
{
this
.
#
addedItems
.
add
(
item
)
;
}
this
.
#
setTimer
(
this
.
#
addedTimerDelay
)
;
}
#
onSnapshotRemoved
(
urls
)
{
for
(
let
url
of
urls
)
{
this
.
#
removedUrls
.
add
(
url
)
;
}
this
.
#
setTimer
(
this
.
#
removedTimerDelay
)
;
}
}
)
(
)
;
