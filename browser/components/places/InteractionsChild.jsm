"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
InteractionsChild
"
]
;
ChromeUtils
.
defineModuleGetter
(
this
"
PrivateBrowsingUtils
"
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
class
InteractionsChild
extends
JSWindowActorChild
{
actorCreated
(
)
{
this
.
isContentWindowPrivate
=
PrivateBrowsingUtils
.
isContentWindowPrivate
(
this
.
contentWindow
)
;
}
async
handleEvent
(
event
)
{
if
(
this
.
isContentWindowPrivate
)
{
return
;
}
switch
(
event
.
type
)
{
case
"
DOMContentLoaded
"
:
{
if
(
!
this
.
docShell
.
currentDocumentChannel
|
|
!
(
this
.
docShell
.
currentDocumentChannel
instanceof
Ci
.
nsIHttpChannel
)
)
{
this
.
sendAsyncMessage
(
"
Interactions
:
PageHide
"
)
;
return
;
}
if
(
!
this
.
docShell
.
currentDocumentChannel
.
requestSucceeded
)
{
return
;
}
let
docInfo
=
await
this
.
#
getDocumentInfo
(
)
;
if
(
docInfo
)
{
this
.
sendAsyncMessage
(
"
Interactions
:
PageLoaded
"
docInfo
)
;
}
break
;
}
case
"
pagehide
"
:
{
if
(
!
this
.
docShell
.
currentDocumentChannel
|
|
!
(
this
.
docShell
.
currentDocumentChannel
instanceof
Ci
.
nsIHttpChannel
)
)
{
return
;
}
if
(
!
this
.
docShell
.
currentDocumentChannel
.
requestSucceeded
)
{
return
;
}
let
docInfo
=
await
this
.
#
getDocumentInfo
(
)
;
if
(
docInfo
)
{
this
.
sendAsyncMessage
(
"
Interactions
:
PageHide
"
)
;
}
break
;
}
}
}
async
#
getDocumentInfo
(
)
{
let
doc
=
this
.
document
;
if
(
doc
.
documentURIObject
.
scheme
!
=
"
http
"
&
&
doc
.
documentURIObject
.
scheme
!
=
"
https
"
)
{
return
null
;
}
return
{
isActive
:
this
.
manager
.
browsingContext
.
isActive
url
:
doc
.
documentURIObject
.
specIgnoringRef
}
;
}
}
