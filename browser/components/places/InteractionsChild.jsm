"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
InteractionsChild
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
PrivateBrowsingUtils
"
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
InteractionsBlocklist
:
"
resource
:
/
/
/
modules
/
InteractionsBlocklist
.
jsm
"
}
)
;
class
InteractionsChild
extends
JSWindowActorChild
{
#
progressListener
;
#
currentURL
;
actorCreated
(
)
{
this
.
isContentWindowPrivate
=
lazy
.
PrivateBrowsingUtils
.
isContentWindowPrivate
(
this
.
contentWindow
)
;
if
(
this
.
isContentWindowPrivate
)
{
return
;
}
this
.
#
progressListener
=
{
onLocationChange
:
(
webProgress
request
location
flags
)
=
>
{
this
.
onLocationChange
(
webProgress
request
location
flags
)
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIWebProgressListener2
"
"
nsIWebProgressListener
"
"
nsISupportsWeakReference
"
]
)
}
;
let
webProgress
=
this
.
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebProgress
)
;
webProgress
.
addProgressListener
(
this
.
#
progressListener
Ci
.
nsIWebProgress
.
NOTIFY_STATE_DOCUMENT
|
Ci
.
nsIWebProgress
.
NOTIFY_LOCATION
)
;
}
didDestroy
(
)
{
if
(
!
this
.
#
progressListener
|
|
!
this
.
docShell
)
{
return
;
}
let
webProgress
=
this
.
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebProgress
)
;
webProgress
.
removeProgressListener
(
this
.
#
progressListener
)
;
}
onLocationChange
(
webProgress
request
location
flags
)
{
if
(
!
webProgress
.
isTopLevel
)
{
return
;
}
if
(
!
(
flags
&
Ci
.
nsIWebProgressListener
.
LOCATION_CHANGE_SAME_DOCUMENT
)
)
{
return
;
}
this
.
#
recordNewPage
(
)
;
}
#
recordNewPage
(
)
{
let
docInfo
=
this
.
#
getDocumentInfo
(
)
;
if
(
!
docInfo
|
|
!
this
.
docShell
.
currentDocumentChannel
)
{
this
.
sendAsyncMessage
(
"
Interactions
:
PageHide
"
)
;
return
;
}
if
(
docInfo
.
url
=
=
this
.
#
currentURL
)
{
return
;
}
this
.
#
currentURL
=
docInfo
.
url
;
if
(
this
.
docShell
.
currentDocumentChannel
instanceof
Ci
.
nsIHttpChannel
&
&
!
this
.
docShell
.
currentDocumentChannel
.
requestSucceeded
)
{
return
;
}
this
.
sendAsyncMessage
(
"
Interactions
:
PageLoaded
"
docInfo
)
;
}
async
handleEvent
(
event
)
{
if
(
this
.
isContentWindowPrivate
)
{
return
;
}
switch
(
event
.
type
)
{
case
"
DOMContentLoaded
"
:
{
this
.
#
recordNewPage
(
)
;
break
;
}
case
"
pagehide
"
:
{
if
(
!
this
.
docShell
.
currentDocumentChannel
)
{
return
;
}
if
(
!
this
.
docShell
.
currentDocumentChannel
.
requestSucceeded
)
{
return
;
}
let
docInfo
=
await
this
.
#
getDocumentInfo
(
)
;
if
(
docInfo
)
{
this
.
sendAsyncMessage
(
"
Interactions
:
PageHide
"
)
;
}
break
;
}
}
}
#
getDocumentInfo
(
)
{
let
doc
=
this
.
document
;
let
requirements
=
lazy
.
InteractionsBlocklist
.
urlRequirements
.
get
(
doc
.
documentURIObject
.
scheme
+
"
:
"
)
;
if
(
!
requirements
|
|
(
requirements
.
extension
&
&
!
doc
.
documentURIObject
.
spec
.
endsWith
(
requirements
.
extension
)
)
)
{
return
null
;
}
let
referrer
;
if
(
doc
.
referrer
)
{
referrer
=
Services
.
io
.
newURI
(
doc
.
referrer
)
;
}
return
{
isActive
:
this
.
manager
.
browsingContext
.
isActive
url
:
doc
.
documentURIObject
.
specIgnoringRef
referrer
:
referrer
?
.
specIgnoringRef
}
;
}
}
