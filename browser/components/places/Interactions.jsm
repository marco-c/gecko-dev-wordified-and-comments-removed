"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
Interactions
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
BrowserWindowTracker
:
"
resource
:
/
/
/
modules
/
BrowserWindowTracker
.
jsm
"
clearTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
InteractionsBlocklist
:
"
resource
:
/
/
/
modules
/
InteractionsBlocklist
.
jsm
"
PlacesUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
PrivateBrowsingUtils
:
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
setTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
logConsole
"
function
(
)
{
return
console
.
createInstance
(
{
prefix
:
"
InteractionsManager
"
maxLogLevel
:
Services
.
prefs
.
getBoolPref
(
"
browser
.
places
.
interactions
.
log
"
false
)
?
"
Debug
"
:
"
Warn
"
}
)
;
}
)
;
XPCOMUtils
.
defineLazyServiceGetters
(
this
{
idleService
:
[
"
mozilla
.
org
/
widget
/
useridleservice
;
1
"
"
nsIUserIdleService
"
]
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
pageViewIdleTime
"
"
browser
.
places
.
interactions
.
pageViewIdleTime
"
60
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
saveInterval
"
"
browser
.
places
.
interactions
.
saveInterval
"
10000
)
;
const
DOMWINDOW_OPENED_TOPIC
=
"
domwindowopened
"
;
let
gLastTime
=
0
;
function
monotonicNow
(
)
{
let
time
=
Date
.
now
(
)
;
if
(
time
=
=
gLastTime
)
{
time
+
+
;
}
return
(
gLastTime
=
time
)
;
}
class
TypingInteraction
{
#
typingStartTime
=
null
;
#
typingEndTime
=
null
;
#
keypresses
=
0
;
static
_TYPING_TIMEOUT
=
3000
;
#
accumulatedKeypresses
=
0
;
#
accumulatedTypingTime
=
0
;
registerWindow
(
win
)
{
Services
.
els
.
addSystemEventListener
(
win
.
document
"
keyup
"
this
false
)
;
}
unregisterWindow
(
win
)
{
Services
.
els
.
removeSystemEventListener
(
win
.
document
"
keyup
"
this
false
)
;
}
#
isTypingKey
(
code
)
{
if
(
[
"
Space
"
"
Comma
"
"
Period
"
"
Quote
"
]
.
includes
(
code
)
)
{
return
true
;
}
return
(
code
.
startsWith
(
"
Key
"
)
|
|
code
.
startsWith
(
"
Digit
"
)
|
|
code
.
startsWith
(
"
Numpad
"
)
)
;
}
#
resetCurrentTypingMetrics
(
)
{
this
.
#
keypresses
=
0
;
this
.
#
typingStartTime
=
null
;
this
.
#
typingEndTime
=
null
;
}
resetTypingInteraction
(
)
{
this
.
#
resetCurrentTypingMetrics
(
)
;
this
.
#
accumulatedKeypresses
=
0
;
this
.
#
accumulatedTypingTime
=
0
;
}
getTypingInteraction
(
)
{
let
typingInteraction
=
this
.
#
getCurrentTypingMetrics
(
)
;
typingInteraction
.
typingTime
+
=
this
.
#
accumulatedTypingTime
;
typingInteraction
.
keypresses
+
=
this
.
#
accumulatedKeypresses
;
return
typingInteraction
;
}
#
getCurrentTypingMetrics
(
)
{
let
typingInteraction
=
{
typingTime
:
0
keypresses
:
0
}
;
if
(
this
.
#
keypresses
>
1
)
{
let
typingTime
=
this
.
#
typingEndTime
-
this
.
#
typingStartTime
;
typingInteraction
.
typingTime
=
typingTime
;
typingInteraction
.
keypresses
=
this
.
#
keypresses
;
}
return
typingInteraction
;
}
#
onTypingEnded
(
)
{
let
typingInteraction
=
this
.
#
getCurrentTypingMetrics
(
)
;
this
.
#
accumulatedTypingTime
+
=
typingInteraction
.
typingTime
;
this
.
#
accumulatedKeypresses
+
=
typingInteraction
.
keypresses
;
this
.
#
resetCurrentTypingMetrics
(
)
;
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
keyup
"
:
if
(
event
.
target
.
ownerGlobal
.
gBrowser
?
.
selectedBrowser
=
=
event
.
target
&
&
this
.
#
isTypingKey
(
event
.
code
)
)
{
const
now
=
Cu
.
now
(
)
;
const
lastKeyDelay
=
now
-
this
.
#
typingEndTime
;
if
(
this
.
#
keypresses
>
0
&
&
lastKeyDelay
>
TypingInteraction
.
_TYPING_TIMEOUT
)
{
this
.
#
onTypingEnded
(
)
;
}
this
.
#
keypresses
+
+
;
if
(
!
this
.
#
typingStartTime
)
{
this
.
#
typingStartTime
=
now
;
}
this
.
#
typingEndTime
=
now
;
}
break
;
}
}
}
class
_Interactions
{
#
interactions
=
new
WeakMap
(
)
;
#
typingInteraction
=
new
TypingInteraction
(
)
;
#
activeWindow
=
undefined
;
#
userIsIdle
=
false
;
_pageViewStartTime
=
Cu
.
now
(
)
;
#
store
=
undefined
;
init
(
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
"
browser
.
places
.
interactions
.
enabled
"
false
)
)
{
return
;
}
ChromeUtils
.
registerWindowActor
(
"
Interactions
"
{
parent
:
{
moduleURI
:
"
resource
:
/
/
/
actors
/
InteractionsParent
.
jsm
"
}
child
:
{
moduleURI
:
"
resource
:
/
/
/
actors
/
InteractionsChild
.
jsm
"
group
:
"
browsers
"
events
:
{
DOMContentLoaded
:
{
}
pagehide
:
{
mozSystemGroup
:
true
}
}
}
}
)
;
this
.
#
activeWindow
=
Services
.
wm
.
getMostRecentBrowserWindow
(
)
;
for
(
let
win
of
BrowserWindowTracker
.
orderedWindows
)
{
if
(
!
win
.
closed
)
{
this
.
#
registerWindow
(
win
)
;
}
}
Services
.
obs
.
addObserver
(
this
DOMWINDOW_OPENED_TOPIC
true
)
;
idleService
.
addIdleObserver
(
this
pageViewIdleTime
)
;
}
uninit
(
)
{
idleService
.
removeIdleObserver
(
this
pageViewIdleTime
)
;
}
async
reset
(
)
{
logConsole
.
debug
(
"
Reset
"
)
;
this
.
#
interactions
=
new
WeakMap
(
)
;
this
.
#
userIsIdle
=
false
;
this
.
_pageViewStartTime
=
Cu
.
now
(
)
;
this
.
#
typingInteraction
?
.
resetTypingInteraction
(
)
;
await
this
.
store
.
reset
(
)
;
}
get
store
(
)
{
if
(
!
this
.
#
store
)
{
this
.
#
store
=
new
InteractionsStore
(
)
;
}
return
this
.
#
store
;
}
registerNewInteraction
(
browser
docInfo
)
{
let
interaction
=
this
.
#
interactions
.
get
(
browser
)
;
if
(
interaction
&
&
interaction
.
url
!
=
docInfo
.
url
)
{
this
.
registerEndOfInteraction
(
browser
)
;
}
if
(
InteractionsBlocklist
.
isUrlBlocklisted
(
docInfo
.
url
)
)
{
logConsole
.
debug
(
"
URL
is
blocklisted
"
docInfo
)
;
return
;
}
logConsole
.
debug
(
"
New
interaction
"
docInfo
)
;
let
now
=
monotonicNow
(
)
;
interaction
=
{
url
:
docInfo
.
url
totalViewTime
:
0
typingTime
:
0
keypresses
:
0
created_at
:
now
updated_at
:
now
}
;
this
.
#
interactions
.
set
(
browser
interaction
)
;
if
(
docInfo
.
isActive
&
&
browser
.
ownerGlobal
=
=
this
.
#
activeWindow
)
{
this
.
_pageViewStartTime
=
Cu
.
now
(
)
;
}
}
registerEndOfInteraction
(
browser
)
{
if
(
!
browser
)
{
return
;
}
logConsole
.
debug
(
"
End
of
interaction
"
)
;
this
.
#
updateInteraction
(
browser
)
;
this
.
#
interactions
.
delete
(
browser
)
;
}
#
updateInteraction
(
browser
=
undefined
)
{
if
(
!
this
.
#
activeWindow
|
|
(
browser
&
&
browser
.
ownerGlobal
!
=
this
.
#
activeWindow
)
)
{
logConsole
.
debug
(
"
No
update
due
to
no
active
window
"
)
;
return
;
}
if
(
this
.
#
userIsIdle
)
{
logConsole
.
debug
(
"
No
update
due
to
user
is
idle
"
)
;
return
;
}
if
(
!
browser
)
{
browser
=
this
.
#
activeWindow
.
gBrowser
.
selectedTab
.
linkedBrowser
;
}
let
interaction
=
this
.
#
interactions
.
get
(
browser
)
;
if
(
!
interaction
)
{
logConsole
.
debug
(
"
No
interaction
to
update
"
)
;
return
;
}
interaction
.
totalViewTime
+
=
Cu
.
now
(
)
-
this
.
_pageViewStartTime
;
this
.
_pageViewStartTime
=
Cu
.
now
(
)
;
const
typingInteraction
=
this
.
#
typingInteraction
.
getTypingInteraction
(
)
;
interaction
.
typingTime
+
=
typingInteraction
.
typingTime
;
interaction
.
keypresses
+
=
typingInteraction
.
keypresses
;
interaction
.
updated_at
=
monotonicNow
(
)
;
this
.
#
typingInteraction
.
resetTypingInteraction
(
)
;
logConsole
.
debug
(
"
Add
to
store
:
"
interaction
)
;
this
.
store
.
add
(
interaction
)
;
}
#
onActivateWindow
(
win
)
{
logConsole
.
debug
(
"
Activate
window
"
)
;
if
(
PrivateBrowsingUtils
.
isWindowPrivate
(
win
)
)
{
return
;
}
this
.
#
activeWindow
=
win
;
this
.
_pageViewStartTime
=
Cu
.
now
(
)
;
}
#
onDeactivateWindow
(
win
)
{
logConsole
.
debug
(
"
Deactivate
window
"
)
;
this
.
#
updateInteraction
(
)
;
this
.
#
activeWindow
=
undefined
;
}
_getTypingTimeout
(
)
{
return
TypingInteraction
.
_TYPING_TIMEOUT
;
}
_setTypingTimeout
(
timeout
)
{
TypingInteraction
.
_TYPING_TIMEOUT
=
timeout
;
}
#
onTabSelect
(
previousBrowser
)
{
logConsole
.
debug
(
"
Tab
switch
notified
"
)
;
this
.
#
updateInteraction
(
previousBrowser
)
;
this
.
_pageViewStartTime
=
Cu
.
now
(
)
;
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
TabSelect
"
:
this
.
#
onTabSelect
(
event
.
detail
.
previousTab
.
linkedBrowser
)
;
break
;
case
"
activate
"
:
this
.
#
onActivateWindow
(
event
.
target
)
;
break
;
case
"
deactivate
"
:
this
.
#
onDeactivateWindow
(
event
.
target
)
;
break
;
case
"
unload
"
:
this
.
#
unregisterWindow
(
event
.
target
)
;
break
;
}
}
observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
DOMWINDOW_OPENED_TOPIC
:
this
.
#
onWindowOpen
(
subject
)
;
break
;
case
"
idle
"
:
logConsole
.
debug
(
"
idle
"
)
;
this
.
#
updateInteraction
(
)
;
this
.
#
userIsIdle
=
true
;
break
;
case
"
active
"
:
logConsole
.
debug
(
"
active
"
)
;
this
.
#
userIsIdle
=
false
;
this
.
_pageViewStartTime
=
Cu
.
now
(
)
;
break
;
}
}
#
registerWindow
(
win
)
{
if
(
PrivateBrowsingUtils
.
isWindowPrivate
(
win
)
)
{
return
;
}
win
.
addEventListener
(
"
TabSelect
"
this
true
)
;
win
.
addEventListener
(
"
deactivate
"
this
true
)
;
win
.
addEventListener
(
"
activate
"
this
true
)
;
this
.
#
typingInteraction
.
registerWindow
(
win
)
;
}
#
unregisterWindow
(
win
)
{
win
.
removeEventListener
(
"
TabSelect
"
this
true
)
;
win
.
removeEventListener
(
"
deactivate
"
this
true
)
;
win
.
removeEventListener
(
"
activate
"
this
true
)
;
this
.
#
typingInteraction
.
unregisterWindow
(
win
)
;
}
#
onWindowOpen
(
win
)
{
win
.
addEventListener
(
"
load
"
(
)
=
>
{
if
(
win
.
document
.
documentElement
.
getAttribute
(
"
windowtype
"
)
!
=
"
navigator
:
browser
"
)
{
return
;
}
this
.
#
registerWindow
(
win
)
;
}
{
once
:
true
}
)
;
}
QueryInterface
=
ChromeUtils
.
generateQI
(
[
"
nsIObserver
"
"
nsISupportsWeakReference
"
]
)
;
}
const
Interactions
=
new
_Interactions
(
)
;
class
InteractionsStore
{
#
timer
=
undefined
;
#
interactions
=
new
Map
(
)
;
#
timerResolve
=
undefined
;
constructor
(
)
{
this
.
progress
=
{
}
;
PlacesUtils
.
history
.
shutdownClient
.
jsclient
.
addBlocker
(
"
Interactions
.
jsm
:
:
store
"
async
(
)
=
>
this
.
flush
(
)
{
fetchState
:
(
)
=
>
this
.
progress
}
)
;
this
.
pendingPromise
=
Promise
.
resolve
(
)
;
}
async
flush
(
)
{
if
(
this
.
#
timer
)
{
clearTimeout
(
this
.
#
timer
)
;
this
.
#
timerResolve
(
)
;
await
this
.
#
updateDatabase
(
)
;
}
}
async
reset
(
)
{
await
PlacesUtils
.
withConnectionWrapper
(
"
Interactions
.
jsm
:
:
reset
"
async
db
=
>
{
await
db
.
executeCached
(
DELETE
FROM
moz_places_metadata
)
;
}
)
;
if
(
this
.
#
timer
)
{
clearTimeout
(
this
.
#
timer
)
;
this
.
#
timerResolve
(
)
;
this
.
#
interactions
.
clear
(
)
;
}
}
add
(
interaction
)
{
let
interactionsForUrl
=
this
.
#
interactions
.
get
(
interaction
.
url
)
;
if
(
!
interactionsForUrl
)
{
interactionsForUrl
=
new
Map
(
)
;
this
.
#
interactions
.
set
(
interaction
.
url
interactionsForUrl
)
;
}
interactionsForUrl
.
set
(
interaction
.
created_at
interaction
)
;
if
(
!
this
.
#
timer
)
{
let
promise
=
new
Promise
(
resolve
=
>
{
this
.
#
timerResolve
=
resolve
;
this
.
#
timer
=
setTimeout
(
(
)
=
>
{
logConsole
.
debug
(
"
Save
Timer
"
)
;
this
.
#
updateDatabase
(
)
.
catch
(
Cu
.
reportError
)
.
then
(
resolve
)
;
}
saveInterval
)
;
}
)
;
this
.
pendingPromise
=
this
.
pendingPromise
.
then
(
(
)
=
>
promise
)
;
}
}
async
#
updateDatabase
(
)
{
this
.
#
timer
=
undefined
;
let
interactions
=
this
.
#
interactions
;
this
.
#
interactions
=
new
Map
(
)
;
let
params
=
{
}
;
let
SQLInsertFragments
=
[
]
;
let
i
=
0
;
for
(
let
interactionsForUrl
of
interactions
.
values
(
)
)
{
for
(
let
interaction
of
interactionsForUrl
.
values
(
)
)
{
params
[
url
{
i
}
]
=
interaction
.
url
;
params
[
created_at
{
i
}
]
=
interaction
.
created_at
;
params
[
updated_at
{
i
}
]
=
interaction
.
updated_at
;
params
[
total_view_time
{
i
}
]
=
Math
.
round
(
interaction
.
totalViewTime
)
|
|
0
;
params
[
typing_time
{
i
}
]
=
Math
.
round
(
interaction
.
typingTime
)
|
|
0
;
params
[
key_presses
{
i
}
]
=
interaction
.
keypresses
|
|
0
;
SQLInsertFragments
.
push
(
(
(
SELECT
id
FROM
moz_places_metadata
WHERE
place_id
=
(
SELECT
id
FROM
moz_places
WHERE
url_hash
=
hash
(
:
url
{
i
}
)
AND
url
=
:
url
{
i
}
)
AND
created_at
=
:
created_at
{
i
}
)
(
SELECT
id
FROM
moz_places
WHERE
url_hash
=
hash
(
:
url
{
i
}
)
AND
url
=
:
url
{
i
}
)
:
created_at
{
i
}
:
updated_at
{
i
}
:
total_view_time
{
i
}
:
typing_time
{
i
}
:
key_presses
{
i
}
)
)
;
i
+
+
;
}
}
logConsole
.
debug
(
Storing
{
i
}
entries
in
the
database
)
;
this
.
progress
.
pendingUpdates
=
i
;
await
PlacesUtils
.
withConnectionWrapper
(
"
Interactions
.
jsm
:
:
updateDatabase
"
async
db
=
>
{
await
db
.
executeCached
(
WITH
inserts
(
id
place_id
created_at
updated_at
total_view_time
typing_time
key_presses
)
AS
(
VALUES
{
SQLInsertFragments
.
join
(
"
"
)
}
)
INSERT
OR
REPLACE
INTO
moz_places_metadata
(
id
place_id
created_at
updated_at
total_view_time
typing_time
key_presses
)
SELECT
*
FROM
inserts
WHERE
place_id
NOT
NULL
;
params
)
;
}
)
;
this
.
progress
.
pendingUpdates
=
0
;
}
}
