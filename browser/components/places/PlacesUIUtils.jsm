var
EXPORTED_SYMBOLS
=
[
"
PlacesUIUtils
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
Element
"
]
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AppConstants
:
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
BrowserWindowTracker
:
"
resource
:
/
/
/
modules
/
BrowserWindowTracker
.
jsm
"
OpenInTabsUtils
:
"
resource
:
/
/
/
modules
/
OpenInTabsUtils
.
jsm
"
PlacesTransactions
:
"
resource
:
/
/
gre
/
modules
/
PlacesTransactions
.
jsm
"
PlacesUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
PluralForm
:
"
resource
:
/
/
gre
/
modules
/
PluralForm
.
jsm
"
PrivateBrowsingUtils
:
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
PromiseUtils
:
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
Weave
:
"
resource
:
/
/
services
-
sync
/
main
.
js
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
bundle
"
function
(
)
{
return
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
browser
/
locale
/
places
/
places
.
properties
"
)
;
}
)
;
const
gInContentProcess
=
Services
.
appinfo
.
processType
=
=
Ci
.
nsIXULRuntime
.
PROCESS_TYPE_CONTENT
;
const
FAVICON_REQUEST_TIMEOUT
=
60
*
1000
;
let
gFaviconLoadDataMap
=
new
Map
(
)
;
const
ITEM_CHANGED_BATCH_NOTIFICATION_THRESHOLD
=
10
;
const
TAB_DROP_TYPE
=
"
application
/
x
-
moz
-
tabbrowser
-
tab
"
;
const
PREF_LOAD_BOOKMARKS_IN_BACKGROUND
=
"
browser
.
tabs
.
loadBookmarksInBackground
"
;
const
PREF_LOAD_BOOKMARKS_IN_TABS
=
"
browser
.
tabs
.
loadBookmarksInTabs
"
;
let
InternalFaviconLoader
=
{
observe
(
subject
topic
data
)
{
let
innerWindowID
=
subject
.
QueryInterface
(
Ci
.
nsISupportsPRUint64
)
.
data
;
this
.
removeRequestsForInner
(
innerWindowID
)
;
}
_cancelRequest
(
{
uri
innerWindowID
timerID
callback
}
reason
)
{
let
request
=
callback
.
request
;
delete
callback
.
request
;
clearTimeout
(
timerID
)
;
try
{
request
.
cancel
(
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
"
When
cancelling
a
request
for
"
+
uri
.
spec
+
"
because
"
+
reason
+
"
it
was
already
canceled
!
"
)
;
}
}
removeRequestsForInner
(
innerID
)
{
for
(
let
[
window
loadDataForWindow
]
of
gFaviconLoadDataMap
)
{
let
newLoadDataForWindow
=
loadDataForWindow
.
filter
(
loadData
=
>
{
let
innerWasDestroyed
=
loadData
.
innerWindowID
=
=
innerID
;
if
(
innerWasDestroyed
)
{
this
.
_cancelRequest
(
loadData
"
the
inner
window
was
destroyed
or
a
new
favicon
was
loaded
for
it
"
)
;
}
return
!
innerWasDestroyed
;
}
)
;
gFaviconLoadDataMap
.
set
(
window
newLoadDataForWindow
)
;
}
}
onUnload
(
win
)
{
let
loadDataForWindow
=
gFaviconLoadDataMap
.
get
(
win
)
;
if
(
loadDataForWindow
)
{
for
(
let
loadData
of
loadDataForWindow
)
{
this
.
_cancelRequest
(
loadData
"
the
chrome
window
went
away
"
)
;
}
}
gFaviconLoadDataMap
.
delete
(
win
)
;
}
_removeLoadDataFromWindowMap
(
win
{
innerWindowID
uri
callback
}
)
{
let
loadDataForWindow
=
gFaviconLoadDataMap
.
get
(
win
)
;
if
(
loadDataForWindow
)
{
let
itemIndex
=
loadDataForWindow
.
findIndex
(
loadData
=
>
{
return
loadData
.
innerWindowID
=
=
innerWindowID
&
&
loadData
.
uri
.
equals
(
uri
)
&
&
loadData
.
callback
.
request
=
=
callback
.
request
;
}
)
;
if
(
itemIndex
!
=
-
1
)
{
let
loadData
=
loadDataForWindow
[
itemIndex
]
;
loadDataForWindow
.
splice
(
itemIndex
1
)
;
return
loadData
;
}
}
return
null
;
}
_makeCompletionCallback
(
win
id
)
{
return
{
onComplete
(
uri
)
{
let
loadData
=
InternalFaviconLoader
.
_removeLoadDataFromWindowMap
(
win
{
uri
innerWindowID
:
id
callback
:
this
}
)
;
if
(
loadData
)
{
clearTimeout
(
loadData
.
timerID
)
;
}
delete
this
.
request
;
}
}
;
}
ensureInitialized
(
)
{
if
(
this
.
_initialized
)
{
return
;
}
this
.
_initialized
=
true
;
Services
.
obs
.
addObserver
(
this
"
inner
-
window
-
destroyed
"
)
;
Services
.
ppmm
.
addMessageListener
(
"
Toolkit
:
inner
-
window
-
destroyed
"
msg
=
>
{
this
.
removeRequestsForInner
(
msg
.
data
)
;
}
)
;
}
loadFavicon
(
browser
principal
uri
expiration
iconURI
)
{
this
.
ensureInitialized
(
)
;
let
win
=
browser
.
ownerGlobal
;
if
(
!
gFaviconLoadDataMap
.
has
(
win
)
)
{
gFaviconLoadDataMap
.
set
(
win
[
]
)
;
let
unloadHandler
=
event
=
>
{
let
doc
=
event
.
target
;
let
eventWin
=
doc
.
defaultView
;
if
(
eventWin
=
=
win
)
{
win
.
removeEventListener
(
"
unload
"
unloadHandler
)
;
this
.
onUnload
(
win
)
;
}
}
;
win
.
addEventListener
(
"
unload
"
unloadHandler
true
)
;
}
let
{
innerWindowID
currentURI
}
=
browser
;
let
loadType
=
PrivateBrowsingUtils
.
isWindowPrivate
(
win
)
?
PlacesUtils
.
favicons
.
FAVICON_LOAD_PRIVATE
:
PlacesUtils
.
favicons
.
FAVICON_LOAD_NON_PRIVATE
;
let
callback
=
this
.
_makeCompletionCallback
(
win
innerWindowID
)
;
if
(
iconURI
&
&
iconURI
.
schemeIs
(
"
data
"
)
)
{
expiration
=
PlacesUtils
.
toPRTime
(
expiration
)
;
PlacesUtils
.
favicons
.
replaceFaviconDataFromDataURL
(
uri
iconURI
.
spec
expiration
principal
)
;
}
let
request
=
PlacesUtils
.
favicons
.
setAndFetchFaviconForPage
(
currentURI
uri
false
loadType
callback
principal
)
;
if
(
!
request
)
{
return
;
}
callback
.
request
=
request
;
let
loadData
=
{
innerWindowID
uri
callback
}
;
loadData
.
timerID
=
setTimeout
(
(
)
=
>
{
this
.
_cancelRequest
(
loadData
"
it
timed
out
"
)
;
this
.
_removeLoadDataFromWindowMap
(
win
loadData
)
;
}
FAVICON_REQUEST_TIMEOUT
)
;
let
loadDataForWindow
=
gFaviconLoadDataMap
.
get
(
win
)
;
loadDataForWindow
.
push
(
loadData
)
;
}
}
;
var
PlacesUIUtils
=
{
LAST_USED_FOLDERS_META_KEY
:
"
bookmarks
/
lastusedfolders
"
createFixedURI
:
function
PUIU_createFixedURI
(
aSpec
)
{
return
Services
.
uriFixup
.
createFixupURI
(
aSpec
Ci
.
nsIURIFixup
.
FIXUP_FLAG_NONE
)
;
}
getFormattedString
:
function
PUIU_getFormattedString
(
key
params
)
{
return
bundle
.
formatStringFromName
(
key
params
params
.
length
)
;
}
getPluralString
:
function
PUIU_getPluralString
(
aKey
aNumber
aParams
)
{
let
str
=
PluralForm
.
get
(
aNumber
bundle
.
GetStringFromName
(
aKey
)
)
;
return
str
.
replace
(
/
\
#
(
\
d
+
)
/
g
function
(
matchedId
matchedNumber
)
{
let
param
=
aParams
[
parseInt
(
matchedNumber
10
)
-
1
]
;
return
param
!
=
=
undefined
?
param
:
matchedId
;
}
)
;
}
getString
:
function
PUIU_getString
(
key
)
{
return
bundle
.
GetStringFromName
(
key
)
;
}
showBookmarkDialog
(
aInfo
aParentWindow
)
{
let
hasFolderPicker
=
!
(
"
hiddenRows
"
in
aInfo
)
|
|
!
aInfo
.
hiddenRows
.
includes
(
"
folderPicker
"
)
;
let
dialogURL
=
hasFolderPicker
?
"
chrome
:
/
/
browser
/
content
/
places
/
bookmarkProperties2
.
xul
"
:
"
chrome
:
/
/
browser
/
content
/
places
/
bookmarkProperties
.
xul
"
;
let
features
=
"
centerscreen
chrome
modal
resizable
=
yes
"
;
let
topUndoEntry
;
let
batchBlockingDeferred
;
topUndoEntry
=
PlacesTransactions
.
topUndoEntry
;
batchBlockingDeferred
=
PromiseUtils
.
defer
(
)
;
PlacesTransactions
.
batch
(
async
(
)
=
>
{
await
batchBlockingDeferred
.
promise
;
}
)
;
aParentWindow
.
openDialog
(
dialogURL
"
"
features
aInfo
)
;
let
bookmarkGuid
=
(
"
bookmarkGuid
"
in
aInfo
&
&
aInfo
.
bookmarkGuid
)
|
|
undefined
;
batchBlockingDeferred
.
resolve
(
)
;
if
(
!
bookmarkGuid
&
&
topUndoEntry
!
=
PlacesTransactions
.
topUndoEntry
)
{
PlacesTransactions
.
undo
(
)
.
catch
(
Cu
.
reportError
)
;
}
return
bookmarkGuid
;
}
loadFavicon
(
browser
principal
uri
expiration
=
0
iconURI
=
null
)
{
if
(
gInContentProcess
)
{
throw
new
Error
(
"
Can
'
t
track
loads
from
within
the
child
process
!
"
)
;
}
InternalFaviconLoader
.
loadFavicon
(
browser
principal
uri
expiration
iconURI
)
;
}
getViewForNode
:
function
PUIU_getViewForNode
(
aNode
)
{
let
node
=
aNode
;
if
(
node
.
localName
=
=
"
panelview
"
&
&
node
.
_placesView
)
{
return
node
.
_placesView
;
}
if
(
node
.
localName
=
=
"
menu
"
&
&
!
node
.
_placesNode
&
&
node
.
lastChild
.
_placesView
)
return
node
.
lastChild
.
_placesView
;
while
(
Element
.
isInstance
(
node
)
)
{
if
(
node
.
_placesView
)
return
node
.
_placesView
;
if
(
node
.
localName
=
=
"
tree
"
&
&
node
.
getAttribute
(
"
type
"
)
=
=
"
places
"
)
return
node
;
node
=
node
.
parentNode
;
}
return
null
;
}
getControllerForCommand
(
win
command
)
{
let
popupNode
;
try
{
popupNode
=
win
.
document
.
popupNode
;
}
catch
(
e
)
{
return
null
;
}
if
(
popupNode
)
{
let
view
=
this
.
getViewForNode
(
popupNode
)
;
if
(
view
&
&
view
.
_contextMenuShown
)
return
view
.
controllers
.
getControllerForCommand
(
command
)
;
}
let
controller
=
win
.
top
.
document
.
commandDispatcher
.
getControllerForCommand
(
command
)
;
return
controller
|
|
null
;
}
updateCommands
(
win
)
{
let
controller
=
this
.
getControllerForCommand
(
win
"
placesCmd_open
"
)
;
for
(
let
command
of
[
"
placesCmd_open
"
"
placesCmd_open
:
window
"
"
placesCmd_open
:
privatewindow
"
"
placesCmd_open
:
tab
"
"
placesCmd_new
:
folder
"
"
placesCmd_new
:
bookmark
"
"
placesCmd_new
:
separator
"
"
placesCmd_show
:
info
"
"
placesCmd_reload
"
"
placesCmd_sortBy
:
name
"
"
placesCmd_cut
"
"
placesCmd_copy
"
"
placesCmd_paste
"
"
placesCmd_delete
"
]
)
{
win
.
goSetCommandEnabled
(
command
controller
&
&
controller
.
isCommandEnabled
(
command
)
)
;
}
}
doCommand
(
win
command
)
{
let
controller
=
this
.
getControllerForCommand
(
win
command
)
;
if
(
controller
&
&
controller
.
isCommandEnabled
(
command
)
)
controller
.
doCommand
(
command
)
;
}
markPageAsTyped
:
function
PUIU_markPageAsTyped
(
aURL
)
{
PlacesUtils
.
history
.
markPageAsTyped
(
this
.
createFixedURI
(
aURL
)
)
;
}
markPageAsFollowedBookmark
:
function
PUIU_markPageAsFollowedBookmark
(
aURL
)
{
PlacesUtils
.
history
.
markPageAsFollowedBookmark
(
this
.
createFixedURI
(
aURL
)
)
;
}
markPageAsFollowedLink
:
function
PUIU_markPageAsFollowedLink
(
aURL
)
{
PlacesUtils
.
history
.
markPageAsFollowedLink
(
this
.
createFixedURI
(
aURL
)
)
;
}
async
setCharsetForPage
(
url
charset
window
)
{
if
(
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
{
return
;
}
if
(
charset
.
toLowerCase
(
)
=
=
"
utf
-
8
"
)
{
charset
=
null
;
}
await
PlacesUtils
.
history
.
update
(
{
url
annotations
:
new
Map
(
[
[
PlacesUtils
.
CHARSET_ANNO
charset
]
]
)
}
)
;
}
checkURLSecurity
:
function
PUIU_checkURLSecurity
(
aURINode
aWindow
)
{
if
(
PlacesUtils
.
nodeIsBookmark
(
aURINode
)
)
return
true
;
var
uri
=
Services
.
io
.
newURI
(
aURINode
.
uri
)
;
if
(
uri
.
schemeIs
(
"
javascript
"
)
|
|
uri
.
schemeIs
(
"
data
"
)
)
{
const
BRANDING_BUNDLE_URI
=
"
chrome
:
/
/
branding
/
locale
/
brand
.
properties
"
;
var
brandShortName
=
Services
.
strings
.
createBundle
(
BRANDING_BUNDLE_URI
)
.
GetStringFromName
(
"
brandShortName
"
)
;
var
errorStr
=
this
.
getString
(
"
load
-
js
-
data
-
url
-
error
"
)
;
Services
.
prompt
.
alert
(
aWindow
brandShortName
errorStr
)
;
return
false
;
}
return
true
;
}
canUserRemove
(
aNode
aView
)
{
let
parentNode
=
aNode
.
parent
;
if
(
!
parentNode
)
{
return
false
;
}
if
(
PlacesUtils
.
nodeIsQuery
(
parentNode
)
)
{
if
(
PlacesUtils
.
nodeIsFolder
(
aNode
)
)
{
let
guid
=
PlacesUtils
.
getConcreteItemGuid
(
aNode
)
;
if
(
PlacesUtils
.
isRootItem
(
guid
)
)
{
return
false
;
}
}
else
if
(
PlacesUtils
.
isVirtualLeftPaneItem
(
aNode
.
bookmarkGuid
)
)
{
return
false
;
}
}
if
(
aNode
.
itemId
=
=
-
1
)
{
return
!
PlacesUtils
.
nodeIsFolder
(
parentNode
)
;
}
if
(
PlacesUtils
.
nodeIsQuery
(
parentNode
)
)
return
true
;
return
!
this
.
isFolderReadOnly
(
parentNode
aView
)
;
}
isFolderReadOnly
(
placesNode
view
)
{
if
(
typeof
placesNode
!
=
"
object
"
|
|
!
PlacesUtils
.
nodeIsFolder
(
placesNode
)
)
{
throw
new
Error
(
"
invalid
value
for
placesNode
"
)
;
}
if
(
!
view
|
|
typeof
view
!
=
"
object
"
)
{
throw
new
Error
(
"
invalid
value
for
aView
"
)
;
}
let
itemId
=
PlacesUtils
.
getConcreteItemId
(
placesNode
)
;
if
(
itemId
=
=
PlacesUtils
.
placesRootId
|
|
view
.
controller
.
hasCachedLivemarkInfo
(
placesNode
)
)
return
true
;
return
false
;
}
_openTabset
:
function
PUIU__openTabset
(
aItemsToOpen
aEvent
aWindow
)
{
if
(
!
aItemsToOpen
.
length
)
return
;
let
browserWindow
=
getBrowserWindow
(
aWindow
)
;
var
urls
=
[
]
;
let
skipMarking
=
browserWindow
&
&
PrivateBrowsingUtils
.
isWindowPrivate
(
browserWindow
)
;
for
(
let
item
of
aItemsToOpen
)
{
urls
.
push
(
item
.
uri
)
;
if
(
skipMarking
)
{
continue
;
}
if
(
item
.
isBookmark
)
this
.
markPageAsFollowedBookmark
(
item
.
uri
)
;
else
this
.
markPageAsTyped
(
item
.
uri
)
;
}
var
where
=
browserWindow
?
browserWindow
.
whereToOpenLink
(
aEvent
false
true
)
:
"
window
"
;
if
(
where
=
=
"
window
"
)
{
var
uriList
=
PlacesUtils
.
toISupportsString
(
urls
.
join
(
"
|
"
)
)
;
var
args
=
Cc
[
"
mozilla
.
org
/
array
;
1
"
]
.
createInstance
(
Ci
.
nsIMutableArray
)
;
args
.
appendElement
(
uriList
)
;
browserWindow
=
Services
.
ww
.
openWindow
(
aWindow
AppConstants
.
BROWSER_CHROME_URL
null
"
chrome
dialog
=
no
all
"
args
)
;
return
;
}
var
loadInBackground
=
where
=
=
"
tabshifted
"
;
browserWindow
.
gBrowser
.
loadTabs
(
urls
{
inBackground
:
loadInBackground
replace
:
false
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
}
)
;
}
openLiveMarkNodesInTabs
:
function
PUIU_openLiveMarkNodesInTabs
(
aNode
aEvent
aView
)
{
let
window
=
aView
.
ownerWindow
;
PlacesUtils
.
livemarks
.
getLivemark
(
{
id
:
aNode
.
itemId
}
)
.
then
(
aLivemark
=
>
{
let
urlsToOpen
=
[
]
;
let
nodes
=
aLivemark
.
getNodesForContainer
(
aNode
)
;
for
(
let
node
of
nodes
)
{
urlsToOpen
.
push
(
{
uri
:
node
.
uri
isBookmark
:
false
}
)
;
}
if
(
OpenInTabsUtils
.
confirmOpenInTabs
(
urlsToOpen
.
length
window
)
)
{
this
.
_openTabset
(
urlsToOpen
aEvent
window
)
;
}
}
Cu
.
reportError
)
;
}
openContainerNodeInTabs
:
function
PUIU_openContainerInTabs
(
aNode
aEvent
aView
)
{
let
window
=
aView
.
ownerWindow
;
let
urlsToOpen
=
PlacesUtils
.
getURLsForContainerNode
(
aNode
)
;
if
(
OpenInTabsUtils
.
confirmOpenInTabs
(
urlsToOpen
.
length
window
)
)
{
this
.
_openTabset
(
urlsToOpen
aEvent
window
)
;
}
}
openURINodesInTabs
:
function
PUIU_openURINodesInTabs
(
aNodes
aEvent
aView
)
{
let
window
=
aView
.
ownerWindow
;
let
urlsToOpen
=
[
]
;
for
(
var
i
=
0
;
i
<
aNodes
.
length
;
i
+
+
)
{
if
(
PlacesUtils
.
nodeIsURI
(
aNodes
[
i
]
)
)
urlsToOpen
.
push
(
{
uri
:
aNodes
[
i
]
.
uri
isBookmark
:
PlacesUtils
.
nodeIsBookmark
(
aNodes
[
i
]
)
}
)
;
}
this
.
_openTabset
(
urlsToOpen
aEvent
window
)
;
}
openNodeWithEvent
:
function
PUIU_openNodeWithEvent
(
aNode
aEvent
)
{
let
window
=
aEvent
.
target
.
ownerGlobal
;
let
browserWindow
=
getBrowserWindow
(
window
)
;
let
where
=
window
.
whereToOpenLink
(
aEvent
false
true
)
;
if
(
this
.
loadBookmarksInTabs
&
&
PlacesUtils
.
nodeIsBookmark
(
aNode
)
)
{
if
(
where
=
=
"
current
"
&
&
!
aNode
.
uri
.
startsWith
(
"
javascript
:
"
)
)
{
where
=
"
tab
"
;
}
if
(
where
=
=
"
tab
"
&
&
browserWindow
.
isTabEmpty
(
browserWindow
.
gBrowser
.
selectedTab
)
)
{
where
=
"
current
"
;
}
}
this
.
_openNodeIn
(
aNode
where
window
)
;
let
view
=
this
.
getViewForNode
(
aEvent
.
target
)
;
if
(
view
&
&
view
.
controller
.
hasCachedLivemarkInfo
(
aNode
.
parent
)
)
{
Services
.
telemetry
.
scalarAdd
(
"
browser
.
feeds
.
livebookmark_item_opened
"
1
)
;
}
}
openNodeIn
:
function
PUIU_openNodeIn
(
aNode
aWhere
aView
aPrivate
)
{
let
window
=
aView
.
ownerWindow
;
this
.
_openNodeIn
(
aNode
aWhere
window
aPrivate
)
;
}
_openNodeIn
:
function
PUIU__openNodeIn
(
aNode
aWhere
aWindow
aPrivate
=
false
)
{
if
(
aNode
&
&
PlacesUtils
.
nodeIsURI
(
aNode
)
&
&
this
.
checkURLSecurity
(
aNode
aWindow
)
)
{
let
isBookmark
=
PlacesUtils
.
nodeIsBookmark
(
aNode
)
;
if
(
!
PrivateBrowsingUtils
.
isWindowPrivate
(
aWindow
)
)
{
if
(
isBookmark
)
this
.
markPageAsFollowedBookmark
(
aNode
.
uri
)
;
else
this
.
markPageAsTyped
(
aNode
.
uri
)
;
}
aWindow
.
openTrustedLinkIn
(
aNode
.
uri
aWhere
{
allowPopups
:
aNode
.
uri
.
startsWith
(
"
javascript
:
"
)
inBackground
:
this
.
loadBookmarksInBackground
private
:
aPrivate
}
)
;
}
}
guessUrlSchemeForUI
(
href
)
{
return
href
.
substr
(
0
href
.
indexOf
(
"
:
"
)
)
;
}
getBestTitle
:
function
PUIU_getBestTitle
(
aNode
aDoNotCutTitle
)
{
var
title
;
if
(
!
aNode
.
title
&
&
PlacesUtils
.
nodeIsURI
(
aNode
)
)
{
try
{
var
uri
=
Services
.
io
.
newURI
(
aNode
.
uri
)
;
var
host
=
uri
.
host
;
var
fileName
=
uri
.
QueryInterface
(
Ci
.
nsIURL
)
.
fileName
;
if
(
aDoNotCutTitle
)
{
title
=
host
+
uri
.
pathQueryRef
;
}
else
{
title
=
host
+
(
fileName
?
(
host
?
"
/
"
+
this
.
ellipsis
+
"
/
"
:
"
"
)
+
fileName
:
uri
.
pathQueryRef
)
;
}
}
catch
(
e
)
{
title
=
"
"
;
}
}
else
title
=
aNode
.
title
;
return
title
|
|
this
.
getString
(
"
noTitle
"
)
;
}
shouldShowTabsFromOtherComputersMenuitem
(
)
{
let
weaveOK
=
Weave
.
Status
.
checkSetup
(
)
!
=
Weave
.
CLIENT_NOT_CONFIGURED
&
&
Weave
.
Svc
.
Prefs
.
get
(
"
firstSync
"
"
"
)
!
=
"
notReady
"
;
return
weaveOK
;
}
isFolderShortcutQueryString
(
queryString
)
{
let
query
=
{
}
options
=
{
}
;
PlacesUtils
.
history
.
queryStringToQuery
(
queryString
query
options
)
;
query
=
query
.
value
;
options
=
options
.
value
;
return
query
.
folderCount
=
=
1
&
&
!
query
.
hasBeginTime
&
&
!
query
.
hasEndTime
&
&
!
query
.
hasDomain
&
&
!
query
.
hasURI
&
&
!
query
.
hasSearchTerms
&
&
!
query
.
tags
.
length
=
=
0
&
&
options
.
maxResults
=
=
0
;
}
async
promiseNodeLikeFromFetchInfo
(
aFetchInfo
)
{
if
(
aFetchInfo
.
itemType
=
=
PlacesUtils
.
bookmarks
.
TYPE_SEPARATOR
)
throw
new
Error
(
"
promiseNodeLike
doesn
'
t
support
separators
"
)
;
let
parent
=
{
itemId
:
await
PlacesUtils
.
promiseItemId
(
aFetchInfo
.
parentGuid
)
bookmarkGuid
:
aFetchInfo
.
parentGuid
type
:
Ci
.
nsINavHistoryResultNode
.
RESULT_TYPE_FOLDER
}
;
return
Object
.
freeze
(
{
itemId
:
await
PlacesUtils
.
promiseItemId
(
aFetchInfo
.
guid
)
bookmarkGuid
:
aFetchInfo
.
guid
title
:
aFetchInfo
.
title
uri
:
aFetchInfo
.
url
!
=
=
undefined
?
aFetchInfo
.
url
.
href
:
"
"
get
type
(
)
{
if
(
aFetchInfo
.
itemType
=
=
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
)
return
Ci
.
nsINavHistoryResultNode
.
RESULT_TYPE_FOLDER
;
if
(
this
.
uri
.
length
=
=
0
)
throw
new
Error
(
"
Unexpected
item
type
"
)
;
if
(
/
^
place
:
/
.
test
(
this
.
uri
)
)
{
if
(
this
.
isFolderShortcutQueryString
(
this
.
uri
)
)
return
Ci
.
nsINavHistoryResultNode
.
RESULT_TYPE_FOLDER_SHORTCUT
;
return
Ci
.
nsINavHistoryResultNode
.
RESULT_TYPE_QUERY
;
}
return
Ci
.
nsINavHistoryResultNode
.
RESULT_TYPE_URI
;
}
get
parent
(
)
{
return
parent
;
}
}
)
;
}
async
batchUpdatesForNode
(
resultNode
itemsBeingChanged
functionToWrap
)
{
if
(
!
resultNode
)
{
await
functionToWrap
(
)
;
return
;
}
resultNode
=
resultNode
.
QueryInterface
(
Ci
.
nsINavBookmarkObserver
)
;
if
(
itemsBeingChanged
>
ITEM_CHANGED_BATCH_NOTIFICATION_THRESHOLD
)
{
resultNode
.
onBeginUpdateBatch
(
)
;
}
try
{
await
functionToWrap
(
)
;
}
finally
{
if
(
itemsBeingChanged
>
ITEM_CHANGED_BATCH_NOTIFICATION_THRESHOLD
)
{
resultNode
.
onEndUpdateBatch
(
)
;
}
}
}
async
handleTransferItems
(
items
insertionPoint
doCopy
view
)
{
let
transactions
;
let
itemsCount
;
if
(
insertionPoint
.
isTag
)
{
let
urls
=
items
.
filter
(
item
=
>
"
uri
"
in
item
)
.
map
(
item
=
>
item
.
uri
)
;
itemsCount
=
urls
.
length
;
transactions
=
[
PlacesTransactions
.
Tag
(
{
urls
tag
:
insertionPoint
.
tagName
}
)
]
;
}
else
{
let
insertionIndex
=
await
insertionPoint
.
getIndex
(
)
;
itemsCount
=
items
.
length
;
transactions
=
getTransactionsForTransferItems
(
items
insertionIndex
insertionPoint
.
guid
!
doCopy
)
;
}
if
(
!
transactions
.
length
)
{
return
[
]
;
}
let
guidsToSelect
=
[
]
;
let
resultForBatching
=
getResultForBatching
(
view
)
;
let
batchingItem
=
transactions
;
if
(
!
insertionPoint
.
isTag
)
{
batchingItem
=
async
(
)
=
>
{
for
(
let
transaction
of
transactions
)
{
let
result
=
await
transaction
.
transact
(
)
;
guidsToSelect
=
guidsToSelect
.
concat
(
result
)
;
}
}
;
}
await
this
.
batchUpdatesForNode
(
resultForBatching
itemsCount
async
(
)
=
>
{
await
PlacesTransactions
.
batch
(
batchingItem
)
;
}
)
;
return
guidsToSelect
;
}
onSidebarTreeClick
(
event
)
{
if
(
event
.
button
=
=
2
)
return
;
let
tree
=
event
.
target
.
parentNode
;
let
tbo
=
tree
.
treeBoxObject
;
let
cell
=
tbo
.
getCellAt
(
event
.
clientX
event
.
clientY
)
;
if
(
cell
.
row
=
=
-
1
|
|
cell
.
childElt
=
=
"
twisty
"
)
return
;
let
win
=
tree
.
ownerGlobal
;
let
rect
=
tbo
.
getCoordsForCellItem
(
cell
.
row
cell
.
col
"
image
"
)
;
let
isRTL
=
win
.
getComputedStyle
(
tree
)
.
direction
=
=
"
rtl
"
;
let
mouseInGutter
=
isRTL
?
event
.
clientX
>
rect
.
x
:
event
.
clientX
<
rect
.
x
;
let
metaKey
=
AppConstants
.
platform
=
=
=
"
macosx
"
?
event
.
metaKey
:
event
.
ctrlKey
;
let
modifKey
=
metaKey
|
|
event
.
shiftKey
;
let
isContainer
=
tbo
.
view
.
isContainer
(
cell
.
row
)
;
let
openInTabs
=
isContainer
&
&
(
event
.
button
=
=
1
|
|
(
event
.
button
=
=
0
&
&
modifKey
)
)
&
&
PlacesUtils
.
hasChildURIs
(
tree
.
view
.
nodeForTreeIndex
(
cell
.
row
)
)
;
if
(
event
.
button
=
=
0
&
&
isContainer
&
&
!
openInTabs
)
{
tbo
.
view
.
toggleOpenState
(
cell
.
row
)
;
}
else
if
(
!
mouseInGutter
&
&
openInTabs
&
&
event
.
originalTarget
.
localName
=
=
"
treechildren
"
)
{
tbo
.
view
.
selection
.
select
(
cell
.
row
)
;
this
.
openContainerNodeInTabs
(
tree
.
selectedNode
event
tree
)
;
}
else
if
(
!
mouseInGutter
&
&
!
isContainer
&
&
event
.
originalTarget
.
localName
=
=
"
treechildren
"
)
{
tbo
.
view
.
selection
.
select
(
cell
.
row
)
;
this
.
openNodeWithEvent
(
tree
.
selectedNode
event
)
;
}
}
onSidebarTreeKeyPress
(
event
)
{
let
node
=
event
.
target
.
selectedNode
;
if
(
node
)
{
if
(
event
.
keyCode
=
=
event
.
DOM_VK_RETURN
)
this
.
openNodeWithEvent
(
node
event
)
;
}
}
onSidebarTreeMouseMove
(
event
)
{
let
treechildren
=
event
.
target
;
if
(
treechildren
.
localName
!
=
"
treechildren
"
)
return
;
let
tree
=
treechildren
.
parentNode
;
let
cell
=
tree
.
treeBoxObject
.
getCellAt
(
event
.
clientX
event
.
clientY
)
;
if
(
cell
.
row
!
=
-
1
)
{
let
node
=
tree
.
view
.
nodeForTreeIndex
(
cell
.
row
)
;
if
(
PlacesUtils
.
nodeIsURI
(
node
)
)
{
this
.
setMouseoverURL
(
node
.
uri
tree
.
ownerGlobal
)
;
return
;
}
}
this
.
setMouseoverURL
(
"
"
tree
.
ownerGlobal
)
;
}
setMouseoverURL
(
url
win
)
{
if
(
win
.
top
.
XULBrowserWindow
)
{
win
.
top
.
XULBrowserWindow
.
setOverLink
(
url
null
)
;
}
}
}
;
XPCOMUtils
.
defineLazyGetter
(
PlacesUIUtils
"
PLACES_FLAVORS
"
(
)
=
>
{
return
[
PlacesUtils
.
TYPE_X_MOZ_PLACE_CONTAINER
PlacesUtils
.
TYPE_X_MOZ_PLACE_SEPARATOR
PlacesUtils
.
TYPE_X_MOZ_PLACE
]
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
PlacesUIUtils
"
URI_FLAVORS
"
(
)
=
>
{
return
[
PlacesUtils
.
TYPE_X_MOZ_URL
TAB_DROP_TYPE
PlacesUtils
.
TYPE_UNICODE
]
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
PlacesUIUtils
"
SUPPORTED_FLAVORS
"
(
)
=
>
{
return
[
.
.
.
PlacesUIUtils
.
PLACES_FLAVORS
.
.
.
PlacesUIUtils
.
URI_FLAVORS
]
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
PlacesUIUtils
"
ellipsis
"
function
(
)
{
return
Services
.
prefs
.
getComplexValue
(
"
intl
.
ellipsis
"
Ci
.
nsIPrefLocalizedString
)
.
data
;
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
PlacesUIUtils
"
loadBookmarksInBackground
"
PREF_LOAD_BOOKMARKS_IN_BACKGROUND
false
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
PlacesUIUtils
"
loadBookmarksInTabs
"
PREF_LOAD_BOOKMARKS_IN_TABS
false
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
PlacesUIUtils
"
openInTabClosesMenu
"
"
browser
.
bookmarks
.
openInTabClosesMenu
"
false
)
;
function
canMoveUnwrappedNode
(
unwrappedNode
)
{
if
(
(
unwrappedNode
.
concreteGuid
&
&
PlacesUtils
.
isRootItem
(
unwrappedNode
.
concreteGuid
)
)
|
|
unwrappedNode
.
id
<
=
0
|
|
PlacesUtils
.
isRootItem
(
unwrappedNode
.
id
)
)
{
return
false
;
}
let
parentGuid
=
unwrappedNode
.
parentGuid
;
if
(
!
parentGuid
|
|
parentGuid
=
=
PlacesUtils
.
bookmarks
.
rootGuid
)
{
return
false
;
}
return
true
;
}
function
getResultForBatching
(
viewOrElement
)
{
if
(
viewOrElement
&
&
Element
.
isInstance
(
viewOrElement
)
&
&
viewOrElement
.
id
=
=
=
"
placesList
"
)
{
viewOrElement
=
viewOrElement
.
ownerDocument
.
getElementById
(
"
placeContent
"
)
|
|
viewOrElement
;
}
if
(
viewOrElement
&
&
viewOrElement
.
result
)
{
return
viewOrElement
.
result
;
}
return
null
;
}
function
getTransactionsForTransferItems
(
items
insertionIndex
insertionParentGuid
doMove
)
{
let
canMove
=
true
;
for
(
let
item
of
items
)
{
if
(
!
PlacesUIUtils
.
SUPPORTED_FLAVORS
.
includes
(
item
.
type
)
)
{
throw
new
Error
(
Unsupported
'
{
item
.
type
}
'
data
type
)
;
}
if
(
!
(
"
instanceId
"
in
item
)
|
|
item
.
instanceId
!
=
PlacesUtils
.
instanceId
)
{
if
(
item
.
type
=
=
PlacesUtils
.
TYPE_X_MOZ_PLACE_CONTAINER
)
{
throw
new
Error
(
"
Can
'
t
copy
a
container
from
a
legacy
-
transactions
build
"
)
;
}
if
(
PlacesUIUtils
.
PLACES_FLAVORS
.
includes
(
item
.
type
)
)
{
Cu
.
reportError
(
"
Tried
to
move
an
unmovable
Places
"
+
"
node
reverting
to
a
copy
operation
.
"
)
;
}
canMove
=
false
;
}
if
(
doMove
&
&
canMove
)
{
canMove
=
canMoveUnwrappedNode
(
item
)
;
}
}
if
(
doMove
&
&
!
canMove
)
{
doMove
=
false
;
}
if
(
doMove
)
{
return
[
PlacesTransactions
.
Move
(
{
guids
:
items
.
map
(
item
=
>
item
.
itemGuid
)
newParentGuid
:
insertionParentGuid
newIndex
:
insertionIndex
}
)
]
;
}
return
getTransactionsForCopy
(
items
insertionIndex
insertionParentGuid
)
;
}
function
getTransactionsForCopy
(
items
insertionIndex
insertionParentGuid
)
{
let
transactions
=
[
]
;
let
index
=
insertionIndex
;
for
(
let
item
of
items
)
{
let
transaction
;
let
guid
=
item
.
itemGuid
;
if
(
PlacesUIUtils
.
PLACES_FLAVORS
.
includes
(
item
.
type
)
&
&
"
instanceId
"
in
item
&
&
item
.
instanceId
=
=
PlacesUtils
.
instanceId
&
&
guid
&
&
!
PlacesUtils
.
bookmarks
.
isVirtualRootItem
(
guid
)
&
&
!
PlacesUtils
.
isVirtualLeftPaneItem
(
guid
)
)
{
transaction
=
PlacesTransactions
.
Copy
(
{
excludingAnnotation
:
"
Places
/
SmartBookmark
"
guid
newIndex
:
index
newParentGuid
:
insertionParentGuid
}
)
;
}
else
if
(
item
.
type
=
=
PlacesUtils
.
TYPE_X_MOZ_PLACE_SEPARATOR
)
{
transaction
=
PlacesTransactions
.
NewSeparator
(
{
index
parentGuid
:
insertionParentGuid
}
)
;
}
else
{
let
title
=
item
.
type
!
=
PlacesUtils
.
TYPE_UNICODE
?
item
.
title
:
item
.
uri
;
transaction
=
PlacesTransactions
.
NewBookmark
(
{
index
parentGuid
:
insertionParentGuid
title
url
:
item
.
uri
}
)
;
}
transactions
.
push
(
transaction
)
;
if
(
index
!
=
-
1
)
{
index
+
+
;
}
}
return
transactions
;
}
function
getBrowserWindow
(
aWindow
)
{
return
aWindow
&
&
aWindow
.
document
.
documentElement
.
getAttribute
(
"
windowtype
"
)
=
=
"
navigator
:
browser
"
?
aWindow
:
BrowserWindowTracker
.
getTopWindow
(
)
;
}
