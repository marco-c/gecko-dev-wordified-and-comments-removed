var
EXPORTED_SYMBOLS
=
[
"
PlacesUIUtils
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
OpenInTabsUtils
:
"
resource
:
/
/
/
modules
/
OpenInTabsUtils
.
jsm
"
PlacesUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
PluralForm
:
"
resource
:
/
/
gre
/
modules
/
PluralForm
.
jsm
"
PrivateBrowsingUtils
:
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
RecentWindow
:
"
resource
:
/
/
/
modules
/
RecentWindow
.
jsm
"
PromiseUtils
:
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
PlacesTransactions
:
"
resource
:
/
/
gre
/
modules
/
PlacesTransactions
.
jsm
"
Weave
:
"
resource
:
/
/
services
-
sync
/
main
.
js
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
bundle
"
function
(
)
{
return
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
browser
/
locale
/
places
/
places
.
properties
"
)
;
}
)
;
const
gInContentProcess
=
Services
.
appinfo
.
processType
=
=
Ci
.
nsIXULRuntime
.
PROCESS_TYPE_CONTENT
;
const
FAVICON_REQUEST_TIMEOUT
=
60
*
1000
;
let
gFaviconLoadDataMap
=
new
Map
(
)
;
const
ITEM_CHANGED_BATCH_NOTIFICATION_THRESHOLD
=
10
;
const
TAB_DROP_TYPE
=
"
application
/
x
-
moz
-
tabbrowser
-
tab
"
;
const
PREF_LOAD_BOOKMARKS_IN_BACKGROUND
=
"
browser
.
tabs
.
loadBookmarksInBackground
"
;
const
PREF_LOAD_BOOKMARKS_IN_TABS
=
"
browser
.
tabs
.
loadBookmarksInTabs
"
;
let
InternalFaviconLoader
=
{
observe
(
subject
topic
data
)
{
let
innerWindowID
=
subject
.
QueryInterface
(
Ci
.
nsISupportsPRUint64
)
.
data
;
this
.
removeRequestsForInner
(
innerWindowID
)
;
}
_cancelRequest
(
{
uri
innerWindowID
timerID
callback
}
reason
)
{
let
request
=
callback
.
request
;
delete
callback
.
request
;
clearTimeout
(
timerID
)
;
try
{
request
.
cancel
(
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
"
When
cancelling
a
request
for
"
+
uri
.
spec
+
"
because
"
+
reason
+
"
it
was
already
canceled
!
"
)
;
}
}
removeRequestsForInner
(
innerID
)
{
for
(
let
[
window
loadDataForWindow
]
of
gFaviconLoadDataMap
)
{
let
newLoadDataForWindow
=
loadDataForWindow
.
filter
(
loadData
=
>
{
let
innerWasDestroyed
=
loadData
.
innerWindowID
=
=
innerID
;
if
(
innerWasDestroyed
)
{
this
.
_cancelRequest
(
loadData
"
the
inner
window
was
destroyed
or
a
new
favicon
was
loaded
for
it
"
)
;
}
return
!
innerWasDestroyed
;
}
)
;
gFaviconLoadDataMap
.
set
(
window
newLoadDataForWindow
)
;
}
}
onUnload
(
win
)
{
let
loadDataForWindow
=
gFaviconLoadDataMap
.
get
(
win
)
;
if
(
loadDataForWindow
)
{
for
(
let
loadData
of
loadDataForWindow
)
{
this
.
_cancelRequest
(
loadData
"
the
chrome
window
went
away
"
)
;
}
}
gFaviconLoadDataMap
.
delete
(
win
)
;
}
_removeLoadDataFromWindowMap
(
win
{
innerWindowID
uri
callback
}
)
{
let
loadDataForWindow
=
gFaviconLoadDataMap
.
get
(
win
)
;
if
(
loadDataForWindow
)
{
let
itemIndex
=
loadDataForWindow
.
findIndex
(
loadData
=
>
{
return
loadData
.
innerWindowID
=
=
innerWindowID
&
&
loadData
.
uri
.
equals
(
uri
)
&
&
loadData
.
callback
.
request
=
=
callback
.
request
;
}
)
;
if
(
itemIndex
!
=
-
1
)
{
let
loadData
=
loadDataForWindow
[
itemIndex
]
;
loadDataForWindow
.
splice
(
itemIndex
1
)
;
return
loadData
;
}
}
return
null
;
}
_makeCompletionCallback
(
win
id
)
{
return
{
onComplete
(
uri
)
{
let
loadData
=
InternalFaviconLoader
.
_removeLoadDataFromWindowMap
(
win
{
uri
innerWindowID
:
id
callback
:
this
}
)
;
if
(
loadData
)
{
clearTimeout
(
loadData
.
timerID
)
;
}
delete
this
.
request
;
}
}
;
}
ensureInitialized
(
)
{
if
(
this
.
_initialized
)
{
return
;
}
this
.
_initialized
=
true
;
Services
.
obs
.
addObserver
(
this
"
inner
-
window
-
destroyed
"
)
;
Services
.
ppmm
.
addMessageListener
(
"
Toolkit
:
inner
-
window
-
destroyed
"
msg
=
>
{
this
.
removeRequestsForInner
(
msg
.
data
)
;
}
)
;
}
loadFavicon
(
browser
principal
uri
requestContextID
)
{
this
.
ensureInitialized
(
)
;
let
win
=
browser
.
ownerGlobal
;
if
(
!
gFaviconLoadDataMap
.
has
(
win
)
)
{
gFaviconLoadDataMap
.
set
(
win
[
]
)
;
let
unloadHandler
=
event
=
>
{
let
doc
=
event
.
target
;
let
eventWin
=
doc
.
defaultView
;
if
(
eventWin
=
=
win
)
{
win
.
removeEventListener
(
"
unload
"
unloadHandler
)
;
this
.
onUnload
(
win
)
;
}
}
;
win
.
addEventListener
(
"
unload
"
unloadHandler
true
)
;
}
let
{
innerWindowID
currentURI
}
=
browser
;
let
loadType
=
PrivateBrowsingUtils
.
isWindowPrivate
(
win
)
?
PlacesUtils
.
favicons
.
FAVICON_LOAD_PRIVATE
:
PlacesUtils
.
favicons
.
FAVICON_LOAD_NON_PRIVATE
;
let
callback
=
this
.
_makeCompletionCallback
(
win
innerWindowID
)
;
let
request
=
PlacesUtils
.
favicons
.
setAndFetchFaviconForPage
(
currentURI
uri
false
loadType
callback
principal
requestContextID
)
;
if
(
!
request
)
{
return
;
}
callback
.
request
=
request
;
let
loadData
=
{
innerWindowID
uri
callback
}
;
loadData
.
timerID
=
setTimeout
(
(
)
=
>
{
this
.
_cancelRequest
(
loadData
"
it
timed
out
"
)
;
this
.
_removeLoadDataFromWindowMap
(
win
loadData
)
;
}
FAVICON_REQUEST_TIMEOUT
)
;
let
loadDataForWindow
=
gFaviconLoadDataMap
.
get
(
win
)
;
loadDataForWindow
.
push
(
loadData
)
;
}
}
;
var
PlacesUIUtils
=
{
ORGANIZER_LEFTPANE_VERSION
:
8
ORGANIZER_FOLDER_ANNO
:
"
PlacesOrganizer
/
OrganizerFolder
"
ORGANIZER_QUERY_ANNO
:
"
PlacesOrganizer
/
OrganizerQuery
"
LOAD_IN_SIDEBAR_ANNO
:
"
bookmarkProperties
/
loadInSidebar
"
DESCRIPTION_ANNO
:
"
bookmarkProperties
/
description
"
createFixedURI
:
function
PUIU_createFixedURI
(
aSpec
)
{
return
Services
.
uriFixup
.
createFixupURI
(
aSpec
Ci
.
nsIURIFixup
.
FIXUP_FLAG_NONE
)
;
}
getFormattedString
:
function
PUIU_getFormattedString
(
key
params
)
{
return
bundle
.
formatStringFromName
(
key
params
params
.
length
)
;
}
getPluralString
:
function
PUIU_getPluralString
(
aKey
aNumber
aParams
)
{
let
str
=
PluralForm
.
get
(
aNumber
bundle
.
GetStringFromName
(
aKey
)
)
;
return
str
.
replace
(
/
\
#
(
\
d
+
)
/
g
function
(
matchedId
matchedNumber
)
{
let
param
=
aParams
[
parseInt
(
matchedNumber
10
)
-
1
]
;
return
param
!
=
=
undefined
?
param
:
matchedId
;
}
)
;
}
getString
:
function
PUIU_getString
(
key
)
{
return
bundle
.
GetStringFromName
(
key
)
;
}
showBookmarkDialog
(
aInfo
aParentWindow
)
{
let
hasFolderPicker
=
!
(
"
hiddenRows
"
in
aInfo
)
|
|
!
aInfo
.
hiddenRows
.
includes
(
"
folderPicker
"
)
;
let
dialogURL
=
hasFolderPicker
?
"
chrome
:
/
/
browser
/
content
/
places
/
bookmarkProperties2
.
xul
"
:
"
chrome
:
/
/
browser
/
content
/
places
/
bookmarkProperties
.
xul
"
;
let
features
=
"
centerscreen
chrome
modal
resizable
=
yes
"
;
let
topUndoEntry
;
let
batchBlockingDeferred
;
topUndoEntry
=
PlacesTransactions
.
topUndoEntry
;
batchBlockingDeferred
=
PromiseUtils
.
defer
(
)
;
PlacesTransactions
.
batch
(
async
(
)
=
>
{
await
batchBlockingDeferred
.
promise
;
}
)
;
aParentWindow
.
openDialog
(
dialogURL
"
"
features
aInfo
)
;
let
performed
=
(
"
performed
"
in
aInfo
&
&
aInfo
.
performed
)
;
batchBlockingDeferred
.
resolve
(
)
;
if
(
!
performed
&
&
topUndoEntry
!
=
PlacesTransactions
.
topUndoEntry
)
{
PlacesTransactions
.
undo
(
)
.
catch
(
Cu
.
reportError
)
;
}
return
performed
;
}
loadFavicon
(
browser
principal
uri
requestContextID
)
{
if
(
gInContentProcess
)
{
throw
new
Error
(
"
Can
'
t
track
loads
from
within
the
child
process
!
"
)
;
}
InternalFaviconLoader
.
loadFavicon
(
browser
principal
uri
requestContextID
)
;
}
getViewForNode
:
function
PUIU_getViewForNode
(
aNode
)
{
let
node
=
aNode
;
if
(
node
.
localName
=
=
"
panelview
"
&
&
node
.
_placesView
)
{
return
node
.
_placesView
;
}
if
(
node
.
localName
=
=
"
menu
"
&
&
!
node
.
_placesNode
&
&
node
.
lastChild
.
_placesView
)
return
node
.
lastChild
.
_placesView
;
while
(
node
instanceof
Ci
.
nsIDOMElement
)
{
if
(
node
.
_placesView
)
return
node
.
_placesView
;
if
(
node
.
localName
=
=
"
tree
"
&
&
node
.
getAttribute
(
"
type
"
)
=
=
"
places
"
)
return
node
;
node
=
node
.
parentNode
;
}
return
null
;
}
getControllerForCommand
(
win
command
)
{
let
popupNode
;
try
{
popupNode
=
win
.
document
.
popupNode
;
}
catch
(
e
)
{
return
null
;
}
if
(
popupNode
)
{
let
view
=
this
.
getViewForNode
(
popupNode
)
;
if
(
view
&
&
view
.
_contextMenuShown
)
return
view
.
controllers
.
getControllerForCommand
(
command
)
;
}
let
controller
=
win
.
top
.
document
.
commandDispatcher
.
getControllerForCommand
(
command
)
;
return
controller
|
|
null
;
}
updateCommands
(
win
)
{
let
controller
=
this
.
getControllerForCommand
(
win
"
placesCmd_open
"
)
;
for
(
let
command
of
[
"
placesCmd_open
"
"
placesCmd_open
:
window
"
"
placesCmd_open
:
privatewindow
"
"
placesCmd_open
:
tab
"
"
placesCmd_new
:
folder
"
"
placesCmd_new
:
bookmark
"
"
placesCmd_new
:
separator
"
"
placesCmd_show
:
info
"
"
placesCmd_reload
"
"
placesCmd_sortBy
:
name
"
"
placesCmd_cut
"
"
placesCmd_copy
"
"
placesCmd_paste
"
"
placesCmd_delete
"
]
)
{
win
.
goSetCommandEnabled
(
command
controller
&
&
controller
.
isCommandEnabled
(
command
)
)
;
}
}
doCommand
(
win
command
)
{
let
controller
=
this
.
getControllerForCommand
(
win
command
)
;
if
(
controller
&
&
controller
.
isCommandEnabled
(
command
)
)
controller
.
doCommand
(
command
)
;
}
markPageAsTyped
:
function
PUIU_markPageAsTyped
(
aURL
)
{
PlacesUtils
.
history
.
markPageAsTyped
(
this
.
createFixedURI
(
aURL
)
)
;
}
markPageAsFollowedBookmark
:
function
PUIU_markPageAsFollowedBookmark
(
aURL
)
{
PlacesUtils
.
history
.
markPageAsFollowedBookmark
(
this
.
createFixedURI
(
aURL
)
)
;
}
markPageAsFollowedLink
:
function
PUIU_markPageAsFollowedLink
(
aURL
)
{
PlacesUtils
.
history
.
markPageAsFollowedLink
(
this
.
createFixedURI
(
aURL
)
)
;
}
checkURLSecurity
:
function
PUIU_checkURLSecurity
(
aURINode
aWindow
)
{
if
(
PlacesUtils
.
nodeIsBookmark
(
aURINode
)
)
return
true
;
var
uri
=
Services
.
io
.
newURI
(
aURINode
.
uri
)
;
if
(
uri
.
schemeIs
(
"
javascript
"
)
|
|
uri
.
schemeIs
(
"
data
"
)
)
{
const
BRANDING_BUNDLE_URI
=
"
chrome
:
/
/
branding
/
locale
/
brand
.
properties
"
;
var
brandShortName
=
Services
.
strings
.
createBundle
(
BRANDING_BUNDLE_URI
)
.
GetStringFromName
(
"
brandShortName
"
)
;
var
errorStr
=
this
.
getString
(
"
load
-
js
-
data
-
url
-
error
"
)
;
Services
.
prompt
.
alert
(
aWindow
brandShortName
errorStr
)
;
return
false
;
}
return
true
;
}
getDescriptionFromDocument
:
function
PUIU_getDescriptionFromDocument
(
doc
)
{
var
metaElements
=
doc
.
getElementsByTagName
(
"
META
"
)
;
for
(
var
i
=
0
;
i
<
metaElements
.
length
;
+
+
i
)
{
if
(
metaElements
[
i
]
.
name
.
toLowerCase
(
)
=
=
"
description
"
|
|
metaElements
[
i
]
.
httpEquiv
.
toLowerCase
(
)
=
=
"
description
"
)
{
return
metaElements
[
i
]
.
content
;
}
}
return
"
"
;
}
getItemDescription
:
function
PUIU_getItemDescription
(
aItemId
)
{
if
(
PlacesUtils
.
annotations
.
itemHasAnnotation
(
aItemId
this
.
DESCRIPTION_ANNO
)
)
return
PlacesUtils
.
annotations
.
getItemAnnotation
(
aItemId
this
.
DESCRIPTION_ANNO
)
;
return
"
"
;
}
canUserRemove
(
aNode
aView
)
{
let
parentNode
=
aNode
.
parent
;
if
(
!
parentNode
)
{
return
false
;
}
if
(
PlacesUtils
.
nodeIsQuery
(
parentNode
)
&
&
PlacesUtils
.
nodeIsFolder
(
aNode
)
)
{
let
guid
=
PlacesUtils
.
getConcreteItemGuid
(
aNode
)
;
if
(
PlacesUtils
.
isRootItem
(
guid
)
)
{
return
false
;
}
}
if
(
aNode
.
itemId
=
=
-
1
)
{
return
!
PlacesUtils
.
nodeIsFolder
(
parentNode
)
;
}
if
(
PlacesUtils
.
nodeIsQuery
(
parentNode
)
)
return
true
;
return
!
this
.
isFolderReadOnly
(
parentNode
aView
)
;
}
isFolderReadOnly
(
placesNode
view
)
{
if
(
typeof
placesNode
!
=
"
object
"
|
|
!
PlacesUtils
.
nodeIsFolder
(
placesNode
)
)
{
throw
new
Error
(
"
invalid
value
for
placesNode
"
)
;
}
if
(
!
view
|
|
typeof
view
!
=
"
object
"
)
{
throw
new
Error
(
"
invalid
value
for
aView
"
)
;
}
let
itemId
=
PlacesUtils
.
getConcreteItemId
(
placesNode
)
;
if
(
itemId
=
=
PlacesUtils
.
placesRootId
|
|
view
.
controller
.
hasCachedLivemarkInfo
(
placesNode
)
)
return
true
;
if
(
typeof
Object
.
getOwnPropertyDescriptor
(
this
"
leftPaneFolderId
"
)
.
get
=
=
"
function
"
)
{
return
false
;
}
return
itemId
=
=
this
.
leftPaneFolderId
;
}
_openTabset
:
function
PUIU__openTabset
(
aItemsToOpen
aEvent
aWindow
)
{
if
(
!
aItemsToOpen
.
length
)
return
;
var
browserWindow
=
null
;
browserWindow
=
aWindow
&
&
aWindow
.
document
.
documentElement
.
getAttribute
(
"
windowtype
"
)
=
=
"
navigator
:
browser
"
?
aWindow
:
RecentWindow
.
getMostRecentBrowserWindow
(
)
;
var
urls
=
[
]
;
let
skipMarking
=
browserWindow
&
&
PrivateBrowsingUtils
.
isWindowPrivate
(
browserWindow
)
;
for
(
let
item
of
aItemsToOpen
)
{
urls
.
push
(
item
.
uri
)
;
if
(
skipMarking
)
{
continue
;
}
if
(
item
.
isBookmark
)
this
.
markPageAsFollowedBookmark
(
item
.
uri
)
;
else
this
.
markPageAsTyped
(
item
.
uri
)
;
}
var
where
=
browserWindow
?
browserWindow
.
whereToOpenLink
(
aEvent
false
true
)
:
"
window
"
;
if
(
where
=
=
"
window
"
)
{
var
uriList
=
PlacesUtils
.
toISupportsString
(
urls
.
join
(
"
|
"
)
)
;
var
args
=
Cc
[
"
mozilla
.
org
/
array
;
1
"
]
.
createInstance
(
Ci
.
nsIMutableArray
)
;
args
.
appendElement
(
uriList
)
;
browserWindow
=
Services
.
ww
.
openWindow
(
aWindow
"
chrome
:
/
/
browser
/
content
/
browser
.
xul
"
null
"
chrome
dialog
=
no
all
"
args
)
;
return
;
}
var
loadInBackground
=
where
=
=
"
tabshifted
"
;
browserWindow
.
gBrowser
.
loadTabs
(
urls
{
inBackground
:
loadInBackground
replace
:
false
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
}
)
;
}
openLiveMarkNodesInTabs
:
function
PUIU_openLiveMarkNodesInTabs
(
aNode
aEvent
aView
)
{
let
window
=
aView
.
ownerWindow
;
PlacesUtils
.
livemarks
.
getLivemark
(
{
id
:
aNode
.
itemId
}
)
.
then
(
aLivemark
=
>
{
let
urlsToOpen
=
[
]
;
let
nodes
=
aLivemark
.
getNodesForContainer
(
aNode
)
;
for
(
let
node
of
nodes
)
{
urlsToOpen
.
push
(
{
uri
:
node
.
uri
isBookmark
:
false
}
)
;
}
if
(
OpenInTabsUtils
.
confirmOpenInTabs
(
urlsToOpen
.
length
window
)
)
{
this
.
_openTabset
(
urlsToOpen
aEvent
window
)
;
}
}
Cu
.
reportError
)
;
}
openContainerNodeInTabs
:
function
PUIU_openContainerInTabs
(
aNode
aEvent
aView
)
{
let
window
=
aView
.
ownerWindow
;
let
urlsToOpen
=
PlacesUtils
.
getURLsForContainerNode
(
aNode
)
;
if
(
OpenInTabsUtils
.
confirmOpenInTabs
(
urlsToOpen
.
length
window
)
)
{
this
.
_openTabset
(
urlsToOpen
aEvent
window
)
;
}
}
openURINodesInTabs
:
function
PUIU_openURINodesInTabs
(
aNodes
aEvent
aView
)
{
let
window
=
aView
.
ownerWindow
;
let
urlsToOpen
=
[
]
;
for
(
var
i
=
0
;
i
<
aNodes
.
length
;
i
+
+
)
{
if
(
PlacesUtils
.
nodeIsURI
(
aNodes
[
i
]
)
)
urlsToOpen
.
push
(
{
uri
:
aNodes
[
i
]
.
uri
isBookmark
:
PlacesUtils
.
nodeIsBookmark
(
aNodes
[
i
]
)
}
)
;
}
this
.
_openTabset
(
urlsToOpen
aEvent
window
)
;
}
openNodeWithEvent
:
function
PUIU_openNodeWithEvent
(
aNode
aEvent
)
{
let
window
=
aEvent
.
target
.
ownerGlobal
;
let
where
=
window
.
whereToOpenLink
(
aEvent
false
true
)
;
if
(
where
=
=
"
current
"
&
&
this
.
loadBookmarksInTabs
&
&
PlacesUtils
.
nodeIsBookmark
(
aNode
)
&
&
!
aNode
.
uri
.
startsWith
(
"
javascript
:
"
)
)
{
where
=
"
tab
"
;
}
this
.
_openNodeIn
(
aNode
where
window
)
;
let
view
=
this
.
getViewForNode
(
aEvent
.
target
)
;
if
(
view
&
&
view
.
controller
.
hasCachedLivemarkInfo
(
aNode
.
parent
)
)
{
Services
.
telemetry
.
scalarAdd
(
"
browser
.
feeds
.
livebookmark_item_opened
"
1
)
;
}
}
openNodeIn
:
function
PUIU_openNodeIn
(
aNode
aWhere
aView
aPrivate
)
{
let
window
=
aView
.
ownerWindow
;
this
.
_openNodeIn
(
aNode
aWhere
window
aPrivate
)
;
}
_openNodeIn
:
function
PUIU__openNodeIn
(
aNode
aWhere
aWindow
aPrivate
=
false
)
{
if
(
aNode
&
&
PlacesUtils
.
nodeIsURI
(
aNode
)
&
&
this
.
checkURLSecurity
(
aNode
aWindow
)
)
{
let
isBookmark
=
PlacesUtils
.
nodeIsBookmark
(
aNode
)
;
if
(
!
PrivateBrowsingUtils
.
isWindowPrivate
(
aWindow
)
)
{
if
(
isBookmark
)
this
.
markPageAsFollowedBookmark
(
aNode
.
uri
)
;
else
this
.
markPageAsTyped
(
aNode
.
uri
)
;
}
if
(
aWhere
=
=
"
current
"
&
&
isBookmark
)
{
if
(
PlacesUtils
.
annotations
.
itemHasAnnotation
(
aNode
.
itemId
this
.
LOAD_IN_SIDEBAR_ANNO
)
)
{
let
browserWin
=
RecentWindow
.
getMostRecentBrowserWindow
(
)
;
if
(
browserWin
)
{
browserWin
.
openWebPanel
(
aNode
.
title
aNode
.
uri
)
;
return
;
}
}
}
aWindow
.
openUILinkIn
(
aNode
.
uri
aWhere
{
allowPopups
:
aNode
.
uri
.
startsWith
(
"
javascript
:
"
)
inBackground
:
this
.
loadBookmarksInBackground
private
:
aPrivate
}
)
;
}
}
guessUrlSchemeForUI
:
function
PUIU_guessUrlSchemeForUI
(
aUrlString
)
{
return
aUrlString
.
substr
(
0
aUrlString
.
indexOf
(
"
:
"
)
)
;
}
getBestTitle
:
function
PUIU_getBestTitle
(
aNode
aDoNotCutTitle
)
{
var
title
;
if
(
!
aNode
.
title
&
&
PlacesUtils
.
nodeIsURI
(
aNode
)
)
{
try
{
var
uri
=
Services
.
io
.
newURI
(
aNode
.
uri
)
;
var
host
=
uri
.
host
;
var
fileName
=
uri
.
QueryInterface
(
Ci
.
nsIURL
)
.
fileName
;
if
(
aDoNotCutTitle
)
{
title
=
host
+
uri
.
pathQueryRef
;
}
else
{
title
=
host
+
(
fileName
?
(
host
?
"
/
"
+
this
.
ellipsis
+
"
/
"
:
"
"
)
+
fileName
:
uri
.
pathQueryRef
)
;
}
}
catch
(
e
)
{
title
=
"
"
;
}
}
else
title
=
aNode
.
title
;
return
title
|
|
this
.
getString
(
"
noTitle
"
)
;
}
get
leftPaneQueries
(
)
{
this
.
leftPaneFolderId
;
return
this
.
leftPaneQueries
;
}
get
leftPaneFolderId
(
)
{
delete
this
.
leftPaneFolderId
;
return
this
.
leftPaneFolderId
=
this
.
maybeRebuildLeftPane
(
)
;
}
maybeRebuildLeftPane
(
)
{
let
leftPaneRoot
=
-
1
;
let
bs
=
PlacesUtils
.
bookmarks
;
let
as
=
PlacesUtils
.
annotations
;
let
queries
=
{
"
PlacesRoot
"
:
{
title
:
"
"
}
"
History
"
:
{
title
:
this
.
getString
(
"
OrganizerQueryHistory
"
)
}
"
Downloads
"
:
{
title
:
this
.
getString
(
"
OrganizerQueryDownloads
"
)
}
"
Tags
"
:
{
title
:
this
.
getString
(
"
OrganizerQueryTags
"
)
}
"
AllBookmarks
"
:
{
title
:
this
.
getString
(
"
OrganizerQueryAllBookmarks
"
)
}
}
;
const
EXPECTED_QUERY_COUNT
=
4
;
function
safeRemoveItem
(
aItemId
)
{
try
{
if
(
as
.
itemHasAnnotation
(
aItemId
PlacesUIUtils
.
ORGANIZER_QUERY_ANNO
)
&
&
!
(
as
.
getItemAnnotation
(
aItemId
PlacesUIUtils
.
ORGANIZER_QUERY_ANNO
)
in
queries
)
)
{
return
;
}
as
.
removeItemAnnotation
(
aItemId
PlacesUIUtils
.
ORGANIZER_FOLDER_ANNO
)
;
as
.
removeItemAnnotation
(
aItemId
PlacesUIUtils
.
ORGANIZER_QUERY_ANNO
)
;
bs
.
removeItem
(
aItemId
)
;
}
catch
(
e
)
{
}
}
function
itemExists
(
aItemId
)
{
try
{
bs
.
getFolderIdForItem
(
aItemId
)
;
return
true
;
}
catch
(
e
)
{
return
false
;
}
}
let
items
=
as
.
getItemsWithAnnotation
(
this
.
ORGANIZER_FOLDER_ANNO
)
;
if
(
items
.
length
>
1
)
{
items
.
forEach
(
safeRemoveItem
)
;
}
else
if
(
items
.
length
=
=
1
&
&
items
[
0
]
!
=
-
1
)
{
leftPaneRoot
=
items
[
0
]
;
let
version
=
as
.
getItemAnnotation
(
leftPaneRoot
this
.
ORGANIZER_FOLDER_ANNO
)
;
if
(
version
!
=
this
.
ORGANIZER_LEFTPANE_VERSION
|
|
!
itemExists
(
leftPaneRoot
)
)
{
safeRemoveItem
(
leftPaneRoot
)
;
leftPaneRoot
=
-
1
;
}
}
if
(
leftPaneRoot
!
=
-
1
)
{
delete
this
.
leftPaneQueries
;
this
.
leftPaneQueries
=
{
}
;
let
queryItems
=
as
.
getItemsWithAnnotation
(
this
.
ORGANIZER_QUERY_ANNO
)
;
let
queriesCount
=
0
;
let
corrupt
=
false
;
for
(
let
i
=
0
;
i
<
queryItems
.
length
;
i
+
+
)
{
let
queryName
=
as
.
getItemAnnotation
(
queryItems
[
i
]
this
.
ORGANIZER_QUERY_ANNO
)
;
if
(
!
(
queryName
in
queries
)
)
continue
;
let
query
=
queries
[
queryName
]
;
query
.
itemId
=
queryItems
[
i
]
;
if
(
!
itemExists
(
query
.
itemId
)
)
{
corrupt
=
true
;
break
;
}
let
parentId
=
bs
.
getFolderIdForItem
(
query
.
itemId
)
;
if
(
!
queryItems
.
includes
(
parentId
)
&
&
parentId
!
=
leftPaneRoot
)
{
corrupt
=
true
;
break
;
}
if
(
bs
.
getItemTitle
(
query
.
itemId
)
!
=
query
.
title
)
bs
.
setItemTitle
(
query
.
itemId
query
.
title
)
;
if
(
"
concreteId
"
in
query
)
{
if
(
bs
.
getItemTitle
(
query
.
concreteId
)
!
=
query
.
concreteTitle
)
bs
.
setItemTitle
(
query
.
concreteId
query
.
concreteTitle
)
;
}
this
.
leftPaneQueries
[
queryName
]
=
query
.
itemId
;
queriesCount
+
+
;
}
if
(
corrupt
|
|
queriesCount
!
=
EXPECTED_QUERY_COUNT
)
{
queryItems
.
forEach
(
safeRemoveItem
)
;
safeRemoveItem
(
leftPaneRoot
)
;
}
else
{
return
leftPaneRoot
;
}
}
var
callback
=
{
create_query
:
function
CB_create_query
(
aQueryName
aParentId
aQueryUrl
)
{
let
itemId
=
bs
.
insertBookmark
(
aParentId
Services
.
io
.
newURI
(
aQueryUrl
)
bs
.
DEFAULT_INDEX
queries
[
aQueryName
]
.
title
)
;
as
.
setItemAnnotation
(
itemId
PlacesUIUtils
.
ORGANIZER_QUERY_ANNO
aQueryName
0
as
.
EXPIRE_NEVER
)
;
as
.
setItemAnnotation
(
itemId
PlacesUtils
.
EXCLUDE_FROM_BACKUP_ANNO
1
0
as
.
EXPIRE_NEVER
)
;
PlacesUIUtils
.
leftPaneQueries
[
aQueryName
]
=
itemId
;
return
itemId
;
}
create_folder
:
function
CB_create_folder
(
aFolderName
aParentId
aIsRoot
)
{
let
folderId
=
bs
.
createFolder
(
aParentId
queries
[
aFolderName
]
.
title
bs
.
DEFAULT_INDEX
)
;
as
.
setItemAnnotation
(
folderId
PlacesUtils
.
EXCLUDE_FROM_BACKUP_ANNO
1
0
as
.
EXPIRE_NEVER
)
;
if
(
aIsRoot
)
{
as
.
setItemAnnotation
(
folderId
PlacesUIUtils
.
ORGANIZER_FOLDER_ANNO
PlacesUIUtils
.
ORGANIZER_LEFTPANE_VERSION
0
as
.
EXPIRE_NEVER
)
;
}
else
{
as
.
setItemAnnotation
(
folderId
PlacesUIUtils
.
ORGANIZER_QUERY_ANNO
aFolderName
0
as
.
EXPIRE_NEVER
)
;
PlacesUIUtils
.
leftPaneQueries
[
aFolderName
]
=
folderId
;
}
return
folderId
;
}
runBatched
:
function
CB_runBatched
(
aUserData
)
{
delete
PlacesUIUtils
.
leftPaneQueries
;
PlacesUIUtils
.
leftPaneQueries
=
{
}
;
leftPaneRoot
=
this
.
create_folder
(
"
PlacesRoot
"
bs
.
placesRoot
true
)
;
this
.
create_query
(
"
History
"
leftPaneRoot
"
place
:
type
=
"
+
Ci
.
nsINavHistoryQueryOptions
.
RESULTS_AS_DATE_QUERY
+
"
&
sort
=
"
+
Ci
.
nsINavHistoryQueryOptions
.
SORT_BY_DATE_DESCENDING
)
;
this
.
create_query
(
"
Downloads
"
leftPaneRoot
"
place
:
transition
=
"
+
Ci
.
nsINavHistoryService
.
TRANSITION_DOWNLOAD
+
"
&
sort
=
"
+
Ci
.
nsINavHistoryQueryOptions
.
SORT_BY_DATE_DESCENDING
)
;
this
.
create_query
(
"
Tags
"
leftPaneRoot
"
place
:
type
=
"
+
Ci
.
nsINavHistoryQueryOptions
.
RESULTS_AS_TAG_QUERY
+
"
&
sort
=
"
+
Ci
.
nsINavHistoryQueryOptions
.
SORT_BY_TITLE_ASCENDING
)
;
this
.
create_query
(
"
AllBookmarks
"
leftPaneRoot
"
place
:
type
=
"
+
Ci
.
nsINavHistoryQueryOptions
.
RESULTS_AS_ROOTS_QUERY
)
;
}
}
;
bs
.
runInBatchMode
(
callback
null
)
;
return
leftPaneRoot
;
}
getLeftPaneQueryNameFromId
:
function
PUIU_getLeftPaneQueryNameFromId
(
aItemId
)
{
var
queryName
=
"
"
;
if
(
Object
.
getOwnPropertyDescriptor
(
this
"
leftPaneFolderId
"
)
.
value
=
=
=
undefined
)
{
try
{
queryName
=
PlacesUtils
.
annotations
.
getItemAnnotation
(
aItemId
this
.
ORGANIZER_QUERY_ANNO
)
;
}
catch
(
ex
)
{
queryName
=
"
"
;
}
}
else
{
for
(
let
[
name
id
]
of
Object
.
entries
(
this
.
leftPaneQueries
)
)
{
if
(
aItemId
=
=
id
)
queryName
=
name
;
}
}
return
queryName
;
}
shouldShowTabsFromOtherComputersMenuitem
(
)
{
let
weaveOK
=
Weave
.
Status
.
checkSetup
(
)
!
=
Weave
.
CLIENT_NOT_CONFIGURED
&
&
Weave
.
Svc
.
Prefs
.
get
(
"
firstSync
"
"
"
)
!
=
"
notReady
"
;
return
weaveOK
;
}
isFolderShortcutQueryString
(
queryString
)
{
let
queriesParam
=
{
}
optionsParam
=
{
}
;
PlacesUtils
.
history
.
queryStringToQueries
(
queryString
queriesParam
{
}
optionsParam
)
;
let
queries
=
queries
.
value
;
if
(
queries
.
length
=
=
0
)
throw
new
Error
(
Invalid
place
:
uri
:
{
queryString
}
)
;
return
queries
.
length
=
=
1
&
&
queries
[
0
]
.
folderCount
=
=
1
&
&
!
queries
[
0
]
.
hasBeginTime
&
&
!
queries
[
0
]
.
hasEndTime
&
&
!
queries
[
0
]
.
hasDomain
&
&
!
queries
[
0
]
.
hasURI
&
&
!
queries
[
0
]
.
hasSearchTerms
&
&
!
queries
[
0
]
.
tags
.
length
=
=
0
&
&
optionsParam
.
value
.
maxResults
=
=
0
;
}
async
promiseNodeLikeFromFetchInfo
(
aFetchInfo
)
{
if
(
aFetchInfo
.
itemType
=
=
PlacesUtils
.
bookmarks
.
TYPE_SEPARATOR
)
throw
new
Error
(
"
promiseNodeLike
doesn
'
t
support
separators
"
)
;
let
parent
=
{
itemId
:
await
PlacesUtils
.
promiseItemId
(
aFetchInfo
.
parentGuid
)
bookmarkGuid
:
aFetchInfo
.
parentGuid
type
:
Ci
.
nsINavHistoryResultNode
.
RESULT_TYPE_FOLDER
}
;
return
Object
.
freeze
(
{
itemId
:
await
PlacesUtils
.
promiseItemId
(
aFetchInfo
.
guid
)
bookmarkGuid
:
aFetchInfo
.
guid
title
:
aFetchInfo
.
title
uri
:
aFetchInfo
.
url
!
=
=
undefined
?
aFetchInfo
.
url
.
href
:
"
"
get
type
(
)
{
if
(
aFetchInfo
.
itemType
=
=
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
)
return
Ci
.
nsINavHistoryResultNode
.
RESULT_TYPE_FOLDER
;
if
(
this
.
uri
.
length
=
=
0
)
throw
new
Error
(
"
Unexpected
item
type
"
)
;
if
(
/
^
place
:
/
.
test
(
this
.
uri
)
)
{
if
(
this
.
isFolderShortcutQueryString
(
this
.
uri
)
)
return
Ci
.
nsINavHistoryResultNode
.
RESULT_TYPE_FOLDER_SHORTCUT
;
return
Ci
.
nsINavHistoryResultNode
.
RESULT_TYPE_QUERY
;
}
return
Ci
.
nsINavHistoryResultNode
.
RESULT_TYPE_URI
;
}
get
parent
(
)
{
return
parent
;
}
}
)
;
}
async
batchUpdatesForNode
(
resultNode
itemsBeingChanged
functionToWrap
)
{
if
(
!
resultNode
)
{
await
functionToWrap
(
)
;
return
;
}
resultNode
=
resultNode
.
QueryInterface
(
Ci
.
nsINavBookmarkObserver
)
;
if
(
itemsBeingChanged
>
ITEM_CHANGED_BATCH_NOTIFICATION_THRESHOLD
)
{
resultNode
.
onBeginUpdateBatch
(
)
;
}
try
{
await
functionToWrap
(
)
;
}
finally
{
if
(
itemsBeingChanged
>
ITEM_CHANGED_BATCH_NOTIFICATION_THRESHOLD
)
{
resultNode
.
onEndUpdateBatch
(
)
;
}
}
}
getTransactionForData
(
aData
aNewParentGuid
aIndex
aCopy
)
{
if
(
!
this
.
SUPPORTED_FLAVORS
.
includes
(
aData
.
type
)
)
throw
new
Error
(
Unsupported
'
{
aData
.
type
}
'
data
type
)
;
if
(
"
itemGuid
"
in
aData
&
&
"
instanceId
"
in
aData
&
&
aData
.
instanceId
=
=
PlacesUtils
.
instanceId
)
{
if
(
!
this
.
PLACES_FLAVORS
.
includes
(
aData
.
type
)
)
throw
new
Error
(
itemGuid
unexpectedly
set
on
{
aData
.
type
}
data
)
;
let
info
=
{
guid
:
aData
.
itemGuid
newParentGuid
:
aNewParentGuid
newIndex
:
aIndex
}
;
if
(
aCopy
)
{
info
.
excludingAnnotation
=
"
Places
/
SmartBookmark
"
;
return
PlacesTransactions
.
Copy
(
info
)
;
}
return
PlacesTransactions
.
Move
(
info
)
;
}
if
(
aData
.
type
=
=
PlacesUtils
.
TYPE_X_MOZ_PLACE_CONTAINER
)
throw
new
Error
(
"
Can
'
t
copy
a
container
from
a
legacy
-
transactions
build
"
)
;
if
(
aData
.
type
=
=
PlacesUtils
.
TYPE_X_MOZ_PLACE_SEPARATOR
)
{
return
PlacesTransactions
.
NewSeparator
(
{
parentGuid
:
aNewParentGuid
index
:
aIndex
}
)
;
}
let
title
=
aData
.
type
!
=
PlacesUtils
.
TYPE_UNICODE
?
aData
.
title
:
aData
.
uri
;
return
PlacesTransactions
.
NewBookmark
(
{
url
:
Services
.
io
.
newURI
(
aData
.
uri
)
title
parentGuid
:
aNewParentGuid
index
:
aIndex
}
)
;
}
async
handleTransferItems
(
items
insertionPoint
doCopy
view
)
{
let
transactions
;
let
itemsCount
;
if
(
insertionPoint
.
isTag
)
{
let
urls
=
items
.
filter
(
item
=
>
"
uri
"
in
item
)
.
map
(
item
=
>
item
.
uri
)
;
itemsCount
=
urls
.
length
;
transactions
=
[
PlacesTransactions
.
Tag
(
{
urls
tag
:
insertionPoint
.
tagName
}
)
]
;
}
else
{
let
insertionIndex
=
await
insertionPoint
.
getIndex
(
)
;
itemsCount
=
items
.
length
;
transactions
=
await
getTransactionsForTransferItems
(
items
insertionIndex
insertionPoint
.
guid
doCopy
)
;
}
if
(
!
transactions
.
length
)
{
return
[
]
;
}
let
guidsToSelect
=
[
]
;
let
resultForBatching
=
getResultForBatching
(
view
)
;
let
batchingItem
=
transactions
;
if
(
!
insertionPoint
.
isTag
)
{
batchingItem
=
async
(
)
=
>
{
for
(
let
transaction
of
transactions
)
{
let
guid
=
await
transaction
.
transact
(
)
;
if
(
guid
)
{
guidsToSelect
.
push
(
guid
)
;
}
}
}
;
}
await
this
.
batchUpdatesForNode
(
resultForBatching
itemsCount
async
(
)
=
>
{
await
PlacesTransactions
.
batch
(
batchingItem
)
;
}
)
;
return
guidsToSelect
;
}
}
;
XPCOMUtils
.
defineLazyGetter
(
PlacesUIUtils
"
PLACES_FLAVORS
"
(
)
=
>
{
return
[
PlacesUtils
.
TYPE_X_MOZ_PLACE_CONTAINER
PlacesUtils
.
TYPE_X_MOZ_PLACE_SEPARATOR
PlacesUtils
.
TYPE_X_MOZ_PLACE
]
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
PlacesUIUtils
"
URI_FLAVORS
"
(
)
=
>
{
return
[
PlacesUtils
.
TYPE_X_MOZ_URL
TAB_DROP_TYPE
PlacesUtils
.
TYPE_UNICODE
]
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
PlacesUIUtils
"
SUPPORTED_FLAVORS
"
(
)
=
>
{
return
[
.
.
.
PlacesUIUtils
.
PLACES_FLAVORS
.
.
.
PlacesUIUtils
.
URI_FLAVORS
]
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
PlacesUIUtils
"
ellipsis
"
function
(
)
{
return
Services
.
prefs
.
getComplexValue
(
"
intl
.
ellipsis
"
Ci
.
nsIPrefLocalizedString
)
.
data
;
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
PlacesUIUtils
"
loadBookmarksInBackground
"
PREF_LOAD_BOOKMARKS_IN_BACKGROUND
false
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
PlacesUIUtils
"
loadBookmarksInTabs
"
PREF_LOAD_BOOKMARKS_IN_TABS
false
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
PlacesUIUtils
"
openInTabClosesMenu
"
"
browser
.
bookmarks
.
openInTabClosesMenu
"
false
)
;
function
canMoveUnwrappedNode
(
unwrappedNode
)
{
if
(
(
unwrappedNode
.
concreteGuid
&
&
PlacesUtils
.
isRootItem
(
unwrappedNode
.
concreteGuid
)
)
|
|
unwrappedNode
.
id
<
=
0
|
|
PlacesUtils
.
isRootItem
(
unwrappedNode
.
id
)
)
{
return
false
;
}
let
parentGuid
=
unwrappedNode
.
parentGuid
;
if
(
!
parentGuid
|
|
parentGuid
=
=
PlacesUtils
.
bookmarks
.
rootGuid
)
{
return
false
;
}
if
(
typeof
Object
.
getOwnPropertyDescriptor
(
PlacesUIUtils
"
leftPaneFolderId
"
)
.
get
!
=
"
function
"
&
&
(
unwrappedNode
.
parent
=
=
PlacesUIUtils
.
leftPaneFolderId
)
)
{
return
false
;
}
return
true
;
}
function
getResultForBatching
(
viewOrElement
)
{
if
(
viewOrElement
&
&
viewOrElement
instanceof
Ci
.
nsIDOMElement
&
&
viewOrElement
.
id
=
=
=
"
placesList
"
)
{
viewOrElement
=
viewOrElement
.
ownerDocument
.
getElementById
(
"
placeContent
"
)
|
|
viewOrElement
;
}
if
(
viewOrElement
&
&
viewOrElement
.
result
)
{
return
viewOrElement
.
result
;
}
return
null
;
}
async
function
getTransactionsForTransferItems
(
items
insertionIndex
insertionParentGuid
doCopy
)
{
let
transactions
=
[
]
;
let
index
=
insertionIndex
;
for
(
let
item
of
items
)
{
if
(
index
!
=
-
1
&
&
item
.
itemGuid
)
{
let
existingBookmark
=
await
PlacesUtils
.
bookmarks
.
fetch
(
item
.
itemGuid
)
;
if
(
existingBookmark
&
&
insertionParentGuid
=
=
existingBookmark
.
parentGuid
)
{
if
(
index
>
existingBookmark
.
index
)
{
index
-
-
;
}
else
if
(
index
=
=
existingBookmark
.
index
)
{
continue
;
}
}
}
if
(
!
doCopy
&
&
!
canMoveUnwrappedNode
(
item
)
)
{
Cu
.
reportError
(
"
Tried
to
move
an
unmovable
Places
"
+
"
node
reverting
to
a
copy
operation
.
"
)
;
doCopy
=
true
;
}
transactions
.
push
(
PlacesUIUtils
.
getTransactionForData
(
item
insertionParentGuid
index
doCopy
)
)
;
if
(
index
!
=
-
1
&
&
item
.
itemGuid
)
{
index
+
+
;
}
}
return
transactions
;
}
