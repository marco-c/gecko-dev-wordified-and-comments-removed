var
EXPORTED_SYMBOLS
=
[
"
PlacesUIUtils
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
clearTimeout
setTimeout
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
BrowserWindowTracker
:
"
resource
:
/
/
/
modules
/
BrowserWindowTracker
.
jsm
"
CustomizableUI
:
"
resource
:
/
/
/
modules
/
CustomizableUI
.
jsm
"
MigrationUtils
:
"
resource
:
/
/
/
modules
/
MigrationUtils
.
jsm
"
OpenInTabsUtils
:
"
resource
:
/
/
/
modules
/
OpenInTabsUtils
.
jsm
"
PlacesTransactions
:
"
resource
:
/
/
gre
/
modules
/
PlacesTransactions
.
jsm
"
PlacesUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
PluralForm
:
"
resource
:
/
/
gre
/
modules
/
PluralForm
.
jsm
"
PrivateBrowsingUtils
:
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
PromiseUtils
:
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
Weave
:
"
resource
:
/
/
services
-
sync
/
main
.
js
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
bundle
"
function
(
)
{
return
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
browser
/
locale
/
places
/
places
.
properties
"
)
;
}
)
;
const
gInContentProcess
=
Services
.
appinfo
.
processType
=
=
Ci
.
nsIXULRuntime
.
PROCESS_TYPE_CONTENT
;
const
FAVICON_REQUEST_TIMEOUT
=
60
*
1000
;
let
gFaviconLoadDataMap
=
new
Map
(
)
;
const
ITEM_CHANGED_BATCH_NOTIFICATION_THRESHOLD
=
10
;
const
TAB_DROP_TYPE
=
"
application
/
x
-
moz
-
tabbrowser
-
tab
"
;
let
InternalFaviconLoader
=
{
_cancelRequest
(
{
uri
innerWindowID
timerID
callback
}
reason
)
{
let
request
=
callback
.
request
;
delete
callback
.
request
;
clearTimeout
(
timerID
)
;
try
{
request
.
cancel
(
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
"
When
cancelling
a
request
for
"
+
uri
.
spec
+
"
because
"
+
reason
+
"
it
was
already
canceled
!
"
)
;
}
}
removeRequestsForInner
(
innerID
)
{
for
(
let
[
window
loadDataForWindow
]
of
gFaviconLoadDataMap
)
{
let
newLoadDataForWindow
=
loadDataForWindow
.
filter
(
loadData
=
>
{
let
innerWasDestroyed
=
loadData
.
innerWindowID
=
=
innerID
;
if
(
innerWasDestroyed
)
{
this
.
_cancelRequest
(
loadData
"
the
inner
window
was
destroyed
or
a
new
favicon
was
loaded
for
it
"
)
;
}
return
!
innerWasDestroyed
;
}
)
;
gFaviconLoadDataMap
.
set
(
window
newLoadDataForWindow
)
;
}
}
onUnload
(
win
)
{
let
loadDataForWindow
=
gFaviconLoadDataMap
.
get
(
win
)
;
if
(
loadDataForWindow
)
{
for
(
let
loadData
of
loadDataForWindow
)
{
this
.
_cancelRequest
(
loadData
"
the
chrome
window
went
away
"
)
;
}
}
gFaviconLoadDataMap
.
delete
(
win
)
;
}
_removeLoadDataFromWindowMap
(
win
{
innerWindowID
uri
callback
}
)
{
let
loadDataForWindow
=
gFaviconLoadDataMap
.
get
(
win
)
;
if
(
loadDataForWindow
)
{
let
itemIndex
=
loadDataForWindow
.
findIndex
(
loadData
=
>
{
return
(
loadData
.
innerWindowID
=
=
innerWindowID
&
&
loadData
.
uri
.
equals
(
uri
)
&
&
loadData
.
callback
.
request
=
=
callback
.
request
)
;
}
)
;
if
(
itemIndex
!
=
-
1
)
{
let
loadData
=
loadDataForWindow
[
itemIndex
]
;
loadDataForWindow
.
splice
(
itemIndex
1
)
;
return
loadData
;
}
}
return
null
;
}
_makeCompletionCallback
(
win
id
)
{
return
{
onComplete
(
uri
)
{
let
loadData
=
InternalFaviconLoader
.
_removeLoadDataFromWindowMap
(
win
{
uri
innerWindowID
:
id
callback
:
this
}
)
;
if
(
loadData
)
{
clearTimeout
(
loadData
.
timerID
)
;
}
delete
this
.
request
;
}
}
;
}
ensureInitialized
(
)
{
if
(
this
.
_initialized
)
{
return
;
}
this
.
_initialized
=
true
;
Services
.
obs
.
addObserver
(
windowGlobal
=
>
{
this
.
removeRequestsForInner
(
windowGlobal
.
innerWindowId
)
;
}
"
window
-
global
-
destroyed
"
)
;
}
loadFavicon
(
browser
principal
pageURI
uri
expiration
iconURI
)
{
this
.
ensureInitialized
(
)
;
let
{
ownerGlobal
:
win
innerWindowID
}
=
browser
;
if
(
!
gFaviconLoadDataMap
.
has
(
win
)
)
{
gFaviconLoadDataMap
.
set
(
win
[
]
)
;
let
unloadHandler
=
event
=
>
{
let
doc
=
event
.
target
;
let
eventWin
=
doc
.
defaultView
;
if
(
eventWin
=
=
win
)
{
win
.
removeEventListener
(
"
unload
"
unloadHandler
)
;
this
.
onUnload
(
win
)
;
}
}
;
win
.
addEventListener
(
"
unload
"
unloadHandler
true
)
;
}
let
loadType
=
lazy
.
PrivateBrowsingUtils
.
isWindowPrivate
(
win
)
?
lazy
.
PlacesUtils
.
favicons
.
FAVICON_LOAD_PRIVATE
:
lazy
.
PlacesUtils
.
favicons
.
FAVICON_LOAD_NON_PRIVATE
;
let
callback
=
this
.
_makeCompletionCallback
(
win
innerWindowID
)
;
if
(
iconURI
&
&
iconURI
.
schemeIs
(
"
data
"
)
)
{
expiration
=
lazy
.
PlacesUtils
.
toPRTime
(
expiration
)
;
lazy
.
PlacesUtils
.
favicons
.
replaceFaviconDataFromDataURL
(
uri
iconURI
.
spec
expiration
principal
)
;
}
let
request
=
lazy
.
PlacesUtils
.
favicons
.
setAndFetchFaviconForPage
(
pageURI
uri
false
loadType
callback
principal
)
;
if
(
!
request
)
{
return
;
}
callback
.
request
=
request
;
let
loadData
=
{
innerWindowID
uri
callback
}
;
loadData
.
timerID
=
setTimeout
(
(
)
=
>
{
this
.
_cancelRequest
(
loadData
"
it
timed
out
"
)
;
this
.
_removeLoadDataFromWindowMap
(
win
loadData
)
;
}
FAVICON_REQUEST_TIMEOUT
)
;
let
loadDataForWindow
=
gFaviconLoadDataMap
.
get
(
win
)
;
loadDataForWindow
.
push
(
loadData
)
;
}
}
;
class
BookmarkState
{
constructor
(
info
tags
=
"
"
keyword
=
"
"
)
{
this
.
_guid
=
info
.
itemGuid
;
this
.
_postData
=
info
.
postData
;
this
.
_isTagContainer
=
info
.
isTag
;
this
.
_originalState
=
{
title
:
this
.
_isTagContainer
?
info
.
tag
:
info
.
title
uri
:
info
.
uri
?
.
spec
tags
:
tags
.
trim
(
)
.
split
(
/
\
s
*
\
s
*
/
)
.
filter
(
tag
=
>
!
!
tag
.
length
)
keyword
parentGuid
:
info
.
parentGuid
}
;
this
.
_newState
=
{
}
;
}
_titleChanged
(
title
)
{
this
.
_newState
.
title
=
title
;
}
_locationChanged
(
location
)
{
this
.
_newState
.
uri
=
location
;
}
_tagsChanged
(
tags
)
{
this
.
_newState
.
tags
=
tags
;
}
_keywordChanged
(
keyword
)
{
this
.
_newState
.
keyword
=
keyword
;
}
_parentGuidChanged
(
parentGuid
)
{
this
.
_newState
.
parentGuid
=
parentGuid
;
}
async
save
(
)
{
if
(
!
Object
.
keys
(
this
.
_newState
)
.
length
)
{
return
this
.
_guid
;
}
if
(
this
.
_isTagContainer
&
&
this
.
_newState
.
title
)
{
await
lazy
.
PlacesTransactions
.
RenameTag
(
{
oldTag
:
this
.
_originalState
.
title
tag
:
this
.
_newState
.
title
}
)
.
transact
(
)
.
catch
(
Cu
.
reportError
)
;
return
this
.
_guid
;
}
let
url
=
this
.
_newState
.
uri
|
|
this
.
_originalState
.
uri
;
let
transactions
=
[
]
;
if
(
this
.
_newState
.
uri
)
{
transactions
.
push
(
lazy
.
PlacesTransactions
.
EditUrl
(
{
guid
:
this
.
_guid
url
}
)
)
;
}
for
(
const
[
key
value
]
of
Object
.
entries
(
this
.
_newState
)
)
{
switch
(
key
)
{
case
"
title
"
:
transactions
.
push
(
lazy
.
PlacesTransactions
.
EditTitle
(
{
guid
:
this
.
_guid
title
:
value
}
)
)
;
break
;
case
"
tags
"
:
let
newTags
=
[
]
;
let
removedTags
=
[
]
;
value
.
filter
(
element
=
>
{
if
(
!
this
.
_originalState
.
tags
.
includes
(
element
)
)
{
newTags
.
push
(
element
)
;
}
}
)
;
this
.
_originalState
.
tags
.
filter
(
el
=
>
{
if
(
!
value
.
includes
(
el
)
)
{
removedTags
.
push
(
el
)
;
}
}
)
;
if
(
newTags
.
length
)
{
transactions
.
push
(
lazy
.
PlacesTransactions
.
Tag
(
{
urls
:
[
url
]
tags
:
newTags
}
)
)
;
}
if
(
removedTags
.
length
)
{
transactions
.
push
(
lazy
.
PlacesTransactions
.
Untag
(
{
urls
:
[
url
]
tags
:
removedTags
}
)
)
;
}
break
;
case
"
keyword
"
:
transactions
.
push
(
lazy
.
PlacesTransactions
.
EditKeyword
(
{
guid
:
this
.
_guid
keyword
:
value
postData
:
this
.
_postData
oldKeyword
:
this
.
_originalState
.
keyword
}
)
)
;
break
;
case
"
parentGuid
"
:
transactions
.
push
(
lazy
.
PlacesTransactions
.
Move
(
{
guid
:
this
.
_guid
newParentGuid
:
this
.
_newState
.
parentGuid
}
)
)
;
break
;
}
}
if
(
transactions
.
length
)
{
await
lazy
.
PlacesTransactions
.
batch
(
transactions
)
;
}
return
this
.
_guid
;
}
}
var
PlacesUIUtils
=
{
BookmarkState
_bookmarkToolbarTelemetryListening
:
false
LAST_USED_FOLDERS_META_KEY
:
"
bookmarks
/
lastusedfolders
"
lastContextMenuTriggerNode
:
null
lastBookmarkDialogDeferred
:
null
getFormattedString
:
function
PUIU_getFormattedString
(
key
params
)
{
return
lazy
.
bundle
.
formatStringFromName
(
key
params
)
;
}
getPluralString
:
function
PUIU_getPluralString
(
aKey
aNumber
aParams
)
{
let
str
=
lazy
.
PluralForm
.
get
(
aNumber
lazy
.
bundle
.
GetStringFromName
(
aKey
)
)
;
return
str
.
replace
(
/
\
#
(
\
d
+
)
/
g
function
(
matchedId
matchedNumber
)
{
let
param
=
aParams
[
parseInt
(
matchedNumber
10
)
-
1
]
;
return
param
!
=
=
undefined
?
param
:
matchedId
;
}
)
;
}
getString
:
function
PUIU_getString
(
key
)
{
return
lazy
.
bundle
.
GetStringFromName
(
key
)
;
}
obfuscateUrlForXulStore
(
url
)
{
if
(
!
url
.
startsWith
(
"
place
:
"
)
)
{
throw
new
Error
(
"
Method
must
be
used
to
only
obfuscate
place
:
uris
!
"
)
;
}
let
urlNoProtocol
=
url
.
substring
(
url
.
indexOf
(
"
:
"
)
+
1
)
;
let
hashedURL
=
lazy
.
PlacesUtils
.
md5
(
urlNoProtocol
)
;
return
place
:
{
hashedURL
}
;
}
async
showBookmarkDialog
(
aInfo
aParentWindow
=
null
)
{
this
.
lastBookmarkDialogDeferred
=
lazy
.
PromiseUtils
.
defer
(
)
;
let
hasFolderPicker
=
!
(
"
hiddenRows
"
in
aInfo
)
|
|
!
aInfo
.
hiddenRows
.
includes
(
"
folderPicker
"
)
;
let
dialogURL
=
hasFolderPicker
?
"
chrome
:
/
/
browser
/
content
/
places
/
bookmarkProperties2
.
xhtml
"
:
"
chrome
:
/
/
browser
/
content
/
places
/
bookmarkProperties
.
xhtml
"
;
let
features
=
"
centerscreen
chrome
modal
resizable
=
yes
"
;
let
bookmarkGuid
;
if
(
!
Services
.
prefs
.
getBoolPref
(
"
browser
.
bookmarks
.
editDialog
.
delayedApply
.
enabled
"
false
)
)
{
let
topUndoEntry
;
let
batchBlockingDeferred
;
topUndoEntry
=
lazy
.
PlacesTransactions
.
topUndoEntry
;
batchBlockingDeferred
=
lazy
.
PromiseUtils
.
defer
(
)
;
lazy
.
PlacesTransactions
.
batch
(
async
(
)
=
>
{
await
batchBlockingDeferred
.
promise
;
}
)
;
if
(
!
aParentWindow
)
{
aParentWindow
=
Services
.
wm
.
getMostRecentWindow
(
null
)
;
}
if
(
aParentWindow
.
gDialogBox
)
{
await
aParentWindow
.
gDialogBox
.
open
(
dialogURL
aInfo
)
;
}
else
{
aParentWindow
.
openDialog
(
dialogURL
"
"
features
aInfo
)
;
}
bookmarkGuid
=
(
"
bookmarkGuid
"
in
aInfo
&
&
aInfo
.
bookmarkGuid
)
|
|
undefined
;
batchBlockingDeferred
.
resolve
(
)
;
if
(
!
bookmarkGuid
&
&
topUndoEntry
!
=
lazy
.
PlacesTransactions
.
topUndoEntry
)
{
lazy
.
PlacesTransactions
.
undo
(
)
.
catch
(
Cu
.
reportError
)
;
}
this
.
lastBookmarkDialogDeferred
.
resolve
(
bookmarkGuid
)
;
return
bookmarkGuid
;
}
if
(
!
aParentWindow
)
{
aParentWindow
=
Services
.
wm
.
getMostRecentWindow
(
null
)
;
}
if
(
aParentWindow
.
gDialogBox
)
{
await
aParentWindow
.
gDialogBox
.
open
(
dialogURL
aInfo
)
;
}
else
{
aParentWindow
.
openDialog
(
dialogURL
"
"
features
aInfo
)
;
}
if
(
aInfo
.
bookmarkState
)
{
bookmarkGuid
=
await
aInfo
.
bookmarkState
.
save
(
)
;
this
.
lastBookmarkDialogDeferred
.
resolve
(
bookmarkGuid
)
;
return
bookmarkGuid
;
}
bookmarkGuid
=
undefined
;
this
.
lastBookmarkDialogDeferred
.
resolve
(
bookmarkGuid
)
;
return
bookmarkGuid
;
}
async
showBookmarkPagesDialog
(
URIList
hiddenRows
=
[
]
win
=
null
)
{
if
(
!
URIList
.
length
)
{
return
;
}
const
bookmarkDialogInfo
=
{
action
:
"
add
"
hiddenRows
}
;
if
(
URIList
.
length
>
1
)
{
bookmarkDialogInfo
.
type
=
"
folder
"
;
bookmarkDialogInfo
.
URIList
=
URIList
;
}
else
{
bookmarkDialogInfo
.
type
=
"
bookmark
"
;
bookmarkDialogInfo
.
title
=
URIList
[
0
]
.
title
;
bookmarkDialogInfo
.
uri
=
URIList
[
0
]
.
uri
;
}
await
PlacesUIUtils
.
showBookmarkDialog
(
bookmarkDialogInfo
win
)
;
}
loadFavicon
(
browser
principal
pageURI
uri
expiration
=
0
iconURI
=
null
)
{
if
(
gInContentProcess
)
{
throw
new
Error
(
"
Can
'
t
track
loads
from
within
the
child
process
!
"
)
;
}
InternalFaviconLoader
.
loadFavicon
(
browser
principal
pageURI
uri
expiration
iconURI
)
;
}
getViewForNode
:
function
PUIU_getViewForNode
(
aNode
)
{
let
node
=
aNode
;
if
(
Cu
.
isDeadWrapper
(
node
)
)
{
return
null
;
}
if
(
node
.
localName
=
=
"
panelview
"
&
&
node
.
_placesView
)
{
return
node
.
_placesView
;
}
if
(
node
.
localName
=
=
"
menu
"
&
&
!
node
.
_placesNode
&
&
node
.
menupopup
.
_placesView
)
{
return
node
.
menupopup
.
_placesView
;
}
while
(
Element
.
isInstance
(
node
)
)
{
if
(
node
.
_placesView
)
{
return
node
.
_placesView
;
}
if
(
node
.
localName
=
=
"
tree
"
&
&
node
.
getAttribute
(
"
is
"
)
=
=
"
places
-
tree
"
)
{
return
node
;
}
node
=
node
.
parentNode
;
}
return
null
;
}
getControllerForCommand
(
win
command
)
{
let
popupNode
=
PlacesUIUtils
.
lastContextMenuTriggerNode
;
if
(
popupNode
)
{
let
isManaged
=
!
!
popupNode
.
closest
(
"
#
managed
-
bookmarks
"
)
;
if
(
isManaged
)
{
return
this
.
managedBookmarksController
;
}
let
view
=
this
.
getViewForNode
(
popupNode
)
;
if
(
view
&
&
view
.
_contextMenuShown
)
{
return
view
.
controllers
.
getControllerForCommand
(
command
)
;
}
}
let
controller
=
win
.
top
.
document
.
commandDispatcher
.
getControllerForCommand
(
command
)
;
return
controller
|
|
null
;
}
updateCommands
(
win
)
{
let
controller
=
this
.
getControllerForCommand
(
win
"
placesCmd_open
"
)
;
for
(
let
command
of
[
"
placesCmd_open
"
"
placesCmd_open
:
window
"
"
placesCmd_open
:
privatewindow
"
"
placesCmd_open
:
tab
"
"
placesCmd_new
:
folder
"
"
placesCmd_new
:
bookmark
"
"
placesCmd_new
:
separator
"
"
placesCmd_show
:
info
"
"
placesCmd_reload
"
"
placesCmd_sortBy
:
name
"
"
placesCmd_cut
"
"
placesCmd_copy
"
"
placesCmd_paste
"
"
placesCmd_delete
"
"
placesCmd_showInFolder
"
]
)
{
win
.
goSetCommandEnabled
(
command
controller
&
&
controller
.
isCommandEnabled
(
command
)
)
;
}
}
doCommand
(
win
command
)
{
let
controller
=
this
.
getControllerForCommand
(
win
command
)
;
if
(
controller
&
&
controller
.
isCommandEnabled
(
command
)
)
{
controller
.
doCommand
(
command
)
;
}
}
markPageAsTyped
:
function
PUIU_markPageAsTyped
(
aURL
)
{
lazy
.
PlacesUtils
.
history
.
markPageAsTyped
(
Services
.
uriFixup
.
getFixupURIInfo
(
aURL
)
.
preferredURI
)
;
}
markPageAsFollowedBookmark
:
function
PUIU_markPageAsFollowedBookmark
(
aURL
)
{
lazy
.
PlacesUtils
.
history
.
markPageAsFollowedBookmark
(
Services
.
uriFixup
.
getFixupURIInfo
(
aURL
)
.
preferredURI
)
;
}
markPageAsFollowedLink
:
function
PUIU_markPageAsFollowedLink
(
aURL
)
{
lazy
.
PlacesUtils
.
history
.
markPageAsFollowedLink
(
Services
.
uriFixup
.
getFixupURIInfo
(
aURL
)
.
preferredURI
)
;
}
async
setCharsetForPage
(
url
charset
window
)
{
if
(
lazy
.
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
{
return
;
}
if
(
charset
.
toLowerCase
(
)
=
=
"
utf
-
8
"
)
{
charset
=
null
;
}
await
lazy
.
PlacesUtils
.
history
.
update
(
{
url
annotations
:
new
Map
(
[
[
lazy
.
PlacesUtils
.
CHARSET_ANNO
charset
]
]
)
}
)
;
}
checkURLSecurity
:
function
PUIU_checkURLSecurity
(
aURINode
aWindow
)
{
if
(
lazy
.
PlacesUtils
.
nodeIsBookmark
(
aURINode
)
)
{
return
true
;
}
var
uri
=
Services
.
io
.
newURI
(
aURINode
.
uri
)
;
if
(
uri
.
schemeIs
(
"
javascript
"
)
|
|
uri
.
schemeIs
(
"
data
"
)
)
{
const
BRANDING_BUNDLE_URI
=
"
chrome
:
/
/
branding
/
locale
/
brand
.
properties
"
;
var
brandShortName
=
Services
.
strings
.
createBundle
(
BRANDING_BUNDLE_URI
)
.
GetStringFromName
(
"
brandShortName
"
)
;
var
errorStr
=
this
.
getString
(
"
load
-
js
-
data
-
url
-
error
"
)
;
Services
.
prompt
.
alert
(
aWindow
brandShortName
errorStr
)
;
return
false
;
}
return
true
;
}
canUserRemove
(
aNode
)
{
let
parentNode
=
aNode
.
parent
;
if
(
!
parentNode
)
{
return
false
;
}
if
(
lazy
.
PlacesUtils
.
nodeIsQuery
(
parentNode
)
)
{
if
(
lazy
.
PlacesUtils
.
nodeIsFolder
(
aNode
)
)
{
let
guid
=
lazy
.
PlacesUtils
.
getConcreteItemGuid
(
aNode
)
;
if
(
lazy
.
PlacesUtils
.
isRootItem
(
guid
)
)
{
return
false
;
}
}
else
if
(
lazy
.
PlacesUtils
.
isVirtualLeftPaneItem
(
aNode
.
bookmarkGuid
)
)
{
return
false
;
}
}
if
(
aNode
.
itemId
=
=
-
1
|
|
lazy
.
PlacesUtils
.
nodeIsQuery
(
parentNode
)
)
{
return
true
;
}
return
!
this
.
isFolderReadOnly
(
parentNode
)
;
}
isFolderReadOnly
(
placesNode
)
{
if
(
typeof
placesNode
!
=
"
object
"
|
|
!
lazy
.
PlacesUtils
.
nodeIsFolder
(
placesNode
)
)
{
throw
new
Error
(
"
invalid
value
for
placesNode
"
)
;
}
return
(
lazy
.
PlacesUtils
.
getConcreteItemId
(
placesNode
)
=
=
lazy
.
PlacesUtils
.
placesRootId
)
;
}
openTabset
(
aItemsToOpen
aEvent
aWindow
)
{
if
(
!
aItemsToOpen
.
length
)
{
return
;
}
let
browserWindow
=
getBrowserWindow
(
aWindow
)
;
var
urls
=
[
]
;
let
skipMarking
=
browserWindow
&
&
lazy
.
PrivateBrowsingUtils
.
isWindowPrivate
(
browserWindow
)
;
for
(
let
item
of
aItemsToOpen
)
{
urls
.
push
(
item
.
uri
)
;
if
(
skipMarking
)
{
continue
;
}
if
(
item
.
isBookmark
)
{
this
.
markPageAsFollowedBookmark
(
item
.
uri
)
;
}
else
{
this
.
markPageAsTyped
(
item
.
uri
)
;
}
}
var
where
=
browserWindow
?
browserWindow
.
whereToOpenLink
(
aEvent
false
true
)
:
"
window
"
;
if
(
where
=
=
"
window
"
)
{
let
args
=
Cc
[
"
mozilla
.
org
/
array
;
1
"
]
.
createInstance
(
Ci
.
nsIMutableArray
)
;
let
stringsToLoad
=
Cc
[
"
mozilla
.
org
/
array
;
1
"
]
.
createInstance
(
Ci
.
nsIMutableArray
)
;
urls
.
forEach
(
url
=
>
stringsToLoad
.
appendElement
(
lazy
.
PlacesUtils
.
toISupportsString
(
url
)
)
)
;
args
.
appendElement
(
stringsToLoad
)
;
browserWindow
=
Services
.
ww
.
openWindow
(
aWindow
AppConstants
.
BROWSER_CHROME_URL
null
"
chrome
dialog
=
no
all
"
args
)
;
return
;
}
var
loadInBackground
=
where
=
=
"
tabshifted
"
;
browserWindow
.
gBrowser
.
loadTabs
(
urls
{
inBackground
:
loadInBackground
replace
:
false
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
}
)
;
}
openMultipleLinksInTabs
(
nodeOrNodes
event
view
)
{
let
window
=
view
.
ownerWindow
;
let
urlsToOpen
=
[
]
;
if
(
lazy
.
PlacesUtils
.
nodeIsContainer
(
nodeOrNodes
)
)
{
urlsToOpen
=
lazy
.
PlacesUtils
.
getURLsForContainerNode
(
nodeOrNodes
)
;
}
else
{
for
(
var
i
=
0
;
i
<
nodeOrNodes
.
length
;
i
+
+
)
{
if
(
lazy
.
PlacesUtils
.
nodeIsURI
(
nodeOrNodes
[
i
]
)
)
{
urlsToOpen
.
push
(
{
uri
:
nodeOrNodes
[
i
]
.
uri
isBookmark
:
lazy
.
PlacesUtils
.
nodeIsBookmark
(
nodeOrNodes
[
i
]
)
}
)
;
}
}
}
if
(
lazy
.
OpenInTabsUtils
.
confirmOpenInTabs
(
urlsToOpen
.
length
window
)
)
{
this
.
openTabset
(
urlsToOpen
event
window
)
;
}
}
openNodeWithEvent
:
function
PUIU_openNodeWithEvent
(
aNode
aEvent
)
{
let
window
=
aEvent
.
target
.
ownerGlobal
;
let
browserWindow
=
getBrowserWindow
(
window
)
;
let
where
=
window
.
whereToOpenLink
(
aEvent
false
true
)
;
if
(
this
.
loadBookmarksInTabs
&
&
lazy
.
PlacesUtils
.
nodeIsBookmark
(
aNode
)
)
{
if
(
where
=
=
"
current
"
&
&
!
aNode
.
uri
.
startsWith
(
"
javascript
:
"
)
)
{
where
=
"
tab
"
;
}
if
(
where
=
=
"
tab
"
&
&
browserWindow
.
gBrowser
.
selectedTab
.
isEmpty
)
{
where
=
"
current
"
;
}
}
this
.
_openNodeIn
(
aNode
where
window
)
;
}
openNodeIn
:
function
PUIU_openNodeIn
(
aNode
aWhere
aView
aPrivate
)
{
let
window
=
aView
.
ownerWindow
;
this
.
_openNodeIn
(
aNode
aWhere
window
{
aPrivate
}
)
;
}
_openNodeIn
:
function
PUIU__openNodeIn
(
aNode
aWhere
aWindow
{
aPrivate
=
false
userContextId
=
0
}
=
{
}
)
{
if
(
aNode
&
&
lazy
.
PlacesUtils
.
nodeIsURI
(
aNode
)
&
&
this
.
checkURLSecurity
(
aNode
aWindow
)
)
{
let
isBookmark
=
lazy
.
PlacesUtils
.
nodeIsBookmark
(
aNode
)
;
if
(
!
lazy
.
PrivateBrowsingUtils
.
isWindowPrivate
(
aWindow
)
)
{
if
(
isBookmark
)
{
this
.
markPageAsFollowedBookmark
(
aNode
.
uri
)
;
}
else
{
this
.
markPageAsTyped
(
aNode
.
uri
)
;
}
}
const
isJavaScriptURL
=
aNode
.
uri
.
startsWith
(
"
javascript
:
"
)
;
aWindow
.
openTrustedLinkIn
(
aNode
.
uri
aWhere
{
allowPopups
:
isJavaScriptURL
inBackground
:
this
.
loadBookmarksInBackground
allowInheritPrincipal
:
isJavaScriptURL
private
:
aPrivate
userContextId
}
)
;
}
}
guessUrlSchemeForUI
(
href
)
{
return
href
.
substr
(
0
href
.
indexOf
(
"
:
"
)
)
;
}
getBestTitle
:
function
PUIU_getBestTitle
(
aNode
aDoNotCutTitle
)
{
var
title
;
if
(
!
aNode
.
title
&
&
lazy
.
PlacesUtils
.
nodeIsURI
(
aNode
)
)
{
try
{
var
uri
=
Services
.
io
.
newURI
(
aNode
.
uri
)
;
var
host
=
uri
.
host
;
var
fileName
=
uri
.
QueryInterface
(
Ci
.
nsIURL
)
.
fileName
;
if
(
aDoNotCutTitle
)
{
title
=
host
+
uri
.
pathQueryRef
;
}
else
{
title
=
host
+
(
fileName
?
(
host
?
"
/
"
+
this
.
ellipsis
+
"
/
"
:
"
"
)
+
fileName
:
uri
.
pathQueryRef
)
;
}
}
catch
(
e
)
{
title
=
"
"
;
}
}
else
{
title
=
aNode
.
title
;
}
return
title
|
|
this
.
getString
(
"
noTitle
"
)
;
}
shouldShowTabsFromOtherComputersMenuitem
(
)
{
let
weaveOK
=
lazy
.
Weave
.
Status
.
checkSetup
(
)
!
=
lazy
.
Weave
.
CLIENT_NOT_CONFIGURED
&
&
lazy
.
Weave
.
Svc
.
Prefs
.
get
(
"
firstSync
"
"
"
)
!
=
"
notReady
"
;
return
weaveOK
;
}
isFolderShortcutQueryString
(
queryString
)
{
let
query
=
{
}
options
=
{
}
;
lazy
.
PlacesUtils
.
history
.
queryStringToQuery
(
queryString
query
options
)
;
query
=
query
.
value
;
options
=
options
.
value
;
return
(
query
.
folderCount
=
=
1
&
&
!
query
.
hasBeginTime
&
&
!
query
.
hasEndTime
&
&
!
query
.
hasDomain
&
&
!
query
.
hasURI
&
&
!
query
.
hasSearchTerms
&
&
!
query
.
tags
.
length
=
=
0
&
&
options
.
maxResults
=
=
0
)
;
}
async
promiseNodeLikeFromFetchInfo
(
aFetchInfo
)
{
if
(
aFetchInfo
.
itemType
=
=
lazy
.
PlacesUtils
.
bookmarks
.
TYPE_SEPARATOR
)
{
throw
new
Error
(
"
promiseNodeLike
doesn
'
t
support
separators
"
)
;
}
let
parent
=
{
itemId
:
await
lazy
.
PlacesUtils
.
promiseItemId
(
aFetchInfo
.
parentGuid
)
bookmarkGuid
:
aFetchInfo
.
parentGuid
type
:
Ci
.
nsINavHistoryResultNode
.
RESULT_TYPE_FOLDER
}
;
return
Object
.
freeze
(
{
itemId
:
await
lazy
.
PlacesUtils
.
promiseItemId
(
aFetchInfo
.
guid
)
bookmarkGuid
:
aFetchInfo
.
guid
title
:
aFetchInfo
.
title
uri
:
aFetchInfo
.
url
!
=
=
undefined
?
aFetchInfo
.
url
.
href
:
"
"
get
type
(
)
{
if
(
aFetchInfo
.
itemType
=
=
lazy
.
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
)
{
return
Ci
.
nsINavHistoryResultNode
.
RESULT_TYPE_FOLDER
;
}
if
(
!
this
.
uri
.
length
)
{
throw
new
Error
(
"
Unexpected
item
type
"
)
;
}
if
(
/
^
place
:
/
.
test
(
this
.
uri
)
)
{
if
(
this
.
isFolderShortcutQueryString
(
this
.
uri
)
)
{
return
Ci
.
nsINavHistoryResultNode
.
RESULT_TYPE_FOLDER_SHORTCUT
;
}
return
Ci
.
nsINavHistoryResultNode
.
RESULT_TYPE_QUERY
;
}
return
Ci
.
nsINavHistoryResultNode
.
RESULT_TYPE_URI
;
}
get
parent
(
)
{
return
parent
;
}
}
)
;
}
async
batchUpdatesForNode
(
resultNode
itemsBeingChanged
functionToWrap
)
{
if
(
!
resultNode
)
{
await
functionToWrap
(
)
;
return
;
}
if
(
itemsBeingChanged
>
ITEM_CHANGED_BATCH_NOTIFICATION_THRESHOLD
)
{
resultNode
.
onBeginUpdateBatch
(
)
;
}
try
{
await
functionToWrap
(
)
;
}
finally
{
if
(
itemsBeingChanged
>
ITEM_CHANGED_BATCH_NOTIFICATION_THRESHOLD
)
{
resultNode
.
onEndUpdateBatch
(
)
;
}
}
}
async
handleTransferItems
(
items
insertionPoint
doCopy
view
)
{
let
transactions
;
let
itemsCount
;
if
(
insertionPoint
.
isTag
)
{
let
urls
=
items
.
filter
(
item
=
>
"
uri
"
in
item
)
.
map
(
item
=
>
item
.
uri
)
;
itemsCount
=
urls
.
length
;
transactions
=
[
lazy
.
PlacesTransactions
.
Tag
(
{
urls
tag
:
insertionPoint
.
tagName
}
)
]
;
}
else
{
let
insertionIndex
=
await
insertionPoint
.
getIndex
(
)
;
itemsCount
=
items
.
length
;
transactions
=
getTransactionsForTransferItems
(
items
insertionIndex
insertionPoint
.
guid
!
doCopy
)
;
}
if
(
!
transactions
.
length
)
{
return
[
]
;
}
let
guidsToSelect
=
[
]
;
let
resultForBatching
=
getResultForBatching
(
view
)
;
let
batchingItem
=
transactions
;
if
(
!
insertionPoint
.
isTag
)
{
batchingItem
=
async
(
)
=
>
{
for
(
let
transaction
of
transactions
)
{
let
result
=
await
transaction
.
transact
(
)
;
guidsToSelect
=
guidsToSelect
.
concat
(
result
)
;
}
}
;
}
await
this
.
batchUpdatesForNode
(
resultForBatching
itemsCount
async
(
)
=
>
{
await
lazy
.
PlacesTransactions
.
batch
(
batchingItem
)
;
}
)
;
return
guidsToSelect
;
}
onSidebarTreeClick
(
event
)
{
if
(
event
.
button
=
=
2
)
{
return
;
}
let
tree
=
event
.
target
.
parentNode
;
let
cell
=
tree
.
getCellAt
(
event
.
clientX
event
.
clientY
)
;
if
(
cell
.
row
=
=
-
1
|
|
cell
.
childElt
=
=
"
twisty
"
)
{
return
;
}
let
win
=
tree
.
ownerGlobal
;
let
rect
=
tree
.
getCoordsForCellItem
(
cell
.
row
cell
.
col
"
image
"
)
;
let
isRTL
=
win
.
getComputedStyle
(
tree
)
.
direction
=
=
"
rtl
"
;
let
mouseInGutter
=
isRTL
?
event
.
clientX
>
rect
.
x
:
event
.
clientX
<
rect
.
x
;
let
metaKey
=
AppConstants
.
platform
=
=
=
"
macosx
"
?
event
.
metaKey
:
event
.
ctrlKey
;
let
modifKey
=
metaKey
|
|
event
.
shiftKey
;
let
isContainer
=
tree
.
view
.
isContainer
(
cell
.
row
)
;
let
openInTabs
=
isContainer
&
&
(
event
.
button
=
=
1
|
|
(
event
.
button
=
=
0
&
&
modifKey
)
)
&
&
lazy
.
PlacesUtils
.
hasChildURIs
(
tree
.
view
.
nodeForTreeIndex
(
cell
.
row
)
)
;
if
(
event
.
button
=
=
0
&
&
isContainer
&
&
!
openInTabs
)
{
tree
.
view
.
toggleOpenState
(
cell
.
row
)
;
}
else
if
(
!
mouseInGutter
&
&
openInTabs
&
&
event
.
originalTarget
.
localName
=
=
"
treechildren
"
)
{
tree
.
view
.
selection
.
select
(
cell
.
row
)
;
this
.
openMultipleLinksInTabs
(
tree
.
selectedNode
event
tree
)
;
}
else
if
(
!
mouseInGutter
&
&
!
isContainer
&
&
event
.
originalTarget
.
localName
=
=
"
treechildren
"
)
{
tree
.
view
.
selection
.
select
(
cell
.
row
)
;
this
.
openNodeWithEvent
(
tree
.
selectedNode
event
)
;
}
}
onSidebarTreeKeyPress
(
event
)
{
let
node
=
event
.
target
.
selectedNode
;
if
(
node
)
{
if
(
event
.
keyCode
=
=
event
.
DOM_VK_RETURN
)
{
this
.
openNodeWithEvent
(
node
event
)
;
}
}
}
onSidebarTreeMouseMove
(
event
)
{
let
treechildren
=
event
.
target
;
if
(
treechildren
.
localName
!
=
"
treechildren
"
)
{
return
;
}
let
tree
=
treechildren
.
parentNode
;
let
cell
=
tree
.
getCellAt
(
event
.
clientX
event
.
clientY
)
;
if
(
cell
.
row
!
=
-
1
)
{
let
node
=
tree
.
view
.
nodeForTreeIndex
(
cell
.
row
)
;
if
(
lazy
.
PlacesUtils
.
nodeIsURI
(
node
)
)
{
this
.
setMouseoverURL
(
node
.
uri
tree
.
ownerGlobal
)
;
return
;
}
}
this
.
setMouseoverURL
(
"
"
tree
.
ownerGlobal
)
;
}
setMouseoverURL
(
url
win
)
{
if
(
win
.
top
.
XULBrowserWindow
)
{
win
.
top
.
XULBrowserWindow
.
setOverLink
(
url
)
;
}
}
NUM_TOOLBAR_BOOKMARKS_TO_UNHIDE
:
3
maybeToggleBookmarkToolbarVisibility
(
aForceVisible
=
false
)
{
const
BROWSER_DOCURL
=
AppConstants
.
BROWSER_CHROME_URL
;
let
xulStore
=
Services
.
xulStore
;
if
(
aForceVisible
|
|
!
xulStore
.
hasValue
(
BROWSER_DOCURL
"
PersonalToolbar
"
"
collapsed
"
)
)
{
let
toolbarIsCustomized
=
xulStore
.
hasValue
(
BROWSER_DOCURL
"
PersonalToolbar
"
"
currentset
"
)
;
if
(
aForceVisible
|
|
toolbarIsCustomized
|
|
lazy
.
PlacesUtils
.
getChildCountForFolder
(
lazy
.
PlacesUtils
.
bookmarks
.
toolbarGuid
)
>
this
.
NUM_TOOLBAR_BOOKMARKS_TO_UNHIDE
)
{
Services
.
obs
.
notifyObservers
(
null
"
browser
-
set
-
toolbar
-
visibility
"
JSON
.
stringify
(
[
lazy
.
CustomizableUI
.
AREA_BOOKMARKS
"
true
"
]
)
)
;
}
}
}
maybeToggleBookmarkToolbarVisibilityAfterMigration
(
)
{
if
(
Services
.
prefs
.
getBoolPref
(
"
browser
.
migrate
.
showBookmarksToolbarAfterMigration
"
)
)
{
this
.
maybeToggleBookmarkToolbarVisibility
(
true
)
;
}
}
async
managedPlacesContextShowing
(
event
)
{
let
menupopup
=
event
.
target
;
let
document
=
menupopup
.
ownerDocument
;
let
window
=
menupopup
.
ownerGlobal
;
if
(
menupopup
.
triggerNode
.
id
=
=
"
managed
-
bookmarks
"
&
&
!
menupopup
.
triggerNode
.
menupopup
.
hasAttribute
(
"
hasbeenopened
"
)
)
{
await
window
.
PlacesToolbarHelper
.
populateManagedBookmarks
(
menupopup
.
triggerNode
.
menupopup
)
;
}
let
linkItems
=
[
"
placesContext_open
:
newtab
"
"
placesContext_open
:
newwindow
"
"
placesContext_openSeparator
"
"
placesContext_copy
"
]
;
Array
.
from
(
menupopup
.
children
)
.
forEach
(
function
(
child
)
{
child
.
hidden
=
true
;
}
)
;
this
.
managedBookmarksController
.
triggerNode
=
menupopup
.
triggerNode
;
let
isFolder
=
menupopup
.
triggerNode
.
hasAttribute
(
"
container
"
)
;
if
(
isFolder
)
{
let
openContainerInTabs_menuitem
=
document
.
getElementById
(
"
placesContext_openContainer
:
tabs
"
)
;
let
menuitems
=
menupopup
.
triggerNode
.
menupopup
.
children
;
let
openContainerInTabs
=
Array
.
from
(
menuitems
)
.
some
(
menuitem
=
>
menuitem
.
link
)
;
openContainerInTabs_menuitem
.
disabled
=
!
openContainerInTabs
;
openContainerInTabs_menuitem
.
hidden
=
false
;
}
else
{
linkItems
.
forEach
(
id
=
>
(
document
.
getElementById
(
id
)
.
hidden
=
false
)
)
;
document
.
getElementById
(
"
placesContext_open
:
newprivatewindow
"
)
.
hidden
=
lazy
.
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
|
|
!
lazy
.
PrivateBrowsingUtils
.
enabled
;
document
.
getElementById
(
"
placesContext_open
:
newcontainertab
"
)
.
hidden
=
!
Services
.
prefs
.
getBoolPref
(
"
privacy
.
userContext
.
enabled
"
false
)
;
}
event
.
target
.
ownerGlobal
.
updateCommands
(
"
places
"
)
;
}
placesContextShowing
(
event
)
{
let
menupopup
=
event
.
target
;
if
(
menupopup
.
id
!
=
"
placesContext
"
)
{
return
true
;
}
PlacesUIUtils
.
lastContextMenuTriggerNode
=
menupopup
.
triggerNode
;
let
isManaged
=
!
!
menupopup
.
triggerNode
.
closest
(
"
#
managed
-
bookmarks
"
)
;
if
(
isManaged
)
{
this
.
managedPlacesContextShowing
(
event
)
;
return
true
;
}
menupopup
.
_view
=
this
.
getViewForNode
(
menupopup
.
triggerNode
)
;
if
(
!
menupopup
.
_view
)
{
event
.
preventDefault
(
)
;
return
false
;
}
if
(
!
this
.
openInTabClosesMenu
)
{
menupopup
.
ownerDocument
.
getElementById
(
"
placesContext_open
:
newtab
"
)
.
setAttribute
(
"
closemenu
"
"
single
"
)
;
}
return
menupopup
.
_view
.
buildContextMenu
(
menupopup
)
;
}
placesContextHiding
(
event
)
{
let
menupopup
=
event
.
target
;
if
(
menupopup
.
_view
)
{
menupopup
.
_view
.
destroyContextMenu
(
)
;
}
if
(
menupopup
.
id
=
=
"
placesContext
"
)
{
PlacesUIUtils
.
lastContextMenuTriggerNode
=
null
;
}
}
createContainerTabMenu
(
event
)
{
let
window
=
event
.
target
.
ownerGlobal
;
return
window
.
createUserContextMenu
(
event
{
isContextMenu
:
true
}
)
;
}
openInContainerTab
(
event
)
{
let
userContextId
=
parseInt
(
event
.
target
.
getAttribute
(
"
data
-
usercontextid
"
)
)
;
let
triggerNode
=
this
.
lastContextMenuTriggerNode
;
let
isManaged
=
!
!
triggerNode
.
closest
(
"
#
managed
-
bookmarks
"
)
;
if
(
isManaged
)
{
let
window
=
triggerNode
.
ownerGlobal
;
window
.
openTrustedLinkIn
(
triggerNode
.
link
"
tab
"
{
userContextId
}
)
;
return
;
}
let
view
=
this
.
getViewForNode
(
triggerNode
)
;
this
.
_openNodeIn
(
view
.
selectedNode
"
tab
"
view
.
ownerWindow
{
userContextId
}
)
;
}
openSelectionInTabs
(
event
)
{
let
isManaged
=
!
!
event
.
target
.
parentNode
.
triggerNode
.
closest
(
"
#
managed
-
bookmarks
"
)
;
let
controller
;
if
(
isManaged
)
{
controller
=
this
.
managedBookmarksController
;
}
else
{
controller
=
PlacesUIUtils
.
getViewForNode
(
PlacesUIUtils
.
lastContextMenuTriggerNode
)
.
controller
;
}
controller
.
openSelectionInTabs
(
event
)
;
}
managedBookmarksController
:
{
triggerNode
:
null
openSelectionInTabs
(
event
)
{
let
window
=
event
.
target
.
ownerGlobal
;
let
menuitems
=
event
.
target
.
parentNode
.
triggerNode
.
menupopup
.
children
;
let
items
=
[
]
;
for
(
let
i
=
0
;
i
<
menuitems
.
length
;
i
+
+
)
{
if
(
menuitems
[
i
]
.
link
)
{
let
item
=
{
}
;
item
.
uri
=
menuitems
[
i
]
.
link
;
item
.
isBookmark
=
true
;
items
.
push
(
item
)
;
}
}
PlacesUIUtils
.
openTabset
(
items
event
window
)
;
}
isCommandEnabled
(
command
)
{
switch
(
command
)
{
case
"
placesCmd_copy
"
:
case
"
placesCmd_open
:
window
"
:
case
"
placesCmd_open
:
privatewindow
"
:
case
"
placesCmd_open
:
tab
"
:
{
return
true
;
}
}
return
false
;
}
doCommand
(
command
)
{
let
window
=
this
.
triggerNode
.
ownerGlobal
;
switch
(
command
)
{
case
"
placesCmd_copy
"
:
let
node
=
{
}
;
node
.
type
=
0
;
node
.
title
=
this
.
triggerNode
.
label
;
node
.
uri
=
this
.
triggerNode
.
link
;
let
contents
=
[
{
type
:
lazy
.
PlacesUtils
.
TYPE_X_MOZ_URL
entries
:
[
]
}
{
type
:
lazy
.
PlacesUtils
.
TYPE_HTML
entries
:
[
]
}
{
type
:
lazy
.
PlacesUtils
.
TYPE_UNICODE
entries
:
[
]
}
]
;
contents
.
forEach
(
function
(
content
)
{
content
.
entries
.
push
(
lazy
.
PlacesUtils
.
wrapNode
(
node
content
.
type
)
)
;
}
)
;
let
xferable
=
Cc
[
"
mozilla
.
org
/
widget
/
transferable
;
1
"
]
.
createInstance
(
Ci
.
nsITransferable
)
;
xferable
.
init
(
null
)
;
function
addData
(
type
data
)
{
xferable
.
addDataFlavor
(
type
)
;
xferable
.
setTransferData
(
type
lazy
.
PlacesUtils
.
toISupportsString
(
data
)
)
;
}
contents
.
forEach
(
function
(
content
)
{
addData
(
content
.
type
content
.
entries
.
join
(
lazy
.
PlacesUtils
.
endl
)
)
;
}
)
;
Services
.
clipboard
.
setData
(
xferable
null
Ci
.
nsIClipboard
.
kGlobalClipboard
)
;
break
;
case
"
placesCmd_open
:
privatewindow
"
:
window
.
openUILinkIn
(
this
.
triggerNode
.
link
"
window
"
{
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
private
:
true
}
)
;
break
;
case
"
placesCmd_open
:
window
"
:
window
.
openUILinkIn
(
this
.
triggerNode
.
link
"
window
"
{
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
private
:
false
}
)
;
break
;
case
"
placesCmd_open
:
tab
"
:
{
window
.
openUILinkIn
(
this
.
triggerNode
.
link
"
tab
"
{
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
}
)
;
}
}
}
}
async
maybeAddImportButton
(
)
{
if
(
!
Services
.
policies
.
isAllowed
(
"
profileImport
"
)
)
{
return
;
}
let
numberOfBookmarks
=
await
lazy
.
PlacesUtils
.
withConnectionWrapper
(
"
PlacesUIUtils
:
maybeAddImportButton
"
async
db
=
>
{
let
rows
=
await
db
.
execute
(
SELECT
COUNT
(
*
)
as
n
FROM
moz_bookmarks
b
WHERE
b
.
parent
=
:
parentId
{
parentId
:
lazy
.
PlacesUtils
.
toolbarFolderId
}
)
;
return
rows
[
0
]
.
getResultByName
(
"
n
"
)
;
}
)
.
catch
(
e
=
>
{
Cu
.
reportError
(
e
)
;
return
0
;
}
)
;
if
(
numberOfBookmarks
<
3
)
{
lazy
.
CustomizableUI
.
addWidgetToArea
(
"
import
-
button
"
lazy
.
CustomizableUI
.
AREA_BOOKMARKS
0
)
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
bookmarks
.
addedImportButton
"
true
)
;
this
.
removeImportButtonWhenImportSucceeds
(
)
;
}
}
removeImportButtonWhenImportSucceeds
(
)
{
let
placement
=
lazy
.
CustomizableUI
.
getPlacementOfWidget
(
"
import
-
button
"
)
;
if
(
placement
?
.
area
!
=
lazy
.
CustomizableUI
.
AREA_BOOKMARKS
)
{
Services
.
prefs
.
clearUserPref
(
"
browser
.
bookmarks
.
addedImportButton
"
)
;
return
;
}
let
obs
=
(
subject
topic
data
)
=
>
{
if
(
data
=
=
Ci
.
nsIBrowserProfileMigrator
.
BOOKMARKS
&
&
lazy
.
MigrationUtils
.
getImportedCount
(
"
bookmarks
"
)
>
0
)
{
lazy
.
CustomizableUI
.
removeWidgetFromArea
(
"
import
-
button
"
)
;
Services
.
prefs
.
clearUserPref
(
"
browser
.
bookmarks
.
addedImportButton
"
)
;
Services
.
obs
.
removeObserver
(
obs
"
Migration
:
ItemAfterMigrate
"
)
;
Services
.
obs
.
removeObserver
(
obs
"
Migration
:
ItemError
"
)
;
}
}
;
Services
.
obs
.
addObserver
(
obs
"
Migration
:
ItemAfterMigrate
"
)
;
Services
.
obs
.
addObserver
(
obs
"
Migration
:
ItemError
"
)
;
}
setupSpeculativeConnection
(
url
window
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
"
browser
.
places
.
speculativeConnect
.
enabled
"
true
)
)
{
return
;
}
if
(
!
url
.
startsWith
(
"
http
"
)
)
{
return
;
}
try
{
let
uri
=
url
instanceof
Ci
.
nsIURI
?
url
:
Services
.
io
.
newURI
(
url
)
;
Services
.
io
.
speculativeConnect
(
uri
window
.
gBrowser
.
contentPrincipal
null
)
;
}
catch
(
ex
)
{
}
}
getImageURL
(
aItem
)
{
let
iconURL
=
aItem
.
image
;
if
(
/
^
https
?
:
/
.
test
(
iconURL
)
)
{
iconURL
=
"
moz
-
anno
:
favicon
:
"
+
iconURL
;
}
return
iconURL
;
}
insertTitleStartDiffs
(
candidates
)
{
function
findStartDifference
(
a
b
)
{
let
i
;
for
(
i
=
PlacesUIUtils
.
similarTitlesMinChars
;
i
<
a
.
length
;
i
+
+
)
{
if
(
a
[
i
]
!
=
b
[
i
]
)
{
return
i
;
}
}
if
(
b
.
length
>
i
)
{
return
i
;
}
return
-
1
;
}
let
longTitles
=
new
Map
(
)
;
for
(
let
candidate
of
candidates
)
{
if
(
!
candidate
.
title
|
|
candidate
.
title
.
length
<
this
.
similarTitlesMinChars
)
{
continue
;
}
let
titleBeginning
=
candidate
.
title
.
slice
(
0
this
.
similarTitlesMinChars
)
;
let
matches
=
longTitles
.
get
(
titleBeginning
)
;
if
(
matches
)
{
for
(
let
match
of
matches
)
{
let
startDiff
=
findStartDifference
(
candidate
.
title
match
.
title
)
;
if
(
startDiff
>
0
)
{
candidate
.
titleDifferentIndex
=
startDiff
;
if
(
!
(
"
titleDifferentIndex
"
in
match
)
|
|
match
.
titleDifferentIndex
>
startDiff
)
{
match
.
titleDifferentIndex
=
startDiff
;
}
}
}
matches
.
push
(
candidate
)
;
}
else
{
longTitles
.
set
(
titleBeginning
[
candidate
]
)
;
}
}
}
}
;
PlacesUIUtils
.
canLoadToolbarContentPromise
=
new
Promise
(
resolve
=
>
{
PlacesUIUtils
.
unblockToolbars
=
resolve
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
PlacesUIUtils
"
PLACES_FLAVORS
"
(
)
=
>
{
return
[
lazy
.
PlacesUtils
.
TYPE_X_MOZ_PLACE_CONTAINER
lazy
.
PlacesUtils
.
TYPE_X_MOZ_PLACE_SEPARATOR
lazy
.
PlacesUtils
.
TYPE_X_MOZ_PLACE
]
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
PlacesUIUtils
"
URI_FLAVORS
"
(
)
=
>
{
return
[
lazy
.
PlacesUtils
.
TYPE_X_MOZ_URL
TAB_DROP_TYPE
lazy
.
PlacesUtils
.
TYPE_UNICODE
]
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
PlacesUIUtils
"
SUPPORTED_FLAVORS
"
(
)
=
>
{
return
[
.
.
.
PlacesUIUtils
.
PLACES_FLAVORS
.
.
.
PlacesUIUtils
.
URI_FLAVORS
]
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
PlacesUIUtils
"
ellipsis
"
function
(
)
{
return
Services
.
prefs
.
getComplexValue
(
"
intl
.
ellipsis
"
Ci
.
nsIPrefLocalizedString
)
.
data
;
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
PlacesUIUtils
"
similarTitlesMinChars
"
"
browser
.
places
.
similarTitlesMinChars
"
20
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
PlacesUIUtils
"
loadBookmarksInBackground
"
"
browser
.
tabs
.
loadBookmarksInBackground
"
false
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
PlacesUIUtils
"
loadBookmarksInTabs
"
"
browser
.
tabs
.
loadBookmarksInTabs
"
false
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
PlacesUIUtils
"
openInTabClosesMenu
"
"
browser
.
bookmarks
.
openInTabClosesMenu
"
false
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
PlacesUIUtils
"
maxRecentFolders
"
"
browser
.
bookmarks
.
editDialog
.
maxRecentFolders
"
7
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
PlacesUIUtils
"
defaultParentGuid
"
"
browser
.
bookmarks
.
defaultLocation
"
"
"
null
async
prefValue
=
>
{
if
(
!
prefValue
)
{
return
lazy
.
PlacesUtils
.
bookmarks
.
toolbarGuid
;
}
if
(
[
"
toolbar
"
"
menu
"
"
unfiled
"
]
.
includes
(
prefValue
)
)
{
return
lazy
.
PlacesUtils
.
bookmarks
[
prefValue
+
"
Guid
"
]
;
}
try
{
return
await
lazy
.
PlacesUtils
.
bookmarks
.
fetch
(
{
guid
:
prefValue
}
)
.
then
(
bm
=
>
bm
.
guid
)
;
}
catch
(
ex
)
{
return
lazy
.
PlacesUtils
.
bookmarks
.
toolbarGuid
;
}
}
)
;
function
canMoveUnwrappedNode
(
unwrappedNode
)
{
if
(
(
unwrappedNode
.
concreteGuid
&
&
lazy
.
PlacesUtils
.
isRootItem
(
unwrappedNode
.
concreteGuid
)
)
|
|
(
unwrappedNode
.
guid
&
&
lazy
.
PlacesUtils
.
isRootItem
(
unwrappedNode
.
guid
)
)
)
{
return
false
;
}
let
parentGuid
=
unwrappedNode
.
parentGuid
;
if
(
parentGuid
=
=
lazy
.
PlacesUtils
.
bookmarks
.
rootGuid
)
{
return
false
;
}
return
true
;
}
function
getResultForBatching
(
viewOrElement
)
{
if
(
viewOrElement
&
&
Element
.
isInstance
(
viewOrElement
)
&
&
viewOrElement
.
id
=
=
=
"
placesList
"
)
{
viewOrElement
=
viewOrElement
.
ownerDocument
.
getElementById
(
"
placeContent
"
)
|
|
viewOrElement
;
}
if
(
viewOrElement
&
&
viewOrElement
.
result
)
{
return
viewOrElement
.
result
;
}
return
null
;
}
function
getTransactionsForTransferItems
(
items
insertionIndex
insertionParentGuid
doMove
)
{
let
canMove
=
true
;
for
(
let
item
of
items
)
{
if
(
!
PlacesUIUtils
.
SUPPORTED_FLAVORS
.
includes
(
item
.
type
)
)
{
throw
new
Error
(
Unsupported
'
{
item
.
type
}
'
data
type
)
;
}
if
(
!
(
"
instanceId
"
in
item
)
|
|
item
.
instanceId
!
=
lazy
.
PlacesUtils
.
instanceId
)
{
if
(
item
.
type
=
=
lazy
.
PlacesUtils
.
TYPE_X_MOZ_PLACE_CONTAINER
)
{
throw
new
Error
(
"
Can
'
t
copy
a
container
from
a
legacy
-
transactions
build
"
)
;
}
if
(
PlacesUIUtils
.
PLACES_FLAVORS
.
includes
(
item
.
type
)
)
{
Cu
.
reportError
(
"
Tried
to
move
an
unmovable
Places
"
+
"
node
reverting
to
a
copy
operation
.
"
)
;
}
canMove
=
false
;
}
if
(
doMove
&
&
canMove
)
{
canMove
=
canMoveUnwrappedNode
(
item
)
;
}
}
if
(
doMove
&
&
!
canMove
)
{
doMove
=
false
;
}
if
(
doMove
)
{
return
[
lazy
.
PlacesTransactions
.
Move
(
{
guids
:
items
.
map
(
item
=
>
item
.
itemGuid
)
newParentGuid
:
insertionParentGuid
newIndex
:
insertionIndex
}
)
]
;
}
return
getTransactionsForCopy
(
items
insertionIndex
insertionParentGuid
)
;
}
function
getTransactionsForCopy
(
items
insertionIndex
insertionParentGuid
)
{
let
transactions
=
[
]
;
let
index
=
insertionIndex
;
for
(
let
item
of
items
)
{
let
transaction
;
let
guid
=
item
.
itemGuid
;
if
(
PlacesUIUtils
.
PLACES_FLAVORS
.
includes
(
item
.
type
)
&
&
"
instanceId
"
in
item
&
&
item
.
instanceId
=
=
lazy
.
PlacesUtils
.
instanceId
&
&
guid
&
&
!
lazy
.
PlacesUtils
.
bookmarks
.
isVirtualRootItem
(
guid
)
&
&
!
lazy
.
PlacesUtils
.
isVirtualLeftPaneItem
(
guid
)
)
{
transaction
=
lazy
.
PlacesTransactions
.
Copy
(
{
guid
newIndex
:
index
newParentGuid
:
insertionParentGuid
}
)
;
}
else
if
(
item
.
type
=
=
lazy
.
PlacesUtils
.
TYPE_X_MOZ_PLACE_SEPARATOR
)
{
transaction
=
lazy
.
PlacesTransactions
.
NewSeparator
(
{
index
parentGuid
:
insertionParentGuid
}
)
;
}
else
{
let
title
=
item
.
type
!
=
lazy
.
PlacesUtils
.
TYPE_UNICODE
?
item
.
title
:
item
.
uri
;
transaction
=
lazy
.
PlacesTransactions
.
NewBookmark
(
{
index
parentGuid
:
insertionParentGuid
title
url
:
item
.
uri
}
)
;
}
transactions
.
push
(
transaction
)
;
if
(
index
!
=
-
1
)
{
index
+
+
;
}
}
return
transactions
;
}
function
getBrowserWindow
(
aWindow
)
{
return
aWindow
&
&
aWindow
.
document
.
documentElement
.
getAttribute
(
"
windowtype
"
)
=
=
"
navigator
:
browser
"
?
aWindow
:
lazy
.
BrowserWindowTracker
.
getTopWindow
(
)
;
}
