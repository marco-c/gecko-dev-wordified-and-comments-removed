"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
InteractionsBlocklist
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
FilterAdult
:
"
resource
:
/
/
activity
-
stream
/
lib
/
FilterAdult
.
jsm
"
UrlbarUtils
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
logConsole
"
function
(
)
{
return
console
.
createInstance
(
{
prefix
:
"
InteractionsBlocklist
"
maxLogLevel
:
Services
.
prefs
.
getBoolPref
(
"
browser
.
places
.
interactions
.
log
"
false
)
?
"
Debug
"
:
"
Warn
"
}
)
;
}
)
;
let
HOST_BLOCKLIST
=
{
auth0
:
[
"
^
https
:
\
\
/
\
\
/
.
*
\
\
.
auth0
\
\
.
com
\
\
/
login
"
]
baidu
:
[
"
^
(
https
?
:
\
\
/
\
\
/
)
?
(
www
\
\
.
)
?
baidu
\
\
.
com
\
\
/
s
.
*
(
\
\
?
|
&
)
wd
=
.
*
"
]
bing
:
[
"
^
(
https
?
:
\
\
/
\
\
/
)
?
(
www
\
\
.
)
?
bing
\
\
.
com
\
\
/
search
.
*
(
\
\
?
|
&
)
q
=
.
*
"
]
duckduckgo
:
[
"
^
(
https
?
:
\
\
/
\
\
/
)
?
(
www
\
\
.
)
?
duckduckgo
\
\
.
com
\
\
/
.
*
(
\
\
?
|
&
)
q
=
.
*
"
]
google
:
[
"
^
(
https
?
:
\
\
/
\
\
/
)
?
(
www
\
\
.
)
?
google
\
\
.
(
\
\
w
|
\
\
.
)
{
2
}
\
\
/
search
.
*
(
\
\
?
|
&
)
q
=
.
*
"
"
^
https
:
\
\
/
\
\
/
accounts
\
\
.
google
\
\
.
com
\
\
/
o
\
\
/
oauth2
\
\
/
v2
\
\
/
auth
"
"
^
https
:
\
\
/
\
\
/
accounts
\
\
.
google
\
\
.
com
\
\
/
signin
\
\
/
oauth
\
\
/
consent
"
]
microsoftonline
:
[
"
^
https
:
\
\
/
\
\
/
login
\
\
.
microsoftonline
\
\
.
com
\
\
/
common
\
\
/
oauth2
\
\
/
v2
\
\
.
0
\
\
/
authorize
"
]
yandex
:
[
"
^
(
https
?
:
\
\
/
\
\
/
)
?
(
www
\
\
.
)
?
yandex
\
\
.
(
\
\
w
|
\
\
.
)
{
2
}
\
\
/
search
.
*
(
\
\
?
|
&
)
text
=
.
*
"
]
zoom
:
[
"
^
(
https
?
:
\
\
/
\
\
/
)
?
(
www
\
\
.
)
?
.
*
\
\
.
zoom
\
\
.
us
\
\
/
j
\
\
/
\
\
d
+
"
]
}
;
HOST_BLOCKLIST
=
new
Proxy
(
HOST_BLOCKLIST
{
get
(
target
property
)
{
let
regexes
=
target
[
property
]
;
if
(
!
regexes
|
|
!
Array
.
isArray
(
regexes
)
)
{
return
null
;
}
for
(
let
i
=
0
;
i
<
regexes
.
length
;
i
+
+
)
{
let
regex
=
regexes
[
i
]
;
if
(
typeof
regex
=
=
=
"
string
"
)
{
regex
=
new
RegExp
(
regex
"
i
"
)
;
if
(
regex
)
{
regexes
[
i
]
=
regex
;
}
else
{
throw
new
Error
(
"
Blocklist
contains
invalid
regex
.
"
)
;
}
}
}
return
regexes
;
}
}
)
;
class
_InteractionsBlocklist
{
constructor
(
)
{
try
{
let
customBlocklist
=
JSON
.
parse
(
Services
.
prefs
.
getStringPref
(
"
places
.
interactions
.
customBlocklist
"
"
[
]
"
)
)
;
if
(
!
Array
.
isArray
(
customBlocklist
)
)
{
throw
new
Error
(
)
;
}
let
parsedBlocklist
=
customBlocklist
.
map
(
regexStr
=
>
new
RegExp
(
regexStr
)
)
;
HOST_BLOCKLIST
[
"
*
"
]
=
parsedBlocklist
;
}
catch
(
ex
)
{
lazy
.
logConsole
.
warn
(
"
places
.
interactions
.
customBlocklist
is
corrupted
.
"
)
;
}
}
get
urlRequirements
(
)
{
return
new
Map
(
[
[
"
http
:
"
{
}
]
[
"
https
:
"
{
}
]
[
"
file
:
"
{
extension
:
"
pdf
"
}
]
]
)
;
}
canRecordUrl
(
url
)
{
let
protocol
pathname
;
if
(
typeof
url
=
=
"
string
"
)
{
url
=
new
URL
(
url
)
;
}
if
(
url
instanceof
Ci
.
nsIURI
)
{
protocol
=
url
.
scheme
+
"
:
"
;
pathname
=
url
.
filePath
;
}
else
{
protocol
=
url
.
protocol
;
pathname
=
url
.
pathname
;
}
let
requirements
=
InteractionsBlocklist
.
urlRequirements
.
get
(
protocol
)
;
return
(
requirements
&
&
(
!
requirements
.
extension
|
|
pathname
.
endsWith
(
requirements
.
extension
)
)
)
;
}
isUrlBlocklisted
(
urlToCheck
)
{
if
(
lazy
.
FilterAdult
.
isAdultUrl
(
urlToCheck
)
)
{
return
true
;
}
if
(
!
this
.
canRecordUrl
(
urlToCheck
)
)
{
return
true
;
}
let
url
;
try
{
url
=
new
URL
(
urlToCheck
)
;
if
(
!
url
)
{
throw
new
Error
(
)
;
}
}
catch
(
ex
)
{
lazy
.
logConsole
.
warn
(
Invalid
URL
passed
to
InteractionsBlocklist
.
isUrlBlocklisted
:
{
url
}
)
;
return
false
;
}
if
(
url
.
protocol
=
=
"
file
:
"
)
{
return
false
;
}
let
hostWithoutSuffix
=
lazy
.
UrlbarUtils
.
stripPublicSuffixFromHost
(
url
.
host
)
;
let
[
hostWithSubdomains
]
=
lazy
.
UrlbarUtils
.
stripPrefixAndTrim
(
hostWithoutSuffix
{
stripWww
:
true
trimTrailingDot
:
true
}
)
;
let
baseHost
=
hostWithSubdomains
.
substring
(
hostWithSubdomains
.
lastIndexOf
(
"
.
"
)
+
1
)
;
let
regexes
=
HOST_BLOCKLIST
[
baseHost
.
toLocaleLowerCase
(
)
]
|
|
[
]
;
regexes
.
push
(
.
.
.
(
HOST_BLOCKLIST
[
"
*
"
]
|
|
[
]
)
)
;
if
(
!
regexes
)
{
return
false
;
}
return
regexes
.
some
(
r
=
>
r
.
test
(
url
.
href
)
)
;
}
addRegexToBlocklist
(
regexToAdd
)
{
let
regex
;
try
{
regex
=
new
RegExp
(
regexToAdd
"
i
"
)
;
}
catch
(
ex
)
{
this
.
logConsole
.
warn
(
"
Invalid
regex
passed
to
addRegexToBlocklist
.
"
)
;
return
;
}
if
(
!
HOST_BLOCKLIST
[
"
*
"
]
)
{
HOST_BLOCKLIST
[
"
*
"
]
=
[
]
;
}
HOST_BLOCKLIST
[
"
*
"
]
.
push
(
regex
)
;
Services
.
prefs
.
setStringPref
(
"
places
.
interactions
.
customBlocklist
"
JSON
.
stringify
(
HOST_BLOCKLIST
[
"
*
"
]
.
map
(
reg
=
>
reg
.
toString
(
)
)
)
)
;
}
removeRegexFromBlocklist
(
regexToRemove
)
{
let
regex
;
try
{
regex
=
new
RegExp
(
regexToRemove
"
i
"
)
;
}
catch
(
ex
)
{
this
.
logConsole
.
warn
(
"
Invalid
regex
passed
to
addRegexToBlocklist
.
"
)
;
return
;
}
if
(
!
HOST_BLOCKLIST
[
"
*
"
]
|
|
!
Array
.
isArray
(
HOST_BLOCKLIST
[
"
*
"
]
)
)
{
return
;
}
HOST_BLOCKLIST
[
"
*
"
]
=
HOST_BLOCKLIST
[
"
*
"
]
.
filter
(
curr
=
>
curr
.
source
!
=
regex
.
source
)
;
Services
.
prefs
.
setStringPref
(
"
places
.
interactions
.
customBlocklist
"
JSON
.
stringify
(
HOST_BLOCKLIST
[
"
*
"
]
.
map
(
reg
=
>
reg
.
toString
(
)
)
)
)
;
}
}
const
InteractionsBlocklist
=
new
_InteractionsBlocklist
(
)
;
