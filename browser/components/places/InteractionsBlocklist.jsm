"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
InteractionsBlocklist
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
UrlbarUtils
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
logConsole
"
function
(
)
{
return
console
.
createInstance
(
{
prefix
:
"
InteractionsBlocklist
"
maxLogLevel
:
Services
.
prefs
.
getBoolPref
(
"
browser
.
places
.
interactions
.
log
"
false
)
?
"
Debug
"
:
"
Warn
"
}
)
;
}
)
;
let
HOST_BLOCKLIST
=
{
baidu
:
[
"
^
(
https
?
:
\
\
/
\
\
/
)
?
(
www
\
\
.
)
?
baidu
\
\
.
com
\
\
/
s
.
*
(
\
\
?
|
&
)
wd
=
.
*
"
]
bing
:
[
"
^
(
https
?
:
\
\
/
\
\
/
)
?
(
www
\
\
.
)
?
bing
\
\
.
com
\
\
/
search
.
*
(
\
\
?
|
&
)
q
=
.
*
"
]
duckduckgo
:
[
"
^
(
https
?
:
\
\
/
\
\
/
)
?
(
www
\
\
.
)
?
duckduckgo
\
\
.
com
\
\
/
.
*
(
\
\
?
|
&
)
q
=
.
*
"
]
example
:
[
"
^
(
https
?
:
\
\
/
\
\
/
)
?
example
\
\
.
com
\
\
/
browser
"
]
google
:
[
"
^
(
https
?
:
\
\
/
\
\
/
)
?
(
www
\
\
.
)
?
google
\
\
.
(
\
\
w
|
\
\
.
)
{
2
}
\
\
/
search
.
*
(
\
\
?
|
&
)
q
=
.
*
"
]
yandex
:
[
"
^
(
https
?
:
\
\
/
\
\
/
)
?
(
www
\
\
.
)
?
yandex
\
\
.
(
\
\
w
|
\
\
.
)
{
2
}
\
\
/
search
.
*
(
\
\
?
|
&
)
text
=
.
*
"
]
zoom
:
[
"
^
(
https
?
:
\
\
/
\
\
/
)
?
(
www
\
\
.
)
?
.
*
\
\
.
zoom
\
\
.
us
\
\
/
j
\
\
/
\
\
d
+
"
]
}
;
HOST_BLOCKLIST
=
new
Proxy
(
HOST_BLOCKLIST
{
get
(
target
property
)
{
let
regexes
=
target
[
property
]
;
if
(
!
regexes
|
|
!
Array
.
isArray
(
regexes
)
)
{
return
null
;
}
for
(
let
i
=
0
;
i
<
regexes
.
length
;
i
+
+
)
{
let
regex
=
regexes
[
i
]
;
if
(
typeof
regex
=
=
=
"
string
"
)
{
regex
=
new
RegExp
(
regex
"
i
"
)
;
if
(
regex
)
{
regexes
[
i
]
=
regex
;
}
else
{
throw
new
Error
(
"
Blocklist
contains
invalid
regex
.
"
)
;
}
}
}
return
regexes
;
}
}
)
;
class
_InteractionsBlocklist
{
isUrlBlocklisted
(
urlToCheck
)
{
let
url
;
try
{
url
=
new
URL
(
urlToCheck
)
;
if
(
!
url
)
{
throw
new
Error
(
)
;
}
}
catch
(
ex
)
{
logConsole
.
warn
(
Invalid
URL
passed
to
InteractionsBlocklist
.
isUrlBlocklisted
:
{
url
}
)
;
return
false
;
}
let
hostWithoutSuffix
=
UrlbarUtils
.
stripPublicSuffixFromHost
(
url
.
host
)
;
let
[
hostWithSubdomains
]
=
UrlbarUtils
.
stripPrefixAndTrim
(
hostWithoutSuffix
{
stripWww
:
true
trimTrailingDot
:
true
}
)
;
let
baseHost
=
hostWithSubdomains
.
substring
(
hostWithSubdomains
.
lastIndexOf
(
"
.
"
)
+
1
)
;
let
regexes
=
HOST_BLOCKLIST
[
baseHost
.
toLocaleLowerCase
(
)
]
;
if
(
!
regexes
)
{
return
false
;
}
return
regexes
.
some
(
r
=
>
r
.
test
(
url
.
href
)
)
;
}
}
const
InteractionsBlocklist
=
new
_InteractionsBlocklist
(
)
;
